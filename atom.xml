<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[It so life]]></title>
  <subtitle><![CDATA[love as life]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://itsolife.com/"/>
  <updated>2014-03-15T09:46:52.172Z</updated>
  <id>http://itsolife.com/</id>
  
  <author>
    <name><![CDATA[RobinChia]]></name>
    <email><![CDATA[arcticchia at gmail.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[将Hadoop源码转作eclipse工程]]></title>
    <link href="http://itsolife.com/2014/03/15/%E5%B0%86hadoop%E6%BA%90%E7%A0%81%E8%BD%AC%E4%BD%9Ceclipse%E5%B7%A5%E7%A8%8B/"/>
    <id>http://itsolife.com/2014/03/15/将hadoop源码转作eclipse工程/</id>
    <published>2014-03-15T03:51:49.000Z</published>
    <updated>2014-03-15T04:21:46.000Z</updated>
    <content type="html"><![CDATA[<h1 id="-hadoop-eclipse-">将Hadoop源码转作eclipse工程</h1>
<p>下载hadoop源码，可以从官网hadoop.apache.org,或者通过命令：<br>git clone git://git.apache.org/hadoop-common.git</p>
<p>我下载的是hadoop2.2.0版。</p>
<p>需要maven（安装及配置方法略）来进行编译：<br>$ mvn install -DskipTests$ mvn eclipse:eclipse -DdownloadSources=true -DdownloadJavadocs=true</p>
<p>接下来可以进行导入了：
选择File中的import...</p>
<p>要说明的是，导入的项目中有无效的引入（有个conf文件夹），可以去掉即可。还有缺少的类（主要是test文件夹中的），可以从对应的项目源码文件中target的对应目录中拷贝过去即可。</p>
<p>现在开始浏览hadoop源码了：）</p>
]]></content>
    
    
      <category term="hadoop" scheme="http://itsolife.com/tags/hadoop/"/>
    
      <category term="hadoop" scheme="http://itsolife.com/categories/hadoop/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CentOS 6 支持HFS Plus]]></title>
    <link href="http://itsolife.com/2014/03/11/centos-6-%E6%94%AF%E6%8C%81hfs-plus/"/>
    <id>http://itsolife.com/2014/03/11/centos-6-支持hfs-plus/</id>
    <published>2014-03-11T06:41:52.000Z</published>
    <updated>2014-03-11T07:26:58.000Z</updated>
    <content type="html"><![CDATA[<p>默认的CentOS6或Redhat6是不支持HFS Plus格式的。</p>
<blockquote>
<p>不过支持的话，也很简单。</p>
</blockquote>
<p>首先安装源：</p>
<blockquote>
<p>1、rpm --import <a href="http://elrepo.org/RPM-GPG-KEY-elrepo.org" target="_blank">http://elrepo.org/RPM-GPG-KEY-elrepo.org</a>
2、rpm -Uvh <a href="http://elrepo.org/elrepo-release-6-4.el6.elrepo.noarch.rpm" target="_blank">http://elrepo.org/elrepo-release-6-4.el6.elrepo.noarch.rpm</a>
如果你已经有了，那就可以忽略上一步。
接下来：
yum install kmod-hfsplus</p>
</blockquote>
<p>Ok，插上硬盘看看吧：）</p>
]]></content>
    
    
  </entry>
  
  <entry>
    <title><![CDATA[编程的首要原则是什么？]]></title>
    <link href="http://itsolife.com/2014/02/03/2014-02-03--%E7%BC%96%E7%A8%8B%E7%9A%84%E9%A6%96%E8%A6%81%E5%8E%9F%E5%88%99%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <id>http://itsolife.com/2014/02/03/2014-02-03--编程的首要原则是什么/</id>
    <published>2014-02-03T03:24:30.000Z</published>
    <updated>2014-03-08T01:12:48.000Z</updated>
    <content type="html"><![CDATA[<h1 id="-">编程的首要原则是什么？</h1>
<p>半年前，JoelOnSoftware和CodingHorror合搞的stackoverflow.com刚上线不久，我兴冲冲地跑过去扔了一个问题：</p>
<p><strong>你们认为编程的首要原则是什么？</strong></p>
<p>作为我的<a href="http://mindhacks.cn/2008/07/08/learning-habits-part1/" target="_blank">学习原则</a>的一个实践：</p>
<ol>
<li>学习一项知识，必须问自己三个重要问题：1. 它的本质是什么。2. 它的第一原则是什么。3. 它的知识结构是怎样的。</li>
</ol>
<p>5个月过去了，这个问题到现在还有人回复，我得到了一大堆有意思的答案，忍不住翻译过来与大家分享：</p>
<ol>
<li>获得<strong>最多认同的答案</strong>：
<strong>KISS – Keep It Simple Stupid</strong></li>
</ol>
<p><strong>DRY – Don’t Repeat Yourself</strong></p>
<p>一点不感到意外吧？</p>
<p>注：DRY原则倒是比较好理解和实践的。但KISS原则则是看上去直白，其实实践起来不那么容易的一个原则，因为simple和stupid的定义并不是每个人、在每个场景下都是一致且明显的，一个人的simple可能是另一个人的stupid，一个人的stupid可能是另一个人的unnecessary。一旦一个标准取决于具体场景，事情就不那么简单了。所以我们经常要说“<a href="http://c2.com/cgi/wiki?ItDepends" target="_blank">It depends</a>”。</p>
<ol>
<li>获得<strong>第二认同的答案</strong>：
<strong>写代码时时刻设想你就是将来要来维护这坨代码的人。</strong></li>
</ol>
<p>在这个答案后面有人添加到：</p>
<p>最好设想你的代码会被一个挥着斧头的精神病来维护。</p>
<p>有人接着又YY道：</p>
<p>而且这个挥着斧头的精神病还知道你住在哪儿。 (( 事实上后面有人指出这是 Martin Golding 的一句名言 ))</p>
<p>注：其实这个原则在设计API时也有用：</p>
<p><strong>写API时时刻设想你就是要去使用这坨API的人。</strong></p>
<ol>
<li><strong>一些众所不一定周知的答案</strong>：</li>
</ol>
<p><strong>先弄清你的问题是什么！</strong></p>
<p><a href="http://www.douban.com/subject/1135754/" target="_blank">弄清问题</a>永远是问题解决过程中的第一步和最重要的一步。</p>
<p><strong>代码只是工具，不是手段。</strong></p>
<p>不知道怎么最好地解决你手头的问题（注：需求、架构、算法，技术选型，etc..），写上一万坨代码也是浪费比特。</p>
<p><strong>知道什么时候不该编码</strong>。</p>
<p>（类似条目：YAGNI——“你并不需要编写这坨代码！”，针对你的需求编码，“写你所需”，别做“聪明事”，为一个不确定的未来编码。同时也注意模块化设计，以便能在未来新增需求时无痛扩充系统）</p>
<p><strong>永远不要假定你已经了解一切了！</strong></p>
<p><strong>不作没有证据的推论。</strong></p>
<p><strong>想清楚了再编写</strong>。类似条目：<strong>如果方案在你脑子里面或者纸上不能工作，写成代码还是不能工作。</strong></p>
<ol>
<li>一些众所很可能周知的答案：</li>
</ol>
<p>越懒越好。</p>
<p>过早优化是一切罪恶的根源。</p>
<p>不要重新发明轮子。</p>
<p>测试通过前说什么“它可以工作”都是纯扯淡。</p>
<p>了解你的工具。</p>
<p>一切以用户需求为导向。</p>
<p>利用分治、抽象，解开子问题之间的耦合。</p>
<ol>
<li><strong>最幽默的答案</strong>：</li>
</ol>
<p><strong>咖啡进，代码出</strong>。（Coffee in, Code out） (( 参见 <a href="http://en.wikipedia.org/wiki/Garbage_in,_garbage_out" target="_blank">Garbage in, Garbage out</a>. ))</p>
<p>最后，整个问题的 thread 在<a href="http://stackoverflow.com/questions/159176" target="_blank">这里</a>。
<strong>Tags:</strong> <a href="http://mindhacks.cn/tags/%e7%bc%96%e7%a8%8b/" target="_blank">编程</a></p>
<p><a href="http://mindhacks.cn/author/pongba/"></a></p>
]]></content>
    
    
      <category term="好文摘录" scheme="http://itsolife.com/categories/%E5%A5%BD%E6%96%87%E6%91%98%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何清晰地思考：近一年来业余阅读的关于思维方面的知识结构整理]]></title>
    <link href="http://itsolife.com/2014/02/03/2014-02-03--%E5%A6%82%E4%BD%95%E6%B8%85%E6%99%B0%E5%9C%B0%E6%80%9D%E8%80%83%EF%BC%9A%E8%BF%91%E4%B8%80%E5%B9%B4%E6%9D%A5%E4%B8%9A%E4%BD%99%E9%98%85%E8%AF%BB%E7%9A%84%E5%85%B3%E4%BA%8E%E6%80%9D%E7%BB%B4%E6%96%B9%E9%9D%A2%E7%9A%84%E7%9F%A5%E8%AF%86%E7%BB%93%E6%9E%84%E6%95%B4%E7%90%86/"/>
    <id>http://itsolife.com/2014/02/03/2014-02-03--如何清晰地思考：近一年来业余阅读的关于思维方面的知识结构整理/</id>
    <published>2014-02-03T03:24:30.000Z</published>
    <updated>2014-03-08T01:16:07.000Z</updated>
    <content type="html"><![CDATA[<h1 id="-">如何清晰地思考：近一年来业余阅读的关于思维方面的知识结构整理</h1>
<p>By 刘未鹏(pongba) 
C++ 的罗浮宫(<a href="http://blog.csdn.net/pongba" target="_blank"><a href="http://blog.csdn.net/pongba">http://blog.csdn.net/pongba</a></a>) 
TopLanguage(<a href="https://groups.google.com/group/pongba" title="https://groups.google.com/group/pongba" target="_blank"><a href="https://groups.google.com/group/pongba">https://groups.google.com/group/pongba</a></a>)</p>
<p>一年前一个偶然的机会我遇到了一本书——《影响力》，看完这本书之后对<strong>我们如何思维</strong>产生了极大的兴趣，于是在一年的时间里面密集地阅读了以下一些方面的经典著作：<strong>社会心理学、认知科学、神经科学、进化心理学、行为经济学、机器学习、人工智能、自然语言处理、问题求解、辩论法（Argumentation Theory）、Critical Thinking、判断与决策。以及大量的 Wikipedia 条目。</strong></p>
<p><strong>这一年来，对以上这些领域的阅读和思考给我带来了极大的价值，我相信他们也会给你带来巨大的收益。</strong></p>
<p>关于为什么我认为我们都需要学习这方面的知识，我曾在博客中写到：
另外还有一些我认为是 essential knowledge 的例子：分析问题解决问题的思维方法（这个东西很难读一两本书就掌握，需要很长时间的锻炼和反思）、判断与决策的方法（生活中需要进行判断与决策的地方远远多于我们的想象），波普尔曾经说过：All Life is Problem-Solving。而判断与决策又是其中最常见的一类Problem Solving。尽管生活中面临重大决策的时候并不多，但另一方面我们时时刻刻都在进行最重大的决策：如：决定自己的日常时间到底投入到什么地方去。如：你能想象有人宁可天天花时间剪报纸上的优惠券，却对于房价的1%的优惠无动于衷吗？（《别做正常的傻瓜》、《Predictably Irrational》）如：你知道为什么当手头股票的股价不可抑止地滑向深渊时我们却一边揪着头发一边愣是不肯撤出吗？（是的，我们适应远古时代的心理机制根本不适应金融市场。）糟糕的判断与决策令我们的生活变得糟糕，这还不是最关键的，最关键的是我们从来不会去质疑自己的判断，而是总是能“找到”其他为自己辩护的理由（《错不在我（Mistakes were made, but not by me）》）又，现在是一个信息泛滥的时代，于是另一个问题也出现：如何在海洋中有效筛选好的信息，以及避免被不好的信息左右我们的大脑（<a href="http://en.wikipedia.org/wiki/Critical_thinking" target="_blank">Critical Thinking</a>）关于以上提到的几点我在豆瓣上有一个专门的豆列（“<a href="http://www.douban.com/doulist/127649/" target="_blank">学会思考</a>”），希望有一天我能够积累出足够多的认识对这个主题展开一些详细介绍。</p>
<p>人类的大脑和思维是目前已知最为复杂的系统，对这个系统的研究不仅自身是一件极其迷人的事情，对于像我们这样的芸芸众生来说<strong>即便不去做研究，学习一些这方面的科普知识，对于学会正确地思考有极大的益处。</strong></p>
<p><strong>你的大脑是你唯一的工具，要正确利用这个工具，唯一的途径就是去了解它。</strong>与很多人的直觉相反，实际上我们的思维有着各种各样的缺陷和陷阱（keyword: <a href="http://en.wikipedia.org/wiki/Cognitive_bias" target="_blank">cognitive bias</a>），我们解决日常问题的思维方式也并不总是最优的（keyword: <a href="http://en.wikipedia.org/wiki/Bounded_rationality" target="_blank">bounded rationality</a>），这里摘抄一段我在豆列上的导言：
我们的思维有很多很多的弱点，我一向认为，正确的思维方式，是一切高效学习的基础。比如参见如下2个例子，错误的思维方式得到的结论有大得多的可能性是谬误。</p>
<ul>
<li>人总喜欢沿袭以往习得的经验，并通过类比来进行外推。我第一次在一个地铁终点站坐地铁的时候，看着从远方开来的地铁，我心生疑惑——“这车每节车厢都这么长，待会怎么调头呢（我心说没看到铁轨终点有一个大大的供调头的 U 形弯啊）？”，当车开始开的时候我终于意识到原来车是可以往两头方向开的。</li>
<li>人喜欢从关联当中寻找因果，有一次我我老婆去银行取款，到了 ATM 室的自动门口，我开玩笑地拿着手头的饭卡去刷了一下，然后——门居然开了。我顿时来了劲，立即得出一个结论：这个刷卡装置不安全，至少不是能够专门识别银联的卡的。我甚至飞快地泛化出了一个更具一般性的理论来解释这个现象：即可能所有带有磁性的卡都可以用来开门。老婆看我得意洋洋，就泼过来一盘冷水：不一定是你的卡刷开的啊，你不刷卡试试看。我不信，说怎么可能呢，心想我刷卡，门就开了，还有比这更明显的因果关系嘛。但出乎我意料的是，我走出门，这次没刷卡，门也开了——原来是感应门——原先这个 ATM 室的确是刷卡门，但后来改成了感应门，刷卡的那个装置只不过没拆掉残留在那里而已。</li>
</ul>
<p>总的来说</p>
<ul>
<li>人类的思维充满着各种各样的捷径，每一条捷径都是一把双刃剑。一方面，它降低了大脑的认知复杂性（笼统的看一个问题要比细致的分析简单得多），有助于迅速做出绝大部分时候都正确的判断；但另一方面，它也常常导致人们把大部分情况下成立的法则当成了放之四海而皆准的。可以说，有多少捷径，就有多少条谬误。</li>
<li>人类的情绪也在很大程度上影响着人的思考。比如，如果你憎恶一个人，你往往就会反对他的所有立场。反之亦成立。</li>
<li>人类大脑经过长时间的进化，先天就具备一些特定的“思维定势”，以使得人类能够在面对进化过程中经常出现的适应性问题时能够不假思索的做出迅速的反应。然而，在现代社会，这类思维定势已经不适应了。</li>
<li>人类不可避免的受着各种各样的偏见的影响，这些偏见有些是有一定适应价值的“思维定势”（如事后聪明式偏见），而有些则是大脑的认知机制的“缺陷”。</li>
</ul>
<p>以上，构成了人类思维中的种种谬误。而学会思考，就是学会认识到这些谬误。</p>
<p>Critical-Thinking 在西方拥有悠久的历史，早到古希腊时代，亚里士多德就已经对人类语言中的各种各样的谬误有了一定的认识（譬如，“我们无法讨论不存在的东西，所以所有的事物都是真实的”），并对辩论之中存在的各种各样的谬误进行了归类。然而令人遗憾的是，在中国的文化里面，理性思维似乎是一直被抑制的，中国文人传统都是非理性思考者；所谓非理性思考，主要包括联想、比方等形式，这些思维方式作为人类天生具有的思维方式的一种，一方面当然有它的好处（比如在科研方面，联想往往能够启发新思路；类比也有助于用新颖的方式来解决既有问题），然而另一方面，这样的思维方式同样也充满了各种各样致命的谬误。在大众知识领域，自中国古代文人思维习惯流传下来的影响深刻地左右着人们的语言习惯，随处可见的不靠谱的类比和文字游戏就是证明（例如，严格来说，类比的一般形式是，A具有X、Y、Z三个属性，B具有X、Y属性（类似于A），所以B具有Z属性。这个类比要成立，必须要满足一个前提，即X、Y属性对于Z属性的有无必须是有关的。然而这个前提被根本忽视了，详见 <a href="http://en.wikipedia.org/wiki/False_analogy" target="_blank">False Analogy</a>）。</p>
<p>这个豆列中的书，有一些是介绍人类思维工作的机制的，认识这些机制是正确思考的大前提；有许多是关于人类推理（Reasoning）过程中的形形色色的谬误的，因为唯有认识到 这些谬误，才能避免它们。唯有避免了思维的谬误，才能进行正确的思考。</p>
<p>注：</p>
<ul>
<li>一个最完整的认知偏见（cognitive bias）列表见：<a href="http://en.wikipedia.org/wiki/List_of_cognitive_biases" target="_blank"><a href="http://en.wikipedia.org/wiki/List_of_cognitive_biases">http://en.wikipedia.org/wiki/List_of_cognitive_biases</a></a></li>
<li>一个完整的 Fallacies 列表见： <a href="http://en.wikipedia.org/wiki/Fallacies" target="_blank"><a href="http://en.wikipedia.org/wiki/Fallacies">http://en.wikipedia.org/wiki/Fallacies</a></a></li>
<li>Wikipedia 上关于 Critical Thinking 的条目见：<a href="http://en.wikipedia.org/wiki/Critical_thinking" target="_blank"><a href="http://en.wikipedia.org/wiki/Critical_thinking">http://en.wikipedia.org/wiki/Critical_thinking</a></a></li>
</ul>
<p>另：</p>
<ul>
<li>人类在思考问题的过程中，自身的思维习惯、性格、知识积累无不都在悄悄地影响着思维的过程，所以，一些心理学的知识也非常有助于帮助正确的思考。更多心理学方面的推荐，参考：<a href="http://www.douban.com/doulist/46003/" target="_blank"><a href="http://www.douban.com/doulist/46003/">http://www.douban.com/doulist/46003/</a></a></li>
</ul>
<p><strong>文章末尾将贴出的是我这一年来学习的知识结构总揽（用 </strong><a href="http://www.xmind.net/" target="_blank">XMind</a><strong> 画的思维导图）</strong>。注：这只是一个整体的知识结构，或者说“寻路图”，其中固然包含一些例子（用 “e.g.” 标出），但<strong>最重要的是从各个分支引申出去的延伸阅读</strong>，后者<strong>包含上百个很有价值的 wikipedia 条目，不下 50 本经典的著作</strong>（大部分我已经读过，小部分经过我的仔细考察，正在阅读中或者肯定是有价值的）。</p>
<p>如何<strong>获得这些延伸出去的阅读</strong>，有两个办法：</p>
<ol>
<li><strong>在总揽图中抽出关键字到 Wikipedia&amp;Google 上查找</strong>，如：<a href="http://en.wikipedia.org/wiki/Informal_fallacy" target="_blank">informal fallacy</a>，<a href="http://en.wikipedia.org/wiki/Cognitive_biases" target="_blank">cognitive biases</a>, <a href="http://en.wikipedia.org/wiki/Bounded_rationality" target="_blank">bounded rationality</a>, <a href="http://en.wikipedia.org/wiki/Critical_thinking" target="_blank">critical thinking</a>, <a href="http://en.wikipedia.org/wiki/Argumentation_theory" target="_blank">argumentation theory</a>, <a href="http://en.wikipedia.org/wiki/Behavioral_economics" target="_blank">behavioral economics</a>,<a href="http://en.wikipedia.org/wiki/Problem_solving" target="_blank">problem solving</a> 等等（以上这些关键字你都会在思维导图中看到）。注：<strong>阅读 Wikipedia 时要严重注意每个条目后面的 Reference ，一般来说这些参考资料本身也都非常经典，其价值不亚于 Wikipedia 条目本身。</strong></li>
<li><strong>查看我整理的四个豆列：</strong></li>
</ol>
<ul>
<li><a href="http://www.douban.com/doulist/46003/" target="_blank"><strong>【只读经典】心理学改变生活</strong></a></li>
<li><a href="http://www.douban.com/doulist/127649/" target="_blank"><strong>【只读经典】学会思考</strong></a></li>
<li><a href="http://www.douban.com/doulist/197706/" target="_blank"><strong>【只读经典】判断与决策</strong></a></li>
<li><a href="http://www.douban.com/doulist/176513/" target="_blank">机器学习与人工智能学习资源导引</a></li>
</ul>
<p>以上四个豆列中整理的绝大多数都是我阅读过的，你也可以参考我的整个<a href="http://www.douban.com/people/pongba/booktags/%E6%80%9D%E7%BB%B4" target="_blank">“思维”标签下的书</a>。如何获得这些书（尤其是其中包含大量的无中文翻译版的英文书）请参考李笑来老师的<a href="http://www.xiaolai.net/index.php/archives/1607.html" target="_blank">笔记</a>。</p>
<p>这个领域的新知识是如此的纷至沓来，以至于我只有时间不断地阅读和思考，以及不时在我的 Google Notebook 里做一些笔记，而完全没有时间一本书一本书，一个子领域一个子领域地写具体的 Introduction （目前具体的荐书只是在 TopLanguage 上<a href="https://groups.google.com/group/pongba/search?group=pongba&amp;q=%E8%8D%90%E4%B9%A6&amp;qt_g=Search+this+group" target="_blank">零散的推荐了几本</a>，还没有专题介绍）。既便如此，仍然还是在博客上写了很多相关的东西，它们就是这一年来的学习的收获的证明:-)，因此<strong>如果你想快速判断上面列出的一些书籍是否对你有价值，有多大的价值，不妨参考一下我写的这些文章，这些文章很大程度上是在这一年的学习过程当中的感悟或总结。注：第 3 部分（关于学习、记忆与思考）的文章基本上是领域无关的：</strong></p>
<ol>
<li><strong>关于 Problem Solving 的</strong></li>
</ol>
<ul>
<li><a href="http://blog.csdn.net/pongba/archive/2008/04/18/2302905.aspx" target="_blank">《跟波利亚学解题》</a></li>
<li><a href="http://blog.csdn.net/pongba/archive/2008/07/07/2622713.aspx" target="_blank">《知其所以然地学习（以算法学习为例）》</a></li>
<li><p><strong>关于机器学习的</strong>（机器学习和人工智能领域对于理解我们的思维方式也提供了极好的参考）</p>
</li>
<li><p><a href="http://blog.csdn.net/pongba/archive/2008/09/21/2958094.aspx" target="_blank">《数学之美番外篇：平凡而又神奇的贝叶斯方法》</a></p>
</li>
<li><a href="http://blog.csdn.net/pongba/archive/2008/09/11/2915005.aspx" target="_blank">《机器学习与人工智能学习资源导引》</a></li>
<li><p><strong>关于学习、记忆与思考的</strong></p>
</li>
<li><p>《一直以来伴随我的一些学习习惯》（<a href="http://blog.csdn.net/pongba/archive/2008/07/08/2625115.aspx" target="_blank">一</a>，<a href="http://blog.csdn.net/pongba/archive/2008/07/20/2681668.aspx" target="_blank">二</a>，<a href="http://blog.csdn.net/pongba/archive/2008/09/17/2942482.aspx" target="_blank">三</a>，<a href="http://blog.csdn.net/pongba/archive/2008/12/05/3456240.aspx" target="_blank">四</a>）</p>
</li>
<li><a href="http://blog.csdn.net/pongba/archive/2008/10/29/3176250.aspx" target="_blank">《方法论、方法论——程序员的阿喀琉斯之踵》</a></li>
<li><a href="http://blog.csdn.net/pongba/archive/2008/06/05/2513263.aspx" target="_blank">《学习与记忆》</a></li>
<li><a href="http://blog.csdn.net/pongba/archive/2008/04/08/2260812.aspx" target="_blank">《阅读与思考》</a></li>
<li><a href="http://blog.csdn.net/pongba/archive/2008/01/04/2025830.aspx" target="_blank">《鱼是最后一个看到水的》</a></li>
<li><a href="http://blog.csdn.net/pongba/archive/2007/06/24/1664597.aspx" target="_blank">《我不想与我不能》</a></li>
<li><a href="http://blog.csdn.net/pongba/archive/2007/05/24/1624382.aspx" target="_blank">《学习密度与专注力》</a></li>
</ul>
<p>好在我并不打算零星的一本一本推荐:D 所以我就花了点时间将整个的知识体系整理了一番，画了下面这张结构图，请按图索骥，如下（有三个版本，1. 至 xMind Share 的超链接，2. 内嵌在该页面中的幻灯片，如果无法载入请参考 1 。3. 图片版（注：图很大，请下载浏览或打印））</p>
<p>我在前面写学习习惯的时候曾经提到：</p>
<ol>
<li>学习一项知识，必须问自己三个重要问题：1. 它的本质是什么。2. 它的第一原则是什么。3. 它的知识结构是怎样的。</li>
</ol>
<p>有朋友问我具体的例子，好吧，那么这张思维导图便是第三点——知识结构——的一个很好的例子:)</p>
<ol>
<li><p>至 XMind Share 的超链接：<a href="http://share.xmind.net/pongba/how-to-think-straight-4/" title="http://share.xmind.net/pongba/how-to-think-straight-4/" target="_blank"><a href="http://share.xmind.net/pongba/how-to-think-straight-4/">http://share.xmind.net/pongba/how-to-think-straight-4/</a></a></p>
</li>
<li><p>嵌入的幻灯片（如加载失败请直接点击上面的 XMind Share 超链接至 XMind 浏览）：</p>
</li>
<li><p>图片版（此为缩略版，完整版请至相册下载：<a href="http://picasaweb.google.com/lh/photo/fdo1gXHiHIoc1hVQfSAwpA" target="_blank">google picasa 的</a> ，或 <a href="http://album.hi.csdn.net/app_uploads/pongba/20081218/134153046.png" target="_blank">csdn 相册的</a>）（<strong>最后提醒一下，别忘了这幅图只是大量书籍和 Wikipedia 条目的“藏宝图”，如何延伸阅读请参考前文所述的方法</strong>）
<a href="http://picasaweb.google.com/lh/photo/fdo1gXHiHIoc1hVQfSAwpA" target="_blank"><img src="" alt=""></a> From <a href="http://picasaweb.google.com/pongba/XMind" target="_blank">XMind</a></p>
</li>
</ol>
<hr>
<p>消息：<a href="https://groups.google.com/group/pongba" target="_blank">TopLanguage</a> 最近经历了一次很大的管理策略修订，可以预期将彻底摆脱这两个月来的噪音问题，未来的讨论质量将会越来越高。详情可参见<a href="https://groups.google.com/group/pongba/t/43e13ca082c07d16" target="_blank">这里</a>。
来源： <a href="[http://blog.csdn.net/pongba/article/details/3549560](http://blog.csdn.net/pongba/article/details/3549560)">[http://blog.csdn.net/pongba/article/details/3549560](http://blog.csdn.net/pongba/article/details/3549560)</a> </p>
]]></content>
    
    
      <category term="好文摘录" scheme="http://itsolife.com/categories/%E5%A5%BD%E6%96%87%E6%91%98%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何清晰地思考：近一年来业余阅读的关于思维方面的知识结构整理（附大幅思维导图）]]></title>
    <link href="http://itsolife.com/2014/02/03/2014-02-03--%E5%A6%82%E4%BD%95%E6%B8%85%E6%99%B0%E5%9C%B0%E6%80%9D%E8%80%83%EF%BC%9A%E8%BF%91%E4%B8%80%E5%B9%B4%E6%9D%A5%E4%B8%9A%E4%BD%99%E9%98%85%E8%AF%BB%E7%9A%84%E5%85%B3%E4%BA%8E%E6%80%9D%E7%BB%B4%E6%96%B9%E9%9D%A2%E7%9A%84%E7%9F%A5%E8%AF%86%E7%BB%93%E6%9E%84%E6%95%B4%E7%90%86%EF%BC%88%E9%99%84%E5%A4%A7%E5%B9%85%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%EF%BC%89/"/>
    <id>http://itsolife.com/2014/02/03/2014-02-03--如何清晰地思考：近一年来业余阅读的关于思维方面的知识结构整理（附大幅思维导图）/</id>
    <published>2014-02-03T03:24:30.000Z</published>
    <updated>2014-03-07T03:33:11.000Z</updated>
    <content type="html"><![CDATA[<h1 id="-">如何清晰地思考：近一年来业余阅读的关于思维方面的知识结构整理（附大幅思维导图）</h1>
<p>分类： <a href="http://blog.csdn.net/pongba/article/category/43902" target="_blank">片面思考</a>  2008-12-18 14:15 136352人阅读 <a href="">评论</a>(45) <a href="&quot;收藏&quot;">收藏</a> <a href="&quot;举报&quot;">举报</a>
<a href="http://blog.csdn.net/tag/details.html?tag=%e8%87%aa%e7%84%b6%e8%af%ad%e8%a8%80%e5%a4%84%e7%90%86" target="_blank">自然语言处理</a><a href="http://blog.csdn.net/tag/details.html?tag=%e7%94%9f%e6%b4%bb" target="_blank">生活</a><a href="http://blog.csdn.net/tag/details.html?tag=reference" target="_blank">reference</a><a href="http://blog.csdn.net/tag/details.html?tag=%e7%9b%b8%e5%86%8c" target="_blank">相册</a><a href="http://blog.csdn.net/tag/details.html?tag=google" target="_blank">google</a><a href="http://blog.csdn.net/tag/details.html?tag=%e8%81%94%e6%83%b3" target="_blank">联想</a></p>
<p><strong>如何清晰地思考：近一年来业余阅读的关于思维方面的知识结构整理（附大幅思维导图）</strong></p>
<p>By 刘未鹏(pongba)
C++ 的罗浮宫(<a href="http://blog.csdn.net/pongba" target="_blank"><a href="http://blog.csdn.net/pongba">http://blog.csdn.net/pongba</a></a>)
TopLanguage(<a href="https://groups.google.com/group/pongba" title="https://groups.google.com/group/pongba" target="_blank"><a href="https://groups.google.com/group/pongba">https://groups.google.com/group/pongba</a></a>)</p>
<p>一年前一个偶然的机会我遇到了一本书——《影响力》，看完这本书之后对<strong>我们如何思维</strong>产生了极大的兴趣，于是在一年的时间里面密集地阅读了以下一些方面的经典著作：<strong>社会心理学、认知科学、神经科学、进化心理学、行为经济学、机器学习、人工智能、自然语言处理、问题求解、辩论法（Argumentation Theory）、Critical Thinking、判断与决策。以及大量的 Wikipedia 条目。</strong></p>
<p><strong>这一年来，对以上这些领域的阅读和思考给我带来了极大的价值，我相信他们也会给你带来巨大的收益。</strong></p>
<p>关于为什么我认为我们都需要学习这方面的知识，我曾在博客中写到：
另外还有一些我认为是 essential knowledge 的例子：分析问题解决问题的思维方法（这个东西很难读一两本书就掌握，需要很长时间的锻炼和反思）、判断与决策的方法（生活中需要进行判断与决策的地方远远多于我们的想象），波普尔曾经说过：All Life is Problem-Solving。而判断与决策又是其中最常见的一类Problem Solving。尽管生活中面临重大决策的时候并不多，但另一方面我们时时刻刻都在进行最重大的决策：如：决定自己的日常时间到底投入到什么地方去。如：你能想象有人宁可天天花时间剪报纸上的优惠券，却对于房价的1%的优惠无动于衷吗？（《别做正常的傻瓜》、《Predictably Irrational》）如：你知道为什么当手头股票的股价不可抑止地滑向深渊时我们却一边揪着头发一边愣是不肯撤出吗？（是的，我们适应远古时代的心理机制根本不适应金融市场。）糟糕的判断与决策令我们的生活变得糟糕，这还不是最关键的，最关键的是我们从来不会去质疑自己的判断，而是总是能“找到”其他为自己辩护的理由（《错不在我（Mistakes were made, but not by me）》）又，现在是一个信息泛滥的时代，于是另一个问题也出现：如何在海洋中有效筛选好的信息，以及避免被不好的信息左右我们的大脑（<a href="http://en.wikipedia.org/wiki/Critical_thinking" target="_blank">Critical Thinking</a>）关于以上提到的几点我在豆瓣上有一个专门的豆列（“<a href="http://www.douban.com/doulist/127649/" target="_blank">学会思考</a>”），希望有一天我能够积累出足够多的认识对这个主题展开一些详细介绍。</p>
<p>人类的大脑和思维是目前已知最为复杂的系统，对这个系统的研究不仅自身是一件极其迷人的事情，对于像我们这样的芸芸众生来说<strong>即便不去做研究，学习一些这方面的科普知识，对于学会正确地思考有极大的益处。</strong></p>
<p><strong>你的大脑是你唯一的工具，要正确利用这个工具，唯一的途径就是去了解它。</strong>与很多人的直觉相反，实际上我们的思维有着各种各样的缺陷和陷阱（keyword: <a href="http://en.wikipedia.org/wiki/Cognitive_bias" target="_blank">cognitive bias</a>），我们解决日常问题的思维方式也并不总是最优的（keyword: <a href="http://en.wikipedia.org/wiki/Bounded_rationality" target="_blank">bounded rationality</a>），这里摘抄一段我在豆列上的导言：
我们的思维有很多很多的弱点，我一向认为，正确的思维方式，是一切高效学习的基础。比如参见如下2个例子，错误的思维方式得到的结论有大得多的可能性是谬误。</p>
<ul>
<li>人总喜欢沿袭以往习得的经验，并通过类比来进行外推。我第一次在一个地铁终点站坐地铁的时候，看着从远方开来的地铁，我心生疑惑——“这车每节车厢都这么长，待会怎么调头呢（我心说没看到铁轨终点有一个大大的供调头的 U 形弯啊）？”，当车开始开的时候我终于意识到原来车是可以往两头方向开的。</li>
<li>人喜欢从关联当中寻找因果，有一次我我老婆去银行取款，到了 ATM 室的自动门口，我开玩笑地拿着手头的饭卡去刷了一下，然后——门居然开了。我顿时来了劲，立即得出一个结论：这个刷卡装置不安全，至少不是能够专门识别银联的卡的。我甚至飞快地泛化出了一个更具一般性的理论来解释这个现象：即可能所有带有磁性的卡都可以用来开门。老婆看我得意洋洋，就泼过来一盘冷水：不一定是你的卡刷开的啊，你不刷卡试试看。我不信，说怎么可能呢，心想我刷卡，门就开了，还有比这更明显的因果关系嘛。但出乎我意料的是，我走出门，这次没刷卡，门也开了——原来是感应门——原先这个 ATM 室的确是刷卡门，但后来改成了感应门，刷卡的那个装置只不过没拆掉残留在那里而已。</li>
</ul>
<p>总的来说</p>
<ul>
<li>人类的思维充满着各种各样的捷径，每一条捷径都是一把双刃剑。一方面，它降低了大脑的认知复杂性（笼统的看一个问题要比细致的分析简单得多），有助于迅速做出绝大部分时候都正确的判断；但另一方面，它也常常导致人们把大部分情况下成立的法则当成了放之四海而皆准的。可以说，有多少捷径，就有多少条谬误。</li>
<li>人类的情绪也在很大程度上影响着人的思考。比如，如果你憎恶一个人，你往往就会反对他的所有立场。反之亦成立。</li>
<li>人类大脑经过长时间的进化，先天就具备一些特定的“思维定势”，以使得人类能够在面对进化过程中经常出现的适应性问题时能够不假思索的做出迅速的反应。然而，在现代社会，这类思维定势已经不适应了。</li>
<li>人类不可避免的受着各种各样的偏见的影响，这些偏见有些是有一定适应价值的“思维定势”（如事后聪明式偏见），而有些则是大脑的认知机制的“缺陷”。</li>
</ul>
<p>以上，构成了人类思维中的种种谬误。而学会思考，就是学会认识到这些谬误。</p>
<p>Critical-Thinking 在西方拥有悠久的历史，早到古希腊时代，亚里士多德就已经对人类语言中的各种各样的谬误有了一定的认识（譬如，“我们无法讨论不存在的东西，所以所有的事物都是真实的”），并对辩论之中存在的各种各样的谬误进行了归类。然而令人遗憾的是，在中国的文化里面，理性思维似乎是一直被抑制的，中国文人传统都是非理性思考者；所谓非理性思考，主要包括联想、比方等形式，这些思维方式作为人类天生具有的思维方式的一种，一方面当然有它的好处（比如在科研方面，联想往往能够启发新思路；类比也有助于用新颖的方式来解决既有问题），然而另一方面，这样的思维方式同样也充满了各种各样致命的谬误。在大众知识领域，自中国古代文人思维习惯流传下来的影响深刻地左右着人们的语言习惯，随处可见的不靠谱的类比和文字游戏就是证明（例如，严格来说，类比的一般形式是，A具有X、Y、Z三个属性，B具有X、Y属性（类似于A），所以B具有Z属性。这个类比要成立，必须要满足一个前提，即X、Y属性对于Z属性的有无必须是有关的。然而这个前提被根本忽视了，详见 <a href="http://en.wikipedia.org/wiki/False_analogy" target="_blank">False Analogy</a>）。</p>
<p>这个豆列中的书，有一些是介绍人类思维工作的机制的，认识这些机制是正确思考的大前提；有许多是关于人类推理（Reasoning）过程中的形形色色的谬误的，因为唯有认识到 这些谬误，才能避免它们。唯有避免了思维的谬误，才能进行正确的思考。</p>
<p>注：</p>
<ul>
<li>一个最完整的认知偏见（cognitive bias）列表见： <a href="http://en.wikipedia.org/wiki/List_of_cognitive_biases" target="_blank"><a href="http://en.wikipedia.org/wiki/List_of_cognitive_biases">http://en.wikipedia.org/wiki/List_of_cognitive_biases</a></a></li>
<li>一个完整的 Fallacies 列表见： <a href="http://en.wikipedia.org/wiki/Fallacies" target="_blank"><a href="http://en.wikipedia.org/wiki/Fallacies">http://en.wikipedia.org/wiki/Fallacies</a></a></li>
<li>Wikipedia 上关于 Critical Thinking 的条目见： <a href="http://en.wikipedia.org/wiki/Critical_thinking" target="_blank"><a href="http://en.wikipedia.org/wiki/Critical_thinking">http://en.wikipedia.org/wiki/Critical_thinking</a></a></li>
</ul>
<p>另：</p>
<ul>
<li>人类在思考问题的过程中，自身的思维习惯、性格、知识积累无不都在悄悄地影响着思维的过程，所以，一些心理学的知识也非常有助于帮助正确的思考。更多心理学方面的推荐，参考：<a href="http://www.douban.com/doulist/46003/" target="_blank"><a href="http://www.douban.com/doulist/46003/">http://www.douban.com/doulist/46003/</a></a></li>
</ul>
<p><strong>文章末尾将贴出的是我这一年来学习的知识结构总揽（用</strong><a href="http://www.xmind.net/" target="_blank">XMind</a><strong>画的思维导图）</strong>。注：这只是一个整体的知识结构，或者说“寻路图”，其中固然包含一些例子（用 “e.g.” 标出），但<strong>最重要的是从各个分支引申出去的延伸阅读</strong>，后者<strong>包含上百个很有价值的 wikipedia 条目，不下 50 本经典的著作</strong>（大部分我已经读过，小部分经过我的仔细考察，正在阅读中或者肯定是有价值的）。</p>
<p>如何<strong>获得这些延伸出去的阅读</strong>，有两个办法：</p>
<ol>
<li><strong>在总揽图中抽出关键字到 Wikipedia&amp;Google 上查找</strong>，如：<a href="http://en.wikipedia.org/wiki/Informal_fallacy" target="_blank">informal fallacy</a>，<a href="http://en.wikipedia.org/wiki/Cognitive_biases" target="_blank">cognitive biases</a>, <a href="http://en.wikipedia.org/wiki/Bounded_rationality" target="_blank">bounded rationality</a>, <a href="http://en.wikipedia.org/wiki/Critical_thinking" target="_blank">critical thinking</a>, <a href="http://en.wikipedia.org/wiki/Argumentation_theory" target="_blank">argumentation theory</a>, <a href="http://en.wikipedia.org/wiki/Behavioral_economics" target="_blank">behavioral economics</a>, <a href="http://en.wikipedia.org/wiki/Problem_solving" target="_blank">problem solving</a> 等等（以上这些关键字你都会在思维导图中看到）。注：<strong>阅读 Wikipedia 时要严重注意每个条目后面的 Reference ，一般来说这些参考资料本身也都非常经典，其价值不亚于 Wikipedia 条目本身。</strong></li>
<li><strong>查看我整理的四个豆列：</strong></li>
</ol>
<ul>
<li><a href="http://www.douban.com/doulist/46003/" target="_blank"><strong>【只读经典】心理学改变生活</strong></a></li>
<li><a href="http://www.douban.com/doulist/127649/" target="_blank"><strong>【只读经典】学会思考</strong></a></li>
<li><a href="http://www.douban.com/doulist/197706/" target="_blank"><strong>【只读经典】判断与决策</strong></a></li>
<li><a href="http://www.douban.com/doulist/176513/" target="_blank">机器学习与人工智能学习资源导引</a></li>
</ul>
<p>以上四个豆列中整理的绝大多数都是我阅读过的，你也可以参考我的整个<a href="http://www.douban.com/people/pongba/booktags/%E6%80%9D%E7%BB%B4" target="_blank">“思维”标签下的书</a>。如何获得这些书（尤其是其中包含大量的无中文翻译版的英文书）请参考李笑来老师的<a href="http://www.xiaolai.net/index.php/archives/1607.html" target="_blank">笔记</a>。</p>
<p>这个领域的新知识是如此的纷至沓来，以至于我只有时间不断地阅读和思考，以及不时在我的 Google Notebook 里做一些笔记，而完全没有时间一本书一本书，一个子领域一个子领域地写具体的 Introduction （目前具体的荐书只是在 TopLanguage 上<a href="https://groups.google.com/group/pongba/search?group=pongba&amp;q=%E8%8D%90%E4%B9%A6&amp;qt_g=Search+this+group" target="_blank">零散的推荐了几本</a>，还没有专题介绍）。既便如此，仍然还是在博客上写了很多相关的东西，它们就是这一年来的学习的收获的证明:-)，因此<strong>如果你想快速判断上面列出的一些书籍是否对你有价值，有多大的价值，不妨参考一下我写的这些文章，这些文章很大程度上是在这一年的学习过程当中的感悟或总结。注：第 3 部分（关于学习、记忆与思考）的文章基本上是领域无关的：</strong></p>
<ol>
<li><strong>关于 Problem Solving 的</strong></li>
</ol>
<ul>
<li><a href="http://blog.csdn.net/pongba/archive/2008/04/18/2302905.aspx" target="_blank">《跟波利亚学解题》</a></li>
<li><a href="http://blog.csdn.net/pongba/archive/2008/07/07/2622713.aspx" target="_blank">《知其所以然地学习（以算法学习为例）》</a></li>
<li><p><strong>关于机器学习的</strong>（机器学习和人工智能领域对于理解我们的思维方式也提供了极好的参考）</p>
</li>
<li><p><a href="http://blog.csdn.net/pongba/archive/2008/09/21/2958094.aspx" target="_blank">《数学之美番外篇：平凡而又神奇的贝叶斯方法》</a></p>
</li>
<li><a href="http://blog.csdn.net/pongba/archive/2008/09/11/2915005.aspx" target="_blank">《机器学习与人工智能学习资源导引》</a></li>
<li><p><strong>关于学习、记忆与思考的</strong></p>
</li>
<li><p>《一直以来伴随我的一些学习习惯》（<a href="http://blog.csdn.net/pongba/archive/2008/07/08/2625115.aspx" target="_blank">一</a>，<a href="http://blog.csdn.net/pongba/archive/2008/07/20/2681668.aspx" target="_blank">二</a>，<a href="http://blog.csdn.net/pongba/archive/2008/09/17/2942482.aspx" target="_blank">三</a>，<a href="http://blog.csdn.net/pongba/archive/2008/12/05/3456240.aspx" target="_blank">四</a>）</p>
</li>
<li><a href="http://blog.csdn.net/pongba/archive/2008/10/29/3176250.aspx" target="_blank">《方法论、方法论——程序员的阿喀琉斯之踵》</a></li>
<li><a href="http://blog.csdn.net/pongba/archive/2008/06/05/2513263.aspx" target="_blank">《学习与记忆》</a></li>
<li><a href="http://blog.csdn.net/pongba/archive/2008/04/08/2260812.aspx" target="_blank">《阅读与思考》</a></li>
<li><a href="http://blog.csdn.net/pongba/archive/2008/01/04/2025830.aspx" target="_blank">《鱼是最后一个看到水的》</a></li>
<li><a href="http://blog.csdn.net/pongba/archive/2007/06/24/1664597.aspx" target="_blank">《我不想与我不能》</a></li>
<li><a href="http://blog.csdn.net/pongba/archive/2007/05/24/1624382.aspx" target="_blank">《学习密度与专注力》</a></li>
</ul>
<p>好在我并不打算零星的一本一本推荐:D 所以我就花了点时间将整个的知识体系整理了一番，画了下面这张结构图，请按图索骥，如下（有三个版本，1. 至 xMind Share 的超链接，2. 内嵌在该页面中的幻灯片，如果无法载入请参考 1 。3. 图片版（注：图很大，请下载浏览或打印））</p>
<p>我在前面写学习习惯的时候曾经提到：</p>
<ol>
<li>学习一项知识，必须问自己三个重要问题：1. 它的本质是什么。2. 它的第一原则是什么。3. 它的知识结构是怎样的。</li>
</ol>
<p>有朋友问我具体的例子，好吧，那么这张思维导图便是第三点——知识结构——的一个很好的例子:)</p>
<ol>
<li><p>至 XMind Share 的超链接：<a href="http://share.xmind.net/pongba/how-to-think-straight-4/" title="http://share.xmind.net/pongba/how-to-think-straight-4/" target="_blank"><a href="http://share.xmind.net/pongba/how-to-think-straight-4/">http://share.xmind.net/pongba/how-to-think-straight-4/</a></a></p>
</li>
<li><p>嵌入的幻灯片（如加载失败请直接点击上面的 XMind Share 超链接至 XMind 浏览）：</p>
</li>
<li><p>图片版（此为缩略版，完整版请至相册下载：<a href="http://picasaweb.google.com/lh/photo/fdo1gXHiHIoc1hVQfSAwpA" target="_blank">google picasa 的</a> ，或 <a href="http://album.hi.csdn.net/app_uploads/pongba/20081218/134153046.png" target="_blank">csdn 相册的</a>）（<strong>最后提醒一下，别忘了这幅图只是大量书籍和 Wikipedia 条目的“藏宝图”，如何延伸阅读请参考前文所述的方法</strong>）
<a href="http://picasaweb.google.com/lh/photo/fdo1gXHiHIoc1hVQfSAwpA" target="_blank"><img src="" alt=""></a> From <a href="http://picasaweb.google.com/pongba/XMind" target="_blank">XMind</a></p>
</li>
</ol>
<hr>
]]></content>
    
    
      <category term="好文摘录" scheme="http://itsolife.com/categories/%E5%A5%BD%E6%96%87%E6%91%98%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[知其所以然（以算法学习为例）]]></title>
    <link href="http://itsolife.com/2014/02/03/2014-02-03--%E7%9F%A5%E5%85%B6%E6%89%80%E4%BB%A5%E7%84%B6%EF%BC%88%E4%BB%A5%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E4%B8%BA%E4%BE%8B%EF%BC%89/"/>
    <id>http://itsolife.com/2014/02/03/2014-02-03--知其所以然（以算法学习为例）/</id>
    <published>2014-02-03T03:24:30.000Z</published>
    <updated>2014-03-07T03:28:06.000Z</updated>
    <content type="html"><![CDATA[<h1 id="-">知其所以然（以算法学习为例）</h1>
<p>其实下文的绝大部分内容对所有学习都是同理的。只不过最近在<a href="http://blog.csdn.net/pongba/archive/2008/06/05/2513263.aspx" target="_blank">正儿巴经地</a>学算法，而后者又不是好啃的骨头，所以平时思考总结得就自然要比学其它东西要多一些。</p>
<p>问题：目前几乎所有的算法书的讲解方式都是欧几里德式的、瀑布式的、自上而下的、每一个推导步骤都是精准制导直接面向目标的。由因到果，定义、引理、定理、证明一样不少，井井有条一丝不乱毫无赘肉。而实际上，这完全把人类大脑创造发明的步骤给反过来了。看起来是阳关大道，实际上车马不通。</p>
<p><img src="http://mindhacks.cn/wp-content/uploads/2009/02/clip-image001.jpg" alt=""></p>
<p>而对读者来说，这就<strong>等于直接告诉你答案&amp;做法了</strong>，然后<strong>让你去验证</strong>这个答案&amp;做法是可行&amp;成立的。而关于答案&amp;做法到底是怎么来的，从问题到答案之间经历了怎样的思维过程。却鲜有书能够很好的阐释。就我有限的阅（算法）书经验，除了波利亚的《怎样解题》还算合格之外（也并非最理想），其它的（包括有名的《算法导论》、《如何解题：现代启发式方法》、《Algorithms》、《编程珠玑》，甚至TAOCP——公平地说由于高老大对算法领域历史了解得非常通透，所以许多地方能够从原始脉络来讲述一个问题，譬如令人印象深刻的从竞赛树到堆的讲解就寥寥一页纸道出了堆这个数据结构的本质来，而像刚才列的几本有名的书却都没有做到），在思维的讲述上都算不上合格<strong>（当然不是说这些书没有价值，作为知识性的参考书籍，它们将知识整理出系统结构，极大的便利了知识的掌握，就像《什么是数学》所做的工作一样）</strong>，为什么我这么说呢，因为我发现每每需要寻找对一个算法的解释的时候，翻开这些书，总是直接就看到关于算法逻辑的描述，却看不到整个算法的诞生过程背后的思想。</p>
<p><strong>我们要的不是相对论，而是诞生相对论的那个大脑。我们要的不是金蛋，而是下金蛋的那只鸡。</strong></p>
<p><strong>Update(2008-7-24):*</strong> <strong>收到不少同学的批评，想来这个开头对一些著作的语气过重了，实际上，注意，*</strong>我完全不否认这些著作的价值，我自己也在通过阅读它们来学习算法，并且有很多收获<strong><em>。这篇文章更多的只是建议</em></strong>除了阅读这些著作之外还需要做的功课<strong><em>。此外，对于这类知识讲述（欧几里德）方式的批判西方（尤其是在数学领域）早就有了，早在欧拉和庞加莱的时候，他们俩就极其强调思维的传授，欧拉认为如果不能传授思维，那数学教学是没意义的。而庞加莱本人则更是对数学思维有极大的兴趣和研究（</em></strong>我前阵子在讨论组上还转载了一篇庞加莱的著名演讲，就是说这个的，参见<strong>[</strong>这里<em>*](<a href="http://groups.google.com/group/pongba/browse_frm/thread/3dfc84e0506486cc" target="_blank">http://groups.google.com/group/pongba/browse_frm/thread/3dfc84e0506486cc</a>)</em>）。我只是在说目前的算法书没有做到思维讲述的层面，因此建议阅读这些书之余应该寻找算法的原始出处，应该寻根究底，多做一些功课，知道算法到底是怎么诞生的，并且我说明了为什么应该知其所以然，有哪些好处（见下文），我还给了几个例子譬如红黑树作者讲红黑树的，g9讲后缀树的，以及Knuth讲heap的。唉，其实挺正统的观点，授人以渔，不管是东方西方都有类似的古老谚语。而我只是从认知科学的角度加了点解释，windstorm称之为“解释文”。而已。可惜被开头的语气搞砸了，算了，既发了也就不改了。*</p>
<p><img src="http://mindhacks.cn/wp-content/uploads/2009/02/clip-image002.gif" alt=""></p>
<p>为什么会这样，其实是有原因的。</p>
<p>我们在思考一个问题的过程中有两种思维形式：</p>
<ul>
<li><strong>联想</strong>：这种思维某种程度上可以说是“混乱”的（虽然从一个更根本的层面上说是有规则的），所谓混乱是指很多时候并不确定联想到的做法最终是否可行，这些联想也许只是基于题目中的某个词语、语法结构、问题的某个切片、一些零星局部的信息。这个过程是试探性的。最后也许有很大一部分被证明是不可行的。很多时候我们解决问题用的都是这种思维，简言之就是首先枚举你关于这个问题能够想到的所有你学过的知识，然后一一往上套看看能否解决手头的问题。这种思维方式受限于人脑联想能力本身的局限性。我在<a href="http://blog.csdn.net/pongba/archive/2008/04/18/2302905.aspx" target="_blank">《跟波利亚学解题》</a>中就提到了几个例子。联想本身需要记忆提取的线索，所以受到记忆提取线索的制约，如果线索不足，那怎么也联想不起来。而提取线索的建立又取决于当初保存记忆的时候的加工方法（<a href="http://www.douban.com/subject/1315575/" target="_blank">《找寻逝去的自我》</a>里面有阐述），同时，面对一个问题，你能够从中抽取出来的联想线索又取决于你对问题的认识层度/抽象深度，表浅的线索很可能是无关的，导致无效的联想&amp;试错（<a href="http://www.douban.com/subject/2845839/" target="_blank">《Psychology of Problem Solving》</a>里面有阐述）。总之，联想这个过程充满了错误的可能。</li>
<li><strong>演绎**</strong>&amp;<strong>**归纳</strong>：演绎&amp;归纳是另一种思维形式。它们远比联想有根据。其中演绎是严格的，必然的。归纳也是有一定根据的。在面对一个问题的时候，我们有意无意的对问题中的各个条件进行着演绎；譬如福尔摩斯著名的“狗叫”推理——狗+生人=&gt;吠叫 &amp; 昨晚狗没有叫 =&gt; 那个人是熟人。就是一个典型的对问题的各个条件进行演绎的推理过程。还有就是通过对一些特殊形式的观察来进行归纳，试图总结问题中的规律。然而，不幸的是，面对复杂的问题，演绎&amp;归纳也并不总是“直奔”问题的解决方案的。人的思维毕竟只能一下子看到有限的几步逻辑结论，一条逻辑演绎路径是否直奔答案，不走到最后往往是不知道的，只要答案还未出现，我们大脑中的逻辑演绎之树的末端就始终隐藏在黑暗之中。而当最终答案出现了之后，我们会发现，这棵演绎之树的很多分支实际上都并不通往答案。所以，虽然演绎&amp;归纳是一种“必然”的推理，然而却并不“必然”引向问题的结论，它也是试错的，只不过比联想要更为靠谱一些。</li>
</ul>
<p>既然认识到，<strong>人类解决问题的两大思维方式实际上都是有很大的试错成分的</strong>（好听一点叫“探索”），那么就不难意识到，对一个问题的思考过程实际上是相当错综复杂的，而且<strong>充满了无效分支</strong>——在思考的过程中我们也会不断的对分支进行评估，做适当的剪枝——因此当我们找到问题的解之后，<strong>一来思维的漫长繁杂的过程已经在大脑里面淡化得差不多了</strong>，只有那些引向最终结论的过程会被加“高亮”——我们在思考的过程中本就会不断的抛弃无效的思路，只留下最有希望的思路。简而言之就是最后证明没用或者早先我们就不抱希望的一些想法就被从工作记忆中扔掉了。<strong>二来，思考过程是我们的空气和水，而“<a href="http://blog.csdn.net/pongba/archive/2008/01/04/2025830.aspx" target="_blank">鱼是最后一个感觉到水的</a>”</strong>，我们感觉不到思维法则本身的存在，我们只是不知不觉运用它。<strong>三来，由于我们的目标是问题的解</strong>，解才是我们为之兴奋和狂喜的东西，而不是求解的过程，<strong>过程只是过程，目的才是目的</strong>。这就像一个寻宝者，在漫长曲折的寻宝历程之后，在找到宝藏的时候，他会对宝藏感到狂喜（记得阿基米德的“找到了！”吗？）而迫不及待地要展示出来，而漫长的思考本身却成了注脚。我们是有目的的动物，目的达到了，其它的就相对不那么重要了。最后，对于传授知识的人，也许还有<strong>其四：感到介绍思维过程是不相干的</strong>，毕竟思维过程并不是算法问题的解，算法问题的解才是算法问题的解。然而不幸的是，忽视到达解的那个过程实际上却变成了舍本逐末。我们看到的是寥寥数行精妙绝伦的算法，然后仰天长叹自己想不出来啊想不出来。为什么想不出来，因为你不知道那短短数行算法背后经历的事怎样漫长的思考过程，如果问题求解是一部侦探小说，<strong>那么算法只是结局而已，而<a href="http://blog.csdn.net/pongba/archive/2008/05/07/2412144.aspx" target="_blank">思考过程</a>才是情节</strong>。</p>
<p><img src="http://mindhacks.cn/wp-content/uploads/2009/02/clip-image003.gif" alt=""></p>
<p>既然如此，也就难怪古往今来算法牛人们算法牛，但却没有几个能真正在讲述的时候还原自己的思维过程的（那个“ 渔”字），手把手的教学生走一遍推理的思路，就可以让学生获得思维过程的训练。金出武雄在<a href="http://www.douban.com/subject/1867455/" target="_blank">《像外行一样思考，像专家一样实践》</a>中说<strong>写论文应该写得像侦探小说一样</strong>，我很赞同。欧几里德式的介绍，除了提供枯燥的知识之外，并没有提供帮助人获得知识的东西——思维（关于对数学书籍的欧几里德式写法的批评其实也是由来已久了，并且有人呼吁了好几种其它的<a href="http://en.wikipedia.org/wiki/Mathematics_education#Methods" target="_blank">教学方法</a>）。<strong>从这方面，我们所尊敬的一些“圣经”级书籍在传道授业上还不如侦探小说</strong>，前者是罗列一大堆知识，后者则是阐述获得知识的过程——推理&amp;联想。</p>
<p>然而，我们都是人，人类该有的思维形式，我们难道不是都有吗。既然如此，思维本身又有什么需要一遍遍教的呢？</p>
<p>并非如此。</p>
<p>讲述思维过程而非结果有几个极其重要的价值：</p>
<ul>
<li><strong>内隐化</strong>：思维法则其实也是知识（只不过它是元知识——是帮助我们获得新知识的知识）；是<a href="http://en.wikipedia.org/wiki/Implicit_memory" target="_blank">内隐的记忆</a>。我们在思考的过程中觉察不到思维法则的作用，它们却在幕后实实在在的左右着我们的思维轨迹。要将思维方法内隐化，<a href="http://blog.csdn.net/pongba/archive/2008/06/05/2513263.aspx" target="_blank">需要不断练习</a>，就像需要不断练习才能无意识状态下就能骑自行车一样。</li>
<li><strong>跨情境运用</strong>：思维法则也是知识记忆，是问题解决策略。既然是记忆，就受到提取线索的制约，这就是为什么当波利亚<a href="http://www.douban.com/subject/1456890/" target="_blank">告诉你</a>要“注意未知数”之后你还是不能真正在所有需要你“注意未知数”的地方都能提醒自己“注意未知数”。很多时候未知数是很隐蔽的，未知数并不会总是头顶一个大帽子上面写着“我是未知数”。所以很多时候缺乏对这个策略的“提醒”线索，这也是为什么<strong>你学会了在解决数学问题的时候“**</strong>注意未知数”<strong><strong>却不一定能在解决现实生活中的问题中时刻都能“</strong></strong>注意你的未知数”<strong>（<a href="http://www.douban.com/subject/1135754/" target="_blank">《你的灯亮着吗？》</a>整本书的价值便在于此），因为解数学题和解决生活中问题的场景不一样，不同的环境线索，在你大脑中激发的记忆也不一样。就连问题求解中，不同的问题之间的细小差别也可能导致思维轨迹很大的不同，有时你的注意力会被一个无关线索激发的联想吸引开去，忘记如“注意你的未知数”这样的重要法则。而一本从思维角度来讲问题求解的书则可以一遍遍将你置于不同的问题场景下然后在该提醒你的时候提醒你，让你醒悟到“</strong>哦，原来<strong>*</strong>这个<strong>*</strong>时候也应该想到<strong>*</strong>这个<strong>*</strong>啊。**”，做多了这样的思维演习你就会逐渐从中领悟到某种共性，并将一些思维习惯得到强化，于是终于能够在需要运用某策略的时候能适时的想起来了。</li>
<li><strong>对问题解的更多**</strong><a href="http://blog.csdn.net/pongba/archive/2008/06/05/2513263.aspx" target="_blank">记忆提取线索</a><strong>：我们平时学习算法时几乎仅止于“理解”，别人把一个方案放在你面前，你去验证一下，心说“哦，不错，这个的确可以工作”。然后就没了。稍微简单一点的算法还好，复杂一点的对于记忆的负担是很大的，这就是为什么有时候我们看到一个绝妙的解法，这个解法看上去不知道从哪里来的，但经过我们的理解，却发现是对的，我们感叹，真巧妙，结果一些天之后，别人问起这个问题，我们说：“</strong>唉，那是个多么巧妙的算法啊，但是我只记得它巧妙，却不记得它到底是怎样的了。<strong>” 为什么？因为在不知其所以然的情况下，算法只是一堆离散的机械步骤，缺少背后的思想的支撑，这些步骤之间就没有一个</strong>本质层面上的关联<strong>（先知亚里士多德早就指出：学习即联接）。所以就跟背历史书也没多大区别。然而，</strong>知道了算法是怎样一步步被推导出来的，我们就一下拥有了大量的记忆提取线索：对算法发现过程中的任何一个关键步骤（尤其是本质）的回忆都可能使我们能够自己动手推导出剩余的内容<strong>。</strong>譬如<strong>你知道堆(heap)是怎样由朴素的决策树演化而来的，它又是为了解决什么问题的，你即便忘记了具体的细节，也可以自己推导出来。</strong>譬如<strong>你知道KMP算法的本质在于消除回溯，至于如何消除回溯却并不是那么难以推导的，所以即便忘了也可以借助于大脑的逻辑演绎能力再现出来。</strong>譬如<strong>你知道Tarjan算法其实只是从后序遍历经过两个优化调整而来的（其中并査集的使用其实只是优化手段——为了能够迅速判断祖先节点是谁——而非算法本质——当然，算法设计的主要任务本来就是通过问题条件中蕴含的知识来“消除冗余计算”和“避免不必要计算”，所以你也可以说并査集的使用是关乎本质的，只不过，知道了为什么需要引入并査集，就会强烈地感觉到一切是顺理成章的了），那这个出了名的绕人的算法也就不那么难以理解和记忆了。</strong>譬如**你知道<a href="http://blog.csdn.net/pongba/archive/2008/06/13/2544933.aspx" target="_blank">排序的本质</a>，就能够对什么是最优排序，为什么它是最优排序有深刻的认识。四两拨千斤。</li>
</ul>
<p><img src="http://mindhacks.cn/wp-content/uploads/2009/02/clip-image004.jpg" alt=""></p>
<ul>
<li><strong>包含了多得多的知识</strong>：<strong>记一个算法，就只有一个算法</strong>。一个萝卜一个坑。<strong>就好比背99**</strong>乘法表只能解决乘法问题一样<strong>。而记</strong>背后的思想，却有助于解决一类问题<strong>。思想所处的抽象层面往往比到处都是实现细节的算法本身要低，越是低的抽象层次，越是本质，涵盖范围越是广泛。数学的发展本身就体现了这个过程，抽象代数就是非常好的例子。</strong>算法诞生过程中的思路往往包含了比实际算法更本质得多的知识**，实际算法乃至算法的某个特定语言的实现包含了太多表面的不相干知识，它们会阻碍对本质的理解。</li>
<li><strong>重在分析推理，而不是联想</strong>：学了一大通算法和数据结构之后的一个<strong>副作用</strong>就是，看到一个问题之后，脑袋里立即不管三七二十一冒出一堆可能相干的数据结构和算法来。联想是强大的<a href="http://www.douban.com/doulist/127649/" target="_blank">思维捷径</a>，在任何时候都会<a href="http://en.wikipedia.org/wiki/Attention#Neural_correlates_of_attention" target="_blank">抢占</a>大脑的<a href="http://en.wikipedia.org/wiki/Working_memory" target="_blank">工作记忆</a>，由不得你控制——比如我问你“如何寻找区间的最大值”，首先进入你的意识的肯定就是学过的那个算法，甚至算法的实现细节都一一跳了出来，也许最先跳出来的还是算法实现中某个最容易弄错的边界细节，或是某个比较tricky的实现技巧！然而这些其实根本不反映一个算法的本质，结果想来想去总是停留在问题的表层。而另一方面，重在思维的传授则可以让人养成从问题本质入手，逐步分析推理的习惯，而不是直接生搬硬套。<strong>当然，完全不可否认，联想本身也是极其重要的思维方法，甚至可以说是人类思维<a href="http://en.wikipedia.org/wiki/Hebbian_learning" target="_blank">最重要的</a>**</strong>特征**。很多时候我们并不知道问题的本质是什么，就需要靠联想、类比来领路探索。只不过，养成优先从问题的本质入手进行考察的好习惯绝对是有更大的好处的。</li>
</ul>
<p>那到底什么样的才算是授人以渔的呢？波利亚的《如何解题》绝对算是一本，他的《数学的发现》也值得一看。具体到算法书，那就不是光看text book就足够的了，为了深入理解一个算法的来龙去脉前因后果，从一个算法中领悟尽量深刻的东西，则需要做到三件事情：</p>
<ul>
<li><strong>寻找该算法的原始出处</strong>：TAOCP作为一个资料库是绝对优秀的，基础的算法只要你能想到的，几乎都可以在上面找到原始出处。查到原始出处之后（譬如一篇paper），就可以去网上搜来看了。因为最初的作者往往对一个方案的诞生过程最为了解。比如经典数据结构中的红黑树是出了名的令人费解的结构之一，但它的作者Sedgewick<a href="http://groups.google.com/group/pongba/browse_thread/thread/3513a21065faba68" target="_blank">一张PPT，给你讲得通通透透</a>，比算法导论上的讲法强上数倍。</li>
<li><strong>原始的出处其实也未必就都推心置腹地和你讲得那么到位</strong>：前面说过，算法设计出来了之后人们几乎是不会去回顾整个的思维过程细节的，只把直指目标的那些东西写出来。结果就又是一篇欧几里德式的文章了。于是你就迷失在一大堆“定义”、“引理”、“定理”之中了。这种文章看上去整个写得井井有条，其实是把发明的过程整个给颠倒过来了，我一直就想，如果作者们能够将整个的思路过程写出来，哪怕文字多上十倍，我也绝对会比看那一堆定义定理要容易理解得多。话说回来，怎么办？可以再去网上找找，牛人讲得<a href="http://blog.csdn.net/g9yuayon/archive/2008/06/21/2574781.aspx" target="_blank">未必比经典教材上的差</a>。那倘若实在找不出好的介绍呢，就只能自己<strong>揣摩</strong>了。<strong>揣摩的重要性，是怎么说都不为过的</strong>。揣摩的<strong>一些指导性的问题有</strong>：为什么要这样（为什么这是好的）？为什么不是那样（有其它做法吗？有更好的做法吗？）？这样做是最好的吗？（为什么？能证明吗？）这个做法跟其它的什么做法有本质联系吗？<em>这个</em>跟<em>这个</em>的区别是什么？<strong>问题的本质是什么</strong>？<strong>这个做法的本质又是什么</strong>？到底本质上是什么东西导致了这个做法如此..？与这个问题类似的还有其它问题吗？（同样或类似的做法也适用吗？）等等。</li>
<li><strong>不仅学习别人的思路，整理自己的思路也是极其重要的</strong>：详见<a href="http://blog.csdn.net/pongba/archive/2008/04/18/2302905.aspx" target="_blank">《跟波利亚学解题》</a>的“4. 一个好习惯”和“7. 总结的意义”。</li>
</ul>
<p>前一段时间我们讨论组上有不少例子，见<a href="http://groups.google.com/group/pongba/web/toplang-problemsolvingseries" target="_blank">这里</a>，或<a href="http://del.icio.us/pongbablog/%E8%A7%A3%E9%A2%98" target="_blank">这里</a>。
来源： <a href="[http://mindhacks.cn/2008/07/07/the-importance-of-knowing-why/](http://mindhacks.cn/2008/07/07/the-importance-of-knowing-why/)">[http://mindhacks.cn/2008/07/07/the-importance-of-knowing-why/](http://mindhacks.cn/2008/07/07/the-importance-of-knowing-why/)</a></p>
]]></content>
    
    
      <category term="好文摘录" scheme="http://itsolife.com/categories/%E5%A5%BD%E6%96%87%E6%91%98%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[知其所以然（三）：为什么算法这么难？]]></title>
    <link href="http://itsolife.com/2014/02/03/2014-02-03--%E7%9F%A5%E5%85%B6%E6%89%80%E4%BB%A5%E7%84%B6%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E7%AE%97%E6%B3%95%E8%BF%99%E4%B9%88%E9%9A%BE%EF%BC%9F/"/>
    <id>http://itsolife.com/2014/02/03/2014-02-03--知其所以然（三）：为什么算法这么难？/</id>
    <published>2014-02-03T03:24:29.000Z</published>
    <updated>2014-03-07T03:24:29.000Z</updated>
    <content type="html"><![CDATA[<h1 id="-">知其所以然（三）：为什么算法这么难？</h1>
<h1 id="-http-mindhacks-cn-2011-07-10-the-importance-of-knowing-why-part3-"><a href="http://mindhacks.cn/2011/07/10/the-importance-of-knowing-why-part3/" target="_blank">知其所以然（三）：为什么算法这么难？</a></h1>
<p>不知不觉《知其所以然》系列竟然也写到第三篇了，虽然前面两篇也说了不少，但是总觉得还有东西没有说“透”，或者说没有说“好”。所以这篇试图从不同的角度用更好的例子来继续深入阐述。（感谢<a href="http://www.douban.com/people/silwile/" target="_blank">silwile</a>对本文的review和意见）</p>
<p>广大码农同学们大多都有个共识，认为算法是个硬骨头，很难啃，悲剧的是啃完了还未必有用——除了面试的时候。实际工程中一般都是用现成的模块，一般只需了解算法的目的和时空复杂度即可。</p>
<p>不过话说回来，面试的时候面算法，包括面项目中几乎不大可能用到的算法，其实并不能说是毫无道理的。<strong>算法往往是对学习和理解能力的一块试金石</strong>，难的都能掌握，往往容易的事情不在话下。志于高者得于中。反之则不成立。另一方面，虽说教科书算法大多数都是那些即便用到也是直接拿模块用的，但不幸的是，我们这群搬砖头的有时候还非得做些发明家的事情：要么是得把算法当白盒加以改进以满足手头的特定需求；要么干脆就是要发明轮子。所以，虽说面试的算法本身未必用得到，但熟悉各种算法的人通常更可能熟悉算法的思想，从而更可能具备这里说的两种能力。</p>
<p>那么，为什么说算法很难呢？这个问题只有两种可能的原因：</p>
<ol>
<li>算法本身就很难。也就是说，算法这个东西对于人类的大脑来说本身就是个困难的事儿。</li>
<li>讲得太烂。</li>
</ol>
<p>下面会说明，算法之所以被绝大多数人认为很难，以上两个原因兼具。</p>
<p>我们说算法难的时候，有两种情况：<strong>一种是学算法难。第二种是设计算法难</strong>。对于前者，大多数人（至少我当年如此）学习算法几乎是在背算法，就跟背菜谱似的（“Cookbook”是深受广大码农喜爱的一类书），然而算法和菜谱的区别在于，算法包含的细节复杂度是菜谱的无数倍，算法的问题描述千变万化，逻辑过程百转千回，往往看得人愁肠百结，而相较之下任何菜谱涉及到的基本元素也就那么些（所以程序员肯定都具有成为好厨师的潜力:D）注意，即便你看了算法的证明，某种程度上还是“背”（为什么这么说，后面会详述）。我自己遇到新算法基本是会看证明的，但是发现没多久还是会忘掉，这是死记硬背的标准症状。如果你也啃过算法书，我相信很大可能性你会有同感：<em>为什么当时明明懂了，但没多久就忘掉了呢？为什么当时明明非常理解其证明，但没过多久想要自己去证明时却发现怎么都没法补上证明中缺失的一环呢？</em></p>
<p>初中学习几何证明的时候，你会不会傻到去背一个定理的证明？不会。你只会背结论。为什么？一方面，因为证明过程包含大量的细节。另一方面，证明的过程环环相扣，往往只需要注意其中关键的一两步，便能够自行推导出来。算法逻辑描述就好比定理，算法的证明的过程就好比定理的证明过程。但不幸的是，与数学里面大量简洁的基本结论不同，算法这个“结论”可不是那么好背的，许多时候，<strong>算法本身的逻辑就几乎包含了与其证明过程等同的信息量</strong>，甚至算法逻辑本身就是证明过程（随便翻开一本经典的算法书，看几个经典的教科书算法，你会发现算法逻辑和算法证明的联系有多紧密）。于是我们又回到刚才那个问题：你会去背数学证明么？<strong>既然没人会傻到去背整个证明，又为什么要生硬地去背算法呢</strong>？</p>
<p>那么，不背就不背，去理解算法的证明如何？理解了算法的证明过程，便更有可能记住算法的逻辑细节，理解记忆嘛。然而，仍然不幸的是，绝大多数算法书在这方面做的实在糟糕，证明倒是给全了，逻辑也倒是挺严谨的，可是似乎没有作者能真正还原算法发明者本身如何得到算法以及算法证明的思维过程，按理说，证明的过程应该反映了这个思维过程，但是在下文关于霍夫曼编码的例子中你会看到，其实饱受赞誉的<a href="http://www.amazon.com/Introduction-Algorithms-International-Thomas-Cormen/dp/0262533057" target="_blank">CLRS</a>和<a href="http://www.amazon.com/Algorithms-Sanjoy-Dasgupta/dp/0073523402" target="_blank">《Algorithms》</a><em>不仅没能还原这个过程，反而掩盖了这个过程</em>。</p>
<p>必须说明的是，没有哪位作者是故意这样做的，但任何人在讲解一个自己已经理解了的东西的时候，往往会无意识地对自己的讲解进行“线性化”，例如证明题，如果你回忆一下高中做平面几何证明题的经历，就会意识到，其实证明的过程是一个充满了试错，联想，反推，特例，修改问题条件，穷举等等一干“非线性”思维的，混乱不堪的过程，而并不像写在课本上那样——引理1，引理2，定理1，定理2，一口气直到最终结论。这样的证明过程也许容易理解，但绝对不容易记忆。过几天你就会忘记其中一个或几个引理，其中的一步或几步关键的手法，然后当你想要回过头来自己试着去证明的时候，就会发现卡在某个关键的地方，为什么会这样？因为证明当中并没有告诉你为什么作者当时会想到证明算法需要那么一个引理或手法，所以，<strong>虽说看完证明之后，对算法这个结论而言你是知其所以然了，但对于算法的证明过程你却还没知其所以然</strong>。在我们大脑的记忆系统当中，<strong>新的知识必须要和既有的知识建立联系，才容易被回忆起来</strong>（<a href="http://mindhacks.cn/2009/03/28/effective-learning-and-memorization/" target="_blank">《如何有效地学习与记忆》</a>）<strong>，联系越多，越容易回忆，而一个天外飞仙似地引理，和我们既有的知识没有半毛钱联系，没娘的孩子没人疼，自然容易被遗忘。</strong>（为什么还原思维过程如此困难呢？我曾经在<a href="http://mindhacks.cn/2008/07/07/the-importance-of-knowing-why/" target="_blank">知其所以然（一）</a>里详述）</p>
<p>正因为绝大多数算法书上悲剧的算法证明过程，很多人发现证明本身也不好记，于是宁可选择直接记结论。当年我在数学系，考试会考证明过程，但似乎计算机系的考试考算法证明过程就是荒谬的？作为“工程”性质的程序设计，似乎更注重使用和结果。但是如果是你需要在项目中自己设计一个算法呢？这种时候最起码需要做的就是证明算法的正确性吧。我们面试的时候往往都会遇到一些算法设计问题，我总是会让应聘者去证明算法的正确性，因为即便是<strong>一个“看上去”正确的算法，真正需要证明起来往往发现并不是那么容易</strong>。</p>
<p>所以说，绝大多数算法书在作为培养算法设计者的角度来说是失败的，比数学教育更失败。大多数人学完了初中平面几何都会做证明题（数学书不会要求你记住几何所有的定理），但很多人看完了一本算法书还是一团浆糊，不会证明一些起码的算法，我们背了一坨又一坨结论，非但这些结论许多根本用不上，就连用上的那些也不会证明。为什么会出现这样的差异？因为数学教育的理想目的是为了让你成为能够发现新定理的科学家，而码农系的算法教育的目的却更现实，是为了让你成为能够使用算法做事情的工程师。然而，事情真的如此简单么？如果真是这样的话干脆连算法结论都不要背了，只要知道算法做的是什么事情，时空复杂度各是多少即可。</p>
<p>如果说以上提到的算法难度（讲解和记忆的难度）属于<a href="http://en.wikipedia.org/wiki/Accidental_complexity" target="_blank">Accidental Complexity</a>的话，算法的另一个难处便是Essential Complexity了：算法设计。还是拿数学证明来类比（如果你看过《Introduction to Algorithms：A Creative Approach》就知道算法和数学证明是多么类似。），与单单只需证明相比，<strong>设计算法的难处在于，定理和证明都需要你去探索，尤其是前者</strong>——你需要去自行发现关键的那（几）个定理，跟证明已知结论相比（已经确定知道结论是正确的了，你只需要用逻辑来连接结论和条件），<strong>这件事情的复杂度往往又难上一个数量级。</strong></p>
<p>一个有趣的事实是，<strong>算法的探索过程往往蕴含算法的证明过程</strong>，理想的算法书应该通过还原算法的探索过程，从而让读者不仅能够自行推导出证明过程，同时还能够具备探索新算法的能力。之所以这么说，皆因为我是个懒人，懒人总梦想学点东西能够实现以下两个目的：</p>
<ol>
<li><strong>一劳永逸</strong>：程序员都知道“<a href="http://en.wikipedia.org/wiki/Write_once,_run_anywhere" target="_blank">一次编写到处运行</a>”的好处，多省事啊。学了就忘，忘了又得学，翻来覆去浪费生命。为什么不能看了一遍就再也不会忘掉呢？到底是教的不好，还是学得不好？</li>
<li><strong>事半功倍</strong>：事实上，程序员不仅讲究一次编写到处运行，更讲究“一次编写到处使用”（也就是俗称的“复用”）。如果学一个算法所得到的经验可以到处使用，学一当十，推而广之，时间的利用效率便会大大提高。究竟怎样学习，才能够使得经验的外推（extrapolate）效率达到最大呢？</li>
</ol>
<p>想要做到这两点就必须<strong>尽量从知识树的“根节点”入手</strong>，虽然这是一个美梦，例如数学界寻找“根节点”的<a href="http://mindhacks.cn/2008/04/18/learning-from-polya/" target="_blank">美梦由来已久</a>（《跟波利亚学解题》的“一点历史”小节），但哥德尔一个证明就<a href="http://mindhacks.cn/2006/10/15/cantor-godel-turing-an-eternal-golden-diagonal/" target="_blank">让美梦成了泡影</a>（《永恒的金色对角线》））；但是，这并不阻止我们去寻找更高层的节点——<a href="http://mindhacks.cn/2008/04/18/learning-from-polya/" target="_blank">更具普适性的解题原则和方法</a>。所以，理想的算法书或者算法讲解应该是从最具一般性的思维法则开始，顺理成章地推导出算法，这个过程应该尽量还原一个”普通人“思考的过程，而不是让人看了之后觉得”这怎么可能想到呢？</p>
<p>以本文上篇提到的霍夫曼编码为例，第一遍看霍夫曼编码的时候是在本科，只看了算法描述，觉得挺直观的，过了两年，忘了，因为不知道为什么要把两个节点的频率加在一起看做单个节点——一件事情不知道“为什么”就会记不牢，知道了“为什么”的话便给这件事情提供了必然性。不知道“为什么”这件事情便可此可彼，<strong>我们的大脑对于可此可彼的事情经常会弄混，它更容易记住有理有据的事情</strong>（<em>从信息论的角度来说，一件必然的事情概率为1，信息量为0，而一件可此可彼的事情信息量则是大于0的</em>）。第二遍看是在工作之后，终于知道要看证明了，拿出著名的《Algorithms》来看，边看边点头，觉得讲得真好，一看就理解了为什么要那样来构造最优编码树。可是没多久，又给忘了！这次忘了倒不是忘了要把两个节点的频率加起来算一个，而是忘了为什么要这么做，因为当时没有弄清霍夫曼为什么能够想到为什么应该那样来构造最优编码树。结果<em>只知其一不知其二</em>。</p>
<p>必须说明的是，如果只关心算法的结论（即算法逻辑），那么理解算法的证明就够了，光背算法逻辑难记住，理解了证明会容易记忆得多。但如果也想不忘算法的证明，那么不仅要理解证明，还要理解证明背后的思维，也就是<em>为什么背后的为什么</em>。后者一般很难在书和资料上找到，唯有自己多加揣摩。为什么要费这个神？只要不会忘记结论不就结了吗？取决于你想做什么，如果你想真正弄清算法设计背后的思想，不去揣摩算法原作者是怎么想出来的是不行的。</p>
<p>回到霍夫曼编码问题，我们首先看一看《Algorithms》上是怎么讲的：</p>
<p>首先它给出了一棵编码树的cost function：</p>
<p>cost of tree = Σ freq(i) /* depth(i)</p>
<p>这个cost function很直白，就是把编码的定义复述了一遍。但是接下来就说了：</p>
<p><em>There is another way to write this cost function that is very helpful.</em> Although we are only given frequencies for the leaves, we can define the frequency of any internal node to be the sum of the frequencies of its descendant leaves; this is, after all, the number of times the internal node is visited during encoding or decoding…</p>
<p>接着就按照这个思路把cost function转换了一下：</p>
<p>The cost of a tree is the sum of the frequencies of all leaves and internal nodes, except the root.</p>
<p>然后就开始得出算法逻辑了：</p>
<p>The <em>first formulation</em> of the cost function tells us that the <em>two symbols with the smallest frequencies must be at the bottom of the optimal tree</em>, as children of the lowest internal node (this internal node has two children since the tree is full). Otherwise, swapping these two symbols with whatever is lowest in the tree would improve the encoding.</p>
<p>This suggests that we start constructing the tree greedily: find the two symbols with the smallest frequencies, say i and j, and make them children of a new node, which then has frequency fi + fj. To keep the notation simple, let’s just assume these are f1 and f2. By the <em>second formulation</em> of the cost function, any tree in which f1 and f2 are sibling-leaves has cost f1 + f2 plus the cost for a tree with n – 1 leaves of frequencies (f1 + f2), f3, f4, .., fn. <em>The latter problem is just a smaller version of the one we started with</em>.</p>
<p>读到这里我想大多数人有两种反应：</p>
<ol>
<li>觉得理所当然。</li>
<li>觉得恍然大悟。</li>
</ol>
<p>因为我当时也是这么觉得的。可是后来当我发现自己无法从头证明一遍的时候，我知道肯定是理解的不够深刻。如果理解的够深刻，那么基本上是不会忘掉的。</p>
<p>如果看完霍夫曼编码这样一个简短证明你觉得顺理成章，一切都挺显然，<em>那就坏了</em>，即便是看上去最基本的性质也往往实际上没那么显然。“逢山开路，遇水架桥”在我们今天看来是无比显然的事实，但是试想在没有桥的远古时代，一个原始人走到一条湍急的河流前，他会怎么想，他又能有什么法子呢？这是个他从来没有遇见过的问题。如果后来有一天，他路过另外一条小溪，看到小溪上有一截被闪电劈断的枯树，于是他踏着树干走过了小溪，并意识到“树横过河面”可以达到“过河”这个目的，这就将条件和目的建立了直接的联系（事实上，是自然界展示了这个联系，我们的原始人只是记住了这个联系）。后来他又路过那条河流，他寻思如何达到“过河”这个目的的时候，忽然意识到在他的记忆中已经遇到过需要达成同样目的的时候了，那个时候的条件是“树横过河面”，于是问题便归结为如何满足这个“树横过河面”的条件，而后一个问题就简单多了。（事实上波利亚在他的著作《How to Solve it》中举的正是这么个例子）</p>
<p>为什么那么多的算法书，就看不到有一本讲得好的？因为我们求解问题过程中的思维步骤太容易被自己当作“显然”的了，但除了我们天生就会的认知模式（联系，类比），没有什么是应该觉得显然的，试错是我们天生就会的思维法则么？是的，但是可供尝试的方案究竟又是怎么来的呢？就拿上面的例子来说，一个从没有见过枯树干架在小溪上的原始人，怎么知道用树架桥是一种可选的方案呢？俗话说巧妇难为无米之炊啊。我们大脑的神经系统会的是将目的和条件联系起来，第一次原始人遇到小溪过不去，大脑中留下了一个未实现的目的，后来见到小溪上的树干，忽然意识到树干是实现这个目的的条件，两者便联系起来了，因此问题就规约为如何架树干了。</p>
<p>回到《Algorithms》中的证明上，这个看似简洁明了的证明其实有几处非常不显然的地方，甚至不严谨的地方，这些地方也正是你过段时间之后试图自己证明的话会发现卡住的地方：</p>
<ol>
<li>作者轻飘飘地就给出了cost function的另外一种关键的描述，而对于如何发现这种描述却只是一语带过：&quot;<em>There is another way to write this cost function that is very helpful.. </em>we can define the frequency of any internal node to be the sum of the frequencies of its descendant leaves“这其实就是我常常痛恨的“<em>我们考虑</em>…”，这里作者其实就是在说”让<em>我们考虑</em>下面这样一种<em>奇妙</em>的转换“，可是怎么来的却不说。但必须承认，《Algorithms》的作者还是算厚道的，因为后面他又稍微解释了一下：“this is, after all, the number of times the internal node is visited during encoding or decoding…”这个解释就有点让人恍然大悟了，但是千万别忘了，这种恍然大悟是一种错觉，你还是没明白为什么他会想到这一点。这就像是作者对你说“<em>仔细观察</em>问题条件，我们<em>容易发现</em>这样一种奇妙的性质..”，怎么个“仔细”法？凭什么我自己“观察”半天就是发现不了呢？霍夫曼本人难道也是死死盯着问题<a href="http://en.wikipedia.org/wiki/Huffman_tree#History" target="_blank">“观察”了一学期</a>然后就“发现”了么？我们有理由相信霍夫曼肯定尝试了各种各样的方法，作出了各种各样的努力，否则当年Shannon都没搞定的这个问题花了他一学期，难道他在这个学期里面大脑就一片空白（或者所有的尝试全都是完全不相干的徒劳），然后到学期末尾忽然“灵光一现”吗？</li>
<li>如果“仔细观察”:)，我们会发现两个cost function表达中frequency的概念有微妙的差异，在第一个cost function中，只有叶子节点有frequency，而这个frequency必须和叶子节点的深度相乘。而在第二个cost function中，内部节点也具有了frequency，可是所有节点的“frequency”忽然全都不跟深度相乘了。frequency的不同含义令人困惑。</li>
<li>作者提到：第一个cost function告诉我们频率最低的两个节点必然处于最优编码树的底端，作为最低内部节点的两个子节点。这是一个不严谨的说法，从前文给出的条件和性质，只能推导出编码树的最底层必然能找到频率最低的两个节点，但<em>它们未必一定要是兄弟节点</em>，如果树的最底层不止能容纳两个节点的话它们就可以有不同的父节点。“我们不妨考虑”这样一个例子：对A,B,C,D四个字母进行编码，假设它们的频率分别是1， 1， 2， 2。这个时候我们可以构造如下图所示的两棵树，两棵树的cost都是12，都是最优的。但其中一棵树中，两个频率最低的节点并非兄弟。 
<a href="http://mindhacks.cn/wp-content/uploads/2011/07/tree2.jpg" target="_blank"><img src="&quot;tree2&quot;" alt="tree2"></a></li>
</ol>
<p>为什么要提到上面这几点不显然和不严谨的地方，因为只要当你看到算法书上出现不显然和不严谨的地方，基本上就意味着作者其实跳过了关键的思维步骤。</p>
<p>不幸的是《Algorithms》这本书里面讲霍夫曼编码已经算是讲的好的了，如果你翻开著名的CLRS，看一看当中是怎么证明的，你就知道我说的什么意思了。有时候这些证明是如此的企图追求formal和严谨，一上来就定义符号一大摞，让人看了就想吐。</p>
<p>说了这么多，<em>有没有可能把霍夫曼编码讲的更好呢</em>？前面说过，霍夫曼编码我记了又忘，忘了又记，好几次了，有一次终于烦了，心想如果要自己去证明，会怎么去证，那个时候我已经忘了《Algorithms》里面怎么讲的了。所以我得从头来起，首先，对于算法问题，有一个一般性原则是，<strong>先看一看解空间的构成</strong>。尤其是对于搜索问题（最优化问题可以看做搜索问题的一个特例），这一点尤其重要。霍夫曼编码的可能的编码树是有穷的，如果穷举所有的编码树，然后找到那棵代价最小的，这种方法至少是可行的，有了可行的方法（即便是穷举）至少让我们内心感到踏实。</p>
<p>接下来便是提高搜寻效率的问题。而提高搜寻效率的关键（同样也是一个一般性原则），便是<strong>尽量去寻找问题条件能够推导出来的性质，**</strong>然后利用这些性质去避免不必要的搜寻**，只要你学过二分搜索就应该理解这个一般性原则：二分搜索的效率之所以高于“穷搜”（O(n)），便是因为它利用了问题中的性质（有序）来避免了不必要的搜寻。有时候这个性质甚至可以直接将时间降为O(1)，例如在一个有序数组中寻找出现次数大于n/2的数（假设该数存在），利用“该数一定出现在数组正中间”这个性质，我们直接就避免了所有的计算。</p>
<p>不过，话虽如此，有时候这些性质并不是那么“显然”的，需要对问题进行深入的折腾才能有可能发现。第三个一般原则：如果你要搜寻的元素是某个满足特定条件的元素（例如寻找最优解的时候，“最优”的定义就是这个“特定条件”），那么可以“<strong>倒过来推</strong>”（数学证明常用手法，结论当条件使），即假设你已经找到了你要找的元素，那么能得出哪些结论，每一个结论都是最优解的一个必要条件，而<em>每一个必要条件都能够帮助你避免不必要的搜寻</em>，因为你<em>只要发现某个候选解不满足某个必要条件，就可以立即将其丢弃</em>，前面提到的寻找出现次数大于n/2的例子是一个极端情况，我们得出的必要条件导致我们可以直接丢弃除中点元素之外的一切其他元素，再例如如果有人叫你寻找有序数组中最小元素，你会毫不犹豫地把该数组头尾元素中较小的那个给他，因为你知道“如果那个最小元素存在，那么它<em>必然</em>位于头尾”——这个必要条件直接允许你丢弃掉n-2个候选解。</p>
<p>回到霍夫曼编码问题，按照这个原则，我们会去<em>假设已经得到了最优编码树</em>，那么我们能够发现关于它的什么性质呢？这里又要提到另一个适用于很多最优化问题的原则（前面提到的原则适用于一般性搜索问题），<strong>所谓最优解，就是说比其他所有解都要更好</strong>，虽然这句话听上去像是废话，但是它的一个直接推论——<strong>比与它邻近的所有候选解都要好</strong>——就是一个非常有用的，不是废话的性质了。学过微积分的都知道，光滑函数的最值点必然是大（小）于其邻域内的所有点的，然后再根据这个就自然推出该点的一阶导数（切线斜率）必然为0的性质，这个性质（必要条件）让我们直接省掉了去整个区间内搜索的麻烦，从而可以直接锁定有限几个候选解。那么，既然我们说最优霍夫曼树一定比它“附近”的树更好，我们就想看看，怎么来找到它附近的树。我们知道要从一个点到它附近，往往是对这个点进行一些调整，例如N+1是到达附近的另一个整数。霍夫曼树是一棵树，所以对这棵树的所有的一次“改动”（或“折腾”）都能够到达与它的“改动”距离为1的点（是不是想起“编辑距离”这个概念），怎么改动呢？最符合直觉的（虽然并不是唯一的）改动便是把叶子节点进行互换。</p>
<p>于是我们得到一个重要的推论：</p>
<ul>
<li><em>在最优霍夫曼树中，无论互换哪两个叶子节点，得到的树都变得更“差”。（严格来说是不会变得更“好”，因为最优树未必唯一）</em></li>
</ul>
<p>这个性质看上去有点像废话，值得费这么多事么？值得。因为虽然前文说了很多，但都是大多数人大脑里面既有的，一般性的法则，前面说过，如果我们能够从我们已经掌握的一般法则出发来推导出问题的解，那么记忆负担是最小的，因为这里面用到的所有法则我们都很清楚，也知道怎么一步步往下走。</p>
<p>上面这个性质究竟意味着什么呢？如果你假设这两个叶子节点的频率为f1和f2，深度为d1和d2，互换它们的时候，其他叶子节点的cost保持不变，令为常量C，那么互换前总cost为C+f1d1+f2d2，互换后为C+f1d2+f2d1，既然互换之后的树一定更”差“那么就是说f1d1+f2d2 &lt; f1d2 + f2d1，简单变换一下就得到结论：f1(d1-d2)<f2(d1-d2)，也就是说如果d1<d2，那么f1必然>f2，如果d1&gt;d2，那么f1必然&lt;f2。换言之就是<em>叶子节点的深度越高，频率必须越低</em>，否则就不可能是最优霍夫曼树。那么，之前我们觉得不那么显然的结论便呼之欲出了：频率最低的叶子节点必然位于树的最底层，频率最高的叶子节点必然位于树的最高层。</p>
<p>有了这个结论之后，我们便能够对最优霍夫曼树的构建走出确定性的一步，即，将频率最低的两个叶子节点放在最底层。别小看这一步，这一步已经排除了大量的可能性。这里，我们容易一开始天真地觉得最底层只有这两个叶子节点，于是它们拥有共同父节点，<em>这样一来霍夫曼树的整个拼图便已经拼好了一个小小的角落</em>。</p>
<p>然后我们会发现，要是它们不是兄弟怎么办呢？这里提到另一个一般原则——<strong>归约</strong>。不是兄弟的情况能否归约为是兄弟的情况？反正我们要求的是<em>一个</em>最优解，而不是<em>所有的</em>最优解，我们只需证明，如果当这两个最低频率的叶子不是兄弟的时候的确存在着某棵最优霍夫曼树，那么通过交换它们各自的兄弟，从而让这两个叶子团聚之后，修改后的树仍然是最优的就可以了。事实情况也的确如此，证明非常直接——既然这里涉及到的所有4个节点都在最底层同一个高度上，那么互相交换的时候不会改变他们任何一个人的深度值，所以总cost不会改变。</p>
<p>但是接下来我们犯了难，整个树的一个小小的樱桃状的局部是确定下来了，接下来怎么办呢？一个最自然的思路就是考虑第三小的叶子，因为前面说了，元素频率越低就越位于树的底部嘛。第三小的叶子有两种可能的归属，一是跟最小的两个叶子同样位于最底层（这不会违反我们前面得到的推论），这个时候第三小的叶子的兄弟叶子肯定是第四小的叶子，如下图：</p>
<p><a href="http://mindhacks.cn/wp-content/uploads/2011/07/tree3.jpg" target="_blank"><img src="&quot;tree3&quot;" alt="tree3"></a></p>
<p>另一种归属就是往上一层去（注意，一旦第三小的叶子往上去了一层，那么剩下的所有叶子都必须至少在这个层以上），往上一层去了之后，它的兄弟是谁呢？不妨将它和刚才第一第二叶子的父节点结为兄弟（前面证明过，同层之前节点互换不会改变编码的cost），如下图：</p>
<p><a href="http://mindhacks.cn/wp-content/uploads/2011/07/tree5.jpg" target="_blank"><img src="&quot;tree5&quot;" alt="tree5"></a></p>
<p>可是现在问题出现了：虽然第一步构建（最小的两个叶子）是确定的，但是到了第二步摆在我们面前的就有两个选择了，到底选择哪个呢？一个办法就是把两种选择都记下来，然后继续往下走。可是别小看两种选择，接下去每一步都有两种选择的话就变成指数复杂度了。所以现在我们便有了动机<em>回头看一看</em>，<em>看问题中是否有什么没有发现的性质能够帮助我们再排除掉其中一个选择</em>。理想情况下如果每一步都是必然的，确定的，那么N步我们就可以构建出整棵树，这是我们希望看到的，抱着这个良好的愿望，我们仔细观察上面两种构型，一个自然而然的问题是：这两种构型都有潜质成为最优解吗？如果我们能够证明其中一种构型不能成为最优解那该多好？就省事多了嘛。这里引入另一个一般性的解题法则：<strong>特例</strong>。我们的<strong>大脑喜欢具体的东西，在特例中折腾和观察会方便的多</strong>。</p>
<p>上面这个{1, 2, 3, 4}的例子就是个很好的特例，如图（注：图中节点旁的数字一概为<em>频率值，</em>而非编号）：</p>
<p><a href="http://mindhacks.cn/wp-content/uploads/2011/07/tree31.jpg" target="_blank"><img src="&quot;tree3&quot;" alt="tree3"></a></p>
<p>多加折腾一番<em>也许</em>我们不难发现，如果将1，2及其父节点跟叶子4进行交换（注意：<em>交换的时候1，2也被一同带走了</em>，因为反正1，2两个节点已确定是好兄弟永远不会分家了，折腾的时候只能作为一个整体移动，所以这里也可以说是<strong>交换子树</strong>），那么树的编码将会变得更优，因为这样一次交换会将1和2的深度+1，意味着整棵树的代价+3，而同时会将叶子4的深度-1，也就是说整棵树的代价-4，总体上整棵树的代价就是+3-4=-1（注意，在计算的时候我们只需考虑被交换的局部，因为树的其他部分的代价保持不变）。如下图：</p>
<p><a href="http://mindhacks.cn/wp-content/uploads/2011/07/tree4.jpg" target="_blank"><img src="&quot;tree4&quot;" alt="tree4"></a></p>
<p>这个交换启发了我们，其实前面一开始说的交换两个叶子节点<em>可以推广为交换内部节点和叶子节点</em>，然后很快我们就会意识到其实可以推广到交换任意两个节点。（注意，<em>当我们说交换内部节点的时候，其实是连同该内部节点作为局部根节点的整个子树都交换过去</em>）于是前面我们的推论就可以推广为：</p>
<ul>
<li><em>在最优霍夫曼树中，无论互换哪两个节点，得到的树都变得更“差”（交换内部节点则是连同该内部节点作为局部根的子树一同带走）</em></li>
</ul>
<p>这个推论很容易理解，只不过是多增加了一种“编辑”最优霍夫曼树的方法罢了（记住<em>最优霍夫曼树无论怎么“编辑”都不会变得更“好”，包括“交换子树”这种“编辑”</em>），我们前面没有想到这种“编辑”方法是因为它不那么显然，而且当时我们已经想到一种最直接的“编辑”方法了，即交换叶子，就容易顺着那个思路一直走下去，直到我们发现必须寻找新的性质，才回过头来看看有没有其他法子。</p>
<p>当然，并不排除一开始就想到这种推广的可能性，问题求解的过程并不是这么线性的，如果我们习惯了推而广之的思维，也许一下就能想到这个推广来。类似的，也不排除从另一种思路出发想到这种推广的可能性。所以这里只是可能的思维轨迹中的一种，重点在于其中并没有某处忽然出现一个不知从哪里冒出来的，神启一般的结论。</p>
<p>刚才提到，构造最优树的第二步是考虑第三小的叶子，但也有另一种常见的思维：考虑到第一步（即选取频率最小的两个叶子）所做的事情是从N个叶子中选择两个黏在一起作为兄弟，那么也许对于一些人来说自然而然的第二步就是试图继续选取两个节点黏在一起作为兄弟（注意这里不仅可以选择叶子，也可以选择已经生成的内部节点），然后依次类推来拼完整棵树。按照这一思路，第二步的选项仍然还是集中在第三小的叶子上，因为这个选择要么是让第三第四小的叶子结拜为兄弟，要么是让最小两个叶子的父节点和第三小的叶子结拜。</p>
<p>回到刚才我们的推论：在最优霍夫曼树中，无论互换哪两个节点，得到的树都变得更“差”（交换内部节点则是连同该内部节点作为局部根的子树一同带走） 。根据这个推论我们容易计算出，<em>在最优霍夫曼树当中，两个内部节点n1和n2，如果n1比n2更深，那么n1下面的所有叶子的频率之和必然要小于n2下面所有叶子的频率之和</em>。如果交换的是一个内部节点和一个叶子节点，则道理是类似的。这个性质的证明和上面的类似，就不赘述了。</p>
<p>这个性质暗示了一个重要的推广结论：<em>如果我们把每个内部节点的所有叶子的频率之和标在它旁边，那么整棵树的每个节点便都有了一个数值，这个数值遵循统一的规律：即越往深层越小</em>。这就意味着，我们刚才的二选一困境有办法了！当我们将最小的两个叶子f1和f2合并的时候，生成了一个新的节点M，这个节点有一个数字（为两个叶子的频率之和f1+f2），根据上面的推论，<em>这个数字f1+f2跟所有频率一同，遵循最小的在最底层的原则</em>，所以我们下一步必须在剩下的那些互相之间关系待确定的节点（叶子节点和内部节点）之中，即{(f1 + f2), f3, f4}里面选择最小的两个数字结合成兄弟（由于f1和f2这两个节点已经铁板钉钉结为整体了，所以从集合里面可以看做移除）。到这里，我们就发现递归已经出现了，接下去的过程对于绝大多数人应该就真的很显然了。</p>
<p>以上的解释，比《Algorithms》更简短吗？显然不是。反而要长得多（其实真正的思维过程比这要更长，因为中间还会涉及各种不成功的尝试）。但是它比《Algorithms》当中的版本更不容易被忘记，因为其中关键的思维拐点并不是毫无来由的，而是从你已经熟知的，或者说虽然不知道，但容易理解的一般性解题法则出发自然推导出来的，所以你基本上不需要记忆什么东西，因为你需要记的已经在你脑海中了。</p>
<p>在上面的证明过程中，还有一个不像看上去那么显然的事情：在我们寻找最优霍夫曼树的时候，我们曾经试图去比较假想的最优树和它的“临近”的树，从而去探索最优树的性质。但是，究竟什么是临近的树？在前面的讲解中，我们说如果交换A和B这两个叶子节点，便得到一颗不同的树，可以看做和原树的“编辑距离”为1的树。但是，真的这么显然么？难道除了交换叶子的位置，就没有其他办法去“折腾”这棵树了？后来我们看到，可以<em>交换子树</em>而不仅仅是叶子，而交换子树让我们得到了至关重要的推论。此外，如果不是交换，而是像AVL树那样“旋转”呢？说到底，二叉树是一个离散的东西，并不像连续值那样，天生就有“距离”这个概念，如果我们离散而孤立地去看待所有的树，那么没有什么临近不临近的，临近本是一个距离的概念，除非我们定义树和树之间的距离函数，才能说临近与否，而距离函数怎么定义才是“显然”的呢？</p>
<p>还有，其实以上只是试图给出最优霍夫曼树的<em>证明</em>的一个更自然的过程，而<em>当年霍夫曼面临这个问题的时候根本还没有人想到要用二叉树呢！更不要说在二叉树的前提之下进行证明了</em>。根据wikipedia的介绍，霍夫曼同学（当年还在读Ph.D，所以的确是“同学”，而这个问题是坑爹的导师Robert M. Fano<a href="http://www.huffmancoding.com/my-family/my-uncle" target="_blank">给他们作为大作业的</a>，Fano自己和Shannon合作给出了一个suboptimal的编码方案，为得不到optimal的方案而寝食难安，情急之下便死马当活马医扔给他的学生们了）当年为这个问题憔悴了一个学期，最后就快到deadline的时候“忽然”想到二叉树这个等价模型，然后在这个模型下三下五除二就搞定了一篇流芳千古的论文，超越了其导师。</p>
<p>最后说两个有趣的现象：也许很多人会觉得，越是大师来写入门教科书越是好，其实很多时候并非如此，尤其是在算法设计和数学领域，往往越是在其中浸淫久了越是难写出贴近初学者的书，因为大量对初学者来说一点都不显然的事情在他看来已经是“不假思索”了，成了他的内隐记忆，尤其是当他想要和你解释一个复杂的东西的时候你就会发现他会常常逻辑跳跃，满嘴跑术语，根本没有意识到别人对有些术语和隐含的逻辑根本没有像他那样的理解。</p>
<p><strong>最适合将一个东西讲给别人听的时候并不是等懂了很多年以后，而是刚刚弄懂的时候</strong>，这个时候从不懂到懂的差别记忆还非常鲜明，能够清清楚楚地记得到底是哪些关键的地方是最折磨人的，也最能够站在不懂者的角度来思考问题。像波利亚这样，成了大师还能够站在不懂者角度去换位思考的，可以说是凤毛麟角。所以说前Amazon CAO（首席算法官）的<a href="http://www.amazon.com/Introduction-Algorithms-Creative-Udi-Manber/dp/0201120372/" target="_blank">《Introduction to Algorithms: a Creative Approach》</a>绝对是本罕见的好算法书）</p>
<p><a href="http://mindhacks.cn/2008/07/07/the-importance-of-knowing-why/" target="_blank">知其所以然（一）</a>里面曾经提到，要弄清来龙去脉，最好去看看原始作者是怎么想的，可是正如上文所说，即便是最初的发明者，在讲述的时候也会有意无意地“线性化”，我就去查看了霍夫曼最初的论文，那叫一个费解，不信你可以自己看看(<a href="http://compression.ru/download/articles/huff/huffman_1952_minimum-redundancy-codes.pdf" target="_blank">PDF</a>)。</p>
<p>可以归约为搜索算法的问题（非常多）一般来说相对还是有一些头绪的，因为搜索空间一般还比较容易界定，难点在于要从问题的条件中推导出用于节省搜索的性质。而策略设计问题则完全是另一个世界，因为策略的设计空间貌似是可列无穷的，常常让人感觉无从下手，摸不着头绪，许多让人挠头的智力问题就有这个特点（例如著名的100个囚徒和1个灯泡的房间就让很多人有这种感觉），策略设计问题也有一些较通用的法则，以后再说。</p>
<p>怎么才能在学算法的时候学到背后的东西呢？有以下几点很重要：</p>
<ol>
<li><strong>不要觉得每个步骤都很显然</strong>，每个nontrivial的算法背后都有一段艰辛的探索经历，觉得显然的话必然是一种幻觉。<strong>Stay foolish</strong>，才能发现某些环节其实并不是那么显然的。</li>
<li>检验是否真正理解的最佳方法就是<strong>过一段时间之后，自己试着证明一次</strong>。如果真正理解了的话，你的证明便会比较顺畅。如果当时没有真正理解，那么凡是那些你当时觉得显然但其实不显然的地方，都会成为你证明里面缺失的环节。</li>
<li>对于一个算法，<strong>多寻找各种来源的资料</strong>，也许能够找到一个讲的比较深刻的。我在<a href="http://mindhacks.cn/2008/06/13/why-is-quicksort-so-quick/" target="_blank">《数学之美番外篇：快排为什么那么快》</a>和<a href="http://mindhacks.cn/2008/07/07/the-importance-of-knowing-why/" target="_blank">《知其所以然（一）》</a>里面都举到了这样的例子。</li>
<li><strong>多试着去抽象背后的一般性法则</strong>，即便后来发现抽象得是错的，也比不去抽象要好。<a href="http://mindhacks.cn/2009/03/28/effective-learning-and-memorization/" target="_blank">抽象是推广的基础</a>。只有抽象出更深层的法则，才能让你事半功倍，触类旁通，否则一个萝卜永远是一个坑。（注意，其实我们的下意识是会进行一定程度的抽象的，例如前面提到的原始人的例子，小溪和小河（或者小沟）细节上是不同的，但本质上是一样的，我们的大脑会自动进行这种简单抽象，提出事物的共性。正因此，即便你不去有意识地总结一般规律，只要你看的足够多，练的足够多，必然就会越来越谙熟。）</li>
</ol>
<p>最后留个问题：虽然按照上文的方式来构造霍夫曼树一定能够得到<em>一个</em>最优树，但是怎么证明一定能得到呢？乍一看这个问题似乎很多余，因为证明很简单：我们拼装整棵树的每一步都没得选，而且每一步都必然拼凑出最优树的一个小小局部，如果最终还没有得到最优树的话，只能说最优树是不存在的了，然而最优树是一定存在的，因为所有树的集合是有穷的，有穷集必有最值，因此证毕。这个证明固然是没问题的，但它其实是一个间接证明，换句话说，我们在构建树的过程中的逻辑是这样的：“之所以我们选择粘结n1和n2，是因为其他粘法必然违反最优树的两个性质。所以我们别无选择。”但是，这并没有说，我们选择了粘结n1和n2，一定就<em>符合</em>了最优树的性质。（也就是说“其他做法都是错”并不能推出“这种做法必然对”，这就像是你在一大堆豆子当中寻找一个特殊的豆子，你拿起一个，看看不是，扔掉，又拿起一个，还不是，扔掉，排除到最后只剩一个豆子了，假设你又知道这个特殊的豆子必然存在，那么这个时候你根本不用看就知道这个豆子一定就是你要找的）那么，你能否直接证明，拼装最优树的过程每一步都<em>符合</em>最优树的性质呢？</p>
<p>P.S.</p>
<p>[1] 《逃出你的肖申克》和《BetterExplained》是我喜欢的两个系列，还会继续写，我有很多问题，也在Evernote里面记了不少零碎的思考和资料，但只有当我觉得理解的足够深入，系统，以及手头有足够的有意思和有说服力的例子的时候，我才会把整条线串起来成文，所以这事慢慢来不着急，反正这个博客也不会关掉。</p>
<p>[2] 工作之后可用业余时间急剧减少，已经陆续基本把GReader砍掉了，时间再往前推，砍掉邮件列表，再往前是Twitter，再往前是BBS。现在基本就只剩邮件了。越来越发现当时间有限的时候，看书比看网要有效得多，也不会那么信息焦虑，网络上的那些消息当中真正重要的会自己来找你，不用每天去刷屏。不过有个例外，我过一阵子就会去逛一下Amazon的个性化推荐项目。如果你已经工作，苦于时间有限，我建议你这么做。最近看过的几本值得好好推荐的书有：《Number Sense》，《Reading in the Brain》，《The Vision Revolution》，《The Tell-Tale Brain》，《Kluge》。</p>
<p>[3] 顺便吐槽国内出版社引进Pop Science类书籍的效率和质量，就我观察，台湾引进Pop Science类书籍需要延迟两年左右，大陆则从三四年到无限期不等（某种程度上，一个国家的出版方的认识水平，决定了这个国家大众的认识水平。你去看下我在豆瓣的书单就知道有多少好书与国内读者失之交臂了），例如《Number Sense》这本好书，到现在还没有引进，99年出版的书啊。《Kluge》更是译为《乱乱脑》这种坑爹的书名，封面搞得跟少儿读物一样。《Reading in the Brain》引入的算较快的，但也延迟了一年半了，而且翻译质量也不是很上乘（算是不功不过吧），说到这里要赞中信出版社，最近一年引入了很多给力的Pop Science畅销书，眼光还算不错。最近在Amazon上搜一些好的发展心理学的书，通过Amazon的推荐引擎看到了<a href="http://www.amazon.com/Pink-Brain-Blue-Differences-Troublesome/dp/0618393110" target="_blank">《Pink Brain，Blue Brain》</a>，这本受到因研究大脑记忆的分子机制而获诺奖的Eric Kandel盛赞的科普09年就出了，到现在国内影子都见不着，还好在卓越上买到了原版。虽然基本还没开始看，但可以郑重推荐给初为父母的同学们:)
来源： <a href="[http://mindhacks.cn/2011/07/10/the-importance-of-knowing-why-part3/](http://mindhacks.cn/2011/07/10/the-importance-of-knowing-why-part3/)">[http://mindhacks.cn/2011/07/10/the-importance-of-knowing-why-part3/](http://mindhacks.cn/2011/07/10/the-importance-of-knowing-why-part3/)</a> </p>
<ul>
<li>kw</li>
</ul>
<p>哇塞，又是不鸣则已，一鸣惊人！</p>
<p>2011年7月10日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="dribble"></li>
</ul>
<p>dribble</p>
<p>其实我倒真是觉得在算法证明的时候用一堆符号有什么不好，因为算法本身就是应用数学，数学需要符号化。算法的牛人们很多都有数学、物理的背景，我觉得就算是理解了某一个算法设计最像idea的地方，对自己设计算法并没有本质的帮助，只能帮助记住这个算法而已。</p>
<p>2011年7月10日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="felven"></li>
</ul>
<p>felven</p>
<p>沙发，正如老师所说的，把算法学好了去哪里都不成问题</p>
<p>2011年7月10日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="cacard"></li>
</ul>
<p>cacard</p>
<p>moring...</p>
<p>2011年7月10日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="sk.c"></li>
</ul>
<p>sk.c</p>
<p>沙发？？？好久没见更新了。。。^_^</p>
<p>2011年7月10日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="limitlimiter"></li>
</ul>
<p>limitlimiter</p>
<p>让我重新捡起算法，谢谢未鹏大牛</p>
<p>2011年7月10日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="佘明磊"></li>
</ul>
<p>佘明磊</p>
<p>谢谢你，虽然有技术壁垒我不大看懂！</p>
<p>2011年7月10日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://www.helishi.net/" title="ikbear" target="_blank"><img src="" alt="ikbear"></a></li>
</ul>
<p><a href="http://www.helishi.net/" target="_blank">ikbear</a></p>
<p>很多思维结论的背后，并不是有确定的东西。发明者之所以连自己都没法将其讲清楚，很可能是这确实无从谈起，因为它确实是一丝灵光的结果；也可能是他的思维确实无法轻易让普通人理解；或者他根本就表达不好。
虽然说，写书的人把那些探索算法的思维过程写出来能够很好的帮助读者理解，让读者跟深更快的掌握算法。但是这也仅限于让读者掌握，让读者接受。这样，读者不光要接受其结论，连其思考过程也要接受。这本身就扼杀了想象力，还是停留在“背”的阶段。拿毕达哥拉斯定理来说，几百种的证明，每一种证明都有不同的思维过程。如果你认为探索每一种证明的思维过程就认为掌握了它，那么它的第二种第三种第N种证明又是从何而来的？
真正要去探索算法，应该是在基本理解算法之后，再去自己思考。参考别人的思考过程可能可以帮助自己思考，但参考别人的思考过程并不代表自己思考，两者并不等同。不过，这正是常人无法得到的。</p>
<p>2011年7月10日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="dsigma"></li>
</ul>
<p>dsigma</p>
<p>我是菜鸟，我倒非常认同刘老师的观点，必须有所思考！
理解是一个思考的过程，而回味这个理解的过程才是我成长的过程。</p>
<p>2011年7月19日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://aboutminds.net/" title="kevinyzd" target="_blank"><img src="" alt="kevinyzd"></a></li>
</ul>
<p><a href="http://aboutminds.net/" target="_blank">kevinyzd</a></p>
<p>订阅你的blog很长时间。我喜欢这种典型的逻辑教程，我虽然数学不是非常好，但希望可以从中得到更多的了解，因为这确实是一个非常有意思的东西。另外你写文章的方式或多或少对我有所影响。</p>
<p>2011年7月10日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://workzen.net/" title="Fey" target="_blank"><img src="" alt="Fey"></a></li>
</ul>
<p><a href="http://workzen.net/" target="_blank">Fey</a></p>
<p>期待刘未鹏的书《暗时间》出版...</p>
<p>2011年7月10日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="feirainy"></li>
</ul>
<p>feirainy</p>
<p>&quot;大脑喜欢具体的东西，在特例中折腾和观察会方便的多，也许我们不难发现，如果交换1，2的父节点（因为反正1，2两个节点已确定是好兄弟永远不会分家了，折腾的时候只能作为一个整体移动）和叶子4，那么树的编码将会变得更优.&quot;－－在这里纠结了好一阵。。。</p>
<p>2011年7月10日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://weibo.com/pongba" title="刘未鹏pongba" target="_blank"><img src="" alt="刘未鹏pongba"></a></li>
</ul>
<p><a href="http://weibo.com/pongba" target="_blank">刘未鹏pongba</a></p>
<p>谢谢提醒，我已经根据你和楼下abellong的意见修改了那部分。我自己写到那里的时候也觉得似乎有点拗口，当时偷懒没改:D</p>
<p>2011年7月10日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="feirainy"></li>
</ul>
<p>feirainy</p>
<p>谢谢回复，关于特例的那一段，因为当时折腾了一阵，后面见到未鹏修改了却与我当时的理解不太一样，我表示提出一点点意见，本人只是菜鸟，如有错，请见谅。</p>
<ol>
<li>对特例的折腾，最后得出的启发是：“在最优霍夫曼树中，无论互换哪两个节点，得到的树都变得更“差””。
可是特例呈现出来的是，通过交换1、2的父结点与结点4（编号是频率），可以得到更“优”的树，这对交换后得出更“差”的启发刚好相反。
（不过因为情况只有两种，即结点3与结点12在同一层，以及结点3在上一层，所以拐个弯能够想到从情况1到情况2更优，即相当于从情况2到情况1更差）。</li>
<li>特例提出的是，在最小的4个频率值为1，2，3，4时，交换1，2的父结点与结点4可以减少树的总代价，得到更优的树。
然后我当时就觉得，如果最小的4个频率值为3，4，5，6时，以同样方式交换结点树的总代价却会增大。于是觉得这样交换代价可能增大，可能减少，不能确定什么呀。。。
后面终于注意到，因为第3个最小频率值的结点的情况只有两种，就是说两种情况有一种比另一种更优（至少不会更差？），于是第3个最小频率值的结点的位置就确定下来了，在此位置确定的基础上，交换确实会令树的代价增加（至少不减少），于是也可以推广交换的方式了。</li>
</ol>
<p>2011年7月11日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://weibo.com/pongba" title="刘未鹏pongba" target="_blank"><img src="" alt="刘未鹏pongba"></a></li>
</ul>
<p><a href="http://weibo.com/pongba" target="_blank">刘未鹏pongba</a></p>
<p>@feirainy，谢谢你提的疑惑。说明我还是没有讲好:)
是这样的，特例中得出的启发仅仅是“可以交换子树，而不仅仅是交换叶子”，仅此而已。至于“最优霍夫曼树中无论交换哪两个子树都使cost增加”并不是特例中得出的推论，而是最优霍夫曼树的“最优”性质得出的直接推论。</p>
<p>2011年7月11日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="abellong"></li>
</ul>
<p>abellong</p>
<p>&quot;频率最低的两个节点必然处于编码树的最底层，但未必一定要是兄弟节点&quot; 这个说法也不严谨，反例：1,1,1,3总有一个频率为1（最低）的在倒数第二层，不是最底层。
“在上面的例子中，我们已经有了特例”，表示不知道特例在哪里？因此，“如果交换1，2的父节点和叶子4，那么树的编码将会变得更优”这个结论也不是“不难发现”，甚至错误。
那个推广，似乎就是从“特例”里得到启发，并没有证明（至少是严格证明），让人不放心
总的感觉，此篇文章仍然让人费解……
我觉得一般书上让人难以理解的其中一点是略去了一些特例（比如频率相等的情况），这些可以通过“归约”解释，可以多花心思在这里：为什么可以只处理某一种情况，其他都可以归约为这种情况？</p>
<p>2011年7月10日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://weibo.com/pongba" title="刘未鹏pongba" target="_blank"><img src="" alt="刘未鹏pongba"></a></li>
</ul>
<p><a href="http://weibo.com/pongba" target="_blank">刘未鹏pongba</a></p>
<ol>
<li>“频率最低的两个节点必然处于编码树的最底层，但未必一定要是兄弟节点” 的确不严谨。谢谢指出。准备添加说明：“当频率最低的两个节点处于不同层的时候，必然可以归约为同层”</li>
<li>特例就是1,2,3,4那个例子。“交换1,2的父节点和叶子4”是指交换1,2那个子树（1,2和他们的父亲）和叶子4。交换后的情况我画了图。</li>
<li>那个推广的确是特例中的启发，然后后面是有证明的。如果你说的是“在最优霍夫曼树中，无论互换哪两个节点，得到的树都变得更“差”（交换内部节点则是连同该内部节点作为局部根的子树一同带走）”这个推广没有证明的话，我想说的是这个是“最优树”的定义的直接蕴含啊，不需要证明。如果你说的是“在最优霍夫曼树当中，两个内部节点n1和n2，如果n1比n2更深，那么n1下面的所有叶子的频率之和必然要小于n2下面所有叶子的频率之和。”这个推广没有证明的话，是因为证明和置换叶子节点的情况类似，文中提了“不加赘述”。
谢谢指正。</li>
</ol>
<p>2011年7月10日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="abellong"></li>
</ul>
<p>abellong</p>
<p>谢谢回复:)
第二个问题，回想我当时的理解：我把那俩幅图里的1、2、3、4默认成编号，即第1小、第2小（而不是理解成频率）…导致我错了。当时脑子短路，没转过来。 不过还是建议换个数字更好些
提的第三个问题 真完全是我的问题了，没有仔细考虑，胡乱就问了，惭愧
谢谢您的分享，从您博客我学到了很多:)</p>
<p>2011年7月10日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="abellong"></li>
</ul>
<p>abellong</p>
<p>回头再看，发现您修改后意思已非常明确了，忽略那个建议吧</p>
<p>2011年7月10日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://weibo.com/pongba" title="刘未鹏pongba" target="_blank"><img src="" alt="刘未鹏pongba"></a></li>
</ul>
<p><a href="http://weibo.com/pongba" target="_blank">刘未鹏pongba</a></p>
<p>@abellong
根据你的建议我仔细修改了那一段的细节，其实我当时写的时候也是觉得那段有点拗口。楼上的feirainy也提了类似的疑惑。
“1、2、3、4默认成编号，即第1小、第2小（而不是理解成频率）”，恩，这个我再想想，也许回头加个注。
再次感谢。</p>
<p>2011年7月10日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://weibo.com/pongba" title="刘未鹏pongba" target="_blank"><img src="" alt="刘未鹏pongba"></a></li>
</ul>
<p><a href="http://weibo.com/pongba" target="_blank">刘未鹏pongba</a></p>
<p><a href="">回复 abellong: </a>我回头看了一下，的确{1,2,3,4}有编号之嫌，因为前文提到第一第二小，和第三第四小，恰巧用的频率也是1，2，3，4，所以的确有点容易混淆。所以我在“特例”那个地方加了括号说明是频率。当然具体频率数字最好是改掉，不过还要重新作图，就懒了:)</p>
<p>2011年7月10日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://mindlee.net/" title="酷~行天下" target="_blank"><img src="" alt="酷~行天下"></a></li>
</ul>
<p><a href="http://mindlee.net/" target="_blank">酷~行天下</a></p>
<p>未鹏大牛终于更新了，学算法学的头大………</p>
<p>2011年7月10日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="Kejia"></li>
</ul>
<p>Kejia</p>
<p>你写的真好。</p>
<p>2011年7月11日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://moodylee.me/" title="moody" target="_blank"><img src="" alt="moody"></a></li>
</ul>
<p><a href="http://moodylee.me/" target="_blank">moody</a></p>
<p>时隔半年，ponba终于又出手了。</p>
<p>2011年7月11日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://www.bengogo.com/" title="好看的电影" target="_blank"><img src="" alt="好看的电影"></a></li>
</ul>
<p><a href="http://www.bengogo.com/" target="_blank">好看的电影</a></p>
<p>哈哈还好我以前的数学还算不错！算术这东西就要思考</p>
<p>2011年7月11日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="hlily"></li>
</ul>
<p>hlily</p>
<p>好吧。。我承认太长的博客。我总是看不下去~</p>
<p>2011年7月11日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="custqi"></li>
</ul>
<p>custqi</p>
<p>几乎所有的算法都来源于其背后的数学知识， 像图论， 贪心有拟阵， 动态规划出自运筹学，搜索其实也能从图论延伸出来，当然还有更难一些的搜索，数论也有专门的数学教材等等， 个人认为用一个学习算法 应该用一个 数学的头脑去学习，一些推导证明更应该用 数学的思维去验证，当然也可以用实例数据去手工执行代码，这样会好理解一些，仅一家之言，口水就不必了。</p>
<p>2011年7月11日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="gordon"></li>
</ul>
<p>gordon</p>
<p>何为“数学的头脑”？帅哥，你还没有说出来啊。呵呵
其实这篇文章已经讲的很清楚了，基本思想就是“读完以后，合上书，你把它复述出来。 ”
这个可是不容易啊，pongba做这个都很吃力的。
要什么自行车，搞的强盗不像强盗，猴子不像猴子的，还是干强盗这份比较有前途的职业吧。
------- 摘自《大话西游》和《卖拐》
当然个人爱好除外。</p>
<p>2011年7月12日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="gordon"></li>
</ul>
<p>gordon</p>
<p>算法在狭义上压根就不是计算机专业的内容，那是计算数学专业的内容。当然非要抬杠说，只要是涉及到计算的都属于计算科学，也属于计算机科学，我也无语。
但那真不是计算机科学的内容，计算科学不等于计算机科学，OK。</p>
<p>2011年9月16日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="gordon"></li>
</ul>
<p>gordon</p>
<p>计算机这个专业是讲什么的，就是讲什么是计算机，从底层硬件、接口技术到用晶体管做一个4位计算机的实现，再到内外存，硬件结束上升到系统软件；
操作系统如何管理硬件，内存管理、磁盘管理等东东，编译器，数据库；系统软件结束了就是应用软件。然后计算机和计算机之间有通讯，就是计算机网络。
完了，真的完了。
计算机专业的数学和其他专业需要计算机处理的数学要分清楚，要清楚的分开。
要搞清楚计算机专业的研究对象是什么，狭义的计算机专业压根就不研究算法，研究的是数据结构。
但是如何选择数据结构？却要把算法提出来，选择不同的数据结构，算法复杂度是不一样的，
也就是说数据结构定了，就会降低算法实现的复杂度。
就是为了讲清楚数据结构怎么选择的问题，所以稍带把算法也讲了，就是这样。</p>
<p>2011年9月16日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="黄铂钧"></li>
</ul>
<p>黄铂钧</p>
<p>计算机学科的“教学”和“研究”要分清楚，要清楚的分开。
要搞清楚计算机专业的教学对象是什么，狭义的计算专业压根就不教“计算机相关研究所需的知识”，教的是“如何把已有的计算机知识应用到实际中”
不过话说回来，现在计算机专业的教学确实很差，只是谁也没有能力去改进而已。</p>
<p>2011年11月12日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="gordon"></li>
</ul>
<p>gordon</p>
<p>码农要研究算法的原因是因为有其他行业的问题需要计算机来处理，这个在公司中一般应该专门设置这样的算法岗位，招聘“ 计算数学 “专业的人才。
小公司一般没有这个岗位，大多是拿开源的工具包在用，只要能看懂文档，会用就行了。</p>
<p>2011年9月16日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://www.iphonephysics.com/" title="iphysics" target="_blank"><img src="" alt="iphysics"></a></li>
</ul>
<p><a href="http://www.iphonephysics.com/" target="_blank">iphysics</a></p>
<p>大刘的想法和我非常相似，多年以来我在数学的学习过程中深有体会，
定理的探索 有很多失败，试错，摸索的过程， 《费马大定理》这本书就是一个揭示类似过程的好例子，可是在教科书和课堂上出现的都是千锤百炼的最精炼的结果，学生学不到如何去摸索，可是要完全再现摸索的过程，确实需要非常精深的学识与阅历。不是一般老师可以达到的</p>
<p>2011年7月12日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="Greg"></li>
</ul>
<p>Greg</p>
<p>您的文章阐述的观点很正确，给人很大启发。
但关于您的文章的表达方面，我从一个读者角度提出一个建议：
我希望您写文章能够更加深入浅出，就是能一目了然的明白文章的主旨。
拿这篇文章作例，我理解的主旨就是：学习算法的好途径是透彻地理解算法。也就是“知其所以然”的学习。（我十分赞同这个观点，自己也是努力这么做的。）
我希望您的表达能更直观，要做到这样本身就需要首先对自己的观点有透彻的理解，不然就容易东一句西一句，抓不住要领。
谢谢。</p>
<p>2011年7月12日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="jkryanchou"></li>
</ul>
<p>jkryanchou</p>
<p>终于更新了。。等过一个又一个季节。又是一篇佳作。。未鹏，一直期待你文章。。。持续关注中。</p>
<p>2011年7月12日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="4D"></li>
</ul>
<p>4D</p>
<p>光滑函数的最值点必然是大（小）于其邻域内的所有点的
这个好像不是最值点的定义吧，这个是极大值点的定义吧</p>
<p>2011年7月13日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://weibo.com/pongba" title="刘未鹏pongba" target="_blank"><img src="" alt="刘未鹏pongba"></a></li>
</ul>
<p><a href="http://weibo.com/pongba" target="_blank">刘未鹏pongba</a></p>
<p>不是定义，是必要条件。</p>
<p>2011年7月13日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="JOB"></li>
</ul>
<p>JOB</p>
<p>我是个大三的学生，您在例证中对哈夫树的讲解跟我们当年离散数学的老师讲的有异曲同工之妙，我现在倒是很感激那个老师了。</p>
<p>2011年7月13日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="JOB"></li>
</ul>
<p>JOB</p>
<p>对于在结尾处您埋下的问题，可否指点一二？</p>
<p>2011年7月14日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://weibo.com/sun0721?inviteCode=1715455645" title="miracle-light" target="_blank"><img src="" alt="miracle-light"></a></li>
</ul>
<p><a href="http://weibo.com/sun0721?inviteCode=1715455645" target="_blank">miracle-light</a></p>
<p>真是太感谢啦，这么好的内容怎么能错过呀，老天有眼！</p>
<p>2011年7月14日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://hi.baidu.com/gevolution90/" title="朱健强" target="_blank"><img src="" alt="朱健强"></a></li>
</ul>
<p><a href="http://hi.baidu.com/gevolution90/" target="_blank">朱健强</a></p>
<p>若是博主把使用 evernote 的方法，技巧，收获等写成一文，想必定是一篇佳作。</p>
<p>2011年7月15日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://www.nb-lz.com/" title="宁波餐饮管理" target="_blank"><img src="" alt="宁波餐饮管理"></a></li>
</ul>
<p><a href="http://www.nb-lz.com/" target="_blank">宁波餐饮管理</a></p>
<p>学习下，谢谢博主分享</p>
<p>2011年7月18日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="黄铂钧"></li>
</ul>
<p>黄铂钧</p>
<p>&quot;设计算法的难处在于，定理和证明都需要你去探索，尤其是前者&quot;
设计算法可以看成是在做解答题,而解答题比证明题难是共识吧.其实数学也一样,主要成果体现在定理的提出,而不在于证明
&quot;理想的算法书应该通过还原算法的探索过程&quot;
没有textbook会这么写的，因为那样写出来的书会奇厚无比，知识的传达应以简洁为好。只有&quot;how to solve it&quot;这种科普读物才有篇幅会讨论思考方法
“当年Shannon都没搞定的这个问题花了他一学期”
我听说的版本是Huffman只用了一个下午就证明了这个贪心算法的最优。就像你说的，huffman面对的问题，难点不在于证明最优性（他只用了半天），而在于提出这个greedy algorithm本身（他用了一个学期）。而通常算法书上只涉及最优树构建这个相对简单的子问题。
“有没有可能把霍夫曼编码讲的更好呢”
taocp里讲的很清楚（可能因为knuth当年专门研究过haffman algebra）</p>
<p>2011年7月20日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="黄铂钧"></li>
</ul>
<p>黄铂钧</p>
<p>解决huffman的最优编码问题，关键在于把它转化成tree construction问题；但有意思的是，想说清楚huffman算法却恰恰要避开tree construction这个视角。只要纠缠在“树”，“节点”，“叶子”这些概念上，无论你怎么解释都会显得cumbersome。
至于思考方法，对于huffman tree这个具体问题，我个人的经验是关键在于要意识到，所谓的&quot;optimal tree&quot;其实往往不止一个，也就是说，同时存在相当数量的彼此不同的树它们都是最优的。一旦意识到这一点证明思路就走上正轨了，后面那些“交换”什么的都是技术问题，仔细思考加上一些耐心就会自然得到。</p>
<p>2011年7月20日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://www.mllovw.info/" title="babyface" target="_blank"><img src="" alt="babyface"></a></li>
</ul>
<p><a href="http://www.mllovw.info/" target="_blank">babyface</a></p>
<p>不错，过来支持下~~</p>
<p>2011年8月2日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://www.hx569.com/" title="丰禾棋牌" target="_blank"><img src="" alt="丰禾棋牌"></a></li>
</ul>
<p><a href="http://www.hx569.com/" target="_blank">丰禾棋牌</a></p>
<p>你成功的让我把头都看大了。</p>
<p>2011年8月5日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://king.violinmm.com/" title="violin" target="_blank"><img src="" alt="violin"></a></li>
</ul>
<p><a href="http://king.violinmm.com/" target="_blank">violin</a></p>
<p>很是佩服楼主如此博学，真是值得学习的好地方！</p>
<p>2011年8月12日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://www.tong12.com/" title="北京时尚摄影" target="_blank"><img src="" alt="北京时尚摄影"></a></li>
</ul>
<p><a href="http://www.tong12.com/" target="_blank">北京时尚摄影</a></p>
<p>博主真是个用脑之人啊，这分析的，佩服佩服</p>
<p>2011年8月16日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://www.9sh.net/" title="仁心博客" target="_blank"><img src="" alt="仁心博客"></a></li>
</ul>
<p><a href="http://www.9sh.net/" target="_blank">仁心博客</a></p>
<p>文字好多 啊</p>
<p>2011年8月29日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://yaojingguo.iteye.com/" title="小雨" target="_blank"><img src="" alt="小雨"></a></li>
</ul>
<p><a href="http://yaojingguo.iteye.com/" target="_blank">小雨</a></p>
<p>有道理。</p>
<p>2011年9月19日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://zwl.me/" title="守候幸福" target="_blank"><img src="" alt="守候幸福"></a></li>
</ul>
<p><a href="http://zwl.me/" target="_blank">守候幸福</a></p>
<p>和高中学习一样，有些人一下子就会了 而且融汇贯通</p>
<p>2011年9月21日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://www.stonecrushermobile.org/" title="stone crusher" target="_blank"><img src="" alt="stone crusher"></a></li>
</ul>
<p><a href="http://www.stonecrushermobile.org/" target="_blank">stone crusher</a></p>
<p>不错。支持</p>
<p>2011年10月9日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://www.popbedding.com/" title="train quilt" target="_blank"><img src="" alt="train quilt"></a></li>
</ul>
<p><a href="http://www.popbedding.com/" target="_blank">train quilt</a></p>
<p>文章很好。另外，验证码也太长了···</p>
<p>2011年10月10日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://stackpop.org/blog/" title="stackpop" target="_blank"><img src="" alt="stackpop"></a></li>
</ul>
<p><a href="http://stackpop.org/blog/" target="_blank">stackpop</a></p>
<p>呵呵~算法到底是像奥数一样的东西还是什么？</p>
<p>2011年10月10日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://www.a891.com/" title="芳草集" target="_blank"><img src="" alt="芳草集"></a></li>
</ul>
<p><a href="http://www.a891.com/" target="_blank">芳草集</a></p>
<p>文字好多 啊</p>
<p>2011年10月27日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://blog.csdn.net/ty1921" title="Ty1921" target="_blank"><img src="" alt="Ty1921"></a></li>
</ul>
<p><a href="http://blog.csdn.net/ty1921" target="_blank">Ty1921</a></p>
<p>上班偷空来瞅着终于更新了，只是比以前长的多，晚上回去细看。
想起前两天的小事：看京东有卖大大的书，买回来一看，后面有一部分算法方面的，给读中学的小弟是不成了，又舍不得，最后让他撕了前一半（暗时间...），我撕了后一半 - -/#</p>
<p>2011年11月3日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="zy498420"></li>
</ul>
<p>zy498420</p>
<p>寻找特定解的过程是个构建无噪声有损信道的信息传递过程，前提条件是信源，信息量损失越小，所得结果更general的概率越高。对于有限字符集和离散无记忆信源寻找前缀码编码表的过程，显然码率越好结果算是更general。该问题信源中有效信息是（前提条件）：字符集对应分布值的比例（绝对值无意义，属于无效信息，信道可以丢失这个信息），互斥事件加法法则（不同字符独立且互斥，“或”的概率可以直接相加），对结果的最优化要求是一个约束，也就是对信道本身做了一些限制，要求某些结果集的概率为0。太困了，改日再说。</p>
<p>2011年12月6日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="haozijun"></li>
</ul>
<p>haozijun</p>
<p>第一次来到这里，作者写的真是深奥，5年没有碰数学了，关于信道什么的都忘光了，现在想要捡起来。向楼主学习。也希望能和楼主交流，我的QQ229742946，希望加我</p>
<p>2012年5月23日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="Zhen"></li>
</ul>
<p>Zhen</p>
<p>Hi, your word 事半功倍 is misused. It is 事倍功半 if I am right.
Thanks</p>
<p>2012年3月12日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="伊生臻爱"></li>
</ul>
<p>伊生臻爱</p>
<p>未鹏大哥，你应该是计算数学专业吧，现在改名叫信息与计算科学，我也是这个专业，但是觉悟远远不如你，像你看齐，还好现在才大二，大一基本玩过去的，专业课都没学，要补啦，像数分、高代的，全要补。。。</p>
<p>2012年3月28日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="raof01"></li>
</ul>
<p>raof01</p>
<p>且不说算法如何难，就尾递归而论，虽然不太复杂，也需要经过“试错、联想……”等一系列探索，才能真正掌握，才能应用到实际问题中去</p>
<p>2012年5月24日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="story"></li>
</ul>
<p>story</p>
<p>刘老师，不知道能否写写有关编程语言的学法，您的博客正是有种相见恨晚的感觉</p>
<p>2012年8月10日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://xq.com.nu/" title="haitao" target="_blank"><img src="" alt="haitao"></a></li>
</ul>
<p><a href="http://xq.com.nu/" target="_blank">haitao</a></p>
<p>构造算法不难，论证才难！
比如，我设计了一个加密算法、伪随机生成算法，怎么验证加密强度、随机程度，真的难！</p>
<p>2012年8月13日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="路人"></li>
</ul>
<p>路人</p>
<p>个人猜测整楼的评论没有一个学历超过研究生的</p>
<p>2012年8月18日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://blog.yejintao.cn/" title="叶金涛" target="_blank"><img src="" alt="叶金涛"></a></li>
</ul>
<p><a href="http://blog.yejintao.cn/" target="_blank">叶金涛</a></p>
<p>数学是计算机的根基，算法是编程的根本，知其所以然，才能用科学的眼光探讨问题。这也是专业培养所在——计算机科学与技术。</p>
<p>2012年8月21日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://www.zwjdjx.com/" title="折弯机模具" target="_blank"><img src="" alt="折弯机模具"></a></li>
</ul>
<p><a href="http://www.zwjdjx.com/" target="_blank">折弯机模具</a></p>
<p>算法总是在变啊，哎，计划永远赶不上变化啊</p>
<p>2012年10月26日<a href="">回复</a><a href="">顶</a><a href="">转发</a><a href="">举报</a></p>
<ul>
<li><a href="http://weibo.com/feiyuliu" title="Feythin Lau" target="_blank"><img src="" alt="Feythin Lau"></a></li>
</ul>
<p><a href="http://weibo.com/feiyuliu" target="_blank">Feythin Lau</a></p>
<p>数学是算法的基础，算法是程序的灵魂。。。</p>
<p>2012年11月3日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://www.renren.com/profile.do?id=282621198" title="杨翼" target="_blank"><img src="" alt="杨翼"></a></li>
</ul>
<p><a href="http://www.renren.com/profile.do?id=282621198" target="_blank">杨翼</a></p>
<p>总是知其然不知其所以然</p>
<p>1月3日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://ifeve.com/" title="并发编程" target="_blank"><img src="" alt="并发编程"></a></li>
</ul>
<p><a href="http://ifeve.com/" target="_blank">并发编程</a></p>
<p>知其然容易，知其所以然难。而对于算法必须要知其所以然。</p>
<p>1月21日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
]]></content>
    
    
      <category term="好文摘录" scheme="http://itsolife.com/categories/%E5%A5%BD%E6%96%87%E6%91%98%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《Rework》摘录及感想]]></title>
    <link href="http://itsolife.com/2014/02/03/2014-02-03--%E3%80%8ARework%E3%80%8B%E6%91%98%E5%BD%95%E5%8F%8A%E6%84%9F%E6%83%B3/"/>
    <id>http://itsolife.com/2014/02/03/2014-02-03--《Rework》摘录及感想/</id>
    <published>2014-02-03T03:24:29.000Z</published>
    <updated>2014-03-07T03:32:03.000Z</updated>
    <content type="html"><![CDATA[<h1 id="-rework-">《Rework》摘录及感想</h1>
<p>2013年3月11日 <a href="http://coolshell.cn/articles/author/haoel" title="由 陈皓 发布" target="_blank">陈皓</a> <a href="">发表评论</a> <a href="">阅读评论</a> 36,592 人阅读    </p>
<p><img src="" alt="">读了《Rework》这本书好多遍，每次读都有不同的感想。但从来没有把这些感想记录下来，今天把《Rework》书中的一些章节做一些摘录，并把我的一些感想总结出来。供大家参考。这是一本平生以来让我中毒很深的书，也是一本让我思考得很多的书。希望看到这篇文章的人都能好好地读读这本书。这本书并不难读，是一本你可以一口气不中断就可以读完的书。</p>
<h3 id="-">现实世界</h3>
<p>“这在现实世界里面行不通”，当你向人们介绍一个新创意时，人们总是这么回答你。这个“现实世界”听起来如此令人沮丧，……只有人耳熟能详，习以为常的事情才会胜利，即使是这些事情已经漏洞百出陈腐低效。</p>
<p>揭开“现实世界”这个锅盖，你会发现居住在里的人都充斥着悲观主义和失望的情绪。更糟的是，他们想将别人拖进他们的坟墓。如果你是充满希望和野心的人，他们会试着说服你，你的想法是不可能的。他们会说你在浪费时间。</p>
<p><strong>“现实世界”并不存在，那只是人的一个借口。只是某些人为了开脱 自己的无所作为，跟你一点关系也没有。</strong>
<strong>感想</strong>：我经常会向一同事和朋友提及一些我的想法，朋友同事们经常会回答我——这个事某某人，某某团队做过了，没成功。或是对我说，你做这个事的时候，要小心这个要小心那个。我觉得，这个时候是最考验我们的时候了，要有一个清醒的头脑去分析别人的话，别人真不代表自己。这个世界上大多数人都是比较保守的，大多数都对这个现实世界都有或多或少的恐惧感。当然，你可以选择做大众，但是如果你想让你的人生有些不同，有些精彩，我还是建议你不要和大多数人想得一样，<strong>如果你和大多数人的想法一样，你必然会和大多数人一样的平庸</strong>。当然，如果你和大多数人不一样，你要么就是天才，要么就是傻瓜。要证明你自己是不是傻瓜，我们可以看看我们过去有没有过一些小成功或小成绩。如果有，那么就应该大胆地坚持自己的想法。</p>
<h3 id="-">被高估的“从错误中学习”</h3>
<p>你真的从错误和失败里面学到什么了吗？你也许学到了别再重蹈覆辙，但是这有什么意义吗？你仍然不知道接下来该做什么。</p>
<p><strong>相反的应该从成功中汲取养分。成功給予真正靠得住的教材。</strong></p>
<p>失败并不是成功的先决条件。自然规律是，<strong>逗留在过去的失败中是无法进化的，进化是建立在成功的基础上的</strong>。
<strong>感想</strong>：我见过和很多人都在抱怨这不好那不好，但是他们其实并不知道什么是好的，因为——没有见过好的，你将永远不知道什么是好的。就好像你没有见过什么是汽车，你就只会整天在抱怨为什么骑自行车太累。回头想想我们的编程的这个过程也是一样，我们编程技能的提高基本上都是在看到别人的那些漂亮优雅的代码。所以，你一定要去看看那些优秀人干是怎么想的，怎么干的，去那些成功的公司开开眼界。另外，你应该多想想你过去做成功过什么事？那些才是你的长处，才是让你进化的前提。</p>
<h3 id="-">计划就是瞎猜</h3>
<p>除非你是算命先生，长期的商业计划是种幻想。有太多的事实证明那是超出你的掌控的：市场环境、对手、顾客、经济等等。做计划让你觉得一切尽在掌握但实际上你没有。</p>
<p><strong>当你把计划变成猜测时，就等于进入一个危险的境地。做计划就是在用过去推导未来，等于给你戴上了眼罩。</strong>
<strong>感想</strong>：你有职业规划吗？如果你有的话，那么你就一定就错了。职业规划是一件很扯淡的事情。我和一些高手都交流过，其实这些人在当初都并不有什么职业规划的，要说有的话，也就是想把技术搞透搞精。这些人在一开始从来没有想过要当个什么经理或是什么架构师之类的东西，这些人就是对技术有非常大的热情，把身边的那些看得见够得着的事情做到好好地，并且保持不持续强大的好奇心努力地学习自己不懂的东西。一个坚定不移的决定和意志力会比任何的计划和职业规划都重要。<strong>你问问自己，想不想当程序员，能不能一辈子都当一个程序员，能不能写程序写一辈子？</strong>（关于做一辈子程序员这个事，大家可以看看我的<a href="http://weibo.com/1401880315/zmebaF5tQ" target="_blank">新浪微博</a> ——<em>没哪个行业能像计算机行业这么活跃、刺激和有趣了。不仅是新兴工业革命的主力，又渗入到所有的行业中，干一辈子值了。//<a href="http://weibo.com/n/_%E4%BD%A0%E4%BA%B2%E7%88%B1%E7%9A%84%E5%81%8F%E6%89%A7%E7%8B%82" target="_blank">@_你亲爱的偏执狂</a>: 程序员首先是工程师，Professional，就跟律师，医生一样，给大家解决问题；但是另一面呢，又是艺术家，创造新奇好玩的东西。这样的职业做一辈子有什么问题？</em>）</p>
<h3 id="-">拒绝壮大</h3>
<p>规模越大你就得承受更大压力、需要更专业、拥有更强的能力。</p>
<p><strong>有没有注意到，一个小公司希望自己变大时，大公司却想要变得灵活变通</strong>。记住，一旦你变大了就很难在不解雇人、不破坏士气、不改变你的整个商业路线的情况下收缩规模。</p>
<p>扩张不必成为你的目标。我们也不是仅在讨论你已有员工数。 还有花费、租金、IT 基础结构、设备等。这些事情不会碰巧发生。 你来决定是否承受这些。如果你决定去承受，你也将遇到新的头痛问题。花费那么多，你强迫自己构建一个复杂的生意，有一大堆困难而高压的事情要解决。</p>
<p><strong>小公司并不是一个起步，小公司本身就是一个伟大的目标。</strong>
<strong>感想</strong>：很多人都会以为拥有一支成百上千人的团队而成为一个成功的标志。就像很多朋友和猎头都会问我管多少人，当我说，我就管个十人不到的团队时，他们似乎都会觉得我很平庸。他们中的一些人基本上就不会再问我在干些什么了，因为他们可能觉得这么少的人都干什么大事呢？。当然，我说了他们也不一定听得懂。人多可能恰恰说明你可能在干一个劳动密集型的事情，这并没有什么可自豪的。真正自豪的不是在战争中用人海战术让大量的人去当炮灰，而是用一个小分队端掉敌军的军火库或指挥部。所以，<strong>关键不是你有多少人，关键是你做的事是不是有非凡的意义，而且你用了最小当量的资源。这就好像建立一个高性能的网站一样，用成百上千的服务器不算本事，谁用的少才是本事</strong>。</p>
<h3 id="-">工作狂</h3>
<p>工作狂的行为不但没有必要，而且愚蠢至极。过多的工作并不代表你对项目更关注，也不代表你作了更多的贡献，这仅仅意味着你干了更多的活而已。<strong>工作狂制造的麻烦比解决的麻烦多</strong>。</p>
<p>工作狂往往不得要领。他们花大把大把的时间去解决问题，<strong>他们以为能靠蛮力来弥补思维上的惰性，其结果就是折腾出一堆粗糙无用的解决方案</strong>。</p>
<p><strong>如果你只是为了工作而工作，那么你就会丧失判断力。你的价值 观和决策方式都是扭曲</strong>。你没有能力去判断哪些工作值得做，哪些工作该放弃，最后搞得自己筋疲力尽，而一个筋疲力尽的人是无法作出明智的决定的。</p>
<p><strong>工作狂不是英雄。他们不是在节约时间而是在浪费生命。真正的英雄早已想出了办法，搞定一切，然后回家了。</strong>
<strong>感想</strong>：这让我想到了那些为了冲业绩的业绩KPI的制订者们，很多时候，他们的价值观和决策真是的很扭曲的。他们生生地把一种技术密集型的工作变成了劳动密集型。<strong>他们其实就是在拼命地训练客户需要的那匹“更快的马”，而从来没有想过要去造个更快的交通工具。</strong></p>
<p>另外，每当我在优秀员工的评比和员工的绩效考核中的跨团队比较中我们能听到很多很多的人说，XX员工工作任劳任愿，工作得很晚很晚，付出很大。老实说，我真的为这样的价值观感到悲哀。最后，我还想说说关于超时工作，我也经常学习和做自己的事情到深夜，我相信很多人也这样，但我们应该认真思考一下Rework中的这个观点，<strong>我们超时工作是在使用蛮力呢？还是在使用热情和兴趣呢？</strong></p>
<h3 id="-">挠自己的痒处</h3>
<p>想要创造一款伟大的产品或者是某项卓越的服务，最直接、最简单的方法就是去做你自己想用的东西。设计你了解的产品——你就能很快发现它到到底好不好用。</p>
<p><strong>最棒的是，“解决你实际遇到的问题”会让你爱上你做的事情</strong>。 你知道问题所在并且熟知解决它的价值。这是无法替代的。毕竟，你会充满希望的在接下来的日子里继续做。 甚至会占据你余生所有时间。所以，最好还是做自己真正关心的东西。
<strong>感想</strong>：这就是吃自己的狗食，做自己感兴趣的事。软件项目中，我最恨的就是那种闭门造车造出来的自己都不用的东西（不是从已有业务生长出来的东西），以及那些自己不动手就在边上指指点点的各种咨询师或是喜欢动用行政命令的高层管理者。</p>
<p>但是，在这里，我更想说说我所理解的另一层“挠自己痒处”——有天我和一前前同事聊天，她说她在那家公司十多年了，现在老了，虽然心不老还想折腾，但是对自己的能力没自信，求稳了。我听到很多朋友想对自己有个改变，比如有QA的同学想做开发，有生活在内地的朋友想来大城市的大公司里有更爽的经历，<strong>这些人明明想活得更有激情，但最终在现实面前认命妥协。我说既然有痒处，还比较痒，那就应该毫不犹豫革自己的命，轰轰烈烈地活一次</strong>。别等老了后悔当年没有勇气。“挠自己痒处”就是挑战自己，革自己的命，既然想了，就做吧，生命只有一次，值得我们轰轰烈烈地去为之付出。</p>
<h3 id="-">“没时间”不是借口</h3>
<p>人们最常用的借口是：“时间不够。”他们宣称很想开一家公司，学一种乐器，写一本书，等等，但时间不够用。拜托，如果你善加利用，时间总是有的。</p>
<p>把看电视或玩魔兽的时间腾出来完成你的创意；把10点上订改成11点上床，这不是怂恿你通宵达旦或是一天干足16个小时——我们要说的是，第周匀出一些业余时间来，就足够你去做些事情了。</p>
<p>当你拥有某种强烈的渴望时，你就能挤出时间来——不管你身上是否背负着其他责任。<strong>事实上，真相是大多数的渴望并不是那么强烈。于是他们拿时间当借口来自我开脱。别给自己错口。</strong></p>
<p>另外，永远会有正当其时的时候，你总会觉得自己会么太年轻，要么太老，要么太忙，太穷，或是别的什么原因。<strong>如果你总是为遇到一个完美时机而发愁，那么，完美的时机绝对不会到来</strong>。
<strong>感想</strong>：我在“<a href="http://coolshell.cn/articles/7048.html" title="挑战无处不在 " target="_blank">挑战无处不在</a>”中也表达过这样的观点，<strong>关于热情和态度，说白了就是不要给自己找借口</strong>。比如：“工作忙事多没时间学所以可以不懂”，“工作中没用到所以可以不懂”，“工作没有挑战，一直没有遇到合适的项目”等等。而且，如果你只能在万事俱备的情况下才能做事，那么，你还有什么价值呢？人的价值和竞争力就是在条件并不完美的时候还能搞定事情。</p>
<h3 id="-">画沙为界，立场明确</h3>
<p>坚定的信念能为你赢得超级粉丝，他们会为你马首是瞻，会舍身保护你，他们充满激情的口碑传播将胜过这世间一切的广告。</p>
<p>强大的主见，也是要付出代价的，在这个过程中，会有人诋毁你，说像傲慢，冷漠。没办法，这就是人生，有人喜欢你，就有人憎恨你。如果你的说法没有引起任何人的心烦意乱，只能说明你的推广力度可能还不够。（也可能代表你比较无趣）</p>
<p><strong>对我们来说，我们的产品所不能处理的和我们的产品所能处理的一样令人感到骄傲</strong>。</p>
<p>我们的产品不适合每一个人，没有关系，我们愿意为了那些更加深爱我们的客户而放弃另一部分客户。这就是我们的立场。
<strong>感想</strong>：我从来不想做一个大众脸。酷壳上有很多比较有争议的文章，也有很多人说我很极端，偏执，有优越感，清高……，说什么的都有，无所谓。我有一个做新闻编辑的太太，主辑要求文章要客观和没有观点，不温不火，本来好好的一篇有观点的文章被编辑过后只剩下了一堆食之无味的文字。<strong>我喜欢有鲜明的观点，因为鲜明的观点和立场能不但能让文章鲜活起来，而且还能迎来更多的不同意见和更多的思考</strong>（而不只是“顶”“赞”之类无意义的回复）。我并不希望我的观点是正确的，我只希望能和更多的人加入我一同思考，而思考最佳的催化剂就是争论。我从这个行为中收益到了很多很多。</p>
<h3 id="-">找好退路无异于失败</h3>
<p>你还常常听到：“你的退出战略是什么？（万一不成功，你怎么办）”甚至在你刚开始启动时就听到它。这些人不知道怎么开始就要想到怎么结束？急什么呢？如果在全情投入之前就想怎么撤出，这种逻辑不是一般的混乱。</p>
<p>你正打算恋爱一场就计划着分手？你在第一次约会时就签订婚前协议？你会在婚礼早上先约见离婚律师？那也太荒谬了吧。</p>
<p><strong>你需要的是承诺战略而不是退出战略。你要考虑的是你的项目怎样发展和成功，而不是怎样撤退</strong>。如果整个战略是基于撤退的，一开始你就不会有机会成功。
<strong>感想</strong>：几年前，我有一个朋友被创新工场忽悠从美国退学回来创业，我非常质疑他退学创业这个事。他对我说，没事，反正就算失败我也不会失去什么。还有一个朋友一年前从美国回国创业，也对我说，就算没搞好也没什么。我都对他们说，如果你以为用试一试的态度就可以把一个事情搞成功，那么你让这世上那些Full Time全天候从事这个事情的并有一些积累的人情何以堪？如果你创业时都想好了失败，那就说你你对这个事没有必胜的信心，也说明连你自己都不相信这个事，你还干个什么劲啊？<strong>你与其把时间用在思考如果创业没成功你会怎么办上，你还如去思考一下如何做才有更大的胜算</strong>。</p>
<h3 id="-">条件受限是好事</h3>
<p>“我没有足够的时间、钱、人手、经验”。不要现无谓的抱怨了。“少”不是什么坏事。“条件受限”貌似缺陷，实力优势。有限的资源能激发你在现有的条件下完成任务的能力。没有一点浪费空间，一切都需要你发挥最大的创造力。</p>
<p>你见过囚犯用肥皂和汤勺制作武器吗？你们是“创新”的典范。只有在条件受到限制时，我们才会发挥出“小材大用”的能力。
<strong>感想</strong>：我相信这世上很多事情都是被条件受限逼过去的。我回想到我以前经常在干的性能调优，想尽一切办法榨干系统资源这件事上，我就无法不赞同这句话。想想淘宝的TFS，就是一个因为条件受限到了不得不自己干的时候，被逼出来的东西。如果你没有足够多的人，你才会去想要怎么去优化工作和开发效率，于是才会逼着你去开发一些自动化的工具，而这些工具恰恰解放了生产力可以让你更快地干更多的事。<strong>只有条件受限，才会从劳动密集型中激发出知识密集型的东西</strong>。再回到以前我的那篇“<a href="http://coolshell.cn/articles/6994.html" title="我们需要专职的QA吗？" target="_blank">是否需要专职的QA</a>”一文说的到东西，如果你有很多很多帮你做测试的QA，你就不会去测试，你的团队也就不会有自动化测试等工具。这就好像在中国这个劳动力又多又廉价的大国下，基本上不需要你在技术上的创新，你只需要去不断地迁就这些低端用户，迁就这些用户越多，你还能有什么重大创新吗？真正的创新是帮助用户成长，而不是迁就用户。</p>
<h3 id="-">与其做个半成品，不如做好半个产品</h3>
<p>同时做N件事的结果就是：一大把绝妙的点子最后被转化成一个蹩脚的产品。</p>
<p>有舍才有得，砍掉多余的野心，你就会发现慢慢做一件正事要胜过毛毛躁躁地做一堆傻事。</p>
<p>很多东西都是越简短越好。拿起斧子动手砍吧，为了一个“伟 大”的起点，让我们把那些“挺不错”地枝节给砍掉吧。
<strong>感想</strong>：这正如“<a href="http://coolshell.cn/articles/3605.html" title="为什么中国的网页设计那么烂？" target="_blank">为什么中国的网页设计这么烂</a>”中说的：“中国的学生只是去记忆东西而不是真正的理解。他们从来不花时间去思考，而只是贪婪地去获取更多的信息”。与其记忆那么多的东西，还不如好好理解部分的东西。还有一种说法是：“Done is better than Perfect!”，这句话某些时候说得也挺对的，尤其是对于那些完美地长期不能Done的项目。但是Done一个Ugly的东西还不如不做。所以平衡Done和Perfect的方式正好就是这句话——“与其做个半成品，不好做好半个产品”，因为，<strong>一个半成品会让人绝望，而半个好产品会让人有所期望，这就是其中的不同</strong>。</p>
<h3 id="-">关注不变因素</h3>
<p><strong>很多公司和人都关注即将到来的大事件。他们热衷于新鲜热辣的事物，追逐最新的潮流和技术</strong>。</p>
<p>这是一条愚笨之路。一旦走上这条路，你就会关注时髦、放弃本质，把注意力放到不断变化的事物上，而不是持久不变的事物上。</p>
<p>你的事业的核心应该建立在不变的基础之上。<strong>你应该投资于那些人们现在需要，并且十年后仍然需要的事物上</strong>。</p>
<p>要记住，时尚会凋零。只有当你聚焦于长久的功能时，你才会发现自己把握住了永不落伍的东西。
<strong>感想</strong>：一年多前，我在《<a href="http://coolshell.cn/articles/5815.html" target="_blank">来信、创业和移动互联网</a>》中谈到过那个时尚的“移动互联网”，说了四个方向：阅读，分享交流，电商，推荐/提醒。大家可以看到现在地铁上已经不像以前很多人都在看报纸了，而是很多人都在看手机。而手机端的社交（分享和交流），电子商务，以及很多推荐、提醒都越来越火了。这些东西都是都是“常量”——十年前存在，未来十年也会存在，我们看到很多人太过着眼于手机上的应用，而不是那些不变的因素。今天还有两个巨火无比的流行词，一个是云计算，一个是大数据，那些一听到这两个词就会兴奋的人，我不知道他们有没有真正理解这两词？他们真正理解了云计算其实就是那个N多年前就提过的IT服务，关于大数据，我完全不知道为什么会火，你会因为听到中国人口有13亿你就会兴奋吗？老鼠的数量比较这个更多呢，呵呵。其实，数据无所谓大小之分，只有好数据和烂数据之分，还热数据和冷数据之分。十年前有两个更为流行的词：一个是计算网格，一个是数据网格，这两个词5年前就凋零了，今天的云计算和大数据，有多少人意识到了其中有什么相通的，或是其中的不变因素是什么？<strong>大数据和云计算其实都在描述两个东西，一个是超大规模的计算能力，另一个则是服务。还有一个词是“平台化”，这可能被大家忽略了，通过平台进行计算和数据服务，这才是那计算机存在以来基本不变的东西，无论你是移动互联网，还是互联网，不管是云计算，还是大数据，都需要一个平台提供服务</strong>。</p>
<h3 id="-">会议有毒</h3>
<p>世人最可恨的打扰莫过于开会。原因是：</p>
<ul>
<li>会议中充斥着纸上谈兵和抽象的概念，大多是不切实际的。</li>
<li>会议中能传达的信息量少之又少。</li>
<li>人们在会议中容易跑题，堪比暴风雪里的芝加哥出租车还容易迷失方向。</li>
<li>会议要求做充分的准备，但是大多数人没有时间准备这些。</li>
<li>会议制定的议程常常是模糊的，根本就没有人真正清楚目标是什么。</li>
<li>会议中难免会轮到那么一两个低能人士发言，于是大家的时间都浪费在他们的扯淡上了。</li>
<li>会议具有自我繁殖功能。一次会议总能导致另外一次，以及再导出下一次，生生不息……
<strong>感想</strong>：这世上除了“他爹的TDD”开发模式，还有“他妈的TMD”开发，就是Team Meeting Driven，很多公司有太多太多的会要开了，开会基本上成了每天工作最主要的东西，对于一些管理者来说一星期中居然有80%时间都在开会。其实，这么多的会议并不意味着你在管理，只是意味着你对要管的东西完全不知道，需要通过开会来了解。很多会完全是没有议题的，大家坐在一起东拉西扯，非常非常地低效。我通常把这种会叫做“神仙会”，用个流行语来说，就是Cloud Meeting，大家神一要的各说各的，似乎，没有这种形式，不能证明参会者的存在，用会议来证明他们的存在，相当的可笑。对我来说，<strong>如果只是带一个或几个问题来开会，简直是就是扯谈，如果对于问题没有几个备选的解决方案和各方案的评估，完全没有必要开会</strong>。Amazon的会议是不会有PPT的，会议组织者会要要讨论的东西写好并打印出来，在会前给参会者把要讨论的东西打印出来，开会前10分钟左右，会场里没有任何声音，每个人都在读文档，全部人读完后，直接对议题发表自己的个人意见应该怎么干，然后很快形成共识，散会。</li>
</ul>
<h3 id="-">人人都得干活</h3>
<p>在一个小团队里，你需要的是干活的人，而不是监工。每个人都得做事，没有人可以袖手旁观 。</p>
<p>这意味着你在招聘中要避免招到监工型的人物，这些人喜欢对别人谆谆教导。对于小团队来讲监工型的人就是累赘。</p>
<p>监工们还喜欢把人拖去开会。实际上，会议是监工们最好的朋友，因为只有在开会时才显得出他们的重要。
<strong>感想</strong>：<strong>为什么会有办公室政治，那就是因为这个公司里有一部分人不干活，不做事，</strong>于是，他们就有大量地时间开始胡思乱想，他们花大量的时间不是想怎么去做事，而是想自己怎么更容易的打垮别人得到上面的认可，从而得到晋升。在大公司中这样的情况会比Startup的公司多得多。所以，如果你不想滋生办公室政治，那么你需要干两个事，第一个是最好不要变成大公司，第一个是让每个人都在实干。我最近看到其大公司，虽然很多东西不规范，而且很多东西在野蛮生长，有些事情也有点土，但绝大多数人都在实干，所以，只要每个人都在实干，就算干的方式不好，干出来的东西有问题，也比那些滋生办公室政治的公司强上几百倍</p>
<h3 id="-">拒绝照搬 &amp; 将你的产品去商品化</h3>
<p>有时候，照猫画虎也是一种学习过程，就好像艺术系的学生通过临摹美术馆的作品来学习绘画。当你还是一个学生时，这种模仿是一种很有效的学习工具。不幸的是，商业战场上的模仿却不招人待见。而这也意味着你打算通过当盲从者或抄袭者的方式来建立你的事业，这注定是一个失败模式。</p>
<p>模仿的问题在于，简单的复制扼杀了深层的理解——而理解才能激发成长。你不但要知其然，还要知其所以然。而当你复制时，你会忽视这一点。你照搬的只是表面，而不是本质。</p>
<p>一旦你扬名立万，模模仿者会蜂拥而至，这就是生活。但你可以用一种绝佳的方式来保护自己不被 他们吞没：让你自己成为你的产品或服务的一部分。
<strong>感想</strong>：在《<a href="http://coolshell.cn/articles/7617.html" title="抄袭，腾讯 和 产品" target="_blank">抄袭，腾讯 和 产品</a>》中我谈到过这个事情，虽然我对抄袭和山寨很反感，但是我不得不承认这是这个世界的一部分，好的东西总是会被人复制的，这也不一定是一个坏事，这会让你更清楚认识到什么是真正产品的价值，什么是核心竞争力，你但凡有一点急功近利的想法你都要想一想那堆抄袭者，其中还不乏有钱有人的专业抄袭的公司。而面对被抄袭这样的事情，最好的解决方法是着眼着远期而不是短期——<strong>如果你着眼短期，你无疑会面对众多的抄袭和模仿者让你万劫不复，但是，如果你着眼长期，做一个3-5年需要花费大量精力才会成熟的产品，那么，那些急功近利的抄袭者会知难而退的，因为长期并不符合抄袭者的价值观</strong>。</p>
<h3 id="-">做得比对手少</h3>
<p>传统智慧告诉我们，要想打败竞争者就要胜人一筹。如果人家有 4 个功能，你就得 5 个（或者 15 个，25 个）。如果人家花了$20,000，你就得花 $30,000。如果人家有 50 个员工，你就得要 100 个。</p>
<p>这样的冷战式的攀比思维会把人引上绝路。一旦被卷入“军备竞赛”，你就陷入了一场无止境的战争，这场战争会让你耗费大量的金钱、时间和动力。并且使你陷入长期的防御战中。处于防御状态的公司是没有预见力的；他们只能后知后觉，他们无法领跑，只能尾随。</p>
<p>那么你应该怎么做呢？比你的竞对手做得少，以此来打败他们。<strong>让自己去解决简单的问题，把那些纠结的、麻烦的、艰难的、讨厌的难题留给竞对手去解决</strong>。不要总想着去胜人一筹、去超过别人，试试相反的做法。</p>
<p>不要因为你的产品或服务不如别人的花哨就感到自惭形秽。把他们做得醒目高调，并引以为傲。就像对手那些强有力的销售他们多功能的产品一样销售你那简约的产品。
<strong>感想</strong>：一个最典型的例子就是iPad，它干得比Laptop少，比上网本少，就是一个很简单的上网和简单游戏的设备，但是他有非常简单的用户体验，让两三岁的儿童和六七十岁的老人都能很快上手。你相信吗？我花了好多年都没教会我父母用电脑以及手机里除了电话功能外的其它功能，但我只花了10分钟就教会他们使用iPad上网了。这就是“做得比对手少”的强大。<strong>只有简约的东西，才会显得更精致，才会显得更专业</strong>。</p>
<h3 id="-">谁在乎他们在干什么</h3>
<p>不管怎样，终究是不值得过于关注你的竞争者。为什么？因为<strong>关注别人太多会让自己受到困扰</strong>。他们现在在做什么？他们下一步呢？我们该怎样作出回应？</p>
<p>每一个小小的动作都会被分析一下。那是一种可怕的心态。这会产生不可抗拒的压力和焦虑。这样的想法会滋长不好的东西。</p>
<p>这是没有意义的事情。竞争者的风景时时在变。你的竞争对手明天一个样儿，今天一个样儿。完全在你控制之外。去担心你所不能控制的事情有意义吗？</p>
<p>过于关注竞争者会混淆你的视野。当你一直吸收别人思想时， 你的机会则会减少。你变得反动而不是充满想象力。你只不过是将你竞对手的产品换了个包装。</p>
<p>如果你打算做一个“the iPod killer”或“the next Pokemon”，你已经死了。你是在承认你的竞争者所设定的参数。你没有跳出 Apple 的套路。他们制定了这个游戏规则。你不可能打败制定规则的那个人。你必须重新制定一个规则，而不是稍微改建一点点。
<strong>感想</strong>：这个社会浮躁之处就在于我们太多的观注了别人，人比人气死人。我们很多人都注意到了别人的风光，看到别人创业被注资，看到别人找到了好的工作，看到了别人不走正道而发达，看到了别人很轻松还挣得多，甚至看到别人的粉丝比自己多，等等，等等，这些东西让自己的心态变，变得非常地不淡定了。眼红也是魔鬼，因为眼红让人心理扭曲了的例子还少吗？<strong>不要在乎别人干了什么，你应该多看看自己的长处是什么，每个人都有每个人的路，你要做的是按照自己的节奏和自己擅长的方式行事，而不是小猫钓鱼</strong>。</p>
<h3 id="-">养成对客户说“不”的习惯</h3>
<p>说“好的”很容易。我们很容易接受同意一个新功能、同意一个过于乐观的截止日期、笑纳一个平庸的设计。很快，一大堆你曾经说“yes”的事情就发生连锁反应，很多你不想要的东西越堆越高，甚至你都看不出原来想要的东西。</p>
<p>别相信“顾客永远是对的”这类的话。如果你是一个大厨，你的很多客人说你做的菜太咸或者太烫，你可以改。但是如果有一些挑剔的老主顾要求在宽面条里面加些香蕉，你千万不要理会他们，没关系。若是为了少数顾客的要求而毁了产品不值得。</p>
<p><strong>你的目标是确保你的产品与就是和你合拍的产品，你就是你自己产品最踏实的粉丝。你是最信赖它的那个人</strong>。那样的话，你会说：“我想你也会爱它的，因为我爱它。”
<strong>感想</strong>：亨利福特说过：“如果我要问我的客户要什么，他们会告诉我他们要一匹更快的马”，所以，过份的迁就用户并不是一件好的事，相反会是一件很不好的事。互联网和电视节目一样都有一个万恶的KPI，电子节目那万恶的KPI是收视率，而互联网的万恶KPI是流量。于是<strong>很多公司为了流量开始不择手段，就像电视节目用庸俗化来提高收视率一样，我们的一些互联网产品也使用庸俗化的东西来提高流量。我们要做的是一个让人称道的有品质的产品，而不是一个只有访问量的产品</strong>。</p>
<h3 id="-">不要攀客户的高枝</h3>
<p>也许你曾经见过这样的场景：一个顾客向一家公司投了很多钱。这家公司想要尽可能的取悦那个顾客。为了迎合这个客户的要求而改变自己的产品，渐渐地，你的产品就会脱离普遍客户的基础。</p>
<p>而且，突然有一天，这个大客户绝尘而去，公司则会背负一个包袱——这个产品是围绕着一个已经离开了的人设计的。而其他人没法用。</p>
<p>人在变，环境在变，你不可能满足所有人的所有要求。<strong>公司要对某一类型的客户全情投入，而不是对某个善变的客户唯唯诺诺</strong>。
<strong>感想</strong>：你永远要找到自己的定位，你不可能满足所有的人。就像屌丝们喜欢的北京的动物园批发市场和高富帅们喜欢的北京燕莎商场一样，他们分别订位于不同的用户。你的产品从生下来的那一时刻就应该需要做好定位，是面对什么样的人群。而且，你也不可能实现所有人的需求的。有时候，失去一些客户并不是坏事，<strong>我们要做的是管理我们的客户，让客户认同我们，而不是被客户牵着走</strong>。</p>
<h3 id="-">一夜成名只是传说</h3>
<p>你不会瞬间大红大紫，也不会一夜暴富，你所了解的那些道听途说的“一夜成名”的故事，深挖一点，你就能发现这些成功人士在到达引爆点之前，都已经在这个方向 上苦熬了很长时间。</p>
<p>把一夜成名的迷梦换成一步一个脚印的成长行动吧。道路很艰难，但你必须充满耐心。你得用功去做，在遇到伯乐前，你得努力很长时间。
<strong>感想</strong>：这和我在<a href="http://coolshell.cn/articles/8790.html" title="程序算法与人生选择" target="_blank">程序算法与人生选择</a>一文中所说的那个最短路径的算法的类比一样，与其展望要当什么架构师或是要成为牛人的憧憬，不如把身边看得见够得着的东西学扎实，干出色。一夜成名只是一个传说，你知道酷壳是因为我写十多年的博客，你知道我是因为我积累了十多年的编程，看看酷壳以前介绍过的<a href="http://coolshell.cn/articles/5651.html" target="_blank">王平同学</a>吧。<strong>很多事情都不是偶然的，都是有前兆的，还是我<a href="http://coolshell.cn/articles/7048.html" target="_blank">以前说过的那句话</a>，“如果一件事情以前没有发生过，未来也不会发生”，比如：如果你在学校里，在工作里，你的同学和同事并不经常来向你请教询问你的意见，那么你基本上很难成为一个Leader</strong>。</p>
<h3 id="-13-">员工不是13岁</h3>
<p><strong>当你把员工当孩子看时，人们就会像孩子一样行事</strong>。</p>
<p>当公司里事事都要上报审批时，你就创造出了一种无脑文化。你成功地制造出了老板和员工之间的对立关系。这种关系在咆哮着：“我不相信你！”</p>
<p>当你处处限制员工，比如禁上他们在上班时访问外部网站或是开小差，你会得到什么好处？什么也得不到。人们需要开小差，这有助于打破整日的枯燥单调，花点时间上上Youtube或Facebook不会失去什么。</p>
<p>如果你要监控你的员工，你得想想你要花多少时间和金钱来监管员工。你浪费了多少钱去安装监控软件？你浪费了多少人力资源去监视员工？你浪费了多少时间去写没有人会看的规章制度？<strong>看看这些成本，你很快就发现，对员工的不信任才是最大的开销</strong>。
<strong>感想</strong>：我始终在跟我的团队成员说，最有效的管理就是自己管理自己，而不是还要专们的人来管你。不然的话，你一定会很难受的。如果你能管理好你的工作和任务，我们就不需要项目经理。如果你能管理得好你的做事的方法和流程，就不需要那些搞流程的。如果你能管理得好你的程序质量，我们就不需要QA来监管你…… 等等。<strong>其实，你们如果能管理得好自己，并能自我进化。你们甚至不需要一个经理。但是，你们可能会需要一个为你们跑腿打杂的人，其实，那个人就是经理</strong>。</p>
<p>（全文完）</p>
<p><strong>（转载本站文章请注明作者和出处 <a href="http://coolshell.cn/" target="_blank">酷壳 – CoolShell.cn</a> ，请勿用于任何商业用途）</strong></p>
]]></content>
    
    
      <category term="好文摘录" scheme="http://itsolife.com/categories/%E5%A5%BD%E6%96%87%E6%91%98%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[数据的游戏：冰与火]]></title>
    <link href="http://itsolife.com/2014/02/03/2014-02-03--%E6%95%B0%E6%8D%AE%E7%9A%84%E6%B8%B8%E6%88%8F%EF%BC%9A%E5%86%B0%E4%B8%8E%E7%81%AB/"/>
    <id>http://itsolife.com/2014/02/03/2014-02-03--数据的游戏：冰与火/</id>
    <published>2014-02-03T03:24:29.000Z</published>
    <updated>2014-03-07T03:33:41.000Z</updated>
    <content type="html"><![CDATA[<h1 id="-">数据的游戏：冰与火</h1>
<p>2013年7月31日 <a href="http://coolshell.cn/articles/author/haoel" title="由 陈皓 发布" target="_blank">陈皓</a></p>
<p><img src="" alt="">我对数据挖掘和机器学习是新手，从去年7月份在Amazon才开始接触，而且还是因为工作需要被动接触的，以前都没有接触过，做的是需求预测机器学习相关的。后来，到了淘宝后，自己凭兴趣主动地做了几个月的和用户地址相关数据挖掘上的工作，有一些浅薄的心得。下面这篇文章主要是我做为一个新人仅从事数据方面技术不到10个月的一些心得，也许对你有用，也许很傻，不管怎么样，欢迎指教和讨论。</p>
<p>另外，注明一下，这篇文章的标题模仿了一个美剧《<a href="http://movie.douban.com/subject/3016187/" target="_blank">权力的游戏：冰与火之歌</a>》。在数据的世界里，我们看到了很多很牛，很强大也很有趣的案例。但是，<strong>数据就像一个王座一样，像征着一种权力和征服，但登上去的路途一样令人胆颤</strong>。</p>
<h3 id="-">数据挖掘中的三种角色</h3>
<p>在Amazon里从事机器学习的工作时，我注意到了Amazon玩数据的三种角色。</p>
<ul>
<li><p><strong>Data Analyzer：数据分析员</strong>。这类人的人主要是分析数据的，从数据中找到一些规则，并且为了数据模型的找不同场景的Training Data。另外，这些人也是把一些脏数据洗干净的的人。</p>
</li>
<li><p><strong>Research Scientist：研究科学家</strong>。这种角色主要是根据不同的需求来建立数据模型的。他们把自己戏称为不近人间烟火的奇异性物种，就像《生活大爆炸》里的 那个Sheldon一样。这些人基本上玩的是数据上的科学</p>
</li>
<li><p><strong>Software Developer ：软件开发工程师</strong>。主要是把 Scientist 建立的数据模型给实现出来，交给Data Analyzer去玩。这些人通常更懂的各种机器学习的算法。</p>
</li>
</ul>
<p>我相信其它公司的做数据挖掘或是机器学习的也就这三种工作，或者说这三种人，对于我来说，</p>
<ul>
<li><p><strong>最有技术含量的是 Scientist</strong>，因为数据建模和抽取最有意义的向量，以及选取不同的方法都是这类人来决定的。这类人，我觉得在国内是找不到的。</p>
</li>
<li><p><strong>最苦逼，也最累，但也最重要的是Data Analyzer</strong>，他们的活也是这三个角色中最最最重要的（注意：我用了三个最）。因为，无论你的模型你的算法再怎么牛，在一堆烂数据上也只能干出一堆垃圾的活来。正所谓：Garbage In, Garbage Out ！但是这个活是最脏最累的活，也是让人最容易退缩的活。</p>
</li>
<li><p><strong>最没技术含量的是Software Developer</strong>。现在国内很多玩数据的都以为算法最重要，并且，很多技术人员都在研究机器学习的算法。错了，最重要的是上面两个人，一个是苦逼地洗数据的Data Analyzer，另一个是真正懂得数据建模的Scientist！而像什么<a href="http://coolshell.cn/articles/7779.html" title="K-Means 算法" target="_blank">K-Means</a>，<a href="http://coolshell.cn/articles/8052.html" title="K Nearest Neighbor 算法" target="_blank">K Nearest Neighbor</a>，或是别的什么贝叶斯、回归、决策树、随机森林等这些玩法，都很成熟了，而且又不是人工智能，说白了，这些算法在机器学习和数据挖掘中，就像Quick Sort之类的算法在软件设计中基本没什么技术含量。</p>
</li>
</ul>
<h3 id="-">数据的质量</h3>
<p><strong>目前所流行的Buzz Word——大数据是相当误导人的。在我眼中，数据不分大小，只分好坏。</strong></p>
<p>在处理数据的过程中，我第一个感受最大的就是数据质量。下面我分几个案例来说明：</p>
<h3 id="-">案例一：数据的标准</h3>
<p>在Amazon里，所有的商品都有一个唯一的ID，叫ASIN——Amazon Single Identify Number，这个ID是用来标识商品的唯一性的（来自于条形码）。也就是说，无论是你把商品描述成什么样，只要ASIN一样，这就是完完全全一模一样的商品。</p>
<p>这样，就不像淘宝一样，当你搜索一个iPhone，你会出现一堆各种各样的iPhone，有的叫“超值iPhone”，有的叫“苹果iPhone”，有的叫“智能手机iPhone”，有的叫“iPhone 白色/黑色”……，这些同一个商品不同的描述是商家为了吸引用户。但是带来的问题有两点：</p>
<p>1）<strong>用户体验不好</strong>。以商品为中心的业务模型，对于消费者来说，体验明显好于以商家为中心的业务模型。</p>
<p>2）<strong>只要你不能正确读懂（识别）数据，你后面的什么算法，什么模型统统没用</strong>。</p>
<p>所以，只要你玩数据，你就会发现，<strong>如果数据的标准没有建立起来，干什么都没用。数据标准是数据质量的第一道关卡</strong>，没这个玩意，你就什么也别玩了。所谓数据的标准，为数据做唯一标识只是其中最最基础的一步，数据的标准还单单只是这个，<strong>更重要的是把数据的标准抽象成数学向量，没有数学向量，后面也无法挖掘</strong>。</p>
<p>所以，你会看到，<strong>洗数据的大量的工作就是在把杂乱无章的数据归并聚合，这就是在建立数据标准。这里面绝对少不了人肉的工作</strong>。无非就是：</p>
<ul>
<li><p>聪明的人在数据产生之前就定义好标准，并在数据产生之时就在干数据清洗的工作。</p>
</li>
<li><p>一般的人是在数据产生并大量堆积之后，才来干这个事。</p>
</li>
</ul>
<p>另外，说一下Amazon的ASIN，这个事从十多年前就开始了，我在Amazon的内网里看到的资料并没有说为什么搞了个这样一个ID，我倒觉得这并不是因为Amazon因为玩数据发现必需建议个商品ID，也许因为Amazon的业务模型就是设计成以“商品为中心”的。今天，这个ASIN依然有很多很多的问题，ASIN一样不能完全保证商品就是一样的，ASIN不一样也不代表商品不一样，不过90%以上的商品是保证的。Amazon有专门的团队Category Team，里面有很多业务人员天天都在拼命地在对ASIN的数据进行更正。</p>
<h3 id="-">案例二：数据的准确</h3>
<p>用户地址是我从事过数据分析的另一个事情。我还记得当时看到那数以亿计的用户地址的数据的那种兴奋。但是随后我就兴奋不起来了。因为地址是用户自己填写的，这里面有很多的坑，都不是很容易做的。</p>
<p>第一个是假/错地址，因为有的商家作弊或是用户做测试。所以地址是错的，</p>
<ul>
<li><p>比如，直接就输入“该地址不存在”，“13243234asdfasdi”之类的。这类的地址是可以被我的程序识别出来的。</p>
</li>
<li><p>还有很能被我的程序所识别出来的。比如：“宇宙路地球小区”之类的。但这类地址可以被人识别出来。</p>
</li>
<li><p>还有连人都识别不出来的，比如：“北京市东四环中路23号南航大厦5楼540室”，这个地址根本不存在。</p>
</li>
</ul>
<p>第二个是真地址，但是因为用户写的不标准，所以很难处理，比如：</p>
<ul>
<li><p>缩写：“建国门外大街” 和 “建外大街”，“中国工商银行”和“工行”……</p>
</li>
<li><p>错别字：“潮阳门”，“通慧河”……</p>
</li>
<li><p>颠倒：“东四环中路朝阳公园” 和 “朝阳公园 （靠东四环）” ……</p>
</li>
<li><p>别名：有的人写的是开发商的小区名“东恒国际”，有的则是写行政的地名“八里庄东里”……</p>
</li>
</ul>
<p>这样的例子多得不能再多了。可见数据如果不准确，会增加你处理的难度。有个比喻非常好，<strong>玩数据的就像是在挖金矿一样，如果含金量高，那么，挖掘的难度就小，也就容易出效果，如果含金量低，那么挖掘的难度就大，效果就差</strong>。</p>
<p>上面，我给了两个案例，旨在说明——</p>
<p><strong>1）数据没有大小之分，只有含金量大的数据和垃圾量大的数据之分</strong>。</p>
<p><strong>2）数据清洗是一件多么重要的工作，这也是一件人肉工作量很大的工作。</strong></p>
<p><em>**</em>所以，这个工作最好是在数据产生的时候就一点一滴的完成。</p>
<p>有一个观点：<strong>如果数据准确度在60%的时候，你干出来的事，一定会被用户骂！如果数据准确度在80%左右，那么用户会说，还不错！只有数据准确度到了90%的时候，用户才会觉得真牛B。但是从数据准确度从80%到90%要付出的成本要比60% 到 80%的付出大得多得多</strong>。大多数据的数据挖掘团队都会止步于70%这个地方。因为，再往后，这就是一件相当累的活。</p>
<h3 id="-">数据的业务场景</h3>
<p>我不知道有多少数据挖掘团队真正意识到了业务场景和数据挖掘的重要关系？<strong>我们需要知道，根本不可能做出能够满足所有业务的数据挖掘和分析模型</strong>。</p>
<p>推荐音乐视频，和电子商务中的推荐商品的场景完全不一样。电商中，只要你买了一个东西没有退货，那么，有很大的概率我可以相信你是喜欢这个东西的，然后，对于音乐和视频，你完全不能通过用户听了这首歌或是看了这个视频就武断地觉得用户是喜欢这首歌和这个视频的，所以，我们可以看到，推荐算法在不同的业务场景下的实现难度也完全不一样。</p>
<p>说到推荐算法，你是不是和我一样，有时候会对推荐有一种感觉——<strong>推荐就是一种按不同维度的排序的算法</strong>。我个人以为，就提一下推荐这个东西在某些业务场景下是比较Tricky的，比如，推荐有两种（不是按用户关系和按物品关系这两种），</p>
<ul>
<li><p>一种是共性化推荐，结果就是推荐了流行的东西，这也许是好 的，但这也许会是用户已知的东西，比如，到了北京，我想找个饭馆，你总是给我推荐烤鸭，我想去个地方，你总是给我推荐天安门故宫天坛（因为大多数人来北京就是吃烤鸭，就是去天安门的），这些我不都知道了嘛，还要你来推荐？另外，共性化的东西通常是可以被水军刷的。</p>
</li>
<li><p>另一种是一种是个性化推荐，这个需要分析用户的个体喜好，好的就是总是给我我喜欢的，不好的就是也许我的口味会随我的年龄和环境所改变，而且，总是推荐符合用户口味的，不能帮用户发掘新鲜点。比如，我喜欢吃辣的，你总是给我推荐川菜和湘菜，时间长了我也会觉得烦的。</p>
</li>
</ul>
<p><strong>推荐有时并不是民主投票，而是专业用户或资深玩家的建议；推荐有时并不是推荐流行的，而是推荐新鲜而我不知道的</strong>。你可以看到，不同的业务场景，不同的产品形态下的玩法可能完全不一样，</p>
<p>另外，就算是对于同一个电子商务来说，书、手机 和服装的业务形态完全不一样。我之前在Amazon做Demand Forecasting（用户需求预测）——通过历史数据来预测用户未来的需求。</p>
<ul>
<li><p>对于书、手机、家电这些东西，在Amazon里叫Hard Line的产品，你可以认为是“标品”（但也不一定），预测是比较准的，甚至可以预测到相关的产品属性的需求。</p>
</li>
<li><p>但是地于服装这样的叫Soft Line的产品，Amazon干了十多年都没有办法预测得很好，因为这类东西受到的干扰因素太多了，比如：用户的对颜色款式的喜好，穿上去合不合身，爱人朋友喜不喜欢…… 这类的东西太容易变了，买得人多了反而会卖不好，所以根本没法预测好，更别Stock/Vender Manager 提出来的“预测某品牌的某种颜色的衣服或鞋子”。</p>
</li>
</ul>
<p>对于需求的预测，我发现，长期在这个行业中打拼的人的预测是最准的，什么机器学习都是浮云。机器学习只有在你要面对的是成千上万种不同商品和品类的时候才会有意义。</p>
<p><strong>数据挖掘不是人工智能，而且差得还太远。不要觉得数据挖掘什么事都能干，找到一个合适的业务场景和产品形态，比什么都重要</strong>。</p>
<h3 id="-">数据的分析结果</h3>
<p>我看到很多的玩大数据的，基本上干的是数据统计的事，从多个不同的维度来统计数据的表现。最简单最常见的统计就是像网站统计这样的事。比如：PV是多少，UV是多少，来路是哪里，浏览器、操作系统、地理、搜索引擎的分布，等等，等等。</p>
<p>唠叨一句，千万不要以为，你一天有十几个T的日志就是数据了，也不要以为你会用Hadoop/MapReduce分析一下日志，这就是数据挖掘了，说得难听一点，你在做的只不过是一个统计的工作。那几个T的Raw Data，基本上来说没什么意义，只能叫日志，连数据都算不上，只有你统计出来的这些数据才是有点意义的，才能叫数据。</p>
<p>当一个用户在面对着自己网店的数据的时候，比如：每千人有5个人下单，有65%的访客是男的，18-24岁的人群有30%，等等。甚至你给出了，你打败了40%同类型商家的这样的数据。作为一个商户，面对这些数据时，大多数人的表现是完全不知道自己能干什么？是把网站改得更男性一点，还是让年轻人更喜欢一点？完全不知道所措。</p>
<p>只要你去看一看，你会发现，好些好些的数据分析出来的结果，看上去似乎不错，但是其实完全不知道下一步该干什么？</p>
<p>所以，我觉得，<strong>数据分析的结果并不仅仅只是把数据呈现出来，而更应该关注的是通过这些数据后面可以干什么？如果看了数据分析的结果后并不知道可以干什么，那么这个数据分析是失败的。</strong></p>
<h3 id="-">总结</h3>
<p>综上所述，下面是我觉得数据挖掘或机器学习最重要的东西：</p>
<p>1）<strong>数据的质量</strong>。分为数据的标准和数据的准确。数据中的杂音要尽量地排除掉。为了数据的质量，大量人肉的工作少不了。</p>
<p>2）<strong>数据的业务场景</strong>。我们不可能做所有场景下的来，所以，业务场景和产品形态很重要，我个人感觉业务场景越窄越好。</p>
<p>3）<strong>数据的分析结果</strong>，要让人能看得懂，知道接下来要干什么，而不是为了数据而数据。</p>
<p>搞数据挖掘的人很多，但成功的案例却不多（相比起大量的尝试来说），就目前而言，<strong>我似乎觉得目前的数据挖掘的技术是一种过渡技术，还在摸索阶段。另外，好些数据挖掘的团队搞得业务不业务，技术不技术的，为其中的技术人员感到惋惜</strong>……</p>
<p>不好意思，我只给出了问题，没有建议，这也说明数据分析中有很多的机会……</p>
<p>最后，还要提的一个是“<strong>数据中的个人隐私问题</strong>”，这似乎就像那些有悖伦理的黑魔法一样，你要成功就得把自己变得黑暗。是的，<strong>数据就像一个王座一样，像征着一种权力和征服，但登上去的路途一样令人胆颤</strong>。</p>
<p>（全文完）
<strong>（转载本站文章请注明作者和出处 <a href="http://coolshell.cn/" target="_blank">酷壳 – CoolShell.cn</a> ，请勿用于任何商业用途）</strong></p>
]]></content>
    
    
      <category term="好文摘录" scheme="http://itsolife.com/categories/%E5%A5%BD%E6%96%87%E6%91%98%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[{技术}{多线程}实施并行编程的五大障碍]]></title>
    <link href="http://itsolife.com/2014/02/03/2014-02-03--%7B%E6%8A%80%E6%9C%AF%7D%7B%E5%A4%9A%E7%BA%BF%E7%A8%8B%7D%E5%AE%9E%E6%96%BD%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B%E7%9A%84%E4%BA%94%E5%A4%A7%E9%9A%9C%E7%A2%8D/"/>
    <id>http://itsolife.com/2014/02/03/2014-02-03--{技术}{多线程}实施并行编程的五大障碍/</id>
    <published>2014-02-03T03:24:29.000Z</published>
    <updated>2014-03-07T03:24:30.000Z</updated>
    <content type="html"><![CDATA[<h1 id="-">{技术}{多线程}实施并行编程的五大障碍</h1>
<p>要使用 Google·网上论坛讨论区，请在您的浏览器设置中启用 JavaScript，然后刷新该网页。   <plaintext/><xmp>.</p>
<ol>
<li><a href="https://plus.google.com/?gpsrc=ogpy0&amp;tab=gX" target="_blank">+你</a></li>
<li><a href="http://www.google.com/webhp?hl=zh-CN&amp;tab=gw" target="_blank">搜索</a></li>
<li><a href="http://www.google.com/imghp?hl=zh-CN&amp;tab=gi" target="_blank">图片</a></li>
<li><a href="https://maps.google.com/maps?hl=zh-CN&amp;tab=gl" target="_blank">地图</a></li>
<li><a href="https://play.google.com/?hl=zh-CN&amp;tab=g8" target="_blank">Play</a></li>
<li><a href="https://www.youtube.com/?tab=g1" target="_blank">YouTube</a></li>
<li><a href="https://news.google.com/nwshp?hl=zh-CN&amp;tab=gn" target="_blank">新闻</a></li>
<li><a href="https://mail.google.com/mail/?tab=gm" target="_blank">Gmail</a></li>
<li><a href="https://drive.google.com/?tab=go" target="_blank">云端硬盘</a></li>
<li><a href="https://www.google.com/calendar?tab=gc" target="_blank">日历</a></li>
<li><p><a href="http://www.google.com/intl/zh-CN/options/" target="_blank">更多</a></p>
</li>
<li><p><a href="https://translate.google.com/?hl=zh-CN&amp;tab=gT" target="_blank">翻译</a></p>
</li>
<li><a href="http://www.google.com/mobile/?hl=zh-CN&amp;tab=gD" target="_blank">移动</a></li>
<li><a href="http://books.google.com/bkshp?hl=zh-CN&amp;tab=gp" target="_blank">图书</a></li>
<li><a href="https://wallet.google.com/manage/?tab=ga" target="_blank">电子钱包</a></li>
<li><a href="https://www.blogger.com/?tab=gj" target="_blank">Blogger</a></li>
<li><a href="https://www.google.com/finance?tab=ge" target="_blank">财经</a></li>
<li><a href="https://plus.google.com/photos?tab=gq" target="_blank">相册</a></li>
<li><a href="http://video.google.com/?hl=zh-CN&amp;tab=gv" target="_blank">视频</a>
1.</li>
<li><a href="http://www.google.com/intl/zh-CN/options/" target="_blank">更多</a></li>
</ol>
<p><a href="https://groups.google.com/d/overview" title="Google 网上论坛"></a></p>
<p>隐藏字段搜索论坛或帖子</p>
<p><img src="" alt=""></p>
<h2 id="account-options">Account Options</h2>
<p>1.</p>
<ol>
<li><a href="https://www.google.com/a/UniversalLogin?continue=https%3A%2F%2Fgroups.google.com%2Fd%2Ftopic%2Fpongba%2FBPGNU3OJZos&amp;hl=zh-CN&amp;service=groups2&amp;hd=default" target="_blank">登录</a><h2 id="-"><a href="">网上论坛</a></h2>
</li>
</ol>
<p><img src="" alt=""><img src="" alt="">第  个，共  个（ 个未读）</p>
<p><img src="" alt="">
<img src="" alt=""></p>
<p><img src="" alt=""></p>
<p><img src="" alt=""></p>
<p><a href="">首页</a></p>
<p>导入预定义搜索，将它们添加到您保存的搜索结果中。</p>
<p>点击论坛的星标即可收藏它
[0</p>
<h3 id="-">最近看过的论坛</h3>
<p>]()</p>
<p><a href=""></a></p>
<p><a href="">0  TopLanguage</a></p>
<p>[0</p>
<h3 id="-">最近的搜索</h3>
<p>]()</p>
<p><a href=""></a>
[0</p>
<h3 id="-">最近发过帖的论坛</h3>
<p>]()</p>
<p><a href=""></a></p>
<p>请<a href="https://www.google.com/a/UniversalLogin?continue=https%3A%2F%2Fgroups.google.com%2Fd%2Ftopic%2Fpongba%2FBPGNU3OJZos&amp;hl=zh-CN&amp;service=groups2&amp;hd=default" target="_blank">登录</a>或开始浏览，以整理您的论坛并查看最近的项目。</p>
<p>©2013 Google
<a href="http://www.google.com/intl/zh-CN/policies/privacy/" target="_blank">隐私权政策</a>  -  <a href="http://www.google.com/intl/zh-CN/policies/terms/" target="_blank">服务条款</a>  -  <a href="http://www.google.com/" target="_blank">Google 首页</a></p>
<p><a href=""></a> <a href=""></a> <a href="">TopLanguage</a> › 由于长期没有活动，本主题已不再开放新回复。如果您要发帖，请在上方搜索更新的主题或发布新问题。 {技术}{多线程}实施并行编程的五大障碍</p>
<p>此主题和其他讨论重复。   <a href=""></a>
系统将您从重复的主题重定向到这里。   <a href=""></a></p>
<p>24 名作者发布了 95 个帖子</p>
<p><img src="" alt="">
上一页 <a href="">上一页</a>  </p>
<p>第 <strong>1</strong> 页
  下一页 <a href="">下一页</a></p>
<p><img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问“什么是实施并行编程的最大障
碍”时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看
<a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/" target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/</a></a>
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是“专家”们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了“编译指导”、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说“在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶……你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的”，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：“你觉得并行编程容易么？”，十有八九会说“我觉得很难”。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点“教育”有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。
<a href="">显示删减掉的内容</a></p>
</li>
</ol>
<p><img src="" alt=""> 机械唯物主义 : linjunhalida <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>恩恩，有些事情还是没有并行的必要。等光处理器出来就好了。
2010/3/22 Guancheng Chen <a href="&#x6d;&#97;&#x69;&#108;&#x74;&#111;&#x3a;&#91;&#99;&#x68;&#101;&#x6e;&#103;&#117;&#46;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#40;&#41;">&#91;&#99;&#x68;&#101;&#x6e;&#103;&#117;&#46;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#40;&#41;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问“什么是实施并行编程的最大障
碍”时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。
( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看
<a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/" target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/</a></a>
)</p>
<ol>
<li>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</li>
<li>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是“专家”们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了“编译指导”、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。
可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说“在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶……你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的”，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：“你觉得并行编程容易么？”，十有八九会说“我觉得很难”。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</li>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？
(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx
总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点“教育”有很大关系了。</li>
<li>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</li>
<li>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> 陨落雕 <img src="" alt=""></li>
</ol>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>呃，我想的障碍是: 1. 类C语言的统治地位; 2. 内存带宽不够; 3. 误导性宣传;</p>
<p>On Mar 21, 7:37 pm, Guancheng Chen <a href="&#x6d;&#97;&#105;&#108;&#116;&#x6f;&#x3a;&#x5b;&#x63;&#x68;&#x65;&#110;&#103;&#x75;&#x61;&#x6e;&#99;&#104;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#109;&#93;&#40;&#x29;">&#x5b;&#x63;&#x68;&#x65;&#110;&#103;&#x75;&#x61;&#x6e;&#99;&#104;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#109;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看<a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..</p>
<p>)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。</p>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<blockquote>
<p>尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。
<a href="">显示删减掉的内容</a></p>
</li>
</ol>
</blockquote>
<p><img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>可是按现在的趋势，多核一定会在光处理器之前成为主流啊</p>
<p>On 3月22日, 上午12时42分, 机械唯物主义 : linjunhalida <a href="&#x6d;&#97;&#x69;&#x6c;&#116;&#111;&#x3a;&#91;&#108;&#105;&#x6e;&#x6a;&#117;&#x6e;&#x68;&#97;&#108;&#46;&#46;&#46;&#64;&#103;&#x6d;&#x61;&#x69;&#x6c;&#46;&#99;&#111;&#x6d;&#x5d;&#40;&#41;">&#91;&#108;&#105;&#x6e;&#x6a;&#117;&#x6e;&#x68;&#97;&#108;&#46;&#46;&#46;&#64;&#103;&#x6d;&#x61;&#x69;&#x6c;&#46;&#99;&#111;&#x6d;&#x5d;&#40;&#41;</a>
wrote:</p>
<blockquote>
<p>恩恩，有些事情还是没有并行的必要。等光处理器出来就好了。</p>
<p>2010/3/22 Guancheng Chen <a href="&#109;&#97;&#105;&#108;&#116;&#x6f;&#x3a;&#91;&#99;&#104;&#101;&#x6e;&#x67;&#117;&#97;&#x6e;&#99;&#104;&#x2e;&#x2e;&#46;&#x40;&#x67;&#109;&#97;&#105;&#108;&#46;&#x63;&#x6f;&#109;&#93;&#x28;&#41;">&#91;&#99;&#104;&#101;&#x6e;&#x67;&#117;&#97;&#x6e;&#99;&#104;&#x2e;&#x2e;&#46;&#x40;&#x67;&#109;&#97;&#105;&#108;&#46;&#x63;&#x6f;&#109;&#93;&#x28;&#41;</a></p>
</blockquote>
<p>&gt;
&gt;
&gt;</p>
<blockquote>
<blockquote>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问“什么是实施并行编程的最大障
碍”时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..</p>
</blockquote>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<blockquote>
<blockquote>
<p>)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是“专家”们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了“编译指导”、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说“在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶……你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的”，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：“你觉得并行编程容易么？”，十有八九会说“我觉得很难”。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点“教育”有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。</p>
</li>
</ol>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
</blockquote>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<ol>
<li>C语言可以使用pthread等库实现并行化，C++ JAVA等已经会即将支持多线程 所以语言能实现并行化 只是难易问题</li>
<li>是指Shared memory模型，多核共享一条内存总线所以造成带宽问题么？这确实是个问题，不过我感觉硬件商家会负责为你带来越来越多的带
宽，而程序员的任务只是合理的利用好这些给定的带宽</li>
<li>能具体说说哪些误导宣传么？</li>
</ol>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>On 3月22日, 上午1时46分, 陨落雕 <a href="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#111;&#58;&#x5b;&#103;&#x65;&#x6f;&#x2e;&#x2e;&#46;&#46;&#x40;&#103;&#109;&#x61;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#41;">&#x5b;&#103;&#x65;&#x6f;&#x2e;&#x2e;&#46;&#46;&#x40;&#103;&#109;&#x61;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>呃，我想的障碍是: 1. 类C语言的统治地位; 2. 内存带宽不够; 3. 误导性宣传;</p>
<p>On Mar 21, 7:37 pm, Guancheng Chen <a href="&#x6d;&#x61;&#105;&#108;&#116;&#111;&#x3a;&#91;&#x63;&#104;&#x65;&#110;&#x67;&#x75;&#x61;&#110;&#99;&#x68;&#46;&#46;&#46;&#x40;&#103;&#x6d;&#97;&#105;&#108;&#46;&#99;&#111;&#109;&#x5d;&#x28;&#41;">&#91;&#x63;&#104;&#x65;&#110;&#x67;&#x75;&#x61;&#110;&#99;&#x68;&#46;&#46;&#46;&#x40;&#103;&#x6d;&#97;&#105;&#108;&#46;&#99;&#111;&#109;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看<a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。
<a href="">显示删减掉的内容</a></p>
</li>
</ol>
</blockquote>
</blockquote>
<p><img src="" alt=""> Jeffrey Zhao <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是“抽象”这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上……我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog: <a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter: <a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p><strong>From:</strong> <a href="&quot;chenguancheng@gmail.com&quot;">Guancheng Chen</a></p>
<p><strong>Sent:</strong> Monday, March 22, 2010 7:37 AM
<strong>To:</strong> <a href="&quot;pongba@googlegroups.com&quot;">TopLanguage</a></p>
<p><strong>Subject:</strong> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问“什么是实施并行编程的最大障
碍”时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。
( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看
<a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/" target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/</a></a>
)</p>
<ol>
<li>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</li>
<li>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是“专家”们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了“编译指导”、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。
可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说“在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶……你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的”，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：“你觉得并行编程容易么？”，十有八九会说“我觉得很难”。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</li>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？
(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx
总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点“教育”有很大关系了。</li>
<li>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</li>
<li>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> tinyfool <img src="" alt=""></li>
</ol>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？
还有支持显卡计算的OpenCL也是无比强大啊。
2010/3/22 Jeffrey Zhao <a href="&#x6d;&#97;&#x69;&#108;&#x74;&#x6f;&#x3a;&#x5b;&#x6a;&#x65;&#46;&#x2e;&#46;&#x40;&#x6c;&#x69;&#x76;&#x65;&#x2e;&#x63;&#111;&#109;&#x5d;&#x28;&#x29;">&#x5b;&#x6a;&#x65;&#46;&#x2e;&#46;&#x40;&#x6c;&#x69;&#x76;&#x65;&#x2e;&#x63;&#111;&#109;&#x5d;&#x28;&#x29;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是“抽象”这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上……我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog: <a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter: <a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p><strong>From:</strong> <a href="&quot;chenguancheng@gmail.com&quot;">Guancheng Chen</a></p>
<p><strong>Sent:</strong> Monday, March 22, 2010 7:37 AM
<strong>To:</strong> <a href="&quot;pongba@googlegroups.com&quot;">TopLanguage</a></p>
<p><strong>Subject:</strong> [TL] {技术}{多线程}实施并行编程的五大障碍
近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问“什么是实施并行编程的最大障
碍”时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。
( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看
<a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/" target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/</a></a>
)</p>
<ol>
<li>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</li>
<li>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是“专家”们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了“编译指导”、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。
可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说“在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶……你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的”，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：“你觉得并行编程容易么？”，十有八九会说“我觉得很难”。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</li>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？
(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx
总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点“教育”有很大关系了。</li>
<li>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</li>
<li>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</li>
</ol>
<h2 id="to-unsubscribe-from-this-group-send-email-to-pongba-unsubscribegooglegroups-com-http-unsubscribegooglegroups-com-or-reply-to-this-email-with-the-words-remove-me-as-the-subject-">To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</h2>
<p>Tinyfool的开发日记 <a href="http://www.tinydust.net/dev/" target="_blank"><a href="http://www.tinydust.net/dev/">http://www.tinydust.net/dev/</a></a>
代码中国网 <a href="http://www.codechina.org/" target="_blank"><a href="http://www.codechina.org">http://www.codechina.org</a></a>
myTwitter: <a href="http://twitter.com/tinyfool" target="_blank"><a href="http://twitter.com/tinyfool">http://twitter.com/tinyfool</a></a>
<a href="">显示删减掉的内容</a></p>
<p><img src="" alt=""> 陨落雕 <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<ol>
<li>这和第二个问题是连起来的，到最后，你还是操作的mutable object，就是无穷无尽的memory consistency的麻烦；</li>
<li>就是这个问题，可惜从来都没跟上来过，光传输是一个可行性，如果实现了的确会改变现在的处境；</li>
<li>说在shared memory模型上内核数量可以无限上去的误导宣传，可惜这个20年前就失败，现在在TOP500上能看到的
supercomputer都是distributed memory model；</li>
</ol>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>On Mar 21, 8:58 pm, Guancheng Chen <a href="&#109;&#x61;&#x69;&#108;&#116;&#111;&#x3a;&#91;&#x63;&#x68;&#x65;&#110;&#x67;&#x75;&#97;&#110;&#x63;&#104;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#109;&#97;&#x69;&#108;&#x2e;&#99;&#x6f;&#x6d;&#93;&#x28;&#41;">&#91;&#x63;&#x68;&#x65;&#110;&#x67;&#x75;&#97;&#110;&#x63;&#104;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#109;&#97;&#x69;&#108;&#x2e;&#99;&#x6f;&#x6d;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<ol>
<li>C语言可以使用pthread等库实现并行化，C++ JAVA等已经会即将支持多线程 所以语言能实现并行化 只是难易问题</li>
<li>是指Shared memory模型，多核共享一条内存总线所以造成带宽问题么？这确实是个问题，不过我感觉硬件商家会负责为你带来越来越多的带
宽，而程序员的任务只是合理的利用好这些给定的带宽</li>
<li>能具体说说哪些误导宣传么？</li>
</ol>
<p>On 3月22日, 上午1时46分, 陨落雕 <a href="&#109;&#97;&#105;&#x6c;&#x74;&#x6f;&#58;&#91;&#x67;&#101;&#111;&#46;&#x2e;&#x2e;&#46;&#x40;&#103;&#109;&#x61;&#105;&#x6c;&#x2e;&#x63;&#111;&#109;&#93;&#x28;&#41;">&#91;&#x67;&#101;&#111;&#46;&#x2e;&#x2e;&#46;&#x40;&#103;&#109;&#x61;&#105;&#x6c;&#x2e;&#x63;&#111;&#109;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>呃，我想的障碍是: 1. 类C语言的统治地位; 2. 内存带宽不够; 3. 误导性宣传;</p>
<p>On Mar 21, 7:37 pm, Guancheng Chen <a href="&#109;&#x61;&#105;&#x6c;&#116;&#x6f;&#x3a;&#x5b;&#x63;&#104;&#101;&#x6e;&#103;&#117;&#97;&#x6e;&#x63;&#x68;&#46;&#46;&#46;&#64;&#x67;&#109;&#97;&#x69;&#108;&#x2e;&#99;&#111;&#109;&#93;&#40;&#41;">&#x5b;&#x63;&#104;&#101;&#x6e;&#103;&#117;&#97;&#x6e;&#x63;&#x68;&#46;&#46;&#46;&#64;&#x67;&#109;&#97;&#x69;&#108;&#x2e;&#99;&#111;&#109;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看<a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。
<a href="">显示删减掉的内容</a>
<img src="" alt=""> 陨落雕 <img src="" alt=""></p>
</li>
</ol>
</blockquote>
</blockquote>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>OpenCL解决了一大类的问题（每个kernel只需要一小部分数据，类似rasterization的渲染），而且现在他们有动力解决另一大类的问
题（每个小的kernel需要查询大量数据，类似ray tracer的渲染）。但是现在移植还是好困难啊，特别是显存和内存通信时候的
consolation，头疼死了，显存不够要swap out的时候，也很头疼。</p>
<p>On Mar 21, 9:20 pm, Tinyfool <a href="&#x6d;&#x61;&#105;&#x6c;&#116;&#x6f;&#x3a;&#91;&#116;&#105;&#x6e;&#x79;&#102;&#x2e;&#46;&#46;&#x40;&#103;&#109;&#97;&#x69;&#x6c;&#46;&#x63;&#x6f;&#109;&#x5d;&#x28;&#41;">&#91;&#116;&#105;&#x6e;&#x79;&#102;&#x2e;&#46;&#46;&#x40;&#103;&#109;&#97;&#x69;&#x6c;&#46;&#x63;&#x6f;&#109;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#x6d;&#97;&#x69;&#x6c;&#x74;&#x6f;&#x3a;&#91;&#x6a;&#x65;&#x2e;&#46;&#x2e;&#x40;&#x6c;&#105;&#118;&#x65;&#46;&#x63;&#111;&#109;&#x5d;&#x28;&#x29;">&#91;&#x6a;&#x65;&#x2e;&#46;&#x2e;&#x40;&#x6c;&#105;&#118;&#x65;&#46;&#x63;&#111;&#109;&#x5d;&#x28;&#x29;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
</blockquote>
</blockquote>
<p>&gt;</p>
<blockquote>
<blockquote>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#109;&#97;&#x69;&#108;&#x74;&#111;&#58;&#91;&#99;&#x68;&#101;&#x6e;&#103;&#117;&#97;&#110;&#x63;&#x68;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#109;&#97;&#x69;&#108;&#x2e;&#99;&#111;&#109;&#93;&#x28;&#41;">&#91;&#99;&#x68;&#101;&#x6e;&#103;&#117;&#97;&#110;&#x63;&#x68;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#109;&#97;&#x69;&#108;&#x2e;&#99;&#111;&#109;&#93;&#x28;&#41;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#109;&#97;&#x69;&#x6c;&#x74;&#x6f;&#58;&#x5b;&#112;&#111;&#110;&#46;&#x2e;&#x2e;&#64;&#103;&#x6f;&#x6f;&#103;&#108;&#x65;&#x67;&#x72;&#111;&#x75;&#x70;&#x73;&#46;&#x63;&#x6f;&#109;&#93;&#40;&#x29;">&#x5b;&#112;&#111;&#110;&#46;&#x2e;&#x2e;&#64;&#103;&#x6f;&#x6f;&#103;&#108;&#x65;&#x67;&#x72;&#111;&#x75;&#x70;&#x73;&#46;&#x63;&#x6f;&#109;&#93;&#40;&#x29;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
</blockquote>
</blockquote>
<p>&gt;</p>
<blockquote>
<blockquote>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..</p>
<p>)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。</p>
</blockquote>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<blockquote>
<blockquote>
<p>尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。</p>
</li>
</ol>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>--
Tinyfool的开发日记<a href="http://www.tinydust.net/dev/" target="_blank"><a href="http://www.tinydust.net/dev/">http://www.tinydust.net/dev/</a></a>
代码中国网<a href="http://www.codechina.org/" target="_blank"><a href="http://www.codechina.org">http://www.codechina.org</a></a>
myTwitter:<a href="http://twitter.com/tinyfool" target="_blank"><a href="http://twitter.com/tinyfool">http://twitter.com/tinyfool</a></a>
<a href="">显示删减掉的内容</a></p>
</blockquote>
<p><img src="" alt=""> Jeffrey Zhao <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>哈哈，广告好，扩展视野，那我继续做广告了……</p>
<p>微软其实很早就在搞Microsoft Accelerator项目，旨在利用DirectX进行计算，.NET项目。 <a href="http://research.microsoft.com/en-us/projects/Accelerator/" title="http://research.microsoft.com/en-us/projects/Accelerator/
CTRL + 单击以下链接"><a href="http://research.microsoft.com/en-us/projects/Accelerator/" target="_blank">http://research.microsoft.com/en-us/projects/Accelerator/</a></a></p>
<p>然后F/#这边由于语言的支持良好，可以设计出丰富的表达式、DSL等Modeling Language，再由框架进行自动并行，解决问题可以很容易（已经2.0了）。</p>
<p>这篇文章是个简单介绍：<a href="http://strangelights.com/blog/archive/2008/09/21/1628.aspx" target="_blank"><a href="http://strangelights.com/blog/archive/2008/09/21/1628.aspx">http://strangelights.com/blog/archive/2008/09/21/1628.aspx</a></a></p>
<p>Microsoft Solver Foundation <a href="http://code.msdn.microsoft.com/solverfoundation" target="_blank"><a href="http://code.msdn.microsoft.com/solverfoundation">http://code.msdn.microsoft.com/solverfoundation</a></a></p>
<p>F/# Optimization Modeling Language Utilizing Microsoft Solver Foundation <a href="http://code.msdn.microsoft.com/solverfoundationfs1" title="http://code.msdn.microsoft.com/solverfoundationfs1
CTRL + 单击以下链接"><a href="http://code.msdn.microsoft.com/solverfoundationfs1" target="_blank">http://code.msdn.microsoft.com/solverfoundationfs1</a></a></p>
<p>现在就等OpenCL如果有标准出来，肯定立马可以跟上个类库，哦耶。</p>
<p>Jeffrey Zhao
Blog: <a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter: <a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a>
<strong>From:</strong> <a href="&quot;tinyfool@gmail.com&quot;">Tinyfool</a></p>
<p><strong>Sent:</strong> Monday, March 22, 2010 9:20 AM
<strong>To:</strong> <a href="&quot;pongba@googlegroups.com&quot;">pon...@googlegroups.com</a></p>
<p><strong>Subject:</strong> Re: [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？
还有支持显卡计算的OpenCL也是无比强大啊。
2010/3/22 Jeffrey Zhao <a href="&#x6d;&#97;&#x69;&#x6c;&#x74;&#x6f;&#x3a;&#x5b;&#106;&#x65;&#46;&#x2e;&#x2e;&#x40;&#108;&#105;&#x76;&#101;&#46;&#99;&#111;&#109;&#x5d;&#x28;&#41;">&#x5b;&#106;&#x65;&#46;&#x2e;&#x2e;&#x40;&#108;&#105;&#x76;&#101;&#46;&#99;&#111;&#109;&#x5d;&#x28;&#41;</a>
我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是“抽象”这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上……我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog: <a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter: <a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p><strong>From:</strong> <a href="&quot;chenguancheng@gmail.com&quot;">Guancheng Chen</a></p>
<p><strong>Sent:</strong> Monday, March 22, 2010 7:37 AM
<strong>To:</strong> <a href="&quot;pongba@googlegroups.com&quot;">TopLanguage</a></p>
<p><strong>Subject:</strong> [TL] {技术}{多线程}实施并行编程的五大障碍
近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问“什么是实施并行编程的最大障
碍”时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。
( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看
<a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/" target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/</a></a>
)</p>
<ol>
<li>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</li>
<li>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是“专家”们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了“编译指导”、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。
可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说“在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶……你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的”，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：“你觉得并行编程容易么？”，十有八九会说“我觉得很难”。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</li>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？
(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx
总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点“教育”有很大关系了。</li>
<li>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</li>
<li>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</li>
</ol>
<h2 id="to-unsubscribe-from-this-group-send-email-to-pongba-unsubscribegooglegroups-com-http-unsubscribegooglegroups-com-or-reply-to-this-email-with-the-words-remove-me-as-the-subject-">To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</h2>
<p>Tinyfool的开发日记 <a href="http://www.tinydust.net/dev/" target="_blank"><a href="http://www.tinydust.net/dev/">http://www.tinydust.net/dev/</a></a>
代码中国网 <a href="http://www.codechina.org/" target="_blank"><a href="http://www.codechina.org">http://www.codechina.org</a></a>
myTwitter: <a href="http://twitter.com/tinyfool" target="_blank"><a href="http://twitter.com/tinyfool">http://twitter.com/tinyfool</a></a></p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> tinyfool <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>OpenCL早就出来标准了，而且在做各个平台的实现…</p>
<p>视野啊…
2010/3/22 Jeffrey Zhao <a href="&#x6d;&#97;&#x69;&#108;&#116;&#x6f;&#x3a;&#91;&#x6a;&#x65;&#x2e;&#x2e;&#x2e;&#64;&#x6c;&#x69;&#118;&#x65;&#46;&#x63;&#111;&#109;&#x5d;&#40;&#41;">&#91;&#x6a;&#x65;&#x2e;&#x2e;&#x2e;&#64;&#x6c;&#x69;&#118;&#x65;&#46;&#x63;&#111;&#109;&#x5d;&#40;&#41;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>哈哈，广告好，扩展视野，那我继续做广告了……</p>
<p>微软其实很早就在搞Microsoft Accelerator项目，旨在利用DirectX进行计算，.NET项目。 <a href="http://research.microsoft.com/en-us/projects/Accelerator/" title="http://research.microsoft.com/en-us/projects/Accelerator/
CTRL + 单击以下链接"><a href="http://research.microsoft.com/en-us/projects/Accelerator/" target="_blank">http://research.microsoft.com/en-us/projects/Accelerator/</a></a></p>
<p>然后F/#这边由于语言的支持良好，可以设计出丰富的表达式、DSL等Modeling Language，再由框架进行自动并行，解决问题可以很容易（已经2.0了）。</p>
<p>这篇文章是个简单介绍：<a href="http://strangelights.com/blog/archive/2008/09/21/1628.aspx" target="_blank"><a href="http://strangelights.com/blog/archive/2008/09/21/1628.aspx">http://strangelights.com/blog/archive/2008/09/21/1628.aspx</a></a></p>
<p>Microsoft Solver Foundation <a href="http://code.msdn.microsoft.com/solverfoundation" target="_blank"><a href="http://code.msdn.microsoft.com/solverfoundation">http://code.msdn.microsoft.com/solverfoundation</a></a></p>
<p>F/# Optimization Modeling Language Utilizing Microsoft Solver Foundation <a href="http://code.msdn.microsoft.com/solverfoundationfs1" title="http://code.msdn.microsoft.com/solverfoundationfs1
CTRL + 单击以下链接"><a href="http://code.msdn.microsoft.com/solverfoundationfs1" target="_blank">http://code.msdn.microsoft.com/solverfoundationfs1</a></a></p>
<p>现在就等OpenCL如果有标准出来，肯定立马可以跟上个类库，哦耶。</p>
<p>Jeffrey Zhao
Blog: <a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter: <a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a>
<strong>From:</strong> <a href="&quot;tinyfool@gmail.com&quot;">Tinyfool</a></p>
<p><strong>Sent:</strong> Monday, March 22, 2010 9:20 AM
<strong>To:</strong> <a href="&quot;pongba@googlegroups.com&quot;">pon...@googlegroups.com</a></p>
<p><strong>Subject:</strong> Re: [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？
还有支持显卡计算的OpenCL也是无比强大啊。
2010/3/22 Jeffrey Zhao <a href="&#109;&#97;&#x69;&#108;&#x74;&#111;&#x3a;&#x5b;&#x6a;&#x65;&#46;&#x2e;&#x2e;&#64;&#x6c;&#x69;&#x76;&#101;&#x2e;&#x63;&#111;&#109;&#x5d;&#x28;&#41;">&#x5b;&#x6a;&#x65;&#46;&#x2e;&#x2e;&#64;&#x6c;&#x69;&#x76;&#101;&#x2e;&#x63;&#111;&#109;&#x5d;&#x28;&#41;</a>
我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是“抽象”这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上……我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog: <a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter: <a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p><strong>From:</strong> <a href="&quot;chenguancheng@gmail.com&quot;">Guancheng Chen</a></p>
<p><strong>Sent:</strong> Monday, March 22, 2010 7:37 AM
<strong>To:</strong> <a href="&quot;pongba@googlegroups.com&quot;">TopLanguage</a></p>
<p><strong>Subject:</strong> [TL] {技术}{多线程}实施并行编程的五大障碍
近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问“什么是实施并行编程的最大障
碍”时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。
( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看
<a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/" target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/</a></a>
)</p>
<ol>
<li>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</li>
<li>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是“专家”们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了“编译指导”、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。
可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说“在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶……你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的”，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：“你觉得并行编程容易么？”，十有八九会说“我觉得很难”。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</li>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？
(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx
总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点“教育”有很大关系了。</li>
<li>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</li>
<li>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</li>
</ol>
<h2 id="to-unsubscribe-from-this-group-send-email-to-pongba-unsubscribegooglegroups-com-http-unsubscribegooglegroups-com-or-reply-to-this-email-with-the-words-remove-me-as-the-subject-">To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</h2>
<p>Tinyfool的开发日记 <a href="http://www.tinydust.net/dev/" target="_blank"><a href="http://www.tinydust.net/dev/">http://www.tinydust.net/dev/</a></a>
代码中国网 <a href="http://www.codechina.org/" target="_blank"><a href="http://www.codechina.org">http://www.codechina.org</a></a>
myTwitter: <a href="http://twitter.com/tinyfool" target="_blank"><a href="http://twitter.com/tinyfool">http://twitter.com/tinyfool</a></a></p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>--
Tinyfool的开发日记 <a href="http://www.tinydust.net/dev/" target="_blank"><a href="http://www.tinydust.net/dev/">http://www.tinydust.net/dev/</a></a>
代码中国网 <a href="http://www.codechina.org/" target="_blank"><a href="http://www.codechina.org">http://www.codechina.org</a></a>
myTwitter: <a href="http://twitter.com/tinyfool" target="_blank"><a href="http://twitter.com/tinyfool">http://twitter.com/tinyfool</a></a>
<a href="">显示删减掉的内容</a></p>
<p><img src="" alt=""> woo <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>C的pthread太重量级了，我觉得golang的go要好很多，虽然只是试验阶段</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>On 17:58 Sun 21 Mar     , Guancheng Chen wrote:</p>
<blockquote>
<ol>
<li>C语言可以使用pthread等库实现并行化，C++ JAVA等已经会即将支持多线程 所以语言能实现并行化 只是难易问题</li>
<li>是指Shared memory模型，多核共享一条内存总线所以造成带宽问题么？这确实是个问题，不过我感觉硬件商家会负责为你带来越来越多的带
宽，而程序员的任务只是合理的利用好这些给定的带宽</li>
<li>能具体说说哪些误导宣传么？</li>
</ol>
<p>On 3月22日, 上午1时46分, 陨落雕 <a href="&#109;&#x61;&#x69;&#108;&#116;&#111;&#58;&#x5b;&#x67;&#101;&#111;&#46;&#x2e;&#46;&#46;&#64;&#103;&#x6d;&#97;&#105;&#x6c;&#x2e;&#99;&#x6f;&#109;&#93;&#40;&#x29;">&#x5b;&#x67;&#101;&#111;&#46;&#x2e;&#46;&#46;&#64;&#103;&#x6d;&#97;&#105;&#x6c;&#x2e;&#99;&#x6f;&#109;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>呃，我想的障碍是: 1. 类C语言的统治地位; 2. 内存带宽不够; 3. 误导性宣传;</p>
<p>On Mar 21, 7:37 pm, Guancheng Chen <a href="&#x6d;&#97;&#x69;&#x6c;&#116;&#111;&#58;&#x5b;&#99;&#x68;&#101;&#110;&#x67;&#117;&#x61;&#110;&#x63;&#x68;&#x2e;&#46;&#46;&#x40;&#x67;&#x6d;&#97;&#105;&#108;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#40;&#x29;">&#x5b;&#99;&#x68;&#101;&#110;&#x67;&#117;&#x61;&#110;&#x63;&#x68;&#x2e;&#46;&#46;&#x40;&#x67;&#x6d;&#97;&#105;&#108;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看<a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。</p>
</li>
</ol>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> 陨落雕 <img src="" alt=""></p>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>言多必失啊，coalescing是写显存时候的问题，单词也拼错了......</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>On Mar 21, 9:33 pm, 陨落雕 <a href="&#109;&#97;&#x69;&#108;&#116;&#x6f;&#x3a;&#x5b;&#x67;&#x65;&#x6f;&#46;&#46;&#x2e;&#x2e;&#x40;&#103;&#109;&#97;&#x69;&#x6c;&#x2e;&#x63;&#111;&#109;&#x5d;&#x28;&#x29;">&#x5b;&#x67;&#x65;&#x6f;&#46;&#46;&#x2e;&#x2e;&#x40;&#103;&#109;&#97;&#x69;&#x6c;&#x2e;&#x63;&#111;&#109;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>OpenCL解决了一大类的问题（每个kernel只需要一小部分数据，类似rasterization的渲染），而且现在他们有动力解决另一大类的问
题（每个小的kernel需要查询大量数据，类似ray tracer的渲染）。但是现在移植还是好困难啊，特别是显存和内存通信时候的
consolation，头疼死了，显存不够要swap out的时候，也很头疼。</p>
<p>On Mar 21, 9:20 pm, Tinyfool <a href="&#109;&#x61;&#105;&#108;&#116;&#111;&#58;&#91;&#x74;&#105;&#x6e;&#121;&#x66;&#46;&#x2e;&#x2e;&#64;&#103;&#x6d;&#x61;&#x69;&#108;&#46;&#99;&#111;&#x6d;&#93;&#40;&#41;">&#91;&#x74;&#105;&#x6e;&#121;&#x66;&#46;&#x2e;&#x2e;&#64;&#103;&#x6d;&#x61;&#x69;&#108;&#46;&#99;&#111;&#x6d;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#109;&#x61;&#105;&#108;&#x74;&#111;&#x3a;&#x5b;&#x6a;&#x65;&#x2e;&#46;&#46;&#64;&#x6c;&#105;&#x76;&#101;&#x2e;&#99;&#111;&#109;&#x5d;&#40;&#x29;">&#x5b;&#x6a;&#x65;&#x2e;&#46;&#46;&#64;&#x6c;&#105;&#x76;&#101;&#x2e;&#99;&#111;&#109;&#x5d;&#40;&#x29;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#111;&#58;&#x5b;&#99;&#x68;&#x65;&#x6e;&#x67;&#x75;&#x61;&#x6e;&#x63;&#x68;&#x2e;&#46;&#46;&#x40;&#x67;&#x6d;&#97;&#x69;&#108;&#x2e;&#99;&#x6f;&#109;&#x5d;&#x28;&#41;">&#x5b;&#99;&#x68;&#x65;&#x6e;&#x67;&#x75;&#x61;&#x6e;&#x63;&#x68;&#x2e;&#46;&#46;&#x40;&#x67;&#x6d;&#97;&#x69;&#108;&#x2e;&#99;&#x6f;&#109;&#x5d;&#x28;&#41;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#109;&#x61;&#x69;&#x6c;&#116;&#x6f;&#58;&#91;&#x70;&#111;&#110;&#46;&#46;&#46;&#64;&#103;&#x6f;&#x6f;&#x67;&#108;&#101;&#x67;&#114;&#x6f;&#x75;&#x70;&#x73;&#46;&#x63;&#111;&#x6d;&#93;&#x28;&#x29;">&#91;&#x70;&#111;&#110;&#46;&#46;&#46;&#64;&#103;&#x6f;&#x6f;&#x67;&#108;&#101;&#x67;&#114;&#x6f;&#x75;&#x70;&#x73;&#46;&#x63;&#111;&#x6d;&#93;&#x28;&#x29;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。</p>
</li>
</ol>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>--
Tinyfool的开发日记<a href="http://www.tinydust.net/dev/" target="_blank"><a href="http://www.tinydust.net/dev/">http://www.tinydust.net/dev/</a></a></p>
</blockquote>
<p>...</p>
<p>read more &gt;&gt;
<a href="">显示删减掉的内容</a></p>
</blockquote>
<p><img src="" alt=""> Jeffrey Zhao <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>是嘛，我记得是提交了标准还在审核。</p>
<p>好吧，我去查了一下果然在08年12月1.0 Stable release了。</p>
<p>Jeffrey Zhao
Blog: <a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter: <a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a>
<strong>From:</strong> <a href="&quot;tinyfool@gmail.com&quot;">Tinyfool</a></p>
<p><strong>Sent:</strong> Monday, March 22, 2010 9:46 AM</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p><strong>To:</strong> <a href="&quot;pongba@googlegroups.com&quot;">pon...@googlegroups.com</a></p>
<p><strong>Subject:</strong> Re: [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>OpenCL早就出来标准了，而且在做各个平台的实现…</p>
<p>视野啊…
2010/3/22 Jeffrey Zhao <a href="&#x6d;&#x61;&#105;&#x6c;&#116;&#111;&#x3a;&#91;&#106;&#101;&#46;&#46;&#46;&#64;&#108;&#105;&#x76;&#101;&#x2e;&#99;&#111;&#109;&#93;&#40;&#x29;">&#91;&#106;&#101;&#46;&#46;&#46;&#64;&#108;&#105;&#x76;&#101;&#x2e;&#99;&#111;&#109;&#93;&#40;&#x29;</a>
哈哈，广告好，扩展视野，那我继续做广告了……</p>
<p>微软其实很早就在搞Microsoft Accelerator项目，旨在利用DirectX进行计算，.NET项目。 <a href="http://research.microsoft.com/en-us/projects/Accelerator/" title="http://research.microsoft.com/en-us/projects/Accelerator/
CTRL + 单击以下链接"><a href="http://research.microsoft.com/en-us/projects/Accelerator/" target="_blank">http://research.microsoft.com/en-us/projects/Accelerator/</a></a></p>
<p>然后F/#这边由于语言的支持良好，可以设计出丰富的表达式、DSL等Modeling Language，再由框架进行自动并行，解决问题可以很容易（已经2.0了）。</p>
<p>这篇文章是个简单介绍：<a href="http://strangelights.com/blog/archive/2008/09/21/1628.aspx" title="http://strangelights.com/blog/archive/2008/09/21/1628.aspx
CTRL + 单击以下链接"><a href="http://strangelights.com/blog/archive/2008/09/21/1628.aspx" target="_blank">http://strangelights.com/blog/archive/2008/09/21/1628.aspx</a></a></p>
<p>Microsoft Solver Foundation <a href="http://code.msdn.microsoft.com/solverfoundation" title="http://code.msdn.microsoft.com/solverfoundation
CTRL + 单击以下链接"><a href="http://code.msdn.microsoft.com/solverfoundation" target="_blank">http://code.msdn.microsoft.com/solverfoundation</a></a></p>
<p>F/# Optimization Modeling Language Utilizing Microsoft Solver Foundation <a href="http://code.msdn.microsoft.com/solverfoundationfs1" title="http://code.msdn.microsoft.com/solverfoundationfs1
CTRL + 单击以下链接"><a href="http://code.msdn.microsoft.com/solverfoundationfs1" target="_blank">http://code.msdn.microsoft.com/solverfoundationfs1</a></a></p>
<p>现在就等OpenCL如果有标准出来，肯定立马可以跟上个类库，哦耶。</p>
<p>Jeffrey Zhao
Blog: <a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter: <a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a>
<strong>From:</strong> <a href="&quot;tinyfool@gmail.com&quot;">Tinyfool</a></p>
<p><strong>Sent:</strong> Monday, March 22, 2010 9:20 AM
<strong>To:</strong> <a href="&quot;pongba@googlegroups.com&quot;">pon...@googlegroups.com</a></p>
<p><strong>Subject:</strong> Re: [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？
还有支持显卡计算的OpenCL也是无比强大啊。
2010/3/22 Jeffrey Zhao <a href="&#x6d;&#97;&#105;&#x6c;&#x74;&#x6f;&#58;&#x5b;&#x6a;&#101;&#46;&#x2e;&#x2e;&#x40;&#x6c;&#x69;&#118;&#101;&#46;&#99;&#x6f;&#109;&#93;&#x28;&#x29;">&#x5b;&#x6a;&#101;&#46;&#x2e;&#x2e;&#x40;&#x6c;&#x69;&#118;&#101;&#46;&#99;&#x6f;&#109;&#93;&#x28;&#x29;</a>
我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是“抽象”这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上……我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog: <a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter: <a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p><strong>From:</strong> <a href="&quot;chenguancheng@gmail.com&quot;">Guancheng Chen</a></p>
<p><strong>Sent:</strong> Monday, March 22, 2010 7:37 AM
<strong>To:</strong> <a href="&quot;pongba@googlegroups.com&quot;">TopLanguage</a></p>
<p><strong>Subject:</strong> [TL] {技术}{多线程}实施并行编程的五大障碍
近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问“什么是实施并行编程的最大障
碍”时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。
( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看
<a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/" target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/</a></a>
)</p>
<ol>
<li>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</li>
<li>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是“专家”们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了“编译指导”、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。
可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说“在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶……你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的”，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：“你觉得并行编程容易么？”，十有八九会说“我觉得很难”。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</li>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？
(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx
总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点“教育”有很大关系了。</li>
<li>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</li>
<li>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</li>
</ol>
<h2 id="to-unsubscribe-from-this-group-send-email-to-pongba-unsubscribegooglegroups-com-http-unsubscribegooglegroups-com-or-reply-to-this-email-with-the-words-remove-me-as-the-subject-">To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</h2>
<p>Tinyfool的开发日记 <a href="http://www.tinydust.net/dev/" target="_blank"><a href="http://www.tinydust.net/dev/">http://www.tinydust.net/dev/</a></a>
代码中国网 <a href="http://www.codechina.org/" target="_blank"><a href="http://www.codechina.org">http://www.codechina.org</a></a>
myTwitter: <a href="http://twitter.com/tinyfool" target="_blank"><a href="http://twitter.com/tinyfool">http://twitter.com/tinyfool</a></a></p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<h2 id="to-unsubscribe-from-this-group-send-email-to-pongba-unsubscribegooglegroups-com-http-unsubscribegooglegroups-com-or-reply-to-this-email-with-the-words-remove-me-as-the-subject-">To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</h2>
<p>Tinyfool的开发日记 <a href="http://www.tinydust.net/dev/" target="_blank"><a href="http://www.tinydust.net/dev/">http://www.tinydust.net/dev/</a></a>
代码中国网 <a href="http://www.codechina.org/" target="_blank"><a href="http://www.codechina.org">http://www.codechina.org</a></a>
myTwitter: <a href="http://twitter.com/tinyfool" target="_blank"><a href="http://twitter.com/tinyfool">http://twitter.com/tinyfool</a></a></p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> changsheng <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>个人觉得最大障碍在工具上.</p>
<p>并行学术上研究得不少, 主要在算法和模型上. 工程上的工具, 多是自串行程序来设计的, 弄得复杂不堪. 并行需要语言和库两级支持, Pthreads 和 MPI 仅从库上入手, 让程序员处理各种重复且复杂的分发, 并发锁等. OpenMP好一些, 可惜目前只支持线程并行.
用 ErLang 等将并行设计在语言里的来做并行会容易得多, 得易于面向消息传递的隔离模型, 程序稳定易写. 模型和语言的性能是一个问题, 主要的问题还在用的人和实际并行项目不多.</p>
<p>调试工具就更少了. 有少数商业化的工具.
当然, 我是将可维护性归结为语言工具太差.</p>
<pre><code>                                                 Changsheng Jiang
</code></pre><p>2010/3/22 Guancheng Chen <a href="&#109;&#97;&#x69;&#108;&#116;&#x6f;&#58;&#x5b;&#99;&#104;&#x65;&#x6e;&#103;&#x75;&#x2e;&#x2e;&#x2e;&#64;&#103;&#109;&#97;&#105;&#x6c;&#46;&#x63;&#x6f;&#109;&#93;&#x28;&#x29;">&#x5b;&#99;&#104;&#x65;&#x6e;&#103;&#x75;&#x2e;&#x2e;&#x2e;&#64;&#103;&#109;&#97;&#105;&#x6c;&#46;&#x63;&#x6f;&#109;&#93;&#x28;&#x29;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问“什么是实施并行编程的最大障
碍”时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。
( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看
<a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/" target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/</a></a>
)</p>
<ol>
<li>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</li>
<li>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是“专家”们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了“编译指导”、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。
可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说“在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶……你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的”，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：“你觉得并行编程容易么？”，十有八九会说“我觉得很难”。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</li>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？
(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx
总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点“教育”有很大关系了。</li>
<li>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</li>
<li>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。</li>
</ol>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a></p>
<p><img src="" alt=""> Milo Yip <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>我在等NVidia的Fermi和Nexus，想試做全域照明。
但怕買了Fermi後，機器也只是用來做做翻譯……</p>
<p>在 2010年3月22日上午9:51，Jeffrey Zhao <a href="&#109;&#97;&#x69;&#x6c;&#x74;&#x6f;&#58;&#x5b;&#x6a;&#101;&#x2e;&#46;&#46;&#x40;&#108;&#x69;&#118;&#x65;&#46;&#x63;&#x6f;&#109;&#93;&#40;&#x29;">&#x5b;&#x6a;&#101;&#x2e;&#46;&#46;&#x40;&#108;&#x69;&#118;&#x65;&#46;&#x63;&#x6f;&#109;&#93;&#40;&#x29;</a> 寫道：</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<blockquote>
<p>是嘛，我记得是提交了标准还在审核。</p>
<p>好吧，我去查了一下果然在08年12月1.0 Stable release了。</p>
<p>Jeffrey Zhao
Blog: <a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter: <a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a>
From: Tinyfool
Sent: Monday, March 22, 2010 9:46 AM
To: <a href="">pon...@googlegroups.com</a>
Subject: Re: [TL] {技术}{多线程}实施并行编程的五大障碍
OpenCL早就出来标准了，而且在做各个平台的实现…
视野啊…</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#109;&#x61;&#x69;&#108;&#x74;&#111;&#x3a;&#91;&#x6a;&#101;&#46;&#46;&#46;&#x40;&#x6c;&#x69;&#118;&#x65;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#x28;&#41;">&#91;&#x6a;&#101;&#46;&#46;&#46;&#x40;&#x6c;&#x69;&#118;&#x65;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#x28;&#41;</a>
&gt;</p>
<blockquote>
<p>哈哈，广告好，扩展视野，那我继续做广告了……</p>
<p>微软其实很早就在搞Microsoft Accelerator项目，旨在利用DirectX进行计算，.NET项目。
<a href="http://research.microsoft.com/en-us/projects/Accelerator/" target="_blank"><a href="http://research.microsoft.com/en-us/projects/Accelerator/">http://research.microsoft.com/en-us/projects/Accelerator/</a></a></p>
<p>然后F/#这边由于语言的支持良好，可以设计出丰富的表达式、DSL等Modeling
Language，再由框架进行自动并行，解决问题可以很容易（已经2.0了）。</p>
<p>这篇文章是个简单介绍：<a href="http://strangelights.com/blog/archive/2008/09/21/1628.aspx" target="_blank"><a href="http://strangelights.com/blog/archive/2008/09/21/1628.aspx">http://strangelights.com/blog/archive/2008/09/21/1628.aspx</a></a></p>
<p>Microsoft Solver Foundation
<a href="http://code.msdn.microsoft.com/solverfoundation" target="_blank"><a href="http://code.msdn.microsoft.com/solverfoundation">http://code.msdn.microsoft.com/solverfoundation</a></a></p>
<p>F/# Optimization Modeling Language Utilizing Microsoft Solver Foundation
<a href="http://code.msdn.microsoft.com/solverfoundationfs1" target="_blank"><a href="http://code.msdn.microsoft.com/solverfoundationfs1">http://code.msdn.microsoft.com/solverfoundationfs1</a></a></p>
<p>现在就等OpenCL如果有标准出来，肯定立马可以跟上个类库，哦耶。</p>
<p>Jeffrey Zhao
Blog: <a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter: <a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a>
From: Tinyfool
Sent: Monday, March 22, 2010 9:20 AM
To: <a href="">pon...@googlegroups.com</a>
Subject: Re: [TL] {技术}{多线程}实施并行编程的五大障碍
唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下
Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？
还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#x6d;&#x61;&#105;&#108;&#x74;&#x6f;&#x3a;&#x5b;&#106;&#x65;&#46;&#x2e;&#46;&#64;&#x6c;&#105;&#x76;&#101;&#46;&#99;&#x6f;&#109;&#93;&#x28;&#x29;">&#x5b;&#106;&#x65;&#46;&#x2e;&#46;&#64;&#x6c;&#105;&#x76;&#101;&#46;&#99;&#x6f;&#109;&#93;&#x28;&#x29;</a>
&gt;</p>
<blockquote>
<p>我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是“抽象”这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上……我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog: <a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter: <a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a>
From: Guancheng Chen
Sent: Monday, March 22, 2010 7:37 AM
To: TopLanguage
Subject: [TL] {技术}{多线程}实施并行编程的五大障碍
近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问“什么是实施并行编程的最大障
碍”时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/" target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/</a></a>
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是“专家”们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了“编译指导”、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说“在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶……你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的”，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：“你觉得并行编程容易么？”，十有八九会说“我觉得很难”。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点“教育”有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。</p>
</li>
</ol>
<p>To unsubscribe from this group, send email to
pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to
pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>--
Tinyfool的开发日记 <a href="http://www.tinydust.net/dev/" target="_blank"><a href="http://www.tinydust.net/dev/">http://www.tinydust.net/dev/</a></a>
代码中国网 <a href="http://www.codechina.org/" target="_blank"><a href="http://www.codechina.org">http://www.codechina.org</a></a>
myTwitter: <a href="http://twitter.com/tinyfool" target="_blank"><a href="http://twitter.com/tinyfool">http://twitter.com/tinyfool</a></a></p>
<p>To unsubscribe from this group, send email to
pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to
pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>--
Tinyfool的开发日记 <a href="http://www.tinydust.net/dev/" target="_blank"><a href="http://www.tinydust.net/dev/">http://www.tinydust.net/dev/</a></a>
代码中国网 <a href="http://www.codechina.org/" target="_blank"><a href="http://www.codechina.org">http://www.codechina.org</a></a>
myTwitter: <a href="http://twitter.com/tinyfool" target="_blank"><a href="http://twitter.com/tinyfool">http://twitter.com/tinyfool</a></a></p>
<p>To unsubscribe from this group, send email to
pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to
pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>--
Milo Yip</p>
<p>Twitter @miloyip
<a href="http://www.cnblogs.com/miloyip/" target="_blank"><a href="http://www.cnblogs.com/miloyip/">http://www.cnblogs.com/miloyip/</a></a>
<a href="http://miloyip.seezone.net/" target="_blank"><a href="http://miloyip.seezone.net/">http://miloyip.seezone.net/</a></a>
<a href="">显示删减掉的内容</a>
<img src="" alt=""> Milo Yip <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>應該是「全局照明」</p>
<p>在 2010年3月22日上午10:20，Milo Yip <a href="&#x6d;&#97;&#x69;&#108;&#116;&#111;&#x3a;&#x5b;&#x6d;&#x69;&#x6c;&#46;&#x2e;&#x2e;&#64;&#103;&#109;&#x61;&#105;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#93;&#40;&#41;">&#x5b;&#x6d;&#x69;&#x6c;&#46;&#x2e;&#x2e;&#64;&#103;&#109;&#x61;&#105;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#93;&#40;&#41;</a> 寫道：</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<blockquote>
<p>我在等NVidia的Fermi和Nexus，想試做全域照明。
但怕買了Fermi後，機器也只是用來做做翻譯……</p>
<p>在 2010年3月22日上午9:51，Jeffrey Zhao <a href="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#111;&#x3a;&#x5b;&#106;&#101;&#46;&#x2e;&#x2e;&#64;&#x6c;&#x69;&#x76;&#101;&#x2e;&#99;&#111;&#109;&#93;&#40;&#x29;">&#x5b;&#106;&#101;&#46;&#x2e;&#x2e;&#64;&#x6c;&#x69;&#x76;&#101;&#x2e;&#99;&#111;&#109;&#93;&#40;&#x29;</a> 寫道：</p>
<blockquote>
<p>是嘛，我记得是提交了标准还在审核。</p>
<p>好吧，我去查了一下果然在08年12月1.0 Stable release了。</p>
<p>Jeffrey Zhao
Blog: <a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter: <a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a>
From: Tinyfool
Sent: Monday, March 22, 2010 9:46 AM
To: <a href="">pon...@googlegroups.com</a>
Subject: Re: [TL] {技术}{多线程}实施并行编程的五大障碍
OpenCL早就出来标准了，而且在做各个平台的实现…
视野啊…</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#109;&#x61;&#x69;&#x6c;&#116;&#x6f;&#x3a;&#91;&#106;&#x65;&#46;&#x2e;&#46;&#64;&#x6c;&#x69;&#118;&#x65;&#x2e;&#x63;&#111;&#109;&#x5d;&#40;&#x29;">&#91;&#106;&#x65;&#46;&#x2e;&#46;&#64;&#x6c;&#x69;&#118;&#x65;&#x2e;&#x63;&#111;&#109;&#x5d;&#40;&#x29;</a>
&gt;</p>
<blockquote>
<p>哈哈，广告好，扩展视野，那我继续做广告了……</p>
<p>微软其实很早就在搞Microsoft Accelerator项目，旨在利用DirectX进行计算，.NET项目。
<a href="http://research.microsoft.com/en-us/projects/Accelerator/" target="_blank"><a href="http://research.microsoft.com/en-us/projects/Accelerator/">http://research.microsoft.com/en-us/projects/Accelerator/</a></a></p>
<p>然后F/#这边由于语言的支持良好，可以设计出丰富的表达式、DSL等Modeling
Language，再由框架进行自动并行，解决问题可以很容易（已经2.0了）。</p>
<p>这篇文章是个简单介绍：<a href="http://strangelights.com/blog/archive/2008/09/21/1628.aspx" target="_blank"><a href="http://strangelights.com/blog/archive/2008/09/21/1628.aspx">http://strangelights.com/blog/archive/2008/09/21/1628.aspx</a></a></p>
<p>Microsoft Solver Foundation
<a href="http://code.msdn.microsoft.com/solverfoundation" target="_blank"><a href="http://code.msdn.microsoft.com/solverfoundation">http://code.msdn.microsoft.com/solverfoundation</a></a></p>
<p>F/# Optimization Modeling Language Utilizing Microsoft Solver Foundation
<a href="http://code.msdn.microsoft.com/solverfoundationfs1" target="_blank"><a href="http://code.msdn.microsoft.com/solverfoundationfs1">http://code.msdn.microsoft.com/solverfoundationfs1</a></a></p>
<p>现在就等OpenCL如果有标准出来，肯定立马可以跟上个类库，哦耶。</p>
<p>Jeffrey Zhao
Blog: <a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter: <a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a>
From: Tinyfool
Sent: Monday, March 22, 2010 9:20 AM
To: <a href="">pon...@googlegroups.com</a>
Subject: Re: [TL] {技术}{多线程}实施并行编程的五大障碍
唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下
Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？
还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#109;&#97;&#x69;&#108;&#x74;&#111;&#58;&#x5b;&#x6a;&#101;&#x2e;&#x2e;&#46;&#x40;&#x6c;&#x69;&#118;&#x65;&#x2e;&#x63;&#111;&#x6d;&#93;&#40;&#41;">&#x5b;&#x6a;&#101;&#x2e;&#x2e;&#46;&#x40;&#x6c;&#x69;&#118;&#x65;&#x2e;&#x63;&#111;&#x6d;&#93;&#40;&#41;</a>
&gt;</p>
<blockquote>
<p>我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是“抽象”这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上……我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog: <a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter: <a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a>
From: Guancheng Chen
Sent: Monday, March 22, 2010 7:37 AM
To: TopLanguage
Subject: [TL] {技术}{多线程}实施并行编程的五大障碍
近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问“什么是实施并行编程的最大障
碍”时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/" target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/</a></a>
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是“专家”们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了“编译指导”、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说“在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶……你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的”，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：“你觉得并行编程容易么？”，十有八九会说“我觉得很难”。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点“教育”有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。</p>
</li>
</ol>
<p>To unsubscribe from this group, send email to
pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to
pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>--
Tinyfool的开发日记 <a href="http://www.tinydust.net/dev/" target="_blank"><a href="http://www.tinydust.net/dev/">http://www.tinydust.net/dev/</a></a>
代码中国网 <a href="http://www.codechina.org/" target="_blank"><a href="http://www.codechina.org">http://www.codechina.org</a></a>
myTwitter: <a href="http://twitter.com/tinyfool" target="_blank"><a href="http://twitter.com/tinyfool">http://twitter.com/tinyfool</a></a></p>
<p>To unsubscribe from this group, send email to
pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to
pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>--
Tinyfool的开发日记 <a href="http://www.tinydust.net/dev/" target="_blank"><a href="http://www.tinydust.net/dev/">http://www.tinydust.net/dev/</a></a>
代码中国网 <a href="http://www.codechina.org/" target="_blank"><a href="http://www.codechina.org">http://www.codechina.org</a></a>
myTwitter: <a href="http://twitter.com/tinyfool" target="_blank"><a href="http://twitter.com/tinyfool">http://twitter.com/tinyfool</a></a></p>
<p>To unsubscribe from this group, send email to
pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to
pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>--
Milo Yip</p>
<p>Twitter @miloyip
<a href="http://www.cnblogs.com/miloyip/" target="_blank"><a href="http://www.cnblogs.com/miloyip/">http://www.cnblogs.com/miloyip/</a></a>
<a href="http://miloyip.seezone.net/" target="_blank"><a href="http://miloyip.seezone.net/">http://miloyip.seezone.net/</a></a></p>
</blockquote>
<p>--
Milo Yip</p>
<p>Twitter @miloyip
<a href="http://www.cnblogs.com/miloyip/" target="_blank"><a href="http://www.cnblogs.com/miloyip/">http://www.cnblogs.com/miloyip/</a></a>
<a href="http://miloyip.seezone.net/" target="_blank"><a href="http://miloyip.seezone.net/">http://miloyip.seezone.net/</a></a>
<a href="">显示删减掉的内容</a></p>
<p><img src="" alt=""> archerzz <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>工具的确是个问题，没有好的工具，很难快速推广。
2010/3/22 Changsheng Jiang <a href="&#109;&#97;&#x69;&#x6c;&#x74;&#111;&#58;&#x5b;&#106;&#105;&#x61;&#110;&#103;&#46;&#x2e;&#46;&#64;&#x67;&#x6d;&#x61;&#105;&#x6c;&#46;&#99;&#111;&#x6d;&#93;&#40;&#41;">&#x5b;&#106;&#105;&#x61;&#110;&#103;&#46;&#x2e;&#46;&#64;&#x67;&#x6d;&#x61;&#105;&#x6c;&#46;&#99;&#111;&#x6d;&#93;&#40;&#41;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>个人觉得最大障碍在工具上.</p>
<p>并行学术上研究得不少, 主要在算法和模型上. 工程上的工具, 多是自串行程序来设计的, 弄得复杂不堪. 并行需要语言和库两级支持, Pthreads 和 MPI 仅从库上入手, 让程序员处理各种重复且复杂的分发, 并发锁等. OpenMP好一些, 可惜目前只支持线程并行.
用 ErLang 等将并行设计在语言里的来做并行会容易得多, 得易于面向消息传递的隔离模型, 程序稳定易写. 模型和语言的性能是一个问题, 主要的问题还在用的人和实际并行项目不多.</p>
<p>调试工具就更少了. 有少数商业化的工具.
当然, 我是将可维护性归结为语言工具太差.</p>
<pre><code>                                                 Changsheng Jiang
</code></pre><p>2010/3/22 Guancheng Chen <a href="&#x6d;&#x61;&#x69;&#x6c;&#116;&#x6f;&#58;&#91;&#x63;&#104;&#x65;&#x6e;&#103;&#x75;&#46;&#x2e;&#46;&#64;&#x67;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#x28;&#x29;">&#91;&#x63;&#104;&#x65;&#x6e;&#103;&#x75;&#46;&#x2e;&#46;&#64;&#x67;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#x28;&#x29;</a></p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问“什么是实施并行编程的最大障
碍”时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。
( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看
<a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/" target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/</a></a>
)</p>
<ol>
<li>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</li>
<li>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是“专家”们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了“编译指导”、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。
可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说“在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶……你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的”，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：“你觉得并行编程容易么？”，十有八九会说“我觉得很难”。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</li>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？
(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx
总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点“教育”有很大关系了。</li>
<li>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</li>
<li>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> 陨落雕 <img src="" alt=""></li>
</ol>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>我也想用Fermi来解一个和ray tracer类似的问题，话说NV招了好多搞ray tracer和hpc的大牛。</p>
<p>On Mar 21, 10:20 pm, Milo Yip <a href="&#109;&#x61;&#x69;&#108;&#x74;&#x6f;&#58;&#91;&#x6d;&#x69;&#108;&#x6f;&#46;&#x2e;&#x2e;&#64;&#103;&#109;&#97;&#x69;&#108;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#40;&#41;">&#91;&#x6d;&#x69;&#108;&#x6f;&#46;&#x2e;&#x2e;&#64;&#103;&#109;&#97;&#x69;&#108;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>我在等NVidia的Fermi和Nexus，想試做全域照明。
但怕買了Fermi後，機器也只是用來做做翻譯......</p>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>在 2010年3月22日上午9:51，Jeffrey Zhao <a href="&#109;&#x61;&#105;&#108;&#116;&#111;&#x3a;&#x5b;&#106;&#101;&#x2e;&#46;&#x2e;&#64;&#x6c;&#x69;&#x76;&#x65;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#40;&#x29;">&#x5b;&#106;&#101;&#x2e;&#46;&#x2e;&#64;&#x6c;&#x69;&#x76;&#x65;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#40;&#x29;</a> 寫道：</p>
<blockquote>
<p>是嘛，我记得是提交了标准还在审核。</p>
<p>好吧，我去查了一下果然在08年12月1.0 Stable release了。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a>
From: Tinyfool
Sent: Monday, March 22, 2010 9:46 AM
To: <a href="">pon...@googlegroups.com</a>
Subject: Re: [TL] {技术}{多线程}实施并行编程的五大障碍
OpenCL早就出来标准了，而且在做各个平台的实现...
视野啊...</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#109;&#97;&#x69;&#108;&#116;&#111;&#x3a;&#91;&#106;&#101;&#46;&#46;&#x2e;&#64;&#x6c;&#x69;&#x76;&#x65;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#41;">&#91;&#106;&#101;&#46;&#46;&#x2e;&#64;&#x6c;&#x69;&#x76;&#x65;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#41;</a></p>
<blockquote>
<p>哈哈，广告好，扩展视野，那我继续做广告了......</p>
</blockquote>
</blockquote>
</blockquote>
<p>&gt;</p>
<blockquote>
<blockquote>
<blockquote>
<p>微软其实很早就在搞Microsoft Accelerator项目，旨在利用DirectX进行计算，.NET项目。
<a href="http://research.microsoft.com/en-us/projects/Accelerator/" target="_blank"><a href="http://research.microsoft.com/en-us/projects/Accelerator/">http://research.microsoft.com/en-us/projects/Accelerator/</a></a></p>
<p>然后F/#这边由于语言的支持良好，可以设计出丰富的表达式、DSL等Modeling
Language，再由框架进行自动并行，解决问题可以很容易（已经2.0了）。</p>
<p>这篇文章是个简单介绍：<a href="http://strangelights.com/blog/archive/2008/09/21/1628.aspx" target="_blank"><a href="http://strangelights.com/blog/archive/2008/09/21/1628.aspx">http://strangelights.com/blog/archive/2008/09/21/1628.aspx</a></a></p>
<p>Microsoft Solver Foundation
<a href="http://code.msdn.microsoft.com/solverfoundation" target="_blank"><a href="http://code.msdn.microsoft.com/solverfoundation">http://code.msdn.microsoft.com/solverfoundation</a></a></p>
<p>F/# Optimization Modeling Language Utilizing Microsoft Solver Foundation
<a href="http://code.msdn.microsoft.com/solverfoundationfs1" target="_blank"><a href="http://code.msdn.microsoft.com/solverfoundationfs1">http://code.msdn.microsoft.com/solverfoundationfs1</a></a></p>
<p>现在就等OpenCL如果有标准出来，肯定立马可以跟上个类库，哦耶。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a>
From: Tinyfool
Sent: Monday, March 22, 2010 9:20 AM
To: <a href="">pon...@googlegroups.com</a>
Subject: Re: [TL] {技术}{多线程}实施并行编程的五大障碍
唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下
Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？
还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#109;&#x61;&#105;&#108;&#x74;&#111;&#x3a;&#91;&#106;&#101;&#x2e;&#46;&#x2e;&#x40;&#108;&#105;&#x76;&#x65;&#46;&#99;&#x6f;&#109;&#x5d;&#x28;&#x29;">&#91;&#106;&#101;&#x2e;&#46;&#x2e;&#x40;&#108;&#105;&#x76;&#x65;&#46;&#99;&#x6f;&#109;&#x5d;&#x28;&#x29;</a></p>
<blockquote>
<p>我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>&gt;</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a>
From: Guancheng Chen
Sent: Monday, March 22, 2010 7:37 AM
To: TopLanguage
Subject: [TL] {技术}{多线程}实施并行编程的五大障碍
近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..</p>
<p>)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。</p>
<p>尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这</li>
</ol>
</blockquote>
</blockquote>
</blockquote>
<p>...</p>
<p>read more &gt;&gt;
<a href="">显示删减掉的内容</a></p>
</blockquote>
<p><img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>微软好像已经推出了跟OpenCL类似的Direct Compute，也能搞GPU CPU混合计算</p>
<p>On 3月22日, 上午2时42分, &quot;Jeffrey Zhao&quot; <a href="&#x6d;&#x61;&#x69;&#x6c;&#116;&#x6f;&#x3a;&#x5b;&#106;&#101;&#x2e;&#46;&#46;&#x40;&#108;&#x69;&#118;&#x65;&#x2e;&#99;&#111;&#x6d;&#x5d;&#x28;&#41;">&#x5b;&#106;&#101;&#x2e;&#46;&#46;&#x40;&#108;&#x69;&#118;&#x65;&#x2e;&#99;&#111;&#x6d;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>哈哈，广告好，扩展视野，那我继续做广告了......</p>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>微软其实很早就在搞Microsoft Accelerator项目，旨在利用DirectX进行计算，.NET项目。<a href="http://research.microsoft.com/en-us/projects/Accelerator/" target="_blank"><a href="http://research.microsoft.com/en-us/projects/Accelerator/">http://research.microsoft.com/en-us/projects/Accelerator/</a></a></p>
<p>然后F/#这边由于语言的支持良好，可以设计出丰富的表达式、DSL等Modeling Language，再由框架进行自动并行，解决问题可以很容易（已经2.0了）。</p>
<p>这篇文章是个简单介绍：<a href="http://strangelights.com/blog/archive/2008/09/21/1628.aspx" target="_blank"><a href="http://strangelights.com/blog/archive/2008/09/21/1628.aspx">http://strangelights.com/blog/archive/2008/09/21/1628.aspx</a></a></p>
<p>Microsoft Solver Foundation<a href="http://[code.msdn.microsoft.com/solverfoundation](http://code.msdn.microsoft.com/solverfoundation" target="_blank">http://[code.msdn.microsoft.com/solverfoundation](http://code.msdn.microsoft.com/solverfoundation</a>)</p>
<p>F/# Optimization Modeling Language Utilizing Microsoft Solver Foundation<a href="http://[code.msdn.microsoft.com/solverfoundationfs1](http://code.msdn.microsoft.com/solverfoundationfs1" target="_blank">http://[code.msdn.microsoft.com/solverfoundationfs1](http://code.msdn.microsoft.com/solverfoundationfs1</a>)</p>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>现在就等OpenCL如果有标准出来，肯定立马可以跟上个类库，哦耶。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p>From: Tinyfool
Sent: Monday, March 22, 2010 9:20 AM
To: <a href="">pon...@googlegroups.com</a>
Subject: Re: [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#109;&#97;&#105;&#108;&#116;&#x6f;&#58;&#91;&#106;&#101;&#46;&#46;&#x2e;&#64;&#x6c;&#105;&#118;&#101;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#41;">&#91;&#106;&#101;&#46;&#46;&#x2e;&#64;&#x6c;&#105;&#118;&#101;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#41;</a></p>
<p>  我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>  其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>  例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>  至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>  例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>  Jeffrey Zhao
  Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
  Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p>  From: Guancheng Chen
  Sent: Monday, March 22, 2010 7:37 AM
  To: TopLanguage
  Subject: [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>  近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
  碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
  (fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
  Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
  的看法。</p>
<p>  ( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看
 <a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..</p>
<p>  )</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。</p>
<p>尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
</li>
<li><p>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</p>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
</li>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可...</p>
</li>
</ol>
<p>阅读更多 &gt;&gt;
<a href="">显示删减掉的内容</a>
<img src="" alt=""> 郑伟 <img src="" alt=""></p>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>我觉得 想要并行开发 必须绕开c/c++
2010/3/22 Guancheng Chen <a href="&#x6d;&#97;&#105;&#x6c;&#116;&#x6f;&#58;&#91;&#x63;&#104;&#x65;&#110;&#103;&#x75;&#x2e;&#x2e;&#46;&#x40;&#103;&#x6d;&#97;&#105;&#108;&#x2e;&#99;&#111;&#109;&#93;&#40;&#x29;">&#91;&#x63;&#104;&#x65;&#110;&#103;&#x75;&#x2e;&#x2e;&#46;&#x40;&#103;&#x6d;&#97;&#105;&#108;&#x2e;&#99;&#111;&#109;&#93;&#40;&#x29;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>微软好像已经推出了跟OpenCL类似的Direct Compute，也能搞GPU CPU混合计算
On 3月22日, 上午2时42分, &quot;Jeffrey Zhao&quot; <a href="&#x6d;&#97;&#105;&#108;&#116;&#x6f;&#58;&#91;&#x6a;&#101;&#46;&#x2e;&#46;&#64;&#x6c;&#x69;&#x76;&#101;&#46;&#x63;&#111;&#x6d;&#93;&#40;&#x29;">&#91;&#x6a;&#101;&#46;&#x2e;&#46;&#64;&#x6c;&#x69;&#x76;&#101;&#46;&#x63;&#111;&#x6d;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>哈哈，广告好，扩展视野，那我继续做广告了......</p>
<p>微软其实很早就在搞Microsoft Accelerator项目，旨在利用DirectX进行计算，.NET项目。<a href="http://research.microsoft.com/en-us/projects/Accelerator/" target="_blank"><a href="http://research.microsoft.com/en-us/projects/Accelerator/">http://research.microsoft.com/en-us/projects/Accelerator/</a></a></p>
<p>然后F/#这边由于语言的支持良好，可以设计出丰富的表达式、DSL等Modeling Language，再由框架进行自动并行，解决问题可以很容易（已经2.0了）。</p>
<p>这篇文章是个简单介绍：<a href="http://strangelights.com/blog/archive/2008/09/21/1628.aspx" target="_blank"><a href="http://strangelights.com/blog/archive/2008/09/21/1628.aspx">http://strangelights.com/blog/archive/2008/09/21/1628.aspx</a></a></p>
<p>Microsoft Solver Foundation<a href="http://[code.msdn.microsoft.com/solverfoundation](http://code.msdn.microsoft.com/solverfoundation" target="_blank">http://[code.msdn.microsoft.com/solverfoundation](http://code.msdn.microsoft.com/solverfoundation</a>)</p>
<p>F/# Optimization Modeling Language Utilizing Microsoft Solver Foundation<a href="http://[code.msdn.microsoft.com/solverfoundationfs1](http://code.msdn.microsoft.com/solverfoundationfs1" target="_blank">http://[code.msdn.microsoft.com/solverfoundationfs1](http://code.msdn.microsoft.com/solverfoundationfs1</a>)</p>
<p>现在就等OpenCL如果有标准出来，肯定立马可以跟上个类库，哦耶。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p>From: Tinyfool
Sent: Monday, March 22, 2010 9:20 AM
To: <a href="">pon...@googlegroups.com</a>
Subject: Re: [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#x6d;&#x61;&#x69;&#108;&#116;&#x6f;&#58;&#x5b;&#106;&#101;&#x2e;&#46;&#46;&#64;&#x6c;&#x69;&#118;&#x65;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#40;&#x29;">&#x5b;&#106;&#101;&#x2e;&#46;&#46;&#64;&#x6c;&#x69;&#118;&#x65;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#40;&#x29;</a></p>
<p>  我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>  其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>  例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>  至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>  例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>  Jeffrey Zhao
  Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
  Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p>  From: Guancheng Chen
  Sent: Monday, March 22, 2010 7:37 AM
  To: TopLanguage
  Subject: [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>  近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
  碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
  (fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
  Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
  的看法。</p>
<p>  ( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看
 <a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
  )</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
</li>
<li><p>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</p>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
</li>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维&gt;   护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可...</p>
</li>
</ol>
<p>阅读更多 &gt;&gt;</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a></p>
<p><img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>很有意思的事情是我上次问过一个负责定制OpenCL的哥们，&quot;从商业角度上讲，苹果为什么要自己搞一个新标准？&quot; 他就说那个时候苹果意识到未来这种
通用并行计算平台的重要性，而为了保证最大的商业利益就选择自己重新搞一个新标准而不是跟当时已有CUDA的Nvidia合作，结果现在NV也开始支持
OpenCL，但是他们最新的一本教材里说到&quot;根据我们的经验，学习OpenCL最好的办法是先学CUDA&quot;</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>On 3月22日, 上午6时10分, 陨落雕 <a href="&#x6d;&#97;&#x69;&#x6c;&#x74;&#111;&#x3a;&#91;&#x67;&#101;&#x6f;&#46;&#46;&#x2e;&#x2e;&#64;&#x67;&#109;&#97;&#x69;&#x6c;&#46;&#x63;&#111;&#109;&#x5d;&#40;&#x29;">&#91;&#x67;&#101;&#x6f;&#46;&#46;&#x2e;&#x2e;&#64;&#x67;&#109;&#97;&#x69;&#x6c;&#46;&#x63;&#111;&#109;&#x5d;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>我也想用Fermi来解一个和ray tracer类似的问题，话说NV招了好多搞ray tracer和hpc的大牛。</p>
<p>On Mar 21, 10:20 pm, Milo Yip <a href="&#x6d;&#97;&#x69;&#108;&#116;&#x6f;&#x3a;&#x5b;&#109;&#105;&#108;&#x6f;&#46;&#46;&#46;&#x40;&#x67;&#109;&#97;&#105;&#x6c;&#x2e;&#x63;&#111;&#109;&#x5d;&#40;&#41;">&#x5b;&#109;&#105;&#108;&#x6f;&#46;&#46;&#46;&#x40;&#x67;&#109;&#97;&#105;&#x6c;&#x2e;&#x63;&#111;&#109;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>我在等NVidia的Fermi和Nexus，想試做全域照明。
但怕買了Fermi後，機器也只是用來做做翻譯......</p>
<p>在 2010年3月22日上午9:51，Jeffrey Zhao <a href="&#x6d;&#97;&#x69;&#x6c;&#116;&#x6f;&#58;&#x5b;&#x6a;&#x65;&#x2e;&#x2e;&#46;&#x40;&#108;&#x69;&#118;&#x65;&#46;&#x63;&#x6f;&#x6d;&#93;&#40;&#41;">&#x5b;&#x6a;&#x65;&#x2e;&#x2e;&#46;&#x40;&#108;&#x69;&#118;&#x65;&#46;&#x63;&#x6f;&#x6d;&#93;&#40;&#41;</a> 寫道：</p>
<blockquote>
<p>是嘛，我记得是提交了标准还在审核。</p>
<p>好吧，我去查了一下果然在08年12月1.0 Stable release了。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a>
From: Tinyfool
Sent: Monday, March 22, 2010 9:46 AM
To: <a href="">pon...@googlegroups.com</a>
Subject: Re: [TL] {技术}{多线程}实施并行编程的五大障碍
OpenCL早就出来标准了，而且在做各个平台的实现...
视野啊...</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#109;&#x61;&#105;&#108;&#116;&#x6f;&#58;&#x5b;&#106;&#x65;&#46;&#46;&#x2e;&#x40;&#108;&#105;&#x76;&#101;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#40;&#x29;">&#x5b;&#106;&#x65;&#46;&#46;&#x2e;&#x40;&#108;&#105;&#x76;&#101;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#40;&#x29;</a></p>
<blockquote>
<p>哈哈，广告好，扩展视野，那我继续做广告了......</p>
<p>微软其实很早就在搞Microsoft Accelerator项目，旨在利用DirectX进行计算，.NET项目。
<a href="http://research.microsoft.com/en-us/projects/Accelerator/" target="_blank"><a href="http://research.microsoft.com/en-us/projects/Accelerator/">http://research.microsoft.com/en-us/projects/Accelerator/</a></a></p>
<p>然后F/#这边由于语言的支持良好，可以设计出丰富的表达式、DSL等Modeling
Language，再由框架进行自动并行，解决问题可以很容易（已经2.0了）。</p>
<p>这篇文章是个简单介绍：<a href="http://strangelights.com/blog/archive/2008/09/21/1628.aspx" target="_blank"><a href="http://strangelights.com/blog/archive/2008/09/21/1628.aspx">http://strangelights.com/blog/archive/2008/09/21/1628.aspx</a></a></p>
<p>Microsoft Solver Foundation
<a href="http://code.msdn.microsoft.com/solverfoundation" target="_blank"><a href="http://code.msdn.microsoft.com/solverfoundation">http://code.msdn.microsoft.com/solverfoundation</a></a></p>
<p>F/# Optimization Modeling Language Utilizing Microsoft Solver Foundation
<a href="http://code.msdn.microsoft.com/solverfoundationfs1" target="_blank"><a href="http://code.msdn.microsoft.com/solverfoundationfs1">http://code.msdn.microsoft.com/solverfoundationfs1</a></a></p>
<p>现在就等OpenCL如果有标准出来，肯定立马可以跟上个类库，哦耶。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a>
From: Tinyfool
Sent: Monday, March 22, 2010 9:20 AM
To: <a href="">pon...@googlegroups.com</a>
Subject: Re: [TL] {技术}{多线程}实施并行编程的五大障碍
唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下
Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？
还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#109;&#97;&#x69;&#108;&#116;&#111;&#x3a;&#91;&#x6a;&#101;&#46;&#x2e;&#x2e;&#64;&#x6c;&#105;&#118;&#x65;&#x2e;&#x63;&#111;&#109;&#x5d;&#40;&#x29;">&#91;&#x6a;&#101;&#46;&#x2e;&#x2e;&#64;&#x6c;&#105;&#118;&#x65;&#x2e;&#x63;&#111;&#109;&#x5d;&#40;&#x29;</a></p>
<blockquote>
<p>我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a>
From: Guancheng Chen
Sent: Monday, March 22, 2010 7:37 AM
To: TopLanguage
Subject: [TL] {技术}{多线程}实施并行编程的五大障碍
近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li>对众核的恐惧...</li>
</ol>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>阅读更多 &gt;&gt;
<a href="">显示删减掉的内容</a>
<img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>不知道您觉得现有的工具哪些个最趁手呢？</p>
<p>On 3月22日, 上午3时19分, Changsheng Jiang <a href="&#x6d;&#97;&#x69;&#108;&#116;&#x6f;&#58;&#91;&#106;&#x69;&#x61;&#110;&#103;&#x7a;&#117;&#111;&#x2e;&#46;&#46;&#64;&#x67;&#109;&#x61;&#105;&#x6c;&#x2e;&#99;&#111;&#109;&#93;&#x28;&#x29;">&#91;&#106;&#x69;&#x61;&#110;&#103;&#x7a;&#117;&#111;&#x2e;&#46;&#46;&#64;&#x67;&#109;&#x61;&#105;&#x6c;&#x2e;&#99;&#111;&#109;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>个人觉得最大障碍在工具上.</p>
<p>并行学术上研究得不少, 主要在算法和模型上. 工程上的工具, 多是自串行程序来设计的, 弄得复杂不堪. 并行需要语言和库两级支持, Pthreads 和
MPI 仅从库上入手, 让程序员处理各种重复且复杂的分发, 并发锁等. OpenMP好一些, 可惜目前只支持线程并行.</p>
<p>用 ErLang 等将并行设计在语言里的来做并行会容易得多, 得易于面向消息传递的隔离模型, 程序稳定易写. 模型和语言的性能是一个问题,
主要的问题还在用的人和实际并行项目不多.</p>
<p>调试工具就更少了. 有少数商业化的工具.</p>
<p>当然, 我是将可维护性归结为语言工具太差.</p>
<pre><code>                                                 Changsheng Jiang
</code></pre><p>2010/3/22 Guancheng Chen <a href="&#x6d;&#97;&#105;&#x6c;&#116;&#111;&#x3a;&#x5b;&#99;&#x68;&#x65;&#x6e;&#x67;&#117;&#x61;&#110;&#x63;&#x68;&#x2e;&#46;&#46;&#x40;&#x67;&#x6d;&#97;&#x69;&#x6c;&#46;&#99;&#x6f;&#109;&#x5d;&#x28;&#41;">&#x5b;&#99;&#x68;&#x65;&#x6e;&#x67;&#117;&#x61;&#110;&#x63;&#x68;&#x2e;&#46;&#46;&#x40;&#x67;&#x6d;&#97;&#x69;&#x6c;&#46;&#99;&#x6f;&#109;&#x5d;&#x28;&#41;</a></p>
</blockquote>
<p>&gt;
&gt;
&gt;</p>
<blockquote>
<blockquote>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..</p>
<p>)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。</p>
</blockquote>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<blockquote>
<blockquote>
<p>尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。</p>
</li>
</ol>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
<a href="">显示删减掉的内容</a></p>
</blockquote>
</blockquote>
<p><img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>哈哈 是想绕开C++那些本来就复杂的要死的feature么？是不是如果有一门新的易用的编程语言会比诸如给C++添加thread特性的方法要
好？</p>
<p>On 3月22日, 上午6时48分, Kula <a href="&#109;&#x61;&#x69;&#x6c;&#116;&#x6f;&#58;&#x5b;&#x6b;&#117;&#108;&#97;&#x73;&#46;&#46;&#x2e;&#64;&#x67;&#109;&#x61;&#105;&#108;&#46;&#99;&#111;&#x6d;&#x5d;&#40;&#x29;">&#x5b;&#x6b;&#117;&#108;&#97;&#x73;&#46;&#46;&#x2e;&#64;&#x67;&#109;&#x61;&#105;&#108;&#46;&#99;&#111;&#x6d;&#x5d;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>我觉得 想要并行开发 必须绕开c/c++</p>
<p>2010/3/22 Guancheng Chen <a href="&#109;&#x61;&#x69;&#x6c;&#x74;&#111;&#x3a;&#x5b;&#99;&#104;&#x65;&#x6e;&#103;&#x75;&#97;&#110;&#x63;&#x68;&#46;&#46;&#x2e;&#x40;&#x67;&#x6d;&#97;&#105;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#40;&#41;">&#x5b;&#99;&#104;&#x65;&#x6e;&#103;&#x75;&#97;&#110;&#x63;&#x68;&#46;&#46;&#x2e;&#x40;&#x67;&#x6d;&#97;&#105;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#40;&#41;</a></p>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>&gt;
&gt;
&gt;</p>
<blockquote>
<blockquote>
<p>微软好像已经推出了跟OpenCL类似的Direct Compute，也能搞GPU CPU混合计算</p>
<p>On 3月22日, 上午2时42分, &quot;Jeffrey Zhao&quot; <a href="&#109;&#97;&#105;&#x6c;&#x74;&#111;&#58;&#x5b;&#106;&#x65;&#46;&#x2e;&#46;&#64;&#x6c;&#105;&#x76;&#x65;&#46;&#x63;&#x6f;&#109;&#93;&#40;&#41;">&#x5b;&#106;&#x65;&#46;&#x2e;&#46;&#64;&#x6c;&#105;&#x76;&#x65;&#46;&#x63;&#x6f;&#109;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>哈哈，广告好，扩展视野，那我继续做广告了......</p>
<p>微软其实很早就在搞Microsoft Accelerator项目，旨在利用DirectX进行计算，.NET项目。
<a href="http://research.microsoft.com/en-us/projects/Accelerator/" target="_blank"><a href="http://research.microsoft.com/en-us/projects/Accelerator/">http://research.microsoft.com/en-us/projects/Accelerator/</a></a></p>
<p>然后F/#这边由于语言的支持良好，可以设计出丰富的表达式、DSL等Modeling
Language，再由框架进行自动并行，解决问题可以很容易（已经2.0了）。</p>
<p>这篇文章是个简单介绍：<a href="http://strangelights.com/blog/archive/2008/09/21/1628.aspx" target="_blank"><a href="http://strangelights.com/blog/archive/2008/09/21/1628.aspx">http://strangelights.com/blog/archive/2008/09/21/1628.aspx</a></a></p>
<p>Microsoft Solver Foundationhttp://
<a href="http://code.msdn.microsoft.com/solverfoundation" target="_blank">code.msdn.microsoft.com/solverfoundation</a></p>
<p>F/# Optimization Modeling Language Utilizing Microsoft Solver
Foundation<a href="http://[code.msdn.microsoft.com/solverfoundationfs1](http://code.msdn.microsoft.com/solverfoundationfs1" target="_blank">http://[code.msdn.microsoft.com/solverfoundationfs1](http://code.msdn.microsoft.com/solverfoundationfs1</a>)</p>
<p>现在就等OpenCL如果有标准出来，肯定立马可以跟上个类库，哦耶。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p>From: Tinyfool
Sent: Monday, March 22, 2010 9:20 AM
To: <a href="">pon...@googlegroups.com</a>
Subject: Re: [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#111;&#58;&#x5b;&#x6a;&#101;&#x2e;&#x2e;&#x2e;&#x40;&#x6c;&#105;&#118;&#101;&#46;&#99;&#x6f;&#109;&#x5d;&#40;&#41;">&#x5b;&#x6a;&#101;&#x2e;&#x2e;&#x2e;&#x40;&#x6c;&#105;&#118;&#101;&#46;&#99;&#x6f;&#109;&#x5d;&#40;&#41;</a></p>
<p>  我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>  其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>  例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>  至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>  例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>  Jeffrey Zhao
  Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
  Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p>  From: Guancheng Chen
  Sent: Monday, March 22, 2010 7:37 AM
  To: TopLanguage
  Subject: [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>  近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
  碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
  (fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
  Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
  的看法。</p>
<p>  ( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看
 <a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-" target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a></a>.
..
  )</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线</p>
</li>
</ol>
</blockquote>
<p>程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。</p>
<blockquote>
<p>  尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
  并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
  好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
  和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
  OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
  训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li><p>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</p>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
</li>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false...</p>
</li>
</ol>
</blockquote>
</blockquote>
<p>阅读更多 &gt;&gt;
<a href="">显示删减掉的内容</a>
<img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>On 3月22日, 上午2时20分, Tinyfool <a href="&#109;&#97;&#x69;&#108;&#x74;&#x6f;&#x3a;&#x5b;&#x74;&#105;&#x6e;&#121;&#x66;&#46;&#x2e;&#46;&#64;&#x67;&#x6d;&#97;&#x69;&#108;&#x2e;&#99;&#111;&#x6d;&#93;&#x28;&#41;">&#x5b;&#x74;&#105;&#x6e;&#121;&#x66;&#46;&#x2e;&#46;&#64;&#x67;&#x6d;&#97;&#x69;&#108;&#x2e;&#99;&#111;&#x6d;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#x6d;&#97;&#x69;&#x6c;&#116;&#x6f;&#58;&#91;&#106;&#101;&#46;&#x2e;&#x2e;&#x40;&#x6c;&#105;&#118;&#101;&#46;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#x29;">&#91;&#106;&#101;&#46;&#x2e;&#x2e;&#x40;&#x6c;&#105;&#118;&#101;&#46;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#x29;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
</blockquote>
</blockquote>
<p>&gt;</p>
<blockquote>
<blockquote>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#x6d;&#x61;&#x69;&#x6c;&#116;&#111;&#x3a;&#x5b;&#99;&#104;&#101;&#110;&#x67;&#117;&#x61;&#x6e;&#x63;&#x68;&#46;&#x2e;&#46;&#x40;&#103;&#x6d;&#x61;&#105;&#108;&#x2e;&#99;&#111;&#109;&#93;&#x28;&#41;">&#x5b;&#99;&#104;&#101;&#110;&#x67;&#117;&#x61;&#x6e;&#x63;&#x68;&#46;&#x2e;&#46;&#x40;&#103;&#x6d;&#x61;&#105;&#108;&#x2e;&#99;&#111;&#109;&#93;&#x28;&#41;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#109;&#x61;&#105;&#x6c;&#116;&#111;&#58;&#x5b;&#112;&#111;&#110;&#x2e;&#46;&#46;&#64;&#103;&#x6f;&#111;&#x67;&#x6c;&#x65;&#x67;&#x72;&#111;&#x75;&#x70;&#x73;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#x28;&#x29;">&#x5b;&#112;&#111;&#110;&#x2e;&#46;&#46;&#64;&#103;&#x6f;&#111;&#x67;&#x6c;&#x65;&#x67;&#x72;&#111;&#x75;&#x70;&#x73;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#x28;&#x29;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
</blockquote>
</blockquote>
<p>&gt;</p>
<blockquote>
<blockquote>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..</p>
<p>)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。</p>
</blockquote>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<blockquote>
<blockquote>
<p>尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。</p>
</li>
</ol>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>--
Tinyfool的开发日记<a href="http://www.tinydust.net/dev/" target="_blank"><a href="http://www.tinydust.net/dev/">http://www.tinydust.net/dev/</a></a>
代码中国网<a href="http://www.codechina.org/" target="_blank"><a href="http://www.codechina.org">http://www.codechina.org</a></a>
myTwitter:<a href="http://twitter.com/tinyfool" target="_blank"><a href="http://twitter.com/tinyfool">http://twitter.com/tinyfool</a></a>
<a href="">显示删减掉的内容</a></p>
</blockquote>
<p><img src="" alt=""> changsheng <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>说来惭愧, 接触并行时间不长, 没什么实际经验, 只写过几个并行程序.</p>
<p>感觉 MPI + OpenMP 倒算好用. 简单的单机程序, 用OpenMP并行, 添加几个编译指令就可以. 复杂点的, 用MPI, 也能忍, 只是需要重新设计一下程序和算法.
除了简单的打印, 跟踪一个进程, 不知道怎么调试并行程序. 没有专用平台如NUMA等的编程经验.</p>
<pre><code>                                                 Changsheng Jiang
</code></pre><p>2010/3/22 Guancheng Chen <a href="&#109;&#97;&#105;&#108;&#x74;&#x6f;&#x3a;&#x5b;&#x63;&#x68;&#101;&#x6e;&#x67;&#117;&#x2e;&#46;&#46;&#64;&#x67;&#109;&#x61;&#105;&#108;&#x2e;&#99;&#111;&#109;&#93;&#x28;&#x29;">&#x5b;&#x63;&#x68;&#101;&#x6e;&#x67;&#117;&#x2e;&#46;&#46;&#64;&#x67;&#109;&#x61;&#105;&#108;&#x2e;&#99;&#111;&#109;&#93;&#x28;&#x29;</a>
不知道您觉得现有的工具哪些个最趁手呢？
On 3月22日, 上午3时19分, Changsheng Jiang <a href="&#x6d;&#x61;&#x69;&#108;&#x74;&#111;&#58;&#91;&#x6a;&#105;&#x61;&#x6e;&#x67;&#122;&#x75;&#111;&#x2e;&#46;&#46;&#x40;&#103;&#x6d;&#x61;&#x69;&#x6c;&#46;&#x63;&#x6f;&#109;&#x5d;&#x28;&#x29;">&#91;&#x6a;&#105;&#x61;&#x6e;&#x67;&#122;&#x75;&#111;&#x2e;&#46;&#46;&#x40;&#103;&#x6d;&#x61;&#x69;&#x6c;&#46;&#x63;&#x6f;&#109;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>个人觉得最大障碍在工具上.</p>
<p>并行学术上研究得不少, 主要在算法和模型上. 工程上的工具, 多是自串行程序来设计的, 弄得复杂不堪. 并行需要语言和库两级支持, Pthreads 和
MPI 仅从库上入手, 让程序员处理各种重复且复杂的分发, 并发锁等. OpenMP好一些, 可惜目前只支持线程并行.</p>
<p>用 ErLang 等将并行设计在语言里的来做并行会容易得多, 得易于面向消息传递的隔离模型, 程序稳定易写. 模型和语言的性能是一个问题,
主要的问题还在用的人和实际并行项目不多.</p>
<p>调试工具就更少了. 有少数商业化的工具.</p>
<p>当然, 我是将可维护性归结为语言工具太差.</p>
<pre><code>                                                 Changsheng Jiang
</code></pre><p>2010/3/22 Guancheng Chen <a href="&#x6d;&#97;&#105;&#108;&#116;&#111;&#58;&#91;&#x63;&#x68;&#101;&#110;&#x67;&#x75;&#x61;&#x6e;&#x63;&#x68;&#x2e;&#x2e;&#46;&#64;&#x67;&#109;&#97;&#x69;&#108;&#46;&#99;&#111;&#109;&#x5d;&#x28;&#41;">&#91;&#x63;&#x68;&#101;&#110;&#x67;&#x75;&#x61;&#x6e;&#x63;&#x68;&#x2e;&#x2e;&#46;&#64;&#x67;&#109;&#97;&#x69;&#108;&#46;&#99;&#111;&#109;&#x5d;&#x28;&#41;</a></p>
<blockquote>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。</p>
</li>
</ol>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> doyle <img src="" alt=""></p>
</blockquote>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>2010/3/22 Guancheng Chen <a href="&#109;&#97;&#105;&#x6c;&#x74;&#x6f;&#x3a;&#91;&#99;&#104;&#101;&#x6e;&#x67;&#x75;&#46;&#46;&#46;&#64;&#x67;&#x6d;&#97;&#x69;&#108;&#46;&#99;&#x6f;&#109;&#x5d;&#40;&#x29;">&#91;&#99;&#104;&#101;&#x6e;&#x67;&#x75;&#46;&#46;&#46;&#64;&#x67;&#x6d;&#97;&#x69;&#108;&#46;&#99;&#x6f;&#109;&#x5d;&#40;&#x29;</a>
我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>我也是被蛊惑了...所以向老婆提申请来着,结果被否掉了...
 On 3月22日, 上午2时20分, Tinyfool <a href="&#109;&#97;&#x69;&#108;&#x74;&#111;&#x3a;&#91;&#116;&#105;&#110;&#x79;&#x66;&#46;&#x2e;&#46;&#64;&#x67;&#x6d;&#x61;&#105;&#108;&#46;&#99;&#111;&#x6d;&#x5d;&#x28;&#x29;">&#91;&#116;&#105;&#110;&#x79;&#x66;&#46;&#x2e;&#46;&#64;&#x67;&#x6d;&#x61;&#105;&#108;&#46;&#99;&#111;&#x6d;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#x6d;&#97;&#105;&#108;&#x74;&#111;&#58;&#91;&#x6a;&#x65;&#46;&#x2e;&#46;&#64;&#108;&#x69;&#x76;&#x65;&#46;&#x63;&#111;&#x6d;&#x5d;&#x28;&#x29;">&#91;&#x6a;&#x65;&#46;&#x2e;&#46;&#64;&#108;&#x69;&#x76;&#x65;&#46;&#x63;&#111;&#x6d;&#x5d;&#x28;&#x29;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#x6d;&#x61;&#105;&#108;&#x74;&#111;&#x3a;&#x5b;&#99;&#x68;&#x65;&#110;&#103;&#x75;&#97;&#110;&#99;&#104;&#46;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#99;&#111;&#x6d;&#93;&#40;&#41;">&#x5b;&#99;&#x68;&#x65;&#110;&#103;&#x75;&#97;&#110;&#99;&#104;&#46;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#99;&#111;&#x6d;&#93;&#40;&#41;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#109;&#97;&#105;&#x6c;&#x74;&#x6f;&#58;&#91;&#112;&#x6f;&#x6e;&#x2e;&#46;&#46;&#x40;&#x67;&#111;&#x6f;&#x67;&#x6c;&#101;&#103;&#x72;&#x6f;&#117;&#x70;&#115;&#x2e;&#x63;&#111;&#109;&#x5d;&#40;&#x29;">&#91;&#112;&#x6f;&#x6e;&#x2e;&#46;&#46;&#x40;&#x67;&#111;&#x6f;&#x67;&#x6c;&#101;&#103;&#x72;&#x6f;&#117;&#x70;&#115;&#x2e;&#x63;&#111;&#109;&#x5d;&#40;&#x29;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
</blockquote>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>&gt;</p>
<blockquote>
<blockquote>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。</p>
</li>
</ol>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>--</p>
<p>Tinyfool的开发日记<a href="http://www.tinydust.net/dev/" target="_blank"><a href="http://www.tinydust.net/dev/">http://www.tinydust.net/dev/</a></a>
代码中国网<a href="http://www.codechina.org/" target="_blank"><a href="http://www.codechina.org">http://www.codechina.org</a></a>
myTwitter:<a href="http://twitter.com/tinyfool" target="_blank"><a href="http://twitter.com/tinyfool">http://twitter.com/tinyfool</a></a></p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a></p>
<p><img src="" alt=""> tinyfool <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>热烈支持，哈哈
2010/3/22 Guancheng Chen <a href="&#x6d;&#97;&#105;&#108;&#x74;&#111;&#x3a;&#91;&#x63;&#x68;&#101;&#110;&#x67;&#117;&#46;&#46;&#x2e;&#64;&#x67;&#x6d;&#97;&#x69;&#108;&#x2e;&#99;&#x6f;&#109;&#93;&#x28;&#x29;">&#91;&#x63;&#x68;&#101;&#110;&#x67;&#117;&#46;&#46;&#x2e;&#64;&#x67;&#x6d;&#97;&#x69;&#108;&#x2e;&#99;&#x6f;&#109;&#93;&#x28;&#x29;</a>
我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>On 3月22日, 上午2时20分, Tinyfool <a href="&#109;&#97;&#x69;&#108;&#116;&#x6f;&#58;&#91;&#x74;&#105;&#110;&#x79;&#x66;&#x2e;&#46;&#x2e;&#64;&#x67;&#x6d;&#x61;&#105;&#x6c;&#46;&#99;&#111;&#x6d;&#x5d;&#x28;&#41;">&#91;&#x74;&#105;&#110;&#x79;&#x66;&#x2e;&#46;&#x2e;&#64;&#x67;&#x6d;&#x61;&#105;&#x6c;&#46;&#99;&#111;&#x6d;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p><a href="">显示删减掉的内容</a>
<img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>我个人也觉得OpenMP是目前比较好用的并行方式。像您这样设计算法的程序员，是不是基本上也是只对串行算法做优化改进，然后性能瓶颈比较大的部分才
考虑实施并行化？</p>
<p>On 3月22日, 上午7时09分, Changsheng Jiang <a href="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#111;&#58;&#91;&#x6a;&#105;&#x61;&#110;&#103;&#122;&#x75;&#x6f;&#46;&#46;&#x2e;&#x40;&#x67;&#109;&#97;&#x69;&#108;&#46;&#99;&#x6f;&#109;&#93;&#x28;&#41;">&#91;&#x6a;&#105;&#x61;&#110;&#103;&#122;&#x75;&#x6f;&#46;&#46;&#x2e;&#x40;&#x67;&#109;&#97;&#x69;&#108;&#46;&#99;&#x6f;&#109;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>说来惭愧, 接触并行时间不长, 没什么实际经验, 只写过几个并行程序.</p>
<p>感觉 MPI + OpenMP 倒算好用. 简单的单机程序, 用OpenMP并行, 添加几个编译指令就可以. 复杂点的, 用MPI, 也能忍,
只是需要重新设计一下程序和算法.</p>
<p>除了简单的打印, 跟踪一个进程, 不知道怎么调试并行程序. 没有专用平台如NUMA等的编程经验.</p>
<pre><code>                                                 Changsheng Jiang
</code></pre><p>2010/3/22 Guancheng Chen <a href="&#109;&#97;&#105;&#x6c;&#116;&#111;&#58;&#91;&#99;&#x68;&#101;&#110;&#103;&#117;&#x61;&#x6e;&#99;&#x68;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#x61;&#105;&#x6c;&#46;&#99;&#x6f;&#x6d;&#93;&#x28;&#x29;">&#91;&#99;&#x68;&#101;&#110;&#103;&#117;&#x61;&#x6e;&#99;&#x68;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#x61;&#105;&#x6c;&#46;&#99;&#x6f;&#x6d;&#93;&#x28;&#x29;</a></p>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>&gt;
&gt;
&gt;</p>
<blockquote>
<blockquote>
<p>不知道您觉得现有的工具哪些个最趁手呢？</p>
<p>On 3月22日, 上午3时19分, Changsheng Jiang <a href="&#109;&#x61;&#x69;&#x6c;&#x74;&#x6f;&#58;&#x5b;&#x6a;&#105;&#97;&#x6e;&#x67;&#x7a;&#x75;&#111;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#109;&#x61;&#x69;&#x6c;&#46;&#99;&#x6f;&#x6d;&#x5d;&#40;&#x29;">&#x5b;&#x6a;&#105;&#97;&#x6e;&#x67;&#x7a;&#x75;&#111;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#109;&#x61;&#x69;&#x6c;&#46;&#99;&#x6f;&#x6d;&#x5d;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>个人觉得最大障碍在工具上.</p>
<p>并行学术上研究得不少, 主要在算法和模型上. 工程上的工具, 多是自串行程序来设计的, 弄得复杂不堪. 并行需要语言和库两级支持,
Pthreads 和
MPI 仅从库上入手, 让程序员处理各种重复且复杂的分发, 并发锁等. OpenMP好一些, 可惜目前只支持线程并行.</p>
<p>用 ErLang 等将并行设计在语言里的来做并行会容易得多, 得易于面向消息传递的隔离模型, 程序稳定易写. 模型和语言的性能是一个问题,
主要的问题还在用的人和实际并行项目不多.</p>
<p>调试工具就更少了. 有少数商业化的工具.</p>
<p>当然, 我是将可维护性归结为语言工具太差.</p>
<pre><code>                                                 Changsheng Jiang
</code></pre><p>2010/3/22 Guancheng Chen <a href="&#109;&#x61;&#105;&#108;&#116;&#x6f;&#58;&#91;&#x63;&#104;&#101;&#x6e;&#103;&#x75;&#97;&#110;&#99;&#x68;&#x2e;&#46;&#x2e;&#x40;&#103;&#x6d;&#x61;&#x69;&#108;&#46;&#x63;&#111;&#109;&#93;&#40;&#x29;">&#91;&#x63;&#104;&#101;&#x6e;&#103;&#x75;&#97;&#110;&#99;&#x68;&#x2e;&#46;&#x2e;&#x40;&#103;&#x6d;&#x61;&#x69;&#108;&#46;&#x63;&#111;&#109;&#93;&#40;&#x29;</a></p>
<blockquote>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-" target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a></a>.
..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线</p>
</blockquote>
</blockquote>
<p>程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。</p>
<blockquote>
<blockquote>
<p>尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。</p>
</li>
</ol>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
<a href="">显示删减掉的内容</a></p>
</blockquote>
</blockquote>
<p><img src="" alt=""> changsheng <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>说设计算法, 其实, 是实现算法, 找到合适的算法实现了.</p>
<p>五个障碍中的第一条在, 人力有限, 只能并行不并行不行的部分.
                                                     Changsheng Jiang
2010/3/22 Guancheng Chen <a href="&#x6d;&#97;&#105;&#108;&#x74;&#x6f;&#x3a;&#91;&#x63;&#104;&#101;&#x6e;&#103;&#117;&#46;&#46;&#46;&#x40;&#103;&#109;&#97;&#x69;&#108;&#x2e;&#x63;&#111;&#x6d;&#93;&#40;&#41;">&#91;&#x63;&#104;&#101;&#x6e;&#103;&#117;&#46;&#46;&#46;&#x40;&#103;&#109;&#97;&#x69;&#108;&#x2e;&#x63;&#111;&#x6d;&#93;&#40;&#41;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>我个人也觉得OpenMP是目前比较好用的并行方式。像您这样设计算法的程序员，是不是基本上也是只对串行算法做优化改进，然后性能瓶颈比较大的部分才
考虑实施并行化？
On 3月22日, 上午7时09分, Changsheng Jiang <a href="&#x6d;&#x61;&#x69;&#108;&#x74;&#x6f;&#58;&#x5b;&#106;&#x69;&#x61;&#x6e;&#x67;&#122;&#x75;&#111;&#46;&#46;&#x2e;&#64;&#103;&#x6d;&#x61;&#x69;&#x6c;&#46;&#x63;&#111;&#109;&#x5d;&#x28;&#41;">&#x5b;&#106;&#x69;&#x61;&#x6e;&#x67;&#122;&#x75;&#111;&#46;&#46;&#x2e;&#64;&#103;&#x6d;&#x61;&#x69;&#x6c;&#46;&#x63;&#111;&#109;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>说来惭愧, 接触并行时间不长, 没什么实际经验, 只写过几个并行程序.</p>
<p>感觉 MPI + OpenMP 倒算好用. 简单的单机程序, 用OpenMP并行, 添加几个编译指令就可以. 复杂点的, 用MPI, 也能忍,
只是需要重新设计一下程序和算法.</p>
<p>除了简单的打印, 跟踪一个进程, 不知道怎么调试并行程序. 没有专用平台如NUMA等的编程经验.</p>
<pre><code>                                                 Changsheng Jiang
</code></pre><p>2010/3/22 Guancheng Chen <a href="&#109;&#97;&#105;&#108;&#116;&#x6f;&#58;&#91;&#99;&#x68;&#101;&#110;&#103;&#117;&#97;&#110;&#99;&#x68;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#x61;&#x69;&#x6c;&#46;&#x63;&#111;&#x6d;&#x5d;&#x28;&#x29;">&#91;&#99;&#x68;&#101;&#110;&#103;&#117;&#97;&#110;&#99;&#x68;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#x61;&#x69;&#x6c;&#46;&#x63;&#111;&#x6d;&#x5d;&#x28;&#x29;</a></p>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>&gt;
&gt;
&gt;</p>
<blockquote>
<blockquote>
<p>不知道您觉得现有的工具哪些个最趁手呢？</p>
<p>On 3月22日, 上午3时19分, Changsheng Jiang <a href="&#109;&#x61;&#x69;&#x6c;&#x74;&#111;&#58;&#x5b;&#106;&#x69;&#97;&#x6e;&#103;&#x7a;&#x75;&#111;&#46;&#x2e;&#46;&#x40;&#103;&#109;&#x61;&#x69;&#x6c;&#46;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#41;">&#x5b;&#106;&#x69;&#97;&#x6e;&#103;&#x7a;&#x75;&#111;&#46;&#x2e;&#46;&#x40;&#103;&#109;&#x61;&#x69;&#x6c;&#46;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>个人觉得最大障碍在工具上.</p>
<p>并行学术上研究得不少, 主要在算法和模型上. 工程上的工具, 多是自串行程序来设计的, 弄得复杂不堪. 并行需要语言和库两级支持,
Pthreads 和
MPI 仅从库上入手, 让程序员处理各种重复且复杂的分发, 并发锁等. OpenMP好一些, 可惜目前只支持线程并行.</p>
<p>用 ErLang 等将并行设计在语言里的来做并行会容易得多, 得易于面向消息传递的隔离模型, 程序稳定易写. 模型和语言的性能是一个问题,
主要的问题还在用的人和实际并行项目不多.</p>
<p>调试工具就更少了. 有少数商业化的工具.</p>
<p>当然, 我是将可维护性归结为语言工具太差.</p>
<pre><code>                                                 Changsheng Jiang
</code></pre><p>2010/3/22 Guancheng Chen <a href="&#x6d;&#x61;&#105;&#x6c;&#x74;&#x6f;&#58;&#91;&#x63;&#x68;&#x65;&#110;&#x67;&#x75;&#97;&#110;&#99;&#104;&#46;&#46;&#x2e;&#64;&#x67;&#109;&#x61;&#105;&#x6c;&#46;&#99;&#x6f;&#109;&#93;&#x28;&#x29;">&#91;&#x63;&#x68;&#x65;&#110;&#x67;&#x75;&#97;&#110;&#99;&#104;&#46;&#46;&#x2e;&#64;&#x67;&#109;&#x61;&#105;&#x6c;&#46;&#99;&#x6f;&#109;&#93;&#x28;&#x29;</a></p>
<blockquote>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-" target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a></a>.
..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线</p>
</blockquote>
</blockquote>
<p>程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。</p>
<blockquote>
<blockquote>
<p>尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。</p>
</li>
</ol>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
 To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> Alleluia <img src="" alt=""></p>
</blockquote>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>Parallelism 说到底是算法问题.Parallelism与Concurrency不同,Concurrency所面对的问题相对的单一可以
让一群有经验的专家来实现一套通用库或者语言来提供一个基本的编程框架.而在Parallelism上,具体的不同问题,其所需要并行的算法是根本不同
的.原因在于不同的问题,其内部的DataDependency的结构完全不同,不同的Data Dependency的结构,需要构造不同的算法.即
便是相同的Data Dependency,在不同的颗粒度下，在不同的硬件条件下所采用的算法也是完全不同的.因为一旦出现Data
Dependency也就意味着并行计算模块之间需要进行通信.从以计算节点为单位的分布式并行,到多核CPU上的Numa结构,到SIMD上的向量处
理器,其计算单元之间的通信手段,通信效率简直天差地别.比如说,在SMP上最常见的并行算法,work stealing也就是Intel的TBB,
是建立在两个条件下第一个是CPU的Cache机制上,这使得通常在内存的之间的数据搬运消耗非常小,第二个是SMP上计算单元相对的少,因此每个计算
单元被分配到的任务就相对的重。其开销远远大于通信的开销,因此这种机制在SMP上相对的划算.但是如果你要在GPU上做Work Stealing就
完全不可行,因为GPU的运算单元数量极多,被分配到的任务就相对来说的非常轻量,CUDA上的一个thread很多时候运算一次的时间不会超过
10us,而一次跨Block的线程之间的通信开销就往往要达到100us左右,再加上目前GPU上的Cache机制非常落后导致了需要频繁的通信开销
的Work Stealing在GPU上是非常不划算得.
所以我个人认为在硬件架构没有更多的突破之前,OpenCL这种东西是没有任何生命力的.不要说CPU的并行与GPU之间差异巨大,就是不同的GPU之
间AMD与Nvidia两个也是各自为政,一个平台上跑得非常快的东西,在另外一个平台极大的可能是龟速.其最终的结果估计就是跟Java的
write once run everywhere一样是个大笑话.</p>
<p>On 3月22日, 下午2时06分, Guancheng Chen <a href="&#109;&#97;&#105;&#108;&#116;&#x6f;&#x3a;&#91;&#x63;&#x68;&#101;&#110;&#x67;&#x75;&#97;&#110;&#99;&#104;&#x2e;&#46;&#x2e;&#x40;&#103;&#109;&#x61;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#x29;">&#91;&#x63;&#x68;&#101;&#110;&#x67;&#x75;&#97;&#110;&#99;&#104;&#x2e;&#46;&#x2e;&#x40;&#103;&#109;&#x61;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>On 3月22日, 上午2时20分, Tinyfool <a href="&#109;&#x61;&#x69;&#x6c;&#116;&#x6f;&#58;&#x5b;&#x74;&#x69;&#110;&#121;&#102;&#x2e;&#46;&#46;&#x40;&#x67;&#109;&#97;&#x69;&#108;&#46;&#x63;&#x6f;&#109;&#x5d;&#x28;&#x29;">&#x5b;&#x74;&#x69;&#110;&#121;&#102;&#x2e;&#46;&#46;&#x40;&#x67;&#109;&#97;&#x69;&#108;&#46;&#x63;&#x6f;&#109;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#109;&#x61;&#x69;&#108;&#x74;&#111;&#58;&#91;&#106;&#x65;&#46;&#46;&#x2e;&#x40;&#x6c;&#105;&#118;&#101;&#46;&#x63;&#111;&#x6d;&#93;&#x28;&#x29;">&#91;&#106;&#x65;&#46;&#46;&#x2e;&#x40;&#x6c;&#105;&#118;&#101;&#46;&#x63;&#111;&#x6d;&#93;&#x28;&#x29;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#109;&#x61;&#105;&#x6c;&#116;&#x6f;&#x3a;&#91;&#99;&#x68;&#101;&#110;&#x67;&#x75;&#x61;&#110;&#x63;&#x68;&#46;&#46;&#46;&#64;&#103;&#109;&#97;&#105;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#x29;">&#91;&#99;&#x68;&#101;&#110;&#x67;&#x75;&#x61;&#110;&#x63;&#x68;&#46;&#46;&#46;&#64;&#103;&#109;&#97;&#105;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#x29;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#109;&#x61;&#105;&#x6c;&#116;&#111;&#x3a;&#91;&#x70;&#x6f;&#x6e;&#46;&#x2e;&#46;&#64;&#103;&#x6f;&#111;&#x67;&#x6c;&#x65;&#x67;&#x72;&#x6f;&#x75;&#112;&#115;&#x2e;&#99;&#111;&#109;&#93;&#x28;&#41;">&#91;&#x70;&#x6f;&#x6e;&#46;&#x2e;&#46;&#64;&#103;&#x6f;&#111;&#x67;&#x6c;&#x65;&#x67;&#x72;&#x6f;&#x75;&#112;&#115;&#x2e;&#99;&#111;&#109;&#93;&#x28;&#41;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
</blockquote>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<blockquote>
<blockquote>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。</p>
</li>
</ol>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>--
Tinyfool的开发日记<a href="http://www.tinydust.net/dev/" target="_blank"><a href="http://www.tinydust.net/dev/">http://www.tinydust.net/dev/</a></a>
代码中国网<a href="http://www.codechina.org/" target="_blank"><a href="http://www.codechina.org">http://www.codechina.org</a></a>
myTwitter:<a href="http://twitter.com/tinyfool" target="_blank"><a href="http://twitter.com/tinyfool">http://twitter.com/tinyfool</a></a>
<a href="">显示删减掉的内容</a></p>
</blockquote>
</blockquote>
<p><img src="" alt=""> Alleluia <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>其实并行计算这个东西,对现有的基于文本内容的程序意义不是很大.因为文本内容的数据量增加是线性的.而相对来说,视频音频的数据就完全不同是按平方甚
至是指数增加的.一个文本长度增加一倍,数据量也就增加一倍.而一张图片,长宽增加一倍,数据量要增加四倍.一个既有的算法在没有大的理论突破的前提
下,在特定的硬件平台上能够优化加速5-6倍已经是了不得了.但是对于多媒体数据来说,这个加速真的不算什么.一个算法在720p上快3,4倍,换到
1080p的也就是达到了720p上不加速的效果而已.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>绝大部分的观点Can&#39;t agree more.其实这也是为什么我引用了高老爷子那段话的原因，因为程序的本质就是数据结构和算法，你要没有非常适
合并行的算法那简直就是巧妇难为无米之炊。但是有疑问的一点是关于Parallelism和Concurrency这两个单词的区别，实际上这也是非常
有意思的一件事情，Sun的多线程指南上写的是： Parallelism is a condition that arises when at
least two threads are executing simultaneously, while concurrency is a
condition that exists when at least two threads are making progress.
Therefore concurrency is a more generalized form of parallelism that
can include time-slicing as a form of virtual parallelism.不知道您怎么看？</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>On 3月22日, 上午8时06分, Alleluia <a href="&#109;&#97;&#x69;&#108;&#x74;&#x6f;&#58;&#x5b;&#97;&#108;&#108;&#117;&#108;&#46;&#x2e;&#x2e;&#64;&#103;&#109;&#97;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#x28;&#41;">&#x5b;&#97;&#108;&#108;&#117;&#108;&#46;&#x2e;&#x2e;&#64;&#103;&#109;&#97;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>Parallelism 说到底是算法问题.Parallelism与Concurrency不同,Concurrency所面对的问题相对的单一可以
让一群有经验的专家来实现一套通用库或者语言来提供一个基本的编程框架.而在Parallelism上,具体的不同问题,其所需要并行的算法是根本不同
的.原因在于不同的问题,其内部的DataDependency的结构完全不同,不同的Data Dependency的结构,需要构造不同的算法.即
便是相同的Data Dependency,在不同的颗粒度下，在不同的硬件条件下所采用的算法也是完全不同的.因为一旦出现Data
Dependency也就意味着并行计算模块之间需要进行通信.从以计算节点为单位的分布式并行,到多核CPU上的Numa结构,到SIMD上的向量处
理器,其计算单元之间的通信手段,通信效率简直天差地别.比如说,在SMP上最常见的并行算法,work stealing也就是Intel的TBB,
是建立在两个条件下第一个是CPU的Cache机制上,这使得通常在内存的之间的数据搬运消耗非常小,第二个是SMP上计算单元相对的少,因此每个计算
单元被分配到的任务就相对的重。其开销远远大于通信的开销,因此这种机制在SMP上相对的划算.但是如果你要在GPU上做Work Stealing就
完全不可行,因为GPU的运算单元数量极多,被分配到的任务就相对来说的非常轻量,CUDA上的一个thread很多时候运算一次的时间不会超过
10us,而一次跨Block的线程之间的通信开销就往往要达到100us左右,再加上目前GPU上的Cache机制非常落后导致了需要频繁的通信开销
的Work Stealing在GPU上是非常不划算得.
所以我个人认为在硬件架构没有更多的突破之前,OpenCL这种东西是没有任何生命力的.不要说CPU的并行与GPU之间差异巨大,就是不同的GPU之
间AMD与Nvidia两个也是各自为政,一个平台上跑得非常快的东西,在另外一个平台极大的可能是龟速.其最终的结果估计就是跟Java的
write once run everywhere一样是个大笑话.</p>
<p>On 3月22日, 下午2时06分, Guancheng Chen <a href="&#109;&#x61;&#105;&#x6c;&#x74;&#x6f;&#x3a;&#x5b;&#99;&#104;&#101;&#x6e;&#103;&#x75;&#97;&#x6e;&#x63;&#x68;&#x2e;&#46;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#105;&#108;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#41;">&#x5b;&#99;&#104;&#101;&#x6e;&#103;&#x75;&#97;&#x6e;&#x63;&#x68;&#x2e;&#46;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#105;&#108;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>On 3月22日, 上午2时20分, Tinyfool <a href="&#x6d;&#97;&#105;&#x6c;&#116;&#111;&#58;&#91;&#116;&#105;&#110;&#x79;&#x66;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#x61;&#105;&#108;&#46;&#99;&#111;&#x6d;&#93;&#x28;&#41;">&#91;&#116;&#105;&#110;&#x79;&#x66;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#x61;&#105;&#108;&#46;&#99;&#111;&#x6d;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#x3a;&#x5b;&#x6a;&#x65;&#46;&#46;&#x2e;&#x40;&#108;&#x69;&#x76;&#x65;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#40;&#x29;">&#x5b;&#x6a;&#x65;&#46;&#46;&#x2e;&#x40;&#108;&#x69;&#x76;&#x65;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#40;&#x29;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#x6d;&#97;&#105;&#108;&#x74;&#x6f;&#x3a;&#x5b;&#99;&#104;&#x65;&#110;&#103;&#117;&#97;&#x6e;&#99;&#x68;&#46;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#97;&#x69;&#108;&#46;&#99;&#x6f;&#109;&#x5d;&#40;&#x29;">&#x5b;&#99;&#104;&#x65;&#110;&#103;&#117;&#97;&#x6e;&#99;&#x68;&#46;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#97;&#x69;&#108;&#46;&#99;&#x6f;&#109;&#x5d;&#40;&#x29;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#109;&#97;&#x69;&#x6c;&#x74;&#x6f;&#58;&#91;&#x70;&#111;&#x6e;&#46;&#x2e;&#x2e;&#x40;&#103;&#111;&#x6f;&#x67;&#108;&#101;&#103;&#114;&#111;&#117;&#x70;&#115;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#41;">&#91;&#x70;&#111;&#x6e;&#46;&#x2e;&#x2e;&#x40;&#103;&#111;&#x6f;&#x67;&#108;&#101;&#103;&#114;&#111;&#117;&#x70;&#115;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#41;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，...</p>
</blockquote>
</blockquote>
</blockquote>
<p>阅读更多 &gt;&gt;
<a href="">显示删减掉的内容</a></p>
</blockquote>
<p><img src="" alt=""> Alleluia <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>Concurrency 说到底纯粹就是一个IO问题.而IO问题本质上是和计算完全无关的事情,不存在能不能行可不可计算的问题.因此它相对来说非常
单纯。他更多的是一种类似时钟同步的问题,如果你把IO事件想像成一种时钟信号.其实时钟本来也就是一堆信号而已.如果你做过Circuit 的东西就
会明白,IO只是在不同的时序下进行数据采样.比如最简单的同步时钟,所有的时序电路公用一个时钟,把不同的电路安排在不同的时序边沿上触发.当然更复
杂异步逻辑的道理也是一样的.放到宏观的Concurrency的问题的实质并没有多大改变,只不过CPU依靠PC指针的移动把这种电路上的时序处理软
件化了.</p>
<p>而Parallelism更多的是需要考虑计算问题同时还要兼顾IO.Parallelism首先要回答的是一个东西是不是可并行的.回答完这个问题
后,如果可并行那么在什么样的硬件设备上并行是最合适的这样一个问题.在Parallelism中需要考虑的的IO也不仅仅是来自于网络更多是,缓存,
内存,磁盘,总线等等.其实我觉得,在Parallelism下你总是处于一个矛盾状态,颗粒度越小的并行获得的计算资源的利用率也就越大加速比就越
大,但是同时通信系统的工作也就越是繁忙整个运算过程浪费在通信消耗上的时间也就越多.
这个当中的tradeoff是非常困难的.很多时候速度不快,完全不是因为你的核心不够多,而是你的通信速度不够高.</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>On 3月22日, 下午3时21分, Guancheng Chen <a href="&#109;&#97;&#x69;&#108;&#116;&#111;&#x3a;&#x5b;&#99;&#x68;&#101;&#x6e;&#103;&#117;&#x61;&#x6e;&#x63;&#104;&#46;&#x2e;&#46;&#x40;&#103;&#x6d;&#97;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#93;&#x28;&#41;">&#x5b;&#99;&#x68;&#101;&#x6e;&#103;&#117;&#x61;&#x6e;&#x63;&#104;&#46;&#x2e;&#46;&#x40;&#103;&#x6d;&#97;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>绝大部分的观点Can&#39;t agree more.其实这也是为什么我引用了高老爷子那段话的原因，因为程序的本质就是数据结构和算法，你要没有非常适
合并行的算法那简直就是巧妇难为无米之炊。但是有疑问的一点是关于Parallelism和Concurrency这两个单词的区别，实际上这也是非常
有意思的一件事情，Sun的多线程指南上写的是： Parallelism is a condition that arises when at
least two threads are executing simultaneously, while concurrency is a
condition that exists when at least two threads are making progress.
Therefore concurrency is a more generalized form of parallelism that
can include time-slicing as a form of virtual parallelism.不知道您怎么看？</p>
<p>On 3月22日, 上午8时06分, Alleluia <a href="&#x6d;&#x61;&#105;&#108;&#116;&#111;&#x3a;&#91;&#97;&#x6c;&#x6c;&#x75;&#x6c;&#x2e;&#46;&#x2e;&#x40;&#103;&#109;&#97;&#105;&#108;&#x2e;&#x63;&#111;&#109;&#93;&#x28;&#41;">&#91;&#97;&#x6c;&#x6c;&#x75;&#x6c;&#x2e;&#46;&#x2e;&#x40;&#103;&#109;&#97;&#105;&#108;&#x2e;&#x63;&#111;&#109;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>Parallelism 说到底是算法问题.Parallelism与Concurrency不同,Concurrency所面对的问题相对的单一可以
让一群有经验的专家来实现一套通用库或者语言来提供一个基本的编程框架.而在Parallelism上,具体的不同问题,其所需要并行的算法是根本不同
的.原因在于不同的问题,其内部的DataDependency的结构完全不同,不同的Data Dependency的结构,需要构造不同的算法.即
便是相同的Data Dependency,在不同的颗粒度下，在不同的硬件条件下所采用的算法也是完全不同的.因为一旦出现Data
Dependency也就意味着并行计算模块之间需要进行通信.从以计算节点为单位的分布式并行,到多核CPU上的Numa结构,到SIMD上的向量处
理器,其计算单元之间的通信手段,通信效率简直天差地别.比如说,在SMP上最常见的并行算法,work stealing也就是Intel的TBB,
是建立在两个条件下第一个是CPU的Cache机制上,这使得通常在内存的之间的数据搬运消耗非常小,第二个是SMP上计算单元相对的少,因此每个计算
单元被分配到的任务就相对的重。其开销远远大于通信的开销,因此这种机制在SMP上相对的划算.但是如果你要在GPU上做Work Stealing就
完全不可行,因为GPU的运算单元数量极多,被分配到的任务就相对来说的非常轻量,CUDA上的一个thread很多时候运算一次的时间不会超过
10us,而一次跨Block的线程之间的通信开销就往往要达到100us左右,再加上目前GPU上的Cache机制非常落后导致了需要频繁的通信开销
的Work Stealing在GPU上是非常不划算得.
所以我个人认为在硬件架构没有更多的突破之前,OpenCL这种东西是没有任何生命力的.不要说CPU的并行与GPU之间差异巨大,就是不同的GPU之
间AMD与Nvidia两个也是各自为政,一个平台上跑得非常快的东西,在另外一个平台极大的可能是龟速.其最终的结果估计就是跟Java的
write once run everywhere一样是个大笑话.</p>
<p>On 3月22日, 下午2时06分, Guancheng Chen <a href="&#x6d;&#97;&#x69;&#x6c;&#116;&#x6f;&#58;&#91;&#99;&#x68;&#101;&#x6e;&#103;&#117;&#x61;&#x6e;&#99;&#x68;&#x2e;&#46;&#x2e;&#64;&#103;&#109;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#40;&#41;">&#91;&#99;&#x68;&#101;&#x6e;&#103;&#117;&#x61;&#x6e;&#99;&#x68;&#x2e;&#46;&#x2e;&#64;&#103;&#109;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>On 3月22日, 上午2时20分, Tinyfool <a href="&#109;&#97;&#105;&#108;&#x74;&#111;&#58;&#x5b;&#x74;&#105;&#110;&#121;&#x66;&#x2e;&#46;&#46;&#x40;&#103;&#109;&#x61;&#105;&#x6c;&#46;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#x29;">&#x5b;&#x74;&#105;&#110;&#121;&#x66;&#x2e;&#46;&#46;&#x40;&#103;&#109;&#x61;&#105;&#x6c;&#46;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#x6d;&#97;&#105;&#108;&#x74;&#x6f;&#58;&#x5b;&#x6a;&#x65;&#46;&#46;&#x2e;&#x40;&#108;&#105;&#x76;&#x65;&#x2e;&#99;&#111;&#109;&#x5d;&#40;&#x29;">&#x5b;&#x6a;&#x65;&#46;&#46;&#x2e;&#x40;&#108;&#105;&#x76;&#x65;&#x2e;&#99;&#111;&#109;&#x5d;&#40;&#x29;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#x6d;&#x61;&#x69;&#108;&#x74;&#111;&#x3a;&#91;&#99;&#x68;&#101;&#110;&#x67;&#x75;&#97;&#110;&#x63;&#104;&#46;&#46;&#x2e;&#x40;&#103;&#x6d;&#x61;&#105;&#108;&#x2e;&#99;&#x6f;&#x6d;&#93;&#x28;&#41;">&#91;&#99;&#x68;&#101;&#110;&#x67;&#x75;&#97;&#110;&#x63;&#104;&#46;&#46;&#x2e;&#x40;&#103;&#x6d;&#x61;&#105;&#108;&#x2e;&#99;&#x6f;&#x6d;&#93;&#x28;&#41;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#111;&#58;&#91;&#x70;&#x6f;&#x6e;&#x2e;&#46;&#x2e;&#64;&#x67;&#x6f;&#x6f;&#x67;&#x6c;&#x65;&#103;&#114;&#x6f;&#117;&#x70;&#115;&#x2e;&#99;&#111;&#109;&#x5d;&#x28;&#x29;">&#91;&#x70;&#x6f;&#x6e;&#x2e;&#46;&#x2e;&#64;&#x67;&#x6f;&#x6f;&#x67;&#x6c;&#x65;&#103;&#114;&#x6f;&#117;&#x70;&#115;&#x2e;&#99;&#111;&#109;&#x5d;&#x28;&#x29;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>...</p>
<p>阅读更多 &gt;&gt;
<a href="">显示删减掉的内容</a>
<img src="" alt=""> Alleluia <img src="" alt=""></p>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>Microsoft Accelerator稍稍看了一下这个东西,是05年的工作.这个东西其实已经不新鲜了.大概跟PyCUDA
array-processing operations such as those which frequently arise in
domains.
但是我要说的是,这个领域相对于真正需要的并行计算实在是太少太少.比如说他强调的 image processing and
scientific computing,当中很多非线性滤波的并行算法就不能用这个架构来做.</p>
<p>On 3月22日, 上午9时42分, &quot;Jeffrey Zhao&quot; <a href="&#x6d;&#x61;&#105;&#108;&#x74;&#111;&#58;&#x5b;&#x6a;&#x65;&#x2e;&#46;&#46;&#64;&#108;&#105;&#x76;&#101;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#41;">&#x5b;&#x6a;&#x65;&#x2e;&#46;&#46;&#64;&#108;&#105;&#x76;&#101;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>哈哈，广告好，扩展视野，那我继续做广告了......</p>
<p>微软其实很早就在搞Microsoft Accelerator项目，旨在利用DirectX进行计算，.NET项目。<a href="http://research.microsoft.com/en-us/projects/Accelerator/" target="_blank"><a href="http://research.microsoft.com/en-us/projects/Accelerator/">http://research.microsoft.com/en-us/projects/Accelerator/</a></a></p>
<p>然后F/#这边由于语言的支持良好，可以设计出丰富的表达式、DSL等Modeling Language，再由框架进行自动并行，解决问题可以很容易（已经2.0了）。</p>
<p>这篇文章是个简单介绍：<a href="http://strangelights.com/blog/archive/2008/09/21/1628.aspx" target="_blank"><a href="http://strangelights.com/blog/archive/2008/09/21/1628.aspx">http://strangelights.com/blog/archive/2008/09/21/1628.aspx</a></a></p>
<p>Microsoft Solver Foundation<a href="http://[code.msdn.microsoft.com/solverfoundation](http://code.msdn.microsoft.com/solverfoundation" target="_blank">http://[code.msdn.microsoft.com/solverfoundation](http://code.msdn.microsoft.com/solverfoundation</a>)</p>
<p>F/# Optimization Modeling Language Utilizing Microsoft Solver Foundation<a href="http://[code.msdn.microsoft.com/solverfoundationfs1](http://code.msdn.microsoft.com/solverfoundationfs1" target="_blank">http://[code.msdn.microsoft.com/solverfoundationfs1](http://code.msdn.microsoft.com/solverfoundationfs1</a>)</p>
<p>现在就等OpenCL如果有标准出来，肯定立马可以跟上个类库，哦耶。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p>From: Tinyfool
Sent: Monday, March 22, 2010 9:20 AM
To: <a href="">pon...@googlegroups.com</a>
Subject: Re: [TL] {技术}{多线程}实施并行编程的五大障碍</p>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#x6d;&#x61;&#105;&#108;&#x74;&#x6f;&#x3a;&#91;&#106;&#x65;&#46;&#46;&#46;&#64;&#x6c;&#x69;&#x76;&#x65;&#46;&#x63;&#x6f;&#109;&#x5d;&#40;&#41;">&#91;&#106;&#x65;&#46;&#46;&#46;&#64;&#x6c;&#x69;&#x76;&#x65;&#46;&#x63;&#x6f;&#109;&#x5d;&#40;&#41;</a></p>
<p>  我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>  其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>  例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>  至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>  例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>  Jeffrey Zhao
  Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
  Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p>  From: Guancheng Chen
  Sent: Monday, March 22, 2010 7:37 AM
  To: TopLanguage
  Subject: [TL] {技术}{多线程}实施并行编程的五大障碍</p>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>&gt;</p>
<blockquote>
<p>  近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
  碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
  (fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
  Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
  的看法。</p>
<p>  ( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看
 <a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
  )</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
</li>
<li><p>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</p>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，</p>
<p>Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
</li>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
...</p>
</li>
</ol>
<p>阅读更多 &gt;&gt;
<a href="">显示删减掉的内容</a></p>
</blockquote>
<p><img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>您的观点很有新意，我以前没有过用IO来区分Concurrency和Parallelism的想法，我猜测可能跟您的网络/通信背景有关。其实我觉得
从广义上来讲Parallelism和Concurrency是基本重合的两个概念，只不过可能Concurrency稍微偏工程一点，
Parallelism稍微偏研究一点。例如Herb Sutter要出的新书叫Effective Concurrency,而市面上其他讲并行计算
的书不少也使用Parallel相关的词汇。</p>
<p>另外您这句话我有些不赞同：&quot;颗粒度越小的并行获得的计算资源的利用率也就越大加速比就越大&quot;，拿一个计算密集型的嵌套循环举例，对比并行外层循环和并
行内层循环，无疑你在并行化外层循环时的性能加速比更好，而这时候你的并行度是粗粒度的(内循环并行相对来说是细粒度的)。当然，粗/细粒度的选择确实
是个tradeoff，拿锁竞争来说，细粒度的锁意味着更好的Scalability，但是你加锁/解锁的次数相比组粒度所来说增加了，而这种加锁/解
锁的操作是有开销的，所以需要在锁操作本身的开销和程序的Scalability中做一个平衡。</p>
<p>多谢指教！</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>On 3月22日, 上午10时19分, Alleluia <a href="&#109;&#x61;&#105;&#108;&#116;&#111;&#58;&#x5b;&#x61;&#108;&#x6c;&#117;&#108;&#x2e;&#x2e;&#46;&#x40;&#x67;&#109;&#97;&#105;&#108;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#40;&#41;">&#x5b;&#x61;&#108;&#x6c;&#117;&#108;&#x2e;&#x2e;&#46;&#x40;&#x67;&#109;&#97;&#105;&#108;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>Concurrency 说到底纯粹就是一个IO问题.而IO问题本质上是和计算完全无关的事情,不存在能不能行可不可计算的问题.因此它相对来说非常
单纯。他更多的是一种类似时钟同步的问题,如果你把IO事件想像成一种时钟信号.其实时钟本来也就是一堆信号而已.如果你做过Circuit 的东西就
会明白,IO只是在不同的时序下进行数据采样.比如最简单的同步时钟,所有的时序电路公用一个时钟,把不同的电路安排在不同的时序边沿上触发.当然更复
杂异步逻辑的道理也是一样的.放到宏观的Concurrency的问题的实质并没有多大改变,只不过CPU依靠PC指针的移动把这种电路上的时序处理软
件化了.</p>
<p>而Parallelism更多的是需要考虑计算问题同时还要兼顾IO.Parallelism首先要回答的是一个东西是不是可并行的.回答完这个问题
后,如果可并行那么在什么样的硬件设备上并行是最合适的这样一个问题.在Parallelism中需要考虑的的IO也不仅仅是来自于网络更多是,缓存,
内存,磁盘,总线等等.其实我觉得,在Parallelism下你总是处于一个矛盾状态,颗粒度越小的并行获得的计算资源的利用率也就越大加速比就越
大,但是同时通信系统的工作也就越是繁忙整个运算过程浪费在通信消耗上的时间也就越多.
这个当中的tradeoff是非常困难的.很多时候速度不快,完全不是因为你的核心不够多,而是你的通信速度不够高.</p>
<p>On 3月22日, 下午3时21分, Guancheng Chen <a href="&#109;&#x61;&#x69;&#x6c;&#116;&#111;&#58;&#x5b;&#x63;&#x68;&#x65;&#110;&#x67;&#x75;&#97;&#110;&#x63;&#x68;&#x2e;&#46;&#x2e;&#x40;&#x67;&#109;&#x61;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#40;&#41;">&#x5b;&#x63;&#x68;&#x65;&#110;&#x67;&#x75;&#97;&#110;&#x63;&#x68;&#x2e;&#46;&#x2e;&#x40;&#x67;&#109;&#x61;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>绝大部分的观点Can&#39;t agree more.其实这也是为什么我引用了高老爷子那段话的原因，因为程序的本质就是数据结构和算法，你要没有非常适
合并行的算法那简直就是巧妇难为无米之炊。但是有疑问的一点是关于Parallelism和Concurrency这两个单词的区别，实际上这也是非常
有意思的一件事情，Sun的多线程指南上写的是： Parallelism is a condition that arises when at
least two threads are executing simultaneously, while concurrency is a
condition that exists when at least two threads are making progress.
Therefore concurrency is a more generalized form of parallelism that
can include time-slicing as a form of virtual parallelism.不知道您怎么看？</p>
<p>On 3月22日, 上午8时06分, Alleluia <a href="&#109;&#x61;&#x69;&#108;&#x74;&#x6f;&#x3a;&#91;&#x61;&#x6c;&#x6c;&#x75;&#108;&#x2e;&#46;&#46;&#x40;&#103;&#x6d;&#97;&#105;&#108;&#x2e;&#99;&#x6f;&#109;&#93;&#40;&#x29;">&#91;&#x61;&#x6c;&#x6c;&#x75;&#108;&#x2e;&#46;&#46;&#x40;&#103;&#x6d;&#97;&#105;&#108;&#x2e;&#99;&#x6f;&#109;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>Parallelism 说到底是算法问题.Parallelism与Concurrency不同,Concurrency所面对的问题相对的单一可以
让一群有经验的专家来实现一套通用库或者语言来提供一个基本的编程框架.而在Parallelism上,具体的不同问题,其所需要并行的算法是根本不同
的.原因在于不同的问题,其内部的DataDependency的结构完全不同,不同的Data Dependency的结构,需要构造不同的算法.即
便是相同的Data Dependency,在不同的颗粒度下，在不同的硬件条件下所采用的算法也是完全不同的.因为一旦出现Data
Dependency也就意味着并行计算模块之间需要进行通信.从以计算节点为单位的分布式并行,到多核CPU上的Numa结构,到SIMD上的向量处
理器,其计算单元之间的通信手段,通信效率简直天差地别.比如说,在SMP上最常见的并行算法,work stealing也就是Intel的TBB,
是建立在两个条件下第一个是CPU的Cache机制上,这使得通常在内存的之间的数据搬运消耗非常小,第二个是SMP上计算单元相对的少,因此每个计算
单元被分配到的任务就相对的重。其开销远远大于通信的开销,因此这种机制在SMP上相对的划算.但是如果你要在GPU上做Work Stealing就
完全不可行,因为GPU的运算单元数量极多,被分配到的任务就相对来说的非常轻量,CUDA上的一个thread很多时候运算一次的时间不会超过
10us,而一次跨Block的线程之间的通信开销就往往要达到100us左右,再加上目前GPU上的Cache机制非常落后导致了需要频繁的通信开销
的Work Stealing在GPU上是非常不划算得.
所以我个人认为在硬件架构没有更多的突破之前,OpenCL这种东西是没有任何生命力的.不要说CPU的并行与GPU之间差异巨大,就是不同的GPU之
间AMD与Nvidia两个也是各自为政,一个平台上跑得非常快的东西,在另外一个平台极大的可能是龟速.其最终的结果估计就是跟Java的
write once run everywhere一样是个大笑话.</p>
<p>On 3月22日, 下午2时06分, Guancheng Chen <a href="&#109;&#97;&#x69;&#108;&#x74;&#x6f;&#58;&#91;&#x63;&#104;&#x65;&#110;&#x67;&#x75;&#97;&#x6e;&#99;&#104;&#46;&#x2e;&#46;&#x40;&#x67;&#109;&#x61;&#105;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#93;&#40;&#x29;">&#91;&#x63;&#104;&#x65;&#110;&#x67;&#x75;&#97;&#x6e;&#99;&#104;&#46;&#x2e;&#46;&#x40;&#x67;&#109;&#x61;&#105;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>On 3月22日, 上午2时20分, Tinyfool <a href="&#109;&#x61;&#x69;&#108;&#x74;&#x6f;&#58;&#x5b;&#x74;&#x69;&#x6e;&#x79;&#102;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#109;&#x61;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#93;&#x28;&#x29;">&#x5b;&#x74;&#x69;&#x6e;&#x79;&#102;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#109;&#x61;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#109;&#97;&#105;&#108;&#116;&#x6f;&#x3a;&#91;&#106;&#101;&#x2e;&#x2e;&#x2e;&#64;&#x6c;&#x69;&#x76;&#101;&#46;&#x63;&#x6f;&#x6d;&#93;&#x28;&#x29;">&#91;&#106;&#101;&#x2e;&#x2e;&#x2e;&#64;&#x6c;&#x69;&#x76;&#101;&#46;&#x63;&#x6f;&#x6d;&#93;&#x28;&#x29;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#x6d;&#97;&#105;&#x6c;&#116;&#111;&#x3a;&#x5b;&#99;&#104;&#x65;&#110;&#103;&#117;&#x61;&#110;&#x63;&#x68;&#46;&#x2e;&#46;&#64;&#x67;&#109;&#97;&#x69;&#108;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#x28;&#x29;">&#x5b;&#99;&#104;&#x65;&#110;&#103;&#117;&#x61;&#110;&#x63;&#x68;&#46;&#x2e;&#46;&#64;&#x67;&#109;&#97;&#x69;&#108;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#x28;&#x29;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#109;&#97;&#105;&#x6c;&#116;&#111;&#x3a;&#x5b;&#112;&#111;&#110;&#x2e;&#46;&#46;&#64;&#103;&#111;&#111;&#x67;&#108;&#x65;&#x67;&#114;&#x6f;&#117;&#112;&#115;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#x29;">&#x5b;&#112;&#111;&#110;&#x2e;&#46;&#46;&#64;&#103;&#111;&#111;&#x67;&#108;&#x65;&#x67;&#114;&#x6f;&#117;&#112;&#115;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#x29;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也...</p>
</li>
</ol>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>阅读更多 &gt;&gt;
<a href="">显示删减掉的内容</a>
<img src="" alt=""> Googol Lee <img src="" alt=""></p>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>彻底来晚了......我是来广告golang的！大并发IO还是csp模型的语言更靠谱！</p>
<p>不过golang在cpu密集的并发上不知道效果会怎么样，就现在的表现来看比erlang好，但还赶不上c/c++</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>On Mar 22, 9:20 am, Tinyfool <a href="&#109;&#x61;&#105;&#x6c;&#116;&#x6f;&#58;&#91;&#x74;&#x69;&#x6e;&#x79;&#102;&#x2e;&#46;&#46;&#x40;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#x29;">&#91;&#x74;&#x69;&#x6e;&#x79;&#102;&#x2e;&#46;&#46;&#x40;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#x6d;&#x61;&#x69;&#108;&#x74;&#x6f;&#x3a;&#x5b;&#x6a;&#101;&#46;&#46;&#46;&#x40;&#x6c;&#x69;&#x76;&#101;&#x2e;&#x63;&#111;&#x6d;&#93;&#40;&#x29;">&#x5b;&#x6a;&#101;&#46;&#46;&#46;&#x40;&#x6c;&#x69;&#x76;&#101;&#x2e;&#x63;&#111;&#x6d;&#93;&#40;&#x29;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#x6f;&#x3a;&#x5b;&#99;&#x68;&#101;&#110;&#103;&#117;&#97;&#x6e;&#x63;&#x68;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#109;&#x61;&#105;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#41;">&#x5b;&#99;&#x68;&#101;&#110;&#103;&#117;&#97;&#x6e;&#x63;&#x68;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#109;&#x61;&#105;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#41;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#109;&#97;&#x69;&#108;&#x74;&#x6f;&#x3a;&#91;&#112;&#x6f;&#110;&#x2e;&#46;&#x2e;&#64;&#103;&#111;&#x6f;&#103;&#108;&#101;&#103;&#114;&#111;&#x75;&#x70;&#115;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#40;&#41;">&#91;&#112;&#x6f;&#110;&#x2e;&#46;&#x2e;&#64;&#103;&#111;&#x6f;&#103;&#108;&#101;&#103;&#114;&#111;&#x75;&#x70;&#115;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#40;&#41;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄</p>
</li>
</ol>
</blockquote>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<blockquote>
<blockquote>
<p>了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。</p>
</li>
</ol>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>--
Tinyfool的开发日记<a href="http://www.tinydust.net/dev/" target="_blank"><a href="http://www.tinydust.net/dev/">http://www.tinydust.net/dev/</a></a>
代码中国网<a href="http://www.codechina.org/" target="_blank"><a href="http://www.codechina.org">http://www.codechina.org</a></a>
myTwitter:<a href="http://twitter.com/tinyfool" target="_blank"><a href="http://twitter.com/tinyfool">http://twitter.com/tinyfool</a></a>
<a href="">显示删减掉的内容</a></p>
</blockquote>
<p><img src="" alt=""> Jeffrey Zhao <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>锟斤拷锟斤拷锟斤拷F/#锟斤拷锟斤拷锟斤拷锟斤拷锟揭伙拷锟斤拷锟斤拷诺姆锟绞斤拷锟绞碉拷锟紺SP锟侥★拷</p>
<p>锟斤拷锟斤拷锟斤拷锟斤拷锟节达拷锟斤拷院锟节诧拷锟斤拷锟斤拷锟斤拷锟较斤拷锟斤拷F/#锟狡广，锟斤拷锟斤拷锟斤拷</p>
<p>Jeffrey Zhao
Blog: <a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter: @jeffz_cn</p>
<hr>
<p>From: &quot;Googol Lee&quot; <a href="&#109;&#97;&#x69;&#x6c;&#116;&#111;&#x3a;&#91;&#103;&#111;&#x6f;&#103;&#46;&#46;&#x2e;&#x40;&#x67;&#109;&#97;&#x69;&#108;&#46;&#x63;&#111;&#x6d;&#x5d;&#x28;&#x29;">&#91;&#103;&#111;&#x6f;&#103;&#46;&#46;&#x2e;&#x40;&#x67;&#109;&#97;&#x69;&#108;&#46;&#x63;&#111;&#x6d;&#x5d;&#x28;&#x29;</a>
Sent: Monday, March 22, 2010 8:30 PM
To: &quot;TopLanguage&quot; <a href="&#109;&#97;&#x69;&#108;&#x74;&#111;&#x3a;&#x5b;&#x70;&#x6f;&#x6e;&#x2e;&#46;&#x2e;&#x40;&#103;&#x6f;&#x6f;&#103;&#108;&#101;&#x67;&#x72;&#111;&#x75;&#112;&#115;&#46;&#x63;&#111;&#109;&#93;&#x28;&#41;">&#x5b;&#x70;&#x6f;&#x6e;&#x2e;&#46;&#x2e;&#x40;&#103;&#x6f;&#x6f;&#103;&#108;&#101;&#x67;&#x72;&#111;&#x75;&#112;&#115;&#46;&#x63;&#111;&#109;&#93;&#x28;&#41;</a>
Subject: [TL] Re: {锟斤拷锟斤拷}{锟斤拷锟竭筹拷}实施锟斤拷锟叫憋拷痰锟斤拷锟斤拷锟较帮拷</p>
<blockquote>
<p>锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷......锟斤拷锟斤拷锟斤拷锟斤拷锟絞olang锟侥ｏ拷锟襟并凤拷IO锟斤拷锟斤拷csp模锟酵碉拷锟斤拷锟皆革拷锟阶ｏ拷</p>
<p>锟斤拷锟斤拷golang锟斤拷cpu锟杰硷拷锟侥诧拷锟斤拷锟较诧拷知锟斤拷效锟斤拷锟斤拷锟矫达拷锟斤拷锟斤拷锟节的憋拷锟斤拷锟斤拷锟斤拷锟斤拷erlang锟矫ｏ拷锟斤拷锟斤拷锟较诧拷锟斤拷c/c++</p>
<p>On Mar 22, 9:20 am, Tinyfool <a href="&#109;&#97;&#x69;&#108;&#116;&#x6f;&#58;&#91;&#x74;&#x69;&#110;&#121;&#102;&#46;&#46;&#46;&#64;&#x67;&#x6d;&#97;&#105;&#x6c;&#46;&#x63;&#111;&#x6d;&#x5d;&#40;&#x29;">&#91;&#x74;&#x69;&#110;&#121;&#102;&#46;&#46;&#46;&#64;&#x67;&#x6d;&#97;&#105;&#x6c;&#46;&#x63;&#111;&#x6d;&#x5d;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷模锟斤拷锟饺伙拷越锟斤拷冒锟斤拷锟斤拷锟剿ｏ拷锟斤拷也锟斤拷锟斤拷锟揭伙拷锟�</p>
<p>Mac OS X锟斤拷锟铰的诧拷锟叫伙拷锟狡斤拷锟斤拷GCD锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟街撅拷知锟斤拷锟睫憋拷强锟斤拷锟剿吧ｏ拷</p>
<p>锟斤拷锟斤拷支锟斤拷锟皆匡拷锟斤拷锟斤拷锟絆penCL也锟斤拷锟睫憋拷强锟襟啊★拷</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#109;&#97;&#105;&#x6c;&#116;&#111;&#x3a;&#91;&#106;&#101;&#46;&#x2e;&#x2e;&#x40;&#x6c;&#x69;&#x76;&#x65;&#46;&#x63;&#x6f;&#x6d;&#93;&#x28;&#x29;">&#91;&#106;&#101;&#46;&#x2e;&#x2e;&#x40;&#x6c;&#x69;&#x76;&#x65;&#46;&#x63;&#x6f;&#x6d;&#93;&#x28;&#x29;</a></p>
<blockquote>
<p> 锟斤拷锟斤拷锟斤拷锟斤拷妫猴拷锟斤拷瞬锟斤拷锌狻拷锟斤拷锟紽/#锟斤拷锟斤拷锟斤拷锟皆碉拷支锟街ｏ拷锟斤拷锟叫憋拷锟斤拷丫锟斤拷锟斤拷缀芏锟斤拷恕锟斤拷锟斤拷锟叫э拷剩锟街达拷锟叫э拷剩锟斤拷锟轿拷锟斤拷远锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟竭★拷</p>
<p>锟斤拷实锟斤拷锟斤拷&quot;锟斤拷锟斤拷&quot;锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷茫锟街灰拷锟脚ｏ拷税锟斤拷锟斤拷壮锟斤拷锟斤拷锟侥讹拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷装锟斤拷锟斤拷锟斤拷锟斤拷一锟斤拷锟斤拷锟矫的筹拷锟襟，对大部分筹拷锟斤拷员锟斤拷说锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷唷�</p>
<p>锟斤拷锟斤拷Memory Consistency锟斤拷锟斤拷JVM锟斤拷CLR锟斤拷锟斤拷锟节革拷CPU锟杰癸拷锟斤拷统一锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷没锟叫诧拷锟叫匡拷锟街э拷郑锟叫达拷锟斤拷谐锟斤拷锟斤拷丫锟斤拷锟斤拷锟斤拷锟斤拷珊芏锟斤拷恕锟�</p>
<p>锟斤拷锟节斤拷锟斤拷锟斤拷......锟揭撅拷锟斤拷锟斤拷实锟斤拷锟斤拷锟斤拷獾癸拷锟斤拷遣锟斤拷锟斤拷锟斤拷械模锟揭诧拷锟斤拷遣锟斤拷锟斤拷锟斤拷锟斤拷锟街的革拷祝锟斤拷锟斤拷牵锟斤拷锟斤拷冢锟斤拷锟斤拷锟斤拷锟矫伙拷锟斤拷锟斤拷吮锟斤拷锟斤拷锟矫★拷</p>
<p>锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷系锟结构锟斤拷锟斤拷锟斤拷系统锟饺等★拷锟斤拷锟斤拷然锟酵诧拷锟斤拷锟叫关ｏ拷锟斤拷也锟斤拷锟角诧拷锟斤拷锟斤拷锟叫的讹拷锟斤拷锟斤拷</p>
</blockquote>
</blockquote>
<p>&gt;</p>
<blockquote>
<blockquote>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#109;&#x61;&#105;&#108;&#x74;&#x6f;&#x3a;&#x5b;&#x63;&#x68;&#x65;&#x6e;&#103;&#117;&#x61;&#110;&#99;&#x68;&#46;&#x2e;&#46;&#64;&#x67;&#109;&#x61;&#x69;&#108;&#x2e;&#99;&#x6f;&#109;&#93;&#x28;&#x29;">&#x5b;&#x63;&#x68;&#x65;&#x6e;&#103;&#117;&#x61;&#110;&#99;&#x68;&#46;&#x2e;&#46;&#64;&#x67;&#109;&#x61;&#x69;&#108;&#x2e;&#99;&#x6f;&#109;&#93;&#x28;&#x29;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#x6f;&#x3a;&#91;&#112;&#x6f;&#110;&#x2e;&#x2e;&#x2e;&#64;&#103;&#111;&#111;&#x67;&#x6c;&#101;&#103;&#114;&#x6f;&#117;&#x70;&#115;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#40;&#41;">&#91;&#112;&#x6f;&#110;&#x2e;&#x2e;&#x2e;&#64;&#103;&#111;&#111;&#x67;&#x6c;&#101;&#103;&#114;&#x6f;&#117;&#x70;&#115;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#40;&#41;</a>
/<em>Subject:/</em> [TL] {锟斤拷锟斤拷}{锟斤拷锟竭筹拷}实施锟斤拷锟叫憋拷痰锟斤拷锟斤拷锟较帮拷</p>
<p>锟斤拷锟节匡拷锟斤拷一篇锟斤拷锟斤拷Intel锟侥猴拷锟斤拷锟斤拷思锟侥凤拷锟斤拷锟斤拷锟铰ｏ拷锟斤拷锟斤拷锟结到锟斤拷锟斤拷锟斤拷45锟斤拷锟斤拷锟侥革拷锟斤拷司锟斤拷锟斤拷员/锟斤拷锟斤拷锟斤拷锟斤拷/战锟斤拷师锟斤拷锟斤拷&quot;什么锟斤拷实施锟斤拷锟叫憋拷痰锟斤拷锟斤拷锟斤拷
锟斤拷&quot;时锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷乇锟斤拷峒帮拷拇锟斤拷锟斤拷锟洁：锟斤拷锟斤拷锟斤拷锟斤拷(legacy code)锟斤拷锟斤拷锟斤拷(education)锟斤拷锟斤拷锟斤拷(tools)锟斤拷锟斤拷锟节猴拷锟斤拷锟狡的恐撅拷
(fear of many cores)锟皆硷拷锟斤拷维锟斤拷锟斤拷(maintainability)锟斤拷锟斤拷锟斤拷锟斤拷然锟斤拷一篇Intel
Parallel
Studio锟斤拷锟斤拷锟侥ｏ拷锟斤拷锟斤拷锟斤拷锟斤拷锟结及锟斤拷锟斤拷锟斤拷锟斤拷习锟饺达拷浅锟街碉拷锟斤拷锟斤拷郏锟斤拷锟斤拷锟斤拷锟斤拷叶锟斤拷锟斤拷锟斤拷锟较帮拷锟斤拷一些锟斤拷浅锟斤拷锟斤拷锟斤拷希锟斤拷锟斤拷锟斤拷一锟斤拷锟斤拷砖锟斤拷锟斤拷锟斤拷锟斤拷茫锟斤拷锟接拷锟揭革拷锟斤拷锟斤拷锟�
锟侥匡拷锟斤拷锟斤拷</p>
<p>( 注锟斤拷锟斤拷锟斤拷Google Group锟斤拷锟斤拷原锟侥碉拷一些锟斤拷锟斤拷锟接讹拷失效锟剿ｏ拷锟斤拷锟斤拷锟斤拷懈锟矫碉拷锟侥讹拷锟斤拷锟介，锟诫看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>锟斤拷锟斤拷锟斤拷锟斤拷
锟斤拷锟斤拷锟斤拷知锟斤拷锟斤拷锟叫伙拷实施锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷压锟剿撅拷锟斤拷锟叫╋拷锟斤拷锟斤拷锟斤拷锟斤拷锟叫伙拷锟斤拷100K~1000K锟侥达拷锟斤拷锟斤拷锟斤拷锟角筹拷锟斤拷锟斤拷斜锟教憋拷锟斤拷锟斤拷锟角非筹拷锟斤拷锟阶筹拷锟斤拷模锟�
一锟斤拷锟斤拷锟斤拷锟絛ata race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe锟饺碉拷锟斤拷锟斤拷锟斤拷锟斤拷锟揭伙拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟酵凤拷螅锟斤拷说要锟斤拷
效锟缴匡拷锟侥诧拷锟叫伙拷锟斤拷些锟接达拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷恕锟斤拷锟斤拷锟斤拷训锟斤拷呛芏锟斤拷锟斤拷锟斤拷锟斤拷牖癸拷斜锟叫达拷锟斤拷丫锟斤拷锟街帮拷锟斤拷牡锟阶拷筒锟饺拷锟斤拷锟斤拷猓拷锟斤拷锟斤拷锟斤拷锟窖╋拷霞锟剿拷锟斤拷映杀锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷通锟斤拷一
些锟斤拷锟斤拷谋锟斤拷锟斤拷锟�(锟斤拷锟斤拷Intel锟斤拷ICC)锟皆讹拷锟斤拷锟叫伙拷一些锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷省钱锟侥ｏ拷锟斤拷锟斤拷锟斤拷锟街凤拷锟斤拷锟斤拷锟斤拷缺锟捷撅拷锟斤拷锟斤拷锟斤拷Intel ICC锟斤拷锟斤拷锟皆讹拷锟酵憋拷锟斤拷锟斤拷
锟斤拷锟皆讹拷锟斤拷锟叫伙拷锟侥达拷锟斤拷浅锟斤拷伲锟斤拷佣锟斤拷锟斤拷锟斤拷锟斤拷峁╋拷锟斤拷锟斤拷锟斤拷呕锟斤拷浅锟斤拷锟斤拷蓿锟斤拷锟斤拷揖锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷芑锟斤拷speedup锟侥达拷锟斤拷也锟叫很讹拷约锟斤拷锟斤拷锟斤拷(锟斤拷锟斤拷loop锟斤拷循锟斤拷之锟斤拷
没锟斤拷dependence锟斤拷锟斤拷锟揭革拷loop应锟斤拷锟斤拷一锟斤拷锟斤拷锟斤拷锟饺碉拷)锟斤拷锟斤拷锟斤拷目前锟斤拷锟斤拷状锟斤拷锟角达拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟诫并锟斤拷锟斤拷锟斤拷效锟侥憋拷锟斤拷锟叫伙拷锟斤拷锟斤拷锟斤拷业锟侥角讹拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟�
锟斤拷一锟街斤拷锟斤拷锟斤拷锟斤拷锟斤拷诙锟绞憋拷锟斤拷诳锟斤拷倏煽锟斤拷锟酵拷锟绞凳╋拷锟斤拷谢锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟�%~30%锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷么锟斤拷锟斤拷丫锟斤拷锟轿拷锟剿撅拷锟绞★拷锟斤拷锟斤拷杀锟斤拷恕锟�</p>
</li>
<li><p>锟斤拷锟斤拷
锟节讹拷锟斤拷锟斤拷习锟斤拷锟斤拷芫锟斤拷浅锟斤拷锟皆比憋拷锟斤拷锟斤拷斜锟教凤拷锟斤拷慕锟斤拷锟斤拷恕锟斤拷锟绞碉拷锟斤拷斜锟斤拷锟窖撅拷锟叫讹拷锟斤拷十锟斤拷锟斤拷锟绞凤拷耍锟斤拷锟斤拷锟斤拷诙锟斤拷CPU锟斤拷锟斤拷之前锟斤拷些锟斤拷锟叫憋拷潭锟斤拷锟�&quot;专锟斤拷&quot;锟角碉拷锟斤拷
锟竭★拷锟斤拷时锟斤拷牟锟斤拷斜锟教达拷锟斤拷锟斤拷锟节硷拷群锟斤拷锟斤拷锟酵伙拷锟斤拷叻锟斤拷锟斤拷锟斤拷希锟酵拷锟組PI(message
passing model)锟斤拷锟斤拷SMP(锟皆称多处锟斤拷锟斤拷锟斤拷锟斤拷一
锟斤拷锟斤拷锟斤拷锟斤拷锟叫讹拷锟斤拷锟斤拷锟紺PU锟斤拷锟斤拷锟斤拷shared memory model)锟斤拷锟斤拷刹锟斤拷屑锟斤拷恪thread锟斤拷准锟斤拷1995锟疥建锟斤拷锟侥ｏ拷之锟斤拷锟斤拷锟斤拷锟�
Windows锟斤拷锟絎in32 thread锟斤拷锟斤拷锟斤拷锟街筹拷锟斤拷锟斤拷&quot;锟斤拷锟斤拷指锟斤拷&quot;锟斤拷锟斤拷锟斤拷data parallel模锟酵碉拷OpenMP(OpenMP 3.0锟斤拷
锟斤拷锟斤拷task parallel支锟斤拷)锟斤拷task parallel锟侥憋拷锟斤拷Click锟斤拷Intel锟斤拷Intel Thread
Building
Block(task parallel)锟斤拷Java 1.5锟斤拷始锟皆讹拷锟竭筹拷锟结供锟较好碉拷支锟斤拷(锟斤拷锟斤拷锟斤拷Java
Memory Model)锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷
GPU锟侥凤拷展锟斤拷Nvidia锟街匡拷始锟斤拷CUDA(data-parallel)锟斤拷Apple一锟斤拷锟斤拷锟皆ｏ拷锟斤拷锟叫憋拷锟斤拷院锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷业貌锟揭伙拷郑锟斤拷锟斤拷锟斤拷约锟斤拷锟斤拷锟脚�
锟剿革拷锟斤拷锟紺PU锟斤拷GPU锟斤拷媳锟教碉拷OpenCL锟斤拷微锟斤拷一锟斤拷也锟斤拷住锟斤拷也要锟斤拷锟斤拷Visual
Studio2010锟斤拷始锟斤拷C/#锟侥诧拷锟叫库，锟斤拷锟斤拷C++0x也
要锟斤拷锟斤拷锟斤拷叱锟街э拷郑锟斤拷锟斤拷锟斤拷锟斤拷瞎哦锟紼rlang也锟斤拷为锟斤拷锟斤拷支锟街诧拷锟叫憋拷锟斤拷锟斤拷锟饺筹拷锟斤拷锟斤拷之锟斤拷锟斤拷摩锟斤拷锟斤拷锟节达拷锟斤拷锟斤拷锟斤拷锟绞э拷锟斤拷锟斤拷业锟界都锟斤拷始锟斤拷锟斤拷锟斤拷锟叫憋拷谭锟斤拷锟�
展锟斤拷</p>
</li>
</ol>
<p>锟斤拷锟角对筹拷锟斤拷员锟斤拷说锟斤拷锟斤拷什么锟斤拷锟斤拷兀锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟杰的斤拷锟斤拷蠖蓟锟斤拷谴锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷些锟姐法锟斤拷锟斤拷萁峁癸拷锟斤拷叩锟斤拷锟斤拷锟揭黄拷锟教革拷锟剿�&quot;锟斤拷锟揭匡拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟�
锟斤拷硬锟斤拷锟斤拷锟斤拷锟斤拷丫锟斤拷藜瓶锟绞╋拷说锟斤拷碌模锟斤拷锟斤拷墙锟組oore锟斤拷锟斤拷失效锟斤拷锟斤拷锟斤拷锟斤拷锟窖革拷锟斤拷锟斤拷锟斤拷锟斤拷撸锟斤拷锟斤拷锟斤拷歉锟斤拷锟斤拷堑幕锟斤拷锟街伙拷锟斤拷锟侥承┲革拷锟斤拷锟斤拷锟斤拷械酶锟斤拷锟剿讹拷锟窖★拷锟斤拷锟斤拷锟斤拷
锟教碉拷锟诫法锟斤拷证锟斤拷锟斤拷失锟杰的ｏ拷锟斤拷一锟姐都锟斤拷锟斤拷械锟斤拷锟斤拷锟�......锟斤拷锟斤拷说锟斤拷锟叫讹拷锟劫筹拷锟斤拷员锟斤拷锟斤拷锟斤拷未锟斤拷一片锟斤拷锟斤拷锟侥伙拷锟斤拷锟斤拷锟斤拷强锟揭碉拷锟斤拷趣锟斤拷锟揭硷拷锟斤拷没锟斤拷锟斤拷说锟斤拷锟斤拷锟斤拷锟斤拷堑锟斤拷呖唷�
锟斤拷锟斤拷锟斤拷锟斤拷学院锟斤拷些锟斤拷硬锟斤拷锟侥家伙拷一直锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟角达拷锟�&quot;锟斤拷锟缴硷拷硬锟斤拷锟斤拷展锟斤拷锟斤拷锟斤拷锟斤拷转锟斤拷直锟接碉拷锟铰筹拷锟斤拷员锟斤拷锟斤拷训锟斤拷锟斤拷锟窖撅拷锟斤拷锟斤拷锟剿★拷锟斤拷么锟斤拷锟斤拷员锟斤拷锟斤拷锟杰碉拷锟斤拷锟矫碉拷
锟斤拷锟叫憋拷探锟斤拷锟斤拷锟斤拷穑亢锟斤拷锟饺伙拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷一锟斤拷锟斤拷通锟侥筹拷锟斤拷员锟斤拷&quot;锟斤拷锟斤拷貌锟斤拷斜锟斤拷锟斤拷锟斤拷么锟斤拷&quot;锟斤拷十锟叫八九伙拷说&quot;锟揭撅拷锟矫猴拷锟斤拷&quot;锟斤拷前一锟斤拷锟斤拷锟斤拷锟斤拷锟桔凤拷锟斤拷锟斤拷锟斤拷锟斤拷枚锟斤拷叱锟�
锟矫伙拷锟角讹拷锟教好ｏ拷锟斤拷实锟斤拷原锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷露锟斤拷叱锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷疲锟斤拷锟斤拷锟絠solation锟侥讹拷锟斤拷模式锟斤拷锟斤拷programming productivity
锟斤拷performance之锟斤拷锟揭碉拷锟饺较好碉拷锟斤拷锟皆ｏ拷锟斤拷锟皆癸拷锟节猴拷锟叫凤拷锟斤拷锟斤拷锟斤拷锟斤拷锟竭讹拷选锟斤拷锟剿讹拷锟斤拷(锟斤拷锟斤拷锟狡凤拷)锟斤拷锟接达拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟叫撅拷锟斤拷系锟斤拷模锟斤拷锟斤拷锟叫�
OS/Compiler锟侥ｏ拷锟斤拷锟角讹拷锟斤拷锟斤拷锟斤拷锟皆的ｏ拷锟斤拷锟节讹拷锟节伙拷努锟斤拷锟斤拷为锟斤拷锟侥筹拷锟斤拷员锟结供一锟斤拷锟斤拷锟斤拷锟斤拷使锟矫的诧拷锟叫憋拷锟侥ｏ拷停锟絀ntel锟解几锟疥不也锟节革拷锟斤拷锟斤拷
训么锟斤拷锟解都锟角猴拷锟斤拷锟襟，碉拷锟角ｏ拷锟斤拷锟斤拷锟斤拷锟饺拷锟斤拷斜锟斤拷时锟斤拷锟斤拷锟洁当锟斤拷锟斤拷路要锟竭★拷锟斤拷锟斤拷锟絀T锟斤拷锟斤拷锟斤拷锟斤拷锟介单锟斤拷锟斤拷锟斤拷锟斤拷胁锟斤拷斜锟教碉拷锟介籍锟斤拷锟角革拷锟杰好碉拷写锟秸★拷</p>
<ol>
<li>锟斤拷锟斤拷
锟斤拷锟斤拷锟斤拷锟斤拷锟铰ｏ拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷么锟街阶讹拷锟斤拷锟斤拷锟斤拷锟矫的ｏ拷锟斤拷锟揭猴拷锟矫的诧拷锟叫憋拷坦锟斤拷锟斤拷卸锟斤拷锟斤拷兀锟斤拷锟接拷锟揭诧拷锟戒）锟斤拷</li>
</ol>
<p>(1) IDE: Intel Parallel Studio锟斤拷微锟斤拷锟斤拷锟较筹拷锟斤拷锟斤拷VS2010锟斤拷一锟斤拷锟斤拷Sun锟斤拷Sun
Studio(锟斤拷知锟斤拷锟斤拷锟轿达拷锟斤拷锟�
锟轿ｏ拷锟斤拷锟斤拷锟斤拷锟斤拷锟酵猴拷小锟斤拷)锟斤拷Nvidia锟斤拷CUDA平台什么锟侥撅拷锟饺诧拷锟斤拷锟斤拷
(2) Compiler: Intel锟斤拷ICC(锟斤拷锟皆讹拷锟斤拷锟叫伙拷一些锟斤拷锟斤拷)锟斤拷Nema Labs锟斤拷FASThread(锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟侥斤拷锟斤拷锟斤拷锟斤拷锟斤拷芸锟斤拷锟�
锟缴匡拷锟斤拷指锟斤拷锟斤拷锟斤拷员实施锟斤拷锟叫伙拷)
(3) Performance Tuning: Intel Vtune Analyzer(锟桔猴拷锟斤拷锟杰凤拷锟斤拷)锟斤拷Thread
profiler锟斤拷
Acumem锟斤拷Thread Spotter(锟斤拷远锟斤拷Cache锟斤拷锟斤拷锟杰凤拷锟斤拷锟斤拷锟脚伙拷)
(4) Debugging: Petra锟斤拷Jinx</p>
<p>锟斤拷锟斤拷锟斤拷锟揭革拷锟剿撅拷锟斤拷锟斤拷锟角对筹拷锟斤拷员锟斤拷说确实锟斤拷锟矫ｏ拷锟斤拷锟斤拷前锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷要锟斤拷锟矫★拷锟斤拷锟斤拷实锟街革拷诙锟斤拷锟�&quot;锟斤拷锟斤拷&quot;锟叫很达拷锟较碉拷恕锟�</p>
<ol>
<li><p>锟斤拷锟节核的恐撅拷
锟斤拷锟斤拷锟斤拷锟角匡拷锟斤拷4锟斤拷锟窖撅拷锟角筹拷锟秸憋拷锟剿ｏ拷锟饺癸拷锟斤拷锟角可撅拷锟斤拷8锟剿ｏ拷16锟剿ｏ拷32锟斤拷锟剿★拷锟斤拷锟斤拷确锟斤拷锟斤拷拇锟斤拷锟斤拷诤锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷泻芎玫锟斤拷锟斤拷埽锟斤拷芎玫目锟斤拷锟斤拷锟斤拷裕锟斤拷锟�
锟斤拷锟斤拷歉锟斤拷锟斤拷狻ｏ拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷芯锟斤拷锟斤拷嵌锟斤拷叱坛锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟杰凤拷锟斤拷锟斤拷目锟侥撅拷锟斤拷为锟剿帮拷锟斤拷锟斤拷锟皆憋拷锟矫的斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟缴碉拷锟斤拷锟斤拷瓶锟斤拷锟斤拷实锟斤拷锟较ｏ拷为锟剿得碉拷锟杰好碉拷
锟斤拷锟斤拷锟斤拷锟皆ｏ拷锟斤拷锟斤拷员锟斤拷要锟斤拷锟斤拷锟斤拷要使锟矫诧拷锟斤拷锟窖好碉拷锟斤拷萁峁�(锟斤拷锟斤拷concurrent hash
map)锟斤拷使锟斤拷细锟斤拷锟饺碉拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟教ｏ拷锟斤拷锟絛ata
parallel锟斤拷锟姐法锟斤拷锟斤拷锟杰碉拷锟斤拷(锟斤拷锟斤拷锟斤拷偷锟絝alse sharing锟斤拷锟斤拷)锟饺等等等ｏ拷锟斤拷锟斤拷锟斤拷每一锟筋都锟角诧拷小锟斤拷锟斤拷战锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷一篇锟斤拷锟铰讹拷锟斤拷锟�
锟斤拷锟竭程筹拷锟斤拷锟结供锟斤拷一些锟斤拷锟矫的斤拷锟介。</p>
</li>
<li><p>锟斤拷维锟斤拷锟斤拷
锟斤拷锟斤拷锟斤拷锟绞ｏ拷锟斤拷锟斤拷希锟斤拷锟叫达拷锟斤拷锟杰癸拷锟斤拷锟街达拷锟絩untime系统锟斤拷build系统锟皆硷拷锟斤拷锟斤拷锟斤拷锟叫达拷锟斤拷一锟斤拷锟斤拷确锟侥癸拷锟斤拷锟斤拷锟斤拷锟角革拷希锟斤拷锟斤拷些锟斤拷锟叫达拷锟斤拷锟斤拷锟斤拷锟斤拷狻拷锟斤拷锟轿�
锟斤拷锟斤拷锟斤拷锟叫较筹拷锟斤拷锟斤拷锟斤拷锟斤拷锟节★拷锟斤拷锟斤拷锟街阶讹拷锟斤拷锟斤拷锟斤拷锟秸诧拷锟叫憋拷痰某锟斤拷锟皆憋拷锟街拷锟斤拷伲锟斤拷锟斤拷也锟斤拷斜锟斤拷锟斤拷锟斤拷锟斤拷么锟斤拷锟窖ｏ拷锟斤拷锟斤拷锟斤拷锟斤拷锟叫╋拷锟斤拷写锟斤拷锟街伙拷锟斤拷锟揭恍┬⌒★拷母亩锟斤拷锟斤拷锟斤拷锌锟�
锟杰碉拷锟斤拷锟铰碉拷bug锟斤拷锟铰碉拷锟斤拷锟斤拷瓶锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟揭伙拷锟斤拷浅锟酵达拷锟斤拷锟斤拷锟介。</p>
</li>
</ol>
</blockquote>
</blockquote>
<p>&gt;</p>
<blockquote>
<blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE
ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>--
Tinyfool锟侥匡拷锟斤拷锟秸硷拷<a href="http://www.tinydust.net/dev/" target="_blank"><a href="http://www.tinydust.net/dev/">http://www.tinydust.net/dev/</a></a>
锟斤拷锟斤拷锟叫癸拷锟斤拷<a href="http://www.codechina.org/" target="_blank"><a href="http://www.codechina.org">http://www.codechina.org</a></a>
myTwitter:<a href="http://twitter.com/tinyfool" target="_blank"><a href="http://twitter.com/tinyfool">http://twitter.com/tinyfool</a></a></p>
</blockquote>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>To unsubscribe from this group, send email to
pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
<p><a href="">显示删减掉的内容</a>
<img src="" alt=""> Lai Jiangshan <img src="" alt=""></p>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>由于内存/cache模型和编译器/cpu的优化, 并行化是不可能通过库来实现的.
我认为最大的障碍是支持并行化的语言.
2010/3/22 Guancheng Chen <a href="&#109;&#x61;&#x69;&#108;&#x74;&#x6f;&#58;&#91;&#x63;&#104;&#x65;&#110;&#x67;&#x75;&#x2e;&#46;&#x2e;&#x40;&#103;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#111;&#109;&#x5d;&#x28;&#41;">&#91;&#x63;&#104;&#x65;&#110;&#x67;&#x75;&#x2e;&#46;&#x2e;&#x40;&#103;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#111;&#109;&#x5d;&#x28;&#41;</a></p>
<ol>
<li>C语言可以使用pthread等库实现并行化，C++ JAVA等已经会即将支持多线程 所以语言能实现并行化 只是难易问题</li>
<li>是指Shared memory模型，多核共享一条内存总线所以造成带宽问题么？这确实是个问题，不过我感觉硬件商家会负责为你带来越来越多的带
宽，而程序员的任务只是合理的利用好这些给定的带宽</li>
<li>能具体说说哪些误导宣传么？
On 3月22日, 上午1时46分, 陨落雕 <a href="&#109;&#x61;&#105;&#108;&#x74;&#x6f;&#x3a;&#91;&#103;&#x65;&#111;&#46;&#x2e;&#x2e;&#46;&#64;&#103;&#109;&#97;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#x28;&#41;">&#91;&#103;&#x65;&#111;&#46;&#x2e;&#x2e;&#46;&#64;&#103;&#109;&#97;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#x28;&#41;</a> wrote:<blockquote>
<p>呃，我想的障碍是: 1. 类C语言的统治地位; 2. 内存带宽不够; 3. 误导性宣传;</p>
</blockquote>
</li>
</ol>
<p>&gt;</p>
<blockquote>
<p>On Mar 21, 7:37 pm, Guancheng Chen <a href="&#109;&#97;&#105;&#108;&#116;&#x6f;&#58;&#91;&#99;&#104;&#x65;&#110;&#x67;&#x75;&#x61;&#110;&#x63;&#x68;&#x2e;&#46;&#x2e;&#x40;&#103;&#109;&#x61;&#x69;&#x6c;&#46;&#99;&#x6f;&#109;&#93;&#x28;&#x29;">&#91;&#99;&#104;&#x65;&#110;&#x67;&#x75;&#x61;&#110;&#x63;&#x68;&#x2e;&#46;&#x2e;&#x40;&#103;&#109;&#x61;&#x69;&#x6c;&#46;&#99;&#x6f;&#109;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看<a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..</p>
</blockquote>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<blockquote>
<blockquote>
<p>)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a></p>
</li>
</ol>
</blockquote>
</blockquote>
<p><img src="" alt=""> Jeffrey Zhao <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>能详细说说为什么“由于内存/cache模型和编译器/cpu的优化, 并行化是不可能通过库来实现的”吗？</p>
<p>Jeffrey Zhao
Blog: <a href="http://www.cnblogs.com/JeffreyZhao/" title="http://www.cnblogs.com/JeffreyZhao/
CTRL + Click to follow link"><a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter: @jeffz_cn
<strong>From:</strong> <a href="&quot;mailto:eag0628@gmail.com
CTRL + Click to follow link&quot;">Lai Jiangshan</a></p>
<p><strong>Sent:</strong> Monday, March 22, 2010 10:17 PM
<strong>To:</strong> <a href="&quot;mailto:pongba@googlegroups.com
CTRL + Click to follow link&quot;">pon...@googlegroups.com</a></p>
<p><strong>Subject:</strong> Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>由于内存/cache模型和编译器/cpu的优化, 并行化是不可能通过库来实现的.
我认为最大的障碍是支持并行化的语言.
2010/3/22 Guancheng Chen <a href="&#109;&#97;&#105;&#108;&#x74;&#111;&#58;&#91;&#x63;&#104;&#x65;&#110;&#103;&#x75;&#46;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#105;&#108;&#46;&#x63;&#111;&#109;&#93;&#40;&#41;">&#91;&#x63;&#104;&#x65;&#110;&#103;&#x75;&#46;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#105;&#108;&#46;&#x63;&#111;&#109;&#93;&#40;&#41;</a></p>
<ol>
<li>C语言可以使用pthread等库实现并行化，C++ JAVA等已经会即将支持多线程 所以语言能实现并行化 只是难易问题</li>
<li>是指Shared memory模型，多核共享一条内存总线所以造成带宽问题么？这确实是个问题，不过我感觉硬件商家会负责为你带来越来越多的带
宽，而程序员的任务只是合理的利用好这些给定的带宽</li>
<li>能具体说说哪些误导宣传么？
On 3月22日, 上午1时46分, 陨落雕 <a href="&#x6d;&#x61;&#105;&#x6c;&#x74;&#111;&#58;&#91;&#103;&#101;&#x6f;&#46;&#x2e;&#46;&#46;&#x40;&#x67;&#x6d;&#97;&#105;&#108;&#x2e;&#x63;&#111;&#109;&#93;&#40;&#41;">&#91;&#103;&#101;&#x6f;&#46;&#x2e;&#46;&#46;&#x40;&#x67;&#x6d;&#97;&#105;&#108;&#x2e;&#x63;&#111;&#109;&#93;&#40;&#41;</a> wrote:<blockquote>
<p>呃，我想的障碍是: 1. 类C语言的统治地位; 2. 内存带宽不够; 3. 误导性宣传;</p>
<p>On Mar 21, 7:37 pm, Guancheng Chen <a href="&#x6d;&#97;&#105;&#108;&#116;&#x6f;&#x3a;&#x5b;&#x63;&#104;&#x65;&#110;&#103;&#117;&#97;&#110;&#99;&#104;&#x2e;&#46;&#x2e;&#x40;&#103;&#x6d;&#97;&#x69;&#x6c;&#46;&#x63;&#111;&#109;&#93;&#40;&#x29;">&#x5b;&#x63;&#104;&#x65;&#110;&#103;&#117;&#97;&#110;&#99;&#104;&#x2e;&#46;&#x2e;&#x40;&#103;&#x6d;&#97;&#x69;&#x6c;&#46;&#x63;&#111;&#109;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看<a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
</li>
</ol>
</blockquote>
</blockquote>
</li>
</ol>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>您值得是那篇著名的“Threads Cannot be Implemented as a Library”吧？恩，好用的并行语言确实关键，虽然
C++0x和Java都会加入memory model，但是要程序员来手动负责这些事情确实还是挺约束生产力的。</p>
<p>On 3月22日, 下午3时17分, Lai Jiangshan <a href="&#x6d;&#x61;&#105;&#x6c;&#x74;&#x6f;&#x3a;&#x5b;&#101;&#97;&#103;&#48;&#46;&#46;&#x2e;&#x40;&#103;&#109;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#x29;">&#x5b;&#101;&#97;&#103;&#48;&#46;&#46;&#x2e;&#x40;&#103;&#109;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>由于内存/cache模型和编译器/cpu的优化, 并行化是不可能通过库来实现的.</p>
<p>我认为最大的障碍是支持并行化的语言.</p>
<p>2010/3/22 Guancheng Chen <a href="&#x6d;&#97;&#105;&#108;&#x74;&#x6f;&#x3a;&#x5b;&#x63;&#x68;&#x65;&#110;&#x67;&#x75;&#97;&#x6e;&#x63;&#x68;&#46;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#97;&#x69;&#108;&#46;&#99;&#111;&#x6d;&#x5d;&#x28;&#41;">&#x5b;&#x63;&#x68;&#x65;&#110;&#x67;&#x75;&#97;&#x6e;&#x63;&#x68;&#46;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#97;&#x69;&#108;&#46;&#99;&#111;&#x6d;&#x5d;&#x28;&#41;</a></p>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>&gt;
&gt;
&gt;</p>
<blockquote>
<blockquote>
<ol>
<li>C语言可以使用pthread等库实现并行化，C++ JAVA等已经会即将支持多线程 所以语言能实现并行化 只是难易问题</li>
<li>是指Shared memory模型，多核共享一条内存总线所以造成带宽问题么？这确实是个问题，不过我感觉硬件商家会负责为你带来越来越多的带
宽，而程序员的任务只是合理的利用好这些给定的带宽</li>
<li>能具体说说哪些误导宣传么？</li>
</ol>
<p>On 3月22日, 上午1时46分, 陨落雕 <a href="&#109;&#97;&#105;&#x6c;&#116;&#x6f;&#x3a;&#x5b;&#x67;&#101;&#x6f;&#46;&#x2e;&#46;&#x2e;&#x40;&#103;&#109;&#x61;&#x69;&#x6c;&#46;&#x63;&#111;&#109;&#x5d;&#x28;&#x29;">&#x5b;&#x67;&#101;&#x6f;&#46;&#x2e;&#46;&#x2e;&#x40;&#103;&#109;&#x61;&#x69;&#x6c;&#46;&#x63;&#111;&#109;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>呃，我想的障碍是: 1. 类C语言的统治地位; 2. 内存带宽不够; 3. 误导性宣传;</p>
<p>On Mar 21, 7:37 pm, Guancheng Chen <a href="&#x6d;&#97;&#x69;&#108;&#116;&#x6f;&#x3a;&#x5b;&#x63;&#x68;&#101;&#x6e;&#x67;&#x75;&#x61;&#110;&#99;&#x68;&#x2e;&#x2e;&#46;&#x40;&#x67;&#x6d;&#x61;&#105;&#108;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#41;">&#x5b;&#x63;&#x68;&#101;&#x6e;&#x67;&#x75;&#x61;&#110;&#99;&#x68;&#x2e;&#x2e;&#46;&#x40;&#x67;&#x6d;&#x61;&#105;&#108;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看
<a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线</p>
</blockquote>
</blockquote>
<p>程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。</p>
<blockquote>
<blockquote>
<p>尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。</p>
</li>
</ol>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
<a href="">显示删减掉的内容</a></p>
</blockquote>
</blockquote>
<p><img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>主要就是那篇《Threads Cannot be Implemented as a Library》的论文，跟我以前发帖说的
Sequential Consistency，memory model有关</p>
<p>On 3月22日, 下午3时38分, &quot;Jeffrey Zhao&quot; <a href="&#109;&#x61;&#105;&#108;&#x74;&#111;&#x3a;&#91;&#x6a;&#101;&#x2e;&#46;&#x2e;&#64;&#x6c;&#105;&#118;&#x65;&#x2e;&#99;&#111;&#x6d;&#93;&#x28;&#x29;">&#91;&#x6a;&#101;&#x2e;&#46;&#x2e;&#64;&#x6c;&#105;&#118;&#x65;&#x2e;&#99;&#111;&#x6d;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>能详细说说为什么&quot;由于内存/cache模型和编译器/cpu的优化, 并行化是不可能通过库来实现的&quot;吗？</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter: @jeffz_cn</p>
<p>From: Lai Jiangshan
Sent: Monday, March 22, 2010 10:17 PM
To: <a href="">pon...@googlegroups.com</a>
Subject: Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>由于内存/cache模型和编译器/cpu的优化, 并行化是不可能通过库来实现的.</p>
<p>我认为最大的障碍是支持并行化的语言.</p>
<p>2010/3/22 Guancheng Chen <a href="&#x6d;&#97;&#x69;&#x6c;&#116;&#111;&#58;&#x5b;&#x63;&#104;&#x65;&#x6e;&#x67;&#117;&#97;&#110;&#99;&#x68;&#46;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#x61;&#105;&#x6c;&#46;&#99;&#x6f;&#x6d;&#x5d;&#40;&#x29;">&#x5b;&#x63;&#104;&#x65;&#x6e;&#x67;&#117;&#97;&#110;&#99;&#x68;&#46;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#x61;&#105;&#x6c;&#46;&#99;&#x6f;&#x6d;&#x5d;&#40;&#x29;</a></p>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>&gt;</p>
<blockquote>
<ol>
<li>C语言可以使用pthread等库实现并行化，C++ JAVA等已经会即将支持多线程 所以语言能实现并行化 只是难易问题</li>
<li>是指Shared memory模型，多核共享一条内存总线所以造成带宽问题么？这确实是个问题，不过我感觉硬件商家会负责为你带来越来越多的带
宽，而程序员的任务只是合理的利用好这些给定的带宽</li>
<li><p>能具体说说哪些误导宣传么？</p>
<p>On 3月22日, 上午1时46分, 陨落雕 <a href="&#109;&#97;&#x69;&#x6c;&#116;&#111;&#x3a;&#x5b;&#x67;&#101;&#111;&#46;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#x69;&#108;&#46;&#99;&#x6f;&#x6d;&#x5d;&#40;&#41;">&#x5b;&#x67;&#101;&#111;&#46;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#x69;&#108;&#46;&#99;&#x6f;&#x6d;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>呃，我想的障碍是: 1. 类C语言的统治地位; 2. 内存带宽不够; 3. 误导性宣传;</p>
<p>On Mar 21, 7:37 pm, Guancheng Chen <a href="&#109;&#97;&#105;&#108;&#116;&#x6f;&#x3a;&#91;&#x63;&#x68;&#101;&#x6e;&#103;&#x75;&#x61;&#110;&#99;&#104;&#x2e;&#x2e;&#46;&#x40;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#46;&#99;&#111;&#x6d;&#x5d;&#40;&#41;">&#91;&#x63;&#x68;&#101;&#x6e;&#103;&#x75;&#x61;&#110;&#99;&#104;&#x2e;&#x2e;&#46;&#x40;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#46;&#99;&#111;&#x6d;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看<a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。</p>
</li>
</ol>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
</li>
</ol>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> Alleluia <img src="" alt=""></p>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>no no.其实Concurrency和Parallelism完全是两码事情,IO来区分它们其实完全是从最基本的体系结构上来说就是如此的.你把
IO理解为网络通信,磁盘读写就太狭隘了.
比如看这个图
<a href="http://ian--king.javaeye.com/upload/picture/pic/57449/40915ec8-f578-3398-9931-1afa4364a2b9.jpg" target="_blank"><a href="http://ian--king.javaeye.com/upload/picture/pic/57449/40915ec8-f578-3398-9931-1afa4364a2b9.jpg">http://ian--king.javaeye.com/upload/picture/pic/57449/40915ec8-f578-3398-9931-1afa4364a2b9.jpg</a></a>
,我们要计算一个ax^2+bx+c的一元二次方程,左边的是并行计算,右边的是顺序计算.这两者完全就是两个体系结构,我们现在所使用的计算机是右边
那个图是由Control Flow Drive的.左边是Data Flow Drive的是典型的并行计算机的结构.其中最大的区别就是,右边的架
构采用了PC指针和Assignment.Assignment本身不是一个计算过程,仅仅是一次IO操作,从存储器里拿出数据/程序灌入运算器或者相
反.那么Assignment跟Concurrency有什么关系呢?为了响应Assigment这种基础的IO,那么冯结构必须依靠CPU时钟来驱动
PC指针的移动.因此控制流驱动模式构成了CPU响应外界IO的最基本的模式.无论是内存还是磁盘或者网络,CPU要获取外部设备的IO最基本模式,只
能是通过本地时钟触发控制流，周期性发起状态查询.CPU在某个周期向其他设备发送信号，在收到远端设备的反馈信号后计算得出本地代码序列上的程序段地
址,然后移动PC指针指向该地址进行处理。无论是早期的轮询模式还是现在广泛采用的中断方式，其基本的IO模式并没有改变,只不过查询对象由最初的IO
设备演变为中断寄存器.
因此你可以看到,Concurrency其实只是在讨论如何能够利用外设信号与CPU时钟之间的差异,让CPU在一定的时钟周期内尽可能多的响应不同外
设信号。一个通常的程序仅仅只需要通过Assigment响应内存IO,而Concurrency程序需要相应成千上万个外部设备,这仅仅是量上的区别
并没有到任何质上的区别,Concurrency程序本质上仍然是一个顺序执行的程序而已.采用恰当的技术比如完成端口之类的,可以在单核CPU机器上
仅仅采用单线程模型就能得到极高的并发性.当然多核同时处理可以进一步提高并发量,但是这不是必须的.
换一句话说,目前的CPU架构本身就是一种具备了Concurrency能力的顺序型架构.甚至在当初冯诺伊曼设计这个架构的时候,就极力杜绝并行计算
的指令在这种机器上出现在程序里,因为他认为并行执行的指令会让人发疯.而你再看右边的计算机构,与冯结构完全不同.他的计算是彻底并行的,这就是所谓
的数据流驱动.虽然说冯结构本身不利于并行,但是这个体系发展到现在,已经在不同层面上用冯结构模拟数据流计算.往小里说,CPU上最典型的顺序型程序
在微指令层面上有很大一部分就是数据流驱动并行执行的,因为要做OOO.往大了说,并行在若干个独立内核上的线程组之间的互相通信,也是一种数据流驱
动.并行必定是数据流驱动的.这是两者本质上的不同.如果你去看GPU上的并行就更接近这个模型,所有的计算都是分成若干个stage,数据依次从
stage上流过,stage上的并行计算单元对数据进行高密度的并行计算.这就是所谓的流处理器.当然现在的流处理器还是非常的简单,未来的GPU会
像Dataflow machine的方向发展.当然DataFlow machine也有自己的问题，比如说的指令牌粒度太小了，这导致两个重要缺
点，一个是通信代价非常高，另一个是指令牌点火代价很高。而Standford的ImagineGPU流处理器引擎可以看作介于数据流机和指令流机之间
的架构，所作的一个重要权衡就是增加指令牌的粒度，从而减小点火代价和利用赠大的Token粒度去减小通信代价</p>
<p>至于粒度问题,关键是看你的计算资源有多少.比如说CPU目前最多8核,16核.那么你所谓的按照循环来进行并行自然是可行的,但是你放到CUDA上
去,GTX295有250个内核,你为了让他所有的内核处于工作繁忙的状态,就根本不可能按照循环层次来进行并行,在这个上面并行的粒度是需要划分的极
为纤细的。更诡异的是有些算法,处理的数据量很小,但是计算量可能极为庞大.比如一些运动估计算法,在一个16/*16的像素区域内要完成256×256
次sad运算.这种数据量和计算完全非常不成比例的.怎么对并行粒度的进行有效的划分,非常考算法功夫的.并行计算最好是通过算法杜绝锁,这也是非常困
难的地方.</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>On 3月22日, 下午7时04分, Guancheng Chen <a href="&#109;&#97;&#x69;&#x6c;&#116;&#x6f;&#58;&#91;&#99;&#104;&#x65;&#110;&#x67;&#117;&#x61;&#x6e;&#x63;&#104;&#46;&#46;&#x2e;&#x40;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#x6d;&#93;&#40;&#x29;">&#91;&#99;&#104;&#x65;&#110;&#x67;&#117;&#x61;&#x6e;&#x63;&#104;&#46;&#46;&#x2e;&#x40;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#x6d;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>您的观点很有新意，我以前没有过用IO来区分Concurrency和Parallelism的想法，我猜测可能跟您的网络/通信背景有关。其实我觉得
从广义上来讲Parallelism和Concurrency是基本重合的两个概念，只不过可能Concurrency稍微偏工程一点，
Parallelism稍微偏研究一点。例如Herb Sutter要出的新书叫Effective Concurrency,而市面上其他讲并行计算
的书不少也使用Parallel相关的词汇。</p>
<p>另外您这句话我有些不赞同：&quot;颗粒度越小的并行获得的计算资源的利用率也就越大加速比就越大&quot;，拿一个计算密集型的嵌套循环举例，对比并行外层循环和并
行内层循环，无疑你在并行化外层循环时的性能加速比更好，而这时候你的并行度是粗粒度的(内循环并行相对来说是细粒度的)。当然，粗/细粒度的选择确实
是个tradeoff，拿锁竞争来说，细粒度的锁意味着更好的Scalability，但是你加锁/解锁的次数相比组粒度所来说增加了，而这种加锁/解
锁的操作是有开销的，所以需要在锁操作本身的开销和程序的Scalability中做一个平衡。</p>
<p>多谢指教！</p>
<p>On 3月22日, 上午10时19分, Alleluia <a href="&#x6d;&#97;&#x69;&#x6c;&#116;&#111;&#58;&#91;&#x61;&#x6c;&#x6c;&#x75;&#108;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#97;&#x69;&#x6c;&#46;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#41;">&#91;&#x61;&#x6c;&#x6c;&#x75;&#108;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#97;&#x69;&#x6c;&#46;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>Concurrency 说到底纯粹就是一个IO问题.而IO问题本质上是和计算完全无关的事情,不存在能不能行可不可计算的问题.因此它相对来说非常
单纯。他更多的是一种类似时钟同步的问题,如果你把IO事件想像成一种时钟信号.其实时钟本来也就是一堆信号而已.如果你做过Circuit 的东西就
会明白,IO只是在不同的时序下进行数据采样.比如最简单的同步时钟,所有的时序电路公用一个时钟,把不同的电路安排在不同的时序边沿上触发.当然更复
杂异步逻辑的道理也是一样的.放到宏观的Concurrency的问题的实质并没有多大改变,只不过CPU依靠PC指针的移动把这种电路上的时序处理软
件化了.</p>
<p>而Parallelism更多的是需要考虑计算问题同时还要兼顾IO.Parallelism首先要回答的是一个东西是不是可并行的.回答完这个问题
后,如果可并行那么在什么样的硬件设备上并行是最合适的这样一个问题.在Parallelism中需要考虑的的IO也不仅仅是来自于网络更多是,缓存,
内存,磁盘,总线等等.其实我觉得,在Parallelism下你总是处于一个矛盾状态,颗粒度越小的并行获得的计算资源的利用率也就越大加速比就越
大,但是同时通信系统的工作也就越是繁忙整个运算过程浪费在通信消耗上的时间也就越多.
这个当中的tradeoff是非常困难的.很多时候速度不快,完全不是因为你的核心不够多,而是你的通信速度不够高.</p>
<p>On 3月22日, 下午3时21分, Guancheng Chen <a href="&#109;&#x61;&#105;&#108;&#x74;&#x6f;&#x3a;&#91;&#99;&#104;&#101;&#x6e;&#103;&#117;&#97;&#x6e;&#99;&#104;&#x2e;&#46;&#x2e;&#x40;&#x67;&#109;&#97;&#x69;&#108;&#x2e;&#x63;&#111;&#x6d;&#93;&#x28;&#41;">&#91;&#99;&#104;&#101;&#x6e;&#103;&#117;&#97;&#x6e;&#99;&#104;&#x2e;&#46;&#x2e;&#x40;&#x67;&#109;&#97;&#x69;&#108;&#x2e;&#x63;&#111;&#x6d;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>绝大部分的观点Can&#39;t agree more.其实这也是为什么我引用了高老爷子那段话的原因，因为程序的本质就是数据结构和算法，你要没有非常适
合并行的算法那简直就是巧妇难为无米之炊。但是有疑问的一点是关于Parallelism和Concurrency这两个单词的区别，实际上这也是非常
有意思的一件事情，Sun的多线程指南上写的是： Parallelism is a condition that arises when at
least two threads are executing simultaneously, while concurrency is a
condition that exists when at least two threads are making progress.
Therefore concurrency is a more generalized form of parallelism that
can include time-slicing as a form of virtual parallelism.不知道您怎么看？</p>
<p>On 3月22日, 上午8时06分, Alleluia <a href="&#x6d;&#97;&#x69;&#x6c;&#x74;&#x6f;&#x3a;&#x5b;&#x61;&#x6c;&#108;&#117;&#108;&#x2e;&#46;&#x2e;&#x40;&#103;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#99;&#111;&#x6d;&#x5d;&#x28;&#41;">&#x5b;&#x61;&#x6c;&#108;&#117;&#108;&#x2e;&#46;&#x2e;&#x40;&#103;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#99;&#111;&#x6d;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>Parallelism 说到底是算法问题.Parallelism与Concurrency不同,Concurrency所面对的问题相对的单一可以
让一群有经验的专家来实现一套通用库或者语言来提供一个基本的编程框架.而在Parallelism上,具体的不同问题,其所需要并行的算法是根本不同
的.原因在于不同的问题,其内部的DataDependency的结构完全不同,不同的Data Dependency的结构,需要构造不同的算法.即
便是相同的Data Dependency,在不同的颗粒度下，在不同的硬件条件下所采用的算法也是完全不同的.因为一旦出现Data
Dependency也就意味着并行计算模块之间需要进行通信.从以计算节点为单位的分布式并行,到多核CPU上的Numa结构,到SIMD上的向量处
理器,其计算单元之间的通信手段,通信效率简直天差地别.比如说,在SMP上最常见的并行算法,work stealing也就是Intel的TBB,
是建立在两个条件下第一个是CPU的Cache机制上,这使得通常在内存的之间的数据搬运消耗非常小,第二个是SMP上计算单元相对的少,因此每个计算
单元被分配到的任务就相对的重。其开销远远大于通信的开销,因此这种机制在SMP上相对的划算.但是如果你要在GPU上做Work Stealing就
完全不可行,因为GPU的运算单元数量极多,被分配到的任务就相对来说的非常轻量,CUDA上的一个thread很多时候运算一次的时间不会超过
10us,而一次跨Block的线程之间的通信开销就往往要达到100us左右,再加上目前GPU上的Cache机制非常落后导致了需要频繁的通信开销
的Work Stealing在GPU上是非常不划算得.
所以我个人认为在硬件架构没有更多的突破之前,OpenCL这种东西是没有任何生命力的.不要说CPU的并行与GPU之间差异巨大,就是不同的GPU之
间AMD与Nvidia两个也是各自为政,一个平台上跑得非常快的东西,在另外一个平台极大的可能是龟速.其最终的结果估计就是跟Java的
write once run everywhere一样是个大笑话.</p>
<p>On 3月22日, 下午2时06分, Guancheng Chen <a href="&#x6d;&#97;&#105;&#x6c;&#x74;&#x6f;&#x3a;&#91;&#x63;&#x68;&#x65;&#x6e;&#103;&#117;&#x61;&#x6e;&#x63;&#x68;&#x2e;&#46;&#46;&#x40;&#103;&#x6d;&#97;&#x69;&#108;&#46;&#99;&#111;&#x6d;&#93;&#x28;&#x29;">&#91;&#x63;&#x68;&#x65;&#x6e;&#103;&#117;&#x61;&#x6e;&#x63;&#x68;&#x2e;&#46;&#46;&#x40;&#103;&#x6d;&#97;&#x69;&#108;&#46;&#99;&#111;&#x6d;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>On 3月22日, 上午2时20分, Tinyfool <a href="&#x6d;&#x61;&#x69;&#108;&#116;&#x6f;&#x3a;&#x5b;&#116;&#105;&#x6e;&#x79;&#x66;&#46;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#97;&#x69;&#108;&#46;&#99;&#x6f;&#109;&#93;&#40;&#x29;">&#x5b;&#116;&#105;&#x6e;&#x79;&#x66;&#46;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#97;&#x69;&#108;&#46;&#99;&#x6f;&#109;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#x6d;&#x61;&#105;&#x6c;&#x74;&#x6f;&#58;&#91;&#x6a;&#x65;&#x2e;&#x2e;&#x2e;&#x40;&#x6c;&#105;&#118;&#101;&#46;&#99;&#x6f;&#109;&#93;&#x28;&#41;">&#91;&#x6a;&#x65;&#x2e;&#x2e;&#x2e;&#x40;&#x6c;&#105;&#118;&#101;&#46;&#99;&#x6f;&#109;&#93;&#x28;&#41;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a></p>
<p>Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#109;&#x61;&#x69;&#108;&#x74;&#111;&#58;&#91;&#99;&#x68;&#x65;&#x6e;&#103;&#117;&#x61;&#110;&#99;&#x68;&#x2e;&#46;&#x2e;&#64;&#x67;&#109;&#x61;&#x69;&#108;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#x29;">&#91;&#99;&#x68;&#x65;&#x6e;&#103;&#117;&#x61;&#110;&#99;&#x68;&#x2e;&#46;&#x2e;&#64;&#x67;&#109;&#x61;&#x69;&#108;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#x29;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#109;&#97;&#x69;&#108;&#x74;&#x6f;&#58;&#x5b;&#112;&#x6f;&#110;&#x2e;&#x2e;&#x2e;&#64;&#103;&#111;&#111;&#103;&#x6c;&#101;&#x67;&#114;&#x6f;&#x75;&#112;&#x73;&#46;&#99;&#x6f;&#x6d;&#93;&#x28;&#x29;">&#x5b;&#112;&#x6f;&#110;&#x2e;&#x2e;&#x2e;&#64;&#103;&#111;&#111;&#103;&#x6c;&#101;&#x67;&#114;&#x6f;&#x75;&#112;&#x73;&#46;&#99;&#x6f;&#x6d;&#93;&#x28;&#x29;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>&gt;</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间</li>
</ol>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>...</p>
<p>阅读更多 &gt;&gt;
<a href="">显示删减掉的内容</a></p>
</blockquote>
<p><img src="" alt=""> Alleluia <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>且抛开,流处理器这种异构的内核,SMP和Numa之间的差异.就说说单个CPU上做SIMD并行化的需要考虑的内存/cache问题.
比如作矩阵乘法运算,如果矩阵都是按照行存储, 则在A/*B中, 乘法对B的访问是按列的. 假设B一行有N个元素, 那么在存储器中, 两个同列不同
行的元素所在的存储单元相差N. 对B的访问并不是局部化的. 因为访问不局部化, 所以每次乘法, 都需要从内存中调一个 cache 单元到
CPU. 这个极大的降低了处理器的执行速度. 因此, 矩阵乘法的优化的核心, 在于局部化B的访问. 反过来, 如果矩阵按照列存储, 则要局部化
对A的访问. 关于怎样局部化访问还能获得正确的乘法,那就要针对具体的情况设计正确的算法.
为何并行化不可能用库来实现呢?其实问题根源在于,并行颗粒度的变化,导致对IO,算法的乃至硬件结构产生天差地别的变化.一个顺序型的问题,可以划分
成不同的颗粒度.比如说一个100M的Byte型数组,要求和,你可以按照1M的颗粒度进行划分,也可以按照1K,甚至256，128，乃至
4byte,8byte进行划分.每种划分,产生的数据搬运的次数,每次数据搬运的大小,乃至缓存命中率都是不同。
再进一步说,颗粒度划分的越细,意味着计算单元就需要增加,否则就没有意义.但是一旦运算单元的增加到一个的极限,就会引起硬件结构的改变,比如说
SMP根本无法支撑超过16Core的架构,超过这个限度你就得换Nehalem那种Numa架构.在Numa结构下你就不得不考虑,本地内存和远端内
存的区别。
目前没有一个很好的方案来统一不同等级并行计算的架构,在8核之下你用Numa就是杀鸡用牛刀了,而超过32核Numa也不堪重负需要像GPU那样去设
计硬件架构这也就是为什么Intel的Larrebe会难产的原因.每个X86内核都要顶着一个硕大的Deocder还有branch
prediction,OOO之类的庞然大物,用PII来做Larrebe都非常的头大的事情.所以,我个人认为,并行化本身就是和硬件结构极为相关的
事情,这一切都不太可能由一个统一的计算库来完成统一的封装.</p>
<p>On 3月22日, 下午10时38分, &quot;Jeffrey Zhao&quot; <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#91;&#x6a;&#x65;&#46;&#46;&#x2e;&#x40;&#108;&#x69;&#118;&#x65;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#x29;">&#91;&#x6a;&#x65;&#46;&#46;&#x2e;&#x40;&#108;&#x69;&#118;&#x65;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>能详细说说为什么&quot;由于内存/cache模型和编译器/cpu的优化, 并行化是不可能通过库来实现的&quot;吗？</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter: @jeffz_cn</p>
<p>From: Lai Jiangshan
Sent: Monday, March 22, 2010 10:17 PM
To: <a href="">pon...@googlegroups.com</a>
Subject: Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>由于内存/cache模型和编译器/cpu的优化, 并行化是不可能通过库来实现的.</p>
<p>我认为最大的障碍是支持并行化的语言.</p>
<p>2010/3/22 Guancheng Chen <a href="&#x6d;&#x61;&#105;&#108;&#x74;&#x6f;&#x3a;&#x5b;&#x63;&#104;&#x65;&#110;&#x67;&#x75;&#x61;&#110;&#99;&#x68;&#x2e;&#x2e;&#x2e;&#64;&#103;&#109;&#97;&#105;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#93;&#40;&#x29;">&#x5b;&#x63;&#104;&#x65;&#110;&#x67;&#x75;&#x61;&#110;&#99;&#x68;&#x2e;&#x2e;&#x2e;&#64;&#103;&#109;&#97;&#105;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#93;&#40;&#x29;</a></p>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>&gt;</p>
<blockquote>
<ol>
<li>C语言可以使用pthread等库实现并行化，C++ JAVA等已经会即将支持多线程 所以语言能实现并行化 只是难易问题</li>
<li>是指Shared memory模型，多核共享一条内存总线所以造成带宽问题么？这确实是个问题，不过我感觉硬件商家会负责为你带来越来越多的带
宽，而程序员的任务只是合理的利用好这些给定的带宽</li>
<li><p>能具体说说哪些误导宣传么？</p>
<p>On 3月22日, 上午1时46分, 陨落雕 <a href="&#109;&#x61;&#x69;&#108;&#x74;&#x6f;&#58;&#91;&#x67;&#x65;&#111;&#46;&#x2e;&#x2e;&#x2e;&#64;&#103;&#x6d;&#97;&#105;&#x6c;&#46;&#99;&#x6f;&#x6d;&#93;&#40;&#41;">&#91;&#x67;&#x65;&#111;&#46;&#x2e;&#x2e;&#x2e;&#64;&#103;&#x6d;&#97;&#105;&#x6c;&#46;&#99;&#x6f;&#x6d;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>呃，我想的障碍是: 1. 类C语言的统治地位; 2. 内存带宽不够; 3. 误导性宣传;</p>
<p>On Mar 21, 7:37 pm, Guancheng Chen <a href="&#x6d;&#97;&#x69;&#x6c;&#116;&#x6f;&#58;&#91;&#99;&#104;&#x65;&#110;&#x67;&#x75;&#97;&#x6e;&#99;&#x68;&#46;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#x6f;&#109;&#93;&#40;&#41;">&#91;&#99;&#104;&#x65;&#110;&#x67;&#x75;&#97;&#x6e;&#99;&#x68;&#46;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#x6f;&#109;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看<a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。</p>
</li>
</ol>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
</li>
</ol>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> 郑伟 <img src="" alt=""></p>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>我对这个比较感兴趣，能详细介绍一下golang在多核下的表现吗？</p>
<p>2010/3/22 Googol Lee <a href="&#x6d;&#97;&#105;&#108;&#x74;&#111;&#58;&#91;&#103;&#111;&#x6f;&#103;&#46;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#105;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#93;&#40;&#41;">&#91;&#103;&#111;&#x6f;&#103;&#46;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#105;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#93;&#40;&#41;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>彻底来晚了......我是来广告golang的！大并发IO还是csp模型的语言更靠谱！
不过golang在cpu密集的并发上不知道效果会怎么样，就现在的表现来看比erlang好，但还赶不上c/c++
On Mar 22, 9:20 am, Tinyfool <a href="&#109;&#97;&#x69;&#108;&#x74;&#111;&#58;&#x5b;&#x74;&#x69;&#x6e;&#x79;&#102;&#46;&#46;&#46;&#64;&#x67;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#40;&#x29;">&#x5b;&#x74;&#x69;&#x6e;&#x79;&#102;&#46;&#46;&#46;&#64;&#x67;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#109;&#97;&#x69;&#108;&#x74;&#111;&#58;&#x5b;&#106;&#101;&#x2e;&#x2e;&#46;&#64;&#x6c;&#x69;&#118;&#x65;&#46;&#99;&#111;&#109;&#93;&#40;&#41;">&#x5b;&#106;&#101;&#x2e;&#x2e;&#46;&#64;&#x6c;&#x69;&#118;&#x65;&#46;&#99;&#111;&#109;&#93;&#40;&#41;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#109;&#97;&#x69;&#x6c;&#116;&#111;&#x3a;&#91;&#x63;&#104;&#101;&#x6e;&#x67;&#117;&#x61;&#x6e;&#99;&#104;&#46;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#x61;&#105;&#108;&#46;&#x63;&#x6f;&#109;&#93;&#x28;&#41;">&#91;&#x63;&#104;&#101;&#x6e;&#x67;&#117;&#x61;&#x6e;&#99;&#104;&#46;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#x61;&#105;&#108;&#46;&#x63;&#x6f;&#109;&#93;&#x28;&#41;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#109;&#97;&#105;&#x6c;&#x74;&#111;&#x3a;&#x5b;&#x70;&#111;&#110;&#x2e;&#46;&#x2e;&#64;&#x67;&#x6f;&#111;&#x67;&#x6c;&#x65;&#103;&#114;&#111;&#117;&#x70;&#x73;&#46;&#x63;&#111;&#109;&#x5d;&#x28;&#x29;">&#x5b;&#x70;&#111;&#110;&#x2e;&#46;&#x2e;&#64;&#x67;&#x6f;&#111;&#x67;&#x6c;&#x65;&#103;&#114;&#111;&#117;&#x70;&#x73;&#46;&#x63;&#111;&#109;&#x5d;&#x28;&#x29;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。</p>
</li>
</ol>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>--</p>
<p>Tinyfool的开发日记<a href="http://www.tinydust.net/dev/" target="_blank"><a href="http://www.tinydust.net/dev/">http://www.tinydust.net/dev/</a></a>
代码中国网<a href="http://www.codechina.org/" target="_blank"><a href="http://www.codechina.org">http://www.codechina.org</a></a></p>
<p>myTwitter:<a href="http://twitter.com/tinyfool" target="_blank"><a href="http://twitter.com/tinyfool">http://twitter.com/tinyfool</a></a>
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a></p>
</blockquote>
<p><img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-23</p>
<p>其他收件人：</p>
<p>您说的可能跟那个问题不是一回事情，窃以为Lai Jiangshan所说的是指CPU和编译器会对并行程序做违反程序semantics的优化（例如
reordering），导致破坏Memory Consistency，例如大牛HJ Boehm的一篇论文《Threads Cannot be
Implemented as a Library》，我之前也写过一篇浅显小文：<a href="http://www.parallellabs.com/2010/03/06/why-should-programmer-care-about-sequential-consistency-rather-than-cache-coherence/" target="_blank"><a href="http://www.parallellabs.com/">http://www.parallellabs.com/</a>
2010/03/06/why-should-programmer-care-about-sequential-consistency-
rather-than-cache-coherence/</a></p>
<p>另外对于您的Concurrency和Parallelism的看法，我大致理解了您所指的&quot;Concurrency&quot;的含义，它跟我所认为的软件层面
的Concurrency不太一样，您的含义更宏观一些，但是感觉我还没有抓住它的精要，不知道能否推荐几篇文献供我参考？</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>On 3月22日, 下午4时35分, Alleluia <a href="&#x6d;&#97;&#105;&#108;&#x74;&#111;&#58;&#x5b;&#97;&#x6c;&#108;&#117;&#108;&#46;&#46;&#x2e;&#64;&#x67;&#x6d;&#x61;&#105;&#108;&#46;&#x63;&#x6f;&#109;&#x5d;&#x28;&#41;">&#x5b;&#97;&#x6c;&#108;&#117;&#108;&#46;&#46;&#x2e;&#64;&#x67;&#x6d;&#x61;&#105;&#108;&#46;&#x63;&#x6f;&#109;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>且抛开,流处理器这种异构的内核,SMP和Numa之间的差异.就说说单个CPU上做SIMD并行化的需要考虑的内存/cache问题.
比如作矩阵乘法运算,如果矩阵都是按照行存储, 则在A/*B中, 乘法对B的访问是按列的. 假设B一行有N个元素, 那么在存储器中, 两个同列不同
行的元素所在的存储单元相差N. 对B的访问并不是局部化的. 因为访问不局部化, 所以每次乘法, 都需要从内存中调一个 cache 单元到
CPU. 这个极大的降低了处理器的执行速度. 因此, 矩阵乘法的优化的核心, 在于局部化B的访问. 反过来, 如果矩阵按照列存储, 则要局部化
对A的访问. 关于怎样局部化访问还能获得正确的乘法,那就要针对具体的情况设计正确的算法.
为何并行化不可能用库来实现呢?其实问题根源在于,并行颗粒度的变化,导致对IO,算法的乃至硬件结构产生天差地别的变化.一个顺序型的问题,可以划分
成不同的颗粒度.比如说一个100M的Byte型数组,要求和,你可以按照1M的颗粒度进行划分,也可以按照1K,甚至256，128，乃至
4byte,8byte进行划分.每种划分,产生的数据搬运的次数,每次数据搬运的大小,乃至缓存命中率都是不同。
再进一步说,颗粒度划分的越细,意味着计算单元就需要增加,否则就没有意义.但是一旦运算单元的增加到一个的极限,就会引起硬件结构的改变,比如说
SMP根本无法支撑超过16Core的架构,超过这个限度你就得换Nehalem那种Numa架构.在Numa结构下你就不得不考虑,本地内存和远端内
存的区别。
目前没有一个很好的方案来统一不同等级并行计算的架构,在8核之下你用Numa就是杀鸡用牛刀了,而超过32核Numa也不堪重负需要像GPU那样去设
计硬件架构这也就是为什么Intel的Larrebe会难产的原因.每个X86内核都要顶着一个硕大的Deocder还有branch
prediction,OOO之类的庞然大物,用PII来做Larrebe都非常的头大的事情.所以,我个人认为,并行化本身就是和硬件结构极为相关的
事情,这一切都不太可能由一个统一的计算库来完成统一的封装.</p>
<p>On 3月22日, 下午10时38分, &quot;Jeffrey Zhao&quot; <a href="&#x6d;&#97;&#105;&#108;&#x74;&#x6f;&#x3a;&#91;&#106;&#x65;&#46;&#x2e;&#x2e;&#x40;&#x6c;&#105;&#118;&#x65;&#x2e;&#x63;&#111;&#109;&#x5d;&#40;&#41;">&#91;&#106;&#x65;&#46;&#x2e;&#x2e;&#x40;&#x6c;&#105;&#118;&#x65;&#x2e;&#x63;&#111;&#109;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>能详细说说为什么&quot;由于内存/cache模型和编译器/cpu的优化, 并行化是不可能通过库来实现的&quot;吗？</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter: @jeffz_cn</p>
<p>From: Lai Jiangshan
Sent: Monday, March 22, 2010 10:17 PM
To: <a href="">pon...@googlegroups.com</a>
Subject: Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>由于内存/cache模型和编译器/cpu的优化, 并行化是不可能通过库来实现的.</p>
<p>我认为最大的障碍是支持并行化的语言.</p>
<p>2010/3/22 Guancheng Chen <a href="&#109;&#97;&#105;&#108;&#x74;&#x6f;&#x3a;&#91;&#99;&#x68;&#x65;&#x6e;&#x67;&#117;&#97;&#110;&#x63;&#104;&#x2e;&#46;&#46;&#x40;&#103;&#x6d;&#97;&#105;&#108;&#x2e;&#99;&#111;&#x6d;&#93;&#40;&#41;">&#91;&#99;&#x68;&#x65;&#x6e;&#x67;&#117;&#97;&#110;&#x63;&#104;&#x2e;&#46;&#46;&#x40;&#103;&#x6d;&#97;&#105;&#108;&#x2e;&#99;&#111;&#x6d;&#93;&#40;&#41;</a></p>
<ol>
<li>C语言可以使用pthread等库实现并行化，C++ JAVA等已经会即将支持多线程 所以语言能实现并行化 只是难易问题</li>
<li>是指Shared memory模型，多核共享一条内存总线所以造成带宽问题么？这确实是个问题，不过我感觉硬件商家会负责为你带来越来越多的带
宽，而程序员的任务只是合理的利用好这些给定的带宽</li>
<li><p>能具体说说哪些误导宣传么？</p>
<p>On 3月22日, 上午1时46分, 陨落雕 <a href="&#x6d;&#97;&#x69;&#x6c;&#x74;&#111;&#x3a;&#x5b;&#x67;&#101;&#111;&#x2e;&#46;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#x61;&#105;&#x6c;&#46;&#x63;&#x6f;&#109;&#x5d;&#40;&#41;">&#x5b;&#x67;&#101;&#111;&#x2e;&#46;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#x61;&#105;&#x6c;&#46;&#x63;&#x6f;&#109;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>呃，我想的障碍是: 1. 类C语言的统治地位; 2. 内存带宽不够; 3. 误导性宣传;</p>
<p>On Mar 21, 7:37 pm, Guancheng Chen <a href="&#x6d;&#x61;&#105;&#x6c;&#116;&#111;&#58;&#x5b;&#x63;&#x68;&#x65;&#x6e;&#x67;&#117;&#x61;&#110;&#x63;&#x68;&#46;&#x2e;&#x2e;&#x40;&#x67;&#109;&#97;&#105;&#x6c;&#46;&#x63;&#111;&#109;&#93;&#x28;&#41;">&#x5b;&#x63;&#x68;&#x65;&#x6e;&#x67;&#117;&#x61;&#110;&#x63;&#x68;&#46;&#x2e;&#x2e;&#x40;&#x67;&#109;&#97;&#105;&#x6c;&#46;&#x63;&#111;&#109;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看<a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx...</p>
</blockquote>
</blockquote>
</li>
</ol>
</blockquote>
<p>阅读更多 &gt;&gt;
<a href="">显示删减掉的内容</a>
<img src="" alt=""> windstorm <img src="" alt=""></p>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-23</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>实在是不能同意你更多......很早很早以前我就在这里和人争论过，GPU的并行计算平台不可能一统天下的。CUDA也不是救世主。OpenCL更不是。</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p><a href="http://www.kunli.info/" target="_blank">www.kunli.info</a>
<a href="http://twitter.com/cnbuff" target="_blank"><a href="http://twitter.com/cnbuff">http://twitter.com/cnbuff</a></a></p>
<p>2010/3/22 Alleluia <a href="&#x6d;&#x61;&#105;&#108;&#116;&#x6f;&#x3a;&#91;&#97;&#108;&#x6c;&#117;&#46;&#x2e;&#46;&#x40;&#x67;&#109;&#97;&#105;&#x6c;&#46;&#99;&#x6f;&#109;&#x5d;&#40;&#41;">&#91;&#97;&#108;&#x6c;&#117;&#46;&#x2e;&#46;&#x40;&#x67;&#109;&#97;&#105;&#x6c;&#46;&#99;&#x6f;&#109;&#x5d;&#40;&#41;</a>:</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<blockquote>
<p>Parallelism 说到底是算法问题.Parallelism与Concurrency不同,Concurrency所面对的问题相对的单一可以
让一群有经验的专家来实现一套通用库或者语言来提供一个基本的编程框架.而在Parallelism上,具体的不同问题,其所需要并行的算法是根本不同
的.原因在于不同的问题,其内部的DataDependency的结构完全不同,不同的Data Dependency的结构,需要构造不同的算法.即
便是相同的Data Dependency,在不同的颗粒度下，在不同的硬件条件下所采用的算法也是完全不同的.因为一旦出现Data
Dependency也就意味着并行计算模块之间需要进行通信.从以计算节点为单位的分布式并行,到多核CPU上的Numa结构,到SIMD上的向量处
理器,其计算单元之间的通信手段,通信效率简直天差地别.比如说,在SMP上最常见的并行算法,work stealing也就是Intel的TBB,
是建立在两个条件下第一个是CPU的Cache机制上,这使得通常在内存的之间的数据搬运消耗非常小,第二个是SMP上计算单元相对的少,因此每个计算
单元被分配到的任务就相对的重。其开销远远大于通信的开销,因此这种机制在SMP上相对的划算.但是如果你要在GPU上做Work Stealing就
完全不可行,因为GPU的运算单元数量极多,被分配到的任务就相对来说的非常轻量,CUDA上的一个thread很多时候运算一次的时间不会超过
10us,而一次跨Block的线程之间的通信开销就往往要达到100us左右,再加上目前GPU上的Cache机制非常落后导致了需要频繁的通信开销
的Work Stealing在GPU上是非常不划算得.
所以我个人认为在硬件架构没有更多的突破之前,OpenCL这种东西是没有任何生命力的.不要说CPU的并行与GPU之间差异巨大,就是不同的GPU之
间AMD与Nvidia两个也是各自为政,一个平台上跑得非常快的东西,在另外一个平台极大的可能是龟速.其最终的结果估计就是跟Java的
write once run everywhere一样是个大笑话.</p>
<p>On 3月22日, 下午2时06分, Guancheng Chen <a href="&#109;&#97;&#x69;&#x6c;&#x74;&#111;&#x3a;&#91;&#x63;&#104;&#x65;&#x6e;&#103;&#x75;&#x61;&#110;&#99;&#x68;&#x2e;&#46;&#46;&#64;&#x67;&#109;&#x61;&#x69;&#108;&#46;&#x63;&#111;&#x6d;&#93;&#40;&#x29;">&#91;&#x63;&#104;&#x65;&#x6e;&#103;&#x75;&#x61;&#110;&#99;&#x68;&#x2e;&#46;&#46;&#64;&#x67;&#109;&#x61;&#x69;&#108;&#46;&#x63;&#111;&#x6d;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>On 3月22日, 上午2时20分, Tinyfool <a href="&#x6d;&#97;&#105;&#108;&#116;&#111;&#58;&#91;&#116;&#105;&#x6e;&#121;&#x66;&#x2e;&#46;&#x2e;&#64;&#103;&#109;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#x28;&#x29;">&#91;&#116;&#105;&#x6e;&#121;&#x66;&#x2e;&#46;&#x2e;&#64;&#103;&#109;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#109;&#97;&#105;&#x6c;&#116;&#x6f;&#58;&#91;&#106;&#x65;&#46;&#46;&#46;&#64;&#108;&#x69;&#x76;&#101;&#46;&#x63;&#x6f;&#109;&#93;&#40;&#x29;">&#91;&#106;&#x65;&#46;&#46;&#46;&#64;&#108;&#x69;&#x76;&#101;&#46;&#x63;&#x6f;&#109;&#93;&#40;&#x29;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#109;&#x61;&#105;&#108;&#116;&#111;&#58;&#x5b;&#99;&#104;&#101;&#x6e;&#103;&#x75;&#x61;&#x6e;&#x63;&#104;&#x2e;&#x2e;&#x2e;&#64;&#103;&#x6d;&#97;&#x69;&#108;&#x2e;&#99;&#111;&#109;&#93;&#40;&#41;">&#x5b;&#99;&#104;&#101;&#x6e;&#103;&#x75;&#x61;&#x6e;&#x63;&#104;&#x2e;&#x2e;&#x2e;&#64;&#103;&#x6d;&#97;&#x69;&#108;&#x2e;&#99;&#111;&#109;&#93;&#40;&#41;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#109;&#x61;&#x69;&#x6c;&#x74;&#x6f;&#58;&#x5b;&#112;&#111;&#110;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#x6f;&#111;&#103;&#108;&#x65;&#x67;&#x72;&#x6f;&#117;&#x70;&#115;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#40;&#41;">&#x5b;&#112;&#111;&#110;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#x6f;&#111;&#103;&#108;&#x65;&#x67;&#x72;&#x6f;&#117;&#x70;&#115;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#40;&#41;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。</p>
</li>
</ol>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>--
Tinyfool的开发日记<a href="http://www.tinydust.net/dev/" target="_blank"><a href="http://www.tinydust.net/dev/">http://www.tinydust.net/dev/</a></a>
代码中国网<a href="http://www.codechina.org/" target="_blank"><a href="http://www.codechina.org">http://www.codechina.org</a></a>
myTwitter:<a href="http://twitter.com/tinyfool" target="_blank"><a href="http://twitter.com/tinyfool">http://twitter.com/tinyfool</a></a></p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p><a href="">显示删减掉的内容</a></p>
</blockquote>
<p><img src="" alt=""> Juv...@gmail.com <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-23</p>
<p>其他收件人：</p>
<p>好像大家说的concurrency和parallelism不是一个东西？
<a href="">显示删减掉的内容</a>
<img src="" alt=""> windstorm <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-23</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>我觉得这两个东西，sun的多线程编程手册说得很清楚了，没必要重新定义。</p>
<p>Parallelism is a condition that arises when at least two threads are
executing simultaneously, while concurrency is a condition that exists
when at least two threads are making progress.</p>
<p>也就是说concurrency有点像更通用化，限制条件更低的parallelism，而某些case下两者完全不同。比如单核多线程程序，你可以叫它是concurrent
program，但不能叫它是parallel
program。Concurrency在现有体系的处理器架构下都可以做到。和Alleluia说的一样，只是一个时钟周期同步的问题。写过硬件编程的人，几乎都算是写过concurrent
program，但很少写过parallel program</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p><a href="http://www.kunli.info/" target="_blank">www.kunli.info</a>
<a href="http://twitter.com/cnbuff" target="_blank"><a href="http://twitter.com/cnbuff">http://twitter.com/cnbuff</a></a></p>
<p>2010/3/22 <a href="">Juv...@gmail.com</a> <a href="&#109;&#x61;&#x69;&#108;&#x74;&#111;&#x3a;&#x5b;&#x6a;&#x75;&#118;&#46;&#46;&#46;&#64;&#103;&#x6d;&#97;&#105;&#x6c;&#46;&#x63;&#111;&#109;&#x5d;&#40;&#x29;">&#x5b;&#x6a;&#x75;&#118;&#46;&#46;&#46;&#64;&#103;&#x6d;&#97;&#105;&#x6c;&#46;&#x63;&#111;&#109;&#x5d;&#40;&#x29;</a>:</p>
<blockquote>
<p>好像大家说的concurrency和parallelism不是一个东西？</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p><a href="">显示删减掉的内容</a></p>
</blockquote>
<p><img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-23</p>
<p>其他收件人：</p>
<p>我觉得现有的OpenCL确实非常不成熟，但是从纯性能角度上来讲，我看好Heterogeneous架构，尽管它们的编程难度太大，就像前面提到的不
同架构需要做不同优化等。CPU的性能是latency-oriented，GPU是throughput-oriented,Intel的
Larrabee虽然现在来看不成功，但是业界都在朝着那个方向努力。</p>
<p>On 3月22日, 下午6时18分, windstorm <a href="&#109;&#x61;&#x69;&#108;&#116;&#x6f;&#x3a;&#91;&#108;&#105;&#x6b;&#x75;&#x6e;&#97;&#x72;&#x6d;&#115;&#x74;&#114;&#x2e;&#46;&#46;&#x40;&#x67;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#x6d;&#x5d;&#40;&#x29;">&#91;&#108;&#105;&#x6b;&#x75;&#x6e;&#97;&#x72;&#x6d;&#115;&#x74;&#114;&#x2e;&#46;&#46;&#x40;&#x67;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#x6d;&#x5d;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>实在是不能同意你更多......很早很早以前我就在这里和人争论过，GPU的并行计算平台不可能一统天下的。CUDA也不是救世主。OpenCL更不是。</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Alleluia <a href="&#109;&#x61;&#x69;&#x6c;&#x74;&#111;&#x3a;&#91;&#x61;&#x6c;&#108;&#x75;&#108;&#x2e;&#x2e;&#x2e;&#64;&#103;&#109;&#x61;&#105;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#93;&#40;&#x29;">&#91;&#x61;&#x6c;&#108;&#x75;&#108;&#x2e;&#x2e;&#x2e;&#64;&#103;&#109;&#x61;&#105;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#93;&#40;&#x29;</a>:</p>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>&gt;
&gt;
&gt;</p>
<blockquote>
<blockquote>
<p>Parallelism 说到底是算法问题.Parallelism与Concurrency不同,Concurrency所面对的问题相对的单一可以
让一群有经验的专家来实现一套通用库或者语言来提供一个基本的编程框架.而在Parallelism上,具体的不同问题,其所需要并行的算法是根本不同
的.原因在于不同的问题,其内部的DataDependency的结构完全不同,不同的Data Dependency的结构,需要构造不同的算法.即
便是相同的Data Dependency,在不同的颗粒度下，在不同的硬件条件下所采用的算法也是完全不同的.因为一旦出现Data
Dependency也就意味着并行计算模块之间需要进行通信.从以计算节点为单位的分布式并行,到多核CPU上的Numa结构,到SIMD上的向量处
理器,其计算单元之间的通信手段,通信效率简直天差地别.比如说,在SMP上最常见的并行算法,work stealing也就是Intel的TBB,
是建立在两个条件下第一个是CPU的Cache机制上,这使得通常在内存的之间的数据搬运消耗非常小,第二个是SMP上计算单元相对的少,因此每个计算
单元被分配到的任务就相对的重。其开销远远大于通信的开销,因此这种机制在SMP上相对的划算.但是如果你要在GPU上做Work Stealing就
完全不可行,因为GPU的运算单元数量极多,被分配到的任务就相对来说的非常轻量,CUDA上的一个thread很多时候运算一次的时间不会超过
10us,而一次跨Block的线程之间的通信开销就往往要达到100us左右,再加上目前GPU上的Cache机制非常落后导致了需要频繁的通信开销
的Work Stealing在GPU上是非常不划算得.
所以我个人认为在硬件架构没有更多的突破之前,OpenCL这种东西是没有任何生命力的.不要说CPU的并行与GPU之间差异巨大,就是不同的GPU之
间AMD与Nvidia两个也是各自为政,一个平台上跑得非常快的东西,在另外一个平台极大的可能是龟速.其最终的结果估计就是跟Java的
write once run everywhere一样是个大笑话.</p>
<p>On 3月22日, 下午2时06分, Guancheng Chen <a href="&#109;&#x61;&#x69;&#x6c;&#116;&#x6f;&#x3a;&#91;&#99;&#104;&#101;&#110;&#x67;&#x75;&#x61;&#x6e;&#x63;&#x68;&#46;&#46;&#x2e;&#64;&#x67;&#109;&#x61;&#105;&#x6c;&#x2e;&#99;&#111;&#x6d;&#x5d;&#x28;&#41;">&#91;&#99;&#104;&#101;&#110;&#x67;&#x75;&#x61;&#x6e;&#x63;&#x68;&#46;&#46;&#x2e;&#64;&#x67;&#109;&#x61;&#105;&#x6c;&#x2e;&#99;&#111;&#x6d;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>On 3月22日, 上午2时20分, Tinyfool <a href="&#x6d;&#97;&#105;&#108;&#x74;&#111;&#x3a;&#x5b;&#116;&#105;&#110;&#x79;&#102;&#46;&#x2e;&#x2e;&#64;&#x67;&#109;&#97;&#x69;&#x6c;&#x2e;&#99;&#111;&#x6d;&#93;&#x28;&#x29;">&#x5b;&#116;&#105;&#110;&#x79;&#102;&#46;&#x2e;&#x2e;&#64;&#x67;&#109;&#97;&#x69;&#x6c;&#x2e;&#99;&#111;&#x6d;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#109;&#x61;&#105;&#108;&#116;&#111;&#x3a;&#x5b;&#x6a;&#x65;&#x2e;&#46;&#46;&#x40;&#x6c;&#x69;&#x76;&#101;&#x2e;&#99;&#x6f;&#109;&#93;&#40;&#x29;">&#x5b;&#x6a;&#x65;&#x2e;&#46;&#46;&#x40;&#x6c;&#x69;&#x76;&#101;&#x2e;&#99;&#x6f;&#109;&#93;&#40;&#x29;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#x6d;&#x61;&#105;&#108;&#116;&#111;&#x3a;&#x5b;&#99;&#x68;&#101;&#110;&#x67;&#x75;&#x61;&#x6e;&#99;&#x68;&#x2e;&#46;&#x2e;&#64;&#x67;&#109;&#x61;&#105;&#108;&#46;&#x63;&#111;&#x6d;&#93;&#x28;&#x29;">&#x5b;&#99;&#x68;&#101;&#110;&#x67;&#x75;&#x61;&#x6e;&#99;&#x68;&#x2e;&#46;&#x2e;&#64;&#x67;&#109;&#x61;&#105;&#108;&#46;&#x63;&#111;&#x6d;&#93;&#x28;&#x29;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#109;&#97;&#105;&#x6c;&#x74;&#111;&#58;&#91;&#112;&#111;&#110;&#46;&#x2e;&#46;&#64;&#x67;&#x6f;&#x6f;&#x67;&#x6c;&#x65;&#103;&#x72;&#111;&#117;&#x70;&#x73;&#46;&#x63;&#x6f;&#x6d;&#93;&#40;&#x29;">&#91;&#112;&#111;&#110;&#46;&#x2e;&#46;&#64;&#x67;&#x6f;&#x6f;&#x67;&#x6c;&#x65;&#103;&#x72;&#111;&#117;&#x70;&#x73;&#46;&#x63;&#x6f;&#x6d;&#93;&#40;&#x29;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？...</li>
</ol>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>阅读更多 &gt;&gt;
<a href="">显示删减掉的内容</a>
<img src="" alt=""> windstorm <img src="" alt=""></p>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-23</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>Larrabee当初我还是很看好的，它的架构比其他的更像一个统一的方案，可惜后来Intel自己经验不足搞不好。</p>
<p>OPENCL还是主要面向multimedia吧，CUDA/OpenCL在业界代表了流处理的方向，从GPU针对任务的角度讲是好的。其他的就算了。就像Alleluia说的那样，在硬件架构没有更多的突破之前，不说没有生命力，至少想取得任何进一步的突破都太难。</p>
<p>现在这个领域，你吹你的水，我吹我的水。至于谁的泡泡大，我看不清。所以真要选东西学，最好还是针对自己的application选靠谱。这也是并行编程教育难的问题。大家需求完全不一样。</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p><a href="http://www.kunli.info/" target="_blank">www.kunli.info</a>
<a href="http://twitter.com/cnbuff" target="_blank"><a href="http://twitter.com/cnbuff">http://twitter.com/cnbuff</a></a></p>
<p>2010/3/22 Guancheng Chen <a href="&#109;&#x61;&#105;&#x6c;&#x74;&#111;&#x3a;&#91;&#x63;&#104;&#101;&#x6e;&#x67;&#117;&#x2e;&#46;&#x2e;&#64;&#103;&#109;&#97;&#x69;&#108;&#46;&#x63;&#x6f;&#109;&#x5d;&#x28;&#x29;">&#91;&#x63;&#104;&#101;&#x6e;&#x67;&#117;&#x2e;&#46;&#x2e;&#64;&#103;&#109;&#97;&#x69;&#108;&#46;&#x63;&#x6f;&#109;&#x5d;&#x28;&#x29;</a>:</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<blockquote>
<p>我觉得现有的OpenCL确实非常不成熟，但是从纯性能角度上来讲，我看好Heterogeneous架构，尽管它们的编程难度太大，就像前面提到的不
同架构需要做不同优化等。CPU的性能是latency-oriented，GPU是throughput-oriented,Intel的
Larrabee虽然现在来看不成功，但是业界都在朝着那个方向努力。</p>
<p>On 3月22日, 下午6时18分, windstorm <a href="&#109;&#x61;&#105;&#108;&#116;&#x6f;&#x3a;&#91;&#108;&#x69;&#x6b;&#117;&#x6e;&#97;&#x72;&#x6d;&#115;&#116;&#114;&#46;&#46;&#x2e;&#64;&#103;&#109;&#x61;&#105;&#x6c;&#x2e;&#x63;&#111;&#109;&#93;&#x28;&#41;">&#91;&#108;&#x69;&#x6b;&#117;&#x6e;&#97;&#x72;&#x6d;&#115;&#116;&#114;&#46;&#46;&#x2e;&#64;&#103;&#109;&#x61;&#105;&#x6c;&#x2e;&#x63;&#111;&#109;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>实在是不能同意你更多......很早很早以前我就在这里和人争论过，GPU的并行计算平台不可能一统天下的。CUDA也不是救世主。OpenCL更不是。</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Alleluia <a href="&#x6d;&#x61;&#105;&#x6c;&#116;&#111;&#58;&#91;&#x61;&#108;&#108;&#x75;&#108;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#x63;&#111;&#109;&#93;&#x28;&#41;">&#91;&#x61;&#108;&#108;&#x75;&#108;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#x63;&#111;&#109;&#93;&#x28;&#41;</a>:</p>
<blockquote>
<p>Parallelism 说到底是算法问题.Parallelism与Concurrency不同,Concurrency所面对的问题相对的单一可以
让一群有经验的专家来实现一套通用库或者语言来提供一个基本的编程框架.而在Parallelism上,具体的不同问题,其所需要并行的算法是根本不同
的.原因在于不同的问题,其内部的DataDependency的结构完全不同,不同的Data Dependency的结构,需要构造不同的算法.即
便是相同的Data Dependency,在不同的颗粒度下，在不同的硬件条件下所采用的算法也是完全不同的.因为一旦出现Data
Dependency也就意味着并行计算模块之间需要进行通信.从以计算节点为单位的分布式并行,到多核CPU上的Numa结构,到SIMD上的向量处
理器,其计算单元之间的通信手段,通信效率简直天差地别.比如说,在SMP上最常见的并行算法,work stealing也就是Intel的TBB,
是建立在两个条件下第一个是CPU的Cache机制上,这使得通常在内存的之间的数据搬运消耗非常小,第二个是SMP上计算单元相对的少,因此每个计算
单元被分配到的任务就相对的重。其开销远远大于通信的开销,因此这种机制在SMP上相对的划算.但是如果你要在GPU上做Work Stealing就
完全不可行,因为GPU的运算单元数量极多,被分配到的任务就相对来说的非常轻量,CUDA上的一个thread很多时候运算一次的时间不会超过
10us,而一次跨Block的线程之间的通信开销就往往要达到100us左右,再加上目前GPU上的Cache机制非常落后导致了需要频繁的通信开销
的Work Stealing在GPU上是非常不划算得.
所以我个人认为在硬件架构没有更多的突破之前,OpenCL这种东西是没有任何生命力的.不要说CPU的并行与GPU之间差异巨大,就是不同的GPU之
间AMD与Nvidia两个也是各自为政,一个平台上跑得非常快的东西,在另外一个平台极大的可能是龟速.其最终的结果估计就是跟Java的
write once run everywhere一样是个大笑话.</p>
<p>On 3月22日, 下午2时06分, Guancheng Chen <a href="&#109;&#97;&#105;&#108;&#x74;&#111;&#x3a;&#x5b;&#99;&#104;&#101;&#x6e;&#x67;&#117;&#97;&#110;&#x63;&#x68;&#46;&#x2e;&#46;&#64;&#x67;&#109;&#x61;&#x69;&#108;&#46;&#99;&#x6f;&#109;&#x5d;&#x28;&#41;">&#x5b;&#99;&#104;&#101;&#x6e;&#x67;&#117;&#97;&#110;&#x63;&#x68;&#46;&#x2e;&#46;&#64;&#x67;&#109;&#x61;&#x69;&#108;&#46;&#99;&#x6f;&#109;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>On 3月22日, 上午2时20分, Tinyfool <a href="&#109;&#97;&#x69;&#x6c;&#116;&#x6f;&#x3a;&#x5b;&#x74;&#105;&#x6e;&#121;&#102;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#97;&#105;&#108;&#x2e;&#99;&#x6f;&#x6d;&#93;&#40;&#x29;">&#x5b;&#x74;&#105;&#x6e;&#121;&#102;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#97;&#105;&#108;&#x2e;&#99;&#x6f;&#x6d;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#109;&#x61;&#105;&#108;&#116;&#x6f;&#x3a;&#91;&#x6a;&#x65;&#46;&#46;&#x2e;&#64;&#x6c;&#x69;&#118;&#x65;&#46;&#x63;&#x6f;&#x6d;&#93;&#40;&#x29;">&#91;&#x6a;&#x65;&#46;&#46;&#x2e;&#64;&#x6c;&#x69;&#118;&#x65;&#46;&#x63;&#x6f;&#x6d;&#93;&#40;&#x29;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#x6d;&#97;&#x69;&#108;&#116;&#x6f;&#x3a;&#x5b;&#x63;&#104;&#x65;&#x6e;&#103;&#117;&#97;&#x6e;&#x63;&#104;&#46;&#x2e;&#46;&#x40;&#103;&#x6d;&#x61;&#x69;&#108;&#46;&#x63;&#x6f;&#109;&#x5d;&#x28;&#41;">&#x5b;&#x63;&#104;&#x65;&#x6e;&#103;&#117;&#97;&#x6e;&#x63;&#104;&#46;&#x2e;&#46;&#x40;&#103;&#x6d;&#x61;&#x69;&#108;&#46;&#x63;&#x6f;&#109;&#x5d;&#x28;&#41;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#109;&#x61;&#x69;&#x6c;&#x74;&#111;&#x3a;&#x5b;&#x70;&#x6f;&#110;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#111;&#111;&#x67;&#x6c;&#x65;&#103;&#114;&#x6f;&#x75;&#x70;&#x73;&#x2e;&#x63;&#111;&#x6d;&#93;&#x28;&#41;">&#x5b;&#x70;&#x6f;&#110;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#111;&#111;&#x67;&#x6c;&#x65;&#103;&#114;&#x6f;&#x75;&#x70;&#x73;&#x2e;&#x63;&#111;&#x6d;&#93;&#x28;&#41;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？...</li>
</ol>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>阅读更多 &gt;&gt;</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p><a href="">显示删减掉的内容</a></p>
</blockquote>
<p><img src="" alt=""> Alleluia <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-23</p>
<p>其他收件人：</p>
<p>对于Concurrency和Parallelism之间混乱的根源就是多线程/进程模型.Concurrrency可以用multithread/
process,也可以不用.一个单核单线程的Concurrency程序只要写的好,对于几万个并发连接不是问题.但是Parallelism必须要
用到multithread.对于Concurrency来说,multithread只是一种可选的方案.
当然,在CPU架构上Concurrency和Parallelism的很多设施都是可以复用的,比如高性能的线程池,以及细粒度的锁等等.</p>
<p>On 3月23日, 上午4时32分, windstorm <a href="&#109;&#97;&#105;&#x6c;&#x74;&#x6f;&#x3a;&#91;&#x6c;&#105;&#x6b;&#117;&#x6e;&#x61;&#x72;&#109;&#x73;&#x74;&#114;&#46;&#46;&#x2e;&#x40;&#x67;&#109;&#97;&#x69;&#x6c;&#x2e;&#99;&#111;&#109;&#x5d;&#x28;&#x29;">&#91;&#x6c;&#105;&#x6b;&#117;&#x6e;&#x61;&#x72;&#109;&#x73;&#x74;&#114;&#46;&#46;&#x2e;&#x40;&#x67;&#109;&#97;&#x69;&#x6c;&#x2e;&#99;&#111;&#109;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>我觉得这两个东西，sun的多线程编程手册说得很清楚了，没必要重新定义。</p>
<p>Parallelism is a condition that arises when at least two threads are
executing simultaneously, while concurrency is a condition that exists
when at least two threads are making progress.</p>
<p>也就是说concurrency有点像更通用化，限制条件更低的parallelism，而某些case下两者完全不同。比如单核多线程程序，你可以叫它是co ncurrent
program，但不能叫它是parallel
program。Concurrency在现有体系的处理器架构下都可以做到。和Alleluia说的一样，只是一个时钟周期同步的问题。写过硬件编程的人，几 乎都算是写过concurrent
program，但很少写过parallel program</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>2010/3/22 <a href="">Juv...@gmail.com</a> <a href="&#109;&#x61;&#x69;&#x6c;&#x74;&#111;&#58;&#91;&#106;&#117;&#118;&#46;&#x2e;&#46;&#x40;&#103;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#x29;">&#91;&#106;&#117;&#118;&#46;&#x2e;&#46;&#x40;&#103;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#x29;</a>:</p>
<blockquote>
<p>好像大家说的concurrency和parallelism不是一个东西？</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> Alleluia <img src="" alt=""></p>
</blockquote>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-23</p>
<p>其他收件人：</p>
<p>Heterogeneous目前来看也是一个暂时的过渡性的东西. Heterogeneous架构最大的问题还是硬件,CPU和GPU之间的
PCIE2的bus带宽太窄了.在上面来回传递一次几M的内存可能需要化掉500us左右.如果一个算法本来就是在3-4ms级别的,你要用GPU去优
化,内存带宽的消耗就占了1/10,这是非常可怕的事情.或许像AMD那种Fusion架构是一种趋势,但是目前来说没有太大的进展.貌似AMD出了一
款混合的CPU,但是貌似还没有看到有多大的优势.</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>On 3月23日, 上午5时02分, Guancheng Chen <a href="&#109;&#97;&#x69;&#x6c;&#x74;&#111;&#58;&#x5b;&#99;&#104;&#101;&#x6e;&#x67;&#x75;&#x61;&#110;&#x63;&#104;&#46;&#x2e;&#x2e;&#x40;&#103;&#109;&#x61;&#105;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#93;&#40;&#x29;">&#x5b;&#99;&#104;&#101;&#x6e;&#x67;&#x75;&#x61;&#110;&#x63;&#104;&#46;&#x2e;&#x2e;&#x40;&#103;&#109;&#x61;&#105;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>我觉得现有的OpenCL确实非常不成熟，但是从纯性能角度上来讲，我看好Heterogeneous架构，尽管它们的编程难度太大，就像前面提到的不
同架构需要做不同优化等。CPU的性能是latency-oriented，GPU是throughput-oriented,Intel的
Larrabee虽然现在来看不成功，但是业界都在朝着那个方向努力。</p>
<p>On 3月22日, 下午6时18分, windstorm <a href="&#x6d;&#97;&#105;&#x6c;&#116;&#x6f;&#x3a;&#x5b;&#108;&#x69;&#107;&#x75;&#110;&#97;&#114;&#x6d;&#115;&#116;&#114;&#x2e;&#x2e;&#x2e;&#64;&#103;&#x6d;&#97;&#x69;&#x6c;&#46;&#x63;&#111;&#109;&#x5d;&#x28;&#41;">&#x5b;&#108;&#x69;&#107;&#x75;&#110;&#97;&#114;&#x6d;&#115;&#116;&#114;&#x2e;&#x2e;&#x2e;&#64;&#103;&#x6d;&#97;&#x69;&#x6c;&#46;&#x63;&#111;&#109;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>实在是不能同意你更多......很早很早以前我就在这里和人争论过，GPU的并行计算平台不可能一统天下的。CUDA也不是救世主。OpenCL更不是。</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Alleluia <a href="&#x6d;&#x61;&#105;&#x6c;&#116;&#x6f;&#58;&#91;&#97;&#x6c;&#108;&#x75;&#108;&#46;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#97;&#x69;&#x6c;&#46;&#99;&#111;&#109;&#93;&#x28;&#41;">&#91;&#97;&#x6c;&#108;&#x75;&#108;&#46;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#97;&#x69;&#x6c;&#46;&#99;&#111;&#109;&#93;&#x28;&#41;</a>:</p>
<blockquote>
<p>Parallelism 说到底是算法问题.Parallelism与Concurrency不同,Concurrency所面对的问题相对的单一可以
让一群有经验的专家来实现一套通用库或者语言来提供一个基本的编程框架.而在Parallelism上,具体的不同问题,其所需要并行的算法是根本不同
的.原因在于不同的问题,其内部的DataDependency的结构完全不同,不同的Data Dependency的结构,需要构造不同的算法.即
便是相同的Data Dependency,在不同的颗粒度下，在不同的硬件条件下所采用的算法也是完全不同的.因为一旦出现Data
Dependency也就意味着并行计算模块之间需要进行通信.从以计算节点为单位的分布式并行,到多核CPU上的Numa结构,到SIMD上的向量处
理器,其计算单元之间的通信手段,通信效率简直天差地别.比如说,在SMP上最常见的并行算法,work stealing也就是Intel的TBB,
是建立在两个条件下第一个是CPU的Cache机制上,这使得通常在内存的之间的数据搬运消耗非常小,第二个是SMP上计算单元相对的少,因此每个计算
单元被分配到的任务就相对的重。其开销远远大于通信的开销,因此这种机制在SMP上相对的划算.但是如果你要在GPU上做Work Stealing就
完全不可行,因为GPU的运算单元数量极多,被分配到的任务就相对来说的非常轻量,CUDA上的一个thread很多时候运算一次的时间不会超过
10us,而一次跨Block的线程之间的通信开销就往往要达到100us左右,再加上目前GPU上的Cache机制非常落后导致了需要频繁的通信开销
的Work Stealing在GPU上是非常不划算得.
所以我个人认为在硬件架构没有更多的突破之前,OpenCL这种东西是没有任何生命力的.不要说CPU的并行与GPU之间差异巨大,就是不同的GPU之
间AMD与Nvidia两个也是各自为政,一个平台上跑得非常快的东西,在另外一个平台极大的可能是龟速.其最终的结果估计就是跟Java的
write once run everywhere一样是个大笑话.</p>
<p>On 3月22日, 下午2时06分, Guancheng Chen <a href="&#109;&#x61;&#x69;&#108;&#116;&#111;&#x3a;&#x5b;&#99;&#x68;&#101;&#x6e;&#103;&#x75;&#97;&#x6e;&#x63;&#x68;&#x2e;&#46;&#46;&#x40;&#103;&#109;&#x61;&#105;&#x6c;&#46;&#x63;&#x6f;&#109;&#93;&#x28;&#x29;">&#x5b;&#99;&#x68;&#101;&#x6e;&#103;&#x75;&#97;&#x6e;&#x63;&#x68;&#x2e;&#46;&#46;&#x40;&#103;&#109;&#x61;&#105;&#x6c;&#46;&#x63;&#x6f;&#109;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>On 3月22日, 上午2时20分, Tinyfool <a href="&#x6d;&#97;&#105;&#x6c;&#116;&#x6f;&#x3a;&#91;&#x74;&#x69;&#110;&#x79;&#102;&#x2e;&#x2e;&#46;&#x40;&#x67;&#x6d;&#97;&#x69;&#x6c;&#46;&#99;&#x6f;&#x6d;&#93;&#40;&#x29;">&#91;&#x74;&#x69;&#110;&#x79;&#102;&#x2e;&#x2e;&#46;&#x40;&#x67;&#x6d;&#97;&#x69;&#x6c;&#46;&#99;&#x6f;&#x6d;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#109;&#97;&#x69;&#108;&#x74;&#x6f;&#58;&#91;&#x6a;&#101;&#46;&#46;&#46;&#64;&#x6c;&#x69;&#118;&#x65;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#41;">&#91;&#x6a;&#101;&#46;&#46;&#46;&#64;&#x6c;&#x69;&#118;&#x65;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#41;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#109;&#x61;&#105;&#108;&#116;&#111;&#x3a;&#91;&#99;&#104;&#101;&#110;&#x67;&#x75;&#x61;&#x6e;&#99;&#x68;&#46;&#46;&#46;&#x40;&#x67;&#x6d;&#97;&#x69;&#108;&#x2e;&#99;&#x6f;&#109;&#93;&#40;&#x29;">&#91;&#99;&#104;&#101;&#110;&#x67;&#x75;&#x61;&#x6e;&#99;&#x68;&#46;&#46;&#46;&#x40;&#x67;&#x6d;&#97;&#x69;&#108;&#x2e;&#99;&#x6f;&#109;&#93;&#40;&#x29;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#x6d;&#97;&#x69;&#108;&#x74;&#111;&#58;&#x5b;&#x70;&#111;&#110;&#46;&#x2e;&#46;&#64;&#x67;&#x6f;&#x6f;&#103;&#x6c;&#x65;&#x67;&#114;&#111;&#117;&#x70;&#x73;&#x2e;&#99;&#x6f;&#109;&#93;&#x28;&#x29;">&#x5b;&#x70;&#111;&#110;&#46;&#x2e;&#46;&#64;&#x67;&#x6f;&#x6f;&#103;&#x6c;&#x65;&#x67;&#114;&#111;&#117;&#x70;&#x73;&#x2e;&#99;&#x6f;&#109;&#93;&#x28;&#x29;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>...</p>
<p>阅读更多 &gt;&gt;
<a href="">显示删减掉的内容</a></p>
</blockquote>
<p><img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-23</p>
<p>其他收件人：</p>
<p>恩 您也是搞体系结构的么？
现在我在跟瑞典这边的爱立信合作做毕设 不过对象不是他们的Erlang 而是传统的C/C++程序 下半年可能我也去搞GPGPU了 因为它的
data parallel模型对遗留代码的并行化很有搞头，现在我粗略的想法是把Compute sensitive的任务放一部分到GPU上去做，
当然我也对GPU目前的一些限制有所了解 但是一些探索工作还是非常值得的 到时候还想向前辈多多请教</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>On 3月22日, 下午11时30分, Alleluia <a href="&#x6d;&#97;&#105;&#108;&#116;&#111;&#58;&#x5b;&#x61;&#108;&#108;&#117;&#108;&#46;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#105;&#108;&#x2e;&#99;&#111;&#x6d;&#93;&#x28;&#x29;">&#x5b;&#x61;&#108;&#108;&#117;&#108;&#46;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#105;&#108;&#x2e;&#99;&#111;&#x6d;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>Heterogeneous目前来看也是一个暂时的过渡性的东西. Heterogeneous架构最大的问题还是硬件,CPU和GPU之间的
PCIE2的bus带宽太窄了.在上面来回传递一次几M的内存可能需要化掉500us左右.如果一个算法本来就是在3-4ms级别的,你要用GPU去优
化,内存带宽的消耗就占了1/10,这是非常可怕的事情.或许像AMD那种Fusion架构是一种趋势,但是目前来说没有太大的进展.貌似AMD出了一
款混合的CPU,但是貌似还没有看到有多大的优势.
On 3月23日, 上午5时02分, Guancheng Chen <a href="&#x6d;&#97;&#105;&#108;&#x74;&#x6f;&#58;&#91;&#99;&#x68;&#101;&#x6e;&#x67;&#x75;&#97;&#110;&#99;&#104;&#46;&#x2e;&#46;&#x40;&#x67;&#x6d;&#x61;&#x69;&#108;&#x2e;&#99;&#111;&#109;&#93;&#x28;&#41;">&#91;&#99;&#x68;&#101;&#x6e;&#x67;&#x75;&#97;&#110;&#99;&#104;&#46;&#x2e;&#46;&#x40;&#x67;&#x6d;&#x61;&#x69;&#108;&#x2e;&#99;&#111;&#109;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>我觉得现有的OpenCL确实非常不成熟，但是从纯性能角度上来讲，我看好Heterogeneous架构，尽管它们的编程难度太大，就像前面提到的不
同架构需要做不同优化等。CPU的性能是latency-oriented，GPU是throughput-oriented,Intel的
Larrabee虽然现在来看不成功，但是业界都在朝着那个方向努力。</p>
<p>On 3月22日, 下午6时18分, windstorm <a href="&#109;&#97;&#x69;&#x6c;&#x74;&#111;&#58;&#91;&#108;&#x69;&#107;&#117;&#110;&#x61;&#114;&#x6d;&#115;&#x74;&#114;&#46;&#46;&#x2e;&#x40;&#x67;&#109;&#97;&#x69;&#108;&#x2e;&#99;&#111;&#x6d;&#x5d;&#x28;&#x29;">&#91;&#108;&#x69;&#107;&#117;&#110;&#x61;&#114;&#x6d;&#115;&#x74;&#114;&#46;&#46;&#x2e;&#x40;&#x67;&#109;&#97;&#x69;&#108;&#x2e;&#99;&#111;&#x6d;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>实在是不能同意你更多......很早很早以前我就在这里和人争论过，GPU的并行计算平台不可能一统天下的。CUDA也不是救世主。OpenCL更不是。</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Alleluia <a href="&#109;&#97;&#x69;&#108;&#116;&#111;&#x3a;&#91;&#x61;&#x6c;&#108;&#x75;&#x6c;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#109;&#x61;&#x69;&#108;&#x2e;&#x63;&#111;&#109;&#93;&#x28;&#x29;">&#91;&#x61;&#x6c;&#108;&#x75;&#x6c;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#109;&#x61;&#x69;&#108;&#x2e;&#x63;&#111;&#109;&#93;&#x28;&#x29;</a>:</p>
<blockquote>
<p>Parallelism 说到底是算法问题.Parallelism与Concurrency不同,Concurrency所面对的问题相对的单一可以
让一群有经验的专家来实现一套通用库或者语言来提供一个基本的编程框架.而在Parallelism上,具体的不同问题,其所需要并行的算法是根本不同
的.原因在于不同的问题,其内部的DataDependency的结构完全不同,不同的Data Dependency的结构,需要构造不同的算法.即
便是相同的Data Dependency,在不同的颗粒度下，在不同的硬件条件下所采用的算法也是完全不同的.因为一旦出现Data
Dependency也就意味着并行计算模块之间需要进行通信.从以计算节点为单位的分布式并行,到多核CPU上的Numa结构,到SIMD上的向量处
理器,其计算单元之间的通信手段,通信效率简直天差地别.比如说,在SMP上最常见的并行算法,work stealing也就是Intel的TBB,
是建立在两个条件下第一个是CPU的Cache机制上,这使得通常在内存的之间的数据搬运消耗非常小,第二个是SMP上计算单元相对的少,因此每个计算
单元被分配到的任务就相对的重。其开销远远大于通信的开销,因此这种机制在SMP上相对的划算.但是如果你要在GPU上做Work Stealing就
完全不可行,因为GPU的运算单元数量极多,被分配到的任务就相对来说的非常轻量,CUDA上的一个thread很多时候运算一次的时间不会超过
10us,而一次跨Block的线程之间的通信开销就往往要达到100us左右,再加上目前GPU上的Cache机制非常落后导致了需要频繁的通信开销
的Work Stealing在GPU上是非常不划算得.
所以我个人认为在硬件架构没有更多的突破之前,OpenCL这种东西是没有任何生命力的.不要说CPU的并行与GPU之间差异巨大,就是不同的GPU之
间AMD与Nvidia两个也是各自为政,一个平台上跑得非常快的东西,在另外一个平台极大的可能是龟速.其最终的结果估计就是跟Java的
write once run everywhere一样是个大笑话.</p>
<p>On 3月22日, 下午2时06分, Guancheng Chen <a href="&#109;&#97;&#105;&#108;&#x74;&#111;&#x3a;&#x5b;&#99;&#104;&#x65;&#x6e;&#103;&#117;&#x61;&#110;&#99;&#104;&#x2e;&#x2e;&#46;&#x40;&#x67;&#109;&#x61;&#105;&#108;&#x2e;&#99;&#x6f;&#x6d;&#93;&#x28;&#41;">&#x5b;&#99;&#104;&#x65;&#x6e;&#103;&#117;&#x61;&#110;&#99;&#104;&#x2e;&#x2e;&#46;&#x40;&#x67;&#109;&#x61;&#105;&#108;&#x2e;&#99;&#x6f;&#x6d;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>On 3月22日, 上午2时20分, Tinyfool <a href="&#x6d;&#x61;&#105;&#108;&#116;&#111;&#58;&#91;&#x74;&#105;&#110;&#121;&#102;&#46;&#x2e;&#x2e;&#64;&#103;&#109;&#97;&#105;&#x6c;&#x2e;&#99;&#111;&#x6d;&#x5d;&#x28;&#41;">&#91;&#x74;&#105;&#110;&#121;&#102;&#46;&#x2e;&#x2e;&#64;&#103;&#109;&#97;&#105;&#x6c;&#x2e;&#99;&#111;&#x6d;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#109;&#97;&#x69;&#x6c;&#116;&#x6f;&#58;&#x5b;&#x6a;&#x65;&#x2e;&#46;&#x2e;&#64;&#x6c;&#105;&#x76;&#x65;&#46;&#x63;&#x6f;&#x6d;&#93;&#x28;&#x29;">&#x5b;&#x6a;&#x65;&#x2e;&#46;&#x2e;&#64;&#x6c;&#105;&#x76;&#x65;&#46;&#x63;&#x6f;&#x6d;&#93;&#x28;&#x29;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#x6d;&#x61;&#105;&#108;&#116;&#x6f;&#58;&#x5b;&#99;&#x68;&#x65;&#110;&#x67;&#117;&#x61;&#110;&#x63;&#x68;&#46;&#x2e;&#46;&#64;&#103;&#109;&#97;&#x69;&#108;&#46;&#99;&#111;&#109;&#x5d;&#40;&#x29;">&#x5b;&#99;&#x68;&#x65;&#110;&#x67;&#117;&#x61;&#110;&#x63;&#x68;&#46;&#x2e;&#46;&#64;&#103;&#109;&#97;&#x69;&#108;&#46;&#99;&#111;&#109;&#x5d;&#40;&#x29;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#109;&#x61;&#x69;&#108;&#116;&#111;&#58;&#x5b;&#112;&#x6f;&#x6e;&#46;&#46;&#x2e;&#x40;&#x67;&#x6f;&#x6f;&#x67;&#108;&#101;&#103;&#x72;&#x6f;&#x75;&#x70;&#115;&#x2e;&#x63;&#111;&#x6d;&#93;&#x28;&#41;">&#x5b;&#112;&#x6f;&#x6e;&#46;&#46;&#x2e;&#x40;&#x67;&#x6f;&#x6f;&#x67;&#108;&#101;&#103;&#x72;&#x6f;&#x75;&#x70;&#115;&#x2e;&#x63;&#111;&#x6d;&#93;&#x28;&#41;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。...</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>阅读更多 &gt;&gt;
<a href="">显示删减掉的内容</a>
<img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-23</p>
<p>其他收件人：</p>
<p>教育以人为本，最终决定使用何种并行技术的还是程序员。目前业界对程序员并没有并行编程的技能要求，全民并行编程的时代什么时候才能到来？这是个问
题。</p>
<p>On 3月22日, 下午10时41分, windstorm <a href="&#109;&#97;&#x69;&#108;&#x74;&#x6f;&#58;&#x5b;&#x6c;&#x69;&#x6b;&#117;&#110;&#x61;&#x72;&#x6d;&#115;&#116;&#114;&#46;&#x2e;&#46;&#x40;&#x67;&#x6d;&#97;&#105;&#x6c;&#46;&#99;&#x6f;&#x6d;&#93;&#40;&#41;">&#x5b;&#x6c;&#x69;&#x6b;&#117;&#110;&#x61;&#x72;&#x6d;&#115;&#116;&#114;&#46;&#x2e;&#46;&#x40;&#x67;&#x6d;&#97;&#105;&#x6c;&#46;&#99;&#x6f;&#x6d;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>Larrabee当初我还是很看好的，它的架构比其他的更像一个统一的方案，可惜后来Intel自己经验不足搞不好。</p>
<p>OPENCL还是主要面向multimedia吧，CUDA/OpenCL在业界代表了流处理的方向，从GPU针对任务的角度讲是好的。其他的就算了。就像Al leluia说的那样，在硬件架构没有更多的突破之前，不说没有生命力，至少想取得任何进一步的突破都太难。</p>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>现在这个领域，你吹你的水，我吹我的水。至于谁的泡泡大，我看不清。所以真要选东西学，最好还是针对自己的application选靠谱。这也是并行编程教育难 的问题。大家需求完全不一样。</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Guancheng Chen <a href="&#x6d;&#97;&#105;&#108;&#x74;&#111;&#58;&#x5b;&#99;&#104;&#x65;&#x6e;&#103;&#x75;&#x61;&#110;&#99;&#104;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#109;&#97;&#105;&#108;&#x2e;&#99;&#x6f;&#109;&#93;&#x28;&#41;">&#x5b;&#99;&#104;&#x65;&#x6e;&#103;&#x75;&#x61;&#110;&#99;&#104;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#109;&#97;&#105;&#108;&#x2e;&#99;&#x6f;&#109;&#93;&#x28;&#41;</a>:</p>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>&gt;
&gt;
&gt;</p>
<blockquote>
<blockquote>
<p>我觉得现有的OpenCL确实非常不成熟，但是从纯性能角度上来讲，我看好Heterogeneous架构，尽管它们的编程难度太大，就像前面提到的不
同架构需要做不同优化等。CPU的性能是latency-oriented，GPU是throughput-oriented,Intel的
Larrabee虽然现在来看不成功，但是业界都在朝着那个方向努力。</p>
<p>On 3月22日, 下午6时18分, windstorm <a href="&#x6d;&#x61;&#105;&#108;&#116;&#111;&#x3a;&#91;&#108;&#105;&#x6b;&#117;&#x6e;&#x61;&#x72;&#109;&#115;&#116;&#114;&#46;&#x2e;&#x2e;&#64;&#103;&#x6d;&#x61;&#x69;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#93;&#40;&#x29;">&#91;&#108;&#105;&#x6b;&#117;&#x6e;&#x61;&#x72;&#109;&#115;&#116;&#114;&#46;&#x2e;&#x2e;&#64;&#103;&#x6d;&#x61;&#x69;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>实在是不能同意你更多......很早很早以前我就在这里和人争论过，GPU的并行计算平台不可能一统天下的。CUDA也不是救世主。OpenCL更不是。</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Alleluia <a href="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#x6f;&#x3a;&#91;&#97;&#108;&#x6c;&#x75;&#108;&#46;&#46;&#46;&#64;&#x67;&#109;&#97;&#105;&#108;&#x2e;&#99;&#111;&#x6d;&#x5d;&#40;&#x29;">&#91;&#97;&#108;&#x6c;&#x75;&#108;&#46;&#46;&#46;&#64;&#x67;&#109;&#97;&#105;&#108;&#x2e;&#99;&#111;&#x6d;&#x5d;&#40;&#x29;</a>:</p>
<blockquote>
<p>Parallelism 说到底是算法问题.Parallelism与Concurrency不同,Concurrency所面对的问题相对的单一可以
让一群有经验的专家来实现一套通用库或者语言来提供一个基本的编程框架.而在Parallelism上,具体的不同问题,其所需要并行的算法是根本不同
的.原因在于不同的问题,其内部的DataDependency的结构完全不同,不同的Data Dependency的结构,需要构造不同的算法.即
便是相同的Data Dependency,在不同的颗粒度下，在不同的硬件条件下所采用的算法也是完全不同的.因为一旦出现Data
Dependency也就意味着并行计算模块之间需要进行通信.从以计算节点为单位的分布式并行,到多核CPU上的Numa结构,到SIMD上的向量处
理器,其计算单元之间的通信手段,通信效率简直天差地别.比如说,在SMP上最常见的并行算法,work stealing也就是Intel的TBB,
是建立在两个条件下第一个是CPU的Cache机制上,这使得通常在内存的之间的数据搬运消耗非常小,第二个是SMP上计算单元相对的少,因此每个计算
单元被分配到的任务就相对的重。其开销远远大于通信的开销,因此这种机制在SMP上相对的划算.但是如果你要在GPU上做Work Stealing就
完全不可行,因为GPU的运算单元数量极多,被分配到的任务就相对来说的非常轻量,CUDA上的一个thread很多时候运算一次的时间不会超过
10us,而一次跨Block的线程之间的通信开销就往往要达到100us左右,再加上目前GPU上的Cache机制非常落后导致了需要频繁的通信开销
的Work Stealing在GPU上是非常不划算得.
所以我个人认为在硬件架构没有更多的突破之前,OpenCL这种东西是没有任何生命力的.不要说CPU的并行与GPU之间差异巨大,就是不同的GPU之
间AMD与Nvidia两个也是各自为政,一个平台上跑得非常快的东西,在另外一个平台极大的可能是龟速.其最终的结果估计就是跟Java的
write once run everywhere一样是个大笑话.</p>
<p>On 3月22日, 下午2时06分, Guancheng Chen <a href="&#x6d;&#97;&#105;&#x6c;&#116;&#x6f;&#58;&#x5b;&#99;&#x68;&#101;&#x6e;&#103;&#117;&#97;&#110;&#99;&#x68;&#x2e;&#x2e;&#46;&#x40;&#x67;&#109;&#97;&#x69;&#x6c;&#46;&#99;&#111;&#109;&#x5d;&#x28;&#41;">&#x5b;&#99;&#x68;&#101;&#x6e;&#103;&#117;&#97;&#110;&#99;&#x68;&#x2e;&#x2e;&#46;&#x40;&#x67;&#109;&#97;&#x69;&#x6c;&#46;&#99;&#111;&#109;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>On 3月22日, 上午2时20分, Tinyfool <a href="&#x6d;&#x61;&#x69;&#108;&#116;&#x6f;&#x3a;&#x5b;&#x74;&#105;&#x6e;&#121;&#102;&#46;&#x2e;&#46;&#64;&#x67;&#109;&#97;&#105;&#x6c;&#46;&#x63;&#x6f;&#109;&#x5d;&#40;&#41;">&#x5b;&#x74;&#105;&#x6e;&#121;&#102;&#46;&#x2e;&#46;&#64;&#x67;&#109;&#97;&#105;&#x6c;&#46;&#x63;&#x6f;&#109;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#109;&#x61;&#x69;&#x6c;&#x74;&#111;&#58;&#91;&#106;&#x65;&#46;&#x2e;&#46;&#x40;&#x6c;&#105;&#x76;&#x65;&#x2e;&#99;&#x6f;&#109;&#93;&#x28;&#41;">&#91;&#106;&#x65;&#46;&#x2e;&#46;&#x40;&#x6c;&#105;&#x76;&#x65;&#x2e;&#99;&#x6f;&#109;&#93;&#x28;&#41;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#109;&#97;&#x69;&#108;&#x74;&#111;&#x3a;&#91;&#x63;&#x68;&#101;&#x6e;&#103;&#x75;&#x61;&#110;&#99;&#104;&#x2e;&#46;&#x2e;&#x40;&#x67;&#109;&#97;&#x69;&#108;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#40;&#x29;">&#91;&#x63;&#x68;&#101;&#x6e;&#103;&#x75;&#x61;&#110;&#99;&#104;&#x2e;&#46;&#x2e;&#x40;&#x67;&#109;&#97;&#x69;&#108;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#40;&#x29;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#x6d;&#x61;&#105;&#108;&#x74;&#111;&#58;&#x5b;&#x70;&#111;&#110;&#x2e;&#46;&#x2e;&#64;&#103;&#111;&#111;&#103;&#108;&#101;&#103;&#x72;&#x6f;&#117;&#112;&#115;&#46;&#99;&#x6f;&#x6d;&#x5d;&#40;&#41;">&#x5b;&#x70;&#111;&#110;&#x2e;&#46;&#x2e;&#64;&#103;&#111;&#111;&#103;&#108;&#101;&#103;&#x72;&#x6f;&#117;&#112;&#115;&#46;&#99;&#x6f;&#x6d;&#x5d;&#40;&#41;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线...</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>阅读更多 &gt;&gt;
<a href="">显示删减掉的内容</a></p>
</blockquote>
<p><img src="" alt=""> windstorm <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-23</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>全民并行编程的时代，只有在全民能够并行编程的时候才会到来嘛，现在不是这个时候</p>
<p>我个人倾向于等待一个比较好的统一性架构。两条路：</p>
<p>一是某一个全新概念的提出，这个要看学术界的努力，而且在某种意义上讲，学术界搞出一个真正可行的并行架构的可能性比工业界更高。虽说今天多核的发展是工业界引领的，但是点子还是最早学术界提出的。典型的有几个：斯坦福的Hydra（1996），斯坦福的Imagine(2000)，MIT的RAW（2002），以及UT奥斯丁的TRIPS（2003）。在这个问题上，是不得不佩服美国的创造力，要知道直到在2000年左右，所有的人都还在为处理器频率按照摩尔定律翻翻而狂热，美国的顶尖研究员就早已看到了这条路的尽头并指出未来处理器的发展之路。</p>
<p>二是你用现有的架构，但是application引导。如果要找一个面向多application
domain的话，刚才说了，本来看好Larrabee，因为它的架构解决了CUDA一个很大的潜在问题，而且允许现有程序员不经过任何特殊training就上手编程，包括图形图像，科学计算，或者网络处理，各个领域。</p>
<p>不过可能就是因为这个solution的过于理想化导致结构的过于复杂化，才让其目前暂时流产。</p>
<p>总的来说，现在的问题就是软件发展不成熟，硬件发展不完善，你没法靠程序员决定使用什么并行技术，完全靠应用主导，这套技术在这个应用上如鱼得水，在那个应用上完全不罩，作为程序员，有什么办法？</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p><a href="http://www.kunli.info/" target="_blank">www.kunli.info</a>
<a href="http://twitter.com/cnbuff" target="_blank"><a href="http://twitter.com/cnbuff">http://twitter.com/cnbuff</a></a></p>
<p>2010/3/22 Guancheng Chen <a href="&#x6d;&#x61;&#x69;&#108;&#x74;&#111;&#x3a;&#91;&#x63;&#104;&#x65;&#x6e;&#x67;&#x75;&#46;&#46;&#x2e;&#64;&#103;&#109;&#x61;&#105;&#x6c;&#x2e;&#99;&#111;&#109;&#x5d;&#x28;&#41;">&#91;&#x63;&#104;&#x65;&#x6e;&#x67;&#x75;&#46;&#46;&#x2e;&#64;&#103;&#109;&#x61;&#105;&#x6c;&#x2e;&#99;&#111;&#109;&#x5d;&#x28;&#41;</a>:</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<blockquote>
<p>教育以人为本，最终决定使用何种并行技术的还是程序员。目前业界对程序员并没有并行编程的技能要求，全民并行编程的时代什么时候才能到来？这是个问
题。</p>
<p>On 3月22日, 下午10时41分, windstorm <a href="&#x6d;&#97;&#105;&#108;&#116;&#111;&#58;&#91;&#108;&#105;&#x6b;&#117;&#x6e;&#97;&#x72;&#x6d;&#115;&#x74;&#114;&#x2e;&#46;&#x2e;&#64;&#103;&#109;&#97;&#x69;&#x6c;&#x2e;&#99;&#111;&#109;&#93;&#40;&#41;">&#91;&#108;&#105;&#x6b;&#117;&#x6e;&#97;&#x72;&#x6d;&#115;&#x74;&#114;&#x2e;&#46;&#x2e;&#64;&#103;&#109;&#97;&#x69;&#x6c;&#x2e;&#99;&#111;&#109;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>Larrabee当初我还是很看好的，它的架构比其他的更像一个统一的方案，可惜后来Intel自己经验不足搞不好。</p>
<p>OPENCL还是主要面向multimedia吧，CUDA/OpenCL在业界代表了流处理的方向，从GPU针对任务的角度讲是好的。其他的就算了。就像Al leluia说的那样，在硬件架构没有更多的突破之前，不说没有生命力，至少想取得任何进一步的突破都太难。</p>
<p>现在这个领域，你吹你的水，我吹我的水。至于谁的泡泡大，我看不清。所以真要选东西学，最好还是针对自己的application选靠谱。这也是并行编程教育难 的问题。大家需求完全不一样。</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Guancheng Chen <a href="&#109;&#97;&#x69;&#108;&#116;&#x6f;&#x3a;&#x5b;&#99;&#x68;&#x65;&#110;&#x67;&#117;&#97;&#x6e;&#x63;&#x68;&#46;&#x2e;&#46;&#x40;&#x67;&#109;&#97;&#105;&#x6c;&#x2e;&#99;&#111;&#109;&#x5d;&#x28;&#41;">&#x5b;&#99;&#x68;&#x65;&#110;&#x67;&#117;&#97;&#x6e;&#x63;&#x68;&#46;&#x2e;&#46;&#x40;&#x67;&#109;&#97;&#105;&#x6c;&#x2e;&#99;&#111;&#109;&#x5d;&#x28;&#41;</a>:</p>
<blockquote>
<p>我觉得现有的OpenCL确实非常不成熟，但是从纯性能角度上来讲，我看好Heterogeneous架构，尽管它们的编程难度太大，就像前面提到的不
同架构需要做不同优化等。CPU的性能是latency-oriented，GPU是throughput-oriented,Intel的
Larrabee虽然现在来看不成功，但是业界都在朝着那个方向努力。</p>
<p>On 3月22日, 下午6时18分, windstorm <a href="&#x6d;&#97;&#105;&#108;&#x74;&#111;&#58;&#x5b;&#x6c;&#105;&#107;&#117;&#x6e;&#x61;&#114;&#x6d;&#115;&#x74;&#114;&#x2e;&#46;&#x2e;&#64;&#x67;&#109;&#97;&#105;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#93;&#x28;&#x29;">&#x5b;&#x6c;&#105;&#107;&#117;&#x6e;&#x61;&#114;&#x6d;&#115;&#x74;&#114;&#x2e;&#46;&#x2e;&#64;&#x67;&#109;&#97;&#105;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>实在是不能同意你更多......很早很早以前我就在这里和人争论过，GPU的并行计算平台不可能一统天下的。CUDA也不是救世主。OpenCL更不是。</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Alleluia <a href="&#109;&#x61;&#105;&#108;&#116;&#111;&#x3a;&#91;&#97;&#x6c;&#x6c;&#117;&#x6c;&#x2e;&#x2e;&#46;&#x40;&#103;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#41;">&#91;&#97;&#x6c;&#x6c;&#117;&#x6c;&#x2e;&#x2e;&#46;&#x40;&#103;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#41;</a>:</p>
<blockquote>
<p>Parallelism 说到底是算法问题.Parallelism与Concurrency不同,Concurrency所面对的问题相对的单一可以
让一群有经验的专家来实现一套通用库或者语言来提供一个基本的编程框架.而在Parallelism上,具体的不同问题,其所需要并行的算法是根本不同
的.原因在于不同的问题,其内部的DataDependency的结构完全不同,不同的Data Dependency的结构,需要构造不同的算法.即
便是相同的Data Dependency,在不同的颗粒度下，在不同的硬件条件下所采用的算法也是完全不同的.因为一旦出现Data
Dependency也就意味着并行计算模块之间需要进行通信.从以计算节点为单位的分布式并行,到多核CPU上的Numa结构,到SIMD上的向量处
理器,其计算单元之间的通信手段,通信效率简直天差地别.比如说,在SMP上最常见的并行算法,work stealing也就是Intel的TBB,
是建立在两个条件下第一个是CPU的Cache机制上,这使得通常在内存的之间的数据搬运消耗非常小,第二个是SMP上计算单元相对的少,因此每个计算
单元被分配到的任务就相对的重。其开销远远大于通信的开销,因此这种机制在SMP上相对的划算.但是如果你要在GPU上做Work Stealing就
完全不可行,因为GPU的运算单元数量极多,被分配到的任务就相对来说的非常轻量,CUDA上的一个thread很多时候运算一次的时间不会超过
10us,而一次跨Block的线程之间的通信开销就往往要达到100us左右,再加上目前GPU上的Cache机制非常落后导致了需要频繁的通信开销
的Work Stealing在GPU上是非常不划算得.
所以我个人认为在硬件架构没有更多的突破之前,OpenCL这种东西是没有任何生命力的.不要说CPU的并行与GPU之间差异巨大,就是不同的GPU之
间AMD与Nvidia两个也是各自为政,一个平台上跑得非常快的东西,在另外一个平台极大的可能是龟速.其最终的结果估计就是跟Java的
write once run everywhere一样是个大笑话.</p>
<p>On 3月22日, 下午2时06分, Guancheng Chen <a href="&#x6d;&#x61;&#x69;&#108;&#x74;&#111;&#58;&#x5b;&#99;&#104;&#x65;&#110;&#x67;&#117;&#97;&#110;&#99;&#104;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#40;&#x29;">&#x5b;&#99;&#104;&#x65;&#110;&#x67;&#117;&#97;&#110;&#99;&#104;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>On 3月22日, 上午2时20分, Tinyfool <a href="&#x6d;&#x61;&#105;&#x6c;&#116;&#111;&#x3a;&#91;&#x74;&#x69;&#110;&#121;&#102;&#x2e;&#x2e;&#46;&#64;&#103;&#x6d;&#x61;&#x69;&#108;&#x2e;&#99;&#x6f;&#109;&#x5d;&#40;&#41;">&#91;&#x74;&#x69;&#110;&#121;&#102;&#x2e;&#x2e;&#46;&#64;&#103;&#x6d;&#x61;&#x69;&#108;&#x2e;&#99;&#x6f;&#109;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#x6d;&#x61;&#x69;&#x6c;&#116;&#111;&#58;&#91;&#x6a;&#101;&#46;&#x2e;&#46;&#64;&#x6c;&#x69;&#118;&#101;&#x2e;&#99;&#111;&#x6d;&#93;&#40;&#41;">&#91;&#x6a;&#101;&#46;&#x2e;&#46;&#64;&#x6c;&#x69;&#118;&#101;&#x2e;&#99;&#111;&#x6d;&#93;&#40;&#41;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#x6d;&#97;&#105;&#108;&#x74;&#x6f;&#58;&#91;&#x63;&#x68;&#x65;&#110;&#x67;&#x75;&#x61;&#x6e;&#99;&#x68;&#x2e;&#46;&#x2e;&#x40;&#103;&#109;&#97;&#x69;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#41;">&#91;&#x63;&#x68;&#x65;&#110;&#x67;&#x75;&#x61;&#x6e;&#99;&#x68;&#x2e;&#46;&#x2e;&#x40;&#103;&#109;&#97;&#x69;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#41;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#x6d;&#97;&#105;&#x6c;&#116;&#x6f;&#x3a;&#x5b;&#x70;&#111;&#110;&#46;&#x2e;&#x2e;&#64;&#103;&#111;&#x6f;&#x67;&#x6c;&#x65;&#103;&#x72;&#x6f;&#x75;&#112;&#x73;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#x28;&#x29;">&#x5b;&#x70;&#111;&#110;&#46;&#x2e;&#x2e;&#64;&#103;&#111;&#x6f;&#x67;&#x6c;&#x65;&#103;&#x72;&#x6f;&#x75;&#112;&#x73;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#x28;&#x29;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线...</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>阅读更多 &gt;&gt;</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p><a href="">显示删减掉的内容</a>
<img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-23</p>
<p>其他收件人：</p>
<p>恩</p>
<p>第二点其实我就是指程序员根据他自己的程序领域选择合适的并行技术。Top Language真是藏龙卧虎啊。你是在Boulder么?我一个大学女同
学在你那读MIS的phd</p>
<p>On 3月23日, 上午12时04分, windstorm <a href="&#x6d;&#x61;&#105;&#108;&#x74;&#x6f;&#58;&#x5b;&#x6c;&#105;&#x6b;&#117;&#110;&#x61;&#x72;&#x6d;&#x73;&#116;&#114;&#x2e;&#x2e;&#46;&#64;&#103;&#109;&#97;&#x69;&#108;&#46;&#x63;&#111;&#109;&#93;&#40;&#x29;">&#x5b;&#x6c;&#105;&#x6b;&#117;&#110;&#x61;&#x72;&#x6d;&#x73;&#116;&#114;&#x2e;&#x2e;&#46;&#64;&#103;&#109;&#97;&#x69;&#108;&#46;&#x63;&#111;&#109;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>全民并行编程的时代，只有在全民能够并行编程的时候才会到来嘛，现在不是这个时候</p>
<p>我个人倾向于等待一个比较好的统一性架构。两条路：</p>
<p>一是某一个全新概念的提出，这个要看学术界的努力，而且在某种意义上讲，学术界搞出一个真正可行的并行架构的可能性比工业界更高。虽说今天多核的发展是工业界引 领的，但是点子还是最早学术界提出的。典型的有几个：斯坦福的Hydra（1996），斯坦福的Imagine(2000)，MIT的RAW（2002），以及 UT奥斯丁的TRIPS（2003）。在这个问题上，是不得不佩服美国的创造力，要知道直到在2000年左右，所有的人都还在为处理器频率按照摩尔定律翻翻而狂 热，美国的顶尖研究员就早已看到了这条路的尽头并指出未来处理器的发展之路。</p>
<p>二是你用现有的架构，但是application引导。如果要找一个面向多application
domain的话，刚才说了，本来看好Larrabee，因为它的架构解决了CUDA一个很大的潜在问题，而且允许现有程序员不经过任何特殊training就 上手编程，包括图形图像，科学计算，或者网络处理，各个领域。</p>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>不过可能就是因为这个solution的过于理想化导致结构的过于复杂化，才让其目前暂时流产。</p>
<p>总的来说，现在的问题就是软件发展不成熟，硬件发展不完善，你没法靠程序员决定使用什么并行技术，完全靠应用主导，这套技术在这个应用上如鱼得水，在那个应用上 完全不罩，作为程序员，有什么办法？</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Guancheng Chen <a href="&#x6d;&#97;&#x69;&#x6c;&#116;&#111;&#58;&#91;&#x63;&#104;&#101;&#110;&#x67;&#117;&#x61;&#110;&#x63;&#104;&#x2e;&#x2e;&#46;&#x40;&#103;&#x6d;&#x61;&#105;&#x6c;&#46;&#x63;&#111;&#109;&#x5d;&#40;&#41;">&#91;&#x63;&#104;&#101;&#110;&#x67;&#117;&#x61;&#110;&#x63;&#104;&#x2e;&#x2e;&#46;&#x40;&#103;&#x6d;&#x61;&#105;&#x6c;&#46;&#x63;&#111;&#109;&#x5d;&#40;&#41;</a>:</p>
<blockquote>
<p>教育以人为本，最终决定使用何种并行技术的还是程序员。目前业界对程序员并没有并行编程的技能要求，全民并行编程的时代什么时候才能到来？这是个问
题。</p>
<p>On 3月22日, 下午10时41分, windstorm <a href="&#109;&#97;&#105;&#108;&#116;&#x6f;&#x3a;&#x5b;&#x6c;&#x69;&#107;&#117;&#110;&#x61;&#x72;&#109;&#x73;&#x74;&#x72;&#46;&#46;&#x2e;&#64;&#x67;&#109;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#x28;&#x29;">&#x5b;&#x6c;&#x69;&#107;&#117;&#110;&#x61;&#x72;&#109;&#x73;&#x74;&#x72;&#46;&#46;&#x2e;&#64;&#x67;&#109;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>Larrabee当初我还是很看好的，它的架构比其他的更像一个统一的方案，可惜后来Intel自己经验不足搞不好。</p>
<p>OPENCL还是主要面向multimedia吧，CUDA/OpenCL在业界代表了流处理的方向，从GPU针对任务的角度讲是好的。其他的就算了。就像Al leluia说的那样，在硬件架构没有更多的突破之前，不说没有生命力，至少想取得任何进一步的突破都太难。</p>
<p>现在这个领域，你吹你的水，我吹我的水。至于谁的泡泡大，我看不清。所以真要选东西学，最好还是针对自己的application选靠谱。这也是并行编程教育难 的问题。大家需求完全不一样。</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Guancheng Chen <a href="&#109;&#97;&#105;&#x6c;&#x74;&#111;&#x3a;&#x5b;&#x63;&#x68;&#x65;&#x6e;&#x67;&#x75;&#97;&#x6e;&#x63;&#x68;&#x2e;&#46;&#46;&#64;&#x67;&#109;&#x61;&#x69;&#x6c;&#46;&#99;&#111;&#x6d;&#93;&#40;&#x29;">&#x5b;&#x63;&#x68;&#x65;&#x6e;&#x67;&#x75;&#97;&#x6e;&#x63;&#x68;&#x2e;&#46;&#46;&#64;&#x67;&#109;&#x61;&#x69;&#x6c;&#46;&#99;&#111;&#x6d;&#93;&#40;&#x29;</a>:</p>
<blockquote>
<p>我觉得现有的OpenCL确实非常不成熟，但是从纯性能角度上来讲，我看好Heterogeneous架构，尽管它们的编程难度太大，就像前面提到的不
同架构需要做不同优化等。CPU的性能是latency-oriented，GPU是throughput-oriented,Intel的
Larrabee虽然现在来看不成功，但是业界都在朝着那个方向努力。</p>
<p>On 3月22日, 下午6时18分, windstorm <a href="&#109;&#97;&#x69;&#x6c;&#x74;&#x6f;&#58;&#91;&#108;&#x69;&#x6b;&#117;&#x6e;&#x61;&#x72;&#109;&#115;&#116;&#114;&#46;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#x61;&#x69;&#108;&#46;&#x63;&#x6f;&#109;&#93;&#x28;&#41;">&#91;&#108;&#x69;&#x6b;&#117;&#x6e;&#x61;&#x72;&#109;&#115;&#116;&#114;&#46;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#x61;&#x69;&#108;&#46;&#x63;&#x6f;&#109;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>实在是不能同意你更多......很早很早以前我就在这里和人争论过，GPU的并行计算平台不可能一统天下的。CUDA也不是救世主。OpenCL更不是。</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Alleluia <a href="&#109;&#x61;&#105;&#x6c;&#x74;&#x6f;&#x3a;&#x5b;&#x61;&#108;&#108;&#117;&#108;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#109;&#x61;&#105;&#108;&#46;&#99;&#111;&#109;&#93;&#x28;&#x29;">&#x5b;&#x61;&#108;&#108;&#117;&#108;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#109;&#x61;&#105;&#108;&#46;&#99;&#111;&#109;&#93;&#x28;&#x29;</a>:</p>
<blockquote>
<p>Parallelism 说到底是算法问题.Parallelism与Concurrency不同,Concurrency所面对的问题相对的单一可以
让一群有经验的专家来实现一套通用库或者语言来提供一个基本的编程框架.而在Parallelism上,具体的不同问题,其所需要并行的算法是根本不同
的.原因在于不同的问题,其内部的DataDependency的结构完全不同,不同的Data Dependency的结构,需要构造不同的算法.即
便是相同的Data Dependency,在不同的颗粒度下，在不同的硬件条件下所采用的算法也是完全不同的.因为一旦出现Data
Dependency也就意味着并行计算模块之间需要进行通信.从以计算节点为单位的分布式并行,到多核CPU上的Numa结构,到SIMD上的向量处
理器,其计算单元之间的通信手段,通信效率简直天差地别.比如说,在SMP上最常见的并行算法,work stealing也就是Intel的TBB,
是建立在两个条件下第一个是CPU的Cache机制上,这使得通常在内存的之间的数据搬运消耗非常小,第二个是SMP上计算单元相对的少,因此每个计算
单元被分配到的任务就相对的重。其开销远远大于通信的开销,因此这种机制在SMP上相对的划算.但是如果你要在GPU上做Work Stealing就
完全不可行,因为GPU的运算单元数量极多,被分配到的任务就相对来说的非常轻量,CUDA上的一个thread很多时候运算一次的时间不会超过
10us,而一次跨Block的线程之间的通信开销就往往要达到100us左右,再加上目前GPU上的Cache机制非常落后导致了需要频繁的通信开销
的Work Stealing在GPU上是非常不划算得.
所以我个人认为在硬件架构没有更多的突破之前,OpenCL这种东西是没有任何生命力的.不要说CPU的并行与GPU之间差异巨大,就是不同的GPU之
间AMD与Nvidia两个也是各自为政,一个平台上跑得非常快的东西,在另外一个平台极大的可能是龟速.其最终的结果估计就是跟Java的
write once run everywhere一样是个大笑话.</p>
<p>On 3月22日, 下午2时06分, Guancheng Chen <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#91;&#99;&#104;&#101;&#110;&#x67;&#x75;&#x61;&#x6e;&#x63;&#104;&#46;&#46;&#46;&#x40;&#x67;&#109;&#x61;&#x69;&#x6c;&#46;&#99;&#111;&#x6d;&#93;&#x28;&#x29;">&#91;&#99;&#104;&#101;&#110;&#x67;&#x75;&#x61;&#x6e;&#x63;&#104;&#46;&#46;&#46;&#x40;&#x67;&#109;&#x61;&#x69;&#x6c;&#46;&#99;&#111;&#x6d;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>On 3月22日, 上午2时20分, Tinyfool <a href="&#x6d;&#x61;&#x69;&#x6c;&#116;&#x6f;&#58;&#x5b;&#x74;&#x69;&#110;&#x79;&#102;&#46;&#x2e;&#46;&#x40;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#x6d;&#x5d;&#40;&#x29;">&#x5b;&#x74;&#x69;&#110;&#x79;&#102;&#46;&#x2e;&#46;&#x40;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#x6d;&#x5d;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#109;&#x61;&#105;&#x6c;&#116;&#111;&#58;&#91;&#106;&#101;&#x2e;&#46;&#46;&#64;&#x6c;&#x69;&#x76;&#101;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#x28;&#x29;">&#91;&#106;&#101;&#x2e;&#46;&#46;&#64;&#x6c;&#x69;&#x76;&#101;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#x28;&#x29;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#x6d;&#97;&#105;&#108;&#x74;&#x6f;&#58;&#x5b;&#x63;&#104;&#101;&#x6e;&#x67;&#117;&#97;&#x6e;&#x63;&#104;&#x2e;&#46;&#46;&#x40;&#103;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#93;&#40;&#x29;">&#x5b;&#x63;&#104;&#101;&#x6e;&#x67;&#117;&#97;&#x6e;&#x63;&#104;&#x2e;&#46;&#46;&#x40;&#103;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#93;&#40;&#x29;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#x6d;&#x61;&#x69;&#108;&#116;&#111;&#58;&#x5b;&#112;&#x6f;&#x6e;&#46;&#x2e;&#46;&#x40;&#x67;&#111;&#x6f;&#103;&#x6c;&#x65;&#x67;&#x72;&#111;&#x75;&#112;&#115;&#x2e;&#99;&#111;&#x6d;&#93;&#x28;&#41;">&#x5b;&#112;&#x6f;&#x6e;&#46;&#x2e;&#46;&#x40;&#x67;&#111;&#x6f;&#103;&#x6c;&#x65;&#x67;&#x72;&#111;&#x75;&#112;&#115;&#x2e;&#99;&#111;&#x6d;&#93;&#x28;&#41;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器...</li>
</ol>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>阅读更多 &gt;&gt;
<a href="">显示删减掉的内容</a></p>
</blockquote>
<p><img src="" alt=""> Alleluia <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-23</p>
<p>其他收件人：</p>
<p>我不是搞体系结构的.但是我认为目前来说做Parallelism的人首先不是去熟悉什么API或者Libarary,而是要熟悉两样东西体系结构和算
法.没有这两样,几乎写不出什么高效率的并行程序.当然你的需求只是并行化循环这种简单的东西当然可以里例外.呵呵.
我觉得你最好放弃用GPGPU去搞遗留代码的想法.现在市面上的GPU产品无论是A记的还是N记的其编程架构与CPU完全不同,你不要想把一个循环简单
的porting到GPU上就能并行了.那是几乎不可能的,比如最简单的你如何处理branch?如果branch非常多,divergence会把速
度拖得比CPU版本还慢.你如何处理CPU代码里的数组随机访问,在GPU上无论是片上的还是片外的内存是不能随机访问的,最要命的是没有cache,
随机访问的代价极其高昂.你几乎需要把CPU上的代码面目全非地从新写一遍,遗留代码除了用作调试测试做结果比对之外几乎要全部抛弃.</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>On 3月23日, 上午6时42分, Guancheng Chen <a href="&#109;&#x61;&#105;&#x6c;&#116;&#111;&#58;&#91;&#x63;&#104;&#x65;&#110;&#x67;&#117;&#97;&#110;&#x63;&#104;&#x2e;&#x2e;&#46;&#x40;&#103;&#109;&#97;&#x69;&#108;&#46;&#x63;&#111;&#109;&#x5d;&#x28;&#41;">&#91;&#x63;&#104;&#x65;&#110;&#x67;&#117;&#97;&#110;&#x63;&#104;&#x2e;&#x2e;&#46;&#x40;&#103;&#109;&#97;&#x69;&#108;&#46;&#x63;&#111;&#109;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>恩 您也是搞体系结构的么？
现在我在跟瑞典这边的爱立信合作做毕设 不过对象不是他们的Erlang 而是传统的C/C++程序 下半年可能我也去搞GPGPU了 因为它的
data parallel模型对遗留代码的并行化很有搞头，现在我粗略的想法是把Compute sensitive的任务放一部分到GPU上去做，
当然我也对GPU目前的一些限制有所了解 但是一些探索工作还是非常值得的 到时候还想向前辈多多请教</p>
<p>On 3月22日, 下午11时30分, Alleluia <a href="&#x6d;&#97;&#105;&#x6c;&#x74;&#111;&#x3a;&#91;&#97;&#x6c;&#108;&#117;&#x6c;&#x2e;&#x2e;&#46;&#x40;&#x67;&#x6d;&#97;&#105;&#108;&#46;&#99;&#111;&#x6d;&#93;&#x28;&#x29;">&#91;&#97;&#x6c;&#108;&#117;&#x6c;&#x2e;&#x2e;&#46;&#x40;&#x67;&#x6d;&#97;&#105;&#108;&#46;&#99;&#111;&#x6d;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>Heterogeneous目前来看也是一个暂时的过渡性的东西. Heterogeneous架构最大的问题还是硬件,CPU和GPU之间的
PCIE2的bus带宽太窄了.在上面来回传递一次几M的内存可能需要化掉500us左右.如果一个算法本来就是在3-4ms级别的,你要用GPU去优
化,内存带宽的消耗就占了1/10,这是非常可怕的事情.或许像AMD那种Fusion架构是一种趋势,但是目前来说没有太大的进展.貌似AMD出了一
款混合的CPU,但是貌似还没有看到有多大的优势.
On 3月23日, 上午5时02分, Guancheng Chen <a href="&#x6d;&#97;&#x69;&#108;&#116;&#111;&#x3a;&#91;&#99;&#104;&#101;&#110;&#103;&#117;&#97;&#110;&#99;&#104;&#x2e;&#x2e;&#46;&#x40;&#103;&#109;&#x61;&#x69;&#108;&#46;&#x63;&#111;&#109;&#93;&#x28;&#41;">&#91;&#99;&#104;&#101;&#110;&#103;&#117;&#97;&#110;&#99;&#104;&#x2e;&#x2e;&#46;&#x40;&#103;&#109;&#x61;&#x69;&#108;&#46;&#x63;&#111;&#109;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>我觉得现有的OpenCL确实非常不成熟，但是从纯性能角度上来讲，我看好Heterogeneous架构，尽管它们的编程难度太大，就像前面提到的不
同架构需要做不同优化等。CPU的性能是latency-oriented，GPU是throughput-oriented,Intel的
Larrabee虽然现在来看不成功，但是业界都在朝着那个方向努力。</p>
<p>On 3月22日, 下午6时18分, windstorm <a href="&#109;&#97;&#105;&#x6c;&#116;&#x6f;&#58;&#91;&#x6c;&#105;&#107;&#x75;&#x6e;&#x61;&#114;&#109;&#115;&#116;&#114;&#46;&#46;&#46;&#64;&#x67;&#109;&#97;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#93;&#x28;&#x29;">&#91;&#x6c;&#105;&#107;&#x75;&#x6e;&#x61;&#114;&#109;&#115;&#116;&#114;&#46;&#46;&#46;&#64;&#x67;&#109;&#97;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>实在是不能同意你更多......很早很早以前我就在这里和人争论过，GPU的并行计算平台不可能一统天下的。CUDA也不是救世主。OpenCL更不是。</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Alleluia <a href="&#109;&#97;&#105;&#108;&#116;&#x6f;&#x3a;&#x5b;&#x61;&#108;&#108;&#x75;&#x6c;&#x2e;&#x2e;&#46;&#64;&#103;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#111;&#x6d;&#93;&#40;&#x29;">&#x5b;&#x61;&#108;&#108;&#x75;&#x6c;&#x2e;&#x2e;&#46;&#64;&#103;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#111;&#x6d;&#93;&#40;&#x29;</a>:</p>
<blockquote>
<p>Parallelism 说到底是算法问题.Parallelism与Concurrency不同,Concurrency所面对的问题相对的单一可以
让一群有经验的专家来实现一套通用库或者语言来提供一个基本的编程框架.而在Parallelism上,具体的不同问题,其所需要并行的算法是根本不同
的.原因在于不同的问题,其内部的DataDependency的结构完全不同,不同的Data Dependency的结构,需要构造不同的算法.即
便是相同的Data Dependency,在不同的颗粒度下，在不同的硬件条件下所采用的算法也是完全不同的.因为一旦出现Data
Dependency也就意味着并行计算模块之间需要进行通信.从以计算节点为单位的分布式并行,到多核CPU上的Numa结构,到SIMD上的向量处
理器,其计算单元之间的通信手段,通信效率简直天差地别.比如说,在SMP上最常见的并行算法,work stealing也就是Intel的TBB,
是建立在两个条件下第一个是CPU的Cache机制上,这使得通常在内存的之间的数据搬运消耗非常小,第二个是SMP上计算单元相对的少,因此每个计算
单元被分配到的任务就相对的重。其开销远远大于通信的开销,因此这种机制在SMP上相对的划算.但是如果你要在GPU上做Work Stealing就
完全不可行,因为GPU的运算单元数量极多,被分配到的任务就相对来说的非常轻量,CUDA上的一个thread很多时候运算一次的时间不会超过
10us,而一次跨Block的线程之间的通信开销就往往要达到100us左右,再加上目前GPU上的Cache机制非常落后导致了需要频繁的通信开销
的Work Stealing在GPU上是非常不划算得.
所以我个人认为在硬件架构没有更多的突破之前,OpenCL这种东西是没有任何生命力的.不要说CPU的并行与GPU之间差异巨大,就是不同的GPU之
间AMD与Nvidia两个也是各自为政,一个平台上跑得非常快的东西,在另外一个平台极大的可能是龟速.其最终的结果估计就是跟Java的
write once run everywhere一样是个大笑话.</p>
<p>On 3月22日, 下午2时06分, Guancheng Chen <a href="&#109;&#97;&#105;&#108;&#x74;&#x6f;&#58;&#91;&#99;&#x68;&#x65;&#110;&#x67;&#117;&#x61;&#x6e;&#x63;&#104;&#46;&#x2e;&#46;&#64;&#x67;&#109;&#97;&#x69;&#x6c;&#46;&#x63;&#111;&#x6d;&#x5d;&#x28;&#x29;">&#91;&#99;&#x68;&#x65;&#110;&#x67;&#117;&#x61;&#x6e;&#x63;&#104;&#46;&#x2e;&#46;&#64;&#x67;&#109;&#97;&#x69;&#x6c;&#46;&#x63;&#111;&#x6d;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>On 3月22日, 上午2时20分, Tinyfool <a href="&#x6d;&#x61;&#x69;&#x6c;&#116;&#x6f;&#58;&#91;&#x74;&#105;&#110;&#121;&#x66;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#109;&#x61;&#105;&#108;&#x2e;&#x63;&#111;&#109;&#x5d;&#40;&#41;">&#91;&#x74;&#105;&#110;&#121;&#x66;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#109;&#x61;&#105;&#108;&#x2e;&#x63;&#111;&#109;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#x6d;&#97;&#105;&#x6c;&#116;&#x6f;&#58;&#x5b;&#x6a;&#x65;&#46;&#x2e;&#x2e;&#x40;&#x6c;&#105;&#118;&#101;&#46;&#x63;&#111;&#x6d;&#93;&#x28;&#x29;">&#x5b;&#x6a;&#x65;&#46;&#x2e;&#x2e;&#x40;&#x6c;&#105;&#118;&#101;&#46;&#x63;&#111;&#x6d;&#93;&#x28;&#x29;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#x6d;&#97;&#x69;&#x6c;&#x74;&#x6f;&#58;&#x5b;&#99;&#104;&#101;&#x6e;&#x67;&#117;&#97;&#110;&#99;&#x68;&#46;&#x2e;&#46;&#64;&#103;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#x29;">&#x5b;&#99;&#104;&#101;&#x6e;&#x67;&#117;&#97;&#110;&#99;&#x68;&#46;&#x2e;&#46;&#64;&#103;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#x29;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#111;&#58;&#x5b;&#x70;&#x6f;&#x6e;&#46;&#x2e;&#46;&#x40;&#103;&#111;&#x6f;&#103;&#108;&#x65;&#103;&#x72;&#x6f;&#117;&#x70;&#115;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#x28;&#41;">&#x5b;&#x70;&#x6f;&#x6e;&#46;&#x2e;&#46;&#x40;&#103;&#111;&#x6f;&#103;&#108;&#x65;&#103;&#x72;&#x6f;&#117;&#x70;&#115;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#x28;&#41;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发</p>
</li>
</ol>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>...</p>
<p>阅读更多 &gt;&gt;
<a href="">显示删减掉的内容</a>
<img src="" alt=""> Alleluia <img src="" alt=""></p>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-23</p>
<p>其他收件人：</p>
<p>我当初就不看好Larrabee这个东西,想想一个Core上一个Decoder就要消耗1瓦的功率,32个捆起来这个Core的功率要多大啊.我觉得
一捆Arm棒在一起都比PII靠谱.</p>
<p>On 3月23日, 上午5时41分, windstorm <a href="&#109;&#97;&#105;&#108;&#x74;&#x6f;&#58;&#x5b;&#x6c;&#x69;&#107;&#117;&#110;&#97;&#x72;&#109;&#x73;&#x74;&#114;&#x2e;&#46;&#x2e;&#64;&#x67;&#109;&#97;&#x69;&#108;&#x2e;&#x63;&#111;&#109;&#93;&#x28;&#x29;">&#x5b;&#x6c;&#x69;&#107;&#117;&#110;&#97;&#x72;&#109;&#x73;&#x74;&#114;&#x2e;&#46;&#x2e;&#64;&#x67;&#109;&#97;&#x69;&#108;&#x2e;&#x63;&#111;&#109;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>Larrabee当初我还是很看好的，它的架构比其他的更像一个统一的方案，可惜后来Intel自己经验不足搞不好。</p>
<p>OPENCL还是主要面向multimedia吧，CUDA/OpenCL在业界代表了流处理的方向，从GPU针对任务的角度讲是好的。其他的就算了。就像Al leluia说的那样，在硬件架构没有更多的突破之前，不说没有生命力，至少想取得任何进一步的突破都太难。</p>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>现在这个领域，你吹你的水，我吹我的水。至于谁的泡泡大，我看不清。所以真要选东西学，最好还是针对自己的application选靠谱。这也是并行编程教育难 的问题。大家需求完全不一样。</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Guancheng Chen <a href="&#x6d;&#x61;&#x69;&#108;&#116;&#111;&#x3a;&#91;&#99;&#104;&#x65;&#110;&#x67;&#117;&#x61;&#x6e;&#99;&#104;&#46;&#46;&#x2e;&#x40;&#103;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#99;&#x6f;&#109;&#93;&#x28;&#41;">&#91;&#99;&#104;&#x65;&#110;&#x67;&#117;&#x61;&#x6e;&#99;&#104;&#46;&#46;&#x2e;&#x40;&#103;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#99;&#x6f;&#109;&#93;&#x28;&#41;</a>:</p>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>&gt;
&gt;
&gt;</p>
<blockquote>
<blockquote>
<p>我觉得现有的OpenCL确实非常不成熟，但是从纯性能角度上来讲，我看好Heterogeneous架构，尽管它们的编程难度太大，就像前面提到的不
同架构需要做不同优化等。CPU的性能是latency-oriented，GPU是throughput-oriented,Intel的
Larrabee虽然现在来看不成功，但是业界都在朝着那个方向努力。</p>
<p>On 3月22日, 下午6时18分, windstorm <a href="&#x6d;&#x61;&#105;&#108;&#116;&#111;&#x3a;&#91;&#x6c;&#x69;&#x6b;&#x75;&#x6e;&#x61;&#x72;&#109;&#115;&#116;&#114;&#46;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#46;&#99;&#x6f;&#109;&#93;&#x28;&#x29;">&#91;&#x6c;&#x69;&#x6b;&#x75;&#x6e;&#x61;&#x72;&#109;&#115;&#116;&#114;&#46;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#46;&#99;&#x6f;&#109;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>实在是不能同意你更多......很早很早以前我就在这里和人争论过，GPU的并行计算平台不可能一统天下的。CUDA也不是救世主。OpenCL更不是。</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Alleluia <a href="&#x6d;&#x61;&#105;&#108;&#116;&#111;&#58;&#91;&#x61;&#x6c;&#x6c;&#117;&#x6c;&#x2e;&#x2e;&#46;&#x40;&#x67;&#109;&#97;&#x69;&#108;&#x2e;&#x63;&#111;&#x6d;&#93;&#x28;&#41;">&#91;&#x61;&#x6c;&#x6c;&#117;&#x6c;&#x2e;&#x2e;&#46;&#x40;&#x67;&#109;&#97;&#x69;&#108;&#x2e;&#x63;&#111;&#x6d;&#93;&#x28;&#41;</a>:</p>
<blockquote>
<p>Parallelism 说到底是算法问题.Parallelism与Concurrency不同,Concurrency所面对的问题相对的单一可以
让一群有经验的专家来实现一套通用库或者语言来提供一个基本的编程框架.而在Parallelism上,具体的不同问题,其所需要并行的算法是根本不同
的.原因在于不同的问题,其内部的DataDependency的结构完全不同,不同的Data Dependency的结构,需要构造不同的算法.即
便是相同的Data Dependency,在不同的颗粒度下，在不同的硬件条件下所采用的算法也是完全不同的.因为一旦出现Data
Dependency也就意味着并行计算模块之间需要进行通信.从以计算节点为单位的分布式并行,到多核CPU上的Numa结构,到SIMD上的向量处
理器,其计算单元之间的通信手段,通信效率简直天差地别.比如说,在SMP上最常见的并行算法,work stealing也就是Intel的TBB,
是建立在两个条件下第一个是CPU的Cache机制上,这使得通常在内存的之间的数据搬运消耗非常小,第二个是SMP上计算单元相对的少,因此每个计算
单元被分配到的任务就相对的重。其开销远远大于通信的开销,因此这种机制在SMP上相对的划算.但是如果你要在GPU上做Work Stealing就
完全不可行,因为GPU的运算单元数量极多,被分配到的任务就相对来说的非常轻量,CUDA上的一个thread很多时候运算一次的时间不会超过
10us,而一次跨Block的线程之间的通信开销就往往要达到100us左右,再加上目前GPU上的Cache机制非常落后导致了需要频繁的通信开销
的Work Stealing在GPU上是非常不划算得.
所以我个人认为在硬件架构没有更多的突破之前,OpenCL这种东西是没有任何生命力的.不要说CPU的并行与GPU之间差异巨大,就是不同的GPU之
间AMD与Nvidia两个也是各自为政,一个平台上跑得非常快的东西,在另外一个平台极大的可能是龟速.其最终的结果估计就是跟Java的
write once run everywhere一样是个大笑话.</p>
<p>On 3月22日, 下午2时06分, Guancheng Chen <a href="&#x6d;&#x61;&#x69;&#x6c;&#116;&#x6f;&#x3a;&#91;&#x63;&#104;&#x65;&#x6e;&#103;&#117;&#x61;&#110;&#x63;&#x68;&#46;&#46;&#46;&#x40;&#x67;&#x6d;&#x61;&#x69;&#108;&#46;&#99;&#111;&#109;&#93;&#x28;&#x29;">&#91;&#x63;&#104;&#x65;&#x6e;&#103;&#117;&#x61;&#110;&#x63;&#x68;&#46;&#46;&#46;&#x40;&#x67;&#x6d;&#x61;&#x69;&#108;&#46;&#99;&#111;&#109;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>On 3月22日, 上午2时20分, Tinyfool <a href="&#x6d;&#x61;&#x69;&#108;&#116;&#x6f;&#x3a;&#91;&#x74;&#x69;&#110;&#x79;&#x66;&#46;&#x2e;&#x2e;&#x40;&#103;&#109;&#97;&#x69;&#108;&#x2e;&#99;&#111;&#x6d;&#93;&#40;&#x29;">&#91;&#x74;&#x69;&#110;&#x79;&#x66;&#46;&#x2e;&#x2e;&#x40;&#103;&#109;&#97;&#x69;&#108;&#x2e;&#99;&#111;&#x6d;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#111;&#58;&#91;&#106;&#x65;&#x2e;&#x2e;&#x2e;&#x40;&#108;&#x69;&#118;&#x65;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#x28;&#x29;">&#91;&#106;&#x65;&#x2e;&#x2e;&#x2e;&#x40;&#108;&#x69;&#118;&#x65;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#x28;&#x29;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#109;&#97;&#105;&#108;&#x74;&#x6f;&#x3a;&#91;&#x63;&#x68;&#x65;&#x6e;&#103;&#117;&#97;&#x6e;&#99;&#x68;&#x2e;&#46;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#105;&#x6c;&#46;&#x63;&#111;&#109;&#93;&#x28;&#x29;">&#91;&#x63;&#x68;&#x65;&#x6e;&#103;&#117;&#97;&#x6e;&#99;&#x68;&#x2e;&#46;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#105;&#x6c;&#46;&#x63;&#111;&#109;&#93;&#x28;&#x29;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#109;&#x61;&#x69;&#x6c;&#116;&#111;&#x3a;&#91;&#112;&#111;&#x6e;&#46;&#x2e;&#x2e;&#64;&#103;&#x6f;&#111;&#103;&#x6c;&#x65;&#x67;&#114;&#x6f;&#117;&#112;&#x73;&#x2e;&#x63;&#111;&#109;&#x5d;&#40;&#x29;">&#91;&#112;&#111;&#x6e;&#46;&#x2e;&#x2e;&#64;&#103;&#x6f;&#111;&#103;&#x6c;&#x65;&#x67;&#114;&#x6f;&#117;&#112;&#x73;&#x2e;&#x63;&#111;&#109;&#x5d;&#40;&#x29;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>...</p>
<p>阅读更多 &gt;&gt;
<a href="">显示删减掉的内容</a></p>
</blockquote>
<p><img src="" alt=""> windstorm <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-23</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>显然不是简单捆绑那么简单阿。</p>
<p>而且我看好它，并不是它将来会一统天下，而是说它相对革命性的架构部分程度上满足了线程完备，从而扩展了GPU的使用领域，所以我看好以它为代表的这种架构的发展。同类型的还有Sun当年的Rock和Niagara
1/2</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p><a href="http://www.kunli.info/" target="_blank">www.kunli.info</a>
<a href="http://twitter.com/cnbuff" target="_blank"><a href="http://twitter.com/cnbuff">http://twitter.com/cnbuff</a></a></p>
<p>2010/3/22 Alleluia <a href="&#x6d;&#x61;&#105;&#x6c;&#116;&#x6f;&#58;&#x5b;&#x61;&#108;&#108;&#x75;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#97;&#105;&#108;&#x2e;&#99;&#x6f;&#109;&#x5d;&#40;&#41;">&#x5b;&#x61;&#108;&#108;&#x75;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#97;&#105;&#108;&#x2e;&#99;&#x6f;&#109;&#x5d;&#40;&#41;</a>:</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<blockquote>
<p>我当初就不看好Larrabee这个东西,想想一个Core上一个Decoder就要消耗1瓦的功率,32个捆起来这个Core的功率要多大啊.我觉得
一捆Arm棒在一起都比PII靠谱.</p>
<p>On 3月23日, 上午5时41分, windstorm <a href="&#109;&#x61;&#105;&#108;&#x74;&#111;&#x3a;&#91;&#x6c;&#105;&#107;&#x75;&#x6e;&#x61;&#x72;&#109;&#115;&#116;&#114;&#x2e;&#46;&#x2e;&#x40;&#103;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#41;">&#91;&#x6c;&#105;&#107;&#x75;&#x6e;&#x61;&#x72;&#109;&#115;&#116;&#114;&#x2e;&#46;&#x2e;&#x40;&#103;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>Larrabee当初我还是很看好的，它的架构比其他的更像一个统一的方案，可惜后来Intel自己经验不足搞不好。</p>
<p>OPENCL还是主要面向multimedia吧，CUDA/OpenCL在业界代表了流处理的方向，从GPU针对任务的角度讲是好的。其他的就算了。就像Al leluia说的那样，在硬件架构没有更多的突破之前，不说没有生命力，至少想取得任何进一步的突破都太难。</p>
<p>现在这个领域，你吹你的水，我吹我的水。至于谁的泡泡大，我看不清。所以真要选东西学，最好还是针对自己的application选靠谱。这也是并行编程教育难 的问题。大家需求完全不一样。</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Guancheng Chen <a href="&#x6d;&#x61;&#x69;&#108;&#116;&#111;&#58;&#x5b;&#x63;&#x68;&#101;&#x6e;&#103;&#x75;&#97;&#110;&#99;&#104;&#46;&#x2e;&#46;&#x40;&#x67;&#109;&#97;&#105;&#108;&#x2e;&#x63;&#111;&#109;&#93;&#40;&#41;">&#x5b;&#x63;&#x68;&#101;&#x6e;&#103;&#x75;&#97;&#110;&#99;&#104;&#46;&#x2e;&#46;&#x40;&#x67;&#109;&#97;&#105;&#108;&#x2e;&#x63;&#111;&#109;&#93;&#40;&#41;</a>:</p>
<blockquote>
<p>我觉得现有的OpenCL确实非常不成熟，但是从纯性能角度上来讲，我看好Heterogeneous架构，尽管它们的编程难度太大，就像前面提到的不
同架构需要做不同优化等。CPU的性能是latency-oriented，GPU是throughput-oriented,Intel的
Larrabee虽然现在来看不成功，但是业界都在朝着那个方向努力。</p>
<p>On 3月22日, 下午6时18分, windstorm <a href="&#109;&#97;&#105;&#x6c;&#x74;&#x6f;&#x3a;&#x5b;&#x6c;&#105;&#x6b;&#117;&#110;&#97;&#114;&#109;&#115;&#x74;&#114;&#46;&#x2e;&#x2e;&#64;&#103;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#111;&#109;&#93;&#40;&#41;">&#x5b;&#x6c;&#105;&#x6b;&#117;&#110;&#97;&#114;&#109;&#115;&#x74;&#114;&#46;&#x2e;&#x2e;&#64;&#103;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#111;&#109;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>实在是不能同意你更多......很早很早以前我就在这里和人争论过，GPU的并行计算平台不可能一统天下的。CUDA也不是救世主。OpenCL更不是。</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Alleluia <a href="&#109;&#x61;&#x69;&#108;&#x74;&#111;&#x3a;&#91;&#x61;&#x6c;&#x6c;&#117;&#108;&#x2e;&#x2e;&#46;&#x40;&#103;&#109;&#97;&#x69;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#x28;&#x29;">&#91;&#x61;&#x6c;&#x6c;&#117;&#108;&#x2e;&#x2e;&#46;&#x40;&#103;&#109;&#97;&#x69;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#x28;&#x29;</a>:</p>
<blockquote>
<p>Parallelism 说到底是算法问题.Parallelism与Concurrency不同,Concurrency所面对的问题相对的单一可以
让一群有经验的专家来实现一套通用库或者语言来提供一个基本的编程框架.而在Parallelism上,具体的不同问题,其所需要并行的算法是根本不同
的.原因在于不同的问题,其内部的DataDependency的结构完全不同,不同的Data Dependency的结构,需要构造不同的算法.即
便是相同的Data Dependency,在不同的颗粒度下，在不同的硬件条件下所采用的算法也是完全不同的.因为一旦出现Data
Dependency也就意味着并行计算模块之间需要进行通信.从以计算节点为单位的分布式并行,到多核CPU上的Numa结构,到SIMD上的向量处
理器,其计算单元之间的通信手段,通信效率简直天差地别.比如说,在SMP上最常见的并行算法,work stealing也就是Intel的TBB,
是建立在两个条件下第一个是CPU的Cache机制上,这使得通常在内存的之间的数据搬运消耗非常小,第二个是SMP上计算单元相对的少,因此每个计算
单元被分配到的任务就相对的重。其开销远远大于通信的开销,因此这种机制在SMP上相对的划算.但是如果你要在GPU上做Work Stealing就
完全不可行,因为GPU的运算单元数量极多,被分配到的任务就相对来说的非常轻量,CUDA上的一个thread很多时候运算一次的时间不会超过
10us,而一次跨Block的线程之间的通信开销就往往要达到100us左右,再加上目前GPU上的Cache机制非常落后导致了需要频繁的通信开销
的Work Stealing在GPU上是非常不划算得.
所以我个人认为在硬件架构没有更多的突破之前,OpenCL这种东西是没有任何生命力的.不要说CPU的并行与GPU之间差异巨大,就是不同的GPU之
间AMD与Nvidia两个也是各自为政,一个平台上跑得非常快的东西,在另外一个平台极大的可能是龟速.其最终的结果估计就是跟Java的
write once run everywhere一样是个大笑话.</p>
<p>On 3月22日, 下午2时06分, Guancheng Chen <a href="&#109;&#x61;&#x69;&#108;&#116;&#x6f;&#58;&#91;&#99;&#104;&#x65;&#x6e;&#103;&#x75;&#97;&#x6e;&#x63;&#104;&#46;&#x2e;&#46;&#64;&#103;&#109;&#x61;&#x69;&#108;&#46;&#99;&#111;&#109;&#93;&#x28;&#x29;">&#91;&#99;&#104;&#x65;&#x6e;&#103;&#x75;&#97;&#x6e;&#x63;&#104;&#46;&#x2e;&#46;&#64;&#103;&#109;&#x61;&#x69;&#108;&#46;&#99;&#111;&#109;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>On 3月22日, 上午2时20分, Tinyfool <a href="&#x6d;&#97;&#x69;&#x6c;&#x74;&#111;&#x3a;&#x5b;&#x74;&#x69;&#x6e;&#x79;&#x66;&#46;&#x2e;&#x2e;&#64;&#x67;&#109;&#97;&#x69;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#93;&#40;&#41;">&#x5b;&#x74;&#x69;&#x6e;&#x79;&#x66;&#46;&#x2e;&#x2e;&#64;&#x67;&#109;&#97;&#x69;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#x6d;&#x61;&#x69;&#108;&#x74;&#x6f;&#x3a;&#91;&#x6a;&#x65;&#x2e;&#x2e;&#46;&#64;&#108;&#105;&#118;&#101;&#46;&#x63;&#111;&#x6d;&#93;&#40;&#x29;">&#91;&#x6a;&#x65;&#x2e;&#x2e;&#46;&#64;&#108;&#105;&#118;&#101;&#46;&#x63;&#111;&#x6d;&#93;&#40;&#x29;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#x6d;&#x61;&#x69;&#108;&#116;&#x6f;&#x3a;&#x5b;&#99;&#104;&#x65;&#110;&#x67;&#x75;&#97;&#x6e;&#99;&#x68;&#46;&#46;&#x2e;&#x40;&#103;&#x6d;&#x61;&#x69;&#x6c;&#46;&#99;&#111;&#x6d;&#93;&#x28;&#x29;">&#x5b;&#99;&#104;&#x65;&#110;&#x67;&#x75;&#97;&#x6e;&#99;&#x68;&#46;&#46;&#x2e;&#x40;&#103;&#x6d;&#x61;&#x69;&#x6c;&#46;&#99;&#111;&#x6d;&#93;&#x28;&#x29;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#109;&#x61;&#105;&#108;&#116;&#x6f;&#x3a;&#91;&#x70;&#111;&#x6e;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#x6f;&#111;&#x67;&#108;&#x65;&#x67;&#114;&#111;&#x75;&#112;&#115;&#x2e;&#99;&#111;&#109;&#93;&#40;&#41;">&#91;&#x70;&#111;&#x6e;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#x6f;&#111;&#x67;&#108;&#x65;&#x67;&#114;&#111;&#x75;&#112;&#115;&#x2e;&#99;&#111;&#109;&#93;&#40;&#41;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>...</p>
<p>阅读更多 &gt;&gt;</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p><a href="">显示删减掉的内容</a>
<img src="" alt=""> windstorm <img src="" alt=""></p>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-23</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>女生？LJJ？</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p><a href="http://www.kunli.info/" target="_blank">www.kunli.info</a>
<a href="http://twitter.com/cnbuff" target="_blank"><a href="http://twitter.com/cnbuff">http://twitter.com/cnbuff</a></a></p>
<p>2010/3/22 Guancheng Chen <a href="&#x6d;&#x61;&#x69;&#108;&#x74;&#x6f;&#58;&#91;&#99;&#104;&#x65;&#x6e;&#x67;&#117;&#x2e;&#46;&#x2e;&#x40;&#103;&#109;&#x61;&#x69;&#x6c;&#x2e;&#99;&#111;&#x6d;&#93;&#x28;&#x29;">&#91;&#99;&#104;&#x65;&#x6e;&#x67;&#117;&#x2e;&#46;&#x2e;&#x40;&#103;&#109;&#x61;&#x69;&#x6c;&#x2e;&#99;&#111;&#x6d;&#93;&#x28;&#x29;</a>:</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<blockquote>
<p>恩</p>
<p>第二点其实我就是指程序员根据他自己的程序领域选择合适的并行技术。Top Language真是藏龙卧虎啊。你是在Boulder么?我一个大学女同
学在你那读MIS的phd</p>
<p>On 3月23日, 上午12时04分, windstorm <a href="&#109;&#x61;&#105;&#x6c;&#116;&#111;&#58;&#91;&#108;&#x69;&#x6b;&#117;&#110;&#97;&#x72;&#109;&#115;&#116;&#x72;&#46;&#x2e;&#x2e;&#x40;&#x67;&#109;&#x61;&#105;&#108;&#x2e;&#x63;&#111;&#x6d;&#93;&#40;&#x29;">&#91;&#108;&#x69;&#x6b;&#117;&#110;&#97;&#x72;&#109;&#115;&#116;&#x72;&#46;&#x2e;&#x2e;&#x40;&#x67;&#109;&#x61;&#105;&#108;&#x2e;&#x63;&#111;&#x6d;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>全民并行编程的时代，只有在全民能够并行编程的时候才会到来嘛，现在不是这个时候</p>
<p>我个人倾向于等待一个比较好的统一性架构。两条路：</p>
<p>一是某一个全新概念的提出，这个要看学术界的努力，而且在某种意义上讲，学术界搞出一个真正可行的并行架构的可能性比工业界更高。虽说今天多核的发展是工业界引 领的，但是点子还是最早学术界提出的。典型的有几个：斯坦福的Hydra（1996），斯坦福的Imagine(2000)，MIT的RAW（2002），以及 UT奥斯丁的TRIPS（2003）。在这个问题上，是不得不佩服美国的创造力，要知道直到在2000年左右，所有的人都还在为处理器频率按照摩尔定律翻翻而狂 热，美国的顶尖研究员就早已看到了这条路的尽头并指出未来处理器的发展之路。</p>
<p>二是你用现有的架构，但是application引导。如果要找一个面向多application
domain的话，刚才说了，本来看好Larrabee，因为它的架构解决了CUDA一个很大的潜在问题，而且允许现有程序员不经过任何特殊training就 上手编程，包括图形图像，科学计算，或者网络处理，各个领域。</p>
<p>不过可能就是因为这个solution的过于理想化导致结构的过于复杂化，才让其目前暂时流产。</p>
<p>总的来说，现在的问题就是软件发展不成熟，硬件发展不完善，你没法靠程序员决定使用什么并行技术，完全靠应用主导，这套技术在这个应用上如鱼得水，在那个应用上 完全不罩，作为程序员，有什么办法？</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Guancheng Chen <a href="&#109;&#97;&#x69;&#108;&#116;&#x6f;&#58;&#91;&#99;&#x68;&#101;&#x6e;&#103;&#x75;&#97;&#110;&#99;&#x68;&#46;&#46;&#46;&#64;&#x67;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#x6d;&#93;&#40;&#41;">&#91;&#99;&#x68;&#101;&#x6e;&#103;&#x75;&#97;&#110;&#99;&#x68;&#46;&#46;&#46;&#64;&#x67;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#x6d;&#93;&#40;&#41;</a>:</p>
<blockquote>
<p>教育以人为本，最终决定使用何种并行技术的还是程序员。目前业界对程序员并没有并行编程的技能要求，全民并行编程的时代什么时候才能到来？这是个问
题。</p>
<p>On 3月22日, 下午10时41分, windstorm <a href="&#x6d;&#97;&#105;&#108;&#x74;&#111;&#x3a;&#x5b;&#x6c;&#105;&#107;&#x75;&#110;&#97;&#x72;&#x6d;&#x73;&#x74;&#x72;&#46;&#46;&#x2e;&#x40;&#103;&#x6d;&#x61;&#105;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#93;&#x28;&#41;">&#x5b;&#x6c;&#105;&#107;&#x75;&#110;&#97;&#x72;&#x6d;&#x73;&#x74;&#x72;&#46;&#46;&#x2e;&#x40;&#103;&#x6d;&#x61;&#105;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>Larrabee当初我还是很看好的，它的架构比其他的更像一个统一的方案，可惜后来Intel自己经验不足搞不好。</p>
<p>OPENCL还是主要面向multimedia吧，CUDA/OpenCL在业界代表了流处理的方向，从GPU针对任务的角度讲是好的。其他的就算了。就像Al leluia说的那样，在硬件架构没有更多的突破之前，不说没有生命力，至少想取得任何进一步的突破都太难。</p>
<p>现在这个领域，你吹你的水，我吹我的水。至于谁的泡泡大，我看不清。所以真要选东西学，最好还是针对自己的application选靠谱。这也是并行编程教育难 的问题。大家需求完全不一样。</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Guancheng Chen <a href="&#x6d;&#x61;&#105;&#x6c;&#x74;&#111;&#x3a;&#91;&#x63;&#104;&#x65;&#110;&#103;&#x75;&#97;&#110;&#x63;&#x68;&#46;&#46;&#x2e;&#64;&#103;&#x6d;&#97;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#40;&#x29;">&#91;&#x63;&#104;&#x65;&#110;&#103;&#x75;&#97;&#110;&#x63;&#x68;&#46;&#46;&#x2e;&#64;&#103;&#x6d;&#97;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#40;&#x29;</a>:</p>
<blockquote>
<p>我觉得现有的OpenCL确实非常不成熟，但是从纯性能角度上来讲，我看好Heterogeneous架构，尽管它们的编程难度太大，就像前面提到的不
同架构需要做不同优化等。CPU的性能是latency-oriented，GPU是throughput-oriented,Intel的
Larrabee虽然现在来看不成功，但是业界都在朝着那个方向努力。</p>
<p>On 3月22日, 下午6时18分, windstorm <a href="&#x6d;&#97;&#105;&#x6c;&#x74;&#111;&#58;&#x5b;&#x6c;&#x69;&#x6b;&#117;&#110;&#x61;&#114;&#109;&#x73;&#x74;&#114;&#46;&#46;&#46;&#x40;&#103;&#x6d;&#97;&#x69;&#x6c;&#46;&#x63;&#111;&#109;&#x5d;&#x28;&#x29;">&#x5b;&#x6c;&#x69;&#x6b;&#117;&#110;&#x61;&#114;&#109;&#x73;&#x74;&#114;&#46;&#46;&#46;&#x40;&#103;&#x6d;&#97;&#x69;&#x6c;&#46;&#x63;&#111;&#109;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>实在是不能同意你更多......很早很早以前我就在这里和人争论过，GPU的并行计算平台不可能一统天下的。CUDA也不是救世主。OpenCL更不是。</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Alleluia <a href="&#x6d;&#97;&#x69;&#108;&#x74;&#x6f;&#x3a;&#91;&#x61;&#108;&#108;&#117;&#108;&#x2e;&#x2e;&#46;&#64;&#x67;&#109;&#x61;&#x69;&#108;&#46;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#41;">&#91;&#x61;&#108;&#108;&#117;&#108;&#x2e;&#x2e;&#46;&#64;&#x67;&#109;&#x61;&#x69;&#108;&#46;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#41;</a>:</p>
<blockquote>
<p>Parallelism 说到底是算法问题.Parallelism与Concurrency不同,Concurrency所面对的问题相对的单一可以
让一群有经验的专家来实现一套通用库或者语言来提供一个基本的编程框架.而在Parallelism上,具体的不同问题,其所需要并行的算法是根本不同
的.原因在于不同的问题,其内部的DataDependency的结构完全不同,不同的Data Dependency的结构,需要构造不同的算法.即
便是相同的Data Dependency,在不同的颗粒度下，在不同的硬件条件下所采用的算法也是完全不同的.因为一旦出现Data
Dependency也就意味着并行计算模块之间需要进行通信.从以计算节点为单位的分布式并行,到多核CPU上的Numa结构,到SIMD上的向量处
理器,其计算单元之间的通信手段,通信效率简直天差地别.比如说,在SMP上最常见的并行算法,work stealing也就是Intel的TBB,
是建立在两个条件下第一个是CPU的Cache机制上,这使得通常在内存的之间的数据搬运消耗非常小,第二个是SMP上计算单元相对的少,因此每个计算
单元被分配到的任务就相对的重。其开销远远大于通信的开销,因此这种机制在SMP上相对的划算.但是如果你要在GPU上做Work Stealing就
完全不可行,因为GPU的运算单元数量极多,被分配到的任务就相对来说的非常轻量,CUDA上的一个thread很多时候运算一次的时间不会超过
10us,而一次跨Block的线程之间的通信开销就往往要达到100us左右,再加上目前GPU上的Cache机制非常落后导致了需要频繁的通信开销
的Work Stealing在GPU上是非常不划算得.
所以我个人认为在硬件架构没有更多的突破之前,OpenCL这种东西是没有任何生命力的.不要说CPU的并行与GPU之间差异巨大,就是不同的GPU之
间AMD与Nvidia两个也是各自为政,一个平台上跑得非常快的东西,在另外一个平台极大的可能是龟速.其最终的结果估计就是跟Java的
write once run everywhere一样是个大笑话.</p>
<p>On 3月22日, 下午2时06分, Guancheng Chen <a href="&#x6d;&#x61;&#x69;&#108;&#x74;&#x6f;&#58;&#x5b;&#99;&#104;&#101;&#x6e;&#103;&#x75;&#97;&#110;&#x63;&#104;&#46;&#46;&#x2e;&#64;&#x67;&#x6d;&#x61;&#105;&#108;&#x2e;&#99;&#111;&#109;&#93;&#40;&#x29;">&#x5b;&#99;&#104;&#101;&#x6e;&#103;&#x75;&#97;&#110;&#x63;&#104;&#46;&#46;&#x2e;&#64;&#x67;&#x6d;&#x61;&#105;&#108;&#x2e;&#99;&#111;&#109;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>On 3月22日, 上午2时20分, Tinyfool <a href="&#109;&#97;&#x69;&#108;&#x74;&#111;&#x3a;&#91;&#x74;&#x69;&#110;&#121;&#102;&#x2e;&#x2e;&#x2e;&#64;&#103;&#109;&#x61;&#x69;&#x6c;&#46;&#x63;&#111;&#x6d;&#93;&#40;&#41;">&#91;&#x74;&#x69;&#110;&#121;&#102;&#x2e;&#x2e;&#x2e;&#64;&#103;&#109;&#x61;&#x69;&#x6c;&#46;&#x63;&#111;&#x6d;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#109;&#97;&#x69;&#108;&#x74;&#x6f;&#x3a;&#91;&#x6a;&#101;&#46;&#x2e;&#46;&#x40;&#108;&#x69;&#118;&#101;&#x2e;&#x63;&#111;&#109;&#93;&#x28;&#x29;">&#91;&#x6a;&#101;&#46;&#x2e;&#46;&#x40;&#108;&#x69;&#118;&#101;&#x2e;&#x63;&#111;&#109;&#93;&#x28;&#x29;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#109;&#x61;&#x69;&#x6c;&#116;&#x6f;&#58;&#91;&#x63;&#104;&#x65;&#110;&#x67;&#x75;&#97;&#x6e;&#x63;&#104;&#x2e;&#46;&#x2e;&#64;&#103;&#109;&#x61;&#x69;&#x6c;&#46;&#x63;&#111;&#x6d;&#x5d;&#40;&#x29;">&#91;&#x63;&#104;&#x65;&#110;&#x67;&#x75;&#97;&#x6e;&#x63;&#104;&#x2e;&#46;&#x2e;&#64;&#103;&#109;&#x61;&#x69;&#x6c;&#46;&#x63;&#111;&#x6d;&#x5d;&#40;&#x29;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#x6d;&#x61;&#105;&#108;&#x74;&#x6f;&#58;&#x5b;&#112;&#111;&#x6e;&#x2e;&#46;&#46;&#x40;&#103;&#x6f;&#111;&#103;&#108;&#x65;&#x67;&#114;&#111;&#x75;&#x70;&#x73;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#x29;">&#x5b;&#112;&#111;&#x6e;&#x2e;&#46;&#46;&#x40;&#103;&#x6f;&#111;&#103;&#108;&#x65;&#x67;&#114;&#111;&#x75;&#x70;&#x73;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#x29;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器...</li>
</ol>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>阅读更多 &gt;&gt;</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p><a href="">显示删减掉的内容</a></p>
</blockquote>
<p><img src="" alt=""> SevenCat <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-23</p>
<p>其他收件人：</p>
<p>大家在什么项目上用到并行编程？
<a href="">显示删减掉的内容</a>
<img src="" alt=""> qiaojie <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-23</p>
<p>其他收件人：</p>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1) = 5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？
<a href="">显示删减掉的内容</a></p>
<p><img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-23</p>
<p>其他收件人：</p>
<p>多谢大牛指教。我之所以提到并行化循环，是因为我以前实习过的公司的解决方案就是以data parallel模型的把循环并行化为主，其实新编写的代
码也可以用他们的技术。我之所以要提到遗留代码，是因为如果针对只对遗留代码的循环进行并行化就已经能取得比较可观的speedup(如果本身该循环是
热点，经过一些指导被程序员正确改成independent的之后即可并行化)，同时又不会引入太多的并行编程的复杂度。我原来测试它的时候一般1-3
个小时就能出结果，speedup在1.2~1.6之间(dual core, quad core 2.X)。</p>
<p>另外想请教您的实际工作中一般适用什么样的并行算法？任务分解(如TBB)？还是数据分解？</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>On 3月23日, 上午3时09分, Alleluia <a href="&#109;&#x61;&#105;&#x6c;&#x74;&#x6f;&#x3a;&#91;&#x61;&#108;&#108;&#117;&#108;&#46;&#46;&#46;&#x40;&#x67;&#x6d;&#x61;&#x69;&#108;&#x2e;&#99;&#111;&#109;&#x5d;&#x28;&#x29;">&#91;&#x61;&#108;&#108;&#117;&#108;&#46;&#46;&#46;&#x40;&#x67;&#x6d;&#x61;&#x69;&#108;&#x2e;&#99;&#111;&#109;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>我不是搞体系结构的.但是我认为目前来说做Parallelism的人首先不是去熟悉什么API或者Libarary,而是要熟悉两样东西体系结构和算
法.没有这两样,几乎写不出什么高效率的并行程序.当然你的需求只是并行化循环这种简单的东西当然可以里例外.呵呵.
我觉得你最好放弃用GPGPU去搞遗留代码的想法.现在市面上的GPU产品无论是A记的还是N记的其编程架构与CPU完全不同,你不要想把一个循环简单
的porting到GPU上就能并行了.那是几乎不可能的,比如最简单的你如何处理branch?如果branch非常多,divergence会把速
度拖得比CPU版本还慢.你如何处理CPU代码里的数组随机访问,在GPU上无论是片上的还是片外的内存是不能随机访问的,最要命的是没有cache,
随机访问的代价极其高昂.你几乎需要把CPU上的代码面目全非地从新写一遍,遗留代码除了用作调试测试做结果比对之外几乎要全部抛弃.</p>
<p>On 3月23日, 上午6时42分, Guancheng Chen <a href="&#x6d;&#x61;&#105;&#108;&#116;&#111;&#58;&#x5b;&#x63;&#104;&#x65;&#x6e;&#103;&#117;&#x61;&#110;&#99;&#x68;&#46;&#46;&#x2e;&#64;&#103;&#109;&#x61;&#x69;&#x6c;&#x2e;&#99;&#111;&#109;&#x5d;&#40;&#41;">&#x5b;&#x63;&#104;&#x65;&#x6e;&#103;&#117;&#x61;&#110;&#99;&#x68;&#46;&#46;&#x2e;&#64;&#103;&#109;&#x61;&#x69;&#x6c;&#x2e;&#99;&#111;&#109;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>恩 您也是搞体系结构的么？
现在我在跟瑞典这边的爱立信合作做毕设 不过对象不是他们的Erlang 而是传统的C/C++程序 下半年可能我也去搞GPGPU了 因为它的
data parallel模型对遗留代码的并行化很有搞头，现在我粗略的想法是把Compute sensitive的任务放一部分到GPU上去做，
当然我也对GPU目前的一些限制有所了解 但是一些探索工作还是非常值得的 到时候还想向前辈多多请教</p>
<p>On 3月22日, 下午11时30分, Alleluia <a href="&#109;&#97;&#105;&#108;&#116;&#x6f;&#x3a;&#91;&#x61;&#x6c;&#x6c;&#x75;&#x6c;&#46;&#x2e;&#46;&#x40;&#x67;&#x6d;&#97;&#105;&#108;&#46;&#99;&#111;&#x6d;&#93;&#x28;&#41;">&#91;&#x61;&#x6c;&#x6c;&#x75;&#x6c;&#46;&#x2e;&#46;&#x40;&#x67;&#x6d;&#97;&#105;&#108;&#46;&#99;&#111;&#x6d;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>Heterogeneous目前来看也是一个暂时的过渡性的东西. Heterogeneous架构最大的问题还是硬件,CPU和GPU之间的
PCIE2的bus带宽太窄了.在上面来回传递一次几M的内存可能需要化掉500us左右.如果一个算法本来就是在3-4ms级别的,你要用GPU去优
化,内存带宽的消耗就占了1/10,这是非常可怕的事情.或许像AMD那种Fusion架构是一种趋势,但是目前来说没有太大的进展.貌似AMD出了一
款混合的CPU,但是貌似还没有看到有多大的优势.
On 3月23日, 上午5时02分, Guancheng Chen <a href="&#109;&#x61;&#x69;&#x6c;&#x74;&#111;&#58;&#91;&#x63;&#x68;&#101;&#110;&#103;&#x75;&#x61;&#x6e;&#x63;&#104;&#x2e;&#46;&#46;&#x40;&#103;&#x6d;&#97;&#105;&#x6c;&#46;&#99;&#111;&#x6d;&#x5d;&#40;&#41;">&#91;&#x63;&#x68;&#101;&#110;&#103;&#x75;&#x61;&#x6e;&#x63;&#104;&#x2e;&#46;&#46;&#x40;&#103;&#x6d;&#97;&#105;&#x6c;&#46;&#99;&#111;&#x6d;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>我觉得现有的OpenCL确实非常不成熟，但是从纯性能角度上来讲，我看好Heterogeneous架构，尽管它们的编程难度太大，就像前面提到的不
同架构需要做不同优化等。CPU的性能是latency-oriented，GPU是throughput-oriented,Intel的
Larrabee虽然现在来看不成功，但是业界都在朝着那个方向努力。</p>
<p>On 3月22日, 下午6时18分, windstorm <a href="&#x6d;&#97;&#105;&#x6c;&#x74;&#111;&#58;&#x5b;&#x6c;&#105;&#x6b;&#x75;&#x6e;&#97;&#114;&#109;&#x73;&#116;&#114;&#x2e;&#46;&#46;&#x40;&#103;&#109;&#x61;&#105;&#x6c;&#46;&#x63;&#111;&#109;&#93;&#x28;&#x29;">&#x5b;&#x6c;&#105;&#x6b;&#x75;&#x6e;&#97;&#114;&#109;&#x73;&#116;&#114;&#x2e;&#46;&#46;&#x40;&#103;&#109;&#x61;&#105;&#x6c;&#46;&#x63;&#111;&#109;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>实在是不能同意你更多......很早很早以前我就在这里和人争论过，GPU的并行计算平台不可能一统天下的。CUDA也不是救世主。OpenCL更不是。</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Alleluia <a href="&#x6d;&#97;&#105;&#108;&#x74;&#x6f;&#58;&#x5b;&#97;&#x6c;&#108;&#x75;&#x6c;&#46;&#46;&#x2e;&#64;&#x67;&#x6d;&#97;&#105;&#x6c;&#46;&#99;&#x6f;&#109;&#x5d;&#40;&#41;">&#x5b;&#97;&#x6c;&#108;&#x75;&#x6c;&#46;&#46;&#x2e;&#64;&#x67;&#x6d;&#97;&#105;&#x6c;&#46;&#99;&#x6f;&#109;&#x5d;&#40;&#41;</a>:</p>
<blockquote>
<p>Parallelism 说到底是算法问题.Parallelism与Concurrency不同,Concurrency所面对的问题相对的单一可以
让一群有经验的专家来实现一套通用库或者语言来提供一个基本的编程框架.而在Parallelism上,具体的不同问题,其所需要并行的算法是根本不同
的.原因在于不同的问题,其内部的DataDependency的结构完全不同,不同的Data Dependency的结构,需要构造不同的算法.即
便是相同的Data Dependency,在不同的颗粒度下，在不同的硬件条件下所采用的算法也是完全不同的.因为一旦出现Data
Dependency也就意味着并行计算模块之间需要进行通信.从以计算节点为单位的分布式并行,到多核CPU上的Numa结构,到SIMD上的向量处
理器,其计算单元之间的通信手段,通信效率简直天差地别.比如说,在SMP上最常见的并行算法,work stealing也就是Intel的TBB,
是建立在两个条件下第一个是CPU的Cache机制上,这使得通常在内存的之间的数据搬运消耗非常小,第二个是SMP上计算单元相对的少,因此每个计算
单元被分配到的任务就相对的重。其开销远远大于通信的开销,因此这种机制在SMP上相对的划算.但是如果你要在GPU上做Work Stealing就
完全不可行,因为GPU的运算单元数量极多,被分配到的任务就相对来说的非常轻量,CUDA上的一个thread很多时候运算一次的时间不会超过
10us,而一次跨Block的线程之间的通信开销就往往要达到100us左右,再加上目前GPU上的Cache机制非常落后导致了需要频繁的通信开销
的Work Stealing在GPU上是非常不划算得.
所以我个人认为在硬件架构没有更多的突破之前,OpenCL这种东西是没有任何生命力的.不要说CPU的并行与GPU之间差异巨大,就是不同的GPU之
间AMD与Nvidia两个也是各自为政,一个平台上跑得非常快的东西,在另外一个平台极大的可能是龟速.其最终的结果估计就是跟Java的
write once run everywhere一样是个大笑话.</p>
<p>On 3月22日, 下午2时06分, Guancheng Chen <a href="&#x6d;&#97;&#105;&#x6c;&#x74;&#111;&#x3a;&#91;&#99;&#104;&#101;&#110;&#103;&#x75;&#x61;&#x6e;&#x63;&#104;&#46;&#46;&#46;&#64;&#x67;&#109;&#x61;&#x69;&#108;&#46;&#99;&#111;&#x6d;&#93;&#40;&#41;">&#91;&#99;&#104;&#101;&#110;&#103;&#x75;&#x61;&#x6e;&#x63;&#104;&#46;&#46;&#46;&#64;&#x67;&#109;&#x61;&#x69;&#108;&#46;&#99;&#111;&#x6d;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>On 3月22日, 上午2时20分, Tinyfool <a href="&#109;&#x61;&#105;&#108;&#x74;&#x6f;&#x3a;&#91;&#116;&#105;&#110;&#121;&#x66;&#x2e;&#46;&#46;&#64;&#x67;&#109;&#97;&#x69;&#108;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#41;">&#91;&#116;&#105;&#110;&#121;&#x66;&#x2e;&#46;&#46;&#64;&#x67;&#109;&#97;&#x69;&#108;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#109;&#97;&#105;&#x6c;&#x74;&#111;&#x3a;&#x5b;&#106;&#x65;&#x2e;&#x2e;&#x2e;&#x40;&#108;&#105;&#x76;&#101;&#x2e;&#99;&#111;&#x6d;&#x5d;&#x28;&#41;">&#x5b;&#106;&#x65;&#x2e;&#x2e;&#x2e;&#x40;&#108;&#105;&#x76;&#101;&#x2e;&#99;&#111;&#x6d;&#x5d;&#x28;&#41;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#109;&#x61;&#105;&#108;&#116;&#x6f;&#x3a;&#x5b;&#x63;&#x68;&#101;&#110;&#103;&#117;&#x61;&#110;&#x63;&#104;&#46;&#46;&#46;&#x40;&#103;&#x6d;&#97;&#105;&#108;&#46;&#x63;&#x6f;&#x6d;&#93;&#x28;&#41;">&#x5b;&#x63;&#x68;&#101;&#110;&#103;&#117;&#x61;&#110;&#x63;&#104;&#46;&#46;&#46;&#x40;&#103;&#x6d;&#97;&#105;&#108;&#46;&#x63;&#x6f;&#x6d;&#93;&#x28;&#41;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#x6f;&#58;&#x5b;&#x70;&#111;&#110;&#x2e;&#x2e;&#46;&#64;&#103;&#111;&#111;&#103;&#108;&#101;&#103;&#114;&#x6f;&#117;&#x70;&#115;&#46;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#41;">&#x5b;&#x70;&#111;&#110;&#x2e;&#x2e;&#46;&#64;&#103;&#111;&#111;&#103;&#108;&#101;&#103;&#114;&#x6f;&#117;&#x70;&#115;&#46;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#41;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育...</p>
</li>
</ol>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>阅读更多 &gt;&gt;
<a href="">显示删减掉的内容</a>
<img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-23</p>
<p>其他收件人：</p>
<p>Yeap.</p>
<p>On 3月23日, 上午3时37分, windstorm <a href="&#x6d;&#97;&#x69;&#x6c;&#x74;&#111;&#x3a;&#91;&#x6c;&#x69;&#107;&#117;&#x6e;&#97;&#x72;&#109;&#115;&#116;&#114;&#46;&#x2e;&#x2e;&#x40;&#x67;&#109;&#x61;&#x69;&#108;&#46;&#99;&#111;&#x6d;&#x5d;&#x28;&#41;">&#91;&#x6c;&#x69;&#107;&#117;&#x6e;&#97;&#x72;&#109;&#115;&#116;&#114;&#46;&#x2e;&#x2e;&#x40;&#x67;&#109;&#x61;&#x69;&#108;&#46;&#99;&#111;&#x6d;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>女生？LJJ？</p>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>&gt;</p>
<blockquote>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Guancheng Chen <a href="&#x6d;&#x61;&#105;&#x6c;&#x74;&#111;&#x3a;&#x5b;&#x63;&#x68;&#x65;&#x6e;&#x67;&#x75;&#97;&#110;&#x63;&#104;&#46;&#46;&#46;&#x40;&#x67;&#x6d;&#97;&#x69;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#93;&#40;&#41;">&#x5b;&#x63;&#x68;&#x65;&#x6e;&#x67;&#x75;&#97;&#110;&#x63;&#104;&#46;&#46;&#46;&#x40;&#x67;&#x6d;&#97;&#x69;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#93;&#40;&#41;</a>:</p>
<blockquote>
<p>恩</p>
<p>第二点其实我就是指程序员根据他自己的程序领域选择合适的并行技术。Top Language真是藏龙卧虎啊。你是在Boulder么?我一个大学女同
学在你那读MIS的phd</p>
<p>On 3月23日, 上午12时04分, windstorm <a href="&#x6d;&#97;&#x69;&#108;&#116;&#111;&#x3a;&#x5b;&#x6c;&#x69;&#x6b;&#x75;&#x6e;&#97;&#114;&#109;&#115;&#116;&#x72;&#46;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#97;&#105;&#x6c;&#x2e;&#99;&#111;&#109;&#93;&#40;&#41;">&#x5b;&#x6c;&#x69;&#x6b;&#x75;&#x6e;&#97;&#114;&#109;&#115;&#116;&#x72;&#46;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#97;&#105;&#x6c;&#x2e;&#99;&#111;&#109;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>全民并行编程的时代，只有在全民能够并行编程的时候才会到来嘛，现在不是这个时候</p>
<p>我个人倾向于等待一个比较好的统一性架构。两条路：</p>
<p>一是某一个全新概念的提出，这个要看学术界的努力，而且在某种意义上讲，学术界搞出一个真正可行的并行架构的可能性比工业界更高。虽说今天多核的发展是工业界引 领的，但是点子还是最早学术界提出的。典型的有几个：斯坦福的Hydra（1996），斯坦福的Imagine(2000)，MIT的RAW（2002），以及 UT奥斯丁的TRIPS（2003）。在这个问题上，是不得不佩服美国的创造力，要知道直到在2000年左右，所有的人都还在为处理器频率按照摩尔定律翻翻而狂 热，美国的顶尖研究员就早已看到了这条路的尽头并指出未来处理器的发展之路。</p>
<p>二是你用现有的架构，但是application引导。如果要找一个面向多application
domain的话，刚才说了，本来看好Larrabee，因为它的架构解决了CUDA一个很大的潜在问题，而且允许现有程序员不经过任何特殊training就 上手编程，包括图形图像，科学计算，或者网络处理，各个领域。</p>
<p>不过可能就是因为这个solution的过于理想化导致结构的过于复杂化，才让其目前暂时流产。</p>
<p>总的来说，现在的问题就是软件发展不成熟，硬件发展不完善，你没法靠程序员决定使用什么并行技术，完全靠应用主导，这套技术在这个应用上如鱼得水，在那个应用上 完全不罩，作为程序员，有什么办法？</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Guancheng Chen <a href="&#x6d;&#97;&#x69;&#108;&#x74;&#111;&#x3a;&#x5b;&#x63;&#104;&#x65;&#110;&#103;&#117;&#x61;&#110;&#99;&#x68;&#46;&#x2e;&#x2e;&#64;&#103;&#109;&#x61;&#105;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#40;&#41;">&#x5b;&#x63;&#104;&#x65;&#110;&#103;&#117;&#x61;&#110;&#99;&#x68;&#46;&#x2e;&#x2e;&#64;&#103;&#109;&#x61;&#105;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#40;&#41;</a>:</p>
<blockquote>
<p>教育以人为本，最终决定使用何种并行技术的还是程序员。目前业界对程序员并没有并行编程的技能要求，全民并行编程的时代什么时候才能到来？这是个问
题。</p>
<p>On 3月22日, 下午10时41分, windstorm <a href="&#109;&#x61;&#x69;&#x6c;&#x74;&#111;&#x3a;&#91;&#x6c;&#105;&#107;&#117;&#x6e;&#97;&#114;&#109;&#115;&#x74;&#x72;&#x2e;&#x2e;&#46;&#64;&#103;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#40;&#41;">&#91;&#x6c;&#105;&#107;&#117;&#x6e;&#97;&#114;&#109;&#115;&#x74;&#x72;&#x2e;&#x2e;&#46;&#64;&#103;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>Larrabee当初我还是很看好的，它的架构比其他的更像一个统一的方案，可惜后来Intel自己经验不足搞不好。</p>
<p>OPENCL还是主要面向multimedia吧，CUDA/OpenCL在业界代表了流处理的方向，从GPU针对任务的角度讲是好的。其他的就算了。就像Al leluia说的那样，在硬件架构没有更多的突破之前，不说没有生命力，至少想取得任何进一步的突破都太难。</p>
<p>现在这个领域，你吹你的水，我吹我的水。至于谁的泡泡大，我看不清。所以真要选东西学，最好还是针对自己的application选靠谱。这也是并行编程教育难 的问题。大家需求完全不一样。</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Guancheng Chen <a href="&#109;&#97;&#x69;&#x6c;&#x74;&#x6f;&#x3a;&#91;&#x63;&#104;&#101;&#110;&#103;&#x75;&#x61;&#x6e;&#x63;&#104;&#x2e;&#46;&#x2e;&#64;&#103;&#109;&#97;&#x69;&#x6c;&#46;&#x63;&#111;&#109;&#x5d;&#x28;&#x29;">&#91;&#x63;&#104;&#101;&#110;&#103;&#x75;&#x61;&#x6e;&#x63;&#104;&#x2e;&#46;&#x2e;&#64;&#103;&#109;&#97;&#x69;&#x6c;&#46;&#x63;&#111;&#109;&#x5d;&#x28;&#x29;</a>:</p>
<blockquote>
<p>我觉得现有的OpenCL确实非常不成熟，但是从纯性能角度上来讲，我看好Heterogeneous架构，尽管它们的编程难度太大，就像前面提到的不
同架构需要做不同优化等。CPU的性能是latency-oriented，GPU是throughput-oriented,Intel的
Larrabee虽然现在来看不成功，但是业界都在朝着那个方向努力。</p>
<p>On 3月22日, 下午6时18分, windstorm <a href="&#x6d;&#x61;&#105;&#108;&#116;&#111;&#58;&#x5b;&#x6c;&#105;&#107;&#x75;&#110;&#97;&#114;&#109;&#x73;&#x74;&#114;&#x2e;&#46;&#46;&#64;&#x67;&#x6d;&#x61;&#105;&#108;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#x28;&#41;">&#x5b;&#x6c;&#105;&#107;&#x75;&#110;&#97;&#114;&#109;&#x73;&#x74;&#114;&#x2e;&#46;&#46;&#64;&#x67;&#x6d;&#x61;&#105;&#108;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>实在是不能同意你更多......很早很早以前我就在这里和人争论过，GPU的并行计算平台不可能一统天下的。CUDA也不是救世主。OpenCL更不是。</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Alleluia <a href="&#x6d;&#97;&#x69;&#108;&#116;&#x6f;&#x3a;&#x5b;&#x61;&#108;&#x6c;&#x75;&#x6c;&#46;&#46;&#x2e;&#x40;&#103;&#109;&#97;&#105;&#108;&#46;&#x63;&#x6f;&#x6d;&#93;&#40;&#41;">&#x5b;&#x61;&#108;&#x6c;&#x75;&#x6c;&#46;&#46;&#x2e;&#x40;&#103;&#109;&#97;&#105;&#108;&#46;&#x63;&#x6f;&#x6d;&#93;&#40;&#41;</a>:</p>
<blockquote>
<p>Parallelism 说到底是算法问题.Parallelism与Concurrency不同,Concurrency所面对的问题相对的单一可以
让一群有经验的专家来实现一套通用库或者语言来提供一个基本的编程框架.而在Parallelism上,具体的不同问题,其所需要并行的算法是根本不同
的.原因在于不同的问题,其内部的DataDependency的结构完全不同,不同的Data Dependency的结构,需要构造不同的算法.即
便是相同的Data Dependency,在不同的颗粒度下，在不同的硬件条件下所采用的算法也是完全不同的.因为一旦出现Data
Dependency也就意味着并行计算模块之间需要进行通信.从以计算节点为单位的分布式并行,到多核CPU上的Numa结构,到SIMD上的向量处
理器,其计算单元之间的通信手段,通信效率简直天差地别.比如说,在SMP上最常见的并行算法,work stealing也就是Intel的TBB,
是建立在两个条件下第一个是CPU的Cache机制上,这使得通常在内存的之间的数据搬运消耗非常小,第二个是SMP上计算单元相对的少,因此每个计算
单元被分配到的任务就相对的重。其开销远远大于通信的开销,因此这种机制在SMP上相对的划算.但是如果你要在GPU上做Work Stealing就
完全不可行,因为GPU的运算单元数量极多,被分配到的任务就相对来说的非常轻量,CUDA上的一个thread很多时候运算一次的时间不会超过
10us,而一次跨Block的线程之间的通信开销就往往要达到100us左右,再加上目前GPU上的Cache机制非常落后导致了需要频繁的通信开销
的Work Stealing在GPU上是非常不划算得.
所以我个人认为在硬件架构没有更多的突破之前,OpenCL这种东西是没有任何生命力的.不要说CPU的并行与GPU之间差异巨大,就是不同的GPU之
间AMD与Nvidia两个也是各自为政,一个平台上跑得非常快的东西,在另外一个平台极大的可能是龟速.其最终的结果估计就是跟Java的
write once run everywhere一样是个大笑话.</p>
<p>On 3月22日, 下午2时06分, Guancheng Chen <a href="&#109;&#x61;&#x69;&#x6c;&#x74;&#111;&#58;&#x5b;&#x63;&#104;&#101;&#110;&#103;&#117;&#x61;&#110;&#99;&#x68;&#46;&#x2e;&#46;&#x40;&#103;&#109;&#x61;&#x69;&#108;&#x2e;&#99;&#x6f;&#109;&#x5d;&#40;&#41;">&#x5b;&#x63;&#104;&#101;&#110;&#103;&#117;&#x61;&#110;&#99;&#x68;&#46;&#x2e;&#46;&#x40;&#103;&#109;&#x61;&#x69;&#108;&#x2e;&#99;&#x6f;&#109;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>On 3月22日, 上午2时20分, Tinyfool <a href="&#x6d;&#97;&#x69;&#x6c;&#x74;&#111;&#58;&#x5b;&#116;&#105;&#x6e;&#x79;&#102;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#97;&#105;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#41;">&#x5b;&#116;&#105;&#x6e;&#x79;&#102;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#97;&#105;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#x6d;&#x61;&#105;&#108;&#x74;&#x6f;&#58;&#91;&#x6a;&#101;&#x2e;&#46;&#x2e;&#x40;&#x6c;&#105;&#118;&#101;&#46;&#x63;&#x6f;&#109;&#93;&#x28;&#41;">&#91;&#x6a;&#101;&#x2e;&#46;&#x2e;&#x40;&#x6c;&#105;&#118;&#101;&#46;&#x63;&#x6f;&#109;&#93;&#x28;&#41;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#109;&#97;&#105;&#108;&#x74;&#x6f;&#58;&#91;&#x63;&#x68;&#x65;&#x6e;&#x67;&#x75;&#97;&#x6e;&#x63;&#104;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#109;&#x61;&#105;&#108;&#46;&#x63;&#111;&#109;&#x5d;&#40;&#x29;">&#91;&#x63;&#x68;&#x65;&#x6e;&#x67;&#x75;&#97;&#x6e;&#x63;&#104;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#109;&#x61;&#105;&#108;&#46;&#x63;&#111;&#109;&#x5d;&#40;&#x29;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#109;&#x61;&#105;&#108;&#116;&#111;&#58;&#91;&#112;&#111;&#x6e;&#46;&#46;&#46;&#64;&#x67;&#111;&#x6f;&#103;&#x6c;&#x65;&#x67;&#114;&#111;&#x75;&#112;&#x73;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#41;">&#91;&#112;&#111;&#x6e;&#46;&#46;&#46;&#64;&#x67;&#111;&#x6f;&#103;&#x6c;&#x65;&#x67;&#114;&#111;&#x75;&#112;&#x73;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#41;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，...</li>
</ol>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>阅读更多 &gt;&gt;
<a href="">显示删减掉的内容</a></p>
</blockquote>
<p><img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-23</p>
<p>其他收件人：</p>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>On 3月23日, 上午9时15分, qiaojie <a href="&#109;&#97;&#105;&#108;&#x74;&#111;&#x3a;&#x5b;&#x71;&#105;&#x61;&#x6f;&#x2e;&#46;&#x2e;&#x40;&#x67;&#109;&#97;&#x69;&#108;&#46;&#x63;&#x6f;&#x6d;&#93;&#40;&#x29;">&#x5b;&#x71;&#105;&#x61;&#x6f;&#x2e;&#46;&#x2e;&#x40;&#x67;&#109;&#97;&#x69;&#108;&#46;&#x63;&#x6f;&#x6d;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1) =
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？
<a href="">显示删减掉的内容</a>
<img src="" alt=""> qiaojie <img src="" alt=""></p>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-23</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>目前正在写的是一个软件渲染器，采用了光栅化和光线跟踪混合算法，渲染算法已经完全并行化了，</p>
<p>在4核系统上基本可以达到线性加速比，更多核的系统暂时还没测试。kd-tree的构造暂时还没有并
行化，以后有空了再研究。</p>
<p>2010/3/23 Guancheng Chen <a href="&#109;&#x61;&#x69;&#108;&#116;&#111;&#58;&#x5b;&#99;&#104;&#101;&#x6e;&#x67;&#x75;&#x2e;&#x2e;&#46;&#x40;&#x67;&#x6d;&#x61;&#105;&#108;&#x2e;&#99;&#111;&#109;&#x5d;&#40;&#x29;">&#x5b;&#99;&#104;&#101;&#x6e;&#x67;&#x75;&#x2e;&#x2e;&#46;&#x40;&#x67;&#x6d;&#x61;&#105;&#108;&#x2e;&#99;&#111;&#109;&#x5d;&#40;&#x29;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？
On 3月23日, 上午9时15分, qiaojie <a href="&#x6d;&#97;&#105;&#x6c;&#116;&#111;&#x3a;&#91;&#x71;&#x69;&#97;&#x6f;&#46;&#46;&#x2e;&#x40;&#103;&#x6d;&#97;&#x69;&#108;&#46;&#99;&#111;&#109;&#93;&#40;&#41;">&#91;&#x71;&#x69;&#97;&#x6f;&#46;&#46;&#x2e;&#x40;&#103;&#x6d;&#97;&#x69;&#108;&#46;&#99;&#111;&#109;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1) =
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a></p>
<p><img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-24</p>
<p>其他收件人：</p>
<p>Nice 大胆预测Linear speedup应该是每个程序员十年后的目标 呵呵</p>
<p>On 3月23日, 上午10时43分, qiaojie <a href="&#109;&#x61;&#x69;&#108;&#116;&#x6f;&#58;&#91;&#113;&#105;&#x61;&#x6f;&#46;&#x2e;&#x2e;&#64;&#x67;&#109;&#97;&#105;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#93;&#40;&#41;">&#91;&#113;&#105;&#x61;&#x6f;&#46;&#x2e;&#x2e;&#64;&#x67;&#109;&#97;&#105;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>目前正在写的是一个软件渲染器，采用了光栅化和光线跟踪混合算法，渲染算法已经完全并行化了，
在4核系统上基本可以达到线性加速比，更多核的系统暂时还没测试。kd-tree的构造暂时还没有并
行化，以后有空了再研究。</p>
<p>2010/3/23 Guancheng Chen <a href="&#x6d;&#x61;&#105;&#108;&#116;&#x6f;&#58;&#91;&#99;&#104;&#101;&#110;&#103;&#117;&#97;&#110;&#99;&#104;&#x2e;&#46;&#46;&#x40;&#103;&#x6d;&#x61;&#x69;&#x6c;&#46;&#99;&#111;&#109;&#x5d;&#x28;&#41;">&#91;&#99;&#104;&#101;&#110;&#103;&#117;&#97;&#110;&#99;&#104;&#x2e;&#46;&#46;&#x40;&#103;&#x6d;&#x61;&#x69;&#x6c;&#46;&#99;&#111;&#109;&#x5d;&#x28;&#41;</a></p>
</blockquote>
<p>&gt;
&gt;
&gt;</p>
<blockquote>
<blockquote>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？</p>
<p>On 3月23日, 上午9时15分, qiaojie <a href="&#109;&#x61;&#x69;&#x6c;&#116;&#111;&#58;&#x5b;&#113;&#x69;&#x61;&#111;&#x2e;&#46;&#x2e;&#64;&#103;&#x6d;&#x61;&#105;&#108;&#46;&#99;&#x6f;&#109;&#x5d;&#40;&#41;">&#x5b;&#113;&#x69;&#x61;&#111;&#x2e;&#46;&#x2e;&#64;&#103;&#x6d;&#x61;&#105;&#108;&#46;&#99;&#x6f;&#109;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1) =
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？</p>
</blockquote>
<p> To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> longshanksmo <img src="" alt=""></p>
</blockquote>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-24</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<h2 id="-cerl-2-0-">凑个热闹，也来个广告：CERL 2.0初具雏形。</h2>
<p>反者道之动，弱者道之用
<a href="">longsh...@gmail.com</a>
<a href="http://blog.csdn.net/longshanks/" target="_blank"><a href="http://blog.csdn.net/longshanks/">http://blog.csdn.net/longshanks/</a></a>
wave开通
<a href="">显示删减掉的内容</a></p>
<p><img src="" alt=""> qiaojie <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-24</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>不是所有的程序都需要并行化的，能用串行化解决的问题没必要并行，所以即使将来many-core系统成为主流，大部分程序员也没必要去搞并行计算。</p>
<p>我觉得未来的主流应该是类似cell这样一颗全功能核心带众多协处理核心的异构系统，这样才能达到最优的 性能/核心面积比。
2010/3/24 Guancheng Chen <a href="&#x6d;&#97;&#105;&#x6c;&#116;&#x6f;&#x3a;&#91;&#x63;&#104;&#x65;&#110;&#103;&#117;&#46;&#x2e;&#46;&#x40;&#x67;&#109;&#x61;&#105;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#93;&#x28;&#41;">&#91;&#x63;&#104;&#x65;&#110;&#103;&#117;&#46;&#x2e;&#46;&#x40;&#x67;&#109;&#x61;&#105;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#93;&#x28;&#41;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>Nice 大胆预测Linear speedup应该是每个程序员十年后的目标 呵呵
On 3月23日, 上午10时43分, qiaojie <a href="&#x6d;&#97;&#x69;&#x6c;&#116;&#111;&#x3a;&#x5b;&#x71;&#x69;&#97;&#111;&#x2e;&#46;&#x2e;&#64;&#x67;&#109;&#97;&#105;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#x28;&#41;">&#x5b;&#x71;&#x69;&#97;&#111;&#x2e;&#46;&#x2e;&#64;&#x67;&#109;&#97;&#105;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>目前正在写的是一个软件渲染器，采用了光栅化和光线跟踪混合算法，渲染算法已经完全并行化了，
在4核系统上基本可以达到线性加速比，更多核的系统暂时还没测试。kd-tree的构造暂时还没有并
行化，以后有空了再研究。</p>
<p>2010/3/23 Guancheng Chen <a href="&#109;&#x61;&#x69;&#108;&#x74;&#111;&#x3a;&#x5b;&#99;&#x68;&#101;&#x6e;&#103;&#x75;&#x61;&#x6e;&#99;&#x68;&#46;&#x2e;&#x2e;&#x40;&#103;&#109;&#x61;&#x69;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#93;&#40;&#41;">&#x5b;&#99;&#x68;&#101;&#x6e;&#103;&#x75;&#x61;&#x6e;&#99;&#x68;&#46;&#x2e;&#x2e;&#x40;&#103;&#109;&#x61;&#x69;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#93;&#40;&#41;</a></p>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>&gt;
&gt;
&gt;</p>
<blockquote>
<blockquote>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？</p>
<p>On 3月23日, 上午9时15分, qiaojie <a href="&#x6d;&#97;&#x69;&#108;&#x74;&#x6f;&#58;&#x5b;&#x71;&#x69;&#97;&#x6f;&#46;&#46;&#46;&#64;&#x67;&#x6d;&#x61;&#x69;&#108;&#46;&#x63;&#111;&#x6d;&#x5d;&#x28;&#41;">&#x5b;&#x71;&#x69;&#97;&#x6f;&#46;&#46;&#46;&#64;&#x67;&#x6d;&#x61;&#x69;&#108;&#46;&#x63;&#111;&#x6d;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1) =
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？</p>
</blockquote>
<p> To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> 机械唯物主义 : linjunhalida <img src="" alt=""></p>
</blockquote>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-24</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>我猜测未来的主流是数据中心，动态分配运算，存储资源。CPU，内存集群。
加上本地终端，运行一些本地进程，比如GUI，实时视频采集和分析什么的。CPU＋GPU。
根据需求和成本来考虑程序在本地或者数据中心。
其实好像这就是现在的状况？
未来的状况还是要局限于成本和性能，
如果瓶颈在数据传输，那么中心化趋势会很明显。
如果瓶颈在运算，那么程序员要花很多时间在并行处理上。
2010/3/24 qiaojie <a href="&#x6d;&#97;&#x69;&#108;&#x74;&#x6f;&#58;&#x5b;&#x71;&#105;&#97;&#x2e;&#46;&#46;&#x40;&#103;&#109;&#97;&#x69;&#108;&#46;&#99;&#111;&#x6d;&#x5d;&#x28;&#41;">&#x5b;&#x71;&#105;&#97;&#x2e;&#46;&#46;&#x40;&#103;&#109;&#97;&#x69;&#108;&#46;&#99;&#111;&#x6d;&#x5d;&#x28;&#41;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>不是所有的程序都需要并行化的，能用串行化解决的问题没必要并行，所以即使将来many-core系统成为主流，大部分程序员也没必要去搞并行计算。</p>
<p>我觉得未来的主流应该是类似cell这样一颗全功能核心带众多协处理核心的异构系统，这样才能达到最优的 性能/核心面积比。
2010/3/24 Guancheng Chen <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#x5b;&#x63;&#x68;&#101;&#x6e;&#x67;&#117;&#46;&#46;&#x2e;&#x40;&#103;&#109;&#97;&#x69;&#x6c;&#46;&#99;&#x6f;&#109;&#x5d;&#40;&#41;">&#x5b;&#x63;&#x68;&#101;&#x6e;&#x67;&#117;&#46;&#46;&#x2e;&#x40;&#103;&#109;&#97;&#x69;&#x6c;&#46;&#99;&#x6f;&#109;&#x5d;&#40;&#41;</a></p>
<p>Nice 大胆预测Linear speedup应该是每个程序员十年后的目标 呵呵
On 3月23日, 上午10时43分, qiaojie <a href="&#109;&#97;&#105;&#x6c;&#x74;&#111;&#x3a;&#x5b;&#x71;&#x69;&#x61;&#x6f;&#46;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#97;&#105;&#108;&#46;&#x63;&#111;&#x6d;&#93;&#40;&#41;">&#x5b;&#x71;&#x69;&#x61;&#x6f;&#46;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#97;&#105;&#108;&#46;&#x63;&#111;&#x6d;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>目前正在写的是一个软件渲染器，采用了光栅化和光线跟踪混合算法，渲染算法已经完全并行化了，
在4核系统上基本可以达到线性加速比，更多核的系统暂时还没测试。kd-tree的构造暂时还没有并
行化，以后有空了再研究。</p>
<p>2010/3/23 Guancheng Chen <a href="&#x6d;&#x61;&#105;&#108;&#x74;&#x6f;&#x3a;&#91;&#99;&#104;&#101;&#x6e;&#x67;&#x75;&#x61;&#110;&#99;&#x68;&#46;&#46;&#x2e;&#x40;&#x67;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#93;&#x28;&#41;">&#91;&#99;&#104;&#101;&#x6e;&#x67;&#x75;&#x61;&#110;&#99;&#x68;&#46;&#46;&#x2e;&#x40;&#x67;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#93;&#x28;&#41;</a></p>
<blockquote>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？</p>
<p>On 3月23日, 上午9时15分, qiaojie <a href="&#109;&#97;&#x69;&#108;&#116;&#x6f;&#58;&#x5b;&#113;&#x69;&#97;&#x6f;&#x2e;&#46;&#46;&#64;&#103;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#40;&#41;">&#x5b;&#113;&#x69;&#97;&#x6f;&#x2e;&#46;&#46;&#64;&#103;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1) =
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？</p>
</blockquote>
<p> To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a></p>
<p><img src="" alt=""> Hongzh...@gmail.com <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-24</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>异构平台如果编程复杂度降不下来的话很难流行起来。cell已经死了...
2010/3/24 qiaojie <a href="&#x6d;&#x61;&#105;&#x6c;&#x74;&#111;&#x3a;&#91;&#113;&#105;&#x61;&#46;&#x2e;&#46;&#x40;&#103;&#109;&#x61;&#x69;&#x6c;&#x2e;&#99;&#111;&#x6d;&#93;&#x28;&#x29;">&#91;&#113;&#105;&#x61;&#46;&#x2e;&#46;&#x40;&#103;&#109;&#x61;&#x69;&#x6c;&#x2e;&#99;&#111;&#x6d;&#93;&#x28;&#x29;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>不是所有的程序都需要并行化的，能用串行化解决的问题没必要并行，所以即使将来many-core系统成为主流，大部分程序员也没必要去搞并行计算。</p>
<p>我觉得未来的主流应该是类似cell这样一颗全功能核心带众多协处理核心的异构系统，这样才能达到最优的 性能/核心面积比。
2010/3/24 Guancheng Chen <a href="&#x6d;&#x61;&#x69;&#108;&#x74;&#x6f;&#x3a;&#91;&#99;&#x68;&#x65;&#110;&#x67;&#x75;&#46;&#46;&#x2e;&#x40;&#103;&#x6d;&#97;&#105;&#x6c;&#46;&#99;&#111;&#x6d;&#x5d;&#x28;&#x29;">&#91;&#99;&#x68;&#x65;&#110;&#x67;&#x75;&#46;&#46;&#x2e;&#x40;&#103;&#x6d;&#97;&#105;&#x6c;&#46;&#99;&#111;&#x6d;&#x5d;&#x28;&#x29;</a></p>
<p>Nice 大胆预测Linear speedup应该是每个程序员十年后的目标 呵呵
On 3月23日, 上午10时43分, qiaojie <a href="&#x6d;&#x61;&#x69;&#108;&#x74;&#x6f;&#x3a;&#x5b;&#113;&#105;&#x61;&#x6f;&#x2e;&#46;&#x2e;&#64;&#103;&#x6d;&#x61;&#x69;&#x6c;&#46;&#x63;&#x6f;&#109;&#93;&#x28;&#41;">&#x5b;&#113;&#105;&#x61;&#x6f;&#x2e;&#46;&#x2e;&#64;&#103;&#x6d;&#x61;&#x69;&#x6c;&#46;&#x63;&#x6f;&#109;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>目前正在写的是一个软件渲染器，采用了光栅化和光线跟踪混合算法，渲染算法已经完全并行化了，
在4核系统上基本可以达到线性加速比，更多核的系统暂时还没测试。kd-tree的构造暂时还没有并
行化，以后有空了再研究。</p>
<p>2010/3/23 Guancheng Chen <a href="&#x6d;&#97;&#x69;&#x6c;&#116;&#x6f;&#58;&#91;&#x63;&#104;&#101;&#x6e;&#x67;&#117;&#97;&#x6e;&#99;&#x68;&#46;&#46;&#x2e;&#64;&#x67;&#109;&#97;&#105;&#x6c;&#46;&#x63;&#111;&#109;&#93;&#x28;&#x29;">&#91;&#x63;&#104;&#101;&#x6e;&#x67;&#117;&#97;&#x6e;&#99;&#x68;&#46;&#46;&#x2e;&#64;&#x67;&#109;&#97;&#105;&#x6c;&#46;&#x63;&#111;&#109;&#93;&#x28;&#x29;</a></p>
<blockquote>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？</p>
<p>On 3月23日, 上午9时15分, qiaojie <a href="&#109;&#97;&#105;&#x6c;&#116;&#111;&#58;&#x5b;&#x71;&#105;&#x61;&#111;&#x2e;&#x2e;&#46;&#64;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#40;&#41;">&#x5b;&#x71;&#105;&#x61;&#111;&#x2e;&#x2e;&#46;&#64;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1) =
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？</p>
</blockquote>
<p> To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> qiaojie <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-24</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>说的没错，cell已经成了先烈了。不过这不代表异构的方向不对，CUDA，OpenCL也都是异构平台，以后我们会越来越习惯异构平台的。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#109;&#97;&#105;&#108;&#116;&#x6f;&#x3a;&#91;&#x68;&#111;&#110;&#103;&#122;&#104;&#46;&#46;&#46;&#64;&#x67;&#109;&#97;&#105;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#x28;&#41;">&#91;&#x68;&#111;&#110;&#103;&#122;&#104;&#46;&#46;&#46;&#64;&#x67;&#109;&#97;&#105;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#x28;&#41;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>异构平台如果编程复杂度降不下来的话很难流行起来。cell已经死了...
2010/3/24 qiaojie <a href="&#x6d;&#x61;&#105;&#x6c;&#116;&#x6f;&#58;&#91;&#x71;&#105;&#x61;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#109;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#x29;">&#91;&#x71;&#105;&#x61;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#109;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#x29;</a>
 不是所有的程序都需要并行化的，能用串行化解决的问题没必要并行，所以即使将来many-core系统成为主流，大部分程序员也没必要去搞并行计算。</p>
<p>我觉得未来的主流应该是类似cell这样一颗全功能核心带众多协处理核心的异构系统，这样才能达到最优的 性能/核心面积比。</p>
<p>2010/3/24 Guancheng Chen <a href="&#109;&#x61;&#x69;&#x6c;&#116;&#x6f;&#x3a;&#x5b;&#99;&#x68;&#x65;&#110;&#x67;&#x75;&#46;&#46;&#46;&#64;&#103;&#x6d;&#x61;&#x69;&#x6c;&#46;&#x63;&#x6f;&#109;&#93;&#40;&#41;">&#x5b;&#99;&#x68;&#x65;&#110;&#x67;&#x75;&#46;&#46;&#46;&#64;&#103;&#x6d;&#x61;&#x69;&#x6c;&#46;&#x63;&#x6f;&#109;&#93;&#40;&#41;</a></p>
<p>Nice 大胆预测Linear speedup应该是每个程序员十年后的目标 呵呵
On 3月23日, 上午10时43分, qiaojie <a href="&#109;&#x61;&#x69;&#x6c;&#x74;&#111;&#58;&#91;&#x71;&#x69;&#97;&#x6f;&#46;&#46;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#99;&#x6f;&#109;&#x5d;&#40;&#x29;">&#91;&#x71;&#x69;&#97;&#x6f;&#46;&#46;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#99;&#x6f;&#109;&#x5d;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>目前正在写的是一个软件渲染器，采用了光栅化和光线跟踪混合算法，渲染算法已经完全并行化了，
在4核系统上基本可以达到线性加速比，更多核的系统暂时还没测试。kd-tree的构造暂时还没有并
行化，以后有空了再研究。</p>
<p>2010/3/23 Guancheng Chen <a href="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#x6f;&#x3a;&#91;&#99;&#x68;&#101;&#x6e;&#x67;&#117;&#x61;&#110;&#x63;&#104;&#46;&#46;&#46;&#64;&#103;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#111;&#109;&#93;&#x28;&#41;">&#91;&#99;&#x68;&#101;&#x6e;&#x67;&#117;&#x61;&#110;&#x63;&#104;&#46;&#46;&#46;&#64;&#103;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#111;&#109;&#93;&#x28;&#41;</a></p>
<blockquote>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？</p>
<p>On 3月23日, 上午9时15分, qiaojie <a href="&#109;&#x61;&#105;&#x6c;&#116;&#x6f;&#x3a;&#x5b;&#113;&#105;&#x61;&#x6f;&#x2e;&#46;&#46;&#64;&#103;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#40;&#x29;">&#x5b;&#113;&#105;&#x61;&#x6f;&#x2e;&#46;&#46;&#64;&#103;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1) =
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？</p>
</blockquote>
<p> To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a></p>
<p><img src="" alt=""> sunjoy <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-24</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>挺有意思的，我之前没有接触过并行计算的相关理论，按照你的公式我花了个图，反映并行度、加速比以及CPU核之间的关系。</p>
<p>2010/3/23 qiaojie <a href="&#x6d;&#97;&#105;&#x6c;&#116;&#111;&#58;&#91;&#x71;&#105;&#x61;&#x2e;&#46;&#x2e;&#x40;&#x67;&#109;&#97;&#x69;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#41;">&#91;&#x71;&#105;&#x61;&#x2e;&#46;&#x2e;&#x40;&#x67;&#109;&#97;&#x69;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#41;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1) = 5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？
 To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a></p>
<p>附件 (1)</p>
<p><a href="https://groups.google.com/group/pongba/attach/53e12db326792d31/parallelism.png?part=4&amp;authuser=0&amp;view=1" title="parallelism.png"></a></p>
<p>parallelism.png 23 KB   <a href="https://groups.google.com/group/pongba/attach/53e12db326792d31/parallelism.png?part=4&amp;authuser=0&amp;view=1" target="_blank">查看</a>   <a href="https://groups.google.com/group/pongba/attach/53e12db326792d31/parallelism.png?part=4&amp;authuser=0" target="_blank">下载</a>
<img src="" alt=""> Hongzh...@gmail.com <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-24</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>异构平台从网络处理器算起已经快10年了，现在情况仍然不明朗。就我看到的，异构平台要想高效，就必须向程序员暴露非常多的硬件细节，这必然导致编程的复杂性。曲高和寡，要想渗透到应用程序这一块，我觉得很难。</p>
<p>2010/3/24 qiaojie <a href="&#x6d;&#97;&#x69;&#x6c;&#x74;&#x6f;&#58;&#91;&#x71;&#x69;&#97;&#46;&#x2e;&#46;&#x40;&#x67;&#109;&#x61;&#x69;&#108;&#46;&#99;&#x6f;&#109;&#x5d;&#x28;&#x29;">&#91;&#x71;&#x69;&#97;&#46;&#x2e;&#46;&#x40;&#x67;&#109;&#x61;&#x69;&#108;&#46;&#99;&#x6f;&#109;&#x5d;&#x28;&#x29;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>说的没错，cell已经成了先烈了。不过这不代表异构的方向不对，CUDA，OpenCL也都是异构平台，以后我们会越来越习惯异构平台的。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#x6d;&#x61;&#105;&#x6c;&#x74;&#111;&#x3a;&#x5b;&#x68;&#x6f;&#110;&#103;&#122;&#104;&#46;&#46;&#46;&#64;&#103;&#x6d;&#x61;&#105;&#108;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#x28;&#41;">&#x5b;&#x68;&#x6f;&#110;&#103;&#122;&#104;&#46;&#46;&#46;&#64;&#103;&#x6d;&#x61;&#105;&#108;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#x28;&#41;</a></p>
<p>异构平台如果编程复杂度降不下来的话很难流行起来。cell已经死了...
2010/3/24 qiaojie <a href="&#109;&#x61;&#x69;&#x6c;&#x74;&#x6f;&#58;&#91;&#x71;&#105;&#97;&#x2e;&#x2e;&#46;&#64;&#x67;&#109;&#x61;&#105;&#108;&#46;&#99;&#111;&#x6d;&#x5d;&#x28;&#x29;">&#91;&#x71;&#105;&#97;&#x2e;&#x2e;&#46;&#64;&#x67;&#109;&#x61;&#105;&#108;&#46;&#99;&#111;&#x6d;&#x5d;&#x28;&#x29;</a>
 不是所有的程序都需要并行化的，能用串行化解决的问题没必要并行，所以即使将来many-core系统成为主流，大部分程序员也没必要去搞并行计算。</p>
<p>我觉得未来的主流应该是类似cell这样一颗全功能核心带众多协处理核心的异构系统，这样才能达到最优的 性能/核心面积比。</p>
<p>2010/3/24 Guancheng Chen <a href="&#x6d;&#x61;&#x69;&#108;&#116;&#111;&#58;&#91;&#99;&#104;&#x65;&#110;&#x67;&#x75;&#x2e;&#x2e;&#46;&#x40;&#x67;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#x6f;&#109;&#93;&#40;&#x29;">&#91;&#99;&#104;&#x65;&#110;&#x67;&#x75;&#x2e;&#x2e;&#46;&#x40;&#x67;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#x6f;&#109;&#93;&#40;&#x29;</a></p>
<p>Nice 大胆预测Linear speedup应该是每个程序员十年后的目标 呵呵
On 3月23日, 上午10时43分, qiaojie <a href="&#109;&#x61;&#105;&#x6c;&#116;&#x6f;&#x3a;&#91;&#113;&#105;&#97;&#111;&#x2e;&#x2e;&#46;&#64;&#103;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#x6f;&#109;&#93;&#x28;&#x29;">&#91;&#113;&#105;&#97;&#111;&#x2e;&#x2e;&#46;&#64;&#103;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#x6f;&#109;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>目前正在写的是一个软件渲染器，采用了光栅化和光线跟踪混合算法，渲染算法已经完全并行化了，
在4核系统上基本可以达到线性加速比，更多核的系统暂时还没测试。kd-tree的构造暂时还没有并
行化，以后有空了再研究。</p>
<p>2010/3/23 Guancheng Chen <a href="&#x6d;&#97;&#x69;&#108;&#x74;&#111;&#58;&#x5b;&#x63;&#x68;&#x65;&#110;&#x67;&#x75;&#97;&#110;&#99;&#104;&#x2e;&#46;&#46;&#64;&#x67;&#x6d;&#x61;&#105;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#x29;">&#x5b;&#x63;&#x68;&#x65;&#110;&#x67;&#x75;&#97;&#110;&#99;&#104;&#x2e;&#46;&#46;&#64;&#x67;&#x6d;&#x61;&#105;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#x29;</a></p>
<blockquote>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？</p>
<p>On 3月23日, 上午9时15分, qiaojie <a href="&#x6d;&#97;&#105;&#x6c;&#x74;&#111;&#58;&#91;&#x71;&#x69;&#97;&#x6f;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#97;&#105;&#108;&#46;&#x63;&#111;&#x6d;&#x5d;&#40;&#x29;">&#91;&#x71;&#x69;&#97;&#x6f;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#97;&#105;&#108;&#46;&#x63;&#111;&#x6d;&#x5d;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1) =
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？</p>
</blockquote>
<p> To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a></p>
<p><img src="" alt=""> qiaojie <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-24</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>并行计算本来就是曲高和寡的东西，就跟3D渲染一样，能开发引擎的毕竟只是小部分人，大多数人在引擎的基础上做应用。关键在于是否有杀手应用，只要有大量的需求，自然会有人去做开发。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#109;&#97;&#105;&#x6c;&#x74;&#x6f;&#58;&#x5b;&#104;&#111;&#110;&#103;&#x7a;&#104;&#46;&#46;&#46;&#x40;&#103;&#x6d;&#x61;&#105;&#108;&#46;&#x63;&#111;&#109;&#x5d;&#40;&#x29;">&#x5b;&#104;&#111;&#110;&#103;&#x7a;&#104;&#46;&#46;&#46;&#x40;&#103;&#x6d;&#x61;&#105;&#108;&#46;&#x63;&#111;&#109;&#x5d;&#40;&#x29;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>异构平台从网络处理器算起已经快10年了，现在情况仍然不明朗。就我看到的，异构平台要想高效，就必须向程序员暴露非常多的硬件细节，这必然导致编程的复杂性。曲高和寡，要想渗透到应用程序这一块，我觉得很难。</p>
<p>2010/3/24 qiaojie <a href="&#109;&#97;&#x69;&#108;&#x74;&#111;&#58;&#x5b;&#x71;&#105;&#97;&#x2e;&#46;&#46;&#x40;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#41;">&#x5b;&#x71;&#105;&#97;&#x2e;&#46;&#46;&#x40;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#41;</a>
说的没错，cell已经成了先烈了。不过这不代表异构的方向不对，CUDA，OpenCL也都是异构平台，以后我们会越来越习惯异构平台的。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#109;&#x61;&#x69;&#x6c;&#116;&#x6f;&#x3a;&#91;&#104;&#x6f;&#110;&#x67;&#x7a;&#x68;&#46;&#46;&#46;&#64;&#103;&#109;&#x61;&#x69;&#108;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#x29;">&#91;&#104;&#x6f;&#110;&#x67;&#x7a;&#x68;&#46;&#46;&#46;&#64;&#103;&#109;&#x61;&#x69;&#108;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#x29;</a></p>
<p>异构平台如果编程复杂度降不下来的话很难流行起来。cell已经死了...
2010/3/24 qiaojie <a href="&#109;&#97;&#105;&#108;&#x74;&#111;&#58;&#x5b;&#x71;&#105;&#97;&#x2e;&#x2e;&#x2e;&#64;&#103;&#x6d;&#x61;&#105;&#108;&#46;&#x63;&#111;&#x6d;&#x5d;&#40;&#41;">&#x5b;&#x71;&#105;&#97;&#x2e;&#x2e;&#x2e;&#64;&#103;&#x6d;&#x61;&#105;&#108;&#46;&#x63;&#111;&#x6d;&#x5d;&#40;&#41;</a>
 不是所有的程序都需要并行化的，能用串行化解决的问题没必要并行，所以即使将来many-core系统成为主流，大部分程序员也没必要去搞并行计算。</p>
<p>我觉得未来的主流应该是类似cell这样一颗全功能核心带众多协处理核心的异构系统，这样才能达到最优的 性能/核心面积比。</p>
<p>2010/3/24 Guancheng Chen <a href="&#109;&#97;&#x69;&#108;&#x74;&#111;&#58;&#91;&#x63;&#104;&#x65;&#110;&#103;&#x75;&#x2e;&#x2e;&#46;&#x40;&#103;&#x6d;&#97;&#105;&#x6c;&#x2e;&#99;&#111;&#x6d;&#x5d;&#x28;&#x29;">&#91;&#x63;&#104;&#x65;&#110;&#103;&#x75;&#x2e;&#x2e;&#46;&#x40;&#103;&#x6d;&#97;&#105;&#x6c;&#x2e;&#99;&#111;&#x6d;&#x5d;&#x28;&#x29;</a></p>
<p>Nice 大胆预测Linear speedup应该是每个程序员十年后的目标 呵呵
On 3月23日, 上午10时43分, qiaojie <a href="&#109;&#97;&#105;&#108;&#x74;&#x6f;&#x3a;&#91;&#x71;&#105;&#97;&#111;&#46;&#x2e;&#46;&#x40;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#99;&#111;&#109;&#x5d;&#x28;&#x29;">&#91;&#x71;&#105;&#97;&#111;&#46;&#x2e;&#46;&#x40;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#99;&#111;&#109;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>目前正在写的是一个软件渲染器，采用了光栅化和光线跟踪混合算法，渲染算法已经完全并行化了，
在4核系统上基本可以达到线性加速比，更多核的系统暂时还没测试。kd-tree的构造暂时还没有并
行化，以后有空了再研究。</p>
<p>2010/3/23 Guancheng Chen <a href="&#x6d;&#x61;&#105;&#108;&#116;&#111;&#58;&#91;&#99;&#104;&#101;&#110;&#x67;&#117;&#97;&#x6e;&#x63;&#x68;&#x2e;&#46;&#x2e;&#x40;&#103;&#x6d;&#97;&#105;&#108;&#46;&#99;&#x6f;&#109;&#x5d;&#x28;&#41;">&#91;&#99;&#104;&#101;&#110;&#x67;&#117;&#97;&#x6e;&#x63;&#x68;&#x2e;&#46;&#x2e;&#x40;&#103;&#x6d;&#97;&#105;&#108;&#46;&#99;&#x6f;&#109;&#x5d;&#x28;&#41;</a></p>
<blockquote>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？</p>
<p>On 3月23日, 上午9时15分, qiaojie <a href="&#x6d;&#97;&#x69;&#x6c;&#116;&#111;&#58;&#91;&#113;&#x69;&#97;&#111;&#46;&#46;&#46;&#64;&#x67;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#x28;&#41;">&#91;&#113;&#x69;&#97;&#111;&#46;&#46;&#46;&#64;&#x67;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1) =
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？</p>
</blockquote>
<p> To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-25</p>
<p>其他收件人：</p>
<p>杀手应用一般来说是指什么样的应用呢？比如用户群特别大的网游？还是那些专有的科学计算用的软件？</p>
<p>On 3月24日, 下午12时36分, qiaojie <a href="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#x6f;&#58;&#91;&#x71;&#x69;&#x61;&#111;&#x2e;&#46;&#46;&#64;&#x67;&#x6d;&#97;&#x69;&#108;&#46;&#99;&#x6f;&#109;&#x5d;&#x28;&#x29;">&#91;&#x71;&#x69;&#x61;&#111;&#x2e;&#46;&#46;&#64;&#x67;&#x6d;&#97;&#x69;&#108;&#46;&#99;&#x6f;&#109;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>并行计算本来就是曲高和寡的东西，就跟3D渲染一样，能开发引擎的毕竟只是小部分人，大多数人在引擎的基础上做应用。关键在于是否有杀手应用，只要有大量的需求 ，自然会有人去做开发。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#x6d;&#97;&#x69;&#x6c;&#116;&#111;&#x3a;&#91;&#x68;&#x6f;&#110;&#x67;&#122;&#x68;&#97;&#x6e;&#x67;&#46;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#109;&#x61;&#x69;&#x6c;&#46;&#99;&#111;&#109;&#93;&#40;&#x29;">&#91;&#x68;&#x6f;&#110;&#x67;&#122;&#x68;&#97;&#x6e;&#x67;&#46;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#109;&#x61;&#x69;&#x6c;&#46;&#99;&#111;&#109;&#93;&#40;&#x29;</a></p>
</blockquote>
<p>&gt;
&gt;
&gt;</p>
<blockquote>
<blockquote>
<p>异构平台从网络处理器算起已经快10年了，现在情况仍然不明朗。就我看到的，异构平台要想高效，就必须向程序员暴露非常多的硬件细节，这必然导致编程的复杂性。 曲高和寡，要想渗透到应用程序这一块，我觉得很难。</p>
<p>2010/3/24 qiaojie <a href="&#109;&#x61;&#105;&#108;&#116;&#111;&#58;&#91;&#113;&#105;&#97;&#x6f;&#x2e;&#x2e;&#x2e;&#64;&#103;&#109;&#97;&#x69;&#108;&#46;&#x63;&#x6f;&#109;&#x5d;&#x28;&#x29;">&#91;&#113;&#105;&#97;&#x6f;&#x2e;&#x2e;&#x2e;&#64;&#103;&#109;&#97;&#x69;&#108;&#46;&#x63;&#x6f;&#109;&#x5d;&#x28;&#x29;</a></p>
</blockquote>
</blockquote>
<p>&gt;</p>
<blockquote>
<blockquote>
<blockquote>
<p>说的没错，cell已经成了先烈了。不过这不代表异构的方向不对，CUDA，OpenCL也都是异构平台，以后我们会越来越习惯异构平台的。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#109;&#x61;&#105;&#x6c;&#116;&#111;&#58;&#x5b;&#x68;&#x6f;&#x6e;&#103;&#x7a;&#104;&#x61;&#110;&#x67;&#x2e;&#x2e;&#x2e;&#46;&#x40;&#103;&#109;&#x61;&#x69;&#108;&#46;&#99;&#x6f;&#109;&#x5d;&#40;&#x29;">&#x5b;&#x68;&#x6f;&#x6e;&#103;&#x7a;&#104;&#x61;&#110;&#x67;&#x2e;&#x2e;&#x2e;&#46;&#x40;&#103;&#109;&#x61;&#x69;&#108;&#46;&#99;&#x6f;&#109;&#x5d;&#40;&#x29;</a></p>
<p>异构平台如果编程复杂度降不下来的话很难流行起来。cell已经死了...</p>
<blockquote>
<p> 2010/3/24 qiaojie <a href="&#x6d;&#97;&#x69;&#x6c;&#x74;&#111;&#x3a;&#91;&#x71;&#x69;&#x61;&#111;&#x2e;&#x2e;&#46;&#x40;&#103;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#40;&#x29;">&#91;&#x71;&#x69;&#x61;&#111;&#x2e;&#x2e;&#46;&#x40;&#103;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#40;&#x29;</a></p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>&gt;</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>不是所有的程序都需要并行化的，能用串行化解决的问题没必要并行，所以即使将来many-core系统成为主流，大部分程序员也没必要去搞并行计算。
  我觉得未来的主流应该是类似cell这样一颗全功能核心带众多协处理核心的异构系统，这样才能达到最优的 性能/核心面积比。</p>
<p>2010/3/24 Guancheng Chen <a href="&#109;&#x61;&#105;&#x6c;&#116;&#x6f;&#x3a;&#x5b;&#x63;&#x68;&#101;&#x6e;&#103;&#117;&#97;&#110;&#x63;&#104;&#x2e;&#46;&#46;&#64;&#103;&#109;&#x61;&#x69;&#108;&#x2e;&#x63;&#111;&#x6d;&#93;&#40;&#41;">&#x5b;&#x63;&#x68;&#101;&#x6e;&#103;&#117;&#97;&#110;&#x63;&#104;&#x2e;&#46;&#46;&#64;&#103;&#109;&#x61;&#x69;&#108;&#x2e;&#x63;&#111;&#x6d;&#93;&#40;&#41;</a></p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>&gt;</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>Nice 大胆预测Linear speedup应该是每个程序员十年后的目标 呵呵</p>
<blockquote>
<p>On 3月23日, 上午10时43分, qiaojie <a href="&#109;&#x61;&#105;&#x6c;&#116;&#111;&#x3a;&#91;&#113;&#x69;&#x61;&#x6f;&#x2e;&#x2e;&#x2e;&#64;&#103;&#x6d;&#x61;&#x69;&#108;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#x29;">&#91;&#113;&#x69;&#x61;&#x6f;&#x2e;&#x2e;&#x2e;&#64;&#103;&#x6d;&#x61;&#x69;&#108;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>目前正在写的是一个软件渲染器，采用了光栅化和光线跟踪混合算法，渲染算法已经完全并行化了，
在4核系统上基本可以达到线性加速比，更多核的系统暂时还没测试。kd-tree的构造暂时还没有并
行化，以后有空了再研究。</p>
<p>2010/3/23 Guancheng Chen <a href="&#109;&#97;&#x69;&#108;&#116;&#111;&#58;&#x5b;&#x63;&#104;&#101;&#x6e;&#x67;&#x75;&#x61;&#110;&#99;&#104;&#x2e;&#46;&#x2e;&#64;&#103;&#109;&#97;&#105;&#x6c;&#x2e;&#99;&#111;&#x6d;&#x5d;&#40;&#x29;">&#x5b;&#x63;&#104;&#101;&#x6e;&#x67;&#x75;&#x61;&#110;&#99;&#104;&#x2e;&#46;&#x2e;&#64;&#103;&#109;&#97;&#105;&#x6c;&#x2e;&#99;&#111;&#x6d;&#x5d;&#40;&#x29;</a></p>
<blockquote>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？</p>
<p>On 3月23日, 上午9时15分, qiaojie <a href="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#111;&#x3a;&#x5b;&#x71;&#x69;&#97;&#111;&#46;&#46;&#x2e;&#64;&#x67;&#x6d;&#x61;&#105;&#108;&#x2e;&#99;&#x6f;&#109;&#93;&#40;&#41;">&#x5b;&#x71;&#x69;&#97;&#111;&#46;&#46;&#x2e;&#64;&#x67;&#x6d;&#x61;&#105;&#108;&#x2e;&#99;&#x6f;&#109;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1)
=
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank
Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？</p>
</blockquote>
<p> To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
<a href="">显示删减掉的内容</a></p>
</blockquote>
</blockquote>
<p><img src="" alt=""> qiaojie <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-25</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>3D游戏就是一类杀手应用，由此支撑起了一个庞大的GPU市场，芯片行业的研发成本是很高的，没有一个庞大的市场是做不起来的。目前的消费者对于多核系统显然还没有强烈的需求，因为应用跟不上，i7发布快2年了还没进入主流市场，这种情况延续下去的话摩尔定律将因此失效。不过我相信杀手级应用总会出现的，这可能要硬件性能突破一个临界点，比方说目前GPU的性能再提升一个数量级的话，光线跟踪算法就可以提供流畅的接近CG的画质，倒是此类应用便会流行开来。</p>
<p>2010/3/25 Guancheng Chen <a href="&#109;&#x61;&#105;&#x6c;&#x74;&#x6f;&#58;&#91;&#x63;&#x68;&#x65;&#110;&#x67;&#117;&#x2e;&#46;&#x2e;&#64;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#41;">&#91;&#x63;&#x68;&#x65;&#110;&#x67;&#117;&#x2e;&#46;&#x2e;&#64;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#41;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>杀手应用一般来说是指什么样的应用呢？比如用户群特别大的网游？还是那些专有的科学计算用的软件？
On 3月24日, 下午12时36分, qiaojie <a href="&#x6d;&#x61;&#105;&#x6c;&#116;&#111;&#x3a;&#x5b;&#x71;&#105;&#97;&#111;&#46;&#x2e;&#46;&#64;&#103;&#x6d;&#x61;&#x69;&#108;&#46;&#99;&#x6f;&#x6d;&#x5d;&#40;&#41;">&#x5b;&#x71;&#105;&#97;&#111;&#46;&#x2e;&#46;&#64;&#103;&#x6d;&#x61;&#x69;&#108;&#46;&#99;&#x6f;&#x6d;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>并行计算本来就是曲高和寡的东西，就跟3D渲染一样，能开发引擎的毕竟只是小部分人，大多数人在引擎的基础上做应用。关键在于是否有杀手应用，只要有大量的需求 ，自然会有人去做开发。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#109;&#x61;&#x69;&#108;&#116;&#x6f;&#58;&#91;&#x68;&#111;&#x6e;&#103;&#122;&#x68;&#x61;&#110;&#x67;&#x2e;&#x2e;&#46;&#x2e;&#64;&#x67;&#109;&#97;&#105;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#93;&#x28;&#x29;">&#91;&#x68;&#111;&#x6e;&#103;&#122;&#x68;&#x61;&#110;&#x67;&#x2e;&#x2e;&#46;&#x2e;&#64;&#x67;&#109;&#97;&#105;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#93;&#x28;&#x29;</a></p>
<blockquote>
<p>异构平台从网络处理器算起已经快10年了，现在情况仍然不明朗。就我看到的，异构平台要想高效，就必须向程序员暴露非常多的硬件细节，这必然导致编程的复杂性。 曲高和寡，要想渗透到应用程序这一块，我觉得很难。</p>
<p>2010/3/24 qiaojie <a href="&#109;&#97;&#x69;&#x6c;&#x74;&#x6f;&#x3a;&#x5b;&#113;&#105;&#97;&#111;&#46;&#x2e;&#x2e;&#x40;&#x67;&#109;&#x61;&#105;&#108;&#x2e;&#x63;&#111;&#x6d;&#93;&#x28;&#41;">&#x5b;&#113;&#105;&#97;&#111;&#46;&#x2e;&#x2e;&#x40;&#x67;&#109;&#x61;&#105;&#108;&#x2e;&#x63;&#111;&#x6d;&#93;&#x28;&#41;</a></p>
<blockquote>
<p>说的没错，cell已经成了先烈了。不过这不代表异构的方向不对，CUDA，OpenCL也都是异构平台，以后我们会越来越习惯异构平台的。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#109;&#97;&#105;&#x6c;&#x74;&#x6f;&#x3a;&#91;&#104;&#x6f;&#x6e;&#103;&#122;&#x68;&#x61;&#110;&#103;&#x2e;&#x2e;&#x2e;&#x2e;&#64;&#103;&#109;&#x61;&#105;&#x6c;&#46;&#99;&#x6f;&#109;&#x5d;&#x28;&#41;">&#91;&#104;&#x6f;&#x6e;&#103;&#122;&#x68;&#x61;&#110;&#103;&#x2e;&#x2e;&#x2e;&#x2e;&#64;&#103;&#109;&#x61;&#105;&#x6c;&#46;&#99;&#x6f;&#109;&#x5d;&#x28;&#41;</a></p>
<p>异构平台如果编程复杂度降不下来的话很难流行起来。cell已经死了...</p>
<blockquote>
<p> 2010/3/24 qiaojie <a href="&#109;&#x61;&#105;&#x6c;&#x74;&#x6f;&#58;&#x5b;&#113;&#x69;&#x61;&#111;&#x2e;&#46;&#x2e;&#64;&#103;&#x6d;&#97;&#x69;&#108;&#46;&#99;&#111;&#109;&#x5d;&#x28;&#x29;">&#x5b;&#113;&#x69;&#x61;&#111;&#x2e;&#46;&#x2e;&#64;&#103;&#x6d;&#97;&#x69;&#108;&#46;&#99;&#111;&#109;&#x5d;&#x28;&#x29;</a></p>
<blockquote>
<p>不是所有的程序都需要并行化的，能用串行化解决的问题没必要并行，所以即使将来many-core系统成为主流，大部分程序员也没必要去搞并行计算。
  我觉得未来的主流应该是类似cell这样一颗全功能核心带众多协处理核心的异构系统，这样才能达到最优的 性能/核心面积比。</p>
<p>2010/3/24 Guancheng Chen <a href="&#109;&#x61;&#x69;&#x6c;&#116;&#x6f;&#x3a;&#x5b;&#x63;&#104;&#101;&#x6e;&#103;&#x75;&#97;&#110;&#x63;&#x68;&#46;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#99;&#111;&#x6d;&#93;&#40;&#x29;">&#x5b;&#x63;&#104;&#101;&#x6e;&#103;&#x75;&#97;&#110;&#x63;&#x68;&#46;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#99;&#111;&#x6d;&#93;&#40;&#x29;</a></p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>&gt;</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>Nice 大胆预测Linear speedup应该是每个程序员十年后的目标 呵呵</p>
<blockquote>
<p>On 3月23日, 上午10时43分, qiaojie <a href="&#x6d;&#97;&#105;&#108;&#116;&#111;&#58;&#91;&#113;&#105;&#x61;&#111;&#46;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#99;&#x6f;&#109;&#x5d;&#40;&#41;">&#91;&#113;&#105;&#x61;&#111;&#46;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#99;&#x6f;&#109;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>目前正在写的是一个软件渲染器，采用了光栅化和光线跟踪混合算法，渲染算法已经完全并行化了，
在4核系统上基本可以达到线性加速比，更多核的系统暂时还没测试。kd-tree的构造暂时还没有并
行化，以后有空了再研究。</p>
<p>2010/3/23 Guancheng Chen <a href="&#109;&#97;&#105;&#x6c;&#x74;&#111;&#x3a;&#91;&#99;&#104;&#x65;&#x6e;&#x67;&#x75;&#97;&#110;&#99;&#104;&#x2e;&#x2e;&#x2e;&#64;&#103;&#x6d;&#97;&#105;&#x6c;&#46;&#x63;&#x6f;&#109;&#93;&#40;&#41;">&#91;&#99;&#104;&#x65;&#x6e;&#x67;&#x75;&#97;&#110;&#99;&#104;&#x2e;&#x2e;&#x2e;&#64;&#103;&#x6d;&#97;&#105;&#x6c;&#46;&#x63;&#x6f;&#109;&#93;&#40;&#41;</a></p>
<blockquote>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？</p>
<p>On 3月23日, 上午9时15分, qiaojie <a href="&#x6d;&#x61;&#105;&#108;&#x74;&#x6f;&#x3a;&#91;&#x71;&#105;&#x61;&#x6f;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#109;&#97;&#x69;&#108;&#46;&#99;&#x6f;&#x6d;&#93;&#x28;&#41;">&#91;&#x71;&#105;&#x61;&#x6f;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#109;&#97;&#x69;&#108;&#46;&#99;&#x6f;&#x6d;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1)
=
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank
Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？</p>
</blockquote>
<p> To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> 机械唯物主义 : linjunhalida <img src="" alt=""></p>
</blockquote>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-25</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>一个谬误：刺激需求
产能=消费，产能才是主动力。技术成长是随着产能成长而起来的。
而产能多的结果就是满足了需求，造成一种需求带来技术进步的假像。
而技术和产能之间的关系又错综复杂。。
2010/3/25 qiaojie <a href="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#x6f;&#58;&#91;&#113;&#x69;&#97;&#x2e;&#x2e;&#46;&#64;&#103;&#x6d;&#97;&#x69;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#x28;&#x29;">&#91;&#113;&#x69;&#97;&#x2e;&#x2e;&#46;&#64;&#103;&#x6d;&#97;&#x69;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#x28;&#x29;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>3D游戏就是一类杀手应用，由此支撑起了一个庞大的GPU市场，芯片行业的研发成本是很高的，没有一个庞大的市场是做不起来的。目前的消费者对于多核系统显然还没有强烈的需求，因为应用跟不上，i7发布快2年了还没进入主流市场，这种情况延续下去的话摩尔定律将因此失效。不过我相信杀手级应用总会出现的，这可能要硬件性能突破一个临界点，比方说目前GPU的性能再提升一个数量级的话，光线跟踪算法就可以提供流畅的接近CG的画质，倒是此类应用便会流行开来。</p>
<p>2010/3/25 Guancheng Chen <a href="&#109;&#97;&#105;&#x6c;&#x74;&#x6f;&#x3a;&#x5b;&#x63;&#x68;&#x65;&#110;&#x67;&#x75;&#x2e;&#46;&#x2e;&#x40;&#x67;&#109;&#97;&#105;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#40;&#41;">&#x5b;&#x63;&#x68;&#x65;&#110;&#x67;&#x75;&#x2e;&#46;&#x2e;&#x40;&#x67;&#109;&#97;&#105;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#40;&#41;</a></p>
<p>杀手应用一般来说是指什么样的应用呢？比如用户群特别大的网游？还是那些专有的科学计算用的软件？
On 3月24日, 下午12时36分, qiaojie <a href="&#x6d;&#97;&#x69;&#x6c;&#116;&#111;&#58;&#x5b;&#113;&#x69;&#97;&#x6f;&#x2e;&#46;&#x2e;&#x40;&#x67;&#109;&#x61;&#x69;&#108;&#46;&#99;&#111;&#x6d;&#x5d;&#x28;&#x29;">&#x5b;&#113;&#x69;&#97;&#x6f;&#x2e;&#46;&#x2e;&#x40;&#x67;&#109;&#x61;&#x69;&#108;&#46;&#99;&#111;&#x6d;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>并行计算本来就是曲高和寡的东西，就跟3D渲染一样，能开发引擎的毕竟只是小部分人，大多数人在引擎的基础上做应用。关键在于是否有杀手应用，只要有大量的需求 ，自然会有人去做开发。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#109;&#97;&#x69;&#108;&#x74;&#x6f;&#x3a;&#x5b;&#104;&#x6f;&#x6e;&#x67;&#x7a;&#x68;&#97;&#110;&#x67;&#46;&#46;&#x2e;&#46;&#64;&#x67;&#109;&#x61;&#x69;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#x29;">&#x5b;&#104;&#x6f;&#x6e;&#x67;&#x7a;&#x68;&#97;&#110;&#x67;&#46;&#46;&#x2e;&#46;&#64;&#x67;&#109;&#x61;&#x69;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#x29;</a></p>
<blockquote>
<p>异构平台从网络处理器算起已经快10年了，现在情况仍然不明朗。就我看到的，异构平台要想高效，就必须向程序员暴露非常多的硬件细节，这必然导致编程的复杂性。 曲高和寡，要想渗透到应用程序这一块，我觉得很难。</p>
<p>2010/3/24 qiaojie <a href="&#x6d;&#x61;&#105;&#x6c;&#116;&#x6f;&#x3a;&#91;&#x71;&#105;&#x61;&#x6f;&#46;&#46;&#46;&#x40;&#x67;&#109;&#x61;&#105;&#108;&#46;&#x63;&#x6f;&#109;&#93;&#x28;&#41;">&#91;&#x71;&#105;&#x61;&#x6f;&#46;&#46;&#46;&#x40;&#x67;&#109;&#x61;&#105;&#108;&#46;&#x63;&#x6f;&#109;&#93;&#x28;&#41;</a></p>
<blockquote>
<p>说的没错，cell已经成了先烈了。不过这不代表异构的方向不对，CUDA，OpenCL也都是异构平台，以后我们会越来越习惯异构平台的。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#x6d;&#x61;&#x69;&#108;&#116;&#x6f;&#58;&#x5b;&#104;&#x6f;&#x6e;&#103;&#x7a;&#104;&#97;&#110;&#103;&#46;&#x2e;&#46;&#46;&#x40;&#x67;&#109;&#x61;&#105;&#x6c;&#46;&#x63;&#x6f;&#109;&#x5d;&#x28;&#41;">&#x5b;&#104;&#x6f;&#x6e;&#103;&#x7a;&#104;&#97;&#110;&#103;&#46;&#x2e;&#46;&#46;&#x40;&#x67;&#109;&#x61;&#105;&#x6c;&#46;&#x63;&#x6f;&#109;&#x5d;&#x28;&#41;</a></p>
<p>异构平台如果编程复杂度降不下来的话很难流行起来。cell已经死了...</p>
<blockquote>
<p> 2010/3/24 qiaojie <a href="&#x6d;&#x61;&#105;&#108;&#116;&#111;&#58;&#x5b;&#113;&#x69;&#x61;&#x6f;&#x2e;&#46;&#x2e;&#64;&#103;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#x63;&#111;&#109;&#93;&#40;&#41;">&#x5b;&#113;&#x69;&#x61;&#x6f;&#x2e;&#46;&#x2e;&#64;&#103;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#x63;&#111;&#109;&#93;&#40;&#41;</a></p>
<blockquote>
<p>不是所有的程序都需要并行化的，能用串行化解决的问题没必要并行，所以即使将来many-core系统成为主流，大部分程序员也没必要去搞并行计算。
  我觉得未来的主流应该是类似cell这样一颗全功能核心带众多协处理核心的异构系统，这样才能达到最优的 性能/核心面积比。</p>
<p>2010/3/24 Guancheng Chen <a href="&#x6d;&#x61;&#105;&#x6c;&#x74;&#x6f;&#x3a;&#x5b;&#99;&#x68;&#x65;&#x6e;&#103;&#117;&#97;&#x6e;&#x63;&#104;&#46;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#97;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#x29;">&#x5b;&#99;&#x68;&#x65;&#x6e;&#103;&#117;&#97;&#x6e;&#x63;&#104;&#46;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#97;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#x29;</a></p>
<p>Nice 大胆预测Linear speedup应该是每个程序员十年后的目标 呵呵</p>
<blockquote>
<p>On 3月23日, 上午10时43分, qiaojie <a href="&#109;&#97;&#105;&#x6c;&#116;&#x6f;&#58;&#x5b;&#113;&#x69;&#x61;&#x6f;&#x2e;&#46;&#x2e;&#64;&#103;&#109;&#97;&#105;&#x6c;&#46;&#x63;&#111;&#x6d;&#93;&#x28;&#41;">&#x5b;&#113;&#x69;&#x61;&#x6f;&#x2e;&#46;&#x2e;&#64;&#103;&#109;&#97;&#105;&#x6c;&#46;&#x63;&#111;&#x6d;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>目前正在写的是一个软件渲染器，采用了光栅化和光线跟踪混合算法，渲染算法已经完全并行化了，
在4核系统上基本可以达到线性加速比，更多核的系统暂时还没测试。kd-tree的构造暂时还没有并
行化，以后有空了再研究。</p>
<p>2010/3/23 Guancheng Chen <a href="&#x6d;&#97;&#x69;&#108;&#x74;&#x6f;&#x3a;&#x5b;&#x63;&#104;&#101;&#110;&#x67;&#117;&#97;&#x6e;&#x63;&#x68;&#46;&#x2e;&#46;&#x40;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#x6f;&#109;&#93;&#40;&#x29;">&#x5b;&#x63;&#104;&#101;&#110;&#x67;&#117;&#97;&#x6e;&#x63;&#x68;&#46;&#x2e;&#46;&#x40;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#x6f;&#109;&#93;&#40;&#x29;</a></p>
<blockquote>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？</p>
<p>On 3月23日, 上午9时15分, qiaojie <a href="&#109;&#97;&#x69;&#108;&#x74;&#x6f;&#x3a;&#x5b;&#x71;&#x69;&#97;&#111;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#97;&#x69;&#x6c;&#46;&#99;&#111;&#109;&#x5d;&#x28;&#x29;">&#x5b;&#x71;&#x69;&#97;&#111;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#97;&#x69;&#x6c;&#46;&#99;&#111;&#109;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1)
=
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank
Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？</p>
</blockquote>
<p> To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a></p>
</blockquote>
</blockquote>
<p><img src="" alt=""> qiaojie <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-25</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>如果产能=消费的话就没有产能过剩这一说了。</p>
<p>2010/3/25 机械唯物主义 : linjunhalida <a href="&#x6d;&#x61;&#x69;&#108;&#116;&#111;&#x3a;&#x5b;&#108;&#105;&#x6e;&#x6a;&#117;&#110;&#46;&#x2e;&#46;&#x40;&#103;&#x6d;&#x61;&#x69;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#93;&#40;&#x29;">&#x5b;&#108;&#105;&#x6e;&#x6a;&#117;&#110;&#46;&#x2e;&#46;&#x40;&#103;&#x6d;&#x61;&#x69;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#93;&#40;&#x29;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>一个谬误：刺激需求
产能=消费，产能才是主动力。技术成长是随着产能成长而起来的。
而产能多的结果就是满足了需求，造成一种需求带来技术进步的假像。
而技术和产能之间的关系又错综复杂。。
2010/3/25 qiaojie <a href="&#x6d;&#x61;&#105;&#x6c;&#116;&#x6f;&#58;&#91;&#x71;&#105;&#x61;&#x2e;&#46;&#x2e;&#x40;&#103;&#x6d;&#97;&#105;&#108;&#46;&#x63;&#x6f;&#x6d;&#93;&#40;&#x29;">&#91;&#x71;&#105;&#x61;&#x2e;&#46;&#x2e;&#x40;&#103;&#x6d;&#97;&#105;&#108;&#46;&#x63;&#x6f;&#x6d;&#93;&#40;&#x29;</a></p>
<p>3D游戏就是一类杀手应用，由此支撑起了一个庞大的GPU市场，芯片行业的研发成本是很高的，没有一个庞大的市场是做不起来的。目前的消费者对于多核系统显然还没有强烈的需求，因为应用跟不上，i7发布快2年了还没进入主流市场，这种情况延续下去的话摩尔定律将因此失效。不过我相信杀手级应用总会出现的，这可能要硬件性能突破一个临界点，比方说目前GPU的性能再提升一个数量级的话，光线跟踪算法就可以提供流畅的接近CG的画质，倒是此类应用便会流行开来。</p>
<p>2010/3/25 Guancheng Chen <a href="&#x6d;&#97;&#x69;&#108;&#x74;&#x6f;&#58;&#x5b;&#99;&#x68;&#101;&#110;&#103;&#x75;&#46;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#97;&#x69;&#x6c;&#46;&#99;&#111;&#x6d;&#x5d;&#40;&#41;">&#x5b;&#99;&#x68;&#101;&#110;&#103;&#x75;&#46;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#97;&#x69;&#x6c;&#46;&#99;&#111;&#x6d;&#x5d;&#40;&#41;</a></p>
<p>杀手应用一般来说是指什么样的应用呢？比如用户群特别大的网游？还是那些专有的科学计算用的软件？
On 3月24日, 下午12时36分, qiaojie <a href="&#109;&#97;&#x69;&#108;&#x74;&#111;&#x3a;&#x5b;&#113;&#x69;&#97;&#x6f;&#46;&#x2e;&#x2e;&#x40;&#x67;&#109;&#x61;&#x69;&#x6c;&#46;&#x63;&#111;&#109;&#93;&#x28;&#x29;">&#x5b;&#113;&#x69;&#97;&#x6f;&#46;&#x2e;&#x2e;&#x40;&#x67;&#109;&#x61;&#x69;&#x6c;&#46;&#x63;&#111;&#109;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>并行计算本来就是曲高和寡的东西，就跟3D渲染一样，能开发引擎的毕竟只是小部分人，大多数人在引擎的基础上做应用。关键在于是否有杀手应用，只要有大量的需求 ，自然会有人去做开发。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#109;&#97;&#105;&#108;&#116;&#x6f;&#58;&#91;&#x68;&#111;&#x6e;&#x67;&#122;&#x68;&#97;&#x6e;&#x67;&#x2e;&#x2e;&#x2e;&#46;&#64;&#103;&#x6d;&#x61;&#105;&#108;&#46;&#99;&#111;&#x6d;&#93;&#40;&#x29;">&#91;&#x68;&#111;&#x6e;&#x67;&#122;&#x68;&#97;&#x6e;&#x67;&#x2e;&#x2e;&#x2e;&#46;&#64;&#103;&#x6d;&#x61;&#105;&#108;&#46;&#99;&#111;&#x6d;&#93;&#40;&#x29;</a></p>
<blockquote>
<p>异构平台从网络处理器算起已经快10年了，现在情况仍然不明朗。就我看到的，异构平台要想高效，就必须向程序员暴露非常多的硬件细节，这必然导致编程的复杂性。 曲高和寡，要想渗透到应用程序这一块，我觉得很难。</p>
<p>2010/3/24 qiaojie <a href="&#x6d;&#x61;&#x69;&#x6c;&#116;&#111;&#x3a;&#91;&#113;&#105;&#x61;&#111;&#46;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#97;&#x69;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#x29;">&#91;&#113;&#105;&#x61;&#111;&#46;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#97;&#x69;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#x29;</a></p>
<blockquote>
<p>说的没错，cell已经成了先烈了。不过这不代表异构的方向不对，CUDA，OpenCL也都是异构平台，以后我们会越来越习惯异构平台的。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#109;&#x61;&#105;&#x6c;&#116;&#x6f;&#x3a;&#91;&#x68;&#x6f;&#110;&#103;&#x7a;&#104;&#x61;&#110;&#103;&#46;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#97;&#x69;&#x6c;&#46;&#x63;&#x6f;&#109;&#93;&#x28;&#x29;">&#91;&#x68;&#x6f;&#110;&#103;&#x7a;&#104;&#x61;&#110;&#103;&#46;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#97;&#x69;&#x6c;&#46;&#x63;&#x6f;&#109;&#93;&#x28;&#x29;</a></p>
<p>异构平台如果编程复杂度降不下来的话很难流行起来。cell已经死了...</p>
<blockquote>
<p> 2010/3/24 qiaojie <a href="&#109;&#97;&#x69;&#x6c;&#116;&#x6f;&#x3a;&#91;&#x71;&#105;&#97;&#x6f;&#46;&#46;&#x2e;&#x40;&#103;&#x6d;&#x61;&#x69;&#108;&#46;&#99;&#x6f;&#x6d;&#93;&#40;&#41;">&#91;&#x71;&#105;&#97;&#x6f;&#46;&#46;&#x2e;&#x40;&#103;&#x6d;&#x61;&#x69;&#108;&#46;&#99;&#x6f;&#x6d;&#93;&#40;&#41;</a></p>
<blockquote>
<p>不是所有的程序都需要并行化的，能用串行化解决的问题没必要并行，所以即使将来many-core系统成为主流，大部分程序员也没必要去搞并行计算。
  我觉得未来的主流应该是类似cell这样一颗全功能核心带众多协处理核心的异构系统，这样才能达到最优的 性能/核心面积比。</p>
<p>2010/3/24 Guancheng Chen <a href="&#x6d;&#x61;&#105;&#x6c;&#116;&#x6f;&#58;&#x5b;&#99;&#104;&#x65;&#110;&#103;&#x75;&#97;&#110;&#x63;&#x68;&#x2e;&#46;&#46;&#64;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#99;&#111;&#x6d;&#x5d;&#x28;&#x29;">&#x5b;&#99;&#104;&#x65;&#110;&#103;&#x75;&#97;&#110;&#x63;&#x68;&#x2e;&#46;&#46;&#64;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#99;&#111;&#x6d;&#x5d;&#x28;&#x29;</a></p>
<p>Nice 大胆预测Linear speedup应该是每个程序员十年后的目标 呵呵</p>
<blockquote>
<p>On 3月23日, 上午10时43分, qiaojie <a href="&#x6d;&#x61;&#105;&#x6c;&#116;&#111;&#x3a;&#x5b;&#113;&#x69;&#97;&#111;&#x2e;&#x2e;&#46;&#64;&#103;&#109;&#97;&#x69;&#108;&#x2e;&#x63;&#111;&#109;&#x5d;&#40;&#41;">&#x5b;&#113;&#x69;&#97;&#111;&#x2e;&#x2e;&#46;&#64;&#103;&#109;&#97;&#x69;&#108;&#x2e;&#x63;&#111;&#109;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>目前正在写的是一个软件渲染器，采用了光栅化和光线跟踪混合算法，渲染算法已经完全并行化了，
在4核系统上基本可以达到线性加速比，更多核的系统暂时还没测试。kd-tree的构造暂时还没有并
行化，以后有空了再研究。</p>
<p>2010/3/23 Guancheng Chen <a href="&#x6d;&#x61;&#x69;&#108;&#116;&#111;&#x3a;&#x5b;&#99;&#x68;&#x65;&#110;&#x67;&#x75;&#97;&#x6e;&#99;&#x68;&#46;&#x2e;&#x2e;&#64;&#x67;&#109;&#97;&#105;&#108;&#x2e;&#99;&#111;&#x6d;&#x5d;&#x28;&#x29;">&#x5b;&#99;&#x68;&#x65;&#110;&#x67;&#x75;&#97;&#x6e;&#99;&#x68;&#46;&#x2e;&#x2e;&#64;&#x67;&#109;&#97;&#105;&#108;&#x2e;&#99;&#111;&#x6d;&#x5d;&#x28;&#x29;</a></p>
<blockquote>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？</p>
<p>On 3月23日, 上午9时15分, qiaojie <a href="&#x6d;&#x61;&#105;&#108;&#x74;&#111;&#x3a;&#x5b;&#113;&#105;&#97;&#x6f;&#46;&#46;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#105;&#108;&#46;&#x63;&#x6f;&#x6d;&#93;&#x28;&#41;">&#x5b;&#113;&#105;&#97;&#x6f;&#46;&#46;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#105;&#108;&#46;&#x63;&#x6f;&#x6d;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1)
=
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank
Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？</p>
</blockquote>
<p> To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> 机械唯物主义 : linjunhalida <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-25</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>产能过剩的说法本来就不对。
产出的东西没有价值，这样的活动就不能说是生产。
比如我这个程序员，花了1周写了一个垃圾程序，然后被开除了。
然后1个月闲着，这是我产能过剩吗？
而闲着的原因是政府给我失业金，我就不需要工作闲起来了。。。
2010/3/25 qiaojie <a href="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#x6f;&#x3a;&#91;&#x71;&#105;&#97;&#46;&#x2e;&#46;&#64;&#103;&#109;&#97;&#x69;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#40;&#41;">&#91;&#x71;&#105;&#97;&#46;&#x2e;&#46;&#64;&#103;&#109;&#97;&#x69;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#40;&#41;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>如果产能=消费的话就没有产能过剩这一说了。</p>
<p>2010/3/25 机械唯物主义 : linjunhalida <a href="&#x6d;&#97;&#105;&#108;&#x74;&#x6f;&#x3a;&#x5b;&#108;&#105;&#110;&#106;&#117;&#110;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#97;&#x69;&#108;&#46;&#99;&#x6f;&#x6d;&#93;&#40;&#41;">&#x5b;&#108;&#105;&#110;&#106;&#117;&#110;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#97;&#x69;&#108;&#46;&#99;&#x6f;&#x6d;&#93;&#40;&#41;</a></p>
<p>一个谬误：刺激需求
产能=消费，产能才是主动力。技术成长是随着产能成长而起来的。
而产能多的结果就是满足了需求，造成一种需求带来技术进步的假像。
而技术和产能之间的关系又错综复杂。。
2010/3/25 qiaojie <a href="&#109;&#x61;&#x69;&#108;&#x74;&#x6f;&#58;&#x5b;&#113;&#x69;&#x61;&#46;&#46;&#x2e;&#x40;&#x67;&#109;&#97;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#x28;&#41;">&#x5b;&#113;&#x69;&#x61;&#46;&#46;&#x2e;&#x40;&#x67;&#109;&#97;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#x28;&#41;</a></p>
<p>3D游戏就是一类杀手应用，由此支撑起了一个庞大的GPU市场，芯片行业的研发成本是很高的，没有一个庞大的市场是做不起来的。目前的消费者对于多核系统显然还没有强烈的需求，因为应用跟不上，i7发布快2年了还没进入主流市场，这种情况延续下去的话摩尔定律将因此失效。不过我相信杀手级应用总会出现的，这可能要硬件性能突破一个临界点，比方说目前GPU的性能再提升一个数量级的话，光线跟踪算法就可以提供流畅的接近CG的画质，倒是此类应用便会流行开来。</p>
<p>2010/3/25 Guancheng Chen <a href="&#x6d;&#97;&#x69;&#x6c;&#x74;&#111;&#58;&#x5b;&#99;&#104;&#x65;&#110;&#103;&#117;&#46;&#x2e;&#x2e;&#x40;&#103;&#109;&#97;&#x69;&#108;&#x2e;&#99;&#x6f;&#109;&#x5d;&#x28;&#x29;">&#x5b;&#99;&#104;&#x65;&#110;&#103;&#117;&#46;&#x2e;&#x2e;&#x40;&#103;&#109;&#97;&#x69;&#108;&#x2e;&#99;&#x6f;&#109;&#x5d;&#x28;&#x29;</a></p>
<p>杀手应用一般来说是指什么样的应用呢？比如用户群特别大的网游？还是那些专有的科学计算用的软件？
On 3月24日, 下午12时36分, qiaojie <a href="&#x6d;&#97;&#x69;&#x6c;&#x74;&#111;&#58;&#x5b;&#x71;&#105;&#97;&#111;&#x2e;&#x2e;&#46;&#64;&#x67;&#x6d;&#97;&#105;&#108;&#46;&#99;&#x6f;&#x6d;&#93;&#40;&#x29;">&#x5b;&#x71;&#105;&#97;&#111;&#x2e;&#x2e;&#46;&#64;&#x67;&#x6d;&#97;&#105;&#108;&#46;&#99;&#x6f;&#x6d;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>并行计算本来就是曲高和寡的东西，就跟3D渲染一样，能开发引擎的毕竟只是小部分人，大多数人在引擎的基础上做应用。关键在于是否有杀手应用，只要有大量的需求 ，自然会有人去做开发。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#x6d;&#97;&#x69;&#108;&#x74;&#x6f;&#58;&#91;&#104;&#111;&#110;&#x67;&#x7a;&#104;&#x61;&#110;&#x67;&#46;&#x2e;&#46;&#46;&#x40;&#x67;&#109;&#x61;&#105;&#x6c;&#46;&#x63;&#x6f;&#109;&#x5d;&#x28;&#41;">&#91;&#104;&#111;&#110;&#x67;&#x7a;&#104;&#x61;&#110;&#x67;&#46;&#x2e;&#46;&#46;&#x40;&#x67;&#109;&#x61;&#105;&#x6c;&#46;&#x63;&#x6f;&#109;&#x5d;&#x28;&#41;</a></p>
<blockquote>
<p>异构平台从网络处理器算起已经快10年了，现在情况仍然不明朗。就我看到的，异构平台要想高效，就必须向程序员暴露非常多的硬件细节，这必然导致编程的复杂性。 曲高和寡，要想渗透到应用程序这一块，我觉得很难。</p>
<p>2010/3/24 qiaojie <a href="&#x6d;&#97;&#x69;&#108;&#x74;&#111;&#58;&#x5b;&#x71;&#x69;&#97;&#x6f;&#x2e;&#46;&#x2e;&#64;&#x67;&#x6d;&#x61;&#x69;&#108;&#46;&#99;&#x6f;&#x6d;&#93;&#40;&#x29;">&#x5b;&#x71;&#x69;&#97;&#x6f;&#x2e;&#46;&#x2e;&#64;&#x67;&#x6d;&#x61;&#x69;&#108;&#46;&#99;&#x6f;&#x6d;&#93;&#40;&#x29;</a></p>
<blockquote>
<p>说的没错，cell已经成了先烈了。不过这不代表异构的方向不对，CUDA，OpenCL也都是异构平台，以后我们会越来越习惯异构平台的。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#111;&#58;&#x5b;&#x68;&#111;&#x6e;&#103;&#122;&#104;&#97;&#x6e;&#103;&#46;&#x2e;&#x2e;&#x2e;&#64;&#103;&#109;&#97;&#105;&#x6c;&#46;&#x63;&#x6f;&#109;&#93;&#x28;&#41;">&#x5b;&#x68;&#111;&#x6e;&#103;&#122;&#104;&#97;&#x6e;&#103;&#46;&#x2e;&#x2e;&#x2e;&#64;&#103;&#109;&#97;&#105;&#x6c;&#46;&#x63;&#x6f;&#109;&#93;&#x28;&#41;</a></p>
<p>异构平台如果编程复杂度降不下来的话很难流行起来。cell已经死了...</p>
<blockquote>
<p> 2010/3/24 qiaojie <a href="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#x6f;&#x3a;&#91;&#113;&#105;&#97;&#x6f;&#46;&#x2e;&#46;&#64;&#x67;&#x6d;&#x61;&#105;&#108;&#46;&#99;&#x6f;&#109;&#93;&#x28;&#41;">&#91;&#113;&#105;&#97;&#x6f;&#46;&#x2e;&#46;&#64;&#x67;&#x6d;&#x61;&#105;&#108;&#46;&#99;&#x6f;&#109;&#93;&#x28;&#41;</a></p>
<blockquote>
<p>不是所有的程序都需要并行化的，能用串行化解决的问题没必要并行，所以即使将来many-core系统成为主流，大部分程序员也没必要去搞并行计算。
  我觉得未来的主流应该是类似cell这样一颗全功能核心带众多协处理核心的异构系统，这样才能达到最优的 性能/核心面积比。</p>
<p>2010/3/24 Guancheng Chen <a href="&#109;&#x61;&#x69;&#x6c;&#116;&#x6f;&#58;&#x5b;&#99;&#104;&#x65;&#110;&#103;&#117;&#97;&#110;&#99;&#x68;&#46;&#x2e;&#46;&#64;&#103;&#109;&#97;&#105;&#x6c;&#46;&#x63;&#111;&#109;&#93;&#x28;&#x29;">&#x5b;&#99;&#104;&#x65;&#110;&#103;&#117;&#97;&#110;&#99;&#x68;&#46;&#x2e;&#46;&#64;&#103;&#109;&#97;&#105;&#x6c;&#46;&#x63;&#111;&#109;&#93;&#x28;&#x29;</a></p>
<p>Nice 大胆预测Linear speedup应该是每个程序员十年后的目标 呵呵</p>
<blockquote>
<p>On 3月23日, 上午10时43分, qiaojie <a href="&#x6d;&#x61;&#105;&#x6c;&#x74;&#x6f;&#58;&#x5b;&#x71;&#105;&#97;&#111;&#46;&#46;&#46;&#64;&#x67;&#x6d;&#97;&#105;&#108;&#x2e;&#x63;&#111;&#109;&#93;&#x28;&#41;">&#x5b;&#x71;&#105;&#97;&#111;&#46;&#46;&#46;&#64;&#x67;&#x6d;&#97;&#105;&#108;&#x2e;&#x63;&#111;&#109;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>目前正在写的是一个软件渲染器，采用了光栅化和光线跟踪混合算法，渲染算法已经完全并行化了，
在4核系统上基本可以达到线性加速比，更多核的系统暂时还没测试。kd-tree的构造暂时还没有并
行化，以后有空了再研究。</p>
<p>2010/3/23 Guancheng Chen <a href="&#x6d;&#97;&#x69;&#108;&#116;&#x6f;&#58;&#x5b;&#99;&#x68;&#101;&#110;&#x67;&#x75;&#x61;&#x6e;&#99;&#x68;&#x2e;&#46;&#x2e;&#64;&#103;&#109;&#x61;&#105;&#108;&#x2e;&#99;&#x6f;&#109;&#x5d;&#40;&#41;">&#x5b;&#99;&#x68;&#101;&#110;&#x67;&#x75;&#x61;&#x6e;&#99;&#x68;&#x2e;&#46;&#x2e;&#64;&#103;&#109;&#x61;&#105;&#108;&#x2e;&#99;&#x6f;&#109;&#x5d;&#40;&#41;</a></p>
<blockquote>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？</p>
<p>On 3月23日, 上午9时15分, qiaojie <a href="&#109;&#97;&#x69;&#x6c;&#x74;&#x6f;&#x3a;&#91;&#113;&#x69;&#97;&#111;&#x2e;&#x2e;&#46;&#64;&#103;&#x6d;&#x61;&#105;&#108;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#40;&#x29;">&#91;&#113;&#x69;&#97;&#111;&#x2e;&#x2e;&#46;&#64;&#103;&#x6d;&#x61;&#105;&#108;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1)
=
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank
Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？</p>
</blockquote>
<p> To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a></p>
<p><img src="" alt=""> 机械唯物主义 : linjunhalida <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-25</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>扯远了。我觉得并行和串行应该是信息处理本质上的2种方式，
在不同的场景下，可以采用不同的方式进行。
重要的是能够“又好又快”地实现需求，以及根据场景，把一个需求进行实现方式的伸缩。
不过看起来这样的工作还是要靠程序员来实现？而体系架构设计者要根据对应问题的本质特性来设计架构？
2010/3/25 机械唯物主义 : linjunhalida <a href="&#109;&#97;&#105;&#x6c;&#x74;&#x6f;&#x3a;&#91;&#x6c;&#x69;&#110;&#106;&#x75;&#x6e;&#x2e;&#x2e;&#46;&#x40;&#103;&#x6d;&#x61;&#105;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#40;&#41;">&#91;&#x6c;&#x69;&#110;&#106;&#x75;&#x6e;&#x2e;&#x2e;&#46;&#x40;&#103;&#x6d;&#x61;&#105;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#40;&#41;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>产能过剩的说法本来就不对。
产出的东西没有价值，这样的活动就不能说是生产。
比如我这个程序员，花了1周写了一个垃圾程序，然后被开除了。
然后1个月闲着，这是我产能过剩吗？
而闲着的原因是政府给我失业金，我就不需要工作闲起来了。。。</p>
<p>2010/3/25 qiaojie <a href="&#x6d;&#x61;&#x69;&#108;&#116;&#111;&#58;&#x5b;&#113;&#x69;&#97;&#46;&#x2e;&#x2e;&#x40;&#103;&#109;&#x61;&#105;&#x6c;&#46;&#x63;&#111;&#x6d;&#93;&#40;&#x29;">&#x5b;&#113;&#x69;&#97;&#46;&#x2e;&#x2e;&#x40;&#103;&#109;&#x61;&#105;&#x6c;&#46;&#x63;&#111;&#x6d;&#93;&#40;&#x29;</a>
如果产能=消费的话就没有产能过剩这一说了。</p>
<p>2010/3/25 机械唯物主义 : linjunhalida <a href="&#x6d;&#x61;&#x69;&#x6c;&#116;&#x6f;&#x3a;&#91;&#108;&#105;&#x6e;&#x6a;&#x75;&#x6e;&#x2e;&#46;&#46;&#x40;&#103;&#x6d;&#97;&#x69;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#x28;&#41;">&#91;&#108;&#105;&#x6e;&#x6a;&#x75;&#x6e;&#x2e;&#46;&#46;&#x40;&#103;&#x6d;&#97;&#x69;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#x28;&#41;</a></p>
<p>一个谬误：刺激需求
产能=消费，产能才是主动力。技术成长是随着产能成长而起来的。
而产能多的结果就是满足了需求，造成一种需求带来技术进步的假像。
而技术和产能之间的关系又错综复杂。。
2010/3/25 qiaojie <a href="&#x6d;&#x61;&#105;&#x6c;&#116;&#x6f;&#58;&#91;&#113;&#105;&#97;&#46;&#x2e;&#46;&#x40;&#103;&#109;&#x61;&#x69;&#108;&#x2e;&#x63;&#111;&#109;&#93;&#x28;&#41;">&#91;&#113;&#105;&#97;&#46;&#x2e;&#46;&#x40;&#103;&#109;&#x61;&#x69;&#108;&#x2e;&#x63;&#111;&#109;&#93;&#x28;&#41;</a></p>
<p>3D游戏就是一类杀手应用，由此支撑起了一个庞大的GPU市场，芯片行业的研发成本是很高的，没有一个庞大的市场是做不起来的。目前的消费者对于多核系统显然还没有强烈的需求，因为应用跟不上，i7发布快2年了还没进入主流市场，这种情况延续下去的话摩尔定律将因此失效。不过我相信杀手级应用总会出现的，这可能要硬件性能突破一个临界点，比方说目前GPU的性能再提升一个数量级的话，光线跟踪算法就可以提供流畅的接近CG的画质，倒是此类应用便会流行开来。</p>
<p>2010/3/25 Guancheng Chen <a href="&#109;&#x61;&#105;&#108;&#x74;&#111;&#58;&#x5b;&#x63;&#104;&#101;&#x6e;&#103;&#117;&#46;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#97;&#x69;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#41;">&#x5b;&#x63;&#104;&#101;&#x6e;&#103;&#117;&#46;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#97;&#x69;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#41;</a></p>
<p>杀手应用一般来说是指什么样的应用呢？比如用户群特别大的网游？还是那些专有的科学计算用的软件？
On 3月24日, 下午12时36分, qiaojie <a href="&#x6d;&#97;&#x69;&#108;&#x74;&#x6f;&#58;&#91;&#113;&#105;&#x61;&#111;&#46;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#97;&#105;&#x6c;&#x2e;&#99;&#x6f;&#109;&#x5d;&#x28;&#41;">&#91;&#113;&#105;&#x61;&#111;&#46;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#97;&#105;&#x6c;&#x2e;&#99;&#x6f;&#109;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>并行计算本来就是曲高和寡的东西，就跟3D渲染一样，能开发引擎的毕竟只是小部分人，大多数人在引擎的基础上做应用。关键在于是否有杀手应用，只要有大量的需求 ，自然会有人去做开发。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#111;&#x3a;&#91;&#x68;&#x6f;&#110;&#x67;&#x7a;&#104;&#x61;&#x6e;&#x67;&#x2e;&#x2e;&#x2e;&#x2e;&#64;&#103;&#x6d;&#x61;&#105;&#108;&#46;&#x63;&#x6f;&#x6d;&#93;&#40;&#x29;">&#91;&#x68;&#x6f;&#110;&#x67;&#x7a;&#104;&#x61;&#x6e;&#x67;&#x2e;&#x2e;&#x2e;&#x2e;&#64;&#103;&#x6d;&#x61;&#105;&#108;&#46;&#x63;&#x6f;&#x6d;&#93;&#40;&#x29;</a></p>
<blockquote>
<p>异构平台从网络处理器算起已经快10年了，现在情况仍然不明朗。就我看到的，异构平台要想高效，就必须向程序员暴露非常多的硬件细节，这必然导致编程的复杂性。 曲高和寡，要想渗透到应用程序这一块，我觉得很难。</p>
<p>2010/3/24 qiaojie <a href="&#x6d;&#97;&#105;&#x6c;&#116;&#111;&#58;&#x5b;&#x71;&#x69;&#97;&#111;&#46;&#x2e;&#46;&#x40;&#x67;&#x6d;&#x61;&#x69;&#108;&#46;&#x63;&#111;&#x6d;&#93;&#x28;&#41;">&#x5b;&#x71;&#x69;&#97;&#111;&#46;&#x2e;&#46;&#x40;&#x67;&#x6d;&#x61;&#x69;&#108;&#46;&#x63;&#111;&#x6d;&#93;&#x28;&#41;</a></p>
<blockquote>
<p>说的没错，cell已经成了先烈了。不过这不代表异构的方向不对，CUDA，OpenCL也都是异构平台，以后我们会越来越习惯异构平台的。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#109;&#x61;&#x69;&#108;&#x74;&#x6f;&#58;&#91;&#x68;&#x6f;&#110;&#103;&#122;&#104;&#x61;&#110;&#103;&#46;&#x2e;&#46;&#x2e;&#64;&#x67;&#109;&#97;&#x69;&#108;&#46;&#x63;&#x6f;&#x6d;&#93;&#40;&#41;">&#91;&#x68;&#x6f;&#110;&#103;&#122;&#104;&#x61;&#110;&#103;&#46;&#x2e;&#46;&#x2e;&#64;&#x67;&#109;&#97;&#x69;&#108;&#46;&#x63;&#x6f;&#x6d;&#93;&#40;&#41;</a></p>
<p>异构平台如果编程复杂度降不下来的话很难流行起来。cell已经死了...</p>
<blockquote>
<p> 2010/3/24 qiaojie <a href="&#109;&#97;&#105;&#x6c;&#x74;&#x6f;&#58;&#x5b;&#113;&#x69;&#97;&#x6f;&#46;&#x2e;&#x2e;&#64;&#103;&#x6d;&#97;&#105;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#93;&#40;&#41;">&#x5b;&#113;&#x69;&#97;&#x6f;&#46;&#x2e;&#x2e;&#64;&#103;&#x6d;&#97;&#105;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#93;&#40;&#41;</a></p>
<blockquote>
<p>不是所有的程序都需要并行化的，能用串行化解决的问题没必要并行，所以即使将来many-core系统成为主流，大部分程序员也没必要去搞并行计算。
  我觉得未来的主流应该是类似cell这样一颗全功能核心带众多协处理核心的异构系统，这样才能达到最优的 性能/核心面积比。</p>
<p>2010/3/24 Guancheng Chen <a href="&#x6d;&#97;&#105;&#108;&#x74;&#x6f;&#x3a;&#91;&#x63;&#x68;&#101;&#x6e;&#x67;&#117;&#x61;&#x6e;&#99;&#x68;&#46;&#x2e;&#x2e;&#64;&#103;&#109;&#x61;&#105;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#41;">&#91;&#x63;&#x68;&#101;&#x6e;&#x67;&#117;&#x61;&#x6e;&#99;&#x68;&#46;&#x2e;&#x2e;&#64;&#103;&#109;&#x61;&#105;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#41;</a></p>
<p>Nice 大胆预测Linear speedup应该是每个程序员十年后的目标 呵呵</p>
<blockquote>
<p>On 3月23日, 上午10时43分, qiaojie <a href="&#x6d;&#97;&#105;&#x6c;&#x74;&#111;&#58;&#x5b;&#113;&#x69;&#97;&#x6f;&#x2e;&#46;&#46;&#64;&#x67;&#x6d;&#97;&#x69;&#x6c;&#46;&#99;&#x6f;&#109;&#93;&#x28;&#41;">&#x5b;&#113;&#x69;&#97;&#x6f;&#x2e;&#46;&#46;&#64;&#x67;&#x6d;&#97;&#x69;&#x6c;&#46;&#99;&#x6f;&#109;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>目前正在写的是一个软件渲染器，采用了光栅化和光线跟踪混合算法，渲染算法已经完全并行化了，
在4核系统上基本可以达到线性加速比，更多核的系统暂时还没测试。kd-tree的构造暂时还没有并
行化，以后有空了再研究。</p>
<p>2010/3/23 Guancheng Chen <a href="&#x6d;&#97;&#105;&#108;&#116;&#111;&#x3a;&#91;&#99;&#104;&#101;&#110;&#x67;&#117;&#x61;&#110;&#99;&#x68;&#46;&#46;&#46;&#64;&#103;&#x6d;&#x61;&#105;&#108;&#x2e;&#99;&#111;&#109;&#93;&#40;&#x29;">&#91;&#99;&#104;&#101;&#110;&#x67;&#117;&#x61;&#110;&#99;&#x68;&#46;&#46;&#46;&#64;&#103;&#x6d;&#x61;&#105;&#108;&#x2e;&#99;&#111;&#109;&#93;&#40;&#x29;</a></p>
<blockquote>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？</p>
<p>On 3月23日, 上午9时15分, qiaojie <a href="&#109;&#x61;&#x69;&#x6c;&#116;&#111;&#x3a;&#91;&#x71;&#x69;&#97;&#x6f;&#x2e;&#x2e;&#46;&#x40;&#x67;&#x6d;&#97;&#x69;&#108;&#46;&#x63;&#111;&#109;&#93;&#x28;&#41;">&#91;&#x71;&#x69;&#97;&#x6f;&#x2e;&#x2e;&#46;&#x40;&#x67;&#x6d;&#97;&#x69;&#108;&#46;&#x63;&#111;&#109;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1)
=
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank
Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？</p>
</blockquote>
<p> To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> qiaojie <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-25</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>什么叫产能过剩？假设全世界每年消费10000亿斤粮食，结果今年收成好，生产了15000亿斤，</p>
<p>那多出来的5000亿斤无法被市场消化掉，就是产能过剩。那5000亿斤没价值，是垃圾？生产那
5000亿斤的农民是闲的蛋疼没事干？靠政府失业金养？</p>
<p>2010/3/25 机械唯物主义 : linjunhalida <a href="&#109;&#x61;&#105;&#108;&#x74;&#111;&#58;&#x5b;&#108;&#x69;&#x6e;&#106;&#x75;&#x6e;&#46;&#x2e;&#46;&#x40;&#103;&#109;&#97;&#x69;&#108;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#40;&#x29;">&#x5b;&#108;&#x69;&#x6e;&#106;&#x75;&#x6e;&#46;&#x2e;&#46;&#x40;&#103;&#109;&#97;&#x69;&#108;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#40;&#x29;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>产能过剩的说法本来就不对。
产出的东西没有价值，这样的活动就不能说是生产。
比如我这个程序员，花了1周写了一个垃圾程序，然后被开除了。
然后1个月闲着，这是我产能过剩吗？
而闲着的原因是政府给我失业金，我就不需要工作闲起来了。。。</p>
<p>2010/3/25 qiaojie <a href="&#109;&#x61;&#x69;&#108;&#x74;&#111;&#58;&#91;&#113;&#105;&#97;&#46;&#46;&#x2e;&#x40;&#103;&#x6d;&#97;&#x69;&#108;&#46;&#x63;&#111;&#109;&#93;&#x28;&#x29;">&#91;&#113;&#105;&#97;&#46;&#46;&#x2e;&#x40;&#103;&#x6d;&#97;&#x69;&#108;&#46;&#x63;&#111;&#109;&#93;&#x28;&#x29;</a>
如果产能=消费的话就没有产能过剩这一说了。</p>
<p>2010/3/25 机械唯物主义 : linjunhalida <a href="&#x6d;&#97;&#x69;&#108;&#116;&#111;&#x3a;&#x5b;&#x6c;&#105;&#x6e;&#106;&#x75;&#110;&#x2e;&#x2e;&#x2e;&#64;&#103;&#x6d;&#97;&#105;&#108;&#46;&#99;&#x6f;&#x6d;&#93;&#x28;&#x29;">&#x5b;&#x6c;&#105;&#x6e;&#106;&#x75;&#110;&#x2e;&#x2e;&#x2e;&#64;&#103;&#x6d;&#97;&#105;&#108;&#46;&#99;&#x6f;&#x6d;&#93;&#x28;&#x29;</a></p>
<p>一个谬误：刺激需求
产能=消费，产能才是主动力。技术成长是随着产能成长而起来的。
而产能多的结果就是满足了需求，造成一种需求带来技术进步的假像。
而技术和产能之间的关系又错综复杂。。
2010/3/25 qiaojie <a href="&#x6d;&#97;&#x69;&#108;&#x74;&#111;&#58;&#91;&#113;&#105;&#97;&#x2e;&#x2e;&#46;&#64;&#x67;&#x6d;&#x61;&#105;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#93;&#40;&#41;">&#91;&#113;&#105;&#97;&#x2e;&#x2e;&#46;&#64;&#x67;&#x6d;&#x61;&#105;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#93;&#40;&#41;</a></p>
<p>3D游戏就是一类杀手应用，由此支撑起了一个庞大的GPU市场，芯片行业的研发成本是很高的，没有一个庞大的市场是做不起来的。目前的消费者对于多核系统显然还没有强烈的需求，因为应用跟不上，i7发布快2年了还没进入主流市场，这种情况延续下去的话摩尔定律将因此失效。不过我相信杀手级应用总会出现的，这可能要硬件性能突破一个临界点，比方说目前GPU的性能再提升一个数量级的话，光线跟踪算法就可以提供流畅的接近CG的画质，倒是此类应用便会流行开来。</p>
<p>2010/3/25 Guancheng Chen <a href="&#109;&#x61;&#105;&#108;&#x74;&#x6f;&#x3a;&#91;&#99;&#104;&#101;&#110;&#x67;&#x75;&#x2e;&#46;&#x2e;&#x40;&#103;&#x6d;&#97;&#105;&#x6c;&#x2e;&#x63;&#111;&#109;&#x5d;&#40;&#x29;">&#91;&#99;&#104;&#101;&#110;&#x67;&#x75;&#x2e;&#46;&#x2e;&#x40;&#103;&#x6d;&#97;&#105;&#x6c;&#x2e;&#x63;&#111;&#109;&#x5d;&#40;&#x29;</a></p>
<p>杀手应用一般来说是指什么样的应用呢？比如用户群特别大的网游？还是那些专有的科学计算用的软件？
On 3月24日, 下午12时36分, qiaojie <a href="&#109;&#x61;&#105;&#108;&#x74;&#x6f;&#58;&#91;&#x71;&#105;&#97;&#111;&#46;&#46;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#46;&#x63;&#111;&#x6d;&#x5d;&#40;&#x29;">&#91;&#x71;&#105;&#97;&#111;&#46;&#46;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#46;&#x63;&#111;&#x6d;&#x5d;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>并行计算本来就是曲高和寡的东西，就跟3D渲染一样，能开发引擎的毕竟只是小部分人，大多数人在引擎的基础上做应用。关键在于是否有杀手应用，只要有大量的需求 ，自然会有人去做开发。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#x6d;&#97;&#x69;&#x6c;&#x74;&#111;&#x3a;&#x5b;&#x68;&#111;&#110;&#103;&#x7a;&#104;&#97;&#110;&#103;&#46;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#109;&#x61;&#x69;&#108;&#46;&#x63;&#111;&#109;&#93;&#40;&#x29;">&#x5b;&#x68;&#111;&#110;&#103;&#x7a;&#104;&#97;&#110;&#103;&#46;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#109;&#x61;&#x69;&#108;&#46;&#x63;&#111;&#109;&#93;&#40;&#x29;</a></p>
<blockquote>
<p>异构平台从网络处理器算起已经快10年了，现在情况仍然不明朗。就我看到的，异构平台要想高效，就必须向程序员暴露非常多的硬件细节，这必然导致编程的复杂性。 曲高和寡，要想渗透到应用程序这一块，我觉得很难。</p>
<p>2010/3/24 qiaojie <a href="&#x6d;&#97;&#x69;&#108;&#116;&#111;&#58;&#91;&#x71;&#105;&#97;&#111;&#46;&#x2e;&#x2e;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#x63;&#x6f;&#109;&#x5d;&#40;&#x29;">&#91;&#x71;&#105;&#97;&#111;&#46;&#x2e;&#x2e;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#x63;&#x6f;&#109;&#x5d;&#40;&#x29;</a></p>
<blockquote>
<p>说的没错，cell已经成了先烈了。不过这不代表异构的方向不对，CUDA，OpenCL也都是异构平台，以后我们会越来越习惯异构平台的。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#109;&#97;&#105;&#x6c;&#x74;&#111;&#x3a;&#x5b;&#104;&#111;&#110;&#103;&#122;&#104;&#x61;&#110;&#x67;&#x2e;&#46;&#x2e;&#46;&#x40;&#103;&#x6d;&#x61;&#x69;&#x6c;&#46;&#99;&#111;&#109;&#x5d;&#x28;&#x29;">&#x5b;&#104;&#111;&#110;&#103;&#122;&#104;&#x61;&#110;&#x67;&#x2e;&#46;&#x2e;&#46;&#x40;&#103;&#x6d;&#x61;&#x69;&#x6c;&#46;&#99;&#111;&#109;&#x5d;&#x28;&#x29;</a></p>
<p>异构平台如果编程复杂度降不下来的话很难流行起来。cell已经死了...</p>
<blockquote>
<p> 2010/3/24 qiaojie <a href="&#x6d;&#x61;&#105;&#108;&#x74;&#x6f;&#x3a;&#x5b;&#x71;&#x69;&#x61;&#x6f;&#x2e;&#46;&#46;&#64;&#x67;&#109;&#97;&#x69;&#108;&#x2e;&#99;&#111;&#109;&#93;&#40;&#41;">&#x5b;&#x71;&#x69;&#x61;&#x6f;&#x2e;&#46;&#46;&#64;&#x67;&#109;&#97;&#x69;&#108;&#x2e;&#99;&#111;&#109;&#93;&#40;&#41;</a></p>
<blockquote>
<p>不是所有的程序都需要并行化的，能用串行化解决的问题没必要并行，所以即使将来many-core系统成为主流，大部分程序员也没必要去搞并行计算。
  我觉得未来的主流应该是类似cell这样一颗全功能核心带众多协处理核心的异构系统，这样才能达到最优的 性能/核心面积比。</p>
<p>2010/3/24 Guancheng Chen <a href="&#109;&#97;&#105;&#108;&#x74;&#x6f;&#58;&#x5b;&#x63;&#x68;&#101;&#x6e;&#103;&#117;&#x61;&#x6e;&#99;&#104;&#46;&#46;&#x2e;&#x40;&#103;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#x29;">&#x5b;&#x63;&#x68;&#101;&#x6e;&#103;&#117;&#x61;&#x6e;&#99;&#104;&#46;&#46;&#x2e;&#x40;&#103;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#x29;</a></p>
<p>Nice 大胆预测Linear speedup应该是每个程序员十年后的目标 呵呵</p>
<blockquote>
<p>On 3月23日, 上午10时43分, qiaojie <a href="&#x6d;&#97;&#105;&#x6c;&#116;&#111;&#58;&#91;&#113;&#x69;&#97;&#x6f;&#46;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#x61;&#105;&#x6c;&#46;&#99;&#111;&#x6d;&#x5d;&#40;&#x29;">&#91;&#113;&#x69;&#97;&#x6f;&#46;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#x61;&#105;&#x6c;&#46;&#99;&#111;&#x6d;&#x5d;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>目前正在写的是一个软件渲染器，采用了光栅化和光线跟踪混合算法，渲染算法已经完全并行化了，
在4核系统上基本可以达到线性加速比，更多核的系统暂时还没测试。kd-tree的构造暂时还没有并
行化，以后有空了再研究。</p>
<p>2010/3/23 Guancheng Chen <a href="&#109;&#x61;&#105;&#108;&#x74;&#111;&#x3a;&#91;&#x63;&#x68;&#x65;&#x6e;&#103;&#117;&#97;&#x6e;&#x63;&#x68;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#109;&#x61;&#105;&#108;&#x2e;&#99;&#111;&#x6d;&#93;&#40;&#41;">&#91;&#x63;&#x68;&#x65;&#x6e;&#103;&#117;&#97;&#x6e;&#x63;&#x68;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#109;&#x61;&#105;&#108;&#x2e;&#99;&#111;&#x6d;&#93;&#40;&#41;</a></p>
<blockquote>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？</p>
<p>On 3月23日, 上午9时15分, qiaojie <a href="&#109;&#x61;&#105;&#x6c;&#116;&#111;&#58;&#x5b;&#x71;&#105;&#97;&#111;&#46;&#46;&#x2e;&#x40;&#x67;&#x6d;&#97;&#105;&#x6c;&#x2e;&#99;&#111;&#x6d;&#x5d;&#x28;&#41;">&#x5b;&#x71;&#105;&#97;&#111;&#46;&#46;&#x2e;&#x40;&#x67;&#x6d;&#97;&#105;&#x6c;&#x2e;&#99;&#111;&#x6d;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1)
=
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank
Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？</p>
</blockquote>
<p> To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a></p>
<p><img src="" alt=""> tinyfool <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-25</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>哈哈，终于从技术聊到经济了</p>
<p>在 2010-3-25，下午2:11， qiaojie 写道：</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>什么叫产能过剩？假设全世界每年消费10000亿斤粮食，结果今年收成好，生产了15000亿斤，</p>
<p>那多出来的5000亿斤无法被市场消化掉，就是产能过剩。那5000亿斤没价值，是垃圾？生产那
5000亿斤的农民是闲的蛋疼没事干？靠政府失业金养？</p>
<p>2010/3/25 机械唯物主义 : linjunhalida <a href="&#109;&#97;&#105;&#108;&#x74;&#x6f;&#x3a;&#91;&#x6c;&#x69;&#110;&#106;&#x75;&#110;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#x61;&#x69;&#108;&#x2e;&#99;&#111;&#109;&#x5d;&#x28;&#41;">&#91;&#x6c;&#x69;&#110;&#106;&#x75;&#110;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#x61;&#x69;&#108;&#x2e;&#99;&#111;&#109;&#x5d;&#x28;&#41;</a>
产能过剩的说法本来就不对。
产出的东西没有价值，这样的活动就不能说是生产。
比如我这个程序员，花了1周写了一个垃圾程序，然后被开除了。
然后1个月闲着，这是我产能过剩吗？
而闲着的原因是政府给我失业金，我就不需要工作闲起来了。。。</p>
<p>2010/3/25 qiaojie <a href="&#x6d;&#x61;&#x69;&#108;&#x74;&#x6f;&#x3a;&#x5b;&#113;&#105;&#97;&#46;&#46;&#x2e;&#64;&#103;&#x6d;&#97;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#93;&#40;&#x29;">&#x5b;&#113;&#105;&#97;&#46;&#46;&#x2e;&#64;&#103;&#x6d;&#97;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#93;&#40;&#x29;</a>
如果产能=消费的话就没有产能过剩这一说了。</p>
<p>2010/3/25 机械唯物主义 : linjunhalida <a href="&#109;&#x61;&#x69;&#108;&#116;&#x6f;&#x3a;&#91;&#x6c;&#x69;&#110;&#x6a;&#x75;&#x6e;&#46;&#46;&#x2e;&#64;&#x67;&#x6d;&#x61;&#x69;&#108;&#x2e;&#99;&#111;&#109;&#x5d;&#x28;&#x29;">&#91;&#x6c;&#x69;&#110;&#x6a;&#x75;&#x6e;&#46;&#46;&#x2e;&#64;&#x67;&#x6d;&#x61;&#x69;&#108;&#x2e;&#99;&#111;&#109;&#x5d;&#x28;&#x29;</a></p>
<p>一个谬误：刺激需求
产能=消费，产能才是主动力。技术成长是随着产能成长而起来的。
而产能多的结果就是满足了需求，造成一种需求带来技术进步的假像。
而技术和产能之间的关系又错综复杂。。
2010/3/25 qiaojie <a href="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#x6f;&#x3a;&#x5b;&#113;&#105;&#97;&#46;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#97;&#105;&#108;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#40;&#x29;">&#x5b;&#113;&#105;&#97;&#46;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#97;&#105;&#108;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#40;&#x29;</a></p>
<p>3D游戏就是一类杀手应用，由此支撑起了一个庞大的GPU市场，芯片行业的研发成本是很高的，没有一个庞大的市场是做不起来的。目前的消费者对于多核系统显然还没有强烈的需求，因为应用跟不上，i7发布快2年了还没进入主流市场，这种情况延续下去的话摩尔定律将因此失效。不过我相信杀手级应用总会出现的，这可能要硬件性能突破一个临界点，比方说目前GPU的性能再提升一个数量级的话，光线跟踪算法就可以提供流畅的接近CG的画质，倒是此类应用便会流行开来。</p>
<p>2010/3/25 Guancheng Chen <a href="&#109;&#x61;&#105;&#x6c;&#x74;&#x6f;&#x3a;&#x5b;&#x63;&#x68;&#x65;&#x6e;&#103;&#117;&#x2e;&#x2e;&#46;&#x40;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#x28;&#x29;">&#x5b;&#x63;&#x68;&#x65;&#x6e;&#103;&#117;&#x2e;&#x2e;&#46;&#x40;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#x28;&#x29;</a></p>
<p>杀手应用一般来说是指什么样的应用呢？比如用户群特别大的网游？还是那些专有的科学计算用的软件？
On 3月24日, 下午12时36分, qiaojie <a href="&#109;&#97;&#105;&#x6c;&#x74;&#111;&#58;&#x5b;&#x71;&#105;&#97;&#x6f;&#x2e;&#46;&#46;&#x40;&#103;&#109;&#x61;&#x69;&#108;&#46;&#x63;&#111;&#x6d;&#x5d;&#40;&#41;">&#x5b;&#x71;&#105;&#97;&#x6f;&#x2e;&#46;&#46;&#x40;&#103;&#109;&#x61;&#x69;&#108;&#46;&#x63;&#111;&#x6d;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>并行计算本来就是曲高和寡的东西，就跟3D渲染一样，能开发引擎的毕竟只是小部分人，大多数人在引擎的基础上做应用。关键在于是否有杀手应用，只要有大量的需求 ，自然会有人去做开发。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#x6d;&#97;&#105;&#108;&#116;&#x6f;&#58;&#91;&#104;&#111;&#110;&#x67;&#x7a;&#x68;&#x61;&#x6e;&#103;&#46;&#46;&#46;&#x2e;&#64;&#103;&#x6d;&#x61;&#105;&#x6c;&#46;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#x29;">&#91;&#104;&#111;&#110;&#x67;&#x7a;&#x68;&#x61;&#x6e;&#103;&#46;&#46;&#46;&#x2e;&#64;&#103;&#x6d;&#x61;&#105;&#x6c;&#46;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#x29;</a></p>
<blockquote>
<p>异构平台从网络处理器算起已经快10年了，现在情况仍然不明朗。就我看到的，异构平台要想高效，就必须向程序员暴露非常多的硬件细节，这必然导致编程的复杂性。 曲高和寡，要想渗透到应用程序这一块，我觉得很难。</p>
<p>2010/3/24 qiaojie <a href="&#x6d;&#97;&#105;&#108;&#x74;&#x6f;&#58;&#91;&#x71;&#105;&#97;&#111;&#x2e;&#46;&#x2e;&#x40;&#x67;&#x6d;&#97;&#x69;&#x6c;&#46;&#x63;&#111;&#x6d;&#x5d;&#40;&#x29;">&#91;&#x71;&#105;&#97;&#111;&#x2e;&#46;&#x2e;&#x40;&#x67;&#x6d;&#97;&#x69;&#x6c;&#46;&#x63;&#111;&#x6d;&#x5d;&#40;&#x29;</a></p>
<blockquote>
<p>说的没错，cell已经成了先烈了。不过这不代表异构的方向不对，CUDA，OpenCL也都是异构平台，以后我们会越来越习惯异构平台的。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#x6d;&#97;&#x69;&#108;&#116;&#x6f;&#x3a;&#91;&#x68;&#111;&#110;&#x67;&#x7a;&#x68;&#97;&#110;&#103;&#x2e;&#46;&#46;&#46;&#x40;&#x67;&#109;&#97;&#x69;&#x6c;&#46;&#x63;&#111;&#x6d;&#93;&#40;&#41;">&#91;&#x68;&#111;&#110;&#x67;&#x7a;&#x68;&#97;&#110;&#103;&#x2e;&#46;&#46;&#46;&#x40;&#x67;&#109;&#97;&#x69;&#x6c;&#46;&#x63;&#111;&#x6d;&#93;&#40;&#41;</a></p>
<p>异构平台如果编程复杂度降不下来的话很难流行起来。cell已经死了...</p>
<blockquote>
<p> 2010/3/24 qiaojie <a href="&#x6d;&#97;&#105;&#108;&#116;&#111;&#58;&#91;&#x71;&#105;&#97;&#111;&#46;&#46;&#x2e;&#64;&#x67;&#109;&#x61;&#105;&#108;&#46;&#x63;&#x6f;&#109;&#x5d;&#x28;&#x29;">&#91;&#x71;&#105;&#97;&#111;&#46;&#46;&#x2e;&#64;&#x67;&#109;&#x61;&#105;&#108;&#46;&#x63;&#x6f;&#109;&#x5d;&#x28;&#x29;</a></p>
<blockquote>
<p>不是所有的程序都需要并行化的，能用串行化解决的问题没必要并行，所以即使将来many-core系统成为主流，大部分程序员也没必要去搞并行计算。
  我觉得未来的主流应该是类似cell这样一颗全功能核心带众多协处理核心的异构系统，这样才能达到最优的 性能/核心面积比。</p>
<p>2010/3/24 Guancheng Chen <a href="&#x6d;&#x61;&#x69;&#x6c;&#116;&#x6f;&#x3a;&#x5b;&#x63;&#104;&#101;&#110;&#103;&#117;&#97;&#x6e;&#99;&#104;&#x2e;&#46;&#46;&#64;&#x67;&#109;&#x61;&#105;&#108;&#x2e;&#99;&#111;&#x6d;&#93;&#40;&#41;">&#x5b;&#x63;&#104;&#101;&#110;&#103;&#117;&#97;&#x6e;&#99;&#104;&#x2e;&#46;&#46;&#64;&#x67;&#109;&#x61;&#105;&#108;&#x2e;&#99;&#111;&#x6d;&#93;&#40;&#41;</a></p>
<p>Nice 大胆预测Linear speedup应该是每个程序员十年后的目标 呵呵</p>
<blockquote>
<p>On 3月23日, 上午10时43分, qiaojie <a href="&#x6d;&#x61;&#105;&#108;&#116;&#x6f;&#58;&#91;&#113;&#105;&#x61;&#x6f;&#46;&#x2e;&#x2e;&#x40;&#x67;&#109;&#x61;&#105;&#108;&#46;&#99;&#111;&#x6d;&#x5d;&#40;&#x29;">&#91;&#113;&#105;&#x61;&#x6f;&#46;&#x2e;&#x2e;&#x40;&#x67;&#109;&#x61;&#105;&#108;&#46;&#99;&#111;&#x6d;&#x5d;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>目前正在写的是一个软件渲染器，采用了光栅化和光线跟踪混合算法，渲染算法已经完全并行化了，
在4核系统上基本可以达到线性加速比，更多核的系统暂时还没测试。kd-tree的构造暂时还没有并
行化，以后有空了再研究。</p>
<p>2010/3/23 Guancheng Chen <a href="&#109;&#x61;&#105;&#108;&#116;&#x6f;&#x3a;&#x5b;&#99;&#104;&#x65;&#x6e;&#103;&#x75;&#x61;&#110;&#99;&#x68;&#46;&#46;&#x2e;&#64;&#x67;&#109;&#97;&#105;&#x6c;&#46;&#99;&#x6f;&#109;&#x5d;&#x28;&#x29;">&#x5b;&#99;&#104;&#x65;&#x6e;&#103;&#x75;&#x61;&#110;&#99;&#x68;&#46;&#46;&#x2e;&#64;&#x67;&#109;&#97;&#105;&#x6c;&#46;&#99;&#x6f;&#109;&#x5d;&#x28;&#x29;</a></p>
<blockquote>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？</p>
<p>On 3月23日, 上午9时15分, qiaojie <a href="&#109;&#x61;&#105;&#108;&#116;&#111;&#x3a;&#x5b;&#x71;&#105;&#97;&#x6f;&#46;&#46;&#x2e;&#x40;&#103;&#109;&#x61;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#93;&#x28;&#41;">&#x5b;&#x71;&#105;&#97;&#x6f;&#46;&#46;&#x2e;&#x40;&#103;&#109;&#x61;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1)
=
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank
Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？</p>
</blockquote>
<p> To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> 机械唯物主义 : linjunhalida <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-25</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>本来就不该生产那么多的粮食，多余的人力和土地可以用来做别的事情。
问题在于为什么他们估算错误？
2010/3/25 qiaojie <a href="&#x6d;&#97;&#105;&#x6c;&#116;&#111;&#x3a;&#x5b;&#x71;&#x69;&#97;&#46;&#x2e;&#46;&#64;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#46;&#x63;&#111;&#109;&#93;&#x28;&#x29;">&#x5b;&#x71;&#x69;&#97;&#46;&#x2e;&#46;&#64;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#46;&#x63;&#111;&#109;&#93;&#x28;&#x29;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>什么叫产能过剩？假设全世界每年消费10000亿斤粮食，结果今年收成好，生产了15000亿斤，</p>
<p>那多出来的5000亿斤无法被市场消化掉，就是产能过剩。那5000亿斤没价值，是垃圾？生产那
5000亿斤的农民是闲的蛋疼没事干？靠政府失业金养？</p>
<p>2010/3/25 机械唯物主义 : linjunhalida <a href="&#109;&#x61;&#105;&#x6c;&#x74;&#x6f;&#58;&#91;&#108;&#105;&#110;&#x6a;&#x75;&#x6e;&#x2e;&#x2e;&#46;&#64;&#x67;&#x6d;&#97;&#x69;&#108;&#46;&#x63;&#111;&#109;&#x5d;&#x28;&#x29;">&#91;&#108;&#105;&#110;&#x6a;&#x75;&#x6e;&#x2e;&#x2e;&#46;&#64;&#x67;&#x6d;&#97;&#x69;&#108;&#46;&#x63;&#111;&#109;&#x5d;&#x28;&#x29;</a>
产能过剩的说法本来就不对。
产出的东西没有价值，这样的活动就不能说是生产。
比如我这个程序员，花了1周写了一个垃圾程序，然后被开除了。
然后1个月闲着，这是我产能过剩吗？
而闲着的原因是政府给我失业金，我就不需要工作闲起来了。。。</p>
<p>2010/3/25 qiaojie <a href="&#109;&#x61;&#x69;&#x6c;&#x74;&#x6f;&#x3a;&#91;&#113;&#x69;&#x61;&#x2e;&#46;&#46;&#x40;&#103;&#x6d;&#x61;&#105;&#108;&#x2e;&#99;&#111;&#x6d;&#93;&#x28;&#x29;">&#91;&#113;&#x69;&#x61;&#x2e;&#46;&#46;&#x40;&#103;&#x6d;&#x61;&#105;&#108;&#x2e;&#99;&#111;&#x6d;&#93;&#x28;&#x29;</a>
如果产能=消费的话就没有产能过剩这一说了。</p>
<p>2010/3/25 机械唯物主义 : linjunhalida <a href="&#x6d;&#97;&#x69;&#108;&#x74;&#111;&#58;&#91;&#x6c;&#105;&#x6e;&#106;&#x75;&#110;&#x2e;&#x2e;&#x2e;&#64;&#103;&#109;&#97;&#x69;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#x28;&#41;">&#91;&#x6c;&#105;&#x6e;&#106;&#x75;&#110;&#x2e;&#x2e;&#x2e;&#64;&#103;&#109;&#97;&#x69;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#x28;&#41;</a></p>
<p>一个谬误：刺激需求
产能=消费，产能才是主动力。技术成长是随着产能成长而起来的。
而产能多的结果就是满足了需求，造成一种需求带来技术进步的假像。
而技术和产能之间的关系又错综复杂。。
2010/3/25 qiaojie <a href="&#109;&#x61;&#105;&#x6c;&#116;&#111;&#58;&#x5b;&#113;&#105;&#x61;&#46;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#x29;">&#x5b;&#113;&#105;&#x61;&#46;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#x29;</a></p>
<p>3D游戏就是一类杀手应用，由此支撑起了一个庞大的GPU市场，芯片行业的研发成本是很高的，没有一个庞大的市场是做不起来的。目前的消费者对于多核系统显然还没有强烈的需求，因为应用跟不上，i7发布快2年了还没进入主流市场，这种情况延续下去的话摩尔定律将因此失效。不过我相信杀手级应用总会出现的，这可能要硬件性能突破一个临界点，比方说目前GPU的性能再提升一个数量级的话，光线跟踪算法就可以提供流畅的接近CG的画质，倒是此类应用便会流行开来。</p>
<p>2010/3/25 Guancheng Chen <a href="&#109;&#x61;&#x69;&#x6c;&#x74;&#111;&#58;&#91;&#x63;&#x68;&#x65;&#110;&#x67;&#117;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#109;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#93;&#x28;&#x29;">&#91;&#x63;&#x68;&#x65;&#110;&#x67;&#117;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#109;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#93;&#x28;&#x29;</a></p>
<p>杀手应用一般来说是指什么样的应用呢？比如用户群特别大的网游？还是那些专有的科学计算用的软件？
On 3月24日, 下午12时36分, qiaojie <a href="&#x6d;&#x61;&#105;&#108;&#x74;&#111;&#58;&#x5b;&#113;&#105;&#x61;&#x6f;&#46;&#46;&#46;&#64;&#x67;&#109;&#x61;&#105;&#108;&#46;&#99;&#x6f;&#109;&#93;&#40;&#41;">&#x5b;&#113;&#105;&#x61;&#x6f;&#46;&#46;&#46;&#64;&#x67;&#109;&#x61;&#105;&#108;&#46;&#99;&#x6f;&#109;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>并行计算本来就是曲高和寡的东西，就跟3D渲染一样，能开发引擎的毕竟只是小部分人，大多数人在引擎的基础上做应用。关键在于是否有杀手应用，只要有大量的需求 ，自然会有人去做开发。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#x6d;&#97;&#105;&#x6c;&#116;&#111;&#58;&#x5b;&#x68;&#x6f;&#110;&#x67;&#122;&#104;&#x61;&#x6e;&#103;&#46;&#46;&#46;&#46;&#x40;&#x67;&#x6d;&#x61;&#x69;&#108;&#x2e;&#99;&#111;&#x6d;&#93;&#x28;&#x29;">&#x5b;&#x68;&#x6f;&#110;&#x67;&#122;&#104;&#x61;&#x6e;&#103;&#46;&#46;&#46;&#46;&#x40;&#x67;&#x6d;&#x61;&#x69;&#108;&#x2e;&#99;&#111;&#x6d;&#93;&#x28;&#x29;</a></p>
<blockquote>
<p>异构平台从网络处理器算起已经快10年了，现在情况仍然不明朗。就我看到的，异构平台要想高效，就必须向程序员暴露非常多的硬件细节，这必然导致编程的复杂性。 曲高和寡，要想渗透到应用程序这一块，我觉得很难。</p>
<p>2010/3/24 qiaojie <a href="&#109;&#97;&#105;&#108;&#116;&#x6f;&#58;&#91;&#113;&#105;&#x61;&#x6f;&#x2e;&#46;&#46;&#64;&#103;&#x6d;&#x61;&#105;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#93;&#40;&#41;">&#91;&#113;&#105;&#x61;&#x6f;&#x2e;&#46;&#46;&#64;&#103;&#x6d;&#x61;&#105;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#93;&#40;&#41;</a></p>
<blockquote>
<p>说的没错，cell已经成了先烈了。不过这不代表异构的方向不对，CUDA，OpenCL也都是异构平台，以后我们会越来越习惯异构平台的。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#x6d;&#97;&#x69;&#108;&#116;&#x6f;&#x3a;&#91;&#x68;&#x6f;&#x6e;&#103;&#122;&#x68;&#97;&#x6e;&#x67;&#46;&#46;&#46;&#46;&#x40;&#103;&#109;&#97;&#105;&#x6c;&#x2e;&#x63;&#111;&#109;&#x5d;&#x28;&#x29;">&#91;&#x68;&#x6f;&#x6e;&#103;&#122;&#x68;&#97;&#x6e;&#x67;&#46;&#46;&#46;&#46;&#x40;&#103;&#109;&#97;&#105;&#x6c;&#x2e;&#x63;&#111;&#109;&#x5d;&#x28;&#x29;</a></p>
<p>异构平台如果编程复杂度降不下来的话很难流行起来。cell已经死了...</p>
<blockquote>
<p> 2010/3/24 qiaojie <a href="&#x6d;&#x61;&#x69;&#108;&#x74;&#111;&#x3a;&#x5b;&#113;&#105;&#97;&#111;&#x2e;&#x2e;&#46;&#x40;&#x67;&#x6d;&#97;&#x69;&#x6c;&#46;&#x63;&#111;&#x6d;&#93;&#x28;&#x29;">&#x5b;&#113;&#105;&#97;&#111;&#x2e;&#x2e;&#46;&#x40;&#x67;&#x6d;&#97;&#x69;&#x6c;&#46;&#x63;&#111;&#x6d;&#93;&#x28;&#x29;</a></p>
<blockquote>
<p>不是所有的程序都需要并行化的，能用串行化解决的问题没必要并行，所以即使将来many-core系统成为主流，大部分程序员也没必要去搞并行计算。
  我觉得未来的主流应该是类似cell这样一颗全功能核心带众多协处理核心的异构系统，这样才能达到最优的 性能/核心面积比。</p>
<p>2010/3/24 Guancheng Chen <a href="&#109;&#x61;&#x69;&#108;&#x74;&#111;&#x3a;&#91;&#x63;&#x68;&#x65;&#x6e;&#x67;&#117;&#97;&#x6e;&#x63;&#104;&#x2e;&#46;&#x2e;&#x40;&#103;&#x6d;&#x61;&#x69;&#108;&#46;&#x63;&#111;&#x6d;&#x5d;&#40;&#x29;">&#91;&#x63;&#x68;&#x65;&#x6e;&#x67;&#117;&#97;&#x6e;&#x63;&#104;&#x2e;&#46;&#x2e;&#x40;&#103;&#x6d;&#x61;&#x69;&#108;&#46;&#x63;&#111;&#x6d;&#x5d;&#40;&#x29;</a></p>
<p>Nice 大胆预测Linear speedup应该是每个程序员十年后的目标 呵呵</p>
<blockquote>
<p>On 3月23日, 上午10时43分, qiaojie <a href="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#111;&#58;&#x5b;&#x71;&#105;&#97;&#x6f;&#x2e;&#46;&#x2e;&#64;&#103;&#109;&#97;&#x69;&#108;&#x2e;&#99;&#111;&#x6d;&#x5d;&#x28;&#41;">&#x5b;&#x71;&#105;&#97;&#x6f;&#x2e;&#46;&#x2e;&#64;&#103;&#109;&#97;&#x69;&#108;&#x2e;&#99;&#111;&#x6d;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>目前正在写的是一个软件渲染器，采用了光栅化和光线跟踪混合算法，渲染算法已经完全并行化了，
在4核系统上基本可以达到线性加速比，更多核的系统暂时还没测试。kd-tree的构造暂时还没有并
行化，以后有空了再研究。</p>
<p>2010/3/23 Guancheng Chen <a href="&#x6d;&#97;&#105;&#108;&#x74;&#x6f;&#58;&#x5b;&#99;&#x68;&#x65;&#110;&#103;&#117;&#x61;&#x6e;&#x63;&#104;&#46;&#x2e;&#46;&#x40;&#x67;&#109;&#x61;&#x69;&#x6c;&#46;&#x63;&#111;&#109;&#x5d;&#40;&#41;">&#x5b;&#99;&#x68;&#x65;&#110;&#103;&#117;&#x61;&#x6e;&#x63;&#104;&#46;&#x2e;&#46;&#x40;&#x67;&#109;&#x61;&#x69;&#x6c;&#46;&#x63;&#111;&#109;&#x5d;&#40;&#41;</a></p>
<blockquote>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？</p>
<p>On 3月23日, 上午9时15分, qiaojie <a href="&#109;&#x61;&#x69;&#108;&#116;&#x6f;&#58;&#91;&#113;&#x69;&#97;&#x6f;&#x2e;&#46;&#x2e;&#x40;&#x67;&#109;&#x61;&#x69;&#x6c;&#46;&#99;&#x6f;&#x6d;&#x5d;&#40;&#x29;">&#91;&#113;&#x69;&#97;&#x6f;&#x2e;&#46;&#x2e;&#x40;&#x67;&#109;&#x61;&#x69;&#x6c;&#46;&#99;&#x6f;&#x6d;&#x5d;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1)
=
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank
Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？</p>
</blockquote>
<p> To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a></p>
<p><img src="" alt=""> qiaojie <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-25</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>产能过剩和短缺导致的价格波动是市场经济的典型特征，想要消除过剩和短缺那叫计划经济，</p>
<p>学点经济学常识再来讨论这些问题吧。
2010/3/25 机械唯物主义 : linjunhalida <a href="&#x6d;&#x61;&#x69;&#108;&#x74;&#x6f;&#58;&#91;&#108;&#x69;&#x6e;&#106;&#117;&#x6e;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#109;&#97;&#x69;&#108;&#x2e;&#99;&#x6f;&#109;&#x5d;&#x28;&#41;">&#91;&#108;&#x69;&#x6e;&#106;&#117;&#x6e;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#109;&#97;&#x69;&#108;&#x2e;&#99;&#x6f;&#109;&#x5d;&#x28;&#41;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>本来就不该生产那么多的粮食，多余的人力和土地可以用来做别的事情。
问题在于为什么他们估算错误？</p>
<p>2010/3/25 qiaojie <a href="&#x6d;&#97;&#x69;&#x6c;&#116;&#x6f;&#x3a;&#x5b;&#x71;&#x69;&#97;&#46;&#x2e;&#46;&#64;&#103;&#x6d;&#x61;&#105;&#108;&#x2e;&#99;&#111;&#x6d;&#x5d;&#x28;&#41;">&#x5b;&#x71;&#x69;&#97;&#46;&#x2e;&#46;&#64;&#103;&#x6d;&#x61;&#105;&#108;&#x2e;&#99;&#111;&#x6d;&#x5d;&#x28;&#41;</a>
什么叫产能过剩？假设全世界每年消费10000亿斤粮食，结果今年收成好，生产了15000亿斤，</p>
<p>那多出来的5000亿斤无法被市场消化掉，就是产能过剩。那5000亿斤没价值，是垃圾？生产那
5000亿斤的农民是闲的蛋疼没事干？靠政府失业金养？</p>
<p>2010/3/25 机械唯物主义 : linjunhalida <a href="&#x6d;&#97;&#x69;&#108;&#x74;&#111;&#x3a;&#91;&#x6c;&#105;&#110;&#x6a;&#x75;&#110;&#46;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#99;&#x6f;&#109;&#x5d;&#40;&#x29;">&#91;&#x6c;&#105;&#110;&#x6a;&#x75;&#110;&#46;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#99;&#x6f;&#109;&#x5d;&#40;&#x29;</a>
产能过剩的说法本来就不对。
产出的东西没有价值，这样的活动就不能说是生产。
比如我这个程序员，花了1周写了一个垃圾程序，然后被开除了。
然后1个月闲着，这是我产能过剩吗？
而闲着的原因是政府给我失业金，我就不需要工作闲起来了。。。</p>
<p>2010/3/25 qiaojie <a href="&#109;&#97;&#x69;&#x6c;&#116;&#x6f;&#x3a;&#x5b;&#113;&#x69;&#97;&#46;&#46;&#x2e;&#x40;&#x67;&#109;&#x61;&#x69;&#x6c;&#x2e;&#99;&#111;&#x6d;&#93;&#x28;&#41;">&#x5b;&#113;&#x69;&#97;&#46;&#46;&#x2e;&#x40;&#x67;&#109;&#x61;&#x69;&#x6c;&#x2e;&#99;&#111;&#x6d;&#93;&#x28;&#41;</a>
如果产能=消费的话就没有产能过剩这一说了。</p>
<p>2010/3/25 机械唯物主义 : linjunhalida <a href="&#x6d;&#97;&#x69;&#108;&#116;&#111;&#58;&#91;&#x6c;&#105;&#x6e;&#106;&#117;&#110;&#x2e;&#46;&#x2e;&#64;&#x67;&#109;&#x61;&#x69;&#108;&#x2e;&#x63;&#111;&#109;&#x5d;&#x28;&#x29;">&#91;&#x6c;&#105;&#x6e;&#106;&#117;&#110;&#x2e;&#46;&#x2e;&#64;&#x67;&#109;&#x61;&#x69;&#108;&#x2e;&#x63;&#111;&#109;&#x5d;&#x28;&#x29;</a></p>
<p>一个谬误：刺激需求
产能=消费，产能才是主动力。技术成长是随着产能成长而起来的。
而产能多的结果就是满足了需求，造成一种需求带来技术进步的假像。
而技术和产能之间的关系又错综复杂。。
2010/3/25 qiaojie <a href="&#x6d;&#97;&#x69;&#x6c;&#116;&#111;&#x3a;&#x5b;&#113;&#x69;&#97;&#46;&#46;&#x2e;&#x40;&#x67;&#109;&#97;&#105;&#x6c;&#x2e;&#99;&#111;&#109;&#x5d;&#40;&#41;">&#x5b;&#113;&#x69;&#97;&#46;&#46;&#x2e;&#x40;&#x67;&#109;&#97;&#105;&#x6c;&#x2e;&#99;&#111;&#109;&#x5d;&#40;&#41;</a></p>
<p>3D游戏就是一类杀手应用，由此支撑起了一个庞大的GPU市场，芯片行业的研发成本是很高的，没有一个庞大的市场是做不起来的。目前的消费者对于多核系统显然还没有强烈的需求，因为应用跟不上，i7发布快2年了还没进入主流市场，这种情况延续下去的话摩尔定律将因此失效。不过我相信杀手级应用总会出现的，这可能要硬件性能突破一个临界点，比方说目前GPU的性能再提升一个数量级的话，光线跟踪算法就可以提供流畅的接近CG的画质，倒是此类应用便会流行开来。</p>
<p>2010/3/25 Guancheng Chen <a href="&#x6d;&#97;&#105;&#x6c;&#116;&#111;&#x3a;&#91;&#x63;&#x68;&#x65;&#110;&#103;&#117;&#x2e;&#46;&#x2e;&#x40;&#x67;&#x6d;&#97;&#x69;&#x6c;&#46;&#x63;&#x6f;&#109;&#x5d;&#x28;&#x29;">&#91;&#x63;&#x68;&#x65;&#110;&#103;&#117;&#x2e;&#46;&#x2e;&#x40;&#x67;&#x6d;&#97;&#x69;&#x6c;&#46;&#x63;&#x6f;&#109;&#x5d;&#x28;&#x29;</a></p>
<p>杀手应用一般来说是指什么样的应用呢？比如用户群特别大的网游？还是那些专有的科学计算用的软件？
On 3月24日, 下午12时36分, qiaojie <a href="&#109;&#97;&#105;&#108;&#x74;&#111;&#x3a;&#91;&#113;&#x69;&#97;&#111;&#x2e;&#46;&#46;&#x40;&#103;&#109;&#97;&#105;&#x6c;&#46;&#x63;&#x6f;&#109;&#93;&#40;&#41;">&#91;&#113;&#x69;&#97;&#111;&#x2e;&#46;&#46;&#x40;&#103;&#109;&#97;&#105;&#x6c;&#46;&#x63;&#x6f;&#109;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>并行计算本来就是曲高和寡的东西，就跟3D渲染一样，能开发引擎的毕竟只是小部分人，大多数人在引擎的基础上做应用。关键在于是否有杀手应用，只要有大量的需求 ，自然会有人去做开发。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#109;&#97;&#x69;&#x6c;&#x74;&#111;&#58;&#x5b;&#x68;&#x6f;&#x6e;&#x67;&#x7a;&#x68;&#97;&#110;&#103;&#x2e;&#46;&#46;&#46;&#x40;&#103;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#111;&#109;&#93;&#x28;&#x29;">&#x5b;&#x68;&#x6f;&#x6e;&#x67;&#x7a;&#x68;&#97;&#110;&#103;&#x2e;&#46;&#46;&#46;&#x40;&#103;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#111;&#109;&#93;&#x28;&#x29;</a></p>
<blockquote>
<p>异构平台从网络处理器算起已经快10年了，现在情况仍然不明朗。就我看到的，异构平台要想高效，就必须向程序员暴露非常多的硬件细节，这必然导致编程的复杂性。 曲高和寡，要想渗透到应用程序这一块，我觉得很难。</p>
<p>2010/3/24 qiaojie <a href="&#109;&#x61;&#x69;&#x6c;&#116;&#x6f;&#58;&#91;&#113;&#x69;&#97;&#x6f;&#46;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#105;&#108;&#x2e;&#x63;&#111;&#109;&#93;&#40;&#x29;">&#91;&#113;&#x69;&#97;&#x6f;&#46;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#105;&#108;&#x2e;&#x63;&#111;&#109;&#93;&#40;&#x29;</a></p>
<blockquote>
<p>说的没错，cell已经成了先烈了。不过这不代表异构的方向不对，CUDA，OpenCL也都是异构平台，以后我们会越来越习惯异构平台的。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#x6d;&#97;&#x69;&#108;&#x74;&#x6f;&#58;&#x5b;&#104;&#111;&#110;&#103;&#122;&#x68;&#97;&#110;&#x67;&#x2e;&#46;&#x2e;&#46;&#x40;&#x67;&#x6d;&#97;&#105;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#93;&#x28;&#41;">&#x5b;&#104;&#111;&#110;&#103;&#122;&#x68;&#97;&#110;&#x67;&#x2e;&#46;&#x2e;&#46;&#x40;&#x67;&#x6d;&#97;&#105;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#93;&#x28;&#41;</a></p>
<p>异构平台如果编程复杂度降不下来的话很难流行起来。cell已经死了...</p>
<blockquote>
<p> 2010/3/24 qiaojie <a href="&#x6d;&#97;&#x69;&#x6c;&#116;&#111;&#58;&#x5b;&#113;&#x69;&#x61;&#x6f;&#46;&#46;&#46;&#64;&#103;&#109;&#97;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#93;&#40;&#41;">&#x5b;&#113;&#x69;&#x61;&#x6f;&#46;&#46;&#46;&#64;&#103;&#109;&#97;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#93;&#40;&#41;</a></p>
<blockquote>
<p>不是所有的程序都需要并行化的，能用串行化解决的问题没必要并行，所以即使将来many-core系统成为主流，大部分程序员也没必要去搞并行计算。
  我觉得未来的主流应该是类似cell这样一颗全功能核心带众多协处理核心的异构系统，这样才能达到最优的 性能/核心面积比。</p>
<p>2010/3/24 Guancheng Chen <a href="&#x6d;&#97;&#105;&#x6c;&#x74;&#111;&#58;&#x5b;&#x63;&#104;&#x65;&#x6e;&#x67;&#x75;&#97;&#110;&#x63;&#104;&#46;&#46;&#x2e;&#64;&#x67;&#x6d;&#x61;&#105;&#108;&#x2e;&#99;&#x6f;&#x6d;&#93;&#x28;&#x29;">&#x5b;&#x63;&#104;&#x65;&#x6e;&#x67;&#x75;&#97;&#110;&#x63;&#104;&#46;&#46;&#x2e;&#64;&#x67;&#x6d;&#x61;&#105;&#108;&#x2e;&#99;&#x6f;&#x6d;&#93;&#x28;&#x29;</a></p>
<p>Nice 大胆预测Linear speedup应该是每个程序员十年后的目标 呵呵</p>
<blockquote>
<p>On 3月23日, 上午10时43分, qiaojie <a href="&#109;&#x61;&#105;&#x6c;&#x74;&#x6f;&#58;&#x5b;&#113;&#x69;&#x61;&#x6f;&#46;&#x2e;&#46;&#x40;&#103;&#109;&#97;&#x69;&#x6c;&#46;&#99;&#111;&#109;&#x5d;&#40;&#x29;">&#x5b;&#113;&#x69;&#x61;&#x6f;&#46;&#x2e;&#46;&#x40;&#103;&#109;&#97;&#x69;&#x6c;&#46;&#99;&#111;&#109;&#x5d;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>目前正在写的是一个软件渲染器，采用了光栅化和光线跟踪混合算法，渲染算法已经完全并行化了，
在4核系统上基本可以达到线性加速比，更多核的系统暂时还没测试。kd-tree的构造暂时还没有并
行化，以后有空了再研究。</p>
<p>2010/3/23 Guancheng Chen <a href="&#x6d;&#x61;&#105;&#x6c;&#x74;&#x6f;&#x3a;&#91;&#99;&#104;&#x65;&#110;&#x67;&#117;&#97;&#x6e;&#99;&#x68;&#x2e;&#46;&#x2e;&#x40;&#x67;&#x6d;&#97;&#x69;&#x6c;&#46;&#x63;&#111;&#x6d;&#93;&#x28;&#41;">&#91;&#99;&#104;&#x65;&#110;&#x67;&#117;&#97;&#x6e;&#99;&#x68;&#x2e;&#46;&#x2e;&#x40;&#x67;&#x6d;&#97;&#x69;&#x6c;&#46;&#x63;&#111;&#x6d;&#93;&#x28;&#41;</a></p>
<blockquote>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？</p>
<p>On 3月23日, 上午9时15分, qiaojie <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#x3a;&#x5b;&#x71;&#105;&#x61;&#111;&#46;&#x2e;&#46;&#64;&#103;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#41;">&#x5b;&#x71;&#105;&#x61;&#111;&#46;&#x2e;&#46;&#64;&#103;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1)
=
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank
Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？</p>
</blockquote>
<p> To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> 机械唯物主义 : linjunhalida <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-25</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>小规模的，市场会自动调节。
如果出现大规模的问题，就有可能是信息错误——货币的币值变了。
2010/3/25 qiaojie <a href="&#109;&#97;&#105;&#x6c;&#116;&#111;&#x3a;&#91;&#x71;&#105;&#x61;&#x2e;&#46;&#x2e;&#64;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#46;&#x63;&#x6f;&#109;&#x5d;&#40;&#x29;">&#91;&#x71;&#105;&#x61;&#x2e;&#46;&#x2e;&#64;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#46;&#x63;&#x6f;&#109;&#x5d;&#40;&#x29;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>产能过剩和短缺导致的价格波动是市场经济的典型特征，想要消除过剩和短缺那叫计划经济，</p>
<p>学点经济学常识再来讨论这些问题吧。
2010/3/25 机械唯物主义 : linjunhalida <a href="&#109;&#97;&#105;&#108;&#x74;&#x6f;&#x3a;&#91;&#x6c;&#105;&#x6e;&#106;&#117;&#110;&#46;&#46;&#46;&#64;&#103;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#x63;&#111;&#109;&#93;&#40;&#41;">&#91;&#x6c;&#105;&#x6e;&#106;&#117;&#110;&#46;&#46;&#46;&#64;&#103;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#x63;&#111;&#109;&#93;&#40;&#41;</a>
本来就不该生产那么多的粮食，多余的人力和土地可以用来做别的事情。
问题在于为什么他们估算错误？</p>
<p>2010/3/25 qiaojie <a href="&#109;&#x61;&#105;&#x6c;&#x74;&#111;&#x3a;&#x5b;&#x71;&#105;&#97;&#x2e;&#46;&#x2e;&#x40;&#103;&#x6d;&#97;&#x69;&#108;&#46;&#99;&#111;&#x6d;&#x5d;&#x28;&#x29;">&#x5b;&#x71;&#105;&#97;&#x2e;&#46;&#x2e;&#x40;&#103;&#x6d;&#97;&#x69;&#108;&#46;&#99;&#111;&#x6d;&#x5d;&#x28;&#x29;</a>
什么叫产能过剩？假设全世界每年消费10000亿斤粮食，结果今年收成好，生产了15000亿斤，</p>
<p>那多出来的5000亿斤无法被市场消化掉，就是产能过剩。那5000亿斤没价值，是垃圾？生产那
5000亿斤的农民是闲的蛋疼没事干？靠政府失业金养？</p>
<p>2010/3/25 机械唯物主义 : linjunhalida <a href="&#x6d;&#97;&#x69;&#108;&#x74;&#111;&#58;&#x5b;&#x6c;&#x69;&#110;&#106;&#x75;&#x6e;&#46;&#46;&#46;&#64;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#99;&#111;&#x6d;&#x5d;&#40;&#x29;">&#x5b;&#x6c;&#x69;&#110;&#106;&#x75;&#x6e;&#46;&#46;&#46;&#64;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#99;&#111;&#x6d;&#x5d;&#40;&#x29;</a>
产能过剩的说法本来就不对。
产出的东西没有价值，这样的活动就不能说是生产。
比如我这个程序员，花了1周写了一个垃圾程序，然后被开除了。
然后1个月闲着，这是我产能过剩吗？
而闲着的原因是政府给我失业金，我就不需要工作闲起来了。。。</p>
<p>2010/3/25 qiaojie <a href="&#109;&#97;&#x69;&#108;&#116;&#x6f;&#58;&#91;&#x71;&#105;&#x61;&#x2e;&#x2e;&#46;&#64;&#x67;&#109;&#97;&#x69;&#108;&#46;&#99;&#x6f;&#109;&#x5d;&#40;&#41;">&#91;&#x71;&#105;&#x61;&#x2e;&#x2e;&#46;&#64;&#x67;&#109;&#97;&#x69;&#108;&#46;&#99;&#x6f;&#109;&#x5d;&#40;&#41;</a>
如果产能=消费的话就没有产能过剩这一说了。</p>
<p>2010/3/25 机械唯物主义 : linjunhalida <a href="&#109;&#x61;&#105;&#x6c;&#x74;&#111;&#x3a;&#x5b;&#108;&#x69;&#x6e;&#x6a;&#x75;&#110;&#46;&#x2e;&#x2e;&#64;&#103;&#109;&#x61;&#105;&#108;&#46;&#x63;&#x6f;&#109;&#x5d;&#40;&#41;">&#x5b;&#108;&#x69;&#x6e;&#x6a;&#x75;&#110;&#46;&#x2e;&#x2e;&#64;&#103;&#109;&#x61;&#105;&#108;&#46;&#x63;&#x6f;&#109;&#x5d;&#40;&#41;</a></p>
<p>一个谬误：刺激需求
产能=消费，产能才是主动力。技术成长是随着产能成长而起来的。
而产能多的结果就是满足了需求，造成一种需求带来技术进步的假像。
而技术和产能之间的关系又错综复杂。。
2010/3/25 qiaojie <a href="&#109;&#x61;&#x69;&#x6c;&#x74;&#x6f;&#x3a;&#91;&#x71;&#x69;&#x61;&#x2e;&#46;&#46;&#64;&#103;&#109;&#x61;&#105;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#41;">&#91;&#x71;&#x69;&#x61;&#x2e;&#46;&#46;&#64;&#103;&#109;&#x61;&#105;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#41;</a></p>
<p>3D游戏就是一类杀手应用，由此支撑起了一个庞大的GPU市场，芯片行业的研发成本是很高的，没有一个庞大的市场是做不起来的。目前的消费者对于多核系统显然还没有强烈的需求，因为应用跟不上，i7发布快2年了还没进入主流市场，这种情况延续下去的话摩尔定律将因此失效。不过我相信杀手级应用总会出现的，这可能要硬件性能突破一个临界点，比方说目前GPU的性能再提升一个数量级的话，光线跟踪算法就可以提供流畅的接近CG的画质，倒是此类应用便会流行开来。</p>
<p>2010/3/25 Guancheng Chen <a href="&#x6d;&#97;&#x69;&#x6c;&#116;&#111;&#58;&#x5b;&#99;&#104;&#x65;&#110;&#x67;&#117;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#109;&#x61;&#105;&#108;&#46;&#x63;&#x6f;&#x6d;&#93;&#x28;&#41;">&#x5b;&#99;&#104;&#x65;&#110;&#x67;&#117;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#109;&#x61;&#105;&#108;&#46;&#x63;&#x6f;&#x6d;&#93;&#x28;&#41;</a></p>
<p>杀手应用一般来说是指什么样的应用呢？比如用户群特别大的网游？还是那些专有的科学计算用的软件？
On 3月24日, 下午12时36分, qiaojie <a href="&#109;&#x61;&#105;&#x6c;&#116;&#111;&#x3a;&#91;&#113;&#x69;&#x61;&#x6f;&#x2e;&#46;&#46;&#x40;&#103;&#109;&#x61;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#93;&#40;&#x29;">&#91;&#113;&#x69;&#x61;&#x6f;&#x2e;&#46;&#46;&#x40;&#103;&#109;&#x61;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>并行计算本来就是曲高和寡的东西，就跟3D渲染一样，能开发引擎的毕竟只是小部分人，大多数人在引擎的基础上做应用。关键在于是否有杀手应用，只要有大量的需求 ，自然会有人去做开发。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#x6f;&#58;&#91;&#x68;&#x6f;&#x6e;&#103;&#122;&#x68;&#97;&#110;&#103;&#x2e;&#46;&#x2e;&#x2e;&#x40;&#103;&#109;&#x61;&#x69;&#108;&#46;&#99;&#111;&#109;&#93;&#40;&#x29;">&#91;&#x68;&#x6f;&#x6e;&#103;&#122;&#x68;&#97;&#110;&#103;&#x2e;&#46;&#x2e;&#x2e;&#x40;&#103;&#109;&#x61;&#x69;&#108;&#46;&#99;&#111;&#109;&#93;&#40;&#x29;</a></p>
<blockquote>
<p>异构平台从网络处理器算起已经快10年了，现在情况仍然不明朗。就我看到的，异构平台要想高效，就必须向程序员暴露非常多的硬件细节，这必然导致编程的复杂性。 曲高和寡，要想渗透到应用程序这一块，我觉得很难。</p>
<p>2010/3/24 qiaojie <a href="&#109;&#97;&#105;&#108;&#x74;&#x6f;&#x3a;&#91;&#113;&#x69;&#97;&#111;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#109;&#x61;&#105;&#108;&#46;&#99;&#x6f;&#109;&#x5d;&#x28;&#41;">&#91;&#113;&#x69;&#97;&#111;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#109;&#x61;&#105;&#108;&#46;&#99;&#x6f;&#109;&#x5d;&#x28;&#41;</a></p>
<blockquote>
<p>说的没错，cell已经成了先烈了。不过这不代表异构的方向不对，CUDA，OpenCL也都是异构平台，以后我们会越来越习惯异构平台的。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#109;&#97;&#x69;&#108;&#x74;&#x6f;&#x3a;&#x5b;&#104;&#x6f;&#110;&#103;&#x7a;&#x68;&#x61;&#x6e;&#103;&#x2e;&#x2e;&#46;&#x2e;&#x40;&#103;&#109;&#97;&#105;&#108;&#x2e;&#99;&#x6f;&#x6d;&#93;&#40;&#x29;">&#x5b;&#104;&#x6f;&#110;&#103;&#x7a;&#x68;&#x61;&#x6e;&#103;&#x2e;&#x2e;&#46;&#x2e;&#x40;&#103;&#109;&#97;&#105;&#108;&#x2e;&#99;&#x6f;&#x6d;&#93;&#40;&#x29;</a></p>
<p>异构平台如果编程复杂度降不下来的话很难流行起来。cell已经死了...</p>
<blockquote>
<p> 2010/3/24 qiaojie <a href="&#x6d;&#97;&#x69;&#x6c;&#x74;&#x6f;&#58;&#91;&#x71;&#105;&#x61;&#x6f;&#46;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#x61;&#x69;&#x6c;&#46;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#x29;">&#91;&#x71;&#105;&#x61;&#x6f;&#46;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#x61;&#x69;&#x6c;&#46;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#x29;</a></p>
<blockquote>
<p>不是所有的程序都需要并行化的，能用串行化解决的问题没必要并行，所以即使将来many-core系统成为主流，大部分程序员也没必要去搞并行计算。
  我觉得未来的主流应该是类似cell这样一颗全功能核心带众多协处理核心的异构系统，这样才能达到最优的 性能/核心面积比。</p>
<p>2010/3/24 Guancheng Chen <a href="&#109;&#97;&#105;&#108;&#116;&#x6f;&#x3a;&#91;&#99;&#104;&#101;&#110;&#x67;&#117;&#x61;&#110;&#99;&#x68;&#46;&#46;&#46;&#x40;&#103;&#x6d;&#97;&#x69;&#108;&#x2e;&#99;&#111;&#109;&#x5d;&#x28;&#x29;">&#91;&#99;&#104;&#101;&#110;&#x67;&#117;&#x61;&#110;&#99;&#x68;&#46;&#46;&#46;&#x40;&#103;&#x6d;&#97;&#x69;&#108;&#x2e;&#99;&#111;&#109;&#x5d;&#x28;&#x29;</a></p>
<p>Nice 大胆预测Linear speedup应该是每个程序员十年后的目标 呵呵</p>
<blockquote>
<p>On 3月23日, 上午10时43分, qiaojie <a href="&#x6d;&#97;&#105;&#108;&#x74;&#111;&#58;&#91;&#113;&#x69;&#x61;&#111;&#46;&#x2e;&#x2e;&#64;&#103;&#x6d;&#97;&#x69;&#108;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#x28;&#x29;">&#91;&#113;&#x69;&#x61;&#111;&#46;&#x2e;&#x2e;&#64;&#103;&#x6d;&#97;&#x69;&#108;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>目前正在写的是一个软件渲染器，采用了光栅化和光线跟踪混合算法，渲染算法已经完全并行化了，
在4核系统上基本可以达到线性加速比，更多核的系统暂时还没测试。kd-tree的构造暂时还没有并
行化，以后有空了再研究。</p>
<p>2010/3/23 Guancheng Chen <a href="&#x6d;&#x61;&#x69;&#108;&#x74;&#x6f;&#x3a;&#91;&#x63;&#x68;&#101;&#x6e;&#103;&#x75;&#x61;&#110;&#x63;&#x68;&#46;&#46;&#46;&#x40;&#103;&#x6d;&#97;&#x69;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#93;&#x28;&#41;">&#91;&#x63;&#x68;&#101;&#x6e;&#103;&#x75;&#x61;&#110;&#x63;&#x68;&#46;&#46;&#46;&#x40;&#103;&#x6d;&#97;&#x69;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#93;&#x28;&#41;</a></p>
<blockquote>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？</p>
<p>On 3月23日, 上午9时15分, qiaojie <a href="&#109;&#x61;&#x69;&#108;&#x74;&#111;&#x3a;&#91;&#x71;&#x69;&#97;&#111;&#46;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#x28;&#41;">&#91;&#x71;&#x69;&#97;&#111;&#46;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1)
=
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank
Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？</p>
</blockquote>
<p> To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a></p>
<p><img src="" alt=""> qiaojie <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-25</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>恩，很快会被升华成为政治问题
2010/3/25 郝培强 tinyfool <a href="&#109;&#x61;&#x69;&#108;&#x74;&#111;&#58;&#91;&#116;&#105;&#x6e;&#121;&#x2e;&#46;&#x2e;&#x40;&#x67;&#109;&#x61;&#x69;&#x6c;&#46;&#x63;&#111;&#109;&#93;&#40;&#41;">&#91;&#116;&#105;&#x6e;&#121;&#x2e;&#46;&#x2e;&#x40;&#x67;&#109;&#x61;&#x69;&#x6c;&#46;&#x63;&#111;&#109;&#93;&#40;&#41;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>哈哈，终于从技术聊到经济了</p>
<p>在 2010-3-25，下午2:11， qiaojie 写道：</p>
<p>什么叫产能过剩？假设全世界每年消费10000亿斤粮食，结果今年收成好，生产了15000亿斤，</p>
<p>那多出来的5000亿斤无法被市场消化掉，就是产能过剩。那5000亿斤没价值，是垃圾？生产那
5000亿斤的农民是闲的蛋疼没事干？靠政府失业金养？</p>
<p>2010/3/25 机械唯物主义 : linjunhalida <a href="&#109;&#x61;&#x69;&#108;&#x74;&#111;&#58;&#91;&#x6c;&#x69;&#x6e;&#106;&#117;&#110;&#x2e;&#46;&#x2e;&#64;&#x67;&#109;&#97;&#105;&#x6c;&#x2e;&#99;&#111;&#x6d;&#x5d;&#40;&#x29;">&#91;&#x6c;&#x69;&#x6e;&#106;&#117;&#110;&#x2e;&#46;&#x2e;&#64;&#x67;&#109;&#97;&#105;&#x6c;&#x2e;&#99;&#111;&#x6d;&#x5d;&#40;&#x29;</a>
产能过剩的说法本来就不对。
产出的东西没有价值，这样的活动就不能说是生产。
比如我这个程序员，花了1周写了一个垃圾程序，然后被开除了。
然后1个月闲着，这是我产能过剩吗？
而闲着的原因是政府给我失业金，我就不需要工作闲起来了。。。</p>
<p>2010/3/25 qiaojie <a href="&#109;&#x61;&#x69;&#x6c;&#x74;&#111;&#58;&#x5b;&#x71;&#x69;&#97;&#x2e;&#46;&#46;&#x40;&#103;&#109;&#97;&#105;&#108;&#46;&#x63;&#111;&#109;&#93;&#x28;&#x29;">&#x5b;&#x71;&#x69;&#97;&#x2e;&#46;&#46;&#x40;&#103;&#109;&#97;&#105;&#108;&#46;&#x63;&#111;&#109;&#93;&#x28;&#x29;</a>
如果产能=消费的话就没有产能过剩这一说了。</p>
<p>2010/3/25 机械唯物主义 : linjunhalida <a href="&#x6d;&#97;&#105;&#108;&#116;&#x6f;&#x3a;&#x5b;&#108;&#105;&#x6e;&#106;&#x75;&#x6e;&#46;&#46;&#x2e;&#64;&#103;&#109;&#x61;&#x69;&#108;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#x28;&#41;">&#x5b;&#108;&#105;&#x6e;&#106;&#x75;&#x6e;&#46;&#46;&#x2e;&#64;&#103;&#109;&#x61;&#x69;&#108;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#x28;&#41;</a></p>
<p>一个谬误：刺激需求
产能=消费，产能才是主动力。技术成长是随着产能成长而起来的。
而产能多的结果就是满足了需求，造成一种需求带来技术进步的假像。
而技术和产能之间的关系又错综复杂。。
2010/3/25 qiaojie <a href="&#109;&#97;&#x69;&#x6c;&#116;&#111;&#x3a;&#x5b;&#x71;&#x69;&#97;&#x2e;&#x2e;&#46;&#x40;&#103;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#93;&#x28;&#x29;">&#x5b;&#x71;&#x69;&#97;&#x2e;&#x2e;&#46;&#x40;&#103;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#93;&#x28;&#x29;</a></p>
<p>3D游戏就是一类杀手应用，由此支撑起了一个庞大的GPU市场，芯片行业的研发成本是很高的，没有一个庞大的市场是做不起来的。目前的消费者对于多核系统显然还没有强烈的需求，因为应用跟不上，i7发布快2年了还没进入主流市场，这种情况延续下去的话摩尔定律将因此失效。不过我相信杀手级应用总会出现的，这可能要硬件性能突破一个临界点，比方说目前GPU的性能再提升一个数量级的话，光线跟踪算法就可以提供流畅的接近CG的画质，倒是此类应用便会流行开来。</p>
<p>2010/3/25 Guancheng Chen <a href="&#109;&#x61;&#x69;&#x6c;&#x74;&#x6f;&#x3a;&#x5b;&#99;&#x68;&#x65;&#110;&#103;&#x75;&#46;&#x2e;&#x2e;&#x40;&#x67;&#109;&#x61;&#x69;&#108;&#46;&#x63;&#x6f;&#109;&#93;&#40;&#41;">&#x5b;&#99;&#x68;&#x65;&#110;&#103;&#x75;&#46;&#x2e;&#x2e;&#x40;&#x67;&#109;&#x61;&#x69;&#108;&#46;&#x63;&#x6f;&#109;&#93;&#40;&#41;</a></p>
<p>杀手应用一般来说是指什么样的应用呢？比如用户群特别大的网游？还是那些专有的科学计算用的软件？
On 3月24日, 下午12时36分, qiaojie <a href="&#x6d;&#x61;&#105;&#x6c;&#x74;&#111;&#x3a;&#x5b;&#x71;&#x69;&#x61;&#111;&#46;&#x2e;&#46;&#64;&#x67;&#x6d;&#97;&#x69;&#108;&#46;&#99;&#x6f;&#109;&#93;&#x28;&#x29;">&#x5b;&#x71;&#x69;&#x61;&#111;&#46;&#x2e;&#46;&#64;&#x67;&#x6d;&#97;&#x69;&#108;&#46;&#99;&#x6f;&#109;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>并行计算本来就是曲高和寡的东西，就跟3D渲染一样，能开发引擎的毕竟只是小部分人，大多数人在引擎的基础上做应用。关键在于是否有杀手应用，只要有大量的需求 ，自然会有人去做开发。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#109;&#x61;&#105;&#108;&#x74;&#x6f;&#58;&#91;&#x68;&#x6f;&#x6e;&#x67;&#x7a;&#104;&#x61;&#110;&#x67;&#x2e;&#x2e;&#46;&#x2e;&#64;&#x67;&#109;&#x61;&#105;&#x6c;&#46;&#99;&#x6f;&#109;&#x5d;&#x28;&#x29;">&#91;&#x68;&#x6f;&#x6e;&#x67;&#x7a;&#104;&#x61;&#110;&#x67;&#x2e;&#x2e;&#46;&#x2e;&#64;&#x67;&#109;&#x61;&#105;&#x6c;&#46;&#99;&#x6f;&#109;&#x5d;&#x28;&#x29;</a></p>
<blockquote>
<p>异构平台从网络处理器算起已经快10年了，现在情况仍然不明朗。就我看到的，异构平台要想高效，就必须向程序员暴露非常多的硬件细节，这必然导致编程的复杂性。 曲高和寡，要想渗透到应用程序这一块，我觉得很难。</p>
<p>2010/3/24 qiaojie <a href="&#109;&#97;&#x69;&#x6c;&#116;&#111;&#58;&#91;&#x71;&#x69;&#x61;&#x6f;&#46;&#46;&#x2e;&#x40;&#x67;&#109;&#x61;&#105;&#x6c;&#46;&#99;&#111;&#109;&#93;&#40;&#41;">&#91;&#x71;&#x69;&#x61;&#x6f;&#46;&#46;&#x2e;&#x40;&#x67;&#109;&#x61;&#105;&#x6c;&#46;&#99;&#111;&#109;&#93;&#40;&#41;</a></p>
<blockquote>
<p>说的没错，cell已经成了先烈了。不过这不代表异构的方向不对，CUDA，OpenCL也都是异构平台，以后我们会越来越习惯异构平台的。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#109;&#97;&#105;&#x6c;&#116;&#111;&#58;&#x5b;&#104;&#x6f;&#110;&#103;&#122;&#x68;&#97;&#110;&#103;&#x2e;&#x2e;&#46;&#46;&#x40;&#x67;&#109;&#x61;&#105;&#x6c;&#46;&#x63;&#x6f;&#109;&#x5d;&#x28;&#x29;">&#x5b;&#104;&#x6f;&#110;&#103;&#122;&#x68;&#97;&#110;&#103;&#x2e;&#x2e;&#46;&#46;&#x40;&#x67;&#109;&#x61;&#105;&#x6c;&#46;&#x63;&#x6f;&#109;&#x5d;&#x28;&#x29;</a></p>
<p>异构平台如果编程复杂度降不下来的话很难流行起来。cell已经死了...</p>
<blockquote>
<p> 2010/3/24 qiaojie <a href="&#109;&#97;&#x69;&#108;&#116;&#111;&#58;&#91;&#113;&#x69;&#x61;&#111;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#x61;&#105;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#41;">&#91;&#113;&#x69;&#x61;&#111;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#x61;&#105;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#41;</a></p>
<blockquote>
<p>不是所有的程序都需要并行化的，能用串行化解决的问题没必要并行，所以即使将来many-core系统成为主流，大部分程序员也没必要去搞并行计算。
  我觉得未来的主流应该是类似cell这样一颗全功能核心带众多协处理核心的异构系统，这样才能达到最优的 性能/核心面积比。</p>
<p>2010/3/24 Guancheng Chen <a href="&#x6d;&#x61;&#x69;&#108;&#x74;&#x6f;&#x3a;&#x5b;&#99;&#104;&#101;&#110;&#x67;&#x75;&#97;&#x6e;&#x63;&#104;&#x2e;&#x2e;&#x2e;&#64;&#103;&#109;&#97;&#105;&#x6c;&#x2e;&#99;&#111;&#x6d;&#93;&#40;&#41;">&#x5b;&#99;&#104;&#101;&#110;&#x67;&#x75;&#97;&#x6e;&#x63;&#104;&#x2e;&#x2e;&#x2e;&#64;&#103;&#109;&#97;&#105;&#x6c;&#x2e;&#99;&#111;&#x6d;&#93;&#40;&#41;</a></p>
<p>Nice 大胆预测Linear speedup应该是每个程序员十年后的目标 呵呵</p>
<blockquote>
<p>On 3月23日, 上午10时43分, qiaojie <a href="&#x6d;&#x61;&#105;&#108;&#x74;&#x6f;&#x3a;&#91;&#113;&#105;&#97;&#x6f;&#x2e;&#46;&#x2e;&#64;&#x67;&#109;&#97;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#109;&#x5d;&#x28;&#x29;">&#91;&#113;&#105;&#97;&#x6f;&#x2e;&#46;&#x2e;&#64;&#x67;&#109;&#97;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#109;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>目前正在写的是一个软件渲染器，采用了光栅化和光线跟踪混合算法，渲染算法已经完全并行化了，
在4核系统上基本可以达到线性加速比，更多核的系统暂时还没测试。kd-tree的构造暂时还没有并
行化，以后有空了再研究。</p>
<p>2010/3/23 Guancheng Chen <a href="&#109;&#97;&#105;&#x6c;&#116;&#111;&#58;&#x5b;&#99;&#104;&#x65;&#110;&#x67;&#117;&#x61;&#x6e;&#99;&#x68;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#109;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#x28;&#41;">&#x5b;&#99;&#104;&#x65;&#110;&#x67;&#117;&#x61;&#x6e;&#99;&#x68;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#109;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#x28;&#41;</a></p>
<blockquote>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？</p>
<p>On 3月23日, 上午9时15分, qiaojie <a href="&#x6d;&#x61;&#x69;&#x6c;&#116;&#x6f;&#x3a;&#x5b;&#x71;&#105;&#97;&#111;&#46;&#x2e;&#46;&#x40;&#103;&#x6d;&#97;&#105;&#108;&#46;&#x63;&#x6f;&#109;&#93;&#x28;&#41;">&#x5b;&#x71;&#105;&#97;&#111;&#46;&#x2e;&#46;&#x40;&#103;&#x6d;&#97;&#105;&#108;&#46;&#x63;&#x6f;&#109;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1)
=
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank
Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？</p>
</blockquote>
<p> To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> tinyfool <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-25</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>哈哈，二位都平和一点，咱们继续回到技术讨论的主线吧</p>
<p>在 2010-3-25，下午2:40， qiaojie 写道：</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>恩，很快会被升华成为政治问题
2010/3/25 郝培强 tinyfool <a href="&#109;&#x61;&#105;&#108;&#x74;&#x6f;&#58;&#x5b;&#x74;&#105;&#x6e;&#121;&#x2e;&#46;&#x2e;&#x40;&#103;&#x6d;&#97;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#41;">&#x5b;&#x74;&#105;&#x6e;&#121;&#x2e;&#46;&#x2e;&#x40;&#103;&#x6d;&#97;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#41;</a>
哈哈，终于从技术聊到经济了</p>
<p>在 2010-3-25，下午2:11， qiaojie 写道：</p>
<p>什么叫产能过剩？假设全世界每年消费10000亿斤粮食，结果今年收成好，生产了15000亿斤，</p>
<p>那多出来的5000亿斤无法被市场消化掉，就是产能过剩。那5000亿斤没价值，是垃圾？生产那
5000亿斤的农民是闲的蛋疼没事干？靠政府失业金养？</p>
<p>2010/3/25 机械唯物主义 : linjunhalida <a href="&#x6d;&#97;&#x69;&#x6c;&#x74;&#x6f;&#58;&#91;&#x6c;&#105;&#110;&#x6a;&#117;&#110;&#x2e;&#46;&#x2e;&#x40;&#103;&#x6d;&#97;&#x69;&#x6c;&#46;&#99;&#x6f;&#109;&#93;&#40;&#41;">&#91;&#x6c;&#105;&#110;&#x6a;&#117;&#110;&#x2e;&#46;&#x2e;&#x40;&#103;&#x6d;&#97;&#x69;&#x6c;&#46;&#99;&#x6f;&#109;&#93;&#40;&#41;</a>
产能过剩的说法本来就不对。
产出的东西没有价值，这样的活动就不能说是生产。
比如我这个程序员，花了1周写了一个垃圾程序，然后被开除了。
然后1个月闲着，这是我产能过剩吗？
而闲着的原因是政府给我失业金，我就不需要工作闲起来了。。。</p>
<p>2010/3/25 qiaojie <a href="&#x6d;&#x61;&#105;&#x6c;&#116;&#111;&#58;&#x5b;&#113;&#x69;&#97;&#46;&#46;&#x2e;&#64;&#x67;&#109;&#97;&#105;&#108;&#46;&#x63;&#111;&#x6d;&#x5d;&#x28;&#41;">&#x5b;&#113;&#x69;&#97;&#46;&#46;&#x2e;&#64;&#x67;&#109;&#97;&#105;&#108;&#46;&#x63;&#111;&#x6d;&#x5d;&#x28;&#41;</a>
如果产能=消费的话就没有产能过剩这一说了。</p>
<p>2010/3/25 机械唯物主义 : linjunhalida <a href="&#x6d;&#x61;&#x69;&#108;&#x74;&#111;&#x3a;&#x5b;&#108;&#105;&#x6e;&#x6a;&#x75;&#x6e;&#x2e;&#x2e;&#46;&#x40;&#x67;&#x6d;&#x61;&#x69;&#108;&#46;&#99;&#111;&#109;&#93;&#x28;&#x29;">&#x5b;&#108;&#105;&#x6e;&#x6a;&#x75;&#x6e;&#x2e;&#x2e;&#46;&#x40;&#x67;&#x6d;&#x61;&#x69;&#108;&#46;&#99;&#111;&#109;&#93;&#x28;&#x29;</a></p>
<p>一个谬误：刺激需求
产能=消费，产能才是主动力。技术成长是随着产能成长而起来的。
而产能多的结果就是满足了需求，造成一种需求带来技术进步的假像。
而技术和产能之间的关系又错综复杂。。
2010/3/25 qiaojie <a href="&#x6d;&#x61;&#105;&#108;&#x74;&#111;&#x3a;&#x5b;&#113;&#x69;&#97;&#46;&#x2e;&#x2e;&#x40;&#x67;&#109;&#x61;&#x69;&#x6c;&#x2e;&#99;&#111;&#x6d;&#x5d;&#40;&#41;">&#x5b;&#113;&#x69;&#97;&#46;&#x2e;&#x2e;&#x40;&#x67;&#109;&#x61;&#x69;&#x6c;&#x2e;&#99;&#111;&#x6d;&#x5d;&#40;&#41;</a></p>
<p>3D游戏就是一类杀手应用，由此支撑起了一个庞大的GPU市场，芯片行业的研发成本是很高的，没有一个庞大的市场是做不起来的。目前的消费者对于多核系统显然还没有强烈的需求，因为应用跟不上，i7发布快2年了还没进入主流市场，这种情况延续下去的话摩尔定律将因此失效。不过我相信杀手级应用总会出现的，这可能要硬件性能突破一个临界点，比方说目前GPU的性能再提升一个数量级的话，光线跟踪算法就可以提供流畅的接近CG的画质，倒是此类应用便会流行开来。</p>
<p>2010/3/25 Guancheng Chen <a href="&#109;&#97;&#105;&#x6c;&#116;&#x6f;&#x3a;&#91;&#x63;&#x68;&#x65;&#x6e;&#x67;&#117;&#46;&#x2e;&#46;&#64;&#x67;&#109;&#97;&#x69;&#x6c;&#46;&#99;&#111;&#109;&#x5d;&#x28;&#41;">&#91;&#x63;&#x68;&#x65;&#x6e;&#x67;&#117;&#46;&#x2e;&#46;&#64;&#x67;&#109;&#97;&#x69;&#x6c;&#46;&#99;&#111;&#109;&#x5d;&#x28;&#41;</a></p>
<p>杀手应用一般来说是指什么样的应用呢？比如用户群特别大的网游？还是那些专有的科学计算用的软件？
On 3月24日, 下午12时36分, qiaojie <a href="&#x6d;&#x61;&#105;&#108;&#x74;&#x6f;&#x3a;&#x5b;&#x71;&#x69;&#97;&#111;&#46;&#46;&#46;&#64;&#x67;&#x6d;&#97;&#x69;&#108;&#x2e;&#99;&#111;&#109;&#x5d;&#x28;&#x29;">&#x5b;&#x71;&#x69;&#97;&#111;&#46;&#46;&#46;&#64;&#x67;&#x6d;&#97;&#x69;&#108;&#x2e;&#99;&#111;&#109;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>并行计算本来就是曲高和寡的东西，就跟3D渲染一样，能开发引擎的毕竟只是小部分人，大多数人在引擎的基础上做应用。关键在于是否有杀手应用，只要有大量的需求 ，自然会有人去做开发。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#109;&#x61;&#x69;&#x6c;&#116;&#x6f;&#x3a;&#91;&#x68;&#111;&#x6e;&#x67;&#x7a;&#104;&#x61;&#x6e;&#103;&#46;&#x2e;&#46;&#46;&#x40;&#x67;&#109;&#x61;&#105;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#93;&#40;&#41;">&#91;&#x68;&#111;&#x6e;&#x67;&#x7a;&#104;&#x61;&#x6e;&#103;&#46;&#x2e;&#46;&#46;&#x40;&#x67;&#109;&#x61;&#105;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#93;&#40;&#41;</a></p>
<blockquote>
<p>异构平台从网络处理器算起已经快10年了，现在情况仍然不明朗。就我看到的，异构平台要想高效，就必须向程序员暴露非常多的硬件细节，这必然导致编程的复杂性。 曲高和寡，要想渗透到应用程序这一块，我觉得很难。</p>
<p>2010/3/24 qiaojie <a href="&#109;&#x61;&#x69;&#108;&#116;&#111;&#58;&#91;&#113;&#x69;&#x61;&#x6f;&#46;&#46;&#x2e;&#x40;&#103;&#109;&#x61;&#x69;&#x6c;&#x2e;&#99;&#111;&#109;&#x5d;&#x28;&#41;">&#91;&#113;&#x69;&#x61;&#x6f;&#46;&#46;&#x2e;&#x40;&#103;&#109;&#x61;&#x69;&#x6c;&#x2e;&#99;&#111;&#109;&#x5d;&#x28;&#41;</a></p>
<blockquote>
<p>说的没错，cell已经成了先烈了。不过这不代表异构的方向不对，CUDA，OpenCL也都是异构平台，以后我们会越来越习惯异构平台的。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#x6d;&#97;&#x69;&#108;&#x74;&#x6f;&#58;&#91;&#x68;&#x6f;&#x6e;&#x67;&#122;&#x68;&#97;&#x6e;&#103;&#x2e;&#46;&#x2e;&#46;&#64;&#103;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#111;&#109;&#x5d;&#x28;&#41;">&#91;&#x68;&#x6f;&#x6e;&#x67;&#122;&#x68;&#97;&#x6e;&#103;&#x2e;&#46;&#x2e;&#46;&#64;&#103;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#111;&#109;&#x5d;&#x28;&#41;</a></p>
<p>异构平台如果编程复杂度降不下来的话很难流行起来。cell已经死了...</p>
<blockquote>
<p> 2010/3/24 qiaojie <a href="&#x6d;&#97;&#x69;&#108;&#116;&#x6f;&#58;&#91;&#113;&#x69;&#97;&#111;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#109;&#97;&#x69;&#x6c;&#x2e;&#99;&#111;&#109;&#x5d;&#40;&#41;">&#91;&#113;&#x69;&#97;&#111;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#109;&#97;&#x69;&#x6c;&#x2e;&#99;&#111;&#109;&#x5d;&#40;&#41;</a></p>
<blockquote>
<p>不是所有的程序都需要并行化的，能用串行化解决的问题没必要并行，所以即使将来many-core系统成为主流，大部分程序员也没必要去搞并行计算。
  我觉得未来的主流应该是类似cell这样一颗全功能核心带众多协处理核心的异构系统，这样才能达到最优的 性能/核心面积比。</p>
<p>2010/3/24 Guancheng Chen <a href="&#109;&#x61;&#x69;&#108;&#116;&#111;&#58;&#91;&#99;&#104;&#x65;&#x6e;&#103;&#117;&#x61;&#x6e;&#99;&#104;&#x2e;&#46;&#x2e;&#64;&#x67;&#109;&#x61;&#105;&#x6c;&#46;&#99;&#x6f;&#109;&#93;&#40;&#41;">&#91;&#99;&#104;&#x65;&#x6e;&#103;&#117;&#x61;&#x6e;&#99;&#104;&#x2e;&#46;&#x2e;&#64;&#x67;&#109;&#x61;&#105;&#x6c;&#46;&#99;&#x6f;&#109;&#93;&#40;&#41;</a></p>
<p>Nice 大胆预测Linear speedup应该是每个程序员十年后的目标 呵呵</p>
<blockquote>
<p>On 3月23日, 上午10时43分, qiaojie <a href="&#x6d;&#97;&#105;&#108;&#116;&#x6f;&#58;&#91;&#113;&#105;&#x61;&#111;&#46;&#x2e;&#x2e;&#64;&#103;&#109;&#97;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#109;&#x5d;&#x28;&#x29;">&#91;&#113;&#105;&#x61;&#111;&#46;&#x2e;&#x2e;&#64;&#103;&#109;&#97;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#109;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>目前正在写的是一个软件渲染器，采用了光栅化和光线跟踪混合算法，渲染算法已经完全并行化了，
在4核系统上基本可以达到线性加速比，更多核的系统暂时还没测试。kd-tree的构造暂时还没有并
行化，以后有空了再研究。</p>
<p>2010/3/23 Guancheng Chen <a href="&#109;&#97;&#105;&#x6c;&#x74;&#x6f;&#58;&#x5b;&#x63;&#104;&#x65;&#x6e;&#103;&#117;&#97;&#x6e;&#99;&#104;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#99;&#111;&#x6d;&#x5d;&#40;&#x29;">&#x5b;&#x63;&#104;&#x65;&#x6e;&#103;&#117;&#97;&#x6e;&#99;&#104;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#99;&#111;&#x6d;&#x5d;&#40;&#x29;</a></p>
<blockquote>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？</p>
<p>On 3月23日, 上午9时15分, qiaojie <a href="&#x6d;&#97;&#x69;&#108;&#x74;&#x6f;&#58;&#x5b;&#113;&#x69;&#97;&#111;&#x2e;&#x2e;&#46;&#64;&#103;&#x6d;&#x61;&#105;&#108;&#46;&#99;&#111;&#x6d;&#93;&#40;&#x29;">&#x5b;&#113;&#x69;&#97;&#111;&#x2e;&#x2e;&#46;&#64;&#103;&#x6d;&#x61;&#105;&#108;&#46;&#99;&#111;&#x6d;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1)
=
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank
Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？</p>
</blockquote>
<p> To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a></p>
<p><img src="" alt=""> 机械唯物主义 : linjunhalida <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-25</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>恩，离题远了。不再讨论经济。</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>2010/3/25 郝培强 tinyfool <a href="&#x6d;&#x61;&#x69;&#108;&#116;&#x6f;&#x3a;&#91;&#116;&#105;&#x6e;&#121;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#x61;&#105;&#x6c;&#46;&#x63;&#x6f;&#109;&#x5d;&#x28;&#41;">&#91;&#116;&#105;&#x6e;&#121;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#x61;&#105;&#x6c;&#46;&#x63;&#x6f;&#109;&#x5d;&#x28;&#41;</a>
哈哈，二位都平和一点，咱们继续回到技术讨论的主线吧</p>
<p>在 2010-3-25，下午2:40， qiaojie 写道：</p>
<p>恩，很快会被升华成为政治问题
2010/3/25 郝培强 tinyfool <a href="&#109;&#97;&#x69;&#108;&#116;&#111;&#58;&#x5b;&#116;&#x69;&#110;&#121;&#46;&#46;&#46;&#x40;&#103;&#x6d;&#97;&#105;&#x6c;&#46;&#x63;&#111;&#109;&#x5d;&#40;&#x29;">&#x5b;&#116;&#x69;&#110;&#121;&#46;&#46;&#46;&#x40;&#103;&#x6d;&#97;&#105;&#x6c;&#46;&#x63;&#111;&#109;&#x5d;&#40;&#x29;</a>
哈哈，终于从技术聊到经济了</p>
<p>在 2010-3-25，下午2:11， qiaojie 写道：</p>
<p>什么叫产能过剩？假设全世界每年消费10000亿斤粮食，结果今年收成好，生产了15000亿斤，</p>
<p>那多出来的5000亿斤无法被市场消化掉，就是产能过剩。那5000亿斤没价值，是垃圾？生产那
5000亿斤的农民是闲的蛋疼没事干？靠政府失业金养？</p>
<p>2010/3/25 机械唯物主义 : linjunhalida <a href="&#x6d;&#x61;&#105;&#x6c;&#x74;&#111;&#58;&#x5b;&#108;&#105;&#110;&#106;&#117;&#110;&#46;&#x2e;&#46;&#x40;&#103;&#x6d;&#97;&#x69;&#x6c;&#46;&#x63;&#111;&#x6d;&#x5d;&#x28;&#x29;">&#x5b;&#108;&#105;&#110;&#106;&#117;&#110;&#46;&#x2e;&#46;&#x40;&#103;&#x6d;&#97;&#x69;&#x6c;&#46;&#x63;&#111;&#x6d;&#x5d;&#x28;&#x29;</a>
产能过剩的说法本来就不对。
产出的东西没有价值，这样的活动就不能说是生产。
比如我这个程序员，花了1周写了一个垃圾程序，然后被开除了。
然后1个月闲着，这是我产能过剩吗？
而闲着的原因是政府给我失业金，我就不需要工作闲起来了。。。</p>
<p>2010/3/25 qiaojie <a href="&#x6d;&#97;&#x69;&#x6c;&#x74;&#x6f;&#58;&#91;&#113;&#105;&#97;&#x2e;&#x2e;&#46;&#x40;&#x67;&#109;&#97;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#41;">&#91;&#113;&#105;&#97;&#x2e;&#x2e;&#46;&#x40;&#x67;&#109;&#97;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#41;</a>
如果产能=消费的话就没有产能过剩这一说了。</p>
<p>2010/3/25 机械唯物主义 : linjunhalida <a href="&#x6d;&#97;&#105;&#x6c;&#116;&#x6f;&#x3a;&#x5b;&#108;&#x69;&#x6e;&#106;&#117;&#110;&#46;&#x2e;&#x2e;&#64;&#103;&#x6d;&#x61;&#105;&#108;&#46;&#x63;&#111;&#x6d;&#93;&#x28;&#41;">&#x5b;&#108;&#x69;&#x6e;&#106;&#117;&#110;&#46;&#x2e;&#x2e;&#64;&#103;&#x6d;&#x61;&#105;&#108;&#46;&#x63;&#111;&#x6d;&#93;&#x28;&#41;</a></p>
<p>一个谬误：刺激需求
产能=消费，产能才是主动力。技术成长是随着产能成长而起来的。
而产能多的结果就是满足了需求，造成一种需求带来技术进步的假像。
而技术和产能之间的关系又错综复杂。。
2010/3/25 qiaojie <a href="&#109;&#97;&#105;&#x6c;&#116;&#111;&#x3a;&#91;&#x71;&#x69;&#97;&#46;&#46;&#46;&#x40;&#103;&#x6d;&#x61;&#105;&#108;&#46;&#99;&#111;&#x6d;&#x5d;&#x28;&#41;">&#91;&#x71;&#x69;&#97;&#46;&#46;&#46;&#x40;&#103;&#x6d;&#x61;&#105;&#108;&#46;&#99;&#111;&#x6d;&#x5d;&#x28;&#41;</a></p>
<p>3D游戏就是一类杀手应用，由此支撑起了一个庞大的GPU市场，芯片行业的研发成本是很高的，没有一个庞大的市场是做不起来的。目前的消费者对于多核系统显然还没有强烈的需求，因为应用跟不上，i7发布快2年了还没进入主流市场，这种情况延续下去的话摩尔定律将因此失效。不过我相信杀手级应用总会出现的，这可能要硬件性能突破一个临界点，比方说目前GPU的性能再提升一个数量级的话，光线跟踪算法就可以提供流畅的接近CG的画质，倒是此类应用便会流行开来。</p>
<p>2010/3/25 Guancheng Chen <a href="&#109;&#97;&#105;&#x6c;&#116;&#x6f;&#x3a;&#91;&#x63;&#104;&#101;&#x6e;&#103;&#x75;&#x2e;&#46;&#x2e;&#x40;&#103;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#99;&#111;&#109;&#93;&#40;&#x29;">&#91;&#x63;&#104;&#101;&#x6e;&#103;&#x75;&#x2e;&#46;&#x2e;&#x40;&#103;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#99;&#111;&#109;&#93;&#40;&#x29;</a></p>
<p>杀手应用一般来说是指什么样的应用呢？比如用户群特别大的网游？还是那些专有的科学计算用的软件？
On 3月24日, 下午12时36分, qiaojie <a href="&#x6d;&#97;&#105;&#x6c;&#x74;&#111;&#58;&#x5b;&#113;&#x69;&#x61;&#111;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#109;&#97;&#x69;&#108;&#x2e;&#99;&#111;&#x6d;&#x5d;&#x28;&#41;">&#x5b;&#113;&#x69;&#x61;&#111;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#109;&#97;&#x69;&#108;&#x2e;&#99;&#111;&#x6d;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>并行计算本来就是曲高和寡的东西，就跟3D渲染一样，能开发引擎的毕竟只是小部分人，大多数人在引擎的基础上做应用。关键在于是否有杀手应用，只要有大量的需求 ，自然会有人去做开发。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#x6d;&#97;&#x69;&#108;&#116;&#x6f;&#x3a;&#91;&#x68;&#x6f;&#x6e;&#x67;&#x7a;&#x68;&#97;&#x6e;&#x67;&#x2e;&#x2e;&#x2e;&#46;&#x40;&#x67;&#109;&#97;&#x69;&#x6c;&#46;&#99;&#x6f;&#x6d;&#93;&#40;&#41;">&#91;&#x68;&#x6f;&#x6e;&#x67;&#x7a;&#x68;&#97;&#x6e;&#x67;&#x2e;&#x2e;&#x2e;&#46;&#x40;&#x67;&#109;&#97;&#x69;&#x6c;&#46;&#99;&#x6f;&#x6d;&#93;&#40;&#41;</a></p>
<blockquote>
<p>异构平台从网络处理器算起已经快10年了，现在情况仍然不明朗。就我看到的，异构平台要想高效，就必须向程序员暴露非常多的硬件细节，这必然导致编程的复杂性。 曲高和寡，要想渗透到应用程序这一块，我觉得很难。</p>
<p>2010/3/24 qiaojie <a href="&#x6d;&#97;&#x69;&#108;&#116;&#x6f;&#58;&#91;&#113;&#x69;&#x61;&#111;&#46;&#46;&#46;&#x40;&#103;&#109;&#97;&#x69;&#108;&#46;&#x63;&#111;&#109;&#93;&#x28;&#41;">&#91;&#113;&#x69;&#x61;&#111;&#46;&#46;&#46;&#x40;&#103;&#109;&#97;&#x69;&#108;&#46;&#x63;&#111;&#109;&#93;&#x28;&#41;</a></p>
<blockquote>
<p>说的没错，cell已经成了先烈了。不过这不代表异构的方向不对，CUDA，OpenCL也都是异构平台，以后我们会越来越习惯异构平台的。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#109;&#x61;&#105;&#108;&#116;&#x6f;&#x3a;&#x5b;&#x68;&#111;&#110;&#x67;&#x7a;&#x68;&#97;&#x6e;&#x67;&#x2e;&#x2e;&#x2e;&#46;&#x40;&#103;&#x6d;&#97;&#105;&#108;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#41;">&#x5b;&#x68;&#111;&#110;&#x67;&#x7a;&#x68;&#97;&#x6e;&#x67;&#x2e;&#x2e;&#x2e;&#46;&#x40;&#103;&#x6d;&#97;&#105;&#108;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#41;</a></p>
<p>异构平台如果编程复杂度降不下来的话很难流行起来。cell已经死了...</p>
<blockquote>
<p> 2010/3/24 qiaojie <a href="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#111;&#x3a;&#91;&#x71;&#105;&#97;&#111;&#46;&#46;&#x2e;&#64;&#x67;&#109;&#x61;&#105;&#108;&#x2e;&#99;&#x6f;&#x6d;&#93;&#40;&#41;">&#91;&#x71;&#105;&#97;&#111;&#46;&#46;&#x2e;&#64;&#x67;&#109;&#x61;&#105;&#108;&#x2e;&#99;&#x6f;&#x6d;&#93;&#40;&#41;</a></p>
<blockquote>
<p>不是所有的程序都需要并行化的，能用串行化解决的问题没必要并行，所以即使将来many-core系统成为主流，大部分程序员也没必要去搞并行计算。
  我觉得未来的主流应该是类似cell这样一颗全功能核心带众多协处理核心的异构系统，这样才能达到最优的 性能/核心面积比。</p>
<p>2010/3/24 Guancheng Chen <a href="&#109;&#x61;&#x69;&#108;&#x74;&#111;&#58;&#x5b;&#99;&#x68;&#101;&#x6e;&#x67;&#117;&#97;&#x6e;&#99;&#x68;&#46;&#46;&#46;&#64;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#46;&#99;&#111;&#109;&#x5d;&#x28;&#41;">&#x5b;&#99;&#x68;&#101;&#x6e;&#x67;&#117;&#97;&#x6e;&#99;&#x68;&#46;&#46;&#46;&#64;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#46;&#99;&#111;&#109;&#x5d;&#x28;&#41;</a></p>
<p>Nice 大胆预测Linear speedup应该是每个程序员十年后的目标 呵呵</p>
<blockquote>
<p>On 3月23日, 上午10时43分, qiaojie <a href="&#109;&#97;&#x69;&#108;&#x74;&#x6f;&#58;&#x5b;&#113;&#105;&#x61;&#111;&#46;&#46;&#46;&#x40;&#103;&#x6d;&#97;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#40;&#41;">&#x5b;&#113;&#105;&#x61;&#111;&#46;&#46;&#46;&#x40;&#103;&#x6d;&#97;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>目前正在写的是一个软件渲染器，采用了光栅化和光线跟踪混合算法，渲染算法已经完全并行化了，
在4核系统上基本可以达到线性加速比，更多核的系统暂时还没测试。kd-tree的构造暂时还没有并
行化，以后有空了再研究。</p>
<p>2010/3/23 Guancheng Chen <a href="&#109;&#x61;&#x69;&#108;&#x74;&#x6f;&#58;&#x5b;&#x63;&#104;&#101;&#110;&#103;&#117;&#x61;&#x6e;&#99;&#x68;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#109;&#x61;&#105;&#x6c;&#x2e;&#99;&#111;&#x6d;&#93;&#40;&#41;">&#x5b;&#x63;&#104;&#101;&#110;&#103;&#117;&#x61;&#x6e;&#99;&#x68;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#109;&#x61;&#105;&#x6c;&#x2e;&#99;&#111;&#x6d;&#93;&#40;&#41;</a></p>
<blockquote>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？</p>
<p>On 3月23日, 上午9时15分, qiaojie <a href="&#109;&#97;&#105;&#108;&#x74;&#x6f;&#x3a;&#x5b;&#x71;&#x69;&#x61;&#x6f;&#x2e;&#x2e;&#46;&#x40;&#103;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#93;&#40;&#x29;">&#x5b;&#x71;&#x69;&#x61;&#x6f;&#x2e;&#x2e;&#46;&#x40;&#103;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1)
=
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank
Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？</p>
</blockquote>
<p> To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> 居振梁 <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-25</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>哈哈，估计有人想说“这次居然是收敛的”</p>
<p>2010/3/25 机械唯物主义 : linjunhalida <a href="&#x6d;&#x61;&#105;&#108;&#x74;&#x6f;&#x3a;&#91;&#108;&#x69;&#110;&#x6a;&#x75;&#x6e;&#x2e;&#x2e;&#46;&#x40;&#103;&#109;&#x61;&#105;&#x6c;&#46;&#x63;&#111;&#109;&#93;&#40;&#x29;">&#91;&#108;&#x69;&#110;&#x6a;&#x75;&#x6e;&#x2e;&#x2e;&#46;&#x40;&#103;&#109;&#x61;&#105;&#x6c;&#46;&#x63;&#111;&#109;&#93;&#40;&#x29;</a></p>
<h2 id="-">恩，离题远了。不再讨论经济。</h2>
<p>御剑乘风来，除魔天地间。有酒乐逍遥，无酒我亦颠。
<a href="http://www.xspirithack.org/" target="_blank"><a href="http://www.xspirithack.org">http://www.xspirithack.org</a></a>
一饮尽江河，再饮吞日月。千杯醉不倒，唯我酒剑仙。
<a href="">显示删减掉的内容</a></p>
<p><img src="" alt=""> qiaojie <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-25</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>淡定....
2010/3/25 居振梁 <a href="&#109;&#97;&#105;&#108;&#x74;&#x6f;&#58;&#91;&#106;&#117;&#x7a;&#x68;&#x65;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#97;&#x69;&#108;&#x2e;&#99;&#111;&#x6d;&#x5d;&#x28;&#x29;">&#91;&#106;&#117;&#x7a;&#x68;&#x65;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#97;&#x69;&#108;&#x2e;&#99;&#111;&#x6d;&#x5d;&#x28;&#x29;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>哈哈，估计有人想说“这次居然是收敛的”</p>
<p>2010/3/25 机械唯物主义 : linjunhalida <a href="&#109;&#97;&#105;&#x6c;&#116;&#x6f;&#58;&#91;&#x6c;&#105;&#x6e;&#106;&#x75;&#x6e;&#46;&#46;&#x2e;&#x40;&#103;&#109;&#97;&#105;&#x6c;&#x2e;&#99;&#111;&#x6d;&#x5d;&#x28;&#x29;">&#91;&#x6c;&#105;&#x6e;&#106;&#x75;&#x6e;&#46;&#46;&#x2e;&#x40;&#103;&#109;&#97;&#105;&#x6c;&#x2e;&#99;&#111;&#x6d;&#x5d;&#x28;&#x29;</a></p>
<h2 id="-"> 恩，离题远了。不再讨论经济。</h2>
<p>御剑乘风来，除魔天地间。有酒乐逍遥，无酒我亦颠。
<a href="http://www.xspirithack.org/" target="_blank"><a href="http://www.xspirithack.org">http://www.xspirithack.org</a></a>
一饮尽江河，再饮吞日月。千杯醉不倒，唯我酒剑仙。</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> tinyfool <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-25</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>呵呵，其实咱们组真的已经是互联网上讨论组里面，最平和，最专业的一个了。</p>
<p>大家有时候稍微相互包容点，就不至于弄得大家都不愉快的，我们还是挺好的。
不准老幸灾乐祸，惟恐天下不乱的，哈哈</p>
<p>技术讨论技术吧
我继续鼓吹OPENCL，哈哈</p>
<p>在 2010-3-25，下午2:44， 居振梁 写道：</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>哈哈，估计有人想说“这次居然是收敛的”</p>
<p>2010/3/25 机械唯物主义 : linjunhalida <a href="&#109;&#x61;&#105;&#x6c;&#116;&#x6f;&#x3a;&#x5b;&#108;&#105;&#110;&#106;&#x75;&#x6e;&#46;&#46;&#46;&#64;&#x67;&#109;&#x61;&#105;&#108;&#46;&#x63;&#x6f;&#x6d;&#93;&#x28;&#x29;">&#x5b;&#108;&#105;&#110;&#106;&#x75;&#x6e;&#46;&#46;&#46;&#64;&#x67;&#109;&#x61;&#105;&#108;&#46;&#x63;&#x6f;&#x6d;&#93;&#x28;&#x29;</a></p>
<h2 id="-">恩，离题远了。不再讨论经济。</h2>
<p>御剑乘风来，除魔天地间。有酒乐逍遥，无酒我亦颠。
<a href="http://www.xspirithack.org/" target="_blank"><a href="http://www.xspirithack.org">http://www.xspirithack.org</a></a>
一饮尽江河，再饮吞日月。千杯醉不倒，唯我酒剑仙。</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a></p>
<p><img src="" alt=""> fxc...@gmail.com <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-26</p>
<p>其他收件人：</p>
<p>好吧，俺也打个广告。
既然大家都说tools是concurrent的一个大issue。那不妨看看MS的Concurrency工具包：Parallel
Debugger/Parallel Profiler. 在下一个版本VS里面会加入Static Analysis的support。
<a href="http://msdn.microsoft.com/en-us/concurrency/default.aspx" target="_blank">msdn.microsoft.com/en-us/concurrency/default.aspx</a></p>
<p>On Mar 24, 9:04 am, 莫华枫 <a href="&#x6d;&#x61;&#x69;&#108;&#116;&#111;&#58;&#91;&#108;&#x6f;&#110;&#x67;&#x73;&#104;&#x61;&#x6e;&#107;&#46;&#46;&#46;&#64;&#103;&#109;&#x61;&#105;&#108;&#x2e;&#x63;&#x6f;&#109;&#93;&#40;&#41;">&#91;&#108;&#x6f;&#110;&#x67;&#x73;&#104;&#x61;&#x6e;&#107;&#46;&#46;&#46;&#64;&#103;&#109;&#x61;&#105;&#108;&#x2e;&#x63;&#x6f;&#109;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>凑个热闹，也来个广告：CERL 2.0初具雏形。</p>
<p>--
反者道之动，弱者道之用
longshank...@gmail.com<a href="http://[blog.csdn.net/longshanks/](http://blog.csdn.net/longshanks/" target="_blank">http://[blog.csdn.net/longshanks/](http://blog.csdn.net/longshanks/</a>)
wave开通
<a href="">显示删减掉的内容</a>
<img src="" alt=""> AWu <img src="" alt=""></p>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-28</p>
<p>其他收件人：</p>
<p>这不是逼俺买MBP嘛？</p>
<p>感觉并行需要有足够简单，足够可靠的工程实施方法才能够大规模得被应用～
毕竟IT业从业人员不是所有人都足够聪明能够写得了、分析得了并行</p>
<p>一个可靠的工程方法来规避并行可能引发的性能或者功能缺陷，如果能够抽象到库里面规避当然更好，但是库这个东西得有足够多的工程实践才能做得出来吧，所
以我认为第一步是有一个可行的并行工程实施方法。</p>
<p>On 3月22日, 下午2时06分, Guancheng Chen <a href="&#x6d;&#97;&#x69;&#108;&#116;&#x6f;&#58;&#x5b;&#99;&#x68;&#101;&#x6e;&#103;&#x75;&#97;&#110;&#x63;&#104;&#46;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#x61;&#105;&#108;&#46;&#x63;&#111;&#x6d;&#x5d;&#x28;&#x29;">&#x5b;&#99;&#x68;&#101;&#x6e;&#103;&#x75;&#97;&#110;&#x63;&#104;&#46;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#x61;&#105;&#108;&#46;&#x63;&#111;&#x6d;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>On 3月22日, 上午2时20分, Tinyfool <a href="&#109;&#x61;&#105;&#x6c;&#x74;&#111;&#58;&#91;&#116;&#105;&#110;&#x79;&#x66;&#46;&#46;&#x2e;&#64;&#103;&#x6d;&#x61;&#105;&#108;&#46;&#x63;&#111;&#109;&#93;&#40;&#41;">&#91;&#116;&#105;&#110;&#x79;&#x66;&#46;&#46;&#x2e;&#64;&#103;&#x6d;&#x61;&#105;&#108;&#46;&#x63;&#111;&#109;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#109;&#x61;&#105;&#x6c;&#116;&#x6f;&#x3a;&#91;&#x6a;&#x65;&#46;&#x2e;&#x2e;&#x40;&#108;&#x69;&#x76;&#101;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#40;&#41;">&#91;&#x6a;&#x65;&#46;&#x2e;&#x2e;&#x40;&#108;&#x69;&#x76;&#101;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#40;&#41;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#x6d;&#x61;&#105;&#108;&#x74;&#111;&#x3a;&#x5b;&#99;&#104;&#101;&#110;&#103;&#x75;&#97;&#110;&#99;&#104;&#x2e;&#x2e;&#46;&#64;&#103;&#x6d;&#x61;&#105;&#108;&#46;&#x63;&#111;&#x6d;&#93;&#40;&#41;">&#x5b;&#99;&#104;&#101;&#110;&#103;&#x75;&#97;&#110;&#99;&#104;&#x2e;&#x2e;&#46;&#64;&#103;&#x6d;&#x61;&#105;&#108;&#46;&#x63;&#111;&#x6d;&#93;&#40;&#41;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#109;&#x61;&#105;&#x6c;&#x74;&#x6f;&#58;&#x5b;&#112;&#x6f;&#110;&#x2e;&#46;&#46;&#64;&#103;&#x6f;&#111;&#103;&#x6c;&#101;&#x67;&#x72;&#111;&#117;&#x70;&#115;&#x2e;&#99;&#111;&#109;&#93;&#40;&#x29;">&#x5b;&#112;&#x6f;&#110;&#x2e;&#46;&#46;&#64;&#103;&#x6f;&#111;&#103;&#x6c;&#101;&#x67;&#x72;&#111;&#117;&#x70;&#115;&#x2e;&#99;&#111;&#109;&#93;&#40;&#x29;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。</p>
</li>
</ol>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>--
Tinyfool的开发日记<a href="http://www.tinydust.net/dev/" target="_blank"><a href="http://www.tinydust.net/dev/">http://www.tinydust.net/dev/</a></a>
代码中国网<a href="http://www.codechina.org/" target="_blank"><a href="http://www.codechina.org">http://www.codechina.org</a></a>
myTwitter:<a href="http://twitter.com/tinyfool" target="_blank"><a href="http://twitter.com/tinyfool">http://twitter.com/tinyfool</a></a>
<a href="">显示删减掉的内容</a>
上一页 <a href="">上一页</a>  </p>
</blockquote>
</blockquote>
<p>第 <strong>1</strong> 页
  下一页 <a href="">下一页</a></p>
]]></content>
    
    
      <category term="好文摘录" scheme="http://itsolife.com/categories/%E5%A5%BD%E6%96%87%E6%91%98%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[学习与记忆]]></title>
    <link href="http://itsolife.com/2014/02/03/2014-02-03--%E5%AD%A6%E4%B9%A0%E4%B8%8E%E8%AE%B0%E5%BF%86/"/>
    <id>http://itsolife.com/2014/02/03/2014-02-03--学习与记忆/</id>
    <published>2014-02-03T03:24:29.000Z</published>
    <updated>2014-03-07T03:24:29.000Z</updated>
    <content type="html"><![CDATA[<h1 id="-">学习与记忆</h1>
<p><a href="http://blog.csdn.net/tag/details.html?tag=%e7%ae%97%e6%b3%95" target="_blank">算法</a><a href="http://blog.csdn.net/tag/details.html?tag=%e6%b4%bb%e5%8a%a8" target="_blank">活动</a><a href="http://blog.csdn.net/tag/details.html?tag=%e7%bd%91%e7%bb%9c" target="_blank">网络</a><a href="http://blog.csdn.net/tag/details.html?tag=%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84" target="_blank">数据结构</a><a href="http://blog.csdn.net/tag/details.html?tag=%e5%b7%a5%e4%bd%9c" target="_blank">工作</a><a href="http://blog.csdn.net/tag/details.html?tag=google" target="_blank">google</a></p>
<p><strong>学习与记忆</strong></p>
<p>By 刘未鹏(pongba)</p>
<p>C++的罗浮宫(<a href="http://blog.csdn.net/pongba" title="http://blog.csdn.net/pongba/archive/2008/04/18/2302905.aspx" target="_blank"><a href="http://blog.csdn.net/pongba">http://blog.csdn.net/pongba</a></a>)</p>
<p>TopLanguage(<a href="http://groups.google.com/group/pongba" title="http://groups.google.com/group/pongba" target="_blank"><a href="http://groups.google.com/group/pongba">http://groups.google.com/group/pongba</a></a>)</p>
<p>正儿巴经学习算法算起来也有快两个月了，之前作为计算机工科生虽然算法和数据结构是必修课，但实际上只是停留在“理解”的层面，相当肤浅，更遑论举一反三灵活运用了。因此，所谓“正儿巴经”学习算法，意即开始对算法思想的本质进行归根究底的过程、对思维方法论进行归纳抽象的过程、对各种解题技巧进行一般化的过程、通过不断练习来让记忆内隐化的过程..</p>
<p>在“正儿巴经”学习算法之前，我曾经有大半年时间都在用业余时间“正儿巴经”地学习心理学和认知神经科学。所以在开始正经思考算法问题之前做的第一件事情就是仔细琢磨一直令我困惑的问题——那些看似抓不到摸不着的灵感到底是怎么来的。</p>
<p>现代心理学的一个最伟大的原则就是：所有的心理活动同时都是生理活动。——实际上，“心理活动”只不过是“大脑神经活动”的通俗称呼。虽然大脑的结构极度复杂，然而许多人不知道的是，现代神经科学对大脑功能从高层原则上的认识已经可以说是相当完备了，而对于记忆和学习这块更加是因为<a href="http://en.wikipedia.org/wiki/Eric_Kandel" target="_blank">Eric Kandel</a>的<a href="http://www.douban.com/subject/1944205/" target="_blank">突破性工作</a>变得相当清晰。可以说剩下的工作主要就是补充细节了。于是乎，借助于三本关于记忆和学习的书，一本专门论述解题心理学的书，wikipedia，波利亚的三卷解题书，以及自己在思考有限多的问题的过程中对自己的思维过程的反省和总结，我试着对解题的心理学做了一个思考和总结（《<a href="http://blog.csdn.net/pongba/archive/2008/04/18/2302905.aspx" target="_blank">跟波利亚学解题</a>》）。——这听起来很奇怪，一个本身只会初级算法的人又如何去思考涵盖所有问题解决的思维过程呢？还是引用波利亚著名的发明者悖论吧：有时候，一个一般性的问题反而要比它的一个特例更好解决。</p>
<p>然而，一般性的问题思考清楚了，清楚解题思维的本质了，并不代表我就万能了，就立即擅长解决所有算法问题了。解题不是光靠思维的，巧妇难为无米之炊。事实上，在《跟波利亚学解题》中总结的一个非常关键的要点就是：启发法固然可贵，然而知识的重要性是不可替代的。不存在通用的、万能的知识，要不然我们也不必到今天还在不断探索物质世界的规律了。此外，获得知识的过程——<strong>学习——本质上是个体力活（尽管是有一定方法的体力活）</strong>，这个体力活大致分为两步：</p>
<ul>
<li><strong>将外界（书本上的）知识转化为</strong><a href="http://en.wikipedia.org/wiki/Explicit_memory" target="_blank"><strong>外显记忆</strong></a><strong>。</strong></li>
<li><strong>通过不断练习，将外显记忆转化为</strong><a href="http://en.wikipedia.org/wiki/Implicit_memory" target="_blank"><strong>内隐记忆</strong></a><strong>。</strong></li>
</ul>
<p>（关于什么是外显记忆什么是内隐记忆请参考wikipedia或者《<a href="http://blog.csdn.net/pongba/archive/2008/04/18/2302905.aspx" target="_blank">跟波利亚学解题</a>》）</p>
<p>而第二步又包含两个过程：</p>
<ul>
<li><strong>将关于思维方法的知识转化为内隐记忆从而不知不觉就遵循。</strong></li>
<li><strong>将关于事实知识（例如“定理”、“性质”）的提取线索们转化为内隐记忆从而看到XX就能想到YY。（参考《</strong><a href="http://www.douban.com/subject/1315575/" target="_blank">找寻逝去的自我</a><strong>》第二章“记忆的建构：对现在和过去的编码和提取”）</strong></li>
</ul>
<p>关于第一点有本不错的书——《<a href="http://www.douban.com/subject/2345548/" target="_blank">学习的艺术</a>》。</p>
<p>关于第二点有一个不错的例子，最初从李笑来老师的blog上读到的（《<a href="http://www.xiaolai.net/?p=459" target="_blank">把时间当作朋友</a>》）：
我李敖看的书很少会忘掉，什么原因呢？方法好。什么方法？心狠手辣。剪刀美工刀全部下来，把书给分尸掉了，就是切开了。这一页我需要，这一段我需要，我把它分类分出来了。那背面有怎么办呢？把它影印出来，或者一开始就买两本书，把两本书都切开以后排出来，把要看的部分切开。结果一本书看完了，这本书也被分尸掉了。这就是我的看书方法。</p>
<p><em>那分类怎么分呢？我有很多自己做的夹子，夹子我写上字，把资料全部分类。一本书看完以后，全部进入我的夹子里面了。我可以分出几千个类来，分的很细。好比说按照图书馆的分类，哲学类，宗教类；宗教类再分佛教类、道教类、天主教类。我李敖分的更细了，天主教还可以分，神父算一类。神父还可以细分，神父同性恋就是一类，神父还俗又是一类。修女同性恋是一类，修女还俗这又是一类。</em></p>
<p>任何书里有关的内容都进入我的资料里来。进入干什么呢？当我要写小说的时候，需要这个资料，打开资料，只是写一下就好了。或者发生了一个什么事件，跟修女同性恋有关系，我要发表对新闻的感想，把新闻拿过来，我的资料打开，两个一合并，文章立刻就写出来了。</p>
<p>换句话说，我这本书看完之后，被我大卸八块，五马分尸。可是被我勾住了，这些资料我不凭记忆来记它，我凭用细部的很耐心的功夫把它勾紧，放在资料夹子里。我的记忆力只要记这些标题就好了。标题是按照我的习惯来分，基本上都翻译成英文字，用英文字母排出来，偶尔也有些中文的。</p>
<p>今天我把看家的本领告诉大家，李敖知道的那么多，博闻强记，记忆力那么好。我告诉大家，记忆力是可以训练的。记忆力一开始就是你不要偷懒，不要说躺在那里看书，看完了这本书还是干干净净的，整整齐齐的，这不对。看完了这本书，这本书就大卸八块，书进了资料夹，才算看完这本书。</p>
<p>今天我为大家特别亮一手，把如何看书的招告诉大家。不要以为这本书看完了，干干净净的新的算看过。那个不算看过，因为当时是看过，可是浪费了。你不能够有系统的扣住这些资料，跟资料挂钩。可是找我这个方法，可以把你看过的书，都把它的精华抓出来，扣在一起。这就是我的这种土法炼钢的治学方法。</p>
<p>恰恰运用了记忆最深刻的原理。</p>
<p>我们的大脑本质上是一个计算器，其物质基础是神经网络；而不断的练习则是对该网络节点间联系强度（神经细胞间的突触联系强度）的训练。——可惜的是像爱因斯坦大脑内的经过完美训练的神经网络参数不能直接导入到我大脑中，也许将来可以做到，但目前只有笨办法，实在是件郁闷的事。</p>
<p>所以，拿起书吧，训练你的神经网络，路漫漫其修远兮..</p>
<p><strong>参考</strong></p>
<p>我在豆瓣上列了两个豆列</p>
<ol>
<li>大半年来看过的心理学和神经科学（初步）的书都列在<a href="http://www.douban.com/doulist/46003/" target="_blank">这个豆列</a>里了。</li>
<li>其中涉及到思维方法论的书单独列在<a href="http://www.douban.com/doulist/127649/" target="_blank">这个豆列</a>里了。</li>
<li>如果你觉得里面列的书太多了不知从何下手，可以优先考虑《<a href="http://blog.csdn.net/pongba/archive/2008/04/18/2302905.aspx" target="_blank">跟波利亚学解题</a>》中列出的书。</li>
</ol>
<p><strong>P.S.</strong></p>
<p>很久不宣传我们的<a href="http://groups.google.com/group/pongba" target="_blank">TopLanguage讨论组</a>了，这个可爱的讨论组<a href="http://blog.csdn.net/pongba/archive/2008/03/12/2172677.aspx" target="_blank">诞生</a>大半年了，大半年来，人数达到了1千多，讨论8千多，主题6百多。目前活跃程度仅次于Python-CN，更重要的是，讨论组内的总体讨论质量相当高（只过年前后那段时候水了一阵）。反正我从中受益很多，在此谢谢大家！</p>
<p>那么，为什么现在又来宣传捏？盖因近来愈是发现里面牛人众多，藏龙卧虎，所以我要大言不惭地替各位牛人吹嘘，“欢迎加入牛逼<a href="http://groups.google.com/group/pongba" target="_blank">TopLanguage</a>兄弟会”:P 我们<strong><em>不</em></strong>讨论鸡零狗碎的，或者可以请教Google得到的，或者可以查书查到的问题 :P
来源： <a href="[http://blog.csdn.net/pongba/article/details/2513263](http://blog.csdn.net/pongba/article/details/2513263)">[http://blog.csdn.net/pongba/article/details/2513263](http://blog.csdn.net/pongba/article/details/2513263)</a> 
17楼 <a href="http://blog.csdn.net/xiaoyao3857" target="_blank">xiaoyao3857</a> 2011-11-08 00:13发表 <a href="http://blog.csdn.net/pongba/article/details/2513263#reply" title="回复" target="_blank">[回复]</a> <a href="http://blog.csdn.net/xiaoyao3857" target="_blank"><img src="" alt=""></a> 牛人啊，弄IT的还看了那么多书，包括心理学的、算法等，实在是强 16楼 <a href="http://blog.csdn.net/dongzezhen" target="_blank">dongzezhen</a> 2011-08-18 17:51发表 <a href="http://blog.csdn.net/pongba/article/details/2513263#reply" title="回复" target="_blank">[回复]</a> <a href="http://blog.csdn.net/dongzezhen" target="_blank"><img src="" alt=""></a> 真的很喜欢你写的文章~~ 15楼 <a href="http://blog.csdn.net/popskf" target="_blank">popskf</a> 2010-10-09 22:45发表 <a href="http://blog.csdn.net/pongba/article/details/2513263#reply" title="回复" target="_blank">[回复]</a> <a href="http://blog.csdn.net/popskf" target="_blank"><img src="" alt=""></a> 您说的TopLanguage讨论组是不是被和谐了？那个地址上不去哟。 14楼 <a href="http://blog.csdn.net/dongan383" target="_blank">dongan383</a> 2010-08-15 20:47发表 <a href="http://blog.csdn.net/pongba/article/details/2513263#reply" title="回复" target="_blank">[回复]</a> <a href="http://blog.csdn.net/dongan383" target="_blank"><img src="" alt=""></a> 找到知音啦！心里的好些困惑一下子揭开了许多！[e01] 13楼 <a href="http://blog.csdn.net/%E5%8C%BF%E5%90%8D%E7%94%A8%E6%88%B7" target="_blank">匿名用户</a> 2010-03-08 15:52发表 <a href="http://blog.csdn.net/pongba/article/details/2513263#reply" title="回复" target="_blank">[回复]</a> <a href="http://blog.csdn.net/%E5%8C%BF%E5%90%8D%E7%94%A8%E6%88%B7" target="_blank"><img src="" alt=""></a> [e01] 12楼 <a href="http://blog.csdn.net/WolfMvP" target="_blank">WolfMvP</a> 2010-03-06 14:13发表 <a href="http://blog.csdn.net/pongba/article/details/2513263#reply" title="回复" target="_blank">[回复]</a> <a href="http://blog.csdn.net/WolfMvP" target="_blank"><img src="" alt=""></a> 没有你读过那么多的书，不过，有时候我也在思考为什么我心里想的和嘴里说的不一样，是很自然的事儿不是刻意为之，原来源头在这里呀，嘿嘿，受教咯！ 11楼 <a href="http://blog.csdn.net/flyinginwind" target="_blank">flyinginwind</a> 2009-11-12 08:32发表 <a href="http://blog.csdn.net/pongba/article/details/2513263#reply" title="回复" target="_blank">[回复]</a> <a href="http://blog.csdn.net/flyinginwind" target="_blank"><img src="" alt=""></a> 偶尔按照这样子的方式在做，但是看了你的文章之后，使我从偶然世界中来到了必然世界，知道了自己以后的方向了。 10楼 <a href="http://blog.csdn.net/kewan001" target="_blank">kewan001</a> 2008-10-12 12:25发表 <a href="http://blog.csdn.net/pongba/article/details/2513263#reply" title="回复" target="_blank">[回复]</a> <a href="http://blog.csdn.net/kewan001" target="_blank"><img src="" alt=""></a> 我也时不时的思考，关于如何学习，记忆等这些问题，但不曾看过什么著作，你带我看到了一个新的世界，谢过 9楼 <a href="http://blog.csdn.net/ybark" target="_blank">ybark</a> 2008-08-19 17:53发表 <a href="http://blog.csdn.net/pongba/article/details/2513263#reply" title="回复" target="_blank">[回复]</a> <a href="http://blog.csdn.net/ybark" target="_blank"><img src="" alt=""></a> 天天看卢浮宫，不过好久没更新啦，期待ing 8楼 <a href="http://blog.csdn.net/daxi" target="_blank">daxi</a> 2008-07-26 20:03发表 <a href="http://blog.csdn.net/pongba/article/details/2513263#reply" title="回复" target="_blank">[回复]</a> <a href="http://blog.csdn.net/daxi" target="_blank"><img src="" alt=""></a> 受教了，我以前的知识面太窄，要先博后渊才能看的更高更远 7楼 <a href="http://blog.csdn.net/%E8%B7%AF%E8%BF%87" target="_blank">路过</a> 2008-07-24 22:17发表 <a href="http://blog.csdn.net/pongba/article/details/2513263#reply" title="回复" target="_blank">[回复]</a> <a href="http://blog.csdn.net/%E8%B7%AF%E8%BF%87" target="_blank"><img src="" alt=""></a> 我认为老子的&quot;无为则无不为&quot;是学习的终极本质. 6楼 <a href="http://blog.csdn.net/xinghongyang" target="_blank">xinghongyang</a> 2008-07-21 14:28发表 <a href="http://blog.csdn.net/pongba/article/details/2513263#reply" title="回复" target="_blank">[回复]</a> <a href="http://blog.csdn.net/xinghongyang" target="_blank"><img src="" alt=""></a> 文章写得很有深度，看了之后，感慨比较多，以前一直追寻的方法用文字表达出来，原来是这么子的简单，只是这些方法性的引导，最重要的还是实际操作，我个人觉得自己读过很多的书，缺的就是实际操作能力，以致于一直在重复同样的事情，而没有那种收获的感觉。 5楼 <a href="http://blog.csdn.net/vip585" target="_blank">vip585</a> 2008-07-09 20:40发表 <a href="http://blog.csdn.net/pongba/article/details/2513263#reply" title="回复" target="_blank">[回复]</a> <a href="http://blog.csdn.net/vip585" target="_blank"><img src="" alt=""></a> 佩服啊,我有个问题在烦,就是如何掌握自己的心理,把握自己朝理想的方向不断前进呢. 4楼 <a href="http://blog.csdn.net/wodiw" target="_blank">wodiw</a> 2008-06-10 11:04发表 <a href="http://blog.csdn.net/pongba/article/details/2513263#reply" title="回复" target="_blank">[回复]</a> <a href="http://blog.csdn.net/wodiw" target="_blank"><img src="" alt=""></a> 如果能找个好媳妇，或幸免于难！ 3楼 <a href="http://blog.csdn.net/wodiw" target="_blank">wodiw</a> 2008-06-10 11:03发表 <a href="http://blog.csdn.net/pongba/article/details/2513263#reply" title="回复" target="_blank">[回复]</a> <a href="http://blog.csdn.net/wodiw" target="_blank"><img src="" alt=""></a> 照这个趋势下去，刘兄最终可能会是个哲学家！！ 2楼 <a href="http://blog.csdn.net/%E7%8B%BC%E6%9C%9B%E5%85%AE" target="_blank">狼望兮</a> 2008-06-06 17:17发表 <a href="http://blog.csdn.net/pongba/article/details/2513263#reply" title="回复" target="_blank">[回复]</a> <a href="http://blog.csdn.net/%E7%8B%BC%E6%9C%9B%E5%85%AE" target="_blank"><img src="" alt=""></a> 文章写得很有深度，看了之后，感慨比较多，以前一直追寻的方法用文字表达出来，原来是这么子的简单，只是这些方法性的引导，最重要的还是实际操作，我个人觉得自己读过很多的书，缺的就是实际操作能力，以致于一直在重复同样的事情，而没有那种收获的感觉。 1楼 <a href="http://blog.csdn.net/fferror" target="_blank">fferror</a> 2008-06-05 22:02发表 <a href="http://blog.csdn.net/pongba/article/details/2513263#reply" title="回复" target="_blank">[回复]</a> <a href="http://blog.csdn.net/pongba/article/details/2513263#quote" title="引用" target="_blank">[引用]</a> <a href="http://blog.csdn.net/pongba/article/details/2513263#report" title="举报" target="_blank">[举报]</a> <a href="http://blog.csdn.net/fferror" target="_blank"><img src="" alt=""></a> 看得出pongba对于认知科学的一些理解已经进入implicit memory了。</p>
]]></content>
    
    
      <category term="好文摘录" scheme="http://itsolife.com/categories/%E5%A5%BD%E6%96%87%E6%91%98%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[转载]深思：清华学生在香港求学受到的心灵震撼]]></title>
    <link href="http://itsolife.com/2014/02/03/2014-02-03--%E8%BD%AC%E8%BD%BD%E6%B7%B1%E6%80%9D%EF%BC%9A%E6%B8%85%E5%8D%8E%E5%AD%A6%E7%94%9F%E5%9C%A8%E9%A6%99%E6%B8%AF%E6%B1%82%E5%AD%A6%E5%8F%97%E5%88%B0%E7%9A%84%E5%BF%83%E7%81%B5%E9%9C%87%E6%92%BC/"/>
    <id>http://itsolife.com/2014/02/03/2014-02-03--转载深思：清华学生在香港求学受到的心灵震撼/</id>
    <published>2014-02-03T03:24:29.000Z</published>
    <updated>2014-03-07T03:31:17.000Z</updated>
    <content type="html"><![CDATA[<h1 id="-">[强烈推荐][转载]深思：清华学生在香港求学受到的心灵震撼</h1>
<pre><code>一篇好文。直指中国教育的病根。文章提到的一些想法自己也思考过，只是没有文中说的这么透彻。很多东西只是自己一些模糊的想法，看到文章豁然开朗。总结一下，文章说了几个东西：
</code></pre><ol>
<li>国内是一种<strong>功利教育</strong>  ，而国外是一种<strong>人格教育</strong> 。国外没法说，不过国内我想大家都深有体会。人生的最初十多二十年，基本上都是在跟分数打交道，不能不说是一种悲哀。</li>
<li>文中的结论：<strong>I am who I am</strong> 。简单说，就是成全你自己，做你自己想做的，成为你自己想成为的。兴趣是最好的老师，而国内的教育偏偏打压兴趣而强调“全面”，结果就是很多人并不知道自己喜欢什么、在做着自己并不愿意做的事情。</li>
<li>结合上面两点，也就不难解释整个社会的一种功利与浮躁。教育尚且如何，更何况其他呢。。。</li>
<li><p>文中很大的篇幅说到了<strong>圣经</strong>  。个人对宗教、信仰这类东西一直都不是很了解（不信它但也不排斥）。但是看文章以后，发现以前之所以不理解，更大的原因是没有经历过一些东西，无法体会其中的道理。现在好了，文中说的正好是我所熟悉的，突然发现信仰这种东西并不像以前所想象的（呵呵，负面教育受的太多了）。信仰啊，无论你信与否，它都就在那，当你感觉无助的时候不妨看一看，有些东西或许能够释然。</p>
<p> 文章有点长，大家需要耐心看看，呵呵。<strong>过去的二十多年我们无法选择，但是将来的几十年我们可以做我们自己的选择，如何选择呢？问问自己的心</strong> 。<strong>很多同学、朋友都在找工作，呵呵，谨以此文共勉，祝大家都能找到那片属于自己的天地！</strong></p>
</li>
</ol>
<hr>
<hr>
<p><a href="http://club.chinaren.com/105403342.html" target="_blank"><a href="http://club.chinaren.com/105403342.html">http://club.chinaren.com/105403342.html</a></a></p>
<p>98年本科毕业，又顺利地被保研，当时的我只是一个憨憨的书呆子，纯洁的如同高中生，在清华这种和尚庙一般的理工学校里呆了四年，女孩似乎是山下的老虎，神秘得让我一见就脸红心跳。未来是什么对于我就是“读完研再说”，反正成绩还行，不读白不读。天上掉了馅饼，用我的兄弟的话来说。香港正好回归一周年，教育部要选派一批本科毕业生去香港科技大学读研，以加强两地的教育和科研交流。清华当然要占不少名额，系里的几个牛人去了美国，所以这个饼就掉到了我头上，确实是个不错的饼，不用考G、考托、全额奖学金，连什么手续都是学校和教育部包办了，我分文不花，后来香港科大的联络人抱怨中国的办事效率和程序烦琐，至于怎样的麻烦过程，我至今都一无所知。</p>
<p>香港科大</p>
<p>就这么糊里糊涂地来到了香港。依山傍海的科技大学美得如同世外桃源，现代感的建筑更让我们爽眼。当时的一个哥们说：“妈的，就是用银子在荒山野岭堆出来的，这样的物质条件算是让我满足了。”后来得知就是亚洲最美丽校园，倒也丝毫不怀疑。据说是香港政府感到了贸易和服务的优势正受中国沿海城市的挑战，而科技就是竞争力，就下了狠心投钱建了这学校，请来了学者。耗资400亿港币，相当于微软公司一年的纯利。组织的参观，教授的讲话，英语的培训很快就过去了，当时的新奇兴奋也褪得干净，每天面对这青山海景，最后也麻木得没有感觉了。由此可以推测娶一个漂亮老婆是没有多大意义的，如果不是为了炫耀。教授大多是华人，台湾和大陆出身的不少，反倒香港人是少数派，很多都是在北美的名校里拿了PhD,奔这里的高薪来了，他们的PhD头衔总要和名字相片挂一起，挂一辈子，Harvard和Standford之类的当然就香了。正教授可以一年拿到一百多万港币，也就是一个月可以买小汽车，比一般的美国大学高。知识真的值钱了，让我们充满了对未来的向往。有回和教授们吃饭，谈及大陆大学教授的待遇，他们就感慨：“知识分子真被廉价到了可耻的地步。”我们也无话可说，反正不是我的错。然而钱不是好拿的，很多教师正是三十出头，教授职称还未到手，和学校只是几年合同，其他的学者也不断在申请进来，所以压力颇大，辛勤程度比公司打工仔有过之而无不及。既然自己做学问要紧，培养学生的事就要往后排了。刚近来时很多教师和我们亲切讲话，之后就不见了，好久不见就不认得。研究生当然有导师的，只要自己不去找他，他是肯定不会找我的。上课之后就是绝对的自由，当时自由得很是惬意。</p>
<p>萧伯纳说人生的苦闷有二，一是欲望没有被满足，二是它得到了满足。这话的确是部分的真理。当我住在这绝世美丽的地方，可以随心所欲的去商店买东西不用担心付不起帐，可以任意的支配自己时间时，最初的半年里，却发现情绪每况愈下。西方化的建筑设计将个人的所谓 privacy保护发挥到极致，进了宿舍就基本感觉不到他人的存在，同单元的人也有独立的卧室，大家都是进了房，将门一关，隔离了，谁也不好意思去敲门。刚来时认识的一伙人，后来发现根本遇不着，如同消失了一般。同住一起的是三十好几的叔叔级人物，偶尔可以说上一两句话，却永无可能说很多。大家都像是住在不同的空间里做研究，忙碌的无瑕顾及他人。</p>
<p>平心而论，对于一个成熟的研究者，如果他有确定的目标和兴趣，对生活人生都不再有不切实际的幻想，准备投身科学研究中，那么这里真是一个好环境。但是我种茫茫睁着无知的眼睛的毛头小子，却是完全另外的感觉。那种茫然的苦闷感觉真是难以描述，找不到人玩，只是将窗户开了又关，关了又开，不停的喝水，仍然感觉不舒服。怀念在清华的破楼里相互串门打闹的日子，怀念抱着篮球在走廊里叫一声就应者云集的日子，可是怀念解决不了问题。以孩子的心理去进入成熟严谨的环境，不可不说是一次考验。</p>
<p>多年的功利教育的辛勤培养，我一路顺当地走过来，发现完全的上当。我在成功的通过了一次次考后，最终都不知道我为什么要通过这些占距人生的考试，这个所谓的优秀学生只是在不停地让自己去符合那个“优秀”的外在标准来麻痹自己的虚荣心，而自己，那个真正的自己却一直没有存在过，没有发育过。我学的任何课程都无法帮我解决当时的苦恼，那么每天学那些微分方程又是为了什么？还去为了父母的微笑，人们的赞许吗？年年得奖学金的清华毕业生是了这么一个怪物：不知道自己要什么，也不知道生活是什么，对社会毫无接触，二十出头，可是见女孩子就一身不自在，会解各式各样的方程，却不能解决自己的困惑，硕士博士的路就在眼前，可是不知道还应不应该这样走下去，这状态难道就是我的追求？一个智商还不错的人努力多年就变成这样？这是一个问题，很早就有了，只不过太晚地暴露出来，我相信这样的问题依然将被很多师弟师妹们面临，我相信在清华依旧有很多像我当年一样的学生。当看到他们天真的讨论： G 2/<em>/</em>/<em>, 托 6/</em>/<em>，GPA 3./</em>, 学校名次Top /<em>/</em>, 仿佛几年的辛劳就只为那么点数字，人生的终极标就是 go abroad. 我无法不为他们忧虑。这也是促使我写这篇文章的主要原因。</p>
<p>很多人没有对做研究的真正兴趣，但是用尽了精力去获得一个去国外做科学研究的机会，就洋溢在掩饰不住的喜悦里，甚至对人生毫无真正规划，对自己的兴趣一无所知，为出国而出国，那将在告别父老乡亲后去迎接苦闷的开端。香港的学生很实际，决大多数本科毕业就去赚钱，三十之间为结婚买房奋斗，如果告诉一个香港人说你二十八了还在读博士，他会觉得你很失败，可能是根本不会赚钱。而留下来读博士的香港学生，就是真的很喜欢作研究的人，扎实地做事，他们的认真让我们一批朝三暮四，心猿意马的大陆学生汗颜。</p>
<p>生活在香港</p>
<p>都说香港是弹丸之地，其实一千多平方公里的面积也不算小，不过大多是山，可利用的地方不多，很多商业区都是添海造出来的。亚热带的气候，又在到处是山和海湾的地方，风景当然好。香港的气候比北京舒适一万倍，冬天冷不了，夏天也不太热，甚至没有明显的四季感。只是上半年天气有些潮。成天都有湿湿的感觉，北方人有点受不了。香港的交通极其发达，公共车从不拥挤，也很少堵车，可是香港的道路比北京的窄得多，车也不会少，布局和管理更好而已，看来北京走向国际化还须努力。这里是名符其实的购物天堂，东西也不算贵，电器和服装可能比北京便宜，特别是国际名牌，由于没有关税，肯定要比大陆便宜。所以不必带很多衣服来，足够便宜了。但是服务业，比如吃饭，理发，涉及到员工劳动和地租的就要比大陆贵好几倍。可以随便往来深圳也是在香港的一大好处，一天可以轻松来回好几次，在香港读书的学生可一得到香港的临时身份证，加上护照上盖个章，就可以自由出入境了。</p>
<p>常有人问及香港的影视明星，可是到了香港就觉得那些人也只是打工仔，背后是更有影响力的老板，一旦老板不想捧了，明星就会很快消失，新人会取而代之。看到他们卖力地载歌载舞，其实也是生存需要，在商业社会里那是绝对的驱动力。香港的金融和资讯服务相当发达，在所谓第一世界里也算相当突出，可以很便宜的享受到信用卡，电讯，互联网服务，因此有些人在香港呆久了再回来反而不适应了，主要就是这些方面，当然还有其他制度等软件原因。
说到学校的生活，物质条件比国内任何大学好，甚至条件好过美国不少学校，香港的学生很少住宿学校，所以一到周末放假学校就很冷清。通常大陆学生独享学校设备，偌大电脑房和运动场，舒服的游泳池，都有不少美好回忆。学生宿舍条件不错，可以作饭，自己作比在餐厅里吃来的便宜，所以大陆学生会乐此不疲，周末常三五成群，作吃的为乐。餐厅里中西餐都有，中餐以广东口味为主，忙起来时以营养为重，口味不对也只能将就吃了。</p>
<p>现在在香港的大陆学生不算多，总共有四五百人，各个学校都有学生联谊会，是比较松散的组织，也有一些机会认识朋友。周末会组织放放电影，搞舞会。临近考试或论文时，谁也没心思搞活动。香港的学生很好打交道，在成熟的社会里长大的人，心理相对简单且好玩，不像一些大陆学生常常过分盘算自己的明天，将自己逼的很累。他们对大陆也渐渐感兴趣，虽然他们常常不知道湖南和四川，只说得上秦始皇和xx。只要主动点和他们交流，是可以结识不少朋友的，粤语不是障碍，很多人可以听普通话，而且，广东话不难学，不留神就长进不少。</p>
<p>关于工作机会</p>
<p>很多人就终于跳到北美去了，大多还是接着读书，从这个意义上讲，香港只是跳板。在香港留下工作的机会不多，如果在进香港的第一天了解这一点，是有好处的。也有回祖国的，我就是，所以我在这里写文章了，看到很多朋友询问去香港读书的问题，作为过来人，就写了这些，如果能给这些朋友提供一点有益的信息，就很满足了。</p>
<p>上次写了文章发表在海外学子版，很多朋友给我回信，给了我很大的鼓励，真的没想到过自己的东西会给别人带来影响。留学的经历给了我很多，几乎是一个脱胎换骨的过程，在一篇文章里是不可能都讲完的，所以我再写一个续集，好莱坞搞续集纯是为赚钱，我呢是什么都不图，万一有 ppmm看了之后找我，最爽不过。将心底里的一点点“龌龊” 都暴露出来，可以痛快讲了。</p>
<p>凡事都是虚空</p>
<p>来自发展中国家的人，难免在神情上都多一丝生存紧张，中国在海外的留学生尤其让人感觉到这一点。看不到出自内心的笑，连谈话时也似乎只有一个主题：今后有什么打算？每做一件事，都在问自己：对我有没有好处？
坦白的说我自己刚到香港时就是这样，只觉得自己多么没着落，无根无底的飘在他乡，我要努力啊，绝不可浪费自己的任何精力，房子，车子，名誉，地位，还有漂亮老婆，我什么都要啊。要学最能给我带来利益的东西，去做最有利自己的事情，直到我成功。</p>
<p>当时我就是这么典型功利，到现在我都想这样痛骂自己。</p>
<p>数学指出函数的极大值往往在最不稳定的点取到，人追求极端就会失去内心的平衡,到时候就不难体会到数学原理的深刻。我很快让我的功利心理逼到无路可走了，对所学的东西怀疑，担心自己变成书呆子，对自己有信心，找不到真正的朋友，找不到让身心平静的乐趣，每天都在心潮起伏。最后我去找学生辅导员。愚蠢的诉说倒不多提了，不过我记得他大胡子的脸有了微笑，眼睛里放出宽容而温和的光。他告诉我觉的我很有意思，他第一次遇到这么坦白的学生。“那些东西有什么意义呢，你怀疑得很好。“之后就翻出圣经来，给我读某些章。</p>
<p>Everything is meaningless.竟是圣经里的话语。那是我看到的最为震惊的一句话，也是我后来觉得最深刻的一句话。中国人很难理解，对在功利教育里熏陶过来，缺少人格教育的中国学生，更无异于晴天霹雳。成绩，offer, 学位，这样那样的好处，每天拼命算计的东西有什么意义？假设你突然死掉，世界将会怎样？世界将一样绚丽，地球转的一样快，太阳系每天在宇宙中换一个位置。大海还是大海，波涛还是波涛，一样的花开花落，潮起潮落。你的亲人可能会掉眼泪，但是周围的人在三个月内将你忘个干净，那是你曾经那么在乎他们怎么看你的一群人啊。如果上帝存在，在他的眼里，你是多么可怜的小虫子，在活着的短暂岁月里，在最美好的青春里，都不曾快乐过，用尽心力去聚集一大堆外在和心灵没有关系的小东西，只是出于对未来的没有信心，小小的心灵在接近熄灭的一天还在发出那个愚蠢的声音，让你忙碌，让你忧虑的声音：我要，我还要。天底下充满了这样的小虫子，当一个离开了，又有一个来了，做着同样的事情，汹涌着同样的小小念头，受着同样的煎熬。于是上帝要感慨了：虚空的虚空，凡事都是虚空。已有的事，后必再有；已行的事，后必再行。日光之下，并无新事。</p>
<p>已过的时世代，无人纪念；将来的世代，后来的人也不纪念。
------圣经 旧约 传道书</p>
<p>我不是在传教，当时的辅导员也不是在传教，但是让我立刻看到自身的渺小，物质追求的虚妄，内心的愚昧。看看资本主义的学生辅导，是不是比我们这边高明多了？马哲曾帮助过我们什么？</p>
<p>不要忧虑“不要为明天忧虑，天上的飞鸟，不耕种也不收获，上天尚且要养活它，田野里的百合花，从不忧虑它能不能开花，是不是可以开得和其它一样美，但是它就自然的开花了，开得比所罗门皇冠上的珍珠还美。你呢，忧虑什么呢？人比飞鸟和百合花贵重多了，上帝会弃你不顾吗？”</p>
<p>一个朋友告诉我，他在等美国offer 的时候，常常梦到接到牛校offer, 过度兴奋到醒，更为郁郁，感慨 “但愿长醉不复醒”。这样的故事大家听了不会太惊诧，由此不难理解《儒林外史》中的进中举了。而得到offer的人到了海外，往往要经历更多的梦醒时分。</p>
<p>为什么活得这么累？生命本是如此美丽，连飞鸟和野花都可以尽情地享受上天的恩赐，而这些有高等思维的聪明人，却活活让思维搞得神情郁郁，哀声叹气。</p>
<p>常有人感叹西方人笑起来那么真实，那么出自内心，探讨起来，又归结到他们更有钱，他们的社会更发达。可我觉得那不是原因。原因就是他们比中国学生更接近飞鸟和野花罢了，更接近《阿甘正传》里的弱智罢了。他们更天真，相信那个万能的上帝会永不遗弃他，所以他们可以少想很多的问题，反而过得更顺利，在团队里表现得更凝聚，因为过分的私心是无法向大家共同的上帝交代的，他们可以很快做出一个Microsoft，一个Dell，但是大家可以看看中国的北大方正，联想，新浪，管理层一年的地震比台湾还多, 这么多年来，连冲出亚洲的野心都没有真正实现过。这难道不是上帝给西方人带来的好处，耶稣说信我就可以得救，不管这个上帝是不是虚拟的，但他在事实上填补了人性的巨大空白，人家的Microsoft 就证明了他的存在，正如计算机的虚拟内存，尽管虚拟，但事实上的作用是巨大的。中国学生总是怀疑这个看不见的上帝是否存在，更在私下里说，他对我能带来好处吗？其实中国人什么都不信，只信好处，从古时的考八股起，读书就是为了好处。因此，大家每天活在害怕没有好处的忧郁里，想靠自己小小的思维，在着巨大的世界系统里去谋取好处，上帝忍了泪水，背过脸去。思维的无奈我并不主张虚无，尽管我在上一篇文章里尽力去指出物质追求的虚妄。</p>
<p>正如萨特认为，人生本是本无意义，但是怎样摆脱虚无却是有意义的。王朔的意义在于砸碎那些没有意义的假崇高，伍迪.艾伦的意义就在于不断指出人生的荒谬。如果一切都是那么可笑，我们怎样面对每天的24小时？但是活着就是这么简单，它只是一个过程，简单而自然地发生，以至于任何干扰和关注都是多余。就像飞鸟掠过天空，野花静静地开放。能把什么东西叫做现在吗？你能占有什么东西吗？一切的意义只在时间的流动的河中。就像一团火，哪个燃烧的过程才叫火，一旦过程停止了，火不存在了。人的思维在作怪,它是一个双面的东西，它不总是带给我们好处，虽然我们对它有那么多自信。思维在很多时候严重地干扰了那个自然的生命过程，它在想单个的状态好不好，值不值得，合不合规范，能给自己带来什么，所以我们很快变得不快乐，不安稳，再也无法享受那种自然的喜悦了，正像被摄像的人，他的表情立刻不自然起来。恐怖片里的鬼魂可能一直不曾出现，人们却开始牙齿打颤，是被自己思维折磨而已。学计算机的朋友肯定知道操作系统将一个进程悬挂起来的意思。人的那个蠢笨不堪的思维，凭什么要常驻内存？它那么长期的运转，又真正解决了多少问题？为什么不在必要的时候悬挂它，去享受生命的自然？明白这一点将改变你的生活，思维会使你陷入矛盾，很多时候它是多余的，用心去体会，甚至用毛孔去感受就足够了。当你不再判断，不再分辨，不再比较，不再权衡，你就立刻、和谐起来。“采菊东篱下，悠然见南山”。那时，还用考虑什么呢？“此间有真意，欲辩已忘言”，连言语都是多余，因为言语来自思维。佛陀的捻花一笑，详和的神情，虽静坐，似乎已飞跃世间一切，他坐在了那个生命的根本之上, 再也没有一丝的不和谐。</p>
<p>读书的时候，我常常到海边听滔声，坐下来看着太阳落下，那会是我一天最美好的时间，当太阳没下去，晚霞渐渐褪去颜色，波浪依然轻轻拍打岸边，幕色从四周将我围过来，静默中我会在心灵里升起喜悦，感觉到冥冥中那个永恒的力量，它在紧紧将我抱住，天地万物和我一样同在，也被温和地抱着，我将永不孤独，永不伤心，永不绝望，因为那力量就一直在那里，将永远在那里，我是它的恩赐，我的灵魂从未像那时一样枝繁叶茂，内心从未像那时一样宁静和谐。我不用去分辨那种力量，是上帝也好，上天也好，老子说的道也好，有什么关系呢？分辨只是是思维常干的蠢事罢了。所有的心灵都是一样的，所以我相信所有人都有那个和谐的状态，就像收音机有那个频道一样，只不过太多人没有调到过。太阳，大海，清风明月，鸟语花香，生生不息的物种，是多么大的恩赐啊，只在我们断暂的生命里才可以感受到，可是太多的人从不念及。他们将自己全部地交给了少得可怜的脑细胞，心灵交给了那个拙劣的 CPU, 时时刻刻在做狭窄不堪的运算和判断，所以才会长时间挣扎焦虑，只看到85分和90分的区别， 5000元月薪和10万年薪的不同，牛校和烂校的分辨。所以“郁闷”，“无耻”，“倒霉”，“不爽”，“急”，这样的词汇就开始在嘴边泛滥了，就像破电脑的出错提示一样多。</p>
<p>本没有打算再写很多了，关于人生的刨根问底本来就是沉重的课题，无异让学业繁多的学子们再怀疑自己，平添忧虑。倒不如多说点逗乐的事，每天多嘻嘻哈哈一阵。前不久见到北大的一个女生，说我前面介绍香港的文字很实用，后面的文章就越来越看不懂了，可以理解，并不是所有的人都要像我一样想这些问题的，特别是女孩，一天多说几声“挺好的”“好温馨哟”就算过得不错了，古今中外都不曾出过一个女哲学家。但是，这位未曾谋面的北大师弟在等我的续集，谢谢你， xmdl(阿扁鱼）, 我不愿让你失望这一篇是为你而写的。</p>
<p>我们看的人文书前面提到的女生就问我，在留学过程中最大的收获是什么，我回答是长了见识。就像在小地方呆久的人出来见了大海，这个收获大得很。所以我渐渐地学会了真正的谦虚态度，越来越承认自己所可以理解到的，可以认识到的只是这世界的太小一部分。在我的脑力范围外有太大的空间，从这一点来看，我们每个人都对自己有过多的自负，每天都在或多或少的干着作井观天的蠢事，争论着盲人摸象的争论。</p>
<p>清华北大的学生的人文素养，我想，很多来源于图书馆的人文书籍，因为喜欢读书的学生多半在那里搬书回来看。可是那些书多产于七十，八十年代，基本上是被一把姓马的刀阉割了的太监式的书，我不怕得罪人。怎么阉割法？举个例子，“总体而言，宗教是唯 心的，错误的世界观，被统治 阶 级利用来麻痹被统治 阶级的广大人民...”从此，你知道了这一点，你么读释迦，读耶稣，读老庄，都觉得如同太监一般阴阳怪气。在红色的年代里，马刀所向无敌，包括孔夫子到孙中山，从曾国 藩到蒋介 石，都少有可以逃脱的，因为他们有“阶 级局限性”。</p>
<p>但是我到了香港，就看到了很多台湾的书，很多香港的书，原来这些书本不象太监的，甚至不比姓马的书少阳刚之气，可以读得让人忘食，哎，可怜它们的被阉。这些都是我以前脑子以外的东西，所以我立刻知道要谦虚了，人总是受着他的经历和环境的巨大局限，他甚至不意思到，没有选择地被限制隔离着。</p>
<p>耶稣呢，用我们的眼光看，他太失败了，没有妻子，没有儿子，没有房子，没有财产，没有地位，最后还要被钉死，他只是游走于四方去救助受苦受难的人们，他有余的眼光总是看到了世界的外面，因为他也到过更高的维度里。
庄子至今看来还是活得最浪漫最洒脱的中国人，他是超脱的同义词，他也是高维空间的蚂蚁。</p>
<p>去读他们，去体会那种来自另外一个维度的智慧的震撼，尽管你可能无法改变无奈的现实，但是可以深刻地改变自己，尽管无法摆脱沉重的肉身，依旧无选择地活在平面上，但是，心灵获得了自由。愿意升起你的心灵吗？</p>
<p>每个人都是独一无二的，而且我们永远只能是自己，卢梭说的，对于整个世界我微不足道，但是我对于自己确是全部。事实上我们只对于自己重要，如果我死掉了，没有几个人会在三年后保持对我的记忆，如果我痛苦，没有几个人会有真正的同情，因为太难了，每个人都无法了解我的意识。所以我们要独立，活着就是成为自己，那个独一无二的自己，去寻找自内在的完美与和谐，去实现句那没有选择的话：I am who I am。Simply because I am not and can not be anyone else.可是我们受教育，教育的目的就是教我们忘掉自己，去变成一个称为标准的人，不是这样吗？从小学起我们就要评三好，树标兵，学雷锋，学赖宁。老师总是看到我们的恶习，“你那样子不合行为规范，不可耻吗？”
到了大学，我们又自由了多少呢？我们依旧看别人，看典型，看所谓成功者，我们依旧活在要忘掉自己的标准包围中，去bbs看看，似乎所有人都统一了口吻，GRE 2400,拿了牛校offer, 签了著名外企，找到了ppmm, 牛啊，羡慕啊，爽啊, 历史走到了21世纪，北大和清华人只剩下一副面孔了，每年招了很多新生，最后就剩下了一个。</p>
<p>比较是有意义的吗？作为一个独一无二的存在，作为自己的全部主宰，为什么要什么都和人家比才可以找到意义？为什么当别人考G的时候，我也一定要考，为什么考不过2200就要郁？为什么billgates 成功的时候，我也一定要学计算机？可是自己和别人是多么的不同，些不同难道可以在一些欲念的驱动下轻易的忽略？</p>
<p>崇拜是有意义的吗？明星是需要那样追捧的吗？中国的那支烂球队是需要那么多关注的吗？</p>
<p>当我们倾注希望的时候，他们借此赚到了更多的银子，活得更加嚣张，更加让我们失望，我们是在给富翁们献爱心，爱心那么多，为什么不献给需要爱心的更多的人们，为什么不献给自己，独一无二的自己？</p>
<p>当我们崇拜自己，热爱自己，追捧自己，关注自己，我们就都也是明星了。这样盲从将无法发生，起哄将无法发生，个人崇拜将无法发生。这个意义大的很，至少大跃进将不发生，文革将不发生，我们的经济有可能早三十年走上正轨，现在我们不需要拼命飞跃重洋，中央到地方的官员就不要象现在一样，在亿万人没有工作时还竭力吹嘘7%的GDP增长，就像阳痿的人，为了脸面，郑重地去声名：请看我浓密的胡须，年增长率7%</p>
]]></content>
    
    
      <category term="好文摘录" scheme="http://itsolife.com/categories/%E5%A5%BD%E6%96%87%E6%91%98%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Bruce Eckel：编程生涯]]></title>
    <link href="http://itsolife.com/2014/02/03/2014-02-03--BruceEckel%EF%BC%9A%E7%BC%96%E7%A8%8B%E7%94%9F%E6%B6%AF/"/>
    <id>http://itsolife.com/2014/02/03/2014-02-03--BruceEckel：编程生涯/</id>
    <published>2014-02-03T03:24:29.000Z</published>
    <updated>2014-03-07T03:24:29.000Z</updated>
    <content type="html"><![CDATA[<h1 id="bruce-eckel-">Bruce Eckel：编程生涯</h1>
<p><strong>EN文：</strong></p>
<p>Computing Thoughts
A Career in Computing
by Bruce Eckel
June 2, 2009
 <strong>Summary</strong>
I regularly receive requests for career advice, and I&#39;ve tried to capture the answers in this blog, and in a follow-on. For those of you who asked but never got an answer, I apologize. Your questions stimulated me to work on this, and it&#39;s taken awhile.</p>
<p>The question that people ask is usually the wrong one: &quot;should I learn C++ or Java?&quot; In this essay, I shall try to lay out my view of the true issues involved in choosing a career in computing.</p>
<p>Note that I am not talking here to the people who already know it is their calling. You&#39;re going to do it regardless of what anyone says, because it&#39;s in your blood and you can&#39;t get away from it. You know the answer already: C++ AND Java AND shell scripting AND Python AND a host of other languages and technologies that you&#39;ll learn as a matter of course. You already know several of these languages, even if you&#39;re only 14.</p>
<p>The person who asks me this question may be coming from another career. Or perhaps they are coming from a field like web development and they&#39;ve figured out that HTML is only kind of like programming, and they&#39;d like to try building something more substantial. But I especially hope that, if you are asking this question, you&#39;ve realized that to be successful in computing, you need to teach yourself how to learn, and never stop learning.</p>
<p>The more I do this, the more it seems to me that software is <a href="http://www.artima.com/weblogs/viewpost.jsp?thread=255898" target="_blank">more akin to writing</a> than anything else. And we haven&#39;t figured out what makes a good writer, we only know when we like what someone writes. This is not some kind of engineering where all we have to do is put something in one end and turn the crank. It is tempting to think of software as deterministic -- that&#39;s what we want it to be, and that&#39;s the reason that we keep coming up with tools to help us produce the behavior we desire. But my experience keeps indicating the opposite, that it is more about people than processes, and the fact that it runs on a deterministic machine becomes less and less of an influence, just like the Heisenberg principle doesn&#39;t affect things on a human scale.</p>
<p>My father built custom homes, and in my youth I would occasionally work for him, mostly doing grunt labor and sometimes hanging sheet rock. He and his lead carpenter would tell me that they gave me these jobs for my own good -- so that I wouldn&#39;t go into the business. It worked.</p>
<p>So I can also use the analogy that building software is like building a house. We don&#39;t refer to everyone who works on a house as if they were exactly the same. There are concrete masons, roofers, plumbers, electricians, sheet rockers, plasterers, tile setters, laborers, rough carpenters, finish carpenters, and of course, general contractors. Each of these requires a different set of skills, which requires a different amount of time and effort to acquire. House-building is also subject to boom and bust cycles, like programming. If you want to get in quick, you might take a job as a laborer or a sheet rocker, where you can start getting paid without much of a learning curve. As long as demmand is strong, you have steady work, and your pay might even go up if there aren&#39;t enough people to do the work. But as soon as there&#39;s a downturn, carpenters and even the general contractor can hang the sheet rock themselves.</p>
<p>When the Internet was first booming, all you had to do was spend some time learning HTML and you could get a job and earn some pretty good money. When things turned down, however, it rapidly becomes clear that there is a hierarchy of desirable skills, and the HTML programmers (like the laborers and sheet rockers) go first, while the highly-skilled code smiths and carpenters are retained.</p>
<p>What I&#39;m trying to say here is that you don&#39;t want to go into this business unless you are ready to commit to lifelong learning. Sometimes it seems like programming is a well-paying, reliable job -- but the only way you can make sure of this is if you are always making yourself more valuable.</p>
<p>Of course you can find exceptions. There are always those people who learn one language and are just competent enough and perhaps savvy enough to stay employed without doing much to expand their abilities. But they are surviving by luck, and they are ultimately vulnerable. To make yourself less vulnerable, you need to continuously improve your abilities, by reading, going to user groups, conferences, and seminars. The more depth you have in this field, the more valuable you will be, which means you have more stable job prospects and can command higher salaries.</p>
<p>Another approach is to look at the field in general, and find a place where you already have talents. For example, my brother is interested in software, and dabbles with it, but his business is in installing computers, fixing them and upgrading them. He&#39;s always been meticulous, so when he installs or fixes your computer you know that it will be in excellent shape when he&#39;s done; not just the software, but all the way down to the cables, which will be bundled neat and out of the way. He&#39;s always had more work than he could do, and he never noticed the dot-com bust. And needless to say, his work cannot be offshored.</p>
<p>I stayed in college a long time, and managed to get by in various ways. I even began a Ph.D. program at UCLA, which was mercifully cut short -- I say mercifully because I no longer loved being in college, and the reason I stayed in college for so long was because I enjoyed it so much. But what I enjoyed was typically the off-track stuff. Art and dance classes, working on the college newspaper, and even the handful of computer programming classes that I took (which were off-track because I was a physics undergrad and a computer <em>engineering</em> graduate student). Although I was far from exceptional academically (a delightful irony is that many colleges that would not have accepted me as a student now use my books in their courses!), I really enjoyed the life of the college student, and had I finished a Ph.D. I probably would have taken the easy path and ended up a professor.</p>
<p>But as it turns out, some of the greatest value that I got from college was from those same off-track courses, the ones that expanded my mind beyond &quot;stuff we already know.&quot; I think this is especially true in computing because you are always programming to support some other goal, and the more you know about that goal the better you&#39;ll perform (I&#39;ve encountered some European graduate programs that require the study of computing in combination with some other specialty, and you build your thesis by solving a domain-specific problem in that other specialty).</p>
<p>I also think that knowing more than just programming vastly improves your problem-solving skills (just as knowing more than one programming language vastly improves your programming skills). On multiple occasions I have encountered people, trained only in computer science, who seem to have more limits in their thinking than those who come from some other background, like math or physics, which requires more rigorous thinking and is less prone to &quot;it works for me&quot; solutions.</p>
<p>In one session a conference that I organized, one of the topics was to come up with a list of features for the ideal job candidate:</p>
<ul>
<li>Learning as a lifestyle. For example, you should know more than one language; nothing opens your eyes more to the strengths and limitations of a language than learning another one.</li>
<li>Know where and how to get new knowledge.</li>
<li>Study prior art.</li>
<li>We are tool users.</li>
<li>Learn to do the simplest thing.</li>
<li>Understand the business (Read magazines. Start with Fast Company, which has very short and interesting articles. Then you can see if you want to read others)</li>
<li>You are personally responsible for errors. &quot;It works for me&quot; is not an acceptable strategy. Find your own bugs.</li>
<li>Become a leader: someone who communicates and inspires.</li>
<li>Who are you serving?</li>
<li>There is no right answer ... and always a better way. Show and discuss your code, without emotional attachment. You are not your code.</li>
<li>It&#39;s an asymptotic journey towards perfection.</li>
</ul>
<p>Take whatever risks you can -- the best risks are the scary ones, but in trying you will feel more alive than you can imagine. It&#39;s best if you don&#39;t plan for a particular outcome, because you will often miss the true possibilities if you&#39;re too attached to a result. My best adventures have been ones that have started with &quot;lets do a little experiment and see where it takes us.</p>
<p>Some people will be disappointed by this answer, and reply &quot;yes, that&#39;s all very interesting and useful. But really, what should I learn? C++ or Java?&quot; I&#39;ll fend these off by repeating here: I know it seems like all the ones and zeroes should make everything deterministic, so that such questions should have a simple answer, but they don&#39;t. It&#39;s not about making one choice and being done with it. It&#39;s about continuous learning and sometimes, bold choices. Trust me, your life will be more exciting this way.</p>
<h1 id="-further-reading-"><a href="">Further Reading</a></h1>
<p>Here&#39;s an earlier piece I wrote on <a href="http://mindview.net/WebLog/log-0030" target="_blank">how I got started in programming</a>.
I found all these to be interesting and stimulating takes on the same subject: </p>
<ul>
<li>Teach yourself programming in ten years, by Peter Norvig: <a href="http://norvig.com/21-days.html" target="_blank"><a href="http://norvig.com/21-days.html">http://norvig.com/21-days.html</a></a></li>
<li>How to be a Programmer, by Robert Read: <a href="http://samizdat.mines.edu/howto/HowToBeAProgrammer.html" target="_blank"><a href="http://samizdat.mines.edu/howto/HowToBeAProgrammer.html">http://samizdat.mines.edu/howto/HowToBeAProgrammer.html</a></a></li>
<li>Here&#39;s a <a href="http://news-service.stanford.edu/news/2005/june15/jobs-061505.html" target="_blank">speech by Steve Jobs</a>, trying to inspire a group of graduating college students.</li>
<li>Kathy Sierra: Does College Matter? <a href="http://headrush.typepad.com/creating_passionate_users/2005/07/does_college_ma.html" target="_blank"><a href="http://headrush.typepad.com/creating_passionate_users/2005/07/does_college_ma.html">http://headrush.typepad.com/creating_passionate_users/2005/07/does_college_ma.html</a></a></li>
<li><a href="http://www.paulgraham.com/college.html" target="_blank"><a href="http://www.paulgraham.com/college.html">http://www.paulgraham.com/college.html</a></a></li>
<li><a href="http://www.joelonsoftware.com/articles/CollegeAdvice.html" target="_blank"><a href="http://www.joelonsoftware.com/articles/CollegeAdvice.html">http://www.joelonsoftware.com/articles/CollegeAdvice.html</a></a></li>
<li><a href="http://www.jamesshore.com/Blog/Five-Design-Skills.html" target="_blank"><a href="http://www.jamesshore.com/Blog/Five-Design-Skills.html">http://www.jamesshore.com/Blog/Five-Design-Skills.html</a></a></li>
<li><a href="http://steve-yegge.blogspot.com/2006/03/truth-about-interviewing.html" target="_blank"><a href="http://steve-yegge.blogspot.com/2006/03/truth-about-interviewing.html">http://steve-yegge.blogspot.com/2006/03/truth-about-interviewing.html</a></a></li>
</ul>
<p>In a future article (I&#39;ll post the link here when it&#39;s done), I will talk about the importance of understanding management and business issues, whether or not you ever plan to be a manager, and in that article I&#39;ll include a list of books that (even though they&#39;re about management) you should read to prepare yourself for your career.</p>
<h1 id="talk-back-">Talk Back!</h1>
<p>Have an opinion? Readers have already posted <a href="http://www.artima.com/forums/flat.jsp?forum=106&amp;thread=259358" target="_blank">24 comments</a> about this weblog entry. Why not <a href="http://www.artima.com/forums/post.jsp?forum=106&amp;thread=259358&amp;reply=true" target="_blank">add yours</a>?</p>
<h1 id="rss-feed">RSS Feed</h1>
<p>If you&#39;d like to be notified whenever Bruce Eckel adds a new entry to <a href="http://www.artima.com/weblogs/index.jsp?blogger=beckel" target="_blank">his weblog</a>, subscribe to his <a href="http://www.artima.com/weblogs/feeds/bloggers/beckel.rss" target="_blank">RSS feed</a>.  </p>
<hr>
<p><strong>中文：</strong></p>
<p><strong>Bruce Eckel：编程生涯</strong></p>
<p>作者 <strong>Bruce Eckel</strong> 是编程界的大牛，著有大名鼎鼎的《Thinking in C++》和《Thinking in Java》。
本文是他对程序员（尤其是新手）的忠告。</p>
<p>================华丽的分割线================</p>
<p>大家总是问一个错误的问题：“我应该学习C++还是Java？”在本文中，我将告诉大伙儿：对于选择编程生涯真正需要关注的是哪些问题。</p>
<p>请 注意，这篇文章的目标读者并不是那些已经做出自己选择的人。（对于这些人而言）你会继续自己的编程生涯，而不管别人会怎么说。因为它已经渗透到你的血液 中，你已经无法摆脱。你已经知道答案：C++、Java、Shell脚本、Python、还有其它一大堆的语言和技术，你都理所当然地会去学习。甚至有可 能你才仅仅14岁，就已经知道好几种不同的语言。</p>
<p>问我这样的问题的人可能来自其他行业，或者来自诸如Web开发之类的领域。他们知道HTML是一种类编程语言，而且想尝试构建某些更大型的应用。但我特别希望，当你在问这个问题时，你已经意识到了想要在计算机领域取得成功，你需要掌握自学能力，而且永不停息。</p>
<p><strong>在这个领域做得越多，我越觉得软件开发比任何行业都更接近于写作。</strong> 我们从来不知道是什么造就了优秀的作者，我们只知道什么时候我们会喜欢某个人的文字。编程不是一种工程，仅需要把东西从入口倒进去，然后再转动手柄。把软 件开发看成确定性的，是一个诱人的想法。因为这个想法，人们总想搞出一些工具来帮我们开发出想要的软件。但是我的经验告诉我，事实并非如此——人的重要性 远高于流程。而软件是否运行在一部精确的机器上已经越来越不重要了——这犹如测不准原理对人类的影响。</p>
<p>我的父亲是造房子的，小时候我偶尔会帮忙打下手，放放砖块之类。他和他的木工告诉我，他们是为我好才让我干这些活——这样我就不至于走入这个行业。事实确实是这样。</p>
<p>我 们不妨把软件开发比作盖房子。造房子的人当然不可能完全一样。这些人里面有：混凝土工、屋顶工、管道工、电工、砖瓦工、水泥工、瓦片工、搬运工、粗木工、 细木工。当然，还有工头。每个工种都需要相应的技能，这些技能都需要花时间和精力去掌握。跟软件开发一样，造房子也是一个“建立/推翻”的过程。如果你想 很快地获得回报，你可能从搬运工和砖瓦工开始做，这样的话，你无需太多的学习曲线就可以获得回报。当需求很多时，你的工作会很稳固，甚至收入也可能提升 ——如果没有足够的人手的话。但是，一旦行情不妙，木匠甚至工头就可能把砖瓦工一脚踢开。</p>
<p>当互联网刚刚兴起时，仅仅是花一点时间学习HTML，你就可以得到一份薪水丰厚的工作。但是当形势惨淡时，对于技能的要求更高了——HTML程序员（就像搬运工和砖瓦工一样）第一个被抛弃了，而拥有更高技能的程序员则留了下来。</p>
<p>我想说的是： <strong>除非你准备活到老学到老，不然的话，不要进入这个行业！编程看起来似乎是一个高收入而又稳定的工作。但要做到这一点，唯一的途径是：始终让自己更有价值。</strong></p>
<p>当然，你总能找到例外。总有那么一些人，仅仅学了一门编程语言，就可以胜任留在一个岗位上，而不需要增长他的技能。但他们只是幸免于难而已，他们最终无疑是很脆弱的。为了不让自己变得脆弱，你需要持续的提高自己，通过阅读、加入用户组、参加研讨会…… <strong>你学得越深入，你就越有价值，也就意味着你有更好的职业前景，可以配得上更高的薪水。</strong></p>
<p>另 一个方法是：先大致地了解这个领域，找到最适合你的地方。打个比方：我的兄弟对软件很感兴趣，也进入了这个行业，但他的工作是安装、维修、升级电脑。他总 是一丝不苟，所以当他把电脑搞好，一定会很完美——不只只是软件，连电线都会被仔细地捆好。他总是生意兴隆，远远超出他的精力所能及。他甚至都不用担心 .com 泡沫的崩溃。显然他的饭碗不容易被抢走。</p>
<p>我在高校里待了很久，甚至还在UCLA（加州大学洛杉矶分校）开始进修博士学位，后来 又幸运地终止了。我说“幸运”是因为我不再喜欢呆在学校，而我之前在高校待了那么久，只是因为我很享受它。但我所享受的，基本上是不务正业的东西——艺术 和舞蹈课，在校报工作，还有一小撮计算机课程（之所以说计算机课程“不务正业”，是因为我本科是物理专业，研究生才是计算机专业）。虽然我在学术上远谈不 上卓越（有意思的是很多当时也许不会接受我这个学生的学校现在却用我的书做教材）。我真的很享受作为学生的日子，当我完成博士课程，也许会以一个教授的身 份终老一生。</p>
<p>但就如现在看到的，我在学校里最大的收获恰恰来自我那些“不务正业”的课程，它们拓展了我的思维，使之超越了“我们已经知道 的东西”。在计算机领域中，你总是为某种目标而编程。你对目标了解得越多，你就做得越好。我遇到过一些欧洲的研究生，他们需要结合其它专业领域来搞编程， 他们的论文需要解决这个专业领域的特定的问题。</p>
<p><strong>了解编程之外的领域，将会极大得提高你解决问题的能力</strong> （就如同多学几种编程语言将极大地提高你的编程技能）。很多时候，我发现仅仅学习计算机专业的学生，比那些（除了计算机之外）拥有其它背景的学生，在思维上有更多的局限性。因为后者有着更严谨的思维，也不那么容易想当然。</p>
<p>有一次我组织了一次会议，其中一个议题是：理想的应聘者有哪些特征：
◇把学习当成生活方式。比如：你应该知道不止一种语言，没有什么比学习一门新语言更能让你开阔眼界了。
◇知道如何获取知识
◇Study prior art
◇善用工具
◇学会把事情简化
◇理解业务
◇为自己的错误负责。“我就是这样的”是不能接受的托词。能找到自己的失误。
◇成为一个领导者，善于沟通和激励。
◇搞清楚你在为谁服务
◇没有绝对正确的答案（更好的方法总是存在的）。展示并讨论你的代码，不要带着感情因素——你的代码并不等于你本人。
◇明白完美是渐进的</p>
<p>要 尝试一些冒险的事情——尤其是那些令人害怕的冒险。当你尝试之后，将体会到出乎意料的兴奋。（在冒险的过程中）最好不要刻意去计划某个特定的结果。当你过 于注重结果，你往往会错过那些真正有价值的问题。我的冒险往往是这样开始的——“我们先做些试验，看看它会把我们带到什么地方”。</p>
<p>或许某 些人会对我的回答感到失望，并回复我说：“是的，这很有趣也很有用。但我到底应该学什么？C++还是Java？” 我再重复一次：并不是所有的问题都有一个唯一的简单的答案。问题的关键不在于选择某个编程语言，然后掌握之。问题的关键在于：持续学习，并且很多时候，有 不止一个选择。相信我所说的，你的生活会更精彩！</p>
<p>洋文原始出处：
<a href="http://www.artima.com/weblogs/viewpost.jsp?thread=259358" target="_blank"><a href="http://www.artima.com/weblogs/viewpost.jsp?thread=259358">http://www.artima.com/weblogs/viewpost.jsp?thread=259358</a></a>
来源： <a href="[http://www.rootsir.com/transshipment/2012/709.html](http://www.rootsir.com/transshipment/2012/709.html)">[http://www.rootsir.com/transshipment/2012/709.html](http://www.rootsir.com/transshipment/2012/709.html)</a> </p>
]]></content>
    
    
      <category term="好文摘录" scheme="http://itsolife.com/categories/%E5%A5%BD%E6%96%87%E6%91%98%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[程序算法与人生选择]]></title>
    <link href="http://itsolife.com/2014/02/03/2014-02-03--%E7%A8%8B%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B8%8E%E4%BA%BA%E7%94%9F%E9%80%89%E6%8B%A9/"/>
    <id>http://itsolife.com/2014/02/03/2014-02-03--程序算法与人生选择/</id>
    <published>2014-02-03T03:24:29.000Z</published>
    <updated>2014-03-07T03:24:29.000Z</updated>
    <content type="html"><![CDATA[<h1 id="-">程序算法与人生选择</h1>
<p><a href="&quot;把这个链接拖到你的Chrome收藏夹工具栏中&quot;">High一下!</a></p>
<h1 id="-coolshell-cn-http-coolshell-cn-"><a href="http://coolshell.cn/" target="_blank">酷壳 – CoolShell.cn</a></h1>
<p>享受编程和技术所带来的快乐 – <a href="http://coolshell.cn" target="_blank">http://coolshell.cn</a></p>
<ul>
<li><a href="http://coolshell.cn/" title="首页" target="_blank">首页</a></li>
<li><a href="http://coolshell.cn/featured_posts" target="_blank">推荐文章</a></li>
<li><a href="http://coolshell.cn/plugins" target="_blank">本站插件</a></li>
<li><a href="http://coolshell.cn/guestbook" target="_blank">留言小本</a></li>
<li><a href="http://coolshell.cn/about" target="_blank">关于酷壳</a></li>
<li><a href="http://coolshell.cn/haoel" target="_blank">关于陈皓</a></li>
<li><a href=""></a>
<a href="http://coolshell.cn/" title="转到首页" target="_blank">首页</a> &gt; <a href="http://coolshell.cn/category/misc" title="查看 杂项资源 中的全部文章" target="_blank">杂项资源</a> &gt; 程序算法与人生选择</li>
</ul>
<h2 id="-">程序算法与人生选择</h2>
<p>2012年12月28日 <a href="http://coolshell.cn/articles/author/haoel" title="由 陈皓 发布" target="_blank">陈皓</a> <a href="">发表评论</a> <a href="">阅读评论</a> 63,218 人阅读    </p>
<p><img src="" alt="">每年一到要找工作的时候，我就能收到很多人给我发来的邮件，总是问我怎么选择他们的offer，去腾讯还是去豆瓣，去外企还是去国内的企业，去创业还是去考研，来北京还是回老家，该不该去创新工场？该不该去thoughtworks？……等等，等等。今年从7月份到现在，我收到并回复了60多封这样的邮件。我更多帮他们整理思路，帮他们明白自己最想要的是什么。（注：我以后不再回复类似的邮件了）。</p>
<p>我深深地发现，对于我国这样从小被父母和老师安排各种事情长大的人，当有一天，父母和老师都跟不上的时候，我们几乎完全不知道怎么去做选择。而我最近也离开了亚马逊，换了一个工作。又正值年底，就像去年的那篇《<a href="http://coolshell.cn/articles/6142.html" title="三个事和三个问题" target="_blank">三个故事和三个问题</a>》一样，让我想到写一篇这样的文章。</p>
<h3 id="-">几个例子</h3>
<p>当我们在面对各种对选择的影响因子的时候，如：城市，公司规模，公司性质，薪水，项目，户口，技术，方向，眼界…… 你总会发现，你会在几个公司中纠结一些东西，举几个例子：</p>
<ul>
<li><p>某网友和我说，他们去上海腾讯，因为腾讯的规模很大，但却发现薪水待遇没有豆瓣高（低的还不是一点），如果以后要换工作的话，起薪点直接关系到了以后的高工资。我说那就去豆瓣吧，他说豆瓣在北京，污染那么严重，又没有户口，生存环境不好。我说去腾讯吧，他说腾讯最近组织调整，不稳定。我说那就去豆瓣吧，慢公司，发展很稳当。他说，豆瓣的盈利不清楚，而且用Python，自己不喜欢。我说，那就去腾讯吧，……</p>
</li>
<li><p>还有一网友和我说，他想回老家，因为老家的人脉关系比较好，能混得好。但又想留在大城市，因为大城市可以开眼界。</p>
</li>
<li><p>另一网友和我说，他想进外企，练练英语，开开眼界，但是又怕在外企里当个螺丝钉，想法得不到实施。朋友拉他去创业，觉得创业挺好的，锻炼大，但是朋友做的那个不知道能不能做好。</p>
</li>
<li><p>还有一网友在创新工场的某团队和考研之间抉择，不知道去创新工场行不行，觉得那个项目一般，但是感觉那个团队挺有激情的，另一方面觉得自己的学历还不够，读个研应该能找到更好的工作。</p>
</li>
<li><p>还有一些朋友问题我应该学什么技术？不应该学什么技术？或是怎么学会学得最快，技术的路径应该是什么？有的说只做后端不做前端，有的说，只做算法研究，不做工程，等等，等等。因为他们觉得人生有限，术业有专攻。</p>
</li>
<li><p>等等，等等……</p>
</li>
</ul>
<p>我个人觉得，如果是非计算机科班出生的人不会做选择，不知道怎么走也罢了，但是我们计算机科班出生的人是学过算法的，<strong>懂算法的人应该是知道怎么做选择的</strong>。</p>
<h2 id="-">#</h2>
<h3 id="-">排序算法</h3>
<p>你不可能要所有的东西，所以你只能要你最重要的东西，你要知道什么东西最重要，你就需要对你心内的那些欲望和抱负有清楚的认识，不然，你就会在纠结中度过。</p>
<p>所以，在选择中纠结的人有必要参考一下排序算法。</p>
<ul>
<li><p>首先，你最需要参考的就是“冒泡排序”——这种算法的思路就是每次冒泡出一个最大的数。所以，你有必要问问你自己，面对那些影响你选择的因子，如果你只能要一个的话，你会要哪个？而剩下的都可以放弃。于是，当你把最大的数，一个一个冒泡出来的时候，并用这个决策因子来过滤选项的时候，你就能比较容易地知道知道你应该选什么了。<strong>这个算法告诉我们，人的杂念越少，就越容易做出选择。</strong></p>
</li>
<li><p>好吧，可能你已茫然到了怎么比较两个决策因子的大小，比如：你分不清楚，工资&gt;业务前景吗？业务前景&gt;能力提升吗？所以你完全没有办法进行冒泡法。那你，你不妨参考一个“快速排序”的思路——这个算法告诉我们，我们一开始并不需要找到最大的数，我们只需要把你价值观中的某个标准拿出来，然后，把可以满足这个价值的放到右边，不能的放到左边去。比如，你的标准是：工资大于5000元&amp;&amp;业务前景长于3年的公司，你可以用这个标准来过滤你的选项。然后，你可以再调整这个标准再继续递归下去。<strong>这个算法告诉我们，我们的选择标准越清晰，我们就越容易做出选择</strong>。</p>
</li>
</ul>
<p>这是排序算法中最经典的两个算法了，面试必考。相信你已烂熟于心中了。所以，我觉得你把这个算法应用于你的人生选择也应该不是什么问题。关于在于，你是否知道自己想要的是什么？</p>
<p>排序算法的核心思想就是，<strong>让你帮助你认清自己最需要的是什么，认清自己最想要的是什么，然后根据这个去做选择</strong>。</p>
<h3 id="-">贪婪算法</h3>
<p>所谓贪婪算法，是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择（注意：是当前状态下），从而希望导致结果是最好或最优的算法。贪婪算法最经典的一个例子就是<a href="http://coolshell.cn/articles/7459.html" title="Huffman 编码压缩算法" target="_blank">哈夫曼编码</a>。</p>
<p>对于人类来说，一般人在行为处事的时候都会使用到贪婪算法，</p>
<ul>
<li><p>比如在找零钱的时候，如果要找补36元，我们一般会按这样的顺序找钱：20元，10元，5元，1元。</p>
</li>
<li><p>或者我们在过十字路口的时候，要从到对角线的那个街区时，我们也会使用贪婪算法——哪边的绿灯先亮了我们就先过到那边去，然后再转身90度等红灯再过街。</p>
</li>
</ul>
<p>这样的例子有很多。对于选择中，大多数人都会选用贪婪算法，因为这是一个比较简单的算法，未来太复杂了，只能走一步看一步，在当前的状况下做出最利于自己的判断和选择即可。</p>
<p>有的人会贪婪薪水，有的人会贪婪做的项目，有的人会贪婪业务，有的人会贪婪职位，有的人会贪婪自己的兴趣……这些都没什么问题。贪婪算法并没有错，虽然不是全局最优解，但其可以让你找到局部最优解或是次优解。其实，有次优解也不错了。<strong>贪婪算法基本上是一种急功近利的算法，但是并不代表这种算法不好，如果贪婪的是一种长远和持续，又未尝不可呢？</strong>。</p>
<h3 id="-">动态规划</h3>
<p>但是我们知道，对于大部分的问题，贪婪法通常都不能找出最优解，因为他们一般没有测试所有可能的解。<strong>因为贪婪算法是一种短视的行为，只会跟据当前的形式做判断，也就是过早做决定</strong>，因而没法达到最佳解。</p>
<p>动态规划和贪婪算法的最大不同是，贪婪算法做出选择，不能回退。动态规划则会保存以前的运算结果，并根据以前的结果对当前进行选择，有回退功能。</p>
<p>动态规划算法至少告诉我们两个事：</p>
<p>1）<strong>承前启后非常重要，</strong>当你准备去做遍历的时候，你的上次的经历不但能开启你以后的经历，而且还能为后面的经历所用。你的每一步都没有浪费。</p>
<p>2）<strong>是否可以回退也很重要</strong>。这意思是——如果你面前有两个选择，一个是A公司一个是B公司，如果今天你错失了B公司，那到你明天还能不能找回来？</p>
<p>比如说：你有两个offer，一个是Yahoo，一个是Baidu，上述的第一点会让我们思考，Yahoo和Baidu谁能给我们开启更大的平台？上述的第二点告诉我们，是进入Yahoo后如果没有选好，是否还能回退到Baidu公司？还是进入Baidu公司后能容易回退到Yahoo公司？</p>
<h3 id="-dijkstra-"><strong>Dijkstra</strong>最短路径</h3>
<p>最短路径是一个Greedy + DP的算法。相当经典。这个算法的大意如下：</p>
<p>1）在初始化的时候，所有的结点都和我是无穷大，默认是达不到的。</p>
<p>2）从离自己最近的结点开始贪婪。</p>
<p>3）走过去，看看又能到达什么样的结点，计算并更新到所有目标点的距离。</p>
<p>4）再贪婪与原点最短的结点，如此反复。</p>
<p>这个算法给我们带来了一些这样的启示：</p>
<ul>
<li><p>有朋友和我说过他想成为一个架构师，或是某技术领域的专家，并会踏踏实实的向这个目标前进，永不放弃。我还是鼓励了他，但我也告诉他了这个著名的算法，我说，这个算法告诉你，架构师或某领域的专家对你来说目前的距离是无穷大，他们放在心中，先看看你能够得着的东西。<strong>所谓踏实，并不是踏踏实实追求你的目标，而是踏踏实实把你够得着看得见的就在身边的东西干好。</strong>我还记得我刚参加工作，从老家出来的时候，从来没有想过要成为一个技术牛人，也从来没有想过我的博客会那么的有影响力，在做自己力所能及，看得见摸得着的事情，我就看见什么技术就学什么，学着学着就知道怎么学更轻松，怎么学更扎实，这也许就是我的最短路径。</p>
</li>
<li><p>有很多朋友问我要不要学C++，或是问我学Python还是学Ruby，是不是不用学前端，等等。这些朋友告诉我，他们不可能学习多个语言，学了不用也就忘了，而且术业有专攻。这并没有什么不对的，只是我个人觉得，学习一个东西没有必要只有两种状态，一种是不学，另一种是精通。了解一个技术其实花不了多少时间，我学C++的目的其实是为了更懂Java，学TCP/IP协议其实是为了更懂Socket编程，很多东西都是连通和相辅相成的，学好了C/C++/Unix/TCP等这些基础技术后，我发现到达别的技术路径一下缩短了（这就是为什么<a href="http://coolshell.cn/articles/8489.html" title="Go 语言简介（下）— 特性" target="_blank">我用两天时间就可以了解Go语言的原因</a>）。<strong>这就好像这个算法一样，算法效率不高，也许达到你的目标，你在一开始花了很长时间，遍历了很多地方，但是，这也许这就是你的最短路径</strong>。</p>
</li>
</ul>
<h3 id="-trade-off">算法就是Trade-Off</h3>
<p>你根本没有办法能得到所有你想得到的东西，<strong>任何的选择都意味着放弃</strong>——<strong>当你要去获得一个东西的时候，你总是需要放弃一些东西</strong>。<strong>人生本来就是一个跷跷板，一头上，另一头必然下</strong>。这和我们做软件设计或算法设计一样，用时间换空间，用空间换时间，还有CAP理论，总是有很多的Trade-Off，正如这个短语的原意一样——<strong>你总是要用某种东西去交易某种东西</strong>。</p>
<p>我们都在用某种东西在交易我们的未来，有的人用自己的努力，有的人用自己的思考，有的人用自己的年轻，有的人用自己的自由，有的人用自己的价值观，有的人用自己的道德…… …… 有的人在交换金钱，有的人在交换眼界，有的人在交换经历，有的人在交换地位，有的人在交换能力，有的人在交换自由，有的人在交换兴趣，有的人在交换虚荣心，在交换安逸享乐…… ……</p>
<p><strong>每个人有每个人的算法，每个算法都有每个算法的purpose，就算大家在用同样的算法，但是每个人算法中的那些变量、开关和条件都不一样，得到的结果也不一样。我们就是生活在Matrix里的一段程序，我们每个人的算法决定着我们每个人的选择，我们的选择决定了我们的人生</strong>。</p>
<p><strong>2012年就要过去了，祝大家新年快乐！</strong>
<img src="" alt="插图来自电影 Life of Pi"></p>
<p>插图来自电影 Life of Pi</p>
<p>（全文完）</p>
<p><strong>（转载本站文章请注明作者和出处 <a href="http://coolshell.cn/" target="_blank">酷壳 – CoolShell.cn</a> ，请勿用于任何商业用途）</strong></p>
<p>——=== <strong>访问 <a href="http://coolshell.cn/404/" target="_blank">酷壳404页面</a> 以支持公益事业</strong> ===——
<a href="&quot;分享到新浪微博&quot;"></a><a href="&quot;分享到腾讯微博&quot;"></a><a href="&quot;分享到搜狐微博&quot;"></a><a href="&quot;分享到网易微博&quot;"></a><a href="&quot;分享到豆瓣&quot;"></a><a href="&quot;分享到人人网&quot;"></a><a href=""></a><a href="&quot;分享到饭否&quot;"></a><a href="&quot;分享到Twitter&quot;"></a><a href="&quot;分享到Facebook&quot;"></a><a href="&quot;分享到Gmail邮箱&quot;"></a><a href="&quot;分享到LinkedIn&quot;"></a><a href="&quot;分享到FriendFeed&quot;"></a><a href="&quot;分享到Digg&quot;"></a><a href="http://www.jiathis.com/share?uid=1541368" target="_blank"></a><a href="">573</a>
分类: <a href="http://coolshell.cn/category/misc" title="查看 杂项资源 中的全部文章" target="_blank">杂项资源</a> 标签: <a href="http://coolshell.cn/tag/algorithm" target="_blank">Algorithm</a>, <a href="http://coolshell.cn/tag/job" target="_blank">Job</a>, <a href="http://coolshell.cn/tag/programmer" target="_blank">Programmer</a>, <a href="http://coolshell.cn/tag/%e7%a8%8b%e5%ba%8f%e5%91%98" target="_blank">程序员</a></p>
<p><img src="&quot;好烂啊&quot;" alt="好烂啊"><img src="&quot;有点差&quot;" alt="有点差"><img src="&quot;凑合看看&quot;" alt="凑合看看"><img src="&quot;还不错&quot;" alt="还不错"><img src="&quot;很精彩&quot;" alt="很精彩"> (<strong>111</strong> 人打了分，平均分： <strong>4.94</strong> )
<img src="&quot;Loading ...&quot;" alt="Loading ..."> Loading ...</p>
<h3 id="-">相关文章</h3>
<ul>
<li>2012年08月22日 -- <a href="http://coolshell.cn/articles/8138.html" target="_blank">为什么我反对纯算法面试题</a></li>
<li>2012年04月17日 -- <a href="http://coolshell.cn/articles/7048.html" target="_blank">挑战无处不在</a></li>
<li>2011年12月20日 -- <a href="http://coolshell.cn/articles/6142.html" target="_blank">三个事和三个问题</a></li>
<li>2010年10月26日 -- <a href="http://coolshell.cn/articles/3231.html" target="_blank">你和你的工作</a></li>
<li>2012年04月11日 -- <a href="http://coolshell.cn/articles/6994.html" target="_blank">我们需要专职的QA吗？</a></li>
<li>2012年08月27日 -- <a href="http://coolshell.cn/articles/8170.html" target="_blank">一次Ajax查错的经历</a></li>
<li>2012年08月16日 -- <a href="http://coolshell.cn/articles/8088.html" target="_blank">对技术的态度</a></li>
<li>2012年04月19日 -- <a href="http://coolshell.cn/articles/7126.html" target="_blank">这到底是谁之错？</a>
<a href="http://www.zemanta.com/?wp-related-posts" target="_blank">Zemanta</a></li>
</ul>
<p><a href="">评论 (168)</a> <a href="">Trackbacks (12)</a> <a href="">发表评论</a> <a href="http://coolshell.cn/articles/8790.html/trackback" target="_blank">Trackback</a></p>
<ol>
<li><img src="" alt=""></li>
</ol>
<p>qte</p>
<p>2013年2月18日23:20 | <a href="">/#1</a></p>
<p><a href="">回复</a> | <a href="">引用</a>
想了下，DP也说得通，抱歉打搅了<a href="">@sigh1988</a></p>
<ol>
<li><img src="" alt=""></li>
</ol>
<p>lanxzh</p>
<p>2013年2月20日10:31 | <a href="">/#2</a></p>
<p><a href="">回复</a> | <a href="">引用</a>
写得作者切身经历的体会和感受，非常好!</p>
<ol>
<li><img src="" alt=""></li>
</ol>
<p>jpbai</p>
<p>2013年2月20日16:57 | <a href="">/#3</a></p>
<p><a href="">回复</a> | <a href="">引用</a>
身在其中的时候经常会表现得浮躁</p>
<ol>
<li><img src="" alt=""></li>
</ol>
<p>FansUnion</p>
<p>2013年2月25日16:41 | <a href="">/#4</a></p>
<p><a href="">回复</a> | <a href="">引用</a>
非常经典啊!</p>
<p>使用几种经典的算法，回答了 若干人的提问-困惑-纠结。</p>
<p>赞！</p>
<ol>
<li><img src="" alt=""></li>
</ol>
<p>sam wu</p>
<p>2013年2月27日14:29 | <a href="">/#5</a></p>
<p><a href="">回复</a> | <a href="">引用</a>
蛮好的文章，很多人面临这些问题。</p>
<ol>
<li><img src="" alt=""></li>
</ol>
<p>LEo</p>
<p>2013年2月27日21:15 | <a href="">/#6</a></p>
<p><a href="">回复</a> | <a href="">引用</a>
看看这些，我自己觉得好讽刺。我现在连一个机会都没有。难道我只好去参加那些培训吗？</p>
<ol>
<li><img src="" alt=""></li>
</ol>
<p><a href="http://www.cnblogs.com/effort0209/" target="_blank">effort</a></p>
<p>2013年3月24日17:55 | <a href="">/#7</a></p>
<p><a href="">回复</a> | <a href="">引用</a>
说的不错，比喻恰当，追求时间舍不得空间，怀拥空间，又惦念着时间，可能真正的茫然是：我们不知道想要什么，总觉得一切东西放到一起时总会有平衡点，当寻求平衡点时，又忘记了我们自己，空耗了精力…..</p>
<ol>
<li><img src="" alt=""></li>
</ol>
<p>tamalegebi</p>
<p>2013年4月2日15:34 | <a href="">/#8</a></p>
<p><a href="">回复</a> | <a href="">引用</a>
完全看不懂算法和人生有啥直接关系，到时那个和网友的扯淡很有意思</p>
<ol>
<li><img src="" alt=""></li>
</ol>
<p>sunny鮟</p>
<p>2013年4月2日22:23 | <a href="">/#9</a></p>
<p><a href="">回复</a> | <a href="">引用</a>
越看越有意思,一个不喜欢自己专业而喜欢搞搞计算机但又完全不会计算机而苦恼的在自学了一段时间之后好像没学一样的大二学生看完表示,还是不知道未来的路在何方……..</p>
<ol>
<li><img src="" alt=""></li>
</ol>
<p><a href="http://lq2419.blog.51cto.com/" target="_blank">呼伦贝尔</a></p>
<p>2013年4月12日21:08 | <a href="">/#10</a></p>
<p><a href="">回复</a> | <a href="">引用</a>
以前忘记在哪看到过这篇文章，觉得这篇不错，现在在你博客里看到，果断转载了。</p>
<ol>
<li><img src="" alt=""></li>
</ol>
<p>linwkr</p>
<p>2013年5月1日18:46 | <a href="">/#11</a></p>
<p><a href="">回复</a> | <a href="">引用</a>
学习了。。。
从自己的领域对人生的思考:每个人都有每个人的算法</p>
<ol>
<li><img src="" alt=""></li>
</ol>
<p>it_liao</p>
<p>2013年5月6日00:19 | <a href="">/#12</a></p>
<p><a href="">回复</a> | <a href="">引用</a>
写得非常棒，要顶~</p>
<ol>
<li><img src="" alt=""></li>
</ol>
<p>IT熊猫</p>
<p>2013年6月21日18:31 | <a href="">/#13</a></p>
<p><a href="">回复</a> | <a href="">引用</a>
好形象哇，好明白哇，看完这我就知道那些 把简单事说得那么复杂的 “大师” 们是多么贱了。
皓哥你的确很高啊，既让我明白了算法的原理，又有点人生感悟的意思，不愧是高手哇。
以后多写点这样的文章啊，不必非得人生感悟哇，把技术知识点形象话就很造福啦。</p>
<ol>
<li><img src="" alt=""></li>
</ol>
<p>kunpengku</p>
<p>2013年6月21日21:00 | <a href="">/#14</a></p>
<p><a href="">回复</a> | <a href="">引用</a>
文章写的非常好，关于算法和人生的结合。</p>
<ol>
<li><img src="" alt=""></li>
</ol>
<p><a href="http://my.oschina.net/nicefan" target="_blank">Fan.Action</a></p>
<p>2013年6月28日16:23 | <a href="">/#15</a></p>
<p><a href="">回复</a> | <a href="">引用</a>
很受启发，很好文章，很受启发！</p>
<ol>
<li><img src="" alt=""></li>
</ol>
<p><a href="http://blog.csdn.net/mxdlove00" target="_blank">大灰狼</a></p>
<p>2013年7月2日12:47 | <a href="">/#16</a></p>
<p><a href="">回复</a> | <a href="">引用</a>
楼主这样的才算是真正的活学活用啊，我感觉我的算法白学了。楼主的这种抽象思维值得学习！</p>
<ol>
<li><img src="" alt=""></li>
</ol>
<p>呢喃的猫咪</p>
<p>2013年7月12日10:47 | <a href="">/#17</a></p>
<p><a href="">回复</a> | <a href="">引用</a>
我是在其他地方看到这篇文章，然后追过来的。
我很喜欢算法，但很遗憾我不懂算法，唯一值得庆幸的是，大学里学的数学专业，现在也算在做编程的工作。文章的的几种算法，每一种几乎都是我大学里地一门专业课。
把对算法的理解融入到人生和职场，才能引发程序员们的共鸣啊。对大部分程序员来说，图片和语言很多时候都显得很苍白无力，很多人都不屑于去看文字去读文字，有时候我也会觉得看那么多废话不如多看多写两行代码来的实在，只是，偶尔真的需要停下来思考思考。这篇从程序员的视角切入的感悟，才能真正引人深思啊。</p>
<ol>
<li><img src="" alt=""></li>
</ol>
<p>呢喃的猫咪</p>
<p>2013年7月12日11:11 | <a href="">/#18</a></p>
<p><a href="">回复</a> | <a href="">引用</a>
算法效率不高，也许达到你的目标，你在一开始花了很长时间，遍历了很多地方，但是，这也许这就是你的最短路径。</p>
<p>我最认可的一句话，因为我终于明白为什么在所有的否定之下我仍然能坚持自己所做之事。我一直相信，也许我现在做的对目前而言不是最优的，但一定是离初始目的最近的。
评论分页</p>
<p><a href="http://coolshell.cn/articles/8790.html/comment-page-3#comments" target="_blank">« 上一页</a> <a href="http://coolshell.cn/articles/8790.html/comment-page-1#comments" target="_blank">1</a> <a href="http://coolshell.cn/articles/8790.html/comment-page-2#comments" target="_blank">2</a> <a href="http://coolshell.cn/articles/8790.html/comment-page-3#comments" target="_blank">3</a> 4 8790</p>
<ol>
<li>2012年12月29日23:14 | <a href="">/#1</a></li>
</ol>
<p><a href="http://argcandargv.com/archives/936" target="_blank">程序算法与人生选择 | argc &amp;&amp; argv</a></p>
<ol>
<li>2012年12月30日20:05 | <a href="">/#2</a></li>
</ol>
<p><a href="http://binary.duapp.com/2012/12/972.html" target="_blank">程序算法与人生选择 | 蜗牛都知道</a></p>
<ol>
<li>2013年1月2日09:23 | <a href="">/#3</a></li>
</ol>
<p><a href="http://www.coderli.com/%e7%a8%8b%e5%ba%8f%e7%ae%97%e6%b3%95%e4%b8%8e%e4%ba%ba%e7%94%9f%e9%80%89%e6%8b%a9" target="_blank">程序算法与人生选择 | OneCoder</a></p>
<ol>
<li>2013年1月5日10:29 | <a href="">/#4</a></li>
</ol>
<p><a href="http://php8848.com/3620.html" target="_blank">我所看到的那些博主的2012年工作总结 | 高度PHP</a></p>
<ol>
<li>2013年1月5日10:45 | <a href="">/#5</a></li>
</ol>
<p><a href="http://g00.asia/2013/01/94.html" target="_blank">程序算法与人生选择 | grace自留地</a></p>
<ol>
<li>2013年1月7日16:01 | <a href="">/#6</a></li>
</ol>
<p><a href="http://www.67tgb.com/?p=532" target="_blank">望月听涛 » 2012年度工作总结</a></p>
<ol>
<li>2013年1月7日16:18 | <a href="">/#7</a></li>
</ol>
<p><a href="http://architecture.riaos.com/?p=3017963" target="_blank">2012年度工作总结 | 架构（architecture.riaos.com）</a></p>
<ol>
<li>2013年2月23日22:28 | <a href="">/#8</a></li>
</ol>
<p><a href="http://sirx.wordpress.com.cn/2013/02/23/%e7%a8%8b%e5%ba%8f%e7%ae%97%e6%b3%95%e4%b8%8e%e4%ba%ba%e7%94%9f%e9%80%89%e6%8b%a9z/" target="_blank">程序算法与人生选择[z] » 笑笑先生</a></p>
<ol>
<li>2013年4月10日15:35 | <a href="">/#9</a></li>
</ol>
<p><a href="http://codingke.sinaapp.com/?p=4" target="_blank">Codingke-左手代码右手湿 » 《Rework》摘录及感想</a></p>
<ol>
<li>2013年4月12日14:44 | <a href="">/#10</a></li>
</ol>
<p><a href="http://codingke.sinaapp.com/?p=42" target="_blank">Codingke-编程疯子 » 《Rework》摘录及感想</a></p>
<ol>
<li>2013年4月20日09:49 | <a href="">/#11</a></li>
</ol>
<p><a href="http://www.ruanfei.com/news/archives/77" target="_blank">一个程序员对《Rework》的摘录及感想 – 软飞</a></p>
<ol>
<li>2013年5月15日15:19 | <a href="">/#12</a></li>
</ol>
<p><a href="http://www.w3c.com.cn/%e7%a8%8b%e5%ba%8f%e7%ae%97%e6%b3%95%e4%b8%8e%e4%ba%ba%e7%94%9f%e9%80%89%e6%8b%a9" target="_blank">程序算法与人生选择 – Sina App Engine – 开发者问答</a>
昵称 (必填)</p>
<p>电子邮箱 (我们会为您保密) (必填)
网址</p>
<p><a href="http://coolshell.cn/comments/feed" target="_blank">订阅评论</a></p>
<p><a href="http://coolshell.cn/articles/8883.html" target="_blank">应该知道的Linux技巧</a> <a href="http://coolshell.cn/articles/8767.html" target="_blank">Web工程师的工具箱</a></p>
<p><a href="http://coolshell.cn/feed" title="订阅这个博客的文章" target="_blank">订阅</a></p>
<ul>
<li><a href="http://fusion.google.com/add?feedurl=http://coolshell.cn/feed" title="订阅到 Google" target="_blank">Google</a></li>
<li><a href="http://reader.youdao.com/#url=http://coolshell.cn/feed" title="订阅到有道" target="_blank">有道</a></li>
<li><a href="http://www.xianguo.com/subscribe.php?url=http://coolshell.cn/feed" title="订阅到鲜果" target="_blank">鲜果</a></li>
<li><a href="http://www.zhuaxia.com/add_channel.php?url=http://coolshell.cn/feed" title="订阅到抓虾" target="_blank">抓虾</a></li>
<li><a href="http://add.my.yahoo.com/rss?url=http://coolshell.cn/feed" title="订阅到 My Yahoo!" target="_blank">My Yahoo!</a></li>
<li><a href="http://www.newsgator.com/ngs/subscriber/subfext.aspx?url=http://coolshell.cn/feed" title="订阅到 newsgator" target="_blank">newsgator</a></li>
<li><a href="http://www.bloglines.com/sub/http://coolshell.cn/feed" title="订阅到 Bloglines" target="_blank">Bloglines</a></li>
<li><a href="http://inezha.com/add?url=http://coolshell.cn/feed" title="订阅到哪吒" target="_blank">哪吒</a></li>
<li><a href="http://mail.qq.com/cgi-bin/feed?u=http://coolshell.cn/feed" title="订阅到QQ Mail" target="_blank">QQ Mail</a></li>
<li><a href="http://9.douban.com/reader/subscribe?url=http://coolshell.cn/feed" title="订阅到Douban" target="_blank">Douban</a></li>
<li><a href="http://www.rojo.com/add-subscription?resource=http://coolshell.cn/feed" title="订阅到Rojo" target="_blank">Rojo</a></li>
<li><a href="http://www.pageflakes.com/subscribe.aspx?url=http://coolshell.cn/feed" title="订阅到Pageflakes" target="_blank">Pageflakes</a>
<a href="http://twitter.com/haoel/" title="Follow me!" target="_blank">Twitter</a></li>
</ul>
<h3 id="-">本站公告</h3>
<p>访问 <a href="http://coolshell.cn/404/" target="_blank">酷壳404页面</a> 支持公益！</p>
<p>酷壳建议大家多使用RSS访问阅读（本站已经是全文输出，推荐使用cloud.feedly.com）。有相关事宜欢迎电邮：haoel(at)hotmail.com。最后，感谢大家对酷壳的支持和体谅！</p>
<p><strong>感谢 <a href="http://42qu.com/" title="42区 找到给你答案的人" target="_blank">42qu.com</a> 为本站提供 <a href="http://vps.42qu.com/" title="42区虚拟主机，卖给创业的你" target="_blank">VPS</a></strong></p>
<h3 id="-">最新文章</h3>
<ul>
<li><a href="http://coolshell.cn/articles/10217.html" title="加班与效率" target="_blank">加班与效率</a></li>
<li><a href="http://coolshell.cn/articles/10169.html" title="类型的本质和函数式实现" target="_blank">类型的本质和函数式实现</a></li>
<li><a href="http://coolshell.cn/articles/10115.html" title="C语言全局变量那些事儿" target="_blank">C语言全局变量那些事儿</a></li>
<li><a href="http://coolshell.cn/articles/9886.html" title="二叉树迭代器算法" target="_blank">二叉树迭代器算法</a></li>
<li><a href="http://coolshell.cn/articles/9917.html" title="Alan Cox：大教堂、市集与市议会" target="_blank">Alan Cox：大教堂、市集与市议会</a></li>
<li><a href="http://coolshell.cn/articles/9949.html" title="IoC/DIP其实是一种管理思想" target="_blank">IoC/DIP其实是一种管理思想</a></li>
<li><a href="http://coolshell.cn/articles/9859.html" title="Alan Cox：单向链表中prev指针的妙用" target="_blank">Alan Cox：单向链表中prev指针的妙用</a></li>
<li><a href="http://coolshell.cn/articles/9749.html" title="Javascript 装载和执行" target="_blank">Javascript 装载和执行</a></li>
<li><a href="http://coolshell.cn/articles/9703.html" title="无锁HashMap的原理与实现" target="_blank">无锁HashMap的原理与实现</a></li>
<li><a href="http://coolshell.cn/articles/9666.html" title="浏览器的渲染原理简介" target="_blank">浏览器的渲染原理简介</a></li>
<li><a href="http://coolshell.cn/articles/9606.html" title="疫苗：Java HashMap的死循环" target="_blank">疫苗：Java HashMap的死循环</a></li>
<li><a href="http://coolshell.cn/articles/9543.html" title="“C++的数组不支持多态”？" target="_blank">“C++的数组不支持多态”？</a></li>
<li><a href="http://coolshell.cn/articles/9410.html" title="Unix考古记：一个“遗失”的shell" target="_blank">Unix考古记：一个“遗失”的shell</a></li>
<li><a href="http://coolshell.cn/articles/9508.html" title="PFIF网上寻人协议" target="_blank">PFIF网上寻人协议</a></li>
<li><a href="http://coolshell.cn/articles/9308.html" title="“作环保的程序员，从不用百度开始”" target="_blank">“作环保的程序员，从不用百度开始”</a></li>
<li><a href="http://coolshell.cn/articles/9156.html" title="《Rework》摘录及感想" target="_blank">《Rework》摘录及感想</a></li>
<li><a href="http://coolshell.cn/articles/9229.html" title="实例分析Java Class的文件结构" target="_blank">实例分析Java Class的文件结构</a></li>
<li><a href="http://coolshell.cn/articles/9169.html" title="并发框架Disruptor译文" target="_blank">并发框架Disruptor译文</a></li>
<li><a href="http://coolshell.cn/articles/9104.html" title="sed 简明教程" target="_blank">sed 简明教程</a></li>
<li><a href="http://coolshell.cn/articles/9070.html" title="AWK 简明教程" target="_blank">AWK 简明教程</a></li>
<li><a href="http://coolshell.cn/articles/8990.html" title="Linus：利用二级指针删除单向链表" target="_blank">Linus：利用二级指针删除单向链表</a></li>
<li><a href="http://coolshell.cn/articles/8961.html" title="从面向对象的设计模式看软件设计" target="_blank">从面向对象的设计模式看软件设计</a></li>
<li><a href="http://coolshell.cn/articles/8883.html" title="应该知道的Linux技巧" target="_blank">应该知道的Linux技巧</a></li>
<li><a href="http://coolshell.cn/articles/8790.html" title="程序算法与人生选择" target="_blank">程序算法与人生选择</a></li>
<li><a href="http://coolshell.cn/articles/8767.html" title="Web工程师的工具箱" target="_blank">Web工程师的工具箱</a></li>
<li><a href="http://coolshell.cn/articles/8745.html" title="如此理解面向对象编程" target="_blank">如此理解面向对象编程</a></li>
<li><a href="http://coolshell.cn/articles/8711.html" title="程序员疫苗：代码注入" target="_blank">程序员疫苗：代码注入</a></li>
<li><a href="http://coolshell.cn/articles/8619.html" title="你可能不知道的Shell" target="_blank">你可能不知道的Shell</a></li>
<li><a href="http://coolshell.cn/articles/8638.html" title="为什么不能用微信或米聊这类的软件" target="_blank">为什么不能用微信或米聊这类的软件</a></li>
<li><a href="http://coolshell.cn/articles/8593.html" title="如何测试洗牌程序" target="_blank">如何测试洗牌程序</a></li>
</ul>
<h3 id="-">全站热门</h3>
<ul>
<li><a href="http://coolshell.cn/articles/4990.html" title="程序员技术练级攻略 - 312,422 人阅读" target="_blank">程序员技术练级攻略</a></li>
<li><a href="http://coolshell.cn/articles/5426.html" title="简明 Vim 练级攻略 - 234,355 人阅读" target="_blank">简明 Vim 练级攻略</a></li>
<li><a href="http://coolshell.cn/articles/4102.html" title="如何学好C语言 - 117,770 人阅读" target="_blank">如何学好C语言</a></li>
<li><a href="http://coolshell.cn/articles/914.html" title="6个变态的C语言Hello World程序 - 113,320 人阅读" target="_blank">6个变态的C语言Hello World程序</a></li>
<li><a href="http://coolshell.cn/articles/6470.html" title="由12306.cn谈谈网站性能技术 - 93,543 人阅读" target="_blank">由12306.cn谈谈网站性能技术</a></li>
<li><a href="http://coolshell.cn/articles/8883.html" title="应该知道的Linux技巧 - 89,617 人阅读" target="_blank">应该知道的Linux技巧</a></li>
<li><a href="http://coolshell.cn/articles/2250.html" title="“21天教你学会C++” - 89,390 人阅读" target="_blank">“21天教你学会C++”</a></li>
<li><a href="http://coolshell.cn/articles/3549.html" title="Android将允许纯C/C++开发应用 - 88,606 人阅读" target="_blank">Android将允许纯C/C++开发应用</a></li>
<li><a href="http://coolshell.cn/articles/1870.html" title="我是怎么招聘程序员的 - 87,272 人阅读" target="_blank">我是怎么招聘程序员的</a></li>
<li><a href="http://coolshell.cn/articles/7186.html" title="做个环保主义的程序员 - 84,428 人阅读" target="_blank">做个环保主义的程序员</a></li>
<li><a href="http://coolshell.cn/articles/9308.html" title="“作环保的程序员，从不用百度开始” - 80,045 人阅读" target="_blank">“作环保的程序员，从不用百度开始”</a></li>
<li><a href="http://coolshell.cn/articles/7829.html" title="28个Unix/Linux的命令行神器 - 75,080 人阅读" target="_blank">28个Unix/Linux的命令行神器</a></li>
<li><a href="http://coolshell.cn/articles/1391.html" title="编程真难啊 - 70,871 人阅读" target="_blank">编程真难啊</a></li>
<li><a href="http://coolshell.cn/articles/2287.html" title="C++ 程序员自信心曲线图 - 70,709 人阅读" target="_blank">C++ 程序员自信心曲线图</a></li>
<li><a href="http://coolshell.cn/articles/6043.html" title="Web开发中需要了解的东西 - 69,987 人阅读" target="_blank">Web开发中需要了解的东西</a></li>
<li><a href="http://coolshell.cn/articles/5701.html" title="SteveY对Amazon和Google平台的吐槽 - 69,372 人阅读" target="_blank">SteveY对Amazon和Google平台的吐槽</a></li>
<li><a href="http://coolshell.cn/articles/355.html" title="20本最好的Linux免费书籍 - 68,994 人阅读" target="_blank">20本最好的Linux免费书籍</a></li>
<li><a href="http://coolshell.cn/articles/4758.html" title="如何写出无法维护的代码 - 65,186 人阅读" target="_blank">如何写出无法维护的代码</a></li>
<li><a href="http://coolshell.cn/articles/8790.html" title="程序算法与人生选择 - 63,218 人阅读" target="_blank">程序算法与人生选择</a></li>
<li><a href="http://coolshell.cn/articles/2058.html" title="各种流行的编程风格 - 63,082 人阅读" target="_blank">各种流行的编程风格</a></li>
<li><a href="http://coolshell.cn/articles/3008.html" title="Windows编程革命简史 - 61,890 人阅读" target="_blank">Windows编程革命简史</a></li>
<li><a href="http://coolshell.cn/articles/4119.html" title="如何学好C++语言 - 61,778 人阅读" target="_blank">如何学好C++语言</a></li>
<li><a href="http://coolshell.cn/articles/5761.html" title="深入理解C语言 - 61,397 人阅读" target="_blank">深入理解C语言</a></li>
<li><a href="http://coolshell.cn/articles/4429.html" title="面试题：火车运煤问题 - 60,295 人阅读" target="_blank">面试题：火车运煤问题</a></li>
<li><a href="http://coolshell.cn/articles/6142.html" title="三个事和三个问题 - 59,185 人阅读" target="_blank">三个事和三个问题</a></li>
<li><a href="http://coolshell.cn/articles/1695.html" title="别的程序员是怎么读你的简历的 - 57,916 人阅读" target="_blank">别的程序员是怎么读你的简历的</a></li>
<li><a href="http://coolshell.cn/articles/2420.html" title="老手是这样教新手编程的 - 56,712 人阅读" target="_blank">老手是这样教新手编程的</a></li>
<li><a href="http://coolshell.cn/articles/945.html" title="C语言的谜题 - 54,791 人阅读" target="_blank">C语言的谜题</a></li>
<li><a href="http://coolshell.cn/articles/3363.html" title="偷了世界的程序员 - 54,702 人阅读" target="_blank">偷了世界的程序员</a></li>
<li><a href="http://coolshell.cn/articles/4506.html" title="再谈“我是怎么招聘程序员的”（上） - 54,089 人阅读" target="_blank">再谈“我是怎么招聘程序员的”（上）</a><h3 id="-">新浪微博</h3>
</li>
</ul>
<h3 id="-">标签</h3>
<p><a href="http://coolshell.cn/tag/agile" title="15 个话题" target="_blank">agile</a> <a href="http://coolshell.cn/tag/ajax" title="11 个话题" target="_blank">AJAX</a> <a href="http://coolshell.cn/tag/algorithm" title="20 个话题" target="_blank">Algorithm</a> <a href="http://coolshell.cn/tag/android" title="8 个话题" target="_blank">Android</a> <a href="http://coolshell.cn/tag/bash" title="8 个话题" target="_blank">Bash</a> <a href="http://coolshell.cn/tag/c" title="74 个话题" target="_blank">C++</a> <a href="http://coolshell.cn/tag/coding" title="25 个话题" target="_blank">Coding</a> <a href="http://coolshell.cn/tag/css" title="21 个话题" target="_blank">CSS</a> <a href="http://coolshell.cn/tag/database" title="7 个话题" target="_blank">Database</a> <a href="http://coolshell.cn/tag/design" title="17 个话题" target="_blank">Design</a> <a href="http://coolshell.cn/tag/design-pattern" title="8 个话题" target="_blank">design pattern</a> <a href="http://coolshell.cn/tag/ebook" title="15 个话题" target="_blank">ebook</a> <a href="http://coolshell.cn/tag/flash" title="7 个话题" target="_blank">Flash</a> <a href="http://coolshell.cn/tag/game" title="9 个话题" target="_blank">Game</a> <a href="http://coolshell.cn/tag/go" title="9 个话题" target="_blank">Go</a> <a href="http://coolshell.cn/tag/google" title="31 个话题" target="_blank">Google</a> <a href="http://coolshell.cn/tag/html" title="32 个话题" target="_blank">HTML</a> <a href="http://coolshell.cn/tag/ie" title="10 个话题" target="_blank">IE</a> <a href="http://coolshell.cn/tag/java" title="45 个话题" target="_blank">Java</a> <a href="http://coolshell.cn/tag/javascript" title="48 个话题" target="_blank">Javascript</a> <a href="http://coolshell.cn/tag/jquery" title="11 个话题" target="_blank">jQuery</a> <a href="http://coolshell.cn/tag/linux" title="58 个话题" target="_blank">Linux</a> <a href="http://coolshell.cn/tag/mysql" title="7 个话题" target="_blank">MySQL</a> <a href="http://coolshell.cn/tag/oop" title="8 个话题" target="_blank">OOP</a> <a href="http://coolshell.cn/tag/password" title="8 个话题" target="_blank">password</a> <a href="http://coolshell.cn/tag/performance" title="13 个话题" target="_blank">Performance</a> <a href="http://coolshell.cn/tag/php" title="25 个话题" target="_blank">PHP</a> <a href="http://coolshell.cn/tag/programmer" title="88 个话题" target="_blank">Programmer</a> <a href="http://coolshell.cn/tag/programming-language" title="12 个话题" target="_blank">programming language</a> <a href="http://coolshell.cn/tag/puzzle" title="9 个话题" target="_blank">Puzzle</a> <a href="http://coolshell.cn/tag/pythondev" title="27 个话题" target="_blank">Python</a> <a href="http://coolshell.cn/tag/ruby" title="9 个话题" target="_blank">Ruby</a> <a href="http://coolshell.cn/tag/sql" title="10 个话题" target="_blank">SQL</a> <a href="http://coolshell.cn/tag/tdd" title="8 个话题" target="_blank">TDD</a> <a href="http://coolshell.cn/tag/ui" title="12 个话题" target="_blank">UI</a> <a href="http://coolshell.cn/tag/unix" title="31 个话题" target="_blank">Unix</a> <a href="http://coolshell.cn/tag/vim" title="18 个话题" target="_blank">vim</a> <a href="http://coolshell.cn/tag/web" title="35 个话题" target="_blank">Web</a> <a href="http://coolshell.cn/tag/windows" title="17 个话题" target="_blank">Windows</a> <a href="http://coolshell.cn/tag/xml" title="8 个话题" target="_blank">XML</a> <a href="http://coolshell.cn/tag/%e5%8f%a3%e4%bb%a4" title="7 个话题" target="_blank">口令</a> <a href="http://coolshell.cn/tag/%e5%ae%89%e5%85%a8" title="16 个话题" target="_blank">安全</a> <a href="http://coolshell.cn/tag/%e7%a8%8b%e5%ba%8f%e5%91%98" title="88 个话题" target="_blank">程序员</a> <a href="http://coolshell.cn/tag/%e7%ae%97%e6%b3%95" title="9 个话题" target="_blank">算法</a> <a href="http://coolshell.cn/tag/interview" title="14 个话题" target="_blank">面试</a></p>
<h3 id="-">分类目录</h3>
<ul>
<li><a href="http://coolshell.cn/category/proglanguage/dotnet" title="查看 .NET编程 下的所有文章" target="_blank">.NET编程</a> (2)</li>
<li><a href="http://coolshell.cn/category/proglanguage/ajaxdev" title="查看 Ajax开发 下的所有文章" target="_blank">Ajax开发</a> (9)</li>
<li><a href="http://coolshell.cn/category/proglanguage/cplusplus" title="查看 C/C++语言 下的所有文章" target="_blank">C/C++语言</a> (53)</li>
<li><a href="http://coolshell.cn/category/proglanguage/erlang" title="查看 Erlang 下的所有文章" target="_blank">Erlang</a> (1)</li>
<li><a href="http://coolshell.cn/category/proglanguage/javadev" title="查看 Java语言 下的所有文章" target="_blank">Java语言</a> (29)</li>
<li><a href="http://coolshell.cn/category/proglanguage/phpdev" title="查看 PHP脚本 下的所有文章" target="_blank">PHP脚本</a> (11)</li>
<li><a href="http://coolshell.cn/category/proglanguage/pythondev" title="查看 Python 下的所有文章" target="_blank">Python</a> (21)</li>
<li><a href="http://coolshell.cn/category/proglanguage/rubydev" title="查看 Ruby 下的所有文章" target="_blank">Ruby</a> (4)</li>
<li><a href="http://coolshell.cn/category/operatingsystem/unixlinux" title="查看 Unix/Linux 下的所有文章" target="_blank">Unix/Linux</a> (66)</li>
<li><a href="http://coolshell.cn/category/proglanguage/webdev" title="查看 Web开发 下的所有文章" target="_blank">Web开发</a> (99)</li>
<li><a href="http://coolshell.cn/category/operatingsystem/mswindows" title="查看 Windows 下的所有文章" target="_blank">Windows</a> (12)</li>
<li><a href="http://coolshell.cn/category/itnews" title="查看 业界新闻 下的所有文章" target="_blank">业界新闻</a> (25)</li>
<li><a href="http://coolshell.cn/category/%e4%bc%81%e4%b8%9a%e5%ba%94%e7%94%a8" title="查看 企业应用 下的所有文章" target="_blank">企业应用</a> (2)</li>
<li><a href="http://coolshell.cn/category/technews" title="查看 技术新闻 下的所有文章" target="_blank">技术新闻</a> (32)</li>
<li><a href="http://coolshell.cn/category/%e6%8a%80%e6%9c%af%e7%ae%a1%e7%90%86" title="查看 技术管理 下的所有文章" target="_blank">技术管理</a> (10)</li>
<li><a href="http://coolshell.cn/category/techarticle" title="查看 技术读物 下的所有文章" target="_blank">技术读物</a> (115)</li>
<li><a href="http://coolshell.cn/category/operatingsystem" title="查看 操作系统 下的所有文章" target="_blank">操作系统</a> (43)</li>
<li><a href="http://coolshell.cn/category/datebase" title="查看 数据库 下的所有文章" target="_blank">数据库</a> (10)</li>
<li><a href="http://coolshell.cn/category/misc" title="查看 杂项资源 下的所有文章" target="_blank">杂项资源</a> (249)</li>
<li><a href="http://coolshell.cn/category/process" title="查看 流程方法 下的所有文章" target="_blank">流程方法</a> (43)</li>
<li><a href="http://coolshell.cn/category/progdesign" title="查看 程序设计 下的所有文章" target="_blank">程序设计</a> (69)</li>
<li><a href="http://coolshell.cn/category/%e7%b3%bb%e7%bb%9f%e6%9e%b6%e6%9e%84" title="查看 系统架构 下的所有文章" target="_blank">系统架构</a> (6)</li>
<li><a href="http://coolshell.cn/category/tools" title="查看 编程工具 下的所有文章" target="_blank">编程工具</a> (61)</li>
<li><a href="http://coolshell.cn/category/proglanguage" title="查看 编程语言 下的所有文章" target="_blank">编程语言</a> (159)</li>
<li><a href="http://coolshell.cn/category/netsecurity" title="查看 网络安全 下的所有文章" target="_blank">网络安全</a> (22)</li>
<li><a href="http://coolshell.cn/category/career" title="查看 职场生涯 下的所有文章" target="_blank">职场生涯</a> (32)</li>
<li><a href="http://coolshell.cn/category/funny" title="查看 趣味问题 下的所有文章" target="_blank">趣味问题</a> (13)</li>
<li><a href="http://coolshell.cn/category/story" title="查看 轶事趣闻 下的所有文章" target="_blank">轶事趣闻</a> (145)</li>
</ul>
<h3 id="-">归档</h3>
<ul>
<li><a href="http://coolshell.cn/articles/date/2013/07" title="2013 年七月" target="_blank">2013 年七月</a> (6)</li>
<li><a href="http://coolshell.cn/articles/date/2013/06" title="2013 年六月" target="_blank">2013 年六月</a> (2)</li>
<li><a href="http://coolshell.cn/articles/date/2013/05" title="2013 年五月" target="_blank">2013 年五月</a> (3)</li>
<li><a href="http://coolshell.cn/articles/date/2013/04" title="2013 年四月" target="_blank">2013 年四月</a> (3)</li>
<li><a href="http://coolshell.cn/articles/date/2013/03" title="2013 年三月" target="_blank">2013 年三月</a> (3)</li>
<li><a href="http://coolshell.cn/articles/date/2013/02" title="2013 年二月" target="_blank">2013 年二月</a> (5)</li>
<li><a href="http://coolshell.cn/articles/date/2013/01" title="2013 年一月" target="_blank">2013 年一月</a> (1)</li>
<li><a href="http://coolshell.cn/articles/date/2012/12" title="2012 年十二月" target="_blank">2012 年十二月</a> (4)</li>
<li><a href="http://coolshell.cn/articles/date/2012/11" title="2012 年十一月" target="_blank">2012 年十一月</a> (5)</li>
<li><a href="http://coolshell.cn/articles/date/2012/10" title="2012 年十月" target="_blank">2012 年十月</a> (3)</li>
<li><a href="http://coolshell.cn/articles/date/2012/09" title="2012 年九月" target="_blank">2012 年九月</a> (4)</li>
<li><a href="http://coolshell.cn/articles/date/2012/08" title="2012 年八月" target="_blank">2012 年八月</a> (8)</li>
<li><a href="http://coolshell.cn/articles/date/2012/07" title="2012 年七月" target="_blank">2012 年七月</a> (4)</li>
<li><a href="http://coolshell.cn/articles/date/2012/06" title="2012 年六月" target="_blank">2012 年六月</a> (7)</li>
<li><a href="http://coolshell.cn/articles/date/2012/05" title="2012 年五月" target="_blank">2012 年五月</a> (6)</li>
<li><a href="http://coolshell.cn/articles/date/2012/04" title="2012 年四月" target="_blank">2012 年四月</a> (6)</li>
<li><a href="http://coolshell.cn/articles/date/2012/03" title="2012 年三月" target="_blank">2012 年三月</a> (6)</li>
<li><a href="http://coolshell.cn/articles/date/2012/02" title="2012 年二月" target="_blank">2012 年二月</a> (3)</li>
<li><a href="http://coolshell.cn/articles/date/2012/01" title="2012 年一月" target="_blank">2012 年一月</a> (6)</li>
<li><a href="http://coolshell.cn/articles/date/2011/12" title="2011 年十二月" target="_blank">2011 年十二月</a> (5)</li>
<li><a href="http://coolshell.cn/articles/date/2011/11" title="2011 年十一月" target="_blank">2011 年十一月</a> (9)</li>
<li><a href="http://coolshell.cn/articles/date/2011/10" title="2011 年十月" target="_blank">2011 年十月</a> (6)</li>
<li><a href="http://coolshell.cn/articles/date/2011/09" title="2011 年九月" target="_blank">2011 年九月</a> (5)</li>
<li><a href="http://coolshell.cn/articles/date/2011/08" title="2011 年八月" target="_blank">2011 年八月</a> (14)</li>
<li><a href="http://coolshell.cn/articles/date/2011/07" title="2011 年七月" target="_blank">2011 年七月</a> (6)</li>
<li><a href="http://coolshell.cn/articles/date/2011/06" title="2011 年六月" target="_blank">2011 年六月</a> (12)</li>
<li><a href="http://coolshell.cn/articles/date/2011/05" title="2011 年五月" target="_blank">2011 年五月</a> (5)</li>
<li><a href="http://coolshell.cn/articles/date/2011/04" title="2011 年四月" target="_blank">2011 年四月</a> (18)</li>
<li><a href="http://coolshell.cn/articles/date/2011/03" title="2011 年三月" target="_blank">2011 年三月</a> (16)</li>
<li><a href="http://coolshell.cn/articles/date/2011/02" title="2011 年二月" target="_blank">2011 年二月</a> (16)</li>
<li><a href="http://coolshell.cn/articles/date/2011/01" title="2011 年一月" target="_blank">2011 年一月</a> (18)</li>
<li><a href="http://coolshell.cn/articles/date/2010/12" title="2010 年十二月" target="_blank">2010 年十二月</a> (11)</li>
<li><a href="http://coolshell.cn/articles/date/2010/11" title="2010 年十一月" target="_blank">2010 年十一月</a> (11)</li>
<li><a href="http://coolshell.cn/articles/date/2010/10" title="2010 年十月" target="_blank">2010 年十月</a> (19)</li>
<li><a href="http://coolshell.cn/articles/date/2010/09" title="2010 年九月" target="_blank">2010 年九月</a> (15)</li>
<li><a href="http://coolshell.cn/articles/date/2010/08" title="2010 年八月" target="_blank">2010 年八月</a> (10)</li>
<li><a href="http://coolshell.cn/articles/date/2010/07" title="2010 年七月" target="_blank">2010 年七月</a> (20)</li>
<li><a href="http://coolshell.cn/articles/date/2010/06" title="2010 年六月" target="_blank">2010 年六月</a> (9)</li>
<li><a href="http://coolshell.cn/articles/date/2010/05" title="2010 年五月" target="_blank">2010 年五月</a> (13)</li>
<li><a href="http://coolshell.cn/articles/date/2010/04" title="2010 年四月" target="_blank">2010 年四月</a> (12)</li>
<li><a href="http://coolshell.cn/articles/date/2010/03" title="2010 年三月" target="_blank">2010 年三月</a> (11)</li>
<li><a href="http://coolshell.cn/articles/date/2010/02" title="2010 年二月" target="_blank">2010 年二月</a> (7)</li>
<li><a href="http://coolshell.cn/articles/date/2010/01" title="2010 年一月" target="_blank">2010 年一月</a> (9)</li>
<li><a href="http://coolshell.cn/articles/date/2009/12" title="2009 年十二月" target="_blank">2009 年十二月</a> (22)</li>
<li><a href="http://coolshell.cn/articles/date/2009/11" title="2009 年十一月" target="_blank">2009 年十一月</a> (27)</li>
<li><a href="http://coolshell.cn/articles/date/2009/10" title="2009 年十月" target="_blank">2009 年十月</a> (17)</li>
<li><a href="http://coolshell.cn/articles/date/2009/09" title="2009 年九月" target="_blank">2009 年九月</a> (15)</li>
<li><a href="http://coolshell.cn/articles/date/2009/08" title="2009 年八月" target="_blank">2009 年八月</a> (21)</li>
<li><a href="http://coolshell.cn/articles/date/2009/07" title="2009 年七月" target="_blank">2009 年七月</a> (18)</li>
<li><a href="http://coolshell.cn/articles/date/2009/06" title="2009 年六月" target="_blank">2009 年六月</a> (19)</li>
<li><a href="http://coolshell.cn/articles/date/2009/05" title="2009 年五月" target="_blank">2009 年五月</a> (27)</li>
<li><a href="http://coolshell.cn/articles/date/2009/04" title="2009 年四月" target="_blank">2009 年四月</a> (53)</li>
<li><p><a href="http://coolshell.cn/articles/date/2009/03" title="2009 年三月" target="_blank">2009 年三月</a> (43)</p>
<h3 id="-">最新评论</h3>
</li>
<li><p><a href="http://coolshell.cn/articles/5132.html#comment-612339" title="疯狂的 Web 应用开源项目, 2011年08月11日" target="_blank">Coffee PUre Cleanse Diet</a>: Hi mates, how is the whole thing, and what you would like to say about this paragraph, in...</p>
</li>
<li><a href="http://coolshell.cn/articles/7186.html#comment-612323" title="做个环保主义的程序员, 2012年04月27日" target="_blank">Small Warm</a>: @呵呵 你认为用baidu就棱不到你吗</li>
<li><a href="http://coolshell.cn/articles/10217.html#comment-612301" title="加班与效率, 2013年07月24日" target="_blank">do</a>: 都是被勤能补拙害的. 天天加班的项目经理不是好程序猿</li>
<li><a href="http://coolshell.cn/articles/10217.html#comment-612246" title="加班与效率, 2013年07月24日" target="_blank">忧郁</a>: 加班没有加班费，是我一生中最大的痛</li>
<li><a href="http://coolshell.cn/guestbook#comment-612169" title="留言小本, 2009年03月02日" target="_blank">李巨宁</a>: 看了博主的几篇心得，觉得博主的语言很有重量，很踏实，实在是让 我获益良多，十分感谢。</li>
<li><a href="http://coolshell.cn/articles/3961.html#comment-612020" title="“火柴棍式”程序员面试题, 2011年03月21日" target="_blank">arrowcj</a>: 不能把i–变成i++么？</li>
<li><a href="http://coolshell.cn/articles/9859.html#comment-611941" title="Alan Cox：单向链表中prev指针的妙用, 2013年06月30日" target="_blank">Yeclipse</a>: The key point has nothing to do with linked list, nor with pre pointer. It just tries to avoid cloning one...</li>
<li><a href="http://coolshell.cn/articles/10217.html#comment-610764" title="加班与效率, 2013年07月24日" target="_blank">ForgetFul</a>: 中国是集体主义国家，其在人数和工作时间上的创造力总能让我惊叹</li>
<li><a href="http://coolshell.cn/articles/21.html#comment-610445" title="101个设计模式, 2009年03月02日" target="_blank">Darlena Failla</a>: First time visit here and have your terrific write-up. May I’ve a copy of the short article?</li>
<li><a href="http://coolshell.cn/articles/2394.html#comment-610430" title="九个PHP很有用的功能, 2010年05月06日" target="_blank">Octavia Vitera</a>: Wonderful collection, many thanks for sharing Eric :)</li>
<li><a href="http://coolshell.cn/articles/8745.html#comment-610422" title="如此理解面向对象编程, 2012年12月13日" target="_blank">Broderick Timmreck</a>: Many thanks for the backlink with podcast.</li>
<li><a href="http://coolshell.cn/articles/2492.html#comment-610416" title="WTF Javascript, 2010年06月02日" target="_blank">Joellen Pekara</a>: Extremely educational thanks, I reckon your current followers may well want even more well written...</li>
<li><a href="http://coolshell.cn/articles/4334.html#comment-610415" title="Eclipse开发Android应用程序入门:重装上阵, 2011年04月08日" target="_blank">Jonah Garvey</a>: I have been reading this blog for just a very good although. Keep up the magnificent job you are doing...</li>
<li><a href="http://coolshell.cn/articles/7992.html#comment-610407" title="C++的坑真的多吗？, 2012年08月06日" target="_blank">Shayla Sturk</a>: Oh and I am not a Liverpool or Chelsea supporter, but the way the Liverpool fans were still singing...</li>
<li><a href="http://coolshell.cn/articles/656.html#comment-610406" title="Linux 的僵尸(zombie)进程, 2009年04月25日" target="_blank">Nevada Riedlinger</a>: good app many thanks for sharing</li>
</ul>
<h3 id="-">友情链接</h3>
<ul>
<li><a href="http://blog.csdn.net/haoel" target="_blank">陈皓的博客</a></li>
<li><a href="http://ifeve.com/" title="促进并发编程的研究和推广" target="_blank">并发编程</a></li>
<li><a href="http://www.raychase.net/" title="一个啰嗦的程序员" target="_blank">四火的唠叨</a></li>
<li><a href="http://www.devtext.com/" title="我们关注互联网、关注软件开发、提供开发技术交流、问答平台" target="_blank">devtext 开发者社区</a></li>
<li><a href="http://claymore.phpme.info/" target="_blank">Claymore&#39;s blog</a></li>
<li><a href="http://www.dutor.net/" target="_blank">Dutor.net</a></li>
<li><a href="http://luy.li/" title="all linux" target="_blank">bones7456</a></li>
<li><a href="http://keeng2008.appspot.com/" title="Keengle&#39;s Blog" target="_blank">Keengle&#39;s Blog</a></li>
<li><a href="http://www.nowamagic.net/" title="专注于互联网主流的各种技术" target="_blank">简明现代魔法</a></li>
<li><a href="http://www.rosoo.net/" title="关注技术更新，关注行业动态。努力做到更好。" target="_blank">罗素工作室</a></li>
<li><a href="http://www.codecho.com/" title="聆听代码的回音" target="_blank">代码回音</a></li>
<li><a href="http://hellogcc.blogbus.com/" title="致力于讨论和学习GNU Toolchain方面的工作组" target="_blank">HelloGcc Working Group</a></li>
<li><a href="http://http://blog.lvscar.info/" title="Just for Fun" target="_blank">吕毅的Blog</a></li>
<li><a href="http://www.cnblogs.com/weidagang2046/" title="Just for Fun" target="_blank">Todd Wei的Blog</a></li>
<li><a href="http://www.cppfans.org/" title="记录我们点滴学习工作生活" target="_blank">C++爱好者博客</a></li>
<li><a href="http://www.mhtml5.com/" title="致力于HTML5在中国的发展与应用" target="_blank">HTML5研究小组</a></li>
<li><a href="http://www.12freeblog.com/" title="关注网站运营，分享技术心得" target="_blank">12Free</a></li>
<li><a href="http://zhuwenhao.com/" title="朱文昊的中文博客－－专注技术，向往自由" target="_blank">朱文昊Albert Zhu</a></li>
<li><a href="http://www.cguage.com/" title="某VC++软件开发爱好者" target="_blank">C瓜哥的博客</a></li>
<li><a href="http://www.kaiyuanba.cn/" title="汇聚各种开源项目的中英文混合介绍并分类排列，致力于软件项目的开源事业" target="_blank">开源吧</a></li>
<li><a href="http://www.stackpop.org/" title="靖难|魔都小码农" target="_blank">靖难|魔都小码农</a></li>
<li><a href="http://acm.zhihua-lai.com/" title="Smart Ideas, Smart Algorithms" target="_blank">ACMer</a></li>
<li><a href="http://chenpeng.info/" title="优秀的开源软件让生活更简单" target="_blank">陈鹏个人博客</a></li>
<li><a href="http://www.coderli.com/" title="一个普通的coder，coding为了生活，coding因为消遣:-) Just a coder" target="_blank">OneCoder</a></li>
<li><a href="http://www.crazyshell.org/blog/" title="专注于底层基础, TCP/IP, 存储, (高性能.高可用.分布式.高并发系统) 研究" target="_blank">狂Shell – Happy Hacking</a></li>
<li><a href="http://blog.tektea.com/" title="关注IT技术 | 分享 | 交流 | 记录" target="_blank">TekTea&#39;s Blog</a></li>
<li><p><a href="http://shellblog.sinaapp.com/" title="我有一颗百度的心。" target="_blank">夕水溪下</a></p>
<h3 id="-">功能</h3>
</li>
<li><p><a href="http://coolshell.cn/wp-login.php?action=register" target="_blank">注册</a></p>
</li>
<li><a href="http://coolshell.cn/wp-login.php" target="_blank">登录</a></li>
<li><a href="http://coolshell.cn/feed" title="使用 RSS 2.0 订阅本站点内容" target="_blank">文章 RSS</a></li>
<li><a href="http://coolshell.cn/comments/feed" title="使用 RSS 订阅本站点的所有文章的近期评论" target="_blank">评论 RSS</a></li>
<li><a href="http://cn.wordpress.org/" title="基于 WordPress，一个优美、先进的个人信息发布平台。" target="_blank">WordPress.org</a></li>
</ul>
<p><a href="http://www.cnzz.com/stat/website.php?web_id=1785679" title="站长统计" target="_blank"><img src="" alt=""></a></p>
<p><a href="">回到顶部</a> <a href="http://wordpress.org/" target="_blank">WordPress</a></p>
<p>版权所有 © 2009-2013 酷壳 – CoolShell.cn
主题由 <a href="http://www.neoease.com/" target="_blank">NeoEase</a> 提供, 通过 <a href="http://validator.w3.org/check?uri=referer" target="_blank">XHTML 1.1</a> 和 <a href="http://jigsaw.w3.org/css-validator/check/referer?profile=css3" target="_blank">CSS 3</a> 验证. <a href="http://www.cnzz.com/stat/website.php?web_id=1785679" title="站长统计" target="_blank"><img src="" alt=""></a></p>
<p><img src="" alt=""></p>
<p>检测到你还在使用百度这个搜索引擎，
做为一个程序员，这是一种自暴自弃！</p>
<p><strong><a href="http://coolshell.cn/articles/7186.html" target="_blank">做环保的程序员，从不用百度开始！</a></strong>
<img src="" alt=""></p>
<p>检测到你还在使用百度这个搜索引擎，
做为一个程序员，这是一种自暴自弃！</p>
<p><strong><a href="http://coolshell.cn/articles/7186.html" target="_blank">做环保的程序员，从不用百度开始！</a></strong></p>
]]></content>
    
    
      <category term="好文摘录" scheme="http://itsolife.com/categories/%E5%A5%BD%E6%96%87%E6%91%98%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[【分享】警惕偷走时间的5大窃贼]]></title>
    <link href="http://itsolife.com/2014/02/03/2014-02-03--%E5%88%86%E4%BA%AB%E8%AD%A6%E6%83%95%E5%81%B7%E8%B5%B0%E6%97%B6%E9%97%B4%E7%9A%845%E5%A4%A7%E7%AA%83%E8%B4%BC/"/>
    <id>http://itsolife.com/2014/02/03/2014-02-03--分享警惕偷走时间的5大窃贼/</id>
    <published>2014-02-03T03:24:29.000Z</published>
    <updated>2014-03-07T03:24:29.000Z</updated>
    <content type="html"><![CDATA[<h1 id="-5-">【分享】警惕偷走时间的5大窃贼</h1>
<p><a href=""></a></p>
<p><a href="http://www.cnblogs.com/cancanwyq/" target="_blank">E8软件 中国式流程管控解决方案领导者 400-006-2800 公众微信号：e8flow</a></p>
<p>致力于中国管理软件设计
E8软件||ITSM解决方案||IT服务管理系统||ITIL管理思想执行工具||E8.NET工作流架构||企业流程管理解决方案</p>
<ul>
<li><a href="http://www.cnblogs.com/" target="_blank">博客园</a></li>
<li><a href="http://www.cnblogs.com/cancanwyq/" target="_blank">首页</a></li>
<li><a href="http://q.cnblogs.com/" target="_blank">博问</a></li>
<li><a href="http://home.cnblogs.com/ing/" target="_blank">闪存</a>
<em>
</em></li>
<li><a href="http://www.cnblogs.com/cancanwyq/rss" target="_blank">订阅</a></li>
<li><a href="http://www.cnblogs.com/cancanwyq/admin/EditPosts.aspx" target="_blank">管理</a>
随笔-133  文章-34  评论-370 </li>
</ul>
<h1 id="-5-http-www-cnblogs-com-cancanwyq-p-3281827-html-"><a href="http://www.cnblogs.com/cancanwyq/p/3281827.html" target="_blank">【分享】警惕偷走时间的5大窃贼</a></h1>
<p> <a href="http://www.chinae8.net/" target="_blank"><img src="" alt=""></a></p>
<p>好的管理者都是好的时间管理者。而管理者时间管理的根本是抓大放小、果断决策、大胆授权、梳理系统、做好计划。只有这样，管理者才能防范偷走你宝贵时间的5大窃贼，才能让自己免于焦头烂额。</p>
<p>管理者管理什么？一是管事，二是管人，三是管时间。在这三个维度上，管事最容易，管人最困难，管时间不难却最容易被忽略。</p>
<p>很多管理者天天忙得团团转，却得不到上司的好评，主要的原因就是不会做时间管理，让自己和下属宝贵的时间被浪费掉。</p>
<p>什么会偷走管理者的时间，让管理者焦头烂额却得不到应得的结果？以我的经验，管理者有5大时间窃贼需要提防。</p>
<ol>
<li><p>抓小放大。很多管理者忙于无数的小细节，不跳出细节思考什么才是自己真正应该做的事情。结果是不重要的事情做了一大堆，重要的事情一个没有做，上司不关心的事情做了一大堆，上司关心的事情一个没有做。其实事情都有逻辑关系和层次：解决一个上一级的问题，通常能让你一下子解决3〜5个次一级的问题。如果我们能抓住最上级的问题用心解决，解决一个最上级问题的效果会相当于解决几十个最底层级的问题。但解决一个大问题和解决一个小问题花的时间差别并不大，至少不是几十倍的差别。</p>
</li>
<li><p>议而不决。很多管理者忙于开会，忙于和很多相关和不相关的同事讨论如何解决一个问题，却迟迟不愿自己负起责任做出决定。这类管理者把本来可以半个小时开完的会议拖延到3个小时，把本来可以在一次会议上做的决定延迟到下一次会议。议而不决的后果是让管理者要处理的事情大量积压，让管理者的时间越来越少。这样的管理者没有认识到，没有事情可以通过拖延得到解决，决策的质量也不能通过拖延得到提高。</p>
</li>
<li><p>不能授权。很多管理者习惯于自己做事情，不习惯授权给别人做，总担心别人做不好，总觉得教会别人做不如自己做快。久而久之，自己做的小事越来越多，自己的时间越来越不够用，身边的人越来越闲，自己的委屈越来越多。</p>
</li>
<li><p>管而不理。很多管理者习惯于管事，不习惯于理事。例如，发现有人迟到，会狠狠地批评当事人，却不会思考是否是公司的考勤制度或考勤技术有问题。管而不理的后果是，一件事情发生一次，管理者要管一次，次次发生，次次要管。随着企业规模的扩大，次次管的事情会大幅增加，管理者的时间越来越少。其实只要系统梳理一次，一类问题就能解决了。从这个角度看，管是小，理是大，管理者要抓大放小，就要更多地梳理，而不是被动地管理。</p>
</li>
<li><p>不做计划。计划是什么？就是把你要做的事情和你可以用的资源合理地匹配起来，简而言之就是事先想清楚在什么时间用什么资源完成你要做的事情。在可以用的资源里，最重要的和最稀少的资源就是时间了。不做计划意味着资源和事情不匹配，意味着资源尤其是时间资源的浪费。一个人一天就24小时，浪费了就没有了。很多人忙，其实不是没有时间，而是没有合理地安排时间。</p>
</li>
</ol>
<p>好的管理者都是好的时间管理者。而管理者时间管理的根本是抓大放小、果断决策、大胆授权、梳理系统、做好计划。只有这样，管理者才能防范偷走你宝贵时间的5大窃贼，才能让自己免于焦头烂额。</p>
<p><strong>分享是一种美德，请随手转播  </strong></p>
<p>敬请关注【流程管理】公众微信平台，微信号：<strong>e8flow</strong>,宣传流程管理理念，每日会与您分享管理技巧，管理经验、哲理小故事和财经评论、财经观点。 您可以通过 “添加朋友”--&gt; &quot;搜索号码&quot; 或 “查找公众微信账号”,输入 e8flow ,搜索添加此关注</p>
<p>E8软件 提升企业战略执行力
<a href="http://www.chinae8.net/" target="_blank"><a href="http://www.chinae8.net">http://www.chinae8.net</a>
</a> 流程银行QQ群 :74080032
【流程管理】微信公众号：e8flow
绿色通道： <a href="">好文要顶</a> <a href="">关注我</a> <a href="">收藏该文</a><a href="http://space.cnblogs.com/msg/send/%e8%8b%8f%e5%ba%b7%e8%83%9c" target="_blank">与我联系</a> <a href="&quot;分享至新浪微博&quot;"><img src="" alt=""></a></p>
<p><a href="http://home.cnblogs.com/u/cancanwyq/" target="_blank"><img src="" alt=""></a></p>
<p><a href="http://home.cnblogs.com/u/cancanwyq/" target="_blank">苏康胜</a>
<a href="http://home.cnblogs.com/u/cancanwyq/followees" target="_blank">关注 - 0</a>
<a href="http://home.cnblogs.com/u/cancanwyq/followers" target="_blank">粉丝 - 24</a></p>
<p><a href="">+加关注</a></p>
<p>0</p>
<p>0
(请您对文章做出评价)</p>
<p><a href="http://www.cnblogs.com/cancanwyq/archive/2013/08/21/3271848.html" target="_blank">«</a> 上一篇：<a href="http://www.cnblogs.com/cancanwyq/archive/2013/08/21/3271848.html" title="发布于2013-08-21 09:04" target="_blank">2013年江苏省钢贸市场融资黑洞引发传统信用分析技术的思考</a></p>
<p>posted @ 2013-08-26 08:24 <a href="http://www.cnblogs.com/cancanwyq/" target="_blank">苏康胜</a> 阅读(162) 评论(0) <a href="http://www.cnblogs.com/cancanwyq/admin/EditPosts.aspx?postid=3281827" target="_blank">编辑</a> <a href="">收藏</a></p>
<p><a href="">刷新评论</a><a href="">刷新页面</a><a href="">返回顶部</a></p>
<p>注册用户登录后才能发表评论，请 <a href="">登录</a> 或 <a href="">注册</a>，<a href="http://www.cnblogs.com/" target="_blank">访问</a>网站首页。
<a href="http://www.cnblogs.com/" title="程序员的网上家园" target="_blank">博客园首页</a><a href="http://q.cnblogs.com/" title="程序员问答社区" target="_blank">博问</a><a href="http://news.cnblogs.com/" title="IT新闻" target="_blank">新闻</a><a href="http://home.cnblogs.com/ing/" target="_blank">闪存</a><a href="http://job.cnblogs.com/" target="_blank">程序员招聘</a><a href="http://kb.cnblogs.com/" target="_blank">知识库</a></p>
<p><strong>最新IT新闻</strong>:
· <a href="http://news.cnblogs.com/n/186400/" target="_blank">淘宝保险潜行三年保单超10亿笔 运费险占比过半</a>
· <a href="http://news.cnblogs.com/n/186399/" target="_blank">科学家发现古埃及人陨石项链：距今5000年</a>
· <a href="http://news.cnblogs.com/n/186398/" target="_blank">键盘藏真菌比臭鞋高65倍</a>
· <a href="http://news.cnblogs.com/n/186396/" target="_blank">乔布斯和马斯克两巨人之间的“神同步”</a>
· <a href="http://news.cnblogs.com/n/186395/" target="_blank">苹果7月修改应用排行算法：首次参考用户评级</a>
» <a href="http://news.cnblogs.com/" title="IT新闻" target="_blank">更多新闻...</a></p>
<p><strong>最新知识库文章</strong>:
· <a href="http://kb.cnblogs.com/page/186346/" target="_blank">计算机专业学习浅谈</a>
· <a href="http://kb.cnblogs.com/page/186221/" target="_blank">遗失的乔布斯访谈</a>
· <a href="http://kb.cnblogs.com/page/179631/" target="_blank">从登录开始</a>
· <a href="http://kb.cnblogs.com/page/179146/" target="_blank">聊聊内存泄露</a>
· <a href="http://kb.cnblogs.com/page/185599/" target="_blank">与Google轻轻地擦肩而过</a>
» <a href="http://kb.cnblogs.com/" target="_blank">更多知识库文章...</a></p>
<h3 id="-">公告</h3>
<p>自2007年10月20日
<a href="http://www.newzgc.com/" target="_blank"><img src="" alt=""><img src="" alt=""><img src="" alt=""><img src="" alt=""><img src="" alt=""><img src="" alt=""><img src="" alt=""><img src="" alt=""></a>
<a href="http://www.feifanit.com.cn/productITSM.htm?default=solutions" target="_blank">E8.ITSM HelpDesk 您身边的IT服务管理专家</a>
<a href="http://www.feifanit.com.cn/productITSM.htm" target="_blank"><img src="" alt=""></a>
<a href="http://www.feifanit.com.cn/productFlow.htm" target="_blank">E8.Net工作流提升企业管理执行力</a>
<a href="http://www.feifanit.com.cn/productFlow.htm" target="_blank"><img src="" alt=""></a>
<a href="http://t.qq.com/E8FLOW" target="_blank"><img src="" alt=""></a> 敬请关注【流程管理专家】公众微信号：e8flow,分享流程管理经验，传播管理理念，提升管理执行力！</p>
<p>昵称：<a href="http://home.cnblogs.com/u/cancanwyq/" target="_blank">苏康胜</a>
园龄：<a href="http://home.cnblogs.com/u/cancanwyq/" title="入园时间：2006-02-15" target="_blank">7年6个月</a>
粉丝：<a href="http://home.cnblogs.com/u/cancanwyq/followers/" target="_blank">24</a>
关注：<a href="http://home.cnblogs.com/u/cancanwyq/followees/" target="_blank">0</a></p>
<p><a href="">+加关注</a></p>
<h3 id="-">搜索</h3>
<h3 id="-">我的标签</h3>
<ul>
<li><a href="http://www.cnblogs.com/cancanwyq/tag/%E5%B7%A5%E4%BD%9C%E6%B5%81/" target="_blank">工作流</a>(15)</li>
<li><a href="http://www.cnblogs.com/cancanwyq/tag/.net/" target="_blank">.net</a>(11)</li>
<li><a href="http://www.cnblogs.com/cancanwyq/tag/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/" target="_blank">项目管理</a>(8)</li>
<li><a href="http://www.cnblogs.com/cancanwyq/tag/%E5%BC%80%E5%8F%91%E5%9B%A2%E9%98%9F/" target="_blank">开发团队</a>(6)</li>
<li><a href="http://www.cnblogs.com/cancanwyq/tag/E8.net/" target="_blank">E8.net</a>(6)</li>
<li><a href="http://www.cnblogs.com/cancanwyq/tag/ITIL/" target="_blank">ITIL</a>(5)</li>
<li><a href="http://www.cnblogs.com/cancanwyq/tag/IT%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86/" target="_blank">IT服务管理</a>(4)</li>
<li><a href="http://www.cnblogs.com/cancanwyq/tag/.Net%E5%B7%A5%E4%BD%9C%E6%B5%81/" target="_blank">.Net工作流</a>(4)</li>
<li><a href="http://www.cnblogs.com/cancanwyq/tag/CIO/" target="_blank">CIO</a>(4)</li>
<li><a href="http://www.cnblogs.com/cancanwyq/tag/E8.Net%E6%9E%B6%E6%9E%84/" target="_blank">E8.Net架构</a>(3)</li>
<li><p><a href="http://www.cnblogs.com/cancanwyq/tag/" target="_blank">更多</a></p>
<h3 id="-">经典收藏</h3>
</li>
<li><p><a href="http://blog.vsharing.com/cancanwyq" target="_blank">ITIL标准面向中国企业的实践之路</a></p>
</li>
<li><a href="http://blog.vsharing.com/cancanwyq" target="_blank">ITIL与ITSM管理软件</a></li>
<li><a href="http://www.cnblogs.com/cancanwyq/articles/343325.html" target="_blank">工作流技术杂谈</a></li>
<li><a href="http://www.feifanit.com.cn/" target="_blank">工作流应用网站</a></li>
</ul>
<h3 id="-">团队博客</h3>
<ul>
<li><a href="http://dotnetenterprise.cnblogs.com/" target="_blank">.Net企业应用开发</a></li>
<li><a href="http://shanghai.cnblogs.com/" target="_blank">上海.net俱乐部</a></li>
<li><p><a href="http://shenzhen.cnblogs.com/" target="_blank">深圳.Net俱乐部</a></p>
<h3 id="-">阅读排行榜</h3>
</li>
<li><p><a href="http://www.cnblogs.com/cancanwyq/archive/2009/09/22/1571707.html" target="_blank">1. 从网友发的一个关于程序员人生的流程图想到的(4923)</a></p>
</li>
<li><a href="http://www.cnblogs.com/cancanwyq/archive/2009/03/18/1415070.html" target="_blank">2. 技术高速发展，IT人员路在何方？(3554)</a></li>
<li><a href="http://www.cnblogs.com/cancanwyq/archive/2007/10/27/939392.html" target="_blank">3. 模式窗口window.open造成Session丢失的解决方法(2984)</a></li>
<li><a href="http://www.cnblogs.com/cancanwyq/archive/2009/05/12/1454574.html" target="_blank">4. 机会来了，创业你准备好了吗？(2668)</a></li>
<li><a href="http://www.cnblogs.com/cancanwyq/archive/2010/06/10/1755244.html" target="_blank">5. 软件公司有一种幸福叫好好活着(2566)</a></li>
</ul>
<h3 id="-">推荐排行榜</h3>
<ul>
<li><a href="http://www.cnblogs.com/cancanwyq/archive/2010/06/10/1755244.html" target="_blank">1. 软件公司有一种幸福叫好好活着(6)</a></li>
<li><a href="http://www.cnblogs.com/cancanwyq/archive/2010/06/09/1754443.html" target="_blank">2. 软件企业三个“留住”，创建品质团队(4)</a></li>
<li><a href="http://www.cnblogs.com/cancanwyq/archive/2010/08/23/1806258.html" target="_blank">3. 项目经理进阶修炼2--处理需求变更策略(4)</a></li>
<li><a href="http://www.cnblogs.com/cancanwyq/archive/2010/07/19/1780453.html" target="_blank">4. 中国程序员有望挑战“比尔.盖茨”的三大管理类需求(3)</a></li>
<li><a href="http://www.cnblogs.com/cancanwyq/archive/2010/08/16/1800428.html" target="_blank">5. 软件开发技术高手转向项目管理者要突破的误区-- 跟博客园的朋友探讨的思路(3)</a>
Copyright ©2013 苏康胜</li>
</ul>
]]></content>
    
    
      <category term="好文摘录" scheme="http://itsolife.com/categories/%E5%A5%BD%E6%96%87%E6%91%98%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[阿里数据库专家：写给我们这些浮躁的程序员]]></title>
    <link href="http://itsolife.com/2014/02/03/2014-02-03--%E9%98%BF%E9%87%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%93%E5%AE%B6%EF%BC%9A%E5%86%99%E7%BB%99%E6%88%91%E4%BB%AC%E8%BF%99%E4%BA%9B%E6%B5%AE%E8%BA%81%E7%9A%84%E7%A8%8B%E5%BA%8F%E5%91%98/"/>
    <id>http://itsolife.com/2014/02/03/2014-02-03--阿里数据库专家：写给我们这些浮躁的程序员/</id>
    <published>2014-02-03T03:24:29.000Z</published>
    <updated>2014-03-07T03:24:29.000Z</updated>
    <content type="html"><![CDATA[<h1 id="-">阿里数据库专家：写给我们这些浮躁的程序员</h1>
<p><strong>本文作者：叶正盛，阿里巴巴数据库技术专家，专注于数据库应用性能量化。</strong></p>
<p>再次写给我们这些刚入行浮躁的程序员，如何成长，以下是列出了一些成长的心得，我们不必每条都去实践，但是优秀的程序员成长过程中总会实践里面的几条。</p>
<p><strong>多做项目，多思考</strong></p>
<p>不要害怕做事，刚毕业的同学最缺的就是工作经验，乱七八糟的项目能让你很快就了解了一个公司的业务与使用的技术，并且可以多接触同事与客户。</p>
<p>当你毕业后刚进一家公司时，如果主管没有把你安排到项目组工作，那真的很杯具，因为他认为你还不能胜任工作或者你的加入会让项目组更糟。</p>
<p>还有人说，我刚进公司，公司就把我当成了苦工，工资又低，项目组加入好几个，也做了很多事情，每天都要加班。我估计有很多人感觉是这种状态，为什么会是这样，因为全国人民（不只是程序员）里有90%可能都和你一样的感觉，这说明你现在状况是很普遍的，也说明你现在的能力并没有很多出众的地方。也许是逆境才能让人成长，如果有一天你让你的团队从这些苦力工作中解脱出来或者能给你的团队前进的动力，那你就升华了，你就比他们出众。你没有能力去改变现状，所以只能接受，而不要认为是自己生不逢时，或者说公司环境太差。创业也一样，不要认为公司没发展的主要原因是环境太差，那你不要去当老板算了，投资环境都非常好还能轮到你吗。</p>
<p>还有很多同学感觉自己付出了很多，回报太少，这个问题很难平衡，首先一点，公司在聘你进来后不会因为你没有成绩就先给你回报，公司也不可能会在你有了成绩后就立即给你回报，但是长时间付出没有回报，那这个公司就不值得你付出。我不赞成频繁换公司，这么做至少可以说明你是一个只求回报不求付出的人。</p>
<p>至于薪资的问题，这个很难去评估，因为每个企业的收益相差太远。但是刚毕业的同学工作需要关注薪资+成长环境，当薪资可以满足普通生活需求后，成长环境更为重要，就好比，给你一月5000元，或者6000元，真的不那么重要，因为这些收入在你以后的人生中基本没有影响。当然，如果你现在在大城市几年里每个月只拿着1000元，那还是需要选择一下收入更好的公司，因为这么低的收入会严重影响你的工作学习计划，也说明你的公司不重视员工，没有能力给员工好生活的公司，将来的发展也是有限的。</p>
<p>特别说明一点，互联网公司与传统信息化企业不一样，互联网一直是风险比较高的行业，也许你选择了一个看好的企业，也佩服老板的眼光，可能你现在需要的是与公司同甘共苦。不要指望在刚创业的团队里拿到非常好的待遇，因为你现在就是在投资，也许几年后公司成功了，你就是功臣，不怎么出色的你也可以当上总监或副总裁。</p>
<p><strong>自己开发框架与工具来提高工作效率</strong></p>
<p>当你参与了很多项目，当你发现自己经常做一些COPY,PASTE的操作时，你可以考虑花时间去提取问题的共性，做一些自动化工具去摆平问题，或者是写一些基础框架来屏蔽这些无聊并且累赘的代码。</p>
<p>自己开发框架与工具，可以让你快速的从一个初级程序员转变成更高级的程序员或分析师或架构师，因为这个过程中给你提供了为其他程序员服务的机会，你有动力去了解其它程序员的工作需求，你可以把你的框架或工具写得很好，接口简单灵活并且性能好，分析师和架构师就经常要干这种让人力成本降低的事。但要记住一点，不要以为自己开发框架与工具就认为很NB了，因为这种工作并不会体现多少技术含量，而只是提高个人抽象问题的能力，这个活很多程序员都能干，但是很少人去干好。</p>
<p><strong>参与开源项目</strong></p>
<p>参与开源项目可以让你领略到不同程序员的沟通方法，开发习惯，技术思维，可以认识更多的朋友，如果你足够强，也可能一举成名哦。可以让你更深入了解这个开源东西，所以最好是感兴趣或者是与工作有关的，不要说什么流行就参与什么。开源项目可以自己贡献一个新的项目，或者参与一个感兴趣的项目。</p>
<p>不要指望开源项目会给你带来直接的金钱，如果你想拿着开源项目封装一下去发财，那我真不知道如何做，可以去问问什么什么芯，什么什么国产操作系统的人，他们更有经验。</p>
<p><strong>英语</strong></p>
<p>在这个全球信息时代，英语真的是一个很重要的工具，我真的很羡慕那些学校里英语就很好的同学，好的英语能力可以更快速的了解到更多知识。当前，新的技术与知识大部份语言都是英语或翻译成英语，如果能把英语学好，可以让你人生少奋斗10年。</p>
<p><strong>写技术博客</strong></p>
<p>写技术博客是一种可以快速提高的方法，但是一个人能坚持每周写技术博客，那是需要付出很多代价，写博客并不是要我们写出高质量的文章才发表，我们可以分享自己的一些小经验，也可以分享自己的体会。一样东西在你大脑里，并不表示你已经掌握了，如果你能说给别人听，或者用文字表达出来，那首先你要将这些知识点整理清楚才好表达。我经常认为自己已经对某个问题了解了，但是在整理技术博客时发现自己的知识盲点，然后再去查找知识来补充自己的盲点，直到最后搞清楚了才算告一段落。</p>
<p>有些人不喜欢分享或者害怕分享，但是在这个世界，只要不是公司机密或商业秘密，拿出来分享可以让你得到更多同行的反馈，网络上的人会给你相对真实的反馈，因为大部份人与你没有利益关系。</p>
<p>新人不要害怕自己分享的知识是否有技术含量，只要你认为有价值，都可以拿出来，这不仅可以给别人提供知识，也可以自己整理思路，还可以得到网友的反馈。如果你的知识没有价值，分享出来也没有关系，如果你的文章技术含量低，怕被人鄙视，那是你这个人不敢承认现实，因为同事与朋友可能不会说你的文章很菜，就算被鄙视了又如何，有时被人鄙视也是一种前进的动力。有人说如果几年后我进步了很多，但还让人看到我这些初学时弱智的文档，误人子弟，不好意思，Ok，那个时候有可以完全把文档删除，其实我更喜欢放在那里品味自己成长的过程，把有误导的地方更正。</p>
<p>我知道有一个技术博客作者，数据库专家杨廷琨(<a href="http://yangtingkun.itpub.net/)，他几年来，每天坚持写一篇技术博客，现在已经有2千多篇，我的ORACLE数据库水平比他差很多，但是我也偶尔看到一些他新写的文档我几年前就会了，但这些并不妨碍我对这位博客作者的敬佩，因为他的博客让我学到了很多知识。" target="_blank">http://yangtingkun.itpub.net/)，他几年来，每天坚持写一篇技术博客，现在已经有2千多篇，我的ORACLE数据库水平比他差很多，但是我也偶尔看到一些他新写的文档我几年前就会了，但这些并不妨碍我对这位博客作者的敬佩，因为他的博客让我学到了很多知识。</a></p>
<p><strong>加入感兴趣的技术论坛</strong></p>
<p>每个公司使用的技术与产品及环境都不太一样，也许你在公司里感觉什么东西都是别人做好了，我只是个流水线工人，我们的系统由于有严格的规范也不太出问题，自己的实践提高机会太少，那建议你加入感兴趣的技术论坛。</p>
<p>技术论坛上你可以看到很多人各种各样的问题与分享讨论，你也可以试着去帮别人解决问题。技术论坛可以让你进一步成长，但不要告诉我你只是会沙发、顶或接分的那种。</p>
<p>国内CSDN、OSCHINA、ITPUB、CHINAUNIX、JAVAEYE都是人气很旺，里面也不缺技术大牛与无敌大菜鸟。</p>
<p><strong>常看参考手册</strong></p>
<p>很多程序员，遇到问题喜欢直接去请教别人，或是Google找结果，通过别人或Google也许问题可以解决，但是只能形成知识点，不能形成知识体系。</p>
<p>要全面掌握一个东西最快的方法是看产品的官方参考手册，参考手册一般是代表正规的用法或者是推荐的用法，对于小产品最好是先将参考手册全部看一遍。如果是比较大的产品如（ORACLE、JAVA、.NET）那可以选择看经常使用到的部分。只有当你在看完参考手册还不懂的时候再去Google或与别人探讨，这样的方式会让你的知识更体系化。</p>
<p><strong>深入分析问题原因</strong></p>
<p>程序员一定要具备对技术问题刨根问底的想法，很多程序员能解决问题，但是不想去了解问题的根源。我们经常遇到问题，而且很多问题重启程序或者重启机器就好了，有多少程序员会去挖掘重启就解决问题的原因。我是从事数据库的，也经常看到很多人遇到数据库有问题，重装一下搞定，而没有深入分析问题产生的原因。也许在生产环境我们没有时间去分析，但是在开发环境、测试环境你是不是也经常重启解决问题。如果能在开发环境与测试环境遇到问题，这是技术人员成长的最好机会，我们在自己的领域一定不能放过这种成长的机会，因为大部份专家都是在这种历练中出来的。</p>
<p><strong>不要害怕复杂</strong></p>
<p>很多程序员习惯了利用各种框架及工具解决问题，自己只是写一些简单逻辑，当有一天遇到一个问题，没有对应的框架或工具时就放弃需求。我们不要害怕困难，如果你每天的代码都没有挑战，那何来提高，我们应该在适当的时候给自己一些压力，这样可以让自己提高得更快一些。比如你的系统需要一个轻量级的工作流引擎、编译器、解析器、界面设计器、屏幕控制器，或者一个http服务器之类的东东，但是现有的东西都感觉不太满意，你可以自己去搞一个试试，不要害怕不成功，不要害怕自己做不好。这些东西看起来有点复杂，但是当你深入去做时，你会发现里面有很多有意思的东西，你需要去逐步改进你的小系统，直到它能很好的运行为止，这是个很好的成长过程，可以让你对程序有更深的理解，也可打开思路。</p>
<p><strong>学习计算机基础，深入技术原理</strong></p>
<p>有时候我们经常迷惘，感觉技术水平没有提高，感觉技术能力总是浮在表面，特别是当你发现自己算法分析、性能分析、故障诊断能力有限时，也许这是你再次需要学习计算机基础的时候，因为基础不牢，所以你的问题诊断准确率不高。每个程序员应该都学过计算机基础（计算机体系、操作系统、网络、数据库原理、算法等等），这些知识对很多人来说是很枯燥。在当前高级编程语言时代，你的计算机基础不好也能编码，而且效率也不低，但是当你要想成为技术牛人，计算机基础就是一道坎，因为不扎实的计算机基础知识会让你在忽悠与被忽悠中成长。</p>
<p><strong>关心产品市场与商业动态</strong></p>
<p>程序员是否需要关心产品市场与商业动态，我认为是有必要的，除非你真是技术天才，能闭关十年后横扫江湖。计算机技术发展太快，每年都有新的流行产品与技术，大公司也经常改变战略或易主。如果你想引领技术潮流，想创业，那一定要关心产品市场与商业动态。</p>
<p><strong>不要去轻视任何一种职位、语言、工具</strong></p>
<p>在IT岗位里，没有高低之分，不要去轻视任何一种岗位，有些程序员认为自己的成果最有价值，美工、测试只是边缘岗位，项目经理就只会瞎指挥，不干活，销售人员与售前人员接到定单后屁事都没有，整个项目基本上就是我一个人的成果。这种心态是最要不得的。其实你的领导并不会这么想，很多事情是你不知道的，如客户关系就可能不是你一个人搞定的。还有最重要的一点，如果这个项目没有你参加怎么样？项目可能换成另外一个人做，也许他也能做得也不错，这就说明你的价值或重要性并不像你想象的那么重要。举个例子：</p>
<p>就好比你买一台联想电脑4000块，卖给一个没看过电脑的火星人20000块，这台电脑是最后的成果，但是否表示联想这台电脑是最重要的，可能你买一台戴尔的电脑还赚的钱更多，也可能你只要给对方一台杂牌电脑就可以拿到20000块。在这个例子里更重要的也许是客户关系与抓住商机，而买什么样的电脑影响不大（你在项目里的地位可能就是这台电脑的作用，没有你肯定不完整，但是很容易找到你的替代品，所以你的价值并不是最重要的）。</p>
<p>计算机编程语言是初学者最喜欢对比的话题，有的大师也经常对比各种语言的优缺点。我并不反对的评论那种语言的优劣，但我们不能去鄙视某种语言的及其使用者，因为流行的语言都有它生存的环境，可能是我们对技术的见识太窄，也可能是我们对人类的思维习惯了解的不全面，不要总是拿自己的习惯去评价。有很多系统管理员喜欢用命令行，喜欢用shell,perl等脚本语言，这些东西在我看来简直是低效且易读性差的东西，但是当你经常在没有图形界面下工作时，脚本语言可能真是更高效的选择。</p>
<p><strong>最后写上一句浮躁的根源：</strong></p>
<p>不要把祖国当母亲，应该把祖国当自己的孩子。</p>
<p>本不想讲这句话的，但是现实就是如此，浮躁的人群总是对社会充满了意见。我认为所有的这些浮躁都有一个共同点，就是认为自己无法改变这个社会，改变这个社会是国家的事，是其他人的事。</p>
<p>小时候老师总是讲祖国是母亲，我们是花朵，但是实际上我们也不是什么花朵，我们就是郑智化歌里的那根“小小的草，风吹雨打后依然不倒”。现实的社会总是充满着种种不平衡，但是浮躁并不能解决问题。有时总在想祖国并不像我的母亲，她更像是我的孩子，她还很小，经历过很多坎坷，我们经常感觉自家的孩子比不上别人的孩子的某个方面，于是对孩子多加责骂，也可能会让她花一个暑假的时间去补习。小孩子有一些成绩后也会骄傲，有时还会欺骗，我们不能容忍的是她的恶意谎言，但是她还没有到无药可救的程度，她依然还在成长。我们经常拿孩子与别人的孩子对比，而且总是发现别人孩子更好的一面，但是你是否希望与别人交换孩子呢，除了感情外你是否了解别人孩子的全部，我们需要更多的面对现实，应该在孩子成长的时候及时指出她的缺点，她不可能什么都是优秀的，所以我们应该尽自己的能力让她更好一些。你不太可能改变母亲，但是你的行动会影响孩子，你抛弃孩子，你真正的孩子将来可能也会抛弃你，所以说祖国可能并不像母亲，更像孩子，如果你把祖国当孩子，也许是另一种人生价值。
来源： <a href="[http://www.oschina.net/question/5189_20311](http://www.oschina.net/question/5189_20311)">[http://www.oschina.net/question/5189_20311](http://www.oschina.net/question/5189_20311)</a> </p>
]]></content>
    
    
      <category term="好文摘录" scheme="http://itsolife.com/categories/%E5%A5%BD%E6%96%87%E6%91%98%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[专访张龙：我的漫漫程序人生路(部分摘录)]]></title>
    <link href="http://itsolife.com/2014/02/03/2014-02-03--%E4%B8%93%E8%AE%BF%E5%BC%A0%E9%BE%99%EF%BC%9A%E6%88%91%E7%9A%84%E6%BC%AB%E6%BC%AB%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F%E8%B7%AF%E9%83%A8%E5%88%86%E6%91%98%E5%BD%95/"/>
    <id>http://itsolife.com/2014/02/03/2014-02-03--专访张龙：我的漫漫程序人生路部分摘录/</id>
    <published>2014-02-03T03:24:29.000Z</published>
    <updated>2014-03-07T03:24:29.000Z</updated>
    <content type="html"><![CDATA[<h1 id="-">专访张龙：我的漫漫程序人生路(部分摘录)</h1>
<h1 id="-">专访张龙：我的漫漫程序人生路</h1>
<p>一、关于基础</p>
<p><strong>CSDN：你在系列文章最后分享了9点心得体会，总结当时到现在的这段时光，是否有新的感悟分享？</strong></p>
<p><strong>张龙：</strong>我现在依然在坚守着这些体会：</p>
<ol>
<li><p>基础的重要性。我总是不断强调基础的重要性，因为我是有切身体会的。基础的东西可以让你受用一生。struts出来了，webwork出来，tapestry出来了，jsf出来了，struts2也出来了，等等等等。但是这些框架或者标准都是新东西吗？其实每个人都知道并不是的，他们都是基于HTTP协议的，换句话说都是构建在jsp与servlet基础之上的，有很多人连这两个基础都没掌握好，就去学这些框架，这真是难以想象的。有了好的基础会让你学习新东西更快，也更扎实，走的也更远，否则你永远都是在跟着别人的脚步。</p>
</li>
<li><p>还是基础。我们都知道Spring是非常优秀的框架，也是很多公司采用的技术选型。但是你是否真的了解Spring的核心IOC与AOP了吗？适当看些设计模式的书会让你受益匪浅。其实你只要掌握了java的动态代理对于AOP的理解就是自然而然的事情了。</p>
</li>
<li><p>舍得投入。 有时间的话买些书看看，好书可以让你系统的学习一些技术，而不是一些支离破碎的技术点。</p>
</li>
<li><p>抓紧时间。 将游戏的时间控制的少一些，把精力放在学习上吧，如果你想投身IT行业，做好不断学习的准备</p>
</li>
<li><p>要有激情。 没有激情的人生是惨淡的人生。生活和学习要有激情，否则你体会不到淋漓尽致的快乐与苦痛。</p>
</li>
<li><p>要有耐心。 没有耐心是无法成为一个优秀的程序员的。其实写程序的时候大部分时间是与错误、异常相伴的，不要幻想一下就能将程序写对，优秀的程序实际上是不断重构的过程。</p>
</li>
<li><p>要能耐得住寂寞。 很多时候我们都是与计算机为伴的，如果你没有对程序的兴趣与热情，时间长了你会坐不住的。</p>
</li>
</ol>
<p>8.英语的重要性，如果你想进外企的话，那么英语是必须要过的一关（主要体现在听说上）。</p>
<ol>
<li>最后一点，坚持学习。活到老学到老是对程序开发人员最好的描述。</li>
</ol>
<p><strong>基础的东西总是最重要的。</strong></p>
<hr>
<hr>
<p>二、关于自学（经验）</p>
<p><strong>CSDN：在（中）篇里，你提及上大学最大的两个收获就是：决定了自己的人生方向和掌握了自学的方法。你对现在正处在大学里的准程序员们有何建议？</strong></p>
<p><strong>张龙：</strong>我始终认为这是我大学期间最大的两个收获。因为进入大学后就意味着要独立承担自己的一切，别人可以给你建议，但最后拿主意的一定是自己。<strong>特别是对于计算机专业来说，自学意味着一切。</strong>毕竟计算机领域涉及众多，学校上课讲的只是最基本和基础的，在掌握了这些内容之后剩下的就要靠自己了。</p>
<p>现如今，互联网上的资源一应俱全，你要的东西网上基本都能找到，比我那个时代好太多了。不过，这是一个最好的时代，也是一个最坏的时代。可能你需要的很多资源都需要翻墙才能获取，这应该是每个程序员的必备技能了。另外，对于在校学生来说，有机会可以兼职或是去公司实习，这样可以尽早步入社会，了解公司都需要什么，为今后的工作提前做好铺垫。</p>
<pre><code>关于压力
</code></pre><p><strong>CSDN：你在研究生的时候做过柯尼卡—美能达公司的经销商管理系统、一个游戏点卡的销售网站，都给了你不小的压力，你是如何对待压力的？</strong></p>
<p><strong>张龙：</strong>压力每个人都有，做事情如果没有压力其实很容易造成拖延。这种压力一方面来自于自身，另一方面则是外界施加的。适度的压力会激发人的潜能，<strong>我现在在做事情的时候就喜欢给自己设定一个截止日期，算是自己给自己的压力吧。</strong>没有压力可能一件事，特别是需要长时间付出的事情永远也做不完。</p>
<p>三、关于沟通（经验）
<strong>CSDN：你在研究生期间就给人讲授课程，锻炼自己的口语表达能力，不少程序员相对比较内敛，这方面你有什么经验可分享？</strong></p>
<p><strong>张龙：</strong>我觉得这是个循环问题。你越闭塞，越不想与人交流，那你就越陷在自己的圈子当中，不愿走出来。反过来说，当你<strong>走出去，多多参与讨论，多多与人沟通，这对你的思维也是很好的锻炼，你就知道该如何与人打交道。</strong>你永远不是一个人在战斗，走出去才能实现更好的腾飞。</p>
<p>四、关于学习（建议）
<strong>CSDN：在你一路走来，遇到一些浮躁的心境时是怎么处理的？对刚进入这个领域的人有何建议？</strong></p>
<p><strong>张龙：</strong>浮躁、烦恼每个人都有，也不光是程序员才会这样，各行各业的人都会遇到各种各样的问题。适当排解很重要，憋在心里只会把人憋疯，出去找朋友喝喝酒、唱唱歌，一切都会过去的。我不是专家，不敢给人提建议，只是觉得<strong>学习是保证你今后的路越走越宽的最佳手段</strong>。</p>
<p><strong>来源： &lt;</strong><a href="http://www.csdn.net/article/2013-08-21/2816646" target="_blank"><strong><a href="http://www.csdn.net/article/2013-08-21/2816646">http://www.csdn.net/article/2013-08-21/2816646</a></strong></a><strong>&gt;</strong></p>
<hr>
<p>另：一个文章摘录</p>
<p>程序员最重要的技能         火龙果软件 发布于 2013-8-22    <img src="" alt="">
什么才是程序员最有价值的技能？怎样才能成为一名成功的开发者呢？我敢打赌，在你的职业生涯中你至少问过自己一次这样的问题。你找到答案了吗？你认为自己搞清楚了没有？
许多年轻的程序员会告诉你，伟大的开发者最重要的技能是<strong>对自己所用语言的掌握</strong>。当然，你得对 C/#、 F/#、C++、Java、Ruby、Haskell 或什么别的语言娴熟于心。然而，语言本身并不能提供足够的技能让你完成桌面或 web 应用。
“那要不就是对平台的知识了，”你又问自己。也许甚至是整个平台体系，如果你仔细思考一下的话。比方说，这有可能意味着要知道 Windows API 或 iOS 开发的工具或库。可是，你再想一下。如果趋势变了的话又会怎样？如果项目转向另一个平台的话又会怎样？如果你只具备前一个平台的知识的话，你还会是一名伟大的程序员吗？我不这么认为。
“对！我知道了。肯定是<strong>解决问题和分析性思维的能力</strong>”，你几乎对着我吼起来了。事实上你是对的。没有一个好的开发者是不具备分析性思维的。但是，问题解决仍然不是你应该具备的最重要技能。
“如果不是编程知识的话，那一定就是<strong>编程激情</strong>。你每天都得学点新东西。不能停止，你得热爱它。”的确，你是对的，尽管这并非最重要的能力，但已经接近了。让你从好的开发者变成伟大的开发者的，是编程的激情，尤其是学习的激情。
然而，还有一个技能更有价值，那就是<strong>沟通</strong>。
许多时候这一点被低估了，可如果不使用沟通技能的话你一天都过不了。而且，你要沟通的还不仅仅是客户。还包括你的同事，分享你的想法，用不侮辱人的方式辩论，说服你的老板应该采取你的方式。此外，还有还要汇报状态更新，解释发生的事情。你每天都要沟通，而且要沟通得当，如果你要成为伟大的开发者的话。
这就是我要发文章谈演讲这个似乎不相干话题的原因。我认为从中你可以学到很多东西，如果你对此感兴趣的话你可以继续学习 coursera 的课程（英文）。</p>
<p>来源： <a href="[http://www.uml.org.cn/itnews/2013082209.asp](http://www.uml.org.cn/itnews/2013082209.asp)">[http://www.uml.org.cn/itnews/2013082209.asp](http://www.uml.org.cn/itnews/2013082209.asp)</a> </p>
]]></content>
    
    
      <category term="好文摘录" scheme="http://itsolife.com/categories/%E5%A5%BD%E6%96%87%E6%91%98%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[逃出你的肖申克（三）]]></title>
    <link href="http://itsolife.com/2014/02/03/2014-02-03--%E9%80%83%E5%87%BA%E4%BD%A0%E7%9A%84%E8%82%96%E7%94%B3%E5%85%8B%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://itsolife.com/2014/02/03/2014-02-03--逃出你的肖申克（三）/</id>
    <published>2014-02-03T03:24:28.000Z</published>
    <updated>2014-03-07T03:24:28.000Z</updated>
    <content type="html"><![CDATA[<h1 id="-">逃出你的肖申克（三）</h1>
<h1 id="-20-http-mindhacks-cn-2010-03-18-escape-from-your-shawshank-part3-"><a href="http://mindhacks.cn/2010/03/18/escape-from-your-shawshank-part3/" target="_blank">逃出你的肖申克（三）：遇见20万年前的自己</a></h1>
<p><a href="http://book.douban.com/subject/2345245/" target="_blank">《Synaptic Self》</a>中曾提出一个发人深省的观点：由于人的大脑是经过漫长的进化年代“堆积”起来的，也就是说，从爬行动物到哺乳动物到高级灵长类这些进化阶段，我们的大脑从只有原始的反射模块，到拥有初步的情感区域，一直到神奇的具有6层结构的“<a href="http://en.wikipedia.org/wiki/Neocortex" target="_blank">新皮质</a>”所支撑的高级认知能力，一步步走来。这个过程并非上帝预先编程架构好的，而更像是在既有结构上“叠床架屋”，比如，大脑从内到外基本上是按照进化年代来排序的，比如啮齿类等一些小型哺乳动物的新皮质是光滑的，这是新皮质在进化出高级灵长类之前的样子，后来为了解决大脑中空间不够的问题，进化之手发明了大脑皮层沟回，通过这些褶皱，在不增加太多占用面积体积的前提下使得大脑皮层表面积暴涨，正是这些褶皱使得灵长类进化出独特的高级认知活动，如工作记忆，语言。这种“堆砌式”的进化有它节省和复用的好处（<a href="http://book.douban.com/subject/4198063/" target="_blank">《Kluge》</a>），然而另一方面也带来了奇特的“进化时滞”效应——进化年代较近的大脑模块和较久远的模块之间要达成完美沟通需要一定的时间，在这之前便会造成多个模块之间面对同一个问题决策不一致的问题。</p>
<p>我们的高级认知模块明明知道有些事情很重要，必须提前准备并持之以恒，然而我们内心的另一个小声音却在万般阻挠我们把屁股从床上挪开或者把眼睛从网页上挪开；我们明明知道赌博，烟酒，犯罪是不对的，然而内心的一个小声音却在喋喋不休地催我们动手去做。我们明明知道高糖高脂肪的食物不宜多吃，但内心的一个小声音却总是怂恿着再吃最后一勺（不禁让人想起《傀儡人生》）。令人感到遗憾的是，很多时候在这个争端中败下阵来的却是代表更先进生产力的高级认知模块，更令人感到遗憾的是，在大多数时候我们的高级认知模块似乎根本就没有启用，而是凭借着本能或直觉“自动驾驶”自己的身体（<a href="http://book.douban.com/subject/2252432/" target="_blank">《Gut Feelings》</a>）。</p>
<p>这里的原因是明显的：设想一下，人类的高级认知模块是在相对较近的进化年代出现的，然而原始的情感和条件反射模块却在千万年的进化长河中忠实地保护着我们在自然环境中生存下来并努力繁衍后代（<a href="http://book.douban.com/subject/4010184/" target="_blank">《Mean Genes》</a>），这些模块似乎“理应”拥有更强大的力量，然而工业时代的到来将人类生存的环境极大的改变了，我们大脑的原始模块适应的是远古时期的生活，以采集狩猎为主题的社会构成，这跟现代工业文明相差颇大，举个例子，我们的社会交往本能令我们非常顾及自己的面子（面子不仅是一个东方文化中的东西， 在全球都存在），面子可以与很多东西关联——与异性的交往成败，在对手面前是否挺身而出，在困难的任务面前是否完成得很好，这里的逻辑是很明显的：一次糟糕的社会性事件会降低我们的声誉，在远古社会，聚居群体较小，成员之间依赖性很高，糟糕的声誉会导致被赖以生存的群体排挤出去，危机自身的一切，所以我们往往有着不顾一切捍卫自己的面子原始冲动，<a href="http://book.douban.com/subject/2374426/" target="_blank">《Bounded Rationality》</a>里面曾经提到这样的一个例子：两个男人因为酒吧里面的一点小争执最终大打出手乃至一方杀了另一方。在类似酒吧这样的一个众目睽睽的社会场所，人们往往会为面子而恼羞成怒，作出过激行为，而我们的大脑同时又会认为我们仍然处在没有法制的远古社会，所以杀人便有了可能，事实上我们不难想象在远古社会杀人可以转化为力量和能力的声誉，由于进化的钝刀还没有来得及磨平我们远古时期的“棱角”，所以只有少部分“理性大脑”强大的人才能够作出适应现代工业社会的行为；《Mean Genes》上面说了这么个例子：在远古社会我们在向姑娘求爱的时候会小心谨慎，因为一次洋相会很快被传递开来从而使得我们变成整个群落的笑柄，然而在现代社会，尤其是人口流动剧烈，人际关系变动频繁的大城市，社交失败的成本近乎于0，所以正确而理性的做法却是永远都勇敢地迈出第一步。</p>
<p>因为我们的大脑中同时存在着远古的自我，和现代的自我，并且两者并没有完美协调，所以才会出现“如著作等身的教授，聪明的数学家，艺术家同样有可能成为性引诱的牺牲品，同样可能犯七宗罪，同样可能成为焦虑和忧郁症的患者”（《Synaptic Self》）（不禁让人想起前阵子著名的泰格伍兹事件）。</p>
<p>然而除了这些极端情况之外，普通人也常常受到困扰——明知正确的事情就是没法去做。仔细想想这简直是一句类似悖论的话：既然你的大脑认可某种做法是正确的，而同样又是你的大脑主管你的行为，那为什么偏偏你没法执行呢？这就说明主管行为的并不仅仅是你的“认知”模块，认知模块发完话之后自会有更强大的情绪模块藐视“上级”的决定。所以我们常常哀叹“说起来容易做起来难”。世界上最痛苦的事情不是和别人作斗争，而是和自己作斗争。</p>
<p><a href="http://book.douban.com/subject/1868282/" target="_blank">《Phantoms in the Brain》</a>提到这么一个有趣的例子：我们看到老朋友时会自然微笑，然而站在摄影师面前我们却经常“挤”出难看而别扭的微笑。我们常常说第一种微笑是发自内心的，第二种笑则是有意做出来的。事实上这两种微笑的确涉及到两种不同的机制，只不过不是心脏和面部肌肉，而是两个不同的大脑模块。自然、下意识的微笑来自于大脑中位于进化年代较古老的丘脑和进化年代较新近的大脑皮层之间的一个叫做“基底核”（basal ganglia）的结构，而有意识的笑则是由大脑中的动作皮层控制的。而这两者只有前者具有正版的微笑神经回路，当我们看到朋友的时候，朋友的脸庞的视觉映像通过视觉神经传导到我们的情绪模块（边缘系统），并进而被转发到基底核，后者的微笑回路负责调动面部肌肉生成一个真正自然的微笑，整个过程在不到一秒内完成，在这个时间里你的高级认知模块根本还没来得及活动呢。</p>
<p>有些时候一些人会因为中风而导致一侧运动皮层受损，如果你叫他对着摄影师笑，你会发现他挤出的是半边脸的山寨微笑，另一边脸（对应受损的运动皮层的那一边）则不笑。然而神奇的是如果他见到老朋友，则会发出两边对称的、自然的微笑，因为控制自然微笑的基底核没有受到损伤。</p>
<p>而在极少数情况下，则会出现一种恰好相反的情况：中风损伤了一个人的基底核，影响了半边脸的微笑回路，一开始这个人自己也注意不到，直到他对妻子自然微笑，妻子会惊讶地发现他脸上只有“一半”微笑。然而，如果摄影师叫他微笑，他却能够做出对称的微笑，虽然是不自然的那种，因为控制有意识微笑的运动皮层并没有损伤。</p>
<p>就像两种微笑一样，我们的大脑在同一个决策上经常有不同模块的参与，有的人更偏向使用直觉进行决策（<a href="http://book.douban.com/subject/2990015/" target="_blank">《Predictably Irrational》</a>），有的人则更偏向于理性分析，而事实上这两者并没有孰优孰劣之分，只是在不同的场合适用，无法驾驭这两种决策引擎的人要么一方压倒另一方，要么就是陷入纠结。</p>
<p>我们在选择职业的时候“听从内心的召唤”，因为我们对事物的热情来自于我们的情感系统，没有这个系统的支持，我们很难在一件事情上持之以恒的专注投入，emotion（情绪）和motion（动力）本就是同根生，说明人们很早就了解到情绪和动力的关系。对此有这么一个真实事件（记不得在哪本心理学书上看到的了，记得的朋友请留言。），一个事业顺利的中年男人，原本过着典型的美国中产阶级的生活，但有一天不幸遭遇了车祸，车祸损伤了他的头部，他的情绪大脑遭到了损坏，后来虽然他健康方面痊愈了，然而却从此对任何事情都无动于衷，再没有动力去发展他的事业，照顾他的家庭，对他来说发生什么都是无所谓的。事实上，我们所谓的生活的意义便来源于情感系统。</p>
<p>我们在面对道德问题的时候听从“良知的召唤”，因为漫长的进化给了我们一套非常优秀的天生道德判断神经回路（<a href="http://book.douban.com/subject/2328458/" target="_blank">《社会性动物》</a>），只要听从良知的召唤我们便能在道德的平衡木上走得稳稳当当。</p>
<p>我们对于很多事情的决策判断都刻画在天性里面，然而同样也正是这些天性在很多时候会让我们陷入困境，我们“能存储能量就尽量存储能量”的食物摄取天性虽然适合远古社会，然而在能量充裕的现代社会却导致大量人的超重。<a href="http://book.douban.com/subject/3440613/" target="_blank">《How We Decide》</a>上有这么一个有意思的实验：让一群人走过一个屋子，屋子的中间放着一个桌子，上面有诱人的巧克力蛋糕，也有水果沙拉，让其中一部分人默记某个7位数字序列，另一部分人则只默记2位数（当然，实验者会为默记数字的原因编造一个谎言，例如测试记忆能力），实验结果是，那些默记7位数字的人更可能选择巧克力蛋糕，因为记忆数字过载了我们的高级认知模块，使得它无暇和原始大脑的决定作抗争。</p>
<p>我们对于未来的惩罚和收益都估计不足，倾向于就眼下的损益进行决策。这就导致我们天性在决策方面目光短浅，一个典型的例子是我们会在大学阶段花费大量的时间去进行学习之外的娱乐，这些娱乐都有一个典型的特点，就是能够立即获得愉悦，并且并不会导致立即的损失。毕业看似遥遥无期，我们很难提前几年就设想几年后的危机，毕竟，未来的事情谁说得清呢？也许我们的远古生活告诉我们的真理就是，几年后的潜在收益跟眼下唾手可得的好处无法相比。</p>
<p>我们的原始大脑同样也分不清什么是虚拟什么是真实，在获得社会成就和声望的动机的驱使下，即便是虚拟的网络游戏社会，我们也会投入大量精力，某种意义上我们的大脑并没有错，我们的确应该去获得声望，只不过它还没有聪明到跟得上工业文明，它并不明白虚拟世界里面的生存能力和地位并没有办法转化为现实世界的生存能力和地位。</p>
<p>如你所见，很多时候我们只是生活在信息社会的远古人，如果上帝要为我们目前生出的时代设计人类，我们将会是身体上适合长期久坐不见阳光，眼睛尤其适合长久盯着30厘米以内的物体看，我们情绪上会偏好有节制而健康的饮食，我们的身体发育将不会在肌肉上浪费太多不必要的能量，青少年也不会在青春期强烈渴望冒险和建立小部落内的声望并为之做出各种危险或可怕的事情，而在执行力上我们则会偏好于执行能够积累知识和技能的长远计划，正如geeks们所崇尚的一句话所言：smart is the new sexy。</p>
<p>然而人类进入工业文明才短短数百年，英特网的历史则更是短的几十年，和漫长的进化长河相比仿佛一瞬，我们匆匆忙忙把自己推入了一个完全不一样的世界，而进化的齿轮转动得却慢了很多拍，于是我们都成了进化时滞的牺牲品，我们用远古的双眼打量着这个世界，关在笼子里的老虎完全不必害怕，但我们还是会汗毛倒竖，汽车酿成的交通事故每天无数，而我们过马路却置若罔闻。一句话：我们的情绪大脑仍然停留在20万年前，而20万年前是没有汽车这种物种的。</p>
<p>然而，我们毕竟拥有所有动物中神经元和突触数量最多，结构最复杂的新皮层。我们拥有神奇的认识自身的能力，这种能力使我们能够利用情绪系统本身的特点来克服它自身的缺点。</p>
<p>我们做事情难以持之以恒地专注，因为任何一个新鲜刺激的外部信号都足以激活我们强大的情绪大脑，情绪大脑一旦被激活，其神经信号往往轻而易举地抢占我们的注意力，结果就是我们发现在这个纷繁的世界里很难维护内心的宁静和专注，于是我们发明各种隔绝干扰的方法来保护我们脆弱的理性大脑，从而能够让自己做应该做的事情。</p>
<p>我们的大脑喜欢事情往积极方向发展，有这样一个实验：研究者让被试将手放在冰水中一段时间，有两个选项可供选择，一是将手放在非常冷的冰水中60秒并取出，另一是将手放在非常冷的冰水中60秒，然后再在逐渐变得不那么冰的冷水中放30秒再取出。绝大多数人认为第二种选择更为不那么痛苦。然而从经历的“客观”痛苦上讲，很明显第二种情况下人要受更多的罪。但是那种“情形正在变得越来越好”可以带来明显的正面情绪，于是第二种情况下的主观痛苦要小于第一种情况。而GTD的原理正是如此：通过提供不断的进展，让执行者意识到事情正在朝向完成不断迈进，这种正面趋势所带来的积极情感能够进一步激励个体把事情执行到底。</p>
<p>总之我们发明各种认知方法来“诱使”或“要挟”我们的情绪大脑同意去执行一件事情：我们向朋友承诺我们要做的事情，于是我们的情绪大脑会迫于信誉受损的压力而去主动完成这件事情。而加入互助学习小组则本质上是利用大脑的从众本能和同侪压力。<a href="http://book.douban.com/subject/4022709/" target="_blank">《Nudge》</a>上提到很多这样的例子，比如“一百美元的论文催缴金”：为了“逼迫”自己在计划时间内完成论文，戴维将三张100美元的支票预先交给泰勒，戴维每延迟一个月完成论文，泰勒便可以提取其中一张支票并将钱用于开聚会（而且还不邀请戴维参加:)），显然，戴维的情绪大脑很难容忍这样吃亏的冤枉事，所以为了避免它，便忠实地督促戴维把论文按时搞定了。此外还有“减肥违约金”，“夏令时”，“圣诞节省钱俱乐部”以及著名的<a href="http://faculty.chicagobooth.edu/richard.thaler/research/SMarTJPE.pdf" target="_blank">“Save more tomorrow”</a>等很多有意思的例子。</p>
<p>最后，经常动用理性思考也能够锻炼理性大脑的“实力”，在更多的决策场合获得压倒性优势。神经科学显示，大脑的模块的确遵循用进废退的原则（<a href="http://book.douban.com/subject/2370985/" target="_blank">《The Brain That Changes Itself》</a>），一个经典的证据是钢琴家的大脑中对应手指的神经回路占用面积要比正常人大很多。另一个有意思的证据是，如果一个人失明了，那么负责接受视觉信号的神经回路往往会被听觉所侵占（人们常说瞎子的听觉格外灵敏难道便是这个原因？）</p>
<p>上帝给了我们一个过了时的原始大脑，但同样也更新了我们的新皮层，能否不被20万年前的自己绑架，取决于你是否认识到关于大脑的进化历史，和能否正确使用你的理性大脑。
来源： <a href="[http://mindhacks.cn/2010/03/18/escape-from-your-shawshank-part3/](http://mindhacks.cn/2010/03/18/escape-from-your-shawshank-part3/)">[http://mindhacks.cn/2010/03/18/escape-from-your-shawshank-part3/](http://mindhacks.cn/2010/03/18/escape-from-your-shawshank-part3/)</a> </p>
<ul>
<li><a href="">110条评论</a></li>
<li><a href="">24条转载</a></li>
<li><a href="">38条新浪微博</a></li>
<li><p><a href="">6条腾讯微博</a></p>
</li>
<li><p>我是在找人工智能的相关内容，结果《机器学习与人工智能学习资源导引》把我带到了我比较喜欢的Mind Hack，于是就顺便把这篇刚发表不久的文章给读完，依然那么犀利，smart is the new sexy！
女人是一种感性动物，很容易受情感影响而失去理智，被20万年前的自己绑架，最近就遇到一位。。。。
2010年3月18日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
</li>
<li><p><img src="" alt="edmond"></p>
</li>
</ul>
<p>edmond</p>
<p>女人是一种感性动物? 大脑会应性别而有区别吗?
认为男女有别, 往往是社会评价起到了作用. 在社会评价中会告诉一个男人或者一个女人,什么样子叫做有男人味(如勇敢,果断,理性等等特征),什么样子叫做有女人味(如细腻, 感性等等). 而我们置身于社会之中,多多少少向社会的主流价值靠拢,并下意识以此准绳来塑造自己,显得自己有男人味,或者有女人味.这个在社会心理学里面叫做从众,服从吧.
所谓失去理智,一般是情绪掌握控制权,而在几十万年的进化中情绪的作用是用来保护我们自己的安全,因为动用理性思考的时间代价要比情绪要多. 比如开车时,突然有车过来,你估计不用经过大脑思考,就下意识地刹车.甚至在事后,你记不得为什么自己会这么做. 这是因为情绪的启动非常快.</p>
<p>2010年3月18日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="hit_alex"></li>
</ul>
<p>hit_alex</p>
<p>我不太理解你为什么会在第一句话抛出两个问题：女人是一种感性动物? 大脑会应性别而有区别吗?
以我阅读你之后的两段话的经历来看，我认为你并没有真正的回答这两个问题。抱歉，由于能力所限，我也暂时回答不了。</p>
<p>2011年1月20日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="ctennis"></li>
</ul>
<p>ctennis</p>
<p>你的第二个问题, &quot;大脑会应性别而有区别吗?&quot;, 我也想再加一个问题:&quot;胸部会因性别而有区别吗?&quot;
男女的大脑有没有区别尚不知道, 非要我选的话我也觉得没(大)区别. 问题是大脑不是在独立运作的, 而是受各种信号的控制的, 流淌在男女体内的激素是不同的, 这种输入信号的不同导致了架构相同的大脑面对同样情况产生不同的反应.
我想如果给你注入肾上腺素的话, 你大脑感性/理性的平衡点也会变化, 这并不代表你大脑发生变化了, 只是输入的差别导致了输入的差别.
你第二段说的男女有别是由社会造成的, 只能说这是一个因素(而且是一个比较浅层次的影响因素), 却不能因此说男女差别就完全是由此导致.</p>
<p>2011年7月13日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="Tung"></li>
</ul>
<p>Tung</p>
<p>我觉得男女还是有别的！不可否认，社会评价起了一定的作用，而且这个作用是显而易见的！但是，是什么原因导致这种社会的对于男女的普遍评价呢？我认为就是男女的区别，是生理上的区别造成心里上的差异。最简单来说，男女所分泌的激素不同，日常的行为也就不同了。</p>
<p>1月5日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="cra"></li>
</ul>
<p>cra</p>
<p>今天看抓虾，大鹏update了，mark后细读</p>
<p>2010年3月18日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://www.86hacker.com/" title="文武全财" target="_blank"><img src="" alt="文武全财"></a></li>
</ul>
<p><a href="http://www.86hacker.com/" target="_blank">文武全财</a></p>
<p>非常精彩的文章。最近一直关注您的更新，收获很多。</p>
<p>2010年3月18日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://www.happy-lovers.com.cn/" title="日月山人" target="_blank"><img src="" alt="日月山人"></a></li>
</ul>
<p><a href="http://www.happy-lovers.com.cn/" target="_blank">日月山人</a></p>
<p>这个系列什么时候可以完成？</p>
<p>2010年3月18日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://mindhacks.cn/" title="pongba" target="_blank"><img src="" alt="pongba"></a></li>
</ul>
<p><a href="http://mindhacks.cn/" target="_blank">pongba</a></p>
<p>目前没有既定的计划，取决于以后的阅读。这个系列其实是我日常业余阅读的“读后感”。</p>
<p>2010年3月18日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="读者"></li>
</ul>
<p>读者</p>
<p>写的和前几篇一样的啊</p>
<p>2010年3月18日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://mindhacks.cn/" title="pongba" target="_blank"><img src="" alt="pongba"></a></li>
</ul>
<p><a href="http://mindhacks.cn/" target="_blank">pongba</a></p>
<p>的确有重合的部分。不过有不少有意思的例子我觉得可以分享:)
P.S. 这个主题我很早之前写过一个《Mean Genes》的简短书评，可以说本文只是展开一下。</p>
<p>2010年3月18日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://zhiwei.in/" title="zhiwei" target="_blank"><img src="" alt="zhiwei"></a></li>
</ul>
<p><a href="http://zhiwei.in/" target="_blank">zhiwei</a></p>
<p>终于更新了。。。先占个位置再细看，嘿嘿</p>
<p>2010年3月18日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://blogning.appspot.com/" title="张宁" target="_blank"><img src="" alt="张宁"></a></li>
</ul>
<p><a href="http://blogning.appspot.com/" target="_blank">张宁</a></p>
<p>“……在不增加太多占用面积的前提下使得大脑皮层表面积暴涨……”
我觉得应该是：“面积” -&gt; “体积”。</p>
<p>2010年3月18日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://mindhacks.cn/" title="pongba" target="_blank"><img src="" alt="pongba"></a></li>
</ul>
<p><a href="http://mindhacks.cn/" target="_blank">pongba</a></p>
<p>感谢！已更正。</p>
<p>2010年3月18日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="mr。lin"></li>
</ul>
<p>mr。lin</p>
<p>说实话 每次看到你有新的更新我都兴奋异常 做什么都有了力量 好久没看过有这么令我深思的博文了v</p>
<p>2010年3月18日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="hi_lucky"></li>
</ul>
<p>hi_lucky</p>
<p>特意从googlereader跑过来，表示支持。这么好的文章，为什么才这么几个人留言。</p>
<p>2010年3月18日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="double"></li>
</ul>
<p>double</p>
<p>留言的人不需要多 只要能够引起共鸣就行</p>
<p>2010年4月3日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="Rocky.liu"></li>
</ul>
<p>Rocky.liu</p>
<p>关于“脑科学”的探讨，作者是切入的比较深入的，我一直在试图通过一些渠道来更好地拓展我们如何高效率地应用大脑。譬如，专注地读书过头了，容易造成大脑缺氧而头疼。那么，进行吐纳（深呼吸运动），可以有效缓解大脑缺氧的问题。国外的研究从鞭辟入里的分析中把脑科学发展的比较深入，而中国传统的一些认知，能够把一些似是而非的用脑法则进行包容。
作者的博文每篇必读，为我打开了一个全新的“脑科学”视野，正在日常学习、工作中借鉴其中的一些做法，通过“有意识”地培养我们用脑的方法，那样我们在处理很多问题的时候能够更加理性和高效，也更能摆平很多人、很多事。</p>
<p>2010年3月18日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="ty1921"></li>
</ul>
<p>ty1921</p>
<p>记得《暗时间》之后，等得是花儿谢了又开还结果了，终于在今天更新，中午的时候表妹祝我节日快乐，说是老师安排的，难不成那位可爱的老师也是刘大的粉丝？
记得小时候动画片里面，坏人要干坏事之前，总是要内心挣扎一番，一个善良的自己和一个邪恶的自己在那打架，还老是邪恶的占据上风，这也许就是文中”远古的自己“和”近代的自己“吧
Smart is the new sexy好像和”书中自有颜如玉”是类似的道理，让人不禁想到《金瓶梅》、《X宫X图》之类的大作。而每次看喜剧之后心情都会很高兴，看了悲剧之后一段时间又都是很悲切的，援引过来，当看到Smart 之后，我们想必也会比平时更加Smart ，久之就被刘大所同化，不知道这个算是条件反射还是自身的进化呢
末了提个小小的建议，文中例子看起来觉得少了点什么，对比以前的文章因为有刘大自身的例子，仿若很鲜活，触手可及似的，以后如果也能亲身举例，效果说不定会更好呢——当然这只是太顾及自身的感受了，罪过罪过</p>
<p>2010年3月18日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://weibo.com/pongba" title="刘未鹏pongba" target="_blank"><img src="" alt="刘未鹏pongba"></a></li>
</ul>
<p><a href="http://weibo.com/pongba" target="_blank">刘未鹏pongba</a></p>
<p>谢谢你的建议，的确应该如此，以后注意 <img src="&quot;:" alt=":)">&quot;)</p>
<p>2010年3月18日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="Riemann"></li>
</ul>
<p>Riemann</p>
<p>能说明什么问题？太表面了。</p>
<p>2010年3月18日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="美丽心情"></li>
</ul>
<p>美丽心情</p>
<p>博主是搞计算机的，不是搞认知心理学和神经学的。</p>
<p>2010年3月18日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="Riemann"></li>
</ul>
<p>Riemann</p>
<p>从哲学上进行思辨或是定性的在那儿想，不会得出什么深刻或是重要的结论的，深刻也有可能，但是起不到本质的作用。比如说，所谓的“力”的概念，或可以把它称之为一种对于世界运作方式的理解(这种运作方式就叫力)，大家都说各种星球之间存在一种作用，于是我们就叫它为“力”，说所谓的粒子(或也是我们想像的，有没有其实不确定)之间也有所谓的“力”，只说(或是只认为、只想像、在概念上承认)有这种力，有什么用呢？对于大家没有什么改变或是没有什么深刻的对于世界运行方式的认识，仅仅是一种认识而已，也无所谓正确与错误。比方说，就好像说，人世间有鬼或是有灵魂一样，大家可以信，也可以不信，都无所谓。但是如果真有一天，人们知道了灵魂与肉体之间的精确的关系， 用所谓的灵魂制造了一个人的时候，或是从所谓的肉体能获取它的灵魂的时候， 于是才对于人类，起到了真正的作用(当然是所谓的好或坏，不确定)。话又说回来，力不力的无所谓，关键是后来newton发现了”力“这种物件之间的比较精准的关系，以及与所谓的运行之间的精确(相对)的关系，所以才对整个人类的所谓进步，产生了真正的作用。对于本文作者所说的文章中的观点，不也是与我上述情形类似吗？所以，问题就是如何真发现这些规律？精准的规律，那么请大家品位一下这本书，&lt;&gt;.</p>
<p>2010年3月18日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="Riemann"></li>
</ul>
<p>Riemann</p>
<p>&lt;&gt;，在17-20世纪初(1600-1900-1930)的年代里，其实那些科学家吧，已经有很多重要的思想了，但是真正深入理解他们思想的人，恐怕没有几个人，有的话，也是在他们之间传递，他们死后，由于他们对于世界运作方式的阐述或是研究，没有完整的保存下来，又因为不占主要地位(包括现在，因为科学家手中没有大量的钱，不能做想做的事，那些既搞科学又做生意，经营企业且成功的人还真了不起)， 无人问津，所以后来的人，有时候也是在重复这些人的事儿，没有真正的搞清他们的思想。。比如说，有哪位真正理解微积分的深刻的思想，当时的人怎么想起的这种思想，laplace那句话是什么意思？Riemann,Galois,Enstein,Hilbert,erdos,gauss,cauchy,还有现在活着的tao等人一生都在想一些什么样的问题，他们想出来了多少，没有解决哪些问题，他们真正的想法，如果能够了解这些东西，我想对于我们来说是无尽的财富，是真正的财富，并且从现实来说，它们能真正的产生能吃能用的”财富“，但是奇怪的是，好像现在没有人搞这些东西，搞了这些东西，现在所有的东西，将马上有解决的端倪。比方说，现在大家都 在研究计算复杂性、混沌、复杂系统这些东西，其实，我上述的那些人也都想过这些问题，目前对于计算复杂性、混沌、复杂系统的研究，有什么深刻的认识和发现呢？好像还没有，都是在那儿奏热闹，有人真正的想过如何去发现其中的规律吗？可能也有人，但是为什么发现不了呢？大家可以想想。</p>
<p>2010年3月18日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="Riemann"></li>
</ul>
<p>Riemann</p>
<p>那本书的名字是:”数学与知识的探求“,给主人提个问题，你的blog的comment上好像无法输入书名号&lt;&gt;</p>
<p>2010年3月18日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="美丽心情"></li>
</ul>
<p>美丽心情</p>
<p>谢谢博主精彩博文。
我们一直在和“20万年前的自己”斗，，多么有意思啊！！！</p>
<p>2010年3月18日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="Adam"></li>
</ul>
<p>Adam</p>
<p>&quot;对此有这么一个真实事件（记不得在哪本心理学书上看到的了，记得的朋友请留言。），一个事业顺利的中年男人，原本过着典型的美国中产阶级的生活，但有一天不幸遭遇了车祸，车祸损伤了他的头部，他的情绪大脑遭到了损坏，后来虽然他健康方面痊愈了，然而却从此对任何事情都无动于衷，再没有动力去发展他的事业，照顾他的家庭，对他来说发生什么都是无所谓的。事实上，我们所谓的生活的意义便来源于情感系统。&quot;
哈哈，这也是《How we decide》里面的例子啊！pongba用了不少《How we decide》了嘛！呵呵，最近自己正好在看这本书。
评论的时候还没看完你这篇，不过看到这里已经觉得这篇绝对爆牛，长度已经说明问题了。。。</p>
<p>2010年3月19日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="shuning"></li>
</ul>
<p>shuning</p>
<p>分析的精彩</p>
<p>2010年3月19日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="aduhupu"></li>
</ul>
<p>aduhupu</p>
<p>终于更新了，不错。</p>
<p>2010年3月19日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="gougu"></li>
</ul>
<p>gougu</p>
<p>期待每一次的更新！</p>
<p>2010年3月19日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://bbs.oscpp.org/" title="greatboy" target="_blank"><img src="" alt="greatboy"></a></li>
</ul>
<p><a href="http://bbs.oscpp.org/" target="_blank">greatboy</a></p>
<p>为什么我经常会被外部的事情所吸引，有没有什么办法训练自己的专注力，请您为我推荐一本书看看！</p>
<p>2010年3月19日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="徐竟倬"></li>
</ul>
<p>徐竟倬</p>
<p>楼主的文章很精彩，我就深有体会。但我有一个疑问就是既然这个是人类共同的特征。为什么有的人没有这些的困扰呢？比如他们就很有毅力，按时起床，按计划做事。遇到困难也不退缩，也不不沉溺于一些爱好。目标很清晰。很多成功学只解释了表象，始终没有说清楚为什么成功人士做这些事情毫无障碍。是不是成功人士的生理上和普通人有区别？不知道楼主对这个问题有研究否。</p>
<p>2010年3月19日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="wirx"></li>
</ul>
<p>wirx</p>
<p>你可以比较两台电脑，一台是懂电脑常优化的，一台是不懂维护常上黄色病毒网站的。先天的确大脑的认知发展会有区别，后天的认知模块训练也很重要</p>
<p>2010年3月20日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="fffff"></li>
</ul>
<p>fffff</p>
<p>这只是作者的定性的推断而已，从本质上说，你是没有把这些事情说清楚的，只能当成是一篇散文来读，或是一种说法来读。对于一个有不好习惯的人来说，他接受你的所谓的理论，也没有什么作用效果。作者你确认人的大脑的所谓的各个模块或区域是有那样的机制吗？即使有，这个机制比较精确的表达或描述是如何的？当然不能是自然语言来描述， 估计这是没有人清楚，所谓的医学上也不能证明，如果用物理上的微粒说(也是现代科学的经典的基础，就是物件都是有一种基本的粒子组成的，这种最基本的粒子，人们好像给的一个顺序是分子-原子-质子-中子-跨克之类吧，这种认识在一定程度上还可以，但是无法解释另外一些东西)来解释，所谓的元素是如何组成了这样的区域或是模块，区域也就是所谓的大量专门功能的细胞构成的“组织”吧，它们为什么就有了所谓的活性，自我复制性，并且有了所谓的记忆、工作等作者你说的那些机制的呢？所以说，认为作者只是自己的一些推断或是想像，来写了这个文章，并且推断或是想像当然无所谓对与错，关键是是否能从作者的想法(观点)中得到一些深刻的东西，并由这种深刻的东西来获得对世界运作方式的更加一般性的认识，我想这很关键。比方说，公元前5世纪的德膜克里特，提出的这种“微粒”的观念，表明对于确定世界的运作方式而言是有效的，至少现代的整个工业文明可以用这个来解释，并且是在这种解释之下，并产生更加深刻的观念来使世界发生变化的，德膜克里特提出的观念的关键在于，后来人可以再按着他的想法，继续想下去，而作者提出的观念，大家当然都接受，没有任何问题，对于一个现代人来说，可以说是一种所谓的“精神劝说”或是类似于圣经的那种对人的一种指正，除了这些，没有看到其它的东西，不能得出更加本质的东西，至少对于那些想戒除坏习惯(积习多年)的人来说，或者想理性思考的人(关于什么是理性，估计现在也没有说清楚)来说， 起不到什么作用，因为你没有提出什么可行的方法来，这点估计作者也无法做到，为什么提不出来？因为这不属于作者的能力范围内的东西了，从这点来说，我觉得如果仅仅是一家之言，那没有问题，但是如果作者比较热，并且有很多人在读作者的东西，那么对于一些不会认真思考的人来说，没有什么好处。打个比方，就好像是说，如果没有把面向对象的设计程序的观念完全、彻底、深刻的搞清楚之前，就不要讲所谓的各种什么什么设计模式，讲什么继承与组合关联之类的东西，在对关系数据库所谓的“关系”二字完全深刻的理解清楚之前，就不要谈企业级应用中的面向领域对象建模与面向所谓的表建模之间哪个更好的问题，在对异常处理的机制、观念完全把握清楚之前，不要宣扬自己认为怎么怎么样，并且也误让不了解这东西的人认为是对的，并且按这个去想问题，去做程序，那就有点耽误人。再举个更不好的例子，不要在完全搞清楚微积分之前，就把所谓的生硬的证明放到教科书上，让学生看，那些所谓的教授都是这样出书的，当然也有少数有识之士不这样做。举个更计算机方面的东西，不要在没有386保护模式中计算机的内存体系结构的背景事实之下，就谈什么OS进程的地址空间问题，就谈什么C ++等面向对象语言中的无用对象不能自动收集等问题，如果不知道一些背景知识，不知道所研究的东西处于哪个大的体系之下，整天想某个点的东西，那简直是越搞越糟，除非能想到它的背景与根基，否则就不要把这种对事物不成熟、不正确的认识，贴出来，这样对看的人没有什么好处。会阻碍大家的进步，就好像下面这个例子，老北京杂酱面里的豆瓣酱可使人致癌，并且是从官方的质量总局发的公告，你说对于一些人来说会有怎么样的影响。网上的东西，一些新闻之类的东西可以看，但是好像在网上还真找不到什么深刻性的东西来，不要说重要的知识理论的探讨了，几乎没有，而技术性的东西，也是很多人在那儿胡说八道。</p>
<p>2010年3月19日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="wirx"></li>
</ul>
<p>wirx</p>
<p>这篇评论，真是混乱的思维，我居然看完了</p>
<p>2010年3月20日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="hi_lucky"></li>
</ul>
<p>hi_lucky</p>
<p>呵呵，我没有看完。
建议作者起码先分一下段。</p>
<p>2010年3月20日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://www.neugls.info/" title="neugls" target="_blank"><img src="" alt="neugls"></a></li>
</ul>
<p><a href="http://www.neugls.info/" target="_blank">neugls</a></p>
<p>我觉得你的评论与作者的博客一样，很精彩！</p>
<p>2011年3月19日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://www.neugls.info/" title="neugls" target="_blank"><img src="" alt="neugls"></a></li>
</ul>
<p><a href="http://www.neugls.info/" target="_blank">neugls</a></p>
<p>呵呵，我觉得这个评论思维不混乱，他想表达的意思我觉得应该是
要理解事物一本质！</p>
<p>2011年3月19日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="Snail"></li>
</ul>
<p>Snail</p>
<blockquote>
<p>就不要把这种对事物不成熟、不正确的认识，贴出来，这样对看的人没有什么好处
这篇文章从一般意义上的逻辑方面说是很严谨的（当然数学上不可能用Hilbert的形式化理论表示），如果从理论上彻底Perfect了，鹏大也就不需要让大家Comment了:-) 
所以说，认为作者只是自己的一些推断或是想像
鹏大的结论都是有实验根据的，比如各种心理学书籍中所提到的实验等。
关键是是否能从作者的想法(观点)中得到一些深刻的东西
这里就无赖一点吧，这么多的人都觉得或多或少学到了点东西，而阁下却没有呢，究竟是为什么捏。。。
当Carl Friedrich Gauss、Bernhard Riemann提出非欧几何时，Kant的粉丝们想到了什么深刻的东西呢？并且非欧几何本身就很混乱，存在有各种各样的非欧几何。
Nicolaus Copernicu的日心说似乎更为悲壮一些，他甚至没有一台望远镜，并且Ptolemy已经把他的理论完善到如此惨绝人寰的地步,以至于根本找不到和肉眼观测有任何不一致的地方。
直到N年后，人类才终于理解了，不认为其他星球都是以某种诡异的方式绕着地球转确实是一件令人愉快的事。这N年间，教皇以及下一代的教皇得到了什么深刻的东西呢？
阁下的评论确实很费解，我也来个莫名其妙的结束曲--
话说是《ヒカルの碁》中塔矢亮说的:How can you listen to anyone that you&#39;re disrespectful to ?</p>
</blockquote>
<p>2010年3月20日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="ffff"></li>
</ul>
<p>ffff</p>
<p>这个与disrespectful与respectful没有关系，正是因为我对作者文章中所言的东西作了认真的思考，并且对于
相关的学科或是领域有一定的分析，是我对作者观点的一种评论，是他的观点的一种观点，也是对科学的
一种观念。日心说这种观念无所谓对错，关键是他所引领的对于天体的持久的研究很重要，newton给出的关键
结论才是最重要的，最重要的是如何从日心说到开普勒的行星运动规律到newton的普遍适用的运行规律，
这个很重要，如果只是提出个日心说的观念，并且只是在那儿做哲学思辨，不去做更加深刻和具体的研究，
并且把哲学思辨让很多没有背景知识的人去玩赏(有些人会马上认为是对的)，这样只会越来越混乱，除非那
些读者也是很有科学背景的人，或不是科学背景，但是有自己对于世界运行方式的认识的人，才能清醒别人是在说什么，否则对于人们的生活，或是科学研究都没有什么好处。现在不是有很多所谓的科普吗？其实有很多
人被科普搞得越来越迷惑.</p>
<p>2010年3月20日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="ffff"></li>
</ul>
<p>ffff</p>
<p>另外，想问snail个问题，非欧几何究竟是说了个什么事儿呢？或者说非欧几何最本质的观念是什么？
因为我对微积分和数论之类的数学分支有一定的了解，对于非欧几何，不是很了解，只知道几个人们
经常说的非欧几何的几个经典的观念，但是没有把握到它比较本质的观念，所以，snail如果清楚的，麻烦
不吝赐教一下，有你认为是把本质说明白了的书也行，麻烦把书名告诉我，这样的话，我就不必再花费时间
找这些东西了。原因是我确实对非欧几何不了解，只是知道几个它的表面上的观念而已，所以我不能对你的
观点评论，也没有什么评论的，因为我说不出什么来，所以我得知道非欧几何究竟是说了个什么后，我才能
对你说的“并且非欧几何本身就很混乱”有所了解，才能判断这话有无道理，再有就是，只有真正的
理解那个东西的时候，才能真正描述好自己想表达的意思。(“并且非欧几何本身就很混乱”, 混乱是指它们
不正确，还是指不一致，还是别的什么意思，不太明白你的这句话，因为我所看到的一些资料说，非欧几何
产生的背景，就是对另一种空间形式的认识，无所谓混乱不混乱)</p>
<p>2010年3月20日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="Snail"></li>
</ul>
<p>Snail</p>
<p>不跟你玩了，自己找Bernhard Riemann去吧，总有一天你会见到他的，只是时间问题。学东西还要别人给你指点，你这人实在无趣的很:-P
though I believe it&#39;s not a sin,but that God just made you hardheaded.</p>
<p>2010年3月20日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="ffff"></li>
</ul>
<p>ffff</p>
<p><a href="">回复 Snail: </a>不要总把“学东西”挂在嘴上，你以为你学得那是真正的东西吗？我只是想听听你对非欧几何的
认识而已，你还真以为需要“你来指点”？找东西，找资料，这个对于一个一般人来说，都没有问题
吧？如果你对非欧几何了解的话，就请你用最简短并且又能表明它本质的话说出来，
如果你能说出来，我肯定会仔细的听着的，我不想同你在这儿费口水，还真不知道你对于数学的理解
能达到什么程度？你就尽管说吧!听了你的对于非欧几何的认识的话后，我就能确定，是我不跟你玩，还是你不跟我玩，呵呵!</p>
<p>2010年3月20日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="sxl-etr"></li>
</ul>
<p>sxl-etr</p>
<p>争论很有意思，都想让自己去说服别人，这也是人类造理论，提观念的原因。从做研究的角度来看，ffff的观点及论证更严谨，站的更高，在说一个问题时，我的观点是实验是很重要的，但是实验不是100%正确的，且都有其限制条件的，这些条件包括适用的范围、技术与科学的发展、采用的方法、工具、以及处理数据的方式等；面临的问题及问题的因由（历史）是很重要的，每种理论都不是真理，只是一种解释，这个大家应该都认可吧！？
刘未鹏对脑科学，人类的认知确实比较爱好，且掌握的资料比较全面，缺点是这些实验只是纸上得来，但不影响科普。人类认知背后的方程式太复杂了，变数太多了，组合的可能性太多了。
关于非欧几何，我感觉Snail既然对其发表评论了，确实应该好好去了解一下，于己于人都百利而无一害</p>
<p>2010年4月16日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="sb"></li>
</ul>
<p>sb</p>
<p>“
可以说是一种所谓的“精神劝说”或是类似于圣经的那种对人的一种指正，除了这些，没有看到其它的东西，不能得出更加本质的东西，至少对于那些想戒除坏习惯 (积习多年)的人来说，或者想理性思考的人(关于什么是理性，估计现在也没有说清楚)来说， 起不到什么作用，因为你没有提出什么可行的方法来
”
我怀疑fffff没有重视文中的链接,比如豆瓣中的评论,呵呵。</p>
<p>2010年5月19日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="阿斯"></li>
</ul>
<p>阿斯</p>
<p>μ牛B大了。μ牛B大了。μ牛B大了。μ牛B大了。μ牛B大了。μ牛B大了。μ牛B大了。μ牛B大了。μ牛B大了。μ牛B大了。</p>
<p>2010年3月19日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="wirx"></li>
</ul>
<p>wirx</p>
<p>我们的原始大脑同样也分不清什么是虚拟什么是真实，在获得社会成就和声望的动机的驱使下，即便是虚拟的网络游戏社会，我们也会投入大量精力，某种意义上我们的大脑并没有错，我们的确应该去获得声望，只“不过它还没有聪明到跟得上工业文明，它并不明白虚拟世界里面的生存能力和地位并没有办法转化为现实世界的生存能力和地位。”
这一段，有补充观点。
首先游戏也是有现实收益的，训练技能+社会群体流行文化+愉悦感+排解等
第二，就愉悦感这些精神状态本身而言，也是人群的现实追求，我的大脑代表的是当前躯体的整体利益，就细胞层面而言，当前的身体是不会考虑几十代以后的身体的需求的
再言，嗨和生存对大脑来说是同等重要的，嗨是大脑的工作目的，是让各个从属组织协调工作的指挥棒</p>
<p>2010年3月20日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="Snail"></li>
</ul>
<p>Snail</p>
<p>鹏大,帮个忙把小弟上面的几个回复删掉吧，麻烦老大了。
真是郁闷，为什么我总是有能力把别人引到跑题的深渊，上帝啊，我究竟是造了什么孽啊:-(</p>
<p>2010年3月20日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://www.douban.com/people/autumnleaf/" title="autumnkeaf" target="_blank"><img src="" alt="autumnkeaf"></a></li>
</ul>
<p><a href="http://www.douban.com/people/autumnleaf/" target="_blank">autumnkeaf</a></p>
<p>&quot;对此有这么一个真实事件（记不得在哪本心理学书上看到的了，记得的朋友请留言。），一个事业顺利的中年男人，原本过着典型的美国中产阶级的生活，但有一天不幸遭遇了车祸，车祸损伤了他的头部，他的情绪大脑遭到了损坏，后来虽然他健康方面痊愈了，然而却从此对任何事情都无动于衷，再没有动力去发展他的事业，照顾他的家庭，对他来说发生什么都是无所谓的。事实上，我们所谓的生活的意义便来源于情感系统。&quot; 
沒有看過 How we decide。不過考據癖補充一下，在&quot;讓大腦自由&quot;中 pp27頁也有一個類似的例子（有點疑問是不是其實同一個例子，某位作者記錯了）
www.douban.com/subject/4137809/
“大腦自由”中出事故的人叫做“菲尼亞斯 蓋奇 (Phineas Gage)“ ，在1868年工作中出現的爆炸事故損傷了他大部分前額葉皮層，雖然他活了下來，但變得笨拙衝動世俗，離開了家漫無目的四處遊蕩，換了一個又一個的工作－聽起來他也失去了對生活的情緒感受。
“大腦自由”中總結說這個事故表明前額葉皮層支配一些人類獨特的認知能力(解決問題，維持注意力並控制情感衝動)－這些能力大部分動物不俱備，連青少年都不俱備。
“菲尼亞斯 蓋奇“被無數書引用過，還包括 
生物心理学漫画笔记 www.douban.com/subject/3683002/
笛卡尔的错误 www.douban.com/subject/2157346/
搜索了一下，覺得這個引用Gage來分析情緒輿決策的關係的文章比較有意思，雖然未免有點牽強。
www.sciam.com.cn/html/shengming/shengmingaomi/2009/0730/5162.html
blog怕spam...如果有興趣深入討論腦科學，請提供一個方便使用的豆瓣小組吧－雖然我也只是入門階段。</p>
<p>2010年3月20日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://weibo.com/pongba" title="刘未鹏pongba" target="_blank"><img src="" alt="刘未鹏pongba"></a></li>
</ul>
<p><a href="http://weibo.com/pongba" target="_blank">刘未鹏pongba</a></p>
<p>感谢提供的信息， 很有用 <img src="&quot;:" alt=":)">&quot;)</p>
<p>2010年3月21日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="David"></li>
</ul>
<p>David</p>
<p>这篇文章我没有办法相信了. 我觉得作者被一些西方的邪门歪道的文章欺骗了.
实际上, 所谓的进化论有很多难以自圆其说的地方,不过中国引进的时候好像都忽略了. 现在人类那么复杂的大脑不是用一个简单的进化的说法就可以讲通的. 从奥卡姆剃刀原则我更愿意相信人是上帝创造的.</p>
<p>2010年3月20日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="jimbinc"></li>
</ul>
<p>jimbinc</p>
<p>个人理解：
大脑不断开发出新的模块来应对新的环境，同时在新的环境中需要的旧模块也会相应的加强。这是一个垂直进化（不断增加先进的模块，更多的功能）和水平进化（增强已有有用的模块）的过程。也因此，原始模块始终要优于现代模块，从而也解释大脑遵循用进废退的原则的原因。</p>
<p>2010年3月22日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="唏嘘12"></li>
</ul>
<p>唏嘘12</p>
<p>似乎从nlp角度说
动机和情绪总不会错 只是行为没有效果
情绪是却也是对问题的反应 想改变反应就要改变潜意识
也就是改变神经元网络</p>
<p>2010年3月22日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="bulage"></li>
</ul>
<p>bulage</p>
<p>终于更新了</p>
<p>2010年3月22日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="riven"></li>
</ul>
<p>riven</p>
<p>情感来自于我们远古的大脑，而理性源自于新进化的皮层。</p>
<p>2010年3月24日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://blogning.appspot.com/" title="张宁" target="_blank"><img src="" alt="张宁"></a></li>
</ul>
<p><a href="http://blogning.appspot.com/" target="_blank">张宁</a></p>
<p>“……在远古社会我们在向姑娘求爱的时候会小心谨慎……”
建议：“我们” -&gt; &quot;男子&quot; || &quot;男孩子&quot;，这样可以与“姑娘”形成对应。</p>
<p>2010年3月26日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="Raymond"></li>
</ul>
<p>Raymond</p>
<p>人们对现实有一些观察，对事实有一些研究，结合自己的推断和自己的生活经验，于是给出看似合理的结论。人们大脑里面有不同的区域这种说法我第一次碰到，不过想想生活中的种种情况，想想《梦的解析》里面关于潜意识的描述，也许这是某个本质问题的另外一种解释，我们还是没有探究到问题的根源。</p>
<p>2010年3月28日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="martin"></li>
</ul>
<p>martin</p>
<p>思辨的火花<figure class="highlight ~~~~"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
</pre></td><td class="code"><pre>
2010年3月29日[<span class="link_label">回复</span>](<span class="link_url"></span>)[<span class="link_label">顶</span>](<span class="link_url"></span>)[<span class="link_label">转发</span>](<span class="link_url"></span>)
<span class="bullet">* </span>![H]()

H

以宾格看待自己的缺陷比较容易上手。

2010年3月30日[<span class="link_label">回复</span>](<span class="link_url"></span>)[<span class="link_label">顶</span>](<span class="link_url"></span>)[<span class="link_label">转发</span>](<span class="link_url"></span>)
<span class="bullet">* </span>[<span class="link_label">![快乐购</span>](<span class="link_url"></span>)](<span class="link_url">http://www.goshishang.com/ "快乐购"</span>)

[<span class="link_label">快乐购</span>](<span class="link_url">http://www.goshishang.com/</span>)

对进化论这一学说一直都挺怀疑的

2010年4月6日[<span class="link_label">回复</span>](<span class="link_url"></span>)[<span class="link_label">顶</span>](<span class="link_url"></span>)[<span class="link_label">转发</span>](<span class="link_url"></span>)
<span class="bullet">* </span>[<span class="link_label">![不错</span>](<span class="link_url"></span>)](<span class="link_url">http://www.hot021.com/ "不错"</span>)

[<span class="link_label">不错</span>](<span class="link_url">http://www.hot021.com/</span>)

[<span class="link_label">热水器维修</span>](<span class="link_url">http://mindhacks.cn/2010/03/18/escape-from-your-shawshank-part3/www.hot021.com</span>)

2010年4月12日[<span class="link_label">回复</span>](<span class="link_url"></span>)[<span class="link_label">顶</span>](<span class="link_url"></span>)[<span class="link_label">转发</span>](<span class="link_url"></span>)
<span class="bullet">* </span>[<span class="link_label">![不错</span>](<span class="link_url"></span>)](<span class="link_url">http://www.zhurouwang.net/ "不错"</span>)

[<span class="link_label">不错</span>](<span class="link_url">http://www.zhurouwang.net/</span>)

[<span class="link_label">猪肉网</span>](<span class="link_url">http://www.zhurouwang.net/</span>)

2010年4月12日[<span class="link_label">回复</span>](<span class="link_url"></span>)[<span class="link_label">顶</span>](<span class="link_url"></span>)[<span class="link_label">转发</span>](<span class="link_url"></span>)
<span class="bullet">* </span>[<span class="link_label">![集趣</span>](<span class="link_url"></span>)](<span class="link_url">http://jeequ.com/ "集趣"</span>)

[<span class="link_label">集趣</span>](<span class="link_url">http://jeequ.com/</span>)

写的不错，可读性强！

2010年4月24日[<span class="link_label">回复</span>](<span class="link_url"></span>)[<span class="link_label">顶</span>](<span class="link_url"></span>)[<span class="link_label">转发</span>](<span class="link_url"></span>)
<span class="bullet">* </span>![elyse]()

elyse

理工科的同学思维还是比较理性和抽象.呵呵
[<span class="link_label">http://gogocat.taobao.com/</span>](<span class="link_url">http://gogocat.taobao.com/</span>)

2010年4月25日[<span class="link_label">回复</span>](<span class="link_url"></span>)[<span class="link_label">顶</span>](<span class="link_url"></span>)[<span class="link_label">转发</span>](<span class="link_url"></span>)
<span class="bullet">* </span>![愚兄]()

愚兄

一直关注你的博客，最近也在西格玛附近工作。希望有机会能认识一下，外面关于你的传说版本太多了！

2010年4月30日[<span class="link_label">回复</span>](<span class="link_url"></span>)[<span class="link_label">顶</span>](<span class="link_url"></span>)[<span class="link_label">转发</span>](<span class="link_url"></span>)
<span class="bullet">* </span>![牛魔王]()

牛魔王

情感中枢永远都不会被淘汰掉。因为很多事情根本就没有所谓正确答案，或者根本没有答案。遇到这些问题，只有理性怎么办？死机吗？哈哈

2010年5月5日[<span class="link_label">回复</span>](<span class="link_url"></span>)[<span class="link_label">顶</span>](<span class="link_url"></span>)[<span class="link_label">转发</span>](<span class="link_url"></span>)
<span class="bullet">* </span>[<span class="link_label">![阿飞</span>](<span class="link_url"></span>)](<span class="link_url">http://eeffee.com/ "阿飞"</span>)

[<span class="link_label">阿飞</span>](<span class="link_url">http://eeffee.com/</span>)

够长的，参考书目几乎全E文的

2010年5月22日[<span class="link_label">回复</span>](<span class="link_url"></span>)[<span class="link_label">顶</span>](<span class="link_url"></span>)[<span class="link_label">转发</span>](<span class="link_url"></span>)
<span class="bullet">* </span>[<span class="link_label">![Sefler</span>](<span class="link_url"></span>)](<span class="link_url">http://www.sefler.net/ "Sefler"</span>)

[<span class="link_label">Sefler</span>](<span class="link_url">http://www.sefler.net/</span>)

有道理。其实我有时候也觉得，有些思维过程不是主观控制的，比如你要跌倒里双手会自动伸出来。

2010年5月22日[<span class="link_label">回复</span>](<span class="link_url"></span>)[<span class="link_label">顶</span>](<span class="link_url"></span>)[<span class="link_label">转发</span>](<span class="link_url"></span>)
<span class="bullet">* </span>![球]()

球

很有收获。。。我只是想感谢你！

2010年6月7日[<span class="link_label">回复</span>](<span class="link_url"></span>)[<span class="link_label">顶</span>](<span class="link_url"></span>)[<span class="link_label">转发</span>](<span class="link_url"></span>)
<span class="bullet">* </span>![zhonyong]()

zhonyong

偶然的看到了博主的这篇文章.也把所有的评论全部看完了. 我有两个观点:
(1)我自己是认同博主的观点的.因为我之前读书的时候就有过这样的想法.朦朦胧胧的,似曾相识.
相信各位都清楚, 在高中的生物课本上,有一组人从受精卵到胎儿的进化图,不知道各位是怎么看待这个进化图的.
我清楚的记得,当时我的想法就是,这个短短的10月怀胎过程,就是整个生物界的一个演进的浓缩版. 每一个对应的时期,都有与之对应的某个历史阶段,而最终进化成了今天的人,所以婴儿也就进化到了今天的人的模样.
(2)关于假说,姑且叫作假说,虽然我更喜好叫想法. 的出处大致有两种途径:
一, 突然的灵感, 或者知觉使然. 这样的想法,使然在很多人身上是错误的,但是也有一些人却因此创造了太多的奇迹. 举一个不是很恰当的例子: 那些被称为天才的人,身上都有这样的特点.他们往往不要经过太多的思考,仅仅知觉或者简单的思考就得出最优的选择,而对此,一般的人却要进行反复的论证再论证,最终可能还是一样的结果. 李小龙,就在某些方面就是这样的一个天才.
二,所谓的严谨的推导,由此产生的有理有据的结论. 但是这样的结论多少有些鼠目寸光,毕竟自己没有太多的预见性,而仅仅是事实让自己往前一步一步的迈进. 
最后,我再大胆的对ffff的话作一些回复..
不要以为只有正真正确的真理才对人有益. 也不要大言不惭的说自己怎么怎么样, 所有对人有提示作用的文字就是正面积极的,所有有助于别人思考的文字都是有意义的. 世界上没有绝对的真理,如果真的有,那也早就是被公认,不需要你在这里面红耳赤的大叫大嚷了. 请学会尊重别人.

2010年6月20日[<span class="link_label">回复</span>](<span class="link_url"></span>)[<span class="link_label">顶</span>](<span class="link_url"></span>)[<span class="link_label">转发</span>](<span class="link_url"></span>)

<span class="bullet">* </span>![RiemannX]()

RiemannX

无知的家伙！你知道个什么？无知者无欲！

2010年12月8日[<span class="link_label">回复</span>](<span class="link_url"></span>)[<span class="link_label">顶</span>](<span class="link_url"></span>)[<span class="link_label">转发</span>](<span class="link_url"></span>)

<span class="bullet">* </span>![zhonyong]()

zhonyong

有无知就有有知,那敢问阁下是无知还是有知阿?
倘若你是有知,会说出上面的话吗? 连最基本的德都没有.可悲可叹!
如果你有不一样的观点,请指正, 有想法提出来,别在那里叽叽喳喳说不出一句像样的话.

2010年12月9日[<span class="link_label">回复</span>](<span class="link_url"></span>)[<span class="link_label">顶</span>](<span class="link_url"></span>)[<span class="link_label">转发</span>](<span class="link_url"></span>)
<span class="bullet">* </span>[<span class="link_label">![lancome gift with purchase</span>](<span class="link_url"></span>)](<span class="link_url">http://www.lancomegiftwithpurchase.com/ "lancome gift with purchase"</span>)

[<span class="link_label">lancome gift with purchase</span>](<span class="link_url">http://www.lancomegiftwithpurchase.com/</span>)

In one moment in my search, I find your site, and always return for here because enjoy it.

2010年6月21日[<span class="link_label">回复</span>](<span class="link_url"></span>)[<span class="link_label">顶</span>](<span class="link_url"></span>)[<span class="link_label">转发</span>](<span class="link_url"></span>)
<span class="bullet">* </span>![zomb]()

zomb

美国电影《Regarding Henry》：一个事业顺利的中年男人律师，原本过着典型的美国中产阶级的生活，但有一天不幸遭遇了劫匪，子弹损伤了他的心脏并伤害了头部，他的情绪大脑遭到了损坏，失去了绝大部分记忆和语言功能，后来虽然他健康方面痊愈了，然而却对自己的职业失去了兴趣，再没有动力去发展他的事业和认知这个离谱的职业和黑暗的社会，后来他彻底的变了个人，……。

2010年7月18日[<span class="link_label">回复</span>](<span class="link_url"></span>)[<span class="link_label">顶</span>](<span class="link_url"></span>)[<span class="link_label">转发</span>](<span class="link_url"></span>)
<span class="bullet">* </span>![joey]()

joey

老师，求求您了，您多一点耐心把这里的看完吧，我真的不知道该怎么办。我的情况是这样的，现在刚满17岁，因为之前读初中的时候一些其他因素没有上普通高中，而是去了一所职业高中，但是在高二的时候跑到了一个培训班去，培训的同时是在接受成人教育，毕业有个成教专科毕业证。现在上到CSDN的一些论坛上发现文凭的重要性质，如果是专科文凭的话工作不仅不好找，而且没有系统的学习过计算机知识（数学也不好）也不会有太大的发展潜力。
现在有两条路可以走，一重新回去读普通高中，因为才17岁。
二 继续读成教，在以后工作中花费更多的努力去参加自考（也不确信能够坚持下来。），来弥补自己的文凭上的欠缺，可以系统学习与计算机相关的知识为今后的发展打下更好的基础。
大概就是这样了，请老师指点一下吧，或者您有更好的办法。我真的感到无所适从，没有办法了才来打搅老师您的。
因为不知道如何得知老师您的回复，可不可以将回复发送到wangyuTAT@163.com。感谢老师。

2010年7月19日[<span class="link_label">回复</span>](<span class="link_url"></span>)[<span class="link_label">顶</span>](<span class="link_url"></span>)[<span class="link_label">转发</span>](<span class="link_url"></span>)

<span class="bullet">* </span>![hope]()

hope

小朋友，我个人觉得如果家庭条件允许的话，你应该回去读高中。虽然看起来走了点弯路，但你在高中一定比别的同学懂事，努力。 成功的机会也大一些。世界上走偏路成功的人固然存在，但都是比较少的一部分啊。祝你成功~

2011年12月1日[<span class="link_label">回复</span>](<span class="link_url"></span>)[<span class="link_label">顶</span>](<span class="link_url"></span>)[<span class="link_label">转发</span>](<span class="link_url"></span>)
<span class="bullet">* </span>![mssr]()

mssr

在网络上链到了你的C++罗浮宫，被《一直以来伴随我的一些学习习惯》一文深深折服，由此将你博客上的其他一些文章一一看过，虽然有些是看不懂的。
这个世界上，有两门学科是真正迷人的。一是物理学，它让我们了解我们所处的这个世界。二是心理学，它让我们了解自己。--我们长期以来的想法和感受，有一天将会被某个陌生人一语道破。
太葱白你了！为此，我决定学习C++，逛了很多论坛之后，我找到了5本相关的书籍，经师易求，人师难得啊。请刘大师指导指导！
![<span class="link_label">[1</span>]]( "[1]") 
深入浅出MFC(附光盘) (平装) 
~ 侯俊杰 (作者) 
![<span class="link_label">[2</span>]]( "[2]") 
C++ Primer中文版(第4版?特别版) (平装) 
~ 李普曼(Stanley B.Lippman) (作者), 拉茹瓦(Josée Lajoie) (作者), 穆(Barbara E.Moo) (作者), 李师贤 (译者), 蒋爱军 (译者), 梅晓勇 (译者), 等 (译者) 
![<span class="link_label">[3</span>]]( "[3]") 
C++程序设计语言(特别版) (平装) 
~ 斯特朗斯特鲁普 (作者), 裘中燕 (译者) 
![<span class="link_label">[4</span>]]( "[4]") 
Windows核心编程(第5版) (平装) 
~ 杰夫瑞 (Jeffrey Richter) (作者), 克里斯托夫 (Christophe Nasarre) (作者), 葛子昂 (译者), 周靖 (译者), 廖敏 (译者) 
![<span class="link_label">[5</span>]]( "[5]") 
Windows 程序设计：第5版（上下册）（附CD-ROM光盘一张）——Microsoft程序设计系列
~ [美]Charles Petzold (作者)

2010年7月26日[<span class="link_label">回复</span>](<span class="link_url"></span>)[<span class="link_label">顶</span>](<span class="link_url"></span>)[<span class="link_label">转发</span>](<span class="link_url"></span>)[<span class="link_label">举报</span>](<span class="link_url"></span>)
<span class="bullet">* </span>![武瑞敏]()

武瑞敏

我们对于很多事情的决策判断都刻画在天性里面，然而同样也正是这些天性在很多时候会让我们陷入困境，我们“能存储能量就尽量存储能量”的食物摄取天性虽然适合远古社会，然而在能量充裕的现代社会却导致大量人的超重。《How We Decide》上有这么一个有意思的实验：让一群人走过一个屋子，屋子的中间放着一个桌子，上面有诱人的巧克力蛋糕，也有水果沙拉，让其中一部分人默记某个7位数字序列，另一部分人则只默记2位数（当然，实验者会为默记数字的原因编造一个谎言，例如测试记忆能力），实验结果是，那些默记7位数字的人更可能选择巧克力蛋糕，因为记忆数字过载了我们的高级认知模块，使得它无暇和原始大脑的决定作抗争。
这个例子没看懂，他想表达什么？为什么是巧克力蛋糕呢？原始大脑能判断出巧克力蛋糕会提供更多的能量么？感觉这个有点牵强。
期待刘大回复

2010年8月4日[<span class="link_label">回复</span>](<span class="link_url"></span>)[<span class="link_label">顶</span>](<span class="link_url"></span>)[<span class="link_label">转发</span>](<span class="link_url"></span>)
<span class="bullet">* </span>[<span class="link_label">![abercrombie and fitch uk</span>](<span class="link_url"></span>)](<span class="link_url">http://www.abercrombiefitchhotsale.com/ "abercrombie and fitch uk"</span>)

[<span class="link_label">abercrombie and fitch uk</span>](<span class="link_url">http://www.abercrombiefitchhotsale.com/</span>)

太惊人了。二十万年前？什么概念？

2010年12月4日[<span class="link_label">回复</span>](<span class="link_url"></span>)[<span class="link_label">顶</span>](<span class="link_url"></span>)[<span class="link_label">转发</span>](<span class="link_url"></span>)
<span class="bullet">* </span>![老杨]()

老杨

期待《逃出你的肖申克4》

2010年12月8日[<span class="link_label">回复</span>](<span class="link_url"></span>)[<span class="link_label">顶</span>](<span class="link_url"></span>)[<span class="link_label">转发</span>](<span class="link_url"></span>)
<span class="bullet">* </span>![qumin]()

qumin

远古的时候应该是那些擅于思考、勤于思考的人能更好的生存 一直到现在也是 为什么那么长时间的进化 我们依旧有很强的思维惰性 更乐于做些简单 甚至是机械的事情（至少对于普通人是）？

2010年12月10日[<span class="link_label">回复</span>](<span class="link_url"></span>)[<span class="link_label">顶</span>](<span class="link_url"></span>)[<span class="link_label">转发</span>](<span class="link_url"></span>)
<span class="bullet">* </span>![hit_alex]()

hit_alex

全是心理学的东西啊
</pre></td></tr></table></figure></p>
<p>2010年12月24日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://duckweeds.blog.sohu.com/" title="ppjohnny" target="_blank"><img src="" alt="ppjohnny"></a></li>
</ul>
<p><a href="http://duckweeds.blog.sohu.com/" target="_blank">ppjohnny</a></p>
<p>从文章中的， &quot;《How We Decide》上有这么一个有意思的实验&quot; ，就是那个关于巧克力蛋糕的实现， 可以得到一个结论。 如果想在决策时，理性大脑占上风。 那个时段，大脑的信息就不能过载。
也就是，信息过载的状态，影响理性的决策。</p>
<p>2011年1月24日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="lumos"></li>
</ul>
<p>lumos</p>
<p>感谢博主深刻的思考,辗转从matrix67到这儿，收获很大~~</p>
<p>2011年1月27日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="Eating"></li>
</ul>
<p>Eating</p>
<h2 id="-60-60-30-">我们的大脑喜欢事情往积极方向发展，有这样一个实验：研究者让被试将手放在冰水中一段时间，有两个选项可供选择，一是将手放在非常冷的冰水中60秒并取出，另一是将手放在非常冷的冰水中60秒，然后再在逐渐变得不那么冰的冷水中放30秒再取出。绝大多数人认为第二种选择更为不那么痛苦。然而从经历的“客观”痛苦上讲，很明显第二种情况下人要受更多的罪。但是那种“情形正在变得越来越好”可以带来明显的正面情绪，于是第二种情况下的主观痛苦要小于第一种情况。</h2>
<p>我想有可能是我个人选择的问题，于是也问了别的朋友，但是我们都认为如果是我们参加这个实验，我们都倾向选择第一种，因为明显60秒后把手拿出去取暖会比再花上无谓的30秒后再拿出来要好很多。因此有些疑问，在这个实验中，真的大部分人会选择第二种么？
是不是描述上有一些遗漏呢？ 还是只是我们个人选择跟别人不同而已？</p>
<p>2011年3月11日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="yangscar"></li>
</ul>
<p>yangscar</p>
<p>我怀疑这个实验中并没有直接告诉被试实验持续的时间，而只是让他完成这两个不同的任务。</p>
<p>2011年12月26日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="aisensiy"></li>
</ul>
<p>aisensiy</p>
<p>嗯 很像那个 自我 本我 超我的说法，如何让超我的命令在自我层次得以实施是个重大的问题。</p>
<p>2011年4月3日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="skywildworld"></li>
</ul>
<p>skywildworld</p>
<p>这么多专业词汇，请问博主是怎么学英文的。
我也喜欢读原著，但是由于英文不好，总是一知半解，经常读到一半就不能坚持下去了。求指教。。。</p>
<p>2011年4月6日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="Fynwa"></li>
</ul>
<p>Fynwa</p>
<p>敢问如何使我们能更好的利用更为先进更为有效的认知模块？也就是如何学会像一些更会理性思考的人一样</p>
<p>2011年7月9日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="Greg"></li>
</ul>
<p>Greg</p>
<p>“这只是作者的定性的推断而已“、“精神劝说”两句是亮点，我也是这么感觉。
另外，从评论者不断堆砌的浮夸、不够深刻的引例可以大胆推测，该评论者当时是本科在读。不知是否如此，呵呵。</p>
<p>2011年7月12日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="avlee"></li>
</ul>
<p>avlee</p>
<p>我一直试图站在上面观察我。</p>
<p>2011年7月12日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://www.playgogo.net/" title="lanyg" target="_blank"><img src="" alt="lanyg"></a></li>
</ul>
<p><a href="http://www.playgogo.net/" target="_blank">lanyg</a></p>
<p>终于Update了，</p>
<p>2011年7月13日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="ALIBABASH"></li>
</ul>
<p>ALIBABASH</p>
<p>立意角度有新意，有启发性。但不知是否作者对神经和认知科学研究不深的原因，总觉得作者有种一知半解，牵强附会，为赋新诗强说愁的感觉！</p>
<p>2011年7月14日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="kmplayer"></li>
</ul>
<p>kmplayer</p>
<p>这段时间又有得学了。</p>
<p>2011年7月25日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="艾迪儿sun"></li>
</ul>
<p>艾迪儿sun</p>
<p>里面有很多心理学的知识，觉得文章很丰富，但是知识也很杂乱。</p>
<p>2011年8月9日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="lvlvbuaa"></li>
</ul>
<p>lvlvbuaa</p>
<p>mark之，最近才开始读你的文章，很有思想。持续关注中。。。</p>
<p>2011年9月24日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="张健飞"></li>
</ul>
<p>张健飞</p>
<p>这篇文章说了些大脑的结构和相应文章的出处，人的大脑处理有两种处理方式，理性与情绪。 理性是高级的认知，情绪是低级的。情绪能更快的处理事件，因为它位于大脑的底层，理性更客观，但总是受制于情绪。人可以通过训练使自己更理性 。。 。 。 看完，还是要写点东西的</p>
<p>2011年10月4日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="Xiaoyi"></li>
</ul>
<p>Xiaoyi</p>
<p>然而在现代社会，尤其是人口流动剧烈，人际关系变动频繁的大城市，社交失败的成本近乎于0，所以正确而理性的做法却是永远都勇敢地迈出第一步。
然而人行动的initiative和motivation往往源于情绪大脑和hypothalamus。</p>
<p>2011年11月12日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://blog.163.com/xmutzhengze/manage/?&amp;fromMail#m=0&amp;t=1" title="James" target="_blank"><img src="" alt="James"></a></li>
</ul>
<p><a href="http://blog.163.com/xmutzhengze/manage/?&amp;fromMail#m=0&amp;t=1" target="_blank">James</a></p>
<p>与20万年前的自己遇到当今信息如洪水般的社会会产生许多的缺点比较，现代思想的开放，激发更多的创新。</p>
<p>2012年2月17日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://www.doufumian.com/" title="豆腐面" target="_blank"><img src="" alt="豆腐面"></a></li>
</ul>
<p><a href="http://www.doufumian.com/" target="_blank">豆腐面</a></p>
<p>这么长的学术文章，居然也有这么多评论~~~</p>
<p>2012年7月3日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="iytbboy"></li>
</ul>
<p>iytbboy</p>
<p>看到这个系列的五，顺藤读到这里来。连续读了两天，最感兴趣、印象最深的部分就是人类社会的进化速度比身体的进化速度快这个理论——也许应该说是事实。站在这个基础上来审视周围的人和事，包括我自己，会形成一些完全不同的态度，宽容了很多。非常感谢。</p>
<p>2012年8月12日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://weibo.com/1986749031" title="楚星520" target="_blank"><img src="" alt="楚星520"></a></li>
</ul>
<p><a href="http://weibo.com/1986749031" target="_blank">楚星520</a></p>
<p>x恩恩 写的真的很好 让我涨了不少见识啊 谢谢smart is the new sexy。</p>
<p>2012年9月3日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://weibo.com/1986749031" title="楚星520" target="_blank"><img src="" alt="楚星520"></a></li>
</ul>
<p><a href="http://weibo.com/1986749031" target="_blank">楚星520</a></p>
<p>我们对于未来的惩罚和收益都估计不足，倾向于就眼下的损益进行决策。这就导致我们天性在决策方面目光短浅，一个典型的例子是我们会在大学阶段花费大量的时间去进行学习之外的娱乐，这些娱乐都有一个典型的特点，就是能够立即获得愉悦，并且并不会导致立即的损失。毕业看似遥遥无期，我们很难提前几年就设想几年后的危机，毕竟，未来的事情谁说得清呢？也许我们的远古生活告诉我们的真理就是，几年后的潜在收益跟眼下唾手可得的好处无法相比。</p>
<p>2012年9月3日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="lee"></li>
</ul>
<p>lee</p>
<p>如你所见，很多时候我们只是生活在信息社会的远古人，如果上帝要为我们目前生出的时代设计人类，我们将会是身体上适合长期久坐不见阳光，眼睛尤其适合长久盯着30厘米以内的物体看，我们情绪上会偏好有节制而健康的饮食，我们的身体发育将不会在肌肉上浪费太多不必要的能量，青少年也不会在青春期强烈渴望冒险和建立小部落内的声望并为之做出各种危险或可怕的事情，而在执行力上我们则会偏好于执行能够积累知识和技能的长远计划，正如geeks们所崇尚的一句话所言：smart is the new sexy。
——以上这个设计人类的方式是如何得出的，为什么这样才是适应现代信息社会的人类。这是不是依照自己的所需来设计了呢</p>
<p>2012年10月1日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="xx"></li>
</ul>
<p>xx</p>
<p>那么，200万年前，左脑在干什么？那时候没有左脑吗？</p>
<p>2012年10月27日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://weibo.com/zdx3578" title="zdx3578" target="_blank"><img src="" alt="zdx3578"></a></li>
</ul>
<p><a href="http://weibo.com/zdx3578" target="_blank">zdx3578</a></p>
<p>是不是在心理学方面做更大的贡献，推荐一些书引进国内翻译，推动国内的心理学相关普及；和乐嘉交流交流。</p>
<p>2012年12月2日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://weibo.com/suqierhz" title="苏小叫化" target="_blank"><img src="" alt="苏小叫化"></a></li>
</ul>
<p><a href="http://weibo.com/suqierhz" target="_blank">苏小叫化</a></p>
<p>《思考，快与慢》分之为快思考和慢思考，书里认为直觉也只是慢思考训练出来的，和本能还是有很大的不同。不过这书我才只看了个开头。</p>
<p>2012年12月13日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://weibo.com/moxiaoxing" title="韩荆菁" target="_blank"><img src="" alt="韩荆菁"></a></li>
</ul>
<p><a href="http://weibo.com/moxiaoxing" target="_blank">韩荆菁</a></p>
<p>推荐</p>
<p>1月18日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://www.renren.com/profile.do?id=246743213" title="周全♪" target="_blank"><img src="" alt="周全♪"></a></li>
</ul>
<p><a href="http://www.renren.com/profile.do?id=246743213" target="_blank">周全♪</a></p>
<p>（三）</p>
<p>6月20日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://www.renren.com/profile.do?id=246743213" title="周全♪" target="_blank"><img src="" alt="周全♪"></a></li>
</ul>
<p><a href="http://www.renren.com/profile.do?id=246743213" target="_blank">周全♪</a></p>
<p>（三）重新分享一下</p>
<p>6月20日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
]]></content>
    
    
      <category term="好文摘录" scheme="http://itsolife.com/categories/%E5%A5%BD%E6%96%87%E6%91%98%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何理解当代中国]]></title>
    <link href="http://itsolife.com/2014/02/03/2014-02-03--%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%BD%93%E4%BB%A3%E4%B8%AD%E5%9B%BD----%E3%80%8A%E5%8D%81%E4%BA%BF%E6%B6%88%E8%B4%B9%E8%80%85%E3%80%8B%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
    <id>http://itsolife.com/2014/02/03/2014-02-03--如何理解当代中国----《十亿消费者》读后感/</id>
    <published>2014-02-03T03:24:28.000Z</published>
    <updated>2014-03-07T03:24:28.000Z</updated>
    <content type="html"><![CDATA[<h1 id="-">如何理解当代中国----《十亿消费者》读后感</h1>
<p>作者： <a href="http://www.ruanyifeng.com/" target="_blank">阮一峰</a> </p>
<p>日期： <a href="http://www.ruanyifeng.com/blog/2013/05/" target="_blank">2013年5月21日</a> （网址：<a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html" target="_blank"><a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html">http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html</a></a>）</p>
<p>前几天，我读完的美国人 <a href="http://en.wikipedia.org/wiki/James_L._McGregor" target="_blank">James McGregor</a> 写的《<a href="http://book.douban.com/subject/2791877/" target="_blank">十亿消费者</a>》（<a href="http://www.onebillioncustomers.com/" target="_blank">One Billion Customers</a>）。</p>
<p><img src="" alt=""></p>
<p>James McGregor 本来是《华尔街日报》和道琼斯集团在华负责人，后来辞职经商。为了对记者生涯做总结，他就写了这本书，让西方人了解如何在中国做生意。</p>
<p><img src="" alt=""></p>
<p>在书中，他通过对一些涉及高层的案例介绍，披露了中国政府商业管理的内幕，对中国社会有精准深刻的分析。很难相信，一个外国人如此懂中国。</p>
<p>我认为，对于想在中国经商的人，这本书是必读的。尤其是如何处理与中国政府的商业关系，大概很难找到比它更好的读物了。</p>
<p>此书不太可能在国内正式出版，译言网有一个网友翻译的<a href="http://group.yeeyan.org/translations/one-billion-consumers" target="_blank">中文版</a>，质量相当好，推荐阅读。</p>
<p>下面就是我整理的一些摘录。</p>
<p>========================================</p>
<p><strong>《十亿消费者》摘录</strong></p>
<p>作者： [美] James McGregor</p>
<p><img src="" alt=""></p>
<p>（题图：<a href="http://article.yeeyan.org/view/168647/150280" target="_blank">刘勃麟</a>的 Hiding in the City 系列）</p>
<p><strong>一、 中国文化</strong></p>
<p>1.</p>
<p>贤明君主自上而下的管理，是中国数千年社会秩序的基础。直到今天，也是中国普遍流行的商业管理模式。</p>
<p>2.</p>
<p>中国文化的核心，就是追求和谐，哪怕这种和谐是表面的。</p>
<p>3.</p>
<p>中国文化提倡，个人追求恭顺和礼仪，接受来自上层的命令和决策。</p>
<p>4.</p>
<p>中国儿童在生活中学到的第一课就是纪律，家长教育孩子遵守纪律。</p>
<p>5.</p>
<p>中国文化提倡克制、克制、再克制。</p>
<p>6.</p>
<p>中国人习惯服从领导。领导人可以对所有问题下命令，甚至包括下属的家庭矛盾。</p>
<p>7.</p>
<p>由于推崇稳定和强调服从，中国人对那些充满魅力、照顾属下、发号施令的领袖惟命是从。</p>
<p>8.</p>
<p>中国人的这种服从性格，在制造业中颇有成效。但是一旦走出国门，或者进入需要更具创造力的领域如研发，中国模式的缺点就暴露无遗。</p>
<p>9.</p>
<p>什么是中国公司中最常见的四个字？&quot;听领导的！&quot;</p>
<p><strong>二、 重视稳定和秩序</strong></p>
<p>10.</p>
<p>中国政府最重视的，就是稳定和秩序。</p>
<p>11.</p>
<p>不管能否控制，中国政府假装一切皆在控制之中。</p>
<p>12.</p>
<p>任何敢于公开与政府对抗的人，都将在国家稳定的名义下遭到无情镇压。</p>
<p>13.</p>
<p>想在中国生存，你不能让这个体制感到为难。</p>
<p>14.</p>
<p>如果想要打击对手，你可以把对手描绘成破坏体制的人。</p>
<p>15.</p>
<p>与中国政府产生矛盾时，你要说明你公司的业务是如何有利于中国，而不是政府如何错了。你不能让人觉得体制很差。</p>
<p>16.</p>
<p>为了维持表面上的秩序，中国人的行为准则，不是有没有内疚，而是会不会被揭露。</p>
<p>17.</p>
<p>只要不被抓住，中国人做任何事都可以心安理得。在这种环境下，政府不得不变得强权和无所不在，加大你作恶之后被抓住的可能。</p>
<p>18.</p>
<p>中国的法律假设，一切皆在政府控制之下，除非法律明文允许，否则你做的事情都是不合法的。而美国法律假设，政府不得干涉人民自由，除非法律明文禁止，否则你可以做任何事情。</p>
<p>19.</p>
<p>为什么中国的交通很乱？因为各种政治压制和社会控制的存在，中国人把油门和方向盘当作发泄工具。</p>
<p><strong>三、 教育和思想控制</strong></p>
<p>20.</p>
<p>中国教育体制培养出来的人是被领导的，而不是领导别人。</p>
<p>21.</p>
<p>这种教育体制的结果，就是强大但却缺乏主动的劳动力大军，而创新性的商业领袖和各种经理人非常之少。</p>
<p>22.</p>
<p>教育在中国是最大的优势，也是最大的劣势。</p>
<p>23.</p>
<p>中国人记忆超群，精于数学，安于枯燥冗长工作。但是死记硬背的教育体系大大削弱了人们的分析和领导能力。</p>
<p>24.</p>
<p>为了维持秩序，中国政府对信息和思想实施控制。这样必然会扼杀创新。</p>
<p>25.</p>
<p>政府相信必须控制信息才能保住权力，但是中国需要公民掌握充分的信息，才能在全球经济中竞争。这使得媒体得以探索自己的笼子到底有多大。</p>
<p>26.</p>
<p>自由意味着知道你自己的笼子有多大。</p>
<p><strong>四、 官员的务实性</strong></p>
<p>27.</p>
<p>表面上要维护秩序，但实际上，为了有效管理国家，中国政府官员在效率和私人问题上是非常务实的。</p>
<p>28.</p>
<p>从高级到基层的党政官员，满嘴都是最新的口号，但是一旦这些官方的政治反刍完毕，谈话立刻就转到经商。</p>
<p>29.</p>
<p>对于大多数中国官员来说，生活的准则就是&quot;指鹿为马&quot;。说的是一套，做的是另一套，因为否则就会威胁到整个体制的稳定。</p>
<p>30.</p>
<p>由于这种两面性的存在，中国的反腐收效甚微，因为整个体制与诚实正直格格不入。</p>
<p>31.</p>
<p>中国政府在决策和处理与人民关系的时候，更像在经营一家公司。就像在公司里一样，党的高层有一些民主，但是在基层则几乎没有。</p>
<p>32.</p>
<p>由于人民不相信政府，政府只能通过促进经济增长，来保持威信。加快经济发展速度，政府只有两个药方：私有化和大量投资。</p>
<p>33.</p>
<p>中国政府喜欢那些能帮助国家解决困难的公司。</p>
<p><strong>五、 重视金钱利益</strong></p>
<p>34.</p>
<p>对政治体系的不信任、腐败、快速的形势变化，又没有社会保障，一切让中国人惴惴不安。大家都觉得，获得安全感的唯一方法，就是快速获得财富。</p>
<p>35.</p>
<p>很多中国人只信任钱。</p>
<p>36.</p>
<p>在葬礼上，一个核心环节就是烧纸钱，给死人送去资产。</p>
<p>37.</p>
<p>在婚礼上，来宾们在公然注视下，排队送礼金，每个人的信封被撕开、清点、并纪录下来。</p>
<p>38.</p>
<p>由于急于致富，除非被迫，否则没有人会排队。每个人都拼命往前挤。这也是商业的运作模式。</p>
<p>39.</p>
<p>快速致富的必然推论是&quot;谁也不要相信&quot;。中国人对体制、对陌生人有着深深的不信任。结果就是商业环境中到处是不诚实。</p>
<p>40.</p>
<p>中国人之间毫无信任可言。在中国做买卖，人们的预期就是对方会骗自己。</p>
<p>41.</p>
<p>中国社会是自私的。中国人竞争能力很强，合作能力很弱。</p>
<p>42.</p>
<p>中国人是全世界最自我、最自私的民族之一。</p>
<p>43.</p>
<p>单个来说，中国人是凶猛可怕的商人。但是，中国人很难组建大型组织，这样的组织需要人们分享观点、平等共处。</p>
<p>44.</p>
<p>在中国，你要么有钱，要么听话。</p>
<p><strong>六、 人际关系与法律</strong></p>
<p>45.</p>
<p>因为表面上需要维持秩序，而实际上又是另一套做法，所以，人际关系在中国社会的重要性，远大于西方。</p>
<p>46.</p>
<p>法律和合同的规定，不如人际关系重要。</p>
<p>47.</p>
<p>在中国做生意，不要完全依赖于法律，你会输的。法律只是你商业行为的一种论据。</p>
<p>48.</p>
<p>中国人事部门主管的权力远高过西方，因为那些被录用的人往往对他们心怀感激。</p>
<p>49.</p>
<p>机会来自和有权有势的人的交往。</p>
<p>50.</p>
<p>在这个需要和层层官僚及个人利益打交道的国家，单靠个人能力是无法成事的。</p>
<p>51.</p>
<p>在一个缺乏公平和公正的法律体系中，你的人际网络能确保你的安全。</p>
<p>52.</p>
<p>商业公司如果不把政府关系当作业务最关键的一部分，那么它的业务就会出现问题。</p>
<p>53.</p>
<p>在中国，市场总能取得胜利。</p>
<p>54.</p>
<p>亲吻干部，拥抱客户。</p>
<p>（完）</p>
<h3 id="-">文档信息</h3>
<ul>
<li>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank">Creative Commons BY-NC-ND 3.0</a></li>
<li>原文网址：<a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html" target="_blank"><a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html">http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html</a></a></li>
<li>最后修改时间：2013年6月14日 21:41</li>
<li>付费支持：<a href="https://me.alipay.com/ruanyf" target="_blank"><img src="&quot;人民币&quot;" alt="人民币 - 支付宝"></a> | <a href="https://www.paypal.com/cgi-bin/webscr?cmd=_xclick&amp;business=yifeng.ruan@gmail.com&amp;currency_code=USD&amp;amount=0.99&amp;return=http://www.ruanyifeng.com/thank.html&amp;item_name=Ruan%20YiFeng&#39;s%20Blog&amp;undefined_quantity=1&amp;no_note=0" target="_blank"><img src="&quot;美元&quot;" alt="美元 - paypal"></a></li>
</ul>
<p><a href="http://www.hi-vps.com/?utm_source=ruanyifeng.com"></a></p>
<h2 id="-">相关文章</h2>
<ul>
<li><strong>2013.04.09: <a href="http://www.ruanyifeng.com/blog/2013/04/entropy.html" target="_blank">熵的社会学意义</a></strong></li>
</ul>
<ol>
<li>上周，我读完了《熵：一种新的世界观》。</li>
</ol>
<ul>
<li><strong>2013.03.08: <a href="http://www.ruanyifeng.com/blog/2013/03/apple_inc_and_division_of_labor.html" target="_blank">苹果公司与分工原理</a></strong></li>
</ul>
<p>我终于读完了《乔布斯传》。这是一本好书，我应该早点读的。</p>
<h2 id="-">功能链接</h2>
<ul>
<li><strong>前一篇：</strong><a href="http://www.ruanyifeng.com/blog/2013/05/jquery-free.html" target="_blank">如何做到 jQuery-free？</a></li>
<li><strong>后一篇：</strong><a href="http://www.ruanyifeng.com/blog/2013/06/emmet_and_haml.html" target="_blank">HTML代码简写法：Emmet和Haml</a></li>
<li><strong>更多内容请访问：</strong><a href="http://www.ruanyifeng.com/blog/" target="_blank">首页</a> » <a href="http://www.ruanyifeng.com/blog/archives.html" target="_blank">档案</a> » <a href="http://www.ruanyifeng.com/blog/books/" target="_blank">读书</a></li>
<li><strong>站内搜索：</strong> </li>
<li><strong>Feed订阅：</strong> <a href="http://feeds.feedburner.com/ruanyifeng" target="_blank"><img src="" alt=""></a><h2 id="-http-www-ruanyifeng-com-ads-html-">广告<a href="http://www.ruanyifeng.com/ads.html" target="_blank">（购买广告位）</a></h2>
</li>
</ul>
<p><a href="http://www.ushan.cn/?act=suit" target="_blank"><img src="" alt=""></a></p>
<h2 id="-54-">留言（54条）</h2>
<p><a href="http://bulaoge.net/?ilovesuede" title="http://bulaoge.net/?ilovesuede" target="_blank">微蓝</a> 说：</p>
<p>要么有钱，要么听话……</p>
<p>p.s.这是沙发么……
<a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-271647" target="_blank">2013年5月21日 11:39</a> | <a href="http://www.ruanyifeng.com/blog/user/%E5%BE%AE%E8%93%9D.html" title="微蓝的全部留言" target="_blank">档案</a> | <a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-text" title="引用微蓝的这条留言" target="_blank">引用</a></p>
<p>某某读者 说：</p>
<p>很喜欢读你的博客，文章真实但不残酷。这个世界很美好，这个世界很丑陋。或者，这个世界很精彩（无论是美的，还是丑的）
<a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-271648" target="_blank">2013年5月21日 11:44</a> | <a href="http://www.ruanyifeng.com/blog/user/%E6%9F%90%E6%9F%90%E8%AF%BB%E8%80%85.html" title="某某读者的全部留言" target="_blank">档案</a> | <a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-text" title="引用某某读者的这条留言" target="_blank">引用</a>
betwinyou 说：</p>
<p>有才啊。文章让我更理解现在的中国
<a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-271649" target="_blank">2013年5月21日 11:54</a> | <a href="http://www.ruanyifeng.com/blog/user/betwinyou.html" title="betwinyou的全部留言" target="_blank">档案</a> | <a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-text" title="引用betwinyou的这条留言" target="_blank">引用</a></p>
<p>dYb 说：</p>
<p>社会环境如此，有好处，必然也有坏处。
<a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-271650" target="_blank">2013年5月21日 11:56</a> | <a href="http://www.ruanyifeng.com/blog/user/dYb.html" title="dYb的全部留言" target="_blank">档案</a> | <a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-text" title="引用dYb的这条留言" target="_blank">引用</a>
<a href="http://kongxz.com/" title="http://kongxz.com/" target="_blank">kmxz</a> 说：</p>
<p>确确实实鞭辟入里，观察透彻
<a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-271651" target="_blank">2013年5月21日 12:31</a> | <a href="http://www.ruanyifeng.com/blog/user/kmxz.html" title="kmxz的全部留言" target="_blank">档案</a> | <a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-text" title="引用kmxz的这条留言" target="_blank">引用</a></p>
<p>Hongye 说：</p>
<p>大部分都是缺点或不好的方面。嗨。有的也不仅限于中国。
<a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-271652" target="_blank">2013年5月21日 12:46</a> | <a href="http://www.ruanyifeng.com/blog/user/Hongye.html" title="Hongye的全部留言" target="_blank">档案</a> | <a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-text" title="引用Hongye的这条留言" target="_blank">引用</a>
alex 说：</p>
<p>深刻的吐槽，但是担心被...
<a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-271653" target="_blank">2013年5月21日 12:48</a> | <a href="http://www.ruanyifeng.com/blog/user/alex.html" title="alex的全部留言" target="_blank">档案</a> | <a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-text" title="引用alex的这条留言" target="_blank">引用</a></p>
<p><a href="http://s5s5.me/" title="http://s5s5.me" target="_blank">s5s5</a> 说：</p>
<p>亲吻干部，拥抱客户。
<a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-271654" target="_blank">2013年5月21日 12:54</a> | <a href="http://www.ruanyifeng.com/blog/user/s5s5.html" title="s5s5的全部留言" target="_blank">档案</a> | <a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-text" title="引用s5s5的这条留言" target="_blank">引用</a>
[0,1] 说：</p>
<p>应该说，这些东西并非新鲜，只要你关注，这些东西中国公知都告诉你了。相比中国公知而言，该书作者言论显得柔和多了。</p>
<p>54点多数都是模糊观点，对之不可能绝对同意或者反对。这模糊的东西也有不少不是中国所特有的，而是举世皆然的东西。</p>
<p>人到了一定年纪，看问题还是如此模糊、极端；或者换一个视角，这样模糊甚至极端的言论有更多的人认同，这也是极为悲哀的。</p>
<p>中国确实问题多多，但也不是54点描述的这样非人类。我相信，中国的艰难前进，能够影响世界，必然有他的大量优点。
<a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-271657" target="_blank">2013年5月21日 13:31</a> | <a href="http://www.ruanyifeng.com/blog/user/[0,1].html" title="[0,1]的全部留言" target="_blank">档案</a> | <a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-text" title="引用[0,1]的这条留言" target="_blank">引用</a></p>
<p>Timesand 说：</p>
<p>太经典了！就是这么回事！
<a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-271663" target="_blank">2013年5月21日 14:54</a> | <a href="http://www.ruanyifeng.com/blog/user/Timesand.html" title="Timesand的全部留言" target="_blank">档案</a> | <a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-text" title="引用Timesand的这条留言" target="_blank">引用</a>
lagolas 说：</p>
<p>书中的观点好像很极端，几乎没有一句好话，都是些陈词滥调，真是无趣。只是把外国人对中国的批评汇总了一下。动不动就说中国人就会死记硬背，不懂创新。
<a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-271664" target="_blank">2013年5月21日 14:56</a> | <a href="http://www.ruanyifeng.com/blog/user/lagolas.html" title="lagolas的全部留言" target="_blank">档案</a> | <a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-text" title="引用lagolas的这条留言" target="_blank">引用</a></p>
<p>若水 说：</p>
<p>那话怎么说的，宁愿信什么什么，别信媒体人那张嘴。这货坑美国自己人的，都这样子了，60年能把经济搞到世界第二，一定是火星人在帮中国
<a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-271665" target="_blank">2013年5月21日 15:12</a> | <a href="http://www.ruanyifeng.com/blog/user/%E8%8B%A5%E6%B0%B4.html" title="若水的全部留言" target="_blank">档案</a> | <a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-text" title="引用若水的这条留言" target="_blank">引用</a>
gj1827 说：</p>
<p>引用若水的发言：</p>
<p>那话怎么说的，宁愿信什么什么，别信媒体人那张嘴。这货坑美国自己人的，都这样子了，60年能把经济搞到世界第二，一定是火星人在帮中国</p>
<p>占世界1/5的人口，经济不是世界第一才是怪闻。
<a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-271669" target="_blank">2013年5月21日 17:14</a> | <a href="http://www.ruanyifeng.com/blog/user/gj1827.html" title="gj1827的全部留言" target="_blank">档案</a> | <a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-text" title="引用gj1827的这条留言" target="_blank">引用</a></p>
<p>密斯颜 说：</p>
<p>观点犀利
<a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-271673" target="_blank">2013年5月21日 18:43</a> | <a href="http://www.ruanyifeng.com/blog/user/%E5%AF%86%E6%96%AF%E9%A2%9C.html" title="密斯颜的全部留言" target="_blank">档案</a> | <a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-text" title="引用密斯颜的这条留言" target="_blank">引用</a>
Whiskier 说：</p>
<p>引用gj1827的发言：</p>
<p>占世界1/5的人口，经济不是世界第一才是怪闻。</p>
<p>印度人咧？
<a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-271674" target="_blank">2013年5月21日 19:55</a> | <a href="http://www.ruanyifeng.com/blog/user/Whiskier.html" title="Whiskier的全部留言" target="_blank">档案</a> | <a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-text" title="引用Whiskier的这条留言" target="_blank">引用</a></p>
<p><a href="http://www.cyfseo.com/" title="http://www.cyfseo.com" target="_blank">陈羽凡</a> 说：</p>
<p>真的说到一针见血哈！
<a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-271677" target="_blank">2013年5月21日 20:58</a> | <a href="http://www.ruanyifeng.com/blog/user/%E9%99%88%E7%BE%BD%E5%87%A1.html" title="陈羽凡的全部留言" target="_blank">档案</a> | <a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-text" title="引用陈羽凡的这条留言" target="_blank">引用</a>
<a href="http://blog.sina.com.cn/laoguo2" title="http://blog.sina.com.cn/laoguo2" target="_blank">laoguo</a> 说：</p>
<p>中国是地球上典型的＂服务自我的社会＂。连听都没听过这种说法的中国人以后在研究＂服务自我的社会＂和＂服务他者的社会＂之间在学术上的定义和表现上的区别的时候，会有得天独厚的理解上的优势。
<a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-271678" target="_blank">2013年5月21日 21:03</a> | <a href="http://www.ruanyifeng.com/blog/user/laoguo.html" title="laoguo的全部留言" target="_blank">档案</a> | <a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-text" title="引用laoguo的这条留言" target="_blank">引用</a></p>
<p>吴佳斌 说：</p>
<p>跟彼得·海斯勒的中国纪实三部曲一样好看
<a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-271679" target="_blank">2013年5月21日 21:53</a> | <a href="http://www.ruanyifeng.com/blog/user/%E5%90%B4%E4%BD%B3%E6%96%8C.html" title="吴佳斌的全部留言" target="_blank">档案</a> | <a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-text" title="引用吴佳斌的这条留言" target="_blank">引用</a>
waveacme 说：</p>
<p>不得不说，他很了解中国。
<a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-271680" target="_blank">2013年5月21日 22:30</a> | <a href="http://www.ruanyifeng.com/blog/user/waveacme.html" title="waveacme的全部留言" target="_blank">档案</a> | <a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-text" title="引用waveacme的这条留言" target="_blank">引用</a></p>
<p>iyutao 说：</p>
<p>是很精准的描述了当下中国的环境氛围，国与国的交往似个人与个人的交往，受个人的背景、品格等等因素影响，所以我开始以此来反思自己
<a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-271683" target="_blank">2013年5月22日 08:52</a> | <a href="http://www.ruanyifeng.com/blog/user/iyutao.html" title="iyutao的全部留言" target="_blank">档案</a> | <a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-text" title="引用iyutao的这条留言" target="_blank">引用</a>
Tony Stark 说：</p>
<p>看后真的是感觉无力又无耐！但不管如何，身在这样的社会当中，你要适应并利用他，为你创造价值。
我们没有安全感，即使你有很多钱，因为我们没有自我保护的方式，我们现在所拥有的，都很有可能在下一刻就被剥夺！筒子们，移民吧
<a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-271684" target="_blank">2013年5月22日 09:27</a> | <a href="http://www.ruanyifeng.com/blog/user/Tony%20Stark.html" title="Tony Stark的全部留言" target="_blank">档案</a> | <a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-text" title="引用Tony Stark的这条留言" target="_blank">引用</a></p>
<p><a href="http://blog.bomoo.com/pin/" title="http://blog.bomoo.com/pin/" target="_blank">pin</a> 说：</p>
<p>这本很早在译言上看到，放在kindle里，一直读不完。往往是看了后面忘了前面讲啥。
<a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-271685" target="_blank">2013年5月22日 10:04</a> | <a href="http://www.ruanyifeng.com/blog/user/pin.html" title="pin的全部留言" target="_blank">档案</a> | <a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-text" title="引用pin的这条留言" target="_blank">引用</a>
lking 说：</p>
<p>说的太好了！！！！ 狂赞！
<a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-271686" target="_blank">2013年5月22日 11:03</a> | <a href="http://www.ruanyifeng.com/blog/user/lking.html" title="lking的全部留言" target="_blank">档案</a> | <a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-text" title="引用lking的这条留言" target="_blank">引用</a></p>
<p>阿斯大声的 说：</p>
<p>印度是奇葩
<a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-271687" target="_blank">2013年5月22日 11:10</a> | <a href="http://www.ruanyifeng.com/blog/user/%E9%98%BF%E6%96%AF%E5%A4%A7%E5%A3%B0%E7%9A%84.html" title="阿斯大声的的全部留言" target="_blank">档案</a> | <a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-text" title="引用阿斯大声的的这条留言" target="_blank">引用</a>
<a href="http://service.weibo.com/reg/ajaxlogin.php?framelogin=1&amp;callback=parent.sinaSSOController.feedBackUrlCallBack" title="http://service.weibo.com/reg/ajaxlogin.php?framelogin=1&amp;callback=parent.sinaSSOController.feedBackUrlCallBack" target="_blank">cctv</a> 说：</p>
<p>在中国，你要么有钱，要么听话。
<a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-271688" target="_blank">2013年5月22日 11:58</a> | <a href="http://www.ruanyifeng.com/blog/user/cctv.html" title="cctv的全部留言" target="_blank">档案</a> | <a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-text" title="引用cctv的这条留言" target="_blank">引用</a></p>
<p>zhouzhou2043 说：</p>
<p>人性本身如此，只是我们希望的太多了，徒增痛苦，阮兄何必。
<a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-271689" target="_blank">2013年5月22日 12:17</a> | <a href="http://www.ruanyifeng.com/blog/user/zhouzhou2043.html" title="zhouzhou2043的全部留言" target="_blank">档案</a> | <a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-text" title="引用zhouzhou2043的这条留言" target="_blank">引用</a>
<a href="http://www.dubbofeng.com/" title="http://www.dubbofeng.com" target="_blank">冯大宝</a> 说：</p>
<p>其实这也不是理解当代中国的方法，就像James McGregor说的，这些规则在中国已经适用上千年了。
<a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-271690" target="_blank">2013年5月22日 14:23</a> | <a href="http://www.ruanyifeng.com/blog/user/%E5%86%AF%E5%A4%A7%E5%AE%9D.html" title="冯大宝的全部留言" target="_blank">档案</a> | <a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-text" title="引用冯大宝的这条留言" target="_blank">引用</a></p>
<p>兵马 说：</p>
<p>引用若水的发言：</p>
<p>那话怎么说的，宁愿信什么什么，别信媒体人那张嘴。这货坑美国自己人的，都这样子了，60年能把经济搞到世界第二，一定是火星人在帮中国</p>
<p>改革了，开放了，朝鲜，越南也可以把经济搞上去，一定是火星人折腾了我们前30年。
<a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-271695" target="_blank">2013年5月22日 18:02</a> | <a href="http://www.ruanyifeng.com/blog/user/%E5%85%B5%E9%A9%AC.html" title="兵马的全部留言" target="_blank">档案</a> | <a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-text" title="引用兵马的这条留言" target="_blank">引用</a>
<a href="http://imoshui.blog.163.com/" title="http://imoshui.blog.163.com" target="_blank">墨水</a> 说：</p>
<p>很难相信，一个外国人如此懂中国。对中国国情呵呵一笑，扬长而去。
<a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-271704" target="_blank">2013年5月23日 10:44</a> | <a href="http://www.ruanyifeng.com/blog/user/%E5%A2%A8%E6%B0%B4.html" title="墨水的全部留言" target="_blank">档案</a> | <a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-text" title="引用墨水的这条留言" target="_blank">引用</a></p>
<p><a href="http://www.callmewind.info/" title="http://www.callmewind.info" target="_blank">rain</a> 说：</p>
<p>“法律和合同的规定，不如人际关系重要”。中国人就是不讲制度的，所以有这样那样的纠纷，无论是大事还是小事，所以制度很重要
<a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-271710" target="_blank">2013年5月23日 21:18</a> | <a href="http://www.ruanyifeng.com/blog/user/rain.html" title="rain的全部留言" target="_blank">档案</a> | <a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-text" title="引用rain的这条留言" target="_blank">引用</a>
<a href="http://cfvwmg.com/" title="http://cfvwmg.com/" target="_blank">怼</a> 说：</p>
<p>水太深，单听净是坑害。要么谷歌，要么雅虎。
<a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-271712" target="_blank">2013年5月24日 08:48</a> | <a href="http://www.ruanyifeng.com/blog/user/%E6%80%BC.html" title="怼的全部留言" target="_blank">档案</a> | <a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-text" title="引用怼的这条留言" target="_blank">引用</a></p>
<p>舒思文 说：</p>
<p>可悲的是外国人比中国人自己更了解我们，我比较好奇的是你是从哪里找到这些比较有价值的书的呢？
<a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-271725" target="_blank">2013年5月24日 17:42</a> | <a href="http://www.ruanyifeng.com/blog/user/%E8%88%92%E6%80%9D%E6%96%87.html" title="舒思文的全部留言" target="_blank">档案</a> | <a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-text" title="引用舒思文的这条留言" target="_blank">引用</a>
<a href="http://chshouyu.com/" title="http://chshouyu.com" target="_blank">轻扬</a> 说：</p>
<p>阮兄不怕被请喝茶啊
<a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-271748" target="_blank">2013年5月26日 11:04</a> | <a href="http://www.ruanyifeng.com/blog/user/%E8%BD%BB%E6%89%AC.html" title="轻扬的全部留言" target="_blank">档案</a> | <a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-text" title="引用轻扬的这条留言" target="_blank">引用</a></p>
<p>BARRY LEE 说：</p>
<p>阮先生，我已付一些费用，转发微信去。
<a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-271753" target="_blank">2013年5月26日 21:16</a> | <a href="http://www.ruanyifeng.com/blog/user/BARRY%20LEE.html" title="BARRY LEE的全部留言" target="_blank">档案</a> | <a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-text" title="引用BARRY LEE的这条留言" target="_blank">引用</a>
<a href="http://dingsanlang.tap.cn/" title="http://dingsanlang.tap.cn/" target="_blank">丁三郎</a> 说：</p>
<p>我也想写一本《两亿乡绅》，招招点向美国人的死穴！不过不知阮兄是否可以代劳？
<a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-271754" target="_blank">2013年5月26日 21:32</a> | <a href="http://www.ruanyifeng.com/blog/user/%E4%B8%81%E4%B8%89%E9%83%8E.html" title="丁三郎的全部留言" target="_blank">档案</a> | <a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-text" title="引用丁三郎的这条留言" target="_blank">引用</a></p>
<p>nuke 说：</p>
<p>引用lagolas的发言：</p>
<p>书中的观点好像很极端，几乎没有一句好话，都是些陈词滥调，真是无趣。只是把外国人对中国的批评汇总了一下。动不动就说中国人就会死记硬背，不懂创新。</p>
<p>这个是摘录的部分，整本书没这么偏激
<a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-271764" target="_blank">2013年5月27日 11:00</a> | <a href="http://www.ruanyifeng.com/blog/user/nuke.html" title="nuke的全部留言" target="_blank">档案</a> | <a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-text" title="引用nuke的这条留言" target="_blank">引用</a>
nuke 说：</p>
<p>其中关于运10的失败，很有学习的价值
<a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-271765" target="_blank">2013年5月27日 11:01</a> | <a href="http://www.ruanyifeng.com/blog/user/nuke.html" title="nuke的全部留言" target="_blank">档案</a> | <a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-text" title="引用nuke的这条留言" target="_blank">引用</a></p>
<p>鱼 说：</p>
<p>引用Whiskier的发言：</p>
<p>印度人咧？</p>
<p>装：野史也疯狂
【中国是富了，还是穷了】四十年间，中国的GDP世界排名变化顺序如下：1978年第15名；1990年第10名；1995年第7名；2000年第6名；2007年第4名；2010年第2名；中国人均收入的世界排名变化顺序如下：1960年第78名；1970年第82名；1980年第94名；1990年第105名；2008年第106名；2010年第127名。来自皮皮精灵4月7日 09:38 阅读(1.6万) 全部转播和评论(236)
<a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-271773" target="_blank">2013年5月27日 16:24</a> | <a href="http://www.ruanyifeng.com/blog/user/%E9%B1%BC.html" title="鱼的全部留言" target="_blank">档案</a> | <a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-text" title="引用鱼的这条留言" target="_blank">引用</a>
kz 说：</p>
<p>当然，还有一种促成这种“现实”的原因：因为大家都是这样认为的。
<a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-271776" target="_blank">2013年5月27日 18:23</a> | <a href="http://www.ruanyifeng.com/blog/user/kz.html" title="kz的全部留言" target="_blank">档案</a> | <a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-text" title="引用kz的这条留言" target="_blank">引用</a></p>
<p><a href="http://www.anxinblog.org/" title="http://www.anxinblog.org" target="_blank">安心博客</a> 说：</p>
<p>亲吻干部，拥抱客户。这真是现实的真实写照！
<a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-271787" target="_blank">2013年5月28日 09:03</a> | <a href="http://www.ruanyifeng.com/blog/user/%E5%AE%89%E5%BF%83%E5%8D%9A%E5%AE%A2.html" title="安心博客的全部留言" target="_blank">档案</a> | <a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-text" title="引用安心博客的这条留言" target="_blank">引用</a>
<a href="http://www.yesnotes.net/" title="http://www.yesnotes.net" target="_blank">卡布奇诺</a> 说：</p>
<p>写到了许多我们不愿意承认但确实存在的问题,鞭辟入里.一个内心虚伪却要外表忠良的国度.
<a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-271792" target="_blank">2013年5月28日 13:10</a> | <a href="http://www.ruanyifeng.com/blog/user/%E5%8D%A1%E5%B8%83%E5%A5%87%E8%AF%BA.html" title="卡布奇诺的全部留言" target="_blank">档案</a> | <a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-text" title="引用卡布奇诺的这条留言" target="_blank">引用</a></p>
<p><a href="http://get-set.cn/wordpress" title="http://get-set.cn/wordpress" target="_blank">hurry</a> 说：</p>
<p>说实话，我不了解我的祖国
<a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-271796" target="_blank">2013年5月28日 14:34</a> | <a href="http://www.ruanyifeng.com/blog/user/hurry.html" title="hurry的全部留言" target="_blank">档案</a> | <a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-text" title="引用hurry的这条留言" target="_blank">引用</a>
luochen1990 说：</p>
<p>为了维持表面上的秩序，中国人的行为准则，不是有没有内疚，而是会不会被揭露。</p>
<p>只要不被抓住，中国人做任何事都可以心安理得。</p>
<p>这两句话太一针见血了,想到不久前的偷车弃婴案,想到无数次的食品安全问题,无不是这两句话的真实反映.
<a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-271808" target="_blank">2013年5月29日 14:33</a> | <a href="http://www.ruanyifeng.com/blog/user/luochen1990.html" title="luochen1990的全部留言" target="_blank">档案</a> | <a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-text" title="引用luochen1990的这条留言" target="_blank">引用</a></p>
<p><a href="http://levin.sinaapp.com/" title="http://levin.sinaapp.com" target="_blank">levin</a> 说：</p>
<p>确实，稳定是压倒一切的。
<a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-271819" target="_blank">2013年5月30日 01:02</a> | <a href="http://www.ruanyifeng.com/blog/user/levin.html" title="levin的全部留言" target="_blank">档案</a> | <a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-text" title="引用levin的这条留言" target="_blank">引用</a>
inspironX 说：</p>
<p>阮兄,还是少谈政治吧.这些话题总会引起大量评论,有人会觉得你想搞个阵地啥的,随时可以封你.
国外虚拟主机的站能被看到就算是开恩了,要珍惜.不要去挑战那些我们无法改变的事情.
<a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-271895" target="_blank">2013年6月 1日 23:17</a> | <a href="http://www.ruanyifeng.com/blog/user/inspironX.html" title="inspironX的全部留言" target="_blank">档案</a> | <a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-text" title="引用inspironX的这条留言" target="_blank">引用</a></p>
<p><a href="http://aviot.us/" title="http://aviot.us" target="_blank">aviot</a> 说：</p>
<p>好多自阉
<a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-271898" target="_blank">2013年6月 2日 01:54</a> | <a href="http://www.ruanyifeng.com/blog/user/aviot.html" title="aviot的全部留言" target="_blank">档案</a> | <a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-text" title="引用aviot的这条留言" target="_blank">引用</a>
钱烨 说：</p>
<p>中国追求的是国家的稳定与秩序。</p>
<p>美国的追求的是世界的稳定与秩序。</p>
<p>这两个国家都有一个共同点，他们的追求都是为了自己的国家。</p>
<p>但是他们又是不同的，中国的追求依靠人民的自我实现，美国依靠强大的武力。</p>
<p>世界的发展终将打破这个世界旧有的秩序和稳定，在世界经济一体化的大潮下，国家之间的平等和民主必将实现，到那个时候，每个国家都能享受到稳定与秩序带来的荣光。谁在与世界为敌，谁在阻挡历史的潮流，谁将成为历史的弃儿，在下一个10年内必见分晓。
<a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-271903" target="_blank">2013年6月 2日 11:29</a> | <a href="http://www.ruanyifeng.com/blog/user/%E9%92%B1%E7%83%A8.html" title="钱烨的全部留言" target="_blank">档案</a> | <a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-text" title="引用钱烨的这条留言" target="_blank">引用</a></p>
<p>小扁豆 说：</p>
<p>这才是中国通
<a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-271910" target="_blank">2013年6月 2日 23:19</a> | <a href="http://www.ruanyifeng.com/blog/user/%E5%B0%8F%E6%89%81%E8%B1%86.html" title="小扁豆的全部留言" target="_blank">档案</a> | <a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-text" title="引用小扁豆的这条留言" target="_blank">引用</a>
左村 说：</p>
<p>推荐看一下韩国电影《新世界》有点象《无间道》，绝对不比《无间道》差，甚至略有胜出
<a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-271956" target="_blank">2013年6月 5日 20:18</a> | <a href="http://www.ruanyifeng.com/blog/user/%E5%B7%A6%E6%9D%91.html" title="左村的全部留言" target="_blank">档案</a> | <a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-text" title="引用左村的这条留言" target="_blank">引用</a></p>
<p><a href="http://www.mingdeng.net/" title="http://www.mingdeng.net" target="_blank">明灯博客</a> 说：</p>
<p>外国人写的比较河蟹的书。
中国特色很鲜明。
<a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-271959" target="_blank">2013年6月 5日 21:37</a> | <a href="http://www.ruanyifeng.com/blog/user/%E6%98%8E%E7%81%AF%E5%8D%9A%E5%AE%A2.html" title="明灯博客的全部留言" target="_blank">档案</a> | <a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-text" title="引用明灯博客的这条留言" target="_blank">引用</a>
fygate 说：</p>
<p>引用inspironX的发言：</p>
<p>阮兄,还是少谈政治吧.这些话题总会引起大量评论,有人会觉得你想搞个阵地啥的,随时可以封你.
国外虚拟主机的站能被看到就算是开恩了,要珍惜.不要去挑战那些我们无法改变的事情.</p>
<p>有些事,总需要有人去做的!什么叫无法改变,如果每个人都沉默,那才真的叫无法改变!虽然我知道你是关心阮兄的!
<a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-271977" target="_blank">2013年6月 7日 12:22</a> | <a href="http://www.ruanyifeng.com/blog/user/fygate.html" title="fygate的全部留言" target="_blank">档案</a> | <a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-text" title="引用fygate的这条留言" target="_blank">引用</a></p>
<p>Sharks 说：</p>
<p>引用inspironX的发言：</p>
<p>阮兄,还是少谈政治吧.这些话题总会引起大量评论,有人会觉得你想搞个阵地啥的,随时可以封你.
国外虚拟主机的站能被看到就算是开恩了,要珍惜.不要去挑战那些我们无法改变的事情.</p>
<p>哪里有压迫，那里就忍着
<a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-271984" target="_blank">2013年6月 8日 05:34</a> | <a href="http://www.ruanyifeng.com/blog/user/Sharks.html" title="Sharks的全部留言" target="_blank">档案</a> | <a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-text" title="引用Sharks的这条留言" target="_blank">引用</a>
伊格尔 说：</p>
<p>正反两面都是需要听听看看的。中国的文化环境是中央集权，家长制，在当今的社会中必然不适合，所以会出现种种的不和谐现象和两面派
<a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-272018" target="_blank">2013年6月 9日 18:00</a> | <a href="http://www.ruanyifeng.com/blog/user/%E4%BC%8A%E6%A0%BC%E5%B0%94.html" title="伊格尔的全部留言" target="_blank">档案</a> | <a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-text" title="引用伊格尔的这条留言" target="_blank">引用</a></p>
<p>巴马奥 说：</p>
<p>你问问奥巴马是不是很乐意让位给麦凯恩？</p>
<p>谁在这个位子上都想着如何做好，如何长久，干嘛只盯着中国不放？
<a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-272071" target="_blank">2013年6月12日 21:28</a> | <a href="http://www.ruanyifeng.com/blog/user/%E5%B7%B4%E9%A9%AC%E5%A5%A5.html" title="巴马奥的全部留言" target="_blank">档案</a> | <a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-text" title="引用巴马奥的这条留言" target="_blank">引用</a></p>
]]></content>
    
    
      <category term="好文摘录" scheme="http://itsolife.com/categories/%E5%A5%BD%E6%96%87%E6%91%98%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[知其所以然（续）]]></title>
    <link href="http://itsolife.com/2014/02/03/2014-02-03--%E7%9F%A5%E5%85%B6%E6%89%80%E4%BB%A5%E7%84%B6%EF%BC%88%E7%BB%AD%EF%BC%89/"/>
    <id>http://itsolife.com/2014/02/03/2014-02-03--知其所以然（续）/</id>
    <published>2014-02-03T03:24:28.000Z</published>
    <updated>2014-03-07T03:29:23.000Z</updated>
    <content type="html"><![CDATA[<h1 id="-">知其所以然（续）</h1>
<h1 id="-http-mindhacks-cn-2010-11-14-the-importance-of-knowing-why-part2-"><a href="http://mindhacks.cn/2010/11/14/the-importance-of-knowing-why-part2/" target="_blank">知其所以然（续）</a></h1>
<p>查了一下，上篇<a href="http://mindhacks.cn/2008/07/07/the-importance-of-knowing-why/" target="_blank">知其所以然（以学习算法为例）</a>是08年7月写的，现在已经是10年11月，过去了两年零4个月，这说明了三件事情：1，一个问题其实你可以一直放在脑子里面，利用<a href="http://mindhacks.cn/2009/12/20/dark-time/" target="_blank">暗时间</a>对其软泡硬磨，时间足够久你总会有一点新的感悟，问题其实就像那句老话说的那样，不怕贼偷就怕贼惦记，聚精会神的思考一天，也许比不上惦记一个星期（据说<a href="http://blog.csdn.net/pongba/archive/2008/07/24/2705151.aspx" target="_blank">数学家庞加莱就特别会惦记问题</a>）。2，事实上，当你感觉懂了的时候，你至少得反问自己一句，真的懂了吗？当你确信自己真的懂了的时候，你至少得讲给别人听，别人听懂了吗？考察你自己是否真懂了的一个很好的依据是，你是否有一种“哦，原来是这样啊，这下再也不可能忘记了”的感觉。3，我其实没有忘记这个博客。如我之前说的，<a href="http://mindhacks.cn/2009/02/15/why-you-should-start-blogging-now/" target="_blank">记录只是学习和思考的副作用</a>，只要还在学习和思考，就必然会有新的记录。</p>
<p>我有一个习惯，看定理必看证明。一个你不明白其证明的定理在我看来比不知道这个定理还要糟糕，因它给你造成一种懂了的错觉。<strong>在没有明白背后的证明之前，任何一个定理对你来说都是等价的——等价于背乘法口诀</strong>（只不过有的长一点有的短一点）。一个原本美妙的定理，把其证明扔掉就是真正的买椟还珠，暴殄天物。</p>
<p>从现实意义来说，<strong>去理解一个定理的证明会带来巨大的好处，首当其冲的好处就是你很难再忘掉它</strong>。这一点其实很容易解释——在理解一个定理的证明之前，定理对你而言是一堆没有内在联系的词句，而在理解了证明之后，定理就<strong>归约为</strong>证明它所需的条件加上逻辑，“逻辑”本来就存在于你的大脑里面，而证明的过程中除了公理和用到的常见定理（往往没几条）之外，宽泛地说，需要你去记的，一般来说也只有一个或两个关键的insights，也就是我们常说的证明中的神来之笔，比如几何证明里面的某条看上去莫名其妙的辅助线，一旦你知道了这条辅助线，那么整个证明就毫无难处，那么该定理的信息量便直接缩减为一条辅助线的信息量；虽然看上去这一步信息并没有缩减多少，但是如果你考虑到类似的辅助线不仅会用在这个特定的定理上，往往会在很多地方用到。很多关键的证明手法是通用的。那么其实你就是把所有以这个辅助线为关键证明手法的定理的集合的信息量归约为了这条辅助线。如果你进而甚至能够理解了作这条辅助线的思想精髓，那就更牛逼了，因为解决问题的思路更具有一般性，理解了寻找正确的辅助线的思路，你就根本不需要去记得某条特定辅助线的作法，你就把所有以作一条或几条辅助线为证明核心的定理的集合的信息量归约为了这个“寻找辅助线的思路”。</p>
<p><strong>这是一个树状的知识结构，越往上层走，需要记忆的节点就越少</strong>。所谓触类旁通者，其实便是因为他擅长去理解解法背后的更具一般性的东西。所以我还有一个习惯，就是看到美妙的证明和解法总是会去一遍又一遍的去反复揣摩，试图理解想出这个证明的人到底是怎么想出来的，有没有什么一般性的方法可循，很多时候，在这样揣摩的过程中，你会理解到更深刻的东西，对问题性质更深刻的认识，对解决问题的思路更深刻的认识，这些认识不仅对于你理解当前这个定理或问题有极大的帮助，同时也有助于你解决以后会遇到的表面不同但本质一样的问题。</p>
<p>与看定理必看证明类似，看一个问题的解法，必然要看解法所诞生的过程，背后是否隐藏着更具一般性的解决问题的思路和原则。否则一个解法就只是一个问题的解法，跟背口诀一样。即便记住了也无法推广，即便当时记住了也容易遗忘。</p>
<p>举个经典的例子：每本算法书都会讲动态规划，每本讲动态规划的书都会讲背包问题，每次讲背包问题都会讲可重复背包和01背包，我们就拿《Algorithms》这本<a href="http://book.douban.com/review/1325850/" target="_blank">还算不错</a>的算法书对背包问题的讲解来说吧，重复背包问题的递归公式是这样的：</p>
<p>K(W) = max { K(W-Wi) + Vi : Wi &lt;= W }</p>
<p>这个公式的理解倒是很简单：为了把问题降阶，我们在最终的最优解里面去掉一个元素，对这个元素的可能性进行讨论，它必然是任何Vi之一（前提是Wi &lt;= W，否则就装不下），而在去掉这个元素之后，剩下的元素肯定构成问题 K(W-Wi) 的最优解，于是递归关系出现了。</p>
<p>此外也可以这样来理解：要拿一组最优元素，那么总得开始一个个拿吧，对第一个拿的元素进行讨论，而问题的最优解等于讨论的各个分支的最优解中的最优者；如果拿掉Vi之后，剩下来要怎么拿才能最优呢？这就是一个 K(W-Wi) 的问题了。</p>
<p>01背包问题就大不一样了——每个物品都只有一件，拿掉之后就不能再拿了。我们不妨看看重复背包问题的解法是不是能用到01背包上呢？还是讨论第一个拿的元素，设被拿掉的是第i个元素，问题就归结为把剩下的物品（注意，可拿的物品少了一件）最优地装入容量为 W-Wi 的包里，所以，问题的参数便变成了两个，一个是背包剩余容量 W-Wi，另一个是剩余可拿的物品集合 S{i} （表示去掉i之后的子集），显而易见第二个参数是物品集合的各种可能的子集，那么其可能性个数就是 2^n ，这就导致子问题的个数是 2^n， 由于要依次计算每个子问题，那么算法复杂度显然也是 2^n ，是不可接受的。</p>
<p>那么，《Algorithms》上又是怎么来讲解01背包问题的解法的呢？以下是原文：</p>
<p>Our earlier subproblems now become completely useless. We must therefore refine our concept of a subproblem to carry additional information about the items being used. We add a second parameter, 0 &lt;= j &lt;= n: K(W, j) = maximum value achievable using a knapsack of capacity w and items 1..j: The answer we seek is K(W, n).</p>
<p>首先作者说了，之前重复背包问题的解法在这里完全废掉了，所以我们必须重新定义子问题，并且子问题的条件必须要包含目前拿剩下的物品。以上这些都还不错，关键是接下来就让人吐血了。作者接着说道，<strong>我们</strong>给子问题加上一个新的参数j…</p>
<p>凭什么啊？</p>
<p>还是让我们回顾一下<a href="http://images.google.com/images?hl=en&amp;source=imghp&amp;biw=1024&amp;bih=620&amp;q=then+a+miracle+occurs&amp;gbv=2&amp;aq=f&amp;aqi=g3g-m6&amp;aql=&amp;oq=&amp;gs_rfai=" target="_blank">这样一幅经典的漫画</a>吧：</p>
<p><img src="" alt=""></p>
<p>“我们给子问题加上一个参数j”，这就像你在看数学证明时看到无比邪恶的“<strong>我们考虑</strong>…“一样，一看到这样的句子，你就知道，这个问题的证明远远不像看上去那么简单，之所以你一路看下去理解上全无困难，那完全是因为作者直接把最重要的一个insight告诉你了，举个很简单的例子，证明素数无最大，谁都会第一时间想到去反证：假设存在一个最大的素数P，那么找到比P大的素数就是证明中最关键的一步，怎么找的？一般书上是不会说的，你会看到书上这样说：假设P是最大的素数，那么我们考虑P’ = 小于等于P的所有素数的乘积+1。那么P’一来显然大于P，二来不能被小于它的所有素数整除，那么P’就成了大于P的素数。</p>
<p>如果你经常注意反证法，你会发现一个有趣的现象，反证法里面经常会有这样一句“我们考虑”，而“我们考虑”后面几乎肯定接着一个天外飞仙一般的insight。素数无最大这个古老的证明里面的“我们考虑”尚算是比较有迹可循的（我们想要构造一个更大的素数，而素数的等价定义就是“不能被小于它的所有素数整除，为了达到这个目的，构造的方法就较明显了）。但是有非常非常多的证明，其中关键的一步就跟嗑药磕出来做梦做出来走路跌跟头跌出来的一样（不信去翻一翻《<a href="http://www.amazon.com/Proofs-BOOK-Martin-Aigner/dp/3540404600" target="_blank">Proofs from THE Book</a>》），让你完全不知道他怎么想到的。</p>
<p>话说回来，虽然有很多数学证明的关键步骤是很难逆向工程的（因为很多时候想出那个关键步骤的本人其实也是尝试了各种方法，撞了无数堵墙，在寻求证法的尝试空间中作了N次回溯才“妙手偶得”，与其说是妙手偶得，不如说是绞尽脑汁），但并非全无章法可循，否则陶哲轩也不会写出《<a href="http://www.amazon.com/Solving-Mathematical-Problems-Personal-Perspective/dp/0199205604" target="_blank">Solving Mathematical Problems</a>》这样的著作来，而求解问题也就成了真正的Black Art了。</p>
<p>算法的解法则比精妙的数学证明稍加更容易逆向工程一点。只要你有耐心仔细地去琢磨算法的关键步骤和本质，总能从中窥探到一些更general的思想和思路来。</p>
<p>此外，很多经典问题，算法书上的讲法虽然时时令我们失望，但如果去网上一搜，则通常会发现更优秀的解释来。比如<a href="http://www.google.com/webhp?hl=en#sclient=psy&amp;hl=en&amp;site=webhp&amp;source=hp&amp;q=%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98+%E8%A7%A3%E7%A9%BA%E9%97%B4&amp;aq=f&amp;aqi=&amp;aql=&amp;oq=&amp;gs_rfai=&amp;pbx=1&amp;fp=ab43752bbefd1914" target="_blank">背包问题就是如此</a>。</p>
<p>简单地说，如果你对于每个问题都能真正弄清以下这几个问题的答案，那么可以肯定的是，你的理解，记忆，以及学习的效率都会得到质的提高：</p>
<ul>
<li>为什么这种解法是对的？</li>
<li>为什么那种解法是错的？</li>
<li>为什么这种解法不是最优的？</li>
<li>证明为什么没有更优的解法。</li>
</ul>
<p>回到人民群众喜闻乐见的经典例子：背包问题。为什么01背包问题的正确（高效）算法是正确（高效）的。表面的解释是，因为01背包问题的子问题定义是 K(W, j)，其两个维度相乘的可能性一共有nW种，也就是说一共要计算nW个子问题，而计算每个子问题的复杂度是O(1)的。</p>
<p>但是如果仅仅满足于这样的解释，可以说是隔靴搔痒，并没有触及到本质。算法本质上可以看做是在一个解空间当中的搜索问题，所以要分析一个算法的好坏，首先弄清它的解空间的结构，然后分析它是怎么来探索这个解空间的。</p>
<p>弄清解空间的是第一步，例如排序算法，其解空间可以看做是所有可能的下标排列组合，其中有且仅有一个排列是正确的排序排列（简单起见假设元素各不相同）。那么一个算法在探索这个解空间方面的行为就决定了它的效率高低，最简单的，如果一个算法每次只能检查解空间中的一个点，那么这个算法的复杂度就是解空间的大小。对排序算法而言也就是n!。从这个角度来看，我们就会很容易的发现，所有基于比较的排序算法，其复杂度为什么是以O(nlogn)为下界的，因为一次比较操作最多有两个结果，a&gt;b或a&lt;b，既然只有两种结果，那么最多只能将解空间进行2分，如果每次都能完美的2分，那么找到那个唯一点最终需要的步骤就是log(n!) = O(nlogn)。如此就不难理解<a href="http://mindhacks.cn/2008/06/13/why-is-quicksort-so-quick/" target="_blank">什么基于比较的排序算法的复杂度最好不过如此了</a>。</p>
<p>回到01背包问题，01背包问题的解空间其实也是类似的。一次选取就是一个01数组，其中每个元素代表其所对应的物品要不要选取。很显然，这个解空间的大小是2^n。在01背包的算法里面，每当我们解出K(W, j)（需要O(W)次计算）之后，解空间就会被折半（排除掉1/2的可能性），一共如此做n次，就能得到最终解。由于每次折半的代价是O(W)，便不难理解为什么算法复杂度是O(nW)了。</p>
<p>那么，为什么每次计算出K(W,j)就能使解空间折半呢？那就需要来看看这个算法是如何探索解空间的，算法探索解空间的方式在其递归公式里面：</p>
<p>K(W, j) = max { K(W, j-1), K(W-Wj, j – 1)  + Vj }</p>
<p>也就是说，首先看你要不要选取第一个物品，有两种可能性（两个分支），每个分支都是一个更低阶的子问题，即在其中的任意一个分支下都要决定要不要选取第二个物品（又是两个分支），如此下递归去，可以构建出一棵有2^n方个叶子节点的树，每条从根结点到叶子节点的路径“01..101”就对应一个解，其中每个分叉代表“选”或“不选”当前的物品。</p>
<p>建立在对这个解空间的理解上，我们再来看为什么01背包问题的正确解法能做到O(nW)。（首先你最好将这棵树画在纸上，其中每个节点都是一个子问题K(W,j)，每条分叉都是0或1。）当我们计算出所有的K(W, 1)（需要O(W)次操作）之后，我们容易注意到，所有离叶子节点的距离为1的内部节点K(W, 2)到叶子节点的两个分支都必然只能取其一了，也就是说，有一半的叶子节点被排除掉了（对解空间折半）。当我们进而计算出K(W,2)之后，同样的道理，我们容易看到，到叶子节点距离为2的内部节点的两个分支也只能取其一了，这就进而再次将解空间折半。由于每次折半需要O(W)的复杂度，所以就不难理解算法的总复杂度为O(nW)了。另一种理解的方法是，当我们计算出K(W,j)的时候，从内部节点K(W,j)到根节点的唯一路径便确定了。经过O(nW)次计算，从根节点到那个唯一解（叶子节点）的路径便完全确定了。</p>
<p><strong>知道怎么做是从正确（高效）解法得到的，而知道为什么必须得那样做则往往是从错误（低效）的解法当中得到的。</strong></p>
<p>然而遗憾的是，绝大多数算法书或教程都只顾一上来就告诉你正确的做法是什么，对于一些常见的错误解法，或者常见的低效解法，却根本不加分析。经验告诉我们，理解错误的做法为什么错误同样甚至更为重要，往往是在理解了错误的解法为什么错误之后，我们才能深刻的体会到为什么正确的解法是如此正确。</p>
<p>还是拿经典的背包问题来作例子，你几乎看不到哪本书会告诉你一个典型的低效解法为什么低效的深刻原因。我们都知道动态规划的核心在于子问题的划分，同样的问题，不同的划分办法得到的复杂度完全不一样。前面已经提到了，重复背包问题的思路在01背包问题上会带来指数级的复杂度，但是为什么呢？如果你满足于说：因为如果拿重复背包问题的思路来解01背包问题，那么子问题定义的第二个维度（物品的子集）（见前文）是指数级的，那么要计算所有子问题，当然是指数级的。那么你只是看到这个问题的表象。</p>
<p>如果从对解空间的探索方式来说，可以容易看出这个现象的本质，我们回顾一下01背包问题的正确（高效）算法：</p>
<p>K(W, j) = max { K(W, j-1), K(W-Wj, j – 1)  + Vj }</p>
<p>这个算法讨论的是两种情况，“要”或者“不要”选取第j个物品，这两种情况所对应的解空间是完全不交的，这就有效地将解空间划分为了不重复的两个部分。</p>
<p>而再来看利用重复背包问题思路的解法：</p>
<p>K(W, S) = max { K(W-Wi, S{i}) + Vi : Wi &lt;= W }</p>
<p>这里讨论的是首先拿掉哪一个物品，还是那句话，讨论的每一个分支都对应了算法对解空间的一个切分，我们容易看出，在“先拿物品i”和”先拿物品j“这两个分支里面，存在大量的重复，因为先拿物品i再拿j，和先拿物品j再拿i对应的是完全一样的一组选取。事实上，如果你将这个递归公式画成树状结构，会发现有n!个叶子节点。n!是什么概念？01背包问题的解空间大小本质上就只有2^n次方，穷举也不过O(2^n)的复杂度，结果这样一切分却变成了n!，可见这种对解空间的切分方法的冗余度是多么高了。你不妨看看，每一次计算K(W, S)子问题能对解空间排查多少呢？是否能像前面正确的算法那样，每次都能有效排查一半情况？理解了这一点之后，我们便注意到在划分解空间，也就是定义子问题的时候的一个原则，就是在建立递归公式的时候，尽量将解空间进行不交的切分。同时我们便有了趁手的工具去分析一个动态规划的解法的效率。</p>
<p>最后再举一个例子：算法书上几乎必讲的霍夫曼树。你所看的算法书在讲霍夫曼树的时候给了证明吗？讲过霍夫曼树的<a href="http://en.wikipedia.org/wiki/Huffman_tree#History" target="_blank">历史八卦</a>吗？也许你看了霍夫曼树的构造方法之后觉得：“哦，这样啊，显然”。但是你可曾想到，在最优编码这个问题上，连<a href="http://en.wikipedia.org/wiki/Shannon-Fano_coding" target="_blank">香农本人之前给出的解法</a>都只是suboptimal的，而且霍夫曼本人在得到这个算法之前也是绞尽脑汁几近放弃。<strong>如果你10分钟就“理解”了，那么百分之百只是背了课文而已。</strong>
**来源： <a href="[http://mindhacks.cn/2010/11/14/the-importance-of-knowing-why-part2/](http://mindhacks.cn/2010/11/14/the-importance-of-knowing-why-part2/)">[http://mindhacks.cn/2010/11/14/the-importance-of-knowing-why-part2/](http://mindhacks.cn/2010/11/14/the-importance-of-knowing-why-part2/)</a> </p>
<ul>
<li>小屋</li>
</ul>
<p>太好了，，我还以为再也不更新了呢
T<strong>__</strong>T</p>
<p>2010年11月25日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="Andy"></li>
</ul>
<p>Andy</p>
<p>有道无术，术可求
有术无道，止于术
根据文章看来，未鹏兄是领悟了数学的道，也领悟了对待科学与真理的道</p>
<p>2010年11月25日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://hi.baidu.com/Akagi201" title="Akagi201" target="_blank"><img src="" alt="Akagi201"></a></li>
</ul>
<p><a href="http://hi.baidu.com/Akagi201" target="_blank">Akagi201</a></p>
<p>不更则已，一更惊人！</p>
<p>2010年11月25日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="pengde"></li>
</ul>
<p>pengde</p>
<p>等你的文章等了好久哟</p>
<p>2010年11月26日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="demo_world"></li>
</ul>
<p>demo_world</p>
<p>就像您说的那样..记录是学习和思考的副作用!!
总是感觉能从您的文章中读处那么一点不一样的味道....
所以我们更加急切希望您的最新文章,殊不知沉淀过后的思想才是你的追求。
我们会继续支持下去，能给我们带来更多更好的思想....</p>
<p>2010年11月27日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="温海"></li>
</ul>
<p>温海</p>
<p>朋友，您好！我是武汉博文视点的编辑温海。我们打算为刘未鹏出版一本书，暂定《暗时间》书名，我们现在想邀请您作为我们的读者顾问团成员，一起为这本书的内容和版式设计出谋划策。不知您是否方便？我的联系地址是wenhai.no.2@gmail.com 如果您方便的时候请跟我联系。谢谢！</p>
<p>2010年12月6日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="hugo"></li>
</ul>
<p>hugo</p>
<p>等了我不少时日啊 ：）
文章还是一贯的深入浅出，很有味道 ：）</p>
<p>2010年11月27日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://wang4747.javaeye.com/" title="lele" target="_blank"><img src="" alt="lele"></a></li>
</ul>
<p><a href="http://wang4747.javaeye.com/" target="_blank">lele</a></p>
<p>等了好久。</p>
<p>2010年11月28日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="breaker"></li>
</ul>
<p>breaker</p>
<p>一直用Google Reader读你的文章，这次来看发现主题变了，你侧边那个“作为信息源的我”和有推荐的书籍怎么没有了？</p>
<p>2010年11月28日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://weibo.com/pongba" title="刘未鹏pongba" target="_blank"><img src="" alt="刘未鹏pongba"></a></li>
</ul>
<p><a href="http://weibo.com/pongba" target="_blank">刘未鹏pongba</a></p>
<p>不好意思，忘了加上去了。稍后加上。</p>
<p>2010年11月28日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="breaker"></li>
</ul>
<p>breaker</p>
<p>动作真快啊，我已经看到了。</p>
<p>2010年11月28日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="Tradition"></li>
</ul>
<p>Tradition</p>
<p>如同法国大餐一样值得等待和回味</p>
<p>2010年11月29日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://www.cncasting-forging.com/" title="bronze casting" target="_blank"><img src="" alt="bronze casting"></a></li>
</ul>
<p><a href="http://www.cncasting-forging.com/" target="_blank">bronze casting</a></p>
<p>终于见到博主更新了，围观围观</p>
<p>2010年11月29日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="gordon"></li>
</ul>
<p>gordon</p>
<p>其实都是凑出来的，但是这个凑合和试错还不相同，在数学上的俚语叫两头凑，没办法当
时我们老师就是这么教的。
证明有从已知出发，有从结论出发，然后构造一个中间层。
其实很多东西都是引入一个中间层的概念，数学推理过程中的很多中间公式是无法用实验
方法实验出来的，那就是构造出来的一个中间层。
知道做什么比知道怎么做重要的多，这就相当于老板和打工仔的关系，
老板其实不知道怎么干，但他知道做什么，他会招来一个数学系的马仔说：
我有一个很漂亮的证明，但是这页纸写不下了，你去把它证明一下。
然后老板去喝酒泡miss、调情去了。理工男“哼哧哼哧”干了半天。
提出命题和猜想的都是牛大的人，
不过引入中间层构造命题，到最后会成圆环套圆环，恶心的跟屎一样，就需要用批判性思
维雕出来，成为瀑布流水式的证明。数学之美从此产生，以前的证明太恶心；终于有个好
的证明了，简捷、明快犹如一件艺术品。
感谢陈凯歌大导演的电影，《无极》给华夏大地的语言增添了很多新元素。
古希腊和文艺复兴时期的人一直有这么一个认知情节，不知道从哪里来的，
每一个石头里都有一个大卫，每一个人身体里都有一个米开朗基罗，
去掉不对，它的轮廓自然清晰的显现出来了。
为什么要知其所以然，不知其所以然到底行不行？
学校里成绩一直不好的同学飘过。。。
为什么要知其所以然，
除了归约为有限集的好处之外，还有推广的好处。
一个技巧变成一个方法，一个方法成为一种思想，这是一种方法的推广。
我早就对数学没什么兴趣了，倒是对数学之外的美比较有兴趣，比如美丽女教师之类的，
当然穿上紧身裙更棒了。让那些糟老头滚蛋，但是如果糟老头穿上豹纹装，跳个草裙舞之
类的也能接受。数学系漂亮女生不多哪能发现数学之美啊，也没兴趣知其所以然。</p>
<p>2010年11月29日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="gordon"></li>
</ul>
<p>gordon</p>
<p>倒数第六行
“为什么要知其所以然” 改为 “对已知的学习为什么要知其所以然”</p>
<p>2010年11月29日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="温海"></li>
</ul>
<p>温海</p>
<p>朋友，您好！我是武汉博文视点的编辑温海。我们打算为刘未鹏出版一本书，暂定《暗时间》书名，我们现在想邀请您作为我们的读者顾问团成员，一起为这本书的内容和版式设计出谋划策。不知您是否方便？我的联系地址是wenhai.no.2@gmail.com 如果您方便的时候请跟我联系。谢谢！</p>
<p>2010年12月6日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="Semloh"></li>
</ul>
<p>Semloh</p>
<p>正好再看算法，不错</p>
<p>2010年12月4日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://www.justuggg.net/" title="ugg Bailey Button Boots" target="_blank"><img src="" alt="ugg Bailey Button Boots"></a></li>
</ul>
<p><a href="http://www.justuggg.net/" target="_blank">ugg Bailey Button Boots</a></p>
<p>真强悍，很不错的文采。、</p>
<p>2010年12月4日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="bigeast"></li>
</ul>
<p>bigeast</p>
<p>可是现在大学课堂上一节课能将N个定理，为了赶进度完成任务，定理的证明几乎从来不讲。自己一个个看也感到力不从心。</p>
<p>2010年12月9日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="InitialG"></li>
</ul>
<p>InitialG</p>
<p>我晕 我的留言很2吗 怎么被删除了》？</p>
<p>2010年12月10日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://weibo.com/pongba" title="刘未鹏pongba" target="_blank"><img src="" alt="刘未鹏pongba"></a></li>
</ul>
<p><a href="http://weibo.com/pongba" target="_blank">刘未鹏pongba</a></p>
<p>不好意思，有一次误操作把这篇文章的所有留言批量删除了 <img src="&quot;:(&quot;" alt=":("></p>
<p>2010年12月13日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://www.wutianqi.com/" title="Tanky Woo" target="_blank"><img src="" alt="Tanky Woo"></a></li>
</ul>
<p><a href="http://www.wutianqi.com/" target="_blank">Tanky Woo</a></p>
<p>收藏了！</p>
<p>2010年12月12日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="LGyuan"></li>
</ul>
<p>LGyuan</p>
<p>读你的文章好有激情啊！</p>
<p>2010年12月14日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="gordon"></li>
</ul>
<p>gordon</p>
<p>顺便说一句，从低效解法的分析得出高效解法，只限定在一类的问题内，例如局部最优问题。
原因是人能够发挥主观能动性，在寻找道路的时候可以记录信息，从而在搜索N次以后，终于可以找到从A到B的路。
在另外一类问题中，这种方法是无效的。
其实得不得出解法根本不是本质，本质是你对这个问题或者说命题的本质认识，不断求解
的过程其实就是你对信系丰富，对问题本质认识深化的过程。其实这些解法根本就是练练
手，就像美工做个小样或者程序开发的快速原型，这里引入了一个词Enrichment——事件
丰富，其实就是侦察一下，看看怎么回事。
其实就是信息丰富的一个过程，对命题本质的理解要深化了。
其实是这三个概念，事件丰富，事件关联，事件压缩。
enrichment、correlation、deduplication</p>
<p>2010年12月18日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="gordon"></li>
</ul>
<p>gordon</p>
<p>我这都是瞎说的，一时手贱打上去了</p>
<p>2010年12月18日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="miley"></li>
</ul>
<p>miley</p>
<p>我倒是觉得你的reply更charming一些呢</p>
<p>2011年1月29日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://www.nbled.net/" title="宁波led显示屏" target="_blank"><img src="" alt="宁波led显示屏"></a></li>
</ul>
<p><a href="http://www.nbled.net/" target="_blank">宁波led显示屏</a></p>
<p>读一遍没感觉，再读一遍，就不信了</p>
<p>2010年12月21日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="ymliu"></li>
</ul>
<p>ymliu</p>
<p>知行合一。
知识的积累固然重要，但是能否把知识转换为生产力，做出实际的贡献也是非常重要的。</p>
<p>2010年12月23日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://t.sina.com.cn/imissyoucj" title="iMissYouCJ" target="_blank"><img src="" alt="iMissYouCJ"></a></li>
</ul>
<p><a href="http://t.sina.com.cn/imissyoucj" target="_blank">iMissYouCJ</a></p>
<p>好久都不更新了</p>
<p>2010年12月25日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://www.noblepen.com/blog/" title="诺贝笔" target="_blank"><img src="" alt="诺贝笔"></a></li>
</ul>
<p><a href="http://www.noblepen.com/blog/" target="_blank">诺贝笔</a></p>
<p>排序算法一直没理解透</p>
<p>2010年12月29日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://www.auggbootsclearance.com/" title="ugg boots clearance" target="_blank"><img src="" alt="ugg boots clearance"></a></li>
</ul>
<p><a href="http://www.auggbootsclearance.com/" target="_blank">ugg boots clearance</a></p>
<p>很给力的文章啊。。呵呵
祝博主新年快乐哦。</p>
<p>2010年12月31日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://www.dino-power.com/" title="spray gun" target="_blank"><img src="" alt="spray gun"></a></li>
</ul>
<p><a href="http://www.dino-power.com/" target="_blank">spray gun</a></p>
<p>没太看明白，感觉很乱</p>
<p>2011年1月5日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="Cross"></li>
</ul>
<p>Cross</p>
<p>哥，更新的太少了啊，所有文章都看了几遍了！ 咕~~(╯﹏╰)</p>
<p>2011年1月16日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://blog.sina.com.cn/enterpriseword" title="侯轲" target="_blank"><img src="" alt="侯轲"></a></li>
</ul>
<p><a href="http://blog.sina.com.cn/enterpriseword" target="_blank">侯轲</a></p>
<p>您好！认识你很高兴！</p>
<p>2011年2月5日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://www.taobaowang-gw.com/" title="taobaowang" target="_blank"><img src="" alt="taobaowang"></a></li>
</ul>
<p><a href="http://www.taobaowang-gw.com/" target="_blank">taobaowang</a></p>
<p>牛人,学习了</p>
<p>2011年2月15日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="kisswind"></li>
</ul>
<p>kisswind</p>
<p>公理是最重要的，对于定理没必要每个都要证明，可以当成已知。“我有一个习惯，看定理必看证明”，这样会很花时间，假如要造个汽车，你不必每个零件都了解它怎么生产的，你只需要了解每个零件的特性，使用方法。就像写程序，你不必了解每个模块的原理，只要理解它的使用方法，只要按照它定的规则使用就绝对不会有问题(前提是每个模块要像定理一样被别人证明正确了)。知识是有层级的，每一个上层的知识都建立在它的下一层级基础之上，你的应用是在哪一级的，对构成它基础的知识就没必要怀疑, 这种怀疑可以是向下没有限度的。</p>
<p>2011年2月28日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="firo"></li>
</ul>
<p>firo</p>
<p>pongba,《Introduction to the design and analysis of algorithms》这本书和作者对于算法的学习观点，基本上和你的一只，很给力！！最近正在拜读中，主要观点可见他的文章 Do We Teach the Right Algorithm Design Techniques ? 这是地址：<a href="http://www.csc.villanova.edu/~levitin/paper.html" target="_blank"><a href="http://www.csc.villanova.edu/~levitin/paper.html">http://www.csc.villanova.edu/~levitin/paper.html</a></a> 
另外感谢你的文章为我学习前行的道路，指明方向。</p>
<p>2011年3月30日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://qmzh.net/" title="xRan" target="_blank"><img src="" alt="xRan"></a></li>
</ul>
<p><a href="http://qmzh.net/" target="_blank">xRan</a></p>
<p>请问您的空间是哪里购买的？ 速度很快，我也想购买。</p>
<p>2011年8月26日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://www.popbedding.com/" title="train quilt" target="_blank"><img src="" alt="train quilt"></a></li>
</ul>
<p><a href="http://www.popbedding.com/" target="_blank">train quilt</a></p>
<p>看了三，再看看二吧！</p>
<p>2011年10月10日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://hi.baidu.com/%E5%9F%BA%E7%9D%A3%E5%B1%B1%E5%94%90%E5%A4%AA%E6%96%AF/home" title="Pencilman" target="_blank"><img src="" alt="Pencilman"></a></li>
</ul>
<p><a href="http://hi.baidu.com/%E5%9F%BA%E7%9D%A3%E5%B1%B1%E5%94%90%E5%A4%AA%E6%96%AF/home" target="_blank">Pencilman</a></p>
<p>很感谢，排序复杂度的那个分析。这样来看自己以前学算法的时候确实没有想得很深入。但我以前学习有个习惯，就是自已用的定理一定要使自己随时都能推出来的定理，但随着课程的深入我发现这样有个弊端：精力花费太大了！不断地模拟定理退出来的过程，固然可以加强自己的理解，但这样成本太大，而且有些东西根本几乎就是自己再怎么想都想不出来的啊！我们学算法当然、一定要去思考这个算法是怎么出来的，但要有个度（也许是我愚蠢的想法），我觉得更好的方式就是和大家一起来探讨这个问题，感觉这样效率会高很多。</p>
<p>2011年10月20日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="jier-liao"></li>
</ul>
<p>jier-liao</p>
<p>&quot;二来不能被小于它的所有素数整除，&quot;可以证明p‘，是素数吗？</p>
<p>2011年12月7日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="ArchNew"></li>
</ul>
<p>ArchNew</p>
<p>现在N多的教材有一个习惯，就是N多的定理不给出证明。原因有很多，有的纯粹是作者问题，有的是篇幅问题，还有的就是这些定理的证明要用到还未介绍的知识。不过真正的好教材，前两种问题对它来说都不是问题。即便碰到最后一种问题，教材的作者也会像一个科普书的作家一样，尽量地给出直觉式的理由。遗憾的是，这样的书太少。</p>
<p>2011年12月18日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://www.vivilli.com/118-sunglasses/" title="cheap sunglasses online" target="_blank"><img src="" alt="cheap sunglasses online"></a></li>
</ul>
<p><a href="http://www.vivilli.com/118-sunglasses/" target="_blank">cheap sunglasses online</a></p>
<p>谢谢您的分享</p>
<p>2012年6月21日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://www.vivilli.com/118-sunglasses/" title="fashion sunglasses" target="_blank"><img src="" alt="fashion sunglasses"></a></li>
</ul>
<p><a href="http://www.vivilli.com/118-sunglasses/" target="_blank">fashion sunglasses</a></p>
<p>呵呵，有道理啊</p>
<p>2012年6月29日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://www.seobokes.com/" title="Lee小漫" target="_blank"><img src="" alt="Lee小漫"></a></li>
</ul>
<p><a href="http://www.seobokes.com/" target="_blank">Lee小漫</a></p>
<p>很给力的文章啊。。呵呵</p>
<p>2012年6月29日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="wclssdn"></li>
</ul>
<p>wclssdn</p>
<p>你的公式只写了出来. 没有对公式中每个字母的含义进行说明.. 菜鸟看不懂啊...</p>
<p>2012年7月4日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="Sen Li"></li>
</ul>
<p>Sen Li</p>
<p>很喜欢你的博文，总是喜欢看看以前看过的看看有没有新的理解
貌似有一个小错误。。
那么我们考虑P’ = 小于等于P的所有素数的乘积+1
应该是 那么我们考虑P’ = 小于等于P的&gt;&gt;所有正整数&lt;&lt;的乘积+1 吧- -
看了半天。。。</p>
<p>2012年8月6日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="Sen Li"></li>
</ul>
<p>Sen Li</p>
<p>还有 而素数的等价定义就是“不能被小于它的所有素数整除。。。貌似也应该是正整数</p>
<p>2012年8月6日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://weibo.com/2836493162" title="messi--forever" target="_blank"><img src="" alt="messi--forever"></a></li>
</ul>
<p><a href="http://weibo.com/2836493162" target="_blank">messi--forever</a></p>
<p>博主写得也没错吧。如果不能被小于它的所有素数整除，那肯定不能被正整数整除啊。你倒过来想，如果一个数n可以被小于它的正整数整除，那n就一定可以被某个小于n的素数整除。因为如果那个正整数是素数，自然成立；如果那个正整数是合数，那么n肯定能被这个整数的素因数整除（合数至少有一个素因子）。</p>
<p>2012年12月14日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="imao"></li>
</ul>
<p>imao</p>
<p>“首当其冲”的好处么？</p>
<p>2012年9月21日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://weibo.com/ericv72" title="Eric_V72" target="_blank"><img src="" alt="Eric_V72"></a></li>
</ul>
<p><a href="http://weibo.com/ericv72" target="_blank">Eric_V72</a></p>
<p>不错</p>
<p>2012年12月3日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://weibo.com/2708024482" title="陈文哲yy" target="_blank"><img src="" alt="陈文哲yy"></a></li>
</ul>
<p><a href="http://weibo.com/2708024482" target="_blank">陈文哲yy</a></p>
<p>其实做任何事情都要有个度，过犹不及，重要的是怎么把握这个度..</p>
<p>4月27日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="wang"></li>
</ul>
<p>wang</p>
]]></content>
    
    
      <category term="好文摘录" scheme="http://itsolife.com/categories/%E5%A5%BD%E6%96%87%E6%91%98%E5%BD%95/"/>
    
  </entry>
  
</feed>
