
<!DOCTYPE HTML>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>The 66 Page | It so life</title>
<meta name="author" content="RobinChia">

<meta name="description" content="It so life">


<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<meta property="og:site_name" content="It so life"/>

<!--[if IE]><style>.testIE.IE{display:inline;}</style><![endif]-->
<!--[if lte IE 7]><link rel="stylesheet" href="/css/ie7.css" type="text/css"><![endif]-->
<!--[if (lt IE 9)&(gt IE 7)]><style>.testIE.IE8{display:inline;}</style><![endif]-->
<!--[if gt IE 8]><style>.testIE.IE9{display:inline;}</style><![endif]-->

<link href="/favicon.png" rel="icon">
<link rel="alternate" href="/atom.xml" title="It so life Feed" type="application/atom+xml">

<link rel="stylesheet" href="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/css/bootstrap.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/font-awesome/4.0.3/css/font-awesome.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/prettify/r298/prettify.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" type="text/css">
<link rel="stylesheet" href="/css/style.css" type="text/css">
<!--[if lt IE 9]>
   <style>article,aside,dialog,footer,header,section,footer,nav,figure,menu{display:block}</style>
   <script src="http://cdn.staticfile.org/html5shiv/r29/html5.min.js"></script>
   <script src="http://cdn.staticfile.org/respond.js/1.4.2/respond.min.js"></script>
<link href="http://cdn.staticfile.org/respond.js/1.4.2/respond-proxy.html" id="respond-proxy" rel="respond-proxy" />
<link href="/js/respond.proxy.gif" id="respond-redirect" rel="respond-redirect" />
<script src="/js/respond.proxy.js"></script>
   <script src="http://cdn.bootcss.com/selectivizr/1.0.2/selectivizr-min.js"></script>
<![endif]-->
<script type="text/javascript">
function loadjs(c,d){var a=document.createElement("script");a.async=!0;a.type="text/javascript";a.src=c;a.charset=d||"gbk";(document.getElementsByTagName("HEAD")[0]||document.getElementsByTagName("BODY")[0]).appendChild(a)};
var _protocol = (("https:" == document.location.protocol) ? " https://" : " http://");
var _js2load = [];
</script>

</head>
<body>
      <header id="header" class="container"><nav id="main-nav" class="navbar navbar-default navbar-fixed-top " role="navigation">
  <div class="container">
    <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
      <span class="sr-only">Toggle navigation</span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="/">It so life</a>
    </div>
    <div  class="collapse navbar-collapse">
      <ul  class="nav navbar-nav">
  
        <li><a href="/" title="Home">Home</a></li>      
        <li><a href="/about/" title="About">About</a></li>      
        <li><a href="/archives/" title="Archives">Archives</a></li>      
      <li class='dropdown'>
        <a class='dropdown-toggle' data-toggle='dropdown' href='#'>website<b class='caret'></b></a>
        <ul class='dropdown-menu pure-menu-selected'>
    
          <li><a href="//groups.google.com/forum/#!forum/pongba" title="TopLanguage">TopLanguage</a></li>    
          <li><a href="//itpub.net/" title="ITPub">ITPub</a></li>    
          <li><a href="//blog.jobbole.com/" title="Bole">Bole</a></li>    
          <li><a href="//nosql-database.org/" title="nosql">nosql</a></li>    
          <li><a href="//gitimmersion.googol.im/" title="Git">Git</a></li>    
        </ul>
      </li>
    
      </ul>
      <ul class="nav navbar-nav navbar-right">
      
        <li><a href="/atom.xml">RSS</a></li>
      
      
        <li><a href="https://twitter.com/robinchia">twitter</a></li>
      
      
      
      
        <li><a href="https://github.com/robinchia">github</a></li>
      
      </ul>
    </div>
  </div>
</nav>
<div class="clearfix"></div>
</header>
  <div id='content' class="container">
     <div class="page-header-wrapper">
      <!--[if lt IE 9]><div class="alert alert-warning alert-dismissable"><button type="button" class="close" data-dismiss="alert" aria-hidden="true">&times;</button><strong>提示:</strong>您的浏览器版本太低了,建议升级到 <strong><a href="http://windows.microsoft.com/zh-cn/internet-explorer/download-ie" title="IE9">IE9</a></strong> 以上,本站使用<a href="https://www.google.com/intl/zh-CN/chrome/">Chrome浏览器</a>可以获得最好的显示效果.</div><![endif]-->
      <div class="page-header"><h1 align="center"><big>It so life</big> </h1>
        <h5 align="center"><big>love as life</big></h5>
      </div>
     </div>
     <div class="row">
       <div id="main-col" class="alignleft col-sx-12 col-sm-8 col-md-9 col-lg-9">
      <section id='header_widget'></section>
          <div id="wrapper"><article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_集合--Hash表分析以及Java实现/">Hash表分析以及Java实现</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:40.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_集合--Hash表分析以及Java实现/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="hash-java-">Hash表分析以及Java实现</h1>
<p><a href="http://www.iteye.com/" target="_blank">首页</a> <a href="http://www.iteye.com/news" target="_blank">新闻</a> <a href="http://www.iteye.com/forums" target="_blank">论坛</a> <a href="http://www.iteye.com/ask" target="_blank">问答</a> <a href="http://www.iteye.com/blogs" target="_blank">博客</a> <a href="http://www.iteye.com/job" target="_blank">招聘</a> <a href="http://java-mzd.iteye.com/blog/827523#" target="_blank">更多 ▼</a></p>
<p><a href="http://www.iteye.com/wiki" target="_blank">专栏</a>  <a href="http://www.iteye.com/groups" target="_blank">群组</a> <a href="http://www.iteye.com/search" target="_blank">搜索</a></p>
<p><a href="http://java-mzd.iteye.com/login" title="登录" target="_blank">您还未登录 !</a> <a href="http://www.iteye.com/all" target="_blank">我的应用</a> <a href="http://java-mzd.iteye.com/login" target="_blank">登录</a> <a href="http://java-mzd.iteye.com/signup" target="_blank">注册</a></p>
<h1 id="-java-mzd-http-java-mzd-iteye-com-"><a href="http://java-mzd.iteye.com/" target="_blank">java-mzd</a></h1>
<p>永久域名 <a href="http://java-mzd.iteye.com/" target="_blank"><a href="http://java-mzd.iteye.com">http://java-mzd.iteye.com</a></a></p>
<p><a href="http://java-mzd.iteye.com/blog/827523#" target="_blank">8顶</a>
<a href="http://java-mzd.iteye.com/blog/827523#" target="_blank">3踩</a></p>
<p><a href="http://java-mzd.iteye.com/blog/829890" title="简单Spring容器实现" target="_blank">简单Spring容器实现</a> | <a href="http://java-mzd.iteye.com/blog/826692" title="查找表分析（总论）" target="_blank">查找表分析（总论）</a></p>
<p>2010-11-29</p>
<h3 id="-hash-java-"><a href="">Hash表分析以及Java实现</a></h3>
<p><strong>文章分类:<a href="http://www.iteye.com/blogs/category/tech" target="_blank">综合技术</a></strong>
       这篇博客主要探讨<strong>Hash表</strong>中的一些原理/概念，及根据这些原理/概念，自己设计一个用来存放/查找数据的Hash表，并且与JDK中的HashMap类进行比较。</p>
<p>我们分一下七个步骤来进行。 </p>
<p><strong>一。    **</strong>Hash<strong>**表概念</strong></p>
<hr>
<p><strong>二 .      **</strong>Hash<strong>**构造函数的方法，及适用范围</strong></p>
<hr>
<p><strong>三.**</strong>      <strong><strong>Hash</strong></strong>处理冲突方法，各自特征**</p>
<hr>
<p><strong>四.**</strong>      <strong><strong>Hash</strong></strong>查找过程**</p>
<hr>
<p><strong>五.**</strong>      <strong><strong>实现一个使用</strong></strong>Hash<strong><strong>存数据的场景</strong></strong>-------Hash<strong>**查找算法，插入算法</strong></p>
<hr>
<p><strong>六.**</strong>      <strong><strong>JDK</strong></strong>中<strong><strong>HashMap</strong></strong>的实现**</p>
<hr>
<p><strong>七.**</strong>      <strong><strong>Hash</strong></strong>表与<strong><strong>HashMap</strong></strong>的对比，性能分析**</p>
<p> <strong>一。    **</strong>Hash<strong>**表概念 </strong></p>
<pre><code>           在查找表中我们已经说过，在Hash表中，**记录在表中的位置和其关键字之间存在着一种确定的关系**。这样       我们就能预先知道所查关键字在表中的位置，从而直接通过下标找到记录。使ASL趋近与0.



          1) ** **哈希(Hash)函数是一个映象，即： 将关键字的集合映射到某个地址集合上，它的设置很灵活，只要这个地       址集合的大小不超出允许范围即可；

         2)  由于哈希函数是一个压缩映象，因此，在一般情况下，很容易产生“冲突”现象，即： key1¹ key2，而  f            (key1) = f(key2)。

          3).  只能尽量减少冲突而不能完全避免冲突，这是因为通常关键字集合比较大，其元素包括所有可能的关键字，       而地址集合的元素仅为哈希表中的地址值



   在构造这种特殊的“查找表” 时，除了需要选择一个**“好”(尽可能少产生冲突)**的哈希函数之外；还需要找到一      种**“处理冲突”** 的方法。
</code></pre><p><strong>二 .    **</strong>Hash<strong>**构造函数的方法，及适用范围</strong></p>
<ul>
<li><strong>直接定址法</strong></li>
<li><strong>数字分析法</strong></li>
<li><strong>平方取中法</strong></li>
<li><strong>折叠法</strong></li>
<li><strong>除留余数法</strong></li>
<li><strong>随机数法</strong>      </li>
</ul>
<pre><code>  （1）直接定址法：

            哈希函数为关键字的线性函数，H(key) = key 或者 H(key) = a ´ key + b

          **此法仅适合于**：地址集合的大小 = = 关键字集合的大小，其中a和b为常数。

 （2）数字分析法：

         假设关键字集合中的每个关键字都是由 s 位数字组成 (u1, u2, …, us)，分析关键字集中的全体，                  并从中提取分布均匀的若干位或它们的组合作为地址。

         **此法适于:**能预先估计出全体关键字的每一位上各种数字出现的频度。

 （3）平方取中法：

           以关键字的平方值的中间几位作为存储地址。求“关键字的平方值” 的目的是“扩大差别” ，同                    时平方值的中间各位又能受到整个关键字中各位的影响。

         **此法适于:**关键字中的每一位都有某些数字重复出现频度很高的现象。

 （4）折叠法：

        将关键字分割成若干部分，然后取它们的叠加和为哈希地址。两种叠加处理的方法：移位叠加:将分                割后的几部分低位对齐相加；间界叠加:从一端沿分割界来回折叠，然后对齐相加。

        **此法适于：**关键字的数字位数特别多。

 （5）除留余数法：

         设定哈希函数为:H(key) = key MOD p   ( p≤m )，其中， m为表长，p 为不大于 m 的素数，或                 是不含 20 以下的质因子

 （6）随机数法：

       设定哈希函数为:H(key) = Random(key)其中，Random 为伪随机函数

       **此法适于：**对长度不等的关键字构造哈希函数。



     实际造表时，采用何种构造哈希函数的方法取决于建表的关键字集合的情况(包括关键字的范围和形态)，以及哈希表    长度（哈希地址范围），**总的原则是使产生冲突的可能性降到尽可能地小。**
</code></pre><p><strong>三.**</strong>      <strong><strong>Hash</strong></strong>处理冲突方法，各自特征**</p>
<p> <strong>“**</strong>处理冲突”<strong><strong>的实际含义是：</strong></strong>为产生冲突的关键字寻找下一个哈希地址。**</p>
<ul>
<li><strong> **</strong>开放定址法**</li>
<li><strong> **</strong>再哈希法**</li>
<li><strong> **</strong>链地址法**</li>
</ul>
<hr>
<pre><code>  （1）开放定址法：

           为产生冲突的关键字地址 H(key) 求得一个地址序列： H0, H1, H2, …, Hs  1≤s≤m-1，Hi = ( H(key)                  +di  ) MOD m，其中： i=1, 2, …, s，H(key)为哈希函数;m为哈希表长;



  （2）链地址法：
</code></pre><p><img src="" alt=""></p>
<pre><code>         将所有哈希地址相同的记录都链接在同一链表中。



  （3）再哈希法：

           方法：构造若干个哈希函数，当发生冲突时，根据另一个哈希函数计算下一个哈希地址，直到冲突不再发                  生。即：Hi=Rhi(key)     i=1,2,……k，其中：Rhi——不同的哈希函数，特点：计算时间增加****
</code></pre><p> <strong>四.**</strong>      <strong><strong>Hash</strong></strong>查找过程**</p>
<p><img src="" alt=""></p>
<p><strong> </strong>      对于给定值 K,计算哈希地址 i = H(K)，若 r[i] = NULL  则查找不成功，若 r[i].key = K  则查找成功， 否则 “求     下一地址 Hi” ，直至r[Hi] = NULL  (查找不成功)  或r[Hi].key = K  (查找成功) 为止。</p>
<p> <strong>五.**</strong>      <strong><strong>实现一个使用</strong></strong>Hash<strong><strong>存数据的场景</strong></strong>-------Hash<strong>**查找算法，插入算法</strong></p>
<pre><code>     假设我们要设计的是一个用来保存中南大学所有在校学生个人信息的数据表。因为在校学生数量也不是特别巨大(8W?)，每个学生的学号是唯一的,因此，我们可以简单的应用直接定址法，声明一个10W大小的数组，每个学生的学号作为主键。然后每次要添加或者查找学生，只需要根据需要去操作即可。

  但是，显然这样做是**很脑残**的。这样做系统的可拓展性和复用性就非常差了，比如有一天人数超过10W了？如果是用来保存别的数据呢？或者我只需要保存20条记录呢？声明大小为10W的数组显然是太浪费了的。



 如果我们是用来保存大数据量（比如银行的用户数，4大的用户数都应该有3-5亿了吧？），这时候我们计算出来的HashCode就很可能会有冲突了， 我们的系统应该有“处理冲突”的能力，此处我们**通过挂链法“处理冲突”**。



 如果我们的数据量非常巨大，并且还持续在增加，如果我们仅仅只是通过挂链法来处理冲突，可能我们的链上挂了上万个数据后，这个时候再通过静态搜索来查找链表，显然性能也是非常低的。所以我们的系统应该还能实现自动扩容，**当容量达到某比例后，即自动扩容，使装载因子保存在一个固定的水平上**。
</code></pre><p>综上所述，我们对这个Hash容器的基本要求应该有如下几点：</p>
<pre><code>         **满足Hash表的查找要求（废话）**
</code></pre><hr>
<p><strong>             能支持从小数据量到大数据量的自动转变（自动扩容）</strong></p>
<hr>
<p><strong>             使用挂链法解决冲突</strong></p>
<p>好了，既然都分析到这一步了，咱就闲话少叙，直接开始上代码吧。</p>
<p>Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>package cn.javamzd.collection.search;  </li>
<li></li>
<li>public class MyMap<K, V> {  </li>
<li>private int size;// 当前容量  </li>
<li>private static int INIT_CAPACITY = 16;// 默认容量  </li>
<li>private Entry<K, V>[] container;// 实际存储数据的数组对象  </li>
<li>private static float LOAD_FACTOR = 0.75f;// 装载因子  </li>
<li>private int max;// 能存的最大的数=capacity/*factor  </li>
<li></li>
<li>// 自己设置容量和装载因子的构造器  </li>
<li>public MyMap(int init_Capaticy, float load_factor) {  </li>
<li>if (init_Capaticy &lt; 0)  </li>
<li>throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot;  </li>
<li><ul>
<li>init_Capaticy);  </li>
</ul>
</li>
<li>if (load_factor &lt;= 0 || Float.isNaN(load_factor))  </li>
<li>throw new IllegalArgumentException(&quot;Illegal load factor: &quot;  </li>
<li><ul>
<li>load_factor);  </li>
</ul>
</li>
<li>this.LOAD_FACTOR = load_factor;  </li>
<li>max = (int) (init_Capaticy /* load_factor);  </li>
<li>container = new Entry[init_Capaticy];  </li>
<li>}  </li>
<li></li>
<li>// 使用默认参数的构造器  </li>
<li>public MyMap() {  </li>
<li>this(INIT_CAPACITY, LOAD_FACTOR);  </li>
<li>}  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* 存 </li>
<li>/*  </li>
<li>/* @param k </li>
<li>/* @param v </li>
<li>/* @return </li>
<li>/*/  </li>
<li>public boolean put(K k, V v) {  </li>
<li>// 1.计算K的hash值  </li>
<li>// 因为自己很难写出对不同的类型都适用的Hash算法，故调用JDK给出的hashCode()方法来计算hash值  </li>
<li>int hash = k.hashCode();  </li>
<li>//将所有信息封装为一个Entry  </li>
<li>Entry<K,V> temp=new Entry(k,v,hash);  </li>
<li>if(setEntry(temp, container)){  </li>
<li>// 大小加一  </li>
<li>size++;  </li>
<li>return true;  </li>
<li>}  </li>
<li>return false;  </li>
<li>}  </li>
<li></li>
<li></li>
<li>//<em>/</em> </li>
<li>/* 扩容的方法 </li>
<li>/*  </li>
<li>/* @param newSize </li>
<li>/*            新的容器大小 </li>
<li>/*/  </li>
<li>private void reSize(int newSize) {  </li>
<li>// 1.声明新数组  </li>
<li>Entry<K, V>[] newTable = new Entry[newSize];  </li>
<li>max = (int) (newSize /* LOAD_FACTOR);  </li>
<li>// 2.复制已有元素,即遍历所有元素，每个元素再存一遍  </li>
<li>for (int j = 0; j &lt; container.length; j++) {  </li>
<li>Entry<K, V> entry = container[j];  </li>
<li>//因为每个数组元素其实为链表，所以…………  </li>
<li>while (null != entry) {  </li>
<li>setEntry(entry, newTable);  </li>
<li>entry = entry.next;  </li>
<li>}  </li>
<li>}  </li>
<li>// 3.改变指向  </li>
<li>container = newTable;  </li>
<li></li>
<li>}  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/*将指定的结点temp添加到指定的hash表table当中 </li>
<li>/* 添加时判断该结点是否已经存在 </li>
<li>/* 如果已经存在，返回false </li>
<li>/* 添加成功返回true </li>
<li>/* @param temp </li>
<li>/* @param table </li>
<li>/* @return </li>
<li>/*/  </li>
<li>private boolean setEntry(Entry<K,V> temp,Entry[] table){  </li>
<li>// 根据hash值找到下标  </li>
<li>int index = indexFor(temp.hash, table.length);  </li>
<li>//根据下标找到对应元素  </li>
<li>Entry<K, V> entry = table[index];  </li>
<li>// 3.若存在  </li>
<li>if (null != entry) {  </li>
<li>// 3.1遍历整个链表，判断是否相等  </li>
<li>while (null != entry) {  </li>
<li>//判断相等的条件时应该注意，除了比较地址相同外，引用传递的相等用equals()方法比较  </li>
<li>//相等则不存，返回false  </li>
<li>if ((temp.key == entry.key||temp.key.equals(entry.key)) &amp;&amp; temp.hash == entry.hash&amp;&amp;(temp.value==entry.value||temp.value.equals(entry.value))) {  </li>
<li>return false;  </li>
<li>}  </li>
<li>//不相等则比较下一个元素  </li>
<li>else if (temp.key != entry.key &amp;&amp; temp.value != entry.value) {  </li>
<li>//到达队尾，中断循环  </li>
<li>if(null==entry.next){  </li>
<li>break;  </li>
<li>}  </li>
<li>// 没有到达队尾，继续遍历下一个元素  </li>
<li>entry = entry.next;  </li>
<li>}  </li>
<li>}  </li>
<li>// 3.2当遍历到了队尾，如果都没有相同的元素，则将该元素挂在队尾  </li>
<li>addEntry2Last(entry,temp);  </li>
<li></li>
<li>}  </li>
<li>// 4.若不存在,直接设置初始化元素  </li>
<li>setFirstEntry(temp,index,table);  </li>
<li>return true;  </li>
<li>}  </li>
<li></li>
<li>private void addEntry2Last(Entry<K, V> entry, Entry<K, V> temp) {  </li>
<li>if (size &gt; max) {  </li>
<li>reSize(container.length /* 4);  </li>
<li>}  </li>
<li>entry.next=temp;  </li>
<li></li>
<li>}  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* 将指定结点temp，添加到指定的hash表table的指定下标index中 </li>
<li>/* @param temp </li>
<li>/* @param index </li>
<li>/* @param table </li>
<li>/*/  </li>
<li>private void setFirstEntry(Entry<K, V> temp, int index, Entry[] table) {  </li>
<li>// 1.判断当前容量是否超标，如果超标，调用扩容方法  </li>
<li>if (size &gt; max) {  </li>
<li>reSize(table.length /* 4);  </li>
<li>}  </li>
<li>// 2.不超标，或者扩容以后，设置元素  </li>
<li>table[index] = temp;  </li>
<li>//！！！！！！！！！！！！！！！  </li>
<li>//因为每次设置后都是新的链表，需要将其后接的结点都去掉  </li>
<li>//NND，少这一行代码卡了哥哥7个小时（代码重构）  </li>
<li>temp.next=null;  </li>
<li>}  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* 取 </li>
<li>/*  </li>
<li>/* @param k </li>
<li>/* @return </li>
<li>/*/  </li>
<li>public V get(K k) {  </li>
<li>Entry<K, V> entry = null;  </li>
<li>// 1.计算K的hash值  </li>
<li>int hash = k.hashCode();  </li>
<li>// 2.根据hash值找到下标  </li>
<li>int index = indexFor(hash, container.length);  </li>
<li>// 3。根据index找到链表  </li>
<li>entry = container[index];  </li>
<li>// 3。若链表为空，返回null  </li>
<li>if (null == entry) {  </li>
<li>return null;  </li>
<li>}  </li>
<li>// 4。若不为空，遍历链表，比较k是否相等,如果k相等，则返回该value  </li>
<li>while (null != entry) {  </li>
<li>if (k == entry.key||entry.key.equals(k)) {  </li>
<li>return entry.value;  </li>
<li>}  </li>
<li>entry = entry.next;  </li>
<li>}  </li>
<li>// 如果遍历完了不相等，则返回空  </li>
<li>return null;  </li>
<li></li>
<li>}  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* 根据hash码，容器数组的长度,计算该哈希码在容器数组中的下标值 </li>
<li>/*  </li>
<li>/* @param hashcode </li>
<li>/* @param containerLength </li>
<li>/* @return </li>
<li>/*/  </li>
<li>public int indexFor(int hashcode, int containerLength) {  </li>
<li>return hashcode &amp; (containerLength - 1);  </li>
<li></li>
<li>}  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* 用来实际保存数据的内部类,因为采用挂链法解决冲突，此内部类设计为链表形式 </li>
<li>/*  </li>
<li>/* @param <K>key </li>
<li>/* @param <V> </li>
<li>/*            value </li>
<li>/*/  </li>
<li>class Entry<K, V> {  </li>
<li>Entry<K, V> next;// 下一个结点  </li>
<li>K key;// key  </li>
<li>V value;// value  </li>
<li>int hash;// 这个key对应的hash码，作为一个成员变量，当下次需要用的时候可以不用重新计算  </li>
<li></li>
<li>// 构造方法  </li>
<li>Entry(K k, V v, int hash) {  </li>
<li>this.key = k;  </li>
<li>this.value = v;  </li>
<li>this.hash = hash;  </li>
<li></li>
<li>}  </li>
<li></li>
<li>//相应的getter()方法  </li>
<li></li>
<li>}  </li>
<li>}<br>package cn.javamzd.collection.search; public class MyMap<K, V> { private int size;// 当前容量 private static int INIT_CAPACITY = 16;// 默认容量 private Entry<K, V>[] container;// 实际存储数据的数组对象 private static float LOAD_FACTOR = 0.75f;// 装载因子 private int max;// 能存的最大的数=capacity/<em>factor // 自己设置容量和装载因子的构造器 public MyMap(int init_Capaticy, float load_factor) { if (init_Capaticy &lt; 0) throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; + init_Capaticy); if (load_factor &lt;= 0 || Float.isNaN(load_factor)) throw new IllegalArgumentException(&quot;Illegal load factor: &quot; + load_factor); this.LOAD_FACTOR = load_factor; max = (int) (init_Capaticy /</em> load_factor); container = new Entry[init_Capaticy]; } // 使用默认参数的构造器 public MyMap() { this(INIT_CAPACITY, LOAD_FACTOR); } //<em>/</em> /<em> 存 /</em> /<em> @param k /</em> @param v /<em> @return /</em>/ public boolean put(K k, V v) { // 1.计算K的hash值 // 因为自己很难写出对不同的类型都适用的Hash算法，故调用JDK给出的hashCode()方法来计算hash值 int hash = k.hashCode(); //将所有信息封装为一个Entry Entry<K,V> temp=new Entry(k,v,hash); if(setEntry(temp, container)){ // 大小加一 size++; return true; } return false; } //<em>/</em> /<em> 扩容的方法 /</em> /<em> @param newSize /</em> 新的容器大小 /<em>/ private void reSize(int newSize) { // 1.声明新数组 Entry<K, V>[] newTable = new Entry[newSize]; max = (int) (newSize /</em> LOAD_FACTOR); // 2.复制已有元素,即遍历所有元素，每个元素再存一遍 for (int j = 0; j &lt; container.length; j++) { Entry<K, V> entry = container[j]; //因为每个数组元素其实为链表，所以………… while (null != entry) { setEntry(entry, newTable); entry = entry.next; } } // 3.改变指向 container = newTable; } //<em>/</em> /<em>将指定的结点temp添加到指定的hash表table当中 /</em> 添加时判断该结点是否已经存在 /<em> 如果已经存在，返回false /</em> 添加成功返回true /<em> @param temp /</em> @param table /<em> @return /</em>/ private boolean setEntry(Entry<K,V> temp,Entry[] table){ // 根据hash值找到下标 int index = indexFor(temp.hash, table.length); //根据下标找到对应元素 Entry<K, V> entry = table[index]; // 3.若存在 if (null != entry) { // 3.1遍历整个链表，判断是否相等 while (null != entry) { //判断相等的条件时应该注意，除了比较地址相同外，引用传递的相等用equals()方法比较 //相等则不存，返回false if ((temp.key == entry.key||temp.key.equals(entry.key)) &amp;&amp; temp.hash == entry.hash&amp;&amp;(temp.value==entry.value||temp.value.equals(entry.value))) { return false; } //不相等则比较下一个元素 else if (temp.key != entry.key &amp;&amp; temp.value != entry.value) { //到达队尾，中断循环 if(null==entry.next){ break; } // 没有到达队尾，继续遍历下一个元素 entry = entry.next; } } // 3.2当遍历到了队尾，如果都没有相同的元素，则将该元素挂在队尾 addEntry2Last(entry,temp); } // 4.若不存在,直接设置初始化元素 setFirstEntry(temp,index,table); return true; } private void addEntry2Last(Entry<K, V> entry, Entry<K, V> temp) { if (size &gt; max) { reSize(container.length /<em> 4); } entry.next=temp; } //</em>/<em> /</em> 将指定结点temp，添加到指定的hash表table的指定下标index中 /<em> @param temp /</em> @param index /<em> @param table /</em>/ private void setFirstEntry(Entry<K, V> temp, int index, Entry[] table) { // 1.判断当前容量是否超标，如果超标，调用扩容方法 if (size &gt; max) { reSize(table.length /<em> 4); } // 2.不超标，或者扩容以后，设置元素 table[index] = temp; //！！！！！！！！！！！！！！！ //因为每次设置后都是新的链表，需要将其后接的结点都去掉 //NND，少这一行代码卡了哥哥7个小时（代码重构） temp.next=null; } //</em>/<em> /</em> 取 /<em> /</em> @param k /<em> @return /</em>/ public V get(K k) { Entry<K, V> entry = null; // 1.计算K的hash值 int hash = k.hashCode(); // 2.根据hash值找到下标 int index = indexFor(hash, container.length); // 3。根据index找到链表 entry = container[index]; // 3。若链表为空，返回null if (null == entry) { return null; } // 4。若不为空，遍历链表，比较k是否相等,如果k相等，则返回该value while (null != entry) { if (k == entry.key||entry.key.equals(k)) { return entry.value; } entry = entry.next; } // 如果遍历完了不相等，则返回空 return null; } //<em>/</em> /<em> 根据hash码，容器数组的长度,计算该哈希码在容器数组中的下标值 /</em> /<em> @param hashcode /</em> @param containerLength /<em> @return /</em>/ public int indexFor(int hashcode, int containerLength) { return hashcode &amp; (containerLength - 1); } //<em>/</em> /<em> 用来实际保存数据的内部类,因为采用挂链法解决冲突，此内部类设计为链表形式 /</em> /<em> @param <K>key /</em> @param <V> /<em> value /</em>/ class Entry<K, V> { Entry<K, V> next;// 下一个结点 K key;// key V value;// value int hash;// 这个key对应的hash码，作为一个成员变量，当下次需要用的时候可以不用重新计算 // 构造方法 Entry(K k, V v, int hash) { this.key = k; this.value = v; this.hash = hash; } //相应的getter()方法 } }</li>
</ol>
<p> 代码中有相当清楚的注释了</p>
<p>在文章的最后这里，我要强烈的宣泄下感情</p>
<p>MLGBD，本来以为分析的挺到位了，写出这个东西也就最多需要个把小时吧</p>
<p>结果因为通宵作业，脑袋运转不灵</p>
<p>硬是花了哥三个小时才写出了</p>
<p>好不容易些出来了</p>
<p>我日</p>
<p>看着代码比较混乱</p>
<p>然后就对代码重构了下</p>
<p>把逻辑抽象清楚，进行重构就花了个多小时</p>
<p>好不容易构造好了</p>
<p>就开始了TMD的一直报错了----------大数据量测试时到大概5000就死循环了</p>
<p>各种调试，各种分析都觉得没错误</p>
<p> 最后花了哥7个小时终于找出来了</p>
<p>我擦</p>
<p>第一次初始化加的时候，因为每个元素的next都是空的</p>
<p>而扩充容量resize()时，因为冲突处理是链式结构的</p>
<p>当将他们重新hash添加的时候，重复的这些鸟元素的next是有元素的</p>
<p>一定要设置为null</p>
<p><strong>七.性能分析：</strong></p>
<pre><code>  1.因为冲突的存在，其查找长度不可能达到O(1)

  2哈希表的平均查找长度是装载因子a 的函数，而不是 n 的函数。

  3.用哈希表构造查找表时，可以选择一个适当的装填因子  ，使得平均查找长度限定在某个范围内。
</code></pre><p>   最后给出我们这个HashMap的性能</p>
<p>  测试代码
Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>public class Test {  </li>
<li></li>
<li>public static void main(String[] args) {  </li>
<li>MyMap<String, String> mm = new MyMap<String, String>();   </li>
<li>Long aBeginTime=System.currentTimeMillis();//记录BeginTime  </li>
<li>for(int i=0;i&lt;1000000;i++){  </li>
<li>mm.put(&quot;&quot;+i, &quot;&quot;+i/*100);  </li>
<li>}  </li>
<li>Long aEndTime=System.currentTimeMillis();//记录EndTime  </li>
<li>System.out.println(&quot;insert time--&gt;&quot;+(aEndTime-aBeginTime));  </li>
<li></li>
<li>Long lBeginTime=System.currentTimeMillis();//记录BeginTime  </li>
<li>mm.get(&quot;&quot;+100000);  </li>
<li>Long lEndTime=System.currentTimeMillis();//记录EndTime  </li>
<li>System.out.println(&quot;seach time---&gt;&quot;+(lEndTime-lBeginTime));  </li>
<li>}  </li>
<li><p>}<br>public class Test { public static void main(String[] args) { MyMap<String, String> mm = new MyMap<String, String>(); Long aBeginTime=System.currentTimeMillis();//记录BeginTime for(int i=0;i&lt;1000000;i++){ mm.put(&quot;&quot;+i, &quot;&quot;+i/*100); } Long aEndTime=System.currentTimeMillis();//记录EndTime System.out.println(&quot;insert time--&gt;&quot;+(aEndTime-aBeginTime)); Long lBeginTime=System.currentTimeMillis();//记录BeginTime mm.get(&quot;&quot;+100000); Long lEndTime=System.currentTimeMillis();//记录EndTime System.out.println(&quot;seach time---&gt;&quot;+(lEndTime-lBeginTime)); } }</p>
<p>100W个数据时，全部存储时间为1S多一点，而<strong>搜寻时间为0 </strong></p>
</li>
</ol>
<p>insert time--&gt;1536
seach time---&gt;0</p>
<p>好了，牢骚发完了</p>
<p>本来今天想写个<strong>有关大访问量处理的一些基本概念</strong>的文章</p>
<p>全泡汤了,明天写吧</p>
<p><a href="http://java-mzd.iteye.com/blog/827523#"><strong>8</strong>
顶</a><a href="http://java-mzd.iteye.com/blog/827523#"><strong>3</strong>
踩</a>
<a href="http://java-mzd.iteye.com/blog/829890" title="简单Spring容器实现" target="_blank">简单Spring容器实现</a> | <a href="http://java-mzd.iteye.com/blog/826692" title="查找表分析（总论）" target="_blank">查找表分析（总论）</a></p>
<ul>
<li>01:46</li>
<li>浏览 (854)</li>
<li><a href="http://java-mzd.iteye.com/blog/827523#comments" target="_blank">评论</a> (8)</li>
<li>分类: <a href="http://java-mzd.iteye.com/category/133623" target="_blank">数据结构----------JAVA类集</a></li>
<li><a href="http://www.iteye.com/wiki/topic/827523" target="_blank">相关推荐</a><h3 id="-">评论</h3>
</li>
</ul>
<p><a href=""></a></p>
<p>8 楼 <a href="http://dengyi04405.iteye.com/" target="_blank">dengyi04405</a> 2010-12-16   <a href="http://java-mzd.iteye.com/blog/827523#" target="_blank">引用</a></p>
<p>错了...是mm.get(&quot;&quot;+36309) 为null，在最后resize的时候挂在9的一起，然后丢失了。
setEntry(entry, newTable);   ----entry在first时next=null
entry = entry.next;---永远是null
7 楼 <a href="http://dengyi04405.iteye.com/" target="_blank">dengyi04405</a> 2010-12-16   <a href="http://java-mzd.iteye.com/blog/827523#" target="_blank">引用</a></p>
<p>resize()好像还是有bug，挂在一个链地址下的数据resize时只能取出第一个，后面的数据就丢失了。
for(int i=0;i&lt;90000;i++) 循环后mm.get(&quot;&quot;+100000)   是null
不知道是不是，楼主看看<img src="" alt="">  </p>
<p>6 楼 <a href="http://java-mzd.iteye.com/" target="_blank">java_mzd</a> 2010-12-01   <a href="http://java-mzd.iteye.com/blog/827523#" target="_blank">引用</a></p>
<p>heng_aa 写道</p>
<p>无聊又测了一下，死循环是因为while没有这种情况的判断，我是加上这些代码的：
else if(temp.key == entry.key &amp;&amp; temp.value != entry.value) {
entry.value = temp.value;
return true;
}
还有我查找不到数据，应该是在109行那里少加了这句吧，return true;因为没有这句下面的setFirstEntry(temp,index,table); 还会执行。<br>看看是不是这样！！！
恩~~确实需要加上这个判断~
不然当传入相同的key不同的value的时候，不会覆盖掉原理的value
这时候linked里面就会有相同的key，不同的value，后面那个value就没意义了。
  只是，这样还是没有死循环吖。。囧
恩，无论如何，这个BUG是确实需要改进的。
5 楼 <a href="http://heng-aa.iteye.com/" target="_blank">heng_aa</a> 2010-11-30   <a href="http://java-mzd.iteye.com/blog/827523#" target="_blank">引用</a></p>
<p>无聊又测了一下，死循环是因为while没有这种情况的判断，我是加上这些代码的：
else if(temp.key == entry.key &amp;&amp; temp.value != entry.value) {
entry.value = temp.value;
return true;
}
还有我查找不到数据，应该是在109行那里少加了这句吧，return true;因为没有这句下面的setFirstEntry(temp,index,table); 还会执行。<br>看看是不是这样！！！</p>
<p>4 楼 <a href="http://java-mzd.iteye.com/" target="_blank">java_mzd</a> 2010-11-30   <a href="http://java-mzd.iteye.com/blog/827523#" target="_blank">引用</a></p>
<p>heng_aa 写道</p>
<p>我测试了一下，发现几个问题。如果放入相同的key不同的value,程序就死循环了！还有扩容后，indexFor（）的算值就不同了，也就是说通过这个算法查找不到值了。无聊试一下而已，不过我也学到了不少东西，看这些问题能不能改进？？
谢谢提醒哦
分几点分析吧
扩容后，通过indexFor()计算的值肯定是需要变化的啊，因为这个时候计算规则变了啊
需要把每个元素重新散列到数组里去啊，这时候通过get()再取的时候，计算的时候，indexFor()是按照新的数组大小来的，所以肯定还是能找到的啊
至于死循环的问题，在重构代码前我测试是正常的，重构后忘了测试这个问题了。。
囧。。。等晚上再测试下再回答你吧。
3 楼 <a href="http://heng-aa.iteye.com/" target="_blank">heng_aa</a> 2010-11-30   <a href="http://java-mzd.iteye.com/blog/827523#" target="_blank">引用</a></p>
<p>我测试了一下，发现几个问题。如果放入相同的key不同的value,程序就死循环了！还有扩容后，indexFor（）的算值就不同了，也就是说通过这个算法查找不到值了。无聊试一下而已，不过我也学到了不少东西，看这些问题能不能改进？？</p>
<p>2 楼 <a href="http://java-mzd.iteye.com/" target="_blank">java_mzd</a> 2010-11-29   <a href="http://java-mzd.iteye.com/blog/827523#" target="_blank">引用</a></p>
<p>smithfox 写道</p>
<p>好文，对动态大数据量的Hash处理很有用.
幸苦了，注意身体呀!
多谢关照~~
1 楼 <a href="http://smithfox.iteye.com/" target="_blank">smithfox</a> 2010-11-29   <a href="http://java-mzd.iteye.com/blog/827523#" target="_blank">引用</a></p>
<p>好文，对动态大数据量的Hash处理很有用.
幸苦了，注意身体呀!</p>
<h3 id="-">发表评论</h3>
<h3 id="-">表情图标</h3>
<p><img src="" alt=""><img src="" alt=""><img src="" alt=""><img src="" alt=""><img src="" alt=""><img src="" alt=""><img src="" alt=""><img src="" alt=""><img src="" alt=""><img src="" alt=""><img src="" alt=""><img src="" alt=""><img src="" alt=""><img src="" alt=""><img src="" alt=""><img src="" alt=""><img src="" alt=""><img src="" alt=""><img src="" alt=""><img src="" alt=""></p>
<p>字体颜色: 标准深红红色橙色棕色黄色绿色橄榄青色蓝色深蓝靛蓝紫色灰色白色黑色 字体大小: 标准1 (xx-small)2 (x-small)3 (small)4 (medium)5 (large)6 (x-large)7 (xx-large) 对齐: 标准居左居中居右</p>
<p>提示：选择您需要装饰的文字, 按上列按钮即可添加上相应的标签</p>
<p>您还没有登录，请<a href="http://java-mzd.iteye.com/login" target="_blank">登录</a>后发表评论(快捷键 Alt+S / Ctrl+Enter)</p>
<p><a href="http://java-mzd.iteye.com/" target="_blank"><img src="&quot;java_mzd的博客: &quot;" alt="java_mzd的博客"></a></p>
<p>java_mzd</p>
<ul>
<li>浏览: 70475 次</li>
<li>性别: <img src="&quot;男&quot;" alt="Icon_minigender_1"></li>
<li>来自: 长沙</li>
<li><img src="" alt=""></li>
<li><a href="http://java-mzd.iteye.com/blog/profile" target="_blank">详细资料</a> <a href="http://java-mzd.iteye.com/blog/guest_book" target="_blank">留言簿</a></li>
</ul>
<h3 id="-">搜索本博客</h3>
<h3 id="-http-java-mzd-iteye-com-blog-user_visits-">最近访客 <a href="http://java-mzd.iteye.com/blog/user_visits" target="_blank">&gt;&gt;更多访客</a></h3>
<p><a href="http://msnvip.iteye.com/" target="_blank"><img src="&quot;msnvip的博客: msnvip&quot;" alt="msnvip的博客"></a></p>
<p><a href="http://msnvip.iteye.com/" target="_blank">msnvip</a></p>
<p><a href="http://kai2008.iteye.com/" target="_blank"><img src="&quot;qinjingkai的博客: 开门见山&quot;" alt="qinjingkai的博客"></a></p>
<p><a href="http://kai2008.iteye.com/" target="_blank">qinjingkai</a>
<a href="http://yanxd.iteye.com/" target="_blank"><img src="&quot;yanxd的博客: &quot;" alt="yanxd的博客"></a></p>
<p><a href="http://yanxd.iteye.com/" target="_blank">yanxd</a></p>
<p><a href="http://luwei-yinzhijie-com.iteye.com/" target="_blank"><img src="&quot;_bulrush的博客: &quot;" alt="_bulrush的博客"></a></p>
<p><a href="http://luwei-yinzhijie-com.iteye.com/" target="_blank">_bulrush</a></p>
<h3 id="-">博客分类</h3>
<ul>
<li><a href="http://java-mzd.iteye.com/" target="_blank">全部博客 (43)</a></li>
<li><a href="http://java-mzd.iteye.com/category/133623" target="_blank">数据结构----------JAVA类集 (5)</a></li>
<li><p><a href="http://java-mzd.iteye.com/category/153171" target="_blank">TCP/IP (7)</a></p>
<h3 id="-http-java-mzd-iteye-com-blog-guest_book-">我的留言簿 <a href="http://java-mzd.iteye.com/blog/guest_book" target="_blank">&gt;&gt;更多留言</a></h3>
</li>
<li><p>楼主 你工作多久了。。。。
-- by <a href="http://java-mzd.iteye.com/blog/guest_book#39913" target="_blank">fanmingxing</a></p>
</li>
<li>写的不错，学习，谢谢！
-- by <a href="http://java-mzd.iteye.com/blog/guest_book#39693" target="_blank">chenge2k</a></li>
<li>看了LZ的文章，发现工作快两年的我，就像是一块浮起来的木头，真的很惭愧！也不怪我拿 ...
-- by <a href="http://java-mzd.iteye.com/blog/guest_book#39618" target="_blank">GoTiger</a></li>
</ul>
<h3 id="-">其他分类</h3>
<ul>
<li><a href="http://java-mzd.iteye.com/blog/favorite" target="_blank">我的收藏</a> (23)</li>
<li><a href="http://java-mzd.iteye.com/blog/code_favorite" target="_blank">我的代码</a> (0)</li>
<li><a href="http://java-mzd.iteye.com/blog/topic" target="_blank">我的论坛主题帖</a> (3)</li>
<li><a href="http://java-mzd.iteye.com/blog/post" target="_blank">我的所有论坛帖</a> (34)</li>
<li><p><a href="http://java-mzd.iteye.com/blog/article" target="_blank">我的精华良好帖</a> (0)</p>
<h3 id="-">最近加入群组</h3>
</li>
<li><p><a href="http://android.group.iteye.com/" target="_blank">Android</a></p>
</li>
</ul>
<h3 id="-">存档</h3>
<ul>
<li><a href="http://java-mzd.iteye.com/blog/monthblog/2011-05" target="_blank">2011-05</a> (2)</li>
<li><a href="http://java-mzd.iteye.com/blog/monthblog/2011-04" target="_blank">2011-04</a> (7)</li>
<li><a href="http://java-mzd.iteye.com/blog/monthblog/2011-03" target="_blank">2011-03</a> (2)</li>
<li><p><a href="http://java-mzd.iteye.com/blog/monthblog_more" target="_blank">更多存档...</a></p>
<h3 id="-">评论排行榜</h3>
</li>
<li><p><a href="http://java-mzd.iteye.com/blog/1050043" title="腾讯、淘宝、金山网络，实习生我该何去何从" target="_blank">腾讯、淘宝、金山网络，实习生我该何去何从</a></p>
</li>
<li><a href="http://java-mzd.iteye.com/blog/1007577" title="TCP/IP传输层，你懂多少？" target="_blank">TCP/IP传输层，你懂多少？</a></li>
<li><a href="http://java-mzd.iteye.com/blog/1004784" title="淘宝武汉*面试归来" target="_blank">淘宝武汉/*面试归来</a></li>
<li><a href="http://java-mzd.iteye.com/blog/1050926" title="淘宝、金山网络，百感交集" target="_blank">淘宝、金山网络，百感交集</a></li>
<li><p><a href="http://java-mzd.iteye.com/blog/862787" title="开源软件？自由软件？免费软件？你了解多少？" target="_blank">开源软件？自由软件？免费软件？你了解多少 ...</a></p>
</li>
<li><p><a href="http://java-mzd.iteye.com/rss" target="_blank"><img src="" alt="Rss"></a></p>
</li>
<li><a href="http://fusion.google.com/add?feedurl=http://java-mzd.iteye.com/rss" target="_blank"><img src="" alt="Rss_google"></a>
声明：ITeye文章版权属于作者，受法律保护。没有作者书面许可不得转载。若作者同意转载，必须以超链接形式标明文章原始出处和作者。
© 2003-2011 ITeye.com. All rights reserved. [ 京ICP证110151号 ]
<img src="" alt=""></li>
</ul>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/Java_集合/">Java_集合</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/Java_集合/" class="label label-success">Java_集合</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:40"datetime="2014-03-07 09:54:40"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-Java_集合--Hash表分析以及Java实现/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-Java_集合--Hash表分析以及Java实现" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-IO--说说IO（二）-IO模型/">说说IO（二）</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:40.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-IO--说说IO（二）-IO模型/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-io-io-">说说IO（二）- IO模型</h1>
<p>这部分的东西在网络编程经常能看到，不过在所有IO处理中都是类似的。</p>
<p><strong>IO**</strong>请求的两个阶段**：</p>
<pre><code>   **等待资源阶段**：IO请求一般需要请求特殊的资源（如磁盘、RAM、文件），当资源被上一个使用者使用没有被释放时，IO请求就会被阻塞，直到能够使用这个资源。

   **使用资源阶段**：真正进行数据接收和发生。
</code></pre><p><strong>      </strong>举例说就是<strong>排队</strong>和<strong>服务。<em>**</em></strong></p>
<p><strong> </strong>在<strong>等待数据</strong>阶段，IO分为阻塞IO和非阻塞IO。</p>
<p><strong>      **</strong>阻塞IO**：资源不可用时，IO请求一直阻塞，直到反馈结果（有数据或超时）。</p>
<p><strong>      **</strong>非阻塞IO**：资源不可用时，IO请求离开返回，返回数据标识资源不可用</p>
<p><strong> </strong>在<strong>使用资源</strong>阶段，IO分为同步IO和异步IO。</p>
<p><strong>      **</strong>同步IO**：应用阻塞在发送或接收数据的状态，直到数据成功传输或返回失败。</p>
<p><strong>       异步IO</strong>：应用发送或接收数据后立刻返回，数据写入OS缓存，由OS完成数据发送或接收，并返回成功或失败的信息给应用。</p>
<p><img src="" alt=""></p>
<p><strong>按照Unix**</strong>的5<strong><strong>个IO</strong></strong>模型划分**</p>
<ul>
<li>阻塞IO</li>
<li>非阻塞IO</li>
<li>IO复用</li>
<li>信号驱动的IO</li>
<li>异步IO</li>
</ul>
<p>从性能上看，异步IO的性能无疑是最好的。</p>
<p><strong>各种IO**</strong>的特点**</p>
<ul>
<li><strong>阻塞IO</strong>：使用简单，但随之而来的问题就是会形成阻塞，需要独立线程配合，而这些线程在大多数时候都是没有进行运算的。Java的BIO使用这种方式，问题带来的问题很明显，一个Socket需要一个独立的线程，因此，会造成线程膨胀。</li>
<li><strong>非阻塞IO</strong>：采用轮询方式，不会形成线程的阻塞。Java的NIO使用这种方式，对比BIO的优势很明显，可以使用一个线程进行所有Socket的监听（select）。大大减少了线程数。</li>
</ul>
<ul>
<li><strong>同步IO</strong>：同步IO保证一个IO操作结束之后才会返回，因此同步IO效率会低一些，但是对应用来说，编程方式会简单。Java的BIO和NIO都是使用这种方式进行数据处理。</li>
<li><strong>异步IO</strong>：由于异步IO请求只是写入了缓存，从缓存到硬盘是否成功不可知，因此异步IO相当于把一个IO拆成了两部分，一是发起请求，二是获取处理结果。因此，对应用来说增加了复杂性。但是异步IO的性能是所有很好的，而且异步的思想贯穿了IT系统放放面面。</li>
</ul>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/IO/">IO</a></li></span></span> | <span class="tags">Tagged <a href="/tags/IO/" class="label label-primary">IO</a><a href="/tags/Java&J2EE/" class="label label-success">Java&J2EE</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:40"datetime="2014-03-07 09:54:40"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-IO--说说IO（二）-IO模型/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-IO--说说IO（二）-IO模型" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-IO--说说IO（三）-IO性能的重要指标/">说说IO（三）</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:40.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-IO--说说IO（三）-IO性能的重要指标/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-io-io-">说说IO（三）- IO性能的重要指标</h1>
<p><strong>最重要的三个指标</strong></p>
<p><strong>IOPS</strong></p>
<p>IOPS，即每秒钟处理的IO请求数量。IOPS是随机访问类型业务（OLTP类）很重要的一个参考指标。</p>
<ul>
<li><strong>一块物理硬盘能提供多少IOPS**</strong>？**</li>
</ul>
<p>从磁盘上进行数据读取时，比较重要的几个时间是：<strong>寻址时间</strong>（找到数据块的起始位置），<strong>旋转时间</strong>（等待磁盘旋转到数据块的起始位置），<strong>传输时间</strong>（读取数据的时间和返回的时间）。其中寻址时间是固定的（磁头定位到数据的存储的扇区即可），旋转时间受磁盘转速的影响，传输时间受数据量大小的影响和接口类型的影响（不用硬盘接口速度不同），但是在随机访问类业务中，他的时间也很少。因此，在硬盘接口相同的情况下，IOPS主要受限于寻址时间和传输时间。以一个15K的硬盘为例，寻址时间固定为4ms，传输时间为60s/15000/*1/2=2ms，忽略传输时间。1000ms/6ms=167个IOPS。</p>
<ul>
<li><strong>OS**</strong>的一次IO<strong><strong>请求对应物理硬盘一个IO</strong></strong>吗？**</li>
</ul>
<p>在没有文件系统、没有VM（卷管理）、没有RAID、没有存储设备的情况下，这个答案还是成立的。但是当这么多中间层加进去以后，这个答案就不是这样了。物理硬盘提供的IO是有限的，也是整个IO系统存在瓶颈的最大根源。所以，如果一块硬盘不能提供，那么多块在一起并行处理，这不就行了吗？确实是这样的。可以看到，<strong>越是高端的存储设备的**</strong>cache越大，硬盘越多，一方面通过cache异步处理IO，另一方面通过盘数增加，尽可能把一个OS的IO<strong>**分布到不同硬盘上，从而提高性能</strong>。文件系统则是在cache上会影响，而VM则可能是一个IO分布到多个不同设备上（Striping）。</p>
<p>所以，<strong>一个**</strong>OS的IO在经过多个中间层以后，发生在物理磁盘上的IO<strong>**是不确定的。可能是一对一个，也可能一个对应多个</strong>。</p>
<ul>
<li><strong>IOPS**</strong>能算出来吗？**</li>
</ul>
<p>对单块磁盘的IOPS的计算没有没问题，但是当系统后面接的是一个存储系统时、考虑不同读写比例，IOPS则很难计算，而需要根据实际情况进行测试。主要的因素有：  </p>
<ul>
<li></li>
<li><strong>存储系统本身有自己的缓存</strong>。缓存大小直接影响IOPS，理论上说，缓存越大能cache的东西越多，在cache命中率保持的情况下，IOPS会越高。</li>
<li><strong>RAID**</strong>级别**。不同的RAID级别影响了物理IO的效率。</li>
<li><strong>读写混合比例</strong>。对读操作，一般只要cache能足够大，可以大大减少物理IO，而都在cache中进行；对写操作，不论cache有多大，最终的写还是会落到磁盘上。因此，100%写的IOPS要越狱小于100%的读的IOPS。同时，100%写的IOPS大致等同于存储设备能提供的物理的IOPS。</li>
<li><strong>一次IO**</strong>请求数据量的多少**。一次读写1KB和一次读写1MB，显而易见，结果是完全不同的。</li>
</ul>
<p>当时上面N多因素混合在一起以后，IOPS的值就变得扑朔迷离了。所以，一般需要通过实际应用的测试才能获得。 </p>
<p><strong>IO Response Time</strong></p>
<p>即IO的响应时间。IO响应时间是从操作系统内核发出一个IO请求到接收到IO响应的时间。因此，IO Response time除了包括磁盘获取数据的时间，还包括了操作系统以及在存储系统内部IO等待的时间。一般看，随IOPS增加，因为IO出现等待，IO响应时间也会随之增加。对一个OLTP系统，10ms以内的响应时间，是比较合理的。下面是一些IO性能示例：</p>
<ul>
<li><strong>一个8K的IO会比一个64K的IO**</strong>速度快**，因为数据读取的少些。</li>
<li><strong>一个64K的IO会比8个8K的IO**</strong>速度快**，因为前者只请求了一个IO而后者是8个IO。</li>
<li><strong>串行IO会比随机IO**</strong>快**，因为串行IO相对随机IO说，即便没有Cache，串行IO在磁盘处理上也会少些操作。</li>
</ul>
<p>需要注意，IOPS与IO Response Time有着密切的联系。一般情况下，IOPS增加，说明IO请求多了，IO Response Time会相应增加。但是会出现IOPS一直增加，但是IO Response Time变得非常慢，超过20ms甚至几十ms，这时候的IOPS虽然还在提高，但是意义已经不大，因为整个IO系统的服务时间已经不可取。</p>
<p><strong>Throughput</strong></p>
<p>为吞吐量。这个指标衡量标识了最大的数据传输量。如上说明，<strong>这个值在顺序访问或者大数据量访问的情况下会比较重要</strong>。尤其在大数据量写的时候。</p>
<p>吞吐量不像IOPS影响因素很多，吞吐量一般受限于一些比较固定的因素，如：网络带宽、IO传输接口的带宽、硬盘接口带宽等。一般他的值就等于上面几个地方中某一个的瓶颈。</p>
<p><strong>一些概念</strong></p>
<p> <strong>IO Chunk Size</strong></p>
<p>即单个IO操作请求数据的大小。一次IO操作是指从发出IO请求到返回数据的过程。IO Chunk Size与应用或业务逻辑有着很密切的关系。比如像Oracle一类数据库，由于其block size一般为8K，读取、写入时都此为单位，因此，8K为这个系统主要的IO Chunk Size。<strong>IO Chunk Size</strong></p>
<p>小，考验的是IO系统的IOPS能力；<strong>IO Chunk Size</strong>大，考验的时候IO系统的IO吞吐量。</p>
<hr>
<p><strong>Queue Deep</strong></p>
<p>熟悉数据库的人都知道，SQL是可以批量提交的，这样可以大大提高操作效率。IO请求也是一样，IO请求可以积累一定数据，然后一次提交到存储系统，这样一些相邻的数据块操作可以进行合并，减少物理IO数。而且Queue Deep如其名，就是设置一起提交的IO请求数量的。一般Queue Deep在IO驱动层面上进行配置。</p>
<p>Queue Deep与IOPS有着密切关系。Queue Deep主要考虑批量提交IO请求，自然只有IOPS是瓶颈的时候才会有意义，如果IO都是大IO，磁盘已经成瓶颈，Queue Deep意义也就不大了。一般来说，IOPS的峰值会随着Queue Deep的增加而增加(不会非常显著)，Queue Deep一般小于256。</p>
<hr>
<p><strong>随机访问（随机IO**</strong>）、顺序访问（顺序IO<strong>**）</strong></p>
<p>随机访问的特点是<strong>每次**</strong>IO<strong>**请求的数据在磁盘上的位置跨度很大</strong>（如：分布在不同的扇区），因此N个非常小的IO请求（如：1K），必须以N次IO请求才能获取到相应的数据。</p>
<p>顺序访问的特点跟随机访问相反，<strong>它请求的数据在磁盘的位置是连续的</strong>。当系统发起N个非常小的IO请求（如：1K）时，因为一次IO是有代价的，系统会取完整的一块数据（如4K、8K），所以当第一次IO完成时，后续IO请求的数据可能已经有了。这样可以减少IO请求的次数。这也就是所谓的预取。</p>
<p>随机访问和顺序访问同样是有应用决定的。如数据库、小文件的存储的业务，大多是随机IO。而视频类业务、大文件存取，则大多为顺序IO。</p>
<p><strong>选取合理的观察指标：</strong></p>
<p>以上各指标中，不用的应用场景需要观察不同的指标，因为应用场景不同，有些指标甚至是没有意义的。</p>
<p><strong>随机访问和IOPS</strong>: 在随机访问场景下，IOPS往往会到达瓶颈，而这个时候去观察Throughput，则往往远低于理论值。</p>
<p><strong>顺序访问和Throughput</strong>：在顺序访问的场景下，Throughput往往会达到瓶颈（磁盘限制或者带宽），而这时候去观察IOPS，往往很小。</p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/IO/">IO</a></li></span></span> | <span class="tags">Tagged <a href="/tags/IO/" class="label label-primary">IO</a><a href="/tags/Java&J2EE/" class="label label-success">Java&J2EE</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:40"datetime="2014-03-07 09:54:40"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-IO--说说IO（三）-IO性能的重要指标/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-IO--说说IO（三）-IO性能的重要指标" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-IO--java中的io系统详解/">java中的io系统详解</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:40.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-IO--java中的io系统详解/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="java-io-">java中的io系统详解</h1>
<p>Java 流在处理上分为字符流和字节流。字符流处理的单元为 2 个字节的 Unicode 字符，分别操作字符、字符数组或字符串，而字节流处理单元为 1 个字节，操作字节和字节数组。</p>
<p>Java 内用 Unicode 编码存储字符，字符流处理类负责将外部的其他编码的字符流和 java 内 Unicode 字符流之间的转换。而类 InputStreamReader 和 OutputStreamWriter 处理字符流和字节流的转换。字符流（一次可以处理一个缓冲区）一次操作比字节流（一次一个字节）效率高。 </p>
<p><strong>( 一 )以字节为导向的 stream------InputStream/OutputStream</strong></p>
<p>InputStream 和 OutputStream 是两个 abstact 类，对于字节为导向的 stream 都扩展这两个鸡肋（基类 ^_^ ） ;</p>
<p>1、 InputStream</p>
<p><img src="http://www.blogjava.net/images/blogjava_net/sinojava/etc/42134.gif" alt="42134.gif"> </p>
<p>1.1</p>
<p>ByteArrayInputStream -- 把内存中的一个缓冲区作为 InputStream 使用 .</p>
<p>construct---</p>
<p>(A)ByteArrayInputStream(byte[]) 创建一个新字节数组输入流（ ByteArrayInputStream ），它从指定字节数组中读取数据（ 使用 byte 作为其缓冲区数组）</p>
<p>(B)---ByteArrayInputStream(byte[], int, int) 创建一个新字节数组输入流，它从指定字节数组中读取数据。</p>
<p>---mark:: 该字节数组未被复制。</p>
<p>1.2</p>
<p>StringBufferInputStream -- 把一个 String 对象作为 InputStream .</p>
<p>construct---  </p>
<p>StringBufferInputStream(String) 据指定串创建一个读取数据的输入流串。</p>
<p>注释：不推荐使用 StringBufferInputStream 方法。 此类不能将字符正确的转换为字节。</p>
<p>同 JDK 1.1 版中的类似，从一个串创建一个流的最佳方法是采用 StringReader 类。</p>
<p>1.3</p>
<p>FileInputStream -- 把一个文件作为 InputStream ，实现对文件的读取操作</p>
<p>construct---</p>
<p>(A)FileInputStream(File name) 创建一个输入文件流，从指定的 File 对象读取数据。</p>
<p>(B)FileInputStream(FileDescriptor) 创建一个输入文件流，从指定的文件描述器读取数据。</p>
<p>(C)-FileInputStream(String  name) 创建一个输入文件流，从指定名称的文件读取数据。</p>
<p>method ---- read() 从当前输入流中读取一字节数据。</p>
<p>read(byte[]) 将当前输入流中 b.length 个字节数据读到一个字节数组中。</p>
<p>read(byte[], int, int) 将输入流中 len 个字节数据读入一个字节数组中。</p>
<p>1.4</p>
<p>PipedInputStream ：实现了 pipe 的概念，主要在线程中使用 . 管道输入流是指一个通讯管道的接收端。</p>
<p>一个线程通过管道输出流发送数据，而另一个线程通过管道输入流读取数据，这样可实现两个线程间的通讯。</p>
<p>construct---</p>
<p>PipedInputStream() 创建一个管道输入流，它还未与一个管道输出流连接。</p>
<p>PipedInputStream(PipedOutputStream) 创建一个管道输入流 , 它已连接到一个管道输出流。</p>
<p>1.5</p>
<p>SequenceInputStream ：把多个 InputStream 合并为一个 InputStream . “序列输入流”类允许应用程序把几个输入流连续地合并起来，</p>
<p>并且使它们像单个输入流一样出现。每个输入流依次被读取，直到到达该流的末尾。</p>
<p>然后“序列输入流”类关闭这个流并自动地切换到下一个输入流。</p>
<p>construct---</p>
<p>SequenceInputStream(Enumeration) 创建一个新的序列输入流，并用指定的输入流的枚举值初始化它。</p>
<p>SequenceInputStream(InputStream, InputStream) 创建一个新的序列输入流，初始化为首先 读输入流 s1, 然后读输入流 s2 。 </p>
<p>2、 OutputSteam</p>
<p><img src="http://www.blogjava.net/images/blogjava_net/sinojava/etc/42135.gif" alt="42135.gif">
2.1</p>
<p>ByteArrayOutputStream ： 把信息存入内存中的一个缓冲区中 . 该类实现一个以字节数组形式写入数据的输出流。</p>
<p>当数据写入缓冲区时，它自动扩大。用 toByteArray() 和 toString() 能检索数据。</p>
<p>constructor</p>
<p>(A)--- ByteArrayOutputStream() 创建一个新的字节数组输出流。</p>
<p>(B)--- ByteArrayOutputStream() 创建一个新的字节数组输出流。</p>
<p>(C)--- ByteArrayOutputStream(int) 创建一个新的字节数组输出流，并带有指定大小字节的缓冲区容量。</p>
<p>toString(String) 根据指定字符编码将缓冲区内容转换为字符串，并将字节转换为字符。</p>
<p>write(byte[], int, int) 将指定字节数组中从偏移量 off 开始的 len 个字节写入该字节数组输出流。</p>
<p>write(int) 将指定字节写入该字节数组输出流。</p>
<p>writeTo(OutputStream) 用 out.write(buf, 0, count) 调用输出流的写方法将该字节数组输出流的全部内容写入指定的输出流参数。</p>
<p>2.2  </p>
<p>FileOutputStream: 文件输出流是向 File 或 FileDescriptor 输出数据的一个输出流。</p>
<p>constructor</p>
<p>(A)FileOutputStream(File  name) 创建一个文件输出流，向指定的 File 对象输出数据。</p>
<p>(B)FileOutputStream(FileDescriptor) 创建一个文件输出流，向指定的文件描述器输出数据。</p>
<p>(C)FileOutputStream(String  name) 创建一个文件输出流，向指定名称的文件输出数据。</p>
<p>(D)FileOutputStream(String, boolean) 用指定系统的文件名，创建一个输出文件。</p>
<p>2.3</p>
<p>PipedOutputStream: 管道输出流是指一个通讯管道的发送端。 一个线程通过管道输出流发送数据，</p>
<p>而另一个线程通过管道输入流读取数据，这样可实现两个线程间的通讯。</p>
<p>constructor</p>
<p>(A)PipedOutputStream() 创建一个管道输出流，它还未与一个管道输入流连接。</p>
<p>(B)PipedOutputStream(PipedInputStream) 创建一个管道输出流，它已连接到一个管道输入流。 </p>
<p><strong>( 二 )以字符为导向的 stream Reader/Writer</strong></p>
<p>以 Unicode 字符为导向的 stream ，表示以 Unicode 字符为单位从 stream 中读取或往 stream 中写入信息。</p>
<p>Reader/Writer 为 abstact 类</p>
<p>以 Unicode 字符为导向的 stream 包括下面几种类型：</p>
<ol>
<li>Reader</li>
</ol>
<p><img src="http://www.blogjava.net/images/blogjava_net/sinojava/etc/42136.gif" alt="42136.gif"> </p>
<p>1.1</p>
<p>  CharArrayReader ：与 ByteArrayInputStream 对应此类实现一个可用作字符输入流的字符缓冲区</p>
<p>constructor</p>
<p>CharArrayReader(char[]) 用指定字符数组创建一个 CharArrayReader 。</p>
<p>CharArrayReader(char[], int, int) 用指定字符数组创建一个 CharArrayReader</p>
<p>1.2</p>
<p>StringReader ： 与 StringBufferInputStream 对应其源为一个字符串的字符流。</p>
<p>StringReader(String) 创建一新的串读取者。</p>
<p>1.3</p>
<p>FileReader ： 与 FileInputStream 对应</p>
<p>1.4</p>
<p>PipedReader ：与 PipedInputStream 对应</p>
<ol>
<li><p>Writer</p>
<p><img src="http://www.blogjava.net/images/blogjava_net/sinojava/etc/42137.gif" alt="42137.gif"></p>
</li>
</ol>
<p>2.1    CharArrayWrite ： 与 ByteArrayOutputStream 对应</p>
<p>2.2   StringWrite ：无与之对应的以字节为导向的 stream</p>
<p>2.3  FileWrite ： 与 FileOutputStream 对应</p>
<p>2.4  PipedWrite ：与 PipedOutputStream 对应 </p>
<p>3、两种不同导向的 stream 之间的转换  </p>
<p>3.1</p>
<p>InputStreamReader 和 OutputStreamReader ：</p>
<p>把一个以字节为导向的 stream 转换成一个以字符为导向的 stream 。</p>
<p>InputStreamReader 类是从字节流到字符流的桥梁：它读入字节，并根据指定的编码方式，将之转换为字符流。</p>
<p>使用的编码方式可能由名称指定，或平台可接受的缺省编码方式。</p>
<p>InputStreamReader 的 read() 方法之一的每次调用，可能促使从基本字节输入流中读取一个或多个字节。</p>
<p>为了达到更高效率，考虑用 BufferedReader 封装 InputStreamReader ，</p>
<p>BufferedReader in = new BufferedReader(new InputStreamReader(System.in));</p>
<p>例如： // 实现从键盘输入一个整数</p>
<ol>
<li>String s = null;             </li>
<li>InputStreamReader re = new InputStreamReader(System.in);  </li>
<li><pre><code>       BufferedReader br = new BufferedReader(re);  
</code></pre></li>
<li><pre><code>       try {  
</code></pre></li>
<li><pre><code>       s = br.readLine();  
</code></pre></li>
<li><pre><code>       System.out.println(&quot;s= &quot; + Integer.parseInt(s));  
</code></pre></li>
<li><pre><code>       br.close();  
</code></pre></li>
<li><pre><code>       }  
</code></pre></li>
<li><pre><code>       catch (IOException e)  
</code></pre></li>
<li><pre><code>       {  
</code></pre></li>
<li><pre><code>       e.printStackTrace();  
</code></pre></li>
<li><pre><code>       }  
</code></pre></li>
<li><pre><code>       catch (NumberFormatException e)// 当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常。  
</code></pre></li>
<li><pre><code>       {  
</code></pre></li>
<li><pre><code>       System.out.println(&quot; 输入的不是数字 &quot;);  
</code></pre></li>
<li><pre><code>       }  
</code></pre></li>
</ol>
<p>InputStreamReader(InputStream) 用缺省的字符编码方式，创建一个 InputStreamReader 。</p>
<p>InputStreamReader(InputStream, String) 用已命名的字符编码方式，创建一个 InputStreamReader 。</p>
<p>OutputStreamWriter 将多个字符写入到一个输出流，根据指定的字符编码将多个字符转换为字节。</p>
<p>每个 OutputStreamWriter 合并它自己的 CharToByteConverter, 因而是从字符流到字节流的桥梁。</p>
<p><strong>（三）Java IO 的一般使用原则 ：  </strong></p>
<p>一、按数据来源（去向）分类：</p>
<p>1 、是文件： FileInputStream, FileOutputStream, ( 字节流 )FileReader, FileWriter( 字符 )</p>
<p>2 、是 byte[] ： ByteArrayInputStream, ByteArrayOutputStream( 字节流 )</p>
<p>3 、是 Char[]: CharArrayReader, CharArrayWriter( 字符流 )</p>
<p>4 、是 String: StringBufferInputStream, StringBufferOuputStream ( 字节流 )StringReader, StringWriter( 字符流 )</p>
<p>5 、网络数据流： InputStream, OutputStream,( 字节流 ) Reader, Writer( 字符流 )</p>
<p>二、按是否格式化输出分：</p>
<p>1 、要格式化输出： PrintStream, PrintWriter</p>
<p>三、按是否要缓冲分：</p>
<p>1 、要缓冲： BufferedInputStream, BufferedOutputStream,( 字节流 ) BufferedReader, BufferedWriter( 字符流 )</p>
<p>四、按数据格式分：</p>
<p>1 、二进制格式（只要不能确定是纯文本的） : InputStream, OutputStream 及其所有带 Stream 结束的子类</p>
<p>2 、纯文本格式（含纯英文与汉字或其他编码方式）； Reader, Writer 及其所有带 Reader, Writer 的子类</p>
<p>五、按输入输出分：</p>
<p>1 、输入： Reader, InputStream 类型的子类</p>
<p>2 、输出： Writer, OutputStream 类型的子类</p>
<p>六、特殊需要：</p>
<p>1 、从 Stream 到 Reader,Writer 的转换类： InputStreamReader, OutputStreamWriter</p>
<p>2 、对象输入输出： ObjectInputStream, ObjectOutputStream</p>
<p>3 、进程间通信： PipeInputStream, PipeOutputStream, PipeReader, PipeWriter</p>
<p>4 、合并输入： SequenceInputStream</p>
<p>5 、更特殊的需要： PushbackInputStream, PushbackReader, LineNumberInputStream, LineNumberReader</p>
<p>决定使用哪个类以及它的构造进程的一般准则如下（不考虑特殊需要）：</p>
<p>首先，考虑最原始的数据格式是什么： 原则四</p>
<p>第二，是输入还是输出：原则五</p>
<p>第三，是否需要转换流：原则六第 1 点</p>
<p>第四，数据来源（去向）是什么：原则一</p>
<p>第五，是否要缓冲：原则三 （特别注明：一定要注意的是 readLine() 是否有定义，有什么比 read, write 更特殊的输入或输出方法）</p>
<p>第六，是否要格式化输出：原则二 </p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/IO/">IO</a></li></span></span> | <span class="tags">Tagged <a href="/tags/IO/" class="label label-primary">IO</a><a href="/tags/Java&J2EE/" class="label label-success">Java&J2EE</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:40"datetime="2014-03-07 09:54:40"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-IO--java中的io系统详解/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-IO--java中的io系统详解" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-IO--说说IO（一）-IO的分层/">说说IO（一）</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:40.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-IO--说说IO（一）-IO的分层/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-io-io-">说说IO（一）- IO的分层</h1>
<p>IO性能对于一个系统的影响是至关重要的。一个系统经过多项优化以后，瓶颈往往落在数据库；而数据库经过多种优化以后，瓶颈最终会落到IO。而IO性能的发展，明显落后于CPU的发展。Memchached也好，NoSql也好，这些流行技术的背后都在直接或者间接地回避IO瓶颈，从而提高系统性能。</p>
<p><strong>IO**</strong>系统的分层：**</p>
<p><img src="" alt=""></p>
<ol>
<li>三层结构</li>
</ol>
<p>上图层次比较多，但总的就是三部分。<strong>磁盘</strong>（存储）、<strong>VM</strong>（卷管理）和<strong>文件系统</strong>。专有名词不好理解，打个比方说：磁盘就相当于一块待用的空地；LVM相当于空地上的围墙（把空地划分成多个部分）；文件系统则相当于每块空地上建的楼房（决定了有多少房间、房屋编号如何，能容纳多少人住）；而房子里面住的人，则相当于系统里面存的数据。</p>
<ul>
<li><strong>文件系统—数据如何存放？</strong></li>
</ul>
<p>对应了上图的File System和Buffer Cache。</p>
<p><strong>File System**</strong>（文件系统）：解决了空间管理的问题**，即：数据如何存放、读取。</p>
<p><strong>Buffer Cache</strong>：解决数据缓冲的问题。对读，进行cache，即：缓存经常要用到的数据；对写，进行buffer，缓冲一定数据以后，一次性进行写入。</p>
<ul>
<li><strong>VM—磁盘空间不足了怎么办？</strong></li>
</ul>
<p>对应上图的Vol Mgmt。</p>
<p>VM其实跟IO没有必然联系。他是处于文件系统和磁盘（存储）中间的一层。<strong>VM**</strong>屏蔽了底层磁盘对上层文件系统的影响**。当没有VM的时候，文件系统直接使用存储上的地址空间，因此文件系统直接受限于物理硬盘，这时如果发生磁盘空间不足的情况，对应用而言将是一场噩梦，不得不新增硬盘，然后重新进行数据复制。而VM则可以实现动态扩展，而对文件系统没有影响。另外，VM也可以把多个磁盘合并成一个磁盘，对文件系统呈现统一的地址空间，这个特性的杀伤力不言而喻。</p>
<ul>
<li><strong>存储—数据放在哪儿？如何访问？如何提高IO速度？</strong></li>
</ul>
<p>对应上图的Device Driver、IO Channel和Disk Device</p>
<p>数据最终会放在这里，因此，效率、数据安全、容灾是这里需要考虑的问题。而提高存储的性能，则可以直接提高物理IO的性能</p>
<pre><code>2. Logical IO vs Physical IO
</code></pre><p>逻辑IO是操作系统发起的IO，这个数据可能会放在磁盘上，也可能会放在内存（文件系统的Cache）里。</p>
<p>物理IO是设备驱动发起的IO，这个数据最终会落在磁盘上。</p>
<pre><code>  逻辑IO和物理IO不是一一对应的。
</code></pre>
      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/IO/">IO</a></li></span></span> | <span class="tags">Tagged <a href="/tags/IO/" class="label label-primary">IO</a><a href="/tags/Java&J2EE/" class="label label-success">Java&J2EE</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:40"datetime="2014-03-07 09:54:40"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-IO--说说IO（一）-IO的分层/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-IO--说说IO（一）-IO的分层" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>





<ul id="pagination" class="pagination pagination-lg">
  <li><a class="extend prev" href="/page/65/">&laquo;</a></li><li><a class="page-number" href="/">1</a></li><li><a class="page-number" href="/page/2/">2</a></li><li><span class="space">&hellip;</span></li><li><a class="page-number" href="/page/63/">63</a></li><li><a class="page-number" href="/page/64/">64</a></li><li><a class="page-number" href="/page/65/">65</a></li><li class="active"><li><span class="page-number current">66</span></li><li><a class="page-number" href="/page/67/">67</a></li><li><a class="page-number" href="/page/68/">68</a></li><li><a class="page-number" href="/page/69/">69</a></li><li><span class="space">&hellip;</span></li></li><li><a class="page-number" href="/page/161/">161</a></li><li><a class="page-number" href="/page/162/">162</a></li><li><a class="extend next" href="/page/67/">&raquo;</a></li>
  <div class="clearfix"></div>
</ul></div><!--wapper-->
       </div><!-- ID main-col END -->
       <aside id="sidebar" class="alignright col-sx-6 col-sm-4 col-md-3 col-lg-3">
<div id="widget_search" class="widget panel panel-primary">
    <form action="//google.com/search" method="get" accept-charset="utf-8">
  <div class="input-group">
    <input class="form-control" id="searchbox" type="search" name="q" results="0" placeholder="search">
    <span class="input-group-btn">
      <button class="btn btn-default" type="submit">Go!</button>
    </span>
    <input type="hidden" name="q" value="site:itsolife.com">
  </div>
</form>
</div>

<div id="widget_category" class="widget panel panel-primary">
  <div class="panel-heading">category</div>  <div data-src='category' class='ajax_widgets'>正在加载...</div>
</div>

<div id="widget_recent_posts" class="widget panel panel-primary">
  <div class="panel-heading">recent posts</div>  <div data-src='recent_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_tagcloud" class="widget panel panel-primary">
  <div class="panel-heading">tagcloud</div>  <div data-src='tagcloud' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_latest_update_posts" class="widget panel panel-primary">
  <div class="panel-heading">最近更新</div>  <div data-src='latest_update_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_recent_comments" class="widget panel panel-primary">
  <div class="panel-heading">recent comments</div>  

<div class="list-group-item ds-recent-comments" data-num-items="6" data-show-avatars="1" data-show-time="1" data-show-title="1" data-show-admin="1" data-excerpt-length="50"></div>



</div>

</aside>
       <div class="clearfix"></div>
     </div><!-- row END -->
  </div>
  <footer id="footer" class="container">
  <div class="panel panel-info">
  <section id='footer_widget'></section>  <div class="panel-footer">
  <div id="site-info">
    <span class='author'>
  
  &copy; 2014 RobinChia
  
    &nbsp;&nbsp;</span>
  
  <span id='analytics-51la'></span><span id='analytics-google'>
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-48559895-1']);
  _gaq.push(['_trackPageview']);
  _js2load.push({src:('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'});
</script></span><span id='analytics-cnzz'>
<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_5774006'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s17.cnzz.com/stat.php%3Fid%3D5774006%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>
</span><span id='analytics-baidu'>
<script>
var _hmt = _hmt || [];
_js2load.push({src:"//hm.baidu.com/hm.js?1442f50724afc42380b51f097c43082c"});
</script>
</span>  </div>
  <div id="copyright">Site powered by <a href='http://zespia.tw/hexo/'><strong>hexo</strong></a>  update time: <em>2014-04-07 19:25:39</em></span></div>
</div>
<div class="clearfix"></div>


  </div>
  </footer>
  
        <script src="http://cdn.bootcss.com/jquery/1.10.2/jquery.min.js"></script>        
        <script src="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/js/bootstrap.min.js"></script>        
                
        <script src="http://cdn.bootcss.com/prettify/r298/prettify.min.js"></script>    <script type="text/javascript">
   var lang=["bsh", "c", "cc", "cpp", "cs", "csh", "cyc", "cv", "htm", "html",
    "java", "js", "m", "mxml", "perl", "pl", "pm", "py", "rb", "sh",
    "xhtml", "xml", "xsl"];
   var pretty_base='';
   $('script').each(function(){
	var c = $(this).attr('src');
	if (!c)
	    return;
	if (c.match(/(\/)?prettify(\.min)?\.js/i))
	{
	    var index = c.lastIndexOf('/');
	    if (index != -1)
		pretty_base = c.substr(0,index + 1);
	    return false;
	}
   })
   $('pre code').each(function(){
	var c = $(this).attr('class')
	if (!c)
	    return;
	c = c.match(/\s?(lang\-\w+)/i);
	if (c && lang.indexOf(c[1]) == -1)
	{
	    lang.push(c[1]);
	    $.getScript(pretty_base + c[1] + '.min.js');
	}
   })

    $(window).load(function(){
       $("pre").addClass("prettyprint");
       prettyPrint();
    })
</script>    
            <script type="text/javascript">
var duoshuoQuery = {short_name:"robinchia"};
_js2load.push({src:'http://static.duoshuo.com/embed.js',charset:'UTF-8'});
</script>
    
            <!--wumii_relatedItems-->
    
        <script src="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js"></script>    <script type="text/javascript">
(function($){
  $('.entry').each(function(i){
    $(this).find('img').each(function(){
      var alt = this.alt;

      if (alt){
        $(this).before('<span class="caption">' + alt + '</span>');
      }

      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox" rel="fancybox' + i + '" />');
    });
  });

  $('.fancybox').fancybox();
})(jQuery);
</script>    
        <script src="http://cdn.bootcss.com/mathjax/2.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>    <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>
    
<script type="text/javascript">
$('.ajax_widgets').each(function(){var src=$(this).attr('data-src');if(src)$(this).load('/widgets/'+src+'.html');});
$.each(_js2load,function(index,obj){loadjs(obj.src,obj.charset)});
</script>

<div id="scroll2top">
<img src="/scroll2top/arrow.png"/>
</div>
<script src="/scroll2top/scroll2top.min.js"></script>
<div id="winterland">
  <canvas></canvas>
</div>
<script src="/js/winterland.min.js"></script>

  </body>
</html>
