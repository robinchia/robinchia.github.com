
<!DOCTYPE HTML>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>The 48 Page | It so life</title>
<meta name="author" content="RobinChia">

<meta name="description" content="It so life">


<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<meta property="og:site_name" content="It so life"/>

<!--[if IE]><style>.testIE.IE{display:inline;}</style><![endif]-->
<!--[if lte IE 7]><link rel="stylesheet" href="/css/ie7.css" type="text/css"><![endif]-->
<!--[if (lt IE 9)&(gt IE 7)]><style>.testIE.IE8{display:inline;}</style><![endif]-->
<!--[if gt IE 8]><style>.testIE.IE9{display:inline;}</style><![endif]-->

<link href="/favicon.png" rel="icon">
<link rel="alternate" href="/atom.xml" title="It so life Feed" type="application/atom+xml">

<link rel="stylesheet" href="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/css/bootstrap.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/font-awesome/4.0.3/css/font-awesome.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/prettify/r298/prettify.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" type="text/css">
<link rel="stylesheet" href="/css/style.css" type="text/css">
<!--[if lt IE 9]>
   <style>article,aside,dialog,footer,header,section,footer,nav,figure,menu{display:block}</style>
   <script src="http://cdn.staticfile.org/html5shiv/r29/html5.min.js"></script>
   <script src="http://cdn.staticfile.org/respond.js/1.4.2/respond.min.js"></script>
<link href="http://cdn.staticfile.org/respond.js/1.4.2/respond-proxy.html" id="respond-proxy" rel="respond-proxy" />
<link href="/js/respond.proxy.gif" id="respond-redirect" rel="respond-redirect" />
<script src="/js/respond.proxy.js"></script>
   <script src="http://cdn.bootcss.com/selectivizr/1.0.2/selectivizr-min.js"></script>
<![endif]-->
<script type="text/javascript">
function loadjs(c,d){var a=document.createElement("script");a.async=!0;a.type="text/javascript";a.src=c;a.charset=d||"gbk";(document.getElementsByTagName("HEAD")[0]||document.getElementsByTagName("BODY")[0]).appendChild(a)};
var _protocol = (("https:" == document.location.protocol) ? " https://" : " http://");
var _js2load = [];
</script>

</head>
<body>
      <header id="header" class="container"><nav id="main-nav" class="navbar navbar-default navbar-fixed-top " role="navigation">
  <div class="container">
    <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
      <span class="sr-only">Toggle navigation</span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="/">It so life</a>
    </div>
    <div  class="collapse navbar-collapse">
      <ul  class="nav navbar-nav">
  
        <li><a href="/" title="Home">Home</a></li>      
        <li><a href="/about/" title="About">About</a></li>      
        <li><a href="/archives/" title="Archives">Archives</a></li>      
      <li class='dropdown'>
        <a class='dropdown-toggle' data-toggle='dropdown' href='#'>website<b class='caret'></b></a>
        <ul class='dropdown-menu pure-menu-selected'>
    
          <li><a href="//groups.google.com/forum/#!forum/pongba" title="TopLanguage">TopLanguage</a></li>    
          <li><a href="//itpub.net/" title="ITPub">ITPub</a></li>    
          <li><a href="//blog.jobbole.com/" title="Bole">Bole</a></li>    
          <li><a href="//nosql-database.org/" title="nosql">nosql</a></li>    
          <li><a href="//gitimmersion.googol.im/" title="Git">Git</a></li>    
        </ul>
      </li>
    
      </ul>
      <ul class="nav navbar-nav navbar-right">
      
        <li><a href="/atom.xml">RSS</a></li>
      
      
        <li><a href="https://twitter.com/robinchia">twitter</a></li>
      
      
      
      
        <li><a href="https://github.com/robinchia">github</a></li>
      
      </ul>
    </div>
  </div>
</nav>
<div class="clearfix"></div>
</header>
  <div id='content' class="container">
     <div class="page-header-wrapper">
      <!--[if lt IE 9]><div class="alert alert-warning alert-dismissable"><button type="button" class="close" data-dismiss="alert" aria-hidden="true">&times;</button><strong>提示:</strong>您的浏览器版本太低了,建议升级到 <strong><a href="http://windows.microsoft.com/zh-cn/internet-explorer/download-ie" title="IE9">IE9</a></strong> 以上,本站使用<a href="https://www.google.com/intl/zh-CN/chrome/">Chrome浏览器</a>可以获得最好的显示效果.</div><![endif]-->
      <div class="page-header"><h1 align="center"><big>It so life</big> </h1>
        <h5 align="center"><big>love as life</big></h5>
      </div>
     </div>
     <div class="row">
       <div id="main-col" class="alignleft col-sx-12 col-sm-8 col-md-9 col-lg-9">
      <section id='header_widget'></section>
          <div id="wrapper"><article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_总结类--J2EE学习总结思维方式和理念/">J2EE学习总结 思维方式和理念</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:42.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_总结类--J2EE学习总结思维方式和理念/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="j2ee-">J2EE学习总结 思维方式和理念</h1>
<p>J2EE学习总结:思维方式和理念
Webjx网页教学提示：不管怎么样我还是建议从基本的做起，学精J2SE，熟读它的源码，准确了解其设计理念，然后分头击破J2EE――一口吃不成一个胖子!不要贪多贪广!脚踏实地就可以了!</p>
<p>这篇文章写在我研究J2SE、J2EE近三年后。前3年我研究了J2SE的Swing、Applet、Net、RMI、Collections、IO、JNI……研究了J2EE的JDBC、Sevlet、JSP、JNDI…..不久我发现这些好像太浮浅了：首先，我发现自己知道的仅仅是java提供的大量的API，根本不能很好地使用它; 其次，我根本就没有学到任何有助于写程序的知识，此时我也只不过能写个几页的小程序。出于这个幼稚的想法我研究了JDK中Collections、Logger、IO…..的源代码，发现这个世界真的很神奇，竟然有如此的高手――利用java语言最最基本的语法，创造了这些优秀的Framework。</p>
<p>从此一发不可收拾，我继续研究了J2EE的部分，又发现这是一个我根本不能理解的方向(曾经有半年停滞不前)，为什么只有接口没有实现啊!后来由于一直使用Tomcat、Derby等软件突然发现：哦!原来J2EE仅仅是一个标准，只是一个架构。真正的实现是不同提供商提供的。</p>
<p>接着我研究了MOM4J、OpenJMS、Mocki、HSQLD……发现这些就是J2EE的实现啊!原来软件竟会如此复杂，竟会如此做….规范和实现又是如何成为一体的呢?通过上面的研究发现：原来J2EE后面竟然有太多太多理念、太多太多的相似!这些相似就是其背后的理念――设计模式!(很幸运，在我学java的时候，我一般学java的一个方向就会读一些关于设计模式的书!很幸运，到能领略一点的时候能真正知道这是为什么!)其实模式就是一种思维方式、就是一种理念……模式是要运用到程序中的，只有从真正的项目中才能领会模式的含义……
学得越多，发现懂得越少!在学习过程中发现一些很有用，很值得学习的开源项目，今天在此推荐给大家。</p>
<p>一、JavaServlet和JSP方向</p>
<p>很多人都是从Servlet和JSP步入J2EE的。它就是J2EE的表现层，用于向客户呈现服务器上的内容。J2EE很重要的方面。不罗嗦了!大家都知道的!下面就开始推荐吧!</p>
<ol>
<li>Jakarta Tomcat</li>
</ol>
<p>Apache基金会提供的免费的开源的Serlvet容器，它是的Jakarta项目中的一个核心项目，由Apache、Sun和其它一些公司(都是IT界的大鳄哦)及个人共同开发而成，全世界绝大部分Servlet和Jsp的容器都是使用它哦!由于Sun的参与和支持，最新的Servlet和Jsp规范总能在Tomcat中得到体现。</p>
<p>不过它是一个非常非常全的Serlvet容器，全部源码可能有4000页，对于初学者或者一般的老手可能还是比较大了!在你有能力时推荐研究!下载地址：<a href="http://jakarta.apache.org/tomcat/index.html" target="_blank">http://jakarta.apache.org/tomcat/index.html</a></p>
<p>下面推荐两个小一点的吧!</p>
<ol>
<li>Jetty</li>
</ol>
<p>Jetty是一个开放源码的HTTP服务器和Java serverlet容器。源代码只有1000页左右，很值得研究。有兴趣可以去<a href="http://jetty.mortbay.com/下载看看。我曾经翻了一下，只是目前没有时间。(都化在博客上了，等博客基本定型，且内容完整了，再干我热衷的事件吧!" target="_blank">http://jetty.mortbay.com/下载看看。我曾经翻了一下，只是目前没有时间。(都化在博客上了，等博客基本定型，且内容完整了，再干我热衷的事件吧!</a>)</p>
<ol>
<li>Jigsaw</li>
</ol>
<p>Jigsaw是W3C开发的HTTP，基于Java 的服务器，提供了未来 Web 技术发展的蓝图。W3C知道吧!(太有名气了，很多标准都是它制订的!有空经常去看看吧!)下载网址：<a href="http://www.w3.org/Jigsaw代码仅仅1000页左右。" target="_blank">http://www.w3.org/Jigsaw代码仅仅1000页左右。</a></p>
<ol>
<li>Jo!</li>
</ol>
<p>Jo!是一个纯Java的实现了Servlet API 2.2, JSP 1.1, 和HTTP/1.1的Web服务器。它的特性包括支持servlet tag,支持SSI，高级线程管理，虚拟主机，数据缓存，自动压缩text或HTML文件进行传输，国际化支持，自动重新加载Servlet、Jsp，自动重新加载web工程文件(WARs)，支持WAR热部署和一个Swing控制台。jo!可以被用做jboss和jakarta avalon-phoenix的web容器。下载地址<a href="http://www.tagtraum.com/" target="_blank">http://www.tagtraum.com/</a> 。我极力推荐大家在研究Tomcat之前研究该软件，主要是其比Tomcat小多了，且开发者提供比较全的手册。该方向研究这两个也就可以了!</p>
<p>二、JDBC方向</p>
<p>很多人都喜欢JDBC，数据库吗!很深奥的东西，一听就可以糊弄人。其实等你真正研究了数据库的实现后发现，接口其实真的太简单，太完美了!要想设计如此优秀的框架还是需要学习的。下面就推荐几个数据库的实现吧!</p>
<ol>
<li>Hypersonic SQL</li>
</ol>
<p>Hypersonic SQL开源数据库方向比较流行的纯Java开发的关系型数据库。好像不是JDBC兼容的，JDBC的很多高级的特性都没有支持，不过幸好支持ANSI-92 标准 SQL语法。我推荐它主要是它的代码比较少1600页左右，如此小的数据库值得研究，而且他占的空间很小，大约只有160K，拥有快速的数据库引擎。推荐你的第一个开源数据库。下载地址：<a href="http://hsqldb.sourceforge.net/。" target="_blank">http://hsqldb.sourceforge.net/。</a></p>
<ol>
<li>Mckoi DataBase</li>
</ol>
<p>McKoiDB 和Hypersonic SQL差不多，它是GPL 的license的纯Java开发的数据库。他的 JDBC Driver 是使用 JDBC version 3 的 Specifaction。 他也是遵循 SQL-92 的标准，也尽量支持新的 SQL 特色, 并且支持 Transaction 的功能。两个可以选一个吧!下载地址：<a href="http://mckoi.com/database/。" target="_blank">http://mckoi.com/database/。</a></p>
<ol>
<li>Apache Derby</li>
</ol>
<p>学Java的数据库我建议使用Apache Derby ，研究数据库想成为一个数据库的高手我建议你先研究Apache Derby。Apache Derby是一个高质量的、纯 Java开发的嵌入式关系数据库引擎，IBM® 将其捐献给Apache开放源码社区，同时IBM的产品CloudSpace是它对应的产品。Derby是基于文件系统，具有高度的可移植性，并且是轻量级的，这使得它非常便于发布。主要是没有商业用户的很好的界面，没有其太多的功能。不过对于我们使用数据库、研究数据库还是极其有用的。对于中小型的企业说老实话你也不要用什么Oracle、SqlServer了，用Derby就可以了，何况是开源的呢!只要能发挥其长处也不容易啊!下载地址：<a href="http://incubator.apache.org/derby。" target="_blank">http://incubator.apache.org/derby。</a></p>
<p>不过在没有足够的能力前，不要试图读懂它!注释和源代码15000页左右，我一年的阅读量!能读下来并且能真正领会它，绝对高手!你能读完Derby的源代码只有两种可能：1.你成为顶尖的高手――至少是数据库这部分; 2.你疯了。选择吧!!!!作为我自己我先选择Hypersonic SQL这样的数据库先研究，能过这一关，再继续研究Derby!不就是一年的阅读量吗!我可以化3年去研究如何做一个数据库其实还是很值得的!有的人搞IT一辈子自己什么都没有做，也根本没有研究别人的东西!</p>
<p>作为一个IT落后于别国若干年的、从事IT的下游产业“外包”的国家的IT从业人员，我认为还是先研究别人的优秀的东西比较好!可以先研究别人的，然后消化，学为己用!一心闭门造车实在遗憾!</p>
<p>三、JMS方向</p>
<p>JMS可能对大家来说是一个比较陌生的方向!其实JMS是一个比较容易理解，容易上手的方向。主要是Java消息服务，API也是相当简单的。不过在企业应用中相当广泛。下面就介绍几个吧!</p>
<ol>
<li>MOM4J</li>
</ol>
<p>MOM4J是一个完全实现JMS1.1规范的消息中间件并且向下兼容JMS1.0与1.02。它提供了自己的消息处理存储使它独立于关系数据与语言，它的客户端可以用任何语言开发。它可以算是一个小麻雀，很全实现也比较简单!它包含一个命名服务器，一个消息服务器，同时提供自己的持续层。设计也相当的巧妙，完全利用操作系统中文件系统设计的观念。代码也很少，250页左右，最近我在写该实现的源代码阅读方面的书，希望明年年中能与大家见面!下载地址：<a href="http://mom4j.sourceforge.net/index.html。" target="_blank">http://mom4j.sourceforge.net/index.html。</a></p>
<ol>
<li>OpenJMS</li>
</ol>
<p>OpenJMS是一个开源的Java Message Service API 1.0.2 规范的实现，它包含有以下特性：</p>
<ol>
<li><p>它既支持点到点(point-to-point)(PTP)模型和发布/订阅(Pub/Sub)模型。</p>
</li>
<li><p>支持同步与异步消息发送 。</p>
</li>
<li><p>JDBC持久性管理使用数据库表来存储消息 。</p>
</li>
<li><p>可视化管理界面。</p>
</li>
<li><p>Applet支持。</p>
</li>
<li><p>能够与Jakarta Tomcat这样的Servlet容器结合。</p>
</li>
<li><p>支持RMI, TCP, HTTP 与SSL协议。</p>
</li>
<li><p>客户端验证 。</p>
</li>
<li><p>提供可靠消息传输、事务和消息过滤。</p>
</li>
</ol>
<p>很好的JMS方向的开源项目!我目前也在研究它的源代码!学习它可以顺便研究JNDI的实现、以及网络通信的细节。这是我JMS方向研究的第二个开源项目。代码量1600页左右吧!下载地址：<a href="http://openjms.sourceforge.net/index.html" target="_blank">http://openjms.sourceforge.net/index.html</a></p>
<ol>
<li>ActiveMQ</li>
</ol>
<p>ActiveMQ是一个开放源码基于Apache 2.0 licenced 发布并实现了JMS 1.1。它能够与Geronimo，轻量级容器和任Java应用程序无缝的给合。主要是Apache的可以任意的使用和发布哦!个人比较喜欢Apache的源代码!下载地址：<a href="http://activemq.codehaus.org/" target="_blank">http://activemq.codehaus.org/</a></p>
<ol>
<li>JORAM</li>
</ol>
<p>JORAM一个类似于openJMS分布在ObjectWeb之下的JMS消息中间件。ObjectWeb的产品也是非常值得研究的!下面我还会给大家另外一个ObjectWeb的产品。下载地址：<a href="http://joram.objectweb.org/" target="_blank">http://joram.objectweb.org/</a></p>
<p>我个人推荐：OpenJMS和ActiveMQ!</p>
<p>四、EJB方向</p>
<p>EJB一个比较“高级”的方向。Sun公司曾经以此在分布式计算领域重拳出击。不过自从出现了Spring、Hibernation……后似乎没落了!这个方向单独开源的也比较少，主要EJB是和JNDI、JDBC、JMS、JTS、JTA结合在一起的是以很少有单独的。下面推荐两个不过好像也要下载其它类库。</p>
<ol>
<li>EasyBeans</li>
</ol>
<p>ObjectWeb的一个新的项目，一个轻量级的EJB3容器，虽然还没有正式发布，但是已经可以从它们的subversion仓库中检出代码。代码量比较小600页左右，熟读它可以对网络编程、架构、RMI、容器的状态设计比较了解了!即学会EJB又能学习其它设计方法何乐而不为哦!下载地址：<a href="http://easybeans.objectweb.org/" target="_blank">http://easybeans.objectweb.org/</a></p>
<ol>
<li>OpenEJB</li>
</ol>
<p>OpenEJB是一个预生成的、自包含的、可移植的EJB容器系统，可以被插入到任意的服务器环境，包括应用程序服务器，Web服务器，J2EE平台， CORBA ORB和数据库等等。OpenEJB 被用于 Apple的WebObjects。听起来很好，我目前没有研究过。不知道我就不推荐了。下载地址：<a href="http://www.openejb.org/" target="_blank">http://www.openejb.org/</a></p>
<p>五、J2EE容器</p>
<p>上面谈了这么多，都是J2EE的各个方向的。其实J2EE是一个规范，J2EE的产品一般要求专业提供商必须提供它们的实现。这些实现本身就是J2EE容器。市场上流行的J2EE容器很多，在开源领域流行的只有很少，很少。其中最著名的是JBoss。</p>
<ol>
<li>JBoss</li>
</ol>
<p>在J2EE应用服务器领域，Jboss是发展最为迅速的应用服务器。由于Jboss遵循商业友好的LGPL授权分发，并且由开源社区开发，这使得Jboss广为流行。另外，Jboss应用服务器还具有许多优秀的特质。</p>
<p>其一，它将具有革命性的JMX微内核服务作为其总线结构;</p>
<p>其二，它本身就是面向服务的架构(Service-Oriented Architecture，SOA);</p>
<p>其三，它还具有统一的类装载器，从而能够实现应用的热部署和热卸载能力。因此，它是高度模块化的和松耦合的。Jboss用户的积极反馈告诉我们，Jboss应用服务器是健壮的、高质量的，而且还具有良好的性能。为满足企业级市场日益增长的需求，Jboss公司从2003年开始就推出了24/*7、专业级产品支持服务。同时，为拓展Jboss的企业级市场，Jboss公司还签订了许多渠道合作伙伴。比如，Jboss公司同HP、Novell、Computer Associates、Unisys等都是合作伙伴。</p>
<p>在2004年6月，Jboss公司宣布，Jboss应用服务器通过了Sun公司的J2EE认证。这是Jboss应用服务器发展史上至今为止最重要的里程碑。与此同时，Jboss一直在紧跟最新的J2EE规范，而且在某些技术领域引领J2EE规范的开发。因此，无论在商业领域，还是在开源社区，Jboss成为了第一个通过J2EE 1.4认证的主流应用服务器。现在，Jboss应用服务器已经真正发展成具有企业强度(即，支持关键级任务的应用)的应用服务器。</p>
<p>Jboss 4.0作为J2EE认证的重要成果之一，已经于2004年9月顺利发布了。同时，Jboss 4.0还提供了Jboss AOP(Aspect-Oriented Programming，面向方面编程)组件。近来，AOP吸引了大量开发者的关注。它提供的新的编程模式使得用户能够将方面(比如，事务)从底层业务逻辑中分离出来，从而能够缩短软件开发周期。用户能够单独使用Jboss AOP，即能够在Jboss应用服务器外部使用它。或者，用户也可以在应用服务器环境中使用它。Jboss AOP 1.0已经在2004年10月发布了。 很有名吧!可以下载一个用一下，下载地址：<a href="http://www.jboss.org/" target="_blank">http://www.jboss.org/</a></p>
<p>关于JBoss的使用资料也非常多，甚至比商业软件的还多。有机会研究吧!</p>
<ol>
<li>JOnAS</li>
</ol>
<p>JOnAS是一个开放源代码的J2EE实现，在ObjectWeb协会中开发。整合了Tomcat或Jetty成为它的Web容器，以确保符合Servlet 2.3和JSP 1.2规范。JOnAS服务器依赖或实现以下的Java API：JCA、JDBC、JTA 、JMS、JMX、JNDI、JAAS、JavaMail 。下载地址：<a href="http://jonas.objectweb.org/" target="_blank">http://jonas.objectweb.org/</a>
3.Apache Geronimo</p>
<p>Apache Geronimo 是 Apache 软件基金会的开放源码J2EE服务器，它集成了众多先进技术和设计理念。 这些技术和理念大多源自独立的项目，配置和部署模型也各不相同。 Geronimo能将这些项目和方法的配置及部署完全整合到一个统一、易用的模型中。作为符合J2EE标准的服务器，Geronimo提供了丰富的功能集和无责任 Apache 许可，具备“立即部署”式J2EE 1.4容器的各种优点，其中包括：</p>
<ol>
<li><p>符合J2EE1.4标准的服务器 。</p>
</li>
<li><p>预集成的开放源码项目 。</p>
</li>
<li><p>统一的集成模型 。</p>
</li>
<li><p>可伸缩性、可管理性和配置管理功能。</p>
</li>
</ol>
<p>我一直比较推荐Apache的产品。主要是可以任意自由地使用。下载地址：<a href="http://incubator.apache.org/projects/geronimo/" target="_blank">http://incubator.apache.org/projects/geronimo/</a></p>
<p>六、其它</p>
<p>讲了这么多大家可能很厌烦了!是不是很多很多啊!其实不然，我们不会的太多太多了!不会的太多太多了。不管你是不是J2EE高手，还是J2SE高手，有些东西你要绝对很精明的。例如：1.Java的Collections Framework就是java的数据结构了，不仅要吃透它，还要能按照需要扩展它，利用其思想创建一个自己的数据结构。2.网络编程肯定要会吧，现在以及以后很多程序都是不在同一台机器上的，不会网络怎么行哦!3.IO肯定要会的吧!你的程序难道不用输入输出数据啊!整个IO包加NIO也有600多页的源代码哦!4.JDBC你要会吧!数据库都不会，在你的企业应用中你的数据又保存到哪里啊!文件中――太落后了吧!典型的没有学过J2EE。尽管数据库背后也是采用文件保存的。5.Serverlet、JSp你要是做网页做网站，肯定要做到。问你一个简单的问题，网页中如何实现分页啊!有具体方法的就在本文章后发言吧!6. Ant要会吧!java语言中发布的工具，类似与c中的make工具。7.JUnit用过吧!单元测试软件。你不要啊!你的软件就没有bug!你牛!(建议大家研究研究其源代码，很有用的框架，包含大量的设计模式，源代码不到100页!看了只能感叹――高手就是高手)细心的朋友可以看到在你使用的很多IDE工具中都有JUnit哦!就是它。</p>
<p>一切的一切才刚刚开始!有兴趣，有需要你可以研究数据库连接池的框架，如：C3P0、Jakarta DBCP、 DBPool….可以研究J2EE框架Spring……. Web框架Struts……持久层框架Hibernate…..甚至开发工具Eclipse…..Sun领导的点对点通信的JXTA…..报表工具JFreeChart、JasperReports…..分布式网络编程的CORBA、网络通信的JGROUPS、XML解析的xerces…..(在不经意间开源已经步入你的电脑，不信啊!你JDK的安装目录jdk1.6.0 src com sun org apache就是Xerces，一个XML解析的著名的开源 项目)</p>
<p>不管怎么样我还是建议从基本的做起，学精J2SE，熟读它的源码，准确了解其设计理念，然后分头击破J2EE――一口吃不成一个胖子!不要贪多贪广!脚踏实地就可以了!</p>
<hr>
<p><strong><a href="http://www.webjx.com/exam/java-15508.html" target="_blank">http://www.webjx.com/exam/java-15508.html</a></strong></p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/Java_总结类/">Java_总结类</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/Java_总结类/" class="label label-success">Java_总结类</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:43"datetime="2014-03-07 09:54:43"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-Java_总结类--J2EE学习总结思维方式和理念/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-Java_总结类--J2EE学习总结思维方式和理念" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_总结类--J2EE学习笔记/">J2EE学习笔记</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:42.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_总结类--J2EE学习笔记/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="j2ee-">J2EE学习笔记</h1>
<p>J2EE学习笔记</p>
<p>注：框架可以用Word菜单中的 “视图/文档结构图” 看到<br>J2EE模式
Value Object(值对象)  用于把数据从某个对象/层传递到其他对象/层的任意Java对象。
通常不包含任何业务方法。
也许设计有公共属性，或者提供可以获取属性值的get方法。
JSP
1．JSP的基础知识    </p>
<pre><code>           __  
    _____ |   directive  (指令)
        |     |-- scripting （脚本）
</code></pre><p> JSP -------|     |<strong> action  （动作）
|
|<em>_</em></strong>Template data ：除JSP语法外，JSP引擎不能解读的东西</p>
<p>1）在JSP中使用的directive(指令)主要有三个：
a) page指令
b) include指令
c) taglib指令
在JSP的任何地方，以任何顺序，一个页面可以包含任意数量的page指令
    2)Scripting（脚本）包括三种类型
a) &lt;%！declaraction  %&gt;;
b) &lt;%  scriptlet     %&gt;;
c) &lt;%= expression   %&gt;;
3)action（动作）
  标准的动作类型有：
        a)  <jsp:useBean>;
b)  <jsp:setProperty>;
d) <jsp:getProperty>;
e) <jsp:param>;
f) <jsp:include>;
g) <jsp:forward>;
h) <jsp:plugin>;</p>
<ol>
<li>注释： &lt;% -----jsp comment-------%&gt;;<pre><code>&lt;! -----html comment-------%&gt;;
</code></pre></li>
<li>&lt;%@ page session = “true”  import =”java.util./*” %&gt;;
session可以不赋值，默认为true,如果session=”false”,则在JSP页面中，隐含的变量session就不能使用。</li>
<li>请求控制器结构（Request Controller）
也被称之为JSP Model 2 Architecture
这种途径涉及到使用一个Servlet或一个JSP作为一个应用程序或一组页面的入口点。
为创建可维护的JSP系统，Request Controller是最有用的方式之一。
不是JSP，而是Java类才是放置控制逻辑的正确的地方。
请求控制器的命名模式为: xxxController.jsp
请求控制器类的命名模式为: xxxRequestController
2．JSP中的JavaBean
JSP三种bean的类型
1) 页面bean
2) 会话bean
3) 应用bean
大多数的系统会使用一个会话bean来保持状态，而对每一个页面使用一个页面bean 来对复杂的数据进行表示。
页面bean是一个模型，而JSP是一个视图。
3．Custom tag
bean是信息的携带者，
而tag更适用于处理信息。
标记库包含一个标记库描述符（TLD）和用于实现Custom tag的Java类
在翻译阶段，JSP容器将使用TLD来验证页面中的所有的tag是否都被正确的使用。
标记处理程序只是一个简单的适配器，而真正的逻辑是在另一个类中实现的，标记处理程序只是提供了一个供其他的可复用的类的JSP接口</li>
</ol>
<p>Servlet
1．ServletConfig
&amp;/#61548; 一个ServletConfig对象是servlet container在servlet initialization的时候传递给servlet的。
ServletConfig包涵 ServletContext 和 一些 Name/Value pair (来自于deployment descriptor)
&amp;/#61548; ServletContext接口封装了Web应用程序的上下文概念。
2．会话跟踪
1) Session
&amp;/#61548; 当一个Client请求多个Servlets时，一个session可以被多个servlet共享。
&amp;/#61548; 通常情况下，如果server detect到browser支持cookie，那么URL就不会重写。
2) cookie
&amp;/#61548; 在Java Servlet中，如果你光  Cookie cookie = new Cookie(name,value)
那么当用户退出Browser时，cookie会被删除掉，而不会被存储在客户端的硬盘上。
如果要存储 cookie，需加一句   cookie.setMaxAge(200)
&amp;/#61548; cookie是跟某一个server相关的，运行在同一个server上的servlet共享一个cookie.
3) URL Rewriting
在使用URL Rewriting来维护Session ID的时候，每一次HTTP请求都需要EncodeURL()
典型的用在两个地方
1） out.print(“form action=\” ”);
out.print(response.encodeURL(“sessionExample”));
out.print(“form action=\” ”);
out.print(“method = GET&gt;;”);
2） out.print(“<p>;<a href=\” ”);
out.print(response.encodeURL(“SessionExample?database=foo&datavalue=bar”));
out.println(“\” >;URL encoded </a>;”);
3．SingleThreadModel
默认的，每一个servlet definition in a container只有一个servlet class的实例。
只有实现了SingleThreadModel，container才会让servlet有多个实例。
Servlet specification上建议，不要使用synchronized，而使用SingleThreadModel。
SingleThreadModel（没有方法）
保证servlet在同一时刻只处理一个客户的请求。
SingleThreadModel是耗费资源的，特别是当有大量的请求发送给Servlet时，SingleThreadModel的作用是使包容器以同步时钟的方式调用service方法。
这等同于在servlet的service()方法种使用synchronized.
Single Thread Model一般使用在需要响应一个heavy request的时候，比如是一个需要和数据库打交道的连接。</p>
<ol>
<li>在重载Servlet地init( )方法后，一定要记得调用super.init( );</li>
<li>the client通过发送一个blank line表示它已经结束request
而the server通过关闭the socket来表示response已结束了。</li>
<li>一个Http Servlet可以送三种东西给Client
1) a single status code
2) any number of http headers
3) a response body</li>
<li>Servlet之间信息共享的一个最简单的方法就是
System.getProperties().put(“key”,”value”);</li>
<li>Post和Get
Post：将form内各字段名称和内容放置在html header内传送给server
Get:  ?之后的查询字符串要使用URLEncode，经过URLEncode后，这个字符串不再带有空格，以后将在server上恢复所带有的空格。</li>
</ol>
<p>Get是Web上最经常使用的一种请求方法，每个超链接都使用这种方法。</p>
<ol>
<li><p>Web.xml就是Web Applicatin 的deployment descriptor
作用有：组织各类元素</p>
<pre><code> 设置init param
 设置安全性
</code></pre></li>
<li><p>Request Dispatcher用来把接收到的request forward processing到另一个servlet
要在一个response里包含另一个servlet的output时，也要用到Request Dispatcher.</p>
</li>
<li>Servlet和Jsp在同一个JVM中，可以通过ServeltContext的
setAttribute( )
getAttribute( )
removeAttribute( )
来共享对象</li>
<li>利用request.getParameter( )得到的String存在字符集问题。
可以用  strTitle = request.getParameter(“title”);<pre><code>strTitle = new String(strTitle.getBytes(“8859-1”),”gb2312”);
</code></pre>如果你希望得到更大得兼容性<pre><code>String encoding = response.getCharacterEncoding();     
</code></pre>//确定Application server用什么编码来读取输入的。<pre><code>strTitle = new String(strTitle.getBytes(encoding),”gb2312”);
</code></pre>XML
1．XML基础知识</li>
<li>一个xml文档可以分成两个基本部分：
首部( header )
内容( content )</li>
<li>xml名字空间规范中指定：
xml文档中的每一个元素都处在一个名字空间中；如果没有指定的名字空间，缺省的名字空间就是和该元素相关联的名字空间。</li>
<li>A document that is well-formed obeys all of the rules of XML documents (nested tags, etc.)
&quot; If a well-formed document uses a Document Type Definition (more on these in a minute), and it follows all the rules of the DTD, then it is also a valid document</li>
<li>A tag is the text between the <angle brackets>;
&quot; An element is the start tag, the end tag,and everything (including other elements) in between</li>
<li>标签( tags ) 实际上包含了“元素”( elements ) 和 “属性”( attributes )两部分。
用元素( elements )来描述有规律的数据。
用属性( attributes ) 来描述系统数据。
如果你有一些数据要提供给某个应用程序，该数据就可能要用到一个元素。
如果该数据用于分类，或者用于告知应用程序如何处理某部分数据，或者该数据从来没有直接对客户程序公开，那么它就可能成为一种属性。</li>
<li>CDATA (读作：C data ) C是character的缩写。</li>
<li>org.xml.sax.Reader
/|\
org.xm.l.sax.XMLReader
/|\
org.apche.xerces.parsers.SAXParser
2．WebService
2．1 WebService的基本概念
WebService是一种可以接收从Internet或者Intranet上的其它系统中传递过来的请求，轻量级的独立的通讯技术。
这种技术允许网络上的所有系统进行交互。随着技术的发展，一个Web服务可以包含额外的指定功能并且可以在多个B2B应用中协作通讯。
Web服务可以理解请求中上下文的关系，并且在每一个特定的情况下产生动态的结果。这些服务会根据用户的身份，地点以及产生请求的原因来改变不同的处理，用以产生一个唯一的，定制的方案。这种协作机制对那些只对最终结果有兴趣的用户来说，是完全透明的。
UDDI 
在用户能够调用Web服务之前，必须确定这个服务内包含哪些商务方法，找到被调用的接口定义，还要在服务端来编制软件。所以，我们需要一种方法来发布我们的Web服务。 
UDDI (Universal Description, Discovery, and Integration) 是一个主要针对Web服务供应商和使用者的新项目。UDDI 项目中的成员可以通过UDDI Business Registry (UBR) 来操作Web服务的调用，UBR是一个全球性的服务。
Web服务供应商可以在UBR中描述并且注册他们的服务。
用户可以在UBR中查找并定位那些他们需要的服务。 
UDDI是一种根据描述文档来引导系统查找相应服务的机制。
UDDI包含标准的“白皮书”类型的商业查询方式，
“黄皮书”类型的局部查找，以及
“绿皮书”类型的服务类型查找。
UDDI利用SOAP消息机制（标准的XML/HTTP）来发布，编辑，浏览以及查找注册信息。它采用XML格式来封装各种不同类型的数据，并且发送到注册中心或者由注册中心来返回需要的数据。
WSDL 
对于商业用户来说，要找到一个自己需要使用的服务，他必须知道如何来调用。
WSDL (Web Services Description Language) 规范是一个描述接口，语义以及Web服务为了响应请求需要经常处理的工作的XML文档。这将使简单地服务方便，快速地被描述和记录。
以下是一个WSDL的样例： 
&lt;?xml version=&quot;1.0&quot;?&gt;;
&lt;definitions name=&quot;StockQuote&quot;<pre><code>    targetNamespace=&quot;http://example.com/stockquote.wsdl&quot;
    xmlns:tns=&quot;http://example.com/stockquote.wsdl&quot;
    xmlns:xsd1=&quot;http://example.com/stockquote.xsd&quot;
    xmlns:soap=&quot;http://schemas.xmlsoap.org/wsdl/soap/&quot;
    xmlns=&quot;http://schemas.xmlsoap.org/wsdl/&quot;&gt;;
</code></pre><types>;
&lt;schema targetNamespace=<a href="http://example.com/stockquote.xsd" target="_blank">http://example.com/stockquote.xsd</a><pre><code>     xmlns=&quot;http://www.w3.org/2000/10/XMLSchema&quot;&gt;;
</code></pre><element name="TradePriceRequest">;
<complexType>;
   <all>;<pre><code>    &lt;element name=&quot;tickerSymbol&quot; type=&quot;string&quot;/&gt;;
  &lt;/all&gt;;
</code></pre>   </complexType>;
</element>;
<element name="TradePrice">;<pre><code>&lt;complexType&gt;;
    &lt;all&gt;;
       &lt;element name=&quot;price&quot; type=&quot;float&quot;/&gt;;
     &lt;/all&gt;;
  &lt;/complexType&gt;;
</code></pre>   </element>;
</schema>;
</types>;
<message name="GetLastTradePriceInput">;
 <part name="body" element="xsd1:TradePriceRequest"/>;
</message>;
<message name="GetLastTradePriceOutput">;
 <part name="body" element="xsd1:TradePrice"/>;
</message>;
<portType name="StockQuotePortType">;
<operation name="GetLastTradePrice">;<pre><code>&lt;input message=&quot;tns:GetLastTradePriceInput&quot;/&gt;;
&lt;output message=&quot;tns:GetLastTradePriceOutput&quot;/&gt;;
</code></pre> </operation>;
</portType>;
&lt;binding name=&quot;StockQuoteSoapBinding&quot;<pre><code>        type=&quot;tns:StockQuotePortType&quot;&gt;;
</code></pre> &lt;soap:binding style=&quot;document&quot;<pre><code>                     transport=&quot;http://schemas.xmlsoap.org/soap/http&quot;/&gt;;
</code></pre><operation name="GetLastTradePrice">;<pre><code>&lt;soap:operation
               soapAction=&quot;http://example.com/GetLastTradePrice&quot;/&gt;;
&lt;input&gt;;
   &lt;soap:body use=&quot;literal&quot;/&gt;;
&lt;/input&gt;;
&lt;output&gt;;
    &lt;soap:body use=&quot;literal&quot;/&gt;;
&lt;/output&gt;;
</code></pre> </operation>;
</binding>;
<service name="StockQuoteService">;
<documentation>;My first service</documentation>;
<port name="StockQuotePort" binding="tns:StockQuoteBinding">;<pre><code>&lt;soap:address location=&quot;http://example.com/stockquote&quot;/&gt;;
</code></pre></port>;
</service>;
</definitions>;
它包含了以下的关键信息： 
消息的描述和格式定义可以通过XML文档中的<types>;和<message>; 标记来传送。 
<portType>; 标记中表示了消息传送机制。 (e.g. request-only, request-response, response-only) 。
<binding>; 标记指定了编码的规范 。
<service>; 标记中表示服务所处的位置 (URL)。 
WSDL在UDDI中总是作为一个接口描述文档。因为UDDI是一个通用的用来注册WSDL规范的地方，UDDI的规范并不限制任何类型或者格式描述文档。这些文档可能是一个WSDL文档，或者是一个正规的包含导向文档的Web页面，也可能只是一个包含联系信息的电子邮件地址。
现在Java提供了一个 Java API for WSDL (JWSDL)规范。它提供了一套能快速处理WSDL文档的方法，并且不用直接对XML文档进行操作，它会比JAXP更方便，更快速。
SOAP 
当商业用户通过UDDI找到你的WSDL描述文档后，他通过可以Simple Object Access Protocol (SOAP) 调用你建立的Web服务中的一个或多个操作。
SOAP是XML文档形式的调用商业方法的规范，它可以支持不同的底层接口，象HTTP(S)或者SMTP。
之所以使用XML是因为它的独立于编程语言，良好的可扩展性以及强大的工业支持。之所以使用HTTP是因为几乎所有的网络系统都可以用这种协议来通信，由于它是一种简单协议，所以可以与任何系统结合，还有一个原因就是它可以利用80端口来穿越过防火墙。
SOAP的强大是因为它简单。SOAP是一种轻量级的，非常容易理解的技术，并且很容易实现。它有工业支持，可以从各主要的电子商务平台供应商那里获得。
从技术角度来看，SOAP详细指明了如何响应不同的请求以及如何对参数编码。一个SOAP封装了可选的头信息和正文，并且通常使用HTTP POST方法来传送到一个HTTP 服务器，当然其他方法也是可以的，例如SMTP。SOAP同时支持消息传送和远程过程调用。以下是一个SOAP请求。
POST /StockQuote HTTP/1.1
Host: www.stockquoteserver.com
Content-Type: text/xml; charset=&quot;utf-8&quot;
Content-Length: nnnn 
SOAPAction: &quot;Some-URI&quot; 
<a href="SOAP-ENV:Envelope
xmlns:SOAP-ENV=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;
SOAP-ENV:encodingStyle=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot;/">SOAP-ENV:Envelope
xmlns:SOAP-ENV=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;
SOAP-ENV:encodingStyle=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot;/</a>;
<SOAP-ENV:Header>;
<t:Transaction xmlns:t="some-URI" SOAP-ENV:mustUnderstand="1">;
   5
</t:Transaction>;
</SOAP-ENV:Header>;
<SOAP-ENV:Body>;
<m:GetLastTradePrice xmlns:m="Some-URI">;<pre><code>&lt;symbol&gt;;SUNW&lt;/symbol&gt;;
</code></pre></m:GetLastTradePrice>;
</SOAP-ENV:Body>;
</SOAP-ENV:Envelope>; 
JAXR 
为了支持UDDI在Java平台上的功能，Java APIs for XML Registries (JAXR)允许开发者来访问注册中心。
值得注意的是，JAXR并不是建立Web服务必需的，你可以利用其他常用的XML APIs来直接集成这些协议。
JAXR是一个方便的API，它提供了Java API来发布，查找以及编辑那些注册信息。它的重点在于基于XML的B2B应用，复杂的地址本查找以及对XML消息订阅的支持等Web服务。
它也可以用来访问其他类型的注册中心，象ebXML注册中心。
这些对Web服务的注册信息进行的操作，可以使用当前的一些Web服务工具来完成（例如第三方的SOAP和ebXML消息工具）。另外，当JAXP提供了一致并具有针对性的API来完成这些操作，这将使开发变得更加容易。
JAX/RPC 
为了使开发人员专注于建立象SOAP那样的基于XML的请求，JCP正在开发基于RPC (JAX/RPC) 的Java API。JAX/RPC是用来发送和接收方法调用请求的，它基于XML协议，象SOAP，或者其他的象XMLP (XML Protocol，要了解更多可以参考<a href="http://www.w3.org/2000/xp/)。JAX/RPC使你不用再关注这些协议的规范，使应用的开发更快速。不久，开发人员就不用直接以XML表示方法调用了。" target="_blank">http://www.w3.org/2000/xp/)。JAX/RPC使你不用再关注这些协议的规范，使应用的开发更快速。不久，开发人员就不用直接以XML表示方法调用了。</a>
目前有很多第三方实现了SOAP，开发人员可以在不同的层次上调用SOAP，并选择使用哪一种。将来，JAX/RPC会取代这些APIs并提供一个统一的接口来构造以及处理SOAP RPC请求。
在接收一个从商业伙伴那里过来的SOAP请求的时候，一个Java servlet用JAX/RPC来接收这个基于XML的请求。一旦接收到请求后，servlet会调用商务方法，并且把结果回复给商业伙伴。
JAXM 
当从商业合作伙伴那里接收一个Web服务的请求时，我们需要Java API实现一个Servlet来处理ebXML消息，就象我们用JAX/RPC来处理SOAP请求一样。
Java API for XML Messaging (JAXM) 是集成XML消息标准（象ebXML消息或者SOAP消息）的规范。
这个API是用来推动XML消息处理的，它检测那些预定单的消息格式以及约束。它控制了所有的消息封装机制，用一种直观的方式分割了消息中的信息，象路由信息，发货单。这样，开发人员只要关注消息的有效负载，而不用去担心那些消息的重复处理。
目前的开发人员用JAXP来实现JAXM将要提供的功能，JAXM将会提供一套非常具有针对性的API来处理基于XML的消息传送。这将大大简化开发人员的代码，并使它们具有统一的接口。
JAXM和JAX/RPC的差别在于处理消息导向的中间件以及远程过程调用的不同。JAXM注重于消息导向，而JAX/RPC是用来完成远程过程调用的。以下是图解。</li>
</ol>
<p>请注意，在JAXM 和 JAX/RPC技术成熟之前，开发人员还是依赖于第三方的SOAP APIs，象Apache SOAP, IdooXOAP, 以及 GLUE。当JAXM 和 JAX/RPC正式发布后，它将为当前不同的SOAP和ebXML消息提供统一的接口。就象JDBC位多种不同的数据库提供统一的接口。
JAXB 
XML绑定技术可以把XML文档和Java对象进行自由转换。
用JAXB，你可以在后台的EJB层，把XML文档转换成Java对象。同样你也可以把从EJB中取出的Java对象转换成XML文档返回给用户。
JAXB接口提供了比SAX和DOM更高级的方法来处理XML文档。它提供的特性可以在XML数据和Java类之间互相映射，提供了一个简单的方法来转换XML数据。它比逐个解析标记更简单。
2．2 建立WeService的步骤
在建立WeService的时候，有三个主要步骤：
1．建立客户端联接 
为了允许Applets，Applications，商业合作伙伴，浏览器和PDAs 使用Web服务。 
2．实现Web服务 
包括工作流，数据传送，商业逻辑以及数据访问。这些功能是隐藏在Web服务后，并且为客户端工作的。 
3．联接后台系统 
这个系统可能包括一个或多个数据库，现存的企业信息系统，商业合作伙伴自己的系统或者Web服务，以及在多个系统中共享的数据。
基于J2EE的Web服务的核心构架：</p>
<p>RMI</p>
<ol>
<li>RMI-IIOP</li>
<li>RMI 是在java中使用remote method invocation的最初的方法，RMI使用java.rmi包
RMI－IIOP 是RMI的一个特殊版本，RMI－IIOP可以和CORBA兼容，RMI-IIOP使用java.rmi包和javax.rmi
JAF(Java活动构架)
开发者可以使用JAF来决定任意一块数据的类型、封装对数据的访问、寻找合适的操作、实例化相关的bean来执行这些操作等。
例如，JavaMail就是使用JAF根据MIME类型来决定实例化那一个对象。
EJB</li>
<li><p>EJB组件实现代码的限制
 EJB组件的约束
 EJB的开发者并不需要在EJB的组件实现代码中编写系统级的服务，EJB提供商/开发
者需知道并且严格地遵守一些限制，这些限制与开发稳定的和可移植的EJB组件的利益有
关。
 以下是你应该回避使用的一些Java特色，并且在你的EJB组件的实现代码中要严格限
制它们的使用：
 1.使用static，非final 字段。建议你在EJB组件中把所有的static字段都声明为final型的。这样可以保证前后一致的运行期语义，使得EJB容器有可以在多个Java虚拟机之间分发组件实例的灵活性。
 2.使用线程同步原语来同步多个组件实例的运行。避免这个问题，你就可以使EJB容器灵活的在多个Java虚拟机之间分发组件实例。
 3.使用AWT函数完成键盘的输入和显示输出。约束它的原因是服务器方的商业组件意味着提供商业功能而不包括用户界面和键盘的I/O功能。
 4.使用文件访问/java.io 操作。EJB商业组件意味着使用资源管理器如JDBC来存储和检索数据而不是使用文件系统API。同时，部署工具提供了在部署描述器（descriptor）中存储环境实体，以至于EJB组件可以通过环境命名上下文用一种标准的方法进行环境实体查询。所以，使用文件系统的需求基本上是被排除了。
 5.监听和接收socket连接，或者用socket进行多路发送。EJB组件并不意味着提供网络socket服务器功能，但是，这个体系结构使得EJB组件可以作为socket客户或是RMI客户并且可以和容器所管理的环境外面的代码进行通讯。
 6.使用映象API查询EJB组件由于安全规则所不能访问的类。这个约束加强了Java平台的安全性。
 7.欲创建或获得一个类的加载器，设置或创建一个新的安全管理器，停止Java虚拟机，改变输入、输出和出错流。这个约束加强了安全性同时保留了EJB容器管理运行环境的能力。
 8.设置socket工厂被URL&#39;s ServerSocket,Socket和Stream handler使用。避免这个特点，可以加强安全性同时保留了EJB容器管理运行环境的能力。
 9.使用任何方法启动、停止和管理线程。这个约束消除了与EJB容器管理死锁、线程
和并发问题的责任相冲突的可能性。
 通过限制使用10－16几个特点，你的目标是堵上一个潜在的安全漏洞：
 10.直接读写文件描述符。
 11.为一段特定的代码获得安全策略信息。
 12.加载原始的类库。
 13.访问Java一般角色所不能访问的包和类。
 14.在包中定义一个类。
 15.访问或修改安全配置对象（策略、安全、提供者、签名者和实体）。
 16.使用Java序列化特点中的细分类和对象替代。
 17.传递this引用指针作为一个参数或者作为返回值返回this引用指针。你必须使用
SessionContext或EntityContext中的getEJBObject()的结果。
 Java2平台的安全策略
 以上所列的特点事实上正是Java编程语言和Java2标准版中的标准的、强有力的特色。EJB容器允许从J2SE中使用一些或全部的受限制的特色，尽管对于EJB组件是不可用的，但需通过J2SE的安全机制来使用而不是通过直接使用J2SE的API。
 Java2平台为EJB1.1规范中的EJB容器所制定的安全策略定义了安全许可集，这些许可在EJB组件的编程限制中出现。通过这个策略，定义了一些许可诸如：java.io.FilePermission,java.net.NetPermission,java.io.reflect.ReflectPermission,java.lang.security.SecurityPermission,以便加强先前所列出的编程限制。
 许多EJB容器没有加强这些限制，他们希望EJB组件开发者能遵守这些编程限制或者是带有冒险想法违背了这些限制。违背这些限制的EJB组件，比标准方法依赖过多或过少的安全许可，都将很少能在多个EJB容器间移植。另外，代码中都将隐藏着一些不确定的、难以预测的问题。所有这些都足以使EJB组件开发者应该知道这些编程限制，同时也应该认真地遵守它们。
 任何违背了这些编程限制的EJB组件的实现代码在编译时都不能检查出来，因为这些特点都是Java语言和J2SE中不可缺少的部分。
 对于EJB组件的这些限制同样适用于EJB组件所使用的帮助/访问（helper/access）类，J2EE应用程序使用Java文档（jar）文件格式打包到一个带.ear（代表Enterprise Archive）扩展名的文件中，这个ear文件对于发送给文件部署器来说是标准的格式。ear文件中包括在一个或多个ejb－jar文件中的EJB组件，还可能有ejb－jar所依赖的库文件。所有ear文件中的代码都是经过深思熟虑开发的应用程序并且都遵守编程限制和访问许可集。
未来版本的规范可能会指定通过部署工具来定制安全许可的能力，通过这种方法指定了一个合法的组件应授予的许可权限，也指定了一个标准方法的需求：如从文件系统中读文件应有哪些要求。一些EJB容器/服务器目前在它们的部署工具中都提供了比标准权限或多或少的许可权限，这些并不是EJB1.1规范中所需要的。
理解这些约束
 EJB容器是EJB组件生存和执行的运行期环境，EJB容器为EJB组件实例提供了一些服务如：事务管理、安全持久化、资源访问、客户端连接。EJB容器也负责EJB组件实例整个生命期的管理、扩展问题以及并发处理。所以，EJB组件就这样寄居在一个被管理的执行环境中－－即EJB容器。</p>
<p> 因为EJB容器完全负责EJB组件的生命期、并发处理、资源访问、安全等等，所以与容器本身的锁定和并发管理相冲突的可能性就需要消除，许多限制都需要使用来填上潜在的安全漏洞。除了与EJB容器责任与安全冲突的问题，EJB组件还意味着仅仅聚焦于商务逻辑，它依赖于EJB容器所提供的服务而不是自己来直接解决底层的系统层的问题。
 可能的问题
 通常，EJB组件在容器之间的移植不可避免地与如下问题相关：
 1.它需要依靠的受限制的特点在特定EJB容器中没有得到加强。
 2.它需要依靠的非标准的服务从容器中可获得。
 为了保证EJB组件的可移植性和一致的行为，你应该使用一个具有与Java2平台安全
策略集相一致的策略集的容器来测试EJB组件，并且其加强了前述的编程限制。
 总结
 EJB组件开发者应该知道这些推荐的关于EJB组件的编程限制，明白它们的重要性，并且从组件的稳定性和可移植性利益方面考虑来遵循它们。因为这些编程限制能阻止你使用标准的Java语言的特点，违背了这些编程限制在编译时不会知道，并且加强这些限制也不是EJB容器的责任。所有这些原因都使你应很小心地遵守这些编程限制，这些限制在组件的合同中已经成为了一个条款，并且它们对于建造可靠的、可移植的组件是非常重要的。</p>
</li>
<li>优化EJB
entity bean为在应用程序和设计中描述持久化商业对象（persistent business objec ts）提供了一个清晰的模型。在java对象模型中，简单对象通常都是以一种简单的方式进行处理但是，很多商业对象所需要的事务化的持久性管理没有得到实现。entity bean将持久化机制封装在容器提供的服务里，并且隐藏了所有的复杂性。entity bean允许应用程序操纵他们就像处理一个一般的java对象应用。除了从调用代码中隐藏持久化的形式和机制外，entity bean还允许EJB容器对对象的持久化进行优化，保证数据存储具有开放性，灵活性，以及可部署性。在一些基于EJB技术的项目中，广泛的使用OO技术导致了对entity bean的大量使用，SUN的工程师们已经积累了很多使用entity Bean的经验，这篇文章就详细阐述的这些卡发经验：
/<em>探索各种优化方法
/</em>提供性能优化和提高适用性的法则和建议
/*讨论如何避免一些教训。
法则1：只要可以，尽量使用CMP 
CMP方式不仅减少了编码的工作量，而且在Container中以及container产生的数据库访问代码中包括了许多优化的可能。Container可以访问内存缓冲中的bean,这就允许它可以监视缓冲中的任何变化。这样的话就在事物没有提交之前，如果缓存的数据没有变化就不用写到数据库中。就可以避免许多不必要的数据库写操作。另外一个优化是在调用find方法的时候。通常情况下find方法需要进行以下数据库操作：
查找数据库中的纪录并且获得主键
将纪录数据装入缓存
CMP允许将这两步操作优化为一步就可以搞定。[具体怎么做我也没弄明白，原文没有具体阐述]
法则2：写代码时尽量保证对BMP和CMP都支持
许多情况下，EJB的开发者可能无法控制他们写的bean怎么样被部署，以及使用的container是不是支持CMP.
一个有效的解决方案是，将商业逻辑的编码完全和持久化机制分离。再CMP类中实现商业逻辑，然后再编写一个BMP类，用该类继承CMP类。这样的话，所有的商业逻辑都在CMP类中，而持久化机制在BMP中实现。[我觉得这种情况在实际工作中很少遇到，但是作者解决问题的思路值得学习]
法则3：把ejbStore中的数据库访问减小到最少。
如果使用BMP,设置一个缓存数据改变标志dirty非常有用。所有改变数据库中底层数据的操作，都要设置dirty,而在ejbStore（）中，首先检测dirty的值，如果dirty的值没有改变，表明目前数据库中的数据与缓存的一致，就不必进行数据库操作了，反之，就要把缓存数据写入数据库。
法则4：总是将从lookup和find中获得的引用进行缓存。（cache）
引用缓存对session bean和entity bean 都是适用的。
通过JNDI lookup获得EJB资源。比如DataSource,bean的引用等等都要付出相当大的代价。因此应该避免多余的lookup.可以这样做：
将这些引用定义为实例变量。
从setEntityContext(session Bean使用setSessionContext)方法查找他们。SetEntityContext方法对于一个bean实例只执行一次，所有的相关引用都在这一次中进行查找，这样查找的代价就不是那么昂贵了。应该避免在其他方法中查找引用。尤其是访问数据库的方法：ejbLoad()和ejbStore(),如果在这些频繁调用的方法中进行DataSource的查找，势必造成时间的浪费。
调用其他entity bean的finder方法也是一种重量级的调用。多次调用finder()方法的代价非常高。如果这种引用不适合放在setEntityContext这样的初始化时执行的方法中执行，就应该在适当的时候缓存finder的执行结果。只是要注意的是，如果这个引用只对当前的entity有效，你就需要在bean从缓冲池中取出来代表另外一个实体时清除掉这些引用。，这些操作应该在ejbActivate（）中进行。
法则5:总是使用prepare statements
这条优化法则适用于所有访问关系数据库的操作。
数据库在处理每一个SQL Statement的时候，执行前都要对Statement进行编译。一些数据库具有缓存statement和statement的编译后形式的功能。数据库可以把新的Statement和缓存中的进行匹配。然而，如果要使用这一优化特性，新的Statement要必须和缓存中的Statement完全匹配。
对于Non-prepared Statement,数据和Statement本身作为一个字符串传递，这样由于前后调用的数据不同而不能匹配，就导致无法使用这种优化。而对于prepared Statement,数据和Statement是分开传递给数据库的，这样Statement就可以和cache中已编译的Statement进行匹配。Statement就不必每次都进行编译操作。从而使用该优化属性。
这项技术在一些小型的数据库访问中能够减少Statement将近90%的执行时间。
法则6：完全关闭所有的Statement
在编写BMP的数据库访问代码时，记住一定要在数据库访问调用之后关闭Statement,因为每个打开的Statement对应于数据库中的一个打开的游标。
Security
1．加密
对称加密
（1）分组密码
（2）流密码
常用的对称加密算法：
DES和TripleDES
Blowfish
RC4
AES
非对称加密
 常用的非对称加密算法
RSA
ElGamal
   会话密钥加密（对称加密和非对称加密一起使用）
常用的会话密钥加密协议
S/MIME
PGP
SSL和TLS   SSL是在Application level protocal和Transport protocal之间的。
比如：Http和TCP/IP之间
SSL 提供了服务器端认证和可选的客户端认证，保密性和数据完整性。
提供基于SSL方式的传输加密和认证，确保以下三种安全防护：
数据的机密性和准确性、
服务器端认证
客户端认证。
客户端认证比服务器端认证不很普遍的原因是每一个要被认证的客户都必须有一张Verisign这样的CA签发的证书。
通常，在进行身份认证的时候，应当只接受一个CA，这个CA的名字包含在客户证书中。
由于不可能随意创建一个由指定CA签发的证书，所以这可以有效的防御通过伪造证书来进行的攻击尝试。
2．认证（Authentication）
认证就是确定一条消息或一个用户的可靠性的过程。
1.消息摘要
MD5
SHA和SHA-1
2.消息认证码（Message Authientication Codes,MAC）
3.数字签名
用户可以用自己的密钥对信息加以处理，由于密钥仅为本人所有，这样就产生了别人无法生成的文件，也就形成了数字签名
数字签名可以
1）保证数据的完整性
2）验证用户的身份
数字签名采用一个人的私钥计算出来，然后用公钥去检验。<pre><code>    hash算法                             私钥加密
</code></pre>原报文 ――――――&gt;;报文摘要( Message Digest ) ―――――&gt;;数字签名
原报文和数字签名一起被发送到接受者那里，接受者用同样的hash算法得到报文摘要，然后用发送者的公钥解开数字签名。
比较是否相同，则可以确定报文确定来自发送者。
验证数字签名必须使用公钥，但是，除非你是通过安全的方式直接得到，否则不能保证公钥的正确性。（数字证书可以解决这个问题）
一个接受者在使用公钥（public key）检查数字签名（digital signature）的可信度时，通常先要检查收到的公钥（public key）是否可信的。
因此发送方不是单单地发送公钥（public key），而是发送一个包含公钥（public key）的数字证书（cetificate ）。
4.数字证书
数字证书是一个经证书授权中心数字签名的包含公开密钥所有者信息以及公开密钥的文件。
数字证书Cetificate中包括：
I. 用户的公钥（public key） 
II. 用户的一些信息，如姓名，email
III. 发行机构的数字签名（digital signature）， 用于保证证书的可信度
IV. 发行机构的一些信息
数字证书的格式遵循X.509国际标准。</li>
</ol>
<p>注意：一个数字证书certificate并不适用于多种browser,甚至一种Browser的多个版本。
数字标识由公用密钥、私人密钥和数字签名三部分组成。
当在邮件中添加数字签名时，您就把数字签名和公用密钥加入到邮件中。数字签名和公用密钥统称为证书。您可以使用 Outlook Express 来指定他人向您发送加密邮件时所需使用的证书。这个证书可以不同于您的签名证书。
收件人可以使用您的数字签名来验证您的身份，并可使用公用密钥给您发送加密邮件，这些邮件必须用您的私人密钥才能阅读。
要发送加密邮件，您的通讯簿必须包含收件人的数字标识。这样，您就可以使用他们的公用密钥来加密邮件了。当收件人收到加密邮件后，用他们的私人密钥来对邮件进行解密才能阅读。
在能够发送带有数字签名的邮件之前，您必须获得数字标识。如果您正在发送加密邮件，您的通讯簿中必须包含每位收件人的数字标识。
数字证书，可以是个人证书或 Web 站点证书，用于将身份与&quot;公开密钥&quot;关联。只有证书的所有者才知道允许所有者&quot;解密&quot;或进行&quot;数字签名&quot;的相应&quot;私人密钥&quot;。当您将自己的证书发送给其他人时，实际上发给他们的是您的公开密钥，这样他们就可以向您发送只能由您使用私人密钥解密和读取的加密信息。　
通过浏览器使用数字证书，必须先要设置浏览器软件 Internet Explorer 或 NetScape使用此证书，才能开始发送加密或需要数字签名的信息。访问安全的 Web 站点（以&quot;https&quot;打头的站点）时，该站点将自动向您发送他们的Web站点证书。
3．CA(证书授证中心)
CA机构，又称为证书授证(Certificate Authority)中心，作为电子商务交易中受信任的第三方，承担公钥体系中公钥的合法性检验的责任。CA中心为每个使用公开密钥的用户发放一个数字证书，数字证书的作用是证明证书中列出的用户合法拥有证书中列出的公开密钥。CA机构的数字签名使得攻击者不能伪造和篡改证书。在SET交易中，CA不仅对持卡人、商户发放证书，还要对获款的银行、网关发放证书。它负责产生、分配并管理所有参与网上交易的个体所需的数字证书，因此是安全电子交易的核心环节。
对证书的信任基于对根证书的信任. 例如在申请SHECA的个人数字证书前，需要先下载根证书，然后再进行各类证书的申请。
下载根证书的目的：
网络服务器验证(S)；安全电子邮件(E)
申请个人数字证书可以为Internet用户提供发送电子邮件的安全和访问需要安全连接（需要客户证书）的站点。
1）个人数字证书 
a.个人身份证书<br>个人身份证书是用来表明和验证个人在网络上的身份的证书，它确保了网上交易和作业的安全性和可靠性。可应用于：网上炒股、网上理财、网上保险、网上缴费、网上购物、网上办公等等。个人身份证书可以存储在软盘或IC卡中。   　
b.个人安全电子邮件证书<br>个人安全电子邮件证书可以确保邮件的真实性和保密性。申请后一般是安装在用户的浏览器里。用户可以利用它来发送签名或加密的电子邮件。 </p>
<p>用户在申请安装完安全安全电子邮件数字证书后，就可以对要发送的邮件进行数字签名。收信人收到该邮件后，就可以看到数字签名的标记，这样就可以证明邮件肯定来自发信者本人，而不是别人盗用该帐号伪造信件，同时也保证该邮件在传送过程中没被他人篡改过任何数据。
安全电子邮件中使用的数字证书可以实现：
保密性  通过使用收件人的数字证书对电子邮件加密。如此以来，只有收件人才能阅读加密的邮件，在Internet上传递的电子邮件信息不会被人窃取，即使发错邮件，收件人也无法看到邮件内容。
认证身份  在Internet上传递电子邮件的双方互相不能见面，所以必须有方法确定对方的身份。利用发件人数字证书在传送前对电子邮件进行数字签名即可确定发件人身份，而不是他人冒充的。
完整性  利用发件人数字证书在传送前对电子邮件进行数字签名不仅可确定发件人身份，而且传递的电子邮件信息也不能被人在传输过程中修改。
不可否认性  由于发件人的数字证书只有发件人唯一拥有，故发件人利用其数字证书在传送前对电子邮件进行数字签名，发件人就无法否认发过这个电子邮件。
OutLook Express中的个人安全电子邮件证书
签名邮件带有签名邮件图标。 
签名邮件可能出现的任何问题都将在本信息之后可能出现的“安全警告”中得到描述。如果存在问题，您应该认为邮件已被篡改，或并非来自所谓的发件人。
当收到一封加密邮件时，您应该可以自信地认为邮件未被任何第三者读过。Outlook Express 会自动对电子邮件解密， 如果在您的计算机上装有正确的数字标识。</p>
<p>2）企业数字证书 
a．企业身份证书
企业身份证书是用来表明和验证企业用户在网络上身份的证书，它确保了企业网上交易和作业的安全性和可靠性。可应用于：网上证券、网上办公、网上交税、网上采购、网上资金转帐、网上银行等。企业身份证书可以存储在软盘和IC卡中。    　　
b．企业安全电子邮件证书<br>企业安全电子邮件证书可以确保邮件的真实性和保密性。申请后一般是安装在用户的浏览器里。企业可以利用它来发送签名或加密的电子邮件。
可使用 Windows 2000 中的证书服务来创建证书颁发机构 (CA)，它负责接收证书申请、验证申请中的信息和申请者的身份、颁发证书、吊销证书以及发布证书吊销列表 (CRL)。 
通常，当用户发出证书申请时，在其计算机上的加密服务提供程序 (CSP) 为用户生成公钥和私钥对。用户的公钥随同必要的识别信息发送至 CA。如果用户的识别信息符合批准申请的 CA 标准，那么 CA 将生成证书，该证书由客户应用程序检索并就地存储。
4．SET
安全接口层协议——SSL(Se cure SocketsLayer)，并且已经几乎成为了目前WWW 世界的事实标准。这一标准使用公共密钥编码方案来对传输数据进行加密，在双方之间建立一个Internet 上的加密通道，从而使第三方无法获得其中的信息，其思路与目前流行的VPN方案大致相同，目的都是要保护数据不被未经授权的第三方所窃听，或即使窃听到也不知所云。但就象VPN 一样，SSL 在认证方面没有任何作为，它们都需要通过另外的手段来确认身份和建立双方彼此间的信任，然后再通过SSL 进行交易。 
正是由于SSL 标准在认证方面的缺憾，所以SET 才有存在的必要。SET(Secure Electronic Transactions) 规范由Masterc ard 和Visa 公司于1996 年发布，专家们认为SET 是保证用户与商家在电子商务与在线交易中免受欺骗的重要手段。传统的信用卡交易者总在担心不诚实的店员会将自己的信用卡号码透露给他人，而在线交易也是如此，持卡者总在担心服务器端的管理员会将信用卡号码泄露出去，或者担心黑客会在管理员不知情的情况下盗取信用卡号码。事实上这些担心都是必要的，而SET 标准则可以保证用户的信用卡号码只传送给信用卡公司进行认证，不会被系统管理员看到，也不会留在交易服务器的硬盘上给黑客以可乘之机。
5．PKI
PKI是一种易于管理的、集中化的网络安全方案。它可支持多种形式的数字认证: 数据加密、数字签字、不可否认、身份鉴别、密钥管理以及交叉认证等。PKI可通过一个基于认证的框架处理所有的数据加密和数字签字工作。P KI标准与协议的开发迄今已有15年的历史,目前的PKI已完全可以向企业网络提供有效的安全保障。
PKI是一种遵循标准的密钥管理平台,它能够为所有网络应用透明地提供采用加密和数字签名等密码服务所必需的密钥和证书管理。PKI必须具有
  1）CA、
2）证书库、
3）密钥备份及恢复系统、
4）证书作废处理系统、
5）客户端证书处理系统
等基本成分,构建PKI也将围绕着这五大系统来构建
一个PKI由众多部件组成,这些部件共同完成两个主要功能:
1）为数据加密
2）创建数字认证。
服务器(即后端)产品是这一系统的核心,这些数据库管理着数字认证、公共密钥及专用密钥( 分别用于数据的加密和解密)。
CA数据库负责发布、废除和修改X.509数字认证信息,它装有用户的公共密钥、证书有效期以及认证功能(例如对数据的加密或对数字签字的验证) 。为了防止对数据签字的篡改,CA在把每一数字签字发送给发出请求的客户机之前,需对每一个数字签字进行认证。一旦数字认证得以创建, 它将会被自动存储于X.500目录中,X.500目录为树形结构。LDAP(Lightweight Directory Access Protocol)协议将响应那些要求提交所存储的公共密钥认证的请求。CA为每一用户或服务器生成两对独立的公共和专用密钥。其中一对用于信息的加密和解密, 另一对由客户机应用程序使用,用于文档或信息传输中数字签字的创建。 
大多数PKI均支持证书分布,这是一个把已发布过的或续延生命期的证书加以存储的过程。这一过程使用了一个公共查询机制,X.500目录可自动完成这一存储过程。影响企业普遍接受P KI的一大障碍是不同CA之间的交叉认证。假设有两家公司,每一家企业分别使用来自不同供应商的CA,现在它们希望相互托管一段时间。如果其后援数据库支持交叉认证, 则这两家企业显然可以互相托管它们的CA,因而它们所托管的所有用户均可由两家企业的CA所托管。<br>＊ 认证机关<br>    CA是证书的签发机构,它是PKI的核心。众所周知,构建密码服务系统的核心内容是如何实现密钥管理,公钥体制涉及到一对密钥,即私钥和公钥, 私钥只由持有者秘密掌握,无须在网上传送,而公钥是公开的,需要在网上传送,故公钥体制的密钥管理主要是公钥的管理问题,目前较好的解决方案是引进证书（certificate）机制。  </p>
<pre><code>证书是公开密钥体制的一种密钥管理媒介。它是一种权威性的电子文档，形同网络计算环境中的一种身份证，用于证明某一主体（如人、服务器等）的身份以及其公开密钥的合法性。在使用公钥体制的网络环境中, 必须向公钥的使用者证明公钥的真实合法性。因此,在公钥体制环境中,必须有一个可信的机构来对任何一个主体的公钥进行公证,证明主体的身份以及他与公钥的匹配关系。C A正是这样的机构,它的职责归纳起来有:  
</code></pre><p>   1、验证并标识证书申请者的身份；<br>   2、确保CA用于签名证书的非对称密钥的质量；<br>   3、确保整个签证过程的安全性,确保签名私钥的安全性；<br>   4、证书材料信息（包括公钥证书序列号、CA标识等）的管理；<br>   5、确定并检查证书的有效期限；<br>   6、确保证书主体标识的唯一性,防止重名；<br>   7、发布并维护作废证书表；<br>   8、对整个证书签发过程做日志记录；<br>   9、向申请人发通知。  </p>
<pre><code>其中最为重要的是CA自己的一对密钥的管理，它必须确保其高度的机密性,防止他方伪造证书。CA的公钥在网上公开,整个网络系统必须保证完整性。  
</code></pre><p>＊ 证书库<br>    证书库是证书的集中存放地,它与网上&quot;白页”类似,是网上的一种公共信息库,用户可以从此处获得其他用户的证书和公钥。<br>构造证书库的最佳方法是采用支持LDAP协议的目录系统,用户或相关的应用通过LDAP来访问证书库。系统必须确保证书库的完整性,防止伪造、篡改证书。<br>＊ 密钥备份及恢复系统  </p>
<p>＊ 证书作废处理系统  </p>
<p>＊ PKI应用接口系统<br>PKI的价值在于使用户能够方便地使用加密、数字签名等安全服务，因此一个完整的PKI必须提供良好的应用接口系统，使得各种各样的应用能够以安全、一致、可信的方式与P KI交互，确保所建立起来的网络环境的可信性，同时降低管理维护成本。最后，PKI应用接口系统应该是跨平台的。</p>
<p>许多权威的认证方案供应商(例如VeriSign、Thawte以及GTE)目前都在提供外包的PKI。外包PKI最大的问题是,用户必须把企业托管给某一服务提供商, 即让出对网络安全的控制权。如果不愿这样做,则可建造一个专用的PKI。专用方案通常需把来自Entrust、Baltimore Technologies以及Xcert的多种服务器产品与来自主流应用程序供应商(如Microsoft、Netscape以及Qualcomm)的产品组合在一起。专用PK I还要求企业在准备其基础设施的过程中投入大量的财力与物力。
7．JAAS
扩展JAAS实现类实例级授权<br>“Java 认证和授权服务”（Java Authentication and Authorization Service，JAAS）
在 JAAS 下，可以给予用户或服务特定的许可权来执行 Java 类中的代码。在本文中，软件工程师 Carlos Fonseca 向您展示如何为企业扩展 JAAS 框架。向 JAAS 框架添加类实例级授权和特定关系使您能够构建更动态、更灵活并且伸缩性更好的企业应用程序。
大多数 Java 应用程序都需要某种类实例级的访问控制。例如，基于 Web 的、自我服务的拍卖应用程序的规范可能有下列要求：
任何已注册（经过认证）的用户都可以创建一个拍卖，但只有创建拍卖的用户才可以修改这个拍卖。 
这意味着任何用户都可以执行被编写用来创建 Auction 类实例的代码，但只有拥有该实例的用户可以执行用来修改它的代码。通常情况下，创建 Auction 实例的用户就是所有者。这被称为类实例所有者关系（class instance owner relationship）。
该应用程序的另一个要求可能是：
任何用户都可以为拍卖创建一个投标，拍卖的所有者可以接受或拒绝任何投标。 
再一次，任何用户都可以执行被编写用来创建 Bid 类实例的代码，但只有拥有该实例的用户会被授予修改该实例的许可权。而且，Auction 类实例的所有者必须能够修改相关的 Bid 类实例中的接受标志。这意味着在 Auction 实例和相应的 Bid 实例之间有一种被称为特定关系（special relationship）的关系。
不幸的是，“Java 认证和授权服务”（JAAS）— 它是 Java 2 平台的一部分 — 没有考虑到类实例级访问控制或者特定关系。在本文中，我们将扩展 JAAS 框架使其同时包含这两者。推动这种扩展的动力是允许我们将访问控制分离到一个通用的框架，该框架使用基于所有权和特定关系的策略。然后管理员可以在应用程序的生命周期内更改这些策略。
在深入到扩展 JAAS 框架之前，我们将重温一下 Java 2 平台的访问控制机制。我们将讨论策略文件和许可权的使用，并讨论 SecurityManager 和 AccessController 之间的关系。 
Java 2 平台中的访问控制
在 Java 2 平台中，所有的代码，不管它是本地代码还是远程代码，都可以由策略来控制。策略（policy）由不同位置上的代码的一组许可权定义，或者由不同的签发者定义、或者由这两者定义。许可权允许对资源进行访问；它通过名称来定义，并且可能与某些操作关联在一起。
抽象类 java.security.Policy 被用于表示应用程序的安全性策略。缺省的实现由 sun.security.provider.PolicyFile 提供，在 sun.security.provider.PolicyFile 中，策略被定义在一个文件中。清单 1 是一个典型策略文件示例：
清单 1. 一个典型的策略文件
// Grant these permissions to code loaded from a sample.jar file
// in the C drive and if it is signed by XYZ
grant codebase &quot;file:/C:/sample.jar&quot;, signedby &quot;XYZ&quot; {
// Allow socket actions to any host using port 8080
permission java.net.SocketPermission &quot;/<em>:8080&quot;, &quot;accept, connect, 
  listen, resolve&quot;;
// Allows file access (read, write, execute, delete) in
// the user&#39;s home directory.
Permission java.io.FilePermission &quot;${user.home}/-&quot;, &quot;read, write, 
  execute, delete&quot;;
};
SecurityManager 对 AccessController
在标准 JDK 分发版中，控制代码源访问的机制缺省情况下是关闭的。在 Java 2 平台以前，对代码源的访问都是由 SecurityManager 类管理的。SecurityManager 是由 java.security.manager 系统属性启动的，如下所示：
java -Djava.security.manager
在 Java 2 平台中，可以将一个应用程序设置为使用 java.lang.SecurityManager 类或者 java.security.AccessController 类管理敏感的操作。AccessController 在 Java 2 平台中是新出现的。为便于向后兼容，SecurityManager 类仍然存在，但把自己的决定提交 AccessController 类裁决。SecurityManager 和 AccessController 都使用应用程序的策略文件确定是否允许一个被请求的操作。清单 2 显示了 AccessController 如何处理 SocketPermission 请求：
清单 2. 保护敏感操作
Public void someMethod() {
Permission permission = 
  new java.net.SocketPermission(&quot;localhost:8080&quot;, &quot;connect&quot;);
AccessController.checkPermission(permission);
// Sensitive code starts here
Socket s = new Socket(&quot;localhost&quot;, 8080);
}
在这个示例中，我们看到 AccessController 检查应用程序的当前策略实现。如果策略文件中定义的任何许可权暗示了被请求的许可权，该方法将只简单地返回；否则抛出一个 AccessControlException 异常。在这个示例中，检查实际上是多余的，因为缺省套接字实现的构造函数也执行相同的检查。
在下一部分，我们将更仔细地看一下 AccessController 如何与 java.security.Policy 实现共同合作安全地处理应用程序请求。
运行中的 AccessController
AccessController 类典型的 checkPermission(Permission p) 方法调用可能会导致下面的一系列操作：
AccessController 调用 java.security.Policy 类实现的 getPermissions(CodeSource codeSource) 方法。
getPermissions(CodeSource codeSource) 方法返回一个 PermissionCollection 类实例，这个类实例代表一个相同类型许可权的集合。
AccessController 调用 PermissionCollection 类的 implies(Permission p) 方法。
接下来，PermissionCollection 调用集合中包含的单个 Permission 对象的 implies(Permission p) 方法。如果集合中的当前许可权对象暗示指定的许可权，则这些方法返回 true，否则返回 false。
现在，让我们更详细地看一下这个访问控制序列中的重要元素。
PermissionCollection 类
大多数许可权类类型都有一个相应的 PermissionCollection 类。这样一个集合的实例可以通过调用 Permission 子类实现定义的 newPermissionCollection() 方法来创建。java.security.Policy 类实现的 getPermissions() 方法也可以返回 Permissions 类实例 — PermissionCollection 的一个子类。这个类代表由 PermissionCollection 组织的不同类型许可权对象的一个集合。Permissions 类的 implies(Permission p) 方法可以调用单个 PermissionCollection 类的 implies(Permission p) 方法。
CodeSource 和 ProtectionDomain 类
许可权组合与 CodeSource（被用于验证签码（signed code）的代码位置和证书）被封装在 ProtectionDomain 类中。有相同许可权和相同 CodeSource 的类实例被放在相同的域中。带有相同许可权，但不同 CodeSource 的类被放在不同的域中。一个类只可属于一个 ProtectionDomain。要为对象获取 ProtectionDomain，请使用 java.lang.Class 类中定义的 getProtectionDomain() 方法。
许可权
赋予 CodeSource 许可权并不一定意味着允许所暗示的操作。要使操作成功完成，调用栈中的每个类必须有必需的许可权。换句话说，如果您将 java.io.FilePermission 赋给类 B，而类 B 是由类 A 来调用，那么类 A 必须也有相同的许可权或者暗示 java.io.FilePermission 的许可权。
在另一方面，调用类可能需要临时许可权来完成另一个拥有那些许可权的类中的操作。例如，当从另一个位置加载的类访问本地文件系统时，我们可能不信任它。但是，本地加载的类被授予对某个目录的读许可权。这些类可以实现 PrivilegedAction 接口来给予调用类许可权以便完成指定的操作。调用栈的检查在遇到 PrivilegedAction 实例时停止，有效地将执行指定操作所必需的许可权授予所有的后继类调用。
使用 JAAS
顾名思义，JAAS 由两个主要组件组成：认证和授权。我们主要关注扩展 JAAS 的授权组件，但开始我们先简要概述一下 JAAS 认证，紧接着看一下一个简单的 JAAS 授权操作。
JAAS 中的用户认证
JAAS 通过添加基于 subject 的策略加强了 Java 2 中定义的访问控制安全性模型。许可权的授予不仅基于 CodeSource，还基于执行代码的用户。显然，要使这个模型生效，每个用户都必须经过认证。
JAAS 的认证机制建立在一组可插登录模块的基础上。JAAS 分发版包含几个 LoginModule 实现。LoginModules 可以用于提示用户输入用户标识和密码。LoginContext 类使用一个配置文件来确定使用哪个 LoginModule 对用户进行认证。这个配置可以通过系统属性 java.security.auth.login.config 指定。一个示例配置是： 
java -Djava.security.auth.login.config=login.conf
下面是一个登录配置文件的样子：
Example {
  com.ibm.resource.security.auth.LoginModuleExample required 
    debug=true userFile=&quot;users.xml&quot; groupFile=&quot;groups.xml&quot;;
};
认识您的主体
Subject 类被用于封装一个被认证实体（比如用户）的凭证。一个 Subject 可能拥有一个被称为主体（principal）的身份分组。例如，如果 Subject 是一个用户，用户的名字和相关的社会保险号可能是 Subject 的某些身份或主体。主体是与身份名关联在一起的。
Principal 实现类及其名称都是在 JAAS 策略文件中指定的。缺省的 JAAS 实现使用的策略文件与 Java 2 实现的策略文件相似 — 除了每个授权语句必须与至少一个主体关联在一起。javax.security.auth.Policy 抽象类被用于表示 JAAS 安全性策略。它的缺省实现由 com.sun.security.auth.PolicyFile 提供，在 com.sun.security.auth.PolicyFile 中策略定义在一个文件中。清单 3 是 JAAS 策略文件的一个示例：
清单 3. 示例 JAAS 策略文件
// Example grant entry
grant codeBase &quot;file:/C:/sample.jar&quot;, signedby &quot;XYZ&quot;,
  principal com.ibm.resource.security.auth.PrincipalExample &quot;admin&quot; {
    // Allow socket actions to any host using port 8080
    permission java.net.SocketPermission 
      &quot;/</em>:8080&quot;, &quot;accept, connect, listen, resolve&quot;;
    // Allows file access (read, write, execute, delete) in
    // the user&#39;s home directory.
    Permission java.io.FilePermission 
      &quot;${user.home}/-&quot;, &quot;read, write, execute, delete&quot;;
};
这个示例与清单 1 中所示的标准 Java 2 策略文件相似。实际上，唯一的不同是主体语句，该语句声明只有拥有指定主体和主体名字的 subject（用户）被授予指定的许可权。
再一次，使用系统属性 java.security.auth.policy 指出 JAAS 策略文件驻留在何处，如下所示：
java -Djava.security.auth.policy=policy.jaas
Subject 类包含几个方法来作为特殊 subject 执行工作；这些方法如下所示：
public static Object 
  doAs(Subject subject, java.security.PrivilegedAction action)
public static Object 
  doAs(Subject subject, java.security.PrivilegedAction action)
  throws java.security.PrivilegedActionException
注意，用来保护敏感代码的方法与“Java 2 代码源访问控制”（Java 2 CodeSource Access Control）概述中描述的方法相同。请参阅参考资料部分以了解更多关于 JAAS 中代码源访问控制和认证的信息。
JAAS 中的授权
清单 4 显示一个授权请求的结果，该请求使用清单 3 中显示的 JAAS 策略文件。假设已经安装了 SecurityManager，并且 loginContext 已经认证了一个带有名为“admin”的 com.ibm.resource.security.auth.PrincipalExample 主体的 Subject。
清单 4. 一个简单的授权请求
public class JaasExample {
public static void main(String[] args) {
...
// where authenticatedUser is a Subject with
// a PrincipalExample named admin.
Subject.doAs(authenticatedUser, new JaasExampleAction());
...
}
}
public class JaasExampleAction implements PrivilegedAction {
public Object run() {
FileWriter fw = new FileWriter(&quot;hi.txt&quot;);
fw.write(&quot;Hello, World!&quot;);
fw.close();
}
}
这里，敏感代码被封装在 JaasExampleAction 类中。还要注意，调用类不要求为 JaasExampleAction 类代码源授予许可权，因为它实现了一个 PrivilegedAction。
扩展 JAAS
大多数应用程序都有定制逻辑，它授权用户不仅仅在类上执行操作，而且还在该类的实例上执行操作。这种授权通常建立在用户和实例之间的关系上。这是 JAAS 的一个小缺点。然而，幸运的是，这样设计 JAAS 使得 JAAS 可以扩展。只要做一点工作，我们将可以扩展 JAAS，使其包含一个通用的、类实例级的授权框架。
在文章开头处我已经说明了，抽象类 javax.security.auth.Policy 被用于代表 JAAS 安全性策略。它的缺省实现是由 com.sun.security.auth.PolicyFile 类提供。PolicyFile 类从 JAAS 格式的文件（象清单 3 中显示的那个一样）中读取策略。
我们需要向这个文件添加一个东西为类实例级授权扩展策略定义：一个与许可权语句相关的可选关系参数。
缺省 JAAS 许可权语句的格式如下：
permission <permission implementation class>; [name], [actions];
我们在这个许可权语句的末尾添加一个可选的关系参数来完成策略定义。下面是新许可权语句的格式：
permission <permission implementation class>; 
  [name], [actions], [relationship];
在为类实例级授权扩展 JAAS 时要注意的最重要的一点是：许可权实现类必须有一个带三个参数的构造函数。第一个参数是名称参数，第二个是行为参数，最后一个是关系参数。
解析新文件格式
既然文件格式已经改变，就需要一个新的 javax.security.auth.Policy 子类来解析文件。
为简单起见，我们的示例使用了一个新的 javax.security.auth.Policy 子类 com.ibm.resource.security.auth.XMLPolicyFile，来从 XML 文件读取策略。在实际的企业应用程序中，关系数据库更适合执行这个任务。
使用 XMLPolicyFile 类代替缺省的 JAAS 访问控制策略实现的最容易的方法是向 java.security 属性文件添加 auth.policy.provider=com.ibm.resource.security.auth.XMLPolicyFile 条目。java.security 属性文件位于 Java 2 平台运行时的 lib/security 目录下。清单 5 是与 XMLPolicyFile 类一起使用的样本 XML 策略文件：
清单 5. 一个 XML 策略文件
&lt;?xml version=&quot;1.0&quot;?&gt;;</p>
<p><policy>;
    <grant codebase="file:/D:/sample_actions.jar">;
      <principal classname=
        "com.ibm.resource.security.auth.PrincipalExample" name="users">;
        <permission classname=
          "com.ibm.resource.security.auth.ResourcePermission"
          name="com.ibm.security.sample.Auction"
          actions="create" />;
        <permission classname=
         "com.ibm.resource.security.auth.ResourcePermission"
          name="com.ibm.security.sample.Auction"
          actions="read" />;
        <permission classname=
         "com.ibm.resource.security.auth.ResourcePermission"
          name="com.ibm.security.sample.Auction"
          actions="write"
          relationship="owner" />;
        <permission classname=
         "com.ibm.resource.security.auth.ResourcePermission"
          name="com.ibm.security.sample.Bid"
          actions="create" />;
        <permission classname=
         "com.ibm.resource.security.auth.ResourcePermission"
          name="com.ibm.security.sample.Bid"
          actions="read" />;
        <permission classname=
         "com.ibm.resource.security.auth.ResourcePermission"
          name="com.ibm.security.sample.Bid"
          actions="write"
          relationship="owner" />;
        <permission classname=
         "com.ibm.resource.security.auth.ResourcePermission"
          name="com.ibm.security.sample.Bid"
          actions="accept"
          relationship="actionOwner" />;
    </principal>;
  </grant>;
</policy>;
在这个示例策略文件中，任何与名为 PrincipalExample 的用户有关的用户（Subject）都可以创建并读取一个 Auction.class 实例。但是，只有创建该实例的用户才可以更新（写）它。这是第三个 permission 元素定义的，该元素包含值为 owner 的 relationship 属性。Bid.class 实例也是一样，除了相应 Auction.class 实例的所有者可以更改投标接受标志。
Resource 接口
要求类实例级访问控制的类必须实现 Resource 接口。该接口的 getOwner() 方法返回类实例的所有者。fulfills(Subject subject, String relationship) 方法被用于处理特定关系。另外，这些类使用 com.ibm.resource.security.auth.ResourcePermission 类保护敏感代码。例如，Auction 类拥有下列构造函数：
public Auction() {
  Permission permission = 
    new ResourcePermission(&quot;com.ibm.security.sample.Auction&quot;, &quot;create&quot;);
  AccessController.checkPermission(permission);
}
所有者关系
ResourcePermission 类的 implies(Permission p) 方法是这个框架的关键。implies() 方法就等同性比较名称和行为属性。如果定义了一个关系，那么必须把受保护的类实例（Resource）传递到 ResourcePermission 构造函数中。ResourcePermission 类理解所有者关系。它将类实例的所有者与执行代码的 subject（用户）进行比较。特定关系被委托给受保护类的 fulfills() 方法。
例如，在清单 5 中所示的 XML 策略文件中，只有 Auction 类实例的所有者可以更新（写）文件。该类的 setter 方法使用清单 6 中显示的保护代码：
清单 6. 运行中的 implies(Permission) 方法
public void setName(String newName) {
  Permission permission = 
    new ResourcePermission(&quot;com.ibm.security.sample.Auction&quot;, &quot;write&quot;, this);
  AccessController.checkPermission(permission);
  // sensitive code
  this.name = newName;
}
被传递到 ResourcePermission 构造函数中的 this 引用代表 Auction 类实现的 Resource 接口。由于策略文件中列出的关系是 owner，所以 ResourcePermission 类使用这个引用检查当前 Subject（用户）是否拥有与实例所有者相匹配的主体。如果指定了另一个关系，那么 ResourcePermission 类调用 Auction 类的 fulfills(Subject subject, String relationship) 方法。由 Resource 实现类提供 fulfills() 方法中的逻辑。
XML 策略文件中列出的 Bid 类拥有清单 7 中所示的方法（假设 Bid 类实例有一个对相应 Auction 类实例的引用 — auction）。
清单 7. 处理特定关系
public void setAccepted(boolean flag) {
  Permission permission = 
    new ResourcePermission(&quot;com.ibm.security.sample.Auction&quot;, &quot;accept&quot;, this);
  AccessController.checkPermission(permission);
  // sensitive code
  this.accepted = flag;
  }
public boolean fulfills(Subject user, String relationship) {
  if( relationship.equalsIgnoreCase(&quot;auctionOwner&quot;) ) {
    String auctionOwner = auction.getOwner();
    Iterator principalIterator = user.getPrincipals().iterator();
    while(principalIterator.hasNext()) {
      Principal principal = (Principal) principalIterator.next();
      if( principal.getName().equals(auctionOwner) )
        return true;
    }
  }
  return false;
}
传递到 fulfills() 方法中的关系字符串是策略文件中列出的关系。在这个案例中，我们使用了“auctionOwner”字符串。
缺省情况下，XMLPolicyFile 类在当前工作目录中查找名为 ResourcePolicy.xml 的文件。系统属性 com.ibm.resource.security.auth.policy 可以用于指定另一个不同的文件名和位置。
WebSphere Application Server 示例
除命令行示例之外，您可能还想运行这个简单的程序，该程序为了 IBM WebSphere Application Server，version 4.0.2 而被优化。</p>
<p>一个可运行的示例
综合这些信息，我们将运行一个简单的命令行示例。该示例程序包含三个 jar 文件：
resourceSecurity.jar 
example.jar 
exampleActions.jar 
resourceSecurity.jar 文件包含允许实例级访问控制的 JAAS 扩展框架。它还包含一个 LoginModuleExample 类，这个类从 XML 文件读取用户认证信息。用户标识和密码存储在 users.xml 文件中。用户组存储在 groups.xml 文件中。关于 LoginModuleExample 的更多信息，请参阅参考资料部分。
该示例包含四个附加的文件：
login.conf 
policy 
resourcePolicy.xml 
run.bat 
在试图运行这个示例程序之前，请确保更新了 run.bat、policy 和 resourcePolicy.xml 文件中的路径。缺省情况下，所有的密码都是“passw0rd”。 
示例如何工作
该示例程序提示输入用户标识和密码。它用 users.xml 文件中的条目核对所提供的用户标识和密码。在认证了用户之后，程序设法创建一个 UserProfile 类实例，修改它并从中读取。缺省情况下，UserProfile 类的所有者是 Jane（jane）。当 Jane 登录时，三个操作全部成功。当 John（john）登录时，只有创建操作成功。当 Jane 的经理 Lou（lou）登录时，只有第一个和最后一个操作成功。当系统管理员（admin）登录时，操作全部成功。当然，只有当提供的 ResourcePolicy.xml 文件未被修改时，上述这些才都是真的。
示例安装 
下面的安装指导假设您正在使用 JDK 1.3 并且已经把文件解压缩到 d:\JaasExample 目录。通过将文件解压缩到这个目录，您可以省去一些工作；否则您就必须使用正确的路径名修改 policy 和 ResourceSecurity.xml 策略文件。
下面是运行该示例需要做的工作：
下载这个示例的源文件。
把 jaas.jar 和 jaasmod.jar 复制到 JDK jre\lib\ext 目录（即 D:\JDK1.3\jre\lib\ext）。
向位于 JDK 的 jre\lib\security 目录（即 D:\JDK1.3\jre\lib\security）中的 java.security 文件的末尾添加下面的字符串：auth.policy.provider=com.ibm.resource.security.auth.XMLPolicyFile。 
执行 run.bat 文件。 
结束语
类实例级授权把访问控制分离到一个通用框架（该框架使用基于所有权和特定关系的策略）中。然后管理员可以在应用程序的生命周期内更改这些策略。用这种方法扩展 JAAS 减少了您或另一个程序员必须在应用程序生命周期内业务规则发生更改时重写代码的可能性。
通过将关系字符串抽象为类可以进一步扩展特定关系这个概念。不调用 Resource 实现类的 fulfills(Subject user, String relationship) 方法，而只要调用 Relationship 实现类中定义的新 fulfills(Subject user, Resource resource) 方法。这样就会允许许多 Resource 实现类使用相同的关系逻辑。
6．Java的安全性</p>
<ol>
<li>the security manager是一个application-wide object ( java.lang.SecurityManager)
每个Java Application都可以有自己地Security Manager,但是默认地Java Application没有一个Security Manager
可以通过下面地代码得到一个Security Manager
try
{
System.setSecurityManager(new SecurityManager(“--”));
}
catch( )
{}
2.
JDBC
在 JDBC 2 开发的过程中，SQL99 还处在一种变化不定的情况下。现在规范已经完成了，而且数据库厂商已经采用了部分标准。所以自然地，JDBC 规范就跟着将自己与 SQL99 功能的一部分相统一。最新的 JDBC 规范已经采用了 SQL99 标准中那些已经被广泛支持的功能，还有那些在五年内可能会获得支持的功能。</li>
<li>DataSource
在JDBC2.0 Optional Package中，提供了透明的连接池（Connection pooling）。
一旦配置了J2EE应用服务器后，只要用DataSource获取连接(Connection)，连接池（Connection pooling）就会自动的工作。
如果用户希望建立一个数据库连接，通过查询在JNDI服务中的DataSource，可以从DataSource中获取相应的数据库连接。
DataSource被认为是从JNDI中获取的网络资源。
DataSource在池中保存的对象都实现了PooledConnection接口。
当应用程序向DataSource请求一个Connection时，它会找到一个可用的PooledConnection对象。
如果连接池空了，它就向ConnectionPoolecDataSource请求一个新的PooledConnection对象
通过使用 DataSource 接口 (JDBC 2.0) 或 DriverManager (JDBC 1.0) 接口，J2EE 组件可以获得物理数据库连接对象（Connection）。要获得逻辑（合用的）连接，J2EE 组件必须使用以下这些 JDBC 2.0 合用管理器接口：
javax.sql.ConnectionPoolDataSource 接口，该接口充当合用的 java.sql.Connection 对象的资源管理器连接 factory。每家数据库服务器供应商都提供该接口的实现
（例如，Oracle 实现 oracle.jdbc.pool.OracleConnectionPoolDataSource 类）。 
javax.sql.PooledConnection 接口，该接口封装到数据库的物理连接。同样，数据库供应商提供其实现。 
对于那些接口和 XA 连接的每一个，都存在一个 XA（X/Open 规范）等价定义。</li>
<li>ResultSet
在JDBC2.0中，为了获得一个Uptatable Result，在Query语句里必须包含Primarykey，并且查询的内容里必须来自一个table
ava.sql.ResultSet接口中定义了三种类型的结果集
TYPE_FORWARD_ONLY
TYPE_SCROLL_INSENSITIVE   这种类型的结果集支持双向滚动
TYPE_SCROLL_SENSITIVE
如果要建立一个双向滚动的ResultSet，一定要在建立Statement的时候使用如下参数
Statement stmt = conn.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,
ResultSet.CONCUR_READ_ONLY);</li>
<li>JDBC驱动程序
连通oracle8.1.6的JDBC
把oracle8.1.6/lib/jdbc//<em>.zip copy 到 %JAVA_HOME%/jre/lib/ext//</em>.jar
如果光copy不ren为.jar是没有用的。</li>
<li>事务处理
本地事务
java.sql.Connection接口可以控制事务边界（即开始和结束）。
在事务开始的时候调用setAutoCommit( false ), 而在中止事务时调用rollback或commit()方法。这类事务叫本地事务。
分布式事务
但是，在特定的情况下，可能有多个客户（例如两个不同的servlet或EJB组件）参与了同一个事务。
或者，客户在同一个事务中可能会执行跨越多个数据库的数据库操作。
JDBC2.0 Optional Package 同JTA一起来实现分布式样事务。</li>
<li>一些技巧
检索自动产生的关键字
为了解决对获取自动产生的或自动增加的关键字的值的需求，JDBC 3.0 API 现在将获取这种值变得很轻松。要确定任何所产生的关键字的值，只要简单地在语句的 execute() 方法中指定一个可选的标记，表示您有兴趣获取产生的值。您感兴趣的程度可以是 Statement.RETURN_GENERATED_KEYS，也可以是 Statement.NO_GENERATED_KEYS。在执行这条语句后，所产生的关键字的值就会通过从 Statement 的实例方法 getGeneratedKeys() 来检索 ResultSet 而获得。ResultSet 包含了每个所产生的关键字的列。清单 1 中的示例创建一个新的作者并返回对应的自动产生的关键字。
清单 1. 检索自动产生的关键字
Statement stmt = conn.createStatement();
// Obtain the generated key that results from the query.
stmt.executeUpdate(&quot;INSERT INTO authors &quot; +<pre><code>    &#39;(first_name, last_name) &quot; +
    &quot;VALUES (&#39;George&#39;, &#39;Orwell&#39;)&quot;,
    Statement.RETURN_GENERATED_KEYS);
</code></pre>ResultSet rs = stmt.getGeneratedKeys();
if ( rs.next() ) {
 // Retrieve the auto generated key(s).
 int key = rs.getInt();
}
JTA/JTS
1．JTA/JTS基本知识
服务器实现JTS是否对应用程序开发人员来说不是很重要的。
对你来说，应该把JTA看作是可用的API。
JTA是用来开发distributed tansaction的 API.
而JTS定义了支持JTA中实现Transaction Manager 的规范。
JavaTransaction Service (JTS) specifies the implementation of a Transaction Manager which supports the Java Transaction API (JTA) 1.0 Specification at the high-level and implements the Java mapping of the OMG Object Transaction Service (OTS) 1.1 Specification at the low-level. JTS uses the standard CORBA ORB/TS interfaces and Internet Inter-ORB Protocol (IIOP) for transaction context propagation between JTS Transaction Managers. 
A JTS Transaction Manager provides transaction services to the parties involved in distributed transactions: the application server, the resource manager, the standalone transactional application, and the Communication Resource Manager (CRM).
2．JTA
1.1 事务处理的概念
JTA实际上是由两部分组成的：一个高级的事务性客户接口和一个低级的 X/Open XA接口。
我们关心的是高级客户接口，因为bean可以访问它，而且是推荐的客户应用程序的事务性接口。
低级的XA接口是由EJB服务器和容器使用来自动协调事务和资源（如数据库）的
1.1.1事务划分
a．程序划分
使用UserTransaction启动JTA事务
The UserTransaction interface defines the methods that allow an application to explicitly manage transaction boundaries.（from j2ee API document）
b．声明划分
EJB容器使用TransactionManager启动JTA事务
The TransactionManager interface defines the methods that allow an application server to manage transaction boundaries. （from j2ee API document）
1.1.2事务上下文及其传播
事务上下文是一种对资源上的事务操作之间和调用操作的组件之间的联系。
1.1.3资源加入
资源加入（resource enlistment）是一个过程，在这个过程中资源管理器通知事务管理器它要参与事务。
1.1.4两阶段提交
两阶段提交是事务管理器和所有加入到事务中的资源之间的协议，确保要么所有的资源管理器都提交了事务，要么都撤销了事务。
如果在一个事务内部只是访问一个单一资源管理器，不需要执行一个两阶段提交。
如果在一个事务内部只是访问多个资源管理器，两阶段提交是有益的。
1.2事务处理系统中的构件模块
应用组件
资源管理器
资源管理器管理持久和稳定的数据存储系统，并且与事务管理器一起参与两阶段提交和恢复协议。典型的资源管理器如数据库系统和消息队列。
事务管理器
3．JTS
JTS 是一个组件事务监视器（component transaction monitor）。
这是什么意思？在第 1 部分，我们介绍了事务处理监视器（TPM）这个概念，TPM 是一个程序，它代表应用程序协调分布式事务的执行。
TPM 与数据库出现的时间长短差不多；在 60 年代后期，IBM 首先开发了 CICS，至今人们仍在使用。经典的（或者说程序化）TPM 管理被程序化定义为针对事务性资源（比如数据库）的操作序列的事务。随着分布式对象协议，如 CORBA、DCOM 和 RMI 的出现，人们希望看到事务更面向对象的前景。将事务性语义告知面向对象的组件要求对 TPM 模型进行扩展 — 在这个模型中事务是按照事务性对象的调用方法定义的。
JTS 只是一个组件事务监视器（有时也称为对象事务监视器（object transaction monitor）），或称为 CTM。
JTS 和 J2EE 的事务支持设计受 CORBA 对象事务服务（CORBA Object Transaction Service，OTS）的影响很大。实际上，JTS 实现 OTS 并充当 Java 事务 API（Java Transaction API）— 一种用来定义事务边界的低级 API — 和 OTS 之间的接口。使用 OTS 代替创建一个新对象事务协议遵循了现有标准，并使 J2EE 和 CORBA 能够互相兼容。
乍一看，从程序化事务监视器到 CTM 的转变好像只是术语名称改变了一下。然而，差别不止这一点。当 CTM 中的事务提交或回滚时，与事务相关的对象所做的全部更改都一起被提交或取消。但 CTM 怎么知道对象在事务期间做了什么事？象 EJB 组件之类的事务性组件并没有 commit() 或 rollback() 方法，它们也没向事务监视器注册自己做了什么事。那么 J2EE 组件执行的操作如何变成事务的一部分呢？
透明的资源征用
当应用程序状态被组件操纵时，它仍然存储在事务性资源管理器（例如，数据库和消息队列服务器）中，这些事务性资源管理器可以注册为分布式事务中的资源管理器。在第 1 部分中，我们讨论了如何在单个事务中征用多个资源管理器，事务管理器如何协调这些资源管理器。资源管理器知道如何把应用程序状态中的变化与特定的事务关联起来。
但这只是把问题的焦点从组件转移到了资源管理器 — 容器如何断定什么资源与该事务有关，可以供它征用？请考虑下面的代码，在典型的 EJB 会话 bean 中您可能会发现这样的代码：
清单 1. bean 管理的事务的透明资源征用 
InitialContext ic = new InitialContext();
UserTransaction ut = ejbContext.getUserTransaction();
ut.begin();
DataSource db1 = (DataSource) ic.lookup(&quot;java:comp/env/OrdersDB&quot;);
DataSource db2 = (DataSource) ic.lookup(&quot;java:comp/env/InventoryDB&quot;);
Connection con1 = db1.getConnection();
Connection con2 = db2.getConnection();
// perform updates to OrdersDB using connection con1
// perform updates to InventoryDB using connection con2
ut.commit();
注意，这个示例中没有征用当前事务中 JDBC 连接的代码 — 容器会为我们完成这个任务。我们来看一下它是如何发生的。
资源管理器的三种类型
当一个 EJB 组件想访问数据库、消息队列服务器或者其它一些事务性资源时，它需要到资源管理器的连接（通常是使用 JNDI）。而且，J2EE 规范只认可三种类型的事务性资源 — JDBC 数据库、JMS 消息队列服务器和“其它通过 JCA 访问的事务性服务”。后面一种服务（比如 ERP 系统）必须通过 JCA（J2EE Connector Architecture，J2EE 连接器体系结构）访问。对于这些类型资源中的每一种，容器或提供者都会帮我们把资源征调到事务中。
在清单 1 中，con1 和 con2 好象是普通的 JDBC 连接，比如那些从 DriverManager.getConnection() 返回的连接。我们从一个 JDBC DataSource 得到这些连接，JDBC DataSource 可以通过查找 JNDI 中的数据源名称得到。EJB 组件中被用来查找数据源（java:comp/env/OrdersDB）的名称是特定于组件的；组件的部署描述符的 resource-ref 部分将其映射为容器管理的一些应用程序级 DataSource 的 JNDI 名称。
隐藏的 JDBC 驱动器
每个 J2EE 容器都可以创建有事务意识的池态 DataSource 对象，但 J2EE 规范并不向您展示如何创建，因为这不在 J2EE 规范内。浏览 J2EE 文档时，?br&gt;</li>
</ol>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/Java_总结类/">Java_总结类</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/Java_总结类/" class="label label-success">Java_总结类</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:42"datetime="2014-03-07 09:54:42"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-Java_总结类--J2EE学习笔记/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-Java_总结类--J2EE学习笔记" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--通过Java-JMX得到fullGC次数？-高级语言虚拟机/">通过Java</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:42.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--通过Java-JMX得到fullGC次数？-高级语言虚拟机/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-java-jmx-full-gc-">通过Java/JMX得到full GC次数？ - 高级语言虚拟机</h1>
<p><a href="http://hllvm.group.iteye.com/login" title="登录" target="_blank">您还未登录 !</a> <a href="http://hllvm.group.iteye.com/login" target="_blank">登录</a> <a href="http://hllvm.group.iteye.com/signup" target="_blank">注册</a></p>
<p><a href="http://www.iteye.com/" target="_blank"><img src="&quot;ITeye-最棒的软件开发交流社区&quot;" alt="ITeye3.0"></a></p>
<p><a href=""></a></p>
<p><a href="http://www.iteye.com/groups" target="_blank">群组首页</a> → <a href="http://hllvm.group.iteye.com/groups/category/language" target="_blank">编程语言</a> → <a href="http://hllvm.group.iteye.com/" target="_blank">高级语言虚拟机</a> → <a href="http://hllvm.group.iteye.com/group/wiki" target="_blank">知识库</a> → <a href="http://hllvm.group.iteye.com/group/wiki?category_id=315" target="_blank">JVM实战</a> → <a href="">通过Java/JMX得到full GC次数？</a>
原创作者: <a href="http://www.javaeye.com/topic/790015" target="_blank">RednaxelaFX</a>   阅读:2261次   评论:1条   更新时间:2011-05-26    </p>
<p>今天有个同事问如何能通过<a href="http://java.sun.com/javase/technologies/core/mntr-mgmt/javamanagement/" target="_blank">JMX</a>获取到某个Java进程的full GC次数：
引用</p>
<p>hi,问个问题，怎们在java中获取到full gc的次数呢？
我现在用jmx的那个得到了gc次数，不过不能细化出来full gc的次数
Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>for (final GarbageCollectorMXBean garbageCollector  </li>
<li>: ManagementFactory.getGarbageCollectorMXBeans()) {  </li>
<li>gcCounts += garbageCollector.getCollectionCount();  </li>
<li><p>}<br>for (final GarbageCollectorMXBean garbageCollector : ManagementFactory.getGarbageCollectorMXBeans()) { gcCounts += garbageCollector.getCollectionCount(); }
你比如我现在是这样拿次数的
我回答说因为full GC概念只有在分代式GC的上下文中才存在，而JVM并不强制要求GC使用分代式实现，所以JMX提供的标准<a href="http://download-llnw.oracle.com/javase/6/docs/technotes/guides/management/mxbeans.html" target="_blank">MXBean</a> API里不提供“full GC次数”这样的方法也正常。
既然“full GC”本来就是非常平台相关的概念，那就hack一点，用平台相关的代码来解决问题好了。这些GC的MXBean都是有名字的，而主流的JVM的GC名字相对稳定，非要通过JMX得到full GC次数的话，用名字来判断一下就好了。
举个例子来看看。通过JDK 6自带的<a href="http://download-llnw.oracle.com/javase/6/docs/technotes/guides/management/jconsole.html" target="_blank">JConsole</a>工具来查看相关的MXBean的话，可以看到，
GC的MXBean在这个位置：
<img src="&quot;点击查看原始大小图片&quot;" alt="">
这个例子是用server模式启动JConsole的，使用的是ParallelScavenge GC，它的年老代对应的收集器在这里：
<img src="&quot;点击查看原始大小图片&quot;" alt="">
该收集器的总收集次数在此，这也就是full GC的次数：
<img src="&quot;点击查看原始大小图片&quot;" alt="">
于是只要知道我们用的JVM提供的GC MXBean的名字与分代的关系，就可以知道full GC的次数了。
Java代码写起来冗长，这帖就不用Java来写例子了，反正API是一样的，意思能表达清楚就OK。
用一个<a href="http://groovy.codehaus.org/" target="_blank">Groovy</a>脚本简单演示一下适用于Oracle (Sun) HotSpot与Oracle (BEA) JRockit的GC统计程序：
Groovy代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>import java.lang.management.ManagementFactory  </p>
</li>
<li></li>
<li>printGCStats = {  </li>
<li>def youngGenCollectorNames = [  </li>
<li>// Oracle (Sun) HotSpot  </li>
<li>// -XX:+UseSerialGC  </li>
<li>&#39;Copy&#39;,  </li>
<li>// -XX:+UseParNewGC  </li>
<li>&#39;ParNew&#39;,  </li>
<li>// -XX:+UseParallelGC  </li>
<li>&#39;PS Scavenge&#39;,  </li>
<li></li>
<li>// Oracle (BEA) JRockit  </li>
<li>// -XgcPrio:pausetime  </li>
<li>&#39;Garbage collection optimized for short pausetimes Young Collector&#39;,  </li>
<li>// -XgcPrio:throughput  </li>
<li>&#39;Garbage collection optimized for throughput Young Collector&#39;,  </li>
<li>// -XgcPrio:deterministic  </li>
<li>&#39;Garbage collection optimized for deterministic pausetimes Young Collector&#39;  </li>
<li>]  </li>
<li></li>
<li>def oldGenCollectorNames = [  </li>
<li>// Oracle (Sun) HotSpot  </li>
<li>// -XX:+UseSerialGC  </li>
<li>&#39;MarkSweepCompact&#39;,  </li>
<li>// -XX:+UseParallelGC and (-XX:+UseParallelOldGC or -XX:+UseParallelOldGCCompacting)  </li>
<li>&#39;PS MarkSweep&#39;,  </li>
<li>// -XX:+UseConcMarkSweepGC  </li>
<li>&#39;ConcurrentMarkSweep&#39;,  </li>
<li></li>
<li>// Oracle (BEA) JRockit  </li>
<li>// -XgcPrio:pausetime  </li>
<li>&#39;Garbage collection optimized for short pausetimes Old Collector&#39;,  </li>
<li>// -XgcPrio:throughput  </li>
<li>&#39;Garbage collection optimized for throughput Old Collector&#39;,  </li>
<li>// -XgcPrio:deterministic  </li>
<li>&#39;Garbage collection optimized for deterministic pausetimes Old Collector&#39;  </li>
<li>]  </li>
<li></li>
<li>R: {  </li>
<li>ManagementFactory.garbageCollectorMXBeans.each {  </li>
<li>def name  = it.name  </li>
<li>def count = it.collectionCount  </li>
<li>def gcType;  </li>
<li>switch (name) {  </li>
<li>case youngGenCollectorNames:  </li>
<li>gcType = &#39;Minor Collection&#39;  </li>
<li>break  </li>
<li>case oldGenCollectorNames:  </li>
<li>gcType = &#39;Major Collection&#39;  </li>
<li>break  </li>
<li>default:  </li>
<li>gcType = &#39;Unknown Collection Type&#39;  </li>
<li>break  </li>
<li>}  </li>
<li>println &quot;$count &lt;- $gcType: $name&quot;  </li>
<li>}  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li><p>printGCStats()<br>import java.lang.management.ManagementFactory printGCStats = { def youngGenCollectorNames = [ // Oracle (Sun) HotSpot // -XX:+UseSerialGC &#39;Copy&#39;, // -XX:+UseParNewGC &#39;ParNew&#39;, // -XX:+UseParallelGC &#39;PS Scavenge&#39;, // Oracle (BEA) JRockit // -XgcPrio:pausetime &#39;Garbage collection optimized for short pausetimes Young Collector&#39;, // -XgcPrio:throughput &#39;Garbage collection optimized for throughput Young Collector&#39;, // -XgcPrio:deterministic &#39;Garbage collection optimized for deterministic pausetimes Young Collector&#39; ] def oldGenCollectorNames = [ // Oracle (Sun) HotSpot // -XX:+UseSerialGC &#39;MarkSweepCompact&#39;, // -XX:+UseParallelGC and (-XX:+UseParallelOldGC or -XX:+UseParallelOldGCCompacting) &#39;PS MarkSweep&#39;, // -XX:+UseConcMarkSweepGC &#39;ConcurrentMarkSweep&#39;, // Oracle (BEA) JRockit // -XgcPrio:pausetime &#39;Garbage collection optimized for short pausetimes Old Collector&#39;, // -XgcPrio:throughput &#39;Garbage collection optimized for throughput Old Collector&#39;, // -XgcPrio:deterministic &#39;Garbage collection optimized for deterministic pausetimes Old Collector&#39; ] R: { ManagementFactory.garbageCollectorMXBeans.each { def name = it.name def count = it.collectionCount def gcType; switch (name) { case youngGenCollectorNames: gcType = &#39;Minor Collection&#39; break case oldGenCollectorNames: gcType = &#39;Major Collection&#39; break default: gcType = &#39;Unknown Collection Type&#39; break } println &quot;$count &lt;- $gcType: $name&quot; } } } printGCStats()
执行可以看到类似这样的输出：
Command prompt代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>5 &lt;- Minor Collection: Copy  </p>
</li>
<li><p>0 &lt;- Major Collection: MarkSweepCompact<br>5 &lt;- Minor Collection: Copy 0 &lt;- Major Collection: MarkSweepCompact
↑这是用client模式的HotSpot执行得到的；
Command prompt代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>0 &lt;- Minor Collection: Garbage collection optimized for throughput Young Collector  </p>
</li>
<li><p>0 &lt;- Major Collection: Garbage collection optimized for throughput Old Collector<br>0 &lt;- Minor Collection: Garbage collection optimized for throughput Young Collector 0 &lt;- Major Collection: Garbage collection optimized for throughput Old Collector
↑这是用JRockit R28在32位Windows上的默认模式得到的。
通过上述方法，要包装起来方便以后使用的话也很简单，例如下面Groovy程序：
Groovy代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>import java.lang.management.ManagementFactory  </p>
</li>
<li></li>
<li>class GCStats {  </li>
<li>static final List<String> YoungGenCollectorNames = [  </li>
<li>// Oracle (Sun) HotSpot  </li>
<li>// -XX:+UseSerialGC  </li>
<li>&#39;Copy&#39;,  </li>
<li>// -XX:+UseParNewGC  </li>
<li>&#39;ParNew&#39;,  </li>
<li>// -XX:+UseParallelGC  </li>
<li>&#39;PS Scavenge&#39;,  </li>
<li></li>
<li>// Oracle (BEA) JRockit  </li>
<li>// -XgcPrio:pausetime  </li>
<li>&#39;Garbage collection optimized for short pausetimes Young Collector&#39;,  </li>
<li>// -XgcPrio:throughput  </li>
<li>&#39;Garbage collection optimized for throughput Young Collector&#39;,  </li>
<li>// -XgcPrio:deterministic  </li>
<li>&#39;Garbage collection optimized for deterministic pausetimes Young Collector&#39;  </li>
<li>]  </li>
<li></li>
<li>static final List<String> OldGenCollectorNames = [  </li>
<li>// Oracle (Sun) HotSpot  </li>
<li>// -XX:+UseSerialGC  </li>
<li>&#39;MarkSweepCompact&#39;,  </li>
<li>// -XX:+UseParallelGC and (-XX:+UseParallelOldGC or -XX:+UseParallelOldGCCompacting)  </li>
<li>&#39;PS MarkSweep&#39;,  </li>
<li>// -XX:+UseConcMarkSweepGC  </li>
<li>&#39;ConcurrentMarkSweep&#39;,  </li>
<li></li>
<li>// Oracle (BEA) JRockit  </li>
<li>// -XgcPrio:pausetime  </li>
<li>&#39;Garbage collection optimized for short pausetimes Old Collector&#39;,  </li>
<li>// -XgcPrio:throughput  </li>
<li>&#39;Garbage collection optimized for throughput Old Collector&#39;,  </li>
<li>// -XgcPrio:deterministic  </li>
<li>&#39;Garbage collection optimized for deterministic pausetimes Old Collector&#39;  </li>
<li>]  </li>
<li></li>
<li>static int getYoungGCCount() {  </li>
<li>ManagementFactory.garbageCollectorMXBeans.inject(0) { youngGCCount, gc -&gt;  </li>
<li>if (YoungGenCollectorNames.contains(gc.name))  </li>
<li>youngGCCount + gc.collectionCount  </li>
<li>else  </li>
<li>youngGCCount  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>static int getFullGCCount() {  </li>
<li>ManagementFactory.garbageCollectorMXBeans.inject(0) { fullGCCount, gc -&gt;  </li>
<li>if (OldGenCollectorNames.contains(gc.name))  </li>
<li>fullGCCount + gc.collectionCount  </li>
<li>else  </li>
<li>fullGCCount  </li>
<li>}  </li>
<li>}  </li>
<li><p>}<br>import java.lang.management.ManagementFactory class GCStats { static final List<String> YoungGenCollectorNames = [ // Oracle (Sun) HotSpot // -XX:+UseSerialGC &#39;Copy&#39;, // -XX:+UseParNewGC &#39;ParNew&#39;, // -XX:+UseParallelGC &#39;PS Scavenge&#39;, // Oracle (BEA) JRockit // -XgcPrio:pausetime &#39;Garbage collection optimized for short pausetimes Young Collector&#39;, // -XgcPrio:throughput &#39;Garbage collection optimized for throughput Young Collector&#39;, // -XgcPrio:deterministic &#39;Garbage collection optimized for deterministic pausetimes Young Collector&#39; ] static final List<String> OldGenCollectorNames = [ // Oracle (Sun) HotSpot // -XX:+UseSerialGC &#39;MarkSweepCompact&#39;, // -XX:+UseParallelGC and (-XX:+UseParallelOldGC or -XX:+UseParallelOldGCCompacting) &#39;PS MarkSweep&#39;, // -XX:+UseConcMarkSweepGC &#39;ConcurrentMarkSweep&#39;, // Oracle (BEA) JRockit // -XgcPrio:pausetime &#39;Garbage collection optimized for short pausetimes Old Collector&#39;, // -XgcPrio:throughput &#39;Garbage collection optimized for throughput Old Collector&#39;, // -XgcPrio:deterministic &#39;Garbage collection optimized for deterministic pausetimes Old Collector&#39; ] static int getYoungGCCount() { ManagementFactory.garbageCollectorMXBeans.inject(0) { youngGCCount, gc -&gt; if (YoungGenCollectorNames.contains(gc.name)) youngGCCount + gc.collectionCount else youngGCCount } } static int getFullGCCount() { ManagementFactory.garbageCollectorMXBeans.inject(0) { fullGCCount, gc -&gt; if (OldGenCollectorNames.contains(gc.name)) fullGCCount + gc.collectionCount else fullGCCount } } }
用的时候：
Groovysh代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>D:>\sdk\groovy-1.7.2\bin\groovysh  </p>
</li>
<li>Groovy Shell (1.7.2, JVM: 1.6.0_20)  </li>
<li>Type &#39;help&#39; or &#39;\h&#39; for help.  </li>
<li><hr>
</li>
<li>groovy:000&gt; GCStats.fullGCCount  </li>
<li>===&gt; 0  </li>
<li>groovy:000&gt; System.gc()  </li>
<li>===&gt; null  </li>
<li>groovy:000&gt; GCStats.fullGCCount  </li>
<li>===&gt; 1  </li>
<li>groovy:000&gt; System.gc()  </li>
<li>===&gt; null  </li>
<li>groovy:000&gt; System.gc()  </li>
<li>===&gt; null  </li>
<li>groovy:000&gt; GCStats.fullGCCount  </li>
<li>===&gt; 3  </li>
<li>groovy:000&gt; GCStats.youngGCCount  </li>
<li>===&gt; 9  </li>
<li>groovy:000&gt; GCStats.youngGCCount  </li>
<li>===&gt; 9  </li>
<li>groovy:000&gt; GCStats.youngGCCount  </li>
<li>===&gt; 9  </li>
<li>groovy:000&gt; System.gc()  </li>
<li>===&gt; null  </li>
<li>groovy:000&gt; GCStats.youngGCCount  </li>
<li>===&gt; 9  </li>
<li>groovy:000&gt; GCStats.fullGCCount  </li>
<li>===&gt; 4  </li>
<li>groovy:000&gt; quit<br>D:>\sdk\groovy-1.7.2\bin\groovysh Groovy Shell (1.7.2, JVM: 1.6.0_20) Type &#39;help&#39; or &#39;\h&#39; for help. -------------------------------------------------- groovy:000&gt; GCStats.fullGCCount ===&gt; 0 groovy:000&gt; System.gc() ===&gt; null groovy:000&gt; GCStats.fullGCCount ===&gt; 1 groovy:000&gt; System.gc() ===&gt; null groovy:000&gt; System.gc() ===&gt; null groovy:000&gt; GCStats.fullGCCount ===&gt; 3 groovy:000&gt; GCStats.youngGCCount ===&gt; 9 groovy:000&gt; GCStats.youngGCCount ===&gt; 9 groovy:000&gt; GCStats.youngGCCount ===&gt; 9 groovy:000&gt; System.gc() ===&gt; null groovy:000&gt; GCStats.youngGCCount ===&gt; 9 groovy:000&gt; GCStats.fullGCCount ===&gt; 4 groovy:000&gt; quit
这是在Sun JDK 6 update 20上跑的。顺带一提，如果这是跑在JRockit上的话，那full GC的次数就不会增加——因为JRockit里System.gc()默认是触发young GC的；请不要因为Sun HotSpot的默认行为而认为System.gc()总是会触发full GC的。
关于JMX的MXBean的使用，也可以参考下面两篇文档：
<a href="http://docs.codehaus.org/display/GROOVY/Groovy+and+JMX" target="_blank">Groovy and JMX</a>
<a href="http://www.engineyard.com/blog/2010/monitoring-the-jvm-heap-with-jruby/" target="_blank">Monitoring the JVM Heap with JRuby</a>
<a href="http://hllvm.group.iteye.com/group/wiki/3042-JVM-eclipse" title="如何更快的启动eclipse" target="_blank">如何更快的启动eclipse</a></li>
</ol>
<p>评论 共 1 条 请<a href="http://hllvm.group.iteye.com/login" target="_blank">登录</a>后发表评论 <a href=""></a></p>
<h3 id="1-xgj1988-http-xgj1988-iteye-com-xgj1988-2011-04-27-15-07">1 楼 <a href="http://xgj1988.iteye.com/" title="xgj1988" target="_blank">xgj1988</a> 2011-04-27 15:07</h3>
<p>SUN jdk   使用FULL GC 是如下的几种之一？
Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>static final List<String> OldGenCollectorNames = [     </li>
<li>// Oracle (Sun) HotSpot     </li>
<li>// -XX:+UseSerialGC     </li>
<li>&#39;MarkSweepCompact&#39;,     </li>
<li>// -XX:+UseParallelGC and (-XX:+UseParallelOldGC or -XX:+UseParallelOldGCCompacting)     </li>
<li>&#39;PS MarkSweep&#39;,     </li>
<li>// -XX:+UseConcMarkSweepGC     </li>
<li>&#39;ConcurrentMarkSweep&#39;,     </li>
<li></li>
<li><p>]<br>static final List<String> OldGenCollectorNames = [ // Oracle (Sun) HotSpot // -XX:+UseSerialGC &#39;MarkSweepCompact&#39;, // -XX:+UseParallelGC and (-XX:+UseParallelOldGC or -XX:+UseParallelOldGCCompacting) &#39;PS MarkSweep&#39;, // -XX:+UseConcMarkSweepGC &#39;ConcurrentMarkSweep&#39;, ]
这几个是young gc?
Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>&#39;Copy&#39;,     </p>
</li>
<li>// -XX:+UseParNewGC     </li>
<li>&#39;ParNew&#39;,     </li>
<li>// -XX:+UseParallelGC     </li>
<li>&#39;PS Scavenge&#39;,     </li>
<li>&#39;Copy&#39;, // -XX:+UseParNewGC &#39;ParNew&#39;, // -XX:+UseParallelGC &#39;PS Scavenge&#39;,
根据名字判断来获取full gc<img src="" alt=""><h3 id="-">发表评论</h3>
</li>
</ol>
<p><a href="http://hllvm.group.iteye.com/login" target="_blank"><img src="" alt=""> 您还没有登录,请您登录后再发表评论</a></p>
<p><a href="http://hllvm.group.iteye.com/group/wiki/new" target="_blank"><img src="" alt="New-page"></a></p>
<h3 id="-">文章信息</h3>
<p><a href="http://hllvm.group.iteye.com/group/wiki/" target="_blank">知识库: 高级语言虚拟机</a></p>
<ul>
<li>由<a href="http://kiral.iteye.com/" title="fantasy" target="_blank">fantasy</a>在2010-12-16创建</li>
<li><p>由<a href="http://kiral.iteye.com/" title="fantasy" target="_blank">fantasy</a>在2011-05-26更新</p>
<h3 id="-">相关新闻</h3>
</li>
<li><p><a href="http://hllvm.group.iteye.com/news/6318-java-se-6-update-14-early-access-version" target="_blank">Java SE 6 Update 14 Early Access 早期使用版本现已发布</a></p>
</li>
<li><a href="http://hllvm.group.iteye.com/news/4146-jdk-7-in-the-new-garbage-collection-mechanism" target="_blank">JDK 7 中新的垃圾收集机制</a></li>
<li><a href="http://hllvm.group.iteye.com/news/10069" target="_blank">Java 7的新功能和Java 1.5,1.6,1.7的性能测试比较</a></li>
</ul>
<h3 id="-">相关讨论</h3>
<ul>
<li><a href="http://hllvm.group.iteye.com/topic/894148" target="_blank">HotSpot VM 内存堆的两个Servivor区</a></li>
<li><a href="http://hllvm.group.iteye.com/topic/976522" target="_blank">java内存管理以及GC</a></li>
<li><a href="http://hllvm.group.iteye.com/topic/802638" target="_blank">JVM内存管理：深入垃圾收集器与内存分配策略</a></li>
<li><a href="http://hllvm.group.iteye.com/topic/212967" target="_blank">一次Java垃圾收集调优实战</a></li>
<li><p><a href="http://hllvm.group.iteye.com/topic/262541" target="_blank">JVM的GC-生命不能承受之重</a></p>
<h3 id="-">相关博客</h3>
</li>
<li><p><a href="http://rednaxelafx.iteye.com/blog/790015" target="_blank">通过Java/JMX得到full GC次数？</a></p>
</li>
<li><a href="http://millerhu.iteye.com/blog/890724" target="_blank">通过Java/JMX得到full GC次数？</a></li>
<li><a href="http://rednaxelafx.iteye.com/blog/790864" target="_blank">用Java获取full GC的次数？（2）</a></li>
<li><a href="http://tianshibaijia.iteye.com/blog/1343308" target="_blank">常用垃圾收集器在Mbean上的名称</a></li>
<li><a href="http://rednaxelafx.iteye.com/blog/1042471" target="_blank">答复: HotSpot VM 内存堆的两个Survivor区</a></li>
<li><a href="http://www.iteye.com/" target="_blank">首页</a></li>
<li><a href="http://www.iteye.com/news" target="_blank">资讯</a></li>
<li><a href="http://www.iteye.com/magazines" target="_blank">精华</a></li>
<li><a href="http://www.iteye.com/forums" target="_blank">论坛</a></li>
<li><a href="http://www.iteye.com/ask" target="_blank">问答</a></li>
<li><a href="http://www.iteye.com/blogs" target="_blank">博客</a></li>
<li><a href="http://www.iteye.com/blogs/subjects" target="_blank">专栏</a></li>
<li><a href="http://www.iteye.com/groups" target="_blank">群组</a></li>
<li><a href="http://job.iteye.com/iteye" target="_blank">招聘</a></li>
<li><a href="http://www.iteye.com/search" target="_blank">搜索</a></li>
<li><a href="http://hllvm.group.iteye.com/index/service" target="_blank">广告服务</a></li>
<li><a href="http://webmaster.iteye.com/" target="_blank">ITeye黑板报</a></li>
<li><a href="http://hllvm.group.iteye.com/index/contactus" target="_blank">联系我们</a></li>
<li><a href="http://hllvm.group.iteye.com/index/friend_links" target="_blank">友情链接</a></li>
</ul>
<p>© 2003-2012 ITeye.com. [ <a href="http://www.miibeian.gov.cn/" target="_blank">京ICP证110151号</a> 京公网安备110105010620 ]
百联优力(北京)投资有限公司 版权所有 <img src="http://stat.iteye.com/?url=http%3A%2F%2Fhllvm.group.iteye.com%2Fgroup%2Fwiki%2F2950-gc&amp;referrer=&amp;user_id=" alt=""></p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/JVM/">JVM</a></li></span></span> | <span class="tags">Tagged <a href="/tags/JVM/" class="label label-primary">JVM</a><a href="/tags/Java&J2EE/" class="label label-success">Java&J2EE</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:42"datetime="2014-03-07 09:54:42"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-JVM--通过Java-JMX得到fullGC次数？-高级语言虚拟机/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-JVM--通过Java-JMX得到fullGC次数？-高级语言虚拟机" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--请别再拿“StringsnewString-xyz-创建了多少个String实例”来/">请别再拿“String s = new String(</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:42.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--请别再拿“StringsnewString-xyz-创建了多少个String实例”来/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-string-s-new-string-xyz-string-">请别再拿“String s = new String(&quot;xyz&quot;);创建了多少个String实例”来面试了吧</h1>
<p>这帖是用来回复<a href="http://hllvm.group.iteye.com/" target="_blank">高级语言虚拟机</a>圈子里的一个问题，<a href="http://hllvm.group.iteye.com/group/topic/21761" target="_blank">一道Java笔试题</a>的。
本来因为见得太多已经吐槽无力，但这次实在忍不住了就又爆发了一把。写得太长干脆单独开了一帖。
顺带广告：对JVM感兴趣的同学们同志们请多多支持<a href="http://hllvm.group.iteye.com/" target="_blank">高级语言虚拟机</a>圈子 <img src="" alt=""></p>
<h1 id="-">以下是回复内容。文中的“楼主”是针对原问题帖而言。</h1>
<p>楼主是看各种宝典了么……以后我面试人的时候就要专找宝典答案是错的来问，方便筛人orz
楼主要注意了：这题或类似的题虽然经常见，但使用这个描述方式实际上没有任何意义：
引用</p>
<p>问题：</p>
<p>Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>String s = new String(&quot;xyz&quot;);<br>String s = new String(&quot;xyz&quot;);创建了几个String Object？
这个问题自身就没有合理的答案，楼主所引用的“标准答案”自然也就不准确了：
引用</li>
</ol>
<p>答案：两个(一个是“xyz”,一个是指向“xyz”的引用对象s)
（好吧这个答案的吐槽点很多……大家慢慢来）
这问题的毛病是什么呢？它并没有定义“创建了”的意义。
什么叫“创建了”？什么时候创建了什么？
而且这段Java代码片段实际运行的时候真的会“创建两个String实例”么？
如果这道是面试题，那么可以当面让面试官澄清“创建了”的定义，然后再对应的回答。这种时候面试官多半会让被面试者自己解释，那就好办了，好好晒给面试官看。</p>
<h1 id="-">如果是笔试题就没有提问要求澄清的机会了。不过会出这种题目的地方水平多半也不怎么样。说不定出题的人就是从各种宝典上把题抄来的，那就按照宝典把那不大对劲的答案写上去就能混过去了<img src="" alt=""></h1>
<p>先换成另一个问题来问：
引用</p>
<p>问题：</p>
<p>Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>String s = new String(&quot;xyz&quot;);<br>String s = new String(&quot;xyz&quot;);在运行时涉及几个String实例？
一种合理的解答是：
引用</li>
</ol>
<p>答案：两个，一个是字符串字面量&quot;xyz&quot;所对应的、驻留（intern）在一个全局共享的字符串常量池中的实例，另一个是通过new String(String)创建并初始化的、内容与&quot;xyz&quot;相同的实例
这是根据Java语言规范相关规定可以给出的合理答案。考虑到Java语言规范中明确指出了：
The Java Language Specification, Third Edition 写道</p>
<p>The Java programming language is normally compiled to the bytecoded instruction set and binary format defined in <em>The Java Virtual Machine Specification, Second Edition</em> (Addison-Wesley, 1999).
也就是规定了Java语言一般是编译为Java虚拟机规范所定义的Class文件，但并没有规定“一定”（must），留有不使用JVM来实现Java语言的余地。
考虑上Java虚拟机规范，确实在这段代码里涉及的常量种类为<a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html#29297" target="_blank">CONSTANT_String_info</a>的字符串常量也只有&quot;xyz&quot;一个。CONSTANT_String_info是用来表示Java语言中String类型的常量表达式的值（包括字符串字面量）用的常量种类，只在这个层面上考虑的话，这个解答也没问题。
所以这种解答可以认为是合理的。
值得注意的是问题中“在运行时”既包括类加载阶段，也包括这个代码片段自身执行的时候。下文会再讨论这个细节与楼主原本给出的问题的关系。
碰到这种问题首先应该想到去查阅相关的规范，这里具体是<a href="http://java.sun.com/docs/books/jls/" target="_blank">Java语言规范</a>与<a href="http://java.sun.com/docs/books/jvms/" target="_blank">Java虚拟机规范</a>，以及一些相关API的JavaDoc。很多人喜欢把“按道理说”当作口头禅，规范就是用来定义各种“道理”的——“为什么XXX是YYY的意思？”“因为规范里是这样定义的！”——无敌了。
在Java虚拟机规范中相关的定义有下面一些：
The Java Virtual Machine Specification, Second Edition 写道</p>
<p><strong>2.3 Literals</strong>
A literal is the source code representation of a value of a primitive type <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Concepts.doc.html#19511" target="_blank">(§2.4.1)</a>, the String type <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Concepts.doc.html#25486" target="_blank">(§2.4.8)</a>, or the null type <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Concepts.doc.html#22930" target="_blank">(§2.4)</a>. String literals and, more generally, strings that are the values of constant expressions are &quot;interned&quot; so as to share unique instances, using the method String.intern.
The null type has one value, the null reference, denoted by the literal null. The boolean type has two values, denoted by the literals true and false.
<strong>2.4.8 The Class String</strong>
Instances of class String represent sequences of Unicode characters <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Concepts.doc.html#25310" target="_blank">(§2.1)</a>. A String object has a constant, unchanging value. String literals <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Concepts.doc.html#20359" target="_blank">(§2.3)</a> are references to instances of class String.
<strong>2.17.6 Creation of New Class Instances</strong>
A new class instance is explicitly created when one of the following situations occurs:</p>
<ul>
<li>Evaluation of a class instance creation expression creates a new instance of the class whose name appears in the expression.</li>
<li><p>Invocation of the newInstance method of class Class creates a new instance of the class represented by the Class object for which the method was invoked.
A new class instance may be implicitly created in the following situations:</p>
</li>
<li><p>Loading of a class or interface that contains a String literal may create a new String object <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Concepts.doc.html#25486" target="_blank">(§2.4.8)</a> to represent that literal. This may not occur if the a String object has already been created to represent a previous occurrence of that literal, or if the String.intern method has been invoked on a String object representing the same string as the literal.</p>
</li>
<li>Execution of a string concatenation operator that is not part of a constant expression sometimes creates a new String object to represent the result. String concatenation operators may also create temporary wrapper objects for a value of a primitive type <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Concepts.doc.html#19511" target="_blank">(§2.4.1)</a>.
Each of these situations identifies a particular constructor to be called with specified arguments (possibly none) as part of the class instance creation process.
<strong>5.1 The Runtime Constant Pool</strong>
...
● A string literal <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Concepts.doc.html#20359" target="_blank">(§2.3)</a> is derived from a CONSTANT_String_info structure <a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html#29297" target="_blank">(§4.4.3)</a> in the binary representation of a class or interface. The CONSTANT_String_info structure gives the sequence of Unicode characters constituting the string literal.
● The Java programming language requires that identical string literals (that is, literals that contain the same sequence of characters) must refer to the same instance of class String. In addition, if the method String.intern is called on any string, the result is a reference to the same class instance that would be returned if that string appeared as a literal. Thus,
Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></li>
</ul>
<ol>
<li>(&quot;a&quot; + &quot;b&quot; + &quot;c&quot;).intern() == &quot;abc&quot;  </li>
</ol>
<p>(&quot;a&quot; + &quot;b&quot; + &quot;c&quot;).intern() == &quot;abc&quot;
must have the value true.
● To derive a string literal, the Java virtual machine examines the sequence of characters given by the CONSTANT_String_info structure.
  ○ If the method String.intern has previously been called on an instance of class String containing a sequence of Unicode characters identical to that given by the CONSTANT_String_info structure, then the result of string literal derivation is a reference to that same instance of class String.
  ○ Otherwise, a new instance of class String is created containing the sequence of Unicode characters given by the CONSTANT_String_info structure; that class instance is the result of string literal derivation. Finally, the intern method of the new String instance is invoked.
...
The remaining structures in the constant_pool table of the binary representation of a class or interface, the CONSTANT_NameAndType_info <a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html#1327" target="_blank">(§4.4.6)</a> and CONSTANT_Utf8_info <a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html#7963" target="_blank">(§4.4.7)</a> structures are only used indirectly when deriving symbolic references to classes, interfaces, methods, and fields, and when deriving string literals.
把Sun的JDK看作参考实现（reference implementation, RI），其中<a href="http://download.oracle.com/javase/6/docs/api/java/lang/String.html#intern(" target="_blank">String.intern()的JavaDoc</a>)为：
JavaDoc 写道</p>
<p>public String intern()
    Returns a canonical representation for the string object.
    A pool of strings, initially empty, is maintained privately by the class String.
    When the intern method is invoked, if the pool already contains a string equal to this String object as determined by the equals(Object) method, then the string from the pool is returned. Otherwise, this String object is added to the pool and a reference to this String object is returned.
    It follows that for any two strings s and t, s.intern() == t.intern() is true if and only if s.equals(t) is true.
    All literal strings and string-valued constant expressions are interned. String literals are defined in §3.10.5 of the Java Language Specification
    <strong>Returns:</strong></p>
<pre><code>    a string that has the same contents as this string, but is guaranteed to be from a pool of unique strings.
</code></pre><p>===============================================================
再换一个问题来问：
引用</p>
<p>问题：</p>
<p>Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>String s = new String(&quot;xyz&quot;);<br>String s = new String(&quot;xyz&quot;); 涉及用户声明的几个String类型的变量？
答案也很简单：
引用</li>
</ol>
<p>答案：一个，就是String s。
把问题换成下面这个版本，答案也一样：
引用</p>
<p>问题：</p>
<p>Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li><p>String s = null;<br>String s = null; 涉及用户声明的几个String类型的变量？
Java里变量就是变量，引用类型的变量只是对某个对象实例或者null的引用，不是实例本身。声明变量的个数跟创建实例的个数没有必然关系，像是说：
Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>String s1 = &quot;a&quot;;  </p>
</li>
<li>String s2 = s1.concat(&quot;&quot;);  </li>
<li>String s3 = null;  </li>
<li>new String(s1);  </li>
</ol>
<p>String s1 = &quot;a&quot;;</p>
<p>String s2 = s1.concat(&quot;&quot;);
String s3 = null;</p>
<p>new String(s1);
这段代码会涉及3个String类型的变量，
1、s1，指向下面String实例的1
2、s2，指向与s1相同
3、s3，值为null，不指向任何实例
以及3个String实例，
1、&quot;a&quot;字面量对应的驻留的字符串常量的String实例
2、&quot;&quot;字面量对应的驻留的字符串常量的String实例
（<a href="http://download.oracle.com/javase/6/docs/api/java/lang/String.html#concat(java.lang.String" target="_blank">String.concat()</a>)是个有趣的方法，当发现传入的参数是空字符串时会返回this，所以这里不会额外创建新的String实例）</p>
<h1 id="3-new-string-string-string-">3、通过new String(String)创建的新String实例；没有任何变量指向它。</h1>
<p>回到楼主开头引用的问题与“标准答案”
引用</p>
<p>问题：</p>
<p>Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li><p>String s = new String(&quot;xyz&quot;);<br>String s = new String(&quot;xyz&quot;);创建了几个String Object？
答案：两个(一个是“xyz”,一个是指向“xyz”的引用对象s)
用归谬法论证。假定问题问的是“在执行这段代码片段时创建了几个String实例”。如果“标准答案”是正确的，那么下面的代码片段在执行时就应该创建4个String实例了：
Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>String s1 = new String(&quot;xyz&quot;);  </p>
</li>
<li>String s2 = new String(&quot;xyz&quot;);  </li>
</ol>
<p>String s1 = new String(&quot;xyz&quot;);</p>
<p>String s2 = new String(&quot;xyz&quot;);
马上就会有人跳出来说上下两个&quot;xyz&quot;字面量都是引用了同一个String对象，所以不应该是创建了4个对象。
那么应该是多少个？
运行时的类加载过程与实际执行某个代码片段，两者必须分开讨论才有那么点意义。
为了执行问题中的代码片段，其所在的类必然要先被加载，而且同一个类最多只会被加载一次（要注意对JVM来说“同一个类”并不是类的全限定名相同就足够了，而是&lt;类全限定名, 定义类加载器&gt;一对都相同才行）。
根据上文引用的规范的内容，符合规范的JVM实现应该在类加载的过程中创建并驻留一个String实例作为常量来对应&quot;xyz&quot;字面量；具体是在类加载的resolve阶段进行的。这个常量是全局共享的，只在先前尚未有内容相同的字符串驻留过的前提下才需要创建新的String实例。
等到真正执行原问题中的代码片段时，JVM需要执行的字节码类似这样：
Java bytecode代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>0: new  /#2; //class java/lang/String  </li>
<li>3: dup  </li>
<li>4: ldc  /#3; //String xyz  </li>
<li>6: invokespecial    /#4; //Method java/lang/String.&quot;<init>&quot;:(Ljava/lang/String;)V  </li>
<li>9: astore_1  </li>
</ol>
<p>0: new    /#2; //class java/lang/String</p>
<p>3: dup
4: ldc    /#3; //String xyz</p>
<p>6: invokespecial    /#4; //Method java/lang/String.&quot;<init>&quot;:(Ljava/lang/String;)V
9: astore_1
这之中出现过多少次new java/lang/String就是创建了多少个String对象。也就是说原问题中的代码在每执行一次只会新创建一个String实例。
这里，ldc指令只是把先前在类加载过程中已经创建好的一个String对象（&quot;xyz&quot;）的一个引用压到操作数栈顶而已，并不新创建String对象。
所以刚才用于归谬的代码片段：
Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>String s1 = new String(&quot;xyz&quot;);  </li>
<li>String s2 = new String(&quot;xyz&quot;);  </li>
</ol>
<p>String s1 = new String(&quot;xyz&quot;);</p>
<p>String s2 = new String(&quot;xyz&quot;);</p>
<h2 id="-2-string-">每执行一次只会新创建2个String实例。</h2>
<p>为了避免一些同学犯糊涂，再强调一次：
在Java语言里，“new”表达式是负责创建实例的，其中会调用构造器去对实例做初始化；构造器自身的返回值类型是void，并不是“构造器返回了新创建的对象的引用”，而是new表达式的值是新创建的对象的引用。
对应的，在JVM里，“new”字节码指令只负责把实例创建出来（包括分配空间、设定类型、所有字段设置默认值等工作），并且把指向新创建对象的引用压到操作数栈顶。此时该引用还不能直接使用，处于未初始化状态（uninitialized）；如果某方法a含有代码试图通过未初始化状态的引用来调用任何实例方法，那么方法a会通不过JVM的字节码校验，从而被JVM拒绝执行。
能对未初始化状态的引用做的唯一一种事情就是通过它调用实例构造器，在Class文件层面表现为特殊初始化方法“<init>”。实际调用的指令是invokespecial，而在实际调用前要把需要的参数按顺序压到操作数栈上。在上面的字节码例子中，压参数的指令包括dup和ldc两条，分别把隐藏参数（新创建的实例的引用，对于实例构造器来说就是“this”）与显式声明的第一个实际参数（&quot;xyz&quot;常量的引用）压到操作数栈上。
在构造器返回之后，新创建的实例的引用就可以正常使用了。</p>
<h1 id="-http-rednaxelafx-iteye-com-blog-652719-">关于构造器的讨论，可以参考我之前的一帖，<a href="http://rednaxelafx.iteye.com/blog/652719" target="_blank">实例构造器是不是静态方法？</a></h1>
<p>以上讨论都只是针对规范所定义的Java语言与Java虚拟机而言。概念上是如此，但实际的JVM实现可以做得更优化，原问题中的代码片段有可能在实际执行的时候一个String实例也不会完整创建（没有分配空间）。
例如说，在x86、Windows Vista SP2、Sun JDK 6 update 14的fastdebug版上跑下面的测试代码：
Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>public class C2EscapeAnalysisDemo {  </li>
<li>private static void warmUp() {  </li>
<li>IFoo[] array = new IFoo[] {  </li>
<li>new FooA(), new FooB(), new FooC(), new FooD()  </li>
<li>};  </li>
<li>for (int i = 0; i &lt; 1000000; i++) {  </li>
<li>array[i % array.length].foo(); // megamorphic callsite to prevent inlining  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>public static void main(String[] args) {  </li>
<li>while (true) {  </li>
<li>warmUp();  </li>
<li>}  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>interface IFoo {  </li>
<li>void foo();  </li>
<li>}  </li>
<li></li>
<li>class FooA implements IFoo {  </li>
<li>public void foo() {  </li>
<li>String s1 = new String(&quot;xyz&quot;);  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>class FooB implements IFoo {  </li>
<li>public void foo() {  </li>
<li>String s1 = new String(&quot;xyz&quot;);  </li>
<li>String s2 = new String(&quot;xyz&quot;);  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>class FooC implements IFoo {  </li>
<li>public void foo() {  </li>
<li>String s1 = new String(&quot;xyz&quot;);  </li>
<li>String s2 = new String(&quot;xyz&quot;);  </li>
<li>String s3 = new String(&quot;xyz&quot;);  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>class FooD implements IFoo {  </li>
<li>public void foo() {  </li>
<li>String s1 = new String(&quot;xyz&quot;);  </li>
<li>String s2 = new String(&quot;xyz&quot;);  </li>
<li>String s3 = new String(&quot;xyz&quot;);  </li>
<li>String s4 = new String(&quot;xyz&quot;);  </li>
<li>}  </li>
<li>}  </li>
</ol>
<p>public class C2EscapeAnalysisDemo {</p>
<p>  private static void warmUp() {
    IFoo[] array = new IFoo[] {</p>
<pre><code>  new FooA(), new FooB(), new FooC(), new FooD()
};

for (int i = 0; i &lt; 1000000; i++) {
  array[i % array.length].foo(); // megamorphic callsite to prevent inlining

}
</code></pre><p>  }</p>
<p>  public static void main(String[] args) {</p>
<pre><code>while (true) {
  warmUp();

}
</code></pre><p>  }</p>
<p>}</p>
<p>interface IFoo {
  void foo();</p>
<p>}</p>
<p>class FooA implements IFoo {
  public void foo() {</p>
<pre><code>String s1 = new String(&quot;xyz&quot;);
</code></pre><p>  }</p>
<p>}</p>
<p>class FooB implements IFoo {
  public void foo() {</p>
<pre><code>String s1 = new String(&quot;xyz&quot;);
String s2 = new String(&quot;xyz&quot;);
</code></pre><p>  }
}</p>
<p>class FooC implements IFoo {</p>
<p>  public void foo() {
    String s1 = new String(&quot;xyz&quot;);</p>
<pre><code>String s2 = new String(&quot;xyz&quot;);
String s3 = new String(&quot;xyz&quot;);
</code></pre><p>  }
}</p>
<p>class FooD implements IFoo {</p>
<p>  public void foo() {
    String s1 = new String(&quot;xyz&quot;);</p>
<pre><code>String s2 = new String(&quot;xyz&quot;);
String s3 = new String(&quot;xyz&quot;);

String s4 = new String(&quot;xyz&quot;);
</code></pre><p>  }</p>
<p>}
照常用javac用默认参数编译，然后先用server模式的默认配置来跑，顺带打出GC和JIT编译日志来看
Command prompt代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>java -server -verbose:gc -XX:+PrintCompilation C2EscapeAnalysisDemo  </li>
</ol>
<p>java -server -verbose:gc -XX:+PrintCompilation C2EscapeAnalysisDemo
看到的日志的开头一段如下：
Hotspot log代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>1       java.lang.String::charAt (33 bytes)  </li>
<li>2       java.lang.Object::<init> (1 bytes)  </li>
<li>3       java.lang.String::<init> (61 bytes)  </li>
<li>1%      C2EscapeAnalysisDemo::warmUp @ 47 (71 bytes)  </li>
<li>4       FooA::foo (11 bytes)  </li>
<li>5       FooB::foo (21 bytes)  </li>
<li>6       FooC::foo (31 bytes)  </li>
<li>7       FooD::foo (42 bytes)  </li>
<li>[GC 3072K-&gt;168K(32768K), 0.0058325 secs]  </li>
<li>[GC 3240K-&gt;160K(32768K), 0.0104623 secs]  </li>
<li>[GC 3232K-&gt;160K(32768K), 0.0027323 secs]  </li>
<li>[GC 3232K-&gt;160K(35840K), 0.0026220 secs]  </li>
<li>[GC 6304K-&gt;160K(35840K), 0.0173733 secs]  </li>
<li>[GC 6304K-&gt;144K(41664K), 0.0059720 secs]  </li>
<li>[GC 12432K-&gt;144K(41664K), 0.0353320 secs]  </li>
<li>[GC 12432K-&gt;144K(54016K), 0.0139333 secs]  </li>
<li>8       C2EscapeAnalysisDemo::warmUp (71 bytes)  </li>
<li>[GC 24720K-&gt;160K(54016K), 0.0697970 secs]  </li>
<li>[GC 24736K-&gt;160K(68800K), 0.0261921 secs]  </li>
<li>[GC 39520K-&gt;160K(68800K), 0.0958433 secs]  </li>
<li>[GC 39520K-&gt;160K(87168K), 0.0433377 secs]  </li>
<li>[GC 57888K-&gt;160K(87168K), 0.0542482 secs]  </li>
<li>[GC 57888K-&gt;148K(87168K), 0.0533140 secs]  </li>
<li>[GC 57876K-&gt;164K(84288K), 0.0533537 secs]  </li>
<li>[GC 55204K-&gt;164K(81728K), 0.0596820 secs]  </li>
<li>[GC 52644K-&gt;164K(79488K), 0.0515090 secs]  </li>
<li>[GC 50212K-&gt;164K(76992K), 0.0491227 secs]  </li>
<li>[GC 47908K-&gt;164K(74944K), 0.0450666 secs]  </li>
<li>[GC 45668K-&gt;164K(72640K), 0.0467671 secs]  </li>
<li>[GC 43556K-&gt;152K(70784K), 0.0420757 secs]  </li>
<li>[GC 41560K-&gt;168K(68736K), 0.0391296 secs]  </li>
<li>[GC 39656K-&gt;168K(67072K), 0.0397539 secs]  </li>
<li><p>[GC 37864K-&gt;188K(65216K), 0.0360861 secs]  </p>
<p>1       java.lang.String::charAt (33 bytes)</p>
<p>2       java.lang.Object::<init> (1 bytes)
3       java.lang.String::<init> (61 bytes)</p>
<p>1%      C2EscapeAnalysisDemo::warmUp @ 47 (71 bytes)
4       FooA::foo (11 bytes)</p>
<p>5       FooB::foo (21 bytes)
6       FooC::foo (31 bytes)</p>
<p>7       FooD::foo (42 bytes)
[GC 3072K-&gt;168K(32768K), 0.0058325 secs]</p>
</li>
</ol>
<p>[GC 3240K-&gt;160K(32768K), 0.0104623 secs]
[GC 3232K-&gt;160K(32768K), 0.0027323 secs]</p>
<p>[GC 3232K-&gt;160K(35840K), 0.0026220 secs]
[GC 6304K-&gt;160K(35840K), 0.0173733 secs]</p>
<p>[GC 6304K-&gt;144K(41664K), 0.0059720 secs]
[GC 12432K-&gt;144K(41664K), 0.0353320 secs]</p>
<p>[GC 12432K-&gt;144K(54016K), 0.0139333 secs]
  8       C2EscapeAnalysisDemo::warmUp (71 bytes)</p>
<p>[GC 24720K-&gt;160K(54016K), 0.0697970 secs]
[GC 24736K-&gt;160K(68800K), 0.0261921 secs]</p>
<p>[GC 39520K-&gt;160K(68800K), 0.0958433 secs]
[GC 39520K-&gt;160K(87168K), 0.0433377 secs]</p>
<p>[GC 57888K-&gt;160K(87168K), 0.0542482 secs]
[GC 57888K-&gt;148K(87168K), 0.0533140 secs]</p>
<p>[GC 57876K-&gt;164K(84288K), 0.0533537 secs]
[GC 55204K-&gt;164K(81728K), 0.0596820 secs]</p>
<p>[GC 52644K-&gt;164K(79488K), 0.0515090 secs]
[GC 50212K-&gt;164K(76992K), 0.0491227 secs]</p>
<p>[GC 47908K-&gt;164K(74944K), 0.0450666 secs]
[GC 45668K-&gt;164K(72640K), 0.0467671 secs]</p>
<p>[GC 43556K-&gt;152K(70784K), 0.0420757 secs]
[GC 41560K-&gt;168K(68736K), 0.0391296 secs]</p>
<p>[GC 39656K-&gt;168K(67072K), 0.0397539 secs]
[GC 37864K-&gt;188K(65216K), 0.0360861 secs]
上面的日志中，后面的方法名的行是JIT编译的日志，而以<a href="&quot;复制代码&quot;">GC开头的是minor GC的日志。
程序一直跑，GC的日志还会不断的打出来。这是理所当然的对吧？HotSpot的堆就那么大，而测试代码在不断新创建String对象，肯定得不断触发GC的。
用不同的VM启动参数来跑的话，
Command prompt代码 [<img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>java -server -verbose:gc -XX:+PrintCompilation -XX:+DoEscapeAnalysis -XX:+EliminateAllocations C2EscapeAnalysisDemo  </li>
</ol>
<p>java -server -verbose:gc -XX:+PrintCompilation -XX:+DoEscapeAnalysis -XX:+EliminateAllocations C2EscapeAnalysisDemo
还是同样的Java测试程序，同样的Sun JDK 6 update 14，但打开了逃逸分析和空间分配消除功能，再运行，看到的全部日志如下：
Hotspot log代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>1       java.lang.String::charAt (33 bytes)  </li>
<li>2       java.lang.Object::<init> (1 bytes)  </li>
<li>3       java.lang.String::<init> (61 bytes)  </li>
<li>1%      C2EscapeAnalysisDemo::warmUp @ 47 (71 bytes)  </li>
<li>5       FooB::foo (21 bytes)  </li>
<li>4       FooA::foo (11 bytes)  </li>
<li>6       FooC::foo (31 bytes)  </li>
<li>7       FooD::foo (42 bytes)  </li>
<li>[GC 3072K-&gt;176K(32768K), 0.0056527 secs]  </li>
<li><p>8       C2EscapeAnalysisDemo::warmUp (71 bytes)  </p>
<p>1       java.lang.String::charAt (33 bytes)</p>
<p>2       java.lang.Object::<init> (1 bytes)
3       java.lang.String::<init> (61 bytes)</p>
<p>1%      C2EscapeAnalysisDemo::warmUp @ 47 (71 bytes)
5       FooB::foo (21 bytes)</p>
<p>4       FooA::foo (11 bytes)
6       FooC::foo (31 bytes)</p>
<p>7       FooD::foo (42 bytes)
[GC 3072K-&gt;176K(32768K), 0.0056527 secs]</p>
<p>8       C2EscapeAnalysisDemo::warmUp (71 bytes)
继续跑下去也没有再打出GC日志了。难道新创建String对象都不吃内存了么？
实际情况是：经过HotSpot的server模式编译器的优化后，FooA、FooB、FooC、FooD四个版本的foo()实现都不新创建String实例了。这样自然不吃内存，也就不再触发GC了。
经过的分析和优化笼统说有方法内联（method inlining）、逃逸分析（escape analysis）、标量替换（scalar replacement）、无用代码削除（dead-code elimination）之类。
FooA.foo()最短，就以它举例来大致演示一下优化的过程。
它其实就是创建并初始化了一个String对象而已。调用的构造器的源码是：
Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>public String(String original) {  </p>
</li>
<li>int size = original.count;  </li>
<li>char[] originalValue = original.value;  </li>
<li>char[] v;  </li>
<li>if (originalValue.length &gt; size) {  </li>
<li>// The array representing the String is bigger than the new  </li>
<li>// String itself.  Perhaps this constructor is being called  </li>
<li>// in order to trim the baggage, so make a copy of the array.  </li>
<li>int off = original.offset;  </li>
<li>v = Arrays.copyOfRange(originalValue, off, off+size);  </li>
<li>} else {  </li>
<li>// The array representing the String is the same  </li>
<li>// size as the String, so no point in making a copy.  </li>
<li>v = originalValue;  </li>
<li>}  </li>
<li>this.offset = 0;  </li>
<li>this.count = size;  </li>
<li>this.value = v;  </li>
<li>}  </li>
</ol>
<p>public String(String original) {</p>
<pre><code>int size = original.count;
char[] originalValue = original.value;

char[] v;
if (originalValue.length &gt; size) {

   // The array representing the String is bigger than the new
   // String itself.  Perhaps this constructor is being called

   // in order to trim the baggage, so make a copy of the array.
  int off = original.offset;

  v = Arrays.copyOfRange(originalValue, off, off+size);
} else {

   // The array representing the String is the same
   // size as the String, so no point in making a copy.

  v = originalValue;
}

this.offset = 0;
this.count = size;

this.value = v;
</code></pre><p>}
因为参数是&quot;xyz&quot;，可以确定在我们的测试代码里不会走到构造器的if分支里，下面为了演示方便就省略掉那部分代码（实际代码还是存在的，只是没执行而已）
Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>public String(String original) {  </li>
<li>int size = original.count;  </li>
<li>char[] originalValue = original.value;  </li>
<li>char[] v;  </li>
<li>if (originalValue.length &gt; size) {  </li>
<li>// 省略  </li>
<li>} else {  </li>
<li>v = originalValue;  </li>
<li>}  </li>
<li>this.offset = 0;  </li>
<li>this.count = size;  </li>
<li>this.value = v;  </li>
<li>}  </li>
</ol>
<p>public String(String original) {</p>
<pre><code>int size = original.count;
char[] originalValue = original.value;

char[] v;
if (originalValue.length &gt; size) {

   // 省略
} else {

  v = originalValue;
}

this.offset = 0;
this.count = size;

this.value = v;
</code></pre><p>}
那么把构造器内联到FooA.foo()里，
Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>public FooA implements IFoo {  </li>
<li>public void foo() {  </li>
<li>String s = AllocateString(); // 这里虚构一个只分配空间，不调用构造器的函数  </li>
<li>String original = &quot;xyz&quot;;  </li>
<li></li>
<li>// 下面就是内联进来的构造器内容  </li>
<li>int size = original.count;  </li>
<li>char[] originalValue = original.value;  </li>
<li>char[] v;  </li>
<li>if (originalValue.length &gt; size) {  </li>
<li>// 省略  </li>
<li>} else {  </li>
<li>v = originalValue;  </li>
<li>}  </li>
<li></li>
<li>s.offset = 0;  </li>
<li>s.count = size;  </li>
<li>s.value = v;  </li>
<li>}  </li>
<li>}  </li>
</ol>
<p>public FooA implements IFoo {</p>
<p>  public void foo() {
    String s = AllocateString(); // 这里虚构一个只分配空间，不调用构造器的函数</p>
<pre><code>String original = &quot;xyz&quot;;


// 下面就是内联进来的构造器内容
int size = original.count;

char[] originalValue = original.value;
char[] v;

if (originalValue.length &gt; size) {
   // 省略

} else {
  v = originalValue;

}


s.offset = 0;
s.count = size;

s.value = v;
</code></pre><p>  }</p>
<p>}
然后经过逃逸分析与标量替换，
Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>public FooA implements IFoo {  </li>
<li>public void foo() {  </li>
<li>String original = &quot;xyz&quot;;  </li>
<li></li>
<li>// 下面就是内联进来的构造器内容  </li>
<li>int size = original.count;  </li>
<li>char[] originalValue = original.value;  </li>
<li>char[] v;  </li>
<li>if (originalValue.length &gt; size) {  </li>
<li>// 省略  </li>
<li>} else {  </li>
<li>v = originalValue;  </li>
<li>}  </li>
<li></li>
<li>// 原本s的实例变量被标量替换为foo()的局部变量  </li>
<li>int sOffset = 0;  </li>
<li>int sCount = size;  </li>
<li>char[] sValue = v;  </li>
<li>}  </li>
<li>}  </li>
</ol>
<p>public FooA implements IFoo {</p>
<p>  public void foo() {
    String original = &quot;xyz&quot;;</p>
<pre><code>// 下面就是内联进来的构造器内容

int size = original.count;
char[] originalValue = original.value;

char[] v;
if (originalValue.length &gt; size) {

   // 省略
} else {

  v = originalValue;
}


// 原本s的实例变量被标量替换为foo()的局部变量

int sOffset = 0;
int sCount = size;

char[] sValue = v;
</code></pre><p>  }</p>
<p>}
注意，到这里就已经把新创建String在堆上分配空间的代码全部削除了，原本新建的String实例的字段变成了FooA.foo()的局部变量。
最后再经过无用代码削除，把sOffset、sCount和sValue这三个没被读过的局部变量给削除掉，
Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>public FooA implements IFoo {  </li>
<li>public void foo() {  </li>
<li>String original = &quot;xyz&quot;;  </li>
<li></li>
<li>// 下面就是内联进来的构造器内容  </li>
<li>int size = original.count;  </li>
<li>char[] originalValue = original.value;  </li>
<li>char[] v;  </li>
<li>if (originalValue.length &gt; size) {  </li>
<li>// 省略  </li>
<li>} else {  </li>
<li>v = originalValue;  </li>
<li>}  </li>
<li></li>
<li>// 几个局部变量也干掉了  </li>
<li>}  </li>
<li>}  </li>
</ol>
<p>public FooA implements IFoo {</p>
<p>  public void foo() {
    String original = &quot;xyz&quot;;</p>
<pre><code>// 下面就是内联进来的构造器内容

int size = original.count;
char[] originalValue = original.value;

char[] v;
if (originalValue.length &gt; size) {

   // 省略
} else {

  v = originalValue;
}


// 几个局部变量也干掉了
</code></pre><p>  }
}
这就跟FooA.foo()被优化编译后实际执行的代码基本一致了。
实际执行的x86代码如下：
X86 asm代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>0x0247aeec: mov    %eax,-0x4000(%esp) ; 检查栈是否溢出（stack bang），若溢出则这条指令会引发异常  </li>
<li>0x0247aef3: push   %ebp               ; 保存老的栈帧指针  </li>
<li>0x0247aef4: sub    $0x18,%esp         ; 为新栈帧分配空间  </li>
<li>0x0247aefa: mov    $0x1027e9a8,%edi   ; String original //<em> EDI /</em>/ = &quot;xyz&quot;  </li>
<li>0x0247aeff: mov    0x8(%edi),%ecx     ; char[] originalValue //<em> ECX /</em>/ = original.value;  </li>
<li>0x0247af02: mov    0x8(%ecx),%ebx     ; EBX = originalValue.length  </li>
<li>0x0247af05: mov    0x10(%edi),%ebp    ; int size //<em> EBP /</em>/ = original.count;  </li>
<li>0x0247af08: cmp    %ebp,%ebx          ; 比较originalValue.length与size  </li>
<li>0x0247af0a: jg     0x0247af17         ; 如果originalValue.length &gt; size则跳转到0x0247af17  </li>
<li>;   实际不会发生跳转（就是不会执行if分支），所以后面代码省略  </li>
<li>0x0247af0c: add    $0x18,%esp         ; 撤销栈帧分配的空间  </li>
<li>0x0247af0f: pop    %ebp               ; 恢复老的栈帧指针  </li>
<li>0x0247af10: test   %eax,0x310000      ; 方法返回前检查是否需要进入safepoint （{poll_return}）  </li>
<li>0x0247af16: ret                       ; 方法返回  </li>
<li>0x0247af17: ; 以下是if分支和异常处理器的代码，因为实际不会执行，省略  </li>
</ol>
<p>0x0247aeec: mov    %eax,-0x4000(%esp) ; 检查栈是否溢出（stack bang），若溢出则这条指令会引发异常</p>
<p>0x0247aef3: push   %ebp               ; 保存老的栈帧指针
0x0247aef4: sub    $0x18,%esp         ; 为新栈帧分配空间</p>
<p>0x0247aefa: mov    $0x1027e9a8,%edi   ; String original //<em> EDI /</em>/ = &quot;xyz&quot;
0x0247aeff: mov    0x8(%edi),%ecx     ; char[] originalValue //<em> ECX /</em>/ = original.value;</p>
<p>0x0247af02: mov    0x8(%ecx),%ebx     ; EBX = originalValue.length
0x0247af05: mov    0x10(%edi),%ebp    ; int size //<em> EBP /</em>/ = original.count;</p>
<p>0x0247af08: cmp    %ebp,%ebx          ; 比较originalValue.length与size
0x0247af0a: jg     0x0247af17         ; 如果originalValue.length &gt; size则跳转到0x0247af17</p>
<pre><code>                                  ;   实际不会发生跳转（就是不会执行if分支），所以后面代码省略
</code></pre><p>0x0247af0c: add    $0x18,%esp         ; 撤销栈帧分配的空间</p>
<p>0x0247af0f: pop    %ebp               ; 恢复老的栈帧指针
0x0247af10: test   %eax,0x310000      ; 方法返回前检查是否需要进入safepoint （{poll_return}）</p>
<p>0x0247af16: ret                       ; 方法返回
0x0247af17: ; 以下是if分支和异常处理器的代码，因为实际不会执行，省略
看，确实没有新创建String对象了。
另外三个版本的foo()实现也是类似，HotSpot成功的把无用的new String(&quot;xyz&quot;)全部干掉了。
关于逃逸分析的例子，可以参考我以前一篇帖，<a href="http://rednaxelafx.iteye.com/blog/659108" target="_blank">HotSpot 17.0-b12的逃逸分析/标量替换的一个演示</a></p>
<h1 id="-fooa-foo-string-">再回头看看楼主的原问题，问题中的代码片段执行的时候（对应到FooA.foo()被调用的时候）一个String对象也没有新建。于是那“标准答案”在现实中的指导意义又有多少呢？</h1>
<p>另外，楼主还提到了PermGen：
QM42977 写道</p>
<p>&quot;xyz&quot;在perm gen应该还会生成一个对象，因为常量(&quot;xyz&quot;)都会保存在perm gen中
这里也是需要强调一点：永生代（“Perm Gen”）只是Sun JDK的一个实现细节而已，Java语言规范和Java虚拟机规范都没有规定必须有“Permanent Generation”这么一块空间，甚至没规定要用什么GC算法——不用分代式GC算法哪儿来的“永生代”？
HotSpot的PermGen是用来实现Java虚拟机规范中的“<strong>方法区</strong>”（method area）的。如果使用“方法区”这个术语，在讨论概念中的JVM时就安全得多——大家都必须实现出这个表象。
当然如何实现又是另一回事了。Oracle JRockit没有PermGen，IBM J9也没有，事实上有这么一块空间特别管理的反而是少数吧orz
事实上新版HotSpot VM也在计划去除PermGen，转而使用native memory来实现方法区存储元数据。在JDK8的HotSpot VM中已经实现了这点。</p>
<h1 id="-http-rednaxelafx-iteye-com-blog-905273-http-rednaxelafx-iteye-com-blog-905273-">可以参考这帖：<a href="http://rednaxelafx.iteye.com/blog/905273" target="_blank"><a href="http://rednaxelafx.iteye.com/blog/905273">http://rednaxelafx.iteye.com/blog/905273</a></a></h1>
<p>费那么多口舌，最后点题：请别再拿“String s = new String(&quot;xyz&quot;);创建了多少个String实例”来面试了吧，既没意义又不涨面子。
困，睡觉去……<img src="" alt=""></p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/JVM/">JVM</a></li></span></span> | <span class="tags">Tagged <a href="/tags/JVM/" class="label label-primary">JVM</a><a href="/tags/Java&J2EE/" class="label label-success">Java&J2EE</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:42"datetime="2014-03-07 09:54:42"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-JVM--请别再拿“StringsnewString-xyz-创建了多少个String实例”来/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-JVM--请别再拿“StringsnewString-xyz-创建了多少个String实例”来" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--豆列：从表到里学习JVM实现/">豆列：从表到里学习JVM实现</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:42.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--豆列：从表到里学习JVM实现/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-jvm-">豆列：从表到里学习JVM实现</h1>
<p>刚写了个学习JVM用的豆列跟大家分享。
豆列地址：<a href="http://book.douban.com/doulist/2545443/" target="_blank"><a href="http://book.douban.com/doulist/2545443/">http://book.douban.com/doulist/2545443/</a></a>
下面把豆列的介绍贴过来。具体书单请到上面的豆列地址那边去看。
在社会化分工、软件行业细分专业化的趋势下，会真的参与到底层系统实现的人肯定是越来越少（比例上说）。真的会参与到JVM实现的人肯定是少数。
但如果您对JVM是如何实现的有兴趣、充满好奇，却苦于没有足够系统的知识去深入，那么这个豆列就是为您打好基础而准备的。
如果只想用用Java用用JVM，对深入到实现细节无甚兴趣的话，这个豆列就请不必参考了，免得浪费钱浪费时间精力，呵呵 :-)
本豆列的脉络是：</p>
<ol>
<li>JVM与Java语言规范
要了解JVM是如何实现的，首先必须要知道JVM到底是什么、不是什么，表面上应该提供怎样的功能。为此，JVM规范必读，而且应该时常放在手边参考。
而JVM的主要服务对象是Java编程语言。虽然JVM也可以支持众多其它语言，但JVM里的“J”仍然最重要，Java的语言特性影响了JVM的原始设计，所以Java语言规范也应该阅读。特别是，JVM关于线程和同步相关的规定都是交由Java语言规范的相关章节定义的。</li>
<li>虚拟机概论
这里选取《Virtual Machines: Versatile Platforms for Systems and Processes》，帮助您了解“虚拟机”一词到底指代什么，有什么不同类型，大概有哪些实现方法，等等。读完这本书有助获得一个清晰的大局观。</li>
<li>为Java程序员从用户的角度介绍JVM的使用经验的几本书
虽然这几本并没有深入到JVM实现的非常细节的角落，但对已经习惯用Java语言编程的程序员来说，有这么几本书带领自己从熟悉的领域进入不熟悉的领域总是件好事。
这几本书中，最深入JVM内部的是《Oracle JRockit: The Definitive Guide》；有丰富调优建议的是《Java Performance》；结合实现大概介绍JVM的抽象概念的是周志明的《深入理解Java虚拟机》。</li>
<li>虚拟机的入门级实现
先通过《Language Implementation Patterns》了解编程语言的一些入门级实现方式，把高级语言编译器与虚拟机两个概念联系起来。
然后通过《プログラミング言語を作る》了解非常简易的、用树遍历式以及字节码式解释器实现虚拟机大概是个怎么回事。虽然这本书没有实现JVM，但它介绍的Diksam与早期JVM的实现颇有相似之处，可参考。
接下来《深入嵌入式Java虚拟机》介绍了一种实际的JVM——KVM的实现细节。KVM是CLDC的参考实现（RI）里的JVM，结构简单，资源消耗小，适合入门阅读。
这部分最后是《The School of Niklaus Wirth》，里面有一章介绍了HotSpot Client Compiler (C1)的原始设计思路。这是个非常简单、但相对来说性能还不错的JIT编译器，可用于对JIT编译器的基本了解。这本书本身就很赞，不为学习虚拟机也可以一读。
需要注意的是从“简易的JVM实现”到“高性能、复杂的JVM实现”跨度非常大；前者的许多部分的实现方式与后者相当不同。先从简易的实现开始入手主要是为了对JVM里大概都有些什么组件有所了解。但如果目标是了解高性能JVM的实现，那就必须在GC、编译原理方面打下更好的基础，重新洗一次脑。</li>
<li>C++基础书
下面要开始逐渐深入JVM的内部实现，如果没有良好的C或（与？）C++基础会比较吃力。虽然也有几乎完全用Java语言实现的高性能JVM，例如Maxine VM与Jikes RVM，但它们都是研究性质的；商用JVM实现仍然是C与C++的天下。
这里我先推荐C++之父自己写的那本书来入门。虽然BS巨巨后来还出过本新书，而近来也渐渐开始有介绍C++11的入门书，但实际上现在多数JVM实现用的还是C99或非常古老的C++（连C++03都不一定用到了），所以用这本老书应该就够了。
然后通过《深度探索C++对象模型》来学习C++对象模型的常见实现方式。这对后面理解Java对象模型的实现很有帮助。</li>
<li>GC与编译原理的入门书
GC书总共就那么几本，倒也没啥可挑的。《The Garbage Collection Handbook》是绝对必读。
编译原理的书就稍微尴尬些。现有的编译原理书大都针对静态编译器、针对像C或C++那样的偏静态、偏native的语言。我还没读到过什么编译原理书是专门介绍JIT编译器或者说动态编译器的。静态与动态编译器会有些取舍上、实现策略上的差异，不过还好其核心的原理都是一样的，所以还是可以推荐几本书。龙书用来最初入门，鲸书用来补充一些优化相关的知识，EAC第二版用来学习编译器一种比较良好的逻辑组织方式，最后学一下针对现代机器的优化。</li>
<li>介绍计算机体系结构的书
实际JVM实现里，如果有JIT编译器或者动态编译器那它们的编译目标多半是底层机器的机器码。这就涉及到计算机体系结构了。
如果您只对Java语言和抽象的JVM有一定了解，那可以用《计算机组成及汇编语言原理》来入门。这本书比较奇葩，用JVM的字节码指令集来当作真实机器介绍体系结构的概念。我并不太喜欢这本书，但感觉它对有Java背景的初学者来说应该有点用。要注意的是千万别只读这本书来入门，请结合下面要介绍的一本书来重新洗一次脑。
如果对C或C++已经有所了解，那《深入理解计算机系统》（CSAPP）是计算机体系结构入门的最适合的书了。</li>
<li>进一步阅读
到此为止各种抽象概念应该都了解得差不多了。那么要在真实的机器上实现高性能JVM，就必须要对真实机器的指令集细节有所了解。x86/x86-64、SPARC、ARM、MIPS，要在哪个平台上做高性能实现就要学习哪个平台的指令集及指令级别优化技巧。这里就不具体推荐书了。
操作系统层面的知识同样重要。像是说JVM要实现线程、内存分配啥的，都可能要跟系统调用或CRT对系统调用的包装打交道。这部分也需要另外找书来读。我回头再考虑下要不要加几本道这个豆列里来。
另外，从80年代开始高级语言虚拟机的实现技术有了突飞猛进的发展，但却没有专门的书对这个领域做综述和导读。多数有用的资料其实还是在论文里。光靠读书是远远不够用的，论文这块也请关注。<h1 id="-http-rednaxelafx-iteye-com-blog-362738-http-rednaxelafx-iteye-com-blog-362738-">顺便广告一下：我的博客里关于虚拟机的文章也推荐给大家参考：<a href="http://rednaxelafx.iteye.com/blog/362738" target="_blank"><a href="http://rednaxelafx.iteye.com/blog/362738">http://rednaxelafx.iteye.com/blog/362738</a></a></h1>
这个豆列没有漏掉 <a href="http://book.douban.com/subject/1788390/" target="_blank">《Inside the Java Virtual Machine, Second Edition》</a> ，中文版<a href="http://book.douban.com/subject/1138768/" target="_blank">《深入Java虚拟机(原书第2版)》</a>，只是我现在已经不再推荐它。这本书刚出版的时候确实引起了一番学习Java虚拟机的热潮，但其部分内容从现在的角度看已经过时，特别是涉及JVM实现的部分。像火车算法什么的现在已经没有JVM实现使用。不过话说回来，了解了解这些过时的信息也没什么不好，前提是能自己分辨清楚哪些信息是适用于现在的JVM的，而哪些已经成为了历史。</li>
</ol>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/JVM/">JVM</a></li></span></span> | <span class="tags">Tagged <a href="/tags/JVM/" class="label label-primary">JVM</a><a href="/tags/Java&J2EE/" class="label label-success">Java&J2EE</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:42"datetime="2014-03-07 09:54:42"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-JVM--豆列：从表到里学习JVM实现/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-JVM--豆列：从表到里学习JVM实现" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>





<ul id="pagination" class="pagination pagination-lg">
  <li><a class="extend prev" href="/page/47/">&laquo;</a></li><li><a class="page-number" href="/">1</a></li><li><a class="page-number" href="/page/2/">2</a></li><li><span class="space">&hellip;</span></li><li><a class="page-number" href="/page/45/">45</a></li><li><a class="page-number" href="/page/46/">46</a></li><li><a class="page-number" href="/page/47/">47</a></li><li class="active"><li><span class="page-number current">48</span></li><li><a class="page-number" href="/page/49/">49</a></li><li><a class="page-number" href="/page/50/">50</a></li><li><a class="page-number" href="/page/51/">51</a></li><li><span class="space">&hellip;</span></li></li><li><a class="page-number" href="/page/164/">164</a></li><li><a class="page-number" href="/page/165/">165</a></li><li><a class="extend next" href="/page/49/">&raquo;</a></li>
  <div class="clearfix"></div>
</ul></div><!--wapper-->
       </div><!-- ID main-col END -->
       <aside id="sidebar" class="alignright col-sx-6 col-sm-4 col-md-3 col-lg-3">
<div id="widget_search" class="widget panel panel-primary">
    <form action="//google.com/search" method="get" accept-charset="utf-8">
  <div class="input-group">
    <input class="form-control" id="searchbox" type="search" name="q" results="0" placeholder="search">
    <span class="input-group-btn">
      <button class="btn btn-default" type="submit">Go!</button>
    </span>
    <input type="hidden" name="q" value="site:itsolife.com">
  </div>
</form>
</div>

<div id="widget_category" class="widget panel panel-primary">
  <div class="panel-heading">category</div>  <div data-src='category' class='ajax_widgets'>正在加载...</div>
</div>

<div id="widget_recent_posts" class="widget panel panel-primary">
  <div class="panel-heading">recent posts</div>  <div data-src='recent_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_tagcloud" class="widget panel panel-primary">
  <div class="panel-heading">tagcloud</div>  <div data-src='tagcloud' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_latest_update_posts" class="widget panel panel-primary">
  <div class="panel-heading">最近更新</div>  <div data-src='latest_update_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_recent_comments" class="widget panel panel-primary">
  <div class="panel-heading">recent comments</div>  

<div class="list-group-item ds-recent-comments" data-num-items="6" data-show-avatars="1" data-show-time="1" data-show-title="1" data-show-admin="1" data-excerpt-length="50"></div>



</div>

</aside>
       <div class="clearfix"></div>
     </div><!-- row END -->
  </div>
  <footer id="footer" class="container">
  <div class="panel panel-info">
  <section id='footer_widget'></section>  <div class="panel-footer">
  <div id="site-info">
    <span class='author'>
  
  &copy; 2014 RobinChia
  
    &nbsp;&nbsp;</span>
  
  <span id='analytics-51la'></span><span id='analytics-google'>
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-48559895-1']);
  _gaq.push(['_trackPageview']);
  _js2load.push({src:('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'});
</script></span><span id='analytics-cnzz'>
<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_5774006'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s17.cnzz.com/stat.php%3Fid%3D5774006%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>
</span><span id='analytics-baidu'>
<script>
var _hmt = _hmt || [];
_js2load.push({src:"//hm.baidu.com/hm.js?1442f50724afc42380b51f097c43082c"});
</script>
</span>  </div>
  <div id="copyright">Blog powered by <a href='http://zespia.tw/hexo/'><strong>hexo</strong></a> Theme <strong><a href='https://github.com/chenall/hexo-theme-chenall'>chenall</a></strong>(Some change in it)<span class="pull-right"> 更新时间: <em>2014-03-15 16:47:45</em></span></div>
</div>
<div class="clearfix"></div>


  </div>
  </footer>
  
        <script src="http://cdn.bootcss.com/jquery/1.10.2/jquery.min.js"></script>        
        <script src="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/js/bootstrap.min.js"></script>        
                
        <script src="http://cdn.bootcss.com/prettify/r298/prettify.min.js"></script>    <script type="text/javascript">
   var lang=["bsh", "c", "cc", "cpp", "cs", "csh", "cyc", "cv", "htm", "html",
    "java", "js", "m", "mxml", "perl", "pl", "pm", "py", "rb", "sh",
    "xhtml", "xml", "xsl"];
   var pretty_base='';
   $('script').each(function(){
	var c = $(this).attr('src');
	if (!c)
	    return;
	if (c.match(/(\/)?prettify(\.min)?\.js/i))
	{
	    var index = c.lastIndexOf('/');
	    if (index != -1)
		pretty_base = c.substr(0,index + 1);
	    return false;
	}
   })
   $('pre code').each(function(){
	var c = $(this).attr('class')
	if (!c)
	    return;
	c = c.match(/\s?(lang\-\w+)/i);
	if (c && lang.indexOf(c[1]) == -1)
	{
	    lang.push(c[1]);
	    $.getScript(pretty_base + c[1] + '.min.js');
	}
   })

    $(window).load(function(){
       $("pre").addClass("prettyprint");
       prettyPrint();
    })
</script>    
            <script type="text/javascript">
var duoshuoQuery = {short_name:"robinchia"};
_js2load.push({src:'http://static.duoshuo.com/embed.js',charset:'UTF-8'});
</script>
    
            <!--wumii_relatedItems-->
    
        <script src="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js"></script>    <script type="text/javascript">
(function($){
  $('.entry').each(function(i){
    $(this).find('img').each(function(){
      var alt = this.alt;

      if (alt){
        $(this).before('<span class="caption">' + alt + '</span>');
      }

      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox" rel="fancybox' + i + '" />');
    });
  });

  $('.fancybox').fancybox();
})(jQuery);
</script>    
        <script src="http://cdn.bootcss.com/mathjax/2.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>    <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>
    
<script type="text/javascript">
$('.ajax_widgets').each(function(){var src=$(this).attr('data-src');if(src)$(this).load('/widgets/'+src+'.html');});
$.each(_js2load,function(index,obj){loadjs(obj.src,obj.charset)});
</script>

<div id="scroll2top">
<img src="/scroll2top/arrow.png"/>
</div>
<script src="/scroll2top/scroll2top.min.js"></script>
<div id="winterland">
  <canvas></canvas>
</div>
<script src="/js/winterland.min.js"></script>

  </body>
</html>
