
<!DOCTYPE HTML>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>The 54 Page | It so life</title>
<meta name="author" content="RobinChia">

<meta name="description" content="It so life">


<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<meta property="og:site_name" content="It so life"/>

<!--[if IE]><style>.testIE.IE{display:inline;}</style><![endif]-->
<!--[if lte IE 7]><link rel="stylesheet" href="/css/ie7.css" type="text/css"><![endif]-->
<!--[if (lt IE 9)&(gt IE 7)]><style>.testIE.IE8{display:inline;}</style><![endif]-->
<!--[if gt IE 8]><style>.testIE.IE9{display:inline;}</style><![endif]-->

<link href="/favicon.png" rel="icon">
<link rel="alternate" href="/atom.xml" title="It so life Feed" type="application/atom+xml">

<link rel="stylesheet" href="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/css/bootstrap.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/font-awesome/4.0.3/css/font-awesome.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/prettify/r298/prettify.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" type="text/css">
<link rel="stylesheet" href="/css/style.css" type="text/css">
<!--[if lt IE 9]>
   <style>article,aside,dialog,footer,header,section,footer,nav,figure,menu{display:block}</style>
   <script src="http://cdn.staticfile.org/html5shiv/r29/html5.min.js"></script>
   <script src="http://cdn.staticfile.org/respond.js/1.4.2/respond.min.js"></script>
<link href="http://cdn.staticfile.org/respond.js/1.4.2/respond-proxy.html" id="respond-proxy" rel="respond-proxy" />
<link href="/js/respond.proxy.gif" id="respond-redirect" rel="respond-redirect" />
<script src="/js/respond.proxy.js"></script>
   <script src="http://cdn.bootcss.com/selectivizr/1.0.2/selectivizr-min.js"></script>
<![endif]-->
<script type="text/javascript">
function loadjs(c,d){var a=document.createElement("script");a.async=!0;a.type="text/javascript";a.src=c;a.charset=d||"gbk";(document.getElementsByTagName("HEAD")[0]||document.getElementsByTagName("BODY")[0]).appendChild(a)};
var _protocol = (("https:" == document.location.protocol) ? " https://" : " http://");
var _js2load = [];
</script>

</head>
<body>
      <header id="header" class="container"><nav id="main-nav" class="navbar navbar-default navbar-fixed-top " role="navigation">
  <div class="container">
    <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
      <span class="sr-only">Toggle navigation</span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="/">It so life</a>
    </div>
    <div  class="collapse navbar-collapse">
      <ul  class="nav navbar-nav">
  
        <li><a href="/" title="Home">Home</a></li>      
        <li><a href="/about/" title="About">About</a></li>      
        <li><a href="/archives/" title="Archives">Archives</a></li>      
      <li class='dropdown'>
        <a class='dropdown-toggle' data-toggle='dropdown' href='#'>website<b class='caret'></b></a>
        <ul class='dropdown-menu pure-menu-selected'>
    
          <li><a href="//groups.google.com/forum/#!forum/pongba" title="TopLanguage">TopLanguage</a></li>    
          <li><a href="//itpub.net/" title="ITPub">ITPub</a></li>    
          <li><a href="//blog.jobbole.com/" title="Bole">Bole</a></li>    
          <li><a href="//nosql-database.org/" title="nosql">nosql</a></li>    
          <li><a href="//gitimmersion.googol.im/" title="Git">Git</a></li>    
        </ul>
      </li>
    
      </ul>
      <ul class="nav navbar-nav navbar-right">
      
        <li><a href="/atom.xml">RSS</a></li>
      
      
        <li><a href="https://twitter.com/robinchia">twitter</a></li>
      
      
      
      
        <li><a href="https://github.com/robinchia">github</a></li>
      
      </ul>
    </div>
  </div>
</nav>
<div class="clearfix"></div>
</header>
  <div id='content' class="container">
     <div class="page-header-wrapper">
      <!--[if lt IE 9]><div class="alert alert-warning alert-dismissable"><button type="button" class="close" data-dismiss="alert" aria-hidden="true">&times;</button><strong>提示:</strong>您的浏览器版本太低了,建议升级到 <strong><a href="http://windows.microsoft.com/zh-cn/internet-explorer/download-ie" title="IE9">IE9</a></strong> 以上,本站使用<a href="https://www.google.com/intl/zh-CN/chrome/">Chrome浏览器</a>可以获得最好的显示效果.</div><![endif]-->
      <div class="page-header"><h1 align="center"><big>It so life</big> </h1>
        <h5 align="center"><big>love as life</big></h5>
      </div>
     </div>
     <div class="row">
       <div id="main-col" class="alignleft col-sx-12 col-sm-8 col-md-9 col-lg-9">
      <section id='header_widget'></section>
          <div id="wrapper"><article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-NIO--JavaNIOAPI详解/">Java NIO API详解</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:41.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-NIO--JavaNIOAPI详解/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="java-nio-api-">Java NIO API详解</h1>
<p><a href="http://www.blogjava.net/19851985lili/" target="_blank">【永恒的瞬间】</a>
☜Give me hapy ☞</p>
<p><a href="http://www.blogjava.net/" target="_blank">BlogJava</a>   <a href="http://www.blogjava.net/19851985lili/" target="_blank">首页</a>      <a href="http://www.blogjava.net/EnterMyBlog.aspx?NewArticle=1" target="_blank">新文章</a>   <a href="http://www.blogjava.net/19851985lili/contact.aspx?id=1" target="_blank">联系</a>   <a href="http://www.blogjava.net/19851985lili/rss" target="_blank">聚合</a><a href="http://www.blogjava.net/19851985lili/rss" target="_blank"><img src="" alt=""></a>   <a href="http://www.blogjava.net/19851985lili/admin/EditPosts.aspx" target="_blank">管理</a>
诱惑的世界,难以自我!
名利的生活,面具包裹!
我们的人生,充当角色!
寂静的深夜,真实自我!
<img src="" alt=""></p>
<h3 id="-">常用链接</h3>
<ul>
<li><a href="http://www.blogjava.net/19851985lili/MyPosts.html" target="_blank">我的随笔</a></li>
<li><a href="http://www.blogjava.net/19851985lili/MyComments.html" target="_blank">我的评论</a></li>
<li><a href="http://www.blogjava.net/19851985lili/OtherPosts.html" target="_blank">我的参与</a></li>
<li><a href="http://www.blogjava.net/19851985lili/RecentComments.html" target="_blank">最新评论</a></li>
</ul>
<h3 id="-3-">留言簿(3)</h3>
<ul>
<li><a href="http://www.blogjava.net/19851985lili/Contact.aspx?id=1" target="_blank">给我留言</a></li>
<li><a href="http://www.blogjava.net/19851985lili/default.aspx?opt=msg" target="_blank">查看公开留言</a></li>
<li><a href="http://www.blogjava.net/19851985lili/admin/MyMessages.aspx" target="_blank">查看私人留言</a></li>
</ul>
<h1 id="-6-">随笔档案(6)</h1>
<ul>
<li><a href="http://www.blogjava.net/19851985lili/archive/2008/05.html" target="_blank">2008年5月 (1)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/archive/2007/05.html" target="_blank">2007年5月 (1)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/archive/2007/04.html" target="_blank">2007年4月 (2)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/archive/2007/02.html" target="_blank">2007年2月 (1)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/archive/2007/01.html" target="_blank">2007年1月 (1)</a></li>
</ul>
<h1 id="-188-">文章分类(188)</h1>
<ul>
<li><a href="http://www.blogjava.net/19851985lili/category/27256.html" target="_blank">Canada (Independent Skilled Worker)(2)</a><a href="http://www.blogjava.net/19851985lili/category/27256.html/rss" title="Subscribe to Canada (Independent Skilled Worker)(2)" target="_blank"><img src="&quot;Subscribe to Canada (Independent Skilled Worker" alt="">(2)&quot;)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/category/26726.html" target="_blank">EJB3.0(4)</a><a href="http://www.blogjava.net/19851985lili/category/26726.html/rss" title="Subscribe to EJB3.0(4)" target="_blank"><img src="&quot;Subscribe to EJB3.0(4" alt="">&quot;)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/category/19161.html" target="_blank">flex2.0(40)</a><a href="http://www.blogjava.net/19851985lili/category/19161.html/rss" title="Subscribe to flex2.0(40)" target="_blank"><img src="&quot;Subscribe to flex2.0(40" alt="">&quot;)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/category/19815.html" target="_blank">flex2Cairngorm(6)</a><a href="http://www.blogjava.net/19851985lili/category/19815.html/rss" title="Subscribe to flex2Cairngorm(6)" target="_blank"><img src="&quot;Subscribe to flex2Cairngorm(6" alt="">&quot;)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/category/18358.html" target="_blank">hibernate(17)</a><a href="http://www.blogjava.net/19851985lili/category/18358.html/rss" title="Subscribe to hibernate(17)" target="_blank"><img src="&quot;Subscribe to hibernate(17" alt="">&quot;)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/category/19706.html" target="_blank">java_code(7)</a><a href="http://www.blogjava.net/19851985lili/category/19706.html/rss" title="Subscribe to java_code(7)" target="_blank"><img src="&quot;Subscribe to java_code(7" alt="">&quot;)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/category/18943.html" target="_blank">JavaBasic(15)</a><a href="http://www.blogjava.net/19851985lili/category/18943.html/rss" title="Subscribe to JavaBasic(15)" target="_blank"><img src="&quot;Subscribe to JavaBasic(15" alt="">&quot;)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/category/18368.html" target="_blank">JAVAEE(20)</a><a href="http://www.blogjava.net/19851985lili/category/18368.html/rss" title="Subscribe to JAVAEE(20)" target="_blank"><img src="&quot;Subscribe to JAVAEE(20" alt="">&quot;)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/category/19705.html" target="_blank">javamail(4)</a><a href="http://www.blogjava.net/19851985lili/category/19705.html/rss" title="Subscribe to javamail(4)" target="_blank"><img src="&quot;Subscribe to javamail(4" alt="">&quot;)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/category/18934.html" target="_blank">Log4j(8)</a><a href="http://www.blogjava.net/19851985lili/category/18934.html/rss" title="Subscribe to Log4j(8)" target="_blank"><img src="&quot;Subscribe to Log4j(8" alt="">&quot;)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/category/22482.html" target="_blank">meshwork(1)</a><a href="http://www.blogjava.net/19851985lili/category/22482.html/rss" title="Subscribe to meshwork(1)" target="_blank"><img src="&quot;Subscribe to meshwork(1" alt="">&quot;)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/category/20441.html" target="_blank">ORACLE(13)</a><a href="http://www.blogjava.net/19851985lili/category/20441.html/rss" title="Subscribe to ORACLE(13)" target="_blank"><img src="&quot;Subscribe to ORACLE(13" alt="">&quot;)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/category/19306.html" target="_blank">server(5)</a><a href="http://www.blogjava.net/19851985lili/category/19306.html/rss" title="Subscribe to server(5)" target="_blank"><img src="&quot;Subscribe to server(5" alt="">&quot;)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/category/18359.html" target="_blank">Spring(6)</a><a href="http://www.blogjava.net/19851985lili/category/18359.html/rss" title="Subscribe to Spring(6)" target="_blank"><img src="&quot;Subscribe to Spring(6" alt="">&quot;)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/category/18360.html" target="_blank">struts(8)</a><a href="http://www.blogjava.net/19851985lili/category/18360.html/rss" title="Subscribe to struts(8)" target="_blank"><img src="&quot;Subscribe to struts(8" alt="">&quot;)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/category/20166.html" target="_blank">Sun_Solaris(11)</a><a href="http://www.blogjava.net/19851985lili/category/20166.html/rss" title="Subscribe to Sun_Solaris(11)" target="_blank"><img src="&quot;Subscribe to Sun_Solaris(11" alt="">&quot;)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/category/19127.html" target="_blank">Tomcat(2)</a><a href="http://www.blogjava.net/19851985lili/category/19127.html/rss" title="Subscribe to Tomcat(2)" target="_blank"><img src="&quot;Subscribe to Tomcat(2" alt="">&quot;)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/category/20208.html" target="_blank">UML(2)</a><a href="http://www.blogjava.net/19851985lili/category/20208.html/rss" title="Subscribe to UML(2)" target="_blank"><img src="&quot;Subscribe to UML(2" alt="">&quot;)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/category/19707.html" target="_blank">Vmware(2)</a><a href="http://www.blogjava.net/19851985lili/category/19707.html/rss" title="Subscribe to Vmware(2)" target="_blank"><img src="&quot;Subscribe to Vmware(2" alt="">&quot;)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/category/20445.html" target="_blank">VSS(2)</a><a href="http://www.blogjava.net/19851985lili/category/20445.html/rss" title="Subscribe to VSS(2)" target="_blank"><img src="&quot;Subscribe to VSS(2" alt="">&quot;)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/category/19285.html" target="_blank">webotx(5)</a><a href="http://www.blogjava.net/19851985lili/category/19285.html/rss" title="Subscribe to webotx(5)" target="_blank"><img src="&quot;Subscribe to webotx(5" alt="">&quot;)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/category/21579.html" target="_blank">Windows x(3)</a><a href="http://www.blogjava.net/19851985lili/category/21579.html/rss" title="Subscribe to Windows x(3)" target="_blank"><img src="&quot;Subscribe to Windows x(3" alt="">&quot;)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/category/19189.html" target="_blank">常用正则表达式 (5)</a><a href="http://www.blogjava.net/19851985lili/category/19189.html/rss" title="Subscribe to 常用正则表达式 (5)" target="_blank"><img src="&quot;Subscribe to 常用正则表达式 (5" alt="">&quot;)</a></li>
</ul>
<h1 id="-206-">文章档案(206)</h1>
<ul>
<li><a href="http://www.blogjava.net/19851985lili/archives/2008/05.html" target="_blank">2008年5月 (10)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/archives/2007/11.html" target="_blank">2007年11月 (2)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/archives/2007/10.html" target="_blank">2007年10月 (4)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/archives/2007/06.html" target="_blank">2007年6月 (5)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/archives/2007/05.html" target="_blank">2007年5月 (21)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/archives/2007/04.html" target="_blank">2007年4月 (33)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/archives/2007/03.html" target="_blank">2007年3月 (10)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/archives/2007/02.html" target="_blank">2007年2月 (58)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/archives/2007/01.html" target="_blank">2007年1月 (63)</a></li>
</ul>
<h1 id="url">URL</h1>
<ul>
<li><a href="http://www.w3school.com.cn/index.html" target="_blank">Web 技术教程</a><a href="http://www.w3school.com.cn/index.html" title="Subscribe to Web 技术教程" target="_blank"><img src="&quot;Subscribe to Web 技术教程&quot;" alt=""></a></li>
<li><a href="http://www.forbeschina.com/cmslive/index.jsp" target="_blank">福布斯中文版</a><a href="http://www.forbeschina.com/cmslive/index.jsp" title="Subscribe to 福布斯中文版" target="_blank"><img src="&quot;Subscribe to 福布斯中文版&quot;" alt=""></a></li>
<li><a href="http://rt.openfoundry.org/Foundry/" target="_blank">自由软体铸造场</a><a href="http://rt.openfoundry.org/Foundry/" title="Subscribe to 自由软体铸造场" target="_blank"><img src="&quot;Subscribe to 自由软体铸造场&quot;" alt=""></a></li>
<li><a href="http://caterpillar.onlyfun.net/GossipCN/index.html" target="_blank">良葛格学习笔记</a><a href="http://caterpillar.onlyfun.net/GossipCN/index.html" title="Subscribe to 良葛格学习笔记" target="_blank"><img src="&quot;Subscribe to 良葛格学习笔记&quot;" alt=""></a></li>
</ul>
<h3 id="-">搜索</h3>
<p>*</p>
<ul>
<li></li>
</ul>
<h3 id="-http-www-blogjava-net-19851985lili-commentsrss-aspx-">最新评论 <a href="http://www.blogjava.net/19851985lili/CommentsRSS.aspx" target="_blank"><img src="" alt=""></a></h3>
<ul>
<li><a href="http://www.blogjava.net/19851985lili/archive/2012/08/27/98475.html#386372" target="_blank">1. re: 研究一下springside的核心部分源代码</a></li>
<li><a href="http://www.easy518.com/" target="_blank"><a href="http://www.easy518.com">http://www.easy518.com</a></a></li>
<li>--美丽说</li>
<li><a href="http://www.blogjava.net/19851985lili/archive/2012/06/08/154836.html#380302" target="_blank">2. re: EJB 简介</a></li>
<li>垃圾</li>
<li>--fff</li>
<li><a href="http://www.blogjava.net/19851985lili/archive/2011/12/27/93705.html#367319" target="_blank">3. webotx https 如何配置</a></li>
<li>你好，请问WebOTX如何配置https服务呢？
如果可以，在线等哦。 谢谢。。。。</li>
<li>--janson</li>
<li><a href="http://www.blogjava.net/19851985lili/archive/2010/11/22/97631.html#338704" target="_blank">4. 你好</a></li>
<li>长须鲸努力掉书袋事故 GUDDSUDUSADSIAUDSFYDIDFSLIFAFSDYIO8YFDOS</li>
<li>--余风好</li>
<li><a href="http://www.blogjava.net/19851985lili/archive/2010/06/08/97622.html#323049" target="_blank">5. re: Flex2 发现之旅：AS3中新的XML处理方法 - E4X</a></li>
<li>不知道为什么，如果使用item.title访问title节点的话，返回是空的</li>
</ul>
<hr>
<p>这个跟返回的XML的namespace有关。</p>
<ul>
<li>--kennethpoon</li>
</ul>
<h3 id="-">阅读排行榜</h3>
<ul>
<li><a href="http://www.blogjava.net/19851985lili/archive/2007/02/06/98199.html" target="_blank">1. explorer.exe文件损坏，如何修复(12012)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/archive/2007/05/23/119380.html" target="_blank">2. 如何解决cmd.exe占CPU资源100%问题(560)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/archive/2007/04/13/110320.html" target="_blank">3. 亲情之歌(346)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/archive/2007/01/03/91573.html" target="_blank">4. 数码相机的原理(336)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/archive/2008/05/29/203793.html" target="_blank">5. 防止IE被黑的技巧(318)</a></li>
</ul>
<h3 id="-">评论排行榜</h3>
<ul>
<li><a href="http://www.blogjava.net/19851985lili/archive/2007/02/06/98199.html" target="_blank">1. explorer.exe文件损坏，如何修复(1)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/archive/2007/01/03/91573.html" target="_blank">2. 数码相机的原理(0)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/archive/2008/05/29/203793.html" target="_blank">3. 防止IE被黑的技巧(0)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/archive/2007/05/23/119380.html" target="_blank">4. 如何解决cmd.exe占CPU资源100%问题(0)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/archive/2007/04/13/110320.html" target="_blank">5. 亲情之歌(0)</a></li>
</ul>
<p><a href="http://www.blogjava.net/19851985lili/articles/93524.html" target="_blank">Java NIO API详解</a></p>
<p>NIO API 主要集中在 java.nio 和它的 subpackages 中：</p>
<p>java.nio</p>
<p>定义了 Buffer 及其数据类型相关的子类。其中被 java.nio.channels 中的类用来进行 IO 操作的 ByteBuffer 的作用非常重要。</p>
<p>java.nio.channels</p>
<p>定义了一系列处理 IO 的 Channel 接口以及这些接口在文件系统和网络通讯上的实现。通过 Selector 这个类，还提供了进行非阻塞 IO 操作的办法。这个包可以说是 NIO API 的核心。</p>
<p>java.nio.channels.spi</p>
<p>定义了可用来实现 channel 和 selector API 的抽象类。</p>
<p>java.nio.charset</p>
<pre><code>     定义了处理字符编码和解码的类。
</code></pre><p>java.nio.charset.spi</p>
<pre><code>     定义了可用来实现 charset API 的抽象类。
</code></pre><p>java.nio.channels.spi 和 java.nio.charset.spi 这两个包主要被用来对现有 NIO API 进行扩展，在实际的使用中，我们一般只和另外的 3 个包打交道。下面将对这 3 个包一一介绍。</p>
<p>Package java.nio</p>
<p>这个包主要定义了 Buffer 及其子类。 Buffer 定义了一个线性存放 primitive type 数据的容器接口。对于除 boolean 以外的其他 primitive type ，都有一个相应的 Buffer 子类， ByteBuffer 是其中最重要的一个子类。</p>
<p>下面这张 UML 类图描述了 java.nio 中的类的关系：</p>
<p><img src="" alt=""></p>
<p><strong>Buffer</strong></p>
<p>定义了一个可以线性存放 primitive type 数据的容器接口。 Buffer 主要包含了与类型（ byte, char… ）无关的功能。值得注意的是 Buffer 及其子类都不是线程安全的。</p>
<p>每个 Buffer 都有以下的属性：</p>
<p>capacity</p>
<p>这个 Buffer 最多能放多少数据。 capacity 一般在 buffer 被创建的时候指定。</p>
<p>limit</p>
<p>在 Buffer 上进行的读写操作都不能越过这个下标。当写数据到 buffer 中时， limit 一般和 capacity 相等，当读数据时， limit 代表 buffer 中有效数据的长度。</p>
<p>position</p>
<p>读 / 写操作的当前下标。当使用 buffer 的相对位置进行读 / 写操作时，读 / 写会从这个下标进行，并在操作完成后， buffer 会更新下标的值。</p>
<p>mark</p>
<p>一个临时存放的位置下标。调用 mark() 会将 mark 设为当前的 position 的值，以后调用 reset() 会将 position 属性设置为 mark 的值。 mark 的值总是小于等于 position 的值，如果将 position 的值设的比 mark 小，当前的 mark 值会被抛弃掉。</p>
<p>这些属性总是满足以下条件：</p>
<p>0 &lt;= mark &lt;= position &lt;= limit &lt;= capacity</p>
<p>limit 和 position 的值除了通过 limit() 和 position() 函数来设置，也可以通过下面这些函数来改变：</p>
<p>Buffer clear()</p>
<p>把 position 设为 0 ，把 limit 设为 capacity ，一般在把数据写入 Buffer 前调用。</p>
<p>Buffer flip()</p>
<p>把 limit 设为当前 position ，把 position 设为 0 ，一般在从 Buffer 读出数据前调用。</p>
<p>Buffer rewind()</p>
<p>把 position 设为 0 ， limit 不变，一般在把数据重写入 Buffer 前调用。</p>
<p>Buffer 对象有可能是只读的，这时，任何对该对象的写操作都会触发一个 ReadOnlyBufferException 。 isReadOnly() 方法可以用来判断一个 Buffer 是否只读。</p>
<p><strong>ByteBuffer</strong></p>
<p>在 Buffer 的子类中， ByteBuffer 是一个地位较为特殊的类，因为在 java.io.channels 中定义的各种 channel 的 IO 操作基本上都是围绕 ByteBuffer 展开的。</p>
<p>ByteBuffer 定义了 4 个 static 方法来做创建工作：</p>
<p>ByteBuffer allocate(int capacity)</p>
<p>创建一个指定 capacity 的 ByteBuffer 。</p>
<p>ByteBuffer allocateDirect(int capacity)</p>
<p>创建一个 direct 的 ByteBuffer ，这样的 ByteBuffer 在参与 IO 操作时性能会更好（很有可能是在底层的实现使用了 DMA 技术），相应的，创建和回收 direct 的 ByteBuffer 的代价也会高一些。 isDirect() 方法可以检查一个 buffer 是否是 direct 的。</p>
<p>ByteBuffer wrap(byte [] array)</p>
<p>ByteBuffer wrap(byte [] array, int offset, int length)</p>
<p>把一个 byte 数组或 byte 数组的一部分包装成 ByteBuffer 。</p>
<p>ByteBuffer 定义了一系列 get 和 put 操作来从中读写 byte 数据，如下面几个：</p>
<p>byte get()</p>
<p>ByteBuffer get(byte [] dst)</p>
<p>byte get(int index)</p>
<p>ByteBuffer put(byte b)</p>
<p>ByteBuffer put(byte [] src)</p>
<p>ByteBuffer put(int index, byte b)</p>
<p>这些操作可分为绝对定位和相对定为两种，相对定位的读写操作依靠 position 来定位 Buffer 中的位置，并在操作完成后会更新 position 的值。</p>
<p>在其它类型的 buffer 中，也定义了相同的函数来读写数据，唯一不同的就是一些参数和返回值的类型。</p>
<p>除了读写 byte 类型数据的函数， ByteBuffer 的一个特别之处是它还定义了读写其它 primitive 数据的方法，如：</p>
<p>int getInt()</p>
<pre><code>     从 ByteBuffer 中读出一个 int 值。
</code></pre><p>ByteBuffer putInt(int value)</p>
<pre><code>     写入一个 int 值到 ByteBuffer 中。
</code></pre><p>读写其它类型的数据牵涉到字节序问题， ByteBuffer 会按其字节序（大字节序或小字节序）写入或读出一个其它类型的数据（ int,long… ）。字节序可以用 order 方法来取得和设置：</p>
<p>ByteOrder order()</p>
<pre><code>     返回 ByteBuffer 的字节序。
</code></pre><p>ByteBuffer order(ByteOrder bo)</p>
<pre><code>     设置 ByteBuffer 的字节序。
</code></pre><p>ByteBuffer 另一个特别的地方是可以在它的基础上得到其它类型的 buffer 。如：</p>
<p>CharBuffer asCharBuffer()</p>
<p>为当前的 ByteBuffer 创建一个 CharBuffer 的视图。在该视图 buffer 中的读写操作会按照 ByteBuffer 的字节序作用到 ByteBuffer 中的数据上。</p>
<p>用这类方法创建出来的 buffer 会从 ByteBuffer 的 position 位置开始到 limit 位置结束，可以看作是这段数据的视图。视图 buffer 的 readOnly 属性和 direct 属性与 ByteBuffer 的一致，而且也只有通过这种方法，才可以得到其他数据类型的 direct buffer 。</p>
<p><strong>ByteOrder</strong></p>
<p>用来表示 ByteBuffer 字节序的类，可将其看成 java 中的 enum 类型。主要定义了下面几个 static 方法和属性：</p>
<p>ByteOrder BIG_ENDIAN</p>
<pre><code>     代表大字节序的 ByteOrder 。
</code></pre><p>ByteOrder LITTLE_ENDIAN</p>
<pre><code>     代表小字节序的 ByteOrder 。
</code></pre><p>ByteOrder nativeOrder()</p>
<pre><code>     返回当前硬件平台的字节序。
</code></pre><p><strong>MappedByteBuffer</strong></p>
<p>ByteBuffer 的子类，是文件内容在内存中的映射。这个类的实例需要通过 FileChannel 的 map() 方法来创建。</p>
<p>接下来看看一个使用 ByteBuffer 的例子，这个例子从标准输入不停地读入字符，当读满一行后，将收集的字符写到标准输出：</p>
<pre><code> **public** **static** **void** main(String [] args)

    **throws** IOException

 {

    //   创建一个 capacity 为 256 的 ByteBuffer

    ByteBuffer buf = ByteBuffer.allocate(256);

    **while** ( **true** ) {

        //   从标准输入流读入一个字符

        **int** c = System.in.read();

        //   当读到输入流结束时，退出循环

        **if** (c == -1)

           **break** ;



        //   把读入的字符写入 ByteBuffer 中

        buf.put(( **byte** ) c);

        //   当读完一行时，输出收集的字符

        **if** (c == &#39;\n&#39; ) {

           //   调用 flip() 使 limit 变为当前的 position 的值 ,position 变为 0,

           //   为接下来从 ByteBuffer 读取做准备

           buf.flip();

           //   构建一个 byte 数组

           **byte** [] content = **new** **byte** [buf.limit()];

           //   从 ByteBuffer 中读取数据到 byte 数组中

           buf.get(content);

             //   把 byte 数组的内容写到标准输出

           System.out.print( **new** String(content));

           //   调用 clear() 使 position 变为 0,limit 变为 capacity 的值，

           //   为接下来写入数据到 ByteBuffer 中做准备

           buf.clear();

        }

    }

 }
</code></pre><p>Package java.nio.channels</p>
<p>这个包定义了 Channel 的概念， Channel 表现了一个可以进行 IO 操作的通道（比如，通过 FileChannel ，我们可以对文件进行读写操作）。 java.nio.channels 包含了文件系统和网络通讯相关的 channel 类。这个包通过 Selector 和 SelectableChannel 这两个类，还定义了一个进行非阻塞（ non-blocking ） IO 操作的 API ，这对需要高性能 IO 的应用非常重要。</p>
<p>下面这张 UML 类图描述了 java.nio.channels 中 interface 的关系：</p>
<p><img src="" alt=""></p>
<p><strong>Channel</strong></p>
<p>Channel 表现了一个可以进行 IO 操作的通道，该 interface 定义了以下方法：</p>
<p>boolean isOpen()</p>
<pre><code>     该 Channel 是否是打开的。
</code></pre><p>void close()</p>
<pre><code>     关闭这个 Channel ，相关的资源会被释放。
</code></pre><p><strong>ReadableByteChannel</strong></p>
<p>定义了一个可从中读取 byte 数据的 channel interface 。</p>
<p>int read(ByteBuffer dst)</p>
<p>从 channel 中读取 byte 数据并写到 ByteBuffer 中。返回读取的 byte 数。</p>
<p><strong>WritableByteChannel</strong></p>
<p>定义了一个可向其写 byte 数据的 channel interface 。</p>
<p>int write(ByteBuffer src)</p>
<pre><code>     从 ByteBuffer 中读取 byte 数据并写到 channel 中。返回写出的 byte 数。
</code></pre><p><strong>ByteChannel</strong></p>
<p>ByteChannel 并没有定义新的方法，它的作用只是把 ReadableByteChannel 和 WritableByteChannel 合并在一起。</p>
<p><strong>ScatteringByteChannel</strong></p>
<p>继承了 ReadableByteChannel 并提供了同时往几个 ByteBuffer 中写数据的能力。</p>
<p><strong>GatheringByteChannel</strong></p>
<p>继承了 WritableByteChannel 并提供了同时从几个 ByteBuffer 中读数据的能力。</p>
<p><strong>InterruptibleChannel</strong></p>
<p>用来表现一个可以被异步关闭的 Channel 。这表现在两方面：</p>
<p>1．     当一个 InterruptibleChannel 的 close() 方法被调用时，其它 block 在这个 InterruptibleChannel 的 IO 操作上的线程会接收到一个 AsynchronousCloseException 。</p>
<p>2．     当一个线程 block 在 InterruptibleChannel 的 IO 操作上时，另一个线程调用该线程的 interrupt() 方法会导致 channel 被关闭，该线程收到一个 ClosedByInterruptException ，同时线程的 interrupt 状态会被设置。</p>
<p>接下来的这张 UML 类图描述了 java.nio.channels 中类的关系：</p>
<p><img src="" alt=""></p>
<p><strong>非阻塞 IO</strong></p>
<p>非阻塞 IO 的支持可以算是 NIO API 中最重要的功能，非阻塞 IO 允许应用程序同时监控多个 channel 以提高性能，这一功能是通过 Selector ， SelectableChannel 和 SelectionKey 这 3 个类来实现的。</p>
<p>SelectableChannel 代表了可以支持非阻塞 IO 操作的 channel ，可以将其注册在 Selector 上，这种注册的关系由 SelectionKey 这个类来表现（见 UML 图）。 Selector 这个类通过 select() 函数，给应用程序提供了一个可以同时监控多个 IO channel 的方法：</p>
<p>应用程序通过调用 select() 函数，让 Selector 监控注册在其上的多个 SelectableChannel ，当有 channel 的 IO 操作可以进行时， select() 方法就会返回以让应用程序检查 channel 的状态，并作相应的处理。</p>
<p>下面是 JDK 1.4 中非阻塞 IO 的一个例子，这段 code 使用了非阻塞 IO 实现了一个 time server ：</p>
<pre><code> **private** **static** **void** acceptConnections( **int** port) **throws** Exception {

    //   打开一个 Selector

    Selector acceptSelector =

        SelectorProvider.provider().openSelector();



    //   创建一个 ServerSocketChannel ，这是一个 SelectableChannel 的子类

    ServerSocketChannel ssc = ServerSocketChannel.open();

    //   将其设为 non-blocking 状态，这样才能进行非阻塞 IO 操作

    ssc.configureBlocking( **false** );



    //   给 ServerSocketChannel 对应的 socket 绑定 IP 和端口

    InetAddress lh = InetAddress.getLocalHost();

    InetSocketAddress isa = **new** InetSocketAddress(lh, port);

    ssc.socket().bind(isa);



    //   将 ServerSocketChannel 注册到 Selector 上，返回对应的 SelectionKey

    SelectionKey acceptKey =

        ssc.register(acceptSelector, SelectionKey.OP_ACCEPT);



    **int** keysAdded = 0;



    //   用 select() 函数来监控注册在 Selector 上的 SelectableChannel

    //   返回值代表了有多少 channel 可以进行 IO 操作  (ready for IO)

    **while** ((keysAdded = acceptSelector.select()) &gt; 0) {

        // selectedKeys()  返回一个 SelectionKey 的集合，

        //   其中每个 SelectionKey 代表了一个可以进行 IO 操作的 channel 。

        //   一个 ServerSocketChannel 可以进行 IO 操作意味着有新的 TCP 连接连入了

        Set readyKeys = acceptSelector.selectedKeys();

        Iterator i = readyKeys.iterator();



        **while** (i.hasNext()) {

           SelectionKey sk = (SelectionKey) i.next();

           //   需要将处理过的 key 从 selectedKeys 这个集合中删除

           i.remove();

           //   从 SelectionKey 得到对应的 channel

           ServerSocketChannel nextReady =

               (ServerSocketChannel) sk.channel();

           //   接受新的 TCP 连接

           Socket s = nextReady.accept().socket();

           //   把当前的时间写到这个新的 TCP 连接中

           PrintWriter out =

               **new** PrintWriter(s.getOutputStream(), **true** );

           Date now = **new** Date();

           out.println(now);

           //   关闭连接

           out.close();

        }

    }

 }
</code></pre><p>这是个纯粹用于演示的例子，因为只有一个 ServerSocketChannel 需要监控，所以其实并不真的需要使用到非阻塞 IO 。不过正因为它的简单，可以很容易地看清楚非阻塞 IO 是如何工作的。</p>
<p><strong>SelectableChannel</strong></p>
<p>这个抽象类是所有支持非阻塞 IO 操作的 channel （如 DatagramChannel 、 SocketChannel ）的父类。 SelectableChannel 可以注册到一个或多个 Selector 上以进行非阻塞 IO 操作。</p>
<p>SelectableChannel 可以是 blocking 和 non-blocking 模式（所有 channel 创建的时候都是 blocking 模式），只有 non-blocking 的 SelectableChannel 才可以参与非阻塞 IO 操作。</p>
<p>SelectableChannel configureBlocking(boolean block)</p>
<pre><code>     设置 blocking 模式。
</code></pre><p>boolean isBlocking()</p>
<pre><code>     返回 blocking 模式。
</code></pre><p>通过 register() 方法， SelectableChannel 可以注册到 Selector 上。</p>
<p>int validOps()</p>
<p>返回一个 bit mask ，表示这个 channel 上支持的 IO 操作。当前在 SelectionKey 中，用静态常量定义了 4 种 IO 操作的 bit 值： OP_ACCEPT ， OP_CONNECT ， OP_READ 和 OP_WRITE 。</p>
<p>SelectionKey register(Selector sel, int ops)</p>
<p>将当前 channel 注册到一个 Selector 上并返回对应的 SelectionKey 。在这以后，通过调用 Selector 的 select() 函数就可以监控这个 channel 。 ops 这个参数是一个 bit mask ，代表了需要监控的 IO 操作。</p>
<p>SelectionKey register(Selector sel, int ops, Object att)</p>
<p>这个函数和上一个的意义一样，多出来的 att 参数会作为 attachment 被存放在返回的 SelectionKey 中，这在需要存放一些 session state 的时候非常有用。</p>
<p>boolean isRegistered()</p>
<pre><code>     该 channel 是否已注册在一个或多个 Selector 上。
</code></pre><p>SelectableChannel 还提供了得到对应 SelectionKey 的方法：</p>
<p>SelectionKey keyFor(Selector sel)</p>
<p>返回该 channe 在 Selector 上的注册关系所对应的 SelectionKey 。若无注册关系，返回 null 。</p>
<p><strong>Selector</strong></p>
<p>Selector 可以同时监控多个 SelectableChannel 的 IO 状况，是非阻塞 IO 的核心。</p>
<p>Selector open()</p>
<pre><code>   Selector 的一个静态方法，用于创建实例。
</code></pre><p>在一个 Selector 中，有 3 个 SelectionKey 的集合：</p>
<p>1． key set 代表了所有注册在这个 Selector 上的 channel ，这个集合可以通过 keys() 方法拿到。</p>
<p>2． Selected-key set 代表了所有通过 select() 方法监测到可以进行 IO 操作的 channel ，这个集合可以通过 selectedKeys() 拿到。</p>
<p>3． Cancelled-key set 代表了已经 cancel 了注册关系的 channel ，在下一个 select() 操作中，这些 channel 对应的 SelectionKey 会从 key set 和 cancelled-key set 中移走。这个集合无法直接访问。</p>
<p>以下是 select() 相关方法的说明：</p>
<p>int select()</p>
<p>监控所有注册的 channel ，当其中有注册的 IO 操作可以进行时，该函数返回，并将对应的 SelectionKey 加入 selected-key set 。</p>
<p>int select(long timeout)</p>
<pre><code>     可以设置超时的 select() 操作。
</code></pre><p>int selectNow()</p>
<pre><code>     进行一个立即返回的 select() 操作。
</code></pre><p>Selector wakeup()</p>
<pre><code>     使一个还未返回的 select() 操作立刻返回。
</code></pre><p><strong>SelectionKey</strong></p>
<p>代表了 Selector 和 SelectableChannel 的注册关系。</p>
<p>Selector 定义了 4 个静态常量来表示 4 种 IO 操作，这些常量可以进行位操作组合成一个 bit mask 。</p>
<p>int OP_ACCEPT</p>
<p>有新的网络连接可以 accept ， ServerSocketChannel 支持这一非阻塞 IO 。</p>
<p>int OP_CONNECT</p>
<pre><code>     代表连接已经建立（或出错）， SocketChannel 支持这一非阻塞 IO 。
</code></pre><p>int OP_READ</p>
<p>int OP_WRITE</p>
<pre><code>     代表了读、写操作。
</code></pre><p>以下是其主要方法：</p>
<p>Object attachment()</p>
<p>返回 SelectionKey 的 attachment ， attachment 可以在注册 channel 的时候指定。</p>
<p>Object attach(Object ob)</p>
<pre><code>     设置 SelectionKey 的 attachment 。
</code></pre><p>SelectableChannel channel()</p>
<pre><code>     返回该 SelectionKey 对应的 channel 。
</code></pre><p>Selector selector()</p>
<pre><code>     返回该 SelectionKey 对应的 Selector 。
</code></pre><p>void cancel()</p>
<pre><code>   cancel 这个 SelectionKey 所对应的注册关系。
</code></pre><p>int interestOps()</p>
<pre><code>     返回代表需要 Selector 监控的 IO 操作的 bit mask 。
</code></pre><p>SelectionKey interestOps(int ops)</p>
<pre><code>     设置 interestOps 。
</code></pre><p>int readyOps()</p>
<pre><code>     返回一个 bit mask ，代表在相应 channel 上可以进行的 IO 操作。
</code></pre><p><strong>ServerSocketChannel</strong></p>
<p>支持非阻塞操作，对应于 java.net.ServerSocket 这个类，提供了 TCP 协议 IO 接口，支持 OP_ACCEPT 操作。</p>
<p>ServerSocket socket()</p>
<pre><code>     返回对应的 ServerSocket 对象。
</code></pre><p>SocketChannel accept()</p>
<pre><code>     接受一个连接，返回代表这个连接的 SocketChannel 对象。
</code></pre><p><strong>SocketChannel</strong></p>
<p>支持非阻塞操作，对应于 java.net.Socket 这个类，提供了 TCP 协议 IO 接口，支持 OP_CONNECT ， OP_READ 和 OP_WRITE 操作。这个类还实现了 ByteChannel ， ScatteringByteChannel 和 GatheringByteChannel 接口。</p>
<p>DatagramChannel 和这个类比较相似，其对应于 java.net.DatagramSocket ，提供了 UDP 协议 IO 接口。</p>
<p>Socket socket()</p>
<pre><code>     返回对应的 Socket 对象。
</code></pre><p>boolean connect(SocketAddress remote)</p>
<p>boolean finishConnect()</p>
<p>connect() 进行一个连接操作。如果当前 SocketChannel 是 blocking 模式，这个函数会等到连接操作完成或错误发生才返回。如果当前 SocketChannel 是 non-blocking 模式，函数在连接能立刻被建立时返回 true ，否则函数返回 false ，应用程序需要在以后用 finishConnect() 方法来完成连接操作。</p>
<p><strong>Pipe</strong></p>
<p>包含了一个读和一个写的 channel(Pipe.SourceChannel 和 Pipe.SinkChannel) ，这对 channel 可以用于进程中的通讯。</p>
<p><strong>FileChannel</strong></p>
<p>用于对文件的读、写、映射、锁定等操作。和映射操作相关的类有 FileChannel.MapMode ，和锁定操作相关的类有 FileLock 。值得注意的是 FileChannel 并不支持非阻塞操作。</p>
<p><strong>Channels</strong></p>
<p>这个类提供了一系列 static 方法来支持 stream 类和 channel 类之间的互操作。这些方法可以将 channel 类包装为 stream 类，比如，将 ReadableByteChannel 包装为 InputStream 或 Reader ；也可以将 stream 类包装为 channel 类，比如，将 OutputStream 包装为 WritableByteChannel 。</p>
<p>Package java.nio.charset</p>
<p>这个包定义了 Charset 及相应的 encoder 和 decoder 。下面这张 UML 类图描述了这个包中类的关系，可以将其中 Charset ， CharsetDecoder 和 CharsetEncoder 理解成一个 Abstract Factory 模式的实现：</p>
<p><img src="" alt=""></p>
<p><strong>Charset</strong></p>
<p>代表了一个字符集，同时提供了 factory method 来构建相应的 CharsetDecoder 和 CharsetEncoder 。</p>
<p>Charset 提供了以下 static 的方法：</p>
<p>SortedMap availableCharsets()</p>
<pre><code>     返回当前系统支持的所有 Charset 对象，用 charset 的名字作为 set 的 key 。
</code></pre><p>boolean isSupported(String charsetName)</p>
<pre><code>     判断该名字对应的字符集是否被当前系统支持。
</code></pre><p>Charset forName(String charsetName)</p>
<pre><code>     返回该名字对应的 Charset 对象。
</code></pre><p>Charset 中比较重要的方法有：</p>
<p>String name()</p>
<pre><code>     返回该字符集的规范名。
</code></pre><p>Set aliases()</p>
<pre><code>     返回该字符集的所有别名。
</code></pre><p>CharsetDecoder newDecoder()</p>
<pre><code>     创建一个对应于这个 Charset 的 decoder 。
</code></pre><p>CharsetEncoder newEncoder()</p>
<pre><code>     创建一个对应于这个 Charset 的 encoder 。
</code></pre><p><strong>CharsetDecoder</strong></p>
<p>将按某种字符集编码的字节流解码为 unicode 字符数据的引擎。</p>
<p>CharsetDecoder 的输入是 ByteBuffer ，输出是 CharBuffer 。进行 decode 操作时一般按如下步骤进行：</p>
<p>1． 调用 CharsetDecoder 的 reset() 方法。（第一次使用时可不调用）</p>
<p>2． 调用 decode() 方法 0 到 n 次，将 endOfInput 参数设为 false ，告诉 decoder 有可能还有新的数据送入。</p>
<p>3． 调用 decode() 方法最后一次，将 endOfInput 参数设为 true ，告诉 decoder 所有数据都已经送入。</p>
<p>4． 调用 decoder 的 flush() 方法。让 decoder 有机会把一些内部状态写到输出的 CharBuffer 中。</p>
<p>CharsetDecoder reset()</p>
<pre><code>     重置 decoder ，并清除 decoder 中的一些内部状态。
</code></pre><p>CoderResult decode(ByteBuffer in, CharBuffer out, boolean endOfInput)</p>
<p>从 ByteBuffer 类型的输入中 decode 尽可能多的字节，并将结果写到 CharBuffer 类型的输出中。根据 decode 的结果，可能返回 3 种 CoderResult ： CoderResult.UNDERFLOW 表示已经没有输入可以 decode ； CoderResult.OVERFLOW 表示输出已满；其它的 CoderResult 表示 decode 过程中有错误发生。根据返回的结果，应用程序可以采取相应的措施，比如，增加输入，清除输出等等，然后再次调用 decode() 方法。</p>
<p>CoderResult flush(CharBuffer out)</p>
<p>有些 decoder 会在 decode 的过程中保留一些内部状态，调用这个方法让这些 decoder 有机会将这些内部状态写到输出的 CharBuffer 中。调用成功返回 CoderResult.UNDERFLOW 。如果输出的空间不够，该函数返回 CoderResult.OVERFLOW ，这时应用程序应该扩大输出 CharBuffer 的空间，然后再次调用该方法。</p>
<p>CharBuffer decode(ByteBuffer in)</p>
<p>一个便捷的方法把 ByteBuffer 中的内容 decode 到一个新创建的 CharBuffer 中。在这个方法中包括了前面提到的 4 个步骤，所以不能和前 3 个函数一起使用。</p>
<p>decode 过程中的错误有两种： malformed-input CoderResult 表示输入中数据有误； unmappable-character CoderResult 表示输入中有数据无法被解码成 unicode 的字符。如何处理 decode 过程中的错误取决于 decoder 的设置。对于这两种错误， decoder 可以通过 CodingErrorAction 设置成：</p>
<p>1． 忽略错误</p>
<p>2． 报告错误。（这会导致错误发生时， decode() 方法返回一个表示该错误的 CoderResult 。）</p>
<p>3． 替换错误，用 decoder 中的替换字串替换掉有错误的部分。</p>
<p>CodingErrorAction malformedInputAction()</p>
<pre><code>     返回 malformed-input 的出错处理。
</code></pre><p>CharsetDecoder onMalformedInput(CodingErrorAction newAction)</p>
<pre><code>     设置 malformed-input 的出错处理。
</code></pre><p>CodingErrorAction unmappableCharacterAction()</p>
<pre><code>     返回 unmappable-character 的出错处理。
</code></pre><p>CharsetDecoder onUnmappableCharacter(CodingErrorAction newAction)</p>
<pre><code>     设置 unmappable-character 的出错处理。
</code></pre><p>String replacement()</p>
<pre><code>     返回 decoder 的替换字串。
</code></pre><p>CharsetDecoder replaceWith(String newReplacement)</p>
<pre><code>     设置 decoder 的替换字串。
</code></pre><p><strong>CharsetEncoder</strong></p>
<p>将 unicode 字符数据编码为特定字符集的字节流的引擎。其接口和 CharsetDecoder 相类似。</p>
<p><strong>CoderResult</strong></p>
<p>描述 encode/decode 操作结果的类。</p>
<p>CodeResult 包含两个 static 成员：</p>
<p>CoderResult OVERFLOW</p>
<pre><code>     表示输出已满
</code></pre><p>CoderResult UNDERFLOW</p>
<pre><code>     表示输入已无数据可用。
</code></pre><p>其主要的成员函数有：</p>
<p>boolean isError()</p>
<p>boolean isMalformed()</p>
<p>boolean isUnmappable()</p>
<p>boolean isOverflow()</p>
<p>boolean isUnderflow()</p>
<pre><code>     用于判断该 CoderResult 描述的错误。
</code></pre><p>int length()</p>
<pre><code>     返回错误的长度，比如，无法被转换成 unicode 的字节长度。
</code></pre><p>void throwException()</p>
<pre><code>     抛出一个和这个 CoderResult 相对应的 exception 。
</code></pre><p><strong>CodingErrorAction</strong></p>
<p>表示 encoder/decoder 中错误处理方法的类。可将其看成一个 enum 类型。有以下 static 属性：</p>
<p>CodingErrorAction IGNORE</p>
<pre><code>     忽略错误。
</code></pre><p>CodingErrorAction REPLACE</p>
<pre><code>     用替换字串替换有错误的部分。
</code></pre><p>CodingErrorAction REPORT</p>
<p>报告错误，对于不同的函数，有可能是返回一个和错误有关的 CoderResult ，也有可能是抛出一个 CharacterCodingException 。
posted on 2007-01-12 20:07 <a href="http://www.blogjava.net/19851985lili/" target="_blank">☜♥☞MengChuChen</a> 阅读(6999) <a href="">评论(0)</a>  <a href="http://www.blogjava.net/19851985lili/admin/EditArticles.aspx?postid=93524" target="_blank">编辑</a>  <a href="http://www.blogjava.net/19851985lili/AddToFavorite.aspx?id=93524" target="_blank">收藏</a> <img src="" alt=""></p>
<p><a href="http://www.blogjava.net/RequireRegister.aspx" target="_blank">新用户注册</a>  <a href="">刷新评论列表</a>  </p>
<p><a href=""></a> <a href="http://www.aliyun.com/cps/channel?channel_id=1306&amp;user=0&amp;lv=1">推荐购买云服务器（15%返利+最高千元奖金）</a>   <a href="http://www.cnblogs.com/" target="_blank">博客园</a>  <a href="http://q.cnblogs.com/" target="_blank">博问</a>  <a href="http://news.cnblogs.com/" target="_blank">IT新闻</a>  <a href="http://job.cnblogs.com/cate-java_programmer/" target="_blank">Java程序员招聘</a> 标题  请输入标题 姓名  请输入你的姓名 主页 请输入验证码 验证码 /*  <img src="http://www.blogjava.net/Modules/CaptchaImage/JpegImage.aspx?cacheid=20130718160740" alt=""> 内容(请不要发表任何与政治相关的内容) 请输入评论内容 Remember Me?   <a href="http://www.blogjava.net/login.aspx?ReturnURL=http://www.blogjava.net/19851985lili/articles/93524.html&amp;SourceURL=/19851985lili/articles/93524.html" target="_blank">登录</a>       [使用Ctrl+Enter键可以直接提交]      网站导航:</p>
<p><a href="http://www.cnblogs.com/" title="程序员的网上家园" target="_blank">博客园</a>   <a href="http://news.cnblogs.com/" target="_blank">IT新闻</a>   <a href="http://kb.cnblogs.com/" target="_blank">知识库</a>   <a href="http://www.cppblog.com/" target="_blank">C++博客</a>   <a href="http://job.cnblogs.com/" target="_blank">程序员招聘</a>   <a href="http://www.blogjava.net/19851985lili/articles/93524.html?opt=admin" target="_blank">管理</a><br>Copyright ©2013 ☜♥☞MengChuChen Powered By<a href="http://www.blogjava.net/" target="_blank">博客园</a> 模板提供：<a href="http://blog.hjenglish.com/" target="_blank">沪江博客</a></p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/NIO/">NIO</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/NIO/" class="label label-success">NIO</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:41"datetime="2014-03-07 09:54:41"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-NIO--JavaNIOAPI详解/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-NIO--JavaNIOAPI详解" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-NIO--Javaaio异步网络IO初探/">Java aio(异步网络IO)初探</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:41.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-NIO--Javaaio异步网络IO初探/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="java-aio-io-">Java aio(异步网络IO)初探</h1>
<p><a href="">&lt;</a> <a href="">&gt;</a>  猎头职位: <a href="http://www.iteye.com/jobs/2509" target="_blank">上海:  Junior Product Manager</a></p>
<p>相关文章: <a href="&quot;关闭&quot;"> </a></p>
<ul>
<li><a href="http://www.iteye.com/topic/1113611" title="JDK7 AIO 初体验" target="_blank">JDK7 AIO 初体验</a></li>
<li><a href="http://www.iteye.com/topic/446298" title="JavaSE7新特性 异步非阻塞I/O 网络通信 AIO" target="_blank">JavaSE7新特性 异步非阻塞I/O 网络通信 AIO</a></li>
<li><p><a href="http://www.iteye.com/topic/834447" title="JAVA NIO 简介" target="_blank">JAVA NIO 简介</a>
推荐群组: <a href="http://dlang.group.iteye.com/" target="_blank">D语言</a>
<a href="http://www.iteye.com/wiki/topic/472333" target="_blank">更多相关推荐</a>
<a href="http://www.iteye.com/forums/tag/%E4%BC%81%E4%B8%9A%E5%BA%94%E7%94%A8" target="_blank">企业应用</a></p>
<p>  按照《Unix网络编程》的划分，IO模型可以分为：阻塞IO、非阻塞IO、IO复用、信号驱动IO和异步IO，按照POSIX标准来划分只分为两类：同步IO和异步IO。如何区分呢？首先一个IO操作其实分成了两个步骤：发起IO请求和实际的IO操作，同步IO和异步IO的区别就在于第二个步骤是否阻塞，如果实际的IO读写阻塞请求进程，那么就是同步IO，因此阻塞IO、非阻塞IO、IO服用、信号驱动IO都是同步IO，如果不阻塞，而是操作系统帮你做完IO操作再将结果返回给你，那么就是异步IO。阻塞IO和非阻塞IO的区别在于第一步，发起IO请求是否会被阻塞，如果阻塞直到完成那么就是传统的阻塞IO，如果不阻塞，那么就是非阻塞IO。
 Java nio 2.0的主要改进就是引入了异步IO（包括文件和网络），这里主要介绍下异步网络IO API的使用以及框架的设计，以TCP服务端为例。首先看下为了支持AIO引入的新的类和接口：
<strong>java.nio.channels.AsynchronousChannel</strong></p>
<pre><code> 标记一个channel支持异步IO操作。
</code></pre><p><strong> java.nio.channels.AsynchronousServerSocketChannel</strong></p>
<pre><code> ServerSocket的aio版本，创建TCP服务端，绑定地址，监听端口等。
</code></pre><p><strong> java.nio.channels.AsynchronousSocketChannel</strong></p>
<pre><code> 面向流的异步socket channel，表示一个连接。
</code></pre><p><strong> java.nio.channels.AsynchronousChannelGroup</strong></p>
<pre><code> 异步channel的分组管理，目的是为了资源共享。一个AsynchronousChannelGroup绑定一个线程池，这个线程池执行两个任务：处理IO事件和派发CompletionHandler。AsynchronousServerSocketChannel创建的时候可以传入一个 AsynchronousChannelGroup，那么通过AsynchronousServerSocketChannel创建的 AsynchronousSocketChannel将同属于一个组，共享资源。
</code></pre><p><strong> java.nio.channels.CompletionHandler</strong></p>
<pre><code> 异步IO操作结果的回调接口，用于定义在IO操作完成后所作的回调工作。AIO的API允许两种方式来处理异步操作的结果：返回的Future模式或者注册CompletionHandler，我更推荐用CompletionHandler的方式，这些handler的调用是由 AsynchronousChannelGroup的线程池派发的。显然，线程池的大小是性能的关键因素。AsynchronousChannelGroup允许绑定不同的线程池，通过三个静态方法来创建：
</code></pre></li>
</ul>
<p>Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>public static AsynchronousChannelGroup withFixedThreadPool(int nThreads,  </li>
<li>ThreadFactory threadFactory)  </li>
<li>throws IOException  </li>
<li></li>
<li>public static AsynchronousChannelGroup withCachedThreadPool(ExecutorService executor,  </li>
<li>int initialSize)  </li>
<li></li>
<li>public static AsynchronousChannelGroup withThreadPool(ExecutorService executor)  </li>
<li>throws IOException  </li>
</ol>
<p>public static AsynchronousChannelGroup withFixedThreadPool(int nThreads,</p>
<pre><code>                                                           ThreadFactory threadFactory)
    throws IOException
</code></pre><p>public static AsynchronousChannelGroup withCachedThreadPool(ExecutorService executor,</p>
<pre><code>                                                            int initialSize)
</code></pre><p>public static AsynchronousChannelGroup withThreadPool(ExecutorService executor)
        throws IOException</p>
<pre><code> 需要根据具体应用相应调整，从框架角度出发，需要暴露这样的配置选项给用户。
 在介绍完了aio引入的TCP的主要接口和类之后，我们来设想下一个aio框架应该怎么设计。参考非阻塞nio框架的设计，一般都是采用**Reactor**模式，Reacot负责事件的注册、select、事件的派发；相应地，异步IO有个**Proactor**模式，Proactor负责 CompletionHandler的派发，查看一个典型的IO写操作的流程来看两者的区别：
 Reactor:  send(msg) -&gt; 消息队列是否为空，如果为空  -&gt; 向Reactor注册OP_WRITE，然后返回 -&gt; Reactor select -&gt; 触发Writable，通知用户线程去处理 -&gt;先注销Writable(很多人遇到的cpu 100%的问题就在于没有注销）,处理Writeable，如果没有完全写入，继续注册OP_WRITE。注意到，写入的工作还是用户线程在处理。
 Proactor: send(msg) -&gt; 消息队列是否为空，如果为空,发起read异步调用，并注册CompletionHandler，然后返回。 -&gt; 操作系统负责将你的消息写入，并返回结果（写入的字节数）给Proactor -&gt; Proactor派发CompletionHandler。可见，写入的工作是操作系统在处理，无需用户线程参与。事实上在aio的API 中,**AsynchronousChannelGroup就扮演了Proactor的角色**。
CompletionHandler有三个方法，分别对应于处理成功、失败、被取消（通过返回的Future)情况下的回调处理：
</code></pre><p>Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>public interface CompletionHandler<V,A> {  </li>
<li></li>
<li>void completed(V result, A attachment);  </li>
<li></li>
<li>void failed(Throwable exc, A attachment);  </li>
<li></li>
<li></li>
<li>void cancelled(A attachment);  </li>
<li>}  </li>
</ol>
<p>public interface CompletionHandler<V,A> {</p>
<pre><code> void completed(V result, A attachment);


void failed(Throwable exc, A attachment);




void cancelled(A attachment);
</code></pre><p>}</p>
<pre><code>其中的泛型参数V表示IO调用的结果，而A是发起调用时传入的attchment。
在初步介绍完aio引入的类和接口后，我们看看一个典型的tcp服务端是怎么启动的，怎么接受连接并处理读和写，这里引用的代码都是yanf4j 的aio分支中的代码，可以从svn checkout，svn地址: [http://yanf4j.googlecode.com/svn/branches/yanf4j-aio](http://yanf4j.googlecode.com/svn/branches/yanf4j-aio)
第一步，创建一个AsynchronousServerSocketChannel，创建之前先创建一个 AsynchronousChannelGroup，上文提到AsynchronousServerSocketChannel可以绑定一个 AsynchronousChannelGroup，那么通过这个AsynchronousServerSocketChannel建立的连接都将同属于一个AsynchronousChannelGroup并共享资源：
</code></pre><p>Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>this.asynchronousChannelGroup = AsynchronousChannelGroup  </li>
<li>.withCachedThreadPool(Executors.newCachedThreadPool(),  </li>
<li>this.threadPoolSize);  </li>
</ol>
<p>this.asynchronousChannelGroup = AsynchronousChannelGroup</p>
<pre><code>                .withCachedThreadPool(Executors.newCachedThreadPool(),
                        this.threadPoolSize);

 然后初始化一个AsynchronousServerSocketChannel，通过open方法：
</code></pre><p>Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>this.serverSocketChannel = AsynchronousServerSocketChannel  </li>
<li>.open(this.asynchronousChannelGroup);  </li>
</ol>
<p>this.serverSocketChannel = AsynchronousServerSocketChannel</p>
<pre><code>            .open(this.asynchronousChannelGroup);


通过nio 2.0引入的SocketOption类设置一些TCP选项：
</code></pre><p>Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>this.serverSocketChannel  </li>
<li>.setOption(  </li>
<li>StandardSocketOption.SO_REUSEADDR,true);  </li>
<li>this.serverSocketChannel  </li>
<li>.setOption(  </li>
<li>StandardSocketOption.SO_RCVBUF,16/*1024);  </li>
</ol>
<p>this.serverSocketChannel</p>
<pre><code>                .setOption(
                        StandardSocketOption.SO_REUSEADDR,true);
</code></pre><p>this.serverSocketChannel
                    .setOption(</p>
<pre><code>                        StandardSocketOption.SO_RCVBUF,16/*1024);


绑定本地地址：
</code></pre><p>Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>this.serverSocketChannel  </li>
<li>.bind(new InetSocketAddress(&quot;localhost&quot;,8080), 100);  </li>
</ol>
<p>this.serverSocketChannel</p>
<pre><code>                .bind(new InetSocketAddress(&quot;localhost&quot;,8080), 100);



其中的100用于指定等待连接的队列大小(backlog)。完了吗？还没有，最重要的**监听**工作还没开始，监听端口是为了等待连接上来以便accept产生一个AsynchronousSocketChannel来表示一个新建立的连接，因此需要发起一个accept调用，调用是异步的，操作系统将在连接建立后，将最后的结果——**AsynchronousSocketChannel**返回给你：
</code></pre><p>Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>public void pendingAccept() {  </li>
<li>if (this.started &amp;&amp; this.serverSocketChannel.isOpen()) {  </li>
<li>this.acceptFuture = this.serverSocketChannel.accept(null,  </li>
<li>new AcceptCompletionHandler());  </li>
<li></li>
<li>} else {  </li>
<li>throw new IllegalStateException(&quot;Controller has been closed&quot;);  </li>
<li>}  </li>
<li>}  </li>
</ol>
<p>public void pendingAccept() {</p>
<pre><code>    if (this.started &amp;&amp; this.serverSocketChannel.isOpen()) {
        this.acceptFuture = this.serverSocketChannel.accept(null,

                new AcceptCompletionHandler());


    } else {
        throw new IllegalStateException(&quot;Controller has been closed&quot;);

    }
}
</code></pre><p>   注意，重复的accept调用将会抛出PendingAcceptException，后文提到的read和write也是如此。accept方法的第一个参数是你想传给CompletionHandler的attchment，第二个参数就是注册的用于回调的CompletionHandler，最后返回结果Future<AsynchronousSocketChannel>。你可以对future做处理，这里采用更推荐的方式就是注册一个CompletionHandler。那么accept的CompletionHandler中做些什么工作呢？显然一个赤裸裸的 AsynchronousSocketChannel是不够的，我们需要将它封装成session，一个session表示一个连接（mina里就叫 IoSession了），里面带了一个缓冲的消息队列以及一些其他资源等。在连接建立后，除非你的服务器只准备接受一个连接，不然你需要在后面<strong>继续调用pendingAccept来发起另一个accept请求</strong>：</p>
<p>Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>private final class AcceptCompletionHandler implements  </li>
<li>CompletionHandler<AsynchronousSocketChannel, Object> {  </li>
<li></li>
<li>@Override  </li>
<li>public void cancelled(Object attachment) {  </li>
<li>logger.warn(&quot;Accept operation was canceled&quot;);  </li>
<li>}  </li>
<li></li>
<li>@Override  </li>
<li>public void completed(AsynchronousSocketChannel socketChannel,  </li>
<li>Object attachment) {  </li>
<li>try {  </li>
<li>logger.debug(&quot;Accept connection from &quot;  </li>
<li><ul>
<li>socketChannel.getRemoteAddress());  </li>
</ul>
</li>
<li>configureChannel(socketChannel);  </li>
<li>AioSessionConfig sessionConfig = buildSessionConfig(socketChannel);  </li>
<li>Session session = new AioTCPSession(sessionConfig,  </li>
<li>AioTCPController.this.configuration  </li>
<li>.getSessionReadBufferSize(),  </li>
<li>AioTCPController.this.sessionTimeout);  </li>
<li>session.start();  </li>
<li>registerSession(session);  </li>
<li>} catch (Exception e) {  </li>
<li>e.printStackTrace();  </li>
<li>logger.error(&quot;Accept error&quot;, e);  </li>
<li>notifyException(e);  </li>
<li>} finally {  </li>
<li><strong>pendingAccept</strong>();  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>@Override  </li>
<li>public void failed(Throwable exc, Object attachment) {  </li>
<li>logger.error(&quot;Accept error&quot;, exc);  </li>
<li>try {  </li>
<li>notifyException(exc);  </li>
<li>} finally {  </li>
<li><strong>pendingAccept</strong>();  </li>
<li>}  </li>
<li>}  </li>
<li>}  </li>
</ol>
<p>private final class AcceptCompletionHandler implements</p>
<pre><code>        CompletionHandler&lt;AsynchronousSocketChannel, Object&gt; {


    @Override
    public void cancelled(Object attachment) {

        logger.warn(&quot;Accept operation was canceled&quot;);
    }


    @Override

    public void completed(AsynchronousSocketChannel socketChannel,
            Object attachment) {

        try {
            logger.debug(&quot;Accept connection from &quot;

                    + socketChannel.getRemoteAddress());
            configureChannel(socketChannel);

            AioSessionConfig sessionConfig = buildSessionConfig(socketChannel);
            Session session = new AioTCPSession(sessionConfig,

                    AioTCPController.this.configuration
                            .getSessionReadBufferSize(),

                    AioTCPController.this.sessionTimeout);
            session.start();

            registerSession(session);
        } catch (Exception e) {

            e.printStackTrace();
            logger.error(&quot;Accept error&quot;, e);

            notifyException(e);
        } finally {
</code></pre><p><strong>pendingAccept</strong></p>
<p>();
            }</p>
<pre><code>    }


    @Override
    public void failed(Throwable exc, Object attachment) {

        logger.error(&quot;Accept error&quot;, exc);
        try {

            notifyException(exc);
        } finally {
</code></pre><p><strong>pendingAccept</strong></p>
<p>();
            }</p>
<pre><code>    }
}



注意到了吧，我们在failed和completed方法中在最后都调用了pendingAccept来继续发起accept调用，等待新的连接上来。有的同学可能要说了，这样搞是不是递归调用，会不会堆栈溢出？实际上不会，因为发起accept调用的线程与CompletionHandler回调的线程并非同一个，不是一个上下文中，两者之间没有耦合关系。要注意到，CompletionHandler的回调共用的是 AsynchronousChannelGroup绑定的线程池，因此**千万别在CompletionHandler回调方法中调用阻塞或者长时间的操作**，例如sleep，回调方法最好能支持超时，防止线程池耗尽。
连接建立后，怎么读和写呢？回忆下在nonblocking nio框架中，连接建立后的第一件事是干什么？注册OP_READ事件等待socket可读。异步IO也同样如此，连接建立后马上发起一个异步read调用，等待socket可读，这个是Session.start方法中所做的事情：
</code></pre><p>Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>public class AioTCPSession {  </li>
<li>protected void start0() {  </li>
<li>pendingRead();  </li>
<li>}  </li>
<li></li>
<li>protected final void pendingRead() {  </li>
<li>if (!isClosed() &amp;&amp; this.asynchronousSocketChannel.isOpen()) {  </li>
<li>if (!this.readBuffer.hasRemaining()) {  </li>
<li>this.readBuffer = ByteBufferUtils  </li>
<li>.increaseBufferCapatity(this.readBuffer);  </li>
<li>}  </li>
<li>this.readFuture = this.asynchronousSocketChannel.read(  </li>
<li>this.readBuffer, this, this.readCompletionHandler);  </li>
<li>} else {  </li>
<li>throw new IllegalStateException(  </li>
<li>&quot;Session Or Channel has been closed&quot;);  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>}  </li>
</ol>
<p>public class AioTCPSession {</p>
<pre><code>protected void start0() {
    pendingRead();

}


protected final void pendingRead() {
    if (!isClosed() &amp;&amp; this.asynchronousSocketChannel.isOpen()) {

        if (!this.readBuffer.hasRemaining()) {
            this.readBuffer = ByteBufferUtils

                    .increaseBufferCapatity(this.readBuffer);
        }

        this.readFuture = this.asynchronousSocketChannel.read(
                this.readBuffer, this, this.readCompletionHandler);

    } else {
        throw new IllegalStateException(

                &quot;Session Or Channel has been closed&quot;);
    }

}
</code></pre><p>}</p>
<pre><code> AsynchronousSocketChannel的read调用与AsynchronousServerSocketChannel的accept调用类似，同样是非阻塞的，返回结果也是一个Future，但是写的结果是整数，表示写入了多少字节，因此read调用返回的是 **Future&lt;Integer&gt;**，方法的第一个参数是读的缓冲区，操作系统将IO读到数据拷贝到这个缓冲区，第二个参数是传递给 CompletionHandler的attchment，第三个参数就是注册的用于回调的CompletionHandler。这里保存了read的结果Future，这是为了在关闭连接的时候能够主动取消调用，accept也是如此。现在可以看看read的CompletionHandler的实现：
</code></pre><p>Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>public final class ReadCompletionHandler implements  </li>
<li>CompletionHandler<Integer, AbstractAioSession> {  </li>
<li></li>
<li>private static final Logger log = LoggerFactory  </li>
<li>.getLogger(ReadCompletionHandler.class);  </li>
<li>protected final AioTCPController controller;  </li>
<li></li>
<li>public ReadCompletionHandler(AioTCPController controller) {  </li>
<li>this.controller = controller;  </li>
<li>}  </li>
<li></li>
<li>@Override  </li>
<li>public void cancelled(AbstractAioSession session) {  </li>
<li>log.warn(&quot;Session(&quot; + session.getRemoteSocketAddress()  </li>
<li><ul>
<li>&quot;) read operation was canceled&quot;);  </li>
</ul>
</li>
<li>}  </li>
<li></li>
<li>@Override  </li>
<li>public void completed(Integer result, AbstractAioSession session) {  </li>
<li>if (log.isDebugEnabled())  </li>
<li>log.debug(&quot;Session(&quot; + session.getRemoteSocketAddress()  </li>
<li><ul>
<li>&quot;) read +&quot; + result + &quot; bytes&quot;);  </li>
</ul>
</li>
<li>if (result &lt; 0) {  </li>
<li>session.close();  </li>
<li>return;  </li>
<li>}  </li>
<li>try {  </li>
<li>if (result &gt; 0) {  </li>
<li>session.updateTimeStamp();  </li>
<li>session.getReadBuffer().flip();  </li>
<li>session.decode();  </li>
<li>session.getReadBuffer().compact();  </li>
<li>}  </li>
<li>} finally {  </li>
<li>try {  </li>
<li>session.pendingRead();  </li>
<li>} catch (IOException e) {  </li>
<li>session.onException(e);  </li>
<li>session.close();  </li>
<li>}  </li>
<li>}  </li>
<li>controller.checkSessionTimeout();  </li>
<li>}  </li>
<li></li>
<li>@Override  </li>
<li>public void failed(Throwable exc, AbstractAioSession session) {  </li>
<li>log.error(&quot;Session read error&quot;, exc);  </li>
<li>session.onException(exc);  </li>
<li>session.close();  </li>
<li>}  </li>
<li></li>
<li>}  </li>
</ol>
<p>public final class ReadCompletionHandler implements</p>
<pre><code>    CompletionHandler&lt;Integer, AbstractAioSession&gt; {


private static final Logger log = LoggerFactory
        .getLogger(ReadCompletionHandler.class);

protected final AioTCPController controller;


public ReadCompletionHandler(AioTCPController controller) {
    this.controller = controller;

}


@Override
public void cancelled(AbstractAioSession session) {

    log.warn(&quot;Session(&quot; + session.getRemoteSocketAddress()
            + &quot;) read operation was canceled&quot;);

}


@Override
public void completed(Integer result, AbstractAioSession session) {

    if (log.isDebugEnabled())
        log.debug(&quot;Session(&quot; + session.getRemoteSocketAddress()

                + &quot;) read +&quot; + result + &quot; bytes&quot;);
    if (result &lt; 0) {

        session.close();
        return;

    }
    try {

        if (result &gt; 0) {
            session.updateTimeStamp();

            session.getReadBuffer().flip();
            session.decode();

            session.getReadBuffer().compact();
        }

    } finally {
        try {

            session.pendingRead();
        } catch (IOException e) {

            session.onException(e);
            session.close();

        }
    }

    controller.checkSessionTimeout();
}


@Override

public void failed(Throwable exc, AbstractAioSession session) {
    log.error(&quot;Session read error&quot;, exc);

    session.onException(exc);
    session.close();

}
</code></pre><p>}</p>
<p>   如果IO读失败，会返回失败产生的异常，这种情况下我们就主动关闭连接，通过session.close()方法，这个方法干了两件事情：关闭channel和取消read调用：</p>
<p>Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>if (null != this.readFuture) {  </li>
<li>this.readFuture.cancel(true);  </li>
<li>}  </li>
<li>this.asynchronousSocketChannel.close();  </li>
</ol>
<p>if (null != this.readFuture) {</p>
<pre><code>        this.readFuture.cancel(true);
    }
</code></pre><p>this.asynchronousSocketChannel.close();</p>
<p>   在读成功的情况下，我们还需要判断结果result是否小于0，<strong>如果小于0就表示对端关闭了</strong>，这种情况下我们也主动关闭连接并返回。如果读到一定字节，也就是result大于0的情况下，我们就尝试从读缓冲区中decode出消息，并派发给业务处理器的回调方法，最终<strong>通过pendingRead继续发起read调用等待socket的下一次可读</strong>。可见，我们并不需要自己去调用channel来进行IO读，而是操作系统帮你直接读到了缓冲区，然后给你一个结果表示读入了多少字节，你处理这个结果即可。而nonblocking IO框架中，是reactor通知用户线程socket可读了，然后用户线程自己去调用read进行实际读操作。这里还有个需要注意的地方，就是decode出来的消息的派发给业务处理器工作最好交给一个线程池来处理，避免阻塞group绑定的线程池。</p>
<p>   IO写的操作与此类似，不过通常写的话我们会在session中关联一个缓冲队列来处理，没有完全写入或者等待写入的消息都存放在队列中，队列为空的情况下发起write调用：</p>
<p>Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>protected void write0(WriteMessage message) {  </li>
<li>boolean needWrite = false;  </li>
<li>synchronized (this.writeQueue) {  </li>
<li>needWrite = this.writeQueue.isEmpty();  </li>
<li>this.writeQueue.offer(message);  </li>
<li>}  </li>
<li>if (needWrite) {  </li>
<li>pendingWrite(message);  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>protected final void pendingWrite(WriteMessage message) {  </li>
<li>message = preprocessWriteMessage(message);  </li>
<li>if (!isClosed() &amp;&amp; this.asynchronousSocketChannel.isOpen()) {  </li>
<li>this.asynchronousSocketChannel.write(message.getWriteBuffer(),  </li>
<li>this, this.writeCompletionHandler);  </li>
<li>} else {  </li>
<li>throw new IllegalStateException(  </li>
<li>&quot;Session Or Channel has been closed&quot;);  </li>
<li>}  </li>
<li><p>}  </p>
<p>protected void write0(WriteMessage message) {</p>
<p>   boolean needWrite = false;
   synchronized (this.writeQueue) {</p>
<pre><code>   needWrite = this.writeQueue.isEmpty();
   this.writeQueue.offer(message);
</code></pre><p>   }
   if (needWrite) {</p>
<pre><code>   pendingWrite(message);
</code></pre><p>   }</p>
<p>}</p>
</li>
</ol>
<pre><code>protected final void pendingWrite(WriteMessage message) {
    message = preprocessWriteMessage(message);

    if (!isClosed() &amp;&amp; this.asynchronousSocketChannel.isOpen()) {
        this.asynchronousSocketChannel.write(message.getWriteBuffer(),

                this, this.writeCompletionHandler);
    } else {

        throw new IllegalStateException(
                &quot;Session Or Channel has been closed&quot;);

    }
}




write调用返回的结果与read一样是一个Future&lt;Integer&gt;，而write的CompletionHandler处理的核心逻辑大概是这样：
</code></pre><p>Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>@Override  </li>
<li>public void completed(Integer result, AbstractAioSession session) {  </li>
<li>if (log.isDebugEnabled())  </li>
<li>log.debug(&quot;Session(&quot; + session.getRemoteSocketAddress()  </li>
<li><ul>
<li>&quot;) writen &quot; + result + &quot; bytes&quot;);  </li>
</ul>
</li>
<li></li>
<li>WriteMessage writeMessage;  </li>
<li>Queue<WriteMessage> writeQueue = session.getWriteQueue();  </li>
<li>synchronized (writeQueue) {  </li>
<li>writeMessage = writeQueue.peek();  </li>
<li>if (writeMessage.getWriteBuffer() == null  </li>
<li>|| !writeMessage.getWriteBuffer().hasRemaining()) {  </li>
<li>writeQueue.remove();  </li>
<li>if (writeMessage.getWriteFuture() != null) {  </li>
<li>writeMessage.getWriteFuture().setResult(Boolean.TRUE);  </li>
<li>}  </li>
<li>try {  </li>
<li>session.getHandler().onMessageSent(session,  </li>
<li>writeMessage.getMessage());  </li>
<li>} catch (Exception e) {  </li>
<li>session.onException(e);  </li>
<li>}  </li>
<li>writeMessage = writeQueue.peek();  </li>
<li>}  </li>
<li>}  </li>
<li>if (writeMessage != null) {  </li>
<li>try {  </li>
<li>session.pendingWrite(writeMessage);  </li>
<li>} catch (IOException e) {  </li>
<li>session.onException(e);  </li>
<li>session.close();  </li>
<li>}  </li>
<li>}  </li>
<li>}  </li>
</ol>
<p>@Override</p>
<pre><code>public void completed(Integer result, AbstractAioSession session) {
    if (log.isDebugEnabled())

        log.debug(&quot;Session(&quot; + session.getRemoteSocketAddress()
                + &quot;) writen &quot; + result + &quot; bytes&quot;);


    WriteMessage writeMessage;

    Queue&lt;WriteMessage&gt; writeQueue = session.getWriteQueue();
    synchronized (writeQueue) {

        writeMessage = writeQueue.peek();
        if (writeMessage.getWriteBuffer() == null

                || !writeMessage.getWriteBuffer().hasRemaining()) {
            writeQueue.remove();

            if (writeMessage.getWriteFuture() != null) {
                writeMessage.getWriteFuture().setResult(Boolean.TRUE);

            }
            try {

                session.getHandler().onMessageSent(session,
                        writeMessage.getMessage());

            } catch (Exception e) {
                session.onException(e);

            }
            writeMessage = writeQueue.peek();

        }
    }

    if (writeMessage != null) {
        try {

            session.pendingWrite(writeMessage);
        } catch (IOException e) {

            session.onException(e);
            session.close();

        }
    }

}
</code></pre><p>   compete方法中的result就是实际写入的字节数，然后我们判断消息的缓冲区是否还有剩余，如果没有就将消息从队列中移除，如果队列中还有消息，那么继续发起write调用。
   重复一下，这里引用的代码都是yanf4j aio分支中的源码，感兴趣的朋友可以直接check out出来看看: <a href="http://yanf4j.googlecode.com/svn/branches/yanf4j-aio" target="_blank"><a href="http://yanf4j.googlecode.com/svn/branches/yanf4j-aio">http://yanf4j.googlecode.com/svn/branches/yanf4j-aio</a></a>。
   在引入了aio之后，java对于网络层的支持已经非常完善，该有的都有了，java也已经成为服务器开发的首选语言之一。java的弱项在于对内存的管理上，由于这一切都交给了GC，因此在高性能的网络服务器上还是Cpp的天下。java这种单一堆模型比之erlang的进程内堆模型还是有差距，很难做到高效的垃圾回收和细粒度的内存管理。
   这里仅仅是介绍了aio开发的核心流程，对于一个网络框架来说，还需要考虑超时的处理、缓冲buffer的处理、业务层和网络层的切分、可扩展性、性能的可调性以及一定的通用性要求。</p>
<p>刚看了一点，第一行有个错别字，不是IO服用，是复用，嘿嘿
老大终于开始介绍java NIO了。。
还有一点，看过一些源代码，对事件驱动还是理解不深，也请老大介绍下把。
rain2005 写道</p>
<p>刚看了一点，第一行有个错别字，不是IO服用，是复用，嘿嘿
老大终于开始介绍java NIO了。。
还有一点，看过一些源代码，对事件驱动还是理解不深，也请老大介绍下把。
多谢指正，关于事件机制，我会画个UML图可能比较清晰</p>
<p>上面提到几个类 怎么在jdk6中没发现那
是不是要下载第三方框架
正好想研究一下
收藏啦
xly_971223 写道</p>
<p>上面提到几个类 怎么在jdk6中没发现那
是不是要下载第三方框架
正好想研究一下
收藏啦
aio是在jdk7引入的，请下载JDK7 preview1版本，或者open jdk</p>
<p>dennis_zane 写道</p>
<p>xly_971223 写道</p>
<p>上面提到几个类 怎么在jdk6中没发现那
是不是要下载第三方框架
正好想研究一下
收藏啦
aio是在jdk7引入的，请下载JDK7 preview1版本，或者open jdk
是不是这个意思。
jdk7以前的nio是非阻塞IO,操作系统底层比方说linux,是用IO复用select实现的
jdk7用的是真正的异步IO,操作系统底层是用epoll实现的
是这样的吗？
rain2005 写道</p>
<p>dennis_zane 写道</p>
<p>xly_971223 写道</p>
<p>上面提到几个类 怎么在jdk6中没发现那
是不是要下载第三方框架
正好想研究一下
收藏啦
aio是在jdk7引入的，请下载JDK7 preview1版本，或者open jdk
是不是这个意思。
jdk7以前的nio是非阻塞IO,操作系统底层比方说linux,是用IO复用select实现的
jdk7用的是真正的异步IO,操作系统底层是用epoll实现的
是这样的吗？
epoll也不是异步IO啊。异步IO在linux上目前仅限于文件系统，并且还没有得到广泛应用，很多平台都没有这玩意。
java aio在windows上是利用iocp实现的，这是真正的异步IO。而在linux上，是通过epoll模拟的。</p>
<p>楼主，你好，我写的server是p2p的应用，恩，想请教一下，因为我对数据库这一块的操作并不是特别的多，基本是客户自己也有很多是服务器，不知道是否可以在事件响应的当前线程来对数据库操作呢？前提是把线程池子的数目设的大些？或者用那个JDK提供的可自己增加线程的池子？
因为如果在弄个池子来处理数据库的话，担心线程太多了，
你如果时间充分心情好的话，真希望你能讲解一下和别人公用一台服务器（主机）是怎么用的呢。。。
总之要谢谢你对这段代码的讲解，kang sang mi da
wujingsong 写道</p>
<p>楼主，你好，我写的server是p2p的应用，恩，想请教一下，因为我对数据库这一块的操作并不是特别的多，基本是客户自己也有很多是服务器，不知道是否可以在事件响应的当前线程来对数据库操作呢？前提是把线程池子的数目设的大些？或者用那个JDK提供的可自己增加线程的池子？
因为如果在弄个池子来处理数据库的话，担心线程太多了，
你如果时间充分心情好的话，真希望你能讲解一下和别人公用一台服务器（主机）是怎么用的呢。。。
总之要谢谢你对这段代码的讲解，kang sang mi da
按我的经验来说，类似数据库操作这样的IO操作，最好还是起个线程池来处理，防止阻塞框架内部的处理线程。如果这样的操作不是特别多，那么直接在响应线程处理也未尝不可，还是建议你自己搞两个版本性能对比一下。
wujingsong 写道</p>
<p>和别人公用一台是怎么用的呢？
我还真不明白什么意思，现在我们的应用基本都跑在虚拟机上了，几个应用跑在一个物理机上。虚拟化我不懂，就不乱弹了。</p>
<p>kang sa mi da,谢谢楼主的回复,确实是个很好的建议.
闲聊啊,今天无意看到Google 上一个音乐的图片链接,点进去后,看到了一个不大容易理解的词,说什么
            &quot;在南中国常年保持高收听率的极有个性的节目&quot;,
费解.....广东那边是这么叫的吗?不大可能吧..</p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/NIO/">NIO</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/NIO/" class="label label-success">NIO</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:41"datetime="2014-03-07 09:54:41"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-NIO--Javaaio异步网络IO初探/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-NIO--Javaaio异步网络IO初探" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-NIO--javanio网络编程的一点心得/">java nio网络编程的一点心得</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:41.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-NIO--javanio网络编程的一点心得/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="java-nio-">java nio网络编程的一点心得</h1>
<p>前几日用java nio写了一个<a href="http://code.google.com/p/marlon-tools/source/browse/tools/tcpmon/TCPMonitorSelect.java" target="_blank">tcp端口转发小工具</a>，还颇费周折，其中一个原因在于网上资料很混乱，不少还是错误的。这篇文章中我会以一个EchoServer作为例子。先看<a href="http://book.douban.com/subject/1438754/" target="_blank">《Java网络编程》</a>中的写法，这也是在网上颇为常见的一个写法。
Java代码  <a href="&quot;收藏这段代码&quot;"><img src="http://marlonyao.iteye.com/images/icon_star.png" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>public class EchoServer {  </li>
<li>public static int DEFAULT_PORT = 7777;  </li>
<li></li>
<li>public static void main(String[] args) throws IOException {  </li>
<li>System.out.println(&quot;Listening for connection on port &quot; + DEFAULT_PORT);  </li>
<li></li>
<li>Selector selector = Selector.open();  </li>
<li>initServer(selector);  </li>
<li></li>
<li>while (true) {  </li>
<li>selector.select();  </li>
<li></li>
<li>for (Iterator<SelectionKey> itor = selector.selectedKeys().iterator(); itor.hasNext();) {  </li>
<li>SelectionKey key = (SelectionKey) itor.next();  </li>
<li>itor.remove();  </li>
<li>try {  </li>
<li>if (key.isAcceptable()) {  </li>
<li>ServerSocketChannel server = (ServerSocketChannel) key.channel();  </li>
<li>SocketChannel client = server.accept();  </li>
<li>System.out.println(&quot;Accepted connection from &quot; + client);  </li>
<li>client.configureBlocking(false);  </li>
<li>SelectionKey clientKey = client.register(selector, SelectionKey.OP_WRITE|SelectionKey.OP_READ);  </li>
<li>ByteBuffer buffer = ByteBuffer.allocate(100);  </li>
<li>clientKey.attach(buffer);  </li>
<li>}  </li>
<li>if (key.isReadable()) {  </li>
<li>SocketChannel client = (SocketChannel) key.channel();  </li>
<li>ByteBuffer buffer = (ByteBuffer) key.attachment();  </li>
<li>client.read(buffer);  </li>
<li>}  </li>
<li>if (key.isWritable()) {  </li>
<li>// System.out.println(&quot;is writable...&quot;);  </li>
<li>SocketChannel client = (SocketChannel) key.channel();  </li>
<li>ByteBuffer buffer = (ByteBuffer) key.attachment();  </li>
<li>buffer.flip();  </li>
<li>client.write(buffer);  </li>
<li>buffer.compact();  </li>
<li>}  </li>
<li>} catch (IOException e) {  </li>
<li>key.cancel();  </li>
<li>try { key.channel().close(); } catch (IOException ioe) { }  </li>
<li>}  </li>
<li>}  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>private static void initServer(Selector selector) throws IOException,  </li>
<li>ClosedChannelException {  </li>
<li>ServerSocketChannel serverChannel = ServerSocketChannel.open();  </li>
<li>ServerSocket ss = serverChannel.socket();  </li>
<li>ss.bind(new InetSocketAddress(DEFAULT_PORT));  </li>
<li>serverChannel.configureBlocking(false);  </li>
<li>serverChannel.register(selector, SelectionKey.OP_ACCEPT);  </li>
<li>}  </li>
<li>}  </li>
</ol>
<p>public class EchoServer {</p>
<pre><code>public static int DEFAULT_PORT = 7777;


public static void main(String[] args) throws IOException {
    System.out.println(&quot;Listening for connection on port &quot; + DEFAULT_PORT);


    Selector selector = Selector.open();

    initServer(selector);


    while (true) {
        selector.select();


        for (Iterator&lt;SelectionKey&gt; itor = selector.selectedKeys().iterator(); itor.hasNext();) {

            SelectionKey key = (SelectionKey) itor.next();
            itor.remove();

            try {
                if (key.isAcceptable()) {

                    ServerSocketChannel server = (ServerSocketChannel) key.channel();
                    SocketChannel client = server.accept();

                    System.out.println(&quot;Accepted connection from &quot; + client);
                    client.configureBlocking(false);

                    SelectionKey clientKey = client.register(selector, SelectionKey.OP_WRITE|SelectionKey.OP_READ);
                    ByteBuffer buffer = ByteBuffer.allocate(100);

                    clientKey.attach(buffer);
                }

                if (key.isReadable()) {
                    SocketChannel client = (SocketChannel) key.channel();

                    ByteBuffer buffer = (ByteBuffer) key.attachment();
                    client.read(buffer);

                }
                if (key.isWritable()) {

                    // System.out.println(&quot;is writable...&quot;);
                    SocketChannel client = (SocketChannel) key.channel();

                    ByteBuffer buffer = (ByteBuffer) key.attachment();
                    buffer.flip();

                    client.write(buffer);
                    buffer.compact();

                }
            } catch (IOException e) {

                key.cancel();
                try { key.channel().close(); } catch (IOException ioe) { }

            }
        }

    }
}


private static void initServer(Selector selector) throws IOException,

        ClosedChannelException {
    ServerSocketChannel serverChannel = ServerSocketChannel.open();

    ServerSocket ss = serverChannel.socket();
    ss.bind(new InetSocketAddress(DEFAULT_PORT));

    serverChannel.configureBlocking(false);
    serverChannel.register(selector, SelectionKey.OP_ACCEPT);

}
</code></pre><p>}
上面的代码很典型，运行结果似乎也是正确的。
Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>marlon$ java EchoServer&amp;  </li>
<li>--&gt; Listening for connection on port 7777  </li>
<li>marlon$ telnet localhost 7777  </li>
<li>--&gt; Accepted connection from java.nio.channels.SocketChannel[connected local=/127.0.0.1:7777 remote=/127.0.0.1:65030]  </li>
<li>hello  </li>
<li>--&gt; hello  </li>
<li>world  </li>
<li>--&gt;world  </li>
</ol>
<p>marlon$ java EchoServer&amp;</p>
<p>--&gt; Listening for connection on port 7777
marlon$ telnet localhost 7777</p>
<p>--&gt; Accepted connection from java.nio.channels.SocketChannel[connected local=/127.0.0.1:7777 remote=/127.0.0.1:65030]
hello</p>
<p>--&gt; hello
world</p>
<p>--&gt;world
但是如果你这时top用看一下发现服务器进程CPU占用到95%以上，如果取消掉32行的注释，服务器会不断地输出&quot;is writable...&quot;，这是为什么呢？让我们来分析当第一个客户端连接上时发生什么情况。</p>
<ol>
<li>在连接之前，服务器第11行：selector.select()处阻塞。当阻塞时，内核会将这个进程调度至休眠状态，此时基本不耗CPU。</li>
<li>当客户端发起一个连接时，服务器检测到客户端连接，selector.select()返回。selector.selectedKeys()返回已就绪的SelectionKey的集合，在这种情况下，它只包含一个key，也就是53行注册的acceptable key。服务器开始运行17-25行的代码，server.accept()返回代码客户端连接的socket，第22行在socket上注册OP_READ和OP_WRITE，表示当socket可读或者可写时就会通知selector。</li>
<li>接着服务器又回到第11行，尽管这时客户端还没有任何输入，但这时selector.select()不会阻塞，因为22行在socket注册了写操作，而socket只要send buffer不满就可以写，刚开始send buffer为空，socket总是可以写，于是server.select()立即返回，包含在22行注册的key。由于这个key可写，所以服务器会运行31-38行的代码，但是这时buffer为空，client.write(buffer)没有向socket写任何东西，立即返回0。</li>
<li><p>接着服务器又回到第11行，由于客户端连接socket可以写，这时selector.select()会立即返回，然后运行31-38行的代码，像步骤3一样，由于buffer为空，服务器没有干任何事又返回到第11行，这样不断循环，服务器却实际没有干事情，却耗大量的CPU。
从上面的分析可以看出问题在于我们在没有数据可写时就在socket上注册了OP_WRITE，导致服务器浪费大量CPU资源，解决办法是<strong>只有数据可以写时才注册OP_WRITE操作</strong>。上面的版本还不只浪费CPU那么简单，它还可能导致潜在的死锁。虽然死锁在我的机器上没有发生，对于这个简单的例子似乎也不大可能发生在别的机器上，但是在对于复杂的情况，比如我写的端口转发工具中就发生了，这还依赖于jdk的实现。对于上面的EchoServer，出现死锁的场景是这样的：</p>
</li>
<li><p>假设服务器已经启动，并且已经有一个客户端与它相连，此时正如上面的分析，服务器在不断地循环做无用功。这时用户在客户端输入&quot;hello&quot;。</p>
</li>
<li><p>当服务器运行到第11行：selector.select()时，这时selector.selectedKeys()会返回一个代表客户端连接的key，显然这时客户端socket是既可读又可写，但jdk却并不保证能够检测到两种状态。如果它检测到key既可读又可写，那么服务器会执行26-38行的代码。如果只检测到可读，那么服务器会执行26-30行的代码。如果只检测到可写，那么会执行31－38行的代码。对于前两种情况，不会造成死锁，因为当执行完29行，buffer会读到用户输入的内容，下次再运行到36行就可以将用户输入内容echo回。但是对最后一种情况，服务器完全忽略了客户端发过来的内容，如果每次selector.select()都只能检测到socket可写，那么服务器永远不能将echo回客户端输入的内容。
避免死锁的一个简单方法就是<strong>不要在同一个socket同时注册多个操作</strong>。对于上面的EchoServer来说就是不要同时注册OP_READ和OP_WRITE，要么只注册OP_READ，要么只注册OP_WRITE。下面的EchoServer修正了以上的错误：
Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>public static void main(String[] args) throws IOException {  </p>
</li>
<li>System.out.println(&quot;Listening for connection on port &quot; + DEFAULT_PORT);  </li>
<li></li>
<li>Selector selector = Selector.open();  </li>
<li>initServer(selector);  </li>
<li></li>
<li>while (true) {  </li>
<li>selector.select();  </li>
<li></li>
<li>for (Iterator<SelectionKey> itor = selector.selectedKeys().iterator(); itor.hasNext();) {  </li>
<li>SelectionKey key = (SelectionKey) itor.next();  </li>
<li>itor.remove();  </li>
<li>try {  </li>
<li>if (key.isAcceptable()) {  </li>
<li>ServerSocketChannel server = (ServerSocketChannel) key.channel();  </li>
<li>SocketChannel client = server.accept();  </li>
<li>System.out.println(&quot;Accepted connection from &quot; + client);  </li>
<li>client.configureBlocking(false);  </li>
<li>SelectionKey clientKey = client.register(selector, SelectionKey.OP_READ);  </li>
<li>ByteBuffer buffer = ByteBuffer.allocate(100);  </li>
<li>clientKey.attach(buffer);  </li>
<li>} else if (key.isReadable()) {  </li>
<li>SocketChannel client = (SocketChannel) key.channel();  </li>
<li>ByteBuffer buffer = (ByteBuffer) key.attachment();  </li>
<li>int n = client.read(buffer);  </li>
<li>if (n &gt; 0) {  </li>
<li>buffer.flip();  </li>
<li>key.interestOps(SelectionKey.OP_WRITE);     // switch to OP_WRITE  </li>
<li>}  </li>
<li>} else if (key.isWritable()) {  </li>
<li>System.out.println(&quot;is writable...&quot;);  </li>
<li>SocketChannel client = (SocketChannel) key.channel();  </li>
<li>ByteBuffer buffer = (ByteBuffer) key.attachment();  </li>
<li>client.write(buffer);  </li>
<li>if (buffer.remaining() == 0) {  // write finished, switch to OP_READ  </li>
<li>buffer.clear();  </li>
<li>key.interestOps(SelectionKey.OP_READ);  </li>
<li>}  </li>
<li>}  </li>
<li>} catch (IOException e) {  </li>
<li>key.cancel();  </li>
<li>try { key.channel().close(); } catch (IOException ioe) { }  </li>
<li>}  </li>
<li>}  </li>
<li>}  </li>
<li><p>}  </p>
<p> public static void main(String[] args) throws IOException {</p>
<pre><code> System.out.println(&quot;Listening for connection on port &quot; + DEFAULT_PORT);
</code></pre></li>
</ol>
<pre><code>    Selector selector = Selector.open();
    initServer(selector);


    while (true) {

        selector.select();


        for (Iterator&lt;SelectionKey&gt; itor = selector.selectedKeys().iterator(); itor.hasNext();) {
            SelectionKey key = (SelectionKey) itor.next();

            itor.remove();
            try {

                if (key.isAcceptable()) {
                    ServerSocketChannel server = (ServerSocketChannel) key.channel();

                    SocketChannel client = server.accept();
                    System.out.println(&quot;Accepted connection from &quot; + client);

                    client.configureBlocking(false);
                    SelectionKey clientKey = client.register(selector, SelectionKey.OP_READ);

                    ByteBuffer buffer = ByteBuffer.allocate(100);
                    clientKey.attach(buffer);

                } else if (key.isReadable()) {
                    SocketChannel client = (SocketChannel) key.channel();

                    ByteBuffer buffer = (ByteBuffer) key.attachment();
                    int n = client.read(buffer);

                    if (n &gt; 0) {
                        buffer.flip();

                        key.interestOps(SelectionKey.OP_WRITE);        // switch to OP_WRITE
                    }

                } else if (key.isWritable()) {
                    System.out.println(&quot;is writable...&quot;);

                    SocketChannel client = (SocketChannel) key.channel();
                    ByteBuffer buffer = (ByteBuffer) key.attachment();

                    client.write(buffer);
                    if (buffer.remaining() == 0) {    // write finished, switch to OP_READ

                        buffer.clear();
                        key.interestOps(SelectionKey.OP_READ);

                    }
                }

            } catch (IOException e) {
                key.cancel();

                try { key.channel().close(); } catch (IOException ioe) { }
            }

        }
    }

}
</code></pre><p>主要变化，在第19行接受客户端连接时只注册OP_READ操作，第28行当读到数据时才切换到OP_WRITE操作，第35-38行，当写操作完成时再切换到OP_READ操作。由于一个key同时只能执行一个操作，我将原来三个并行if换成了if...else。
上面的代码不够优雅，它将处理服务器Socket和客户连接Socket的代码搅在一起，对于简单的EchoServer这样做没什么问题，当服务器变得复杂，使用命令模式将它们分开变显得非常必要。首先创建一个接口来抽象对SelectionKey的处理。
Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>interface Handler {  </li>
<li>void execute(Selector selector, SelectionKey key);  </li>
<li><p>}  </p>
<p> interface Handler {</p>
<pre><code> void execute(Selector selector, SelectionKey key);
</code></pre><p> }
再来看main函数：
Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>public static void main(String[] args) throws IOException {  </p>
</li>
<li>System.out.println(&quot;Listening for connection on port &quot; + DEFAULT_PORT);  </li>
<li></li>
<li>Selector selector = Selector.open();  </li>
<li>initServer(selector);  </li>
<li></li>
<li>while (true) {  </li>
<li>selector.select();  </li>
<li></li>
<li>for (Iterator<SelectionKey> itor = selector.selectedKeys().iterator(); itor.hasNext();) {  </li>
<li>SelectionKey key = (SelectionKey) itor.next();  </li>
<li>itor.remove();  </li>
<li>Handler handler = (Handler) key.attachment();  </li>
<li>handler.execute(selector, key);  </li>
<li>}  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>private static void initServer(Selector selector) throws IOException,  </li>
<li>ClosedChannelException {  </li>
<li>ServerSocketChannel serverChannel = ServerSocketChannel.open();  </li>
<li>ServerSocket ss = serverChannel.socket();  </li>
<li>ss.bind(new InetSocketAddress(DEFAULT_PORT));  </li>
<li>serverChannel.configureBlocking(false);  </li>
<li>SelectionKey serverKey = serverChannel.register(selector, SelectionKey.OP_ACCEPT);  </li>
<li>serverKey.attach(new ServerHandler());  </li>
<li><p>}  </p>
<p> public static void main(String[] args) throws IOException {</p>
<pre><code> System.out.println(&quot;Listening for connection on port &quot; + DEFAULT_PORT);
</code></pre></li>
</ol>
<pre><code>    Selector selector = Selector.open();
    initServer(selector);


    while (true) {

        selector.select();


        for (Iterator&lt;SelectionKey&gt; itor = selector.selectedKeys().iterator(); itor.hasNext();) {
            SelectionKey key = (SelectionKey) itor.next();

            itor.remove();
            Handler handler = (Handler) key.attachment();

            handler.execute(selector, key);
        }

    }
}


private static void initServer(Selector selector) throws IOException,

        ClosedChannelException {
    ServerSocketChannel serverChannel = ServerSocketChannel.open();

    ServerSocket ss = serverChannel.socket();
    ss.bind(new InetSocketAddress(DEFAULT_PORT));

    serverChannel.configureBlocking(false);
    SelectionKey serverKey = serverChannel.register(selector, SelectionKey.OP_ACCEPT);

    serverKey.attach(new ServerHandler());
}
</code></pre><p>main函数非常简单，迭代SelectionKey，对每个key的attachment为Handler，调用它的execute的方法，不用管它是服务器Socket还是客户Socket。注意initServer方法将serverKey附加了一个ServerHandler。下面是ServerHandler的代码：
Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>class ServerHandler implements Handler {  </li>
<li>public void execute(Selector selector, SelectionKey key) {  </li>
<li>ServerSocketChannel server = (ServerSocketChannel) key.channel();  </li>
<li>SocketChannel client = null;  </li>
<li>try {  </li>
<li>client = server.accept();  </li>
<li>System.out.println(&quot;Accepted connection from &quot; + client);  </li>
<li>} catch (IOException e) {  </li>
<li>e.printStackTrace();  </li>
<li>return;  </li>
<li>}  </li>
<li></li>
<li>SelectionKey clientKey = null;  </li>
<li>try {  </li>
<li>client.configureBlocking(false);  </li>
<li>clientKey = client.register(selector, SelectionKey.OP_READ);  </li>
<li>clientKey.attach(new ClientHandler());  </li>
<li>} catch (IOException e) {  </li>
<li>if (clientKey != null)  </li>
<li>clientKey.cancel();  </li>
<li>try { client.close(); } catch (IOException ioe) { }  </li>
<li>}  </li>
<li>}  </li>
<li><p>}  </p>
<p> class ServerHandler implements Handler {</p>
<pre><code> public void execute(Selector selector, SelectionKey key) {
     ServerSocketChannel server = (ServerSocketChannel) key.channel();

     SocketChannel client = null;
     try {

         client = server.accept();
         System.out.println(&quot;Accepted connection from &quot; + client);

     } catch (IOException e) {
         e.printStackTrace();

         return;
     }
</code></pre></li>
</ol>
<pre><code>        SelectionKey clientKey = null;

        try {
            client.configureBlocking(false);

            clientKey = client.register(selector, SelectionKey.OP_READ);
            clientKey.attach(new ClientHandler());

        } catch (IOException e) {
            if (clientKey != null)

                clientKey.cancel();
            try { client.close(); } catch (IOException ioe) { }

        }
    }

}
</code></pre><p>ServerHandler接收连接，为每个客户Socket注册OP_READ操作，返回的clientKey附加上ClientHandler。
Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>class ClientHandler implements Handler {  </li>
<li>private ByteBuffer buffer;  </li>
<li></li>
<li>public ClientHandler() {  </li>
<li>buffer = ByteBuffer.allocate(100);  </li>
<li>}  </li>
<li></li>
<li>public void execute(Selector selector, SelectionKey key) {  </li>
<li>try {  </li>
<li>if (key.isReadable()) {  </li>
<li>readKey(selector, key);  </li>
<li>} else if (key.isWritable()) {  </li>
<li>writeKey(selector, key);  </li>
<li>}  </li>
<li>} catch (IOException e) {  </li>
<li>key.cancel();  </li>
<li>try { key.channel().close(); } catch (IOException ioe) { }  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>private void readKey(Selector selector, SelectionKey key) throws IOException {  </li>
<li>SocketChannel client = (SocketChannel) key.channel();  </li>
<li>int n = client.read(buffer);  </li>
<li>if (n &gt; 0) {  </li>
<li>buffer.flip();  </li>
<li>key.interestOps(SelectionKey.OP_WRITE);     // switch to OP_WRITE  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>private void writeKey(Selector selector, SelectionKey key) throws IOException {  </li>
<li>// System.out.println(&quot;is writable...&quot;);  </li>
<li>SocketChannel client = (SocketChannel) key.channel();  </li>
<li>client.write(buffer);  </li>
<li>if (buffer.remaining() == 0) {  // write finished, switch to OP_READ  </li>
<li>buffer.clear();  </li>
<li>key.interestOps(SelectionKey.OP_READ);  </li>
<li>}  </li>
<li>}  </li>
<li><p>}  </p>
<p> class ClientHandler implements Handler {</p>
<pre><code> private ByteBuffer buffer;
</code></pre></li>
</ol>
<pre><code>    public ClientHandler() {
        buffer = ByteBuffer.allocate(100);

    }


    public void execute(Selector selector, SelectionKey key) {
        try {

            if (key.isReadable()) {
                readKey(selector, key);

            } else if (key.isWritable()) {
                writeKey(selector, key);

            }
        } catch (IOException e) {

            key.cancel();
            try { key.channel().close(); } catch (IOException ioe) { }

        }
    }


    private void readKey(Selector selector, SelectionKey key) throws IOException {

        SocketChannel client = (SocketChannel) key.channel();
        int n = client.read(buffer);

        if (n &gt; 0) {
            buffer.flip();

            key.interestOps(SelectionKey.OP_WRITE);        // switch to OP_WRITE
        }

    }


    private void writeKey(Selector selector, SelectionKey key) throws IOException {
        // System.out.println(&quot;is writable...&quot;);

        SocketChannel client = (SocketChannel) key.channel();
        client.write(buffer);

        if (buffer.remaining() == 0) {    // write finished, switch to OP_READ
            buffer.clear();

            key.interestOps(SelectionKey.OP_READ);
        }

    }
}
</code></pre><p>这个代码没有什么新内容，只是将根据key是可读还可写拆分为两个方法，代码结构显得更清晰。对于EchoServer，这么做确实有些过度工程，对于稍微复杂一点的服务器这么做是很值得的。
代码：<a href="http://pastebin.com/de64ZzUy" target="_blank">EchoServer.java</a>, <a href="http://pastebin.com/fFy0Uhbm" target="_blank">EchoServer2.java</a>, <a href="http://pastebin.com/DRMT4LdJ" target="_blank">EchoServer3.java</a>
参考：</p>
<ol>
<li><a href="http://rox-xmlrpc.sourceforge.net/niotut/" target="_blank">The Rox Java NIO Tutorial</a></li>
<li><a href="http://today.java.net/pub/a/today/2007/02/13/architecture-of-highly-scalable-nio-server.html" target="_blank">Architecture of a Highly Scalable NIO-Based Server</a></li>
</ol>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/NIO/">NIO</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/NIO/" class="label label-success">NIO</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:41"datetime="2014-03-07 09:54:41"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-NIO--javanio网络编程的一点心得/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-NIO--javanio网络编程的一点心得" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-java深入分析--JDKJREJVM区别/">JDKJREJVM区别</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:41.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-java深入分析--JDKJREJVM区别/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="jdkjrejvm-">JDKJREJVM区别</h1>
<p><strong><a href="http://java-mzd.iteye.com/blog/838514" target="_blank">JDK,JRE,JVM区别与联系</a></strong></p>
<p><strong>文章分类**</strong>:<a href="http://www.iteye.com/blogs/category/java" target="_blank">Java编程</a>**</p>
<pre><code>很多朋友可能跟我一样，已经使用JAVA开发很久了，可是对JDK,JRE,JVM这三者的联系与区别，一直都是模模糊糊的。

今天特写此文，来整理下三者的关系。



JDK : Java Development ToolKit(Java开发工具包)。JDK是整个JAVA的核心，包括了Java运行环境（Java Runtime Envirnment），一堆Java工具（javac/java/jdb等）和Java基础的类库（即Java API 包括rt.jar）。

最主流的JDK是Sun公司发布的JDK，除了Sun之外，还有很多公司和组织都开发了属于自己的JDK，例如国外IBM公司开发了属于自己的JDK，国内淘宝也开发了属于自己的JDK，各个组织开发自己的JDK都是为了在某些方面得到一些提高，以适应自己的需求，比如IBM的JDK据说运行效率就比SUN的JDK高的多。但不管怎么说，我们还是需要先把基础的Sun JDK掌握好。

JDK有以下三种版本：
</code></pre><p>J2SE，standard edition，标准版，是我们通常用的一个版本J2EE，enterpsise edtion，企业版，使用这种JDK开发J2EE应用程序J2ME，micro edtion，主要用于移动设备、嵌入式设备上的java应用程序</p>
<pre><code>我们常常用JDK来代指Java API，Java API是Java的应用程序接口，其实就是前辈们写好的一些java Class，包括一些重要的语言结构以及基本图形，网络和文件I/O等等 ，我们在自己的程序中，调用前辈们写好的这些Class，来作为我们自己开发的一个基础。当然，现在已经有越来越多的性能更好或者功能更强大的第三方类库供我们使用。



JRE:Java  Runtime  Enviromental(java运行时环境)。也就是我们说的JAVA平台，所有的Java程序都要在JRE下才能运行。包括JVM和JAVA核心类库和支持文件。与JDK相比，它不包含开发工具——编译器、调试器和其它工具。



JVM：Java Virtual Mechinal(JAVA虚拟机)。JVM是JRE的一部分，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。JVM有自己完善的硬件架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。JVM 的主要工作是解释自己的指令集（即字节码）并映射到本地的 CPU 的指令集或 OS 的系统调用。Java语言是跨平台运行的，其实就是不同的操作系统，使用不同的JVM映射规则，让其与操作系统无关，完成了跨平台性。JVM 对上层的Java 源文件是不关心的，它关注的只是由源文件生成的类文件（ class file ）。类文件的组成包括JVM 指令集，符号表以及一些补助信息。
</code></pre><p>下图很好的表面了JDK,JRE,JVM三者间的关系：</p>
<p><img src="" alt="http://dl.iteye.com/upload/attachment/364841/7dbc84af-e878-3718-beb5-6471ad99b995.gif"></p>
<pre><code>我们开发的实际情况是：我们利用JDK（调用JAVA API）开发了属于我们自己的JAVA程序后，通过JDK中的编译程序（javac）将我们的文本java文件编译成JAVA字节码，在JRE上运行这些JAVA字节码，JVM解析这些字节码，映射到CPU指令集或OS的系统调用。
</code></pre><p>url: <a href="http://java-mzd.iteye.com/blog/838514" target="_blank">http://java-mzd.iteye.com/blog/838514</a></p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/java深入分析/">java深入分析</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/java深入分析/" class="label label-success">java深入分析</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:41"datetime="2014-03-07 09:54:41"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-java深入分析--JDKJREJVM区别/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-java深入分析--JDKJREJVM区别" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--JVM调优总结（二）-一些概念-高级语言虚拟机/">JVM调优总结（二）</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:41.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--JVM调优总结（二）-一些概念-高级语言虚拟机/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="jvm-">JVM调优总结（二）-一些概念 - 高级语言虚拟机</h1>
<p><a href="http://hllvm.group.iteye.com/login" title="登录" target="_blank">您还未登录 !</a> <a href="http://hllvm.group.iteye.com/login" target="_blank">登录</a> <a href="http://hllvm.group.iteye.com/signup" target="_blank">注册</a></p>
<p><a href="http://www.iteye.com/" target="_blank"><img src="&quot;ITeye-最棒的软件开发交流社区&quot;" alt="ITeye3.0"></a></p>
<p><a href=""></a></p>
<p><a href="http://www.iteye.com/groups" target="_blank">群组首页</a> → <a href="http://hllvm.group.iteye.com/groups/category/language" target="_blank">编程语言</a> → <a href="http://hllvm.group.iteye.com/" target="_blank">高级语言虚拟机</a> → <a href="http://hllvm.group.iteye.com/group/wiki" target="_blank">知识库</a> → <a href="http://hllvm.group.iteye.com/group/wiki?category_id=301" target="_blank">JVM调优</a> → <a href="">JVM调优总结（二）-一些概念</a>
原创作者: <a href="http://www.javaeye.com/topic/519471" target="_blank">和你在一起</a>   阅读:4764次   评论:6条   更新时间:2011-05-26    </p>
<h2 id="java-">Java对象的大小</h2>
<pre><code>基本数据的类型的大小是固定的，这里就不多说了。对于非基本类型的Java对象，其大小就值得商榷。

在Java中，**一个空Object对象的大小是8byte**，这个大小只是保存堆中一个没有任何属性的对象的大小。看下面语句：
</code></pre><p>Object ob = new Object();</p>
<pre><code>这样在程序中完成了一个Java对象的生命，但是它所占的空间为：**4byte+8byte**。4byte是上面部分所说的Java栈中保存引用的所需要的空间。而那8byte则是Java堆中对象的信息。因为所有的Java非基本类型的对象都需要默认继承Object对象，因此不论什么样的Java对象，其大小都必须是大于8byte。
</code></pre><p>   有了Object对象的大小，我们就可以计算其他对象的大小了。
Class NewObject {</p>
<pre><code>int count;

boolean flag;

Object ob;
</code></pre><p>}</p>
<pre><code>其大小为：空对象大小(8byte)+int大小(4byte)+Boolean大小(1byte)+空Object引用的大小(4byte)=17byte。但是因为Java在对对象内存分配时都是以8的整数倍来分，因此大于17byte的最接近8的整数倍的是24，因此此对象的大小为24byte。

这里需要注意一下**基本类型的包装类型的大小**。因为这种包装类型已经成为对象了，因此需要把他们作为对象来看待。包装类型的大小至少是12byte（声明一个空Object至少需要的空间），而且12byte没有包含任何有效信息，同时，因为Java对象大小是8的整数倍，因此**一个基本类型包装类的大小至少是16byte**。这个内存占用是很恐怖的，它是使用基本类型的N倍（N&gt;2），有些类型的内存占用更是夸张（随便想下就知道了）。因此，可能的话应尽量少使用包装类。在JDK5.0以后，因为加入了自动类型装换，因此，Java虚拟机会在存储方面进行相应的优化。
</code></pre><h2 id="-">引用类型</h2>
<pre><code>对象引用类型分为**强引用、软引用、弱引用和虚引用**。
</code></pre><p><strong>强引用:</strong>就是我们一般声明对象是时虚拟机生成的引用，强引用环境下，垃圾回收时需要严格判断当前对象是否被强引用，如果被强引用，则不会被垃圾回收</p>
<p><strong>软引用:</strong>软引用一般被做为缓存来使用。与强引用的区别是，软引用在垃圾回收时，虚拟机会根据当前系统的剩余内存来决定是否对软引用进行回收。如果剩余内存比较紧张，则虚拟机会回收软引用所引用的空间；如果剩余内存相对富裕，则不会进行回收。换句话说，虚拟机在发生OutOfMemory时，肯定是没有软引用存在的。</p>
<p><strong>弱引用:</strong>弱引用与软引用类似，都是作为缓存来使用。但与软引用不同，弱引用在进行垃圾回收时，是一定会被回收掉的，因此其生命周期只存在于一个垃圾回收周期内。</p>
<pre><code>强引用不用说，我们系统一般在使用时都是用的强引用。而“软引用”和“弱引用”比较少见。他们一般被作为缓存使用，而且一般是在内存大小比较受限的情况下做为缓存。因为如果内存足够大的话，可以直接使用强引用作为缓存即可，同时可控性更高。因而，他们常见的是被使用在桌面应用系统的缓存。
</code></pre><p><a href="http://hllvm.group.iteye.com/group/wiki/2858-JVM" title="JVM调优总结（一）-- 一些概念" target="_blank">JVM调优总结（一）-- 一些概念</a> | <a href="http://hllvm.group.iteye.com/group/wiki/2861-JVM" title="JVM调优总结（三）-基本垃圾回收算法" target="_blank">JVM调优总结（三）-基本垃圾回收算法</a></p>
<p>评论 共 6 条 请<a href="http://hllvm.group.iteye.com/login" target="_blank">登录</a>后发表评论 <a href=""></a></p>
<h3 id="6-xianneng-lin-http-xianneng-lin-iteye-com-xianneng-lin-2012-11-21-15-47">6 楼 <a href="http://xianneng-lin.iteye.com/" title="xianneng.lin" target="_blank">xianneng.lin</a> 2012-11-21 15:47</h3>
<p>虚引用呢？</p>
<h3 id="5-xiaodatao-http-xiaodatao-iteye-com-xiaodatao-2012-01-19-16-43">5 楼 <a href="http://xiaodatao.iteye.com/" title="xiaodatao" target="_blank">xiaodatao</a> 2012-01-19 16:43</h3>
<p>基本数据的类型的大小是固定的。
Object ob = new Object();
    这样在程序中完成了一个Java对象的生命，但是它所占的空间为：4byte+8byte。4byte是Java栈中保存实例引用。<img src="" alt=""> <img src="" alt=""> </p>
<h3 id="4-shaomeng95-http-shaomeng95-iteye-com-shaomeng95-2011-07-08-13-13">4 楼 <a href="http://shaomeng95.iteye.com/" title="shaomeng95" target="_blank">shaomeng95</a> 2011-07-08 13:13</h3>
<p>官方文档上说：This data type represents one bit of information, but its &quot;size&quot; isn&#39;t something that&#39;s precisely defined.</p>
<h3 id="3-shaomeng95-http-shaomeng95-iteye-com-shaomeng95-2011-07-08-13-10">3 楼 <a href="http://shaomeng95.iteye.com/" title="shaomeng95" target="_blank">shaomeng95</a> 2011-07-08 13:10</h3>
<p>而且12byte没有包含</p>
<p>kthh0226 写道
这个有问题吧，java没有说明boolean的大小，不一定是1byte的
boolean的大小是依赖VM的</p>
<h3 id="2-kthh0226-http-kthh0226-iteye-com-kthh0226-2011-06-17-17-30">2 楼 <a href="http://kthh0226.iteye.com/" title="kthh0226" target="_blank">kthh0226</a> 2011-06-17 17:30</h3>
<p>这个有问题吧，java没有说明boolean的大小，不一定是1byte的</p>
<h3 id="1-smalltalker-http-smalltalker-iteye-com-smalltalker-2011-05-30-20-18">1 楼 <a href="http://smalltalker.iteye.com/" title="smalltalker" target="_blank">smalltalker</a> 2011-05-30 20:18</h3>
<p><img src="" alt=""></p>
<h3 id="-">发表评论</h3>
<p><a href="http://hllvm.group.iteye.com/login" target="_blank"><img src="" alt=""> 您还没有登录,请您登录后再发表评论</a></p>
<p><a href="http://hllvm.group.iteye.com/group/wiki/new" target="_blank"><img src="" alt="New-page"></a></p>
<h3 id="-">文章信息</h3>
<p><a href="http://hllvm.group.iteye.com/group/wiki/" target="_blank">知识库: 高级语言虚拟机</a></p>
<ul>
<li>由<a href="http://kiral.iteye.com/" title="fantasy" target="_blank">fantasy</a>在2010-11-08创建</li>
<li><p>由<a href="http://kiral.iteye.com/" title="fantasy" target="_blank">fantasy</a>在2011-05-26更新</p>
<h3 id="-">相关新闻</h3>
</li>
<li><p><a href="http://hllvm.group.iteye.com/news/25761" target="_blank">Leak Finder：谷歌的JavaScript内存泄露检测工具</a></p>
</li>
<li><a href="http://hllvm.group.iteye.com/news/16601" target="_blank">Azul Systems将要开源Managed Runtime Initiative中的重要技术</a></li>
<li><a href="http://hllvm.group.iteye.com/news/4" target="_blank">struts2新特性预览</a></li>
</ul>
<h3 id="-">相关讨论</h3>
<ul>
<li><a href="http://hllvm.group.iteye.com/topic/671298" target="_blank">封装ConcurrentHashMap成为具有各种引用类型key与value的ConcurrentReferenceMap，完美取代WeakHashMap</a></li>
<li><a href="http://hllvm.group.iteye.com/topic/1030509" target="_blank">关于java 垃圾回收的理解</a></li>
<li><a href="http://hllvm.group.iteye.com/topic/1039464" target="_blank">闲来无事，用Java的软引用写了一个山寨的缓存</a></li>
<li><a href="http://hllvm.group.iteye.com/topic/401478" target="_blank">理解 Java 的 GC 与 幽灵引用</a></li>
<li><p><a href="http://hllvm.group.iteye.com/topic/704710" target="_blank">关于ThreadLocal的内存泄露</a></p>
<h3 id="-">相关博客</h3>
</li>
<li><p><a href="http://hzbaihu.iteye.com/blog/961293" target="_blank">JVM概念中的Java对象的大小，以及三种引用类型的定义与区分</a></p>
</li>
<li><a href="http://jiaozhiguang-126-com.iteye.com/blog/1701027" target="_blank">JVM调优总结（二）-一些概念</a></li>
<li><a href="http://pengjiaheng.iteye.com/blog/519471" target="_blank">JVM调优总结（二）-一些概念</a></li>
<li><a href="http://qjbtj999.iteye.com/blog/660134" target="_blank">[转] JVM调优总结（二）-一些概念</a></li>
<li><a href="http://millerhu.iteye.com/blog/890685" target="_blank">JVM调优总结（二）-一些概念</a></li>
<li><a href="http://www.iteye.com/" target="_blank">首页</a></li>
<li><a href="http://www.iteye.com/news" target="_blank">资讯</a></li>
<li><a href="http://www.iteye.com/magazines" target="_blank">精华</a></li>
<li><a href="http://www.iteye.com/forums" target="_blank">论坛</a></li>
<li><a href="http://www.iteye.com/ask" target="_blank">问答</a></li>
<li><a href="http://www.iteye.com/blogs" target="_blank">博客</a></li>
<li><a href="http://www.iteye.com/blogs/subjects" target="_blank">专栏</a></li>
<li><a href="http://www.iteye.com/groups" target="_blank">群组</a></li>
<li><a href="http://job.iteye.com/iteye" target="_blank">招聘</a></li>
<li><a href="http://www.iteye.com/search" target="_blank">搜索</a></li>
<li><a href="http://hllvm.group.iteye.com/index/service" target="_blank">广告服务</a></li>
<li><a href="http://webmaster.iteye.com/" target="_blank">ITeye黑板报</a></li>
<li><a href="http://hllvm.group.iteye.com/index/contactus" target="_blank">联系我们</a></li>
<li><a href="http://hllvm.group.iteye.com/index/friend_links" target="_blank">友情链接</a></li>
</ul>
<p>© 2003-2012 ITeye.com. [ <a href="http://www.miibeian.gov.cn/" target="_blank">京ICP证110151号</a> 京公网安备110105010620 ]
百联优力(北京)投资有限公司 版权所有 <img src="http://stat.iteye.com/?url=http%3A%2F%2Fhllvm.group.iteye.com%2Fgroup%2Fwiki%2F2860-JVM&amp;referrer=http%3A%2F%2Fhllvm.group.iteye.com%2Fgroup%2Fwiki%2F%3Fcategory_id%3D301&amp;user_id=" alt=""></p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/JVM/">JVM</a></li></span></span> | <span class="tags">Tagged <a href="/tags/JVM/" class="label label-primary">JVM</a><a href="/tags/Java&J2EE/" class="label label-success">Java&J2EE</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:41"datetime="2014-03-07 09:54:41"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-JVM--JVM调优总结（二）-一些概念-高级语言虚拟机/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-JVM--JVM调优总结（二）-一些概念-高级语言虚拟机" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>





<ul id="pagination" class="pagination pagination-lg">
  <li><a class="extend prev" href="/page/53/">&laquo;</a></li><li><a class="page-number" href="/">1</a></li><li><a class="page-number" href="/page/2/">2</a></li><li><span class="space">&hellip;</span></li><li><a class="page-number" href="/page/51/">51</a></li><li><a class="page-number" href="/page/52/">52</a></li><li><a class="page-number" href="/page/53/">53</a></li><li class="active"><li><span class="page-number current">54</span></li><li><a class="page-number" href="/page/55/">55</a></li><li><a class="page-number" href="/page/56/">56</a></li><li><a class="page-number" href="/page/57/">57</a></li><li><span class="space">&hellip;</span></li></li><li><a class="page-number" href="/page/162/">162</a></li><li><a class="page-number" href="/page/163/">163</a></li><li><a class="extend next" href="/page/55/">&raquo;</a></li>
  <div class="clearfix"></div>
</ul></div><!--wapper-->
       </div><!-- ID main-col END -->
       <aside id="sidebar" class="alignright col-sx-6 col-sm-4 col-md-3 col-lg-3">
<div id="widget_search" class="widget panel panel-primary">
    <form action="//google.com/search" method="get" accept-charset="utf-8">
  <div class="input-group">
    <input class="form-control" id="searchbox" type="search" name="q" results="0" placeholder="search">
    <span class="input-group-btn">
      <button class="btn btn-default" type="submit">Go!</button>
    </span>
    <input type="hidden" name="q" value="site:itsolife.com">
  </div>
</form>
</div>

<div id="widget_category" class="widget panel panel-primary">
  <div class="panel-heading">category</div>  <div data-src='category' class='ajax_widgets'>正在加载...</div>
</div>

<div id="widget_recent_posts" class="widget panel panel-primary">
  <div class="panel-heading">recent posts</div>  <div data-src='recent_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_tagcloud" class="widget panel panel-primary">
  <div class="panel-heading">tagcloud</div>  <div data-src='tagcloud' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_latest_update_posts" class="widget panel panel-primary">
  <div class="panel-heading">最近更新</div>  <div data-src='latest_update_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_recent_comments" class="widget panel panel-primary">
  <div class="panel-heading">recent comments</div>  

<div class="list-group-item ds-recent-comments" data-num-items="6" data-show-avatars="1" data-show-time="1" data-show-title="1" data-show-admin="1" data-excerpt-length="50"></div>



</div>

</aside>
       <div class="clearfix"></div>
     </div><!-- row END -->
  </div>
  <footer id="footer" class="container">
  <div class="panel panel-info">
  <section id='footer_widget'></section>  <div class="panel-footer">
  <div id="site-info">
    <span class='author'>
  
  &copy; 2014 RobinChia
  
    &nbsp;&nbsp;</span>
  
  <span id='analytics-51la'></span><span id='analytics-google'>
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-48559895-1']);
  _gaq.push(['_trackPageview']);
  _js2load.push({src:('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'});
</script></span><span id='analytics-cnzz'>
<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_5774006'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s17.cnzz.com/stat.php%3Fid%3D5774006%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>
</span><span id='analytics-baidu'>
<script>
var _hmt = _hmt || [];
_js2load.push({src:"//hm.baidu.com/hm.js?1442f50724afc42380b51f097c43082c"});
</script>
</span>  </div>
  <div id="copyright">Site powered by <a href='http://zespia.tw/hexo/'><strong>hexo</strong></a>  update time: <em>2014-03-30 14:30:15</em></span></div>
</div>
<div class="clearfix"></div>


  </div>
  </footer>
  
        <script src="http://cdn.bootcss.com/jquery/1.10.2/jquery.min.js"></script>        
        <script src="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/js/bootstrap.min.js"></script>        
                
        <script src="http://cdn.bootcss.com/prettify/r298/prettify.min.js"></script>    <script type="text/javascript">
   var lang=["bsh", "c", "cc", "cpp", "cs", "csh", "cyc", "cv", "htm", "html",
    "java", "js", "m", "mxml", "perl", "pl", "pm", "py", "rb", "sh",
    "xhtml", "xml", "xsl"];
   var pretty_base='';
   $('script').each(function(){
	var c = $(this).attr('src');
	if (!c)
	    return;
	if (c.match(/(\/)?prettify(\.min)?\.js/i))
	{
	    var index = c.lastIndexOf('/');
	    if (index != -1)
		pretty_base = c.substr(0,index + 1);
	    return false;
	}
   })
   $('pre code').each(function(){
	var c = $(this).attr('class')
	if (!c)
	    return;
	c = c.match(/\s?(lang\-\w+)/i);
	if (c && lang.indexOf(c[1]) == -1)
	{
	    lang.push(c[1]);
	    $.getScript(pretty_base + c[1] + '.min.js');
	}
   })

    $(window).load(function(){
       $("pre").addClass("prettyprint");
       prettyPrint();
    })
</script>    
            <script type="text/javascript">
var duoshuoQuery = {short_name:"robinchia"};
_js2load.push({src:'http://static.duoshuo.com/embed.js',charset:'UTF-8'});
</script>
    
            <!--wumii_relatedItems-->
    
        <script src="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js"></script>    <script type="text/javascript">
(function($){
  $('.entry').each(function(i){
    $(this).find('img').each(function(){
      var alt = this.alt;

      if (alt){
        $(this).before('<span class="caption">' + alt + '</span>');
      }

      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox" rel="fancybox' + i + '" />');
    });
  });

  $('.fancybox').fancybox();
})(jQuery);
</script>    
        <script src="http://cdn.bootcss.com/mathjax/2.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>    <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>
    
<script type="text/javascript">
$('.ajax_widgets').each(function(){var src=$(this).attr('data-src');if(src)$(this).load('/widgets/'+src+'.html');});
$.each(_js2load,function(index,obj){loadjs(obj.src,obj.charset)});
</script>

<div id="scroll2top">
<img src="/scroll2top/arrow.png"/>
</div>
<script src="/scroll2top/scroll2top.min.js"></script>
<div id="winterland">
  <canvas></canvas>
</div>
<script src="/js/winterland.min.js"></script>

  </body>
</html>
