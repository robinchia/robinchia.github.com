
<!DOCTYPE HTML>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>The 145 Page | It so life</title>
<meta name="author" content="RobinChia">

<meta name="description" content="It so life">


<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<meta property="og:site_name" content="It so life"/>

<!--[if IE]><style>.testIE.IE{display:inline;}</style><![endif]-->
<!--[if lte IE 7]><link rel="stylesheet" href="/css/ie7.css" type="text/css"><![endif]-->
<!--[if (lt IE 9)&(gt IE 7)]><style>.testIE.IE8{display:inline;}</style><![endif]-->
<!--[if gt IE 8]><style>.testIE.IE9{display:inline;}</style><![endif]-->

<link href="/favicon.png" rel="icon">
<link rel="alternate" href="/atom.xml" title="It so life Feed" type="application/atom+xml">

<link rel="stylesheet" href="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/css/bootstrap.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/font-awesome/4.0.3/css/font-awesome.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/prettify/r298/prettify.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" type="text/css">
<link rel="stylesheet" href="/css/style.css" type="text/css">
<!--[if lt IE 9]>
   <style>article,aside,dialog,footer,header,section,footer,nav,figure,menu{display:block}</style>
   <script src="http://cdn.staticfile.org/html5shiv/r29/html5.min.js"></script>
   <script src="http://cdn.staticfile.org/respond.js/1.4.2/respond.min.js"></script>
<link href="http://cdn.staticfile.org/respond.js/1.4.2/respond-proxy.html" id="respond-proxy" rel="respond-proxy" />
<link href="/js/respond.proxy.gif" id="respond-redirect" rel="respond-redirect" />
<script src="/js/respond.proxy.js"></script>
   <script src="http://cdn.bootcss.com/selectivizr/1.0.2/selectivizr-min.js"></script>
<![endif]-->
<script type="text/javascript">
function loadjs(c,d){var a=document.createElement("script");a.async=!0;a.type="text/javascript";a.src=c;a.charset=d||"gbk";(document.getElementsByTagName("HEAD")[0]||document.getElementsByTagName("BODY")[0]).appendChild(a)};
var _protocol = (("https:" == document.location.protocol) ? " https://" : " http://");
var _js2load = [];
</script>

</head>
<body>
      <header id="header" class="container"><nav id="main-nav" class="navbar navbar-default navbar-fixed-top " role="navigation">
  <div class="container">
    <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
      <span class="sr-only">Toggle navigation</span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="/">It so life</a>
    </div>
    <div  class="collapse navbar-collapse">
      <ul  class="nav navbar-nav">
  
        <li><a href="/" title="Home">Home</a></li>      
        <li><a href="/about/" title="About">About</a></li>      
        <li><a href="/archives/" title="Archives">Archives</a></li>      
      <li class='dropdown'>
        <a class='dropdown-toggle' data-toggle='dropdown' href='#'>website<b class='caret'></b></a>
        <ul class='dropdown-menu pure-menu-selected'>
    
          <li><a href="//groups.google.com/forum/#!forum/pongba" title="TopLanguage">TopLanguage</a></li>    
          <li><a href="//itpub.net/" title="ITPub">ITPub</a></li>    
          <li><a href="//blog.jobbole.com/" title="Bole">Bole</a></li>    
          <li><a href="//nosql-database.org/" title="nosql">nosql</a></li>    
          <li><a href="//gitimmersion.googol.im/" title="Git">Git</a></li>    
        </ul>
      </li>
    
      </ul>
      <ul class="nav navbar-nav navbar-right">
      
        <li><a href="/atom.xml">RSS</a></li>
      
      
        <li><a href="https://twitter.com/robinchia">twitter</a></li>
      
      
      
      
        <li><a href="https://github.com/robinchia">github</a></li>
      
      </ul>
    </div>
  </div>
</nav>
<div class="clearfix"></div>
</header>
  <div id='content' class="container">
     <div class="page-header-wrapper">
      <!--[if lt IE 9]><div class="alert alert-warning alert-dismissable"><button type="button" class="close" data-dismiss="alert" aria-hidden="true">&times;</button><strong>提示:</strong>您的浏览器版本太低了,建议升级到 <strong><a href="http://windows.microsoft.com/zh-cn/internet-explorer/download-ie" title="IE9">IE9</a></strong> 以上,本站使用<a href="https://www.google.com/intl/zh-CN/chrome/">Chrome浏览器</a>可以获得最好的显示效果.</div><![endif]-->
      <div class="page-header"><h1 align="center"><big>It so life</big> </h1>
        <h5 align="center"><big>love as life</big></h5>
      </div>
     </div>
     <div class="row">
       <div id="main-col" class="alignleft col-sx-12 col-sm-8 col-md-9 col-lg-9">
      <section id='header_widget'></section>
          <div id="wrapper"><article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-框架汇总-反射--Java反射机制剖析/">Java反射机制剖析</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:29.000Z"> <a href="/2014/02/02/2014-02-02-框架汇总-反射--Java反射机制剖析/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="java-">Java反射机制剖析</h1>
<p><a href="http://blog.csdn.net/lfsf802/article/details/7239652" target="_blank">（一）-定义和API</a></p>
<ol>
<li>什么是Java反射机制
Java的反射机制是在程序运行时，能够完全知道任何一个类，及其它的属性和方法，并且能够任意调用一个对象的属性和方法。这种运行时的动态获取就是Java的反射机制。其实这也是Java是动态语言的一个象征。</li>
</ol>
<p>用一句话来概括反射就是加载一个运行时才知道的类以及它的完整内部结构。</p>
<ol>
<li>为什么要有Java反射机制
我们为什么要用Java的反射机制呢？</li>
</ol>
<p>我认为有两种：</p>
<p>第一种：反射的目的就是为了扩展未知的应用。比如你写了一个程序，这个程序定义了一些接口，只要实现了这些接口的dll都可以作为插件来插入到这个程序中。那么怎么实现呢？就可以通过反射来实现。就是把dll加载进内存，然后通过反射的方式来调用dll中的方法。</p>
<p>第二种：在编码阶段不知道那个类名,要在运行期从配置文件读取类名, 这时候就没有办法硬编码new ClassName(),而必须用到反射才能创建这个对象。</p>
<p>一个生活中常看到的例子有助于理解我们为什么要用Java的反射机制：你进了一家饭店，你不知道他们都有那些菜，要多少钱。那么你第一件事情是干啥“服务员拿个菜单过来”，然后指着菜单说“我要这个，我要那个”。</p>
<ol>
<li>一起来看ReflectionAPI</li>
</ol>
<p>在生活中，我们使用一个未知的东西的时候总会用帮助来解决我们的使用问题，电视机有帮助，电脑有帮助，几乎所有的事物都携带着它的一本帮助，Java的反射机制也不例外。</p>
<p>在JDK中有Reflection API的帮助，它主要说明了什么是Java反射机制，这种反射机制提供了什么样的属性和方法，进一步我们能够知道能够通过它完成什么样的工作。</p>
<p>下面咱就一起看看这部分的API。这些接口和类都位于lang包里。</p>
<p>如图：</p>
<p><img src="" alt=""></p>
<p>接口：</p>
<p><img src="" alt=""></p>
<p>类：</p>
<p><img src="" alt=""></p>
<p>简单介绍一些类和接口的用法。</p>
<p>1)     Member成员是一种接口，反映有关单个成员（字段或方法）或构造方法的标识信息</p>
<p>2)     InvocationHandler是代理实例的调用处理程序 实现的接口（这个接口的具体用法等到java反射机制剖析4着重介绍）</p>
<p>3)     Method提供一个类的方法的信息以及访问类的方法的接口。</p>
<p>示例：</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/lfsf802/article/details/7239652#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/lfsf802/article/details/7239652#" title="copy" target="_blank">copy</a><a href="http://blog.csdn.net/lfsf802/article/details/7239652#" title="print" target="_blank">print</a><a href="http://blog.csdn.net/lfsf802/article/details/7239652#" title="?" target="_blank">?</a></p>
<ol>
<li>import java.lang.reflect.Method;  </li>
<li></li>
<li>public class TestMethod {  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* @param args </li>
<li>/* @throws Exception  </li>
<li>/*/  </li>
<li>public static void main(String[] args) throws Exception {  </li>
<li>// TODO Auto-generated method stub  </li>
<li>Class classType=Class.forName(args[0]);  </li>
<li>Method methods[]=classType.getDeclaredMethods();  </li>
<li>for(int i=0;i&lt;methods.length;i++){  </li>
<li>System.out.println(methods[i].toString());  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>}  </li>
</ol>
<p>4)     Filed提供一个类的域的信息以及访问类的域的接口。</p>
<p>示例：</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/lfsf802/article/details/7239652#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/lfsf802/article/details/7239652#" title="copy" target="_blank">copy</a><a href="http://blog.csdn.net/lfsf802/article/details/7239652#" title="print" target="_blank">print</a><a href="http://blog.csdn.net/lfsf802/article/details/7239652#" title="?" target="_blank">?</a></p>
<ol>
<li>import java.lang.reflect.Field;  </li>
<li></li>
<li></li>
<li>public class TestField {  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* @param args </li>
<li>/* @throws Exception  </li>
<li>/*/  </li>
<li>public static void main(String[] args) throws Exception {  </li>
<li>// TODO Auto-generated method stub  </li>
<li>Class classType=Class.forName(args[0]);  </li>
<li>Field[] fields = classType.getFields();  </li>
<li>for(int i=0;i&lt;fields.length;i++){  </li>
<li>System.out.println(fields[i].toString());  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>}  </li>
</ol>
<p>5)     Array 类提供了动态创建和访问 Java 数组的方法。</p>
<p>示例：</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/lfsf802/article/details/7239652#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/lfsf802/article/details/7239652#" title="copy" target="_blank">copy</a><a href="http://blog.csdn.net/lfsf802/article/details/7239652#" title="print" target="_blank">print</a><a href="http://blog.csdn.net/lfsf802/article/details/7239652#" title="?" target="_blank">?</a></p>
<ol>
<li>import java.lang.reflect.Array;  </li>
<li></li>
<li></li>
<li>public class TestArray {  </li>
<li></li>
<li>public TestArray(){  </li>
<li></li>
<li>}  </li>
<li>//<em>/</em> </li>
<li>/* @param args </li>
<li>/* @throws Exception  </li>
<li>/*/  </li>
<li>public static void main(String[] args) throws Exception {  </li>
<li></li>
<li>Class&lt;?&gt; classType = Class.forName(&quot;java.lang.String&quot;);  </li>
<li></li>
<li>Object array = Array.newInstance(classType, 10);  </li>
<li></li>
<li>Array.set(array, 5, &quot;hello&quot;);  </li>
<li></li>
<li>String s = (String)Array.get(array, 5);  </li>
<li>System.out.println(s);  </li>
<li></li>
<li>}  </li>
<li></li>
<li>}  </li>
</ol>
<p>6)     Proxy提供动态地生成代理类和类实例的静态方法（这个方法在java放射机制剖析4着重介绍）。</p>
<p>其余的类和接口的使用方法详见API
来源： <a href="[http://blog.csdn.net/lfsf802/article/details/7239652](http://blog.csdn.net/lfsf802/article/details/7239652)">[http://blog.csdn.net/lfsf802/article/details/7239652](http://blog.csdn.net/lfsf802/article/details/7239652)</a></p>
<p> <a href="http://blog.csdn.net/lfsf802/article/details/7239711" target="_blank">（二）-功能以及举例</a></p>
<p>从<a href="http://blog.csdn.net/lfsf802/article/details/7239652" target="_blank">《java反射机制剖析（一）》</a>的API我们看到了许多接口和类，我们能够通过这些接口做些什么呢？</p>
<p>从上篇API中我们能看到它能够完成下面的这些功能：</p>
<p>1)     获得类
A.     运用getClass()  (每个class都有此函数)</p>
<pre><code>                                i.    String str = &quot;abc&quot;;

                              ii.    Class c1 = str.getClass();
</code></pre><p>B.     运用Class.forName() (static method 最常被使用)</p>
<pre><code>                                i.    Class c1 = Class.forName (&quot;java.lang.String&quot;);

                              ii.    Class c2 = Class.forName (&quot;java.awt.Button&quot;);
</code></pre><p>C.     运用  .class 语法</p>
<pre><code>                                i.    Class c1 = String.class;

                              ii.    Class c2 = java.awt.Button.class;

                            iii.    Class c4 = int.class;

                              iv.    Class c5 = int[].class;
</code></pre><p>D.     运用 TYPE语法 ( primitive wrapper classes 基本数据类型包装类的 TYPE语法)</p>
<pre><code>                                i.    Class c1 = Boolean.TYPE;
</code></pre><p>2)     获得属性（这个功能的实例见Java反射机制剖析（2））
以下四个方法可以获得属性，主要参见的是Java.lang.class</p>
<p> Public  Field  getField</p>
<p>(String name) 返回一个 Field 对象，它反映此 Class 对象所表示的类或接口的指定公共成员字段 public Field[] getFields() 返回一个包含某些 Field 对象的数组，这些对象反映此 Class 对象所表示的类或接口的所有可访问公共字段 Public  Field</p>
<p>getDeclaredField(String name) 返回一个 Field 对象，该对象反映此 Class 对象所表示的类或接口的指定已声明字段 public  Field[]</p>
<p>getDeclaredFields() 返回 Field 对象的一个数组，这些对象反映此 Class 对象所表示的类或接口所声明的所有字段</p>
<p>3)     获得方法（）
以下四个方法可以获得方法，要参见的是Java.lang.class</p>
<p>public  Method</p>
<p>getMethod(String name,</p>
<p>... )</p>
<p>返回一个 Method 对象，它反映此 Class 对象所表示的类或接口的指定公共成员方法 public Method[] getMethods()</p>
<p>返回一个包含某些 Method 对象的数组，这些对象反映此 Class 对象所表示的类或接口（包括那些由该类或接口声明的以及从超类和超接口继承的那些的类或接口）的公共 member 方法 public Method</p>
<p>getDeclaredMethod(String name,…)</p>
<p>返回一个 Method 对象，该对象反映此 Class 对象所表示的类或接口的指定已声明方法 public Method[]</p>
<p>getDeclaredMethods()</p>
<p>返回 Method 对象的一个数组，这些对象反映此 Class 对象表示的类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法</p>
<p>4)     获取类的构造器
以下四个方法可以获得方法，要参见的是Java.lang.class</p>
<p>public  Constructor</p>
<p>getConstructor(Class&lt;?&gt;... )</p>
<p>返回一个 Constructor 对象，它反映此 Class 对象所表示的类的指定公共构造方法 public  Constructor&lt;?&gt;[]</p>
<p>getConstructors()</p>
<p>返回一个包含某些 Constructor 对象的数组，这些对象反映此 Class 对象所表示的类的所有公共构造方法 Public  Constructor<T></p>
<p>getDeclaredConstructor(Class&lt;?&gt;...)</p>
<p>返回一个 Constructor 对象，该对象反映此 Class 对象所表示的类或接口的指定构造方法 public  Constructor&lt;?&gt;[]</p>
<p>getDeclaredConstructors()</p>
<p>返回 Constructor 对象的一个数组，这些对象反映此 Class 对象表示的类声明的所有构造方法。它们是公共、保护、默认（包）访问和私有构造方法 
示例代码：</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/lfsf802/article/details/7239711#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/lfsf802/article/details/7239711#" title="copy" target="_blank">copy</a><a href="http://blog.csdn.net/lfsf802/article/details/7239711#" title="print" target="_blank">print</a><a href="http://blog.csdn.net/lfsf802/article/details/7239711#" title="?" target="_blank">?</a></p>
<ol>
<li>import java.lang.reflect.Constructor;  </li>
<li></li>
<li></li>
<li>public class TestConstructor {  </li>
<li>//<em>/</em> </li>
<li>/* @param args </li>
<li>/* @throws ClassNotFoundException  </li>
<li>/* @throws SecurityException  </li>
<li>/* @throws NoSuchMethodException  </li>
<li>/*/  </li>
<li>public static void main(String[] args) throws Exception {  </li>
<li>// TODO Auto-generated method stub  </li>
<li>Class classType=Class.forName(args[0]);  </li>
<li>Constructor Constructor= classType.getConstructor();  </li>
<li></li>
<li>System.out.println(Constructor.toString());  </li>
<li></li>
<li>}  </li>
<li></li>
<li></li>
<li>}  </li>
</ol>
<p>5)     新建类的实例</p>
<p>调用类的Class对象的newInstance方法</p>
<p>示例：</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/lfsf802/article/details/7239711#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/lfsf802/article/details/7239711#" title="copy" target="_blank">copy</a><a href="http://blog.csdn.net/lfsf802/article/details/7239711#" title="print" target="_blank">print</a><a href="http://blog.csdn.net/lfsf802/article/details/7239711#" title="?" target="_blank">?</a></p>
<ol>
<li>import java.lang.reflect.Constructor;  </li>
<li></li>
<li></li>
<li>public class TestConstructor {  </li>
<li>//<em>/</em> </li>
<li>/* @param args </li>
<li>/* @throws ClassNotFoundException  </li>
<li>/* @throws SecurityException  </li>
<li>/* @throws NoSuchMethodException  </li>
<li>/*/  </li>
<li>public static void main(String[] args) throws Exception {  </li>
<li>// TODO Auto-generated method stub  </li>
<li>Class classType=Class.forName(args[0]);  </li>
<li>//Constructor Constructor= classType.getConstructor();  </li>
<li>Object inst=classType.newInstance();  </li>
<li>System.out.println(inst);     </li>
<li>}  </li>
<li>}   调用默认Constructor对象的newInstance方法</li>
</ol>
<p>示例：</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/lfsf802/article/details/7239711#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/lfsf802/article/details/7239711#" title="copy" target="_blank">copy</a><a href="http://blog.csdn.net/lfsf802/article/details/7239711#" title="print" target="_blank">print</a><a href="http://blog.csdn.net/lfsf802/article/details/7239711#" title="?" target="_blank">?</a></p>
<ol>
<li>import java.lang.reflect.Constructor;  </li>
<li></li>
<li></li>
<li>public class TestConstructor {  </li>
<li>//<em>/</em> </li>
<li>/* @param args </li>
<li>/* @throws ClassNotFoundException  </li>
<li>/* @throws SecurityException  </li>
<li>/* @throws NoSuchMethodException  </li>
<li>/*/  </li>
<li>public static void main(String[] args) throws Exception {  </li>
<li>// TODO Auto-generated method stub  </li>
<li>Class classType=Class.forName(args[0]);  </li>
<li>Constructor Constructor= classType.getConstructor();  </li>
<li>Object inst=Constructor.newInstance();  </li>
<li>System.out.println(inst);     </li>
<li>}  </li>
<li>}   调用带参数Constructor对象的newInstance方法</li>
</ol>
<p>示例：</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/lfsf802/article/details/7239711#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/lfsf802/article/details/7239711#" title="copy" target="_blank">copy</a><a href="http://blog.csdn.net/lfsf802/article/details/7239711#" title="print" target="_blank">print</a><a href="http://blog.csdn.net/lfsf802/article/details/7239711#" title="?" target="_blank">?</a></p>
<ol>
<li>Class classType=User.class  </li>
<li>Constructor constructor2 =  </li>
<li>classType.getDeclaredConstructor(int.class, String.class);  </li>
<li></li>
<li>Object inst = constructor2.newInstance(1, &quot;123&quot;);  </li>
<li></li>
<li>System.out.println(inst);  </li>
</ol>
<p>来源： <a href="[http://blog.csdn.net/lfsf802/article/details/7239711](http://blog.csdn.net/lfsf802/article/details/7239711)">[http://blog.csdn.net/lfsf802/article/details/7239711](http://blog.csdn.net/lfsf802/article/details/7239711)</a></p>
<p><a href="http://blog.csdn.net/lfsf802/article/details/7239766" target="_blank">（三）-简单谈谈动态代理</a>
通过<a href="http://blog.csdn.net/lfsf802/article/details/7239652" target="_blank">Java反射机制剖析（一）</a>和<a href="http://blog.csdn.net/lfsf802/article/details/7239711" target="_blank">Java反射机制剖析（二）</a>的学习，已经对反射有了一定的了解，这一篇通过动态代理的例子来进一步学习反射机制。</p>
<ol>
<li>代理模式</li>
</ol>
<p>代理模式就是为其他对象提供一种代理来控制对这个对象的访问。其实代理模式是在访问的对象时引入一定程度的间接性，这种间接性可以附加多种用途。</p>
<p>它的特征是代理类与委托类有同样的接口，代理类主要负责为委托类预处理消息、过滤消息、把消息转发给委托类，以及事后处理消息等。代理类与委托类之间通常会存在关联关系，一个代理类的对象与一个委托类的对象关联，代理类的对象本身并不真正实现服务，而是通过调用委托类的对象的相关方法，来提供特定的服务。</p>
<ol>
<li>分类</li>
</ol>
<p>代理类按照创建时期可以分为两种，静态代理类和动态代理类。</p>
<p>静态代理类：由程序员创建或由特定工具自动生成源代码，再对其编译。在程序运行前，代理类的.class文件就已经存在了。</p>
<p>动态代理类：在程序运行时，运用反射机制动态创建而成。</p>
<ol>
<li>静态代理和动态代理举例</li>
</ol>
<p>静态代理：</p>
<p>业务接口类：</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/lfsf802/article/details/7239766#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/lfsf802/article/details/7239766#" title="copy" target="_blank">copy</a><a href="http://blog.csdn.net/lfsf802/article/details/7239766#" title="print" target="_blank">print</a><a href="http://blog.csdn.net/lfsf802/article/details/7239766#" title="?" target="_blank">?</a></p>
<ol>
<li>package com.bjpowernode.pattern;  </li>
<li></li>
<li>public interface UserManager {  </li>
<li></li>
<li>public void addUser(String userId, String userName);  </li>
<li></li>
<li>public void delUser(String userId);  </li>
<li></li>
<li>public void modifyUser(String userId, String userName);  </li>
<li></li>
<li>public String findUser(String userId);  </li>
<li>}<br>业务接口实现类：</li>
</ol>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/lfsf802/article/details/7239766#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/lfsf802/article/details/7239766#" title="copy" target="_blank">copy</a><a href="http://blog.csdn.net/lfsf802/article/details/7239766#" title="print" target="_blank">print</a><a href="http://blog.csdn.net/lfsf802/article/details/7239766#" title="?" target="_blank">?</a></p>
<ol>
<li>package com.bjpowernode.pattern;  </li>
<li></li>
<li>public class UserManagerImpl implements UserManager {  </li>
<li></li>
<li>public void addUser(String userId, String userName) {  </li>
<li>//System.out.println(&quot;start--&gt;&gt;addUser() userId--&gt;&gt;&quot; + userId);  </li>
<li>try {  </li>
<li>System.out.println(&quot;UserManagerImpl.addUser() userId--&gt;&gt;&quot; + userId);  </li>
<li></li>
<li>//System.out.println(&quot;success--&gt;&gt;addUser()&quot;);  </li>
<li>}catch(Exception e) {  </li>
<li>e.printStackTrace();  </li>
<li>//System.out.println(&quot;error--&gt;&gt;addUser()&quot;);  </li>
<li>throw new RuntimeException();  </li>
<li>}     </li>
<li>}  </li>
<li></li>
<li>public void delUser(String userId) {  </li>
<li>System.out.println(&quot;UserManagerImpl.delUser() userId--&gt;&gt;&quot; + userId);  </li>
<li>}  </li>
<li></li>
<li>public String findUser(String userId) {  </li>
<li>System.out.println(&quot;UserManagerImpl.findUser() userId--&gt;&gt;&quot; + userId);  </li>
<li>return &quot;张三&quot;;  </li>
<li>}  </li>
<li></li>
<li>public void modifyUser(String userId, String userName) {  </li>
<li>System.out.println(&quot;UserManagerImpl.modifyUser() userId--&gt;&gt;&quot; + userId);  </li>
<li>}  </li>
<li></li>
<li>}<br>业务代理类：</li>
</ol>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/lfsf802/article/details/7239766#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/lfsf802/article/details/7239766#" title="copy" target="_blank">copy</a><a href="http://blog.csdn.net/lfsf802/article/details/7239766#" title="print" target="_blank">print</a><a href="http://blog.csdn.net/lfsf802/article/details/7239766#" title="?" target="_blank">?</a></p>
<ol>
<li>package com.bjpowernode.pattern;  </li>
<li></li>
<li>public class UserManagerImplProxy implements UserManager {  </li>
<li></li>
<li>private UserManager userManager;  </li>
<li></li>
<li>public UserManagerImplProxy(UserManager userManager) {  </li>
<li>this.userManager = userManager;  </li>
<li>}  </li>
<li></li>
<li>public void addUser(String userId, String userName) {  </li>
<li>try {  </li>
<li>System.out.println(&quot;start--&gt;&gt;addUser() userId--&gt;&gt;&quot; + userId);  </li>
<li>userManager.addUser(userId, userName);  </li>
<li>System.out.println(&quot;success--&gt;&gt;addUser()&quot;);  </li>
<li>}catch(Exception e) {  </li>
<li>e.printStackTrace();  </li>
<li>System.out.println(&quot;error--&gt;&gt;addUser()&quot;);  </li>
<li>}     </li>
<li>}  </li>
<li></li>
<li>public void delUser(String userId) {  </li>
<li></li>
<li>}  </li>
<li></li>
<li>public String findUser(String userId) {  </li>
<li>return null;  </li>
<li>}  </li>
<li></li>
<li>public void modifyUser(String userId, String userName) {  </li>
<li></li>
<li>}  </li>
<li></li>
<li>}<br>客户端类：</li>
</ol>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/lfsf802/article/details/7239766#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/lfsf802/article/details/7239766#" title="copy" target="_blank">copy</a><a href="http://blog.csdn.net/lfsf802/article/details/7239766#" title="print" target="_blank">print</a><a href="http://blog.csdn.net/lfsf802/article/details/7239766#" title="?" target="_blank">?</a></p>
<ol>
<li>package com.bjpowernode.pattern;  </li>
<li></li>
<li>public class Client {  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* @param args </li>
<li>/*/  </li>
<li>public static void main(String[] args) {  </li>
<li>//UserManager userManager = new UserManagerImpl();  </li>
<li>UserManager userManager = new UserManagerImplProxy(new UserManagerImpl());  </li>
<li>userManager.addUser(&quot;0001&quot;, &quot;张三&quot;);  </li>
<li>}  </li>
<li></li>
<li>}<br>运行结果：</li>
</ol>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/lfsf802/article/details/7239766#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/lfsf802/article/details/7239766#" title="copy" target="_blank">copy</a><a href="http://blog.csdn.net/lfsf802/article/details/7239766#" title="print" target="_blank">print</a><a href="http://blog.csdn.net/lfsf802/article/details/7239766#" title="?" target="_blank">?</a></p>
<ol>
<li>start--&gt;&gt;addUser() userId--&gt;&gt;0001  </li>
<li>UserManagerImpl.addUser() userId--&gt;&gt;0001  </li>
<li>success--&gt;&gt;addUser()  </li>
</ol>
<p>动态代理：</p>
<p>业务接口类:</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/lfsf802/article/details/7239766#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/lfsf802/article/details/7239766#" title="copy" target="_blank">copy</a><a href="http://blog.csdn.net/lfsf802/article/details/7239766#" title="print" target="_blank">print</a><a href="http://blog.csdn.net/lfsf802/article/details/7239766#" title="?" target="_blank">?</a></p>
<ol>
<li>package com.bjpowernode.pattern;  </li>
<li></li>
<li>public interface UserManager {  </li>
<li></li>
<li></li>
<li>public String test(String userId);  </li>
<li>}<br>业务接口实现类：</li>
</ol>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/lfsf802/article/details/7239766#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/lfsf802/article/details/7239766#" title="copy" target="_blank">copy</a><a href="http://blog.csdn.net/lfsf802/article/details/7239766#" title="print" target="_blank">print</a><a href="http://blog.csdn.net/lfsf802/article/details/7239766#" title="?" target="_blank">?</a></p>
<ol>
<li>package com.bjpowernode.pattern;  </li>
<li></li>
<li>public class UserManagerImpl implements UserManager {  </li>
<li></li>
<li>public String test(String userId) {  </li>
<li>System.out.println(&quot;UserManagerImpl.findUser() userId--&gt;&gt;&quot; + userId);  </li>
<li>return &quot;张三&quot;;  </li>
<li>}  </li>
<li></li>
<li>}<br>BusinessHandler类：</li>
</ol>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/lfsf802/article/details/7239766#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/lfsf802/article/details/7239766#" title="copy" target="_blank">copy</a><a href="http://blog.csdn.net/lfsf802/article/details/7239766#" title="print" target="_blank">print</a><a href="http://blog.csdn.net/lfsf802/article/details/7239766#" title="?" target="_blank">?</a></p>
<ol>
<li>package com.bjpowernode.pattern;  </li>
<li></li>
<li>import java.lang.reflect.InvocationHandler;  </li>
<li>import java.lang.reflect.Method;  </li>
<li>import java.lang.reflect.Proxy;  </li>
<li></li>
<li>public class BusinessHandler implements InvocationHandler {  </li>
<li></li>
<li>private Object targetObject;  </li>
<li></li>
<li>public Object newProxyInstance(Object targetObject) {  </li>
<li></li>
<li>this.targetObject = targetObject;  </li>
<li>return Proxy.newProxyInstance(targetObject.getClass().getClassLoader(),  </li>
<li>targetObject.getClass().getInterfaces(), this);  </li>
<li>}  </li>
<li></li>
<li>public Object invoke(Object proxy, Method method, Object[] args)  </li>
<li>throws Throwable {  </li>
<li>System.out.println(&quot;start--&gt;&gt;&quot; + method.getName());  </li>
<li>for (int i=0; i&lt;args.length; i++) {  </li>
<li>System.out.println(args[i]);  </li>
<li>}  </li>
<li>Object ret = null;  </li>
<li>try {  </li>
<li>//调用目标方法  </li>
<li>ret = method.invoke(targetObject, args);  </li>
<li>System.out.println(&quot;success--&gt;&gt;&quot; + method.getName());   </li>
<li>}catch(Exception e) {  </li>
<li>e.printStackTrace();  </li>
<li>System.out.println(&quot;error--&gt;&gt;&quot; + method.getName());  </li>
<li>throw e;  </li>
<li>}  </li>
<li>return ret;  </li>
<li>}  </li>
<li></li>
<li>}<br>客户端类：</li>
</ol>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/lfsf802/article/details/7239766#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/lfsf802/article/details/7239766#" title="copy" target="_blank">copy</a><a href="http://blog.csdn.net/lfsf802/article/details/7239766#" title="print" target="_blank">print</a><a href="http://blog.csdn.net/lfsf802/article/details/7239766#" title="?" target="_blank">?</a></p>
<ol>
<li>package com.bjpowernode.pattern;  </li>
<li></li>
<li>import java.lang.reflect.Field;  </li>
<li></li>
<li></li>
<li>public class Client {  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* @param args </li>
<li>/*/  </li>
<li>public static void main(String[] args) {  </li>
<li></li>
<li>BusinessHandler businessHandler = new BusinessHandler();  </li>
<li>UserManager userManager = (UserManager)businessHandler.newProxyInstance(new UserManagerImpl());  </li>
<li></li>
<li></li>
<li></li>
<li>//userManager.addUser(&quot;0001&quot;, &quot;张三&quot;);  </li>
<li>//userManager.delUser(&quot;0001&quot;);  </li>
<li>// System.out.println(userManager.getClass().getName());  </li>
<li></li>
<li>String name = userManager.test(&quot;0001&quot;);  </li>
<li>//String name = ((UserManagerImpl) logHandler.newProxyInstance(new UserManagerImpl())).test(&quot;0001&quot;);  </li>
<li>System.out.println(&quot;Client.main() --- &quot; + name);  </li>
<li>}  </li>
<li></li>
<li>}<br>运行结果：</li>
</ol>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/lfsf802/article/details/7239766#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/lfsf802/article/details/7239766#" title="copy" target="_blank">copy</a><a href="http://blog.csdn.net/lfsf802/article/details/7239766#" title="print" target="_blank">print</a><a href="http://blog.csdn.net/lfsf802/article/details/7239766#" title="?" target="_blank">?</a></p>
<ol>
<li>start--&gt;&gt;test  </li>
<li>0001  </li>
<li>UserManagerImpl.findUser() userId--&gt;&gt;0001  </li>
<li>success--&gt;&gt;test  </li>
<li>Client.main() --- 张三  </li>
</ol>
<p>来源： <a href="[http://blog.csdn.net/lfsf802/article/details/7239766](http://blog.csdn.net/lfsf802/article/details/7239766)">[http://blog.csdn.net/lfsf802/article/details/7239766](http://blog.csdn.net/lfsf802/article/details/7239766)</a></p>
<p> <a href="http://blog.csdn.net/lfsf802/article/details/7239799" target="_blank">（四）-深度剖析动态代理原理及总结</a>
动态代理类原理（<a href="http://blog.csdn.net/lfsf802/article/details/7239766" target="_blank">示例代码参见java反射机制剖析（三）</a>）
a)  理解上面的动态代理示例流程</p>
<p><img src="" alt=""></p>
<p>b)  代理接口实现类源代码剖析</p>
<p>咱们一起来剖析一下代理实现类（$Proxy0）的源代码和整个动态代理的流程。</p>
<p>$Proxy0生成的代码如下：</p>
<p><strong>[html]</strong> <a href="http://blog.csdn.net/lfsf802/article/details/7239799#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/lfsf802/article/details/7239799#" title="copy" target="_blank">copy</a><a href="http://blog.csdn.net/lfsf802/article/details/7239799#" title="print" target="_blank">print</a><a href="http://blog.csdn.net/lfsf802/article/details/7239799#" title="?" target="_blank">?</a></p>
<ol>
<li>import java.lang.reflect.InvocationHandler;  </li>
<li>import java.lang.reflect.Method;  </li>
<li>import java.lang.reflect.Proxy;  </li>
<li>import java.lang.reflect.UndeclaredThrowableException;  </li>
<li></li>
<li>public final class $Proxy0 extends Proxy implements Manager {  </li>
<li></li>
<li>private static Method m1;  </li>
<li>private static Method m0;  </li>
<li>private static Method m3;  </li>
<li>private static Method m2;  </li>
<li></li>
<li>static {  </li>
<li>try {  </li>
<li>m1 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;equals&quot;,  </li>
<li>new Class[] { Class.forName(&quot;java.lang.Object&quot;) });  </li>
<li>m0 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;hashCode&quot;,  </li>
<li>new Class[0]);  </li>
<li>m3 = Class.forName(&quot;com.ml.test.Manager&quot;).getMethod(&quot;test&quot;,  </li>
<li>new Class[0]);  </li>
<li>m2 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;toString&quot;,  </li>
<li>new Class[0]);  </li>
<li>} catch (NoSuchMethodException nosuchmethodexception) {  </li>
<li>throw new NoSuchMethodError(nosuchmethodexception.getMessage());  </li>
<li>} catch (ClassNotFoundException classnotfoundexception) {  </li>
<li>throw new NoClassDefFoundError(classnotfoundexception.getMessage());  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>public $Proxy0(InvocationHandler invocationhandler) {  </li>
<li>super(invocationhandler);  </li>
<li>}  </li>
<li></li>
<li>@Override  </li>
<li>public final boolean equals(Object obj) {  </li>
<li>try {  </li>
<li>return ((Boolean) super.h.invoke(this, m1, new Object[] { obj }))  </li>
<li>.booleanValue();  </li>
<li>} catch (Throwable throwable) {  </li>
<li>throw new UndeclaredThrowableException(throwable);  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>@Override  </li>
<li>public final int hashCode() {  </li>
<li>try {  </li>
<li>return ((Integer) super.h.invoke(this, m0, null)).intValue();  </li>
<li>} catch (Throwable throwable) {  </li>
<li>throw new UndeclaredThrowableException(throwable);  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>public final void test() {  </li>
<li>try {  </li>
<li>super.h.invoke(this, m3, null);  </li>
<li>return;  </li>
<li>} catch (Error e) {  </li>
<li>} catch (Throwable throwable) {  </li>
<li>throw new UndeclaredThrowableException(throwable);  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>@Override  </li>
<li>public final String toString() {  </li>
<li>try {  </li>
<li>return (String) super.h.invoke(this, m2, null);  </li>
<li>} catch (Throwable throwable) {  </li>
<li>throw new UndeclaredThrowableException(throwable);  </li>
<li>}  </li>
<li>}  </li>
<li>}  </li>
</ol>
<p>引入眼帘的是这个代理接口实现类实现了业务类的接口（也就是例子中的UserManager接口），又继承了基类Proxy类；</p>
<p>接着就是构造函数，在构造方法中把BusinessHandler传过去,接着$Proxy0调用父类Proxy的构造器,为h赋值（这里要看Proxy的构造方法）；</p>
<p>随后看到的就是这个类重写了Proxy类的Equals、hashCode、toString方法，又实现了业务类接口的方法（即UserManager的test方法），具体重写和实现都是用到的super.h.invoke（即Proxy.h.invoke）这个方法。</p>
<p>简单分析完这个代理接口实现类，咱们下面来整体看一下这个动态代理是怎么实现的：</p>
<p>首先客户端初始化了BusinessHandler类，调用这个类的newProxyInstance(new UserManagerImpl())方法来初始化了上面的代理接口实现类；</p>
<p>接下来代理接口实现类通过构造函数把BusinessHandler传过去（也就是代码中的this），并通过Proxy的构造函数给h赋值；</p>
<p>随后再客户端就能实例化出代理接口实现类$Proxy0，我们把它强制转换为业务实现接口（UserManager）类型的（为什么要强制转换，这里非常有意思，如果不强制转换就会报错，这里很好解释，因为当前的环境根本不会知道这个代理接口实现类$Proxy0既继承Proxy又实现业务实现接口UserManager，但是强制转换成UserManager它是可以做到的，因为当前环境中就有UserManager。这就是反射的厉害之处，可以在运行时动态调用任何一个类并可以使用这个类的具体细节。）；</p>
<p>之后当我们调用test方法的时候其实是调用了$Proxy0中的test方法，这个方法的实现是通过Proxy.h的invoke方法实现的（即调用了BusinessHandler.invoke方法）；</p>
<p>之后在调用了Method的invoke方法（这时的参数是this，和args）。</p>
<p>这样就调用了UserManagerImpl的对应方法，之后返回给客户端。</p>
<p>到此就完成了整个的调用关系。</p>
<p>反射，反射，程序员的快乐
通过上篇文章对动态代理进行了深度剖析，现在想起来还感觉非常有意思，这里面其实最根本的机制就是反射机制，运行时动态实例化任何一个类，并且调用它的具体细节。现在反看动态代理的示例，其实发现这里最关键的还是在就在Proxy.newProxyInstance(..)方法执行时生成了$Proxy0的内存字节码这一点上，当我们有了内存字节码，我们的反射就会大显威力，这样才有了我们之后的一系列的调用关系。</p>
<p>通过反射机制的分析和动态代理示例的剖析，发现编程是一件多么有意思的事情，以至于我们沉浸其中不能自拔。</p>
<p>最后总结一下：反射，反射，程序员的快乐！
来源： <a href="[http://blog.csdn.net/lfsf802/article/details/7239799](http://blog.csdn.net/lfsf802/article/details/7239799)">[http://blog.csdn.net/lfsf802/article/details/7239799](http://blog.csdn.net/lfsf802/article/details/7239799)</a></p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/框架汇总/">框架汇总</a></li></span><span class="breadcrumb"><li><a href="/categories/框架汇总/">框架汇总</a></li><li><a href="/categories/框架汇总/反射/">反射</a></li></span></span> | <span class="tags">Tagged <a href="/tags/反射/" class="label label-primary">反射</a><a href="/tags/框架汇总/" class="label label-success">框架汇总</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:29"datetime="2014-03-07 09:54:29"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-框架汇总-反射--Java反射机制剖析/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-框架汇总-反射--Java反射机制剖析" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-框架汇总-Spring--Spring-设计模式-aop-ioc/">Spring</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:29.000Z"> <a href="/2014/02/02/2014-02-02-框架汇总-Spring--Spring-设计模式-aop-ioc/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="spring-aop-ioc">Spring-设计模式-aop-ioc</h1>
<p><a href="http://www.goldendoc.org/" target="_blank">黄金档</a></p>
<p>路漫漫其修远兮，吾将上下而求索……</p>
<ul>
<li><a href="http://www.goldendoc.org/" title="首页" target="_blank">首页</a></li>
<li><a href="http://www.goldendoc.org/hire/" target="_blank">招聘</a></li>
<li><a href="http://www.goldendoc.org/about/" target="_blank">关于</a></li>
</ul>
<h1 id="spring">Spring</h1>
<h2 id="-spring-http-www-goldendoc-org-2010-12-spring_design_pattern-spring-"><a href="http://www.goldendoc.org/2010/12/spring_design_pattern/" title="永久链接：Spring中的设计模式" target="_blank">Spring中的设计模式</a></h2>
<p><a href="http://www.goldendoc.org/2010/12/spring_design_pattern/#comments" target="_blank">2</a></p>
<p>2年前</p>
<p>由<a href="http://www.goldendoc.org/author/jackey/" title="jackey发表的文章 " target="_blank">jackey</a>发布 在<a href="http://www.goldendoc.org/category/spring/" title="Spring (4主题)" target="_blank">Spring</a>
应该说设计模式是我们在写代码时候的一种被承认的较好的模式。好的设计模式就像是给代码造了一个很好的骨架，在这个骨架里，你可以知道心在哪里，肺在哪里，因为大多数人都认识这样的骨架，就有了很好的传播性。这是从易读和易传播来感知设计模式的好处。当然设计模式本身更重要的是设计原则的一种实现，比如开闭原则，依赖倒置原则，这些是在代码的修改和扩展上说事。说到底就是人类和代码发生关系的四种场合：阅读，修改，增加，删除。让每一种场合都比较舒服的话，就需要用设计模式。</p>
<p>下面来简单列举Spring中的设计模式：
<strong>1. 简单工厂</strong>
又叫做静态工厂方法（StaticFactory Method）模式，但不属于23种GOF设计模式之一。
简单工厂模式的实质是由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类。
Spring中的BeanFactory就是简单工厂模式的体现，根据传入一个唯一的标识来获得Bean对象，但是否是在传入参数后创建还是传入参数前创建这个要根据具体情况来定。
<strong>2. 工厂方法（Factory Method）</strong>
定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method使一个类的实例化延迟到其子类。
Spring中的FactoryBean就是典型的工厂方法模式。如下图：
<a href="http://pic.yupoo.com/goldendoc/AFbYXQy8/cgvMF.jpg" target="_blank"><img src="" alt=""></a></p>
<p><strong>3. 单例（Singleton）</strong>
保证一个类仅有一个实例，并提供一个访问它的全局访问点。
Spring中的单例模式完成了后半句话，即提供了全局的访问点BeanFactory。但没有从构造器级别去控制单例，这是因为Spring管理的是是任意的Java对象。
<strong>4. 适配器（Adapter）</strong>
将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。
Spring中在对于AOP的处理中有Adapter模式的例子，见如下图：
<a href="http://pic.yupoo.com/goldendoc/AFbYXG9r/yaKsE.jpg" target="_blank"><img src="" alt=""></a>
由于Advisor链需要的是MethodInterceptor对象，所以每一个Advisor中的Advice都要适配成对应的MethodInterceptor对象。
<strong>5.包装器（Decorator）</strong>
动态地给一个对象添加一些额外的职责。就增加功能来说，Decorator模式相比生成子类更为灵活。 <em>**</em></p>
<p><a href="http://pic.yupoo.com/goldendoc/AFbYXVzM/iEPst.jpg" target="_blank"><img src="" alt=""></a>
Spring中用到的包装器模式在类名上有两种表现：一种是类名中含有Wrapper，另一种是类名中含有Decorator。基本上都是动态地给一个对象添加一些额外的职责。
<strong>6. 代理（Proxy）</strong>
为其他对象提供一种代理以控制对这个对象的访问。
从结构上来看和Decorator模式类似，但Proxy是控制，更像是一种对功能的限制，而Decorator是增加职责。
<img src="" alt="">
Spring的Proxy模式在aop中有体现，比如JdkDynamicAopProxy和Cglib2AopProxy。
<strong>7.观察者（Observer）</strong>
定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。
<a href="http://pic.yupoo.com/goldendoc/AFbYY79B/QRttX.jpg" target="_blank"><img src="" alt=""></a>
Spring中Observer模式常用的地方是listener的实现。如ApplicationListener。
<strong>8. 策略（Strategy）</strong>
定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。
Spring中在实例化对象的时候用到Strategy模式，见如下图：
<a href="http://pic.yupoo.com/goldendoc/AFbYYjl6/c2IJb.jpg" target="_blank"><img src="" alt=""></a>
在SimpleInstantiationStrategy中有如下代码说明了策略模式的使用情况：
<a href="http://pic.yupoo.com/goldendoc/AFbYYecL/xJ2n1.jpg" target="_blank"><img src="" alt=""></a>
<strong>9.模板方法（Template Method）</strong>
定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。Template Method使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。
<img src="" alt="">
Template Method模式一般是需要继承的。这里想要探讨另一种对Template Method的理解。Spring中的JdbcTemplate，在用这个类时并不想去继承这个类，因为这个类的方法太多，但是我们还是想用到JdbcTemplate已有的稳定的、公用的数据库连接，那么我们怎么办呢？我们可以把变化的东西抽出来作为一个参数传入JdbcTemplate的方法中。但是变化的东西是一段代码，而且这段代码会用到JdbcTemplate中的变量。怎么办？那我们就用回调对象吧。在这个回调对象中定义一个操纵JdbcTemplate中变量的方法，我们去实现这个方法，就把变化的东西集中到这里了。然后我们再传入这个回调对象到JdbcTemplate，从而完成了调用。这可能是Template Method不需要继承的另一种实现方式吧。</p>
<p>以下是一个具体的例子：
JdbcTemplate中的execute方法：</p>
<p><a href="http://pic.yupoo.com/goldendoc/AFbYXJ1i/Gqxeo.jpg" target="_blank"><img src="" alt=""></a>
JdbcTemplate执行execute方法：
<a href="http://pic.yupoo.com/goldendoc/AFbYYoCZ/coCXA.jpg" target="_blank"><img src="" alt=""></a></p>
<p><a href="http://www.goldendoc.org/tag/%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f/" title="设计模式 (1主题)" target="_blank">设计模式</a></p>
<h2 id="-spring-aop-http-www-goldendoc-org-2010-12-spring_aop-spring-aop-"><a href="http://www.goldendoc.org/2010/12/spring_aop/" title="永久链接：Spring AOP介绍及源码分析" target="_blank">Spring AOP介绍及源码分析</a></h2>
<p><a href="http://www.goldendoc.org/2010/12/spring_aop/#comments" target="_blank">3</a></p>
<p>2年前</p>
<p>由<a href="http://www.goldendoc.org/author/lwei/" title="lwei发表的文章 " target="_blank">lwei</a>发布 在<a href="http://www.goldendoc.org/category/spring/" title="Spring (4主题)" target="_blank">Spring</a>
软件开发经历了从汇编语言到高级语言和从过程化编程到面向对象编程；前者是为了提高开发效率，而后者则使用了归纳法，把具有共性的东西进行归类并使之模块化，达到便于维护和扩展的目的；如果说面向对象编程可以对业务需求进行很好的分解使之模块化；那么面向切面编程AOP（Aspect-Oriented Programming）则可以对系统需求进行很好的模软件开发经历了从汇编语言到高级语言和从过程化编程到面向对象编程；前者是为了提高开发效率，而后者则使用了归纳法，把具有共性的东西进行归类并使之模块化，达到便于维护和扩展的目的；如果说面向对象编程可以对业务需求进行很好的分解使之模块化；那么面向切面编程AOP（Aspect-Oriented Programming）则可以对系统需求进行很好的模块组织，简化系统需求和实现之间的对比关系，是对OOP思想的一种补充；块组织，简化系统需求和实现之间的对比关系，是对OOP思想的一种补充；</p>
<p><strong>一、AOP介绍
</strong></p>
<p>举个例子来说明一下吧！现在系统中有很多的业务方法，如上传产品信息、修改产品信息、发布公司库等；现在需要对这些方法的执行做性能监控，看每个业务方法的执行时间；在不改变原业务代码的基础上，也许我们会这么做：</p>
<p><strong>Offer接口：
</strong></p>
<p><img src="" alt=""></p>
<p><strong>Offer实现：
</strong></p>
<p><img src="" alt=""></p>
<p><strong>Offer代理：
</strong></p>
<p><img src="" alt=""></p>
<p>我们要通过下面的方式来使用：</p>
<p><img src="" alt=""></p>
<p>上面的例子的输出为：</p>
<p><img src="" alt=""></p>
<p>上面的例子中，OfferProxy实现了IOffer，而所有的业务实现均委托给其成员offer；可以想像，这应该就是最简单的AOP的实现了；但这种方式会存在一个问题：如果有非常多的这种业务对象需要性能监控，我们就需要写同样多的XyzProxy来满足需求，这也是非常巨大的工作量。</p>
<p>上面说到了代理，我们先看看代理模式吧！</p>
<p><strong>二、代理模式及实现
</strong></p>
<p>下面是代理模式的类图：</p>
<p><img src="" alt=""></p>
<p>代理模式类图</p>
<p>代理模式中，存在一个称为ProxyObject的代理对象和RealObject的真实对象，它们都实现了相同的接口；在调用的地方持有ProxyObject的实例，当调用request()方法时，ProxyObject可以在执行RealObject.request()前后做一些特定的业务，甚至不调用RealObject.request()方法。</p>
<p>目前实现代理模式的方式有两种：基于JDK的动态代理和基于CGLIB字节码的代理。</p>
<p><strong>2.1 JDK动态代理
</strong></p>
<p>JDK动态代理，顾名思义，是基于JDK的反射(reflect)机制；在JDK中，提供了InvocationHandler这个接口，下面是JDK里面的注释：</p>
<p>InvocationHandler is the interface implemented by the invocation handler of a proxy instance.</p>
<p>Each proxy instance has an associated invocation handler. When a method is invoked on a proxy instance, the method invocation is encoded and dispatched to the invoke method of its invocation handler.</p>
<p>简单翻译，意思是说：该接口由被代理对象的handler所实现；当调用代理对象的方法时，该方法调用将被编码，然后交给代理对象的invoke方法去执行；</p>
<p>是不是有一种豁然开朗的感觉呢？没错，答案就在你心中。</p>
<p>这样，上面的代码就可以改成下面的实现方式：</p>
<p><img src="" alt=""><em>**</em></p>
<p><strong>调用端：
</strong></p>
<p><img src="" alt=""></p>
<p>通过这种方式，你不需要为针对每一个业务写一个代理对象，就可以很轻松地完成你的需求；但也许你已经注意到了，JDK的动态代理，在创建代理对象(上面红色代码部分)时，被代理的对象需要实现接口(即面向接口编程)；</p>
<p>这就是JDK的动态代理，简单吧！下面看看CGLIB代理方式。</p>
<p><strong>2.2 CGLIB代理
</strong></p>
<p>如果目标对象没有实现任何接口，那怎么办呢？不用担心，你可以用CGLIB来实现代理：</p>
<p><img src="" alt=""></p>
<p><strong>调用端：
</strong></p>
<p><img src="" alt=""></p>
<p>使用CGLIB创建的代理对象，其实就是继承了要代理的目标类，然后对目标类中所有非final方法进行覆盖，但在覆盖方法时会添加一些拦截代码(上面CglibProxyFactory类中的intercept方法)。</p>
<p>下面看看Spring中是如何实现AOP的。</p>
<p><strong>三、Spring AOP的实现
</strong></p>
<p><strong>3.1 Spring AOP的几个概念
</strong></p>
<p>Spring AOP中的几个基本概念，每次学习AOP都被这几个概念折腾的很不爽，我们在这里再把这几个概念描述一遍，力争把这几个概念搞清，在每次review这块内容的时候可以很快上手。</p>
<ol>
<li>切面(Aspect)：切面就是一个关注点的模块化，如事务管理、日志管理、权限管理等；</li>
<li>连接点(Joinpoint)：程序执行时的某个特定的点，在Spring中就是一个方法的执行；</li>
<li>通知(Advice)：通知就是在切面的某个连接点上执行的操作，也就是事务管理、日志管理等；</li>
<li>切入点(Pointcut)：切入点就是描述某一类选定的连接点，也就是指定某一类要织入通知的方法；</li>
<li>目标对象(Target)：就是被AOP动态代理的目标对象；</li>
</ol>
<p>用一张图来形象地表达AOP的概念及其关系如下：</p>
<p><img src="" alt=""></p>
<p><strong>3.2 Spring AOP中切入点、通知、切面的实现
</strong></p>
<p>理解了上面的几个概念后，我们分别来看看Spring AOP是如何实现这些概念的；</p>
<ol>
<li>切入点(Pointcut)：它定义了哪些连接点需要被织入横切逻辑；在Java中，连接点对应哪些类(接口)的方法。因此，我们都能猜到，所谓的切入点，就是定义了匹配哪些娄的哪些方法的一些规则，可以是静态的基于类(方法)名的值匹配，也可以是基于正则表达式的模式匹配。来看看Spring AOP Pointcut相关的类图：</li>
</ol>
<p><img src="" alt=""></p>
<p>在Pointcut接口的定义中，也许你已经想到了，ClassFilter是类过滤器，它定义了哪些类名需要拦截；典型的两个实现类为<strong>TypePatternClassFilter</strong>和<strong>TrueClassFilter</strong>(所有类均匹配)；而MethodMatcher为方法匹配器，定义哪些方法需要拦截。</p>
<p>在上面的类图中：</p>
<ul>
<li>StaticMethodMatch与DynamicMethodMatch的区别是后者在运行时会依据方法的参数值进行匹配。</li>
<li>NameMatchMethodPointCut根据指定的mappedNames来匹配方法。</li>
<li>AbstractRegexpMethodPointCut根据正则表达式来匹配方法。</li>
</ul>
<ol>
<li>通知(Advice)：通知定义了具体的横切逻辑。在Spring中，存在两种类型的Advice，即per-class和per-instance的Advice。</li>
</ol>
<p>所谓per-class，即该类型的Advice只提供方法拦截，不会为目标对象保存任何状态或者添加新的特性，它也是我们最常见的Advice。下面是per-class的类图：</p>
<p><img src="" alt=""></p>
<ul>
<li>BeforeAdvice：在连接点前执行的横切逻辑。</li>
<li>AfterReturningAdvice：在连接点执行后，再执行横切逻辑。</li>
<li>AfterAdvice：一般由程序自己实现，当抛出异常后，执行横切逻辑。</li>
<li>AroundAdvice：Spring AOP中并没有提供这个接口，而是采用了AOP Alliance的MethodInteceptor接口；通过看AfterReturningAdvice的源码我们知道，它是不能更改连接点所在方法的返回值的(更改引用)；但使用的MethodInteceptor，所有的事情，都不在话下。</li>
</ul>
<p>在上面的类图中，还有两种类没有介绍，那就是/<em>/</em>/<em>AdviceAdapter和/</em>/<em>/</em>AdviceInteceptor，我们以AfterReturningAdviceInterceptor为例来说明：</p>
<p><img src="" alt=""></p>
<p>该类实现了MethodInterceptor和AfterAdvice接口，同时构造函数中还有一个AfterReturningAdvice实例的参数；这个类存在的作用是为了什么呢？对，没错，Spring AOP把所有的Advice都适配成了MethodInterceptor，统一的好处是方便后面横切逻辑的执行(参看下一节)，适配的工作即由/<em>/</em>/*AdviceAdapter完成；</p>
<p>哈哈，Spring AOP的代码也不过如此嘛：所谓的AfterReturningAdvice，通过适配成MethodInterceptor后，其实就是在invoke方法中，先执行目标对象的方法，再执行的AfterReturningAdvice所定义的横切逻辑。你现在明白它为什么不能修改返回值的引用了吧？</p>
<p>对于per-instance的Advice，目前只有一种实现，就是Introduction，使用的场景比较少，有兴趣的同学可以自己研究一下，呵呵！</p>
<ol>
<li>切面(Aspect)：在Spring中，Advisor就是切面；但与通常的Aspect不同的是，Advisor通常只有一个Pointcut和一个Advice，而Aspect则可以包含多个Pointcut和多个Advice，因此Advisor是一种特殊的Aspect。但，这已经够用了！</li>
</ol>
<p>接下来看下per-class Advisor的类图：</p>
<p><img src="" alt=""></p>
<p>其实没有什么好看的，前面已经说过，Advisor包含一个Pointcut和一个Advisor；在AbstractGenericPointcutAdvisor中，持有一个Advice的引用；下面的几个实现，均是针对前面提到的几种不同的Pointcut的实现。</p>
<p><strong>3.3 Spring AOP实现的基本线索
</strong></p>
<p>我们选择ProxyFactoryBean作为入口点和分析的开始。ProxyFactoryBean是在Spring IoC环境中，创建AOP应用的最底层方法，从中，可以看到一条实现AOP的基本线索。</p>
<p>所有的逻辑从以下的方法开始,我们主要针对单例的代理对象的生成：</p>
<p><img src="" alt=""></p>
<p>下面我们深入到SpringAOP核心代码的内部，看看代理对象的生成机制，拦截器横切逻辑以及织入的实现。</p>
<p><strong>3.4  代理对象的生成
</strong></p>
<p>对于getSingletonInstance()方法返回了什么，这就是代理对象如何产生的逻辑了，然我们须根溯源，看看传说中的proxy到底是如何一步一步的产生的。</p>
<p><img src="" alt=""></p>
<p>ProxyFactoryBean是AdvisedSupport的子类，Spring使用AopProxy接口把AOP代理的实现与框架的其他部分分离开来。在AdvisedSupport中通过这样的方式来得到AopProxy,当然这里需要得到AopProxyFactory的帮助 ，从JDK或者cglib中得到想要的代理对象：</p>
<p><img src="" alt=""></p>
<p>这个DefaultAopProxyFactory是Spring用来生成AopProxy的地方，它包含JDK和Cglib两种实现方式。让我接着往里面看：</p>
<p><img src="" alt=""></p>
<p>可以看到其中的代理对象可以由JDK或者Cglib来生成，JdkDynamicAopProxy类和Cglib2AopProxy都实现的是AopProxy的接口，我们进入JdkDynamicAopProxy实现中看看Proxy是怎样生成的：</p>
<p><img src="" alt=""></p>
<p>用Proxy包装target之后，通过ProxyFactoryBean得到对其方法的调用就被Proxy拦截了， ProxyFactoryBean的getObject()方法得到的实际上是一个Proxy了，target对象已经被封装了。对 ProxyFactoryBean这个工厂bean而言，其生产出来的对象是封装了目标对象的代理对象。</p>
<p><strong>3.5 拦截器的作用
</strong></p>
<p>前面分析了SpringAOP实现中得到Proxy对象的过程，接下来我们去探寻Spring AOP中拦截器链是怎样被调用的，也就是Proxy模式是怎样起作用的。
还记得在JdkDynamicAopProxy中生成Proxy对象的时候，有一句这样的代码吗？</p>
<p><strong>return</strong> Proxy.<em>newProxyInstance</em>(classLoader, proxiedInterfaces, <strong>this</strong>);<em>**</em></p>
<p>这里我们的JdkDynamicAopProxy实现了InvocationHandler这个接口，this参数对应的是InvocationHandler对象,也就是说当 Proxy对象的函数被调用的时候，InvocationHandler的invoke方法会被作为回调函数调用：</p>
<p><img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>上面所说的目标对象方法的调用，是通过AopUtils的方法调用，使用反射机制来对目标对象的方法进行的：</p>
<p><img src="" alt=""></p>
<p>接下来，我们来看具体的ReflectiveMethodInvocation中proceed()方法的实现，也就是拦截器链的实现机制：</p>
<p><img src="" alt=""></p>
<p>从上面的分析我们看到了Spring AOP拦截机制的基本实现，比如Spring怎样得到Proxy，怎样利用JAVA Proxy以及反射机制对用户定义的拦截器链进行处理。</p>
<p><strong>3.6 织入的实现
</strong></p>
<p>在上面调用拦截器的时候，经过一系列的注册，适配的过程以后，拦截器在拦截的时候，会调用到预置好的一个通知适配器，设置通知拦截器，这是一系列Spring设计好为通知服务的类的一个，是最终完成通知拦截和实现的地方，例如对 MethodBeforeAdviceInterceptor的实现是这样的：</p>
<p><img src="" alt=""></p>
<p>可以看到通知适配器将advice适配成Interceptor以后，会调用advice的before方法去执行横切逻辑。这样就成功的完成了before通知的织入。</p>
<p><a href="http://www.goldendoc.org/tag/aop/" title="AOP (1主题)" target="_blank">AOP</a></p>
<h2 id="-spring-ioc-applicationcontext-http-www-goldendoc-org-2010-11-spring_ioc_applicationcontext-2-spring-ioc-applicationcontext-"><a href="http://www.goldendoc.org/2010/11/spring_ioc_applicationcontext-2/" title="永久链接：Spring IoC之ApplicationContext" target="_blank">Spring IoC之ApplicationContext</a></h2>
<p><a href="http://www.goldendoc.org/2010/11/spring_ioc_applicationcontext-2/#comments" target="_blank">0</a></p>
<p>2年前</p>
<p>由<a href="http://www.goldendoc.org/author/iwlh/" title="iwlh发表的文章 " target="_blank">iwlh</a>发布 在<a href="http://www.goldendoc.org/category/spring/" title="Spring (4主题)" target="_blank">Spring</a>
本章主要讲ApplicationContext接口对BeanFactory接口的扩展内容。BeanFactory接口主要围绕着bean和bean相关配置方式，没有关注应用环境的相关配置。ApplicationContext接口从BeanFactory接口派生而来，它与BeanFactory的对比如下图所示：</p>
<p>BeanFactory </p>
<p>ApplicationContext  Bean配置/实例化</p>
<p>Yes </p>
<p>Yes  自动装配BeanPostProcessor</p>
<p>No </p>
<p>Yes  自动装配BeanFactoryPostProcessor</p>
<p>No </p>
<p>Yes  国际化信息（MessageSources）支持</p>
<p>No </p>
<p>Yes  容器内部事件（ApplicationEvent）支持</p>
<p>No </p>
<p>Yes  多配置模块加载</p>
<p>No </p>
<p>Yes </p>
<p><strong>1、统一资源加载
</strong></p>
<p>Spring中提供了org.springframework.core.io.Resource接口作为所有资源的抽象。Spring中默认提供了一些Resource接口的实现类，如图所示：</p>
<p><img src="" alt=""></p>
<p>实现类命名上就可以看出对应的资源，比如ClassPathResource类是从java应用程序的ClassPath中加载相关资源等等。</p>
<p>Spring中使用ResourceLoader来查找和定位Resource资源。ResorceLoader接口类图如下所示：</p>
<p><img src="" alt=""></p>
<p>从上图可以看出，ApplicationContext接口继承自ResourceLoader接口。AbstractApplicationContext抽象类也继承自DefaultResourceLoader类，而且还拥有一个PathMatchingResourcePatternResolver属性字段，需要加载多个Resource时候，委派给PathMatchingResourcePatternResolver类加载即可。</p>
<p>回过来，让我们再看下DefaultResourceLoader中getResource方法的实现代码。</p>
<p><img src="" alt=""></p>
<p>可以看到getResource方法尝试了classPath、url方式加载资源。需要注意的是，该类不能加载相对路径或绝对路径下的资源（例如文件），如果需要加载绝对路径的资源，可以使用FileSystemResourceLoader对象。</p>
<p><strong>2、国际化信息支持
</strong></p>
<p>Java SE中已经有了国际化支持，也就是java.util.Locale和java.util.ResourceBundle。Spring在JavaSE的国际化支持上，进一步抽象了国际化信息的访问接口，提供了org.springframework.context.MessageSource接口，该接口提供一下方法：</p>
<p><img src="" alt=""></p>
<p>ApplicationContext也实现了MessageSource接口。当ApplicationContext初始化时，它会自动在容器中查找名称为”messageSource”的bean。如果找到，对上述方法的调用将被委托给该bean。否则ApplicationContext会在其父类中查找是否含有同名的bean。如果有，就把它作为MessageSource。如果它最终没有找到任何的消息源，一个空的StaticMessageSource将会被实例化，使它能够接受上述方法的调用。messageSource bean的配置实例如下：</p>
<p><img src="" alt=""></p>
<p>Spring提供了三种MessageSource的实现。即StaticMessageSource（提供简单实现，可通过编程方式添加信息条目，多用于测试，不应该用于正式的生产环境）、ResourceBundleMessageSource（基于标准的java.util.ResourceBundle而实现的MessageSource，对父类AbstractMessageSource进行扩展，提供对多个ResourceBundle的缓存以提高查询速度。是最常用的，可用于生产环境下的MessageSource）、ReloadableResourceBundleMessageSource（同样是基于标准的java.util.ResourceBundle而实现的MessageSource，通过cacheSeconds属性可以定期刷新并检查properties资源文件是否发生变化，并且通过ResourceLoader加载properties资源文件。）</p>
<p>另外，MessageSourceAware接口还能用于获取任何已定义的MessageSource引用。任何实现了MessageSourceAware接口的bean将在Spring容器初始化时候与MessageSource一同被注入。</p>
<p>MessageSource与ApplicationContext的类结构图如下所示：</p>
<p><img src="" alt=""></p>
<p><strong>3、Spring容器内部事件发布
</strong></p>
<p>ApplicationContext容器提供了容器内部事件发布功能，是继承自JavaSE标准自定义事件类而实现的。</p>
<p>JavaSE标准自定义事件结构不在此详细描述，一张图很直观的描述清楚：</p>
<p><img src="" alt=""></p>
<p>EventObject，为JavaSE提供的事件类型基类，任何自定义的事件都继承自该类，例如上图中右侧灰色的各个事件。Spring中提供了该接口的子类ApplicationEvent。</p>
<p>EventListener，为JavaSE提供的事件监听者接口，任何自定义的事件监听者都实现了该接口，如上图左侧的各个事件监听者。Spring中提供了该接口的子类ApplicationListener接口。</p>
<p>JavaSE中未提供事件发布者这一角色类， 由各个应用程序自行实现事件发布者这一角色。Spring中提供了ApplicationEventPublisher接口作为事件发布者，并且ApplicationContext实现了这个接口，担当起了事件发布者这一角色。但ApplicationContext在具体实现上有所差异，Spring提供了ApplicationEventMulticaster接口，负责管理ApplicationListener和发布ApplicationEvent。ApplicationContext会把相应的事件相关工作委派给ApplicationEventMulticaster接口实现类来做。类图如下所示：</p>
<p><img src="" alt=""></p>
<p>附上一张事件发布的时序图：</p>
<p><a href="http://pic.yupoo.com/goldendoc/AH0MxsWp/jBIbm.png" target="_blank"><img src="" alt=""></a></p>
<p><strong>4、多配置模块加载
</strong></p>
<p>现在的应用程序，一般都会把配置信息按照某些规则进行分割，将不同类型或关注点的配置项放置在不同的文件中。相对BeanFactory来说，ApplicationContext已经支持了加载多个配置文件。</p>
<p>ApplicationContext加载多个配置文件的方法有：</p>
<p>1) 数组方式</p>
<p>String[] locations = new String[]{ “conf/bean1.xml”,”conf/bean2.xml”, “conf/bean3.xml”};</p>
<p>ApplicationContext container = new FileSystemXmlApplicationContext(locations);</p>
<p>2) 通配符</p>
<p>ApplicationContext container = new FileSystemXmlApplicationContext(“conf//<em>/</em>//*.xml”);</p>
<p>3) ClassPathXmlApplicationContext特性</p>
<p>ApplicationContext ctx = new ClassPathXmlApplicationContext(new String[] {“services.xml”, “daos.xml”}, MessengerService.class);</p>
<p>该方法可以通过MessengerService类在ClassPath中的位置定位配置文件，而不用指定每个配置文件的完整路径名。</p>
<p><a href="http://www.goldendoc.org/tag/applicationcontext/" title="ApplicationContext (1主题)" target="_blank">ApplicationContext</a></p>
<h2 id="-spring-ioc-beanfactory-http-www-goldendoc-org-2010-11-spring-ioc-e4-b9-8bbeanfactory-spring-ioc-beanfactory-"><a href="http://www.goldendoc.org/2010/11/spring-ioc%e4%b9%8bbeanfactory/" title="永久链接：Spring IoC之BeanFactory" target="_blank">Spring IoC之BeanFactory</a></h2>
<p><a href="http://www.goldendoc.org/2010/11/spring-ioc%e4%b9%8bbeanfactory/#comments" target="_blank">0</a></p>
<p>2年前</p>
<p>由<a href="http://www.goldendoc.org/author/khotyn/" title="khotyn发表的文章 " target="_blank">khotyn</a>发布 在<a href="http://www.goldendoc.org/category/spring/" title="Spring (4主题)" target="_blank">Spring</a>
本文的内容为对Spring IoC容器实现的分析。</p>
<p>本文一共分为5个部分：</p>
<ul>
<li>第一部分简要讲述了IoC的概念</li>
<li>第二部分对Spring IoC容器中的主要类及其职责做一些了解</li>
<li>第三部分分析了Spring IoC容器的初始化过程</li>
<li>第四部分分析了从Spring IoC容器中获取Bean的过程</li>
<li>第五部分简要讲述了Spring IoC容器对Bean生命周期的管理。</li>
</ul>
<p>本文假设读者对以下的概念有所了解：IoC（控制反转），DI（依赖注入），Bean，并且读者有使用Spring IoC容器的经验。</p>
<p>约定：本文中所指的IoC容器没有特别说明均为Spring IoC容器</p>
<h3 id="-ioc-"><a href="">一、什么是</a><a href="">IoC</a><a href=""></a></h3>
<p><a href=""></a></p>
<p><a href="">IoC是Inversion of Control的缩写，中文的意思是控制反转，在IoC中，组件不需要去寻找它所依赖的对象，而是由IoC容器来负责将组件所依赖的对象通过Java Bean的Setter方法或者是构造函数等方式注入给组件。IoC的另一个名字是DI，即依赖注入，关于IoC和DI之间的关系以及关于IoC的更多内容，大家可以参考Wiki上的</a><a href="http://www.google.com/url?q=http%3A%2F%2Fzh.wikipedia.org%2Fzh%2F%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC&amp;sa=D&amp;sntz=1&amp;usg=AFQjCNGHDFZSBvJ9wlCDET_IgqV-4DVCzw">控制反转条目。
</a></p>
<p><a href="http://www.google.com/url?q=http%3A%2F%2Fzh.wikipedia.org%2Fzh%2F%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC&amp;sa=D&amp;sntz=1&amp;usg=AFQjCNGHDFZSBvJ9wlCDET_IgqV-4DVCzw">
</a></p>
<h3 id="-http-www-google-com-url-q-http-3a-2f-2fzh-wikipedia-org-2fzh-2f-e6-8e-a7-e5-88-b6-e5-8f-8d-e8-bd-ac-sa-d-sntz-1-usg-afqjcnghdfzsbvj9wlcdet_igqv-4dvczw-ioc-"><a href="http://www.google.com/url?q=http%3A%2F%2Fzh.wikipedia.org%2Fzh%2F%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC&amp;sa=D&amp;sntz=1&amp;usg=AFQjCNGHDFZSBvJ9wlCDET_IgqV-4DVCzw"></a>[二、IoC容器中的类主要类及其职责</h3>
<p>]()</p>
<p><a href="">
我们先来看下IoC容器的一个大概的类图：
</a></p>
<p><a href=""></a><a href="http://www.google.com/url?q=http%3A%2F%2Fpic.yupoo.com%2Fkhotyn%2F816909ab9c75%2Fji8tx5ue.jpg&amp;sa=D&amp;sntz=1&amp;usg=AFQjCNEixIuYlet6oZmgnSPQy-ZxrCs4yA"><img src="" alt=""></a></p>
<p><a href="http://www.google.com/url?q=http%3A%2F%2Fpic.yupoo.com%2Fkhotyn%2F816909ab9c75%2Fji8tx5ue.jpg&amp;sa=D&amp;sntz=1&amp;usg=AFQjCNEixIuYlet6oZmgnSPQy-ZxrCs4yA" target="_blank">点击查看大图</a></p>
<p>这张图中比较简单的展示了IoC容器中的各个类及其指责，我们需要重点把握几个接口的职责：</p>
<ul>
<li>BeanFactory：这个接口是整个IoC容器最底层的接口，定义了一组访问Bean容器的基本方法。一些其他的接口，比如ListableBeanFactory和ConfigurableBeanFactory，都是继承了BeanFactory，并添加了其他的方法来完成某些特别的功能（比如ConfigurableBeanFactory，顾名思义，这个接口的职责是让BeanFactory变得可配置，那么它就定义了一组可以配置BeanFactory的方法）。</li>
<li>AbstractBeanFactory：从名字可以看出，这个类是BeanFactory接口的一个抽象实现类，这个类本身实现的是ConfigurableBeanFactory，对ConfigurableBeanFactory以及BeanFactory中的方法提供了实现，并且提供了一些诸如单例缓存，别名等等功能。</li>
<li>SingletonBeanRegistry：定义了一组操作单例Bean的方法</li>
</ul>
<h3 id="-ioc-"><a href="">三、</a>[IoC容器的初始化</h3>
<p>]()<a href=""></a></p>
<p>[
使用过Spring的人都知道，我们都是在一份Bean配置文件中定义Bean，然后就可以通过BeanFactory的getBean()方法来获取Bean，那么我们就可以大致猜想到IoC容器的初始化工作大概就是将我们编写的Bean配置文件转换成IoC容器内部定义的用于放置Bean定义信息的数据结构，而这个数据结构就是BeanDefinition这个类。下面我们就来了解下这个转换过程是如何进行的。</p>
<p>我们通过实例化ClassPathXmlApplicationContext这个类来一步步来看其初始化的过程，简单地实例化ClassPathXmlApplicationContext的代码如下：</p>
<p><img src="" alt=""></p>
<p>这里我们传入一个beans.xml作为配置文件的路径去实例化一个ClassPathXmlApplicationContext。</p>
<p>首先我们还是来看下整个初始化过程的序列图：
]()</p>
<p><a href=""></a><a href="http://www.google.com/url?q=http%3A%2F%2Fpic.yupoo.com%2Fkhotyn%2F005389ab9c75%2Fogfhmraj.jpg&amp;sa=D&amp;sntz=1&amp;usg=AFQjCNHa07fld9fiZq1BzNzeljU3nfHFXQ"><img src="" alt=""></a></p>
<p><a href="http://www.google.com/url?q=http%3A%2F%2Fpic.yupoo.com%2Fkhotyn%2F005389ab9c75%2Fogfhmraj.jpg&amp;sa=D&amp;sntz=1&amp;usg=AFQjCNHa07fld9fiZq1BzNzeljU3nfHFXQ" target="_blank">点击查看大图</a></p>
<p>这个图中涉及到的类或许有点吓人，且慢，下面我会慢慢带你了解整个过程。从序列图里面我们看到初始化过程首先调用了refresh()方法，后面调用到了AbstractXmlApplicationContext的loadBeanDefinitions方法，来看下这个方法的实现：</p>
<p><img src="" alt=""></p>
<p>这个方法将beanFactory（实现了BeanDefinitionRegistry接口，后续将通过这个接口将Bean定义信息注册到BeanFactory中去）传入new了一个XmlBeanDefinitionReader对象，然后将刚刚new出来的beanDefinitionReader传入调用loadBeanDefinitions方法，最终调用了XmlBeanDefinitionReader的loadBeanDefinitions(EncodedResource encodedResource)方法：</p>
<p><img src="" alt=""></p>
<p>这个方法获取了Bean配置文件的输入流，并且调用了doLoadBeanDefinitions方法，在这个方法里面，程序将输入流转换成Document对象，然后调用了下面这个方法：</p>
<p><img src="" alt=""></p>
<p>需要注意这个createReaderContext(resource)方法，创建这个方法的时候XmlBeanDefinitionReader将自己传入，以便在后面可以获取到它的Registry对象。最终DefaultBeanDefinitionDocumentReader将解析BeanDefinition的工作又交给了BeanDefinitionParserDelegate对象：</p>
<p><img src="" alt=""></p>
<p>从上面的方法中，我们可以看到BeanDefinitionParserDelegate对象解析出BeanDefinition后，就由BeanDefinitionRegistry来将BeanDefinition注册到BeanFactory中去了。</p>
<p>至此，整个BeanFactory就初始化完毕了，可能一大堆方法调来调去地早就把大家给调晕了，我们就来总结下初始化过程中设计到的几个主要的类以及它们的职责吧：</p>
<ul>
<li>XmlBeanDefinitionReader：读取定义Bean的XML文件并且将XML文件转成Document对象，交给BeanDefinitionDocuementReader再做解析。它持有一个BeanDefinitionRegistry对象，用于将BeanDefinition注册到BeanFactory中去。</li>
<li>XmlBeanDefinitionDocumentReader：取出Docuement对象内的各个元素并将这些元素交给BeanDefinitionParserDelegate来解析。</li>
<li>BeanDefinitionParserDelegate：用于解析Bean定义信息的代理类，负责一个Bean定义信息（可以看作是一个<bean></bean>标签对）解析成一个BeanDefinition对象。</li>
<li>BeanDefinitionRegister：负责将BeanDefinition注册到BeanFactory中去。</li>
</ul>
<h3 id="-ioc-bean-"><a href="">四、从</a><a href="">IoC容器中获取Bean</a><a href=""></a></h3>
<p><a href="">
用过Spring的人大概都知道，在Spring中，我们是通过调用BeanFactory的getBean()方法来取得我们所需要的Bean的，而getBean()方法的主要逻辑在AbstactBeanFactory的doGetBean()方法中。在Spring中，有单例Bean和原型Bean的区分，在从容器中获取Bean的时候，单例Bean和原型Bean有些不同，当第一次获取单例Bean的时候，整个过程和获取原型Bean几乎是一样的，都需要创建一个Bean，但是当第二次，第三次，……，获取同样的单例Bean的时候，容器就直接从单例缓存中获取Bean了，而不会再去像获取原型Bean一样一而再再而三地创建Bean了。这样我们这一节也主要从两个方面来讲，一个是获取原型Bean，第一次获取单例Bean的逻辑和这个类似，有特别的地方也会在这里顺带提到，二则是将从单例缓存中获取单例Bean的过程，首先我们来看获取原型Bean：
</a></p>
<h3 id="-4-1-bean"><a href=""></a>[4.1、获取原型Bean</h3>
<p>]()</p>
<p>[
正如前面所说，我们来看下AbstractBeanFactory的doGetBean()方法来了解获取原型Bean的整个过程。</p>
<p>在获取Bean的时候，无论这个Bean是单例的还是原型的，Spring都会尝试从单例缓存中获取Bean，但是当拿原型Bean的时候，这里显然是拿不到的，接下来程序就会根据BeanDefinition信息来判断要创建的Bean是不是原型Bean，如果是，则进入下面这段逻辑：</p>
<p><img src="" alt=""></p>
<p>程序在上图的（1）中的位置调用了beforePrototypeCreation方法，告诉容器当前的这个Bean正在创建中，来防止发生重复创建的情况。接下来，程序在（2）处调用了createBean方法来创建这个prototypeBean，最后，在（3）处，程序调用afterProtytypeCreation来告诉容器，这个Bean现在已经不再创建过程中了。</p>
<p>那么，让我们来关注下createBean这个方法里面干了些什么事情：</p>
<p><img src="" alt=""></p>
<p>在做了一堆准备工作后，程序就到了上面的这一段中，从代码中我们可以看出这个方法主要的功能为以下两点：</p>
<ul>
<li>调用resolveBeforeInstantiation方法，让BeanPostProcessor可以有机会给你返回一个代理类而不是原来的类，当后面我们看到Spring AOP代理类的生成的时候，就会看到这个方法的用处了。</li>
<li>调用doCreateBean()方法创建Bean</li>
</ul>
<p>我们再来看下doCreateBean方法：</p>
<p><img src="" alt=""></p>
<p>同样，这个方法里面也有两个主要的功能：</p>
<ul>
<li>一是调用createBeanInstance方法，创建一个Bean实例，在这个方法的内部，会调用BeanUtils的instantiateClass来实例化Bean，并把它包装成一个BeanWrapper</li>
<li>二是调用populateBean方法来将Bean依赖的属性设置进去。
]()</li>
</ul>
<h3 id="-4-2-bean"><a href=""></a>[4.2、创建单例Bean</h3>
<p>]()</p>
<p>[
整个获取原型Bean的过程大概就是这样样子，因为创建单例Bean和这个过程基本上是一样的，但是也有一些稍微不一样的地方，这里也稍微提到一下：</p>
<p><img src="" alt=""></p>
<p>创建单例Bean是通过调用getSingleton来实现的，这个方法传入一个beanName和一个ObjectFactory，这个ObjectFactory的getObject方法里面调用到了我们前面提到的createBean方法，所以我们看下getSingleton这个方法的实现：</p>
<p><img src="" alt=""></p>
<p>这个方法先尝试从singletonObjects中获取单例Bean，如果获取不到，则自己创建，同样，和创建原型Bean一样，在创建开始之前会调用beforeSingletonCreation方法来将beanName放到singletonsCurrentlyInCreation来告诉容器这个Bean已经在创建中了，在创建完成之后，会将BeanName从singletonsCurrentlyInCreation中删除掉。创建的过程是调用了传入的ObjectFactory的getObject方法，和创建原型Bean类似。在创建完成之后，还有一步addSingleton的操作，来讲单例放到单例缓存中去，看一下这个的实现：</p>
<p><img src="" alt=""></p>
<p>方法的逻辑非常简单：把创建出来的单例Bean放到singletonObjects中去，然后从singletonFactories和earlySingletonObjects中删除掉，最后在registeredSingletons里面再加入这个Bean，对于这里面用到的几个容器，我觉得有必要在这里描述一下其作用，要不然读者肯定是晕呼晕呼的：</p>
<ul>
<li>singletonObjects：用于保存BeanName和Bean实例之间的关系</li>
<li>singletonFactories：用于保存BeanName和创建Bean的工厂之间的关系</li>
<li>earlySingletonObjects：也是保存BeanName和Bean实例之间的关系，与singletonObjects的不同之处在于，当一个单例Bean被放到这里面去后，那么当Bean还在创建过程中，就可以通过getBean来拿到了，其目的是用来检测循环引用。</li>
<li>registeredSingletons：用来保存当前所有已注册的Bean
]()</li>
</ul>
<h3 id="-4-3-bean"><a href=""></a>[4.3、从单例缓存中获取单例Bean</h3>
<p>]()</p>
<p>[
单例在Spring的同一个容器内只会被创建一次，后续再获取Bean，就直接从单例缓存中获取了，我们来看下这一段过程，看下doGetBean里面调用的getSingleton方法：</p>
<p><img src="" alt=""></p>
<p>这个方法的逻辑也相对简单，先尝试从singletonObjects里面获取，如果获取不到再从earlySingletonObjects里面获取，如果再获取不到，再尝试从singletonFactories里面获取beanName对应的ObjectFactory，然后调用这个ObjectFactory的getObject来创建Bean，并放到earlySingletonObjects里面去，并且从singletonFacotories里面remove掉这个ObjectFactory。</p>
<h3 id="-ioc-bean-">六、IoC容器对Bean生命周期的管理</h3>
<p>Spring有一套Bean生命周期去管理Bean，值得注意的是，Spring只对非单例的Bean进行生命周期管理。关于Spring中Bean的生命周期，我们来看下一张老图：</p>
<p><img src="" alt=""></p>
<p>在上面这张图里面，我们看到有很多的生命周期方法，那么这些生命周期方法是在哪里调用的呢？在前面获取原型Bean的一节中，我们已经知道，Spring会先调用createBeanInstance方法来创建Bean实例，然后通过populateBean方法来设置Bean的属性，在调用这个方法之后，其实Spring还调用了一个initializeBean的方法，上图中我们看到的生命周期方法基本上都在这个方法里面调用：</p>
<p><img src="" alt=""></p>
<p>在这个方法里面：</p>
<ul>
<li>Spring首先调用了invokeAwareMethods来调用各个Aware方法，包括BeanNameAware，BeanClassLoaderAware和BeanFactoryAware</li>
<li>然后调用了所有BeanPostProcessor的postProcessBeforeInitialization方法</li>
<li>接着调用invokeInitMethods方法，里面包括调用afterPropertiesSet和自定义的init方法</li>
<li>最后调用了所有BeanPostProcessor的postProcessAfterInitialization方法</li>
</ul>
<p>在调用这些方法以后，我们的Bean才算是可以使用啦。至于生命周期的最后两个方法，是在容器销毁的时候来调用的。
]()<a href=""></a></p>
<p><a href=""></a></p>
<p><a href=""></a><a href="http://www.goldendoc.org/tag/beanfactory/" title="BeanFactory (1主题)">BeanFactory</a></p>
<p>*</p>
<ul>
<li><h3 id="-">分类</h3>
</li>
<li><p><a href="http://www.goldendoc.org/category/java-nio/" title="查看 Java NIO下的所有文章" target="_blank">Java NIO <strong>(9)</strong> Java NIO相关内容</a></p>
</li>
<li><a href="http://www.goldendoc.org/category/jms/" title="查看 JMS下的所有文章" target="_blank">JMS <strong>(3)</strong> Java Messaging Service</a></li>
<li><a href="http://www.goldendoc.org/category/juc/" title="查看 JUC下的所有文章" target="_blank">JUC <strong>(4)</strong></a></li>
<li><a href="http://www.goldendoc.org/category/jvm/" title="查看 JVM下的所有文章" target="_blank">JVM <strong>(8)</strong> Java Virtual Machine</a></li>
<li><a href="http://www.goldendoc.org/category/spring/" title="查看 Spring下的所有文章" target="_blank">Spring <strong>(4)</strong></a></li>
<li><a href="http://www.goldendoc.org/category/tomcat/" title="查看 Tomcat下的所有文章" target="_blank">Tomcat <strong>(7)</strong></a></li>
<li><a href="http://www.goldendoc.org/category/translation/" title="查看 翻译下的所有文章" target="_blank">翻译 <strong>(1)</strong></a></li>
<li><h3 id="-">最新评论</h3>
</li>
<li><p><a href="http://www.goldendoc.org/2012/01/optimization-barrier3/#comment-306" title="在 优化屏障（Optimization barrier）第三讲" target="_blank"><img src="" alt="熊猫家族">  熊猫家族 很详细，了解了很多 5个月前</a></p>
</li>
<li><a href="http://www.goldendoc.org/2011/06/juc_concurrenthashmap/#comment-304" title="在 Java并发编程之ConcurrentHashMap" target="_blank"><img src="" alt="聊聊并发（四）深入分析ConcurrentHashMap并发编程网 | 并发编程网">  聊聊并发（四）深入分析ConcurrentHashMap并发编程网 | 并发编程网 [...] Java并发编程之ConcurrentHashMap [...] 6个月前</a></li>
<li><a href="http://www.goldendoc.org/2011/06/juc_concurrenthashmap/#comment-301" title="在 Java并发编程之ConcurrentHashMap" target="_blank"><img src="" alt="Jun">  Jun for (HashEntry p = first; p != e; p = p.next) newFirst = new HashEntry(p.key, p.hash, […] 6个月前</a></li>
<li><a href="http://www.goldendoc.org/2011/06/juc_concurrenthashmap/#comment-294" title="在 Java并发编程之ConcurrentHashMap" target="_blank"><img src="" alt="khotyn">  khotyn 这里是我搞错了，已经纠正过来了，谢谢赵姐夫指正。 7个月前</a></li>
<li><a href="http://www.goldendoc.org/2011/06/juc_concurrenthashmap/#comment-293" title="在 Java并发编程之ConcurrentHashMap" target="_blank"><img src="" alt="老赵">  老赵 这里Segment的数量是不大于concurrentLevel的最大的2的指数 应该是“不小于concurrentLevel”的最小的2的指数吧。 7个月前</a>
<a href="&quot;显示下5个条目&quot;">显示更多</a></li>
<li><h3 id="-">最新文章</h3>
</li>
<li><p><a href="http://www.goldendoc.org/2013/01/parentdelegation/" title="从问题出发看双亲委派" target="_blank">从问题出发看双亲委派 (0)  同事A问了这样一个问题： <em>BootstrapClassLoader为什么能够加载用户自定义的类？</em> 当时我想到的是这样的场景： javaagent设置Boot-Class-Path，或者添加启动参数-Xbootclasspath、-Xbootclasspath/a […] 5个月前</a></p>
</li>
<li><a href="http://www.goldendoc.org/2012/07/somethings_i_ve_learnt_about_programming/" title="我学到的一些关于编程的事儿（翻译）" target="_blank">我学到的一些关于编程的事儿（翻译） (3) 原文地址：Some things I&#39;ve learnt about programming ---- By John Graham-Cumming 我已经从事编程 30 年了，用过的机器包括从现在看来很差的（基于 Z80 和 6502）到最新的，用过的语言包括 […] 11个月前</a></li>
<li><a href="http://www.goldendoc.org/2012/02/classloader-jvm/" title="ClassLoader与JVM" target="_blank">ClassLoader与JVM (0) <strong>一、ClassLoader与HotSpot</strong> 对JVM有所了解的人应该知道，类文件的格式是不能违背JVM规范的，而JVM自然会有解析类文件的工具ClassFileParser。 ClassFileParser由ClassFileStream/*构造，其实 […] 1年前</a></li>
<li><a href="http://www.goldendoc.org/2012/01/optimization-barrier3/" title="优化屏障（Optimization barrier）第三讲" target="_blank">优化屏障（Optimization barrier）第三讲 (1) 上一篇 优化屏障（Optimization barrier）第二讲 1. […] 1年前</a></li>
<li><a href="http://www.goldendoc.org/2012/01/optimization-barrier2/" title="优化屏障（Optimization barrier）第二讲" target="_blank">优化屏障（Optimization barrier）第二讲 (1) 上一篇 优化屏障（Optimization barrier）第一讲 1. gcc编译的大致过程 可以看到，gcc优化主要分两大部分:Tree优化和RTL(Register Transfer Language)优化； 前文所说的指令调度（Instruction […] 1年前</a>
<a href="&quot;显示下5个条目&quot;">显示更多</a></li>
<li><h3 id="-">友情链接</h3>
</li>
<li><p><a href="http://ifeve.com/" target="_blank">并发编程促进并发编程的研究和传播</a>
自豪地使用<a href="http://wordpress.org/" target="_blank">WordPress</a>，Mystique主题来自<a href="http://digitalnature.eu/" target="_blank">digitalnature</a> | <a href="http://www.goldendoc.org/feed/" target="_blank">RSS订阅</a>  <a href="">回到顶部</a></p>
</li>
</ul>
<p><a href=""> </a></p>
<p><a href=""> </a></p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/框架汇总/">框架汇总</a></li></span><span class="breadcrumb"><li><a href="/categories/框架汇总/">框架汇总</a></li><li><a href="/categories/框架汇总/Spring/">Spring</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Spring/" class="label label-primary">Spring</a><a href="/tags/框架汇总/" class="label label-success">框架汇总</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:29"datetime="2014-03-07 09:54:29"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-框架汇总-Spring--Spring-设计模式-aop-ioc/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-框架汇总-Spring--Spring-设计模式-aop-ioc" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-框架汇总-ORM-hibernate--Hibernate性能调优（转载--作者：RobbinFan）/">Hibernate性能调优（转载</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:29.000Z"> <a href="/2014/02/02/2014-02-02-框架汇总-ORM-hibernate--Hibernate性能调优（转载--作者：RobbinFan）/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="hibernate-robbin-fan-">Hibernate性能调优（转载--作者：Robbin Fan）</h1>
<hr>
<p><strong>一。**</strong>inverse = ?**</p>
<pre><code>      inverse=false(default)

                  用于单向one-to-many关联

                  parent.getChildren().add(child) // insert child

                  parent.getChildren().delete(child) // delete child

       inverse=true

                  用于双向one-to-many关联

                  child.setParent(parent); session.save(child) // insert child

                   session.delete(child)

        在分层结构的体系中

         parentDao, childDao对于CRUD的封装导致往往直接通过session接口持久化对象，而很少通过关联对象可达性
</code></pre><p><strong>二。**</strong>one-to-many<strong>**关系</strong></p>
<pre><code>            单向关系还是双向关系？

                 parent.getChildren().add(child)对集合的触及操作会导致lazy的集合初始化，在没有对集合配置二级缓存的情况下，应避免此类操作

               select /* from child where parent_id = xxx;

      性能口诀：

              1. 一般情况下避免使用单向关联，尽量使用双向关联

              2. 使用双向关联，inverse=“true”

              3. 在分层结构中通过DAO接口用session直接持久化对象，避免通过关联关系进行可达性持久化
</code></pre><p><strong>三。**</strong>many-to-one<strong>**关系</strong></p>
<pre><code>     单向many-to-one表达了外键存储方

     灵活运用many-to-one可以避免一些不必要的性能问题

     many-to-one表达的含义是：0..n : 1，many可以是0，可以是1，也可以是n，也就是说many-to-one可以表达一对多，一对一，多对一关系

      因此可以配置双向many-to-one关系，例如：

            1.   一桌四人打麻将，麻将席位和打麻将的人是什么关系？是双向many-to-one的关系
</code></pre><p><strong>四。**</strong>one-to-one**</p>
<pre><code>        通过主键进行关联

        相当于把大表拆分为多个小表

        例如把大字段单独拆分出来，以提高数据库操作的性能

        Hibernate的one-to-one似乎无法lazy，必须通过bytecode enhancement
</code></pre><p><strong>五。集合**</strong>List/Bag/Set**</p>
<pre><code>        one-to-many

           1.    List需要维护index column，不能被用于双向关联，必须inverse=“false”，被谨慎的使用在某些稀有的场合

           2.      Bag/Set语义上没有区别

           3.       我个人比较喜欢使用Bag

       many-to-many

           1.      Bag和Set语义有区别

           2。   建议使用Set
</code></pre><p><strong>六。集合的过滤</strong></p>
<pre><code>         1. children = session.createFilter(parent.getChildren(), “where this.age &gt; 5 and   this.age &lt; 10”).list()

     针对一对多关联当中的集合元素非常庞大的情况，特别适合于庞大集合的分页：

               session.createFilter(parent.getChildren(),“”).setFirstResult(0).setMaxResults(10).list();
</code></pre><p>在hibernate 中用 super.getSession().createFilter( , )</p>
<p><strong>七。继承关系当中的隐式多态</strong></p>
<pre><code>       HQL: from Object

         1.     把所有数据库表全部查询出来

          2.     polymorphism=“implicit”(default)将当前对象，和对象所有继承子类全部一次性取出

          3.      polymorphism=“explicit”，只取出当前查询对象
</code></pre><p><strong>八。**</strong>Hibernate<strong>**二级缓存</strong></p>
<pre><code>          著名的n+1问题：from Child，然后在页面上面显示每个子类的父类信息，就会导致n条对parent表的查询：

               select /* from parent where id = ?

               .......................

               select /* from parent where id = ?

          解决方案

                    1.      eager fetch

                     2.      二级缓存
</code></pre><p><strong>九。**</strong>inverse<strong>**和二级缓存的关系</strong></p>
<pre><code>        当使用集合缓存的情况下：

             1.     inverse=“false”，通过parent.getChildren()来操作，Hibernate维护集合缓存

              2.    inverse=“true”，直接对child进行操作，未能维护集合缓存！导致缓存脏数据

              3.    双向关联，inverse=“true”的情况下应避免使用集合缓存
</code></pre><p><strong>十。**</strong>Hibernate<strong><strong>二级缓存是提升</strong></strong>web<strong>**应用性能的法宝</strong></p>
<pre><code>          OLTP类型的web应用，由于应用服务器端可以进行群集水平扩展，最终的系统瓶颈总是逃不开数据库访问；

       哪个框架能够最大限度减少数据库访问，降低数据库访问压力， 哪个框架提供的性能就更高；针对数据库的缓存策略：

                1.        对象缓存：细颗粒度，针对表的记录级别，透明化访问，在不改变程序代码的情况下可以极大提升web应用的性能。对象缓存是ORM的制胜法宝。

                2.       对象缓存的优劣取决于框架实现的水平，Hibernate是目前已知对象缓存最强大的开源ORM

                3.        查询缓存：粗颗粒度，针对查询结果集，应用于数据实时化要求不高的场合
</code></pre><p><strong>十一。应用场合决定了系统架构</strong></p>
<p>一、是否需要ORM</p>
<p>Hibernate or iBATIS？</p>
<p>二、采用ORM决定了数据库设计</p>
<pre><code>        Hibernate：

                倾向于细颗粒度的设计，面向对象，将大表拆分为多个关联关系的小表，消除冗余column，通过二级缓存提升性能（DBA比较忌讳关联关系的出现，但是ORM的缓存将突破关联关系的性能瓶颈）；Hibernate的性能瓶颈不在于关联关系，而在于大表的操作

        iBATIS：

                倾向于粗颗粒度设计，面向关系，尽量把表合并，通过表column冗余，消除关联关系。无有效缓存手段。iBATIS的性能瓶颈不在于大表操作，而在于关联关系。
</code></pre><p>总结：</p>
<pre><code> 性能口诀

           1、使用双向一对多关联，不使用单向一对多

           2、灵活使用单向多对一关联

           3、不用一对一，用多对一取代

           4、配置对象缓存，不使用集合缓存

           5、一对多集合使用Bag，多对多集合使用Set

           6、继承类使用显式多态

           7、表字段要少，表关联不要怕多，有二级缓存撑腰
</code></pre><p>最近开始留意项目中的Hibernate的性能问题，希望可以抽出时间学习一下hiberante的性能优化。主要是对数据库连接池技术、hibernate二级缓存、hibernate的配置优化等问题进行学习！</p>
<p>1.关联关系：</p>
<p>普通的关联关系：是不包括一个连接表，也就是中间表如：</p>
<p>create table Person(personId bigint not null primary key,addressId bigint not null)</p>
<p>create table Address(addressId bigint not null primary key)</p>
<p>也就是不会还有一个关系表如：</p>
<p>create table Person(personId bigint not null primary key)</p>
<p>create table Address(addressId bigint not null primary key)</p>
<p>create table PersonAddress(personId bigint not null,ddressId bigint not null primary key)</p>
<p>单向many-to-one关联是最常见的，而单向one-to-many是不常见的</p>
<ol>
<li>inner join(内连接)</li>
</ol>
<p>left (outer) join（左外连接）</p>
<p>right (outer) join (右外连接)</p>
<p>full join (全连接，并不常用)</p>
<p>3.小技巧：</p>
<p>统计结果数目：</p>
<p>(Integer)session.iterator(&quot;select count(/*) from ..&quot;).next()).intValue();</p>
<p>根据一个集合大小来排序：</p>
<p>select user.id,user.name</p>
<p>from User as user.name</p>
<pre><code>left join user.messages msg
</code></pre><p>group by user.id,user.name</p>
<p>having count(msg)&gt;=1</p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/框架汇总/">框架汇总</a></li></span><span class="breadcrumb"><li><a href="/categories/框架汇总/">框架汇总</a></li><li><a href="/categories/框架汇总/ORM/">ORM</a></li><li><a href="/categories/框架汇总/ORM/hibernate/">hibernate</a></li></span></span> | <span class="tags">Tagged <a href="/tags/ORM/" class="label label-primary">ORM</a><a href="/tags/hibernate/" class="label label-success">hibernate</a><a href="/tags/框架汇总/" class="label label-info">框架汇总</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:29"datetime="2014-03-07 09:54:29"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-框架汇总-ORM-hibernate--Hibernate性能调优（转载--作者：RobbinFan）/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-框架汇总-ORM-hibernate--Hibernate性能调优（转载--作者：RobbinFan）" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-框架汇总-ORM-hibernate--Hibernate总结/">Hibernate总结</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:29.000Z"> <a href="/2014/02/02/2014-02-02-框架汇总-ORM-hibernate--Hibernate总结/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="hibernate-">Hibernate总结</h1>
<p><a href="http://blog.csdn.net/llhhyy1989/article/details/7300599" target="_blank">Hibernate总结</a></p>
<p>看了大约十天的视频，从整体上了解一下hibernate，hibernate的优缺点以及如何搭建hibernate，在上篇博客中已经介绍。</p>
<p>   目前在看ssh，但是具体的细节没有研究，只是从整体了解其出现的原因以及如何配置，但是里面涉及到细节部分，暂时不做研究，根据后期的学习，会进行深刻理解。</p>
<p>  现在自己的java知识不够，这个阶段需要狂塞，猛汲取，整体上尽量消化。后期再对其进行研究细化。</p>
<p>   那我们看一下hibernate中整体的内容：</p>
<p><img src="" alt=""></p>
<p>   我们一一介绍其中的内容。</p>
<ol>
<li>Hibernate出现的原因上篇博客已经介绍，可以参考《Hibernate介绍》</li>
<li>Hibernate中的核心五大接口，在上篇博客中也已经介绍，可以参考《Hibernate介绍》</li>
<li>如何搭建Hibernate，请参考《八步详解Hibernate的搭建及使用》</li>
<li>持久化对象的三种状态。</li>
</ol>
<p>分别为：瞬时状态（Transient），持久化状态（Persistent），离线状态（Detached）。三种状态下的对象的生命周期如下：</p>
<p><img src="" alt=""></p>
<p>三种状态的区别是：瞬时状态的对象：没有被session管理，在数据库没有；持久化状态的对象：被session管理，在数据库存在，当属性发生改变，在清理缓存时，会自动和数据库同步；离线状态：没有被session管理，但是在数据库中存在。
来源： <a href="[http://blog.csdn.net/llhhyy1989/article/details/7300599](http://blog.csdn.net/llhhyy1989/article/details/7300599)">[http://blog.csdn.net/llhhyy1989/article/details/7300599](http://blog.csdn.net/llhhyy1989/article/details/7300599)</a> </p>
<p>5.测试工具Juit。</p>
<p>测试类需要继承TestCase，编写单元测试方法，方法名称必须为test开头，方法没有参数没有返回值，采用public修饰。其中在测试中，查询对象时，使用get或者load两种方法进行加载，这种方法的区别：get不支持延迟加载，而load默认情况下是支持延迟加载。并且get查询对象不存在时，返回null；而load查询对象不存在时，则抛出ObjectNotFoundException异常。</p>
<p>6.悲观锁和乐观锁解释。</p>
<p>悲观锁为了解决并发性，跟操作系统中的进程中添加锁的概念一样。就是在整个过程中在事务提交之前或回滚之前，其他的进程是无法访问这个资源的。悲观锁的实现方式有两种：一种使用数据库中的独占锁；另一种是在数据库添加一个锁的字段。hibernate中声明锁如下：</p>
<p>Account account = (Account)session.get(Account.class, 1, LockMode.UPGRADE);而net.sf.hibernate.LockMode类表示锁模式，当取值LockMode.UPGRADE时，则表示使用悲观锁for update；而乐观锁是为了解决版本冲突的问题。就是在数据库中添加version字段，每次更新时，则把自己的version与数据库中的version进行比较，若是版本相比较低，则不允许进行修改更新。</p>
<p>7.H ibernate中的缓存机制。</p>
<p>缓存是什么呢？缓存是应用程序和数据库之间的内存的一片区域。主要的目的是：为了减少对数据库读取的时间。当查询数据时，首先在缓存中查询，若存在，则直接取出，若不存在，然后再向数据库中查询。所以应该把经常访问数据库的数据放到缓存中，至于缓存中的数据如何不断的置换，这也需要涉及一种淘汰数据的算法。</p>
<p>谈到这个hibernate中的缓存，你想到了什么呢？刚才叙述缓存时，是否感觉很熟悉，感觉从哪也听过似的。嗯呢，是呢，是很熟悉，写着写着就很熟悉，这个刚才的缓存以及缓存的置换算法就和计算机组成中的cache类似。</p>
<p>好吧，来回到我们hibernate中的缓存。</p>
<p>hibernate中的缓存可以分为两种：一级缓存，也称session缓存；二级缓存，是由sessionFactory管理。</p>
<p>那一级缓存和二级缓存有什么区别呢？区别的关键关于：缓存的生命周期，也就是缓存的范围不同。</p>
<p>那首先介绍一下缓存的生命周期，也就是缓存的范围。</p>
<p>1.事务缓存，每个事务都有自己的缓存，当事务结束，则缓存的生命周期同样结束，正如上篇博客中我们提到，对数据库的操作，增删改查都是放到事务中的，和事务保持同步，若是事务提交完毕，一般是不允许是再次对数据库进行操作。所以session是属于事务缓存的。</p>
<p>2.应用缓存，一个应用程序中的缓存，也就是应用程序中的所有事务的缓存。只有当应用程序结束时，此时的缓存的额生命周期结束。二级缓存就是应用缓存。</p>
<p>3.集群缓存，被一台机器或多台机器的进程共享。</p>
<p>这下明白了一级缓存和二级缓存的区别了吧。那一级缓存和二级缓存的共同点是：都是缓存实体属性，</p>
<p>二级缓存一般情况都是由第三方插件实现的。第三方插件如：</p>
<p>EHCache，JbossCache（是由Jboss开源组织提供的），osCache(open symphony)，swarmCache。前三种对hibernate中的查询缓存是支持的，后一种是不支持hibernate查询缓存。</p>
<p>那什么是hibernate查询缓存呢？</p>
<p>查询缓存是用来缓存普通属性的，对于实体对象而言，是缓存实体对象的id。
来源： <a href="[http://blog.csdn.net/llhhyy1989/article/details/7306009](http://blog.csdn.net/llhhyy1989/article/details/7306009)">[http://blog.csdn.net/llhhyy1989/article/details/7306009](http://blog.csdn.net/llhhyy1989/article/details/7306009)</a> 8.hql查询。</p>
<p>  Hibernate query language。hql查询中关键字不区分大小写，但是类和属性都是区分大小写的。</p>
<p>  1.简单属性查询。</p>
<p>  单一属性查询，返回属性结果集列表，元素类型和实体类的相应的类型一致。
<strong>[java]</strong> <a href="http://blog.csdn.net/llhhyy1989/article/details/7307436#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/llhhyy1989/article/details/7307436#" title="copy" target="_blank">copy</a><a href="http://blog.csdn.net/llhhyy1989/article/details/7307436#" title="print" target="_blank">print</a><a href="http://blog.csdn.net/llhhyy1989/article/details/7307436#" title="?" target="_blank">?</a></p>
<ol>
<li>List students = session.createQuery(&quot;select name from Student&quot;).list();  </li>
<li></li>
<li>for (Iterator iter=students.iterator(); iter.hasNext();) {  </li>
<li></li>
<li>String name = (String)iter.next();  </li>
<li></li>
<li>System.out.println(name);  </li>
<li></li>
<li>}  </li>
</ol>
<p> //返回结果集属性列表，元素类型和实体类中的属性类型一致</p>
<p>多个属性查询，多个属性查询返回数组对象，对象数组的长度取决于属性的个数，对象数组中的元素类型与实体类中属性一致。
<strong>[java]</strong> <a href="http://blog.csdn.net/llhhyy1989/article/details/7307436#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/llhhyy1989/article/details/7307436#" title="copy" target="_blank">copy</a><a href="http://blog.csdn.net/llhhyy1989/article/details/7307436#" title="print" target="_blank">print</a><a href="http://blog.csdn.net/llhhyy1989/article/details/7307436#" title="?" target="_blank">?</a></p>
<ol>
<li>List students = session.createQuery(&quot;select id, name from Student&quot;).list();  </li>
<li></li>
<li>for (Iterator iter=students.iterator(); iter.hasNext();) {  </li>
<li></li>
<li>Object[] obj = (Object[])iter.next();  </li>
<li></li>
<li>System.out.println(obj[0] + &quot;, &quot; + obj[1]);  </li>
<li></li>
<li>}  </li>
</ol>
<p>2.实体对象查询</p>
<p>List students = session.createQuery(&quot;from Student&quot;).list();</p>
<p>当然这种hql语句，可以使用别名,as可以省去，如：from Student as s,若是使用select关键字，则必须使用别名。如：select s from Student as s.但是不支持select /* from Student格式。</p>
<p>查询中使用list和Iterate区别：</p>
<p>list查询是直接运行查询的结果，所以只有一句sql语句。而iterate方法则有可能会产生N+1条sql语句。这是怎么回事呢？要理解N+1条语句，首先得弄明白iterate是如何执行查询的？</p>
<p>首先发出一条查询对象ID的语句，然后根据对象的ID到缓存（缓存的概念上篇博客已经提到）中查找，若是存在查询出此对象的其他的属性，否则会发出N条语句，此时的N语句，是刚才第一次查询的记录条数。这种现象就是N+1sql语句。</p>
<p>其中list是默认情况下都发出sql语句，查询出的结果会放到缓存中，但是它不会利用缓存，即使放进去，下次执行时，仍然继续发出sql语句。</p>
<p>而：iterate默认情况下会利用缓存，若是缓存中有则不会发出N+1条语句。</p>
<p>3.条件查询。</p>
<p>这种方式就是传入参数，使用参数占位符“？”。也可以使用“：参数名”</p>
<p>java代码如下：
<strong>[java]</strong> <a href="http://blog.csdn.net/llhhyy1989/article/details/7307436#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/llhhyy1989/article/details/7307436#" title="copy" target="_blank">copy</a><a href="http://blog.csdn.net/llhhyy1989/article/details/7307436#" title="print" target="_blank">print</a><a href="http://blog.csdn.net/llhhyy1989/article/details/7307436#" title="?" target="_blank">?</a></p>
<ol>
<li>List students = session.createQuery(&quot;select s.id, s.name from Student s where s.name like ?&quot;)  </li>
<li></li>
<li>.setParameter(0, &quot;%0%&quot;)  </li>
<li></li>
<li>.list();  </li>
<li></li>
<li>List students = session.createQuery(&quot;select s.id, s.name from Student s where s.name like :myname&quot;)  </li>
<li></li>
<li>.setParameter(&quot;myname&quot;,  &quot;%0%&quot;)  </li>
<li></li>
<li><p>.list();  </p>
<p>4.使用原生sql语句。</p>
<p>  和咱们原先写入的sql语句一样。在此不介绍了。</p>
<p>5.外置命名查询。</p>
<p>   这个听起来有点晦涩，怎么理解呢？其实通俗的说就是把hql语句写在外面，写在映射文件中。使用标签：</p>
</li>
</ol>
<p><strong>[html]</strong> <a href="http://blog.csdn.net/llhhyy1989/article/details/7307436#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/llhhyy1989/article/details/7307436#" title="copy" target="_blank">copy</a><a href="http://blog.csdn.net/llhhyy1989/article/details/7307436#" title="print" target="_blank">print</a><a href="http://blog.csdn.net/llhhyy1989/article/details/7307436#" title="?" target="_blank">?</a></p>
<ol>
<li><query name="queryStudent">  </li>
<li></li>
<li>&lt;![CDATA[ 
1.</li>
<li>select s from Student s where s.id &lt;? 
1.</li>
<li>]]&gt;  </li>
<li></li>
<li></query>  </li>
</ol>
<pre><code>那在程序中是如何使用此标签的呢？使用session.getNameQuery()，并进行赋值，代码如下：
</code></pre><p><strong>[java]</strong> <a href="http://blog.csdn.net/llhhyy1989/article/details/7307436#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/llhhyy1989/article/details/7307436#" title="copy" target="_blank">copy</a><a href="http://blog.csdn.net/llhhyy1989/article/details/7307436#" title="print" target="_blank">print</a><a href="http://blog.csdn.net/llhhyy1989/article/details/7307436#" title="?" target="_blank">?</a></p>
<ol>
<li>List students = session.getNamedQuery(&quot;queryStudent&quot;)  </li>
<li></li>
<li>.setParameter(0, 10)  </li>
<li></li>
<li>.list();  </li>
</ol>
<p> 6.查询过滤器。</p>
<pre><code>这个是什么意思呢？过滤器大家很熟悉吧，不熟悉的可以参考我的以前博客&lt;&gt;.原来我们接触过编码过滤器，编码过滤器就是为了避免当时每个页面需要设置编码格式而提出的。这个查询过滤器其实也是这个意思。若是代码都需要某一句sql语句的话，可以考虑使用它。这样可以避免每次都写查询语句。

使用如下：首先在映射文件中配置标签：
</code></pre><p><strong>[html]</strong> <a href="http://blog.csdn.net/llhhyy1989/article/details/7307436#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/llhhyy1989/article/details/7307436#" title="copy" target="_blank">copy</a><a href="http://blog.csdn.net/llhhyy1989/article/details/7307436#" title="print" target="_blank">print</a><a href="http://blog.csdn.net/llhhyy1989/article/details/7307436#" title="?" target="_blank">?</a></p>
<ol>
<li><filter-def name="testFilter">  </li>
<li></li>
<li><filter-param type="integer" name="myid"/>  </li>
<li></li>
<li></filter-def>  </li>
</ol>
<p>  然后程序中如下使用并进行赋值：
<strong>[java]</strong> <a href="http://blog.csdn.net/llhhyy1989/article/details/7307436#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/llhhyy1989/article/details/7307436#" title="copy" target="_blank">copy</a><a href="http://blog.csdn.net/llhhyy1989/article/details/7307436#" title="print" target="_blank">print</a><a href="http://blog.csdn.net/llhhyy1989/article/details/7307436#" title="?" target="_blank">?</a></p>
<ol>
<li>session.enableFilter(&quot;testFilter&quot;)  </li>
<li></li>
<li>.setParameter(&quot;myid&quot;, 10);  </li>
</ol>
<p>7.分页查询。</p>
<pre><code>分页查询，这个肯定不陌生，因为在做drp项目时，做的最多的是分页，当时使用oracle数据库，分页查询涉及到三层嵌套。直接传入的参数为：每页的大小（记录数），页号。

 Hibernate中给我们已经封装好了，只要设置开始的页号以及每页的大小即可，不用亲自动手写嵌套的sql语句。

 代码如下：
</code></pre><p><strong>[java]</strong> <a href="http://blog.csdn.net/llhhyy1989/article/details/7307436#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/llhhyy1989/article/details/7307436#" title="copy" target="_blank">copy</a><a href="http://blog.csdn.net/llhhyy1989/article/details/7307436#" title="print" target="_blank">print</a><a href="http://blog.csdn.net/llhhyy1989/article/details/7307436#" title="?" target="_blank">?</a></p>
<ol>
<li>List students = session.createQuery(&quot;from Student&quot;)  </li>
<li></li>
<li>.setFirstResult(1)  </li>
<li></li>
<li>.setMaxResults(2)  </li>
<li></li>
<li>.list();  </li>
</ol>
<p>8.对象导航查询。</p>
<p>这个什么意思呢？这个只要是用于一个类的属性是另一个类的引用。比如：student类中有一个classes属性。其中的classes也是一个类Class的引用。</p>
<p>当我们查询的时候可以这样使用：
<strong>[java]</strong> <a href="http://blog.csdn.net/llhhyy1989/article/details/7307436#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/llhhyy1989/article/details/7307436#" title="copy" target="_blank">copy</a><a href="http://blog.csdn.net/llhhyy1989/article/details/7307436#" title="print" target="_blank">print</a><a href="http://blog.csdn.net/llhhyy1989/article/details/7307436#" title="?" target="_blank">?</a></p>
<ol>
<li>List students = session.createQuery(&quot;from Student s where s.classes.name like &#39;%t%&#39;&quot;)  </li>
<li></li>
<li>.list();  </li>
</ol>
<p>相当于：s.getClasses.getName()，直接使用get后面的属性，然后首字母小写。</p>
<p> 这种语法，是不是很熟悉？想想我们在哪是不是也用过？想起来了吗？估计你猜出来啦，呵呵，是JSTL（jsp standard tag library）中。若是想进一步了解，可以参考我的博客哈，当时是转载滴貌似。</p>
<p>9.连接查询。</p>
<pre><code>连接分为：内连接和外连接，其中外连接分为左连接，右连接，完全连接。这个跟数据库中的左右连接其实是一样的。我们通俗解释一下：

左连接：以左边为准，右边即使没哟匹配的，也要把这条记录查询出来，此时没有匹配的右边以null填充。

右连接：以右边为准，左边即使没有匹配的，也要把这条记录查询出来，此时没有匹配的左边以null填充。
</code></pre><p>   完全连接：只要一方存在即可。</p>
<p>   内连接：必须两方都存在才可以查询提取此记录。</p>
<p>10.统计查询。</p>
<pre><code> 其实就是查询count的记录数。其中查询出来的额count是long类型。
</code></pre><p>11.DML风格的操作。</p>
<pre><code> DML？其实DML=Data Manipulate Language（数据操作语言），举个例子：
</code></pre><p><strong>[java]</strong> <a href="http://blog.csdn.net/llhhyy1989/article/details/7307436#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/llhhyy1989/article/details/7307436#" title="copy" target="_blank">copy</a><a href="http://blog.csdn.net/llhhyy1989/article/details/7307436#" title="print" target="_blank">print</a><a href="http://blog.csdn.net/llhhyy1989/article/details/7307436#" title="?" target="_blank">?</a></p>
<ol>
<li>session.createQuery(&quot;update Student s set s.name=? where s.id&lt;?&quot;)  </li>
<li></li>
<li>.setParameter(0, &quot;王斌&quot;)  </li>
<li></li>
<li>.setParameter(1, 2)  </li>
<li></li>
<li>.executeUpdate();   </li>
</ol>
<p>假若原来的名字是：李四，更新完数据库后变成王斌，若是我们此时取出数据，其姓名是李四还是王斌？按照道理应该是王斌，但是结果确实李四，若不信，可以自己去实践一下。</p>
<p>这个原因，是因为更新了数据库，但是缓存中没有更新，才会造成这种数据库和缓存不同步的问题。</p>
<p>所以，我们应该尽量不使用这种形式。扬其长避其短嘛。
来源： <a href="[http://blog.csdn.net/llhhyy1989/article/details/7307436](http://blog.csdn.net/llhhyy1989/article/details/7307436)">[http://blog.csdn.net/llhhyy1989/article/details/7307436](http://blog.csdn.net/llhhyy1989/article/details/7307436)</a> </p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/框架汇总/">框架汇总</a></li></span><span class="breadcrumb"><li><a href="/categories/框架汇总/">框架汇总</a></li><li><a href="/categories/框架汇总/ORM/">ORM</a></li><li><a href="/categories/框架汇总/ORM/hibernate/">hibernate</a></li></span></span> | <span class="tags">Tagged <a href="/tags/ORM/" class="label label-primary">ORM</a><a href="/tags/hibernate/" class="label label-success">hibernate</a><a href="/tags/框架汇总/" class="label label-info">框架汇总</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:29"datetime="2014-03-07 09:54:29"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-框架汇总-ORM-hibernate--Hibernate总结/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-框架汇总-ORM-hibernate--Hibernate总结" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-框架汇总-ORM-hibernate--Hibernate知识总结/">Hibernate知识总结</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:29.000Z"> <a href="/2014/02/02/2014-02-02-框架汇总-ORM-hibernate--Hibernate知识总结/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="hibernate-">Hibernate知识总结</h1>
<p><a href=""></a></p>
<h1 id="-li-boy-http-libooy-diandian-com-"><a href="http://libooy.diandian.com/" target="_blank">Li-boy 奋斗的蜗牛</a></h1>
<ul>
<li><a href="http://libooy.diandian.com/submit" target="_blank">投稿</a></li>
<li><a href="http://libooy.diandian.com/inbox" target="_blank">私信</a></li>
<li><a href="http://libooy.diandian.com/archive" target="_blank">存档</a></li>
<li><a href="http://libooy.diandian.com/random" target="_blank">随机文章</a></li>
<li><a href="">关于</a>
<img src="" alt="Li-boy 奋斗的蜗牛"></li>
</ul>
<h3 id="-">关于我</h3>
<p>一天进步一点点！！！</p>
<p>26 Mar</p>
<h1 id="hibernate-">Hibernate知识总结</h1>
<p><img src="" alt=""></p>
<hr>
<p><strong>1.Hibernate持久化对象的生命周期 (状态)  </strong></p>
<p>(1) 瞬态（自由态） (2) 持久态 (3) 托管（游离态）</p>
<p><strong>1.1自由态</strong></p>
<p>   持久化对象的自由态，指的是对象在内存中存在，但是在数据库中并</p>
<p>没有数据与其关联。比如Student student = new Student()，这里</p>
<p>的student对象就是一个自由态的持久化对象。</p>
<p><strong>1.2持久态</strong></p>
<p>   持久态指的是持久化对象处于由Hibernate管理的状态，这种状态下</p>
<p>持久化对象的变化将会被同步到数据库中。</p>
<p>session.beginTransaction();</p>
<p>User user = new User();</p>
<p>user.setUserName(&quot;James&quot;);</p>
<p>user.setUserPwd(&quot;123&quot;);</p>
<p>session.save(user);</p>
<p>session.getTransaction().commit();</p>
<p><strong>1.3游离态</strong></p>
<p>处于持久态的对象，在其对应的Session实例关闭后，此时对象迚入</p>
<p>游离态。也就是说Session实例是持久态对象的宿主环境，一旦宿主</p>
<p>环境失效，那么持久态对象迚入游离状态。</p>
<p>session.beginTransaction();</p>
<p>User user = new User();</p>
<p>user.setUserName(&quot;James&quot;);</p>
<p>user.setUserPwd(&quot;123&quot;);</p>
<p>Integer id = (Integer) session.save(user);</p>
<p>user.setUserPwd(&quot;456&quot;);</p>
<p>session.getTransaction().commit();</p>
<p>user.setUserPwd(&quot;789&quot;);</p>
<p><strong>游离态和自由态的区别</strong></p>
<p>区别就在于游离态对象可以再次与Session迚行关联而成为持久态对</p>
<p>象。</p>
<p>session.beginTransaction();</p>
<p>User user = new User();</p>
<p>user.setUserName(&quot;James&quot;);</p>
<p>user.setUserPwd(&quot;123&quot;);</p>
<p>Integer id = (Integer) session.save(user);</p>
<p>user.setUserPwd(&quot;456&quot;);</p>
<p>session.getTransaction().commit();</p>
<p>Session session2 = HibernateUtil.getSessionFactory().getCurrentS</p>
<p>session2.beginTransaction();</p>
<p>user.setUserPwd(&quot;789&quot;);</p>
<p>session2.update(user);</p>
<p>session2.getTransaction().commit();</p>
<p>自由态对象在数据库中没有数据与其对应，但是游离态对象在数据库</p>
<p>中有数据与其对应，只不过当前对象不在Session环境中而已。从对</p>
<p>象的是否有主键值可以做简单的判断。</p>
<p>session.beginTransaction();</p>
<p>User user = new User();</p>
<p>user.setUserName(&quot;James&quot;);</p>
<p>user.setUserPwd(&quot;123&quot;);</p>
<p>System.out.println(user.getId());</p>
<p>Integer id = (Integer) session.save(user);</p>
<p>session.getTransaction().commit();</p>
<p>System.out.println(user.getId());</p>
<p>如果我自己创建一个对象，并且给主键属性赋值，该值还在数据库中</p>
<p>存在，当前对象的状态不也是游离态了？</p>
<p>/* 在Hibernate中根据主键判断对象是自由态还是游离态只是判断的</p>
<p>一个参考点，在Hibernate中还有更复杂的机制来判断一个对象的</p>
<p>状态，比如对象的version等等。</p>
<p>回到自由态</p>
<p>session.beginTransaction();</p>
<p>User user = (User) session.load(User.class, 120);</p>
<p>session.delete(user);</p>
<p>session.getTransaction().commit();</p>
<p>三种状态的转换 :</p>
<p><img src="" alt=""></p>
<p><strong>load和get方法</strong></p>
<p>相同点：</p>
<p>   get和load方法都是利用对象的主键值获取相应的对象，并可以使对</p>
<p>象处于持久状态。</p>
<p>不同点：</p>
<p>   load方法获取对象时不会立即执行查询操作，而是在第一次使用对象</p>
<p>是再去执行查询操作。如果查询的对象在数据库中不存在，load方法</p>
<p>返回值不会为null，在第一次使用时抛出</p>
<p>org.hibernate.ObjectNotFoundException异常。</p>
<p>   使用get方法获取对象时会立即执行查询操作，并且对象在数据库中</p>
<p>不存在时返回null值。</p>
<p><strong>save和persist方法</strong></p>
<p>相同点：</p>
<p>save和persist方法都是将持久化对象保存到数据库中</p>
<p>区别：</p>
<p>sava方法成功执行后，返回持久化对象的ID</p>
<p>persist方法成功执行后，不会返回持久化对象的ID，persist方法是</p>
<p>JPA中推荐使用的方法  </p>
<p><strong>save和update方法</strong></p>
<p>save方法是将自由态的对象迚行保存。</p>
<p>update方法是将游离态的对象迚行保存。</p>
<p>update和saveOrUpdate方法</p>
<p>   如果一个对象是游离态戒持久态，对其执行update方法后会将对象</p>
<p>的修改同步到数据库中，如果该对象是自由态，则执行update方法</p>
<p>是没有作用的。</p>
<p>   在执行saveOrUpdate方法时该方法会自动判断对象的状态，如果为</p>
<p>自由态则执行save操作，如果为游离态戒持久态则执行update操作。</p>
<p><strong>update和merge方法</strong></p>
<p>   如果持久化对象在数据库中存在，使用merge操作时迚行同步操作。</p>
<p>如果对象在数据库不存在，merge对象则迚行保存操作。</p>
<p>   如果对象是游离状态，经过update操作后，对象转换为持久态。但</p>
<p>是经过merge操作后，对象状态依然是游离态。</p>
<p><strong>saveOrUpdate和merge方法</strong></p>
<p>saveOrUpdate方法和merge方法的区别在于如果session中存在两</p>
<p>个主键值相同的对象，迚行saveOrUpdate操作时会有异常抛出。这</p>
<p>时必须使用merge迚行操作。</p>
<p>session.beginTransaction();</p>
<p>User user = new User();</p>
<p>user.setId(3);</p>
<p>user.setUserName(&quot;aaaaaaaa&quot;);</p>
<p>user.setUserPwd(&quot;123123&quot;);</p>
<p>User user2 = (User) session.get(User.class, 3);</p>
<p>session.saveOrUpdate(user);//ERROR</p>
<p>session.getTransaction().commit();</p>
<p>clear方法和flush方法</p>
<p>clear方法是将Session中对象全部清除，当前在Session中的对象由</p>
<p>持久态转换为游离态。flush方法则是将持久态对象的更改同步到数据</p>
<p>库中。</p>
<p>session.beginTransaction();</p>
<p>User user = (User) session.get(User.class, 3);</p>
<p>user.setPassword(&quot;111&quot;);</p>
<p>session.flush();  </p>
<p>session.getTransaction().commit();</p>
<p><strong>2.Hibernate查询</strong></p>
<p><strong>2.1 HQL</strong></p>
<p>   HQL（Hibernate Query Language）提供了丰富灵活的查询方式，</p>
<p>使用HQL进行查询也是Hibernate官方推荐使用的查询方式。</p>
<p>   HQL在语法结构上和SQL语句十分的相同，所以可以很快的上手进行</p>
<p>使用。使用HQL需要用到Hibernate中的Query对象，该对象丏门执</p>
<p>行HQL方式的操作。</p>
<p><strong>1.查询所有</strong></p>
<p>session.beginTransaction();</p>
<p>String hql = &quot;from User&quot;;</p>
<p>Query query = session.createQuery(hql);</p>
<p>List<User> userList = query.list();</p>
<p>for(User user:userList){</p>
<p> System.out.println(user.getUserName());</p>
<p>}</p>
<p>session.getTransaction().commit();</p>
<p><strong>2.where</strong></p>
<p>session.beginTransaction();</p>
<p>String hql = &quot;from User where userName = &#39;James&#39;&quot;;</p>
<p>Query query = session.createQuery(hql);</p>
<p>List<User> userList = query.list();</p>
<p>for(User user:userList){</p>
<p> System.out.println(user.getUserName());</p>
<p>}</p>
<p>session.getTransaction().commit();</p>
<p>在HQL中where语句中使用的是持久化对象的属性名，比如上面示例</p>
<p>中的userName。当然在HQL中也可以使用别名：</p>
<p>String hql = &quot;from User as u where u.userName = &#39;James&#39;&quot;;</p>
<p><strong>3.过滤条件</strong></p>
<p>在where语句中还可以使用各种过滤条件，如：=、&lt;&gt;、&lt;、&gt;、&gt;=</p>
<p>、&lt;=、between、not between、in、not in、is、like、and、or</p>
<p>等。</p>
<p>– from Student where age &gt; 20;</p>
<p>– from Student where age between 20 and 30;</p>
<p>– from Student where name is null;</p>
<p>– from Student where name like ‘小%’;</p>
<p>– from Student where name like ‘小%’ and age &lt; 30</p>
<p><strong>4.获取一个不完整对象</strong></p>
<p><strong>一列：</strong></p>
<p>session.beginTransaction();</p>
<p>String hql = &quot;select userName from User&quot;</p>
<p>Query query = session.createQuery(hql);</p>
<p>List nameList = query.list();</p>
<p>for(Object obj:nameList){</p>
<p> System.out.println(obj);</p>
<p>}</p>
<p>session.getTransaction().commit();</p>
<p><strong>5.两列或多列：</strong></p>
<p>session.beginTransaction();</p>
<p>String hql = &quot;select userName,userPwd from User&quot;;</p>
<p>Query query = session.createQuery(hql);</p>
<p>List nameList = query.list();</p>
<p>for(Object obj:nameList){</p>
<p>Object[] array = (Object[]) obj;</p>
<p>System.out.println(&quot;name:&quot; + array[0]);</p>
<p>System.out.println(&quot;pwd:&quot; + array[1]);</p>
<p>}</p>
<p>session.getTransaction().commit();</p>
<p><strong>6.统计和分组查询</strong></p>
<p>session.beginTransaction();</p>
<p>String hql = &quot;select count(/*),max(id) from User&quot;;</p>
<p>Query query = session.createQuery(hql);</p>
<p>List nameList = query.list();</p>
<p>for(Object obj:nameList){</p>
<p>Object[] array = (Object[]) obj;</p>
<p>System.out.println(&quot;count:&quot; + array[0]);</p>
<p>System.out.println(&quot;max:&quot; + array[1]);</p>
<p>}</p>
<p>session.getTransaction().commit();</p>
<p><strong>7.更多写法…</strong></p>
<p>消除重复： select distinct name from Student;</p>
<p>最大： select max(age) from Student;</p>
<p>行数： select count(age),age from Student group by age;</p>
<p>排序： from Student order by age;</p>
<p><strong>HQL占位符</strong></p>
<p>session.beginTransaction();</p>
<p>String hql = &quot;from User where userName = ?&quot;;</p>
<p>Query query = session.createQuery(hql);</p>
<p>query.setString(0, &quot;James&quot;);</p>
<p>List<User> userList = query.list();</p>
<p>for(User user:userList){</p>
<p> System.out.println(user.getUserName());</p>
<p>}</p>
<p>session.getTransaction().commit();</p>
<p><strong>HQL引用占位符</strong></p>
<p>session.beginTransaction();</p>
<p>String hql = &quot;from User where userName = :name&quot;;</p>
<p>Query query = session.createQuery(hql);</p>
<p>query.setParameter(&quot;name&quot;, &quot;James&quot;);</p>
<p>List<User> userList = query.list();</p>
<p>for(User user:userList){</p>
<p> System.out.println(user.getUserName());</p>
<p>}</p>
<p>session.getTransaction().commit();</p>
<p><strong>HQL分页</strong></p>
<p>session.beginTransaction();</p>
<p>String hql = &quot;from User&quot;;</p>
<p>Query query = session.createQuery(hql);</p>
<p><strong>query.setFirstResult(0);</strong></p>
<p><strong>query.setMaxResults(2);</strong></p>
<p>List<User> userList = query.list();</p>
<p>for(User user:userList){</p>
<p> System.out.println(user.getUserName());</p>
<p>}</p>
<p>session.getTransaction().commit();</p>
<p><strong>3.Criteria查询</strong></p>
<p>   Criteria对象提供了一种面向对象的方式查询数据库。Criteria对象需</p>
<p>要使用Session对象来获得。</p>
<p>一个Criteria对象表示对一个持久化类的查询。</p>
<p><strong>1.查询所有</strong></p>
<p>session.beginTransaction();</p>
<p>Criteria c = session.createCriteria(User.class);</p>
<p>List<User> userList = c.list();</p>
<p>for(User user:userList){</p>
<p> System.out.println(user.getUserName());</p>
<p>}</p>
<p>session.getTransaction().commit();</p>
<p><strong>2.Where</strong></p>
<p>session.beginTransaction();</p>
<p>Criteria c = session.createCriteria(User.class);</p>
<p>c.add(Restrictions.eq(&quot;userName&quot;, &quot;James&quot;));</p>
<p>List<User> userList = c.list();</p>
<p>for(User user:userList){</p>
<p> System.out.println(user.getUserName());</p>
<p>}</p>
<p>session.getTransaction().commit();</p>
<p><strong>3.Restrictions对象</strong></p>
<p><img src="" alt=""></p>
<p><strong>where...and .... 语句</strong></p>
<p>session.beginTransaction();</p>
<p><strong>Criteria c = session.createCriteria(User.class)</strong></p>
<p><strong>c.add(Restrictions.like(&quot;userName&quot;, &quot;J&quot;));</strong></p>
<p><strong>c.add(Restrictions.eq(&quot;id&quot;, 120));</strong></p>
<p>List<User> userList = c.list();</p>
<p>for(User user:userList){</p>
<p> System.out.println(user.getUserName());</p>
<p>}</p>
<p>session.getTransaction().commit();</p>
<p><strong>where...or .... 语句</strong></p>
<p>session.beginTransaction();</p>
<p>Criteria c = session.createCriteria(User.class);</p>
<p><strong>c.add(Restrictions.or(Restrictions.eq(&quot;userName&quot;, &quot;James&quot;),</strong></p>
<p><strong> Restrictions.eq(&quot;userName&quot;, &quot;Alex&quot;)));</strong></p>
<p>List<User> userList = c.list();</p>
<p>for(User user:userList){</p>
<p>System.out.println(user.getUserName());</p>
<p>}</p>
<p>session.getTransaction().commit();</p>
<p><strong>获取唯一的记录</strong></p>
<p>session.beginTransaction();</p>
<p>Criteria c = session.createCriteria(User.class);</p>
<p>c.add(Restrictions.eq(&quot;id&quot;, 120));</p>
<p>User user = (User) c.uniqueResult();</p>
<p>System.out.println(user.getUserName());</p>
<p>session.getTransaction().commit();</p>
<p><strong>分页</strong></p>
<p>session.beginTransaction();</p>
<p>Criteria c = session.createCriteria(User.class);</p>
<p>c.setFirstResult(0);</p>
<p>c.setMaxResults(5);</p>
<p>List<User> userList = c.list();</p>
<p>for(User user:userList){</p>
<p> System.out.println(user.getUserName());</p>
<p>}</p>
<p>session.getTransaction().commit();</p>
<p><strong>分组与统计</strong></p>
<p>session.beginTransaction();</p>
<p>Criteria c = session.createCriteria(User.class);</p>
<p>c.setProjection(Projections.sum(&quot;id&quot;));</p>
<p>Object obj = c.uniqueResult();</p>
<p>System.out.println(obj);</p>
<p>session.getTransaction().commit();</p>
<p>Projections对象</p>
<p><img src="" alt=""></p>
<p><strong>多个统计与分组</strong></p>
<p>session.beginTransaction();</p>
<p>Criteria c = session.createCriteria(User.class);</p>
<p><strong>ProjectionList projectionList = Projections.projectionList();</strong></p>
<p><strong>projectionList.add(Projections.sum(&quot;id&quot;));</strong></p>
<p><strong>projectionList.add(Projections.min(&quot;id&quot;));</strong></p>
<p><strong>c.setProjection(projectionList);</strong></p>
<p>Object[] obj = (Object[]) c.uniqueResult();</p>
<p>System.out.println(&quot;sum:&quot; + obj[0]);</p>
<p>System.out.println(&quot;min:&quot; + obj[1]);</p>
<p>session.getTransaction().commit();</p>
<p><strong>排序</strong></p>
<p>session.beginTransaction();</p>
<p>Criteria c = session.createCriteria(User.class);</p>
<p><strong>c.addOrder(Order.desc(&quot;id&quot;));</strong></p>
<p>List<User> list = c.list();</p>
<p>for(User user : list){</p>
<p> System.out.println(user.getUserName());</p>
<p>}</p>
<p>session.getTransaction().commit();</p>
<p><strong>4.使用原生SQL查询</strong></p>
<p><strong>1.查询出后必须封装才可以用：</strong></p>
<p>session.beginTransaction();</p>
<p>String sql = &quot;select id,username,userpwd from t_user&quot;;</p>
<p>List list = session.createSQLQuery(sql).list();</p>
<p>for(Object item : list){</p>
<p>Object[] rows = (Object[]) item;</p>
<p>System.out.println(&quot;id:&quot; + rows[0] + &quot;username:&quot;  </p>
<ul>
<li>rows[1] + &quot;userpwd:&quot; + rows[2]);</li>
</ul>
<p>}</p>
<p>session.getTransaction().commit();</p>
<p><strong>2.查询出一个集合可以直接用对象操作：</strong></p>
<p>session.beginTransaction();</p>
<p>String sql = &quot;select id,username,userpwd from t_user&quot;;</p>
<p>SQLQuery query = session.createSQLQuery(sql).addEntity(User.class);</p>
<p>List<User> list = query.list();</p>
<p>for(User user : list){</p>
<p> System.out.println(user.getUserName());</p>
<p>}</p>
<p>session.getTransaction().commit();</p>
<p><strong>3.查询出一个对象可以直接用对象操作</strong>：</p>
<p>session.beginTransaction();</p>
<p>String sql = &quot;select id,username,userpwd from t_user where id = 2&quot;;</p>
<p>SQLQuery query = session.createSQLQuery(sql).addEntity(User.class);</p>
<p>User user = (User) query.uniqueResult();</p>
<p>System.out.println(user.getUserName());</p>
<p>session.getTransaction().commit();</p>
<p><a href="http://libooy.diandian.com/?tag=hibernate" title="hibernate" target="_blank">hibernate</a>
<a href="">喜欢</a> <a href="">热度 (4)</a></p>
<p><a href="">分享</a></p>
<p><a href=""></a>
<a href="http://libooy.diandian.com/" target="_blank">返回首页</a></p>
<p><a href=""></a>
<a href="http://libooy.diandian.com/post/2012-03-28/14606048" target="_blank">上一篇</a></p>
<p><a href="http://libooy.diandian.com/post/2012-03-26/18813130" target="_blank">下一篇</a></p>
<h3 id="-"><a href="&quot;关于&quot;">关于</a></h3>
<p>一天进步一点点！！！</p>
<h3 id="-">导航</h3>
<ul>
<li><a href="http://libooy.diandian.com/rss" target="_blank">RSS订阅</a></li>
<li><a href="http://libooy.diandian.com/random" target="_blank">随机文章</a></li>
<li><a href="http://libooy.diandian.com/archive" target="_blank">存档</a></li>
<li><a href="http://libooy.diandian.com/inbox" title="私信" target="_blank">私信</a></li>
<li><p><a href="http://libooy.diandian.com/submit" title="投稿" target="_blank">投稿</a></p>
<h3 id="-">页面</h3>
</li>
<li><p><a href="http://libooy.diandian.com/" target="_blank">首页</a></p>
</li>
<li><p>© <a href="http://libooy.diandian.com/" title="Li-boy 奋斗的蜗牛" target="_blank">Li-boy 奋斗的蜗牛</a></p>
</li>
<li>Powered by <a href="http://www.diandian.com/" title="点点网" target="_blank">点点</a></li>
<li>Themed by <a href="http://www.yiyifly.com/" title="舟遥遥以轻飏,风飘飘而吹衣" target="_blank">吹衣轻飏</a></li>
</ul>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/框架汇总/">框架汇总</a></li></span><span class="breadcrumb"><li><a href="/categories/框架汇总/">框架汇总</a></li><li><a href="/categories/框架汇总/ORM/">ORM</a></li><li><a href="/categories/框架汇总/ORM/hibernate/">hibernate</a></li></span></span> | <span class="tags">Tagged <a href="/tags/ORM/" class="label label-primary">ORM</a><a href="/tags/hibernate/" class="label label-success">hibernate</a><a href="/tags/框架汇总/" class="label label-info">框架汇总</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:29"datetime="2014-03-07 09:54:29"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-框架汇总-ORM-hibernate--Hibernate知识总结/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-框架汇总-ORM-hibernate--Hibernate知识总结" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>





<ul id="pagination" class="pagination pagination-lg">
  <li><a class="extend prev" href="/page/144/">&laquo;</a></li><li><a class="page-number" href="/">1</a></li><li><a class="page-number" href="/page/2/">2</a></li><li><span class="space">&hellip;</span></li><li><a class="page-number" href="/page/142/">142</a></li><li><a class="page-number" href="/page/143/">143</a></li><li><a class="page-number" href="/page/144/">144</a></li><li class="active"><li><span class="page-number current">145</span></li><li><a class="page-number" href="/page/146/">146</a></li><li><a class="page-number" href="/page/147/">147</a></li><li><a class="page-number" href="/page/148/">148</a></li><li><span class="space">&hellip;</span></li></li><li><a class="page-number" href="/page/163/">163</a></li><li><a class="page-number" href="/page/164/">164</a></li><li><a class="extend next" href="/page/146/">&raquo;</a></li>
  <div class="clearfix"></div>
</ul></div><!--wapper-->
       </div><!-- ID main-col END -->
       <aside id="sidebar" class="alignright col-sx-6 col-sm-4 col-md-3 col-lg-3">
<div id="widget_search" class="widget panel panel-primary">
    <form action="//google.com/search" method="get" accept-charset="utf-8">
  <div class="input-group">
    <input class="form-control" id="searchbox" type="search" name="q" results="0" placeholder="search">
    <span class="input-group-btn">
      <button class="btn btn-default" type="submit">Go!</button>
    </span>
    <input type="hidden" name="q" value="site:itsolife.com">
  </div>
</form>
</div>

<div id="widget_category" class="widget panel panel-primary">
  <div class="panel-heading">category</div>  <div data-src='category' class='ajax_widgets'>正在加载...</div>
</div>

<div id="widget_recent_posts" class="widget panel panel-primary">
  <div class="panel-heading">recent posts</div>  <div data-src='recent_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_tagcloud" class="widget panel panel-primary">
  <div class="panel-heading">tagcloud</div>  <div data-src='tagcloud' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_latest_update_posts" class="widget panel panel-primary">
  <div class="panel-heading">最近更新</div>  <div data-src='latest_update_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_recent_comments" class="widget panel panel-primary">
  <div class="panel-heading">recent comments</div>  

<div class="list-group-item ds-recent-comments" data-num-items="6" data-show-avatars="1" data-show-time="1" data-show-title="1" data-show-admin="1" data-excerpt-length="50"></div>



</div>

</aside>
       <div class="clearfix"></div>
     </div><!-- row END -->
  </div>
  <footer id="footer" class="container">
  <div class="panel panel-info">
  <section id='footer_widget'></section>  <div class="panel-footer">
  <div id="site-info">
    <span class='author'>
  
  &copy; 2014 RobinChia
  
    &nbsp;&nbsp;</span>
  
  <span id='analytics-51la'></span><span id='analytics-google'>
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-48559895-1']);
  _gaq.push(['_trackPageview']);
  _js2load.push({src:('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'});
</script></span><span id='analytics-cnzz'>
<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_5774006'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s17.cnzz.com/stat.php%3Fid%3D5774006%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>
</span><span id='analytics-baidu'>
<script>
var _hmt = _hmt || [];
_js2load.push({src:"//hm.baidu.com/hm.js?1442f50724afc42380b51f097c43082c"});
</script>
</span>  </div>
  <div id="copyright">Site powered by <a href='http://zespia.tw/hexo/'><strong>hexo</strong></a>  update time: <em>2014-03-29 22:06:56</em></span></div>
</div>
<div class="clearfix"></div>


  </div>
  </footer>
  
        <script src="http://cdn.bootcss.com/jquery/1.10.2/jquery.min.js"></script>        
        <script src="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/js/bootstrap.min.js"></script>        
                
        <script src="http://cdn.bootcss.com/prettify/r298/prettify.min.js"></script>    <script type="text/javascript">
   var lang=["bsh", "c", "cc", "cpp", "cs", "csh", "cyc", "cv", "htm", "html",
    "java", "js", "m", "mxml", "perl", "pl", "pm", "py", "rb", "sh",
    "xhtml", "xml", "xsl"];
   var pretty_base='';
   $('script').each(function(){
	var c = $(this).attr('src');
	if (!c)
	    return;
	if (c.match(/(\/)?prettify(\.min)?\.js/i))
	{
	    var index = c.lastIndexOf('/');
	    if (index != -1)
		pretty_base = c.substr(0,index + 1);
	    return false;
	}
   })
   $('pre code').each(function(){
	var c = $(this).attr('class')
	if (!c)
	    return;
	c = c.match(/\s?(lang\-\w+)/i);
	if (c && lang.indexOf(c[1]) == -1)
	{
	    lang.push(c[1]);
	    $.getScript(pretty_base + c[1] + '.min.js');
	}
   })

    $(window).load(function(){
       $("pre").addClass("prettyprint");
       prettyPrint();
    })
</script>    
            <script type="text/javascript">
var duoshuoQuery = {short_name:"robinchia"};
_js2load.push({src:'http://static.duoshuo.com/embed.js',charset:'UTF-8'});
</script>
    
            <!--wumii_relatedItems-->
    
        <script src="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js"></script>    <script type="text/javascript">
(function($){
  $('.entry').each(function(i){
    $(this).find('img').each(function(){
      var alt = this.alt;

      if (alt){
        $(this).before('<span class="caption">' + alt + '</span>');
      }

      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox" rel="fancybox' + i + '" />');
    });
  });

  $('.fancybox').fancybox();
})(jQuery);
</script>    
        <script src="http://cdn.bootcss.com/mathjax/2.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>    <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>
    
<script type="text/javascript">
$('.ajax_widgets').each(function(){var src=$(this).attr('data-src');if(src)$(this).load('/widgets/'+src+'.html');});
$.each(_js2load,function(index,obj){loadjs(obj.src,obj.charset)});
</script>

<div id="scroll2top">
<img src="/scroll2top/arrow.png"/>
</div>
<script src="/scroll2top/scroll2top.min.js"></script>
<div id="winterland">
  <canvas></canvas>
</div>
<script src="/js/winterland.min.js"></script>

  </body>
</html>
