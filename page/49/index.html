
<!DOCTYPE HTML>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>The 49 Page | It so life</title>
<meta name="author" content="RobinChia">

<meta name="description" content="It so life">


<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<meta property="og:site_name" content="It so life"/>

<!--[if IE]><style>.testIE.IE{display:inline;}</style><![endif]-->
<!--[if lte IE 7]><link rel="stylesheet" href="/css/ie7.css" type="text/css"><![endif]-->
<!--[if (lt IE 9)&(gt IE 7)]><style>.testIE.IE8{display:inline;}</style><![endif]-->
<!--[if gt IE 8]><style>.testIE.IE9{display:inline;}</style><![endif]-->

<link href="/favicon.png" rel="icon">
<link rel="alternate" href="/atom.xml" title="It so life Feed" type="application/atom+xml">

<link rel="stylesheet" href="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/css/bootstrap.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/font-awesome/4.0.3/css/font-awesome.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/prettify/r298/prettify.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" type="text/css">
<link rel="stylesheet" href="/css/style.css" type="text/css">
<!--[if lt IE 9]>
   <style>article,aside,dialog,footer,header,section,footer,nav,figure,menu{display:block}</style>
   <script src="http://cdn.staticfile.org/html5shiv/r29/html5.min.js"></script>
   <script src="http://cdn.staticfile.org/respond.js/1.4.2/respond.min.js"></script>
<link href="http://cdn.staticfile.org/respond.js/1.4.2/respond-proxy.html" id="respond-proxy" rel="respond-proxy" />
<link href="/js/respond.proxy.gif" id="respond-redirect" rel="respond-redirect" />
<script src="/js/respond.proxy.js"></script>
   <script src="http://cdn.bootcss.com/selectivizr/1.0.2/selectivizr-min.js"></script>
<![endif]-->
<script type="text/javascript">
function loadjs(c,d){var a=document.createElement("script");a.async=!0;a.type="text/javascript";a.src=c;a.charset=d||"gbk";(document.getElementsByTagName("HEAD")[0]||document.getElementsByTagName("BODY")[0]).appendChild(a)};
var _protocol = (("https:" == document.location.protocol) ? " https://" : " http://");
var _js2load = [];
</script>

</head>
<body>
      <header id="header" class="container"><nav id="main-nav" class="navbar navbar-default navbar-fixed-top " role="navigation">
  <div class="container">
    <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
      <span class="sr-only">Toggle navigation</span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="/">It so life</a>
    </div>
    <div  class="collapse navbar-collapse">
      <ul  class="nav navbar-nav">
  
        <li><a href="/" title="Home">Home</a></li>      
        <li><a href="/about/" title="About">About</a></li>      
        <li><a href="/archives/" title="Archives">Archives</a></li>      
      <li class='dropdown'>
        <a class='dropdown-toggle' data-toggle='dropdown' href='#'>website<b class='caret'></b></a>
        <ul class='dropdown-menu pure-menu-selected'>
    
          <li><a href="//groups.google.com/forum/#!forum/pongba" title="TopLanguage">TopLanguage</a></li>    
          <li><a href="//itpub.net/" title="ITPub">ITPub</a></li>    
          <li><a href="//blog.jobbole.com/" title="Bole">Bole</a></li>    
          <li><a href="//nosql-database.org/" title="nosql">nosql</a></li>    
          <li><a href="//gitimmersion.googol.im/" title="Git">Git</a></li>    
        </ul>
      </li>
    
      </ul>
      <ul class="nav navbar-nav navbar-right">
      
        <li><a href="/atom.xml">RSS</a></li>
      
      
        <li><a href="https://twitter.com/robinchia">twitter</a></li>
      
      
      
      
        <li><a href="https://github.com/robinchia">github</a></li>
      
      </ul>
    </div>
  </div>
</nav>
<div class="clearfix"></div>
</header>
  <div id='content' class="container">
     <div class="page-header-wrapper">
      <!--[if lt IE 9]><div class="alert alert-warning alert-dismissable"><button type="button" class="close" data-dismiss="alert" aria-hidden="true">&times;</button><strong>提示:</strong>您的浏览器版本太低了,建议升级到 <strong><a href="http://windows.microsoft.com/zh-cn/internet-explorer/download-ie" title="IE9">IE9</a></strong> 以上,本站使用<a href="https://www.google.com/intl/zh-CN/chrome/">Chrome浏览器</a>可以获得最好的显示效果.</div><![endif]-->
      <div class="page-header"><h1 align="center"><big>It so life</big> </h1>
        <h5 align="center"><big>love as life</big></h5>
      </div>
     </div>
     <div class="row">
       <div id="main-col" class="alignleft col-sx-12 col-sm-8 col-md-9 col-lg-9">
      <section id='header_widget'></section>
          <div id="wrapper"><article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--JVM调优总结（四）-垃圾回收面临的问题/">JVM调优总结（四）</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:42.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--JVM调优总结（四）-垃圾回收面临的问题/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="jvm-">JVM调优总结（四）-垃圾回收面临的问题</h1>
<p>如何区分垃圾</p>
<pre><code>上面说到的“引用计数”法，通过统计控制生成对象和删除对象时的引用数来判断。垃圾回收程序收集计数为0的对象即可。但是这种方法无法解决循环引用。所以，后来实现的垃圾判断算法中，都是从程序运行的根节点出发，遍历整个对象引用，查找存活的对象。那么在这种方式的实现中，**垃圾回收从哪儿开始的呢**？即，从哪儿开始查找哪些对象是正在被当前系统使用的。上面分析的堆和栈的区别，其中栈是真正进行程序执行地方，所以要获取哪些对象正在被使用，则需要从Java栈开始。同时，一个栈是与一个线程对应的，因此，如果有多个线程的话，则必须对这些线程对应的所有的栈进行检查。
</code></pre><p><img src="" alt=""></p>
<pre><code>同时，除了栈外，还有系统运行时的寄存器等，也是存储程序运行数据的。这样，以栈或寄存器中的引用为起点，我们可以找到堆中的对象，又从这些对象找到对堆中其他对象的引用，这种引用逐步扩展，最终以null引用或者基本类型结束，这样就形成了一颗以Java栈中引用所对应的对象为根节点的一颗对象树，如果栈中有多个引用，则最终会形成多颗对象树。在这些对象树上的对象，都是当前系统运行所需要的对象，不能被垃圾回收。而其他剩余对象，则可以视为无法被引用到的对象，可以被当做垃圾进行回收。
</code></pre><p>因此，<strong>垃圾回收的起点是一些根对象（java栈, 静态变量, 寄存器...）</strong>。而最简单的Java栈就是Java程序执行的main函数。这种回收方式，也是上面提到的“标记-清除”的回收方式</p>
<h2 id="-">如何处理碎片</h2>
<p>   由于不同Java对象存活时间是不一定的，因此，在程序运行一段时间以后，如果不进行内存整理，就会出现零散的内存碎片。碎片最直接的问题就是会导致无法分配大块的内存空间，以及程序运行效率降低。所以，在上面提到的基本垃圾回收算法中，“复制”方式和“标记-整理”方式，都可以解决碎片的问题。</p>
<h2 id="-">如何解决同时存在的对象创建和对象回收问题</h2>
<pre><code>垃圾回收线程是回收内存的，而程序运行线程则是消耗（或分配）内存的，**一个回收内存，一个分配内存**，从这点看，两者是矛盾的。因此，在现有的垃圾回收方式中，要进行垃圾回收前，一般都需要暂停整个应用（即：暂停内存的分配），然后进行垃圾回收，回收完成后再继续应用。这种实现方式是最直接，而且最有效的解决二者矛盾的方式。
</code></pre><p>但是<strong>这种方式有一个很明显的弊端，就是当堆空间持续增大时，垃圾回收的时间也将会相应的持续增大，对应应用暂停的时间也会相应的增大</strong>。一些对相应时间要求很高的应用，比如最大暂停时间要求是几百毫秒，那么当堆空间大于几个G时，就很有可能超过这个限制，在这种情况下，垃圾回收将会成为系统运行的一个瓶颈。为解决这种矛盾，有了<strong>并发垃圾回收算法</strong>，使用这种算法，垃圾回收线程与程序运行线程同时运行。在这种方式下，解决了暂停的问题，但是因为需要在新生成对象的同时又要回收对象，算法复杂性会大大增加，系统的处理能力也会相应降低，同时，“碎片”问题将会比较难解决。</p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/JVM/">JVM</a></li></span></span> | <span class="tags">Tagged <a href="/tags/JVM/" class="label label-primary">JVM</a><a href="/tags/Java&J2EE/" class="label label-success">Java&J2EE</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:42"datetime="2014-03-07 09:54:42"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-JVM--JVM调优总结（四）-垃圾回收面临的问题/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-JVM--JVM调优总结（四）-垃圾回收面临的问题" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--JVM调优总结（十二）-参考资料/">JVM调优总结（十二）</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:42.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--JVM调优总结（十二）-参考资料/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="jvm-">JVM调优总结（十二）-参考资料</h1>
<pre><code>能整理出上面一些东西，也是因为站在巨人的肩上。下面是一些参考资料，供大家学习，大家有更好的，可以继续完善：）
</code></pre><p>· <a href="http://www.ibm.com/developerworks/cn/java/j-jtp10283/" target="_blank">Java 理论与实践: 垃圾收集简史</a></p>
<p>· <a href="http://pengjiaheng.iteye.com/admin/blogs/#resources" target="_blank">Java SE 6 HotSpot[tm] Virtual Machine Garbage Collection Tuning</a></p>
<p>· <a href="http://pengjiaheng.iteye.com/admin/blogs/#16.2.6" target="_blank">Improving Java Application Performance and Scalability by Reducing Garbage Collection Times and Sizing Memory Using JDK 1.4.1</a></p>
<p>· <a href="https://java.sun.com/j2se/reference/whitepapers/memorymanagement_whitepaper.pdf" target="_blank">Hotspot memory management whitepaper</a></p>
<p>· <a href="http://java.sun.com/performance/reference/whitepapers/tuning.html" target="_blank">Java Tuning White Paper</a></p>
<p>· <a href="http://java.sun.com/docs/hotspot/gc1.4.2/example.html" target="_blank">Diagnosing a Garbage Collection problem</a></p>
<p>· <a href="http://java.sun.com/javase/technologies/hotspot/vmoptions.jsp" target="_blank">Java HotSpot VM Options</a></p>
<p>· <a href="http://blogs.sun.com/watt/resource/jvm-options-list.html" target="_blank">A Collection of JVM Options</a></p>
<p>· <a href="http://research.sun.com/jtech/pubs/04-g1-paper-ismm.pdf" target="_blank">Garbage-First Garbage Collection</a></p>
<p>· <a href="http://java.sun.com/docs/hotspot/gc1.4.2/faq.html" target="_blank">Frequently Asked Questions about Garbage Collection in the HotspotTM JavaTM Virtual Machine</a></p>
<p>· <a href="http://pengjiaheng.spaces.live.com/blog/cns!2DAA368B386E6AEA!685.entry" target="_blank">JProfiler试用手记</a></p>
<p>· <a href="http://kenwu.me/java6-jvm-options-chinese-edition-published" target="_blank">Java6 JVM参数选项大全</a></p>
<p>· <a href="http://www.douban.com/subject/1138768/" target="_blank">《深入Java虚拟机》</a>。虽然过去了很多年，但这本书依旧是经典。</p>
<pre><code>这里是本系列的最后一篇了，很高兴大家能够喜欢这系列的文章。期间也提了很多问题，其中有些是我之前没有想到的或者考虑欠妥的，感谢提出这些问题的朋友，我也学到的不少东西。
</code></pre>
      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/JVM/">JVM</a></li></span></span> | <span class="tags">Tagged <a href="/tags/JVM/" class="label label-primary">JVM</a><a href="/tags/Java&J2EE/" class="label label-success">Java&J2EE</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:42"datetime="2014-03-07 09:54:42"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-JVM--JVM调优总结（十二）-参考资料/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-JVM--JVM调优总结（十二）-参考资料" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--JVM调优总结（六）-分代垃圾回收详述2/">JVM调优总结（六）</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:42.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--JVM调优总结（六）-分代垃圾回收详述2/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="jvm-2">JVM调优总结（六）-分代垃圾回收详述2</h1>
<h2 id="-">分代垃圾回收流程示意</h2>
<p><img src="" alt=""></p>
<p><img src="" alt=""></p>
<p><img src="" alt=""></p>
<p><img src="" alt=""></p>
<h2 id="-">选择合适的垃圾收集算法</h2>
<p><strong>串行收集器</strong></p>
<p><img src="" alt=""></p>
<p>用单线程处理所有垃圾回收工作，因为无需多线程交互，所以效率比较高。但是，也无法使用多处理器的优势，所以此收集器适合单处理器机器。当然，此收集器也可以用在小数据量（100M左右）情况下的多处理器机器上。可以使用-XX:+UseSerialGC打开。</p>
<p><strong>并行收集器</strong></p>
<p><img src="" alt=""></p>
<p>对年轻代进行并行垃圾回收，因此可以减少垃圾回收时间。一般在多线程多处理器机器上使用。使用-XX:+UseParallelGC.打开。并行收集器在J2SE5.0第六6更新上引入，在Java SE6.0中进行了增强--可以对年老代进行并行收集。如果年老代不使用并发收集的话，默认是使用单线程进行垃圾回收，因此会制约扩展能力。使用-XX:+UseParallelOldGC打开。</p>
<p>使用-XX:ParallelGCThreads=<N>设置并行垃圾回收的线程数。此值可以设置与机器处理器数量相等。</p>
<p>此收集器可以进行如下配置：
<strong>最大垃圾回收暂停:</strong>指定垃圾回收时的最长暂停时间，通过-XX:MaxGCPauseMillis=<N>指定。<N>为毫秒.如果指定了此值的话，堆大小和垃圾回收相关参数会进行调整以达到指定值。设定此值可能会减少应用的吞吐量。</p>
<p><strong>吞吐量:</strong>吞吐量为垃圾回收时间与非垃圾回收时间的比值，通过-XX:GCTimeRatio=<N>来设定，公式为1/（1+N）。例如，-XX:GCTimeRatio=19时，表示5%的时间用于垃圾回收。默认情况为99，即1%的时间用于垃圾回收。</p>
<p><strong>并发收集器</strong></p>
<p>可以保证大部分工作都并发进行（应用不停止），垃圾回收只暂停很少的时间，此收集器适合对响应时间要求比较高的中、大规模应用。使用-XX:+UseConcMarkSweepGC打开。</p>
<p><img src="" alt=""></p>
<pre><code>并发收集器主要减少年老代的暂停时间，他在应用不停止的情况下使用独立的垃圾回收线程，跟踪可达对象。在每个年老代垃圾回收周期中，在收集初期并发收集器 会对整个应用进行简短的暂停，在收集中还会再暂停一次。第二次暂停会比第一次稍长，在此过程中多个线程同时进行垃圾回收工作。

并发收集器使用处理器换来短暂的停顿时间。在一个N个处理器的系统上，并发收集部分使用K/N个可用处理器进行回收，一般情况下1&lt;=K&lt;=N/4。

在只有一个处理器的主机上使用并发收集器，设置为incremental mode模式也可获得较短的停顿时间。



**浮动垃圾：**由于在应用运行的同时进行垃圾回收，所以有些垃圾可能在垃圾回收进行完成时产生，这样就造成了“Floating Garbage”，这些垃圾需要在下次垃圾回收周期时才能回收掉。所以，并发收集器一般需要20%的预留空间用于这些浮动垃圾。



**Concurrent Mode Failure：**并发收集器在应用运行时进行收集，所以需要保证堆在垃圾回收的这段时间有足够的空间供程序使用，否则，垃圾回收还未完成，堆空间先满了。这种情况下将会发生“并发模式失败”，此时整个应用将会暂停，进行垃圾回收。



**启动并发收集器：**因为并发收集在应用运行时进行收集，所以必须保证收集完成之前有足够的内存空间供程序使用，否则会出现“Concurrent Mode Failure”。通过设置-XX:CMSInitiatingOccupancyFraction=&lt;N&gt;指定还有多少剩余堆时开始执行并发收集
</code></pre><h2 id="-">小结</h2>
<p><strong>串行处理器：</strong></p>
<p>--适用情况：数据量比较小（100M左右）；单处理器下并且对响应时间无要求的应用。
--缺点：只能用于小型应用</p>
<p><strong>并行处理器：</strong></p>
<p>--适用情况：“对吞吐量有高要求”，多CPU、对应用响应时间无要求的中、大型应用。举例：后台处理、科学计算。
--缺点：垃圾收集过程中应用响应时间可能加长</p>
<p><strong>并发处理器：</strong></p>
<p>--适用情况：“对响应时间有高要求”，多CPU、对应用响应时间有较高要求的中、大型应用。举例：Web服务器/应用服务器、电信交换、集成开发环境。</p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/JVM/">JVM</a></li></span></span> | <span class="tags">Tagged <a href="/tags/JVM/" class="label label-primary">JVM</a><a href="/tags/Java&J2EE/" class="label label-success">Java&J2EE</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:42"datetime="2014-03-07 09:54:42"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-JVM--JVM调优总结（六）-分代垃圾回收详述2/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-JVM--JVM调优总结（六）-分代垃圾回收详述2" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--eden区没有发生minorgc，对象直接分配在了oldgen/">eden区没有发生minor gc，对象直接分配在了old gen</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:42.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--eden区没有发生minorgc，对象直接分配在了oldgen/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="eden-minor-gc-old-gen">eden区没有发生minor gc，对象直接分配在了old gen</h1>
<p><a href="http://hllvm.group.iteye.com/login" title="登录" target="_blank">您还未登录 !</a> <a href="http://hllvm.group.iteye.com/login" target="_blank">登录</a> <a href="http://hllvm.group.iteye.com/signup" target="_blank">注册</a></p>
<p><a href="http://www.iteye.com/" target="_blank"><img src="&quot;ITeye-最棒的软件开发交流社区&quot;" alt="ITeye3.0"></a></p>
<p><a href="http://www.iteye.com/groups" target="_blank">群组首页</a> → <a href="http://hllvm.group.iteye.com/groups/category/language" target="_blank">编程语言</a> → <a href="http://hllvm.group.iteye.com/" target="_blank">高级语言虚拟机</a> → <a href="http://hllvm.group.iteye.com/group/forum" target="_blank">论坛</a></p>
<p><img src="" alt=""> <a href="http://hllvm.group.iteye.com/group/topic/38293/post/new" target="_blank">发表回复</a></p>
<h3 id="-http-hllvm-group-iteye-com-group-forum-tag_id-690-eden-minor-gc-old-gen-"><a href="http://hllvm.group.iteye.com/group/forum?tag_id=690" target="_blank">[讨论]</a> <a href="">eden区没有发生minor gc，对象直接分配在了old gen</a></h3>
<p><a href="http://zsl8544-163-com.iteye.com/" target="_blank"><img src="&quot;等待雨季的到来的博客: &quot;" alt="等待雨季的到来的博客"></a> <a href="http://zsl8544-163-com.iteye.com/" title="等待雨季的到来" target="_blank">等待雨季的到来</a> 2013-07-21</p>
<p>我的测试代码如下
Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>//<em>/</em> </li>
<li>/* -Xmx100M -XX:+PrintGCDetails -XX:MaxNewSize=40M -XX:+PrintTenuringDistribution </li>
<li>/*/  </li>
<li>public static void testAllocation(){  </li>
<li>byte[] byte1 = new byte[_1MB/*5];  </li>
<li>byte[] byte2 = new byte[_1MB/*10];  </li>
<li>byte1 = null;  </li>
<li>byte2 = null;                         </li>
<li>byte[] byte3 = new byte[_1MB/*5];  </li>
<li>byte[] byte4 = new byte[_1MB/*10];  </li>
<li>byte3 = null;  </li>
<li>byte4 = null;  </li>
<li>byte[] byte5 = new byte[_1MB/*15];   </li>
<li><p>}<br>//<em>/</em> /<em> -Xmx100M -XX:+PrintGCDetails -XX:MaxNewSize=40M -XX:+PrintTenuringDistribution /</em>/ public static void testAllocation(){ byte[] byte1 = new byte[_1MB/<em>5]; byte[] byte2 = new byte[_1MB/</em>10]; byte1 = null; byte2 = null; byte[] byte3 = new byte[_1MB/<em>5]; byte[] byte4 = new byte[_1MB/</em>10]; byte3 = null; byte4 = null; byte[] byte5 = new byte[_1MB/*15]; }
因为没有用NewSize限定新生代的初始大小，所以eden区的初始大小为20M，而我用MaxNewSize限定了新生代的初始大小为40M。
GC Log
Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>[GC  </p>
</li>
<li>Desired survivor size 3538944 bytes, new threshold 7 (max 15)  </li>
<li>[PSYoungGen: 16194K-&gt;368K(24320K)] 16194K-&gt;368K(79872K), 0.0020460 secs] [Times: user=0.01 sys=0.00, real=0.00 secs]   </li>
<li>Heap  </li>
<li>PSYoungGen      total 24320K, used 17199K [0x0000000115490000, 0x0000000117c90000, 0x0000000117c90000)  </li>
<li>eden space 20864K, 80% used [0x0000000115490000,0x00000001164ffe38,0x00000001168f0000)  </li>
<li>from space 3456K, 10% used [0x00000001168f0000,0x000000011694c010,0x0000000116c50000)  </li>
<li>to   space 3456K, 0% used [0x0000000117930000,0x0000000117930000,0x0000000117c90000)  </li>
<li>ParOldGen       total 55552K, used 15360K [0x0000000111890000, 0x0000000114ed0000, 0x0000000115490000)  </li>
<li>object space 55552K, 27% used [0x0000000111890000,0x0000000112790010,0x0000000114ed0000)  </li>
<li>PSPermGen       total 21248K, used 2695K [0x000000010c690000, 0x000000010db50000, 0x0000000111890000)  </li>
<li>object space 21248K, 12% used [0x000000010c690000,0x000000010c931ef0,0x000000010db50000)<br>[GC Desired survivor size 3538944 bytes, new threshold 7 (max 15) [PSYoungGen: 16194K-&gt;368K(24320K)] 16194K-&gt;368K(79872K), 0.0020460 secs] [Times: user=0.01 sys=0.00, real=0.00 secs] Heap PSYoungGen total 24320K, used 17199K <a href="http://rednaxelafx.iteye.com/">0x0000000115490000, 0x0000000117c90000, 0x0000000117c90000) eden space 20864K, 80% used [0x0000000115490000,0x00000001164ffe38,0x00000001168f0000) from space 3456K, 10% used [0x00000001168f0000,0x000000011694c010,0x0000000116c50000) to space 3456K, 0% used [0x0000000117930000,0x0000000117930000,0x0000000117c90000) ParOldGen total 55552K, used 15360K [0x0000000111890000, 0x0000000114ed0000, 0x0000000115490000) object space 55552K, 27% used [0x0000000111890000,0x0000000112790010,0x0000000114ed0000) PSPermGen total 21248K, used 2695K [0x000000010c690000, 0x000000010db50000, 0x0000000111890000) object space 21248K, 12% used [0x000000010c690000,0x000000010c931ef0,0x000000010db50000)
现象：
当分配byte3时触发了一次minor gc，byte1和byte2都被回收了，可是我分配byte5的时候，却直接分配在了老生代，byte3和byte4依旧在eden区，而byte5直接被分配在了老生代。
问题：
1、byte5为什么没有触发minor gc而是直接分配在老生代，byte3和byte4为什么没有被回收？
2、eden区什么时候才会自动扩容到40M，当创建超过20M的对象时，都是直接分配在了老生，而创建大小超过老生代的对象时老生代会自动扩容。
其他：
我在用eclipse调试的时候发现，同样的测试代码在执行的时候输出的GC log居然会有很大的变化，有的时候eden区被初始化为8M有的时候初始化为20M。我工作在OS X下，JDK版本如下。
java version &quot;1.7.0_25&quot;
Java(TM) SE Runtime Environment (build 1.7.0_25-b15)
Java HotSpot(TM) 64-Bit Server VM (build 23.25-b01, mixed mode)
<img src="" alt="Spinner"> [<img src="&quot;RednaxelaFX的博客: Script Ahead, Code Behind&quot;" alt="RednaxelaFX的博客"></a> <a href="http://rednaxelafx.iteye.com/" title="RednaxelaFX" target="_blank">RednaxelaFX</a> 2013-07-25</li>
</ol>
<p>楼主是看了毕玄的实验之后自己动手测试么？
把楼主的代码弄成可执行的，我用的测试代码是：
Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>public class PSAllocTest {  </li>
<li>private static final int _1KB = 1024;  </li>
<li>private static final int _1MB = _1KB /* 1024;  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* -Xmx100M -XX:+PrintGCDetails -XX:MaxNewSize=40M -XX:+PrintTenuringDistribution </li>
<li>/*/  </li>
<li>public static void testAllocation() {  </li>
<li>byte[] byte1 = new byte[_1MB/*5];  </li>
<li>byte[] byte2 = new byte[_1MB/*10];  </li>
<li>byte1 = null;  </li>
<li>byte2 = null;                         </li>
<li>byte[] byte3 = new byte[_1MB/*5];  </li>
<li>byte[] byte4 = new byte[_1MB/*10];  </li>
<li>byte3 = null;  </li>
<li>byte4 = null;  </li>
<li>byte[] byte5 = new byte[_1MB/*15];   </li>
<li>}  </li>
<li></li>
<li>public static void main(String[] args) {  </li>
<li>testAllocation();  </li>
<li>}  </li>
<li><p>}<br>public class PSAllocTest { private static final int _1KB = 1024; private static final int _1MB = _1KB /<em> 1024; //</em>/<em> /</em> -Xmx100M -XX:+PrintGCDetails -XX:MaxNewSize=40M -XX:+PrintTenuringDistribution /<em>/ public static void testAllocation() { byte[] byte1 = new byte[_1MB/</em>5]; byte[] byte2 = new byte[_1MB/<em>10]; byte1 = null; byte2 = null; byte[] byte3 = new byte[_1MB/</em>5]; byte[] byte4 = new byte[_1MB/<em>10]; byte3 = null; byte4 = null; byte[] byte5 = new byte[_1MB/</em>15]; } public static void main(String[] args) { testAllocation(); } }
我这边在JDK7u9 64-bit Server VM上跑看到的GC日志会有两次GC：
Gc log代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>D:\test\pstest&gt;java -Xmx100M -XX:+PrintGCDetails -XX:MaxNewSize=40M PSAllocTest  </p>
</li>
<li>[GC [PSYoungGen: 16002K-&gt;584K(18688K)] 16002K-&gt;584K(61376K), 0.0016857 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]  </li>
<li>[GC [PSYoungGen: 16648K-&gt;576K(34752K)] 32008K-&gt;15936K(77440K), 0.0014163 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]  </li>
<li>Heap  </li>
<li>PSYoungGen      total 34752K, used 1218K [0x00000000fd800000, 0x00000000ffc80000, 0x0000000100000000)  </li>
<li>eden space 32128K, 2% used [0x00000000fd800000,0x00000000fd8a0ab0,0x00000000ff760000)  </li>
<li>from space 2624K, 21% used [0x00000000ff9f0000,0x00000000ffa80030,0x00000000ffc80000)  </li>
<li>to   space 2624K, 0% used [0x00000000ff760000,0x00000000ff760000,0x00000000ff9f0000)  </li>
<li>ParOldGen       total 42688K, used 15360K [0x00000000f9c00000, 0x00000000fc5b0000, 0x00000000fd800000)  </li>
<li>object space 42688K, 35% used [0x00000000f9c00000,0x00000000fab00010,0x00000000fc5b0000)  </li>
<li>PSPermGen       total 21248K, used 2505K [0x00000000f4a00000, 0x00000000f5ec0000, 0x00000000f9c00000)  </li>
<li><p>object space 21248K, 11% used [0x00000000f4a00000,0x00000000f4c72638,0x00000000f5ec0000)<br>D:\test\pstest&gt;java -Xmx100M -XX:+PrintGCDetails -XX:MaxNewSize=40M PSAllocTest [GC [PSYoungGen: 16002K-&gt;584K(18688K)] 16002K-&gt;584K(61376K), 0.0016857 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [GC [PSYoungGen: 16648K-&gt;576K(34752K)] 32008K-&gt;15936K(77440K), 0.0014163 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] Heap PSYoungGen total 34752K, used 1218K <a href="&quot;复制代码&quot;">0x00000000fd800000, 0x00000000ffc80000, 0x0000000100000000) eden space 32128K, 2% used [0x00000000fd800000,0x00000000fd8a0ab0,0x00000000ff760000) from space 2624K, 21% used [0x00000000ff9f0000,0x00000000ffa80030,0x00000000ffc80000) to space 2624K, 0% used [0x00000000ff760000,0x00000000ff760000,0x00000000ff9f0000) ParOldGen total 42688K, used 15360K [0x00000000f9c00000, 0x00000000fc5b0000, 0x00000000fd800000) object space 42688K, 35% used [0x00000000f9c00000,0x00000000fab00010,0x00000000fc5b0000) PSPermGen total 21248K, used 2505K [0x00000000f4a00000, 0x00000000f5ec0000, 0x00000000f9c00000) object space 21248K, 11% used [0x00000000f4a00000,0x00000000f4c72638,0x00000000f5ec0000)
第二次GC其实已经在第5个数组成功分配之后了，就楼主关心的部分看我这边看到的跟楼主实验看到的行为一致，只要关心日志里的第一次GC就好了。
如果加上额外参数的话，可以看到更多GC信息：
Java代码 [<img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>D:\test\pstest&gt;java -Xmx100M -XX:+PrintGCDetails -XX:+PrintHeapAtGC -XX:+PrintTLAB -XX:MaxNewSize=40M -XX:+PrintTenuringDistribution PSAllocTest  </p>
</li>
<li>{Heap before GC invocations=1 (full 0):  </li>
<li>PSYoungGen      total 18688K, used 16002K [0x00000000fd800000, 0x00000000fecd0000, 0x0000000100000000)  </li>
<li>eden space 16064K, 99% used [0x00000000fd800000,0x00000000fe7a0b60,0x00000000fe7b0000)  </li>
<li>from space 2624K, 0% used [0x00000000fea40000,0x00000000fea40000,0x00000000fecd0000)  </li>
<li>to   space 2624K, 0% used [0x00000000fe7b0000,0x00000000fe7b0000,0x00000000fea40000)  </li>
<li>ParOldGen       total 42688K, used 0K [0x00000000f9c00000, 0x00000000fc5b0000, 0x00000000fd800000)  </li>
<li>object space 42688K, 0% used [0x00000000f9c00000,0x00000000f9c00000,0x00000000fc5b0000)  </li>
<li>PSPermGen       total 21248K, used 2495K [0x00000000f4a00000, 0x00000000f5ec0000, 0x00000000f9c00000)  </li>
<li>object space 21248K, 11% used [0x00000000f4a00000,0x00000000f4c6fc80,0x00000000f5ec0000)  </li>
<li>TLAB: gc thread: 0x000000000028c000 [id: 10344] desired_size: 321KB slow allocs: 3  refill waste: 5232B alloc: 0.99998    16003KB refills: 2 waste  6.2% gc: 40912B slow: 40B fast: 0B  </li>
<li>TLAB totals: thrds: 1  refills: 2 max: 2 slow allocs: 3 max 3 waste:  6.2% gc: 40912B max: 40912B slow: 40B max: 40B fast: 0B max: 0B  </li>
<li>[GC  </li>
<li>Desired survivor size 2686976 bytes, new threshold 7 (max 15)  </li>
<li>[PSYoungGen: 16002K-&gt;640K(18688K)] 16002K-&gt;640K(61376K), 0.0015035 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]   </li>
<li>Heap after GC invocations=1 (full 0):  </li>
<li>PSYoungGen      total 18688K, used 640K [0x00000000fd800000, 0x00000000ffc80000, 0x0000000100000000)  </li>
<li>eden space 16064K, 0% used [0x00000000fd800000,0x00000000fd800000,0x00000000fe7b0000)  </li>
<li>from space 2624K, 24% used [0x00000000fe7b0000,0x00000000fe850030,0x00000000fea40000)  </li>
<li>to   space 2624K, 0% used [0x00000000ff9f0000,0x00000000ff9f0000,0x00000000ffc80000)  </li>
<li>ParOldGen       total 42688K, used 0K [0x00000000f9c00000, 0x00000000fc5b0000, 0x00000000fd800000)  </li>
<li>object space 42688K, 0% used [0x00000000f9c00000,0x00000000f9c00000,0x00000000fc5b0000)  </li>
<li>PSPermGen       total 21248K, used 2495K [0x00000000f4a00000, 0x00000000f5ec0000, 0x00000000f9c00000)  </li>
<li>object space 21248K, 11% used [0x00000000f4a00000,0x00000000f4c6fc80,0x00000000f5ec0000)  </li>
<li>}  </li>
<li>{Heap before GC invocations=2 (full 0):  </li>
<li>PSYoungGen      total 18688K, used 16704K [0x00000000fd800000, 0x00000000ffc80000, 0x0000000100000000)  </li>
<li>eden space 16064K, 100% used [0x00000000fd800000,0x00000000fe7b0000,0x00000000fe7b0000)  </li>
<li>from space 2624K, 24% used [0x00000000fe7b0000,0x00000000fe850030,0x00000000fea40000)  </li>
<li>to   space 2624K, 0% used [0x00000000ff9f0000,0x00000000ff9f0000,0x00000000ffc80000)  </li>
<li>ParOldGen       total 42688K, used 15360K [0x00000000f9c00000, 0x00000000fc5b0000, 0x00000000fd800000)  </li>
<li>object space 42688K, 35% used [0x00000000f9c00000,0x00000000fab00010,0x00000000fc5b0000)  </li>
<li>PSPermGen       total 21248K, used 2498K [0x00000000f4a00000, 0x00000000f5ec0000, 0x00000000f9c00000)  </li>
<li>object space 21248K, 11% used [0x00000000f4a00000,0x00000000f4c708a0,0x00000000f5ec0000)  </li>
<li>TLAB: gc thread: 0x00000000022a5800 [id: 10100] desired_size: 321KB slow allocs: 0  refill waste: 5136B alloc: 0.99998    16064KB refills: 1 waste 100.0% gc: 328952B slow: 0B fast: 0B  </li>
<li>TLAB: gc thread: 0x000000000229e800 [id: 3928] desired_size: 321KB slow allocs: 0  refill waste: 5136B alloc: 0.99998    16064KB refills: 1 waste 100.0% gc: 328984B slow: 0B fast: 0B  </li>
<li>TLAB totals: thrds: 2  refills: 2 max: 1 slow allocs: 0 max 0 waste: 100.0% gc: 657936B max: 328984B slow: 0B max: 0B fast: 0B max: 0B  </li>
<li>[GC  </li>
<li>Desired survivor size 2686976 bytes, new threshold 7 (max 15)  </li>
<li>[PSYoungGen: 16704K-&gt;520K(34752K)] 32064K-&gt;15880K(77440K), 0.0012669 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]   </li>
<li>Heap after GC invocations=2 (full 0):  </li>
<li>PSYoungGen      total 34752K, used 520K [0x00000000fd800000, 0x00000000ffc80000, 0x0000000100000000)  </li>
<li>eden space 32128K, 0% used [0x00000000fd800000,0x00000000fd800000,0x00000000ff760000)  </li>
<li>from space 2624K, 19% used [0x00000000ff9f0000,0x00000000ffa72020,0x00000000ffc80000)  </li>
<li>to   space 2624K, 0% used [0x00000000ff760000,0x00000000ff760000,0x00000000ff9f0000)  </li>
<li>ParOldGen       total 42688K, used 15360K [0x00000000f9c00000, 0x00000000fc5b0000, 0x00000000fd800000)  </li>
<li>object space 42688K, 35% used [0x00000000f9c00000,0x00000000fab00010,0x00000000fc5b0000)  </li>
<li>PSPermGen       total 21248K, used 2498K [0x00000000f4a00000, 0x00000000f5ec0000, 0x00000000f9c00000)  </li>
<li>object space 21248K, 11% used [0x00000000f4a00000,0x00000000f4c708a0,0x00000000f5ec0000)  </li>
<li>}  </li>
<li>Heap  </li>
<li>PSYoungGen      total 34752K, used 1162K [0x00000000fd800000, 0x00000000ffc80000, 0x0000000100000000)  </li>
<li>eden space 32128K, 2% used [0x00000000fd800000,0x00000000fd8a0ab0,0x00000000ff760000)  </li>
<li>from space 2624K, 19% used [0x00000000ff9f0000,0x00000000ffa72020,0x00000000ffc80000)  </li>
<li>to   space 2624K, 0% used [0x00000000ff760000,0x00000000ff760000,0x00000000ff9f0000)  </li>
<li>ParOldGen       total 42688K, used 15360K [0x00000000f9c00000, 0x00000000fc5b0000, 0x00000000fd800000)  </li>
<li>object space 42688K, 35% used [0x00000000f9c00000,0x00000000fab00010,0x00000000fc5b0000)  </li>
<li>PSPermGen       total 21248K, used 2505K [0x00000000f4a00000, 0x00000000f5ec0000, 0x00000000f9c00000)  </li>
<li><p>object space 21248K, 11% used [0x00000000f4a00000,0x00000000f4c72638,0x00000000f5ec0000)<br>D:\test\pstest&gt;java -Xmx100M -XX:+PrintGCDetails -XX:+PrintHeapAtGC -XX:+PrintTLAB -XX:MaxNewSize=40M -XX:+PrintTenuringDistribution PSAllocTest {Heap before GC invocations=1 (full 0): PSYoungGen total 18688K, used 16002K [0x00000000fd800000, 0x00000000fecd0000, 0x0000000100000000) eden space 16064K, 99% used [0x00000000fd800000,0x00000000fe7a0b60,0x00000000fe7b0000) from space 2624K, 0% used [0x00000000fea40000,0x00000000fea40000,0x00000000fecd0000) to space 2624K, 0% used [0x00000000fe7b0000,0x00000000fe7b0000,0x00000000fea40000) ParOldGen total 42688K, used 0K [0x00000000f9c00000, 0x00000000fc5b0000, 0x00000000fd800000) object space 42688K, 0% used [0x00000000f9c00000,0x00000000f9c00000,0x00000000fc5b0000) PSPermGen total 21248K, used 2495K [0x00000000f4a00000, 0x00000000f5ec0000, 0x00000000f9c00000) object space 21248K, 11% used [0x00000000f4a00000,0x00000000f4c6fc80,0x00000000f5ec0000) TLAB: gc thread: 0x000000000028c000 [id: 10344] desired_size: 321KB slow allocs: 3 refill waste: 5232B alloc: 0.99998 16003KB refills: 2 waste 6.2% gc: 40912B slow: 40B fast: 0B TLAB totals: thrds: 1 refills: 2 max: 2 slow allocs: 3 max 3 waste: 6.2% gc: 40912B max: 40912B slow: 40B max: 40B fast: 0B max: 0B [GC Desired survivor size 2686976 bytes, new threshold 7 (max 15) [PSYoungGen: 16002K-&gt;640K(18688K)] 16002K-&gt;640K(61376K), 0.0015035 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] Heap after GC invocations=1 (full 0): PSYoungGen total 18688K, used 640K [0x00000000fd800000, 0x00000000ffc80000, 0x0000000100000000) eden space 16064K, 0% used [0x00000000fd800000,0x00000000fd800000,0x00000000fe7b0000) from space 2624K, 24% used [0x00000000fe7b0000,0x00000000fe850030,0x00000000fea40000) to space 2624K, 0% used [0x00000000ff9f0000,0x00000000ff9f0000,0x00000000ffc80000) ParOldGen total 42688K, used 0K [0x00000000f9c00000, 0x00000000fc5b0000, 0x00000000fd800000) object space 42688K, 0% used [0x00000000f9c00000,0x00000000f9c00000,0x00000000fc5b0000) PSPermGen total 21248K, used 2495K [0x00000000f4a00000, 0x00000000f5ec0000, 0x00000000f9c00000) object space 21248K, 11% used [0x00000000f4a00000,0x00000000f4c6fc80,0x00000000f5ec0000) } {Heap before GC invocations=2 (full 0): PSYoungGen total 18688K, used 16704K [0x00000000fd800000, 0x00000000ffc80000, 0x0000000100000000) eden space 16064K, 100% used [0x00000000fd800000,0x00000000fe7b0000,0x00000000fe7b0000) from space 2624K, 24% used [0x00000000fe7b0000,0x00000000fe850030,0x00000000fea40000) to space 2624K, 0% used [0x00000000ff9f0000,0x00000000ff9f0000,0x00000000ffc80000) ParOldGen total 42688K, used 15360K [0x00000000f9c00000, 0x00000000fc5b0000, 0x00000000fd800000) object space 42688K, 35% used [0x00000000f9c00000,0x00000000fab00010,0x00000000fc5b0000) PSPermGen total 21248K, used 2498K [0x00000000f4a00000, 0x00000000f5ec0000, 0x00000000f9c00000) object space 21248K, 11% used [0x00000000f4a00000,0x00000000f4c708a0,0x00000000f5ec0000) TLAB: gc thread: 0x00000000022a5800 [id: 10100] desired_size: 321KB slow allocs: 0 refill waste: 5136B alloc: 0.99998 16064KB refills: 1 waste 100.0% gc: 328952B slow: 0B fast: 0B TLAB: gc thread: 0x000000000229e800 [id: 3928] desired_size: 321KB slow allocs: 0 refill waste: 5136B alloc: 0.99998 16064KB refills: 1 waste 100.0% gc: 328984B slow: 0B fast: 0B TLAB totals: thrds: 2 refills: 2 max: 1 slow allocs: 0 max 0 waste: 100.0% gc: 657936B max: 328984B slow: 0B max: 0B fast: 0B max: 0B [GC Desired survivor size 2686976 bytes, new threshold 7 (max 15) [PSYoungGen: 16704K-&gt;520K(34752K)] 32064K-&gt;15880K(77440K), 0.0012669 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] Heap after GC invocations=2 (full 0): PSYoungGen total 34752K, used 520K <a href="&quot;复制代码&quot;">0x00000000fd800000, 0x00000000ffc80000, 0x0000000100000000) eden space 32128K, 0% used [0x00000000fd800000,0x00000000fd800000,0x00000000ff760000) from space 2624K, 19% used [0x00000000ff9f0000,0x00000000ffa72020,0x00000000ffc80000) to space 2624K, 0% used [0x00000000ff760000,0x00000000ff760000,0x00000000ff9f0000) ParOldGen total 42688K, used 15360K [0x00000000f9c00000, 0x00000000fc5b0000, 0x00000000fd800000) object space 42688K, 35% used [0x00000000f9c00000,0x00000000fab00010,0x00000000fc5b0000) PSPermGen total 21248K, used 2498K [0x00000000f4a00000, 0x00000000f5ec0000, 0x00000000f9c00000) object space 21248K, 11% used [0x00000000f4a00000,0x00000000f4c708a0,0x00000000f5ec0000) } Heap PSYoungGen total 34752K, used 1162K [0x00000000fd800000, 0x00000000ffc80000, 0x0000000100000000) eden space 32128K, 2% used [0x00000000fd800000,0x00000000fd8a0ab0,0x00000000ff760000) from space 2624K, 19% used [0x00000000ff9f0000,0x00000000ffa72020,0x00000000ffc80000) to space 2624K, 0% used [0x00000000ff760000,0x00000000ff760000,0x00000000ff9f0000) ParOldGen total 42688K, used 15360K [0x00000000f9c00000, 0x00000000fc5b0000, 0x00000000fd800000) object space 42688K, 35% used [0x00000000f9c00000,0x00000000fab00010,0x00000000fc5b0000) PSPermGen total 21248K, used 2505K [0x00000000f4a00000, 0x00000000f5ec0000, 0x00000000f9c00000) object space 21248K, 11% used [0x00000000f4a00000,0x00000000f4c72638,0x00000000f5ec0000)
加上-XX:+PrintHeapAtGC可以看到每次GC前后堆布局的情况；加上-XX:+PrintTLAB可以看到TLAB的使用状况。
从日志可以看到，这个线程的TLAB才只有321KB，不足以分配楼主例子里的任何一个数组。也就是说例子里的数组全部都不是在TLAB里分配的，而是直接分配在GC堆的共享部分。
我们可以模拟一下楼主的例子的执行过程。整个例子都肯定是在解释器里跑的，所以我们就从解释器来切入。
分配第一个5MB的数组时，解释器要执行newarray字节码指令，来到这里：
hotspot/src/share/vm/interpreter/interpreterRuntime.cpp
C++代码 [<img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>IRT_ENTRY(void, InterpreterRuntime::newarray(JavaThread/* thread, BasicType type, jint size))  </p>
</li>
<li>oop obj = oopFactory::new_typeArray(type, size, CHECK);  </li>
<li>thread-&gt;set_vm_result(obj);  </li>
<li><p>IRT_END<br>IRT_ENTRY(void, InterpreterRuntime::newarray(JavaThread/* thread, BasicType type, jint size)) oop obj = oopFactory::new_typeArray(type, size, CHECK); thread-&gt;set_vm_result(obj); IRT_END
里面调用到：
hotspot/src/share/vm/memory/oopFactory.cpp
C++代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>typeArrayOop oopFactory::new_typeArray(BasicType type, int length, TRAPS) {  </p>
</li>
<li>klassOop type_asKlassOop = Universe::typeArrayKlassObj(type);  </li>
<li>typeArrayKlass/* type_asArrayKlass = typeArrayKlass::cast(type_asKlassOop);  </li>
<li>typeArrayOop result = type_asArrayKlass-&gt;allocate(length, THREAD);  </li>
<li>return result;  </li>
<li><p>}<br>typeArrayOop oopFactory::new_typeArray(BasicType type, int length, TRAPS) { klassOop type_asKlassOop = Universe::typeArrayKlassObj(type); typeArrayKlass/* type_asArrayKlass = typeArrayKlass::cast(type_asKlassOop); typeArrayOop result = type_asArrayKlass-&gt;allocate(length, THREAD); return result; }
进一步调用到：
hotspot/src/share/vm/oops/typeArrayKlass.cpp
C++代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>typeArrayOop typeArrayKlass::allocate(int length, TRAPS) {  </p>
</li>
<li>assert(log2_element_size() &gt;= 0, &quot;bad scale&quot;);  </li>
<li>if (length &gt;= 0) {  </li>
<li>if (length &lt;= max_length()) {  </li>
<li>size_t size = typeArrayOopDesc::object_size(layout_helper(), length);  </li>
<li>KlassHandle h_k(THREAD, as_klassOop());  </li>
<li>typeArrayOop t;  </li>
<li>CollectedHeap/* ch = Universe::heap();  </li>
<li>if (size &lt; ch-&gt;large_typearray_limit()) {  </li>
<li>t = (typeArrayOop)CollectedHeap::array_allocate(h_k, (int)size, length, CHECK_NULL);  </li>
<li>} else {  </li>
<li>t = (typeArrayOop)CollectedHeap::large_typearray_allocate(h_k, (int)size, length, CHECK_NULL);  </li>
<li>}  </li>
<li>assert(t-&gt;is_parsable(), &quot;Don&#39;t publish unless parsable&quot;);  </li>
<li>return t;  </li>
<li>} else {  </li>
<li>report_java_out_of_memory(&quot;Requested array size exceeds VM limit&quot;);  </li>
<li>THROW_OOP_0(Universe::out_of_memory_error_array_size());  </li>
<li>}  </li>
<li>} else {  </li>
<li>THROW_0(vmSymbols::java_lang_NegativeArraySizeException());  </li>
<li>}  </li>
<li><p>}<br>typeArrayOop typeArrayKlass::allocate(int length, TRAPS) { assert(log2_element_size() &gt;= 0, &quot;bad scale&quot;); if (length &gt;= 0) { if (length &lt;= max_length()) { size_t size = typeArrayOopDesc::object_size(layout_helper(), length); KlassHandle h_k(THREAD, as_klassOop()); typeArrayOop t; CollectedHeap/* ch = Universe::heap(); if (size &lt; ch-&gt;large_typearray_limit()) { t = (typeArrayOop)CollectedHeap::array_allocate(h_k, (int)size, length, CHECK_NULL); } else { t = (typeArrayOop)CollectedHeap::large_typearray_allocate(h_k, (int)size, length, CHECK_NULL); } assert(t-&gt;is_parsable(), &quot;Don&#39;t publish unless parsable&quot;); return t; } else { report_java_out_of_memory(&quot;Requested array size exceeds VM limit&quot;); THROW_OOP_0(Universe::out_of_memory_error_array_size()); } } else { THROW_0(vmSymbols::java_lang_NegativeArraySizeException()); } }
这个地方我们看到代码根据要分配的数组是否大于large_typearray_limit()做了分支。那么这个界限是多大呢？
hotspot/src/share/vm/gc_implementation/parallelScavenge/parallelScavengeHeap.hpp
C++代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>size_t large_typearray_limit() { return FastAllocateSizeLimit; }<br>size_t large_typearray_limit() { return FastAllocateSizeLimit; }
hotspot/src/share/vm/runtime/globals.hpp
C++代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>develop(intx, FastAllocateSizeLimit, 128/*K,                               \  </p>
</li>
<li>//<em> Note:  This value is zero mod 1&lt;&lt;13 for a cheap sparc set. /</em>/  \  </li>
<li><p>&quot;Inline allocations larger than this in doublewords must go slow&quot;)\<br>develop(intx, FastAllocateSizeLimit, 128/<em>K, \ //</em> Note: This value is zero mod 1&lt;&lt;13 for a cheap sparc set. /*/ \ &quot;Inline allocations larger than this in doublewords must go slow&quot;)\
这里我们知道了如果对象大小大于128K个doubleword（8字节单元），也就是1MB，就不会进入快速分配路径，而会走慢速分配路径。楼主例子里的数组全部都大于1MB，所以都肯定会走满足分配路径。
不过其实具体到现在HotSpot VM的实现，FastAllocateSizeLimit参数的影响甚微。
它最明显的作用就是让HotSpot Server Compiler（C2）在编译Java方法时看到要分配大于该参数指定的大小的对象时不生成快速分配路径的代码，而直接调用回到VM的慢速分配路径。
而对ParallelScanvege GC来说，这个参数其实设到多少都不影响该GC的行为：本来它就只间接影响到下面讲到的is_noref参数的值，但ParallelScavenge无视了is_noref参数。
回到分配的模拟。接下来调用到：
hotspot/src/share/vm/gc_interface/collectedHeap.inline.hpp
C++代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>oop CollectedHeap::large_typearray_allocate(KlassHandle klass,  </p>
</li>
<li>int size,  </li>
<li>int length,  </li>
<li>TRAPS) {  </li>
<li>debug_only(check_for_valid_allocation_state());  </li>
<li>assert(!Universe::heap()-&gt;is_gc_active(), &quot;Allocation during gc not allowed&quot;);  </li>
<li>assert(size &gt;= 0, &quot;int won&#39;t convert to size_t&quot;);  </li>
<li>HeapWord/* obj = common_mem_allocate_init(size, true, CHECK_NULL);  </li>
<li>post_allocation_setup_array(klass, obj, size, length);  </li>
<li>NOT_PRODUCT(Universe::heap()-&gt;check_for_bad_heap_word_value(obj, size));  </li>
<li>return (oop)obj;  </li>
<li><p>}<br>oop CollectedHeap::large_typearray_allocate(KlassHandle klass, int size, int length, TRAPS) { debug_only(check_for_valid_allocation_state()); assert(!Universe::heap()-&gt;is_gc_active(), &quot;Allocation during gc not allowed&quot;); assert(size &gt;= 0, &quot;int won&#39;t convert to size_t&quot;); HeapWord/* obj = common_mem_allocate_init(size, true, CHECK_NULL); post_allocation_setup_array(klass, obj, size, length); NOT_PRODUCT(Universe::heap()-&gt;check_for_bad_heap_word_value(obj, size)); return (oop)obj; }
这里留意它传给common_mem_allocate_init()的is_noref参数为true，就是说不要refill TLAB。
同一文件里，
C++代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>HeapWord/* CollectedHeap::common_mem_allocate_noinit(size_t size, bool is_noref, TRAPS) {  </p>
</li>
<li></li>
<li>// Clear unhandled oops for memory allocation.  Memory allocation might  </li>
<li>// not take out a lock if from tlab, so clear here.  </li>
<li>CHECK_UNHANDLED_OOPS_ONLY(THREAD-&gt;clear_unhandled_oops();)  </li>
<li></li>
<li>if (HAS_PENDING_EXCEPTION) {  </li>
<li>NOT_PRODUCT(guarantee(false, &quot;Should not allocate with exception pending&quot;));  </li>
<li>return NULL;  // caller does a CHECK_0 too  </li>
<li>}  </li>
<li></li>
<li>// We may want to update this, is_noref objects might not be allocated in TLABs.  </li>
<li>HeapWord/* result = NULL;  </li>
<li>if (UseTLAB) {  </li>
<li>result = CollectedHeap::allocate_from_tlab(THREAD, size);  </li>
<li>if (result != NULL) {  </li>
<li>assert(!HAS_PENDING_EXCEPTION,  </li>
<li>&quot;Unexpected exception, will result in uninitialized storage&quot;);  </li>
<li>return result;  </li>
<li>}  </li>
<li>}  </li>
<li>bool gc_overhead_limit_was_exceeded = false;  </li>
<li>result = Universe::heap()-&gt;mem_allocate(size,  </li>
<li>is_noref,  </li>
<li>false,  </li>
<li>&amp;gc_overhead_limit_was_exceeded);  </li>
<li>if (result != NULL) {  </li>
<li>NOT_PRODUCT(Universe::heap()-&gt;  </li>
<li>check_for_non_bad_heap_word_value(result, size));  </li>
<li>assert(!HAS_PENDING_EXCEPTION,  </li>
<li>&quot;Unexpected exception, will result in uninitialized storage&quot;);  </li>
<li>THREAD-&gt;incr_allocated_bytes(size /* HeapWordSize);  </li>
<li>return result;  </li>
<li>}  </li>
<li></li>
<li></li>
<li>if (!gc_overhead_limit_was_exceeded) {  </li>
<li>// -XX:+HeapDumpOnOutOfMemoryError and -XX:OnOutOfMemoryError support  </li>
<li>report_java_out_of_memory(&quot;Java heap space&quot;);  </li>
<li></li>
<li>if (JvmtiExport::should_post_resource_exhausted()) {  </li>
<li>JvmtiExport::post_resource_exhausted(  </li>
<li>JVMTI_RESOURCE_EXHAUSTED_OOM_ERROR | JVMTI_RESOURCE_EXHAUSTED_JAVA_HEAP,  </li>
<li>&quot;Java heap space&quot;);  </li>
<li>}  </li>
<li></li>
<li>THROW_OOP_0(Universe::out_of_memory_error_java_heap());  </li>
<li>} else {  </li>
<li>// -XX:+HeapDumpOnOutOfMemoryError and -XX:OnOutOfMemoryError support  </li>
<li>report_java_out_of_memory(&quot;GC overhead limit exceeded&quot;);  </li>
<li></li>
<li>if (JvmtiExport::should_post_resource_exhausted()) {  </li>
<li>JvmtiExport::post_resource_exhausted(  </li>
<li>JVMTI_RESOURCE_EXHAUSTED_OOM_ERROR | JVMTI_RESOURCE_EXHAUSTED_JAVA_HEAP,  </li>
<li>&quot;GC overhead limit exceeded&quot;);  </li>
<li>}  </li>
<li></li>
<li>THROW_OOP_0(Universe::out_of_memory_error_gc_overhead_limit());  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>HeapWord/* CollectedHeap::common_mem_allocate_init(size_t size, bool is_noref, TRAPS) {  </li>
<li>HeapWord/* obj = common_mem_allocate_noinit(size, is_noref, CHECK_NULL);  </li>
<li>init_obj(obj, size);  </li>
<li>return obj;  </li>
<li><p>}<br>HeapWord/<em> CollectedHeap::common_mem_allocate_noinit(size_t size, bool is_noref, TRAPS) { // Clear unhandled oops for memory allocation. Memory allocation might // not take out a lock if from tlab, so clear here. CHECK_UNHANDLED_OOPS_ONLY(THREAD-&gt;clear_unhandled_oops();) if (HAS_PENDING_EXCEPTION) { NOT_PRODUCT(guarantee(false, &quot;Should not allocate with exception pending&quot;)); return NULL; // caller does a CHECK_0 too } // We may want to update this, is_noref objects might not be allocated in TLABs. HeapWord/</em> result = NULL; if (UseTLAB) { result = CollectedHeap::allocate_from_tlab(THREAD, size); if (result != NULL) { assert(!HAS_PENDING_EXCEPTION, &quot;Unexpected exception, will result in uninitialized storage&quot;); return result; } } bool gc_overhead_limit_was_exceeded = false; result = Universe::heap()-&gt;mem_allocate(size, is_noref, false, &amp;gc_overhead_limit_was_exceeded); if (result != NULL) { NOT_PRODUCT(Universe::heap()-&gt; check_for_non_bad_heap_word_value(result, size)); assert(!HAS_PENDING_EXCEPTION, &quot;Unexpected exception, will result in uninitialized storage&quot;); THREAD-&gt;incr_allocated_bytes(size /<em> HeapWordSize); return result; } if (!gc_overhead_limit_was_exceeded) { // -XX:+HeapDumpOnOutOfMemoryError and -XX:OnOutOfMemoryError support report_java_out_of_memory(&quot;Java heap space&quot;); if (JvmtiExport::should_post_resource_exhausted()) { JvmtiExport::post_resource_exhausted( JVMTI_RESOURCE_EXHAUSTED_OOM_ERROR | JVMTI_RESOURCE_EXHAUSTED_JAVA_HEAP, &quot;Java heap space&quot;); } THROW_OOP_0(Universe::out_of_memory_error_java_heap()); } else { // -XX:+HeapDumpOnOutOfMemoryError and -XX:OnOutOfMemoryError support report_java_out_of_memory(&quot;GC overhead limit exceeded&quot;); if (JvmtiExport::should_post_resource_exhausted()) { JvmtiExport::post_resource_exhausted( JVMTI_RESOURCE_EXHAUSTED_OOM_ERROR | JVMTI_RESOURCE_EXHAUSTED_JAVA_HEAP, &quot;GC overhead limit exceeded&quot;); } THROW_OOP_0(Universe::out_of_memory_error_gc_overhead_limit()); } } HeapWord/</em> CollectedHeap::common_mem_allocate_init(size_t size, bool is_noref, TRAPS) { HeapWord/* obj = common_mem_allocate_noinit(size, is_noref, CHECK_NULL); init_obj(obj, size); return obj; }
然后会先调用到：
hotspot/src/share/vm/gc_interface/collectedHeap.inline.hpp
C++代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>HeapWord/<em> CollectedHeap::allocate_from_tlab(Thread/</em> thread, size_t size) {  </p>
</li>
<li>assert(UseTLAB, &quot;should use UseTLAB&quot;);  </li>
<li></li>
<li>HeapWord/* obj = thread-&gt;tlab().allocate(size);  </li>
<li>if (obj != NULL) {  </li>
<li>return obj;  </li>
<li>}  </li>
<li>// Otherwise...  </li>
<li>return allocate_from_tlab_slow(thread, size);  </li>
<li><p>}<br>HeapWord/<em> CollectedHeap::allocate_from_tlab(Thread/</em> thread, size_t size) { assert(UseTLAB, &quot;should use UseTLAB&quot;); HeapWord/* obj = thread-&gt;tlab().allocate(size); if (obj != NULL) { return obj; } // Otherwise... return allocate_from_tlab_slow(thread, size); }
前面已经说了，TLAB的大小不足以分配楼主例子里的数组，所以thread-&gt;tlab().allocate()肯定会返回NULL表示无法分配，于是调用到：
hotspot/src/share/vm/gc_interface/collectedHeap.cpp
C++代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>HeapWord/<em> CollectedHeap::allocate_from_tlab_slow(Thread/</em> thread, size_t size) {  </p>
</li>
<li></li>
<li>// Retain tlab and allocate object in shared space if  </li>
<li>// the amount free in the tlab is too large to discard.  </li>
<li>if (thread-&gt;tlab().free() &gt; thread-&gt;tlab().refill_waste_limit()) {  </li>
<li>thread-&gt;tlab().record_slow_allocation(size);  </li>
<li>return NULL;  </li>
<li>}  </li>
<li>// ...  </li>
<li><p>}<br>HeapWord/<em> CollectedHeap::allocate_from_tlab_slow(Thread/</em> thread, size_t size) { // Retain tlab and allocate object in shared space if // the amount free in the tlab is too large to discard. if (thread-&gt;tlab().free() &gt; thread-&gt;tlab().refill_waste_limit()) { thread-&gt;tlab().record_slow_allocation(size); return NULL; } // ... }
例子里TLAB几乎是空的，所以这个if判断肯定会通过，TLAB就会记录下一次slow allocation。从GC日志中第一次minor GC的TLAB统计信息可以看到3次slow allocation，其实就是头两个数组（5MB和10MB那两个）成功分配后，第三个数组（又一个5MB的）尝试在TLAB分配失败后打出的日志。
那么回到CollectedHeap::common_mem_allocate_noinit()，它会调用Universe::heap()-&gt;mem_allocate(...)进一步尝试分配，传入的is_noref为true，is_tlab为false：
hotspot/src/share/vm/gc_implementation/parallelScavengeHeap.cpp
C++代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>// There are two levels of allocation policy here.  </p>
</li>
<li>//  </li>
<li>// When an allocation request fails, the requesting thread must invoke a VM  </li>
<li>// operation, transfer control to the VM thread, and await the results of a  </li>
<li>// garbage collection. That is quite expensive, and we should avoid doing it  </li>
<li>// multiple times if possible.  </li>
<li>//  </li>
<li>// To accomplish this, we have a basic allocation policy, and also a  </li>
<li>// failed allocation policy.  </li>
<li>//  </li>
<li>// The basic allocation policy controls how you allocate memory without  </li>
<li>// attempting garbage collection. It is okay to grab locks and  </li>
<li>// expand the heap, if that can be done without coming to a safepoint.  </li>
<li>// It is likely that the basic allocation policy will not be very  </li>
<li>// aggressive.  </li>
<li>//  </li>
<li>// The failed allocation policy is invoked from the VM thread after  </li>
<li>// the basic allocation policy is unable to satisfy a mem_allocate  </li>
<li>// request. This policy needs to cover the entire range of collection,  </li>
<li>// heap expansion, and out-of-memory conditions. It should make every  </li>
<li>// attempt to allocate the requested memory.  </li>
<li></li>
<li>// Basic allocation policy. Should never be called at a safepoint, or  </li>
<li>// from the VM thread.  </li>
<li>//  </li>
<li>// This method must handle cases where many mem_allocate requests fail  </li>
<li>// simultaneously. When that happens, only one VM operation will succeed,  </li>
<li>// and the rest will not be executed. For that reason, this method loops  </li>
<li>// during failed allocation attempts. If the java heap becomes exhausted,  </li>
<li>// we rely on the size_policy object to force a bail out.  </li>
<li>HeapWord/* ParallelScavengeHeap::mem_allocate(  </li>
<li>size_t size,  </li>
<li>bool is_noref,  </li>
<li>bool is_tlab,  </li>
<li>bool/* gc_overhead_limit_was_exceeded) {  </li>
<li>assert(!SafepointSynchronize::is_at_safepoint(), &quot;should not be at safepoint&quot;);  </li>
<li>assert(Thread::current() != (Thread/*)VMThread::vm_thread(), &quot;should not be in vm thread&quot;);  </li>
<li>assert(!Heap_lock-&gt;owned_by_self(), &quot;this thread should not own the Heap_lock&quot;);  </li>
<li></li>
<li>// In general gc_overhead_limit_was_exceeded should be false so  </li>
<li>// set it so here and reset it to true only if the gc time  </li>
<li>// limit is being exceeded as checked below.  </li>
<li>/*gc_overhead_limit_was_exceeded = false;  </li>
<li></li>
<li>HeapWord/* result = young_gen()-&gt;allocate(size, is_tlab);  </li>
<li></li>
<li>uint loop_count = 0;  </li>
<li>uint gc_count = 0;  </li>
<li></li>
<li>while (result == NULL) {  </li>
<li>// We don&#39;t want to have multiple collections for a single filled generation.  </li>
<li>// To prevent this, each thread tracks the total_collections() value, and if  </li>
<li>// the count has changed, does not do a new collection.  </li>
<li>//  </li>
<li>// The collection count must be read only while holding the heap lock. VM  </li>
<li>// operations also hold the heap lock during collections. There is a lock  </li>
<li>// contention case where thread A blocks waiting on the Heap_lock, while  </li>
<li>// thread B is holding it doing a collection. When thread A gets the lock,  </li>
<li>// the collection count has already changed. To prevent duplicate collections,  </li>
<li>// The policy MUST attempt allocations during the same period it reads the  </li>
<li>// total_collections() value!  </li>
<li>{  </li>
<li>MutexLocker ml(Heap_lock);  </li>
<li>gc_count = Universe::heap()-&gt;total_collections();  </li>
<li></li>
<li>result = young_gen()-&gt;allocate(size, is_tlab);  </li>
<li></li>
<li>// (1) If the requested object is too large to easily fit in the  </li>
<li>//     young_gen, or  </li>
<li>// (2) If GC is locked out via GCLocker, young gen is full and  </li>
<li>//     the need for a GC already signalled to GCLocker (done  </li>
<li>//     at a safepoint),  </li>
<li>// ... then, rather than force a safepoint and (a potentially futile)  </li>
<li>// collection (attempt) for each allocation, try allocation directly  </li>
<li>// in old_gen. For case (2) above, we may in the future allow  </li>
<li>// TLAB allocation directly in the old gen.  </li>
<li>if (result != NULL) {  </li>
<li>return result;  </li>
<li>}  </li>
<li>if (!is_tlab &amp;&amp;  </li>
<li>size &gt;= (young_gen()-&gt;eden_space()-&gt;capacity_in_words(Thread::current()) / 2)) {  </li>
<li>result = old_gen()-&gt;allocate(size, is_tlab);  </li>
<li>if (result != NULL) {  </li>
<li>return result;  </li>
<li>}  </li>
<li>}  </li>
<li>if (GC_locker::is_active_and_needs_gc()) {  </li>
<li>// GC is locked out. If this is a TLAB allocation,  </li>
<li>// return NULL; the requestor will retry allocation  </li>
<li>// of an idividual object at a time.  </li>
<li>if (is_tlab) {  </li>
<li>return NULL;  </li>
<li>}  </li>
<li></li>
<li>// If this thread is not in a jni critical section, we stall  </li>
<li>// the requestor until the critical section has cleared and  </li>
<li>// GC allowed. When the critical section clears, a GC is  </li>
<li>// initiated by the last thread exiting the critical section; so  </li>
<li>// we retry the allocation sequence from the beginning of the loop,  </li>
<li>// rather than causing more, now probably unnecessary, GC attempts.  </li>
<li>JavaThread/* jthr = JavaThread::current();  </li>
<li>if (!jthr-&gt;in_critical()) {  </li>
<li>MutexUnlocker mul(Heap_lock);  </li>
<li>GC_locker::stall_until_clear();  </li>
<li>continue;  </li>
<li>} else {  </li>
<li>if (CheckJNICalls) {  </li>
<li>fatal(&quot;Possible deadlock due to allocating while&quot;  </li>
<li>&quot; in jni critical section&quot;);  </li>
<li>}  </li>
<li>return NULL;  </li>
<li>}  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>if (result == NULL) {  </li>
<li></li>
<li>// Generate a VM operation  </li>
<li>VM_ParallelGCFailedAllocation op(size, is_tlab, gc_count);  </li>
<li>VMThread::execute(&amp;op);  </li>
<li></li>
<li>// Did the VM operation execute? If so, return the result directly.  </li>
<li>// This prevents us from looping until time out on requests that can  </li>
<li>// not be satisfied.  </li>
<li>if (op.prologue_succeeded()) {  </li>
<li>assert(Universe::heap()-&gt;is_in_or_null(op.result()),  </li>
<li>&quot;result not in heap&quot;);  </li>
<li></li>
<li>// If GC was locked out during VM operation then retry allocation  </li>
<li>// and/or stall as necessary.  </li>
<li>if (op.gc_locked()) {  </li>
<li>assert(op.result() == NULL, &quot;must be NULL if gc_locked() is true&quot;);  </li>
<li>continue;  // retry and/or stall as necessary  </li>
<li>}  </li>
<li></li>
<li>// Exit the loop if the gc time limit has been exceeded.  </li>
<li>// The allocation must have failed above (&quot;result&quot; guarding  </li>
<li>// this path is NULL) and the most recent collection has exceeded the  </li>
<li>// gc overhead limit (although enough may have been collected to  </li>
<li>// satisfy the allocation).  Exit the loop so that an out-of-memory  </li>
<li>// will be thrown (return a NULL ignoring the contents of  </li>
<li>// op.result()),  </li>
<li>// but clear gc_overhead_limit_exceeded so that the next collection  </li>
<li>// starts with a clean slate (i.e., forgets about previous overhead  </li>
<li>// excesses).  Fill op.result() with a filler object so that the  </li>
<li>// heap remains parsable.  </li>
<li>const bool limit_exceeded = size_policy()-&gt;gc_overhead_limit_exceeded();  </li>
<li>const bool softrefs_clear = collector_policy()-&gt;all_soft_refs_clear();  </li>
<li>assert(!limit_exceeded || softrefs_clear, &quot;Should have been cleared&quot;);  </li>
<li>if (limit_exceeded &amp;&amp; softrefs_clear) {  </li>
<li>/*gc_overhead_limit_was_exceeded = true;  </li>
<li>size_policy()-&gt;set_gc_overhead_limit_exceeded(false);  </li>
<li>if (PrintGCDetails &amp;&amp; Verbose) {  </li>
<li>gclog_or_tty-&gt;print_cr(&quot;ParallelScavengeHeap::mem_allocate: &quot;  </li>
<li>&quot;return NULL because gc_overhead_limit_exceeded is set&quot;);  </li>
<li>}  </li>
<li>if (op.result() != NULL) {  </li>
<li>CollectedHeap::fill_with_object(op.result(), size);  </li>
<li>}  </li>
<li>return NULL;  </li>
<li>}  </li>
<li></li>
<li>return op.result();  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>// The policy object will prevent us from looping forever. If the  </li>
<li>// time spent in gc crosses a threshold, we will bail out.  </li>
<li>loop_count++;  </li>
<li>if ((result == NULL) &amp;&amp; (QueuedAllocationWarningCount &gt; 0) &amp;&amp;  </li>
<li>(loop_count % QueuedAllocationWarningCount == 0)) {  </li>
<li>warning(&quot;ParallelScavengeHeap::mem_allocate retries %d times \n\t&quot;  </li>
<li>&quot; size=%d %s&quot;, loop_count, size, is_tlab ? &quot;(TLAB)&quot; : &quot;&quot;);  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>return result;  </li>
<li><p>}<br>// There are two levels of allocation policy here. // // When an allocation request fails, the requesting thread must invoke a VM // operation, transfer control to the VM thread, and await the results of a // garbage collection. That is quite expensive, and we should avoid doing it // multiple times if possible. // // To accomplish this, we have a basic allocation policy, and also a // failed allocation policy. // // The basic allocation policy controls how you allocate memory without // attempting garbage collection. It is okay to grab locks and // expand the heap, if that can be done without coming to a safepoint. // It is likely that the basic allocation policy will not be very // aggressive. // // The failed allocation policy is invoked from the VM thread after // the basic allocation policy is unable to satisfy a mem_allocate // request. This policy needs to cover the entire range of collection, // heap expansion, and out-of-memory conditions. It should make every // attempt to allocate the requested memory. // Basic allocation policy. Should never be called at a safepoint, or // from the VM thread. // // This method must handle cases where many mem_allocate requests fail // simultaneously. When that happens, only one VM operation will succeed, // and the rest will not be executed. For that reason, this method loops // during failed allocation attempts. If the java heap becomes exhausted, // we rely on the size_policy object to force a bail out. HeapWord/<em> ParallelScavengeHeap::mem_allocate( size_t size, bool is_noref, bool is_tlab, bool/</em> gc_overhead_limit_was_exceeded) { assert(!SafepointSynchronize::is_at_safepoint(), &quot;should not be at safepoint&quot;); assert(Thread::current() != (Thread/<em>)VMThread::vm_thread(), &quot;should not be in vm thread&quot;); assert(!Heap_lock-&gt;owned_by_self(), &quot;this thread should not own the Heap_lock&quot;); // In general gc_overhead_limit_was_exceeded should be false so // set it so here and reset it to true only if the gc time // limit is being exceeded as checked below. /</em>gc_overhead_limit_was_exceeded = false; HeapWord/<em> result = young_gen()-&gt;allocate(size, is_tlab); uint loop_count = 0; uint gc_count = 0; while (result == NULL) { // We don&#39;t want to have multiple collections for a single filled generation. // To prevent this, each thread tracks the total_collections() value, and if // the count has changed, does not do a new collection. // // The collection count must be read only while holding the heap lock. VM // operations also hold the heap lock during collections. There is a lock // contention case where thread A blocks waiting on the Heap_lock, while // thread B is holding it doing a collection. When thread A gets the lock, // the collection count has already changed. To prevent duplicate collections, // The policy MUST attempt allocations during the same period it reads the // total_collections() value! { MutexLocker ml(Heap_lock); gc_count = Universe::heap()-&gt;total_collections(); result = young_gen()-&gt;allocate(size, is_tlab); // (1) If the requested object is too large to easily fit in the // young_gen, or // (2) If GC is locked out via GCLocker, young gen is full and // the need for a GC already signalled to GCLocker (done // at a safepoint), // ... then, rather than force a safepoint and (a potentially futile) // collection (attempt) for each allocation, try allocation directly // in old_gen. For case (2) above, we may in the future allow // TLAB allocation directly in the old gen. if (result != NULL) { return result; } if (!is_tlab &amp;&amp; size &gt;= (young_gen()-&gt;eden_space()-&gt;capacity_in_words(Thread::current()) / 2)) { result = old_gen()-&gt;allocate(size, is_tlab); if (result != NULL) { return result; } } if (GC_locker::is_active_and_needs_gc()) { // GC is locked out. If this is a TLAB allocation, // return NULL; the requestor will retry allocation // of an idividual object at a time. if (is_tlab) { return NULL; } // If this thread is not in a jni critical section, we stall // the requestor until the critical section has cleared and // GC allowed. When the critical section clears, a GC is // initiated by the last thread exiting the critical section; so // we retry the allocation sequence from the beginning of the loop, // rather than causing more, now probably unnecessary, GC attempts. JavaThread/</em> jthr = JavaThread::current(); if (!jthr-&gt;in_critical()) { MutexUnlocker mul(Heap_lock); GC_locker::stall_until_clear(); continue; } else { if (CheckJNICalls) { fatal(&quot;Possible deadlock due to allocating while&quot; &quot; in jni critical section&quot;); } return NULL; } } } if (result == NULL) { // Generate a VM operation VM_ParallelGCFailedAllocation op(size, is_tlab, gc_count); VMThread::execute(&amp;op); // Did the VM operation execute? If so, return the result directly. // This prevents us from looping until time out on requests that can // not be satisfied. if (op.prologue_succeeded()) { assert(Universe::heap()-&gt;is_in_or_null(op.result()), &quot;result not in heap&quot;); // If GC was locked out during VM operation then retry allocation // and/or stall as necessary. if (op.gc_locked()) { assert(op.result() == NULL, &quot;must be NULL if gc_locked() is true&quot;); continue; // retry and/or stall as necessary } // Exit the loop if the gc time limit has been exceeded. // The allocation must have failed above (&quot;result&quot; guarding // this path is NULL) and the most recent collection has exceeded the // gc overhead limit (although enough may have been collected to // satisfy the allocation). Exit the loop so that an out-of-memory // will be thrown (return a NULL ignoring the contents of // op.result()), // but clear gc_overhead_limit_exceeded so that the next collection // starts with a clean slate (i.e., forgets about previous overhead // excesses). Fill op.result() with a filler object so that the // heap remains parsable. const bool limit_exceeded = size_policy()-&gt;gc_overhead_limit_exceeded(); const bool softrefs_clear = collector_policy()-&gt;all_soft_refs_clear(); assert(!limit_exceeded || softrefs_clear, &quot;Should have been cleared&quot;); if (limit_exceeded &amp;&amp; softrefs_clear) { /*gc_overhead_limit_was_exceeded = true; size_policy()-&gt;set_gc_overhead_limit_exceeded(false); if (PrintGCDetails &amp;&amp; Verbose) { gclog_or_tty-&gt;print_cr(&quot;ParallelScavengeHeap::mem_allocate: &quot; &quot;return NULL because gc_overhead_limit_exceeded is set&quot;); } if (op.result() != NULL) { CollectedHeap::fill_with_object(op.result(), size); } return NULL; } return op.result(); } } // The policy object will prevent us from looping forever. If the // time spent in gc crosses a threshold, we will bail out. loop_count++; if ((result == NULL) &amp;&amp; (QueuedAllocationWarningCount &gt; 0) &amp;&amp; (loop_count % QueuedAllocationWarningCount == 0)) { warning(&quot;ParallelScavengeHeap::mem_allocate retries %d times \n\t&quot; &quot; size=%d %s&quot;, loop_count, size, is_tlab ? &quot;(TLAB)&quot; : &quot;&quot;); } } return result; }
这里会先尝试在young gen里分配
C++代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>// Allocation  </p>
</li>
<li>HeapWord/* allocate(size_t word_size, bool is_tlab) {  </li>
<li>HeapWord/* result = eden_space()-&gt;cas_allocate(word_size);  </li>
<li>return result;  </li>
<li><p>}<br>// Allocation HeapWord/<em> allocate(size_t word_size, bool is_tlab) { HeapWord/</em> result = eden_space()-&gt;cas_allocate(word_size); return result; }
实际上就是尝试在eden里做一次CAS分配。楼主例子里的头两个数组都会在这里分配成功，把eden占用到99%。然后到第三个数组触发GC前试图分配的时候，eden已经没有足够空间了，分配就会失败从而返回NULL。
然后就开始进入“试图分配 -&gt; 不行的话GC -&gt; 再试图分配 -&gt; 不行的话再GC -&gt; 再试图分配”的循环。
做了第一次minor GC后，头两个数组都被GC掉了，eden为空，于是再试图在young gen里分配第三个数组（5MB那个）就成功了。第四个数组（10MB那个）分配的状况与第二个数组类似，都不需要另外触发GC就可以成功。
等到要分配第5个数组（15MB那个）时，堆的状况跟要分配第三个数组时类似，eden都是99%满，所以楼主可能会以为这个数组也会在GC后分配到eden里。实际状况却是它在young gen尝试分配失败后，真的进入GC前还会试图分配，来到ParallelScavengeHeap::mem_allocate()的这个分支：
C++代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>if (!is_tlab &amp;&amp;  </p>
</li>
<li>size &gt;= (young_gen()-&gt;eden_space()-&gt;capacity_in_words(Thread::current()) / 2)) {  </li>
<li>result = old_gen()-&gt;allocate(size, is_tlab);  </li>
<li>if (result != NULL) {  </li>
<li>return result;  </li>
<li>}  </li>
<li>}<br>if (!is_tlab &amp;&amp; size &gt;= (young_gen()-&gt;eden_space()-&gt;capacity_in_words(Thread::current()) / 2)) { result = old_gen()-&gt;allocate(size, is_tlab); if (result != NULL) { return result; } }
此时eden的capacity有15MB多，一半就是不到8MB，第5个数组有15MB多一点，肯定超过了这个判断条件的限制，于是就直接在old gen尝试分配，成功，就不需要做GC，因而之前的第3和第4个数组就都还在。
等待雨季的到来 写道</li>
</ol>
<p>1、byte5为什么没有触发minor gc而是直接分配在老生代，byte3和byte4为什么没有被回收？
总结一下过程：
第1个数组：
大小5MB，慢速路径上在young gen分配直接成功；
第2个数组：
大小10MB，慢速路径上在young gen分配直接成功；
第3个数组：
大小5MB，慢速路径上在young gen分配失败，
（进入循环）再尝试在young gen分配，还是失败，
没达到去old gen分配的大小限制，
于是真的触发一次minor GC，eden清空，
再尝试在young gen分配，成功；
第4个数组：
大小10MB，慢速路径上在young gen分配直接成功；
第5个数组：
大小15MB，慢速路径上在young gen分配失败，
（进入循环）再尝试在young gen分配，还是失败，</p>
<h1 id="-old-gen-old-gen-gc-">达到了去old gen直接分配的大小限制，在old gen上分配成功。没有触发GC。</h1>
<p>等待雨季的到来 写道</p>
<p>2、eden区什么时候才会自动扩容到40M，当创建超过20M的对象时，都是直接分配在了老生，而创建大小超过老生代的对象时老生代会自动扩容。
上面的过程已经很清楚了。如果创建20MB的对象，它在eden分配会失败（此时只有15MB多一点的容量），然后又满足了直接在old gen分配的条件（试图分配的大小大于eden的capacity的一半），就跑到old gen分配了。</p>
<h1 id="-java-tlab-eden-gc-">如果是比较正常的Java程序，创建的多数对象都是小对象，都通过TLAB来分配，那就可以观察到eden经过几次GC后渐渐扩容到最大大小。</h1>
<p>等待雨季的到来 写道</p>
<p>其他：
我在用eclipse调试的时候发现，同样的测试代码在执行的时候输出的GC log居然会有很大的变化，有的时候eden区被初始化为8M有的时候初始化为20M。
这个问题我就不太清楚了。通过Eclipse来调试Java程序，在目标Java程序里会产生一些额外的垃圾，我不太肯定这跟您看到的抖动有没有关系。
<img src="" alt="Spinner"> <a href="http://zsl8544-163-com.iteye.com/" target="_blank"><img src="&quot;等待雨季的到来的博客: &quot;" alt="等待雨季的到来的博客"></a> <a href="http://zsl8544-163-com.iteye.com/" title="等待雨季的到来" target="_blank">等待雨季的到来</a> 前天</p>
<p>实在是太感谢R大神百忙之中能给出这么细致入微的解释了！受益匪浅！以前我的认识只是eden区会在GC之后分配内存，并不知道如果分配内存大于eden区capacity一半就会直接在old gen分配的规则。
只是由于我对TLAB的具体细节只知甚少，对您下面的eden扩容的解释还是不是太清楚。
引用</p>
<p>如果是比较正常的Java程序，创建的多数对象都是小对象，都通过TLAB来分配，那就可以观察到eden经过几次GC后渐渐扩容到最大大小。
为什么说创建小对象，通过TLAB来分配，eden就会渐渐扩容到最大了呢？
还有一个比较傻的问题，内存区域扩容之后还会再缩小吗？有内存扩容这个设计的原因是不是capacity小得内存区域收集的会更快呢？
<img src="" alt="Spinner"> <a href="http://zsl8544-163-com.iteye.com/" target="_blank"><img src="&quot;等待雨季的到来的博客: &quot;" alt="等待雨季的到来的博客"></a> <a href="http://zsl8544-163-com.iteye.com/" title="等待雨季的到来" target="_blank">等待雨季的到来</a> 前天</p>
<p>对了，我没有看毕玄的实验，能给个链接吗？
我看的是您推荐的周志明老师写的深入Java虚拟机。
<img src="" alt="Spinner"> <a href="http://icyfenix.iteye.com/" target="_blank"><img src="&quot;IcyFenix的博客: FenixSoft 3.0&quot;" alt="IcyFenix的博客"></a> <a href="http://icyfenix.iteye.com/" title="IcyFenix" target="_blank">IcyFenix</a> 昨天</p>
<p>等待雨季的到来 写道</p>
<p>实在是太感谢R大神百忙之中能给出这么细致入微的解释了！受益匪浅！以前我的认识只是eden区会在GC之后分配内存，并不知道如果分配内存大于eden区capacity一半就会直接在old gen分配的规则。
只是由于我对TLAB的具体细节只知甚少，对您下面的eden扩容的解释还是不是太清楚。
引用</p>
<p>如果是比较正常的Java程序，创建的多数对象都是小对象，都通过TLAB来分配，那就可以观察到eden经过几次GC后渐渐扩容到最大大小。
为什么说创建小对象，通过TLAB来分配，eden就会渐渐扩容到最大了呢？
还有一个比较傻的问题，内存区域扩容之后还会再缩小吗？有内存扩容这个设计的原因是不是capacity小得内存区域收集的会更快呢？
赞R大的详细解答。我被召唤来回答楼上的2个问题“eden是如何扩容的？”，“eden扩容之后还会缩小吗？”
也按照上面一步一步分析代码来解释，但过程有点多，我就只帖方法名，具体代码不粘上来了，代码可以到openjdk的repo上直接看。
1.遇到分配内存指令（InterpreterRuntime中的new或者newarray这些字节码模版）
2.开始分配内存（前面R大写的分配数组oopFactory::new_typeArray或者分配对象instanceKlass::allocate_instance）
3.向CollectedHeap请求内存（入口是CollectedHeap::array_allocate或者CollectedHeap::obj_allocate，两者最终走到CollectedHeap::common_mem_allocate_noinit方法中）
4.如果能够通过TLAB顺利分配（allocate_from_tlab方法）就在TLAB上划
5.否则，通过mem_allocate方法在eden上划。这个是纯虚方法，因此要看CollectedHeap的子类ParallelScavengeHeap（LZ使用PS收集器）
6.在men_allocate方法中，先通过cas_allocate在MutableSpace上划，不成功的话，堕入GC-尝试分配-GC-尝试分配……的循环中，这个R大在前面讲的很详细，其他就不多说了，着重讲GC。
7.进入GC的过程不是直接方法调用，是通过发送VM_ParallelGCFailedAllocation信号给VM线程触发的，最终转到ParallelScavengeHeap::failed_mem_allocate()方法中。
8.该通过PSScavenge::invoke()开始GC过程，实际GC的活是在PSScavenge::invoke_no_policy()做的。
9.invoke_no_policy()方法可以看到，实际上每次GC都会重置eden大小，即调用了ParallelScavengeHeap::resize_young_gen()方法，eden是否会真正改变，取决于这个方法传入的参数，如果和eden的原本大小不一样，那就相当于增加或者缩小了eden了。
10.这里关系有点烦，补一段说清楚一些。resize_young_gen()方法的参数值就是PSAdaptiveSizePolicy::calculated_eden_size_in_bytes()返回值，换句话说，GC是否要改变eden大小，完全是由PSAdaptiveSizePolicy控制的（这个方法在它的父类AdaptiveSizePolicy中，但calculated_eden_size_in_bytes只是简单返回一个数值，数值是在子类中计算的，PSScavenge::invoke_no_policy()中调用了PSAdaptiveSizePolicy::compute_generation_free_space()去改变这个数值）。
11.到这里，eden如何改变就取决于PSAdaptiveSizePolicy::compute_generation_free_space()的计算结果了。PS收集器的特点是可以设置一些目标策略，譬如追求吞吐量，追求最小停顿时间等，这个方法会根据用户选定的目标，调用adjust_for_minor_pause_time()、adjust_eden_for_footprint()、adjust_for_pause_time()等方法去计算eden的值，具体就不一个一个细说了。即使不详细看方法内容，光从eden_increment_with_supplement_aligned_up、eden_decrement_aligned_down这些明显含有“increment”、“decrement”的方法名字，也可以回答“内存区域扩容之后还会再缩小吗？”这个问题了。
PS：如果对这个确实感兴趣，可以加个PrintAdaptiveSizePolicy，在每次重新计算内存区域大小时输出一些信息看看。
PSS：我把自己的理解写完了，但也木有搞清楚PS收集器eden的大小计算，和TLAB分配的联系在哪里，请R大继续讲解。
<img src="" alt="Spinner"></p>
<p><img src="" alt=""> <a href="http://hllvm.group.iteye.com/group/topic/38293/post/new" target="_blank">发表回复</a></p>
<p><a href="http://hllvm.group.iteye.com/" target="_blank">&gt;&gt;返回群组首页</a></p>
<p><a href="http://hllvm.group.iteye.com/" target="_blank"><img src="&quot;高级语言虚拟机: 关注各种高级语言虚拟机（high-level language virtual machine，HLL VM）的设计与实现，泛化至各种高级语言的运行时的设计与实现。讨论范围包括JVM、CLI、Parrot等当前流行的VM平台，也包括Python、Ruby、JavaScript、Lua、Perl、Forth、Smalltalk等众多语言的引擎，还有历史上有影响的各种高级语言虚拟机，如SECD等。&quot;" alt="高级语言虚拟机群组"></a></p>
<h3 id="-">相关讨论</h3>
<ul>
<li><a href="http://www.iteye.com/topic/802638" target="_blank">JVM内存管理：深入垃圾收集器与内存分配策略</a></li>
<li><a href="http://www.iteye.com/topic/976522" target="_blank">java内存管理以及GC</a></li>
<li><a href="http://www.iteye.com/topic/894148" target="_blank">HotSpot VM 内存堆的两个Servivor区</a></li>
<li><a href="http://www.iteye.com/topic/814815" target="_blank">jvm crash,疑似GC的bug</a></li>
<li><a href="http://www.iteye.com/topic/730461" target="_blank">借助HotSpot SA来一窥PermGen上的对象</a></li>
<li><a href="http://www.iteye.com/" target="_blank">首页</a></li>
<li><a href="http://www.iteye.com/news" target="_blank">资讯</a></li>
<li><a href="http://www.iteye.com/magazines" target="_blank">精华</a></li>
<li><a href="http://www.iteye.com/forums" target="_blank">论坛</a></li>
<li><a href="http://www.iteye.com/ask" target="_blank">问答</a></li>
<li><a href="http://www.iteye.com/blogs" target="_blank">博客</a></li>
<li><a href="http://www.iteye.com/blogs/subjects" target="_blank">专栏</a></li>
<li><a href="http://www.iteye.com/groups" target="_blank">群组</a></li>
<li><a href="http://job.iteye.com/iteye" target="_blank">招聘</a></li>
<li><a href="http://www.iteye.com/search" target="_blank">搜索</a></li>
<li><a href="http://hllvm.group.iteye.com/index/service" target="_blank">广告服务</a></li>
<li><a href="http://webmaster.iteye.com/" target="_blank">ITeye黑板报</a></li>
<li><a href="http://hllvm.group.iteye.com/index/contactus" target="_blank">联系我们</a></li>
<li><a href="http://hllvm.group.iteye.com/index/friend_links" target="_blank">友情链接</a></li>
</ul>
<p>© 2003-2012 ITeye.com. [ <a href="http://www.miibeian.gov.cn/" target="_blank">京ICP证110151号</a> 京公网安备110105010620 ]
百联优力(北京)投资有限公司 版权所有 <img src="http://stat.iteye.com/?url=http%3A%2F%2Fhllvm.group.iteye.com%2Fgroup%2Ftopic%2F38293&amp;referrer=http%3A%2F%2Fhllvm.group.iteye.com%2F&amp;user_id=" alt=""></p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/JVM/">JVM</a></li></span></span> | <span class="tags">Tagged <a href="/tags/JVM/" class="label label-primary">JVM</a><a href="/tags/Java&J2EE/" class="label label-success">Java&J2EE</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:42"datetime="2014-03-07 09:54:42"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-JVM--eden区没有发生minorgc，对象直接分配在了oldgen/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-JVM--eden区没有发生minorgc，对象直接分配在了oldgen" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--JVM调优总结（五）-分代垃圾回收详述1/">JVM调优总结（五）</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:42.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--JVM调优总结（五）-分代垃圾回收详述1/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="jvm-1">JVM调优总结（五）-分代垃圾回收详述1</h1>
<h2 id="-">为什么要分代</h2>
<pre><code>分代的垃圾回收策略，是基于这样一个事实：**不同的对象的生命周期是不一样的**。因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。



在Java程序运行的过程中，会产生大量的对象，其中有些对象是与业务信息相关，比如Http请求中的Session对象、线程、Socket连接，这类对象跟业务直接挂钩，因此生命周期比较长。但是还有一些对象，主要是程序运行过程中生成的临时变量，这些对象生命周期会比较短，比如：String对象，由于其不变类的特性，系统会产生大量的这些对象，有些对象甚至只用一次即可回收。



试想，在不进行对象存活时间区分的情况下，每次垃圾回收都是对整个堆空间进行回收，花费时间相对会长，同时，因为每次回收都需要遍历所有存活对象，但实际上，对于生命周期长的对象而言，这种遍历是没有效果的，因为可能进行了很多次遍历，但是他们依旧存在。因此，分代垃圾回收采用分治的思想，进行代的划分，把不同生命周期的对象放在不同代上，不同代上采用最适合它的垃圾回收方式进行回收。
</code></pre><h2 id="-">如何分代</h2>
<p><img src="" alt=""></p>
<p>如图所示：</p>
<pre><code>虚拟机中的共划分为三个代：**年轻代（Young Generation）、年老点（Old Generation）和持久代（Permanent Generation）**。其中持久代主要存放的是Java类的类信息，与垃圾收集要收集的Java对象关系不大。年轻代和年老代的划分是对垃圾收集影响比较大的。
</code></pre><p><strong>年轻代:</strong></p>
<pre><code>所有新生成的对象首先都是放在年轻代的。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。年轻代分三个区。一个Eden区，两个Survivor区(一般而言)。大部分对象在Eden区中生成。当Eden区满时，还存活的对象将被复制到Survivor区（两个中的一个），当这个Survivor区满时，此区的存活对象将被复制到另外一个Survivor区，当这个Survivor去也满了的时候，从第一个Survivor区复制过来的并且此时还存活的对象，将被复制“年老区(Tenured)”。需要注意，Survivor的两个区是对称的，没先后关系，所以同一个区中可能同时存在从Eden复制过来 对象，和从前一个Survivor复制过来的对象，而复制到年老区的只有从第一个Survivor去过来的对象。而且，Survivor区总有一个是空的。同时，根据程序需要，Survivor区是可以配置为多个的（多于两个），这样可以增加对象在年轻代中的存在时间，减少被放到年老代的可能。
</code></pre><p><strong>年老代:</strong></p>
<pre><code>在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。
</code></pre><p><strong>持久代:</strong></p>
<pre><code>用于存放静态文件，如今Java类、方法等。持久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些class，例如Hibernate等，在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中新增的类。持久代大小通过-XX:MaxPermSize=&lt;N&gt;进行设置。
</code></pre><h2 id="-">什么情况下触发垃圾回收</h2>
<pre><code>由于对象进行了分代处理，因此垃圾回收区域、时间也不一样。GC有两种类型：**Scavenge GC**和**Full GC**。
</code></pre><p><strong>Scavenge GC</strong></p>
<pre><code>一般情况下，当新对象生成，并且在Eden申请空间失败时，就会触发Scavenge GC，对Eden区域进行GC，清除非存活对象，并且把尚且存活的对象移动到Survivor区。然后整理Survivor的两个区。这种方式的GC是对年轻代的Eden区进行，不会影响到年老代。因为大部分对象都是从Eden区开始的，同时Eden区不会分配的很大，所以Eden区的GC会频繁进行。因而，一般在这里需要使用速度快、效率高的算法，使Eden去能尽快空闲出来。
</code></pre><p><strong>Full GC</strong></p>
<pre><code>对整个堆进行整理，包括Young、Tenured和Perm。Full GC因为需要对整个对进行回收，所以比Scavenge GC要慢，因此应该尽可能减少Full GC的次数。在对JVM调优的过程中，很大一部分工作就是对于FullGC的调节。有如下原因可能导致Full GC：
</code></pre><p>· 年老代（Tenured）被写满</p>
<p>· 持久代（Perm）被写满 </p>
<p>· System.gc()被显示调用 </p>
<p>·上一次GC之后Heap的各域分配策略动态变化</p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/JVM/">JVM</a></li></span></span> | <span class="tags">Tagged <a href="/tags/JVM/" class="label label-primary">JVM</a><a href="/tags/Java&J2EE/" class="label label-success">Java&J2EE</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:42"datetime="2014-03-07 09:54:42"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-JVM--JVM调优总结（五）-分代垃圾回收详述1/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-JVM--JVM调优总结（五）-分代垃圾回收详述1" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>





<ul id="pagination" class="pagination pagination-lg">
  <li><a class="extend prev" href="/page/48/">&laquo;</a></li><li><a class="page-number" href="/">1</a></li><li><a class="page-number" href="/page/2/">2</a></li><li><span class="space">&hellip;</span></li><li><a class="page-number" href="/page/46/">46</a></li><li><a class="page-number" href="/page/47/">47</a></li><li><a class="page-number" href="/page/48/">48</a></li><li class="active"><li><span class="page-number current">49</span></li><li><a class="page-number" href="/page/50/">50</a></li><li><a class="page-number" href="/page/51/">51</a></li><li><a class="page-number" href="/page/52/">52</a></li><li><span class="space">&hellip;</span></li></li><li><a class="page-number" href="/page/164/">164</a></li><li><a class="page-number" href="/page/165/">165</a></li><li><a class="extend next" href="/page/50/">&raquo;</a></li>
  <div class="clearfix"></div>
</ul></div><!--wapper-->
       </div><!-- ID main-col END -->
       <aside id="sidebar" class="alignright col-sx-6 col-sm-4 col-md-3 col-lg-3">
<div id="widget_search" class="widget panel panel-primary">
    <form action="//google.com/search" method="get" accept-charset="utf-8">
  <div class="input-group">
    <input class="form-control" id="searchbox" type="search" name="q" results="0" placeholder="search">
    <span class="input-group-btn">
      <button class="btn btn-default" type="submit">Go!</button>
    </span>
    <input type="hidden" name="q" value="site:itsolife.com">
  </div>
</form>
</div>

<div id="widget_category" class="widget panel panel-primary">
  <div class="panel-heading">category</div>  <div data-src='category' class='ajax_widgets'>正在加载...</div>
</div>

<div id="widget_recent_posts" class="widget panel panel-primary">
  <div class="panel-heading">recent posts</div>  <div data-src='recent_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_tagcloud" class="widget panel panel-primary">
  <div class="panel-heading">tagcloud</div>  <div data-src='tagcloud' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_latest_update_posts" class="widget panel panel-primary">
  <div class="panel-heading">最近更新</div>  <div data-src='latest_update_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_recent_comments" class="widget panel panel-primary">
  <div class="panel-heading">recent comments</div>  

<div class="list-group-item ds-recent-comments" data-num-items="6" data-show-avatars="1" data-show-time="1" data-show-title="1" data-show-admin="1" data-excerpt-length="50"></div>



</div>

</aside>
       <div class="clearfix"></div>
     </div><!-- row END -->
  </div>
  <footer id="footer" class="container">
  <div class="panel panel-info">
  <section id='footer_widget'></section>  <div class="panel-footer">
  <div id="site-info">
    <span class='author'>
  
  &copy; 2014 RobinChia
  
    &nbsp;&nbsp;</span>
  
  <span id='analytics-51la'></span><span id='analytics-google'>
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-48559895-1']);
  _gaq.push(['_trackPageview']);
  _js2load.push({src:('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'});
</script></span><span id='analytics-cnzz'>
<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_5774006'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s17.cnzz.com/stat.php%3Fid%3D5774006%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>
</span><span id='analytics-baidu'>
<script>
var _hmt = _hmt || [];
_js2load.push({src:"//hm.baidu.com/hm.js?1442f50724afc42380b51f097c43082c"});
</script>
</span>  </div>
  <div id="copyright">Blog powered by <a href='http://zespia.tw/hexo/'><strong>hexo</strong></a> Theme <strong><a href='https://github.com/chenall/hexo-theme-chenall'>chenall</a></strong>(Some change in it)<span class="pull-right"> 更新时间: <em>2014-03-15 20:45:44</em></span></div>
</div>
<div class="clearfix"></div>


  </div>
  </footer>
  
        <script src="http://cdn.bootcss.com/jquery/1.10.2/jquery.min.js"></script>        
        <script src="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/js/bootstrap.min.js"></script>        
                
        <script src="http://cdn.bootcss.com/prettify/r298/prettify.min.js"></script>    <script type="text/javascript">
   var lang=["bsh", "c", "cc", "cpp", "cs", "csh", "cyc", "cv", "htm", "html",
    "java", "js", "m", "mxml", "perl", "pl", "pm", "py", "rb", "sh",
    "xhtml", "xml", "xsl"];
   var pretty_base='';
   $('script').each(function(){
	var c = $(this).attr('src');
	if (!c)
	    return;
	if (c.match(/(\/)?prettify(\.min)?\.js/i))
	{
	    var index = c.lastIndexOf('/');
	    if (index != -1)
		pretty_base = c.substr(0,index + 1);
	    return false;
	}
   })
   $('pre code').each(function(){
	var c = $(this).attr('class')
	if (!c)
	    return;
	c = c.match(/\s?(lang\-\w+)/i);
	if (c && lang.indexOf(c[1]) == -1)
	{
	    lang.push(c[1]);
	    $.getScript(pretty_base + c[1] + '.min.js');
	}
   })

    $(window).load(function(){
       $("pre").addClass("prettyprint");
       prettyPrint();
    })
</script>    
            <script type="text/javascript">
var duoshuoQuery = {short_name:"robinchia"};
_js2load.push({src:'http://static.duoshuo.com/embed.js',charset:'UTF-8'});
</script>
    
            <!--wumii_relatedItems-->
    
        <script src="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js"></script>    <script type="text/javascript">
(function($){
  $('.entry').each(function(i){
    $(this).find('img').each(function(){
      var alt = this.alt;

      if (alt){
        $(this).before('<span class="caption">' + alt + '</span>');
      }

      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox" rel="fancybox' + i + '" />');
    });
  });

  $('.fancybox').fancybox();
})(jQuery);
</script>    
        <script src="http://cdn.bootcss.com/mathjax/2.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>    <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>
    
<script type="text/javascript">
$('.ajax_widgets').each(function(){var src=$(this).attr('data-src');if(src)$(this).load('/widgets/'+src+'.html');});
$.each(_js2load,function(index,obj){loadjs(obj.src,obj.charset)});
</script>

<div id="scroll2top">
<img src="/scroll2top/arrow.png"/>
</div>
<script src="/scroll2top/scroll2top.min.js"></script>
<div id="winterland">
  <canvas></canvas>
</div>
<script src="/js/winterland.min.js"></script>

  </body>
</html>
