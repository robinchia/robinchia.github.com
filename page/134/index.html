
<!DOCTYPE HTML>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>The 134 Page | It so life</title>
<meta name="author" content="RobinChia">

<meta name="description" content="It so life">


<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<meta property="og:site_name" content="It so life"/>

<!--[if IE]><style>.testIE.IE{display:inline;}</style><![endif]-->
<!--[if lte IE 7]><link rel="stylesheet" href="/css/ie7.css" type="text/css"><![endif]-->
<!--[if (lt IE 9)&(gt IE 7)]><style>.testIE.IE8{display:inline;}</style><![endif]-->
<!--[if gt IE 8]><style>.testIE.IE9{display:inline;}</style><![endif]-->

<link href="/favicon.png" rel="icon">
<link rel="alternate" href="/atom.xml" title="It so life Feed" type="application/atom+xml">

<link rel="stylesheet" href="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/css/bootstrap.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/font-awesome/4.0.3/css/font-awesome.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/prettify/r298/prettify.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" type="text/css">
<link rel="stylesheet" href="/css/style.css" type="text/css">
<!--[if lt IE 9]>
   <style>article,aside,dialog,footer,header,section,footer,nav,figure,menu{display:block}</style>
   <script src="http://cdn.staticfile.org/html5shiv/r29/html5.min.js"></script>
   <script src="http://cdn.staticfile.org/respond.js/1.4.2/respond.min.js"></script>
<link href="http://cdn.staticfile.org/respond.js/1.4.2/respond-proxy.html" id="respond-proxy" rel="respond-proxy" />
<link href="/js/respond.proxy.gif" id="respond-redirect" rel="respond-redirect" />
<script src="/js/respond.proxy.js"></script>
   <script src="http://cdn.bootcss.com/selectivizr/1.0.2/selectivizr-min.js"></script>
<![endif]-->
<script type="text/javascript">
function loadjs(c,d){var a=document.createElement("script");a.async=!0;a.type="text/javascript";a.src=c;a.charset=d||"gbk";(document.getElementsByTagName("HEAD")[0]||document.getElementsByTagName("BODY")[0]).appendChild(a)};
var _protocol = (("https:" == document.location.protocol) ? " https://" : " http://");
var _js2load = [];
</script>

</head>
<body>
      <header id="header" class="container"><nav id="main-nav" class="navbar navbar-default navbar-fixed-top " role="navigation">
  <div class="container">
    <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
      <span class="sr-only">Toggle navigation</span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="/">It so life</a>
    </div>
    <div  class="collapse navbar-collapse">
      <ul  class="nav navbar-nav">
  
        <li><a href="/" title="Home">Home</a></li>      
        <li><a href="/about/" title="About">About</a></li>      
        <li><a href="/archives/" title="Archives">Archives</a></li>      
      <li class='dropdown'>
        <a class='dropdown-toggle' data-toggle='dropdown' href='#'>website<b class='caret'></b></a>
        <ul class='dropdown-menu pure-menu-selected'>
    
          <li><a href="//groups.google.com/forum/#!forum/pongba" title="TopLanguage">TopLanguage</a></li>    
          <li><a href="//itpub.net/" title="ITPub">ITPub</a></li>    
          <li><a href="//blog.jobbole.com/" title="Bole">Bole</a></li>    
          <li><a href="//nosql-database.org/" title="nosql">nosql</a></li>    
          <li><a href="//gitimmersion.googol.im/" title="Git">Git</a></li>    
        </ul>
      </li>
    
      </ul>
      <ul class="nav navbar-nav navbar-right">
      
        <li><a href="/atom.xml">RSS</a></li>
      
      
        <li><a href="https://twitter.com/robinchia">twitter</a></li>
      
      
      
      
        <li><a href="https://github.com/robinchia">github</a></li>
      
      </ul>
    </div>
  </div>
</nav>
<div class="clearfix"></div>
</header>
  <div id='content' class="container">
     <div class="page-header-wrapper">
      <!--[if lt IE 9]><div class="alert alert-warning alert-dismissable"><button type="button" class="close" data-dismiss="alert" aria-hidden="true">&times;</button><strong>提示:</strong>您的浏览器版本太低了,建议升级到 <strong><a href="http://windows.microsoft.com/zh-cn/internet-explorer/download-ie" title="IE9">IE9</a></strong> 以上,本站使用<a href="https://www.google.com/intl/zh-CN/chrome/">Chrome浏览器</a>可以获得最好的显示效果.</div><![endif]-->
      <div class="page-header"><h1 align="center"><big>It so life</big> </h1>
        <h5 align="center"><big>love as life</big></h5>
      </div>
     </div>
     <div class="row">
       <div id="main-col" class="alignleft col-sx-12 col-sm-8 col-md-9 col-lg-9">
      <section id='header_widget'></section>
          <div id="wrapper"><article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-百万级访问网站前期的技术准备/">百万级访问网站前期的技术准备 </a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:32.000Z"> <a href="/2014/02/02/2014-02-02-百万级访问网站前期的技术准备/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h3 id="-"><a href="">百万级访问网站前期的技术准备</a> **</h3>
<p><strong>博客分类：</strong></p>
<ul>
<li><a href="http://zz563143188.iteye.com/category/269712" target="_blank">web</a>
<a href="http://www.iteye.com/blogs/tag/%E7%99%BE%E4%B8%87%E7%BA%A7%E8%AE%BF%E9%97%AE%E7%BD%91%E7%AB%99%E5%89%8D%E6%9C%9F%E7%9A%84%E6%8A%80%E6%9C%AF%E5%87%86%E5%A4%87" target="_blank">百万级访问网站前期的技术准备</a></li>
</ul>
<p>开了自己域名的博客，第一篇就得来个重磅一点的才对得起这4美金的域名。作为一个技术从业者十年，逛了十年发现有些知识东一榔头西一棒槌的得满世界 看个遍才整理出个头绪，那咱就系统点的从头一步一步的说，一个从日几千访问的小小网站，到日访问一两百万的小网站，怎么才能让它平滑的度过这个阶段，别在 技术上出现先天不足，写给一些技术人员，也写给不懂技术的创业者。
对互联网有了解的人都有自己的想法，有人就把想法付诸实现，做个网站然后开始运营。其实从纯网站技术上来说，因为开源模式的发展，现在建一个小网站 已经很简单也很便宜。当访问量到达一定数量级的时候成本就开始飙升了，问题也开始显现了。因为带宽的增加、硬件的扩展、人员的扩张所带来的成本提高是显而 易见的，而还有相当大的一部分成本是因为代码重构、架构重构，甚至底层开发语言更换引起的，最惨的就是数据丢失，辛辛苦苦好几年，一夜回到创业前。
减少成本就是增加利润。很多事情，我们在一开始就可以避免，先打好基础，往后可以省很多精力，少操很多心。
假设你是一个参与创业的技术人员，当前一穷二白，什么都要自己做，自己出钱，初期几十万的资金，做一个应用不是特别复杂的网站，那么就要注意以下几点：
一、开发语言
一般来说，技术人员（程序员）创业都是根据自己技术背景选择自己最熟悉的语言，不过考虑到不可能永远是您一个人写程序，这点还得仔细想想。无论用什么语言，最终代码质量是看管理，所以我们还是从纯语言层面来说实际一点。现在流行的java、php、.net、python、ruby都 有自己的优劣，python和ruby，现在人员还是相对难招一些，性能优化也会费些力气，.net平台买不起windows server。java、php用的还是最多。对于初期，应用几乎都是靠前端支撑的网站来说，php的优势稍大一些，入门简单、设计模式简单、写起来快、 性能足够等，不过不注重设计模式也是它的劣势，容易变得松散，隐藏bug稍多、难以维护。java的优势在于整套管理流程已经有很多成熟工具来辅助，强类 型也能避免一些弱智BUG，大多数JAVA程序员比较注重设计模式，别管实不实际，代码格式看起来还是不错的。这也是个劣势，初学者可能太注重模式而很难 解决实际需求。
前端不只是html、css这类。整个负责跟用户交互的部分都是前端，包括处理程序。这类程序还是建议用php，主要原因就是开发迅速、从业人员广泛。至于后端例如行为分析、银行接口、异步消息处理等，随便用什么程序，那个只能是根据不同业务需求来选择不同语言了。
二、代码版本管理
如果开发人员之间的网络速度差不多，就SVN；比较分散例如跨国，就hg。大多数人还是svn的.
假设选了svn，那么有几点考虑。一是采用什么树结构。初期可能只有一条主干，往后就需要建立分支，例如一条开发分支，一条上线分支，再往后，可能 要每个小组一个分支。建议一开始人少时选择两条分支，开发和线上，每个功能本地测试无误后提交到开发分支，最后统一测试，可以上线时合并到上线分支。如果 喜欢把svn当做移动硬盘用，写一点就commit一次也无所谓，就是合并的时候头大一些，这些人可以自己建个分支甚至建立个本地代码仓库，随便往自己的 分支提交，测试完毕后再提交到开发分支上。
部署，可以手工部署也可以自动部署。手工部署相对简单，一般是直接在服务器上svn update，或者找个新目录svn checkout，再把web root给ln -s过去。应用越复杂，部署越复杂，没有什么统一标准，只要别再用ftp上传那种形式就好，一是上传时文件引用不一致错误率增加，二是很容易出现开发人员 的版本跟线上版本不一致，导致本来想改个错字结果变成回滚的杯具。如果有多台服务器还是建议自动部署，更换代码的机器从当前服务池中临时撤出，更新完毕后 再重新加入。
不管项目多小，养成使用版本管理的好习惯，最起码还可以当做你的备份，我的 <a href="http://zhiyi.us" target="_blank">http://zhiyi.us</a> 虽然就是一个wordpress，可还是svn了，只改动一两句css那也是劳动成果。
三、服务器硬件
别羡慕大客户和有钱人，看看机房散户区，一台服务器孤独的支撑的网站数不清。如果资金稍微充足，建议至少三台的标准配置，分别用作web处理、数据 库、备份。web服务器至少要8G内存，双sata raid1，如果经济稍微宽松，或静态文件或图片多，则15k sas raid1+0。数据库至少16G内存，15k sas raid 1+0。备份服务器最好跟数据库服务器同等配置。硬件可以自己买品牌的底板，也就是机箱配主板和硬盘盒，CPU内存硬盘都自己配，也可以上整套品牌，也可 以兼容机。三台机器，市场行情6、7万也就配齐了。
web服务器可以既跑程序又当内存缓存，数据库服务器则只跑主数据库（假如是MySQL的话），备份服务器干的活就相对多一些，web配置、缓存配置、数据库配置都要跟前两台一致，这样WEB和数据库任意一台出问题，把备份服务器换个ip就切换上去了。备份策略，可以drbd，可以rsync，或者其他的很多很多的开源备份方案可选择。rsync最简单，放cron里自己跑就行。备份和切换，建议多做测试，选最安全最适合业务的，并且尽可能异地备份。
四、机房
三种机房尽量不要选：联通访问特别慢的电信机房、电信访问特别慢的联通机房、电信联通访问特别慢的移动或铁通机房。那网通机房呢？亲，网通联通N久 以前合并改叫联通了。多多寻找，实地参观，多多测试，多方打探，北京、上海、广州等各个主节点城市，还是有很多优质机房的，找个网络质量好，管理严格的机 房，特别是管理要严格，千万别网站无法访问了，打个电话过去才知道别人维护时把你网线碰掉了，这比DOS都头疼。自己扯了几根光纤就称为机房的，看您抗风 险程度和心理素质了。机房可以说是非常重要，直接关系到网站访问速度，网站访问速度直接关系到用户体验，我可以F墙看风景，但买个网游vpn才能打开你这 个还不怎么知名的网站就有难度了。或许您网站的ajax很出色，可是document怎么也不ready，一些代码永远绝缘于用户。
五、架构
初期架构一般比较简单，web负载均衡+数据库主从+缓存+分布式存储+队列。大方向上也确实就这几样东西，细节上也无数文章都重复过了，按照将来 会有N多WEB，N多主从关系，N多缓存，N多xxx设计就行，基本方案都是现成的，只是您比其他人厉害之处就在于设计上考虑到缓存失效时的雪崩效应、主 从同步的数据一致性和时间差、队列的稳定性和失败后的重试策略、文件存储的效率和备份方式等等意外情况。缓存总有一天会失效，数据库复制总有一天会断掉， 队列总有一天会写不进去，电源总有一天会烧坏。根据墨菲定律，如果不考虑这些，网站早晚会成为茶几。
六、服务器软件
Linux、nginx、php、mysql，几乎是标配，我们除了看名字，还得选版本。Linux发行版众多，只要没特殊要求，就选个用的人最多的，社区最活跃的，配置最方便的，软件包最全最新的，例如debian、ubuntu。 至于RHEL之类的嘛，你用只能在RHEL上才能运行的软件么？剩下的nginx、php、mysql、activemq、其他的等等，除非你改过这些软 件或你的程序真的不兼容新版本，否则尽量版本越新越好，版本新，意味着新特性增多、BUG减少、性能增加。总有些道听途说的人跟你说老的版本稳定。所谓稳 定，是相对于特殊业务来说的，而就一个php写的网站，大多数人都没改过任何服务器软件源代码，绝大多数情况是能平稳的升级到新版本的。类似于jdk5到 jdk6，python2到python3这类变动比较大的升级还是比较少见的。看看ChangeLog，看看升级说明，结合自己情况评估一下，越早升级 越好，别人家都用php6写程序了这边还php4的逛游呢。优秀的开源程序升级还是很负责任的，看好文档，别怕。
以上这六点准备完毕，现在我们有了运行环境，有了基本架构骨架，有了备份和切换方案，应该开始着手设计开发方面的事情了。开发方面的事情无数，下一篇会先说一些重点。
原文地址
七、数据库
几乎所有操作最后都要落到数据库身上，它又最难扩展（存储也挺难）。对于mysql，什么样的表用myisam，什么样的表用innodb，在开发 之前要确定。复制策略、分片策略，也要确定。表引擎方面，一般，更新不多、不需要事务的表可以用myisam，需要行锁定、事务支持的，用innodb。 myisam的锁表不一定是性能低下的根源，innodb也不一定全是行锁，具体细节要多看相关的文档，熟悉了引擎特性才能用的更好。现代WEB应用越来 越复杂了，我们设计表结构时常常设计很多冗余，虽然不符合传统范式，但为了速度考虑还是值得的，要求高的情况下甚至要杜绝联合查询。编程时得多注意数据一 致性。
复制策略方面，多主多从结构也最好一开始就设计好，代码直接按照多主多从来编写，用一些小技巧来避免复制延时问题，并且还要解决多数据库数据是否一致，可以自己写或者找现成的运维工具。
分片策略。总会有那么几个表数据量超大，这时分片必不可免。分片有很多策略，从简单的分区到根据热度自动调整，依照具体业务选择一个适合自己的。避免自增ID作为主键，不利于分片。
用存储过程是比较难扩展的，这种情形多发生于传统C/S，特别是OA系统转换过来的开发人员。低成本网站不是一两台小型机跑一个数据库处理所有业务的模式，是机海作战。方便水平扩展比那点预分析时间和网络传输流量要重要的多的多。
NoSQL。这只是一个概念。实际应用中，网站有着越来越多的密集写操作、上亿的简单关系数据读取、热备等，这都不是传统关系数据库所擅长的，于是 就产生了很多非关系型数据库，比如Redis/TC&amp;TT/MongoDB/Memcachedb等，在测试中，这些几乎都达到了每秒至少一万次 的写操作，内存型的甚至5万以上。例如MongoDB，几句配置就可以组建一个复制+自动分片+failover的环境，文档化的存储也简化了传统设计库 结构再开发的模式。很多业务是可以用这类数据库来替代mysql的。
八、缓存。
数据库很脆弱，一定要有缓存在前面挡着，其实我们优化速度，几乎就是优化缓存，能用缓存的地方，就不要再跑到后端数据库那折腾。缓存有持久化缓存、 内存缓存，生成静态页面是最容易理解的持久化缓存了，还有很多比如varnish的分块缓存、前面提到的memcachedb等，内存缓 存，memcached首当其冲。缓存更新可用被动更新和主动更新。被动更新的好处是设计简单，缓存空了就自动去数据库取数据再把缓存填上，但容易引发雪 崩效应，一旦缓存大面积失效，数据库的压力直线上升很可能挂掉。主动缓存可避免这点但是可能引发程序取不到数据的问题。这两者之间如何配合，程序设计要多 动脑筋。
九、队列。
用户一个操作很可能引发一系列资源和功能的调动，这些调动如果同时发生，压力无法控制，用户体验也不好，可以把这样一些操作放入队列，由另几个模块 去异步执行，例如发送邮件，发送手机短信。开源队列服务器很多，性能要求不高用数据库当做队列也可以，只要保证程序读写队列的接口不变，底层队列服务可随 时更换就可以，类似Zend Framework里的Zend_Queue类，java.util.Queue接口等。
十、文件存储。
除了结构化数据，我们经常要存放其他的数据，像图片之类的。这类数据数量繁多、访问量大。典型的就是图片，从用户头像到用户上传的照片，还要生成不 同的缩略图尺寸。存储的分布几乎跟数据库扩展一样艰难。不使用专业存储的情况下，基本都是靠自己的NAS。这就涉及到结构。拿图片存储举例，图片是非常容 易产生热点的，有些图片上传后就不再有人看，有些可能每天被访问数十万次，而且大量小文件的异步备份也很耗费时间。
为了将来图片走cdn做准备，一开始最好就将图片的域名分开，且不用主域名。很多网站都将cookie设置到了.domain.ltd，如果图片也在这个域名下，很可能因为cookie而造成缓存失效，并且占多余流量，还可能因为浏览器并发线程限制造成访问缓慢。
如果用普通的文件系统存储图片，有一个简单的方法。计算文件的hash值，比如md5，以结果第一位作为第一级目录，这样第一级有16个目录。从0 到F，可以把这个字母作为域名，0.yourimg.com到f.yourimg.com（客户端dns压力会增大），还可以扩展到最多16个NAS集群 上。第二级可用年月例如，201011，第三级用日，第四级可选，根据上传量，比如am/pm，甚至小时。最终的目录结构可能会是 e/201008/25/am/e43ae391c839d82801920cf.jpg。rsync备份时可以用脚本只同步某年某日某时的文件，避免计 算大量文件带来的开销。当然最好是能用专门的分布式文件系统或更专业点的存储解决方案。
下面，我们要谈谈代码了。
这一系列的最后一篇写给普通编程人员，如果不感兴趣可直接看本文最后几段。开始设计代码结构之前，先回顾一下之前准备过的事情：我们有负载均衡的 WEB服务器，有主从DB服务器并可能分片，有缓存，有可扩展的存储。在组织代码的各个方面，跟这些准备息息相关，我一二三的列出来分别说，并且每一条都 以“前面讲到”这个经典句式开头，为了方便对照。
别着急看经典句式，我思维跳跃了，插一段。实际开发中，我们总会在性能和代码优雅性上作折中。对于当今的计算机和语言解释器，多几层少几层对象调 用、声明变量为Map还是HashMap这种问题是最后才需要考虑的问题，永远要考虑系统最慢的部分，从最慢的部分解决。例如看看你用的ORM是不是做了 很多你用不到的事情，是不是有重复的数据调用。我们做的是web应用开发，不是底层框架API，代码易读易懂是保证质量很重要的一方面，你的程序是为了什 么而设计，有不同的方法……算了，这个话题另起一篇文章来说，扯远了，想交流可关注我的微博 <a href="http://t.sina.com.cn/liuzhiyi，咱继续……" target="_blank">http://t.sina.com.cn/liuzhiyi，咱继续……</a>
前面讲到，WEB 服务器是要做负载均衡的，图片服务器是要分开的。对于这点，代码在处理客户端状态时，不要把状态放到单机上，举例，不要用文件session，嗯，常识。 如果有可能，最好在一开始就做好用户单点认证的统一接口，包括跨域如何判断状态、静态页面如何判断状态，需要登录时的跳转和返回参数定义，底层给好接口， 应用层直接就用（可参考GAE的 user服务）。登录方面的设计要考虑移动设备的特性，比如电脑可以用浮动层窗口，但NOKIA自带的浏览器或UCWEB就无法处理这种表现形式，程序一 定既能处理AJAX请求又能直接通过URL来处理请求。图片服务器分开，资源文件最好也布局到图片服务器，也就是WEB服务器只服务动态程序。虽然开发测 试时稍微复杂（因为需要绝对URI才能访问），但将来页面前端优化上会轻松许多，并且你的WEB服务器IO优化也轻松许多。程序引用资源文件时，要有一个 统一的处理方法，在方法内部可以自动完成很多事情，例如将css/js根据组合，拼成一个文件，或者自动在生成的URI后面加上QUERYSTRING， 如果将来前端用了缓存服务，那生成QUERYSTRING是最简单的刷新服务端缓存和客户端缓存的办法。
前面讲到， 数据库会有复制，可能会多主多从，可能会分片。我们程序在处理数据的过程中，最好能抽象出来单独放做一层。拿现在流行的MVC模式来说，就是在M层下方再 放一个数据层，这个数据层不是通常所说的JDBC/PDO/ActiveRecord等，而是你自己的存取数据层，仅对外暴露方法，隐藏数据存取细节。这 个数据层内部不要怕写的难看，但一定要提供所有的数据存储功能，其他任何层次不要看到跟数据库打交道的字眼。之所以这样做，是因为在单关系数据库的情况 下，可能会SELECT…JOIN…或直接INSERT…INTO…，可你可能会将一些表放到key-value数据库里存储，或者分片，这么做之后原来 的语句和方式要全部改变，如果过于分散，则移植时会耗费很大精力，或得到一个很大的Model。在数据层面的设计上，尽量避免JOIN查询，我们可以多做 冗余，多做缓存，每种数据尽量只需要一次查询，然后在你的程序里面进行组合。对于比较复杂的数据组合，在实时性要求不高的情况下，可采用异步处理，用户访 问时只取处理后的结果。在对于主键的处理上，避免使用自增ID，可以用一定规则生成的唯一值当做主键，这种主键是最简单的分片分布策略。即使用自增ID， 也最好用一个自增ID发生器，否则从数据库不小心被写了一下，那主键很容易冲突。
前面讲到，咱数据库前面还有某些缓存挡着。别把 mysql的query cache当缓存，应用稍复杂的时候QUERY CACHE反而会成为累赘。缓存跟数据库和业务结合的很紧密，正因为跟业务关系紧密，所以这点没有放之四海而皆准的方法。但我们还是有一些规则可参照。规 则一：越接近前端，缓存的颗粒度越大。例如在WEB最前端缓存整个页面，再往后一层缓存部分页面区域，再往后缓存区域内的单条记录。因为越靠近后端，我们 的可操作性越灵活，并且变化最多的前端代码也比较方便编写。在实践中，因为产品需求变化速度非常快，迭代周期越来越短，有时很难将Controller和 Model分的那么清楚，Controller层面处理部分缓存必不可免，但要保证如果出现这种情况，Controller所操作的缓存一定不要影响其他 数据需求方，也就是要保证这个缓存数据只有这一个Controller在用。规则二：没有缓存时程序不能出错。在不考虑缓存失效引发的雪崩效应时，你的程 序要有缓存跟没缓存一个样，不能像新浪微博一样，缓存一失效，粉丝微博全空，整个应用都乱套了。在缓存必不可少的情况下，给用户出错信息都比给一个让人误 解的信息强。规则三，缓存更新要保证原子性或称作线程安全，特别是采用被动缓存的方式时，很可能两个用户访问时导致同一个缓存被更新，通常情况这不是大问 题，可缓存失效后重建时很可能是引发连锁反应的原因之一。规则四：缓存也是有成本的。不只是技术成本，还有人工时间成本。如果一个功能使用缓存和不使用， 在可预见的访问量情况下区别微小，但使用缓存会使复杂度增加，那就不用，我们可以加个TODO标注，在下次迭代的时候加上缓存处理。
前 面讲到，文件存储是独立的，那么所有的文件操作就都是远程调用。可以在文件服务器上提供一个很简单的RESTful接口，也可以提供xmlrpc 或json serveice，WEB服务器端所生成和处理的文件，全部通过接口通知文件服务器去处理，WEB服务器本身不要提供任何文件存储。你会发现很多大网站的 上传图片跟保存文章是分两步完成的，就是基于这个原因。
以上几条“前面讲到”，其实无数人都讲过，我也只是结合前几篇文章用自己的话重 复了一遍，真正分析起来精髓很简单——除了良好的功能逻辑分层，我们 还要为数据库存储、缓存、队列、文件服务等程序外层资源调用单独设计接口，你可以把你的程序想象成是运行在 Amazon EC2 上并用他的所有web service服务，你的数据库就是它的SimpleDB，你的队列就是他的SQS，你的存储就是他的S3，唯一不同是amazon的接口是远程调用，你的是内部调用。
将支撑服务接口化，意味着将MySQL更换到PostgreSQL不需要更改业务处理程序，移植团队甚至不需要跟业务开发团队过多沟通；意味着业务开发团队是对接口编程而不是对数据库编程；意味着不会因为某个业务开发人员的失误而拖垮性能。
对程序扫盲不感兴趣的直接看这里——
产 品设计完了，程序框架搭完了，可能有矛盾在这个节骨眼儿产生了。不断有产品设计抱怨说他的创意没实现到预期效果，有程序员抱怨说产品设计不切实 际。这种抱怨多缘于产品人员不懂技术，技术人员不理解产品。从广义上来讲，产品包含市场策略、营销手段、功能设计，产品和技术在争论时往往把焦点放在功能 上，而实际重点是，实现这个功能所消耗的成本跟能这个功能带来的利益能否换算，能否取其轻重。若可以，争议解决。若不能，则抛硬币看运气。因为一个功能的 加强而引发指标井喷，或因项目拖延而导致贻误战机的例子比比皆是。激进的决策者注重利益，保守的决策者注重损失，聪明的决策者会考虑这个问题是否真的那么 严重。
关系到未来的事情谁都说不准，要不怎么说创业一半靠运气呢。不过总有能说的准的事情，那就得靠数据说话。
没有100%也有99.9%的网站安装了访问统计代码，连我的 <a href="http://zhiyi.us" target="_blank">http://zhiyi.us</a> 也不例外，新闻联播也总说科学决策科学发展的。有了统计，能确定的事情就很多了。例如，可以根据来源-目标转化率来分析哪类渠道的人均获取成本低，根据来 源-内容访问猜测用户跳出率原因，根据用户点击行为判断链接位置是否合理等。将数据以不同方式组合起来，找到内在联系，分析内因外因，制定对应策略，减少 拍脑门决策。靠数据支撑运营是个非常专业的事情，虽然不懂深奥的数学模型不会复杂的公式计算，渐渐学会因为A所以B，因为A和B所以C还是相对简单的。
全系列完毕。老话，大半夜连抽烟带码字的挺伤身，转载请注明出处
文章来源： </p>
<hr>
<p><strong>企业级项目实战(带源码)地址**</strong>：**<a href="http://zz563143188.iteye.com/blog/1825168" target="_blank"><a href="http://zz563143188.iteye.com/blog/1825168">http://zz563143188.iteye.com/blog/1825168</a></a></p>
<p><strong>收集五年的开发资料下载地址：  <a href="http://pan.baidu.com/share/link?shareid=372668&amp;uk=4076915866#dir/path=%2F%E5%AD%A6%E4%B9%A0%E6%96%87%E4%BB%B6" title="http://pan.baidu.com/share/link?shareid=372668&amp;uk=4076915866" target="_blank"><a href="http://pan.baidu.com/share/link?shareid=372668&amp;uk=4076915866/#dir/path=%2F%E5%AD%A6%E4%B9%A0%E6%96%87%E4%BB%B6">http://pan.baidu.com/share/link?shareid=372668&amp;uk=4076915866/#dir/path=%2F%E5%AD%A6%E4%B9%A0%E6%96%87%E4%BB%B6</a></a></strong>
<a href="http://zhiyi.us/internet/thinking-twice-before-building-your-site-one.html" target="_blank">http://zhiyi.us/internet/thinking-twice-before-building-your-site-one.html</a>
<a href="http://zhiyi.us/internet/thinking-twice-before-building-your-site-two.html" target="_blank">http://zhiyi.us/internet/thinking-twice-before-building-your-site-two.html</a>
<a href="http://zhiyi.us/internet/thinking-twice-before-building-your-site-final.html" target="_blank">http://zhiyi.us/internet/thinking-twice-before-building-your-site-final.html</a></p>
<p>分享到： <a href="&quot;分享到新浪微博&quot;"><img src="" alt=""></a> <a href="&quot;分享到腾讯微博&quot;"><img src="" alt=""></a></p>
<p><a href="http://zz563143188.iteye.com/blog/1842141" title="主流服务器apache、IIS、tomcat、jboss、resin、weblogic、websphere的区别" target="_blank">主流服务器apache、IIS、tomcat、jboss、 ...</a> | <a href="http://zz563143188.iteye.com/blog/1842129" title="高性能网站性能优化与系统架构" target="_blank">高性能网站性能优化与系统架构</a></p>
<ul>
<li>2013-04-05 00:16</li>
<li>浏览 2751</li>
<li><a href="http://zz563143188.iteye.com/blog/1842135#comments" target="_blank">评论(14)</a></li>
<li>分类:<a href="http://www.iteye.com/blogs/category/web" target="_blank">Web前端</a></li>
<li><a href="http://www.iteye.com/wiki/blog/1842135" target="_blank">相关推荐</a></li>
</ul>
<h3 id="-">评论</h3>
<p><a href=""></a></p>
<p>14 楼 <a href="http://shenfuli.iteye.com/" title="shenfuli" target="_blank">shenfuli</a> 3 小时前  </p>
<p>NB,需要加大学习。
13 楼 <a href="http://xyz5201314.iteye.com/" title="xyz5201314" target="_blank">xyz5201314</a> 2013-05-27  </p>
<p>好人一个。d一下。</p>
<p>12 楼 <a href="http://zz563143188.iteye.com/" title="zz563143188" target="_blank">zz563143188</a> 2013-04-28  </p>
<p>桃花源记 写道</p>
<p>这得多牛，才能总结出这么多知识啊！
有些只需要知道
11 楼 <a href="http://lxz2672282.iteye.com/" title="桃花源记" target="_blank">桃花源记</a> 2013-04-28  </p>
<p>这得多牛，才能总结出这么多知识啊！</p>
<p>10 楼 <a href="http://zz563143188.iteye.com/" title="zz563143188" target="_blank">zz563143188</a> 2013-04-18  </p>
<p>thrillerzw 写道</p>
<p>有些词不懂，看来我还得努力。<img src="" alt="">
厚积薄发，先把基础知识搞扎实。
9 楼 <a href="http://thrillerzw.iteye.com/" title="thrillerzw" target="_blank">thrillerzw</a> 2013-04-18  </p>
<p>有些词不懂，看来我还得努力。<img src="" alt=""></p>
<p>8 楼 <a href="http://zz563143188.iteye.com/" title="zz563143188" target="_blank">zz563143188</a> 2013-04-16  </p>
<p>tss0823 写道</p>
<p>看完了，我是一个字节看下去的，真心觉得不错，有些东西感同身受，当时无法用语言来描述，现在看了楼主的文章，才觉得那些东西我貌似也经历过。总之，谢谢。
可能实际中运用不到这么多知识，但这样可以让我们的知识全面。
7 楼 <a href="http://tss0823.iteye.com/" title="tss0823" target="_blank">tss0823</a> 2013-04-16  </p>
<p>看完了，我是一个字节看下去的，真心觉得不错，有些东西感同身受，当时无法用语言来描述，现在看了楼主的文章，才觉得那些东西我貌似也经历过。总之，谢谢。</p>
<p>6 楼 <a href="http://zz563143188.iteye.com/" title="zz563143188" target="_blank">zz563143188</a> 2013-04-13  </p>
<p>chenhjzn 写道</p>
<p><img src="" alt=""> 非常不错
多学习了解
5 楼 <a href="http://chenhjzn.iteye.com/" title="chenhjzn" target="_blank">chenhjzn</a> 2013-04-13  </p>
<p><img src="" alt=""> 非常不错</p>
<p>4 楼 <a href="http://zz563143188.iteye.com/" title="zz563143188" target="_blank">zz563143188</a> 2013-04-09  </p>
<p>jayluns 写道</p>
<p>非常不错，赞。<img src="" alt="">
只供学习参考
3 楼 <a href="http://jayluns.iteye.com/" title="jayluns" target="_blank">jayluns</a> 2013-04-08  </p>
<p>非常不错，赞。<img src="" alt=""></p>
<p>2 楼 <a href="http://zz563143188.iteye.com/" title="zz563143188" target="_blank">zz563143188</a> 2013-04-07  </p>
<p>shichuanliujie 写道</p>
<p><img src="" alt=""> 不错
只供参考引用，扩展眼界
1 楼 <a href="http://shichuanliujie.iteye.com/" title="shichuanliujie" target="_blank">shichuanliujie</a> 2013-04-07  </p>
<p><img src="" alt=""> 不错</p>
<h3 id="-">发表评论</h3>
<p><a href="http://zz563143188.iteye.com/login" target="_blank"><img src="" alt=""></a><a href="http://zz563143188.iteye.com/login" target="_blank">您还没有登录,请您登录后再发表评论</a></p>
<p><a href="http://zz563143188.iteye.com/" target="_blank"><img src="&quot;zz563143188的博客: 既然来了就要多看几篇博客， 因为每一篇都适合你。如果收藏重复看，你一定能感受到我的正能量。&quot;" alt="zz563143188的博客"></a></p>
<p>zz563143188</p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/网上资料url集/">网上资料url集</a></li></span></span> | <span class="tags">Tagged <a href="/tags/网上资料url集/" class="label label-primary">网上资料url集</a></span> | <span class="time">recent updated:<time title="2014-03-26 20:47:04"datetime="2014-03-26 20:47:04"> mar. 26 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-百万级访问网站前期的技术准备/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-百万级访问网站前期的技术准备" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-我心目中最好的框架组合是/">我心目中最好的框架组合是 </a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:32.000Z"> <a href="/2014/02/02/2014-02-02-我心目中最好的框架组合是/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-">我心目中最好的框架组合是</h1>
<h1 id="-http-zz563143188-iteye-com-"><a href="http://zz563143188.iteye.com/" target="_blank">既然来了就要多看几篇博客， 因为每一篇都适合你。如果收藏重复看，你一定能感受到我的正能量。</a></h1>
<p><strong>  我心目中最好的框架组合是：</strong></p>
<p>   表示层:spring mvc 3.1 + annotation
    控制层:spring 3.1
    持久层：hibernate 3.6 +jdbcTemplate
    后台列表控件：displaytag 1.2
    Ajax框架: DWR 3
    JS框架 ： Jquery
    缓存机制：spring 3.1 cache + ehcache/memcached
    静态化机制： Freemarker静态化/spring mvc伪静态化
    页面技术： EL + JSTL +JSP
    安全框架 spring security
    搜索引擎： Lucene
    中文分词：IKAnalyzer
    模板引擎： apache tiles 2.22
     Linux、nginx、php、mysql，几乎是标配
    部署视图所需：
    数据库： mysql
    Web 服务器： windows 下用apache, linux 下用ngnix
    应用服务器： Tomcat  Jboss,tomcat,weblogic</p>
<p><strong>常用的系统架构是:
</strong>Linux + Apache + PHP + MySQL + web负载均衡+数据库主从+缓存+分布式存储+队列
Linux + Apache + Java (WebSphere) + Oracle
Windows Server 2003/2008 + IIS + C/#/ASP.NET + 数据库</p>
<p><strong>大型动态应用系统又可分为几个子系统：
</strong>  1）Web前端系统
  2）负载均衡系统
  3）数据库集群系统
  4）缓存系统
  5）分布式存储系统
  6）分布式服务器管理系统
  7）代码分发系统</p>
<p><strong>常用的工具列表</strong></p>
<p>集成ORM  hibernate ,jdo,toplink,apache ojb ,ibatis,jpa
集成视图  jsp ,jstl ,tiles,velocity, freemarker,xslt ,pdf/excel,jaseperreports
集成web框架  jsf struts tapestry webwork
整合其它J2EE  webserives,ejb jms jmx jca 邮件抽象层，定时调度和线程池，java注解
数据库 mysql ,sqlsever,oralce,sqlite,db2
Ajax框架  ext,jquery ,prototype,dojo,yui,
容器 Jboss,tomcat,weblogic</p>
<p> <strong>高级软件工程师的招聘条件</strong></p>
<p>技能技巧要求:</p>
<p>◆熟练使用css语言，对css布局，编写有一定经验；
◆熟练使用jquery语言，能够编写jquery通用插件，且能够阅读复杂的jquery插件；
◆熟练使用spring framework，且阅读过部分sping相关源码；
◆熟悉Web应用多层架构设计；
◆熟悉OO分析设计方法和J2EE 设计模式，具备良好的沟通能力与表达能力；
◆有mongodb,RabbitMQ,Lucence等技术经验更佳；
◆熟悉tocmat,nginx基本工作原理，能够阅读nginx源代码；或者熟悉tcp/ip协议细节；
◆能正常使用linux操作系统，简单管理linux系统；
◆能够根据产品需求文档，编写开发详细文档；
◆能够分析系统基本性能问题，能够mysql性能调优；
◆英语四级以上，能熟练阅读英文技术资料。</p>
<p><strong>学习Web基础（HTML/CSS/JS)+服务器端技术(LAMP)</strong></p>
<p>未来必然是Web的世界，学习Web基础的最佳网站是<a href="http://www.w3school.com.cn/" target="_blank">W3School</a>。</p>
<ul>
<li>学习HTML基本语法</li>
<li>学习CSS如何选中HTML元素并应用一些基本样式（关键词：box model）</li>
<li>学会用 Firefox + Firebug 或 Chrome 查看你觉得很炫的网页结构，并动态修改。</li>
<li>学习使用Javascript操纵HTML元件。理解DOM和动态网页（<a href="http://oreilly.com/catalog/9780596527402" target="_blank"><a href="http://oreilly.com/catalog/9780596527402">http://oreilly.com/catalog/9780596527402</a></a>)网上有免费的章节，足够用了。或参看 <a href="http://www.w3school.com.cn/htmldom/index.asp" target="_blank">DOM</a> 。</li>
<li>学会用 Firefox + Firebug 或 Chrome 调试 Javascript 代码（设置断点，查看变量，性能，控制台等）</li>
<li>在一台机器上配置<a href="http://coolshell.cn/articles/www.apache.org" target="_blank">Apache</a>或<a href="http://coolshell.cn/articles/nginx.net" target="_blank">Nginx</a></li>
<li>学习<a href="http://coolshell.cn/articles/www.php.net" target="_blank">PHP</a>，让后台PHP和前台HTML进行数据交互，对服务器相应浏览器请求形成初步认识。实现一个表单提交和反显的功能。</li>
<li>把PHP连接本地或者远程数据库 MySQL（MySQL 和 SQL现学现用够了）</li>
<li>跟完一个名校的网络编程课程（例如：<a href="http://www.stanford.edu/~ouster/cgi-bin/cs142-fall10/index.php" target="_blank"><a href="http://www.stanford.edu/~ouster/cgi-bin/cs142-fall10/index.php">http://www.stanford.edu/~ouster/cgi-bin/cs142-fall10/index.php</a></a> )不要觉得需要多于一学期时间，大学生是全职一学期选3-5门课，你业余时间一定可以跟上</li>
<li>学习一个Javascript库（例如jQuery或ExtJS）+ Ajax(异步读入一个服务器端图片或者数据库内容）+ JSON数据格式。</li>
<li>HTTP: The Definite Guide 读完前4章你就明白你每天上网用浏览器的时候发生的事情了(proxy, gateway, browsers)</li>
<li>做个小网站（例如：一个小的留言板，支持用户登录，Cookie/Session，增、删、改、查，上传图片附件，分页显示）</li>
<li>买个域名，租个空间，做个自己的网站。</li>
</ul>
<pre><code> 此学习备忘录只是我工作之外收集的一些资料，只希望能够扩大IT从业人员的知识面。IT的知识很繁多，有此只需要了解知道。此备忘录有硬件方面的，也有软件方面的，也有大IT公司要求的技能。作为新手你可以阅览一下，知识有哪些知识。作为高手，你可以补充一下自己的知识面。
</code></pre><p><strong>企业级项目实战(带源码升级版本）地址： </strong><a href="http://zz563143188.iteye.com/blog/1825168" target="_blank"><a href="http://zz563143188.iteye.com/blog/1825168">http://zz563143188.iteye.com/blog/1825168</a></a>
<strong>收集五年的开发资料及源码下载地址：</strong> <a href="http://pan.baidu.com/share/link?shareid=372668&amp;uk=4076915866#dir/path=%2F%E5%AD%A6%E4%B9%A0%E6%96%87%E4%BB%B6" title="http://pan.baidu.com/share/link?shareid=372668&amp;uk=4076915866" target="_blank"><a href="http://pan.baidu.com/share/link?shareid=372668&amp;uk=4076915866/#dir/path=%2F%E5%AD%A6%E4%B9%A0%E6%96%87%E4%BB%B6">http://pan.baidu.com/share/link?shareid=372668&amp;uk=4076915866/#dir/path=%2F%E5%AD%A6%E4%B9%A0%E6%96%87%E4%BB%B6</a></a>
<strong>13</strong>
顶</p>
<p><strong>7</strong>
踩</p>
<p>分享到： <a href="&quot;分享到新浪微博&quot;"><img src="" alt=""></a> <a href="&quot;分享到腾讯微博&quot;"><img src="" alt=""></a></p>
<p><a href="http://zz563143188.iteye.com/blog/1870134" title="关于《深入理解并行编程》一书 " target="_blank">关于《深入理解并行编程》一书</a> | <a href="http://zz563143188.iteye.com/blog/1860248" title="比较全的OA系统功能模块列表 " target="_blank">比较全的OA系统功能模块列表</a></p>
<ul>
<li>2013-05-13 10:59</li>
<li>浏览 6334</li>
<li><a href="http://zz563143188.iteye.com/blog/1867767#comments" target="_blank">评论(52)</a></li>
<li>分类:<a href="http://www.iteye.com/blogs/category/architecture" target="_blank">企业架构</a></li>
<li><a href="http://www.iteye.com/wiki/blog/1867767" target="_blank">相关推荐</a></li>
</ul>
<h3 id="-">评论</h3>
<p><a href=""></a></p>
<p>52 楼 <a href="http://zz563143188.iteye.com/" title="zz563143188" target="_blank">zz563143188</a> 2013-05-23  </p>
<p>yaozhuan 写道</p>
<p>yaozhuan 写道</p>
<p>从您百度网盘下载的源码jeecms 运行后碰到一个问题  其他都功能没问题 在后台点  栏目  这个版块的时候tomcat后台报错 root 获取不到值 不知道你又碰到这个问题没
[framework] 2013-05-23 11:28:48,340 -414609 [http-bio-8080-exec-2] ERROR freemarker.runtime  - Error on line 34, column
59 in jeecms_sys/channel/list.html
Expecting a string, date or number here, Expression root is instead a freemarker.template.SimpleSequence
Error on line 34, column 59 in jeecms_sys/channel/list.html
Expecting a string, date or number here, Expression root is instead a freemarker.template.SimpleSequence</p>
<h2 id="the-problematic-instruction-">The problematic instruction:</h2>
<h2 id="-root-on-line-34-column-57-in-jeecms_sys-channel-list-html-">==&gt; ${root} [on line 34, column 57 in jeecms_sys/channel/list.html]</h2>
<h2 id="java-backtrace-for-programmers-">Java backtrace for programmers:</h2>
<p>freemarker.core.NonStringException: Error on line 34, column 59 in jeecms_sys/channel/list.html
Expecting a string, date or number here, Expression root is instead a freemarker.template.SimpleSequence
已经解决
if (root == null) {
list = manager.getTopList(CmsUtils.getSiteId(request), false);
root=0;//加这句代码
} else {
list = manager.getChildList(root, false);
}
你真厉害，继续努力。
51 楼 <a href="http://yaozhuan.iteye.com/" title="yaozhuan" target="_blank">yaozhuan</a> 2013-05-23  </p>
<p>yaozhuan 写道</p>
<p>从您百度网盘下载的源码jeecms 运行后碰到一个问题  其他都功能没问题 在后台点  栏目  这个版块的时候tomcat后台报错 root 获取不到值 不知道你又碰到这个问题没
[framework] 2013-05-23 11:28:48,340 -414609 [http-bio-8080-exec-2] ERROR freemarker.runtime  - Error on line 34, column
59 in jeecms_sys/channel/list.html
Expecting a string, date or number here, Expression root is instead a freemarker.template.SimpleSequence
Error on line 34, column 59 in jeecms_sys/channel/list.html
Expecting a string, date or number here, Expression root is instead a freemarker.template.SimpleSequence</p>
<h2 id="the-problematic-instruction-">The problematic instruction:</h2>
<h2 id="-root-on-line-34-column-57-in-jeecms_sys-channel-list-html-">==&gt; ${root} [on line 34, column 57 in jeecms_sys/channel/list.html]</h2>
<h2 id="java-backtrace-for-programmers-">Java backtrace for programmers:</h2>
<p>freemarker.core.NonStringException: Error on line 34, column 59 in jeecms_sys/channel/list.html
Expecting a string, date or number here, Expression root is instead a freemarker.template.SimpleSequence
已经解决
if (root == null) {
list = manager.getTopList(CmsUtils.getSiteId(request), false);
root=0;//加这句代码
} else {
list = manager.getChildList(root, false);
}</p>
<p>50 楼 <a href="http://yaozhuan.iteye.com/" title="yaozhuan" target="_blank">yaozhuan</a> 2013-05-23  </p>
<p>从您百度网盘下载的源码jeecms 运行后碰到一个问题  其他都功能没问题 在后台点  栏目  这个版块的时候tomcat后台报错 root 获取不到值 不知道你又碰到这个问题没
[framework] 2013-05-23 11:28:48,340 -414609 [http-bio-8080-exec-2] ERROR freemarker.runtime  - Error on line 34, column
59 in jeecms_sys/channel/list.html
Expecting a string, date or number here, Expression root is instead a freemarker.template.SimpleSequence
Error on line 34, column 59 in jeecms_sys/channel/list.html
Expecting a string, date or number here, Expression root is instead a freemarker.template.SimpleSequence</p>
<h2 id="the-problematic-instruction-">The problematic instruction:</h2>
<h2 id="-root-on-line-34-column-57-in-jeecms_sys-channel-list-html-">==&gt; ${root} [on line 34, column 57 in jeecms_sys/channel/list.html]</h2>
<h2 id="java-backtrace-for-programmers-">Java backtrace for programmers:</h2>
<p>freemarker.core.NonStringException: Error on line 34, column 59 in jeecms_sys/channel/list.html
Expecting a string, date or number here, Expression root is instead a freemarker.template.SimpleSequence
49 楼 <a href="http://zengguoqin520.iteye.com/" title="zengguoqin520" target="_blank">zengguoqin520</a> 2013-05-20  </p>
<p>很欣赏楼主的分享精神，正能量已收到。
<img src="" alt=""></p>
<p>48 楼 <a href="http://zz563143188.iteye.com/" title="zz563143188" target="_blank">zz563143188</a> 2013-05-20  </p>
<p>zz563143188 写道</p>
<p>teasp 写道</p>
<p>diggywang 写道</p>
<p>liqingyuan 写道</p>
<p>MrLee23 写道</p>
<p>ajax为什么要用dwr呢？它的优点又是什么呢？想听一听，学习学习
DWR主要是能直接调用后台JAVA方法，而且能够自动封装后台对象为JSON数据。个人观点，DWR最好别用，在前端直接调后台方法这个想法就非常不好——一切设计模式都是为了解耦，DWR反而想去追求把前端和后台耦合到一起，这个想法太奇葩。
所以，还是gwt好，这东西就是开发的时候太耗资源，整个设计架构是非常好超前的。
另外，开发了那么多年，绝大部分情况下ibatis/mybatis足够了。
GWT好在哪里？你怎么用它做项目的？我在08年的时候用它做过一个网站前端，它有个很大的毛病就是第一次访问的时候要下载大量的js代码，因此会等很久，这是很坏的体验。不知道GWT现在是个什么情况了，能否多讲点？
这个内部访问还是可以的，现在ext也不错
用ext太多了，有时看到ext会一种很腻的感觉。
47 楼 <a href="http://zz563143188.iteye.com/" title="zz563143188" target="_blank">zz563143188</a> 2013-05-20  </p>
<p>diggywang 写道</p>
<p>teasp 写道</p>
<p>diggywang 写道</p>
<p>liqingyuan 写道</p>
<p>MrLee23 写道</p>
<p>ajax为什么要用dwr呢？它的优点又是什么呢？想听一听，学习学习
DWR主要是能直接调用后台JAVA方法，而且能够自动封装后台对象为JSON数据。个人观点，DWR最好别用，在前端直接调后台方法这个想法就非常不好——一切设计模式都是为了解耦，DWR反而想去追求把前端和后台耦合到一起，这个想法太奇葩。
所以，还是gwt好，这东西就是开发的时候太耗资源，整个设计架构是非常好超前的。
另外，开发了那么多年，绝大部分情况下ibatis/mybatis足够了。
GWT好在哪里？你怎么用它做项目的？我在08年的时候用它做过一个网站前端，它有个很大的毛病就是第一次访问的时候要下载大量的js代码，因此会等很久，这是很坏的体验。不知道GWT现在是个什么情况了，能否多讲点？
GWT第一次访问下载js过多问题，你可以根据需要进行分解的，如多module。用google plugin这种自动建的项目默认会第一次下载所有js，你也可以根据需要手动在那个初始html里改掉。
我GWT应用得最多的是企业内部的系统，带宽不是问题，而且一次性加载之后，用户体验非常好。
随着宽带的改善，以后这些问题可能考虑的少了。</p>
<p>46 楼 <a href="http://zz563143188.iteye.com/" title="zz563143188" target="_blank">zz563143188</a> 2013-05-20  </p>
<p>teasp 写道</p>
<p>diggywang 写道</p>
<p>liqingyuan 写道</p>
<p>MrLee23 写道</p>
<p>ajax为什么要用dwr呢？它的优点又是什么呢？想听一听，学习学习
DWR主要是能直接调用后台JAVA方法，而且能够自动封装后台对象为JSON数据。个人观点，DWR最好别用，在前端直接调后台方法这个想法就非常不好——一切设计模式都是为了解耦，DWR反而想去追求把前端和后台耦合到一起，这个想法太奇葩。
所以，还是gwt好，这东西就是开发的时候太耗资源，整个设计架构是非常好超前的。
另外，开发了那么多年，绝大部分情况下ibatis/mybatis足够了。
GWT好在哪里？你怎么用它做项目的？我在08年的时候用它做过一个网站前端，它有个很大的毛病就是第一次访问的时候要下载大量的js代码，因此会等很久，这是很坏的体验。不知道GWT现在是个什么情况了，能否多讲点？
这个内部访问还是可以的，现在ext也不错
45 楼 <a href="http://zz563143188.iteye.com/" title="zz563143188" target="_blank">zz563143188</a> 2013-05-20  </p>
<p>white_crucifix 写道</p>
<p>几年前用过GWT-ext，感觉还不错，总体来说我还是比较有兴趣的。
不过后来自从用了原生Extjs，就再也懒得用GWText了，呵呵
我现在也用ext js多一些。</p>
<p>44 楼 <a href="http://white-crucifix.iteye.com/" title="white_crucifix" target="_blank">white_crucifix</a> 2013-05-20  </p>
<p>几年前用过GWT-ext，感觉还不错，总体来说我还是比较有兴趣的。
不过后来自从用了原生Extjs，就再也懒得用GWText了，呵呵
43 楼 <a href="http://teasp.iteye.com/" title="teasp" target="_blank">teasp</a> 2013-05-20  </p>
<p>diggywang 写道</p>
<p>teasp 写道</p>
<p>diggywang 写道</p>
<p>liqingyuan 写道</p>
<p>MrLee23 写道</p>
<p>ajax为什么要用dwr呢？它的优点又是什么呢？想听一听，学习学习
DWR主要是能直接调用后台JAVA方法，而且能够自动封装后台对象为JSON数据。个人观点，DWR最好别用，在前端直接调后台方法这个想法就非常不好——一切设计模式都是为了解耦，DWR反而想去追求把前端和后台耦合到一起，这个想法太奇葩。
所以，还是gwt好，这东西就是开发的时候太耗资源，整个设计架构是非常好超前的。
另外，开发了那么多年，绝大部分情况下ibatis/mybatis足够了。
GWT好在哪里？你怎么用它做项目的？我在08年的时候用它做过一个网站前端，它有个很大的毛病就是第一次访问的时候要下载大量的js代码，因此会等很久，这是很坏的体验。不知道GWT现在是个什么情况了，能否多讲点？
GWT第一次访问下载js过多问题，你可以根据需要进行分解的，如多module。用google plugin这种自动建的项目默认会第一次下载所有js，你也可以根据需要手动在那个初始html里改掉。
我GWT应用得最多的是企业内部的系统，带宽不是问题，而且一次性加载之后，用户体验非常好。
你们是不是把系统做成web桌面这样了？</p>
<p>42 楼 <a href="http://diggywang.iteye.com/" title="diggywang" target="_blank">diggywang</a> 2013-05-19  </p>
<p>teasp 写道</p>
<p>diggywang 写道</p>
<p>liqingyuan 写道</p>
<p>MrLee23 写道</p>
<p>ajax为什么要用dwr呢？它的优点又是什么呢？想听一听，学习学习
DWR主要是能直接调用后台JAVA方法，而且能够自动封装后台对象为JSON数据。个人观点，DWR最好别用，在前端直接调后台方法这个想法就非常不好——一切设计模式都是为了解耦，DWR反而想去追求把前端和后台耦合到一起，这个想法太奇葩。
所以，还是gwt好，这东西就是开发的时候太耗资源，整个设计架构是非常好超前的。
另外，开发了那么多年，绝大部分情况下ibatis/mybatis足够了。
GWT好在哪里？你怎么用它做项目的？我在08年的时候用它做过一个网站前端，它有个很大的毛病就是第一次访问的时候要下载大量的js代码，因此会等很久，这是很坏的体验。不知道GWT现在是个什么情况了，能否多讲点？
GWT第一次访问下载js过多问题，你可以根据需要进行分解的，如多module。用google plugin这种自动建的项目默认会第一次下载所有js，你也可以根据需要手动在那个初始html里改掉。
我GWT应用得最多的是企业内部的系统，带宽不是问题，而且一次性加载之后，用户体验非常好。
41 楼 <a href="http://teasp.iteye.com/" title="teasp" target="_blank">teasp</a> 2013-05-18  </p>
<p>diggywang 写道</p>
<p>liqingyuan 写道</p>
<p>MrLee23 写道</p>
<p>ajax为什么要用dwr呢？它的优点又是什么呢？想听一听，学习学习
DWR主要是能直接调用后台JAVA方法，而且能够自动封装后台对象为JSON数据。个人观点，DWR最好别用，在前端直接调后台方法这个想法就非常不好——一切设计模式都是为了解耦，DWR反而想去追求把前端和后台耦合到一起，这个想法太奇葩。
所以，还是gwt好，这东西就是开发的时候太耗资源，整个设计架构是非常好超前的。
另外，开发了那么多年，绝大部分情况下ibatis/mybatis足够了。
GWT好在哪里？你怎么用它做项目的？我在08年的时候用它做过一个网站前端，它有个很大的毛病就是第一次访问的时候要下载大量的js代码，因此会等很久，这是很坏的体验。不知道GWT现在是个什么情况了，能否多讲点？</p>
<p>40 楼 <a href="http://zz563143188.iteye.com/" title="zz563143188" target="_blank">zz563143188</a> 2013-05-15  </p>
<p>zz563143188 写道</p>
<p>kjj 写道</p>
<p>nonocast 写道</p>
<p>我心目中最好的框架组合是DIY，呵呵，全部自己写。
全部自己写有那么多时间和精力吗,质量如何呢,还要考时间检验吧
哈哈，是开玩笑的啦
开玩笑的，我们当然不会因为欣赏花就要一个一个细胞的去组合，而只需要找种子慢慢培育。
39 楼 <a href="http://zz563143188.iteye.com/" title="zz563143188" target="_blank">zz563143188</a> 2013-05-15  </p>
<p>kjj 写道</p>
<p>nonocast 写道</p>
<p>我心目中最好的框架组合是DIY，呵呵，全部自己写。
全部自己写有那么多时间和精力吗,质量如何呢,还要考时间检验吧
哈哈，是开玩笑的啦</p>
<p>38 楼 <a href="http://docs.iteye.com/" title="kjj" target="_blank">kjj</a> 2013-05-14  </p>
<p>nonocast 写道</p>
<p>我心目中最好的框架组合是DIY，呵呵，全部自己写。
全部自己写有那么多时间和精力吗,质量如何呢,还要考时间检验吧
37 楼 <a href="http://zz563143188.iteye.com/" title="zz563143188" target="_blank">zz563143188</a> 2013-05-14  </p>
<p>white_crucifix 写道</p>
<p>楼主太牛了，所学的知识面超级广啊，从传统web编程，到分布式，还有nosql，以及新型的ngnix似乎也是楼主的心爱。膜拜！
PS. 感觉linux上用的最多的web服务器还是apache，除非是处理大数据量高并发可能会力不从心
呵呵，我一个人怎么可能会这么多呢，还都是网络的功效。nosql有前景，以前有sqlite和delphi一起做过项目。</p>
<p>36 楼 <a href="http://white-crucifix.iteye.com/" title="white_crucifix" target="_blank">white_crucifix</a> 2013-05-14  </p>
<p>楼主太牛了，所学的知识面超级广啊，从传统web编程，到分布式，还有nosql，以及新型的ngnix似乎也是楼主的心爱。膜拜！
PS. 感觉linux上用的最多的web服务器还是apache，除非是处理大数据量高并发可能会力不从心
35 楼 <a href="http://zz563143188.iteye.com/" title="zz563143188" target="_blank">zz563143188</a> 2013-05-14  </p>
<p>xnk9499 写道</p>
<p>博主，可否给个   静态化机制： Freemarker静态化/spring mvc伪静态化
这方面的列子看看
你去看一下这个吧 <a href="http://zz563143188.iteye.com/blog/1825168" target="_blank">http://zz563143188.iteye.com/blog/1825168</a></p>
<p>34 楼 <a href="http://quentinxu.iteye.com/" title="xnk9499" target="_blank">xnk9499</a> 2013-05-14  </p>
<p>博主，可否给个   静态化机制： Freemarker静态化/spring mvc伪静态化
这方面的列子看看
33 楼 <a href="http://zz563143188.iteye.com/" title="zz563143188" target="_blank">zz563143188</a> 2013-05-14  </p>
<p>galfordliu 写道</p>
<p>jQuery已经有强大的ajax了.为何还要用dwr?
你通过dwr在js脚本中调用业务类,这不是违背了前后台分离的原则么.
金山公司和快玩游戏公司开发项目用Jquery比较多，这也证明了JQuery的强大和优势。Jquery的前后兼容不是很完善，稳定和支持动画方面还有空间。SpringMVC、struts2.0零配置功能让dwrd在js脚本中调用业务类方法显得有意义。</p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/网上资料url集/">网上资料url集</a></li></span></span> | <span class="tags">Tagged <a href="/tags/网上资料url集/" class="label label-primary">网上资料url集</a></span> | <span class="time">recent updated:<time title="2014-03-26 20:57:44"datetime="2014-03-26 20:57:44"> mar. 26 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-我心目中最好的框架组合是/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-我心目中最好的框架组合是" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-UML的九种模型图/">UML 的九种模型图 </a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:32.000Z"> <a href="/2014/02/02/2014-02-02-UML的九种模型图/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="uml-">UML 的九种模型图</h1>
<h1 id="-http-zz563143188-iteye-com-"><a href="http://zz563143188.iteye.com/" target="_blank">既然来了就要多看几篇博客， 因为每一篇都适合你。如果收藏重复看，你一定能感受到我的正能量。</a></h1>
<h3 id="uml-">UML设计九种图例</h3>
<p>一、作为一种建模语言，UML的定义包括UML语义和UML表示法两个部分。</p>
<ul>
<li><p>UML语义：描述基于UML的精确元模型定义。</p>
</li>
<li><p>UML表示法：定义UML符号的表示法，为开发者或开发工具使用这些图形符号和文本语法为系统建模提供了标准。这些图形符号和文字所表达的是应用级的模型，在语义上它是UML元模型的实例。
二、标准建模语言UML可以由下列5类图来定义。</p>
</li>
<li><p>用例图：从用户角度描述系统功能，并指出各功能的操作者。</p>
</li>
<li><p><strong>静态图：包括类图和对象图。</strong>类图描述系统中类的静态结构，不仅定义系统中的类，表示类之间的联系，如关联、依赖、聚合等，也包括类的属性和操作，类图描述的是一种静态关系，在系统的整个生命周期都是有效的。对象图是类图的实例，几乎使用与类图完全相同的标识。一个对象图是类图的一个实例。由于对象存在生命周期，因此对象图只能在系统某一时间段存在。</p>
</li>
<li><p>行为图：描述系统的动态模型和组成对象间的交互关系，<strong>包括状态图和活动图</strong>。状态图描述类的对象所有可能的状态以及事件发生时状态的转移条件，状态图是对类图的补充，活动图描述满足用例要求所要进行的活动以及活动间的约束关系，有利于识别并进行活动。</p>
</li>
<li><p>交互图：描述对象间的交互关系，包括<strong>时序图和协作图</strong>。时序图显示对象之间的动态合作关系，它强调对象之间消息发送的顺序，同时显示对象之间的交互；协作图描述对象间的协作关系，协作图跟时序图相似，显示对象间的动态合作关系。除显示信息交换外，协作图还显示对象以及它们之间的关系。如果强调时间和顺序，则使用时序图；如果强调上下级关系，则选择协作图。</p>
</li>
<li><p>实现图：包括<strong>组件图和部署图</strong>。组件图描述代码部件的物理结构及各部件之间的依赖关系，组件图有助于分析和理解部件之间的相互影响程度；部署图定义系统中软硬件的物理体系结构。</p>
</li>
</ul>
<p>采用UML来设计系统时，第一步是描述需求；第二步根据需求建立系统的静态模型，以构造系统的结构；第三步是描述系统的行为。其中在第一步与第二步中所建立的模型都是静态的，包括用例图、类图、对象图、组件图和部署图等5种图形，是标准建模语言UML的静态建模机制。其中第三步中所建立的模型或者可以执行，或者表示执行时的时序状态或交互关系。它包括状态图、活动图、时序图和协作图等4种图形，是标准建模语言UML的动态建模机制。</p>
<p>首先对UML中的各个图的功用做一个简单介绍：
<strong>1、用例图</strong></p>
<pre><code>描述角色以及角色与用例之间的连接关系。说明的是谁要使用系统，以及他们使用该系统可以做些什么。一个用例图包含了多个模型元素，如系统、参与者和用例，并且显示了这些元素之间的各种关系，如泛化、关联和依赖。
</code></pre><p><strong>2、类图</strong></p>
<pre><code>类图是描述系统中的类，以及各个类之间的关系的静态视图。能够让我们在正确编写代码以前对系统有一个全面的认识。类图是一种模型类型，确切的说，是一种静态模型类型。
</code></pre><p><strong>3、对象图</strong></p>
<pre><code>与类图极为相似，它是类图的实例，对象图显示类的多个对象实例，而不是实际的类。它描述的不是类之间的关系，而是对象之间的关系。
</code></pre><p><strong>4、活动图</strong></p>
<pre><code>描述用例要求所要进行的活动，以及活动间的约束关系，有利于识别并行活动。能够演示出系统中哪些地方存在功能，以及这些功能和系统中其他组件的功能如何共同满足前面使用用例图建模的商务需求。
</code></pre><p><strong>5、状态图</strong></p>
<pre><code>描述类的对象所有可能的状态，以及事件发生时状态的转移条件。可以捕获对象、子系统和系统的生命周期。他们可以告知一个对象可以拥有的状态，并且事件(如消息的接收、时间的流逝、错误、条件变为真等)会怎么随着时间的推移来影响这些状态。一个状态图应该连接到所有具有清晰的可标识状态和复杂行为的类；该图可以确定类的行为，以及该行为如何根据当前的状态变化，也可以展示哪些事件将会改变类的对象的状态。状态图是对类图的补充。
</code></pre><p><strong>6、序列图</strong>（顺序图）</p>
<pre><code>序列图是用来显示你的参与者如何以一系列顺序的步骤与系统的对象交互的模型。顺序图可以用来展示对象之间是如何进行交互的。顺序图将显示的重点放在消息序列上，即强调消息是如何在对象之间被发送和接收的。
</code></pre><p><strong>7、协作图</strong></p>
<pre><code>和序列图相似，显示对象间的动态合作关系。可以看成是类图和顺序图的交集，协作图建模对象或者角色，以及它们彼此之间是如何通信的。如果强调时间和顺序，则使用序列图；如果强调上下级关系，则选择协作图；这两种图合称为交互图。
</code></pre><p><strong>8、构件图</strong> （组件图）</p>
<pre><code>描述代码构件的物理结构以及各种构建之间的依赖关系。用来建模软件的组件及其相互之间的关系，这些图由构件标记符和构件之间的关系构成。在组件图中，构件时软件单个组成部分，它可以是一个文件，产品、可执行文件和脚本等。
</code></pre><p><strong>9、部署图</strong> （配置图）</p>
<pre><code>是用来建模系统的物理部署。例如计算机和设备，以及它们之间是如何连接的。部署图的使用者是开发人员、系统集成人员和测试人员。
</code></pre><p><strong>几种图的区别：</strong></p>
<p>一：这九种模型图各有侧重，</p>
<p>1:用例图侧重描述用户需求，</p>
<p>2:类图侧重描述系统具体实现；</p>
<p>二：描述的方面都不相同，</p>
<p>1:类图描述的是系统的结构，</p>
<p>2:序列图描述的是系统的行为；</p>
<p>三：抽象的层次也不同，</p>
<p>1：构件图描述系统的模块结构，抽象层次较高，</p>
<p>2：类图是描述具体模块的结构，抽象层次一般，</p>
<p>3：对象图描述了具体的模块实现，抽象层次较低。</p>
<p>在有的文献书籍中，将这九种模型图分为三大类：</p>
<p>结构分类、动态行为和模型管理：</p>
<p><strong>1：结构分类包括用例图、类图、对象图、构件图和部署图，</strong></p>
<p><strong>2：动态行为包括状态图、活动图、顺序图和协作图，</strong></p>
<p><strong>3：模型管理则包含类图。</strong></p>
<p><strong>画图说明</strong>
UML(统一建模语言)：是面向对象的可视化建模的一种语言。是数据库设计过程中，在E-R图（实体-联系图）的设计后的进一步建模。
UML中有3种构造块：事物、关系和图，事物是对模型中最具有代表性的成分的抽象；关系是把事物结合在一起；图聚集了相关的的事物。具体关系图标如下：</p>
<p><img src="" alt="">
说明：
构件事物是名词，是模型的静态部分。
行为事物是动态部分，表示行为。
分组事物是组织部分。
注释事物是解释部分。
依赖：一个事物变化会引起另一个事物变化。
聚集：特殊的关联，描述整体与部分的组合关系。
泛化：是一种特殊与一般的关系，如子元素（特殊）与父元素（一般），箭头指向父元素。
实现：类元之间的关系，其中一个类元指定了由另一个类元保证执行的契约。一般用在接口和实现他们的类之间或用例和实现它们的协作之间。</p>
<p>UML提供9种视图：类图、对象图，用例图，序列图、协作图，状态图、活动图，构件图和部署图。
在UML系统开发中有三个主要的模型：</p>
<p>功能模型: 从用户的角度展示系统的功能，包括用例图。
对象模型: 采用对象，属性，操作，关联等概念展示系统的结构和基础，包括类图。
动态模型: 展现系统的内部行为。 包括序列图，活动图，状态图。
下面具体说明：</p>
<p>1.类图：描述一组对象、接口、协作等事物之间的关系。如下图(摘自网络)：
<img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>注：/#表示protected，+表示Public，-表示private</p>
<p>2.对象图：描述一组对象之间的关系，是具有具体属性值和行为的一个具体事物，其是类图中所建事物实例的静态快照，其与类图的主要区别是一个是抽象的,而对象图是具体的。如下图(摘自网络)：
<img src="" alt=""></p>
<p><img src="" alt="">
3.用例图：描述一组用例、参与者以及它们之间的关系，其展示的是该系统在它的外面环境中所提供的外部可见服务。如下图(摘自网络)：</p>
<p><img src="" alt="">
4.交互图：包括序列图（顺序图）和协作图，两者对应，顺序图是强调消息时间顺序，有对象生命线和控制焦点。协作图是强调接收和发送消息的对象的结构组织，有路径和顺序号。如下图(摘自网络)：</p>
<p>序列图：
<img src="" alt=""><img src="" alt=""></p>
<p><strong>5.协作图：</strong></p>
<p> <img src="" alt="">
<img src="" alt="">
6.状态图：展示了一个状态机，由状态、转换、事件和活动组成。强调事件行为的顺序。如下图(摘自网络)：
<img src="" alt=""></p>
<p>7.活动图：是一种特殊的状态图，实现一个活动到另一个活动的流程。如下图(摘自网络)：
<img src="" alt=""></p>
<p>8.构件图 9.部署图：构件图展示一组构件之间的组织和依赖关系，并以全局的模型展示出来。部署图是构件的配置及描述系统如何在硬件上部署。如下图(摘自网络)：
<img src="" alt=""></p>
<p> <strong>企业级项目实战(带源码)地址**</strong>：<strong><a href="http://zz563143188.iteye.com/blog/1825168" target="_blank"><a href="http://zz563143188.iteye.com/blog/1825168">http://zz563143188.iteye.com/blog/1825168</a></a>
</strong>收集五年的开发资料下载地址：  <a href="http://pan.baidu.com/share/link?shareid=372668&amp;uk=4076915866#dir/path=%2F%E5%AD%A6%E4%B9%A0%E6%96%87%E4%BB%B6" title="http://pan.baidu.com/share/link?shareid=372668&amp;uk=4076915866" target="_blank"><a href="http://pan.baidu.com/share/link?shareid=372668&amp;uk=4076915866/#dir/path=%2F%E5%AD%A6%E4%B9%A0%E6%96%87%E4%BB%B6">http://pan.baidu.com/share/link?shareid=372668&amp;uk=4076915866/#dir/path=%2F%E5%AD%A6%E4%B9%A0%E6%96%87%E4%BB%B6</a></a>**</p>
<hr>
<p><a href="http://ibingle.blog.sohu.com/176849217.html" target="_blank"><a href="http://ibingle.blog.sohu.com/176849217.html">http://ibingle.blog.sohu.com/176849217.html</a></a></p>
<ul>
<li><a href="http://dl2.iteye.com/upload/attachment/0082/6257/cc2c3ebb-6011-30bd-a5c7-cc98d8351a18.jpg" target="_blank"><img src="&quot;点击查看原始大小图片&quot;" alt=""></a></li>
<li><p>大小: 54.4 KB</p>
</li>
<li><p><a href="http://dl2.iteye.com/upload/attachment/0082/6259/7ffd5ffb-441c-3dd6-8bf5-9f6cdf7c9e99.jpg" target="_blank"><img src="&quot;点击查看原始大小图片&quot;" alt=""></a></p>
</li>
<li><p>大小: 25.7 KB</p>
</li>
<li><p><a href="http://dl2.iteye.com/upload/attachment/0082/6261/3b798d8f-dd55-3cdf-ab77-aee78b060ecf.jpg" target="_blank"><img src="&quot;点击查看原始大小图片&quot;" alt=""></a></p>
</li>
<li><p>大小: 29.1 KB</p>
</li>
<li><p><a href="http://dl2.iteye.com/upload/attachment/0082/6265/bda107f8-1e1d-3a8c-80a5-c637b0da189c.jpg" target="_blank"><img src="&quot;点击查看原始大小图片&quot;" alt=""></a></p>
</li>
<li><p>大小: 29.1 KB</p>
</li>
<li><p><a href="http://dl2.iteye.com/upload/attachment/0082/6271/92d8fdae-d694-35e0-89a5-940d0994497a.jpg" target="_blank"><img src="&quot;点击查看原始大小图片&quot;" alt=""></a></p>
</li>
<li><p>大小: 26.7 KB</p>
</li>
<li><p><a href="http://zz563143188.iteye.com/blog/1841234#" target="_blank">查看图片附件</a></p>
</li>
</ul>
<p>分享到： <a href="&quot;分享到新浪微博&quot;"><img src="" alt=""></a> <a href="&quot;分享到腾讯微博&quot;"><img src="" alt=""></a>
<a href="http://zz563143188.iteye.com/blog/1841239" title="Oracle笔记 五、创建表、约束、视图、索引、序列、同义词、表空间" target="_blank">Oracle笔记 五、创建表、约束、视图、索引 ...</a> | <a href="http://zz563143188.iteye.com/blog/1841225" title="UML中数据流图，用例图，类图，对象图，角色图，活动图，序列图详细讲述保存供参考" target="_blank">UML中数据流图，用例图，类图，对象图，角 ...</a></p>
<ul>
<li>2013-04-03 10:15</li>
</ul>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/网上资料url集/">网上资料url集</a></li></span></span> | <span class="tags">Tagged <a href="/tags/网上资料url集/" class="label label-primary">网上资料url集</a></span> | <span class="time">recent updated:<time title="2014-03-26 21:01:50"datetime="2014-03-26 21:01:50"> mar. 26 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-UML的九种模型图/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-UML的九种模型图" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-Java开发中的23种设计模式详解/">Java开发中的23种设计模式详解 </a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:32.000Z"> <a href="/2014/02/02/2014-02-02-Java开发中的23种设计模式详解/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h3 id="java-23-">Java开发中的23种设计模式详解</h3>
<p><strong>设计模式（Design Patterns）</strong></p>
<p>——可复用面向对象软件的基础</p>
<p>设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理的运用设计模式可以完美的解决很多问题，每种模式在现在中都有相应的原理来与之对应，每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是它能被广泛应用的原因。本章系<strong>Java之美[从菜鸟到高手演变]系列</strong>之设计模式，我们会以理论与实践相结合的方式来进行本章的学习，希望广大程序爱好者，学好设计模式，做一个优秀的软件工程师！</p>
<p><strong>在阅读过程中有任何问题，请及时联系：egg。</strong></p>
<p><strong>邮箱：xtfggef@gmail.com 微博：</strong><a href="http://weibo.com/xtfggef" target="_blank"><a href="http://weibo.com/xtfggef">http://weibo.com/xtfggef</a></a><em>**</em></p>
<p>如有转载，请说明出处：<strong><a href="http://blog.csdn.net/zhangerqing" target="_blank">http://blog.csdn.net/zhangerqing</a></strong></p>
<p><strong>企业级项目实战(带源码)地址**</strong>：<strong><a href="http://zz563143188.iteye.com/blog/1825168" target="_blank"><a href="http://zz563143188.iteye.com/blog/1825168">http://zz563143188.iteye.com/blog/1825168</a></a>
</strong>23种模式java实现源码下载地址** <a href="http://pan.baidu.com/share/link?shareid=372668&amp;uk=4076915866#dir/path=%2F%E5%AD%A6%E4%B9%A0%E6%96%87%E4%BB%B6" title="http://pan.baidu.com/share/link?shareid=372668&amp;uk=4076915866" target="_blank"><a href="http://pan.baidu.com/share/link?shareid=372668&amp;uk=4076915866/#dir/path=%2F%E5%AD%A6%E4%B9%A0%E6%96%87%E4%BB%B6">http://pan.baidu.com/share/link?shareid=372668&amp;uk=4076915866/#dir/path=%2F%E5%AD%A6%E4%B9%A0%E6%96%87%E4%BB%B6</a></a></p>
<p><strong>一、设计模式的分类</strong></p>
<p>总体来说设计模式分为三大类：</p>
<p>创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。</p>
<p>结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</p>
<p>行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</p>
<p>其实还有两类：并发型模式和线程池模式。用一个图片来整体描述一下：</p>
<p><img src="&quot;点击查看原始大小图片&quot;" alt=""></p>
<p><strong>二、设计模式的六大原则</strong></p>
<p><strong>1、开闭原则（Open Close Principle）</strong></p>
<p>开闭原则就是说<strong>对扩展开放，对修改关闭</strong>。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。</p>
<p><strong>2、里氏代换原则（Liskov Substitution Principle）</strong></p>
<p>里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。—— From Baidu 百科</p>
<p><strong>3、依赖倒转原则（Dependence Inversion Principle）</strong></p>
<p>这个是开闭原则的基础，具体内容：真对接口编程，依赖于抽象而不依赖于具体。</p>
<p><strong>4、接口隔离原则（Interface Segregation Principle）</strong></p>
<p>这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。</p>
<p><strong>5、迪米特法则（最少知道原则）（Demeter Principle）</strong></p>
<p>为什么叫最少知道原则，就是说：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。</p>
<p><strong>6、合成复用原则（Composite Reuse Principle）</strong></p>
<p>原则是尽量使用合成/聚合的方式，而不是使用继承。</p>
<p><strong>三、Java的23中设计模式</strong></p>
<p>从这一块开始，我们详细介绍Java中23种设计模式的概念，应用场景等情况，并结合他们的特点及设计模式的原则进行分析。</p>
<p><strong>1、工厂方法模式（Factory Method）</strong></p>
<p>工厂方法模式分为三种：</p>
<p><strong><em>11、普通工厂模式</em></strong>，就是建立一个工厂类，对实现了同一接口的一些类进行实例的创建。首先看下关系图：</p>
<p><img src="" alt=""></p>
<p>举例如下：（我们举一个发送邮件和短信的例子）</p>
<p>首先，创建二者的共同接口：
<strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8194653" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8194653" title="copy" target="_blank">copy</a></p>
<ol>
<li>public interface Sender {</li>
<li>public void Send();</li>
<li>}</li>
</ol>
<p>其次，创建实现类：</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8194653" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8194653" title="copy" target="_blank">copy</a></p>
<ol>
<li>public class MailSender implements Sender {</li>
<li>@Override</li>
<li>public void Send() {</li>
<li>System.out.println(&quot;this is mailsender!&quot;);</li>
<li>}</li>
<li>}</li>
</ol>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8194653" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8194653" title="copy" target="_blank">copy</a></p>
<ol>
<li>public class SmsSender implements Sender {
1.</li>
<li>@Override</li>
<li>public void Send() {</li>
<li>System.out.println(&quot;this is sms sender!&quot;);</li>
<li>}</li>
<li>}</li>
</ol>
<p>最后，建工厂类：
<strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8194653" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8194653" title="copy" target="_blank">copy</a></p>
<ol>
<li>public class SendFactory {
1.</li>
<li>public Sender produce(String type) {</li>
<li>if (&quot;mail&quot;.equals(type)) {</li>
<li>return new MailSender();</li>
<li>} else if (&quot;sms&quot;.equals(type)) {</li>
<li>return new SmsSender();</li>
<li>} else {</li>
<li>System.out.println(&quot;请输入正确的类型!&quot;);</li>
<li>return null;</li>
<li>}</li>
<li>}</li>
<li>}</li>
</ol>
<p>我们来测试下：</p>
<ol>
<li>public class FactoryTest {
1.</li>
<li>public static void main(String[] args) {</li>
<li>SendFactory factory = new SendFactory();</li>
<li>Sender sender = factory.produce(&quot;sms&quot;);</li>
<li>sender.Send();</li>
<li>}</li>
<li>}</li>
</ol>
<p>输出：this is sms sender!</p>
<p><strong><em>22、多个工厂方法模式</em></strong>，是对普通工厂方法模式的改进，在普通工厂方法模式中，如果传递的字符串出错，则不能正确创建对象，而多个工厂方法模式是提供多个工厂方法，分别创建对象。关系图：</p>
<p><img src="&quot;点击查看原始大小图片&quot;" alt=""></p>
<p>将上面的代码做下修改，改动下SendFactory类就行，如下：
<strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8194653" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8194653" title="copy" target="_blank">copy</a>public class SendFactory {</p>
<p>public Sender produceMail(){</p>
<ol>
<li>return new MailSender();</li>
<li>}
1.</li>
<li>public Sender produceSms(){</li>
<li>return new SmsSender();</li>
<li>}</li>
<li>}</li>
</ol>
<p>测试类如下：</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8194653" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8194653" title="copy" target="_blank">copy</a></p>
<ol>
<li>public class FactoryTest {
1.</li>
<li>public static void main(String[] args) {</li>
<li>SendFactory factory = new SendFactory();</li>
<li>Sender sender = factory.produceMail();</li>
<li>sender.Send();</li>
<li>}</li>
<li>}</li>
</ol>
<p>输出：this is mailsender!</p>
<p><strong><em>33、静态工厂方法模式</em></strong>，将上面的多个工厂方法模式里的方法置为静态的，不需要创建实例，直接调用即可。
<strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8194653" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8194653" title="copy" target="_blank">copy</a></p>
<ol>
<li>public class SendFactory {
1.</li>
<li>public static Sender produceMail(){</li>
<li>return new MailSender();</li>
<li>}
1.</li>
<li>public static Sender produceSms(){</li>
<li>return new SmsSender();</li>
<li>}</li>
<li>}</li>
</ol>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8194653" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8194653" title="copy" target="_blank">copy</a></p>
<ol>
<li>public class FactoryTest {
1.</li>
<li>public static void main(String[] args) {</li>
<li>Sender sender = SendFactory.produceMail();</li>
<li>sender.Send();</li>
<li>}</li>
<li>}</li>
</ol>
<p>输出：this is mailsender!</p>
<p>总体来说，工厂模式适合：凡是出现了大量的产品需要创建，并且具有共同的接口时，可以通过工厂方法模式进行创建。在以上的三种模式中，第一种如果传入的字符串有误，不能正确创建对象，第三种相对于第二种，不需要实例化工厂类，所以，大多数情况下，我们会选用第三种——静态工厂方法模式。</p>
<p><strong>2、抽象工厂模式（Abstract Factory）</strong></p>
<p>工厂方法模式有一个问题就是，类的创建依赖工厂类，也就是说，如果想要拓展程序，必须对工厂类进行修改，这违背了闭包原则，所以，从设计角度考虑，有一定的问题，如何解决？就用到抽象工厂模式，创建多个工厂类，这样一旦需要增加新的功能，直接增加新的工厂类就可以了，不需要修改之前的代码。因为抽象工厂不太好理解，我们先看看图，然后就和代码，就比较容易理解。</p>
<p><img src="&quot;点击查看原始大小图片&quot;" alt=""></p>
<p>请看例子：
<strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8194653" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8194653" title="copy" target="_blank">copy</a></p>
<ol>
<li>public interface Sender {</li>
<li>public void Send();</li>
<li>}</li>
</ol>
<p>两个实现类：</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8194653" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8194653" title="copy" target="_blank">copy</a></p>
<ol>
<li>public class MailSender implements Sender {</li>
<li>@Override</li>
<li>public void Send() {</li>
<li>System.out.println(&quot;this is mailsender!&quot;);</li>
<li>}</li>
<li>}</li>
</ol>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8194653" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8194653" title="copy" target="_blank">copy</a></p>
<ol>
<li>public class SmsSender implements Sender {
1.</li>
<li>@Override</li>
<li>public void Send() {</li>
<li>System.out.println(&quot;this is sms sender!&quot;);</li>
<li>}</li>
<li>}</li>
</ol>
<p>两个工厂类：
<strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8194653" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8194653" title="copy" target="_blank">copy</a></p>
<ol>
<li>public class SendMailFactory implements Provider {
1.</li>
<li>@Override</li>
<li>public Sender produce(){</li>
<li>return new MailSender();</li>
<li>}</li>
<li>}</li>
</ol>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8194653" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8194653" title="copy" target="_blank">copy</a></p>
<ol>
<li>public class SendSmsFactory implements Provider{
1.</li>
<li>@Override</li>
<li>public Sender produce() {</li>
<li>return new SmsSender();</li>
<li>}</li>
<li>}</li>
</ol>
<p>在提供一个接口：
<strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8194653" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8194653" title="copy" target="_blank">copy</a></p>
<ol>
<li>public interface Provider {</li>
<li>public Sender produce();</li>
<li>}</li>
</ol>
<p>测试类：</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8194653" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8194653" title="copy" target="_blank">copy</a></p>
<ol>
<li>public class Test {
1.</li>
<li>public static void main(String[] args) {</li>
<li>Provider provider = new SendMailFactory();</li>
<li>Sender sender = provider.produce();</li>
<li>sender.Send();</li>
<li>}</li>
<li>}</li>
</ol>
<p>其实这个模式的好处就是，如果你现在想增加一个功能：发及时信息，则只需做一个实现类，实现Sender接口，同时做一个工厂类，实现Provider接口，就OK了，无需去改动现成的代码。这样做，拓展性较好！</p>
<p><strong>3、单例模式（</strong>Singleton<strong>）</strong></p>
<p>单例对象（Singleton）是一种常用的设计模式。在Java应用中，单例对象能保证在一个JVM中，该对象只有一个实例存在。这样的模式有几个好处：</p>
<p>1、某些类创建比较频繁，对于一些大型的对象，这是一笔很大的系统开销。</p>
<p>2、省去了new操作符，降低了系统内存的使用频率，减轻GC压力。</p>
<p>3、有些类如交易所的核心交易引擎，控制着交易流程，如果该类可以创建多个的话，系统完全乱了。（比如一个军队出现了多个司令员同时指挥，肯定会乱成一团），所以只有使用单例模式，才能保证核心交易服务器独立控制整个流程。</p>
<p>首先我们写一个简单的单例类：
<strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8194653" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8194653" title="copy" target="_blank">copy</a></p>
<ol>
<li>public class Singleton {
1.</li>
<li>//<em> 持有私有静态实例，防止被引用，此处赋值为null，目的是实现延迟加载 /</em>/</li>
<li>private static Singleton instance = null;
1.</li>
<li>//<em> 私有构造方法，防止被实例化 /</em>/</li>
<li>private Singleton() {</li>
<li>}
1.</li>
<li>//<em> 静态工程方法，创建实例 /</em>/</li>
<li>public static Singleton getInstance() {</li>
<li>if (instance == null) {</li>
<li>instance = new Singleton();</li>
<li>}</li>
<li>return instance;</li>
<li>}
1.</li>
<li>//<em> 如果该对象被用于序列化，可以保证对象在序列化前后保持一致 /</em>/</li>
<li>public Object readResolve() {</li>
<li>return instance;</li>
<li>}</li>
<li>}</li>
</ol>
<p>这个类可以满足基本要求，但是，像这样毫无线程安全保护的类，如果我们把它放入多线程的环境下，肯定就会出现问题了，如何解决？我们首先会想到对getInstance方法加synchronized关键字，如下：</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8194653" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8194653" title="copy" target="_blank">copy</a></p>
<ol>
<li>public static synchronized Singleton getInstance() {</li>
<li>if (instance == null) {</li>
<li>instance = new Singleton();</li>
<li>}</li>
<li>return instance;</li>
<li>}</li>
</ol>
<p>但是，synchronized关键字锁住的是这个对象，这样的用法，在性能上会有所下降，因为每次调用getInstance()，都要对对象上锁，事实上，只有在第一次创建对象的时候需要加锁，之后就不需要了，所以，这个地方需要改进。我们改成下面这个：</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8194653" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8194653" title="copy" target="_blank">copy</a></p>
<ol>
<li>public static Singleton getInstance() {</li>
<li>if (instance == null) {</li>
<li>synchronized (instance) {</li>
<li>if (instance == null) {</li>
<li>instance = new Singleton();</li>
<li>}</li>
<li>}</li>
<li>}</li>
<li>return instance;</li>
<li>}</li>
</ol>
<p>似乎解决了之前提到的问题，将synchronized关键字加在了内部，也就是说当调用的时候是不需要加锁的，只有在instance为null，并创建对象的时候才需要加锁，性能有一定的提升。但是，这样的情况，还是有可能有问题的，看下面的情况：在Java指令中创建对象和赋值操作是分开进行的，也就是说instance = new Singleton();语句是分两步执行的。但是JVM并不保证这两个操作的先后顺序，也就是说有可能JVM会为新的Singleton实例分配空间，然后直接赋值给instance成员，然后再去初始化这个Singleton实例。这样就可能出错了，我们以A、B两个线程为例：</p>
<p>a&gt;A、B线程同时进入了第一个if判断</p>
<p>b&gt;A首先进入synchronized块，由于instance为null，所以它执行instance = new Singleton();</p>
<p>c&gt;由于JVM内部的优化机制，JVM先画出了一些分配给Singleton实例的空白内存，并赋值给instance成员（注意此时JVM没有开始初始化这个实例），然后A离开了synchronized块。</p>
<p>d&gt;B进入synchronized块，由于instance此时不是null，因此它马上离开了synchronized块并将结果返回给调用该方法的程序。</p>
<p>e&gt;此时B线程打算使用Singleton实例，却发现它没有被初始化，于是错误发生了。</p>
<p>所以程序还是有可能发生错误，其实程序在运行过程是很复杂的，从这点我们就可以看出，尤其是在写多线程环境下的程序更有难度，有挑战性。我们对该程序做进一步优化：
<strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8194653" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8194653" title="copy" target="_blank">copy</a></p>
<ol>
<li>private static class SingletonFactory{</li>
<li>private static Singleton instance = new Singleton();</li>
<li>}</li>
<li>public static Singleton getInstance(){</li>
<li>return SingletonFactory.instance;</li>
<li>}</li>
</ol>
<p>实际情况是，单例模式使用内部类来维护单例的实现，JVM内部的机制能够保证当一个类被加载的时候，这个类的加载过程是线程互斥的。这样当我们第一次调用getInstance的时候，JVM能够帮我们保证instance只被创建一次，并且会保证把赋值给instance的内存初始化完毕，这样我们就不用担心上面的问题。同时该方法也只会在第一次调用的时候使用互斥机制，这样就解决了低性能问题。这样我们暂时总结一个完美的单例模式：</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8194653" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8194653" title="copy" target="_blank">copy</a></p>
<ol>
<li>public class Singleton {
1.</li>
<li>//<em> 私有构造方法，防止被实例化 /</em>/</li>
<li>private Singleton() {</li>
<li>}
1.</li>
<li>//<em> 此处使用一个内部类来维护单例 /</em>/</li>
<li>private static class SingletonFactory {</li>
<li>private static Singleton instance = new Singleton();</li>
<li>}
1.</li>
<li>//<em> 获取实例 /</em>/</li>
<li>public static Singleton getInstance() {</li>
<li>return SingletonFactory.instance;</li>
<li>}
1.</li>
<li>//<em> 如果该对象被用于序列化，可以保证对象在序列化前后保持一致 /</em>/</li>
<li>public Object readResolve() {</li>
<li>return getInstance();</li>
<li>}</li>
<li>}</li>
</ol>
<p>其实说它完美，也不一定，如果在构造函数中抛出异常，实例将永远得不到创建，也会出错。所以说，十分完美的东西是没有的，我们只能根据实际情况，选择最适合自己应用场景的实现方法。也有人这样实现：因为我们只需要在创建类的时候进行同步，所以只要将创建和getInstance()分开，单独为创建加synchronized关键字，也是可以的：</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8194653" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8194653" title="copy" target="_blank">copy</a></p>
<ol>
<li>public class SingletonTest {
1.</li>
<li>private static SingletonTest instance = null;
1.</li>
<li>private SingletonTest() {</li>
<li>}
1.</li>
<li>private static synchronized void syncInit() {</li>
<li>if (instance == null) {</li>
<li>instance = new SingletonTest();</li>
<li>}</li>
<li>}
1.</li>
<li>public static SingletonTest getInstance() {</li>
<li>if (instance == null) {</li>
<li>syncInit();</li>
<li>}</li>
<li>return instance;</li>
<li>}</li>
<li>}</li>
</ol>
<p>考虑性能的话，整个程序只需创建一次实例，所以性能也不会有什么影响。</p>
<p><strong>补充：采用&quot;影子实例&quot;的办法为单例对象的属性同步更新</strong>
<strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8194653" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8194653" title="copy" target="_blank">copy</a></p>
<ol>
<li>public class SingletonTest {
1.</li>
<li>private static SingletonTest instance = null;</li>
<li>private Vector properties = null;
1.</li>
<li>public Vector getProperties() {</li>
<li>return properties;</li>
<li>}
1.</li>
<li>private SingletonTest() {</li>
<li>}
1.</li>
<li>private static synchronized void syncInit() {</li>
<li>if (instance == null) {</li>
<li>instance = new SingletonTest();</li>
<li>}</li>
<li>}
1.</li>
<li>public static SingletonTest getInstance() {</li>
<li>if (instance == null) {</li>
<li>syncInit();</li>
<li>}</li>
<li>return instance;</li>
<li>}
1.</li>
<li>public void updateProperties() {</li>
<li>SingletonTest shadow = new SingletonTest();</li>
<li>properties = shadow.getProperties();</li>
<li>}</li>
<li>}</li>
</ol>
<p>通过单例模式的学习告诉我们：</p>
<p>1、单例模式理解起来简单，但是具体实现起来还是有一定的难度。</p>
<p>2、synchronized关键字锁定的是对象，在用的时候，一定要在恰当的地方使用（注意需要使用锁的对象和过程，可能有的时候并不是整个对象及整个过程都需要锁）。</p>
<p>到这儿，单例模式基本已经讲完了，结尾处，笔者突然想到另一个问题，就是采用类的静态方法，实现单例模式的效果，也是可行的，此处二者有什么不同？</p>
<p>首先，静态类不能实现接口。（从类的角度说是可以的，但是那样就破坏了静态了。因为接口中不允许有static修饰的方法，所以即使实现了也是非静态的）</p>
<p>其次，单例可以被延迟初始化，静态类一般在第一次加载是初始化。之所以延迟加载，是因为有些类比较庞大，所以延迟加载有助于提升性能。</p>
<p>再次，单例类可以被继承，他的方法可以被覆写。但是静态类内部方法都是static，无法被覆写。</p>
<p>最后一点，单例类比较灵活，毕竟从实现上只是一个普通的Java类，只要满足单例的基本需求，你可以在里面随心所欲的实现一些其它功能，但是静态类不行。从上面这些概括中，基本可以看出二者的区别，但是，从另一方面讲，我们上面最后实现的那个单例模式，内部就是用一个静态类来实现的，所以，二者有很大的关联，只是我们考虑问题的层面不同罢了。两种思想的结合，才能造就出完美的解决方案，就像HashMap采用数组+链表来实现一样，其实生活中很多事情都是这样，单用不同的方法来处理问题，总是有优点也有缺点，最完美的方法是，结合各个方法的优点，才能最好的解决问题！</p>
<p><strong>4、建造者模式（Builder）</strong></p>
<p>工厂类模式提供的是创建单个类的模式，而建造者模式则是将各种产品集中起来进行管理，用来创建复合对象，所谓复合对象就是指某个类具有不同的属性，其实建造者模式就是前面抽象工厂模式和最后的Test结合起来得到的。我们看一下代码：</p>
<p>还和前面一样，一个Sender接口，两个实现类MailSender和SmsSender。最后，建造者类如下：
<strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8194653" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8194653" title="copy" target="_blank">copy</a></p>
<ol>
<li>public class Builder {
1.</li>
<li>private List<Sender> list = new ArrayList<Sender>();
1.</li>
<li>public void produceMailSender(int count){</li>
<li>for(int i=0; i&lt;count; i++){</li>
<li>list.add(new MailSender());</li>
<li>}</li>
<li>}
1.</li>
<li>public void produceSmsSender(int count){</li>
<li>for(int i=0; i&lt;count; i++){</li>
<li>list.add(new SmsSender());</li>
<li>}</li>
<li>}</li>
<li>}</li>
</ol>
<p>测试类：</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8194653" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8194653" title="copy" target="_blank">copy</a></p>
<ol>
<li>public class Test {
1.</li>
<li>public static void main(String[] args) {</li>
<li>Builder builder = new Builder();</li>
<li>builder.produceMailSender(10);</li>
<li>}</li>
<li>}</li>
</ol>
<p>从这点看出，建造者模式将很多功能集成到一个类里，这个类可以创造出比较复杂的东西。所以与工程模式的区别就是：工厂模式关注的是创建单个产品，而建造者模式则关注创建符合对象，多个部分。因此，是选择工厂模式还是建造者模式，依实际情况而定。</p>
<p><strong>5、原型模式（Prototype）</strong></p>
<p>原型模式虽然是创建型的模式，但是与工程模式没有关系，从名字即可看出，该模式的思想就是将一个对象作为原型，对其进行复制、克隆，产生一个和原对象类似的新对象。本小结会通过对象的复制，进行讲解。在Java中，复制对象是通过clone()实现的，先创建一个原型类：
<strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8194653" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8194653" title="copy" target="_blank">copy</a></p>
<ol>
<li>public class Prototype implements Cloneable {
1.</li>
<li>public Object clone() throws CloneNotSupportedException {</li>
<li>Prototype proto = (Prototype) super.clone();</li>
<li>return proto;</li>
<li>}</li>
<li>}</li>
</ol>
<p>很简单，一个原型类，只需要实现Cloneable接口，覆写clone方法，此处clone方法可以改成任意的名称，因为Cloneable接口是个空接口，你可以任意定义实现类的方法名，如cloneA或者cloneB，因为此处的重点是super.clone()这句话，super.clone()调用的是Object的clone()方法，而在Object类中，clone()是native的，具体怎么实现，我会在另一篇文章中，关于解读Java中本地方法的调用，此处不再深究。在这儿，我将结合对象的浅复制和深复制来说一下，首先需要了解对象深、浅复制的概念：</p>
<p>浅复制：将一个对象复制后，基本数据类型的变量都会重新创建，而引用类型，指向的还是原对象所指向的。</p>
<p>深复制：将一个对象复制后，不论是基本数据类型还有引用类型，都是重新创建的。简单来说，就是深复制进行了完全彻底的复制，而浅复制不彻底。</p>
<p>此处，写一个深浅复制的例子：
<strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8194653" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8194653" title="copy" target="_blank">copy</a></p>
<ol>
<li>public class Prototype implements Cloneable, Serializable {
1.</li>
<li>private static final long serialVersionUID = 1L;</li>
<li>private String string;
1.</li>
<li>private SerializableObject obj;
1.</li>
<li>//<em> 浅复制 /</em>/</li>
<li>public Object clone() throws CloneNotSupportedException {</li>
<li>Prototype proto = (Prototype) super.clone();</li>
<li>return proto;</li>
<li>}
1.</li>
<li>//<em> 深复制 /</em>/</li>
<li>public Object deepClone() throws IOException, ClassNotFoundException {
1.</li>
<li>//<em> 写入当前对象的二进制流 /</em>/</li>
<li>ByteArrayOutputStream bos = new ByteArrayOutputStream();</li>
<li>ObjectOutputStream oos = new ObjectOutputStream(bos);</li>
<li>oos.writeObject(this);
1.</li>
<li>//<em> 读出二进制流产生的新对象 /</em>/</li>
<li>ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());</li>
<li>ObjectInputStream ois = new ObjectInputStream(bis);</li>
<li>return ois.readObject();</li>
<li>}
1.</li>
<li>public String getString() {</li>
<li>return string;</li>
<li>}
1.</li>
<li>public void setString(String string) {</li>
<li>this.string = string;</li>
<li>}
1.</li>
<li>public SerializableObject getObj() {</li>
<li>return obj;</li>
<li>}
1.</li>
<li>public void setObj(SerializableObject obj) {</li>
<li>this.obj = obj;</li>
<li>}
1.</li>
<li>}
1.</li>
<li>class SerializableObject implements Serializable {</li>
<li>private static final long serialVersionUID = 1L;</li>
<li>}</li>
</ol>
<p>要实现深复制，需要采用流的形式读入当前对象的二进制输入，再写出二进制数据对应的对象。
我们接着讨论设计模式，上篇文章我讲完了5种创建型模式，这章开始，我将讲下7种结构型模式：适配器模式、装饰模式、代理模式、外观模式、桥接模式、组合模式、享元模式。其中对象的适配器模式是各种模式的起源，我们看下面的图：</p>
<p><img src="&quot;点击查看原始大小图片&quot;" alt=""></p>
<p>适配器模式将某个类的接口转换成客户端期望的另一个接口表示，目的是消除由于接口不匹配所造成的类的兼容性问题。主要分为三类：类的适配器模式、对象的适配器模式、接口的适配器模式。首先，我们来看看<strong>类的适配器模式</strong>，先看类图：</p>
<p><img src="" alt=""></p>
<p>核心思想就是：有一个Source类，拥有一个方法，待适配，目标接口时Targetable，通过Adapter类，将Source的功能扩展到Targetable里，看代码：
<strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8239539" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8239539" title="copy" target="_blank">copy</a></p>
<ol>
<li>public class Source {
1.</li>
<li>public void method1() {</li>
<li>System.out.println(&quot;this is original method!&quot;);</li>
<li>}</li>
<li>}</li>
</ol>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8239539" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8239539" title="copy" target="_blank">copy</a></p>
<ol>
<li>public interface Targetable {
1.</li>
<li>//<em> 与原类中的方法相同 /</em>/</li>
<li>public void method1();
1.</li>
<li>//<em> 新类的方法 /</em>/</li>
<li>public void method2();</li>
<li><p>}
<strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8239539" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8239539" title="copy" target="_blank">copy</a></p>
</li>
<li><p>public class Adapter extends Source implements Targetable {
1.</p>
</li>
<li>@Override</li>
<li>public void method2() {</li>
<li>System.out.println(&quot;this is the targetable method!&quot;);</li>
<li>}</li>
<li>}</li>
</ol>
<p>Adapter类继承Source类，实现Targetable接口，下面是测试类：</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8239539" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8239539" title="copy" target="_blank">copy</a></p>
<ol>
<li>public class AdapterTest {
1.</li>
<li>public static void main(String[] args) {</li>
<li>Targetable target = new Adapter();</li>
<li>target.method1();</li>
<li>target.method2();</li>
<li>}</li>
<li>}</li>
</ol>
<p>输出：</p>
<p>this is original method!
this is the targetable method!</p>
<p>这样Targetable接口的实现类就具有了Source类的功能。</p>
<p><strong>对象的适配器模式</strong></p>
<p>基本思路和类的适配器模式相同，只是将Adapter类作修改，这次不继承Source类，而是持有Source类的实例，以达到解决兼容性的问题。看图：</p>
<p><img src="" alt=""></p>
<p>只需要修改Adapter类的源码即可：
<strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8239539" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8239539" title="copy" target="_blank">copy</a></p>
<ol>
<li>public class Wrapper implements Targetable {
1.</li>
<li>private Source source;
1.</li>
<li>public Wrapper(Source source){</li>
<li>super();</li>
<li>this.source = source;</li>
<li>}</li>
<li>@Override</li>
<li>public void method2() {</li>
<li>System.out.println(&quot;this is the targetable method!&quot;);</li>
<li>}
1.</li>
<li>@Override</li>
<li>public void method1() {</li>
<li>source.method1();</li>
<li>}</li>
<li>}</li>
</ol>
<p>测试类：</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8239539" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8239539" title="copy" target="_blank">copy</a></p>
<ol>
<li>public class AdapterTest {
1.</li>
<li>public static void main(String[] args) {</li>
<li>Source source = new Source();</li>
<li>Targetable target = new Wrapper(source);</li>
<li>target.method1();</li>
<li>target.method2();</li>
<li>}</li>
<li>}</li>
</ol>
<p>输出与第一种一样，只是适配的方法不同而已。</p>
<p>第三种适配器模式是<strong>接口的适配器模式</strong>，接口的适配器是这样的：有时我们写的一个接口中有多个抽象方法，当我们写该接口的实现类时，必须实现该接口的所有方法，这明显有时比较浪费，因为并不是所有的方法都是我们需要的，有时只需要某一些，此处为了解决这个问题，我们引入了接口的适配器模式，借助于一个抽象类，该抽象类实现了该接口，实现了所有的方法，而我们不和原始的接口打交道，只和该抽象类取得联系，所以我们写一个类，继承该抽象类，重写我们需要的方法就行。看一下类图：</p>
<p><img src="" alt=""></p>
<p>这个很好理解，在实际开发中，我们也常会遇到这种接口中定义了太多的方法，以致于有时我们在一些实现类中并不是都需要。看代码：
<strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8239539" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8239539" title="copy" target="_blank">copy</a></p>
<ol>
<li>public interface Sourceable {
1.</li>
<li>public void method1();</li>
<li>public void method2();</li>
<li>}</li>
</ol>
<p>抽象类Wrapper2：</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8239539" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8239539" title="copy" target="_blank">copy</a></p>
<ol>
<li>public abstract class Wrapper2 implements Sourceable{
1.</li>
<li>public void method1(){}</li>
<li>public void method2(){}</li>
<li>}</li>
</ol>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8239539" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8239539" title="copy" target="_blank">copy</a></p>
<ol>
<li>public class SourceSub1 extends Wrapper2 {</li>
<li>public void method1(){</li>
<li>System.out.println(&quot;the sourceable interface&#39;s first Sub1!&quot;);</li>
<li>}</li>
<li><p>}
<strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8239539" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8239539" title="copy" target="_blank">copy</a></p>
</li>
<li><p>public class SourceSub2 extends Wrapper2 {</p>
</li>
<li>public void method2(){</li>
<li>System.out.println(&quot;the sourceable interface&#39;s second Sub2!&quot;);</li>
<li>}</li>
<li>}</li>
</ol>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8239539" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8239539" title="copy" target="_blank">copy</a></p>
<ol>
<li>public class WrapperTest {
1.</li>
<li>public static void main(String[] args) {</li>
<li>Sourceable source1 = new SourceSub1();</li>
<li>Sourceable source2 = new SourceSub2();
1.</li>
<li>source1.method1();</li>
<li>source1.method2();</li>
<li>source2.method1();</li>
<li>source2.method2();</li>
<li>}</li>
<li>}</li>
</ol>
<p>测试输出：</p>
<p>the sourceable interface&#39;s first Sub1!
the sourceable interface&#39;s second Sub2!</p>
<p>达到了我们的效果！</p>
<p>讲了这么多，总结一下三种适配器模式的应用场景：</p>
<p>类的适配器模式：当希望将<strong>一个类</strong>转换成满足<strong>另一个新接口</strong>的类时，可以使用类的适配器模式，创建一个新类，继承原有的类，实现新的接口即可。</p>
<p>对象的适配器模式：当希望将一个对象转换成满足另一个新接口的对象时，可以创建一个Wrapper类，持有原类的一个实例，在Wrapper类的方法中，调用实例的方法就行。</p>
<p>接口的适配器模式：当不希望实现一个接口中所有的方法时，可以创建一个抽象类Wrapper，实现所有方法，我们写别的类的时候，继承抽象类即可。</p>
<p><strong>7、装饰模式（Decorator）</strong></p>
<p>顾名思义，装饰模式就是给一个对象增加一些新的功能，而且是动态的，要求装饰对象和被装饰对象实现同一个接口，装饰对象持有被装饰对象的实例，关系图如下：</p>
<p><img src="" alt=""></p>
<p>Source类是被装饰类，Decorator类是一个装饰类，可以为Source类动态的添加一些功能，代码如下：
<strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8239539" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8239539" title="copy" target="_blank">copy</a></p>
<ol>
<li>public interface Sourceable {</li>
<li>public void method();</li>
<li>}</li>
</ol>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8239539" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8239539" title="copy" target="_blank">copy</a></p>
<ol>
<li>public class Source implements Sourceable {
1.</li>
<li>@Override</li>
<li>public void method() {</li>
<li>System.out.println(&quot;the original method!&quot;);</li>
<li>}</li>
<li><p>}
<strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8239539" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8239539" title="copy" target="_blank">copy</a></p>
</li>
<li><p>public class Decorator implements Sourceable {
1.</p>
</li>
<li>private Sourceable source;
1.</li>
<li>public Decorator(Sourceable source){</li>
<li>super();</li>
<li>this.source = source;</li>
<li>}</li>
<li>@Override</li>
<li>public void method() {</li>
<li>System.out.println(&quot;before decorator!&quot;);</li>
<li>source.method();</li>
<li>System.out.println(&quot;after decorator!&quot;);</li>
<li>}</li>
<li>}</li>
</ol>
<p>测试类：</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8239539" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8239539" title="copy" target="_blank">copy</a></p>
<ol>
<li>public class DecoratorTest {
1.</li>
<li>public static void main(String[] args) {</li>
<li>Sourceable source = new Source();</li>
<li>Sourceable obj = new Decorator(source);</li>
<li>obj.method();</li>
<li>}</li>
<li>}</li>
</ol>
<p>输出：</p>
<p>before decorator!
the original method!
after decorator!</p>
<p>装饰器模式的应用场景：</p>
<p>1、需要扩展一个类的功能。</p>
<p>2、动态的为一个对象增加功能，而且还能动态撤销。（继承不能做到这一点，继承的功能是静态的，不能动态增删。）</p>
<p>缺点：产生过多相似的对象，不易排错！</p>
<p><strong>8、代理模式（Proxy）</strong></p>
<p>其实每个模式名称就表明了该模式的作用，代理模式就是多一个代理类出来，替原对象进行一些操作，比如我们在租房子的时候回去找中介，为什么呢？因为你对该地区房屋的信息掌握的不够全面，希望找一个更熟悉的人去帮你做，此处的代理就是这个意思。再如我们有的时候打官司，我们需要请律师，因为律师在法律方面有专长，可以替我们进行操作，表达我们的想法。先来看看关系图：<img src="" alt=""></p>
<p>根据上文的阐述，代理模式就比较容易的理解了，我们看下代码：
<strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8239539" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8239539" title="copy" target="_blank">copy</a></p>
<ol>
<li>public interface Sourceable {</li>
<li>public void method();</li>
<li>}</li>
</ol>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8239539" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8239539" title="copy" target="_blank">copy</a></p>
<ol>
<li>public class Source implements Sourceable {
1.</li>
<li>@Override</li>
<li>public void method() {</li>
<li>System.out.println(&quot;the original method!&quot;);</li>
<li>}</li>
<li><p>}
<strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8239539" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8239539" title="copy" target="_blank">copy</a></p>
</li>
<li><p>public class Proxy implements Sourceable {
1.</p>
</li>
<li>private Source source;</li>
<li>public Proxy(){</li>
<li>super();</li>
<li>this.source = new Source();</li>
<li>}</li>
<li>@Override</li>
<li>public void method() {</li>
<li>before();</li>
<li>source.method();</li>
<li>atfer();</li>
<li>}</li>
<li>private void atfer() {</li>
<li>System.out.println(&quot;after proxy!&quot;);</li>
<li>}</li>
<li>private void before() {</li>
<li>System.out.println(&quot;before proxy!&quot;);</li>
<li>}</li>
<li>}</li>
</ol>
<p>测试类：</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8239539" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8239539" title="copy" target="_blank">copy</a></p>
<ol>
<li>public class ProxyTest {
1.</li>
<li>public static void main(String[] args) {</li>
<li>Sourceable source = new Proxy();</li>
<li>source.method();</li>
<li>}
1.</li>
<li>}</li>
</ol>
<p>输出：</p>
<p>before proxy!
the original method!
after proxy!</p>
<p>代理模式的应用场景：</p>
<p>如果已有的方法在使用的时候需要对原有的方法进行改进，此时有两种办法：</p>
<p>1、修改原有的方法来适应。这样违反了“对扩展开放，对修改关闭”的原则。</p>
<p>2、就是采用一个代理类调用原有的方法，且对产生的结果进行控制。这种方法就是代理模式。</p>
<p>使用代理模式，可以将功能划分的更加清晰，有助于后期维护！</p>
<p><strong>9、外观模式（Facade）</strong></p>
<p>外观模式是为了解决类与类之家的依赖关系的，像spring一样，可以将类和类之间的关系配置到配置文件中，而外观模式就是将他们的关系放在一个Facade类中，降低了类类之间的耦合度，该模式中没有涉及到接口，看下类图：（我们以一个计算机的启动过程为例）</p>
<p><img src="" alt=""></p>
<p>我们先看下实现类：
<strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8239539" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8239539" title="copy" target="_blank">copy</a></p>
<ol>
<li>public class CPU {
1.</li>
<li>public void startup(){</li>
<li>System.out.println(&quot;cpu startup!&quot;);</li>
<li>}
1.</li>
<li>public void shutdown(){</li>
<li>System.out.println(&quot;cpu shutdown!&quot;);</li>
<li>}</li>
<li>}</li>
</ol>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8239539" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8239539" title="copy" target="_blank">copy</a></p>
<ol>
<li>public class Memory {
1.</li>
<li>public void startup(){</li>
<li>System.out.println(&quot;memory startup!&quot;);</li>
<li>}
1.</li>
<li>public void shutdown(){</li>
<li>System.out.println(&quot;memory shutdown!&quot;);</li>
<li>}</li>
<li><p>}
<strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8239539" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8239539" title="copy" target="_blank">copy</a></p>
</li>
<li><p>public class Disk {
1.</p>
</li>
<li>public void startup(){</li>
<li>System.out.println(&quot;disk startup!&quot;);</li>
<li>}
1.</li>
<li>public void shutdown(){</li>
<li>System.out.println(&quot;disk shutdown!&quot;);</li>
<li>}</li>
<li>}</li>
</ol>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8239539" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8239539" title="copy" target="_blank">copy</a></p>
<ol>
<li>public class Computer {</li>
<li>private CPU cpu;</li>
<li>private Memory memory;</li>
<li>private Disk disk;
1.</li>
<li>public Computer(){</li>
<li>cpu = new CPU();</li>
<li>memory = new Memory();</li>
<li>disk = new Disk();</li>
<li>}
1.</li>
<li>public void startup(){</li>
<li>System.out.println(&quot;start the computer!&quot;);</li>
<li>cpu.startup();</li>
<li>memory.startup();</li>
<li>disk.startup();</li>
<li>System.out.println(&quot;start computer finished!&quot;);</li>
<li>}
1.</li>
<li>public void shutdown(){</li>
<li>System.out.println(&quot;begin to close the computer!&quot;);</li>
<li>cpu.shutdown();</li>
<li>memory.shutdown();</li>
<li>disk.shutdown();</li>
<li>System.out.println(&quot;computer closed!&quot;);</li>
<li>}</li>
<li>}</li>
</ol>
<p>User类如下：
<strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8239539" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8239539" title="copy" target="_blank">copy</a></p>
<ol>
<li>public class User {
1.</li>
<li>public static void main(String[] args) {</li>
<li>Computer computer = new Computer();</li>
<li>computer.startup();</li>
<li>computer.shutdown();</li>
<li>}</li>
<li>}</li>
</ol>
<p>输出：</p>
<p>start the computer!
cpu startup!
memory startup!
disk startup!
start computer finished!
begin to close the computer!
cpu shutdown!
memory shutdown!
disk shutdown!
computer closed!</p>
<p>如果我们没有Computer类，那么，CPU、Memory、Disk他们之间将会相互持有实例，产生关系，这样会造成严重的依赖，修改一个类，可能会带来其他类的修改，这不是我们想要看到的，有了Computer类，他们之间的关系被放在了Computer类里，这样就起到了解耦的作用，这，就是外观模式！</p>
<p><strong>10、桥接模式（Bridge）</strong></p>
<p>桥接模式就是把事物和其具体实现分开，使他们可以各自独立的变化。桥接的用意是：<strong>将抽象化与实现化解耦，使得二者可以独立变化</strong>，像我们常用的JDBC桥DriverManager一样，JDBC进行连接数据库的时候，在各个数据库之间进行切换，基本不需要动太多的代码，甚至丝毫不用动，原因就是JDBC提供统一接口，每个数据库提供各自的实现，用一个叫做数据库驱动的程序来桥接就行了。我们来看看关系图：</p>
<p><img src="" alt=""></p>
<p>实现代码：</p>
<p>先定义接口：
<strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8239539" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8239539" title="copy" target="_blank">copy</a></p>
<ol>
<li>public interface Sourceable {</li>
<li>public void method();</li>
<li>}</li>
</ol>
<p>分别定义两个实现类：</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8239539" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8239539" title="copy" target="_blank">copy</a></p>
<ol>
<li>public class SourceSub1 implements Sourceable {
1.</li>
<li>@Override</li>
<li>public void method() {</li>
<li>System.out.println(&quot;this is the first sub!&quot;);</li>
<li>}</li>
<li>}</li>
</ol>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8239539" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8239539" title="copy" target="_blank">copy</a></p>
<ol>
<li>public class SourceSub2 implements Sourceable {
1.</li>
<li>@Override</li>
<li>public void method() {</li>
<li>System.out.println(&quot;this is the second sub!&quot;);</li>
<li>}</li>
<li>}</li>
</ol>
<p>定义一个桥，持有Sourceable的一个实例：
<strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8239539" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8239539" title="copy" target="_blank">copy</a></p>
<ol>
<li>public abstract class Bridge {</li>
<li>private Sourceable source;
1.</li>
<li>public void method(){</li>
<li>source.method();</li>
<li>}
1.</li>
<li>public Sourceable getSource() {</li>
<li>return source;</li>
<li>}
1.</li>
<li>public void setSource(Sourceable source) {</li>
<li>this.source = source;</li>
<li>}</li>
<li>}</li>
</ol>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8239539" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8239539" title="copy" target="_blank">copy</a></p>
<ol>
<li>public class MyBridge extends Bridge {</li>
<li>public void method(){</li>
<li>getSource().method();</li>
<li>}</li>
<li>}</li>
</ol>
<p>测试类：
<strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8239539" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8239539" title="copy" target="_blank">copy</a></p>
<ol>
<li>public class BridgeTest {
1.</li>
<li>public static void main(String[] args) {
1.</li>
<li>Bridge bridge = new MyBridge();
1.</li>
<li>//<em>调用第一个对象/</em>/</li>
<li>Sourceable source1 = new SourceSub1();</li>
<li>bridge.setSource(source1);</li>
<li>bridge.method();
1.</li>
<li>//<em>调用第二个对象/</em>/</li>
<li>Sourceable source2 = new SourceSub2();</li>
<li>bridge.setSource(source2);</li>
<li>bridge.method();</li>
<li>}</li>
<li>}</li>
</ol>
<p>output：</p>
<p>this is the first sub!
this is the second sub!</p>
<p>这样，就通过对Bridge类的调用，实现了对接口Sourceable的实现类SourceSub1和SourceSub2的调用。接下来我再画个图，大家就应该明白了，因为这个图是我们JDBC连接的原理，有数据库学习基础的，一结合就都懂了。</p>
<p><img src="" alt=""></p>
<p><strong>11、组合模式（Composite）</strong></p>
<p>组合模式有时又叫<strong>部分-整体</strong>模式在处理类似树形结构的问题时比较方便，看看关系图：</p>
<p><img src="" alt=""></p>
<p>直接来看代码：
<strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8239539" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8239539" title="copy" target="_blank">copy</a></p>
<ol>
<li>public class TreeNode {
1.</li>
<li>private String name;</li>
<li>private TreeNode parent;</li>
<li>private Vector<TreeNode> children = new Vector<TreeNode>();
1.</li>
<li>public TreeNode(String name){</li>
<li>this.name = name;</li>
<li>}
1.</li>
<li>public String getName() {</li>
<li>return name;</li>
<li>}
1.</li>
<li>public void setName(String name) {</li>
<li>this.name = name;</li>
<li>}
1.</li>
<li>public TreeNode getParent() {</li>
<li>return parent;</li>
<li>}
1.</li>
<li>public void setParent(TreeNode parent) {</li>
<li>this.parent = parent;</li>
<li>}
1.</li>
<li>//添加孩子节点</li>
<li>public void add(TreeNode node){</li>
<li>children.add(node);</li>
<li>}
1.</li>
<li>//删除孩子节点</li>
<li>public void remove(TreeNode node){</li>
<li>children.remove(node);</li>
<li>}
1.</li>
<li>//取得孩子节点</li>
<li>public Enumeration<TreeNode> getChildren(){</li>
<li>return children.elements();</li>
<li>}</li>
<li>}</li>
</ol>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8239539" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8239539" title="copy" target="_blank">copy</a></p>
<ol>
<li>public class Tree {
1.</li>
<li>TreeNode root = null;
1.</li>
<li>public Tree(String name) {</li>
<li>root = new TreeNode(name);</li>
<li>}
1.</li>
<li>public static void main(String[] args) {</li>
<li>Tree tree = new Tree(&quot;A&quot;);</li>
<li>TreeNode nodeB = new TreeNode(&quot;B&quot;);</li>
<li>TreeNode nodeC = new TreeNode(&quot;C&quot;);
1.</li>
<li>nodeB.add(nodeC);</li>
<li>tree.root.add(nodeB);</li>
<li>System.out.println(&quot;build the tree finished!&quot;);</li>
<li>}</li>
<li>}</li>
</ol>
<p>使用场景：将多个对象组合在一起进行操作，常用于表示树形结构中，例如二叉树，数等。</p>
<p><strong>12、享元模式（Flyweight）</strong></p>
<p>享元模式的主要目的是实现对象的共享，即共享池，当系统中对象多的时候可以减少内存的开销，通常与工厂模式一起使用。</p>
<p><img src="" alt=""></p>
<p>FlyWeightFactory负责创建和管理享元单元，当一个客户端请求时，工厂需要检查当前对象池中是否有符合条件的对象，如果有，就返回已经存在的对象，如果没有，则创建一个新对象，FlyWeight是超类。一提到共享池，我们很容易联想到Java里面的JDBC连接池，想想每个连接的特点，我们不难总结出：适用于作共享的一些个对象，他们有一些共有的属性，就拿数据库连接池来说，url、driverClassName、username、password及dbname，这些属性对于每个连接来说都是一样的，所以就适合用享元模式来处理，建一个工厂类，将上述类似属性作为内部数据，其它的作为外部数据，在方法调用时，当做参数传进来，这样就节省了空间，减少了实例的数量。</p>
<p>看个例子：</p>
<p><img src="" alt=""></p>
<p>看下数据库连接池的代码：
<strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8239539" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8239539" title="copy" target="_blank">copy</a></p>
<ol>
<li>public class ConnectionPool {
1.</li>
<li>private Vector<Connection> pool;
1.</li>
<li>//<em>公有属性/</em>/</li>
<li>private String url = &quot;jdbc:mysql://localhost:3306/test&quot;;</li>
<li>private String username = &quot;root&quot;;</li>
<li>private String password = &quot;root&quot;;</li>
<li>private String driverClassName = &quot;com.mysql.jdbc.Driver&quot;;
1.</li>
<li>private int poolSize = 100;</li>
<li>private static ConnectionPool instance = null;</li>
<li>Connection conn = null;
1.</li>
<li>//<em>构造方法，做一些初始化工作/</em>/</li>
<li>private ConnectionPool() {</li>
<li>pool = new Vector<Connection>(poolSize);
1.</li>
<li>for (int i = 0; i &lt; poolSize; i++) {</li>
<li>try {</li>
<li>Class.forName(driverClassName);</li>
<li>conn = DriverManager.getConnection(url, username, password);</li>
<li>pool.add(conn);</li>
<li>} catch (ClassNotFoundException e) {</li>
<li>e.printStackTrace();</li>
<li>} catch (SQLException e) {</li>
<li>e.printStackTrace();</li>
<li>}</li>
<li>}</li>
<li>}
1.</li>
<li>//<em> 返回连接到连接池 /</em>/</li>
<li>public synchronized void release() {</li>
<li>pool.add(conn);</li>
<li>}
1.</li>
<li>//<em> 返回连接池中的一个数据库连接 /</em>/</li>
<li>public synchronized Connection getConnection() {</li>
<li>if (pool.size() &gt; 0) {</li>
<li>Connection conn = pool.get(0);</li>
<li>pool.remove(conn);</li>
<li>return conn;</li>
<li>} else {</li>
<li>return null;</li>
<li>}</li>
<li>}</li>
<li>}</li>
</ol>
<p>通过连接池的管理，实现了数据库连接的共享，不需要每一次都重新创建连接，节省了数据库重新创建的开销，提升了系统的性能！本章讲解了7种结构型模式，因为篇幅的问题，剩下的11种行为型模式，</p>
<p>本章是关于设计模式的最后一讲，会讲到第三种设计模式——行为型模式，共11种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。这段时间一直在写关于设计模式的东西，终于写到一半了，写博文是个很费时间的东西，因为我得为读者负责，不论是图还是代码还是表述，都希望能尽量写清楚，以便读者理解，我想不论是我还是读者，都希望看到高质量的博文出来，从我本人出发，我会一直坚持下去，不断更新，源源动力来自于读者朋友们的不断支持，我会尽自己的努力，写好每一篇文章！希望大家能不断给出意见和建议，共同打造完美的博文！</p>
<hr>
<hr>
<p>先来张图，看看这11中模式的关系：</p>
<p>第一类：通过父类与子类的关系进行实现。第二类：两个类之间。第三类：类的状态。第四类：通过中间类</p>
<p><img src="" alt=""></p>
<p><strong>13、策略模式（strategy）</strong></p>
<p>策略模式定义了一系列算法，并将每个算法封装起来，使他们可以相互替换，且算法的变化不会影响到使用算法的客户。需要设计一个接口，为一系列实现类提供统一的方法，多个实现类实现该接口，设计一个抽象类（可有可无，属于辅助类），提供辅助函数，关系图如下：</p>
<p><img src="" alt=""></p>
<p>图中ICalculator提供同意的方法，
AbstractCalculator是辅助类，提供辅助方法，接下来，依次实现下每个类：</p>
<p>首先统一接口：
<strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8243942" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8243942" title="copy" target="_blank">copy</a></p>
<ol>
<li>public interface ICalculator {</li>
<li>public int calculate(String exp);</li>
<li>}</li>
</ol>
<p>辅助类：</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8243942" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8243942" title="copy" target="_blank">copy</a></p>
<ol>
<li>public abstract class AbstractCalculator {
1.</li>
<li>public int[] split(String exp,String opt){</li>
<li>String array[] = exp.split(opt);</li>
<li>int arrayInt[] = new int[2];</li>
<li>arrayInt[0] = Integer.parseInt(array[0]);</li>
<li>arrayInt[1] = Integer.parseInt(array[1]);</li>
<li>return arrayInt;</li>
<li>}</li>
<li>}</li>
</ol>
<p>三个实现类：</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8243942" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8243942" title="copy" target="_blank">copy</a></p>
<ol>
<li>public class Plus extends AbstractCalculator implements ICalculator {
1.</li>
<li>@Override</li>
<li>public int calculate(String exp) {</li>
<li>int arrayInt[] = split(exp,&quot;\+&quot;);</li>
<li>return arrayInt[0]+arrayInt[1];</li>
<li>}</li>
<li>}</li>
</ol>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8243942" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8243942" title="copy" target="_blank">copy</a></p>
<ol>
<li>public class Minus extends AbstractCalculator implements ICalculator {
1.</li>
<li>@Override</li>
<li>public int calculate(String exp) {</li>
<li>int arrayInt[] = split(exp,&quot;-&quot;);</li>
<li>return arrayInt[0]-arrayInt[1];</li>
<li>}
1.</li>
<li><p>}
<strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8243942" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8243942" title="copy" target="_blank">copy</a></p>
</li>
<li><p>public class Multiply extends AbstractCalculator implements ICalculator {
1.</p>
</li>
<li>@Override</li>
<li>public int calculate(String exp) {</li>
<li>int arrayInt[] = split(exp,&quot;\/*&quot;);</li>
<li>return arrayInt[0]/*arrayInt[1];</li>
<li>}</li>
<li>}</li>
</ol>
<p>简单的测试类：</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8243942" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8243942" title="copy" target="_blank">copy</a></p>
<ol>
<li>public class StrategyTest {
1.</li>
<li>public static void main(String[] args) {</li>
<li>String exp = &quot;2+8&quot;;</li>
<li>ICalculator cal = new Plus();</li>
<li>int result = cal.calculate(exp);</li>
<li>System.out.println(result);</li>
<li>}</li>
<li>}</li>
</ol>
<p>输出：10</p>
<p>策略模式的决定权在用户，系统本身提供不同算法的实现，新增或者删除算法，对各种算法做封装。因此，策略模式多用在算法决策系统中，外部用户只需要决定用哪个算法即可。</p>
<p><strong>14、模板方法模式（Template Method）</strong></p>
<p>解释一下模板方法模式，就是指：一个抽象类中，有一个主方法，再定义1...n个方法，可以是抽象的，也可以是实际的方法，定义一个类，继承该抽象类，重写抽象方法，通过调用抽象类，实现对子类的调用，先看个关系图：</p>
<p><img src="" alt=""></p>
<p>就是在AbstractCalculator类中定义一个主方法calculate，calculate()调用spilt()等，Plus和Minus分别继承AbstractCalculator类，通过对AbstractCalculator的调用实现对子类的调用，看下面的例子：
<strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8243942" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8243942" title="copy" target="_blank">copy</a></p>
<ol>
<li>public abstract class AbstractCalculator {
1.</li>
<li>//<em>主方法，实现对本类其它方法的调用/</em>/</li>
<li>public final int calculate(String exp,String opt){</li>
<li>int array[] = split(exp,opt);</li>
<li>return calculate(array[0],array[1]);</li>
<li>}
1.</li>
<li>//<em>被子类重写的方法/</em>/</li>
<li>abstract public int calculate(int num1,int num2);
1.</li>
<li>public int[] split(String exp,String opt){</li>
<li>String array[] = exp.split(opt);</li>
<li>int arrayInt[] = new int[2];</li>
<li>arrayInt[0] = Integer.parseInt(array[0]);</li>
<li>arrayInt[1] = Integer.parseInt(array[1]);</li>
<li>return arrayInt;</li>
<li>}</li>
<li>}</li>
</ol>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8243942" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8243942" title="copy" target="_blank">copy</a></p>
<ol>
<li>public class Plus extends AbstractCalculator {
1.</li>
<li>@Override</li>
<li>public int calculate(int num1,int num2) {</li>
<li>return num1 + num2;</li>
<li>}</li>
<li>}</li>
</ol>
<p>测试类：
<strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8243942" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8243942" title="copy" target="_blank">copy</a></p>
<ol>
<li>public class StrategyTest {
1.</li>
<li>public static void main(String[] args) {</li>
<li>String exp = &quot;8+8&quot;;</li>
<li>AbstractCalculator cal = new Plus();</li>
<li>int result = cal.calculate(exp, &quot;\+&quot;);</li>
<li>System.out.println(result);</li>
<li>}</li>
<li>}</li>
</ol>
<p>我跟踪下这个小程序的执行过程：首先将exp和&quot;\+&quot;做参数，调用AbstractCalculator类里的calculate(String,String)方法，在calculate(String,String)里调用同类的split()，之后再调用calculate(int ,int)方法，从这个方法进入到子类中，执行完return num1 + num2后，将值返回到AbstractCalculator类，赋给result，打印出来。正好验证了我们开头的思路。</p>
<p><strong>15、观察者模式（Observer）</strong></p>
<p>包括这个模式在内的接下来的四个模式，都是类和类之间的关系，不涉及到继承，学的时候应该 记得归纳，记得本文最开始的那个图。观察者模式很好理解，类似于邮件订阅和RSS订阅，当我们浏览一些博客或wiki时，经常会看到RSS图标，就这的意思是，当你订阅了该文章，如果后续有更新，会及时通知你。其实，简单来讲就一句话：当一个对象变化时，其它依赖该对象的对象都会收到通知，并且随着变化！对象之间是一种一对多的关系。先来看看关系图：</p>
<p><img src="" alt=""></p>
<p>我解释下这些类的作用：MySubject类就是我们的主对象，Observer1和Observer2是依赖于MySubject的对象，当MySubject变化时，Observer1和Observer2必然变化。AbstractSubject类中定义着需要监控的对象列表，可以对其进行修改：增加或删除被监控对象，且当MySubject变化时，负责通知在列表内存在的对象。我们看实现代码：</p>
<p>一个Observer接口：
<strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8243942" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8243942" title="copy" target="_blank">copy</a></p>
<ol>
<li>public interface Observer {</li>
<li>public void update();</li>
<li>}</li>
</ol>
<p>两个实现类：</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8243942" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8243942" title="copy" target="_blank">copy</a></p>
<ol>
<li>public class Observer1 implements Observer {
1.</li>
<li>@Override</li>
<li>public void update() {</li>
<li>System.out.println(&quot;observer1 has received!&quot;);</li>
<li>}</li>
<li>}</li>
</ol>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8243942" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8243942" title="copy" target="_blank">copy</a></p>
<ol>
<li>public class Observer2 implements Observer {
1.</li>
<li>@Override</li>
<li>public void update() {</li>
<li>System.out.println(&quot;observer2 has received!&quot;);</li>
<li>}
1.</li>
<li>}</li>
</ol>
<p>Subject接口及实现类：
<strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8243942" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8243942" title="copy" target="_blank">copy</a></p>
<ol>
<li>public interface Subject {
1.</li>
<li>//<em>增加观察者/</em>/</li>
<li>public void add(Observer observer);
1.</li>
<li>//<em>删除观察者/</em>/</li>
<li>public void del(Observer observer);
1.</li>
<li>//<em>通知所有的观察者/</em>/</li>
<li>public void notifyObservers();
1.</li>
<li>//<em>自身的操作/</em>/</li>
<li>public void operation();</li>
<li>}</li>
</ol>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8243942" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8243942" title="copy" target="_blank">copy</a></p>
<ol>
<li>public abstract class AbstractSubject implements Subject {
1.</li>
<li>private Vector<Observer> vector = new Vector<Observer>();</li>
<li>@Override</li>
<li>public void add(Observer observer) {</li>
<li>vector.add(observer);</li>
<li>}
1.</li>
<li>@Override</li>
<li>public void del(Observer observer) {</li>
<li>vector.remove(observer);</li>
<li>}
1.</li>
<li>@Override</li>
<li>public void notifyObservers() {</li>
<li>Enumeration<Observer> enumo = vector.elements();</li>
<li>while(enumo.hasMoreElements()){</li>
<li>enumo.nextElement().update();</li>
<li>}</li>
<li>}</li>
<li><p>}
<strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8243942" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8243942" title="copy" target="_blank">copy</a></p>
</li>
<li><p>public class MySubject extends AbstractSubject {
1.</p>
</li>
<li>@Override</li>
<li>public void operation() {</li>
<li>System.out.println(&quot;update self!&quot;);</li>
<li>notifyObservers();</li>
<li>}
1.</li>
<li>}</li>
</ol>
<p>测试类：</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8243942" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8243942" title="copy" target="_blank">copy</a></p>
<ol>
<li>public class ObserverTest {
1.</li>
<li>public static void main(String[] args) {</li>
<li>Subject sub = new MySubject();</li>
<li>sub.add(new Observer1());</li>
<li>sub.add(new Observer2());
1.</li>
<li>sub.operation();</li>
<li>}
1.</li>
<li>}</li>
</ol>
<p>输出：</p>
<p>update self!
observer1 has received!
observer2 has received!</p>
<p>这些东西，其实不难，只是有些抽象，不太容易整体理解，建议读者：<strong>根据关系图，新建项目，自己写代码（或者参考我的代码）,</strong>按照<strong>总体思路走一遍，这样才能体会它的思想，理解起来容易！<em>**</em></strong></p>
<p><strong>16、迭代子模式（Iterator）</strong></p>
<p>顾名思义，迭代器模式就是顺序访问聚集中的对象，一般来说，集合中非常常见，如果对集合类比较熟悉的话，理解本模式会十分轻松。这句话包含两层意思：一是需要遍历的对象，即聚集对象，二是迭代器对象，用于对聚集对象进行遍历访问。我们看下关系图：</p>
<p><img src="" alt=""></p>
<p>这个思路和我们常用的一模一样，MyCollection中定义了集合的一些操作，MyIterator中定义了一系列迭代操作，且持有Collection实例，我们来看看实现代码：</p>
<p>两个接口：
<strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8243942" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8243942" title="copy" target="_blank">copy</a></p>
<ol>
<li>public interface Collection {
1.</li>
<li>public Iterator iterator();
1.</li>
<li>//<em>取得集合元素/</em>/</li>
<li>public Object get(int i);
1.</li>
<li>//<em>取得集合大小/</em>/</li>
<li>public int size();</li>
<li>}</li>
</ol>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8243942" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8243942" title="copy" target="_blank">copy</a></p>
<ol>
<li>public interface Iterator {</li>
<li>//前移</li>
<li>public Object previous();
1.</li>
<li>//后移</li>
<li>public Object next();</li>
<li>public boolean hasNext();
1.</li>
<li>//取得第一个元素</li>
<li>public Object first();</li>
<li>}</li>
</ol>
<p>两个实现：
<strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8243942" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8243942" title="copy" target="_blank">copy</a></p>
<ol>
<li>public class MyCollection implements Collection {
1.</li>
<li>public String string[] = {&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;};</li>
<li>@Override</li>
<li>public Iterator iterator() {</li>
<li>return new MyIterator(this);</li>
<li>}
1.</li>
<li>@Override</li>
<li>public Object get(int i) {</li>
<li>return string[i];</li>
<li>}
1.</li>
<li>@Override</li>
<li>public int size() {</li>
<li>return string.length;</li>
<li>}</li>
<li>}</li>
</ol>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8243942" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8243942" title="copy" target="_blank">copy</a></p>
<ol>
<li>public class MyIterator implements Iterator {
1.</li>
<li>private Collection collection;</li>
<li>private int pos = -1;
1.</li>
<li>public MyIterator(Collection collection){</li>
<li>this.collection = collection;</li>
<li>}
1.</li>
<li>@Override</li>
<li>public Object previous() {</li>
<li>if(pos &gt; 0){</li>
<li>pos--;</li>
<li>}</li>
<li>return collection.get(pos);</li>
<li>}
1.</li>
<li>@Override</li>
<li>public Object next() {</li>
<li>if(pos&lt;collection.size()-1){</li>
<li>pos++;</li>
<li>}</li>
<li>return collection.get(pos);</li>
<li>}
1.</li>
<li>@Override</li>
<li>public boolean hasNext() {</li>
<li>if(pos&lt;collection.size()-1){</li>
<li>return true;</li>
<li>}else{</li>
<li>return false;</li>
<li>}</li>
<li>}
1.</li>
<li>@Override</li>
<li>public Object first() {</li>
<li>pos = 0;</li>
<li>return collection.get(pos);</li>
<li>}
1.</li>
<li>}</li>
</ol>
<p>测试类：
<strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8243942" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8243942" title="copy" target="_blank">copy</a></p>
<ol>
<li>public class Test {
1.</li>
<li>public static void main(String[] args) {</li>
<li>Collection collection = new MyCollection();</li>
<li>Iterator it = collection.iterator();
1.</li>
<li>while(it.hasNext()){</li>
<li>System.out.println(it.next());</li>
<li>}</li>
<li>}</li>
<li>}</li>
</ol>
<p>输出：A B C D E</p>
<p>此处我们貌似模拟了一个集合类的过程，感觉是不是很爽？其实JDK中各个类也都是这些基本的东西，加一些设计模式，再加一些优化放到一起的，只要我们把这些东西学会了，掌握好了，我们也可以写出自己的集合类，甚至框架！</p>
<p><strong>17、责任链模式（Chain of Responsibility）
</strong>接下来我们将要谈谈责任链模式，有多个对象，每个对象持有对下一个对象的引用，这样就会形成一条链，请求在这条链上传递，直到某一对象决定处理该请求。但是发出者并不清楚到底最终那个对象会处理该请求，所以，责任链模式可以实现，在隐瞒客户端的情况下，对系统进行动态的调整。先看看关系图：</p>
<p><img src="" alt=""></p>
<p>Abstracthandler类提供了get和set方法，方便MyHandle类设置和修改引用对象，MyHandle类是核心，实例化后生成一系列相互持有的对象，构成一条链。
<strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8243942" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8243942" title="copy" target="_blank">copy</a></p>
<ol>
<li>public interface Handler {</li>
<li>public void operator();</li>
<li>}</li>
</ol>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8243942" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8243942" title="copy" target="_blank">copy</a></p>
<ol>
<li>public abstract class AbstractHandler {
1.</li>
<li>private Handler handler;
1.</li>
<li>public Handler getHandler() {</li>
<li>return handler;</li>
<li>}
1.</li>
<li>public void setHandler(Handler handler) {</li>
<li>this.handler = handler;</li>
<li>}
1.</li>
<li><p>}
<strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8243942" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8243942" title="copy" target="_blank">copy</a></p>
</li>
<li><p>public class MyHandler extends AbstractHandler implements Handler {
1.</p>
</li>
<li>private String name;
1.</li>
<li>public MyHandler(String name) {</li>
<li>this.name = name;</li>
<li>}
1.</li>
<li>@Override</li>
<li>public void operator() {</li>
<li>System.out.println(name+&quot;deal!&quot;);</li>
<li>if(getHandler()!=null){</li>
<li>getHandler().operator();</li>
<li>}</li>
<li>}</li>
<li>}</li>
</ol>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8243942" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8243942" title="copy" target="_blank">copy</a></p>
<ol>
<li>public class Test {
1.</li>
<li>public static void main(String[] args) {</li>
<li>MyHandler h1 = new MyHandler(&quot;h1&quot;);</li>
<li>MyHandler h2 = new MyHandler(&quot;h2&quot;);</li>
<li>MyHandler h3 = new MyHandler(&quot;h3&quot;);
1.</li>
<li>h1.setHandler(h2);</li>
<li>h2.setHandler(h3);
1.</li>
<li>h1.operator();</li>
<li>}</li>
<li>}</li>
</ol>
<p>输出：</p>
<p>h1deal!
h2deal!
h3deal!</p>
<p>此处强调一点就是，链接上的请求可以是一条链，可以是一个树，还可以是一个环，模式本身不约束这个，需要我们自己去实现，同时，在一个时刻，命令只允许由一个对象传给另一个对象，而不允许传给多个对象。</p>
<p><strong>18、命令模式（Command）</strong></p>
<p>命令模式很好理解，举个例子，司令员下令让士兵去干件事情，从整个事情的角度来考虑，司令员的作用是，发出口令，口令经过传递，传到了士兵耳朵里，士兵去执行。这个过程好在，三者相互解耦，任何一方都不用去依赖其他人，只需要做好自己的事儿就行，司令员要的是结果，不会去关注到底士兵是怎么实现的。我们看看关系图：</p>
<p><img src="" alt=""></p>
<p>Invoker是调用者（司令员），Receiver是被调用者（士兵），MyCommand是命令，实现了Command接口，持有接收对象，看实现代码：
<strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8243942" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8243942" title="copy" target="_blank">copy</a></p>
<ol>
<li>public interface Command {</li>
<li>public void exe();</li>
<li>}</li>
</ol>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8243942" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8243942" title="copy" target="_blank">copy</a></p>
<ol>
<li>public class MyCommand implements Command {
1.</li>
<li>private Receiver receiver;
1.</li>
<li>public MyCommand(Receiver receiver) {</li>
<li>this.receiver = receiver;</li>
<li>}
1.</li>
<li>@Override</li>
<li>public void exe() {</li>
<li>receiver.action();</li>
<li>}</li>
<li><p>}
<strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8243942" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8243942" title="copy" target="_blank">copy</a></p>
</li>
<li><p>public class Receiver {</p>
</li>
<li>public void action(){</li>
<li>System.out.println(&quot;command received!&quot;);</li>
<li>}</li>
<li>}</li>
</ol>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8243942" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8243942" title="copy" target="_blank">copy</a></p>
<ol>
<li>public class Invoker {
1.</li>
<li>private Command command;
1.</li>
<li>public Invoker(Command command) {</li>
<li>this.command = command;</li>
<li>}
1.</li>
<li>public void action(){</li>
<li>command.exe();</li>
<li>}</li>
<li><p>}
<strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8243942" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8243942" title="copy" target="_blank">copy</a></p>
</li>
<li><p>public class Test {
1.</p>
</li>
<li>public static void main(String[] args) {</li>
<li>Receiver receiver = new Receiver();</li>
<li>Command cmd = new MyCommand(receiver);</li>
<li>Invoker invoker = new Invoker(cmd);</li>
<li>invoker.action();</li>
<li>}</li>
<li>}</li>
</ol>
<p>输出：command received!</p>
<p>这个很哈理解，命令模式的目的就是达到命令的发出者和执行者之间解耦，实现请求和执行分开，熟悉Struts的同学应该知道，Struts其实就是一种将请求和呈现分离的技术，其中必然涉及命令模式的思想！
其实每个设计模式都是很重要的一种思想，看上去很熟，其实是因为我们在学到的东西中都有涉及，尽管有时我们并不知道，其实在Java本身的设计之中处处都有体现，像AWT、JDBC、集合类、IO管道或者是Web框架，里面设计模式无处不在。因为我们篇幅有限，很难讲每一个设计模式都讲的很详细，不过我会尽我所能，尽量在有限的空间和篇幅内，把意思写清楚了，更好让大家明白。本章不出意外的话，应该是设计模式最后一讲了，首先还是上一下上篇开头的那个图：</p>
<p><img src="&quot;点击查看原始大小图片&quot;" alt=""></p>
<p>本章讲讲第三类和第四类。</p>
<p><strong>19、备忘录模式（Memento）</strong></p>
<p>主要目的是保存一个对象的某个状态，以便在适当的时候恢复对象，个人觉得叫备份模式更形象些，通俗的讲下：假设有原始类A，A中有各种属性，A可以决定需要备份的属性，备忘录类B是用来存储A的一些内部状态，类C呢，就是一个用来存储备忘录的，且只能存储，不能修改等操作。做个图来分析一下：</p>
<p><img src="" alt=""></p>
<p>Original类是原始类，里面有需要保存的属性value及创建一个备忘录类，用来保存value值。Memento类是备忘录类，Storage类是存储备忘录的类，持有Memento类的实例，该模式很好理解。直接看源码：
<strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8245537" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8245537" title="copy" target="_blank">copy</a></p>
<ol>
<li>public class Original {
1.</li>
<li>private String value;
1.</li>
<li>public String getValue() {</li>
<li>return value;</li>
<li>}
1.</li>
<li>public void setValue(String value) {</li>
<li>this.value = value;</li>
<li>}
1.</li>
<li>public Original(String value) {</li>
<li>this.value = value;</li>
<li>}
1.</li>
<li>public Memento createMemento(){</li>
<li>return new Memento(value);</li>
<li>}
1.</li>
<li>public void restoreMemento(Memento memento){</li>
<li>this.value = memento.getValue();</li>
<li>}</li>
<li>}</li>
</ol>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8245537" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8245537" title="copy" target="_blank">copy</a></p>
<ol>
<li>public class Memento {
1.</li>
<li>private String value;
1.</li>
<li>public Memento(String value) {</li>
<li>this.value = value;</li>
<li>}
1.</li>
<li>public String getValue() {</li>
<li>return value;</li>
<li>}
1.</li>
<li>public void setValue(String value) {</li>
<li>this.value = value;</li>
<li>}</li>
<li><p>}
<strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8245537" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8245537" title="copy" target="_blank">copy</a></p>
</li>
<li><p>public class Storage {
1.</p>
</li>
<li>private Memento memento;
1.</li>
<li>public Storage(Memento memento) {</li>
<li>this.memento = memento;</li>
<li>}
1.</li>
<li>public Memento getMemento() {</li>
<li>return memento;</li>
<li>}
1.</li>
<li>public void setMemento(Memento memento) {</li>
<li>this.memento = memento;</li>
<li>}</li>
<li>}</li>
</ol>
<p>测试类：</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8245537" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8245537" title="copy" target="_blank">copy</a></p>
<ol>
<li>public class Test {
1.</li>
<li>public static void main(String[] args) {
1.</li>
<li>// 创建原始类</li>
<li>Original origi = new Original(&quot;egg&quot;);
1.</li>
<li>// 创建备忘录</li>
<li>Storage storage = new Storage(origi.createMemento());
1.</li>
<li>// 修改原始类的状态</li>
<li>System.out.println(&quot;初始化状态为：&quot; + origi.getValue());</li>
<li>origi.setValue(&quot;niu&quot;);</li>
<li>System.out.println(&quot;修改后的状态为：&quot; + origi.getValue());
1.</li>
<li>// 回复原始类的状态</li>
<li>origi.restoreMemento(storage.getMemento());</li>
<li>System.out.println(&quot;恢复后的状态为：&quot; + origi.getValue());</li>
<li>}</li>
<li>}</li>
</ol>
<p>输出：</p>
<p>初始化状态为：egg
修改后的状态为：niu
恢复后的状态为：egg</p>
<p>简单描述下：新建原始类时，value被初始化为egg，后经过修改，将value的值置为niu，最后倒数第二行进行恢复状态，结果成功恢复了。其实我觉得这个模式叫“备份-恢复”模式最形象。</p>
<p><strong>20、状态模式（State）</strong></p>
<p>核心思想就是：当对象的状态改变时，同时改变其行为，很好理解！就拿QQ来说，有几种状态，在线、隐身、忙碌等，每个状态对应不同的操作，而且你的好友也能看到你的状态，所以，状态模式就两点：1、可以通过改变状态来获得不同的行为。2、你的好友能同时看到你的变化。看图：</p>
<p><img src="" alt=""></p>
<p>State类是个状态类，Context类可以实现切换，我们来看看代码：</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8245537" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8245537" title="copy" target="_blank">copy</a></p>
<ol>
<li>package com.xtfggef.dp.state;
1.</li>
<li>//<em>/</em></li>
<li>/* 状态类的核心类</li>
<li>/* 2012-12-1</li>
<li>/* @author erqing</li>
<li>/*</li>
<li>/*/</li>
<li>public class State {
1.</li>
<li>private String value;
1.</li>
<li>public String getValue() {</li>
<li>return value;</li>
<li>}
1.</li>
<li>public void setValue(String value) {</li>
<li>this.value = value;</li>
<li>}
1.</li>
<li>public void method1(){</li>
<li>System.out.println(&quot;execute the first opt!&quot;);</li>
<li>}
1.</li>
<li>public void method2(){</li>
<li>System.out.println(&quot;execute the second opt!&quot;);</li>
<li>}</li>
<li>}</li>
</ol>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8245537" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8245537" title="copy" target="_blank">copy</a></p>
<ol>
<li>package com.xtfggef.dp.state;
1.</li>
<li>//<em>/</em></li>
<li>/* 状态模式的切换类 2012-12-1</li>
<li>/* @author erqing</li>
<li>/*</li>
<li>/*/</li>
<li>public class Context {
1.</li>
<li>private State state;
1.</li>
<li>public Context(State state) {</li>
<li>this.state = state;</li>
<li>}
1.</li>
<li>public State getState() {</li>
<li>return state;</li>
<li>}
1.</li>
<li>public void setState(State state) {</li>
<li>this.state = state;</li>
<li>}
1.</li>
<li>public void method() {</li>
<li>if (state.getValue().equals(&quot;state1&quot;)) {</li>
<li>state.method1();</li>
<li>} else if (state.getValue().equals(&quot;state2&quot;)) {</li>
<li>state.method2();</li>
<li>}</li>
<li>}</li>
<li>}
测试类：</li>
</ol>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8245537" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8245537" title="copy" target="_blank">copy</a></p>
<ol>
<li>public class Test {
1.</li>
<li>public static void main(String[] args) {
1.</li>
<li>State state = new State();</li>
<li>Context context = new Context(state);
1.</li>
<li>//设置第一种状态</li>
<li>state.setValue(&quot;state1&quot;);</li>
<li>context.method();
1.</li>
<li>//设置第二种状态</li>
<li>state.setValue(&quot;state2&quot;);</li>
<li>context.method();</li>
<li>}</li>
<li>}
输出：</li>
</ol>
<p>execute the first opt!
execute the second opt!</p>
<p>根据这个特性，状态模式在日常开发中用的挺多的，尤其是做网站的时候，我们有时希望根据对象的某一属性，区别开他们的一些功能，比如说简单的权限控制等。
<strong>21、访问者模式（Visitor）</strong></p>
<p>访问者模式把数据结构和作用于结构上的操作解耦合，使得操作集合可相对自由地演化。访问者模式适用于数据结构相对稳定算法又易变化的系统。因为访问者模式使得算法操作增加变得容易。若系统数据结构对象易于变化，经常有新的数据对象增加进来，则不适合使用访问者模式。访问者模式的优点是增加操作很容易，因为增加操作意味着增加新的访问者。访问者模式将有关行为集中到一个访问者对象中，其改变不影响系统数据结构。其缺点就是增加新的数据结构很困难。—— From 百科</p>
<p>简单来说，访问者模式就是一种分离对象数据结构与行为的方法，通过这种分离，可达到为一个被访问者动态添加新的操作而无需做其它的修改的效果。简单关系图：</p>
<p><img src="" alt=""></p>
<p>来看看原码：一个Visitor类，存放要访问的对象，</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8245537" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8245537" title="copy" target="_blank">copy</a></p>
<ol>
<li>public interface Visitor {</li>
<li>public void visit(Subject sub);</li>
<li>}</li>
</ol>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8245537" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8245537" title="copy" target="_blank">copy</a></p>
<ol>
<li>public class MyVisitor implements Visitor {
1.</li>
<li>@Override</li>
<li>public void visit(Subject sub) {</li>
<li>System.out.println(&quot;visit the subject：&quot;+sub.getSubject());</li>
<li>}</li>
<li><p>}
Subject类，accept方法，接受将要访问它的对象，getSubject()获取将要被访问的属性，
<strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8245537" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8245537" title="copy" target="_blank">copy</a></p>
</li>
<li><p>public interface Subject {</p>
</li>
<li>public void accept(Visitor visitor);</li>
<li>public String getSubject();</li>
<li>}</li>
</ol>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8245537" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8245537" title="copy" target="_blank">copy</a></p>
<ol>
<li>public class MySubject implements Subject {
1.</li>
<li>@Override</li>
<li>public void accept(Visitor visitor) {</li>
<li>visitor.visit(this);</li>
<li>}
1.</li>
<li>@Override</li>
<li>public String getSubject() {</li>
<li>return &quot;love&quot;;</li>
<li>}</li>
<li>}
测试：</li>
</ol>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8245537" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8245537" title="copy" target="_blank">copy</a></p>
<ol>
<li>public class Test {
1.</li>
<li>public static void main(String[] args) {
1.</li>
<li>Visitor visitor = new MyVisitor();</li>
<li>Subject sub = new MySubject();</li>
<li>sub.accept(visitor);</li>
<li>}</li>
<li>}
输出：visit the subject：love</li>
</ol>
<p>该模式适用场景：如果我们想为一个现有的类增加新功能，不得不考虑几个事情：1、新功能会不会与现有功能出现兼容性问题？2、以后会不会再需要添加？3、如果类不允许修改代码怎么办？面对这些问题，最好的解决方法就是使用访问者模式，访问者模式适用于数据结构相对稳定的系统，把数据结构和算法解耦，
<strong>22、中介者模式（Mediator）</strong></p>
<p>中介者模式也是用来降低类类之间的耦合的，因为如果类类之间有依赖关系的话，不利于功能的拓展和维护，因为只要修改一个对象，其它关联的对象都得进行修改。如果使用中介者模式，只需关心和Mediator类的关系，具体类类之间的关系及调度交给Mediator就行，这有点像spring容器的作用。先看看图：</p>
<p><img src="" alt=""></p>
<p>User类统一接口，User1和User2分别是不同的对象，二者之间有关联，如果不采用中介者模式，则需要二者相互持有引用，这样二者的耦合度很高，为了解耦，引入了Mediator类，提供统一接口，MyMediator为其实现类，里面持有User1和User2的实例，用来实现对User1和User2的控制。这样User1和User2两个对象相互独立，他们只需要保持好和Mediator之间的关系就行，剩下的全由MyMediator类来维护！基本实现：</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8245537" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8245537" title="copy" target="_blank">copy</a></p>
<ol>
<li>public interface Mediator {</li>
<li>public void createMediator();</li>
<li>public void workAll();</li>
<li>}</li>
</ol>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8245537" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8245537" title="copy" target="_blank">copy</a></p>
<ol>
<li>public class MyMediator implements Mediator {
1.</li>
<li>private User user1;</li>
<li>private User user2;
1.</li>
<li>public User getUser1() {</li>
<li>return user1;</li>
<li>}
1.</li>
<li>public User getUser2() {</li>
<li>return user2;</li>
<li>}
1.</li>
<li>@Override</li>
<li>public void createMediator() {</li>
<li>user1 = new User1(this);</li>
<li>user2 = new User2(this);</li>
<li>}
1.</li>
<li>@Override</li>
<li>public void workAll() {</li>
<li>user1.work();</li>
<li>user2.work();</li>
<li>}</li>
<li><p>}
<strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8245537" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8245537" title="copy" target="_blank">copy</a></p>
</li>
<li><p>public abstract class User {
1.</p>
</li>
<li>private Mediator mediator;
1.</li>
<li>public Mediator getMediator(){</li>
<li>return mediator;</li>
<li>}
1.</li>
<li>public User(Mediator mediator) {</li>
<li>this.mediator = mediator;</li>
<li>}
1.</li>
<li>public abstract void work();</li>
<li>}</li>
</ol>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8245537" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8245537" title="copy" target="_blank">copy</a></p>
<ol>
<li>public class User1 extends User {
1.</li>
<li>public User1(Mediator mediator){</li>
<li>super(mediator);</li>
<li>}
1.</li>
<li>@Override</li>
<li>public void work() {</li>
<li>System.out.println(&quot;user1 exe!&quot;);</li>
<li>}</li>
<li><p>}
<strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8245537" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8245537" title="copy" target="_blank">copy</a></p>
</li>
<li><p>public class User2 extends User {
1.</p>
</li>
<li>public User2(Mediator mediator){</li>
<li>super(mediator);</li>
<li>}
1.</li>
<li>@Override</li>
<li>public void work() {</li>
<li>System.out.println(&quot;user2 exe!&quot;);</li>
<li>}</li>
<li>}
测试类：</li>
</ol>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8245537" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8245537" title="copy" target="_blank">copy</a></p>
<ol>
<li>public class Test {
1.</li>
<li>public static void main(String[] args) {</li>
<li>Mediator mediator = new MyMediator();</li>
<li>mediator.createMediator();</li>
<li>mediator.workAll();</li>
<li>}</li>
<li>}
输出：</li>
</ol>
<p>user1 exe!
user2 exe!
<strong>23、解释器模式（Interpreter）</strong>
解释器模式是我们暂时的最后一讲，一般主要应用在OOP开发中的编译器的开发中，所以适用面比较窄。</p>
<p><img src="" alt=""></p>
<p>Context类是一个上下文环境类，Plus和Minus分别是用来计算的实现，代码如下：</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8245537" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8245537" title="copy" target="_blank">copy</a></p>
<ol>
<li>public interface Expression {</li>
<li>public int interpret(Context context);</li>
<li>}</li>
</ol>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8245537" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8245537" title="copy" target="_blank">copy</a></p>
<ol>
<li>public class Plus implements Expression {
1.</li>
<li>@Override</li>
<li>public int interpret(Context context) {</li>
<li>return context.getNum1()+context.getNum2();</li>
<li>}</li>
<li><p>}
<strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8245537" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8245537" title="copy" target="_blank">copy</a></p>
</li>
<li><p>public class Minus implements Expression {
1.</p>
</li>
<li>@Override</li>
<li>public int interpret(Context context) {</li>
<li>return context.getNum1()-context.getNum2();</li>
<li>}</li>
<li>}</li>
</ol>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8245537" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8245537" title="copy" target="_blank">copy</a></p>
<ol>
<li>public class Context {
1.</li>
<li>private int num1;</li>
<li>private int num2;
1.</li>
<li>public Context(int num1, int num2) {</li>
<li>this.num1 = num1;</li>
<li>this.num2 = num2;</li>
<li>}
1.</li>
<li>public int getNum1() {</li>
<li>return num1;</li>
<li>}</li>
<li>public void setNum1(int num1) {</li>
<li>this.num1 = num1;</li>
<li>}</li>
<li>public int getNum2() {</li>
<li>return num2;</li>
<li>}</li>
<li>public void setNum2(int num2) {</li>
<li>this.num2 = num2;</li>
<li>}
1.
1.</li>
<li><p>}
<strong>[java]</strong> <a href="http://blog.csdn.net/zhangerqing/article/details/8245537" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/zhangerqing/article/details/8245537" title="copy" target="_blank">copy</a></p>
</li>
<li><p>public class Test {
1.</p>
</li>
<li>public static void main(String[] args) {
1.</li>
<li>// 计算9+2-8的值</li>
<li>int result = new Minus().interpret((new Context(new Plus()</li>
<li>.interpret(new Context(9, 2)), 8)));</li>
<li>System.out.println(result);</li>
<li>}</li>
<li>}
最后输出正确的结果：3。</li>
</ol>
<p>基本就这样，解释器模式用来做各种各样的解释器，如正则表达式等的解释器等等！</p>
<p>设计模式基本就这么大概讲完了，总体感觉有点简略，的确，这么点儿篇幅，不足以对整个23种设计模式做全面的阐述，此处读者可将它作为一个理论基础去学习，通过这四篇博文，先基本有个概念，虽然我讲的有些简单，但基本都能说明问题及他们的特点，如果对哪一个感兴趣，可以继续深入研究！同时我也会不断更新，尽量补全遗漏、修正不足，欢迎广大读者及时提出好的建议，我们一起学习！项目中涉及到的代码，已经放到了我的资源里：<a href="http://download.csdn.net/detail/zhangerqing/4835830（因为我不喜欢不劳而获，所以没有免积分，只设置了5个，如果有人实在没积分又急要，那么联系我吧，我给你发过去）。" target="_blank">http://download.csdn.net/detail/zhangerqing/4835830（因为我不喜欢不劳而获，所以没有免积分，只设置了5个，如果有人实在没积分又急要，那么联系我吧，我给你发过去）。</a></p>
<p><strong>在阅读的过程中，有任何问题，请联系：egg。</strong></p>
<p><strong>邮箱：xtfggef@gmail.com 微博：<a href="http://weibo.com/xtfggefa" target="_blank"><a href="http://weibo.com/xtfggefa">http://weibo.com/xtfggefa</a></a></strong></p>
<ul>
<li><a href="http://dl2.iteye.com/upload/attachment/0083/1179/57a92d42-4d84-3aa9-a8b9-63a0b02c2c36.jpg" target="_blank"><img src="&quot;点击查看原始大小图片&quot;" alt=""></a></li>
<li><p>大小: 92.6 KB</p>
</li>
<li><p><a href="http://dl2.iteye.com/upload/attachment/0083/1180/421a1a3f-6777-3bca-85d7-00fc60c1ae8b.png" target="_blank"><img src="&quot;点击查看原始大小图片&quot;" alt=""></a></p>
</li>
<li><p>大小: 12 KB</p>
</li>
<li><p><a href="http://dl2.iteye.com/upload/attachment/0083/1181/84673ccf-ef89-3774-b5cf-6d2523cd03e5.jpg" target="_blank"><img src="&quot;点击查看原始大小图片&quot;" alt=""></a></p>
</li>
<li><p>大小: 21.3 KB</p>
</li>
<li><p><a href="http://dl2.iteye.com/upload/attachment/0083/1185/34a0f8de-16e0-3cd5-9f69-257fcb2be742.jpg" target="_blank"><img src="&quot;点击查看原始大小图片&quot;" alt=""></a></p>
</li>
<li><p>大小: 28.8 KB</p>
</li>
<li><p><a href="http://dl2.iteye.com/upload/attachment/0083/1187/e28698b9-994e-3fa8-8810-16f30e7cf3e3.jpg" target="_blank"><img src="&quot;点击查看原始大小图片&quot;" alt=""></a></p>
</li>
<li><p>大小: 50.7 KB</p>
</li>
<li><p><a href="http://dl2.iteye.com/upload/attachment/0083/1189/6b2d13aa-7cc7-3e98-9764-bdcb2c64f795.jpg" target="_blank"><img src="&quot;点击查看原始大小图片&quot;" alt=""></a></p>
</li>
<li><p>大小: 19.2 KB</p>
</li>
<li><p><a href="http://dl2.iteye.com/upload/attachment/0083/1191/0aabe35b-5b79-3ead-838f-9d4b6fbd774d.jpg" target="_blank"><img src="&quot;点击查看原始大小图片&quot;" alt=""></a></p>
</li>
<li><p>大小: 20.3 KB</p>
</li>
<li><p><a href="http://dl2.iteye.com/upload/attachment/0083/1193/a604fca8-e0c6-3e4e-b00a-49da21595b4e.jpg" target="_blank"><img src="&quot;点击查看原始大小图片&quot;" alt=""></a></p>
</li>
<li><p>大小: 21.8 KB</p>
</li>
<li><p><a href="http://dl2.iteye.com/upload/attachment/0083/1195/e1b8b6a3-0150-31ae-8f77-7c3d888b6f80.jpg" target="_blank"><img src="&quot;点击查看原始大小图片&quot;" alt=""></a></p>
</li>
<li><p>大小: 13.1 KB</p>
</li>
<li><p><a href="http://dl2.iteye.com/upload/attachment/0083/1197/ea094ad9-efc5-337d-a8e8-ce9223511144.jpg" target="_blank"><img src="&quot;点击查看原始大小图片&quot;" alt=""></a></p>
</li>
<li><p>大小: 14.9 KB</p>
</li>
<li><p><a href="http://dl2.iteye.com/upload/attachment/0083/1199/eebe2103-6ced-35f2-8664-3a2e8a557f81.jpg" target="_blank"><img src="&quot;点击查看原始大小图片&quot;" alt=""></a></p>
</li>
<li><p>大小: 23.2 KB</p>
</li>
<li><p><a href="http://dl2.iteye.com/upload/attachment/0083/1201/35f0b172-b976-3757-bb51-c65d5c9ce68e.jpg" target="_blank"><img src="&quot;点击查看原始大小图片&quot;" alt=""></a></p>
</li>
<li><p>大小: 26.6 KB</p>
</li>
<li><p><a href="http://dl2.iteye.com/upload/attachment/0083/1203/6f713d07-1409-3312-99c9-fa6b0909f0b2.jpg" target="_blank"><img src="&quot;点击查看原始大小图片&quot;" alt=""></a></p>
</li>
<li><p>大小: 17.4 KB</p>
</li>
<li><p><a href="http://dl2.iteye.com/upload/attachment/0083/1205/09cab656-5ff9-380e-9df1-326339ac3509.jpg" target="_blank"><img src="&quot;点击查看原始大小图片&quot;" alt=""></a></p>
</li>
<li><p>大小: 14.2 KB</p>
</li>
<li><p><a href="http://dl2.iteye.com/upload/attachment/0083/1207/f7aae0dd-b250-3829-bb07-49d87069bfbb.jpg" target="_blank"><img src="&quot;点击查看原始大小图片&quot;" alt=""></a></p>
</li>
<li><p>大小: 17 KB</p>
</li>
<li><p><a href="http://dl2.iteye.com/upload/attachment/0083/1209/53bc0bf4-cafb-3a12-8574-e20a525f2b72.jpg" target="_blank"><img src="&quot;点击查看原始大小图片&quot;" alt=""></a></p>
</li>
<li><p>大小: 14.8 KB</p>
</li>
<li><p><a href="http://dl2.iteye.com/upload/attachment/0083/1211/5e2feb58-4170-3c07-a370-ed99bdcab223.jpg" target="_blank"><img src="&quot;点击查看原始大小图片&quot;" alt=""></a></p>
</li>
<li><p>大小: 51.2 KB</p>
</li>
<li><p><a href="http://dl2.iteye.com/upload/attachment/0083/1213/2319a2c3-7ebd-3ee3-b389-1548074ea9c6.jpg" target="_blank"><img src="&quot;点击查看原始大小图片&quot;" alt=""></a></p>
</li>
<li><p>大小: 27.1 KB</p>
</li>
<li><p><a href="http://dl2.iteye.com/upload/attachment/0083/1215/c3d57775-ddf9-302b-9dfe-c65967518d3c.jpg" target="_blank"><img src="&quot;点击查看原始大小图片&quot;" alt=""></a></p>
</li>
<li><p>大小: 16.9 KB</p>
</li>
<li><p><a href="http://dl2.iteye.com/upload/attachment/0083/1217/f7571a69-3c85-3fe1-b781-e460563a40a8.jpg" target="_blank"><img src="&quot;点击查看原始大小图片&quot;" alt=""></a></p>
</li>
<li><p>大小: 33.6 KB</p>
</li>
<li><p><a href="http://dl2.iteye.com/upload/attachment/0083/1219/729a82ce-0987-347c-a4f1-bf64dee59ddb.jpg" target="_blank"><img src="&quot;点击查看原始大小图片&quot;" alt=""></a></p>
</li>
<li><p>大小: 21 KB</p>
</li>
<li><p><a href="http://dl2.iteye.com/upload/attachment/0083/1221/5d3c9b85-c281-3c48-999c-d27095c6ec9f.jpg" target="_blank"><img src="&quot;点击查看原始大小图片&quot;" alt=""></a></p>
</li>
<li><p>大小: 48 KB</p>
</li>
<li><p><a href="http://dl2.iteye.com/upload/attachment/0083/1223/853d5c5a-9b7b-3341-a72e-abd3cbc3c81f.jpg" target="_blank"><img src="&quot;点击查看原始大小图片&quot;" alt=""></a></p>
</li>
<li><p>大小: 24.4 KB</p>
</li>
<li><p><a href="http://dl2.iteye.com/upload/attachment/0083/1225/006156d2-f41f-3019-a194-b872a59ca426.jpg" target="_blank"><img src="&quot;点击查看原始大小图片&quot;" alt=""></a></p>
</li>
<li><p>大小: 14.4 KB</p>
</li>
<li><p><a href="http://dl2.iteye.com/upload/attachment/0083/1227/96bd38f3-2888-3cc5-b90f-0e7542dc5845.jpg" target="_blank"><img src="&quot;点击查看原始大小图片&quot;" alt=""></a></p>
</li>
<li><p>大小: 18.2 KB</p>
</li>
<li><p><a href="http://dl2.iteye.com/upload/attachment/0083/1229/f1f2cc36-ab27-32fa-9906-9cdee2c2b625.jpg" target="_blank"><img src="&quot;点击查看原始大小图片&quot;" alt=""></a></p>
</li>
<li><p>大小: 39.5 KB</p>
</li>
<li><p><a href="http://dl2.iteye.com/upload/attachment/0083/1231/c87e402e-a355-3761-9ce3-7978956ba475.jpg" target="_blank"><img src="&quot;点击查看原始大小图片&quot;" alt=""></a></p>
</li>
<li><p>大小: 29.7 KB</p>
</li>
<li><p><a href="http://dl2.iteye.com/upload/attachment/0083/1233/d588525c-fbad-3040-971c-69b2716c67a4.jpg" target="_blank"><img src="&quot;点击查看原始大小图片&quot;" alt=""></a></p>
</li>
<li><p>大小: 34.6 KB</p>
</li>
<li><p><a href="http://dl2.iteye.com/upload/attachment/0083/1239/98cda4fc-00b1-300d-a25b-63229f0f1cbd.jpg" target="_blank"><img src="&quot;点击查看原始大小图片&quot;" alt=""></a></p>
</li>
<li><p>大小: 20.7 KB</p>
</li>
<li><p><a href="http://zz563143188.iteye.com/blog/1847029#" target="_blank">查看图片附件</a></p>
</li>
</ul>
<p>分享到： <a href="&quot;分享到新浪微博&quot;"><img src="" alt=""></a><a href="&quot;分享到腾讯微博&quot;"><img src="" alt=""></a>
<a href="http://zz563143188.iteye.com/blog/1849952" title="一例讲述lang,util,text包50种高级用法" target="_blank">一例讲述lang,util,text包50种高级用法</a>| <a href="http://zz563143188.iteye.com/blog/1846708" title="收集多年的开发资料和开发工具" target="_blank">收集多年的开发资料和开发工具</a></p>
<ul>
<li>2013-04-14 09:09</li>
<li>浏览 13983</li>
<li><a href="http://zz563143188.iteye.com/blog/1847029#comments" target="_blank">评论(64)</a></li>
<li>分类:<a href="http://www.iteye.com/blogs/category/language" target="_blank">编程语言</a></li>
<li><a href="http://www.iteye.com/wiki/blog/1847029" target="_blank">相关推荐</a><h3 id="-">评论</h3>
</li>
</ul>
<p><a href=""></a></p>
<p>64 楼 <a href="http://qvp8.iteye.com/" title="qvp8" target="_blank">qvp8</a>前天</p>
<p><img src="" alt=""> 最近看设计模式，看了几个。感觉还是本主说的清楚。<img src="" alt="">
63 楼 <a href="http://zz563143188.iteye.com/" title="zz563143188" target="_blank">zz563143188</a> 2013-05-14</p>
<p>满手都是炸 写道</p>
<p>今天听老师讲 struts2里的action是非单例， 搜到这个看看
好的，spring单例用的广</p>
<p>62 楼 <a href="http://zz563143188.iteye.com/" title="zz563143188" target="_blank">zz563143188</a> 2013-05-14</p>
<p>勇气魄力 写道</p>
<p>写的不错，<img src="" alt="">
呵呵，多琢磨，有争议的地方提出来。
61 楼 <a href="http://nianlaiqu.iteye.com/" title="满手都是炸" target="_blank">满手都是炸</a>2013-05-13</p>
<p>今天听老师讲 struts2里的action是非单例， 搜到这个看看</p>
<p>60 楼 <a href="http://wushuang.iteye.com/" title="勇气魄力" target="_blank">勇气魄力</a>2013-05-12</p>
<p>写的不错，<img src="" alt="">
59 楼 <a href="http://zz563143188.iteye.com/" title="zz563143188" target="_blank">zz563143188</a> 2013-05-10</p>
<p>qqweixing123 写道</p>
<p>楼主其实文笔不错，讲得比较易懂，但是有些模式的理解确实需要再斟酌一下，然后再发表一下就更好了，不然把别人误了就不好了。
好吧，能具体一些吗。我再重新审视一下</p>
<p>58 楼 <a href="http://qqweixing123.iteye.com/" title="qqweixing123" target="_blank">qqweixing123</a> 2013-05-10</p>
<p>楼主其实文笔不错，讲得比较易懂，但是有些模式的理解确实需要再斟酌一下，然后再发表一下就更好了，不然把别人误了就不好了。
57 楼 <a href="http://zz563143188.iteye.com/" title="zz563143188" target="_blank">zz563143188</a> 2013-05-08</p>
<p>teasp 写道</p>
<p>zz563143188 写道</p>
<p>teasp 写道</p>
<p>楼主根本就没理解自己要讲的东西就在这里误人子弟。看了前面两个模式工厂和单例。抽象工厂方法模式有问题。单例的除了那个利用私有工厂产生实例的是正确的外，其他的实现方式都错了。
看来你是认真分析或者仔细斟酌过后才得出和结论吧，愿兄台能够具体指出歧义的地方。
当然是仔细斟酌后给出的结论。我只会在付费后给出正确的解，请原谅。因为我指出有错误已经是最大的帮助了，你完全可以自己找到正确的做法。
天下熙熙皆为利来,天下攘攘皆为利往。人为财死，鸟为食亡。道不同则不相为谋；志不合不相与随。虽兄弟厉害，可咱们没相交点。</p>
<p>56 楼 <a href="http://teasp.iteye.com/" title="teasp" target="_blank">teasp</a> 2013-05-08</p>
<p>zz563143188 写道</p>
<p>teasp 写道</p>
<p>楼主根本就没理解自己要讲的东西就在这里误人子弟。看了前面两个模式工厂和单例。抽象工厂方法模式有问题。单例的除了那个利用私有工厂产生实例的是正确的外，其他的实现方式都错了。
看来你是认真分析或者仔细斟酌过后才得出和结论吧，愿兄台能够具体指出歧义的地方。
当然是仔细斟酌后给出的结论。我只会在付费后给出正确的解，请原谅。因为我指出有错误已经是最大的帮助了，你完全可以自己找到正确的做法。
55 楼 <a href="http://zz563143188.iteye.com/" title="zz563143188" target="_blank">zz563143188</a> 2013-05-07</p>
<p>teasp 写道</p>
<p>楼主根本就没理解自己要讲的东西就在这里误人子弟。看了前面两个模式工厂和单例。抽象工厂方法模式有问题。单例的除了那个利用私有工厂产生实例的是正确的外，其他的实现方式都错了。
看来你是认真分析或者仔细斟酌过后才得出和结论吧，愿兄台能够具体指出歧义的地方。</p>
<p>54 楼 <a href="http://zz563143188.iteye.com/" title="zz563143188" target="_blank">zz563143188</a> 2013-05-07</p>
<p>GLC 写道</p>
<p><img src="" alt=""> 来到这里我想自己发现了一座宝库。。。
若遇知已则相见恨晚，若遇同行则相生相克。
53 楼 <a href="http://zz563143188.iteye.com/" title="zz563143188" target="_blank">zz563143188</a> 2013-05-07</p>
<p>qqweixing123 写道</p>
<p>您好，你的单例模式里对于并发情况下的处理感觉弄得过于复杂了，我的想法是：
1.public class Singleton {
2.</p>
<ol>
<li>//<em> 持有私有静态实例，防止被引用，此处赋值为null，目的是实现延迟加载 /</em>/</li>
<li><strong>private static Singleton instance = null;</strong>
替换成：
private static Singleton instance = new Singleton();
5.</li>
<li>//<em> 私有构造方法，防止被实例化 /</em>/</li>
<li>private Singleton() {</li>
<li>}
9.</li>
<li>//<em> 静态工程方法，创建实例 /</em>/</li>
<li>public static Singleton getInstance() {</li>
<li>将 **if (instance == null) {</li>
<li>instance = new Singleton();</li>
<li>}** 去掉</li>
<li>return instance;</li>
<li>}
17.</li>
<li>//<em> 如果该对象被用于序列化，可以保证对象在序列化前后保持一致 /</em>/</li>
<li>public Object readResolve() {</li>
<li>return instance;</li>
<li>}
22.}
每一个模式都是三部分组成的规则，表达的是某一个环境，一个问题以及解决问题的方案。</li>
</ol>
<p>52 楼 <a href="http://teasp.iteye.com/" title="teasp" target="_blank">teasp</a> 2013-05-07</p>
<p>qqweixing123 写道</p>
<p>您好，你的单例模式里对于并发情况下的处理感觉弄得过于复杂了，我的想法是：
1.public class Singleton {
2.</p>
<ol>
<li>//<em> 持有私有静态实例，防止被引用，此处赋值为null，目的是实现延迟加载 /</em>/</li>
<li><strong>private static Singleton instance = null;</strong>
替换成：
private static Singleton instance = new Singleton();
5.</li>
<li>//<em> 私有构造方法，防止被实例化 /</em>/</li>
<li>private Singleton() {</li>
<li>}
9.</li>
<li>//<em> 静态工程方法，创建实例 /</em>/</li>
<li>public static Singleton getInstance() {</li>
<li>将 **if (instance == null) {</li>
<li>instance = new Singleton();</li>
<li>}** 去掉</li>
<li>return instance;</li>
<li>}
17.</li>
<li>//<em> 如果该对象被用于序列化，可以保证对象在序列化前后保持一致 /</em>/</li>
<li>public Object readResolve() {</li>
<li>return instance;</li>
<li>}
22.}
你这个是即时加载的，楼主没讲，其实这种是最简单安全的。
51 楼 <a href="http://teasp.iteye.com/" title="teasp" target="_blank">teasp</a> 2013-05-07</li>
</ol>
<p>楼主根本就没理解自己要讲的东西就在这里误人子弟。看了前面两个模式工厂和单例。抽象工厂方法模式有问题。单例的除了那个利用私有工厂产生实例的是正确的外，其他的实现方式都错了。</p>
<p>50 楼 <a href="http://glc.iteye.com/" title="GLC" target="_blank">GLC</a> 2013-05-04</p>
<p><img src="" alt=""> 来到这里我想自己发现了一座宝库。。。
49 楼 <a href="http://qqweixing123.iteye.com/" title="qqweixing123" target="_blank">qqweixing123</a> 2013-05-02</p>
<p>您好，你的单例模式里对于并发情况下的处理感觉弄得过于复杂了，我的想法是：
1.public class Singleton {
2.</p>
<ol>
<li>//<em> 持有私有静态实例，防止被引用，此处赋值为null，目的是实现延迟加载 /</em>/</li>
<li><strong>private static Singleton instance = null;</strong>
替换成：
private static Singleton instance = new Singleton();
5.</li>
<li>//<em> 私有构造方法，防止被实例化 /</em>/</li>
<li>private Singleton() {</li>
<li>}
9.</li>
<li>//<em> 静态工程方法，创建实例 /</em>/</li>
<li>public static Singleton getInstance() {</li>
<li>将 **if (instance == null) {</li>
<li>instance = new Singleton();</li>
<li>}** 去掉</li>
<li>return instance;</li>
<li>}
17.</li>
<li>//<em> 如果该对象被用于序列化，可以保证对象在序列化前后保持一致 /</em>/</li>
<li>public Object readResolve() {</li>
<li>return instance;</li>
<li>}
22.}</li>
</ol>
<p>48 楼 <a href="http://zz563143188.iteye.com/" title="zz563143188" target="_blank">zz563143188</a> 2013-04-25</p>
<p>yjingy 写道</p>
<p>zz563143188 写道</p>
<p>yjingy 写道</p>
<p>为毛总感觉合成模式那里有点不对劲的感觉。。。
记得要区分叶子节点和树节点，而且根据树节点中管理方法的定义是否放在公共接口中有两种不同的区分来着。
可以说详细一点吗
这个可以看这个网址：<a href="http://eneasy.iteye.com/blog/174889，是同一个作者的博客，也是用的阎宏的《java与模式》书中的例子。" target="_blank">http://eneasy.iteye.com/blog/174889，是同一个作者的博客，也是用的阎宏的《java与模式》书中的例子。</a>
好的，我去看看
47 楼 <a href="http://zz563143188.iteye.com/" title="zz563143188" target="_blank">zz563143188</a> 2013-04-25</p>
<p>yjingy 写道</p>
<p>zz563143188 写道</p>
<p>yjingy 写道</p>
<p>刚看了几个，抽象工厂模式有点问题，抽象工厂应该是对应产品族的情况下使用的。
可以说详细一点
我看设计模式的时候看的是阎宏的《java与模式》一书，在网上搜了下，比较具体的描述可以看这个地方的：<a href="http://eneasy.iteye.com/blog/174831，在页面接近底部的位置，抽象工厂方法模式。" target="_blank">http://eneasy.iteye.com/blog/174831，在页面接近底部的位置，抽象工厂方法模式。</a>
好的，我仔细看看</p>
<p>46 楼 <a href="http://yjingy.iteye.com/" title="yjingy" target="_blank">yjingy</a> 2013-04-25</p>
<p>zz563143188 写道</p>
<p>yjingy 写道</p>
<p>为毛总感觉合成模式那里有点不对劲的感觉。。。
记得要区分叶子节点和树节点，而且根据树节点中管理方法的定义是否放在公共接口中有两种不同的区分来着。
可以说详细一点吗
这个可以看这个网址：<a href="http://eneasy.iteye.com/blog/174889，是同一个作者的博客，也是用的阎宏的《java与模式》书中的例子。" target="_blank">http://eneasy.iteye.com/blog/174889，是同一个作者的博客，也是用的阎宏的《java与模式》书中的例子。</a>
45 楼 <a href="http://yjingy.iteye.com/" title="yjingy" target="_blank">yjingy</a> 2013-04-25</p>
<p>zz563143188 写道</p>
<p>yjingy 写道</p>
<p>刚看了几个，抽象工厂模式有点问题，抽象工厂应该是对应产品族的情况下使用的。
可以说详细一点
我看设计模式的时候看的是阎宏的《java与模式》一书，在网上搜了下，比较具体的描述可以看这个地方的：<a href="http://eneasy.iteye.com/blog/174831，在页面接近底部的位置，抽象工厂方法模式。" target="_blank">http://eneasy.iteye.com/blog/174831，在页面接近底部的位置，抽象工厂方法模式。</a></p>
<p>« 上一页 1 <a href="http://zz563143188.iteye.com/blog/1847029?page=2#comments" target="_blank">2</a> <a href="http://zz563143188.iteye.com/blog/1847029?page=3#comments" target="_blank">3</a> <a href="http://zz563143188.iteye.com/blog/1847029?page=4#comments" target="_blank">4</a> <a href="http://zz563143188.iteye.com/blog/1847029?page=2#comments" target="_blank">下一页 »</a></p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/网上资料url集/">网上资料url集</a></li></span></span> | <span class="tags">Tagged <a href="/tags/网上资料url集/" class="label label-primary">网上资料url集</a></span> | <span class="time">recent updated:<time title="2014-03-26 20:59:35"datetime="2014-03-26 20:59:35"> mar. 26 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-Java开发中的23种设计模式详解/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-Java开发中的23种设计模式详解" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-从程序员到CTO的Java技术路线图/">从程序员到CTO的Java技术路线图 </a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:32.000Z"> <a href="/2014/02/02/2014-02-02-从程序员到CTO的Java技术路线图/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h3 id="-cto-java-"><a href="">从程序员到CTO的Java技术路线图</a> **</h3>
<h3 id="-">在技术方面无论我们怎么学习，总感觉需要提升自已不知道自己处于什么水平了。但如果有清晰的指示图供参考还是非常不错的，这样我们清楚的知道我们大概处于那个阶段和水平。</h3>
<h3 id="-"><img src="" alt=""></h3>
<h3 id="java-">Java程序员</h3>
<p>高级特性</p>
<pre><code>          反射、泛型、注释符、自动装箱和拆箱、枚举类、可变

          参数、可变返回类型、增强循环、静态导入

    核心编程

         IO、多线程、实体类、

         集合类、正则表达式、

         XML和属性文件

         图形编程

         AWT（Java2D/JavaSound/JMF）、Swing、SWT、JFace

    网路编程

        Applet、Socket/TCP/UDP、NIO、RMI、CORBA

   Java语法基础

       类、抽象类、接口、最终类、静态类、匿名类、内部类、异常类、编码规范

  Java开发环境

      JDK、JVM、Eclipse、Linux
</code></pre><p>Java核心编程技术</p>
<p>Java，设计而又非常精巧的语言。学习Java，须从Java开发环境开始，到Java语法，再到Java的核心API。</p>
<pre><code>    1.Java开发入门：Java开发环境的安装与使用，包括JDK命令、EclipseIDE、Linux下Java程序的开发和部署等。

    2.Java语法基础：基于JDK和Eclipse环境，进行Java核心功能开发，掌握Java面向对象的语法构成，包括类、抽象类、接口、最终类、静态类、匿名类、内部类、异常的编写。

    3.Java核心API：基于JDK提供的类库，掌握三大核心功能：

    A。Java核心编程:包括Java编程的两大核心功能——Java输入/输出流和多线程，以及常用的辅助类库——实体类、集合类、正则表达式、XML和属性文件。

    B。Java图形编程：包括Sun的GUI库AWT（Java2D、JavaSound、JMF）和Swing，IBM和GUI库SWT和Jface;

    C. Java网路编程：Applet组件编程，Socket编程，NIO非阻塞Socket编程、RMI和CORBA分布式开发。

    4.Java高级特性：掌握JDK1.4、JDK5.0、JDK6.0中的Java高级特性，包括反射、泛型、注释，以及java高级特性——自动装箱和拆箱、枚举类、可变参数、可变返回类型、增强循环、静态导入等。
</code></pre><h3 id="javaee-">JavaEE初级软件工程师</h3>
<p>JSF框架开发技术</p>
<pre><code>   配置文件（页面导航、后台Bean）、JSF组件库（JSF EL语言、HTML标签、事件处理、）、JSF核心库（格式转换、输入验证、国际化）
</code></pre><p>Javaweb核心开发技术       </p>
<pre><code>   开发环境（Eclipse、Linux）

   三大组件（JSP、JavaBean、Servlet）

   扩展技术（EL、JSTL、Taglib）
</code></pre><p>网页开发技术</p>
<pre><code>   HTML、XML、CSS、JavaScript、AJAX

   数据库设计技术

   SQL、MySql、Oracle、SQLServer、JDBC
</code></pre><p>Web服务器（Tomcat/Jetty/Resin/JBossWeb）</p>
<p>JavaWeb核心技术：</p>
<pre><code>    JavaWeb项目开发的全过程可以分解为：

   网页开发+数据库设计——&gt;JavaWeb项目开发，其中，javaWeb由6项基本技术组成：JSP+JavaBean+Servlet+EL+JSTL+Taglib，而JSF正是将这6种技术进行有机结合的技术框架：
</code></pre><h3 id="javaee-">JavaEE中级软件工程师</h3>
<p>四种经典架构SSH1、SSI1、SSH2、SSI2</p>
<pre><code>    Struts1表现层框架

  入门配置、核心组件、标签库、国际化、数据检验、数据库开发、Sitemesh集成、集成Hibernate/iBATIS

    Struts2表现层框架

           入门配置、核心组件、标签库、国际化、数据校验、Sitemesh集成转换器、拦截器、集成Hibernate/iBATIS

    Spring业务层框架

          入门配置、IoC容器、MVC、标签库、国际化、数据校验、数据库开发

    Hibernate持久层框架

        MySQL、Oracle、SQLServer iBATIS持久层框架

        MySQL、Oracle、SQLServer
</code></pre><p>Web服务器（Tomcat/Jetty/Resin/JBossWeb）</p>
<h3 id="java-">Java高级软件工程师</h3>
<p>javaWeb开源技术与框架</p>
<pre><code>    工作流、
</code></pre><p>规则引擎</p>
<p>搜索引擎、</p>
<p>缓存引擎 、</p>
<pre><code>    任务调度、
</code></pre><p>身份认证</p>
<pre><code>    报表服务、
</code></pre><p>系统测试、</p>
<pre><code>    集群、
</code></pre><p>负载平衡、</p>
<p>故障转移</p>
<p>JavaWeb分布式开发技术</p>
<p>JTA（Java事物管理）</p>
<pre><code>  JAAS（Java验证和授权服务）

  JNDI（Java命名和目录服务）

  JavaMail（Java邮件服务）
</code></pre><p>JMS（java信息服务）</p>
<p>WebService(web服务)</p>
<p>JCA（java连接体系）</p>
<p>JMS（java管理体系）</p>
<p>应用服务器（JBossAS/WebLogic/WebSphere）</p>
<h3 id="javaee-">JavaEE系统架构师</h3>
<pre><code>    面向云架构（COA）

        COA、SaaS、网格计算、集群计算、分布式计算、云计算

    面向资源架构（ROA）

        ROA、RESI

    面向web服务架构（SOA）

       WebService、SOA、SCA、ESB、OSGI、EAI

    Java设计模式

      创建式模式：抽象工厂/建造者/工厂方法/原型/单例

      构造型模式：适配器/桥接/组合/装饰/外观/享元/代理

      行为型模式：责任链/命令/解释器/迭代子/中介者/备忘录/观察者/状态/策略/模板方法/访问者

   Java与UML建模

      对象图、用例图、组件图、部署图、序列图、交互图、活动图、正向工程与逆向工程
</code></pre><h3 id="cto-">CTO首席技术官</h3>
<pre><code>     发展战略

     技术总监

     团队提升

     团队建设

     项目管理

     产品管理
</code></pre><p><strong>企业级项目实战(带源码)地址**</strong>：**<a href="http://zz563143188.iteye.com/blog/1825168" target="_blank"><a href="http://zz563143188.iteye.com/blog/1825168">http://zz563143188.iteye.com/blog/1825168</a></a></p>
<p><strong>收集五年的开发资料下载地址： </strong> <a href="http://pan.baidu.com/share/link?shareid=372668&amp;uk=4076915866#dir/path=%2F%E5%AD%A6%E4%B9%A0%E6%96%87%E4%BB%B6" title="http://pan.baidu.com/share/link?shareid=372668&amp;uk=4076915866" target="_blank"><a href="http://pan.baidu.com/share/link?shareid=372668&amp;uk=4076915866/#dir/path=%2F%E5%AD%A6%E4%B9%A0%E6%96%87%E4%BB%B6">http://pan.baidu.com/share/link?shareid=372668&amp;uk=4076915866/#dir/path=%2F%E5%AD%A6%E4%B9%A0%E6%96%87%E4%BB%B6</a></a></p>
<p><strong> 下面的更深入的有兴趣可以了解一下，我的目的不是要大家掌握下面的知识，只是希望扩展自己的思维，摘自牛人的技术博客。</strong></p>
<p><strong>//<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>牛人必看/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/*/</strong></p>
<p>系统后台框架：</p>
<p><img src="&quot;点击查看原始大小图片&quot;" alt=""></p>
<p><strong>前端工程师技能：</strong></p>
<p><strong><img src="&quot;点击查看原始大小图片&quot;" alt=""></strong></p>
<p>B2C电子商务基础系统架构解析
运营B2C日 久，越来越深刻的意识到IT系统对确保规范化业务流转，支撑消费者端的均一服务有着决定性的作用。于是，一直想好好整理下相关的系统架构，怎奈俗务缠身， 一直拖到今日，猛然发现下周娃很可能就要出生，拖无可拖，快马加笔，居然整出来了。本文的重点是理清系统的逻辑关系，详细的功能模块请参见结尾附上的系统 架构图。
首先，聊下对系统逻辑架构的看法；我个人始终坚持认为，系统的开发与演化，前台严格follow消费者的购买流程，后台则盯牢订单流转，牢牢抓住这两条主线，才能高屋建瓴的看清B2C的逻辑链和数据流，更深刻的规划功能模块，从而更有效支撑实际业务的流转。
前台系统包括：商品展示，内容展示，订单确认，支付系统，用户中心四大模块
一，商品展示
按照Ebay的内部分类，任何将商品以单个或批量的方式展示给消费者的功能均应归入此系统。因此，该系统至少包括：
A，站内搜索（搜索提示，搜索规则，搜索成功页，搜索不成功页，相似推荐）
B，导航（频道导航，其他导航如销售排行，广告位，推荐位，文字链，Also buy等）
C，商品分类（品牌分类，品类分类，属性分类如剪裁形式）
D， 登陆页（商品列表页，商品详细页，商品活动页）
这里的访问逻辑是：A /B/C分流消费者去往相对个性化的页面，由登陆页体现商家的核心诉求和价值传递，完成call-to-action的第一步。
二，内容展示
内容展示较为简单，对纯购物品牌而言包括：
A，公告区
B，帮助中心
C，论坛（如需商城与论坛发生交互，则需自行开发，否则可集成discuz做同步登陆即可）
大家都知道，就不多说了。
三，订单确认
订单确认，就是帮助消费者正确提交订单信息的环节，看似简单，实则非常复杂，需要对很多信息逻辑判断和处理，一般由2个部分组成：
A，购物车（购物车浮层，购物车页面，无注册购买）
无注册购买是需要慎用的功能，除非刻意追求用户的短平快下单，如团购/换购，一般不推荐使用，会造成系统异常复杂，开发量也很大。
B，订单提交（返回购物车，收货地址&amp;地址薄，支付方式判断，配送方式，发票，订单标记，实付金额计算等等）
值得一提的是，几乎大多数的促销逻辑运算在这个环节完成，充分考虑各种促销方式之间的互斥与重叠是系统设计的核心，需要充分考虑各种情况，避免出现逻辑漏洞。
四，支付系统
与一般的想象不同，支付系统其实并不简单等于第三方支付工具接入：
A，外部支付系统（支付宝将接口，财付通接口，网银直联端口，信用ka分期端口）
B，内部支付系统（账户余额，积分，礼品卡，优惠券）
支付系统的逻辑设计不但需要考虑到各种极端情况的发生（如一张订单先用礼品卡，再用积分，最后网银支付），还要预留财务做账所需的相关字段，并充分考虑订单取消之后如何回滚各类内部账户。
五，用户中心
用户中心的实质是用户自助功能的dashboard，一般4个部分组成：
A，注册&amp;登陆（快速注册，完整注册，注册有礼，推荐注册，密码找回，主站id登陆，open-id登陆如QQ，新浪微博等）
B，订单中心（历史订单状态，中间状态订单修改，物流追踪）
C，服务中心（各类自助服务如退款申请，退换货申请，建议与投诉等）
D， 信息管理（用户基本信息管理和账户信息管理）
用户中心的价值在于：尽可能引导用户自行获取所需的信息并提交所需的服务，在提升服务准确率，及时性的同时降低对人工成本。
后台系统包括：商品&amp;促销，CRM，订单处理，WMS，采购管理，财务管理，报表管理，系统设置，WA系统9大模块
一， 商品&amp;促销
商品&amp;促销模块的核心在于确保消费者下单之前，前台内容所见即所得
A， 商品管理（品类管理，品牌管理，单品管理）
B， 促销管理（活动管理和自定义活动模板管理）
在上述模块中，最重要的是2个部分：单品管理中的批量产品生成的自动程序和活动管理中“共享与互斥”管理。前者用于大幅提升上新速度，后者避免促销活动失控。
二， CRM
CRM是对B2C核心资源—会员的管理，服务与再营销系统，包括如下部分：
A，会员管理（会员信息的增删改查和到其他系统的链接）
B，用户关怀（条件触发和人工触发相关EDM &amp; 短信 &amp; OB）
C，定向营销（会员分组和营销活动管理）
D， 客服管理（内容非常多，集成所有需前台与后台交互的功能，详情还是看图吧）
E， 呼叫中心（IVR，坐席管理，统计报表，参数传递与窗口嵌入）
值得注意的，EDM和短信通道市面上已经有成熟的外包服务商，一般都会外包；呼叫中心和在线客服自行开发成本太高，特别是呼叫中心系统，业务初期也都是外包的。
三， 订单处理
订单处理是在订单未正式进入仓储部门处理之前，对订单的前置性处理环节。
A，订单录入（电话订购，网上下单，外部团购订单，无金额订单录入如礼品单）
B，订单审核（自动审核和人工审核）
C，RMA处理（RMA申请单和RMA处理单）
RMA的逻辑也异常复杂，需要在效率和成本之间找平衡，确保在不拖垮仓储部门的正常出入库的前提下对消费者端快速有效close工单；对内部则需要控制成本，货损不能超过预算上限。
四， WMS（Warehouse Management system仓库管理系统）
WMS的流程很长，功能模块也很多，大致分为入库管理，库存管理，出库管理和票据管理4个模块四个模块，细细道来就是另外一篇文章了，各位可以参考 我这篇文章：庖丁解牛—B2C仓储内部运作解密（上，中，下）<a href="http://blog.sina.com.cn/wangxida0855" target="_blank"><a href="http://blog.sina.com.cn/wangxida0855">http://blog.sina.com.cn/wangxida0855</a></a>
五， 采购管理
采购管理的核心是有效跟进采购合同/发票的状态，大货的采购入库/退库，财务结算和在仓库存查询和处理。
A，供应商管理（供应商信息管理，合同发票管理）
B，采购单管理（PO单管理，负PO单管理）
C，库存管理（库存查询，库存占用单，库存变动log）
六， 财务管理
B2C的财务管理，主要是对供应商，渠道和内部费用支出的成本控制。
A，供应商结算
B，渠道结算
C，配送结算
D， 内部结算
说实在的，哥对财务这块也不算很了解，大家将就看看，图片上有明细。
七， 报表管理
报表是B2C业务的宏观表现，理论上说，每个部门的KPI都应该从中找到。
A，搜索报表（站内搜索量查询）
B，销售报表（多个维度销量查询，优惠券使用情况，报表导出）
C，财务报表
D， 客服报表（客服日报和坐席报表）
前者反映与消费者发生的日常交互（包括正常与异常），后者考核客服的工作绩效
E， 仓储物流报表
这几块报表，是业务运作的核心，涉及到公司机密，就不能写的太细了，见谅。
八， 系统设置
这块大家都知道是干嘛的，也就不多说了，分成三块。
A，基础设置（和业务有关的一些字段值）
B，权限设置（不同账号的操作权限和操作记录）
C，其他设置
九， WA系统（Web Analytcis）
网站分析系 统，几乎全是外购，很少有能够自建的，即使自建，最多做几个简单的模块。用于实战的，要么是免费的GA（Google Analytics），要么是昂贵的Omniture。这块的知识，细细说来也是另外一篇文章了，有兴趣的同学可以看我这篇科普文章：揭秘—我所知道的网 站分析（上，下） <a href="http://blog.sina.com.cn/wangxida0855" target="_blank"><a href="http://blog.sina.com.cn/wangxida0855">http://blog.sina.com.cn/wangxida0855</a></a>
最后，上全系统大图，再感慨一句，B2C系统，真是一个大工程啊。</p>
<p><img src="&quot;点击查看原始大小图片&quot;" alt=""></p>
<p>fr  <a href="http://blog.sina.com.cn/s/blog_59d6717c0100syh3.html" target="_blank"><a href="http://blog.sina.com.cn/s/blog_59d6717c0100syh3.html">http://blog.sina.com.cn/s/blog_59d6717c0100syh3.html</a></a>
<strong>61</strong>
顶</p>
<p><strong>4</strong>
踩</p>
<p>分享到： <a href="&quot;分享到新浪微博&quot;"><img src="" alt=""></a> <a href="&quot;分享到腾讯微博&quot;"><img src="" alt=""></a></p>
<p><a href="http://zz563143188.iteye.com/blog/1876477" title="全国(大学)高等教育各学科视频教学全集 " target="_blank">全国(大学)高等教育各学科视频教学全集</a></p>
<ul>
<li>2013-05-28 06:45</li>
<li>浏览 11786</li>
<li><a href="http://zz563143188.iteye.com/blog/1877266#comments" target="_blank">评论(91)</a></li>
<li>分类:<a href="http://www.iteye.com/blogs/category/other" target="_blank">非技术</a></li>
<li><a href="http://www.iteye.com/wiki/blog/1877266" target="_blank">相关推荐</a></li>
</ul>
<h3 id="-">评论</h3>
<p><a href=""></a></p>
<p>91 楼 <a href="http://zz563143188.iteye.com/" title="zz563143188" target="_blank">zz563143188</a> 28 分钟前  </p>
<p>openFox 写道</p>
<p>感谢楼主的分享精神，其实做了2年J2ee也接触了其中大部分技术，但就是学的不深入，完全停留在会用阶段。准备按着LZ的思路再详细看一遍
根据实际情况和需要学习，可以深入基础学习一下。
90 楼 <a href="http://openfox.iteye.com/" title="openFox" target="_blank">openFox</a> 30 分钟前  </p>
<p>感谢楼主的分享精神，其实做了2年J2ee也接触了其中大部分技术，但就是学的不深入，完全停留在会用阶段。准备按着LZ的思路再详细看一遍</p>
<p>89 楼 <a href="http://zz563143188.iteye.com/" title="zz563143188" target="_blank">zz563143188</a> 2 小时前  </p>
<p>jackami121 写道</p>
<p><img src="" alt=""> LZ涉猎面真广
呵呵，还可以光注我更多博客，还有更多的惊喜等你。
88 楼 <a href="http://zz563143188.iteye.com/" title="zz563143188" target="_blank">zz563143188</a> 2 小时前  </p>
<p>maosijun 写道</p>
<p>很好。 受教了
知识面有点广，希望你能根据实际情况学习。</p>
<p>87 楼 <a href="http://zz563143188.iteye.com/" title="zz563143188" target="_blank">zz563143188</a> 2 小时前  </p>
<p>mikzhang 写道</p>
<p>zz563143188 写道</p>
<p>mikzhang 写道</p>
<p>我觉得CTO未必这些全会<img src="" alt="">
当然不用全会，具体根据公司业务和规模决定的。主要是让大家知道有些知识，开拓视野。
我的意思是 你可以给出一个成为CTO的主线技术<img src="" alt="">
面对大众的东西，是不能细分的。只能面面俱到，然后可以根据需要自己拉主线。
86 楼 <a href="http://jackami121.iteye.com/" title="jackami121" target="_blank">jackami121</a> 2 小时前  </p>
<p><img src="" alt=""> LZ涉猎面真广</p>
<p>85 楼 <a href="http://maosijun.iteye.com/" title="maosijun" target="_blank">maosijun</a> 2 小时前  </p>
<p>很好。 受教了
84 楼 <a href="http://mikzhang.iteye.com/" title="mikzhang" target="_blank">mikzhang</a> 3 小时前  </p>
<p>zz563143188 写道</p>
<p>mikzhang 写道</p>
<p>我觉得CTO未必这些全会<img src="" alt="">
当然不用全会，具体根据公司业务和规模决定的。主要是让大家知道有些知识，开拓视野。
我的意思是 你可以给出一个成为CTO的主线技术<img src="" alt=""></p>
<p>83 楼 <a href="http://zz563143188.iteye.com/" title="zz563143188" target="_blank">zz563143188</a> 3 小时前  </p>
<p>iamxi 写道</p>
<p>这图叫扯淡，耽误无数青少年。你看CTO的都是XX管理、XX管理，这些和图下面的技术有毛线关系。要注意的是程序员的进阶中，至少有两条路线，技术路线和管理路线，如果一直走技术，可以成为某领域的大牛。如果走管理才会去努力当个CTO。
呵呵，你误会我的意思了。下面的这图不是要大家掌握，只是让看看有哪些技术。有兴趣的可以参考对比自己的不足，如果没有兴趣也就茶后饭谈聊天而已。
82 楼 <a href="http://iamxi.iteye.com/" title="iamxi" target="_blank">iamxi</a> 3 小时前  </p>
<p>这图叫扯淡，耽误无数青少年。你看CTO的都是XX管理、XX管理，这些和图下面的技术有毛线关系。要注意的是程序员的进阶中，至少有两条路线，技术路线和管理路线，如果一直走技术，可以成为某领域的大牛。如果走管理才会去努力当个CTO。</p>
<p>81 楼 <a href="http://zz563143188.iteye.com/" title="zz563143188" target="_blank">zz563143188</a> 4 小时前  </p>
<p>mikzhang 写道</p>
<p>我觉得CTO未必这些全会<img src="" alt="">
当然不用全会，具体根据公司业务和规模决定的。主要是让大家知道有些知识，开拓视野。
80 楼 <a href="http://mikzhang.iteye.com/" title="mikzhang" target="_blank">mikzhang</a> 4 小时前  </p>
<p>我觉得CTO未必这些全会<img src="" alt=""></p>
<p>79 楼 <a href="http://zz563143188.iteye.com/" title="zz563143188" target="_blank">zz563143188</a> 4 小时前  </p>
<p>tuweijie 写道</p>
<p>[color=red][/color][size=large][/size][align=center][/align][b][/b]太牛了
学习永无静止，只要有心。
78 楼 <a href="http://zz563143188.iteye.com/" title="zz563143188" target="_blank">zz563143188</a> 4 小时前  </p>
<p>cloudzb 写道</p>
<p>LZ厉害！现在还是下层的人，表示压力三大！
人是没有上下层之分的，只是我比你早了一占，如果再过三年你又比刚毕业的人前进了很多，不是层次问题，而是阅历问题。</p>
<p>77 楼 <a href="http://zz563143188.iteye.com/" title="zz563143188" target="_blank">zz563143188</a> 4 小时前  </p>
<p>zhongxiaweimian 写道</p>
<p>哎<img src="" alt=""> 要学的东西还很多呢
根据自己需要学习，在有多余的时间再学习自己喜欢的。
76 楼 <a href="http://tuweijie.iteye.com/" title="tuweijie" target="_blank">tuweijie</a> 4 小时前  </p>
<p>[color=red][/color][size=large][/size][align=center][/align][b][/b]太牛了</p>
<p>75 楼 <a href="http://cloudzb.iteye.com/" title="cloudzb" target="_blank">cloudzb</a> 4 小时前  </p>
<p>LZ厉害！现在还是下层的人，表示压力三大！
74 楼 <a href="http://zhongxiaweimian.iteye.com/" title="zhongxiaweimian" target="_blank">zhongxiaweimian</a> 5 小时前  </p>
<p>哎<img src="" alt=""> 要学的东西还很多呢</p>
<p>73 楼 <a href="http://zz563143188.iteye.com/" title="zz563143188" target="_blank">zz563143188</a> 20 小时前  </p>
<p>kun20031029 写道</p>
<p>难得楼主这么无私奉献，先谢过了
呵呵，那就好好吸收吧。
72 楼 <a href="http://kun20031029.iteye.com/" title="kun20031029" target="_blank">kun20031029</a> 20 小时前  </p>
<p>难得楼主这么无私奉献，先谢过了</p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/网上资料url集/">网上资料url集</a></li></span></span> | <span class="tags">Tagged <a href="/tags/网上资料url集/" class="label label-primary">网上资料url集</a></span> | <span class="time">recent updated:<time title="2014-03-26 20:49:24"datetime="2014-03-26 20:49:24"> mar. 26 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-从程序员到CTO的Java技术路线图/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-从程序员到CTO的Java技术路线图" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>





<ul id="pagination" class="pagination pagination-lg">
  <li><a class="extend prev" href="/page/133/">&laquo;</a></li><li><a class="page-number" href="/">1</a></li><li><a class="page-number" href="/page/2/">2</a></li><li><span class="space">&hellip;</span></li><li><a class="page-number" href="/page/131/">131</a></li><li><a class="page-number" href="/page/132/">132</a></li><li><a class="page-number" href="/page/133/">133</a></li><li class="active"><li><span class="page-number current">134</span></li><li><a class="page-number" href="/page/135/">135</a></li><li><a class="page-number" href="/page/136/">136</a></li><li><a class="page-number" href="/page/137/">137</a></li><li><span class="space">&hellip;</span></li></li><li><a class="page-number" href="/page/161/">161</a></li><li><a class="page-number" href="/page/162/">162</a></li><li><a class="extend next" href="/page/135/">&raquo;</a></li>
  <div class="clearfix"></div>
</ul></div><!--wapper-->
       </div><!-- ID main-col END -->
       <aside id="sidebar" class="alignright col-sx-6 col-sm-4 col-md-3 col-lg-3">
<div id="widget_search" class="widget panel panel-primary">
    <form action="//google.com/search" method="get" accept-charset="utf-8">
  <div class="input-group">
    <input class="form-control" id="searchbox" type="search" name="q" results="0" placeholder="search">
    <span class="input-group-btn">
      <button class="btn btn-default" type="submit">Go!</button>
    </span>
    <input type="hidden" name="q" value="site:itsolife.com">
  </div>
</form>
</div>

<div id="widget_category" class="widget panel panel-primary">
  <div class="panel-heading">category</div>  <div data-src='category' class='ajax_widgets'>正在加载...</div>
</div>

<div id="widget_recent_posts" class="widget panel panel-primary">
  <div class="panel-heading">recent posts</div>  <div data-src='recent_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_tagcloud" class="widget panel panel-primary">
  <div class="panel-heading">tagcloud</div>  <div data-src='tagcloud' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_latest_update_posts" class="widget panel panel-primary">
  <div class="panel-heading">最近更新</div>  <div data-src='latest_update_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_recent_comments" class="widget panel panel-primary">
  <div class="panel-heading">recent comments</div>  

<div class="list-group-item ds-recent-comments" data-num-items="6" data-show-avatars="1" data-show-time="1" data-show-title="1" data-show-admin="1" data-excerpt-length="50"></div>



</div>

</aside>
       <div class="clearfix"></div>
     </div><!-- row END -->
  </div>
  <footer id="footer" class="container">
  <div class="panel panel-info">
  <section id='footer_widget'></section>  <div class="panel-footer">
  <div id="site-info">
    <span class='author'>
  
  &copy; 2014 RobinChia
  
    &nbsp;&nbsp;</span>
  
  <span id='analytics-51la'></span><span id='analytics-google'>
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-48559895-1']);
  _gaq.push(['_trackPageview']);
  _js2load.push({src:('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'});
</script></span><span id='analytics-cnzz'>
<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_5774006'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s17.cnzz.com/stat.php%3Fid%3D5774006%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>
</span><span id='analytics-baidu'>
<script>
var _hmt = _hmt || [];
_js2load.push({src:"//hm.baidu.com/hm.js?1442f50724afc42380b51f097c43082c"});
</script>
</span>  </div>
  <div id="copyright">Site powered by <a href='http://zespia.tw/hexo/'><strong>hexo</strong></a>  update time: <em>2014-04-07 17:26:53</em></span></div>
</div>
<div class="clearfix"></div>


  </div>
  </footer>
  
        <script src="http://cdn.bootcss.com/jquery/1.10.2/jquery.min.js"></script>        
        <script src="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/js/bootstrap.min.js"></script>        
                
        <script src="http://cdn.bootcss.com/prettify/r298/prettify.min.js"></script>    <script type="text/javascript">
   var lang=["bsh", "c", "cc", "cpp", "cs", "csh", "cyc", "cv", "htm", "html",
    "java", "js", "m", "mxml", "perl", "pl", "pm", "py", "rb", "sh",
    "xhtml", "xml", "xsl"];
   var pretty_base='';
   $('script').each(function(){
	var c = $(this).attr('src');
	if (!c)
	    return;
	if (c.match(/(\/)?prettify(\.min)?\.js/i))
	{
	    var index = c.lastIndexOf('/');
	    if (index != -1)
		pretty_base = c.substr(0,index + 1);
	    return false;
	}
   })
   $('pre code').each(function(){
	var c = $(this).attr('class')
	if (!c)
	    return;
	c = c.match(/\s?(lang\-\w+)/i);
	if (c && lang.indexOf(c[1]) == -1)
	{
	    lang.push(c[1]);
	    $.getScript(pretty_base + c[1] + '.min.js');
	}
   })

    $(window).load(function(){
       $("pre").addClass("prettyprint");
       prettyPrint();
    })
</script>    
            <script type="text/javascript">
var duoshuoQuery = {short_name:"robinchia"};
_js2load.push({src:'http://static.duoshuo.com/embed.js',charset:'UTF-8'});
</script>
    
            <!--wumii_relatedItems-->
    
        <script src="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js"></script>    <script type="text/javascript">
(function($){
  $('.entry').each(function(i){
    $(this).find('img').each(function(){
      var alt = this.alt;

      if (alt){
        $(this).before('<span class="caption">' + alt + '</span>');
      }

      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox" rel="fancybox' + i + '" />');
    });
  });

  $('.fancybox').fancybox();
})(jQuery);
</script>    
        <script src="http://cdn.bootcss.com/mathjax/2.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>    <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>
    
<script type="text/javascript">
$('.ajax_widgets').each(function(){var src=$(this).attr('data-src');if(src)$(this).load('/widgets/'+src+'.html');});
$.each(_js2load,function(index,obj){loadjs(obj.src,obj.charset)});
</script>

<div id="scroll2top">
<img src="/scroll2top/arrow.png"/>
</div>
<script src="/scroll2top/scroll2top.min.js"></script>
<div id="winterland">
  <canvas></canvas>
</div>
<script src="/js/winterland.min.js"></script>

  </body>
</html>
