
<!DOCTYPE HTML>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>The 40 Page | It so life</title>
<meta name="author" content="RobinChia">

<meta name="description" content="It so life">


<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<meta property="og:site_name" content="It so life"/>

<!--[if IE]><style>.testIE.IE{display:inline;}</style><![endif]-->
<!--[if lte IE 7]><link rel="stylesheet" href="/css/ie7.css" type="text/css"><![endif]-->
<!--[if (lt IE 9)&(gt IE 7)]><style>.testIE.IE8{display:inline;}</style><![endif]-->
<!--[if gt IE 8]><style>.testIE.IE9{display:inline;}</style><![endif]-->

<link href="/favicon.png" rel="icon">
<link rel="alternate" href="/atom.xml" title="It so life Feed" type="application/atom+xml">

<link rel="stylesheet" href="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/css/bootstrap.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/font-awesome/4.0.3/css/font-awesome.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/prettify/r298/prettify.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" type="text/css">
<link rel="stylesheet" href="/css/style.css" type="text/css">
<!--[if lt IE 9]>
   <style>article,aside,dialog,footer,header,section,footer,nav,figure,menu{display:block}</style>
   <script src="http://cdn.staticfile.org/html5shiv/r29/html5.min.js"></script>
   <script src="http://cdn.staticfile.org/respond.js/1.4.2/respond.min.js"></script>
<link href="http://cdn.staticfile.org/respond.js/1.4.2/respond-proxy.html" id="respond-proxy" rel="respond-proxy" />
<link href="/js/respond.proxy.gif" id="respond-redirect" rel="respond-redirect" />
<script src="/js/respond.proxy.js"></script>
   <script src="http://cdn.bootcss.com/selectivizr/1.0.2/selectivizr-min.js"></script>
<![endif]-->
<script type="text/javascript">
function loadjs(c,d){var a=document.createElement("script");a.async=!0;a.type="text/javascript";a.src=c;a.charset=d||"gbk";(document.getElementsByTagName("HEAD")[0]||document.getElementsByTagName("BODY")[0]).appendChild(a)};
var _protocol = (("https:" == document.location.protocol) ? " https://" : " http://");
var _js2load = [];
</script>

</head>
<body>
      <header id="header" class="container"><nav id="main-nav" class="navbar navbar-default navbar-fixed-top " role="navigation">
  <div class="container">
    <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
      <span class="sr-only">Toggle navigation</span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="/">It so life</a>
    </div>
    <div  class="collapse navbar-collapse">
      <ul  class="nav navbar-nav">
  
        <li><a href="/" title="Home">Home</a></li>      
        <li><a href="/about/" title="About">About</a></li>      
        <li><a href="/archives/" title="Archives">Archives</a></li>      
      <li class='dropdown'>
        <a class='dropdown-toggle' data-toggle='dropdown' href='#'>website<b class='caret'></b></a>
        <ul class='dropdown-menu pure-menu-selected'>
    
          <li><a href="//groups.google.com/forum/#!forum/pongba" title="TopLanguage">TopLanguage</a></li>    
          <li><a href="//itpub.net/" title="ITPub">ITPub</a></li>    
          <li><a href="//blog.jobbole.com/" title="Bole">Bole</a></li>    
          <li><a href="//nosql-database.org/" title="nosql">nosql</a></li>    
          <li><a href="//gitimmersion.googol.im/" title="Git">Git</a></li>    
        </ul>
      </li>
    
      </ul>
      <ul class="nav navbar-nav navbar-right">
      
        <li><a href="/atom.xml">RSS</a></li>
      
      
        <li><a href="https://twitter.com/robinchia">twitter</a></li>
      
      
      
      
        <li><a href="https://github.com/robinchia">github</a></li>
      
      </ul>
    </div>
  </div>
</nav>
<div class="clearfix"></div>
</header>
  <div id='content' class="container">
     <div class="page-header-wrapper">
      <!--[if lt IE 9]><div class="alert alert-warning alert-dismissable"><button type="button" class="close" data-dismiss="alert" aria-hidden="true">&times;</button><strong>提示:</strong>您的浏览器版本太低了,建议升级到 <strong><a href="http://windows.microsoft.com/zh-cn/internet-explorer/download-ie" title="IE9">IE9</a></strong> 以上,本站使用<a href="https://www.google.com/intl/zh-CN/chrome/">Chrome浏览器</a>可以获得最好的显示效果.</div><![endif]-->
      <div class="page-header"><h1 align="center"><big>It so life</big> </h1>
        <h5 align="center"><big>love as life</big></h5>
      </div>
     </div>
     <div class="row">
       <div id="main-col" class="alignleft col-sx-12 col-sm-8 col-md-9 col-lg-9">
      <section id='header_widget'></section>
          <div id="wrapper"><article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-Nutz--Nutz对继承POJO的有效操作（原创）/">Nutz 对继承POJO的有效操作（原创）</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:43.000Z"> <a href="/2014/02/02/2014-02-02-Nutz--Nutz对继承POJO的有效操作（原创）/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="nutz-pojo-">Nutz 对继承POJO的有效操作（原创）</h1>
<p>Nutz对POJO直接操作数据库是有效的，同时对继承类（子类）的操作，一定程序上是有效的。</p>
<p>如下：
建立POJO类testt：</p>
<p>import org.nutz.dao.entity.annotation.Column;
import org.nutz.dao.entity.annotation.Id;</p>
<p>import org.nutz.dao.entity.annotation.Table;
import org.nutz.dao.impl.NutDao;</p>
<p>@Table(&quot;venus_testt&quot;)
public class testt {</p>
<pre><code>@Id
private int id;

@Column(&quot;name&quot;)
private String name;

@Column
private String test;
</code></pre><p>}</p>
<p>子类test2：
import org.nutz.dao.entity.annotation.Column;</p>
<p>public class test2 extends testt {
    @Column</p>
<pre><code>private String haha;
</code></pre><p>}</p>
<p>测试父类，建立表成功。</p>
<pre><code>    Dao dao = ioc.get(Dao.class, &quot;dao&quot;);
    dao.create(testt.class, false);
</code></pre><p>Table: venus_test</p>
<p><strong>字段信息</strong>
Field Type Comment id int(32) name varchar(50) test varchar(50)
测试子类，同样也成功：</p>
<pre><code>       Dao dao = ioc.get(Dao.class, &quot;dao&quot;);       
     dao.create(test2.class, false);
</code></pre><p>Table: venus_test</p>
<p><strong>字段信息</strong>
Field Type Comment id int(32) haha varchar(50) name varchar(50) test varchar(50)
如果将子类指定表名：</p>
<p>@Table(&quot;venus_t_test&quot;)
则同样成功：</p>
<p><img src="" alt="">
 Table: venus_t_test</p>
<p><strong>字段信息</strong>
Field Type Comment id int(32) haha varchar(50) name varchar(50) test varchar(50)</p>
<p>当需要对表进行精确控制时，可采用@ColDefine
如果，test2可修改如下：</p>
<p>import org.nutz.dao.entity.annotation.ColDefine;</p>
<p>import org.nutz.dao.entity.annotation.ColType;
import org.nutz.dao.entity.annotation.Column;</p>
<p>import org.nutz.dao.entity.annotation.Table;
@Table(&quot;venus_t_test&quot;)</p>
<p>public class test2 extends testt {
    @Column</p>
<pre><code>@ColDefine(type=ColType.VARCHAR,width=128,notNull=true)
private String haha; }
</code></pre><p>测试后，结果如下：
<img src="" alt=""></p>
<hr>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Nutz/">Nutz</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Nutz/" class="label label-primary">Nutz</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:44"datetime="2014-03-07 09:54:44"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-Nutz--Nutz对继承POJO的有效操作（原创）/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-Nutz--Nutz对继承POJO的有效操作（原创）" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-Nutz--Nutz匿名内部类的传值/">Nutz匿名内部类的传值</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:43.000Z"> <a href="/2014/02/02/2014-02-02-Nutz--Nutz匿名内部类的传值/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="nutz-">Nutz匿名内部类的传值</h1>
<p>在Nutz中,存在大量需要使用匿名内部类的情况,很多童鞋都对传值很困惑,所以我这里说明一下</p>
<p><strong>传入**</strong>:**
//匿名内部类,只能访问final的本地变量及方法参数</p>
<p>public void addUser(final String name, String passwd, final String userType) {</p>
<pre><code>User user = null;

if (&quot;admin&quot;.equal(userType))

   user = new AdminUser(name, passwd); //仅作演示.

else

   user = new User(name, passwd);

final User _user = user; //因为user变量不能设置为final,所以需要新加一个变量来中转

Trans.run(new Atom(){

    public void run() {

        dao.insert(_user);

        if (log.isDebugEnable())

            log.debugf(&quot;Add user id=%d, name=%s , type=%s&quot;, _user.getId(), name, userType);

    }

});
</code></pre><p>}</p>
<p><strong>传出**</strong>(<strong><strong>获取方法返回值等等</strong></strong>):**</p>
<p><strong>方法**</strong>1 –<strong>**对象数组法</strong> 通过一个final的Object对象数组,存放需要的值
public long countUser(final String userType) {</p>
<pre><code>final Object[] objs = new Object[1];

Trans.run(new Atom(){

    public void run() {

        objs[0] = dao.count(User.class, Cnd.where(&#39;userType&#39;, &#39;=&#39;, userType));

    }

});

return ((Number)objs[0]).longValue();
</code></pre><p>}</p>
<p><strong>方法**</strong>2 – ThreadLocal<strong>**法</strong> 通过一个ThreadLocal来存放结果,这个ThreadLocal可以是静态的,供全app使用的</p>
<p>private static final ThreadLocal re = new ThreadLocal(); //自行补上泛型Object</p>
<p>public long countUser(final String userType) {</p>
<pre><code>Trans.run(new Atom(){

    public void run() {

        re.set(dao.count(User.class, Cnd.where(&#39;userType&#39;, &#39;=&#39;, userType)));

    }

});

return ((Number)re.get()).longValue(); //严谨一点的话,应该将ThreadLocal置空
</code></pre><p>}</p>
<p><strong>方法**</strong>3 – Molecule<strong>**法</strong> Molecule类是Nutz内置的抽象类类,实现Runnable和Atom接口,添加了两个获取/设置值的方法.</p>
<p>public long countUser(final String userType) {</p>
<pre><code>Molecule mole = new Molecule() { //需要自行补齐泛型

    public void run() {

        setObj(dao.count(User.class, Cnd.where(&#39;userType&#39;, &#39;=&#39;, userType)));

    }

};

Trans.run(mole);

return ((Number)mole.getObj()).longValue();
</code></pre><p>}</p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Nutz/">Nutz</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Nutz/" class="label label-primary">Nutz</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:43"datetime="2014-03-07 09:54:43"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-Nutz--Nutz匿名内部类的传值/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-Nutz--Nutz匿名内部类的传值" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-连接池--用连接池提高Servlet访问数据库的效率-txt/">用连接池提高Servlet访问数据库的效率 (</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:43.000Z"> <a href="/2014/02/02/2014-02-02-连接池--用连接池提高Servlet访问数据库的效率-txt/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-servlet-txt">用连接池提高Servlet访问数据库的效率 (-).txt</h1>
<p>作者：jeru</p>
<p>日期：2000-12-7 11:45:06
Java Servlet作为首选的服务器端数据处理技术，正在迅速取代CGI脚本。Servlet超越CGI的优势之一在于，不仅多个请求</p>
<p>可以共享公用资源，而且还可以在不同用户请求之间保留持续数据。本文介绍一种充分发挥该特色的实用技术，即数据库连
接池。</p>
<p>一、实现连接池的意义</p>
<p>动态Web站点往往用数据库存储的信息生成Web页面，每一个页面请求导致一次数据库访问。连接
数据库不仅要开销一定的通讯和内存资源，还必须完成用户验证、安全上下文配置这类任务，因而往往成为最为耗时的操</p>
<p>作。当然，实际的连接时间开销千变万化，但1到2秒延迟并非不常见。如果某个基于数据库的Web应用只需建立一次初始连
接，不同页面请求能够共享同一连接，就能获得显著的性能改善。</p>
<p>Servlet是一个Java类。Servlet引擎（它可能是Web服务软件的一部分，也可能是一个独立的附加模块）在系统启动或Servlet
第一次被请求时将该类装入Java虚拟机并创建它的一个实例。不同用户请求由同一Servlet实例的多个独立线程处理。那些要</p>
<p>求在不同请求之间持续有效的数据既可以用Servlet的实例变量来保存，也可以保存在独立的辅助对象中。
用JDBC访问数据库首先要创建与数据库之间的连接，获得一个连接对象（Connection），由连接对象提供执行SQL语句的方法。</p>
<p>本文介绍的数据库连接池包括一个管理类DBConnectionManager，负责提供与多个连接池对象（DBConnectionPool类）之间
的接口。每一个连接池对象管理一组JDBC连接对象，每一个连接对象可以被任意数量的Servlet共享。</p>
<p>类DBConnectionPool提供以下功能：</p>
<p>1) 从连接池获取（或创建）可用连接。
2) 把连接返回给连接池。</p>
<p>3) 在系统关闭时释放所有资源，关闭所有连接。</p>
<p>此外， DBConnectionPool类还能够处理无效连接（原来登记为可用的连接，由于某种原因不再可用，如超时，通讯问题）
，并能够限制连接池中的连接总数不超过某个预定值。</p>
<p>管理类DBConnectionManager用于管理多个连接池对象，它提供以下功能：</p>
<p>1) 装载和注册JDBC驱动程序。
2) 根据在属性文件中定义的属性创建连接池对象。</p>
<p>3) 实现连接池名字与其实例之间的映射。
4) 跟踪客户程序对连接池的引用，保证在最后一个客户程序结束时安全地关闭所有连接池。</p>
<p>本文余下部分将详细说明这两个类，最后给出一个示例演示Servlet使用连接池的一般过程。</p>
<p>二、具体实现</p>
<p>DBConnectionManager.java程序清单如下：</p>
<p>001 import java.io./<em>;
002 import java.sql./</em>;</p>
<p>003 import java.util./*;
004 import java.util.Date;</p>
<p>005
006 //<em>/</em></p>
<p>007 /<em> 管理类DBConnectionManager支持对一个或多个由属性文件定义的数据库连接
008 /</em> 池的访问.客户程序可以调用getInstance()方法访问本类的唯一实例.</p>
<p>009 /*/
010 public class DBConnectionManager {</p>
<p>011 static private DBConnectionManager instance; // 唯一实例
012 static private int clients;</p>
<p>013
014 private Vector drivers = new Vector();</p>
<p>015 private PrintWriter log;
016 private Hashtable pools = new Hashtable();</p>
<p>017
018 //<em>/</em></p>
<p>019 /<em> 返回唯一实例.如果是第一次调用此方法,则创建实例
020 /</em></p>
<p>021 /<em> @return DBConnectionManager 唯一实例
022 /</em>/</p>
<p>023 static synchronized public DBConnectionManager getInstance() {
024 if (instance == null) {</p>
<p>025 instance = new DBConnectionManager();
026 }</p>
<p>027 clients++;
028 return instance;</p>
<p>029 }
030</p>
<p>031 //<em>/</em>
032 /* 建构函数私有以防止其它对象创建本类实例</p>
<p>033 /*/
034 private DBConnectionManager() {</p>
<p>035 init();
036 }</p>
<p>037
038 //<em>/</em></p>
<p>039 /<em> 将连接对象返回给由名字指定的连接池
040 /</em></p>
<p>041 /<em> @param name 在属性文件中定义的连接池名字
042 /</em> @param con 连接对象</p>
<p>043 /*/
044 public void freeConnection(String name, Connection con) {</p>
<p>045 DBConnectionPool pool = (DBConnectionPool) pools.get(name);
046 if (pool != null) {</p>
<p>047 pool.freeConnection(con);
048 }</p>
<p>049 }
050</p>
<p>051 //<em>/</em>
052 /* 获得一个可用的(空闲的)连接.如果没有可用连接,且已有连接数小于最大连接数</p>
<p>053 /<em> 限制,则创建并返回新连接
054 /</em></p>
<p>055 /<em> @param name 在属性文件中定义的连接池名字
056 /</em> @return Connection 可用连接或null</p>
<p>057 /*/
058 public Connection getConnection(String name) {</p>
<p>059 DBConnectionPool pool = (DBConnectionPool) pools.get(name);
060 if (pool != null) {</p>
<p>061 return pool.getConnection();
062 }</p>
<p>063 return null;
064 }</p>
<p>065
066 //<em>/</em></p>
<p>067 /<em> 获得一个可用连接.若没有可用连接,且已有连接数小于最大连接数限制,
068 /</em> 则创建并返回新连接.否则,在指定的时间内等待其它线程释放连接.</p>
<p>069 /<em>
070 /</em> @param name 连接池名字</p>
<p>071 /<em> @param time 以毫秒计的等待时间
072 /</em> @return Connection 可用连接或null</p>
<p>073 /*/
074 public Connection getConnection(String name, long time) {</p>
<p>075 DBConnectionPool pool = (DBConnectionPool) pools.get(name);
076 if (pool != null) {</p>
<p>077 return pool.getConnection(time);
078 }</p>
<p>079 return null;
080 }</p>
<p>081
082 //<em>/</em></p>
<p>083 /<em> 关闭所有连接,撤销驱动程序的注册
084 /</em>/</p>
<p>085 public synchronized void release() {
086 // 等待直到最后一个客户程序调用</p>
<p>087 if (--clients != 0) {
088 return;</p>
<p>089 }
090</p>
<p>091 Enumeration allPools = pools.elements();
092 while (allPools.hasMoreElements()) {</p>
<p>093 DBConnectionPool pool = (DBConnectionPool) allPools.nextElement();
094 pool.release();</p>
<p>095 }
096 Enumeration allDrivers = drivers.elements();</p>
<p>097 while (allDrivers.hasMoreElements()) {
098 Driver driver = (Driver) allDrivers.nextElement();</p>
<p>099 try {
100 DriverManager.deregisterDriver(driver);</p>
<p>101 log(&quot;撤销JDBC驱动程序 &quot; + driver.getClass().getName()+&quot;的注册&quot;);
102 }</p>
<p>103 catch (SQLException e) {
104 log(e, &quot;无法撤销下列JDBC驱动程序的注册: &quot; + driver.getClass().getName());</p>
<p>105 }
106 }</p>
<p>107 }
108</p>
<p>109 //<em>/</em>
110 /* 根据指定属性创建连接池实例.</p>
<p>111 /<em>
112 /</em> @param props 连接池属性</p>
<p>113 /*/
114 private void createPools(Properties props) {</p>
<p>115 Enumeration propNames = props.propertyNames();
116 while (propNames.hasMoreElements()) {</p>
<p>117 String name = (String) propNames.nextElement();
118 if (name.endsWith(&quot;.url&quot;)) {</p>
<p>119 String poolName = name.substring(0, name.lastIndexOf(&quot;.&quot;));
120 String url = props.getProperty(poolName + &quot;.url&quot;);</p>
<p>121 if (url == null) {
122 log(&quot;没有为连接池&quot; + poolName + &quot;指定URL&quot;);</p>
<p>123 continue;
124 }</p>
<p>125 String user = props.getProperty(poolName + &quot;.user&quot;);
126 String password = props.getProperty(poolName + &quot;.password&quot;);</p>
<p>127 String maxconn = props.getProperty(poolName + &quot;.maxconn&quot;, &quot;0&quot;);
128 int max;</p>
<p>129 try {
130 max = Integer.valueOf(maxconn).intValue();</p>
<p>131 }
132 catch (NumberFormatException e) {</p>
<p>133 log(&quot;错误的最大连接数限制: &quot; + maxconn + &quot; .连接池: &quot; + poolName);
134 max = 0;</p>
<p>135 }
136 DBConnectionPool pool =</p>
<p>137 new DBConnectionPool(poolName, url, user, password, max);
138 pools.put(poolName, pool);</p>
<p>139 log(&quot;成功创建连接池&quot; + poolName);
140 }</p>
<p>141 }
142 }</p>
<p>143
144 //<em>/</em></p>
<p>145 /<em> 读取属性完成初始化
146 /</em>/</p>
<p>147 private void init() {
148 InputStream is = getClass().getResourceAsStream(&quot;/db.properties&quot;);</p>
<p>149 Properties dbProps = new Properties();
150 try {</p>
<p>151 dbProps.load(is);
152 }</p>
<p>153 catch (Exception e) {
154 System.err.println(&quot;不能读取属性文件. &quot; +</p>
<p>155 &quot;请确保db.properties在CLASSPATH指定的路径中&quot;);
156 return;</p>
<p>157 }
158 String logFile = dbProps.getProperty(&quot;logfile&quot;, &quot;DBConnectionManager.log&quot;);</p>
<p>159 try {
160 log = new PrintWriter(new FileWriter(logFile, true), true);</p>
<p>161 }
162 catch (IOException e) {</p>
<p>163 System.err.println(&quot;无法打开日志文件: &quot; + logFile);
164 log = new PrintWriter(System.err);</p>
<p>165 }
166 loadDrivers(dbProps);</p>
<p>167 createPools(dbProps);
168 }</p>
<p>169
170 //<em>/</em></p>
<p>171 /<em> 装载和注册所有JDBC驱动程序
172 /</em></p>
<p>173 /<em> @param props 属性
174 /</em>/</p>
<p>175 private void loadDrivers(Properties props) {
176 String driverClasses = props.getProperty(&quot;drivers&quot;);</p>
<p>177 StringTokenizer st = new StringTokenizer(driverClasses);
178 while (st.hasMoreElements()) {</p>
<p>179 String driverClassName = st.nextToken().trim();
180 try {</p>
<p>181 Driver driver = (Driver)
182 Class.forName(driverClassName).newInstance();</p>
<p>183 DriverManager.registerDriver(driver);
184 drivers.addElement(driver);</p>
<p>185 log(&quot;成功注册JDBC驱动程序&quot; + driverClassName);
186 }</p>
<p>187 catch (Exception e) {
188 log(&quot;无法注册JDBC驱动程序: &quot; +</p>
<p>189 driverClassName + &quot;, 错误: &quot; + e);
190 }</p>
<p>191 }
192 }</p>
<p>193
194 //<em>/</em></p>
<p>195 /<em> 将文本信息写入日志文件
196 /</em>/</p>
<p>197 private void log(String msg) {
198 log.println(new Date() + &quot;: &quot; + msg);</p>
<p>199 }
200</p>
<p>201 //<em>/</em>
202 /* 将文本信息与异常写入日志文件</p>
<p>203 /*/
204 private void log(Throwable e, String msg) {</p>
<p>205 log.println(new Date() + &quot;: &quot; + msg);
206 e.printStackTrace(log);</p>
<p>207 }
208</p>
<p>209 //<em>/</em>
210 /* 此内部类定义了一个连接池.它能够根据要求创建新连接,直到预定的最</p>
<p>211 /<em> 大连接数为止.在返回连接给客户程序之前,它能够验证连接的有效性.
212 /</em>/</p>
<p>213 class DBConnectionPool {
214 private int checkedOut;</p>
<p>215 private Vector freeConnections = new Vector();
216 private int maxConn;</p>
<p>217 private String name;
218 private String password;</p>
<p>219 private String URL;
220 private String user;</p>
<p>221
222 //<em>/</em></p>
<p>223 /<em> 创建新的连接池
224 /</em></p>
<p>225 /<em> @param name 连接池名字
226 /</em> @param URL 数据库的JDBC URL</p>
<p>227 /<em> @param user 数据库帐号,或 null
228 /</em> @param password 密码,或 null</p>
<p>229 /<em> @param maxConn 此连接池允许建立的最大连接数
230 /</em>/</p>
<p>231 public DBConnectionPool(String name, String URL, String user, String password,
232 int maxConn) {</p>
<p>233 this.name = name;
234 this.URL = URL;</p>
<p>235 this.user = user;
236 this.password = password;</p>
<p>237 this.maxConn = maxConn;
238 }</p>
<p>239
240 //<em>/</em></p>
<p>241 /<em> 将不再使用的连接返回给连接池
242 /</em></p>
<p>243 /<em> @param con 客户程序释放的连接
244 /</em>/</p>
<p>245 public synchronized void freeConnection(Connection con) {
246 // 将指定连接加入到向量末尾</p>
<p>247 freeConnections.addElement(con);
248 checkedOut--;</p>
<p>249 notifyAll();
250 }</p>
<p>251
252 //<em>/</em></p>
<p>253 /<em> 从连接池获得一个可用连接.如没有空闲的连接且当前连接数小于最大连接
254 /</em> 数限制,则创建新连接.如原来登记为可用的连接不再有效,则从向量删除之,</p>
<p>255 /<em> 然后递归调用自己以尝试新的可用连接.
256 /</em>/</p>
<p>257 public synchronized Connection getConnection() {
258 Connection con = null;</p>
<p>259 if (freeConnections.size() &gt; 0) {
260 // 获取向量中第一个可用连接</p>
<p>261 con = (Connection) freeConnections.firstElement();
262 freeConnections.removeElementAt(0);</p>
<p>263 try {
264 if (con.isClosed()) {</p>
<p>265 log(&quot;从连接池&quot; + name+&quot;删除一个无效连接&quot;);
266 // 递归调用自己,尝试再次获取可用连接</p>
<p>267 con = getConnection();
268 }</p>
<p>269 }
270 catch (SQLException e) {</p>
<p>271 log(&quot;从连接池&quot; + name+&quot;删除一个无效连接&quot;);
272 // 递归调用自己,尝试再次获取可用连接</p>
<p>273 con = getConnection();
274 }</p>
<p>275 }
276 else if (maxConn == 0 || checkedOut &lt; maxConn) {</p>
<p>277 con = newConnection();
278 }</p>
<p>279 if (con != null) {
280 checkedOut++;</p>
<p>281 }
282 return con;</p>
<p>283 }
284</p>
<p>285 //<em>/</em>
286 /* 从连接池获取可用连接.可以指定客户程序能够等待的最长时间</p>
<p>287 /<em> 参见前一个getConnection()方法.
288 /</em></p>
<p>289 /<em> @param timeout 以毫秒计的等待时间限制
290 /</em>/</p>
<p>291 public synchronized Connection getConnection(long timeout) {
292 long startTime = new Date().getTime();</p>
<p>293 Connection con;
294 while ((con = getConnection()) == null) {</p>
<p>295 try {
296 wait(timeout);</p>
<p>297 }
298 catch (InterruptedException e) {}</p>
<p>299 if ((new Date().getTime() - startTime) &gt;= timeout) {
300 // wait()返回的原因是超时</p>
<p>301 return null;
302 }</p>
<p>303 }
304 return con;</p>
<p>305 }
306</p>
<p>307 //<em>/</em>
308 /* 关闭所有连接</p>
<p>309 /*/
310 public synchronized void release() {</p>
<p>311 Enumeration allConnections = freeConnections.elements();
312 while (allConnections.hasMoreElements()) {</p>
<p>313 Connection con = (Connection) allConnections.nextElement();
314 try {</p>
<p>315 con.close();
316 log(&quot;关闭连接池&quot; + name+&quot;中的一个连接&quot;);</p>
<p>317 }
318 catch (SQLException e) {</p>
<p>319 log(e, &quot;无法关闭连接池&quot; + name+&quot;中的连接&quot;);
320 }</p>
<p>321 }
322 freeConnections.removeAllElements();</p>
<p>323 }
324</p>
<p>325 //<em>/</em>
326 /* 创建新的连接</p>
<p>327 /*/
328 private Connection newConnection() {</p>
<p>329 Connection con = null;
330 try {</p>
<p>331 if (user == null) {
332 con = DriverManager.getConnection(URL);</p>
<p>333 }
334 else {</p>
<p>335 con = DriverManager.getConnection(URL, user, password);
336 }</p>
<p>337 log(&quot;连接池&quot; + name+&quot;创建一个新的连接&quot;);
338 }</p>
<p>339 catch (SQLException e) {
340 log(e, &quot;无法创建下列URL的连接: &quot; + URL);</p>
<p>341 return null;
342 }</p>
<p>343 return con;
344 }</p>
<p>345 }
346 }</p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/连接池/">连接池</a></li></span></span> | <span class="tags">Tagged <a href="/tags/连接池/" class="label label-primary">连接池</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:43"datetime="2014-03-07 09:54:43"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-连接池--用连接池提高Servlet访问数据库的效率-txt/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-连接池--用连接池提高Servlet访问数据库的效率-txt" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-连接池--druid教程/">druid 教程</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:43.000Z"> <a href="/2014/02/02/2014-02-02-连接池--druid教程/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="druid-">druid 教程</h1>
<pre><code> java程序很大一部分要操作数据库，为了提高性能操作数据库的时候，有不得不使用数据库连接池。数据库连接池有很多选择，c3p、dhcp、proxool等，druid作为一名后起之秀，凭借其出色的性能，也逐渐印入了大家的眼帘。接下来本教程就说一下druid的简单使用。
</code></pre><p> 首先从<a href="http://repo1.maven.org/maven2/com/alibaba/druid/" target="_blank"><a href="http://repo1.maven.org/maven2/com/alibaba/druid/">http://repo1.maven.org/maven2/com/alibaba/druid/</a></a> 下载最新的jar包。如果想使用最新的源码编译，可以从<a href="https://github.com/alibaba/druid" target="_blank"><a href="https://github.com/alibaba/druid">https://github.com/alibaba/druid</a></a> 下载源码，然后使用maven命令行，或者导入到eclipse中进行编译。</p>
<h2 id="-1-"><a href=""></a>1 配置</h2>
<p>和dbcp类似，druid的配置项如下</p>
<p>配置 缺省值 说明 name   配置这个属性的意义在于，如果存在多个数据源，监控的时候
可以通过名字来区分开来。如果没有配置，将会生成一个名字，
格式是：&quot;DataSource-&quot; + System.identityHashCode(this) jdbcUrl   连接数据库的url，不同数据库不一样。例如：
mysql : jdbc:mysql://10.20.153.104:3306/druid2 
oracle : jdbc:oracle:thin:@10.20.149.85:1521:ocnauto username   连接数据库的用户名 password   连接数据库的密码。如果你不希望密码直接写在配置文件中，
可以使用ConfigFilter。详细看这里：
<a href="https://github.com/alibaba/druid/wiki/%E4%BD%BF%E7%94%A8ConfigFilter" target="_blank"><a href="https://github.com/alibaba/druid/wiki/%E4%BD%BF%E7%94%A8ConfigFilter">https://github.com/alibaba/druid/wiki/%E4%BD%BF%E7%94%A8ConfigFilter</a></a> driverClassName 根据url自动识别 这一项可配可不配，如果不配置druid会根据url自动识别dbType，
然后选择相应的driverClassName initialSize 0 初始化时建立物理连接的个数。初始化发生在显示调用init方法，
或者第一次getConnection时 maxActive 8 最大连接池数量 maxIdle 8 已经不再使用，配置了也没效果 minIdle   最小连接池数量 maxWait   获取连接时最大等待时间，单位毫秒。配置了maxWait之后，
缺省启用公平锁，并发效率会有所下降，
如果需要可以通过配置useUnfairLock属性为true使用非公平锁。 poolPreparedStatements false 是否缓存preparedStatement，也就是PSCache。
PSCache对支持游标的数据库性能提升巨大，比如说oracle。
在mysql下建议关闭。 maxOpenPreparedStatements -1 要启用PSCache，必须配置大于0，当大于0时，
poolPreparedStatements自动触发修改为true。
在Druid中，不会存在Oracle下PSCache占用内存过多的问题，
可以把这个数值配置大一些，比如说100 validationQuery   用来检测连接是否有效的sql，要求是一个查询语句。
如果validationQuery为null，testOnBorrow、testOnReturn、
testWhileIdle都不会其作用。 testOnBorrow true 申请连接时执行validationQuery检测连接是否有效，
做了这个配置会降低性能。 testOnReturn false 归还连接时执行validationQuery检测连接是否有效，
做了这个配置会降低性能 testWhileIdle false 建议配置为true，不影响性能，并且保证安全性。
申请连接的时候检测，如果空闲时间大于
timeBetweenEvictionRunsMillis，
执行validationQuery检测连接是否有效。 timeBetweenEvictionRunsMillis   有两个含义：
1) Destroy线程会检测连接的间隔时间
 2) testWhileIdle的判断依据，详细看testWhileIdle属性的说明 numTestsPerEvictionRun   不再使用，一个DruidDataSource只支持一个EvictionRun minEvictableIdleTimeMillis     connectionInitSqls   物理连接初始化的时候执行的sql exceptionSorter 根据dbType自动识别 当数据库抛出一些不可恢复的异常时，抛弃连接 filters   属性类型是字符串，通过别名的方式配置扩展插件，
常用的插件有：
监控统计用的filter:stat 
日志用的filter:log4j
 防御sql注入的filter:wall proxyFilters   类型是List<com.alibaba.druid.filter.Filter>，
如果同时配置了filters和proxyFilters，
是组合关系，并非替换关系<strong>表1.1 配置属性</strong></p>
<p>根据常用的配置属性，首先给出一个如下的配置文件，放置于src目录下。</p>
<p><strong>[plain]</strong> <a href="http://blog.csdn.net/yunnysunny/article/details/8657095#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/yunnysunny/article/details/8657095#" title="copy" target="_blank">copy</a></p>
<ol>
<li>url:jdbc:mysql://localhost:3306/dragoon_v25_masterdb  </li>
<li>driverClassName:com.mysql.jdbc.Driver  </li>
<li>username:root  </li>
<li>password:aaaaaaaa  </li>
<li></li>
<li>filters:stat  </li>
<li></li>
<li>maxActive:20  </li>
<li>initialSize:1  </li>
<li>maxWait:60000  </li>
<li>minIdle:10  </li>
<li>/#maxIdle:15  </li>
<li></li>
<li>timeBetweenEvictionRunsMillis:60000  </li>
<li>minEvictableIdleTimeMillis:300000  </li>
<li></li>
<li>validationQuery:SELECT &#39;x&#39;  </li>
<li>testWhileIdle:true  </li>
<li>testOnBorrow:false  </li>
<li>testOnReturn:false  </li>
<li>/#poolPreparedStatements:true  </li>
<li>maxOpenPreparedStatements:20  </li>
<li></li>
<li>/#对于长时间不使用的连接强制关闭  </li>
<li>removeAbandoned:true  </li>
<li>/#超过30分钟开始关闭空闲连接  </li>
<li>removeAbandonedTimeout:1800  </li>
<li>/#将当前关闭动作记录到日志  </li>
<li>logAbandoned:true  </li>
</ol>
<p><strong>配置文件1.1 </strong></p>
<p>配置项中指定了各个参数后，在连接池内部是这么使用这些参数的。数据库连接池在初始化的时候会创建initialSize个连接，当有数据库操作时，会从池中取出一个连接。如果当前池中正在使用的连接数等于maxActive，则会等待一段时间，等待其他操作释放掉某一个连接，如果这个等待时间超过了maxWait，则会报错；如果当前正在使用的连接数没有达到maxActive，则判断当前是否空闲连接，如果有则直接使用空闲连接，如果没有则新建立一个连接。在连接使用完毕后，不是将其物理连接关闭，而是将其放入池中等待其他操作复用。</p>
<p>同时连接池内部有机制判断，如果当前的总的连接数少于miniIdle，则会建立新的空闲连接，以保证连接数得到miniIdle。如果当前连接池中某个连接在空闲了timeBetweenEvictionRunsMillis时间后任然没有使用，则被物理性的关闭掉。有些数据库连接的时候有超时限制（mysql连接在8小时后断开），或者由于网络中断等原因，连接池的连接会出现失效的情况，这时候设置一个testWhileIdle参数为true，可以保证连接池内部定时检测连接的可用性，不可用的连接会被抛弃或者重建，最大情况的保证从连接池中得到的Connection对象是可用的。当然，为了保证绝对的可用性，你也可以使用testOnBorrow为true（即在获取Connection对象时检测其可用性），不过这样会影响性能。</p>
<h2 id="-2-"><a href=""></a>2 代码编写</h2>
<h3 id="-2-1-spring"><a href=""></a>2.1 使用spring</h3>
<p>首先给出spring配置文件</p>
<p><strong>[html]</strong> <a href="http://blog.csdn.net/yunnysunny/article/details/8657095#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/yunnysunny/article/details/8657095#" title="copy" target="_blank">copy</a></p>
<ol>
<li>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;  </li>
<li>&lt;beans xmlns=&quot;<a href="http://www.springframework.org/schema/beans" target="_blank">http://www.springframework.org/schema/beans</a>&quot;  </li>
<li>xmlns:xsi=&quot;<a href="http://www.w3.org/2001/XMLSchema-instance" target="_blank">http://www.w3.org/2001/XMLSchema-instance</a>&quot;  </li>
<li>xsi:schemaLocation=&quot;<a href="http://www.springframework.org/schema/mvc" target="_blank">http://www.springframework.org/schema/mvc</a> <a href="http://www.springframework.org/schema/mvc/spring-mvc-3.0.xsd" target="_blank">http://www.springframework.org/schema/mvc/spring-mvc-3.0.xsd</a>  </li>
<li><a href="http://www.springframework.org/schema/beans" target="_blank">http://www.springframework.org/schema/beans</a> <a href="http://www.springframework.org/schema/beans/spring-beans-3.0.xsd" target="_blank">http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</a>  </li>
<li><a href="http://www.springframework.org/schema/context" target="_blank">http://www.springframework.org/schema/context</a> <a href="http://www.springframework.org/schema/context/spring-context-3.0.xsd&quot;&gt;" target="_blank">http://www.springframework.org/schema/context/spring-context-3.0.xsd&quot;&gt;</a>  </li>
<li><!-- 给web使用的spring文件 -->  </li>
<li>&lt;bean id=&quot;propertyConfigurer&quot;  </li>
<li>class=&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&gt;  </li>
<li><property name="locations">  </li>
<li><list>  </li>
<li><value>/WEB-INF/classes/dbconfig.properties</value>  </li>
<li></list>  </li>
<li></property>  </li>
<li></bean>  </li>
<li>&lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;  </li>
<li>destroy-method=&quot;close&quot;&gt;  </li>
<li><property name="url" value="${url}" />  </li>
<li><property name="username" value="${username}" />  </li>
<li><property name="password" value="${password}" />  </li>
<li><property name="driverClassName" value="${driverClassName}" />  </li>
<li><property name="filters" value="${filters}" />  </li>
<li></li>
<li><property name="maxActive" value="${maxActive}" />  </li>
<li><property name="initialSize" value="${initialSize}" />  </li>
<li><property name="maxWait" value="${maxWait}" />  </li>
<li><property name="minIdle" value="${minIdle}" />  </li>
<li></li>
<li><property name="timeBetweenEvictionRunsMillis" value="${timeBetweenEvictionRunsMillis}" />  </li>
<li><property name="minEvictableIdleTimeMillis" value="${minEvictableIdleTimeMillis}" />  </li>
<li></li>
<li><property name="validationQuery" value="${validationQuery}" />  </li>
<li><property name="testWhileIdle" value="${testWhileIdle}" />  </li>
<li><property name="testOnBorrow" value="${testOnBorrow}" />  </li>
<li><property name="testOnReturn" value="${testOnReturn}" />  </li>
<li>&lt;property name=&quot;maxOpenPreparedStatements&quot;  </li>
<li>value=&quot;${maxOpenPreparedStatements}&quot; /&gt;  </li>
<li><property name="removeAbandoned" value="${removeAbandoned}" /> <!-- 打开removeAbandoned功能 -->  </li>
<li><property name="removeAbandonedTimeout" value="${removeAbandonedTimeout}" /> <!-- 1800秒，也就是30分钟 -->  </li>
<li><property name="logAbandoned" value="${logAbandoned}" /> <!-- 关闭abanded连接时输出错误日志 -->  </li>
<li></bean>  </li>
<li></li>
<li>&lt;bean id=&quot;dataSourceDbcp&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot;  </li>
<li>destroy-method=&quot;close&quot;&gt;  </li>
<li></li>
<li><property name="driverClassName" value="${driverClassName}" />  </li>
<li><property name="url" value="${url}" />  </li>
<li><property name="username" value="${username}" />  </li>
<li><property name="password" value="${password}" />  </li>
<li></li>
<li><property name="maxActive" value="${maxActive}" />  </li>
<li><property name="minIdle" value="${minIdle}" />  </li>
<li><property name="maxWait" value="${maxWait}" />  </li>
<li><property name="defaultAutoCommit" value="true" />  </li>
<li></li>
<li><property name="timeBetweenEvictionRunsMillis" value="${timeBetweenEvictionRunsMillis}" />  </li>
<li><property name="minEvictableIdleTimeMillis" value="${minEvictableIdleTimeMillis}" />  </li>
<li></li>
<li><property name="validationQuery" value="${validationQuery}" />  </li>
<li><property name="testWhileIdle" value="${testWhileIdle}" />  </li>
<li><property name="testOnBorrow" value="${testOnBorrow}" />  </li>
<li><property name="testOnReturn" value="${testOnReturn}" />  </li>
<li>&lt;property name=&quot;maxOpenPreparedStatements&quot;  </li>
<li>value=&quot;${maxOpenPreparedStatements}&quot; /&gt;  </li>
<li><property name="removeAbandoned" value="${removeAbandoned}" />   </li>
<li><property name="removeAbandonedTimeout" value="${removeAbandonedTimeout}" />  </li>
<li><property name="logAbandoned" value="${logAbandoned}" />  </li>
<li></bean>  </li>
<li></li>
<li></li>
<li><!-- jdbcTemplate -->  </li>
<li><bean id="jdbc" class="org.springframework.jdbc.core.JdbcTemplate">  </li>
<li><property name="dataSource">  </li>
<li><ref bean="dataSource" />  </li>
<li></property>  </li>
<li></bean>  </li>
<li></li>
<li>&lt;bean id=&quot;SpringTableOperatorBean&quot; class=&quot;com.whyun.druid.model.TableOperator&quot;  </li>
<li>scope=&quot;prototype&quot;&gt;  </li>
<li><property name="dataSource">  </li>
<li><ref bean="dataSource" />  </li>
<li></property>  </li>
<li></bean>  </li>
<li></li>
<li></beans>  </li>
</ol>
<p><strong>配置文件2.1</strong></p>
<p>其中第一个bean中给出的配置文件/WEB-INF/classes/dbconfig.properties就是第1节中给出的配置文件。我这里还特地给出dbcp的spring配置项，目的就是将两者进行对比，方便大家进行迁移。这里没有使用JdbcTemplate，所以jdbc那个bean没有使用到。下面给出com.whyun.druid.model.TableOperator类的代码。</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/yunnysunny/article/details/8657095#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/yunnysunny/article/details/8657095#" title="copy" target="_blank">copy</a></p>
<ol>
<li>package com.whyun.druid.model;  </li>
<li></li>
<li>import java.sql.Connection;  </li>
<li>import java.sql.PreparedStatement;  </li>
<li>import java.sql.SQLException;  </li>
<li>import java.sql.Statement;  </li>
<li></li>
<li>import javax.sql.DataSource;  </li>
<li></li>
<li>public class TableOperator {  </li>
<li>private DataSource dataSource;  </li>
<li>public void setDataSource(DataSource dataSource) {  </li>
<li>this.dataSource = dataSource;  </li>
<li>}  </li>
<li></li>
<li>private static final int COUNT = 800;      </li>
<li></li>
<li>public TableOperator() {  </li>
<li></li>
<li>}  </li>
<li></li>
<li>public void tearDown() throws Exception {  </li>
<li>try {  </li>
<li>dropTable();  </li>
<li>} catch (SQLException e) {  </li>
<li>e.printStackTrace();  </li>
<li>}         </li>
<li>}  </li>
<li></li>
<li>public void insert() throws Exception {  </li>
<li></li>
<li>StringBuffer ddl = new StringBuffer();  </li>
<li>ddl.append(&quot;INSERT INTO t_big (&quot;);  </li>
<li>for (int i = 0; i &lt; COUNT; ++i) {  </li>
<li>if (i != 0) {  </li>
<li>ddl.append(&quot;, &quot;);  </li>
<li>}  </li>
<li>ddl.append(&quot;F&quot; + i);  </li>
<li>}  </li>
<li>ddl.append(&quot;) VALUES (&quot;);  </li>
<li>for (int i = 0; i &lt; COUNT; ++i) {  </li>
<li>if (i != 0) {  </li>
<li>ddl.append(&quot;, &quot;);  </li>
<li>}  </li>
<li>ddl.append(&quot;?&quot;);  </li>
<li>}  </li>
<li>ddl.append(&quot;)&quot;);  </li>
<li></li>
<li>Connection conn = dataSource.getConnection();  </li>
<li></li>
<li>//        System.out.println(ddl.toString());  </li>
<li></li>
<li>PreparedStatement stmt = conn.prepareStatement(ddl.toString());  </li>
<li></li>
<li>for (int i = 0; i &lt; COUNT; ++i) {  </li>
<li>stmt.setInt(i + 1, i);  </li>
<li>}  </li>
<li>stmt.execute();  </li>
<li>stmt.close();  </li>
<li></li>
<li>conn.close();  </li>
<li>}  </li>
<li></li>
<li>private void dropTable() throws SQLException {  </li>
<li></li>
<li>Connection conn = dataSource.getConnection();  </li>
<li></li>
<li>Statement stmt = conn.createStatement();  </li>
<li>stmt.execute(&quot;DROP TABLE t_big&quot;);  </li>
<li>stmt.close();  </li>
<li></li>
<li>conn.close();  </li>
<li>}  </li>
<li></li>
<li>public void createTable() throws SQLException {  </li>
<li>StringBuffer ddl = new StringBuffer();  </li>
<li>ddl.append(&quot;CREATE TABLE t_big (FID INT AUTO_INCREMENT PRIMARY KEY &quot;);  </li>
<li>for (int i = 0; i &lt; COUNT; ++i) {  </li>
<li>ddl.append(&quot;, &quot;);  </li>
<li>ddl.append(&quot;F&quot; + i);  </li>
<li>ddl.append(&quot; BIGINT NULL&quot;);  </li>
<li>}  </li>
<li>ddl.append(&quot;)&quot;);  </li>
<li></li>
<li>Connection conn = dataSource.getConnection();  </li>
<li></li>
<li>Statement stmt = conn.createStatement();  </li>
<li>stmt.execute(ddl.toString());  </li>
<li>stmt.close();  </li>
<li></li>
<li>conn.close();  </li>
<li>}  </li>
<li>}  </li>
</ol>
<p><strong>代码片段2.1</strong></p>
<p><strong>注意：在使用的时候，通过获取完Connection对象，在使用完之后，要将其close掉，这样其实是将用完的连接放入到连接池中，如果你不close的话，会造成连接泄露。</strong>
然后我们写一个servlet来测试他.</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/yunnysunny/article/details/8657095#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/yunnysunny/article/details/8657095#" title="copy" target="_blank">copy</a></p>
<ol>
<li>package com.whyun.druid.servelt;  </li>
<li></li>
<li>import java.io.IOException;  </li>
<li>import java.io.PrintWriter;  </li>
<li>import java.sql.SQLException;  </li>
<li></li>
<li>import javax.servlet.ServletContext;  </li>
<li>import javax.servlet.ServletException;  </li>
<li>import javax.servlet.http.HttpServlet;  </li>
<li>import javax.servlet.http.HttpServletRequest;  </li>
<li>import javax.servlet.http.HttpServletResponse;  </li>
<li></li>
<li>import org.springframework.web.context.WebApplicationContext;  </li>
<li>import org.springframework.web.context.support.WebApplicationContextUtils;  </li>
<li></li>
<li>import com.whyun.druid.model.TableOperator;  </li>
<li></li>
<li>public class TestServlet extends HttpServlet {  </li>
<li>private TableOperator operator;  </li>
<li></li>
<li></li>
<li>@Override  </li>
<li>public void init() throws ServletException {  </li>
<li></li>
<li>super.init();  </li>
<li>ServletContext servletContext = this.getServletContext();     </li>
<li></li>
<li>WebApplicationContext ctx  </li>
<li>= WebApplicationContextUtils.getWebApplicationContext(servletContext);  </li>
<li>operator = (TableOperator)ctx.getBean(&quot;SpringTableOperatorBean&quot;);  </li>
<li>}  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* The doGet method of the servlet. <br> </li>
<li>/* </li>
<li>/* This method is called when a form has its tag value method equals to get. </li>
<li>/*  </li>
<li>/* @param request the request send by the client to the server </li>
<li>/* @param response the response send by the server to the client </li>
<li>/* @throws ServletException if an error occurred </li>
<li>/* @throws IOException if an error occurred </li>
<li>/*/  </li>
<li>public void doGet(HttpServletRequest request, HttpServletResponse response)  </li>
<li>throws ServletException, IOException {  </li>
<li></li>
<li>response.setContentType(&quot;text/html&quot;);  </li>
<li>PrintWriter out = response.getWriter();  </li>
<li></li>
<li>boolean createResult = false;  </li>
<li>boolean insertResult = false;  </li>
<li>boolean dropResult = false;  </li>
<li></li>
<li>try {  </li>
<li>operator.createTable();  </li>
<li>createResult = true;  </li>
<li>} catch (SQLException e) {  </li>
<li>e.printStackTrace();  </li>
<li>}  </li>
<li>if (createResult) {  </li>
<li>try {  </li>
<li>operator.insert();  </li>
<li>insertResult = true;  </li>
<li>} catch (Exception e) {  </li>
<li>e.printStackTrace();  </li>
<li>}  </li>
<li>try {  </li>
<li>operator.tearDown();  </li>
<li>dropResult = true;  </li>
<li>} catch (Exception e) {  </li>
<li>e.printStackTrace();  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li></li>
<li>out.println(&quot;{&#39;createResult&#39;:&quot;+createResult+&quot;,&#39;insertResult&#39;:&quot;  </li>
<li>+insertResult+&quot;,&#39;dropResult&#39;:&quot;+dropResult+&quot;}&quot;);  </li>
<li></li>
<li>out.flush();  </li>
<li>out.close();  </li>
<li>}  </li>
<li></li>
<li>}<br><strong>代码片段2.2</strong></li>
</ol>
<p>这里没有用到struts2或者springmvc，虽然大部分开发者用的是这两种框架。</p>
<h3 id="-2-2-spring"><a href=""></a>2.2 不使用spring</h3>
<p>类似于dbcp，druid也提供了原生态的支持。先看下面这段代码：</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/yunnysunny/article/details/8657095#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/yunnysunny/article/details/8657095#" title="copy" target="_blank">copy</a></p>
<ol>
<li>package com.whyun.util.db;  </li>
<li></li>
<li>import javax.sql.DataSource;  </li>
<li></li>
<li>import org.apache.commons.dbcp.BasicDataSourceFactory;  </li>
<li></li>
<li>import com.alibaba.druid.pool.DruidDataSourceFactory;  </li>
<li>import com.whyun.util.config.MySqlConfigProperty;  </li>
<li>import com.whyun.util.config.MySqlConfigProperty2;  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* The Class DataSourceUtil. </li>
<li>/*/  </li>
<li>public class DataSourceUtil {  </li>
<li></li>
<li>//<em>/</em> 使用配置文件dbconfig.properties构建Druid数据源. /*/  </li>
<li>public static final int DRUID_MYSQL_SOURCE = 0;  </li>
<li></li>
<li>//<em>/</em> 使用配置文件dbconfig2.properties构建Druid数据源. /*/  </li>
<li>public static final int DRUID_MYSQL_SOURCE2 = 1;  </li>
<li></li>
<li>//<em>/</em> 使用配置文件dbconfig.properties构建Dbcp数据源. /*/  </li>
<li>public static final int DBCP_SOURCE = 4;  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* 根据类型获取数据源 </li>
<li>/* </li>
<li>/* @param sourceType 数据源类型 </li>
<li>/* @return druid或者dbcp数据源 </li>
<li>/* @throws Exception the exception </li>
<li>/*/  </li>
<li>public static final DataSource getDataSource(int sourceType)  </li>
<li>throws Exception {  </li>
<li>DataSource dataSource = null;  </li>
<li>switch(sourceType) {  </li>
<li>case DRUID_MYSQL_SOURCE:              </li>
<li>dataSource = DruidDataSourceFactory.createDataSource(  </li>
<li>MySqlConfigProperty.getInstance().getProperties());               </li>
<li>break;  </li>
<li>case DRUID_MYSQL_SOURCE2:  </li>
<li>dataSource = DruidDataSourceFactory.createDataSource(  </li>
<li>MySqlConfigProperty2.getInstance().getProperties());  </li>
<li>break;  </li>
<li>case DBCP_SOURCE:  </li>
<li>dataSource = BasicDataSourceFactory.createDataSource(  </li>
<li>MySqlConfigProperty.getInstance().getProperties());  </li>
<li>break;  </li>
<li>}  </li>
<li>return dataSource;  </li>
<li>}  </li>
<li>}  </li>
</ol>
<p><strong>代码片段2.3 手动读取配置文件初始化连接池</strong></p>
<p>第37行中调用了类com.alibaba.druid.pool.DruidDataSourceFactory中createDataSource方法来初始化一个连接池。对比dbcp的使用方法，两者很相似。</p>
<p>下面给出一个多线程的测试程序。运行后可以比较druid和dbcp的性能差别。</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/yunnysunny/article/details/8657095#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/yunnysunny/article/details/8657095#" title="copy" target="_blank">copy</a></p>
<ol>
<li>package com.whyun.druid.test;  </li>
<li></li>
<li>import java.sql.SQLException;  </li>
<li>import java.util.ArrayList;  </li>
<li>import java.util.List;  </li>
<li>import java.util.concurrent.Callable;  </li>
<li>import java.util.concurrent.ExecutorService;  </li>
<li>import java.util.concurrent.Executors;  </li>
<li>import java.util.concurrent.Future;  </li>
<li>import java.util.concurrent.TimeUnit;  </li>
<li></li>
<li>import com.whyun.druid.model.TableOperator;  </li>
<li>import com.whyun.util.db.DataSourceUtil;  </li>
<li></li>
<li>public class MutilThreadTest {  </li>
<li>public static void test(int dbType, int times)  </li>
<li>throws Exception {   </li>
<li>int numOfThreads =Runtime.getRuntime().availableProcessors()/*2;  </li>
<li>ExecutorService executor = Executors.newFixedThreadPool(numOfThreads);    </li>
<li>final TableOperator test = new TableOperator();  </li>
<li>//        int dbType = DataSourceUtil.DRUID_MYSQL_SOURCE;  </li>
<li>//        dbType = DataSourceUtil.DBCP_SOURCE;  </li>
<li>test.setDataSource(DataSourceUtil.getDataSource(dbType));  </li>
<li></li>
<li>boolean createResult = false;  </li>
<li>try {  </li>
<li>test.createTable();  </li>
<li>createResult = true;  </li>
<li>} catch (SQLException e) {  </li>
<li>e.printStackTrace();  </li>
<li>}  </li>
<li>if (createResult) {  </li>
<li>List<Future<Long>&gt; results = new ArrayList<Future<Long>&gt;();     </li>
<li>for (int i = 0; i &lt; times; i++) {    </li>
<li>results.add(executor.submit(new Callable<Long>() {    </li>
<li>@Override    </li>
<li>public Long call() throws Exception {    </li>
<li>long begin = System.currentTimeMillis();  </li>
<li>try {  </li>
<li>test.insert();  </li>
<li>//insertResult = true;  </li>
<li>} catch (Exception e) {  </li>
<li>e.printStackTrace();  </li>
<li>}                             </li>
<li>long end = System.currentTimeMillis();    </li>
<li>return end - begin;    </li>
<li>}    </li>
<li>}));    </li>
<li>}    </li>
<li>executor.shutdown();    </li>
<li>while(!executor.awaitTermination(Long.MAX_VALUE, TimeUnit.DAYS));    </li>
<li></li>
<li>long sum = 0;    </li>
<li>for (Future<Long> result : results) {    </li>
<li>sum += result.get();    </li>
<li>}    </li>
<li></li>
<li></li>
<li>System.out.println(&quot;---------------db type &quot;+dbType+&quot;------------------&quot;);    </li>
<li>System.out.println(&quot;number of threads :&quot; + numOfThreads + &quot; times:&quot; + times);    </li>
<li>System.out.println(&quot;running time: &quot; + sum + &quot;ms&quot;);    </li>
<li>System.out.println(&quot;TPS: &quot; + (double)(100000 /* 1000) / (double)(sum));    </li>
<li>System.out.println();    </li>
<li>try {  </li>
<li>test.tearDown();  </li>
<li>//dropResult = true;  </li>
<li>} catch (Exception e) {  </li>
<li>e.printStackTrace();  </li>
<li>}  </li>
<li>} else {  </li>
<li>System.out.println(&quot;初始化数据库失败&quot;);  </li>
<li>}  </li>
<li></li>
<li>}    </li>
<li></li>
<li>public static void main (String argc[])  </li>
<li>throws Exception {  </li>
<li>test(DataSourceUtil.DBCP_SOURCE,50);  </li>
<li>test(DataSourceUtil.DRUID_MYSQL_SOURCE,50);  </li>
<li></li>
<li>}  </li>
<li>}  </li>
</ol>
<p><strong>代码片段2.4 连接池多线程测试程序</strong></p>
<hr>
<h2 id="-3-"><a href=""></a><strong>3 监控</strong></h2>
<h3 id="-3-1-web-"><a href=""></a><strong>3.1 web监控</strong></h3>
<p>druid提供了sql语句查询时间等信息的监控功能。为了让数据库查询一直运行，下面特地写了一个ajax进行轮询。同时，还要保证在web.xml中配置如下信息</p>
<p><strong>[html]</strong> <a href="http://blog.csdn.net/yunnysunny/article/details/8657095#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/yunnysunny/article/details/8657095#" title="copy" target="_blank">copy</a></p>
<ol>
<li><servlet>  </li>
<li><servlet-name>DruidStatView</servlet-name>  </li>
<li><servlet-class>com.alibaba.druid.support.http.StatViewServlet</servlet-class>  </li>
<li></servlet>  </li>
<li><servlet-mapping>  </li>
<li><servlet-name>DruidStatView</servlet-name>  </li>
<li><url-pattern>/druid//*</url-pattern>  </li>
<li></servlet-mapping><br><strong>配置文件3.1 在web.xml中添加druid监控</strong></li>
</ol>
<p><em>**</em>同时将ajax代码提供如下</p>
<p><strong>[javascript]</strong> <a href="http://blog.csdn.net/yunnysunny/article/details/8657095#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/yunnysunny/article/details/8657095#" title="copy" target="_blank">copy</a></p>
<ol>
<li>function showTime() {  </li>
<li>var myDate = new Date();  </li>
<li>var timeStr = &#39;&#39;;  </li>
<li>timeStr += myDate.getFullYear()+&#39;-&#39;; //获取完整的年份(4位,1970-????)  </li>
<li>timeStr += myDate.getMonth()+&#39;-&#39;;      //获取当前月份(0-11,0代表1月)  </li>
<li>timeStr += myDate.getDate() + &#39; &#39;;      //获取当前日(1-31)  </li>
<li>timeStr += myDate.getHours()+&#39;:&#39;;      //获取当前小时数(0-23)  </li>
<li>timeStr += myDate.getMinutes()+&#39;:&#39;;    //获取当前分钟数(0-59)  </li>
<li>timeStr += myDate.getSeconds();    //获取当前秒数(0-59)  </li>
<li>return timeStr  </li>
<li>}  </li>
<li>$(document).ready(function() {  </li>
<li>function loadDBTestMessage() {  </li>
<li>$.get(&#39;servlet/MysqlTestServlet&#39;,function(data) {  </li>
<li>if (typeof(data) != &#39;object&#39;) {  </li>
<li>data = eval(&#39;(&#39; + data + &#39;)&#39;);  </li>
<li>}  </li>
<li>var html = &#39;[&#39;+showTime()+&#39;]&#39;;  </li>
<li>html += &#39;创建：&#39; + data[&#39;createResult&#39;];  </li>
<li>html +=  &#39;插入：&#39; + data[&#39;insertResult&#39;];  </li>
<li>html += &#39;销毁:&#39; + data[&#39;dropResult&#39;];  </li>
<li>html +=   </li>
<li>$(&#39;/#message&#39;).html(html);  </li>
<li>});  </li>
<li>}  </li>
<li></li>
<li>setInterval(function() {  </li>
<li>loadDBTestMessage();  </li>
<li>}, 10000);  </li>
<li>});<br><strong>代码片段3.1 ajax轮询</strong></li>
</ol>
<p>这时打开<a href="http://localhost/druid-web/druid/" target="_blank">http://localhost/druid-web/druid/</a> 地址，会看到监控界面，点击其中的sql标签。</p>
<p><img src="" alt=""></p>
<p><strong>图3.1 监控界面查看sql查询时间</strong></p>
<p><strong>注意：在写配置文件1.1时，要保证filter配置项中含有stat属性，否则这个地方看不到sql语句的监控数据。</strong></p>
<p>表格中各项含义如下</p>
<hr>
<p>名称</p>
<p>解释</p>
<p>备注 ExecuteCount</p>
<p>当前sql已执行次数 ExecTime</p>
<p>当前sql已执行时间 ExecMax</p>
<p>当前sql最大执行时间 Txn</p>
<p>当前运行的事务数量 Error</p>
<p>当前sql执行出错的数目 Update</p>
<p>当前sql更新或者删除操作中已经影响的行数 FetchRow</p>
<p>当前sql操作中已经读取的行数 Running</p>
<p>当前sql正在运行的数目 Concurrent</p>
<p>当前sql最大并发执行数  ExecHisto </p>
<p>当前sql做execute操作的时间分布数组</p>
<p>分为0-1,1-10,10-100,100-1000，&gt;1000，5个时间分布区域，单位为ms ExecRsHisto </p>
<p>当前sql做execute操作和resultSet</p>
<p>打开至关闭的时间总和分布数组</p>
<p>同上 FetchRowHisto</p>
<p>当前sql查询时间分布数组</p>
<p>同上 UpdateHisto </p>
<p>当前sql更新、删除时间分布数组</p>
<p>同上表3.1 监控字段含义</p>
<p>老版本的druid的jar包中不支持通过web界面进行远程监控，从0.2.14开始可以通过配置jmx地址来获取远程运行druid的服务器的监控信息。具体配置方法如下：</p>
<p><strong>[html]</strong> <a href="http://blog.csdn.net/yunnysunny/article/details/8657095#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/yunnysunny/article/details/8657095#" title="copy" target="_blank">copy</a></p>
<ol>
<li><servlet>  </li>
<li><servlet-name>DruidStatView</servlet-name>  </li>
<li><servlet-class>com.alibaba.druid.support.http.StatViewServlet</servlet-class>  </li>
<li><init-param>  </li>
<li><param-name>jmxUrl</param-name>  </li>
<li><param-value>service:jmx:rmi:///jndi/rmi://localhost:9004/jmxrmi</param-value>  </li>
<li></init-param>  </li>
<li></servlet>  </li>
<li><servlet-mapping>  </li>
<li><servlet-name>DruidStatView</servlet-name>  </li>
<li><url-pattern>/druid//*</url-pattern>  </li>
<li></servlet-mapping><br>配置文件3.2 远程监控web</li>
</ol>
<p>这里连接的配置参数中多了一个jmxUrl，里面配置一个jmx连接地址。jmx连接中也可以指定用户名、密码，在上面的servlet中添加两个init-param，其param-name分别为jmxUsername和jmxPassword，分别对应连接jmx的用户名和密码。对于jmx在服务器端的配置，可以参考3.2节中的介绍。</p>
<h3 id="-3-2-jconsole-"><a href=""></a><strong>3.2 jconsole监控</strong></h3>
<p>同时druid提供了jconsole监控的功能，因为界面做的不是很好，所以官方中没有对其的相关介绍。如果是纯java程序的话，上面提到的web监控就无法使用了，jconsole的作用就体现出来了。不过我在下面做教程的时候，依然使用的是刚才用的web项目。</p>
<p>首先在catalina.bat（或者catalina.sh）中加入java的启动选项，放置于if &quot;%OS%&quot; == &quot;Windows_NT&quot; setlocal这句之后。</p>
<p>set JAVA_OPTS=%JAVA_OPTS% -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=&quot;9004&quot; -Dcom.sun.management.jmxremote.authenticate=&quot;false&quot; -Dcom.sun.management.jmxremote.ssl=&quot;false&quot;</p>
<p>保存完之后，启动startup.bat(或者startup.sh)来运行tomcat（上面设置java启动项的配置，按理来说在eclipse中也能适用，但是笔者在其下没有试验成功）。然后在远程的某台电脑的命令行中运行如下命令</p>
<p>jconsole -pluginpath E:\kuaipan\workspace6\druid-web\WebRoot\WEB-INF\lib\druid-0.2.11.jar</p>
<p>这里的最后一个参数就是你的druid的jar包的路径。</p>
<p><img src="" alt=""></p>
<p><strong>图3.2 jconsole连接界面</strong></p>
<p>在远程进程的输入框里面输入ip:端口号，然后点击连接（上面的配置中没有指定用户名、密码，所以这里不用填写）。打开的界面如下：</p>
<p><img src="" alt=""></p>
<p><strong>图3.3 jconsole 连接成功界面</strong></p>
<p>可以看到和web监控界面类似的数据了。
来源： <a href="[http://blog.csdn.net/yunnysunny/article/details/8657095](http://blog.csdn.net/yunnysunny/article/details/8657095)">[http://blog.csdn.net/yunnysunny/article/details/8657095](http://blog.csdn.net/yunnysunny/article/details/8657095)</a> </p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/连接池/">连接池</a></li></span></span> | <span class="tags">Tagged <a href="/tags/连接池/" class="label label-primary">连接池</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:43"datetime="2014-03-07 09:54:43"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-连接池--druid教程/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-连接池--druid教程" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-连接池--JavaSocket连接池/">Java Socket连接池</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:43.000Z"> <a href="/2014/02/02/2014-02-02-连接池--JavaSocket连接池/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="java-socket-">Java Socket连接池</h1>
<p>1：SocketAdapter类，此类继承了socket，重载了socket类的close方法，目的是当用户关闭socket的时候，我们并不关闭它只是放在连接池内部。
package com.tarena.socketpool;
import java.net./<em>;
import java.io.IOException;
//</em>/<em>
/</em> <p>socket连接的简单实现</p>
/<em> <p>Description: </p>
/</em> <p>Copyright: Copyright Tarena(c) 2005</p>
/<em> <p>Company: Tarena</p>
/</em> @author chengxing
/<em> @version 1.0
/</em>/
public class ConnectionAdapter extends Socket{
//<em>/</em>
/<em> 连接状态
/</em>/
private boolean status=true;
//<em>/</em>
/<em> 默认的构造函数
/</em>/
public ConnectionAdapter() {
super();
}
public ConnectionAdapter(String host,int port)throws UnknownHostException,IOException{
super(host,port);
}
//<em>/</em>
/<em> 判断此连接是否空闲
/</em> @return boolean 空闲返回ture,否则false
/<em>/
public boolean isFree(){
return status;
}
//</em>/<em>
/</em> 当使用此连接的时候设置状态为false（忙碌）
/<em>/
public void setBusy(){
this.status=false;
}
//</em>/<em>
/</em> 当客户端关闭连接的时候状态设置为true(空闲）
/*/
public void close(){
System.out.println(Close : set the status is free );
status=true;
}
public void destroy(){
//Close socket connection
close();
// System.out.println(Close success );
}
}
第二个类连接管理器。
package com.tarena.socketpool;</p>
<p>import java.lang.reflect./<em>;
import java.util.Properties;
//</em>/<em>
/</em> <p>连接管理器</p>
/<em> <p>Copyright: Copyright Tarena(c) 2005</p>
/</em> <p>Company: Tarena</p>
/<em> @author chengxing
/</em> @version 1.0
/<em>/
public class ConnectionManager {
//测试程序默认的连接池实现类
public static final String PROVIDER_CLASS=com.tarena.socketpool.MyConnectionProvider;
//测试程序的默认ip
public static final String HOST=127.0.0.1;
//测试程序的默认端口号
public static final String PORT=9880;
//</em>/<em>
/</em> 注册钩子程序的静态匿名块
/<em>/
static {
//增加钩子控制资源的释放周期
Runtime runtime = Runtime.getRuntime();
Class c = runtime.getClass();
try {
Method m = c.getMethod(addShutdownHook, new Class[] { Thread.class } );
m.invoke(runtime, new Object[] { new ShutdownThread() });
}
catch (NoSuchMethodException e) {
e.printStackTrace();
// Ignore -- the user might not be running JDK 1.3 or later.
}
catch (Exception e) {
e.printStackTrace();
}
}
//</em>/<em>
/</em> 默认的构造函数
/<em>/
public ConnectionManager() {
}
//</em>/<em>
/</em> 得到并初始化一个连接池
/<em> 连接池的实现类通过系统参数来传递进来，通过命令行-DConnectionProvider=YourImplClass
/</em> 如果没有指定的实现的话，则采用系统默认的实现类
/<em> 通过命令行传入的参数列表如下
/</em> 对方主机名-DHost=192.168.0.200
/<em> 对方端口号　-DPort=9880
/</em> 最小连接数 -DMax_style=&#39;font-size:10px&#39;0
/<em> 最大连结数　-DMin_style=&#39;font-size:14px&#39;0
/</em> 以上的值可以改变，但是参数不能改变，
/<em> 最大连结数和最小连接数可以省略，默认值分别为２０和１０
/</em> @return ConnectionProvider
/*/
public static ConnectionProvider getConnectionProvider()throws Exception{
String provider_class=System.getProperty(ConnectionProvider);
if(provider_class==null)provider_class=PROVIDER_CLASS;</p>
<p>String host=System.getProperty(Host);
if(host==null)host=HOST;</p>
<p>String port=System.getProperty(port);
if(port==null)port=PORT;</p>
<p>String max_size=System.getProperty(Max_size);
String min_size=System.getProperty(Min_size);</p>
<p>Properties pro=new Properties();
pro.setProperty(ConnectionProvider.SERVER_IP,host);
pro.setProperty(ConnectionProvider.SERVER_PORT,port);
if(max_size!=null)pro.setProperty(ConnectionProvider.MAX_SIZE,max_size);
if(min_size!=null)pro.setProperty(ConnectionProvider.MIN_SIZE,min_size);
//通过反射得到实现类
System.out.println(provider_class);
System.out.flush();
Class provider_impl=Class.forName(provider_class);
//由于是单子模式，采用静态方法回调
Method m=provider_impl.getMethod(newInstance,new Class[]{java.util.Properties.class});
ConnectionProvider provider=null;
try{
provider = (ConnectionProvider) m.invoke(provider_impl, new Object[]{pro});
}catch(Exception e){
e.printStackTrace();
}</p>
<p>return provider;
}
//<em>/</em>
/<em>
/</em> <p>一个钩子的线程: 在程序结束的时候调用注销连接池</p>
/<em> <p>Description: </p>
/</em> <p>Copyright: Copyright Tarena(c) 2005</p>
/<em> <p>Company: Tarena</p>
/</em> @author chengxing
/<em> @version 1.0
/</em>/
private static class ShutdownThread extends Thread {
public void run() {
try{
ConnectionProvider provider = ConnectionManager.getConnectionProvider();
if (provider != null) {
provider.destroy();
}
}catch(Exception e){
e.printStackTrace();
}
}
}</p>
<p>}</p>
<p>第三个类，连接池的接口定义
package com.tarena.socketpool;</p>
<p>import java.net./<em>;
import java.util./</em>;
import java.io.IOException;</p>
<p>//<em>/</em>
/<em>
/</em> <p>定义的抽象类，所有的子类必须单子模式去实现，
/<em> 统一方法为public ConnectionProvider newInstance();
/</em> 连接提供器的抽象接口，每一个实现它的子类最好都是JAVABEAN，
/<em> 这样它的方法就可以是被外界控制</p>
/</em> @see JiveBeanInfo
/<em> <p>Copyright: Copyright Tarena(c) 2005</p>
/</em> <p>Company: Tarena</p>
/<em> @author chengxing
/</em> @version 1.0
/*/
public interface
ConnectionProvider {
public static final String SERVER_IP = SERVER_IP_ADDRESS;
public static final String SERVER_PORT = SERVER_IP_PORT;
public static final String MAX_SIZE = MAX_SIZE;
public static final String MIN_SIZE = MIN_SIZE;</p>
<p>//<em>/</em>
/<em>判断连接池内是否有连接
/</em> @return true 有连接返回true,否则返回false
/*/
public boolean isPooled();</p>
<p>//<em>/</em>
/<em> 当此方法被调用的时候提供一个 socket
/</em> @see Socket
/<em> @return Socket a Connection object.
/</em>/
public Socket getConnection() throws java.net.SocketException;</p>
<p>//<em>/</em>
/<em> 连接池初始化
/</em>/
public void init() throws UnknownHostException, IOException;</p>
<p>//<em>/</em>
/<em> 连接池重新启动
/</em>/
public void restart() throws UnknownHostException, IOException;</p>
<p>//<em>/</em>
/<em> 注销连接池
/</em>/
public void destroy();
}
第四个类MyConnectionProvider，自己写的一个连接池的简单实现
package com.tarena.socketpool;</p>
<p>import java.util./<em>;
import java.net./</em>;
import java.net.SocketException;
import java.io.IOException;</p>
<p>//<em>/</em>
/<em>
/</em> <p>这是一个连接管理器的简单实现</p>
/<em> <p>Description: implements the Interface ConnectionProvider</p>
/</em> <p>Copyright: Copyright Tarena(c) 2005</p>
/<em> <p>Company: Tarena</p>
/</em> @author chengxing
/<em> @version 1.0
/</em>/
public class MyConnectionProvider
implements ConnectionProvider {</p>
<p>private Properties pro = null;
private static ConnectionProvider provider = null;
private static Object object_lock = new Object();
private String ip;
private String port;</p>
<p>//<em>/</em>
/<em> 默认的最大连接数
/</em>/
private int max_size = 20;</p>
<p>//<em>/</em>
/<em> 默认的最小连接数
/</em>/
private int min_size = 10;</p>
<p>//<em>/</em>
/<em> Socket connection池数组
/</em>/
private ConnectionAdapter[] socketpool = null;</p>
<p>//<em>/</em>
/<em> 构造对象的时候初始化连接池
/</em> @throws UnknownHostException 未知的主机异常
/<em> @throws IOException
/</em>/
private MyConnectionProvider(Properties pro) throws UnknownHostException,
IOException {
ip = pro.getProperty(SERVER_IP);
port = pro.getProperty(SERVER_PORT);
String max_size_s = pro.getProperty(MAX_SIZE);
String min_size_s = pro.getProperty(MIN_SIZE);
if (max_size_s != null) {
max_size = Integer.parseInt(max_size_s);
}
if (min_size_s != null) {
min_size = Integer.parseInt(min_size_s);
}</p>
<p>init(); //构造对象的时候初始化连接池
}</p>
<p>//<em>/</em>
/<em> 判断是否已经池化
/</em> @return boolean 如果池化返回ture,反之返回false
/*/
public boolean isPooled() {
if (socketpool != null) {
return true;
}
else return false;
}</p>
<p>//<em>/</em>
/<em>返回一个连接
/</em> @return a Connection object.
/*/
public Socket getConnection() {
Socket s = null;
for (int i = 0; i &lt; socketpool.length; i++) {
if (socketpool[i] != null) {
//如果有空闲的连接，返回一个空闲连接，如果没有，继续循环
if (socketpool[i].isFree()) {
s = socketpool[i];
return s;
}
else continue;
}
else { //如果连接为空，证明超过最小连接数，重新生成连接
try {
s = socketpool[i] = new ConnectionAdapter(ip, Integer.parseInt(port));
}
catch (Exception e) {
//never throw
}
}
}
//如果连接仍旧为空的话，则超过了最大连接数
if (s == null) {
try { //生成普通连接，由客户端自行关闭，释放资源，不再由连接池管理
s = new Socket(ip, Integer.parseInt(port));
}
catch (Exception e) { //此异常永远不会抛出
}
}
return s;
}</p>
<p>//<em>/</em>
/<em> 初始化连接池
/</em> @throws UnknownHostException 主机ip找不到
/<em> @throws IOException 此端口号上无server监听
/</em>/
public void init() throws UnknownHostException, IOException {</p>
<p>socketpool = new ConnectionAdapter[max_size];
for (int i = 0; i &lt; min_size; i++) {
socketpool[i] = new ConnectionAdapter(ip, Integer.parseInt(port));
System.out.print( . );
}
System.out.println();
System.out.println(System init success ....);
}</p>
<p>//<em>/</em>
/<em> 重新启动连接池
/</em> @throws UnknownHostException
/<em> @throws IOException
/</em>/
public void restart() throws UnknownHostException, IOException {
destroy();
init();
}</p>
<p>//<em>/</em>
/<em> 注销此连接池
/</em>/
public void destroy() {
for (int i = 0; i &lt; socketpool.length; i++) {
if (socketpool[i] != null) {
ConnectionAdapter adapter = (ConnectionAdapter) socketpool[i];
adapter.destroy();
System.out.print( . );
}
}
System.out.println(\ndestory success ....);
}
//<em>/</em>
/<em> 静态方法，生成此连接池实现的对象
/</em> @param pro Properties 此连接池所需要的所有参数的封装
/<em> @throws UnknownHostException 主机无法找到
/</em> @throws IOException 与服务器无法建立连接
/<em> @return ConnectionProvider 返回父类ConnectionProvider
/</em>/
public static ConnectionProvider newInstance(java.util.Properties pro) throws
UnknownHostException, IOException {
if (provider == null) {
synchronized (object_lock) {
if (provider == null) {
provider = new MyConnectionProvider(pro);
}
}
}
return provider;
}
//<em>/</em>
/<em>设置系统属性 通过封装系统properties对象来封装所需要的不同值
/</em> SERVER_IP，SERVER_PORT，MAX_SIZE,MIN_SIZE等父类定义的不同的参数
/<em> @param pro Properties 传进来的系统属性
/</em>/
public void setProperties(Properties pro) {
this.pro = pro;
}
}</p>
<p>posted on 2008-04-26 16:51 <a href="http://www.cnblogs.com/pony/" target="_blank">马森</a> 阅读(661) <a href="http://www.cnblogs.com/pony/archive/2008/04/26/1172288.html#Post" target="_blank">评论(0)</a> <a href="http://www.cnblogs.com/pony/admin/EditPosts.aspx?postid=1172288" target="_blank">编辑</a> <a href="http://www.cnblogs.com/pony/AddToFavorite.aspx?id=1172288" target="_blank">收藏</a> <a href="http://www.cnblogs.com/pony/archive/2008/04/26/1172288.html#" target="_blank">网摘</a></p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/连接池/">连接池</a></li></span></span> | <span class="tags">Tagged <a href="/tags/连接池/" class="label label-primary">连接池</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:43"datetime="2014-03-07 09:54:43"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-连接池--JavaSocket连接池/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-连接池--JavaSocket连接池" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>





<ul id="pagination" class="pagination pagination-lg">
  <li><a class="extend prev" href="/page/39/">&laquo;</a></li><li><a class="page-number" href="/">1</a></li><li><a class="page-number" href="/page/2/">2</a></li><li><span class="space">&hellip;</span></li><li><a class="page-number" href="/page/37/">37</a></li><li><a class="page-number" href="/page/38/">38</a></li><li><a class="page-number" href="/page/39/">39</a></li><li class="active"><li><span class="page-number current">40</span></li><li><a class="page-number" href="/page/41/">41</a></li><li><a class="page-number" href="/page/42/">42</a></li><li><a class="page-number" href="/page/43/">43</a></li><li><span class="space">&hellip;</span></li></li><li><a class="page-number" href="/page/163/">163</a></li><li><a class="page-number" href="/page/164/">164</a></li><li><a class="extend next" href="/page/41/">&raquo;</a></li>
  <div class="clearfix"></div>
</ul></div><!--wapper-->
       </div><!-- ID main-col END -->
       <aside id="sidebar" class="alignright col-sx-6 col-sm-4 col-md-3 col-lg-3">
<div id="widget_search" class="widget panel panel-primary">
    <form action="//google.com/search" method="get" accept-charset="utf-8">
  <div class="input-group">
    <input class="form-control" id="searchbox" type="search" name="q" results="0" placeholder="search">
    <span class="input-group-btn">
      <button class="btn btn-default" type="submit">Go!</button>
    </span>
    <input type="hidden" name="q" value="site:itsolife.com">
  </div>
</form>
</div>

<div id="widget_category" class="widget panel panel-primary">
  <div class="panel-heading">category</div>  <div data-src='category' class='ajax_widgets'>正在加载...</div>
</div>

<div id="widget_recent_posts" class="widget panel panel-primary">
  <div class="panel-heading">recent posts</div>  <div data-src='recent_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_tagcloud" class="widget panel panel-primary">
  <div class="panel-heading">tagcloud</div>  <div data-src='tagcloud' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_latest_update_posts" class="widget panel panel-primary">
  <div class="panel-heading">最近更新</div>  <div data-src='latest_update_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_recent_comments" class="widget panel panel-primary">
  <div class="panel-heading">recent comments</div>  

<div class="list-group-item ds-recent-comments" data-num-items="6" data-show-avatars="1" data-show-time="1" data-show-title="1" data-show-admin="1" data-excerpt-length="50"></div>



</div>

</aside>
       <div class="clearfix"></div>
     </div><!-- row END -->
  </div>
  <footer id="footer" class="container">
  <div class="panel panel-info">
  <section id='footer_widget'></section>  <div class="panel-footer">
  <div id="site-info">
    <span class='author'>
  
  &copy; 2014 RobinChia
  
    &nbsp;&nbsp;</span>
  
  <span id='analytics-51la'></span><span id='analytics-google'>
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-48559895-1']);
  _gaq.push(['_trackPageview']);
  _js2load.push({src:('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'});
</script></span><span id='analytics-cnzz'>
<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_5774006'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s17.cnzz.com/stat.php%3Fid%3D5774006%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>
</span><span id='analytics-baidu'>
<script>
var _hmt = _hmt || [];
_js2load.push({src:"//hm.baidu.com/hm.js?1442f50724afc42380b51f097c43082c"});
</script>
</span>  </div>
  <div id="copyright">Site powered by <a href='http://zespia.tw/hexo/'><strong>hexo</strong></a>  update time: <em>2014-03-29 22:06:56</em></span></div>
</div>
<div class="clearfix"></div>


  </div>
  </footer>
  
        <script src="http://cdn.bootcss.com/jquery/1.10.2/jquery.min.js"></script>        
        <script src="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/js/bootstrap.min.js"></script>        
                
        <script src="http://cdn.bootcss.com/prettify/r298/prettify.min.js"></script>    <script type="text/javascript">
   var lang=["bsh", "c", "cc", "cpp", "cs", "csh", "cyc", "cv", "htm", "html",
    "java", "js", "m", "mxml", "perl", "pl", "pm", "py", "rb", "sh",
    "xhtml", "xml", "xsl"];
   var pretty_base='';
   $('script').each(function(){
	var c = $(this).attr('src');
	if (!c)
	    return;
	if (c.match(/(\/)?prettify(\.min)?\.js/i))
	{
	    var index = c.lastIndexOf('/');
	    if (index != -1)
		pretty_base = c.substr(0,index + 1);
	    return false;
	}
   })
   $('pre code').each(function(){
	var c = $(this).attr('class')
	if (!c)
	    return;
	c = c.match(/\s?(lang\-\w+)/i);
	if (c && lang.indexOf(c[1]) == -1)
	{
	    lang.push(c[1]);
	    $.getScript(pretty_base + c[1] + '.min.js');
	}
   })

    $(window).load(function(){
       $("pre").addClass("prettyprint");
       prettyPrint();
    })
</script>    
            <script type="text/javascript">
var duoshuoQuery = {short_name:"robinchia"};
_js2load.push({src:'http://static.duoshuo.com/embed.js',charset:'UTF-8'});
</script>
    
            <!--wumii_relatedItems-->
    
        <script src="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js"></script>    <script type="text/javascript">
(function($){
  $('.entry').each(function(i){
    $(this).find('img').each(function(){
      var alt = this.alt;

      if (alt){
        $(this).before('<span class="caption">' + alt + '</span>');
      }

      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox" rel="fancybox' + i + '" />');
    });
  });

  $('.fancybox').fancybox();
})(jQuery);
</script>    
        <script src="http://cdn.bootcss.com/mathjax/2.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>    <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>
    
<script type="text/javascript">
$('.ajax_widgets').each(function(){var src=$(this).attr('data-src');if(src)$(this).load('/widgets/'+src+'.html');});
$.each(_js2load,function(index,obj){loadjs(obj.src,obj.charset)});
</script>

<div id="scroll2top">
<img src="/scroll2top/arrow.png"/>
</div>
<script src="/scroll2top/scroll2top.min.js"></script>
<div id="winterland">
  <canvas></canvas>
</div>
<script src="/js/winterland.min.js"></script>

  </body>
</html>
