
<!DOCTYPE HTML>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>The 46 Page | It so life</title>
<meta name="author" content="RobinChia">

<meta name="description" content="It so life">


<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<meta property="og:site_name" content="It so life"/>

<!--[if IE]><style>.testIE.IE{display:inline;}</style><![endif]-->
<!--[if lte IE 7]><link rel="stylesheet" href="/css/ie7.css" type="text/css"><![endif]-->
<!--[if (lt IE 9)&(gt IE 7)]><style>.testIE.IE8{display:inline;}</style><![endif]-->
<!--[if gt IE 8]><style>.testIE.IE9{display:inline;}</style><![endif]-->

<link href="/favicon.png" rel="icon">
<link rel="alternate" href="/atom.xml" title="It so life Feed" type="application/atom+xml">

<link rel="stylesheet" href="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/css/bootstrap.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/font-awesome/4.0.3/css/font-awesome.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/prettify/r298/prettify.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" type="text/css">
<link rel="stylesheet" href="/css/style.css" type="text/css">
<!--[if lt IE 9]>
   <style>article,aside,dialog,footer,header,section,footer,nav,figure,menu{display:block}</style>
   <script src="http://cdn.staticfile.org/html5shiv/r29/html5.min.js"></script>
   <script src="http://cdn.staticfile.org/respond.js/1.4.2/respond.min.js"></script>
<link href="http://cdn.staticfile.org/respond.js/1.4.2/respond-proxy.html" id="respond-proxy" rel="respond-proxy" />
<link href="/js/respond.proxy.gif" id="respond-redirect" rel="respond-redirect" />
<script src="/js/respond.proxy.js"></script>
   <script src="http://cdn.bootcss.com/selectivizr/1.0.2/selectivizr-min.js"></script>
<![endif]-->
<script type="text/javascript">
function loadjs(c,d){var a=document.createElement("script");a.async=!0;a.type="text/javascript";a.src=c;a.charset=d||"gbk";(document.getElementsByTagName("HEAD")[0]||document.getElementsByTagName("BODY")[0]).appendChild(a)};
var _protocol = (("https:" == document.location.protocol) ? " https://" : " http://");
var _js2load = [];
</script>

</head>
<body>
      <header id="header" class="container"><nav id="main-nav" class="navbar navbar-default navbar-fixed-top " role="navigation">
  <div class="container">
    <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
      <span class="sr-only">Toggle navigation</span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="/">It so life</a>
    </div>
    <div  class="collapse navbar-collapse">
      <ul  class="nav navbar-nav">
  
        <li><a href="/" title="Home">Home</a></li>      
        <li><a href="/about/" title="About">About</a></li>      
        <li><a href="/archives/" title="Archives">Archives</a></li>      
      <li class='dropdown'>
        <a class='dropdown-toggle' data-toggle='dropdown' href='#'>website<b class='caret'></b></a>
        <ul class='dropdown-menu pure-menu-selected'>
    
          <li><a href="//groups.google.com/forum/#!forum/pongba" title="TopLanguage">TopLanguage</a></li>    
          <li><a href="//itpub.net/" title="ITPub">ITPub</a></li>    
          <li><a href="//blog.jobbole.com/" title="Bole">Bole</a></li>    
          <li><a href="//nosql-database.org/" title="nosql">nosql</a></li>    
          <li><a href="//gitimmersion.googol.im/" title="Git">Git</a></li>    
        </ul>
      </li>
    
      </ul>
      <ul class="nav navbar-nav navbar-right">
      
        <li><a href="/atom.xml">RSS</a></li>
      
      
        <li><a href="https://twitter.com/robinchia">twitter</a></li>
      
      
      
      
        <li><a href="https://github.com/robinchia">github</a></li>
      
      </ul>
    </div>
  </div>
</nav>
<div class="clearfix"></div>
</header>
  <div id='content' class="container">
     <div class="page-header-wrapper">
      <!--[if lt IE 9]><div class="alert alert-warning alert-dismissable"><button type="button" class="close" data-dismiss="alert" aria-hidden="true">&times;</button><strong>提示:</strong>您的浏览器版本太低了,建议升级到 <strong><a href="http://windows.microsoft.com/zh-cn/internet-explorer/download-ie" title="IE9">IE9</a></strong> 以上,本站使用<a href="https://www.google.com/intl/zh-CN/chrome/">Chrome浏览器</a>可以获得最好的显示效果.</div><![endif]-->
      <div class="page-header"><h1 align="center"><big>It so life</big> </h1>
        <h5 align="center"><big>love as life</big></h5>
      </div>
     </div>
     <div class="row">
       <div id="main-col" class="alignleft col-sx-12 col-sm-8 col-md-9 col-lg-9">
      <section id='header_widget'></section>
          <div id="wrapper"><article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--请别再拿“StringsnewString-xyz-创建了多少个String实例”来/">请别再拿“String s = new String(</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:42.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--请别再拿“StringsnewString-xyz-创建了多少个String实例”来/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-string-s-new-string-xyz-string-">请别再拿“String s = new String(&quot;xyz&quot;);创建了多少个String实例”来面试了吧</h1>
<p>这帖是用来回复<a href="http://hllvm.group.iteye.com/" target="_blank">高级语言虚拟机</a>圈子里的一个问题，<a href="http://hllvm.group.iteye.com/group/topic/21761" target="_blank">一道Java笔试题</a>的。
本来因为见得太多已经吐槽无力，但这次实在忍不住了就又爆发了一把。写得太长干脆单独开了一帖。
顺带广告：对JVM感兴趣的同学们同志们请多多支持<a href="http://hllvm.group.iteye.com/" target="_blank">高级语言虚拟机</a>圈子 <img src="" alt=""></p>
<h1 id="-">以下是回复内容。文中的“楼主”是针对原问题帖而言。</h1>
<p>楼主是看各种宝典了么……以后我面试人的时候就要专找宝典答案是错的来问，方便筛人orz
楼主要注意了：这题或类似的题虽然经常见，但使用这个描述方式实际上没有任何意义：
引用</p>
<p>问题：</p>
<p>Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>String s = new String(&quot;xyz&quot;);<br>String s = new String(&quot;xyz&quot;);创建了几个String Object？
这个问题自身就没有合理的答案，楼主所引用的“标准答案”自然也就不准确了：
引用</li>
</ol>
<p>答案：两个(一个是“xyz”,一个是指向“xyz”的引用对象s)
（好吧这个答案的吐槽点很多……大家慢慢来）
这问题的毛病是什么呢？它并没有定义“创建了”的意义。
什么叫“创建了”？什么时候创建了什么？
而且这段Java代码片段实际运行的时候真的会“创建两个String实例”么？
如果这道是面试题，那么可以当面让面试官澄清“创建了”的定义，然后再对应的回答。这种时候面试官多半会让被面试者自己解释，那就好办了，好好晒给面试官看。</p>
<h1 id="-">如果是笔试题就没有提问要求澄清的机会了。不过会出这种题目的地方水平多半也不怎么样。说不定出题的人就是从各种宝典上把题抄来的，那就按照宝典把那不大对劲的答案写上去就能混过去了<img src="" alt=""></h1>
<p>先换成另一个问题来问：
引用</p>
<p>问题：</p>
<p>Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>String s = new String(&quot;xyz&quot;);<br>String s = new String(&quot;xyz&quot;);在运行时涉及几个String实例？
一种合理的解答是：
引用</li>
</ol>
<p>答案：两个，一个是字符串字面量&quot;xyz&quot;所对应的、驻留（intern）在一个全局共享的字符串常量池中的实例，另一个是通过new String(String)创建并初始化的、内容与&quot;xyz&quot;相同的实例
这是根据Java语言规范相关规定可以给出的合理答案。考虑到Java语言规范中明确指出了：
The Java Language Specification, Third Edition 写道</p>
<p>The Java programming language is normally compiled to the bytecoded instruction set and binary format defined in <em>The Java Virtual Machine Specification, Second Edition</em> (Addison-Wesley, 1999).
也就是规定了Java语言一般是编译为Java虚拟机规范所定义的Class文件，但并没有规定“一定”（must），留有不使用JVM来实现Java语言的余地。
考虑上Java虚拟机规范，确实在这段代码里涉及的常量种类为<a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html#29297" target="_blank">CONSTANT_String_info</a>的字符串常量也只有&quot;xyz&quot;一个。CONSTANT_String_info是用来表示Java语言中String类型的常量表达式的值（包括字符串字面量）用的常量种类，只在这个层面上考虑的话，这个解答也没问题。
所以这种解答可以认为是合理的。
值得注意的是问题中“在运行时”既包括类加载阶段，也包括这个代码片段自身执行的时候。下文会再讨论这个细节与楼主原本给出的问题的关系。
碰到这种问题首先应该想到去查阅相关的规范，这里具体是<a href="http://java.sun.com/docs/books/jls/" target="_blank">Java语言规范</a>与<a href="http://java.sun.com/docs/books/jvms/" target="_blank">Java虚拟机规范</a>，以及一些相关API的JavaDoc。很多人喜欢把“按道理说”当作口头禅，规范就是用来定义各种“道理”的——“为什么XXX是YYY的意思？”“因为规范里是这样定义的！”——无敌了。
在Java虚拟机规范中相关的定义有下面一些：
The Java Virtual Machine Specification, Second Edition 写道</p>
<p><strong>2.3 Literals</strong>
A literal is the source code representation of a value of a primitive type <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Concepts.doc.html#19511" target="_blank">(§2.4.1)</a>, the String type <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Concepts.doc.html#25486" target="_blank">(§2.4.8)</a>, or the null type <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Concepts.doc.html#22930" target="_blank">(§2.4)</a>. String literals and, more generally, strings that are the values of constant expressions are &quot;interned&quot; so as to share unique instances, using the method String.intern.
The null type has one value, the null reference, denoted by the literal null. The boolean type has two values, denoted by the literals true and false.
<strong>2.4.8 The Class String</strong>
Instances of class String represent sequences of Unicode characters <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Concepts.doc.html#25310" target="_blank">(§2.1)</a>. A String object has a constant, unchanging value. String literals <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Concepts.doc.html#20359" target="_blank">(§2.3)</a> are references to instances of class String.
<strong>2.17.6 Creation of New Class Instances</strong>
A new class instance is explicitly created when one of the following situations occurs:</p>
<ul>
<li>Evaluation of a class instance creation expression creates a new instance of the class whose name appears in the expression.</li>
<li><p>Invocation of the newInstance method of class Class creates a new instance of the class represented by the Class object for which the method was invoked.
A new class instance may be implicitly created in the following situations:</p>
</li>
<li><p>Loading of a class or interface that contains a String literal may create a new String object <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Concepts.doc.html#25486" target="_blank">(§2.4.8)</a> to represent that literal. This may not occur if the a String object has already been created to represent a previous occurrence of that literal, or if the String.intern method has been invoked on a String object representing the same string as the literal.</p>
</li>
<li>Execution of a string concatenation operator that is not part of a constant expression sometimes creates a new String object to represent the result. String concatenation operators may also create temporary wrapper objects for a value of a primitive type <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Concepts.doc.html#19511" target="_blank">(§2.4.1)</a>.
Each of these situations identifies a particular constructor to be called with specified arguments (possibly none) as part of the class instance creation process.
<strong>5.1 The Runtime Constant Pool</strong>
...
● A string literal <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Concepts.doc.html#20359" target="_blank">(§2.3)</a> is derived from a CONSTANT_String_info structure <a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html#29297" target="_blank">(§4.4.3)</a> in the binary representation of a class or interface. The CONSTANT_String_info structure gives the sequence of Unicode characters constituting the string literal.
● The Java programming language requires that identical string literals (that is, literals that contain the same sequence of characters) must refer to the same instance of class String. In addition, if the method String.intern is called on any string, the result is a reference to the same class instance that would be returned if that string appeared as a literal. Thus,
Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></li>
</ul>
<ol>
<li>(&quot;a&quot; + &quot;b&quot; + &quot;c&quot;).intern() == &quot;abc&quot;  </li>
</ol>
<p>(&quot;a&quot; + &quot;b&quot; + &quot;c&quot;).intern() == &quot;abc&quot;
must have the value true.
● To derive a string literal, the Java virtual machine examines the sequence of characters given by the CONSTANT_String_info structure.
  ○ If the method String.intern has previously been called on an instance of class String containing a sequence of Unicode characters identical to that given by the CONSTANT_String_info structure, then the result of string literal derivation is a reference to that same instance of class String.
  ○ Otherwise, a new instance of class String is created containing the sequence of Unicode characters given by the CONSTANT_String_info structure; that class instance is the result of string literal derivation. Finally, the intern method of the new String instance is invoked.
...
The remaining structures in the constant_pool table of the binary representation of a class or interface, the CONSTANT_NameAndType_info <a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html#1327" target="_blank">(§4.4.6)</a> and CONSTANT_Utf8_info <a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html#7963" target="_blank">(§4.4.7)</a> structures are only used indirectly when deriving symbolic references to classes, interfaces, methods, and fields, and when deriving string literals.
把Sun的JDK看作参考实现（reference implementation, RI），其中<a href="http://download.oracle.com/javase/6/docs/api/java/lang/String.html#intern(" target="_blank">String.intern()的JavaDoc</a>)为：
JavaDoc 写道</p>
<p>public String intern()
    Returns a canonical representation for the string object.
    A pool of strings, initially empty, is maintained privately by the class String.
    When the intern method is invoked, if the pool already contains a string equal to this String object as determined by the equals(Object) method, then the string from the pool is returned. Otherwise, this String object is added to the pool and a reference to this String object is returned.
    It follows that for any two strings s and t, s.intern() == t.intern() is true if and only if s.equals(t) is true.
    All literal strings and string-valued constant expressions are interned. String literals are defined in §3.10.5 of the Java Language Specification
    <strong>Returns:</strong></p>
<pre><code>    a string that has the same contents as this string, but is guaranteed to be from a pool of unique strings.
</code></pre><p>===============================================================
再换一个问题来问：
引用</p>
<p>问题：</p>
<p>Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>String s = new String(&quot;xyz&quot;);<br>String s = new String(&quot;xyz&quot;); 涉及用户声明的几个String类型的变量？
答案也很简单：
引用</li>
</ol>
<p>答案：一个，就是String s。
把问题换成下面这个版本，答案也一样：
引用</p>
<p>问题：</p>
<p>Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li><p>String s = null;<br>String s = null; 涉及用户声明的几个String类型的变量？
Java里变量就是变量，引用类型的变量只是对某个对象实例或者null的引用，不是实例本身。声明变量的个数跟创建实例的个数没有必然关系，像是说：
Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>String s1 = &quot;a&quot;;  </p>
</li>
<li>String s2 = s1.concat(&quot;&quot;);  </li>
<li>String s3 = null;  </li>
<li>new String(s1);  </li>
</ol>
<p>String s1 = &quot;a&quot;;</p>
<p>String s2 = s1.concat(&quot;&quot;);
String s3 = null;</p>
<p>new String(s1);
这段代码会涉及3个String类型的变量，
1、s1，指向下面String实例的1
2、s2，指向与s1相同
3、s3，值为null，不指向任何实例
以及3个String实例，
1、&quot;a&quot;字面量对应的驻留的字符串常量的String实例
2、&quot;&quot;字面量对应的驻留的字符串常量的String实例
（<a href="http://download.oracle.com/javase/6/docs/api/java/lang/String.html#concat(java.lang.String" target="_blank">String.concat()</a>)是个有趣的方法，当发现传入的参数是空字符串时会返回this，所以这里不会额外创建新的String实例）</p>
<h1 id="3-new-string-string-string-">3、通过new String(String)创建的新String实例；没有任何变量指向它。</h1>
<p>回到楼主开头引用的问题与“标准答案”
引用</p>
<p>问题：</p>
<p>Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li><p>String s = new String(&quot;xyz&quot;);<br>String s = new String(&quot;xyz&quot;);创建了几个String Object？
答案：两个(一个是“xyz”,一个是指向“xyz”的引用对象s)
用归谬法论证。假定问题问的是“在执行这段代码片段时创建了几个String实例”。如果“标准答案”是正确的，那么下面的代码片段在执行时就应该创建4个String实例了：
Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>String s1 = new String(&quot;xyz&quot;);  </p>
</li>
<li>String s2 = new String(&quot;xyz&quot;);  </li>
</ol>
<p>String s1 = new String(&quot;xyz&quot;);</p>
<p>String s2 = new String(&quot;xyz&quot;);
马上就会有人跳出来说上下两个&quot;xyz&quot;字面量都是引用了同一个String对象，所以不应该是创建了4个对象。
那么应该是多少个？
运行时的类加载过程与实际执行某个代码片段，两者必须分开讨论才有那么点意义。
为了执行问题中的代码片段，其所在的类必然要先被加载，而且同一个类最多只会被加载一次（要注意对JVM来说“同一个类”并不是类的全限定名相同就足够了，而是&lt;类全限定名, 定义类加载器&gt;一对都相同才行）。
根据上文引用的规范的内容，符合规范的JVM实现应该在类加载的过程中创建并驻留一个String实例作为常量来对应&quot;xyz&quot;字面量；具体是在类加载的resolve阶段进行的。这个常量是全局共享的，只在先前尚未有内容相同的字符串驻留过的前提下才需要创建新的String实例。
等到真正执行原问题中的代码片段时，JVM需要执行的字节码类似这样：
Java bytecode代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>0: new  /#2; //class java/lang/String  </li>
<li>3: dup  </li>
<li>4: ldc  /#3; //String xyz  </li>
<li>6: invokespecial    /#4; //Method java/lang/String.&quot;<init>&quot;:(Ljava/lang/String;)V  </li>
<li>9: astore_1  </li>
</ol>
<p>0: new    /#2; //class java/lang/String</p>
<p>3: dup
4: ldc    /#3; //String xyz</p>
<p>6: invokespecial    /#4; //Method java/lang/String.&quot;<init>&quot;:(Ljava/lang/String;)V
9: astore_1
这之中出现过多少次new java/lang/String就是创建了多少个String对象。也就是说原问题中的代码在每执行一次只会新创建一个String实例。
这里，ldc指令只是把先前在类加载过程中已经创建好的一个String对象（&quot;xyz&quot;）的一个引用压到操作数栈顶而已，并不新创建String对象。
所以刚才用于归谬的代码片段：
Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>String s1 = new String(&quot;xyz&quot;);  </li>
<li>String s2 = new String(&quot;xyz&quot;);  </li>
</ol>
<p>String s1 = new String(&quot;xyz&quot;);</p>
<p>String s2 = new String(&quot;xyz&quot;);</p>
<h2 id="-2-string-">每执行一次只会新创建2个String实例。</h2>
<p>为了避免一些同学犯糊涂，再强调一次：
在Java语言里，“new”表达式是负责创建实例的，其中会调用构造器去对实例做初始化；构造器自身的返回值类型是void，并不是“构造器返回了新创建的对象的引用”，而是new表达式的值是新创建的对象的引用。
对应的，在JVM里，“new”字节码指令只负责把实例创建出来（包括分配空间、设定类型、所有字段设置默认值等工作），并且把指向新创建对象的引用压到操作数栈顶。此时该引用还不能直接使用，处于未初始化状态（uninitialized）；如果某方法a含有代码试图通过未初始化状态的引用来调用任何实例方法，那么方法a会通不过JVM的字节码校验，从而被JVM拒绝执行。
能对未初始化状态的引用做的唯一一种事情就是通过它调用实例构造器，在Class文件层面表现为特殊初始化方法“<init>”。实际调用的指令是invokespecial，而在实际调用前要把需要的参数按顺序压到操作数栈上。在上面的字节码例子中，压参数的指令包括dup和ldc两条，分别把隐藏参数（新创建的实例的引用，对于实例构造器来说就是“this”）与显式声明的第一个实际参数（&quot;xyz&quot;常量的引用）压到操作数栈上。
在构造器返回之后，新创建的实例的引用就可以正常使用了。</p>
<h1 id="-http-rednaxelafx-iteye-com-blog-652719-">关于构造器的讨论，可以参考我之前的一帖，<a href="http://rednaxelafx.iteye.com/blog/652719" target="_blank">实例构造器是不是静态方法？</a></h1>
<p>以上讨论都只是针对规范所定义的Java语言与Java虚拟机而言。概念上是如此，但实际的JVM实现可以做得更优化，原问题中的代码片段有可能在实际执行的时候一个String实例也不会完整创建（没有分配空间）。
例如说，在x86、Windows Vista SP2、Sun JDK 6 update 14的fastdebug版上跑下面的测试代码：
Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>public class C2EscapeAnalysisDemo {  </li>
<li>private static void warmUp() {  </li>
<li>IFoo[] array = new IFoo[] {  </li>
<li>new FooA(), new FooB(), new FooC(), new FooD()  </li>
<li>};  </li>
<li>for (int i = 0; i &lt; 1000000; i++) {  </li>
<li>array[i % array.length].foo(); // megamorphic callsite to prevent inlining  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>public static void main(String[] args) {  </li>
<li>while (true) {  </li>
<li>warmUp();  </li>
<li>}  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>interface IFoo {  </li>
<li>void foo();  </li>
<li>}  </li>
<li></li>
<li>class FooA implements IFoo {  </li>
<li>public void foo() {  </li>
<li>String s1 = new String(&quot;xyz&quot;);  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>class FooB implements IFoo {  </li>
<li>public void foo() {  </li>
<li>String s1 = new String(&quot;xyz&quot;);  </li>
<li>String s2 = new String(&quot;xyz&quot;);  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>class FooC implements IFoo {  </li>
<li>public void foo() {  </li>
<li>String s1 = new String(&quot;xyz&quot;);  </li>
<li>String s2 = new String(&quot;xyz&quot;);  </li>
<li>String s3 = new String(&quot;xyz&quot;);  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>class FooD implements IFoo {  </li>
<li>public void foo() {  </li>
<li>String s1 = new String(&quot;xyz&quot;);  </li>
<li>String s2 = new String(&quot;xyz&quot;);  </li>
<li>String s3 = new String(&quot;xyz&quot;);  </li>
<li>String s4 = new String(&quot;xyz&quot;);  </li>
<li>}  </li>
<li>}  </li>
</ol>
<p>public class C2EscapeAnalysisDemo {</p>
<p>  private static void warmUp() {
    IFoo[] array = new IFoo[] {</p>
<pre><code>  new FooA(), new FooB(), new FooC(), new FooD()
};

for (int i = 0; i &lt; 1000000; i++) {
  array[i % array.length].foo(); // megamorphic callsite to prevent inlining

}
</code></pre><p>  }</p>
<p>  public static void main(String[] args) {</p>
<pre><code>while (true) {
  warmUp();

}
</code></pre><p>  }</p>
<p>}</p>
<p>interface IFoo {
  void foo();</p>
<p>}</p>
<p>class FooA implements IFoo {
  public void foo() {</p>
<pre><code>String s1 = new String(&quot;xyz&quot;);
</code></pre><p>  }</p>
<p>}</p>
<p>class FooB implements IFoo {
  public void foo() {</p>
<pre><code>String s1 = new String(&quot;xyz&quot;);
String s2 = new String(&quot;xyz&quot;);
</code></pre><p>  }
}</p>
<p>class FooC implements IFoo {</p>
<p>  public void foo() {
    String s1 = new String(&quot;xyz&quot;);</p>
<pre><code>String s2 = new String(&quot;xyz&quot;);
String s3 = new String(&quot;xyz&quot;);
</code></pre><p>  }
}</p>
<p>class FooD implements IFoo {</p>
<p>  public void foo() {
    String s1 = new String(&quot;xyz&quot;);</p>
<pre><code>String s2 = new String(&quot;xyz&quot;);
String s3 = new String(&quot;xyz&quot;);

String s4 = new String(&quot;xyz&quot;);
</code></pre><p>  }</p>
<p>}
照常用javac用默认参数编译，然后先用server模式的默认配置来跑，顺带打出GC和JIT编译日志来看
Command prompt代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>java -server -verbose:gc -XX:+PrintCompilation C2EscapeAnalysisDemo  </li>
</ol>
<p>java -server -verbose:gc -XX:+PrintCompilation C2EscapeAnalysisDemo
看到的日志的开头一段如下：
Hotspot log代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>1       java.lang.String::charAt (33 bytes)  </li>
<li>2       java.lang.Object::<init> (1 bytes)  </li>
<li>3       java.lang.String::<init> (61 bytes)  </li>
<li>1%      C2EscapeAnalysisDemo::warmUp @ 47 (71 bytes)  </li>
<li>4       FooA::foo (11 bytes)  </li>
<li>5       FooB::foo (21 bytes)  </li>
<li>6       FooC::foo (31 bytes)  </li>
<li>7       FooD::foo (42 bytes)  </li>
<li>[GC 3072K-&gt;168K(32768K), 0.0058325 secs]  </li>
<li>[GC 3240K-&gt;160K(32768K), 0.0104623 secs]  </li>
<li>[GC 3232K-&gt;160K(32768K), 0.0027323 secs]  </li>
<li>[GC 3232K-&gt;160K(35840K), 0.0026220 secs]  </li>
<li>[GC 6304K-&gt;160K(35840K), 0.0173733 secs]  </li>
<li>[GC 6304K-&gt;144K(41664K), 0.0059720 secs]  </li>
<li>[GC 12432K-&gt;144K(41664K), 0.0353320 secs]  </li>
<li>[GC 12432K-&gt;144K(54016K), 0.0139333 secs]  </li>
<li>8       C2EscapeAnalysisDemo::warmUp (71 bytes)  </li>
<li>[GC 24720K-&gt;160K(54016K), 0.0697970 secs]  </li>
<li>[GC 24736K-&gt;160K(68800K), 0.0261921 secs]  </li>
<li>[GC 39520K-&gt;160K(68800K), 0.0958433 secs]  </li>
<li>[GC 39520K-&gt;160K(87168K), 0.0433377 secs]  </li>
<li>[GC 57888K-&gt;160K(87168K), 0.0542482 secs]  </li>
<li>[GC 57888K-&gt;148K(87168K), 0.0533140 secs]  </li>
<li>[GC 57876K-&gt;164K(84288K), 0.0533537 secs]  </li>
<li>[GC 55204K-&gt;164K(81728K), 0.0596820 secs]  </li>
<li>[GC 52644K-&gt;164K(79488K), 0.0515090 secs]  </li>
<li>[GC 50212K-&gt;164K(76992K), 0.0491227 secs]  </li>
<li>[GC 47908K-&gt;164K(74944K), 0.0450666 secs]  </li>
<li>[GC 45668K-&gt;164K(72640K), 0.0467671 secs]  </li>
<li>[GC 43556K-&gt;152K(70784K), 0.0420757 secs]  </li>
<li>[GC 41560K-&gt;168K(68736K), 0.0391296 secs]  </li>
<li>[GC 39656K-&gt;168K(67072K), 0.0397539 secs]  </li>
<li><p>[GC 37864K-&gt;188K(65216K), 0.0360861 secs]  </p>
<p>1       java.lang.String::charAt (33 bytes)</p>
<p>2       java.lang.Object::<init> (1 bytes)
3       java.lang.String::<init> (61 bytes)</p>
<p>1%      C2EscapeAnalysisDemo::warmUp @ 47 (71 bytes)
4       FooA::foo (11 bytes)</p>
<p>5       FooB::foo (21 bytes)
6       FooC::foo (31 bytes)</p>
<p>7       FooD::foo (42 bytes)
[GC 3072K-&gt;168K(32768K), 0.0058325 secs]</p>
</li>
</ol>
<p>[GC 3240K-&gt;160K(32768K), 0.0104623 secs]
[GC 3232K-&gt;160K(32768K), 0.0027323 secs]</p>
<p>[GC 3232K-&gt;160K(35840K), 0.0026220 secs]
[GC 6304K-&gt;160K(35840K), 0.0173733 secs]</p>
<p>[GC 6304K-&gt;144K(41664K), 0.0059720 secs]
[GC 12432K-&gt;144K(41664K), 0.0353320 secs]</p>
<p>[GC 12432K-&gt;144K(54016K), 0.0139333 secs]
  8       C2EscapeAnalysisDemo::warmUp (71 bytes)</p>
<p>[GC 24720K-&gt;160K(54016K), 0.0697970 secs]
[GC 24736K-&gt;160K(68800K), 0.0261921 secs]</p>
<p>[GC 39520K-&gt;160K(68800K), 0.0958433 secs]
[GC 39520K-&gt;160K(87168K), 0.0433377 secs]</p>
<p>[GC 57888K-&gt;160K(87168K), 0.0542482 secs]
[GC 57888K-&gt;148K(87168K), 0.0533140 secs]</p>
<p>[GC 57876K-&gt;164K(84288K), 0.0533537 secs]
[GC 55204K-&gt;164K(81728K), 0.0596820 secs]</p>
<p>[GC 52644K-&gt;164K(79488K), 0.0515090 secs]
[GC 50212K-&gt;164K(76992K), 0.0491227 secs]</p>
<p>[GC 47908K-&gt;164K(74944K), 0.0450666 secs]
[GC 45668K-&gt;164K(72640K), 0.0467671 secs]</p>
<p>[GC 43556K-&gt;152K(70784K), 0.0420757 secs]
[GC 41560K-&gt;168K(68736K), 0.0391296 secs]</p>
<p>[GC 39656K-&gt;168K(67072K), 0.0397539 secs]
[GC 37864K-&gt;188K(65216K), 0.0360861 secs]
上面的日志中，后面的方法名的行是JIT编译的日志，而以<a href="&quot;复制代码&quot;">GC开头的是minor GC的日志。
程序一直跑，GC的日志还会不断的打出来。这是理所当然的对吧？HotSpot的堆就那么大，而测试代码在不断新创建String对象，肯定得不断触发GC的。
用不同的VM启动参数来跑的话，
Command prompt代码 [<img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>java -server -verbose:gc -XX:+PrintCompilation -XX:+DoEscapeAnalysis -XX:+EliminateAllocations C2EscapeAnalysisDemo  </li>
</ol>
<p>java -server -verbose:gc -XX:+PrintCompilation -XX:+DoEscapeAnalysis -XX:+EliminateAllocations C2EscapeAnalysisDemo
还是同样的Java测试程序，同样的Sun JDK 6 update 14，但打开了逃逸分析和空间分配消除功能，再运行，看到的全部日志如下：
Hotspot log代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>1       java.lang.String::charAt (33 bytes)  </li>
<li>2       java.lang.Object::<init> (1 bytes)  </li>
<li>3       java.lang.String::<init> (61 bytes)  </li>
<li>1%      C2EscapeAnalysisDemo::warmUp @ 47 (71 bytes)  </li>
<li>5       FooB::foo (21 bytes)  </li>
<li>4       FooA::foo (11 bytes)  </li>
<li>6       FooC::foo (31 bytes)  </li>
<li>7       FooD::foo (42 bytes)  </li>
<li>[GC 3072K-&gt;176K(32768K), 0.0056527 secs]  </li>
<li><p>8       C2EscapeAnalysisDemo::warmUp (71 bytes)  </p>
<p>1       java.lang.String::charAt (33 bytes)</p>
<p>2       java.lang.Object::<init> (1 bytes)
3       java.lang.String::<init> (61 bytes)</p>
<p>1%      C2EscapeAnalysisDemo::warmUp @ 47 (71 bytes)
5       FooB::foo (21 bytes)</p>
<p>4       FooA::foo (11 bytes)
6       FooC::foo (31 bytes)</p>
<p>7       FooD::foo (42 bytes)
[GC 3072K-&gt;176K(32768K), 0.0056527 secs]</p>
<p>8       C2EscapeAnalysisDemo::warmUp (71 bytes)
继续跑下去也没有再打出GC日志了。难道新创建String对象都不吃内存了么？
实际情况是：经过HotSpot的server模式编译器的优化后，FooA、FooB、FooC、FooD四个版本的foo()实现都不新创建String实例了。这样自然不吃内存，也就不再触发GC了。
经过的分析和优化笼统说有方法内联（method inlining）、逃逸分析（escape analysis）、标量替换（scalar replacement）、无用代码削除（dead-code elimination）之类。
FooA.foo()最短，就以它举例来大致演示一下优化的过程。
它其实就是创建并初始化了一个String对象而已。调用的构造器的源码是：
Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>public String(String original) {  </p>
</li>
<li>int size = original.count;  </li>
<li>char[] originalValue = original.value;  </li>
<li>char[] v;  </li>
<li>if (originalValue.length &gt; size) {  </li>
<li>// The array representing the String is bigger than the new  </li>
<li>// String itself.  Perhaps this constructor is being called  </li>
<li>// in order to trim the baggage, so make a copy of the array.  </li>
<li>int off = original.offset;  </li>
<li>v = Arrays.copyOfRange(originalValue, off, off+size);  </li>
<li>} else {  </li>
<li>// The array representing the String is the same  </li>
<li>// size as the String, so no point in making a copy.  </li>
<li>v = originalValue;  </li>
<li>}  </li>
<li>this.offset = 0;  </li>
<li>this.count = size;  </li>
<li>this.value = v;  </li>
<li>}  </li>
</ol>
<p>public String(String original) {</p>
<pre><code>int size = original.count;
char[] originalValue = original.value;

char[] v;
if (originalValue.length &gt; size) {

   // The array representing the String is bigger than the new
   // String itself.  Perhaps this constructor is being called

   // in order to trim the baggage, so make a copy of the array.
  int off = original.offset;

  v = Arrays.copyOfRange(originalValue, off, off+size);
} else {

   // The array representing the String is the same
   // size as the String, so no point in making a copy.

  v = originalValue;
}

this.offset = 0;
this.count = size;

this.value = v;
</code></pre><p>}
因为参数是&quot;xyz&quot;，可以确定在我们的测试代码里不会走到构造器的if分支里，下面为了演示方便就省略掉那部分代码（实际代码还是存在的，只是没执行而已）
Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>public String(String original) {  </li>
<li>int size = original.count;  </li>
<li>char[] originalValue = original.value;  </li>
<li>char[] v;  </li>
<li>if (originalValue.length &gt; size) {  </li>
<li>// 省略  </li>
<li>} else {  </li>
<li>v = originalValue;  </li>
<li>}  </li>
<li>this.offset = 0;  </li>
<li>this.count = size;  </li>
<li>this.value = v;  </li>
<li>}  </li>
</ol>
<p>public String(String original) {</p>
<pre><code>int size = original.count;
char[] originalValue = original.value;

char[] v;
if (originalValue.length &gt; size) {

   // 省略
} else {

  v = originalValue;
}

this.offset = 0;
this.count = size;

this.value = v;
</code></pre><p>}
那么把构造器内联到FooA.foo()里，
Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>public FooA implements IFoo {  </li>
<li>public void foo() {  </li>
<li>String s = AllocateString(); // 这里虚构一个只分配空间，不调用构造器的函数  </li>
<li>String original = &quot;xyz&quot;;  </li>
<li></li>
<li>// 下面就是内联进来的构造器内容  </li>
<li>int size = original.count;  </li>
<li>char[] originalValue = original.value;  </li>
<li>char[] v;  </li>
<li>if (originalValue.length &gt; size) {  </li>
<li>// 省略  </li>
<li>} else {  </li>
<li>v = originalValue;  </li>
<li>}  </li>
<li></li>
<li>s.offset = 0;  </li>
<li>s.count = size;  </li>
<li>s.value = v;  </li>
<li>}  </li>
<li>}  </li>
</ol>
<p>public FooA implements IFoo {</p>
<p>  public void foo() {
    String s = AllocateString(); // 这里虚构一个只分配空间，不调用构造器的函数</p>
<pre><code>String original = &quot;xyz&quot;;


// 下面就是内联进来的构造器内容
int size = original.count;

char[] originalValue = original.value;
char[] v;

if (originalValue.length &gt; size) {
   // 省略

} else {
  v = originalValue;

}


s.offset = 0;
s.count = size;

s.value = v;
</code></pre><p>  }</p>
<p>}
然后经过逃逸分析与标量替换，
Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>public FooA implements IFoo {  </li>
<li>public void foo() {  </li>
<li>String original = &quot;xyz&quot;;  </li>
<li></li>
<li>// 下面就是内联进来的构造器内容  </li>
<li>int size = original.count;  </li>
<li>char[] originalValue = original.value;  </li>
<li>char[] v;  </li>
<li>if (originalValue.length &gt; size) {  </li>
<li>// 省略  </li>
<li>} else {  </li>
<li>v = originalValue;  </li>
<li>}  </li>
<li></li>
<li>// 原本s的实例变量被标量替换为foo()的局部变量  </li>
<li>int sOffset = 0;  </li>
<li>int sCount = size;  </li>
<li>char[] sValue = v;  </li>
<li>}  </li>
<li>}  </li>
</ol>
<p>public FooA implements IFoo {</p>
<p>  public void foo() {
    String original = &quot;xyz&quot;;</p>
<pre><code>// 下面就是内联进来的构造器内容

int size = original.count;
char[] originalValue = original.value;

char[] v;
if (originalValue.length &gt; size) {

   // 省略
} else {

  v = originalValue;
}


// 原本s的实例变量被标量替换为foo()的局部变量

int sOffset = 0;
int sCount = size;

char[] sValue = v;
</code></pre><p>  }</p>
<p>}
注意，到这里就已经把新创建String在堆上分配空间的代码全部削除了，原本新建的String实例的字段变成了FooA.foo()的局部变量。
最后再经过无用代码削除，把sOffset、sCount和sValue这三个没被读过的局部变量给削除掉，
Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>public FooA implements IFoo {  </li>
<li>public void foo() {  </li>
<li>String original = &quot;xyz&quot;;  </li>
<li></li>
<li>// 下面就是内联进来的构造器内容  </li>
<li>int size = original.count;  </li>
<li>char[] originalValue = original.value;  </li>
<li>char[] v;  </li>
<li>if (originalValue.length &gt; size) {  </li>
<li>// 省略  </li>
<li>} else {  </li>
<li>v = originalValue;  </li>
<li>}  </li>
<li></li>
<li>// 几个局部变量也干掉了  </li>
<li>}  </li>
<li>}  </li>
</ol>
<p>public FooA implements IFoo {</p>
<p>  public void foo() {
    String original = &quot;xyz&quot;;</p>
<pre><code>// 下面就是内联进来的构造器内容

int size = original.count;
char[] originalValue = original.value;

char[] v;
if (originalValue.length &gt; size) {

   // 省略
} else {

  v = originalValue;
}


// 几个局部变量也干掉了
</code></pre><p>  }
}
这就跟FooA.foo()被优化编译后实际执行的代码基本一致了。
实际执行的x86代码如下：
X86 asm代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>0x0247aeec: mov    %eax,-0x4000(%esp) ; 检查栈是否溢出（stack bang），若溢出则这条指令会引发异常  </li>
<li>0x0247aef3: push   %ebp               ; 保存老的栈帧指针  </li>
<li>0x0247aef4: sub    $0x18,%esp         ; 为新栈帧分配空间  </li>
<li>0x0247aefa: mov    $0x1027e9a8,%edi   ; String original //<em> EDI /</em>/ = &quot;xyz&quot;  </li>
<li>0x0247aeff: mov    0x8(%edi),%ecx     ; char[] originalValue //<em> ECX /</em>/ = original.value;  </li>
<li>0x0247af02: mov    0x8(%ecx),%ebx     ; EBX = originalValue.length  </li>
<li>0x0247af05: mov    0x10(%edi),%ebp    ; int size //<em> EBP /</em>/ = original.count;  </li>
<li>0x0247af08: cmp    %ebp,%ebx          ; 比较originalValue.length与size  </li>
<li>0x0247af0a: jg     0x0247af17         ; 如果originalValue.length &gt; size则跳转到0x0247af17  </li>
<li>;   实际不会发生跳转（就是不会执行if分支），所以后面代码省略  </li>
<li>0x0247af0c: add    $0x18,%esp         ; 撤销栈帧分配的空间  </li>
<li>0x0247af0f: pop    %ebp               ; 恢复老的栈帧指针  </li>
<li>0x0247af10: test   %eax,0x310000      ; 方法返回前检查是否需要进入safepoint （{poll_return}）  </li>
<li>0x0247af16: ret                       ; 方法返回  </li>
<li>0x0247af17: ; 以下是if分支和异常处理器的代码，因为实际不会执行，省略  </li>
</ol>
<p>0x0247aeec: mov    %eax,-0x4000(%esp) ; 检查栈是否溢出（stack bang），若溢出则这条指令会引发异常</p>
<p>0x0247aef3: push   %ebp               ; 保存老的栈帧指针
0x0247aef4: sub    $0x18,%esp         ; 为新栈帧分配空间</p>
<p>0x0247aefa: mov    $0x1027e9a8,%edi   ; String original //<em> EDI /</em>/ = &quot;xyz&quot;
0x0247aeff: mov    0x8(%edi),%ecx     ; char[] originalValue //<em> ECX /</em>/ = original.value;</p>
<p>0x0247af02: mov    0x8(%ecx),%ebx     ; EBX = originalValue.length
0x0247af05: mov    0x10(%edi),%ebp    ; int size //<em> EBP /</em>/ = original.count;</p>
<p>0x0247af08: cmp    %ebp,%ebx          ; 比较originalValue.length与size
0x0247af0a: jg     0x0247af17         ; 如果originalValue.length &gt; size则跳转到0x0247af17</p>
<pre><code>                                  ;   实际不会发生跳转（就是不会执行if分支），所以后面代码省略
</code></pre><p>0x0247af0c: add    $0x18,%esp         ; 撤销栈帧分配的空间</p>
<p>0x0247af0f: pop    %ebp               ; 恢复老的栈帧指针
0x0247af10: test   %eax,0x310000      ; 方法返回前检查是否需要进入safepoint （{poll_return}）</p>
<p>0x0247af16: ret                       ; 方法返回
0x0247af17: ; 以下是if分支和异常处理器的代码，因为实际不会执行，省略
看，确实没有新创建String对象了。
另外三个版本的foo()实现也是类似，HotSpot成功的把无用的new String(&quot;xyz&quot;)全部干掉了。
关于逃逸分析的例子，可以参考我以前一篇帖，<a href="http://rednaxelafx.iteye.com/blog/659108" target="_blank">HotSpot 17.0-b12的逃逸分析/标量替换的一个演示</a></p>
<h1 id="-fooa-foo-string-">再回头看看楼主的原问题，问题中的代码片段执行的时候（对应到FooA.foo()被调用的时候）一个String对象也没有新建。于是那“标准答案”在现实中的指导意义又有多少呢？</h1>
<p>另外，楼主还提到了PermGen：
QM42977 写道</p>
<p>&quot;xyz&quot;在perm gen应该还会生成一个对象，因为常量(&quot;xyz&quot;)都会保存在perm gen中
这里也是需要强调一点：永生代（“Perm Gen”）只是Sun JDK的一个实现细节而已，Java语言规范和Java虚拟机规范都没有规定必须有“Permanent Generation”这么一块空间，甚至没规定要用什么GC算法——不用分代式GC算法哪儿来的“永生代”？
HotSpot的PermGen是用来实现Java虚拟机规范中的“<strong>方法区</strong>”（method area）的。如果使用“方法区”这个术语，在讨论概念中的JVM时就安全得多——大家都必须实现出这个表象。
当然如何实现又是另一回事了。Oracle JRockit没有PermGen，IBM J9也没有，事实上有这么一块空间特别管理的反而是少数吧orz
事实上新版HotSpot VM也在计划去除PermGen，转而使用native memory来实现方法区存储元数据。在JDK8的HotSpot VM中已经实现了这点。</p>
<h1 id="-http-rednaxelafx-iteye-com-blog-905273-http-rednaxelafx-iteye-com-blog-905273-">可以参考这帖：<a href="http://rednaxelafx.iteye.com/blog/905273" target="_blank"><a href="http://rednaxelafx.iteye.com/blog/905273">http://rednaxelafx.iteye.com/blog/905273</a></a></h1>
<p>费那么多口舌，最后点题：请别再拿“String s = new String(&quot;xyz&quot;);创建了多少个String实例”来面试了吧，既没意义又不涨面子。
困，睡觉去……<img src="" alt=""></p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/JVM/">JVM</a></li></span></span> | <span class="tags">Tagged <a href="/tags/JVM/" class="label label-primary">JVM</a><a href="/tags/Java&J2EE/" class="label label-success">Java&J2EE</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:42"datetime="2014-03-07 09:54:42"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-JVM--请别再拿“StringsnewString-xyz-创建了多少个String实例”来/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-JVM--请别再拿“StringsnewString-xyz-创建了多少个String实例”来" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--学习JVM的References/">学习JVM的References</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:42.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--学习JVM的References/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-jvm-references">学习JVM的References</h1>
<h1 id="-bluedavy-blog-https-blog-bluedavy-com-"><a href="https://blog.bluedavy.com/" target="_blank">BlueDavy之技术blog</a></h1>
<p>{互联网，OSGi，Java, High Scalability, High Performance,HA}</p>
<ul>
<li><a href="https://blog.bluedavy.com/" target="_blank">Home</a></li>
<li><a href="https://blog.bluedavy.com/?page_id=2" target="_blank">About</a></li>
<li><a href="https://blog.bluedavy.com/?page_id=81" target="_blank">Photos</a></li>
</ul>
<h2 id="-jvm-references-https-blog-bluedavy-com-p-187-jvm-references-"><a href="https://blog.bluedavy.com/?p=187" title="学习JVM的References" target="_blank">学习JVM的References</a></h2>
<p>Nov 16</p>
<p><a href="http://bluedavy.com/" title="Visit bluedavy’s website" target="_blank">bluedavy</a><a href="https://blog.bluedavy.com/?cat=13" title="View all posts in jvm" target="_blank">jvm</a> <a href="https://blog.bluedavy.com/?tag=jvm" target="_blank">jvm</a>, <a href="https://blog.bluedavy.com/?tag=references" target="_blank">references</a> <a href="&quot;Comment on 学习JVM的References&quot;">15 Comments</a>
本blog中列举了我学习JVM的references，会不断的更新，为了避免版权问题，就不在blog上提供references的下载了，感兴趣的同学可自行下载或购买，:)
大多数的论文可从此下载：<a href="http://citeseer.ist.psu.edu/index.jsp" target="_blank"><a href="http://citeseer.ist.psu.edu/index.jsp">http://citeseer.ist.psu.edu/index.jsp</a></a>
同时推荐@rednaxelafx 整理的jvm的参考资料：<a href="http://goo.gl/oXmRQ" target="_blank"><a href="http://goo.gl/oXmRQ">http://goo.gl/oXmRQ</a></a></p>
<p>References
  |— Towards a Renaissance VM
  |— Oracle JRockit The Definitive Guide
  |— JVM Magic
  |— JAVA虚拟机中文第二版
  |— Java Lang Spec 3.0
  |— Inside Out A Modern Virtual Machine Revealed
  |— Hotspot Overview
  |— Azul’s JVM experiences
  |— A Crash Course in Modern Hardware
  |— [ adaptive ]
        |— Understanding Adaptive Runtimes
        |— Adaptive Optimization of Java Real-time
        |— Adaptive Optimization in the Jalapeno JVM
  |— [ compiler ]
        |— The Java HotSpotTM Server Compiler
        |— Tailoring Graph-coloring Register Allocation For Runtime Compilation
        |— Linear Scan Register Allocation
        |— Design of the Java HotSpotTM Client Compiler for Java 6
  |— [ concurrent ]
        |— The.Art.of.Multiprocessor.Programming.Mar.2008
        |— The Concurrency Revolution The Hardware Story
        |— Multithreaded Programming Guide
        |— JVM Continuations
        |— java.util.concurrent Synchronizer Framework
        |— Java Concurrency Gotchas
        |— Groovy and Concurrency
        |— concurrent programming without locks
        |— Concurrency Grab Bag
        |— Alternative Concurrency Paradigms For the JVM
        |— Accelerating Java Workloads via GPUs
        |— A Scalable Lockfree Stack Algorithm
        |— A Concurrent Dynamic Analysis Framework
  |— [ io ]
        |— Asynchronous IO Tricks and Tips
  |— [ memory management ]
        |— Tuning Java Memory Manager
        |— The Ghost in the Virtual Machine A Reference to References
        |— The Garbage Collection Mythbusters
        |— SuperSizingJava
        |— Step by Step GC Tuning in the HotSpot Java Virtual Machine
        |— parallel gc ppt
        |— Oracle JDBC Memory Management
        |— NUMA-Aware-Java-Heaps-for-Server-Applications
        |— memorymanagement_whitepaper
        |— markcompact_gc ppt
        |— Leak Pruning
        |— GC Vs Explicit MM
        |— GC Tuning in the hotspot
        |— Garbage Collection and Memory Architecture
        |— Garbage Collection Algorithms For Automatic Dynamic Memory Management – Richard Jones
        |— [ Hotspot GC论文 ]
              |— Parallel Garbage Collection for Shared Memory Multiprocessors
              |— Garbage First Garbage Collector
              |— A Generational Mostly-concurrent Garbage Collector
        |— [ 其他JVM GC ]
              |— The pauseless gc
              |— Immix A Mark-Region Garbage Collector
              |— How to write a distributed gc
              |— GC Nirvana High Throughput And Low Latency Together
  |— [ monitoring and profiling ]
        |— Where Does All the Native Memory Go
        |— What’s Happening with My Application JVM Monitoring Tool
        |— Practical Lessons in Memory Analysis
        |— MonitoringGuide
        |— Microarchitectural Characterization of Production JVMs and JavaWorkloads
        |— Going Beyond Memory Leaks Debugging Java from Dumps, Using Memory Analyzer
        |— Diagnosing and Fixing Memory Leaks in Web Applications Tips from the Front Line
  |— [ osrelated ]
        |— poll-epoll_2
        |— poll-epoll_1
        |— memory systems
        |— Linux内核源代码情景分析
        |— linux_cpu_scheduler
        |— Linux 内核中断内幕
        |— Linux System and Performance Monitoring
        |— cpumemory
  |— [ performance ]
        |— Towards Performance Measurements for the Java Virtual Machine’s invokedynamic
        |— Thinking clearly about performance
        |— The Impact of Performance Asymmetry in Emerging Multicore Architectures
        |— the art of benchmarking
        |— Techniques for Obtaining High Performance in Java Programs
        |— Pipelining for Performance
        |— Performance myths and legends
        |— Performance Java Versus C
        |— How to Tune and Write Low-Latency Applications on the Java Virtual Machine
        |— How to Get the Most Performance from Sun JVM on Intel? Multi-Core Servers
        |— Comparing the Performance of Web Server Arch
        |— A Common API for Measuring Performance</p>
<p><a href="https://blog.bluedavy.com/?p=185" target="_blank">BTrace使用简介</a> <a href="https://blog.bluedavy.com/?p=198" target="_blank">JRockit读书笔记I — Java代码的高效执行</a></p>
<h3 id="15-comments-add-yours-">15 Comments <em>(<a href="">+add yours?</a>)</em></h3>
<ol>
<li><img src="https://secure.gravatar.com/avatar/e7a7df93e0364af10fd5bd942fd81f56?s=48&amp;d=&lt;path_to_url&gt;&amp;r=G" alt=""> <a href="http://blog.csdn.net/yang_net" target="_blank">yangwm</a>
<strong>Nov 16, 2010</strong> @ 20:34:17
顶！</li>
<li><img src="" alt=""> <a href="http://www.helishi.net/" target="_blank">ikbear</a>
<strong>Nov 16, 2010</strong> @ 21:29:26
顶！收藏了！</li>
<li><img src="https://secure.gravatar.com/avatar/37e14c958f24c5d75fb4dd926c175629?s=48&amp;d=&lt;path_to_url&gt;&amp;r=G" alt=""> <a href="http://www.ximengbao365.info/" target="_blank">ximengbao</a>
<strong>Nov 27, 2010</strong> @ 17:01:53
没人留言么 那我留一句</li>
<li><img src="https://secure.gravatar.com/avatar/d2b47d707d59207554e65aa3d3f83d18?s=48&amp;d=&lt;path_to_url&gt;&amp;r=G" alt=""> alipay_fred
<strong>Dec 03, 2010</strong> @ 20:17:48
Bohem GC 还是值得一开</li>
</ol>
<p>另外richard Jones 明年有本新书 关于GC的 期待中。。。</p>
<p>另外 今年ISMM 2011 的一些会议论文也很 insightfull</p>
<ol>
<li><img src="https://secure.gravatar.com/avatar/5267242305332fe1affd9c4788191e1d?s=48&amp;d=&lt;path_to_url&gt;&amp;r=G" alt=""> <a href="http://bluedavy.com/" target="_blank">bluedavy</a>
<strong>Dec 04, 2010</strong> @ 21:51:35
恩，感谢建议，:)</li>
<li><img src="https://secure.gravatar.com/avatar/3a190f857aef4c178e77fd9c499ba648?s=48&amp;d=&lt;path_to_url&gt;&amp;r=G" alt=""> <a href="http://www.ruyan.info/" target="_blank">如烟</a>
<strong>Dec 20, 2010</strong> @ 22:40:44
搜索过来的，这个还是挺有帮助的，谢了</li>
<li><img src="" alt=""> jilen
<strong>Jan 01, 2011</strong> @ 22:23:49
给力啊，毕玄同学</li>
<li><img src="https://secure.gravatar.com/avatar/5e07c82e4b00ec8fa41e753e43b90d97?s=48&amp;d=&lt;path_to_url&gt;&amp;r=G" alt=""> clark
<strong>Feb 11, 2011</strong> @ 14:39:54
楼主同学你好厉害啊，对于我们一般人，这些书都看完，人会不会翘掉？？</li>
<li><img src="https://secure.gravatar.com/avatar/5267242305332fe1affd9c4788191e1d?s=48&amp;d=&lt;path_to_url&gt;&amp;r=G" alt=""> <a href="http://bluedavy.com/" target="_blank">bluedavy</a>
<strong>Feb 15, 2011</strong> @ 21:34:00
哈哈，只要有兴趣，看完应该还是正常滴…</li>
<li><img src="https://secure.gravatar.com/avatar/d7159b92ad12edacca5f2a922957ec17?s=48&amp;d=&lt;path_to_url&gt;&amp;r=G" alt=""> lorb
<strong>Mar 22, 2011</strong> @ 11:28:05
赞，发现好多博客的参考链接都指到这儿
在国内这么浮躁的技术氛围中的一方净土，偶像ORZ
JVM相关的中文书籍太少，能否写一本</li>
<li><img src="https://secure.gravatar.com/avatar/aca8bd25b6ab38864dc63502766e357f?s=48&amp;d=&lt;path_to_url&gt;&amp;r=G" alt=""> milo
<strong>Jun 09, 2011</strong> @ 23:18:15
大侠，请教一个很弱智的问题，最近jboss老出现：java.lang.OutOfMemoryError: nativeGetNewTLA 错误，我想请问 nativeGetNewTLA 有什么含义，因为当我看到java.lang.OutOfMemoryError: allocLargeObjectOrArray 时，根据allocLargeObjectOrArray可大概知道是在堆上为大对象或数组对象分配空间时内存不够了，所以我想nativeGetNewTLA 应该能告诉我点什么。google 上看了很多，不理想，想请教你，另外有没有什么文档对这个OutOfMemoryError错误的各种message做个大概的说明。</li>
<li><img src="https://secure.gravatar.com/avatar/5267242305332fe1affd9c4788191e1d?s=48&amp;d=&lt;path_to_url&gt;&amp;r=G" alt=""> <a href="http://bluedavy.com/" target="_blank">bluedavy</a>
<strong>Jun 10, 2011</strong> @ 11:57:18
…这是java crash后出现的错误信息吧？
也许可以看看这个里面关于OOM的说明：<a href="http://blog.bluedavy.com/?p=200" target="_blank">http://blog.bluedavy.com/?p=200</a></li>
<li><img src="https://secure.gravatar.com/avatar/54e62b72074a55e9e404bfabb9217386?s=48&amp;d=&lt;path_to_url&gt;&amp;r=G" alt=""> cheto
<strong>Aug 18, 2011</strong> @ 13:05:15
JRocket The Definite Guide 这一类原版书要怎么才能买到？是不是要代购啊</li>
<li><img src="https://secure.gravatar.com/avatar/5267242305332fe1affd9c4788191e1d?s=48&amp;d=&lt;path_to_url&gt;&amp;r=G" alt=""> <a href="http://bluedavy.com/" target="_blank">bluedavy</a>
<strong>Aug 18, 2011</strong> @ 20:30:29
@cheto，恩，是滴，在国内没有引入影像版前，就只有代购了，或者买电子版吧。<h3 id="leave-a-reply">Leave a Reply</h3>
</li>
</ol>
<p><a href="">Cancel</a></p>
<p>Name (required)</p>
<p>Mail (required)</p>
<p>Website</p>
<p><img src="&quot;CAPTCHA Image&quot;" alt="CAPTCHA Image"></p>
<p><a href="&quot;Refresh Image&quot;"><img src="" alt="Refresh Image"></a></p>
<p>CAPTCHA Code /*</p>
<p><style type='text/css'>/#submit {display:none;}</style><br /> <input name="submit" type="submit" id="submit-alt" tabindex="6" value="Submit Comment" /></p>
<p>July 2013 M T W T F S S <a href="https://blog.bluedavy.com/?m=201303" title="View posts for March 2013" target="_blank">« Mar</a>     1234567 891011121314 15161718192021 22232425262728 293031  </p>
<h3 id="categories">Categories</h3>
<ul>
<li><a href="https://blog.bluedavy.com/?cat=63" title="View all posts filed under Java" target="_blank">Java</a> (10)</li>
<li><a href="https://blog.bluedavy.com/?cat=13" title="View all posts filed under jvm" target="_blank">jvm</a> (19)</li>
<li><a href="https://blog.bluedavy.com/?cat=56" title="View all posts filed under NoSQL" target="_blank">NoSQL</a> (7)</li>
<li><a href="https://blog.bluedavy.com/?cat=4" title="View all posts filed under SOA" target="_blank">SOA</a> (1)</li>
<li><a href="https://blog.bluedavy.com/?cat=11" title="关于《分布式Java应用：基础与实践》书部分章节的公开、书内容的纠错以及补充完善。" target="_blank">书:分布式Java应用</a> (5)</li>
<li><a href="https://blog.bluedavy.com/?cat=6" title="View all posts filed under 互联网" target="_blank">互联网</a> (5)</li>
<li><a href="https://blog.bluedavy.com/?cat=46" title="View all posts filed under 产品总结" target="_blank">产品总结</a> (1)</li>
<li><a href="https://blog.bluedavy.com/?cat=18" title="View all posts filed under 优化案例" target="_blank">优化案例</a> (1)</li>
<li><a href="https://blog.bluedavy.com/?cat=12" title="View all posts filed under 圆桌交流" target="_blank">圆桌交流</a> (2)</li>
<li><a href="https://blog.bluedavy.com/?cat=8" title="View all posts filed under 容量规划" target="_blank">容量规划</a> (2)</li>
<li><a href="https://blog.bluedavy.com/?cat=97" title="View all posts filed under 迁户口" target="_blank">迁户口</a> (1)</li>
<li><a href="https://blog.bluedavy.com/?cat=52" title="View all posts filed under 高可用" target="_blank">高可用</a> (1)</li>
<li><a href="https://blog.bluedavy.com/?cat=3" title="View all posts filed under 高并发" target="_blank">高并发</a> (3)</li>
<li><p><a href="https://blog.bluedavy.com/?cat=1" title="关于性能优化方面的一些东西。" target="_blank">高性能</a> (2)</p>
<h3 id="recent-comments">Recent Comments</h3>
</li>
<li><p><a href="http://code1.riaos.com/?p=5030138" target="_blank">JVM调优 | code1（code1.riaos.com）</a> on <a href="https://blog.bluedavy.com/?p=70&amp;cpage=1#comment-16520" target="_blank">说说MaxTenuringThreshold这个参数</a></p>
</li>
<li><a href="http://architecture1.riaos.com/?p=3063358" target="_blank">JVM调优 | architecture（riaos.com）</a> on <a href="https://blog.bluedavy.com/?p=70&amp;cpage=1#comment-16519" target="_blank">说说MaxTenuringThreshold这个参数</a></li>
<li><a href="http://bluedavy.com/" target="_blank">bluedavy</a> on <a href="https://blog.bluedavy.com/?p=409&amp;cpage=1#comment-16462" target="_blank">一个Java应用频繁抛异常导致cpu us诡异现象的案例</a></li>
<li>xiaobo on <a href="https://blog.bluedavy.com/?p=409&amp;cpage=1#comment-16460" target="_blank">一个Java应用频繁抛异常导致cpu us诡异现象的案例</a></li>
<li><a href="http://bluedavy.com/" target="_blank">bluedavy</a> on <a href="https://blog.bluedavy.com/?p=409&amp;cpage=1#comment-16459" target="_blank">一个Java应用频繁抛异常导致cpu us诡异现象的案例</a></li>
</ul>
<h3 id="tags">Tags</h3>
<p><a href="https://blog.bluedavy.com/?tag=btrace" title="2 topics" target="_blank">btrace</a> <a href="https://blog.bluedavy.com/?tag=c1" title="1 topic" target="_blank">c1</a> <a href="https://blog.bluedavy.com/?tag=c2" title="1 topic" target="_blank">c2</a> <a href="https://blog.bluedavy.com/?tag=deflater" title="1 topic" target="_blank">Deflater</a> <a href="https://blog.bluedavy.com/?tag=facebook" title="2 topics" target="_blank">facebook</a> <a href="https://blog.bluedavy.com/?tag=gc" title="4 topics" target="_blank">gc</a> <a href="https://blog.bluedavy.com/?tag=gc-tuning" title="2 topics" target="_blank">gc tuning</a> <a href="https://blog.bluedavy.com/?tag=grizzly" title="2 topics" target="_blank">Grizzly</a> <a href="https://blog.bluedavy.com/?tag=hbase" title="6 topics" target="_blank">HBase</a> <a href="https://blog.bluedavy.com/?tag=hotspot" title="1 topic" target="_blank">hotspot</a> <a href="https://blog.bluedavy.com/?tag=inflater" title="1 topic" target="_blank">Inflater</a> <a href="https://blog.bluedavy.com/?tag=interpreter" title="1 topic" target="_blank">interpreter</a> <a href="https://blog.bluedavy.com/?tag=javac" title="1 topic" target="_blank">javac</a> <a href="https://blog.bluedavy.com/?tag=java-code-generation" title="1 topic" target="_blank">java code generation</a> <a href="https://blog.bluedavy.com/?tag=javaone" title="4 topics" target="_blank">JavaOne</a> <a href="https://blog.bluedavy.com/?tag=javaone-general-technical-session" title="1 topic" target="_blank">javaone general technical session</a> <a href="https://blog.bluedavy.com/?tag=java%e4%bb%a3%e7%a0%81%e6%89%a7%e8%a1%8c" title="1 topic" target="_blank">java代码执行</a> <a href="https://blog.bluedavy.com/?tag=java-%e5%b9%b6%e5%8f%91" title="1 topic" target="_blank">Java 并发</a> <a href="https://blog.bluedavy.com/?tag=jit" title="1 topic" target="_blank">jit</a> <a href="https://blog.bluedavy.com/?tag=jvm" title="12 topics" target="_blank">jvm</a> <a href="https://blog.bluedavy.com/?tag=memory-management" title="1 topic" target="_blank">memory management</a> <a href="https://blog.bluedavy.com/?tag=native-memory-leak" title="1 topic" target="_blank">Native Memory Leak</a> <a href="https://blog.bluedavy.com/?tag=nosql" title="2 topics" target="_blank">NoSQL</a> <a href="https://blog.bluedavy.com/?tag=oom" title="1 topic" target="_blank">oom</a> <a href="https://blog.bluedavy.com/?tag=oracle-keynote" title="1 topic" target="_blank">oracle keynote</a> <a href="https://blog.bluedavy.com/?tag=pessimism-policy" title="1 topic" target="_blank">pessimism policy</a> <a href="https://blog.bluedavy.com/?tag=references" title="1 topic" target="_blank">references</a> <a href="https://blog.bluedavy.com/?tag=rpc" title="2 topics" target="_blank">RPC</a> <a href="https://blog.bluedavy.com/?tag=serial-gc" title="1 topic" target="_blank">serial gc</a> <a href="https://blog.bluedavy.com/?tag=soa" title="2 topics" target="_blank">SOA</a> <a href="https://blog.bluedavy.com/?tag=sun-jdk" title="1 topic" target="_blank">sun jdk</a> <a href="https://blog.bluedavy.com/?tag=sun-jdk-oom" title="1 topic" target="_blank">sun jdk oom</a> <a href="https://blog.bluedavy.com/?tag=web%e5%ae%b9%e9%87%8f%e8%a7%84%e5%88%92%e7%9a%84%e8%89%ba%e6%9c%af" title="1 topic" target="_blank">Web容量规划的艺术</a> <a href="https://blog.bluedavy.com/?tag=yuanzhuo" title="1 topic" target="_blank">yuanzhuo</a> <a href="https://blog.bluedavy.com/?tag=%e4%b9%a6" title="1 topic" target="_blank">书:分布式Java应用</a> <a href="https://blog.bluedavy.com/?tag=%e4%b9%a6%e8%af%84" title="1 topic" target="_blank">书评</a> <a href="https://blog.bluedavy.com/?tag=%e4%ba%92%e8%81%94%e7%bd%91%e6%8a%80%e6%9c%af" title="1 topic" target="_blank">互联网技术</a> <a href="https://blog.bluedavy.com/?tag=%e4%ba%a4%e6%b5%81" title="1 topic" target="_blank">交流</a> <a href="https://blog.bluedavy.com/?tag=%e5%86%85%e5%ad%98%e7%ae%a1%e7%90%86" title="1 topic" target="_blank">内存管理</a> <a href="https://blog.bluedavy.com/?tag=%e5%88%86%e5%b8%83%e5%bc%8fjava%e5%ba%94%e7%94%a8" title="2 topics" target="_blank">分布式Java应用</a> <a href="https://blog.bluedavy.com/?tag=%e5%9c%86%e6%a1%8c%e4%ba%a4%e6%b5%81" title="1 topic" target="_blank">圆桌交流</a> <a href="https://blog.bluedavy.com/?tag=%e5%ae%b9%e9%87%8f%e8%a7%84%e5%88%92" title="2 topics" target="_blank">容量规划</a> <a href="https://blog.bluedavy.com/?tag=%e6%82%b2%e8%a7%82%e7%ad%96%e7%95%a5" title="3 topics" target="_blank">悲观策略</a> <a href="https://blog.bluedavy.com/?tag=%e6%9c%8d%e5%8a%a1%e6%a1%86%e6%9e%b6" title="1 topic" target="_blank">服务框架</a> <a href="https://blog.bluedavy.com/?tag=%e7%a1%85%e8%b0%b7%e5%85%ac%e5%8f%b8" title="1 topic" target="_blank">硅谷公司</a></p>
<h3 id="-">订阅</h3>
<h3 id="-">推荐书籍</h3>
<h3 id="my-book">My Book</h3>
<p><a href="http://book.douban.com/subject/4848587/" title="分布式Java应用：基础与实践" target="_blank"><img src="" alt=""></a> <a href="http://book.douban.com/subject/3843896/" title="OSGi原理与最佳实践" target="_blank"><img src="" alt=""></a>
© <a href="https://blog.bluedavy.com/" target="_blank">BlueDavy之技术blog</a> 2013</p>
<p><a href="http://icondock.com/" target="_blank">Icons</a> &amp; <a href="http://www.ndesign-studio.com/wp-themes" target="_blank">Wordpress Theme</a> by <a href="http://www.ndesign-studio.com/" target="_blank">N.Design</a></p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/JVM/">JVM</a></li></span></span> | <span class="tags">Tagged <a href="/tags/JVM/" class="label label-primary">JVM</a><a href="/tags/Java&J2EE/" class="label label-success">Java&J2EE</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:42"datetime="2014-03-07 09:54:42"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-JVM--学习JVM的References/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-JVM--学习JVM的References" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--借HSDB来探索HotSpotVM的运行时数据/">借HSDB来探索HotSpot VM的运行时数据</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:42.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--借HSDB来探索HotSpotVM的运行时数据/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-hsdb-hotspot-vm-">借HSDB来探索HotSpot VM的运行时数据</h1>
<p>（未经许可请勿转载。希望转载请与我联系。）
（如果打开此页面时浏览器有点卡住的话请耐心等待片刻。大概是ItEye的代码高亮太耗时了…）
几天前在<a href="http://hllvm.group.iteye.com/" target="_blank">HLLVM群组</a>有人<a href="http://hllvm.group.iteye.com/group/topic/37542" target="_blank">问了个小问题</a>，说
Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>public class Test {  </li>
<li>static Test2 t1 = new Test2();  </li>
<li>Test2 t2 = new Test2();  </li>
<li>public void fn() {  </li>
<li>Test2 t3 = new Test2();       </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>class Test2 {  </li>
<li></li>
<li>}  </li>
</ol>
<p>public class Test {</p>
<pre><code>static Test2 t1 = new Test2();
       Test2 t2 = new Test2();

public void fn() {
    Test2 t3 = new Test2();    

}
</code></pre><p>}</p>
<p>class Test2 {</p>
<p>}
这个程序的t1、t2、t3三个变量本身（而不是这三个变量所指向的对象）到底在哪里。
TL;DR版回答是：</p>
<ul>
<li>t1在存Java静态变量的地方，概念上在JVM的方法区（method area）里</li>
<li>t2在Java堆里，作为Test的一个实例的字段存在</li>
<li>t3在Java线程的调用栈里，作为Test.fn()的一个局部变量存在
不过就这么简单的回答大家都会，满足不了对JVM的实现感兴趣的同学们的好奇心。说到底，这“方法区”到底是啥？Java堆在哪里？Java线程的调用栈又是啥样的？
那就让我们跑点例子，借助调试器来看看在一个实际运行中的JVM里是啥状况。<h1 id="-https-gist-github-com-rednaxelafx-5392451-https-gist-github-com-rednaxelafx-5392451-">（下文中代码也传了一份到<a href="https://gist.github.com/rednaxelafx/5392451" target="_blank"><a href="https://gist.github.com/rednaxelafx/5392451">https://gist.github.com/rednaxelafx/5392451</a></a>）</h1>
写个启动类来跑上面问题中的代码：
Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></li>
</ul>
<ol>
<li>public class Main {  </li>
<li>public static void main(String[] args) {  </li>
<li>Test test = new Test();  </li>
<li>test.fn();  </li>
<li>}  </li>
<li>}  </li>
</ol>
<p>public class Main {</p>
<pre><code>public static void main(String[] args) {
    Test test = new Test();

    test.fn();
}
</code></pre><p>}
（编译这个Main.java和上面的Test.java时最好加上-g参数生成LocalVariableTable等调试信息，以便后面某些情况下可以用到）
接下来如无特别说明本文将使用Windows 7 64-bit, Oracle JDK 1.7.0_09 Server VM, Serial GC的环境中运行所有例子。
之前在GreenTeaJUG在杭州的活动<a href="http://rednaxelafx.iteye.com/blog/1814180" target="_blank">演示Serviceability Agent</a>的时候也讲到过这是个非常便于探索HotSpot VM内部实现的API，而HSDB则是在SA基础上包装起来的一个调试器。这次我们就用HSDB来做实验。
SA的一个限制是它只实现了调试snapshot的功能：要么要让被调试的目标进程完全暂停，要么就调试core dump。所以我们在用HSDB做实验前，得先让我们的Java程序运行到我们关注的点上才行。
理想情况下我们会希望让这Java程序停在Test.java的第6行，也就是Test.fn()中t3局部变量已经进入作用域，而该方法又尚未返回的地方。怎样才能停在这里呢？
其实用个Java层的调试器即可。大家平时可能习惯了在Eclipse、IntelliJ IDEA、NetBeans等Java IDE里使用Java层调试器，但为了减少对外部工具的依赖，本文将使用Oracle JDK自带的jdb工具来完成此任务。
<a href="http://docs.oracle.com/javase/7/docs/technotes/tools/windows/jdb.html" target="_blank">jdb</a>跟上面列举的IDE里包含的调试器底下依赖着同一套调试API，也就是<a href="http://docs.oracle.com/javase/7/docs/technotes/guides/jpda/index.html" target="_blank">Java Platform Debugger Architecture (JPDA)</a>。功能也类似，只是界面是命令行的，表明上看起来不太一样而已。
为了方便后续步骤，启动jdb的时候可以设定让目标Java程序使用serial GC和10MB的Java heap。
启动jdb之后可以用stop in命令在指定的Java方法入口处设置断点，
然后用run命令指定主类名称来启动Java程序，
等跑到断点看看位置是否已经到满足需求，还没到的话可以用step、next之类的命令来向前进。
对jdb命令不熟悉的同学可以在启动jdb之后使用help命令来查看命令列表和说明。
具体步骤如下：
Command prompt代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>D:\test&gt;jdb -XX:+UseSerialGC -Xmx10m  </li>
<li>Initializing jdb ...  </li>
<li><blockquote>
<p>stop in Test.fn  </p>
</blockquote>
</li>
<li>Deferring breakpoint Test.fn.  </li>
<li>It will be set after the class is loaded.  </li>
<li><blockquote>
<p>run Main  </p>
</blockquote>
</li>
<li>run  Main  </li>
<li>Set uncaught java.lang.Throwable  </li>
<li>Set deferred uncaught java.lang.Throwable  </li>
<li><blockquote>
</blockquote>
</li>
<li>VM Started: Set deferred breakpoint Test.fn  </li>
<li></li>
<li>Breakpoint hit: &quot;thread=main&quot;, Test.fn(), line=5 bci=0  </li>
<li>5            Test2 t3 = new Test2();  </li>
<li></li>
<li>main[1] next  </li>
<li></li>
<li>Step completed: &gt; &quot;thread=main&quot;, Test.fn(), line=6 bci=8  </li>
<li>6        }  </li>
<li></li>
<li>main[1]   </li>
</ol>
<p>D:\test&gt;jdb -XX:+UseSerialGC -Xmx10m</p>
<p>Initializing jdb ...</p>
<blockquote>
<p>stop in Test.fn</p>
</blockquote>
<p>Deferring breakpoint Test.fn.
It will be set after the class is loaded.</p>
<blockquote>
<p>run Main
run  Main</p>
</blockquote>
<p>Set uncaught java.lang.Throwable
Set deferred uncaught java.lang.Throwable</p>
<p>&gt;
VM Started: Set deferred breakpoint Test.fn</p>
<p>Breakpoint hit: &quot;thread=main&quot;, Test.fn(), line=5 bci=0</p>
<p>5            Test2 t3 = new Test2();</p>
<p>main[1] next</p>
<p>Step completed: &gt; &quot;thread=main&quot;, Test.fn(), line=6 bci=8
6        }</p>
<p>main[1]
按照上述步骤执行完最后一个next命令之后，我们就来到了最初想要的Test.java的第6行，也就是Test.fn()返回前的位置。
接下来把这个jdb窗口放一边，另开一个命令行窗口用<a href="http://docs.oracle.com/javase/7/docs/technotes/tools/share/jps.html" target="_blank">jps</a>命令看看我们要调试的Java进程的pid是多少：
Command prompt代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>D:\test&gt;jps  </li>
<li>4328 Main  </li>
<li>9064 Jps  </li>
<li>7716 TTY  </li>
</ol>
<p>D:\test&gt;jps</p>
<p>4328 Main
9064 Jps</p>
<p>7716 TTY
可以看到是4328。把这个pid记下来待会儿用。
然后启动HSDB：
Command prompt代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>D:\test&gt;java -cp .;%JAVA_HOME%/lib/sa-jdi.jar sun.jvm.hotspot.HSDB  </li>
</ol>
<p>D:\test&gt;java -cp .;%JAVA_HOME%/lib/sa-jdi.jar sun.jvm.hotspot.HSDB
（要留意Linux和Solaris在Oracle/Sun JDK6就可以使用HSDB了，但Windows上要到Oracle JDK7才可以用HSDB）
启动HSDB之后，把它连接到目标进程上。从菜单里选择File -&gt; Attach to HotSpot process：
<img src="&quot;点击查看原始大小图片&quot;" alt="">
在弹出的对话框里输入刚才记下的pid然后按OK：
<img src="&quot;点击查看原始大小图片&quot;" alt="">
这会儿就连接到目标进程了：
<img src="&quot;点击查看原始大小图片&quot;" alt="">
刚开始打开的窗口是Java Threads，里面有个线程列表。双击代表线程的行会打开一个Oop Inspector窗口显示HotSpot VM里记录线程的一些基本信息的C++对象的内容。
不过这里我们更可能会关心的是线程栈的内存数据。先选择main线程，然后点击Java Threads窗口里的工具栏按钮从左数第2个可以打开Stack Memory窗口来显示main线程的栈：
<img src="&quot;点击查看原始大小图片&quot;" alt="">
Stack Memory窗口的内容有三栏：
左起第1栏是内存地址，请让我提醒一下本文里提到“内存地址”的地方都是指虚拟内存意义上的地址，<strong>不是</strong>“物理内存地址”，请不要弄混了这俩概念；
第2栏是该地址上存的数据，以字宽为单位，本文例子中我是在Windows 7 64-bit上跑64位的JDK7的HotSpot VM，字宽是64位（8字节）；
第3栏是对数据的注释，竖线表示范围，横线或斜线连接范围与注释文字。
现在看不懂这个窗口里的数据没关系，先放一边，后面再回过头来看。
现在让我们打开HSDB里的控制台，以便用命令来了解更多信息。
在菜单里选择Windows -&gt; Console：
<img src="" alt="">
然后会得到一个空白的Command Line窗口。在里面敲一下回车就会出现hsdb&gt;提示符。
（用过CLHSDB的同学可能会发现这就是把CLHSDB嵌入在了HSDB的图形界面里）
不知道有什么命令可用的同学可以先用help命令看看命令列表。
可以用universe命令来查看GC堆的地址范围和使用情况：
Hsdb代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>hsdb&gt; universe  </li>
<li>Heap Parameters:  </li>
<li>Gen 0:   eden [0x00000000fa400000,0x00000000fa4aad68,0x00000000fa6b0000) space capacity = 2818048, 24.831088753633722 used  </li>
<li>from [0x00000000fa6b0000,0x00000000fa6b0000,0x00000000fa700000) space capacity = 327680, 0.0 used  </li>
<li>to   [0x00000000fa700000,0x00000000fa700000,0x00000000fa750000) space capacity = 327680, 0.0 usedInvocations: 0  </li>
<li></li>
<li>Gen 1:   old  [0x00000000fa750000,0x00000000fa750000,0x00000000fae00000) space capacity = 7012352, 0.0 usedInvocations: 0  </li>
<li></li>
<li>perm [0x00000000fae00000,0x00000000fb078898,0x00000000fc2c0000) space capacity = 21757952, 11.90770160721009 usedInvocations: 0  </li>
</ol>
<p>hsdb&gt; universe</p>
<p>Heap Parameters:
Gen 0:   eden [0x00000000fa400000,0x00000000fa4aad68,0x00000000fa6b0000) space capacity = 2818048, 24.831088753633722 used</p>
<p>  from [0x00000000fa6b0000,0x00000000fa6b0000,0x00000000fa700000) space capacity = 327680, 0.0 used
  to   [0x00000000fa700000,0x00000000fa700000,0x00000000fa750000) space capacity = 327680, 0.0 usedInvocations: 0</p>
<p>Gen 1:   old  [0x00000000fa750000,0x00000000fa750000,0x00000000fae00000) space capacity = 7012352, 0.0 usedInvocations: 0</p>
<p>  perm <a href="&quot;复制代码&quot;">0x00000000fae00000,0x00000000fb078898,0x00000000fc2c0000) space capacity = 21757952, 11.90770160721009 usedInvocations: 0
这里用的是HotSpot VM的serial GC。GC堆由young gen = DefNewGeneration（包括eden和两个survivor space）、old gen = TenuredGeneration和perm gen = PermGen构成。
其中young gen和old gen构成了这种配置下HotSpot VM里的Java堆（Java heap），而perm gen不属于Java heap的一部分，它存储的主要是元数据或者叫反射信息，主要用于实现JVM规范里的“方法区”概念。
在我们的Java代码里，执行到Test.fn()末尾为止应该创建了3个Test2的实例。它们必然在GC堆里，但都在哪里呢？用scanoops命令来看：
Hsdb代码 [<img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>hsdb&gt; scanoops 0x00000000fa400000 0x00000000fc2c0000 Test2  </li>
<li>0x00000000fa49a710 Test2  </li>
<li>0x00000000fa49a730 Test2  </li>
<li>0x00000000fa49a740 Test2  </li>
</ol>
<p>hsdb&gt; scanoops 0x00000000fa400000 0x00000000fc2c0000 Test2</p>
<p>0x00000000fa49a710 Test2
0x00000000fa49a730 Test2</p>
<p>0x00000000fa49a740 Test2
scanoops接受两个必选参数和一个可选参数：必选参数是要扫描的地址范围，一个是起始地址一个是结束地址；可选参数用于指定要扫描什么类型的对象实例。实际扫描的时候会扫出指定的类型及其派生类的实例。
这里可以看到确实扫出了3个Test2的实例。内容有两列：左边是对象的起始地址，右边是对象的实际类型。
从它们所在的地址，对照前面universe命令看到的GC堆的地址范围，可以知道它们都在eden里。
通过whatis命令可以进一步知道它们都在eden之中分配给main线程的thread-local allocation buffer (TLAB)中：
Hsdb代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>hsdb&gt; whatis 0x00000000fa49a710  </li>
<li>Address 0x00000000fa49a710: In thread-local allocation buffer for thread &quot;main&quot; (1)  [0x00000000fa48f490,0x00000000fa49a750,0x00000000fa49d118)  </li>
<li></li>
<li>hsdb&gt; whatis 0x00000000fa49a730  </li>
<li>Address 0x00000000fa49a730: In thread-local allocation buffer for thread &quot;main&quot; (1)  [0x00000000fa48f490,0x00000000fa49a750,0x00000000fa49d118)  </li>
<li></li>
<li>hsdb&gt; whatis 0x00000000fa49a740  </li>
<li>Address 0x00000000fa49a740: In thread-local allocation buffer for thread &quot;main&quot; (1)  [0x00000000fa48f490,0x00000000fa49a750,0x00000000fa49d118)  </li>
<li></li>
<li>hsdb&gt;   </li>
</ol>
<p>hsdb&gt; whatis 0x00000000fa49a710</p>
<p>Address 0x00000000fa49a710: In thread-local allocation buffer for thread &quot;main&quot; (1)  [0x00000000fa48f490,0x00000000fa49a750,0x00000000fa49d118)</p>
<p>hsdb&gt; whatis 0x00000000fa49a730
Address 0x00000000fa49a730: In thread-local allocation buffer for thread &quot;main&quot; (1)  [0x00000000fa48f490,0x00000000fa49a750,0x00000000fa49d118)</p>
<p>hsdb&gt; whatis 0x00000000fa49a740</p>
<p>Address 0x00000000fa49a740: In thread-local allocation buffer for thread &quot;main&quot; (1)  [0x00000000fa48f490,0x00000000fa49a750,0x00000000fa49d118)</p>
<p>hsdb&gt;
还可以用inspect命令来查看对象的内容：
Hsdb代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>hsdb&gt; inspect 0x00000000fa49a710  </li>
<li>instance of Oop for Test2 @ 0x00000000fa49a710 @ 0x00000000fa49a710 (size = 16)  </li>
<li>_mark: 1  </li>
</ol>
<p>hsdb&gt; inspect 0x00000000fa49a710</p>
<p>instance of Oop for Test2 @ 0x00000000fa49a710 @ 0x00000000fa49a710 (size = 16)
_mark: 1
可见一个Test2的实例要16字节。因为Test2类没有任何Java层的实例字段，这里就没有任何Java实例字段可显示。不过本来这里还应该显示一行：
Hsdb代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>_metadata._compressed_klass: InstanceKlass for Test2 @ 0x00000000fb078608  </li>
</ol>
<p>_metadata._compressed_klass: InstanceKlass for Test2 @ 0x00000000fb078608
不幸因为这个版本的HotSpot VM里带的SA有bug所以没显示出来。此bug在新版里已修。
还想看到更裸的数据的同学可以用mem命令来看实际内存里的数据长啥样：
Hsdb代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>hsdb&gt; mem 0x00000000fa49a710 2  </li>
<li>0x00000000fa49a710: 0x0000000000000001   </li>
<li>0x00000000fa49a718: 0x00000000fb078608   </li>
</ol>
<p>hsdb&gt; mem 0x00000000fa49a710 2</p>
<p>0x00000000fa49a710: 0x0000000000000001
0x00000000fa49a718: 0x00000000fb078608
mem命令接受的两个参数都必选，一个是起始地址，另一个是以字宽为单位的“长度”。我们知道一个Test2实例有16字节，所以给定长度为2来看。
上面的数字都是啥来的呢？
Memory代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>0x00000000fa49a710:  _mark:                        0x0000000000000001   </li>
<li>0x00000000fa49a718:  _metadata._compressed_klass:  0xfb078608  </li>
<li>0x00000000fa49a71c:  (padding):                    0x00000000  </li>
</ol>
<p>0x00000000fa49a710:  _mark:                        0x0000000000000001</p>
<p>0x00000000fa49a718:  _metadata._compressed_klass:  0xfb078608
0x00000000fa49a71c:  (padding):                    0x00000000
一个Test2的实例包含2个给VM用的隐含字段作为对象头，和0个Java字段。
对象头的第一个字段是mark word，记录该对象的GC状态、同步状态、identity hash code之类的多种信息。
对象头的第二个字段是个类型信息指针，klass pointer。这里因为默认开启了压缩指针，所以本来应该是64位的指针存在了32位字段里。
最后还有4个字节是为了满足对齐需求而做的填充（padding）。
以前在另一帖里也介绍过这部分内容，可以参考：<a href="http://rednaxelafx.iteye.com/blog/730461" target="_blank">借助HotSpot SA来一窥PermGen上的对象</a>
顺带发张Inspector的截图来展示HotSpot VM里描述Test2类的VM对象长啥样吧。
在菜单里选Tools -&gt; Inspector，在地址里输入前面看到的klass地址：
<img src="&quot;点击查看原始大小图片&quot;" alt="">
InstanceKlass存着Java类型的名字、继承关系、实现接口关系，字段信息，方法信息，运行时常量池的指针，还有内嵌的虚方法表（vtable）、接口方法表（itable）和记录对象里什么位置上有GC会关心的指针（oop map）等等。
留意到这个InstanceKlass是给VM内部用的，并不直接暴露给Java层；InstanceKlass不是java.lang.Class的实例。
在HotSpot VM里，java.lang.Class的实例被称为“Java mirror”，意思是它是VM内部用的klass对象的“镜像”，把klass对象包装了一层来暴露给Java层使用。
在InstanceKlass里有个_java_mirror字段引用着它对应的Java mirror，而mirror里也有个隐藏字段指向其对应的InstanceKlass。
所以当我们写obj.getClass()，在HotSpot VM里实际上经过了两层间接引用才能找到最终的Class对象：
Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>obj-&gt;_klass-&gt;_java_mirror  </li>
</ol>
<p>obj-&gt;_klass-&gt;_java_mirror
在Oracle JDK7之前，Oracle/Sun JDK的HotSpot VM把Java类的静态变量存在InstanceKlass结构的末尾；从Oracle JDK7开始，为了配合PermGen移除的工作，Java类的静态变量被挪到Java mirror（Class对象）的末尾了。</p>
<h1 id="-jdk7-java-mirror-permgen-jdk7-java-mirror-java-eden-permgen-jdk8-permgen-klass-gc-java-mirror-jdk7-">还有就是，在JDK7之前Java mirror存放在PermGen里，而从JDK7开始Java mirror默认也跟普通Java对象一样先从eden开始分配而不放在PermGen里。到JDK8则进一步彻底移除了PermGen，把诸如klass之类的元数据都挪到GC堆之外管理，而Java mirror的处理则跟JDK7一样。</h1>
<p>前面对HSDB的操作和HotSpot VM里的一些内部数据结构有了一定的了解，现在让我们回到主题：找指针！
HotSpot VM内部使用直接指针来实现Java引用。在64位环境中有可能启用“压缩指针”的功能把64位指针压缩到只用32位来存。压缩指针与非压缩指针直接有非常简单的1对1对应关系，前者可以看作后者的特例。
于是我们要找t1、t2、t3这三个变量，等同于找出存有指向上述3个Test2实例的地址的存储位置。
不嫌麻烦的话手工扫描内存去找也能找到，不过幸好HSDB内建了revptrs命令，可以找出“反向指针”——如果a变量引用着b对象，那么对b对象来说a就是一个“反向指针”。
先拿第一个Test2的实例试试看：
Hsdb代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>hsdb&gt; revptrs 0x00000000fa49a710  </li>
<li>Computing reverse pointers...  </li>
<li>Done.  </li>
<li>null  </li>
<li>Oop for java/lang/Class @ 0x00000000fa499b00  </li>
</ol>
<p>hsdb&gt; revptrs 0x00000000fa49a710</p>
<p>Computing reverse pointers...
Done.</p>
<p>null
Oop for java/lang/Class @ 0x00000000fa499b00
还真的找到了一个包含指向Test2实例的指针，在一个java.lang.Class的实例里。
用whatis命令来看看这个Class对象在哪里：
Hsdb代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>hsdb&gt; whatis 0x00000000fa499b00  </li>
<li>Address 0x00000000fa499b00: In thread-local allocation buffer for thread &quot;main&quot; (1)  [0x00000000fa48f490,0x00000000fa49a750,0x00000000fa49d118)  </li>
<li></li>
</ol>
<p>hsdb&gt; whatis 0x00000000fa499b00</p>
<p>Address 0x00000000fa499b00: In thread-local allocation buffer for thread &quot;main&quot; (1)  [0x00000000fa48f490,0x00000000fa49a750,0x00000000fa49d118)</p>
<p>可以看到这个Class对象也在eden里，具体来说在main线程的TLAB里。
这个Class对象是如何引用到Test2的实例的呢？再用inspect命令：
Hsdb代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>hsdb&gt; inspect 0x00000000fa499b00  </li>
<li>instance of Oop for java/lang/Class @ 0x00000000fa499b00 @ 0x00000000fa499b00 (size = 120)  </li>
<li>&lt;<Reverse pointers>&gt;:   </li>
<li>t1: Oop for Test2 @ 0x00000000fa49a710 Oop for Test2 @ 0x00000000fa49a710  </li>
</ol>
<p>hsdb&gt; inspect 0x00000000fa499b00</p>
<p>instance of Oop for java/lang/Class @ 0x00000000fa499b00 @ 0x00000000fa499b00 (size = 120)
&lt;<Reverse pointers>&gt;:</p>
<p>t1: Oop for Test2 @ 0x00000000fa49a710 Oop for Test2 @ 0x00000000fa49a710
可以看到，这个Class对象里存着Test类的静态变量t1，指向着第一个Test2实例。
<strong>成功找到t1了！这个有点特别，本来JVM规范里也没明确规定静态变量要存在哪里，通常认为它应该在概念中的“方法区”里；但现在在JDK7的HotSpot VM里它实质上也被放在Java heap里了。可以把这种特例看作是HotSpot VM把方法区的一部分数据也放在Java heap里了。
前面也已经提过，在JDK7之前的Oracle/Sun JDK里的HotSpot VM把静态变量存在InstanceKlass末尾，存在PermGen里。那个时候的PermGen更接近于完整的方法区一些。</strong>
关于PermGen移除计划的一些零星笔记可以参考<a href="http://rednaxelafx.iteye.com/blog/905273" target="_blank">我以前一老帖</a>。
再接再厉，用revptrs看看第二个Test2实例有谁引用：
Hsdb代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>hsdb&gt; revptrs 0x00000000fa49a730  </li>
<li>Oop for Test @ 0x00000000fa49a720  </li>
</ol>
<p>hsdb&gt; revptrs 0x00000000fa49a730</p>
<p>Oop for Test @ 0x00000000fa49a720
找到了一个Test实例。同样用whatis来看看它在哪儿：
Hsdb代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>hsdb&gt; whatis 0x00000000fa49a720  </li>
<li>Address 0x00000000fa49a720: In thread-local allocation buffer for thread &quot;main&quot; (1)  [0x00000000fa48f490,0x00000000fa49a750,0x00000000fa49d118)  </li>
<li></li>
</ol>
<p>hsdb&gt; whatis 0x00000000fa49a720</p>
<p>Address 0x00000000fa49a720: In thread-local allocation buffer for thread &quot;main&quot; (1)  [0x00000000fa48f490,0x00000000fa49a750,0x00000000fa49d118)</p>
<p>果然也在main线程的TLAB里。
然后看这个Test实例的内容：
Hsdb代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>hsdb&gt; inspect 0x00000000fa49a720  </li>
<li>instance of Oop for Test @ 0x00000000fa49a720 @ 0x00000000fa49a720 (size = 16)  </li>
<li>&lt;<Reverse pointers>&gt;:   </li>
<li>_mark: 1  </li>
<li>t2: Oop for Test2 @ 0x00000000fa49a730 Oop for Test2 @ 0x00000000fa49a730  </li>
</ol>
<p>hsdb&gt; inspect 0x00000000fa49a720</p>
<p>instance of Oop for Test @ 0x00000000fa49a720 @ 0x00000000fa49a720 (size = 16)
&lt;<Reverse pointers>&gt;:</p>
<p>_mark: 1
t2: Oop for Test2 @ 0x00000000fa49a730 Oop for Test2 @ 0x00000000fa49a730
可以看到这个Test实例里有个成员字段t2，指向了第二个Test2实例。
<strong>于是t2也找到了！在Java堆里，作为Test的实例的成员字段存在。</strong>
那么赶紧试试用revptrs命令看第三个Test2实例：
Hsdb代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>hsdb&gt; revptrs 0x00000000fa49a740  </li>
<li>null  </li>
</ol>
<p>hsdb&gt; revptrs 0x00000000fa49a740</p>
<p>null
啥？没找到？！SA这也太弱小了吧。明明就在那里…
回头我会做个补丁让新版HotSpot VM的SA能处理这种情况。
这个时候的HSDB界面全貌：
<img src="&quot;点击查看原始大小图片&quot;" alt="">
0x00000000fa49a740看起来有没有点眼熟？
回到前面打开的Stack Memory窗口看，仔细看会发现那个窗口里正好就有0x00000000fa49a740这数字，位于0x000000000287f858地址上。
实际情况是，下面这张图里红色框住的部分就是main线程上Test.fn()的调用对应的栈帧：
<img src="&quot;点击查看原始大小图片&quot;" alt="">
如果图里看得不清楚的话，我再用文字重新写一遍（两道横线之间的是Test.fn()的栈帧内容，前后的则是别的东西）：
Memory代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>0x000000000287f7f0: 0x0000000002886298   </li>
<li>0x000000000287f7f8: 0x0000000002893ca5   </li>
<li>0x000000000287f800: 0x0000000002893ca5   </li>
<li><hr>
</li>
<li>Stack frame for Test.fn() @bci=8, line=6, pc=0x0000000002893ca5, methodOop=0x00000000fb077f78 (Interpreted frame)  </li>
<li>0x000000000287f808: 0x000000000287f808 expression stack bottom          &lt;- rsp  </li>
<li>0x000000000287f810: 0x00000000fb077f58 bytecode pointer    = 0x00000000fb077f50 (base) + 8 (bytecode index) in PermGen  </li>
<li>0x000000000287f818: 0x000000000287f860 pointer to locals  </li>
<li>0x000000000287f820: 0x00000000fb078360 constant pool cache = ConstantPoolCache for Test in PermGen  </li>
<li>0x000000000287f828: 0x0000000000000000 method data oop     = null  </li>
<li>0x000000000287f830: 0x00000000fb077f78 method oop          = Method for Test.fn()V in PermGen  </li>
<li>0x000000000287f838: 0x0000000000000000 last Java stack pointer (not set)  </li>
<li>0x000000000287f840: 0x000000000287f860 old stack pointer (saved rsp)  </li>
<li>0x000000000287f848: 0x000000000287f8a8 old frame pointer (saved rbp)    &lt;- rbp  </li>
<li>0x000000000287f850: 0x0000000002886298 return address      = in interpreter codelet &quot;return entry points&quot; [0x00000000028858b8, 0x00000000028876c0)  7688 bytes  </li>
<li>0x000000000287f858: 0x00000000fa49a740 local[1] &quot;t3&quot;       = Oop for Test2 in NewGen  </li>
<li>0x000000000287f860: 0x00000000fa49a720 local[0] &quot;this&quot;     = Oop for Test in NewGen  </li>
<li><hr>
</li>
<li>0x000000000287f868: 0x000000000287f868   </li>
<li>0x000000000287f870: 0x00000000fb077039   </li>
<li>0x000000000287f878: 0x000000000287f8c0   </li>
<li>0x000000000287f880: 0x00000000fb077350   </li>
<li>0x000000000287f888: 0x0000000000000000   </li>
<li>0x000000000287f890: 0x00000000fb077060   </li>
<li>0x000000000287f898: 0x000000000287f860   </li>
<li>0x000000000287f8a0: 0x000000000287f8c0   </li>
<li>0x000000000287f8a8: 0x000000000287f9a0   </li>
<li>0x000000000287f8b0: 0x000000000288062a   </li>
<li>0x000000000287f8b8: 0x00000000fa49a720   </li>
<li>0x000000000287f8c0: 0x00000000fa498ea8   </li>
<li>0x000000000287f8c8: 0x0000000000000000   </li>
<li>0x000000000287f8d0: 0x0000000000000000   </li>
<li>0x000000000287f8d8: 0x0000000000000000   </li>
</ol>
<p>0x000000000287f7f0: 0x0000000002886298</p>
<p>0x000000000287f7f8: 0x0000000002893ca5
0x000000000287f800: 0x0000000002893ca5</p>
<hr>
<p>Stack frame for Test.fn() @bci=8, line=6, pc=0x0000000002893ca5, methodOop=0x00000000fb077f78 (Interpreted frame)</p>
<p>0x000000000287f808: 0x000000000287f808 expression stack bottom          &lt;- rsp
0x000000000287f810: 0x00000000fb077f58 bytecode pointer    = 0x00000000fb077f50 (base) + 8 (bytecode index) in PermGen</p>
<p>0x000000000287f818: 0x000000000287f860 pointer to locals
0x000000000287f820: 0x00000000fb078360 constant pool cache = ConstantPoolCache for Test in PermGen</p>
<p>0x000000000287f828: 0x0000000000000000 method data oop     = null
0x000000000287f830: 0x00000000fb077f78 method oop          = Method for Test.fn()V in PermGen</p>
<p>0x000000000287f838: 0x0000000000000000 last Java stack pointer (not set)
0x000000000287f840: 0x000000000287f860 old stack pointer (saved rsp)</p>
<p>0x000000000287f848: 0x000000000287f8a8 old frame pointer (saved rbp)    &lt;- rbp
0x000000000287f850: 0x0000000002886298 return address      = in interpreter codelet &quot;return entry points&quot; [0x00000000028858b8, 0x00000000028876c0)  7688 bytes</p>
<p>0x000000000287f858: 0x00000000fa49a740 local[1] &quot;t3&quot;       = Oop for Test2 in NewGen
0x000000000287f860: 0x00000000fa49a720 local[0] &quot;this&quot;     = Oop for Test in NewGen</p>
<hr>
<p>0x000000000287f868: 0x000000000287f868</p>
<p>0x000000000287f870: 0x00000000fb077039
0x000000000287f878: 0x000000000287f8c0</p>
<p>0x000000000287f880: 0x00000000fb077350
0x000000000287f888: 0x0000000000000000</p>
<p>0x000000000287f890: 0x00000000fb077060
0x000000000287f898: 0x000000000287f860</p>
<p>0x000000000287f8a0: 0x000000000287f8c0
0x000000000287f8a8: 0x000000000287f9a0</p>
<p>0x000000000287f8b0: 0x000000000288062a
0x000000000287f8b8: 0x00000000fa49a720</p>
<p>0x000000000287f8c0: 0x00000000fa498ea8
0x000000000287f8c8: 0x0000000000000000</p>
<p>0x000000000287f8d0: 0x0000000000000000
0x000000000287f8d8: 0x0000000000000000
回顾<a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-2.html#jvms-2.6" target="_blank">JVM规范里所描述的Java栈帧结构</a>，包括：
[ 操作数栈  (operand stack)   ]</p>
<p>[ 栈帧信息  (dynamic linking) ]
[ 局部变量区 (local variables) ]
上张<a href="http://www.valleytalk.org/2011/07/28/java-%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%EF%BC%8C%E5%8A%A0%E8%BD%BD-%E5%92%8C-%E6%89%A7%E8%A1%8C/" target="_blank">我以前做的投影稿</a>里的图：
<img src="" alt="">
再跟HotSpot VM的解释器所使用的栈帧布局对比看看，是不是正好能对应上？局部变量区（locals）有了，VM所需的栈帧信息也有了；执行到这个位置operand stack正好是空的所以看不到它。
（HotSpot VM里把operand stack叫做expression stack。这是因为operand stack通常只在表达式求值过程中才有内容）
<strong>从Test.fn()的栈帧中我们可以看到t3变量就在locals[1]的位置上。t3变量也找到了！大功告成！</strong>
栈帧信息里具体都是些啥，以后有机会再展开讲吧。
都看到这里了，干脆把main方法的栈帧也如法炮制分析一下。先上图：
<img src="&quot;点击查看原始大小图片&quot;" alt="">
然后再用文字写一次：
Memory代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a></p>
<ol>
<li>0x000000000287f7f0: 0x0000000002886298   </li>
<li>0x000000000287f7f8: 0x0000000002893ca5   </li>
<li>0x000000000287f800: 0x0000000002893ca5   </li>
<li>0x000000000287f808: 0x000000000287f808   </li>
<li>0x000000000287f810: 0x00000000fb077f58   </li>
<li>0x000000000287f818: 0x000000000287f860   </li>
<li>0x000000000287f820: 0x00000000fb078360   </li>
<li>0x000000000287f828: 0x0000000000000000   </li>
<li>0x000000000287f830: 0x00000000fb077f78   </li>
<li>0x000000000287f838: 0x0000000000000000   </li>
<li>0x000000000287f840: 0x000000000287f860   </li>
<li>0x000000000287f848: 0x000000000287f8a8   </li>
<li>0x000000000287f850: 0x0000000002886298   </li>
<li>0x000000000287f858: 0x00000000fa49a740   </li>
<li><hr>
</li>
<li>Stack frame for Main.main(java.lang.String[]) @bci=9, line=4, pc=0x0000000002886298, methodOop=0x00000000fb077060 (Interpreted frame)  </li>
<li>0x000000000287f860: 0x00000000fa49a720 expression stack[0] = Oop for Test in NewGen  </li>
<li>0x000000000287f868: 0x000000000287f868 expression stack bottom  </li>
<li>0x000000000287f870: 0x00000000fb077039 bytecode pointer    = 0x00000000fb077030 (base) + 9 (bytecode index) in PermGen  </li>
<li>0x000000000287f878: 0x000000000287f8c0 pointer to locals  </li>
<li>0x000000000287f880: 0x00000000fb077350 constant pool cache = ConstantPoolCache for Main in PermGen  </li>
<li>0x000000000287f888: 0x0000000000000000 method data oop     = null  </li>
<li>0x000000000287f890: 0x00000000fb077060 method oop          = Method for Main.main([Ljava/lang/String;)V in PermGen  </li>
<li>0x000000000287f898: 0x000000000287f860 last Java stack pointer  </li>
<li>0x000000000287f8a0: 0x000000000287f8c0 old stack pointer  </li>
<li>0x000000000287f8a8: 0x000000000287f9a0 old frame pointer  </li>
<li>0x000000000287f8b0: 0x000000000288062a return address      = in StubRoutines  </li>
<li>0x000000000287f8b8: 0x00000000fa49a720 local[1] &quot;test&quot;     = Oop for Test in NewGen  </li>
<li>0x000000000287f8c0: 0x00000000fa498ea8 local[0] &quot;args&quot;     = Oop for java.lang.String[] in NewGen  </li>
<li><hr>
</li>
<li>0x000000000287f8c8: 0x0000000000000000   </li>
<li>0x000000000287f8d0: 0x0000000000000000   </li>
<li>0x000000000287f8d8: 0x0000000000000000   </li>
</ol>
<p>0x000000000287f7f0: 0x0000000002886298</p>
<p>0x000000000287f7f8: 0x0000000002893ca5
0x000000000287f800: 0x0000000002893ca5</p>
<p>0x000000000287f808: 0x000000000287f808
0x000000000287f810: 0x00000000fb077f58</p>
<p>0x000000000287f818: 0x000000000287f860
0x000000000287f820: 0x00000000fb078360</p>
<p>0x000000000287f828: 0x0000000000000000
0x000000000287f830: 0x00000000fb077f78</p>
<p>0x000000000287f838: 0x0000000000000000
0x000000000287f840: 0x000000000287f860</p>
<p>0x000000000287f848: 0x000000000287f8a8
0x000000000287f850: 0x0000000002886298</p>
<h2 id="0x000000000287f858-0x00000000fa49a740">0x000000000287f858: 0x00000000fa49a740</h2>
<p>Stack frame for Main.main(java.lang.String[]) @bci=9, line=4, pc=0x0000000002886298, methodOop=0x00000000fb077060 (Interpreted frame)
0x000000000287f860: 0x00000000fa49a720 expression stack[0] = Oop for Test in NewGen</p>
<p>0x000000000287f868: 0x000000000287f868 expression stack bottom
0x000000000287f870: 0x00000000fb077039 bytecode pointer    = 0x00000000fb077030 (base) + 9 (bytecode index) in PermGen</p>
<p>0x000000000287f878: 0x000000000287f8c0 pointer to locals
0x000000000287f880: 0x00000000fb077350 constant pool cache = ConstantPoolCache for Main in PermGen</p>
<p>0x000000000287f888: 0x0000000000000000 method data oop     = null
0x000000000287f890: 0x00000000fb077060 method oop          = Method for Main.main([Ljava/lang/String;)V in PermGen</p>
<p>0x000000000287f898: 0x000000000287f860 last Java stack pointer
0x000000000287f8a0: 0x000000000287f8c0 old stack pointer</p>
<p>0x000000000287f8a8: 0x000000000287f9a0 old frame pointer
0x000000000287f8b0: 0x000000000288062a return address      = in StubRoutines</p>
<p>0x000000000287f8b8: 0x00000000fa49a720 local[1] &quot;test&quot;     = Oop for Test in NewGen
0x000000000287f8c0: 0x00000000fa498ea8 local[0] &quot;args&quot;     = Oop for java.lang.String[] in NewGen</p>
<hr>
<p>0x000000000287f8c8: 0x0000000000000000</p>
<p>0x000000000287f8d0: 0x0000000000000000
0x000000000287f8d8: 0x0000000000000000
main的栈帧的operand stack就不是空的了，有一个元素，用来传递参数给其调用的Test.fn()方法（作为“this”）。
仔细的同学可能发现了，0x000000000287f860这个地址前面不是说是调用Test.fn()产生的栈帧么？怎么这里又变成调用main()方法的栈帧的一部分了呢？
其实栈帧直接可以有重叠：（再上一张以前做的投影稿里的图）
<img src="&quot;点击查看原始大小图片&quot;" alt="">
这样可以减少传递参数所需的数据拷贝，也节省了空间。
回到HSDB，我们换个方式来把t3变量找出来。这里就需要编译Test.java时给的-g参数所生成的LocalVariableTable的信息了：
Hsdb代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a></p>
<ol>
<li>hsdb&gt; jseval &quot;ts = jvm.threads&quot;  </li>
<li>[Thread (address=0x00000000fa48fb38, name=Service Thread), Thread (address=0x00000000fa48fa18, name=C2 CompilerThread1), Thread (address=0x00000000fa48f8f8, name=C2 CompilerThread0), Thread (address=0x00000000fa49d178, name=JDWP Command Reader), Thread (address=0x00000000fa48f820, name=JDWP Event Helper Thread), Thread (address=0x00000000fa48f6d8, name=JDWP Transport Listener: dt_shmem), Thread (address=0x00000000fa48dc88, name=Attach Listener), Thread (address=0x00000000fa48db68, name=Signal Dispatcher), Thread (address=0x00000000fa405828, name=Finalizer), Thread (address=0x00000000fa4053a0, name=Reference Handler), Thread (address=0x00000000fa404860, name=main)]   </li>
<li>hsdb&gt; jseval &quot;t = ts[ts.length - 1]&quot;  </li>
<li>Thread (address=0x00000000fa404860, name=main)   </li>
<li>hsdb&gt; jseval &quot;fs = t.frames&quot;  </li>
<li>[Frame (method=Test.fn(), bci=8, line=6), Frame (method=Main.main(java.lang.String[]), bci=9, line=4)]   </li>
<li>hsdb&gt; jseval &quot;f0 = fs[0]&quot;  </li>
<li>Frame (method=Test.fn(), bci=8, line=6)   </li>
<li>hsdb&gt; jseval &quot;f1 = fs[1]&quot;  </li>
<li>Frame (method=Main.main(java.lang.String[]), bci=9, line=4)   </li>
<li>hsdb&gt; jseval &quot;f0.locals&quot;  </li>
<li>{t3=Object 0x00000000fa49a740}   </li>
<li>hsdb&gt;   </li>
</ol>
<p>hsdb&gt; jseval &quot;ts = jvm.threads&quot;</p>
<p>[Thread (address=0x00000000fa48fb38, name=Service Thread), Thread (address=0x00000000fa48fa18, name=C2 CompilerThread1), Thread (address=0x00000000fa48f8f8, name=C2 CompilerThread0), Thread (address=0x00000000fa49d178, name=JDWP Command Reader), Thread (address=0x00000000fa48f820, name=JDWP Event Helper Thread), Thread (address=0x00000000fa48f6d8, name=JDWP Transport Listener: dt_shmem), Thread (address=0x00000000fa48dc88, name=Attach Listener), Thread (address=0x00000000fa48db68, name=Signal Dispatcher), Thread (address=0x00000000fa405828, name=Finalizer), Thread (address=0x00000000fa4053a0, name=Reference Handler), Thread (address=0x00000000fa404860, name=main)]
hsdb&gt; jseval &quot;t = ts[ts.length - 1]&quot;</p>
<p>Thread (address=0x00000000fa404860, name=main)
hsdb&gt; jseval &quot;fs = t.frames&quot;</p>
<p>[Frame (method=Test.fn(), bci=8, line=6), Frame (method=Main.main(java.lang.String[]), bci=9, line=4)]
hsdb&gt; jseval &quot;f0 = fs[0]&quot;</p>
<p>Frame (method=Test.fn(), bci=8, line=6)
hsdb&gt; jseval &quot;f1 = fs[1]&quot;</p>
<p>Frame (method=Main.main(java.lang.String[]), bci=9, line=4)
hsdb&gt; jseval &quot;f0.locals&quot;</p>
<p>{t3=Object 0x00000000fa49a740}</p>
<h1 id="hsdb-">hsdb&gt;</h1>
<p>上面讲栈帧布局的时候出现了“bytecode pointer”字眼。既然之前被不少好奇的同学问过“JVM里字节码存在哪里”，这里就一并回答掉好了。
强调一点：“字节码”只是元数据的一部分。它只负责描述运行逻辑，而其它信息像是类型名、成员的个数、类型、名字等等都<strong>不是字节码</strong>。在Class文件里是如此，到运行时在JVM里仍然是如此。
HotSpot VM里有一套对象专门用来存放元数据，它们包括：</p>
<ul>
<li>Klass系对象。元数据的最主要入口。用于描述类型的总体信息</li>
<li>ConstantPool/ConstantPoolCache对象。每个InstanceKlass关联着一个ConstantPool，作为该类型的运行时常量池。这个常量池的结构跟Class文件里的常量池基本上是对应的。可以参考<a href="http://hllvm.group.iteye.com/group/topic/26412#post-187861" target="_blank">我以前的一个回帖</a>。ConstantPoolCache主要用于存储某些字节码指令所需的解析（resolve）好的常量项，例如给[get|put]static、[get|put]field、invoke[static|special|virtual|interface|dynamic]等指令对应的常量池项用。</li>
<li>Method对象，用来描述Java方法的总体信息，像是方法入口地址、调用/循环计数器等等</li>
<li>ConstMethod对象，记录着Java方法的不变的描述信息，包括方法名、方法的访问修饰符、<strong>字节码</strong>、行号表、局部变量表等等。注意了，字节码就嵌在这ConstMethod对象里面。</li>
<li>Symbol对象，对应Class文件常量池里的JVM_CONSTANT_Utf8类型的常量。有一个VM全局的SymbolTable管理着所有Symbol。Symbol由所有Java类所共享。</li>
<li>MethodData对象，记录着Java方法执行时的profile信息，例如某方法里的某个字节码之类是否从来没遇到过null，某个条件跳转是否总是走同一个分支，等等。这些信息在解释器（多层编译模式下也在低层的编译生成的代码里）收集，然后供给HotSpot Server Compiler用于做激进优化。
在PermGen移除前，上述元数据对象都在PermGen里，直接被GC管理着。
JDK8彻底移除PermGen后，这些对象被挪到GC堆外的一块叫做Metaspace的空间里做特殊管理，仍然间接的受GC管理。
介绍了背景，让我们回到HSDB里。前面不是说“bytecode pointer (bcp)”嘛，从背景介绍可以知道字节码存在ConstMethod对象里，那就让我们用Test.fn()栈帧里存的bcp来验证一下是否真的如此。
还是用whatis命令：
Hsdb代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a></li>
</ul>
<ol>
<li>hsdb&gt; whatis 0x00000000fb077f58  </li>
<li>Address 0x00000000fb077f58: In perm generation   perm [0x00000000fae00000,0x00000000fb078898,0x00000000fc2c0000) space capacity = 21757952, 11.90770160721009 used   </li>
</ol>
<p>hsdb&gt; whatis 0x00000000fb077f58</p>
<p>Address 0x00000000fb077f58: In perm generation   perm <a href="&quot;复制代码&quot;">0x00000000fae00000,0x00000000fb078898,0x00000000fc2c0000) space capacity = 21757952, 11.90770160721009 used
这地址确实在PermGen里了。那么inspect一下看看？
Hsdb代码 [<img src="" alt="复制代码"></a></p>
<ol>
<li>hsdb&gt; inspect 0x00000000fb077f58  </li>
<li>Error: sun.jvm.hotspot.debugger.UnalignedAddressException: 100011  </li>
</ol>
<p>hsdb&gt; inspect 0x00000000fb077f58</p>
<p>Error: sun.jvm.hotspot.debugger.UnalignedAddressException: 100011
呃，这样不行。inspect命令只能接受对象的起始地址，但字节码是嵌在ConstMethod对象中间的。
那换条路子。栈帧里还有method oop，指向该栈帧对应的Method对象。先从它入手：
Hsdb代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a></p>
<ol>
<li>hsdb&gt; inspect 0x00000000fb077f78  </li>
<li>instance of Method fn()V@0x00000000fb077f78 @ 0x00000000fb077f78 @ 0x00000000fb077f78 (size = 136)  </li>
<li>_mark: 1  </li>
<li>_constMethod: ConstMethod fn()V@0x00000000fb077f08 @ 0x00000000fb077f08 Oop @ 0x00000000fb077f08  </li>
<li>_constants: ConstantPool for Test @ 0x00000000fb077c68 Oop @ 0x00000000fb077c68  </li>
<li>_method_size: 17  </li>
<li>_max_stack: 2  </li>
<li>_max_locals: 2  </li>
<li>_size_of_parameters: 1  </li>
<li>_access_flags: 1  </li>
</ol>
<p>hsdb&gt; inspect 0x00000000fb077f78</p>
<p>instance of Method fn()V@0x00000000fb077f78 @ 0x00000000fb077f78 @ 0x00000000fb077f78 (size = 136)
_mark: 1</p>
<p>_constMethod: ConstMethod fn()V@0x00000000fb077f08 @ 0x00000000fb077f08 Oop @ 0x00000000fb077f08
_constants: ConstantPool for Test @ 0x00000000fb077c68 Oop @ 0x00000000fb077c68</p>
<p>_method_size: 17
_max_stack: 2</p>
<p>_max_locals: 2
_size_of_parameters: 1</p>
<p>_access_flags: 1
这样就找到了Test.fn()的Method对象，看到里面的_constMethod字段所指向的ConstMethod对象：
Hsdb代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a></p>
<ol>
<li>hsdb&gt; inspect 0x00000000fb077f08  </li>
<li>instance of ConstMethod fn()V@0x00000000fb077f08 @ 0x00000000fb077f08 @ 0x00000000fb077f08 (size = 112)  </li>
<li>_mark: 1  </li>
<li>_method: Method fn()V@0x00000000fb077f78 @ 0x00000000fb077f78 Oop @ 0x00000000fb077f78  </li>
<li>_exception_table: [I @ 0x00000000fae01d50 Oop for [I @ 0x00000000fae01d50  </li>
<li>_constMethod_size: 14  </li>
<li>_flags: 5  </li>
<li>_code_size: 9  </li>
<li>_name_index: 18  </li>
<li>_signature_index: 12  </li>
<li>_generic_signature_index: 0  </li>
<li>_code_size: 9  </li>
</ol>
<p>hsdb&gt; inspect 0x00000000fb077f08</p>
<p>instance of ConstMethod fn()V@0x00000000fb077f08 @ 0x00000000fb077f08 @ 0x00000000fb077f08 (size = 112)
_mark: 1</p>
<p>_method: Method fn()V@0x00000000fb077f78 @ 0x00000000fb077f78 Oop @ 0x00000000fb077f78
_exception_table: [I @ 0x00000000fae01d50 Oop for [I @ 0x00000000fae01d50</p>
<p>_constMethod_size: 14
_flags: 5</p>
<p>_code_size: 9
_name_index: 18</p>
<p>_signature_index: 12
_generic_signature_index: 0</p>
<p>_code_size: 9
这个ConstMethod对象从0x00000000fb077f08开始，长度112字节，也就是这个对象的范围是<a href="&quot;复制代码&quot;">0x00000000fb077f08, 0x00000000fb077f78)。bcp指向0x00000000fb077f58，确实在这个ConstMethod范围内。
通过经验可以知道实际上这里字节码的起始地址是0x00000000fb077f50。通过ConstMethod的_code_size字段可以知道该方法的字节码有9字节。找出来用mem命令看看内存里的数据：
Hsdb代码 [<img src="" alt="复制代码"></a></p>
<ol>
<li>hsdb&gt; mem 0x00000000fb077f50 2  </li>
<li>0x00000000fb077f50: 0x4c0001b7590200ca   </li>
<li>0x00000000fb077f58: 0x00000000004105b1   </li>
</ol>
<p>hsdb&gt; mem 0x00000000fb077f50 2</p>
<p>0x00000000fb077f50: 0x4c0001b7590200ca
0x00000000fb077f58: 0x00000000004105b1
这串数字是什么东西呢？展开来写清楚一点就是：
Memory代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a></p>
<ol>
<li>0x00000000fb077f50:  bb 00 02  new <cp index /#2> [Class Test2]  </li>
<li>0x00000000fb077f53:  59        dup  </li>
<li>0x00000000fb077f54:  b7 01 00  invokespecial <cp cache index /#1> [Method Test2.<init>()V]  </li>
<li>0x00000000fb077f57:  4c        astore_1  </li>
<li>0x00000000fb077f58:  b1        return  </li>
</ol>
<p>0x00000000fb077f50:  bb 00 02  new <cp index /#2> [Class Test2]</p>
<p>0x00000000fb077f53:  59        dup
0x00000000fb077f54:  b7 01 00  invokespecial <cp cache index /#1> [Method Test2.<init>()V]</p>
<p>0x00000000fb077f57:  4c        astore_1
0x00000000fb077f58:  b1        return
眼尖的同学要吐槽了：在0x00000000fb077f50的字节不是0xca么，怎么变成0xbb了？
其实0xca是JVM规范里有描述的一个可选字节码指令，<a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html#jvms-6.2" target="_blank">breakpoint</a>
Memory代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a></p>
<ol>
<li>0x00000000fb077f50:  ca 00 02  breakpoint // 00 02 not used  </li>
</ol>
<p>0x00000000fb077f50:  ca 00 02  breakpoint // 00 02 not used
还记得本文的实验一开始用了jdb在Test.fn()的入口设置了断点吗？这就是结果——入口处的字节码指令被改写为breakpoint了。当然，原本的字节码指令也还在别的地方存着，等断点解除之后这个位置就会被恢复成原本的0xbb指令。
把ConstMethod里存的字节码跟Class文件里存的比较一下看看。用<a href="http://docs.oracle.com/javase/7/docs/technotes/tools/windows/javap.html" target="_blank">javap</a>工具来看Class文件的内容：
Javap代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a></p>
<ol>
<li>public void fn();  </li>
<li>Code:  </li>
<li>stack=2, locals=2, args_size=1  </li>
<li>0:  bb 00 02  new           /#2                  // class Test2  </li>
<li>3:  59        dup  </li>
<li>4:  b7 00 03  invokespecial /#3                  // Method Test2.&quot;<init>&quot;:()V  </li>
<li>7:  4c        astore_1  </li>
<li><p>8:  b1        return  </p>
<p>public void fn();</p>
<p>Code:
stack=2, locals=2, args_size=1</p>
<p>0:  bb 00 02  new           /#2                  // class Test2
3:  59        dup</p>
<p>4:  b7 00 03  invokespecial /#3                  // Method Test2.&quot;<init>&quot;:()V
7:  4c        astore_1</p>
<p>8:  b1        return
几乎一模一样。唯一的不同也是个有趣的小细节：invokespecial的参数的常量池号码不一样了。HotSpot VM执行new指令的时候用的还是Class文件里的常量池号和字节序。而在执行invokespecial时，光是ConstantPool里的的常量项不够地方放解析（resolve）出来的信息，所以把这些信息放在ConstantPoolCache里，然后也把invokespecial指令里的参数改写过来，顺带变成了平台相关的字节序。
同样也看看Main.main()方法。内存内容：
Memory代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a></p>
</li>
<li><p>hsdb&gt; mem 0x00000000fb077030 2  </p>
</li>
<li>0x00000000fb077030: 0x4c0001b7590200bb   </li>
<li>0x00000000fb077038: 0x214103b10002b62b   </li>
</ol>
<p>hsdb&gt; mem 0x00000000fb077030 2</p>
<p>0x00000000fb077030: 0x4c0001b7590200bb
0x00000000fb077038: 0x214103b10002b62b
展开来注解：
Memory代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a></p>
<ol>
<li>0x00000000fb077030:  bb 00 02  new <cp index /#2> [Class Test]  </li>
<li>0x00000000fb077033:  59        dup  </li>
<li>0x00000000fb077034:  b7 01 00  invokespecial <cp cache index /#1> [Method Test.<init>()V]  </li>
<li>0x00000000fb077037:  4c        astore_1  </li>
<li>0x00000000fb077038:  2b        aload_1  </li>
<li>0x00000000fb077039:  b6 02 00  invokevirtual <cp cache index /#2> [Method Test.fn()V]  </li>
<li>0x00000000fb07703c:  b1        return  </li>
</ol>
<p>0x00000000fb077030:  bb 00 02  new <cp index /#2> [Class Test]</p>
<p>0x00000000fb077033:  59        dup
0x00000000fb077034:  b7 01 00  invokespecial <cp cache index /#1> [Method Test.<init>()V]</p>
<p>0x00000000fb077037:  4c        astore_1
0x00000000fb077038:  2b        aload_1</p>
<p>0x00000000fb077039:  b6 02 00  invokevirtual <cp cache index /#2> [Method Test.fn()V]
0x00000000fb07703c:  b1        return
对应的javap输出：
Javap代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a></p>
<ol>
<li>public static void main(java.lang.String[]);  </li>
<li>Code:  </li>
<li>stack=2, locals=2, args_size=1  </li>
<li>0:  bb 00 02  new           /#2                  // class Test  </li>
<li>3:  59        dup  </li>
<li>4:  b7 00 03  invokespecial /#3                  // Method Test.&quot;<init>&quot;:()V  </li>
<li>7:  4c        astore_1  </li>
<li>8:  2b        aload_1  </li>
<li>9:  b6 00 04  invokevirtual /#4                  // Method Test.fn:()V  </li>
<li><p>12:  b1        return  </p>
<p>public static void main(java.lang.String[]);</p>
<p>Code:
stack=2, locals=2, args_size=1</p>
<p>0:  bb 00 02  new           /#2                  // class Test
3:  59        dup</p>
<p>4:  b7 00 03  invokespecial /#3                  // Method Test.&quot;<init>&quot;:()V
7:  4c        astore_1</p>
<p>8:  2b        aload_1
9:  b6 00 04  invokevirtual /#4                  // Method Test.fn:()V</p>
<p>12:  b1        return
好，今天就写到这里吧～</p>
</li>
</ol>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/JVM/">JVM</a></li></span></span> | <span class="tags">Tagged <a href="/tags/JVM/" class="label label-primary">JVM</a><a href="/tags/Java&J2EE/" class="label label-success">Java&J2EE</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:42"datetime="2014-03-07 09:54:42"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-JVM--借HSDB来探索HotSpotVM的运行时数据/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-JVM--借HSDB来探索HotSpotVM的运行时数据" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--动态跟踪Java代码的执行状况工具--BTrace/">动态跟踪Java代码的执行状况工具</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:42.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--动态跟踪Java代码的执行状况工具--BTrace/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-java-btrace">动态跟踪Java代码的执行状况工具--BTrace</h1>
<h1 id="-bluedavy-blog-http-www-blogjava-net-bluedavy-"><a href="http://www.blogjava.net/BlueDavy/" target="_blank">BlueDavy之技术Blog</a></h1>
<p>理论不懂就实践，实践不会就学理论！</p>
<h2 id="-java-btrace-http-www-blogjava-net-bluedavy-archive-2009-10-10-297661-html-"><a href="http://www.blogjava.net/BlueDavy/archive/2009/10/10/297661.html" target="_blank">动态跟踪Java代码的执行状况工具--BTrace</a></h2>
<p>非常强烈的推荐下BTrace这个工具，用了后不得不说太强大了，BTrace简单来说，就是能在不改动当前程序的情况下，运行时的去监控Java程序的执行状况，例如可以做到内存状况的监控、方法调用的监控等等，官方网站上有非常多详细的例子，我不说太多，只在下面举一个简单的例子来说明它的作用，BTrace的User Guide请见：<a href="http://kenai.com/projects/btrace/pages/UserGuide" target="_blank"><a href="http://kenai.com/projects/btrace/pages/UserGuide">http://kenai.com/projects/btrace/pages/UserGuide</a></a>。
对于运行中的Java程序，尤其是出了问题的程序，会需要跟踪其执行状况，例如传入的参数是什么、执行了多少时间，返回的对象是什么，抛出了什么异常，传统的做法只能是把程序改一遍，加上一堆log，一个例子来展示下用BTrace的情况下，怎么来跟踪一个方法的执行时间：
@BTrace public class MethodResponseTime {</p>
<pre><code>@TLS private static long startTime;

@OnMethod(clazz=&quot;类名&quot;,method=&quot;方法名&quot;)
public static void onCall(){
    println(&quot;enter this method&quot;);
    startTime=timeMillis();
}

@OnMethod(clazz=&quot;类名&quot;,method=&quot;方法名&quot;,location=@Location(Kind.RETURN))
public static void onReturn(){
    println(&quot;method end!&quot;);
    println(strcat(&quot;Time taken ms&quot;,str(timeMillis()-startTime)));
}
</code></pre><p>}
用btrace执行上面的代码，就可以动态的监控任意的目前运行的Java程序中某类的某方法的执行时间，执行上面代码的方式如下（jdk 6+）：
btrace [pid] MethodResponseTime.class
还有例如获取调用参数、调用者的对象实例以及返回值等请参看User Guide。
btrace为了保持JVM运行的安全性，因此做了很多的限制，例如不能抛出异常、修改传入的参数的值、修改返回值等，基本是一个只读的动态分析代码运行状况的工具，但仍然是非常的有用，其实现机制是attach api + asm +  instrumentation。</p>
<p>posted on 2009-10-10 12:41 <a href="http://www.blogjava.net/BlueDavy/" target="_blank">BlueDavy</a> 阅读(11121) <a href="">评论(8)</a>  <a href="http://www.blogjava.net/BlueDavy/admin/EditPosts.aspx?postid=297661" target="_blank">编辑</a>  <a href="http://www.blogjava.net/BlueDavy/AddToFavorite.aspx?id=297661" target="_blank">收藏</a> 所属分类: <a href="http://www.blogjava.net/BlueDavy/category/1366.html" target="_blank">Java</a></p>
<p> <img src="" alt=""></p>
<p><a href=""></a> <a href=""></a></p>
<p>[</p>
<h3 id="-">评论</h3>
<p>]()</p>
<h3 id="-permalink-re-java-btrace-re-java-btrace-2009-10-10-14-02-argan-http-argan-javaeye-com-"><a href=""></a><a href="&quot;permalink: re: 动态跟踪Java代码的执行状况工具--BTrace&quot;">/#</a> <a href=""></a>re: 动态跟踪Java代码的执行状况工具--BTrace  2009-10-10 14:02  <a href="http://argan.javaeye.com/">argan</a></h3>
<p>不错，这个有点强悍的，使用一下先  <a href="">回复</a>  <a href="http://www.blogjava.net/comment?author=argan" title="查看该作者发表过的评论" target="_blank">更多评论</a> <a href=""></a>  <a href=""></a></p>
<h3 id="-permalink-re-java-btrace-re-java-btrace-2009-10-11-01-02-http-www-blogjava-net-unmi-"><a href="&quot;permalink: re: 动态跟踪Java代码的执行状况工具--BTrace&quot;">/#</a> <a href=""></a>re: 动态跟踪Java代码的执行状况工具--BTrace  2009-10-11 01:02  <a href="http://www.blogjava.net/Unmi/">隔叶黄莺</a></h3>
<p>收藏了，以后可能用得着。  <a href="">回复</a>  <a href="http://www.blogjava.net/comment?author=%e9%9a%94%e5%8f%b6%e9%bb%84%e8%8e%ba" title="查看该作者发表过的评论" target="_blank">更多评论</a> <a href=""></a>  <a href=""></a></p>
<h3 id="-permalink-re-java-btrace-re-java-btrace-2009-10-11-23-28-http-www-blogjava-net-youxia-"><a href="&quot;permalink: re: 动态跟踪Java代码的执行状况工具--BTrace[未登录]&quot;">/#</a> <a href=""></a>re: 动态跟踪Java代码的执行状况工具--BTrace[未登录]  2009-10-11 23:28  <a href="http://www.blogjava.net/youxia">海边沫沫</a></h3>
<p>要钱吗?  <a href="">回复</a>  <a href="http://www.blogjava.net/comment?author=%e6%b5%b7%e8%be%b9%e6%b2%ab%e6%b2%ab" title="查看该作者发表过的评论" target="_blank">更多评论</a> <a href=""></a>  <a href=""></a></p>
<h3 id="-permalink-re-java-btrace-re-java-btrace-2009-10-12-03-54-duguo-http-duguo-com-"><a href="&quot;permalink: re: 动态跟踪Java代码的执行状况工具--BTrace&quot;">/#</a> <a href=""></a>re: 动态跟踪Java代码的执行状况工具--BTrace  2009-10-12 03:54  <a href="http://duguo.com/">duguo</a></h3>
<p>试了一下trace Apache Felix 2.0.0, 已加载了的类不好使，抛出NullPointerException。  <a href="">回复</a>  <a href="http://www.blogjava.net/comment?author=duguo" title="查看该作者发表过的评论" target="_blank">更多评论</a> <a href=""></a>  <a href=""></a></p>
<h3 id="-permalink-re-java-btrace-re-java-btrace-2009-10-12-17-12-weager-http-www-blogjava-net-dongritengfei-"><a href="&quot;permalink: re: 动态跟踪Java代码的执行状况工具--BTrace&quot;">/#</a> <a href=""></a>re: 动态跟踪Java代码的执行状况工具--BTrace  2009-10-12 17:12  <a href="http://www.blogjava.net/dongritengfei/">weager</a></h3>
<p>貌似没有什么界面，还得用命令行啊~~~  <a href="">回复</a>  <a href="http://www.blogjava.net/comment?author=weager" title="查看该作者发表过的评论" target="_blank">更多评论</a> <a href=""></a>  <a href=""></a></p>
<h3 id="-permalink-re-java-btrace-re-java-btrace-2009-10-13-00-13-gengmao-"><a href="&quot;permalink: re: 动态跟踪Java代码的执行状况工具--BTrace&quot;">/#</a> <a href=""></a>re: 动态跟踪Java代码的执行状况工具--BTrace  2009-10-13 00:13  <a href="">gengmao</a></h3>
<p>visualvm有btrace的插件  <a href="">回复</a>  <a href="http://www.blogjava.net/comment?author=gengmao" title="查看该作者发表过的评论" target="_blank">更多评论</a> <a href=""></a>  <a href=""></a></p>
<h3 id="-permalink-re-java-btrace-re-java-btrace-2009-10-13-00-57-sswv-http-blog-linjian-org-"><a href="&quot;permalink: re: 动态跟踪Java代码的执行状况工具--BTrace&quot;">/#</a> <a href=""></a>re: 动态跟踪Java代码的执行状况工具--BTrace  2009-10-13 00:57  <a href="http://blog.linjian.org/">sswv</a></h3>
<p>林昊朋友，你好，
首先祝贺你的blog被ZDNet评为了“最受欢迎中国技术博客”之一。
不过你的照片……不知你弄错了还是ZDNet弄错了，是我的头像呵。
详情参考： <a href="http://blog.linjian.org/articles/my-photo-misused-again/" target="_blank"><a href="http://blog.linjian.org/articles/my-photo-misused-again/">http://blog.linjian.org/articles/my-photo-misused-again/</a></a>
有机会看看你写的书。我前不久也与博文视点合作过，是《我是一只IT小小鸟》的合作者之一。  <a href="">回复</a>  <a href="http://www.blogjava.net/comment?author=sswv" title="查看该作者发表过的评论" target="_blank">更多评论</a> <a href=""></a>  <a href=""></a></p>
<h3 id="-permalink-re-java-btrace-re-java-btrace-2009-10-13-08-13-bluedavy-http-www-blogjava-net-bluedavy-"><a href="&quot;permalink: re: 动态跟踪Java代码的执行状况工具--BTrace[未登录]&quot;">/#</a> <a href=""></a>re: 动态跟踪Java代码的执行状况工具--BTrace[未登录]<a href=""></a>  2009-10-13 08:13  <a href="http://www.blogjava.net/bluedavy" target="_blank">BlueDavy</a></h3>
<p>@sswv
...我并不知道ZDNET评选这件事情，我联系下他们吧，不好意思了，<IT小小鸟>可是现在相当火的书，非常恭喜。
  <a href="">回复</a>  <a href="http://www.blogjava.net/comment?author=BlueDavy" title="查看该作者发表过的评论" target="_blank">更多评论</a> <a href=""></a>  <a href=""></a>
<a href="http://www.blogjava.net/RequireRegister.aspx" target="_blank">新用户注册</a>  <a href="">刷新评论列表</a>  </p>
<p><a href=""></a> <a href="http://www.aliyun.com/cps/channel?channel_id=1306&amp;user=0&amp;lv=1">推荐购买云服务器（15%返利+最高千元奖金）</a>   <a href="http://www.cnblogs.com/" target="_blank">博客园</a>  <a href="http://q.cnblogs.com/" target="_blank">博问</a>  <a href="http://news.cnblogs.com/" target="_blank">IT新闻</a>  <a href="http://job.cnblogs.com/cate-java_programmer/" target="_blank">Java程序员招聘</a> 标题  请输入标题 姓名  请输入你的姓名 主页 请输入验证码 验证码 /*  <img src="http://www.blogjava.net/Modules/CaptchaImage/JpegImage.aspx?cacheid=20130727130706" alt=""> 内容(请不要发表任何与政治相关的内容) 请输入评论内容 Remember Me?   <a href="http://www.blogjava.net/login.aspx?ReturnURL=http://www.blogjava.net/BlueDavy/archive/2009/10/10/297661.html&amp;SourceURL=/BlueDavy/archive/2009/10/10/297661.html" target="_blank">登录</a>       [使用Ctrl+Enter键可以直接提交]      网站导航:</p>
<p><a href="http://www.cnblogs.com/" title="程序员的网上家园" target="_blank">博客园</a>   <a href="http://news.cnblogs.com/" target="_blank">IT新闻</a>   <a href="http://kb.cnblogs.com/" target="_blank">知识库</a>   <a href="http://www.cppblog.com/" target="_blank">C++博客</a>   <a href="http://job.cnblogs.com/" target="_blank">程序员招聘</a>   <a href="http://www.blogjava.net/BlueDavy/archive/2009/10/10/297661.html?opt=admin" target="_blank">管理</a> 相关文章:</p>
<ul>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2010/05/25/321796.html" target="_blank">关于《分布式Java应用：基础与实践》一书</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2010/04/30/319794.html" target="_blank">杭州程序员圆桌交流第二期视频</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2010/03/22/316148.html" target="_blank">第一次杭州程序员交流会总结</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2010/03/19/315989.html" target="_blank">杭州程序员圆桌交流第一期–并发编程PPT</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/12/03/304597.html" target="_blank">GCLogViewer(tool to visualize gc log) V0.2 Release</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/11/25/303662.html" target="_blank">Simple Scala actor Vs java Thread Vs Kilim Test</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/11/06/301448.html" target="_blank">《构建高性能的大型分布式Java应用》目录&amp;试读样章</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/10/10/297661.html" target="_blank">动态跟踪Java代码的执行状况工具--BTrace</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/10/09/297562.html" target="_blank">GC策略的调优</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/08/06/290003.html" target="_blank">Hessian 3.2.0的两个bug</a><br>Powered by: <a href="http://www.blogjava.net/" target="_blank">BlogJava</a> Copyright © BlueDavy<h3 id="-">公告</h3>
</li>
</ul>
<p><a href="http://www.douban.com/subject/3843896/" target="_blank"><img src="" alt=""></a> 
<a href="http://china.osgiusers.org/" target="_blank"><img src="" alt=""></a>
<a href="http://feed.feedsky.com/bluedavy" title="BlogJava-BlueDavy之技术Blog" target="_blank"><img src="" alt=""></a> <a href="http://feed.feedsky.com/bluedavy" target="_blank"><img src="" alt="feedsky"></a>
<a href="http://www.zhuaxia.com/add_channel.php?url=http://feed.feedsky.com/bluedavy" target="_blank"><img src="" alt="抓虾"></a>
<a href="http://fusion.google.com/add?feedurl=http://feed.feedsky.com/bluedavy" target="_blank"><img src="" alt="google reader"></a>
<a href="http://www.xianguo.com/subscribe.php?url=http://feed.feedsky.com/bluedavy" target="_blank"><img src="" alt="鲜果"></a></p>
<h3 id="-">导航</h3>
<ul>
<li><a href="http://www.blogjava.net/" target="_blank">BlogJava</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/" target="_blank">首页</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/admin/EditPosts.aspx?opt=1" target="_blank">新随笔</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/contact.aspx?id=1" target="_blank">联系</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/rss" target="_blank">聚合</a><a href="http://www.blogjava.net/BlueDavy/rss" target="_blank"><img src="" alt=""></a></li>
<li><a href="http://www.blogjava.net/BlueDavy/admin/EditPosts.aspx" target="_blank">管理</a>
<a href="&quot;转到上一个月&quot;">&lt;</a>2009年10月<a href="&quot;转到下一个月&quot;">&gt;</a>日一二三四五六2728293012345678<a href="http://www.blogjava.net/BlueDavy/archive/2009/10/09.html" target="_blank">9</a><a href="http://www.blogjava.net/BlueDavy/archive/2009/10/10.html" target="_blank">10</a>1112131415161718192021222324252627282930311234567</li>
</ul>
<h3 id="-">统计</h3>
<ul>
<li>随笔 - 294</li>
<li>文章 - 2</li>
<li>评论 - 2068</li>
<li>引用 - 1</li>
</ul>
<h3 id="-">随笔分类</h3>
<ul>
<li><a href="http://www.blogjava.net/BlueDavy/category/10609.html" target="_blank">@RIAWork(10)</a> <a href="http://www.blogjava.net/BlueDavy/category/10609.html/rss" title="Subscribe to @RIAWork(10)" target="_blank">(rss)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/category/32839.html" target="_blank">Internet(20)</a> <a href="http://www.blogjava.net/BlueDavy/category/32839.html/rss" title="Subscribe to Internet(20)" target="_blank">(rss)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/category/1366.html" target="_blank">Java(82)</a> <a href="http://www.blogjava.net/BlueDavy/category/1366.html/rss" title="Subscribe to Java(82)" target="_blank">(rss)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/category/8127.html" target="_blank">Javascript(7)</a> <a href="http://www.blogjava.net/BlueDavy/category/8127.html/rss" title="Subscribe to Javascript(7)" target="_blank">(rss)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/category/18356.html" target="_blank">OSGi、SOA、SCA(81)</a> <a href="http://www.blogjava.net/BlueDavy/category/18356.html/rss" title="Subscribe to OSGi、SOA、SCA(81)" target="_blank">(rss)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/category/1514.html" target="_blank">Plugin Architecture(10)</a> <a href="http://www.blogjava.net/BlueDavy/category/1514.html/rss" title="Subscribe to Plugin Architecture(10)" target="_blank">(rss)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/category/1513.html" target="_blank">Workflow(4)</a> <a href="http://www.blogjava.net/BlueDavy/category/1513.html/rss" title="Subscribe to Workflow(4)" target="_blank">(rss)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/category/11559.html" target="_blank">业界随想(28)</a> <a href="http://www.blogjava.net/BlueDavy/category/11559.html/rss" title="Subscribe to 业界随想(28)" target="_blank">(rss)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/category/22527.html" target="_blank">数据集成(8)</a> <a href="http://www.blogjava.net/BlueDavy/category/22527.html/rss" title="Subscribe to 数据集成(8)" target="_blank">(rss)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/category/1911.html" target="_blank">系统设计(38)</a> <a href="http://www.blogjava.net/BlueDavy/category/1911.html/rss" title="Subscribe to 系统设计(38)" target="_blank">(rss)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/category/1367.html" target="_blank">软件工程(22)</a> <a href="http://www.blogjava.net/BlueDavy/category/1367.html/rss" title="Subscribe to 软件工程(22)" target="_blank">(rss)</a></li>
</ul>
<h3 id="-">随笔档案</h3>
<ul>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2010/05.html" target="_blank">2010年5月 (3)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2010/04.html" target="_blank">2010年4月 (4)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2010/03.html" target="_blank">2010年3月 (3)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2010/02.html" target="_blank">2010年2月 (1)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2010/01.html" target="_blank">2010年1月 (2)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/12.html" target="_blank">2009年12月 (1)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/11.html" target="_blank">2009年11月 (3)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/10.html" target="_blank">2009年10月 (2)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/09.html" target="_blank">2009年9月 (2)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/08.html" target="_blank">2009年8月 (2)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/07.html" target="_blank">2009年7月 (3)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/06.html" target="_blank">2009年6月 (1)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/05.html" target="_blank">2009年5月 (4)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/04.html" target="_blank">2009年4月 (5)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/03.html" target="_blank">2009年3月 (5)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/01.html" target="_blank">2009年1月 (1)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2008/11.html" target="_blank">2008年11月 (3)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2008/10.html" target="_blank">2008年10月 (1)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2008/09.html" target="_blank">2008年9月 (2)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2008/08.html" target="_blank">2008年8月 (1)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2008/07.html" target="_blank">2008年7月 (4)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2008/06.html" target="_blank">2008年6月 (4)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2008/05.html" target="_blank">2008年5月 (3)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2008/04.html" target="_blank">2008年4月 (1)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2008/03.html" target="_blank">2008年3月 (3)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2008/02.html" target="_blank">2008年2月 (1)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2008/01.html" target="_blank">2008年1月 (10)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2007/12.html" target="_blank">2007年12月 (2)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2007/11.html" target="_blank">2007年11月 (2)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2007/10.html" target="_blank">2007年10月 (6)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2007/09.html" target="_blank">2007年9月 (2)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2007/08.html" target="_blank">2007年8月 (4)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2007/07.html" target="_blank">2007年7月 (5)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2007/06.html" target="_blank">2007年6月 (2)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2007/05.html" target="_blank">2007年5月 (4)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2007/04.html" target="_blank">2007年4月 (2)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2007/03.html" target="_blank">2007年3月 (2)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2007/02.html" target="_blank">2007年2月 (2)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2007/01.html" target="_blank">2007年1月 (1)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/12.html" target="_blank">2006年12月 (6)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/11.html" target="_blank">2006年11月 (5)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/10.html" target="_blank">2006年10月 (8)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/09.html" target="_blank">2006年9月 (13)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/08.html" target="_blank">2006年8月 (15)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/07.html" target="_blank">2006年7月 (3)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/06.html" target="_blank">2006年6月 (7)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/05.html" target="_blank">2006年5月 (9)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/04.html" target="_blank">2006年4月 (12)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/03.html" target="_blank">2006年3月 (13)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/02.html" target="_blank">2006年2月 (9)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/01.html" target="_blank">2006年1月 (14)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2005/12.html" target="_blank">2005年12月 (11)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2005/11.html" target="_blank">2005年11月 (14)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2005/10.html" target="_blank">2005年10月 (9)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2005/09.html" target="_blank">2005年9月 (10)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2005/08.html" target="_blank">2005年8月 (5)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2005/07.html" target="_blank">2005年7月 (9)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2005/06.html" target="_blank">2005年6月 (9)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2005/05.html" target="_blank">2005年5月 (2)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2005/02.html" target="_blank">2005年2月 (1)</a></li>
</ul>
<h3 id="-">文章档案</h3>
<ul>
<li><a href="http://www.blogjava.net/BlueDavy/archives/2005/05.html" target="_blank">2005年5月 (2)</a></li>
</ul>
<h3 id="blogger-s">Blogger&#39;s</h3>
<ul>
<li><a href="http://www.dbanotes.net/" target="_blank">DBANotes</a></li>
<li>大名鼎鼎了，勿需多说</li>
<li><a href="http://www.esbzone.net/" target="_blank">ESBZone</a> <a href="http://www.esbzone.net/feed" title="Subscribe to ESBZone" target="_blank">(rss)</a></li>
<li>SOA实战者，强烈推荐</li>
<li><a href="http://kenwublog.com/" target="_blank">kenwu&#39;s blog[推荐]</a> <a href="http://feed.kenwublog.com/" title="Subscribe to kenwu&#39;s blog[推荐]" target="_blank">(rss)</a></li>
<li>Java底层和JVM的很多文章，强烈推荐。</li>
<li><a href="http://dreamhead.blogbus.com/" target="_blank">梦想风暴</a></li>
<li><a href="http://www.blogjava.net/cenwenchu/" target="_blank">西湖边的穷秀才</a></li>
</ul>
<h3 id="-">搜索</h3>
<p>*</p>
<ul>
<li></li>
</ul>
<h3 id="-http-www-blogjava-net-bluedavy-commentsrss-aspx-">最新评论 <a href="http://www.blogjava.net/BlueDavy/CommentsRSS.aspx" target="_blank"><img src="" alt=""></a></h3>
<ul>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2013/07/19/321796.html#401750" target="_blank">1. re: 关于《分布式Java应用：基础与实践》一书</a></li>
<li>博主 大神啊 这个博客很久没有更新了</li>
<li>--1836567962@qq.com</li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2013/07/11/267970.html#401444" target="_blank">2. re: 网站架构相关PPT、文章整理（更新于2009-7-15）</a></li>
<li>这个文章很有用，收藏</li>
<li>--度哥网</li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2013/05/28/267968.html#399877" target="_blank">3. re: OSGi Opendoc &amp; Book</a></li>
<li>评论内容较长,点击标题查看</li>
<li>--stono</li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2013/05/28/267968.html#399865" target="_blank">4. re: OSGi Opendoc &amp; Book</a></li>
<li>我再看《OSGi》原理与最佳实践，可是源码没有办法下载呀；
有没有什么办法呢？</li>
<li>--stono</li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2013/05/27/321796.html#399801" target="_blank">5. re: 关于《分布式Java应用：基础与实践》一书</a></li>
<li>在这篇blog中放置了我收集的一些网站架构相关的PPT和文章</li>
<li>--色都</li>
</ul>
<h3 id="-">阅读排行榜</h3>
<ul>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2008/09/03/226749.html" target="_blank">1. 大型网站架构演变和知识体系(57638)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/04/28/267970.html" target="_blank">2. 网站架构相关PPT、文章整理（更新于2009-7-15）(38732)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/03/27/37582.html" target="_blank">3. Hibernate实践(31780)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2005/06/13/6037.html" target="_blank">4. 系统设计说明书(架构、概要、详细)目录结构(24258)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/08/25/65741.html" target="_blank">5. 发布《OSGi实战》正式版(17725)</a></li>
</ul>
<h3 id="-">评论排行榜</h3>
<ul>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2008/09/03/226749.html" target="_blank">1. 大型网站架构演变和知识体系(96)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2005/09/07/12340.html" target="_blank">2. 漫谈CMS(88)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/04/28/267970.html" target="_blank">3. 网站架构相关PPT、文章整理（更新于2009-7-15）(66)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2007/09/29/149631.html" target="_blank">4. 《OSGi进阶》预览版发布(59)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/08/25/65741.html" target="_blank">5. 发布《OSGi实战》正式版(54)</a></li>
</ul>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/JVM/">JVM</a></li></span></span> | <span class="tags">Tagged <a href="/tags/JVM/" class="label label-primary">JVM</a><a href="/tags/Java&J2EE/" class="label label-success">Java&J2EE</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:42"datetime="2014-03-07 09:54:42"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-JVM--动态跟踪Java代码的执行状况工具--BTrace/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-JVM--动态跟踪Java代码的执行状况工具--BTrace" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--JVM调优总结-Xms-Xmx-Xmn-Xss/">JVM调优总结 </a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:42.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--JVM调优总结-Xms-Xmx-Xmn-Xss/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="jvm-xms-xmx-xmn-xss">JVM调优总结 -Xms -Xmx -Xmn -Xss</h1>
<ol>
<li><strong>堆大小设置
</strong>JVM 中最大堆大小有三方面限制：相关操作系统的数据模型（32-bt还是64-bit）限制；系统的可用虚拟内存限制；系统的可用物理内存限制。32位系统下，一般限制在1.5G~2G；64为操作系统对内存无限制。我在Windows Server 2003 系统，3.5G物理内存，JDK5.0下测试，最大可设置为1478m。
<strong>典型设置：</strong></li>
</ol>
<ul>
<li>java <strong>-Xmx3550m -Xms3550m -Xmn2g</strong> <strong>-Xss128k</strong>
<strong>-**</strong>Xmx3550m<strong>：设置JVM最大可用内存为3550M。
</strong>-Xms3550m<strong>：设置JVM促使内存为3550m。此值可以设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存。
</strong>-Xmn2g<strong>：设置年轻代大小为2G。</strong>整个JVM内存大小=年轻代大小 + 年老代大小 + 持久代大小<strong>。持久代一般固定大小为64m，所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。
</strong>-Xss128k**：设置每个线程的堆栈大小。JDK5.0以后每个线程堆栈大小为1M，以前每个线程堆栈大小为256K。更具应用的线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。</li>
<li>java -Xmx3550m -Xms3550m -Xss128k <strong>-XX:NewRatio=4 -XX:SurvivorRatio=4 -XX:MaxPermSize=16m -XX:MaxTenuringThreshold=0</strong>
<strong>-XX:NewRatio=4</strong>:设置年轻代（包括Eden和两个Survivor区）与年老代的比值（除去持久代）。设置为4，则年轻代与年老代所占比值为1：4，年轻代占整个堆栈的1/5
<strong>-XX:SurvivorRatio=4</strong>：设置年轻代中Eden区与Survivor区的大小比值。设置为4，则两个Survivor区与一个Eden区的比值为2:4，一个Survivor区占整个年轻代的1/6
<strong>-XX:MaxPermSize=16m</strong>:设置持久代大小为16m。
<strong>-XX:MaxTenuringThreshold=0</strong>：设置垃圾最大年龄。<strong>如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代</strong>。对于年老代比较多的应用，可以提高效率。<strong>如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间</strong>，增加在年轻代即被回收的概论。</li>
<li><strong>回收器选择
</strong>JVM给了三种选择：<strong>串行收集器、并行收集器、并发收集器</strong>，但是串行收集器只适用于小数据量的情况，所以这里的选择主要针对并行收集器和并发收集器。默认情况下，JDK5.0以前都是使用串行收集器，如果想使用其他收集器需要在启动时加入相应参数。JDK5.0以后，JVM会根据当前<a href="http://java.sun.com/j2se/1.5.0/docs/guide/vm/server-class.html" target="_blank">系统配置</a>进行判断。</li>
</ul>
<ol>
<li><strong>吞吐量优先</strong>的并行收集器
如上文所述，并行收集器主要以到达一定的吞吐量为目标，适用于科学技术和后台处理等。
<strong>典型配置</strong>：</li>
</ol>
<ul>
<li>java -Xmx3800m -Xms3800m -Xmn2g -Xss128k <strong>-XX:+UseParallelGC -XX:ParallelGCThreads=20</strong>
<strong>-XX:+UseParallelGC</strong>：选择垃圾收集器为并行收集器。<strong>此配置仅对年轻代有效。即上述配置下，年轻代使用并发收集，而年老代仍旧使用串行收集。
**</strong>-XX:ParallelGCThreads=20**：配置并行收集器的线程数，即：同时多少个线程一起进行垃圾回收。此值最好配置与处理器数目相等。</li>
<li>java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:ParallelGCThreads=20 <strong>-XX:+UseParallelOldGC
**</strong>-XX:+UseParallelOldGC**：配置年老代垃圾收集方式为并行收集。JDK6.0支持对年老代并行收集。</li>
<li>java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseParallelGC  <strong>-XX:MaxGCPauseMillis=100
**</strong>-XX:MaxGCPauseMillis=100<strong>**:</strong>设置每次年轻代垃圾回收的最长时间，如果无法满足此时间，JVM会自动调整年轻代大小，以满足此值。</li>
<li>java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseParallelGC  -XX:MaxGCPauseMillis=100 <strong>-XX:+UseAdaptiveSizePolicy
-XX:+UseAdaptiveSizePolicy</strong>：设置此选项后，并行收集器会自动选择年轻代区大小和相应的Survivor区比例，以达到目标系统规定的最低相应时间或者收集频率等，此值建议使用并行收集器时，一直打开。</li>
<li><p><strong>响应时间优先</strong>的并发收集器
如上文所述，并发收集器主要是保证系统的响应时间，减少垃圾收集时的停顿时间。适用于应用服务器、电信领域等。
<strong>典型配置</strong>：</p>
</li>
<li><p>java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:ParallelGCThreads=20 <strong>-XX:+UseConcMarkSweepGC -XX:+UseParNewGC
**</strong>-XX:+UseConcMarkSweepGC<strong>：设置年老代为并发收集。测试中配置这个以后，-XX:NewRatio=4的配置失效了，原因不明。所以，此时年轻代大小最好用-Xmn设置。
</strong>-XX:+UseParNewGC**:设置年轻代为并行收集。可与CMS收集同时使用。JDK5.0以上，JVM会根据系统配置自行设置，所以无需再设置此值。</p>
</li>
<li>java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseConcMarkSweepGC <strong>-XX:CMSFullGCsBeforeCompaction=5 -XX:+UseCMSCompactAtFullCollection</strong>
<strong>-XX:CMSFullGCsBeforeCompaction</strong>：由于并发收集器不对内存空间进行压缩、整理，所以运行一段时间以后会产生“碎片”，使得运行效率降低。此值设置运行多少次GC以后对内存空间进行压缩、整理。
<strong>-XX:+UseCMSCompactAtFullCollection</strong>：打开对年老代的压缩。可能会影响性能，但是可以消除碎片</li>
<li><p><strong>辅助信息
</strong>JVM提供了大量命令行参数，打印信息，供调试使用。主要有以下一些：</p>
</li>
<li><p><strong>-XX:+PrintGC
</strong>输出形式<strong>：[GC 118250K-&gt;113543K(130112K), 0.0094143 secs]</strong></p>
</li>
</ul>
<p><strong>                [Full GC 121376K-&gt;10414K(130112K), 0.0650971 secs]</strong></p>
<ul>
<li><strong>-XX:+PrintGCDetails
</strong>输出形式<strong>：[GC [DefNew: 8614K-&gt;781K(9088K), 0.0123035 secs] 118250K-&gt;113543K(130112K), 0.0124633 secs]</strong></li>
</ul>
<p><strong>                [GC [DefNew: 8614K-&gt;8614K(9088K), 0.0000665 secs][Tenured: 112761K-&gt;10414K(121024K), 0.0433488 secs] 121376K-&gt;10414K(130112K), 0.0436268 secs]</strong></p>
<ul>
<li><strong>-XX:+PrintGCTimeStamps</strong> -XX:+PrintGC：PrintGCTimeStamps可与上面两个混合使用
输出形式：<strong>11.851: [GC 98328K-&gt;93620K(130112K), 0.0082960 secs]
</strong></li>
<li><strong>-XX:+PrintGCApplicationConcurrentTime:</strong>打印每次垃圾回收前，程序未中断的执行时间。可与上面混合使用
输出形式：<strong>Application time: 0.5291524 seconds
</strong></li>
<li><strong>-XX:+PrintGCApplicationStoppedTime</strong>：打印垃圾回收期间程序暂停的时间。可与上面混合使用
输出形式：<strong>Total time for which application threads were stopped: 0.0468229 seconds
</strong></li>
<li><strong>-XX:PrintHeapAtGC</strong>:打印GC前后的详细堆栈信息
输出形式：
34.702: [GC {Heap before gc invocations=7:
def new generation   total 55296K, used 52568K [0x1ebd0000, 0x227d0000, 0x227d0000)
<strong>eden space 49152K,  99% used</strong> [0x1ebd0000, 0x21bce430, 0x21bd0000)
<strong>from space 6144K,  55% used</strong> [0x221d0000, 0x22527e10, 0x227d0000)
to   space 6144K,   0% used [0x21bd0000, 0x21bd0000, 0x221d0000)
tenured generation   total 69632K, used 2696K [0x227d0000, 0x26bd0000, 0x26bd0000)
<strong>the space 69632K,   3% used</strong> [0x227d0000, 0x22a720f8, 0x22a72200, 0x26bd0000)
compacting perm gen  total 8192K, used 2898K [0x26bd0000, 0x273d0000, 0x2abd0000)
 the space 8192K,  35% used [0x26bd0000, 0x26ea4ba8, 0x26ea4c00, 0x273d0000)
  ro space 8192K,  66% used [0x2abd0000, 0x2b12bcc0, 0x2b12be00, 0x2b3d0000)
  rw space 12288K,  46% used [0x2b3d0000, 0x2b972060, 0x2b972200, 0x2bfd0000)
34.735: [DefNew: 52568K-&gt;3433K(55296K), 0.0072126 secs] 55264K-&gt;6615K(124928K)<strong>Heap after gc invocations=8:
</strong> def new generation   total 55296K, used 3433K [0x1ebd0000, 0x227d0000, 0x227d0000)
<strong>eden space 49152K,   0% used</strong> [0x1ebd0000, 0x1ebd0000, 0x21bd0000)
from space 6144K,  55% used [0x21bd0000, 0x21f2a5e8, 0x221d0000)
to   space 6144K,   0% used [0x221d0000, 0x221d0000, 0x227d0000)
tenured generation   total 69632K, used 3182K [0x227d0000, 0x26bd0000, 0x26bd0000)
<strong>the space 69632K,   4% used</strong>[0x227d0000, 0x22aeb958, 0x22aeba00, 0x26bd0000)
compacting perm gen  total 8192K, used 2898K [0x26bd0000, 0x273d0000, 0x2abd0000)
 the space 8192K,  35% used [0x26bd0000, 0x26ea4ba8, 0x26ea4c00, 0x273d0000)
  ro space 8192K,  66% used [0x2abd0000, 0x2b12bcc0, 0x2b12be00, 0x2b3d0000)
  rw space 12288K,  46% used [0x2b3d0000, 0x2b972060, 0x2b972200, 0x2bfd0000)
}
, 0.0757599 secs]</li>
<li><strong>-Xloggc:filename</strong>:与上面几个配合使用，把相关日志信息记录到文件以便分析。</li>
<li><strong>常见配置汇总</strong></li>
</ul>
<ol>
<li>堆设置</li>
</ol>
<ul>
<li><strong>-Xms</strong>:初始堆大小</li>
<li><strong>-Xmx</strong>:最大堆大小</li>
<li><strong>-XX:NewSize=n</strong>:设置年轻代大小</li>
<li><strong>-XX:NewRatio=n:</strong>设置年轻代和年老代的比值。如:为3，表示年轻代与年老代比值为1：3，年轻代占整个年轻代年老代和的1/4</li>
<li><strong>-XX:SurvivorRatio=n</strong>:年轻代中Eden区与两个Survivor区的比值。注意Survivor区有两个。如：3，表示Eden：Survivor=3：2，一个Survivor区占整个年轻代的1/5</li>
<li><strong>-XX:MaxPermSize=n</strong>:设置持久代大小</li>
<li><p>收集器设置</p>
</li>
<li><p><strong>-XX:+UseSerialGC</strong>:设置串行收集器</p>
</li>
<li><strong>-XX:+UseParallelGC</strong>:设置并行收集器</li>
<li><strong>-XX:+UseParalledlOldGC</strong>:设置并行年老代收集器</li>
<li><strong>-XX:+UseConcMarkSweepGC</strong>:设置并发收集器</li>
<li><p>垃圾回收统计信息</p>
</li>
<li><p><strong>-XX:+PrintGC</strong></p>
</li>
<li><strong>-XX:+PrintGCDetails</strong></li>
<li><strong>-XX:+PrintGCTimeStamps</strong></li>
<li><strong>-Xloggc:filename</strong></li>
<li><p>并行收集器设置</p>
</li>
<li><p><strong>-XX:ParallelGCThreads=n</strong>:设置并行收集器收集时使用的CPU数。并行收集线程数。</p>
</li>
<li><strong>-XX:MaxGCPauseMillis=n</strong>:设置并行收集最大暂停时间</li>
<li><strong>-XX:GCTimeRatio=n</strong>:设置垃圾回收时间占程序运行时间的百分比。公式为1/(1+n)</li>
<li><p>并发收集器设置</p>
</li>
<li><p><strong>-XX:+CMSIncrementalMode</strong>:设置为增量模式。适用于单CPU情况。</p>
</li>
<li><strong>-XX:ParallelGCThreads=n</strong>:设置并发收集器年轻代收集方式为并行收集时，使用的CPU数。并行收集线程数。</li>
</ul>
<p><strong>四、调优总结</strong></p>
<ol>
<li><strong>年轻代大小选择</strong></li>
</ol>
<ul>
<li><strong>响应时间优先的应用</strong>：<strong>尽可能设大，直到接近系统的最低响应时间限制</strong>（根据实际情况选择）。在此种情况下，年轻代收集发生的频率也是最小的。同时，减少到达年老代的对象。</li>
<li><strong>吞吐量优先的应用</strong>：尽可能的设置大，可能到达Gbit的程度。因为对响应时间没有要求，垃圾收集可以并行进行，一般适合8CPU以上的应用。</li>
<li><p><strong>年老代大小选择</strong></p>
</li>
<li><p><strong>响应时间优先的应用</strong>：年老代使用并发收集器，所以其大小需要小心设置，一般要考虑<strong>并发会话率</strong>和<strong>会话持续时间</strong>等一些参数。如果堆设置小了，可以会造成内存碎片、高回收频率以及应用暂停而使用传统的标记清除方式；如果堆大了，则需要较长的收集时间。最优化的方案，一般需要参考以下数据获得：</p>
</li>
<li><p>并发垃圾收集信息</p>
</li>
<li>持久代并发收集次数</li>
<li>传统GC信息</li>
<li>花在年轻代和年老代回收上的时间比例
减少年轻代和年老代花费的时间，一般会提高应用的效率</li>
<li><strong>吞吐量优先的应用</strong>：一般吞吐量优先的应用都有一个很大的年轻代和一个较小的年老代。原因是，这样可以尽可能回收掉大部分短期对象，减少中期的对象，而年老代尽存放长期存活对象。</li>
<li><p><strong>较小堆引起的碎片问题
</strong>因为年老代的并发收集器使用标记、清除算法，所以不会对堆进行压缩。当收集器回收时，他会把相邻的空间进行合并，这样可以分配给较大的对象。但是，当堆空间较小时，运行一段时间以后，就会出现“碎片”，如果并发收集器找不到足够的空间，那么并发收集器将会停止，然后使用传统的标记、清除方式进行回收。如果出现“碎片”，可能需要进行如下配置：</p>
</li>
<li><p><strong>-XX:+UseCMSCompactAtFullCollection</strong>：使用并发收集器时，开启对年老代的压缩。</p>
</li>
<li><strong>-XX:CMSFullGCsBeforeCompaction=0</strong>：上面配置开启的情况下，这里设置多少次Full GC后，对年老代进行压缩</li>
</ul>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/JVM/">JVM</a></li></span></span> | <span class="tags">Tagged <a href="/tags/JVM/" class="label label-primary">JVM</a><a href="/tags/Java&J2EE/" class="label label-success">Java&J2EE</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:42"datetime="2014-03-07 09:54:42"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-JVM--JVM调优总结-Xms-Xmx-Xmn-Xss/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-JVM--JVM调优总结-Xms-Xmx-Xmn-Xss" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>





<ul id="pagination" class="pagination pagination-lg">
  <li><a class="extend prev" href="/page/45/">&laquo;</a></li><li><a class="page-number" href="/">1</a></li><li><a class="page-number" href="/page/2/">2</a></li><li><span class="space">&hellip;</span></li><li><a class="page-number" href="/page/43/">43</a></li><li><a class="page-number" href="/page/44/">44</a></li><li><a class="page-number" href="/page/45/">45</a></li><li class="active"><li><span class="page-number current">46</span></li><li><a class="page-number" href="/page/47/">47</a></li><li><a class="page-number" href="/page/48/">48</a></li><li><a class="page-number" href="/page/49/">49</a></li><li><span class="space">&hellip;</span></li></li><li><a class="page-number" href="/page/161/">161</a></li><li><a class="page-number" href="/page/162/">162</a></li><li><a class="extend next" href="/page/47/">&raquo;</a></li>
  <div class="clearfix"></div>
</ul></div><!--wapper-->
       </div><!-- ID main-col END -->
       <aside id="sidebar" class="alignright col-sx-6 col-sm-4 col-md-3 col-lg-3">
<div id="widget_search" class="widget panel panel-primary">
    <form action="//google.com/search" method="get" accept-charset="utf-8">
  <div class="input-group">
    <input class="form-control" id="searchbox" type="search" name="q" results="0" placeholder="search">
    <span class="input-group-btn">
      <button class="btn btn-default" type="submit">Go!</button>
    </span>
    <input type="hidden" name="q" value="site:itsolife.com">
  </div>
</form>
</div>

<div id="widget_category" class="widget panel panel-primary">
  <div class="panel-heading">category</div>  <div data-src='category' class='ajax_widgets'>正在加载...</div>
</div>

<div id="widget_recent_posts" class="widget panel panel-primary">
  <div class="panel-heading">recent posts</div>  <div data-src='recent_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_tagcloud" class="widget panel panel-primary">
  <div class="panel-heading">tagcloud</div>  <div data-src='tagcloud' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_latest_update_posts" class="widget panel panel-primary">
  <div class="panel-heading">最近更新</div>  <div data-src='latest_update_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_recent_comments" class="widget panel panel-primary">
  <div class="panel-heading">recent comments</div>  

<div class="list-group-item ds-recent-comments" data-num-items="6" data-show-avatars="1" data-show-time="1" data-show-title="1" data-show-admin="1" data-excerpt-length="50"></div>



</div>

</aside>
       <div class="clearfix"></div>
     </div><!-- row END -->
  </div>
  <footer id="footer" class="container">
  <div class="panel panel-info">
  <section id='footer_widget'></section>  <div class="panel-footer">
  <div id="site-info">
    <span class='author'>
  
  &copy; 2014 RobinChia
  
    &nbsp;&nbsp;</span>
  
  <span id='analytics-51la'></span><span id='analytics-google'>
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-48559895-1']);
  _gaq.push(['_trackPageview']);
  _js2load.push({src:('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'});
</script></span><span id='analytics-cnzz'>
<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_5774006'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s17.cnzz.com/stat.php%3Fid%3D5774006%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>
</span><span id='analytics-baidu'>
<script>
var _hmt = _hmt || [];
_js2load.push({src:"//hm.baidu.com/hm.js?1442f50724afc42380b51f097c43082c"});
</script>
</span>  </div>
  <div id="copyright">Site powered by <a href='http://zespia.tw/hexo/'><strong>hexo</strong></a>  update time: <em>2014-04-07 19:05:46</em></span></div>
</div>
<div class="clearfix"></div>


  </div>
  </footer>
  
        <script src="http://cdn.bootcss.com/jquery/1.10.2/jquery.min.js"></script>        
        <script src="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/js/bootstrap.min.js"></script>        
                
        <script src="http://cdn.bootcss.com/prettify/r298/prettify.min.js"></script>    <script type="text/javascript">
   var lang=["bsh", "c", "cc", "cpp", "cs", "csh", "cyc", "cv", "htm", "html",
    "java", "js", "m", "mxml", "perl", "pl", "pm", "py", "rb", "sh",
    "xhtml", "xml", "xsl"];
   var pretty_base='';
   $('script').each(function(){
	var c = $(this).attr('src');
	if (!c)
	    return;
	if (c.match(/(\/)?prettify(\.min)?\.js/i))
	{
	    var index = c.lastIndexOf('/');
	    if (index != -1)
		pretty_base = c.substr(0,index + 1);
	    return false;
	}
   })
   $('pre code').each(function(){
	var c = $(this).attr('class')
	if (!c)
	    return;
	c = c.match(/\s?(lang\-\w+)/i);
	if (c && lang.indexOf(c[1]) == -1)
	{
	    lang.push(c[1]);
	    $.getScript(pretty_base + c[1] + '.min.js');
	}
   })

    $(window).load(function(){
       $("pre").addClass("prettyprint");
       prettyPrint();
    })
</script>    
            <script type="text/javascript">
var duoshuoQuery = {short_name:"robinchia"};
_js2load.push({src:'http://static.duoshuo.com/embed.js',charset:'UTF-8'});
</script>
    
            <!--wumii_relatedItems-->
    
        <script src="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js"></script>    <script type="text/javascript">
(function($){
  $('.entry').each(function(i){
    $(this).find('img').each(function(){
      var alt = this.alt;

      if (alt){
        $(this).before('<span class="caption">' + alt + '</span>');
      }

      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox" rel="fancybox' + i + '" />');
    });
  });

  $('.fancybox').fancybox();
})(jQuery);
</script>    
        <script src="http://cdn.bootcss.com/mathjax/2.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>    <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>
    
<script type="text/javascript">
$('.ajax_widgets').each(function(){var src=$(this).attr('data-src');if(src)$(this).load('/widgets/'+src+'.html');});
$.each(_js2load,function(index,obj){loadjs(obj.src,obj.charset)});
</script>

<div id="scroll2top">
<img src="/scroll2top/arrow.png"/>
</div>
<script src="/scroll2top/scroll2top.min.js"></script>
<div id="winterland">
  <canvas></canvas>
</div>
<script src="/js/winterland.min.js"></script>

  </body>
</html>
