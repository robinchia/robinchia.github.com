
<!DOCTYPE HTML>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>The 46 Page | It so life</title>
<meta name="author" content="RobinChia">

<meta name="description" content="It so life">


<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<meta property="og:site_name" content="It so life"/>

<!--[if IE]><style>.testIE.IE{display:inline;}</style><![endif]-->
<!--[if lte IE 7]><link rel="stylesheet" href="/css/ie7.css" type="text/css"><![endif]-->
<!--[if (lt IE 9)&(gt IE 7)]><style>.testIE.IE8{display:inline;}</style><![endif]-->
<!--[if gt IE 8]><style>.testIE.IE9{display:inline;}</style><![endif]-->

<link href="/favicon.png" rel="icon">
<link rel="alternate" href="/atom.xml" title="It so life Feed" type="application/atom+xml">

<link rel="stylesheet" href="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/css/bootstrap.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/font-awesome/4.0.3/css/font-awesome.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/prettify/r298/prettify.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" type="text/css">
<link rel="stylesheet" href="/css/style.css" type="text/css">
<!--[if lt IE 9]>
   <style>article,aside,dialog,footer,header,section,footer,nav,figure,menu{display:block}</style>
   <script src="http://cdn.staticfile.org/html5shiv/r29/html5.min.js"></script>
   <script src="http://cdn.staticfile.org/respond.js/1.4.2/respond.min.js"></script>
<link href="http://cdn.staticfile.org/respond.js/1.4.2/respond-proxy.html" id="respond-proxy" rel="respond-proxy" />
<link href="/js/respond.proxy.gif" id="respond-redirect" rel="respond-redirect" />
<script src="/js/respond.proxy.js"></script>
   <script src="http://cdn.bootcss.com/selectivizr/1.0.2/selectivizr-min.js"></script>
<![endif]-->
<script type="text/javascript">
function loadjs(c,d){var a=document.createElement("script");a.async=!0;a.type="text/javascript";a.src=c;a.charset=d||"gbk";(document.getElementsByTagName("HEAD")[0]||document.getElementsByTagName("BODY")[0]).appendChild(a)};
var _protocol = (("https:" == document.location.protocol) ? " https://" : " http://");
var _js2load = [];
</script>

</head>
<body>
      <header id="header" class="container"><nav id="main-nav" class="navbar navbar-default navbar-fixed-top " role="navigation">
  <div class="container">
    <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
      <span class="sr-only">Toggle navigation</span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="/">It so life</a>
    </div>
    <div  class="collapse navbar-collapse">
      <ul  class="nav navbar-nav">
  
        <li><a href="/" title="Home">Home</a></li>      
        <li><a href="/about/" title="About">About</a></li>      
        <li><a href="/archives/" title="Archives">Archives</a></li>      
      <li class='dropdown'>
        <a class='dropdown-toggle' data-toggle='dropdown' href='#'>website<b class='caret'></b></a>
        <ul class='dropdown-menu pure-menu-selected'>
    
          <li><a href="//groups.google.com/forum/#!forum/pongba" title="TopLanguage">TopLanguage</a></li>    
          <li><a href="//itpub.net/" title="ITPub">ITPub</a></li>    
          <li><a href="//blog.jobbole.com/" title="Bole">Bole</a></li>    
          <li><a href="//nosql-database.org/" title="nosql">nosql</a></li>    
          <li><a href="//gitimmersion.googol.im/" title="Git">Git</a></li>    
        </ul>
      </li>
    
      </ul>
      <ul class="nav navbar-nav navbar-right">
      
        <li><a href="/atom.xml">RSS</a></li>
      
      
        <li><a href="https://twitter.com/robinchia">twitter</a></li>
      
      
      
      
        <li><a href="https://github.com/robinchia">github</a></li>
      
      </ul>
    </div>
  </div>
</nav>
<div class="clearfix"></div>
</header>
  <div id='content' class="container">
     <div class="page-header-wrapper">
      <!--[if lt IE 9]><div class="alert alert-warning alert-dismissable"><button type="button" class="close" data-dismiss="alert" aria-hidden="true">&times;</button><strong>提示:</strong>您的浏览器版本太低了,建议升级到 <strong><a href="http://windows.microsoft.com/zh-cn/internet-explorer/download-ie" title="IE9">IE9</a></strong> 以上,本站使用<a href="https://www.google.com/intl/zh-CN/chrome/">Chrome浏览器</a>可以获得最好的显示效果.</div><![endif]-->
      <div class="page-header"><h1 align="center"><big>It so life</big> </h1>
        <h5 align="center"><big>love as life</big></h5>
      </div>
     </div>
     <div class="row">
       <div id="main-col" class="alignleft col-sx-12 col-sm-8 col-md-9 col-lg-9">
      <section id='header_widget'></section>
          <div id="wrapper"><article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_设计类--浅谈Java开发中的设计模式/">浅谈Java开发中的设计模式</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:42.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_设计类--浅谈Java开发中的设计模式/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-java-">浅谈Java开发中的设计模式</h1>
<p>浅谈Java开发中的设计模式</p>
<p>1、工厂模式：客户类和工厂类分开。消费者任何时候需要某种产品，只需向工厂请求即可。消费者无须修改就可以接纳新产品。缺点是当产品修改时，工厂类也要做相应的修改。如：如何创建及如何向客户端提供。</p>
<p> 2、建造模式：将产品的内部表象和产品的生成过程分割开来，从而使一个建造过程生成具有不同的内部表象的产品对象。建造模式使得产品内部表象可以独立的变化，客户不必知道产品内部组成的细节。建造模式可以强制实行一种分步骤进行的建造过程。</p>
<p> 3、工厂方法模式：核心工厂类不再负责所有产品的创建，而是将具体创建的工作交给子类去做，成为一个抽象工厂角色，仅负责给出具体工厂类必须实现的接口，而不接触哪一个产品类应当被实例化这种细节。</p>
<p> 4、原始模型模式：通过给出一个原型对象来指明所要创建的对象的类型，然后用复制这个原型对象的方法创建出更多同类型的对象。原始模型模式允许动态的增加或减少产品类，产品类不需要非得有任何事先确定的等级结构，原始模型模式适用于任何的等级结构。缺点是每一个类都必须配备一个克隆方法。</p>
<p> 5、单例模式：单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例单例模式。单例模式只应在有真正的“单一实例”的需求时才可使用。</p>
<p> 6、适配器(变压器)模式：把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口原因不匹配而无法一起工作的两个类能够一起工作。适配类可以根据参数返还一个合适的实例给客户端。</p>
<p> 7、桥梁模式：将抽象化与实现化脱耦，使得二者可以独立的变化，也就是说将他们之间的强关联变成弱关联，也就是指在一个软件系统的抽象化和实现化之间使用组合/聚合关系而不是继承关系，从而使两者可以独立的变化。</p>
<p> 8、合成模式：合成模式将对象组织到树结构中，可以用来描述整体与部分的关系。合成模式就是一个处理对象的树结构的模式。合成模式把部分与整体的关系用树结构表示出来。合成模式使得客户端把一个个单独的成分对象和由他们复合而成的合成对象同等看待。</p>
<p> 9、装饰模式：装饰模式以对客户端透明的方式扩展对象的功能，是继承关系的一个替代方案，提供比继承更多的灵活性。动态给一个对象增加功能，这些功能可以再动态的撤消。增加由一些基本功能的排列组合而产生的非常大量的功能。</p>
<p> 10、门面模式：外部与一个子系统的通信必须通过一个统一的门面对象进行。门面模式提供一个高层次的接口，使得子系统更易于使用。每一个子系统只有一个门面类，而且此门面类只有一个实例，也就是说它是一个单例模式。但整个系统可以有多个门面类。</p>
<p> 11、享元模式：FLYWEIGHT在拳击比赛中指最轻量级。享元模式以共享的方式高效的支持大量的细粒度对象。享元模式能做到共享的关键是区分内蕴状态和外蕴状态。内蕴状态存储在享元内部，不会随环境的改变而有所不同。外蕴状态是随环境的改变而改变的。外蕴状态不能影响内蕴状态，它们是相互独立的。将可以共享的状态和不可以共享的状态从常规类中区分开来，将不可以共享的状态从类里剔除出去。客户端不可以直接创建被共享的对象，而应当使用一个工厂对象负责创建被共享的对象。享元模式大幅度的降低内存中对象的数量。</p>
<p> 12、代理模式：代理模式给某一个对象提供一个代理对象，并由代理对象控制对源对象的引用。代理就是一个人或一个机构代表另一个人或者一个机构采取行动。某些情况下，客户不想或者不能够直接引用一个对象，代理对象可以在客户和目标对象直接起到中介的作用。客户端分辨不出代理主题对象与真实主题对象。代理模式可以并不知道真正的被代理对象，而仅仅持有一个被代理对象的接口，这时候代理对象不能够创建被代理对象，被代理对象必须有系统的其他角色代为创建并传入。</p>
<p> 13、责任链模式：在责任链模式中，很多对象由每一个对象对其下家的引用而接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。客户并不知道链上的哪一个对象最终处理这个请求，系统可以在不影响客户端的情况下动态的重新组织链和分配责任。处理者有两个选择：承担责任或者把责任推给下家。一个请求可以最终不被任何接收端对象所接受。</p>
<p>14、命令模式：命令模式把一个请求或者操作封装到一个对象中。命令模式把发出命令的责任和执行命令的责任分割开，委派给不同的对象。命令模式允许请求的一方和发送的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否执行，何时被执行以及是怎么被执行的。系统支持命令的撤消。</p>
<p> 15、解释器模式：给定一个语言后，解释器模式可以定义出其文法的一种表示，并同时提供一个解释器。客户端可以使用这个解释器来解释这个语言中的句子。解释器模式将描述怎样在有了一个简单的文法后，使用模式设计解释这些语句。在解释器模式里面提到的语言是指任何解释器对象能够解释的任何组合。在解释器模式中需要定义一个代表文法的命令类的等级结构，也就是一系列的组合规则。每一个命令对象都有一个解释方法，代表对命令对象的解释。命令对象的等级结构中的对象的任何排列组合都是一个语言。</p>
<p> 16、迭代子模式：迭代子模式可以顺序访问一个聚集中的元素而不必暴露聚集的内部表象。多个对象聚在一起形成的总体称之为聚集，聚集对象是能够包容一组对象的容器对象。迭代子模式将迭代逻辑封装到一个独立的子对象中，从而与聚集本身隔开。迭代子模式简化了聚集的界面。每一个聚集对象都可以有一个或一个以上的迭代子对象，每一个迭代子的迭代状态可以是彼此独立的。迭代算法可以独立于聚集角色变化。</p>
<p> 17、调停者模式：调停者模式包装了一系列对象相互作用的方式，使得这些对象不必相互明显作用。从而使他们可以松散偶合。当某些对象之间的作用发生改变时，不会立即影响其他的一些对象之间的作用。保证这些作用可以彼此独立的变化。调停者模式将多对多的相互作用转化为一对多的相互作用。调停者模式将对象的行为和协作抽象化，把对象在小尺度的行为上与其他对象的相互作用分开处理。</p>
<p> 18、备忘录模式：备忘录对象是一个用来存储另外一个对象内部状态的快照的对象。备忘录模式的用意是在不破坏封装的条件下，将一个对象的状态捉住，并外部化，存储起来，从而可以在将来合适的时候把这个对象还原到存储起来的状态。</p>
<p> 19、观察者模式：观察者模式定义了一种一队多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使他们能够自动更新自己。</p>
<p> 20、状态模式：状态模式允许一个对象在其内部状态改变的时候改变行为。这个对象看上去象是改变了它的类一样。状态模式把所研究的对象的行为包装在不同的状态对象里，每一个状态对象都属于一个抽象状态类的一个子类。状态模式的意图是让一个对象在其内部状态改变的时候，其行为也随之改变。状态模式需要对每一个系统可能取得的状态创立一个状态类的子类。当系统的状态变化时，系统便改变所选的子类。</p>
<p> 21、策略模式：策略模式针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换。策略模式使得算法可以在不影响到客户端的情况下发生变化。策略模式把行为和环境分开。环境类负责维持和查询行为类，各种算法在具体的策略类中提供。由于算法和环境独立开来，算法的增减，修改都不会影响到环境和客户端。</p>
<p> 22、模板方法模式：模板方法模式准备一个抽象类，将部分逻辑以具体方法以及具体构造子的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现。先制定一个顶级逻辑框架，而将逻辑的细节留给具体的子类去实现。</p>
<p> 23、访问者模式：访问者模式的目的是封装一些施加于某种数据结构元素之上的操作。一旦这些操作需要修改的话，接受这个操作的数据结构可以保持不变。访问者模式适用于数据结构相对未定的系统，它把数据结构和作用于结构上的操作之间的耦合解脱开，使得操作集合可以相对自由的演化。访问者模式使得增加新的操作变的很容易，就是增加一个新的访问者类。访问者模式将有关的行为集中到一个访问者对象中，而不是分散到一个个的节点类中。当使用访问者模式时，要将尽可能多的对象浏览逻辑放在访问者类中，而不是放到它的子类中。访问者模式可以跨过几个类的等级结构访问属于不同的等级结构的成员</p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/Java_设计类/">Java_设计类</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/Java_设计类/" class="label label-success">Java_设计类</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:42"datetime="2014-03-07 09:54:42"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-Java_设计类--浅谈Java开发中的设计模式/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-Java_设计类--浅谈Java开发中的设计模式" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_设计类--软件设计文档二三事-善攻者动于九天之上-博客园/">软件设计文档二三事 </a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:42.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_设计类--软件设计文档二三事-善攻者动于九天之上-博客园/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-">软件设计文档二三事 - 善攻者动于九天之上 - 博客园</h1>
<p><img src="" alt=""> Saving Data...
正在保存数据...
正在儲存資料...</p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/Java_设计类/">Java_设计类</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/Java_设计类/" class="label label-success">Java_设计类</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:42"datetime="2014-03-07 09:54:42"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-Java_设计类--软件设计文档二三事-善攻者动于九天之上-博客园/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-Java_设计类--软件设计文档二三事-善攻者动于九天之上-博客园" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_设计类--概要设计文档模板/">概要设计文档模板</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:42.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_设计类--概要设计文档模板/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-">概要设计文档模板</h1>
<p><img src="" alt=""></p>
<p><a href="http://www.cnblogs.com/campo/" target="_blank">campo</a>
态度和细节决定一切 专注 务实 探索
随笔- 55  文章- 2  评论- 151 </p>
<p><a href="http://www.cnblogs.com/" target="_blank">博客园</a>  <a href="http://www.cnblogs.com/campo/" target="_blank">首页</a>  <a href="http://www.cnblogs.com/campo/admin/EditPosts.aspx?opt=1" target="_blank">新随笔</a>  <a href="http://space.cnblogs.com/msg/send/campo" target="_blank">联系</a>  <a href="http://www.cnblogs.com/campo/admin/EditPosts.aspx" target="_blank">管理</a>  <a href="http://www.cnblogs.com/campo/rss" target="_blank">订阅</a> <a href="http://www.cnblogs.com/campo/rss" target="_blank"><img src="" alt="订阅"></a></p>
<h1 id="-http-www-cnblogs-com-campo-archive-2007-08-24-867923-html-"><a href="http://www.cnblogs.com/campo/archive/2007/08/24/867923.html" target="_blank">概要设计文档模板</a></h1>
<p><strong><a href=""></a>概要设计说明书</strong> <strong>一． 引言</strong> 1． 编写目的 <img src="" alt="">500){this.resized=true;this.style.width=500;}&quot; resized=&quot;0&quot;&gt;从该阶段开发正式进入软件的实际开发阶段，本阶段完成系统的大致设计并明确系统的数据结构与软件结构。在软件设计阶段主要是把一个软件需求转化为软件表示的过程，这种表示只是描绘出软件的总的概貌。本概要设计说明书的目的就是进一步细化软件设计阶段得出的软件总体概貌，把它加工成在程序细节上非常接近于源程序的软件表示。 2． 项目背景（略） 3． 定义 <img src="" alt="">500){this.resized=true;this.style.width=500;}&quot; resized=&quot;0&quot;&gt;在该概要设计说明书中的专门术语有：
<img src="" alt="">500){this.resized=true;this.style.width=500;}&quot; resized=&quot;0&quot;&gt;<strong>总体设计<strong>**</strong></strong><img src="" alt="">500){this.resized=true;this.style.width=500;}&quot; resized=&quot;0&quot;&gt;接口设计**</p>
<p><strong><img src="" alt="">500){this.resized=true;this.style.width=500;}&quot; resized=&quot;0&quot;&gt;数据结构设计</strong></p>
<p><strong><img src="" alt="">500){this.resized=true;this.style.width=500;}&quot; resized=&quot;0&quot;&gt;运行设计</strong></p>
<p><strong><img src="" alt="">500){this.resized=true;this.style.width=500;}&quot; resized=&quot;0&quot;&gt;出错设计</strong>
<img src="" alt="">500){this.resized=true;this.style.width=500;}&quot; resized=&quot;0&quot;&gt;具体的概念与含义在文档后将会解释。 4． 参考资料 <img src="" alt="">500){this.resized=true;this.style.width=500;}&quot; resized=&quot;0&quot;&gt;&lt;软件工程概论&gt; 李存珠 李宣东 编著 南京大学<a href="http://www.mflw.com/search.aspx?keyword=%BC%C6%CB%E3%BB%FA&amp;where=title" title="电脑和计算机方面" target="_blank">计算机</a>系出版 2001年8月 <strong>二． 任务概述</strong> 1． 目标 <img src="" alt="">500){this.resized=true;this.style.width=500;}&quot; resized=&quot;0&quot;&gt;该阶段目的在于明确系统的数据结构和软件结构，此外总体设计还将给出内部软件和外部系统部件之间的接口定义，各个软件模块的功能说明，数据结构的细节以及具体的装配要求。 2． 运行环境 <img src="" alt="">500){this.resized=true;this.style.width=500;}&quot; resized=&quot;0&quot;&gt;软件基本运行环境为Windows环境。 3． 需求概述（略） 4． 条件与限制 <img src="" alt="">500){this.resized=true;this.style.width=500;}&quot; resized=&quot;0&quot;&gt;为了评价该设计阶段的设计表示的“优劣程度”，必须遵循以下几个准则：
<img src="" alt="">500){this.resized=true;this.style.width=500;}&quot; resized=&quot;0&quot;&gt;1.软件设计应当表现出层次结构，它应巧妙地利用各个软件部件之间的控制关系。
<img src="" alt="">500){this.resized=true;this.style.width=500;}&quot; resized=&quot;0&quot;&gt;2.设计应当是模块化的，即该软件应当从逻辑上被划分成多个部件，分别实现各种特定功能和子功能。
<img src="" alt="">500){this.resized=true;this.style.width=500;}&quot; resized=&quot;0&quot;&gt;3.设计最终应当给出具体的模块（例如子程序或过程），这些模块就具有独立的功能特性。
<img src="" alt="">500){this.resized=true;this.style.width=500;}&quot; resized=&quot;0&quot;&gt;4.应当应用在软件需求分析期间得到的信息，采取循环反复的方法来获得设计。 <strong>三． 总体设计</strong> 1．处理流程 <img src="" alt="">500){this.resized=true;this.style.width=500;}&quot; resized=&quot;0&quot;&gt;系统的总体处理数据流程如下图： <img src="" alt="">500){this.resized=true;this.style.width=500;}&quot; resized=&quot;0&quot;&gt; <strong>图八</strong><img src="" alt="">500){this.resized=true;this.style.width=500;}&quot; resized=&quot;0&quot;&gt;<strong>总体处理流程图</strong>   2．总体结构和模块外部设计 <img src="" alt="">500){this.resized=true;this.style.width=500;}&quot; resized=&quot;0&quot;&gt;模块是软件结构的基础，软件结构的好坏完全由模块的属性体现出来，把软件模块化的目的是为了降低软件复杂性，使软件设计，测试，调试，维护等工作变得简易，但随着模块数目的增加，通过接口连接这些模块的工作量也随之增加。从这些特性可得出如图九的一条总的成本（或工作量）曲线，在考虑模块化时，应尽量使模块数接近于图中的M，它使得研制成本最小，而且应尽量避免不足的模块化或超量。 <img src="" alt="">500){this.resized=true;this.style.width=500;}&quot; resized=&quot;0&quot;&gt; <strong>图九</strong><img src="" alt="">500){this.resized=true;this.style.width=500;}&quot; resized=&quot;0&quot;&gt;<strong>模块化与总体成本</strong> 3．功能分配 <img src="" alt="">500){this.resized=true;this.style.width=500;}&quot; resized=&quot;0&quot;&gt;从程序的结构中可以看出，学生的信息输入输出功能是由学生管理系统进行的。课程的信息输入输出是由课程管理系统进行的，而班级的信息流动则是班级管理系统进行的。 <strong>四． 接口设计</strong> <img src="" alt="">500){this.resized=true;this.style.width=500;}&quot; resized=&quot;0&quot;&gt;由于系统的各种内外部接口是通过借助数据库开发软件来实现的，是完全在数据库内部操作的，故在此略过此内容。 1． 外部接口（略） 2． 内部接口（略） <strong>五． 数据结构设计</strong> 1． 逻辑结构设计 <strong>student_Info 学生基本信息表</strong> <strong>列名</strong> <strong>数据类型</strong> <strong>可否为空</strong> <strong>说明</strong> student_ID INT(4) NOT NULL 学生学号（主键） student_Name CHAR(10) NULL 学生姓名 student_Gender CHAR(2) NULL 学生性别 born_Date DATETIME(8) NULL 出生日期 class_No INT(4) NULL 班号 tele_Number CHAR(10) NULL 联系电话 ru_Date DATETIME(8) NULL 入校时间 address VARCHAR(50) NULL 家庭住址 comment VARCHAR(200) NULL 注释   <strong>class_Info 班级信息表格</strong> <strong>列名</strong> <strong>数据类型</strong> <strong>可否为空</strong> <strong>说明</strong> class_No INT(4) NOT NULL 班号(主键) grade CHAR(10) NULL 年级 Director CHAR(10) NULL 班主任 Classroom_No CHAR(10) NULL 教室   <strong>course_Info 课程基本信息表</strong> <strong>列名</strong> <strong>数据类型</strong> <strong>可否为空</strong> <strong>说明</strong> course_No INT(4) NOT NULL 课程编号(主键) course_Name CHAR(10) NULL 课程名称 course_Type CHAR(10) NULL 课程类型 course_Des CHAR(50) NULL 课程描述   <strong>gradecourse_Info 年级课程设置表</strong> <strong>列名</strong> <strong>数据类型</strong> <strong>可否为空</strong> <strong>说明</strong> grade CHAR(10) NULL 年级 course_Name CHAR(10) NULL 课程名称   <strong>result_Info 学生成绩信息表</strong> <strong>列名</strong> <strong>数据类型</strong> <strong>可否为空</strong> <strong>说明</strong> exam_No CHAR(10) NOT NULL 考试编号 student_ID INT(4) NOT NULL 学生学号 student_Name CHAR(10) NULL 学生姓名 class_No INT(4) NULL 学生班号 course_Name CHAR(10) NULL 课程名称 result FLOAT(8) NULL 分数   <strong>user_Info 系统用户表</strong> <strong>列名</strong> <strong>数据类型</strong> <strong>可否为空</strong> <strong>说明</strong> user_ID CHAR(10) NOT NULL 用户名称（主键） user_PWD CHAR(10) NULL 用户密码 user_DES CHAR(10) NULL 用户描述 <strong>图十</strong><img src="" alt="">500){this.resized=true;this.style.width=500;}&quot; resized=&quot;0&quot;&gt;<strong>数据库逻辑结构图表</strong> 2． 物理结构设计 <img src="" alt="">500){this.resized=true;this.style.width=500;}&quot; resized=&quot;0&quot;&gt;系统的物理结构具体由数据库来设计与生成，此处略。 3． 数据结构与程序的关系 <img src="" alt="">500){this.resized=true;this.style.width=500;}&quot; resized=&quot;0&quot;&gt;系统的数据结构由标准数据库语言SQL生成。
<img src="" alt="">500){this.resized=true;this.style.width=500;}&quot; resized=&quot;0&quot;&gt;具体的例如创建系统用户表格 user_Info的程序用SQL表示就是：
<img src="" alt="">500){this.resized=true;this.style.width=500;}&quot; resized=&quot;0&quot;&gt;<strong>CREATE TABLE[dbo].<a href="![](">user_Info</a>500){this.resized=true;this.style.width=500;}&quot; resized=&quot;0&quot;&gt;<img src="" alt="">500){this.resized=true;this.style.width=500;}&quot; resized=&quot;0&quot;&gt;[user_ID]<a href="10">char</a>COLLATE Chinese_PRC_CI_AS NOT NULL,
<img src="" alt="">500){this.resized=true;this.style.width=500;}&quot; resized=&quot;0&quot;&gt;<img src="" alt="">500){this.resized=true;this.style.width=500;}&quot; resized=&quot;0&quot;&gt;[user_PWD]<a href="10">char</a>COLLATE Chinese_PRC_CI_AS NULL,
<img src="" alt="">500){this.resized=true;this.style.width=500;}&quot; resized=&quot;0&quot;&gt;<img src="" alt="">500){this.resized=true;this.style.width=500;}&quot; resized=&quot;0&quot;&gt;[user_Des]<a href="10">char</a>COLLATE Chinese_PRC_CI_AS NULL
<img src="" alt="">500){this.resized=true;this.style.width=500;}&quot; resized=&quot;0&quot;&gt;) ON [PRIMARY]</strong> <strong>六． 运行设计</strong> 1． 运行模块的组合 <strong><img src="" alt="">500){this.resized=true;this.style.width=500;}&quot; resized=&quot;0&quot;&gt;</strong>具体软件的运行模块组合为程序多窗口的运行环境，各个模块在软件运行过程中能较好的交换信息，处理数据。 2． 运行控制 <strong><img src="" alt="">500){this.resized=true;this.style.width=500;}&quot; resized=&quot;0&quot;&gt;</strong>软件运行时有较友好的界面，基本能够实现用户的数据处理要求。 3． 运行时间 <strong><img src="" alt="">500){this.resized=true;this.style.width=500;}&quot; resized=&quot;0&quot;&gt;</strong>系统的运行时间基本可以达到用户所提出的要求。 <strong>七． 出错处理设计</strong> 1． 出错输出信息 <strong><img src="" alt="">500){this.resized=true;this.style.width=500;}&quot; resized=&quot;0&quot;&gt;</strong>在用户使用错误的数据或访问没有权限的数据后，系统给出提示：“对不起，你非法使用数据，没有权限！”而且用户的密码管理可以允许用户修改自己的密码，不允许用户的匿名登录。 2． 出错处理对策 <strong><img src="" alt="">500){this.resized=true;this.style.width=500;}&quot; resized=&quot;0&quot;&gt;</strong>由于数据在数据库中已经有备份，故在系统出错后可以依靠数据库的恢复功能，并且依靠日志文件使系统再启动，就算系统崩溃用户数据也不会丢失或遭到破坏。但有可能占用更多的数据存储空间，权衡措施由用户来决定。 <strong>八． 安全保密设计</strong> <strong><img src="" alt="">500){this.resized=true;this.style.width=500;}&quot; resized=&quot;0&quot;&gt;</strong>系统的系统用户管理保证了只有授权的用户才能进入系统进行数据操作，而且对一些重要数据，系统设置为只有更高权限的人员方可读取或是操作。系统安全保密性较高。 <strong>九． 维护设计</strong> <strong><img src="" alt="">500){this.resized=true;this.style.width=500;}&quot; resized=&quot;0&quot;&gt;</strong>由于系统较小没有外加维护模块，因为维护工作比较简单，仅靠数据库的一些基本维护</p>
<p>0</p>
<p>0
0</p>
<p>(请您对文章做出评价)
<a href="http://www.cnblogs.com/campo/archive/2007/07/26/832590.html" target="_blank">«</a>上一篇：<a href="http://www.cnblogs.com/campo/archive/2007/07/26/832590.html" title="发布于2007-07-26 17:53" target="_blank">windows文章串联</a>
<a href="http://www.cnblogs.com/campo/archive/2007/08/24/867928.html" target="_blank">»</a>下一篇：<a href="http://www.cnblogs.com/campo/archive/2007/08/24/867928.html" title="发布于2007-08-24 10:36" target="_blank">概要设计模板</a></p>
<p>posted @ 2007-08-24 10:33 <a href="http://www.cnblogs.com/campo/" target="_blank">campo</a> 阅读(6961) <a href="http://www.cnblogs.com/campo/archive/2007/08/24/867923.html#commentform" target="_blank">评论(3)</a>  <a href="http://www.cnblogs.com/campo/admin/EditPosts.aspx?postid=867923" target="_blank">编辑</a> <a href="http://www.cnblogs.com/campo/AddToFavorite.aspx?id=867923" target="_blank">收藏</a> <a href="http://www.cnblogs.com/campo/archive/2007/08/24/867923.html#" target="_blank">网摘</a>
<img src="" alt=""><a href=""></a></p>
<p>发表评论</p>
<p>1600226
  <a href="http://www.cnblogs.com/campo/archive/2007/08/24/867923.html#commentform" target="_blank">回复</a>  <a href="http://www.cnblogs.com/campo/archive/2007/08/24/867923.html#commentform" target="_blank">引用</a>  <a href=""></a>  <a href=""></a><a href="http://www.cnblogs.com/campo/archive/2007/08/24/867923.html#1013155" target="_blank">/#1楼</a><a href=""></a>2007-12-24 20:52 | <a href="http://www.cnitblog.com/r.aspx?url=http://dgdfg">fghfdsgh[未注册用户]</a></p>
<p>gsdfgdf
;asdlf
laji</p>
<p>  <a href="http://www.cnblogs.com/campo/archive/2007/08/24/867923.html#commentform" target="_blank">回复</a>  <a href="http://www.cnblogs.com/campo/archive/2007/08/24/867923.html#commentform" target="_blank">引用</a>  <a href=""></a>  <a href=""></a><a href="http://www.cnblogs.com/campo/archive/2007/08/24/867923.html#1600225" target="_blank">/#2楼</a><a href=""></a>2009-07-30 14:58 | <a href="">chris.wang[未注册用户]</a></p>
<p>十分感谢您发布的概要设计文档，对我的工作提供了很大的帮助。
祝您工作顺利！
  <a href="http://www.cnblogs.com/campo/archive/2007/08/24/867923.html#commentform" target="_blank">回复</a>  <a href="http://www.cnblogs.com/campo/archive/2007/08/24/867923.html#commentform" target="_blank">引用</a>  <a href=""></a>  <a href=""></a><a href="http://www.cnblogs.com/campo/archive/2007/08/24/867923.html#1600226" target="_blank">/#3楼</a><a href=""></a><a href=""></a>2009-07-30 14:58 | <a href="">chris.wang[未注册用户]</a></p>
<p>十分感谢您发布的概要设计文档，对我的工作提供了很大的帮助。
祝您工作顺利！
注册用户登录后才能发表评论，请 <a href="http://passport.cnblogs.com/login.aspx?ReturnUrl=http%3a%2f%2fwww.cnblogs.com%2fcampo%2farchive%2f2007%2f08%2f24%2f867923.html%3flogin%3d1%23commentform" target="_blank">登录</a> 或 <a href="http://passport.cnblogs.com/register.aspx?ReturnUrl=http%3a%2f%2fwww.cnblogs.com%2fcampo%2farchive%2f2007%2f08%2f24%2f867923.html%23Bottom2" target="_blank">注册</a> 。</p>
<p><a href="http://www.cnblogs.com/" target="_blank">博客园首页</a>  <a href="http://news.cnblogs.com/" target="_blank">IT新闻</a>  <a href="http://home.cnblogs.com/ing/" target="_blank">闪存</a>  <a href="http://kb.cnblogs.com/" target="_blank">知识库</a>  <a href="http://job.cnblogs.com/" target="_blank">招聘</a></p>
<p><a href="http://news.cnblogs.com/" target="_blank">IT新闻</a>:
· <a href="http://news.cnblogs.com/n/57476/" target="_blank">给Oracle支招：改善Java的15种方式</a>
· <a href="http://news.cnblogs.com/n/57475/" target="_blank">谷歌中国面临人才流失 猎头公司挖走多名员工</a>
· <a href="http://news.cnblogs.com/n/57474/" target="_blank">惠普正式开放新加坡云计算实验室</a>
· <a href="http://news.cnblogs.com/n/57473/" target="_blank">微软向美国联邦政府提供云计算服务</a>
· <a href="http://news.cnblogs.com/n/57472/" target="_blank">中国3G运营商 真正的大考才刚开始</a>
<a href="http://a4.yeshj.com/rd/34138/" target="_blank">每天10分钟，轻松学英语</a>
专题：<a href="http://kb.cnblogs.com/zt/iPad/" target="_blank">iPad</a>  <a href="http://kb.cnblogs.com/zt/jquery/" target="_blank">jQuery</a>  <a href="http://kb.cnblogs.com/zt/windows7/" target="_blank">Windows 7</a></p>
<p>网站导航：
<a href="http://www.cnblogs.com/" target="_blank">博客园首页</a>  <a href="http://news.cnblogs.com/" target="_blank">IT新闻</a>  <a href="http://home.cnblogs.com/" target="_blank">个人主页</a>  <a href="http://home.cnblogs.com/ing/" target="_blank">闪存</a>  <a href="http://job.cnblogs.com/" target="_blank">程序员招聘</a>  <a href="http://space.cnblogs.com/" target="_blank">社区</a>  <a href="http://space.cnblogs.com/q/" target="_blank">博问</a>  <a href="http://wz.cnblogs.com/" target="_blank">网摘</a>
<a href="http://www.china-pub.com/STATIC07/0912/zh_ndcx_091212.asp" target="_blank"><img src="" alt=""></a>
<a href="http://www.china-pub.com/itbook/" target="_blank">China-pub 计算机图书网上专卖店！6.5万品种2-8折！</a>
<a href="http://www.china-pub.com/static07/0901/zh_jueba_090121.asp" target="_blank">China-Pub 计算机绝版图书按需印刷服务</a></p>
<p><strong>在知识库中查看：</strong>
<a href="http://kb.cnblogs.com/a/867923/" target="_blank">概要设计文档模板</a></p>
<p>Copyright ©2010 campo</p>
<p><a href="http://home.cnblogs.com/campo/" target="_blank">我的主页</a>  <a href="http://home.cnblogs.com/campo/detail/" target="_blank">个人资料</a>
<a href="http://home.cnblogs.com/campo/ing/" target="_blank">我的闪存</a>  <a href="http://space.cnblogs.com/msg/send/campo" target="_blank">发短消息</a></p>
<p><a href="&quot;Go to the previous month&quot;">&lt;</a> 2007年8月 <a href="&quot;Go to the next month&quot;">&gt;</a> 日 一 二 三 四 五 六 29 30 31 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 <a href="http://www.cnblogs.com/campo/archive/2007/8/24.html" target="_blank">24</a> 25 26 27 28 29 <a href="http://www.cnblogs.com/campo/archive/2007/8/30.html" target="_blank">30</a> 31 1 2 3 4 5 6 7 8</p>
<h3 id="-">搜索</h3>
<h3 id="-">常用链接</h3>
<ul>
<li><a href="http://www.cnblogs.com/campo/MyPosts.html" target="_blank">我的随笔</a></li>
<li><a href="http://home.cnblogs.com/campo/" target="_blank">我的空间</a></li>
<li><a href="http://space.cnblogs.com/msg/recent" target="_blank">我的短信</a></li>
<li><a href="http://www.cnblogs.com/campo/MyComments.html" target="_blank">我的评论</a></li>
<li><a href="http://www.cnblogs.com/campo/archive/2007/08/24/867923.html#" target="_blank">更多链接</a></li>
<li><a href="http://www.cnblogs.com/campo/OtherPosts.html" title="我发表过评论的随笔" target="_blank">我的参与</a></li>
<li><a href="http://www.cnblogs.com/campo/MyNews.html" target="_blank">我的新闻</a></li>
<li><a href="http://www.cnblogs.com/campo/RecentComments.html" target="_blank">最新评论</a></li>
<li><p><a href="http://www.cnblogs.com/campo/tag/" target="_blank">我的标签</a></p>
<h3 id="-">我的标签</h3>
</li>
<li><p><a href="http://www.cnblogs.com/campo/tag/0x80040155++æ¥å£æ²¡ææ³¨å/" target="_blank">0x80040155 接口没有注册</a>(1)</p>
</li>
</ul>
<h1 id="-">随笔分类</h1>
<ul>
<li><a href="http://www.cnblogs.com/campo/category/133119.html" target="_blank">Asp.Net Ajax</a><a href="http://www.cnblogs.com/campo/archive/2007/08/24/867923.html###" title="Subscribe to Asp.Net Ajax" target="_blank"><img src="&quot;Subscribe to Asp.Net Ajax&quot;" alt=""></a></li>
<li><a href="http://www.cnblogs.com/campo/category/122183.html" target="_blank">CodeSmith</a><a href="http://www.cnblogs.com/campo/archive/2007/08/24/867923.html###" title="Subscribe to CodeSmith" target="_blank"><img src="&quot;Subscribe to CodeSmith&quot;" alt=""></a></li>
<li><a href="http://www.cnblogs.com/campo/category/78191.html" target="_blank">DotNet(9)</a><a href="http://www.cnblogs.com/campo/archive/2007/08/24/867923.html###" title="Subscribe to DotNet(9)" target="_blank"><img src="&quot;Subscribe to DotNet(9" alt="">&quot;)</a></li>
<li><a href="http://www.cnblogs.com/campo/category/122184.html" target="_blank">Enterprise Library</a><a href="http://www.cnblogs.com/campo/archive/2007/08/24/867923.html###" title="Subscribe to Enterprise Library" target="_blank"><img src="&quot;Subscribe to Enterprise Library&quot;" alt=""></a></li>
<li><a href="http://www.cnblogs.com/campo/category/78193.html" target="_blank">Java(1)</a><a href="http://www.cnblogs.com/campo/archive/2007/08/24/867923.html###" title="Subscribe to Java(1)" target="_blank"><img src="&quot;Subscribe to Java(1" alt="">&quot;)</a></li>
<li><a href="http://www.cnblogs.com/campo/category/125077.html" target="_blank">Javascript小技巧(1)</a><a href="http://www.cnblogs.com/campo/archive/2007/08/24/867923.html###" title="Subscribe to Javascript小技巧(1)" target="_blank"><img src="&quot;Subscribe to Javascript小技巧(1" alt="">&quot;)</a></li>
<li><a href="http://www.cnblogs.com/campo/category/95054.html" target="_blank">Linux(1)</a><a href="http://www.cnblogs.com/campo/archive/2007/08/24/867923.html###" title="Subscribe to Linux(1)" target="_blank"><img src="&quot;Subscribe to Linux(1" alt="">&quot;)</a></li>
<li><a href="http://www.cnblogs.com/campo/category/99054.html" target="_blank">OpenCms</a><a href="http://www.cnblogs.com/campo/archive/2007/08/24/867923.html###" title="Subscribe to OpenCms" target="_blank"><img src="&quot;Subscribe to OpenCms&quot;" alt=""></a></li>
<li><a href="http://www.cnblogs.com/campo/category/105128.html" target="_blank">PS(1)</a><a href="http://www.cnblogs.com/campo/archive/2007/08/24/867923.html###" title="Subscribe to PS(1)" target="_blank"><img src="&quot;Subscribe to PS(1" alt="">&quot;)</a></li>
<li><a href="http://www.cnblogs.com/campo/category/105561.html" target="_blank">程序员必经之路(2)</a><a href="http://www.cnblogs.com/campo/archive/2007/08/24/867923.html###" title="Subscribe to 程序员必经之路(2)" target="_blank"><img src="&quot;Subscribe to 程序员必经之路(2" alt="">&quot;)</a></li>
<li><a href="http://www.cnblogs.com/campo/category/133120.html" target="_blank">代码生产</a><a href="http://www.cnblogs.com/campo/archive/2007/08/24/867923.html###" title="Subscribe to 代码生产" target="_blank"><img src="&quot;Subscribe to 代码生产&quot;" alt=""></a></li>
<li><a href="http://www.cnblogs.com/campo/category/78195.html" target="_blank">软件工程</a><a href="http://www.cnblogs.com/campo/archive/2007/08/24/867923.html###" title="Subscribe to 软件工程" target="_blank"><img src="&quot;Subscribe to 软件工程&quot;" alt=""></a></li>
<li><a href="http://www.cnblogs.com/campo/category/78194.html" target="_blank">数据库(5)</a><a href="http://www.cnblogs.com/campo/archive/2007/08/24/867923.html###" title="Subscribe to 数据库(5)" target="_blank"><img src="&quot;Subscribe to 数据库(5" alt="">&quot;)</a></li>
</ul>
<h1 id="-">随笔档案</h1>
<ul>
<li><a href="http://www.cnblogs.com/campo/archive/2008/09.html" target="_blank">2008年9月 (1)</a></li>
<li><a href="http://www.cnblogs.com/campo/archive/2008/06.html" target="_blank">2008年6月 (1)</a></li>
<li><a href="http://www.cnblogs.com/campo/archive/2008/03.html" target="_blank">2008年3月 (2)</a></li>
<li><a href="http://www.cnblogs.com/campo/archive/2008/01.html" target="_blank">2008年1月 (1)</a></li>
<li><a href="http://www.cnblogs.com/campo/archive/2007/11.html" target="_blank">2007年11月 (3)</a></li>
<li><a href="http://www.cnblogs.com/campo/archive/2007/10.html" target="_blank">2007年10月 (4)</a></li>
<li><a href="http://www.cnblogs.com/campo/archive/2007/09.html" target="_blank">2007年9月 (9)</a></li>
<li><a href="http://www.cnblogs.com/campo/archive/2007/08.html" target="_blank">2007年8月 (3)</a></li>
<li><a href="http://www.cnblogs.com/campo/archive/2007/07.html" target="_blank">2007年7月 (7)</a></li>
<li><a href="http://www.cnblogs.com/campo/archive/2007/06.html" target="_blank">2007年6月 (2)</a></li>
<li><a href="http://www.cnblogs.com/campo/archive/2007/05.html" target="_blank">2007年5月 (1)</a></li>
<li><a href="http://www.cnblogs.com/campo/archive/2007/04.html" target="_blank">2007年4月 (2)</a></li>
<li><a href="http://www.cnblogs.com/campo/archive/2007/02.html" target="_blank">2007年2月 (2)</a></li>
<li><a href="http://www.cnblogs.com/campo/archive/2007/01.html" target="_blank">2007年1月 (2)</a></li>
</ul>
<h1 id="-">文章分类</h1>
<ul>
<li><a href="http://www.cnblogs.com/campo/category/80348.html" target="_blank">编程知识</a><a href="http://www.cnblogs.com/campo/archive/2007/08/24/867923.html###" title="Subscribe to 编程知识" target="_blank"><img src="&quot;Subscribe to 编程知识&quot;" alt=""></a></li>
</ul>
<h1 id="-">相册</h1>
<ul>
<li><a href="http://www.cnblogs.com/campo/gallery/105746.html" target="_blank">basketball</a></li>
</ul>
<h1 id="-">编程技术文章</h1>
<ul>
<li><a href="http://www.cnblogs.com/3echo/archive/2006/02/14/330579.html" target="_blank">C/#学习笔记之程序集</a></li>
<li><a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank">Jeffrey Zhao</a></li>
<li><a href="http://mail-ricklee.cnblogs.com/" target="_blank">NickLee</a></li>
<li><a href="http://blog.sina.com.cn/campoem" target="_blank">沉香</a></li>
<li><a href="http://www.cnblogs.com/ruxpinsp1/" target="_blank">大胡仔</a><h3 id="-rss-http-www-cnblogs-com-campo-commentsrss-aspx-rss-">最新评论<a href="http://www.cnblogs.com/campo/CommentsRSS.aspx" title="RSS订阅最最新评论" target="_blank"><img src="&quot;RSS订阅最最新评论&quot;" alt=""></a></h3>
</li>
</ul>
<p><a href="http://www.cnblogs.com/campo/archive/2007/08/24/867923.html#1600226" target="_blank">1. Re:概要设计文档模板</a></p>
<p>十分感谢您发布的概要设计文档，对我的工作提供了很大的帮助。祝您工作顺利！ (chris.wang)
<a href="http://www.cnblogs.com/campo/archive/2007/08/24/867923.html#1600225" target="_blank">2. Re:概要设计文档模板</a></p>
<p>十分感谢您发布的概要设计文档，对我的工作提供了很大的帮助。祝您工作顺利！ (chris.wang)
<a href="http://www.cnblogs.com/campo/archive/2007/10/05/914504.html#1429366" target="_blank">3. re: 2007IT业薪资调查，请注明城市</a></p>
<p>4000 应届 北京 (飞林沙)
<a href="http://www.cnblogs.com/campo/archive/2007/10/05/914504.html#1300074" target="_blank">4. re: 2007IT业薪资调查，请注明城市</a></p>
<p>1500 一年 青岛 唉 (随&amp;风)
<a href="http://www.cnblogs.com/campo/archive/2007/10/05/914504.html#1299291" target="_blank">5. re: 2007IT业薪资调查，请注明城市</a></p>
<p>6K-8K。 (养猪设备)</p>
<h3 id="-">阅读排行榜</h3>
<ul>
<li><a href="http://www.cnblogs.com/campo/archive/2007/08/24/867923.html" target="_blank">1. 概要设计文档模板(6961)</a></li>
<li><a href="http://www.cnblogs.com/campo/archive/2007/10/05/914504.html" target="_blank">2. 2007IT业薪资调查，请注明城市(6651)</a></li>
<li><a href="http://www.cnblogs.com/campo/archive/2007/09/07/885354.html" target="_blank">3. sqlserver2000下载地址(5108)</a></li>
<li><a href="http://www.cnblogs.com/campo/archive/2007/08/24/867928.html" target="_blank">4. 概要设计模板(4755)</a></li>
<li><p><a href="http://www.cnblogs.com/campo/archive/2007/09/07/885342.html" target="_blank">5. SQLServer2000安装图解(3051)</a></p>
<h3 id="-">评论排行榜</h3>
</li>
<li><p><a href="http://www.cnblogs.com/campo/archive/2007/10/05/914504.html" target="_blank">1. 2007IT业薪资调查，请注明城市(138)</a></p>
</li>
<li><a href="http://www.cnblogs.com/campo/archive/2007/08/24/867923.html" target="_blank">2. 概要设计文档模板(3)</a></li>
<li><a href="http://www.cnblogs.com/campo/archive/2007/06/28/798991.html" target="_blank">3. 工作流技术学习专题(3)</a></li>
<li><a href="http://www.cnblogs.com/campo/archive/2007/09/10/888924.html" target="_blank">4. 用例 UseCase(2)</a></li>
<li><a href="http://www.cnblogs.com/campo/archive/2008/01/07/1029353.html" target="_blank">5. 往消息队列传数据的存储过程(2)</a></li>
</ul>
<p>msn:campolake@hotmail.com</p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/Java_设计类/">Java_设计类</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/Java_设计类/" class="label label-success">Java_设计类</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:42"datetime="2014-03-07 09:54:42"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-Java_设计类--概要设计文档模板/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-Java_设计类--概要设计文档模板" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--JVM内存管理：深入Java内存区域与OOM-高级语言虚拟机/">JVM内存管理：深入Java内存区域与OOM </a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:42.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--JVM内存管理：深入Java内存区域与OOM-高级语言虚拟机/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="jvm-java-oom-">JVM内存管理：深入Java内存区域与OOM - 高级语言虚拟机</h1>
<p><a href="http://hllvm.group.iteye.com/login" title="登录" target="_blank">您还未登录 !</a> <a href="http://hllvm.group.iteye.com/login" target="_blank">登录</a> <a href="http://hllvm.group.iteye.com/signup" target="_blank">注册</a></p>
<p><a href="http://www.iteye.com/" target="_blank"><img src="&quot;ITeye-最棒的软件开发交流社区&quot;" alt="ITeye3.0"></a></p>
<p><a href=""></a></p>
<p><a href="http://www.iteye.com/groups" target="_blank">群组首页</a> → <a href="http://hllvm.group.iteye.com/groups/category/language" target="_blank">编程语言</a> → <a href="http://hllvm.group.iteye.com/" target="_blank">高级语言虚拟机</a> → <a href="http://hllvm.group.iteye.com/group/wiki" target="_blank">知识库</a> → <a href="http://hllvm.group.iteye.com/group/wiki?category_id=316" target="_blank">JVM基础</a> → <a href="">JVM内存管理：深入Java内存区域与OOM</a>
原创作者: <a href="http://www.javaeye.com/topic/802573" target="_blank">IcyFenix</a>   阅读:10325次   评论:5条   更新时间:2011-05-26    </p>
<p>Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的高墙，墙外面的人想进去，墙里面的人却想出来。</p>
<h2 id="-">概述：</h2>
<p>对于从事C、C++程序开发的开发人员来说，在内存管理领域，他们即是拥有最高权力的皇帝又是执行最基础工作的劳动人民——拥有每一个对象的“所有权”，又担负着每一个对象生命开始到终结的维护责任。</p>
<p>对于Java程序员来说，不需要在为每一个new操作去写配对的delete/free，不容易出现内容泄漏和内存溢出错误，看起来由JVM管理内存一切都很美好。不过，也正是因为Java程序员把内存控制的权力交给了JVM，一旦出现泄漏和溢出，如果不了解JVM是怎样使用内存的，那排查错误将会是一件非常困难的事情。</p>
<h2 id="vm-">VM运行时数据区域</h2>
<p>JVM执行Java程序的过程中，会使用到各种数据区域，这些区域有各自的用途、创建和销毁时间。根据《Java虚拟机规范（第二版）》（下文称VM Spec）的规定，JVM包括下列几个运行时数据区域：</p>
<p>1.程序计数器（Program Counter Register）：</p>
<p>每一个Java线程都有一个程序计数器来用于保存程序执行到当前方法的哪一个指令，对于非Native方法，这个区域记录的是正在执行的VM原语的地址，如果正在执行的是Natvie方法，这个区域则为空（undefined）。此内存区域是唯一一个在VM Spec中没有规定任何OutOfMemoryError情况的区域。</p>
<p>2.Java虚拟机栈（Java Virtual Machine Stacks）</p>
<p>与程序计数器一样，VM栈的生命周期也是与线程相同。VM栈描述的是Java方法调用的内存模型：每个方法被执行的时候，都会同时创建一个帧（Frame）用于存储本地变量表、操作栈、动态链接、方法出入口等信息。每一个方法的调用至完成，就意味着一个帧在VM栈中的入栈至出栈的过程。在后文中，我们将着重讨论VM栈中本地变量表部分。</p>
<p>经常有人把Java内存简单的区分为堆内存（Heap）和栈内存（Stack），实际中的区域远比这种观点复杂，这样划分只是说明与变量定义密切相关的内存区域是这两块。其中所指的“堆”后面会专门描述，而所指的“栈”就是VM栈中各个帧的本地变量表部分。本地变量表存放了编译期可知的各种标量类型（boolean、byte、char、short、int、float、long、double）、对象引用（不是对象本身，仅仅是一个引用指针）、方法返回地址等。其中long和double会占用2个本地变量空间（32bit），其余占用1个。本地变量表在进入方法时进行分配，当进入一个方法时，这个方法需要在帧中分配多大的本地变量是一件完全确定的事情，在方法运行期间不改变本地变量表的大小。</p>
<p>在VM Spec中对这个区域规定了2中异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果VM栈可以动态扩展（VM Spec中允许固定长度的VM栈），当扩展时无法申请到足够内存则抛出OutOfMemoryError异常。</p>
<p>3.本地方法栈（Native Method Stacks）</p>
<p>本地方法栈与VM栈所发挥作用是类似的，只不过VM栈为虚拟机运行VM原语服务，而本地方法栈是为虚拟机使用到的Native方法服务。它的实现的语言、方式与结构并没有强制规定，甚至有的虚拟机（譬如Sun Hotspot虚拟机）直接就把本地方法栈和VM栈合二为一。和VM栈一样，这个区域也会抛出StackOverflowError和OutOfMemoryError异常。</p>
<p>4.Java堆（Java Heap）</p>
<p>对于绝大多数应用来说，Java堆是虚拟机管理最大的一块内存。Java堆是被所有线程共享的，在虚拟机启动时创建。Java堆的唯一目的就是存放对象实例，绝大部分的对象实例都在这里分配。这一点在VM Spec中的描述是：所有的实例以及数组都在堆上分配（原文：The heap is the runtime data area from which memory for all class instances and arrays is allocated），但是在逃逸分析和标量替换优化技术出现后，VM Spec的描述就显得并不那么准确了。</p>
<p>Java堆内还有更细致的划分：新生代、老年代，再细致一点的：eden、from survivor、to survivor，甚至更细粒度的本地线程分配缓冲（TLAB）等，无论对Java堆如何划分，目的都是为了更好的回收内存，或者更快的分配内存，在本章中我们仅仅针对内存区域的作用进行讨论，Java堆中的上述各个区域的细节，可参见本文第二章《JVM内存管理：深入垃圾收集器与内存分配策略》。</p>
<p>根据VM Spec的要求，Java堆可以处于物理上不连续的内存空间，它逻辑上是连续的即可，就像我们的磁盘空间一样。实现时可以选择实现成固定大小的，也可以是可扩展的，不过当前所有商业的虚拟机都是按照可扩展来实现的（通过-Xmx和-Xms控制）。如果在堆中无法分配内存，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。</p>
<p>5.方法区（Method Area）</p>
<p>叫“方法区”可能认识它的人还不太多，如果叫永久代（Permanent Generation）它的粉丝也许就多了。它还有个别名叫做Non-Heap（非堆），但是VM Spec上则描述方法区为堆的一个逻辑部分（原文：the method area is logically part of the heap），这个名字的问题还真容易令人产生误解，我们在这里就不纠结了。</p>
<p>方法区中存放了每个Class的结构信息，包括常量池、字段描述、方法描述等等。VM Space描述中对这个区域的限制非常宽松，除了和Java堆一样不需要连续的内存，也可以选择固定大小或者可扩展外，甚至可以选择不实现垃圾收集。相对来说，垃圾收集行为在这个区域是相对比较少发生的，但并不是某些描述那样永久代不会发生GC（至少对当前主流的商业JVM实现来说是如此），这里的GC主要是对常量池的回收和对类的卸载，虽然回收的“成绩”一般也比较差强人意，尤其是类卸载，条件相当苛刻。</p>
<p>6.运行时常量池（Runtime Constant Pool）</p>
<p>Class文件中除了有类的版本、字段、方法、接口等描述等信息外，还有一项信息是常量表(constant_pool table)，用于存放编译期已可知的常量，这部分内容将在类加载后进入方法区（永久代）存放。但是Java语言并不要求常量一定只有编译期预置入Class的常量表的内容才能进入方法区常量池，运行期间也可将新内容放入常量池（最典型的String.intern()方法）。</p>
<p>运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法在申请到内存时会抛出OutOfMemoryError异常。</p>
<p>7.本机直接内存（Direct Memory）</p>
<p>直接内存并不是虚拟机运行时数据区的一部分，它根本就是本机内存而不是VM直接管理的区域。但是这部分内存也会导致OutOfMemoryError异常出现，因此我们放到这里一起描述。</p>
<p>在JDK1.4中新加入了NIO类，引入一种基于渠道与缓冲区的I/O方式，它可以通过本机Native函数库直接分配本机内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java对和本机堆中来回复制数据。</p>
<p>显然本机直接内存的分配不会受到Java堆大小的限制，但是即然是内存那肯定还是要受到本机物理内存（包括SWAP区或者Windows虚拟内存）的限制的，一般服务器管理员配置JVM参数时，会根据实际内存设置-Xmx等参数信息，但经常忽略掉直接内存，使得各个内存区域总和大于物理内存限制（包括物理的和操作系统级的限制），而导致动态扩展时出现OutOfMemoryError异常。</p>
<h2 id="-outofmemoryerror">实战OutOfMemoryError</h2>
<p>上述区域中，除了程序计数器，其他在VM Spec中都描述了产生OutOfMemoryError（下称OOM）的情形，那我们就实战模拟一下，通过几段简单的代码，令对应的区域产生OOM异常以便加深认识，同时初步介绍一些与内存相关的虚拟机参数。下文的代码都是基于Sun Hotspot虚拟机1.6版的实现，对于不同公司的不同版本的虚拟机，参数与程序运行结果可能结果会有所差别。</p>
<p><strong>Java**</strong>堆**</p>
<p>Java堆存放的是对象实例，因此只要不断建立对象，并且保证GC Roots到对象之间有可达路径即可产生OOM异常。测试中限制Java堆大小为20M，不可扩展，通过参数-XX:+HeapDumpOnOutOfMemoryError让虚拟机在出现OOM异常的时候Dump出内存映像以便分析。（关于Dump映像文件分析方面的内容，可参见本文第三章《JVM内存管理：深入JVM内存异常分析与调优》。）</p>
<p>清单1：Java堆OOM测试
//<em>/</em></p>
<p> /* VM Args：-Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError</p>
<p> /* @author zzm</p>
<p> /*/</p>
<p>public class HeapOOM {</p>
<pre><code>   static class OOMObject {

   }



   public static void main(String[] args) {

          List&lt;OOMObject&gt; list = new ArrayList&lt;OOMObject&gt;();



          while (true) {

                 list.add(new OOMObject());

          }

   }
</code></pre><p>}</p>
<p>运行结果：
java.lang.OutOfMemoryError: Java heap space</p>
<p>Dumping heap to java_pid3404.hprof ...</p>
<p>Heap dump file created [22045981 bytes in 0.663 secs]</p>
<p><strong>VM**</strong>栈和本地方法栈**</p>
<p>Hotspot虚拟机并不区分VM栈和本地方法栈，因此-Xoss参数实际上是无效的，栈容量只由-Xss参数设定。关于VM栈和本地方法栈在VM Spec描述了两种异常：StackOverflowError与OutOfMemoryError，当栈空间无法继续分配分配时，到底是内存太小还是栈太大其实某种意义上是对同一件事情的两种描述而已，在笔者的实验中，对于单线程应用尝试下面3种方法均无法让虚拟机产生OOM，全部尝试结果都是获得SOF异常。</p>
<p>1.使用-Xss参数削减栈内存容量。结果：抛出SOF异常时的堆栈深度相应缩小。</p>
<p>2.定义大量的本地变量，增大此方法对应帧的长度。结果：抛出SOF异常时的堆栈深度相应缩小。</p>
<p>3.创建几个定义很多本地变量的复杂对象，打开逃逸分析和标量替换选项，使得JIT编译器允许对象拆分后在栈中分配。结果：实际效果同第二点。</p>
<p>清单2：VM栈和本地方法栈OOM测试（仅作为第1点测试程序）
//<em>/</em></p>
<p> /* VM Args：-Xss128k</p>
<p> /* @author zzm</p>
<p> /*/</p>
<p>public class JavaVMStackSOF {</p>
<pre><code>   private int stackLength = 1;



   public void stackLeak() {

          stackLength++;

          stackLeak();

   }



   public static void main(String[] args) throws Throwable {

          JavaVMStackSOF oom = new JavaVMStackSOF();

          try {

                 oom.stackLeak();

          } catch (Throwable e) {

                 System.out.println(&quot;stack length:&quot; + oom.stackLength);

                 throw e;

          }

   }
</code></pre><p>}</p>
<p>运行结果：
stack length:2402</p>
<p>Exception in thread &quot;main&quot; java.lang.StackOverflowError</p>
<pre><code>    at org.fenixsoft.oom.JavaVMStackSOF.stackLeak(JavaVMStackSOF.java:20)

    at org.fenixsoft.oom.JavaVMStackSOF.stackLeak(JavaVMStackSOF.java:21)

    at org.fenixsoft.oom.JavaVMStackSOF.stackLeak(JavaVMStackSOF.java:21)
</code></pre><p>如果在多线程环境下，不断建立线程倒是可以产生OOM异常，但是基本上这个异常和VM栈空间够不够关系没有直接关系，甚至是给每个线程的VM栈分配的内存越多反而越容易产生这个OOM异常。</p>
<p>原因其实很好理解，操作系统分配给每个进程的内存是有限制的，譬如32位Windows限制为2G，Java堆和方法区的大小JVM有参数可以限制最大值，那剩余的内存为2G（操作系统限制）-Xmx（最大堆）-MaxPermSize（最大方法区），程序计数器消耗内存很小，可以忽略掉，那虚拟机进程本身耗费的内存不计算的话，剩下的内存就供每一个线程的VM栈和本地方法栈瓜分了，那自然每个线程中VM栈分配内存越多，就越容易把剩下的内存耗尽。</p>
<p>清单3：创建线程导致OOM异常
//<em>/</em></p>
<p> /* VM Args：-Xss2M （这时候不妨设大些）</p>
<p> /* @author zzm</p>
<p> /*/</p>
<p>public class JavaVMStackOOM {</p>
<pre><code>   private void dontStop() {

          while (true) {

          }

   }



   public void stackLeakByThread() {

          while (true) {

                 Thread thread = new Thread(new Runnable() {

                        @Override

                        public void run() {

                               dontStop();

                        }

                 });

                 thread.start();

          }

   }



   public static void main(String[] args) throws Throwable {

          JavaVMStackOOM oom = new JavaVMStackOOM();

          oom.stackLeakByThread();

   }
</code></pre><p>}</p>
<p>特别提示一下，如果读者要运行上面这段代码，记得要存盘当前工作，上述代码执行时有很大令操作系统卡死的风险。</p>
<p>运行结果：
Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: unable to create new native thread</p>
<p><strong>运行时常量池</strong></p>
<hr>
<p>要在常量池里添加内容，最简单的就是使用String.intern()这个Native方法。由于常量池分配在方法区内，我们只需要通过-XX:PermSize和-XX:MaxPermSize限制方法区大小即可限制常量池容量。实现代码如下：</p>
<p>清单4：运行时常量池导致的OOM异常
//<em>/</em></p>
<p> /* VM Args：-XX:PermSize=10M -XX:MaxPermSize=10M</p>
<p> /* @author zzm</p>
<p> /*/</p>
<p>public class RuntimeConstantPoolOOM {</p>
<pre><code>   public static void main(String[] args) {

          // 使用List保持着常量池引用，压制Full GC回收常量池行为

          List&lt;String&gt; list = new ArrayList&lt;String&gt;();

          // 10M的PermSize在integer范围内足够产生OOM了

          int i = 0;

          while (true) {

                 list.add(String.valueOf(i++).intern());

          }

   }
</code></pre><p>}</p>
<p>运行结果：
Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: PermGen space</p>
<pre><code>   at java.lang.String.intern(Native Method)

   at org.fenixsoft.oom.RuntimeConstantPoolOOM.main(RuntimeConstantPoolOOM.java:18)
</code></pre><p><strong>方法区</strong></p>
<p>上文讲过，方法区用于存放Class相关信息，所以这个区域的测试我们借助CGLib直接操作字节码动态生成大量的Class，值得注意的是，这里我们这个例子中模拟的场景其实经常会在实际应用中出现：当前很多主流框架，如Spring、Hibernate对类进行增强时，都会使用到CGLib这类字节码技术，当增强的类越多，就需要越大的方法区用于保证动态生成的Class可以加载入内存。</p>
<p>清单5：借助CGLib使得方法区出现OOM异常
//<em>/</em></p>
<p> /* VM Args： -XX:PermSize=10M -XX:MaxPermSize=10M</p>
<p> /* @author zzm</p>
<p> /*/</p>
<p>public class JavaMethodAreaOOM {</p>
<pre><code>   public static void main(String[] args) {

          while (true) {

                 Enhancer enhancer = new Enhancer();

                 enhancer.setSuperclass(OOMObject.class);

                 enhancer.setUseCache(false);

                 enhancer.setCallback(new MethodInterceptor() {

                        public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {

                               return proxy.invokeSuper(obj, args);

                        }

                 });

                 enhancer.create();

          }

   }



   static class OOMObject {



   }
</code></pre><p>}</p>
<p>运行结果：
Caused by: java.lang.OutOfMemoryError: PermGen space</p>
<pre><code>   at java.lang.ClassLoader.defineClass1(Native Method)

   at java.lang.ClassLoader.defineClassCond(ClassLoader.java:632)

   at java.lang.ClassLoader.defineClass(ClassLoader.java:616)

   ... 8 more
</code></pre><p><strong>本机直接内存</strong></p>
<p>DirectMemory容量可通过-XX:MaxDirectMemorySize指定，不指定的话默认与Java堆（-Xmx指定）一样，下文代码越过了DirectByteBuffer，直接通过反射获取Unsafe实例进行内存分配（Unsafe类的getUnsafe()方法限制了只有引导类加载器才会返回实例，也就是基本上只有rt.jar里面的类的才能使用），因为DirectByteBuffer也会抛OOM异常，但抛出异常时实际上并没有真正向操作系统申请分配内存，而是通过计算得知无法分配既会抛出，真正申请分配的方法是unsafe.allocateMemory()。</p>
<p>//<em>/</em></p>
<p> /* VM Args：-Xmx20M -XX:MaxDirectMemorySize=10M</p>
<p> /* @author zzm</p>
<p> /*/</p>
<p>public class DirectMemoryOOM {</p>
<pre><code>   private static final int _1MB = 1024 /* 1024;



   public static void main(String[] args) throws Exception {

          Field unsafeField = Unsafe.class.getDeclaredFields()[0];

          unsafeField.setAccessible(true);

          Unsafe unsafe = (Unsafe) unsafeField.get(null);

          while (true) {

                 unsafe.allocateMemory(_1MB);

          }

   }
</code></pre><p>}</p>
<p>运行结果：
Exception in thread &quot;main&quot; java.lang.OutOfMemoryError</p>
<pre><code>   at sun.misc.Unsafe.allocateMemory(Native Method)

   at org.fenixsoft.oom.DirectMemoryOOM.main(DirectMemoryOOM.java:20)
</code></pre><h1 id="-">总结</h1>
<p>到此为止，我们弄清楚虚拟机里面的内存是如何划分的，哪部分区域，什么样的代码、操作可能导致OOM异常。虽然Java有垃圾收集机制，但OOM仍然离我们并不遥远，本章内容我们只是知道各个区域OOM异常出现的原因，下一章我们将看看Java垃圾收集机制为了避免OOM异常出现，做出了什么样的努力。
<a href="http://hllvm.group.iteye.com/group/wiki/2859-JVM" title="JVM内存管理：深入垃圾收集器与内存分配策略" target="_blank">JVM内存管理：深入垃圾收集器与内存分配策 ...</a> | <a href="http://hllvm.group.iteye.com/group/wiki/2871-JVM" title="深入理解JVM" target="_blank">深入理解JVM</a></p>
<p>评论 共 5 条 请<a href="http://hllvm.group.iteye.com/login" target="_blank">登录</a>后发表评论 <a href=""></a></p>
<h3 id="5-http-bahaihe-iteye-com-2013-06-26-21-38">5 楼 <a href="http://bahaihe.iteye.com/" title="巴海和" target="_blank">巴海和</a> 2013-06-26 21:38</h3>
<p>前辈，能够讲一下关于类被加载到内存后，它运行过程是什么？就是讲一下方法区、栈区、程序计数器是如何相互配合完成类的运行的？谢谢</p>
<h3 id="4-zhifeidie12-http-zhifeidie12-iteye-com-zhifeidie12-2013-02-26-23-58">4 楼 <a href="http://zhifeidie12.iteye.com/" title="zhifeidie12" target="_blank">zhifeidie12</a> 2013-02-26 23:58</h3>
<p><img src="" alt=""></p>
<h3 id="3-java-http-pinefantasy-iteye-com-java-2011-04-14-13-19">3 楼 <a href="http://pinefantasy.iteye.com/" title="独爱Java" target="_blank">独爱Java</a> 2011-04-14 13:19</h3>
<p>谢谢作者的好文章，受教了!!!</p>
<h3 id="2-nathanyu-http-nathanyu-iteye-com-nathanyu-2011-04-11-12-32">2 楼 <a href="http://nathanyu.iteye.com/" title="Nathanyu" target="_blank">Nathanyu</a> 2011-04-11 12:32</h3>
<p>  有了这资料 正好把基础打好点.</p>
<h3 id="1-sd6733531-http-sd6733531-iteye-com-sd6733531-2011-02-22-11-20">1 楼 <a href="http://sd6733531.iteye.com/" title="sd6733531" target="_blank">sd6733531</a> 2011-02-22 11:20</h3>
<p><img src="" alt="">
看了前辈的讲解对JVM有了更深入的了解了</p>
<h3 id="-">发表评论</h3>
<p><a href="http://hllvm.group.iteye.com/login" target="_blank"><img src="" alt=""> 您还没有登录,请您登录后再发表评论</a></p>
<p><a href="http://hllvm.group.iteye.com/group/wiki/new" target="_blank"><img src="" alt="New-page"></a></p>
<h3 id="-">文章信息</h3>
<p><a href="http://hllvm.group.iteye.com/group/wiki/" target="_blank">知识库: 高级语言虚拟机</a></p>
<ul>
<li>由<a href="http://kiral.iteye.com/" title="fantasy" target="_blank">fantasy</a>在2010-11-08创建</li>
<li><p>由<a href="http://kiral.iteye.com/" title="fantasy" target="_blank">fantasy</a>在2011-05-26更新</p>
<h3 id="-">相关新闻</h3>
</li>
<li><p><a href="http://hllvm.group.iteye.com/news/27958-JVM" target="_blank">你必须知道的5个JVM命令行标志</a></p>
</li>
<li><a href="http://hllvm.group.iteye.com/news/16601" target="_blank">Azul Systems将要开源Managed Runtime Initiative中的重要技术</a></li>
<li><a href="http://hllvm.group.iteye.com/news/2823" target="_blank">推荐风轻扬：Java 6中的性能优化</a></li>
</ul>
<h3 id="-">相关讨论</h3>
<ul>
<li><a href="http://hllvm.group.iteye.com/topic/802573" target="_blank">JVM内存管理：深入Java内存区域与OOM</a></li>
<li><a href="http://hllvm.group.iteye.com/topic/966928" target="_blank">jvm的各个运行时数据区域的理解</a></li>
<li><a href="http://hllvm.group.iteye.com/topic/622488" target="_blank">[JVM-翻译]揭开java.lang.OutOfMemoryError面纱之一</a></li>
<li><a href="http://hllvm.group.iteye.com/topic/808550" target="_blank">线程安全总结（二）</a></li>
<li><p><a href="http://hllvm.group.iteye.com/topic/1120656" target="_blank">java内存区域与内存溢出异常</a></p>
<h3 id="-">相关博客</h3>
</li>
<li><p><a href="http://tomyz0223.iteye.com/blog/803943" target="_blank">JVM 运行时区域划分（转载）</a></p>
</li>
<li><a href="http://zhuyuehua.iteye.com/blog/930058" target="_blank">JVM运行时数据区结构</a></li>
<li><a href="http://alanlhy.iteye.com/blog/1165044" target="_blank">VM运行时数据区域</a></li>
<li><a href="http://tanghongjun1985.iteye.com/blog/1748159" target="_blank">jdk优化和配置</a></li>
<li><a href="http://wujianjun12315.iteye.com/blog/1683962" target="_blank">深入了解Java运行时的内存区域</a></li>
<li><a href="http://www.iteye.com/" target="_blank">首页</a></li>
<li><a href="http://www.iteye.com/news" target="_blank">资讯</a></li>
<li><a href="http://www.iteye.com/magazines" target="_blank">精华</a></li>
<li><a href="http://www.iteye.com/forums" target="_blank">论坛</a></li>
<li><a href="http://www.iteye.com/ask" target="_blank">问答</a></li>
<li><a href="http://www.iteye.com/blogs" target="_blank">博客</a></li>
<li><a href="http://www.iteye.com/blogs/subjects" target="_blank">专栏</a></li>
<li><a href="http://www.iteye.com/groups" target="_blank">群组</a></li>
<li><a href="http://job.iteye.com/iteye" target="_blank">招聘</a></li>
<li><a href="http://www.iteye.com/search" target="_blank">搜索</a></li>
<li><a href="http://hllvm.group.iteye.com/index/service" target="_blank">广告服务</a></li>
<li><a href="http://webmaster.iteye.com/" target="_blank">ITeye黑板报</a></li>
<li><a href="http://hllvm.group.iteye.com/index/contactus" target="_blank">联系我们</a></li>
<li><a href="http://hllvm.group.iteye.com/index/friend_links" target="_blank">友情链接</a></li>
</ul>
<p>© 2003-2012 ITeye.com. [ <a href="http://www.miibeian.gov.cn/" target="_blank">京ICP证110151号</a> 京公网安备110105010620 ]
百联优力(北京)投资有限公司 版权所有 <img src="http://stat.iteye.com/?url=http%3A%2F%2Fhllvm.group.iteye.com%2Fgroup%2Fwiki%2F2857-JVM&amp;referrer=http%3A%2F%2Fhllvm.group.iteye.com%2Fgroup%2Fwiki%2F%3Fcategory_id%3D316&amp;user_id=" alt=""></p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/JVM/">JVM</a></li></span></span> | <span class="tags">Tagged <a href="/tags/JVM/" class="label label-primary">JVM</a><a href="/tags/Java&J2EE/" class="label label-success">Java&J2EE</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:42"datetime="2014-03-07 09:54:42"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-JVM--JVM内存管理：深入Java内存区域与OOM-高级语言虚拟机/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-JVM--JVM内存管理：深入Java内存区域与OOM-高级语言虚拟机" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE--Java字节码工具ASM在WebService开发中的应用/">Java字节码工具ASM在Web Service开发中的应用</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:42.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE--Java字节码工具ASM在WebService开发中的应用/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="java-asm-web-service-">Java字节码工具ASM在Web Service开发中的应用</h1>
<p>在基于 JAX-WS 标准的 web services 的开发中，不少实际场景都是希望采用自底向上的开发方式， 即基于已有的 Java bean 来创建 web services 。WebSphere Application Server ( 以下简称 WAS ) 提供了命令行的工具 wsgen 和相对应的 Ant task 来支持这种开发过程，而且这两个工具比较适合大型项目的自动化构建。 这两个工具的使用前提是 Java bean 中事先添加有 web services 的 Annotation 标注，而在现有的业务系统中，class 文件一般是不带 Annotation 的，这就需要开发人员去修改现有的代码，以手工方式添加 Annotation，但这样带来的工作量太大且容易出错。本文介绍了一种解决途径，可以不用修改源代码，而是利用字节码工具 ASM 直接修改 class 文件， 在字节码文件中自动注入 Annotation ，然后再利用 wsgen 工具就可以很方便地生成 web services 应用。 本文同时也总结了使用 ASM 的一些实践。</p>
<p>本文首先介绍了和 ASM 使用相关的四种文件，以及它们之间的相互转化。然后结合 web services 开发实例，介绍了使用 wsgen 开发时遇到的实际问题，如何写一个 ASM 的适配器去修改现有 class，最终如何产生 web services 文件。</p>
<p>ASM 是一个多用途的 Java 字节码操控和分析框架。它能以二进制的形式直接修改现有的类或动态生成的类。 ASM 提供了常用的转换和分析算法，是一种允许用户方便的组装定制化的复杂转换和代码分析工具。 ASM 也提供和其它的字节码工具类似的功能，但 ASM 的重点是使用的简单和高性能。由于 ASM 在设计实现的时候尽可能 的小的内存占用和提供更高的性能；因此在动态系统中使用 ASM 是很有优势的。ASM 作为一种轻量级、高性能的 Java 字节码操控和分析框架，设计了一种更有效的方法、提供更好的性能和内存占用。今天， ASM 在许多领域都有应用，并已成为事实上的字节码处理框架标准。</p>
<p><a href="">问题的引入</a></p>
<p>先写一个不带 web services 标注的 SayHelloImpl 类。
<a href=""><strong>清单 1. 不带 web services 的 SayHelloImpl 类</strong></a>1</p>
<p>public</p>
<p>class</p>
<p>SayHelloImpl {</p>
<p>2</p>
<p>public</p>
<p>String sayHello(String s) {
3</p>
<p>return</p>
<p>“Hello: ” + s ;</p>
<p>4</p>
<p>}
5</p>
<p>}</p>
<p>再用 wsgen 来创建 web services，wsgen 的使用如下：
<a href=""><strong>清单 2. wsgen 实例</strong></a>1</p>
<p>wsgen.exe – </p>
<p>cp</p>
<p>bin – s output – d output – r output – wsdl ibm.was.asm.SayHelloImpl我们将会遇到如下错误： 
<a href=""><strong>清单 3. 根据不带 web services 标注的类创建 web services 时遇到的错误信息</strong></a> 
注释处理过程中遇到问题；</p>
<p>......
com.sun.tools.internal.ws.processor.modeler.ModelerException: [failed to localiz</p>
<p>e] A web service endpoint could not be found()
        at com.sun.tools.internal.ws.processor.modeler.annotation.WebServiceAP.o</p>
<p>nError(WebServiceAP.java:215)
        at com.sun.tools.internal.ws.processor.modeler.annotation.WebServiceAP.b</p>
<p>uildModel(WebServiceAP.java:322)
        at com.sun.tools.internal.ws.processor.modeler.annotation.WebServiceAP.p</p>
<p>rocess(WebServiceAP.java:256)
        at com.sun.mirror.apt.AnnotationProcessors$CompositeAnnotationProcessor.</p>
<p>process(AnnotationProcessors.java:60)</p>
<p>注意：我们通常是在 class 前使用 @WebService， 在方法前使用 @WebMethod 来将一个类标注为 web services 的。WAS 6.1 的 web services 功能部件包和 WAS 7 都支持基于 JAX-WS 标准 的 web services 的开发， 在 WAS 安装目录的 bin 目录下提供了命令行工具 wsgen，wsgen 支持自底向上的开发方式。 下面是 wsgen 的用法：
<a href=""><strong>清单 4. wsgen 命令格式</strong></a> 
注 wsgen [options]  [SEI]</p>
<p>主要选项：</p>
<ul>
<li>-d 指定生成的 class 文件位置；</li>
<li>-s 指定生成的 Java 源文件位置；</li>
<li>-r 指定生成的 resources 文件位置，如 wsdl，xsd；</li>
<li>-cp 指定服务实现类所在的位置；</li>
<li>-wsdl，-servicename，-portname 三个参数指定生成的 wsdl 文件中的 service 和 port 的名称。</li>
</ul>
<p>SEI(Service Endpoint Interface) 是一个 endpoint implementation class，不能是一个 interface。所以首先要开发一个 endpoint 的实现类，如本例中的 SayHelloImpl 。用 @WebService 声明 web services ，然后将它编译，才能提供给 wsgen 来创建 web services 。</p>
<p><a href="">四种文件之间的转换</a></p>
<p>下面介绍本文要用到的四个概念（Java Source，Java Class，ASM Code，ASM Source）</p>
<ul>
<li>Java Source: 即我们通常编写的 Java 源文件；</li>
<li>Java Class: Java 源文件编译后的字节码文件；</li>
<li>ASM Source : 类似于对 class 反编译后的源文件，也就是 &quot;textual byte code&quot;，但比原始的 Java Source 可读性要差， 参见清单 5。</li>
<li>ASM Code: 指读写 class 文件的 ASM 程序代码。需要用到 ASM 提供的 API， 参见清单 6。
<a href=""><strong>清单 5. SayHelloImpl 类对应的 ASM Source</strong></a>01</li>
</ul>
<p>// class version 50.0 (50)</p>
<p>02</p>
<p>// access flags 33
03</p>
<p>public</p>
<p>class</p>
<p>com/ibm/was/asm/SayHelloImpl {</p>
<p>04</p>
<p>05</p>
<p>// access flags 1</p>
<p>06</p>
<p>public</p>
<p><init>()V
07</p>
<p>ALOAD </p>
<p>0</p>
<p>08</p>
<p>INVOKESPECIAL java/lang/Object. <init> ()V
09</p>
<p>RETURN</p>
<p>10</p>
<p>MAXSTACK = </p>
<p>1
11</p>
<p>MAXLOCALS = </p>
<p>1</p>
<p>12</p>
<p>13</p>
<p>// access flags 1</p>
<p>14</p>
<p>public</p>
<p>sayHello(Ljava/lang/String;)Ljava/lang/String;
15</p>
<p>NEW java/lang/StringBuilder</p>
<p>16</p>
<p>DUP
17</p>
<p>LDC </p>
<p>&quot;Hello:&quot;</p>
<p>18</p>
<p>INVOKESPECIAL java/lang/StringBuilder. <init> (Ljava/lang/String;)V
19</p>
<p>ALOAD </p>
<p>1</p>
<p>20</p>
<p>INVOKEVIRTUAL java/lang/StringBuilder.append (Ljava/lang/String;)
21</p>
<p>Ljava/lang/StringBuilder;</p>
<p>22</p>
<p>INVOKEVIRTUAL java/lang/StringBuilder.toString ()Ljava/lang/String;
23</p>
<p>ARETURN</p>
<p>24</p>
<p>MAXSTACK = </p>
<p>3
25</p>
<p>MAXLOCALS = </p>
<p>2</p>
<p>26</p>
<p>}<a href=""><strong>清单 6. 生成 SayHelloImpl.class 的 ASM Code</strong></a><a href="http://www.oschina.net/question/129540_28430#viewSource" title="view source" target="_blank">view source</a><a href="http://www.oschina.net/question/129540_28430#printSource" title="print" target="_blank">print</a><a href="http://www.oschina.net/question/129540_28430#about" title="?" target="_blank">?</a></p>
<p>01</p>
<p>package</p>
<p>asm.com.ibm.was.asm;</p>
<p>02</p>
<p>import</p>
<p>java.util./*;
03</p>
<p>import</p>
<p>org.objectweb.asm./*;</p>
<p>04</p>
<p>import</p>
<p>org.objectweb.asm.attrs./*;
05</p>
<p>public</p>
<p>class</p>
<p>SayHelloImplDump </p>
<p>implements</p>
<p>Opcodes {</p>
<p>06</p>
<p>public</p>
<p>static</p>
<p>byte</p>
<p>[] dump () </p>
<p>throws</p>
<p>Exception {
07</p>
<p>ClassWriter cw = </p>
<p>new</p>
<p>ClassWriter(</p>
<p>0</p>
<p>);</p>
<p>08</p>
<p>FieldVisitor fv;
09</p>
<p>MethodVisitor mv;</p>
<p>10</p>
<p>AnnotationVisitor av0;
11</p>
<p>12</p>
<p>cw.visit(V1_6, ACC_PUBLIC + ACC_SUPER, </p>
<p>&quot;com/ibm/was/asm/SayHelloImpl&quot;</p>
<p>,
13</p>
<p>null</p>
<p>, </p>
<p>&quot;java/lang/Object&quot;</p>
<p>, </p>
<p>null</p>
<p>);</p>
<p>14</p>
<p>15</p>
<p>{</p>
<p>16</p>
<p>mv = cw.visitMethod(ACC_PUBLIC, </p>
<p>&quot;<init>&quot;</p>
<p>, </p>
<p>&quot;()V&quot;</p>
<p>, </p>
<p>null</p>
<p>, </p>
<p>null</p>
<p>);
17</p>
<p>mv.visitCode();</p>
<p>18</p>
<p>mv.visitVarInsn(ALOAD, </p>
<p>0</p>
<p>);
19</p>
<p>mv.visitMethodInsn(INVOKESPECIAL, </p>
<p>&quot;java/lang/Object&quot;</p>
<p>, </p>
<p>&quot;<init>&quot;</p>
<p>, </p>
<p>&quot;()V&quot;</p>
<p>);</p>
<p>20</p>
<p>mv.visitInsn(RETURN);
21</p>
<p>mv.visitMaxs(</p>
<p>1</p>
<p>, </p>
<p>1</p>
<p>);</p>
<p>22</p>
<p>mv.visitEnd();
23</p>
<p>}</p>
<p>24</p>
<p>{
25</p>
<p>mv = cw.visitMethod(ACC_PUBLIC, </p>
<p>&quot;sayHello&quot;</p>
<p>,</p>
<p>26</p>
<p>&quot;(Ljava/lang/String;)Ljava/lang/String;&quot;</p>
<p>, </p>
<p>null</p>
<p>, </p>
<p>null</p>
<p>);
27</p>
<p>mv.visitCode();</p>
<p>28</p>
<p>mv.visitTypeInsn(NEW, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>);
29</p>
<p>mv.visitInsn(DUP);</p>
<p>30</p>
<p>mv.visitLdcInsn(</p>
<p>&quot;Hello:&quot;</p>
<p>);
31</p>
<p>mv.visitMethodInsn(INVOKESPECIAL, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>,</p>
<p>32</p>
<p>&quot;<init>&quot;</p>
<p>, </p>
<p>&quot;(Ljava/lang/String;)V&quot;</p>
<p>);
33</p>
<p>mv.visitVarInsn(ALOAD, </p>
<p>1</p>
<p>);</p>
<p>34</p>
<p>mv.visitMethodInsn(INVOKEVIRTUAL, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>,
35</p>
<p>&quot;append&quot;</p>
<p>, </p>
<p>&quot;(Ljava/lang/String;)Ljava/lang/StringBuilder;&quot;</p>
<p>);</p>
<p>36</p>
<p>mv.visitMethodInsn(INVOKEVIRTUAL, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>,
37</p>
<p>&quot;toString&quot;</p>
<p>, </p>
<p>&quot;()Ljava/lang/String;&quot;</p>
<p>);</p>
<p>38</p>
<p>mv.visitInsn(ARETURN);
39</p>
<p>mv.visitMaxs(</p>
<p>3</p>
<p>, </p>
<p>2</p>
<p>);</p>
<p>40</p>
<p>mv.visitEnd();
41</p>
<p>}</p>
<p>42</p>
<p>cw.visitEnd();
43</p>
<p>return</p>
<p>cw.toByteArray();</p>
<p>44</p>
<p>}
45</p>
<p>}</p>
<p>图 1 描述了 Java Source 文件、Java Class 文件、ASM Code 文件和 ASM Source 文件之间的转换关系。
<a href=""><strong>图 1. 四种文件的转换图</strong></a> 
<a href="http://static.oschina.net/uploads/img/201109/26204312_QD65.jpg" target="_blank"><img src="" alt="图 1. 四种文件的转换图"></a> </p>
<p>如图 -1 所示，Java Source 文件通过 Javac 可以转换为 Java Class 文件。而相应的 Java Class 文件通过 Java 反编译器工具可转换为 Java Source 文件；</p>
<p>通 过 ASM Code 去创建和修改 Java Class 需要对 ASM API 比较熟悉才行，一个常见的问题时，怎么用 ASM Code 生成一个我们希望的 class 文件， 也就是说， 给定了 Java Class， 怎么得到其对应的 ASM Code 呢？ 所幸的是， ASM 框架为我们提供了 ASMifierClassVisitor 工具来产生 Java Class 对应的 ASM Code。代码如下：
<a href=""><strong>清单 7. 给定 class 文件，通过 ASMifierClassVisitor 获得其对应的 ASM Code</strong></a>01</p>
<p>public</p>
<p>void</p>
<p>showClassASMProcess() {</p>
<p>02</p>
<p>ClassReader cr;
03</p>
<p>final</p>
<p>String n = SayHelloImpl.</p>
<p>class</p>
<p>.getName();</p>
<p>04</p>
<p>05</p>
<p>try</p>
<p>{</p>
<p>06</p>
<p>cr = </p>
<p>new</p>
<p>ClassReader(n);<br>07</p>
<p>cr.accept(</p>
<p>new</p>
<p>ASMifierClassVisitor(</p>
<p>new</p>
<p>PrintWriter(System.out)),</p>
<p>08</p>
<p>new</p>
<p>Attribute[</p>
<p>0</p>
<p>],
09</p>
<p>ClassReader.SKIP_DEBUG);</p>
<p>10</p>
<p>11</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {</p>
<p>12</p>
<p>e.printStackTrace();
13</p>
<p>}</p>
<p>14</p>
<p>}</p>
<p>另外一个重要的转换就是， 给定了 Java Class 文件， 如何查看它的 ASM Source ？ 这点对于我们验证 ASM Code 生成的 class 是否正确很有用。ASM 提供了另外一个工具 TraceClassVisitor， 来获得一个 Java Class 对应的 ASM Source。代码如下：
<a href=""><strong>清单 8. 利用 TraceClassVisitor 查看 class 文件的 ASM Source</strong></a>01</p>
<p>//file 是 class 文件的全路径名</p>
<p>02</p>
<p>public</p>
<p>void</p>
<p>showClassSource(String file) {
03</p>
<p>FileInputStream is ;</p>
<p>04</p>
<p>ClassReader cr; 
05</p>
<p>06</p>
<p>try</p>
<p>{
07</p>
<p>is = </p>
<p>new</p>
<p>FileInputStream(file);     </p>
<p>08</p>
<p>cr = </p>
<p>new</p>
<p>ClassReader(is);
09</p>
<p>TraceClassVisitor trace = </p>
<p>new</p>
<p>TraceClassVisitor(</p>
<p>new</p>
<p>PrintWriter(System.out));</p>
<p>10</p>
<p>cr.accept(trace, ClassReader.SKIP_DEBUG);
11</p>
<p>12</p>
<p>is.close() ;
13</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {</p>
<p>14</p>
<p>e.printStackTrace() ;
15</p>
<p>}</p>
<p>16</p>
<p>}
17</p>
<p>{</p>
<p>18</p>
<p>e.printStackTrace();
19</p>
<p>}</p>
<p>20</p>
<p>}</p>
<p><a href="">ASM 类注入</a></p>
<p>ASM 类注入是指修改一个现有的 class 文件，在其中加入自己的代码。按通常思维，我们需要利用 ASM 提供的 reader 类去读取所要修改的类文件， 找到要修改的地方，如方法名或属性名，然后在该处插入自己的代码或修改现有的代码，这种思路将使问题复杂化。 ASM 为我们提供了访问类文件的 Visitor 模式，来遍历一个 class 文件，Visitor 是一个实现 ClassVisitor 接口的类。 要注入一个 class 文件，先要找到一个合适的 Visitor 做向导， ASM 提供了好几种 Visitor， 最常用的是 ClassWriter。同时我们需要提供一个适配器类 ClassAdapter， Visitor 会带着这个 Adapter 一起去遍历， 然后在遍历过程中回调 Adapter 提供的方法。我们在 Adapter 的这些方法中就可以实现我们的修改和定制逻辑。当然，如果你不想做任何修改，那 Visitor 遍历完后将得到一个和被遍历的 class 完全一样的拷贝。
<a href=""><strong>清单 9. 类注入的完整过程</strong></a>01</p>
<p>public</p>
<p>void</p>
<p>addAnnotationToExistingClass() {</p>
<p>02</p>
<p>FileInputStream is ;
03</p>
<p>ClassReader cr;          </p>
<p>04</p>
<p>try</p>
<p>{<br>05</p>
<p>String classfile = </p>
<p>&quot;E:\SayHelloImpl.class&quot;</p>
<p>; </p>
<p>// 待遍历的类</p>
<p>06</p>
<p>showClassSource(classfile) ;  </p>
<p>// 打印该类的 ASM source
07</p>
<p>08</p>
<p>is = </p>
<p>new</p>
<p>FileInputStream(classfile);<br>09</p>
<p>cr = </p>
<p>new</p>
<p>ClassReader(is);</p>
<p>10</p>
<p>// 此处我们使用 ClassWriter 做 Visitor
11</p>
<p>ClassWriter cw = </p>
<p>new</p>
<p>ClassWriter(ClassWriter.COMPUTE_MAXS);</p>
<p>12</p>
<p>// 给 Visitor 提供一个 Adapter
13</p>
<p>AddAnnotationAdapter adapter = </p>
<p>new</p>
<p>AddAnnotationAdapter(cw);           </p>
<p>14</p>
<p>cr.accept(adapter, ClassReader.SKIP_DEBUG);<br>15</p>
<p>16</p>
<p>// 遍历完后，生成的 class 保存在字节数组中
17</p>
<p>byte</p>
<p>[] b = cw.toByteArray();</p>
<p>18</p>
<p>19</p>
<p>try</p>
<p>{</p>
<p>20</p>
<p>// 将字节数组输出到文件中
21</p>
<p>// 为了不至于覆盖掉原有的 SayHelloImpl.class 文件，我们将结果输出到 _SayHelloImpl.class</p>
<p>22</p>
<p>FileOutputStream fout = </p>
<p>new</p>
<p>FileOutputStream(</p>
<p>&quot;E:\_SayHelloImpl.class&quot;</p>
<p>);
23</p>
<p>fout.write(b) ;</p>
<p>24</p>
<p>fout.flush();
25</p>
<p>fout.close() ;</p>
<p>26</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {
27</p>
<p>e.printStackTrace() ;</p>
<p>28</p>
<p>}
29</p>
<p>30</p>
<p>// 验证 _SayHelloImpl.class 是否包含我们注入的代码
31</p>
<p>showClassSource(</p>
<p>&quot;E:\_SayHelloImpl.class&quot;</p>
<p>) ;</p>
<p>32</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {
33</p>
<p>e.printStackTrace();</p>
<p>34</p>
<p>} 
35</p>
<p>}</p>
<p><a href="">web services 标记注入过程</a></p>
<p>我们已经知道了如何往 class 中注入自己的代码，那对于一个已有的 Java bean，怎么往里注入 @WebService 和 @WebMethod 呢？根据上面我们讲的转换关系，我们可以先写一个带 annotation 的 Java Source，编译得到 Java Class， 再得到其 ASM Code。下面是利用 ASM 给一个不带任何 Annotation 的 class 添加 @WebService 和 @WebMethod 的步骤。</p>
<ol>
<li>首先在 SayHelloImpl.java 中添加 @WebService 和 @WebMethod： 
<a href=""><strong>清单 10. 带 web services 标注的 SayHelloImpl 类</strong></a>1</li>
</ol>
<p>@WebService</p>
<p>2</p>
<p>public</p>
<p>class</p>
<p>SayHelloImpl {
3</p>
<p>@WebMethod</p>
<p>4</p>
<p>public</p>
<p>String sayHello(String s) {
5</p>
<p>return</p>
<p>&quot;Hello: &quot;</p>
<ul>
<li>s ;</li>
</ul>
<p>6</p>
<p>}
7</p>
<p>}</p>
<ol>
<li>通过 ASMifierClassVisitor 工具获得 SayHelloImpl class 的 ASM Code，见清单 6。</li>
<li>写一个 ClassAdapter 类， ClassAdapter 其实也是一个 Visitor。根据 ASM Code 的提示， 我们就可以知道如何利用 ASM API 去获得我们希望的 class 文件。下面是 Adapter 的示例代码。 
<a href=""><strong>清单 11. 添加 Annotation 的 Adapter 类</strong></a>01</li>
</ol>
<p>public</p>
<p>class</p>
<p>AddAnnotationAdapter </p>
<p>extends</p>
<p>ClassAdapter </p>
<p>implements</p>
<p>Opcodes{</p>
<p>02</p>
<p>//private String annotationDesc;
03</p>
<p>private</p>
<p>boolean</p>
<p>isAnnotationPresent;</p>
<p>04</p>
<p>05</p>
<p>public</p>
<p>AddAnnotationAdapter(ClassVisitor cv) {</p>
<p>06</p>
<p>super</p>
<p>(cv);
07</p>
<p>}</p>
<p>08</p>
<p>09</p>
<p>@Override</p>
<p>10</p>
<p>public</p>
<p>void</p>
<p>visit(</p>
<p>int</p>
<p>version, </p>
<p>int</p>
<p>access, String name, String signature,
11</p>
<p>String superName, String[] interfaces) {</p>
<p>12</p>
<p>13</p>
<p>cv.visit(V1_6, ACC_PUBLIC + ACC_SUPER, name, signature, superName,</p>
<p>14</p>
<p>interfaces);
15</p>
<p>AnnotationVisitor av0;</p>
<p>16</p>
<p>av0 = cv.visitAnnotation(</p>
<p>&quot;Ljavax/jws/WebService;&quot;</p>
<p>, </p>
<p>true</p>
<p>);
17</p>
<p>av0.visitEnd();</p>
<p>18</p>
<p>}
19</p>
<p>20</p>
<p>@Override
21</p>
<p>public</p>
<p>AnnotationVisitor visitAnnotation(String desc, </p>
<p>boolean</p>
<p>visible) {</p>
<p>22</p>
<p>return</p>
<p>cv.visitAnnotation(desc, visible);
23</p>
<p>}</p>
<p>24</p>
<p>25</p>
<p>@Override</p>
<p>26</p>
<p>public</p>
<p>void</p>
<p>visitInnerClass(String name, String outerName,
27</p>
<p>String innerName, </p>
<p>int</p>
<p>access) {</p>
<p>28</p>
<p>cv.visitInnerClass(name, outerName, innerName, access);
29</p>
<p>}</p>
<p>30</p>
<p>31</p>
<p>@Override</p>
<p>32</p>
<p>public</p>
<p>FieldVisitor visitField(</p>
<p>int</p>
<p>access, String name, String desc,
33</p>
<p>String signature, Object value) {</p>
<p>34</p>
<p>return</p>
<p>cv.visitField(access, name, desc, signature, value);
35</p>
<p>}</p>
<p>36</p>
<p>37</p>
<p>@Override</p>
<p>38</p>
<p>public</p>
<p>MethodVisitor visitMethod(</p>
<p>int</p>
<p>access, String name, String desc,
39</p>
<p>String signature, String[] exceptions) {   </p>
<p>40</p>
<p>MethodVisitor mv  = cv.visitMethod(access, name, desc, signature,
41</p>
<p>exceptions);</p>
<p>42</p>
<p>if</p>
<p>(!name.equals(</p>
<p>&quot;<init>&quot;</p>
<p>)) {
43</p>
<p>AnnotationVisitor av0;</p>
<p>44</p>
<p>av0 = mv.visitAnnotation(</p>
<p>&quot;Ljavax/jws/WebMethod;&quot;</p>
<p>, </p>
<p>true</p>
<p>);
45</p>
<p>av0.visitEnd();</p>
<p>46</p>
<p>}
47</p>
<p>return</p>
<p>mv;</p>
<p>48</p>
<p>}
49</p>
<p>50</p>
<p>@Override
51</p>
<p>public</p>
<p>void</p>
<p>visitEnd() {</p>
<p>52</p>
<p>cv.visitEnd();
53</p>
<p>}</p>
<p>54</p>
<p>55</p>
<p>}</p>
<p>最后，我们采用上面讲的类注入办法，即可得到一个带 @WebService 和 @WebMethod 标注的 class 文件。再通过 wsgen 工具即可成功创建 web services，该命令将会在 src 目录下生成 web services 描述文件：SayHelloImplService.wsdl，SayHelloImplService_schema1.xsd，同时生成了 2 个 JAX-WS 文件，分别为：SayHello.java，SayHelloResponse.java。</p>
<p>当然，在实际应用中，我们可能需要将一个 class 的某些特定方法发布为 web services，这就需要我们对 Adapter 做进一步的改造，在 visitMethod() 方法中根据方法名称等参数做进一步的处理。</p>
<p><a href="">结束语</a></p>
<p>本文简要介绍了 ASM 字节码工具及其在 web services 开发中的应用。web services 的使用已经越来越广泛， 但在改造遗留系统过程中会遇到不少问题，本文针对其中一个主要问题给出了解决办法，该方法无须对现有系统做大量的改动， 即可将现存的 Java bean 转化成 web services 。本文对那些正考虑迁移到 JAX-WS 编程模型上的项目有一定的参考价值。
来源： <a href="[http://www.oschina.net/question/129540_28430](http://www.oschina.net/question/129540_28430)">[http://www.oschina.net/question/129540_28430](http://www.oschina.net/question/129540_28430)</a> </p>
<p>在基于 JAX-WS 标准的 web services 的开发中，不少实际场景都是希望采用自底向上的开发方式， 即基于已有的 Java bean 来创建 web services 。WebSphere Application Server ( 以下简称 WAS ) 提供了命令行的工具 wsgen 和相对应的 Ant task 来支持这种开发过程，而且这两个工具比较适合大型项目的自动化构建。 这两个工具的使用前提是 Java bean 中事先添加有 web services 的 Annotation 标注，而在现有的业务系统中，class 文件一般是不带 Annotation 的，这就需要开发人员去修改现有的代码，以手工方式添加 Annotation，但这样带来的工作量太大且容易出错。本文介绍了一种解决途径，可以不用修改源代码，而是利用字节码工具 ASM 直接修改 class 文件， 在字节码文件中自动注入 Annotation ，然后再利用 wsgen 工具就可以很方便地生成 web services 应用。 本文同时也总结了使用 ASM 的一些实践。</p>
<p>本文首先介绍了和 ASM 使用相关的四种文件，以及它们之间的相互转化。然后结合 web services 开发实例，介绍了使用 wsgen 开发时遇到的实际问题，如何写一个 ASM 的适配器去修改现有 class，最终如何产生 web services 文件。</p>
<p>ASM 是一个多用途的 Java 字节码操控和分析框架。它能以二进制的形式直接修改现有的类或动态生成的类。 ASM 提供了常用的转换和分析算法，是一种允许用户方便的组装定制化的复杂转换和代码分析工具。 ASM 也提供和其它的字节码工具类似的功能，但 ASM 的重点是使用的简单和高性能。由于 ASM 在设计实现的时候尽可能 的小的内存占用和提供更高的性能；因此在动态系统中使用 ASM 是很有优势的。ASM 作为一种轻量级、高性能的 Java 字节码操控和分析框架，设计了一种更有效的方法、提供更好的性能和内存占用。今天， ASM 在许多领域都有应用，并已成为事实上的字节码处理框架标准。</p>
<p><a href="">问题的引入</a></p>
<p>先写一个不带 web services 标注的 SayHelloImpl 类。
<a href=""><strong>清单 1. 不带 web services 的 SayHelloImpl 类</strong></a>1</p>
<p>public</p>
<p>class</p>
<p>SayHelloImpl {</p>
<p>2</p>
<p>public</p>
<p>String sayHello(String s) {
3</p>
<p>return</p>
<p>“Hello: ” + s ;</p>
<p>4</p>
<p>}
5</p>
<p>}</p>
<p>再用 wsgen 来创建 web services，wsgen 的使用如下：
<a href=""><strong>清单 2. wsgen 实例</strong></a>1</p>
<p>wsgen.exe – </p>
<p>cp</p>
<p>bin – s output – d output – r output – wsdl ibm.was.asm.SayHelloImpl我们将会遇到如下错误： 
<a href=""><strong>清单 3. 根据不带 web services 标注的类创建 web services 时遇到的错误信息</strong></a> 
注释处理过程中遇到问题；</p>
<p>......
com.sun.tools.internal.ws.processor.modeler.ModelerException: [failed to localiz</p>
<p>e] A web service endpoint could not be found()
        at com.sun.tools.internal.ws.processor.modeler.annotation.WebServiceAP.o</p>
<p>nError(WebServiceAP.java:215)
        at com.sun.tools.internal.ws.processor.modeler.annotation.WebServiceAP.b</p>
<p>uildModel(WebServiceAP.java:322)
        at com.sun.tools.internal.ws.processor.modeler.annotation.WebServiceAP.p</p>
<p>rocess(WebServiceAP.java:256)
        at com.sun.mirror.apt.AnnotationProcessors$CompositeAnnotationProcessor.</p>
<p>process(AnnotationProcessors.java:60)</p>
<p>注意：我们通常是在 class 前使用 @WebService， 在方法前使用 @WebMethod 来将一个类标注为 web services 的。WAS 6.1 的 web services 功能部件包和 WAS 7 都支持基于 JAX-WS 标准 的 web services 的开发， 在 WAS 安装目录的 bin 目录下提供了命令行工具 wsgen，wsgen 支持自底向上的开发方式。 下面是 wsgen 的用法：
<a href=""><strong>清单 4. wsgen 命令格式</strong></a> 
注 wsgen [options]  [SEI]</p>
<p>主要选项：</p>
<ul>
<li>-d 指定生成的 class 文件位置；</li>
<li>-s 指定生成的 Java 源文件位置；</li>
<li>-r 指定生成的 resources 文件位置，如 wsdl，xsd；</li>
<li>-cp 指定服务实现类所在的位置；</li>
<li>-wsdl，-servicename，-portname 三个参数指定生成的 wsdl 文件中的 service 和 port 的名称。</li>
</ul>
<p>SEI(Service Endpoint Interface) 是一个 endpoint implementation class，不能是一个 interface。所以首先要开发一个 endpoint 的实现类，如本例中的 SayHelloImpl 。用 @WebService 声明 web services ，然后将它编译，才能提供给 wsgen 来创建 web services 。</p>
<p><a href="">四种文件之间的转换</a></p>
<p>下面介绍本文要用到的四个概念（Java Source，Java Class，ASM Code，ASM Source）</p>
<ul>
<li>Java Source: 即我们通常编写的 Java 源文件；</li>
<li>Java Class: Java 源文件编译后的字节码文件；</li>
<li>ASM Source : 类似于对 class 反编译后的源文件，也就是 &quot;textual byte code&quot;，但比原始的 Java Source 可读性要差， 参见清单 5。</li>
<li>ASM Code: 指读写 class 文件的 ASM 程序代码。需要用到 ASM 提供的 API， 参见清单 6。
<a href=""><strong>清单 5. SayHelloImpl 类对应的 ASM Source</strong></a>01</li>
</ul>
<p>// class version 50.0 (50)</p>
<p>02</p>
<p>// access flags 33
03</p>
<p>public</p>
<p>class</p>
<p>com/ibm/was/asm/SayHelloImpl {</p>
<p>04</p>
<p>05</p>
<p>// access flags 1</p>
<p>06</p>
<p>public</p>
<p><init>()V
07</p>
<p>ALOAD </p>
<p>0</p>
<p>08</p>
<p>INVOKESPECIAL java/lang/Object. <init> ()V
09</p>
<p>RETURN</p>
<p>10</p>
<p>MAXSTACK = </p>
<p>1
11</p>
<p>MAXLOCALS = </p>
<p>1</p>
<p>12</p>
<p>13</p>
<p>// access flags 1</p>
<p>14</p>
<p>public</p>
<p>sayHello(Ljava/lang/String;)Ljava/lang/String;
15</p>
<p>NEW java/lang/StringBuilder</p>
<p>16</p>
<p>DUP
17</p>
<p>LDC </p>
<p>&quot;Hello:&quot;</p>
<p>18</p>
<p>INVOKESPECIAL java/lang/StringBuilder. <init> (Ljava/lang/String;)V
19</p>
<p>ALOAD </p>
<p>1</p>
<p>20</p>
<p>INVOKEVIRTUAL java/lang/StringBuilder.append (Ljava/lang/String;)
21</p>
<p>Ljava/lang/StringBuilder;</p>
<p>22</p>
<p>INVOKEVIRTUAL java/lang/StringBuilder.toString ()Ljava/lang/String;
23</p>
<p>ARETURN</p>
<p>24</p>
<p>MAXSTACK = </p>
<p>3
25</p>
<p>MAXLOCALS = </p>
<p>2</p>
<p>26</p>
<p>}<a href=""><strong>清单 6. 生成 SayHelloImpl.class 的 ASM Code</strong></a>01</p>
<p>package</p>
<p>asm.com.ibm.was.asm;</p>
<p>02</p>
<p>import</p>
<p>java.util./*;
03</p>
<p>import</p>
<p>org.objectweb.asm./*;</p>
<p>04</p>
<p>import</p>
<p>org.objectweb.asm.attrs./*;
05</p>
<p>public</p>
<p>class</p>
<p>SayHelloImplDump </p>
<p>implements</p>
<p>Opcodes {</p>
<p>06</p>
<p>public</p>
<p>static</p>
<p>byte</p>
<p>[] dump () </p>
<p>throws</p>
<p>Exception {
07</p>
<p>ClassWriter cw = </p>
<p>new</p>
<p>ClassWriter(</p>
<p>0</p>
<p>);</p>
<p>08</p>
<p>FieldVisitor fv;
09</p>
<p>MethodVisitor mv;</p>
<p>10</p>
<p>AnnotationVisitor av0;
11</p>
<p>12</p>
<p>cw.visit(V1_6, ACC_PUBLIC + ACC_SUPER, </p>
<p>&quot;com/ibm/was/asm/SayHelloImpl&quot;</p>
<p>,
13</p>
<p>null</p>
<p>, </p>
<p>&quot;java/lang/Object&quot;</p>
<p>, </p>
<p>null</p>
<p>);</p>
<p>14</p>
<p>15</p>
<p>{</p>
<p>16</p>
<p>mv = cw.visitMethod(ACC_PUBLIC, </p>
<p>&quot;<init>&quot;</p>
<p>, </p>
<p>&quot;()V&quot;</p>
<p>, </p>
<p>null</p>
<p>, </p>
<p>null</p>
<p>);
17</p>
<p>mv.visitCode();</p>
<p>18</p>
<p>mv.visitVarInsn(ALOAD, </p>
<p>0</p>
<p>);
19</p>
<p>mv.visitMethodInsn(INVOKESPECIAL, </p>
<p>&quot;java/lang/Object&quot;</p>
<p>, </p>
<p>&quot;<init>&quot;</p>
<p>, </p>
<p>&quot;()V&quot;</p>
<p>);</p>
<p>20</p>
<p>mv.visitInsn(RETURN);
21</p>
<p>mv.visitMaxs(</p>
<p>1</p>
<p>, </p>
<p>1</p>
<p>);</p>
<p>22</p>
<p>mv.visitEnd();
23</p>
<p>}</p>
<p>24</p>
<p>{
25</p>
<p>mv = cw.visitMethod(ACC_PUBLIC, </p>
<p>&quot;sayHello&quot;</p>
<p>,</p>
<p>26</p>
<p>&quot;(Ljava/lang/String;)Ljava/lang/String;&quot;</p>
<p>, </p>
<p>null</p>
<p>, </p>
<p>null</p>
<p>);
27</p>
<p>mv.visitCode();</p>
<p>28</p>
<p>mv.visitTypeInsn(NEW, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>);
29</p>
<p>mv.visitInsn(DUP);</p>
<p>30</p>
<p>mv.visitLdcInsn(</p>
<p>&quot;Hello:&quot;</p>
<p>);
31</p>
<p>mv.visitMethodInsn(INVOKESPECIAL, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>,</p>
<p>32</p>
<p>&quot;<init>&quot;</p>
<p>, </p>
<p>&quot;(Ljava/lang/String;)V&quot;</p>
<p>);
33</p>
<p>mv.visitVarInsn(ALOAD, </p>
<p>1</p>
<p>);</p>
<p>34</p>
<p>mv.visitMethodInsn(INVOKEVIRTUAL, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>,
35</p>
<p>&quot;append&quot;</p>
<p>, </p>
<p>&quot;(Ljava/lang/String;)Ljava/lang/StringBuilder;&quot;</p>
<p>);</p>
<p>36</p>
<p>mv.visitMethodInsn(INVOKEVIRTUAL, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>,
37</p>
<p>&quot;toString&quot;</p>
<p>, </p>
<p>&quot;()Ljava/lang/String;&quot;</p>
<p>);</p>
<p>38</p>
<p>mv.visitInsn(ARETURN);
39</p>
<p>mv.visitMaxs(</p>
<p>3</p>
<p>, </p>
<p>2</p>
<p>);</p>
<p>40</p>
<p>mv.visitEnd();
41</p>
<p>}</p>
<p>42</p>
<p>cw.visitEnd();
43</p>
<p>return</p>
<p>cw.toByteArray();</p>
<p>44</p>
<p>}
45</p>
<p>}</p>
<p>图 1 描述了 Java Source 文件、Java Class 文件、ASM Code 文件和 ASM Source 文件之间的转换关系。
<a href=""><strong>图 1. 四种文件的转换图</strong></a> 
<a href=""><img src="" alt="图 1. 四种文件的转换图"></a> </p>
<p>如图 -1 所示，Java Source 文件通过 Javac 可以转换为 Java Class 文件。而相应的 Java Class 文件通过 Java 反编译器工具可转换为 Java Source 文件；</p>
<p>通 过 ASM Code 去创建和修改 Java Class 需要对 ASM API 比较熟悉才行，一个常见的问题时，怎么用 ASM Code 生成一个我们希望的 class 文件， 也就是说， 给定了 Java Class， 怎么得到其对应的 ASM Code 呢？ 所幸的是， ASM 框架为我们提供了 ASMifierClassVisitor 工具来产生 Java Class 对应的 ASM Code。代码如下：
<a href=""><strong>清单 7. 给定 class 文件，通过 ASMifierClassVisitor 获得其对应的 ASM Code</strong></a><a href="http://www.oschina.net/question/129540_28430#viewSource" title="view source" target="_blank">view source</a><a href="http://www.oschina.net/question/129540_28430#printSource" title="print" target="_blank">print</a><a href="http://www.oschina.net/question/129540_28430#about" title="?" target="_blank">?</a></p>
<p>01</p>
<p>public</p>
<p>void</p>
<p>showClassASMProcess() {</p>
<p>02</p>
<p>ClassReader cr;
03</p>
<p>final</p>
<p>String n = SayHelloImpl.</p>
<p>class</p>
<p>.getName();</p>
<p>04</p>
<p>05</p>
<p>try</p>
<p>{</p>
<p>06</p>
<p>cr = </p>
<p>new</p>
<p>ClassReader(n);<br>07</p>
<p>cr.accept(</p>
<p>new</p>
<p>ASMifierClassVisitor(</p>
<p>new</p>
<p>PrintWriter(System.out)),</p>
<p>08</p>
<p>new</p>
<p>Attribute[</p>
<p>0</p>
<p>],
09</p>
<p>ClassReader.SKIP_DEBUG);</p>
<p>10</p>
<p>11</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {</p>
<p>12</p>
<p>e.printStackTrace();
13</p>
<p>}</p>
<p>14</p>
<p>}</p>
<p>另外一个重要的转换就是， 给定了 Java Class 文件， 如何查看它的 ASM Source ？ 这点对于我们验证 ASM Code 生成的 class 是否正确很有用。ASM 提供了另外一个工具 TraceClassVisitor， 来获得一个 Java Class 对应的 ASM Source。代码如下：
<a href=""><strong>清单 8. 利用 TraceClassVisitor 查看 class 文件的 ASM Source</strong></a>01</p>
<p>//file 是 class 文件的全路径名</p>
<p>02</p>
<p>public</p>
<p>void</p>
<p>showClassSource(String file) {
03</p>
<p>FileInputStream is ;</p>
<p>04</p>
<p>ClassReader cr; 
05</p>
<p>06</p>
<p>try</p>
<p>{
07</p>
<p>is = </p>
<p>new</p>
<p>FileInputStream(file);     </p>
<p>08</p>
<p>cr = </p>
<p>new</p>
<p>ClassReader(is);
09</p>
<p>TraceClassVisitor trace = </p>
<p>new</p>
<p>TraceClassVisitor(</p>
<p>new</p>
<p>PrintWriter(System.out));</p>
<p>10</p>
<p>cr.accept(trace, ClassReader.SKIP_DEBUG);
11</p>
<p>12</p>
<p>is.close() ;
13</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {</p>
<p>14</p>
<p>e.printStackTrace() ;
15</p>
<p>}</p>
<p>16</p>
<p>}
17</p>
<p>{</p>
<p>18</p>
<p>e.printStackTrace();
19</p>
<p>}</p>
<p>20</p>
<p>}</p>
<p><a href="">ASM 类注入</a></p>
<p>ASM 类注入是指修改一个现有的 class 文件，在其中加入自己的代码。按通常思维，我们需要利用 ASM 提供的 reader 类去读取所要修改的类文件， 找到要修改的地方，如方法名或属性名，然后在该处插入自己的代码或修改现有的代码，这种思路将使问题复杂化。 ASM 为我们提供了访问类文件的 Visitor 模式，来遍历一个 class 文件，Visitor 是一个实现 ClassVisitor 接口的类。 要注入一个 class 文件，先要找到一个合适的 Visitor 做向导， ASM 提供了好几种 Visitor， 最常用的是 ClassWriter。同时我们需要提供一个适配器类 ClassAdapter， Visitor 会带着这个 Adapter 一起去遍历， 然后在遍历过程中回调 Adapter 提供的方法。我们在 Adapter 的这些方法中就可以实现我们的修改和定制逻辑。当然，如果你不想做任何修改，那 Visitor 遍历完后将得到一个和被遍历的 class 完全一样的拷贝。
<a href=""><strong>清单 9. 类注入的完整过程</strong></a>01</p>
<p>public</p>
<p>void</p>
<p>addAnnotationToExistingClass() {</p>
<p>02</p>
<p>FileInputStream is ;
03</p>
<p>ClassReader cr;          </p>
<p>04</p>
<p>try</p>
<p>{<br>05</p>
<p>String classfile = </p>
<p>&quot;E:\SayHelloImpl.class&quot;</p>
<p>; </p>
<p>// 待遍历的类</p>
<p>06</p>
<p>showClassSource(classfile) ;  </p>
<p>// 打印该类的 ASM source
07</p>
<p>08</p>
<p>is = </p>
<p>new</p>
<p>FileInputStream(classfile);<br>09</p>
<p>cr = </p>
<p>new</p>
<p>ClassReader(is);</p>
<p>10</p>
<p>// 此处我们使用 ClassWriter 做 Visitor
11</p>
<p>ClassWriter cw = </p>
<p>new</p>
<p>ClassWriter(ClassWriter.COMPUTE_MAXS);</p>
<p>12</p>
<p>// 给 Visitor 提供一个 Adapter
13</p>
<p>AddAnnotationAdapter adapter = </p>
<p>new</p>
<p>AddAnnotationAdapter(cw);           </p>
<p>14</p>
<p>cr.accept(adapter, ClassReader.SKIP_DEBUG);<br>15</p>
<p>16</p>
<p>// 遍历完后，生成的 class 保存在字节数组中
17</p>
<p>byte</p>
<p>[] b = cw.toByteArray();</p>
<p>18</p>
<p>19</p>
<p>try</p>
<p>{</p>
<p>20</p>
<p>// 将字节数组输出到文件中
21</p>
<p>// 为了不至于覆盖掉原有的 SayHelloImpl.class 文件，我们将结果输出到 _SayHelloImpl.class</p>
<p>22</p>
<p>FileOutputStream fout = </p>
<p>new</p>
<p>FileOutputStream(</p>
<p>&quot;E:\_SayHelloImpl.class&quot;</p>
<p>);
23</p>
<p>fout.write(b) ;</p>
<p>24</p>
<p>fout.flush();
25</p>
<p>fout.close() ;</p>
<p>26</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {
27</p>
<p>e.printStackTrace() ;</p>
<p>28</p>
<p>}
29</p>
<p>30</p>
<p>// 验证 _SayHelloImpl.class 是否包含我们注入的代码
31</p>
<p>showClassSource(</p>
<p>&quot;E:\_SayHelloImpl.class&quot;</p>
<p>) ;</p>
<p>32</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {
33</p>
<p>e.printStackTrace();</p>
<p>34</p>
<p>} 
35</p>
<p>}</p>
<p><a href="">web services 标记注入过程</a></p>
<p>我们已经知道了如何往 class 中注入自己的代码，那对于一个已有的 Java bean，怎么往里注入 @WebService 和 @WebMethod 呢？根据上面我们讲的转换关系，我们可以先写一个带 annotation 的 Java Source，编译得到 Java Class， 再得到其 ASM Code。下面是利用 ASM 给一个不带任何 Annotation 的 class 添加 @WebService 和 @WebMethod 的步骤。</p>
<ol>
<li>首先在 SayHelloImpl.java 中添加 @WebService 和 @WebMethod： 
<a href=""><strong>清单 10. 带 web services 标注的 SayHelloImpl 类</strong></a>1</li>
</ol>
<p>@WebService</p>
<p>2</p>
<p>public</p>
<p>class</p>
<p>SayHelloImpl {
3</p>
<p>@WebMethod</p>
<p>4</p>
<p>public</p>
<p>String sayHello(String s) {
5</p>
<p>return</p>
<p>&quot;Hello: &quot;</p>
<ul>
<li>s ;</li>
</ul>
<p>6</p>
<p>}
7</p>
<p>}</p>
<ol>
<li>通过 ASMifierClassVisitor 工具获得 SayHelloImpl class 的 ASM Code，见清单 6。</li>
<li>写一个 ClassAdapter 类， ClassAdapter 其实也是一个 Visitor。根据 ASM Code 的提示， 我们就可以知道如何利用 ASM API 去获得我们希望的 class 文件。下面是 Adapter 的示例代码。 
<a href=""><strong>清单 11. 添加 Annotation 的 Adapter 类</strong></a>01</li>
</ol>
<p>public</p>
<p>class</p>
<p>AddAnnotationAdapter </p>
<p>extends</p>
<p>ClassAdapter </p>
<p>implements</p>
<p>Opcodes{</p>
<p>02</p>
<p>//private String annotationDesc;
03</p>
<p>private</p>
<p>boolean</p>
<p>isAnnotationPresent;</p>
<p>04</p>
<p>05</p>
<p>public</p>
<p>AddAnnotationAdapter(ClassVisitor cv) {</p>
<p>06</p>
<p>super</p>
<p>(cv);
07</p>
<p>}</p>
<p>08</p>
<p>09</p>
<p>@Override</p>
<p>10</p>
<p>public</p>
<p>void</p>
<p>visit(</p>
<p>int</p>
<p>version, </p>
<p>int</p>
<p>access, String name, String signature,
11</p>
<p>String superName, String[] interfaces) {</p>
<p>12</p>
<p>13</p>
<p>cv.visit(V1_6, ACC_PUBLIC + ACC_SUPER, name, signature, superName,</p>
<p>14</p>
<p>interfaces);
15</p>
<p>AnnotationVisitor av0;</p>
<p>16</p>
<p>av0 = cv.visitAnnotation(</p>
<p>&quot;Ljavax/jws/WebService;&quot;</p>
<p>, </p>
<p>true</p>
<p>);
17</p>
<p>av0.visitEnd();</p>
<p>18</p>
<p>}
19</p>
<p>20</p>
<p>@Override
21</p>
<p>public</p>
<p>AnnotationVisitor visitAnnotation(String desc, </p>
<p>boolean</p>
<p>visible) {</p>
<p>22</p>
<p>return</p>
<p>cv.visitAnnotation(desc, visible);
23</p>
<p>}</p>
<p>24</p>
<p>25</p>
<p>@Override</p>
<p>26</p>
<p>public</p>
<p>void</p>
<p>visitInnerClass(String name, String outerName,
27</p>
<p>String innerName, </p>
<p>int</p>
<p>access) {</p>
<p>28</p>
<p>cv.visitInnerClass(name, outerName, innerName, access);
29</p>
<p>}</p>
<p>30</p>
<p>31</p>
<p>@Override</p>
<p>32</p>
<p>public</p>
<p>FieldVisitor visitField(</p>
<p>int</p>
<p>access, String name, String desc,
33</p>
<p>String signature, Object value) {</p>
<p>34</p>
<p>return</p>
<p>cv.visitField(access, name, desc, signature, value);
35</p>
<p>}</p>
<p>36</p>
<p>37</p>
<p>@Override</p>
<p>38</p>
<p>public</p>
<p>MethodVisitor visitMethod(</p>
<p>int</p>
<p>access, String name, String desc,
39</p>
<p>String signature, String[] exceptions) {   </p>
<p>40</p>
<p>MethodVisitor mv  = cv.visitMethod(access, name, desc, signature,
41</p>
<p>exceptions);</p>
<p>42</p>
<p>if</p>
<p>(!name.equals(</p>
<p>&quot;<init>&quot;</p>
<p>)) {
43</p>
<p>AnnotationVisitor av0;</p>
<p>44</p>
<p>av0 = mv.visitAnnotation(</p>
<p>&quot;Ljavax/jws/WebMethod;&quot;</p>
<p>, </p>
<p>true</p>
<p>);
45</p>
<p>av0.visitEnd();</p>
<p>46</p>
<p>}
47</p>
<p>return</p>
<p>mv;</p>
<p>48</p>
<p>}
49</p>
<p>50</p>
<p>@Override
51</p>
<p>public</p>
<p>void</p>
<p>visitEnd() {</p>
<p>52</p>
<p>cv.visitEnd();
53</p>
<p>}</p>
<p>54</p>
<p>55</p>
<p>}</p>
<p>最后，我们采用上面讲的类注入办法，即可得到一个带 @WebService 和 @WebMethod 标注的 class 文件。再通过 wsgen 工具即可成功创建 web services，该命令将会在 src 目录下生成 web services 描述文件：SayHelloImplService.wsdl，SayHelloImplService_schema1.xsd，同时生成了 2 个 JAX-WS 文件，分别为：SayHello.java，SayHelloResponse.java。</p>
<p>当然，在实际应用中，我们可能需要将一个 class 的某些特定方法发布为 web services，这就需要我们对 Adapter 做进一步的改造，在 visitMethod() 方法中根据方法名称等参数做进一步的处理。</p>
<p><a href="">结束语</a></p>
<p>本文简要介绍了 ASM 字节码工具及其在 web services 开发中的应用。web services 的使用已经越来越广泛， 但在改造遗留系统过程中会遇到不少问题，本文针对其中一个主要问题给出了解决办法，该方法无须对现有系统做大量的改动， 即可将现存的 Java bean 转化成 web services 。本文对那些正考虑迁移到 JAX-WS 编程模型上的项目有一定的参考价值。在基于 JAX-WS 标准的 web services 的开发中，不少实际场景都是希望采用自底向上的开发方式， 即基于已有的 Java bean 来创建 web services 。WebSphere Application Server ( 以下简称 WAS ) 提供了命令行的工具 wsgen 和相对应的 Ant task 来支持这种开发过程，而且这两个工具比较适合大型项目的自动化构建。 这两个工具的使用前提是 Java bean 中事先添加有 web services 的 Annotation 标注，而在现有的业务系统中，class 文件一般是不带 Annotation 的，这就需要开发人员去修改现有的代码，以手工方式添加 Annotation，但这样带来的工作量太大且容易出错。本文介绍了一种解决途径，可以不用修改源代码，而是利用字节码工具 ASM 直接修改 class 文件， 在字节码文件中自动注入 Annotation ，然后再利用 wsgen 工具就可以很方便地生成 web services 应用。 本文同时也总结了使用 ASM 的一些实践。</p>
<p>本文首先介绍了和 ASM 使用相关的四种文件，以及它们之间的相互转化。然后结合 web services 开发实例，介绍了使用 wsgen 开发时遇到的实际问题，如何写一个 ASM 的适配器去修改现有 class，最终如何产生 web services 文件。</p>
<p>ASM 是一个多用途的 Java 字节码操控和分析框架。它能以二进制的形式直接修改现有的类或动态生成的类。 ASM 提供了常用的转换和分析算法，是一种允许用户方便的组装定制化的复杂转换和代码分析工具。 ASM 也提供和其它的字节码工具类似的功能，但 ASM 的重点是使用的简单和高性能。由于 ASM 在设计实现的时候尽可能 的小的内存占用和提供更高的性能；因此在动态系统中使用 ASM 是很有优势的。ASM 作为一种轻量级、高性能的 Java 字节码操控和分析框架，设计了一种更有效的方法、提供更好的性能和内存占用。今天， ASM 在许多领域都有应用，并已成为事实上的字节码处理框架标准。</p>
<p><a href="">问题的引入</a></p>
<p>先写一个不带 web services 标注的 SayHelloImpl 类。
<a href=""><strong>清单 1. 不带 web services 的 SayHelloImpl 类</strong></a>1</p>
<p>public</p>
<p>class</p>
<p>SayHelloImpl {</p>
<p>2</p>
<p>public</p>
<p>String sayHello(String s) {
3</p>
<p>return</p>
<p>“Hello: ” + s ;</p>
<p>4</p>
<p>}
5</p>
<p>}</p>
<p>再用 wsgen 来创建 web services，wsgen 的使用如下：
<a href=""><strong>清单 2. wsgen 实例</strong></a>1</p>
<p>wsgen.exe – </p>
<p>cp</p>
<p>bin – s output – d output – r output – wsdl ibm.was.asm.SayHelloImpl我们将会遇到如下错误： 
<a href=""><strong>清单 3. 根据不带 web services 标注的类创建 web services 时遇到的错误信息</strong></a> 
注释处理过程中遇到问题；</p>
<p>......
com.sun.tools.internal.ws.processor.modeler.ModelerException: [failed to localiz</p>
<p>e] A web service endpoint could not be found()
        at com.sun.tools.internal.ws.processor.modeler.annotation.WebServiceAP.o</p>
<p>nError(WebServiceAP.java:215)
        at com.sun.tools.internal.ws.processor.modeler.annotation.WebServiceAP.b</p>
<p>uildModel(WebServiceAP.java:322)
        at com.sun.tools.internal.ws.processor.modeler.annotation.WebServiceAP.p</p>
<p>rocess(WebServiceAP.java:256)
        at com.sun.mirror.apt.AnnotationProcessors$CompositeAnnotationProcessor.</p>
<p>process(AnnotationProcessors.java:60)</p>
<p>注意：我们通常是在 class 前使用 @WebService， 在方法前使用 @WebMethod 来将一个类标注为 web services 的。WAS 6.1 的 web services 功能部件包和 WAS 7 都支持基于 JAX-WS 标准 的 web services 的开发， 在 WAS 安装目录的 bin 目录下提供了命令行工具 wsgen，wsgen 支持自底向上的开发方式。 下面是 wsgen 的用法：
<a href=""><strong>清单 4. wsgen 命令格式</strong></a> 
注 wsgen [options]  [SEI]</p>
<p>主要选项：</p>
<ul>
<li>-d 指定生成的 class 文件位置；</li>
<li>-s 指定生成的 Java 源文件位置；</li>
<li>-r 指定生成的 resources 文件位置，如 wsdl，xsd；</li>
<li>-cp 指定服务实现类所在的位置；</li>
<li>-wsdl，-servicename，-portname 三个参数指定生成的 wsdl 文件中的 service 和 port 的名称。</li>
</ul>
<p>SEI(Service Endpoint Interface) 是一个 endpoint implementation class，不能是一个 interface。所以首先要开发一个 endpoint 的实现类，如本例中的 SayHelloImpl 。用 @WebService 声明 web services ，然后将它编译，才能提供给 wsgen 来创建 web services 。</p>
<p><a href="">四种文件之间的转换</a></p>
<p>下面介绍本文要用到的四个概念（Java Source，Java Class，ASM Code，ASM Source）</p>
<ul>
<li>Java Source: 即我们通常编写的 Java 源文件；</li>
<li>Java Class: Java 源文件编译后的字节码文件；</li>
<li>ASM Source : 类似于对 class 反编译后的源文件，也就是 &quot;textual byte code&quot;，但比原始的 Java Source 可读性要差， 参见清单 5。</li>
<li>ASM Code: 指读写 class 文件的 ASM 程序代码。需要用到 ASM 提供的 API， 参见清单 6。
<a href=""><strong>清单 5. SayHelloImpl 类对应的 ASM Source</strong></a>01</li>
</ul>
<p>// class version 50.0 (50)</p>
<p>02</p>
<p>// access flags 33
03</p>
<p>public</p>
<p>class</p>
<p>com/ibm/was/asm/SayHelloImpl {</p>
<p>04</p>
<p>05</p>
<p>// access flags 1</p>
<p>06</p>
<p>public</p>
<p><init>()V
07</p>
<p>ALOAD </p>
<p>0</p>
<p>08</p>
<p>INVOKESPECIAL java/lang/Object. <init> ()V
09</p>
<p>RETURN</p>
<p>10</p>
<p>MAXSTACK = </p>
<p>1
11</p>
<p>MAXLOCALS = </p>
<p>1</p>
<p>12</p>
<p>13</p>
<p>// access flags 1</p>
<p>14</p>
<p>public</p>
<p>sayHello(Ljava/lang/String;)Ljava/lang/String;
15</p>
<p>NEW java/lang/StringBuilder</p>
<p>16</p>
<p>DUP
17</p>
<p>LDC </p>
<p>&quot;Hello:&quot;</p>
<p>18</p>
<p>INVOKESPECIAL java/lang/StringBuilder. <init> (Ljava/lang/String;)V
19</p>
<p>ALOAD </p>
<p>1</p>
<p>20</p>
<p>INVOKEVIRTUAL java/lang/StringBuilder.append (Ljava/lang/String;)
21</p>
<p>Ljava/lang/StringBuilder;</p>
<p>22</p>
<p>INVOKEVIRTUAL java/lang/StringBuilder.toString ()Ljava/lang/String;
23</p>
<p>ARETURN</p>
<p>24</p>
<p>MAXSTACK = </p>
<p>3
25</p>
<p>MAXLOCALS = </p>
<p>2</p>
<p>26</p>
<p>}<a href=""><strong>清单 6. 生成 SayHelloImpl.class 的 ASM Code</strong></a>01</p>
<p>package</p>
<p>asm.com.ibm.was.asm;</p>
<p>02</p>
<p>import</p>
<p>java.util./*;
03</p>
<p>import</p>
<p>org.objectweb.asm./*;</p>
<p>04</p>
<p>import</p>
<p>org.objectweb.asm.attrs./*;
05</p>
<p>public</p>
<p>class</p>
<p>SayHelloImplDump </p>
<p>implements</p>
<p>Opcodes {</p>
<p>06</p>
<p>public</p>
<p>static</p>
<p>byte</p>
<p>[] dump () </p>
<p>throws</p>
<p>Exception {
07</p>
<p>ClassWriter cw = </p>
<p>new</p>
<p>ClassWriter(</p>
<p>0</p>
<p>);</p>
<p>08</p>
<p>FieldVisitor fv;
09</p>
<p>MethodVisitor mv;</p>
<p>10</p>
<p>AnnotationVisitor av0;
11</p>
<p>12</p>
<p>cw.visit(V1_6, ACC_PUBLIC + ACC_SUPER, </p>
<p>&quot;com/ibm/was/asm/SayHelloImpl&quot;</p>
<p>,
13</p>
<p>null</p>
<p>, </p>
<p>&quot;java/lang/Object&quot;</p>
<p>, </p>
<p>null</p>
<p>);</p>
<p>14</p>
<p>15</p>
<p>{</p>
<p>16</p>
<p>mv = cw.visitMethod(ACC_PUBLIC, </p>
<p>&quot;<init>&quot;</p>
<p>, </p>
<p>&quot;()V&quot;</p>
<p>, </p>
<p>null</p>
<p>, </p>
<p>null</p>
<p>);
17</p>
<p>mv.visitCode();</p>
<p>18</p>
<p>mv.visitVarInsn(ALOAD, </p>
<p>0</p>
<p>);
19</p>
<p>mv.visitMethodInsn(INVOKESPECIAL, </p>
<p>&quot;java/lang/Object&quot;</p>
<p>, </p>
<p>&quot;<init>&quot;</p>
<p>, </p>
<p>&quot;()V&quot;</p>
<p>);</p>
<p>20</p>
<p>mv.visitInsn(RETURN);
21</p>
<p>mv.visitMaxs(</p>
<p>1</p>
<p>, </p>
<p>1</p>
<p>);</p>
<p>22</p>
<p>mv.visitEnd();
23</p>
<p>}</p>
<p>24</p>
<p>{
25</p>
<p>mv = cw.visitMethod(ACC_PUBLIC, </p>
<p>&quot;sayHello&quot;</p>
<p>,</p>
<p>26</p>
<p>&quot;(Ljava/lang/String;)Ljava/lang/String;&quot;</p>
<p>, </p>
<p>null</p>
<p>, </p>
<p>null</p>
<p>);
27</p>
<p>mv.visitCode();</p>
<p>28</p>
<p>mv.visitTypeInsn(NEW, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>);
29</p>
<p>mv.visitInsn(DUP);</p>
<p>30</p>
<p>mv.visitLdcInsn(</p>
<p>&quot;Hello:&quot;</p>
<p>);
31</p>
<p>mv.visitMethodInsn(INVOKESPECIAL, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>,</p>
<p>32</p>
<p>&quot;<init>&quot;</p>
<p>, </p>
<p>&quot;(Ljava/lang/String;)V&quot;</p>
<p>);
33</p>
<p>mv.visitVarInsn(ALOAD, </p>
<p>1</p>
<p>);</p>
<p>34</p>
<p>mv.visitMethodInsn(INVOKEVIRTUAL, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>,
35</p>
<p>&quot;append&quot;</p>
<p>, </p>
<p>&quot;(Ljava/lang/String;)Ljava/lang/StringBuilder;&quot;</p>
<p>);</p>
<p>36</p>
<p>mv.visitMethodInsn(INVOKEVIRTUAL, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>,
37</p>
<p>&quot;toString&quot;</p>
<p>, </p>
<p>&quot;()Ljava/lang/String;&quot;</p>
<p>);</p>
<p>38</p>
<p>mv.visitInsn(ARETURN);
39</p>
<p>mv.visitMaxs(</p>
<p>3</p>
<p>, </p>
<p>2</p>
<p>);</p>
<p>40</p>
<p>mv.visitEnd();
41</p>
<p>}</p>
<p>42</p>
<p>cw.visitEnd();
43</p>
<p>return</p>
<p>cw.toByteArray();</p>
<p>44</p>
<p>}
45</p>
<p>}</p>
<p>图 1 描述了 Java Source 文件、Java Class 文件、ASM Code 文件和 ASM Source 文件之间的转换关系。
<a href=""><strong>图 1. 四种文件的转换图</strong></a> 
<a href=""><img src="" alt="图 1. 四种文件的转换图"></a> </p>
<p>如图 -1 所示，Java Source 文件通过 Javac 可以转换为 Java Class 文件。而相应的 Java Class 文件通过 Java 反编译器工具可转换为 Java Source 文件；</p>
<p>通 过 ASM Code 去创建和修改 Java Class 需要对 ASM API 比较熟悉才行，一个常见的问题时，怎么用 ASM Code 生成一个我们希望的 class 文件， 也就是说， 给定了 Java Class， 怎么得到其对应的 ASM Code 呢？ 所幸的是， ASM 框架为我们提供了 ASMifierClassVisitor 工具来产生 Java Class 对应的 ASM Code。代码如下：
<a href=""><strong>清单 7. 给定 class 文件，通过 ASMifierClassVisitor 获得其对应的 ASM Code</strong></a><a href="http://www.oschina.net/question/129540_28430#viewSource" title="view source" target="_blank">view source</a><a href="http://www.oschina.net/question/129540_28430#printSource" title="print" target="_blank">print</a><a href="http://www.oschina.net/question/129540_28430#about" title="?" target="_blank">?</a></p>
<p>01</p>
<p>public</p>
<p>void</p>
<p>showClassASMProcess() {</p>
<p>02</p>
<p>ClassReader cr;
03</p>
<p>final</p>
<p>String n = SayHelloImpl.</p>
<p>class</p>
<p>.getName();</p>
<p>04</p>
<p>05</p>
<p>try</p>
<p>{</p>
<p>06</p>
<p>cr = </p>
<p>new</p>
<p>ClassReader(n);<br>07</p>
<p>cr.accept(</p>
<p>new</p>
<p>ASMifierClassVisitor(</p>
<p>new</p>
<p>PrintWriter(System.out)),</p>
<p>08</p>
<p>new</p>
<p>Attribute[</p>
<p>0</p>
<p>],
09</p>
<p>ClassReader.SKIP_DEBUG);</p>
<p>10</p>
<p>11</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {</p>
<p>12</p>
<p>e.printStackTrace();
13</p>
<p>}</p>
<p>14</p>
<p>}</p>
<p>另外一个重要的转换就是， 给定了 Java Class 文件， 如何查看它的 ASM Source ？ 这点对于我们验证 ASM Code 生成的 class 是否正确很有用。ASM 提供了另外一个工具 TraceClassVisitor， 来获得一个 Java Class 对应的 ASM Source。代码如下：
<a href=""><strong>清单 8. 利用 TraceClassVisitor 查看 class 文件的 ASM Source</strong></a>01</p>
<p>//file 是 class 文件的全路径名</p>
<p>02</p>
<p>public</p>
<p>void</p>
<p>showClassSource(String file) {
03</p>
<p>FileInputStream is ;</p>
<p>04</p>
<p>ClassReader cr; 
05</p>
<p>06</p>
<p>try</p>
<p>{
07</p>
<p>is = </p>
<p>new</p>
<p>FileInputStream(file);     </p>
<p>08</p>
<p>cr = </p>
<p>new</p>
<p>ClassReader(is);
09</p>
<p>TraceClassVisitor trace = </p>
<p>new</p>
<p>TraceClassVisitor(</p>
<p>new</p>
<p>PrintWriter(System.out));</p>
<p>10</p>
<p>cr.accept(trace, ClassReader.SKIP_DEBUG);
11</p>
<p>12</p>
<p>is.close() ;
13</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {</p>
<p>14</p>
<p>e.printStackTrace() ;
15</p>
<p>}</p>
<p>16</p>
<p>}
17</p>
<p>{</p>
<p>18</p>
<p>e.printStackTrace();
19</p>
<p>}</p>
<p>20</p>
<p>}</p>
<p><a href="">ASM 类注入</a></p>
<p>ASM 类注入是指修改一个现有的 class 文件，在其中加入自己的代码。按通常思维，我们需要利用 ASM 提供的 reader 类去读取所要修改的类文件， 找到要修改的地方，如方法名或属性名，然后在该处插入自己的代码或修改现有的代码，这种思路将使问题复杂化。 ASM 为我们提供了访问类文件的 Visitor 模式，来遍历一个 class 文件，Visitor 是一个实现 ClassVisitor 接口的类。 要注入一个 class 文件，先要找到一个合适的 Visitor 做向导， ASM 提供了好几种 Visitor， 最常用的是 ClassWriter。同时我们需要提供一个适配器类 ClassAdapter， Visitor 会带着这个 Adapter 一起去遍历， 然后在遍历过程中回调 Adapter 提供的方法。我们在 Adapter 的这些方法中就可以实现我们的修改和定制逻辑。当然，如果你不想做任何修改，那 Visitor 遍历完后将得到一个和被遍历的 class 完全一样的拷贝。
<a href=""><strong>清单 9. 类注入的完整过程</strong></a>01</p>
<p>public</p>
<p>void</p>
<p>addAnnotationToExistingClass() {</p>
<p>02</p>
<p>FileInputStream is ;
03</p>
<p>ClassReader cr;          </p>
<p>04</p>
<p>try</p>
<p>{<br>05</p>
<p>String classfile = </p>
<p>&quot;E:\SayHelloImpl.class&quot;</p>
<p>; </p>
<p>// 待遍历的类</p>
<p>06</p>
<p>showClassSource(classfile) ;  </p>
<p>// 打印该类的 ASM source
07</p>
<p>08</p>
<p>is = </p>
<p>new</p>
<p>FileInputStream(classfile);<br>09</p>
<p>cr = </p>
<p>new</p>
<p>ClassReader(is);</p>
<p>10</p>
<p>// 此处我们使用 ClassWriter 做 Visitor
11</p>
<p>ClassWriter cw = </p>
<p>new</p>
<p>ClassWriter(ClassWriter.COMPUTE_MAXS);</p>
<p>12</p>
<p>// 给 Visitor 提供一个 Adapter
13</p>
<p>AddAnnotationAdapter adapter = </p>
<p>new</p>
<p>AddAnnotationAdapter(cw);           </p>
<p>14</p>
<p>cr.accept(adapter, ClassReader.SKIP_DEBUG);<br>15</p>
<p>16</p>
<p>// 遍历完后，生成的 class 保存在字节数组中
17</p>
<p>byte</p>
<p>[] b = cw.toByteArray();</p>
<p>18</p>
<p>19</p>
<p>try</p>
<p>{</p>
<p>20</p>
<p>// 将字节数组输出到文件中
21</p>
<p>// 为了不至于覆盖掉原有的 SayHelloImpl.class 文件，我们将结果输出到 _SayHelloImpl.class</p>
<p>22</p>
<p>FileOutputStream fout = </p>
<p>new</p>
<p>FileOutputStream(</p>
<p>&quot;E:\_SayHelloImpl.class&quot;</p>
<p>);
23</p>
<p>fout.write(b) ;</p>
<p>24</p>
<p>fout.flush();
25</p>
<p>fout.close() ;</p>
<p>26</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {
27</p>
<p>e.printStackTrace() ;</p>
<p>28</p>
<p>}
29</p>
<p>30</p>
<p>// 验证 _SayHelloImpl.class 是否包含我们注入的代码
31</p>
<p>showClassSource(</p>
<p>&quot;E:\_SayHelloImpl.class&quot;</p>
<p>) ;</p>
<p>32</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {
33</p>
<p>e.printStackTrace();</p>
<p>34</p>
<p>} 
35</p>
<p>}</p>
<p><a href="">web services 标记注入过程</a></p>
<p>我们已经知道了如何往 class 中注入自己的代码，那对于一个已有的 Java bean，怎么往里注入 @WebService 和 @WebMethod 呢？根据上面我们讲的转换关系，我们可以先写一个带 annotation 的 Java Source，编译得到 Java Class， 再得到其 ASM Code。下面是利用 ASM 给一个不带任何 Annotation 的 class 添加 @WebService 和 @WebMethod 的步骤。</p>
<ol>
<li>首先在 SayHelloImpl.java 中添加 @WebService 和 @WebMethod： 
<a href=""><strong>清单 10. 带 web services 标注的 SayHelloImpl 类</strong></a>1</li>
</ol>
<p>@WebService</p>
<p>2</p>
<p>public</p>
<p>class</p>
<p>SayHelloImpl {
3</p>
<p>@WebMethod</p>
<p>4</p>
<p>public</p>
<p>String sayHello(String s) {
5</p>
<p>return</p>
<p>&quot;Hello: &quot;</p>
<ul>
<li>s ;</li>
</ul>
<p>6</p>
<p>}
7</p>
<p>}</p>
<ol>
<li>通过 ASMifierClassVisitor 工具获得 SayHelloImpl class 的 ASM Code，见清单 6。</li>
<li>写一个 ClassAdapter 类， ClassAdapter 其实也是一个 Visitor。根据 ASM Code 的提示， 我们就可以知道如何利用 ASM API 去获得我们希望的 class 文件。下面是 Adapter 的示例代码。 
<a href=""><strong>清单 11. 添加 Annotation 的 Adapter 类</strong></a>01</li>
</ol>
<p>public</p>
<p>class</p>
<p>AddAnnotationAdapter </p>
<p>extends</p>
<p>ClassAdapter </p>
<p>implements</p>
<p>Opcodes{</p>
<p>02</p>
<p>//private String annotationDesc;
03</p>
<p>private</p>
<p>boolean</p>
<p>isAnnotationPresent;</p>
<p>04</p>
<p>05</p>
<p>public</p>
<p>AddAnnotationAdapter(ClassVisitor cv) {</p>
<p>06</p>
<p>super</p>
<p>(cv);
07</p>
<p>}</p>
<p>08</p>
<p>09</p>
<p>@Override</p>
<p>10</p>
<p>public</p>
<p>void</p>
<p>visit(</p>
<p>int</p>
<p>version, </p>
<p>int</p>
<p>access, String name, String signature,
11</p>
<p>String superName, String[] interfaces) {</p>
<p>12</p>
<p>13</p>
<p>cv.visit(V1_6, ACC_PUBLIC + ACC_SUPER, name, signature, superName,</p>
<p>14</p>
<p>interfaces);
15</p>
<p>AnnotationVisitor av0;</p>
<p>16</p>
<p>av0 = cv.visitAnnotation(</p>
<p>&quot;Ljavax/jws/WebService;&quot;</p>
<p>, </p>
<p>true</p>
<p>);
17</p>
<p>av0.visitEnd();</p>
<p>18</p>
<p>}
19</p>
<p>20</p>
<p>@Override
21</p>
<p>public</p>
<p>AnnotationVisitor visitAnnotation(String desc, </p>
<p>boolean</p>
<p>visible) {</p>
<p>22</p>
<p>return</p>
<p>cv.visitAnnotation(desc, visible);
23</p>
<p>}</p>
<p>24</p>
<p>25</p>
<p>@Override</p>
<p>26</p>
<p>public</p>
<p>void</p>
<p>visitInnerClass(String name, String outerName,
27</p>
<p>String innerName, </p>
<p>int</p>
<p>access) {</p>
<p>28</p>
<p>cv.visitInnerClass(name, outerName, innerName, access);
29</p>
<p>}</p>
<p>30</p>
<p>31</p>
<p>@Override</p>
<p>32</p>
<p>public</p>
<p>FieldVisitor visitField(</p>
<p>int</p>
<p>access, String name, String desc,
33</p>
<p>String signature, Object value) {</p>
<p>34</p>
<p>return</p>
<p>cv.visitField(access, name, desc, signature, value);
35</p>
<p>}</p>
<p>36</p>
<p>37</p>
<p>@Override</p>
<p>38</p>
<p>public</p>
<p>MethodVisitor visitMethod(</p>
<p>int</p>
<p>access, String name, String desc,
39</p>
<p>String signature, String[] exceptions) {   </p>
<p>40</p>
<p>MethodVisitor mv  = cv.visitMethod(access, name, desc, signature,
41</p>
<p>exceptions);</p>
<p>42</p>
<p>if</p>
<p>(!name.equals(</p>
<p>&quot;<init>&quot;</p>
<p>)) {
43</p>
<p>AnnotationVisitor av0;</p>
<p>44</p>
<p>av0 = mv.visitAnnotation(</p>
<p>&quot;Ljavax/jws/WebMethod;&quot;</p>
<p>, </p>
<p>true</p>
<p>);
45</p>
<p>av0.visitEnd();</p>
<p>46</p>
<p>}
47</p>
<p>return</p>
<p>mv;</p>
<p>48</p>
<p>}
49</p>
<p>50</p>
<p>@Override
51</p>
<p>public</p>
<p>void</p>
<p>visitEnd() {</p>
<p>52</p>
<p>cv.visitEnd();
53</p>
<p>}</p>
<p>54</p>
<p>55</p>
<p>}</p>
<p>最后，我们采用上面讲的类注入办法，即可得到一个带 @WebService 和 @WebMethod 标注的 class 文件。再通过 wsgen 工具即可成功创建 web services，该命令将会在 src 目录下生成 web services 描述文件：SayHelloImplService.wsdl，SayHelloImplService_schema1.xsd，同时生成了 2 个 JAX-WS 文件，分别为：SayHello.java，SayHelloResponse.java。</p>
<p>当然，在实际应用中，我们可能需要将一个 class 的某些特定方法发布为 web services，这就需要我们对 Adapter 做进一步的改造，在 visitMethod() 方法中根据方法名称等参数做进一步的处理。</p>
<p><a href="">结束语</a></p>
<p>本文简要介绍了 ASM 字节码工具及其在 web services 开发中的应用。web services 的使用已经越来越广泛， 但在改造遗留系统过程中会遇到不少问题，本文针对其中一个主要问题给出了解决办法，该方法无须对现有系统做大量的改动， 即可将现存的 Java bean 转化成 web services 。本文对那些正考虑迁移到 JAX-WS 编程模型上的项目有一定的参考价值。在基于 JAX-WS 标准的 web services 的开发中，不少实际场景都是希望采用自底向上的开发方式， 即基于已有的 Java bean 来创建 web services 。WebSphere Application Server ( 以下简称 WAS ) 提供了命令行的工具 wsgen 和相对应的 Ant task 来支持这种开发过程，而且这两个工具比较适合大型项目的自动化构建。 这两个工具的使用前提是 Java bean 中事先添加有 web services 的 Annotation 标注，而在现有的业务系统中，class 文件一般是不带 Annotation 的，这就需要开发人员去修改现有的代码，以手工方式添加 Annotation，但这样带来的工作量太大且容易出错。本文介绍了一种解决途径，可以不用修改源代码，而是利用字节码工具 ASM 直接修改 class 文件， 在字节码文件中自动注入 Annotation ，然后再利用 wsgen 工具就可以很方便地生成 web services 应用。 本文同时也总结了使用 ASM 的一些实践。</p>
<p>本文首先介绍了和 ASM 使用相关的四种文件，以及它们之间的相互转化。然后结合 web services 开发实例，介绍了使用 wsgen 开发时遇到的实际问题，如何写一个 ASM 的适配器去修改现有 class，最终如何产生 web services 文件。</p>
<p>ASM 是一个多用途的 Java 字节码操控和分析框架。它能以二进制的形式直接修改现有的类或动态生成的类。 ASM 提供了常用的转换和分析算法，是一种允许用户方便的组装定制化的复杂转换和代码分析工具。 ASM 也提供和其它的字节码工具类似的功能，但 ASM 的重点是使用的简单和高性能。由于 ASM 在设计实现的时候尽可能 的小的内存占用和提供更高的性能；因此在动态系统中使用 ASM 是很有优势的。ASM 作为一种轻量级、高性能的 Java 字节码操控和分析框架，设计了一种更有效的方法、提供更好的性能和内存占用。今天， ASM 在许多领域都有应用，并已成为事实上的字节码处理框架标准。</p>
<p><a href="">问题的引入</a></p>
<p>先写一个不带 web services 标注的 SayHelloImpl 类。
<a href=""><strong>清单 1. 不带 web services 的 SayHelloImpl 类</strong></a>1</p>
<p>public</p>
<p>class</p>
<p>SayHelloImpl {</p>
<p>2</p>
<p>public</p>
<p>String sayHello(String s) {
3</p>
<p>return</p>
<p>“Hello: ” + s ;</p>
<p>4</p>
<p>}
5</p>
<p>}</p>
<p>再用 wsgen 来创建 web services，wsgen 的使用如下：
<a href=""><strong>清单 2. wsgen 实例</strong></a>1</p>
<p>wsgen.exe – </p>
<p>cp</p>
<p>bin – s output – d output – r output – wsdl ibm.was.asm.SayHelloImpl我们将会遇到如下错误： 
<a href=""><strong>清单 3. 根据不带 web services 标注的类创建 web services 时遇到的错误信息</strong></a> 
注释处理过程中遇到问题；</p>
<p>......
com.sun.tools.internal.ws.processor.modeler.ModelerException: [failed to localiz</p>
<p>e] A web service endpoint could not be found()
        at com.sun.tools.internal.ws.processor.modeler.annotation.WebServiceAP.o</p>
<p>nError(WebServiceAP.java:215)
        at com.sun.tools.internal.ws.processor.modeler.annotation.WebServiceAP.b</p>
<p>uildModel(WebServiceAP.java:322)
        at com.sun.tools.internal.ws.processor.modeler.annotation.WebServiceAP.p</p>
<p>rocess(WebServiceAP.java:256)
        at com.sun.mirror.apt.AnnotationProcessors$CompositeAnnotationProcessor.</p>
<p>process(AnnotationProcessors.java:60)</p>
<p>注意：我们通常是在 class 前使用 @WebService， 在方法前使用 @WebMethod 来将一个类标注为 web services 的。WAS 6.1 的 web services 功能部件包和 WAS 7 都支持基于 JAX-WS 标准 的 web services 的开发， 在 WAS 安装目录的 bin 目录下提供了命令行工具 wsgen，wsgen 支持自底向上的开发方式。 下面是 wsgen 的用法：
<a href=""><strong>清单 4. wsgen 命令格式</strong></a> 
注 wsgen [options]  [SEI]</p>
<p>主要选项：</p>
<ul>
<li>-d 指定生成的 class 文件位置；</li>
<li>-s 指定生成的 Java 源文件位置；</li>
<li>-r 指定生成的 resources 文件位置，如 wsdl，xsd；</li>
<li>-cp 指定服务实现类所在的位置；</li>
<li>-wsdl，-servicename，-portname 三个参数指定生成的 wsdl 文件中的 service 和 port 的名称。</li>
</ul>
<p>SEI(Service Endpoint Interface) 是一个 endpoint implementation class，不能是一个 interface。所以首先要开发一个 endpoint 的实现类，如本例中的 SayHelloImpl 。用 @WebService 声明 web services ，然后将它编译，才能提供给 wsgen 来创建 web services 。</p>
<p><a href="">四种文件之间的转换</a></p>
<p>下面介绍本文要用到的四个概念（Java Source，Java Class，ASM Code，ASM Source）</p>
<ul>
<li>Java Source: 即我们通常编写的 Java 源文件；</li>
<li>Java Class: Java 源文件编译后的字节码文件；</li>
<li>ASM Source : 类似于对 class 反编译后的源文件，也就是 &quot;textual byte code&quot;，但比原始的 Java Source 可读性要差， 参见清单 5。</li>
<li>ASM Code: 指读写 class 文件的 ASM 程序代码。需要用到 ASM 提供的 API， 参见清单 6。
<a href=""><strong>清单 5. SayHelloImpl 类对应的 ASM Source</strong></a>01</li>
</ul>
<p>// class version 50.0 (50)</p>
<p>02</p>
<p>// access flags 33
03</p>
<p>public</p>
<p>class</p>
<p>com/ibm/was/asm/SayHelloImpl {</p>
<p>04</p>
<p>05</p>
<p>// access flags 1</p>
<p>06</p>
<p>public</p>
<p><init>()V
07</p>
<p>ALOAD </p>
<p>0</p>
<p>08</p>
<p>INVOKESPECIAL java/lang/Object. <init> ()V
09</p>
<p>RETURN</p>
<p>10</p>
<p>MAXSTACK = </p>
<p>1
11</p>
<p>MAXLOCALS = </p>
<p>1</p>
<p>12</p>
<p>13</p>
<p>// access flags 1</p>
<p>14</p>
<p>public</p>
<p>sayHello(Ljava/lang/String;)Ljava/lang/String;
15</p>
<p>NEW java/lang/StringBuilder</p>
<p>16</p>
<p>DUP
17</p>
<p>LDC </p>
<p>&quot;Hello:&quot;</p>
<p>18</p>
<p>INVOKESPECIAL java/lang/StringBuilder. <init> (Ljava/lang/String;)V
19</p>
<p>ALOAD </p>
<p>1</p>
<p>20</p>
<p>INVOKEVIRTUAL java/lang/StringBuilder.append (Ljava/lang/String;)
21</p>
<p>Ljava/lang/StringBuilder;</p>
<p>22</p>
<p>INVOKEVIRTUAL java/lang/StringBuilder.toString ()Ljava/lang/String;
23</p>
<p>ARETURN</p>
<p>24</p>
<p>MAXSTACK = </p>
<p>3
25</p>
<p>MAXLOCALS = </p>
<p>2</p>
<p>26</p>
<p>}<a href=""><strong>清单 6. 生成 SayHelloImpl.class 的 ASM Code</strong></a>01</p>
<p>package</p>
<p>asm.com.ibm.was.asm;</p>
<p>02</p>
<p>import</p>
<p>java.util./*;
03</p>
<p>import</p>
<p>org.objectweb.asm./*;</p>
<p>04</p>
<p>import</p>
<p>org.objectweb.asm.attrs./*;
05</p>
<p>public</p>
<p>class</p>
<p>SayHelloImplDump </p>
<p>implements</p>
<p>Opcodes {</p>
<p>06</p>
<p>public</p>
<p>static</p>
<p>byte</p>
<p>[] dump () </p>
<p>throws</p>
<p>Exception {
07</p>
<p>ClassWriter cw = </p>
<p>new</p>
<p>ClassWriter(</p>
<p>0</p>
<p>);</p>
<p>08</p>
<p>FieldVisitor fv;
09</p>
<p>MethodVisitor mv;</p>
<p>10</p>
<p>AnnotationVisitor av0;
11</p>
<p>12</p>
<p>cw.visit(V1_6, ACC_PUBLIC + ACC_SUPER, </p>
<p>&quot;com/ibm/was/asm/SayHelloImpl&quot;</p>
<p>,
13</p>
<p>null</p>
<p>, </p>
<p>&quot;java/lang/Object&quot;</p>
<p>, </p>
<p>null</p>
<p>);</p>
<p>14</p>
<p>15</p>
<p>{</p>
<p>16</p>
<p>mv = cw.visitMethod(ACC_PUBLIC, </p>
<p>&quot;<init>&quot;</p>
<p>, </p>
<p>&quot;()V&quot;</p>
<p>, </p>
<p>null</p>
<p>, </p>
<p>null</p>
<p>);
17</p>
<p>mv.visitCode();</p>
<p>18</p>
<p>mv.visitVarInsn(ALOAD, </p>
<p>0</p>
<p>);
19</p>
<p>mv.visitMethodInsn(INVOKESPECIAL, </p>
<p>&quot;java/lang/Object&quot;</p>
<p>, </p>
<p>&quot;<init>&quot;</p>
<p>, </p>
<p>&quot;()V&quot;</p>
<p>);</p>
<p>20</p>
<p>mv.visitInsn(RETURN);
21</p>
<p>mv.visitMaxs(</p>
<p>1</p>
<p>, </p>
<p>1</p>
<p>);</p>
<p>22</p>
<p>mv.visitEnd();
23</p>
<p>}</p>
<p>24</p>
<p>{
25</p>
<p>mv = cw.visitMethod(ACC_PUBLIC, </p>
<p>&quot;sayHello&quot;</p>
<p>,</p>
<p>26</p>
<p>&quot;(Ljava/lang/String;)Ljava/lang/String;&quot;</p>
<p>, </p>
<p>null</p>
<p>, </p>
<p>null</p>
<p>);
27</p>
<p>mv.visitCode();</p>
<p>28</p>
<p>mv.visitTypeInsn(NEW, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>);
29</p>
<p>mv.visitInsn(DUP);</p>
<p>30</p>
<p>mv.visitLdcInsn(</p>
<p>&quot;Hello:&quot;</p>
<p>);
31</p>
<p>mv.visitMethodInsn(INVOKESPECIAL, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>,</p>
<p>32</p>
<p>&quot;<init>&quot;</p>
<p>, </p>
<p>&quot;(Ljava/lang/String;)V&quot;</p>
<p>);
33</p>
<p>mv.visitVarInsn(ALOAD, </p>
<p>1</p>
<p>);</p>
<p>34</p>
<p>mv.visitMethodInsn(INVOKEVIRTUAL, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>,
35</p>
<p>&quot;append&quot;</p>
<p>, </p>
<p>&quot;(Ljava/lang/String;)Ljava/lang/StringBuilder;&quot;</p>
<p>);</p>
<p>36</p>
<p>mv.visitMethodInsn(INVOKEVIRTUAL, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>,
37</p>
<p>&quot;toString&quot;</p>
<p>, </p>
<p>&quot;()Ljava/lang/String;&quot;</p>
<p>);</p>
<p>38</p>
<p>mv.visitInsn(ARETURN);
39</p>
<p>mv.visitMaxs(</p>
<p>3</p>
<p>, </p>
<p>2</p>
<p>);</p>
<p>40</p>
<p>mv.visitEnd();
41</p>
<p>}</p>
<p>42</p>
<p>cw.visitEnd();
43</p>
<p>return</p>
<p>cw.toByteArray();</p>
<p>44</p>
<p>}
45</p>
<p>}</p>
<p>图 1 描述了 Java Source 文件、Java Class 文件、ASM Code 文件和 ASM Source 文件之间的转换关系。
<a href=""><strong>图 1. 四种文件的转换图</strong></a> 
<a href=""><img src="" alt="图 1. 四种文件的转换图"></a> </p>
<p>如图 -1 所示，Java Source 文件通过 Javac 可以转换为 Java Class 文件。而相应的 Java Class 文件通过 Java 反编译器工具可转换为 Java Source 文件；</p>
<p>通 过 ASM Code 去创建和修改 Java Class 需要对 ASM API 比较熟悉才行，一个常见的问题时，怎么用 ASM Code 生成一个我们希望的 class 文件， 也就是说， 给定了 Java Class， 怎么得到其对应的 ASM Code 呢？ 所幸的是， ASM 框架为我们提供了 ASMifierClassVisitor 工具来产生 Java Class 对应的 ASM Code。代码如下：
<a href=""><strong>清单 7. 给定 class 文件，通过 ASMifierClassVisitor 获得其对应的 ASM Code</strong></a><a href="http://www.oschina.net/question/129540_28430#viewSource" title="view source" target="_blank">view source</a><a href="http://www.oschina.net/question/129540_28430#printSource" title="print" target="_blank">print</a><a href="http://www.oschina.net/question/129540_28430#about" title="?" target="_blank">?</a></p>
<p>01</p>
<p>public</p>
<p>void</p>
<p>showClassASMProcess() {</p>
<p>02</p>
<p>ClassReader cr;
03</p>
<p>final</p>
<p>String n = SayHelloImpl.</p>
<p>class</p>
<p>.getName();</p>
<p>04</p>
<p>05</p>
<p>try</p>
<p>{</p>
<p>06</p>
<p>cr = </p>
<p>new</p>
<p>ClassReader(n);<br>07</p>
<p>cr.accept(</p>
<p>new</p>
<p>ASMifierClassVisitor(</p>
<p>new</p>
<p>PrintWriter(System.out)),</p>
<p>08</p>
<p>new</p>
<p>Attribute[</p>
<p>0</p>
<p>],
09</p>
<p>ClassReader.SKIP_DEBUG);</p>
<p>10</p>
<p>11</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {</p>
<p>12</p>
<p>e.printStackTrace();
13</p>
<p>}</p>
<p>14</p>
<p>}</p>
<p>另外一个重要的转换就是， 给定了 Java Class 文件， 如何查看它的 ASM Source ？ 这点对于我们验证 ASM Code 生成的 class 是否正确很有用。ASM 提供了另外一个工具 TraceClassVisitor， 来获得一个 Java Class 对应的 ASM Source。代码如下：
<a href=""><strong>清单 8. 利用 TraceClassVisitor 查看 class 文件的 ASM Source</strong></a>01</p>
<p>//file 是 class 文件的全路径名</p>
<p>02</p>
<p>public</p>
<p>void</p>
<p>showClassSource(String file) {
03</p>
<p>FileInputStream is ;</p>
<p>04</p>
<p>ClassReader cr; 
05</p>
<p>06</p>
<p>try</p>
<p>{
07</p>
<p>is = </p>
<p>new</p>
<p>FileInputStream(file);     </p>
<p>08</p>
<p>cr = </p>
<p>new</p>
<p>ClassReader(is);
09</p>
<p>TraceClassVisitor trace = </p>
<p>new</p>
<p>TraceClassVisitor(</p>
<p>new</p>
<p>PrintWriter(System.out));</p>
<p>10</p>
<p>cr.accept(trace, ClassReader.SKIP_DEBUG);
11</p>
<p>12</p>
<p>is.close() ;
13</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {</p>
<p>14</p>
<p>e.printStackTrace() ;
15</p>
<p>}</p>
<p>16</p>
<p>}
17</p>
<p>{</p>
<p>18</p>
<p>e.printStackTrace();
19</p>
<p>}</p>
<p>20</p>
<p>}</p>
<p><a href="">ASM 类注入</a></p>
<p>ASM 类注入是指修改一个现有的 class 文件，在其中加入自己的代码。按通常思维，我们需要利用 ASM 提供的 reader 类去读取所要修改的类文件， 找到要修改的地方，如方法名或属性名，然后在该处插入自己的代码或修改现有的代码，这种思路将使问题复杂化。 ASM 为我们提供了访问类文件的 Visitor 模式，来遍历一个 class 文件，Visitor 是一个实现 ClassVisitor 接口的类。 要注入一个 class 文件，先要找到一个合适的 Visitor 做向导， ASM 提供了好几种 Visitor， 最常用的是 ClassWriter。同时我们需要提供一个适配器类 ClassAdapter， Visitor 会带着这个 Adapter 一起去遍历， 然后在遍历过程中回调 Adapter 提供的方法。我们在 Adapter 的这些方法中就可以实现我们的修改和定制逻辑。当然，如果你不想做任何修改，那 Visitor 遍历完后将得到一个和被遍历的 class 完全一样的拷贝。
<a href=""><strong>清单 9. 类注入的完整过程</strong></a>01</p>
<p>public</p>
<p>void</p>
<p>addAnnotationToExistingClass() {</p>
<p>02</p>
<p>FileInputStream is ;
03</p>
<p>ClassReader cr;          </p>
<p>04</p>
<p>try</p>
<p>{<br>05</p>
<p>String classfile = </p>
<p>&quot;E:\SayHelloImpl.class&quot;</p>
<p>; </p>
<p>// 待遍历的类</p>
<p>06</p>
<p>showClassSource(classfile) ;  </p>
<p>// 打印该类的 ASM source
07</p>
<p>08</p>
<p>is = </p>
<p>new</p>
<p>FileInputStream(classfile);<br>09</p>
<p>cr = </p>
<p>new</p>
<p>ClassReader(is);</p>
<p>10</p>
<p>// 此处我们使用 ClassWriter 做 Visitor
11</p>
<p>ClassWriter cw = </p>
<p>new</p>
<p>ClassWriter(ClassWriter.COMPUTE_MAXS);</p>
<p>12</p>
<p>// 给 Visitor 提供一个 Adapter
13</p>
<p>AddAnnotationAdapter adapter = </p>
<p>new</p>
<p>AddAnnotationAdapter(cw);           </p>
<p>14</p>
<p>cr.accept(adapter, ClassReader.SKIP_DEBUG);<br>15</p>
<p>16</p>
<p>// 遍历完后，生成的 class 保存在字节数组中
17</p>
<p>byte</p>
<p>[] b = cw.toByteArray();</p>
<p>18</p>
<p>19</p>
<p>try</p>
<p>{</p>
<p>20</p>
<p>// 将字节数组输出到文件中
21</p>
<p>// 为了不至于覆盖掉原有的 SayHelloImpl.class 文件，我们将结果输出到 _SayHelloImpl.class</p>
<p>22</p>
<p>FileOutputStream fout = </p>
<p>new</p>
<p>FileOutputStream(</p>
<p>&quot;E:\_SayHelloImpl.class&quot;</p>
<p>);
23</p>
<p>fout.write(b) ;</p>
<p>24</p>
<p>fout.flush();
25</p>
<p>fout.close() ;</p>
<p>26</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {
27</p>
<p>e.printStackTrace() ;</p>
<p>28</p>
<p>}
29</p>
<p>30</p>
<p>// 验证 _SayHelloImpl.class 是否包含我们注入的代码
31</p>
<p>showClassSource(</p>
<p>&quot;E:\_SayHelloImpl.class&quot;</p>
<p>) ;</p>
<p>32</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {
33</p>
<p>e.printStackTrace();</p>
<p>34</p>
<p>} 
35</p>
<p>}</p>
<p><a href="">web services 标记注入过程</a></p>
<p>我们已经知道了如何往 class 中注入自己的代码，那对于一个已有的 Java bean，怎么往里注入 @WebService 和 @WebMethod 呢？根据上面我们讲的转换关系，我们可以先写一个带 annotation 的 Java Source，编译得到 Java Class， 再得到其 ASM Code。下面是利用 ASM 给一个不带任何 Annotation 的 class 添加 @WebService 和 @WebMethod 的步骤。</p>
<ol>
<li>首先在 SayHelloImpl.java 中添加 @WebService 和 @WebMethod： 
<a href=""><strong>清单 10. 带 web services 标注的 SayHelloImpl 类</strong></a>1</li>
</ol>
<p>@WebService</p>
<p>2</p>
<p>public</p>
<p>class</p>
<p>SayHelloImpl {
3</p>
<p>@WebMethod</p>
<p>4</p>
<p>public</p>
<p>String sayHello(String s) {
5</p>
<p>return</p>
<p>&quot;Hello: &quot;</p>
<ul>
<li>s ;</li>
</ul>
<p>6</p>
<p>}
7</p>
<p>}</p>
<ol>
<li>通过 ASMifierClassVisitor 工具获得 SayHelloImpl class 的 ASM Code，见清单 6。</li>
<li>写一个 ClassAdapter 类， ClassAdapter 其实也是一个 Visitor。根据 ASM Code 的提示， 我们就可以知道如何利用 ASM API 去获得我们希望的 class 文件。下面是 Adapter 的示例代码。 
<a href=""><strong>清单 11. 添加 Annotation 的 Adapter 类</strong></a>01</li>
</ol>
<p>public</p>
<p>class</p>
<p>AddAnnotationAdapter </p>
<p>extends</p>
<p>ClassAdapter </p>
<p>implements</p>
<p>Opcodes{</p>
<p>02</p>
<p>//private String annotationDesc;
03</p>
<p>private</p>
<p>boolean</p>
<p>isAnnotationPresent;</p>
<p>04</p>
<p>05</p>
<p>public</p>
<p>AddAnnotationAdapter(ClassVisitor cv) {</p>
<p>06</p>
<p>super</p>
<p>(cv);
07</p>
<p>}</p>
<p>08</p>
<p>09</p>
<p>@Override</p>
<p>10</p>
<p>public</p>
<p>void</p>
<p>visit(</p>
<p>int</p>
<p>version, </p>
<p>int</p>
<p>access, String name, String signature,
11</p>
<p>String superName, String[] interfaces) {</p>
<p>12</p>
<p>13</p>
<p>cv.visit(V1_6, ACC_PUBLIC + ACC_SUPER, name, signature, superName,</p>
<p>14</p>
<p>interfaces);
15</p>
<p>AnnotationVisitor av0;</p>
<p>16</p>
<p>av0 = cv.visitAnnotation(</p>
<p>&quot;Ljavax/jws/WebService;&quot;</p>
<p>, </p>
<p>true</p>
<p>);
17</p>
<p>av0.visitEnd();</p>
<p>18</p>
<p>}
19</p>
<p>20</p>
<p>@Override
21</p>
<p>public</p>
<p>AnnotationVisitor visitAnnotation(String desc, </p>
<p>boolean</p>
<p>visible) {</p>
<p>22</p>
<p>return</p>
<p>cv.visitAnnotation(desc, visible);
23</p>
<p>}</p>
<p>24</p>
<p>25</p>
<p>@Override</p>
<p>26</p>
<p>public</p>
<p>void</p>
<p>visitInnerClass(String name, String outerName,
27</p>
<p>String innerName, </p>
<p>int</p>
<p>access) {</p>
<p>28</p>
<p>cv.visitInnerClass(name, outerName, innerName, access);
29</p>
<p>}</p>
<p>30</p>
<p>31</p>
<p>@Override</p>
<p>32</p>
<p>public</p>
<p>FieldVisitor visitField(</p>
<p>int</p>
<p>access, String name, String desc,
33</p>
<p>String signature, Object value) {</p>
<p>34</p>
<p>return</p>
<p>cv.visitField(access, name, desc, signature, value);
35</p>
<p>}</p>
<p>36</p>
<p>37</p>
<p>@Override</p>
<p>38</p>
<p>public</p>
<p>MethodVisitor visitMethod(</p>
<p>int</p>
<p>access, String name, String desc,
39</p>
<p>String signature, String[] exceptions) {   </p>
<p>40</p>
<p>MethodVisitor mv  = cv.visitMethod(access, name, desc, signature,
41</p>
<p>exceptions);</p>
<p>42</p>
<p>if</p>
<p>(!name.equals(</p>
<p>&quot;<init>&quot;</p>
<p>)) {
43</p>
<p>AnnotationVisitor av0;</p>
<p>44</p>
<p>av0 = mv.visitAnnotation(</p>
<p>&quot;Ljavax/jws/WebMethod;&quot;</p>
<p>, </p>
<p>true</p>
<p>);
45</p>
<p>av0.visitEnd();</p>
<p>46</p>
<p>}
47</p>
<p>return</p>
<p>mv;</p>
<p>48</p>
<p>}
49</p>
<p>50</p>
<p>@Override
51</p>
<p>public</p>
<p>void</p>
<p>visitEnd() {</p>
<p>52</p>
<p>cv.visitEnd();
53</p>
<p>}</p>
<p>54</p>
<p>55</p>
<p>}</p>
<p>最后，我们采用上面讲的类注入办法，即可得到一个带 @WebService 和 @WebMethod 标注的 class 文件。再通过 wsgen 工具即可成功创建 web services，该命令将会在 src 目录下生成 web services 描述文件：SayHelloImplService.wsdl，SayHelloImplService_schema1.xsd，同时生成了 2 个 JAX-WS 文件，分别为：SayHello.java，SayHelloResponse.java。</p>
<p>当然，在实际应用中，我们可能需要将一个 class 的某些特定方法发布为 web services，这就需要我们对 Adapter 做进一步的改造，在 visitMethod() 方法中根据方法名称等参数做进一步的处理。</p>
<p><a href="">结束语</a></p>
<p>本文简要介绍了 ASM 字节码工具及其在 web services 开发中的应用。web services 的使用已经越来越广泛， 但在改造遗留系统过程中会遇到不少问题，本文针对其中一个主要问题给出了解决办法，该方法无须对现有系统做大量的改动， 即可将现存的 Java bean 转化成 web services 。本文对那些正考虑迁移到 JAX-WS 编程模型上的项目有一定的参考价值。在基于 JAX-WS 标准的 web services 的开发中，不少实际场景都是希望采用自底向上的开发方式， 即基于已有的 Java bean 来创建 web services 。WebSphere Application Server ( 以下简称 WAS ) 提供了命令行的工具 wsgen 和相对应的 Ant task 来支持这种开发过程，而且这两个工具比较适合大型项目的自动化构建。 这两个工具的使用前提是 Java bean 中事先添加有 web services 的 Annotation 标注，而在现有的业务系统中，class 文件一般是不带 Annotation 的，这就需要开发人员去修改现有的代码，以手工方式添加 Annotation，但这样带来的工作量太大且容易出错。本文介绍了一种解决途径，可以不用修改源代码，而是利用字节码工具 ASM 直接修改 class 文件， 在字节码文件中自动注入 Annotation ，然后再利用 wsgen 工具就可以很方便地生成 web services 应用。 本文同时也总结了使用 ASM 的一些实践。</p>
<p>本文首先介绍了和 ASM 使用相关的四种文件，以及它们之间的相互转化。然后结合 web services 开发实例，介绍了使用 wsgen 开发时遇到的实际问题，如何写一个 ASM 的适配器去修改现有 class，最终如何产生 web services 文件。</p>
<p>ASM 是一个多用途的 Java 字节码操控和分析框架。它能以二进制的形式直接修改现有的类或动态生成的类。 ASM 提供了常用的转换和分析算法，是一种允许用户方便的组装定制化的复杂转换和代码分析工具。 ASM 也提供和其它的字节码工具类似的功能，但 ASM 的重点是使用的简单和高性能。由于 ASM 在设计实现的时候尽可能 的小的内存占用和提供更高的性能；因此在动态系统中使用 ASM 是很有优势的。ASM 作为一种轻量级、高性能的 Java 字节码操控和分析框架，设计了一种更有效的方法、提供更好的性能和内存占用。今天， ASM 在许多领域都有应用，并已成为事实上的字节码处理框架标准。</p>
<p><a href="">问题的引入</a></p>
<p>先写一个不带 web services 标注的 SayHelloImpl 类。
<a href=""><strong>清单 1. 不带 web services 的 SayHelloImpl 类</strong></a>1</p>
<p>public</p>
<p>class</p>
<p>SayHelloImpl {</p>
<p>2</p>
<p>public</p>
<p>String sayHello(String s) {
3</p>
<p>return</p>
<p>“Hello: ” + s ;</p>
<p>4</p>
<p>}
5</p>
<p>}</p>
<p>再用 wsgen 来创建 web services，wsgen 的使用如下：
<a href=""><strong>清单 2. wsgen 实例</strong></a>1</p>
<p>wsgen.exe – </p>
<p>cp</p>
<p>bin – s output – d output – r output – wsdl ibm.was.asm.SayHelloImpl我们将会遇到如下错误： 
<a href=""><strong>清单 3. 根据不带 web services 标注的类创建 web services 时遇到的错误信息</strong></a> 
注释处理过程中遇到问题；</p>
<p>......
com.sun.tools.internal.ws.processor.modeler.ModelerException: [failed to localiz</p>
<p>e] A web service endpoint could not be found()
        at com.sun.tools.internal.ws.processor.modeler.annotation.WebServiceAP.o</p>
<p>nError(WebServiceAP.java:215)
        at com.sun.tools.internal.ws.processor.modeler.annotation.WebServiceAP.b</p>
<p>uildModel(WebServiceAP.java:322)
        at com.sun.tools.internal.ws.processor.modeler.annotation.WebServiceAP.p</p>
<p>rocess(WebServiceAP.java:256)
        at com.sun.mirror.apt.AnnotationProcessors$CompositeAnnotationProcessor.</p>
<p>process(AnnotationProcessors.java:60)</p>
<p>注意：我们通常是在 class 前使用 @WebService， 在方法前使用 @WebMethod 来将一个类标注为 web services 的。WAS 6.1 的 web services 功能部件包和 WAS 7 都支持基于 JAX-WS 标准 的 web services 的开发， 在 WAS 安装目录的 bin 目录下提供了命令行工具 wsgen，wsgen 支持自底向上的开发方式。 下面是 wsgen 的用法：
<a href=""><strong>清单 4. wsgen 命令格式</strong></a> 
注 wsgen [options]  [SEI]</p>
<p>主要选项：</p>
<ul>
<li>-d 指定生成的 class 文件位置；</li>
<li>-s 指定生成的 Java 源文件位置；</li>
<li>-r 指定生成的 resources 文件位置，如 wsdl，xsd；</li>
<li>-cp 指定服务实现类所在的位置；</li>
<li>-wsdl，-servicename，-portname 三个参数指定生成的 wsdl 文件中的 service 和 port 的名称。</li>
</ul>
<p>SEI(Service Endpoint Interface) 是一个 endpoint implementation class，不能是一个 interface。所以首先要开发一个 endpoint 的实现类，如本例中的 SayHelloImpl 。用 @WebService 声明 web services ，然后将它编译，才能提供给 wsgen 来创建 web services 。</p>
<p><a href="">四种文件之间的转换</a></p>
<p>下面介绍本文要用到的四个概念（Java Source，Java Class，ASM Code，ASM Source）</p>
<ul>
<li>Java Source: 即我们通常编写的 Java 源文件；</li>
<li>Java Class: Java 源文件编译后的字节码文件；</li>
<li>ASM Source : 类似于对 class 反编译后的源文件，也就是 &quot;textual byte code&quot;，但比原始的 Java Source 可读性要差， 参见清单 5。</li>
<li>ASM Code: 指读写 class 文件的 ASM 程序代码。需要用到 ASM 提供的 API， 参见清单 6。
<a href=""><strong>清单 5. SayHelloImpl 类对应的 ASM Source</strong></a>01</li>
</ul>
<p>// class version 50.0 (50)</p>
<p>02</p>
<p>// access flags 33
03</p>
<p>public</p>
<p>class</p>
<p>com/ibm/was/asm/SayHelloImpl {</p>
<p>04</p>
<p>05</p>
<p>// access flags 1</p>
<p>06</p>
<p>public</p>
<p><init>()V
07</p>
<p>ALOAD </p>
<p>0</p>
<p>08</p>
<p>INVOKESPECIAL java/lang/Object. <init> ()V
09</p>
<p>RETURN</p>
<p>10</p>
<p>MAXSTACK = </p>
<p>1
11</p>
<p>MAXLOCALS = </p>
<p>1</p>
<p>12</p>
<p>13</p>
<p>// access flags 1</p>
<p>14</p>
<p>public</p>
<p>sayHello(Ljava/lang/String;)Ljava/lang/String;
15</p>
<p>NEW java/lang/StringBuilder</p>
<p>16</p>
<p>DUP
17</p>
<p>LDC </p>
<p>&quot;Hello:&quot;</p>
<p>18</p>
<p>INVOKESPECIAL java/lang/StringBuilder. <init> (Ljava/lang/String;)V
19</p>
<p>ALOAD </p>
<p>1</p>
<p>20</p>
<p>INVOKEVIRTUAL java/lang/StringBuilder.append (Ljava/lang/String;)
21</p>
<p>Ljava/lang/StringBuilder;</p>
<p>22</p>
<p>INVOKEVIRTUAL java/lang/StringBuilder.toString ()Ljava/lang/String;
23</p>
<p>ARETURN</p>
<p>24</p>
<p>MAXSTACK = </p>
<p>3
25</p>
<p>MAXLOCALS = </p>
<p>2</p>
<p>26</p>
<p>}<a href=""><strong>清单 6. 生成 SayHelloImpl.class 的 ASM Code</strong></a>01</p>
<p>package</p>
<p>asm.com.ibm.was.asm;</p>
<p>02</p>
<p>import</p>
<p>java.util./*;
03</p>
<p>import</p>
<p>org.objectweb.asm./*;</p>
<p>04</p>
<p>import</p>
<p>org.objectweb.asm.attrs./*;
05</p>
<p>public</p>
<p>class</p>
<p>SayHelloImplDump </p>
<p>implements</p>
<p>Opcodes {</p>
<p>06</p>
<p>public</p>
<p>static</p>
<p>byte</p>
<p>[] dump () </p>
<p>throws</p>
<p>Exception {
07</p>
<p>ClassWriter cw = </p>
<p>new</p>
<p>ClassWriter(</p>
<p>0</p>
<p>);</p>
<p>08</p>
<p>FieldVisitor fv;
09</p>
<p>MethodVisitor mv;</p>
<p>10</p>
<p>AnnotationVisitor av0;
11</p>
<p>12</p>
<p>cw.visit(V1_6, ACC_PUBLIC + ACC_SUPER, </p>
<p>&quot;com/ibm/was/asm/SayHelloImpl&quot;</p>
<p>,
13</p>
<p>null</p>
<p>, </p>
<p>&quot;java/lang/Object&quot;</p>
<p>, </p>
<p>null</p>
<p>);</p>
<p>14</p>
<p>15</p>
<p>{</p>
<p>16</p>
<p>mv = cw.visitMethod(ACC_PUBLIC, </p>
<p>&quot;<init>&quot;</p>
<p>, </p>
<p>&quot;()V&quot;</p>
<p>, </p>
<p>null</p>
<p>, </p>
<p>null</p>
<p>);
17</p>
<p>mv.visitCode();</p>
<p>18</p>
<p>mv.visitVarInsn(ALOAD, </p>
<p>0</p>
<p>);
19</p>
<p>mv.visitMethodInsn(INVOKESPECIAL, </p>
<p>&quot;java/lang/Object&quot;</p>
<p>, </p>
<p>&quot;<init>&quot;</p>
<p>, </p>
<p>&quot;()V&quot;</p>
<p>);</p>
<p>20</p>
<p>mv.visitInsn(RETURN);
21</p>
<p>mv.visitMaxs(</p>
<p>1</p>
<p>, </p>
<p>1</p>
<p>);</p>
<p>22</p>
<p>mv.visitEnd();
23</p>
<p>}</p>
<p>24</p>
<p>{
25</p>
<p>mv = cw.visitMethod(ACC_PUBLIC, </p>
<p>&quot;sayHello&quot;</p>
<p>,</p>
<p>26</p>
<p>&quot;(Ljava/lang/String;)Ljava/lang/String;&quot;</p>
<p>, </p>
<p>null</p>
<p>, </p>
<p>null</p>
<p>);
27</p>
<p>mv.visitCode();</p>
<p>28</p>
<p>mv.visitTypeInsn(NEW, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>);
29</p>
<p>mv.visitInsn(DUP);</p>
<p>30</p>
<p>mv.visitLdcInsn(</p>
<p>&quot;Hello:&quot;</p>
<p>);
31</p>
<p>mv.visitMethodInsn(INVOKESPECIAL, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>,</p>
<p>32</p>
<p>&quot;<init>&quot;</p>
<p>, </p>
<p>&quot;(Ljava/lang/String;)V&quot;</p>
<p>);
33</p>
<p>mv.visitVarInsn(ALOAD, </p>
<p>1</p>
<p>);</p>
<p>34</p>
<p>mv.visitMethodInsn(INVOKEVIRTUAL, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>,
35</p>
<p>&quot;append&quot;</p>
<p>, </p>
<p>&quot;(Ljava/lang/String;)Ljava/lang/StringBuilder;&quot;</p>
<p>);</p>
<p>36</p>
<p>mv.visitMethodInsn(INVOKEVIRTUAL, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>,
37</p>
<p>&quot;toString&quot;</p>
<p>, </p>
<p>&quot;()Ljava/lang/String;&quot;</p>
<p>);</p>
<p>38</p>
<p>mv.visitInsn(ARETURN);
39</p>
<p>mv.visitMaxs(</p>
<p>3</p>
<p>, </p>
<p>2</p>
<p>);</p>
<p>40</p>
<p>mv.visitEnd();
41</p>
<p>}</p>
<p>42</p>
<p>cw.visitEnd();
43</p>
<p>return</p>
<p>cw.toByteArray();</p>
<p>44</p>
<p>}
45</p>
<p>}</p>
<p>图 1 描述了 Java Source 文件、Java Class 文件、ASM Code 文件和 ASM Source 文件之间的转换关系。
<a href=""><strong>图 1. 四种文件的转换图</strong></a> 
<a href=""><img src="" alt="图 1. 四种文件的转换图"></a> </p>
<p>如图 -1 所示，Java Source 文件通过 Javac 可以转换为 Java Class 文件。而相应的 Java Class 文件通过 Java 反编译器工具可转换为 Java Source 文件；</p>
<p>通 过 ASM Code 去创建和修改 Java Class 需要对 ASM API 比较熟悉才行，一个常见的问题时，怎么用 ASM Code 生成一个我们希望的 class 文件， 也就是说， 给定了 Java Class， 怎么得到其对应的 ASM Code 呢？ 所幸的是， ASM 框架为我们提供了 ASMifierClassVisitor 工具来产生 Java Class 对应的 ASM Code。代码如下：
<a href=""><strong>清单 7. 给定 class 文件，通过 ASMifierClassVisitor 获得其对应的 ASM Code</strong></a><a href="http://www.oschina.net/question/129540_28430#viewSource" title="view source" target="_blank">view source</a><a href="http://www.oschina.net/question/129540_28430#printSource" title="print" target="_blank">print</a><a href="http://www.oschina.net/question/129540_28430#about" title="?" target="_blank">?</a></p>
<p>01</p>
<p>public</p>
<p>void</p>
<p>showClassASMProcess() {</p>
<p>02</p>
<p>ClassReader cr;
03</p>
<p>final</p>
<p>String n = SayHelloImpl.</p>
<p>class</p>
<p>.getName();</p>
<p>04</p>
<p>05</p>
<p>try</p>
<p>{</p>
<p>06</p>
<p>cr = </p>
<p>new</p>
<p>ClassReader(n);<br>07</p>
<p>cr.accept(</p>
<p>new</p>
<p>ASMifierClassVisitor(</p>
<p>new</p>
<p>PrintWriter(System.out)),</p>
<p>08</p>
<p>new</p>
<p>Attribute[</p>
<p>0</p>
<p>],
09</p>
<p>ClassReader.SKIP_DEBUG);</p>
<p>10</p>
<p>11</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {</p>
<p>12</p>
<p>e.printStackTrace();
13</p>
<p>}</p>
<p>14</p>
<p>}</p>
<p>另外一个重要的转换就是， 给定了 Java Class 文件， 如何查看它的 ASM Source ？ 这点对于我们验证 ASM Code 生成的 class 是否正确很有用。ASM 提供了另外一个工具 TraceClassVisitor， 来获得一个 Java Class 对应的 ASM Source。代码如下：
<a href=""><strong>清单 8. 利用 TraceClassVisitor 查看 class 文件的 ASM Source</strong></a>01</p>
<p>//file 是 class 文件的全路径名</p>
<p>02</p>
<p>public</p>
<p>void</p>
<p>showClassSource(String file) {
03</p>
<p>FileInputStream is ;</p>
<p>04</p>
<p>ClassReader cr; 
05</p>
<p>06</p>
<p>try</p>
<p>{
07</p>
<p>is = </p>
<p>new</p>
<p>FileInputStream(file);     </p>
<p>08</p>
<p>cr = </p>
<p>new</p>
<p>ClassReader(is);
09</p>
<p>TraceClassVisitor trace = </p>
<p>new</p>
<p>TraceClassVisitor(</p>
<p>new</p>
<p>PrintWriter(System.out));</p>
<p>10</p>
<p>cr.accept(trace, ClassReader.SKIP_DEBUG);
11</p>
<p>12</p>
<p>is.close() ;
13</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {</p>
<p>14</p>
<p>e.printStackTrace() ;
15</p>
<p>}</p>
<p>16</p>
<p>}
17</p>
<p>{</p>
<p>18</p>
<p>e.printStackTrace();
19</p>
<p>}</p>
<p>20</p>
<p>}</p>
<p><a href="">ASM 类注入</a></p>
<p>ASM 类注入是指修改一个现有的 class 文件，在其中加入自己的代码。按通常思维，我们需要利用 ASM 提供的 reader 类去读取所要修改的类文件， 找到要修改的地方，如方法名或属性名，然后在该处插入自己的代码或修改现有的代码，这种思路将使问题复杂化。 ASM 为我们提供了访问类文件的 Visitor 模式，来遍历一个 class 文件，Visitor 是一个实现 ClassVisitor 接口的类。 要注入一个 class 文件，先要找到一个合适的 Visitor 做向导， ASM 提供了好几种 Visitor， 最常用的是 ClassWriter。同时我们需要提供一个适配器类 ClassAdapter， Visitor 会带着这个 Adapter 一起去遍历， 然后在遍历过程中回调 Adapter 提供的方法。我们在 Adapter 的这些方法中就可以实现我们的修改和定制逻辑。当然，如果你不想做任何修改，那 Visitor 遍历完后将得到一个和被遍历的 class 完全一样的拷贝。
<a href=""><strong>清单 9. 类注入的完整过程</strong></a>01</p>
<p>public</p>
<p>void</p>
<p>addAnnotationToExistingClass() {</p>
<p>02</p>
<p>FileInputStream is ;
03</p>
<p>ClassReader cr;          </p>
<p>04</p>
<p>try</p>
<p>{<br>05</p>
<p>String classfile = </p>
<p>&quot;E:\SayHelloImpl.class&quot;</p>
<p>; </p>
<p>// 待遍历的类</p>
<p>06</p>
<p>showClassSource(classfile) ;  </p>
<p>// 打印该类的 ASM source
07</p>
<p>08</p>
<p>is = </p>
<p>new</p>
<p>FileInputStream(classfile);<br>09</p>
<p>cr = </p>
<p>new</p>
<p>ClassReader(is);</p>
<p>10</p>
<p>// 此处我们使用 ClassWriter 做 Visitor
11</p>
<p>ClassWriter cw = </p>
<p>new</p>
<p>ClassWriter(ClassWriter.COMPUTE_MAXS);</p>
<p>12</p>
<p>// 给 Visitor 提供一个 Adapter
13</p>
<p>AddAnnotationAdapter adapter = </p>
<p>new</p>
<p>AddAnnotationAdapter(cw);           </p>
<p>14</p>
<p>cr.accept(adapter, ClassReader.SKIP_DEBUG);<br>15</p>
<p>16</p>
<p>// 遍历完后，生成的 class 保存在字节数组中
17</p>
<p>byte</p>
<p>[] b = cw.toByteArray();</p>
<p>18</p>
<p>19</p>
<p>try</p>
<p>{</p>
<p>20</p>
<p>// 将字节数组输出到文件中
21</p>
<p>// 为了不至于覆盖掉原有的 SayHelloImpl.class 文件，我们将结果输出到 _SayHelloImpl.class</p>
<p>22</p>
<p>FileOutputStream fout = </p>
<p>new</p>
<p>FileOutputStream(</p>
<p>&quot;E:\_SayHelloImpl.class&quot;</p>
<p>);
23</p>
<p>fout.write(b) ;</p>
<p>24</p>
<p>fout.flush();
25</p>
<p>fout.close() ;</p>
<p>26</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {
27</p>
<p>e.printStackTrace() ;</p>
<p>28</p>
<p>}
29</p>
<p>30</p>
<p>// 验证 _SayHelloImpl.class 是否包含我们注入的代码
31</p>
<p>showClassSource(</p>
<p>&quot;E:\_SayHelloImpl.class&quot;</p>
<p>) ;</p>
<p>32</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {
33</p>
<p>e.printStackTrace();</p>
<p>34</p>
<p>} 
35</p>
<p>}</p>
<p><a href="">web services 标记注入过程</a></p>
<p>我们已经知道了如何往 class 中注入自己的代码，那对于一个已有的 Java bean，怎么往里注入 @WebService 和 @WebMethod 呢？根据上面我们讲的转换关系，我们可以先写一个带 annotation 的 Java Source，编译得到 Java Class， 再得到其 ASM Code。下面是利用 ASM 给一个不带任何 Annotation 的 class 添加 @WebService 和 @WebMethod 的步骤。</p>
<ol>
<li>首先在 SayHelloImpl.java 中添加 @WebService 和 @WebMethod： 
<a href=""><strong>清单 10. 带 web services 标注的 SayHelloImpl 类</strong></a>1</li>
</ol>
<p>@WebService</p>
<p>2</p>
<p>public</p>
<p>class</p>
<p>SayHelloImpl {
3</p>
<p>@WebMethod</p>
<p>4</p>
<p>public</p>
<p>String sayHello(String s) {
5</p>
<p>return</p>
<p>&quot;Hello: &quot;</p>
<ul>
<li>s ;</li>
</ul>
<p>6</p>
<p>}
7</p>
<p>}</p>
<ol>
<li>通过 ASMifierClassVisitor 工具获得 SayHelloImpl class 的 ASM Code，见清单 6。</li>
<li>写一个 ClassAdapter 类， ClassAdapter 其实也是一个 Visitor。根据 ASM Code 的提示， 我们就可以知道如何利用 ASM API 去获得我们希望的 class 文件。下面是 Adapter 的示例代码。 
<a href=""><strong>清单 11. 添加 Annotation 的 Adapter 类</strong></a>01</li>
</ol>
<p>public</p>
<p>class</p>
<p>AddAnnotationAdapter </p>
<p>extends</p>
<p>ClassAdapter </p>
<p>implements</p>
<p>Opcodes{</p>
<p>02</p>
<p>//private String annotationDesc;
03</p>
<p>private</p>
<p>boolean</p>
<p>isAnnotationPresent;</p>
<p>04</p>
<p>05</p>
<p>public</p>
<p>AddAnnotationAdapter(ClassVisitor cv) {</p>
<p>06</p>
<p>super</p>
<p>(cv);
07</p>
<p>}</p>
<p>08</p>
<p>09</p>
<p>@Override</p>
<p>10</p>
<p>public</p>
<p>void</p>
<p>visit(</p>
<p>int</p>
<p>version, </p>
<p>int</p>
<p>access, String name, String signature,
11</p>
<p>String superName, String[] interfaces) {</p>
<p>12</p>
<p>13</p>
<p>cv.visit(V1_6, ACC_PUBLIC + ACC_SUPER, name, signature, superName,</p>
<p>14</p>
<p>interfaces);
15</p>
<p>AnnotationVisitor av0;</p>
<p>16</p>
<p>av0 = cv.visitAnnotation(</p>
<p>&quot;Ljavax/jws/WebService;&quot;</p>
<p>, </p>
<p>true</p>
<p>);
17</p>
<p>av0.visitEnd();</p>
<p>18</p>
<p>}
19</p>
<p>20</p>
<p>@Override
21</p>
<p>public</p>
<p>AnnotationVisitor visitAnnotation(String desc, </p>
<p>boolean</p>
<p>visible) {</p>
<p>22</p>
<p>return</p>
<p>cv.visitAnnotation(desc, visible);
23</p>
<p>}</p>
<p>24</p>
<p>25</p>
<p>@Override</p>
<p>26</p>
<p>public</p>
<p>void</p>
<p>visitInnerClass(String name, String outerName,
27</p>
<p>String innerName, </p>
<p>int</p>
<p>access) {</p>
<p>28</p>
<p>cv.visitInnerClass(name, outerName, innerName, access);
29</p>
<p>}</p>
<p>30</p>
<p>31</p>
<p>@Override</p>
<p>32</p>
<p>public</p>
<p>FieldVisitor visitField(</p>
<p>int</p>
<p>access, String name, String desc,
33</p>
<p>String signature, Object value) {</p>
<p>34</p>
<p>return</p>
<p>cv.visitField(access, name, desc, signature, value);
35</p>
<p>}</p>
<p>36</p>
<p>37</p>
<p>@Override</p>
<p>38</p>
<p>public</p>
<p>MethodVisitor visitMethod(</p>
<p>int</p>
<p>access, String name, String desc,
39</p>
<p>String signature, String[] exceptions) {   </p>
<p>40</p>
<p>MethodVisitor mv  = cv.visitMethod(access, name, desc, signature,
41</p>
<p>exceptions);</p>
<p>42</p>
<p>if</p>
<p>(!name.equals(</p>
<p>&quot;<init>&quot;</p>
<p>)) {
43</p>
<p>AnnotationVisitor av0;</p>
<p>44</p>
<p>av0 = mv.visitAnnotation(</p>
<p>&quot;Ljavax/jws/WebMethod;&quot;</p>
<p>, </p>
<p>true</p>
<p>);
45</p>
<p>av0.visitEnd();</p>
<p>46</p>
<p>}
47</p>
<p>return</p>
<p>mv;</p>
<p>48</p>
<p>}
49</p>
<p>50</p>
<p>@Override
51</p>
<p>public</p>
<p>void</p>
<p>visitEnd() {</p>
<p>52</p>
<p>cv.visitEnd();
53</p>
<p>}</p>
<p>54</p>
<p>55</p>
<p>}</p>
<p>最后，我们采用上面讲的类注入办法，即可得到一个带 @WebService 和 @WebMethod 标注的 class 文件。再通过 wsgen 工具即可成功创建 web services，该命令将会在 src 目录下生成 web services 描述文件：SayHelloImplService.wsdl，SayHelloImplService_schema1.xsd，同时生成了 2 个 JAX-WS 文件，分别为：SayHello.java，SayHelloResponse.java。</p>
<p>当然，在实际应用中，我们可能需要将一个 class 的某些特定方法发布为 web services，这就需要我们对 Adapter 做进一步的改造，在 visitMethod() 方法中根据方法名称等参数做进一步的处理。</p>
<p><a href="">结束语</a></p>
<p>本文简要介绍了 ASM 字节码工具及其在 web services 开发中的应用。web services 的使用已经越来越广泛， 但在改造遗留系统过程中会遇到不少问题，本文针对其中一个主要问题给出了解决办法，该方法无须对现有系统做大量的改动， 即可将现存的 Java bean 转化成 web services 。本文对那些正考虑迁移到 JAX-WS 编程模型上的项目有一定的参考价值。在基于 JAX-WS 标准的 web services 的开发中，不少实际场景都是希望采用自底向上的开发方式， 即基于已有的 Java bean 来创建 web services 。WebSphere Application Server ( 以下简称 WAS ) 提供了命令行的工具 wsgen 和相对应的 Ant task 来支持这种开发过程，而且这两个工具比较适合大型项目的自动化构建。 这两个工具的使用前提是 Java bean 中事先添加有 web services 的 Annotation 标注，而在现有的业务系统中，class 文件一般是不带 Annotation 的，这就需要开发人员去修改现有的代码，以手工方式添加 Annotation，但这样带来的工作量太大且容易出错。本文介绍了一种解决途径，可以不用修改源代码，而是利用字节码工具 ASM 直接修改 class 文件， 在字节码文件中自动注入 Annotation ，然后再利用 wsgen 工具就可以很方便地生成 web services 应用。 本文同时也总结了使用 ASM 的一些实践。</p>
<p>本文首先介绍了和 ASM 使用相关的四种文件，以及它们之间的相互转化。然后结合 web services 开发实例，介绍了使用 wsgen 开发时遇到的实际问题，如何写一个 ASM 的适配器去修改现有 class，最终如何产生 web services 文件。</p>
<p>ASM 是一个多用途的 Java 字节码操控和分析框架。它能以二进制的形式直接修改现有的类或动态生成的类。 ASM 提供了常用的转换和分析算法，是一种允许用户方便的组装定制化的复杂转换和代码分析工具。 ASM 也提供和其它的字节码工具类似的功能，但 ASM 的重点是使用的简单和高性能。由于 ASM 在设计实现的时候尽可能 的小的内存占用和提供更高的性能；因此在动态系统中使用 ASM 是很有优势的。ASM 作为一种轻量级、高性能的 Java 字节码操控和分析框架，设计了一种更有效的方法、提供更好的性能和内存占用。今天， ASM 在许多领域都有应用，并已成为事实上的字节码处理框架标准。</p>
<p><a href="">问题的引入</a></p>
<p>先写一个不带 web services 标注的 SayHelloImpl 类。
<a href=""><strong>清单 1. 不带 web services 的 SayHelloImpl 类</strong></a>1</p>
<p>public</p>
<p>class</p>
<p>SayHelloImpl {</p>
<p>2</p>
<p>public</p>
<p>String sayHello(String s) {
3</p>
<p>return</p>
<p>“Hello: ” + s ;</p>
<p>4</p>
<p>}
5</p>
<p>}</p>
<p>再用 wsgen 来创建 web services，wsgen 的使用如下：
<a href=""><strong>清单 2. wsgen 实例</strong></a>1</p>
<p>wsgen.exe – </p>
<p>cp</p>
<p>bin – s output – d output – r output – wsdl ibm.was.asm.SayHelloImpl我们将会遇到如下错误： 
<a href=""><strong>清单 3. 根据不带 web services 标注的类创建 web services 时遇到的错误信息</strong></a> 
注释处理过程中遇到问题；</p>
<p>......
com.sun.tools.internal.ws.processor.modeler.ModelerException: [failed to localiz</p>
<p>e] A web service endpoint could not be found()
        at com.sun.tools.internal.ws.processor.modeler.annotation.WebServiceAP.o</p>
<p>nError(WebServiceAP.java:215)
        at com.sun.tools.internal.ws.processor.modeler.annotation.WebServiceAP.b</p>
<p>uildModel(WebServiceAP.java:322)
        at com.sun.tools.internal.ws.processor.modeler.annotation.WebServiceAP.p</p>
<p>rocess(WebServiceAP.java:256)
        at com.sun.mirror.apt.AnnotationProcessors$CompositeAnnotationProcessor.</p>
<p>process(AnnotationProcessors.java:60)</p>
<p>注意：我们通常是在 class 前使用 @WebService， 在方法前使用 @WebMethod 来将一个类标注为 web services 的。WAS 6.1 的 web services 功能部件包和 WAS 7 都支持基于 JAX-WS 标准 的 web services 的开发， 在 WAS 安装目录的 bin 目录下提供了命令行工具 wsgen，wsgen 支持自底向上的开发方式。 下面是 wsgen 的用法：
<a href=""><strong>清单 4. wsgen 命令格式</strong></a> 
注 wsgen [options]  [SEI]</p>
<p>主要选项：</p>
<ul>
<li>-d 指定生成的 class 文件位置；</li>
<li>-s 指定生成的 Java 源文件位置；</li>
<li>-r 指定生成的 resources 文件位置，如 wsdl，xsd；</li>
<li>-cp 指定服务实现类所在的位置；</li>
<li>-wsdl，-servicename，-portname 三个参数指定生成的 wsdl 文件中的 service 和 port 的名称。</li>
</ul>
<p>SEI(Service Endpoint Interface) 是一个 endpoint implementation class，不能是一个 interface。所以首先要开发一个 endpoint 的实现类，如本例中的 SayHelloImpl 。用 @WebService 声明 web services ，然后将它编译，才能提供给 wsgen 来创建 web services 。</p>
<p><a href="">四种文件之间的转换</a></p>
<p>下面介绍本文要用到的四个概念（Java Source，Java Class，ASM Code，ASM Source）</p>
<ul>
<li>Java Source: 即我们通常编写的 Java 源文件；</li>
<li>Java Class: Java 源文件编译后的字节码文件；</li>
<li>ASM Source : 类似于对 class 反编译后的源文件，也就是 &quot;textual byte code&quot;，但比原始的 Java Source 可读性要差， 参见清单 5。</li>
<li>ASM Code: 指读写 class 文件的 ASM 程序代码。需要用到 ASM 提供的 API， 参见清单 6。
<a href=""><strong>清单 5. SayHelloImpl 类对应的 ASM Source</strong></a>01</li>
</ul>
<p>// class version 50.0 (50)</p>
<p>02</p>
<p>// access flags 33
03</p>
<p>public</p>
<p>class</p>
<p>com/ibm/was/asm/SayHelloImpl {</p>
<p>04</p>
<p>05</p>
<p>// access flags 1</p>
<p>06</p>
<p>public</p>
<p><init>()V
07</p>
<p>ALOAD </p>
<p>0</p>
<p>08</p>
<p>INVOKESPECIAL java/lang/Object. <init> ()V
09</p>
<p>RETURN</p>
<p>10</p>
<p>MAXSTACK = </p>
<p>1
11</p>
<p>MAXLOCALS = </p>
<p>1</p>
<p>12</p>
<p>13</p>
<p>// access flags 1</p>
<p>14</p>
<p>public</p>
<p>sayHello(Ljava/lang/String;)Ljava/lang/String;
15</p>
<p>NEW java/lang/StringBuilder</p>
<p>16</p>
<p>DUP
17</p>
<p>LDC </p>
<p>&quot;Hello:&quot;</p>
<p>18</p>
<p>INVOKESPECIAL java/lang/StringBuilder. <init> (Ljava/lang/String;)V
19</p>
<p>ALOAD </p>
<p>1</p>
<p>20</p>
<p>INVOKEVIRTUAL java/lang/StringBuilder.append (Ljava/lang/String;)
21</p>
<p>Ljava/lang/StringBuilder;</p>
<p>22</p>
<p>INVOKEVIRTUAL java/lang/StringBuilder.toString ()Ljava/lang/String;
23</p>
<p>ARETURN</p>
<p>24</p>
<p>MAXSTACK = </p>
<p>3
25</p>
<p>MAXLOCALS = </p>
<p>2</p>
<p>26</p>
<p>}<a href=""><strong>清单 6. 生成 SayHelloImpl.class 的 ASM Code</strong></a>01</p>
<p>package</p>
<p>asm.com.ibm.was.asm;</p>
<p>02</p>
<p>import</p>
<p>java.util./*;
03</p>
<p>import</p>
<p>org.objectweb.asm./*;</p>
<p>04</p>
<p>import</p>
<p>org.objectweb.asm.attrs./*;
05</p>
<p>public</p>
<p>class</p>
<p>SayHelloImplDump </p>
<p>implements</p>
<p>Opcodes {</p>
<p>06</p>
<p>public</p>
<p>static</p>
<p>byte</p>
<p>[] dump () </p>
<p>throws</p>
<p>Exception {
07</p>
<p>ClassWriter cw = </p>
<p>new</p>
<p>ClassWriter(</p>
<p>0</p>
<p>);</p>
<p>08</p>
<p>FieldVisitor fv;
09</p>
<p>MethodVisitor mv;</p>
<p>10</p>
<p>AnnotationVisitor av0;
11</p>
<p>12</p>
<p>cw.visit(V1_6, ACC_PUBLIC + ACC_SUPER, </p>
<p>&quot;com/ibm/was/asm/SayHelloImpl&quot;</p>
<p>,
13</p>
<p>null</p>
<p>, </p>
<p>&quot;java/lang/Object&quot;</p>
<p>, </p>
<p>null</p>
<p>);</p>
<p>14</p>
<p>15</p>
<p>{</p>
<p>16</p>
<p>mv = cw.visitMethod(ACC_PUBLIC, </p>
<p>&quot;<init>&quot;</p>
<p>, </p>
<p>&quot;()V&quot;</p>
<p>, </p>
<p>null</p>
<p>, </p>
<p>null</p>
<p>);
17</p>
<p>mv.visitCode();</p>
<p>18</p>
<p>mv.visitVarInsn(ALOAD, </p>
<p>0</p>
<p>);
19</p>
<p>mv.visitMethodInsn(INVOKESPECIAL, </p>
<p>&quot;java/lang/Object&quot;</p>
<p>, </p>
<p>&quot;<init>&quot;</p>
<p>, </p>
<p>&quot;()V&quot;</p>
<p>);</p>
<p>20</p>
<p>mv.visitInsn(RETURN);
21</p>
<p>mv.visitMaxs(</p>
<p>1</p>
<p>, </p>
<p>1</p>
<p>);</p>
<p>22</p>
<p>mv.visitEnd();
23</p>
<p>}</p>
<p>24</p>
<p>{
25</p>
<p>mv = cw.visitMethod(ACC_PUBLIC, </p>
<p>&quot;sayHello&quot;</p>
<p>,</p>
<p>26</p>
<p>&quot;(Ljava/lang/String;)Ljava/lang/String;&quot;</p>
<p>, </p>
<p>null</p>
<p>, </p>
<p>null</p>
<p>);
27</p>
<p>mv.visitCode();</p>
<p>28</p>
<p>mv.visitTypeInsn(NEW, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>);
29</p>
<p>mv.visitInsn(DUP);</p>
<p>30</p>
<p>mv.visitLdcInsn(</p>
<p>&quot;Hello:&quot;</p>
<p>);
31</p>
<p>mv.visitMethodInsn(INVOKESPECIAL, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>,</p>
<p>32</p>
<p>&quot;<init>&quot;</p>
<p>, </p>
<p>&quot;(Ljava/lang/String;)V&quot;</p>
<p>);
33</p>
<p>mv.visitVarInsn(ALOAD, </p>
<p>1</p>
<p>);</p>
<p>34</p>
<p>mv.visitMethodInsn(INVOKEVIRTUAL, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>,
35</p>
<p>&quot;append&quot;</p>
<p>, </p>
<p>&quot;(Ljava/lang/String;)Ljava/lang/StringBuilder;&quot;</p>
<p>);</p>
<p>36</p>
<p>mv.visitMethodInsn(INVOKEVIRTUAL, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>,
37</p>
<p>&quot;toString&quot;</p>
<p>, </p>
<p>&quot;()Ljava/lang/String;&quot;</p>
<p>);</p>
<p>38</p>
<p>mv.visitInsn(ARETURN);
39</p>
<p>mv.visitMaxs(</p>
<p>3</p>
<p>, </p>
<p>2</p>
<p>);</p>
<p>40</p>
<p>mv.visitEnd();
41</p>
<p>}</p>
<p>42</p>
<p>cw.visitEnd();
43</p>
<p>return</p>
<p>cw.toByteArray();</p>
<p>44</p>
<p>}
45</p>
<p>}</p>
<p>图 1 描述了 Java Source 文件、Java Class 文件、ASM Code 文件和 ASM Source 文件之间的转换关系。
<a href=""><strong>图 1. 四种文件的转换图</strong></a> 
<a href=""><img src="" alt="图 1. 四种文件的转换图"></a> </p>
<p>如图 -1 所示，Java Source 文件通过 Javac 可以转换为 Java Class 文件。而相应的 Java Class 文件通过 Java 反编译器工具可转换为 Java Source 文件；</p>
<p>通 过 ASM Code 去创建和修改 Java Class 需要对 ASM API 比较熟悉才行，一个常见的问题时，怎么用 ASM Code 生成一个我们希望的 class 文件， 也就是说， 给定了 Java Class， 怎么得到其对应的 ASM Code 呢？ 所幸的是， ASM 框架为我们提供了 ASMifierClassVisitor 工具来产生 Java Class 对应的 ASM Code。代码如下：
<a href=""><strong>清单 7. 给定 class 文件，通过 ASMifierClassVisitor 获得其对应的 ASM Code</strong></a>01</p>
<p>public</p>
<p>void</p>
<p>showClassASMProcess() {</p>
<p>02</p>
<p>ClassReader cr;
03</p>
<p>final</p>
<p>String n = SayHelloImpl.</p>
<p>class</p>
<p>.getName();</p>
<p>04</p>
<p>05</p>
<p>try</p>
<p>{</p>
<p>06</p>
<p>cr = </p>
<p>new</p>
<p>ClassReader(n);<br>07</p>
<p>cr.accept(</p>
<p>new</p>
<p>ASMifierClassVisitor(</p>
<p>new</p>
<p>PrintWriter(System.out)),</p>
<p>08</p>
<p>new</p>
<p>Attribute[</p>
<p>0</p>
<p>],
09</p>
<p>ClassReader.SKIP_DEBUG);</p>
<p>10</p>
<p>11</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {</p>
<p>12</p>
<p>e.printStackTrace();
13</p>
<p>}</p>
<p>14</p>
<p>}</p>
<p>另外一个重要的转换就是， 给定了 Java Class 文件， 如何查看它的 ASM Source ？ 这点对于我们验证 ASM Code 生成的 class 是否正确很有用。ASM 提供了另外一个工具 TraceClassVisitor， 来获得一个 Java Class 对应的 ASM Source。代码如下：
<a href=""><strong>清单 8. 利用 TraceClassVisitor 查看 class 文件的 ASM Source</strong></a>01</p>
<p>//file 是 class 文件的全路径名</p>
<p>02</p>
<p>public</p>
<p>void</p>
<p>showClassSource(String file) {
03</p>
<p>FileInputStream is ;</p>
<p>04</p>
<p>ClassReader cr; 
05</p>
<p>06</p>
<p>try</p>
<p>{
07</p>
<p>is = </p>
<p>new</p>
<p>FileInputStream(file);     </p>
<p>08</p>
<p>cr = </p>
<p>new</p>
<p>ClassReader(is);
09</p>
<p>TraceClassVisitor trace = </p>
<p>new</p>
<p>TraceClassVisitor(</p>
<p>new</p>
<p>PrintWriter(System.out));</p>
<p>10</p>
<p>cr.accept(trace, ClassReader.SKIP_DEBUG);
11</p>
<p>12</p>
<p>is.close() ;
13</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {</p>
<p>14</p>
<p>e.printStackTrace() ;
15</p>
<p>}</p>
<p>16</p>
<p>}
17</p>
<p>{</p>
<p>18</p>
<p>e.printStackTrace();
19</p>
<p>}</p>
<p>20</p>
<p>}</p>
<p><a href="">ASM 类注入</a></p>
<p>ASM 类注入是指修改一个现有的 class 文件，在其中加入自己的代码。按通常思维，我们需要利用 ASM 提供的 reader 类去读取所要修改的类文件， 找到要修改的地方，如方法名或属性名，然后在该处插入自己的代码或修改现有的代码，这种思路将使问题复杂化。 ASM 为我们提供了访问类文件的 Visitor 模式，来遍历一个 class 文件，Visitor 是一个实现 ClassVisitor 接口的类。 要注入一个 class 文件，先要找到一个合适的 Visitor 做向导， ASM 提供了好几种 Visitor， 最常用的是 ClassWriter。同时我们需要提供一个适配器类 ClassAdapter， Visitor 会带着这个 Adapter 一起去遍历， 然后在遍历过程中回调 Adapter 提供的方法。我们在 Adapter 的这些方法中就可以实现我们的修改和定制逻辑。当然，如果你不想做任何修改，那 Visitor 遍历完后将得到一个和被遍历的 class 完全一样的拷贝。
<a href=""><strong>清单 9. 类注入的完整过程</strong></a>01</p>
<p>public</p>
<p>void</p>
<p>addAnnotationToExistingClass() {</p>
<p>02</p>
<p>FileInputStream is ;
03</p>
<p>ClassReader cr;          </p>
<p>04</p>
<p>try</p>
<p>{<br>05</p>
<p>String classfile = </p>
<p>&quot;E:\SayHelloImpl.class&quot;</p>
<p>; </p>
<p>// 待遍历的类</p>
<p>06</p>
<p>showClassSource(classfile) ;  </p>
<p>// 打印该类的 ASM source
07</p>
<p>08</p>
<p>is = </p>
<p>new</p>
<p>FileInputStream(classfile);<br>09</p>
<p>cr = </p>
<p>new</p>
<p>ClassReader(is);</p>
<p>10</p>
<p>// 此处我们使用 ClassWriter 做 Visitor
11</p>
<p>ClassWriter cw = </p>
<p>new</p>
<p>ClassWriter(ClassWriter.COMPUTE_MAXS);</p>
<p>12</p>
<p>// 给 Visitor 提供一个 Adapter
13</p>
<p>AddAnnotationAdapter adapter = </p>
<p>new</p>
<p>AddAnnotationAdapter(cw);           </p>
<p>14</p>
<p>cr.accept(adapter, ClassReader.SKIP_DEBUG);<br>15</p>
<p>16</p>
<p>// 遍历完后，生成的 class 保存在字节数组中
17</p>
<p>byte</p>
<p>[] b = cw.toByteArray();</p>
<p>18</p>
<p>19</p>
<p>try</p>
<p>{</p>
<p>20</p>
<p>// 将字节数组输出到文件中
21</p>
<p>// 为了不至于覆盖掉原有的 SayHelloImpl.class 文件，我们将结果输出到 _SayHelloImpl.class</p>
<p>22</p>
<p>FileOutputStream fout = </p>
<p>new</p>
<p>FileOutputStream(</p>
<p>&quot;E:\_SayHelloImpl.class&quot;</p>
<p>);
23</p>
<p>fout.write(b) ;</p>
<p>24</p>
<p>fout.flush();
25</p>
<p>fout.close() ;</p>
<p>26</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {
27</p>
<p>e.printStackTrace() ;</p>
<p>28</p>
<p>}
29</p>
<p>30</p>
<p>// 验证 _SayHelloImpl.class 是否包含我们注入的代码
31</p>
<p>showClassSource(</p>
<p>&quot;E:\_SayHelloImpl.class&quot;</p>
<p>) ;</p>
<p>32</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {
33</p>
<p>e.printStackTrace();</p>
<p>34</p>
<p>} 
35</p>
<p>}</p>
<p><a href="">web services 标记注入过程</a></p>
<p>我们已经知道了如何往 class 中注入自己的代码，那对于一个已有的 Java bean，怎么往里注入 @WebService 和 @WebMethod 呢？根据上面我们讲的转换关系，我们可以先写一个带 annotation 的 Java Source，编译得到 Java Class， 再得到其 ASM Code。下面是利用 ASM 给一个不带任何 Annotation 的 class 添加 @WebService 和 @WebMethod 的步骤。</p>
<ol>
<li>首先在 SayHelloImpl.java 中添加 @WebService 和 @WebMethod： 
<a href=""><strong>清单 10. 带 web services 标注的 SayHelloImpl 类</strong></a>1</li>
</ol>
<p>@WebService</p>
<p>2</p>
<p>public</p>
<p>class</p>
<p>SayHelloImpl {
3</p>
<p>@WebMethod</p>
<p>4</p>
<p>public</p>
<p>String sayHello(String s) {
5</p>
<p>return</p>
<p>&quot;Hello: &quot;</p>
<ul>
<li>s ;</li>
</ul>
<p>6</p>
<p>}
7</p>
<p>}</p>
<ol>
<li>通过 ASMifierClassVisitor 工具获得 SayHelloImpl class 的 ASM Code，见清单 6。</li>
<li>写一个 ClassAdapter 类， ClassAdapter 其实也是一个 Visitor。根据 ASM Code 的提示， 我们就可以知道如何利用 ASM API 去获得我们希望的 class 文件。下面是 Adapter 的示例代码。 
<a href=""><strong>清单 11. 添加 Annotation 的 Adapter 类</strong></a>01</li>
</ol>
<p>public</p>
<p>class</p>
<p>AddAnnotationAdapter </p>
<p>extends</p>
<p>ClassAdapter </p>
<p>implements</p>
<p>Opcodes{</p>
<p>02</p>
<p>//private String annotationDesc;
03</p>
<p>private</p>
<p>boolean</p>
<p>isAnnotationPresent;</p>
<p>04</p>
<p>05</p>
<p>public</p>
<p>AddAnnotationAdapter(ClassVisitor cv) {</p>
<p>06</p>
<p>super</p>
<p>(cv);
07</p>
<p>}</p>
<p>08</p>
<p>09</p>
<p>@Override</p>
<p>10</p>
<p>public</p>
<p>void</p>
<p>visit(</p>
<p>int</p>
<p>version, </p>
<p>int</p>
<p>access, String name, String signature,
11</p>
<p>String superName, String[] interfaces) {</p>
<p>12</p>
<p>13</p>
<p>cv.visit(V1_6, ACC_PUBLIC + ACC_SUPER, name, signature, superName,</p>
<p>14</p>
<p>interfaces);
15</p>
<p>AnnotationVisitor av0;</p>
<p>16</p>
<p>av0 = cv.visitAnnotation(</p>
<p>&quot;Ljavax/jws/WebService;&quot;</p>
<p>, </p>
<p>true</p>
<p>);
17</p>
<p>av0.visitEnd();</p>
<p>18</p>
<p>}
19</p>
<p>20</p>
<p>@Override
21</p>
<p>public</p>
<p>AnnotationVisitor visitAnnotation(String desc, </p>
<p>boolean</p>
<p>visible) {</p>
<p>22</p>
<p>return</p>
<p>cv.visitAnnotation(desc, visible);
23</p>
<p>}</p>
<p>24</p>
<p>25</p>
<p>@Override</p>
<p>26</p>
<p>public</p>
<p>void</p>
<p>visitInnerClass(String name, String outerName,
27</p>
<p>String innerName, </p>
<p>int</p>
<p>access) {</p>
<p>28</p>
<p>cv.visitInnerClass(name, outerName, innerName, access);
29</p>
<p>}</p>
<p>30</p>
<p>31</p>
<p>@Override</p>
<p>32</p>
<p>public</p>
<p>FieldVisitor visitField(</p>
<p>int</p>
<p>access, String name, String desc,
33</p>
<p>String signature, Object value) {</p>
<p>34</p>
<p>return</p>
<p>cv.visitField(access, name, desc, signature, value);
35</p>
<p>}</p>
<p>36</p>
<p>37</p>
<p>@Override</p>
<p>38</p>
<p>public</p>
<p>MethodVisitor visitMethod(</p>
<p>int</p>
<p>access, String name, String desc,
39</p>
<p>String signature, String[] exceptions) {   </p>
<p>40</p>
<p>MethodVisitor mv  = cv.visitMethod(access, name, desc, signature,
41</p>
<p>exceptions);</p>
<p>42</p>
<p>if</p>
<p>(!name.equals(</p>
<p>&quot;<init>&quot;</p>
<p>)) {
43</p>
<p>AnnotationVisitor av0;</p>
<p>44</p>
<p>av0 = mv.visitAnnotation(</p>
<p>&quot;Ljavax/jws/WebMethod;&quot;</p>
<p>, </p>
<p>true</p>
<p>);
45</p>
<p>av0.visitEnd();</p>
<p>46</p>
<p>}
47</p>
<p>return</p>
<p>mv;</p>
<p>48</p>
<p>}
49</p>
<p>50</p>
<p>@Override
51</p>
<p>public</p>
<p>void</p>
<p>visitEnd() {</p>
<p>52</p>
<p>cv.visitEnd();
53</p>
<p>}</p>
<p>54</p>
<p>55</p>
<p>}</p>
<p>最后，我们采用上面讲的类注入办法，即可得到一个带 @WebService 和 @WebMethod 标注的 class 文件。再通过 wsgen 工具即可成功创建 web services，该命令将会在 src 目录下生成 web services 描述文件：SayHelloImplService.wsdl，SayHelloImplService_schema1.xsd，同时生成了 2 个 JAX-WS 文件，分别为：SayHello.java，SayHelloResponse.java。</p>
<p>当然，在实际应用中，我们可能需要将一个 class 的某些特定方法发布为 web services，这就需要我们对 Adapter 做进一步的改造，在 visitMethod() 方法中根据方法名称等参数做进一步的处理。</p>
<p><a href="">结束语</a></p>
<p>本文简要介绍了 ASM 字节码工具及其在 web services 开发中的应用。web services 的使用已经越来越广泛， 但在改造遗留系统过程中会遇到不少问题，本文针对其中一个主要问题给出了解决办法，该方法无须对现有系统做大量的改动， 即可将现存的 Java bean 转化成 web services 。本文对那些正考虑迁移到 JAX-WS 编程模型上的项目有一定的参考价值。在基于 JAX-WS 标准的 web services 的开发中，不少实际场景都是希望采用自底向上的开发方式， 即基于已有的 Java bean 来创建 web services 。WebSphere Application Server ( 以下简称 WAS ) 提供了命令行的工具 wsgen 和相对应的 Ant task 来支持这种开发过程，而且这两个工具比较适合大型项目的自动化构建。 这两个工具的使用前提是 Java bean 中事先添加有 web services 的 Annotation 标注，而在现有的业务系统中，class 文件一般是不带 Annotation 的，这就需要开发人员去修改现有的代码，以手工方式添加 Annotation，但这样带来的工作量太大且容易出错。本文介绍了一种解决途径，可以不用修改源代码，而是利用字节码工具 ASM 直接修改 class 文件， 在字节码文件中自动注入 Annotation ，然后再利用 wsgen 工具就可以很方便地生成 web services 应用。 本文同时也总结了使用 ASM 的一些实践。</p>
<p>本文首先介绍了和 ASM 使用相关的四种文件，以及它们之间的相互转化。然后结合 web services 开发实例，介绍了使用 wsgen 开发时遇到的实际问题，如何写一个 ASM 的适配器去修改现有 class，最终如何产生 web services 文件。</p>
<p>ASM 是一个多用途的 Java 字节码操控和分析框架。它能以二进制的形式直接修改现有的类或动态生成的类。 ASM 提供了常用的转换和分析算法，是一种允许用户方便的组装定制化的复杂转换和代码分析工具。 ASM 也提供和其它的字节码工具类似的功能，但 ASM 的重点是使用的简单和高性能。由于 ASM 在设计实现的时候尽可能 的小的内存占用和提供更高的性能；因此在动态系统中使用 ASM 是很有优势的。ASM 作为一种轻量级、高性能的 Java 字节码操控和分析框架，设计了一种更有效的方法、提供更好的性能和内存占用。今天， ASM 在许多领域都有应用，并已成为事实上的字节码处理框架标准。</p>
<p><a href="">问题的引入</a></p>
<p>先写一个不带 web services 标注的 SayHelloImpl 类。
<a href=""><strong>清单 1. 不带 web services 的 SayHelloImpl 类</strong></a>1</p>
<p>public</p>
<p>class</p>
<p>SayHelloImpl {</p>
<p>2</p>
<p>public</p>
<p>String sayHello(String s) {
3</p>
<p>return</p>
<p>“Hello: ” + s ;</p>
<p>4</p>
<p>}
5</p>
<p>}</p>
<p>再用 wsgen 来创建 web services，wsgen 的使用如下：
<a href=""><strong>清单 2. wsgen 实例</strong></a>1</p>
<p>wsgen.exe – </p>
<p>cp</p>
<p>bin – s output – d output – r output – wsdl ibm.was.asm.SayHelloImpl我们将会遇到如下错误： 
<a href=""><strong>清单 3. 根据不带 web services 标注的类创建 web services 时遇到的错误信息</strong></a> 
注释处理过程中遇到问题；</p>
<p>......
com.sun.tools.internal.ws.processor.modeler.ModelerException: [failed to localiz</p>
<p>e] A web service endpoint could not be found()
        at com.sun.tools.internal.ws.processor.modeler.annotation.WebServiceAP.o</p>
<p>nError(WebServiceAP.java:215)
        at com.sun.tools.internal.ws.processor.modeler.annotation.WebServiceAP.b</p>
<p>uildModel(WebServiceAP.java:322)
        at com.sun.tools.internal.ws.processor.modeler.annotation.WebServiceAP.p</p>
<p>rocess(WebServiceAP.java:256)
        at com.sun.mirror.apt.AnnotationProcessors$CompositeAnnotationProcessor.</p>
<p>process(AnnotationProcessors.java:60)</p>
<p>注意：我们通常是在 class 前使用 @WebService， 在方法前使用 @WebMethod 来将一个类标注为 web services 的。WAS 6.1 的 web services 功能部件包和 WAS 7 都支持基于 JAX-WS 标准 的 web services 的开发， 在 WAS 安装目录的 bin 目录下提供了命令行工具 wsgen，wsgen 支持自底向上的开发方式。 下面是 wsgen 的用法：
<a href=""><strong>清单 4. wsgen 命令格式</strong></a> 
注 wsgen [options]  [SEI]</p>
<p>主要选项：</p>
<ul>
<li>-d 指定生成的 class 文件位置；</li>
<li>-s 指定生成的 Java 源文件位置；</li>
<li>-r 指定生成的 resources 文件位置，如 wsdl，xsd；</li>
<li>-cp 指定服务实现类所在的位置；</li>
<li>-wsdl，-servicename，-portname 三个参数指定生成的 wsdl 文件中的 service 和 port 的名称。</li>
</ul>
<p>SEI(Service Endpoint Interface) 是一个 endpoint implementation class，不能是一个 interface。所以首先要开发一个 endpoint 的实现类，如本例中的 SayHelloImpl 。用 @WebService 声明 web services ，然后将它编译，才能提供给 wsgen 来创建 web services 。</p>
<p><a href="">四种文件之间的转换</a></p>
<p>下面介绍本文要用到的四个概念（Java Source，Java Class，ASM Code，ASM Source）</p>
<ul>
<li>Java Source: 即我们通常编写的 Java 源文件；</li>
<li>Java Class: Java 源文件编译后的字节码文件；</li>
<li>ASM Source : 类似于对 class 反编译后的源文件，也就是 &quot;textual byte code&quot;，但比原始的 Java Source 可读性要差， 参见清单 5。</li>
<li>ASM Code: 指读写 class 文件的 ASM 程序代码。需要用到 ASM 提供的 API， 参见清单 6。
<a href=""><strong>清单 5. SayHelloImpl 类对应的 ASM Source</strong></a>01</li>
</ul>
<p>// class version 50.0 (50)</p>
<p>02</p>
<p>// access flags 33
03</p>
<p>public</p>
<p>class</p>
<p>com/ibm/was/asm/SayHelloImpl {</p>
<p>04</p>
<p>05</p>
<p>// access flags 1</p>
<p>06</p>
<p>public</p>
<p><init>()V
07</p>
<p>ALOAD </p>
<p>0</p>
<p>08</p>
<p>INVOKESPECIAL java/lang/Object. <init> ()V
09</p>
<p>RETURN</p>
<p>10</p>
<p>MAXSTACK = </p>
<p>1
11</p>
<p>MAXLOCALS = </p>
<p>1</p>
<p>12</p>
<p>13</p>
<p>// access flags 1</p>
<p>14</p>
<p>public</p>
<p>sayHello(Ljava/lang/String;)Ljava/lang/String;
15</p>
<p>NEW java/lang/StringBuilder</p>
<p>16</p>
<p>DUP
17</p>
<p>LDC </p>
<p>&quot;Hello:&quot;</p>
<p>18</p>
<p>INVOKESPECIAL java/lang/StringBuilder. <init> (Ljava/lang/String;)V
19</p>
<p>ALOAD </p>
<p>1</p>
<p>20</p>
<p>INVOKEVIRTUAL java/lang/StringBuilder.append (Ljava/lang/String;)
21</p>
<p>Ljava/lang/StringBuilder;</p>
<p>22</p>
<p>INVOKEVIRTUAL java/lang/StringBuilder.toString ()Ljava/lang/String;
23</p>
<p>ARETURN</p>
<p>24</p>
<p>MAXSTACK = </p>
<p>3
25</p>
<p>MAXLOCALS = </p>
<p>2</p>
<p>26</p>
<p>}<a href=""><strong>清单 6. 生成 SayHelloImpl.class 的 ASM Code</strong></a>01</p>
<p>package</p>
<p>asm.com.ibm.was.asm;</p>
<p>02</p>
<p>import</p>
<p>java.util./*;
03</p>
<p>import</p>
<p>org.objectweb.asm./*;</p>
<p>04</p>
<p>import</p>
<p>org.objectweb.asm.attrs./*;
05</p>
<p>public</p>
<p>class</p>
<p>SayHelloImplDump </p>
<p>implements</p>
<p>Opcodes {</p>
<p>06</p>
<p>public</p>
<p>static</p>
<p>byte</p>
<p>[] dump () </p>
<p>throws</p>
<p>Exception {
07</p>
<p>ClassWriter cw = </p>
<p>new</p>
<p>ClassWriter(</p>
<p>0</p>
<p>);</p>
<p>08</p>
<p>FieldVisitor fv;
09</p>
<p>MethodVisitor mv;</p>
<p>10</p>
<p>AnnotationVisitor av0;
11</p>
<p>12</p>
<p>cw.visit(V1_6, ACC_PUBLIC + ACC_SUPER, </p>
<p>&quot;com/ibm/was/asm/SayHelloImpl&quot;</p>
<p>,
13</p>
<p>null</p>
<p>, </p>
<p>&quot;java/lang/Object&quot;</p>
<p>, </p>
<p>null</p>
<p>);</p>
<p>14</p>
<p>15</p>
<p>{</p>
<p>16</p>
<p>mv = cw.visitMethod(ACC_PUBLIC, </p>
<p>&quot;<init>&quot;</p>
<p>, </p>
<p>&quot;()V&quot;</p>
<p>, </p>
<p>null</p>
<p>, </p>
<p>null</p>
<p>);
17</p>
<p>mv.visitCode();</p>
<p>18</p>
<p>mv.visitVarInsn(ALOAD, </p>
<p>0</p>
<p>);
19</p>
<p>mv.visitMethodInsn(INVOKESPECIAL, </p>
<p>&quot;java/lang/Object&quot;</p>
<p>, </p>
<p>&quot;<init>&quot;</p>
<p>, </p>
<p>&quot;()V&quot;</p>
<p>);</p>
<p>20</p>
<p>mv.visitInsn(RETURN);
21</p>
<p>mv.visitMaxs(</p>
<p>1</p>
<p>, </p>
<p>1</p>
<p>);</p>
<p>22</p>
<p>mv.visitEnd();
23</p>
<p>}</p>
<p>24</p>
<p>{
25</p>
<p>mv = cw.visitMethod(ACC_PUBLIC, </p>
<p>&quot;sayHello&quot;</p>
<p>,</p>
<p>26</p>
<p>&quot;(Ljava/lang/String;)Ljava/lang/String;&quot;</p>
<p>, </p>
<p>null</p>
<p>, </p>
<p>null</p>
<p>);
27</p>
<p>mv.visitCode();</p>
<p>28</p>
<p>mv.visitTypeInsn(NEW, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>);
29</p>
<p>mv.visitInsn(DUP);</p>
<p>30</p>
<p>mv.visitLdcInsn(</p>
<p>&quot;Hello:&quot;</p>
<p>);
31</p>
<p>mv.visitMethodInsn(INVOKESPECIAL, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>,</p>
<p>32</p>
<p>&quot;<init>&quot;</p>
<p>, </p>
<p>&quot;(Ljava/lang/String;)V&quot;</p>
<p>);
33</p>
<p>mv.visitVarInsn(ALOAD, </p>
<p>1</p>
<p>);</p>
<p>34</p>
<p>mv.visitMethodInsn(INVOKEVIRTUAL, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>,
35</p>
<p>&quot;append&quot;</p>
<p>, </p>
<p>&quot;(Ljava/lang/String;)Ljava/lang/StringBuilder;&quot;</p>
<p>);</p>
<p>36</p>
<p>mv.visitMethodInsn(INVOKEVIRTUAL, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>,
37</p>
<p>&quot;toString&quot;</p>
<p>, </p>
<p>&quot;()Ljava/lang/String;&quot;</p>
<p>);</p>
<p>38</p>
<p>mv.visitInsn(ARETURN);
39</p>
<p>mv.visitMaxs(</p>
<p>3</p>
<p>, </p>
<p>2</p>
<p>);</p>
<p>40</p>
<p>mv.visitEnd();
41</p>
<p>}</p>
<p>42</p>
<p>cw.visitEnd();
43</p>
<p>return</p>
<p>cw.toByteArray();</p>
<p>44</p>
<p>}
45</p>
<p>}</p>
<p>图 1 描述了 Java Source 文件、Java Class 文件、ASM Code 文件和 ASM Source 文件之间的转换关系。
<a href=""><strong>图 1. 四种文件的转换图</strong></a> 
<a href=""><img src="" alt="图 1. 四种文件的转换图"></a> </p>
<p>如图 -1 所示，Java Source 文件通过 Javac 可以转换为 Java Class 文件。而相应的 Java Class 文件通过 Java 反编译器工具可转换为 Java Source 文件；</p>
<p>通 过 ASM Code 去创建和修改 Java Class 需要对 ASM API 比较熟悉才行，一个常见的问题时，怎么用 ASM Code 生成一个我们希望的 class 文件， 也就是说， 给定了 Java Class， 怎么得到其对应的 ASM Code 呢？ 所幸的是， ASM 框架为我们提供了 ASMifierClassVisitor 工具来产生 Java Class 对应的 ASM Code。代码如下：
<a href=""><strong>清单 7. 给定 class 文件，通过 ASMifierClassVisitor 获得其对应的 ASM Code</strong></a>01</p>
<p>public</p>
<p>void</p>
<p>showClassASMProcess() {</p>
<p>02</p>
<p>ClassReader cr;
03</p>
<p>final</p>
<p>String n = SayHelloImpl.</p>
<p>class</p>
<p>.getName();</p>
<p>04</p>
<p>05</p>
<p>try</p>
<p>{</p>
<p>06</p>
<p>cr = </p>
<p>new</p>
<p>ClassReader(n);<br>07</p>
<p>cr.accept(</p>
<p>new</p>
<p>ASMifierClassVisitor(</p>
<p>new</p>
<p>PrintWriter(System.out)),</p>
<p>08</p>
<p>new</p>
<p>Attribute[</p>
<p>0</p>
<p>],
09</p>
<p>ClassReader.SKIP_DEBUG);</p>
<p>10</p>
<p>11</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {</p>
<p>12</p>
<p>e.printStackTrace();
13</p>
<p>}</p>
<p>14</p>
<p>}</p>
<p>另外一个重要的转换就是， 给定了 Java Class 文件， 如何查看它的 ASM Source ？ 这点对于我们验证 ASM Code 生成的 class 是否正确很有用。ASM 提供了另外一个工具 TraceClassVisitor， 来获得一个 Java Class 对应的 ASM Source。代码如下：
<a href=""><strong>清单 8. 利用 TraceClassVisitor 查看 class 文件的 ASM Source</strong></a>01</p>
<p>//file 是 class 文件的全路径名</p>
<p>02</p>
<p>public</p>
<p>void</p>
<p>showClassSource(String file) {
03</p>
<p>FileInputStream is ;</p>
<p>04</p>
<p>ClassReader cr; 
05</p>
<p>06</p>
<p>try</p>
<p>{
07</p>
<p>is = </p>
<p>new</p>
<p>FileInputStream(file);     </p>
<p>08</p>
<p>cr = </p>
<p>new</p>
<p>ClassReader(is);
09</p>
<p>TraceClassVisitor trace = </p>
<p>new</p>
<p>TraceClassVisitor(</p>
<p>new</p>
<p>PrintWriter(System.out));</p>
<p>10</p>
<p>cr.accept(trace, ClassReader.SKIP_DEBUG);
11</p>
<p>12</p>
<p>is.close() ;
13</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {</p>
<p>14</p>
<p>e.printStackTrace() ;
15</p>
<p>}</p>
<p>16</p>
<p>}
17</p>
<p>{</p>
<p>18</p>
<p>e.printStackTrace();
19</p>
<p>}</p>
<p>20</p>
<p>}</p>
<p><a href="">ASM 类注入</a></p>
<p>ASM 类注入是指修改一个现有的 class 文件，在其中加入自己的代码。按通常思维，我们需要利用 ASM 提供的 reader 类去读取所要修改的类文件， 找到要修改的地方，如方法名或属性名，然后在该处插入自己的代码或修改现有的代码，这种思路将使问题复杂化。 ASM 为我们提供了访问类文件的 Visitor 模式，来遍历一个 class 文件，Visitor 是一个实现 ClassVisitor 接口的类。 要注入一个 class 文件，先要找到一个合适的 Visitor 做向导， ASM 提供了好几种 Visitor， 最常用的是 ClassWriter。同时我们需要提供一个适配器类 ClassAdapter， Visitor 会带着这个 Adapter 一起去遍历， 然后在遍历过程中回调 Adapter 提供的方法。我们在 Adapter 的这些方法中就可以实现我们的修改和定制逻辑。当然，如果你不想做任何修改，那 Visitor 遍历完后将得到一个和被遍历的 class 完全一样的拷贝。
<a href=""><strong>清单 9. 类注入的完整过程</strong></a>01</p>
<p>public</p>
<p>void</p>
<p>addAnnotationToExistingClass() {</p>
<p>02</p>
<p>FileInputStream is ;
03</p>
<p>ClassReader cr;          </p>
<p>04</p>
<p>try</p>
<p>{<br>05</p>
<p>String classfile = </p>
<p>&quot;E:\SayHelloImpl.class&quot;</p>
<p>; </p>
<p>// 待遍历的类</p>
<p>06</p>
<p>showClassSource(classfile) ;  </p>
<p>// 打印该类的 ASM source
07</p>
<p>08</p>
<p>is = </p>
<p>new</p>
<p>FileInputStream(classfile);<br>09</p>
<p>cr = </p>
<p>new</p>
<p>ClassReader(is);</p>
<p>10</p>
<p>// 此处我们使用 ClassWriter 做 Visitor
11</p>
<p>ClassWriter cw = </p>
<p>new</p>
<p>ClassWriter(ClassWriter.COMPUTE_MAXS);</p>
<p>12</p>
<p>// 给 Visitor 提供一个 Adapter
13</p>
<p>AddAnnotationAdapter adapter = </p>
<p>new</p>
<p>AddAnnotationAdapter(cw);           </p>
<p>14</p>
<p>cr.accept(adapter, ClassReader.SKIP_DEBUG);<br>15</p>
<p>16</p>
<p>// 遍历完后，生成的 class 保存在字节数组中
17</p>
<p>byte</p>
<p>[] b = cw.toByteArray();</p>
<p>18</p>
<p>19</p>
<p>try</p>
<p>{</p>
<p>20</p>
<p>// 将字节数组输出到文件中
21</p>
<p>// 为了不至于覆盖掉原有的 SayHelloImpl.class 文件，我们将结果输出到 _SayHelloImpl.class</p>
<p>22</p>
<p>FileOutputStream fout = </p>
<p>new</p>
<p>FileOutputStream(</p>
<p>&quot;E:\_SayHelloImpl.class&quot;</p>
<p>);
23</p>
<p>fout.write(b) ;</p>
<p>24</p>
<p>fout.flush();
25</p>
<p>fout.close() ;</p>
<p>26</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {
27</p>
<p>e.printStackTrace() ;</p>
<p>28</p>
<p>}
29</p>
<p>30</p>
<p>// 验证 _SayHelloImpl.class 是否包含我们注入的代码
31</p>
<p>showClassSource(</p>
<p>&quot;E:\_SayHelloImpl.class&quot;</p>
<p>) ;</p>
<p>32</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {
33</p>
<p>e.printStackTrace();</p>
<p>34</p>
<p>} 
35</p>
<p>}</p>
<p><a href="">web services 标记注入过程</a></p>
<p>我们已经知道了如何往 class 中注入自己的代码，那对于一个已有的 Java bean，怎么往里注入 @WebService 和 @WebMethod 呢？根据上面我们讲的转换关系，我们可以先写一个带 annotation 的 Java Source，编译得到 Java Class， 再得到其 ASM Code。下面是利用 ASM 给一个不带任何 Annotation 的 class 添加 @WebService 和 @WebMethod 的步骤。</p>
<ol>
<li>首先在 SayHelloImpl.java 中添加 @WebService 和 @WebMethod： 
<a href=""><strong>清单 10. 带 web services 标注的 SayHelloImpl 类</strong></a>1</li>
</ol>
<p>@WebService</p>
<p>2</p>
<p>public</p>
<p>class</p>
<p>SayHelloImpl {
3</p>
<p>@WebMethod</p>
<p>4</p>
<p>public</p>
<p>String sayHello(String s) {
5</p>
<p>return</p>
<p>&quot;Hello: &quot;</p>
<ul>
<li>s ;</li>
</ul>
<p>6</p>
<p>}
7</p>
<p>}</p>
<ol>
<li>通过 ASMifierClassVisitor 工具获得 SayHelloImpl class 的 ASM Code，见清单 6。</li>
<li>写一个 ClassAdapter 类， ClassAdapter 其实也是一个 Visitor。根据 ASM Code 的提示， 我们就可以知道如何利用 ASM API 去获得我们希望的 class 文件。下面是 Adapter 的示例代码。 
<a href=""><strong>清单 11. 添加 Annotation 的 Adapter 类</strong></a>01</li>
</ol>
<p>public</p>
<p>class</p>
<p>AddAnnotationAdapter </p>
<p>extends</p>
<p>ClassAdapter </p>
<p>implements</p>
<p>Opcodes{</p>
<p>02</p>
<p>//private String annotationDesc;
03</p>
<p>private</p>
<p>boolean</p>
<p>isAnnotationPresent;</p>
<p>04</p>
<p>05</p>
<p>public</p>
<p>AddAnnotationAdapter(ClassVisitor cv) {</p>
<p>06</p>
<p>super</p>
<p>(cv);
07</p>
<p>}</p>
<p>08</p>
<p>09</p>
<p>@Override</p>
<p>10</p>
<p>public</p>
<p>void</p>
<p>visit(</p>
<p>int</p>
<p>version, </p>
<p>int</p>
<p>access, String name, String signature,
11</p>
<p>String superName, String[] interfaces) {</p>
<p>12</p>
<p>13</p>
<p>cv.visit(V1_6, ACC_PUBLIC + ACC_SUPER, name, signature, superName,</p>
<p>14</p>
<p>interfaces);
15</p>
<p>AnnotationVisitor av0;</p>
<p>16</p>
<p>av0 = cv.visitAnnotation(</p>
<p>&quot;Ljavax/jws/WebService;&quot;</p>
<p>, </p>
<p>true</p>
<p>);
17</p>
<p>av0.visitEnd();</p>
<p>18</p>
<p>}
19</p>
<p>20</p>
<p>@Override
21</p>
<p>public</p>
<p>AnnotationVisitor visitAnnotation(String desc, </p>
<p>boolean</p>
<p>visible) {</p>
<p>22</p>
<p>return</p>
<p>cv.visitAnnotation(desc, visible);
23</p>
<p>}</p>
<p>24</p>
<p>25</p>
<p>@Override</p>
<p>26</p>
<p>public</p>
<p>void</p>
<p>visitInnerClass(String name, String outerName,
27</p>
<p>String innerName, </p>
<p>int</p>
<p>access) {</p>
<p>28</p>
<p>cv.visitInnerClass(name, outerName, innerName, access);
29</p>
<p>}</p>
<p>30</p>
<p>31</p>
<p>@Override</p>
<p>32</p>
<p>public</p>
<p>FieldVisitor visitField(</p>
<p>int</p>
<p>access, String name, String desc,
33</p>
<p>String signature, Object value) {</p>
<p>34</p>
<p>return</p>
<p>cv.visitField(access, name, desc, signature, value);
35</p>
<p>}</p>
<p>36</p>
<p>37</p>
<p>@Override</p>
<p>38</p>
<p>public</p>
<p>MethodVisitor visitMethod(</p>
<p>int</p>
<p>access, String name, String desc,
39</p>
<p>String signature, String[] exceptions) {   </p>
<p>40</p>
<p>MethodVisitor mv  = cv.visitMethod(access, name, desc, signature,
41</p>
<p>exceptions);</p>
<p>42</p>
<p>if</p>
<p>(!name.equals(</p>
<p>&quot;<init>&quot;</p>
<p>)) {
43</p>
<p>AnnotationVisitor av0;</p>
<p>44</p>
<p>av0 = mv.visitAnnotation(</p>
<p>&quot;Ljavax/jws/WebMethod;&quot;</p>
<p>, </p>
<p>true</p>
<p>);
45</p>
<p>av0.visitEnd();</p>
<p>46</p>
<p>}
47</p>
<p>return</p>
<p>mv;</p>
<p>48</p>
<p>}
49</p>
<p>50</p>
<p>@Override
51</p>
<p>public</p>
<p>void</p>
<p>visitEnd() {</p>
<p>52</p>
<p>cv.visitEnd();
53</p>
<p>}</p>
<p>54</p>
<p>55</p>
<p>}</p>
<p>最后，我们采用上面讲的类注入办法，即可得到一个带 @WebService 和 @WebMethod 标注的 class 文件。再通过 wsgen 工具即可成功创建 web services，该命令将会在 src 目录下生成 web services 描述文件：SayHelloImplService.wsdl，SayHelloImplService_schema1.xsd，同时生成了 2 个 JAX-WS 文件，分别为：SayHello.java，SayHelloResponse.java。</p>
<p>当然，在实际应用中，我们可能需要将一个 class 的某些特定方法发布为 web services，这就需要我们对 Adapter 做进一步的改造，在 visitMethod() 方法中根据方法名称等参数做进一步的处理。</p>
<p><a href="">结束语</a></p>
<p>本文简要介绍了 ASM 字节码工具及其在 web services 开发中的应用。web services 的使用已经越来越广泛， 但在改造遗留系统过程中会遇到不少问题，本文针对其中一个主要问题给出了解决办法，该方法无须对现有系统做大量的改动， 即可将现存的 Java bean 转化成 web services 。本文对那些正考虑迁移到 JAX-WS 编程模型上的项目有一定的参考价值。</p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:42"datetime="2014-03-07 09:54:42"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE--Java字节码工具ASM在WebService开发中的应用/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE--Java字节码工具ASM在WebService开发中的应用" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>





<ul id="pagination" class="pagination pagination-lg">
  <li><a class="extend prev" href="/page/45/">&laquo;</a></li><li><a class="page-number" href="/">1</a></li><li><a class="page-number" href="/page/2/">2</a></li><li><span class="space">&hellip;</span></li><li><a class="page-number" href="/page/43/">43</a></li><li><a class="page-number" href="/page/44/">44</a></li><li><a class="page-number" href="/page/45/">45</a></li><li class="active"><li><span class="page-number current">46</span></li><li><a class="page-number" href="/page/47/">47</a></li><li><a class="page-number" href="/page/48/">48</a></li><li><a class="page-number" href="/page/49/">49</a></li><li><span class="space">&hellip;</span></li></li><li><a class="page-number" href="/page/164/">164</a></li><li><a class="page-number" href="/page/165/">165</a></li><li><a class="extend next" href="/page/47/">&raquo;</a></li>
  <div class="clearfix"></div>
</ul></div><!--wapper-->
       </div><!-- ID main-col END -->
       <aside id="sidebar" class="alignright col-sx-6 col-sm-4 col-md-3 col-lg-3">
<div id="widget_search" class="widget panel panel-primary">
    <form action="//google.com/search" method="get" accept-charset="utf-8">
  <div class="input-group">
    <input class="form-control" id="searchbox" type="search" name="q" results="0" placeholder="search">
    <span class="input-group-btn">
      <button class="btn btn-default" type="submit">Go!</button>
    </span>
    <input type="hidden" name="q" value="site:itsolife.com">
  </div>
</form>
</div>

<div id="widget_category" class="widget panel panel-primary">
  <div class="panel-heading">category</div>  <div data-src='category' class='ajax_widgets'>正在加载...</div>
</div>

<div id="widget_recent_posts" class="widget panel panel-primary">
  <div class="panel-heading">recent posts</div>  <div data-src='recent_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_tagcloud" class="widget panel panel-primary">
  <div class="panel-heading">tagcloud</div>  <div data-src='tagcloud' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_latest_update_posts" class="widget panel panel-primary">
  <div class="panel-heading">最近更新</div>  <div data-src='latest_update_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_recent_comments" class="widget panel panel-primary">
  <div class="panel-heading">recent comments</div>  

<div class="list-group-item ds-recent-comments" data-num-items="6" data-show-avatars="1" data-show-time="1" data-show-title="1" data-show-admin="1" data-excerpt-length="50"></div>



</div>

</aside>
       <div class="clearfix"></div>
     </div><!-- row END -->
  </div>
  <footer id="footer" class="container">
  <div class="panel panel-info">
  <section id='footer_widget'></section>  <div class="panel-footer">
  <div id="site-info">
    <span class='author'>
  
  &copy; 2014 RobinChia
  
    &nbsp;&nbsp;</span>
  
  <span id='analytics-51la'></span><span id='analytics-google'>
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-48559895-1']);
  _gaq.push(['_trackPageview']);
  _js2load.push({src:('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'});
</script></span><span id='analytics-cnzz'>
<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_5774006'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s17.cnzz.com/stat.php%3Fid%3D5774006%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>
</span><span id='analytics-baidu'>
<script>
var _hmt = _hmt || [];
_js2load.push({src:"//hm.baidu.com/hm.js?1442f50724afc42380b51f097c43082c"});
</script>
</span>  </div>
  <div id="copyright">Blog powered by <a href='http://zespia.tw/hexo/'><strong>hexo</strong></a> Theme <strong><a href='https://github.com/chenall/hexo-theme-chenall'>chenall</a></strong>(Some change in it)<span class="pull-right"> 更新时间: <em>2014-03-15 16:47:45</em></span></div>
</div>
<div class="clearfix"></div>


  </div>
  </footer>
  
        <script src="http://cdn.bootcss.com/jquery/1.10.2/jquery.min.js"></script>        
        <script src="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/js/bootstrap.min.js"></script>        
                
        <script src="http://cdn.bootcss.com/prettify/r298/prettify.min.js"></script>    <script type="text/javascript">
   var lang=["bsh", "c", "cc", "cpp", "cs", "csh", "cyc", "cv", "htm", "html",
    "java", "js", "m", "mxml", "perl", "pl", "pm", "py", "rb", "sh",
    "xhtml", "xml", "xsl"];
   var pretty_base='';
   $('script').each(function(){
	var c = $(this).attr('src');
	if (!c)
	    return;
	if (c.match(/(\/)?prettify(\.min)?\.js/i))
	{
	    var index = c.lastIndexOf('/');
	    if (index != -1)
		pretty_base = c.substr(0,index + 1);
	    return false;
	}
   })
   $('pre code').each(function(){
	var c = $(this).attr('class')
	if (!c)
	    return;
	c = c.match(/\s?(lang\-\w+)/i);
	if (c && lang.indexOf(c[1]) == -1)
	{
	    lang.push(c[1]);
	    $.getScript(pretty_base + c[1] + '.min.js');
	}
   })

    $(window).load(function(){
       $("pre").addClass("prettyprint");
       prettyPrint();
    })
</script>    
            <script type="text/javascript">
var duoshuoQuery = {short_name:"robinchia"};
_js2load.push({src:'http://static.duoshuo.com/embed.js',charset:'UTF-8'});
</script>
    
            <!--wumii_relatedItems-->
    
        <script src="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js"></script>    <script type="text/javascript">
(function($){
  $('.entry').each(function(i){
    $(this).find('img').each(function(){
      var alt = this.alt;

      if (alt){
        $(this).before('<span class="caption">' + alt + '</span>');
      }

      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox" rel="fancybox' + i + '" />');
    });
  });

  $('.fancybox').fancybox();
})(jQuery);
</script>    
        <script src="http://cdn.bootcss.com/mathjax/2.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>    <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>
    
<script type="text/javascript">
$('.ajax_widgets').each(function(){var src=$(this).attr('data-src');if(src)$(this).load('/widgets/'+src+'.html');});
$.each(_js2load,function(index,obj){loadjs(obj.src,obj.charset)});
</script>

<div id="scroll2top">
<img src="/scroll2top/arrow.png"/>
</div>
<script src="/scroll2top/scroll2top.min.js"></script>
<div id="winterland">
  <canvas></canvas>
</div>
<script src="/js/winterland.min.js"></script>

  </body>
</html>
