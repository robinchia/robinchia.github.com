
<!DOCTYPE HTML>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>The 51 Page | It so life</title>
<meta name="author" content="RobinChia">

<meta name="description" content="It so life">


<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<meta property="og:site_name" content="It so life"/>

<!--[if IE]><style>.testIE.IE{display:inline;}</style><![endif]-->
<!--[if lte IE 7]><link rel="stylesheet" href="/css/ie7.css" type="text/css"><![endif]-->
<!--[if (lt IE 9)&(gt IE 7)]><style>.testIE.IE8{display:inline;}</style><![endif]-->
<!--[if gt IE 8]><style>.testIE.IE9{display:inline;}</style><![endif]-->

<link href="/favicon.png" rel="icon">
<link rel="alternate" href="/atom.xml" title="It so life Feed" type="application/atom+xml">

<link rel="stylesheet" href="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/css/bootstrap.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/font-awesome/4.0.3/css/font-awesome.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/prettify/r298/prettify.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" type="text/css">
<link rel="stylesheet" href="/css/style.css" type="text/css">
<!--[if lt IE 9]>
   <style>article,aside,dialog,footer,header,section,footer,nav,figure,menu{display:block}</style>
   <script src="http://cdn.staticfile.org/html5shiv/r29/html5.min.js"></script>
   <script src="http://cdn.staticfile.org/respond.js/1.4.2/respond.min.js"></script>
<link href="http://cdn.staticfile.org/respond.js/1.4.2/respond-proxy.html" id="respond-proxy" rel="respond-proxy" />
<link href="/js/respond.proxy.gif" id="respond-redirect" rel="respond-redirect" />
<script src="/js/respond.proxy.js"></script>
   <script src="http://cdn.bootcss.com/selectivizr/1.0.2/selectivizr-min.js"></script>
<![endif]-->
<script type="text/javascript">
function loadjs(c,d){var a=document.createElement("script");a.async=!0;a.type="text/javascript";a.src=c;a.charset=d||"gbk";(document.getElementsByTagName("HEAD")[0]||document.getElementsByTagName("BODY")[0]).appendChild(a)};
var _protocol = (("https:" == document.location.protocol) ? " https://" : " http://");
var _js2load = [];
</script>

</head>
<body>
      <header id="header" class="container"><nav id="main-nav" class="navbar navbar-default navbar-fixed-top " role="navigation">
  <div class="container">
    <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
      <span class="sr-only">Toggle navigation</span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="/">It so life</a>
    </div>
    <div  class="collapse navbar-collapse">
      <ul  class="nav navbar-nav">
  
        <li><a href="/" title="Home">Home</a></li>      
        <li><a href="/about/" title="About">About</a></li>      
        <li><a href="/archives/" title="Archives">Archives</a></li>      
      <li class='dropdown'>
        <a class='dropdown-toggle' data-toggle='dropdown' href='#'>website<b class='caret'></b></a>
        <ul class='dropdown-menu pure-menu-selected'>
    
          <li><a href="//groups.google.com/forum/#!forum/pongba" title="TopLanguage">TopLanguage</a></li>    
          <li><a href="//itpub.net/" title="ITPub">ITPub</a></li>    
          <li><a href="//blog.jobbole.com/" title="Bole">Bole</a></li>    
          <li><a href="//nosql-database.org/" title="nosql">nosql</a></li>    
          <li><a href="//gitimmersion.googol.im/" title="Git">Git</a></li>    
        </ul>
      </li>
    
      </ul>
      <ul class="nav navbar-nav navbar-right">
      
        <li><a href="/atom.xml">RSS</a></li>
      
      
        <li><a href="https://twitter.com/robinchia">twitter</a></li>
      
      
      
      
        <li><a href="https://github.com/robinchia">github</a></li>
      
      </ul>
    </div>
  </div>
</nav>
<div class="clearfix"></div>
</header>
  <div id='content' class="container">
     <div class="page-header-wrapper">
      <!--[if lt IE 9]><div class="alert alert-warning alert-dismissable"><button type="button" class="close" data-dismiss="alert" aria-hidden="true">&times;</button><strong>提示:</strong>您的浏览器版本太低了,建议升级到 <strong><a href="http://windows.microsoft.com/zh-cn/internet-explorer/download-ie" title="IE9">IE9</a></strong> 以上,本站使用<a href="https://www.google.com/intl/zh-CN/chrome/">Chrome浏览器</a>可以获得最好的显示效果.</div><![endif]-->
      <div class="page-header"><h1 align="center"><big>It so life</big> </h1>
        <h5 align="center"><big>love as life</big></h5>
      </div>
     </div>
     <div class="row">
       <div id="main-col" class="alignleft col-sx-12 col-sm-8 col-md-9 col-lg-9">
      <section id='header_widget'></section>
          <div id="wrapper"><article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--借HSDB来探索HotSpotVM的运行时数据/">借HSDB来探索HotSpot VM的运行时数据</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:42.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--借HSDB来探索HotSpotVM的运行时数据/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-hsdb-hotspot-vm-">借HSDB来探索HotSpot VM的运行时数据</h1>
<p>（未经许可请勿转载。希望转载请与我联系。）
（如果打开此页面时浏览器有点卡住的话请耐心等待片刻。大概是ItEye的代码高亮太耗时了…）
几天前在<a href="http://hllvm.group.iteye.com/" target="_blank">HLLVM群组</a>有人<a href="http://hllvm.group.iteye.com/group/topic/37542" target="_blank">问了个小问题</a>，说
Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>public class Test {  </li>
<li>static Test2 t1 = new Test2();  </li>
<li>Test2 t2 = new Test2();  </li>
<li>public void fn() {  </li>
<li>Test2 t3 = new Test2();       </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>class Test2 {  </li>
<li></li>
<li>}  </li>
</ol>
<p>public class Test {</p>
<pre><code>static Test2 t1 = new Test2();
       Test2 t2 = new Test2();

public void fn() {
    Test2 t3 = new Test2();    

}
</code></pre><p>}</p>
<p>class Test2 {</p>
<p>}
这个程序的t1、t2、t3三个变量本身（而不是这三个变量所指向的对象）到底在哪里。
TL;DR版回答是：</p>
<ul>
<li>t1在存Java静态变量的地方，概念上在JVM的方法区（method area）里</li>
<li>t2在Java堆里，作为Test的一个实例的字段存在</li>
<li>t3在Java线程的调用栈里，作为Test.fn()的一个局部变量存在
不过就这么简单的回答大家都会，满足不了对JVM的实现感兴趣的同学们的好奇心。说到底，这“方法区”到底是啥？Java堆在哪里？Java线程的调用栈又是啥样的？
那就让我们跑点例子，借助调试器来看看在一个实际运行中的JVM里是啥状况。<h1 id="-https-gist-github-com-rednaxelafx-5392451-https-gist-github-com-rednaxelafx-5392451-">（下文中代码也传了一份到<a href="https://gist.github.com/rednaxelafx/5392451" target="_blank"><a href="https://gist.github.com/rednaxelafx/5392451">https://gist.github.com/rednaxelafx/5392451</a></a>）</h1>
写个启动类来跑上面问题中的代码：
Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></li>
</ul>
<ol>
<li>public class Main {  </li>
<li>public static void main(String[] args) {  </li>
<li>Test test = new Test();  </li>
<li>test.fn();  </li>
<li>}  </li>
<li>}  </li>
</ol>
<p>public class Main {</p>
<pre><code>public static void main(String[] args) {
    Test test = new Test();

    test.fn();
}
</code></pre><p>}
（编译这个Main.java和上面的Test.java时最好加上-g参数生成LocalVariableTable等调试信息，以便后面某些情况下可以用到）
接下来如无特别说明本文将使用Windows 7 64-bit, Oracle JDK 1.7.0_09 Server VM, Serial GC的环境中运行所有例子。
之前在GreenTeaJUG在杭州的活动<a href="http://rednaxelafx.iteye.com/blog/1814180" target="_blank">演示Serviceability Agent</a>的时候也讲到过这是个非常便于探索HotSpot VM内部实现的API，而HSDB则是在SA基础上包装起来的一个调试器。这次我们就用HSDB来做实验。
SA的一个限制是它只实现了调试snapshot的功能：要么要让被调试的目标进程完全暂停，要么就调试core dump。所以我们在用HSDB做实验前，得先让我们的Java程序运行到我们关注的点上才行。
理想情况下我们会希望让这Java程序停在Test.java的第6行，也就是Test.fn()中t3局部变量已经进入作用域，而该方法又尚未返回的地方。怎样才能停在这里呢？
其实用个Java层的调试器即可。大家平时可能习惯了在Eclipse、IntelliJ IDEA、NetBeans等Java IDE里使用Java层调试器，但为了减少对外部工具的依赖，本文将使用Oracle JDK自带的jdb工具来完成此任务。
<a href="http://docs.oracle.com/javase/7/docs/technotes/tools/windows/jdb.html" target="_blank">jdb</a>跟上面列举的IDE里包含的调试器底下依赖着同一套调试API，也就是<a href="http://docs.oracle.com/javase/7/docs/technotes/guides/jpda/index.html" target="_blank">Java Platform Debugger Architecture (JPDA)</a>。功能也类似，只是界面是命令行的，表明上看起来不太一样而已。
为了方便后续步骤，启动jdb的时候可以设定让目标Java程序使用serial GC和10MB的Java heap。
启动jdb之后可以用stop in命令在指定的Java方法入口处设置断点，
然后用run命令指定主类名称来启动Java程序，
等跑到断点看看位置是否已经到满足需求，还没到的话可以用step、next之类的命令来向前进。
对jdb命令不熟悉的同学可以在启动jdb之后使用help命令来查看命令列表和说明。
具体步骤如下：
Command prompt代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>D:\test&gt;jdb -XX:+UseSerialGC -Xmx10m  </li>
<li>Initializing jdb ...  </li>
<li><blockquote>
<p>stop in Test.fn  </p>
</blockquote>
</li>
<li>Deferring breakpoint Test.fn.  </li>
<li>It will be set after the class is loaded.  </li>
<li><blockquote>
<p>run Main  </p>
</blockquote>
</li>
<li>run  Main  </li>
<li>Set uncaught java.lang.Throwable  </li>
<li>Set deferred uncaught java.lang.Throwable  </li>
<li><blockquote>
</blockquote>
</li>
<li>VM Started: Set deferred breakpoint Test.fn  </li>
<li></li>
<li>Breakpoint hit: &quot;thread=main&quot;, Test.fn(), line=5 bci=0  </li>
<li>5            Test2 t3 = new Test2();  </li>
<li></li>
<li>main[1] next  </li>
<li></li>
<li>Step completed: &gt; &quot;thread=main&quot;, Test.fn(), line=6 bci=8  </li>
<li>6        }  </li>
<li></li>
<li>main[1]   </li>
</ol>
<p>D:\test&gt;jdb -XX:+UseSerialGC -Xmx10m</p>
<p>Initializing jdb ...</p>
<blockquote>
<p>stop in Test.fn</p>
</blockquote>
<p>Deferring breakpoint Test.fn.
It will be set after the class is loaded.</p>
<blockquote>
<p>run Main
run  Main</p>
</blockquote>
<p>Set uncaught java.lang.Throwable
Set deferred uncaught java.lang.Throwable</p>
<p>&gt;
VM Started: Set deferred breakpoint Test.fn</p>
<p>Breakpoint hit: &quot;thread=main&quot;, Test.fn(), line=5 bci=0</p>
<p>5            Test2 t3 = new Test2();</p>
<p>main[1] next</p>
<p>Step completed: &gt; &quot;thread=main&quot;, Test.fn(), line=6 bci=8
6        }</p>
<p>main[1]
按照上述步骤执行完最后一个next命令之后，我们就来到了最初想要的Test.java的第6行，也就是Test.fn()返回前的位置。
接下来把这个jdb窗口放一边，另开一个命令行窗口用<a href="http://docs.oracle.com/javase/7/docs/technotes/tools/share/jps.html" target="_blank">jps</a>命令看看我们要调试的Java进程的pid是多少：
Command prompt代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>D:\test&gt;jps  </li>
<li>4328 Main  </li>
<li>9064 Jps  </li>
<li>7716 TTY  </li>
</ol>
<p>D:\test&gt;jps</p>
<p>4328 Main
9064 Jps</p>
<p>7716 TTY
可以看到是4328。把这个pid记下来待会儿用。
然后启动HSDB：
Command prompt代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>D:\test&gt;java -cp .;%JAVA_HOME%/lib/sa-jdi.jar sun.jvm.hotspot.HSDB  </li>
</ol>
<p>D:\test&gt;java -cp .;%JAVA_HOME%/lib/sa-jdi.jar sun.jvm.hotspot.HSDB
（要留意Linux和Solaris在Oracle/Sun JDK6就可以使用HSDB了，但Windows上要到Oracle JDK7才可以用HSDB）
启动HSDB之后，把它连接到目标进程上。从菜单里选择File -&gt; Attach to HotSpot process：
<img src="&quot;点击查看原始大小图片&quot;" alt="">
在弹出的对话框里输入刚才记下的pid然后按OK：
<img src="&quot;点击查看原始大小图片&quot;" alt="">
这会儿就连接到目标进程了：
<img src="&quot;点击查看原始大小图片&quot;" alt="">
刚开始打开的窗口是Java Threads，里面有个线程列表。双击代表线程的行会打开一个Oop Inspector窗口显示HotSpot VM里记录线程的一些基本信息的C++对象的内容。
不过这里我们更可能会关心的是线程栈的内存数据。先选择main线程，然后点击Java Threads窗口里的工具栏按钮从左数第2个可以打开Stack Memory窗口来显示main线程的栈：
<img src="&quot;点击查看原始大小图片&quot;" alt="">
Stack Memory窗口的内容有三栏：
左起第1栏是内存地址，请让我提醒一下本文里提到“内存地址”的地方都是指虚拟内存意义上的地址，<strong>不是</strong>“物理内存地址”，请不要弄混了这俩概念；
第2栏是该地址上存的数据，以字宽为单位，本文例子中我是在Windows 7 64-bit上跑64位的JDK7的HotSpot VM，字宽是64位（8字节）；
第3栏是对数据的注释，竖线表示范围，横线或斜线连接范围与注释文字。
现在看不懂这个窗口里的数据没关系，先放一边，后面再回过头来看。
现在让我们打开HSDB里的控制台，以便用命令来了解更多信息。
在菜单里选择Windows -&gt; Console：
<img src="" alt="">
然后会得到一个空白的Command Line窗口。在里面敲一下回车就会出现hsdb&gt;提示符。
（用过CLHSDB的同学可能会发现这就是把CLHSDB嵌入在了HSDB的图形界面里）
不知道有什么命令可用的同学可以先用help命令看看命令列表。
可以用universe命令来查看GC堆的地址范围和使用情况：
Hsdb代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>hsdb&gt; universe  </li>
<li>Heap Parameters:  </li>
<li>Gen 0:   eden [0x00000000fa400000,0x00000000fa4aad68,0x00000000fa6b0000) space capacity = 2818048, 24.831088753633722 used  </li>
<li>from [0x00000000fa6b0000,0x00000000fa6b0000,0x00000000fa700000) space capacity = 327680, 0.0 used  </li>
<li>to   [0x00000000fa700000,0x00000000fa700000,0x00000000fa750000) space capacity = 327680, 0.0 usedInvocations: 0  </li>
<li></li>
<li>Gen 1:   old  [0x00000000fa750000,0x00000000fa750000,0x00000000fae00000) space capacity = 7012352, 0.0 usedInvocations: 0  </li>
<li></li>
<li>perm [0x00000000fae00000,0x00000000fb078898,0x00000000fc2c0000) space capacity = 21757952, 11.90770160721009 usedInvocations: 0  </li>
</ol>
<p>hsdb&gt; universe</p>
<p>Heap Parameters:
Gen 0:   eden [0x00000000fa400000,0x00000000fa4aad68,0x00000000fa6b0000) space capacity = 2818048, 24.831088753633722 used</p>
<p>  from [0x00000000fa6b0000,0x00000000fa6b0000,0x00000000fa700000) space capacity = 327680, 0.0 used
  to   [0x00000000fa700000,0x00000000fa700000,0x00000000fa750000) space capacity = 327680, 0.0 usedInvocations: 0</p>
<p>Gen 1:   old  [0x00000000fa750000,0x00000000fa750000,0x00000000fae00000) space capacity = 7012352, 0.0 usedInvocations: 0</p>
<p>  perm <a href="&quot;复制代码&quot;">0x00000000fae00000,0x00000000fb078898,0x00000000fc2c0000) space capacity = 21757952, 11.90770160721009 usedInvocations: 0
这里用的是HotSpot VM的serial GC。GC堆由young gen = DefNewGeneration（包括eden和两个survivor space）、old gen = TenuredGeneration和perm gen = PermGen构成。
其中young gen和old gen构成了这种配置下HotSpot VM里的Java堆（Java heap），而perm gen不属于Java heap的一部分，它存储的主要是元数据或者叫反射信息，主要用于实现JVM规范里的“方法区”概念。
在我们的Java代码里，执行到Test.fn()末尾为止应该创建了3个Test2的实例。它们必然在GC堆里，但都在哪里呢？用scanoops命令来看：
Hsdb代码 [<img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>hsdb&gt; scanoops 0x00000000fa400000 0x00000000fc2c0000 Test2  </li>
<li>0x00000000fa49a710 Test2  </li>
<li>0x00000000fa49a730 Test2  </li>
<li>0x00000000fa49a740 Test2  </li>
</ol>
<p>hsdb&gt; scanoops 0x00000000fa400000 0x00000000fc2c0000 Test2</p>
<p>0x00000000fa49a710 Test2
0x00000000fa49a730 Test2</p>
<p>0x00000000fa49a740 Test2
scanoops接受两个必选参数和一个可选参数：必选参数是要扫描的地址范围，一个是起始地址一个是结束地址；可选参数用于指定要扫描什么类型的对象实例。实际扫描的时候会扫出指定的类型及其派生类的实例。
这里可以看到确实扫出了3个Test2的实例。内容有两列：左边是对象的起始地址，右边是对象的实际类型。
从它们所在的地址，对照前面universe命令看到的GC堆的地址范围，可以知道它们都在eden里。
通过whatis命令可以进一步知道它们都在eden之中分配给main线程的thread-local allocation buffer (TLAB)中：
Hsdb代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>hsdb&gt; whatis 0x00000000fa49a710  </li>
<li>Address 0x00000000fa49a710: In thread-local allocation buffer for thread &quot;main&quot; (1)  [0x00000000fa48f490,0x00000000fa49a750,0x00000000fa49d118)  </li>
<li></li>
<li>hsdb&gt; whatis 0x00000000fa49a730  </li>
<li>Address 0x00000000fa49a730: In thread-local allocation buffer for thread &quot;main&quot; (1)  [0x00000000fa48f490,0x00000000fa49a750,0x00000000fa49d118)  </li>
<li></li>
<li>hsdb&gt; whatis 0x00000000fa49a740  </li>
<li>Address 0x00000000fa49a740: In thread-local allocation buffer for thread &quot;main&quot; (1)  [0x00000000fa48f490,0x00000000fa49a750,0x00000000fa49d118)  </li>
<li></li>
<li>hsdb&gt;   </li>
</ol>
<p>hsdb&gt; whatis 0x00000000fa49a710</p>
<p>Address 0x00000000fa49a710: In thread-local allocation buffer for thread &quot;main&quot; (1)  [0x00000000fa48f490,0x00000000fa49a750,0x00000000fa49d118)</p>
<p>hsdb&gt; whatis 0x00000000fa49a730
Address 0x00000000fa49a730: In thread-local allocation buffer for thread &quot;main&quot; (1)  [0x00000000fa48f490,0x00000000fa49a750,0x00000000fa49d118)</p>
<p>hsdb&gt; whatis 0x00000000fa49a740</p>
<p>Address 0x00000000fa49a740: In thread-local allocation buffer for thread &quot;main&quot; (1)  [0x00000000fa48f490,0x00000000fa49a750,0x00000000fa49d118)</p>
<p>hsdb&gt;
还可以用inspect命令来查看对象的内容：
Hsdb代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>hsdb&gt; inspect 0x00000000fa49a710  </li>
<li>instance of Oop for Test2 @ 0x00000000fa49a710 @ 0x00000000fa49a710 (size = 16)  </li>
<li>_mark: 1  </li>
</ol>
<p>hsdb&gt; inspect 0x00000000fa49a710</p>
<p>instance of Oop for Test2 @ 0x00000000fa49a710 @ 0x00000000fa49a710 (size = 16)
_mark: 1
可见一个Test2的实例要16字节。因为Test2类没有任何Java层的实例字段，这里就没有任何Java实例字段可显示。不过本来这里还应该显示一行：
Hsdb代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>_metadata._compressed_klass: InstanceKlass for Test2 @ 0x00000000fb078608  </li>
</ol>
<p>_metadata._compressed_klass: InstanceKlass for Test2 @ 0x00000000fb078608
不幸因为这个版本的HotSpot VM里带的SA有bug所以没显示出来。此bug在新版里已修。
还想看到更裸的数据的同学可以用mem命令来看实际内存里的数据长啥样：
Hsdb代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>hsdb&gt; mem 0x00000000fa49a710 2  </li>
<li>0x00000000fa49a710: 0x0000000000000001   </li>
<li>0x00000000fa49a718: 0x00000000fb078608   </li>
</ol>
<p>hsdb&gt; mem 0x00000000fa49a710 2</p>
<p>0x00000000fa49a710: 0x0000000000000001
0x00000000fa49a718: 0x00000000fb078608
mem命令接受的两个参数都必选，一个是起始地址，另一个是以字宽为单位的“长度”。我们知道一个Test2实例有16字节，所以给定长度为2来看。
上面的数字都是啥来的呢？
Memory代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>0x00000000fa49a710:  _mark:                        0x0000000000000001   </li>
<li>0x00000000fa49a718:  _metadata._compressed_klass:  0xfb078608  </li>
<li>0x00000000fa49a71c:  (padding):                    0x00000000  </li>
</ol>
<p>0x00000000fa49a710:  _mark:                        0x0000000000000001</p>
<p>0x00000000fa49a718:  _metadata._compressed_klass:  0xfb078608
0x00000000fa49a71c:  (padding):                    0x00000000
一个Test2的实例包含2个给VM用的隐含字段作为对象头，和0个Java字段。
对象头的第一个字段是mark word，记录该对象的GC状态、同步状态、identity hash code之类的多种信息。
对象头的第二个字段是个类型信息指针，klass pointer。这里因为默认开启了压缩指针，所以本来应该是64位的指针存在了32位字段里。
最后还有4个字节是为了满足对齐需求而做的填充（padding）。
以前在另一帖里也介绍过这部分内容，可以参考：<a href="http://rednaxelafx.iteye.com/blog/730461" target="_blank">借助HotSpot SA来一窥PermGen上的对象</a>
顺带发张Inspector的截图来展示HotSpot VM里描述Test2类的VM对象长啥样吧。
在菜单里选Tools -&gt; Inspector，在地址里输入前面看到的klass地址：
<img src="&quot;点击查看原始大小图片&quot;" alt="">
InstanceKlass存着Java类型的名字、继承关系、实现接口关系，字段信息，方法信息，运行时常量池的指针，还有内嵌的虚方法表（vtable）、接口方法表（itable）和记录对象里什么位置上有GC会关心的指针（oop map）等等。
留意到这个InstanceKlass是给VM内部用的，并不直接暴露给Java层；InstanceKlass不是java.lang.Class的实例。
在HotSpot VM里，java.lang.Class的实例被称为“Java mirror”，意思是它是VM内部用的klass对象的“镜像”，把klass对象包装了一层来暴露给Java层使用。
在InstanceKlass里有个_java_mirror字段引用着它对应的Java mirror，而mirror里也有个隐藏字段指向其对应的InstanceKlass。
所以当我们写obj.getClass()，在HotSpot VM里实际上经过了两层间接引用才能找到最终的Class对象：
Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>obj-&gt;_klass-&gt;_java_mirror  </li>
</ol>
<p>obj-&gt;_klass-&gt;_java_mirror
在Oracle JDK7之前，Oracle/Sun JDK的HotSpot VM把Java类的静态变量存在InstanceKlass结构的末尾；从Oracle JDK7开始，为了配合PermGen移除的工作，Java类的静态变量被挪到Java mirror（Class对象）的末尾了。</p>
<h1 id="-jdk7-java-mirror-permgen-jdk7-java-mirror-java-eden-permgen-jdk8-permgen-klass-gc-java-mirror-jdk7-">还有就是，在JDK7之前Java mirror存放在PermGen里，而从JDK7开始Java mirror默认也跟普通Java对象一样先从eden开始分配而不放在PermGen里。到JDK8则进一步彻底移除了PermGen，把诸如klass之类的元数据都挪到GC堆之外管理，而Java mirror的处理则跟JDK7一样。</h1>
<p>前面对HSDB的操作和HotSpot VM里的一些内部数据结构有了一定的了解，现在让我们回到主题：找指针！
HotSpot VM内部使用直接指针来实现Java引用。在64位环境中有可能启用“压缩指针”的功能把64位指针压缩到只用32位来存。压缩指针与非压缩指针直接有非常简单的1对1对应关系，前者可以看作后者的特例。
于是我们要找t1、t2、t3这三个变量，等同于找出存有指向上述3个Test2实例的地址的存储位置。
不嫌麻烦的话手工扫描内存去找也能找到，不过幸好HSDB内建了revptrs命令，可以找出“反向指针”——如果a变量引用着b对象，那么对b对象来说a就是一个“反向指针”。
先拿第一个Test2的实例试试看：
Hsdb代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>hsdb&gt; revptrs 0x00000000fa49a710  </li>
<li>Computing reverse pointers...  </li>
<li>Done.  </li>
<li>null  </li>
<li>Oop for java/lang/Class @ 0x00000000fa499b00  </li>
</ol>
<p>hsdb&gt; revptrs 0x00000000fa49a710</p>
<p>Computing reverse pointers...
Done.</p>
<p>null
Oop for java/lang/Class @ 0x00000000fa499b00
还真的找到了一个包含指向Test2实例的指针，在一个java.lang.Class的实例里。
用whatis命令来看看这个Class对象在哪里：
Hsdb代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>hsdb&gt; whatis 0x00000000fa499b00  </li>
<li>Address 0x00000000fa499b00: In thread-local allocation buffer for thread &quot;main&quot; (1)  [0x00000000fa48f490,0x00000000fa49a750,0x00000000fa49d118)  </li>
<li></li>
</ol>
<p>hsdb&gt; whatis 0x00000000fa499b00</p>
<p>Address 0x00000000fa499b00: In thread-local allocation buffer for thread &quot;main&quot; (1)  [0x00000000fa48f490,0x00000000fa49a750,0x00000000fa49d118)</p>
<p>可以看到这个Class对象也在eden里，具体来说在main线程的TLAB里。
这个Class对象是如何引用到Test2的实例的呢？再用inspect命令：
Hsdb代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>hsdb&gt; inspect 0x00000000fa499b00  </li>
<li>instance of Oop for java/lang/Class @ 0x00000000fa499b00 @ 0x00000000fa499b00 (size = 120)  </li>
<li>&lt;<Reverse pointers>&gt;:   </li>
<li>t1: Oop for Test2 @ 0x00000000fa49a710 Oop for Test2 @ 0x00000000fa49a710  </li>
</ol>
<p>hsdb&gt; inspect 0x00000000fa499b00</p>
<p>instance of Oop for java/lang/Class @ 0x00000000fa499b00 @ 0x00000000fa499b00 (size = 120)
&lt;<Reverse pointers>&gt;:</p>
<p>t1: Oop for Test2 @ 0x00000000fa49a710 Oop for Test2 @ 0x00000000fa49a710
可以看到，这个Class对象里存着Test类的静态变量t1，指向着第一个Test2实例。
<strong>成功找到t1了！这个有点特别，本来JVM规范里也没明确规定静态变量要存在哪里，通常认为它应该在概念中的“方法区”里；但现在在JDK7的HotSpot VM里它实质上也被放在Java heap里了。可以把这种特例看作是HotSpot VM把方法区的一部分数据也放在Java heap里了。
前面也已经提过，在JDK7之前的Oracle/Sun JDK里的HotSpot VM把静态变量存在InstanceKlass末尾，存在PermGen里。那个时候的PermGen更接近于完整的方法区一些。</strong>
关于PermGen移除计划的一些零星笔记可以参考<a href="http://rednaxelafx.iteye.com/blog/905273" target="_blank">我以前一老帖</a>。
再接再厉，用revptrs看看第二个Test2实例有谁引用：
Hsdb代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>hsdb&gt; revptrs 0x00000000fa49a730  </li>
<li>Oop for Test @ 0x00000000fa49a720  </li>
</ol>
<p>hsdb&gt; revptrs 0x00000000fa49a730</p>
<p>Oop for Test @ 0x00000000fa49a720
找到了一个Test实例。同样用whatis来看看它在哪儿：
Hsdb代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>hsdb&gt; whatis 0x00000000fa49a720  </li>
<li>Address 0x00000000fa49a720: In thread-local allocation buffer for thread &quot;main&quot; (1)  [0x00000000fa48f490,0x00000000fa49a750,0x00000000fa49d118)  </li>
<li></li>
</ol>
<p>hsdb&gt; whatis 0x00000000fa49a720</p>
<p>Address 0x00000000fa49a720: In thread-local allocation buffer for thread &quot;main&quot; (1)  [0x00000000fa48f490,0x00000000fa49a750,0x00000000fa49d118)</p>
<p>果然也在main线程的TLAB里。
然后看这个Test实例的内容：
Hsdb代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>hsdb&gt; inspect 0x00000000fa49a720  </li>
<li>instance of Oop for Test @ 0x00000000fa49a720 @ 0x00000000fa49a720 (size = 16)  </li>
<li>&lt;<Reverse pointers>&gt;:   </li>
<li>_mark: 1  </li>
<li>t2: Oop for Test2 @ 0x00000000fa49a730 Oop for Test2 @ 0x00000000fa49a730  </li>
</ol>
<p>hsdb&gt; inspect 0x00000000fa49a720</p>
<p>instance of Oop for Test @ 0x00000000fa49a720 @ 0x00000000fa49a720 (size = 16)
&lt;<Reverse pointers>&gt;:</p>
<p>_mark: 1
t2: Oop for Test2 @ 0x00000000fa49a730 Oop for Test2 @ 0x00000000fa49a730
可以看到这个Test实例里有个成员字段t2，指向了第二个Test2实例。
<strong>于是t2也找到了！在Java堆里，作为Test的实例的成员字段存在。</strong>
那么赶紧试试用revptrs命令看第三个Test2实例：
Hsdb代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>hsdb&gt; revptrs 0x00000000fa49a740  </li>
<li>null  </li>
</ol>
<p>hsdb&gt; revptrs 0x00000000fa49a740</p>
<p>null
啥？没找到？！SA这也太弱小了吧。明明就在那里…
回头我会做个补丁让新版HotSpot VM的SA能处理这种情况。
这个时候的HSDB界面全貌：
<img src="&quot;点击查看原始大小图片&quot;" alt="">
0x00000000fa49a740看起来有没有点眼熟？
回到前面打开的Stack Memory窗口看，仔细看会发现那个窗口里正好就有0x00000000fa49a740这数字，位于0x000000000287f858地址上。
实际情况是，下面这张图里红色框住的部分就是main线程上Test.fn()的调用对应的栈帧：
<img src="&quot;点击查看原始大小图片&quot;" alt="">
如果图里看得不清楚的话，我再用文字重新写一遍（两道横线之间的是Test.fn()的栈帧内容，前后的则是别的东西）：
Memory代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>0x000000000287f7f0: 0x0000000002886298   </li>
<li>0x000000000287f7f8: 0x0000000002893ca5   </li>
<li>0x000000000287f800: 0x0000000002893ca5   </li>
<li><hr>
</li>
<li>Stack frame for Test.fn() @bci=8, line=6, pc=0x0000000002893ca5, methodOop=0x00000000fb077f78 (Interpreted frame)  </li>
<li>0x000000000287f808: 0x000000000287f808 expression stack bottom          &lt;- rsp  </li>
<li>0x000000000287f810: 0x00000000fb077f58 bytecode pointer    = 0x00000000fb077f50 (base) + 8 (bytecode index) in PermGen  </li>
<li>0x000000000287f818: 0x000000000287f860 pointer to locals  </li>
<li>0x000000000287f820: 0x00000000fb078360 constant pool cache = ConstantPoolCache for Test in PermGen  </li>
<li>0x000000000287f828: 0x0000000000000000 method data oop     = null  </li>
<li>0x000000000287f830: 0x00000000fb077f78 method oop          = Method for Test.fn()V in PermGen  </li>
<li>0x000000000287f838: 0x0000000000000000 last Java stack pointer (not set)  </li>
<li>0x000000000287f840: 0x000000000287f860 old stack pointer (saved rsp)  </li>
<li>0x000000000287f848: 0x000000000287f8a8 old frame pointer (saved rbp)    &lt;- rbp  </li>
<li>0x000000000287f850: 0x0000000002886298 return address      = in interpreter codelet &quot;return entry points&quot; [0x00000000028858b8, 0x00000000028876c0)  7688 bytes  </li>
<li>0x000000000287f858: 0x00000000fa49a740 local[1] &quot;t3&quot;       = Oop for Test2 in NewGen  </li>
<li>0x000000000287f860: 0x00000000fa49a720 local[0] &quot;this&quot;     = Oop for Test in NewGen  </li>
<li><hr>
</li>
<li>0x000000000287f868: 0x000000000287f868   </li>
<li>0x000000000287f870: 0x00000000fb077039   </li>
<li>0x000000000287f878: 0x000000000287f8c0   </li>
<li>0x000000000287f880: 0x00000000fb077350   </li>
<li>0x000000000287f888: 0x0000000000000000   </li>
<li>0x000000000287f890: 0x00000000fb077060   </li>
<li>0x000000000287f898: 0x000000000287f860   </li>
<li>0x000000000287f8a0: 0x000000000287f8c0   </li>
<li>0x000000000287f8a8: 0x000000000287f9a0   </li>
<li>0x000000000287f8b0: 0x000000000288062a   </li>
<li>0x000000000287f8b8: 0x00000000fa49a720   </li>
<li>0x000000000287f8c0: 0x00000000fa498ea8   </li>
<li>0x000000000287f8c8: 0x0000000000000000   </li>
<li>0x000000000287f8d0: 0x0000000000000000   </li>
<li>0x000000000287f8d8: 0x0000000000000000   </li>
</ol>
<p>0x000000000287f7f0: 0x0000000002886298</p>
<p>0x000000000287f7f8: 0x0000000002893ca5
0x000000000287f800: 0x0000000002893ca5</p>
<hr>
<p>Stack frame for Test.fn() @bci=8, line=6, pc=0x0000000002893ca5, methodOop=0x00000000fb077f78 (Interpreted frame)</p>
<p>0x000000000287f808: 0x000000000287f808 expression stack bottom          &lt;- rsp
0x000000000287f810: 0x00000000fb077f58 bytecode pointer    = 0x00000000fb077f50 (base) + 8 (bytecode index) in PermGen</p>
<p>0x000000000287f818: 0x000000000287f860 pointer to locals
0x000000000287f820: 0x00000000fb078360 constant pool cache = ConstantPoolCache for Test in PermGen</p>
<p>0x000000000287f828: 0x0000000000000000 method data oop     = null
0x000000000287f830: 0x00000000fb077f78 method oop          = Method for Test.fn()V in PermGen</p>
<p>0x000000000287f838: 0x0000000000000000 last Java stack pointer (not set)
0x000000000287f840: 0x000000000287f860 old stack pointer (saved rsp)</p>
<p>0x000000000287f848: 0x000000000287f8a8 old frame pointer (saved rbp)    &lt;- rbp
0x000000000287f850: 0x0000000002886298 return address      = in interpreter codelet &quot;return entry points&quot; [0x00000000028858b8, 0x00000000028876c0)  7688 bytes</p>
<p>0x000000000287f858: 0x00000000fa49a740 local[1] &quot;t3&quot;       = Oop for Test2 in NewGen
0x000000000287f860: 0x00000000fa49a720 local[0] &quot;this&quot;     = Oop for Test in NewGen</p>
<hr>
<p>0x000000000287f868: 0x000000000287f868</p>
<p>0x000000000287f870: 0x00000000fb077039
0x000000000287f878: 0x000000000287f8c0</p>
<p>0x000000000287f880: 0x00000000fb077350
0x000000000287f888: 0x0000000000000000</p>
<p>0x000000000287f890: 0x00000000fb077060
0x000000000287f898: 0x000000000287f860</p>
<p>0x000000000287f8a0: 0x000000000287f8c0
0x000000000287f8a8: 0x000000000287f9a0</p>
<p>0x000000000287f8b0: 0x000000000288062a
0x000000000287f8b8: 0x00000000fa49a720</p>
<p>0x000000000287f8c0: 0x00000000fa498ea8
0x000000000287f8c8: 0x0000000000000000</p>
<p>0x000000000287f8d0: 0x0000000000000000
0x000000000287f8d8: 0x0000000000000000
回顾<a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-2.html#jvms-2.6" target="_blank">JVM规范里所描述的Java栈帧结构</a>，包括：
[ 操作数栈  (operand stack)   ]</p>
<p>[ 栈帧信息  (dynamic linking) ]
[ 局部变量区 (local variables) ]
上张<a href="http://www.valleytalk.org/2011/07/28/java-%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%EF%BC%8C%E5%8A%A0%E8%BD%BD-%E5%92%8C-%E6%89%A7%E8%A1%8C/" target="_blank">我以前做的投影稿</a>里的图：
<img src="" alt="">
再跟HotSpot VM的解释器所使用的栈帧布局对比看看，是不是正好能对应上？局部变量区（locals）有了，VM所需的栈帧信息也有了；执行到这个位置operand stack正好是空的所以看不到它。
（HotSpot VM里把operand stack叫做expression stack。这是因为operand stack通常只在表达式求值过程中才有内容）
<strong>从Test.fn()的栈帧中我们可以看到t3变量就在locals[1]的位置上。t3变量也找到了！大功告成！</strong>
栈帧信息里具体都是些啥，以后有机会再展开讲吧。
都看到这里了，干脆把main方法的栈帧也如法炮制分析一下。先上图：
<img src="&quot;点击查看原始大小图片&quot;" alt="">
然后再用文字写一次：
Memory代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a></p>
<ol>
<li>0x000000000287f7f0: 0x0000000002886298   </li>
<li>0x000000000287f7f8: 0x0000000002893ca5   </li>
<li>0x000000000287f800: 0x0000000002893ca5   </li>
<li>0x000000000287f808: 0x000000000287f808   </li>
<li>0x000000000287f810: 0x00000000fb077f58   </li>
<li>0x000000000287f818: 0x000000000287f860   </li>
<li>0x000000000287f820: 0x00000000fb078360   </li>
<li>0x000000000287f828: 0x0000000000000000   </li>
<li>0x000000000287f830: 0x00000000fb077f78   </li>
<li>0x000000000287f838: 0x0000000000000000   </li>
<li>0x000000000287f840: 0x000000000287f860   </li>
<li>0x000000000287f848: 0x000000000287f8a8   </li>
<li>0x000000000287f850: 0x0000000002886298   </li>
<li>0x000000000287f858: 0x00000000fa49a740   </li>
<li><hr>
</li>
<li>Stack frame for Main.main(java.lang.String[]) @bci=9, line=4, pc=0x0000000002886298, methodOop=0x00000000fb077060 (Interpreted frame)  </li>
<li>0x000000000287f860: 0x00000000fa49a720 expression stack[0] = Oop for Test in NewGen  </li>
<li>0x000000000287f868: 0x000000000287f868 expression stack bottom  </li>
<li>0x000000000287f870: 0x00000000fb077039 bytecode pointer    = 0x00000000fb077030 (base) + 9 (bytecode index) in PermGen  </li>
<li>0x000000000287f878: 0x000000000287f8c0 pointer to locals  </li>
<li>0x000000000287f880: 0x00000000fb077350 constant pool cache = ConstantPoolCache for Main in PermGen  </li>
<li>0x000000000287f888: 0x0000000000000000 method data oop     = null  </li>
<li>0x000000000287f890: 0x00000000fb077060 method oop          = Method for Main.main([Ljava/lang/String;)V in PermGen  </li>
<li>0x000000000287f898: 0x000000000287f860 last Java stack pointer  </li>
<li>0x000000000287f8a0: 0x000000000287f8c0 old stack pointer  </li>
<li>0x000000000287f8a8: 0x000000000287f9a0 old frame pointer  </li>
<li>0x000000000287f8b0: 0x000000000288062a return address      = in StubRoutines  </li>
<li>0x000000000287f8b8: 0x00000000fa49a720 local[1] &quot;test&quot;     = Oop for Test in NewGen  </li>
<li>0x000000000287f8c0: 0x00000000fa498ea8 local[0] &quot;args&quot;     = Oop for java.lang.String[] in NewGen  </li>
<li><hr>
</li>
<li>0x000000000287f8c8: 0x0000000000000000   </li>
<li>0x000000000287f8d0: 0x0000000000000000   </li>
<li>0x000000000287f8d8: 0x0000000000000000   </li>
</ol>
<p>0x000000000287f7f0: 0x0000000002886298</p>
<p>0x000000000287f7f8: 0x0000000002893ca5
0x000000000287f800: 0x0000000002893ca5</p>
<p>0x000000000287f808: 0x000000000287f808
0x000000000287f810: 0x00000000fb077f58</p>
<p>0x000000000287f818: 0x000000000287f860
0x000000000287f820: 0x00000000fb078360</p>
<p>0x000000000287f828: 0x0000000000000000
0x000000000287f830: 0x00000000fb077f78</p>
<p>0x000000000287f838: 0x0000000000000000
0x000000000287f840: 0x000000000287f860</p>
<p>0x000000000287f848: 0x000000000287f8a8
0x000000000287f850: 0x0000000002886298</p>
<h2 id="0x000000000287f858-0x00000000fa49a740">0x000000000287f858: 0x00000000fa49a740</h2>
<p>Stack frame for Main.main(java.lang.String[]) @bci=9, line=4, pc=0x0000000002886298, methodOop=0x00000000fb077060 (Interpreted frame)
0x000000000287f860: 0x00000000fa49a720 expression stack[0] = Oop for Test in NewGen</p>
<p>0x000000000287f868: 0x000000000287f868 expression stack bottom
0x000000000287f870: 0x00000000fb077039 bytecode pointer    = 0x00000000fb077030 (base) + 9 (bytecode index) in PermGen</p>
<p>0x000000000287f878: 0x000000000287f8c0 pointer to locals
0x000000000287f880: 0x00000000fb077350 constant pool cache = ConstantPoolCache for Main in PermGen</p>
<p>0x000000000287f888: 0x0000000000000000 method data oop     = null
0x000000000287f890: 0x00000000fb077060 method oop          = Method for Main.main([Ljava/lang/String;)V in PermGen</p>
<p>0x000000000287f898: 0x000000000287f860 last Java stack pointer
0x000000000287f8a0: 0x000000000287f8c0 old stack pointer</p>
<p>0x000000000287f8a8: 0x000000000287f9a0 old frame pointer
0x000000000287f8b0: 0x000000000288062a return address      = in StubRoutines</p>
<p>0x000000000287f8b8: 0x00000000fa49a720 local[1] &quot;test&quot;     = Oop for Test in NewGen
0x000000000287f8c0: 0x00000000fa498ea8 local[0] &quot;args&quot;     = Oop for java.lang.String[] in NewGen</p>
<hr>
<p>0x000000000287f8c8: 0x0000000000000000</p>
<p>0x000000000287f8d0: 0x0000000000000000
0x000000000287f8d8: 0x0000000000000000
main的栈帧的operand stack就不是空的了，有一个元素，用来传递参数给其调用的Test.fn()方法（作为“this”）。
仔细的同学可能发现了，0x000000000287f860这个地址前面不是说是调用Test.fn()产生的栈帧么？怎么这里又变成调用main()方法的栈帧的一部分了呢？
其实栈帧直接可以有重叠：（再上一张以前做的投影稿里的图）
<img src="&quot;点击查看原始大小图片&quot;" alt="">
这样可以减少传递参数所需的数据拷贝，也节省了空间。
回到HSDB，我们换个方式来把t3变量找出来。这里就需要编译Test.java时给的-g参数所生成的LocalVariableTable的信息了：
Hsdb代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a></p>
<ol>
<li>hsdb&gt; jseval &quot;ts = jvm.threads&quot;  </li>
<li>[Thread (address=0x00000000fa48fb38, name=Service Thread), Thread (address=0x00000000fa48fa18, name=C2 CompilerThread1), Thread (address=0x00000000fa48f8f8, name=C2 CompilerThread0), Thread (address=0x00000000fa49d178, name=JDWP Command Reader), Thread (address=0x00000000fa48f820, name=JDWP Event Helper Thread), Thread (address=0x00000000fa48f6d8, name=JDWP Transport Listener: dt_shmem), Thread (address=0x00000000fa48dc88, name=Attach Listener), Thread (address=0x00000000fa48db68, name=Signal Dispatcher), Thread (address=0x00000000fa405828, name=Finalizer), Thread (address=0x00000000fa4053a0, name=Reference Handler), Thread (address=0x00000000fa404860, name=main)]   </li>
<li>hsdb&gt; jseval &quot;t = ts[ts.length - 1]&quot;  </li>
<li>Thread (address=0x00000000fa404860, name=main)   </li>
<li>hsdb&gt; jseval &quot;fs = t.frames&quot;  </li>
<li>[Frame (method=Test.fn(), bci=8, line=6), Frame (method=Main.main(java.lang.String[]), bci=9, line=4)]   </li>
<li>hsdb&gt; jseval &quot;f0 = fs[0]&quot;  </li>
<li>Frame (method=Test.fn(), bci=8, line=6)   </li>
<li>hsdb&gt; jseval &quot;f1 = fs[1]&quot;  </li>
<li>Frame (method=Main.main(java.lang.String[]), bci=9, line=4)   </li>
<li>hsdb&gt; jseval &quot;f0.locals&quot;  </li>
<li>{t3=Object 0x00000000fa49a740}   </li>
<li>hsdb&gt;   </li>
</ol>
<p>hsdb&gt; jseval &quot;ts = jvm.threads&quot;</p>
<p>[Thread (address=0x00000000fa48fb38, name=Service Thread), Thread (address=0x00000000fa48fa18, name=C2 CompilerThread1), Thread (address=0x00000000fa48f8f8, name=C2 CompilerThread0), Thread (address=0x00000000fa49d178, name=JDWP Command Reader), Thread (address=0x00000000fa48f820, name=JDWP Event Helper Thread), Thread (address=0x00000000fa48f6d8, name=JDWP Transport Listener: dt_shmem), Thread (address=0x00000000fa48dc88, name=Attach Listener), Thread (address=0x00000000fa48db68, name=Signal Dispatcher), Thread (address=0x00000000fa405828, name=Finalizer), Thread (address=0x00000000fa4053a0, name=Reference Handler), Thread (address=0x00000000fa404860, name=main)]
hsdb&gt; jseval &quot;t = ts[ts.length - 1]&quot;</p>
<p>Thread (address=0x00000000fa404860, name=main)
hsdb&gt; jseval &quot;fs = t.frames&quot;</p>
<p>[Frame (method=Test.fn(), bci=8, line=6), Frame (method=Main.main(java.lang.String[]), bci=9, line=4)]
hsdb&gt; jseval &quot;f0 = fs[0]&quot;</p>
<p>Frame (method=Test.fn(), bci=8, line=6)
hsdb&gt; jseval &quot;f1 = fs[1]&quot;</p>
<p>Frame (method=Main.main(java.lang.String[]), bci=9, line=4)
hsdb&gt; jseval &quot;f0.locals&quot;</p>
<p>{t3=Object 0x00000000fa49a740}</p>
<h1 id="hsdb-">hsdb&gt;</h1>
<p>上面讲栈帧布局的时候出现了“bytecode pointer”字眼。既然之前被不少好奇的同学问过“JVM里字节码存在哪里”，这里就一并回答掉好了。
强调一点：“字节码”只是元数据的一部分。它只负责描述运行逻辑，而其它信息像是类型名、成员的个数、类型、名字等等都<strong>不是字节码</strong>。在Class文件里是如此，到运行时在JVM里仍然是如此。
HotSpot VM里有一套对象专门用来存放元数据，它们包括：</p>
<ul>
<li>Klass系对象。元数据的最主要入口。用于描述类型的总体信息</li>
<li>ConstantPool/ConstantPoolCache对象。每个InstanceKlass关联着一个ConstantPool，作为该类型的运行时常量池。这个常量池的结构跟Class文件里的常量池基本上是对应的。可以参考<a href="http://hllvm.group.iteye.com/group/topic/26412#post-187861" target="_blank">我以前的一个回帖</a>。ConstantPoolCache主要用于存储某些字节码指令所需的解析（resolve）好的常量项，例如给[get|put]static、[get|put]field、invoke[static|special|virtual|interface|dynamic]等指令对应的常量池项用。</li>
<li>Method对象，用来描述Java方法的总体信息，像是方法入口地址、调用/循环计数器等等</li>
<li>ConstMethod对象，记录着Java方法的不变的描述信息，包括方法名、方法的访问修饰符、<strong>字节码</strong>、行号表、局部变量表等等。注意了，字节码就嵌在这ConstMethod对象里面。</li>
<li>Symbol对象，对应Class文件常量池里的JVM_CONSTANT_Utf8类型的常量。有一个VM全局的SymbolTable管理着所有Symbol。Symbol由所有Java类所共享。</li>
<li>MethodData对象，记录着Java方法执行时的profile信息，例如某方法里的某个字节码之类是否从来没遇到过null，某个条件跳转是否总是走同一个分支，等等。这些信息在解释器（多层编译模式下也在低层的编译生成的代码里）收集，然后供给HotSpot Server Compiler用于做激进优化。
在PermGen移除前，上述元数据对象都在PermGen里，直接被GC管理着。
JDK8彻底移除PermGen后，这些对象被挪到GC堆外的一块叫做Metaspace的空间里做特殊管理，仍然间接的受GC管理。
介绍了背景，让我们回到HSDB里。前面不是说“bytecode pointer (bcp)”嘛，从背景介绍可以知道字节码存在ConstMethod对象里，那就让我们用Test.fn()栈帧里存的bcp来验证一下是否真的如此。
还是用whatis命令：
Hsdb代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a></li>
</ul>
<ol>
<li>hsdb&gt; whatis 0x00000000fb077f58  </li>
<li>Address 0x00000000fb077f58: In perm generation   perm [0x00000000fae00000,0x00000000fb078898,0x00000000fc2c0000) space capacity = 21757952, 11.90770160721009 used   </li>
</ol>
<p>hsdb&gt; whatis 0x00000000fb077f58</p>
<p>Address 0x00000000fb077f58: In perm generation   perm <a href="&quot;复制代码&quot;">0x00000000fae00000,0x00000000fb078898,0x00000000fc2c0000) space capacity = 21757952, 11.90770160721009 used
这地址确实在PermGen里了。那么inspect一下看看？
Hsdb代码 [<img src="" alt="复制代码"></a></p>
<ol>
<li>hsdb&gt; inspect 0x00000000fb077f58  </li>
<li>Error: sun.jvm.hotspot.debugger.UnalignedAddressException: 100011  </li>
</ol>
<p>hsdb&gt; inspect 0x00000000fb077f58</p>
<p>Error: sun.jvm.hotspot.debugger.UnalignedAddressException: 100011
呃，这样不行。inspect命令只能接受对象的起始地址，但字节码是嵌在ConstMethod对象中间的。
那换条路子。栈帧里还有method oop，指向该栈帧对应的Method对象。先从它入手：
Hsdb代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a></p>
<ol>
<li>hsdb&gt; inspect 0x00000000fb077f78  </li>
<li>instance of Method fn()V@0x00000000fb077f78 @ 0x00000000fb077f78 @ 0x00000000fb077f78 (size = 136)  </li>
<li>_mark: 1  </li>
<li>_constMethod: ConstMethod fn()V@0x00000000fb077f08 @ 0x00000000fb077f08 Oop @ 0x00000000fb077f08  </li>
<li>_constants: ConstantPool for Test @ 0x00000000fb077c68 Oop @ 0x00000000fb077c68  </li>
<li>_method_size: 17  </li>
<li>_max_stack: 2  </li>
<li>_max_locals: 2  </li>
<li>_size_of_parameters: 1  </li>
<li>_access_flags: 1  </li>
</ol>
<p>hsdb&gt; inspect 0x00000000fb077f78</p>
<p>instance of Method fn()V@0x00000000fb077f78 @ 0x00000000fb077f78 @ 0x00000000fb077f78 (size = 136)
_mark: 1</p>
<p>_constMethod: ConstMethod fn()V@0x00000000fb077f08 @ 0x00000000fb077f08 Oop @ 0x00000000fb077f08
_constants: ConstantPool for Test @ 0x00000000fb077c68 Oop @ 0x00000000fb077c68</p>
<p>_method_size: 17
_max_stack: 2</p>
<p>_max_locals: 2
_size_of_parameters: 1</p>
<p>_access_flags: 1
这样就找到了Test.fn()的Method对象，看到里面的_constMethod字段所指向的ConstMethod对象：
Hsdb代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a></p>
<ol>
<li>hsdb&gt; inspect 0x00000000fb077f08  </li>
<li>instance of ConstMethod fn()V@0x00000000fb077f08 @ 0x00000000fb077f08 @ 0x00000000fb077f08 (size = 112)  </li>
<li>_mark: 1  </li>
<li>_method: Method fn()V@0x00000000fb077f78 @ 0x00000000fb077f78 Oop @ 0x00000000fb077f78  </li>
<li>_exception_table: [I @ 0x00000000fae01d50 Oop for [I @ 0x00000000fae01d50  </li>
<li>_constMethod_size: 14  </li>
<li>_flags: 5  </li>
<li>_code_size: 9  </li>
<li>_name_index: 18  </li>
<li>_signature_index: 12  </li>
<li>_generic_signature_index: 0  </li>
<li>_code_size: 9  </li>
</ol>
<p>hsdb&gt; inspect 0x00000000fb077f08</p>
<p>instance of ConstMethod fn()V@0x00000000fb077f08 @ 0x00000000fb077f08 @ 0x00000000fb077f08 (size = 112)
_mark: 1</p>
<p>_method: Method fn()V@0x00000000fb077f78 @ 0x00000000fb077f78 Oop @ 0x00000000fb077f78
_exception_table: [I @ 0x00000000fae01d50 Oop for [I @ 0x00000000fae01d50</p>
<p>_constMethod_size: 14
_flags: 5</p>
<p>_code_size: 9
_name_index: 18</p>
<p>_signature_index: 12
_generic_signature_index: 0</p>
<p>_code_size: 9
这个ConstMethod对象从0x00000000fb077f08开始，长度112字节，也就是这个对象的范围是<a href="&quot;复制代码&quot;">0x00000000fb077f08, 0x00000000fb077f78)。bcp指向0x00000000fb077f58，确实在这个ConstMethod范围内。
通过经验可以知道实际上这里字节码的起始地址是0x00000000fb077f50。通过ConstMethod的_code_size字段可以知道该方法的字节码有9字节。找出来用mem命令看看内存里的数据：
Hsdb代码 [<img src="" alt="复制代码"></a></p>
<ol>
<li>hsdb&gt; mem 0x00000000fb077f50 2  </li>
<li>0x00000000fb077f50: 0x4c0001b7590200ca   </li>
<li>0x00000000fb077f58: 0x00000000004105b1   </li>
</ol>
<p>hsdb&gt; mem 0x00000000fb077f50 2</p>
<p>0x00000000fb077f50: 0x4c0001b7590200ca
0x00000000fb077f58: 0x00000000004105b1
这串数字是什么东西呢？展开来写清楚一点就是：
Memory代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a></p>
<ol>
<li>0x00000000fb077f50:  bb 00 02  new <cp index /#2> [Class Test2]  </li>
<li>0x00000000fb077f53:  59        dup  </li>
<li>0x00000000fb077f54:  b7 01 00  invokespecial <cp cache index /#1> [Method Test2.<init>()V]  </li>
<li>0x00000000fb077f57:  4c        astore_1  </li>
<li>0x00000000fb077f58:  b1        return  </li>
</ol>
<p>0x00000000fb077f50:  bb 00 02  new <cp index /#2> [Class Test2]</p>
<p>0x00000000fb077f53:  59        dup
0x00000000fb077f54:  b7 01 00  invokespecial <cp cache index /#1> [Method Test2.<init>()V]</p>
<p>0x00000000fb077f57:  4c        astore_1
0x00000000fb077f58:  b1        return
眼尖的同学要吐槽了：在0x00000000fb077f50的字节不是0xca么，怎么变成0xbb了？
其实0xca是JVM规范里有描述的一个可选字节码指令，<a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html#jvms-6.2" target="_blank">breakpoint</a>
Memory代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a></p>
<ol>
<li>0x00000000fb077f50:  ca 00 02  breakpoint // 00 02 not used  </li>
</ol>
<p>0x00000000fb077f50:  ca 00 02  breakpoint // 00 02 not used
还记得本文的实验一开始用了jdb在Test.fn()的入口设置了断点吗？这就是结果——入口处的字节码指令被改写为breakpoint了。当然，原本的字节码指令也还在别的地方存着，等断点解除之后这个位置就会被恢复成原本的0xbb指令。
把ConstMethod里存的字节码跟Class文件里存的比较一下看看。用<a href="http://docs.oracle.com/javase/7/docs/technotes/tools/windows/javap.html" target="_blank">javap</a>工具来看Class文件的内容：
Javap代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a></p>
<ol>
<li>public void fn();  </li>
<li>Code:  </li>
<li>stack=2, locals=2, args_size=1  </li>
<li>0:  bb 00 02  new           /#2                  // class Test2  </li>
<li>3:  59        dup  </li>
<li>4:  b7 00 03  invokespecial /#3                  // Method Test2.&quot;<init>&quot;:()V  </li>
<li>7:  4c        astore_1  </li>
<li><p>8:  b1        return  </p>
<p>public void fn();</p>
<p>Code:
stack=2, locals=2, args_size=1</p>
<p>0:  bb 00 02  new           /#2                  // class Test2
3:  59        dup</p>
<p>4:  b7 00 03  invokespecial /#3                  // Method Test2.&quot;<init>&quot;:()V
7:  4c        astore_1</p>
<p>8:  b1        return
几乎一模一样。唯一的不同也是个有趣的小细节：invokespecial的参数的常量池号码不一样了。HotSpot VM执行new指令的时候用的还是Class文件里的常量池号和字节序。而在执行invokespecial时，光是ConstantPool里的的常量项不够地方放解析（resolve）出来的信息，所以把这些信息放在ConstantPoolCache里，然后也把invokespecial指令里的参数改写过来，顺带变成了平台相关的字节序。
同样也看看Main.main()方法。内存内容：
Memory代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a></p>
</li>
<li><p>hsdb&gt; mem 0x00000000fb077030 2  </p>
</li>
<li>0x00000000fb077030: 0x4c0001b7590200bb   </li>
<li>0x00000000fb077038: 0x214103b10002b62b   </li>
</ol>
<p>hsdb&gt; mem 0x00000000fb077030 2</p>
<p>0x00000000fb077030: 0x4c0001b7590200bb
0x00000000fb077038: 0x214103b10002b62b
展开来注解：
Memory代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a></p>
<ol>
<li>0x00000000fb077030:  bb 00 02  new <cp index /#2> [Class Test]  </li>
<li>0x00000000fb077033:  59        dup  </li>
<li>0x00000000fb077034:  b7 01 00  invokespecial <cp cache index /#1> [Method Test.<init>()V]  </li>
<li>0x00000000fb077037:  4c        astore_1  </li>
<li>0x00000000fb077038:  2b        aload_1  </li>
<li>0x00000000fb077039:  b6 02 00  invokevirtual <cp cache index /#2> [Method Test.fn()V]  </li>
<li>0x00000000fb07703c:  b1        return  </li>
</ol>
<p>0x00000000fb077030:  bb 00 02  new <cp index /#2> [Class Test]</p>
<p>0x00000000fb077033:  59        dup
0x00000000fb077034:  b7 01 00  invokespecial <cp cache index /#1> [Method Test.<init>()V]</p>
<p>0x00000000fb077037:  4c        astore_1
0x00000000fb077038:  2b        aload_1</p>
<p>0x00000000fb077039:  b6 02 00  invokevirtual <cp cache index /#2> [Method Test.fn()V]
0x00000000fb07703c:  b1        return
对应的javap输出：
Javap代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a></p>
<ol>
<li>public static void main(java.lang.String[]);  </li>
<li>Code:  </li>
<li>stack=2, locals=2, args_size=1  </li>
<li>0:  bb 00 02  new           /#2                  // class Test  </li>
<li>3:  59        dup  </li>
<li>4:  b7 00 03  invokespecial /#3                  // Method Test.&quot;<init>&quot;:()V  </li>
<li>7:  4c        astore_1  </li>
<li>8:  2b        aload_1  </li>
<li>9:  b6 00 04  invokevirtual /#4                  // Method Test.fn:()V  </li>
<li><p>12:  b1        return  </p>
<p>public static void main(java.lang.String[]);</p>
<p>Code:
stack=2, locals=2, args_size=1</p>
<p>0:  bb 00 02  new           /#2                  // class Test
3:  59        dup</p>
<p>4:  b7 00 03  invokespecial /#3                  // Method Test.&quot;<init>&quot;:()V
7:  4c        astore_1</p>
<p>8:  2b        aload_1
9:  b6 00 04  invokevirtual /#4                  // Method Test.fn:()V</p>
<p>12:  b1        return
好，今天就写到这里吧～</p>
</li>
</ol>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/JVM/">JVM</a></li></span></span> | <span class="tags">Tagged <a href="/tags/JVM/" class="label label-primary">JVM</a><a href="/tags/Java&J2EE/" class="label label-success">Java&J2EE</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:42"datetime="2014-03-07 09:54:42"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-JVM--借HSDB来探索HotSpotVM的运行时数据/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-JVM--借HSDB来探索HotSpotVM的运行时数据" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--动态跟踪Java代码的执行状况工具--BTrace/">动态跟踪Java代码的执行状况工具</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:42.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--动态跟踪Java代码的执行状况工具--BTrace/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-java-btrace">动态跟踪Java代码的执行状况工具--BTrace</h1>
<h1 id="-bluedavy-blog-http-www-blogjava-net-bluedavy-"><a href="http://www.blogjava.net/BlueDavy/" target="_blank">BlueDavy之技术Blog</a></h1>
<p>理论不懂就实践，实践不会就学理论！</p>
<h2 id="-java-btrace-http-www-blogjava-net-bluedavy-archive-2009-10-10-297661-html-"><a href="http://www.blogjava.net/BlueDavy/archive/2009/10/10/297661.html" target="_blank">动态跟踪Java代码的执行状况工具--BTrace</a></h2>
<p>非常强烈的推荐下BTrace这个工具，用了后不得不说太强大了，BTrace简单来说，就是能在不改动当前程序的情况下，运行时的去监控Java程序的执行状况，例如可以做到内存状况的监控、方法调用的监控等等，官方网站上有非常多详细的例子，我不说太多，只在下面举一个简单的例子来说明它的作用，BTrace的User Guide请见：<a href="http://kenai.com/projects/btrace/pages/UserGuide" target="_blank"><a href="http://kenai.com/projects/btrace/pages/UserGuide">http://kenai.com/projects/btrace/pages/UserGuide</a></a>。
对于运行中的Java程序，尤其是出了问题的程序，会需要跟踪其执行状况，例如传入的参数是什么、执行了多少时间，返回的对象是什么，抛出了什么异常，传统的做法只能是把程序改一遍，加上一堆log，一个例子来展示下用BTrace的情况下，怎么来跟踪一个方法的执行时间：
@BTrace public class MethodResponseTime {</p>
<pre><code>@TLS private static long startTime;

@OnMethod(clazz=&quot;类名&quot;,method=&quot;方法名&quot;)
public static void onCall(){
    println(&quot;enter this method&quot;);
    startTime=timeMillis();
}

@OnMethod(clazz=&quot;类名&quot;,method=&quot;方法名&quot;,location=@Location(Kind.RETURN))
public static void onReturn(){
    println(&quot;method end!&quot;);
    println(strcat(&quot;Time taken ms&quot;,str(timeMillis()-startTime)));
}
</code></pre><p>}
用btrace执行上面的代码，就可以动态的监控任意的目前运行的Java程序中某类的某方法的执行时间，执行上面代码的方式如下（jdk 6+）：
btrace [pid] MethodResponseTime.class
还有例如获取调用参数、调用者的对象实例以及返回值等请参看User Guide。
btrace为了保持JVM运行的安全性，因此做了很多的限制，例如不能抛出异常、修改传入的参数的值、修改返回值等，基本是一个只读的动态分析代码运行状况的工具，但仍然是非常的有用，其实现机制是attach api + asm +  instrumentation。</p>
<p>posted on 2009-10-10 12:41 <a href="http://www.blogjava.net/BlueDavy/" target="_blank">BlueDavy</a> 阅读(11121) <a href="">评论(8)</a>  <a href="http://www.blogjava.net/BlueDavy/admin/EditPosts.aspx?postid=297661" target="_blank">编辑</a>  <a href="http://www.blogjava.net/BlueDavy/AddToFavorite.aspx?id=297661" target="_blank">收藏</a> 所属分类: <a href="http://www.blogjava.net/BlueDavy/category/1366.html" target="_blank">Java</a></p>
<p> <img src="" alt=""></p>
<p><a href=""></a> <a href=""></a></p>
<p>[</p>
<h3 id="-">评论</h3>
<p>]()</p>
<h3 id="-permalink-re-java-btrace-re-java-btrace-2009-10-10-14-02-argan-http-argan-javaeye-com-"><a href=""></a><a href="&quot;permalink: re: 动态跟踪Java代码的执行状况工具--BTrace&quot;">/#</a> <a href=""></a>re: 动态跟踪Java代码的执行状况工具--BTrace  2009-10-10 14:02  <a href="http://argan.javaeye.com/">argan</a></h3>
<p>不错，这个有点强悍的，使用一下先  <a href="">回复</a>  <a href="http://www.blogjava.net/comment?author=argan" title="查看该作者发表过的评论" target="_blank">更多评论</a> <a href=""></a>  <a href=""></a></p>
<h3 id="-permalink-re-java-btrace-re-java-btrace-2009-10-11-01-02-http-www-blogjava-net-unmi-"><a href="&quot;permalink: re: 动态跟踪Java代码的执行状况工具--BTrace&quot;">/#</a> <a href=""></a>re: 动态跟踪Java代码的执行状况工具--BTrace  2009-10-11 01:02  <a href="http://www.blogjava.net/Unmi/">隔叶黄莺</a></h3>
<p>收藏了，以后可能用得着。  <a href="">回复</a>  <a href="http://www.blogjava.net/comment?author=%e9%9a%94%e5%8f%b6%e9%bb%84%e8%8e%ba" title="查看该作者发表过的评论" target="_blank">更多评论</a> <a href=""></a>  <a href=""></a></p>
<h3 id="-permalink-re-java-btrace-re-java-btrace-2009-10-11-23-28-http-www-blogjava-net-youxia-"><a href="&quot;permalink: re: 动态跟踪Java代码的执行状况工具--BTrace[未登录]&quot;">/#</a> <a href=""></a>re: 动态跟踪Java代码的执行状况工具--BTrace[未登录]  2009-10-11 23:28  <a href="http://www.blogjava.net/youxia">海边沫沫</a></h3>
<p>要钱吗?  <a href="">回复</a>  <a href="http://www.blogjava.net/comment?author=%e6%b5%b7%e8%be%b9%e6%b2%ab%e6%b2%ab" title="查看该作者发表过的评论" target="_blank">更多评论</a> <a href=""></a>  <a href=""></a></p>
<h3 id="-permalink-re-java-btrace-re-java-btrace-2009-10-12-03-54-duguo-http-duguo-com-"><a href="&quot;permalink: re: 动态跟踪Java代码的执行状况工具--BTrace&quot;">/#</a> <a href=""></a>re: 动态跟踪Java代码的执行状况工具--BTrace  2009-10-12 03:54  <a href="http://duguo.com/">duguo</a></h3>
<p>试了一下trace Apache Felix 2.0.0, 已加载了的类不好使，抛出NullPointerException。  <a href="">回复</a>  <a href="http://www.blogjava.net/comment?author=duguo" title="查看该作者发表过的评论" target="_blank">更多评论</a> <a href=""></a>  <a href=""></a></p>
<h3 id="-permalink-re-java-btrace-re-java-btrace-2009-10-12-17-12-weager-http-www-blogjava-net-dongritengfei-"><a href="&quot;permalink: re: 动态跟踪Java代码的执行状况工具--BTrace&quot;">/#</a> <a href=""></a>re: 动态跟踪Java代码的执行状况工具--BTrace  2009-10-12 17:12  <a href="http://www.blogjava.net/dongritengfei/">weager</a></h3>
<p>貌似没有什么界面，还得用命令行啊~~~  <a href="">回复</a>  <a href="http://www.blogjava.net/comment?author=weager" title="查看该作者发表过的评论" target="_blank">更多评论</a> <a href=""></a>  <a href=""></a></p>
<h3 id="-permalink-re-java-btrace-re-java-btrace-2009-10-13-00-13-gengmao-"><a href="&quot;permalink: re: 动态跟踪Java代码的执行状况工具--BTrace&quot;">/#</a> <a href=""></a>re: 动态跟踪Java代码的执行状况工具--BTrace  2009-10-13 00:13  <a href="">gengmao</a></h3>
<p>visualvm有btrace的插件  <a href="">回复</a>  <a href="http://www.blogjava.net/comment?author=gengmao" title="查看该作者发表过的评论" target="_blank">更多评论</a> <a href=""></a>  <a href=""></a></p>
<h3 id="-permalink-re-java-btrace-re-java-btrace-2009-10-13-00-57-sswv-http-blog-linjian-org-"><a href="&quot;permalink: re: 动态跟踪Java代码的执行状况工具--BTrace&quot;">/#</a> <a href=""></a>re: 动态跟踪Java代码的执行状况工具--BTrace  2009-10-13 00:57  <a href="http://blog.linjian.org/">sswv</a></h3>
<p>林昊朋友，你好，
首先祝贺你的blog被ZDNet评为了“最受欢迎中国技术博客”之一。
不过你的照片……不知你弄错了还是ZDNet弄错了，是我的头像呵。
详情参考： <a href="http://blog.linjian.org/articles/my-photo-misused-again/" target="_blank"><a href="http://blog.linjian.org/articles/my-photo-misused-again/">http://blog.linjian.org/articles/my-photo-misused-again/</a></a>
有机会看看你写的书。我前不久也与博文视点合作过，是《我是一只IT小小鸟》的合作者之一。  <a href="">回复</a>  <a href="http://www.blogjava.net/comment?author=sswv" title="查看该作者发表过的评论" target="_blank">更多评论</a> <a href=""></a>  <a href=""></a></p>
<h3 id="-permalink-re-java-btrace-re-java-btrace-2009-10-13-08-13-bluedavy-http-www-blogjava-net-bluedavy-"><a href="&quot;permalink: re: 动态跟踪Java代码的执行状况工具--BTrace[未登录]&quot;">/#</a> <a href=""></a>re: 动态跟踪Java代码的执行状况工具--BTrace[未登录]<a href=""></a>  2009-10-13 08:13  <a href="http://www.blogjava.net/bluedavy" target="_blank">BlueDavy</a></h3>
<p>@sswv
...我并不知道ZDNET评选这件事情，我联系下他们吧，不好意思了，<IT小小鸟>可是现在相当火的书，非常恭喜。
  <a href="">回复</a>  <a href="http://www.blogjava.net/comment?author=BlueDavy" title="查看该作者发表过的评论" target="_blank">更多评论</a> <a href=""></a>  <a href=""></a>
<a href="http://www.blogjava.net/RequireRegister.aspx" target="_blank">新用户注册</a>  <a href="">刷新评论列表</a>  </p>
<p><a href=""></a> <a href="http://www.aliyun.com/cps/channel?channel_id=1306&amp;user=0&amp;lv=1">推荐购买云服务器（15%返利+最高千元奖金）</a>   <a href="http://www.cnblogs.com/" target="_blank">博客园</a>  <a href="http://q.cnblogs.com/" target="_blank">博问</a>  <a href="http://news.cnblogs.com/" target="_blank">IT新闻</a>  <a href="http://job.cnblogs.com/cate-java_programmer/" target="_blank">Java程序员招聘</a> 标题  请输入标题 姓名  请输入你的姓名 主页 请输入验证码 验证码 /*  <img src="http://www.blogjava.net/Modules/CaptchaImage/JpegImage.aspx?cacheid=20130727130706" alt=""> 内容(请不要发表任何与政治相关的内容) 请输入评论内容 Remember Me?   <a href="http://www.blogjava.net/login.aspx?ReturnURL=http://www.blogjava.net/BlueDavy/archive/2009/10/10/297661.html&amp;SourceURL=/BlueDavy/archive/2009/10/10/297661.html" target="_blank">登录</a>       [使用Ctrl+Enter键可以直接提交]      网站导航:</p>
<p><a href="http://www.cnblogs.com/" title="程序员的网上家园" target="_blank">博客园</a>   <a href="http://news.cnblogs.com/" target="_blank">IT新闻</a>   <a href="http://kb.cnblogs.com/" target="_blank">知识库</a>   <a href="http://www.cppblog.com/" target="_blank">C++博客</a>   <a href="http://job.cnblogs.com/" target="_blank">程序员招聘</a>   <a href="http://www.blogjava.net/BlueDavy/archive/2009/10/10/297661.html?opt=admin" target="_blank">管理</a> 相关文章:</p>
<ul>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2010/05/25/321796.html" target="_blank">关于《分布式Java应用：基础与实践》一书</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2010/04/30/319794.html" target="_blank">杭州程序员圆桌交流第二期视频</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2010/03/22/316148.html" target="_blank">第一次杭州程序员交流会总结</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2010/03/19/315989.html" target="_blank">杭州程序员圆桌交流第一期–并发编程PPT</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/12/03/304597.html" target="_blank">GCLogViewer(tool to visualize gc log) V0.2 Release</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/11/25/303662.html" target="_blank">Simple Scala actor Vs java Thread Vs Kilim Test</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/11/06/301448.html" target="_blank">《构建高性能的大型分布式Java应用》目录&amp;试读样章</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/10/10/297661.html" target="_blank">动态跟踪Java代码的执行状况工具--BTrace</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/10/09/297562.html" target="_blank">GC策略的调优</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/08/06/290003.html" target="_blank">Hessian 3.2.0的两个bug</a><br>Powered by: <a href="http://www.blogjava.net/" target="_blank">BlogJava</a> Copyright © BlueDavy<h3 id="-">公告</h3>
</li>
</ul>
<p><a href="http://www.douban.com/subject/3843896/" target="_blank"><img src="" alt=""></a> 
<a href="http://china.osgiusers.org/" target="_blank"><img src="" alt=""></a>
<a href="http://feed.feedsky.com/bluedavy" title="BlogJava-BlueDavy之技术Blog" target="_blank"><img src="" alt=""></a> <a href="http://feed.feedsky.com/bluedavy" target="_blank"><img src="" alt="feedsky"></a>
<a href="http://www.zhuaxia.com/add_channel.php?url=http://feed.feedsky.com/bluedavy" target="_blank"><img src="" alt="抓虾"></a>
<a href="http://fusion.google.com/add?feedurl=http://feed.feedsky.com/bluedavy" target="_blank"><img src="" alt="google reader"></a>
<a href="http://www.xianguo.com/subscribe.php?url=http://feed.feedsky.com/bluedavy" target="_blank"><img src="" alt="鲜果"></a></p>
<h3 id="-">导航</h3>
<ul>
<li><a href="http://www.blogjava.net/" target="_blank">BlogJava</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/" target="_blank">首页</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/admin/EditPosts.aspx?opt=1" target="_blank">新随笔</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/contact.aspx?id=1" target="_blank">联系</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/rss" target="_blank">聚合</a><a href="http://www.blogjava.net/BlueDavy/rss" target="_blank"><img src="" alt=""></a></li>
<li><a href="http://www.blogjava.net/BlueDavy/admin/EditPosts.aspx" target="_blank">管理</a>
<a href="&quot;转到上一个月&quot;">&lt;</a>2009年10月<a href="&quot;转到下一个月&quot;">&gt;</a>日一二三四五六2728293012345678<a href="http://www.blogjava.net/BlueDavy/archive/2009/10/09.html" target="_blank">9</a><a href="http://www.blogjava.net/BlueDavy/archive/2009/10/10.html" target="_blank">10</a>1112131415161718192021222324252627282930311234567</li>
</ul>
<h3 id="-">统计</h3>
<ul>
<li>随笔 - 294</li>
<li>文章 - 2</li>
<li>评论 - 2068</li>
<li>引用 - 1</li>
</ul>
<h3 id="-">随笔分类</h3>
<ul>
<li><a href="http://www.blogjava.net/BlueDavy/category/10609.html" target="_blank">@RIAWork(10)</a> <a href="http://www.blogjava.net/BlueDavy/category/10609.html/rss" title="Subscribe to @RIAWork(10)" target="_blank">(rss)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/category/32839.html" target="_blank">Internet(20)</a> <a href="http://www.blogjava.net/BlueDavy/category/32839.html/rss" title="Subscribe to Internet(20)" target="_blank">(rss)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/category/1366.html" target="_blank">Java(82)</a> <a href="http://www.blogjava.net/BlueDavy/category/1366.html/rss" title="Subscribe to Java(82)" target="_blank">(rss)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/category/8127.html" target="_blank">Javascript(7)</a> <a href="http://www.blogjava.net/BlueDavy/category/8127.html/rss" title="Subscribe to Javascript(7)" target="_blank">(rss)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/category/18356.html" target="_blank">OSGi、SOA、SCA(81)</a> <a href="http://www.blogjava.net/BlueDavy/category/18356.html/rss" title="Subscribe to OSGi、SOA、SCA(81)" target="_blank">(rss)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/category/1514.html" target="_blank">Plugin Architecture(10)</a> <a href="http://www.blogjava.net/BlueDavy/category/1514.html/rss" title="Subscribe to Plugin Architecture(10)" target="_blank">(rss)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/category/1513.html" target="_blank">Workflow(4)</a> <a href="http://www.blogjava.net/BlueDavy/category/1513.html/rss" title="Subscribe to Workflow(4)" target="_blank">(rss)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/category/11559.html" target="_blank">业界随想(28)</a> <a href="http://www.blogjava.net/BlueDavy/category/11559.html/rss" title="Subscribe to 业界随想(28)" target="_blank">(rss)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/category/22527.html" target="_blank">数据集成(8)</a> <a href="http://www.blogjava.net/BlueDavy/category/22527.html/rss" title="Subscribe to 数据集成(8)" target="_blank">(rss)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/category/1911.html" target="_blank">系统设计(38)</a> <a href="http://www.blogjava.net/BlueDavy/category/1911.html/rss" title="Subscribe to 系统设计(38)" target="_blank">(rss)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/category/1367.html" target="_blank">软件工程(22)</a> <a href="http://www.blogjava.net/BlueDavy/category/1367.html/rss" title="Subscribe to 软件工程(22)" target="_blank">(rss)</a></li>
</ul>
<h3 id="-">随笔档案</h3>
<ul>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2010/05.html" target="_blank">2010年5月 (3)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2010/04.html" target="_blank">2010年4月 (4)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2010/03.html" target="_blank">2010年3月 (3)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2010/02.html" target="_blank">2010年2月 (1)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2010/01.html" target="_blank">2010年1月 (2)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/12.html" target="_blank">2009年12月 (1)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/11.html" target="_blank">2009年11月 (3)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/10.html" target="_blank">2009年10月 (2)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/09.html" target="_blank">2009年9月 (2)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/08.html" target="_blank">2009年8月 (2)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/07.html" target="_blank">2009年7月 (3)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/06.html" target="_blank">2009年6月 (1)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/05.html" target="_blank">2009年5月 (4)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/04.html" target="_blank">2009年4月 (5)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/03.html" target="_blank">2009年3月 (5)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/01.html" target="_blank">2009年1月 (1)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2008/11.html" target="_blank">2008年11月 (3)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2008/10.html" target="_blank">2008年10月 (1)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2008/09.html" target="_blank">2008年9月 (2)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2008/08.html" target="_blank">2008年8月 (1)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2008/07.html" target="_blank">2008年7月 (4)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2008/06.html" target="_blank">2008年6月 (4)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2008/05.html" target="_blank">2008年5月 (3)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2008/04.html" target="_blank">2008年4月 (1)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2008/03.html" target="_blank">2008年3月 (3)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2008/02.html" target="_blank">2008年2月 (1)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2008/01.html" target="_blank">2008年1月 (10)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2007/12.html" target="_blank">2007年12月 (2)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2007/11.html" target="_blank">2007年11月 (2)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2007/10.html" target="_blank">2007年10月 (6)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2007/09.html" target="_blank">2007年9月 (2)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2007/08.html" target="_blank">2007年8月 (4)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2007/07.html" target="_blank">2007年7月 (5)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2007/06.html" target="_blank">2007年6月 (2)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2007/05.html" target="_blank">2007年5月 (4)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2007/04.html" target="_blank">2007年4月 (2)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2007/03.html" target="_blank">2007年3月 (2)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2007/02.html" target="_blank">2007年2月 (2)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2007/01.html" target="_blank">2007年1月 (1)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/12.html" target="_blank">2006年12月 (6)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/11.html" target="_blank">2006年11月 (5)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/10.html" target="_blank">2006年10月 (8)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/09.html" target="_blank">2006年9月 (13)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/08.html" target="_blank">2006年8月 (15)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/07.html" target="_blank">2006年7月 (3)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/06.html" target="_blank">2006年6月 (7)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/05.html" target="_blank">2006年5月 (9)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/04.html" target="_blank">2006年4月 (12)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/03.html" target="_blank">2006年3月 (13)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/02.html" target="_blank">2006年2月 (9)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/01.html" target="_blank">2006年1月 (14)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2005/12.html" target="_blank">2005年12月 (11)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2005/11.html" target="_blank">2005年11月 (14)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2005/10.html" target="_blank">2005年10月 (9)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2005/09.html" target="_blank">2005年9月 (10)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2005/08.html" target="_blank">2005年8月 (5)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2005/07.html" target="_blank">2005年7月 (9)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2005/06.html" target="_blank">2005年6月 (9)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2005/05.html" target="_blank">2005年5月 (2)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2005/02.html" target="_blank">2005年2月 (1)</a></li>
</ul>
<h3 id="-">文章档案</h3>
<ul>
<li><a href="http://www.blogjava.net/BlueDavy/archives/2005/05.html" target="_blank">2005年5月 (2)</a></li>
</ul>
<h3 id="blogger-s">Blogger&#39;s</h3>
<ul>
<li><a href="http://www.dbanotes.net/" target="_blank">DBANotes</a></li>
<li>大名鼎鼎了，勿需多说</li>
<li><a href="http://www.esbzone.net/" target="_blank">ESBZone</a> <a href="http://www.esbzone.net/feed" title="Subscribe to ESBZone" target="_blank">(rss)</a></li>
<li>SOA实战者，强烈推荐</li>
<li><a href="http://kenwublog.com/" target="_blank">kenwu&#39;s blog[推荐]</a> <a href="http://feed.kenwublog.com/" title="Subscribe to kenwu&#39;s blog[推荐]" target="_blank">(rss)</a></li>
<li>Java底层和JVM的很多文章，强烈推荐。</li>
<li><a href="http://dreamhead.blogbus.com/" target="_blank">梦想风暴</a></li>
<li><a href="http://www.blogjava.net/cenwenchu/" target="_blank">西湖边的穷秀才</a></li>
</ul>
<h3 id="-">搜索</h3>
<p>*</p>
<ul>
<li></li>
</ul>
<h3 id="-http-www-blogjava-net-bluedavy-commentsrss-aspx-">最新评论 <a href="http://www.blogjava.net/BlueDavy/CommentsRSS.aspx" target="_blank"><img src="" alt=""></a></h3>
<ul>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2013/07/19/321796.html#401750" target="_blank">1. re: 关于《分布式Java应用：基础与实践》一书</a></li>
<li>博主 大神啊 这个博客很久没有更新了</li>
<li>--1836567962@qq.com</li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2013/07/11/267970.html#401444" target="_blank">2. re: 网站架构相关PPT、文章整理（更新于2009-7-15）</a></li>
<li>这个文章很有用，收藏</li>
<li>--度哥网</li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2013/05/28/267968.html#399877" target="_blank">3. re: OSGi Opendoc &amp; Book</a></li>
<li>评论内容较长,点击标题查看</li>
<li>--stono</li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2013/05/28/267968.html#399865" target="_blank">4. re: OSGi Opendoc &amp; Book</a></li>
<li>我再看《OSGi》原理与最佳实践，可是源码没有办法下载呀；
有没有什么办法呢？</li>
<li>--stono</li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2013/05/27/321796.html#399801" target="_blank">5. re: 关于《分布式Java应用：基础与实践》一书</a></li>
<li>在这篇blog中放置了我收集的一些网站架构相关的PPT和文章</li>
<li>--色都</li>
</ul>
<h3 id="-">阅读排行榜</h3>
<ul>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2008/09/03/226749.html" target="_blank">1. 大型网站架构演变和知识体系(57638)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/04/28/267970.html" target="_blank">2. 网站架构相关PPT、文章整理（更新于2009-7-15）(38732)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/03/27/37582.html" target="_blank">3. Hibernate实践(31780)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2005/06/13/6037.html" target="_blank">4. 系统设计说明书(架构、概要、详细)目录结构(24258)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/08/25/65741.html" target="_blank">5. 发布《OSGi实战》正式版(17725)</a></li>
</ul>
<h3 id="-">评论排行榜</h3>
<ul>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2008/09/03/226749.html" target="_blank">1. 大型网站架构演变和知识体系(96)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2005/09/07/12340.html" target="_blank">2. 漫谈CMS(88)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/04/28/267970.html" target="_blank">3. 网站架构相关PPT、文章整理（更新于2009-7-15）(66)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2007/09/29/149631.html" target="_blank">4. 《OSGi进阶》预览版发布(59)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/08/25/65741.html" target="_blank">5. 发布《OSGi实战》正式版(54)</a></li>
</ul>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/JVM/">JVM</a></li></span></span> | <span class="tags">Tagged <a href="/tags/JVM/" class="label label-primary">JVM</a><a href="/tags/Java&J2EE/" class="label label-success">Java&J2EE</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:42"datetime="2014-03-07 09:54:42"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-JVM--动态跟踪Java代码的执行状况工具--BTrace/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-JVM--动态跟踪Java代码的执行状况工具--BTrace" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--学习JVM的References/">学习JVM的References</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:42.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--学习JVM的References/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-jvm-references">学习JVM的References</h1>
<h1 id="-bluedavy-blog-https-blog-bluedavy-com-"><a href="https://blog.bluedavy.com/" target="_blank">BlueDavy之技术blog</a></h1>
<p>{互联网，OSGi，Java, High Scalability, High Performance,HA}</p>
<ul>
<li><a href="https://blog.bluedavy.com/" target="_blank">Home</a></li>
<li><a href="https://blog.bluedavy.com/?page_id=2" target="_blank">About</a></li>
<li><a href="https://blog.bluedavy.com/?page_id=81" target="_blank">Photos</a></li>
</ul>
<h2 id="-jvm-references-https-blog-bluedavy-com-p-187-jvm-references-"><a href="https://blog.bluedavy.com/?p=187" title="学习JVM的References" target="_blank">学习JVM的References</a></h2>
<p>Nov 16</p>
<p><a href="http://bluedavy.com/" title="Visit bluedavy’s website" target="_blank">bluedavy</a><a href="https://blog.bluedavy.com/?cat=13" title="View all posts in jvm" target="_blank">jvm</a> <a href="https://blog.bluedavy.com/?tag=jvm" target="_blank">jvm</a>, <a href="https://blog.bluedavy.com/?tag=references" target="_blank">references</a> <a href="&quot;Comment on 学习JVM的References&quot;">15 Comments</a>
本blog中列举了我学习JVM的references，会不断的更新，为了避免版权问题，就不在blog上提供references的下载了，感兴趣的同学可自行下载或购买，:)
大多数的论文可从此下载：<a href="http://citeseer.ist.psu.edu/index.jsp" target="_blank"><a href="http://citeseer.ist.psu.edu/index.jsp">http://citeseer.ist.psu.edu/index.jsp</a></a>
同时推荐@rednaxelafx 整理的jvm的参考资料：<a href="http://goo.gl/oXmRQ" target="_blank"><a href="http://goo.gl/oXmRQ">http://goo.gl/oXmRQ</a></a></p>
<p>References
  |— Towards a Renaissance VM
  |— Oracle JRockit The Definitive Guide
  |— JVM Magic
  |— JAVA虚拟机中文第二版
  |— Java Lang Spec 3.0
  |— Inside Out A Modern Virtual Machine Revealed
  |— Hotspot Overview
  |— Azul’s JVM experiences
  |— A Crash Course in Modern Hardware
  |— [ adaptive ]
        |— Understanding Adaptive Runtimes
        |— Adaptive Optimization of Java Real-time
        |— Adaptive Optimization in the Jalapeno JVM
  |— [ compiler ]
        |— The Java HotSpotTM Server Compiler
        |— Tailoring Graph-coloring Register Allocation For Runtime Compilation
        |— Linear Scan Register Allocation
        |— Design of the Java HotSpotTM Client Compiler for Java 6
  |— [ concurrent ]
        |— The.Art.of.Multiprocessor.Programming.Mar.2008
        |— The Concurrency Revolution The Hardware Story
        |— Multithreaded Programming Guide
        |— JVM Continuations
        |— java.util.concurrent Synchronizer Framework
        |— Java Concurrency Gotchas
        |— Groovy and Concurrency
        |— concurrent programming without locks
        |— Concurrency Grab Bag
        |— Alternative Concurrency Paradigms For the JVM
        |— Accelerating Java Workloads via GPUs
        |— A Scalable Lockfree Stack Algorithm
        |— A Concurrent Dynamic Analysis Framework
  |— [ io ]
        |— Asynchronous IO Tricks and Tips
  |— [ memory management ]
        |— Tuning Java Memory Manager
        |— The Ghost in the Virtual Machine A Reference to References
        |— The Garbage Collection Mythbusters
        |— SuperSizingJava
        |— Step by Step GC Tuning in the HotSpot Java Virtual Machine
        |— parallel gc ppt
        |— Oracle JDBC Memory Management
        |— NUMA-Aware-Java-Heaps-for-Server-Applications
        |— memorymanagement_whitepaper
        |— markcompact_gc ppt
        |— Leak Pruning
        |— GC Vs Explicit MM
        |— GC Tuning in the hotspot
        |— Garbage Collection and Memory Architecture
        |— Garbage Collection Algorithms For Automatic Dynamic Memory Management – Richard Jones
        |— [ Hotspot GC论文 ]
              |— Parallel Garbage Collection for Shared Memory Multiprocessors
              |— Garbage First Garbage Collector
              |— A Generational Mostly-concurrent Garbage Collector
        |— [ 其他JVM GC ]
              |— The pauseless gc
              |— Immix A Mark-Region Garbage Collector
              |— How to write a distributed gc
              |— GC Nirvana High Throughput And Low Latency Together
  |— [ monitoring and profiling ]
        |— Where Does All the Native Memory Go
        |— What’s Happening with My Application JVM Monitoring Tool
        |— Practical Lessons in Memory Analysis
        |— MonitoringGuide
        |— Microarchitectural Characterization of Production JVMs and JavaWorkloads
        |— Going Beyond Memory Leaks Debugging Java from Dumps, Using Memory Analyzer
        |— Diagnosing and Fixing Memory Leaks in Web Applications Tips from the Front Line
  |— [ osrelated ]
        |— poll-epoll_2
        |— poll-epoll_1
        |— memory systems
        |— Linux内核源代码情景分析
        |— linux_cpu_scheduler
        |— Linux 内核中断内幕
        |— Linux System and Performance Monitoring
        |— cpumemory
  |— [ performance ]
        |— Towards Performance Measurements for the Java Virtual Machine’s invokedynamic
        |— Thinking clearly about performance
        |— The Impact of Performance Asymmetry in Emerging Multicore Architectures
        |— the art of benchmarking
        |— Techniques for Obtaining High Performance in Java Programs
        |— Pipelining for Performance
        |— Performance myths and legends
        |— Performance Java Versus C
        |— How to Tune and Write Low-Latency Applications on the Java Virtual Machine
        |— How to Get the Most Performance from Sun JVM on Intel? Multi-Core Servers
        |— Comparing the Performance of Web Server Arch
        |— A Common API for Measuring Performance</p>
<p><a href="https://blog.bluedavy.com/?p=185" target="_blank">BTrace使用简介</a> <a href="https://blog.bluedavy.com/?p=198" target="_blank">JRockit读书笔记I — Java代码的高效执行</a></p>
<h3 id="15-comments-add-yours-">15 Comments <em>(<a href="">+add yours?</a>)</em></h3>
<ol>
<li><img src="https://secure.gravatar.com/avatar/e7a7df93e0364af10fd5bd942fd81f56?s=48&amp;d=&lt;path_to_url&gt;&amp;r=G" alt=""> <a href="http://blog.csdn.net/yang_net" target="_blank">yangwm</a>
<strong>Nov 16, 2010</strong> @ 20:34:17
顶！</li>
<li><img src="" alt=""> <a href="http://www.helishi.net/" target="_blank">ikbear</a>
<strong>Nov 16, 2010</strong> @ 21:29:26
顶！收藏了！</li>
<li><img src="https://secure.gravatar.com/avatar/37e14c958f24c5d75fb4dd926c175629?s=48&amp;d=&lt;path_to_url&gt;&amp;r=G" alt=""> <a href="http://www.ximengbao365.info/" target="_blank">ximengbao</a>
<strong>Nov 27, 2010</strong> @ 17:01:53
没人留言么 那我留一句</li>
<li><img src="https://secure.gravatar.com/avatar/d2b47d707d59207554e65aa3d3f83d18?s=48&amp;d=&lt;path_to_url&gt;&amp;r=G" alt=""> alipay_fred
<strong>Dec 03, 2010</strong> @ 20:17:48
Bohem GC 还是值得一开</li>
</ol>
<p>另外richard Jones 明年有本新书 关于GC的 期待中。。。</p>
<p>另外 今年ISMM 2011 的一些会议论文也很 insightfull</p>
<ol>
<li><img src="https://secure.gravatar.com/avatar/5267242305332fe1affd9c4788191e1d?s=48&amp;d=&lt;path_to_url&gt;&amp;r=G" alt=""> <a href="http://bluedavy.com/" target="_blank">bluedavy</a>
<strong>Dec 04, 2010</strong> @ 21:51:35
恩，感谢建议，:)</li>
<li><img src="https://secure.gravatar.com/avatar/3a190f857aef4c178e77fd9c499ba648?s=48&amp;d=&lt;path_to_url&gt;&amp;r=G" alt=""> <a href="http://www.ruyan.info/" target="_blank">如烟</a>
<strong>Dec 20, 2010</strong> @ 22:40:44
搜索过来的，这个还是挺有帮助的，谢了</li>
<li><img src="" alt=""> jilen
<strong>Jan 01, 2011</strong> @ 22:23:49
给力啊，毕玄同学</li>
<li><img src="https://secure.gravatar.com/avatar/5e07c82e4b00ec8fa41e753e43b90d97?s=48&amp;d=&lt;path_to_url&gt;&amp;r=G" alt=""> clark
<strong>Feb 11, 2011</strong> @ 14:39:54
楼主同学你好厉害啊，对于我们一般人，这些书都看完，人会不会翘掉？？</li>
<li><img src="https://secure.gravatar.com/avatar/5267242305332fe1affd9c4788191e1d?s=48&amp;d=&lt;path_to_url&gt;&amp;r=G" alt=""> <a href="http://bluedavy.com/" target="_blank">bluedavy</a>
<strong>Feb 15, 2011</strong> @ 21:34:00
哈哈，只要有兴趣，看完应该还是正常滴…</li>
<li><img src="https://secure.gravatar.com/avatar/d7159b92ad12edacca5f2a922957ec17?s=48&amp;d=&lt;path_to_url&gt;&amp;r=G" alt=""> lorb
<strong>Mar 22, 2011</strong> @ 11:28:05
赞，发现好多博客的参考链接都指到这儿
在国内这么浮躁的技术氛围中的一方净土，偶像ORZ
JVM相关的中文书籍太少，能否写一本</li>
<li><img src="https://secure.gravatar.com/avatar/aca8bd25b6ab38864dc63502766e357f?s=48&amp;d=&lt;path_to_url&gt;&amp;r=G" alt=""> milo
<strong>Jun 09, 2011</strong> @ 23:18:15
大侠，请教一个很弱智的问题，最近jboss老出现：java.lang.OutOfMemoryError: nativeGetNewTLA 错误，我想请问 nativeGetNewTLA 有什么含义，因为当我看到java.lang.OutOfMemoryError: allocLargeObjectOrArray 时，根据allocLargeObjectOrArray可大概知道是在堆上为大对象或数组对象分配空间时内存不够了，所以我想nativeGetNewTLA 应该能告诉我点什么。google 上看了很多，不理想，想请教你，另外有没有什么文档对这个OutOfMemoryError错误的各种message做个大概的说明。</li>
<li><img src="https://secure.gravatar.com/avatar/5267242305332fe1affd9c4788191e1d?s=48&amp;d=&lt;path_to_url&gt;&amp;r=G" alt=""> <a href="http://bluedavy.com/" target="_blank">bluedavy</a>
<strong>Jun 10, 2011</strong> @ 11:57:18
…这是java crash后出现的错误信息吧？
也许可以看看这个里面关于OOM的说明：<a href="http://blog.bluedavy.com/?p=200" target="_blank">http://blog.bluedavy.com/?p=200</a></li>
<li><img src="https://secure.gravatar.com/avatar/54e62b72074a55e9e404bfabb9217386?s=48&amp;d=&lt;path_to_url&gt;&amp;r=G" alt=""> cheto
<strong>Aug 18, 2011</strong> @ 13:05:15
JRocket The Definite Guide 这一类原版书要怎么才能买到？是不是要代购啊</li>
<li><img src="https://secure.gravatar.com/avatar/5267242305332fe1affd9c4788191e1d?s=48&amp;d=&lt;path_to_url&gt;&amp;r=G" alt=""> <a href="http://bluedavy.com/" target="_blank">bluedavy</a>
<strong>Aug 18, 2011</strong> @ 20:30:29
@cheto，恩，是滴，在国内没有引入影像版前，就只有代购了，或者买电子版吧。<h3 id="leave-a-reply">Leave a Reply</h3>
</li>
</ol>
<p><a href="">Cancel</a></p>
<p>Name (required)</p>
<p>Mail (required)</p>
<p>Website</p>
<p><img src="&quot;CAPTCHA Image&quot;" alt="CAPTCHA Image"></p>
<p><a href="&quot;Refresh Image&quot;"><img src="" alt="Refresh Image"></a></p>
<p>CAPTCHA Code /*</p>
<p><style type='text/css'>/#submit {display:none;}</style><br /> <input name="submit" type="submit" id="submit-alt" tabindex="6" value="Submit Comment" /></p>
<p>July 2013 M T W T F S S <a href="https://blog.bluedavy.com/?m=201303" title="View posts for March 2013" target="_blank">« Mar</a>     1234567 891011121314 15161718192021 22232425262728 293031  </p>
<h3 id="categories">Categories</h3>
<ul>
<li><a href="https://blog.bluedavy.com/?cat=63" title="View all posts filed under Java" target="_blank">Java</a> (10)</li>
<li><a href="https://blog.bluedavy.com/?cat=13" title="View all posts filed under jvm" target="_blank">jvm</a> (19)</li>
<li><a href="https://blog.bluedavy.com/?cat=56" title="View all posts filed under NoSQL" target="_blank">NoSQL</a> (7)</li>
<li><a href="https://blog.bluedavy.com/?cat=4" title="View all posts filed under SOA" target="_blank">SOA</a> (1)</li>
<li><a href="https://blog.bluedavy.com/?cat=11" title="关于《分布式Java应用：基础与实践》书部分章节的公开、书内容的纠错以及补充完善。" target="_blank">书:分布式Java应用</a> (5)</li>
<li><a href="https://blog.bluedavy.com/?cat=6" title="View all posts filed under 互联网" target="_blank">互联网</a> (5)</li>
<li><a href="https://blog.bluedavy.com/?cat=46" title="View all posts filed under 产品总结" target="_blank">产品总结</a> (1)</li>
<li><a href="https://blog.bluedavy.com/?cat=18" title="View all posts filed under 优化案例" target="_blank">优化案例</a> (1)</li>
<li><a href="https://blog.bluedavy.com/?cat=12" title="View all posts filed under 圆桌交流" target="_blank">圆桌交流</a> (2)</li>
<li><a href="https://blog.bluedavy.com/?cat=8" title="View all posts filed under 容量规划" target="_blank">容量规划</a> (2)</li>
<li><a href="https://blog.bluedavy.com/?cat=97" title="View all posts filed under 迁户口" target="_blank">迁户口</a> (1)</li>
<li><a href="https://blog.bluedavy.com/?cat=52" title="View all posts filed under 高可用" target="_blank">高可用</a> (1)</li>
<li><a href="https://blog.bluedavy.com/?cat=3" title="View all posts filed under 高并发" target="_blank">高并发</a> (3)</li>
<li><p><a href="https://blog.bluedavy.com/?cat=1" title="关于性能优化方面的一些东西。" target="_blank">高性能</a> (2)</p>
<h3 id="recent-comments">Recent Comments</h3>
</li>
<li><p><a href="http://code1.riaos.com/?p=5030138" target="_blank">JVM调优 | code1（code1.riaos.com）</a> on <a href="https://blog.bluedavy.com/?p=70&amp;cpage=1#comment-16520" target="_blank">说说MaxTenuringThreshold这个参数</a></p>
</li>
<li><a href="http://architecture1.riaos.com/?p=3063358" target="_blank">JVM调优 | architecture（riaos.com）</a> on <a href="https://blog.bluedavy.com/?p=70&amp;cpage=1#comment-16519" target="_blank">说说MaxTenuringThreshold这个参数</a></li>
<li><a href="http://bluedavy.com/" target="_blank">bluedavy</a> on <a href="https://blog.bluedavy.com/?p=409&amp;cpage=1#comment-16462" target="_blank">一个Java应用频繁抛异常导致cpu us诡异现象的案例</a></li>
<li>xiaobo on <a href="https://blog.bluedavy.com/?p=409&amp;cpage=1#comment-16460" target="_blank">一个Java应用频繁抛异常导致cpu us诡异现象的案例</a></li>
<li><a href="http://bluedavy.com/" target="_blank">bluedavy</a> on <a href="https://blog.bluedavy.com/?p=409&amp;cpage=1#comment-16459" target="_blank">一个Java应用频繁抛异常导致cpu us诡异现象的案例</a></li>
</ul>
<h3 id="tags">Tags</h3>
<p><a href="https://blog.bluedavy.com/?tag=btrace" title="2 topics" target="_blank">btrace</a> <a href="https://blog.bluedavy.com/?tag=c1" title="1 topic" target="_blank">c1</a> <a href="https://blog.bluedavy.com/?tag=c2" title="1 topic" target="_blank">c2</a> <a href="https://blog.bluedavy.com/?tag=deflater" title="1 topic" target="_blank">Deflater</a> <a href="https://blog.bluedavy.com/?tag=facebook" title="2 topics" target="_blank">facebook</a> <a href="https://blog.bluedavy.com/?tag=gc" title="4 topics" target="_blank">gc</a> <a href="https://blog.bluedavy.com/?tag=gc-tuning" title="2 topics" target="_blank">gc tuning</a> <a href="https://blog.bluedavy.com/?tag=grizzly" title="2 topics" target="_blank">Grizzly</a> <a href="https://blog.bluedavy.com/?tag=hbase" title="6 topics" target="_blank">HBase</a> <a href="https://blog.bluedavy.com/?tag=hotspot" title="1 topic" target="_blank">hotspot</a> <a href="https://blog.bluedavy.com/?tag=inflater" title="1 topic" target="_blank">Inflater</a> <a href="https://blog.bluedavy.com/?tag=interpreter" title="1 topic" target="_blank">interpreter</a> <a href="https://blog.bluedavy.com/?tag=javac" title="1 topic" target="_blank">javac</a> <a href="https://blog.bluedavy.com/?tag=java-code-generation" title="1 topic" target="_blank">java code generation</a> <a href="https://blog.bluedavy.com/?tag=javaone" title="4 topics" target="_blank">JavaOne</a> <a href="https://blog.bluedavy.com/?tag=javaone-general-technical-session" title="1 topic" target="_blank">javaone general technical session</a> <a href="https://blog.bluedavy.com/?tag=java%e4%bb%a3%e7%a0%81%e6%89%a7%e8%a1%8c" title="1 topic" target="_blank">java代码执行</a> <a href="https://blog.bluedavy.com/?tag=java-%e5%b9%b6%e5%8f%91" title="1 topic" target="_blank">Java 并发</a> <a href="https://blog.bluedavy.com/?tag=jit" title="1 topic" target="_blank">jit</a> <a href="https://blog.bluedavy.com/?tag=jvm" title="12 topics" target="_blank">jvm</a> <a href="https://blog.bluedavy.com/?tag=memory-management" title="1 topic" target="_blank">memory management</a> <a href="https://blog.bluedavy.com/?tag=native-memory-leak" title="1 topic" target="_blank">Native Memory Leak</a> <a href="https://blog.bluedavy.com/?tag=nosql" title="2 topics" target="_blank">NoSQL</a> <a href="https://blog.bluedavy.com/?tag=oom" title="1 topic" target="_blank">oom</a> <a href="https://blog.bluedavy.com/?tag=oracle-keynote" title="1 topic" target="_blank">oracle keynote</a> <a href="https://blog.bluedavy.com/?tag=pessimism-policy" title="1 topic" target="_blank">pessimism policy</a> <a href="https://blog.bluedavy.com/?tag=references" title="1 topic" target="_blank">references</a> <a href="https://blog.bluedavy.com/?tag=rpc" title="2 topics" target="_blank">RPC</a> <a href="https://blog.bluedavy.com/?tag=serial-gc" title="1 topic" target="_blank">serial gc</a> <a href="https://blog.bluedavy.com/?tag=soa" title="2 topics" target="_blank">SOA</a> <a href="https://blog.bluedavy.com/?tag=sun-jdk" title="1 topic" target="_blank">sun jdk</a> <a href="https://blog.bluedavy.com/?tag=sun-jdk-oom" title="1 topic" target="_blank">sun jdk oom</a> <a href="https://blog.bluedavy.com/?tag=web%e5%ae%b9%e9%87%8f%e8%a7%84%e5%88%92%e7%9a%84%e8%89%ba%e6%9c%af" title="1 topic" target="_blank">Web容量规划的艺术</a> <a href="https://blog.bluedavy.com/?tag=yuanzhuo" title="1 topic" target="_blank">yuanzhuo</a> <a href="https://blog.bluedavy.com/?tag=%e4%b9%a6" title="1 topic" target="_blank">书:分布式Java应用</a> <a href="https://blog.bluedavy.com/?tag=%e4%b9%a6%e8%af%84" title="1 topic" target="_blank">书评</a> <a href="https://blog.bluedavy.com/?tag=%e4%ba%92%e8%81%94%e7%bd%91%e6%8a%80%e6%9c%af" title="1 topic" target="_blank">互联网技术</a> <a href="https://blog.bluedavy.com/?tag=%e4%ba%a4%e6%b5%81" title="1 topic" target="_blank">交流</a> <a href="https://blog.bluedavy.com/?tag=%e5%86%85%e5%ad%98%e7%ae%a1%e7%90%86" title="1 topic" target="_blank">内存管理</a> <a href="https://blog.bluedavy.com/?tag=%e5%88%86%e5%b8%83%e5%bc%8fjava%e5%ba%94%e7%94%a8" title="2 topics" target="_blank">分布式Java应用</a> <a href="https://blog.bluedavy.com/?tag=%e5%9c%86%e6%a1%8c%e4%ba%a4%e6%b5%81" title="1 topic" target="_blank">圆桌交流</a> <a href="https://blog.bluedavy.com/?tag=%e5%ae%b9%e9%87%8f%e8%a7%84%e5%88%92" title="2 topics" target="_blank">容量规划</a> <a href="https://blog.bluedavy.com/?tag=%e6%82%b2%e8%a7%82%e7%ad%96%e7%95%a5" title="3 topics" target="_blank">悲观策略</a> <a href="https://blog.bluedavy.com/?tag=%e6%9c%8d%e5%8a%a1%e6%a1%86%e6%9e%b6" title="1 topic" target="_blank">服务框架</a> <a href="https://blog.bluedavy.com/?tag=%e7%a1%85%e8%b0%b7%e5%85%ac%e5%8f%b8" title="1 topic" target="_blank">硅谷公司</a></p>
<h3 id="-">订阅</h3>
<h3 id="-">推荐书籍</h3>
<h3 id="my-book">My Book</h3>
<p><a href="http://book.douban.com/subject/4848587/" title="分布式Java应用：基础与实践" target="_blank"><img src="" alt=""></a> <a href="http://book.douban.com/subject/3843896/" title="OSGi原理与最佳实践" target="_blank"><img src="" alt=""></a>
© <a href="https://blog.bluedavy.com/" target="_blank">BlueDavy之技术blog</a> 2013</p>
<p><a href="http://icondock.com/" target="_blank">Icons</a> &amp; <a href="http://www.ndesign-studio.com/wp-themes" target="_blank">Wordpress Theme</a> by <a href="http://www.ndesign-studio.com/" target="_blank">N.Design</a></p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/JVM/">JVM</a></li></span></span> | <span class="tags">Tagged <a href="/tags/JVM/" class="label label-primary">JVM</a><a href="/tags/Java&J2EE/" class="label label-success">Java&J2EE</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:42"datetime="2014-03-07 09:54:42"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-JVM--学习JVM的References/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-JVM--学习JVM的References" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--深入理解JVM/">深入理解JVM</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:42.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--深入理解JVM/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-jvm">深入理解JVM</h1>
<p><strong>1 Java技术与Java虚拟机</strong></p>
<p>说起Java，人们首先想到的是Java编程语言，然而事实上，Java是一种技术，它由四方面组成: Java编程语言、Java类文件格式、Java虚拟机和Java应用程序接口(Java API)。它们的关系如下图所示：</p>
<p><img src="" alt=""></p>
<p>图1 Java四个方面的关系</p>
<p>运行期环境代表着Java平台，开发人员编写Java代码(.java文件)，然后将之编译成字节码(.class文件)。最后字节码被装入内存，一旦字节码进入虚拟机，它就会被解释器解释执行，或者是被即时代码发生器有选择的转换成机器码执行。从上图也可以看出Java平台由Java虚拟机和 Java应用程序接口搭建，Java语言则是进入这个平台的通道，用Java语言编写并编译的程序可以运行在这个平台上。这个平台的结构如下图所示：</p>
<p><img src="" alt=""></p>
<p>在Java平台的结构中, 可以看出，Java虚拟机(JVM) 处在核心的位置，是程序与底层操作系统和硬件无关的关键。它的下方是移植接口，移植接口由两部分组成：适配器和Java操作系统, 其中依赖于平台的部分称为适配器；JVM 通过移植接口在具体的平台和操作系统上实现；在JVM 的上方是Java的基本类库和扩展类库以及它们的API， 利用Java API编写的应用程序(application) 和小程序(Java applet) 可以在任何Java平台上运行而无需考虑底层平台, 就是因为有Java虚拟机(JVM)实现了程序与操作系统的分离，从而实现了Java 的平台无关性。</p>
<p>那么到底什么是Java虚拟机(JVM)呢？通常我们谈论JVM时，我们的意思可能是：</p>
<ol>
<li><p>对JVM规范的的比较抽象的说明；</p>
</li>
<li><p>对JVM的具体实现；</p>
</li>
<li><p>在程序运行期间所生成的一个JVM实例。</p>
</li>
</ol>
<p>对JVM规范的的抽象说明是一些概念的集合，它们已经在书《The Java Virtual Machine Specification》（《Java虚拟机规范》）中被详细地描述了；对JVM的具体实现要么是软件，要么是软件和硬件的组合，它已经被许多生产厂商所实现，并存在于多种平台之上；运行Java程序的任务由JVM的运行期实例单个承担。在本文中我们所讨论的Java虚拟机(JVM)主要针对第三种情况而言。它可以被看成一个想象中的机器，在实际的计算机上通过软件模拟来实现，有自己想象中的硬件，如处理器、堆栈、寄存器等，还有自己相应的指令系统。</p>
<p>JVM在它的生存周期中有一个明确的任务，那就是运行Java程序，因此当Java程序启动的时候，就产生JVM的一个实例；当程序运行结束的时候，该实例也跟着消失了。下面我们从JVM的体系结构和它的运行过程这两个方面来对它进行比较深入的研究。</p>
<p><strong>2 Java虚拟机的体系结构</strong></p>
<p>刚才已经提到，JVM可以由不同的厂商来实现。由于厂商的不同必然导致JVM在实现上的一些不同，然而JVM还是可以实现跨平台的特性，这就要归功于设计JVM时的体系结构了。</p>
<p>我们知道，一个JVM实例的行为不光是它自己的事，还涉及到它的子系统、存储区域、数据类型和指令这些部分，它们描述了JVM的一个抽象的内部体系结构，其目的不光规定实现JVM时它内部的体系结构，更重要的是提供了一种方式，用于严格定义实现时的外部行为。每个JVM都有两种机制，一个是装载具有合适名称的类(类或是接口)，叫做类装载子系统；另外的一个负责执行包含在已装载的类或接口中的指令，叫做运行引擎。每个JVM又包括方法区、堆、 Java栈、程序计数器和本地方法栈这五个部分，这几个部分和类装载机制与运行引擎机制一起组成的体系结构图为：</p>
<p><img src="" alt=""></p>
<p>图3 JVM的体系结构</p>
<p>JVM的每个实例都有一个它自己的方法域和一个堆，运行于JVM内的所有的线程都共享这些区域；当虚拟机装载类文件的时候，它解析其中的二进制数据所包含的类信息，并把它们放到方法域中；当程序运行的时候，JVM把程序初始化的所有对象置于堆上；而每个线程创建的时候，都会拥有自己的程序计数器和 Java栈，其中程序计数器中的值指向下一条即将被执行的指令，线程的Java栈则存储为该线程调用Java方法的状态；本地方法调用的状态被存储在本地方法栈，该方法栈依赖于具体的实现。</p>
<p>下面分别对这几个部分进行说明。</p>
<p>执行引擎处于JVM的核心位置，在Java虚拟机规范中，它的行为是由指令集所决定的。尽管对于每条指令，规范很详细地说明了当JVM执行字节码遇到指令时，它的实现应该做什么，但对于怎么做却言之甚少。Java虚拟机支持大约248个字节码。每个字节码执行一种基本的CPU运算,例如,把一个整数加到寄存器,子程序转移等。Java指令集相当于Java程序的汇编语言。</p>
<p>Java指令集中的指令包含一个单字节的操作符,用于指定要执行的操作,还有0个或多个操作数,提供操作所需的参数或数据。许多指令没有操作数,仅由一个单字节的操作符构成。</p>
<p>虚拟机的内层循环的执行过程如下:</p>
<p>do{</p>
<p>取一个操作符字节;</p>
<p>根据操作符的值执行一个动作;</p>
<p>}while(程序未结束)</p>
<p>由于指令系统的简单性,使得虚拟机执行的过程十分简单,从而有利于提高执行的效率。指令中操作数的数量和大小是由操作符决定的。如果操作数比一个字节大,那么它存储的顺序是高位字节优先。例如,一个16位的参数存放时占用两个字节,其值为:</p>
<p>第一个字节/*256+第二个字节字节码。</p>
<p>指令流一般只是字节对齐的。指令tableswitch和lookup是例外,在这两条指令内部要求强制的4字节边界对齐。</p>
<p>对于本地方法接口，实现JVM并不要求一定要有它的支持，甚至可以完全没有。Sun公司实现Java本地接口(JNI)是出于可移植性的考虑，当然我们也可以设计出其它的本地接口来代替Sun公司的JNI。但是这些设计与实现是比较复杂的事情，需要确保垃圾回收器不会将那些正在被本地方法调用的对象释放掉。</p>
<p>Java的堆是一个运行时数据区,类的实例(对象)从中分配空间，它的管理是由垃圾回收来负责的:不给程序员显式释放对象的能力。Java不规定具体使用的垃圾回收算法,可以根据系统的需求使用各种各样的算法。</p>
<p>Java方法区与传统语言中的编译后代码或是Unix进程中的正文段类似。它保存方法代码(编译后的java代码)和符号表。在当前的Java实现中,方法代码不包括在垃圾回收堆中,但计划在将来的版本中实现。每个类文件包含了一个Java类或一个Java界面的编译后的代码。可以说类文件是 Java语言的执行代码文件。为了保证类文件的平台无关性,Java虚拟机规范中对类文件的格式也作了详细的说明。其具体细节请参考Sun公司的Java 虚拟机规范。</p>
<p>Java虚拟机的寄存器用于保存机器的运行状态,与微处理器中的某些专用寄存器类似。Java虚拟机的寄存器有四种:</p>
<ol>
<li><p>pc: Java程序计数器；</p>
</li>
<li><p>optop: 指向操作数栈顶端的指针；</p>
</li>
<li><p>frame: 指向当前执行方法的执行环境的指针；</p>
</li>
<li><p>vars: 指向当前执行方法的局部变量区第一个变量的指针。</p>
</li>
</ol>
<p>在上述体系结构图中，我们所说的是第一种，即程序计数器，每个线程一旦被创建就拥有了自己的程序计数器。当线程执行Java方法的时候，它包含该线程正在被执行的指令的地址。但是若线程执行的是一个本地的方法，那么程序计数器的值就不会被定义。</p>
<p>Java虚拟机的栈有三个区域:局部变量区、运行环境区、操作数区。</p>
<p><strong>局部变量区</strong></p>
<p>每个Java方法使用一个固定大小的局部变量集。它们按照与vars寄存器的字偏移量来寻址。局部变量都是32位的。长整数和双精度浮点数占据了两个局部变量的空间,却按照第一个局部变量的索引来寻址。(例如,一个具有索引n的局部变量,如果是一个双精度浮点数,那么它实际占据了索引n和n+1所代表的存储空间)虚拟机规范并不要求在局部变量中的64位的值是64位对齐的。虚拟机提供了把局部变量中的值装载到操作数栈的指令,也提供了把操作数栈中的值写入局部变量的指令。</p>
<p><strong>运行环境区</strong></p>
<p>在运行环境中包含的信息用于动态链接,正常的方法返回以及异常捕捉。</p>
<p><strong>动态链接</strong></p>
<p>运行环境包括对指向当前类和当前方法的解释器符号表的指针,用于支持方法代码的动态链接。方法的class文件代码在引用要调用的方法和要访问的变量时使用符号。动态链接把符号形式的方法调用翻译成实际方法调用,装载必要的类以解释还没有定义的符号,并把变量访问翻译成与这些变量运行时的存储结构相应的偏移地址。动态链接方法和变量使得方法中使用的其它类的变化不会影响到本程序的代码。</p>
<p><strong>正常的方法返回</strong></p>
<p>如果当前方法正常地结束了,在执行了一条具有正确类型的返回指令时,调用的方法会得到一个返回值。执行环境在正常返回的情况下用于恢复调用者的寄存器,并把调用者的程序计数器增加一个恰当的数值,以跳过已执行过的方法调用指令,然后在调用者的执行环境中继续执行下去。</p>
<p><strong>异常捕捉</strong></p>
<p>异常情况在Java中被称作Error(错误)或Exception(异常),是Throwable类的子类,在程序中的原因是:①动态链接错,如无法找到所需的class文件。②运行时错,如对一个空指针的引用。程序使用了throw语句。</p>
<p>当异常发生时,Java虚拟机采取如下措施:</p>
<p>· 检查与当前方法相联系的catch子句表。每个catch子句包含其有效指令范围,能够处理的异常类型,以及处理异常的代码块地址。</p>
<p>· 与异常相匹配的catch子句应该符合下面的条件:造成异常的指令在其指令范围之内,发生的异常类型是其能处理的异常类型的子类型。如果找到了匹配的catch子句,那么系统转移到指定的异常处理块处执行;如果没有找到异常处理块,重复寻找匹配的catch子句的过程,直到当前方法的所有嵌套的 catch子句都被检查过。</p>
<p>· 由于虚拟机从第一个匹配的catch子句处继续执行,所以catch子句表中的顺序是很重要的。因为Java代码是结构化的,因此总可以把某个方法的所有的异常处理器都按序排列到一个表中,对任意可能的程序计数器的值,都可以用线性的顺序找到合适的异常处理块,以处理在该程序计数器值下发生的异常情况。</p>
<p>· 如果找不到匹配的catch子句,那么当前方法得到一个&quot;未截获异常&quot;的结果并返回到当前方法的调用者,好像异常刚刚在其调用者中发生一样。如果在调用者中仍然没有找到相应的异常处理块,那么这种错误将被传播下去。如果错误被传播到最顶层,那么系统将调用一个缺省的异常处理块。</p>
<p><strong>操作数栈区</strong></p>
<p>机器指令只从操作数栈中取操作数,对它们进行操作,并把结果返回到栈中。选择栈结构的原因是:在只有少量寄存器或非通用寄存器的机器(如 Intel486)上,也能够高效地模拟虚拟机的行为。操作数栈是32位的。它用于给方法传递参数,并从方法接收结果,也用于支持操作的参数,并保存操作的结果。例如,iadd指令将两个整数相加。相加的两个整数应该是操作数栈顶的两个字。这两个字是由先前的指令压进堆栈的。这两个整数将从堆栈弹出、相加,并把结果压回到操作数栈中。</p>
<p>每个原始数据类型都有专门的指令对它们进行必须的操作。每个操作数在栈中需要一个存储位置,除了long和double型,它们需要两个位置。操作数只能被适用于其类型的操作符所操作。例如,压入两个int类型的数,如果把它们当作是一个long类型的数则是非法的。在Sun的虚拟机实现中,这个限制由字节码验证器强制实行。但是,有少数操作(操作符dupe和swap),用于对运行时数据区进行操作时是不考虑类型的。</p>
<p>本地方法栈，当一个线程调用本地方法时，它就不再受到虚拟机关于结构和安全限制方面的约束，它既可以访问虚拟机的运行期数据区，也可以使用本地处理器以及任何类型的栈。例如，本地栈是一个C语言的栈，那么当C程序调用C函数时，函数的参数以某种顺序被压入栈，结果则返回给调用函数。在实现Java虚拟机时，本地方法接口使用的是C语言的模型栈，那么它的本地方法栈的调度与使用则完全与C语言的栈相同。</p>
<p><strong>3 Java虚拟机的运行过程</strong></p>
<p>上面对虚拟机的各个部分进行了比较详细的说明，下面通过一个具体的例子来分析它的运行过程。</p>
<p>虚拟机通过调用某个指定类的方法main启动，传递给main一个字符串数组参数，使指定的类被装载，同时链接该类所使用的其它的类型，并且初始化它们。例如对于程序：</p>
<p>class HelloApp</p>
<p>{</p>
<p>public static void main(String[] args)</p>
<p>{</p>
<p>System.out.println(&quot;Hello World!&quot;);</p>
<p>for (int i = 0; i &lt; args.length; i++ )</p>
<p>{</p>
<p>System.out.println(args[i]);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>编译后在命令行模式下键入： java HelloApp run virtual machine</p>
<p>将通过调用HelloApp的方法main来启动java虚拟机，传递给main一个包含三个字符串&quot;run&quot;、&quot;virtual&quot;、&quot;machine&quot;的数组。现在我们略述虚拟机在执行HelloApp时可能采取的步骤。</p>
<p>开始试图执行类HelloApp的main方法，发现该类并没有被装载，也就是说虚拟机当前不包含该类的二进制代表，于是虚拟机使用 ClassLoader试图寻找这样的二进制代表。如果这个进程失败，则抛出一个异常。类被装载后同时在main方法被调用之前，必须对类 HelloApp与其它类型进行链接然后初始化。链接包含三个阶段：检验，准备和解析。检验检查被装载的主类的符号和语义，准备则创建类或接口的静态域以及把这些域初始化为标准的默认值，解析负责检查主类对其它类或接口的符号引用，在这一步它是可选的。类的初始化是对类中声明的静态初始化函数和静态域的初始化构造方法的执行。一个类在初始化之前它的父类必须被初始化。整个过程如下：
<img src="" alt=""></p>
<p>图4：虚拟机的运行过程</p>
<p><strong>4 结束语</strong></p>
<p>本文通过对JVM的体系结构的深入研究以及一个Java程序执行时虚拟机的运行过程的详细分析，意在剖析清楚Java虚拟机的机理。</p>
<h1 id="-jvm-http-www-javaeye-com-wiki-jvm-2905-jvm-"><a href=""></a><a href="http://www.javaeye.com/wiki/jvm/2905-JVM">慢慢琢磨JVM</a></h1>
<h2 id="-1-jvm-"><a href=""></a>1 JVM简介</h2>
<p>JVM是我们Javaer的最基本功底了，刚开始学Java的时候，一般都是从“Hello World”开始的，然后会写个复杂点class，然后再找一些开源框架，比如Spring，Hibernate等等，再然后就开发企业级的应用，比如网站、企业内部应用、实时交易系统等等，直到某一天突然发现做的系统咋就这么慢呢，而且时不时还来个内存溢出什么的，今天是交易系统报了StackOverflowError，明天是网站系统报了个OutOfMemoryError，这种错误又很难重现，只有分析Javacore和dump文件，运气好点还能分析出个结果，运行遭的点，就直接去庙里烧香吧！每天接客户的电话都是战战兢兢的，生怕再出什么幺蛾子了。我想Java做的久一点的都有这样的经历，那这些问题的最终根结是在哪呢？—— JVM。</p>
<p>JVM全称是Java VirtualMachine，Java虚拟机，也就是在计算机上再虚拟一个计算机，这和我们使用 VMWare不一样，那个虚拟的东西你是可以看到的，这个JVM你是看不到的，它存在内存中。我们知道计算机的基本构成是：运算器、控制器、存储器、输入和输出设备，那这个JVM也是有这成套的元素，运算器是当然是交给硬件CPU还处理了，只是为了适应“一次编译，随处运行”的情况，需要做一个翻译动作，于是就用了JVM自己的命令集，这与汇编的命令集有点类似，每一种汇编命令集针对一个系列的CPU，比如8086系列的汇编也是可以用在8088上的，但是就不能跑在8051上，而JVM的命令集则是可以到处运行的，因为JVM做了翻译，根据不同的CPU，翻译成不同的机器语言。</p>
<p>JVM中我们最需要深入理解的就是它的存储部分，存储？硬盘？NO，NO，JVM是一个内存中的虚拟机，那它的存储就是内存了，我们写的所有类、常量、变量、方法都在内存中，这决定着我们程序运行的是否健壮、是否高效，接下来的部分就是重点介绍之。</p>
<h2 id="-2-jvm-"><a href=""></a>2 JVM的组成部分</h2>
<p>我们先把JVM这个虚拟机画出来，如下图所示：</p>
<p><img src="" alt=""></p>
<p>从这个图中可以看到，JVM是运行在操作系统之上的，它与硬件没有直接的交互。我们再来看下JVM有哪些组成部分，如下图所示：
<img src="" alt=""></p>
<p>该图参考了网上广为流传的JVM构成图，大家看这个图，整个JVM分为四部分：</p>
<p><strong>Class Loader类加载器</strong></p>
<p>类加载器的作用是加载类文件到内存，比如编写一个HelloWord.java程序，然后通过javac编译成class文件，那怎么才能加载到内存中被执行呢？Class Loader承担的就是这个责任，那不可能随便建立一个.class文件就能被加载的，Class Loader加载的class文件是有格式要求，在《JVM Specification》中式这样定义Class文件的结构：</p>
<p>ClassFile{</p>
<p>u4magic;</p>
<p>u2minor_version;</p>
<p>u2major_version;</p>
<p>u2constant_pool_count;</p>
<p>cp_infoconstant_pool[constant_pool_count-1];</p>
<p>u2access_flags;</p>
<p>u2this_class;</p>
<p>u2super_class;</p>
<p>u2interfaces_count;</p>
<p>u2interfaces[interfaces_count];</p>
<p>u2fields_count;</p>
<p>field_infofields[fields_count];</p>
<p>u2methods_count;</p>
<p>method_infomethods[methods_count];</p>
<p>u2attributes_count;</p>
<p>attribute_infoattributes[attributes_count];</p>
<p>}</p>
<p>需要详细了解的话，可以仔细阅读《JVM Specification》的第四章“The class File Format”，这里不再详细说明。</p>
<p>友情提示：Class Loader只管加载，只要符合文件结构就加载，至于说能不能运行，则不是它负责的，那是由Execution Engine负责的。</p>
<p><strong>Execution Engine执行引擎</strong></p>
<p>执行引擎也叫做解释器(Interpreter)，负责解释命令，提交操作系统执行。</p>
<p><strong>Native Interface本地接口</strong></p>
<p>本地接口的作用是融合不同的编程语言为Java所用，它的初衷是融合C/C++程序，Java诞生的时候是C/C++横行的时候，要想立足，必须有一个聪明的、睿智的调用C/C++程序，于是就在内存中专门开辟了一块区域处理标记为native的代码，它的具体做法是Native Method Stack中登记native方法，在Execution Engine执行时加载native libraies。目前该方法使用的是越来越少了，除非是与硬件有关的应用，比如通过Java程序驱动打印机，或者Java系统管理生产设备，在企业级应用中已经比较少见，因为现在的异构领域间的通信很发达，比如可以使用Socket通信，也可以使用Web Service等等，不多做介绍。</p>
<p><strong>Runtime data area运行数据区</strong></p>
<p>运行数据区是整个JVM的重点。我们所有写的程序都被加载到这里，之后才开始运行，Java生态系统如此的繁荣，得益于该区域的优良自治，下一章节详细介绍之。</p>
<p>整个JVM框架由加载器加载文件，然后执行器在内存中处理数据，需要与异构系统交互是可以通过本地接口进行，瞧，一个完整的系统诞生了！</p>
<h2 id="-2-jvm-"><a href=""></a>2 JVM的内存管理</h2>
<p>所有的数据和程序都是在运行数据区存放，它包括以下几部分：</p>
<p>q Stack 栈</p>
<p>栈也叫栈内存，是Java程序的运行区，是在线程创建时创建，它的生命期是跟随线程的生命期，线程结束栈内存也就释放，对于栈来说不存在垃圾回收问题，只要线程一结束，该栈就Over。问题出来了：栈中存的是那些数据呢？又什么是格式呢？</p>
<p>栈中的数据都是以栈帧（Stack Frame）的格式存在，栈帧是一个内存区块，是一个数据集，是一个有关方法(Method)和运行期数据的数据集，当一个方法A被调用时就产生了一个栈帧F1，并被压入到栈中，A方法又调用了B方法，于是产生栈帧F2也被压入栈，执行完毕后，先弹出F2栈帧，再弹出F1栈帧，遵循“先进后出”原则。</p>
<p>那栈帧中到底存在着什么数据呢？栈帧中主要保存3类数据：本地变量（LocalVariables），包括输入参数和输出参数以及方法内的变量；栈操作（Operand Stack），记录出栈、入栈的操作；栈帧数据（FrameData），包括类文件、方法等等。光说比较枯燥，我们画个图来理解一下Java栈，如下图所示：
<img src="" alt=""></p>
<p>图示在一个栈中有两个栈帧，栈帧2是最先被调用的方法，先入栈，然后方法2又调用了方法1，栈帧1处于栈顶的位置，栈帧2处于栈底，执行完毕后，依次弹出栈帧1和栈帧2，线程结束，栈释放。</p>
<p><strong>Heap堆内存</strong></p>
<p>一个JVM实例只存在一个堆类存，堆内存的大小是可以调节的。类加载器读取了类文件后，需要把类、方法、常变量放到堆内存中，以方便执行器执行，堆内存分为三部分：</p>
<p><strong>Permanent Space永久存储区</strong></p>
<p>永久存储区是一个常驻内存区域，用于存放JDK自身所携带的Class,Interface的元数据，也就是说它存储的是运行环境必须的类信息，被装载进此区域的数据是不会被垃圾回收器回收掉的，关闭JVM才会释放此区域所占用的内存。</p>
<p><strong>Young Generation Space 新生区</strong></p>
<p>新生区是类的诞生、成长、消亡的区域，一个类在这里产生，应用，最后被垃圾回收器收集，结束生命。新生区又分为两部分：伊甸区（Eden space）和幸存者区（Survivor pace），所有的类都是在伊甸区被new出来的。幸存区有两个：0区（Survivor 0 space）和1区（Survivor 1 space）。当伊甸园的空间用完时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园区进行垃圾回收，将伊甸园区中的不再被其他对象所引用的对象进行销毁。然后将伊甸园中的剩余对象移动到幸存0区。若幸存0区也满了，再对该区进行垃圾回收，然后移动到1区。那如果1区也满了呢？再移动到养老区。</p>
<p><strong>Tenure generation space养老区</strong></p>
<p>养老区用于保存从新生区筛选出来的JAVA对象，一般池对象都在这个区域活跃。三个区的示意图如下：
<img src="" alt=""></p>
<p><strong>Method Area 方法区</strong></p>
<p>方法区是被所有线程共享，该区域保存所有字段和方法字节码，以及一些特殊方法如构造函数，接口代码也在此定义。</p>
<p><strong>PC Register 程序计数器</strong></p>
<p>每个线程都有一个程序计数器，就是一个指针，指向方法区中的方法字节码，由执行引擎读取下一条指令。</p>
<p><strong>Native Method Stack 本地方法栈</strong></p>
<h2 id="-3-jvm-"><a href=""></a>3 JVM相关问题</h2>
<p><strong>问：堆和栈有什么区别</strong></p>
<p>答：堆是存放对象的，但是对象内的临时变量是存在栈内存中，如例子中的methodVar是在运行期存放到栈中的。</p>
<p>栈是跟随线程的，有线程就有栈，堆是跟随JVM的，有JVM就有堆内存。</p>
<p><strong>问：堆内存中到底存在着什么东西？</strong></p>
<p>答：对象，包括对象变量以及对象方法。</p>
<p><strong>问：类变量和实例变量有什么区别？</strong></p>
<p>答：静态变量是类变量，非静态变量是实例变量，直白的说，有static修饰的变量是静态变量，没有static修饰的变量是实例变量。静态变量存在方法区中，实例变量存在堆内存中。</p>
<p><strong>问：我听说类变量是在JVM启动时就初始化好的，和你这说的不同呀！</strong></p>
<p>答：那你是道听途说，信我的，没错。</p>
<p><strong>问：Java的方法（函数）到底是传值还是传址？</strong></p>
<p>答：都不是，是以传值的方式传递地址，具体的说原生数据类型传递的值，引用类型传递的地址。对于原始数据类型，JVM的处理方法是从Method Area或Heap中拷贝到Stack，然后运行frame中的方法，运行完毕后再把变量指拷贝回去。</p>
<p><strong>问：为什么会产生OutOfMemory产生？</strong></p>
<p>答：一句话：Heap内存中没有足够的可用内存了。这句话要好好理解，不是说Heap没有内存了，是说新申请内存的对象大于Heap空闲内存，比如现在Heap还空闲1M，但是新申请的内存需要1.1M，于是就会报OutOfMemory了，可能以后的对象申请的内存都只要0.9M，于是就只出现一次OutOfMemory，GC也正常了，看起来像偶发事件，就是这么回事。但如果此时GC没有回收就会产生挂起情况，系统不响应了。</p>
<p><strong>问：我产生的对象不多呀，为什么还会产生OutOfMemory？</strong></p>
<p>答：你继承层次忒多了，Heap中产生的对象是先产生父类，然后才产生子类，明白不？</p>
<p><strong>问：OutOfMemory错误分几种？</strong></p>
<p>答：分两种，分别是“OutOfMemoryError:java heap size”和”OutOfMemoryError: PermGen space”，两种都是内存溢出，heap size是说申请不到新的内存了，这个很常见，检查应用或调整堆内存大小。</p>
<p>“PermGen space”是因为永久存储区满了，这个也很常见，一般在热发布的环境中出现，是因为每次发布应用系统都不重启，久而久之永久存储区中的死对象太多导致新对象无法申请内存，一般重新启动一下即可。</p>
<p><strong>问：为什么会产生StackOverflowError？</strong></p>
<p>答：因为一个线程把Stack内存全部耗尽了，一般是递归函数造成的。</p>
<p><strong>问：一个机器上可以看多个JVM吗？JVM之间可以互访吗？</strong></p>
<p>答：可以多个JVM，只要机器承受得了。JVM之间是不可以互访，你不能在A-JVM中访问B-JVM的Heap内存，这是不可能的。在以前老版本的JVM中，会出现A-JVM Crack后影响到B-JVM，现在版本非常少见。</p>
<p><strong>问：为什么Java要采用垃圾回收机制，而不采用C/C++的显式内存管理？</strong></p>
<p>答：为了简单，内存管理不是每个程序员都能折腾好的。</p>
<p><strong>问：为什么你没有详细介绍垃圾回收机制？</strong></p>
<p>答：垃圾回收机制每个JVM都不同，JVM Specification只是定义了要自动释放内存，也就是说它只定义了垃圾回收的抽象方法，具体怎么实现各个厂商都不同，算法各异，这东西实在没必要深入。</p>
<p><strong>问：JVM中到底哪些区域是共享的？哪些是私有的？</strong></p>
<p>答：Heap和Method Area是共享的，其他都是私有的，</p>
<p><strong>问：什么是JIT，你怎么没说？</strong></p>
<p>答：JIT是指Just In Time，有的文档把JIT作为JVM的一个部件来介绍，有的是作为执行引擎的一部分来介绍，这都能理解。Java刚诞生的时候是一个解释性语言，别嘘，即使编译成了字节码（byte code）也是针对JVM的，它需要再次翻译成原生代码(native code)才能被机器执行，于是效率的担忧就提出来了。Sun为了解决该问题提出了一套新的机制，好，你想编译成原生代码，没问题，我在JVM上提供一个工具，把字节码编译成原生码，下次你来访问的时候直接访问原生码就成了，于是JIT就诞生了，就这么回事。</p>
<p><strong>问：JVM还有哪些部分是你没有提到的？</strong></p>
<p>答：JVM是一个异常复杂的东西，写一本砖头书都不为过，还有几个要说明的：</p>
<p>常量池（constant pool）：按照顺序存放程序中的常量，并且进行索引编号的区域。比如int i =100，这个100就放在常量池中。</p>
<p>安全管理器（Security Manager）：提供Java运行期的安全控制，防止恶意攻击，比如指定读取文件，写入文件权限，网络访问，创建进程等等，Class Loader在Security Manager认证通过后才能加载class文件的。</p>
<p>方法索引表（Methods table），记录的是每个method的地址信息，Stack和Heap中的地址指针其实是指向Methodstable地址。</p>
<p><strong>问：为什么不建议在程序中显式的生命System.gc()？</strong></p>
<p>答：因为显式声明是做堆内存全扫描，也就是Full GC，是需要停止所有的活动的（Stop The World Collection），你的应用能承受这个吗？</p>
<p><strong>问：JVM有哪些调整参数？</strong></p>
<p>答：非常多，自己去找，堆内存、栈内存的大小都可以定义，甚至是堆内存的三个部分、新生代的各个比例都能调整。</p>
<p>转载自：<a href="http://wenku.baidu.com/view/70e45e8ba0116c175f0e4840.html" target="_blank"><a href="http://wenku.baidu.com/view/70e45e8ba0116c175f0e4840.html">http://wenku.baidu.com/view/70e45e8ba0116c175f0e4840.html</a></a></p>
<p>来源： &lt;<a href="http://blog.csdn.net/chinajane163/article/details/7784521" target="_blank">深入理解JVM - ChinaJane163的专栏 - 博客频道 - CSDN.NET</a>&gt; </p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/JVM/">JVM</a></li></span></span> | <span class="tags">Tagged <a href="/tags/JVM/" class="label label-primary">JVM</a><a href="/tags/Java&J2EE/" class="label label-success">Java&J2EE</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:42"datetime="2014-03-07 09:54:42"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-JVM--深入理解JVM/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-JVM--深入理解JVM" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--虚拟机随谈（一）：解释器，树遍历解释器，基于栈与基于寄存器，大杂烩/">虚拟机随谈（一）：解释器，树遍历解释器，基于栈与基于寄存器，大杂烩</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:42.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--虚拟机随谈（一）：解释器，树遍历解释器，基于栈与基于寄存器，大杂烩/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-">虚拟机随谈（一）：解释器，树遍历解释器，基于栈与基于寄存器，大杂烩</h1>
<p>（Disclaimer：如果需要转载请先与我联系；文中图片请不要直接链接
作者：<a href="http://weibo.com/rednaxelafx" target="_blank">@RednaxelaFX</a> -&gt; <a href="http://rednaxelafx.iteye.com/" target="_blank"><a href="http://rednaxelafx.iteye.com">http://rednaxelafx.iteye.com</a></a>）
大前天收到一条PM：
引用</p>
<p>你好，很冒昧的向你发短消息，我现在在看JS引擎，能过看博客发现你对js engine很了解，我想请教一下你 基于栈的解析器与基于寄存器的解析器有什么同，javascriptcore是基于寄存器的，V8是基于栈的，能不能说一下这两者有什么一样吗？能推荐一点资料吗？谢谢。
我刚收到的时候很兴奋，就开始写回复。写啊写发觉已经比我平时发的帖还要长了，想着干脆把回复直接发出来好了。于是下面就是回复：
你好 ^ ^ 很抱歉拖了这么久才回复。码字和画图太耗时间了。
别说冒昧了，我只是个普通的刚毕业的学生而已，担当不起啊 =<em>=||||
而且我也不敢说“很”了解，只是有所接触而已。很高兴有人来一起讨论JavaScript引擎的设计与实现，总觉得身边对这个有兴趣的人不多，或者是很少冒出来讨论。如果你发个帖或者blog来讨论这方面的内容我也会很感兴趣的～
想拿出几点来讨论一下。上面提出的问题我希望能够一一给予回答，不过首先得做些铺垫。
另外先提一点：JavaScriptCore从SquirrelFish版开始是“基于寄存器”的，V8则不适合用“基于栈”或者“基于寄存器”的说法来描述。
<strong>1、解析器与解释器</strong>
解析器是parser，而解释器是interpreter。两者不是同一样东西，不应该混用。
前者是编译器/解释器的重要组成部分，也可以用在IDE之类的地方；其主要作用是进行语法分析，提取出句子的结构。广义来说输入一般是程序的源码，输出一般是语法树（syntax tree，也叫parse tree等）或抽象语法树（abstract syntax tree，AST）。进一步剥开来，广义的解析器里一般会有扫描器（scanner，也叫tokenizer或者lexical analyzer，词法分析器），以及狭义的解析器（parser，也叫syntax analyzer，语法分析器）。扫描器的输入一般是文本，经过词法分析，输出是将文本切割为单词的流。狭义的解析器输入是单词的流，经过语法分析，输出是语法树或者精简过的AST。
（在一些编译器/解释器中，解析也可能与后续的语义分析、代码生成或解释执行等步骤融合在一起，不一定真的会构造出完整的语法树。但概念上说解析器就是用来抽取句子结构用的，而语法树就是表示句子结构的方式。关于边解析边解释执行的例子，可以看看<a href="http://rednaxelafx.iteye.com/blog/472113" target="_blank">这帖</a>的计算器。）
举例：将i = a + b /* c作为源代码输入到解析器里，则广义上的解析器的工作流程如下图：
<img src="" alt="">
其中词法分析由扫描器完成，语法分析由狭义的解析器完成。
（嗯，说来其实“解析器”这词还是按狭义用法比较准确。把扫描器和解析器合起来叫解析器总觉得怪怪的，但不少人这么用，这里就将就下吧 =</em>=
不过近来“<a href="http://en.wikipedia.org/wiki/Scannerless_parsing" target="_blank">scannerless parsing</a>”也挺流行的：不区分词法分析与语法分析，没有单独的扫描器，直接用解析器从源码生成语法树。这倒整个就是解析器了，没狭不狭义的问题）
后者则是实现程序执行的一种实现方式，与编译器相对。它直接实现程序源码的语义，输入是程序源码，输出则是执行源码得到的计算结果；编译器的输入与解释器相同，而输出是用别的语言实现了输入源码的语义的程序。通常编译器的输入语言比输出语言高级，但不一定；也有输入输出是同种语言的情况，此时编译器很可能主要用于优化代码。
举例：把同样的源码分别输入到编译器与解释器中，得到的输出不同：
<img src="" alt="">
值得留意的是，编译器生成出来的代码执行后的结果应该跟解释器输出的结果一样——它们都应该实现源码所指定的语义。
在很多地方都看到解析器与解释器两个不同的东西被混为一谈，感到十分无奈。
最近某本引起很多关注的书便在开篇给读者们当头一棒，介绍了“<a href="http://www.fecit.com.cn/%E7%AC%AC1%E7%AB%A0_%E4%B8%8E%E5%88%9D%E5%AD%A6%E8%80%85%E8%B0%88%E8%B0%88JavaScript%E5%AD%A6%E4%B9%A0.pdf" target="_blank">JavaScript解析机制</a>”。“编译”和“预处理”也顺带混为一谈了，还有“预编译” 0_0
我一直以为“预编译”应该是<a href="http://en.wikipedia.org/wiki/AOT_compiler" target="_blank">ahead-of-time compilation</a>的翻译，是与“即时编译”（just-in-time compilation，JIT）相对的概念。另外就是PCH（precompile header）这种用法，把以前的编译结果缓存下来称为“预编译”。把AOT、PCH跟“预处理”（<a href="http://en.wikipedia.org/wiki/Preprocessor" target="_blank">preprocess</a>）混为一谈真是诡异。算了，我还是不要淌这浑水的好……打住。
<strong>2、“解释器”到底是什么？“解释型语言”呢？</strong>
很多资料会说，Python、Ruby、JavaScript都是“解释型语言”，是通过解释器来实现的。这么说其实很容易引起误解：语言一般只会定义其抽象语义，而不会强制性要求采用某种实现方式。
例如说C一般被认为是“编译型语言”，但C的解释器也是存在的，例如<a href="http://www.softintegration.com/" target="_blank">Ch</a>。同样，C++也有解释器版本的实现，例如<a href="http://root.cern.ch/drupal/content/cint" target="_blank">Cint</a>。
一般被称为“解释型语言”的是主流实现为解释器的语言，但并不是说它就无法编译。例如说经常被认为是“解释型语言”的<a href="http://schemers.org/" target="_blank">Scheme</a>就有好几种编译器实现，其中率先支持<a href="http://www.r6rs.org/" target="_blank">R6RS</a>规范的大部分内容的是<a href="http://ikarus-scheme.org/" target="_blank">Ikarus</a>，支持在x86上编译Scheme；它最终不是生成某种虚拟机的字节码，而是直接生成x86机器码。
解释器就是个黑箱，输入是源码，输出就是输入程序的执行结果，对用户来说中间没有独立的“编译”步骤。这非常抽象，内部是怎么实现的都没关系，只要能实现语义就行。你可以写一个C语言的解释器，里面只是先用普通的C编译器把源码编译为in-memory image，然后直接调用那个image去得到运行结果；用户拿过去，发现直接输入源码可以得到源程序对应的运行结果就满足需求了，无需在意解释器这个“黑箱子”里到底是什么。
实际上很多解释器内部是以“编译器+虚拟机”的方式来实现的，先通过编译器将源码转换为AST或者字节码，然后由虚拟机去完成实际的执行。所谓“解释型语言”并不是不用编译，而只是不需要用户显式去使用编译器得到可执行代码而已。
那么虚拟机（<a href="http://en.wikipedia.org/wiki/Virtual_machine" target="_blank">virtual machine</a>，VM）又是什么？在许多不同的场合，VM有着不同的意义。如果上下文是Java、Python这类语言，那么一般指的是高级语言虚拟机（high-level language virtual machine，HLL VM），其意义是实现高级语言的语义。VM既然被称为“机器”，一般认为输入是满足某种指令集架构（<a href="http://en.wikipedia.org/wiki/Instruction_set" target="_blank">instruction set architecture</a>，ISA）的指令序列，中间转换为目标ISA的指令序列并加以执行，输出为程序的执行结果的，就是VM。源与目标ISA可以是同一种，这是所谓same-ISA VM。
前面提到解释器中的编译器的输出可能是AST，也可能是字节码之类的指令序列；一般会把执行后者的程序称为VM，而执行前者的还是笼统称为解释器或者树遍历式解释器（tree-walking interpreter）。这只是种习惯而已，并没有多少确凿的依据。只不过线性（相对于树形）的指令序列看起来更像一般真正机器会执行的指令序列而已。
其实我觉得把执行AST的也叫VM也没啥大问题。如果认同这个观点，那么把<a href="http://rednaxelafx.iteye.com/blog/241430" target="_blank">DLR</a>看作一种VM也就可以接受了——它的“指令集”就是树形的Expression Tree。
VM并不是神奇的就能执行代码了，它也得采用某种方式去实现输入程序的语义，并且同样有几种选择：“编译”，例如微软的.NET中的CLR；“解释”，例如CPython、CRuby 1.9，许多老的JavaScript引擎等；也有介于两者之间的混合式，例如Sun的JVM，<a href="http://en.wikipedia.org/wiki/HotSpot" target="_blank">HotSpot</a>。如果采用编译方式，VM会把输入的指令先转换为某种能被底下的系统直接执行的形式（一般就是native code），然后再执行之；如果采用解释方式，则VM会把输入的指令逐条直接执行。
换个角度说，我觉得采用编译和解释方式实现虚拟机最大的区别就在于是否存下目标代码：编译的话会把输入的源程序以某种单位（例如<a href="http://en.wikipedia.org/wiki/Basic_block" target="_blank">基本块</a>/函数/方法/trace等）翻译生成为目标代码，并存下来（无论是存在内存中还是磁盘上，无所谓），后续执行可以复用之；解释的话则是把源程序中的指令逐条解释，不生成也不存下目标代码，后续执行没有多少可复用的信息。有些稍微先进一点的解释器可能会优化输入的源程序，把满足某些模式的指令序列合并为“超级指令”；这么做就是朝着编译的方向推进。后面讲到解释器的演化时再讨论超级指令吧。
如果一种语言的主流实现是解释器，其内部是编译器+虚拟机，而虚拟机又是采用解释方式实现的，或者内部实现是编译器+树遍历解释器，那它就是名副其实的“解释型语言”。如果内部用的虚拟机是用编译方式实现的，其实跟普遍印象中的“解释器”还是挺不同的……
可以举这样一个例子：ActionScript 3，一般都被认为是“解释型语言”对吧？但这种观点到底是把FlashPlayer整体看成一个解释器，因而AS3是“解释型语言”呢？还是认为FlashPlayer中的虚拟机采用解释执行方案，因而AS3是“解释型语言”呢？
其实Flash或Flex等从AS3生成出来的SWF文件里就包含有AS字节码（ActionScript Byte Code，ABC）。等到FlashPlayer去执行SWF文件，或者说等到AVM2（ActionScript Virtual Machine 2）去执行ABC时，又有解释器和JIT编译器两种实现。这种需要让用户显式进行编译步骤的语言，到底是不是“解释型语言”呢？呵呵。所以我一直觉得“编译型语言”跟“解释型语言”的说法太模糊，不太好。
有兴趣想体验一下从命令行编译“裸”的AS3文件得到ABC文件，再从命令行调用AVM2去执行ABC文件的同学，可以从<a href="http://rednaxelafx.iteye.com/blog/196278" target="_blank">这帖</a>下载我之前从源码编译出来的AVM2，自己玩玩看。例如说要编译一个名为test.as的文件，用下列命令：
Command prompt代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>java -jar asc.jar -import builtin.abc -import toplevel.abc test.as  </li>
</ol>
<p>java -jar asc.jar -import builtin.abc -import toplevel.abc test.as
就是用ASC将test.as编译，得到test.abc。接着用：
Command prompt代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>avmplus test.abc  </li>
</ol>
<p>avmplus test.abc
就是用AVM2去执行程序了。很生动的体现出“编译器+虚拟机”的实现方式。
这个“裸”的AVM2没有带Flash或Flex的类库，能用的函数和类都有限。不过AS3语言实现是完整的。可以用print()函数来向标准输出流写东西。
Well……其实写Java程序不也是这样么？现在也确实还有很多人把Java称为“解释型语言”，完全无视Java代码通常是经过显式编译步骤才得到.class文件，而有些JVM是采用纯JIT编译方式实现的，内部没解释器，例如JRockit、<a href="https://wikis.oracle.com/display/MaxineVM/Home" target="_blank">Maxine VM</a>和<a href="http://jikesrvm.org/" target="_blank">Jikes RVM</a>。我愈发感到“解释型语言”是个应该避开的用语 =_=
关于虚拟机，有本很好的书绝对值得一读，《虚拟机——系统与进程的通用平台》（Virtual Machines: Versatile Platforms for Systems and Processes）。国内有影印版也有中文版，我是读了影印版，不太清楚中文版的翻译质量如何。据说翻译得还行，我无法印证。
<strong>3、基于栈与基于寄存器的指令集架构</strong>
用C的语法来写这么一个语句：
C代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>a = b + c;  </li>
</ol>
<p>a = b + c;
如果把它变成这种形式：
add a, b, c
那看起来就更像机器指令了，对吧？这种就是所谓“三地址指令”（3-address instruction），一般形式为：
op dest, src1, src2
许多操作都是二元运算+赋值。三地址指令正好可以指定两个源和一个目标，能非常灵活的支持二元操作与赋值的组合。ARM处理器的主要指令集就是三地址形式的。
C里要是这样写的话：
C代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>a += b;  </li>
</ol>
<p>a += b;
变成:
add a, b
这就是所谓“二地址指令”，一般形式为：
op dest, src
它要支持二元操作，就只能把其中一个源同时也作为目标。上面的add a, b在执行过后，就会破坏a原有的值，而b的值保持不变。x86系列的处理器就是二地址形式的。
上面提到的三地址与二地址形式的指令集，一般就是通过“基于寄存器的架构”来实现的。例如典型的RISC架构会要求除load和store以外，其它用于运算的指令的源与目标都要是寄存器。
显然，指令集可以是任意“n地址”的，n属于自然数。那么一地址形式的指令集是怎样的呢？
想像一下这样一组指令序列：
add 5
sub 3
这只指定了操作的源，那目标是什么？一般来说，这种运算的目标是被称为“累加器”（accumulator）的专用寄存器，所有运算都靠更新累加器的状态来完成。那么上面两条指令用C来写就类似：
C代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>acc += 5;  </li>
<li>acc -= 3;  </li>
</ol>
<p>acc += 5;</p>
<p>acc -= 3;
只不过acc是“隐藏”的目标。基于累加器的架构近来比较少见了，在很老的机器上繁荣过一段时间。
那“n地址”的n如果是0的话呢？
看这样一段Java字节码：
Java bytecode代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>iconst_1  </li>
<li>iconst_2  </li>
<li>iadd  </li>
<li>istore_0  </li>
</ol>
<p>iconst_1</p>
<p>iconst_2
iadd</p>
<p>istore_0
注意那个iadd（表示整型加法）指令并没有任何参数。连源都无法指定了，零地址指令有什么用？？
零地址意味着源与目标都是隐含参数，其实现依赖于一种常见的数据结构——没错，就是栈。上面的iconst_1、iconst_2两条指令，分别向一个叫做“求值栈”（evaluation stack，也叫做operand stack“操作数栈”或者expression stack“表达式栈”）的地方压入整型常量1、2。iadd指令则从求值栈顶弹出2个值，将值相加，然后把结果压回到栈顶。istore_0指令从求值栈顶弹出一个值，并将值保存到局部变量区的第一个位置（slot 0）。
零地址形式的指令集一般就是通过“基于栈的架构”来实现的。请一定要注意，这个栈是指“求值栈”，而不是与系统调用栈（system call stack，或者就叫system stack）。千万别弄混了。有些虚拟机把求值栈实现在系统调用栈上，但两者概念上不是一个东西。
由于指令的源与目标都是隐含的，零地址指令的“密度”可以非常高——可以用更少空间放下更多条指令。因此在空间紧缺的环境中，零地址指令是种可取的设计。但零地址指令要完成一件事情，一般会比二地址或者三地址指令许多更多条指令。上面Java字节码做的加法，如果用x86指令两条就能完成了：
X86 asm代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>mov  eax, 1  </li>
<li>add  eax, 2  </li>
</ol>
<p>mov  eax, 1</p>
<p>add  eax, 2
（好吧我犯规了，istore<em>0对应的保存我没写。但假如局部变量比较少的话也不必把EAX的值保存（“溢出”，register spilling）到调用栈上，就这样吧 =</em>=
其实就算把结果保存到栈上也就是多一条指令而已……）
一些比较老的解释器，例如<a href="http://www.ruby-lang.org/" target="_blank">CRuby</a>在1.9引入<a href="http://www.atdot.net/yarv/" target="_blank">YARV</a>作为新的VM之前的解释器，还有SquirrleFish之前的老JavaScriptCore以及它的前身KJS，它们内部是树遍历式解释器；解释器递归遍历树，树的每个节点的操作依赖于解释其各个子节点返回的值。这种解释器里没有所谓的求值栈，也没有所谓的虚拟寄存器，所以不适合以“基于栈”或“基于寄存器”去描述。
而像V8那样直接编译JavaScript生成机器码，而不通过中间的字节码的中间表示的JavaScript引擎，它内部有虚拟寄存器的概念，但那只是普通native编译器的正常组成部分。我觉得也不应该用“基于栈”或“基于寄存器”去描述它。
V8在内部也用了“求值栈”（在V8里具体叫“表达式栈”）的概念来简化生成代码的过程，在编译过程中进行“抽象解释”，使用所谓“虚拟栈帧”来记录局部变量与求值栈的状态；但在真正生成代码的时候会做窥孔优化，消除冗余的push/pop，将许多对求值栈的操作转变为对寄存器的操作，以此提高代码质量。于是最终生成出来的代码看起来就不像是基于栈的代码了。
关于JavaScript引擎的实现方式，下文会再提到。
<strong>4、基于栈与基于寄存器架构的VM，用哪个好？</strong>
如果是要模拟现有的处理器，那没什么可选的，原本处理器采用了什么架构就只能以它为源。但HLL VM的架构通常可以自由构造，有很大的选择余地。为什么许多主流HLL VM，诸如JVM、CLI、CPython、CRuby 1.9等，都采用了基于栈的架构呢？我觉得这有三个主要原因：
·实现简单
由于指令中不必显式指定源与目标，VM可以设计得很简单，不必考虑为临时变量分配空间的问题，求值过程中的临时数据存储都让求值栈包办就行。
更新：回帖中cscript指出了这句不太准确，应该是针对基于栈架构的指令集生成代码的编译器更容易实现，而不是VM更容易实现。
·该VM是为某类资源非常匮乏的硬件而设计的
这类硬件的存储器可能很小，每一字节的资源都要节省。零地址指令比其它形式的指令更紧凑，所以是个自然的选择。
·考虑到可移植性
处理器的特性各个不同：典型的CISC处理器的通用寄存器数量很少，例如32位的<a href="http://en.wikipedia.org/wiki/X86" target="_blank">x86</a>就只有8个32位通用寄存器（如果不算EBP和ESP那就是6个，现在一般都算上）；典型的RISC处理器的各种寄存器数量多一些，例如<a href="http://en.wikipedia.org/wiki/ARM_architecture" target="_blank">ARM</a>有16个32位通用寄存器，Sun的<a href="http://en.wikipedia.org/wiki/SPARC" target="_blank">SPARC</a>在一个寄存器窗口里则有24个通用寄存器（8 in，8 local，8 out）。
假如一个VM采用基于寄存器的架构（它接受的指令集大概就是二地址或者三地址形式的），为了高效执行，一般会希望能把源架构中的寄存器映射到实际机器上寄存器上。但是VM里有些很重要的辅助数据会经常被访问，例如一些VM会保存源指令序列的程序计数器（program counter，PC），为了效率，这些数据也得放在实际机器的寄存器里。如果源架构中寄存器的数量跟实际机器的一样，或者前者比后者更多，那源架构的寄存器就没办法都映射到实际机器的寄存器上；这样VM实现起来比较麻烦，与能够全部映射相比效率也会大打折扣。像Dalvik VM的解释器实现，就是把虚拟寄存器全部映射到栈帧（内存）里的，这跟把局部变量区与操作数栈都映射到内存里的JVM解释器实现相比实际区别不太大。
如果一个VM采用基于栈的架构，则无论在怎样的实际机器上，都很好实现——它的源架构里没有任何通用寄存器，所以实现VM时可以比较自由的分配实际机器的寄存器。于是这样的VM可移植性就比较高。作为优化，基于栈的VM可以用编译方式实现，“求值栈”实际上也可以由编译器映射到寄存器上，减轻数据移动的开销。
回到主题，基于栈与基于寄存器的架构，谁更快？看看现在的实际处理器，大多都是基于寄存器的架构，从侧面反映出它比基于栈的架构更优秀。
而对于VM来说，源架构的求值栈或者寄存器都可能是用实际机器的内存来模拟的，所以性能特性与实际硬件又有点不同。一般认为基于寄存器的架构对VM来说也是更快的，原因是：虽然零地址指令更紧凑，但完成操作需要更多的load/store指令，也意味着更多的指令分派（instruction dispatch）次数与内存访问次数；访问内存是执行速度的一个重要瓶颈，二地址或三地址指令虽然每条指令占的空间较多，但总体来说可以用更少的指令完成操作，指令分派与内存访问次数都较少。
这方面有篇被引用得很多的论文讲得比较清楚，<a href="http://www.usenix.org/events/vee05/full_papers/p153-yunhe.pdf" target="_blank">Virtual Machine Showdown: Stack Versus Registers</a>，是在VEE 2005发表的。VEE是Virtual Execution Environment的缩写，是ACM下SIGPLAN组织的一个会议，专门研讨虚拟机的设计与实现的。可以去找找这个会议往年的论文，很多都值得读。
<strong>5、树遍历解释器图解</strong>
在演示基于栈与基于寄存器的VM的例子前，先回头看看更原始的解释器形式。
前面提到解析器的时候用了i = a + b /<em> c的例子，现在让我们来看看由解析器生成的AST要是交给一个树遍历解释器，会如何被解释执行呢？
用文字说不够形象，还是看图吧：
<img src="" alt="">
这是对AST的后序遍历：假设有一个eval(Node n)函数，用于解释AST上的每个节点；在解释一个节点时如果依赖于子树的操作，则对子节点递归调用eval(Node n)，从这些递归调用的返回值获取需要的值（或副作用）——也就是说子节点都eval好了之后，父节点才能进行自己的eval——典型的后序遍历。
（话说，上图中节点左下角有蓝色标记的说明那是节点的“内在属性”。从<a href="http://en.wikipedia.org/wiki/Attribute_grammar" target="_blank">属性语法</a>的角度看，如果一个节点的某个属性的值只依赖于自身或子节点，则该属性被称为“综合属性”（synthesized attribute）；如果一个节点的某个属性只依赖于自身、父节点和兄弟节点，则该属性被称为“继承属性”（inherited attribute）。上图中节点右下角的红色标记都只依赖子节点来计算，显然是综合属性。）
SquirrelFish之前的JavaScriptCore、CRuby 1.9之前的CRuby就都是采用这种方式来解释执行的。
可能需要说明的：
·左值与右值
在源代码i = a + b /</em> c中，赋值符号左侧的i是一个标识符，表示一个变量，取的是变量的“左值”（也就是与变量i绑定的存储单元）；右侧的a、b、c虽然也是变量，但取的是它们的右值（也就是与变量绑定的存储单元内的值）。在许多编程语言中，左值与右值在语法上没有区别，它们实质的差异容易被忽视。一般来说左值可以作为右值使用，反之则不一定。例如数字1，它自身有值就是1，可以作为右值使用；但它没有与可赋值的存储单元相绑定，所以无法作为左值使用。
左值不一定只是简单的变量，还可以是数组元素或者结构体的域之类，可能由复杂的表达式所描述。因此左值也是需要计算的。
·优先级、结合性与求值顺序
这三个是不同的概念，却经常被混淆。通过AST来看就很容易理解：（假设源码是从左到右输入的）
所谓<strong>优先级</strong>，就是不同操作相邻出现时，AST节点与根的距离的关系。优先级高的操作会更远离根，优先级低的操作会更接近根。为什么？因为整棵AST是以后序遍历求值的，显然节点离根越远就越早被求值。
所谓<strong>结合性</strong>，就是当同类操作相邻出现时，操作的先后顺序同AST节点与根的距离的关系。如果是左结合，则先出现的操作对应的AST节点比后出现的操作的节点离根更远；换句话说，先出现的节点会是后出现节点的子节点。
所谓<strong>求值顺序</strong>，就是在遍历子节点时的顺序。对二元运算对应的节点来说，先遍历左子节点再遍历右子节点就是左结合，反之则是右结合。
这三个概念与运算的联系都很紧密，但实际描述的是不同的关系。前两者是解析器根据语法生成AST时就已经决定好的，后者则是解释执行或者生成代码而去遍历AST时决定的。
在没有副作用的环境中，给定优先级与结合性，则无论求值顺序是怎样的都能得到同样的结果；而在有副作用的环境中，求值顺序会影响结果。
赋值运算虽然是右结合的，但仍然可以用从左到右的求值顺序；事实上Java、C/#等许多语言都在规范里写明表达式的求值顺序是从左到右的。上面的例子中就先遍历的=的左侧，求得i的左值；再遍历=的右侧，得到表达式的值23；最后执行=自身，完成对i的赋值。
所以如果你要问：赋值在类似C的语言里明明是右结合的运算，为什么你先遍历左子树再遍历右子树？上面的说明应该能让你发现你把结合性与求值顺序混为一谈了。
看看Java从左到右求值顺序的例子：
Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>public class EvalOrderDemo {  </li>
<li>public static void main(String[] args) {  </li>
<li>int[] arr = new int[1];  </li>
<li>int a = 1;  </li>
<li>int b = 2;  </li>
<li>arr[0] = a + b;  </li>
<li>}  </li>
<li>}  </li>
</ol>
<p>public class EvalOrderDemo {</p>
<pre><code>public static void main(String[] args) {
    int[] arr = new int[1];

    int a = 1;
    int b = 2;

    arr[0] = a + b;
}
</code></pre><p>}
由javac编译，得到arr[0] = a + b对应的字节码是：
Java bytecode代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>// 左子树：数组下标  </li>
<li>// a[0]  </li>
<li>aload_1  </li>
<li>iconst_0  </li>
<li></li>
<li>// 右子树：加法  </li>
<li>// a  </li>
<li>iload_2  </li>
<li>// b  </li>
<li>iload_3  </li>
<li>// +  </li>
<li>iadd  </li>
<li></li>
<li>// 根节点：赋值  </li>
<li>iastore  </li>
</ol>
<p>// 左子树：数组下标</p>
<p>// a[0]
aload_1</p>
<p>iconst_0</p>
<p>// 右子树：加法
// a</p>
<p>iload_2
// b</p>
<p>iload_3
// +</p>
<p>iadd</p>
<p>// 根节点：赋值
iastore
<strong>6、从树遍历解释器进化为基于栈的字节码解释器的前端</strong>
如果你看到树形结构与后序遍历，并且知道后缀记法（或者逆波兰记法，<a href="http://en.wikipedia.org/wiki/Reverse_Polish_notation" target="_blank">reverse Polish notation</a>）的话，那敏锐的你或许已经察觉了：要解释执行AST，可以先通过后序遍历AST生成对应的后缀记法的操作序列，然后再解释执行该操作序列。这样就把树形结构压扁，成为了线性结构。
树遍历解释器对AST的求值其实隐式依赖于调用栈：eval(Node n)的递归调用关系是靠调用栈来维护的。后缀表达式的求值则通常显式依赖于一个栈，在遇到操作数时将其压入栈中，遇到运算时将合适数量的值从栈顶弹出进行运算，再将结果压回到栈上。这种描述看起来眼熟么？没错，后缀记法的求值中的核心数据结构就是前文提到过的“求值栈”（或者叫操作数栈，现在应该更好理解了）。后缀记法也就与基于栈的架构联系了起来：后者可以很方便的执行前者。同理，零地址指令也与树形结构联系了起来：可以通过一个栈方便的把零地址指令序列再转换回到树的形式。
Java字节码与Java源码联系紧密，前者可以看成后者的后缀记法。如果想在JVM上开发一种语义能直接映射到Java上的语言，那么编译器很好写：秘诀就是后序遍历AST。
那么让我们再来看看，同样是i = a + b /<em> c这段源码对应的AST，生成Java字节码的例子：
<img src="" alt="">
（假设a、b、c、i分别被分配到局部变量区的slot 0到slot 3）
能看出Java字节码与源码间的对应关系了么？
一个Java编译器的输入是Java源代码，输出是含有Java字节码的.class文件。它里面主要包含扫描器与解析器，语义分析器（包括类型检查器/类型推导器等），代码生成器等几大部分。上图所展示的就是代码生成器的工作。对Java编译器来说，代码生成就到字节码的层次就结束了；而对native编译器来说，这里刚到生成中间表示的部分，接下去是优化与最终的代码生成。
如果你对<a href="http://rednaxelafx.iteye.com/blog/382412" target="_blank">Python</a>、<a href="http://lifegoo.pluskid.org/upload/doc/yarv/yarv_iset.html" target="_blank">CRuby 1.9</a>之类有所了解，会发现它们的字节码跟Java字节码在“基于栈”的这一特征上非常相似。其实它们都是由“编译器+VM”构成的，概念上就像是Java编译器与JVM融为一体一般。
从这点看，Java与Python和Ruby可以说是一条船上的。虽说内部具体实现的显著差异使得先进的JVM比简单的JVM快很多，而JVM又普遍比Python和Ruby快很多。
当解释器中用于解释执行的中间代码是树形时，其中能被称为“编译器”的部分基本上就是解析器；中间代码是线性形式（如字节码）时，其中能被称为编译器的部分就包括上述的代码生成器部分，更接近于所谓“完整的编译器”；如果虚拟机是基于寄存器架构的，那么编译器里至少还得有虚拟寄存器分配器，又更接近“完整的编译器”了。
<em>*7、基于栈与基于寄存器架构的VM的一组图解</em></em>
要是拿两个分别实现了基于栈与基于寄存器架构、但没有直接联系的VM来对比，效果或许不会太好。现在恰巧有两者有紧密联系的例子——JVM与Dalvik VM。JVM的字节码主要是零地址形式的，概念上说JVM是基于栈的架构。Google Android平台上的应用程序的主要开发语言是Java，通过其中的<a href="http://en.wikipedia.org/wiki/Dalvik_virtual_machine" target="_blank">Dalvik VM</a>来运行Java程序。为了能正确实现语义，Dalvik VM的许多设计都考虑到与JVM的兼容性；但它却采用了基于寄存器的架构，其字节码主要是二地址/三地址混合形式的，乍一看可能让人纳闷。考虑到Android有明确的目标：面向移动设备，特别是最初要对ARM提供良好的支持。ARM9有16个32位通用寄存器，Dalvik VM的架构也常用16个虚拟寄存器（一样多……没办法把虚拟寄存器全部直接映射到硬件寄存器上了）；这样Dalvik VM就不用太顾虑可移植性的问题，优先考虑在ARM9上以高效的方式实现，发挥基于寄存器架构的优势。
Dalvik VM的主要设计者<a href="http://www.milk.com/home/danfuzz/" target="_blank">Dan Bornstein</a>在Google I/O 2008上做过一个<a href="http://sites.google.com/site/io/dalvik-vm-internals" target="_blank">关于Dalvik内部实现</a>的演讲；同一演讲也在Google Developer Day 2008 China和Japan等会议上重复过。这个演讲中Dan特别提到了Dalvik VM与JVM在字节码设计上的区别，指出Dalvik VM的字节码可以用更少指令条数、更少内存访问次数来完成操作。（看不到YouTube的请自行想办法）
眼见为实。要自己动手感受一下该例子，请先确保已经正确安装JDK 6，并从<a href="http://developer.android.com/sdk/" target="_blank">官网</a>获取Android SDK 1.6R1。连不上官网的也请自己想办法。
创建Demo.java文件，内容为：
Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>public class Demo {  </li>
<li>public static void foo() {  </li>
<li>int a = 1;  </li>
<li>int b = 2;  </li>
<li>int c = (a + b) /* 5;  </li>
<li>}  </li>
<li>}  </li>
</ol>
<p>public class Demo {</p>
<pre><code>public static void foo() {
    int a = 1;

    int b = 2;
    int c = (a + b) /* 5;

}
</code></pre><p>}
通过javac编译，得到Demo.class。通过javap可以看到foo()方法的字节码是：
Java bytecode代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>0:  iconst_1  </li>
<li>1:  istore_0  </li>
<li>2:  iconst_2  </li>
<li>3:  istore_1  </li>
<li>4:  iload_0  </li>
<li>5:  iload_1  </li>
<li>6:  iadd  </li>
<li>7:  iconst_5  </li>
<li>8:  imul  </li>
<li>9:  istore_2  </li>
<li>10: return  </li>
</ol>
<p>0:  iconst_1</p>
<p>1:  istore_0
2:  iconst_2</p>
<p>3:  istore_1
4:  iload_0</p>
<p>5:  iload_1
6:  iadd</p>
<p>7:  iconst_5
8:  imul</p>
<p>9:  istore_2
10: return
接着用Android SDK里platforms\android-1.6\tools目录中的dx工具将Demo.class转换为dex格式。转换时可以直接以文本形式dump出dex文件的内容。使用下面的命令：
Command prompt代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>dx --dex --verbose --dump-to=Demo.dex.txt --dump-method=Demo.foo --verbose-dump Demo.class  </li>
</ol>
<p>dx --dex --verbose --dump-to=Demo.dex.txt --dump-method=Demo.foo --verbose-dump Demo.class
可以看到foo()方法的字节码是：
Dalvik bytecode代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>0000: const/4       v0, /#int 1 // /#1  </li>
<li>0001: const/4       v1, /#int 2 // /#2  </li>
<li>0002: add-int/2addr v0, v1  </li>
<li>0003: mul-int/lit8  v0, v0, /#int 5 // /#05  </li>
<li>0005: return-void  </li>
</ol>
<p>0000: const/4       v0, /#int 1 // /#1</p>
<p>0001: const/4       v1, /#int 2 // /#2
0002: add-int/2addr v0, v1</p>
<p>0003: mul-int/lit8  v0, v0, /#int 5 // /#05
0005: return-void
（原本的输出里还有些code-address、local-snapshot等，那些不是字节码的部分，可以忽略。）
让我们看看两个版本在概念上是如何工作的。
JVM：
<img src="" alt="">
（图中数字均以十六进制表示。其中字节码的一列表示的是字节码指令的实际数值，后面跟着的助记符则是其对应的文字形式。标记为红色的值是相对上一条指令的执行状态有所更新的值。下同）
说明：Java字节码以1字节为单元。上面代码中有11条指令，每条都只占1单元，共11单元==11字节。
程序计数器是用于记录程序当前执行的位置用的。对Java程序来说，每个线程都有自己的PC。PC以字节为单位记录当前运行位置里方法开头的偏移量。
每个线程都有一个Java栈，用于记录Java方法调用的“活动记录”（activation record）。Java栈以帧（frame）为单位线程的运行状态，每调用一个方法就会分配一个新的栈帧压入Java栈上，每从一个方法返回则弹出并撤销相应的栈帧。
每个栈帧包括局部变量区、求值栈（JVM规范中将其称为“操作数栈”）和其它一些信息。局部变量区用于存储方法的参数与局部变量，其中参数按源码中从左到右顺序保存在局部变量区开头的几个slot。求值栈用于保存求值的中间结果和调用别的方法的参数等。两者都以字长（32位的字）为单位，每个slot可以保存byte、short、char、int、float、reference和returnAddress等长度小于或等于32位的类型的数据；相邻两项可用于保存long和double类型的数据。每个方法所需要的局部变量区与求值栈大小都能够在编译时确定，并且记录在.class文件里。
在上面的例子中，Demo.foo()方法所需要的局部变量区大小为3个slot，需要的求值栈大小为2个slot。Java源码的a、b、c分别被分配到局部变量区的slot 0、slot 1和slot 2。可以观察到Java字节码是如何指示JVM将数据压入或弹出栈，以及数据是如何在栈与局部变量区之前流动的；可以看到数据移动的次数特别多。动画里可能不太明显，iadd和imul指令都是要从求值栈弹出两个值运算，再把结果压回到栈上的；光这样一条指令就有3次概念上的数据移动了。
对了，想提醒一下：Java的局部变量区并不需要把某个局部变量固定分配在某个slot里；不仅如此，在一个方法内某个slot甚至可能保存不同类型的数据。如何分配slot是编译器的自由。从类型安全的角度看，只要对某个slot的一次load的类型与最近一次对它的store的类型匹配，JVM的字节码校验器就不会抱怨。以后再找时间写写这方面。
Dalvik VM：
<img src="" alt="">
说明：Dalvik字节码以16位为单元（或许叫“双字节码”更准确 =_=|||）。上面代码中有5条指令，其中mul-int/lit8指令占2单元，其余每条都只占1单元，共6单元==12字节。
与JVM相似，在Dalvik VM中每个线程都有自己的PC和调用栈，方法调用的活动记录以帧为单位保存在调用栈上。PC记录的是以16位为单位的偏移量而不是以字节为单位的。
与JVM不同的是，Dalvik VM的栈帧中没有局部变量区与求值栈，取而代之的是一组虚拟寄存器。每个方法被调用时都会得到自己的一组虚拟寄存器。常用v0-v15这16个，也有少数指令可以访问v0-v255范围内的256个虚拟寄存器。与JVM相同的是，每个方法所需要的虚拟寄存器个数都能够在编译时确定，并且记录在.dex文件里；每个寄存器都是字长（32位），相邻的一对寄存器可用于保存64位数据。方法的参数按源码中从左到右的顺序保存在末尾的几个虚拟寄存器里。
与JVM版相比，可以发现Dalvik版程序的指令数明显减少了，数据移动次数也明显减少了，用于保存临时结果的存储单元也减少了。
你可能会抱怨：上面两个版本的代码明明不对应：JVM版到return前完好持有a、b、c三个变量的值；而Dalvik版到return-void前只持有b与c的值（分别位于v0与v1），a的值被刷掉了。
但注意到a与b的特征：它们都只在声明时接受过一次赋值，赋值的源是常量。这样就可以对它们应用<a href="http://en.wikipedia.org/wiki/Constant_folding" target="_blank">常量传播</a>，将
Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>int c = (a + b) /* 5;  </li>
</ol>
<p>int c = (a + b) /* 5;
替换为
Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>int c = (1 + 2) /* 5;  </li>
</ol>
<p>int c = (1 + 2) /* 5;
然后可以再对c的初始化表达式应用常量折叠，进一步替换为：
Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>int c = 15;  </li>
</ol>
<p>int c = 15;
把变量的每次状态更新（包括初始赋值在内）称为变量的一次“定义”（definition），把每次访问变量（从变量读取值）称为变量的一次“使用”（use），则可以把代码整理为“使用-定义链”（简称UD链，<a href="http://en.wikipedia.org/wiki/Use-define_chain" target="_blank">use-define chain</a>）。显然，一个变量的某次定义要被使用过才有意义。上面的例子经过常量传播与折叠后，我们可以分析得知变量a、b、c都只被定义而没有被使用。于是它们的定义就成为了无用代码（dead code），可以安全的被消除。
上面一段的分析用一句话描述就是：由于foo()里没有产生外部可见的副作用，所以foo()的整个方法体都可以被优化为空。经过dx工具处理后，Dalvik版程序相对JVM版确实是稍微优化了一些，不过没有影响程序的语义，程序的正确性是没问题的。这是其一。
其二是Dalvik版代码只要多分配一个虚拟寄存器就能在return-void前同时持有a、b、c三个变量的值，指令几乎没有变化：
Dalvik bytecode代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>0000: const/4      v0, /#int 1 // /#1  </li>
<li>0001: const/4      v1, /#int 2 // /#2  </li>
<li>0002: add-int      v2, v0, v1  </li>
<li>0004: mul-int/lit8 v2, v2, /#int 5 // /#05  </li>
<li>0006: return-void  </li>
</ol>
<p>0000: const/4      v0, /#int 1 // /#1</p>
<p>0001: const/4      v1, /#int 2 // /#2
0002: add-int      v2, v0, v1</p>
<p>0004: mul-int/lit8 v2, v2, /#int 5 // /#05
0006: return-void
这样比原先的版本多使用了一个虚拟寄存器，指令方面也多用了一个单元（add-int指令占2单元）；但指令的条数没变，仍然是5条，数据移动的次数也没变。
题外话1：Dalvik VM是基于寄存器的，x86也是基于寄存器的，但两者的“寄存器”却相当不同：前者的寄存器是每个方法被调用时都有自己一组私有的，后者的寄存器则是全局的。也就是说，概念上Dalvik VM字节码中不用担心保护寄存器的问题，某个方法在调用了别的方法返回过来后自己的寄存器的值肯定跟调用前一样。而x86程序在调用函数时要考虑清楚<a href="http://en.wikipedia.org/wiki/Calling_convention" target="_blank">calling convention</a>，调用方在调用前要不要保护某些寄存器的当前状态，还是说被调用方会处理好这些问题，麻烦事不少。Dalvik VM这种虚拟寄存器让人想起一些实际处理器的“寄存器窗口”，例如SPARC的<a href="http://www.usenix.org/events/sec01/full_papers/frantzen/frantzen_html/node5.html" target="_blank">Register Windows</a>也是保证每个函数都觉得自己有“私有的一组寄存器”，减轻了在代码里处理寄存器保护的麻烦——扔给硬件和操作系统解决了。<a href="http://en.wikipedia.org/wiki/Itanium" target="_blank">IA-64</a>也有寄存器窗口的概念。
（当然，Dalvik VM与x86的“寄存器”一个是虚拟寄存器一个是真实硬件的ISA提供的寄存器，本来也不在一个级别上…上面这段只是讨论寄存器的语义。）
题外话2：Dalvik的.dex文件在未压缩状态下的体积通常比同等内容的.jar文件在deflate压缩后还要小。但光从字节码看，Java字节码几乎总是比Dalvik的小，那.dex文件的体积是从哪里来减出来的呢？这主要得益与.dex文件对常量池的压缩，一个.dex文件中所有类都共享常量池，使得相同的字符串、相同的数字常量等都只出现一次，自然能大大减小体积。相比之下，.jar文件中每个类都持有自己的常量池，诸如&quot;Ljava/lang/Object;&quot;这种常见的字符串会被重复多次。Sun自己也有进一步压缩JAR的工具，Pack200，对应的标准是<a href="http://jcp.org/en/jsr/detail?id=200" target="_blank">JSR 200</a>。它的主要应用场景是作为JAR的网络传输格式，以更高的压缩比来减少文件传输时间。在<a href="http://java.sun.com/j2se/1.5.0/docs/guide/deployment/deployment-guide/pack200.html" target="_blank">官方文档</a>提到了Pack200所用到的压缩技巧，
JDK 5.0 Documentation 写道</p>
<p>Pack200 works most efficiently on Java class files. It uses several techniques to efficiently reduce the size of JAR files:</p>
<ul>
<li>It merges and sorts the constant-pool data in the class files and co-locates them in the archive.</li>
<li>It removes redundant class attributes.</li>
<li>It stores internal data structures.</li>
<li>It use delta and variable length encoding.</li>
<li>It chooses optimum coding types for secondary compression.
可见.dex文件与Pack200采用了一些相似的减小体积的方法。很可惜目前还没有正式发布的JVM支持直接加载Pack200格式的归档，毕竟网络传输才是Pack200最初构想的应用场景。<h1 id="-jvm-dalvik-vm-vm-vm-">再次提醒注意，<strong>上面的描述是针对概念上的JVM与Dalvik VM，而不是针对它们的具体实现</strong>。实现VM时可以采用许多优化技巧去减少性能损失，使得实际的运行方式与概念中的不完全相符，只要最终的运行结果满足原本概念上的VM所实现的语义就行。</h1>
上面“简单”的提了些讨论点，不过还没具体到JavaScript引擎，抱歉。弄得太长了，只好在这里先拆分一次……有些东西想写的，洗个澡又忘记了。等想起来再补充 orz
“简单”是相对于实际应该掌握的信息量而言。上面写的都还没挠上痒痒，心虚。
Anyway。根据拆分的现状，下一篇应该是讨论动态语言与编译的问题，然后再下一篇会看看解释器的演化方法，再接着会看看JavaScript引擎的状况（主要针对V8和Nitro，也会谈谈Tamarin。就不讨论JScript了）。
关于推荐资料，在<a href="http://rednaxelafx.iteye.com/link?tag=virtual+machine" target="_blank">“我的收藏”的virtual machine标签</a>里就有不少值得一读的资料。如果只是对JavaScript引擎相关感兴趣的话也可以选着读些。我的收藏里还有v8和tamarin等标签的，资料有的是 ^ ^
能有耐心读到结尾的同学们，欢迎提出意见和建议，以及指出文中的错漏 ^<em>^
不像抓到虫就给美分的大师，我没那种信心……错漏难免，我也需要进一步学习。拜托大家了～
P.S. 画图真的很辛苦，加上JavaEye的带宽也不是无限的……所以拜托不要直接链接这帖里的图 &lt;(</em> _)&gt;
有需要原始图片的可以跟我联系。我是画成多帧PNG然后转换为GIF发出来的。上面的PNG图片都还保留有原始的图层信息，要拿去再编辑也很方便 ^ ^
更新1：
原本在树遍历解释器图解的小节中，我用的是这幅图：
<img src="" alt="">
其实上图画得不准确，a、b、c的右值不应该画在节点上的；节点应该只保存了它们的左值才对，要获取对应的右值就要查询变量表。我修改了图更新到正文了。原本的图里对i的赋值看起来很奇怪，就像是遍历过程经过了两次i节点一般，而事实不是那样的。</li>
</ul>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/JVM/">JVM</a></li></span></span> | <span class="tags">Tagged <a href="/tags/JVM/" class="label label-primary">JVM</a><a href="/tags/Java&J2EE/" class="label label-success">Java&J2EE</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:42"datetime="2014-03-07 09:54:42"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-JVM--虚拟机随谈（一）：解释器，树遍历解释器，基于栈与基于寄存器，大杂烩/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-JVM--虚拟机随谈（一）：解释器，树遍历解释器，基于栈与基于寄存器，大杂烩" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>





<ul id="pagination" class="pagination pagination-lg">
  <li><a class="extend prev" href="/page/50/">&laquo;</a></li><li><a class="page-number" href="/">1</a></li><li><a class="page-number" href="/page/2/">2</a></li><li><span class="space">&hellip;</span></li><li><a class="page-number" href="/page/48/">48</a></li><li><a class="page-number" href="/page/49/">49</a></li><li><a class="page-number" href="/page/50/">50</a></li><li class="active"><li><span class="page-number current">51</span></li><li><a class="page-number" href="/page/52/">52</a></li><li><a class="page-number" href="/page/53/">53</a></li><li><a class="page-number" href="/page/54/">54</a></li><li><span class="space">&hellip;</span></li></li><li><a class="page-number" href="/page/164/">164</a></li><li><a class="page-number" href="/page/165/">165</a></li><li><a class="extend next" href="/page/52/">&raquo;</a></li>
  <div class="clearfix"></div>
</ul></div><!--wapper-->
       </div><!-- ID main-col END -->
       <aside id="sidebar" class="alignright col-sx-6 col-sm-4 col-md-3 col-lg-3">
<div id="widget_search" class="widget panel panel-primary">
    <form action="//google.com/search" method="get" accept-charset="utf-8">
  <div class="input-group">
    <input class="form-control" id="searchbox" type="search" name="q" results="0" placeholder="search">
    <span class="input-group-btn">
      <button class="btn btn-default" type="submit">Go!</button>
    </span>
    <input type="hidden" name="q" value="site:itsolife.com">
  </div>
</form>
</div>

<div id="widget_category" class="widget panel panel-primary">
  <div class="panel-heading">category</div>  <div data-src='category' class='ajax_widgets'>正在加载...</div>
</div>

<div id="widget_recent_posts" class="widget panel panel-primary">
  <div class="panel-heading">recent posts</div>  <div data-src='recent_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_tagcloud" class="widget panel panel-primary">
  <div class="panel-heading">tagcloud</div>  <div data-src='tagcloud' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_latest_update_posts" class="widget panel panel-primary">
  <div class="panel-heading">最近更新</div>  <div data-src='latest_update_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_recent_comments" class="widget panel panel-primary">
  <div class="panel-heading">recent comments</div>  

<div class="list-group-item ds-recent-comments" data-num-items="6" data-show-avatars="1" data-show-time="1" data-show-title="1" data-show-admin="1" data-excerpt-length="50"></div>



</div>

</aside>
       <div class="clearfix"></div>
     </div><!-- row END -->
  </div>
  <footer id="footer" class="container">
  <div class="panel panel-info">
  <section id='footer_widget'></section>  <div class="panel-footer">
  <div id="site-info">
    <span class='author'>
  
  &copy; 2014 RobinChia
  
    &nbsp;&nbsp;</span>
  
  <span id='analytics-51la'></span><span id='analytics-google'>
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-48559895-1']);
  _gaq.push(['_trackPageview']);
  _js2load.push({src:('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'});
</script></span><span id='analytics-cnzz'>
<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_5774006'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s17.cnzz.com/stat.php%3Fid%3D5774006%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>
</span><span id='analytics-baidu'>
<script>
var _hmt = _hmt || [];
_js2load.push({src:"//hm.baidu.com/hm.js?1442f50724afc42380b51f097c43082c"});
</script>
</span>  </div>
  <div id="copyright">Blog powered by <a href='http://zespia.tw/hexo/'><strong>hexo</strong></a> Theme <strong><a href='https://github.com/chenall/hexo-theme-chenall'>chenall</a></strong>(Some change in it)<span class="pull-right"> 更新时间: <em>2014-03-15 16:55:36</em></span></div>
</div>
<div class="clearfix"></div>


  </div>
  </footer>
  
        <script src="http://cdn.bootcss.com/jquery/1.10.2/jquery.min.js"></script>        
        <script src="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/js/bootstrap.min.js"></script>        
                
        <script src="http://cdn.bootcss.com/prettify/r298/prettify.min.js"></script>    <script type="text/javascript">
   var lang=["bsh", "c", "cc", "cpp", "cs", "csh", "cyc", "cv", "htm", "html",
    "java", "js", "m", "mxml", "perl", "pl", "pm", "py", "rb", "sh",
    "xhtml", "xml", "xsl"];
   var pretty_base='';
   $('script').each(function(){
	var c = $(this).attr('src');
	if (!c)
	    return;
	if (c.match(/(\/)?prettify(\.min)?\.js/i))
	{
	    var index = c.lastIndexOf('/');
	    if (index != -1)
		pretty_base = c.substr(0,index + 1);
	    return false;
	}
   })
   $('pre code').each(function(){
	var c = $(this).attr('class')
	if (!c)
	    return;
	c = c.match(/\s?(lang\-\w+)/i);
	if (c && lang.indexOf(c[1]) == -1)
	{
	    lang.push(c[1]);
	    $.getScript(pretty_base + c[1] + '.min.js');
	}
   })

    $(window).load(function(){
       $("pre").addClass("prettyprint");
       prettyPrint();
    })
</script>    
            <script type="text/javascript">
var duoshuoQuery = {short_name:"robinchia"};
_js2load.push({src:'http://static.duoshuo.com/embed.js',charset:'UTF-8'});
</script>
    
            <!--wumii_relatedItems-->
    
        <script src="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js"></script>    <script type="text/javascript">
(function($){
  $('.entry').each(function(i){
    $(this).find('img').each(function(){
      var alt = this.alt;

      if (alt){
        $(this).before('<span class="caption">' + alt + '</span>');
      }

      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox" rel="fancybox' + i + '" />');
    });
  });

  $('.fancybox').fancybox();
})(jQuery);
</script>    
        <script src="http://cdn.bootcss.com/mathjax/2.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>    <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>
    
<script type="text/javascript">
$('.ajax_widgets').each(function(){var src=$(this).attr('data-src');if(src)$(this).load('/widgets/'+src+'.html');});
$.each(_js2load,function(index,obj){loadjs(obj.src,obj.charset)});
</script>

<div id="scroll2top">
<img src="/scroll2top/arrow.png"/>
</div>
<script src="/scroll2top/scroll2top.min.js"></script>
<div id="winterland">
  <canvas></canvas>
</div>
<script src="/js/winterland.min.js"></script>

  </body>
</html>
