
<!DOCTYPE HTML>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>The 51 Page | It so life</title>
<meta name="author" content="RobinChia">

<meta name="description" content="It so life">


<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<meta property="og:site_name" content="It so life"/>

<!--[if IE]><style>.testIE.IE{display:inline;}</style><![endif]-->
<!--[if lte IE 7]><link rel="stylesheet" href="/css/ie7.css" type="text/css"><![endif]-->
<!--[if (lt IE 9)&(gt IE 7)]><style>.testIE.IE8{display:inline;}</style><![endif]-->
<!--[if gt IE 8]><style>.testIE.IE9{display:inline;}</style><![endif]-->

<link href="/favicon.png" rel="icon">
<link rel="alternate" href="/atom.xml" title="It so life Feed" type="application/atom+xml">

<link rel="stylesheet" href="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/css/bootstrap.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/font-awesome/4.0.3/css/font-awesome.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/prettify/r298/prettify.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" type="text/css">
<link rel="stylesheet" href="/css/style.css" type="text/css">
<!--[if lt IE 9]>
   <style>article,aside,dialog,footer,header,section,footer,nav,figure,menu{display:block}</style>
   <script src="http://cdn.staticfile.org/html5shiv/r29/html5.min.js"></script>
   <script src="http://cdn.staticfile.org/respond.js/1.4.2/respond.min.js"></script>
<link href="http://cdn.staticfile.org/respond.js/1.4.2/respond-proxy.html" id="respond-proxy" rel="respond-proxy" />
<link href="/js/respond.proxy.gif" id="respond-redirect" rel="respond-redirect" />
<script src="/js/respond.proxy.js"></script>
   <script src="http://cdn.bootcss.com/selectivizr/1.0.2/selectivizr-min.js"></script>
<![endif]-->
<script type="text/javascript">
function loadjs(c,d){var a=document.createElement("script");a.async=!0;a.type="text/javascript";a.src=c;a.charset=d||"gbk";(document.getElementsByTagName("HEAD")[0]||document.getElementsByTagName("BODY")[0]).appendChild(a)};
var _protocol = (("https:" == document.location.protocol) ? " https://" : " http://");
var _js2load = [];
</script>

</head>
<body>
      <header id="header" class="container"><nav id="main-nav" class="navbar navbar-default navbar-fixed-top " role="navigation">
  <div class="container">
    <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
      <span class="sr-only">Toggle navigation</span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="/">It so life</a>
    </div>
    <div  class="collapse navbar-collapse">
      <ul  class="nav navbar-nav">
  
        <li><a href="/" title="Home">Home</a></li>      
        <li><a href="/about/" title="About">About</a></li>      
        <li><a href="/archives/" title="Archives">Archives</a></li>      
      <li class='dropdown'>
        <a class='dropdown-toggle' data-toggle='dropdown' href='#'>website<b class='caret'></b></a>
        <ul class='dropdown-menu pure-menu-selected'>
    
          <li><a href="//groups.google.com/forum/#!forum/pongba" title="TopLanguage">TopLanguage</a></li>    
          <li><a href="//itpub.net/" title="ITPub">ITPub</a></li>    
          <li><a href="//blog.jobbole.com/" title="Bole">Bole</a></li>    
          <li><a href="//nosql-database.org/" title="nosql">nosql</a></li>    
          <li><a href="//gitimmersion.googol.im/" title="Git">Git</a></li>    
        </ul>
      </li>
    
      </ul>
      <ul class="nav navbar-nav navbar-right">
      
        <li><a href="/atom.xml">RSS</a></li>
      
      
        <li><a href="https://twitter.com/robinchia">twitter</a></li>
      
      
      
      
        <li><a href="https://github.com/robinchia">github</a></li>
      
      </ul>
    </div>
  </div>
</nav>
<div class="clearfix"></div>
</header>
  <div id='content' class="container">
     <div class="page-header-wrapper">
      <!--[if lt IE 9]><div class="alert alert-warning alert-dismissable"><button type="button" class="close" data-dismiss="alert" aria-hidden="true">&times;</button><strong>提示:</strong>您的浏览器版本太低了,建议升级到 <strong><a href="http://windows.microsoft.com/zh-cn/internet-explorer/download-ie" title="IE9">IE9</a></strong> 以上,本站使用<a href="https://www.google.com/intl/zh-CN/chrome/">Chrome浏览器</a>可以获得最好的显示效果.</div><![endif]-->
      <div class="page-header"><h1 align="center"><big>It so life</big> </h1>
        <h5 align="center"><big>love as life</big></h5>
      </div>
     </div>
     <div class="row">
       <div id="main-col" class="alignleft col-sx-12 col-sm-8 col-md-9 col-lg-9">
      <section id='header_widget'></section>
          <div id="wrapper"><article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_设计类--软件设计文档二三事-善攻者动于九天之上-博客园/">软件设计文档二三事 </a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:42.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_设计类--软件设计文档二三事-善攻者动于九天之上-博客园/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-">软件设计文档二三事 - 善攻者动于九天之上 - 博客园</h1>
<p><img src="" alt=""> Saving Data...
正在保存数据...
正在儲存資料...</p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/Java_设计类/">Java_设计类</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/Java_设计类/" class="label label-success">Java_设计类</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:42"datetime="2014-03-07 09:54:42"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-Java_设计类--软件设计文档二三事-善攻者动于九天之上-博客园/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-Java_设计类--软件设计文档二三事-善攻者动于九天之上-博客园" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_总结类--J2EE学习总结思维方式和理念/">J2EE学习总结 思维方式和理念</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:42.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_总结类--J2EE学习总结思维方式和理念/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="j2ee-">J2EE学习总结 思维方式和理念</h1>
<p>J2EE学习总结:思维方式和理念
Webjx网页教学提示：不管怎么样我还是建议从基本的做起，学精J2SE，熟读它的源码，准确了解其设计理念，然后分头击破J2EE――一口吃不成一个胖子!不要贪多贪广!脚踏实地就可以了!</p>
<p>这篇文章写在我研究J2SE、J2EE近三年后。前3年我研究了J2SE的Swing、Applet、Net、RMI、Collections、IO、JNI……研究了J2EE的JDBC、Sevlet、JSP、JNDI…..不久我发现这些好像太浮浅了：首先，我发现自己知道的仅仅是java提供的大量的API，根本不能很好地使用它; 其次，我根本就没有学到任何有助于写程序的知识，此时我也只不过能写个几页的小程序。出于这个幼稚的想法我研究了JDK中Collections、Logger、IO…..的源代码，发现这个世界真的很神奇，竟然有如此的高手――利用java语言最最基本的语法，创造了这些优秀的Framework。</p>
<p>从此一发不可收拾，我继续研究了J2EE的部分，又发现这是一个我根本不能理解的方向(曾经有半年停滞不前)，为什么只有接口没有实现啊!后来由于一直使用Tomcat、Derby等软件突然发现：哦!原来J2EE仅仅是一个标准，只是一个架构。真正的实现是不同提供商提供的。</p>
<p>接着我研究了MOM4J、OpenJMS、Mocki、HSQLD……发现这些就是J2EE的实现啊!原来软件竟会如此复杂，竟会如此做….规范和实现又是如何成为一体的呢?通过上面的研究发现：原来J2EE后面竟然有太多太多理念、太多太多的相似!这些相似就是其背后的理念――设计模式!(很幸运，在我学java的时候，我一般学java的一个方向就会读一些关于设计模式的书!很幸运，到能领略一点的时候能真正知道这是为什么!)其实模式就是一种思维方式、就是一种理念……模式是要运用到程序中的，只有从真正的项目中才能领会模式的含义……
学得越多，发现懂得越少!在学习过程中发现一些很有用，很值得学习的开源项目，今天在此推荐给大家。</p>
<p>一、JavaServlet和JSP方向</p>
<p>很多人都是从Servlet和JSP步入J2EE的。它就是J2EE的表现层，用于向客户呈现服务器上的内容。J2EE很重要的方面。不罗嗦了!大家都知道的!下面就开始推荐吧!</p>
<ol>
<li>Jakarta Tomcat</li>
</ol>
<p>Apache基金会提供的免费的开源的Serlvet容器，它是的Jakarta项目中的一个核心项目，由Apache、Sun和其它一些公司(都是IT界的大鳄哦)及个人共同开发而成，全世界绝大部分Servlet和Jsp的容器都是使用它哦!由于Sun的参与和支持，最新的Servlet和Jsp规范总能在Tomcat中得到体现。</p>
<p>不过它是一个非常非常全的Serlvet容器，全部源码可能有4000页，对于初学者或者一般的老手可能还是比较大了!在你有能力时推荐研究!下载地址：<a href="http://jakarta.apache.org/tomcat/index.html" target="_blank">http://jakarta.apache.org/tomcat/index.html</a></p>
<p>下面推荐两个小一点的吧!</p>
<ol>
<li>Jetty</li>
</ol>
<p>Jetty是一个开放源码的HTTP服务器和Java serverlet容器。源代码只有1000页左右，很值得研究。有兴趣可以去<a href="http://jetty.mortbay.com/下载看看。我曾经翻了一下，只是目前没有时间。(都化在博客上了，等博客基本定型，且内容完整了，再干我热衷的事件吧!" target="_blank">http://jetty.mortbay.com/下载看看。我曾经翻了一下，只是目前没有时间。(都化在博客上了，等博客基本定型，且内容完整了，再干我热衷的事件吧!</a>)</p>
<ol>
<li>Jigsaw</li>
</ol>
<p>Jigsaw是W3C开发的HTTP，基于Java 的服务器，提供了未来 Web 技术发展的蓝图。W3C知道吧!(太有名气了，很多标准都是它制订的!有空经常去看看吧!)下载网址：<a href="http://www.w3.org/Jigsaw代码仅仅1000页左右。" target="_blank">http://www.w3.org/Jigsaw代码仅仅1000页左右。</a></p>
<ol>
<li>Jo!</li>
</ol>
<p>Jo!是一个纯Java的实现了Servlet API 2.2, JSP 1.1, 和HTTP/1.1的Web服务器。它的特性包括支持servlet tag,支持SSI，高级线程管理，虚拟主机，数据缓存，自动压缩text或HTML文件进行传输，国际化支持，自动重新加载Servlet、Jsp，自动重新加载web工程文件(WARs)，支持WAR热部署和一个Swing控制台。jo!可以被用做jboss和jakarta avalon-phoenix的web容器。下载地址<a href="http://www.tagtraum.com/" target="_blank">http://www.tagtraum.com/</a> 。我极力推荐大家在研究Tomcat之前研究该软件，主要是其比Tomcat小多了，且开发者提供比较全的手册。该方向研究这两个也就可以了!</p>
<p>二、JDBC方向</p>
<p>很多人都喜欢JDBC，数据库吗!很深奥的东西，一听就可以糊弄人。其实等你真正研究了数据库的实现后发现，接口其实真的太简单，太完美了!要想设计如此优秀的框架还是需要学习的。下面就推荐几个数据库的实现吧!</p>
<ol>
<li>Hypersonic SQL</li>
</ol>
<p>Hypersonic SQL开源数据库方向比较流行的纯Java开发的关系型数据库。好像不是JDBC兼容的，JDBC的很多高级的特性都没有支持，不过幸好支持ANSI-92 标准 SQL语法。我推荐它主要是它的代码比较少1600页左右，如此小的数据库值得研究，而且他占的空间很小，大约只有160K，拥有快速的数据库引擎。推荐你的第一个开源数据库。下载地址：<a href="http://hsqldb.sourceforge.net/。" target="_blank">http://hsqldb.sourceforge.net/。</a></p>
<ol>
<li>Mckoi DataBase</li>
</ol>
<p>McKoiDB 和Hypersonic SQL差不多，它是GPL 的license的纯Java开发的数据库。他的 JDBC Driver 是使用 JDBC version 3 的 Specifaction。 他也是遵循 SQL-92 的标准，也尽量支持新的 SQL 特色, 并且支持 Transaction 的功能。两个可以选一个吧!下载地址：<a href="http://mckoi.com/database/。" target="_blank">http://mckoi.com/database/。</a></p>
<ol>
<li>Apache Derby</li>
</ol>
<p>学Java的数据库我建议使用Apache Derby ，研究数据库想成为一个数据库的高手我建议你先研究Apache Derby。Apache Derby是一个高质量的、纯 Java开发的嵌入式关系数据库引擎，IBM® 将其捐献给Apache开放源码社区，同时IBM的产品CloudSpace是它对应的产品。Derby是基于文件系统，具有高度的可移植性，并且是轻量级的，这使得它非常便于发布。主要是没有商业用户的很好的界面，没有其太多的功能。不过对于我们使用数据库、研究数据库还是极其有用的。对于中小型的企业说老实话你也不要用什么Oracle、SqlServer了，用Derby就可以了，何况是开源的呢!只要能发挥其长处也不容易啊!下载地址：<a href="http://incubator.apache.org/derby。" target="_blank">http://incubator.apache.org/derby。</a></p>
<p>不过在没有足够的能力前，不要试图读懂它!注释和源代码15000页左右，我一年的阅读量!能读下来并且能真正领会它，绝对高手!你能读完Derby的源代码只有两种可能：1.你成为顶尖的高手――至少是数据库这部分; 2.你疯了。选择吧!!!!作为我自己我先选择Hypersonic SQL这样的数据库先研究，能过这一关，再继续研究Derby!不就是一年的阅读量吗!我可以化3年去研究如何做一个数据库其实还是很值得的!有的人搞IT一辈子自己什么都没有做，也根本没有研究别人的东西!</p>
<p>作为一个IT落后于别国若干年的、从事IT的下游产业“外包”的国家的IT从业人员，我认为还是先研究别人的优秀的东西比较好!可以先研究别人的，然后消化，学为己用!一心闭门造车实在遗憾!</p>
<p>三、JMS方向</p>
<p>JMS可能对大家来说是一个比较陌生的方向!其实JMS是一个比较容易理解，容易上手的方向。主要是Java消息服务，API也是相当简单的。不过在企业应用中相当广泛。下面就介绍几个吧!</p>
<ol>
<li>MOM4J</li>
</ol>
<p>MOM4J是一个完全实现JMS1.1规范的消息中间件并且向下兼容JMS1.0与1.02。它提供了自己的消息处理存储使它独立于关系数据与语言，它的客户端可以用任何语言开发。它可以算是一个小麻雀，很全实现也比较简单!它包含一个命名服务器，一个消息服务器，同时提供自己的持续层。设计也相当的巧妙，完全利用操作系统中文件系统设计的观念。代码也很少，250页左右，最近我在写该实现的源代码阅读方面的书，希望明年年中能与大家见面!下载地址：<a href="http://mom4j.sourceforge.net/index.html。" target="_blank">http://mom4j.sourceforge.net/index.html。</a></p>
<ol>
<li>OpenJMS</li>
</ol>
<p>OpenJMS是一个开源的Java Message Service API 1.0.2 规范的实现，它包含有以下特性：</p>
<ol>
<li><p>它既支持点到点(point-to-point)(PTP)模型和发布/订阅(Pub/Sub)模型。</p>
</li>
<li><p>支持同步与异步消息发送 。</p>
</li>
<li><p>JDBC持久性管理使用数据库表来存储消息 。</p>
</li>
<li><p>可视化管理界面。</p>
</li>
<li><p>Applet支持。</p>
</li>
<li><p>能够与Jakarta Tomcat这样的Servlet容器结合。</p>
</li>
<li><p>支持RMI, TCP, HTTP 与SSL协议。</p>
</li>
<li><p>客户端验证 。</p>
</li>
<li><p>提供可靠消息传输、事务和消息过滤。</p>
</li>
</ol>
<p>很好的JMS方向的开源项目!我目前也在研究它的源代码!学习它可以顺便研究JNDI的实现、以及网络通信的细节。这是我JMS方向研究的第二个开源项目。代码量1600页左右吧!下载地址：<a href="http://openjms.sourceforge.net/index.html" target="_blank">http://openjms.sourceforge.net/index.html</a></p>
<ol>
<li>ActiveMQ</li>
</ol>
<p>ActiveMQ是一个开放源码基于Apache 2.0 licenced 发布并实现了JMS 1.1。它能够与Geronimo，轻量级容器和任Java应用程序无缝的给合。主要是Apache的可以任意的使用和发布哦!个人比较喜欢Apache的源代码!下载地址：<a href="http://activemq.codehaus.org/" target="_blank">http://activemq.codehaus.org/</a></p>
<ol>
<li>JORAM</li>
</ol>
<p>JORAM一个类似于openJMS分布在ObjectWeb之下的JMS消息中间件。ObjectWeb的产品也是非常值得研究的!下面我还会给大家另外一个ObjectWeb的产品。下载地址：<a href="http://joram.objectweb.org/" target="_blank">http://joram.objectweb.org/</a></p>
<p>我个人推荐：OpenJMS和ActiveMQ!</p>
<p>四、EJB方向</p>
<p>EJB一个比较“高级”的方向。Sun公司曾经以此在分布式计算领域重拳出击。不过自从出现了Spring、Hibernation……后似乎没落了!这个方向单独开源的也比较少，主要EJB是和JNDI、JDBC、JMS、JTS、JTA结合在一起的是以很少有单独的。下面推荐两个不过好像也要下载其它类库。</p>
<ol>
<li>EasyBeans</li>
</ol>
<p>ObjectWeb的一个新的项目，一个轻量级的EJB3容器，虽然还没有正式发布，但是已经可以从它们的subversion仓库中检出代码。代码量比较小600页左右，熟读它可以对网络编程、架构、RMI、容器的状态设计比较了解了!即学会EJB又能学习其它设计方法何乐而不为哦!下载地址：<a href="http://easybeans.objectweb.org/" target="_blank">http://easybeans.objectweb.org/</a></p>
<ol>
<li>OpenEJB</li>
</ol>
<p>OpenEJB是一个预生成的、自包含的、可移植的EJB容器系统，可以被插入到任意的服务器环境，包括应用程序服务器，Web服务器，J2EE平台， CORBA ORB和数据库等等。OpenEJB 被用于 Apple的WebObjects。听起来很好，我目前没有研究过。不知道我就不推荐了。下载地址：<a href="http://www.openejb.org/" target="_blank">http://www.openejb.org/</a></p>
<p>五、J2EE容器</p>
<p>上面谈了这么多，都是J2EE的各个方向的。其实J2EE是一个规范，J2EE的产品一般要求专业提供商必须提供它们的实现。这些实现本身就是J2EE容器。市场上流行的J2EE容器很多，在开源领域流行的只有很少，很少。其中最著名的是JBoss。</p>
<ol>
<li>JBoss</li>
</ol>
<p>在J2EE应用服务器领域，Jboss是发展最为迅速的应用服务器。由于Jboss遵循商业友好的LGPL授权分发，并且由开源社区开发，这使得Jboss广为流行。另外，Jboss应用服务器还具有许多优秀的特质。</p>
<p>其一，它将具有革命性的JMX微内核服务作为其总线结构;</p>
<p>其二，它本身就是面向服务的架构(Service-Oriented Architecture，SOA);</p>
<p>其三，它还具有统一的类装载器，从而能够实现应用的热部署和热卸载能力。因此，它是高度模块化的和松耦合的。Jboss用户的积极反馈告诉我们，Jboss应用服务器是健壮的、高质量的，而且还具有良好的性能。为满足企业级市场日益增长的需求，Jboss公司从2003年开始就推出了24/*7、专业级产品支持服务。同时，为拓展Jboss的企业级市场，Jboss公司还签订了许多渠道合作伙伴。比如，Jboss公司同HP、Novell、Computer Associates、Unisys等都是合作伙伴。</p>
<p>在2004年6月，Jboss公司宣布，Jboss应用服务器通过了Sun公司的J2EE认证。这是Jboss应用服务器发展史上至今为止最重要的里程碑。与此同时，Jboss一直在紧跟最新的J2EE规范，而且在某些技术领域引领J2EE规范的开发。因此，无论在商业领域，还是在开源社区，Jboss成为了第一个通过J2EE 1.4认证的主流应用服务器。现在，Jboss应用服务器已经真正发展成具有企业强度(即，支持关键级任务的应用)的应用服务器。</p>
<p>Jboss 4.0作为J2EE认证的重要成果之一，已经于2004年9月顺利发布了。同时，Jboss 4.0还提供了Jboss AOP(Aspect-Oriented Programming，面向方面编程)组件。近来，AOP吸引了大量开发者的关注。它提供的新的编程模式使得用户能够将方面(比如，事务)从底层业务逻辑中分离出来，从而能够缩短软件开发周期。用户能够单独使用Jboss AOP，即能够在Jboss应用服务器外部使用它。或者，用户也可以在应用服务器环境中使用它。Jboss AOP 1.0已经在2004年10月发布了。 很有名吧!可以下载一个用一下，下载地址：<a href="http://www.jboss.org/" target="_blank">http://www.jboss.org/</a></p>
<p>关于JBoss的使用资料也非常多，甚至比商业软件的还多。有机会研究吧!</p>
<ol>
<li>JOnAS</li>
</ol>
<p>JOnAS是一个开放源代码的J2EE实现，在ObjectWeb协会中开发。整合了Tomcat或Jetty成为它的Web容器，以确保符合Servlet 2.3和JSP 1.2规范。JOnAS服务器依赖或实现以下的Java API：JCA、JDBC、JTA 、JMS、JMX、JNDI、JAAS、JavaMail 。下载地址：<a href="http://jonas.objectweb.org/" target="_blank">http://jonas.objectweb.org/</a>
3.Apache Geronimo</p>
<p>Apache Geronimo 是 Apache 软件基金会的开放源码J2EE服务器，它集成了众多先进技术和设计理念。 这些技术和理念大多源自独立的项目，配置和部署模型也各不相同。 Geronimo能将这些项目和方法的配置及部署完全整合到一个统一、易用的模型中。作为符合J2EE标准的服务器，Geronimo提供了丰富的功能集和无责任 Apache 许可，具备“立即部署”式J2EE 1.4容器的各种优点，其中包括：</p>
<ol>
<li><p>符合J2EE1.4标准的服务器 。</p>
</li>
<li><p>预集成的开放源码项目 。</p>
</li>
<li><p>统一的集成模型 。</p>
</li>
<li><p>可伸缩性、可管理性和配置管理功能。</p>
</li>
</ol>
<p>我一直比较推荐Apache的产品。主要是可以任意自由地使用。下载地址：<a href="http://incubator.apache.org/projects/geronimo/" target="_blank">http://incubator.apache.org/projects/geronimo/</a></p>
<p>六、其它</p>
<p>讲了这么多大家可能很厌烦了!是不是很多很多啊!其实不然，我们不会的太多太多了!不会的太多太多了。不管你是不是J2EE高手，还是J2SE高手，有些东西你要绝对很精明的。例如：1.Java的Collections Framework就是java的数据结构了，不仅要吃透它，还要能按照需要扩展它，利用其思想创建一个自己的数据结构。2.网络编程肯定要会吧，现在以及以后很多程序都是不在同一台机器上的，不会网络怎么行哦!3.IO肯定要会的吧!你的程序难道不用输入输出数据啊!整个IO包加NIO也有600多页的源代码哦!4.JDBC你要会吧!数据库都不会，在你的企业应用中你的数据又保存到哪里啊!文件中――太落后了吧!典型的没有学过J2EE。尽管数据库背后也是采用文件保存的。5.Serverlet、JSp你要是做网页做网站，肯定要做到。问你一个简单的问题，网页中如何实现分页啊!有具体方法的就在本文章后发言吧!6. Ant要会吧!java语言中发布的工具，类似与c中的make工具。7.JUnit用过吧!单元测试软件。你不要啊!你的软件就没有bug!你牛!(建议大家研究研究其源代码，很有用的框架，包含大量的设计模式，源代码不到100页!看了只能感叹――高手就是高手)细心的朋友可以看到在你使用的很多IDE工具中都有JUnit哦!就是它。</p>
<p>一切的一切才刚刚开始!有兴趣，有需要你可以研究数据库连接池的框架，如：C3P0、Jakarta DBCP、 DBPool….可以研究J2EE框架Spring……. Web框架Struts……持久层框架Hibernate…..甚至开发工具Eclipse…..Sun领导的点对点通信的JXTA…..报表工具JFreeChart、JasperReports…..分布式网络编程的CORBA、网络通信的JGROUPS、XML解析的xerces…..(在不经意间开源已经步入你的电脑，不信啊!你JDK的安装目录jdk1.6.0 src com sun org apache就是Xerces，一个XML解析的著名的开源 项目)</p>
<p>不管怎么样我还是建议从基本的做起，学精J2SE，熟读它的源码，准确了解其设计理念，然后分头击破J2EE――一口吃不成一个胖子!不要贪多贪广!脚踏实地就可以了!</p>
<hr>
<p><strong><a href="http://www.webjx.com/exam/java-15508.html" target="_blank">http://www.webjx.com/exam/java-15508.html</a></strong></p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/Java_总结类/">Java_总结类</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/Java_总结类/" class="label label-success">Java_总结类</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:43"datetime="2014-03-07 09:54:43"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-Java_总结类--J2EE学习总结思维方式和理念/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-Java_总结类--J2EE学习总结思维方式和理念" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--Java虚拟机技术总结07年写的-原JavaEye精华帖/">Java虚拟机技术总结(07年写的</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:42.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--Java虚拟机技术总结07年写的-原JavaEye精华帖/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="java-07-javaeye-">Java虚拟机技术总结(07年写的,原JavaEye精华帖)</h1>
<p>原文：IBM WebSphere Application Server 诊断和调优（一））
大家可以google：“IBM WebSphere Application Server 诊断和调优”。
近段时间，我们项目中用到的WebSphere应用服务器(WAS)，但在客户的production环境下极不稳定，经常宕机。给客户造成非常不好的影响，同时，也给项目组很大压力。为此，我们花了近一个月时间对其诊断，现在基本上稳定了，需要继续观察一段时间。现在我主要将工作做一个阶段性的总结。
我们的产品环境是：WAS6.0＋DB2 8.1＋AIX5.3＋RS/6000。在该产品环境下，出现的问题非常多，现象如下：
WAS经常不稳定、宕机几乎一天一次，经常报告OutOfMemory(内存泄漏吗？NO)。
DB2连接数过大，有时把DB2撑死，有时也把AIX撑死。
AIX虚拟内存报错、分页报错、IO也报错、还有很多其它莫名奇妙的错。
总是，每次问题发生的现象和理论上的总是不一致，导致我们不知道从何入手，也无从检测自己的优化参数。咨询过多次IBM技术支持，只解决了某些局部问题。
虽然问题依然存在，但我想，解决问题的思路、特别是理论基础，还是有一些规律和原则。
对于WAS这块，我近段时间的主要时间集中在以下几个方面(时间顺序)：
1、Java性能监测工具：Jprofiler，也用到Jprobe。后来发现Jprofiler在AIX下几乎不可用。
2、IBM Java虚拟机和WAS技术细节，特别是IBM JVM的GC原理，我发现它和sun、bea的差别很大。
3、IBM的heap分析器Heap Analyzer、GCCollector。这两个事后监测工具非常实用，特别是我们的产品运行环境，非测试环境。
4、某些Application的怀疑和诊断。
5、AIX诊断，我几乎没有这个能力，只能常规监测一下，需另请高人。
我打算将本文分成以下几个部分总结：
JVM原理、IBM JVM的GC策略和调优
Jprofiler和IBM工具的实际体会
WAS的诊断体会和AIX调优
下面开始主题吧，可能比较零碎，另外，开始的理论篇基本上看书都可以，我只是总结一下，再添加一些自己的理解。
以下是我参考的最重要的两本电子书和一些网站：
《Inside Java Vrtual Machine》:半部分有约四章我认为非常棒，其它章节可能意义不大。
《The Java Virtual Machine Specification, 2nd》：前半部分有两三章很不错，不过可以对照上一本书看。
sun的hotspot虚拟机技术：[url]<a href="http://java.sun.com/javase/technologies/hotspot/" target="_blank">http://java.sun.com/javase/technologies/hotspot/</a> [/url]
BEA的JRockit虚拟机技术：[url]<a href="http://edocs.bea.com/jrockit/geninfo/genintro/index.html" target="_blank">http://edocs.bea.com/jrockit/geninfo/genintro/index.html</a> [/url]JVM技术文档入口，虚拟机理论，内存泄漏诊断等的索引页。
IBM诊断资料：<a href="http://www-128.ibm.com/developerworks/java/jdk/diagnosis/" target="_blank">http://www-128.ibm.com/developerworks/java/jdk/diagnosis/</a> 上面有一个500多页的pdf文档，对IBM JVM技术和诊断讲解很深入。
我不得不提的是，在查资料这块，BEA和Sun都有很好的官方文档和论坛支持，并且官方文档导航非常好。虽然IBM的诊断资料也不少，但需要搜索，其搜索是很痛苦的。而且，IBM官方论坛很差。如果用IBM的产品出问题，切记：找IBM技术支持，千万不要蒙着头搞！反正它们的产品很少免费。说实话，它们的技术支持还是挺负责的，一般会为你推荐很多support资料，而该资料往往都在developerworks网站上，属于support那个频道，但你就是搜不着。
<strong>Java虚拟机规范概要</strong>
研究Java虚拟机，首先要了解Sun的Java虚拟机规范。现在，该实现版本很多，如比较有名的Sun、IBM、BEA、Apple、HP、MS、Apache Harmony。它们都实现了JVM规范，但有各自扩展。譬如，针对IBM虚拟机的堆碎片导致OutOfMemory（OOM），在Sun的虚拟机上就不会发生。Sun的JVM有maxPermSize的概念，IBM就没有，如果你设置这个参数，虚拟机根本就启动不了。
比较有意思的是，学Java，就一定要了解各种规范，这和MS的风格很不一样。Sun总是在定义一些规范，实现都留给各厂商。我们除了理解规范本身外，一定要理解规范和实现之间的关系，譬如JDBC规范和JDBC驱动的关系，它们是怎么组合到一起的。要是你用过php的xml解析库，或db函数，就会体会深刻，它们可没有什么规范可言，所以每个数据库厂商的db函数用法都不一样。我推荐大家研读一下HSQLDB的jdbc和Tomcat的servlet相关实现，因为我认为它们还是比较好懂的。
JVM规范只是定义一个虚拟机该做什么，但它并没有要求你该怎么做。例如我们最常见的Servlet规范，在该规范中，有HttpServletRequest、HttpServletResponse，HttpSession等接口，但它们的实现都留给了各个容器厂商。遗憾的是，规范留下的空白，会把我们这些开发人员给整惨了：容器间移植有时候就是恶梦。譬如J2EE并没有SSO规范，但它很重要，我以前专门针对它做过WebSphere AppServer和Weblogic AppServer的SSO项目，差别还是不小，不过还是有点共通，那就是都遵循JAAS规范。
<strong>JVM的结构</strong>
从功能上分，Java虚拟机主要由六个部分组成，可以分成三类：
第一类：JVM API：就是我们最常用的Java API，它是开发人员和Java交互的入口，它主要是JAVA_HOME/jre/lib下的运行时类库rt.jar和编译相关的tools.jar
第二类：JVM内部组件
类装载器(ClassLoader)：将Byte Array的 .class文件装载、链接和初始化。
内存管理(Memory Managent)：为对象分配内存，以及释放内存。后者就是垃圾回收Garbage Collector（GC）。由于JVM最复杂的、最影响性能的就是GC，所以内存管理一般就指垃圾回收。
诊断接口(Diagostics Interface)：这主要体现在JVMTI(jdk1.4下的JVMPI和JVMDI)，它主要用来诊断程序的问题和性能，一般提供给工具厂商实现。如eclispe IDE下的debug功能，Jprofiler性能调优工具。
类解释器(Interpreter)：解释装载进虚拟机的class对象，包括JIT等特性相关。
第三类：平台相关接口(Platform Interface)：主要为了跨操作系统平台重用JVM代码，不过，它和我们开发人员关系不大。
在以上六个组件中，我们开发人员最关心的是ClassLoader和GC，用Java做系统框架、容器和它们密切相关。做业务系统时一些基础代码也和它们打交道，譬如最常用的Class.forName(),Thread.currentThread.getContextClassLoader()。我们仔细想想，为什么是上面两个问题？因为，它和我们class的整个生命周期最为相关：怎么将一个class和相关class加载进来，class实例什么时候创建，什么时候被销毁？
所以，下面的部分我们要专门讨论这些问题。
<strong>ClassLoader</strong>
JVM主要有三类ClassLoader：Bootstrap、Extention、Application，该三类ClassLoader从上到下是分级(hierarchy)结构，遵循代理模型(Delegation Model)。
Tip：大家可以看看sun.misc.Launcher的源码，Bootstrap和Extention就在该文件里。该src可以在sun的网站上下载该压缩包，约60M(jdk-1_5_0-src-scsl.zip)，它不在jdk自带的那个src.zip里。
Bootstrap ClassLoader：也称为primordial(root) class loader。主要是负责装载jre/lib下的jar文件，当然，你也可以通过-Xbootclasspath参数定义。该ClassLoader不能被Java代码实例化，因为它是JVM本身的一部分。
Extention ClassLoader：该ClassLoader是Bootstrap classLoader的子class loader。它主要负责加载jre/lib/ext/下的所有jar文件。只要jar包放置这个位置，就会被虚拟机加载。一个常见的、类似的问题是，你将mysql的低版本驱动不小心放置在这儿，但你的Web应用程序的lib下有一个新的jdbc驱动，但怎么都报错，譬如不支持JDBC2.0的DataSource，这时你就要当心你的新jdbc可能并没有被加载。这就是ClassLoader的delegate现象。常见的有log4j、common-log、dbcp会出现问题，因为它们很容易被人塞到这个ext目录，或是Tomcat下的common/lib目录。
Application ClassLoader：也称为System ClassLoaer。它负责加载CLASSPATH环境变量下的classes。缺省情况下，它是用户创建的任何ClassLoader的父ClassLoader，我们创建的standalone应用的main class缺省情况下也是由它加载(通过Thread.currentThread().getContextClassLoader()查看)。
我们实际开发中，用ClassLoader更多时候是用其加载classpath下的资源，特别是配置文件，如ClassLoader.getResource()，比FileInputStream直接。
ClassLoader是一种分级(hierarchy)的代理(delegation)模型。
Delegation：其实是Parent Delegation，当需要加载一个class时，当前线程的ClassLoader首先会将请求代理到其父classLoader，递归向上，如果该class已经被父classLoader加载，那么直接拿来用，譬如典型的ArrayList，它最终由Bootstrap ClassLoader加载。并且，每个ClassLoader只有一个父ClassLoader。
Class查找的位置和顺序依次是：Cache、parent、self。
Hierarchy：上面的delegation已经暗示了一种分级结构，同时它也说明：一个ClassLoader只能看到被它自己加载的classes，或是看到其父(parent) ClassLoader或祖先(ancestor) ClassLoader加载的Classes。
在一个单虚拟机环境下，标识一个类有两个因素：class的全路径名、该类的ClassLoader。
我碰到的一个典型的例子是：在做WAS的SSO开发时，由于我们的类是由WAS在启动时加载，该ClassLoader比下面的部署的Applicaton的ClassLoader的级别高。所以，在我们自己的类中没法用到应用程序的连接池，必须自建。
代理模型是Java安全模型的保证。譬如，我们自己写一个String.java，并且编译、package到自己的java.lang包下。按照代理模型，当前线程的ClassLoader会将其代理到父ClassLoader，父ClassLoader(最终会是Bootstrap)会找到rt.jar下的String.class，也就是说我们的String.class不会捣乱。
<strong>自定义ClassLoader</strong>
我们前面说过，自定义ClassLoader的缺省父ClassLoader是Application ClassLoader。一般的应用开发用不到它，但我们最好理解。因为在内存泄漏查找、应用程序部署出问题时，很多都和它有关。
譬如，内存泄漏是怎么产生的？这就涉及到ClassLoader和Class的生命周期。我曾经碰到这样一个问题：我们的程序用到了Webwork和Spring框架，当部署到Tomcat下时没有任何问题，但部署到WAS下，报告找不到Webwork的xml的DTD文件，而且Spring的日志也总是失效。Why？因为解析xml dtd时，用的是IBM的Xerces，不是我们的。而Spring日志问题是因为应用程序用的是WAS的Common-log.jar，而不是我们的。将应用的ClassLoader从默认的Parent-First，改成Parent-Last就可以解决，不过我们项目中用到其它库，又发生了其它问题。
<strong>一般来说，用到自定义ClassLoader有三种情况：</strong>
1、应用框架可以自己控制Classes的目录，并且自动部署。
我读过Jive公司的Wildfire(著名的即时通讯服务器)，它自己有一套应用框架，非常灵活，遵循该框架插件规范的的第三方的plug-in放置在指定目录可以自动部署，实现某些扩展功能，如文件传输、语音聊天。
2、区分用户代码
这被广泛应用在Servlet容器和类似容器，譬如EJB Container设计中，大家看到Tomcat下有common、server、share三个目录吧(ClassLoader顺序从左到有)，另外也有用户应用的WEB-INF目录，它是我们自己开发的。
3、允许Classes卸载
如果没有自定义的ClassLoader，那么我们自己应用中的classes永远都不能被卸载，因为这些类被Application ClassLoader加载后cache起来了，我们的classes一直对该ClassLoader有引用，而该系统级的ClassLoader永远都不会被卸载，除非JVM shutdown了。JSP和Servlet的动态部署就用到这个特性。
待续…….
Note: 还有JVM运行时(Runtime)架构，ClassLoader加载class过程没有总结，这两部分我觉得太重要了，但内容太多，写不完啊。
这部分内容，《Inside Java Virtual Machine》讲解非常清楚，BEA的官方网站这部分也非常不错，要理解深刻，我建议结合JProfiler工具，非常直观。
待续…….
该文仅存的一点回复：
[zwchen]
<strong>为什么都说WAS难用？</strong>
<strong>安装过程</strong>
1、先安装WAS，然后创建三种不同类型的profiles(manager,default,custom)，譬如缺省的profiles吧，在创建这个profiles过程中，需要启动至少10个端口，要是那10个默认端口有些被你的系统占用了，麻烦就来了。改端口不就ok了吗？但你知道怎么改吗？可能你觉得没有必要10个端口，但WAS就是需要这么多：控制台端口两个(http，https),引导端口2089，soap、ORB，单元 cell发现….  总之，你都不知道你为什么要关心这么多端口。WLS够绝了：一个smart端口 7001全部搞定，在上走各种协议。
2、系统为你生成的上百个bat命令文件，里面交叉引用的path都是绝对路径，所以，往往你的机器重装了，那么WAS也重装吧。WLS和JBoss可以将整个文件夹移动，WAS不行，如果你喜欢折腾，当然也可以做到，就看值不值了。
控制台的部署过程
1、它总是以为我们的应用前台是httpd Server分发，于是让我们选择虚拟主机。其实，我们不是CMS系统，我们的Web前端就是WAS的web容器。
2、它总是以为我们的应用包含EJB，或是要发布成Web Services，于是让我们选择进退两难。其实，我们只是简单的Web应用。
3、它总是以为我们的应用要部署分散在多个WAS上，或者在cluster里，所以会强制要求我们选择发布目标位置。其实，我们只是用单Server。
4、它以为我们发布的应用是EAR企业包，而WAR包只是一个Web前端展示模块，所以它总是在xml配置里面写一堆。其实，我们很想手动修改配置文件。
我刚才特别部署了一个简单的web应用，就是Struts的sample，写入了29个xml配置文件。设想，保存部署文件是一个事务性的过程，如果你在大连，服务器在北京，速度超级慢，这个写入文件过程失败，呵呵，你就下地狱吧，我们碰到个几次，有一次就被迫服务器profiles重建。
虽然上面很多步骤我省略了，对于我特别说到的，虽然有默认，但每个默认页有上10个选项，而你并不是很明白这些选择的确切含义，它们是否相互冲突。
我建议WAS的设计师：请留下尽量少的发布步骤，需要定制，可以部署后修改，学学WLS吧：考虑普通开发人员的感受。
<strong>开发过程</strong>
用WAS，最好有其配套的开发工具，eclipse那个WAS插件，我试过不太好用。用RAD吧，要lisence。RAD也是个超级大户，官方推荐内存是最低768M，WAS官方推荐大概是1000M，我的1G机器也可以跑，就是慢了点。
大家如果用WAS的EJB容器，并且你想做standalone的ejb客户端，那么，千万不要选择IBM之外的JVM，我固执地试过，最后用sun的JVM成功了，但需要一堆IBM WAS下的jar，而且必须走IIOP协议，我可以说，初次使用99%的尝试是失败的。而且，此时的开发工具一定要选择IBM的 RAD或WSAD。建议，学习EJB这类分布式开发阶段，用WLS或JBoss吧，因为它们的EJB standalone客户端都支持smart stub。譬如，对于JBoss，它会通过socket先将客户端stub下载到本地，你察觉不到这个过程。大概WLS是通过反射生成stub。而WAS 必须部署过程编译一堆stub，需要引用一堆jar，sun的ejb部署大概也这样。之所以sun的简单点，那是因为你的ejb客户端jar往往自动被它加入了classpath，或者客户端是在AppServer里。
如果你要开发基于WAS的Web Services，并且用WAS内置的Web Services引擎，那么你一定要用它自己的开发工具发布和部署，我虽然成功了，只是因为太固执，付出的代价太大。
<strong>问题诊断</strong>
用WAS出问题比不出问题正常。出问题咋办？这个我暂时不说了，留给我的后文吧，总之一句话：问题独一无二。
我本人并不是说WAS做得烂，我只是想说明一点，它的使用，对我们的理论技术水平要求太高，特别不适合初学者。
———————————————————-
抛出异常的爱 写道
用的是5.只有一本。。。中文的。。
6有没有中文的红宝书？
[zwchen]像是现在还没有，我建议看它的原著吧，非常易懂，图特多，一天看200多页应该不困难。学习WAS，往往一本红皮书是不够的。市面上介绍WAS的书，大概极少有超越红皮书的。
——————————————————–
[zwchen]惭愧啊，我确实算不上高手，真正的高手在北京的IBM中国技术支持中心。我和那边的人电话和邮件聊过好多次，那才是一个字：高！
了解WAS，我随便总结一下吧：
引用</p>
<p>前提：你是项目组专门负责WAS上开发、部署、调优的，并且有与WAS抗争的决心。
1、学习WAS宝典丛书：WAS相关红皮书，前面我介绍过几本。并且多研究研究WAS的目录结构。
2、一本非红皮书，IBM内部的技术支持汇总，主要是关于诊断，但它最难吃透但最受用：《IBM® Developer Kit and Runtime Environment, Java™ 2 Technology Edition, Version 6.0  Diagnostics Guide》，500多页。
3、一定要有JVM相关技术积累：ClassLoader、GC策略，而且一定要注意它们与Sun的JVM的区别，往往WAS的问题发生在这个上面。如Sun的JVM一般建议heap的最大最小值一样，但IBM的JVM你要是这么做会导致严重的碎片问题。Why？默认的GC策略不同。
4、用JProfiler这类工具深入到WAS内部。
5、最好对JavaEE相关技术的原理有较深入的了解，譬如EJB的原理、Servlet的原理。而且，最好是这些技术怎么实现的，譬如读读Tomcat的源码,我强烈建议大家读一下这篇文章：<a href="http://www.onjava.com/pub/a/onjava/2003/05/14" target="_blank">http://www.onjava.com/pub/a/onjava/2003/05/14</a> /java_webserver.html。
整体体会，WAS的功底是在WAS之外，它只是对JVM、JavaEE规范的一个实现罢了。
另外也建议：不要花太多的时间的在WAS上，我认为非常不值。想研究，还不如去看JBoss，WLS。WAS这东西，知道一般的用法就够了，而且你永远都不可能明白它为什么有那么多的bug和不合理，明白了又能咋样？你的时间都白白浪费了。</p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/JVM/">JVM</a></li></span></span> | <span class="tags">Tagged <a href="/tags/JVM/" class="label label-primary">JVM</a><a href="/tags/Java&J2EE/" class="label label-success">Java&J2EE</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:42"datetime="2014-03-07 09:54:42"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-JVM--Java虚拟机技术总结07年写的-原JavaEye精华帖/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-JVM--Java虚拟机技术总结07年写的-原JavaEye精华帖" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_总结类--Servlet总结01——servlet的主要接口、类_javanewlearner的空间_百度空间/">Servlet总结01——servlet的主要接口、类_javanewlearner的空间_百度空间</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:42.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_总结类--Servlet总结01——servlet的主要接口、类_javanewlearner的空间_百度空间/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="servlet-01-servlet-_javanewlearner-_-">Servlet总结01——servlet的主要接口、类<em>javanewlearner的空间</em>百度空间</h1>
<p><a href="http://hi.baidu.com/"></a></p>
<ul>
<li><a href="http://hi.baidu.com/index" target="_blank">广场</a></li>
<li><a href="https://passport.baidu.com/center" target="_blank">jywv</a>
*</li>
<li><a href="https://passport.baidu.com/?logout&amp;bdstoken=aa9855a9aad4216b27441b12182ad1a7&amp;u=http://hi.baidu.com/yrynxtecldbjmxq/item/4070a6ad7af544d15bf19195" target="_blank">退出</a>
<a href="http://hi.baidu.com/yrynxtecldbjmxq/item/4070a6ad7af544d15bf19195#" target="_blank">关注此空间</a></li>
</ul>
<h1 id="-javanewlearner-http-hi-baidu-com-new-yrynxtecldbjmxq-"><a href="http://hi.baidu.com/new/yrynxtecldbjmxq" target="_blank">javanewlearner的空间</a></h1>
<p>2012-02-25 15:47</p>
<h2 id="servlet-01-servlet-">Servlet总结01——servlet的主要接口、类</h2>
<p><strong>（一）servlet类</strong></p>
<p>Servlet主要类、接口的结构如下图所示：</p>
<p><img src="" alt=""></p>
<p>要编写一个Servlet需要实现javax.servlet.Servlet接口，该接口定义了5个方法。如下：</p>
<p><img src="" alt=""></p>
<p>1.init()，初始化servlet对象，完成一些初始化工作。</p>
<p>它是由servlet容器控制的，该方法只能被调用一次，<strong>初始化过程</strong>如下：</p>
<p><img src="" alt=""></p>
<p>2.service()，接受客户端请求对象，执行业务操作，利用响应对象响应客户端请求。</p>
<p>3.destroy()，当容器监测到一个servlet从服务中被移除时，容器调用该方法，释放资源。</p>
<p>4.getServletConfig()，ServletConfig是容器向servlet传递参数的载体。</p>
<p>5.getServletInfo()，获取servlet相关信息。</p>
<p><strong>（二）与servlet相关的接口</strong></p>
<p>从servlet仅有的5个方法当中，我们知道其涉及3个接口，分别是：</p>
<p>ServletConfig</p>
<p>ServletRequest</p>
<p>ServletResponse</p>
<p>2.1. ServletConfig</p>
<p>主要方法：</p>
<p><img src="" alt=""></p>
<p>重点关注getServletContext，之前说servletConfig是容器向servlet传递参数的载体，那么它也可以让Servlet获取其在容器中的上下文。</p>
<p>ServletContext是针对一个web应用，jdk中具体描述——</p>
<p><em>There is one context per &quot;web application&quot; per Java Virtual Machine. (A &quot;web application&quot; is a collection of servlets and content installed under a specific subset of the server&#39;s URL namespace such as /catalog and possibly installed via a .war file.)</em></p>
<p>2.2.ServletRequest</p>
<p>获取客户端发来的请求数据。（查看<a href="http://download.oracle.com/javaee/5/api/javax/servlet/ServletRequest.html" target="_blank">api</a>）</p>
<p><strong><em>note：注意getAttribute和getParameter的区别。</em></strong></p>
<p><em>getAttribute( String name )可以得到由setAttribute()设置的参数值，相当于是使用getAttribute()得到一</em></p>
<p><em>个自己定义的参数，而不是从客户端得到的参数。</em></p>
<p><em>getParameter( String name )它用来获取客户端通过get或post方法等传递过来的值，是从客户端传递过来的，</em></p>
<p><em>一般指的是客户端提交的表单组件的值。</em></p>
<p><strong><em>note：setCharacterEncoding在什么时候使用才有效？</em></strong></p>
<p><em>它可以覆盖请求正文中所使用的字符编码，但是它必须在读取parameters之前设置，否则无效。</em></p>
<p>2.3.ServletResponse</p>
<p>响应客户端请求。（查看<a href="http://download.oracle.com/javaee/5/api/javax/servlet/ServletResponse.html" target="_blank">api</a>）</p>
<p><strong>（三）GenericServlet抽象类</strong></p>
<p>为了简化serlvet的编写，在javax.servlet包中提供了一个抽象类GenericServlet，它给出了除service()方法以外的简单实现。</p>
<p>GenericServlet定义了一个通用的，不依赖具体协议的Servlet，它实现了Servlet接口和ServletConfig接口。</p>
<p><strong><em>public abstract class GenericServlet implements Servlet, ServletConfig, java.io.Serializable</em></strong></p>
<p><strong>（四）HttpServlet抽象类</strong></p>
<p>HttpServlet主要是应用于HTTP协议的请求和响应，为了快速开发HTTP协议的serlvet，sun提供了一个继承自GenericServlet的抽象类HttpServlet，</p>
<p>用于创建适合Web站点的HTTP Servlet。</p>
<p><strong>public abstract class HttpServlet extends GenericServlet implements java.io.Serializable</strong></p>
<p>重点关注HttpServlet中的一个私有方法service。
protectedvoidservice(HttpServletRequest req, HttpServletResponse resp)         throwsServletException, IOException {           String method = req.getMethod();           if(method.equals(METHOD_GET)) {             longlastModified = getLastModified(req);             if(lastModified == -1) {                 // servlet doesn&#39;t support if-modified-since, no reason                 // to go through further expensive logic                 doGet(req, resp);             } else{                 longifModifiedSince = req.getDateHeader(HEADER_IFMODSINCE);                 if(ifModifiedSince &lt; (lastModified / 1000/* 1000)) {                     // If the servlet mod time is later, call doGet()                     // Round down to the nearest second for a proper compare                     // A ifModifiedSince of -1 will always be less                     maybeSetLastModified(resp, lastModified);                     doGet(req, resp);                 } else{                     resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED);                 }             }           } elseif(method.equals(METHOD_HEAD)) {             longlastModified = getLastModified(req);             maybeSetLastModified(resp, lastModified);             doHead(req, resp);           } elseif(method.equals(METHOD_POST)) {             doPost(req, resp);                       } elseif(method.equals(METHOD_PUT)) {             doPut(req, resp);                               } elseif(method.equals(METHOD_DELETE)) {             doDelete(req, resp);                       } elseif(method.equals(METHOD_OPTIONS)) {             doOptions(req,resp);                       } elseif(method.equals(METHOD_TRACE)) {             doTrace(req,resp);                       } else{             //             // Note that this means NO servlet supports whatever             // method was requested, anywhere on this server.             //               String errMsg = lStrings.getString(&quot;http.method_not_implemented&quot;);             Object[] errArgs = newObject[1];             errArgs[0] = method;             errMsg = MessageFormat.format(errMsg, errArgs);                           resp.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED, errMsg);         }     }</p>
<p>而它实现Servlet接口的service方法，是将ServletResponse对象和ServletRequest对象转化成httpServletResponse对象和HttpservletRequest对象，</p>
<p>然后再调用私有方法service。它根据request获取Http method(get、post等)的名称，根据http method调用不同的方法执行操作。</p>
<p><strong>（五）HttpServletRequest、HttpServletResponse</strong></p>
<p>由于HttpServletRequest和HttpServletResponse都是基于Http协议“升级改造”的，所以这两个对象较之ServletRequest和ServletResponse多出的方法主要和</p>
<p>Http协议相关。</p>
<p>例如：Cookie、request（response）headers、Session、URL等。</p>
<p>具体请查看api。</p>
<p><strong>（六）重点</strong></p>
<p>6.1.servlet的生命周期。</p>
<p>6.2.servlet的上下文。
<a href="http://hi.baidu.com/tag/J2ee/feeds" target="_blank">/#J2ee</a></p>
<p><a href="http://hi.baidu.com/yrynxtecldbjmxq/item/4070a6ad7af544d15bf19195#" target="_blank">举报</a>浏览(5) <a href="http://hi.baidu.com/yrynxtecldbjmxq/item/4070a6ad7af544d15bf19195#" target="_blank">评论</a><a href="http://hi.baidu.com/yrynxtecldbjmxq/item/4070a6ad7af544d15bf19195#" target="_blank">转载</a></p>
<p><a href="http://hi.baidu.com/yrynxtecldbjmxq/item/da67bbe6ad8d7adbea34c991" title="上一篇"></a></p>
<p><a href="http://hi.baidu.com/yrynxtecldbjmxq/item/3aaa4928228f59846e2cc391" title="下一篇"></a>
评论
<a href="http://hi.baidu.com/go/show/introduce" target="_blank">帮助中心</a> | <a href="http://tieba.baidu.com/p/1781683739" target="_blank">空间客服</a> | <a href="http://tousu.baidu.com/hi/add" target="_blank">投诉中心</a> | <a href="http://www.baidu.com/search/hi_contract.html" target="_blank">空间协议</a></p>
<p>©2012 Baidu</p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/Java_总结类/">Java_总结类</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/Java_总结类/" class="label label-success">Java_总结类</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:42"datetime="2014-03-07 09:54:42"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-Java_总结类--Servlet总结01——servlet的主要接口、类_javanewlearner的空间_百度空间/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-Java_总结类--Servlet总结01——servlet的主要接口、类_javanewlearner的空间_百度空间" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--虚拟机随谈（一）：解释器，树遍历解释器，基于栈与基于寄存器，大杂烩/">虚拟机随谈（一）：解释器，树遍历解释器，基于栈与基于寄存器，大杂烩</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:42.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--虚拟机随谈（一）：解释器，树遍历解释器，基于栈与基于寄存器，大杂烩/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-">虚拟机随谈（一）：解释器，树遍历解释器，基于栈与基于寄存器，大杂烩</h1>
<p>（Disclaimer：如果需要转载请先与我联系；文中图片请不要直接链接
作者：<a href="http://weibo.com/rednaxelafx" target="_blank">@RednaxelaFX</a> -&gt; <a href="http://rednaxelafx.iteye.com/" target="_blank"><a href="http://rednaxelafx.iteye.com">http://rednaxelafx.iteye.com</a></a>）
大前天收到一条PM：
引用</p>
<p>你好，很冒昧的向你发短消息，我现在在看JS引擎，能过看博客发现你对js engine很了解，我想请教一下你 基于栈的解析器与基于寄存器的解析器有什么同，javascriptcore是基于寄存器的，V8是基于栈的，能不能说一下这两者有什么一样吗？能推荐一点资料吗？谢谢。
我刚收到的时候很兴奋，就开始写回复。写啊写发觉已经比我平时发的帖还要长了，想着干脆把回复直接发出来好了。于是下面就是回复：
你好 ^ ^ 很抱歉拖了这么久才回复。码字和画图太耗时间了。
别说冒昧了，我只是个普通的刚毕业的学生而已，担当不起啊 =<em>=||||
而且我也不敢说“很”了解，只是有所接触而已。很高兴有人来一起讨论JavaScript引擎的设计与实现，总觉得身边对这个有兴趣的人不多，或者是很少冒出来讨论。如果你发个帖或者blog来讨论这方面的内容我也会很感兴趣的～
想拿出几点来讨论一下。上面提出的问题我希望能够一一给予回答，不过首先得做些铺垫。
另外先提一点：JavaScriptCore从SquirrelFish版开始是“基于寄存器”的，V8则不适合用“基于栈”或者“基于寄存器”的说法来描述。
<strong>1、解析器与解释器</strong>
解析器是parser，而解释器是interpreter。两者不是同一样东西，不应该混用。
前者是编译器/解释器的重要组成部分，也可以用在IDE之类的地方；其主要作用是进行语法分析，提取出句子的结构。广义来说输入一般是程序的源码，输出一般是语法树（syntax tree，也叫parse tree等）或抽象语法树（abstract syntax tree，AST）。进一步剥开来，广义的解析器里一般会有扫描器（scanner，也叫tokenizer或者lexical analyzer，词法分析器），以及狭义的解析器（parser，也叫syntax analyzer，语法分析器）。扫描器的输入一般是文本，经过词法分析，输出是将文本切割为单词的流。狭义的解析器输入是单词的流，经过语法分析，输出是语法树或者精简过的AST。
（在一些编译器/解释器中，解析也可能与后续的语义分析、代码生成或解释执行等步骤融合在一起，不一定真的会构造出完整的语法树。但概念上说解析器就是用来抽取句子结构用的，而语法树就是表示句子结构的方式。关于边解析边解释执行的例子，可以看看<a href="http://rednaxelafx.iteye.com/blog/472113" target="_blank">这帖</a>的计算器。）
举例：将i = a + b /* c作为源代码输入到解析器里，则广义上的解析器的工作流程如下图：
<img src="" alt="">
其中词法分析由扫描器完成，语法分析由狭义的解析器完成。
（嗯，说来其实“解析器”这词还是按狭义用法比较准确。把扫描器和解析器合起来叫解析器总觉得怪怪的，但不少人这么用，这里就将就下吧 =</em>=
不过近来“<a href="http://en.wikipedia.org/wiki/Scannerless_parsing" target="_blank">scannerless parsing</a>”也挺流行的：不区分词法分析与语法分析，没有单独的扫描器，直接用解析器从源码生成语法树。这倒整个就是解析器了，没狭不狭义的问题）
后者则是实现程序执行的一种实现方式，与编译器相对。它直接实现程序源码的语义，输入是程序源码，输出则是执行源码得到的计算结果；编译器的输入与解释器相同，而输出是用别的语言实现了输入源码的语义的程序。通常编译器的输入语言比输出语言高级，但不一定；也有输入输出是同种语言的情况，此时编译器很可能主要用于优化代码。
举例：把同样的源码分别输入到编译器与解释器中，得到的输出不同：
<img src="" alt="">
值得留意的是，编译器生成出来的代码执行后的结果应该跟解释器输出的结果一样——它们都应该实现源码所指定的语义。
在很多地方都看到解析器与解释器两个不同的东西被混为一谈，感到十分无奈。
最近某本引起很多关注的书便在开篇给读者们当头一棒，介绍了“<a href="http://www.fecit.com.cn/%E7%AC%AC1%E7%AB%A0_%E4%B8%8E%E5%88%9D%E5%AD%A6%E8%80%85%E8%B0%88%E8%B0%88JavaScript%E5%AD%A6%E4%B9%A0.pdf" target="_blank">JavaScript解析机制</a>”。“编译”和“预处理”也顺带混为一谈了，还有“预编译” 0_0
我一直以为“预编译”应该是<a href="http://en.wikipedia.org/wiki/AOT_compiler" target="_blank">ahead-of-time compilation</a>的翻译，是与“即时编译”（just-in-time compilation，JIT）相对的概念。另外就是PCH（precompile header）这种用法，把以前的编译结果缓存下来称为“预编译”。把AOT、PCH跟“预处理”（<a href="http://en.wikipedia.org/wiki/Preprocessor" target="_blank">preprocess</a>）混为一谈真是诡异。算了，我还是不要淌这浑水的好……打住。
<strong>2、“解释器”到底是什么？“解释型语言”呢？</strong>
很多资料会说，Python、Ruby、JavaScript都是“解释型语言”，是通过解释器来实现的。这么说其实很容易引起误解：语言一般只会定义其抽象语义，而不会强制性要求采用某种实现方式。
例如说C一般被认为是“编译型语言”，但C的解释器也是存在的，例如<a href="http://www.softintegration.com/" target="_blank">Ch</a>。同样，C++也有解释器版本的实现，例如<a href="http://root.cern.ch/drupal/content/cint" target="_blank">Cint</a>。
一般被称为“解释型语言”的是主流实现为解释器的语言，但并不是说它就无法编译。例如说经常被认为是“解释型语言”的<a href="http://schemers.org/" target="_blank">Scheme</a>就有好几种编译器实现，其中率先支持<a href="http://www.r6rs.org/" target="_blank">R6RS</a>规范的大部分内容的是<a href="http://ikarus-scheme.org/" target="_blank">Ikarus</a>，支持在x86上编译Scheme；它最终不是生成某种虚拟机的字节码，而是直接生成x86机器码。
解释器就是个黑箱，输入是源码，输出就是输入程序的执行结果，对用户来说中间没有独立的“编译”步骤。这非常抽象，内部是怎么实现的都没关系，只要能实现语义就行。你可以写一个C语言的解释器，里面只是先用普通的C编译器把源码编译为in-memory image，然后直接调用那个image去得到运行结果；用户拿过去，发现直接输入源码可以得到源程序对应的运行结果就满足需求了，无需在意解释器这个“黑箱子”里到底是什么。
实际上很多解释器内部是以“编译器+虚拟机”的方式来实现的，先通过编译器将源码转换为AST或者字节码，然后由虚拟机去完成实际的执行。所谓“解释型语言”并不是不用编译，而只是不需要用户显式去使用编译器得到可执行代码而已。
那么虚拟机（<a href="http://en.wikipedia.org/wiki/Virtual_machine" target="_blank">virtual machine</a>，VM）又是什么？在许多不同的场合，VM有着不同的意义。如果上下文是Java、Python这类语言，那么一般指的是高级语言虚拟机（high-level language virtual machine，HLL VM），其意义是实现高级语言的语义。VM既然被称为“机器”，一般认为输入是满足某种指令集架构（<a href="http://en.wikipedia.org/wiki/Instruction_set" target="_blank">instruction set architecture</a>，ISA）的指令序列，中间转换为目标ISA的指令序列并加以执行，输出为程序的执行结果的，就是VM。源与目标ISA可以是同一种，这是所谓same-ISA VM。
前面提到解释器中的编译器的输出可能是AST，也可能是字节码之类的指令序列；一般会把执行后者的程序称为VM，而执行前者的还是笼统称为解释器或者树遍历式解释器（tree-walking interpreter）。这只是种习惯而已，并没有多少确凿的依据。只不过线性（相对于树形）的指令序列看起来更像一般真正机器会执行的指令序列而已。
其实我觉得把执行AST的也叫VM也没啥大问题。如果认同这个观点，那么把<a href="http://rednaxelafx.iteye.com/blog/241430" target="_blank">DLR</a>看作一种VM也就可以接受了——它的“指令集”就是树形的Expression Tree。
VM并不是神奇的就能执行代码了，它也得采用某种方式去实现输入程序的语义，并且同样有几种选择：“编译”，例如微软的.NET中的CLR；“解释”，例如CPython、CRuby 1.9，许多老的JavaScript引擎等；也有介于两者之间的混合式，例如Sun的JVM，<a href="http://en.wikipedia.org/wiki/HotSpot" target="_blank">HotSpot</a>。如果采用编译方式，VM会把输入的指令先转换为某种能被底下的系统直接执行的形式（一般就是native code），然后再执行之；如果采用解释方式，则VM会把输入的指令逐条直接执行。
换个角度说，我觉得采用编译和解释方式实现虚拟机最大的区别就在于是否存下目标代码：编译的话会把输入的源程序以某种单位（例如<a href="http://en.wikipedia.org/wiki/Basic_block" target="_blank">基本块</a>/函数/方法/trace等）翻译生成为目标代码，并存下来（无论是存在内存中还是磁盘上，无所谓），后续执行可以复用之；解释的话则是把源程序中的指令逐条解释，不生成也不存下目标代码，后续执行没有多少可复用的信息。有些稍微先进一点的解释器可能会优化输入的源程序，把满足某些模式的指令序列合并为“超级指令”；这么做就是朝着编译的方向推进。后面讲到解释器的演化时再讨论超级指令吧。
如果一种语言的主流实现是解释器，其内部是编译器+虚拟机，而虚拟机又是采用解释方式实现的，或者内部实现是编译器+树遍历解释器，那它就是名副其实的“解释型语言”。如果内部用的虚拟机是用编译方式实现的，其实跟普遍印象中的“解释器”还是挺不同的……
可以举这样一个例子：ActionScript 3，一般都被认为是“解释型语言”对吧？但这种观点到底是把FlashPlayer整体看成一个解释器，因而AS3是“解释型语言”呢？还是认为FlashPlayer中的虚拟机采用解释执行方案，因而AS3是“解释型语言”呢？
其实Flash或Flex等从AS3生成出来的SWF文件里就包含有AS字节码（ActionScript Byte Code，ABC）。等到FlashPlayer去执行SWF文件，或者说等到AVM2（ActionScript Virtual Machine 2）去执行ABC时，又有解释器和JIT编译器两种实现。这种需要让用户显式进行编译步骤的语言，到底是不是“解释型语言”呢？呵呵。所以我一直觉得“编译型语言”跟“解释型语言”的说法太模糊，不太好。
有兴趣想体验一下从命令行编译“裸”的AS3文件得到ABC文件，再从命令行调用AVM2去执行ABC文件的同学，可以从<a href="http://rednaxelafx.iteye.com/blog/196278" target="_blank">这帖</a>下载我之前从源码编译出来的AVM2，自己玩玩看。例如说要编译一个名为test.as的文件，用下列命令：
Command prompt代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>java -jar asc.jar -import builtin.abc -import toplevel.abc test.as  </li>
</ol>
<p>java -jar asc.jar -import builtin.abc -import toplevel.abc test.as
就是用ASC将test.as编译，得到test.abc。接着用：
Command prompt代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>avmplus test.abc  </li>
</ol>
<p>avmplus test.abc
就是用AVM2去执行程序了。很生动的体现出“编译器+虚拟机”的实现方式。
这个“裸”的AVM2没有带Flash或Flex的类库，能用的函数和类都有限。不过AS3语言实现是完整的。可以用print()函数来向标准输出流写东西。
Well……其实写Java程序不也是这样么？现在也确实还有很多人把Java称为“解释型语言”，完全无视Java代码通常是经过显式编译步骤才得到.class文件，而有些JVM是采用纯JIT编译方式实现的，内部没解释器，例如JRockit、<a href="https://wikis.oracle.com/display/MaxineVM/Home" target="_blank">Maxine VM</a>和<a href="http://jikesrvm.org/" target="_blank">Jikes RVM</a>。我愈发感到“解释型语言”是个应该避开的用语 =_=
关于虚拟机，有本很好的书绝对值得一读，《虚拟机——系统与进程的通用平台》（Virtual Machines: Versatile Platforms for Systems and Processes）。国内有影印版也有中文版，我是读了影印版，不太清楚中文版的翻译质量如何。据说翻译得还行，我无法印证。
<strong>3、基于栈与基于寄存器的指令集架构</strong>
用C的语法来写这么一个语句：
C代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>a = b + c;  </li>
</ol>
<p>a = b + c;
如果把它变成这种形式：
add a, b, c
那看起来就更像机器指令了，对吧？这种就是所谓“三地址指令”（3-address instruction），一般形式为：
op dest, src1, src2
许多操作都是二元运算+赋值。三地址指令正好可以指定两个源和一个目标，能非常灵活的支持二元操作与赋值的组合。ARM处理器的主要指令集就是三地址形式的。
C里要是这样写的话：
C代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>a += b;  </li>
</ol>
<p>a += b;
变成:
add a, b
这就是所谓“二地址指令”，一般形式为：
op dest, src
它要支持二元操作，就只能把其中一个源同时也作为目标。上面的add a, b在执行过后，就会破坏a原有的值，而b的值保持不变。x86系列的处理器就是二地址形式的。
上面提到的三地址与二地址形式的指令集，一般就是通过“基于寄存器的架构”来实现的。例如典型的RISC架构会要求除load和store以外，其它用于运算的指令的源与目标都要是寄存器。
显然，指令集可以是任意“n地址”的，n属于自然数。那么一地址形式的指令集是怎样的呢？
想像一下这样一组指令序列：
add 5
sub 3
这只指定了操作的源，那目标是什么？一般来说，这种运算的目标是被称为“累加器”（accumulator）的专用寄存器，所有运算都靠更新累加器的状态来完成。那么上面两条指令用C来写就类似：
C代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>acc += 5;  </li>
<li>acc -= 3;  </li>
</ol>
<p>acc += 5;</p>
<p>acc -= 3;
只不过acc是“隐藏”的目标。基于累加器的架构近来比较少见了，在很老的机器上繁荣过一段时间。
那“n地址”的n如果是0的话呢？
看这样一段Java字节码：
Java bytecode代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>iconst_1  </li>
<li>iconst_2  </li>
<li>iadd  </li>
<li>istore_0  </li>
</ol>
<p>iconst_1</p>
<p>iconst_2
iadd</p>
<p>istore_0
注意那个iadd（表示整型加法）指令并没有任何参数。连源都无法指定了，零地址指令有什么用？？
零地址意味着源与目标都是隐含参数，其实现依赖于一种常见的数据结构——没错，就是栈。上面的iconst_1、iconst_2两条指令，分别向一个叫做“求值栈”（evaluation stack，也叫做operand stack“操作数栈”或者expression stack“表达式栈”）的地方压入整型常量1、2。iadd指令则从求值栈顶弹出2个值，将值相加，然后把结果压回到栈顶。istore_0指令从求值栈顶弹出一个值，并将值保存到局部变量区的第一个位置（slot 0）。
零地址形式的指令集一般就是通过“基于栈的架构”来实现的。请一定要注意，这个栈是指“求值栈”，而不是与系统调用栈（system call stack，或者就叫system stack）。千万别弄混了。有些虚拟机把求值栈实现在系统调用栈上，但两者概念上不是一个东西。
由于指令的源与目标都是隐含的，零地址指令的“密度”可以非常高——可以用更少空间放下更多条指令。因此在空间紧缺的环境中，零地址指令是种可取的设计。但零地址指令要完成一件事情，一般会比二地址或者三地址指令许多更多条指令。上面Java字节码做的加法，如果用x86指令两条就能完成了：
X86 asm代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>mov  eax, 1  </li>
<li>add  eax, 2  </li>
</ol>
<p>mov  eax, 1</p>
<p>add  eax, 2
（好吧我犯规了，istore<em>0对应的保存我没写。但假如局部变量比较少的话也不必把EAX的值保存（“溢出”，register spilling）到调用栈上，就这样吧 =</em>=
其实就算把结果保存到栈上也就是多一条指令而已……）
一些比较老的解释器，例如<a href="http://www.ruby-lang.org/" target="_blank">CRuby</a>在1.9引入<a href="http://www.atdot.net/yarv/" target="_blank">YARV</a>作为新的VM之前的解释器，还有SquirrleFish之前的老JavaScriptCore以及它的前身KJS，它们内部是树遍历式解释器；解释器递归遍历树，树的每个节点的操作依赖于解释其各个子节点返回的值。这种解释器里没有所谓的求值栈，也没有所谓的虚拟寄存器，所以不适合以“基于栈”或“基于寄存器”去描述。
而像V8那样直接编译JavaScript生成机器码，而不通过中间的字节码的中间表示的JavaScript引擎，它内部有虚拟寄存器的概念，但那只是普通native编译器的正常组成部分。我觉得也不应该用“基于栈”或“基于寄存器”去描述它。
V8在内部也用了“求值栈”（在V8里具体叫“表达式栈”）的概念来简化生成代码的过程，在编译过程中进行“抽象解释”，使用所谓“虚拟栈帧”来记录局部变量与求值栈的状态；但在真正生成代码的时候会做窥孔优化，消除冗余的push/pop，将许多对求值栈的操作转变为对寄存器的操作，以此提高代码质量。于是最终生成出来的代码看起来就不像是基于栈的代码了。
关于JavaScript引擎的实现方式，下文会再提到。
<strong>4、基于栈与基于寄存器架构的VM，用哪个好？</strong>
如果是要模拟现有的处理器，那没什么可选的，原本处理器采用了什么架构就只能以它为源。但HLL VM的架构通常可以自由构造，有很大的选择余地。为什么许多主流HLL VM，诸如JVM、CLI、CPython、CRuby 1.9等，都采用了基于栈的架构呢？我觉得这有三个主要原因：
·实现简单
由于指令中不必显式指定源与目标，VM可以设计得很简单，不必考虑为临时变量分配空间的问题，求值过程中的临时数据存储都让求值栈包办就行。
更新：回帖中cscript指出了这句不太准确，应该是针对基于栈架构的指令集生成代码的编译器更容易实现，而不是VM更容易实现。
·该VM是为某类资源非常匮乏的硬件而设计的
这类硬件的存储器可能很小，每一字节的资源都要节省。零地址指令比其它形式的指令更紧凑，所以是个自然的选择。
·考虑到可移植性
处理器的特性各个不同：典型的CISC处理器的通用寄存器数量很少，例如32位的<a href="http://en.wikipedia.org/wiki/X86" target="_blank">x86</a>就只有8个32位通用寄存器（如果不算EBP和ESP那就是6个，现在一般都算上）；典型的RISC处理器的各种寄存器数量多一些，例如<a href="http://en.wikipedia.org/wiki/ARM_architecture" target="_blank">ARM</a>有16个32位通用寄存器，Sun的<a href="http://en.wikipedia.org/wiki/SPARC" target="_blank">SPARC</a>在一个寄存器窗口里则有24个通用寄存器（8 in，8 local，8 out）。
假如一个VM采用基于寄存器的架构（它接受的指令集大概就是二地址或者三地址形式的），为了高效执行，一般会希望能把源架构中的寄存器映射到实际机器上寄存器上。但是VM里有些很重要的辅助数据会经常被访问，例如一些VM会保存源指令序列的程序计数器（program counter，PC），为了效率，这些数据也得放在实际机器的寄存器里。如果源架构中寄存器的数量跟实际机器的一样，或者前者比后者更多，那源架构的寄存器就没办法都映射到实际机器的寄存器上；这样VM实现起来比较麻烦，与能够全部映射相比效率也会大打折扣。像Dalvik VM的解释器实现，就是把虚拟寄存器全部映射到栈帧（内存）里的，这跟把局部变量区与操作数栈都映射到内存里的JVM解释器实现相比实际区别不太大。
如果一个VM采用基于栈的架构，则无论在怎样的实际机器上，都很好实现——它的源架构里没有任何通用寄存器，所以实现VM时可以比较自由的分配实际机器的寄存器。于是这样的VM可移植性就比较高。作为优化，基于栈的VM可以用编译方式实现，“求值栈”实际上也可以由编译器映射到寄存器上，减轻数据移动的开销。
回到主题，基于栈与基于寄存器的架构，谁更快？看看现在的实际处理器，大多都是基于寄存器的架构，从侧面反映出它比基于栈的架构更优秀。
而对于VM来说，源架构的求值栈或者寄存器都可能是用实际机器的内存来模拟的，所以性能特性与实际硬件又有点不同。一般认为基于寄存器的架构对VM来说也是更快的，原因是：虽然零地址指令更紧凑，但完成操作需要更多的load/store指令，也意味着更多的指令分派（instruction dispatch）次数与内存访问次数；访问内存是执行速度的一个重要瓶颈，二地址或三地址指令虽然每条指令占的空间较多，但总体来说可以用更少的指令完成操作，指令分派与内存访问次数都较少。
这方面有篇被引用得很多的论文讲得比较清楚，<a href="http://www.usenix.org/events/vee05/full_papers/p153-yunhe.pdf" target="_blank">Virtual Machine Showdown: Stack Versus Registers</a>，是在VEE 2005发表的。VEE是Virtual Execution Environment的缩写，是ACM下SIGPLAN组织的一个会议，专门研讨虚拟机的设计与实现的。可以去找找这个会议往年的论文，很多都值得读。
<strong>5、树遍历解释器图解</strong>
在演示基于栈与基于寄存器的VM的例子前，先回头看看更原始的解释器形式。
前面提到解析器的时候用了i = a + b /<em> c的例子，现在让我们来看看由解析器生成的AST要是交给一个树遍历解释器，会如何被解释执行呢？
用文字说不够形象，还是看图吧：
<img src="" alt="">
这是对AST的后序遍历：假设有一个eval(Node n)函数，用于解释AST上的每个节点；在解释一个节点时如果依赖于子树的操作，则对子节点递归调用eval(Node n)，从这些递归调用的返回值获取需要的值（或副作用）——也就是说子节点都eval好了之后，父节点才能进行自己的eval——典型的后序遍历。
（话说，上图中节点左下角有蓝色标记的说明那是节点的“内在属性”。从<a href="http://en.wikipedia.org/wiki/Attribute_grammar" target="_blank">属性语法</a>的角度看，如果一个节点的某个属性的值只依赖于自身或子节点，则该属性被称为“综合属性”（synthesized attribute）；如果一个节点的某个属性只依赖于自身、父节点和兄弟节点，则该属性被称为“继承属性”（inherited attribute）。上图中节点右下角的红色标记都只依赖子节点来计算，显然是综合属性。）
SquirrelFish之前的JavaScriptCore、CRuby 1.9之前的CRuby就都是采用这种方式来解释执行的。
可能需要说明的：
·左值与右值
在源代码i = a + b /</em> c中，赋值符号左侧的i是一个标识符，表示一个变量，取的是变量的“左值”（也就是与变量i绑定的存储单元）；右侧的a、b、c虽然也是变量，但取的是它们的右值（也就是与变量绑定的存储单元内的值）。在许多编程语言中，左值与右值在语法上没有区别，它们实质的差异容易被忽视。一般来说左值可以作为右值使用，反之则不一定。例如数字1，它自身有值就是1，可以作为右值使用；但它没有与可赋值的存储单元相绑定，所以无法作为左值使用。
左值不一定只是简单的变量，还可以是数组元素或者结构体的域之类，可能由复杂的表达式所描述。因此左值也是需要计算的。
·优先级、结合性与求值顺序
这三个是不同的概念，却经常被混淆。通过AST来看就很容易理解：（假设源码是从左到右输入的）
所谓<strong>优先级</strong>，就是不同操作相邻出现时，AST节点与根的距离的关系。优先级高的操作会更远离根，优先级低的操作会更接近根。为什么？因为整棵AST是以后序遍历求值的，显然节点离根越远就越早被求值。
所谓<strong>结合性</strong>，就是当同类操作相邻出现时，操作的先后顺序同AST节点与根的距离的关系。如果是左结合，则先出现的操作对应的AST节点比后出现的操作的节点离根更远；换句话说，先出现的节点会是后出现节点的子节点。
所谓<strong>求值顺序</strong>，就是在遍历子节点时的顺序。对二元运算对应的节点来说，先遍历左子节点再遍历右子节点就是左结合，反之则是右结合。
这三个概念与运算的联系都很紧密，但实际描述的是不同的关系。前两者是解析器根据语法生成AST时就已经决定好的，后者则是解释执行或者生成代码而去遍历AST时决定的。
在没有副作用的环境中，给定优先级与结合性，则无论求值顺序是怎样的都能得到同样的结果；而在有副作用的环境中，求值顺序会影响结果。
赋值运算虽然是右结合的，但仍然可以用从左到右的求值顺序；事实上Java、C/#等许多语言都在规范里写明表达式的求值顺序是从左到右的。上面的例子中就先遍历的=的左侧，求得i的左值；再遍历=的右侧，得到表达式的值23；最后执行=自身，完成对i的赋值。
所以如果你要问：赋值在类似C的语言里明明是右结合的运算，为什么你先遍历左子树再遍历右子树？上面的说明应该能让你发现你把结合性与求值顺序混为一谈了。
看看Java从左到右求值顺序的例子：
Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>public class EvalOrderDemo {  </li>
<li>public static void main(String[] args) {  </li>
<li>int[] arr = new int[1];  </li>
<li>int a = 1;  </li>
<li>int b = 2;  </li>
<li>arr[0] = a + b;  </li>
<li>}  </li>
<li>}  </li>
</ol>
<p>public class EvalOrderDemo {</p>
<pre><code>public static void main(String[] args) {
    int[] arr = new int[1];

    int a = 1;
    int b = 2;

    arr[0] = a + b;
}
</code></pre><p>}
由javac编译，得到arr[0] = a + b对应的字节码是：
Java bytecode代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>// 左子树：数组下标  </li>
<li>// a[0]  </li>
<li>aload_1  </li>
<li>iconst_0  </li>
<li></li>
<li>// 右子树：加法  </li>
<li>// a  </li>
<li>iload_2  </li>
<li>// b  </li>
<li>iload_3  </li>
<li>// +  </li>
<li>iadd  </li>
<li></li>
<li>// 根节点：赋值  </li>
<li>iastore  </li>
</ol>
<p>// 左子树：数组下标</p>
<p>// a[0]
aload_1</p>
<p>iconst_0</p>
<p>// 右子树：加法
// a</p>
<p>iload_2
// b</p>
<p>iload_3
// +</p>
<p>iadd</p>
<p>// 根节点：赋值
iastore
<strong>6、从树遍历解释器进化为基于栈的字节码解释器的前端</strong>
如果你看到树形结构与后序遍历，并且知道后缀记法（或者逆波兰记法，<a href="http://en.wikipedia.org/wiki/Reverse_Polish_notation" target="_blank">reverse Polish notation</a>）的话，那敏锐的你或许已经察觉了：要解释执行AST，可以先通过后序遍历AST生成对应的后缀记法的操作序列，然后再解释执行该操作序列。这样就把树形结构压扁，成为了线性结构。
树遍历解释器对AST的求值其实隐式依赖于调用栈：eval(Node n)的递归调用关系是靠调用栈来维护的。后缀表达式的求值则通常显式依赖于一个栈，在遇到操作数时将其压入栈中，遇到运算时将合适数量的值从栈顶弹出进行运算，再将结果压回到栈上。这种描述看起来眼熟么？没错，后缀记法的求值中的核心数据结构就是前文提到过的“求值栈”（或者叫操作数栈，现在应该更好理解了）。后缀记法也就与基于栈的架构联系了起来：后者可以很方便的执行前者。同理，零地址指令也与树形结构联系了起来：可以通过一个栈方便的把零地址指令序列再转换回到树的形式。
Java字节码与Java源码联系紧密，前者可以看成后者的后缀记法。如果想在JVM上开发一种语义能直接映射到Java上的语言，那么编译器很好写：秘诀就是后序遍历AST。
那么让我们再来看看，同样是i = a + b /<em> c这段源码对应的AST，生成Java字节码的例子：
<img src="" alt="">
（假设a、b、c、i分别被分配到局部变量区的slot 0到slot 3）
能看出Java字节码与源码间的对应关系了么？
一个Java编译器的输入是Java源代码，输出是含有Java字节码的.class文件。它里面主要包含扫描器与解析器，语义分析器（包括类型检查器/类型推导器等），代码生成器等几大部分。上图所展示的就是代码生成器的工作。对Java编译器来说，代码生成就到字节码的层次就结束了；而对native编译器来说，这里刚到生成中间表示的部分，接下去是优化与最终的代码生成。
如果你对<a href="http://rednaxelafx.iteye.com/blog/382412" target="_blank">Python</a>、<a href="http://lifegoo.pluskid.org/upload/doc/yarv/yarv_iset.html" target="_blank">CRuby 1.9</a>之类有所了解，会发现它们的字节码跟Java字节码在“基于栈”的这一特征上非常相似。其实它们都是由“编译器+VM”构成的，概念上就像是Java编译器与JVM融为一体一般。
从这点看，Java与Python和Ruby可以说是一条船上的。虽说内部具体实现的显著差异使得先进的JVM比简单的JVM快很多，而JVM又普遍比Python和Ruby快很多。
当解释器中用于解释执行的中间代码是树形时，其中能被称为“编译器”的部分基本上就是解析器；中间代码是线性形式（如字节码）时，其中能被称为编译器的部分就包括上述的代码生成器部分，更接近于所谓“完整的编译器”；如果虚拟机是基于寄存器架构的，那么编译器里至少还得有虚拟寄存器分配器，又更接近“完整的编译器”了。
<em>*7、基于栈与基于寄存器架构的VM的一组图解</em></em>
要是拿两个分别实现了基于栈与基于寄存器架构、但没有直接联系的VM来对比，效果或许不会太好。现在恰巧有两者有紧密联系的例子——JVM与Dalvik VM。JVM的字节码主要是零地址形式的，概念上说JVM是基于栈的架构。Google Android平台上的应用程序的主要开发语言是Java，通过其中的<a href="http://en.wikipedia.org/wiki/Dalvik_virtual_machine" target="_blank">Dalvik VM</a>来运行Java程序。为了能正确实现语义，Dalvik VM的许多设计都考虑到与JVM的兼容性；但它却采用了基于寄存器的架构，其字节码主要是二地址/三地址混合形式的，乍一看可能让人纳闷。考虑到Android有明确的目标：面向移动设备，特别是最初要对ARM提供良好的支持。ARM9有16个32位通用寄存器，Dalvik VM的架构也常用16个虚拟寄存器（一样多……没办法把虚拟寄存器全部直接映射到硬件寄存器上了）；这样Dalvik VM就不用太顾虑可移植性的问题，优先考虑在ARM9上以高效的方式实现，发挥基于寄存器架构的优势。
Dalvik VM的主要设计者<a href="http://www.milk.com/home/danfuzz/" target="_blank">Dan Bornstein</a>在Google I/O 2008上做过一个<a href="http://sites.google.com/site/io/dalvik-vm-internals" target="_blank">关于Dalvik内部实现</a>的演讲；同一演讲也在Google Developer Day 2008 China和Japan等会议上重复过。这个演讲中Dan特别提到了Dalvik VM与JVM在字节码设计上的区别，指出Dalvik VM的字节码可以用更少指令条数、更少内存访问次数来完成操作。（看不到YouTube的请自行想办法）
眼见为实。要自己动手感受一下该例子，请先确保已经正确安装JDK 6，并从<a href="http://developer.android.com/sdk/" target="_blank">官网</a>获取Android SDK 1.6R1。连不上官网的也请自己想办法。
创建Demo.java文件，内容为：
Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>public class Demo {  </li>
<li>public static void foo() {  </li>
<li>int a = 1;  </li>
<li>int b = 2;  </li>
<li>int c = (a + b) /* 5;  </li>
<li>}  </li>
<li>}  </li>
</ol>
<p>public class Demo {</p>
<pre><code>public static void foo() {
    int a = 1;

    int b = 2;
    int c = (a + b) /* 5;

}
</code></pre><p>}
通过javac编译，得到Demo.class。通过javap可以看到foo()方法的字节码是：
Java bytecode代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>0:  iconst_1  </li>
<li>1:  istore_0  </li>
<li>2:  iconst_2  </li>
<li>3:  istore_1  </li>
<li>4:  iload_0  </li>
<li>5:  iload_1  </li>
<li>6:  iadd  </li>
<li>7:  iconst_5  </li>
<li>8:  imul  </li>
<li>9:  istore_2  </li>
<li>10: return  </li>
</ol>
<p>0:  iconst_1</p>
<p>1:  istore_0
2:  iconst_2</p>
<p>3:  istore_1
4:  iload_0</p>
<p>5:  iload_1
6:  iadd</p>
<p>7:  iconst_5
8:  imul</p>
<p>9:  istore_2
10: return
接着用Android SDK里platforms\android-1.6\tools目录中的dx工具将Demo.class转换为dex格式。转换时可以直接以文本形式dump出dex文件的内容。使用下面的命令：
Command prompt代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>dx --dex --verbose --dump-to=Demo.dex.txt --dump-method=Demo.foo --verbose-dump Demo.class  </li>
</ol>
<p>dx --dex --verbose --dump-to=Demo.dex.txt --dump-method=Demo.foo --verbose-dump Demo.class
可以看到foo()方法的字节码是：
Dalvik bytecode代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>0000: const/4       v0, /#int 1 // /#1  </li>
<li>0001: const/4       v1, /#int 2 // /#2  </li>
<li>0002: add-int/2addr v0, v1  </li>
<li>0003: mul-int/lit8  v0, v0, /#int 5 // /#05  </li>
<li>0005: return-void  </li>
</ol>
<p>0000: const/4       v0, /#int 1 // /#1</p>
<p>0001: const/4       v1, /#int 2 // /#2
0002: add-int/2addr v0, v1</p>
<p>0003: mul-int/lit8  v0, v0, /#int 5 // /#05
0005: return-void
（原本的输出里还有些code-address、local-snapshot等，那些不是字节码的部分，可以忽略。）
让我们看看两个版本在概念上是如何工作的。
JVM：
<img src="" alt="">
（图中数字均以十六进制表示。其中字节码的一列表示的是字节码指令的实际数值，后面跟着的助记符则是其对应的文字形式。标记为红色的值是相对上一条指令的执行状态有所更新的值。下同）
说明：Java字节码以1字节为单元。上面代码中有11条指令，每条都只占1单元，共11单元==11字节。
程序计数器是用于记录程序当前执行的位置用的。对Java程序来说，每个线程都有自己的PC。PC以字节为单位记录当前运行位置里方法开头的偏移量。
每个线程都有一个Java栈，用于记录Java方法调用的“活动记录”（activation record）。Java栈以帧（frame）为单位线程的运行状态，每调用一个方法就会分配一个新的栈帧压入Java栈上，每从一个方法返回则弹出并撤销相应的栈帧。
每个栈帧包括局部变量区、求值栈（JVM规范中将其称为“操作数栈”）和其它一些信息。局部变量区用于存储方法的参数与局部变量，其中参数按源码中从左到右顺序保存在局部变量区开头的几个slot。求值栈用于保存求值的中间结果和调用别的方法的参数等。两者都以字长（32位的字）为单位，每个slot可以保存byte、short、char、int、float、reference和returnAddress等长度小于或等于32位的类型的数据；相邻两项可用于保存long和double类型的数据。每个方法所需要的局部变量区与求值栈大小都能够在编译时确定，并且记录在.class文件里。
在上面的例子中，Demo.foo()方法所需要的局部变量区大小为3个slot，需要的求值栈大小为2个slot。Java源码的a、b、c分别被分配到局部变量区的slot 0、slot 1和slot 2。可以观察到Java字节码是如何指示JVM将数据压入或弹出栈，以及数据是如何在栈与局部变量区之前流动的；可以看到数据移动的次数特别多。动画里可能不太明显，iadd和imul指令都是要从求值栈弹出两个值运算，再把结果压回到栈上的；光这样一条指令就有3次概念上的数据移动了。
对了，想提醒一下：Java的局部变量区并不需要把某个局部变量固定分配在某个slot里；不仅如此，在一个方法内某个slot甚至可能保存不同类型的数据。如何分配slot是编译器的自由。从类型安全的角度看，只要对某个slot的一次load的类型与最近一次对它的store的类型匹配，JVM的字节码校验器就不会抱怨。以后再找时间写写这方面。
Dalvik VM：
<img src="" alt="">
说明：Dalvik字节码以16位为单元（或许叫“双字节码”更准确 =_=|||）。上面代码中有5条指令，其中mul-int/lit8指令占2单元，其余每条都只占1单元，共6单元==12字节。
与JVM相似，在Dalvik VM中每个线程都有自己的PC和调用栈，方法调用的活动记录以帧为单位保存在调用栈上。PC记录的是以16位为单位的偏移量而不是以字节为单位的。
与JVM不同的是，Dalvik VM的栈帧中没有局部变量区与求值栈，取而代之的是一组虚拟寄存器。每个方法被调用时都会得到自己的一组虚拟寄存器。常用v0-v15这16个，也有少数指令可以访问v0-v255范围内的256个虚拟寄存器。与JVM相同的是，每个方法所需要的虚拟寄存器个数都能够在编译时确定，并且记录在.dex文件里；每个寄存器都是字长（32位），相邻的一对寄存器可用于保存64位数据。方法的参数按源码中从左到右的顺序保存在末尾的几个虚拟寄存器里。
与JVM版相比，可以发现Dalvik版程序的指令数明显减少了，数据移动次数也明显减少了，用于保存临时结果的存储单元也减少了。
你可能会抱怨：上面两个版本的代码明明不对应：JVM版到return前完好持有a、b、c三个变量的值；而Dalvik版到return-void前只持有b与c的值（分别位于v0与v1），a的值被刷掉了。
但注意到a与b的特征：它们都只在声明时接受过一次赋值，赋值的源是常量。这样就可以对它们应用<a href="http://en.wikipedia.org/wiki/Constant_folding" target="_blank">常量传播</a>，将
Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>int c = (a + b) /* 5;  </li>
</ol>
<p>int c = (a + b) /* 5;
替换为
Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>int c = (1 + 2) /* 5;  </li>
</ol>
<p>int c = (1 + 2) /* 5;
然后可以再对c的初始化表达式应用常量折叠，进一步替换为：
Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>int c = 15;  </li>
</ol>
<p>int c = 15;
把变量的每次状态更新（包括初始赋值在内）称为变量的一次“定义”（definition），把每次访问变量（从变量读取值）称为变量的一次“使用”（use），则可以把代码整理为“使用-定义链”（简称UD链，<a href="http://en.wikipedia.org/wiki/Use-define_chain" target="_blank">use-define chain</a>）。显然，一个变量的某次定义要被使用过才有意义。上面的例子经过常量传播与折叠后，我们可以分析得知变量a、b、c都只被定义而没有被使用。于是它们的定义就成为了无用代码（dead code），可以安全的被消除。
上面一段的分析用一句话描述就是：由于foo()里没有产生外部可见的副作用，所以foo()的整个方法体都可以被优化为空。经过dx工具处理后，Dalvik版程序相对JVM版确实是稍微优化了一些，不过没有影响程序的语义，程序的正确性是没问题的。这是其一。
其二是Dalvik版代码只要多分配一个虚拟寄存器就能在return-void前同时持有a、b、c三个变量的值，指令几乎没有变化：
Dalvik bytecode代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>0000: const/4      v0, /#int 1 // /#1  </li>
<li>0001: const/4      v1, /#int 2 // /#2  </li>
<li>0002: add-int      v2, v0, v1  </li>
<li>0004: mul-int/lit8 v2, v2, /#int 5 // /#05  </li>
<li>0006: return-void  </li>
</ol>
<p>0000: const/4      v0, /#int 1 // /#1</p>
<p>0001: const/4      v1, /#int 2 // /#2
0002: add-int      v2, v0, v1</p>
<p>0004: mul-int/lit8 v2, v2, /#int 5 // /#05
0006: return-void
这样比原先的版本多使用了一个虚拟寄存器，指令方面也多用了一个单元（add-int指令占2单元）；但指令的条数没变，仍然是5条，数据移动的次数也没变。
题外话1：Dalvik VM是基于寄存器的，x86也是基于寄存器的，但两者的“寄存器”却相当不同：前者的寄存器是每个方法被调用时都有自己一组私有的，后者的寄存器则是全局的。也就是说，概念上Dalvik VM字节码中不用担心保护寄存器的问题，某个方法在调用了别的方法返回过来后自己的寄存器的值肯定跟调用前一样。而x86程序在调用函数时要考虑清楚<a href="http://en.wikipedia.org/wiki/Calling_convention" target="_blank">calling convention</a>，调用方在调用前要不要保护某些寄存器的当前状态，还是说被调用方会处理好这些问题，麻烦事不少。Dalvik VM这种虚拟寄存器让人想起一些实际处理器的“寄存器窗口”，例如SPARC的<a href="http://www.usenix.org/events/sec01/full_papers/frantzen/frantzen_html/node5.html" target="_blank">Register Windows</a>也是保证每个函数都觉得自己有“私有的一组寄存器”，减轻了在代码里处理寄存器保护的麻烦——扔给硬件和操作系统解决了。<a href="http://en.wikipedia.org/wiki/Itanium" target="_blank">IA-64</a>也有寄存器窗口的概念。
（当然，Dalvik VM与x86的“寄存器”一个是虚拟寄存器一个是真实硬件的ISA提供的寄存器，本来也不在一个级别上…上面这段只是讨论寄存器的语义。）
题外话2：Dalvik的.dex文件在未压缩状态下的体积通常比同等内容的.jar文件在deflate压缩后还要小。但光从字节码看，Java字节码几乎总是比Dalvik的小，那.dex文件的体积是从哪里来减出来的呢？这主要得益与.dex文件对常量池的压缩，一个.dex文件中所有类都共享常量池，使得相同的字符串、相同的数字常量等都只出现一次，自然能大大减小体积。相比之下，.jar文件中每个类都持有自己的常量池，诸如&quot;Ljava/lang/Object;&quot;这种常见的字符串会被重复多次。Sun自己也有进一步压缩JAR的工具，Pack200，对应的标准是<a href="http://jcp.org/en/jsr/detail?id=200" target="_blank">JSR 200</a>。它的主要应用场景是作为JAR的网络传输格式，以更高的压缩比来减少文件传输时间。在<a href="http://java.sun.com/j2se/1.5.0/docs/guide/deployment/deployment-guide/pack200.html" target="_blank">官方文档</a>提到了Pack200所用到的压缩技巧，
JDK 5.0 Documentation 写道</p>
<p>Pack200 works most efficiently on Java class files. It uses several techniques to efficiently reduce the size of JAR files:</p>
<ul>
<li>It merges and sorts the constant-pool data in the class files and co-locates them in the archive.</li>
<li>It removes redundant class attributes.</li>
<li>It stores internal data structures.</li>
<li>It use delta and variable length encoding.</li>
<li>It chooses optimum coding types for secondary compression.
可见.dex文件与Pack200采用了一些相似的减小体积的方法。很可惜目前还没有正式发布的JVM支持直接加载Pack200格式的归档，毕竟网络传输才是Pack200最初构想的应用场景。<h1 id="-jvm-dalvik-vm-vm-vm-">再次提醒注意，<strong>上面的描述是针对概念上的JVM与Dalvik VM，而不是针对它们的具体实现</strong>。实现VM时可以采用许多优化技巧去减少性能损失，使得实际的运行方式与概念中的不完全相符，只要最终的运行结果满足原本概念上的VM所实现的语义就行。</h1>
上面“简单”的提了些讨论点，不过还没具体到JavaScript引擎，抱歉。弄得太长了，只好在这里先拆分一次……有些东西想写的，洗个澡又忘记了。等想起来再补充 orz
“简单”是相对于实际应该掌握的信息量而言。上面写的都还没挠上痒痒，心虚。
Anyway。根据拆分的现状，下一篇应该是讨论动态语言与编译的问题，然后再下一篇会看看解释器的演化方法，再接着会看看JavaScript引擎的状况（主要针对V8和Nitro，也会谈谈Tamarin。就不讨论JScript了）。
关于推荐资料，在<a href="http://rednaxelafx.iteye.com/link?tag=virtual+machine" target="_blank">“我的收藏”的virtual machine标签</a>里就有不少值得一读的资料。如果只是对JavaScript引擎相关感兴趣的话也可以选着读些。我的收藏里还有v8和tamarin等标签的，资料有的是 ^ ^
能有耐心读到结尾的同学们，欢迎提出意见和建议，以及指出文中的错漏 ^<em>^
不像抓到虫就给美分的大师，我没那种信心……错漏难免，我也需要进一步学习。拜托大家了～
P.S. 画图真的很辛苦，加上JavaEye的带宽也不是无限的……所以拜托不要直接链接这帖里的图 &lt;(</em> _)&gt;
有需要原始图片的可以跟我联系。我是画成多帧PNG然后转换为GIF发出来的。上面的PNG图片都还保留有原始的图层信息，要拿去再编辑也很方便 ^ ^
更新1：
原本在树遍历解释器图解的小节中，我用的是这幅图：
<img src="" alt="">
其实上图画得不准确，a、b、c的右值不应该画在节点上的；节点应该只保存了它们的左值才对，要获取对应的右值就要查询变量表。我修改了图更新到正文了。原本的图里对i的赋值看起来很奇怪，就像是遍历过程经过了两次i节点一般，而事实不是那样的。</li>
</ul>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/JVM/">JVM</a></li></span></span> | <span class="tags">Tagged <a href="/tags/JVM/" class="label label-primary">JVM</a><a href="/tags/Java&J2EE/" class="label label-success">Java&J2EE</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:42"datetime="2014-03-07 09:54:42"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-JVM--虚拟机随谈（一）：解释器，树遍历解释器，基于栈与基于寄存器，大杂烩/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-JVM--虚拟机随谈（一）：解释器，树遍历解释器，基于栈与基于寄存器，大杂烩" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>





<ul id="pagination" class="pagination pagination-lg">
  <li><a class="extend prev" href="/page/50/">&laquo;</a></li><li><a class="page-number" href="/">1</a></li><li><a class="page-number" href="/page/2/">2</a></li><li><span class="space">&hellip;</span></li><li><a class="page-number" href="/page/48/">48</a></li><li><a class="page-number" href="/page/49/">49</a></li><li><a class="page-number" href="/page/50/">50</a></li><li class="active"><li><span class="page-number current">51</span></li><li><a class="page-number" href="/page/52/">52</a></li><li><a class="page-number" href="/page/53/">53</a></li><li><a class="page-number" href="/page/54/">54</a></li><li><span class="space">&hellip;</span></li></li><li><a class="page-number" href="/page/164/">164</a></li><li><a class="page-number" href="/page/165/">165</a></li><li><a class="extend next" href="/page/52/">&raquo;</a></li>
  <div class="clearfix"></div>
</ul></div><!--wapper-->
       </div><!-- ID main-col END -->
       <aside id="sidebar" class="alignright col-sx-6 col-sm-4 col-md-3 col-lg-3">
<div id="widget_search" class="widget panel panel-primary">
    <form action="//google.com/search" method="get" accept-charset="utf-8">
  <div class="input-group">
    <input class="form-control" id="searchbox" type="search" name="q" results="0" placeholder="search">
    <span class="input-group-btn">
      <button class="btn btn-default" type="submit">Go!</button>
    </span>
    <input type="hidden" name="q" value="site:itsolife.com">
  </div>
</form>
</div>

<div id="widget_category" class="widget panel panel-primary">
  <div class="panel-heading">category</div>  <div data-src='category' class='ajax_widgets'>正在加载...</div>
</div>

<div id="widget_recent_posts" class="widget panel panel-primary">
  <div class="panel-heading">recent posts</div>  <div data-src='recent_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_tagcloud" class="widget panel panel-primary">
  <div class="panel-heading">tagcloud</div>  <div data-src='tagcloud' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_latest_update_posts" class="widget panel panel-primary">
  <div class="panel-heading">最近更新</div>  <div data-src='latest_update_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_recent_comments" class="widget panel panel-primary">
  <div class="panel-heading">recent comments</div>  

<div class="list-group-item ds-recent-comments" data-num-items="6" data-show-avatars="1" data-show-time="1" data-show-title="1" data-show-admin="1" data-excerpt-length="50"></div>



</div>

</aside>
       <div class="clearfix"></div>
     </div><!-- row END -->
  </div>
  <footer id="footer" class="container">
  <div class="panel panel-info">
  <section id='footer_widget'></section>  <div class="panel-footer">
  <div id="site-info">
    <span class='author'>
  
  &copy; 2014 RobinChia
  
    &nbsp;&nbsp;</span>
  
  <span id='analytics-51la'></span><span id='analytics-google'>
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-48559895-1']);
  _gaq.push(['_trackPageview']);
  _js2load.push({src:('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'});
</script></span><span id='analytics-cnzz'>
<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_5774006'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s17.cnzz.com/stat.php%3Fid%3D5774006%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>
</span><span id='analytics-baidu'>
<script>
var _hmt = _hmt || [];
_js2load.push({src:"//hm.baidu.com/hm.js?1442f50724afc42380b51f097c43082c"});
</script>
</span>  </div>
  <div id="copyright">Blog powered by <a href='http://zespia.tw/hexo/'><strong>hexo</strong></a> Theme <strong><a href='https://github.com/chenall/hexo-theme-chenall'>chenall</a></strong>(Some change in it)<span class="pull-right"> 更新时间: <em>2014-03-15 13:06:28</em></span></div>
</div>
<div class="clearfix"></div>


  </div>
  </footer>
  
        <script src="http://cdn.bootcss.com/jquery/1.10.2/jquery.min.js"></script>        
        <script src="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/js/bootstrap.min.js"></script>        
                
        <script src="http://cdn.bootcss.com/prettify/r298/prettify.min.js"></script>    <script type="text/javascript">
   var lang=["bsh", "c", "cc", "cpp", "cs", "csh", "cyc", "cv", "htm", "html",
    "java", "js", "m", "mxml", "perl", "pl", "pm", "py", "rb", "sh",
    "xhtml", "xml", "xsl"];
   var pretty_base='';
   $('script').each(function(){
	var c = $(this).attr('src');
	if (!c)
	    return;
	if (c.match(/(\/)?prettify(\.min)?\.js/i))
	{
	    var index = c.lastIndexOf('/');
	    if (index != -1)
		pretty_base = c.substr(0,index + 1);
	    return false;
	}
   })
   $('pre code').each(function(){
	var c = $(this).attr('class')
	if (!c)
	    return;
	c = c.match(/\s?(lang\-\w+)/i);
	if (c && lang.indexOf(c[1]) == -1)
	{
	    lang.push(c[1]);
	    $.getScript(pretty_base + c[1] + '.min.js');
	}
   })

    $(window).load(function(){
       $("pre").addClass("prettyprint");
       prettyPrint();
    })
</script>    
            <script type="text/javascript">
var duoshuoQuery = {short_name:"robinchia"};
_js2load.push({src:'http://static.duoshuo.com/embed.js',charset:'UTF-8'});
</script>
    
            <!--wumii_relatedItems-->
    
        <script src="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js"></script>    <script type="text/javascript">
(function($){
  $('.entry').each(function(i){
    $(this).find('img').each(function(){
      var alt = this.alt;

      if (alt){
        $(this).before('<span class="caption">' + alt + '</span>');
      }

      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox" rel="fancybox' + i + '" />');
    });
  });

  $('.fancybox').fancybox();
})(jQuery);
</script>    
        <script src="http://cdn.bootcss.com/mathjax/2.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>    <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>
    
<script type="text/javascript">
$('.ajax_widgets').each(function(){var src=$(this).attr('data-src');if(src)$(this).load('/widgets/'+src+'.html');});
$.each(_js2load,function(index,obj){loadjs(obj.src,obj.charset)});
</script>

<div id="scroll2top">
<img src="/scroll2top/arrow.png"/>
</div>
<script src="/scroll2top/scroll2top.min.js"></script>
<div id="winterland">
  <canvas></canvas>
</div>
<script src="/js/winterland.min.js"></script>

  </body>
</html>
