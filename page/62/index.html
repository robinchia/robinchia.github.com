
<!DOCTYPE HTML>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>The 62 Page | It so life</title>
<meta name="author" content="RobinChia">

<meta name="description" content="It so life">


<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<meta property="og:site_name" content="It so life"/>

<!--[if IE]><style>.testIE.IE{display:inline;}</style><![endif]-->
<!--[if lte IE 7]><link rel="stylesheet" href="/css/ie7.css" type="text/css"><![endif]-->
<!--[if (lt IE 9)&(gt IE 7)]><style>.testIE.IE8{display:inline;}</style><![endif]-->
<!--[if gt IE 8]><style>.testIE.IE9{display:inline;}</style><![endif]-->

<link href="/favicon.png" rel="icon">
<link rel="alternate" href="/atom.xml" title="It so life Feed" type="application/atom+xml">

<link rel="stylesheet" href="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/css/bootstrap.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/font-awesome/4.0.3/css/font-awesome.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/prettify/r298/prettify.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" type="text/css">
<link rel="stylesheet" href="/css/style.css" type="text/css">
<!--[if lt IE 9]>
   <style>article,aside,dialog,footer,header,section,footer,nav,figure,menu{display:block}</style>
   <script src="http://cdn.staticfile.org/html5shiv/r29/html5.min.js"></script>
   <script src="http://cdn.staticfile.org/respond.js/1.4.2/respond.min.js"></script>
<link href="http://cdn.staticfile.org/respond.js/1.4.2/respond-proxy.html" id="respond-proxy" rel="respond-proxy" />
<link href="/js/respond.proxy.gif" id="respond-redirect" rel="respond-redirect" />
<script src="/js/respond.proxy.js"></script>
   <script src="http://cdn.bootcss.com/selectivizr/1.0.2/selectivizr-min.js"></script>
<![endif]-->
<script type="text/javascript">
function loadjs(c,d){var a=document.createElement("script");a.async=!0;a.type="text/javascript";a.src=c;a.charset=d||"gbk";(document.getElementsByTagName("HEAD")[0]||document.getElementsByTagName("BODY")[0]).appendChild(a)};
var _protocol = (("https:" == document.location.protocol) ? " https://" : " http://");
var _js2load = [];
</script>

</head>
<body>
      <header id="header" class="container"><nav id="main-nav" class="navbar navbar-default navbar-fixed-top " role="navigation">
  <div class="container">
    <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
      <span class="sr-only">Toggle navigation</span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="/">It so life</a>
    </div>
    <div  class="collapse navbar-collapse">
      <ul  class="nav navbar-nav">
  
        <li><a href="/" title="Home">Home</a></li>      
        <li><a href="/about/" title="About">About</a></li>      
        <li><a href="/archives/" title="Archives">Archives</a></li>      
      <li class='dropdown'>
        <a class='dropdown-toggle' data-toggle='dropdown' href='#'>website<b class='caret'></b></a>
        <ul class='dropdown-menu pure-menu-selected'>
    
          <li><a href="//groups.google.com/forum/#!forum/pongba" title="TopLanguage">TopLanguage</a></li>    
          <li><a href="//itpub.net/" title="ITPub">ITPub</a></li>    
          <li><a href="//blog.jobbole.com/" title="Bole">Bole</a></li>    
          <li><a href="//nosql-database.org/" title="nosql">nosql</a></li>    
          <li><a href="//gitimmersion.googol.im/" title="Git">Git</a></li>    
        </ul>
      </li>
    
      </ul>
      <ul class="nav navbar-nav navbar-right">
      
        <li><a href="/atom.xml">RSS</a></li>
      
      
        <li><a href="https://twitter.com/robinchia">twitter</a></li>
      
      
      
      
        <li><a href="https://github.com/robinchia">github</a></li>
      
      </ul>
    </div>
  </div>
</nav>
<div class="clearfix"></div>
</header>
  <div id='content' class="container">
     <div class="page-header-wrapper">
      <!--[if lt IE 9]><div class="alert alert-warning alert-dismissable"><button type="button" class="close" data-dismiss="alert" aria-hidden="true">&times;</button><strong>提示:</strong>您的浏览器版本太低了,建议升级到 <strong><a href="http://windows.microsoft.com/zh-cn/internet-explorer/download-ie" title="IE9">IE9</a></strong> 以上,本站使用<a href="https://www.google.com/intl/zh-CN/chrome/">Chrome浏览器</a>可以获得最好的显示效果.</div><![endif]-->
      <div class="page-header"><h1 align="center"><big>It so life</big> </h1>
        <h5 align="center"><big>love as life</big></h5>
      </div>
     </div>
     <div class="row">
       <div id="main-col" class="alignleft col-sx-12 col-sm-8 col-md-9 col-lg-9">
      <section id='header_widget'></section>
          <div id="wrapper"><article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-java-com-jacob--jacob合并几个word文件到一个word文件/">jacob合并几个word文件到一个word文件</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:41.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-java-com-jacob--jacob合并几个word文件到一个word文件/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="jacob-word-word-">jacob合并几个word文件到一个word文件</h1>
<pre><code> 因项目需要将几个word文件合并到一个word文件，后面附项目运用的jar包jacob-1.9
</code></pre><p>jacob运用中，需要将附件内的jacob.dll放到windows/system32下</p>
<pre><code> 直接上代码：
</code></pre><p>Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>public static void main(String[] args) {  </li>
<li>List list  = new ArrayList();  </li>
<li>String file1= &quot;D:\file1.doc&quot;;  </li>
<li>String file2= &quot;D:\file2.doc&quot;;  </li>
<li>String file3= &quot;D:\file3.doc&quot;;  </li>
<li>list.add(file1);  </li>
<li>list.add(file2);  </li>
<li>list.add(file3);  </li>
<li>uniteDoc(list,&quot;d:\file.doc&quot;);  </li>
<li>}  </li>
<li>public static void uniteDoc(List fileList, String savepaths) {  </li>
<li>if (fileList.size() == 0 || fileList == null) {  </li>
<li>return;  </li>
<li>}  </li>
<li>//打开word  </li>
<li>ActiveXComponent app = new ActiveXComponent(&quot;Word.Application&quot;);//启动word  </li>
<li>try {  </li>
<li>// 设置word不可见  </li>
<li>app.setProperty(&quot;Visible&quot;, new Variant(false));  </li>
<li>//获得documents对象  </li>
<li>Object docs = app.getProperty(&quot;Documents&quot;).toDispatch();  </li>
<li>//打开第一个文件  </li>
<li>Object doc = Dispatch  </li>
<li>.invoke(  </li>
<li>(Dispatch) docs,  </li>
<li>&quot;Open&quot;,  </li>
<li>Dispatch.Method,  </li>
<li>new Object[] { (String) fileList.get(0),  </li>
<li>new Variant(false), new Variant(true) },  </li>
<li>new int[3]).toDispatch();  </li>
<li>//追加文件  </li>
<li>for (int i = 1; i &lt; fileList.size(); i++) {  </li>
<li>Dispatch.invoke(app.getProperty(&quot;Selection&quot;).toDispatch(),  </li>
<li>&quot;insertFile&quot;, Dispatch.Method, new Object[] {  </li>
<li>(String) fileList.get(i), &quot;&quot;,  </li>
<li>new Variant(false), new Variant(false),  </li>
<li>new Variant(false) }, new int[3]);  </li>
<li>}  </li>
<li>//保存新的word文件  </li>
<li>Dispatch.invoke((Dispatch) doc, &quot;SaveAs&quot;, Dispatch.Method,  </li>
<li>new Object[] { savepaths, new Variant(1) }, new int[3]);  </li>
<li>Variant f = new Variant(false);  </li>
<li>Dispatch.call((Dispatch) doc, &quot;Close&quot;, f);  </li>
<li>} catch (Exception e) {  </li>
<li>throw new RuntimeException(&quot;合并word文件出错.原因:&quot; + e);  </li>
<li>} finally {  </li>
<li>app.invoke(&quot;Quit&quot;, new Variant[] {});  </li>
<li>}  </li>
<li>}  </li>
</ol>
<p>public static void main(String[] args) {</p>
<pre><code>        List list  = new ArrayList();
        String file1= &quot;D:\\file1.doc&quot;;

        String file2= &quot;D:\\file2.doc&quot;;
        String file3= &quot;D:\\file3.doc&quot;;

        list.add(file1);
        list.add(file2);

        list.add(file3);
        uniteDoc(list,&quot;d:\\file.doc&quot;);

}
public static void uniteDoc(List fileList, String savepaths) {

    if (fileList.size() == 0 || fileList == null) {
        return;

    }
    //打开word

    ActiveXComponent app = new ActiveXComponent(&quot;Word.Application&quot;);//启动word
    try {

        // 设置word不可见
        app.setProperty(&quot;Visible&quot;, new Variant(false));

        //获得documents对象
        Object docs = app.getProperty(&quot;Documents&quot;).toDispatch();

        //打开第一个文件
        Object doc = Dispatch

            .invoke(
                    (Dispatch) docs,

                    &quot;Open&quot;,
                    Dispatch.Method,

                    new Object[] { (String) fileList.get(0),
                            new Variant(false), new Variant(true) },

                    new int[3]).toDispatch();
        //追加文件

        for (int i = 1; i &lt; fileList.size(); i++) {
            Dispatch.invoke(app.getProperty(&quot;Selection&quot;).toDispatch(),

                &quot;insertFile&quot;, Dispatch.Method, new Object[] {
                        (String) fileList.get(i), &quot;&quot;,

                        new Variant(false), new Variant(false),
                        new Variant(false) }, new int[3]);

        }
        //保存新的word文件

        Dispatch.invoke((Dispatch) doc, &quot;SaveAs&quot;, Dispatch.Method,
            new Object[] { savepaths, new Variant(1) }, new int[3]);

        Variant f = new Variant(false);
        Dispatch.call((Dispatch) doc, &quot;Close&quot;, f);

    } catch (Exception e) {
        throw new RuntimeException(&quot;合并word文件出错.原因:&quot; + e);

    } finally {
        app.invoke(&quot;Quit&quot;, new Variant[] {});

    }
}
</code></pre>
      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/java-com/">java-com</a></li><li><a href="/categories/Java&J2EE/java-com/jacob/">jacob</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/jacob/" class="label label-success">jacob</a><a href="/tags/java-com/" class="label label-info">java-com</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:41"datetime="2014-03-07 09:54:41"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-java-com-jacob--jacob合并几个word文件到一个word文件/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-java-com-jacob--jacob合并几个word文件到一个word文件" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_常用--switch之enum/">switch之enum</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:41.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_常用--switch之enum/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="switch-enum">switch之enum</h1>
<h3 id="-switch-enum-http-blog-csdn-net-wzju64676266-article-details-6140871-"><a href="http://blog.csdn.net/wzju64676266/article/details/6140871" target="_blank">switch之enum</a></h3>
<p>2011-01-14 23:46 
<a href="http://blog.csdn.net/tag/details.html?tag=spring" target="_blank">spring</a><a href="http://blog.csdn.net/tag/details.html?tag=table" target="_blank">table</a><a href="http://blog.csdn.net/tag/details.html?tag=class" target="_blank">class</a><a href="http://blog.csdn.net/tag/details.html?tag=string" target="_blank">string</a><a href="http://blog.csdn.net/tag/details.html?tag=%e7%bc%96%e8%af%91%e5%99%a8" target="_blank">编译器</a><a href="http://blog.csdn.net/tag/details.html?tag=byte" target="_blank">byte</a></p>
<p>记得曾经去一家公司面试，那时啥也不懂，面试我的那个人好像呆过IBM，数据结构、编译原理这些都很NB。</p>
<p>问答环节</p>
<p>他：java switch中能支持什么类型？</p>
<p>我：byte short char int ，jdk1.5出来了enum，同样也支持enum</p>
<p>他：为什么能支持byte short char int   而long不行？</p>
<p>我：这个可能是设计问题</p>
<p>他：其实jvm执行class文件的时候，byte short char int这些都是当int类型来执行的，long不能直接转换成int，编译阶段就通不过了。</p>
<p>我：我那个时候不太理解他说的那个意思，只能点点头</p>
<p>他：好，那接着讨论switch为什么支持enum，刚才也讨论过switch其实都是int类型，也只支持int，那enum不是int类型，是个对象，那为什么支持呢！</p>
<p>我：那个时候我就蒙了（心里想着，你这家伙，就胡扯），但我讲不出理由，就直接说不知道</p>
<p>他：其实在switch中enum也是int类型</p>
<p>我：心想----我不知道你说的是对还是错，你怎么说都行</p>
<p>自从那以后，哥去研究虚拟机，java指令</p>
<p> <strong>好，废话不多说了，现在来看一下代码，代码比较简单！</strong></p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/wzju64676266/article/details/6140871#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/wzju64676266/article/details/6140871#" title="copy" target="_blank">copy</a></p>
<ol>
<li>//<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/* </li>
<li>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/* </li>
<li>源代码 </li>
<li>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/* </li>
<li>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/*/  </li>
<li>public static void testSwitchInt() {  </li>
<li>int intElement = 3;  </li>
<li>switch (intElement) {  </li>
<li>case 3:  </li>
<li>System.out.println(&quot;3&quot;);  </li>
<li>break;  </li>
<li>default:  </li>
<li>System.out.println(&quot;int DEFAULT&quot;);  </li>
<li>break;  </li>
<li>}  </li>
<li>}  </li>
<li>//int 类型反编译跟源代码是一样的  </li>
<li></li>
<li>//<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/* </li>
<li>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/* </li>
<li>用javap工具看class指令 </li>
<li>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/* </li>
<li>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/*/  </li>
<li>//case 的值本来就是int，这没什么好说的  </li>
<li>public static void testSwitchInt();  </li>
<li>Code:  </li>
<li>Stack=2, Locals=1, Args_size=0  </li>
<li>0:   iconst_3      //解释：加载int常量3  </li>
<li>1:   istore_0     //解释：保存int类型到局部变量表index为0的位置（其实保存的就是3）  </li>
<li>2:   iload_0      //加载局部变量表index为0的位置的int变量，用于switch里面  </li>
<li>3:   lookupswitch{ //1  </li>
<li>3: 20;  </li>
<li>default: 31 }  </li>
<li>20:  getstatic       /#9; //Field java/lang/System.out:Ljava/io/PrintStream;  </li>
<li>23:  ldc     /#13; //String 3  </li>
<li>25:  invokevirtual   /#11; //Method java/io/PrintStream.println:(Ljava/lang/St  </li>
<li>ring;)V  </li>
<li>28:  goto    39  </li>
<li>31:  getstatic       /#9; //Field java/lang/System.out:Ljava/io/PrintStream;  </li>
<li>34:  ldc     /#14; //String int DEFAULT  </li>
<li>36:  invokevirtual   /#11; //Method java/io/PrintStream.println:(Ljava/lang/St  </li>
<li>ring;)V  </li>
<li>39:  return  </li>
<li></li>
<li><hr>
</li>
<li><hr>
</li>
<li></li>
<li></li>
<li>//<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/* </li>
<li>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/* </li>
<li>源代码 </li>
<li>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/* </li>
<li>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/*/  </li>
<li>public static void testSwitchChar() {  </li>
<li>int charElement = &#39;a&#39;;   //ascii对应的是97，编译器直接把这个值编译成97，case里面也是这样的  </li>
<li>switch (charElement) {  </li>
<li>case &#39;a&#39;:  </li>
<li>System.out.println(&quot;a&quot;);  </li>
<li>break;  </li>
<li>default:  </li>
<li>System.out.println(&quot;char DEFAULT&quot;);  </li>
<li>break;  </li>
<li>}  </li>
<li>}  </li>
<li>//<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/* </li>
<li>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/* </li>
<li>编译后的代码 </li>
<li>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/* </li>
<li>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/*/  </li>
<li>public static void testSwitchChar()  </li>
<li>{  </li>
<li>int charElement = 97;     </li>
<li>switch(charElement)  </li>
<li>{  </li>
<li>case 97: // &#39;a&#39;  </li>
<li>System.out.println(&quot;a&quot;);  </li>
<li>break;  </li>
<li>default:  </li>
<li>System.out.println(&quot;char DEFAULT&quot;);  </li>
<li>break;  </li>
<li>}  </li>
<li>}  </li>
<li>//<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/* </li>
<li>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/* </li>
<li>用javap工具看class指令 </li>
<li>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/* </li>
<li>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/*/  </li>
<li>//case 的值本来就是char类型，但被编译器处理成int   </li>
<li>public static void testSwitchChar();  </li>
<li>Code:  </li>
<li>Stack=2, Locals=1, Args_size=0  </li>
<li>0:   bipush  97   //解释：加载int常量97,a的ascii码  </li>
<li>2:   istore_0    //接下来和上面都一样的  </li>
<li>3:   iload_0      </li>
<li>4:   tableswitch{ //97 to 97  </li>
<li>97: 24;  </li>
<li>default: 35 }  </li>
<li>24:  getstatic       /#46; //Field java/lang/System.out:Ljava/io/PrintStream;  </li>
<li>27:  ldc     /#68; //String a  </li>
<li>29:  invokevirtual   /#53; //Method java/io/PrintStream.println:(Ljava/lang/St  </li>
<li>ring;)V  </li>
<li>32:  goto    43  </li>
<li>35:  getstatic       /#46; //Field java/lang/System.out:Ljava/io/PrintStream;  </li>
<li>38:  ldc     /#70; //String char DEFAULT  </li>
<li>40:  invokevirtual   /#53; //Method java/io/PrintStream.println:(Ljava/lang/St  </li>
<li>ring;)V  </li>
<li>43:  return  </li>
<li>byte  short  也是同理，都会编译成int  </li>
<li></li>
<li><hr>
</li>
<li><hr>
</li>
<li>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>上面的例子都比较好理解，enum大家可能也会有点疑惑/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>  </li>
<li></li>
<li>//<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/* </li>
<li>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/* </li>
<li>源代码 </li>
<li>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/* </li>
<li>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/*/  </li>
<li>enum EnumTest {  </li>
<li>WINTER, SUMMER, SPRING, AUTUMN;  </li>
<li>}  </li>
<li>public static void testSwitchEnum() {  </li>
<li>EnumTest enumElement = EnumTest.AUTUMN;  </li>
<li>switch (enumElement) {  </li>
<li>case AUTUMN:  </li>
<li>System.out.println(&quot;AUTUMN&quot;);  </li>
<li>break;  </li>
<li>default:  </li>
<li>System.out.println(&quot;enum DEFAULT&quot;);  </li>
<li>break;  </li>
<li>}  </li>
<li>}  </li>
<li>//<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/* </li>
<li>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/* </li>
<li>enum类编译后的代码 </li>
<li>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/* </li>
<li>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/*/  </li>
<li>//enum其实也就是个普通的类，继承Enum  </li>
<li>public final class EnumTest extends Enum  </li>
<li>{  </li>
<li>private EnumTest(String s, int i)  </li>
<li>{  </li>
<li>super(s, i);      </li>
<li></li>
<li>//*调用父类的构造函数 </li>
<li>protected Enum(String name, int ordinal) { </li>
<li>this.name = name;    //名称 </li>
<li>this.ordinal = ordinal;   元素位置 </li>
<li>} </li>
<li>/*/  </li>
<li>}  </li>
<li>public static EnumTest[] values()  </li>
<li>{  </li>
<li>EnumTest aenumtest[];  </li>
<li>int i;  </li>
<li>EnumTest aenumtest1[];  </li>
<li>System.arraycopy(aenumtest = ENUM$VALUES, 0, aenumtest1 = new EnumTest[i = aenumtest.length], 0, i);  </li>
<li>return aenumtest1;  </li>
<li>}  </li>
<li>public static EnumTest valueOf(String s)  </li>
<li>{  </li>
<li>return (EnumTest)Enum.valueOf(meiju/EnumTest, s);  </li>
<li>}  </li>
<li>public static final EnumTest WINTER;  </li>
<li>public static final EnumTest SUMMER;  </li>
<li>public static final EnumTest SPRING;  </li>
<li>public static final EnumTest AUTUMN;  </li>
<li>private static final EnumTest ENUM$VALUES[];  </li>
<li>static   </li>
<li>{  </li>
<li>//enum的位置的排好的，想数组一样，enum元素最终都保存在ENUM$VALUES数组  </li>
<li>WINTER = new EnumTest(&quot;WINTER&quot;, 0);    </li>
<li>SUMMER = new EnumTest(&quot;SUMMER&quot;, 1);  </li>
<li>SPRING = new EnumTest(&quot;SPRING&quot;, 2);  </li>
<li>AUTUMN = new EnumTest(&quot;AUTUMN&quot;, 3);  </li>
<li>ENUM$VALUES = (new EnumTest[] {  </li>
<li>WINTER, SUMMER, SPRING, AUTUMN  </li>
<li>});  </li>
<li>}  </li>
<li>}  </li>
<li>//<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/* </li>
<li>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/* </li>
<li>testSwitchEnum方法编译后的代码 </li>
<li>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/* </li>
<li>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/*/  </li>
<li>用到enum元素，所以会在当前类中多生成一个$SWITCH_TABLE$meiju$EnumTest()方法和$SWITCH_TABLE$meiju$EnumTest[]变量，用于switch  </li>
<li>static int[] $SWITCH_TABLE$meiju$EnumTest()  </li>
<li>{  </li>
<li>$SWITCH_TABLE$meiju$EnumTest;  </li>
<li>if($SWITCH_TABLE$meiju$EnumTest == null) goto _L2; else goto _L1  </li>
<li>_L1:  </li>
<li>return;  </li>
<li>_L2:  </li>
<li>JVM INSTR pop ;  </li>
<li>int ai[] = new int[EnumTest.values().length];  </li>
<li>try  </li>
<li>{  </li>
<li>ai[EnumTest.AUTUMN.ordinal()] = 4;  </li>
<li>}  </li>
<li>catch(NoSuchFieldError _ex) { }  </li>
<li>try  </li>
<li>{  </li>
<li>ai[EnumTest.SPRING.ordinal()] = 3;  </li>
<li>}  </li>
<li>catch(NoSuchFieldError _ex) { }  </li>
<li>try  </li>
<li>{  </li>
<li>ai[EnumTest.SUMMER.ordinal()] = 2;  </li>
<li>}  </li>
<li>catch(NoSuchFieldError _ex) { }  </li>
<li>try  </li>
<li>{  </li>
<li>ai[EnumTest.WINTER.ordinal()] = 1;  </li>
<li>}  </li>
<li>catch(NoSuchFieldError _ex) { }  </li>
<li>return $SWITCH_TABLE$meiju$EnumTest = ai;  </li>
<li>}  </li>
<li>private static int $SWITCH_TABLE$meiju$EnumTest[];//保存的是enum的index  </li>
<li></li>
<li>public static void testSwitchEnum()  </li>
<li>{  </li>
<li>EnumTest enumElement = EnumTest.AUTUMN;  </li>
<li>//这个就是上面所用到的变量  </li>
<li>switch($SWITCH_TABLE$meiju$EnumTest()[enumElement.ordinal()])  </li>
<li>{  </li>
<li>case 4: // &#39;/004&#39;     因为enum类的元素其实就是个常量，在编译阶段就能确定值，在源代码的case AUTUMN:   其实也就被他所在的ordinal()给替换掉了，其实就是索引  </li>
<li>System.out.println(&quot;AUTUMN&quot;);  </li>
<li>break;  </li>
<li>default:  </li>
<li>System.out.println(&quot;enum DEFAULT&quot;);  </li>
<li>break;  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>//<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/* </li>
<li>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/* </li>
<li>用javap工具看class指令 </li>
<li>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/* </li>
<li>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/*/  </li>
<li>public static void testSwitchEnum();  </li>
<li>Code:  </li>
<li>Stack=2, Locals=1, Args_size=0  </li>
<li>0:   getstatic       /#6; //Field meiju/EnumTest.AUTUMN:Lmeiju/EnumTest;  </li>
<li>3:   astore_0  </li>
<li>4:   getstatic       /#7; //Field meiju/SwitchEnum$1.$SwitchMap$meiju$EnumTest  </li>
<li>:[I  </li>
<li>7:   aload_0  </li>
<li>8:   invokevirtual   /#8; //Method meiju/EnumTest.ordinal:()I  </li>
<li>11:  iaload  </li>
<li>12:  lookupswitch{ //1  </li>
<li>1: 32;  </li>
<li>default: 43 }  </li>
<li>32:  getstatic       /#9; //Field java/lang/System.out:Ljava/io/PrintStream;  </li>
<li>35:  ldc     /#10; //String AUTUMN  </li>
<li>37:  invokevirtual   /#11; //Method java/io/PrintStream.println:(Ljava/lang/St  </li>
<li>ring;)V  </li>
<li>40:  goto    51  </li>
<li>43:  getstatic       /#9; //Field java/lang/System.out:Ljava/io/PrintStream;  </li>
<li>46:  ldc     /#12; //String enum DEFAULT  </li>
<li>48:  invokevirtual   /#11; //Method java/io/PrintStream.println:(Ljava/lang/St  </li>
<li>ring;)V  </li>
<li>51:  return  </li>
</ol>
<p>事实证明当时他不是忽悠我，确实是这样的:)</p>
<p>来源： <a href="[http://blog.csdn.net/wzju64676266/article/details/6140871](http://blog.csdn.net/wzju64676266/article/details/6140871)">[http://blog.csdn.net/wzju64676266/article/details/6140871](http://blog.csdn.net/wzju64676266/article/details/6140871)</a> </p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/Java_常用/">Java_常用</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/Java_常用/" class="label label-success">Java_常用</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:41"datetime="2014-03-07 09:54:41"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-Java_常用--switch之enum/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-Java_常用--switch之enum" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_常用--jsp-include与include的区别/">jsp</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:41.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_常用--jsp-include与include的区别/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="jsp-include-include-">jsp:include与include的区别</h1>
<p>（题外话：引入的文件如果是jsp则应定义为/<em>/</em>/<em>.jspf文件，如果其他文件可定义为/</em>/<em>/</em>.inc文件，即include file。而且&lt;%@ inlucde page=&quot;&quot; %&gt;除了可以引jspf还可以引servlet——很重要）
近日做一项目要用到JSP动态包含JSP，本想肯定很简单，但不想这么复杂，而且目前还没有求到好的答案，问题如下：
/#文件：one.jsp
1</p>
<p>2
3 &lt;%!</p>
<p>String var1=</p>
<p>&quot;China&quot;</p>
<p>;
%&gt;
/#文件 two.jsp
1</p>
<p>2
3</p>
<p>4
 &lt;%!</p>
<p>String var1=</p>
<p>&quot;America&quot;</p>
<p>;
String var2=</p>
<p>&quot;England&quot;</p>
<p>;</p>
<p>%&gt;
/#文件 three.jsp
1</p>
<p>2
3</p>
<p>4
5</p>
<p>6
7</p>
<p>8
9</p>
<p>10
11</p>
<p>12
 &lt;%</p>
<p>int j=1;
if</p>
<p>(j==1){</p>
<p>%&gt;
&lt;%@ include file=</p>
<p>&quot;one.jsp&quot;</p>
<p>%&gt;</p>
<p>&lt;%
}</p>
<p>else</p>
<p>{</p>
<p>%&gt;
&lt;%@ include file=</p>
<p>&quot;two.jsp&quot;</p>
<p>%&gt;</p>
<p>&lt;%}%&gt;
&lt;%=var1%&gt;</p>
<p>&lt;%=var2%&gt;
执行three.jsp会出什么结果？
a.编译错误
b.显示China England
很多人理所当然的觉得肯定是a,因为j=1所以只包含one.jsp,two.jsp不会包含进来，但答案是b,上机测试就知道。
为什么？
因为@include要先于jsp的其他代码执行，所以两个文件都会被包含进来！
－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－
如果你说用jsp:include可以解决问题，好，把three.jsp改成如下：
＃文件 three.jsp
1</p>
<p>2
3</p>
<p>4
5</p>
<p>6
7</p>
<p>8
9</p>
<p>10
11 &lt;%</p>
<p>int j=1;
String includeFile=</p>
<p>&quot;&quot;</p>
<p>;</p>
<p>if</p>
<p>(j==1){
includeFile =</p>
<p>&quot;one.jsp&quot;</p>
<p>;</p>
<p>}</p>
<p>else</p>
<p>{
includeFile =</p>
<p>&quot;two.jsp&quot;</p>
<p>;</p>
<p>}
%&gt;</p>
<p><jsp:include page=′<%=includeFile%>′ /&gt;
&lt;%=var1%&gt;
－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－
结果是什么？
a.编译错误
b.显示 China
是b吗，不，是a,编译错误！提示var1未定义。
为什么？因为jsp:include是动态包含，相当于把包含文件与被包含文件分开编译。
－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－
现把include的问题总结如下：
【引用 gfzhx(小小)的话】
    动态包含相当于作了一个页面跳转，也就是相当于重新访问了另一个servlet，所以当然会提示变量没有定义，你想一想，一个类中申明了一个变量，第二个类直接是用这个变量，你说可以吗？其实你的情况和这个例子很像，这就是动态包含，而静态包含你可以看一看jsp编译后的java文件就知道了，它是直接将你包含的页面直接包含进去，然后再编译的。所以你的问题采用静态包含就可以了。不过不管怎么，还是不推荐采用这种形式，会给程序造成很多问题，至少比较难以维护了，可以说是一种不好的编程风格。建议采用其他方法解决问题。
【引用 xiao_yuer(小鱼儿)的话】
要使用引入文件中定义的变量，只能用@include指令。
也就是&lt;%@ include file=&quot;one.jsp&quot; %&gt;,但这在一般情况下都不是动态的，是在jsp页面第一次编译时，把它导入的。而jsp编译后，这两个文件再作修改很多jsp服务器都不会侦测到，因为包含这两的jsp的jsp文件本身并没有发生变化。但很奇怪，weblogic6好像可以。你可以试试，不过不要抱太大希望，因为你这种要求不是很合理。向你这种情况，完全应该引入一个java类，这个类中定义一些变量（按你的说法都应该算是常量了，jsp取出来直接用而不会修改它再存回去），然后再jsp中得到那个类的实例，来进行处理。那样如果你要修改这些常量的值，就修改java类，而不用修改jsp.
【自己的:-))】
@include包含是静态包含，是把被包含文件加入到包含文件中然后进行编译，所以这种包含与解释执行的语言很象（例如php)，而且JSP中@开头的语句都要先于其他语句执行，所以如上，用if.else来判断然后包含是不行的，所以以前如果是做PHP这种解释语言的人会觉得不适应。
jsp:include是既可以静态包含又可以动态包含，与@include不同的是，jsp:include没有@include那样的优先权，即不是现于其他语句执行的，所以jsp:include可以又选择性的包含。不过更重要的一点是，用jsp:include相当于编译两个不同的文件，所以如果被包含文件中仅仅是显示某些东西（例如被包含文件是纯HTML）的话，这种情况下，用jsp:include和@include来包含文件的效果是一样的，但如果要用jsp:include来显示被包含文件中定义的变量就不行了（为什么？见上面的引用吧，就不赘述了）。
【感谢】
gfzhx(小小)、xiao_yuer(小鱼儿)
来源： <a href="[http://www.wudongqi.com/article/529.htm](http://www.wudongqi.com/article/529.htm)">[http://www.wudongqi.com/article/529.htm](http://www.wudongqi.com/article/529.htm)</a> </p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/Java_常用/">Java_常用</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/Java_常用/" class="label label-success">Java_常用</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:41"datetime="2014-03-07 09:54:41"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-Java_常用--jsp-include与include的区别/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-Java_常用--jsp-include与include的区别" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_常用--javaenum/">java enum</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:41.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_常用--javaenum/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="java-enum">java enum</h1>
<p>Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"></a></p>
<ol>
<li>public enum Operation {  </li>
<li></li>
<li>PLUS    { double eval(double x, double y) { return x + y; } },  </li>
<li></li>
<li>MINUS   { double eval(double x, double y) { return x - y; } },  </li>
<li></li>
<li>TIMES   { double eval(double x, double y) { return x /* y; } },  </li>
<li></li>
<li>DIVIDE { double eval(double x, double y) { return x / y; } };  </li>
<li></li>
<li></li>
<li>// Do arithmetic op represented by this constant  </li>
<li></li>
<li>abstract double eval(double x, double y);  </li>
<li></li>
<li>public static void main(String args[]) {  </li>
<li></li>
<li>double x = Double.parseDouble(&quot;3&quot;);  </li>
<li></li>
<li>double y = Double.parseDouble(&quot;2&quot;);  </li>
<li></li>
<li>for (Operation op : Operation.values())  </li>
<li></li>
<li>System.out.printf(&quot;%f %s %f = %f%n&quot;, x, op, y, op.eval(x, y));  </li>
<li></li>
<li>System.out.println(Operation.valueOf(&quot;PLUS&quot;).eval(x, y));  </li>
<li>}  </li>
<li></li>
<li>}  </li>
<li>public enum RandomStr {  </li>
<li>//<em>/</em> </li>
<li>/* 只有数字 </li>
<li>/*/  </li>
<li>Number(&quot;0123456789&quot;),  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* 包含数字和大小写字符 </li>
<li>/*/  </li>
<li>NumberAndChar(&quot;abcdefghjkmnpqrstuvwxyz23456789ABCDEFGHJKLMNPQRSTUVWXYZ&quot;),  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* 包含数字和大写字符 </li>
<li>/*/  </li>
<li>NumberAndCharIgnoreCase(&quot;ABCDEFGHJKLMNPQRSTUVWXYZ23456789&quot;),  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* 数字和字符平均出现 </li>
<li>/*/  </li>
<li>AvgNumberAndCharIgnoreCase(  </li>
<li>&quot;ABCDEFGHJKLMNPQRSTUVWXYZ234567892345678923456789&quot;);  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* 原始值 </li>
<li>/*/  </li>
<li>private String original;  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* 产生指定长度的随机码。 </li>
<li>/*/  </li>
<li>public String rand(int length) {  </li>
<li>String codes = &quot;&quot;;  </li>
<li>if (length &gt; 0) {  </li>
<li>int max = original.length();  </li>
<li>long seed = System.currentTimeMillis();  </li>
<li>Random random = new Random(seed);  </li>
<li>for (int i = 0; i &lt; length; i++) {  </li>
<li>codes += original.charAt(random.nextInt(max));  </li>
<li>}  </li>
<li>}  </li>
<li>return codes;  </li>
<li>}  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* 私有构造器。 </li>
<li>/*/  </li>
<li>private RandomStr(String original) {  </li>
<li>this.original = original;  </li>
<li>}  </li>
<li></li>
<li>}<br>注意：JDK4.0以前的都不支持，转成5.0以上才支持 
jdk5.0发布以后，添加了枚举类型，其实当初在从Delphi转向Java的时候，我就在为java中没有枚举这个功能感到不可思议。因为枚举类型在很多方面有着独特作用，现在好了，java中添加了这项功能，今天我就试了试，还满好的。 </li>
</ol>
<p>java中的枚举类型包括了其他语言中枚举类型的一般特性。 
class EnumDemo{ 
   public enum Seasons { 
    winter,spring,summer,fall; 
    } </p>
<pre><code>public static void main(String[] args){ 

   for(Seasons s:Seasons.values()) 
    System.out.println(s); 

    } 
</code></pre><p>} 
运行结果： 
winter 
spring 
summer 
fall 
上面这个例子，展示了枚举类型的一般用法，在java的枚举类中提供了静态values()方法以供循环迭代时使用。大家再看一看下面这个例子： 
public enum Seasons { 
winter, 
spring, 
summer, 
fall; 
//list the values 
public static void main(String[] args) { 
for(Seasons s:Seasons.values()) 
   { 
      System.out.println(s); 
   } 
} 
} 
这两个例子得出的是一样的结果。由此可知enum关键字是代表一个类相当于class的意思，但是它又比class的范围要小，仅仅代表枚举类而已。 
java中的枚举类除了有这些一般的功能外还包括一些特殊的功能，例如：枚举类型可以有构造函数、可以添加任意多的方法和属性；同时枚举类型还可以为不同的属性添加不同的方法。 
在这里我们假设你希望向一个枚举类中添加数据和行为。例如我们可以设想一下银河系的星球。每个星球的它自己的特定数据，由此来计算物体在其表面上的重量。下面就是实例： 
public enum Planet { 
     MERCURY (3.303e+23, 2.4397e6), //水星 
     VENUS    (4.869e+24, 6.0518e6), //金星 
     EARTH    (5.976e+24, 6.37814e6), //地球 
     MARS     (6.421e+23, 3.3972e6), //火星 
     JUPITER (1.9e+27,    7.1492e7), //木星 
     SATURN   (5.688e+26, 6.0268e7), //土星 
     URANUS   (8.686e+25, 2.5559e7), //天王星 
     NEPTUNE (1.024e+26, 2.4746e7),  //海王星 
     PLUTO    (1.27e+22,   1.137e6); //冥王星 
     private final double mass;    // in kilograms 
     private final double radius; // in meters 
     Planet(double mass, double radius) {   //枚举类不需要被实例化，所以构造器是私有的private,不加默认为私有类型 
         this.mass = mass; 
         this.radius = radius; 
     } 
     public double mass()    { return mass; } 
     public double radius() { return radius; } 
     // universal gravitational constant   (m 3 kg -1 s-2) 
     public static final double G = 6.67300E-11; 
     public double surfaceGravity() { 
         return G /<em> mass / (radius /</em> radius); 
     } 
     public double surfaceWeight(double otherMass) { 
         return otherMass /<em> surfaceGravity(); 
     } 
     public static void main(String[] args) { 
         double earthWeight = Double.parseDouble(args[0]); 
         double mass = earthWeight/EARTH.surfaceGravity(); 
         for (Planet p : Planet.values()) 
            System.out.printf(&quot;Your weight on %s is %f%n&quot;, 
                              p, p.surfaceWeight(mass)); 
     } 
} 
运行结果： 
C:\java&gt;java Planet 60 
Your weight on MERCURY is 22.665457 
Your weight on VENUS is 54.299946 
Your weight on EARTH is 60.000000 
Your weight on MARS is 22.724231 
Your weight on JUPITER is 151.833452 
Your weight on SATURN is 63.960932 
Your weight on URANUS is 54.307632 
Your weight on NEPTUNE is 68.299684 
Your weight on PLUTO is 4.012468 
在这里我们可以看到这个枚举类中含有一个带有两个参数的构造函数。通过构造函数我们可以产生含有不同数据特征的星球对象。Planet 的构造函数参数值从枚举常量里获取，如： 
当遍历到水星时 MERCURY (3.303e+23, 2.4397e6), //水星 
就会把里面的值3.303e+23传给mass, 而2.4397e6传给radius 
Planet(double mass, double radius) { 
         this.mass = mass; 
         this.radius = radius; 
     } 
在main()函数中，我们通过有不同的星球调用相同的方法来得到物体在该星球上的重量。 
我们可以把为枚举常量添加行为的主意更向前推进一步。我们可以为不同枚举常量添加不同的行为。通过使用switch语句是达到这个目的的一种方法。下面就有一个实例： 
public enum Operation { 
     PLUS, MINUS, TIMES, DIVIDE; 
     // Do arithmetic op represented by this constant 
     double eval(double x, double y){ 
         switch(this) { 
             case PLUS:    return x + y; 
             case MINUS:   return x - y; 
             case TIMES:   return x /</em> y; 
             case DIVIDE: return x / y; 
         } 
         throw new AssertionError(&quot;Unknown op: &quot; + this); 
     } 
} 
它工作的非常好，当时如果没有throw语句的话，它将不能通过编译，因此它就显得不是那么完美了。更加糟糕的是，你一定要记住在你向枚举类中添加枚举变量时，你要为这个变量添加操作。如果你忘了的话，eval方法将会操作失败。 
这里有另外一种给枚举常量添加行为的方法。使用这种方法你可以避免上面说提到的问题。你可以在枚举类型中添加一个abstract方法，然后在每一个枚举常量中重载它。这就是有名的constant-specific方法。下面就是用这种技术对以前实例的重写： 
public enum Operation { 
   PLUS    { double eval(double x, double y) { return x + y; } }, 
   MINUS   { double eval(double x, double y) { return x - y; } }, 
   TIMES   { double eval(double x, double y) { return x /<em> y; } }, 
   DIVIDE { double eval(double x, double y) { return x / y; } }; 
   // Do arithmetic op represented by this constant 
   abstract double eval(double x, double y); 
   public static void main(String args[]) { 
         double x = Double.parseDouble(args[0]); 
         double y = Double.parseDouble(args[1]); 
         for (Operation op : Operation.values()) 
             System.out.printf(&quot;%f %s %f = %f%n&quot;, x, op, y, op.eval(x, y)); 
     } 
} 
运行结果： 
C:\java&gt;java Operation 24 56 
24.000000 PLUS 56.000000 = 80.000000 
24.000000 MINUS 56.000000 = -32.000000 
24.000000 TIMES 56.000000 = 1344.000000 
24.000000 DIVIDE 56.000000 = 0.428571 
大家可能会不太明白“PLUS    { double eval(double x, double y) { return x + y; } }”的意思。其实如果大家理解内部类的话，可能就不难理解这句话的含义了。我的理解是: 
class MyenumOperation implements enumOperation 
{ 
     double eval(double x, double y) { return x + y; } 
} 
MyenumOperation plus = new MyenumOperation(); 
与枚举类型一起添加进来的还有enumset和enummap，我会在下一篇文章中介绍。 
Enum是enumeration(列举)的简写形式,包含在java.lang包中.熟悉C, C++, C 
/#, 或 Pascal人应该对列举有所了解,先看个例子: 
public enum Season { winter, spring, summer, fall } 
一个enum是定义一组值的对象,它可以包括零个或多个值成员.它是属于enum类型的,一个enum对象中不可有两个或多个相同的属性或值.在次之前的java程序员一般是 用接口的方法实现列举的,如 : 
public interface Season { 
    static winter = 0; 
    static spring = 1; //etc.. 
} 
引入了enum的java的列举的编写方便了许多,只须定义一个enum型的对象.enum对象的值都回自动获得一个数字值,从0开始,依次递增.看一个比较简单的enum实现的例子: 
EnumDemo.java 
package net.javagarage.enums; 
//</em> 
We can loop over the values we put into the enum 
using the values() method. 
Note that the enum Seasons is compiled into a 
separate unit, called EnumDemo$Seasons.class 
/<em>/ 
public class EnumDemo { 
       //</em>declare the enum and add values to it. note that, like in C/#, we don&#39;t use a ; to 
end this statement and we use commas to separate the values /<em>/ 
       private enum Seasons { winter, spring, 
        summer, fall } 
       //list the values 
       public static void main(String[] args) { 
             for (Seasons s : Seasons.values()){ 
                   System.out.println(s); 
             } 
       } 
} 
运行上述代码你回得到 以下结果: 
winter 
spring 
summer 
fall 
Enum的属性调用: 
下面的代码展示了调用enum对象的方法,这也是它通常的用法: 
package net.javagarage.enums; 
//</em> 
File: EnumSwitch.java 
Purpose: show how to switch against the values in an enum. 
/<em>/ 
public class EnumSwitch { 
       private enum Color { red, blue, green } 
       //list the values 
       public static void main(String[] args) { 
             //refer to the qualified value 
             doIt(Color.red); 
       } 
       //</em>note that you switch against the UNQUALIFIED name. that is, &quot;case Color.red:&quot; is a 
compiler error /<em>/ 
       private static void doIt(Color c){ 
       switch (c) { 
       case red: 
             System.out.println(&quot;value is &quot; + Color.red); 
             break; 
       case green: 
             System.out.println(&quot;value is &quot; + Color.green); 
             break; 
       case blue: 
             System.out.println(&quot;value is : &quot; + Color.blue); 
             break; 
       default : 
             System.out.println(&quot;default&quot;); 
       } 
       } 
} 
为enums添加属性和方法 
enums也可以象一般的类一样添加方法和属性,你可以为它添加静态和非静态的属性或方法,这一切都象你在一般的类中做的那样. 
package net.javagarage.enums; 
//</em> 
File: EnumDemo.java 
Purpose: show how to use an enum that also defines its own fields and methods 
/*/ 
public class EnumWithMethods { 
//declare the enum and add values to it. 
public enum Season { 
       winter, spring, summer, fall; 
       private final static String location = &quot;Phoenix&quot;; 
       public static Season getBest(){ 
             if (location.equals(&quot;Phoenix&quot;)) 
                   return winter; 
             else 
                   return summer; 
       } 
       public static void main(String[] args) { 
       System.out.println(Season.getBest()); 
       } 
} 
就是这么的简单.但是有一点是需要注意的,那就是enums的值列表必须紧跟在enum声明,不然编译时将会出错. 
Enums构造函数: 
和类一样enums也可以有自己的构造函数,如下: 
package net.javagarage.enums; 
public class EnumConstructor { 
       public static void main(String[] a) { 
             //call our enum using the values method 
             for (Temp t : Temp.values()) 
                   System.out.println(t + &quot; is : &quot; + t.getValue()); 
       } 
       //make the enum 
       public enum Temp { 
             absoluteZero(-459), freezing(32), 
             boiling(212), paperBurns(451); 
       //constructor here 
       Temp(int value) { 
             this.value = value; 
       } 
       //regular field?but make it final, 
       //since that is the point, to make constants 
       private final int value; 
       //regular get method 
       public int getValue() { 
       return value; 
       } 
       } 
} 
输出结果是: 
absoluteZero is : -459 
freezing is : 32 
boiling is : 212 
paperBurns is : 451 
尽管enums有这么多的属性,但并不是用的越多越好,如果那样还不如直接用类来的直接.enums的优势在定义int最终变量仅当这些值有一定特殊含义时.但是如果你需要的是一个类,就定义一个类,而不是enum.</p>
<p>来源： <a href="[http://xiewenbo.iteye.com/blog/1313676](http://xiewenbo.iteye.com/blog/1313676)">[http://xiewenbo.iteye.com/blog/1313676](http://xiewenbo.iteye.com/blog/1313676)</a></p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/Java_常用/">Java_常用</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/Java_常用/" class="label label-success">Java_常用</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:41"datetime="2014-03-07 09:54:41"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-Java_常用--javaenum/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-Java_常用--javaenum" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-java-com-jacob--java操作word文档jacob-poi/">java操作word文档(jacob</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:41.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-java-com-jacob--java操作word文档jacob-poi/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="java-word-jacob-poi-">java操作word文档(jacob,poi)</h1>
<p>项目需要，用户从系统里面下载word文档，该文档进行了填写限制和加密，用户只能在固定位置填写内容。现要求系统验证上传的附件是否从系统上下载下来的。</p>
<p>思路：系统上面的文档都加入一个固定书签，用户上传文档的时候，检验文档里是否包含这个书签。</p>
<p>采用jacob操作word文档</p>
<p>JACOB（java -com bridge）是一个 JAVA到微软的COM接口的桥梁。使用JACOB允许任何JVM访问COM对象，从而使JAVA应用程序能够调用COM对象。</p>
<p>下载地址：<a href="http://sourceforge.net/projects/jacob-project/" target="_blank"><a href="http://sourceforge.net/projects/jacob-project/">http://sourceforge.net/projects/jacob-project/</a></a></p>
<p>其中jacob-1.16.1-x64.dll 是用于64位机器上的，jacob-1.16.1-x86.dll用于32位的。</p>
<p>该dll放于 C:\Windows\system32 目录下。jacob.jar放于应用lib底下</p>
<p>测试代码
Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>ActiveXComponent    word = null;  </li>
<li>try {  </li>
<li>word = new ActiveXComponent(&quot;Word.Application&quot;);  </li>
<li>System.out.println(&quot;jacob当前版本：&quot;+word.getBuildVersion());  </li>
<li>}catch(Exception e ){  </li>
<li>e.printStackTrace();  </li>
<li>}  </li>
</ol>
<p>ActiveXComponent    word = null;</p>
<p>try {
        word = new ActiveXComponent(&quot;Word.Application&quot;);</p>
<pre><code>    System.out.println(&quot;jacob当前版本：&quot;+word.getBuildVersion());
</code></pre><p>}catch(Exception e ){</p>
<pre><code>     e.printStackTrace();
</code></pre><p>}</p>
<p>下面再贴出网上常见的代码+自己整理的几个方法（模糊查询书签等）</p>
<p>注意插入书签+书签值的方法，要先插入书签值再选中书签值，之后插入书签。这样根据书签名才能取得书签值。否则根据网络上很多方法，都取不到书签值或者取到空。因为书签值可以是一个点也可以是一大段内容。
Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>import java.io.File;  </li>
<li>import java.util.HashMap;  </li>
<li>import java.util.Map;  </li>
<li></li>
<li>import com.gdcn.bpaf.common.helper.StringHelper;  </li>
<li>import com.jacob.activeX.ActiveXComponent;  </li>
<li>import com.jacob.com.ComThread;  </li>
<li>import com.jacob.com.Dispatch;  </li>
<li>import com.jacob.com.Variant;  </li>
<li>//<em>/</em> </li>
<li>/<em>  /</em> </li>
<li>/* <p>Description: {jacob操作word类}    </p> </li>
<li>/* </li>
<li>/* <p>Copyright: Copyright (c) 2011</p> </li>
<li>/*  </li>
<li>/* <p>CreateDate: 2012-6-28</p> </li>
<li>/* </li>
<li>/* @author Beny </li>
<li>/* @version 1.0 </li>
<li>/*/  </li>
<li></li>
<li>public class JacobHelper {  </li>
<li>// word文档  </li>
<li>private Dispatch doc;  </li>
<li></li>
<li>// word运行程序对象  </li>
<li>private ActiveXComponent word;  </li>
<li></li>
<li>// 所有word文档集合  </li>
<li>private Dispatch documents;  </li>
<li></li>
<li>// 选定的范围或插入点  </li>
<li>private Dispatch selection;  </li>
<li></li>
<li>private boolean saveOnExit = true;  </li>
<li></li>
<li>public JacobHelper(boolean visible) throws Exception {  </li>
<li>ComThread.InitSTA();//线程启动  </li>
<li>if (word == null) {  </li>
<li>word = new ActiveXComponent(&quot;Word.Application&quot;);  </li>
<li>word.setProperty(&quot;Visible&quot;, new Variant(visible)); // 不可见打开word  </li>
<li>word.setProperty(&quot;AutomationSecurity&quot;, new Variant(3)); // 禁用宏  </li>
<li>}  </li>
<li>if (documents == null)  </li>
<li>documents = word.getProperty(&quot;Documents&quot;).toDispatch();  </li>
<li>}  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* 设置退出时参数 </li>
<li>/*  </li>
<li>/* @param saveOnExit </li>
<li>/*            boolean true-退出时保存文件，false-退出时不保存文件 </li>
<li>/*/  </li>
<li>public void setSaveOnExit(boolean saveOnExit) {  </li>
<li>this.saveOnExit = saveOnExit;  </li>
<li>}  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* 创建一个新的word文档 </li>
<li>/*  </li>
<li>/*/  </li>
<li>public void createNewDocument() {  </li>
<li>doc = Dispatch.call(documents, &quot;Add&quot;).toDispatch();  </li>
<li>selection = Dispatch.get(word, &quot;Selection&quot;).toDispatch();  </li>
<li>}  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* 打开一个已存在的文档 </li>
<li>/*  </li>
<li>/* @param docPath </li>
<li>/*/  </li>
<li>public void openDocument(String docPath) {  </li>
<li>//      closeDocument();  </li>
<li>doc = Dispatch.call(documents, &quot;Open&quot;, docPath).toDispatch();  </li>
<li>selection = Dispatch.get(word, &quot;Selection&quot;).toDispatch();  </li>
<li>}  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* 只读方式打开一个加密的文档 </li>
<li>/*  </li>
<li>/* @param docPath-文件全名 </li>
<li>/* @param pwd-密码 </li>
<li>/*/  </li>
<li>public void openDocumentOnlyRead(String docPath, String pwd)  </li>
<li>throws Exception {  </li>
<li>//      closeDocument();  </li>
<li>doc = Dispatch.callN(  </li>
<li>documents,  </li>
<li>&quot;Open&quot;,  </li>
<li>new Object[] { docPath, new Variant(false), new Variant(true),  </li>
<li>new Variant(true), pwd, &quot;&quot;, new Variant(false) })  </li>
<li>.toDispatch();  </li>
<li>selection = Dispatch.get(word, &quot;Selection&quot;).toDispatch();  </li>
<li>}  </li>
<li>//<em>/</em> </li>
<li>/* 打开一个加密的文档 </li>
<li>/* @param docPath </li>
<li>/* @param pwd </li>
<li>/* @throws Exception </li>
<li>/*/  </li>
<li>public void openDocument(String docPath, String pwd) throws Exception {  </li>
<li>//      closeDocument();  </li>
<li>doc = Dispatch.callN(  </li>
<li>documents,  </li>
<li>&quot;Open&quot;,  </li>
<li>new Object[] { docPath, new Variant(false), new Variant(false),  </li>
<li>new Variant(true), pwd }).toDispatch();  </li>
<li>selection = Dispatch.get(word, &quot;Selection&quot;).toDispatch();  </li>
<li>}  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* 从选定内容或插入点开始查找文本 </li>
<li>/*  </li>
<li>/* @param toFindText </li>
<li>/*            要查找的文本 </li>
<li>/* @return boolean true-查找到并选中该文本，false-未查找到文本 </li>
<li>/*/  </li>
<li>@SuppressWarnings(&quot;static-access&quot;)  </li>
<li>public boolean find(String toFindText) {  </li>
<li>if (toFindText == null || toFindText.equals(&quot;&quot;))  </li>
<li>return false;  </li>
<li>// 从selection所在位置开始查询  </li>
<li>Dispatch find = word.call(selection, &quot;Find&quot;).toDispatch();  </li>
<li>// 设置要查找的内容  </li>
<li>Dispatch.put(find, &quot;Text&quot;, toFindText);  </li>
<li>// 向前查找  </li>
<li>Dispatch.put(find, &quot;Forward&quot;, &quot;True&quot;);  </li>
<li>// 设置格式  </li>
<li>Dispatch.put(find, &quot;Format&quot;, &quot;True&quot;);  </li>
<li>// 大小写匹配  </li>
<li>Dispatch.put(find, &quot;MatchCase&quot;, &quot;True&quot;);  </li>
<li>// 全字匹配  </li>
<li>Dispatch.put(find, &quot;MatchWholeWord&quot;, &quot;false&quot;);  </li>
<li>// 查找并选中  </li>
<li>return Dispatch.call(find, &quot;Execute&quot;).getBoolean();  </li>
<li>}  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* 把选定选定内容设定为替换文本 </li>
<li>/*  </li>
<li>/* @param toFindText </li>
<li>/*            查找字符串 </li>
<li>/* @param newText </li>
<li>/*            要替换的内容 </li>
<li>/* @return </li>
<li>/*/  </li>
<li>public boolean replaceText(String toFindText, String newText) {  </li>
<li>if (!find(toFindText))  </li>
<li>return false;  </li>
<li>Dispatch.put(selection, &quot;Text&quot;, newText);  </li>
<li>return true;  </li>
<li>}  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* 全局替换文本 </li>
<li>/*  </li>
<li>/* @param toFindText </li>
<li>/*            查找字符串 </li>
<li>/* @param newText </li>
<li>/*            要替换的内容 </li>
<li>/*/  </li>
<li>public void replaceAllText(String toFindText, String newText) {  </li>
<li>while (find(toFindText)) {  </li>
<li>Dispatch.put(selection, &quot;Text&quot;, newText);  </li>
<li>Dispatch.call(selection, &quot;MoveRight&quot;);  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* 在当前插入点插入字符串 </li>
<li>/*  </li>
<li>/* @param newText </li>
<li>/*            要插入的新字符串 </li>
<li>/*/  </li>
<li>public void insertText(String newText) {  </li>
<li>Dispatch.put(selection, &quot;Text&quot;, newText);  </li>
<li>}  </li>
<li></li>
<li></li>
<li></li>
<li>//<em>/</em> </li>
<li>/* 设置当前选定内容的字体 </li>
<li>/*  </li>
<li>/* @param boldSize </li>
<li>/* @param italicSize </li>
<li>/* @param underLineSize </li>
<li>/*            下划线 </li>
<li>/* @param colorSize </li>
<li>/*            字体颜色 </li>
<li>/* @param size </li>
<li>/*            字体大小 </li>
<li>/* @param name </li>
<li>/*            字体名称 </li>
<li>/* @param hidden </li>
<li>/*            是否隐藏 </li>
<li>/*/  </li>
<li>public void setFont(boolean bold, boolean italic, boolean underLine,  </li>
<li>String colorSize, String size, String name,boolean hidden) {  </li>
<li>Dispatch font = Dispatch.get(selection, &quot;Font&quot;).toDispatch();  </li>
<li>Dispatch.put(font, &quot;Name&quot;, new Variant(name));  </li>
<li>Dispatch.put(font, &quot;Bold&quot;, new Variant(bold));  </li>
<li>Dispatch.put(font, &quot;Italic&quot;, new Variant(italic));  </li>
<li>Dispatch.put(font, &quot;Underline&quot;, new Variant(underLine));  </li>
<li>Dispatch.put(font, &quot;Color&quot;, colorSize);  </li>
<li>Dispatch.put(font, &quot;Size&quot;, size);  </li>
<li>Dispatch.put(font, &quot;Hidden&quot;, hidden);  </li>
<li>}  </li>
<li></li>
<li></li>
<li>//<em>/</em> </li>
<li>/* 文件保存或另存为 </li>
<li>/*  </li>
<li>/* @param savePath </li>
<li>/*            保存或另存为路径 </li>
<li>/*/  </li>
<li>public void save(String savePath) {  </li>
<li>Dispatch.call(Dispatch.call(word, &quot;WordBasic&quot;).getDispatch(),  </li>
<li>&quot;FileSaveAs&quot;, savePath);  </li>
<li>}  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* 文件保存为html格式 </li>
<li>/*  </li>
<li>/* @param savePath </li>
<li>/* @param htmlPath </li>
<li>/*/  </li>
<li>public void saveAsHtml(String htmlPath) {  </li>
<li>Dispatch.invoke(doc, &quot;SaveAs&quot;, Dispatch.Method, new Object[] {  </li>
<li>htmlPath, new Variant(8) }, new int[1]);  </li>
<li>}  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* 关闭文档 </li>
<li>/*  </li>
<li>/* @param val </li>
<li>/*            0不保存修改 -1 保存修改 -2 提示是否保存修改 </li>
<li>/*/  </li>
<li>public void closeDocument(int val) {  </li>
<li>Dispatch.call(doc, &quot;Close&quot;, new Variant(val));//注 是documents而不是doc  </li>
<li>documents = null;  </li>
<li>doc = null;  </li>
<li>}  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* 关闭当前word文档 </li>
<li>/*  </li>
<li>/*/  </li>
<li>public void closeDocument() {  </li>
<li>if (documents != null) {  </li>
<li>Dispatch.call(documents, &quot;Save&quot;);  </li>
<li>Dispatch.call(documents, &quot;Close&quot;, new Variant(saveOnExit));  </li>
<li>documents = null;  </li>
<li>doc = null;  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>public void closeDocumentWithoutSave() {  </li>
<li>if (documents != null) {  </li>
<li>Dispatch.call(documents, &quot;Close&quot;, new Variant(false));  </li>
<li>documents = null;  </li>
<li>doc = null;  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* 保存并关闭全部应用 </li>
<li>/*  </li>
<li>/*/  </li>
<li>public void close() {  </li>
<li>closeDocument(-1);  </li>
<li>if (word != null) {  </li>
<li>//          Dispatch.call(word, &quot;Quit&quot;);  </li>
<li>word.invoke(&quot;Quit&quot;, new Variant[] {});  </li>
<li>word = null;  </li>
<li>}  </li>
<li>selection = null;  </li>
<li>documents = null;  </li>
<li>ComThread.Release();//释放com线程。根据jacob的帮助文档，com的线程回收不由java的垃圾回收器处理  </li>
<li></li>
<li>}  </li>
<li>//<em>/</em> </li>
<li>/* 打印当前word文档 </li>
<li>/*  </li>
<li>/*/  </li>
<li>public void printFile() {  </li>
<li>if (doc != null) {  </li>
<li>Dispatch.call(doc, &quot;PrintOut&quot;);  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* 保护当前档,如果不存在, 使用expression.Protect(Type, NoReset, Password) </li>
<li>/*  </li>
<li>/* @param pwd </li>
<li>/* @param type </li>
<li>/*            WdProtectionType 常量之一(int 类型，只读)： </li>
<li>/*            1-wdAllowOnlyComments  仅批注 </li>
<li>/*            2-wdAllowOnlyFormFields 仅填写窗体 </li>
<li>/*            0-wdAllowOnlyRevisions 仅修订 </li>
<li>/*            -1-wdNoProtection 无保护,  </li>
<li>/*            3-wdAllowOnlyReading 只读 </li>
<li>/*  </li>
<li>/*/  </li>
<li>public void protectedWord(String pwd,String type) {  </li>
<li>String protectionType = Dispatch.get(doc, &quot;ProtectionType&quot;).toString();  </li>
<li>if (protectionType.equals(&quot;-1&quot;)) {  </li>
<li>Dispatch.call(doc, &quot;Protect&quot;, Integer.parseInt(type), new Variant(true),pwd);  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* 解除文档保护,如果存在 </li>
<li>/*  </li>
<li>/* @param pwd </li>
<li>/*            WdProtectionType 常量之一(int 类型，只读)： </li>
<li>/*            1-wdAllowOnlyComments  仅批注 </li>
<li>/*            2-wdAllowOnlyFormFields 仅填写窗体 </li>
<li>/*            0-wdAllowOnlyRevisions 仅修订 </li>
<li>/*            -1-wdNoProtection 无保护,  </li>
<li>/*            3-wdAllowOnlyReading 只读 </li>
<li>/*  </li>
<li>/*/  </li>
<li>public void unProtectedWord(String pwd) {  </li>
<li>String protectionType = Dispatch.get(doc, &quot;ProtectionType&quot;).toString();  </li>
<li>if (!protectionType.equals(&quot;0&quot;)&amp;&amp;!protectionType.equals(&quot;-1&quot;)) {  </li>
<li>Dispatch.call(doc, &quot;Unprotect&quot;, pwd);  </li>
<li>}  </li>
<li>}  </li>
<li>//<em>/</em> </li>
<li>/* 返回文档的保护类型 </li>
<li>/* @return </li>
<li>/*/  </li>
<li>public String getProtectedType(){  </li>
<li>return Dispatch.get(doc, &quot;ProtectionType&quot;).toString();  </li>
<li>}  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* 设置word文档安全级别 </li>
<li>/*  </li>
<li>/* @param value </li>
<li>/*            1-msoAutomationSecurityByUI 使用“安全”对话框指定的安全设置。 </li>
<li>/*            2-msoAutomationSecurityForceDisable </li>
<li>/*            在程序打开的所有文件中禁用所有宏，而不显示任何安全提醒。 3-msoAutomationSecurityLow </li>
<li>/*            启用所有宏，这是启动应用程序时的默认值。 </li>
<li>/*/  </li>
<li>public void setAutomationSecurity(int value) {  </li>
<li>word.setProperty(&quot;AutomationSecurity&quot;, new Variant(value));  </li>
<li>}  </li>
<li></li>
<li></li>
<li></li>
<li></li>
<li>//<em>/</em> </li>
<li>/* 在word中插入标签 labelName是标签名，labelValue是标签值 </li>
<li>/* @param labelName </li>
<li>/* @param labelValue </li>
<li>/*/  </li>
<li>public  void insertLabelValue(String labelName,String labelValue) {  </li>
<li></li>
<li>Dispatch bookMarks = Dispatch.call(doc, &quot;Bookmarks&quot;).toDispatch();  </li>
<li>boolean isExist = Dispatch.call(bookMarks, &quot;Exists&quot;, labelName).getBoolean();  </li>
<li>if (isExist == true) {  </li>
<li>Dispatch rangeItem1 = Dispatch.call(bookMarks, &quot;Item&quot;, labelName).toDispatch();  </li>
<li>Dispatch range1 = Dispatch.call(rangeItem1, &quot;Range&quot;).toDispatch();  </li>
<li>String bookMark1Value = Dispatch.get(range1, &quot;Text&quot;).toString();  </li>
<li>System.out.println(&quot;书签内容：&quot;+bookMark1Value);  </li>
<li>} else {  </li>
<li>System.out.println(&quot;当前书签不存在,重新建立!&quot;);  </li>
<li>//TODO 先插入文字，再查找选中文字，再插入标签  </li>
<li>this.insertText(labelValue);  </li>
<li>//          this.find(labelValue);//查找文字，并选中  </li>
<li>this.setFont(true, true,true,&quot;102,92,38&quot;, &quot;20&quot;, &quot;&quot;,true);  </li>
<li>Dispatch.call(bookMarks, &quot;Add&quot;, labelName, selection);  </li>
<li>Dispatch.call(bookMarks, &quot;Hidden&quot;, labelName);  </li>
<li>}  </li>
<li>}  </li>
<li>//<em>/</em> </li>
<li>/* 在word中插入标签 labelName是标签名 </li>
<li>/* @param labelName </li>
<li>/*/  </li>
<li>public  void insertLabel(String labelName) {  </li>
<li></li>
<li>Dispatch bookMarks = Dispatch.call(doc, &quot;Bookmarks&quot;).toDispatch();  </li>
<li>boolean isExist = Dispatch.call(bookMarks, &quot;Exists&quot;, labelName).getBoolean();  </li>
<li>if (isExist == true) {  </li>
<li>System.out.println(&quot;书签已存在&quot;);  </li>
<li>} else {  </li>
<li>System.out.println(&quot;建立书签：&quot;+labelName);  </li>
<li>Dispatch.call(bookMarks, &quot;Add&quot;, labelName, selection);  </li>
<li>}  </li>
<li>}     </li>
<li>//<em>/</em> </li>
<li>/* 查找书签 </li>
<li>/* @param labelName </li>
<li>/* @return </li>
<li>/*/  </li>
<li>public boolean findLabel(String labelName) {  </li>
<li>Dispatch bookMarks = Dispatch.call(doc, &quot;Bookmarks&quot;).toDispatch();  </li>
<li>boolean isExist = Dispatch.call(bookMarks, &quot;Exists&quot;, labelName).getBoolean();  </li>
<li>if (isExist == true) {  </li>
<li>return true;  </li>
<li>} else {  </li>
<li>System.out.println(&quot;当前书签不存在!&quot;);  </li>
<li>return false;  </li>
<li>}  </li>
<li>}  </li>
<li>//<em>/</em> </li>
<li>/* 模糊查找书签,并返回准确的书签名称 </li>
<li>/* @param labelName </li>
<li>/* @return </li>
<li>/*/  </li>
<li>public String findLabelLike(String labelName) {  </li>
<li>Dispatch bookMarks = Dispatch.call(doc, &quot;Bookmarks&quot;).toDispatch();  </li>
<li>int count = Dispatch.get(bookMarks, &quot;Count&quot;).getInt(); // 书签数  </li>
<li>Dispatch rangeItem = null;  </li>
<li>String lname = &quot;&quot;;  </li>
<li>for(int i=1;i&lt;=count;i++){  </li>
<li>rangeItem = Dispatch.call(bookMarks, &quot;Item&quot;, new Variant(i)).toDispatch();  </li>
<li>lname = Dispatch.call(rangeItem, &quot;Name&quot;).toString();//书签名称  </li>
<li>if(lname.startsWith(labelName)){//前面匹配  </li>
<li>//             return lname.replaceFirst(labelName, &quot;&quot;);//返回后面值  </li>
<li>return lname;  </li>
<li>}  </li>
<li>}  </li>
<li>return &quot;&quot;;  </li>
<li>}  </li>
<li>//<em>/</em> </li>
<li>/* 模糊删除书签 </li>
<li>/* @param labelName </li>
<li>/*/  </li>
<li>public void deleteLableLike(String labelName){  </li>
<li>Dispatch bookMarks = Dispatch.call(doc, &quot;Bookmarks&quot;).toDispatch();  </li>
<li>int count = Dispatch.get(bookMarks, &quot;Count&quot;).getInt(); // 书签数  </li>
<li>Dispatch rangeItem = null;  </li>
<li>String lname = &quot;&quot;;  </li>
<li>for(int i=1;i&lt;=count;i++){  </li>
<li>rangeItem = Dispatch.call(bookMarks, &quot;Item&quot;, new Variant(i)).toDispatch();  </li>
<li>lname = Dispatch.call(rangeItem, &quot;Name&quot;).toString();//书签名称  </li>
<li>if(lname.startsWith(labelName)){//前面匹配  </li>
<li>Dispatch.call(rangeItem, &quot;Delete&quot;);  </li>
<li>count--;//书签已被删除，书签数目和当前书签都要相应减1，否则会报错:集合找不到  </li>
<li>i--;  </li>
<li>}  </li>
<li>}  </li>
<li>}  </li>
<li>//<em>/</em> </li>
<li>/* 获取书签内容 </li>
<li>/* @param labelName </li>
<li>/* @return </li>
<li>/*/  </li>
<li>public String getLableValue(String labelName){  </li>
<li>if(this.findLabel(labelName)){  </li>
<li>Dispatch bookMarks = Dispatch.call(doc, &quot;Bookmarks&quot;).toDispatch();  </li>
<li>Dispatch rangeItem1 = Dispatch.call(bookMarks, &quot;Item&quot;, labelName).toDispatch();  </li>
<li>Dispatch range1 = Dispatch.call(rangeItem1, &quot;Range&quot;).toDispatch();  </li>
<li>Dispatch font = Dispatch.get(range1, &quot;Font&quot;).toDispatch();  </li>
<li>Dispatch.put(font, &quot;Hidden&quot;, new Variant(false)); //显示书签内容  </li>
<li>String bookMark1Value = Dispatch.get(range1, &quot;Text&quot;).toString();  </li>
<li>System.out.println(&quot;书签内容：&quot;+bookMark1Value);  </li>
<li>//            font = Dispatch.get(range1, &quot;Font&quot;).toDispatch();  </li>
<li>//              Dispatch.put(font, &quot;Hidden&quot;, new Variant(true)); //隐藏书签内容  </li>
<li>return bookMark1Value;  </li>
<li>}  </li>
<li>return &quot;&quot;;  </li>
<li>}  </li>
<li></li>
<li></li>
<li>public static void main(String[] args) throws Exception {  </li>
<li></li>
<li>}     </li>
<li></li>
<li>}  </li>
</ol>
<p>import java.io.File;</p>
<p>import java.util.HashMap;
import java.util.Map;</p>
<p>import com.gdcn.bpaf.common.helper.StringHelper;</p>
<p>import com.jacob.activeX.ActiveXComponent;
import com.jacob.com.ComThread;</p>
<p>import com.jacob.com.Dispatch;
import com.jacob.com.Variant;</p>
<p>//<em>/</em>
 /<em>  /</em></p>
<p> /<em> <p>Description: {jacob操作word类}    </p>
/</em></p>
<p>/<em> <p>Copyright: Copyright (c) 2011</p>
/</em></p>
<p>/<em> <p>CreateDate: 2012-6-28</p>
/</em></p>
<p>/<em> @author Beny
/</em> @version 1.0</p>
<p>/*/</p>
<p>public class JacobHelper {
    // word文档</p>
<pre><code>private Dispatch doc;


// word运行程序对象
private ActiveXComponent word;


// 所有word文档集合

private Dispatch documents;


// 选定的范围或插入点
private Dispatch selection;


private boolean saveOnExit = true;


public JacobHelper(boolean visible) throws Exception {

    ComThread.InitSTA();//线程启动
    if (word == null) {

        word = new ActiveXComponent(&quot;Word.Application&quot;);
        word.setProperty(&quot;Visible&quot;, new Variant(visible)); // 不可见打开word

        word.setProperty(&quot;AutomationSecurity&quot;, new Variant(3)); // 禁用宏
    }

    if (documents == null)
        documents = word.getProperty(&quot;Documents&quot;).toDispatch();

}


//*/*
 /* 设置退出时参数

 /*
 /* @param saveOnExit

 /*            boolean true-退出时保存文件，false-退出时不保存文件
 /*/

public void setSaveOnExit(boolean saveOnExit) {
    this.saveOnExit = saveOnExit;

}


//*/*
 /* 创建一个新的word文档

 /*
 /*/

public void createNewDocument() {
    doc = Dispatch.call(documents, &quot;Add&quot;).toDispatch();

    selection = Dispatch.get(word, &quot;Selection&quot;).toDispatch();
}


//*/*

 /* 打开一个已存在的文档
 /*

 /* @param docPath
 /*/

public void openDocument(String docPath) {
</code></pre><p>//        closeDocument();</p>
<pre><code>    doc = Dispatch.call(documents, &quot;Open&quot;, docPath).toDispatch();
    selection = Dispatch.get(word, &quot;Selection&quot;).toDispatch();

}


//*/*
 /* 只读方式打开一个加密的文档

 /*
 /* @param docPath-文件全名

 /* @param pwd-密码
 /*/

public void openDocumentOnlyRead(String docPath, String pwd)
        throws Exception {
</code></pre><p>//        closeDocument();
        doc = Dispatch.callN(</p>
<pre><code>            documents,
            &quot;Open&quot;,

            new Object[] { docPath, new Variant(false), new Variant(true),
                    new Variant(true), pwd, &quot;&quot;, new Variant(false) })

            .toDispatch();
    selection = Dispatch.get(word, &quot;Selection&quot;).toDispatch();

}
//*/*

 /* 打开一个加密的文档
 /* @param docPath

 /* @param pwd
 /* @throws Exception

 /*/
public void openDocument(String docPath, String pwd) throws Exception {
</code></pre><p>//        closeDocument();
        doc = Dispatch.callN(</p>
<pre><code>            documents,
            &quot;Open&quot;,

            new Object[] { docPath, new Variant(false), new Variant(false),
                    new Variant(true), pwd }).toDispatch();

    selection = Dispatch.get(word, &quot;Selection&quot;).toDispatch();
}


//*/*

 /* 从选定内容或插入点开始查找文本
 /*

 /* @param toFindText
 /*            要查找的文本

 /* @return boolean true-查找到并选中该文本，false-未查找到文本
 /*/

@SuppressWarnings(&quot;static-access&quot;)
public boolean find(String toFindText) {

    if (toFindText == null || toFindText.equals(&quot;&quot;))
        return false;

    // 从selection所在位置开始查询
    Dispatch find = word.call(selection, &quot;Find&quot;).toDispatch();

    // 设置要查找的内容
    Dispatch.put(find, &quot;Text&quot;, toFindText);

    // 向前查找
    Dispatch.put(find, &quot;Forward&quot;, &quot;True&quot;);

    // 设置格式
    Dispatch.put(find, &quot;Format&quot;, &quot;True&quot;);

    // 大小写匹配
    Dispatch.put(find, &quot;MatchCase&quot;, &quot;True&quot;);

    // 全字匹配
    Dispatch.put(find, &quot;MatchWholeWord&quot;, &quot;false&quot;);

    // 查找并选中
    return Dispatch.call(find, &quot;Execute&quot;).getBoolean();

}


//*/*
 /* 把选定选定内容设定为替换文本

 /*
 /* @param toFindText

 /*            查找字符串
 /* @param newText

 /*            要替换的内容
 /* @return

 /*/
public boolean replaceText(String toFindText, String newText) {

    if (!find(toFindText))
        return false;

    Dispatch.put(selection, &quot;Text&quot;, newText);
    return true;

}


//*/*
 /* 全局替换文本

 /*
 /* @param toFindText

 /*            查找字符串
 /* @param newText

 /*            要替换的内容
 /*/

public void replaceAllText(String toFindText, String newText) {
    while (find(toFindText)) {

        Dispatch.put(selection, &quot;Text&quot;, newText);
        Dispatch.call(selection, &quot;MoveRight&quot;);

    }
}


//*/*

 /* 在当前插入点插入字符串
 /*

 /* @param newText
 /*            要插入的新字符串

 /*/
public void insertText(String newText) {

    Dispatch.put(selection, &quot;Text&quot;, newText);
}





//*/*

 /* 设置当前选定内容的字体
 /*

 /* @param boldSize
 /* @param italicSize

 /* @param underLineSize
 /*            下划线

 /* @param colorSize
 /*            字体颜色

 /* @param size
 /*            字体大小

 /* @param name
 /*            字体名称

 /* @param hidden
 /*            是否隐藏

 /*/
public void setFont(boolean bold, boolean italic, boolean underLine,

        String colorSize, String size, String name,boolean hidden) {
    Dispatch font = Dispatch.get(selection, &quot;Font&quot;).toDispatch();

    Dispatch.put(font, &quot;Name&quot;, new Variant(name));
    Dispatch.put(font, &quot;Bold&quot;, new Variant(bold));

    Dispatch.put(font, &quot;Italic&quot;, new Variant(italic));
    Dispatch.put(font, &quot;Underline&quot;, new Variant(underLine));

    Dispatch.put(font, &quot;Color&quot;, colorSize);
    Dispatch.put(font, &quot;Size&quot;, size);

    Dispatch.put(font, &quot;Hidden&quot;, hidden);
}




//*/*
 /* 文件保存或另存为

 /*
 /* @param savePath

 /*            保存或另存为路径
 /*/

public void save(String savePath) {
    Dispatch.call(Dispatch.call(word, &quot;WordBasic&quot;).getDispatch(),

            &quot;FileSaveAs&quot;, savePath);
}


//*/*

 /* 文件保存为html格式
 /*

 /* @param savePath
 /* @param htmlPath

 /*/
public void saveAsHtml(String htmlPath) {

    Dispatch.invoke(doc, &quot;SaveAs&quot;, Dispatch.Method, new Object[] {
            htmlPath, new Variant(8) }, new int[1]);

}


//*/*
 /* 关闭文档

 /*
 /* @param val

 /*            0不保存修改 -1 保存修改 -2 提示是否保存修改
 /*/

public void closeDocument(int val) {
    Dispatch.call(doc, &quot;Close&quot;, new Variant(val));//注 是documents而不是doc

    documents = null;
    doc = null;

}


//*/*
 /* 关闭当前word文档

 /*
 /*/

public void closeDocument() {
    if (documents != null) {

        Dispatch.call(documents, &quot;Save&quot;);
        Dispatch.call(documents, &quot;Close&quot;, new Variant(saveOnExit));

        documents = null;
        doc = null;

    }
}


public void closeDocumentWithoutSave() {

    if (documents != null) {
        Dispatch.call(documents, &quot;Close&quot;, new Variant(false));

        documents = null;
        doc = null;

    }
}


//*/*

 /* 保存并关闭全部应用
 /*

 /*/
public void close() {

    closeDocument(-1);
    if (word != null) {
</code></pre><p>//            Dispatch.call(word, &quot;Quit&quot;);
            word.invoke(&quot;Quit&quot;, new Variant[] {});</p>
<pre><code>        word = null;
    }

    selection = null;
    documents = null;

    ComThread.Release();//释放com线程。根据jacob的帮助文档，com的线程回收不由java的垃圾回收器处理


}
//*/*

 /* 打印当前word文档
 /*

 /*/
public void printFile() {

    if (doc != null) {
        Dispatch.call(doc, &quot;PrintOut&quot;);

    }
}


//*/*

 /* 保护当前档,如果不存在, 使用expression.Protect(Type, NoReset, Password)
 /*

 /* @param pwd
 /* @param type

 /*            WdProtectionType 常量之一(int 类型，只读)：
 /*            1-wdAllowOnlyComments  仅批注

 /*            2-wdAllowOnlyFormFields 仅填写窗体
 /*            0-wdAllowOnlyRevisions 仅修订

 /*            -1-wdNoProtection 无保护,
 /*            3-wdAllowOnlyReading 只读

 /*
 /*/

public void protectedWord(String pwd,String type) {
    String protectionType = Dispatch.get(doc, &quot;ProtectionType&quot;).toString();

    if (protectionType.equals(&quot;-1&quot;)) {
        Dispatch.call(doc, &quot;Protect&quot;, Integer.parseInt(type), new Variant(true),pwd);

    }
}


//*/*

 /* 解除文档保护,如果存在
 /*

 /* @param pwd
 /*            WdProtectionType 常量之一(int 类型，只读)：

 /*            1-wdAllowOnlyComments  仅批注
 /*            2-wdAllowOnlyFormFields 仅填写窗体

 /*            0-wdAllowOnlyRevisions 仅修订
 /*            -1-wdNoProtection 无保护,

 /*            3-wdAllowOnlyReading 只读
 /*

 /*/
public void unProtectedWord(String pwd) {

    String protectionType = Dispatch.get(doc, &quot;ProtectionType&quot;).toString();
    if (!protectionType.equals(&quot;0&quot;)&amp;&amp;!protectionType.equals(&quot;-1&quot;)) {

        Dispatch.call(doc, &quot;Unprotect&quot;, pwd);
    }

}
//*/*

 /* 返回文档的保护类型
 /* @return

 /*/
public String getProtectedType(){

    return Dispatch.get(doc, &quot;ProtectionType&quot;).toString();
}


//*/*

 /* 设置word文档安全级别
 /*

 /* @param value
 /*            1-msoAutomationSecurityByUI 使用“安全”对话框指定的安全设置。

 /*            2-msoAutomationSecurityForceDisable
 /*            在程序打开的所有文件中禁用所有宏，而不显示任何安全提醒。 3-msoAutomationSecurityLow

 /*            启用所有宏，这是启动应用程序时的默认值。
 /*/

public void setAutomationSecurity(int value) {
    word.setProperty(&quot;AutomationSecurity&quot;, new Variant(value));

}






//*/*

 /* 在word中插入标签 labelName是标签名，labelValue是标签值
 /* @param labelName

 /* @param labelValue
 /*/

public  void insertLabelValue(String labelName,String labelValue) {


   Dispatch bookMarks = Dispatch.call(doc, &quot;Bookmarks&quot;).toDispatch();
   boolean isExist = Dispatch.call(bookMarks, &quot;Exists&quot;, labelName).getBoolean();

    if (isExist == true) {
        Dispatch rangeItem1 = Dispatch.call(bookMarks, &quot;Item&quot;, labelName).toDispatch();

        Dispatch range1 = Dispatch.call(rangeItem1, &quot;Range&quot;).toDispatch();
        String bookMark1Value = Dispatch.get(range1, &quot;Text&quot;).toString();

          System.out.println(&quot;书签内容：&quot;+bookMark1Value);
    } else {

        System.out.println(&quot;当前书签不存在,重新建立!&quot;);
        //TODO 先插入文字，再查找选中文字，再插入标签

        this.insertText(labelValue);
</code></pre><p>//            this.find(labelValue);//查找文字，并选中</p>
<pre><code>        this.setFont(true, true,true,&quot;102,92,38&quot;, &quot;20&quot;, &quot;&quot;,true);
         Dispatch.call(bookMarks, &quot;Add&quot;, labelName, selection);

         Dispatch.call(bookMarks, &quot;Hidden&quot;, labelName);
    }

}
//*/*

 /* 在word中插入标签 labelName是标签名
 /* @param labelName

 /*/
public  void insertLabel(String labelName) {


   Dispatch bookMarks = Dispatch.call(doc, &quot;Bookmarks&quot;).toDispatch();

   boolean isExist = Dispatch.call(bookMarks, &quot;Exists&quot;, labelName).getBoolean();
    if (isExist == true) {

          System.out.println(&quot;书签已存在&quot;);
    } else {

        System.out.println(&quot;建立书签：&quot;+labelName);
         Dispatch.call(bookMarks, &quot;Add&quot;, labelName, selection);

    }
}   

//*/*
 /* 查找书签

 /* @param labelName
 /* @return

 /*/
public boolean findLabel(String labelName) {

   Dispatch bookMarks = Dispatch.call(doc, &quot;Bookmarks&quot;).toDispatch();
   boolean isExist = Dispatch.call(bookMarks, &quot;Exists&quot;, labelName).getBoolean();

   if (isExist == true) {
          return true;

    } else {
        System.out.println(&quot;当前书签不存在!&quot;);

        return false;
    }

}
//*/*

 /* 模糊查找书签,并返回准确的书签名称
 /* @param labelName

 /* @return
 /*/

public String findLabelLike(String labelName) {
   Dispatch bookMarks = Dispatch.call(doc, &quot;Bookmarks&quot;).toDispatch();

   int count = Dispatch.get(bookMarks, &quot;Count&quot;).getInt(); // 书签数
   Dispatch rangeItem = null;

   String lname = &quot;&quot;;
   for(int i=1;i&lt;=count;i++){

       rangeItem = Dispatch.call(bookMarks, &quot;Item&quot;, new Variant(i)).toDispatch();
       lname = Dispatch.call(rangeItem, &quot;Name&quot;).toString();//书签名称

       if(lname.startsWith(labelName)){//前面匹配
</code></pre><p>//               return lname.replaceFirst(labelName, &quot;&quot;);//返回后面值</p>
<pre><code>           return lname;
       }

   }
   return &quot;&quot;;

}
//*/*

 /* 模糊删除书签
 /* @param labelName

 /*/
public void deleteLableLike(String labelName){

    Dispatch bookMarks = Dispatch.call(doc, &quot;Bookmarks&quot;).toDispatch();
   int count = Dispatch.get(bookMarks, &quot;Count&quot;).getInt(); // 书签数

   Dispatch rangeItem = null;
   String lname = &quot;&quot;;

   for(int i=1;i&lt;=count;i++){
       rangeItem = Dispatch.call(bookMarks, &quot;Item&quot;, new Variant(i)).toDispatch();

       lname = Dispatch.call(rangeItem, &quot;Name&quot;).toString();//书签名称
       if(lname.startsWith(labelName)){//前面匹配

           Dispatch.call(rangeItem, &quot;Delete&quot;);
           count--;//书签已被删除，书签数目和当前书签都要相应减1，否则会报错:集合找不到

           i--;
       }

   }
}

//*/*
 /* 获取书签内容

 /* @param labelName
 /* @return

 /*/
public String getLableValue(String labelName){

    if(this.findLabel(labelName)){
        Dispatch bookMarks = Dispatch.call(doc, &quot;Bookmarks&quot;).toDispatch();

        Dispatch rangeItem1 = Dispatch.call(bookMarks, &quot;Item&quot;, labelName).toDispatch();
        Dispatch range1 = Dispatch.call(rangeItem1, &quot;Range&quot;).toDispatch();

        Dispatch font = Dispatch.get(range1, &quot;Font&quot;).toDispatch();
        Dispatch.put(font, &quot;Hidden&quot;, new Variant(false)); //显示书签内容

        String bookMark1Value = Dispatch.get(range1, &quot;Text&quot;).toString();
          System.out.println(&quot;书签内容：&quot;+bookMark1Value);
</code></pre><p>//            font = Dispatch.get(range1, &quot;Font&quot;).toDispatch();
//              Dispatch.put(font, &quot;Hidden&quot;, new Variant(true)); //隐藏书签内容</p>
<pre><code>          return bookMark1Value;
    }

    return &quot;&quot;;
}




public static void main(String[] args) throws Exception {


}   
</code></pre><p>}</p>
<p> 采用jacob方式操作文档，经常会出现卡机的现象，所以最后采用poi方式来操作书签。若单纯的操作书签用poi方式还是比较简单的，但要操作表格、文档格式之类的还是用jacob功能比较强大。
Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>InputStream input = null;  </li>
<li>File docFile = new File( fileName );  </li>
<li>HWPFDocument document = null;  </li>
<li>try{  </li>
<li>input = new FileInputStream(docFile);//加载 doc 文档  </li>
<li>document = new HWPFDocument(input);//文件流方式创建hwpf  </li>
<li>Bookmarks bookmarks =  document.getBookmarks();//文档书签  </li>
<li>for(int i=0,length=bookmarks.getBookmarksCount();i&lt;length;i++){  </li>
<li>bookmarkName = bookmarks.getBookmark(i).getName();  </li>
<li>//.....  </li>
<li>}  </li>
<li></li>
<li>}catch( Exception e){  </li>
<li></li>
<li>}finally{  </li>
<li>if( null != input )  </li>
<li>input.close();  </li>
<li>}  </li>
</ol>
<p>InputStream input = null;</p>
<p>File docFile = new File( fileName );
HWPFDocument document = null;</p>
<p>try{
    input = new FileInputStream(docFile);//加载 doc 文档</p>
<pre><code>document = new HWPFDocument(input);//文件流方式创建hwpf
Bookmarks bookmarks =  document.getBookmarks();//文档书签

for(int i=0,length=bookmarks.getBookmarksCount();i&lt;length;i++){
    bookmarkName = bookmarks.getBookmark(i).getName();

    //.....
}
</code></pre><p>}catch( Exception e){</p>
<p>}finally{</p>
<pre><code>if( null != input )
        input.close();
</code></pre><p>}</p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/java-com/">java-com</a></li><li><a href="/categories/Java&J2EE/java-com/jacob/">jacob</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/jacob/" class="label label-success">jacob</a><a href="/tags/java-com/" class="label label-info">java-com</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:41"datetime="2014-03-07 09:54:41"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-java-com-jacob--java操作word文档jacob-poi/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-java-com-jacob--java操作word文档jacob-poi" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>





<ul id="pagination" class="pagination pagination-lg">
  <li><a class="extend prev" href="/page/61/">&laquo;</a></li><li><a class="page-number" href="/">1</a></li><li><a class="page-number" href="/page/2/">2</a></li><li><span class="space">&hellip;</span></li><li><a class="page-number" href="/page/59/">59</a></li><li><a class="page-number" href="/page/60/">60</a></li><li><a class="page-number" href="/page/61/">61</a></li><li class="active"><li><span class="page-number current">62</span></li><li><a class="page-number" href="/page/63/">63</a></li><li><a class="page-number" href="/page/64/">64</a></li><li><a class="page-number" href="/page/65/">65</a></li><li><span class="space">&hellip;</span></li></li><li><a class="page-number" href="/page/161/">161</a></li><li><a class="page-number" href="/page/162/">162</a></li><li><a class="extend next" href="/page/63/">&raquo;</a></li>
  <div class="clearfix"></div>
</ul></div><!--wapper-->
       </div><!-- ID main-col END -->
       <aside id="sidebar" class="alignright col-sx-6 col-sm-4 col-md-3 col-lg-3">
<div id="widget_search" class="widget panel panel-primary">
    <form action="//google.com/search" method="get" accept-charset="utf-8">
  <div class="input-group">
    <input class="form-control" id="searchbox" type="search" name="q" results="0" placeholder="search">
    <span class="input-group-btn">
      <button class="btn btn-default" type="submit">Go!</button>
    </span>
    <input type="hidden" name="q" value="site:itsolife.com">
  </div>
</form>
</div>

<div id="widget_category" class="widget panel panel-primary">
  <div class="panel-heading">category</div>  <div data-src='category' class='ajax_widgets'>正在加载...</div>
</div>

<div id="widget_recent_posts" class="widget panel panel-primary">
  <div class="panel-heading">recent posts</div>  <div data-src='recent_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_tagcloud" class="widget panel panel-primary">
  <div class="panel-heading">tagcloud</div>  <div data-src='tagcloud' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_latest_update_posts" class="widget panel panel-primary">
  <div class="panel-heading">最近更新</div>  <div data-src='latest_update_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_recent_comments" class="widget panel panel-primary">
  <div class="panel-heading">recent comments</div>  

<div class="list-group-item ds-recent-comments" data-num-items="6" data-show-avatars="1" data-show-time="1" data-show-title="1" data-show-admin="1" data-excerpt-length="50"></div>



</div>

</aside>
       <div class="clearfix"></div>
     </div><!-- row END -->
  </div>
  <footer id="footer" class="container">
  <div class="panel panel-info">
  <section id='footer_widget'></section>  <div class="panel-footer">
  <div id="site-info">
    <span class='author'>
  
  &copy; 2014 RobinChia
  
    &nbsp;&nbsp;</span>
  
  <span id='analytics-51la'></span><span id='analytics-google'>
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-48559895-1']);
  _gaq.push(['_trackPageview']);
  _js2load.push({src:('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'});
</script></span><span id='analytics-cnzz'>
<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_5774006'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s17.cnzz.com/stat.php%3Fid%3D5774006%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>
</span><span id='analytics-baidu'>
<script>
var _hmt = _hmt || [];
_js2load.push({src:"//hm.baidu.com/hm.js?1442f50724afc42380b51f097c43082c"});
</script>
</span>  </div>
  <div id="copyright">Site powered by <a href='http://zespia.tw/hexo/'><strong>hexo</strong></a>  update time: <em>2014-04-07 17:26:53</em></span></div>
</div>
<div class="clearfix"></div>


  </div>
  </footer>
  
        <script src="http://cdn.bootcss.com/jquery/1.10.2/jquery.min.js"></script>        
        <script src="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/js/bootstrap.min.js"></script>        
                
        <script src="http://cdn.bootcss.com/prettify/r298/prettify.min.js"></script>    <script type="text/javascript">
   var lang=["bsh", "c", "cc", "cpp", "cs", "csh", "cyc", "cv", "htm", "html",
    "java", "js", "m", "mxml", "perl", "pl", "pm", "py", "rb", "sh",
    "xhtml", "xml", "xsl"];
   var pretty_base='';
   $('script').each(function(){
	var c = $(this).attr('src');
	if (!c)
	    return;
	if (c.match(/(\/)?prettify(\.min)?\.js/i))
	{
	    var index = c.lastIndexOf('/');
	    if (index != -1)
		pretty_base = c.substr(0,index + 1);
	    return false;
	}
   })
   $('pre code').each(function(){
	var c = $(this).attr('class')
	if (!c)
	    return;
	c = c.match(/\s?(lang\-\w+)/i);
	if (c && lang.indexOf(c[1]) == -1)
	{
	    lang.push(c[1]);
	    $.getScript(pretty_base + c[1] + '.min.js');
	}
   })

    $(window).load(function(){
       $("pre").addClass("prettyprint");
       prettyPrint();
    })
</script>    
            <script type="text/javascript">
var duoshuoQuery = {short_name:"robinchia"};
_js2load.push({src:'http://static.duoshuo.com/embed.js',charset:'UTF-8'});
</script>
    
            <!--wumii_relatedItems-->
    
        <script src="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js"></script>    <script type="text/javascript">
(function($){
  $('.entry').each(function(i){
    $(this).find('img').each(function(){
      var alt = this.alt;

      if (alt){
        $(this).before('<span class="caption">' + alt + '</span>');
      }

      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox" rel="fancybox' + i + '" />');
    });
  });

  $('.fancybox').fancybox();
})(jQuery);
</script>    
        <script src="http://cdn.bootcss.com/mathjax/2.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>    <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>
    
<script type="text/javascript">
$('.ajax_widgets').each(function(){var src=$(this).attr('data-src');if(src)$(this).load('/widgets/'+src+'.html');});
$.each(_js2load,function(index,obj){loadjs(obj.src,obj.charset)});
</script>

<div id="scroll2top">
<img src="/scroll2top/arrow.png"/>
</div>
<script src="/scroll2top/scroll2top.min.js"></script>
<div id="winterland">
  <canvas></canvas>
</div>
<script src="/js/winterland.min.js"></script>

  </body>
</html>
