
<!DOCTYPE HTML>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>The 62 Page | It so life</title>
<meta name="author" content="RobinChia">

<meta name="description" content="It so life">


<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<meta property="og:site_name" content="It so life"/>

<!--[if IE]><style>.testIE.IE{display:inline;}</style><![endif]-->
<!--[if lte IE 7]><link rel="stylesheet" href="/css/ie7.css" type="text/css"><![endif]-->
<!--[if (lt IE 9)&(gt IE 7)]><style>.testIE.IE8{display:inline;}</style><![endif]-->
<!--[if gt IE 8]><style>.testIE.IE9{display:inline;}</style><![endif]-->

<link href="/favicon.png" rel="icon">
<link rel="alternate" href="/atom.xml" title="It so life Feed" type="application/atom+xml">

<link rel="stylesheet" href="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/css/bootstrap.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/font-awesome/4.0.3/css/font-awesome.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/prettify/r298/prettify.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" type="text/css">
<link rel="stylesheet" href="/css/style.css" type="text/css">
<!--[if lt IE 9]>
   <style>article,aside,dialog,footer,header,section,footer,nav,figure,menu{display:block}</style>
   <script src="http://cdn.staticfile.org/html5shiv/r29/html5.min.js"></script>
   <script src="http://cdn.staticfile.org/respond.js/1.4.2/respond.min.js"></script>
<link href="http://cdn.staticfile.org/respond.js/1.4.2/respond-proxy.html" id="respond-proxy" rel="respond-proxy" />
<link href="/js/respond.proxy.gif" id="respond-redirect" rel="respond-redirect" />
<script src="/js/respond.proxy.js"></script>
   <script src="http://cdn.bootcss.com/selectivizr/1.0.2/selectivizr-min.js"></script>
<![endif]-->
<script type="text/javascript">
function loadjs(c,d){var a=document.createElement("script");a.async=!0;a.type="text/javascript";a.src=c;a.charset=d||"gbk";(document.getElementsByTagName("HEAD")[0]||document.getElementsByTagName("BODY")[0]).appendChild(a)};
var _protocol = (("https:" == document.location.protocol) ? " https://" : " http://");
var _js2load = [];
</script>

</head>
<body>
      <header id="header" class="container"><nav id="main-nav" class="navbar navbar-default navbar-fixed-top " role="navigation">
  <div class="container">
    <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
      <span class="sr-only">Toggle navigation</span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="/">It so life</a>
    </div>
    <div  class="collapse navbar-collapse">
      <ul  class="nav navbar-nav">
  
        <li><a href="/" title="Home">Home</a></li>      
        <li><a href="/about/" title="About">About</a></li>      
        <li><a href="/archives/" title="Archives">Archives</a></li>      
      <li class='dropdown'>
        <a class='dropdown-toggle' data-toggle='dropdown' href='#'>website<b class='caret'></b></a>
        <ul class='dropdown-menu pure-menu-selected'>
    
          <li><a href="//groups.google.com/forum/#!forum/pongba" title="TopLanguage">TopLanguage</a></li>    
          <li><a href="//itpub.net/" title="ITPub">ITPub</a></li>    
          <li><a href="//blog.jobbole.com/" title="Bole">Bole</a></li>    
          <li><a href="//nosql-database.org/" title="nosql">nosql</a></li>    
          <li><a href="//gitimmersion.googol.im/" title="Git">Git</a></li>    
        </ul>
      </li>
    
      </ul>
      <ul class="nav navbar-nav navbar-right">
      
        <li><a href="/atom.xml">RSS</a></li>
      
      
        <li><a href="https://twitter.com/robinchia">twitter</a></li>
      
      
      
      
        <li><a href="https://github.com/robinchia">github</a></li>
      
      </ul>
    </div>
  </div>
</nav>
<div class="clearfix"></div>
</header>
  <div id='content' class="container">
     <div class="page-header-wrapper">
      <!--[if lt IE 9]><div class="alert alert-warning alert-dismissable"><button type="button" class="close" data-dismiss="alert" aria-hidden="true">&times;</button><strong>提示:</strong>您的浏览器版本太低了,建议升级到 <strong><a href="http://windows.microsoft.com/zh-cn/internet-explorer/download-ie" title="IE9">IE9</a></strong> 以上,本站使用<a href="https://www.google.com/intl/zh-CN/chrome/">Chrome浏览器</a>可以获得最好的显示效果.</div><![endif]-->
      <div class="page-header"><h1 align="center"><big>It so life</big> </h1>
        <h5 align="center"><big>love as life</big></h5>
      </div>
     </div>
     <div class="row">
       <div id="main-col" class="alignleft col-sx-12 col-sm-8 col-md-9 col-lg-9">
      <section id='header_widget'></section>
          <div id="wrapper"><article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_多线程-并发--深入浅出JavaConcurrency4-并发容器/">深入浅出 Java Concurrency (4)</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:41.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_多线程-并发--深入浅出JavaConcurrency4-并发容器/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-java-concurrency-4-">深入浅出 Java Concurrency (4): 并发容器</h1>
<p>从这一节开始正式进入并发容器的部分，来看看JDK 6带来了哪些并发容器。</p>
<p>在JDK 1.4以下只有Vector和Hashtable是线程安全的集合（也称并发容器，Collections.synchronized/*系列也可以看作是线程安全的实现）。从JDK 5开始增加了线程安全的Map接口ConcurrentMap和线程安全的队列BlockingQueue（尽管Queue也是同时期引入的新的集合，但是规范并没有规定一定是线程安全的，事实上一些实现也不是线程安全的，比如PriorityQueue、ArrayDeque、LinkedList等，在Queue章节中会具体讨论这些队列的结构图和实现）。</p>
<p>在介绍ConcurrencyMap之前先来回顾下Map的体系结构。下图描述了Map的体系结构，其中蓝色字体的是JDK 5以后新增的并发容器。</p>
<p><a href="http://www.blogjava.net/images/blogjava_net/xylz/WindowsLiveWriter/JavaConcurrency16part1ConcurrentMap1_10A52/image_2.png" target="_blank"><img src="&quot;image&quot;" alt="image"></a></p>
<p>针对上图有以下几点说明：</p>
<ol>
<li>Hashtable是JDK 5之前Map唯一线程安全的内置实现（Collections.synchronizedMap不算）。特别说明的是Hashtable的t是小写的（不知道为啥），Hashtable继承的是Dictionary（Hashtable是其唯一公开的子类），并<strong>不继承AbstractMap或者HashMap</strong>。尽管Hashtable和HashMap的结构非常类似，但是他们之间并没有多大联系。</li>
<li>ConcurrentHashMap是HashMap的线程安全版本，ConcurrentSkipListMap是TreeMap的线程安全版本。</li>
<li>最终可用的线程安全版本Map实现是ConcurrentHashMap/ConcurrentSkipListMap/Hashtable/Properties四个，但是Hashtable是过时的类库，因此如果可以的应该尽可能的使用ConcurrentHashMap和ConcurrentSkipListMap。</li>
</ol>
<p>回到正题来，这个小节主要介绍ConcurrentHashMap的API以及应用，下一节才开始将原理和分析。</p>
<p><a href="http://www.blogjava.net/images/blogjava_net/xylz/WindowsLiveWriter/JavaConcurrency16part1ConcurrentMap1_10A52/image_4.png" target="_blank"><img src="&quot;ConcurrentMap API&quot;" alt="ConcurrentMap API"></a></p>
<p>除了实现Map接口里面对象的方法外，ConcurrentHashMap还实现了ConcurrentMap里面的四个方法。</p>
<p><strong>V putIfAbsent(K key,V value)</strong></p>
<p>如果不存在key对应的值，则将value以key加入Map，否则返回key对应的旧值。这个等价于清单1 的操作：</p>
<p><strong><em>清单1 putIfAbsent的等价操作</em></strong>
if (!map.containsKey(key)) 
   return map.put(key, value);
else
   return map.get(key);</p>
<p>在前面的章节中提到过，连续两个或多个原子操作的序列并不一定是原子操作。比如上面的操作即使在Hashtable中也不是原子操作。而putIfAbsent就是一个线程安全版本的操作的。</p>
<p>有些人喜欢用这种功能来实现<a href="http://www.blogjava.net/xylz/archive/2009/12/18/306622.html" target="_blank"><strong>单例模式</strong></a>，例如清单2。</p>
<p><strong><em>清单2 一种单例模式的实现</em></strong>
package xylz.study.concurrency;</p>
<p>import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;</p>
<p>public class ConcurrentDemo1 {</p>
<pre><code>private static final ConcurrentMap&lt;String, ConcurrentDemo1&gt; map = new ConcurrentHashMap&lt;String, ConcurrentDemo1&gt;();
private static ConcurrentDemo1 instance;
public static ConcurrentDemo1 getInstance() {
    if (instance == null) {

        map.putIfAbsent(&quot;INSTANCE&quot;, new ConcurrentDemo1());

        instance = map.get(&quot;INSTANCE&quot;);
    }
    return instance;
}

private ConcurrentDemo1() {
}
</code></pre><p>}</p>
<p>当然这里只是一个操作的例子，实际上在<a href="http://www.blogjava.net/xylz/archive/2009/12/18/306622.html" target="_blank"><strong>单例模式</strong></a>文章中有很多的实现和比较。清单2 在存在大量单例的情况下可能有用，实际情况下很少用于单例模式。但是这个方法避免了向Map中的同一个Key提交多个结果的可能，有时候在去掉重复记录上很有用（如果记录的格式比较固定的话）。</p>
<p><strong>boolean remove(Object key,Object value)</strong></p>
<p>只有目前将键的条目映射到给定值时，才移除该键的条目。这等价于清单3 的操作。</p>
<p><strong><em>清单3 remove(Object,Object)的等价操作</em></strong>
if (map.containsKey(key) &amp;&amp; map.get(key).equals(value)) {
   map.remove(key);
   return true;
}
return false;</p>
<p>由于集合类通常比较的hashCode和equals方法，而这两个方法是在Object对象里面，因此两个对象如果hashCode一致，并且覆盖了equals方法后也一致，那么这两个对象在集合类里面就是“相同”的，不管是否是同一个对象或者同一类型的对象。也就是说只要key1.hashCode()==key2.hashCode() &amp;&amp; key1.equals(key2)，那么key1和key2在集合类里面就认为是一致，哪怕他们的Class类型不一致也没关系，所以在很多集合类里面允许通过Object来类型来比较（或者定位）。比如说Map尽管添加的时候只能通过制定的类型<K,V>，但是删除的时候却允许通过一个Object来操作，而不必是K类型。</p>
<p>既然Map里面有一个remove(Object)方法，为什么ConcurrentMap还需要remove(Object,Object)方法呢？这是因为尽管Map里面的key没有变化，但是value可能已经被其他线程修改了，如果修改后的值是我们期望的，那么我们就不能拿一个key来删除此值，尽管我们的期望值是删除此key对于的旧值。</p>
<p>这种特性在原子操作章节的<a href="http://www.blogjava.net/xylz/archive/2010/07/02/325079.html" target="_blank">AtomicMarkableReference</a>和<a href="http://www.blogjava.net/xylz/archive/2010/07/02/325079.html" target="_blank">AtomicStampedReference</a>里面介绍过。</p>
<p><strong>boolean replace(K key,V oldValue,V newValue)</strong></p>
<p>只有目前将键的条目映射到给定值时，才替换该键的条目。这等价于清单4 的操作。</p>
<p><strong><em>清单4 replace(K,V,V)的等价操作</em></strong>
if (map.containsKey(key) &amp;&amp; map.get(key).equals(oldValue)) {
   map.put(key, newValue);
   return true;
}
return false;</p>
<p><strong>V replace(K key,V value)</strong></p>
<p>只有当前键存在的时候更新此键对于的值。这等价于清单5 的操作。</p>
<p><strong><em>清单5 replace(K,V)的等价操作</em></strong>
if (map.containsKey(key)) {
   return map.put(key, value);
}
return null;</p>
<p>replace(K,V,V)相比replace(K,V)而言，就是增加了匹配oldValue的操作。</p>
<p>其实这4个扩展方法，是ConcurrentMap附送的四个操作，其实我们更关心的是Map本身的操作。当然如果没有这4个方法，要完成类似的功能我们可能需要额外的锁，所以有总比没有要好。比如清单6，如果没有putIfAbsent内置的方法，我们如果要完成此操作就需要完全锁住整个Map，这样就大大降低了ConcurrentMap的并发性。这在下一节中有详细的分析和讨论。</p>
<p><strong><em>清单6 putIfAbsent的外部实现</em></strong>
public V putIfAbsent(K key, V value) {
    synchronized (map) {
        if (!map.containsKey(key)) return map.put(key, value);
        return map.get(key);
    }
}</p>
<p>参考资料：</p>
<ul>
<li><a href="http://www.blogjava.net/xylz/archive/2009/12/18/306622.html" target="_blank">单例模式完全解析</a></li>
<li><a href="http://www.blogjava.net/xylz/archive/2010/07/02/325079.html" target="_blank">原子操作 part 2 数组、引用的原子操作</a></li>
</ul>
<p>来源： <a href="[http://www.blogjava.net/xylz/archive/2010/07/19/326527.html](http://www.blogjava.net/xylz/archive/2010/07/19/326527.html)">[http://www.blogjava.net/xylz/archive/2010/07/19/326527.html](http://www.blogjava.net/xylz/archive/2010/07/19/326527.html)</a></p>
<p>本来想比较全面和深入的谈谈ConcurrentHashMap的，发现网上有很多对HashMap和ConcurrentHashMap分析的文章，因此本小节尽可能的分析其中的细节，少一点理论的东西，多谈谈内部设计的原理和思想。</p>
<p>要谈ConcurrentHashMap的构造，就不得不谈HashMap的构造，因此先从HashMap开始简单介绍。</p>
<hr>
<p><strong>HashMap原理</strong></p>
<p>我们从头开始设想。要将对象存放在一起，如何设计这个容器。目前只有两条路可以走，一种是采用分格技术，每一个对象存放于一个格子中，这样通过对格子的编号就能取到或者遍历对象；另一种技术就是采用串联的方式，将各个对象串联起来，这需要各个对象至少带有下一个对象的索引（或者指针）。显然第一种就是数组的概念，第二种就是链表的概念。所有的容器的实现其实都是基于这两种方式的，不管是数组还是链表，或者二者俱有。HashMap采用的就是数组的方式。</p>
<p>有了存取对象的容器后还需要以下两个条件才能完成Map所需要的条件。</p>
<ul>
<li>能够快速定位元素：Map的需求就是能够根据一个查询条件快速得到需要的结果，所以这个过程需要的就是尽可能的快。</li>
<li>能够自动扩充容量：显然对于容器而然，不需要人工的去控制容器的容量是最好的，这样对于外部使用者来说越少知道底部细节越好，不仅使用方便，也越安全。</li>
</ul>
<p>首先条件1，快速定位元素。快速定位元素属于算法和数据结构的范畴，通常情况下哈希（Hash）算法是一种简单可行的算法。所谓<strong>哈希算法</strong>，是将任意长度的二进制值映射为固定长度的较小二进制值。常见的MD2,MD4,MD5，SHA-1等都属于Hash算法的范畴。具体的算法原理和介绍可以参考相应的算法和数据结构的书籍，但是这里特别提醒一句，由于将一个较大的集合映射到一个较小的集合上，所以必然就存在多个元素映射到同一个元素上的结果，这个叫“碰撞”，后面会用到此知识，暂且不表。</p>
<p>条件2，如果满足了条件1，一个元素映射到了某个位置，现在一旦扩充了容量，也就意味着元素映射的位置需要变化。因为对于Hash算法来说，调整了映射的小集合，那么原来映射的路径肯定就不复存在，那么就需要对现有重新计算映射路径，也就是所谓的rehash过程。</p>
<p>好了有了上面的理论知识后来看HashMap是如何实现的。</p>
<p>在HashMap中首先由一个对象数组table是不可避免的，修饰符transient只是表示序列号的时候不被存储而已。size描述的是Map中元素的大小，threshold描述的是达到指定元素个数后需要扩容，loadFactor是扩容因子(loadFactor&gt;0)，也就是计算threshold的。那么元素的容量就是table.length，也就是数组的大小。换句话说，如果存取的元素大小达到了整个容量(table.length)的loadFactor倍（也就是table.length/*loadFactor个），那么就需要扩充容量了。在HashMap中每次扩容就是将扩大数组的一倍，使数组大小为原来的两倍。</p>
<p> <a href="http://www.blogjava.net/images/blogjava_net/xylz/WindowsLiveWriter/JavaConcurrency17part2ConcurrentMap2_FF15/image_2.png" target="_blank"><img src="&quot;HashMap数据结构&quot;" alt="HashMap数据结构"></a></p>
<p>然后接下来看如何将一个元素映射到数组table中。显然要映射的key是一个无尽的超大集合，而table是一个较小的有限集合，那么一种方式就是将key编码后的hashCode值取模映射到table上，这样看起来不错。但是在Java中采用了一种更高效的办法。由于与(&amp;)是比取模(%)更高效的操作，因此Java中采用hash值与数组大小-1后取与来确定数组索引的。为什么这样做是更有效的？<a href="http://www.javaeye.com/topic/539465" target="_blank">参考资料7</a>对这一块进行非常详细的分析，这篇文章的作者非常认真，也非常仔细的分析了里面包含的思想。</p>
<p><strong><em>清单1 indexFor片段</em></strong>
static int indexFor(int h, int length) {
    return h &amp; (length-1);
}</p>
<p>前面说明，既然是大集合映射到小集合上，那么就必然存在“碰撞”，也就是不同的key映射到了相同的元素上。那么HashMap是怎么解决这个问题的？</p>
<p>在HashMap中采用了下面方式，解决了此问题。</p>
<ol>
<li>同一个索引的数组元素组成一个链表，查找允许时循环链表找到需要的元素。</li>
<li>尽可能的将元素均匀的分布在数组上。</li>
</ol>
<p><a href="http://www.blogjava.net/images/blogjava_net/xylz/WindowsLiveWriter/JavaConcurrency17part2ConcurrentMap2_FF15/image_4.png" target="_blank"><img src="&quot;Map.Entry结构&quot;" alt="Map.Entry结构"></a>对于问题1，HashMap采用了上图的一种数据结构。table中每一个元素是一个Map.Entry，其中Entry包含了四个数据，key,value,hash,next。key和value是存储的数据；hash是元素key的Hash后的表现形式（最终要映射到数组上），这里链表上所有元素的hash经过清单1 的indexFor后将得到相同的数组索引；next是指向下一个元素的索引，同一个链表上的元素就是通过next串联起来的。</p>
<p>再来看问题2 尽可能的将元素均匀的分布在数组上这个问题是怎么解决的。首先清单2 是将key的hashCode经过一系列的变换，使之更符合小数据集合的散列模型。</p>
<p><strong><em>清单2 hashCode的二次散列</em></strong>
static int hash(int h) {
    // This function ensures that hashCodes that differ only by
    // constant multiples at each bit position have a bounded
    // number of collisions (approximately 8 at default load factor).
    h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);
    return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);
}</p>
<p>至于清单2 为什么这样散列我没有找到依据，也没有什么好的参考资料。<a href="http://www.javaeye.com/topic/709945" target="_blank">参考资料1</a> 分析了此过程，认为是一种比较有效的方式，有兴趣的可以研究下。</p>
<p>第二点就是在清单1 的描述中，尽可能的与数组的长度减1的数与操作，使之分布均匀。这在<a href="http://www.javaeye.com/topic/539465" target="_blank">参考资料7</a> 中有介绍。</p>
<p>第三点就是构造数组时数组的长度是2的倍数。清单3 反映了这个过程。为什么要是2的倍数？在<a href="http://www.javaeye.com/topic/539465" target="_blank">参考资料7</a> 中分析说是使元素尽可能的分布均匀。</p>
<p><strong><em>清单3 HashMap 构造数组</em></strong>
// Find a power of 2 &gt;= initialCapacity
int capacity = 1;
while (capacity &lt; initialCapacity)
    capacity &lt;&lt;= 1;</p>
<p>this.loadFactor = loadFactor;
threshold = (int)(capacity /* loadFactor);
table = new Entry[capacity];</p>
<p>另外loadFactor的默认值0.75和capacity的默认值16是经过大量的统计分析得出的，很久以前我见过相关的数据分析，现在找不到了，有兴趣的可以查询相关资料。这里不再叙述了。</p>
<p>有了上述原理后再来分析HashMap的各种方法就不是什么问题的。</p>
<p><strong><em>清单4 HashMap的get操作</em></strong>
public V get(Object key) {
    if (key == null)
        return getForNullKey();
    int hash = hash(key.hashCode());
    for (Entry<K,V> e = table[indexFor(hash, table.length)];
         e != null;
         e = e.next) {
        Object k;
        if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))
            return e.value;
    }
    return null;
}</p>
<p>清单4 描述的是HashMap的get操作，在这个操作中首先判断key是否为空，因为为空的话总是映射到table的第0个元素上（可以看上面的清单2和清单1）。然后就需要查找table的索引。一旦找到对应的Map.Entry元素后就开始遍历此链表。由于不同的hash可能映射到同一个table[index]上，而相同的key却同时映射到相同的hash上，所以一个key和Entry对应的条件就是hash(key)==e.hash 并且key.equals(e.key)。从这里我们看到，Object.hashCode()只是为了将相同的元素映射到相同的链表上（Map.Entry)，而Object.equals()才是比较两个元素是否相同的关键！这就是为什么总是成对覆盖hashCode()和equals()的原因。</p>
<p><strong><em>清单5 HashMap的put操作</em></strong>
public V put(K key, V value) {
    if (key == null)
        return putForNullKey(value);
    int hash = hash(key.hashCode());
    int i = indexFor(hash, table.length);
    for (Entry<K,V> e = table[i]; e != null; e = e.next) {
        Object k;
        if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) {
            V oldValue = e.value;
            e.value = value;
            e.recordAccess(this);
            return oldValue;
        }
    }</p>
<pre><code>modCount++;
addEntry(hash, key, value, i);
return null;
</code></pre><p>}
void addEntry(int hash, K key, V value, int bucketIndex) {
    Entry<K,V> e = table[bucketIndex];
        table[bucketIndex] = new Entry<K,V>(hash, key, value, e);
        if (size++ &gt;= threshold)
            resize(2 /* table.length);
}</p>
<p>清单5 描述的是HashMap的put操作。对比get操作，可以发现，put实际上是先查找，一旦找到key对应的Entry就直接修改Entry的value值，否则就增加一个元素。增加的元素是在链表的头部，也就是占据table中的元素，如果table中对应索引原来有元素的话就将整个链表添加到新增加的元素的后面。也就是说新增加的元素再次查找的话是优于在它之前添加的同一个链表上的元素。这里涉及到就是扩容，也就是一旦元素的个数达到了扩容因子规定的数量(threhold=table.length/*loadFactor)，就将数组扩大一倍。</p>
<p><strong><em>清单6 HashMap扩容过程</em></strong>
void resize(int newCapacity) {
    Entry[] oldTable = table;
    int oldCapacity = oldTable.length;
    if (oldCapacity == MAXIMUM_CAPACITY) {
        threshold = Integer.MAX_VALUE;
        return;
    }</p>
<pre><code>Entry[] newTable = new Entry[newCapacity];
transfer(newTable);
table = newTable;
threshold = (int)(newCapacity /* loadFactor);
</code></pre><p>}</p>
<p>void transfer(Entry[] newTable) {
    Entry[] src = table;
    int newCapacity = newTable.length;
    for (int j = 0; j &lt; src.length; j++) {
        Entry<K,V> e = src[j];
        if (e != null) {
            src[j] = null;
            do {
                Entry<K,V> next = e.next;
                int i = indexFor(e.hash, newCapacity);
                e.next = newTable[i];
                newTable[i] = e;
                e = next;
            } while (e != null);
        }
    }
}</p>
<p>清单6 描述的是HashMap扩容的过程。可以看到扩充过程会导致元素数据的所有元素进行重新hash计算，这个过程也叫rehash。显然这是一个非常耗时的过程，否则扩容都会导致所有元素重新计算hash。因此尽可能的选择合适的初始化大小是有效提高HashMap效率的关键。太大了会导致过多的浪费空间，太小了就可能会导致繁重的rehash过程。在这个过程中loadFactor也可以考虑。</p>
<p>举个例子来说，如果要存储1000个元素，采用默认扩容因子0.75，那么1024显然是不够的，因为1000&gt;0.75/*1024了，所以选择2048是必须的，显然浪费了1048个空间。如果确定最多只有1000个元素，那么扩容因子为1，那么1024是不错的选择。另外需要强调的一点是扩容因此越大，从统计学角度讲意味着链表的长度就也大，也就是在查找元素的时候就需要更多次的循环。所以凡事必然是一个平衡的过程。</p>
<p>这里可能有人要问题，一旦我将Map的容量扩大后（也就是数组的大小），这个容量还能减小么？比如说刚开始Map中可能有10000个元素，运行一旦时间以后Map的大小永远不会超过10个，那么Map的容量能减小到10个或者16个么？答案就是不能，这个capacity一旦扩大后就不能减小了，只能通过构造一个新的Map来控制capacity了。</p>
<p>HashMap的几个内部迭代器也是非常重要的，这里限于篇幅就不再展开了，有兴趣的可以自己研究下。</p>
<p>Hashtable的原理和HashMap的原理几乎一样，所以就不讨论了。另外LinkedHashMap是在Map.Entry的基础上增加了before/after两个双向索引，用来将所有Map.Entry串联起来，这样就可以遍历或者做LRU Cache等。这里也不再展开讨论了。</p>
<p><a href="http://memcached.org/" target="_blank">memcached</a> 内部数据结构就是采用了HashMap类似的思想来实现的，有兴趣的可以参考资料8,9，10。</p>
<p>为了不使这篇文章过长，因此将ConcurrentHashMap的原理放到下篇讲。需要说明的是，尽管ConcurrentHashMap与HashMap的名称有些渊源，而且实现原理有些相似，但是为了更好的支持并发，ConcurrentHashMap在内部也有一些比较大的调整，这个在下篇会具体介绍。</p>
<p>参考资料：</p>
<ol>
<li><a href="http://www.javaeye.com/topic/709945" target="_blank">HashMap hash方法分析</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/java/j-lo-hash/" target="_blank">通过分析 JDK 源代码研究 Hash 存储机制</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/java/j-jtp05273/" target="_blank">Java 理论与实践: 哈希</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/java/j-jtp08223/" target="_blank">Java 理论与实践: 构建一个更好的 HashMap</a></li>
<li><a href="http://yk94wo.blog.sohu.com/155835132.html" target="_blank">jdk1.6 ConcurrentHashMap</a></li>
<li><a href="http://www.javaeye.com/topic/344876" target="_blank">ConcurrentHashMap之实现细节</a></li>
<li><a href="http://www.javaeye.com/topic/539465" target="_blank">深入理解HashMap</a></li>
<li><a href="http://www.lampchina.net/article/htmls/201005/Mjg1MTYy.html" target="_blank">memcached-数据结构</a></li>
<li><a href="http://www.cublog.cn/u/20146/showart_1820089.html" target="_blank">memcached存储管理 数据结构</a></li>
<li><a href="http://memcached.org/" target="_blank">memcached</a>
来源： <a href="[http://www.blogjava.net/xylz/archive/2010/07/20/326584.html](http://www.blogjava.net/xylz/archive/2010/07/20/326584.html)">[http://www.blogjava.net/xylz/archive/2010/07/20/326584.html](http://www.blogjava.net/xylz/archive/2010/07/20/326584.html)</a> </li>
</ol>
<p>在上一篇中介绍了HashMap的原理，这一节是ConcurrentMap的最后一节，所以会完整的介绍ConcurrentHashMap的实现。</p>
<p><strong>ConcurrentHashMap原理</strong></p>
<p>在<a href="http://www.blogjava.net/xylz/archive/2010/07/14/326080.html" target="_blank">读写锁章节部分</a>介绍过一种是用读写锁实现Map的方法。此种方法看起来可以实现Map响应的功能，而且吞吐量也应该不错。但是通过前面对<a href="http://www.blogjava.net/xylz/archive/2010/07/15/326152.html" target="_blank">读写锁原理</a>的分析后知道，读写锁的适合场景是读操作&gt;&gt;写操作，也就是读操作应该占据大部分操作，另外读写锁存在一个很严重的问题是读写操作不能同时发生。要想解决读写同时进行问题（至少不同元素的读写分离），那么就只能将锁拆分，不同的元素拥有不同的锁，这种技术就是“锁分离”技术。</p>
<p>默认情况下ConcurrentHashMap是用了16个类似HashMap 的结构，其中每一个HashMap拥有一个独占锁。也就是说最终的效果就是通过某种Hash算法，将任何一个元素均匀的映射到某个HashMap的Map.Entry上面，而对某个一个元素的操作就集中在其分布的HashMap上，与其它HashMap无关。这样就支持最多16个并发的写操作。</p>
<p> <a href="http://www.blogjava.net/images/blogjava_net/xylz/WindowsLiveWriter/JavaConcurrency18part3ConcurrentMap3_693/image_8.png" target="_blank"><img src="&quot;image&quot;" alt="image"></a></p>
<p>上图就是ConcurrentHashMap的类图。参考上面的说明和HashMap的原理分析，可以看到ConcurrentHashMap将整个对象列表分为segmentMask+1个片段（Segment）。其中每一个片段是一个类似于HashMap的结构，它有一个HashEntry的数组，数组的每一项又是一个链表，通过HashEntry的next引用串联起来。</p>
<p>这个类图上面的数据结构的定义非常有学问，接下来会一个个有针对性的分析。</p>
<p>首先如何从ConcurrentHashMap定位到HashEntry。在HashMap的原理分析部分说过，对于一个Hash的数据结构来说，为了减少浪费的空间和快速定位数据，那么就需要数据在Hash上的分布比较均匀。对于一次Map的查找来说，首先就需要定位到Segment，然后从过Segment定位到HashEntry链表，最后才是通过遍历链表得到需要的元素。</p>
<p>在不讨论并发的前提下先来讨论如何定位到HashEntry的。在ConcurrentHashMap中是通过hash(key.hashCode())和segmentFor(hash)来得到Segment的。清单1 描述了如何定位Segment的过程。其中hash(int)是将key的hashCode进行二次编码，使之能够在segmentMask+1个Segment上均匀分布（默认是16个）。可以看到的是这里和HashMap还是有点不同的，这里采用的算法叫Wang/Jenkins hash，有兴趣的可以<a href="http://tech.puredanger.com/2007/07/25/hash/" target="_blank">参考资料1</a>和<a href="http://www.goworkday.com/2010/03/19/single-word-wangjenkins-hash-concurrenthashmap/" target="_blank">参考资料2</a>。总之它的目的就是使元素能够均匀的分布在不同的Segment上，这样才能够支持最多segmentMask+1个并发，这里segmentMask+1是segments的大小。</p>
<p><strong><em>清单1 定位Segment</em></strong>
private static int hash(int h) {
    // Spread bits to regularize both segment and index locations,
    // using variant of single-word Wang/Jenkins hash.
    h += (h &lt;&lt;  15) ^ 0xffffcd7d;
    h ^= (h &gt;&gt;&gt; 10);
    h += (h &lt;&lt;   3);
    h ^= (h &gt;&gt;&gt;  6);
    h += (h &lt;&lt;   2) + (h &lt;&lt; 14);
    return h ^ (h &gt;&gt;&gt; 16);
}
final Segment<K,V> segmentFor(int hash) {
    return segments[(hash &gt;&gt;&gt; segmentShift) &amp; segmentMask];
}</p>
<p>显然在不能够对Segment扩容的情况下，segments的大小就应该是固定的。所以在ConcurrentHashMap中segments/segmentMask/segmentShift都是常量，一旦初始化后就不能被再次修改，其中segmentShift是查找Segment的一个常量偏移量。</p>
<p>有了Segment以后再定位HashEntry就和HashMap中定位HashEntry一样了，先将hash值与Segment中HashEntry的大小减1进行与操作定位到HashEntry链表，然后遍历链表就可以完成相应的操作了。</p>
<p>能够定位元素以后ConcurrentHashMap就已经具有了HashMap的功能了，现在要解决的就是如何并发的问题。要解决并发问题，加锁是必不可免的。再回头看Segment的类图，可以看到Segment除了有一个volatile类型的元素大小count外，Segment还是集成自ReentrantLock的。另外在前面的原子操作和锁机制中介绍过，要想最大限度的支持并发，那么能够利用的思路就是尽量读操作不加锁，写操作不加锁。如果是读操作不加锁，写操作加锁，对于竞争资源来说就需要定义为<a href="http://www.blogjava.net/xylz/archive/2010/07/03/325168.html" target="_blank">volatile</a>类型的。<a href="http://www.blogjava.net/xylz/archive/2010/07/03/325168.html" target="_blank">volatile</a>类型能够保证<a href="http://www.blogjava.net/xylz/archive/2010/07/03/325168.html" target="_blank">happens-before法则</a>，所以volatile能够近似保证正确性的情况下最大程度的降低加锁带来的影响，同时还与写操作的锁不产生冲突。</p>
<p>同时为了防止在遍历HashEntry的时候被破坏，那么对于HashEntry的数据结构来说，除了value之外其他属性就应该是常量，否则不可避免的会得到ConcurrentModificationException。这就是为什么HashEntry数据结构中key,hash,next是常量的原因(final类型）。</p>
<p>有了上面的分析和条件后再来看Segment的get/put/remove就容易多了。</p>
<p><strong>get操作</strong></p>
<hr>
<p><strong><em>清单2 Segment定位元素</em></strong>
V get(Object key, int hash) {
    if (count != 0) { // read-volatile
        HashEntry<K,V> e = getFirst(hash);
        while (e != null) {
            if (e.hash == hash &amp;&amp; key.equals(e.key)) {
                V v = e.value;
                if (v != null)
                    return v;
                return readValueUnderLock(e); // recheck
            }
            e = e.next;
        }
    }
    return null;
}
HashEntry<K,V> getFirst(int hash) {
    HashEntry<K,V>[] tab = table;
    return tab[hash &amp; (tab.length - 1)];
}</p>
<p>V readValueUnderLock(HashEntry<K,V> e) {
    lock();
    try {
        return e.value;
    } finally {
        unlock();
    }
}</p>
<p>清单2 描述的是Segment如何定位元素。首先判断Segment的大小count&gt;0，Segment的大小描述的是HashEntry不为空(key不为空)的个数。如果Segment中存在元素那么就通过getFirst定位到指定的HashEntry链表的头节点上，然后遍历此节点，一旦找到key对应的元素后就返回其对应的值。但是在清单2 中可以看到拿到HashEntry的value后还进行了一次判断操作，如果为空还需要加锁再读取一次（readValueUnderLock）。为什么会有这样的操作？尽管ConcurrentHashMap不允许将value为null的值加入，但现在仍然能够读到一个为空的value就意味着此值对当前线程还不可见（这是因为HashEntry还没有完全构造完成就赋值导致的，后面还会谈到此机制）。</p>
<p><strong>put操作</strong></p>
<hr>
<p>清单3 描述的是Segment的put操作。首先就需要加锁了，修改一个竞争资源肯定是要加锁的，这个毫无疑问。需要说明的是Segment集成的是ReentrantLock，所以这里加的锁也就是独占锁，也就是说同一个Segment在同一时刻只有能一个put操作。</p>
<p>接下来来就是检查是否需要扩容，这和HashMap一样，如果需要的话就扩大一倍，同时进行rehash操作。</p>
<p>查找元素就和get操作是一样的，得到元素就直接修改其值就好了。这里onlyIfAbsent只是为了实现ConcurrentMap的putIfAbsent操作而已。需要说明以下几点：</p>
<ul>
<li>如果找到key对于的HashEntry后直接修改就好了，如果找不到那么就需要构造一个新的HashEntry出来加到hash对于的HashEntry的头部，同时就的头部就加到新的头部后面。这是因为HashEntry的next是final类型的，所以只能修改头节点才能加元素加入链表中。</li>
<li>如果增加了新的操作后，就需要将count+1写回去。前面说过count是volatile类型，而读取操作没有加锁，所以只能把元素真正写回Segment中的时候才能修改count值，这个要放到整个操作的最后。</li>
<li>在将新的HashEntry写入table中时是通过构造函数来设置value值的，这意味对table的赋值可能在设置value之前，也就是说得到了一个半构造完的HashEntry。这就是重排序可能引起的问题。所以在读取操作中，一旦读到了一个value为空的value是就需要加锁重新读取一次。为什么要加锁？加锁意味着前一个写操作的锁释放，也就是前一个锁的数据已经完成写完了了，根据happens-before法则，前一个写操作的结果对当前读线程就可见了。当然在JDK 6.0以后不一定存在此问题。</li>
<li>在Segment中table变量是volatile类型，多次读取volatile类型的开销要不非volatile开销要大，而且编译器也无法优化，所以在put操作中首先建立一个临时变量tab指向table，多次读写tab的效率要比volatile类型的table要高，JVM也能够对此进行优化。</li>
</ul>
<p><strong><em>清单3 Segment的put操作</em></strong>
V put(K key, int hash, V value, boolean onlyIfAbsent) {
    lock();
    try {
        int c = count;
        if (c++ &gt; threshold) // ensure capacity
            rehash();
        HashEntry<K,V>[] tab = table;
        int index = hash &amp; (tab.length - 1);
        HashEntry<K,V> first = tab[index];
        HashEntry<K,V> e = first;
        while (e != null &amp;&amp; (e.hash != hash || !key.equals(e.key)))
            e = e.next;</p>
<pre><code>    V oldValue;
    if (e != null) {
        oldValue = e.value;
        if (!onlyIfAbsent)
            e.value = value;
    }
    else {
        oldValue = null;
        ++modCount;
        tab[index] = new HashEntry&lt;K,V&gt;(key, hash, first, value);
        count = c; // write-volatile
    }
    return oldValue;
} finally {
    unlock();
}
</code></pre><p>}</p>
<p><strong>remove 操作</strong></p>
<p>清单4 描述了Segment删除一个元素的过程。同put一样，remove也需要加锁，这是因为对table可能会有变更。由于HashEntry的next节点是final类型的，所以一旦删除链表中间一个元素，就需要将删除之前或者之后的元素重新加入新的链表。而Segment采用的是将删除元素之前的元素一个个重新加入删除之后的元素之前（也就是链表头结点）来完成新链表的构造。</p>
<p><strong><em>清单4 Segment的remove操作</em></strong>
V remove(Object key, int hash, Object value) {
    lock();
    try {
        int c = count - 1;
        HashEntry<K,V>[] tab = table;
        int index = hash &amp; (tab.length - 1);
        HashEntry<K,V> first = tab[index];
        HashEntry<K,V> e = first;
        while (e != null &amp;&amp; (e.hash != hash || !key.equals(e.key)))
            e = e.next;</p>
<pre><code>    V oldValue = null;
    if (e != null) {
        V v = e.value;
        if (value == null || value.equals(v)) {
            oldValue = v;
            // All entries following removed node can stay
            // in list, but all preceding ones need to be
            // cloned.
            ++modCount;
            HashEntry&lt;K,V&gt; newFirst = e.next;
            for (HashEntry&lt;K,V&gt; p = first; p != e; p = p.next)
                newFirst = new HashEntry&lt;K,V&gt;(p.key, p.hash,
                                              newFirst, p.value);
            tab[index] = newFirst;
            count = c; // write-volatile
        }
    }
    return oldValue;
} finally {
    unlock();
}
</code></pre><p>}</p>
<p>下面的示意图描述了如何删除一个已经存在的元素的。假设我们要删除B3元素。首先定位到B3所在的Segment，然后再定位到Segment的table中的B1元素，也就是Bx所在的链表。然后遍历链表找到B3，找到之后就从头结点B1开始构建新的节点B1（蓝色）加到B4的前面，继续B1后面的节点B2构造B2（蓝色），加到由蓝色的B1和B4构成的新的链表。继续下去，直到遇到B3后终止，这样就构造出来一个新的链表B2（蓝色）-&gt;B1（蓝色）-&gt;B4-&gt;B5，然后将此链表的头结点B2（蓝色）设置到Segment的table中。这样就完成了元素B3的删除操作。需要说明的是，尽管就的链表仍然存在(B1-&gt;B2-&gt;B3-&gt;B4-&gt;B5)，但是由于没有引用指向此链表，所以此链表中无引用的（B1-&gt;B2-&gt;B3）最终会被GC回收掉。这样做的一个好处是，如果某个读操作在删除时已经定位到了旧的链表上，那么此操作仍然将能读到数据，只不过读取到的是旧数据而已，这在多线程里面是没有问题的。</p>
<p><a href="http://www.blogjava.net/images/blogjava_net/xylz/WindowsLiveWriter/JavaConcurrency18part3ConcurrentMap3_693/image_10.png" target="_blank"><img src="&quot;image&quot;" alt="image"></a><a href="http://www.blogjava.net/images/blogjava_net/xylz/WindowsLiveWriter/JavaConcurrency18part3ConcurrentMap3_693/image_12.png" target="_blank"><img src="&quot;image&quot;" alt="image"></a></p>
<p>除了对单个元素操作外，还有对全部的Segment的操作，比如size()操作等。</p>
<p><strong>size操作</strong></p>
<p>size操作涉及到统计所有Segment的大小，这样就会遍历所有的Segment，如果每次加锁就会导致整个Map都被锁住了，任何需要锁的操作都将无法进行。这里用到了一个比较巧妙的方案解决此问题。</p>
<p>在Segment中有一个变量modCount，用来记录Segment结构变更的次数，结构变更包括增加元素和删除元素，每增加一个元素操作就+1，每进行一次删除操作+1，每进行一次清空操作(clear)就+1。也就是说每次涉及到元素个数变更的操作modCount都会+1，而且一直是增大的，不会减小。</p>
<p>遍历两次ConcurrentHashMap中的segments，每次遍历是记录每一个Segment的modCount，比较两次遍历的modCount值的和是否相同，如果相同就返回在遍历过程中获取的Segment的count的和，也就是所有元素的个数。如果不相同就重复再做一次。重复一次还不相同就将所有Segment锁住，一个一个的获取其大小(count)，最后将这些count加起来得到总的大小。当然了最后需要将锁一一释放。清单5 描述了这个过程。</p>
<p>这里有一个比较高级的话题是为什么在读取modCount的时候总是先要读取count一下。为什么不是先读取modCount然后再读取count的呢？也就是说下面的两条语句能否交换下顺序？
sum += segments[i].count;
mcsum += mc[i] = segments[i].modCount;</p>
<p>答案是不能！为什么？这是因为modCount总是在加锁的情况下才发生变化，所以不会发生多线程同时修改的情况，也就是没必要时volatile类型。另外总是在count修改的情况下修改modCount，而count是一个volatile变量。于是这里就充分利用了volatile的特性。</p>
<p>根据<a href="http://www.blogjava.net/xylz/archive/2010/07/03/325168.html" target="_blank">happens-before法则</a>，第（3）条：对volatile字段的写入操作happens-before于每一个后续的同一个字段的读操作。也就是说一个操作C在volatile字段的写操作之后，那么volatile写操作之前的所有操作都对此操作C可见。所以修改modCount总是在修改count之前，也就是说如果读取到了一个count的值，那么在count变化之前的modCount也就能够读取到，换句话说就是如果看到了count值的变化，那么就一定看到了modCount值的变化。而如果上面两条语句交换下顺序就无法保证这个结果一定存在了。</p>
<p>在ConcurrentHashMap.containsValue中，可以看到每次遍历segments时都会执行int c = segments[i].count;，但是接下来的语句中又不用此变量c，尽管如此JVM仍然不能将此语句优化掉，因为这是一个volatile字段的读取操作，它保证了一些列操作的happens-before顺序，所以是至关重要的。在这里可以看到：
ConcurrentHashMap将volatile发挥到了极致！</p>
<p>另外isEmpty操作于size操作类似，不再累述。</p>
<p><strong><em>清单5 ConcurrentHashMap的size操作</em></strong>
public int size() {
    final Segment<K,V>[] segments = this.segments;
    long sum = 0;
    long check = 0;
    int[] mc = new int[segments.length];
    // Try a few times to get accurate count. On failure due to
    // continuous async changes in table, resort to locking.
    for (int k = 0; k &lt; RETRIES_BEFORE_LOCK; ++k) {
        check = 0;
        sum = 0;
        int mcsum = 0;
        for (int i = 0; i &lt; segments.length; ++i) {
            sum += segments[i].count;
            mcsum += mc[i] = segments[i].modCount;
        }
        if (mcsum != 0) {
            for (int i = 0; i &lt; segments.length; ++i) {
                check += segments[i].count;
                if (mc[i] != segments[i].modCount) {
                    check = -1; // force retry
                    break;
                }
            }
        }
        if (check == sum)
            break;
    }
    if (check != sum) { // Resort to locking all segments
        sum = 0;
        for (int i = 0; i &lt; segments.length; ++i)
            segments[i].lock();
        for (int i = 0; i &lt; segments.length; ++i)
            sum += segments[i].count;
        for (int i = 0; i &lt; segments.length; ++i)
            segments[i].unlock();
    }
    if (sum &gt; Integer.MAX_VALUE)
        return Integer.MAX_VALUE;
    else
        return (int)sum;
}</p>
<p><strong>ConcurrentSkipListMap/Set</strong></p>
<p>本来打算介绍下ConcurrentSkipListMap的，结果打开源码一看，彻底放弃了。那里面的数据结构和算法我估计研究一周也未必能够完全弄懂。很久以前我看TreeMap的时候就头大，想想那些复杂的“红黑二叉树”我头都大了。这些都归咎于从前没有好好学习《数据结构和算法》，现在再回头看这些复杂的算法感觉非常头疼，为了减少脑细胞的死亡，暂且还是不要惹这些“玩意儿”。有兴趣的可以看看<a href="http://www.ibm.com/developerworks/cn/java/j-lo-tree/index.html?ca=drs-" target="_blank">参考资料4</a> 中对TreeMap的介绍。</p>
<p>参考资料：</p>
<ol>
<li><a href="http://tech.puredanger.com/2007/07/25/hash/" target="_blank">Hash this</a></li>
<li><a href="http://www.goworkday.com/2010/03/19/single-word-wangjenkins-hash-concurrenthashmap/" target="_blank">Single-word Wang/Jenkins Hash in ConcurrentHashMap</a></li>
<li><a href="http://www.blogjava.net/xylz/archive/2010/07/03/325168.html" target="_blank">指令重排序与happens-before法则</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/java/j-lo-tree/index.html?ca=drs-" target="_blank">通过分析 JDK 源代码研究 TreeMap 红黑树算法实现</a></li>
</ol>
<p>来源： <a href="[http://www.blogjava.net/xylz/archive/2010/07/20/326661.html](http://www.blogjava.net/xylz/archive/2010/07/20/326661.html)">[http://www.blogjava.net/xylz/archive/2010/07/20/326661.html](http://www.blogjava.net/xylz/archive/2010/07/20/326661.html)</a></p>
<p>Queue是JDK 5以后引入的新的集合类，它属于Java Collections Framework的成员，在Collection集合中和List/Set是同一级别的接口。通常来讲Queue描述的是一种FIFO的队列，当然不全都是，比如PriorityQueue是按照优先级的顺序（或者说是自然顺序，借助于Comparator接口）。</p>
<p>下图描述了Java Collections Framework中Queue的整个家族体系。</p>
<p>对于Queue而言是在Collection的基础上增加了offer/remove/poll/element/peek方法，另外重新定义了add方法。对于这六个方法，有不同的定义。</p>
<hr>
<p><strong>抛出异常</strong></p>
<p><strong>返回特殊值</strong></p>
<p><strong>操作描述</strong> 插入</p>
<p>add(e)</p>
<p>offer(e)</p>
<p>将元素加入到队列尾部 移除</p>
<p>remove()</p>
<p>poll()</p>
<p>移除队列头部的元素 检查</p>
<p>element()</p>
<p>peek()</p>
<p>返回队列头部的元素而不移除此元素</p>
<p>特别说明的是对于Queue而言，规范并没有规定是线程安全的，为了解决这个问题，引入了可阻塞的队列BlockingQueue。对于BlockingQueue而言所有操作的是线程安全的，并且队列的操作可以被阻塞，直到满足某种条件。Queue的另一个子接口Deque描述的是一个双向的队列。与Queue不同的是，Deque允许在队列的头部增加元素和在队列的尾部删除元素。也就是说Deque是一个双向队列。二者功能都有的队列就是BlockingDeque，这种阻塞队列允许在队列的头和尾部分别操作元素，应该说是Queue中功能最强大的实现。</p>
<p><a href="http://www.blogjava.net/images/blogjava_net/xylz/WindowsLiveWriter/ead4e8800e0c_FD45/image_4.png" target="_blank"><img src="&quot;image&quot;" alt="image"></a></p>
<p>在JDK 5之前LinkedList就已经存在，而且本身实现都是一种双向队列。所以到了JDK 5以后就将LinkedList同时实现Deque接口，这样LinkedList就又属于Queue的一部分了。</p>
<p>通常情况下Queue都是靠链表结构实现的，但是链表意味着有一些而外的引用开销，如果是双向链表开销就更大了。所以为了节省内存，一种方式就是使用固定大小的数组来实现队列。在这种情况下队列的大小是固定，元素的遍历通过数组的索引进行，很显然这是一种双向链表的模型。ArrayDeque就是这样一种实现。</p>
<p>另外ArrayBlockingQueue也是一种数组实现的队列，但是却没有改造成双向，仅仅实现了BlockingQueue的模型。理论上和ArrayDeque一样也应该容易改造成双向的实现。</p>
<p>PriorityQueue和PriorityBlockingQueue实现了一种排序的队列模型。这很类似与SortedSet，通过队列的Comparator接口或者Comparable元素来排序元素。这种情况下元素在队列中的出入就不是按照FIFO的形式，而是根据比较后的自然顺序来进行。</p>
<p>CocurrentLinkedQueue是一种线程安全却非阻塞的FIFO队列，这种队列通常实现起来比较简单，但是却很有效。在接下来的章节会详细的描述它。</p>
<p>SynchronousQueue是一种特别的BlockingQueue，它只是把一个add/offer操作的元素直接移交给remove/take操作。也就是说它本身不会缓存任何元素，所以严格意义上说来讲并不是一种真正的队列。此队列维护一个线程列表，这些线程等待从队列中加入元素或者移除元素。简单的说，至少有一个remove/take操作时add/offer操作才能成功，同样至少有一个add/offer操作时remove/take操作才能成功。这是一种双向等待的队列模型，出队列等待加入等列，而入队列又等待出队列。这种队列的好处在于能够最大线程的保持吞吐量却又是线程安全的。所以对于一个需要快速处理的任务队列，SynchronousQueue是一个不错的选择。</p>
<p>BlockingQueue还有一种实现DelayQueue，这种实现允许每一个元素(Delayed)带有一个延时时间，当调用take/poll的时候会检测队列头元素这个时间是否&lt;=0，如果满足就是说已经超时了，那么此元素就可以被移除了，否则就会等待。特别说明的是这个头元素应该是最先被超时的元素（这个时间是绝对时间）。这个类设计很巧妙，被用于ScheduledFutureTask来进行定时操作。希望后面会开辟一个章节讲讲这里面的想法。实在不行在讲线程池部分肯定会提到这个。
来源： <a href="[http://www.blogjava.net/xylz/archive/2010/07/21/326723.html](http://www.blogjava.net/xylz/archive/2010/07/21/326723.html)">[http://www.blogjava.net/xylz/archive/2010/07/21/326723.html](http://www.blogjava.net/xylz/archive/2010/07/21/326723.html)</a> </p>
<p>ConcurrentLinkedQueue是Queue的一个线程安全实现。先来看一段文档说明。</p>
<p>一个基于链接节点的无界线程安全队列。此队列按照 FIFO（先进先出）原则对元素进行排序。队列的头部 是队列中时间最长的元素。队列的尾部 是队列中时间最短的元素。新的元素插入到队列的尾部，队列获取操作从队列头部获得元素。当多个线程共享访问一个公共 collection 时，ConcurrentLinkedQueue 是一个恰当的选择。此队列不允许使用 null 元素。</p>
<p>由于ConcurrentLinkedQueue只是简单的实现了一个队列Queue，因此从API的角度讲，没有多少值的介绍，使用起来也很简单，和前面遇到的所有FIFO队列都类似。出队列只能操作头节点，入队列只能操作尾节点，任意节点操作就需要遍历完整的队列。</p>
<p>重点放在解释ConcurrentLinkedQueue的原理和实现上。</p>
<p>在继续探讨之前，结合前面线程安全的相关知识，我来分析设计一个线程安全的队列哪几种方法。</p>
<p>第一种：使用synchronized同步队列，就像Vector或者Collections.synchronizedList/Collection那样。显然这不是一个好的并发队列，这会导致吞吐量急剧下降。</p>
<p>第二种：使用Lock。一种好的实现方式是使用ReentrantReadWriteLock来代替ReentrantLock提高读取的吞吐量。但是显然ReentrantReadWriteLock的实现更为复杂，而且更容易导致出现问题，另外也不是一种通用的实现方式，因为ReentrantReadWriteLock适合哪种读取量远远大于写入量的场合。当然了ReentrantLock是一种很好的实现，结合Condition能够很方便的实现阻塞功能，这在后面介绍BlockingQueue的时候会具体分析。</p>
<p>第三种：使用CAS操作。尽管Lock的实现也用到了CAS操作，但是毕竟是间接操作，而且会导致线程挂起。一个好的并发队列就是采用某种非阻塞算法来取得最大的吞吐量。</p>
<p>ConcurrentLinkedQueue采用的就是第三种策略。它采用了<a href="http://www.cs.rochester.edu/u/scott/papers/1996_PODC_queues.pdf" target="_blank">参考资料1</a> 中的算法。</p>
<p>在锁机制中谈到过，要使用非阻塞算法来完成队列操作，那么就需要一种“循环尝试”的动作，就是循环操作队列，直到成功为止，失败就会再次尝试。这在前面的章节中多次介绍过。</p>
<p>针对各种功能深入分析。</p>
<p>在开始之前先介绍下ConcurrentLinkedQueue的数据结构。</p>
<p><a href="http://www.blogjava.net/images/blogjava_net/xylz/WindowsLiveWriter/JavaConcurrency20part5ConcurrentLinkedQu_C9AC/image_2.png" target="_blank"><img src="&quot;image&quot;" alt="image"></a>在上面的数据结构中，ConcurrentLinkedQueue只有头结点、尾节点两个元素，而对于一个节点Node而言除了保存队列元素item外，还有一个指向下一个节点的引用next。 看起来整个数据结构还是比较简单的。但是也有几点是需要说明：</p>
<ol>
<li>所有结构（head/tail/item/next）都是volatile类型。 这是因为ConcurrentLinkedQueue是非阻塞的，所以只有volatile才能使变量的写操作对后续读操作是可见的（这个是有happens-before法则保证的）。同样也不会导致指令的重排序。</li>
<li>所有结构的操作都带有原子操作，这是由AtomicReferenceFieldUpdater保证的，这在原子操作中介绍过。它能保证需要的时候对变量的修改操作是原子的。</li>
<li>由于队列中任何一个节点（Node）只有下一个节点的引用，所以这个队列是单向的，根据FIFO特性，也就是说出队列在头部(head)，入队列在尾部(tail)。头部保存有进入队列最长时间的元素，尾部是最近进入的元素。</li>
<li>没有对队列长度进行计数，所以队列的长度是无限的，同时获取队列的长度的时间不是固定的，这需要遍历整个队列，并且这个计数也可能是不精确的。</li>
<li>初始情况下队列头和队列尾都指向一个空节点，但是非null，这是为了方便操作，不需要每次去判断head/tail是否为空。但是head却不作为存取元素的节点，tail在不等于head情况下保存一个节点元素。也就是说head.item这个应该一直是空，但是tail.item却不一定是空（如果head!=tail，那么tail.item!=null）。</li>
</ol>
<p>对于第5点，可以从ConcurrentLinkedQueue的初始化中看到。这种头结点也叫“伪节点”，也就是说它不是真正的节点，只是一标识，就像c中的字符数组后面的\0以后，只是用来标识结束，并不是真正字符数组的一部分。
private transient volatile Node<E> head = new Node<E>(null, null);
private transient volatile Node<E> tail = head;</p>
<p>有了上述5点再来解释相关API操作就容易多了。</p>
<p>在上一节中列出了add/offer/remove/poll/element/peek等价方法的区别，所以这里就不再重复了。</p>
<p><strong><em>清单1 入队列操作</em></strong>
public boolean offer(E e) {
    if (e == null) throw new NullPointerException();
    Node<E> n = new Node<E>(e, null);
    for (;;) {
        Node<E> t = tail;
        Node<E> s = t.getNext();
        if (t == tail) {
            if (s == null) {
                if (t.casNext(s, n)) {
                    casTail(t, n);
                    return true;
                }
            } else {
                casTail(t, s);
            }
        }
    }
}</p>
<p>清单1 描述的是入队列的过程。整个过程是这样的。</p>
<ol>
<li>获取尾节点t，以及尾节点的下一个节点s。如果尾节点没有被别人修改，也就是t==tail，进行2，否则进行1。</li>
<li>如果s不为空，也就是说此时尾节点后面还有元素，那么就需要把尾节点往后移，进行1。否则进行3。</li>
<li>修改尾节点的下一个节点为新节点，如果成功就修改尾节点，返回true。否则进行1。</li>
</ol>
<p>从操作3中可以看到是先修改尾节点的下一个节点，然后才修改尾节点位置的，所以这才有操作2中为什么获取到的尾节点的下一个节点不为空的原因。</p>
<p>特别需要说明的是，对尾节点的tail的操作需要换成临时变量t和s，一方面是为了去掉volatile变量的可变性，另一方面是为了减少volatile的性能影响。</p>
<p>清单2 描述的出队列的过程，这个过程和入队列相似，有点意思。</p>
<p>头结点是为了标识队列起始，也为了减少空指针的比较，所以头结点总是一个item为null的非null节点。也就是说head!=null并且head.item==null总是成立。所以实际上获取的是head.next，一旦将头结点head设置为head.next成功就将新head的item设置为null。至于以前就的头结点h，h.item=null并且h.next为新的head，但是由于没有对h的引用，所以最终会被GC回收。这就是整个出队列的过程。</p>
<p><strong><em>清单2 出队列操作</em></strong>
public E poll() {
    for (;;) {
        Node<E> h = head;
        Node<E> t = tail;
        Node<E> first = h.getNext();
        if (h == head) {
            if (h == t) {
                if (first == null)
                    return null;
                else
                    casTail(t, first);
            } else if (casHead(h, first)) {
                E item = first.getItem();
                if (item != null) {
                    first.setItem(null);
                    return item;
                }
                // else skip over deleted item, continue loop,
            }
        }
    }
}</p>
<p>另外对于清单3 描述的获取队列大小的过程，由于没有一个计数器来对队列大小计数，所以获取队列的大小只能通过从头到尾完整的遍历队列，显然这个代价是很大的。所以通常情况下ConcurrentLinkedQueue需要和一个AtomicInteger搭配才能获取队列大小。后面介绍的BlockingQueue正是使用了这种思想。</p>
<p><strong>清单3 遍历队列大小</strong>
public int size() {
    int count = 0;
    for (Node<E> p = first(); p != null; p = p.getNext()) {
        if (p.getItem() != null) {
            // Collections.size() spec says to max out
            if (++count == Integer.MAX_VALUE)
                break;
        }
    }
    return count;
}</p>
<p>参考资料：</p>
<ol>
<li><a href="http://www.cs.rochester.edu/u/scott/papers/1996_PODC_queues.pdf" target="_blank">Simple, Fast, and Practical Non-Blocking and Blocking Concurrent Queue Algorithms</a></li>
<li><a href="http://yanxuxin.javaeye.com/blog/586943" target="_blank">多线程基础总结十一—ConcurrentLinkedQueue</a></li>
<li><a href="http://www.javaeye.com/topic/68279" target="_blank">对ConcurrentLinkedQueue进行的并发测试</a> </li>
</ol>
<p>来源： <a href="[http://www.blogjava.net/xylz/archive/2010/07/23/326934.html](http://www.blogjava.net/xylz/archive/2010/07/23/326934.html)">[http://www.blogjava.net/xylz/archive/2010/07/23/326934.html](http://www.blogjava.net/xylz/archive/2010/07/23/326934.html)</a></p>
<p>在《<a href="http://www.blogjava.net/xylz/archive/2010/07/21/326723.html" target="_blank">并发容器 part 4 并发队列与Queue简介</a>》节中的类图中可以看到，对于Queue来说，BlockingQueue是主要的线程安全版本。这是一个可阻塞的版本，也就是允许添加/删除元素被阻塞，直到成功为止。</p>
<p>BlockingQueue相对于Queue而言增加了两个操作：put/take。下面是一张整理的表格。</p>
<p><a href="http://www.blogjava.net/images/blogjava_net/xylz/WindowsLiveWriter/JavaConcurrency21part5ConcurrentLinkedQu_E370/image_4.png" target="_blank"><img src="&quot;image&quot;" alt="image"></a>看似简单的API，非常有用。这在控制队列的并发上非常有好处。既然加入队列和移除队列能够被阻塞，这在实现生产者-消费者模型上就简单多了。</p>
<p>清单1 是生产者-消费者模型的一个例子。这个例子是一个真实的场景。服务端（ICE服务）接受客户端的请求(accept)，请求计算此人的好友生日，然后将计算的结果存取缓存中（Memcache）中。在这个例子中采用了ExecutorService实现多线程的功能，尽可能的提高吞吐量，这个在后面线程池的部分会详细说明。目前就可以理解为new Thread(r).start()就可以了。另外这里阻塞队列使用的是LinkedBlockingQueue。</p>
<p><strong><em>清单1 一个生产者-消费者例子</em></strong>
package xylz.study.concurrency;</p>
<p>import java.util.concurrent.BlockingQueue;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.LinkedBlockingDeque;</p>
<p>public class BirthdayService {</p>
<pre><code>final int workerNumber;

final Worker[] workers;

final ExecutorService threadPool;

static volatile boolean running = true;

public BirthdayService(int workerNumber, int capacity) {
    if (workerNumber &lt;= 0) throw new IllegalArgumentException();
    this.workerNumber = workerNumber;
    workers = new Worker[workerNumber];
    for (int i = 0; i &lt; workerNumber; i++) {
        workers[i] = new Worker(capacity);
    }
    //
    boolean b = running;// kill the resorting
    threadPool = Executors.newFixedThreadPool(workerNumber);
    for (Worker w : workers) {
        threadPool.submit(w);
    }
}

Worker getWorker(int id) {
    return workers[id % workerNumber];

}

class Worker implements Runnable {

    final BlockingQueue&lt;Integer&gt; queue;

    public Worker(int capacity) {
        queue = new LinkedBlockingQueue&lt;Integer&gt;(capacity);
    }

    public void run() {
        while (true) {
            try {
                consume(queue.take());
            } catch (InterruptedException e) {
                return;
            }
        }
    }

    void put(int id) {
        try {
            queue.put(id);
        } catch (InterruptedException e) {
            return;
        }
    }
}

public void accept(int id) {
    //accept client request
    getWorker(id).put(id);
}

protected void consume(int id) {
    //do the work
    //get the list of friends and save the birthday to cache
}
</code></pre><p>}</p>
<p>在清单1 中可以看到不管是put()还是get()，都抛出了一个InterruptedException。我们就从这里开始，为什么会抛出这个异常。</p>
<p><a href="http://www.blogjava.net/xylz/archive/2010/07/23/326934.html" target="_blank">上一节</a>中提到实现一个并发队列有三种方式。显然只有第二种 Lock 才能实现阻塞队列。在锁机制中提到过，Lock结合Condition就可以实现线程的阻塞，这在锁机制部分的很多工具中都详细介绍过，而接下来要介绍的LinkedBlockingQueue就是采用这种方式。</p>
<p><strong>LinkedBlockingQueue 原理</strong></p>
<p><a href="http://www.blogjava.net/images/blogjava_net/xylz/WindowsLiveWriter/JavaConcurrency21part5ConcurrentLinkedQu_E370/image8_1.png" target="_blank"><img src="&quot;image&quot;" alt="image"></a>对比<a href="http://www.blogjava.net/xylz/archive/2010/07/23/326934.html" target="_blank">ConcurrentLinkedQueue的结构图</a>，LinkedBlockingQueue多了两个ReentrantLock和两个Condition以及用于计数的AtomicInteger，显然这会导致LinkedBlockingQueue的实现有点复杂。对照此结构，有以下几点说明：</p>
<ol>
<li>但是整体上讲，LinkedBlockingQueue和ConcurrentLinkedQueue的结构类似，都是采用头尾节点，每个节点指向下一个节点的结构，这表示它们在操作上应该类似。</li>
<li>LinkedBlockingQueue引入了原子计数器count，这意味着获取队列大小size()已经是常量时间了，不再需要遍历队列。每次队列长度有变更时只需要修改count即可。</li>
<li>有了修改Node指向有了锁，所以不需要volatile特性了。既然有了锁Node的item为什么需要volatile在后面会详细分析，暂且不表。</li>
<li>引入了两个锁，一个入队列锁，一个出队列锁。当然同时有一个队列不满的Condition和一个队列不空的Condition。其实参照锁机制前面介绍过的生产者-消费者模型就知道，入队列就代表生产者，出队列就代表消费者。为什么需要两个锁？一个锁行不行？其实一个锁完全可以，但是一个锁意味着入队列和出队列同时只能有一个在进行，另一个必须等待其释放锁。而从ConcurrentLinkedQueue的实现原理来看，事实上head和last (ConcurrentLinkedQueue中是tail)是分离的，互相独立的，这意味着入队列实际上是不会修改出队列的数据的，同时出队列也不会修改入队列，也就是说这两个操作是互不干扰的。更通俗的将，这个锁相当于两个写入锁，入队列是一种写操作，操作head，出队列是一种写操作，操作tail。可见它们是无关的。但是并非完全无关，后面详细分析。</li>
</ol>
<p>在没有揭示入队列和出队列过程前，暂且猜测下实现原理。</p>
<p>根据前面学到的锁机制原理结合ConcurrentLinkedQueue的原理，入队列的阻塞过程大概是这样的：</p>
<ol>
<li>获取入队列的锁putLock，检测队列大小，如果队列已满，那么就挂起线程，等待队列不满信号notFull的唤醒。</li>
<li>将元素加入到队列尾部，同时修改队列尾部引用last。</li>
<li>队列大小加1。</li>
<li>释放锁putLock。</li>
<li>唤醒notEmpty线程（如果有挂起的出队列线程），告诉消费者，已经有了新的产品。</li>
</ol>
<p>对比入队列，出队列的阻塞过程大概是这样的：</p>
<ol>
<li>获取出队列的锁takeLock，检测队列大小，如果队列为空，那么就挂起线程，等待队列不为空notEmpty的唤醒。</li>
<li>将元素从头部移除，同时修改队列头部引用head。</li>
<li>队列大小减1。</li>
<li>释放锁takeLock。</li>
<li>唤醒notFull线程（如果有挂起的入队列线程），告诉生产者，现在还有空闲的空间。</li>
</ol>
<p>下面来验证上面的过程。</p>
<p><strong>入队列过程（put/offer）</strong></p>
<p><strong><em>清单2 阻塞的入队列过程</em></strong>
public void put(E e) throws InterruptedException {
    if (e == null) throw new NullPointerException();
    int c = -1;
    final ReentrantLock putLock = this.putLock;
    final AtomicInteger count = this.count;
    putLock.lockInterruptibly();
    try {
        try {
            while (count.get() == capacity)
                notFull.await();
        } catch (InterruptedException ie) {
            notFull.signal(); // propagate to a non-interrupted thread
            throw ie;
        }
        insert(e);
        c = count.getAndIncrement();
        if (c + 1 &lt; capacity)
            notFull.signal();
    } finally {
        putLock.unlock();
    }
    if (c == 0)
        signalNotEmpty();
}</p>
<p>清单2 描述的是入队列的阻塞过程。可以看到和上面描述的入队列的过程基本相同。但是也有以下几个问题：</p>
<ol>
<li>如果在入队列的时候线程被中断，那么就需要发出一个notFull的信号，表示下一个入队列的线程能够被唤醒（如果阻塞的话）。</li>
<li>入队列成功后如果队列不满需要补一个notFull的信号。为什么？队列不满的时候其它入队列的阻塞线程难道不知道么？有可能。这是因为为了减少上下文切换的次数，每次唤醒一个线程（不管是入队列还是出队列）都是只随机唤醒一个(notify)，而不是唤醒所有的（notifyall()）。这会导致其它阻塞的入队列线程不能够即使处理队列不满的情况。</li>
<li>如果队列不为空并且可能有一个元素的话就唤醒一个出队列线程。这么做说明之前队列一定为空，因为在加入队列之后队列最多只能为1，那么说明未加入之前是0，那么就可能有被阻塞的出队列线程，所以就唤醒一个出队列线程。特别说明的是为什么使用一个临时变量c，而不用count。这是因为读取一个count的开销比读取一个临时一个变量大，而此处c又能够完成确认队列最多只有一个元素的判断。首先c默认为-1，如果加入队列后获取原子计数器的结果为0，说明之前队列为空，不可能消费（出队列），也不可能入队列，因为此时锁还在当前线程上，那么加入一个后队列就不为空了，所以就可以安全的唤醒一个消费（出对立）线程。</li>
<li>入队列的过程允许被中断，所以总是抛出InterruptedException 异常。</li>
</ol>
<p>针对第2点，特别补充说明下。本来这属于锁机制中条件队列的范围，由于没有应用场景，所以当时没有提。</p>
<p>前面提高notifyall总是比notify更可靠，因为notify可能丢失通知，为什么不适用notifyall呢？</p>
<p>先解释下notify丢失通知的问题。</p>
<p><strong>notify丢失通知问题</strong></p>
<p>假设线程A因为某种条件在条件队列中等待，同时线程B因为另外一种条件在同一个条件队列中等待，也就是说线程A/B都被同一个Conditon.await()挂起，但是等待的条件不同。现在假设线程B的线程被满足，线程C执行一个notify操作，此时JVM从Conditon.await()的多个线程（A/B）中随机挑选一个唤醒，不幸的是唤醒了A。此时A的条件不满足，于是A继续挂起。而此时B仍然在傻傻的等待被唤醒的信号。也就是说本来给B的通知却被一个无关的线程持有了，真正需要通知的线程B却没有得到通知，而B仍然在等待一个已经发生过的通知。</p>
<p>如果使用notifyall，则能够避免此问题。notifyall会唤醒所有正在等待的线程，线程C发出的通知线程A同样能够收到，但是由于对于A没用，所以A继续挂起，而线程B也收到了此通知，于是线程B正常被唤醒。</p>
<p>既然notifyall能够解决单一notify丢失通知的问题，那么为什么不总是使用notifyall替换notify呢？</p>
<p>假设有N个线程在条件队列中等待，调用notifyall会唤醒所有线程，然后这N个线程竞争同一个锁，最多只有一个线程能够得到锁，于是其它线程又回到挂起状态。这意味每一次唤醒操作可能带来大量的上下文切换（如果N比较大的话），同时有大量的竞争锁的请求。这对于频繁的唤醒操作而言性能上可能是一种灾难。</p>
<p>如果说总是只有一个线程被唤醒后能够拿到锁，那么为什么不使用notify呢？所以某些情况下使用notify的性能是要高于notifyall的。</p>
<p>如果满足下面的条件，可以使用单一的notify取代notifyall操作：
相同的等待者，也就是说等待条件变量的线程操作相同，每一个从wait放回后执行相同的逻辑，同时一个条件变量的通知至多只能唤醒一个线程。</p>
<p>也就是说理论上讲在put/take中如果使用sinallAll唤醒的话，那么在清单2 中的notFull.singal就是多余的。</p>
<p><strong>出队列过程（poll/take）</strong></p>
<p>再来看出队列过程。清单3 描述了出队列的过程。可以看到这和入队列是对称的。从这里可以看到，出队列使用的是和入队列不同的锁，所以入队列、出队列这两个操作才能并行进行。</p>
<p><strong><em>清单3 阻塞的出队列过程</em></strong>
public E take() throws InterruptedException {
    E x;
    int c = -1;
    final AtomicInteger count = this.count;
    final ReentrantLock takeLock = this.takeLock;
    takeLock.lockInterruptibly();
    try {
        try {
            while (count.get() == 0)
                notEmpty.await();
        } catch (InterruptedException ie) {
            notEmpty.signal(); // propagate to a non-interrupted thread
            throw ie;
        }</p>
<pre><code>    x = extract();
    c = count.getAndDecrement();
    if (c &gt; 1)
        notEmpty.signal();
} finally {
    takeLock.unlock();
}
if (c == capacity)
    signalNotFull();
return x;
</code></pre><p>}</p>
<p><strong>为什么有异常？</strong></p>
<p>有了入队列、出队列的过程后再来回答前面的几个问题。</p>
<p>为什么总是抛出InterruptedException 异常？ 这是很大一块内容，其实是Java对线程中断的处理问题，希望能够在系列文章的最后能够对此开辟单独的篇章来谈谈。</p>
<p>在锁机制里面也是总遇到，这是因为，Java里面没有一种直接的方法中断一个挂起的线程，所以通常情况下等于一个处于WAITING状态的线程，允许设置一个中断位，一旦线程检测到这个中断位就会从WAITING状态退出，以一个InterruptedException 的异常返回。所以只要是对一个线程挂起操作都会导致InterruptedException 的可能，比如Thread.sleep()、Thread.join()、Object.wait()。尽管LockSupport.park()不会抛出一个InterruptedException 异常，但是它会将当前线程的的interrupted状态位置上，而对于Lock/Condition而言，当捕捉到interrupted状态后就认为线程应该终止任务，所以就抛出了一个InterruptedException 异常。</p>
<p><strong>又见volatile</strong></p>
<p>还有一个不容易理解的问题。<strong>为什么Node.item是volatile类型的？</strong></p>
<p>起初我不大明白，因为对于一个进入队列的Node，它的item是不变，当且仅当出队列的时候会将头结点元素的item 设置为null。尽管在remove(o)的时候也是设置为null,但是那时候是加了putLock/takeLock两个锁的，所以肯定是没有问题的。那么问题出在哪？</p>
<p>我们知道，item的值是在put/offer的时候加入的。这时候都是有putLock锁保证的，也就是说它保证使用putLock锁的读取肯定是没有问题的。那么问题就只可能出在一个不适用putLock却需要读取Node.item的地方。</p>
<p>peek操作时获取头结点的元素而不移除它。显然他不会操作尾节点，所以它不需要putLock锁，也就是说它只有takeLock锁。清单4 描述了这个过程。</p>
<p><strong><em>清单4 查询队列头元素过程</em></strong>
public E peek() {
    if (count.get() == 0)
        return null;
    final ReentrantLock takeLock = this.takeLock;
    takeLock.lock();
    try {
        Node<E> first = head.next;
        if (first == null)
            return null;
        else
            return first.item;
    } finally {
        takeLock.unlock();
    }
}</p>
<p>清单4 描述了peek的过程，最后返回一个非null节点的结果是Node.item。这里读取了Node的item值，但是整个过程却是使用了takeLock而非putLock。换句话说putLock对Node.item的操作，peek()线程可能不可见！</p>
<p><strong><em>清单5 队列尾部加入元素</em></strong>
private void insert(E x) {
    last = last.next = new Node<E>(x);
}</p>
<p>清单5 是入队列offer/put的一部分，这里关键在于last=new Node<E>(x)可能发生重排序。Node构造函数是这样的：Node(E x) { item = x; }。在这一步里面我们可能得到以下一种情况：</p>
<ol>
<li>构建一个Node对象n；</li>
<li>将Node的n赋给last</li>
<li>初始化n，设置item=x</li>
</ol>
<p>在执行步骤2 的时候一个peek线程可能拿到了新的Node n，这时候它读取item，得到了一个null。显然这是不可靠的。</p>
<p>对item采用volatile之后，JMM保证对item=x的赋值一定在last=n之前，也就是说last得到的一个是一个已经赋值了的新节点n。这就不会导致读取空元素的问题的。</p>
<p>出对了poll/take和peek都是使用的takeLock锁，所以不会导致此问题。</p>
<p>删除操作和遍历操作由于同时获取了takeLock和putLock，所以也不会导致此问题。</p>
<p>总结：当前仅当元素加入队列时读取此元素才可能导致不一致的问题。采用volatile正式避免此问题。</p>
<p><strong>附加功能</strong></p>
<p>BlockingQueue有一个额外的功能，允许批量从队列中异常元素。这个API是：
<strong><em>int drainTo(Collection&lt;? super E&gt; c, int maxElements);</em></strong> 最多从此队列中移除给定数量的可用元素，并将这些元素添加到给定 collection 中。</p>
<p><strong><em>int drainTo(Collection&lt;? super E&gt; c);</em></strong> 移除此队列中所有可用的元素，并将它们添加到给定 collection 中。</p>
<p>清单6 描述的是最多移除指定数量元素的过程。由于批量操作只需要一次获取锁，所以效率会比每次获取锁要高。但是需要说明的，需要同时获取takeLock/putLock两把锁，因为当移除完所有元素后这会涉及到尾节点的修改（last节点仍然指向一个已经移走的节点）。</p>
<p>由于迭代操作<strong>contains()/remove()/iterator()</strong>也是获取了两个锁，所以迭代操作也是线程安全的。</p>
<p><strong><em>清单6 批量移除操作</em></strong>
public int drainTo(Collection&lt;? super E&gt; c, int maxElements) {
    if (c == null)
        throw new NullPointerException();
    if (c == this)
        throw new IllegalArgumentException();
    fullyLock();
    try {
        int n = 0;
        Node<E> p = head.next;
        while (p != null &amp;&amp; n &lt; maxElements) {
            c.add(p.item);
            p.item = null;
            p = p.next;
            ++n;
        }
        if (n != 0) {
            head.next = p;
            assert head.item == null;
            if (p == null)
                last = head;
            if (count.getAndAdd(-n) == capacity)
                notFull.signalAll();
        }
        return n;
    } finally {
        fullyUnlock();
    }
}</p>
<p>来源： <a href="[http://www.blogjava.net/xylz/archive/2010/07/24/326988.html](http://www.blogjava.net/xylz/archive/2010/07/24/326988.html)">[http://www.blogjava.net/xylz/archive/2010/07/24/326988.html](http://www.blogjava.net/xylz/archive/2010/07/24/326988.html)</a></p>
<p>在<a href="http://www.blogjava.net/xylz/archive/2010/07/24/326988.html" target="_blank">上一节</a>中详细分析了<strong>LinkedBlockingQueue </strong>的实现原理。实现一个可扩展的队列通常有两种方式：一种方式就像LinkedBlockingQueue一样使用链表，也就是每一个元素带有下一个元素的引用，这样的队列原生就是可扩展的；另外一种就是通过数组实现，一旦队列的大小达到数组的容量的时候就将数组扩充一倍（或者一定的系数倍），从而达到扩容的目的。常见的ArrayList就属于第二种。前面章节介绍过的HashMap确是综合使用了这两种方式。</p>
<p>对于一个Queue而言，同样可以使用数组实现。使用数组的好处在于各个元素之间原生就是通过数组的索引关联起来的，一次元素之间就是有序的，在通过索引操作数组就方便多了。当然也有它不利的一面，扩容起来比较麻烦，同时删除一个元素也比较低效。</p>
<p>ArrayBlockingQueue 就是Queue的一种数组实现。</p>
<p><strong>ArrayBlockingQueue 原理</strong></p>
<p>在没有介绍ArrayBlockingQueue原理之前可以想象下，一个数组如何实现Queue的FIFO特性。首先，数组是固定大小的，这个是毫无疑问的，那么初始化就是所有元素都为null。假设数组一段为头，另一端为尾。那么头和尾之间的元素就是FIFO队列。</p>
<ol>
<li>入队列就将尾索引往右移动一个，新元素加入尾索引的位置；</li>
<li>出队列就将头索引往尾索引方向移动一个，同时将旧头索引元素设为null，返回旧头索引的元素。</li>
<li>一旦数组已满，那么就不允许添加新元素（除非扩充容量）</li>
<li>如果尾索引移到了数组的最后（最大索引处），那么就从索引0开始，形成一个“闭合”的数组。</li>
<li>由于头索引和尾索引之间的元素都不能为空（因为为空不知道take出来的元素为空还是队列为空），所以删除一个头索引和尾索引之间的元素的话，需要移动删除索引前面或者后面的所有元素，以便填充删除索引的位置。</li>
<li>由于是阻塞队列，那么显然需要一个锁，另外由于只是一份数据（一个数组），所以只能有一个锁，也就是同时只能有一个线程操作队列。</li>
</ol>
<p>有了上述几点分析，设计一个可阻塞的数组队列就比较容易了。</p>
<p><a href="http://www.blogjava.net/images/blogjava_net/xylz/WindowsLiveWriter/JavaConcurrency22part7BlockingQueue2_1216F/image_4.png" target="_blank"><img src="&quot;image&quot;" alt="image"></a></p>
<p>上图描述的ArrayBlockingQueue的数据结构。首先有一个数组E[]，用来存储所有的元素。由于ArrayBlockingQueue最终设置为一个不可扩展大小的Queue，所以这里items就是初始化就固定大小的数组（final类型）；另外有两个索引，头索引takeIndex，尾索引putIndex；一个队列的大小count；要支持阻塞就必须需要一个锁lock和两个条件（非空、非满），这三个元素都是不可变更类型的（final）。</p>
<p>由于只有一把锁，所以任何时刻对队列的操作都只有一个线程，这意味着对索引和大小的操作都是线程安全的，所以可以看到这个takeIndex/putIndex/count就不需要原子操作和volatile语义了。</p>
<p>清单1 描述的是一个可阻塞的添加元素过程。这与前面介绍的消费者、生产者模型相同。如果队列已经满了就挂起等待，否则就插入元素，同时唤醒一个队列已空的线程。对比清单2 可以看到是完全相反的两个过程。这在前面几种实现生产者-消费者模型的时候都介绍过了。</p>
<p><strong><em>清单1 可阻塞的添加元素</em></strong>
public void put(E e) throws InterruptedException {
    if (e == null) throw new NullPointerException();
    final E[] items = this.items;
    final ReentrantLock lock = this.lock;
    lock.lockInterruptibly();
    try {
        try {
            while (count == items.length)
                notFull.await();
        } catch (InterruptedException ie) {
            notFull.signal(); // propagate to non-interrupted thread
            throw ie;
        }
        insert(e);
    } finally {
        lock.unlock();
    }
}</p>
<p> <strong><em>清单2 可阻塞的移除元素</em></strong>
public E take() throws InterruptedException {
    final ReentrantLock lock = this.lock;
    lock.lockInterruptibly();
    try {
        try {
            while (count == 0)
                notEmpty.await();
        } catch (InterruptedException ie) {
            notEmpty.signal(); // propagate to non-interrupted thread
            throw ie;
        }
        E x = extract();
        return x;
    } finally {
        lock.unlock();
    }
}</p>
<p>需要注意到的是，尽管每次加入、移除一个元素使用的都是signal()通知，而不是signalAll()通知。我们参考上一节中notify替换notifyAll的原则：每一个await醒来的动作相同，每次最多唤醒一个线程来操作。显然这里符合这两种条件，因此使用signal要比使用signalAll要高效，并且是可靠的。</p>
<p><a href="http://www.blogjava.net/images/blogjava_net/xylz/WindowsLiveWriter/JavaConcurrency22part7BlockingQueue2_1216F/image_10.png" target="_blank"><img src="&quot;image&quot;" alt="image"></a>上图描述了take()/put()的索引位置示意图。</p>
<p>一开始takeIndex/putIndex都在E/0位置，然后每加入一个元素offer/put，putIndex都增加1，也就是往后边移动一位；每移除一个元素poll/take，takeIndex都增加1，也是往后边移动一位，显然takeIndex总是在putIndex的“后边”，因为当队列中没有元素的时候takeIndex和putIndex相等，同时当前位置也没有元素，takeIndex也就是无法再往右边移动了；一旦putIndex/takeIndex移动到了最后面，也就是size-1的位置（这里size是指数组的长度），那么就移动到0，继续循环。循环的前提是数组中元素的个数小于数组的长度。整个过程就是这样的。可见putIndex同时指向头元素的下一个位置（如果队列已经满了，那么就是尾元素位置，否则就是一个元素为null的位置）。</p>
<p>比较复杂的操作时删除任意一个元素。清单3 描述的是删除任意一个元素的过程。显然删除任何一个元素需要遍历整个数组，也就是它的复杂度是O(n)，这与根据索引从ArrayList中查找一个元素的复杂度O(1)相比开销要大得多。参考声明的结构图，一旦删除的是takeIndex位置的元素，那么只需要将takeIndex往“右边”移动一位即可；如果删除的是takeIndex和putIndex之间的元素怎么办？这时候就从删除的位置i开始，将i后面的所有元素位置都往“左”移动一位，直到putIndex为止。最终的结果是删除位置的所有元素都“后退”了一个位置，同时putIndex也后退了一个位置。</p>
<p><strong><em>清单3 删除任意一个元素</em></strong>
public boolean remove(Object o) {
    if (o == null) return false;
    final E[] items = this.items;
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {
        int i = takeIndex;
        int k = 0;
        for (;;) {
            if (k++ &gt;= count)
                return false;
            if (o.equals(items[i])) {
                removeAt(i);
                return true;
            }
            i = inc(i);
        }</p>
<pre><code>} finally {
    lock.unlock();
}
</code></pre><p>}
void removeAt(int i) {
    final E[] items = this.items;
    // if removing front item, just advance
    if (i == takeIndex) {
        items[takeIndex] = null;
        takeIndex = inc(takeIndex);
    } else {
        // slide over all others up through putIndex.
        for (;;) {
            int nexti = inc(i);
            if (nexti != putIndex) {
                items[i] = items[nexti];
                i = nexti;
            } else {
                items[i] = null;
                putIndex = i;
                break;
            }
        }
    }
    --count;
    notFull.signal();
}</p>
<p>对于其他的操作，由于都是带着Lock的操作，所以都比较简单就不再展开了。</p>
<p>下一篇中将介绍另外两个BlockingQueue， PriorityBlockingQueue和SynchronousQueue 然后对这些常见的Queue进行一个小范围的对比。
来源： <a href="[http://www.blogjava.net/xylz/archive/2010/07/27/327265.html](http://www.blogjava.net/xylz/archive/2010/07/27/327265.html)">[http://www.blogjava.net/xylz/archive/2010/07/27/327265.html](http://www.blogjava.net/xylz/archive/2010/07/27/327265.html)</a> </p>
<p>在Set中有一个排序的集合SortedSet，用来保存按照自然顺序排列的对象。Queue中同样引入了一个支持排序的FIFO模型。</p>
<h3 id="-queue-http-www-blogjava-net-xylz-archive-2010-07-21-326723-html-priorityqueue-priorityblockingqueue-queue-queue-queue-priorityblockingqueue-priorityqueue-blocking-"><a href="http://www.blogjava.net/xylz/archive/2010/07/21/326723.html" target="_blank">并发队列与Queue简介</a> 中介绍了，PriorityQueue和PriorityBlockingQueue就是支持排序的Queue。显然一个支持阻塞的排序Queue要比一个非线程安全的Queue实现起来要复杂的多，因此下面只介绍PriorityBlockingQueue，至于PriorityQueue只需要去掉Blocking功能就基本相同了。</h3>
<p><strong>排序的BlockingQueue — PriorityBlockingQueue</strong></p>
<p>先简单介绍下PriorityQueue，因为PriorityBlockingQueue内部就是通过PriorityQueue适配实现的，只不过通过锁进行同步和阻塞而已。</p>
<p>PriorityQueue是一个数组实现的，是一个二叉树的实现，这个二叉树的任意一个节点都比其子节点要小，这样顶点就是最小的节点。每一个元素或者节点要么本身是可比较的（Comparable），或者队列本身带有一个比较器（Comparator&lt;? super E&gt;），所有元素就是靠比较自身的大小来确定顺序的。而数组中顶点就是数组的第0个元素，因此出队列的话总是取第0个元素。对于第0个元素，其子节点是第1个元素和第2个元素，对于第1个元素，其子元素又是第3/4个元素，以此类推，第i个元素的父节点就是(i-1)/2。这样任意一个元素加入队列就从其父节点(i-1)/2开始比较，一旦新节点比父节点小就交换两个节点，然后继续比较新节点与其新的父节点。知道所有节点都是按照父节点一定比子节点小的顺序排列。这是一个有点复杂的算法，此处不再讨论更多的细节。不管是删除还是查找，我们只需要了解的顶点（索引为0的元素）总是最小的。</p>
<p>特别需要说明的是PriorityQueue是一个无界的队列，也就是说一旦元素的个数达到了数组的大小，那么就将数组扩大50%，这样这个数组就是无穷大的。当然了如果达到了整数的最大值就会得到一个OutOfMemoryError，这个是由逻辑保证的。</p>
<p>对于PriorityBlockingQueue而言，由于是无界的，因此就只有非空的信号，也就是说只有take()才能阻塞，put是永远不会阻塞（除非达到Integer.MAX_VALUE直到抛出一个OutOfMemoryError异常）。</p>
<p>只有take()操作的时候才可能因为队列为空而挂起。同时其它需要操作队列变化和大小的只需要使用独占锁ReentrantLock就可以了，非常方便。需要说明的是PriorityBlockingQueue采用了一个公平的锁。</p>
<p>总的来说PriorityBlockingQueue 不是一个FIFO的队列，而是一个有序的队列，这个队列总是取“自然顺序”最小的对象，同时又是一个只能出队列阻塞的BlockingQueue，对于入队列却不是阻塞的。所有操作都是线程安全的。</p>
<p><strong>直接交换的BlockingQueue — SynchronousQueue</strong></p>
<p>这是一个很有意思的阻塞队列，其中每个插入操作必须等待另一个线程的移除操作，同样任何一个移除操作都等待另一个线程的插入操作。因此此队列内部其实没有任何一个元素，或者说容量是0，严格说并不是一种容器。由于队列没有容量，因此不能调用peek操作，因为只有移除元素时才有元素。</p>
<p>一个没有容量的并发队列有什么用了？或者说存在的意义是什么？</p>
<p>SynchronousQueue 的实现非常复杂，当然了如果真要去分析还是能够得到一些经验的，但是前面分析了过多的结构后，发现越来越陷于数据结构与算法里面了。我的初衷是通过研究并发实现的原理来更好的利用并发来最大限度的利用可用资源。所以在后面的章节中尽可能的少研究数据结构和算法，但是为了弄清楚里面的原理，必不可免的会涉及到一些这方面的知识，希望后面能够适可而止。</p>
<p>再回到话题。SynchronousQueue 内部没有容量，但是由于一个插入操作总是对应一个移除操作，反过来同样需要满足。那么一个元素就不会再SynchronousQueue 里面长时间停留，一旦有了插入线程和移除线程，元素很快就从插入线程移交给移除线程。也就是说这更像是一种信道（管道），资源从一个方向快速传递到另一方向。</p>
<p>需要特别说明的是，尽管元素在SynchronousQueue 内部不会“停留”，但是并不意味之SynchronousQueue 内部没有队列。实际上SynchronousQueue 维护者线程队列，也就是插入线程或者移除线程在不同时存在的时候就会有线程队列。既然有队列，同样就有公平性和非公平性特性，公平性保证正在等待的插入线程或者移除线程以FIFO的顺序传递资源。</p>
<p>显然这是一种快速传递元素的方式，也就是说在这种情况下元素总是以最快的方式从插入着（生产者）传递给移除着（消费者），这在多任务队列中是最快处理任务的方式。在线程池的相关章节中还会更多的提到此特性。</p>
<p>事实上在《<a href="http://www.blogjava.net/xylz/archive/2010/07/21/326723.html" target="_blank">并发队列与Queue简介</a>》中介绍了还有一种BlockingQueue的实现DelayQueue，它描述的是一种延时队列。这个队列的特性是，队列中的元素都要延迟时间（超时时间），只有一个元素达到了延时时间才能出队列，也就是说每次从队列中获取的元素总是最先到达延时的元素。这种队列的场景就是计划任务。比如以前要完成计划任务，很有可能是使用Timer/TimerTask，这是一种循环检测的方式，也就是在循环里面遍历所有元素总是检测元素是否满足条件，一旦满足条件就执行相关任务。显然这中方式浪费了很多的检测工作，因为大多数时间总是在进行无谓的检测。而DelayQueue 却能避免这种无谓的检测。在线程池的计划任务部分还有更加详细的讨论此队列实现。</p>
<p>下面就对常见的BlockingQueue进行小节下，这里不包括双向的队列，尽管ConcurrentLinkedQueue不是可阻塞的Queue，但是这里还是将其放在一起进行对比。</p>
<p><a href="http://www.blogjava.net/images/blogjava_net/xylz/WindowsLiveWriter/JavaConcurrency23part8BlockingQueue3_1086D/image_2.png" target="_blank"><img src="&quot;并发队列比较&quot;" alt="并发队列比较"></a></p>
<p>如果不需要阻塞队列，优先选择ConcurrentLinkedQueue；如果需要阻塞队列，队列大小固定优先选择ArrayBlockingQueue，队列大小不固定优先选择LinkedBlockingQueue；如果需要对队列进行排序，选择PriorityBlockingQueue；如果需要一个快速交换的队列，选择SynchronousQueue；如果需要对队列中的元素进行延时操作，则选择DelayQueue。
来源： <a href="[http://www.blogjava.net/xylz/archive/2010/07/30/327582.html](http://www.blogjava.net/xylz/archive/2010/07/30/327582.html)">[http://www.blogjava.net/xylz/archive/2010/07/30/327582.html](http://www.blogjava.net/xylz/archive/2010/07/30/327582.html)</a> </p>
<p>有一段时间没有更新了。接着上节继续吧。</p>
<p>Queue除了前面介绍的实现外，还有一种双向的Queue实现Deque。这种队列允许在队列头和尾部进行入队出队操作，因此在功能上比Queue显然要更复杂。下图描述的是Deque的完整体系图。需要说明的是LinkedList也已经加入了Deque的一部分（LinkedList是从jdk1.2 开始就存在数据结构）。</p>
<p><a href="http://www.blogjava.net/images/blogjava_net/xylz/WindowsLiveWriter/JavaConcurrency24part9Deque_1425C/image_2.png" target="_blank"><img src="&quot;Deque体系结构&quot;" alt="Deque体系结构"></a></p>
<p>Deque在Queue的基础上增加了更多的操作方法。</p>
<p><a href="http://www.blogjava.net/images/blogjava_net/xylz/WindowsLiveWriter/JavaConcurrency24part9Deque_1425C/image_4.png" target="_blank"><img src="&quot;Deque操作方法&quot;" alt="Deque操作方法"></a></p>
<p>从上图可以看到，Deque不仅具有FIFO的Queue实现，也有FILO的实现，也就是不仅可以实现队列，也可以实现一个堆栈。</p>
<p>同时在Deque的体系结构图中可以看到，实现一个Deque可以使用数组（ArrayDeque），同时也可以使用链表（LinkedList），还可以同实现一个支持阻塞的线程安全版本队列LinkedBlockingDeque。</p>
<p><a href="http://www.blogjava.net/images/blogjava_net/xylz/WindowsLiveWriter/JavaConcurrency24part9Deque_1425C/image_6.png" target="_blank"><img src="&quot;image&quot;" alt="image"></a>对于数组实现的Deque来说，数据结构上比较简单，只需要一个存储数据的数组以及头尾两个索引即可。由于数组是固定长度的，所以很容易就得到数组的头和尾，那么对于数组的操作只需要移动头和尾的索引即可。</p>
<p>特别说明的是ArrayDeque并不是一个固定大小的队列，每次队列满了以后就将队列容量扩大一倍（doubleCapacity()），因此加入一个元素总是能成功，而且也不会抛出一个异常。也就是说ArrayDeque是一个没有容量限制的队列。</p>
<p>同样继续性能的考虑，使用System.arraycopy复制一个数组比循环设置要高效得多。</p>
<p><a href="http://www.blogjava.net/images/blogjava_net/xylz/WindowsLiveWriter/JavaConcurrency24part9Deque_1425C/image_8.png" target="_blank"><img src="&quot;image&quot;" alt="image"></a></p>
<p>对于LinkedList本身而言，数据结构就更简单了，除了一个size用来记录大小外，只有head一个元素Entry。对比Map和Queue的其它数据结构可以看到这里的Entry有两个引用，是双向的队列。</p>
<p>在示意图中，LinkedList总是有一个“傀儡”节点，用来描述队列“头部”，但是并不表示头部元素，它是一个执行null的空节点。</p>
<p>队列一开始只有head一个空元素，然后从尾部加入E1(add/addLast)，head和E1之间建立双向链接。然后继续从尾部加入E2，E2就在head和E1之间建立双向链接。最后从队列的头部加入E3(push/addFirst)，于是E3就在E1和head之间链接双向链接。</p>
<p>双向链表的数据结构比较简单，操作起来也比较容易，从事从“傀儡”节点开始，“傀儡”节点的下一个元素就是队列的头部，前一个元素是队列的尾部，换句话说，“傀儡”节点在头部和尾部之间建立了一个通道，是整个队列形成一个循环，这样就可以从任意一个节点的任意一个方向能遍历完整的队列。</p>
<p>同样LinkedList也是一个没有容量限制的队列，因此入队列（不管是从头部还是尾部）总能成功。</p>
<p>上面描述的ArrayDeque和LinkedList是两种不同方式的实现，通常在遍历和节省内存上ArrayDeque更高效（索引更快，另外不需要Entry对象），但是在队列扩容下LinkedList更灵活，因为不需要复制原始的队列，某些情况下可能更高效。</p>
<p>同样需要注意的上述两个实现都不是线程安全的，因此只适合在单线程环境下使用，下面章节要介绍的LinkedBlockingDeque就是线程安全的可阻塞的Deque。事实上也应该是功能最强大的Queue实现，当然了实现起来也许会复杂一点。
来源： <a href="[http://www.blogjava.net/xylz/archive/2010/08/12/328587.html](http://www.blogjava.net/xylz/archive/2010/08/12/328587.html)">[http://www.blogjava.net/xylz/archive/2010/08/12/328587.html](http://www.blogjava.net/xylz/archive/2010/08/12/328587.html)</a> </p>
<p>这个小节介绍Queue的最后一个工具，也是最强大的一个工具。从名称上就可以看到此工具的特点：双向并发阻塞队列。所谓双向是指可以从队列的头和尾同时操作，并发只是线程安全的实现，阻塞允许在入队出队不满足条件时挂起线程，这里说的队列是指支持FIFO/FILO实现的链表。</p>
<p>首先看下LinkedBlockingDeque的数据结构。通常情况下从数据结构上就能看出这种实现的优缺点，这样就知道如何更好的使用工具了。</p>
<p><a href="http://www.blogjava.net/images/blogjava_net/xylz/WindowsLiveWriter/JavaConcurrency25part10BlockingDeque_CB65/image_2.png" target="_blank"><img src="&quot;LinkedBlockingDeque类图&quot;" alt="LinkedBlockingDeque类图"></a></p>
<p>从数据结构和功能需求上可以得到以下结论：</p>
<ol>
<li>要想支持阻塞功能，队列的容量一定是固定的，否则无法在入队的时候挂起线程。也就是capacity是final类型的。</li>
<li>既然是双向链表，每一个结点就需要前后两个引用，这样才能将所有元素串联起来，支持双向遍历。也即需要prev/next两个引用。</li>
<li>双向链表需要头尾同时操作，所以需要first/last两个节点，当然可以参考LinkedList那样采用一个节点的双向来完成，那样实现起来就稍微麻烦点。</li>
<li>既然要支持阻塞功能，就需要锁和条件变量来挂起线程。这里使用一个锁两个条件变量来完成此功能。</li>
</ol>
<p>有了上面的结论再来研究LinkedBlockingDeque的优缺点。</p>
<p>优点当然是功能足够强大，同时由于采用一个独占锁，因此实现起来也比较简单。所有对队列的操作都加锁就可以完成。同时独占锁也能够很好的支持双向阻塞的特性。</p>
<p>凡事有利必有弊。缺点就是由于独占锁，所以不能同时进行两个操作，这样性能上就大打折扣。从性能的角度讲LinkedBlockingDeque要比LinkedBlockingQueue要低很多，比CocurrentLinkedQueue就低更多了，这在高并发情况下就比较明显了。</p>
<p>前面分析足够多的Queue实现后，LinkedBlockingDeque的原理和实现就不值得一提了，无非是在独占锁下对一个链表的普通操作。</p>
<p>有趣的是此类支持序列化，但是Node并不支持序列化，因此fist/last就不能序列化，那么如何完成序列化/反序列化过程呢？</p>
<p><strong><em>清单1 LinkedBlockingDeque的序列化、反序列化</em></strong>
private void writeObject(java.io.ObjectOutputStream s)
    throws java.io.IOException {
    lock.lock();
    try {
        // Write out capacity and any hidden stuff
        s.defaultWriteObject();
        // Write out all elements in the proper order.
        for (Node<E> p = first; p != null; p = p.next)
            s.writeObject(p.item);
        // Use trailing null as sentinel
        s.writeObject(null);
    } finally {
        lock.unlock();
    }
}</p>
<p>private void readObject(java.io.ObjectInputStream s)
    throws java.io.IOException, ClassNotFoundException {
    s.defaultReadObject();
    count = 0;
    first = null;
    last = null;
    // Read in all elements and place in queue
    for (;;) {
        E item = (E)s.readObject();
        if (item == null)
            break;
        add(item);
    }
}</p>
<p>清单1 描述的是LinkedBlockingDeque序列化/反序列化的过程。序列化时将真正的元素写入输出流，最后还写入了一个null。读取的时候将所有对象列表读出来，如果读取到一个null就表示结束。这就是为什么写入的时候写入一个null的原因，因为没有将count写入流，所以就靠null来表示结束，省一个整数空间。</p>
<p>来源： <a href="[http://www.blogjava.net/xylz/archive/2010/08/18/329227.html](http://www.blogjava.net/xylz/archive/2010/08/18/329227.html)">[http://www.blogjava.net/xylz/archive/2010/08/18/329227.html](http://www.blogjava.net/xylz/archive/2010/08/18/329227.html)</a> </p>
<p>可以在对中对元素进行配对和交换的线程的同步点。每个线程将条目上的某个方法呈现给 </p>
<p>exchange
 方法，与伙伴线程进行匹配，并且在返回时接收其伙伴的对象。Exchanger 可能被视为 </p>
<p>SynchronousQueue
 的双向形式。</p>
<p>换句话说Exchanger提供的是一个交换服务，允许原子性的交换两个（多个）对象，但同时只有一对才会成功。先看一个简单的实例模型。</p>
<p><a href="http://www.blogjava.net/images/blogjava_net/xylz/Windows-Live-Writer/-Java-Concurrency-26--part-11--BlockingD_12273/Exchanger_2.png" target="_blank"><img src="&quot;Exchanger&quot;" alt="Exchanger"></a></p>
<p>在上面的模型中，我们假定一个空的栈（Stack），栈顶（Top）当然是没有元素的。同时我们假定一个数据结构Node，包含一个要交换的元素E和一个要填充的“洞”Node。这时线程T1携带节点node1进入栈（cas_push)，当然这是CAS操作，这样栈顶就不为空了。线程T2携带节点node2进入栈，发现栈里面已经有元素了node1，同时发现node1的hold（Node）为空，于是将自己（node2）填充到node1的hold中（cas_fill）。然后将元素node1从栈中弹出（cas_take）。这样线程T1就得到了node1.hold.item也就是node2的元素e2，线程T2就得到了node1.item也就是e1，从而达到了交换的目的。</p>
<p>算法描述就是下图展示的内容。</p>
<p><a href="http://www.blogjava.net/images/blogjava_net/xylz/Windows-Live-Writer/-Java-Concurrency-26--part-11--BlockingD_12273/image_4.png" target="_blank"><img src="&quot;image&quot;" alt="image"></a></p>
<p>JDK 5就是采用类似的思想实现的Exchanger。JDK 6以后为了支持多线程多对象同时Exchanger了就进行了改造（为了支持更好的并发），采用ConcurrentHashMap的思想，将Stack分割成很多的片段（或者说插槽Slot），线程Id（Thread.getId()）hash相同的落在同一个Slot上，这样在默认32个Slot上就有很好的吞吐量。当然会根据机器CPU内核的数量有一定的优化，有兴趣的可以去了解下Exchanger的源码。</p>
<p>至于Exchanger的使用，在JDK文档上有个例子，讲述的是两个线程交换数据缓冲区的例子（实际上仍然可以认为是生产者/消费者模型）。
class FillAndEmpty {
   Exchanger<DataBuffer> exchanger = new Exchanger<DataBuffer>();
   DataBuffer initialEmptyBuffer = <img src="" alt=""> a made-up type
   DataBuffer initialFullBuffer = <img src="" alt="">
   class FillingLoop implements Runnable {
     public void run() {
       DataBuffer currentBuffer = initialEmptyBuffer;
       try {
         while (currentBuffer != null) {
           addToBuffer(currentBuffer);
           if (currentBuffer.isFull())
             currentBuffer = exchanger.exchange(currentBuffer);
         }
       } catch (InterruptedException ex) { <img src="" alt=""> handle <img src="" alt=""> }
     }
   }
   class EmptyingLoop implements Runnable {
     public void run() {
       DataBuffer currentBuffer = initialFullBuffer;
       try {
         while (currentBuffer != null) {
           takeFromBuffer(currentBuffer);
           if (currentBuffer.isEmpty())
             currentBuffer = exchanger.exchange(currentBuffer);
         }
       } catch (InterruptedException ex) { <img src="" alt=""> handle <img src="" alt="">}
     }
   }
   void start() {
     new Thread(new FillingLoop()).start();
     new Thread(new EmptyingLoop()).start();
   }
  }</p>
<p>Exchanger实现的是一种数据分片的思想，这在大数据情况下将数据分成一定的片段并且多线程执行的情况下有一定的使用价值。</p>
<p>最近一直推托工作忙，更新频度越来越低了，好在现在的工作还有点个人时间，以后争取多更新下吧，至少也要把这个专辑写完。
来源： <a href="[http://www.blogjava.net/xylz/archive/2010/11/22/338733.html](http://www.blogjava.net/xylz/archive/2010/11/22/338733.html)">[http://www.blogjava.net/xylz/archive/2010/11/22/338733.html](http://www.blogjava.net/xylz/archive/2010/11/22/338733.html)</a> </p>
<p>本小节是《并发容器》的最后一部分，这一个小节描述的是针对List/Set接口的一个线程版本。</p>
<p>在《<a href="http://www.blogjava.net/xylz/archive/2010/07/21/326723.html" target="_blank">并发队列与Queue简介</a>》中介绍了并发容器的一个概括，主要描述的是Queue的实现。其中特别提到一点LinkedList是List/Queue的实现，但是LinkedList确实非线程安全的。不管BlockingQueue还是ConcurrentMap的实现，我们发现都是针对链表的实现，当然尽可能的使用CAS或者Lock的特性，同时都有通过锁部分容器来提供并发的特性。而对于List或者Set而言，增、删操作其实都是针对整个容器，因此每次操作都不可避免的需要锁定整个容器空间，性能肯定会大打折扣。要实现一个线程安全的List/Set，只需要在修改操作的时候进行同步即可，比如使用java.util.Collections.synchronizedList(List<T>)或者java.util.Collections.synchronizedSet(Set<T>)。当然也可以使用Lock来实现线程安全的List/Set。</p>
<p>通常情况下我们的高并发都发生在“多读少写”的情况，因此如果能够实现一种更优秀的算法这对生产环境还是很有好处的。ReadWriteLock当然是一种实现。CopyOnWriteArrayList/CopyOnWriteArraySet确实另外一种思路。</p>
<p>CopyOnWriteArrayList/CopyOnWriteArraySet的基本思想是一旦对容器有修改，那么就“复制”一份新的集合，在新的集合上修改，然后将新集合复制给旧的引用。当然了这部分少不了要加锁。显然对于CopyOnWriteArrayList/CopyOnWriteArraySet来说最大的好处就是“读”操作不需要锁了。</p>
<p>我们来看看源码。
//<em>/</em> The array, accessed only via getArray/setArray. /*/
private volatile transient Object[] array;
public E get(int index) {
    return (E)(getArray()[index]);
}
private static int indexOf(Object o, Object[] elements,
                           int index, int fence) {
    if (o == null) {
        for (int i = index; i &lt; fence; i++)
            if (elements[i] == null)
                return i;
    } else {
        for (int i = index; i &lt; fence; i++)
            if (o.equals(elements[i]))
                return i;
    }
    return -1;
}
public Iterator<E> iterator() {
    return new COWIterator<E>(getArray(), 0);
}
    public void clear() {
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {
        setArray(new Object[0]);
    } finally {
        lock.unlock();
    }
    }</p>
<p>对于上述代码，有几点说明：</p>
<ol>
<li>List仍然是基于数组的实现，因为只有数组是最快的。</li>
<li>为了保证无锁的读操作能够看到写操作的变化，因此数组array是volatile类型的。</li>
<li>get/indexOf/iterator等操作都是无锁的，同时也可以看到所操作的都是某一时刻array的镜像（这得益于数组是不可变化的）</li>
<li>add/set/remove/clear等元素变化的都是需要加锁的，这里使用的是ReentrantLock。</li>
</ol>
<p>这里有一段有意思的代码片段。
    public E set(int index, E element) {
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {
        Object[] elements = getArray();
        Object oldValue = elements[index];
        if (oldValue != element) {
        int len = elements.length;
        Object[] newElements = Arrays.copyOf(elements, len);
        newElements[index] = element;
        setArray(newElements);
        } else {
        // Not quite a no-op; ensures volatile write semantics
        setArray(elements);
        }
        return (E)oldValue;
    } finally {
        lock.unlock();
    }
    }
final void setArray(Object[] a) {
    array = a;
}</p>
<p>对于set操作，如果元素有变化，修改后setArray(newElements);将新数组赋值还好理解。那么如果一个元素没有变化，也就是上述代码的else部分，为什么还需要进行一个无谓的setArray操作？毕竟setArray操作没有改变任何数据。</p>
<p>对于这个问题也是很有意思，有一封邮件讨论了此问题（<a href="http://cs.oswego.edu/pipermail/concurrency-interest/2010-February/006886.html" target="_blank">1</a>、<a href="http://cs.oswego.edu/pipermail/concurrency-interest/2010-February/006887.html" target="_blank">2</a>、<a href="http://cs.oswego.edu/pipermail/concurrency-interest/2010-February/006888.html" target="_blank">3</a>）。
大致的意思是，尽管没有改变任何数据，但是为了保持“volatile”的语义，任何一个读操作都应该是一个写操作的结果，也就是读操作看到的数据一定是某个写操作的结果（尽管写操作没有改变数据本身）。所以这里即使不设置也没有问题，仅仅是为了一个语义上的补充（个人理解）。</p>
<p>这里还有一个有意思的讨论，说什么addIfAbsent在元素没有变化的时候为什么没有setArray操作？这个要看怎么理解addIfAbsent的语义了。如果说addIfAbsent语义是”写“或者”不写“操作，而把”不写“操作当作一次”读“操作的话，那么”读“操作就不需要保持volatile语义了。</p>
<p>对于CopyOnWriteArraySet而言就简单多了，只是持有一个CopyOnWriteArrayList，仅仅在add/addAll的时候检测元素是否存在，如果存在就不加入集合中。
private final CopyOnWriteArrayList<E> al;
//<em>/</em>
/<em> Creates an empty set.
/</em>/
public CopyOnWriteArraySet() {
    al = new CopyOnWriteArrayList<E>();
}
public boolean add(E e) {
    return al.addIfAbsent(e);
}</p>
<p>在使用上CopyOnWriteArrayList/CopyOnWriteArraySet就简单多了，和List/Set基本相同，这里就不再介绍了。</p>
<p>整个并发容器结束了，接下来好好规划下线程池部分，然后进入最后一部分的梳理。
来源： <a href="[http://www.blogjava.net/xylz/archive/2010/11/23/338853.html](http://www.blogjava.net/xylz/archive/2010/11/23/338853.html)">[http://www.blogjava.net/xylz/archive/2010/11/23/338853.html](http://www.blogjava.net/xylz/archive/2010/11/23/338853.html)</a> </p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/Java_多线程/">Java_多线程</a></li><li><a href="/categories/Java&J2EE/Java_多线程/并发/">并发</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/Java_多线程/" class="label label-success">Java_多线程</a><a href="/tags/并发/" class="label label-info">并发</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:41"datetime="2014-03-07 09:54:41"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-Java_多线程-并发--深入浅出JavaConcurrency4-并发容器/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-Java_多线程-并发--深入浅出JavaConcurrency4-并发容器" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_多线程-并发--聊聊并发（五）——原子操作的实现原理/">聊聊并发（五）——原子操作的实现原理</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:41.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_多线程-并发--聊聊并发（五）——原子操作的实现原理/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-">聊聊并发（五）——原子操作的实现原理</h1>
<h3 id="-">分享到</h3>
<ul>
<li><a href="">一键分享</a></li>
<li><a href="">QQ空间</a></li>
<li><a href="">新浪微博</a></li>
<li><a href="">百度搜藏</a></li>
<li><a href="">人人网</a></li>
<li><a href="">腾讯微博</a></li>
<li><a href="">百度相册</a></li>
<li><a href="">开心网</a></li>
<li><a href="">腾讯朋友</a></li>
<li><a href="">百度贴吧</a></li>
<li><a href="">豆瓣网</a></li>
<li><a href="">搜狐微博</a></li>
<li><a href="">百度新首页</a></li>
<li><a href="">QQ好友</a></li>
<li><a href="">和讯微博</a></li>
<li><a href="">更多...</a></li>
</ul>
<p><a href="">百度分享</a></p>
<h1 id="-">聊聊并发（五）——原子操作的实现原理</h1>
<p>作者 <a href="http://www.infoq.com/cn/author/%E6%96%B9%E8%85%BE%E9%A3%9E" target="_blank">方腾飞</a> 发布于 十一月 29, 2012 <em>|</em> <a href="">14 评论</a></p>
<h2 id="1-">1. 引言</h2>
<p>原子（atom）本意是“不能被进一步分割的最小粒子”，而原子操作（atomic operation）意为&quot;不可被中断的一个或一系列操作&quot; 。在多处理器上实现原子操作就变得有点复杂。本文让我们一起来聊一聊在Intel处理器和Java里是如何实现原子操作的。</p>
<h2 id="2-">2. 术语定义</h2>
<p>术语 英文 解释 缓存行 Cache line 缓存的最小操作单位 比较并交换 Compare and Swap CAS操作需要输入两个数值，一个旧值（期望操作前的值）和一个新值，在操作期间先比较下旧值有没有发生变化，如果没有发生变化，才交换成新值，发生了变化则不交换。 CPU流水线 CPU pipeline CPU流水线的工作方式就象工业生产上的装配流水线，在CPU中由5~6个不同功能的电路单元组成一条指令处理流水线，然后将一条X86指令分成5~6步后再由这些电路单元分别执行，这样就能实现在一个CPU时钟周期完成一条指令，因此提高CPU的运算速度。 内存顺序冲突 Memory order violation 内存顺序冲突一般是由假共享引起，假共享是指多个CPU同时修改同一个缓存行的不同部分而引起其中一个CPU的操作无效，当出现这个内存顺序冲突时，CPU必须清空流水线。</p>
<h2 id="3-">3. 处理器如何实现原子操作</h2>
<p>32位IA-32处理器使用基于对缓存加锁或总线加锁的方式来实现多处理器之间的原子操作。</p>
<h3 id="3-1-">3.1 处理器自动保证基本内存操作的原子性</h3>
<p>首先处理器会自动保证基本的内存操作的原子性。处理器保证从系统内存当中读取或者写入一个字节是原子的，意思是当一个处理器读取一个字节时，其他处理器不能访问这个字节的内存地址。奔腾6和最新的处理器能自动保证单处理器对同一个缓存行里进行16/32/64位的操作是原子的，但是复杂的内存操作处理器不能自动保证其原子性，比如跨总线宽度，跨多个缓存行，跨页表的访问。但是处理器提供总线锁定和缓存锁定两个机制来保证复杂内存操作的原子性。</p>
<h3 id="3-2-">3.2 使用总线锁保证原子性</h3>
<p>第一个机制是通过总线锁保证原子性。如果多个处理器同时对共享变量进行读改写（i++就是经典的读改写操作）操作，那么共享变量就会被多个处理器同时进行操作，这样读改写操作就不是原子的，操作完之后共享变量的值会和期望的不一致，举个例子：如果i=1,我们进行两次i++操作，我们期望的结果是3，但是有可能结果是2。如下图</p>
<p><img src="" alt=""></p>
<p>（例1）</p>
<p>原因是有可能多个处理器同时从各自的缓存中读取变量i，分别进行加一操作，然后分别写入系统内存当中。那么想要保证读改写共享变量的操作是原子的，就必须保证CPU1读改写共享变量的时候，CPU2不能操作缓存了该共享变量内存地址的缓存。</p>
<p>处理器使用总线锁就是来解决这个问题的。所谓总线锁就是使用处理器提供的一个LOCK＃信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住,那么该处理器可以独占使用共享内存。</p>
<h3 id="3-3-">3.3 使用缓存锁保证原子性</h3>
<p>第二个机制是通过缓存锁定保证原子性。在同一时刻我们只需保证对某个内存地址的操作是原子性即可，但总线锁定把CPU和内存之间通信锁住了，这使得锁定期间，其他处理器不能操作其他内存地址的数据，所以总线锁定的开销比较大，最近的处理器在某些场合下使用缓存锁定代替总线锁定来进行优化。</p>
<p>频繁使用的内存会缓存在处理器的L1，L2和L3高速缓存里，那么原子操作就可以直接在处理器内部缓存中进行，并不需要声明总线锁，在奔腾6和最近的处理器中可以使用“缓存锁定”的方式来实现复杂的原子性。所谓“缓存锁定”就是如果缓存在处理器缓存行中内存区域在LOCK操作期间被锁定，当它执行锁操作回写内存时，处理器不在总线上声言LOCK＃信号，而是修改内部的内存地址，并允许它的缓存一致性机制来保证操作的原子性，因为缓存一致性机制会阻止同时修改被两个以上处理器缓存的内存区域数据，当其他处理器回写已被锁定的缓存行的数据时会起缓存行无效，在例1中，当CPU1修改缓存行中的i时使用缓存锁定，那么CPU2就不能同时缓存了i的缓存行。</p>
<p>但是有两种情况下处理器不会使用缓存锁定。第一种情况是：当操作的数据不能被缓存在处理器内部，或操作的数据跨多个缓存行（cache line），则处理器会调用总线锁定。第二种情况是：有些处理器不支持缓存锁定。对于Inter486和奔腾处理器,就算锁定的内存区域在处理器的缓存行中也会调用总线锁定。</p>
<p>以上两个机制我们可以通过Inter处理器提供了很多LOCK前缀的指令来实现。比如位测试和修改指令BTS，BTR，BTC，交换指令XADD，CMPXCHG和其他一些操作数和逻辑指令，比如ADD（加），OR（或）等，被这些指令操作的内存区域就会加锁，导致其他处理器不能同时访问它。</p>
<h2 id="4-java-">4. JAVA如何实现原子操作</h2>
<p>在java中可以通过锁和循环CAS的方式来实现原子操作。</p>
<h3 id="4-1-cas-">4.1 使用循环CAS实现原子操作</h3>
<p>JVM中的CAS操作正是利用了上一节中提到的处理器提供的CMPXCHG指令实现的。自旋CAS实现的基本思路就是循环进行CAS操作直到成功为止，以下代码实现了一个基于CAS线程安全的计数器方法safeCount和一个非线程安全的计数器count。
public class Counter { private AtomicInteger atomicI = new AtomicInteger(0); private int i = 0; public static void main(String[] args) { final Counter cas = new Counter(); List<Thread> ts = new ArrayList<Thread>(600); long start = System.currentTimeMillis(); for (int j = 0; j &lt; 100; j++) { Thread t = new Thread(new Runnable() { @Override public void run() { for (int i = 0; i &lt; 10000; i++) { cas.count(); cas.safeCount(); } } }); ts.add(t); } for (Thread t : ts) { t.start(); } // 等待所有线程执行完成 for (Thread t : ts) { try { t.join(); } catch (InterruptedException e) { e.printStackTrace(); } } System.out.println(cas.i); System.out.println(cas.atomicI.get()); System.out.println(System.currentTimeMillis() - start); } //<em>/</em> /<em> 使用CAS实现线程安全计数器 /</em>/ private void safeCount() { for (;;) { int i = atomicI.get(); boolean suc = atomicI.compareAndSet(i, ++i); if (suc) { break; } } } //<em>/</em> /<em> 非线程安全计数器 /</em>/ private void count() { i++; } }</p>
<p>在java并发包中有一些并发框架也使用了自旋CAS的方式来实现原子操作，比如LinkedTransferQueue类的Xfer方法。CAS虽然很高效的解决原子操作，但是CAS仍然存在三大问题。ABA问题，循环时间长开销大和只能保证一个共享变量的原子操作。</p>
<ol>
<li>ABA问题。因为CAS需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么A－B－A 就会变成1A-2B－3A。
从Java1.5开始JDK的atomic包里提供了一个类AtomicStampedReference来解决ABA问题。这个类的compareAndSet方法作用是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。
public boolean compareAndSet (V expectedReference,//预期引用 V newReference,//更新后的引用 int expectedStamp, //预期标志 int newStamp) //更新后的标志</li>
<li>循环时间长开销大。自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。</li>
<li>只能保证一个共享变量的原子操作。当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁，或者有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如有两个共享变量i＝2,j=a，合并一下ij=2a，然后用CAS来操作ij。从Java1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行CAS操作。</li>
</ol>
<h3 id="4-2-">4.2 使用锁机制实现原子操作</h3>
<p>锁机制保证了只有获得锁的线程能够操作锁定的内存区域。JVM内部实现了很多种锁机制，有偏向锁，轻量级锁和互斥锁，有意思的是除了偏向锁，JVM实现锁的方式都用到的循环CAS，当一个线程想进入同步块的时候使用循环CAS的方式来获取锁，当它退出同步块的时候使用循环CAS释放锁。详细说明可以参见文章Java SE1.6中的Synchronized。</p>
<h2 id="5-">5. 参考资料</h2>
<ol>
<li><a href="http://www.infoq.com/cn/articles/java-se-16-synchronized" target="_blank">Java SE1.6中的Synchronized</a></li>
<li><a href="http://www.intel.com/products/processor/manuals/" target="_blank">Intel 64和IA-32架构软件开发人员手册</a></li>
<li><a href="http://www.infoq.com/cn/articles/ftf-java-volatile" target="_blank">深入分析Volatile的实现原理</a></li>
</ol>
<h2 id="-">作者介绍</h2>
<p><strong>方腾飞</strong>，花名清英，淘宝资深开发工程师，关注并发编程，目前在广告技术部从事无线广告联盟的开发和设计工作。个人博客：<a href="http://ifeve.com/" target="_blank"><a href="http://ifeve.com">http://ifeve.com</a></a> 微博：<a href="http://weibo.com/kirals" target="_blank"><a href="http://weibo.com/kirals">http://weibo.com/kirals</a></a> 欢迎通过我的微博进行技术交流。</p>
<p>感谢<a href="http://www.infoq.com/cn/bycategory.action?authorName=张龙" target="_blank">张龙</a>对本文的审校。</p>
<p>给InfoQ中文站投稿或者参与内容翻译工作，请邮件至<a href="mailto:editors@cn.infoq.com">editors@cn.infoq.com</a>。也欢迎大家通过新浪微博（<a href="http://www.weibo.com/infoqchina" target="_blank">@InfoQ</a>）或者腾讯微博（<a href="http://t.qq.com/infoqchina" target="_blank">@InfoQ</a>）关注我们，并与我们的编辑和其他读者朋友交流。</p>
<ul>
<li><a href="">Sections</a></li>
<li><a href="http://www.infoq.com/cn/architecture-design" target="_blank"><strong>架构 &amp; 设计</strong></a></li>
<li><a href="http://www.infoq.com/cn/development" target="_blank"><strong>语言 &amp; 开发</strong></a></li>
<li><a href="">Topics</a></li>
<li><a href="http://www.infoq.com/cn/cloud-computing" target="_blank">云计算</a></li>
<li><a href="http://www.infoq.com/cn/Multi-threading" target="_blank">多线程</a></li>
<li><a href="http://www.infoq.com/cn/atomic-operation" target="_blank">原子操作</a></li>
<li><a href="http://www.infoq.com/cn/Security" target="_blank">安全</a></li>
<li><a href="http://www.infoq.com/cn/concurrency" target="_blank">并发</a></li>
<li><a href="http://www.infoq.com/cn/soa_platforms" target="_blank">SOA平台</a></li>
<li><a href="http://www.infoq.com/cn/architecture" target="_blank">架构</a></li>
<li><a href="http://www.infoq.com/cn/java" target="_blank">Java</a></li>
<li><a href="http://www.infoq.com/cn/soa" target="_blank">SOA</a></li>
<li><a href="http://www.infoq.com/cn/enterprise-architecture" target="_blank">企业架构</a></li>
<li><a href="http://www.infoq.com/cn/intel" target="_blank">Intel</a></li>
</ul>
<p>相关内容</p>
<h3 id="-concurrentlinkedqueue-http-www-infoq-com-cn-articles-concurrentlinkedqueue-utm_source-infoq-utm_medium-related_content_link-utm_campaign-relatedcontent_articles_clk-"><a href="http://www.infoq.com/cn/articles/ConcurrentLinkedQueue?utm_source=infoq&amp;utm_medium=related_content_link&amp;utm_campaign=relatedContent_articles_clk" target="_blank">聊聊并发（六）——ConcurrentLinkedQueue的实现原理分析</a></h3>
<h3 id="-concurrenthashmap-http-www-infoq-com-cn-articles-concurrenthashmap-utm_source-infoq-utm_medium-related_content_link-utm_campaign-relatedcontent_articles_clk-"><a href="http://www.infoq.com/cn/articles/ConcurrentHashMap?utm_source=infoq&amp;utm_medium=related_content_link&amp;utm_campaign=relatedContent_articles_clk" target="_blank">聊聊并发（四）——深入分析ConcurrentHashMap</a></h3>
<h3 id="-java-http-www-infoq-com-cn-articles-java-threadpool-utm_source-infoq-utm_medium-related_content_link-utm_campaign-relatedcontent_articles_clk-"><a href="http://www.infoq.com/cn/articles/java-threadPool?utm_source=infoq&amp;utm_medium=related_content_link&amp;utm_campaign=relatedContent_articles_clk" target="_blank">聊聊并发（三）——JAVA线程池的分析和使用</a></h3>
<h3 id="-volatile-http-www-infoq-com-cn-articles-ftf-java-volatile-utm_source-infoq-utm_medium-related_content_link-utm_campaign-relatedcontent_articles_clk-"><a href="http://www.infoq.com/cn/articles/ftf-java-volatile?utm_source=infoq&amp;utm_medium=related_content_link&amp;utm_campaign=relatedContent_articles_clk" target="_blank">聊聊并发（一）——深入分析Volatile的实现原理</a></h3>
<h3 id="-intel-javascript-http-www-infoq-com-cn-news-2012-02-javascript-parallel-processing-utm_source-infoq-utm_medium-related_content_link-utm_campaign-relatedcontent_articles_clk-"><a href="http://www.infoq.com/cn/news/2012/02/javascript-parallel-processing?utm_source=infoq&amp;utm_medium=related_content_link&amp;utm_campaign=relatedContent_articles_clk" target="_blank">Intel发布JavaScript扩展以支持并行运算</a></h3>
<h2 id="-">您好，陌生人！</h2>
<p>您需要 <a href="http://www.infoq.com/reginit.action" target="_blank">注册一个InfoQ账号</a> 或者 <a href="">登录</a> 才能进行评论。在您完成注册后还需要进行一些设置。</p>
<h2 id="-infoq-">获得来自InfoQ的更多体验。<a href=""></a></h2>
<p>允许的HTML标签: a,b,br,blockquote,i,li,pre,u,ul,p</p>
<p>当有人回复此评论时请E-mail通知我</p>
<p>社区评论 <a href="">Watch Thread</a></p>
<p><a href=""><strong>您好，有个地方不太明白</strong> by 王 凯 Posted 30/11/2012 05:01</a>
<a href=""><strong>Re: 您好，有个地方不太明白</strong> by 方 腾飞 Posted 30/11/2012 05:14</a></p>
<p><a href=""><strong>Re: 您好，有个地方不太明白</strong> by 王 凯 Posted 30/11/2012 05:21</a>
<a href=""><strong>期待看到happens-before的深入解读</strong> by freish freish Posted 05/12/2012 08:54</a></p>
<p><a href=""><strong>Re: 期待看到happens-before的深入解读</strong> by 方 腾飞 Posted 05/12/2012 11:04</a>
<a href=""><strong>缓存锁定一处不太明白</strong> by 陈 良柱 Posted 18/12/2012 08:20</a></p>
<p><a href=""><strong>Re: 缓存锁定一处不太明白</strong> by 方 腾飞 Posted 27/12/2012 01:00</a>
<a href=""><strong>Re: 缓存锁定一处不太明白</strong> by Zhao Yu Posted 27/12/2012 10:20</a></p>
<p><a href=""><strong>Re: 缓存锁定一处不太明白</strong> by 方 腾飞 Posted 31/12/2012 10:28</a>
<a href=""><strong>Re: 缓存锁定一处不太明白</strong> by 陈 良柱 Posted 31/12/2012 09:29</a></p>
<p><a href=""><strong>缓存锁定</strong> by Zhao Yu Posted 25/12/2012 04:19</a>
<a href=""><strong>Re: 缓存锁定</strong> by 方 腾飞 Posted 27/12/2012 00:59</a></p>
<p><a href=""><strong>关于总线锁的问题</strong> by lee jw Posted 29/12/2012 12:54</a>
<a href=""><strong>Re: 关于总线锁的问题</strong> by 方 腾飞 Posted 31/12/2012 10:30</a>
<a href=""></a></p>
<p><strong>您好，有个地方不太明白</strong> 30/11/2012 05:01 by 王 凯</p>
<p>safeCount()方法有些看不明白，直接让atomicI自增不可以吗，AtomicInteger本身不就是原子方式增加的吗，谢谢。</p>
<ul>
<li><a href="">回复</a></li>
<li><a href="">回到顶部</a></li>
</ul>
<p><a href=""></a></p>
<p><strong>Re: 您好，有个地方不太明白</strong> 30/11/2012 05:14 by 方 腾飞</p>
<p>atomicI.compareAndSet(i, ++i);本身是原子方式的增加，但是有可能会增加失败，所以需要不停atomicI.compareAndSet(i, ++i);</p>
<ul>
<li><a href="">回复</a></li>
<li><a href="">回到顶部</a>
<a href=""></a></li>
</ul>
<p><strong>Re: 您好，有个地方不太明白</strong> 30/11/2012 05:21 by 王 凯</p>
<p>哦，明白了，我看了下AtomicInteger的源码，incrementAndGet方法实现，呵呵</p>
<ul>
<li><a href="">回复</a></li>
<li><a href="">回到顶部</a></li>
</ul>
<p><a href=""></a></p>
<p><strong>期待看到happens-before的深入解读</strong> 05/12/2012 08:54 by freish freish</p>
<p>期待看到happens-before的深入解读</p>
<ul>
<li><a href="">回复</a></li>
<li><a href="">回到顶部</a>
<a href=""></a></li>
</ul>
<p><strong>Re: 期待看到happens-before的深入解读</strong> 05/12/2012 11:04 by 方 腾飞</p>
<p>好的，没问题，在JMM文章里我会深入解读下。</p>
<ul>
<li><a href="">回复</a></li>
<li><a href="">回到顶部</a></li>
</ul>
<p><a href=""></a></p>
<p><strong>缓存锁定一处不太明白</strong> 18/12/2012 08:20 by 陈 良柱</p>
<p>缓存失效是在内存写回之前还是之后？如何使得其他cpu的缓存失效？是说内存到缓存的映射是一共享区域且回写内存包含对其的检查吗？</p>
<ul>
<li><a href="">回复</a></li>
<li><a href="">回到顶部</a>
<a href=""></a></li>
</ul>
<p><strong>缓存锁定</strong> 25/12/2012 04:19 by Zhao Yu</p>
<p>“所谓“缓存锁定”就是如果缓存在处理器缓存行中内存区域在LOCK操作期间被锁定，当它执行锁操作回写内存时，处理器不在总线上声言LOCK＃信号，而是修改内部的内存地址，并允许它的缓存一致性机制来保证操作的原子性”
这句实在不理解，首先什么是Lock操作期间？不是不锁总线了嘛？为什么还Lock？其次，处理器不发Lock信号而是修改内部的内存地址，到底是怎么保障在一个处理器修改缓存并回写期间，其它处理器不会执行同样操作？？？望作者解答一下</p>
<ul>
<li><a href="">回复</a></li>
<li><a href="">回到顶部</a></li>
</ul>
<p><a href=""></a></p>
<p><strong>Re: 缓存锁定</strong> 27/12/2012 00:59 by 方 腾飞</p>
<p>Lock操作期间，是指Lock指令执行期间，不锁总线但是锁缓存。
最后一个问题，这个是由缓存一致性协议保证的，详细参见：<a href="http://www.tektalk.org/2011/07/07/cache一致性与2种基本写策略1/" target="_blank">www.tektalk.org/2011/07/07/cache一致性与2种基本写策略1/</a></p>
<ul>
<li><a href="">回复</a></li>
<li><a href="">回到顶部</a>
<a href=""></a></li>
</ul>
<p><strong>Re: 缓存锁定一处不太明白</strong> 27/12/2012 01:00 by 方 腾飞</p>
<p>参见缓存一致性协议：www.tektalk.org/2011/07/07/cache一致性与2种基本写策略1/</p>
<ul>
<li><a href="">回复</a></li>
<li><a href="">回到顶部</a></li>
</ul>
<p><a href=""></a></p>
<p><strong>Re: 缓存锁定一处不太明白</strong> 27/12/2012 10:20 by Zhao Yu</p>
<p>好的～多谢作者的答复，这块内容关注很久了，多线程并发开发程序，那门语言和平台都是学到最后的最为重要，也是最深的地方，希望您继续发表相关博文～</p>
<ul>
<li><a href="">回复</a></li>
<li><a href="">回到顶部</a>
<a href=""></a></li>
</ul>
<p><strong>关于总线锁的问题</strong> 29/12/2012 12:54 by lee jw</p>
<p>您好，我想请问CPU在什么情况下会发出LOCK/#信号，是在冲突的时候发出，还是在读写内存的时候发出？看您的文章是说CPU1发出LOCK/#信号后，CPU2就不能读写内存，我想请问一下这里面是否有优先级的判断？谢谢</p>
<ul>
<li><a href="">回复</a></li>
<li><a href="">回到顶部</a></li>
</ul>
<p><a href=""></a></p>
<p><strong>Re: 缓存锁定一处不太明白</strong> 31/12/2012 10:28 by 方 腾飞</p>
<p>多谢你的关注，定期会发表新文章的。或者你也可以关注我的小站<a href="http://ifeve.com/" target="_blank">ifeve.com</a> 最近我在做国外并发编程文章的翻译，都是非常值得一看的文章，你也可以参与到我们的翻译当中来，一起促进并发编程的研究和推广 。</p>
<ul>
<li><a href="">回复</a></li>
<li><a href="">回到顶部</a>
<a href=""></a></li>
</ul>
<p><strong>Re: 关于总线锁的问题</strong> 31/12/2012 10:30 by 方 腾飞</p>
<p>指令触发的，比如使用lock前缀的指令。</p>
<ul>
<li><a href="">回复</a></li>
<li><a href="">回到顶部</a></li>
</ul>
<p><a href=""></a></p>
<p><strong>Re: 缓存锁定一处不太明白</strong> 31/12/2012 09:29 by 陈 良柱</p>
<p>你给的文章链接没有回答我的问题，不过write-invalidate和write-update两词很有用处。
找到一篇个人认为写得较为清楚的综述文章，在此分享：<a href="http://www.docin.com/p-92508695.html。" target="_blank">www.docin.com/p-92508695.html。</a></p>
<ul>
<li><a href="">回复</a></li>
<li><a href="">回到顶部</a></li>
</ul>
<p><a href="">关闭</a></p>
<h3 id="-by"><em>**</em>by</h3>
<p>发布于</p>
<ul>
<li><a href="">查看</a></li>
<li><a href="">回复</a></li>
<li><a href="">回到顶部</a>
<a href="">关闭</a> 主题  您的回复 <a href="">引用原消息</a></li>
</ul>
<p>允许的HTML标签: a,b,br,blockquote,i,li,pre,u,ul,p
当有人回复此评论时请E-mail通知我</p>
<p><a href="">关闭</a> 主题  您的回复</p>
<p>允许的HTML标签: a,b,br,blockquote,i,li,pre,u,ul,p
当有人回复此评论时请E-mail通知我
<a href="">关闭</a></p>
<ul>
<li>热点内容</li>
<li><a href="">本周</a></li>
<li><a href="">本月</a></li>
<li><a href="">近6个月</a><h3 id="-32-http-www-infoq-com-cn-news-2012-08-32-most-important-algorithms-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2012/08/32-most-important-algorithms?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">计算机科学中最重要的32个算法</a></h3>
</li>
</ul>
<h3 id="-thoughtworks-2013-5-http-www-infoq-com-cn-articles-thoughtworks-technology-radar-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/thoughtWorks-technology-radar?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">ThoughtWorks技术雷达（2013年5月）</a></h3>
<h3 id="-1-5-http-www-infoq-com-cn-articles-iqiyi-cloud-push-practices-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/iqiyi-cloud-push-practices?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">让1.5亿移动端用户第一时间获取消息</a></h3>
<h3 id="-thoughtworks-ceo-http-www-infoq-com-cn-news-2013-06-tw-guoxiao-on-talents-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2013/06/tw-guoxiao-on-talents?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">ThoughtWorks全球CEO郭晓谈软件人才的招聘与培养</a></h3>
<h3 id="-http-www-infoq-com-cn-news-2013-06-10-sins-for-scalability-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2013/06/10-sins-for-scalability?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">影响可扩展性的十宗罪</a></h3>
<h3 id="-6-http-www-infoq-com-cn-minibooks-architect-jun-10-2013-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/architect-jun-10-2013?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">架构师（6月刊）</a></h3>
<h3 id="-http-www-infoq-com-cn-articles-function-switch-realize-better-continuous-implementations-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/function-switch-realize-better-continuous-implementations?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">使用功能开关更好地实现持续部署</a></h3>
<h3 id="-eclipse-github-http-www-infoq-com-cn-news-2013-06-eclipse-github-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2013/06/eclipse-github?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">Eclipse迁移到GitHub</a></h3>
<h3 id="-newegg-com-http-www-infoq-com-cn-presentations-newegg-big-data-practice-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/presentations/newegg-big-data-practice?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">Newegg.com大数据实践</a></h3>
<h3 id="-http-www-infoq-com-cn-minibooks-software-sys-architect-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/software-sys-architect?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">软件系统架构：使用视点和视角与利益相关者合作</a></h3>
<h3 id="-32-http-www-infoq-com-cn-news-2012-08-32-most-important-algorithms-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2012/08/32-most-important-algorithms?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">计算机科学中最重要的32个算法</a></h3>
<h3 id="-6-http-www-infoq-com-cn-minibooks-architect-jun-10-2013-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/architect-jun-10-2013?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">架构师（6月刊）</a></h3>
<h3 id="-rest-http-www-infoq-com-cn-news-2013-06-rest-drawbacks-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2013/06/rest-drawbacks?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">REST的缺点是什么？</a></h3>
<h3 id="-google-web-ui-polymer-http-www-infoq-com-cn-news-2013-06-webcomponents-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2013/06/webcomponents?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">Google 发布新一代Web UI库Polymer</a></h3>
<h3 id="-http-www-infoq-com-cn-news-2013-06-dianping-xinnet-hacked-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2013/06/dianping-xinnet-hacked?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">大众点评网域名劫持事件概述</a></h3>
<h3 id="-node-js-grunt-js-http-www-infoq-com-cn-articles-gruntjs-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/GruntJs?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">基于Node.js的自动化构建工具Grunt.js</a></h3>
<h3 id="-node-js-node-js-http-www-infoq-com-cn-articles-what-is-nodejs-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/what-is-nodejs?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">深入浅出Node.js（一）：什么是Node.js</a></h3>
<h3 id="-http-www-infoq-com-cn-minibooks-i-m-wrights-hard-code-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/i-m-wrights-hard-code?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">代码之殇·第二版</a></h3>
<h3 id="-http-www-infoq-com-cn-minibooks-software-sys-architect-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/software-sys-architect?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">软件系统架构：使用视点和视角与利益相关者合作</a></h3>
<h3 id="-18-java-http-www-infoq-com-cn-news-2013-06-zhuhong-on-java-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2013/06/zhuhong-on-java?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">大家谈18岁的Java——朱鸿：开过跑车后再去开大巴车总是有点不爽的</a></h3>
<h3 id="-32-http-www-infoq-com-cn-news-2012-08-32-most-important-algorithms-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2012/08/32-most-important-algorithms?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">计算机科学中最重要的32个算法</a></h3>
<h3 id="-java-http-www-infoq-com-cn-articles-java-memory-model-1-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/java-memory-model-1?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">深入理解Java内存模型（一）——基础</a></h3>
<h3 id="-node-js-node-js-http-www-infoq-com-cn-articles-what-is-nodejs-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/what-is-nodejs?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">深入浅出Node.js（一）：什么是Node.js</a></h3>
<h3 id="-node-js-node-js-npm-http-www-infoq-com-cn-articles-nodejs-npm-install-config-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/nodejs-npm-install-config?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">深入浅出Node.js（二）：Node.js&amp;NPM的安装与配置</a></h3>
<h3 id="-3-http-www-infoq-com-cn-minibooks-architect-mar-10-2013-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/architect-mar-10-2013?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">架构师（3月刊）</a></h3>
<h3 id="-1-http-www-infoq-com-cn-minibooks-architect-jan-10-2013-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/architect-jan-10-2013?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">架构师（1月刊）</a></h3>
<h3 id="-4-http-www-infoq-com-cn-minibooks-architect-apr-10-2013-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/architect-apr-10-2013?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">架构师（4月刊）</a></h3>
<h3 id="-java-http-www-infoq-com-cn-articles-java-threadpool-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/java-threadPool?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">聊聊并发（三）——JAVA线程池的分析和使用</a></h3>
<h3 id="-2-http-www-infoq-com-cn-minibooks-architect-feb-10-2013-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/architect-feb-10-2013?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">架构师（2月刊）</a></h3>
<h3 id="-12306-github-http-www-infoq-com-cn-news-2013-01-12306-plugin-ddos-github-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2013/01/12306-plugin-ddos-github?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">12306订票助手插件拖垮GitHub事件原因始末</a></h3>
<h2 id="-">深度内容</h2>
<ul>
<li><a href="">全部</a></li>
<li><a href="">文章</a></li>
<li><a href="">演讲</a></li>
<li><a href="">访谈</a></li>
<li><a href="">迷你书</a><h2 id="-juergen-fesslmeier-javascript-http-www-infoq-com-cn-interviews-end-to-end-javascript-juergen-fesslmeier-javascript-"><a href="http://www.infoq.com/cn/interviews/end-to-end-javascript" title="Juergen Fesslmeier谈端到端的JavaScript开发" target="_blank">Juergen Fesslmeier谈端到端的JavaScript开发</a></h2>
</li>
</ul>
<p><a href="http://www.infoq.com/cn/author/Juergen-Fesslmeier" title="Juergen Fesslmeier" target="_blank">Juergen Fesslmeier</a> 七月 02, 2013</p>
<p><a href="http://www.infoq.com/cn/interviews/end-to-end-javascript" title="Juergen Fesslmeier谈端到端的JavaScript开发" target="_blank"><img src="" alt=""></a></p>
<h2 id="-http-www-infoq-com-cn-articles-design-pattern-automation-"><a href="http://www.infoq.com/cn/articles/Design-Pattern-Automation" title="设计模式自动化" target="_blank">设计模式自动化</a></h2>
<p><a href="http://www.infoq.com/cn/author/Gael-Fraiteur-and-Yan-Cui" title="Gael Fraiteur and Yan Cui" target="_blank">Gael Fraiteur and Yan Cui</a> 七月 01, 2013</p>
<p><a href="http://www.infoq.com/cn/articles/Design-Pattern-Automation" title="设计模式自动化" target="_blank"><img src="" alt=""></a></p>
<h2 id="-http-www-infoq-com-cn-articles-designing-a-world-at-your-fingertips-mobile-user-interfaces-"><a href="http://www.infoq.com/cn/articles/designing-a-world-at-your-fingertips-mobile-user-interfaces" title="设计指尖上的世界：移动用户界面一瞥" target="_blank">设计指尖上的世界：移动用户界面一瞥</a></h2>
<p><a href="http://www.infoq.com/cn/author/Forrest-Shull" title="Forrest Shull" target="_blank">Forrest Shull</a> 六月 28, 2013</p>
<p><a href="http://www.infoq.com/cn/articles/designing-a-world-at-your-fingertips-mobile-user-interfaces" title="设计指尖上的世界：移动用户界面一瞥" target="_blank"><img src="" alt=""></a></p>
<h2 id="-alm-http-www-infoq-com-cn-articles-integrated-alm-alm-"><a href="http://www.infoq.com/cn/articles/Integrated-ALM" title="成功的根本—集成的ALM工具" target="_blank">成功的根本—集成的ALM工具</a></h2>
<p><a href="http://www.infoq.com/cn/author/Dave-West" title="Dave West" target="_blank">Dave West</a> 六月 28, 2013</p>
<p><a href="http://www.infoq.com/cn/articles/Integrated-ALM" title="成功的根本—集成的ALM工具" target="_blank"><img src="" alt=""></a></p>
<h2 id="-http-www-infoq-com-cn-articles-atdd-by-example-book-"><a href="http://www.infoq.com/cn/articles/atdd-by-example-book" title="书评：验收测试驱动开发实践指南" target="_blank">书评：验收测试驱动开发实践指南</a></h2>
<p><a href="http://www.infoq.com/cn/author/Manuel-Pais" title="Manuel Pais" target="_blank">Manuel Pais</a> 六月 26, 2013</p>
<p><a href="http://www.infoq.com/cn/articles/atdd-by-example-book" title="书评：验收测试驱动开发实践指南" target="_blank"><img src="" alt=""></a></p>
<h2 id="-web-http-www-infoq-com-cn-presentations-across-device-web-web-"><a href="http://www.infoq.com/cn/presentations/across-device-web" title="跨终端的web" target="_blank">跨终端的web</a></h2>
<p><a href="http://www.infoq.com/cn/author/%E8%88%92%E6%96%87%E4%BA%AE" title="舒文亮" target="_blank">舒文亮</a> 六月 26, 2013</p>
<p><a href="http://www.infoq.com/cn/presentations/across-device-web" title="跨终端的web" target="_blank"><img src="" alt=""></a></p>
<ul>
<li><a href="">更早的 &gt;</a></li>
</ul>
<p>语言 &amp; 开发</p>
<p><a href="http://www.infoq.com/cn/interviews/end-to-end-javascript" title="Juergen Fesslmeier谈端到端的JavaScript开发" target="_blank">Juergen Fesslmeier谈端到端的JavaScript开发</a></p>
<p><a href="http://www.infoq.com/cn/news/2013/07/mobilecloud-tfs" title="MobileCloud for TFS支持测试Windows Phone,Android,iOS及BlackBerry应用" target="_blank">MobileCloud for TFS支持测试Windows Phone,Android,iOS及BlackBerry应用</a></p>
<p><a href="http://www.infoq.com/cn/news/2013/07/baidu-salon39-summary" title="百度技术沙龙第39期回顾：前端快速开发实践（含资料下载）" target="_blank">百度技术沙龙第39期回顾：前端快速开发实践（含资料下载）</a></p>
<p>架构 &amp; 设计</p>
<p><a href="http://www.infoq.com/cn/news/2013/07/Native-Performance" title="内存与本机代码的性能" target="_blank">内存与本机代码的性能</a></p>
<p><a href="http://www.infoq.com/cn/articles/Design-Pattern-Automation" title="设计模式自动化" target="_blank">设计模式自动化</a></p>
<p><a href="http://www.infoq.com/cn/news/2013/07/WinRT-Devices" title="连接设备编程" target="_blank">连接设备编程</a>
过程 &amp; 实践</p>
<p><a href="http://www.infoq.com/cn/articles/Integrated-ALM" title="成功的根本—集成的ALM工具" target="_blank">成功的根本—集成的ALM工具</a></p>
<p><a href="http://www.infoq.com/cn/news/2013/06/tw-guoxiao-on-talents" title="ThoughtWorks全球CEO郭晓谈软件人才的招聘与培养" target="_blank">ThoughtWorks全球CEO郭晓谈软件人才的招聘与培养</a></p>
<p><a href="http://www.infoq.com/cn/articles/atdd-by-example-book" title="书评：验收测试驱动开发实践指南" target="_blank">书评：验收测试驱动开发实践指南</a></p>
<p>运维 &amp; 基础架构</p>
<p><a href="http://www.infoq.com/cn/news/2013/06/devops-in-traditional-enterprise" title="在传统企业中引入DevOps" target="_blank">在传统企业中引入DevOps</a></p>
<p><a href="http://www.infoq.com/cn/news/2013/06/dod-ams-day1-s-is-for-security" title="安全性——“DevOpS”中的S" target="_blank">安全性——“DevOpS”中的S</a></p>
<p><a href="http://www.infoq.com/cn/articles/atdd-by-example-book" title="书评：验收测试驱动开发实践指南" target="_blank">书评：验收测试驱动开发实践指南</a>
企业架构</p>
<p><a href="http://www.infoq.com/cn/articles/designing-a-world-at-your-fingertips-mobile-user-interfaces" title="设计指尖上的世界：移动用户界面一瞥" target="_blank">设计指尖上的世界：移动用户界面一瞥</a></p>
<p><a href="http://www.infoq.com/cn/news/2013/06/stratos-2" title="Stratos 2.0已发布，支持所有运行时环境和30个IaaS" target="_blank">Stratos 2.0已发布，支持所有运行时环境和30个IaaS</a></p>
<p><a href="http://www.infoq.com/cn/articles/iqiyi-cloud-push-practices" title="让1.5亿移动端用户第一时间获取消息" target="_blank">让1.5亿移动端用户第一时间获取消息</a>
<a href="">Close</a> E-mail  密码</p>
<p><a href="http://www.infoq.com/cn/social/googleLogin.action?fl=login" title="使用Google账号登录" target="_blank">使用Google账号登录</a> <a href="http://www.infoq.com/cn/social/liveLogin.action?fl=login" title="使用Microsoft账号登录" target="_blank">使用Microsoft账号登录</a>
<a href="">忘记密码？</a>
 InfoQ账号使用的E-mail 发送邮件</p>
<p><a href="">重新登录</a>
重新发送激活信息 重新发送</p>
<p><a href="">重新登录</a>
<a href="http://www.infoq.com/cn/reginit.action" target="_blank">没有用户名？</a></p>
<p><a href="http://www.infoq.com/cn/reginit.action" target="_blank">点击注册</a></p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/Java_多线程/">Java_多线程</a></li><li><a href="/categories/Java&J2EE/Java_多线程/并发/">并发</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/Java_多线程/" class="label label-success">Java_多线程</a><a href="/tags/并发/" class="label label-info">并发</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:41"datetime="2014-03-07 09:54:41"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-Java_多线程-并发--聊聊并发（五）——原子操作的实现原理/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-Java_多线程-并发--聊聊并发（五）——原子操作的实现原理" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_多线程--多线程讲解/">多线程讲解</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:41.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_多线程--多线程讲解/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-">多线程讲解</h1>
<p>多线程是java应用程序的一个特点，掌握java的多线程也是作为一java程序员必备的知识。多线程指的是在单个程序中可以同时运行多个同的线程执行不同的任务.线程是程序内的顺序控制流，只能使用分配给序的资源和环境。还记得刚开始学习的时候总是和进程分不清，总是对这两个名词所迷惑。</p>
<p>下面就首先对这两个名词区分来作为本篇博客的开始：</p>
<p><strong>    一、线程与进程的区别</strong></p>
<p>多个进程的内部数据和状态都是完全独立的,而多线程是共享一块内存空间和一组系统资源,有可能互相影响. •线程本身的数据通常只有寄存器数据，以及一个程序执行时使用的堆栈，所以线程的切换比进程切换的负担要小。</p>
<p> 多线程编程的目的，就是&quot;最大限度地利用CPU资源&quot;，当某一线程的处理不需要占用CPU而只和I/O等资源打交道时，让需要占用CPU资源的其它线程有机会获得CPU资源。从根本上说，这就是多线程编程的最终目的。</p>
<p>二、了解一下java在多线程中的基础知识</p>
<p>1.Java中如果我们自己没有产生线程，那么系统就会给我们产生一个线程（主线程，main方法就在主线程上运行），我们的程序都是由线程来执行的。</p>
<ol>
<li>进程：执行中的程序（程序是静态的概念，进程是动态的概念）。 </li>
</ol>
<ol>
<li><p>线程的实现有两种方式，<strong>第一种方式是继承Thread类，然后重写run方法；第二种是实现Runnable接口，然后实现其run方法。 </strong></p>
</li>
<li><p>将我们希望线程执行的代码放到run方法中，然后通过start方法来启动线程，<strong>start方法首先为线程的执行准备好系统资源，然后再去调用run方法。</strong>当某个类继承了Thread类之后，该类就叫做一个线程类。 </p>
</li>
<li><p>一个进程至少要包含一个线程。 </p>
</li>
<li><p>对于单核CPU来说，某一时刻只能有一个线程在执行（微观串行），从宏观角度来看，多个线程在同时执行（宏观并行）。 </p>
</li>
<li><p>对于双核或双核以上的CPU来说，可以真正做到微观并行。</p>
</li>
</ol>
<p>三、Thread源码研究： </p>
<p>1) Thread类也实现了Runnable接口，因此实现了Runnable接口中的run方法； </p>
<p>2) 当生成一个线程对象时，如果没有为其设定名字，那么线程对象的名字将使用如下形式：Thread-number,该number将是自动增加的，并被所有的Thread对象所共享（因为它是static的成员变量）。 </p>
<p>3) 当使用第一种方式来生成线程对象时，我们需要重写run方法，因为Thread类的run方法此时什么事情也不做。</p>
<p>4）当使用第二种方式生成线程对象时，我们需要实现Runnable接口的run方法，然后使用new Thread（new MyThread（））（假如MyThread已经实现了Runnable接口）来生成线程对象，这时的线程对象的run方法或调就会MyThread类的run方法，这样我们自己编写的run方法就执行了。</p>
<p>说明： </p>
<p>Public void run(){</p>
<p>If(target!=null){</p>
<p>Target.run();</p>
<p>}}</p>
<p>当使用继承Thread生成线程对象时，target为空，什么也不执行，当使用第二种方式生成时，执行target.run（），target为runnable的实例对象，即为执行重写后的方法</p>
<p>总结：两种生成线程对象的区别：</p>
<p>1.两种方法均需执行线程的start方法为线程分配必须的系统资源、调度线程运行并执行线程的run方法。 </p>
<p>2.在具体应用中，采用哪种方法来构造线程体要视情况而定。通常，当一个线程已继承了另一个类时，就应该用第二种方法来构造，即实现Runnable接口。 </p>
<p><strong>四：线程的生命周期：</strong></p>
<p><img src="" alt=""></p>
<p>由上图可以看出，一个线程由出生到死亡分为五个阶段：</p>
<p><strong>1）.创建状态 </strong></p>
<p>•当用new操作符创建一个新的线程对象时，该线程处于创建状态。 </p>
<p>•处于创建状态的线程只是一个空的线程对象，系统不为它分配资源 </p>
<p><strong>2）. 可运行状态 </strong></p>
<p>•执行线程的start()方法将为线程分配必须的系统资源，安排其运行，并调用线程体—run()方法，这样就使得该线程处于可运行( Runnable )状态。 </p>
<p>•这一状态并不是运行中状态（Running )，因为线程也许实际上并未真正运行。 </p>
<p><strong>3）.不可运行状态 </strong></p>
<p>.当发生下列事件时，处于运行状态的线程会转入到不可运行状态。 </p>
<p>调用了sleep（）方法； </p>
<p>•线程调用wait方法等待特定条件的满足 </p>
<p>•线程输入/输出阻塞 </p>
<p><strong>4）返回可运行状态： </strong></p>
<p>•处于睡眠状态的线程在指定的时间过去后 </p>
<p>•如果线程在等待某一条件，另一个对象必须通过notify()或notifyAll()方法通知等待线程条件的改变 </p>
<p>•如果线程是因为输入/输出阻塞，等待输入/输出完成 </p>
<p><strong>5）. 消亡状态 </strong></p>
<p>当线程的run方法执行结束后，该线程自然消亡。 </p>
<p>注意：</p>
<p>1.停止线程的方式：不能使用Thread类的stop方法来终止线程的执行。一般要设定一个变量，在run方法中是一个循环，循环每次检查该变量，如果满足条件则继续执行，否则跳出循环，线程结束。 </p>
<p>2.不能依靠线程的优先级来决定线程的执行顺序。 </p>
<p><strong>五：多线程并发</strong></p>
<p>多线程并发是线程同步中比较常见的现象，java多线程为了避免多线程并发解决多线程共享数据同步问题提供了<strong>synchronized关键字</strong></p>
<p>synchronized关键字：当synchronized关键字修饰一个方法的时候，该方法叫做同步方法。 </p>
<p>1.Java中的每个对象都有一个锁（lock）或者叫做监视器（monitor），当访问某个对象的synchronized方法时，表示将该对象上锁，此时其他任何线程都无法再去访问该synchronized方法了，直到之前的那个线程执行方法完毕后（或者是抛出了异常），那么将该对象的锁释放掉，其他线程才有可能再去访问该synchronized方法。 </p>
<ol>
<li>如果一个对象有多个synchronized方法，某一时刻某个线程已经进入到了某个synchronized方法，那么在该方法没有执行完毕前，其他线程是无法访问该对象的任何synchronized方法的。 </li>
</ol>
<p>3.如果某个synchronized方法是static的，那么当线程访问该方法时，它锁的并不是synchronized方法所在的对象，而是synchronized方法所在的对象所对应的Class对象，因为Java中无论一个类有多少个对象，这些对象会对应唯一一个Class对象，因此当线程分别访问同一个类的两个对象的两个static，synchronized方法时，他们的执行顺序也是顺序的，也就是说一个线程先去执行方法，执行完毕后另一个线程才开始执行。 </p>
<ol>
<li>synchronized块，写法： </li>
</ol>
<p>synchronized(object) </p>
<p>{ </p>
<p>} </p>
<p>表示线程在执行的时候会对object对象上锁。 </p>
<p>5.synchronized方法是一种粗粒度的并发控制，某一时刻，只能有一个线程执行该synchronized方法;synchronized块则是一种细粒度的并发控制，只会将块中的代码同步，位于方法内、synchronized块之外的代码是可以被多个线程同时访问到的。 </p>
<p>同步的线程状态图：</p>
<p><img src="" alt=""></p>
<p><strong>六：wait与notify</strong></p>
<p>1.wait与notify方法都是定义在Object类中，而且是final的，因此会被所有的Java类所继承并且无法重写。这两个方法要求在调用时线程应该已经获得了对象的锁，因此对这两个方法的调用需要放在synchronized方法或块当中。当线程执行了wait方法时，它会释放掉对象的锁。 </p>
<ol>
<li>另一个会导致线程暂停的方法就是Thread类的sleep方法，它会导致线程睡眠指定的毫秒数，但线程在睡眠的过程中是不会释放掉对象的锁的。 </li>
</ol>
<p>3.notify():唤醒在此对象监视器上等待的单个线程。如果所有线程都在此对象上等待，则会选择唤醒其中一个线程。选择是任意性的，并在对实现做出决定时发生。线程通过调用其中一个 wait 方法，在对象的监视器上等待。 </p>
<p>直到当前线程放弃此对象上的锁定，才能继续执行被唤醒的线程。被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞争；例如，唤醒的线程在作为锁定此对象的下一个线程方面没有可靠的特权或劣势。</p>
<p>此方法只应由作为此对象监视器的所有者的线程来调用。通过以下三种方法之一，线程可以成为此对象监视器的所有者：</p>
<p>o 通过执行此对象的同步实例方法。</p>
<p>o 通过执行在此对象上进行同步的 synchronized 语句的正文。</p>
<p>o 对于 Class 类型的对象，可以通过执行该类的同步静态方法。</p>
<p>一次只能有一个线程拥有对象的监视器。</p>
<p><img src="" alt=""></p>
<p> <strong>关于成员变量与局部变量</strong>：如果一个变量是成员变量，那么多个线程对同一个对象的成员变量进行操作时，他们对该成员变量是彼此影响的（也就是说一个线程对成员变量的改变会影响到另一个线程）。  如果一个变量是局部变量，那么每个线程都会有一个该局部变量的拷贝，一个线程对该局部变量的改变不会影响到其他的线程。</p>
<p><strong>七：死锁的问题： </strong></p>
<p>定义：线程1锁住了对象A的监视器，等待对象B的监视器，线程2锁住了对象B的监视器，等待对象A的监视器，就造成了死锁。</p>
<pre><code> 导致死锁的根源在于不适当地运用“synchronized”关键词来管理线程对特定对象的访问。“synchronized”关键词的作用是，确保在某个时刻只有一个线程被允许执行特定的代码块，因此，被允许执行的线程首先必须拥有对变量或对象的排他性访问权。当线程访问对象时，线程会给对象加锁
</code></pre><p>Java中每个对象都有一把锁与之对应。但Java不提供单独的lock和unlock操作。下面笔者分析死锁的两个过程“上锁”和“锁死” 。</p>
<p>(1) 上锁
     许多线程在执行中必须考虑与其他线程之间共享数据或协调执行状态，就需要同步机制。因此大多数应用程序要求线程互相通信来同步它们的动作，在 Java 程序中最简单实现同步的方法就是上锁。在 Java 编程中，所有的对象都有锁。线程可以使用 synchronized 关键字来获得锁。在任一时刻对于给定的类的实例，方法或同步的代码块只能被一个线程执行。这是因为代码在执行之前要求获得对象的锁。</p>
<pre><code>为了防止同时访问共享资源，线程在使用资源的前后可以给该资源上锁和开锁。给共享变量上锁就使得 Java 线程能够快速方便地通信和同步。某个线程若给一个对象上了锁，就可以知道没有其他线程能够访问该对象。即使在抢占式模型中，其他线程也不能够访问此对象，直到上锁的线程被唤醒、完成工作并开锁。那些试图访问一个上锁对象的线程通常会进入睡眠状态，直到上锁的线程开锁。一旦锁被打开，这些睡眠进程就会被唤醒并移到准备就绪队列中。
</code></pre><p>(2)锁死
     如果程序中有几个竞争资源的并发线程,那么保证均衡是很重要的。系统均衡是指每个线程在执行过程中都能充分访问有限的资源，系统中没有饿死和死锁的线程。当多个并发的线程分别试图同时占有两个锁时，会出现加锁冲突的情形。如果一个线程占有了另一个线程必需的锁，互相等待时被阻塞就有可能出现死锁。</p>
<pre><code>在编写多线程代码时，笔者认为死锁是最难处理的问题之一。因为死锁可能在最意想不到的地方发生，所以查找和修正它既费时又费力。例如，常见的例子如下面这段程序。[print](http://write.blog.csdn.net/postedit#)[?](http://write.blog.csdn.net/postedit#)
</code></pre><p>1 public int sumArrays(int[] a1, int[] a2){  </p>
<p>2   int value = 0;  </p>
<p>3   int size = a1.length;  </p>
<p>4   if (size == a2.length) {  </p>
<p>5      synchronized(a1) { //1        </p>
<p>6        synchronized(a2) { //2          </p>
<p>7          for (int i=0; i&lt;size; i++)  </p>
<p>8             value += a1[i] + a2[i];  </p>
<p>9        }    </p>
<p>10      }    </p>
<p>11   } return value;  </p>
<p>12 }   </p>
<p>这段代码在求和操作中访问两个数组对象之前锁定了这两个数组对象。它形式简短，编写也适合所要执行的任务；但不幸的是，它有一个潜在的问题。这个问题就是它埋下了死锁的种子。</p>
<p><strong>ThreadLocal类（这个类本人没用过，暂时不太懂）</strong></p>
<p>首先，ThreadLocal 不是用来解决共享对象的多线程访问问题的，一般情况下，通过ThreadLocal.set() 到线程中的对象是该线程自己使用的对象，其他线程是不需要访问的，也访问不到的。各个线程中访问的是不同的对象。
另外，说ThreadLocal使得各线程能够保持各自独立的一个对象，并不是通过ThreadLocal.set()来实现的，而是通过每个线程中的new 对象 的操作来创建的对象，每个线程创建一个，不是什么对象的拷贝或副本。通过ThreadLocal.set()将这个新创建的对象的引用保存到各线程的自己的一个map中，每个线程都有这样一个map，执行ThreadLocal.get()时，各线程从自己的map中取出放进去的对象，因此取出来的是各自自己线程中的对象，ThreadLocal实例是作为map的key来使用的。
如果ThreadLocal.set()进去的东西本来就是多个线程共享的同一个对象，那么多个线程的ThreadLocal.get()取得的还是这个共享对象本身，还是有并发访问问题。</p>
<p><strong> 本文来自：曹胜欢博客专栏。转载请注明出处：<a href="http://blog.csdn.net/csh624366188" target="_blank"><a href="http://blog.csdn.net/csh624366188">http://blog.csdn.net/csh624366188</a></a></strong></p>
<p>来源： <a href="[http://blog.csdn.net/csh624366188/article/details/7318245](http://blog.csdn.net/csh624366188/article/details/7318245)">[http://blog.csdn.net/csh624366188/article/details/7318245](http://blog.csdn.net/csh624366188/article/details/7318245)</a> </p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/Java_多线程/">Java_多线程</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/Java_多线程/" class="label label-success">Java_多线程</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:41"datetime="2014-03-07 09:54:41"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-Java_多线程--多线程讲解/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-Java_多线程--多线程讲解" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--JVM调优总结（二）-一些概念-高级语言虚拟机/">JVM调优总结（二）</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:41.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--JVM调优总结（二）-一些概念-高级语言虚拟机/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="jvm-">JVM调优总结（二）-一些概念 - 高级语言虚拟机</h1>
<p><a href="http://hllvm.group.iteye.com/login" title="登录" target="_blank">您还未登录 !</a> <a href="http://hllvm.group.iteye.com/login" target="_blank">登录</a> <a href="http://hllvm.group.iteye.com/signup" target="_blank">注册</a></p>
<p><a href="http://www.iteye.com/" target="_blank"><img src="&quot;ITeye-最棒的软件开发交流社区&quot;" alt="ITeye3.0"></a></p>
<p><a href=""></a></p>
<p><a href="http://www.iteye.com/groups" target="_blank">群组首页</a> → <a href="http://hllvm.group.iteye.com/groups/category/language" target="_blank">编程语言</a> → <a href="http://hllvm.group.iteye.com/" target="_blank">高级语言虚拟机</a> → <a href="http://hllvm.group.iteye.com/group/wiki" target="_blank">知识库</a> → <a href="http://hllvm.group.iteye.com/group/wiki?category_id=301" target="_blank">JVM调优</a> → <a href="">JVM调优总结（二）-一些概念</a>
原创作者: <a href="http://www.javaeye.com/topic/519471" target="_blank">和你在一起</a>   阅读:4764次   评论:6条   更新时间:2011-05-26    </p>
<h2 id="java-">Java对象的大小</h2>
<pre><code>基本数据的类型的大小是固定的，这里就不多说了。对于非基本类型的Java对象，其大小就值得商榷。

在Java中，**一个空Object对象的大小是8byte**，这个大小只是保存堆中一个没有任何属性的对象的大小。看下面语句：
</code></pre><p>Object ob = new Object();</p>
<pre><code>这样在程序中完成了一个Java对象的生命，但是它所占的空间为：**4byte+8byte**。4byte是上面部分所说的Java栈中保存引用的所需要的空间。而那8byte则是Java堆中对象的信息。因为所有的Java非基本类型的对象都需要默认继承Object对象，因此不论什么样的Java对象，其大小都必须是大于8byte。
</code></pre><p>   有了Object对象的大小，我们就可以计算其他对象的大小了。
Class NewObject {</p>
<pre><code>int count;

boolean flag;

Object ob;
</code></pre><p>}</p>
<pre><code>其大小为：空对象大小(8byte)+int大小(4byte)+Boolean大小(1byte)+空Object引用的大小(4byte)=17byte。但是因为Java在对对象内存分配时都是以8的整数倍来分，因此大于17byte的最接近8的整数倍的是24，因此此对象的大小为24byte。

这里需要注意一下**基本类型的包装类型的大小**。因为这种包装类型已经成为对象了，因此需要把他们作为对象来看待。包装类型的大小至少是12byte（声明一个空Object至少需要的空间），而且12byte没有包含任何有效信息，同时，因为Java对象大小是8的整数倍，因此**一个基本类型包装类的大小至少是16byte**。这个内存占用是很恐怖的，它是使用基本类型的N倍（N&gt;2），有些类型的内存占用更是夸张（随便想下就知道了）。因此，可能的话应尽量少使用包装类。在JDK5.0以后，因为加入了自动类型装换，因此，Java虚拟机会在存储方面进行相应的优化。
</code></pre><h2 id="-">引用类型</h2>
<pre><code>对象引用类型分为**强引用、软引用、弱引用和虚引用**。
</code></pre><p><strong>强引用:</strong>就是我们一般声明对象是时虚拟机生成的引用，强引用环境下，垃圾回收时需要严格判断当前对象是否被强引用，如果被强引用，则不会被垃圾回收</p>
<p><strong>软引用:</strong>软引用一般被做为缓存来使用。与强引用的区别是，软引用在垃圾回收时，虚拟机会根据当前系统的剩余内存来决定是否对软引用进行回收。如果剩余内存比较紧张，则虚拟机会回收软引用所引用的空间；如果剩余内存相对富裕，则不会进行回收。换句话说，虚拟机在发生OutOfMemory时，肯定是没有软引用存在的。</p>
<p><strong>弱引用:</strong>弱引用与软引用类似，都是作为缓存来使用。但与软引用不同，弱引用在进行垃圾回收时，是一定会被回收掉的，因此其生命周期只存在于一个垃圾回收周期内。</p>
<pre><code>强引用不用说，我们系统一般在使用时都是用的强引用。而“软引用”和“弱引用”比较少见。他们一般被作为缓存使用，而且一般是在内存大小比较受限的情况下做为缓存。因为如果内存足够大的话，可以直接使用强引用作为缓存即可，同时可控性更高。因而，他们常见的是被使用在桌面应用系统的缓存。
</code></pre><p><a href="http://hllvm.group.iteye.com/group/wiki/2858-JVM" title="JVM调优总结（一）-- 一些概念" target="_blank">JVM调优总结（一）-- 一些概念</a> | <a href="http://hllvm.group.iteye.com/group/wiki/2861-JVM" title="JVM调优总结（三）-基本垃圾回收算法" target="_blank">JVM调优总结（三）-基本垃圾回收算法</a></p>
<p>评论 共 6 条 请<a href="http://hllvm.group.iteye.com/login" target="_blank">登录</a>后发表评论 <a href=""></a></p>
<h3 id="6-xianneng-lin-http-xianneng-lin-iteye-com-xianneng-lin-2012-11-21-15-47">6 楼 <a href="http://xianneng-lin.iteye.com/" title="xianneng.lin" target="_blank">xianneng.lin</a> 2012-11-21 15:47</h3>
<p>虚引用呢？</p>
<h3 id="5-xiaodatao-http-xiaodatao-iteye-com-xiaodatao-2012-01-19-16-43">5 楼 <a href="http://xiaodatao.iteye.com/" title="xiaodatao" target="_blank">xiaodatao</a> 2012-01-19 16:43</h3>
<p>基本数据的类型的大小是固定的。
Object ob = new Object();
    这样在程序中完成了一个Java对象的生命，但是它所占的空间为：4byte+8byte。4byte是Java栈中保存实例引用。<img src="" alt=""> <img src="" alt=""> </p>
<h3 id="4-shaomeng95-http-shaomeng95-iteye-com-shaomeng95-2011-07-08-13-13">4 楼 <a href="http://shaomeng95.iteye.com/" title="shaomeng95" target="_blank">shaomeng95</a> 2011-07-08 13:13</h3>
<p>官方文档上说：This data type represents one bit of information, but its &quot;size&quot; isn&#39;t something that&#39;s precisely defined.</p>
<h3 id="3-shaomeng95-http-shaomeng95-iteye-com-shaomeng95-2011-07-08-13-10">3 楼 <a href="http://shaomeng95.iteye.com/" title="shaomeng95" target="_blank">shaomeng95</a> 2011-07-08 13:10</h3>
<p>而且12byte没有包含</p>
<p>kthh0226 写道
这个有问题吧，java没有说明boolean的大小，不一定是1byte的
boolean的大小是依赖VM的</p>
<h3 id="2-kthh0226-http-kthh0226-iteye-com-kthh0226-2011-06-17-17-30">2 楼 <a href="http://kthh0226.iteye.com/" title="kthh0226" target="_blank">kthh0226</a> 2011-06-17 17:30</h3>
<p>这个有问题吧，java没有说明boolean的大小，不一定是1byte的</p>
<h3 id="1-smalltalker-http-smalltalker-iteye-com-smalltalker-2011-05-30-20-18">1 楼 <a href="http://smalltalker.iteye.com/" title="smalltalker" target="_blank">smalltalker</a> 2011-05-30 20:18</h3>
<p><img src="" alt=""></p>
<h3 id="-">发表评论</h3>
<p><a href="http://hllvm.group.iteye.com/login" target="_blank"><img src="" alt=""> 您还没有登录,请您登录后再发表评论</a></p>
<p><a href="http://hllvm.group.iteye.com/group/wiki/new" target="_blank"><img src="" alt="New-page"></a></p>
<h3 id="-">文章信息</h3>
<p><a href="http://hllvm.group.iteye.com/group/wiki/" target="_blank">知识库: 高级语言虚拟机</a></p>
<ul>
<li>由<a href="http://kiral.iteye.com/" title="fantasy" target="_blank">fantasy</a>在2010-11-08创建</li>
<li><p>由<a href="http://kiral.iteye.com/" title="fantasy" target="_blank">fantasy</a>在2011-05-26更新</p>
<h3 id="-">相关新闻</h3>
</li>
<li><p><a href="http://hllvm.group.iteye.com/news/25761" target="_blank">Leak Finder：谷歌的JavaScript内存泄露检测工具</a></p>
</li>
<li><a href="http://hllvm.group.iteye.com/news/16601" target="_blank">Azul Systems将要开源Managed Runtime Initiative中的重要技术</a></li>
<li><a href="http://hllvm.group.iteye.com/news/4" target="_blank">struts2新特性预览</a></li>
</ul>
<h3 id="-">相关讨论</h3>
<ul>
<li><a href="http://hllvm.group.iteye.com/topic/671298" target="_blank">封装ConcurrentHashMap成为具有各种引用类型key与value的ConcurrentReferenceMap，完美取代WeakHashMap</a></li>
<li><a href="http://hllvm.group.iteye.com/topic/1030509" target="_blank">关于java 垃圾回收的理解</a></li>
<li><a href="http://hllvm.group.iteye.com/topic/1039464" target="_blank">闲来无事，用Java的软引用写了一个山寨的缓存</a></li>
<li><a href="http://hllvm.group.iteye.com/topic/401478" target="_blank">理解 Java 的 GC 与 幽灵引用</a></li>
<li><p><a href="http://hllvm.group.iteye.com/topic/704710" target="_blank">关于ThreadLocal的内存泄露</a></p>
<h3 id="-">相关博客</h3>
</li>
<li><p><a href="http://hzbaihu.iteye.com/blog/961293" target="_blank">JVM概念中的Java对象的大小，以及三种引用类型的定义与区分</a></p>
</li>
<li><a href="http://jiaozhiguang-126-com.iteye.com/blog/1701027" target="_blank">JVM调优总结（二）-一些概念</a></li>
<li><a href="http://pengjiaheng.iteye.com/blog/519471" target="_blank">JVM调优总结（二）-一些概念</a></li>
<li><a href="http://qjbtj999.iteye.com/blog/660134" target="_blank">[转] JVM调优总结（二）-一些概念</a></li>
<li><a href="http://millerhu.iteye.com/blog/890685" target="_blank">JVM调优总结（二）-一些概念</a></li>
<li><a href="http://www.iteye.com/" target="_blank">首页</a></li>
<li><a href="http://www.iteye.com/news" target="_blank">资讯</a></li>
<li><a href="http://www.iteye.com/magazines" target="_blank">精华</a></li>
<li><a href="http://www.iteye.com/forums" target="_blank">论坛</a></li>
<li><a href="http://www.iteye.com/ask" target="_blank">问答</a></li>
<li><a href="http://www.iteye.com/blogs" target="_blank">博客</a></li>
<li><a href="http://www.iteye.com/blogs/subjects" target="_blank">专栏</a></li>
<li><a href="http://www.iteye.com/groups" target="_blank">群组</a></li>
<li><a href="http://job.iteye.com/iteye" target="_blank">招聘</a></li>
<li><a href="http://www.iteye.com/search" target="_blank">搜索</a></li>
<li><a href="http://hllvm.group.iteye.com/index/service" target="_blank">广告服务</a></li>
<li><a href="http://webmaster.iteye.com/" target="_blank">ITeye黑板报</a></li>
<li><a href="http://hllvm.group.iteye.com/index/contactus" target="_blank">联系我们</a></li>
<li><a href="http://hllvm.group.iteye.com/index/friend_links" target="_blank">友情链接</a></li>
</ul>
<p>© 2003-2012 ITeye.com. [ <a href="http://www.miibeian.gov.cn/" target="_blank">京ICP证110151号</a> 京公网安备110105010620 ]
百联优力(北京)投资有限公司 版权所有 <img src="http://stat.iteye.com/?url=http%3A%2F%2Fhllvm.group.iteye.com%2Fgroup%2Fwiki%2F2860-JVM&amp;referrer=http%3A%2F%2Fhllvm.group.iteye.com%2Fgroup%2Fwiki%2F%3Fcategory_id%3D301&amp;user_id=" alt=""></p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/JVM/">JVM</a></li></span></span> | <span class="tags">Tagged <a href="/tags/JVM/" class="label label-primary">JVM</a><a href="/tags/Java&J2EE/" class="label label-success">Java&J2EE</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:41"datetime="2014-03-07 09:54:41"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-JVM--JVM调优总结（二）-一些概念-高级语言虚拟机/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-JVM--JVM调优总结（二）-一些概念-高级语言虚拟机" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_多线程--探索java多线程（连载）1守护线程-ikon-BlogJava/">探索java多线程（连载）1 守护线程 </a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:41.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_多线程--探索java多线程（连载）1守护线程-ikon-BlogJava/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-java-1-ikon-blogjava">探索java多线程（连载）1 守护线程 - ikon - BlogJava</h1>
<h1 id="-ikon-http-www-blogjava-net-ikon-"><a href="http://www.blogjava.net/ikon/" target="_blank">ikon</a></h1>
<p>posts - 1, comments - 0, trackbacks - 0, articles - 1   <a href="http://www.blogjava.net/" target="_blank">BlogJava</a> :: <a href="http://www.blogjava.net/ikon/" target="_blank">首页</a> :: <a href="http://www.blogjava.net/ikon/admin/EditPosts.aspx?opt=1" target="_blank">新随笔</a> :: <a href="http://www.blogjava.net/ikon/contact.aspx?id=1" target="_blank">联系</a> :: <a href="http://www.blogjava.net/ikon/rss" target="_blank">聚合</a> <a href="http://www.blogjava.net/ikon/rss" target="_blank"><img src="" alt=""></a> :: <a href="http://www.blogjava.net/ikon/admin/EditPosts.aspx" target="_blank">管理</a> <img src="" alt=""></p>
<h3 id="-">日历</h3>
<p><a href="&quot;Go to the previous month&quot;">&lt;</a>2011年3月<a href="&quot;Go to the next month&quot;">&gt;</a>日一二三四五六2728123456789101112131415161718192021<a href="http://www.blogjava.net/ikon/archive/2011/03/22.html" target="_blank">22</a>232425262728293031123456789</p>
<p><img src="" alt=""></p>
<h3 id="-">常用链接</h3>
<ul>
<li><a href="http://www.blogjava.net/ikon/MyPosts.html" target="_blank">我的随笔</a></li>
<li><a href="http://www.blogjava.net/ikon/MyComments.html" target="_blank">我的评论</a></li>
<li><a href="http://www.blogjava.net/ikon/OtherPosts.html" target="_blank">我的参与</a>
<img src="" alt=""></li>
</ul>
<h3 id="-">留言簿</h3>
<ul>
<li><a href="http://www.blogjava.net/ikon/Contact.aspx?id=1" target="_blank">给我留言</a></li>
<li><a href="http://www.blogjava.net/ikon/default.aspx?opt=msg" target="_blank">查看公开留言</a></li>
<li><a href="http://www.blogjava.net/ikon/admin/MyMessages.aspx" target="_blank">查看私人留言</a></li>
</ul>
<p><img src="" alt=""></p>
<h3 id="-">随笔档案</h3>
<ul>
<li><a href="http://www.blogjava.net/ikon/archive/2011/03.html" target="_blank">2011年3月 (1)</a>
<img src="" alt=""></li>
</ul>
<h3 id="-">搜索</h3>
<ul>
<li></li>
</ul>
<p><img src="" alt=""></p>
<h3 id="-http-www-blogjava-net-ikon-commentsrss-aspx-java-1-">最新评论 <a href="http://www.blogjava.net/ikon/CommentsRSS.aspx" target="_blank"><img src="" alt=""></a> ## <a href="">探索java多线程（连载）1 守护线程</a></h3>
<p>Posted on 2011-03-22 19:25 <a href="http://www.blogjava.net/ikon/" target="_blank">ikon</a> 阅读(1692) <a href="http://www.blogjava.net/ikon/archive/2011/03/22/346738.html#Post" target="_blank">评论(0)</a>  <a href="http://www.blogjava.net/ikon/admin/EditPosts.aspx?postid=346738" target="_blank">编辑</a>  <a href="http://www.blogjava.net/ikon/AddToFavorite.aspx?id=346738" target="_blank">收藏</a> <img src="" alt=""></p>
<pre><code>  在java中有一类线程，专门在后台提供服务，此类线程无需显式关闭，当程序结束了，它也就结束了，这就是守护线程 daemon thread。如果还有非守护线程的线程在执行，它就不会结束。      守护线程有何用处呢？让我们来看个实践中的例子。

  在我们的系统中经常应用各种配置文件（黑名单，禁用词汇），当修改配置文件后，一般要重启服务，系统才能够加载；当重启服务的代价比较高的情况下，这种加载方式不能满足我们的要求，这个时候守护线程该发挥它的作用了，它可以实时加载你的配置文件，无需重启。（当然，相当重要的配置文件，不推荐实时加载）
</code></pre><p><img src="" alt="">package com.ikon.thread.daemon;
<img src="" alt="">
<img src="" alt="">import java.io.File;
<img src="" alt="">import java.util./<em>;
<img src="" alt="">
<img src="" alt=""><img src="" alt="">//</em>/<em> /</em>///<em>/</em>
<img src="" alt=""> /<em> 文件监测
<img src="" alt=""> /</em> @author ikon99999
<img src="" alt=""> /<em> 
<img src="" alt=""> /</em>/
<img src="" alt=""><img src="" alt="">public abstract class FileWatchdog extends Thread <img src="" alt="">{
<img src="" alt="">
<img src="" alt=""> 
<img src="" alt="">  static final public long DEFAULT_DELAY = 20/*1000; 
<img src="" alt=""> 
<img src="" alt=""><br><img src="" alt="">  protected HashMap fileList;
<img src="" alt=""> 
<img src="" alt="">  protected long delay = DEFAULT_DELAY; 
<img src="" alt=""><br><img src="" alt="">  boolean warnedAlready = false;
<img src="" alt=""><br><img src="" alt="">  boolean interrupted = false;
<img src="" alt="">
<img src="" alt="">  public static class Entity
<img src="" alt=""><img src="" alt="">  <img src="" alt="">{
<img src="" alt="">        File file;
<img src="" alt="">        long lastModify;
<img src="" alt="">        Entity(File file,long lastModify)
<img src="" alt=""><img src="" alt="">        <img src="" alt="">{
<img src="" alt="">            this.file = file;
<img src="" alt="">            this.lastModify = lastModify;
<img src="" alt="">        }
<img src="" alt="">  }
<img src="" alt=""><br><img src="" alt=""><img src="" alt="">  protected  FileWatchdog() <img src="" alt="">{
<img src="" alt="">      fileList = new HashMap ();
<img src="" alt="">    setDaemon(true);
<img src="" alt="">  }
<img src="" alt="">
<img src="" alt=""> 
<img src="" alt=""><img src="" alt="">  public  void setDelay(long delay) <img src="" alt="">{
<img src="" alt="">    this.delay = delay;
<img src="" alt="">  }
<img src="" alt="">
<img src="" alt="">  public void addFile(File file)
<img src="" alt=""><img src="" alt="">  <img src="" alt="">{
<img src="" alt="">        fileList.put(file.getAbsolutePath(),new Entity(file,file.lastModified()));<br><img src="" alt="">  }
<img src="" alt=""><br><img src="" alt="">  public boolean contains(File file)
<img src="" alt=""><img src="" alt="">  <img src="" alt="">{
<img src="" alt="">        if( fileList.get(file.getAbsolutePath()) != null) return true;
<img src="" alt="">        else return false;
<img src="" alt="">  }
<img src="" alt=""><br><img src="" alt="">  abstract   protected   void doOnChange(File file);
<img src="" alt="">
<img src="" alt=""><img src="" alt="">  protected  void checkAndConfigure() <img src="" alt="">{
<img src="" alt="">      HashMap map = (HashMap)fileList.clone(); 
<img src="" alt="">      Iterator it = map.values().iterator();
<img src="" alt=""><br><img src="" alt="">      while( it.hasNext())
<img src="" alt=""><img src="" alt="">      <img src="" alt="">{
<img src="" alt=""><br><img src="" alt="">            Entity entity = (Entity)it.next();
<img src="" alt=""><br><img src="" alt="">            boolean fileExists;
<img src="" alt=""><img src="" alt="">            try <img src="" alt="">{
<img src="" alt="">              fileExists = entity.file.exists();
<img src="" alt="">            } catch(SecurityException  e) 
<img src="" alt=""><img src="" alt="">            <img src="" alt="">{
<img src="" alt="">              System.err.println (&quot;Was not allowed to read check file existance, file:[&quot;+ entity.file .getAbsolutePath() +&quot;].&quot;);
<img src="" alt="">              interrupted = true; 
<img src="" alt="">              return;
<img src="" alt="">            }
<img src="" alt="">
<img src="" alt="">            if(fileExists) 
<img src="" alt=""><img src="" alt="">            <img src="" alt="">{
<img src="" alt=""><br><img src="" alt="">              long l = entity.file.lastModified(); // this can also throw a SecurityException
<img src="" alt=""><img src="" alt="">              if(l &gt; entity.lastModify) <img src="" alt="">{           // however, if we reached this point this
<img src="" alt="">                    entity.lastModify = l;              // is very unlikely.
<img src="" alt="">                    newThread(entity.file);
<img src="" alt="">              }
<img src="" alt="">            }
<img src="" alt="">            else 
<img src="" alt=""><img src="" alt="">            <img src="" alt="">{
<img src="" alt="">                System.err.println (&quot;[&quot;+entity.file .getAbsolutePath()+&quot;] does not exist.&quot;);
<img src="" alt="">            }
<img src="" alt="">      }
<img src="" alt="">  }
<img src="" alt=""><br><img src="" alt="">  private void newThread(File file)
<img src="" alt=""><img src="" alt="">  <img src="" alt="">{
<img src="" alt="">      class MyThread extends Thread
<img src="" alt=""><img src="" alt="">      <img src="" alt="">{
<img src="" alt="">            File f;
<img src="" alt="">            public MyThread(File f)
<img src="" alt=""><img src="" alt="">            <img src="" alt="">{
<img src="" alt="">                this.f = f;
<img src="" alt="">            }
<img src="" alt=""><br><img src="" alt="">            public void run()
<img src="" alt=""><img src="" alt="">            <img src="" alt="">{
<img src="" alt="">                doOnChange(f);
<img src="" alt="">            }
<img src="" alt="">      }
<img src="" alt=""><br><img src="" alt="">      MyThread mt = new MyThread(file);
<img src="" alt="">      mt.start();
<img src="" alt="">  }
<img src="" alt="">
<img src="" alt="">  public  void run() 
<img src="" alt=""><img src="" alt="">  <img src="" alt="">{<br><img src="" alt=""><img src="" alt="">    while(!interrupted) <img src="" alt="">{
<img src="" alt=""><img src="" alt="">      try <img src="" alt="">{
<img src="" alt="">        Thread.currentThread().sleep(delay);
<img src="" alt=""><img src="" alt="">      } catch(InterruptedException e) <img src="" alt="">{
<img src="" alt="">    // no interruption expected
<img src="" alt="">      }
<img src="" alt="">      checkAndConfigure();
<img src="" alt="">    }
<img src="" alt="">  }
<img src="" alt="">}
<img src="" alt=""></p>
<pre><code>FileWatchdog是个抽象类，本身是线程的子类；在构造函数中设置为守护线程；
此类用hashmap维护着一个文件和最新修改时间值对，checkAndConfigure()方法用来检测哪些文件的修改时间更新了，如果发现文件更新了则调用doOnChange方法来完成监测逻辑；doOnChange方法是我们需要实现的；看下面关于一个黑名单服务的监测服务：
</code></pre><p> 1<img src="" alt="">package com.ikon.thread.daemon;
 2<img src="" alt="">
 3<img src="" alt="">import java.io.File;
 4<img src="" alt="">
 5<img src="" alt=""><img src="" alt="">//<em>/</em> /<em>///</em>/<em>
 6<img src="" alt=""> /</em> 黑名单服务
 7<img src="" alt=""> /<em> @author ikon99999
 8<img src="" alt=""> /</em> 2011-3-21
 9<img src="" alt=""> /<em>/
10<img src="" alt=""><img src="" alt="">public class BlacklistService <img src="" alt="">{
11<img src="" alt="">    private File configFile = new File(&quot;c:/blacklist.txt&quot;);
12<img src="" alt=""><br>13<img src="" alt=""><img src="" alt="">    public void init() throws Exception<img src="" alt="">{
14<img src="" alt="">        loadConfig();
15<img src="" alt="">        ConfigWatchDog dog = new ConfigWatchDog();
16<img src="" alt="">        dog.setName(&quot;daemon_demo_config_watchdog&quot;);//a
17<img src="" alt="">        dog.addFile(configFile);//b
18<img src="" alt="">        dog.start();//c
19<img src="" alt="">    }
20<img src="" alt=""><br>21<img src="" alt=""><img src="" alt="">    public void loadConfig()<img src="" alt="">{
22<img src="" alt=""><img src="" alt="">        try<img src="" alt="">{
23<img src="" alt="">            Thread.sleep(1/</em>1000);//d
24<img src="" alt=""><br>25<img src="" alt="">            System.out.println(&quot;加载黑名单&quot;);
26<img src="" alt=""><img src="" alt="">        }catch(InterruptedException ex)<img src="" alt="">{
27<img src="" alt="">            System.out.println(&quot;加载配置文件失败！&quot;);
28<img src="" alt="">        }
29<img src="" alt="">    }
30<img src="" alt=""><br>31<img src="" alt=""><img src="" alt="">    public File getConfigFile() <img src="" alt="">{
32<img src="" alt="">        return configFile;
33<img src="" alt="">    }
34<img src="" alt="">
35<img src="" alt=""><img src="" alt="">    public void setConfigFile(File configFile) <img src="" alt="">{
36<img src="" alt="">        this.configFile = configFile;
37<img src="" alt="">    }
38<img src="" alt="">
39<img src="" alt="">
40<img src="" alt=""><img src="" alt="">    private class ConfigWatchDog extends FileWatchdog<img src="" alt="">{
41<img src="" alt=""><br>42<img src="" alt="">        @Override
43<img src="" alt=""><img src="" alt="">        protected void doOnChange(File file) <img src="" alt="">{
44<img src="" alt="">            System.out.println(&quot;文件&quot;+file.getName()+&quot;发生改变，重新加载&quot;);
45<img src="" alt="">            loadConfig();
46<img src="" alt="">        }
47<img src="" alt=""><br>48<img src="" alt="">    }
49<img src="" alt=""><br>50<img src="" alt=""><img src="" alt="">    public static void main(String[] args) throws Exception <img src="" alt="">{
51<img src="" alt="">        BlacklistService service = new BlacklistService();
52<img src="" alt="">        service.init();
53<img src="" alt=""><br>54<img src="" alt="">        Thread.sleep(60/<em>60/</em>1000);//e
55<img src="" alt="">    }
56<img src="" alt="">}
57<img src="" alt="">
        ConfigWatchDog内部类实现了doOnChange(File file)方法，当文件被修改后，watchdog调用doOnChange方法完成重新加载操作；
        在blackservice的init方法中初始化watchdog线程；
        d：模拟文件加载耗时
        e：主要是防止主线程退出；
        其实上面的FileWatchdog就是取自log4j；</p>
<p><a href="http://www.blogjava.net/RequireRegister.aspx" target="_blank">新用户注册</a>  <a href="">刷新评论列表</a>  </p>
<p><a href=""></a> <a href="http://job.cnblogs.com/">找优秀程序员，就在博客园</a>
<a href="http://job.cnblogs.com/offer/12368/" target="_blank">网易有道诚聘CRM研发工程师</a>
<a href="http://job.cnblogs.com/offer/11576/" target="_blank">锦江国际诚聘Java高级软件工程师</a>
<a href="http://job.cnblogs.com/offer/12493/" target="_blank">福州几维网络诚聘Java服务端程序员</a>
IT新闻：
· <a href="http://news.cnblogs.com/n/101664/" target="_blank">开放，开放，开放 —— 垄断</a>
· <a href="http://news.cnblogs.com/n/101663/" target="_blank">GNOME讨论放弃支持非Linux操作系统</a>
· <a href="http://news.cnblogs.com/n/101662/" target="_blank">Chrome 13将隐藏地址栏</a>
· <a href="http://news.cnblogs.com/n/101661/" target="_blank">联想：USB 3.0将在2012年成为主流</a>
· <a href="http://news.cnblogs.com/n/101659/" target="_blank">意法半导体 CEO ：诺基亚 Windows Phone 将采用 U8500 双核芯片</a>   <a href="http://www.cnblogs.com/" target="_blank">博客园</a>  <a href="http://home.cnblogs.com/q/" target="_blank">博问</a>  <a href="http://news.cnblogs.com/" target="_blank">IT新闻</a>  <a href="http://job.cnblogs.com/cate-java_programmer/" target="_blank">Java程序员招聘</a> 标题  请输入标题 姓名  请输入你的姓名 主页 请输入验证码 验证码 /*  <img src="" alt=""> 内容(请不要发表任何与政治相关的内容) 请输入评论内容 Remember Me?   <a href="http://www.blogjava.net/login.aspx?ReturnURL=http://www.blogjava.net/ikon/archive/2011/03/22/346738.html&amp;SourceURL=/ikon/archive/2011/03/22/346738.html" target="_blank">登录</a>       [使用Ctrl+Enter键可以直接提交]    推荐职位：
· <a href="http://job.cnblogs.com/offer/5914/" target="_blank">北京.NET 研发工程师 (北京捷报数据)</a>
· <a href="http://job.cnblogs.com/offer/12527/" target="_blank">(北京).NET软件开发工程师(北京龙达)</a>
· <a href="http://job.cnblogs.com/offer/11584/" target="_blank">厦门高级.NET软件工程师(服务于美国Amazon)</a>
· <a href="http://job.cnblogs.com/offer/10723/" target="_blank">高级Web页面前端开发工程师(新蛋中国)</a>
· <a href="http://job.cnblogs.com/offer/12493/" target="_blank">厦门Java服务端程序员(福州几维网络)</a>
· <a href="http://job.cnblogs.com/offer/9051/" target="_blank">.NET 高级软件开发工程师 (新蛋中国)</a>
· <a href="http://job.cnblogs.com/offer/12439/" target="_blank">北京ASP.NET 工程师（月薪12k）(北京盛安德)</a>
· <a href="http://job.cnblogs.com/offer/12492/" target="_blank">厦门C/#游戏客户端程序员 (福州几维网络)</a></p>
<p>博客园首页随笔：
· <a href="http://www.cnblogs.com/kqingchao/archive/2011/05/20/character-encoding-2.html" target="_blank">字符编码浅谈（二）</a>
· <a href="http://www.cnblogs.com/xuesong/archive/2011/05/20/2051892.html" target="_blank">Windows Phone 7编程实践—必应地图导航</a>
· <a href="http://www.cnblogs.com/ini_always/archive/2011/05/20/2050517.html" target="_blank">绕死你不偿命的UNICODE、_UNICODE、<strong>TEXT、</strong>T、_T、_TEXT、TEXT宏</a>
· <a href="http://www.cnblogs.com/leslies2/archive/2011/05/20/2051844.html" target="_blank">学习笔记：JAVA RMI远程方法调用简单实例</a>
· <a href="http://www.cnblogs.com/bobomouse/archive/2011/05/20/2051846.html" target="_blank">关于CellSet转DataTable的改进方案</a>
知识库：
· <a href="http://kb.cnblogs.com/page/101423/" target="_blank">程序员的本质</a>
· <a href="http://kb.cnblogs.com/page/101345/" target="_blank">Scrum之成败——从自身案例说起</a>
· <a href="http://kb.cnblogs.com/page/101321/" target="_blank">清除代码异味</a>
· <a href="http://kb.cnblogs.com/page/101198/" target="_blank">详解.NET程序集的加载规则</a>
· <a href="http://kb.cnblogs.com/page/101162/" target="_blank">如何通过ildasm/ilasm修改assembly的IL代码</a> 最简洁阅读版式：
<a href="http://archive.cnblogs.com/b/346738/" target="_blank">探索java多线程（连载）1 守护线程</a> 网站导航:</p>
<p><a href="http://www.cnblogs.com/" title="程序员的网上家园" target="_blank">博客园</a>   <a href="http://news.cnblogs.com/" target="_blank">IT新闻</a>   <a href="http://kb.cnblogs.com/" target="_blank">知识库</a>   <a href="http://www.cnweblog.com/" target="_blank">博客生活</a>   <a href="http://www.cnitblog.com/" target="_blank">IT博客网</a>   <a href="http://www.cppblog.com/" target="_blank">C++博客</a>   <a href="http://space.cnblogs.com/q/" title="IT问答" target="_blank">博问</a>   <a href="http://www.blogjava.net/ikon/archive/2011/03/22/346738.html?opt=admin" target="_blank">管理</a>    Powered by:
<a href="http://www.blogjava.net/" target="_blank">BlogJava</a>
Copyright © ikon</p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/Java_多线程/">Java_多线程</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/Java_多线程/" class="label label-success">Java_多线程</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:41"datetime="2014-03-07 09:54:41"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-Java_多线程--探索java多线程（连载）1守护线程-ikon-BlogJava/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-Java_多线程--探索java多线程（连载）1守护线程-ikon-BlogJava" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>





<ul id="pagination" class="pagination pagination-lg">
  <li><a class="extend prev" href="/page/61/">&laquo;</a></li><li><a class="page-number" href="/">1</a></li><li><a class="page-number" href="/page/2/">2</a></li><li><span class="space">&hellip;</span></li><li><a class="page-number" href="/page/59/">59</a></li><li><a class="page-number" href="/page/60/">60</a></li><li><a class="page-number" href="/page/61/">61</a></li><li class="active"><li><span class="page-number current">62</span></li><li><a class="page-number" href="/page/63/">63</a></li><li><a class="page-number" href="/page/64/">64</a></li><li><a class="page-number" href="/page/65/">65</a></li><li><span class="space">&hellip;</span></li></li><li><a class="page-number" href="/page/161/">161</a></li><li><a class="page-number" href="/page/162/">162</a></li><li><a class="extend next" href="/page/63/">&raquo;</a></li>
  <div class="clearfix"></div>
</ul></div><!--wapper-->
       </div><!-- ID main-col END -->
       <aside id="sidebar" class="alignright col-sx-6 col-sm-4 col-md-3 col-lg-3">
<div id="widget_search" class="widget panel panel-primary">
    <form action="//google.com/search" method="get" accept-charset="utf-8">
  <div class="input-group">
    <input class="form-control" id="searchbox" type="search" name="q" results="0" placeholder="search">
    <span class="input-group-btn">
      <button class="btn btn-default" type="submit">Go!</button>
    </span>
    <input type="hidden" name="q" value="site:itsolife.com">
  </div>
</form>
</div>

<div id="widget_category" class="widget panel panel-primary">
  <div class="panel-heading">category</div>  <div data-src='category' class='ajax_widgets'>正在加载...</div>
</div>

<div id="widget_recent_posts" class="widget panel panel-primary">
  <div class="panel-heading">recent posts</div>  <div data-src='recent_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_tagcloud" class="widget panel panel-primary">
  <div class="panel-heading">tagcloud</div>  <div data-src='tagcloud' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_latest_update_posts" class="widget panel panel-primary">
  <div class="panel-heading">最近更新</div>  <div data-src='latest_update_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_recent_comments" class="widget panel panel-primary">
  <div class="panel-heading">recent comments</div>  

<div class="list-group-item ds-recent-comments" data-num-items="6" data-show-avatars="1" data-show-time="1" data-show-title="1" data-show-admin="1" data-excerpt-length="50"></div>



</div>

</aside>
       <div class="clearfix"></div>
     </div><!-- row END -->
  </div>
  <footer id="footer" class="container">
  <div class="panel panel-info">
  <section id='footer_widget'></section>  <div class="panel-footer">
  <div id="site-info">
    <span class='author'>
  
  &copy; 2014 RobinChia
  
    &nbsp;&nbsp;</span>
  
  <span id='analytics-51la'></span><span id='analytics-google'>
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-48559895-1']);
  _gaq.push(['_trackPageview']);
  _js2load.push({src:('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'});
</script></span><span id='analytics-cnzz'>
<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_5774006'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s17.cnzz.com/stat.php%3Fid%3D5774006%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>
</span><span id='analytics-baidu'>
<script>
var _hmt = _hmt || [];
_js2load.push({src:"//hm.baidu.com/hm.js?1442f50724afc42380b51f097c43082c"});
</script>
</span>  </div>
  <div id="copyright">Site powered by <a href='http://zespia.tw/hexo/'><strong>hexo</strong></a>  update time: <em>2014-04-07 17:30:36</em></span></div>
</div>
<div class="clearfix"></div>


  </div>
  </footer>
  
        <script src="http://cdn.bootcss.com/jquery/1.10.2/jquery.min.js"></script>        
        <script src="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/js/bootstrap.min.js"></script>        
                
        <script src="http://cdn.bootcss.com/prettify/r298/prettify.min.js"></script>    <script type="text/javascript">
   var lang=["bsh", "c", "cc", "cpp", "cs", "csh", "cyc", "cv", "htm", "html",
    "java", "js", "m", "mxml", "perl", "pl", "pm", "py", "rb", "sh",
    "xhtml", "xml", "xsl"];
   var pretty_base='';
   $('script').each(function(){
	var c = $(this).attr('src');
	if (!c)
	    return;
	if (c.match(/(\/)?prettify(\.min)?\.js/i))
	{
	    var index = c.lastIndexOf('/');
	    if (index != -1)
		pretty_base = c.substr(0,index + 1);
	    return false;
	}
   })
   $('pre code').each(function(){
	var c = $(this).attr('class')
	if (!c)
	    return;
	c = c.match(/\s?(lang\-\w+)/i);
	if (c && lang.indexOf(c[1]) == -1)
	{
	    lang.push(c[1]);
	    $.getScript(pretty_base + c[1] + '.min.js');
	}
   })

    $(window).load(function(){
       $("pre").addClass("prettyprint");
       prettyPrint();
    })
</script>    
            <script type="text/javascript">
var duoshuoQuery = {short_name:"robinchia"};
_js2load.push({src:'http://static.duoshuo.com/embed.js',charset:'UTF-8'});
</script>
    
            <!--wumii_relatedItems-->
    
        <script src="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js"></script>    <script type="text/javascript">
(function($){
  $('.entry').each(function(i){
    $(this).find('img').each(function(){
      var alt = this.alt;

      if (alt){
        $(this).before('<span class="caption">' + alt + '</span>');
      }

      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox" rel="fancybox' + i + '" />');
    });
  });

  $('.fancybox').fancybox();
})(jQuery);
</script>    
        <script src="http://cdn.bootcss.com/mathjax/2.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>    <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>
    
<script type="text/javascript">
$('.ajax_widgets').each(function(){var src=$(this).attr('data-src');if(src)$(this).load('/widgets/'+src+'.html');});
$.each(_js2load,function(index,obj){loadjs(obj.src,obj.charset)});
</script>

<div id="scroll2top">
<img src="/scroll2top/arrow.png"/>
</div>
<script src="/scroll2top/scroll2top.min.js"></script>
<div id="winterland">
  <canvas></canvas>
</div>
<script src="/js/winterland.min.js"></script>

  </body>
</html>
