
<!DOCTYPE HTML>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>The 107 Page | It so life</title>
<meta name="author" content="RobinChia">

<meta name="description" content="It so life">


<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<meta property="og:site_name" content="It so life"/>

<!--[if IE]><style>.testIE.IE{display:inline;}</style><![endif]-->
<!--[if lte IE 7]><link rel="stylesheet" href="/css/ie7.css" type="text/css"><![endif]-->
<!--[if (lt IE 9)&(gt IE 7)]><style>.testIE.IE8{display:inline;}</style><![endif]-->
<!--[if gt IE 8]><style>.testIE.IE9{display:inline;}</style><![endif]-->

<link href="/favicon.png" rel="icon">
<link rel="alternate" href="/atom.xml" title="It so life Feed" type="application/atom+xml">

<link rel="stylesheet" href="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/css/bootstrap.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/font-awesome/4.0.3/css/font-awesome.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/prettify/r298/prettify.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" type="text/css">
<link rel="stylesheet" href="/css/style.css" type="text/css">
<!--[if lt IE 9]>
   <style>article,aside,dialog,footer,header,section,footer,nav,figure,menu{display:block}</style>
   <script src="http://cdn.staticfile.org/html5shiv/r29/html5.min.js"></script>
   <script src="http://cdn.staticfile.org/respond.js/1.4.2/respond.min.js"></script>
<link href="http://cdn.staticfile.org/respond.js/1.4.2/respond-proxy.html" id="respond-proxy" rel="respond-proxy" />
<link href="/js/respond.proxy.gif" id="respond-redirect" rel="respond-redirect" />
<script src="/js/respond.proxy.js"></script>
   <script src="http://cdn.bootcss.com/selectivizr/1.0.2/selectivizr-min.js"></script>
<![endif]-->
<script type="text/javascript">
function loadjs(c,d){var a=document.createElement("script");a.async=!0;a.type="text/javascript";a.src=c;a.charset=d||"gbk";(document.getElementsByTagName("HEAD")[0]||document.getElementsByTagName("BODY")[0]).appendChild(a)};
var _protocol = (("https:" == document.location.protocol) ? " https://" : " http://");
var _js2load = [];
</script>

</head>
<body>
      <header id="header" class="container"><nav id="main-nav" class="navbar navbar-default navbar-fixed-top " role="navigation">
  <div class="container">
    <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
      <span class="sr-only">Toggle navigation</span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="/">It so life</a>
    </div>
    <div  class="collapse navbar-collapse">
      <ul  class="nav navbar-nav">
  
        <li><a href="/" title="Home">Home</a></li>      
        <li><a href="/about/" title="About">About</a></li>      
        <li><a href="/archives/" title="Archives">Archives</a></li>      
      <li class='dropdown'>
        <a class='dropdown-toggle' data-toggle='dropdown' href='#'>website<b class='caret'></b></a>
        <ul class='dropdown-menu pure-menu-selected'>
    
          <li><a href="//groups.google.com/forum/#!forum/pongba" title="TopLanguage">TopLanguage</a></li>    
          <li><a href="//itpub.net/" title="ITPub">ITPub</a></li>    
          <li><a href="//blog.jobbole.com/" title="Bole">Bole</a></li>    
          <li><a href="//nosql-database.org/" title="nosql">nosql</a></li>    
          <li><a href="//gitimmersion.googol.im/" title="Git">Git</a></li>    
        </ul>
      </li>
    
      </ul>
      <ul class="nav navbar-nav navbar-right">
      
        <li><a href="/atom.xml">RSS</a></li>
      
      
        <li><a href="https://twitter.com/robinchia">twitter</a></li>
      
      
      
      
        <li><a href="https://github.com/robinchia">github</a></li>
      
      </ul>
    </div>
  </div>
</nav>
<div class="clearfix"></div>
</header>
  <div id='content' class="container">
     <div class="page-header-wrapper">
      <!--[if lt IE 9]><div class="alert alert-warning alert-dismissable"><button type="button" class="close" data-dismiss="alert" aria-hidden="true">&times;</button><strong>提示:</strong>您的浏览器版本太低了,建议升级到 <strong><a href="http://windows.microsoft.com/zh-cn/internet-explorer/download-ie" title="IE9">IE9</a></strong> 以上,本站使用<a href="https://www.google.com/intl/zh-CN/chrome/">Chrome浏览器</a>可以获得最好的显示效果.</div><![endif]-->
      <div class="page-header"><h1 align="center"><big>It so life</big> </h1>
        <h5 align="center"><big>love as life</big></h5>
      </div>
     </div>
     <div class="row">
       <div id="main-col" class="alignleft col-sx-12 col-sm-8 col-md-9 col-lg-9">
      <section id='header_widget'></section>
          <div id="wrapper"><article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-scala--ScalaTour/">Scala Tour</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:37.000Z"> <a href="/2014/02/02/2014-02-02-scala--ScalaTour/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="scala-tour">Scala Tour</h1>
<p>5月1日是劳动的日子，笔者做了一个学习Scala精彩特性的网站<a href="http://zh.scala-tour.com/" title="scala-tour" target="_blank">Scala-Tour</a>。在学习Scala是时候，遇到很多令人激动的特性，主要函数式编程和并发。相比下Java已经老态龙钟，步履躇跚。或许Scala不会成为替代Java语言，但的确给后来者设立了标杆。所以做了这个网站，顺着一个一个例子，由浅入深，由表及里。逐渐学会Scala,尽管不会因此成为一个熟练Scala的开发者，但是对函数式编程的也会相当了然。这篇文章精选了Scala-Tour上了一些章节，想快速了解的朋友可以看看这篇文章，当然想详细看就上上<a href="http://zh.scala-tour.com/" title="scala-tour" target="_blank">Scala-Tour</a>吧。
<img src="&quot;Scala&quot;" alt=""></p>
<h3 id="-close">不再需要Close</h3>
<p>在Java里面，使用完资源(文件句柄，数据库连接)等之后，必须手动Close。否则发生泄漏后，程序只有被迫重启。Scala可以通过函数式实现自动close。
import scala.reflect.io.File</p>
<p>import java.util.Scanner</p>
<p>def withScanner(f: File, op: Scanner =&gt; Unit) = {
    val scanner = new Scanner(f.bufferedReader)</p>
<pre><code>try {
    op(scanner)

} finally {
    scanner.close()

}
</code></pre><p>}</p>
<p>withScanner(File(&quot;/proc/self/stat&quot;),</p>
<pre><code>scanner =&gt; println(&quot;pid is &quot; + scanner.next()))
</code></pre><p>这个例子是从/proc/self/stat文件中读取当前进程的pid。withScanner封装了try-finally块，所以调用者不用再close。</p>
<h3 id="-">按名称传递参数</h3>
<p>我们熟悉的参数传递方式是按值传递。按名称传递的方式，可以理解为直接传递参数名字，等到实际调用的时候，再去取值。在Java代码中，往往充斥着if(log.isDebug()){log.debug(...)}这样语句。之前的if调用是很有必要的，因为在之后的debug语句中往往有字符串拼接的操作。在不需要打Log的时候，字符串拼接也有可能发生异常抛出。而Scala可以通过按名称传递解决这个问题，这样就不再需要if(log.isDebug())这样的语句了。
val logEnable = false</p>
<p>def log(msg: =&gt; String) =</p>
<pre><code>if (logEnable) println(msg)
</code></pre><p>val MSG = &quot;programing is running&quot;</p>
<p>log(MSG + 1 / 0)</p>
<h3 id="-">鸭子类型</h3>
<p>“走起来像鸭子，叫起来像鸭子，就是鸭子。”这个例子中使用{ def close(): Unit }作为参数类型。因此任何含有close()的函数的类都可以作为参数。这样的做法比使用接口要好很多，因为可以不引入任何依赖。这个withClose方法单独编译，随处使用。
def withClose(closeAble: { def close(): Unit }, op: { def close(): Unit } =&gt; Unit) {</p>
<pre><code>try {
    op(closeAble)

} finally {
    closeAble.close()

}
</code></pre><p>}</p>
<p>class Connection {</p>
<pre><code>def close() = println(&quot;close Connection&quot;)
</code></pre><p>}</p>
<p>val conn: Connection = new Connection()</p>
<p>withClose(conn, conn =&gt;
    println(&quot;do something with Connection&quot;))</p>
<h3 id="trait">Trait</h3>
<p>Traits就像是有函数体的Interface，使用with关键字来混入。单个Traits就像是一块乐高积木，一个插件。就像下面的JsonAble，当使用一个对象的时候，可以随时随地把它插在他上面。这个对接就具备了toJson的能力。不用创建一个类，或者写组合的代码，非常干脆。这样也可以使代码有很高的正交性。不再会为了一个很小的需求，去修改一个被广泛使用的类。
trait ForEachAble[A] {</p>
<p>  def iterator: java.util.Iterator[A]
  def foreach(f: A =&gt; Unit) = {</p>
<pre><code>val iter = iterator
while (iter.hasNext)

  f(iter.next)
</code></pre><p>  }</p>
<p>}</p>
<p>trait JsonAble {
  def toJson() =</p>
<pre><code>scala.util.parsing.json.JSONFormat.defaultFormatter(this)
</code></pre><p>}</p>
<p>val list = new java.util.ArrayList<a href="">Int</a> with ForEachAble[Int]</p>
<p>list.add(1); list.add(2)</p>
<p>println(&quot;For each: &quot;); list.foreach(x =&gt; println(x))
//println(&quot;Json: &quot; + list.toJson())</p>
<h3 id="-">函数式真正的威力</h3>
<p>通过将函数作为参数，可以使程序极为简洁。 函数式除了能简化代码外，更重要的是他关注的是Input和Output，函数本身没有副作用。 就是Unix pipeline一样，简单的命令可以组合在一起。 List的filter方法接受一个过滤函数，返回一个新的List 如果你喜欢Unix pipeline的方式，你一定也会喜欢函数式编程。 这个例子是用函数式的代码模拟“cat file | grep &#39;warn&#39; | grep &#39;2013&#39; | wc”的行为。相比于Ruby等动态语言,这威力来自于科学而不是魔法
val file = List(&quot;warn 2013 msg&quot;, &quot;warn 2012 msg&quot;, &quot;error 2013 msg&quot;, &quot;warn 2013 msg&quot;)</p>
<p>println(&quot;cat file | grep &#39;warn&#39; | grep &#39;2013&#39; | wc : &quot;</p>
<pre><code>+ file.filter(_.contains(&quot;warn&quot;)).filter(_.contains(&quot;2013&quot;)).size)
</code></pre><h3 id="-nullexception">再见 NullException</h3>
<p>每个Java程序员都被NullException折磨过。因为Java中每个对象都可能为Null,所以要么到处检查null的问题，要么到处try/cache。
Scala提供了Option机制来解决，代码中不断检查null的问题。这个例子包装了getProperty方法，使其返回一个Option。 这样就可以不再漫无目的地null检查。只要Option类型的值即可。使用pattern match来检查是常见做法。也可以使用getOrElse来提供当为None时的默认值。给力的是Option还可以看作是最大长度为1的List，List的强大功能都可以使用。
不是每个对象都可以为Null了，只有Option可以为None。这样的做法显示区分了可能为Null的情况，可以和NullException说再见了。
def getProperty(name: String): Option[String] = {</p>
<p>  val value = System.getProperty(name)
  if (value != null) Some(value) else None</p>
<p>}</p>
<p>val osName = getProperty(&quot;os.name&quot;)</p>
<p>osName match {
  case Some(value) =&gt; println(value)</p>
<p>  case _ =&gt; println(&quot;none&quot;)
}</p>
<p>println(osName.getOrElse(&quot;none&quot;))</p>
<p>osName.foreach(print _)</p>
<h3 id="-">并行集合</h3>
<p>这个例子是访问若干URL。但确可以并行访问，比非并行的做法可以快一倍。要想让访问并行，只要调用List.par就可以了。
val urls = List(&quot;<a href="http://scala-lang.org" target="_blank">http://scala-lang.org</a>&quot;,</p>
<p>  &quot;<a href="https://github.com/yankay/scala-tour" target="_blank">https://github.com/yankay/scala-tour</a>&quot;)</p>
<p>def fromURL(url: String) = scala.io.Source.fromURL(url)
  .getLines().mkString(&quot;\n&quot;)</p>
<p>val t = System.currentTimeMillis()</p>
<p>urls.par.map(fromURL(_))
println(&quot;time: &quot; + (System.currentTimeMillis - t) + &quot;ms&quot;)</p>
<p>是不是非常的简单？并行集合支持大部分集合的功能。不增加程序复杂性，却能大幅提高并发的能力。</p>
<h3 id="-actor">远程Actor</h3>
<p>Actor是并发模型，也使用于分布式。这个例子创建一个时间服务器，通过alive来监听TCP端口，register来注册自己。调用时通过select创建client。其余使用方式和普通Actor一样。
将单机并发和分布式抽象成一种模型。简化了程序复杂性。虽然多核编程并不广泛，但调用外部接口的情况越来越多。Actor模型非常适用于这样的异步环境。
import scala.actors.remote.RemoteActor._</p>
<p>import scala.actors.Actor._
import scala.actors.remote.Node</p>
<p>val port = 31241</p>
<p>val echoServer = actor {</p>
<p>  alive(port)
  register(&#39;echoServer, self)</p>
<p>  loop {
    react {</p>
<pre><code>  case msg =&gt; {
    reply(&quot;replay &quot; + msg)

  }
}
</code></pre><p>  }
}</p>
<p>val timeServerClient = select(Node(&quot;127.0.0.1&quot;, port), &#39;echoServer)</p>
<p>timeServerClient !? &quot;hi&quot; match {</p>
<p>  case replay: String =&gt; println(replay)
}</p>
<h3 id="-">抽取器</h3>
<p>抽取器可以进行解构。这个例子是构建一个Email抽取器，只要实现unapply函数就可以了。
Scala的正则表达式会自带抽取器，可以抽取出一个List。List里的元素是匹配()里的表达式。
抽取器很有用，短短的例子里就有两处使用抽取器：</p>
<ul>
<li>通过 case user :: do main :: Nil 来解构List</li>
<li>通过 case Email(user, domain) 来解构Email。
import scala.util.matching.Regex</li>
</ul>
<p>object Email {</p>
<p>  def unapply(str: String) = new Regex(&quot;&quot;&quot;(./<em>)@(./</em>)&quot;&quot;&quot;)
    .unapplySeq(str).get match {</p>
<pre><code>case user :: domain :: Nil =&gt; Some(user, domain)
case _ =&gt; None
</code></pre><p>  }
}</p>
<p>&quot;user@domain.com&quot; match {</p>
<p>  case Email(user, domain) =&gt; println(user + &quot;@&quot; + domain)
}</p>
<h3 id="dsl">DSL</h3>
<p>DSL是Scala最强大武器，可以使一些描述性代码变得极为简单。这个例子是使用DSL生成JSON。Scala很多看似是语言级的特性也是用DSL做到的。
自己编写DSL有点复杂，但使用起来非常方便。这样可以使Scala可以嵌入XML，嵌入Json，嵌入SQL。而其他语言中这些都只是字符串而已。
import org.json4s._</p>
<p>import org.json4s.JsonDSL.<em>
import org.json4s.jackson.JsonMethods.</em></p>
<p>import java.util.Date</p>
<p>case class Twitter(id: Long, text: String, publishedAt: Option[java.util.Date])</p>
<p>var twitters = Twitter(1, &quot;hello scala&quot;, Some(new Date())) ::
  Twitter(2, &quot;I like scala tour&quot;, None) :: Nil</p>
<p>var json = (&quot;twitters&quot;</p>
<p>  -&gt; twitters.map(
    t =&gt; (&quot;id&quot; -&gt; t.id)</p>
<pre><code>  ~ (&quot;text&quot; -&gt; t.text)
  ~ (&quot;published_at&quot; -&gt; t.publishedAt.toString())))
</code></pre><p>println(pretty(render(json)))</p>
<h3 id="simple-build-tool">Simple Build Tool</h3>
<p>SBT是Scala的最佳编译工具，在他的帮助下，你甚至不需要安装除JRE外的任何东西，来开发Scala。
例如你想在自己的机器上执行<a href="http://zh.scala-tour.com/" title="scala-tour" target="_blank">Scala-Tour</a>,可以执行下面的命令
/#Linux/Mac(compile &amp; run):</p>
<p>git clone <a href="https://github.com/yankay/scala-tour-zh.git" target="_blank">https://github.com/yankay/scala-tour-zh.git</a>
cd scala-tour-zh</p>
<p>./sbt/sbt stage
./target/start</p>
<p>/#Windows(can only compile):</p>
<p>git clone <a href="https://github.com/yankay/scala-tour-zh.git" target="_blank">https://github.com/yankay/scala-tour-zh.git</a>
cd scala-tour-zh</p>
<p>sbt\sbt stage</p>
<h3 id="-">结语</h3>
<p>这几个例子精选自<a href="http://zh.scala-tour.com/" title="scala-tour" target="_blank">Scala-Tour</a>，这个网站中还有介绍了很多其他好的特性，比如模式匹配和隐式转换，就不逐一介绍了。这个项目Host在<a href="https://github.com/yankay/scala-tour/" title="GitHub" target="_blank">GitHub</a>上，如果你也有精彩的用法的话，大家交流交流吧。
Share the post &quot;Scala Tour - 精选&quot;</p>
<ul>
<li><a href="http://service.weibo.com/share/share.php?url=http%3A%2F%2Fwww.yankay.com%2Fscala-tour-choiceness%2F" title="Share this article on Weibo" target="_blank">Weibo</a></li>
</ul>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/scala/">scala</a></li></span></span> | <span class="tags">Tagged <a href="/tags/scala/" class="label label-primary">scala</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:37"datetime="2014-03-07 09:54:37"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-scala--ScalaTour/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-scala--ScalaTour" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-hadoop--hdfs_design/">hdfs_design</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:36.000Z"> <a href="/2014/02/02/2014-02-02-hadoop--hdfs_design/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="hdfs_design">hdfs_design</h1>
<p>HDFS Architecture
by Dhruba Borthakur
Table of contents
1 2
Introduction .......................................................................................................................3 Assumptions and Goals .....................................................................................................3
2.1 2.2 2.3 2.4 2.5 2.6
Hardware Failure .......................................................................................................... 3 Streaming Data Access .................................................................................................3 Large Data Sets .............................................................................................................3 Simple Coherency Model ............................................................................................. 4 “Moving Computation is Cheaper than Moving Data” ................................................4 Portability Across Heterogeneous Hardware and Software Platforms .........................4
3 4 5
NameNode and DataNodes ...............................................................................................4 The File System Namespace ............................................................................................. 5 Data Replication ................................................................................................................6
5.1 5.2 5.3
Replica Placement: The First Baby Steps .................................................................... 7 Replica Selection .......................................................................................................... 8 Safemode ...................................................................................................................... 8
6 7 8
The Persistence of File System Metadata ......................................................................... 8 The Communication Protocols ......................................................................................... 9 Robustness ........................................................................................................................ 9
8.1 8.2 8.3 8.4 8.5
Data Disk Failure, Heartbeats and Re-Replication .....................................................10 Cluster Rebalancing ....................................................................................................10 Data Integrity ..............................................................................................................10 Metadata Disk Failure ................................................................................................ 10 Snapshots ....................................................................................................................11
Copyright © 2008 The Apache Software Foundation. All rights reserved.
HDFS Architecture
9
Data Organization ........................................................................................................... 11
9.1 9.2 9.3
Data Blocks ................................................................................................................ 11 Staging ........................................................................................................................11 Replication Pipelining ................................................................................................ 12 FS Shell .....................................................................................................................12 DFSAdmin ................................................................................................................ 13 Browser Interface ......................................................................................................13 File Deletes and Undeletes ....................................................................................... 13 Decrease Replication Factor ..................................................................................... 14
10
Accessibility .................................................................................................................. 12
10.1 10.2 10.3 11
Space Reclamation ........................................................................................................ 13
11.1 11.2 12
References ..................................................................................................................... 14
Page 2
Copyright © 2008 The Apache Software Foundation. All rights reserved.
HDFS Architecture</p>
<ol>
<li>Introduction
The Hadoop Distributed File System (HDFS) is a distributed file system designed to run on commodity hardware. It has many similarities with existing distributed file systems. However, the differences from other distributed file systems are significant. HDFS is highly fault-tolerant and is designed to be deployed on low-cost hardware. HDFS provides high throughput access to application data and is suitable for applications that have large data sets. HDFS relaxes a few POSIX requirements to enable streaming access to file system data. HDFS was originally built as infrastructure for the Apache Nutch web search engine project. HDFS is part of the Apache Hadoop Core project. The project URL is <a href="http://hadoop.apache.org/core/" target="_blank">http://hadoop.apache.org/core/</a>.</li>
<li>Assumptions and Goals
2.1. Hardware Failure
Hardware failure is the norm rather than the exception. An HDFS instance may consist of hundreds or thousands of server machines, each storing part of the file system’s data. The fact that there are a huge number of components and that each component has a non-trivial probability of failure means that some component of HDFS is always non-functional. Therefore, detection of faults and quick, automatic recovery from them is a core architectural goal of HDFS.
2.2. Streaming Data Access
Applications that run on HDFS need streaming access to their data sets. They are not general purpose applications that typically run on general purpose file systems. HDFS is designed more for batch processing rather than interactive use by users. The emphasis is on high throughput of data access rather than low latency of data access. POSIX imposes many hard requirements that are not needed for applications that are targeted for HDFS. POSIX semantics in a few key areas has been traded to increase data throughput rates.
2.3. Large Data Sets
Applications that run on HDFS have large data sets. A typical file in HDFS is gigabytes to terabytes in size. Thus, HDFS is tuned to support large files. It should provide high aggregate data bandwidth and scale to hundreds of nodes in a single cluster. It should support tens of millions of files in a single instance.
Page 3
Copyright © 2008 The Apache Software Foundation. All rights reserved.
HDFS Architecture
2.4. Simple Coherency Model
HDFS applications need a write-once-read-many access model for files. A file once created, written, and closed need not be changed. This assumption simplifies data coherency issues and enables high throughput data access. A Map/Reduce application or a web crawler application fits perfectly with this model. There is a plan to support appending-writes to files in the future.
2.5. “Moving Computation is Cheaper than Moving Data”
A computation requested by an application is much more efficient if it is executed near the data it operates on. This is especially true when the size of the data set is huge. This minimizes network congestion and increases the overall throughput of the system. The assumption is that it is often better to migrate the computation closer to where the data is located rather than moving the data to where the application is running. HDFS provides interfaces for applications to move themselves closer to where the data is located.
2.6. Portability Across Heterogeneous Hardware and Software Platforms
HDFS has been designed to be easily portable from one platform to another. This facilitates widespread adoption of HDFS as a platform of choice for a large set of applications.</li>
<li>NameNode and DataNodes
HDFS has a master/slave architecture. An HDFS cluster consists of a single NameNode, a master server that manages the file system namespace and regulates access to files by clients. In addition, there are a number of DataNodes, usually one per node in the cluster, which manage storage attached to the nodes that they run on. HDFS exposes a file system namespace and allows user data to be stored in files. Internally, a file is split into one or more blocks and these blocks are stored in a set of DataNodes. The NameNode executes file system namespace operations like opening, closing, and renaming files and directories. It also determines the mapping of blocks to DataNodes. The DataNodes are responsible for serving read and write requests from the file system’s clients. The DataNodes also perform block creation, deletion, and replication upon instruction from the NameNode.
Page 4
Copyright © 2008 The Apache Software Foundation. All rights reserved.
<img src="" alt=""> HDFS Architecture
The NameNode and DataNode are pieces of software designed to run on commodity machines. These machines typically run a GNU/Linux operating system (OS). HDFS is built using the Java language; any machine that supports Java can run the NameNode or the DataNode software. Usage of the highly portable Java language means that HDFS can be deployed on a wide range of machines. A typical deployment has a dedicated machine that runs only the NameNode software. Each of the other machines in the cluster runs one instance of the DataNode software. The architecture does not preclude running multiple DataNodes on the same machine but in a real deployment that is rarely the case. The existence of a single NameNode in a cluster greatly simplifies the architecture of the system. The NameNode is the arbitrator and repository for all HDFS metadata. The system is designed in such a way that user data never flows through the NameNode.</li>
<li>The File System Namespace
HDFS supports a traditional hierarchical file organization. A user or an application can create directories and store files inside these directories. The file system namespace hierarchy is
Page 5
Copyright © 2008 The Apache Software Foundation. All rights reserved.
HDFS Architecture
similar to most other existing file systems; one can create and remove files, move a file from one directory to another, or rename a file. HDFS does not yet implement user quotas or access permissions. HDFS does not support hard links or soft links. However, the HDFS architecture does not preclude implementing these features. The NameNode maintains the file system namespace. Any change to the file system namespace or its properties is recorded by the NameNode. An application can specify the number of replicas of a file that should be maintained by HDFS. The number of copies of a file is called the replication factor of that file. This information is stored by the NameNode.</li>
<li>Data Replication
HDFS is designed to reliably store very large files across machines in a large cluster. It stores each file as a sequence of blocks; all blocks in a file except the last block are the same size. The blocks of a file are replicated for fault tolerance. The block size and replication factor are configurable per file. An application can specify the number of replicas of a file. The replication factor can be specified at file creation time and can be changed later. Files in HDFS are write-once and have strictly one writer at any time. The NameNode makes all decisions regarding replication of blocks. It periodically receives a Heartbeat and a Blockreport from each of the DataNodes in the cluster. Receipt of a Heartbeat implies that the DataNode is functioning properly. A Blockreport contains a list of all blocks on a DataNode.
Page 6
Copyright © 2008 The Apache Software Foundation. All rights reserved.
<img src="" alt=""> HDFS Architecture
5.1. Replica Placement: The First Baby Steps
The placement of replicas is critical to HDFS reliability and performance. Optimizing replica placement distinguishes HDFS from most other distributed file systems. This is a feature that needs lots of tuning and experience. The purpose of a rack-aware replica placement policy is to improve data reliability, availability, and network bandwidth utilization. The current implementation for the replica placement policy is a first effort in this direction. The short-term goals of implementing this policy are to validate it on production systems, learn more about its behavior, and build a foundation to test and research more sophisticated policies. Large HDFS instances run on a cluster of computers that commonly spread across many racks. Communication between two nodes in different racks has to go through switches. In most cases, network bandwidth between machines in the same rack is greater than network bandwidth between machines in different racks. The NameNode determines the rack id each DataNode belongs to via the process outlined in Rack Awareness. A simple but non-optimal policy is to place replicas on unique racks. This prevents losing data when an entire rack fails and allows use of bandwidth from multiple
Page 7
Copyright © 2008 The Apache Software Foundation. All rights reserved.
HDFS Architecture
racks when reading data. This policy evenly distributes replicas in the cluster which makes it easy to balance load on component failure. However, this policy increases the cost of writes because a write needs to transfer blocks to multiple racks. For the common case, when the replication factor is three, HDFS’s placement policy is to put one replica on one node in the local rack, another on a different node in the local rack, and the last on a different node in a different rack. This policy cuts the inter-rack write traffic which generally improves write performance. The chance of rack failure is far less than that of node failure; this policy does not impact data reliability and availability guarantees. However, it does reduce the aggregate network bandwidth used when reading data since a block is placed in only two unique racks rather than three. With this policy, the replicas of a file do not evenly distribute across the racks. One third of replicas are on one node, two thirds of replicas are on one rack, and the other third are evenly distributed across the remaining racks. This policy improves write performance without compromising data reliability or read performance. The current, default replica placement policy described here is a work in progress.
5.2. Replica Selection
To minimize global bandwidth consumption and read latency, HDFS tries to satisfy a read request from a replica that is closest to the reader. If there exists a replica on the same rack as the reader node, then that replica is preferred to satisfy the read request. If angg/ HDFS cluster spans multiple data centers, then a replica that is resident in the local data center is preferred over any remote replica.
5.3. Safemode
On startup, the NameNode enters a special state called Safemode. Replication of data blocks does not occur when the NameNode is in the Safemode state. The NameNode receives Heartbeat and Blockreport messages from the DataNodes. A Blockreport contains the list of data blocks that a DataNode is hosting. Each block has a specified minimum number of replicas. A block is considered safely replicated when the minimum number of replicas of that data block has checked in with the NameNode. After a configurable percentage of safely replicated data blocks checks in with the NameNode (plus an additional 30 seconds), the NameNode exits the Safemode state. It then determines the list of data blocks (if any) that still have fewer than the specified number of replicas. The NameNode then replicates these blocks to other DataNodes.</li>
<li>The Persistence of File System Metadata
Page 8
Copyright © 2008 The Apache Software Foundation. All rights reserved.
HDFS Architecture
The HDFS namespace is stored by the NameNode. The NameNode uses a transaction log called the EditLog to persistently record every change that occurs to file system metadata. For example, creating a new file in HDFS causes the NameNode to insert a record into the EditLog indicating this. Similarly, changing the replication factor of a file causes a new record to be inserted into the EditLog. The NameNode uses a file in its local host OS file system to store the EditLog. The entire file system namespace, including the mapping of blocks to files and file system properties, is stored in a file called the FsImage. The FsImage is stored as a file in the NameNode’s local file system too. The NameNode keeps an image of the entire file system namespace and file Blockmap in memory. This key metadata item is designed to be compact, such that a NameNode with 4 GB of RAM is plenty to support a huge number of files and directories. When the NameNode starts up, it reads the FsImage and EditLog from disk, applies all the transactions from the EditLog to the in-memory representation of the FsImage, and flushes out this new version into a new FsImage on disk. It can then truncate the old EditLog because its transactions have been applied to the persistent FsImage. This process is called a checkpoint. In the current implementation, a checkpoint only occurs when the NameNode starts up. Work is in progress to support periodic checkpointing in the near future. The DataNode stores HDFS data in files in its local file system. The DataNode has no knowledge about HDFS files. It stores each block of HDFS data in a separate file in its local file system. The DataNode does not create all files in the same directory. Instead, it uses a heuristic to determine the optimal number of files per directory and creates subdirectories appropriately. It is not optimal to create all local files in the same directory because the local file system might not be able to efficiently support a huge number of files in a single directory. When a DataNode starts up, it scans through its local file system, generates a list of all HDFS data blocks that correspond to each of these local files and sends this report to the NameNode: this is the Blockreport.</li>
<li>The Communication Protocols
All HDFS communication protocols are layered on top of the TCP/IP protocol. A client establishes a connection to a configurable TCP port on the NameNode machine. It talks the ClientProtocol with the NameNode. The DataNodes talk to the NameNode using the DataNode Protocol. A Remote Procedure Call (RPC) abstraction wraps both the Client Protocol and the DataNode Protocol. By design, the NameNode never initiates any RPCs. Instead, it only responds to RPC requests issued by DataNodes or clients.</li>
<li>Robustness
The primary objective of HDFS is to store data reliably even in the presence of failures. The
Page 9
Copyright © 2008 The Apache Software Foundation. All rights reserved.
HDFS Architecture
three common types of failures are NameNode failures, DataNode failures and network partitions.
8.1. Data Disk Failure, Heartbeats and Re-Replication
Each DataNode sends a Heartbeat message to the NameNode periodically. A network partition can cause a subset of DataNodes to lose connectivity with the NameNode. The NameNode detects this condition by the absence of a Heartbeat message. The NameNode marks DataNodes without recent Heartbeats as dead and does not forward any new IO requests to them. Any data that was registered to a dead DataNode is not available to HDFS any more. DataNode death may cause the replication factor of some blocks to fall below their specified value. The NameNode constantly tracks which blocks need to be replicated and initiates replication whenever necessary. The necessity for re-replication may arise due to many reasons: a DataNode may become unavailable, a replica may become corrupted, a hard disk on a DataNode may fail, or the replication factor of a file may be increased.
8.2. Cluster Rebalancing
The HDFS architecture is compatible with data rebalancing schemes. A scheme might automatically move data from one DataNode to another if the free space on a DataNode falls below a certain threshold. In the event of a sudden high demand for a particular file, a scheme might dynamically create additional replicas and rebalance other data in the cluster. These types of data rebalancing schemes are not yet implemented.
8.3. Data Integrity
It is possible that a block of data fetched from a DataNode arrives corrupted. This corruption can occur because of faults in a storage device, network faults, or buggy software. The HDFS client software implements checksum checking on the contents of HDFS files. When a client creates an HDFS file, it computes a checksum of each block of the file and stores these checksums in a separate hidden file in the same HDFS namespace. When a client retrieves file contents it verifies that the data it received from each DataNode matches the checksum stored in the associated checksum file. If not, then the client can opt to retrieve that block from another DataNode that has a replica of that block.
8.4. Metadata Disk Failure
The FsImage and the EditLog are central data structures of HDFS. A corruption of these files can cause the HDFS instance to be non-functional. For this reason, the NameNode can be configured to support maintaining multiple copies of the FsImage and EditLog. Any update
Page 10
Copyright © 2008 The Apache Software Foundation. All rights reserved.
HDFS Architecture
to either the FsImage or EditLog causes each of the FsImages and EditLogs to get updated synchronously. This synchronous updating of multiple copies of the FsImage and EditLog may degrade the rate of namespace transactions per second that a NameNode can support. However, this degradation is acceptable because even though HDFS applications are very data intensive in nature, they are not metadata intensive. When a NameNode restarts, it selects the latest consistent FsImage and EditLog to use. The NameNode machine is a single point of failure for an HDFS cluster. If the NameNode machine fails, manual intervention is necessary. Currently, automatic restart and failover of the NameNode software to another machine is not supported.
8.5. Snapshots
Snapshots support storing a copy of data at a particular instant of time. One usage of the snapshot feature may be to roll back a corrupted HDFS instance to a previously known good point in time. HDFS does not currently support snapshots but will in a future release.</li>
<li>Data Organization
9.1. Data Blocks
HDFS is designed to support very large files. Applications that are compatible with HDFS are those that deal with large data sets. These applications write their data only once but they read it one or more times and require these reads to be satisfied at streaming speeds. HDFS supports write-once-read-many semantics on files. A typical block size used by HDFS is 64 MB. Thus, an HDFS file is chopped up into 64 MB chunks, and if possible, each chunk will reside on a different DataNode.
9.2. Staging
A client request to create a file does not reach the NameNode immediately. In fact, initially the HDFS client caches the file data into a temporary local file. Application writes are transparently redirected to this temporary local file. When the local file accumulates data worth over one HDFS block size, the client contacts the NameNode. The NameNode inserts the file name into the file system hierarchy and allocates a data block for it. The NameNode responds to the client request with the identity of the DataNode and the destination data block. Then the client flushes the block of data from the local temporary file to the specified DataNode. When a file is closed, the remaining un-flushed data in the temporary local file is transferred to the DataNode. The client then tells the NameNode that the file is closed. At this point, the NameNode commits the file creation operation into a persistent store. If the
Page 11
Copyright © 2008 The Apache Software Foundation. All rights reserved.
HDFS Architecture
NameNode dies before the file is closed, the file is lost. The above approach has been adopted after careful consideration of target applications that run on HDFS. These applications need streaming writes to files. If a client writes to a remote file directly without any client side buffering, the network speed and the congestion in the network impacts throughput considerably. This approach is not without precedent. Earlier distributed file systems, e.g. AFS, have used client side caching to improve performance. A POSIX requirement has been relaxed to achieve higher performance of data uploads.
9.3. Replication Pipelining
When a client is writing data to an HDFS file, its data is first written to a local file as explained in the previous section. Suppose the HDFS file has a replication factor of three. When the local file accumulates a full block of user data, the client retrieves a list of DataNodes from the NameNode. This list contains the DataNodes that will host a replica of that block. The client then flushes the data block to the first DataNode. The first DataNode starts receiving the data in small portions (4 KB), writes each portion to its local repository and transfers that portion to the second DataNode in the list. The second DataNode, in turn starts receiving each portion of the data block, writes that portion to its repository and then flushes that portion to the third DataNode. Finally, the third DataNode writes the data to its local repository. Thus, a DataNode can be receiving data from the previous one in the pipeline and at the same time forwarding data to the next one in the pipeline. Thus, the data is pipelined from one DataNode to the next.</li>
<li>Accessibility
HDFS can be accessed from applications in many different ways. Natively, HDFS provides a FileSystem Java API for applications to use. A C language wrapper for this Java API is also available. In addition, an HTTP browser can also be used to browse the files of an HDFS instance. Work is in progress to expose HDFS through the WebDAV protocol.
10.1. FS Shell
HDFS allows user data to be organized in the form of files and directories. It provides a commandline interface called FS shell that lets a user interact with the data in HDFS. The syntax of this command set is similar to other shells (e.g. bash, csh) that users are already familiar with. Here are some sample action/command pairs:
Action Create a directory named /foodir Command bin/hadoop dfs -mkdir /foodir
Page 12
Copyright © 2008 The Apache Software Foundation. All rights reserved.
HDFS Architecture
Remove a directory named /foodir View the contents of a file named /foodir/myfile.txt
bin/hadoop dfs -rmr /foodir bin/hadoop dfs -cat /foodir/myfile.txt
FS shell is targeted for applications that need a scripting language to interact with the stored data.
10.2. DFSAdmin
The DFSAdmin command set is used for administering an HDFS cluster. These are commands that are used only by an HDFS administrator. Here are some sample action/command pairs:
Action Put the cluster in Safemode Generate a list of DataNodes Recommission or decommission DataNode(s) Command bin/hadoop dfsadmin -safemode enter bin/hadoop dfsadmin -report bin/hadoop dfsadmin -refreshNodes
10.3. Browser Interface
A typical HDFS install configures a web server to expose the HDFS namespace through a configurable TCP port. This allows a user to navigate the HDFS namespace and view the contents of its files using a web browser.</li>
<li>Space Reclamation
11.1. File Deletes and Undeletes
When a file is deleted by a user or an application, it is not immediately removed from HDFS. Instead, HDFS first renames it to a file in the /trash directory. The file can be restored quickly as long as it remains in /trash. A file remains in /trash for a configurable amount of time. After the expiry of its life in /trash, the NameNode deletes the file from the HDFS namespace. The deletion of a file causes the blocks associated with the file to be freed. Note that there could be an appreciable time delay between the time a file is deleted by a user and the time of the corresponding increase in free space in HDFS. A user can Undelete a file after deleting it as long as it remains in the /trash directory. If a user wants to undelete a file that he/she has deleted, he/she can navigate the /trash directory and retrieve the file. The /trash directory contains only the latest copy of the file
Page 13
Copyright © 2008 The Apache Software Foundation. All rights reserved.
HDFS Architecture
that was deleted. The /trash directory is just like any other directory with one special feature: HDFS applies specified policies to automatically delete files from this directory. The current default policy is to delete files from /trash that are more than 6 hours old. In the future, this policy will be configurable through a well defined interface.
11.2. Decrease Replication Factor
When the replication factor of a file is reduced, the NameNode selects excess replicas that can be deleted. The next Heartbeat transfers this information to the DataNode. The DataNode then removes the corresponding blocks and the corresponding free space appears in the cluster. Once again, there might be a time delay between the completion of the setReplication API call and the appearance of free space in the cluster.</li>
<li>References
Hadoop JavaDoc API. HDFS source code: <a href="http://hadoop.apache.org/core/version_control.html" target="_blank">http://hadoop.apache.org/core/version_control.html</a>
Page 14
Copyright © 2008 The Apache Software Foundation. All rights reserved.</li>
</ol>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/hadoop/">hadoop</a></li></span></span> | <span class="tags">Tagged <a href="/tags/hadoop/" class="label label-primary">hadoop</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:36"datetime="2014-03-07 09:54:36"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-hadoop--hdfs_design/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-hadoop--hdfs_design" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-hadoop--hadoop/">hadoop</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:36.000Z"> <a href="/2014/02/02/2014-02-02-hadoop--hadoop/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="hadoop">hadoop</h1>
<p><img src="" alt=""></p>
<h1 id="hadoop">hadoop</h1>
<h2 id="table-of-contents">Table of Contents</h2>
<ul>
<li><p><a href="http://dirlt.com/hadoop.html#sec-1" target="_blank">1 hadoop</a></p>
</li>
<li><p><a href="http://dirlt.com/hadoop.html#sec-1-1" target="_blank">1.1 FAQ</a></p>
</li>
<li><p><a href="http://dirlt.com/hadoop.html#sec-1-1-1" target="_blank">1.1.1 Hadoop可以用来做什么</a></p>
</li>
<li><a href="http://dirlt.com/hadoop.html#sec-1-1-2" target="_blank">1.1.2 Hadoop包括哪些组件</a></li>
<li><a href="http://dirlt.com/hadoop.html#sec-1-1-3" target="_blank">1.1.3 CDH和Apache Hadoop的关系</a></li>
<li><a href="http://dirlt.com/hadoop.html#sec-1-1-4" target="_blank">1.1.4 CDH产品组件构成</a></li>
<li><p><a href="http://dirlt.com/hadoop.html#sec-1-1-5" target="_blank">1.1.5 CDH产品组件端口分布和配置</a></p>
</li>
<li><p><a href="http://dirlt.com/hadoop.html#sec-1-1-5-1" target="_blank">1.1.5.1 Hadoop HDFS</a></p>
</li>
<li><a href="http://dirlt.com/hadoop.html#sec-1-1-5-2" target="_blank">1.1.5.2 Hadoop MRv1</a></li>
<li><a href="http://dirlt.com/hadoop.html#sec-1-1-5-3" target="_blank">1.1.5.3 Hadoop YARN</a></li>
<li><a href="http://dirlt.com/hadoop.html#sec-1-1-5-4" target="_blank">1.1.5.4 HBase</a></li>
<li><a href="http://dirlt.com/hadoop.html#sec-1-1-5-5" target="_blank">1.1.5.5 Hive</a></li>
<li><a href="http://dirlt.com/hadoop.html#sec-1-1-5-6" target="_blank">1.1.5.6 Sqoop</a></li>
<li><a href="http://dirlt.com/hadoop.html#sec-1-1-5-7" target="_blank">1.1.5.7 Zookeeper</a></li>
<li><a href="http://dirlt.com/hadoop.html#sec-1-1-5-8" target="_blank">1.1.5.8 Hue</a></li>
<li><a href="http://dirlt.com/hadoop.html#sec-1-1-5-9" target="_blank">1.1.5.9 Ozzie</a></li>
<li><a href="http://dirlt.com/hadoop.html#sec-1-1-5-10" target="_blank">1.1.5.10 Ganglia</a></li>
<li><a href="http://dirlt.com/hadoop.html#sec-1-1-5-11" target="_blank">1.1.5.11 Kerberos</a></li>
<li><p><a href="http://dirlt.com/hadoop.html#sec-1-2" target="_blank">1.2 观点</a></p>
</li>
<li><p><a href="http://dirlt.com/hadoop.html#sec-1-2-1" target="_blank">1.2.1 Hadoop即将过时了吗？</a></p>
</li>
<li><a href="http://dirlt.com/hadoop.html#sec-1-2-2" target="_blank">1.2.2 Best Practices for Selecting Apache Hadoop Hardware</a></li>
<li><a href="http://dirlt.com/hadoop.html#sec-1-2-3" target="_blank">1.2.3 The dark side of Hadoop - BackType Technology</a></li>
<li><p><a href="http://dirlt.com/hadoop.html#sec-1-3" target="_blank">1.3 使用问题</a></p>
</li>
<li><p><a href="http://dirlt.com/hadoop.html#sec-1-3-1" target="_blank">1.3.1 CDH3u3搭建单节点集群</a></p>
</li>
<li><a href="http://dirlt.com/hadoop.html#sec-1-3-2" target="_blank">1.3.2 CDH4.2.0搭建单节点集群</a></li>
<li><a href="http://dirlt.com/hadoop.html#sec-1-3-3" target="_blank">1.3.3 CDH4.3.0</a></li>
<li><p><a href="http://dirlt.com/hadoop.html#sec-1-3-4" target="_blank">1.3.4 Configuration</a></p>
</li>
<li><p><a href="http://dirlt.com/hadoop.html#sec-1-3-4-1" target="_blank">1.3.4.1 .bash_profile</a></p>
</li>
<li><a href="http://dirlt.com/hadoop.html#sec-1-3-4-2" target="_blank">1.3.4.2 core-site.xml</a></li>
<li><a href="http://dirlt.com/hadoop.html#sec-1-3-4-3" target="_blank">1.3.4.3 hdfs-site.xml</a></li>
<li><a href="http://dirlt.com/hadoop.html#sec-1-3-4-4" target="_blank">1.3.4.4 mapred-site.xml</a></li>
<li><a href="http://dirlt.com/hadoop.html#sec-1-3-4-5" target="_blank">1.3.4.5 hadoop-env.sh</a></li>
<li><a href="http://dirlt.com/hadoop.html#sec-1-3-4-6" target="_blank">1.3.4.6 hbase-site.xml</a></li>
<li><a href="http://dirlt.com/hadoop.html#sec-1-3-4-7" target="_blank">1.3.4.7 hbase-env.sh</a></li>
<li><p><a href="http://dirlt.com/hadoop.html#sec-1-4" target="_blank">1.4 Hadoop权威指南</a></p>
</li>
<li><p><a href="http://dirlt.com/hadoop.html#sec-1-4-1" target="_blank">1.4.1 初识Hadoop</a></p>
</li>
<li><a href="http://dirlt.com/hadoop.html#sec-1-4-2" target="_blank">1.4.2 关于MapReduce</a></li>
<li><a href="http://dirlt.com/hadoop.html#sec-1-4-3" target="_blank">1.4.3 Hadoop分布式文件系统</a></li>
<li><a href="http://dirlt.com/hadoop.html#sec-1-4-4" target="_blank">1.4.4 Hadoop IO</a></li>
<li><a href="http://dirlt.com/hadoop.html#sec-1-4-5" target="_blank">1.4.5 MapReduce应用开发</a></li>
<li><a href="http://dirlt.com/hadoop.html#sec-1-4-6" target="_blank">1.4.6 MapReduce的工作机制</a></li>
<li><a href="http://dirlt.com/hadoop.html#sec-1-4-7" target="_blank">1.4.7 MapReduce的类型与格式</a></li>
<li><a href="http://dirlt.com/hadoop.html#sec-1-4-8" target="_blank">1.4.8 MapReduce的特性</a></li>
<li><a href="http://dirlt.com/hadoop.html#sec-1-4-9" target="_blank">1.4.9 构建Hadoop集群</a></li>
<li><a href="http://dirlt.com/hadoop.html#sec-1-4-10" target="_blank">1.4.10 管理Hadoop</a></li>
<li><p><a href="http://dirlt.com/hadoop.html#sec-1-5" target="_blank">1.5 Benchmark</a></p>
</li>
<li><p><a href="http://dirlt.com/hadoop.html#sec-1-5-1" target="_blank">1.5.1 TestDFSIO</a></p>
</li>
<li><a href="http://dirlt.com/hadoop.html#sec-1-5-2" target="_blank">1.5.2 TeraSort</a></li>
<li><a href="http://dirlt.com/hadoop.html#sec-1-5-3" target="_blank">1.5.3 nnbench</a></li>
<li><a href="http://dirlt.com/hadoop.html#sec-1-5-4" target="_blank">1.5.4 mrbench</a></li>
<li><a href="http://dirlt.com/hadoop.html#sec-1-5-5" target="_blank">1.5.5 hbase.PerformanceEvaluation</a></li>
</ul>
<h2 id="1-hadoop">1 hadoop</h2>
<p>参考资源</p>
<ul>
<li>Cloudera <a href="http://www.cloudera.com/" target="_blank"><a href="http://www.cloudera.com/">http://www.cloudera.com/</a></a></li>
<li>Apache Hadoop <a href="http://hadoop.apache.org/" target="_blank"><a href="http://hadoop.apache.org/">http://hadoop.apache.org/</a></a></li>
<li>Apache Hadoop r1.0.3 文档 <a href="http://hadoop.apache.org/common/docs/r1.0.3/" target="_blank"><a href="http://hadoop.apache.org/common/docs/r1.0.3/">http://hadoop.apache.org/common/docs/r1.0.3/</a></a></li>
<li>Apache Hadoop r1.0.3 中文文档 <a href="http://hadoop.apache.org/common/docs/r1.0.3/cn" target="_blank"><a href="http://hadoop.apache.org/common/docs/r1.0.3/cn">http://hadoop.apache.org/common/docs/r1.0.3/cn</a></a></li>
<li>CDH Downloads <a href="https://ccp.cloudera.com/display/SUPPORT/Downloads" target="_blank"><a href="https://ccp.cloudera.com/display/SUPPORT/Downloads">https://ccp.cloudera.com/display/SUPPORT/Downloads</a></a></li>
<li>CDH Documentation <a href="https://ccp.cloudera.com/display/DOC/Documentation" target="_blank"><a href="https://ccp.cloudera.com/display/DOC/Documentation">https://ccp.cloudera.com/display/DOC/Documentation</a></a></li>
<li>CDH Tutorial <a href="https://ccp.cloudera.com/display/SUPPORT/Hadoop+Tutorial" target="_blank"><a href="https://ccp.cloudera.com/display/SUPPORT/Hadoop+Tutorial">https://ccp.cloudera.com/display/SUPPORT/Hadoop+Tutorial</a></a></li>
</ul>
<h3 id="1-1-faq">1.1 FAQ</h3>
<h3 id="1-1-1-hadoop-">1.1.1 Hadoop可以用来做什么</h3>
<p>Why Hadoop? <a href="http://www.cloudera.com/why-hadoop/" target="_blank"><a href="http://www.cloudera.com/why-hadoop/">http://www.cloudera.com/why-hadoop/</a></a></p>
<p>TODO(dirlt):translate it!!!</p>
<p>Simply put, Hadoop can transform the way you store and process data throughout your enterprise. According to analysts, about 80% of the data in the world is unstructured, and until Hadoop, it was essentially unusable in any systematic way. With Hadoop, for the first time you can combine all your data and look at it as one.</p>
<ul>
<li>Make All Your Data Profitable. Hadoop enables you to gain insight from all the data you already have; to ingest the data flowing into your systems 24/7 and leverage it to make optimizations that were impossible before; to make decisions based on hard data, not hunches; to look at complete data, not samples; to look at years of transactions, not days or weeks. In short, Hadoop will change the way you run your organization.</li>
<li>Leverage All Types of Data, From All Types of Systems. Hadoop can handle all types of data from disparate systems: structured, unstructured, log files, pictures, audio files, communications records, email– just about anything you can think of. Even when different types of data have been stored in unrelated systems, you can dump it all into your Hadoop cluster before you even know how you might take advantage of it in the future.</li>
<li>Scale Beyond Anything You Have Today. The largest social network in the world is built on the same open-source technology as Hadoop, and now exceeds 100 petabytes. It’s unlikely your organization has that much data. As you need more capacity, you just add more commodity servers and Hadoop automatically incorporates the new storage and compute capacity.</li>
</ul>
<h3 id="1-1-2-hadoop-">1.1.2 Hadoop包括哪些组件</h3>
<p>TODO(dirlt):translate it!!!</p>
<p>Apache Hadoop包括了下面这些组件：</p>
<ul>
<li><a href="http://hadoop.apache.org/common/" target="_blank">Hadoop Common</a> The common utilities that support the other Hadoop subprojects.</li>
<li><a href="http://hadoop.apache.org/hdfs/" target="_blank">Hadoop Distributed File System(HDFS)</a> A distributed file system that provides high-throughput access to application data.</li>
<li><a href="http://hadoop.apache.org/mapreduce/" target="_blank">Hadoop MapReduce</a> A software framework for distributed processing of large data sets on compute clusters.</li>
</ul>
<p>和Apache Hadoop相关的组件有：</p>
<ul>
<li><a href="http://avro.apache.org/" target="_blank">Avro</a> A data serialization system.</li>
<li><a href="http://cassandra.apache.org/" target="_blank">Cassandra</a> A scalable multi-master database with no single points of failure.</li>
<li><a href="http://incubator.apache.org/chukwa/" target="_blank">Chukwa</a> A data collection system for managing large distributed systems.</li>
<li><a href="http://hbase.apache.org/" target="_blank">HBase</a> A scalable, distributed database that supports structured data storage for large tables.</li>
<li><a href="http://hive.apache.org/" target="_blank">Hive</a> A data warehouse infrastructure that provides data summarization and ad hoc querying.</li>
<li><a href="http://mahout.apache.org/" target="_blank">Mahout</a> A Scalable machine learning and data mining library.</li>
<li><a href="http://pig.apache.org/" target="_blank">Pig</a> A high-level data-flow language and execution framework for parallel computation.</li>
<li><a href="http://zookeeper.apache.org/" target="_blank">ZooKeeper</a> A high-performance coordination service for distributed applications.<h3 id="1-1-3-cdh-apache-hadoop-">1.1.3 CDH和Apache Hadoop的关系</h3>
</li>
</ul>
<p>CDH Hadoop FAQ <a href="https://ccp.cloudera.com/display/SUPPORT/Hadoop+FAQ" target="_blank"><a href="https://ccp.cloudera.com/display/SUPPORT/Hadoop+FAQ">https://ccp.cloudera.com/display/SUPPORT/Hadoop+FAQ</a></a></p>
<p>TODO(dirlt):translate it!!!</p>
<ul>
<li>What exactly is included in CDH? / Cloudera&#39;s Distribution Including Apache Hadoop (CDH) is a certified release of Apache Hadoop. We include some stable patches scheduled to be included in future releases, as well as some patches we have developed for our supported customers, and are in the process of contributing back to Apache.</li>
<li>What license is Cloudera&#39;s Distribution Including Apache Hadoop released under? / Just like Hadoop, Cloudera&#39;s Distribution Including Apache Hadoop is released under the Apache Public License version 2.</li>
<li>Is Cloudera forking Hadoop? / Absolutely not. Cloudera is committed to the Hadoop project and the principles of the Apache Software License and Foundation. We continue to work actively with current releases of Hadoop and deliver certified releases to the community as appropriate.</li>
<li>Does Cloudera contribute their changes back to Apache? / We do, and will continue to contribute all eligible changes back to Apache. We occasionally release code we know to be stable even if our contribution to Apache is still in progress. Some of our changes are not eligible for contribution, as they capture the Cloudera brand, or link to our tools and documentation, but these do not affect compatibility with core project.</li>
</ul>
<h3 id="1-1-4-cdh-">1.1.4 CDH产品组件构成</h3>
<p><a href="http://www.cloudera.com/content/cloudera/en/products/cdh.html" target="_blank"><a href="http://www.cloudera.com/content/cloudera/en/products/cdh.html">http://www.cloudera.com/content/cloudera/en/products/cdh.html</a></a></p>
<p>从这里可以下载CDH4组件 <a href="http://www.cloudera.com/content/cloudera-content/cloudera-docs/CDHTarballs/3.25.2013/CDH4-Downloadable-Tarballs/CDH4-Downloadable-Tarballs.html" target="_blank"><a href="http://www.cloudera.com/content/cloudera-content/cloudera-docs/CDHTarballs/3.25.2013/CDH4-Downloadable-Tarballs/CDH4-Downloadable-Tarballs.html">http://www.cloudera.com/content/cloudera-content/cloudera-docs/CDHTarballs/3.25.2013/CDH4-Downloadable-Tarballs/CDH4-Downloadable-Tarballs.html</a></a></p>
<p><img src="" alt="./images/cloudera-enterprise-diagram.png"></p>
<h3 id="1-1-5-cdh-">1.1.5 CDH产品组件端口分布和配置</h3>
<p>The CDH4 components, and third parties such as Kerberos, use the ports listed in the tables that follow. Before you deploy CDH4, make sure these ports are open on each system.</p>
<h3 id="1-1-5-1-hadoop-hdfs">1.1.5.1 Hadoop HDFS</h3>
<p>ServiceQualifierPortProtocolAccess RequirementConfigurationCommentDataNode50010TCPExternaldfs.datanode.addressDataNode HTTP server portDataNodeSecure1004TCPExternaldfs.datanode.addressDataNode50075TCPExternaldfs.datanode.http.addressDataNodeSecure1006TCPExternaldfs.datanode.http.addressDataNode50020TCPExternaldfs.datanode.ipc.addressNameNode8020TCPExternalfs.default.name or fs.defaultFSfs.default.name is deprecated (but still works)NameNode50070TCPExternaldfs.http.address or dfs.namenode.http-addressdfs.http.address is deprecated (but still works)NameNodeSecure50470TCPExternaldfs.https.address or dfs.namenode.https-addressdfs.https.address is deprecated (but still works)Sec NameNode50090TCPInternaldfs.secondary.http.address or dfs.namenode.secondary.http-addressdfs.secondary.http.address is deprecated (but still works)Sec NameNodeSecure50495TCPInternaldfs.secondary.https.addressJournalNode8485TCPInternaldfs.namenode.shared.edits.dirJournalNode8480TCPInternal</p>
<h3 id="1-1-5-2-hadoop-mrv1">1.1.5.2 Hadoop MRv1</h3>
<p>ServiceQualifierPortProtocolAccess RequirementConfigurationCommentJobTracker8021TCPExternalmapred.job.trackerJobTracker50030TCPExternalmapred.job.tracker.http.addressJobTrackerThrift Plugin9290TCPInternaljobtracker.thrift.addressRequired by Hue and Cloudera Manager Activity MonitorTaskTracker50060TCPExternalmapred.task.tracker.http.addressTaskTracker0TCPLocalhostmapred.task.tracker.report.addressCommunicating with child (umbilical)</p>
<h3 id="1-1-5-3-hadoop-yarn">1.1.5.3 Hadoop YARN</h3>
<p>ServiceQualifierPortProtocolAccess RequirementConfigurationCommentResourceManager8032TCPyarn.resourcemanager.addressResourceManager8030TCPyarn.resourcemanager.scheduler.addressResourceManager8031TCPyarn.resourcemanager.resource-tracker.addressResourceManager8033TCPyarn.resourcemanager.admin.addressResourceManager8088TCPyarn.resourcemanager.webapp.addressNodeManager8040TCPyarn.nodemanager.localizer.addressNodeManager8042TCPyarn.nodemanager.webapp.addressNodeManager8041TCPyarn.nodemanager.addressMapReduce JobHistory Server10020TCPmapreduce.jobhistory.addressMapReduce JobHistory Server19888TCPmapreduce.jobhistory.webapp.address</p>
<h3 id="1-1-5-4-hbase">1.1.5.4 HBase</h3>
<p>ServiceQualifierPortProtocolAccess RequirementConfigurationCommentMaster60000TCPExternalhbase.master.portIPCMaster60010TCPExternalhbase.master.info.portHTTPRegionServer60020TCPExternalhbase.regionserver.portIPCRegionServer60030TCPExternalhbase.regionserver.info.portHTTPHQuorumPeer2181TCPhbase.zookeeper.property.clientPortHBase-managed ZK modeHQuorumPeer2888TCPhbase.zookeeper.peerportHBase-managed ZK modeHQuorumPeer3888TCPhbase.zookeeper.leaderportHBase-managed ZK modeRESTREST Service8080TCPExternalhbase.rest.portThriftServerThrift Server9090TCPExternalPass -p <port> on CLIAvro server9090TCPExternalPass –port <port> on CLI</p>
<h3 id="1-1-5-5-hive">1.1.5.5 Hive</h3>
<p>ServiceQualifierPortProtocolAccess RequirementConfigurationCommentMetastore9083TCPExternalHiveServer10000TCPExternal</p>
<h3 id="1-1-5-6-sqoop">1.1.5.6 Sqoop</h3>
<p>ServiceQualifierPortProtocolAccess RequirementConfigurationCommentMetastore16000TCPExternalsqoop.metastore.server.portSqoop 2 server12000TCPExternal</p>
<h3 id="1-1-5-7-zookeeper">1.1.5.7 Zookeeper</h3>
<p>ServiceQualifierPortProtocolAccess RequirementConfigurationCommentServer (with CDH4 and/or Cloudera Manager 4)2181TCPExternalclientPortClient portServer (with CDH4 only)2888TCPInternalX in server.N=host:X:YPeerServer (with CDH4 only)3888TCPInternalY in server.N=host:X:YPeerServer (with CDH4 and Cloudera Manager 4)3181TCPInternalX in server.N=host:X:YPeerServer (with CDH4 and Cloudera Manager 4)4181TCPInternalY in server.N=host:X:YPeerZooKeeper FailoverController (ZKFC)8019TCPInternalUsed for HAZooKeeper JMX port9010TCPInternal</p>
<p>As JMX port, ZooKeeper will also use another randomly selected port for RMI. In order for Cloudera Manager to monitor ZooKeeper, you must open up all ports when the connection originates from the Cloudera Manager server.</p>
<h3 id="1-1-5-8-hue">1.1.5.8 Hue</h3>
<p>ServiceQualifierPortProtocolAccess RequirementConfigurationCommentServer8888TCPExternalBeeswax Server8002InternalBeeswax Metastore8003Internal</p>
<h3 id="1-1-5-9-ozzie">1.1.5.9 Ozzie</h3>
<p>ServiceQualifierPortProtocolAccess RequirementConfigurationCommentOozie Server11000TCPExternalOOZIE_HTTP_PORT in oozie-env.shHTTPOozie Server11001TCPlocalhostOOZIE_ADMIN_PORT in oozie-env.shShutdown port</p>
<h3 id="1-1-5-10-ganglia">1.1.5.10 Ganglia</h3>
<p>ServiceQualifierPortProtocolAccess RequirementConfigurationCommentganglia-gmond8649UDP/TCPInternalganglia-web80TCPExternalVia Apache httpd</p>
<h3 id="1-1-5-11-kerberos">1.1.5.11 Kerberos</h3>
<p>ServiceQualifierPortProtocolAccess RequirementConfigurationCommentKRB5 KDC ServerSecure88UDP/TCPExternalkdc_ports and kdc_tcp_ports in either the [kdcdefaults] or [realms] sections of kdc.confBy default only UDPKRB5 Admin ServerSecure749TCPInternalkadmind_port in the [realms] section of kdc.conf</p>
<h3 id="1-2-">1.2 观点</h3>
<h3 id="1-2-1-hadoop-">1.2.1 Hadoop即将过时了吗？</h3>
<p><a href="http://www.kuqin.com/database/20120715/322528.html" target="_blank"><a href="http://www.kuqin.com/database/20120715/322528.html">http://www.kuqin.com/database/20120715/322528.html</a></a></p>
<p>google提出的三个东西都是解决hadoop的软肋，最终目的还是需要解决大数据上面的实时性问题。</p>
<ul>
<li>增量索引过滤器（Percolator for incremental indexing）和频繁变化数据集分析。Hadoop是一台大型“机器”，当启动并全速运转时处理数据的性能惊人，你唯一需要操心的就是硬盘的传输速度跟不上。但是每次你准备启动分析数据时，都需要把所有的数据都过一遍，当数据集越来越庞大时，这个问题将导致分析时间无限延长。那么Google是如何解决让搜索结果返回速度越来越接近实时的呢？答案是用增量处理引擎Percolator代替GMR。通过只处理新增的、改动过的或删除的文档和使用二级指数来高效率建目录，返回查询结果。Percolator论文的作者写道：“将索引系统转换成增量系统…将文档处理延迟缩短了100倍。”这意味着索引web新内容的速度比用MapReduce快100倍！类似大型强子对撞机产生的数据将不断变大，Twitter也是如此。这也是为什么HBase中会新增触发流程，而Twitter Storm正在成为实时处理流数据的热门技术。</li>
<li>用于点对点分析的Dremel。Google和Hadoop生态系统都致力于让MapReduce成为可用的点对点分析工具。从Sawzall到Pig和Hive，创建了大量的界面层，但是尽管这让Hadoop看上去更像SQL系统，但是人们忘记了一个基本事实——MapReduce(以及Hadoop)是为组织数据处理任务开发的系统，诞生于工作流内核，而不是点对点分析。今天有大量的BI/分析查询都是点对点模式，属于互动和低延迟的分析。Hadoop的Map和Reduce工作流让很多分析师望而却步，而且工作启动和完成工作流运行的漫长周期对于很多互动性分析来说意味着糟糕的用户体验。于是，Google发明了Dremel（业界也称之为BigQuery产品）专用工具，可以让分析师数秒钟内就扫描成PB（Petabyte）的数据完成点到点查询，而且还能支持可视化。Google在Dremel的论文中声称：“Dremel能够在数秒内完成数万亿行数据的聚合查询，比MapReduce快上100倍！”</li>
<li>分析图数据的Pregel。Google MapReduce的设计初衷是分析世界上最大的数据图谱——互联网。但是在分析人际网络、电信设备、文档和其他一些图数据时就没有那么灵光了，例如MapReduce在计算单源最短路径（SSSP）时效率非常低下，已有的并行图算法库Parallel BGL或者CGMgraph又没有容错。于是Google开发了Pregel，一个可以在分布式通用服务器上处理PB级别图数据的大型同步处理应用。与Hadoop经常在处理图数据时产生指数级数据放大相比，Pregel能够自然高效地处理SSSP或PageRank等图算法，所用时间要短得多，代码也简洁得多。目前唯一能与Pregel媲美的开源选择是Giraph，这是一个早期的Apache孵化项目，调用了HDFS和Zookeeper。Githb上还有一个项目Golden Orb可用。</li>
</ul>
<h3 id="1-2-2-best-practices-for-selecting-apache-hadoop-hardware">1.2.2 Best Practices for Selecting Apache Hadoop Hardware</h3>
<p><a href="http://hortonworks.com/blog/best-practices-for-selecting-apache-hadoop-hardware/" target="_blank"><a href="http://hortonworks.com/blog/best-practices-for-selecting-apache-hadoop-hardware/">http://hortonworks.com/blog/best-practices-for-selecting-apache-hadoop-hardware/</a></a></p>
<p>RAID cards, redundant power supplies and other per-component reliability features are not needed. Buy error-correcting RAM and SATA drives with good MTBF numbers. Good RAM allows you to trust the quality of your computations. Hard drives are the largest source of failures, so buy decent ones.（不需要选购RAID，冗余电源或者是一些满足高可靠性组件，但是选择带有ECC的RAM以及good MTBF的SATA硬盘却是非常需要的。ECC RAM可以让你确保计算结果的正确性，而SATA故障是大部分故障的主要原因）</p>
<ul>
<li>On CPU: It helps to understand your workload, but for most systems I recommend sticking with medium clock speeds and no more than 2 sockets. Both your upfront costs and power costs rise quickly on the high-end. For many workloads, the extra performance per node is not cost-effective.（没有特别要求，普通频率，dual-socket？？？）</li>
<li>On Power: Power is a major concern when designing Hadoop clusters. It is worth understanding how much power the systems you are buying use and not buying the biggest and fastest nodes on the market.In years past we saw huge savings in pricing and significant power savings by avoiding the fastest CPUs, not buying redundant power supplies, etc. Nowadays, vendors are building machines for cloud data centers that are designed to reduce cost and power and that exclude a lot of the niceties that bulk up traditional servers. Spermicro, Dell and HP all have such product lines for cloud providers, so if you are buying in large volume, it is worth looking for stripped-down cloud servers. （根据自己的需要尽量减少能耗开销，撇去一些不需要的部件。而且现在很多厂商也在尽量减少不必要的部件）</li>
<li>On RAM: What you need to consider is the amount of RAM needed to keep the processors busy and where the knee in the cost curve resides. Right now 48GB seems like a pretty good number. You can get this much RAM at commodity prices on low-end server motherboards. This is enough to provide the Hadoop framework with lots of RAM (~4 GB) and still have plenty to run many processes. Don’t worry too much about RAM, you’ll find a use for it, often running more processes in parallel. If you don’t, the system will still use it to good effect, caching disk data and improving performance.（RAM方面的话越大越好，对于48GB的RAM来说普通的主板也是支持的。如果RAM用的上的话那么允许多个进程并行执行，如果暂时永不上的话可以做cache来提高速度）</li>
<li>On Disk: Look to buy high-capacity SATA drives, usually 7200RPM. Hadoop is storage hungry and seek efficient but it does not require fast, expensive hard drives. Keep in mind that with 12-drive systems you are generally getting 24 or 36 TB/node. Until recently, putting this much storage in a node was not practical because, in large clusters, disk failures are a regular occurrence and replicating 24+TB could swamp the network for long enough to really disrupt work and cause jobs to miss SLAs. The most recent release of Hadoop 0.20.204 is engineered to handle the failure of drives more elegantly, allowing machines to continue serving from their remaining drives. With these changes, we expect to see a lot of 12+ drive systems. In general, add disks for storage and not seeks. If your workload does not require huge amounts of storage, dropping disk count to 6 or 4 per box is a reasonable way to economize.（高容量SATA硬盘，最好是7.2KRPM，并且最好单机上面挂在12个硬盘。对于hadoop之前这种方式并不实际，因为磁盘非常容易损坏并且备份这24TB的数据非常耗时。而hadoop可以很好地解决这个问题。</li>
</ul>
<p>小集群来说的话，通常单个机器上面挂在4-6个disk即可）</p>
<ul>
<li>On Network: This is the hardest variable to nail down. Hadoop workloads vary a lot. The key is to buy enough network capacity to allow all nodes in your cluster to communicate with each other at reasonable speeds and for reasonable cost. For smaller clusters, I’d recommend at least 1GB all-to-all bandwidth, which is easily achieved by just connecting all of your nodes to a good switch. With larger clusters this is still a good target although based on workload you can probably go lower. In the very large data centers the Yahoo! built, they are seeing 2/<em>10GB per 20 node rack going up to a pair of central switches, with rack nodes connected with two 1GB links. As a rule of thumb, watch the ratio of network-to-computer cost and aim for network cost being somewhere around 20% of your total cost. Network costs should include your complete network, core switches, rack switches, any network cards needed, etc. We’ve been seeing InfiniBand and 10GB Ethernet networks to the node now. If you can build this cost effectively, that’s great. However, keep in mind that Hadoop grew up with commodity Ethernet, so understand your workload requirements before spending too much on the network.（这个主要还是看需求。通常来说网络整体开销占据所有开销的20%，包括核心交换机，机架之间的交换机以及网卡设备等。yahoo大集群的部署方式是rack之间使用2/</em>10GB的核心交换机工作，而20个节点的rack之间内部使用1GB链路）。<h3 id="1-2-3-the-dark-side-of-hadoop-backtype-technology">1.2.3 The dark side of Hadoop - BackType Technology</h3>
</li>
</ul>
<p><a href="http://web.archive.org/web/20110510125644/http://tech.backtype.com/the-dark-side-of-hadoop" target="_blank"><a href="http://web.archive.org/web/20110510125644/http://tech.backtype.com/the-dark-side-of-hadoop">http://web.archive.org/web/20110510125644/http://tech.backtype.com/the-dark-side-of-hadoop</a></a></p>
<p>谈到了一些在使用hadoop出现的一些问题，而这些问题是hadoop本身的。</p>
<ul>
<li>Critical configuration poorly documented 一些关键的参数和配置并没有很好地说明清楚。</li>
<li><p>Terrible with memory usage 内存使用上面存在问题。hadoop里面有一些非常sloppy的实现，比如chmod以及ln -s等操作，并没有调用fs API而是直接创建一个shell进程来完成。因为fork出一个shell进程需要申请同样大小的内存（虽然实现上是COW），但是这样造成jvm出现oom。解决的办法是开辟一定空间的swap The solution to these memory problems is to allocate a healthy amount of swap space for each machine to protect you from these memory glitches. We couldn&#39;t believe how much more stable everything became when we added swap space to our worker machines.</p>
</li>
<li><p>Thomas Jungblut&#39;s Blog: Dealing with &quot;OutOfMemoryError&quot; in Hadoop <a href="http://codingwiththomas.blogspot.jp/2011/07/dealing-with-outofmemoryerror-in-hadoop.html" target="_blank"><a href="http://codingwiththomas.blogspot.jp/2011/07/dealing-with-outofmemoryerror-in-hadoop.html">http://codingwiththomas.blogspot.jp/2011/07/dealing-with-outofmemoryerror-in-hadoop.html</a></a> 作者给出的解决办法就是修改hadoop的代码，通过调用Java API而不是使用ProcessBuilder来解决。</p>
</li>
<li><strong>NOTE(dirlt):出现OOM的话必须区分JVM还是Linux System本身的OOM。JVM出现OOM是抛出异常，而Linux出现OOM是会触发OOM killer</strong></li>
<li>Zombies hadoop集群出现一些zombie进程，而这些进程会一直持有内存直到大量zombie进程存在最后需要重启。造成这些zombie进程的原因通常是因为jvm oom（增加了swap之后就没有出现这个问题了），但是奇怪的是tasktracker作为这些process的parent，并不负责cleanup这些zombie进程而是依赖这些zombie进程的自己退出，这就是hadoop设计方面的问题。</li>
</ul>
<p>Making Hadoop easy to deploy, use, and operate should be the /#1 priority for the developers of Hadoop.</p>
<h3 id="1-3-">1.3 使用问题</h3>
<h3 id="1-3-1-cdh3u3-">1.3.1 CDH3u3搭建单节点集群</h3>
<p>搭建单节点集群允许我们在单机做一些模拟或者是测试，还是非常有意义的。如何操作的话可以参考链接 <a href="http://localhost/utils/hadoop-0.20.2-cdh3u3/docs/single_node_setup.html" target="_blank"><a href="http://localhost/utils/hadoop-0.20.2-cdh3u3/docs/single_node_setup.html">http://localhost/utils/hadoop-0.20.2-cdh3u3/docs/single_node_setup.html</a></a></p>
<p>这里稍微总结一下：</p>
<ul>
<li>首先安装ssh和rsync /# sudo apt-get install ssh &amp;&amp; sudo apt-get install rsync</li>
<li>本机建立好信任关系 /# cat ~/.ssh/id_dsa.pub &gt;&gt; ~/.ssh/authorized_keys</li>
<li>将{hadoop-package}/conf配置文件修改如下：</li>
<li><p>conf/core-site.xml</p>
<configuration>

   <property>
       <name>fs.default.name</name>

       <value>hdfs://localhost:9000</value>
   </property>

</li>
</ul>
<p></configuration></p>
<ul>
<li><p>conf/hdfs-site.xml</p>
<configuration>

   <property>
       <name>dfs.replication</name>

       <value>1</value>
   </property>

</li>
</ul>
<p></configuration></p>
<ul>
<li><p>conf/mapred-site.xml</p>
<configuration>

   <property>
       <name>mapred.job.tracker</name>

       <value>localhost:9001</value>
   </property>

</li>
</ul>
<p></configuration></p>
<ul>
<li>格式化namenode /# bin/hadoop namenode -format</li>
<li>启动hadoop集群 /# bin/start-all.sh</li>
<li>停止hadoop集群 /# bin/stop-all.sh</li>
<li><p>webconsole</p>
</li>
<li><p>NameNode - <a href="http://localhost:50070/" target="_blank"><a href="http://localhost:50070/">http://localhost:50070/</a></a></p>
</li>
<li>JobTracker - <a href="http://localhost:50030/" target="_blank"><a href="http://localhost:50030/">http://localhost:50030/</a></a></li>
</ul>
<h3 id="1-3-2-cdh4-2-0-">1.3.2 CDH4.2.0搭建单节点集群</h3>
<p>基本流程和CDH3u3是相同的，但是有一些差异我记录下来。</p>
<ul>
<li><p>配置文件</p>
</li>
<li><p>配置文件在etc/hadoop，包括环境配置脚本比如hadoop-env.sh</p>
</li>
<li>bin/sbin目录下面有hadoop集群启动停止工具 <strong>NOTE（dirlt）：不要使用它们</strong></li>
<li>libexec目录下面是公用的配置脚本</li>
<li>mapred-site.xml中jobtracker地址配置key修改为 mapred.jobtracker.address <strong>NOTE(dirlt):this for yarn.如果是mr1那么不用修改,依然是mapred.job.tracker</strong></li>
<li>hadoop-daemons.sh会使用/sbin/slaves.sh来在各个节点启动，但是 /<em>不知道什么原因，很多环境变量没有设置/</em> ，所以在slaves.sh执行ssh命令部分最开始增加了 source ~/.shrc; 来强制设置我的环境变量</li>
<li><strong>NOTE(dirlt):不要使用shell脚本来启动，而是直接使用类似hadoop namenode这种方式来启动单个机器上的实例</strong></li>
<li><p>公共组件</p>
</li>
<li><p>CDH4.2.0 native-library都放在了目录lib/native下面，而不是CDH3u3的lib/native/Linux-amd64-64下面，这点需要注意。</p>
</li>
<li>CDH4.2.0 没有自带libhadoop.so, 所以启动的时候都会出现 ”Unable to load native-hadoop library for your platform… using builtin-java classes where applicable“ 这个警告。需要自己编译放到lib/native目录下面。</li>
<li>CDH4.2.0 lib下面没有任何文件，所有的lib都在share/hadoop//*/lib下面，比如share/hadoop/common/lib. 这点和CDH3有差别，CDH3所有的jar都放在lib目录下面。使用 hadoop classpath 命令可以察看</li>
<li><p>环境变量</p>
</li>
<li><p>JAVA_LIBRARY_PATH用来设置native library path</p>
</li>
<li>HADOOP_CLASSPATH可以用来设置hadoop相关的classpath（比如使用hadoop-lzo等）</li>
<li><p>准备工作</p>
</li>
<li><p>使用hdfs namenode -format来做格式化 <strong>注意如果使用sudo apt-get来安装的话，是其他用户比如hdfs,impala,mapred,yarn来启动的，所以必须确保目录对于这些用户是可写的</strong></p>
</li>
<li>使用命令 hadoop org/apache/hadoop/examples/QuasiMonteCarlo 1 1 确定集群是否可以正常运行。<h3 id="1-3-3-cdh4-3-0">1.3.3 CDH4.3.0</h3>
</li>
</ul>
<p>基本流程和CDH4.2.0是相同的，但是存在一些差异我记录下来的。从4.3.0开始将mr1和mr2分开存放，还是一个比较大的区别的。这里我以使用mr1为例。</p>
<ul>
<li>在libexec/hadoop-config.sh添加source ~/.shrc 来强制设置环境变量。</li>
<li><p>mr1和mr2分开存放主要有</p>
</li>
<li><p>etc目录，hadoop and hadoop-mapreduce1</p>
</li>
<li>bin目录，bin and bin-mapreduce1</li>
<li><p>lib目录。如果需要使用mr1的话，那么将cp -r share/hadoop/mapreduce1/ .</p>
</li>
<li><p><strong>NOTE（dirlt）：似乎只需要最顶层的一些jar文件即可</strong></p>
</li>
<li>在bin/hadoop-config.sh添加source ~/.shrc 来强制设置环境变量。</li>
<li><strong>NOTE（dirlt）：不要使用start-dfs.sh这些脚本启动，似乎这些脚本会去读取master,slaves这些文件然后逐个上去ssh启动。直接使用hadoop namenode这种方式可以只启动单个机器上的实例</strong></li>
</ul>
<h3 id="1-3-4-configuration">1.3.4 Configuration</h3>
<h3 id="1-3-4-1-bash_profile">1.3.4.1 .bash_profile</h3>
<p>export HADOOP_HOME=$HOME/dirlt/hadoop-2.0.0-cdh4.3.0/</p>
<p>export HADOOP_CONF_DIR=$HADOOP_HOME/etc/hadoop
export HBASE_HOME=/home/alium_zhanyinan/dirlt/hbase-0.94.6-cdh4.3.0</p>
<p>export HBASE_CLASSPATH=$HBASE_HOME/hbase-0.94.6-cdh4.3.0-security.jar:$HBASE_HOME/conf
export ZK_HOME=/home/alium_zhanyinan/dirlt/zookeeper-3.4.5-cdh4.3.0</p>
<p>export ZK_CLASSPATH=$ZK_HOME/zookeeper-3.4.5-cdh4.3.0.jar
export HADOOP_CLASSPATH=$HADOOP_CLASSPATH:$HBASE_CLASSPATH:$ZK_CLASSPATH</p>
<p>export JAVA_HOME=/usr/java/default/</p>
<h3 id="1-3-4-2-core-site-xml">1.3.4.2 core-site.xml</h3>
<configuration>

  <property>
    <name>fs.default.name</name>

    <value>hdfs://umengds1.mob.cm3:8020</value>
  </property>


  <property>

    <name>fs.trash.interval</name>
    <value>1440</value>

  </property>
</configuration>


<h3 id="1-3-4-3-hdfs-site-xml">1.3.4.3 hdfs-site.xml</h3>
<configuration>

  <property>
    <name>dfs.name.dir</name>

    <value>/disk1/data/dfs/nn</value>
  </property>


  <property>

    <name>dfs.data.dir</name>
    <value>/disk1/data/dfs/dn</value>

  </property>


  <property>
    <name>fs.checkpoint.dir</name>

    <value>/disk1/data/dfs/snn</value>
  </property>


  <property>

    <name>dfs.replication</name>
    <value>3</value>

  </property>


  <property>
    <name>dfs.block.size</name>

    <value>134217728</value>
  </property>


  <property>

    <name>dfs.datanode.max.xcievers</name>
    <value>8192</value>

  </property>


  <property>
    <name>dfs.datanode.du.reserved</name>

    <value>21474836480</value>
  </property>


  <property>

    <name>dfs.namenode.handler.count</name>
    <value>64</value>

  </property>


  <property>
    <name>dfs.datanode.handler.count</name>

    <value>32</value>
  </property>


  <property>

    <name>dfs.client.read.shortcircuit</name>
    <value>true</value>

  </property>
</configuration>



<h3 id="1-3-4-4-mapred-site-xml">1.3.4.4 mapred-site.xml</h3>
<configuration>

  <property>
    <name>mapred.job.tracker</name>

    <value>umengds2.mob.cm3:8021</value>
  </property>


  <property>

    <name>mapred.system.dir</name>
    <value>/tmp/mapred/system</value>

  </property>


  <property>
    <name>mapreduce.jobtracker.staging.root.dir</name>

    <value>/user</value>
  </property>


  <property>

    <name>mapred.local.dir</name>
    <value>/disk1/data/mapred/local</value>

  </property>


  <property>
    <name>mapred.submit.replication</name>

    <value>3</value>
    <final>true</final>

  </property>


  <property>
    <name>mapred.tasktracker.map.tasks.maximum</name>

    <value>6</value>
  </property>

  <property>
    <name>mapred.tasktracker.reduce.tasks.maximum</name>

    <value>8</value>
  </property>


  <property>

    <name>mapred.child.java.opts</name>
    <value> -Xmx2048M -XX:-UseGCOverheadLimit</value>

  </property>


  <property>
    <name>mapred.job.tracker.handler.count</name>

    <value>64</value>
  </property>


  <property>

    <name>io.sort.mb</name>
    <value>256</value>

  </property>


  <property>
    <name>io.sort.factor</name>

    <value>64</value>
  </property>

</configuration>

<h3 id="1-3-4-5-hadoop-env-sh">1.3.4.5 hadoop-env.sh</h3>
<p>/# The maximum amount of heap to use, in MB. Default is 1000.</p>
<p>export HADOOP_HEAPSIZE=6000</p>
<p>/# Extra Java runtime options. Empty by default.
/# if [&quot;$HADOOP_OPTS&quot; == &quot;&quot; ]; then export HADOOP_OPTS=-server; else HADOOP_OPTS+=&quot; -server&quot;</p>
<p>; fi</p>
<p>/# Command specific options appended to HADOOP_OPTS when specified
export HADOOP_NAMENODE_OPTS=&quot;-Xmx12000m $HADOOP_NAMENODE_OPTS&quot;export HADOOP_SECONDARYNAMENODE_OPTS=&quot;-Xmx12000m $HADOOP_SECONDARYNAMENODE_OPTS&quot;export HADOOP_DATANODE_OPTS=&quot;-Xmx6000m $HADOOP_DATANODE_OPTS&quot;export HADOOP_BALANCER_OPTS=&quot;-Xmx3000m $HADOOP_BALANCER_OPTS&quot;export HADOOP_JOBTRACKER_OPTS=&quot;-Xmx12000m $HADOOP_JOBTRACKER_OPTS&quot;</p>
<h3 id="1-3-4-6-hbase-site-xml">1.3.4.6 hbase-site.xml</h3>
<configuration>

  <property>
    <name>hbase.cluster.distributed</name>

    <value>true</value>
  </property>


  <property>

    <name>hbase.rootdir</name>
    <value>hdfs://umengds1.mob.cm3:8020/hbase</value>

  </property>


  <property>
    <name>hbase.zookeeper.quorum</name>

    <value>umengds1.mob.cm3,umengds2.mob.cm3</value>
  </property>


  <property>

    <name>hbase.hregion.memstore.mslab.enabled</name>
    <value>true</value>

  </property>


  <property>
    <name>hbase.regionserver.handler.count</name>

    <value>128</value>
  </property>


  <property>

    <name>hbase.client.write.buffer</name>
    <value>4194304</value>

  </property>


  <property>
    <name>hbase.hregion.memstore.block.multiplier</name>

    <value>8</value>
  </property>


  <property>

    <name>hbase.server.thread.wakefrequency</name>
    <value>1000</value>

  </property>


  <property>
    <name>hbase.regionserver.lease.period</name>

    <value>600000</value>
  </property>


  <property>

    <name>hbase.hstore.blockingStoreFiles</name>
    <value>15</value>

  </property>


  <property>
    <name>hbase.hregion.max.filesize</name>

    <value>2147483648</value>
  </property>


  <property>

    <name>hbase.ipc.client.tcpnodelay</name>
    <value>true</value>

  </property>


  <property>
    <name>ipc.ping.interval</name>

    <value>10000</value>
  </property>


  <property>

    <name>hbase.hregion.majorcompaction</name>
    <value>0</value>

  </property>


  <property>
    <name>hbase.regionserver.checksum.verify</name>

    <value>true</value>
  </property>

</configuration>

<h3 id="1-3-4-7-hbase-env-sh">1.3.4.7 hbase-env.sh</h3>
<p>/# The maximum amount of heap to use, in MB. Default is 1000.</p>
<p>export HBASE_HEAPSIZE=14000</p>
<p>/# Extra Java runtime options.
/# Below are what we set by default. May only work with SUN JVM.</p>
<p>/# For more on why as well as other possible settings,
/# see <a href="http://wiki.apache.org/hadoop/PerformanceTuning" target="_blank">http://wiki.apache.org/hadoop/PerformanceTuning</a></p>
<p>/# export HBASE_OPTS=
&quot;-ea -XX:+UseConcMarkSweepGC -XX:+CMSIncrementalMode&quot;export HBASE_OPTS=&quot;-ea -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:+UseCMSCompactAtFullCollection -XX:CMSInitiatingOccupancyFraction=90&quot;</p>
<h3 id="1-4-hadoop-">1.4 Hadoop权威指南</h3>
<h3 id="1-4-1-hadoop">1.4.1 初识Hadoop</h3>
<p>古代，人们用牛来拉中午，当一头牛拉不动一根圆木的时候，他们不曾想过培育更大更壮的牛。同样，我们也不需要尝试开发超级计算机，而应试着结合使用更多计算机系统。</p>
<h3 id="1-4-2-mapreduce">1.4.2 关于MapReduce</h3>
<ul>
<li>设置HADOOP_CLASSPATH就可以直接使用hadoop CLASSNAME来在本地运行mapreduce程序。</li>
<li><p>hadoop jar $HADOOP_HOME/contrib/streaming/hadoop-streaming-0.20.2-cdh3u3.jar 可以用来启动streaming任务</p>
</li>
<li><p>使用stdin/stdout来作为输入和输出</p>
</li>
<li><p><strong>NOTE（dirlt）：倒是可以探索一下如何使用，但是觉得能力有限</strong></p>
</li>
<li><p>Input/Output Format</p>
</li>
<li>外围环境的访问比如访问hdfs以及hbase</li>
<li>程序打包。比如使用很多第三方库的话在其他机器上面没有部署。</li>
<li><p>hadoop pipes 可以用来启动pipes任务</p>
</li>
<li><p>Hadoop的Pipes是Hadoop MapReduce的C++接口代称</p>
</li>
<li>使用Unix Domain Socket来作为输入和输出</li>
<li><p><strong>NOTE（dirlt）：可能使用上面还是没有native mr或者是streaming方式方便</strong></p>
<h3 id="1-4-3-hadoop-">1.4.3 Hadoop分布式文件系统</h3>
</li>
<li><p>使用hadoop archive能够将大量小文档打包，存档文件之能够只读访问</p>
</li>
<li><p>使用hadoop archive -archiveName <file>.har -p <parent-path> src dst</p>
</li>
<li><p>存档过程使用mapreduce完成，输出结果为目录</p>
</li>
<li><p>part-0 表示存档内容文件，应该是使用一个reduce做聚合。</p>
</li>
<li>_index,_masterindex 是对存档内容文件的索引文件。</li>
<li><p>har(hadoop archive)文件系统是建立在其他文件系统上面的，比如hdfs或者是local fs.</p>
</li>
<li><p>hadoop fs -ls har:///file.har 那么访问的是默认的文件系统上面的file.har</p>
</li>
<li>如果想显示地访问hdfs文件系统的话，那么可以hadoop fs -ls har://hdfs-localhost:9000/file.har</li>
<li>如果想显示地访问本地文件系统的话，那么可以使用hadoop fs -ls har://file-localhost/file.har</li>
<li>hadoop fs -ls har://schema-<host>/<path> 是通用的访问方式</li>
</ul>
<h3 id="1-4-4-hadoop-io">1.4.4 Hadoop IO</h3>
<ul>
<li><p>文件系统</p>
</li>
<li><p>ChecksumFileSystem</p>
</li>
<li><p>使用decorator设计模式，底层filesystem称为RawFileSystem</p>
</li>
<li>对于每个文件filename都会创建.filename.crc文件存储校验和</li>
<li>计算crc的单位大小通过io.bytes.per.checksum来进行控制</li>
<li>读取文件如果出现错误的话，那么会抛出ChecksumException</li>
<li><p>考虑到存在多副本的情况，如果读取某个副本出错的话，期间那么会调用reportChecksumFailure方法</p>
</li>
<li><p><strong>NOTE（dirlt）：这个部分的代码不太好读，非常绕</strong></p>
</li>
<li><p>RawLocalFileSystem</p>
</li>
<li><p>本地文件系统</p>
</li>
<li><p>LocalFileSystem</p>
</li>
<li><p>RawLocalFileSystem + ChecksumFileSystem</p>
</li>
<li>reportChecksumFailure实现为将校验和存在问题的文件移动到bad_files边际文件夹（side directory）</li>
<li><p>DistributedFileSystem</p>
</li>
<li><p>分布式文件系统</p>
</li>
<li><p>ChecksumDistributedFileSystem</p>
</li>
<li><p>DistributedFileSystem + ChecksumFileSystem</p>
</li>
<li><p>压缩解压</p>
</li>
<li><p>DEFLATE org.apache.hadoop.io.compress.DefaultCodec 扩展名.defalte</p>
</li>
<li>Gzip org.apache.hadoop.io.compress.GzipCodec 扩展名.gz 使用DEFLATE算法但是增加了额外的文件头。</li>
<li>bzip2 org.apache.hadoop.io.compress.BZip2Codec 扩展名.bz2 自身支持文件切分，内置同步点。</li>
<li><p>LZO com.hadoop.compression.lzo.LzopCodec 扩展名.lzo 和lzop工具兼容，LZO算法增加了额外的文件头。</p>
</li>
<li><p>LzopCodec则是纯lzo格式的codec,使用.lzo_deflate作为文件扩展名</p>
</li>
<li>因为LZO代码库拥有GPL许可，因此没有办法包含在Apache的发行版本里面。</li>
<li><p>运行MapReduce时候可能需要针对不同压缩文件解压读取，就需要构造CompressionCodec对象，我们可以通过CompressionCodecFactory来构造这个对象</p>
</li>
<li><p>CompressionCodecFactory读取变量io.compression.codecs</p>
</li>
<li>然后根据输入文件的扩展名来选择使用何种codec.</li>
<li>getDefaultExtension</li>
<li><p>压缩和解压算法可能同时存在Java实现和原生实现</p>
</li>
<li><p>如果是原生实现的话通常是.so，那么需要设置java.library.path或者是在环境变量里面设置LD_LIBRARY_PATH</p>
</li>
<li>如果同时有原生实现和Java实现，我们想只是使用原生实现的话，那么可以设置hadoop.native.lib = false来禁用原生实现。</li>
<li><p>压缩算法涉及到对应的InputFormat,也就涉及到是否支持切分</p>
</li>
<li><p>对于一些不支持切分的文件，可能存在一些外部工具来建立索引，从而支持切分。</p>
</li>
<li><p>下面这些选项可以针对map结果以及mapreduce结果进行压缩</p>
</li>
<li><p>mapred.output.compress = true 将mapreduce结果做压缩</p>
</li>
<li>mapred.output.compression.codec mapreduce压缩格式</li>
<li>mapred.output.compress.type = BLOCK/RECORD 如果输出格式为SequenceFile的话，那么这个参数可以控制是块压缩还是记录压缩</li>
<li><strong>NOTE（dirlt）：我现在强烈感觉MR的中间结果存储格式为SequenceFile</strong></li>
<li><strong>NOTE（dirlt）：应该是IFile，但是是否共享了这个配置呢？</strong></li>
<li>mapred.compress.map.output = true 将map结果做压缩</li>
<li><p>mapred.map.output.compression.codec map压缩格式</p>
</li>
<li><p>序列化</p>
</li>
<li><p>Hadoop的序列化都是基于Writable实现的，WritableComparable则是同时继承Writable,Comparable<T>.</p>
</li>
<li><p>序列化对象需要实现RawComparator，接口为public int compare(byte[] b1, int s1, int l1, byte[] b2, int s2, int l2)进行二进制比较。</p>
</li>
<li><p>WritableComparator简化了这个实现，继承WritableComparator就实现了这个接口</p>
</li>
<li>但是这个接口实现起来非常naive，就是将两个byte stream反序列化然后调用对象的compareTo实现</li>
<li>如果想要提高效率的话，可以考虑通过直接比较两个byte stream来做优化。</li>
<li><p>基于文件的数据结构</p>
</li>
<li><p>SequenceFile 主要用来存储KV数据结构，多条记录之间会穿插一些同步标记，因此允许进行切分。</p>
</li>
<li><p>使用SequenceFileInputFormat和SequenceFileOutputFormat来读取和输出SequenceFile</p>
</li>
<li>hadoop fs -text 可以用来读取文件</li>
<li><p>mapred.output.compress.type = BLOCK/RECORD 可以用来控制压缩方式</p>
</li>
<li><p>如果没有使用压缩的话，那么格式为 recordLength(4byte) + keyLength(4byte) + key + value</p>
</li>
<li>如果使用记录压缩的话，那么格式为 recordLnegth(4byte) + keyLength(4byte) + key + compressedValue</li>
<li>如果使用块压缩的话，那么格式为 numberRecord(1-5byte) + keyLength(4byte) + compressedKeys + valueLength(4byte) + compressedValues.每个block之间会插入sync标记</li>
<li>块压缩大小可以使用io.seqfile.compress.blocksize来控制，默认1MB</li>
<li><p>MapFile 也是用来存储KV数据结构，但是可以认为已经按照了Key进行排序 <strong>NOTE（dirlt）：要求添加顺序就按照Key排序</strong></p>
</li>
<li><p>存储格式实际上也是SequenceFile，data，index都是。</p>
</li>
<li>底层会建立index，index在搜索的时候会加载到内存里面，这样可以减少data上的随机查询次数。</li>
<li>使用io.map.index.interval可以控制多少个item在index里面创建一个条目</li>
<li>使用io.map.index.skip = 0/1/2/n 可以控制skip几个index的item，如果为1的话那么表示只是使用1/2的索引。</li>
<li><p>从SequenceFile创建MapFile非常简单</p>
</li>
<li><p>首先使用sort将SequenceFile进行排序(可以使用hadoop example的sort）</p>
</li>
<li><p>然后调用hadoop MapFileFixer来建立索引</p>
<h3 id="1-4-5-mapreduce-">1.4.5 MapReduce应用开发</h3>
</li>
<li><p>Configuration用来读取配置文件，功能还是比较强大的，有变量替换的功能</p>
</li>
<li><property><name>…</name><value>…</value></property></li>
<li>如果使用<final>true</final>标记的话那么这个变量不允许被重置</li>
<li>变量替换可以使用${variable}</li>
<li><p>通过addResource来添加读取的配置文件</p>
</li>
<li><p>Hadoop集群有三种工作方式，分别为</p>
</li>
<li><p>standalone 使用单个JVM进程来模拟</p>
</li>
<li><p>如果不进行任何配置的话默认使用这个模式 <strong>NOTE（dirlt）：这个模式确实不错</strong></p>
</li>
<li>fs.default.name = file 本地文件系统</li>
<li>mapred.job.tracker = local</li>
<li><p>pseudo-distributed 本地启动单节点集群</p>
</li>
<li><p>fs.default.name = hdfs://localhost</p>
</li>
<li>mapred.job.tracker = localhost:8021</li>
<li><p>fully-distributed 完全分布式环境</p>
</li>
<li><p>fs.default.name = hdfs://<namenode></p>
</li>
<li><p>mapred.job.tracer = <jobtracker>:8021</p>
</li>
<li><p>使用hadoop启动MapReduce任务的常用参数</p>
</li>
</ul>
<ol>
<li>-D property=value 覆盖默认配置属性</li>
<li>-conf filename 添加配置文件</li>
<li>-fs uri 设置默认文件系统</li>
<li>-jt host:port 设置jobtracker</li>
<li>-files file,file2 这些文件可以在tasktracker工作目录下面访问</li>
<li>-archives archive,archive2 和files类似，但是是存档文件</li>
</ol>
<ul>
<li>突然觉得这个差别在files只能是平级结构，而archive可以是层级结构。</li>
<li>-libjars jar1,jar2 和files类似，通常这些JAR文件是MapReduce所需要的。</li>
</ul>
<p>如果希望运行时候动态创建集群的话，可以通过这几个类来创建</p>
<ul>
<li>MiniDFSCluster</li>
<li>MiniMRCluster</li>
<li>MiniHBaseCluster</li>
<li>MiniZooKeeperClutser</li>
<li><strong>NOTE(dirlt):都称为Mini???Cluster？</strong></li>
</ul>
<p>另外还有自带的ClusterMapReduceTestCase以及HBaseTestingUtility来帮助进行mapreduce的testcase. 这些类散步在hadoop,hbase,hadoop-test以及hbase-test里面。</p>
<p><strong>NOTE（dirlt）：但是个人觉得可能还是没有本地测试方便，不过倒是可以试试</strong></p>
<p>job，task and attempt</p>
<ul>
<li><p>jobID常见格式为 job_200904110811_0002</p>
</li>
<li><p>其中200904110811表示jobtracker从2009.04.11的08:11启动的</p>
</li>
<li>0002 表示第三个job,从0000开始计数。超过10000的话就不能够很好地排序</li>
<li><p>taskID常见格式为 task_200904110811_0002_m_000003</p>
</li>
<li><p>前面一串数字和jobID匹配，表示从属于这个job</p>
</li>
<li>m表示map任务，r表示reduce任务</li>
<li>000003表示这是第4个map任务。顺序是在初始化时候指定的，并不反应具体的执行顺序。</li>
<li><p>attemptID常见格式为 attempt_200904110811_0002_m_000003_0</p>
</li>
<li><p>前面一串数字和taskID匹配，表示从属与这个task</p>
</li>
<li>attempt出现的原因是因为一个task可能会因为失败重启或者是预测执行而执行多次</li>
<li>如果jobtracker重启而导致作业重启的话，那么做后面id从1000开始避免和原来的attempt冲突。</li>
</ul>
<p>作业调试</p>
<ul>
<li><p>相关配置</p>
</li>
<li><p>mapred.jobtracker.completeuserjobs.maximum 表示web页面下面展示completed jobs的个数，默认是100，超过的部分放到历史信息页。</p>
</li>
<li>mapred.jobtracker.restart.recover = true jobtracker重启之后自动恢复作业</li>
<li>hadoop.job.history.location 历史作业信息存放位置，超过30天删除，默认在_logs/history</li>
<li>hadoop.job.history.user.location 如果不为none那么历史作业信息在这里也会存在一份，不会删除。</li>
<li><p>相关命令</p>
</li>
<li><p>hadoop fs -getmerge <src> <dst> 能够将hdfs的src下面所有的文件merge合并成为一份文件并且copy到本地</p>
</li>
<li>hadoop job -history 察看作业历史</li>
<li>hadoop job -counter 察看作业计数器</li>
<li><p>相关日志</p>
</li>
<li><p>系统守护进程日志 写入HADOOP_LOG_DIR里面，可以用来监控namenode以及datanode的运行情况</p>
</li>
<li>MapReduce作业历史日志 _logs/history</li>
<li>MapReduce任务日志 写入HADOOP_LOG_DIR/userlogs里面，可以用来监控每个job的运行情况</li>
<li><p>分析任务</p>
</li>
<li><p>JobConf允许设置profile参数 <strong>NOTE（dirlt）：新的接口里面JobConf-&gt;JobContext-&gt;Job，Job没有这些接口，但是可以通过Configuration来设置</strong></p>
</li>
<li><p>setProfileEnabled 打开profile功能，默认false，属性 mapred.task.profile</p>
</li>
<li><p>setProfileParams 设置profile参数</p>
</li>
<li><p>属性 mapred.task.profile.params</p>
</li>
<li>默认使用hprof -agentlib:hprof=cpu=samples,heap=sites,force=n,thread=y,verbose=n,file=%s&quot;</li>
<li>其中%s会替换成为profile输出文件</li>
<li><strong>NOTE（dirlt）：其实这里似乎也可以设置成为jmxremote来通过jvisualvm来调试</strong></li>
<li><p>setProfileTaskRange(boolean,String)</p>
</li>
<li><p>参数1表示针对map还是reduce task做profile, true表示map, false表示reduce</p>
</li>
<li>参数2表示针对哪些tasks做优化，&quot;0-2&quot;表示针对0，1，2三个任务，默认也是&quot;0-2&quot;</li>
<li>map task对应属性mapred.task.profile.maps，reduce task对应属性mapred.task.profile.reduces</li>
<li><p>任务重现</p>
</li>
<li><p>首先将keep.failed.task.files设置为true,这样如果任务失败的话，那么这个任务的输入和输出都会保留下来</p>
</li>
<li><p>如果是map任务的话，那么输入分别会在本地保留</p>
</li>
<li>如果是reduce任务的话，那么对应的map任务输出会在本地保留</li>
<li>然后我们使用hadoop IsolationRunner job.xml来重新运行这个任务</li>
<li>可以修改HADOOP_OPTS添加远程调试选项来启动这个任务。</li>
<li>如果希望任务都保留而不仅仅是失败任务保留的话，那么可以设置 keep.task.files.pattern 为正则表达式（与保留的任务ID匹配）</li>
</ul>
<h3 id="1-4-6-mapreduce-">1.4.6 MapReduce的工作机制</h3>
<p>Hadoop运行MapReduce作业的工作原理</p>
<p><img src="" alt="./images/mapreduce-workflow-architecture.png"></p>
<p>其中有几点需要注意的：</p>
<ul>
<li>计算分片信息是在本地完成的，分片信息和其他resouce(包括jars,files,archives等）一起copy到HDFS上面，然后jobtracker直接读取分片信息。</li>
<li>提交的资源可以设置replication数目，高副本数目可以缓解tasktracker获取resource的压力。参数是mapred.submit.replication.</li>
<li>对于streaming以及pipes的实现，无非就是task并不直接执行任务，而是开辟另外一个子进程来运行streaming或者是pipes的程序。</li>
</ul>
<p><img src="" alt="./images/mapreduce-streamming-pipes.jpg"></p>
<p>进度和状态的更新</p>
<ul>
<li>map任务进度是已经处理输入的比例</li>
<li><p>reduce任务进度分为三个部分</p>
</li>
<li><p>shuffle 1/3</p>
</li>
<li>sort 1/3</li>
<li>reduce 1/3</li>
<li>也就是说如果刚运行完成sort的话，那么进度是2/3</li>
<li><p>状态的更新</p>
</li>
<li><p>触发事件</p>
</li>
<li><p>读取记录</p>
</li>
<li>输出记录</li>
<li>修改状态 reporter的setStatus</li>
<li>计数器修改</li>
<li>reporter的progress</li>
<li><p>子进程有单独线程每隔3秒检查progress位是否设置，如果设置的话那么和tasktracker发起心跳</p>
</li>
<li><p>通过mapred.task.timeout控制</p>
</li>
<li><p>tasktracker每隔5秒和jobtracker做心跳</p>
</li>
<li><p>心跳时间通过 mapred.tasktracker.expircy.interval 设置</p>
</li>
<li><p>jobClient定期会去jobtracker询问job是否完成</p>
</li>
<li><p>jobClient也可以设置属性job.end.notification.url,任务完成jobtracker会调用这个url</p>
</li>
<li>可以认为就是推拉方式的结合。</li>
</ul>
<p>失败检测和处理</p>
<ul>
<li><p>任务失败</p>
</li>
<li><p>子进程抛出异常的话，tasktracker将异常信息记录到日志文件然后标记失败</p>
</li>
<li>对于streaming任务的话非0退出表示出现问题，也可以使用stream.non.zero.exit.is.failure = false来规避（ <strong>这样是否就没有办法判断是否正常退出了？</strong> ）</li>
<li>如果长时间没有响应的话，没有和tasktracker有交互，那么也会认为失败。这个时间使用mapred.task.timeout控制，默认10min</li>
<li><p>如果任务失败的话，jobtracker会尝试进行多次重试</p>
</li>
<li><p>map重试次数通过 mapred.map.max.attempts 配置</p>
</li>
<li>reduce重试次数通过 mapre.reduce.max.attempts 配置</li>
<li><strong>任何任务重试超过4次的话那么会认为整个job失败</strong></li>
<li>另外需要区分KILLED状态和FAILED状态，对于KILLED状态可能是因为推测执行造成的，不会记录到failed attempts里面</li>
<li><p>如果我们希望允许少量任务失败的话，那么可以配置</p>
</li>
<li><p>mapred.max.map.failures.percent 允许map失败的最大比率</p>
</li>
<li>mapred.max.reduce.failures.percent 允许reduce失败的最大比率</li>
<li>如果一个job超过一定的task在某个tt上面运行失败的话，那么就会将这个tt加入到这个job的blacklist. mapred.max.tracker.failures = 4</li>
<li>如果job成功的话，检查运行task失败的tt并且标记，如果超过一定阈值的话，那么会将tt加入到全局的blacklist. mapred.max.tracker.blacklists = 4</li>
</ul>
<p>作业的调度</p>
<ul>
<li><p>fifo scheduler</p>
</li>
<li><p>可以通过mapred.job.priority或者是setJobPriority设置</p>
</li>
<li>当队列中有空闲的槽位需要执行任务时，从等待队列中选择优先级最高的作业</li>
<li>fair scheduler</li>
<li>capacity scheduler</li>
</ul>
<p>shuffle和排序</p>
<p><img src="" alt="./images/mapreduce-shuffle-sort.jpg"></p>
<p><img src="" alt="./images/mapreduce-shuffle-sort-2.png"></p>
<p>有下面这些参数控制shuffle和sort的过程 <strong>NOTE（dirlt）：书上倒是有很多参数，但是好多还是不太理解</strong></p>
<ul>
<li>io.sort.mb map输出缓存空间大小，默认是100MB. 建议设置10/* io.sort.factor.</li>
<li><p>io.sort.spill.percent 如果map输出超过了缓存空间大小的这个阈值的话，那么就会spill,默认是0.8</p>
</li>
<li><p>每次spill之前先会对这个文件进行排序，如果有combiner的话那么会在上面调用combiner</p>
</li>
<li>写磁盘是按照轮询的方式写到mapred.local.dir属性指定的目录下面</li>
<li>如果spill速度太慢的话，那么往缓存空间写入进程就会阻塞，直到spill腾出空间。</li>
<li><p>io.sort.factor 多路归并的数量，默认是10. 建议设置在25-32.</p>
</li>
<li><p>在map阶段，因为最终会存在多个spill文件，所以需要做多路归并。 <strong>TODO（dirlt）：如果归并数量少的话是否可能会多次merge？</strong></p>
</li>
<li>在reduce阶段的话，因为可能存在多路map输出的结果，所以需要做多路归并。</li>
<li>min.num.spill.for.combine 如果指定combiner并且spill次数超过这个值的话就会调用combine,默认为3</li>
<li>tasktracker.http.threads reduce通过HTTP接口来发起数据请求，这个就是HTTP接口相应线程数目，默认为40。 <strong>mapper as server</strong></li>
<li><p>mapred.reduce.parallel.copies reduce启动多少个线程去请求map输出，默认为5。 <strong>reducer as client</strong></p>
</li>
<li><p><strong>NOTE(dirlt):如果reduce和每个map都使用一个线程去请求输出结果的话，只要shuffle阶段没有出现network congestion，那么提高线程数量是有效果的</strong></p>
</li>
<li><strong>NOTE（dirlt）：可以设置到15-50</strong></li>
<li>mapred.reduce.copy.backoff = 300(s) reduce下载线程最大等待时间</li>
<li>mapred.job.shuffle.input.buffer.percent = 0.7 用来缓存shuffle数据的reduce task heap百分比</li>
<li>mapred.job.shuffle.merge.percent = 0.66 缓存的内存中多少百分比后开始做merge操作</li>
<li>mapred.job.reduce.input.buffer.percent = 0.0 sort完成后reduce计算阶段用来缓存数据的百分比. 默认来说不会使用任何内存来缓存，因此完全从磁盘上进行读取。</li>
</ul>
<p>任务的执行</p>
<ul>
<li><p>推测执行参数</p>
</li>
<li><p>如果某个任务执行缓慢的话会执行另外一个备份任务</p>
</li>
<li>mapred.map.tasks.speculative.execution true</li>
<li>mapred.reduce.tasks.speculative.execution true</li>
<li><p>JVM重用</p>
</li>
<li><p>一个JVM实例可以用来执行多个task.</p>
</li>
<li>mapred.job.reuse.jvm.num.tasks/setNumTasksToExecutePerJvm 单个JVM运行任务的最大数目</li>
<li>-1表示没有限制</li>
<li><p>任务执行环境</p>
</li>
<li><p>程序自身可以知道执行环境对于开发还是比较有帮助的</p>
</li>
<li><p>这些属性对于streaming可以通过环境变量获得</p>
</li>
<li><p><strong>对于streaming来说.替换成为_</strong></p>
</li>
<li>mapred.job.id string jobID</li>
<li>mapred.tip.id string taskID</li>
<li>mapred.task.id string attemptID</li>
<li>mapred.task.partition int 作业中任务编号</li>
<li>mapred.task.is.map boolean 是否为map</li>
<li>mapred.work.output.dir / FileOutputFormat.getWorkOutputPath 当前工作目录</li>
<li><p>杂项 <strong>NOTE（dirlt）：from misc articles</strong></p>
</li>
<li><p>mapred.job.map.capacity /# 最大同时运行map数量</p>
</li>
<li>mapred.job.reduce.capacity /# 最大同时运行reduce数量</li>
<li>mapred.job.queue.name /# 选择执行queue<h3 id="1-4-7-mapreduce-">1.4.7 MapReduce的类型与格式</h3>
</li>
</ul>
<p>MapReduce的类型</p>
<p>老API里面还有MapRunner这个类，这个类主要的作用是可以用来控制Mapper运行的方法，比如可以多线程来控制Mapper的运行。 但是在新API里面已经完全集成到Mapper实现里面来了，用户可以重写两个方法来完全控制mapper的运行</p>
<ul>
<li>map 如何处理kv</li>
<li><p>run 如何从context里面读取kv
protected void map(KEYIN key, VALUEIN value,</p>
<pre><code>             Context context) throws IOException, InterruptedException {
</code></pre><p>context.write((KEYOUT) key, (VALUEOUT) value);</p>
</li>
</ul>
<p>}
public void run(Context context) throws IOException, InterruptedException {</p>
<p>  setup(context);
  while (context.nextKeyValue()) {</p>
<pre><code>map(context.getCurrentKey(), context.getCurrentValue(), context);
</code></pre><p>  }</p>
<p>  cleanup(context);
}</p>
<p><strong>NOTE（dirlt）：觉得这个特性不是特别有用</strong></p>
<ul>
<li>mapred.input.format.class setInputFormat</li>
<li>mapred.mapoutput.key.class setMapOutputKeyClass</li>
<li>mapred.mapoutput.value.class setMapOutputValueClass</li>
<li>mapred.output.key.class setOutputKeyClass</li>
<li>mapred.output.value.class setOutputValueClass</li>
<li>mapred.mapper.class setMapperClass</li>
<li>mapred.map.runner.class setMapRunnerClass</li>
<li>mapred.combiner.class setCombinerClass</li>
<li>mapred.partitioner.class setPartitionerClass</li>
<li>mapred.output.key.comparator.class setOutputKeyComparatorClass</li>
<li>mapred.output.value.groupfn.class setOutputValueGroupingComparator</li>
<li>mapred.reducer.class setReducerClass</li>
<li>mapred.output.format.class setOutputFormat</li>
</ul>
<p>输入格式</p>
<p>对于InputFormat来说包含两个任务</p>
<ul>
<li>根据job描述来对输入进行切片（InputSplit）</li>
<li><p>根据切片信息来读取记录（RecordReader）
public abstract class InputFormat<K, V> {</p>
<p>public abstract
  List<InputSplit> getSplits(JobContext context</p>
<pre><code>                         ) throws IOException, InterruptedException;
</code></pre></li>
</ul>
<p>   public abstract
    RecordReader<K,V> createRecordReader(InputSplit split,</p>
<pre><code>                                     TaskAttemptContext context
                                    ) throws IOException,

                                             InterruptedException;
</code></pre><p>}</p>
<p>public abstract class InputSplit {
  public abstract long getLength() throws IOException, InterruptedException;</p>
<p>  public abstract</p>
<pre><code>String[] getLocations() throws IOException, InterruptedException;
</code></pre><p>}</p>
<p>public abstract class RecordReader<KEYIN, VALUEIN> implements Closeable {</p>
<p>  public abstract void initialize(InputSplit split,
                                  TaskAttemptContext context</p>
<pre><code>                              ) throws IOException, InterruptedException;
</code></pre><p>  public abstract
  boolean nextKeyValue() throws IOException, InterruptedException;</p>
<p>  public abstract</p>
<p>  KEYIN getCurrentKey() throws IOException, InterruptedException;</p>
<p>  public abstract
  VALUEIN getCurrentValue() throws IOException, InterruptedException;</p>
<p>  public abstract float getProgress() throws IOException, InterruptedException;</p>
<p>  public abstract void close() throws IOException;</p>
<p>}</p>
<p>下面是一些常见的InputFormat实现</p>
<ul>
<li><p>FileInputFormat</p>
</li>
<li><p>addInputPath或者是setInputPaths修改输入路径 mapred.input.dir</p>
</li>
<li><p>setInputPathFilter可以修改过滤器 mapred.input.path.Filter.class</p>
</li>
<li><p>基本实现会排除隐藏.或者是_开头文件。</p>
</li>
<li>自定义的过滤器是建立在默认过滤器的基础上的。</li>
<li><p>分片大小由下面三个参数控制</p>
</li>
<li><p>mapred.min.split.size 1</p>
</li>
<li>mapred.max.split.size MAX</li>
<li>dfs.block.size 64MB</li>
<li>算法是max(minSplitSize,min(maxSplitSize,blockSize))</li>
<li>isSplitable可以控制输入文件是否需要分片</li>
<li>CombineFileInputFormat 可以处理多个小文件输入，抽象类需要继承实现。</li>
<li><p>TextInputFormat</p>
</li>
<li><p>输入单位是行，key是LongWritable表示行偏移，value是Text表示行内容</p>
</li>
<li><p>KeyValueTextInputFormat</p>
</li>
<li><p>输入单位是行，按照key.value.seperator.in.input.line来进行分隔默认是\t</p>
</li>
<li>key和value的格式都是Text</li>
<li><p>NLineInputFormat</p>
</li>
<li><p>和TextInputFormat非常类似，大师使用多行输入默认为1行</p>
</li>
<li>通过mapred.line.input.format.linespermap来控制行数</li>
<li><p>XML</p>
</li>
<li><p>InputFormat使用StreamInputFormat,</p>
</li>
<li>设置RecordReader使用stream.recordreader.class来设置</li>
<li>RecordReader使用org.apache.hadoop.streaming.StreamXmlRecordReader</li>
<li><strong>NOTE（dirlt）：也有现成的XmlInputFormat的实现</strong></li>
<li>SequenceFileInputFormat</li>
<li><p>SequenceFileAsTextInputFormat</p>
</li>
<li><p>将输入的kv转换成为text对象适合streaming处理方式</p>
</li>
<li>SequenceFileAsBinaryInputFormat <strong>NOTE（dirlt）：似乎没有什么用！</strong></li>
<li>MultipleInputs</li>
<li>DBInputFormat/DBOutputFormat JDBC数据库输入输出</li>
<li>TableInputFormat/TableOutputFormat HBase输入输出</li>
</ul>
<p>输出格式</p>
<ul>
<li><p>TextOutputFormat</p>
</li>
<li><p>使用mpared.textoutputformat.seperator来控制kv的分隔，默认是\t</p>
</li>
<li>对应的输入格式为KeyValueTextInputFormat</li>
<li>可以使用NullWritable来忽略输出的k或者是v</li>
<li>SequenceFileOutputFormat</li>
<li>SequenceFileAsBinaryOutpuFormat <strong>NOTE（dirlt）：似乎没有什么用！</strong></li>
<li>MapFileOutputFormat</li>
<li>MultipleOutputFormat</li>
<li><p>MultipleOutputs</p>
</li>
<li><p>如果不像生成那写part-r-00000这些空文件的话，那么可以将OutputFormat设置成为NullOutputFormat</p>
</li>
<li>但是使用NullOutputFormat的话会没有输出目录，如果想保留目录的话那么可以使用LazyOutputFormat</li>
</ul>
<h3 id="1-4-8-mapreduce-">1.4.8 MapReduce的特性</h3>
<ul>
<li><p>计数器</p>
</li>
<li><p>streaming计数器和可以通过写stderr来提交</p>
</li>
<li><p>reporter:counter:<group>,<counter>,<amount></p>
</li>
<li>reporter:status:<message></li>
<li><p>连接</p>
</li>
<li><p>map端连接</p>
</li>
<li><p>必须确保多路输入文件的reduce数量相同以及键相同。</p>
</li>
<li>使用CompositeInputFormat来运行map端连接。</li>
<li><strong>NOTE（dirlt)；不过我稍微看了一下代码，实现上其实也是针对输入文件对每条记录读取，然后进行join包括inner或者是outer。感觉场景会有限，而且效率不会太高</strong></li>
<li><p>分布式缓存</p>
</li>
<li><p>使用-files以及-archives来添加缓存文件</p>
</li>
<li><p>也可以使用DistributedAPI来完成之间事情</p>
</li>
<li><p>addCacheFile/addCacheArchive</p>
</li>
<li>然后在task里面通过configuration的getLocalCacheFiles以及getLocalCacheArchives来获得这些缓存文件</li>
<li><p>工作原理</p>
</li>
<li><p>缓存文件首先被放到hdfs上面</p>
</li>
<li><p>task需要的话那么会尝试下载，之后会对这个缓存文件进行引用计数，如果为0那么删除</p>
</li>
<li><p>这也就意味着缓存文件可能会被多次下载</p>
</li>
<li>但是运气好的话多个task在一个node上面的话那么就不用重复下载</li>
<li>缓存文件存放在${mapred.local.dir}/taskTracker/archive下面，但是通过软连接指向工作目录</li>
<li>缓存大小通过local.cache.size来配置</li>
<li><p>MapReduce库类</p>
</li>
<li><p>ChainMapper/ChainReducer 能够在一个mapper以及reducer里面运行多次mapper以及reducer</p>
</li>
<li><p>ChainMapper 允许在Map阶段，多个mapper组成一个chain,然后连续进行调用</p>
</li>
<li>ChainReducer 允许在Reuduce阶段，reducer完成之后执行一个mapper chain.</li>
<li>最终达到的效果就是 M+ -&gt; R -&gt; M/* （1个或者是多个mapper, 一个reducer，然后0个或者是多个mapper)</li>
<li><p><strong>TODO(dirlt):这样做倒是可以将各个mapper组合起来用作adapter.</strong></p>
<h3 id="1-4-9-hadoop-">1.4.9 构建Hadoop集群</h3>
</li>
<li><p>很多教程说hadoop集群需要配置ssh,但是配置这个前提是你希望使用start-all.sh这个脚本来启动集群</p>
</li>
<li><p>我现在的公司使用apt-get来安装，使用cssh来登陆到所有的节点上面进行配置，因此没有配置这个信任关系</p>
</li>
<li><p>Hadoop配置</p>
</li>
<li><p>配置文件</p>
</li>
<li><p>hadoop-env.sh 环境变量脚本</p>
</li>
<li>core-site.xml core配置，包括hdfs以及mapred的IO配置等</li>
<li>hdfs-site.xml hadoop进程配置比如namenode以及datanode以及secondary namenode</li>
<li>mapred-site.xml mapred进程配置比如jobtracker以及tasktracker</li>
<li><p>masters 运行namenode（secondary namenode)的机器列表，每行一个, <strong>无需分发到各个节点</strong></p>
</li>
<li><p><strong>在本地启动primary namenode</strong></p>
</li>
<li><p>slaves 运行datanode以及tasktracker的机器列表，每行一个 <strong>无需分发到各个节点</strong></p>
</li>
<li><p><strong>在本地启动jobtracker</strong></p>
</li>
<li>hadoop-metrics.properties 对hadoop做监控的配置文件</li>
<li>log4j.properties 日志配置文件</li>
<li>这些文件在conf目录下面有，如果想使用不同的文件也可以使用-config来另行指定</li>
<li><strong>NOTE(dirlt):所以从上面这个脚本来看，还是具有一定的局限性的</strong></li>
<li><p>hadoop-env.sh</p>
</li>
<li><p>HADOOP_HEAPSIZE = 1000MB 守护进程大小</p>
</li>
<li>HADOOP_NAMENODE_OPTS</li>
<li>HADOOP_SECONDARYNAMENODE_OPTS</li>
<li>HADOOP_IDENT_STRING 用户名称标记，默认为${USER}</li>
<li>HADOOP_LOG_DIR hadoop日志文件，默认是HADOOP_INSTALL/logs</li>
<li><p>core-site.xml</p>
</li>
<li><p>io.file.buffer.size IO操作缓冲区大小，默认是4KB <strong>这个需要提高</strong></p>
</li>
<li><p>hdfs-site.xml</p>
</li>
<li><p>fs.default.name</p>
</li>
<li>hadoop.tmp.dir hadoop临时目录，默认是在/tmp/hadoop-${user.name}</li>
<li>dfs.name.dir namenode数据目录，一系列的目录，namenode内容会同时备份在所有指定的目录中。默认为${hadoop.tmp.dir}/dfs/name</li>
<li>dfs.data.dir datanode数据目录，一系列的目录，循环将数据写在各个目录里面。默认是${hadoop.tmp.dir}/dfs/data</li>
<li>fs.checkpoint.dir secondarynamenode数据目录，一系列目录，所有目录都会写一份。默认为${hadoop.tmp.dir}/dfs/namesecondary</li>
<li>dfs.namenode.handler.count namenode上用来处理请求的线程数目</li>
<li>dfs.datanode.ipc.address 0.0.0.0:50020 datanode的RPC接口，主要和namenode交互</li>
<li>dfs.datanode.address 0.0.0.0:50010 datanode的data block传输接口，主要和client交互</li>
<li>dfs.datanode.http.address 0.0.0.0:50075 datanode的HTTP接口，和user交互</li>
<li>dfs.datanode.handler.count datanode上用来处理请求的线程数目</li>
<li>dfs.datanode.max.xcievers datanode允许最多同时打开的文件数量</li>
<li>dfs.http.address 0.0.0.0:50070 namenode的HTTP接口</li>
<li>dfs.secondary.http.address 0.0.0.0:50090 secondard namenode的HTTP接口</li>
<li>dfs.datanode.dns.interface default 绑定的NIC，默认是绑定默认的NIC比如eth0</li>
<li>dfs.hosts / dfs.hosts.exclude 加入的datanode以及排除的datanode</li>
<li>dfs.replication = 3 副本数目</li>
<li>dfs.block.size = 64MB</li>
<li>dfs.datanode.du.reserved 默认datanode会使用目录所在磁盘所有空间，这个值可以保证有多少空间被reserved的</li>
<li><p>fs.trash.interval 单位分钟，如果不为0的话，那么删除文件会移动到回收站，超过这个单位时间的文件才会完全删除。</p>
</li>
<li><p>回收站位置/home/${user]/.Trash <strong>NOTE(dirlt):回收站这个功能只是对fs shell有效。fs shell remove时候会构造Trash这个类来处理删除文件的请求。如果调用Java API的话那么会直接删除文件</strong></p>
</li>
<li>haddop fs -expunge 强制删除</li>
<li><strong>NOTE（dirlt）：grep代码发现只有NameNode在TrashEmptier里面构造了Trash这个类，因此这个配置之需要在nn上配置即可，决定多久定期删除垃圾文件</strong></li>
<li><p>fs.trash.checkpoint.interval 单位分钟，namenode多久检查一次文件是否需要删除。</p>
</li>
<li><p><strong>NOTE（dirlt）：似乎没有这个参数。如果没有这个参数的话，那么两次检查时长应该是由参数fs.trasn.interval来决定</strong></p>
</li>
<li><p>mapred-site.xml</p>
</li>
<li><p>mapred.job.tracker</p>
</li>
<li>mapred.local.dir MR中间数据存储，一系列目录，分散写到各个目录下面，默认为${hadoop.tmp.dir}/mapred/local</li>
<li>mapred.system.dir MR运行期间存储，比如存放jar或者是缓存文件等。默认${hadoop.tmp.dir}/mapred/system</li>
<li>mapred.tasktracker.map.tasks.maximum = 2 单个tasktracker最多多少map任务</li>
<li>mapred.tasktracker.reduce.tasks.maximum = 2 单个tasktracker最多多少个reduce任务</li>
<li>mapred.tasktracker.dns.interface default 绑定的NIC，默认是绑定默认的NIC比如eth0</li>
<li>mapred.child.ulimit 单个tasktracker允许子进程占用的最大内存空间。通常为2-3/* mapred.child.java.opts.</li>
<li><p>mapred.child.java.opts = -Xmx200m 每个子JVM进程200M. <strong>NOTE（dirlt）：这个是在提交机器上面设置的，而不是每个tasktracker上面设置的，每个job可以不同</strong></p>
</li>
<li><p>不一定支持将map/reduce的jvm参数分开设置 <a href="http://hadoop-common.472056.n3.nabble.com/separate-JVM-flags-for-map-and-reduce-tasks-td743351.html" target="_blank"><a href="http://hadoop-common.472056.n3.nabble.com/separate-JVM-flags-for-map-and-reduce-tasks-td743351.html">http://hadoop-common.472056.n3.nabble.com/separate-JVM-flags-for-map-and-reduce-tasks-td743351.html</a></a></p>
</li>
<li><strong>NOTE（dirlt）：个人折中思路是限制内存大小为1G，然后大内存机器允许同时执行map/reduce数量上限提高，通过增加job的map/reduce数量来提高并发增加性能</strong></li>
<li><p><strong>NOTE（dirlt）：我grep了一下cdh3u3的代码，应该是将map/reduce的jvm参数分开进行了设置</strong></p>
</li>
<li><p>mapred.map.child.java.opts</p>
</li>
<li>mapred.reduce.child.java.opts</li>
<li>mapred.task.tracker.report.address 127.0.0.1:0 tasktracker启动子进程通信的端口，0表示使用任意端口</li>
<li>mapred.task.tracker.expiry.interval 600(sec) tt和jt之间的心跳间隔</li>
<li>mapred.job.tracker.handler.count. jobtracker用来处理请求的线程数目。</li>
<li>mapred.job.tracker.http.address 0.0.0.0:50030 jobtracker的HTTP接口</li>
<li>mapred.task.tracker.http.address 0.0.0.0:50060 tasktrackder的HTTP接口</li>
<li>mapred.hosts / mapred.hosts.exclude 加入的tasktracker以及排除的tasktracker.</li>
<li><p>Hadoop Benchmark <strong>NOTE（dirlt）：try it out</strong></p>
</li>
<li><p>在hadoop安装目录下面有jar可以来做基准测试</p>
</li>
<li>TestDFSIO测试HDFS的IO性能</li>
<li>Sort测试MapReduce性能</li>
<li>MRBench多次运行一个小作业来检验小作业能否快速相应</li>
<li>NNBench测试namenode硬件的负载</li>
</ul>
<h3 id="1-4-10-hadoop">1.4.10 管理Hadoop</h3>
<ul>
<li><p>永久性数据结构</p>
</li>
<li><p>namenode的目录结构</p>
</li>
<li><p>current表示当前的namenode数据（对于辅助节点上这个数据并不是最新的）</p>
</li>
<li><p>previous.checkpoint表示secondarynamenode完成checkpoint的数据（和current可能存在一些编辑差距）</p>
</li>
<li><p>hadoop dfsadmin -saveNamespace 可以强制创建检查点,仅仅在安全模式下面运行</p>
</li>
<li><p>辅助namenode每隔5分钟会检查</p>
</li>
<li><p>如果超过fs.checkpoint.period = 3600（sec），那么会创建检查点</p>
</li>
<li>如果编辑日志大小超过fs.checkpoint.size = 64MB,同样也会创建检查点</li>
<li>除了将文件copy到namenode之外，在辅助节点上面可以使用选项-importCheckpoint来载入</li>
<li><p>VERSION Java属性文件</p>
</li>
<li><p>namespaceID 每次格式化都会重新生成一个ID，这样可以防止错误的datanode加入</p>
</li>
<li>cTime namenode存储系统创建时间，对于刚格式化的存储系统为0.对于升级的话会更新到最新的时间戳</li>
<li>storageType NAME_NODE or DATA_NODE</li>
<li>layoutVersion 负整数表示hdfs文件系统布局版本号，对于hadoop升级的话这个版本号可能不会变化</li>
<li>edits 编辑日志文件</li>
<li>fsimage 镜像文件</li>
<li>fstime ???</li>
<li><p>datanode的目录结构</p>
</li>
<li><p>blk<em><id>以及blk</em><id>.meta 表示块数据以及对应的元信息，元数据主要包括校验和等内容</p>
</li>
<li>如果datanode文件非常多的话，超过dfs.datanode.numblocks = 64的话，那么会创建一个目录单独存放，最终结果就是形成树存储结构。</li>
<li>dfs.data.dir目录是按照round-robin的算法选择的。</li>
<li><p>安全模式</p>
</li>
<li><p>namenode启动的时候会尝试合并edit数据并且新建一个checkpoint，然后进入安全模式，在这个模式内文件系统是只读的</p>
</li>
<li>可以通过hadoop dfsadmin -safemode来操作安全模式</li>
<li><p>当达到下面几个条件的时候会离开安全模式</p>
</li>
<li><p>整个系统的副本数目大于某个阈值的副本数目比率超过一个阈值之后，然后继续等待一段时间就会离开安全模式</p>
</li>
<li>dfs.replication.min = 1 副本数目阈值</li>
<li>dfs.safemode.threshold.pct = 0.999 比率阈值</li>
<li>dfs.safemode.extension = 30000(ms) 等待时间</li>
<li><p>工具</p>
</li>
<li><p>dfsadmin</p>
</li>
<li>fsck</li>
<li><p>scanner</p>
</li>
<li><p>DataBlockScanner每隔一段时间会扫描本地的data block检查是否出现校验和问题</p>
</li>
<li>时间间隔是dfs.datanode.scan.period.hours = 504默认三周</li>
<li>可以通过页面访问每个datanode的block情况 <a href="http://localhost:50075/blockScannerReport" target="_blank"><a href="http://localhost:50075/blockScannerReport">http://localhost:50075/blockScannerReport</a></a></li>
<li>加上listblocks参数可以看每个block情况 <a href="http://localhost:50075/blockScannerReport?listblocks" target="_blank"><a href="http://localhost:50075/blockScannerReport?listblocks">http://localhost:50075/blockScannerReport?listblocks</a></a> <strong>NOTE（dirlt）：可能会很大</strong></li>
<li><p>balancer</p>
</li>
<li><p>通过start-balancer.sh来启动,集群中只允许存在一个均衡器</p>
</li>
<li>均衡的标准是datanode的利用率和集群平均利用率的插值，如果超过某个阈值就会进行block movement</li>
<li>-threshold可以执行阈值，默认为10%</li>
<li>dfs.balance.bandwidthPerSec = 1024 /* 1024 用于balance的带宽上限。</li>
<li><p>监控</p>
</li>
<li><p>日志</p>
</li>
<li><p>jobtracker的stack信息（thread-dump）<a href="http://localhost:50030/stacks" target="_blank"><a href="http://localhost:50030/stacks">http://localhost:50030/stacks</a></a></p>
</li>
<li><p>度量</p>
</li>
<li><p>度量从属于特性的上下文(context),包括下面几个</p>
</li>
<li><p>dfs</p>
</li>
<li>mapred</li>
<li>rpc</li>
<li>jvm</li>
<li><p>下面是几种常见的context</p>
</li>
<li><p>FileContext 度量写到文件</p>
</li>
<li>GangliaContext 度量写到ganglia <strong>(这个似乎比较靠谱）</strong></li>
<li>CompositeContext 组合context</li>
<li>度量可以从hadoop-metrics.properties进行配置</li>
</ul>
<h3 id="1-5-benchmark">1.5 Benchmark</h3>
<ul>
<li>Benchmarking and Stress Testing an Hadoop Cluster with TeraSort, TestDFSIO &amp; Co. - Michael G. Noll <a href="http://www.michael-noll.com/blog/2011/04/09/benchmarking-and-stress-testing-an-hadoop-cluster-with-terasort-testdfsio-nnbench-mrbench/" target="_blank"><a href="http://www.michael-noll.com/blog/2011/04/09/benchmarking-and-stress-testing-an-hadoop-cluster-with-terasort-testdfsio-nnbench-mrbench/">http://www.michael-noll.com/blog/2011/04/09/benchmarking-and-stress-testing-an-hadoop-cluster-with-terasort-testdfsio-nnbench-mrbench/</a></a></li>
<li>intel-hadoop/HiBench · GitHub <a href="https://github.com/intel-hadoop/HiBench" target="_blank"><a href="https://github.com/intel-hadoop/HiBench">https://github.com/intel-hadoop/HiBench</a></a></li>
<li>HBase Performance Testing at hstack <a href="http://hstack.org/hbase-performance-testing/" target="_blank"><a href="http://hstack.org/hbase-performance-testing/">http://hstack.org/hbase-performance-testing/</a></a></li>
<li>Performance testing / Benchmarking a HBase cluster – Sujee Maniyam <a href="http://sujee.net/tech/articles/hadoop/hbase-performance-testing/" target="_blank"><a href="http://sujee.net/tech/articles/hadoop/hbase-performance-testing/">http://sujee.net/tech/articles/hadoop/hbase-performance-testing/</a></a></li>
<li>new Put(&quot;lars&quot;.toBytes(&quot;UTF-8&quot;)) : Performance testing HBase using YCSB <a href="http://blog.lars-francke.de/2010/08/16/performance-testing-hbase-using-ycsb/" target="_blank"><a href="http://blog.lars-francke.de/2010/08/16/performance-testing-hbase-using-ycsb/">http://blog.lars-francke.de/2010/08/16/performance-testing-hbase-using-ycsb/</a></a></li>
<li>Hbase/PerformanceEvaluation - Hadoop Wiki <a href="http://wiki.apache.org/hadoop/Hbase/PerformanceEvaluation" target="_blank"><a href="http://wiki.apache.org/hadoop/Hbase/PerformanceEvaluation">http://wiki.apache.org/hadoop/Hbase/PerformanceEvaluation</a></a></li>
</ul>
<h3 id="1-5-1-testdfsio">1.5.1 TestDFSIO</h3>
<p>测试hdfs吞吐
hdfs@hadoop1:~$ hadoop jar /usr/lib/hadoop/hadoop-test-0.20.2-cdh3u3.jar TestDFSIO</p>
<p>Usage: TestDFSIO [genericOptions] -read | -write | -append | -clean [-nrFiles N] [-fileSize Size[B|KB|MB|GB|TB]] [-resFile resultFileName] [-bufferSize Bytes] [-rootDir]%</p>
<ul>
<li>read / write / append / clean 操作类型 <strong>append和write执行效率差别不大，但是write会创建新文件所以使用比较方便</strong> (default read)</li>
<li>nrFiles 文件数目(default 1) <strong>启动相同数量的map</strong></li>
<li>fileSize 每个文件大小(1MB)</li>
<li>resFile 结果报告文件(TestDFSIO_results.log)</li>
<li>bufferSize write buffer size(单次write写入大小）（1000000 bytes)</li>
<li><p>rootDir 操作文件根目录（/benchmarks/TestDFSIO/）
----- TestDFSIO ----- : write</p>
<pre><code>     Date &amp; time: Thu Apr 25 19:14:21 CST 2013
 Number of files: 2
</code></pre></li>
</ul>
<p>Total MBytes processed: 2.0
     Throughput mb/sec: 7.575757575757576</p>
<p>Average IO rate mb/sec: 7.61113977432251
IO rate std deviation: 0.5189420757292891</p>
<pre><code>Test exec time sec: 14.565
</code></pre><p>----- TestDFSIO ----- : read
           Date &amp; time: Thu Apr 25 19:15:13 CST 2013</p>
<pre><code>   Number of files: 2
</code></pre><p>Total MBytes processed: 2.0</p>
<pre><code> Throughput mb/sec: 27.77777777777778
</code></pre><p>Average IO rate mb/sec: 28.125</p>
<p>IO rate std deviation: 3.125
    Test exec time sec: 14.664</p>
<ul>
<li>throughtput = sum(filesize) / sum(time)</li>
<li>avaerage io rate = sum(filesize/time) / n</li>
<li>io rate std deviation<h3 id="1-5-2-terasort">1.5.2 TeraSort</h3>
</li>
</ul>
<p>通过排序测试MR执行效率 <strong>我看了一下代码map/reduce都有CPU操作，并且这个也非常依靠shuffle/copy.因此这个测试应该会是比较全面的</strong>
hdfs@hadoop1:~$ hadoop jar /usr/lib/hadoop/hadoop-examples-0.20.2-cdh3u3.jar <command></p>
<ul>
<li><p>teragen 产生排序数据</p>
</li>
<li><number of 100-byte rows>
</li>
<li><p>10 bytes key(random characters)</p>
</li>
<li>10 bytes rowid(right justified row id as a int)</li>
<li>78 bytes filler</li>
<li>\r\n</li>
<li><output dir></li>
<li><p>terasort 对数据排序</p>
</li>
<li><input dir></li>
<li><output dir></li>
<li>teravalidate 对排序数据做验证</li>
</ul>
<p>可以使用hadoop job -history all <job-output-dir>来观察程序运行数据，也可以通过web page来分析。</p>
<h3 id="1-5-3-nnbench">1.5.3 nnbench</h3>
<p>测试nn负载能力
➜  ~HADOOP_HOME  hadoop jar hadoop-test-0.20.2-cdh3u3.jar nnbench</p>
<p>NameNode Benchmark 0.4
Usage: nnbench <options></p>
<p>Options:
        -operation <Available operations are create_write open_read rename delete. This option is mandatory></p>
<pre><code>     /* NOTE: The open_read, rename and delete operations assume that the files they operate on, are already available. The create_write operation must be run before running the other operations.
    -maps &lt;number of maps. default is 1. This is not mandatory&gt;

    -reduces &lt;number of reduces. default is 1. This is not mandatory&gt;
    -startTime &lt;time to start, given in seconds from the epoch. Make sure this is far enough into the future, so all maps (operations) will start at the same time&gt;. default is launch time + 2 mins. This is not mandatory

    -blockSize &lt;Block size in bytes. default is 1. This is not mandatory&gt;
    -bytesToWrite &lt;Bytes to write. default is 0. This is not mandatory&gt;

    -bytesPerChecksum &lt;Bytes per checksum for the files. default is 1. This is not mandatory&gt;
    -numberOfFiles &lt;number of files to create. default is 1. This is not mandatory&gt;

    -replicationFactorPerFile &lt;Replication factor for the files. default is 1. This is not mandatory&gt;
    -baseDir &lt;base DFS path. default is /becnhmarks/NNBench. This is not mandatory&gt;

    -readFileAfterOpen &lt;true or false. if true, it reads the file and reports the average time to read. This is valid with the open_read operation. default is false. This is not mandatory&gt;
    -help: Display the help statement
</code></pre><ul>
<li>startTime 作用是为了能够让所有的map同时启动以便对nn造成压力
➜  ~HADOOP_HOME  hadoop jar hadoop-test-0.20.2-cdh3u3.jar nnbench -operation create_write -bytesToWrite 0 -numberOfFiles 1200</li>
</ul>
<p>➜  ~HADOOP_HOME  hadoop jar hadoop-test-0.20.2-cdh3u3.jar nnbench -operation open_read</p>
<p>结果报告文件是 NNBench_results.log</p>
<p>-------------- NNBench -------------- :</p>
<pre><code>                           Version: NameNode Benchmark 0.4
                       Date &amp; time: 2013-04-25 19:41:02,873


                    Test Operation: create_write

                        Start time: 2013-04-25 19:40:21,70
                       Maps to run: 1

                    Reduces to run: 1
                Block Size (bytes): 1

                    Bytes to write: 0
                Bytes per checksum: 1

                   Number of files: 1200
                Replication factor: 1

        Successful file operations: 1200


    /# maps that missed the barrier: 0
                      /# exceptions: 0


           TPS: Create/Write/Close: 75
</code></pre><p>Avg exec time (ms): Create/Write/Close: 26.526666666666667
            Avg Lat (ms): Create/Write: 13.236666666666666</p>
<pre><code>               Avg Lat (ms): Close: 13.164166666666667


             RAW DATA: AL Total /#1: 15884
             RAW DATA: AL Total /#2: 15797

          RAW DATA: TPS Total (ms): 31832
   RAW DATA: Longest Map Time (ms): 31832.0

               RAW DATA: Late maps: 0
         RAW DATA: /# of exceptions: 0
</code></pre><p>-------------- NNBench -------------- :</p>
<pre><code>                           Version: NameNode Benchmark 0.4
                       Date &amp; time: 2013-04-25 19:44:42,354


                    Test Operation: open_read

                        Start time: 2013-04-25 19:44:31,921
                       Maps to run: 1

                    Reduces to run: 1
                Block Size (bytes): 1

                    Bytes to write: 0
                Bytes per checksum: 1

                   Number of files: 1
                Replication factor: 1

        Successful file operations: 1


    /# maps that missed the barrier: 0
                      /# exceptions: 0


                    TPS: Open/Read: 500

     Avg Exec time (ms): Open/Read: 2.0
                Avg Lat (ms): Open: 2.0


             RAW DATA: AL Total /#1: 2

             RAW DATA: AL Total /#2: 0
          RAW DATA: TPS Total (ms): 2

   RAW DATA: Longest Map Time (ms): 2.0
               RAW DATA: Late maps: 0

         RAW DATA: /# of exceptions: 0
</code></pre><ul>
<li>maps that missed the barrier 从代码上分析是，在等待到start time期间中,如果sleep出现异常的话。</li>
<li>exceptions 表示在操作文件系统时候的exception数量</li>
<li>TPS transactions per second</li>
<li>exec（execution） 执行时间</li>
<li>lat（latency） 延迟时间</li>
<li>late maps 和 maps missed the barrier是一个概念。</li>
</ul>
<p>对于后面RAW DATA部分的话，从代码上看，就是为了计算出上面那些指标的，所以没有必要关注。</p>
<h3 id="1-5-4-mrbench">1.5.4 mrbench</h3>
<p>测试运行small mr jobs执行效率，主要关注响应时间。
MRBenchmark.0.0.2</p>
<p>Usage: mrbench [-baseDir <base DFS path for output/input, default is /benchmarks/MRBench>] [-jar <local path to job jar file containing Mapper and Reducer implementations, default is current jar file>] [-numRuns <number of times to run the job, default is 1>] [-maps <number of maps for each run, default is 2>] [-reduces <number of reduces for each run, default is 1>] [-inputLines <number of input lines to generate, default is 1>] [-inputType <type of input to generate, one of ascending (default), descending, random>] [-verbose]</p>
<ul>
<li>baseDir 输入输出目录</li>
<li>jar 通常不需要指定，用默认即可。</li>
<li>inputLines 输入条数</li>
<li>inputType 输入是否有序
hdfs@hadoop1:~$ hadoop jar /usr/lib/hadoop/hadoop-test-0.20.2-cdh3u3.jar mrbench -verbose</li>
</ul>
<p>结果直接输出在终端上面，</p>
<p>Total MapReduce jobs executed: 1</p>
<p>Total lines of data per job: 1
Maps per job: 2</p>
<p>Reduces per job: 1
Total milliseconds for task: 1 = 16452</p>
<p>DataLines       Maps    Reduces AvgTime (milliseconds)
1               2       1       16452</p>
<p>可以看到每个任务平均执行时间在16.452s.</p>
<h3 id="1-5-5-hbase-performanceevaluation">1.5.5 hbase.PerformanceEvaluation</h3>
<p>hdfs@hadoop1:~$ hbase org.apache.hadoop.hbase.PerformanceEvaluation</p>
<p>Usage: java org.apache.hadoop.hbase.PerformanceEvaluation \
  [--miniCluster] [--nomapred] [--rows=ROWS] <command> <nclients></p>
<p>Options:</p>
<p> miniCluster     Run the test on an HBaseMiniCluster
 nomapred        Run multiple clients using threads (rather than use mapreduce)</p>
<p> rows            Rows each client runs. Default: One million
 flushCommits    Used to determine if the test should flush the table.  Default: false</p>
<p> writeToWAL      Set writeToWAL on puts. Default: True</p>
<p>Command:
 filterScan      Run scan test using a filter to find a specific row based on it&#39;s value (make sure to use --rows=20)</p>
<p> randomRead      Run random read test
 randomSeekScan  Run random seek and scan 100 test</p>
<p> randomWrite     Run random write test
 scan            Run scan test (read every row)</p>
<p> scanRange10     Run random seek scan with both start and stop row (max 10 rows)
 scanRange100    Run random seek scan with both start and stop row (max 100 rows)</p>
<p> scanRange1000   Run random seek scan with both start and stop row (max 1000 rows)
 scanRange10000  Run random seek scan with both start and stop row (max 10000 rows)</p>
<p> sequentialRead  Run sequential read test
sequentialWrite Run sequential write test</p>
<p>Args:</p>
<p> nclients        Integer. Required. Total number of clients (and HRegionServers)
                 running: 1 &lt;= value &lt;= 500</p>
<p>Examples:
To run a single evaluation client:</p>
<p>$ bin/hbase org.apache.hadoop.hbase.PerformanceEvaluation sequentialWrite 1</p>
<p>从参数上看还是比较直接的。benchmark每个client通常对应10个mapper, 每个client操作<rows>个row,因此每个mapper操作<rows>/10个row,每个row大约1000bytes.</p>
<ul>
<li>filterScan 随机生成value，然后从头开始scan直到equal</li>
<li>randomRead 随机选取key读取</li>
<li>randomSeekScan 从某个随机位置开始scan最多100个</li>
<li>randomWrite 随即生成key写入</li>
<li>scan 每次scan 1个row，start随机</li>
<li>scan<num> 每次scan num个row，start随机</li>
<li>seqRead 顺序地读取每个key</li>
<li>seqWrite 顺序地写入每个key</li>
<li><strong>NOTE(dirlt):这里的key都非常简单，10个字符的数字，printf(&quot;%010d&quot;,row)</strong>
hdfs@hadoop1:~$ time hbase org.apache.hadoop.hbase.PerformanceEvaluation --rows=1000 sequentialWrite 2</li>
</ul>
<p>13/04/25 23:47:56 INFO mapred.JobClient:   HBase Performance Evaluation
13/04/25 23:47:56 INFO mapred.JobClient:     Row count=2000</p>
<p>13/04/25 23:47:56 INFO mapred.JobClient:     Elapsed time in milliseconds=258</p>
<p>输出结果是在counter里面，这里面row count = 2000, 占用时间为258 ms.
Date: 2013-12-15T10:28+0800</p>
<p><a href="http://orgmode.org/" target="_blank">Org</a> version 7.9.2 with <a href="http://www.gnu.org/software/emacs/" target="_blank">Emacs</a> version 24
<a href="http://validator.w3.org/check?uri=referer" target="_blank">Validate XHTML 1.0</a>
来源： <a href="[http://dirlt.com/hadoop.html/#sec-1-1-4](http://dirlt.com/hadoop.html#sec-1-1-4)">[http://dirlt.com/hadoop.html/#sec-1-1-4](http://dirlt.com/hadoop.html#sec-1-1-4)</a> </p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/hadoop/">hadoop</a></li></span></span> | <span class="tags">Tagged <a href="/tags/hadoop/" class="label label-primary">hadoop</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:36"datetime="2014-03-07 09:54:36"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-hadoop--hadoop/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-hadoop--hadoop" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-hadoop--NotesforHadoopthedefinitiveguide/">Notes for Hadoop the definitive guide</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:36.000Z"> <a href="/2014/02/02/2014-02-02-hadoop--NotesforHadoopthedefinitiveguide/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="notes-for-hadoop-the-definitive-guide">Notes for Hadoop the definitive guide</h1>
<h1 id="1-introduction-to-hdfs">1. Introduction to HDFS</h1>
<h2 id="1-1-hdfs-concepts">1.1. HDFS Concepts</h2>
<h3 id="1-1-1-blocks">1.1.1. Blocks</h3>
<p>l HDFS too has the concept of a block, but it is a much larger unit 64 MB by default.</p>
<p>l Like in a filesystem for a single disk, files in HDFS are broken into block-sized chunks, which are stored as independent units.</p>
<p>l Unlike a filesystem for a single disk, a file in HDFS that is smaller than a single block does not occupy a full block’s worth of underlying storage.</p>
<h3 id="1-1-2-namenodes-and-datanodes">1.1.2. Namenodes and Datanodes</h3>
<p>l The namenode manages the filesystem namespace.</p>
<p>n It maintains the filesystem tree and the metadata for all the files and directories in the tree.</p>
<p>n This information is stored persistently on the local disk in the form of two files: the namespace image and the edit log.</p>
<p>n The namenode also knows the datanodes on which all the blocks for a given file are located, however, it does not store block locations persistently, since this information is reconstructed from datanodes when the system starts.</p>
<p>l Datanodes are the work horses of the filesystem.</p>
<p>n They store and retrieve blocks when they are told to (by clients or the namenode)</p>
<p>n They report back to the namenode periodically with lists of blocks that they are storing.</p>
<p>l secondary namenode</p>
<p>n It does not act as a namenode.</p>
<p>n Its main role is to periodically merge the namespace image with the edit log to prevent the edit log from becoming too large.</p>
<p>n It keeps a copy of the merged name space image, which can be used in the event of the namenode failing.</p>
<h3 id="namenode-directory-structure">Namenode directory structure</h3>
<p><a href="http://images.cnblogs.com/cnblogs_com/forfuture1978/WindowsLiveWriter/NotesforHadoopthedefinitiveguide_14109/clip_image002_2.jpg" target="_blank"><img src="&quot;clip_image002&quot;" alt="clip_image002"></a></p>
<p>l The VERSION file is a Java properties file that contains information about the version of HDFS that is running</p>
<p>n The layoutVersion is a negative integer that defines the version of HDFS’s persistent data structures.</p>
<p>n The namespaceID is a unique identifier for the filesystem, which is created when the filesystem is first formatted.</p>
<p>n The cTime property marks the creation time of the namenode’s storage.</p>
<p>n The storageType indicates that this storage directory contains data structures for a namenode.</p>
<p><a href="http://images.cnblogs.com/cnblogs_com/forfuture1978/WindowsLiveWriter/NotesforHadoopthedefinitiveguide_14109/clip_image004_2.jpg" target="_blank"><img src="&quot;clip_image004&quot;" alt="clip_image004"></a></p>
<h3 id="the-filesystem-image-and-edit-log">The filesystem image and edit log</h3>
<p>l When a filesystem client performs a write operation, it is first recorded in the edit log.</p>
<p>l The namenode also has an in-memory representation of the filesystem metadata, which it updates after the edit log has been modified.</p>
<p>l The edit log is flushed and synced after every write before a success code is returned to the client.</p>
<p>l The fsimage file is a persistent checkpoint of the filesystem metadata. it is not updated for every filesystem write operation.</p>
<p>l If the namenode fails, then the latest state of its metadata can be reconstructed by loading the fsimage from disk into memory, then applying each of the operations in the edit log.</p>
<p>l This is precisely what the namenode does when it starts up.</p>
<p>l The fsimage file contains a serialized form of all the directory and file inodes in the filesystem.</p>
<p>l The secondary namenode is to produce checkpoints of the primary’s in-memory filesystem metadata.</p>
<p>l The checkpointing process proceeds as follows :</p>
<p>n The secondary asks the primary to roll its edits file, so new edits go to a new file.</p>
<p>n The secondary retrieves fsimage and edits from the primary (using HTTP GET).</p>
<p>n The secondary loads fsimage into memory, applies each operation from edits, then creates a new consolidated fsimage file.</p>
<p>n The secondary sends the new fsimage back to the primary (using HTTP POST).</p>
<p>n The primary replaces the old fsimage with the new one from the secondary, and the old edits file with the new one it started in step 1. It also updates the fstime file to record the time that the checkpoint was taken.</p>
<p>n At the end of the process, the primary has an up-to-date fsimage file, and a shorter edits file.</p>
<p><a href="http://images.cnblogs.com/cnblogs_com/forfuture1978/WindowsLiveWriter/NotesforHadoopthedefinitiveguide_14109/clip_image006_2.jpg" target="_blank"><img src="&quot;clip_image006&quot;" alt="clip_image006"></a></p>
<h3 id="secondary-namenode-directory-structure">Secondary namenode directory structure</h3>
<p><a href="http://images.cnblogs.com/cnblogs_com/forfuture1978/WindowsLiveWriter/NotesforHadoopthedefinitiveguide_14109/clip_image008_2.jpg" target="_blank"><img src="&quot;clip_image008&quot;" alt="clip_image008"></a></p>
<h3 id="datanode-directory-structure">Datanode directory structure</h3>
<p><a href="http://images.cnblogs.com/cnblogs_com/forfuture1978/WindowsLiveWriter/NotesforHadoopthedefinitiveguide_14109/clip_image010_2.jpg" target="_blank"><img src="&quot;clip_image010&quot;" alt="clip_image010"></a></p>
<p>l A datanode’s VERSION file</p>
<p><a href="http://images.cnblogs.com/cnblogs_com/forfuture1978/WindowsLiveWriter/NotesforHadoopthedefinitiveguide_14109/clip_image012_2.jpg" target="_blank"><img src="&quot;clip_image012&quot;" alt="clip_image012"></a></p>
<p>l The other files in the datanode’s current storage directory are the files with the blk_ prefix.</p>
<p>n There are two types: the HDFS blocks themselves (which just consist of the file’s raw bytes) and the metadata for a block (with a .meta suffix).</p>
<p>n A block file just consists of the raw bytes of a portion of the file being stored;</p>
<p>n the metadata file is made up of a header with version and type information, followed by a series of checksums for sections of the block.</p>
<p>l When the number of blocks in a directory grows to a certain size, the datanode creates a new subdirectory in which to place new blocks and their accompanying metadata.</p>
<h2 id="1-2-data-flow">1.2. Data Flow</h2>
<h3 id="1-2-1-anatomy-of-a-file-read">1.2.1. Anatomy of a File Read</h3>
<p><a href="http://images.cnblogs.com/cnblogs_com/forfuture1978/WindowsLiveWriter/NotesforHadoopthedefinitiveguide_14109/clip_image014_2.jpg" target="_blank"><img src="&quot;clip_image014&quot;" alt="clip_image014"></a></p>
<p>l The client opens the file it wishes to read by calling open() on the FileSystem object (step 1).</p>
<p>l DistributedFileSystem calls the namenode, using RPC, to determine the locations of the blocks for the first few blocks in the file (step 2).</p>
<p>l For each block, the namenode returns the addresses of the datanodes that have a copy of that block.</p>
<p>l The datanodes are sorted according to their proximity to the client.</p>
<p>l The DistributedFileSystem returns a FSDataInputStream to the client for it to read data from.</p>
<p>l The client then calls read() on the stream (step 3).</p>
<p>l DFSInputStream connects to the first (closest) datanode for the first block in the file.</p>
<p>l Data is streamed from the datanode back to the client (step 4).</p>
<p>l When the end of the block is reached, DFSInputStream will close the connection to the datanode, then find the best datanode for the next block (step 5).</p>
<p>l When the client has finished reading, it calls close() on the FSDataInputStream (step 6).</p>
<p>l During reading, if the client encounters an error while communicating with a datanode, then it will try the next closest one for that block.</p>
<p>l It will also remember datanodes that have failed so that it doesn’t needlessly retry them for later blocks.</p>
<p>l The client also verifies checksums for the data transferred to it from the datanode. If a corrupted block is found, it is reported to the namenode.</p>
<h3 id="1-2-2-anatomy-of-a-file-write">1.2.2. Anatomy of a File Write</h3>
<p><a href="http://images.cnblogs.com/cnblogs_com/forfuture1978/WindowsLiveWriter/NotesforHadoopthedefinitiveguide_14109/clip_image016_2.jpg" target="_blank"><img src="&quot;clip_image016&quot;" alt="clip_image016"></a></p>
<p>l The client creates the file by calling create() (step 1).</p>
<p>l DistributedFileSystem makes an RPC call to the namenode to create a new file in the filesystem’s namespace, with no blocks associated with it (step 2).</p>
<p>l The namenode performs various checks to make sure the file doesn’t already exist, and that the client has the right permissions to create the file. If these checks pass, the namenode makes a record of the new file; otherwise, file creation fails and the client is thrown an IOException.</p>
<p>l The DistributedFileSystem returns a FSDataOutputStream for the client to start writing data to.</p>
<p>l As the client writes data (step 3), DFSOutputStream splits it into packets, which it writes to an internal queue, called the data queue.</p>
<p>l The data queue is consumed by the Data Streamer, whose responsibility it is to ask the namenode to allocate new blocks by picking a list of suitable datanodes to store the replicas. The list of datanodes forms apipeline.</p>
<p>l The DataStreamer streams the packets to the first datanode in the pipeline, which stores the packet and forwards it to the second datanode in the pipeline. Similarly, the second datanode stores the packet and forwards it to the third (and last) datanode in the pipe line (step 4).</p>
<p>l DFSOutputStream also maintains an internal queue of packets that are waiting to be acknowledged by datanodes, called the ack queue. A packet is removed from the ack queue only when it has been acknowledged by all the datanodes in the pipeline (step 5).</p>
<p>l If a datanode fails while data is being written to it,</p>
<p>n First the pipeline is closed, and any packets in the ack queue are added to the front of the data queue.</p>
<p>n The current block on the good datanodes is given a new identity by the namenode, so that the partial block on the failed datanode will be deleted if the failed data node recovers later on.</p>
<p>n The failed datanode is removed from the pipeline and the remainder of the block’s data is written to the two good datanodes in the pipeline.</p>
<p>n The namenode notices that the block is under-replicated, and it arranges for a further replica to be created on another node.</p>
<p>l When the client has finished writing data it calls close() on the stream (step 6). This action flushes all the remaining packets to the datanode pipeline and waits for acknowledgments before contacting the namenode to signal that the file is complete (step7).</p>
<h1 id="2-meet-map-reduce">2. Meet Map/Reduce</h1>
<p>l MapReduce has two phases: the map phase and the reduce phase.</p>
<p>l Each phase has key-value pairs as input and output (the types can be specified).</p>
<p>n The input key-value types of the map phase is determined by the input format</p>
<p>n The output key-value types of the map phase should match the input key value types of the reduce phase</p>
<p>n The output key-value types of the reduce phase can be set in the JobConf interface.</p>
<p>l The programmer specifies two functions: the map function and the reduce function.</p>
<h2 id="2-1-mapreduce-logical-data-flow">2.1. MapReduce logical data flow</h2>
<p><a href="http://images.cnblogs.com/cnblogs_com/forfuture1978/WindowsLiveWriter/NotesforHadoopthedefinitiveguide_14109/clip_image018_2.jpg" target="_blank"><img src="&quot;clip_image018&quot;" alt="clip_image018"></a></p>
<h2 id="2-2-mapreduce-code">2.2. MapReduce Code</h2>
<h3 id="2-2-1-the-map-function-is-represented-by-an-implementation-of-the-mapper-interface-which-declares-a-map-method-">2.2.1. The map function is represented by an implementation of the Mapper interface, which declares a map() method.</h3>
<p><a href="http://images.cnblogs.com/cnblogs_com/forfuture1978/WindowsLiveWriter/NotesforHadoopthedefinitiveguide_14109/clip_image020_2.jpg" target="_blank"><img src="&quot;clip_image020&quot;" alt="clip_image020"></a></p>
<h3 id="2-2-2-the-reduce-function-is-defined-using-a-reducer">2.2.2. The reduce function is defined using a Reducer</h3>
<p>l The input types of the reduce function must match the output type of the map function.</p>
<p><a href="http://images.cnblogs.com/cnblogs_com/forfuture1978/WindowsLiveWriter/NotesforHadoopthedefinitiveguide_14109/clip_image022_2.jpg" target="_blank"><img src="&quot;clip_image022&quot;" alt="clip_image022"></a></p>
<h3 id="2-2-3-the-code-runs-the-mapreduce-job">2.2.3. The code runs the MapReduce job</h3>
<p>l An input path is specified by calling the static addInputPath() method on FileInputFormat</p>
<p>n It can be a single file, a directory, or a file pattern.</p>
<p>n addInputPath() can be called more than once to use input from multiple paths.</p>
<p>l The output path is specified by the static setOutputPath() method on FileOutputFormat.</p>
<p>n It specifies a directory where the output files from the reducer functions are written.</p>
<p>n The directory shouldn’t exist before running the job</p>
<p>l The map and reduce types can be specified via the setMapperClass() and setReducerClass() methods.</p>
<p>l The setOutputKeyClass() and setOutputValueClass() methods control the output types for the map and the reduce functions, which are often the same.</p>
<p>n If they are different, then the map output types can be set using the methods setMapOutputKeyClass() and setMapOutputValueClass().</p>
<p>l The input types are controlled via the input format, which we have not explicitly set since we are using the default TextInputFormat.</p>
<p><a href="http://images.cnblogs.com/cnblogs_com/forfuture1978/WindowsLiveWriter/NotesforHadoopthedefinitiveguide_14109/clip_image024_2.jpg" target="_blank"><img src="&quot;clip_image024&quot;" alt="clip_image024"></a></p>
<h2 id="2-3-scaling-out">2.3. Scaling Out</h2>
<h3 id="2-3-1-mapreduce-data-flow-with-a-single-reduce-task">2.3.1. MapReduce data flow with a single reduce task</h3>
<p>l A MapReduce job is a unit of work that the client wants to be performed: it consists of the input data, the MapReduce program, and configuration information.</p>
<p>l Hadoop runs the job by dividing it into tasks, of which there are two types: map tasks and reduce tasks.</p>
<p>l There are two types of nodes that control the job execution process: a jobtracker and a number of tasktrackers.</p>
<p>n The jobtracker coordinates all the jobs run on the system by scheduling tasks to run on tasktrackers.</p>
<p>n Tasktrackers run tasks and send progress reports to the jobtracker, which keeps a record of the overall progress of each job.</p>
<p>n If a tasks fails, the jobtracker can reschedule it on a different tasktracker.</p>
<p>l Hadoop divides the input to a MapReduce job into fixed-size input splits.</p>
<p>l Hadoop creates one map task for each split, which runs the user defined map function for each record in the split.</p>
<p>l Hadoop does its best to run the map task on a node where the input data resides in HDFS.</p>
<p>n This is called the data locality optimization.</p>
<p>n This is why the optimal split size is the same as the block size: it is the largest size of input that can be guaranteed to be stored on a single node.</p>
<p>l Reduce tasks don’t have the advantage of data locality</p>
<p>n The input to a single reduce task is normally the output from all mappers.</p>
<p>n The output of the reduce is normally stored in HDFS for reliability.</p>
<p><a href="http://images.cnblogs.com/cnblogs_com/forfuture1978/WindowsLiveWriter/NotesforHadoopthedefinitiveguide_14109/clip_image026_2.jpg" target="_blank"><img src="&quot;clip_image026&quot;" alt="clip_image026"></a></p>
<h3 id="2-3-2-mapreduce-data-flow-with-multiple-reduce-tasks">2.3.2. MapReduce data flow with multiple reduce tasks</h3>
<p>The number of reduce tasks is not governed by the size of the input, but is specified independently.</p>
<p>l When there are multiple reducers, the map tasks partition their output, each creating one partition for each reduce task.</p>
<p>l There can be many keys (and their associated values) in each partition, but the records for every key are all in a single partition.</p>
<p>l The partitioning can be controlled by a user-defined partitioning function</p>
<p>n Normally the default partitioner which buckets keys using a hash function.</p>
<p>n conf.setPartitionerClass(HashPartitioner.class);</p>
<p>n conf.setNumReduceTasks(1);</p>
<p>l The data flow between map and reduce tasks is “the shuffle,” as each reduce task is fed by many map tasks.</p>
<p><a href="http://images.cnblogs.com/cnblogs_com/forfuture1978/WindowsLiveWriter/NotesforHadoopthedefinitiveguide_14109/clip_image028_2.jpg" target="_blank"><img src="&quot;clip_image028&quot;" alt="clip_image028"></a></p>
<p>l It’s also possible to have zero reduce tasks. This can be appropriate when you don’t need the shuffle since the processing can be carried out entirely in parallel</p>
<h1 id="3-mapreduce-types-and-formats">3. MapReduce Types and Formats</h1>
<h2 id="3-1-mapreduce-types">3.1. MapReduce Types</h2>
<p>l The map and reduce functions in Hadoop MapReduce have the following general form:</p>
<p><a href="http://images.cnblogs.com/cnblogs_com/forfuture1978/WindowsLiveWriter/NotesforHadoopthedefinitiveguide_14109/clip_image030_2.jpg" target="_blank"><img src="&quot;clip_image030&quot;" alt="clip_image030"></a></p>
<p><a href="http://images.cnblogs.com/cnblogs_com/forfuture1978/WindowsLiveWriter/NotesforHadoopthedefinitiveguide_14109/clip_image032_2.jpg" target="_blank"><img src="&quot;clip_image032&quot;" alt="clip_image032"></a></p>
<p>l The partition function operates on the intermediate key and value types (K2 and V2), and returns the partition index.</p>
<p><a href="http://images.cnblogs.com/cnblogs_com/forfuture1978/WindowsLiveWriter/NotesforHadoopthedefinitiveguide_14109/clip_image034_2.jpg" target="_blank"><img src="&quot;clip_image034&quot;" alt="clip_image034"></a></p>
<p><a href="http://images.cnblogs.com/cnblogs_com/forfuture1978/WindowsLiveWriter/NotesforHadoopthedefinitiveguide_14109/clip_image036_2.jpg" target="_blank"><img src="&quot;clip_image036&quot;" alt="clip_image036"></a></p>
<h3 id="3-1-1-configuration-of-mapreduce-types">3.1.1. Configuration of MapReduce types</h3>
<p><a href="http://images.cnblogs.com/cnblogs_com/forfuture1978/WindowsLiveWriter/NotesforHadoopthedefinitiveguide_14109/clip_image038_2.jpg" target="_blank"><img src="&quot;clip_image038&quot;" alt="clip_image038"></a></p>
<p>l Input types are set by the input format.</p>
<p>n For instance, a TextInputFormat generates keys of type LongWritable and values of type Text.</p>
<p>l A minimal MapReduce driver, with the defaults explicitly set</p>
<p><a href="http://images.cnblogs.com/cnblogs_com/forfuture1978/WindowsLiveWriter/NotesforHadoopthedefinitiveguide_14109/clip_image040_2.jpg" target="_blank"><img src="&quot;clip_image040&quot;" alt="clip_image040"></a></p>
<p>l The default input format is TextInputFormat, which produces keys of type LongWritable (the offset of the beginning of the line in the file) and values of type Text (the line of text).</p>
<p>l The setNumMapTasks() call does not necessarily set the number of map tasks to one</p>
<p>n The actual number of map tasks depends on the size of the input</p>
<p>l The default mapper is IdentityMapper</p>
<p><a href="http://images.cnblogs.com/cnblogs_com/forfuture1978/WindowsLiveWriter/NotesforHadoopthedefinitiveguide_14109/clip_image042_2.jpg" target="_blank"><img src="&quot;clip_image042&quot;" alt="clip_image042"></a></p>
<p>l Map tasks are run by MapRunner, the default implementation of MapRunnable that calls the Mapper’s map() method sequentially with each record.</p>
<p>l The default partitioner is HashPartitioner, which hashes a record’s key to determine which partition the record belongs in.</p>
<p>n Each partition is processed by a reduce task, so the number of partitions is equal to the number of reduce tasks for the job</p>
<p><a href="http://images.cnblogs.com/cnblogs_com/forfuture1978/WindowsLiveWriter/NotesforHadoopthedefinitiveguide_14109/clip_image044_2.jpg" target="_blank"><img src="&quot;clip_image044&quot;" alt="clip_image044"></a></p>
<p>l The default reducer is IdentityReducer</p>
<p><a href="http://images.cnblogs.com/cnblogs_com/forfuture1978/WindowsLiveWriter/NotesforHadoopthedefinitiveguide_14109/clip_image046_2.jpg" target="_blank"><img src="&quot;clip_image046&quot;" alt="clip_image046"></a></p>
<p>l Records are sorted by the MapReduce system before being presented to the reducer.</p>
<p>l The default output format is TextOutputFormat, which writes out records, one per line, by converting keys and values to strings and separating them with a tab character.</p>
<h2 id="3-2-input-formats">3.2. Input Formats</h2>
<h3 id="3-2-1-input-splits-and-records">3.2.1. Input Splits and Records</h3>
<p>l An input split is a chunk of the input that is processed by a single map.</p>
<p>l Each split is divided into records, and the map processes each record—a key-value pair—in turn.</p>
<p><a href="http://images.cnblogs.com/cnblogs_com/forfuture1978/WindowsLiveWriter/NotesforHadoopthedefinitiveguide_14109/clip_image048_2.jpg" target="_blank"><img src="&quot;clip_image048&quot;" alt="clip_image048"></a></p>
<p>l An InputSplit has a length in bytes, and a set of storage locations, which are just hostname strings.</p>
<p>l A split doesn’t contain the input data; it is just a reference to the data.</p>
<p>l The storage locations are used by the MapReduce system to place map tasks as close to the split’s data as possible</p>
<p>l The size is used to order the splits so that the largest get processed first</p>
<p>l An InputFormat is responsible for creating the input splits, and dividing them into records.</p>
<p><a href="http://images.cnblogs.com/cnblogs_com/forfuture1978/WindowsLiveWriter/NotesforHadoopthedefinitiveguide_14109/clip_image050_2.jpg" target="_blank"><img src="&quot;clip_image050&quot;" alt="clip_image050"></a></p>
<p>l The JobClient calls the getSplits() method, passing the desired number of map tasks as the numSplits argument.</p>
<p>l Having calculated the splits, the client sends them to the jobtracker, which uses their storage locations to schedule map tasks to process them on the tasktrackers.</p>
<p>l On a tasktracker, the map task passes the split to the getRecordReader() method on InputFormat to obtain a RecordReader for that split.</p>
<p>l A RecordReader is little more than an iterator over records, and the map task uses one to generate record key-value pairs, which it passes to the map function.</p>
<p><a href="http://images.cnblogs.com/cnblogs_com/forfuture1978/WindowsLiveWriter/NotesforHadoopthedefinitiveguide_14109/clip_image052_2.jpg" target="_blank"><img src="&quot;clip_image052&quot;" alt="clip_image052"></a></p>
<p>l The same key and value objects are used on each invocation of the map() method—only their contents are changed. If you need to change the value out of map, make a copy of the object you want to hold on to.</p>
<h3 id="3-2-2-fileinputformat">3.2.2. FileInputFormat</h3>
<p>l FileInputFormat is the base class for all implementations of InputFormat that use files as their data source.</p>
<p>l It provides two things: a place to define which files are included as the input to a job, and an implementation for generating splits for the input files.</p>
<p><a href="http://images.cnblogs.com/cnblogs_com/forfuture1978/WindowsLiveWriter/NotesforHadoopthedefinitiveguide_14109/clip_image054_2.jpg" target="_blank"><img src="&quot;clip_image054&quot;" alt="clip_image054"></a></p>
<p>l FileInputFormat input paths may represent a file, a directory, or, by using a glob, a collection of files and directories.</p>
<p><a href="http://images.cnblogs.com/cnblogs_com/forfuture1978/WindowsLiveWriter/NotesforHadoopthedefinitiveguide_14109/clip_image056_2.jpg" target="_blank"><img src="&quot;clip_image056&quot;" alt="clip_image056"></a></p>
<p>l To exclude certain files from the input, you can set a filter using the setInputPathFilter() method on FileInputFormat</p>
<p><a href="http://images.cnblogs.com/cnblogs_com/forfuture1978/WindowsLiveWriter/NotesforHadoopthedefinitiveguide_14109/clip_image058_2.jpg" target="_blank"><img src="&quot;clip_image058&quot;" alt="clip_image058"></a></p>
<p>l FileInputFormat splits only large files. Here “large” means larger than an HDFS block.</p>
<p>l Properties for controlling split size</p>
<p>n The minimum split size is usually 1 byte, by setting this to a value larger than the block size, they can force splits to be larger than a block.</p>
<p>n The maximum split size defaults to the maximum value that can be represented by a Java long type. It has an effect only when it is less than the block size, forcing splits to be smaller than a block.</p>
<h3 id="small-files-and-combinefileinputformat">Small files and CombineFileInputFormat</h3>
<p>l Hadoop works better with a small number of large files than a large number of small files.</p>
<p>l Where FileInputFormat creates a split per file, CombineFileInputFormat packs many files into each split so that each mapper has more to process.</p>
<p>l One technique for avoiding the many small files case is to merge small files into larger files by using a SequenceFile: the keys can act as filenames and the values as file contents.</p>
<h3 id="3-2-3-text-input">3.2.3. Text Input</h3>
<p>l TextInputFormat is the default InputFormat.</p>
<p>n Each record is a line of input.</p>
<p>n The key, a LongWritable, is the byte offset within the file of the beginning of the line.</p>
<p>n The value is the contents of the line, excluding any line terminators, and is packaged as a Text object.</p>
<p>l The logical records that FileInputFormats define do not usually fit neatly into HDFS blocks.</p>
<p>l A single file is broken into lines, and the line boundaries do not correspond with the HDFS block boundaries.</p>
<p>l Splits honor logical record boundaries</p>
<p>n The first split contains line 5, even though it spans the first and second block.</p>
<p>n The second split starts at line 6.</p>
<p>l Data-local maps will perform some remote reads.</p>
<p><a href="http://images.cnblogs.com/cnblogs_com/forfuture1978/WindowsLiveWriter/NotesforHadoopthedefinitiveguide_14109/clip_image060_2.jpg" target="_blank"><img src="&quot;clip_image060&quot;" alt="clip_image060"></a></p>
<h3 id="keyvaluetextinputformat">KeyValueTextInputFormat</h3>
<p>l It is common for each line in a file to be a key-value pair, separated by a delimiter such as a tab character.</p>
<p>l You can specify the separator via the key.value.separator.in.input.line property.</p>
<h3 id="nlineinputformat">NLineInputFormat</h3>
<p>l If you want your mappers to receive a fixed number of lines of input, then NLineInputFormat is the InputFormat to use.</p>
<p>l Like TextInputFormat, the keys are the byte offsets within the file and the values are the lines themselves.</p>
<p>l N refers to the number of lines of input that each mapper receives.</p>
<h3 id="3-2-4-binary-input">3.2.4. Binary Input</h3>
<h3 id="sequencefileinputformat">SequenceFileInputFormat</h3>
<p>l Hadoop’s sequence file format stores sequences of binary key-value pairs.</p>
<p>l To use data from sequence files as the input to MapReduce, you use SequenceFileInputFormat.</p>
<p>l The keys and values are determined by the sequence file, and you need to make sure that your map input types correspond.</p>
<p>l For example, if your sequence file has IntWritable keys and Text values, then the map signature would be Mapper<IntWritable, Text, K, V>.</p>
<h3 id="sequencefileastextinputformat">SequenceFileAsTextInputFormat</h3>
<p>l SequenceFileAsTextInputFormat is a variant of SequenceFileInputFormat that converts the sequence file’s keys and values to Text objects.</p>
<h3 id="sequencefileasbinaryinputformat">SequenceFileAsBinaryInputFormat</h3>
<p>l SequenceFileAsBinaryInputFormat is a variant of SequenceFileInputFormat that retrieves the sequence file’s keys and values as opaque binary objects.</p>
<p>l They are encapsulated as BytesWritable objects</p>
<h3 id="sequencefile">SequenceFile</h3>
<p>l Writing a SequenceFile</p>
<p>n To create a SequenceFile, use one of its createWriter() static methods, which returns a SequenceFile.Writer instance.</p>
<p>n specify a stream to write to (either a FSDataOutputStream or a FileSystem and Path pairing), a Configuration object, and the key and value types.</p>
<p>n Once you have a SequenceFile.Writer, you then write key-value pairs, using the append() method.</p>
<p>n Then when you’ve finished you call the close() method</p>
<p><a href="http://images.cnblogs.com/cnblogs_com/forfuture1978/WindowsLiveWriter/NotesforHadoopthedefinitiveguide_14109/clip_image062_2.jpg" target="_blank"><img src="&quot;clip_image062&quot;" alt="clip_image062"></a></p>
<p>l Reading a SequenceFile</p>
<p>n Reading sequence files from beginning to end is a matter of creating an instance of SequenceFile.Reader, and iterating over records by repeatedly invoking one of the next() methods.</p>
<p><a href="http://images.cnblogs.com/cnblogs_com/forfuture1978/WindowsLiveWriter/NotesforHadoopthedefinitiveguide_14109/clip_image064_2.jpg" target="_blank"><img src="&quot;clip_image064&quot;" alt="clip_image064"></a></p>
<p>l The SequenceFile Format</p>
<p>n A sequence file consists of a header followed by one or more records.</p>
<p>n The first three bytes of a sequence file are the bytes SEQ, which acts a magic number, followed by a single byte representing the version number.</p>
<p>n The header contains other fields including the names of the key and value classes, compression details, user-defined metadata, and the sync marker.</p>
<p>n The sync marker is used to allow a reader to synchronize to a record boundary from any position in the file.</p>
<p><a href="http://images.cnblogs.com/cnblogs_com/forfuture1978/WindowsLiveWriter/NotesforHadoopthedefinitiveguide_14109/clip_image066_2.jpg" target="_blank"><img src="&quot;clip_image066&quot;" alt="clip_image066"></a></p>
<h3 id="3-2-5-multiple-inputs">3.2.5. Multiple Inputs</h3>
<p>l The MultipleInputs class allows you to specify the InputFormat and Mapper to use on a per-path basis.</p>
<p><a href="http://images.cnblogs.com/cnblogs_com/forfuture1978/WindowsLiveWriter/NotesforHadoopthedefinitiveguide_14109/clip_image068_2.jpg" target="_blank"><img src="&quot;clip_image068&quot;" alt="clip_image068"></a></p>
<h2 id="3-3-output-formats">3.3. Output Formats</h2>
<h3 id="3-3-1-text-output">3.3.1. Text Output</h3>
<p>l The default output format, TextOutputFormat, writes records as lines of text.</p>
<p>l Its keys and values may be of any type, since TextOutputFormat turns them to strings by calling toString() on them.</p>
<p>l Each key-value pair is separated by a tab character, although that may be changed using the mapred.textoutputformat.separator property.</p>
<h3 id="3-3-2-binary-output">3.3.2. Binary Output</h3>
<p>l SequenceFileOutputFormat</p>
<p>l SequenceFileAsBinaryOutputFormat</p>
<p>l MapFileOutputFormat</p>
<h3 id="writing-a-mapfile">Writing a MapFile</h3>
<p>l You create an instance of MapFile.Writer, then call the append() method to add entries in order.</p>
<p>l Keys must be instances of WritableComparable, and values must be Writable</p>
<p><a href="http://images.cnblogs.com/cnblogs_com/forfuture1978/WindowsLiveWriter/NotesforHadoopthedefinitiveguide_14109/clip_image070_2.jpg" target="_blank"><img src="&quot;clip_image070&quot;" alt="clip_image070"></a></p>
<p>l If we look at the MapFile, we see it’s actually a directory containing two files called data and index:</p>
<p><a href="http://images.cnblogs.com/cnblogs_com/forfuture1978/WindowsLiveWriter/NotesforHadoopthedefinitiveguide_14109/clip_image072_2.jpg" target="_blank"><img src="&quot;clip_image072&quot;" alt="clip_image072"></a></p>
<p>l Both files are SequenceFiles. The data file contains all of the entries, in order:</p>
<p><a href="http://images.cnblogs.com/cnblogs_com/forfuture1978/WindowsLiveWriter/NotesforHadoopthedefinitiveguide_14109/clip_image074_2.jpg" target="_blank"><img src="&quot;clip_image074&quot;" alt="clip_image074"></a></p>
<p>l The index file contains a fraction of the keys, and contains a mapping from the key to that key’s offset in the data file:</p>
<p><a href="http://images.cnblogs.com/cnblogs_com/forfuture1978/WindowsLiveWriter/NotesforHadoopthedefinitiveguide_14109/clip_image076_2.jpg" target="_blank"><img src="&quot;clip_image076&quot;" alt="clip_image076"></a></p>
<h3 id="reading-a-mapfile">Reading a MapFile</h3>
<p>l you create a MapFile.Reader, then call the next() method until it returns false</p>
<h3 id="3-3-3-multiple-outputs">3.3.3. Multiple Outputs</h3>
<h3 id="multipleoutputformat">MultipleOutputFormat</h3>
<p>l MultipleOutputFormat allows you to write data to multiple files whose names are derived from the output keys and values.</p>
<p>n conf.setOutputFormat(StationNameMultipleTextOutputFormat.class);</p>
<p><a href="http://images.cnblogs.com/cnblogs_com/forfuture1978/WindowsLiveWriter/NotesforHadoopthedefinitiveguide_14109/clip_image078_2.jpg" target="_blank"><img src="&quot;clip_image078&quot;" alt="clip_image078"></a></p>
<h3 id="multipleoutputs">MultipleOutputs</h3>
<p>l MultipleOutputs can emit different types for each output.</p>
<p><a href="http://images.cnblogs.com/cnblogs_com/forfuture1978/WindowsLiveWriter/NotesforHadoopthedefinitiveguide_14109/clip_image080_2.jpg" target="_blank"><img src="&quot;clip_image080&quot;" alt="clip_image080"></a></p>
<h1 id="4-developing-a-mapreduce-application">4. Developing a MapReduce Application</h1>
<h2 id="4-1-the-configuration-api">4.1. The Configuration API</h2>
<p>l An instance of the Configuration class (found in the org.apache.hadoop.conf package) represents a collection of configuration properties and their values.</p>
<p>l Configurations read their properties from resources—XML files</p>
<p><a href="http://images.cnblogs.com/cnblogs_com/forfuture1978/WindowsLiveWriter/NotesforHadoopthedefinitiveguide_14109/clip_image082_2.jpg" target="_blank"><img src="&quot;clip_image082&quot;" alt="clip_image082"></a></p>
<p>l we can access its properties using a piece of code like this:</p>
<p><a href="http://images.cnblogs.com/cnblogs_com/forfuture1978/WindowsLiveWriter/NotesforHadoopthedefinitiveguide_14109/clip_image084_2.jpg" target="_blank"><img src="&quot;clip_image084&quot;" alt="clip_image084"></a></p>
<h2 id="4-2-configuring-the-development-environment">4.2. Configuring the Development Environment</h2>
<h3 id="4-2-1-managing-configuration">4.2.1. Managing Configuration</h3>
<p>l When developing Hadoop applications, it is common to switch between running the application locally and running it on a cluster.</p>
<p>l hadoop-local.xml</p>
<p><a href="http://images.cnblogs.com/cnblogs_com/forfuture1978/WindowsLiveWriter/NotesforHadoopthedefinitiveguide_14109/clip_image086_2.jpg" target="_blank"><img src="&quot;clip_image086&quot;" alt="clip_image086"></a></p>
<p>l hadoop-localhost.xml</p>
<p><a href="http://images.cnblogs.com/cnblogs_com/forfuture1978/WindowsLiveWriter/NotesforHadoopthedefinitiveguide_14109/clip_image088_2.jpg" target="_blank"><img src="&quot;clip_image088&quot;" alt="clip_image088"></a></p>
<p>l hadoop-cluster.xml</p>
<p><a href="http://images.cnblogs.com/cnblogs_com/forfuture1978/WindowsLiveWriter/NotesforHadoopthedefinitiveguide_14109/clip_image090_2.jpg" target="_blank"><img src="&quot;clip_image090&quot;" alt="clip_image090"></a></p>
<p><a href="http://images.cnblogs.com/cnblogs_com/forfuture1978/WindowsLiveWriter/NotesforHadoopthedefinitiveguide_14109/clip_image092_2.jpg" target="_blank"><img src="&quot;clip_image092&quot;" alt="clip_image092"></a></p>
<p>l With this setup, it is easy to use any configuration with the -conf command-line switch.</p>
<p>l For example, the following command shows a directory listing on the HDFS server running in pseudo-distributed mode on localhost:</p>
<p><a href="http://images.cnblogs.com/cnblogs_com/forfuture1978/WindowsLiveWriter/NotesforHadoopthedefinitiveguide_14109/clip_image094_2.jpg" target="_blank"><img src="&quot;clip_image094&quot;" alt="clip_image094"></a></p>
<h3 id="4-2-2-genericoptionsparser-tool-and-toolrunner">4.2.2. GenericOptionsParser, Tool, and ToolRunner</h3>
<p><a href="http://images.cnblogs.com/cnblogs_com/forfuture1978/WindowsLiveWriter/NotesforHadoopthedefinitiveguide_14109/clip_image096_2.jpg" target="_blank"><img src="&quot;clip_image096&quot;" alt="clip_image096"></a></p>
<p><a href="http://images.cnblogs.com/cnblogs_com/forfuture1978/WindowsLiveWriter/NotesforHadoopthedefinitiveguide_14109/clip_image098_2.jpg" target="_blank"><img src="&quot;clip_image098&quot;" alt="clip_image098"></a></p>
<h1 id="5-how-mapreduce-works">5. How MapReduce Works</h1>
<h2 id="5-1-anatomy-of-a-mapreduce-job-run">5.1. Anatomy of a MapReduce Job Run</h2>
<p>l There are four independent entities:</p>
<p>n The client, which submits the MapReduce job.</p>
<p>n The jobtracker, which coordinates the job run. The jobtracker is a Java application whose main class is JobTracker.</p>
<p>n The tasktrackers, which run the tasks that the job has been split into. Tasktrackers are Java applications whose main class is TaskTracker.</p>
<p>n The distributed filesystem, which is used for sharing job files between the other entities.</p>
<p><a href="http://images.cnblogs.com/cnblogs_com/forfuture1978/WindowsLiveWriter/NotesforHadoopthedefinitiveguide_14109/clip_image100_2.jpg" target="_blank"><img src="&quot;clip_image100&quot;" alt="clip_image100"></a></p>
<h3 id="5-1-1-job-submission">5.1.1. Job Submission</h3>
<p>l The runJob() method on JobClient creates a new JobClient instance and calls submitJob() on it.</p>
<p>l Having submitted the job, runJob() polls the job’s progress once a second, and reports the progress to the console if it has changed since the last report.</p>
<p>l When the job is complete, if it was successful, the job counters are displayed. Otherwise, the error that caused the job to fail is logged to the console.</p>
<h3 id="the-job-submission-process">The job submission process</h3>
<p>l Asks the jobtracker for a new job ID (by calling getNewJobId() on JobTracker)</p>
<p>l Checks the output specification of the job.</p>
<p>l Computes the input splits for the job.</p>
<p>l Copies the resources needed to run the job, including the job JAR file, the configuration file and the computed input splits, to the jobtracker’s filesystem in a directory named after the job ID.</p>
<p>l Tells the jobtracker that the job is ready for execution (by calling submitJob() on JobTracker)</p>
<h3 id="5-1-2-job-initialization">5.1.2. Job Initialization</h3>
<p>l When the JobTracker receives a call to its submitJob() method, it puts it into an internal queue from where the job scheduler will pick it up and initialize it.</p>
<p>l Initialization involves creating an object to represent the job being run, which encapsulates its tasks, and bookkeeping information to keep track of the tasks’ status and progress.</p>
<p>l To create the list of tasks to run, the job scheduler first retrieves the input splits computed by the JobClient from the shared filesystem.</p>
<p>l It then creates one map task for each split.</p>
<p>l Tasks are given IDs at this point.</p>
<h3 id="5-1-3-task-assignment">5.1.3. Task Assignment</h3>
<p>l Tasktrackers run a simple loop that periodically sends heartbeat method calls to the jobtracker.</p>
<p>l As a part of the heartbeat, a tasktracker will indicate whether it is ready to run a new task, and if it is, the jobtracker will allocate it a task, which it communicates to the tasktracker using the heartbeat return value</p>
<p>l Before it can choose a task for the tasktracker, the jobtracker must choose a job to select the task from according to priority.(setJobPriority() and FIFO)</p>
<p>l Tasktrackers have a fixed number of slots for map tasks and for reduce tasks.</p>
<p>l The default scheduler fills empty map task slots before reduce task slots</p>
<p>l To choose a reduce task the jobtracker simply takes the next in its list of yet-to-be-run reduce tasks, since there are no data locality considerations.</p>
<h3 id="5-1-4-task-execution">5.1.4. Task Execution</h3>
<p>l Now the tasktracker has been assigned a task, the next step is for it to run the task.</p>
<p>l First, it localizes the job JAR by copying it from the shared filesystem to the tasktracker’s filesystem.</p>
<p>l It also copies any files needed from the distributed cache by the application to the local disk</p>
<p>l Second, it creates a local working directory for the task, and un-jars the contents of the JAR into this directory.</p>
<p>l Third, it creates an instance of TaskRunner to run the task.</p>
<p>l TaskRunner launches a new Java Virtual Machine to run each task in</p>
<p>l It is however possible to reuse the JVM between tasks;</p>
<p>l The child process communicates with its parent through the umbilical interface.</p>
<h3 id="5-1-5-job-completion">5.1.5. Job Completion</h3>
<p>l When the jobtracker receives a notification that the last task for a job is complete, it changes the status for the job to “successful.” T</p>
<p>l hen, when the JobClient polls for status, it learns that the job has completed successfully, so it prints a message to tell the user, and then returns from the runJob() method.</p>
<p><a href="http://images.cnblogs.com/cnblogs_com/forfuture1978/WindowsLiveWriter/NotesforHadoopthedefinitiveguide_14109/clip_image102_2.jpg" target="_blank"><img src="&quot;clip_image102&quot;" alt="clip_image102"></a></p>
<h2 id="5-2-failures">5.2. Failures</h2>
<h3 id="5-2-1-task-failure">5.2.1. Task Failure</h3>
<p>l The most common way is when user code in the map or reduce task throws a runtime exception.</p>
<p>n the child JVM reports the error back to its parent tasktracker, before it exits.</p>
<p>n The error ultimately makes it into the user logs.</p>
<p>n The tasktracker marks the task attempt as failed, freeing up a slot to run another task.</p>
<p>l Another failure mode is the sudden exit of the child JVM</p>
<p>n the tasktracker notices that the process has exited, and marks the attempt as failed.</p>
<p>l Hanging tasks are dealt with differently.</p>
<p>n The tasktracker notices that it hasn’t received a progress update for a while, and proceeds to mark the task as failed.</p>
<p>n The child JVM process will be automatically killed after this period</p>
<p>l When the jobtracker is notified of a task attempt that has failed (by the tasktracker’s heartbeat call) it will reschedule execution of the task.</p>
<p>n The jobtracker will try to avoid rescheduling the task on a tasktracker where it has previously failed.</p>
<p>n If a task fails more than four times, it will not be retried further.</p>
<h3 id="5-2-2-tasktracker-failure">5.2.2. Tasktracker Failure</h3>
<p>l If a tasktracker fails by crashing, or running very slowly, it will stop sending heartbeats to the jobtracker (or send them very infrequently).</p>
<p>l The jobtracker will notice a tasktracker that has stopped sending heartbeats and remove it from its pool of tasktrackers to schedule tasks on.</p>
<p>l The jobtracker arranges for map tasks that were run and completed successfully on that tasktracker to be rerun if they belong to incomplete jobs, since their intermediate output residing on the failed tasktracker’s local filesystem may not be accessible to the reduce task. Any tasks in progress are also rescheduled.</p>
<h3 id="5-2-3-jobtracker-failure">5.2.3. Jobtracker Failure</h3>
<h2 id="5-3-shuffle-and-sort">5.3. Shuffle and Sort</h2>
<p><a href="http://images.cnblogs.com/cnblogs_com/forfuture1978/WindowsLiveWriter/NotesforHadoopthedefinitiveguide_14109/clip_image104_2.jpg" target="_blank"><img src="&quot;clip_image104&quot;" alt="clip_image104"></a></p>
<h3 id="5-3-1-the-map-side">5.3.1. The Map Side</h3>
<p>l When the map function starts producing output, it is not simply written to disk.</p>
<p>l Each map task has a circular memory buffer that it writes the output to.</p>
<p>l When the contents of the buffer reach a certain threshold size, a background thread will start to spill the contents to disk.</p>
<p>l Spills are written in round-robin fashion to the directories specified by the mapred.local.dir property</p>
<p>l Before it writes to disk, the thread first divides the data into partitions corresponding to the reducers that they will ultimately be sent to.</p>
<p>l Within each partition, the background thread performs an in-memory sort by key.</p>
<p>l Each time the memory buffer reaches the spill threshold, a new spill file is created, so after the map task has written its last output record there could be several spill files.</p>
<p>l Before the task is finished, the spill files are merged into a single partitioned and sorted output file.</p>
<p>l The output file’s partitions are made available to the reducers over HTTP.</p>
<p>l The number of worker threads used to serve the file partitions is controlled by the task tracker.http.threads property</p>
<h3 id="5-3-2-the-reduce-side">5.3.2. The Reduce Side</h3>
<p>l As map tasks complete successfully, they notify their parent tasktracker of the status update, which in turn notifies the jobtracker.</p>
<p>l for a given job, the jobtracker knows the mapping between map outputs and tasktrackers.</p>
<p>l A thread in the reducer periodically asks the jobtracker for map output locations until it has retrieved them all.</p>
<p>l The reduce task needs the map output for its particular partition from several map tasks across the cluster.</p>
<p>l The map tasks may finish at different times, so the reduce task starts copying their outputs as soon as each completes. This is known as the copy phase of the reduce task.</p>
<p>l The reduce task has a small number of copier threads so that it can fetch map outputs in parallel.</p>
<p>l As the copies accumulate on disk, a background thread merges them into larger, sorted files.</p>
<p>l When all the map outputs have been copied, the reduce task moves into the sort phase (which should properly be called the merge phase, as the sorting was carried out on the map side), which merges the map outputs, maintaining their sort ordering.</p>
<p>l During the reduce phase the reduce function is invoked for each key in the sorted output. The output of this phase is written directly to the output filesystem, typically HDFS.
来源： &lt;<a href="http://www.cnblogs.com/forfuture1978/archive/2010/02/27/1674955.html" target="_blank">Notes for Hadoop the definitive guide - 觉先 - 博客园</a>&gt; </p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/hadoop/">hadoop</a></li></span></span> | <span class="tags">Tagged <a href="/tags/hadoop/" class="label label-primary">hadoop</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:36"datetime="2014-03-07 09:54:36"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-hadoop--NotesforHadoopthedefinitiveguide/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-hadoop--NotesforHadoopthedefinitiveguide" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-hadoop--HDFS写入和读取流程/">HDFS写入和读取流程</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:36.000Z"> <a href="/2014/02/02/2014-02-02-hadoop--HDFS写入和读取流程/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="hdfs-">HDFS写入和读取流程</h1>
<p>您还未登录！|<a href="https://passport.csdn.net/account/login" target="_blank">登录</a>|<a href="https://passport.csdn.net/account/register" target="_blank">注册</a>|<a href="https://passport.csdn.net/help/faq" target="_blank">帮助</a></p>
<ul>
<li><a href="http://www.csdn.net/" target="_blank">首页</a></li>
<li><a href="http://news.csdn.net/" target="_blank">业界</a></li>
<li><a href="http://mobile.csdn.net/" target="_blank">移动</a></li>
<li><a href="http://cloud.csdn.net/" target="_blank">云计算</a></li>
<li><a href="http://sd.csdn.net/" target="_blank">研发</a></li>
<li><a href="http://bbs.csdn.net/" target="_blank">论坛</a></li>
<li><a href="http://blog.csdn.net/" target="_blank">博客</a></li>
<li><a href="http://download.csdn.net/" target="_blank">下载</a></li>
<li><h2 id="-"><a href="">更多</a></h2>
</li>
</ul>
<h1 id="-guisu-http-blog-csdn-net-hguisu-"><a href="http://blog.csdn.net/hguisu" target="_blank">guisu，程序人生。</a></h1>
<h2 id="-a-clever-person-solves-a-problem-a-wise-person-avoids-it-">能干的人解决问题。智慧的人绕开问题(A clever person solves a problem. A wise person avoids it)</h2>
<ul>
<li><a href="http://blog.csdn.net/hguisu?viewmode=contents" target="_blank"><img src="" alt="">目录视图</a></li>
<li><a href="http://blog.csdn.net/hguisu?viewmode=list" target="_blank"><img src="" alt="">摘要视图</a></li>
<li><a href="http://blog.csdn.net/hguisu/rss/list" target="_blank"><img src="" alt="">订阅</a>
<a href="http://blog.csdn.net/blogdevteam/article/details/11889881" target="_blank">2014年1月微软MVP申请开始啦！</a>      <a href="http://bbs.csdn.net/topics/390594487" target="_blank">CSDN社区中秋晒福利活动正式开始啦！</a>        <a href="http://www.csdn.net/article/2013-09-17/2816962" target="_blank">专访钟声：Java程序员，上班那点事儿</a>      <a href="http://blog.csdn.net/adali/article/details/9813651" target="_blank">独一无二的职位：开源社区经理</a>      <a href="http://blog.csdn.net/blogdevteam/article/details/11975399" target="_blank">“说说家乡的互联网”主题有奖征文</a></li>
</ul>
<h3 id="-hdfs-"><a href="">HDFS写入和读取流程</a></h3>
<p>分类： <a href="http://blog.csdn.net/hguisu/article/category/1072794" target="_blank">云计算hadoop</a>  2012-02-14 23:50 8282人阅读 <a href="">评论</a>(17) <a href="&quot;收藏&quot;">收藏</a> <a href="&quot;举报&quot;">举报</a>
<a href="http://blog.csdn.net/tag/details.html?tag=%e5%ad%98%e5%82%a8" target="_blank">存储</a><a href="http://blog.csdn.net/tag/details.html?tag=hadoop" target="_blank">hadoop</a><a href="http://blog.csdn.net/tag/details.html?tag=image" target="_blank">image</a><a href="http://blog.csdn.net/tag/details.html?tag=system" target="_blank">system</a><a href="http://blog.csdn.net/tag/details.html?tag=mysql" target="_blank">mysql</a></p>
<p>目录<a href="&quot;系统根据文章中H1到H6标签自动生成文章目录&quot;">(?)</a><a href="&quot;展开&quot;">[+]</a></p>
<ol>
<li><a href="">一HDFS</a></li>
<li><a href="">二HDFS的体系结构</a></li>
<li><p><a href="">三读写流程</a></p>
</li>
<li><p><a href="">GFS论文提到的文件读取简单流程</a></p>
</li>
<li><a href=""></a></li>
<li><a href=""></a></li>
<li><a href=""></a></li>
<li><a href="">详细流程</a></li>
<li><a href=""></a></li>
<li><p><a href="">GFS论文提到的写入文件简单流程</a></p>
</li>
<li><p><a href="">详细流程</a></p>
</li>
<li><a href=""></a><h2 id="-hdfs"><a href=""></a>一、HDFS</h2>
</li>
</ol>
<p>HDFS全称是Hadoop Distributed System。HDFS是为以流的方式存取大文件而设计的。适用于几百MB，GB以及TB，并写一次读多次的场合。而对于低延时数据访问、大量小文件、同时写和任意的文件修改，则并不是十分适合。</p>
<p>目前HDFS支持的使用接口除了Java的还有，Thrift、C、FUSE、WebDAV、HTTP等。HDFS是以block-sized chunk组织其文件内容的，默认的block大小为64MB，对于不足64MB的文件，其会占用一个block，但实际上不用占用实际硬盘上的64MB，这可以说是HDFS是在文件系统之上架设的一个中间层。之所以将默认的block大小设置为64MB这么大，是因为block-sized对于文件定位很有帮助，同时大文件更使传输的时间远大于文件寻找的时间，这样可以最大化地减少文件定位的时间在整个文件获取总时间中的比例 。</p>
<h2 id="-hdfs-"><a href=""></a>二、HDFS的体系结构</h2>
<p>构成HDFS主要是Namenode（master）和一系列的Datanode（workers）。Namenode是管理HDFS的目录树和相关的文件元数据，这些信息是以&quot;namespace image&quot;和&quot;edit log&quot;两个文件形式存放在本地磁盘，但是这些文件是在HDFS每次重启的时候重新构造出来的。Datanode则是存取文件实际内容的节点，Datanodes会定时地将block的列表汇报给Namenode。</p>
<p>由于Namenode是元数据存放的节点，如果Namenode挂了那么HDFS就没法正常运行，因此一般使用将元数据持久存储在本地或远程的机器上，或者使用secondary namenode来定期同步Namenode的元数据信息，secondary namenode有点类似于MySQL的Master/Salves中的Slave，&quot;edit log&quot;就类似&quot;bin log&quot;。如果Namenode出现了故障，一般会将原Namenode中持久化的元数据拷贝到secondary namenode中，使secondary namenode作为新的Namenode运行起来。</p>
<pre><code>                        ![]()
</code></pre><h2 id="-"><a href=""></a>三、读写流程</h2>
<h3 id="-gfs-"><a href=""></a>GFS论文提到的文件读取简单流程：</h3>
<h3 id="-"><a href=""></a></h3>
<h3 id="-"><a href=""></a>                <img src="" alt=""></h3>
<h3 id="-"><a href=""></a><em>**</em></h3>
<h3 id="-reading-data-from-hdfs-http-blog-endlesscode-com-wp-content-uploads-2010-06-reading-data-from-hdfs-png-reading-data-from-hdfs-"><a href=""></a><strong>详细流程：</strong><img src="http://blog.endlesscode.com/wp-content/uploads/2010/06/reading-data-from-hdfs.png" alt="reading data from hdfs" title="reading data from hdfs"></h3>
<p>文件读取的过程如下：</p>
<ol>
<li>使用HDFS提供的客户端开发库Client，向远程的Namenode发起RPC请求；</li>
<li>Namenode会视情况返回文件的部分或者全部block列表，对于每个block，Namenode都会返回有该block拷贝的DataNode地址；</li>
<li>客户端开发库Client会选取离客户端最接近的DataNode来读取block；如果客户端本身就是DataNode,那么将从本地直接获取数据.</li>
<li>读取完当前block的数据后，关闭与当前的DataNode连接，并为读取下一个block寻找最佳的DataNode；</li>
<li>当读完列表的block后，且文件读取还没有结束，客户端开发库会继续向Namenode获取下一批的block列表。</li>
<li>读取完一个block都会进行checksum验证，如果读取datanode时出现错误，客户端会通知Namenode，然后再从下一个拥有该block拷贝的datanode继续读。</li>
</ol>
<h3 id="-"><a href=""></a></h3>
<h3 id="-gfs-"><a href=""></a>GFS论文提到的写入文件简单流程：</h3>
<pre><code>                                 ![]()             
</code></pre><h2 id="-writing-data-to-hdfs-http-blog-endlesscode-com-wp-content-uploads-2010-06-writing-data-to-hdfs-png-writing-data-to-hdfs-"><a href=""></a>详细流程：<img src="http://blog.endlesscode.com/wp-content/uploads/2010/06/writing-data-to-hdfs.png" alt="writing data to hdfs" title="writing data to hdfs"></h2>
<p>写入文件的过程比读取较为复杂：</p>
<ol>
<li>使用HDFS提供的客户端开发库Client，向远程的Namenode发起RPC请求；</li>
<li>Namenode会检查要创建的文件是否已经存在，创建者是否有权限进行操作，成功则会为文件<strong>创建一个记录</strong>，否则会让客户端抛出异常；</li>
<li>当客户端开始写入文件的时候，开发库会将文件切分成多个packets，并在内部以数据队列&quot;data queue&quot;的形式管理这些packets，并向Namenode申请新的blocks，获取用来存储replicas的合适的datanodes列表，列表的大小根据在Namenode中对replication的设置而定。</li>
<li>开始以pipeline（管道）的形式将packet写入所有的replicas中。开发库把packet以流的方式写入第一个datanode，该datanode把该packet存储之后，再将其传递给在此pipeline中的下一个datanode，直到最后一个datanode，这种写数据的方式呈流水线的形式。</li>
<li>最后一个datanode成功存储之后会返回一个ack packet，在pipeline里传递至客户端，在客户端的开发库内部维护着&quot;ack queue&quot;，成功收到datanode返回的ack packet后会从&quot;ack queue&quot;移除相应的packet。</li>
<li>如果传输过程中，有某个datanode出现了故障，那么当前的pipeline会被关闭，出现故障的datanode会从当前的pipeline中移除，剩余的block会继续剩下的datanode中继续以pipeline的形式传输，同时Namenode会分配一个新的datanode，保持replicas设定的数量。</li>
</ol>
<h2 id="-"><a href=""></a></h2>
<p>分享到： <a href="&quot;分享到新浪微博&quot;"></a><a href="&quot;分享到腾讯微博&quot;"></a></p>
<ol>
<li>上一篇：<a href="http://blog.csdn.net/hguisu/article/details/7256833" target="_blank">Hadoop Hive sql语法详解</a></li>
<li>下一篇：<a href="http://blog.csdn.net/hguisu/article/details/7261145" target="_blank">Hadoop HDFS分布式文件系统设计要点与架构</a></li>
</ol>
<p>顶 3 踩 1
查看评论<a href=""></a></p>
<p>3楼 <a href="http://blog.csdn.net/huangbo1988911" target="_blank">huangbo1988911</a> 2012-04-09 11:25发表 <a href="&quot;回复&quot;">[回复]</a>  <a href="&quot;引用&quot;">[引用]</a> <a href="&quot;举报&quot;">[举报]</a><a href="http://blog.csdn.net/huangbo1988911" target="_blank"><img src="" alt=""></a>在写数据的过程中，一个文件被分割成很多blocks，这些block是按顺序一个个操作的，还是并发的进行传输的？Re: <a href="http://blog.csdn.net/hguisu" target="_blank">真实的归宿</a> 2012-04-09 12:45发表 <a href="&quot;回复&quot;">[回复]</a>  <a href="&quot;引用&quot;">[引用]</a> <a href="&quot;举报&quot;">[举报]</a><a href="http://blog.csdn.net/hguisu" target="_blank"><img src="" alt=""></a>回复huangbo1988911：写数据的是以流的方式传输，即管道的方式，一个一个block顺序传输。而不是像树形拓扑结构那样分散传输。Re: <a href="http://blog.csdn.net/huangbo1988911" target="_blank">huangbo1988911</a> 2012-04-17 18:03发表 <a href="&quot;回复&quot;">[回复]</a>  <a href="&quot;引用&quot;">[引用]</a> <a href="&quot;举报&quot;">[举报]</a><a href="http://blog.csdn.net/huangbo1988911" target="_blank"><img src="" alt=""></a>回复hguisu：您好，很感谢您回答我，但是我仍有点疑惑，hdfs中的文件大小区分为：chunk&lt;packet&lt;block,在每个packet的传输到多个DN（datanode）的过程中是以pipeline方式，但是当其中一个block在以这种方式传输时，其他的block是要等待还是并发的进行呢？谢谢！Re: <a href="http://blog.csdn.net/hguisu" target="_blank">真实的归宿</a> 2012-04-20 16:23发表 <a href="&quot;回复&quot;">[回复]</a>  <a href="&quot;引用&quot;">[引用]</a> <a href="&quot;举报&quot;">[举报]</a><a href="http://blog.csdn.net/hguisu" target="_blank"><img src="" alt=""></a>回复huangbo1988911：管道方式，即是队列方式传输。只能一个block传完了，接着传下个block。Re: <a href="http://blog.csdn.net/huangbo1988911" target="_blank">huangbo1988911</a> 2012-04-30 18:18发表 <a href="&quot;回复&quot;">[回复]</a>  <a href="&quot;引用&quot;">[引用]</a> <a href="&quot;举报&quot;">[举报]</a><a href="http://blog.csdn.net/huangbo1988911" target="_blank"><img src="" alt=""></a>回复hguisu：你好！如果这样，那hdfs的并发写实如何体现的呢？Re: <a href="http://blog.csdn.net/hguisu" target="_blank">真实的归宿</a> 2012-05-02 09:29发表 <a href="&quot;回复&quot;">[回复]</a>  <a href="&quot;引用&quot;">[引用]</a> <a href="&quot;举报&quot;">[举报]</a><a href="http://blog.csdn.net/hguisu" target="_blank"><img src="" alt=""></a>回复huangbo1988911：hdfs没有并发写入。Re: <a href="http://blog.csdn.net/huangbo1988911" target="_blank">huangbo1988911</a> 2012-05-03 23:39发表 <a href="&quot;回复&quot;">[回复]</a>  <a href="&quot;引用&quot;">[引用]</a> <a href="&quot;举报&quot;">[举报]</a><a href="http://blog.csdn.net/huangbo1988911" target="_blank"><img src="" alt=""></a>回复hguisu：这样的话，那hadoop是比较适合大数据的处理了，对于文件的写的速度并没有多大的提高了?Re: <a href="http://blog.csdn.net/hguisu" target="_blank">真实的归宿</a> 2012-05-04 09:40发表 <a href="&quot;回复&quot;">[回复]</a>  <a href="&quot;引用&quot;">[引用]</a> <a href="&quot;举报&quot;">[举报]</a><a href="http://blog.csdn.net/hguisu" target="_blank"><img src="" alt=""></a>回复huangbo1988911：hadoop本来就是通往云服务的捷径，为处理超大数据集而准备。Re: <a href="http://blog.csdn.net/huangbo1988911" target="_blank">huangbo1988911</a> 2012-05-07 10:57发表 <a href="&quot;回复&quot;">[回复]</a>  <a href="&quot;引用&quot;">[引用]</a> <a href="&quot;举报&quot;">[举报]</a><a href="http://blog.csdn.net/huangbo1988911" target="_blank"><img src="" alt=""></a>回复hguisu：这样hadoop的主要优势是在map/reduce那一块，而其文件系统有什么样的优势呢（在文件的读写方面，和其他的文件系统）？Re: <a href="http://blog.csdn.net/hguisu" target="_blank">真实的归宿</a> 2012-05-07 11:50发表 <a href="&quot;回复&quot;">[回复]</a>  <a href="&quot;引用&quot;">[引用]</a> <a href="&quot;举报&quot;">[举报]</a><a href="http://blog.csdn.net/hguisu" target="_blank"><img src="" alt=""></a>回复huangbo1988911：hdfs可以存储超大数据，而map/reduce要处理的数据存储在hdfs上，即MR分布式运算。Re: <a href="http://blog.csdn.net/huangbo1988911" target="_blank">huangbo1988911</a> 2012-05-09 22:35发表 <a href="&quot;回复&quot;">[回复]</a>  <a href="&quot;引用&quot;">[引用]</a> <a href="&quot;举报&quot;">[举报]</a><a href="http://blog.csdn.net/huangbo1988911" target="_blank"><img src="" alt=""></a>回复hguisu： 那多个文件同时向hdfs写入是如何进行的呢？Re: <a href="http://blog.csdn.net/huangbo1988911" target="_blank">huangbo1988911</a> 2012-05-09 00:39发表 <a href="&quot;回复&quot;">[回复]</a>  <a href="&quot;引用&quot;">[引用]</a> <a href="&quot;举报&quot;">[举报]</a><a href="http://blog.csdn.net/huangbo1988911" target="_blank"><img src="" alt=""></a>回复hguisu：恩，hdfs相对于其他的文件系统，除了更适合存储大数据以外，而且有很强的容错能力，但是对数据的读写等，没有并发性，只是采用了管道的方式，这可能是它的一个小缺点吧。2楼 <a href="http://blog.csdn.net/CD_xiaoxin" target="_blank">CD_xiaoxin</a> 2012-03-19 09:44发表 <a href="&quot;回复&quot;">[回复]</a>  <a href="&quot;引用&quot;">[引用]</a> <a href="&quot;举报&quot;">[举报]</a><a href="http://blog.csdn.net/CD_xiaoxin" target="_blank"><img src="" alt=""></a>很详细 很有帮助 谢谢1楼 <a href="http://blog.csdn.net/lin_FS" target="_blank">lin_FS</a> 2012-03-16 10:01发表 <a href="&quot;回复&quot;">[回复]</a>  <a href="&quot;引用&quot;">[引用]</a> <a href="&quot;举报&quot;">[举报]</a><a href="http://blog.csdn.net/lin_FS" target="_blank"><img src="" alt=""></a>client端的那个queue是在内存中，还是写在临时文件里了？Re: <a href="http://blog.csdn.net/hguisu" target="_blank">真实的归宿</a> 2012-03-19 09:43发表 <a href="&quot;回复&quot;">[回复]</a>  <a href="&quot;引用&quot;">[引用]</a> <a href="&quot;举报&quot;">[举报]</a><a href="http://blog.csdn.net/hguisu" target="_blank"><img src="" alt=""></a>回复lin_FS：client分割数据成一个个block（packet）这些数据都不在内存中，你可以想象，如果一个数据是100G，它你那个放进内存吗？Re: <a href="http://blog.csdn.net/lin_FS" target="_blank">lin_FS</a> 2012-03-21 17:26发表 <a href="&quot;回复&quot;">[回复]</a>  <a href="&quot;引用&quot;">[引用]</a> <a href="&quot;举报&quot;">[举报]</a><a href="http://blog.csdn.net/lin_FS" target="_blank"><img src="" alt=""></a>在client端， 多个block（packet）组成一个队列，然后可以想象把文件（100G）分成若干个packet，如果队列满了就根本写不进去数据了，根本不会出现你想象的那种情况。我想了解的是，这个队列在内存中还是以文件的形式，呵呵Re: <a href="http://blog.csdn.net/hguisu" target="_blank">真实的归宿</a> 2012-03-31 18:47发表 <a href="&quot;回复&quot;">[回复]</a>  <a href="&quot;引用&quot;">[引用]</a> <a href="&quot;举报&quot;">[举报]</a><a href="http://blog.csdn.net/hguisu" target="_blank"><img src="" alt=""></a>回复lin_FS：这个队列肯定是文件的形式存在的。
您还没有登录,请<a href="">[登录]</a>或<a href="http://passport.csdn.net/account/register?from=http%3A%2F%2Fblog.csdn.net%2Fhguisu%2Farticle%2Fdetails%2F7259716" target="_blank">[注册]</a></p>
<p>/* 以上用户言论只代表其个人观点，不代表CSDN网站的观点或立场<a href=""></a><a href=""></a></p>
<p><a href="">hguisu</a>
<a href="&quot;回到顶部&quot;"><img src="" alt="TOP"></a></p>
<p>个人资料</p>
<p><a href="http://my.csdn.net/hguisu" target="_blank"><img src="&quot;访问我的空间&quot;" alt=""></a>
<a href="http://my.csdn.net/hguisu" target="_blank">真实的归宿</a></p>
<p><a href="&quot;[加关注]&quot;"></a> <a href="&quot;[发私信]&quot;"></a>
<a href="http://medal.blog.csdn.net/allmedal.aspx" target="_blank"><img src="" alt=""></a></p>
<ul>
<li>访问：481035次</li>
<li>积分：6666分</li>
<li><p>排名：第614名</p>
</li>
<li><p>原创：190篇</p>
</li>
<li>转载：1篇</li>
<li>译文：0篇</li>
<li>评论：313条</li>
</ul>
<p>文章分类</p>
<ul>
<li><a href="http://blog.csdn.net/hguisu/article/category/1253451" target="_blank">操作系统</a>(5)</li>
<li><a href="http://blog.csdn.net/hguisu/article/category/796967" target="_blank">Linux</a>(17)</li>
<li><a href="http://blog.csdn.net/hguisu/article/category/796963" target="_blank">MySQL</a>(12)</li>
<li><a href="http://blog.csdn.net/hguisu/article/category/796962" target="_blank">PHP</a>(41)</li>
<li><a href="http://blog.csdn.net/hguisu/article/category/1104862" target="_blank">PHP内核</a>(11)</li>
<li><a href="http://blog.csdn.net/hguisu/article/category/796968" target="_blank">技术人生</a>(7)</li>
<li><a href="http://blog.csdn.net/hguisu/article/category/1054628" target="_blank">数据结构与算法</a>(27)</li>
<li><a href="http://blog.csdn.net/hguisu/article/category/1072794" target="_blank">云计算hadoop</a>(20)</li>
<li><a href="http://blog.csdn.net/hguisu/article/category/1075597" target="_blank">网络知识</a>(7)</li>
<li><a href="http://blog.csdn.net/hguisu/article/category/1080443" target="_blank">c/c++</a>(22)</li>
<li><a href="http://blog.csdn.net/hguisu/article/category/1099674" target="_blank">memcache</a>(5)</li>
<li><a href="http://blog.csdn.net/hguisu/article/category/1111071" target="_blank">HipHop</a>(2)</li>
<li><a href="http://blog.csdn.net/hguisu/article/category/1112019" target="_blank">计算机原理</a>(4)</li>
<li><a href="http://blog.csdn.net/hguisu/article/category/1114530" target="_blank">Java</a>(7)</li>
<li><a href="http://blog.csdn.net/hguisu/article/category/1122753" target="_blank">socket网络编程</a>(5)</li>
<li><a href="http://blog.csdn.net/hguisu/article/category/1133340" target="_blank">设计模式</a>(26)</li>
<li><a href="http://blog.csdn.net/hguisu/article/category/1151353" target="_blank">AOP</a>(2)</li>
<li><a href="http://blog.csdn.net/hguisu/article/category/1152364" target="_blank">重构</a>(11)</li>
<li><a href="http://blog.csdn.net/hguisu/article/category/1173389" target="_blank">重构与模式</a>(1)</li>
<li><a href="http://blog.csdn.net/hguisu/article/category/1209788" target="_blank">大数据处理</a>(11)</li>
<li><a href="http://blog.csdn.net/hguisu/article/category/1230933" target="_blank">搜索引擎Search Engine</a>(15)</li>
<li><a href="http://blog.csdn.net/hguisu/article/category/1302430" target="_blank">HTML5</a>(1)</li>
<li><a href="http://blog.csdn.net/hguisu/article/category/1309674" target="_blank">Android</a>(1)</li>
<li><a href="http://blog.csdn.net/hguisu/article/category/1422000" target="_blank">webserver</a>(3)</li>
<li><p><a href="http://blog.csdn.net/hguisu/article/category/1429288" target="_blank">NOSQL</a>(6)
文章存档</p>
</li>
<li><p><a href="http://blog.csdn.net/hguisu/article/month/2013/09" target="_blank">2013年09月</a>(2)</p>
</li>
<li><a href="http://blog.csdn.net/hguisu/article/month/2013/08" target="_blank">2013年08月</a>(1)</li>
<li><a href="http://blog.csdn.net/hguisu/article/month/2013/07" target="_blank">2013年07月</a>(2)</li>
<li><a href="http://blog.csdn.net/hguisu/article/month/2013/06" target="_blank">2013年06月</a>(3)</li>
<li><a href="http://blog.csdn.net/hguisu/article/month/2013/05" target="_blank">2013年05月</a>(3)</li>
<li><a href="http://blog.csdn.net/hguisu/article/month/2013/03" target="_blank">2013年03月</a>(3)</li>
<li><a href="http://blog.csdn.net/hguisu/article/month/2013/02" target="_blank">2013年02月</a>(2)</li>
<li><a href="http://blog.csdn.net/hguisu/article/month/2013/01" target="_blank">2013年01月</a>(2)</li>
<li><a href="http://blog.csdn.net/hguisu/article/month/2012/12" target="_blank">2012年12月</a>(4)</li>
<li><a href="http://blog.csdn.net/hguisu/article/month/2012/11" target="_blank">2012年11月</a>(3)</li>
<li><a href="http://blog.csdn.net/hguisu/article/month/2012/10" target="_blank">2012年10月</a>(2)</li>
<li><a href="http://blog.csdn.net/hguisu/article/month/2012/09" target="_blank">2012年09月</a>(15)</li>
<li><a href="http://blog.csdn.net/hguisu/article/month/2012/08" target="_blank">2012年08月</a>(6)</li>
<li><a href="http://blog.csdn.net/hguisu/article/month/2012/07" target="_blank">2012年07月</a>(8)</li>
<li><a href="http://blog.csdn.net/hguisu/article/month/2012/06" target="_blank">2012年06月</a>(14)</li>
<li><a href="http://blog.csdn.net/hguisu/article/month/2012/05" target="_blank">2012年05月</a>(29)</li>
<li><a href="http://blog.csdn.net/hguisu/article/month/2012/04" target="_blank">2012年04月</a>(26)</li>
<li><a href="http://blog.csdn.net/hguisu/article/month/2012/03" target="_blank">2012年03月</a>(27)</li>
<li><a href="http://blog.csdn.net/hguisu/article/month/2012/02" target="_blank">2012年02月</a>(18)</li>
<li><a href="http://blog.csdn.net/hguisu/article/month/2011/12" target="_blank">2011年12月</a>(7)</li>
<li><a href="http://blog.csdn.net/hguisu/article/month/2011/01" target="_blank">2011年01月</a>(8)</li>
<li><a href="http://blog.csdn.net/hguisu/article/month/2010/07" target="_blank">2010年07月</a>(6)</li>
<li><a href="http://blog.csdn.net/hguisu/article/month/2007/12" target="_blank">2007年12月</a>(2)</li>
</ul>
<p>展开</p>
<p>阅读排行</p>
<ul>
<li><a href="http://blog.csdn.net/hguisu/article/details/7237395" title="Hadoop集群配置（最全面总结）" target="_blank">Hadoop集群配置（最全面总结）</a>(23024)</li>
<li><a href="http://blog.csdn.net/hguisu/article/details/7527842" title="设计模式（五）适配器模式Adapter（结构型）" target="_blank">设计模式（五）适配器模式Adapter（结构型）</a>(21421)</li>
<li><a href="http://blog.csdn.net/hguisu/article/details/7244413" title="hbase安装配置（整合到hadoop）" target="_blank">hbase安装配置（整合到hadoop）</a>(20780)</li>
<li><a href="http://blog.csdn.net/hguisu/article/details/7453390" title="socket阻塞与非阻塞，同步与异步、I/O模型" target="_blank">socket阻塞与非阻塞，同步与异步、I/O模型</a>(12788)</li>
<li><a href="http://blog.csdn.net/hguisu/article/details/7282050" title="Hadoop Hive与Hbase整合" target="_blank">Hadoop Hive与Hbase整合</a>(11869)</li>
<li><a href="http://blog.csdn.net/hguisu/article/details/7558249" title="设计模式 ( 十八 ) 策略模式Strategy（对象行为型）" target="_blank">设计模式 ( 十八 ) 策略模式Strategy（对象行为型）</a>(11737)</li>
<li><a href="http://blog.csdn.net/hguisu/article/details/7786014" title="B-树和B+树的应用：数据搜索和数据库索引" target="_blank">B-树和B+树的应用：数据搜索和数据库索引</a>(11507)</li>
<li><a href="http://blog.csdn.net/hguisu/article/details/5731880" title="Mysql 多表联合查询效率分析及优化" target="_blank">Mysql 多表联合查询效率分析及优化</a>(10454)</li>
<li><a href="http://blog.csdn.net/hguisu/article/details/7244991" title="谷歌三大核心技术（三）Google BigTable中文版" target="_blank">谷歌三大核心技术（三）Google BigTable中文版</a>(9958)</li>
<li><p><a href="&quot;HDFS写入和读取流程&quot;">HDFS写入和读取流程</a>(8282)
评论排行</p>
</li>
<li><p><a href="http://blog.csdn.net/hguisu/article/details/7558249" title="设计模式 ( 十八 ) 策略模式Strategy（对象行为型）" target="_blank">设计模式 ( 十八 ) 策略模式Strategy（对象行为型）</a>(33)</p>
</li>
<li><a href="&quot;HDFS写入和读取流程&quot;">HDFS写入和读取流程</a>(17)</li>
<li><a href="http://blog.csdn.net/hguisu/article/details/7529194" title="设计模式（六）桥连模式Bridge（结构型）" target="_blank">设计模式（六）桥连模式Bridge（结构型）</a>(14)</li>
<li><a href="http://blog.csdn.net/hguisu/article/details/7505909" title="设计模式（一）工厂模式Factory（创建型）" target="_blank">设计模式（一）工厂模式Factory（创建型）</a>(13)</li>
<li><a href="http://blog.csdn.net/hguisu/article/details/7880288" title="海量数据处理算法—Bit-Map" target="_blank">海量数据处理算法—Bit-Map</a>(13)</li>
<li><a href="http://blog.csdn.net/hguisu/article/details/7237395" title="Hadoop集群配置（最全面总结）" target="_blank">Hadoop集群配置（最全面总结）</a>(13)</li>
<li><a href="http://blog.csdn.net/hguisu/article/details/7448528" title="PHP SOCKET编程" target="_blank">PHP SOCKET编程</a>(11)</li>
<li><a href="http://blog.csdn.net/hguisu/article/details/7453390" title="socket阻塞与非阻塞，同步与异步、I/O模型" target="_blank">socket阻塞与非阻塞，同步与异步、I/O模型</a>(11)</li>
<li><a href="http://blog.csdn.net/hguisu/article/details/7282050" title="Hadoop Hive与Hbase整合" target="_blank">Hadoop Hive与Hbase整合</a>(10)</li>
<li><a href="http://blog.csdn.net/hguisu/article/details/7244413" title="hbase安装配置（整合到hadoop）" target="_blank">hbase安装配置（整合到hadoop）</a>(10)</li>
</ul>
<p>推荐文章
最新评论</p>
<ul>
<li><a href="http://blog.csdn.net/hguisu/article/details/7453390#comments" target="_blank">socket阻塞与非阻塞，同步与异步、I/O模型</a></li>
</ul>
<p><a href="http://blog.csdn.net/ctqctq99" target="_blank">ctqctq99</a>: 他的意思可能是阻塞IO和非阻塞IO的区别就在于：应用程序的调用是否立即返回！这句话说反了。应该是非阻...</p>
<ul>
<li><a href="http://blog.csdn.net/hguisu/article/details/7408047#comments" target="_blank">硬盘的读写原理</a></li>
</ul>
<p><a href="http://blog.csdn.net/m1013923728" target="_blank">m1013923728</a>: 写的通俗易懂！</p>
<ul>
<li><a href="http://blog.csdn.net/hguisu/article/details/7470695#comments" target="_blank">C语言中的宏定义</a></li>
</ul>
<p><a href="http://blog.csdn.net/ouwen3536" target="_blank">ouwen3536</a>: 很半，转起！</p>
<ul>
<li><a href="http://blog.csdn.net/hguisu/article/details/7470695#comments" target="_blank">C语言中的宏定义</a></li>
</ul>
<p><a href="http://blog.csdn.net/zhangyongbluesky" target="_blank">zhangyongbluesky</a>: good</p>
<ul>
<li><a href="http://blog.csdn.net/hguisu/article/details/7244413#comments" target="_blank">hbase安装配置（整合到hadoop）</a></li>
</ul>
<p><a href="http://blog.csdn.net/hguisu" target="_blank">真实的归宿</a>: @u012171806:conf/hbase-site.xml你应该看官方文档的快速入门。安装的东西...</p>
<ul>
<li><a href="http://blog.csdn.net/hguisu/article/details/7244413#comments" target="_blank">hbase安装配置（整合到hadoop）</a></li>
</ul>
<p><a href="http://blog.csdn.net/u012171806" target="_blank">JAVA_小陈</a>: 我把hbase下载了，你上面说的需要配置一个xml文件，请问配置在什么地方呢？然后启动的时候是在什么...</p>
<ul>
<li><a href="http://blog.csdn.net/hguisu/article/details/7408047#comments" target="_blank">硬盘的读写原理</a></li>
</ul>
<p><a href="http://blog.csdn.net/mxhlee" target="_blank">mxhlee</a>: 好东西啊！！！（实际是斜切向运动）这句话让我纠结了很长时间、我自己就感觉是这运动 但是没有一个介绍...</p>
<ul>
<li><a href="http://blog.csdn.net/hguisu/article/details/7453390#comments" target="_blank">socket阻塞与非阻塞，同步与异步、I/O模型</a></li>
</ul>
<p><a href="http://blog.csdn.net/hguisu" target="_blank">真实的归宿</a>: @liaokailin:并没有反。实际就是这样的。</p>
<ul>
<li><a href="http://blog.csdn.net/hguisu/article/details/7453390#comments" target="_blank">socket阻塞与非阻塞，同步与异步、I/O模型</a></li>
</ul>
<p><a href="http://blog.csdn.net/hguisu" target="_blank">真实的归宿</a>: @liaokailin:实际就是这样的。</p>
<ul>
<li><a href="http://blog.csdn.net/hguisu/article/details/7453390#comments" target="_blank">socket阻塞与非阻塞，同步与异步、I/O模型</a></li>
</ul>
<p><a href="http://blog.csdn.net/liaokailin" target="_blank">廖凯林</a>: 同步IO和异步IO的区别就在于：数据拷贝的时候进程是否阻塞！阻塞IO和非阻塞IO的区别就在于：应用程...</p>
<p><a href="http://www.csdn.net/company/about.html" target="_blank">公司简介</a>|<a href="http://www.csdn.net/company/recruit.html" target="_blank">招贤纳士</a>|<a href="http://www.csdn.net/company/marketing.html" target="_blank">广告服务</a>|<a href="http://www.csdn.net/company/account.html" target="_blank">银行汇款帐号</a>|<a href="http://www.csdn.net/company/contact.html" target="_blank">联系方式</a>|<a href="http://www.csdn.net/company/statement.html" target="_blank">版权声明</a>|<a href="http://www.csdn.net/company/layer.html" target="_blank">法律顾问</a>|<a href="mailto:webmaster@csdn.net">问题报告</a><a href="http://wpa.qq.com/msgrd?v=3&amp;uin=2355263776&amp;site=qq&amp;menu=yes" target="_blank">QQ客服</a> <a href="http://e.weibo.com/csdnsupport/profile" target="_blank">微博客服</a> <a href="http://bbs.csdn.net/forums/Service" target="_blank">论坛反馈</a> <a href="mailto:webmaster@csdn.net">联系邮箱：webmaster@csdn.net</a> 服务热线：400-600-2320京 ICP 证 070598 号北京创新乐知信息技术有限公司 版权所有世纪乐知(北京)网络技术有限公司 提供技术支持江苏乐知网络技术有限公司 提供商务支持Copyright © 1999-2012, CSDN.NET, All Rights Reserved <a href="http://www.hd315.gov.cn/beian/view.asp?bianhao=010202001032100010" target="_blank"><img src="" alt="GongshangLogo"></a>
<img src="http://counter.csdn.net/pv.aspx?id=24" alt=""></p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/hadoop/">hadoop</a></li></span></span> | <span class="tags">Tagged <a href="/tags/hadoop/" class="label label-primary">hadoop</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:36"datetime="2014-03-07 09:54:36"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-hadoop--HDFS写入和读取流程/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-hadoop--HDFS写入和读取流程" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>





<ul id="pagination" class="pagination pagination-lg">
  <li><a class="extend prev" href="/page/106/">&laquo;</a></li><li><a class="page-number" href="/">1</a></li><li><a class="page-number" href="/page/2/">2</a></li><li><span class="space">&hellip;</span></li><li><a class="page-number" href="/page/104/">104</a></li><li><a class="page-number" href="/page/105/">105</a></li><li><a class="page-number" href="/page/106/">106</a></li><li class="active"><li><span class="page-number current">107</span></li><li><a class="page-number" href="/page/108/">108</a></li><li><a class="page-number" href="/page/109/">109</a></li><li><a class="page-number" href="/page/110/">110</a></li><li><span class="space">&hellip;</span></li></li><li><a class="page-number" href="/page/164/">164</a></li><li><a class="page-number" href="/page/165/">165</a></li><li><a class="extend next" href="/page/108/">&raquo;</a></li>
  <div class="clearfix"></div>
</ul></div><!--wapper-->
       </div><!-- ID main-col END -->
       <aside id="sidebar" class="alignright col-sx-6 col-sm-4 col-md-3 col-lg-3">
<div id="widget_search" class="widget panel panel-primary">
    <form action="//google.com/search" method="get" accept-charset="utf-8">
  <div class="input-group">
    <input class="form-control" id="searchbox" type="search" name="q" results="0" placeholder="search">
    <span class="input-group-btn">
      <button class="btn btn-default" type="submit">Go!</button>
    </span>
    <input type="hidden" name="q" value="site:itsolife.com">
  </div>
</form>
</div>

<div id="widget_category" class="widget panel panel-primary">
  <div class="panel-heading">category</div>  <div data-src='category' class='ajax_widgets'>正在加载...</div>
</div>

<div id="widget_recent_posts" class="widget panel panel-primary">
  <div class="panel-heading">recent posts</div>  <div data-src='recent_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_tagcloud" class="widget panel panel-primary">
  <div class="panel-heading">tagcloud</div>  <div data-src='tagcloud' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_latest_update_posts" class="widget panel panel-primary">
  <div class="panel-heading">最近更新</div>  <div data-src='latest_update_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_recent_comments" class="widget panel panel-primary">
  <div class="panel-heading">recent comments</div>  

<div class="list-group-item ds-recent-comments" data-num-items="6" data-show-avatars="1" data-show-time="1" data-show-title="1" data-show-admin="1" data-excerpt-length="50"></div>



</div>

</aside>
       <div class="clearfix"></div>
     </div><!-- row END -->
  </div>
  <footer id="footer" class="container">
  <div class="panel panel-info">
  <section id='footer_widget'></section>  <div class="panel-footer">
  <div id="site-info">
    <span class='author'>
  
  &copy; 2014 RobinChia
  
    &nbsp;&nbsp;</span>
  
  <span id='analytics-51la'></span><span id='analytics-google'>
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-48559895-1']);
  _gaq.push(['_trackPageview']);
  _js2load.push({src:('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'});
</script></span><span id='analytics-cnzz'>
<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_5774006'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s17.cnzz.com/stat.php%3Fid%3D5774006%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>
</span><span id='analytics-baidu'>
<script>
var _hmt = _hmt || [];
_js2load.push({src:"//hm.baidu.com/hm.js?1442f50724afc42380b51f097c43082c"});
</script>
</span>  </div>
  <div id="copyright">Blog powered by <a href='http://zespia.tw/hexo/'><strong>hexo</strong></a> Theme <strong><a href='https://github.com/chenall/hexo-theme-chenall'>chenall</a></strong>(Some change in it)<span class="pull-right"> 更新时间: <em>2014-03-15 13:06:28</em></span></div>
</div>
<div class="clearfix"></div>


  </div>
  </footer>
  
        <script src="http://cdn.bootcss.com/jquery/1.10.2/jquery.min.js"></script>        
        <script src="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/js/bootstrap.min.js"></script>        
                
        <script src="http://cdn.bootcss.com/prettify/r298/prettify.min.js"></script>    <script type="text/javascript">
   var lang=["bsh", "c", "cc", "cpp", "cs", "csh", "cyc", "cv", "htm", "html",
    "java", "js", "m", "mxml", "perl", "pl", "pm", "py", "rb", "sh",
    "xhtml", "xml", "xsl"];
   var pretty_base='';
   $('script').each(function(){
	var c = $(this).attr('src');
	if (!c)
	    return;
	if (c.match(/(\/)?prettify(\.min)?\.js/i))
	{
	    var index = c.lastIndexOf('/');
	    if (index != -1)
		pretty_base = c.substr(0,index + 1);
	    return false;
	}
   })
   $('pre code').each(function(){
	var c = $(this).attr('class')
	if (!c)
	    return;
	c = c.match(/\s?(lang\-\w+)/i);
	if (c && lang.indexOf(c[1]) == -1)
	{
	    lang.push(c[1]);
	    $.getScript(pretty_base + c[1] + '.min.js');
	}
   })

    $(window).load(function(){
       $("pre").addClass("prettyprint");
       prettyPrint();
    })
</script>    
            <script type="text/javascript">
var duoshuoQuery = {short_name:"robinchia"};
_js2load.push({src:'http://static.duoshuo.com/embed.js',charset:'UTF-8'});
</script>
    
            <!--wumii_relatedItems-->
    
        <script src="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js"></script>    <script type="text/javascript">
(function($){
  $('.entry').each(function(i){
    $(this).find('img').each(function(){
      var alt = this.alt;

      if (alt){
        $(this).before('<span class="caption">' + alt + '</span>');
      }

      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox" rel="fancybox' + i + '" />');
    });
  });

  $('.fancybox').fancybox();
})(jQuery);
</script>    
        <script src="http://cdn.bootcss.com/mathjax/2.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>    <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>
    
<script type="text/javascript">
$('.ajax_widgets').each(function(){var src=$(this).attr('data-src');if(src)$(this).load('/widgets/'+src+'.html');});
$.each(_js2load,function(index,obj){loadjs(obj.src,obj.charset)});
</script>

<div id="scroll2top">
<img src="/scroll2top/arrow.png"/>
</div>
<script src="/scroll2top/scroll2top.min.js"></script>
<div id="winterland">
  <canvas></canvas>
</div>
<script src="/js/winterland.min.js"></script>

  </body>
</html>
