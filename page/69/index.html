
<!DOCTYPE HTML>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>The 69 Page | It so life</title>
<meta name="author" content="RobinChia">

<meta name="description" content="It so life">


<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<meta property="og:site_name" content="It so life"/>

<!--[if IE]><style>.testIE.IE{display:inline;}</style><![endif]-->
<!--[if lte IE 7]><link rel="stylesheet" href="/css/ie7.css" type="text/css"><![endif]-->
<!--[if (lt IE 9)&(gt IE 7)]><style>.testIE.IE8{display:inline;}</style><![endif]-->
<!--[if gt IE 8]><style>.testIE.IE9{display:inline;}</style><![endif]-->

<link href="/favicon.png" rel="icon">
<link rel="alternate" href="/atom.xml" title="It so life Feed" type="application/atom+xml">

<link rel="stylesheet" href="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/css/bootstrap.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/font-awesome/4.0.3/css/font-awesome.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/prettify/r298/prettify.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" type="text/css">
<link rel="stylesheet" href="/css/style.css" type="text/css">
<!--[if lt IE 9]>
   <style>article,aside,dialog,footer,header,section,footer,nav,figure,menu{display:block}</style>
   <script src="http://cdn.staticfile.org/html5shiv/r29/html5.min.js"></script>
   <script src="http://cdn.staticfile.org/respond.js/1.4.2/respond.min.js"></script>
<link href="http://cdn.staticfile.org/respond.js/1.4.2/respond-proxy.html" id="respond-proxy" rel="respond-proxy" />
<link href="/js/respond.proxy.gif" id="respond-redirect" rel="respond-redirect" />
<script src="/js/respond.proxy.js"></script>
   <script src="http://cdn.bootcss.com/selectivizr/1.0.2/selectivizr-min.js"></script>
<![endif]-->
<script type="text/javascript">
function loadjs(c,d){var a=document.createElement("script");a.async=!0;a.type="text/javascript";a.src=c;a.charset=d||"gbk";(document.getElementsByTagName("HEAD")[0]||document.getElementsByTagName("BODY")[0]).appendChild(a)};
var _protocol = (("https:" == document.location.protocol) ? " https://" : " http://");
var _js2load = [];
</script>

</head>
<body>
      <header id="header" class="container"><nav id="main-nav" class="navbar navbar-default navbar-fixed-top " role="navigation">
  <div class="container">
    <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
      <span class="sr-only">Toggle navigation</span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="/">It so life</a>
    </div>
    <div  class="collapse navbar-collapse">
      <ul  class="nav navbar-nav">
  
        <li><a href="/" title="Home">Home</a></li>      
        <li><a href="/about/" title="About">About</a></li>      
        <li><a href="/archives/" title="Archives">Archives</a></li>      
      <li class='dropdown'>
        <a class='dropdown-toggle' data-toggle='dropdown' href='#'>website<b class='caret'></b></a>
        <ul class='dropdown-menu pure-menu-selected'>
    
          <li><a href="//groups.google.com/forum/#!forum/pongba" title="TopLanguage">TopLanguage</a></li>    
          <li><a href="//itpub.net/" title="ITPub">ITPub</a></li>    
          <li><a href="//blog.jobbole.com/" title="Bole">Bole</a></li>    
          <li><a href="//nosql-database.org/" title="nosql">nosql</a></li>    
          <li><a href="//gitimmersion.googol.im/" title="Git">Git</a></li>    
        </ul>
      </li>
    
      </ul>
      <ul class="nav navbar-nav navbar-right">
      
        <li><a href="/atom.xml">RSS</a></li>
      
      
        <li><a href="https://twitter.com/robinchia">twitter</a></li>
      
      
      
      
        <li><a href="https://github.com/robinchia">github</a></li>
      
      </ul>
    </div>
  </div>
</nav>
<div class="clearfix"></div>
</header>
  <div id='content' class="container">
     <div class="page-header-wrapper">
      <!--[if lt IE 9]><div class="alert alert-warning alert-dismissable"><button type="button" class="close" data-dismiss="alert" aria-hidden="true">&times;</button><strong>提示:</strong>您的浏览器版本太低了,建议升级到 <strong><a href="http://windows.microsoft.com/zh-cn/internet-explorer/download-ie" title="IE9">IE9</a></strong> 以上,本站使用<a href="https://www.google.com/intl/zh-CN/chrome/">Chrome浏览器</a>可以获得最好的显示效果.</div><![endif]-->
      <div class="page-header"><h1 align="center"><big>It so life</big> </h1>
        <h5 align="center"><big>love as life</big></h5>
      </div>
     </div>
     <div class="row">
       <div id="main-col" class="alignleft col-sx-12 col-sm-8 col-md-9 col-lg-9">
      <section id='header_widget'></section>
          <div id="wrapper"><article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-内存分析--Java工具（jmap-jstack）在linux上的源码分析/">Java 工具（jmap</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:40.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-内存分析--Java工具（jmap-jstack）在linux上的源码分析/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="java-jmap-jstack-linux-">Java 工具（jmap,jstack）在linux上的源码分析</h1>
<p><a href="http://blog.csdn.net/raintungli/article/details/7023092" target="_blank">Java 工具（jmap,jstack）在linux上的源码分析（一）</a></p>
<p>在我们常用的Jstack, Jmap 用于分析java虚拟机的状态的工具，通过起另一个虚拟机通过运行sun.tools包下的java文件，去跟踪另一个虚拟机的状态。</p>
<p>如果让你设计一个跟踪另一个进程的方法，你也通常会考虑这几种常用的方式。</p>
<p>第一种，就是通知被跟踪的进程，让进程执行相应的消息，同时对该消息做出反应。</p>
<p>第二种，就是通过内核的调用，直接能够访问进程的内存，堆栈情况，通过分析被跟踪的进程的内存结构，从而知道当前被跟踪的进程的状态。</p>
<p>第一种方式</p>
<p>优势：</p>
<p>对调用者和被调用者只要达成简单的通讯协议，调用者无需知道被调用者的逻辑，结构，只需要简单的发送命令的方式，被调用者能够接受到命令，并且对该命令进行回应就可以。</p>
<p>缺点：</p>
<p>如果被调用者当时的状态本来就不正常，或者繁忙，没办法对该命令做出响应，那这个跟踪进程往往是在规定的等待时间里，无法返回正确的需要的信息。其次被调用者在分析的过程中，有可能需要暂停进程中的其他的线程，而对被跟踪的进程有一定的影响。</p>
<p>第二种方式</p>
<p>优势：</p>
<p>通过内核的支持，访问被跟踪的内存，并作出快照，后台分析，很少影响被跟踪的进程。</p>
<p>缺点：</p>
<p>这种方式需要对被跟踪程的内存分配和使用非常的了解，无法解耦，而本身系统内核调用也会出问题。</p>
<p>Java工具类中也是大致实现了这2中方式，工具中会先选择第一种方式，如果发现第一种方式不能成功，将会建议使用-F参数，也就是第二种方式。</p>
<p>我们先讲第一种方式。</p>
<p>既然是需要向被跟踪进程发出命令，在linux中可以选择多种方式进行进程中通讯 共享内存，文件之类，其中创建socket的文件实现通讯是比较简单的方法。</p>
<p>下面是整个的流程图：</p>
<p><img src="" alt="">
来源： <a href="[http://blog.csdn.net/raintungli/article/details/7023092](http://blog.csdn.net/raintungli/article/details/7023092)">[http://blog.csdn.net/raintungli/article/details/7023092](http://blog.csdn.net/raintungli/article/details/7023092)</a> <a href="http://blog.csdn.net/raintungli/article/details/7034005" target="_blank">Java 工具（jmap,jstack）在linux上的源码分析（二）信号处理</a></p>
<p>当java虚拟机启动的时候，会启动很多内部的线程，这些线程主要在thread.cpp里的create_vm方法体里实现</p>
<p>而在thread.cpp里主要起了2个线程来处理信号相关的
<strong>[cpp]</strong> <a href="http://blog.csdn.net/raintungli/article/details/7034005#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/raintungli/article/details/7034005#" title="copy" target="_blank">copy</a></p>
<ol>
<li>JvmtiExport::enter_live_phase();  </li>
<li></li>
<li>// Signal Dispatcher needs to be started before VMInit event is posted  </li>
<li>os::signal_init();  </li>
<li></li>
<li>// Start Attach Listener if +StartAttachListener or it can&#39;t be started lazily  </li>
<li>if (!DisableAttachMechanism) {  </li>
<li>if (StartAttachListener || AttachListener::init_at_startup()) {  </li>
<li>AttachListener::init();  </li>
<li>}  </li>
<li>}  </li>
</ol>
<h3 id="-1-signal-dispatcher-"><a href=""></a>1. Signal Dispatcher 线程</h3>
<p>在os.cpp中的signal_init()函数中，启动了signal dispatcher 线程，对signal dispather 线程主要是用于处理信号，等待信号并且分发处理，可以详细看signal_thread_entry的方法
<strong>[cpp]</strong> <a href="http://blog.csdn.net/raintungli/article/details/7034005#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/raintungli/article/details/7034005#" title="copy" target="_blank">copy</a></p>
<ol>
<li>static void signal_thread_entry(JavaThread/* thread, TRAPS) {  </li>
<li>os::set_priority(thread, NearMaxPriority);  </li>
<li>while (true) {  </li>
<li>int sig;  </li>
<li>{  </li>
<li>// FIXME : Currently we have not decieded what should be the status  </li>
<li>//         for this java thread blocked here. Once we decide about  </li>
<li>//         that we should fix this.  </li>
<li>sig = os::signal_wait();  </li>
<li>}  </li>
<li>if (sig == os::sigexitnum_pd()) {  </li>
<li>// Terminate the signal thread  </li>
<li>return;  </li>
<li>}  </li>
<li></li>
<li>switch (sig) {  </li>
<li>case SIGBREAK: {  </li>
<li>// Check if the signal is a trigger to start the Attach Listener - in that  </li>
<li>// case don&#39;t print stack traces.  </li>
<li>if (!DisableAttachMechanism &amp;&amp; AttachListener::is_init_trigger()) {  </li>
<li>continue;  </li>
<li>}  </li>
<li>// Print stack traces  </li>
<li>// Any SIGBREAK operations added here should make sure to flush  </li>
<li>// the output stream (e.g. tty-&gt;flush()) after output.  See 4803766.  </li>
<li>// Each module also prints an extra carriage return after its output.  </li>
<li>VM_PrintThreads op;  </li>
<li>VMThread::execute(&amp;op);  </li>
<li>VM_PrintJNI jni_op;  </li>
<li>VMThread::execute(&amp;jni_op);  </li>
<li>VM_FindDeadlocks op1(tty);  </li>
<li>VMThread::execute(&amp;op1);  </li>
<li>Universe::print_heap_at_SIGBREAK();  </li>
<li>if (PrintClassHistogram) {  </li>
<li>VM_GC_HeapInspection op1(gclog_or_tty, true //<em> force full GC before heap inspection /</em>/,  </li>
<li>true //<em> need_prologue /</em>/);  </li>
<li>VMThread::execute(&amp;op1);  </li>
<li>}  </li>
<li>if (JvmtiExport::should_post_data_dump()) {  </li>
<li>JvmtiExport::post_data_dump();  </li>
<li>}  </li>
<li>break;  </li>
<li>}  </li>
<li>default: {  </li>
<li>// Dispatch the signal to java  </li>
<li>HandleMark hm(THREAD);  </li>
<li>klassOop k = SystemDictionary::resolve_or_null(vmSymbolHandles::sun_misc_Signal(), THREAD);  </li>
<li>KlassHandle klass (THREAD, k);  </li>
<li>if (klass.not_null()) {  </li>
<li>JavaValue result(T_VOID);  </li>
<li>JavaCallArguments args;  </li>
<li>args.push_int(sig);  </li>
<li>JavaCalls::call_static(  </li>
<li>&amp;result,  </li>
<li>klass,  </li>
<li>vmSymbolHandles::dispatch_name(),  </li>
<li>vmSymbolHandles::int_void_signature(),  </li>
<li>&amp;args,  </li>
<li>THREAD  </li>
<li>);  </li>
<li>}  </li>
<li>if (HAS_PENDING_EXCEPTION) {  </li>
<li>// tty is initialized early so we don&#39;t expect it to be null, but  </li>
<li>// if it is we can&#39;t risk doing an initialization that might  </li>
<li>// trigger additional out-of-memory conditions  </li>
<li>if (tty != NULL) {  </li>
<li>char klass_name[256];  </li>
<li>char tmp_sig_name[16];  </li>
<li>const char/* sig_name = &quot;UNKNOWN&quot;;  </li>
<li>instanceKlass::cast(PENDING_EXCEPTION-&gt;klass())-&gt;  </li>
<li>name()-&gt;as_klass_external_name(klass_name, 256);  </li>
<li>if (os::exception_name(sig, tmp_sig_name, 16) != NULL)  </li>
<li>sig_name = tmp_sig_name;  </li>
<li>warning(&quot;Exception %s occurred dispatching signal %s to handler&quot;  </li>
<li>&quot;- the VM may need to be forcibly terminated&quot;,  </li>
<li>klass_name, sig_name );  </li>
<li>}  </li>
<li>CLEAR_PENDING_EXCEPTION;  </li>
<li>}  </li>
<li>}  </li>
<li>}  </li>
<li>}  </li>
<li>}  </li>
</ol>
<p>可以看到通过os::signal_wait();等待信号，而在linux里是通过sem_wait()来实现，接受到SIGBREAK(linux 中的QUIT)信号的时候（关于信号处理请参考笔者的另一篇博客<a href="http://blog.csdn.net/raintungli/article/details/7178472" target="_blank">:java 中关于信号的处理在linux下的实现</a>），第一次通过调用 AttachListener::is_init_trigger（）初始化attach listener线程，详细见2.Attach Listener 线程。</p>
<ol>
<li>第一次收到信号，会开始初始化，当初始化成功，将会直接返回，而且不返回任何线程stack的信息（通过socket file的操作返回），并且第二次将不在需要初始化。如果初始化不成功，将直接在控制台的outputstream中打印线程栈信息。</li>
<li>第二次收到信号，如果已经初始化过，将直接在控制台中打印线程的栈信息。如果没有初始化，继续初始化，走和第一次相同的流程。</li>
</ol>
<h3 id="-2-attach-listener-"><a href=""></a>2. Attach Listener 线程</h3>
<p>Attach Listener 线程是负责接收到外部的命令，而对该命令进行执行的并且吧结果返回给发送者。在jvm启动的时候，如果没有指定+StartAttachListener，该线程是不会启动的，刚才我们讨论到了在接受到quit信号之后，会调用 AttachListener::is_init_trigger（）通过调用用AttachListener::init（）启动了Attach Listener 线程，同时在不同的操作系统下初始化，在linux中 是在attachListener_Linux.cpp文件中实现的。</p>
<p>在linux中如果发现文件.attach_pid/#pid存在，才会启动attach listener线程，同时初始化了socket 文件，也就是通常jmap,jstack tool干的事情，先创立attach_pid/#pid文件，然后发quit信号,通过这种方式暗式的启动了Attach Listener线程（见博客：<a href="http://blog.csdn.net/raintungli/article/details/7023092" target="_blank"><a href="http://blog.csdn.net/raintungli/article/details/7023092">http://blog.csdn.net/raintungli/article/details/7023092</a></a>）。</p>
<p>线程的实现在 attach_listener_thread_entry 方法体中实现
<strong>[cpp]</strong> <a href="http://blog.csdn.net/raintungli/article/details/7034005#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/raintungli/article/details/7034005#" title="copy" target="_blank">copy</a></p>
<ol>
<li>static void attach_listener_thread_entry(JavaThread/* thread, TRAPS) {  </li>
<li>os::set_priority(thread, NearMaxPriority);  </li>
<li></li>
<li>if (AttachListener::pd_init() != 0) {  </li>
<li>return;  </li>
<li>}  </li>
<li>AttachListener::set_initialized();  </li>
<li></li>
<li>for (;;) {  </li>
<li>AttachOperation/* op = AttachListener::dequeue();    </li>
<li>if (op == NULL) {  </li>
<li>return;   // dequeue failed or shutdown  </li>
<li>}  </li>
<li></li>
<li>ResourceMark rm;  </li>
<li>bufferedStream st;  </li>
<li>jint res = JNI_OK;  </li>
<li></li>
<li>// handle special detachall operation  </li>
<li>if (strcmp(op-&gt;name(), AttachOperation::detachall_operation_name()) == 0) {  </li>
<li>AttachListener::detachall();  </li>
<li>} else {  </li>
<li>// find the function to dispatch too  </li>
<li>AttachOperationFunctionInfo/* info = NULL;  </li>
<li>for (int i=0; funcs[i].name != NULL; i++) {  </li>
<li>const char/* name = funcs[i].name;  </li>
<li>assert(strlen(name) &lt;= AttachOperation::name_length_max, &quot;operation &lt;= name_length_max&quot;);  </li>
<li>if (strcmp(op-&gt;name(), name) == 0) {  </li>
<li>info = &amp;(funcs[i]);  </li>
<li>break;  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>// check for platform dependent attach operation  </li>
<li>if (info == NULL) {  </li>
<li>info = AttachListener::pd_find_operation(op-&gt;name());  </li>
<li>}  </li>
<li></li>
<li>if (info != NULL) {  </li>
<li>// dispatch to the function that implements this operation  </li>
<li>res = (info-&gt;func)(op, &amp;st);  </li>
<li>} else {  </li>
<li>st.print(&quot;Operation %s not recognized!&quot;, op-&gt;name());  </li>
<li>res = JNI_ERR;  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>// operation complete - send result and output to client  </li>
<li>op-&gt;complete(res, &amp;st);  </li>
<li>}  </li>
<li>}  </li>
</ol>
<p>在AttachListener::dequeue(); 在liunx里的实现就是监听刚才创建的socket的文件，如果有请求进来，找到请求对应的操作，调用操作得到结果并把结果写到这个socket的文件，如果你把socket的文件删除，jstack/jmap会出现错误信息 unable to open socket file:........</p>
<p>我们经常使用 kill -3 pid的操作打印出线程栈信息，我们可以看到具体的实现是在Signal Dispatcher 线程中完成的，因为kill -3 pid 并不会创建.attach_pid/#pid文件，所以一直初始化不成功，从而线程的栈信息被打印到控制台中。
来源： <a href="[http://blog.csdn.net/raintungli/article/details/7034005](http://blog.csdn.net/raintungli/article/details/7034005)">[http://blog.csdn.net/raintungli/article/details/7034005](http://blog.csdn.net/raintungli/article/details/7034005)</a></p>
<h3 id="-java-jmap-jstack-linux-vm-thread-http-blog-csdn-net-raintungli-article-details-7045024-"><a href="http://blog.csdn.net/raintungli/article/details/7045024" target="_blank">Java 工具（jmap,jstack）在linux上的源码分析（三）执行的线程vm thread</a></h3>
<h3 id="-"> </h3>
<p>在前面的博客中（<a href="http://blog.csdn.net/raintungli/article/details/7034005" target="_blank"><a href="http://blog.csdn.net/raintungli/article/details/7034005">http://blog.csdn.net/raintungli/article/details/7034005</a></a>）所提到的信号转发线程，Attach Listener 线程都只是操作socket文件，并没有去执行比如stack 分析，或者heap的分析，真正的工作线程其实是vm thread.</p>
<p>（一）启动vm thread
<strong>[cpp]</strong> <a href="http://blog.csdn.net/raintungli/article/details/7045024#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/raintungli/article/details/7045024#" title="copy" target="_blank">copy</a></p>
<ol>
<li>jint Threads::create_vm(JavaVMInitArgs/<em> args, bool/</em> canTryAgain) {  </li>
<li>...  </li>
<li>// Create the VMThread  </li>
<li>{ TraceTime timer(&quot;Start VMThread&quot;, TraceStartupTime);  </li>
<li>VMThread::create();  </li>
<li>Thread/* vmthread = VMThread::vm_thread();  </li>
<li></li>
<li>if (!os::create_thread(vmthread, os::vm_thread))  </li>
<li>vm_exit_during_initialization(&quot;Cannot create VM thread. Out of system resources.&quot;);  </li>
<li></li>
<li>// Wait for the VM thread to become ready, and VMThread::run to initialize  </li>
<li>// Monitors can have spurious returns, must always check another state flag  </li>
<li>{  </li>
<li>MutexLocker ml(Notify_lock);  </li>
<li>os::start_thread(vmthread);  </li>
<li>while (vmthread-&gt;active_handles() == NULL) {  </li>
<li>Notify_lock-&gt;wait();  </li>
<li>}  </li>
<li>}  </li>
<li>}  </li>
<li>...  </li>
<li></li>
<li></li>
<li>}  </li>
</ol>
<p>我们可以看到，在thread.cpp里启动了线程vm thread，在这里我们同时也稍微的略带的讲一下jvm在linux里如何启动线程的。</p>
<p>通常在linux中启动线程，是调用
<strong>[cpp]</strong> <a href="http://blog.csdn.net/raintungli/article/details/7045024#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/raintungli/article/details/7045024#" title="copy" target="_blank">copy</a></p>
<ol>
<li>int pthread_create((pthread_t /<em><strong>thread, </strong>const pthread_attr_t /</em><strong>attr,void /<em>(/</em></strong>start_routine) (void /<em>), void /</em>__arg));  </li>
</ol>
<p>而在java里却增加了os:create_thread --初始化线程 和os:start_thread--启动线程</p>
<p>我们去看一下jvm里面是如何在linux里做到的</p>
<p>在os_linux.cpp中来看create_thread的方法
<strong>[cpp]</strong> <a href="http://blog.csdn.net/raintungli/article/details/7045024#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/raintungli/article/details/7045024#" title="copy" target="_blank">copy</a></p>
<ol>
<li>bool os::create_thread(Thread/* thread, ThreadType thr_type, size_t stack_size) {  </li>
<li>....  </li>
<li>int ret = pthread_create(&amp;tid, &amp;attr, (void/<em> (/</em>)(void/*)) java_start, thread);  </li>
<li>....  </li>
<li>}  </li>
</ol>
<p>继续看java_start方法</p>
<p><strong>[cpp]</strong> <a href="http://blog.csdn.net/raintungli/article/details/7045024#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/raintungli/article/details/7045024#" title="copy" target="_blank">copy</a></p>
<ol>
<li>static void /<em>java_start(Thread /</em>thread) {  </li>
<li>....  </li>
<li>// handshaking with parent thread  </li>
<li>{  </li>
<li>MutexLockerEx ml(sync, Mutex::_no_safepoint_check_flag);  </li>
<li></li>
<li>// notify parent thread  </li>
<li>osthread-&gt;set_state(INITIALIZED);  </li>
<li>sync-&gt;notify_all();  </li>
<li></li>
<li>// wait until os::start_thread()  </li>
<li>while (osthread-&gt;get_state() == INITIALIZED) {  </li>
<li>sync-&gt;wait(Mutex::_no_safepoint_check_flag);  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>// call one more level start routine  </li>
<li>thread-&gt;run();  </li>
<li></li>
<li>return 0;  </li>
<li>}  </li>
</ol>
<p>首先jvm先设置了当前线程的状态是Initialized, 然后notify所有的线程，</p>
<p> while (osthread-&gt;get_state() == INITIALIZED) {
      sync-&gt;wait(Mutex::_no_safepoint_check_flag);
    }</p>
<p>不停的查看线程的当前状态是不是Initialized, 如果是的话，调用了sync-&gt;wait()的方法等待。</p>
<p>来看os:start_thread的方法 os.cpp
<strong>[cpp]</strong> <a href="http://blog.csdn.net/raintungli/article/details/7045024#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/raintungli/article/details/7045024#" title="copy" target="_blank">copy</a></p>
<ol>
<li>void os::start_thread(Thread/* thread) {  </li>
<li>// guard suspend/resume  </li>
<li>MutexLockerEx ml(thread-&gt;SR_lock(), Mutex::_no_safepoint_check_flag);  </li>
<li>OSThread/* osthread = thread-&gt;osthread();  </li>
<li>osthread-&gt;set_state(RUNNABLE);  </li>
<li>pd_start_thread(thread);  </li>
<li>}  </li>
</ol>
<p>这时候设置了线程的状态为runnable,但没有notify线程</p>
<p>在 pd_start_thread(thread)中, os_linux.cpp中
<strong>[cpp]</strong> <a href="http://blog.csdn.net/raintungli/article/details/7045024#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/raintungli/article/details/7045024#" title="copy" target="_blank">copy</a></p>
<ol>
<li>void os::pd_start_thread(Thread/* thread) {  </li>
<li>OSThread /* osthread = thread-&gt;osthread();  </li>
<li>assert(osthread-&gt;get_state() != INITIALIZED, &quot;just checking&quot;);  </li>
<li>Monitor/* sync_with_child = osthread-&gt;startThread_lock();  </li>
<li>MutexLockerEx ml(sync_with_child, Mutex::_no_safepoint_check_flag);  </li>
<li>sync_with_child-&gt;notify();  </li>
<li>}  </li>
</ol>
<p>这时候我们看到了notify 线程的操作</p>
<p>也就是这时候notify了线程，因为这时候的线程的状态是RUNNABLE, 方法java_start继续往下执行，于是调用了thread-&gt;run()的方法</p>
<p>对于线程vm Thread 也就是调用了vmthread::run方法</p>
<p>vmThread.cpp
<strong>[cpp]</strong> <a href="http://blog.csdn.net/raintungli/article/details/7045024#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/raintungli/article/details/7045024#" title="copy" target="_blank">copy</a></p>
<ol>
<li>void VMThread::run() {  </li>
<li>...  </li>
<li>this-&gt;loop();  </li>
<li>...  </li>
<li>}  </li>
</ol>
<p>调用了loop函数，处理了VM_Operation 的queue 关于queue的级别和优先级处理算法：可以参考 另一篇博客：<a href="http://blog.csdn.net/raintungli/article/details/6553337" target="_blank"><a href="http://blog.csdn.net/raintungli/article/details/6553337">http://blog.csdn.net/raintungli/article/details/6553337</a></a></p>
<p>（二）Jstack 运行在vm thread里的VM_Operation</p>
<p>jstack 处理也就是在前面博客所提到的attach Listener 线程所做的 operation
<strong>[cpp]</strong> <a href="http://blog.csdn.net/raintungli/article/details/7045024#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/raintungli/article/details/7045024#" title="copy" target="_blank">copy</a></p>
<ol>
<li>static jint thread_dump(AttachOperation/<em> op, outputStream/</em> out) {  </li>
<li>bool print_concurrent_locks = false;  </li>
<li>if (op-&gt;arg(0) != NULL &amp;&amp; strcmp(op-&gt;arg(0), &quot;-l&quot;) == 0) {  </li>
<li>print_concurrent_locks = true;  </li>
<li>}  </li>
<li></li>
<li>// thread stacks  </li>
<li>VM_PrintThreads op1(out, print_concurrent_locks);  </li>
<li>VMThread::execute(&amp;op1);  </li>
<li></li>
<li>// JNI global handles  </li>
<li>VM_PrintJNI op2(out);  </li>
<li>VMThread::execute(&amp;op2);  </li>
<li></li>
<li>// Deadlock detection  </li>
<li>VM_FindDeadlocks op3(out);  </li>
<li>VMThread::execute(&amp;op3);  </li>
<li></li>
<li>return JNI_OK;  </li>
<li>}  </li>
</ol>
<p>简单看一下类VM_PrintThreads 它 继承了VM_Operation</p>
<p><strong>[cpp]</strong> <a href="http://blog.csdn.net/raintungli/article/details/7045024#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/raintungli/article/details/7045024#" title="copy" target="_blank">copy</a></p>
<ol>
<li>class VM_PrintThreads: public VM_Operation {  </li>
<li>private:  </li>
<li>outputStream/* _out;  </li>
<li>bool _print_concurrent_locks;  </li>
<li>public:  </li>
<li>VM_PrintThreads()                                                { _out = tty; _print_concurrent_locks = PrintConcurrentLocks; }  </li>
<li>VM_PrintThreads(outputStream/* out, bool print_concurrent_locks)  { _out = out; _print_concurrent_locks = print_concurrent_locks; }  </li>
<li>VMOp_Type type() const                                           {  return VMOp_PrintThreads; }  </li>
<li>void doit();  </li>
<li>bool doit_prologue();  </li>
<li>void doit_epilogue();  </li>
<li>};  </li>
</ol>
<p>当调用VMThread::execute()也就是将VM_PrintThreads 放入了_vm_queue中，交给vm thread 处理，对vm thread来说取出queue里的VM_Operation,并且调用doit方法。</p>
<p>在jstack里，attach listener 的线程产生了VM_PrintThreads，VM_PrintJNI，VM_FindDeadlocks 3个operations，交给了vm thread  的线程处理。
来源： <a href="[http://blog.csdn.net/raintungli/article/details/7045024](http://blog.csdn.net/raintungli/article/details/7045024)">[http://blog.csdn.net/raintungli/article/details/7045024](http://blog.csdn.net/raintungli/article/details/7045024)</a> <a href="http://blog.csdn.net/raintungli/article/details/7162468" target="_blank">Java 工具（jmap,jstack）在linux上的源码分析（四）safe point</a></p>
<p>safe point 顾明思意，就是安全点，当需要jvm做一些操作的时候，需要把当前正在运行的线程进入一个安全点的状态（也可以说停止状态），这样才能做一些安全的操作，比如线程的dump，堆栈的信息。</p>
<p>在jvm里面通常vm_thread（我们一直在谈论的做一些属于vm 份内事情的线程） 和cms_thread（内存回收的线程）做的操作，是需要将其他的线程通过调用SafepointSynchronize::begin 和 SafepointSynchronize:end来实现让其他的线程进入或者退出safe point 的状态。</p>
<h2 id="-safepoint-"><a href=""></a>通常safepoint 的有三种状态</h2>
<p>_not_synchronized 说明没有任何打断现在所有线程运行的操作，也就是vm thread, cms thread 没有接到操作的指令 _synchronizing vm thread,cms thread 接到操作指令，正在等待所有线程进入safe point _synchronized 所有线程进入safe point, vm thread, cms thread 可以开始指令操作</p>
<h2 id="-java-"><a href=""></a>Java线程的状态</h2>
<p>通常在java 进程中的Java 的线程有几个不同的状态，如何让这些线程进入safepoint 的状态中，jvm是采用不同的方式</p>
<h3 id="-a-"><a href=""></a>a. 正在解释执行</h3>
<p>由于java是解释性语言，而线程在解释java 字节码的时候，需要dispatch table,记录方法地址进行跳转的，那么这样让线程进入停止状态就比较容易了，只要替换掉dispatch table 就可以了，让线程知道当前进入softpoint 状态。</p>
<p>java里会设置3个DispatchTable，  _active_table，  _normal_table， _safept_table</p>
<p>_active_table 正在解释运行的线程使用的dispatch table</p>
<p>_normal_table 就是正常运行的初始化的dispatch table</p>
<p>_safept_table safe point需要的dispatch table</p>
<p>解释运行的线程一直都在使用_active_table,关键处就是在进入saftpoint 的时候，用_safept_table替换_active_table, 在退出saftpoint 的时候，使用_normal_table来替换_active_table</p>
<p>具体实现可以查看源码
<strong>[cpp]</strong> <a href="http://blog.csdn.net/raintungli/article/details/7162468#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/raintungli/article/details/7162468#" title="copy" target="_blank">copy</a></p>
<ol>
<li>void TemplateInterpreter::notice_safepoints() {  </li>
<li>if (!_notice_safepoints) {  </li>
<li>// switch to safepoint dispatch table  </li>
<li>_notice_safepoints = true;  </li>
<li>copy_table((address/<em>)&amp;_safept_table, (address/</em>)&amp;_active_table, sizeof(_active_table) / sizeof(address));  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>// switch from the dispatch table which notices safepoints back to the  </li>
<li>// normal dispatch table.  So that we can notice single stepping points,  </li>
<li>// keep the safepoint dispatch table if we are single stepping in JVMTI.  </li>
<li>// Note that the should_post_single_step test is exactly as fast as the  </li>
<li>// JvmtiExport::_enabled test and covers both cases.  </li>
<li>void TemplateInterpreter::ignore_safepoints() {  </li>
<li>if (_notice_safepoints) {  </li>
<li>if (!JvmtiExport::should_post_single_step()) {  </li>
<li>// switch to normal dispatch table  </li>
<li>_notice_safepoints = false;  </li>
<li>copy_table((address/<em>)&amp;_normal_table, (address/</em>)&amp;_active_table, sizeof(_active_table) / sizeof(address));  </li>
<li>}  </li>
<li>}  </li>
<li>}  </li>
</ol>
<h3 id="-"><a href=""></a></h3>
<p>b. 运行在native code</p>
<p>如果线程运行在native code的时候，vm thread 是不需要等待线程执行完的，只需要在从native code 返回的时候去判断一下 _state 的状态就可以了。</p>
<p>在方法体里就是前面博客也出现过的 SafepointSynchronize::do_call_back()
<strong>[cpp]</strong> <a href="http://blog.csdn.net/raintungli/article/details/7162468#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/raintungli/article/details/7162468#" title="copy" target="_blank">copy</a></p>
<ol>
<li>inline static bool do_call_back() {  </li>
<li>return (_state != _not_synchronized);  </li>
<li>}  </li>
</ol>
<p>判断了_state 不是_not_synchronized状态</p>
<p>为了能让线程从native code 回到java 的时候为了能读到/设置正确线程的状态，通常的解决方法使用memory barrier，java 使用OrderAccess::fence(); 在汇编里使用<strong>asm</strong> volatile (&quot;lock; addl $0,0(%%rsp)&quot; : : : &quot;cc&quot;, &quot;memory&quot;); 保证从内存里读到正确的值，但是这种方法严重影响系统的性能，于是java使用了每个线程都有独立的内存页来设置状态。通过使用使用参数-XX:+UseMembar  参数使用memory barrier，默认是不打开的，也就是使用独立的内存页来设置状态。</p>
<h3 id="-c-"><a href=""></a> c. 运行编译的代码</h3>
<h3 id="-1-poling-page-"><a href=""></a>1. Poling page 页面</h3>
<p>Poling page是在jvm初始化启动的时候会初始化的一个单独的内存页面，这个页面是让运行的编译过的代码的线程进入停止状态的关键。</p>
<p>在linux里面使用了mmap初始化，源码如下
<strong>[cpp]</strong> <a href="http://blog.csdn.net/raintungli/article/details/7162468#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/raintungli/article/details/7162468#" title="copy" target="_blank">copy</a></p>
<ol>
<li>address polling_page = (address) ::mmap(NULL, Linux::page_size(), PROT_READ, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);  </li>
</ol>
<h3 id="-"><a href=""></a></h3>
<ol>
<li>编译</li>
</ol>
<p>java 的JIT 会直接编译一些热门的源码到机器码，直接执行而不需要在解释执行从而提高效率，在编译的代码中，当函数或者方法块返回的时候会去访问一个内存poling页面.</p>
<p>x86架构下
<strong>[cpp]</strong> <a href="http://blog.csdn.net/raintungli/article/details/7162468#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/raintungli/article/details/7162468#" title="copy" target="_blank">copy</a></p>
<ol>
<li>void LIR_Assembler::return_op(LIR_Opr result) {  </li>
<li>assert(result-&gt;is_illegal() || !result-&gt;is_single_cpu() || result-&gt;as_register() == rax, &quot;word returns are in rax,&quot;);  </li>
<li>if (!result-&gt;is_illegal() &amp;&amp; result-&gt;is_float_kind() &amp;&amp; !result-&gt;is_xmm_register()) {  </li>
<li>assert(result-&gt;fpu() == 0, &quot;result must already be on TOS&quot;);  </li>
<li>}  </li>
<li></li>
<li>// Pop the stack before the safepoint code  </li>
<li>__ remove_frame(initial_frame_size_in_bytes());  </li>
<li></li>
<li>bool result_is_oop = result-&gt;is_valid() ? result-&gt;is_oop() : false;  </li>
<li></li>
<li>// Note: we do not need to round double result; float result has the right precision  </li>
<li>// the poll sets the condition code, but no data registers  </li>
<li>AddressLiteral polling_page(os::get_polling_page() + (SafepointPollOffset % os::vm_page_size()),  </li>
<li>relocInfo::poll_return_type);  </li>
<li></li>
<li>// NOTE: the requires that the polling page be reachable else the reloc  </li>
<li>// goes to the movq that loads the address and not the faulting instruction  </li>
<li>// which breaks the signal handler code  </li>
<li></li>
<li>__ test32(rax, polling_page);  </li>
<li></li>
<li>__ ret(0);  </li>
<li>}  </li>
</ol>
<p>在前面提到的SafepointSynchronize::begin 函数源码中</p>
<p><strong>[cpp]</strong> <a href="http://blog.csdn.net/raintungli/article/details/7162468#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/raintungli/article/details/7162468#" title="copy" target="_blank">copy</a></p>
<ol>
<li>if (UseCompilerSafepoints &amp;&amp; DeferPollingPageLoopCount &lt; 0) {  </li>
<li>// Make polling safepoint aware  </li>
<li>guarantee (PageArmed == 0, &quot;invariant&quot;) ;  </li>
<li>PageArmed = 1 ;  </li>
<li>os::make_polling_page_unreadable();  </li>
<li>}  </li>
</ol>
<p>这里提到了2个参数 UseCompilerSafepoints 和 DeferPollingPageLoopCount ，在默认的情况下这2个参数是true和-1</p>
<p>函数体将会调用os:make_polling_page_unreadable();在linux os 下具体实现是调用了mprotect(bottom,size,prot) 使polling 内存页变成不可读。</p>
<h3 id="-3-"><a href=""></a>3. 信号</h3>
<p>到当编译好的程序尝试在去访问这个不可读的polling页面的时候，在系统级别会产生一个错误信号SIGSEGV, 可以参考笔者的一篇博客中曾经讲过<a href="http://blog.csdn.net/raintungli/article/details/7178472" target="_blank">java 的信号处理</a>，可以知道信号SIGSEGV的处理函数在x86体系下见下源码：
<strong>[cpp]</strong> <a href="http://blog.csdn.net/raintungli/article/details/7162468#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/raintungli/article/details/7162468#" title="copy" target="_blank">copy</a></p>
<ol>
<li>JVM_handle_linux_signal(int sig,  </li>
<li>siginfo_t/* info,  </li>
<li>void/* ucVoid,  </li>
<li>int abort_if_unrecognized){  </li>
<li>....  </li>
<li>if (sig == SIGSEGV &amp;&amp; os::is_poll_address((address)info-&gt;si_addr)) {  </li>
<li>stub = SharedRuntime::get_poll_stub(pc);  </li>
<li>}   </li>
<li>....  </li>
<li>}  </li>
</ol>
<p>在linux x86,64 bit的体系中，poll stub 的地址 就是 SafepointSynchronize::handle_polling_page_exception 详细程序可见shareRuntime_x86_64.cpp</p>
<p>回到safepoint.cpp中，SafepointSynchronize::handle_polling_page_exception通过取出线程的safepoint_stat,调用函数void ThreadSafepointState::handle_polling_page_exception，最后通过调用SafepointSynchronize::block(thread()); 来block当前线程。</p>
<h3 id="-d-block-"><a href=""></a>d. block 状态</h3>
<p>当线程进入block状态的时候，继续保持block状态。
来源： <a href="[http://blog.csdn.net/raintungli/article/details/7162468](http://blog.csdn.net/raintungli/article/details/7162468)">[http://blog.csdn.net/raintungli/article/details/7162468](http://blog.csdn.net/raintungli/article/details/7162468)</a><a href="http://blog.csdn.net/raintungli/article/details/7245709" target="_blank">Java 工具（jmap,jstack）在linux上的源码分析(五) -F 参数的bug</a></p>
<p>当使用jmap,jstack是用-F参数的时候，是通过调用系统调用ptrace来取的寄存器的信息，关于linux下的ptrace实现可以参考我的博客（<a href="http://blog.csdn.net/raintungli/article/details/6563867" target="_blank"><a href="http://blog.csdn.net/raintungli/article/details/6563867">http://blog.csdn.net/raintungli/article/details/6563867</a></a>）</p>
<p>在jdk6u23版本之前你会发现，当你使用jstack -F的时候 经常在logger 里面 看到错误信息，直接抛出异常，根本无法看到堆栈信息。</p>
<p>Thread 26724: (state = BLOCKED)
Error occurred during stack walking:
sun.jvm.hotspot.debugger.DebuggerException: sun.jvm.hotspot.debugger.DebuggerException: get_thread_regs failed for a lwp
        at sun.jvm.hotspot.debugger.linux.LinuxDebuggerLocal$LinuxDebuggerLocalWorkerThread.execute(LinuxDebuggerLocal.java:152)
        at sun.jvm.hotspot.debugger.....</p>
<p>通过查看源码，最后调用的函数是process_get_lwp_regs /ps_proc.c</p>
<p><strong>[cpp]</strong> <a href="http://blog.csdn.net/raintungli/article/details/7245709#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/raintungli/article/details/7245709#" title="copy" target="_blank">copy</a></p>
<ol>
<li>static bool process_get_lwp_regs(struct ps_prochandle/<em> ph, pid_t pid, struct user_regs_struct /</em>user) {  </li>
<li>// we have already attached to all thread &#39;pid&#39;s, just use ptrace call  </li>
<li>// to get regset now. Note that we don&#39;t cache regset upfront for processes.  </li>
<li>// Linux on x86 and sparc are different.  On x86 ptrace(PTRACE_GETREGS, ...)  </li>
<li>// uses pointer from 4th argument and ignores 3rd argument.  On sparc it uses  </li>
<li>// pointer from 3rd argument and ignores 4th argument  </li>
<li>/#if defined(sparc) || defined(sparcv9)  </li>
<li>/#define ptrace_getregs(request, pid, addr, data) ptrace(request, pid, addr, data)  </li>
<li>/#else  </li>
<li>/#define ptrace_getregs(request, pid, addr, data) ptrace(request, pid, data, addr)  </li>
<li>/#endif  </li>
<li></li>
<li>/#ifdef _LP64  </li>
<li>/#ifdef PTRACE_GETREGS64  </li>
<li>/#define PTRACE_GETREGS_REQ PTRACE_GETREGS64  </li>
<li>/#endif  </li>
<li>/#else  </li>
<li>/#if defined(PTRACE_GETREGS) || defined(PT_GETREGS)  </li>
<li>/#define PTRACE_GETREGS_REQ PTRACE_GETREGS  </li>
<li>/#endif  </li>
<li>/#endif //<em> _LP64 /</em>/  </li>
<li></li>
<li>/#ifdef PTRACE_GETREGS_REQ  </li>
<li>if (ptrace_getregs(PTRACE_GETREGS_REQ, pid, user, NULL) &lt; 0) {  </li>
<li>print_debug(&quot;ptrace(PTRACE_GETREGS, ...) failed for lwp %d\n&quot;, pid);  </li>
<li>return false;  </li>
<li>}  </li>
<li>return true;  </li>
<li>/#else  </li>
<li>print_debug(&quot;ptrace(PTRACE_GETREGS, ...) not supported\n&quot;);  </li>
<li>return false;  </li>
<li>/#endif  </li>
<li></li>
<li>}  </li>
</ol>
<p>无法判断究竟是否是因为没有定义参数PTRACE_GETREGS_REQ，还是因为ptrace的调用参数错误所导致的，这样就必须打开print_debug，查看打印的信息。</p>
<p>通过源码，可以查到print_debug函数是通过环境变量LIBSAPROC_DEBUG来控制</p>
<p>设置 </p>
<p>export LIBSAPROC_DEBUG=1</p>
<p>运行</p>
<p>jstack -F processid</p>
<p>我们能看到错误中多了一行</p>
<p><strong>[cpp]</strong> <a href="http://blog.csdn.net/raintungli/article/details/7245709#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/raintungli/article/details/7245709#" title="copy" target="_blank">copy</a></p>
<ol>
<li>Thread 26724: (state = BLOCKED)  </li>
<li>libsaproc DEBUG: ptrace(PTRACE_GETREGS, ...) not supported  </li>
</ol>
<p>产生的原因就非常清楚了，bug主要是因为宏定义PTRACE_GETREGS_REQ缺失，查看源码</p>
<p><strong>[cpp]</strong> <a href="http://blog.csdn.net/raintungli/article/details/7245709#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/raintungli/article/details/7245709#" title="copy" target="_blank">copy</a></p>
<ol>
<li>/#ifdef _LP64  </li>
<li>/#ifdef PTRACE_GETREGS64  </li>
<li>/#define PTRACE_GETREGS_REQ PTRACE_GETREGS64  </li>
<li>/#endif  </li>
<li>/#else  </li>
<li>/#if defined(PTRACE_GETREGS) || defined(PT_GETREGS)  </li>
<li>/#define PTRACE_GETREGS_REQ PTRACE_GETREGS  </li>
<li>/#endif  </li>
<li>/#endif //<em> _LP64 /</em>/  </li>
</ol>
<p>_LP64 是64位机器的宏定义，而对ptrace的参数PTRACE_GETREGS64，显然Linux kernel 2.6.35里面并没有支持，导致了没有宏定义PTRACE_GETREGS_REQ，这里明显是jvm没有考虑到的情况。</p>
<p>解决办法</p>
<p>a. 因为这是jvm 编译级别的bug，除非你重现修改编译libsaproc.so，覆盖目录/jdk1.6.0_23/jre/lib/amd64</p>
<p>笔者自己编译了这个lib,可以在csdn上下载（<a href="http://download.csdn.net/detail/raintungli/4065304" target="_blank"><a href="http://download.csdn.net/detail/raintungli/4065304">http://download.csdn.net/detail/raintungli/4065304</a></a>），笔者编译的jdk版本是1.6.23 build(19.0)</p>
<p>b. 建议升级jvm到1.6.30版本，该版本已经测试过，已经修复该bug.</p>
<p>后话：</p>
<p><strong>[cpp]</strong> <a href="http://blog.csdn.net/raintungli/article/details/7245709#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/raintungli/article/details/7245709#" title="copy" target="_blank">copy</a></p>
<ol>
<li>if (ptrace_getregs(PTRACE_GETREGS_REQ, pid, user, NULL) &lt; 0) {  </li>
<li>print_debug(&quot;ptrace(PTRACE_GETREGS, ...) failed for lwp %d\n&quot;, pid);  </li>
<li>return false;  </li>
<li>}  </li>
</ol>
<p>jvm可以在此处更清楚点，不是简单的判断&lt;0，而是在判断&lt;0的时候把errno打印出来，能更容易的判断出是什么原因无法ptrace 上。</p>
<p>来源： <a href="[http://blog.csdn.net/raintungli/article/details/7245709](http://blog.csdn.net/raintungli/article/details/7245709)">[http://blog.csdn.net/raintungli/article/details/7245709](http://blog.csdn.net/raintungli/article/details/7245709)</a><a href="http://blog.csdn.net/raintungli/article/details/7289639" target="_blank">Java 工具（jmap,jstack）在linux上的源码分析(六) -F 参数 读取动态链接共享库文件中的符号表</a></p>
<p>通常我们使用jmap,jstack 去检查堆栈信息的时候，是不会使用-f参数的，但有的时候系统在无法打印出堆栈信息的时候，会建议你使用参数-F。</p>
<p>关于-F参数与非-F参数的区别笔者已经在前面的博客中讲述（<a href="http://blog.csdn.net/raintungli/article/details/7023092" target="_blank"><a href="http://blog.csdn.net/raintungli/article/details/7023092">http://blog.csdn.net/raintungli/article/details/7023092</a></a>），简单的说也就是一种是让jvm进程自己打印出堆栈信息，另有一种是直接访问jvm的堆栈区通过固定的结构找出我们需要的信息。</p>
<h1 id="-1-linux-f-"><a href=""></a>1. Linux-F参数的实现</h1>
<p>在linux中可以使用ptrace的系统调用去访问运行中的进程的内存信息，具体如何实现可以参考笔者的博客（<a href="http://blog.csdn.net/raintungli/article/details/6563867" target="_blank"><a href="http://blog.csdn.net/raintungli/article/details/6563867">http://blog.csdn.net/raintungli/article/details/6563867</a></a>）</p>
<p>在java中使用动态加载的方式加载jvm自己的链接共享库，jvm的核心链接共享库是libjvm.so，linux中如何动态加载可以参考（<a href="http://www.ibm.com/developerworks/cn/linux/l-dynamic-libraries/#dynamiclinking" target="_blank"><a href="http://www.ibm.com/developerworks/cn/linux/l-dynamic-libraries//#dynamiclinking">http://www.ibm.com/developerworks/cn/linux/l-dynamic-libraries//#dynamiclinking</a></a>）</p>
<p>因为是动态共享库，当想查找具体的参数的值，内存的信息的时候，就需要计算出正确的参数或者函数的地址。</p>
<h1 id="-2-"><a href=""></a>2. 共享库中的符号相对地址偏移</h1>
<p>可运行程序，共享库使用ELF格式，当运行一个程序的时候，内核会把ELF加载到用户空间，里面记录了程序的函数和数据的地址和内容，elf文件格式就不具体描述了。</p>
<p>在linux 中可以使用结构体ELF_EHDR，ELF_PHDR，ELF_SHDR读出elf 的program header, section header, section data.</p>
<p>在jvm中源码具体实现请参考 /hotspot/agent/os/linux/salibelf.c </p>
<p>在linux中本身就自带一个读取elf格式的工具，readelf 你可以使用不同的参数读取不同的内容。</p>
<p><strong>[cpp]</strong> <a href="http://blog.csdn.net/raintungli/article/details/7289639#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/raintungli/article/details/7289639#" title="copy" target="_blank">copy</a></p>
<ol>
<li>readelf -s libjvm.so  </li>
</ol>
<p>显示共享库中的方法参数的虚拟地址，类型，名字</p>
<p><strong>[cpp]</strong> <a href="http://blog.csdn.net/raintungli/article/details/7289639#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/raintungli/article/details/7289639#" title="copy" target="_blank">copy</a></p>
<ol>
<li>readelf -l libjvm.so  </li>
</ol>
<p>读取program headers，其中出现2个LOAD的类型，第一个是程序的指令虚拟的起始地址，另一个是程序数据的起始地址</p>
<p>通过2个地址我们就能找到共享库中的参数，函数的相对地址的偏移</p>
<h1 id="-3-"><a href=""></a>3. 进程中的符号地址</h1>
<p>在第二章节中，得到的只是相对的地址偏移，并不是真实运行中的进程的符号地址，如何得到真实的地址在linux中就相对比较简单。</p>
<p><strong>[cpp]</strong> <a href="http://blog.csdn.net/raintungli/article/details/7289639#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/raintungli/article/details/7289639#" title="copy" target="_blank">copy</a></p>
<ol>
<li><p>cat /proc/$processid/maps<br>在maps里详细记录了进程的堆栈分配的地址，包括共享库的地址，那么起始地址就是这个库分配的最小地址
<strong>[cpp]</strong> <a href="http://blog.csdn.net/raintungli/article/details/7289639#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/raintungli/article/details/7289639#" title="copy" target="_blank">copy</a></p>
</li>
<li><p>进程中共享库分配的最小地址+相对地址的偏移 =真实的进程中该函数或变量的真实地址  </p>
</li>
</ol>
<h1 id="-4-java-tool-"><a href=""></a>4. Java tool 保存的符号表</h1>
<p>在jmap/jstack 中，为了提高读取符号地址的性能，避免每一次要找符号的地址从elf文件中查找，只是在初始话的时候将符号表保存成哈希表，其中key是符号的名字，内容是符号的地址，长度。</p>
<p>具体实现可以参考  /hotspot/src/os/linux/symtab.c build_symtab_internal 函数</p>
<p>来源： <a href="[http://blog.csdn.net/raintungli/article/details/7289639](http://blog.csdn.net/raintungli/article/details/7289639)">[http://blog.csdn.net/raintungli/article/details/7289639](http://blog.csdn.net/raintungli/article/details/7289639)</a></p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/内存分析/">内存分析</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/内存分析/" class="label label-success">内存分析</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:40"datetime="2014-03-07 09:54:40"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-内存分析--Java工具（jmap-jstack）在linux上的源码分析/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-内存分析--Java工具（jmap-jstack）在linux上的源码分析" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-内存分析--jvmcrash的崩溃日志详细分析及注意点/">jvm crash 的崩溃日志详细分析及注意点</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:40.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-内存分析--jvmcrash的崩溃日志详细分析及注意点/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="jvm-crash-">jvm crash 的崩溃日志详细分析及注意点</h1>
<h2 id="-">生成</h2>
<ol>
<li><p>生成error 文件的路径：你可以通过参数设置-XX:ErrorFile=/path/hs_error%p.log, 默认是在java运行的当前目录 [default: ./hs_err_pid%p.log]</p>
</li>
<li><p>参数-XX:OnError  可以在crash退出的时候执行命令，格式是-XX:OnError=“string”,  <string> 可以是命令的集合，用分号做分隔符, 可以用&quot;%p&quot;来取到当前进程的ID.
例如：</p>
</li>
</ol>
<p>// -XX:OnError=&quot;pmap %p&quot;                // show memory map</p>
<p>// -XX:OnError=&quot;gcore %p; dbx - %p&quot;     // dump core and launch debugger</p>
<p>在linux中系统会fork出一个子进程去执行shell的命令，因为是用fork可能会内存不够的情况，注意修改你的 /proc/sys/vm/overcommit_memory 参数,不清楚为什么这里不使用vfork</p>
<ol>
<li>-XX:+ShowMessageBoxOnError 参数，当jvm crash的时候在linux里会启动gdb 去分析和调式，适合在测试环境中使用。</li>
</ol>
<h2 id="-error-"><a href=""></a>什么情况下不会生成error文件</h2>
<p>linux 内核在发生OOM的时候会强制kill一些进程, 可以在/var/logs/messages中查找</p>
<h2 id="-error-crash-"><a href=""></a>Error crash 文件的几个重要部分</h2>
<p><strong>a.  错误信息概要</strong></p>
<p><strong>[plain]</strong> <a href="http://blog.csdn.net/raintungli/article/details/7642575#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/raintungli/article/details/7642575#" title="copy" target="_blank">copy</a></p>
<ol>
<li>/# A fatal error has been detected by the Java Runtime Environment:  </li>
<li>/#  </li>
<li>/#  SIGSEGV (0xb) at pc=0x0000000000043566, pid=32046, tid=1121192256  </li>
<li>/#  </li>
<li>/# JRE version: 6.0_17-b04  </li>
<li>/# Java VM: Java HotSpot(TM) 64-Bit Server VM (14.3-b01 mixed mode linux-amd64 )  </li>
<li>/# Problematic frame:  </li>
<li>/# C  0x0000000000043566  </li>
<li>/#  </li>
<li>/# If you would like to submit a bug report, please visit:  </li>
<li>/#   <a href="http://java.sun.com/webapps/bugreport/crash.jsp" target="_blank">http://java.sun.com/webapps/bugreport/crash.jsp</a>  </li>
<li>/# The crash happened outside the Java Virtual Machine in native code.  </li>
<li>/# See problematic frame for where to report the bug.<br>SIGSEGV 错误的信号类型 </li>
</ol>
<p>pc 就是IP/PC寄存器值也就是执行指令的代码地址</p>
<p>pid 就是进程id</p>
<p>/# Problematic frame:</p>
<p>/# V  [libjvm.so+0x593045]</p>
<p>就是导致问题的动态链接库函数的地址</p>
<p>pc 和 +0x593045 指的是同一个地址，只是一个是动态的偏移地址，一个是运行的虚拟地址</p>
<p><strong>b.信号信息</strong></p>
<p>Java中在linux 中注册的信号处理函数，中间有2个参数info, ucvoid</p>
<p><strong>[cpp]</strong> <a href="http://blog.csdn.net/raintungli/article/details/7642575#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/raintungli/article/details/7642575#" title="copy" target="_blank">copy</a></p>
<ol>
<li>static void crash_handler(int sig, siginfo_t/<em> info, void/</em> ucVoid) {  </li>
<li>// unmask current signal  </li>
<li>sigset_t newset;  </li>
<li>sigemptyset(&amp;newset);  </li>
<li>sigaddset(&amp;newset, sig);  </li>
<li>sigprocmask(SIG_UNBLOCK, &amp;newset, NULL);  </li>
<li></li>
<li>VMError err(NULL, sig, NULL, info, ucVoid);  </li>
<li>err.report_and_die();  </li>
<li>}<br>在crash report中的信号错误提示</li>
</ol>
<p><strong>[plain]</strong> <a href="http://blog.csdn.net/raintungli/article/details/7642575#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/raintungli/article/details/7642575#" title="copy" target="_blank">copy</a></p>
<ol>
<li>siginfo:si_signo=SIGSEGV: si_errno=0, si_code=1 (SEGV_MAPERR), si_addr=0x0000000000043566<br>信号的详细信息和si_addr 出错误的内存，都保存在siginfo_t的结构体中，也就是信号注册函数crash_handler里的参数info,内核会保存导致错误的内存地址在用户空间的信号结构体中siginfo_t，这样在进程在注册的信号处理函数中可以取得导致错误的地址。</li>
</ol>
<p><strong>c.寄存器信息</strong></p>
<p><strong>[plain]</strong> <a href="http://blog.csdn.net/raintungli/article/details/7642575#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/raintungli/article/details/7642575#" title="copy" target="_blank">copy</a></p>
<ol>
<li>Registers:  </li>
<li>RAX=0x00002aacb5ae5de2, RBX=0x00002aaaaf46aa48, RCX=0x0000000000000219, RDX=0x00002aaaaf46b920  </li>
<li>RSP=0x0000000042d3f968, RBP=0x0000000042d3f9c8, RSI=0x0000000042d3f9e8, RDI=0x0000000045aef9b8  </li>
<li>R8 =0x0000000000000f80, R9 =0x00002aaab3d30ce8, R10=0x00002aaaab138ea1, R11=0x00002b017ae65110  </li>
<li>R12=0x0000000042d3f6f0, R13=0x00002aaaaf46aa48, R14=0x0000000042d3f9e8, R15=0x0000000045aef800  </li>
<li>RIP=0x0000000000043566, EFL=0x0000000000010202, CSGSFS=0x0000000000000033, ERR=0x0000000000000014  </li>
<li>TRAPNO=0x000000000000000e<br>寄存器的信息就保存在b部分的信号处理函数参数 (ucontext_t/*)usVoid中</li>
</ol>
<p>在X86架构下：</p>
<p><strong>[cpp]</strong> <a href="http://blog.csdn.net/raintungli/article/details/7642575#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/raintungli/article/details/7642575#" title="copy" target="_blank">copy</a></p>
<ol>
<li>void os::print_context(outputStream /<em>st, void /</em>context) {  </li>
<li>if (context == NULL) return;  </li>
<li></li>
<li>ucontext_t /<em>uc = (ucontext_t/</em>)context;  </li>
<li>st-&gt;print_cr(&quot;Registers:&quot;);  </li>
<li>/#ifdef AMD64  </li>
<li>st-&gt;print(  &quot;RAX=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_RAX]);  </li>
<li>st-&gt;print(&quot;, RBX=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_RBX]);  </li>
<li>st-&gt;print(&quot;, RCX=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_RCX]);  </li>
<li>st-&gt;print(&quot;, RDX=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_RDX]);  </li>
<li>st-&gt;cr();  </li>
<li>st-&gt;print(  &quot;RSP=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_RSP]);  </li>
<li>st-&gt;print(&quot;, RBP=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_RBP]);  </li>
<li>st-&gt;print(&quot;, RSI=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_RSI]);  </li>
<li>st-&gt;print(&quot;, RDI=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_RDI]);  </li>
<li>st-&gt;cr();  </li>
<li>st-&gt;print(  &quot;R8 =&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_R8]);  </li>
<li>st-&gt;print(&quot;, R9 =&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_R9]);  </li>
<li>st-&gt;print(&quot;, R10=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_R10]);  </li>
<li>st-&gt;print(&quot;, R11=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_R11]);  </li>
<li>st-&gt;cr();  </li>
<li>st-&gt;print(  &quot;R12=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_R12]);  </li>
<li>st-&gt;print(&quot;, R13=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_R13]);  </li>
<li>st-&gt;print(&quot;, R14=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_R14]);  </li>
<li>st-&gt;print(&quot;, R15=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_R15]);  </li>
<li>st-&gt;cr();  </li>
<li>st-&gt;print(  &quot;RIP=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_RIP]);  </li>
<li>st-&gt;print(&quot;, EFL=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_EFL]);  </li>
<li>st-&gt;print(&quot;, CSGSFS=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_CSGSFS]);  </li>
<li>st-&gt;print(&quot;, ERR=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_ERR]);  </li>
<li>st-&gt;cr();  </li>
<li>st-&gt;print(&quot;  TRAPNO=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_TRAPNO]);  </li>
<li>/#else  </li>
<li>st-&gt;print(  &quot;EAX=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_EAX]);  </li>
<li>st-&gt;print(&quot;, EBX=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_EBX]);  </li>
<li>st-&gt;print(&quot;, ECX=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_ECX]);  </li>
<li>st-&gt;print(&quot;, EDX=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_EDX]);  </li>
<li>st-&gt;cr();  </li>
<li>st-&gt;print(  &quot;ESP=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_UESP]);  </li>
<li>st-&gt;print(&quot;, EBP=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_EBP]);  </li>
<li>st-&gt;print(&quot;, ESI=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_ESI]);  </li>
<li>st-&gt;print(&quot;, EDI=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_EDI]);  </li>
<li>st-&gt;cr();  </li>
<li>st-&gt;print(  &quot;EIP=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_EIP]);  </li>
<li>st-&gt;print(&quot;, CR2=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.cr2);  </li>
<li>st-&gt;print(&quot;, EFLAGS=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_EFL]);  </li>
<li>/#endif // AMD64  </li>
<li>st-&gt;cr();  </li>
<li>st-&gt;cr();  </li>
<li></li>
<li>intptr_t /<em>sp = (intptr_t /</em>)os::Linux::ucontext_get_sp(uc);  </li>
<li>st-&gt;print_cr(&quot;Top of Stack: (sp=&quot; PTR_FORMAT &quot;)&quot;, sp);  </li>
<li>print_hex_dump(st, (address)sp, (address)(sp + 8/*sizeof(intptr_t)), sizeof(intptr_t));  </li>
<li>st-&gt;cr();  </li>
<li></li>
<li>// Note: it may be unsafe to inspect memory near pc. For example, pc may  </li>
<li>// point to garbage if entry point in an nmethod is corrupted. Leave  </li>
<li>// this at the end, and hope for the best.  </li>
<li>address pc = os::Linux::ucontext_get_pc(uc);  </li>
<li>st-&gt;print_cr(&quot;Instructions: (pc=&quot; PTR_FORMAT &quot;)&quot;, pc);  </li>
<li>print_hex_dump(st, pc - 16, pc + 16, sizeof(char));  </li>
<li>}<br>寄存器的信息在分析出错的时候是非常重要的
打印出执行附近的部分机器码</li>
</ol>
<p><strong>[plain]</strong> <a href="http://blog.csdn.net/raintungli/article/details/7642575#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/raintungli/article/details/7642575#" title="copy" target="_blank">copy</a></p>
<ol>
<li>Instructions: (pc=0x00007f48f14ef51a)  </li>
<li>0x00007f48f14ef4fa:   90 90 55 48 89 e5 48 81 ec 98 9f 00 00 48 89 bd  </li>
<li>0x00007f48f14ef50a:   f8 5f ff ff 48 89 b5 f0 5f ff ff b8 00 00 00 00  </li>
<li>0x00007f48f14ef51a:   c7 00 01 00 00 00 c6 85 00 60 ff ff ff c9 c3 90  </li>
<li>0x00007f48f14ef52a:   90 90 90 90 90 90 55 48 89 e5 53 48 8d 1d 94 00<br>在instruction 部分中会打印出部分的机器码</li>
</ol>
<p>格式是</p>
<p><strong>[cpp]</strong> <a href="http://blog.csdn.net/raintungli/article/details/7642575#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/raintungli/article/details/7642575#" title="copy" target="_blank">copy</a></p>
<ol>
<li>地址：机器码<br>第一种使用udis库里带的udcli工具来反汇编</li>
</ol>
<p>命令：</p>
<p><strong>[cpp]</strong> <a href="http://blog.csdn.net/raintungli/article/details/7642575#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/raintungli/article/details/7642575#" title="copy" target="_blank">copy</a></p>
<ol>
<li>echo &#39;90 90 55 48 89 e5 48 81 ec 98 9f 00 00 48 89 bd&#39; | udcli -intel -x -64 -o 0x00007f48f14ef4fa<br>显示出对应的汇编</li>
</ol>
<p>第二种可以用</p>
<p><strong>[plain]</strong> <a href="http://blog.csdn.net/raintungli/article/details/7642575#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/raintungli/article/details/7642575#" title="copy" target="_blank">copy</a></p>
<ol>
<li>objectdump -d -C libjvm.so &gt;&gt; jvmsodisass.dump   </li>
</ol>
<p>查找偏移地址  0x593045， 就是当时的执行的汇编，然后结合上下文，源码推测出问题的语句。</p>
<p><strong>d.寄存器对应的内存的值</strong></p>
<p><strong>[cpp]</strong> <a href="http://blog.csdn.net/raintungli/article/details/7642575#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/raintungli/article/details/7642575#" title="copy" target="_blank">copy</a></p>
<ol>
<li>RAX=0x0000000000000000 is an unknown value  </li>
<li>RBX=0x000000041a07d1e8 is an oop  </li>
<li>{method}  </li>
<li><ul>
<li>klass: {other class}  </li>
</ul>
</li>
<li>RCX=0x0000000000000000 is an unknown value  </li>
<li>RDX=0x0000000040111800 is a thread  </li>
<li>RSP=0x0000000041261b88 is pointing into the stack for thread: 0x0000000040111800  </li>
<li>RBP=0x000000004126bb20 is pointing into the stack for thread: 0x0000000040111800  </li>
<li>RSI=0x000000004126bb80 is pointing into the stack for thread: 0x0000000040111800  </li>
<li>RDI=0x00000000401119d0 is an unknown value  </li>
<li>R8 =0x0000000040111c40 is an unknown value  </li>
<li>R9 =0x00007f48fcc8b550: <offset 0xa85550> in /usr/java/jdk1.6.0_30/jre/lib/amd64/server/libjvm.so at 0x00007f48fc206000  </li>
<li>R10=0x00007f48f8ca7d41 is an Interpreter codelet  </li>
<li>method entry point (kind = native)  [0x00007f48f8ca7ae0, 0x00007f48f8ca8320]  2112 bytes  </li>
<li>R11=0x00007f48fc98f270: <offset 0x789270> in /usr/java/jdk1.6.0_30/jre/lib/amd64/server/libjvm.so at 0x00007f48fc206000  </li>
<li>R12=0x0000000000000000 is an unknown value  </li>
<li>R13=0x000000041a07d1e8 is an oop  </li>
<li>{method}  </li>
<li><ul>
<li>klass: {other class}  </li>
</ul>
</li>
<li>R14=0x000000004126bb88 is pointing into the stack for thread: 0x0000000040111800  </li>
<li>R15=0x0000000040111800 is a thread<br>jvm 会通过寄存器的值对找对应的对象，也是一个比较好的参考</li>
</ol>
<p><strong>e. 其他的信息</strong></p>
<p>error 里面还有一些线程信息，还有当时内存映像信息，这些都可以作为分析的部分参考</p>
<p>crash 报告可以大概的反应出一个当时的情况，特别是在没有core dump的时候，是比较有助于帮助分析的，但如果有core dump的话，最终还是core dump能快速准确的发现问题原因。
来源： <a href="[http://blog.csdn.net/raintungli/article/details/7642575/#comments](http://blog.csdn.net/raintungli/article/details/7642575#comments)">[http://blog.csdn.net/raintungli/article/details/7642575/#comments](http://blog.csdn.net/raintungli/article/details/7642575#comments)</a> </p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/内存分析/">内存分析</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/内存分析/" class="label label-success">内存分析</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:40"datetime="2014-03-07 09:54:40"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-内存分析--jvmcrash的崩溃日志详细分析及注意点/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-内存分析--jvmcrash的崩溃日志详细分析及注意点" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-内存分析--一次Java内存溢出异常的分析过程/">一次Java内存溢出异常的分析过程</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:40.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-内存分析--一次Java内存溢出异常的分析过程/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-java-">一次Java内存溢出异常的分析过程</h1>
<p>前些天，<a href="http://server.chinabyte.com/" target="_blank">服务器</a>上一个服务跑了一个多月突然当掉了。看了下日志，程序抛出了java.lang.OutOfMemoryError，之前也出现过同样的错误，服务跑了三个月内存溢出。出现这个异常，初步判断是程序有内存泄漏，接下来需要利用一些工具来分析具体原因。</p>
<p>首先使用jdk自带的工具jmap转储(dump)java内存堆数据到本地文件中。jmap转储(dump)命令格式如下：</p>
<p>jmap -dump:</p>
<p>表示dump选项，表示需要dump的java应用程序的进程ID</p>
<p>dump-options可以有以下三种参数，参数之间用逗号隔开：</p>
<p>live，只dump活动的object，如果没有指定，表示dump所有object</p>
<p>format=b，字节流格式</p>
<p>file=，是转储文件的保存路径</p>
<p>下面是dump命令的一个例子:</p>
<p>jmap -dump:format=b,file=heap.bin 8023</p>
<p>dump完成后，用Eclipse Memory Analyzer打开转储文件进行分析。Eclipse Memory Analyzer是一个java内存堆转储文件分析工具，可以生成内存分析报告(包括内存泄露Leak Suspects )。下面是分析完成后查看Top Consumers所看到的图表:</p>
<p><img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>看到这两张图表，问题就比较明朗了。berkeley db中的数据结点com.sleepycat.je.tree.BIN占用了大量内存，导致内存溢出了。为了提高访问效率，berkeley db会缓存大量的结点，缓存大小限制可以在EnvironmentConfig设置，默认为jvm内存大小限制的60%。而这个应用程序中使用了5个EnvironmentImpl，并且都未单独设置缓存大小，总的缓存限制为jvm内存限制的300%(图表中BIN结点已经占用了94.55%的内存)，远远超出java的内存限制。随着服务的运行，缓存数据越来越多，最后导致内存溢出错误。因此，为每个EnvironmentImpl设置合适的缓存大小限制，就可以避免再次发生内存溢出。
来源： <a href="[http://soft.chinabyte.com/database/475/12147475.shtml](http://soft.chinabyte.com/database/475/12147475.shtml)">[http://soft.chinabyte.com/database/475/12147475.shtml](http://soft.chinabyte.com/database/475/12147475.shtml)</a> </p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/内存分析/">内存分析</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/内存分析/" class="label label-success">内存分析</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:40"datetime="2014-03-07 09:54:40"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-内存分析--一次Java内存溢出异常的分析过程/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-内存分析--一次Java内存溢出异常的分析过程" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-内存分析--内存离线分析——jhat命令JavaHeapAnalyseTool/">内存离线分析——jhat命令(Java Heap Analyse Tool)</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:40.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-内存分析--内存离线分析——jhat命令JavaHeapAnalyseTool/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-jhat-java-heap-analyse-tool-">内存离线分析——jhat命令(Java Heap Analyse Tool)</h1>
<p><strong>jhat命令 -- Java Head Analyse Tool</strong>
用途：是用来分析java堆的命令，可以将堆中的对象以html的形式显示出来，包括对象的数量，大小等等，并支持对象查询语言
第一步：导出堆
<img src="http://hi.csdn.net/attachment/201011/27/0_1290844064DW4R.gif" alt="">
第二步：分析堆文件
<img src="http://hi.csdn.net/attachment/201011/27/0_12908442022NhZ.gif" alt="">
第三步：查看html
<img src="http://hi.csdn.net/attachment/201011/27/0_1290844795NW5d.gif" alt=""></p>
<p>有时你dump出来的堆很大，在启动时会报堆空间不足的错误，可以使用如下参数：
<strong>jhat -J-Xmx512m <heap dump file>
对于jhat启动后显示的html页面中功能：
（1）显示出堆中所包含的所有的类
<img src="http://hi.csdn.net/attachment/201011/27/0_1290845808988Q.gif" alt="">
（2）从根集能引用到的对象
<img src="http://hi.csdn.net/attachment/201011/27/0_1290846435q4Lt.gif" alt="">
（3）显示平台包括的所有类的实例数量
<img src="http://hi.csdn.net/attachment/201011/27/0_1290846620I6qt.gif" alt="">
（4）堆实例的分布表
<img src="http://hi.csdn.net/attachment/201011/27/0_1290846932gSmq.gif" alt=""></strong></p>
<p><strong>（5）执行对象查询语句
<img src="http://hi.csdn.net/attachment/201011/27/0_1290847142bSbC.gif" alt="">
更多关于对象查询语言的信息，见这篇文章：
<a href="http://blog.csdn.net/gtuu0123/archive/2010/11/27/6039592.aspx" target="_blank">http://blog.csdn.net/gtuu0123/archive/2010/11/27/6039592.aspx</a></strong>
done</p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/内存分析/">内存分析</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/内存分析/" class="label label-success">内存分析</a></span> | <span class="time">recent updated:<time title="2014-03-30 13:27:37"datetime="2014-03-30 13:27:37"> mar. 30 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-内存分析--内存离线分析——jhat命令JavaHeapAnalyseTool/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-内存分析--内存离线分析——jhat命令JavaHeapAnalyseTool" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-算法数组优化-算法--数学之美番外篇：快排为什么那样快/">数学之美番外篇：快排为什么那样快</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:40.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-算法数组优化-算法--数学之美番外篇：快排为什么那样快/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-">数学之美番外篇：快排为什么那样快</h1>
<ul>
<li><a href="http://mindhacks.cn/about/" target="_blank">Mind Hacks 的含义</a></li>
<li><a href="http://mindhacks.cn/former-life-of-mindhacks/" target="_blank">前世档案 | C++的罗浮宫</a></li>
<li><a href="http://mindhacks.cn/archives/" target="_blank">所有文章</a></li>
<li><a href="http://mindhacks.cn/about-toplanguage/" target="_blank">TopLanguage 讨论组</a></li>
<li><a href="http://mindhacks.cn/friend-links/" target="_blank">价值博客们</a></li>
</ul>
<p><a href="http://mindhacks.cn/" target="_blank">刘未鹏 | Mind Hacks</a> 思维改变生活</p>
<ul>
<li><a href="http://mindhacks.cn/topics/learning-method/" target="_blank">学习方法</a></li>
<li><a href="http://mindhacks.cn/topics/mind/" target="_blank">思维改变生活</a></li>
<li><a href="http://mindhacks.cn/topics/algorithms/" target="_blank">算法</a></li>
<li><a href="http://mindhacks.cn/topics/computer-science/" target="_blank">计算机科学</a></li>
<li><a href="http://mindhacks.cn/topics/math/" target="_blank">数学</a></li>
<li><a href="http://mindhacks.cn/topics/machine-learning/" target="_blank">机器学习与人工智能</a></li>
<li><p><a href="http://mindhacks.cn/topics/programming/" target="_blank">编程</a></p>
</li>
<li><p><a href="http://mindhacks.cn/feed/" title="刘未鹏 | Mind Hacks RSS Feed" target="_blank">RSS Feed</a></p>
</li>
</ul>
<h1 id="-http-mindhacks-cn-2008-06-13-why-is-quicksort-so-quick-"><a href="http://mindhacks.cn/2008/06/13/why-is-quicksort-so-quick/" target="_blank">数学之美番外篇：快排为什么那样快</a></h1>
<p>By <a href="http://mindhacks.cn/author/pongba/" title="???" target="_blank">???</a> – June 13, 2008<strong>Posted in:</strong><a href="http://mindhacks.cn/topics/math/" target="_blank">数学</a>, <a href="http://mindhacks.cn/topics/algorithms/" target="_blank">算法</a>, <a href="http://mindhacks.cn/topics/computer-science/" target="_blank">计算机科学</a></p>
<p><strong>目录</strong></p>
<ol>
<li><p>前言</p>
</li>
<li><p>猜数字</p>
</li>
<li><p>称球</p>
</li>
<li><p>排序</p>
<p> 3.1 为什么堆排比快排慢</p>
<p> 3.2 为什么快排其实也不是那么快</p>
<p> 3.3 基排又为什么那么快呢</p>
</li>
<li><p>信息论！信息论？</p>
</li>
<li><p>小结</p>
</li>
</ol>
<p><strong>0.**</strong>前言**</p>
<p>知道这个理论是在<a href="http://groups.google.com/group/pongba" target="_blank">TopLanguage</a>上的一次讨论，先是g9<a href="http://groups.google.com/group/pongba/msg/f95aa12feb4dfd67" target="_blank">转了David MacKay的一篇文章</a>，然后引发了牛人们的<a href="http://groups.google.com/group/pongba/browse_frm/thread/28ac39e0222becf2" target="_blank">一场关于信息论的讨论</a>。Anyway，正如g9很久以前在<a href="http://blog.csdn.net/g9yuayon" target="_blank">Blog</a>里面所<a href="http://blog.csdn.net/g9yuayon/archive/2007/04/22/1574518.aspx" target="_blank">说</a>的：
有时无知是福。俺看到一点新鲜的科普也能觉得造化神奇。刚才读Gerald Jay Sussman（<a href="http://mitpress.mit.edu/sicp/" target="_blank">SICP</a>作者）的文章，<a href="http://swiss.csail.mit.edu/classes/symbolic/spring07/readings/robust-systems.pdf" target="_blank">Building Robust Systems – an essay</a>，竟然心如小鹿乱撞，手心湿润，仿佛第一次握住初恋情人温柔的手。</p>
<p>而看到<a href="http://users.aims.ac.za/~mackay/" target="_blank">MacKay</a>的这篇文章我也有这种感觉——以前模糊的东西忽然有了深刻的解释，一切顿时变得明白无比。原来看问题的角度或层面能够带来这么大的变化。再一次印证了越是深刻的原理往往越是简单和强大。所以说，土鳖也有土鳖的幸福:P</p>
<p>这篇文章相当于MacKay<a href="http://users.aims.ac.za/~mackay/sorting/sorting.html" target="_blank">原文</a>的白话文版。MacKay在原文中用到了信息论的知识，后者在我看来并不是必须的，尽管计算的时候方便，但与本质无关。所以我用大白话解释了一通。</p>
<p><strong>1.**</strong>猜数字**</p>
<p>我们先来玩一个猜数字游戏：我心里默念一个1~64之间的数，你来猜（你只能问答案是“是”或“否”的问题）。为了保证不论在什么情况下都能以尽量少的次数猜中，你应该采取什么策略呢？很显然，二分。先是猜是不是位于1~32之间，排除掉一半可能性，然后对区间继续二分。这种策略能够保证无论数字怎么跟你捉迷藏，都能在log_2{n}次以内猜中。用算法的术语来说就是它的下界是最好的。</p>
<p>我们再来回顾一下这个游戏所蕴含的本质：为什么这种策略具有最优下界？答案也很简单，这个策略是平衡的。反之如果策略不是平衡的，比如问是不是在1~10之间，那么一旦发现不是在1~10之间的话就会剩下比N/2更多的可能性需要去考察了。</p>
<p><a href="http://blog.youxu.info/" target="_blank">徐宥</a>在讨论中提到，这种策略的本质可以概括成“让未知世界无机可乘”。它是没有“弱点的”，<strong>答案的任何一个分支都是等概率的</strong>。反之，一旦某个分支蕴含的可能性更多，当情况落到那个分支上的时候你就郁闷了。比如猜数字游戏最糟糕的策略就是一个一个的猜：是1吗？是2吗？… 因为这种猜法最差的情况下需要64次才能猜对，下界非常糟糕。二分搜索为什么好，就是因为它每次都将可能性排除一半并且<strong>无论如何</strong>都能排除一半（它是最糟情况下表现最好的）。</p>
<p><strong>2.**</strong>称球**</p>
<p>12个小球，其中有一个是坏球。有一架天平。需要你用最少的称次数来确定哪个小球是坏的并且它到底是轻还是重。</p>
<p>这个问题是一道流传已久的智力题。网络上也有很多讲解，还有泛化到N个球的情况下的严格证明。也有零星的一些地方提到从信息论的角度来看待最优解法。本来我一直认为这道题目除了试错之外没有其它高妙的思路了，只能一个个方法试，并尽量从结果中寻找信息，然后看看哪种方案最少。</p>
<p>然而，实际上它的确有其它的思路，一个更本质的思路，而且根本用不着信息论这么拗口的知识。</p>
<p>我们先回顾一下猜数字游戏。为了保证任何情况下以最少次数猜中，我们的策略是每次都排除恰好一半的可能性。类比到称球问题上：坏球可能是12个球中的任意一个，这就是12种可能性；而其中每种可能性下坏球可能轻也可能重。于是“坏球是哪个球，是轻是重”这个问题的答案就有12×2=24种可能性。现在我们用天平来称球，就等同于对这24种可能性发问，由于天平的输出结果有三种“平衡、左倾、右倾”，这就相当于我们的问题有三个答案，即可以将所有的可能性切成三份，根据猜数字游戏的启发，我们应当尽量让这三个分支概率均等，即平均切分所有的可能性为三等份。如此一来的话一次称量就可以将答案的可能性缩减为原来的1/3，三次就能缩减为1/27。而总共才有24种可能性，所以理论上是完全可以3次称出来的。</p>
<p>如何称的指导原则有了，构造一个称的策略就不是什么太困难的事情了。首先不妨解释一下为什么最直观的称法不是最优的——6、6称：在6、6称的时候，天平平衡的可能性是0。刚才说了，最优策略应该使得天平三种状态的概率均等，这样才能三等分答案的所有可能性。</p>
<p>为了更清楚的看待这个问题，我们不妨假设有6个球，来考虑一下3、3称和2、2称的区别：</p>
<p>在未称之前，一共有12种可能性：1轻、1重、2轻、2重、…、6轻、6重。现在将1、2、3号放在左边，4、5、6放在右边3、3称了之后，不失一般性假设天平左倾，那么小球的可能性就变成了原来的一半（6种）：1重、2重、3重、4轻、5轻、6轻。即这种称法能排除一半可能性。</p>
<p>现在再来看2、2称法，即1、2放左边，3、4放右边，剩下的5、6不称，放一边。假设结果是天平平衡，那么可能性剩下——4种：5重、5轻、6重、6轻。假设天平左倾，可能性也剩下4种：1重、2重、3轻、4轻。右倾和左倾的情况类似。总之，这种称法，不管天平结果如何，情况都被我们缩小到了原来的三分之一！我们充分利用了“天平的结果状态可能有三种”这个条件来三等分所有可能性，而不是二等分。</p>
<p>说到这里，剩下的事情就实在很简单了：第二步称法，只要记着这样一个指导思想——你选择的称法必须使得当天平平衡的时候答案剩下的可能性和天平左倾（右倾）的时候答案剩下的可能性一样多。实际上，这等同于你得选择一种称法，使得天平输出三种结果的概率是均等的，因为天平输出某个结果的概率就等同于所有支持这个结果（左倾、右倾、平衡）的答案可能性的和，并且答案的每个可能性都是等概率的。</p>
<p>MacKay在他的书《Information Theory: Inference and Learning Algorithms》（<a href="http://users.aims.ac.za/~mackay/itila/book.html" target="_blank">作者开放免费电子书</a>）里面4.1节专门讲了这个称球问题，还画了一张不错的图，我就照抄了：</p>
<p><a href="http://mindhacks.cn/wp-content/uploads/2009/02/23131201.jpg" target="_blank"><img src="&quot;2313120&quot;" alt="2313120"></a></p>
<p>图中“1+”是指“1号小球为重”这一可能性。一开始一共有24种可能性。4、4称了之后不管哪种情况（分支），剩下来的可能性总是4种。这是一个完美的三分。然后对每个分支构造第二次称法，这里你只要稍加演算就可以发现，分支1上的第二次称法，即“1、2、6对3、4、5”这种称法，天平输出三种结果的可能性是均等的（严格来说是几乎均等）。这就是为什么这个称法能够在最坏的情况下也能表现最好的原因，没有哪个分支是它的弱点，它必然能将情况缩小到原来的1/3。</p>
<p><strong>3.**</strong>排序**</p>
<p>用前面的看问题视角，排序的本质可以这样来表述：一组未排序的N个数字，它们一共有N!种重排，其中只有一种排列是满足题意的（譬如从大到小排列）。换句话说，排序问题的可能性一共有N!种。任何基于比较的排序的基本操作单元都是“比较a和b”，这就相当于猜数字游戏里面的一个问句，显然这个问句的答案只能是“是”或“否”，一个只有两种输出的问题最多只能将可能性空间切成两半，根据上面的思路，最佳切法就是切成1/2和1/2。也就是说，我们希望在比较了a和b的大小关系之后，如果发现a<b的话剩下的排列可能性就变成N!/2，如果发现a>b也是剩下N!/2种可能性。由于假设每种排列的概率是均等的，所以这也就意味着支持a<b的排列一共有N!/2个，支持a>b的也是N!/2个，换言之，a<b的概率等于a>b的概率。</p>
<p>我们希望每次在比较a和b的时候，a<b和a>b的概率是均等的，这样我们就能保证无论如何都能将可能性缩小为原来的一半了！最优下界。</p>
<p>一个直接的推论是，如果每次都像上面这样的完美比较，那么N个元素的N!种可能排列只需要log_2{N!}就排查玩了，而log_2{N!}近似于NlogN。这正是快排的复杂度。</p>
<p><strong>3.1**</strong>为什么堆排比快排慢**</p>
<p>回顾一下堆排的过程：</p>
<ol>
<li><p>建立最大堆（堆顶的元素大于其两个儿子，两个儿子又分别大于它们各自下属的两个儿子… 以此类推）</p>
</li>
<li><p>将堆顶的元素和最后一个元素对调（相当于将堆顶元素（最大值）拿走，然后将堆底的那个元素补上它的空缺），然后让那最后一个元素从顶上往下滑到恰当的位置（重新使堆最大化）。</p>
</li>
<li><p>重复第2步。</p>
</li>
</ol>
<p>这里的关键问题就在于第2步，堆底的元素肯定很小，将它拿到堆顶和原本属于最大元素的两个子节点比较，它比它们大的可能性是微乎其微的。实际上它肯定小于其中的一个儿子。而大于另一个儿子的可能性非常小。于是，这一次比较的结果就是概率不均等的，根据前面的分析，概率不均等的比较是不明智的，因为它并不能保证在糟糕情况下也能将问题的可能性削减到原本的1/2。可以想像一种极端情况，如果a肯定小于b，那么比较a和b就会什么信息也得不到——原本剩下多少可能性还是剩下多少可能性。</p>
<p>在堆排里面有大量这种近乎无效的比较，因为被拿到堆顶的那个元素几乎肯定是很小的，而靠近堆顶的元素又几乎肯定是很大的，将一个很小的数和一个很大的数比较，结果几乎肯定是“小于”的，这就意味着问题的可能性只被排除掉了很小一部分。</p>
<p>这就是为什么堆排比较慢（堆排虽然和快排一样复杂度都是O(NlogN)但堆排复杂度的常系数更大）。</p>
<p>MacKay也提供了一个修改版的堆排：每次不是将堆底的元素拿到上面去，而是直接比较堆顶（最大）元素的两个儿子，即选出次大的元素。由于这两个儿子之间的大小关系是很不确定的，两者都很大，说不好哪个更大哪个更小，所以这次比较的两个结果就是概率均等的了。具体参考<a href="http://users.aims.ac.za/~mackay/sorting/sorting.html" target="_blank">这里</a>。</p>
<p><strong>3.2**</strong>为什么快排其实也不是那么快**</p>
<p>我们考虑快排的过程：随机选择一个元素做“轴元素”，将所有大于轴元素的移到左边，其余移到右边。根据这个过程，快排的第一次比较就是将一个元素和轴元素比较，这个时候显而易见的是，“大于”和“小于”的可能性各占一半。这是一次漂亮的比较。</p>
<p>然而，快排的第二次比较就不那么高明了：我们不妨令轴元素为pivot，第一次比较结果是a1<pivot，那么可以证明第二次比较a2也小于pivot的可能性是2/3！这容易证明：如果a2>pivot的话，那么a1，a2，pivot这三个元素之间的关系就完全确定了——a1&lt;pivot&lt;a2，剩下来的元素排列的可能性我们不妨记为P（不需要具体算出来）。而如果a2&lt;pivot呢？那么a1和a2的关系就仍然是不确定的，也就是说，这个分支里面含有两种情况：a1&lt;a2&lt;pivot，以及a2&lt;a1&lt;pivot。对于其中任一种情况，剩下的元素排列的可能性都是P，于是这个分支里面剩下的排列可能性就是2P。所以当a2&lt;pivot的时候，还剩下2/3的可能性需要排查。</p>
<p>再进一步，如果第二步比较果真发现a2&lt;pivot的话，第三步比较就更不妙了，模仿上面的推理，a3&lt;pivot的概率将会是3/4！</p>
<p>这就是快排也不那么快的原因，因为它也没有做到每次比较都能将剩下的可能性砍掉一半。</p>
<p><strong>3.3**</strong>鸡排为什么又那么快呢？**</p>
<p>传统的解释是：<a href="http://en.wikipedia.org/wiki/Radix_sort" target="_blank">基排</a>不是基于比较的，所以不具有后者的局限性。话是没错，但其实还可以将它和基于比较的排序做一个类比。</p>
<p>基排的过程也许是源于我们理顺一副牌的过程：如果你有N（N&lt;=13）张牌，乱序，如何理顺呢？我们假象桌上有十三个位置，然后我们将手里的牌一张一张放出去，如果是3，就放在位置3上，如果是J，就放在位置11上，放完了之后从位置1到位置13收集所有的牌（没有牌的位置上不收集任何牌）。</p>
<p>我们可以这样来理解基排高效的本质原因：假设前i张牌都已经放到了它们对应的位置上，第i+1张牌放出去的时候，实际上就相当于“一下子”就确立了它和前i张牌的大小关系，用O(1)的操作就将这张牌正确地插入到了前i张牌中的正确位置上，这个效果就相当于插入排序的第i轮原本需要比较O(i)次的，现在只需要O(1)了。</p>
<p>但是，为什么基排能够达到这个效果呢？上面只是解释了过程，解释了过程不代表解释了本质。</p>
<p>当i张牌放到位之后，放置第i+1张牌的时候有多少种可能性？大约i+1种，因为前i张牌将13个位置分割成了i+1个区间——第i+1张牌可以落在任意一个区间。所以放置第i+1张牌就好比是询问这样一个问题：“这张牌落在哪个区间呢？”而这个问题的答案有i+1种可能性？所以它就将剩下来的可能性均分成了i+1份（换句话说，砍掉了i/i+1的可能性！）。再看看基于比较的排序吧：由于每次比较只有两种结果，所以最多只能将剩下的可能性砍掉一半。</p>
<p>这就是为什么基排要快得多。而所有基于比较的排序都逃脱不了NlogN的宿命。</p>
<p><strong>4.**</strong>信息论！信息论？**</p>
<p>本来呢，MacKay写那篇文章是想用信息论来解释为什么堆排慢，以及为什么快排也慢的。MacKay在他的文章中的解释是，只有提出每种答案的概率都均等的问题，才能获得最大信息量。然而，仔细一想，其实这里信息论并不是因，而是果。这里不需要用信息论就完全能够解释，而且更明白。信息论只是对这个解释的一个形式化。当然，信息论在其它地方还是有应用的。但这里其实用不着信息论这么重量级的东西（也许具体计算一些数据的时候是需要的），而是只需要一种看问题的本质视角：将排序问题看成和猜数字一样，是通过问问题来缩小/排除（narrow down）结果的可能性区间，这样一来，就会发现，“最好的问题”就是那些能够均分所有可能性的问题，因为那样的话不管问题的答案如何，都能排除掉k-1/k（k为问题的答案有多少种输出——猜数字里面是2，称球里面是3）种可能性，而不均衡的问题总会有一个或一些答案分支排除掉的可能性要小于k-1/k。于是策略的下界就被拖累了。</p>
<p><strong>5.**</strong>小结**</p>
<p>这的确是“小结”，因为两点：</p>
<ol>
<li><p>这个问题可以有信息论的理论解释，而信息论则是一个相当大的领域了。</p>
</li>
<li><p>文中提到的这种看问题的视角除了用于排序、称球，还能够运用到哪些问题上（比如搜索）。</p>
</li>
</ol>
<p><strong>Update(06/13/2008)</strong> : <a href="http://blog.youxu.info/" target="_blank">徐宥</a>在讨论中<a href="http://groups.google.com/group/pongba/msg/07493e329ed920ff" target="_blank">继续提到</a>：
另外，这几天我重新把TAOCP 第三卷(第二版)翻出来看了看 Knuth 怎么说这个问题的, 发现真是牛大了：</p>
<p>先说性能：</p>
<p>pp148, section 5.2.3 说：</p>
<p>When N = 1000, the approximate average runiing time on MIX are
160000u for heapsort
130000u for shellsort
80000u  for quicksort</p>
<p>这里,  Knuth 同学发现一般情况下 heapsort 表现很不好. 于是，在下文他就说，习题18 (pp156, 难度21)</p>
<p>(R.W.Floyd) During the selection phase of heapsort, the key K tends to
be quite small, so that nearly all the comparisons in step H6 find
K&lt;K_j. Show how to modify the algorithm so that K is not compared with
K_j in the main loop of the computation, thereby nearly cutting the
average number of comparisons in half.</p>
<p>答案里面的方法和DMK的方法是一样的。(我觉得DMK是看了这个论文或者TAoCP的) 这里说 by half，就正好和快排差不多了。</p>
<p>再说信息论分析：</p>
<p>在5.3.1 (pp181) 高爷爷就说, “排序问题可以看成是一个树上的鸟儿排排站的问题. (还特地画了一棵树), 下一段就说, 其实这个也
有等价说法, 就是信息论, 我们从称球问题说起…”</p>
<p>然后后面一直讲信息论和最小比较排序…</p>
<p>高爷爷真不愧是姓高的，囧rz..
<strong>Tags:</strong> <a href="http://mindhacks.cn/tags/%e6%95%b0%e5%ad%a6/" target="_blank">数学</a>, <a href="http://mindhacks.cn/tags/%e7%ae%97%e6%b3%95/" target="_blank">算法</a>, <a href="http://mindhacks.cn/tags/%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%a7%91%e5%ad%a6/" target="_blank">计算机科学</a></p>
<p><a href="http://mindhacks.cn/author/pongba/"></a></p>
<h3 id="about-">About ???</h3>
<p> <a href=""></a> <a href=""></a></p>
<p><a href="">喜欢取消喜欢</a>2 人喜欢</p>
<p><a href="">最新</a><a href="">最早</a><a href="">最热</a></p>
<ul>
<li><a href="">26条评论</a></li>
<li><a href="">14条转载</a></li>
<li><a href="">28条新浪微博</a></li>
<li><p><a href="">1条腾讯微博</a></p>
</li>
<li><p><img src="" alt="chaonin"></p>
</li>
</ul>
<p>chaonin</p>
<p>@@之前就在你的卢浮宫看到了，写的直白明了！
小弟学的是编码，呵呵。
Mackay的那本书重点是介绍编码的，具体的说是纠错码的。编码理论的重要基础是信息论。
他对这些问题的分析不是专门要来分析这写问题的，而只是用信息论的方法来解释这些现象。</p>
<p>2009年2月17日<a href="">回复</a><a href="">顶</a><a href="">转发</a><a href="">举报</a></p>
<ul>
<li><a href="http://stupidpig.cublog.cn/" title="帅得不敢出门" target="_blank"><img src="" alt="帅得不敢出门"></a></li>
</ul>
<p><a href="http://stupidpig.cublog.cn/" target="_blank">帅得不敢出门</a></p>
<p>受益良多
每每看到一些精妙的解法(算法),都想拍手称快.</p>
<p>2009年3月23日<a href="">回复</a><a href="">顶</a><a href="">转发</a><a href="">举报</a></p>
<ul>
<li><a href="http://www.cloved.cn/" title="conan" target="_blank"><img src="" alt="conan"></a></li>
</ul>
<p><a href="http://www.cloved.cn/" target="_blank">conan</a></p>
<p>关注toplanguage很久了.只是一直不敢在上面留言,看上面的聊天就感觉自己是沧海一粟.今天看到一篇.可能你是幸运的吧.我大概算了下,你应该是和我同届的.不过我比你小一岁.马上就毕业两年了.研究生们也快毕业了....回忆这些日子,感觉偏离了自己的目标,也感觉工作后并没有自己希望的成长着.一直觉得学校的东西很迂腐,什么都需要自己去学习.曾经也深深相信自己能好好成长起来.只是,到了今天,不知道自己是否还跟着大家的脚步....</p>
<p>2009年5月11日<a href="">回复</a><a href="">顶</a><a href="">转发</a><a href="">举报</a></p>
<ul>
<li><img src="" alt="metal-fan"></li>
</ul>
<p>metal-fan</p>
<p>写的太棒了～深入本质～受益匪浅！！！</p>
<p>2009年10月15日<a href="">回复</a><a href="">顶</a><a href="">转发</a><a href="">举报</a></p>
<ul>
<li><img src="" alt="raymond"></li>
</ul>
<p>raymond</p>
<p>这是最大熵原则的几个例子，即保留最大的不确定性，因为这样才能保留最大的信息。生活中很多问题都可以归结为一些简单的法则，而在实际处理问题的时候，这些简单的法则会被以各种各样的形式掩盖，从而让我们失去探索的机会。博主是个有心人啊</p>
<p>2009年12月25日<a href="">回复</a><a href="">顶</a><a href="">转发</a><a href="">举报</a></p>
<ul>
<li><img src="" alt="bigining"></li>
</ul>
<p>bigining</p>
<p>在说到12个的例子时，第二次称时：“这是一个完美的三分。然后对每个分支构造第二次称法，这里你只要稍加演算就可以发现，分支1上的第二次称法，即“1、2、6对3、4、5”这种称法，天平输出三种结果的可能性是均等的（严格来说是几乎均等）。”，但是这样好像是找不出那个不同的球的。不知道1、2、6对3、4、5之后要怎么进行判断？（可以假设1、2、6比3、4、5重，然后只能说明1、 2较重或5较轻，然后第三次要怎么进行？）</p>
<p>2010年4月24日<a href="">回复</a><a href="">顶</a><a href="">转发</a><a href="">举报</a></p>
<ul>
<li><img src="" alt="Ted"></li>
</ul>
<p>Ted</p>
<p>晕，你都说了“然后只能说明1、 2较重或5较轻”，这还不明显，再把1，2分别放2边，哪个重，哪个就是，否则就是平衡，那5就是目标。</p>
<p>2011年11月28日<a href="">回复</a><a href="">顶</a><a href="">转发</a><a href="">举报</a></p>
<ul>
<li><img src="" alt="simple"></li>
</ul>
<p>simple</p>
<p>以6个球的例子来说，这个策略的“答案”是随着剩下的可能性（或者说剩下的球）的数量而发生变化的，比如，当球剩下2个时，那么天平的输出结果只可能有两种：左或右倾。因此，这时候应该是以以2去平分剩下的可能性。</p>
<p>2012年9月21日<a href="">回复</a><a href="">顶</a><a href="">转发</a><a href="">举报</a></p>
<ul>
<li><img src="" alt="rrison"></li>
</ul>
<p>rrison</p>
<p>离散数学里的博弈树</p>
<p>2010年5月6日<a href="">回复</a><a href="">顶</a><a href="">转发</a><a href="">举报</a></p>
<ul>
<li><a href="http://www.usbphoneworld.com/lbded6620.html" title="dell latitude d620 laptop battery" target="_blank"><img src="" alt="dell latitude d620 laptop battery"></a></li>
</ul>
<p><a href="http://www.usbphoneworld.com/lbded6620.html" target="_blank">dell latitude d620 laptop battery</a></p>
<p>非常感谢。受益良多。</p>
<p>2010年6月13日<a href="">回复</a><a href="">顶</a><a href="">转发</a><a href="">举报</a></p>
<ul>
<li><img src="" alt="kmplayer"></li>
</ul>
<p>kmplayer</p>
<p>&quot;那么可以证明第二次比较a2也小于pivot的可能性是2/3！&quot;
”a3&lt;pivot的概率将会是3/4！“
这两个地方的”叹号“很容易误解为”阶层“</p>
<p>2010年12月16日<a href="">回复</a><a href="">顶</a><a href="">转发</a><a href="">举报</a></p>
<ul>
<li><img src="" alt="hit_alex"></li>
</ul>
<p>hit_alex</p>
<p>把这西抽象出来确实也挺有意思的。另外，我注意到标题：<strong>鸡排为什么又那么快呢？</strong>中“鸡排”是不是写错了？莫非是作者故意为之？</p>
<p>2010年12月26日<a href="">回复</a><a href="">顶</a><a href="">转发</a><a href="">举报</a></p>
<ul>
<li><a href="http://www.lisher.tk/" title="Miller" target="_blank"><img src="" alt="Miller"></a></li>
</ul>
<p><a href="http://www.lisher.tk/" target="_blank">Miller</a></p>
<p>4、4称了之后不管哪种情况（分支），剩下来的可能性总是》 8 《种吧</p>
<p>2011年2月14日<a href="">回复</a><a href="">顶</a><a href="">转发</a><a href="">举报</a></p>
<ul>
<li><img src="" alt="wosunziwuwan"></li>
</ul>
<p>wosunziwuwan</p>
<p>&quot;那么可以证明第二次比较a2也小于pivot的可能性是2/3&quot;这句话有问题吧，可能性应该还是1/2吧？因为只是a2和pivot相对次序的比较，和a1无关，是一次独立的比较。这和取排问题不同，确定了2张牌后，第3张牌只有从剩下的牌中去取</p>
<p>2011年11月27日<a href="">回复</a><a href="">顶(1)</a><a href="">转发</a><a href="">举报</a></p>
<ul>
<li><a href="http://yeasy.blogspot.com/" title="yeasy" target="_blank"><img src="" alt="yeasy"></a></li>
</ul>
<p><a href="http://yeasy.blogspot.com/" target="_blank">yeasy</a></p>
<p>更为本质一些，我觉得跟最大熵原理有些关系。
参考<a href="http://yeasy.blogspot.com/2011/11/blog-post.html" target="_blank"><a href="http://yeasy.blogspot.com/2011/11/blog-post.html">http://yeasy.blogspot.com/2011/11/blog-post.html</a></a></p>
<p>2011年12月15日<a href="">回复</a><a href="">顶</a><a href="">转发</a><a href="">举报</a></p>
<ul>
<li><img src="" alt="LittleJ"></li>
</ul>
<p>LittleJ</p>
<p>&quot;第一次比较结果是a1&lt;pivot，那么可以证明第二次比较a2也小于pivot的可能性是2/3！&quot;这里我也不是很明白。这里指的第一次第二次都是相对于快排的一次排序来说的吧？那么第一次将a1和pivot比较，大或者小的概率是相等的这里没有问题。为什么第二次比较a2要“也”小于pivot呢？我的意思就是第一次比较和第二次比较之间有什么关联？这里我没有看明白，能不能解释一下呢？谢谢：）</p>
<p>2012年3月19日<a href="">回复</a><a href="">顶(1)</a><a href="">转发</a><a href="">举报</a></p>
<ul>
<li><a href="http://www.douban.com/people/49902334/" title="透明的沙子" target="_blank"><img src="" alt="透明的沙子"></a></li>
</ul>
<p><a href="http://www.douban.com/people/49902334/" target="_blank">透明的沙子</a></p>
<p>看起来很多人不理解这个，反复想不明白，坐等解答啊</p>
<p>2012年9月3日<a href="">回复</a><a href="">顶</a><a href="">转发</a><a href="">举报</a></p>
<ul>
<li><a href="http://www.douban.com/people/49902334/" title="透明的沙子" target="_blank"><img src="" alt="透明的沙子"></a></li>
</ul>
<p><a href="http://www.douban.com/people/49902334/" target="_blank">透明的沙子</a></p>
<p>“然而，快排的第二次比较就不那么高明了：我们不妨令轴元素为pivot，第一次比较结果是a1pivot的话，那么a1，a2，pivot这三个元素之间的关系就完全确定了——a1</p>
<p>2012年9月3日<a href="">回复</a><a href="">顶</a><a href="">转发</a><a href="">举报</a></p>
<ul>
<li><a href="http://weibo.com/1742521405" title="滔要考研" target="_blank"><img src="" alt="滔要考研"></a></li>
</ul>
<p><a href="http://weibo.com/1742521405" target="_blank">滔要考研</a></p>
<p>关于快排的部分，其实本质是指轴元素如果选取的不够“中间”，会导致第一次排序后左右不均，从而导致较差的效率表现。刘大牛从缩减可能性这个角度出发，让人耳目一新。受教了。</p>
<p>2012年9月7日<a href="">回复</a><a href="">顶</a><a href="">转发</a><a href="">举报</a></p>
<ul>
<li><img src="" alt="simple"></li>
</ul>
<p>simple</p>
<p>鸡排之所以快，我觉得还可以用另一种说法（以13张牌的例子为例）：第i张牌确定位置后，放第i+1张牌时，桌上剩下的位置还有 13-i 个，即放牌的可能性为13-i种，然后，摸牌再看是什么点数就相当于公布答案，而这个答案刚好也是有 13-i 种，即，13-i种答案把13-i种可能性平均分为了13-i/13-i = 1种，最后得到鸡排需要的时间复杂度为O（1）</p>
<p>2012年9月22日<a href="">回复</a><a href="">顶</a><a href="">转发</a><a href="">举报</a></p>
<ul>
<li><img src="" alt="imgen"></li>
</ul>
<p>imgen</p>
<p>关于称球问题，我正是用了信息论的方法为指引，三分而称球，而且我也给出了推广到N的解法，从中获得了很多乐趣和满足。不过那是在大学时代了，久远了</p>
<p>2012年9月29日<a href="">回复</a><a href="">顶</a><a href="">转发</a><a href="">举报</a></p>
<ul>
<li><a href="http://weibo.com/2177249280" title="icrt_" target="_blank"><img src="" alt="icrt_"></a></li>
</ul>
<p><a href="http://weibo.com/2177249280" target="_blank">icrt_</a></p>
<p>真心佩服了。之前觉得称球问题没有什么，看这文章才知道原来有这么多的东西！</p>
<p>2012年10月10日<a href="">回复</a><a href="">顶</a><a href="">转发</a><a href="">举报</a></p>
<ul>
<li><a href="http://weibo.com/1238983263" title="_小毛童鞋_" target="_blank"><img src="" alt="_小毛童鞋_"></a></li>
</ul>
<p><a href="http://weibo.com/1238983263" target="_blank"><em>小毛童鞋</em></a></p>
<p>高爷爷是谁？</p>
<p>2012年10月16日<a href="">回复</a><a href="">顶</a><a href="">转发</a><a href="">举报</a></p>
<ul>
<li><a href="http://weibo.com/brightown" title="鸡翅呀鸡翅" target="_blank"><img src="" alt="鸡翅呀鸡翅"></a></li>
</ul>
<p><a href="http://weibo.com/brightown" target="_blank">鸡翅呀鸡翅</a></p>
<p>哇高爷爷果然是神人也，查了一下73年v3的第一版就有神论<figure class="highlight 膜拜orz~~~"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
</pre></td><td class="code"><pre>
<span class="number">2012</span>年<span class="number">11</span>月<span class="number">6</span>日[回复]()[顶]()[转发]()[举报]()
* [![ouqi]()](http://weibo.com/xianqings "ouqi")

[ouqi](http://weibo.com/xianqings)

同不明白这一块：
然而，快排的第二次比较就不那么高明了：我们不妨令轴元素为pivot，第一次比较结果是a1&lt;pivot，那么可以证明第二次比较a2也小于pivot的可能性是<span class="number">2</span>/<span class="number">3</span>！这容易证明：如果a2&gt;pivot的话，那么a1，a2，pivot这三个元素之间的关系就完全确定了——a1&lt;pivot&lt;a2，剩下来的元素排列的可能性我们不妨记为P（不需要具体算出来）。而如果a2&lt;pivot呢？那么a1和a2的关系就仍然是不确定的，也就是说，这个分支里面含有两种情况：a1&lt;a2&lt;pivot，以及a2&lt;a1&lt;pivot。对于其中任一种情况，剩下的元素排列的可能性都是P，于是这个分支里面剩下的排列可能性就是<span class="number">2</span>P。所以当a2&lt;pivot的时候，还剩下<span class="number">2</span>/<span class="number">3</span>的可能性需要排查。
我的疑惑在于，第一次的a2是什么，为什么要把第二次的排序和第一次的排序相关联?
不明白您定义的第二次排序是什么，我以为的第二次排序是对第一次的起始位置到第一次的pivot之间的数字的排序，那么第二次的privot又是重新选定的。也就是说在第一次排序之后，任何一个值跟第一次的privot的大小关系都是确定了的，要么比他大 要么比他小。那您说a2是什么？

<span class="number">4</span>月<span class="number">10</span>日[回复]()[顶]()[转发]()[举报]()
* [![ナイキ 通販]()](http://www.abcsnk.com/ "ナイキ 通販")

[ナイキ 通販](http://www.abcsnk.com/)

searching is another thing no doubt you like to accomplish (specially me), when i don't recognize how but searching is one particular activity which offers us eminence delight and relaxation whenever we are generally tired as well as frustrated as well as irritated, but while using ever raising targets along with office update they have became next to impossible <span class="flow">for</span> us to determine some time <span class="flow">for</span> it to hang out with his friends and enjoy that period while rooming around <span class="flow">for</span> the streets involving market.
But even as we always say there's [http://www.abcsnk.com/adidas-スパイクサッカー-アディピュア-<span class="number">11</span>pro-c-<span class="number">22</span>_23_29.html](http://www.abcsnk.com/adidas-スパイクサッカー-アディピュア-<span class="number">11</span>pro-c-<span class="number">22</span>_23_29.html) アディピュア<span class="number">11</span>pro a option <span class="flow">for</span> just about every problem along with situation on the [http:///www.sportrakuten.com](http:/www.sportrakuten.com) サングラス通販 globe, all you want to <span class="flow">do</span> is seek out that option with [http://www.sportrakuten.com/categories/<span class="number">1369471366</span>-<span class="number">179</span>.html](http://www.sportrakuten.com/categories/<span class="number">1369471366</span>-<span class="number">179</span>.html) レイバン サングラス 'something different' perspective. And which is the very reason we invented a many new method involving shopping which <span class="flow">in</span> turn know while online searching method. But staying this strategy new types of quarries that happen to be there inside mind of folks related on the same and were here to unravel those themselves.
But today you'll find thousands involving products that is purchased via an web shop starting coming from a bugger to your flat <span class="flow">in</span> fact it is impossible <span class="flow">for</span> individuals to cover hundreds of <span class="flow">in</span> one particular discussion themselves therefore today we'll be only talking over facts pertains to [http://www.abcsnk.com](http://www.abcsnk.com/) ナイキ 通販 online searching of sneakers <span class="flow">for</span> adult men.
Buying some your favourite Adidas [http://www.abcsnk.com/adidas-スパイクサッカー-プレデター-アディダス-<span class="number">11</span>-c-<span class="number">22</span>_23_25.html](http://www.abcsnk.com/adidas-スパイクサッカー-プレデター-アディダス-<span class="number">11</span>-c-<span class="number">22</span>_23_25.html) adidas プレデター sneakers from these websites is just about the easiest thing on the [http:///www.sportrakuten.com/categories/<span class="number">1369471516</span>-<span class="number">183</span>.html](http:/www.sportrakuten.com/categories/<span class="number">1369471516</span>-<span class="number">183</span>.html) レイバン(RAY BAN) globe, but to generate it truly easy you've got to keep up few <span class="flow">in</span> the things as well as points that happen to be listed down below.

<span class="number">6</span>月<span class="number">19</span>日[回复]()[顶]()[转发]()[举报]()
[<span class="number">1</span>]()[]()

社交帐号登录:
* [微博](http://pongba.duoshuo.com/login/weibo/?sso=<span class="number">1</span>&redirect_uri=http<span class="envvar">%3A%</span><span class="number">2</span>F<span class="envvar">%2Fmindhacks.cn%</span><span class="number">2</span>Fwp-login.php<span class="envvar">%3Faction%</span><span class="number">3</span>Dduoshuo_login&redirect_to<span class="envvar">%3Dhttp%</span><span class="number">3</span>A<span class="envvar">%2F%</span><span class="number">2</span>Fmindhacks.cn<span class="envvar">%2F2008%</span><span class="number">2</span>F06<span class="envvar">%2F13%</span><span class="number">2</span>Fwhy-is-quicksort-so-quick%<span class="number">2</span>F)
* [QQ](http://pongba.duoshuo.com/login/qq/?sso=<span class="number">1</span>&redirect_uri=http<span class="envvar">%3A%</span><span class="number">2</span>F<span class="envvar">%2Fmindhacks.cn%</span><span class="number">2</span>Fwp-login.php<span class="envvar">%3Faction%</span><span class="number">3</span>Dduoshuo_login&redirect_to<span class="envvar">%3Dhttp%</span><span class="number">3</span>A<span class="envvar">%2F%</span><span class="number">2</span>Fmindhacks.cn<span class="envvar">%2F2008%</span><span class="number">2</span>F06<span class="envvar">%2F13%</span><span class="number">2</span>Fwhy-is-quicksort-so-quick%<span class="number">2</span>F)
* [人人](http://pongba.duoshuo.com/login/renren/?sso=<span class="number">1</span>&redirect_uri=http<span class="envvar">%3A%</span><span class="number">2</span>F<span class="envvar">%2Fmindhacks.cn%</span><span class="number">2</span>Fwp-login.php<span class="envvar">%3Faction%</span><span class="number">3</span>Dduoshuo_login&redirect_to<span class="envvar">%3Dhttp%</span><span class="number">3</span>A<span class="envvar">%2F%</span><span class="number">2</span>Fmindhacks.cn<span class="envvar">%2F2008%</span><span class="number">2</span>F06<span class="envvar">%2F13%</span><span class="number">2</span>Fwhy-is-quicksort-so-quick%<span class="number">2</span>F)
* [豆瓣](http://pongba.duoshuo.com/login/douban/?sso=<span class="number">1</span>&redirect_uri=http<span class="envvar">%3A%</span><span class="number">2</span>F<span class="envvar">%2Fmindhacks.cn%</span><span class="number">2</span>Fwp-login.php<span class="envvar">%3Faction%</span><span class="number">3</span>Dduoshuo_login&redirect_to<span class="envvar">%3Dhttp%</span><span class="number">3</span>A<span class="envvar">%2F%</span><span class="number">2</span>Fmindhacks.cn<span class="envvar">%2F2008%</span><span class="number">2</span>F06<span class="envvar">%2F13%</span><span class="number">2</span>Fwhy-is-quicksort-so-quick%<span class="number">2</span>F)
* [更多»]()

* [开心](http://pongba.duoshuo.com/login/kaixin/?sso=<span class="number">1</span>&redirect_uri=http<span class="envvar">%3A%</span><span class="number">2</span>F<span class="envvar">%2Fmindhacks.cn%</span><span class="number">2</span>Fwp-login.php<span class="envvar">%3Faction%</span><span class="number">3</span>Dduoshuo_login&redirect_to<span class="envvar">%3Dhttp%</span><span class="number">3</span>A<span class="envvar">%2F%</span><span class="number">2</span>Fmindhacks.cn<span class="envvar">%2F2008%</span><span class="number">2</span>F06<span class="envvar">%2F13%</span><span class="number">2</span>Fwhy-is-quicksort-so-quick%<span class="number">2</span>F)
* [网易](http://pongba.duoshuo.com/login/netease/?sso=<span class="number">1</span>&redirect_uri=http<span class="envvar">%3A%</span><span class="number">2</span>F<span class="envvar">%2Fmindhacks.cn%</span><span class="number">2</span>Fwp-login.php<span class="envvar">%3Faction%</span><span class="number">3</span>Dduoshuo_login&redirect_to<span class="envvar">%3Dhttp%</span><span class="number">3</span>A<span class="envvar">%2F%</span><span class="number">2</span>Fmindhacks.cn<span class="envvar">%2F2008%</span><span class="number">2</span>F06<span class="envvar">%2F13%</span><span class="number">2</span>Fwhy-is-quicksort-so-quick%<span class="number">2</span>F)
* [搜狐](http://pongba.duoshuo.com/login/sohu/?sso=<span class="number">1</span>&redirect_uri=http<span class="envvar">%3A%</span><span class="number">2</span>F<span class="envvar">%2Fmindhacks.cn%</span><span class="number">2</span>Fwp-login.php<span class="envvar">%3Faction%</span><span class="number">3</span>Dduoshuo_login&redirect_to<span class="envvar">%3Dhttp%</span><span class="number">3</span>A<span class="envvar">%2F%</span><span class="number">2</span>Fmindhacks.cn<span class="envvar">%2F2008%</span><span class="number">2</span>F06<span class="envvar">%2F13%</span><span class="number">2</span>Fwhy-is-quicksort-so-quick%<span class="number">2</span>F)
* [百度](http://pongba.duoshuo.com/login/baidu/?sso=<span class="number">1</span>&redirect_uri=http<span class="envvar">%3A%</span><span class="number">2</span>F<span class="envvar">%2Fmindhacks.cn%</span><span class="number">2</span>Fwp-login.php<span class="envvar">%3Faction%</span><span class="number">3</span>Dduoshuo_login&redirect_to<span class="envvar">%3Dhttp%</span><span class="number">3</span>A<span class="envvar">%2F%</span><span class="number">2</span>Fmindhacks.cn<span class="envvar">%2F2008%</span><span class="number">2</span>F06<span class="envvar">%2F13%</span><span class="number">2</span>Fwhy-is-quicksort-so-quick%<span class="number">2</span>F)
* [谷歌](http://pongba.duoshuo.com/login/google/?sso=<span class="number">1</span>&redirect_uri=http<span class="envvar">%3A%</span><span class="number">2</span>F<span class="envvar">%2Fmindhacks.cn%</span><span class="number">2</span>Fwp-login.php<span class="envvar">%3Faction%</span><span class="number">3</span>Dduoshuo_login&redirect_to<span class="envvar">%3Dhttp%</span><span class="number">3</span>A<span class="envvar">%2F%</span><span class="number">2</span>Fmindhacks.cn<span class="envvar">%2F2008%</span><span class="number">2</span>F06<span class="envvar">%2F13%</span><span class="number">2</span>Fwhy-is-quicksort-so-quick%<span class="number">2</span>F)
[![]()]()

发布

[]( "插入表情")

[刘未鹏 | Mind Hacks正在使用多说](http://duoshuo.com/)
<span class="number">1</span>. chaonin on [February <span class="number">17</span>, <span class="number">2009</span> at <span class="number">10</span>:<span class="number">34</span> am](http://mindhacks.cn/<span class="number">2008</span>/<span class="number">06</span>/<span class="number">13</span>/why-is-quicksort-so-quick/comment-page-<span class="number">1</span>/#comment-<span class="number">93</span>) said:

@@之前就在你的卢浮宫看到了，写的直白明了！

小弟学的是编码，呵呵。
Mackay的那本书重点是介绍编码的，具体的说是纠错码的。编码理论的重要基础是信息论。
他对这些问题的分析不是专门要来分析这写问题的，而只是用信息论的方法来解释这些现象。
<span class="number">1</span>. [帅得不敢出门](http://stupidpig.cublog.cn/) on [March <span class="number">23</span>, <span class="number">2009</span> at <span class="number">8</span>:<span class="number">46</span> pm](http://mindhacks.cn/<span class="number">2008</span>/<span class="number">06</span>/<span class="number">13</span>/why-is-quicksort-so-quick/comment-page-<span class="number">1</span>/#comment-<span class="number">292</span>) said:

受益良多
每每看到一些精妙的解法(算法),都想拍手称快.
<span class="number">1</span>. [conan](http://www.cloved.cn/) on [May <span class="number">11</span>, <span class="number">2009</span> at <span class="number">9</span>:<span class="number">43</span> am](http://mindhacks.cn/<span class="number">2008</span>/<span class="number">06</span>/<span class="number">13</span>/why-is-quicksort-so-quick/comment-page-<span class="number">1</span>/#comment-<span class="number">407</span>) said:

关注toplanguage很久了.只是一直不敢在上面留言,看上面的聊天就感觉自己是沧海一粟.今天看到一篇.可能你是幸运的吧.我大概算了下,你应该是和我同届的.不过我比你小一岁.马上就毕业两年了.研究生们也快毕业了….回忆这些日子,感觉偏离了自己的目标,也感觉工作后并没有自己希望的成长着.一直觉得学校的东西很迂腐,什么都需要自己去学习.曾经也深深相信自己能好好成长起来.只是,到了今天,不知道自己是否还跟着大家的脚步….
<span class="number">1</span>. metal-fan on [October <span class="number">15</span>, <span class="number">2009</span> at <span class="number">9</span>:<span class="number">13</span> pm](http://mindhacks.cn/<span class="number">2008</span>/<span class="number">06</span>/<span class="number">13</span>/why-is-quicksort-so-quick/comment-page-<span class="number">1</span>/#comment-<span class="number">616</span>) said:

写的太棒了～深入本质～受益匪浅！！！
<span class="number">1</span>. raymond on [December <span class="number">25</span>, <span class="number">2009</span> at <span class="number">10</span>:<span class="number">38</span> pm](http://mindhacks.cn/<span class="number">2008</span>/<span class="number">06</span>/<span class="number">13</span>/why-is-quicksort-so-quick/comment-page-<span class="number">1</span>/#comment-<span class="number">709</span>) said:

这是最大熵原则的几个例子，即保留最大的不确定性，因为这样才能保留最大的信息。生活中很多问题都可以归结为一些简单的法则，而在实际处理问题的时候，这些简单的法则会被以各种各样的形式掩盖，从而让我们失去探索的机会。博主是个有心人啊
<span class="number">1</span>. bigining on [April <span class="number">24</span>, <span class="number">2010</span> at <span class="number">6</span>:<span class="number">10</span> pm](http://mindhacks.cn/<span class="number">2008</span>/<span class="number">06</span>/<span class="number">13</span>/why-is-quicksort-so-quick/comment-page-<span class="number">1</span>/#comment-<span class="number">888</span>) said:

在说到<span class="number">12</span>个的例子时，第二次称时：“这是一个完美的三分。然后对每个分支构造第二次称法，这里你只要稍加演算就可以发现，分支<span class="number">1</span>上的第二次称法，即“<span class="number">1</span>、<span class="number">2</span>、<span class="number">6</span>对<span class="number">3</span>、<span class="number">4</span>、<span class="number">5</span>”这种称法，天平输出三种结果的可能性是均等的（严格来说是几乎均等）。”，但是这样好像是找不出那个不同的球的。不知道<span class="number">1</span>、<span class="number">2</span>、<span class="number">6</span>对<span class="number">3</span>、<span class="number">4</span>、<span class="number">5</span>之后要怎么进行判断？（可以假设<span class="number">1</span>、<span class="number">2</span>、<span class="number">6</span>比<span class="number">3</span>、<span class="number">4</span>、<span class="number">5</span>重，然后只能说明<span class="number">1</span>、 <span class="number">2</span>较重或<span class="number">5</span>较轻，然后第三次要怎么进行？）

* Ted on [November <span class="number">28</span>, <span class="number">2011</span> at <span class="number">3</span>:<span class="number">30</span> am](http://mindhacks.cn/<span class="number">2008</span>/<span class="number">06</span>/<span class="number">13</span>/why-is-quicksort-so-quick/comment-page-<span class="number">1</span>/#comment-<span class="number">18264</span>) said:

晕，你都说了“然后只能说明<span class="number">1</span>、 <span class="number">2</span>较重或<span class="number">5</span>较轻”，这还不明显，再把<span class="number">1</span>，<span class="number">2</span>分别放<span class="number">2</span>边，哪个重，哪个就是，否则就是平衡，那<span class="number">5</span>就是目标。
* rrison on [May <span class="number">6</span>, <span class="number">2010</span> at <span class="number">11</span>:<span class="number">26</span> am](http://mindhacks.cn/<span class="number">2008</span>/<span class="number">06</span>/<span class="number">13</span>/why-is-quicksort-so-quick/comment-page-<span class="number">1</span>/#comment-<span class="number">904</span>) said:

离散数学里的博弈树
* [dell latitude d620 laptop battery](http://www.usbphoneworld.com/lbded6620.html) on [June <span class="number">13</span>, <span class="number">2010</span> at <span class="number">10</span>:<span class="number">56</span> am](http://mindhacks.cn/<span class="number">2008</span>/<span class="number">06</span>/<span class="number">13</span>/why-is-quicksort-so-quick/comment-page-<span class="number">1</span>/#comment-<span class="number">934</span>) said:

非常感谢。受益良多。
* 
Pingback: [数学之美番外篇：快排为什么那样快 | 天道酬勤](http://www.iskycloud.com/blog/algorithm/<span class="number">52</span>.html)
* kmplayer on [December <span class="number">16</span>, <span class="number">2010</span> at <span class="number">3</span>:<span class="number">25</span> pm](http://mindhacks.cn/<span class="number">2008</span>/<span class="number">06</span>/<span class="number">13</span>/why-is-quicksort-so-quick/comment-page-<span class="number">1</span>/#comment-<span class="number">11214</span>) said:

“那么可以证明第二次比较a2也小于pivot的可能性是<span class="number">2</span>/<span class="number">3</span>！”
”a3&lt;pivot的概率将会是<span class="number">3</span>/<span class="number">4</span>！“
这两个地方的”叹号“很容易误解为”阶层“
* hit_alex on [December <span class="number">26</span>, <span class="number">2010</span> at <span class="number">5</span>:<span class="number">15</span> pm](http://mindhacks.cn/<span class="number">2008</span>/<span class="number">06</span>/<span class="number">13</span>/why-is-quicksort-so-quick/comment-page-<span class="number">1</span>/#comment-<span class="number">11319</span>) said:

把这西抽象出来确实也挺有意思的。另外，我注意到标题：**鸡排为什么又那么快呢？**中“鸡排”是不是写错了？莫非是作者故意为之？
* [Miller](http://www.lisher.tk/) on [February <span class="number">14</span>, <span class="number">2011</span> at <span class="number">10</span>:<span class="number">23</span> pm](http://mindhacks.cn/<span class="number">2008</span>/<span class="number">06</span>/<span class="number">13</span>/why-is-quicksort-so-quick/comment-page-<span class="number">1</span>/#comment-<span class="number">12358</span>) said:

<span class="number">4</span>、<span class="number">4</span>称了之后不管哪种情况（分支），剩下来的可能性总是》 <span class="number">8</span> 《种吧
* 
Pingback: [知其所以然（续） - 东莞律师网](http://www.lawyer888.com/?p=<span class="number">122</span>)
* 
Pingback: [知其所以然（续） | w3er](http://w3er.com/<span class="envvar">%e6%</span><span class="number">9</span>c<span class="envvar">%aa%</span>e5<span class="envvar">%88%</span><span class="number">86</span><span class="envvar">%e7%</span>b1<span class="envvar">%bb/%</span>e7<span class="envvar">%9f%</span>a5<span class="envvar">%e5%</span><span class="number">85</span><span class="envvar">%b6%</span>e6<span class="envvar">%89%</span><span class="number">80</span><span class="envvar">%e4%</span>bb<span class="envvar">%a5%</span>e7<span class="envvar">%84%</span>b6<span class="envvar">%ef%</span>bc<span class="envvar">%88%</span>e7<span class="envvar">%bb%</span>ad<span class="envvar">%ef%</span>bc%<span class="number">89</span>/)
* 
Pingback: [知其所以然（三）——为什么算法这么难？](http://mindhacks.cn/<span class="number">2011</span>/<span class="number">07</span>/<span class="number">10</span>/the-importance-of-knowing-why-part3/)
* 
Pingback: [推荐读书《暗时间》](http://www.whoisnerd.com/<span class="number">2011</span>/<span class="number">07</span>/<span class="number">31</span>/<span class="envvar">%e6%</span><span class="number">8</span>e<span class="envvar">%a8%</span>e8<span class="envvar">%8d%</span><span class="number">90</span><span class="envvar">%e8%</span>af<span class="envvar">%bb%</span>e4<span class="envvar">%b9%</span>a6<span class="envvar">%e3%</span><span class="number">80</span><span class="envvar">%8a%</span>e6<span class="envvar">%9a%</span><span class="number">97</span><span class="envvar">%e6%</span><span class="number">97</span><span class="envvar">%b6%</span>e9<span class="envvar">%97%</span>b4<span class="envvar">%e3%</span><span class="number">80</span>%<span class="number">8</span>b/)
* 
Pingback: [转：为什么算法这么难？ | South♂楠个人博客](http://southmagic.sinaapp.com/?p=<span class="number">18</span>)
* 
Pingback: [知其所以然（续） | 风的天地](http://blog69.tk/?p=<span class="number">540</span>)
* 
Pingback: [知其所以然（三）：为什么算法这么难？ | 风的天地](http://blog69.tk/?p=<span class="number">114</span>)
* wosunziwuwan on [November <span class="number">27</span>, <span class="number">2011</span> at <span class="number">9</span>:<span class="number">55</span> pm](http://mindhacks.cn/<span class="number">2008</span>/<span class="number">06</span>/<span class="number">13</span>/why-is-quicksort-so-quick/comment-page-<span class="number">1</span>/#comment-<span class="number">18259</span>) said:

“那么可以证明第二次比较a2也小于pivot的可能性是<span class="number">2</span>/<span class="number">3</span>″这句话有问题吧，可能性应该还是<span class="number">1</span>/<span class="number">2</span>吧？因为只是a2和pivot相对次序的比较，和a1无关，是一次独立的比较。这和取排问题不同，确定了<span class="number">2</span>张牌后，第<span class="number">3</span>张牌只有从剩下的牌中去取
* [yeasy](http://yeasy.blogspot.com/) on [December <span class="number">15</span>, <span class="number">2011</span> at <span class="number">4</span>:<span class="number">23</span> pm](http://mindhacks.cn/<span class="number">2008</span>/<span class="number">06</span>/<span class="number">13</span>/why-is-quicksort-so-quick/comment-page-<span class="number">1</span>/#comment-<span class="number">18653</span>) said:

更为本质一些，我觉得跟最大熵原理有些关系。
参考http://yeasy.blogspot.com/<span class="number">2011</span>/<span class="number">11</span>/blog-post.html
* 
Pingback: [罗青-技术博客 | [re]趣谈二分法](http://tsingroo.sinaapp.com/?p=<span class="number">302</span>)
* 
Pingback: [趣题：天平找假币 - Aikilis' Blog](http://aikilis.tk/<span class="number">1398</span>)
* 
Pingback: [快排_quicksort() - C++](http://cblog.lylzone.info/<span class="number">2012</span>/<span class="number">03</span>/<span class="number">6</span>/quicksort.html)
* LittleJ on [March <span class="number">19</span>, <span class="number">2012</span> at <span class="number">6</span>:<span class="number">12</span> pm](http://mindhacks.cn/<span class="number">2008</span>/<span class="number">06</span>/<span class="number">13</span>/why-is-quicksort-so-quick/comment-page-<span class="number">1</span>/#comment-<span class="number">20448</span>) said:

“第一次比较结果是a1&lt;pivot，那么可以证明第二次比较a2也小于pivot的可能性是<span class="number">2</span>/<span class="number">3</span>！"这里我也不是很明白。这里指的第一次第二次都是相对于快排的一次排序来说的吧？那么第一次将a1和pivot比较，大或者小的概率是相等的这里没有问题。为什么第二次比较a2要“也”小于pivot呢？我的意思就是第一次比较和第二次比较之间有什么关联？这里我没有看明白，能不能解释一下呢？谢谢：）
* 
Pingback: [知其所以然（三）：为什么算法这么难？ | 吃杂烩](http://blog.chiapp.com/html/<span class="number">2012</span>-<span class="number">08</span>-<span class="number">09</span>/<span class="number">4159</span>.html)
* 
Pingback: [所有排序总结（内排序）（续）——基于比较排序下界 | 编程·早晨](http://code.zc4u.com/articles/<span class="number">5362</span>.html)
* 
Pingback: [孙吾饭的游乐场 | 暗时间](http://patdelphi.com/wordpress/?p=<span class="number">508</span>)
* [透明的沙子](http://www.douban.com/people/<span class="number">49902334</span>/) on [September <span class="number">3</span>, <span class="number">2012</span> at <span class="number">8</span>:<span class="number">51</span> pm](http://mindhacks.cn/<span class="number">2008</span>/<span class="number">06</span>/<span class="number">13</span>/why-is-quicksort-so-quick/comment-page-<span class="number">1</span>/#comment-<span class="number">31818</span>) said:

“然而，快排的第二次比较就不那么高明了：我们不妨令轴元素为pivot，第一次比较结果是a1pivot的话，那么a1，a2，pivot这三个元素之间的关系就完全确定了——a1
* [透明的沙子](http://www.douban.com/people/<span class="number">49902334</span>/) on [September <span class="number">3</span>, <span class="number">2012</span> at <span class="number">8</span>:<span class="number">53</span> pm](http://mindhacks.cn/<span class="number">2008</span>/<span class="number">06</span>/<span class="number">13</span>/why-is-quicksort-so-quick/comment-page-<span class="number">1</span>/#comment-<span class="number">31819</span>) said:

看起来很多人不理解这个，反复想不明白，坐等解答啊
* [滔要考研](http://weibo.com/<span class="number">1742521405</span>) on [September <span class="number">7</span>, <span class="number">2012</span> at <span class="number">1</span>:<span class="number">06</span> am](http://mindhacks.cn/<span class="number">2008</span>/<span class="number">06</span>/<span class="number">13</span>/why-is-quicksort-so-quick/comment-page-<span class="number">1</span>/#comment-<span class="number">31827</span>) said:

关于快排的部分，其实本质是指轴元素如果选取的不够“中间”，会导致第一次排序后左右不均，从而导致较差的效率表现。刘大牛从缩减可能性这个角度出发，让人耳目一新。受教了。
* simple on [September <span class="number">21</span>, <span class="number">2012</span> at <span class="number">11</span>:<span class="number">34</span> pm](http://mindhacks.cn/<span class="number">2008</span>/<span class="number">06</span>/<span class="number">13</span>/why-is-quicksort-so-quick/comment-page-<span class="number">1</span>/#comment-<span class="number">31875</span>) said:

以<span class="number">6</span>个球的例子来说，这个策略的“答案”是随着剩下的可能性（或者说剩下的球）的数量而发生变化的，比如，当球剩下<span class="number">2</span>个时，那么天平的输出结果只可能有两种：左或右倾。因此，这时候应该是以以<span class="number">2</span>去平分剩下的可能性。
* simple on [September <span class="number">22</span>, <span class="number">2012</span> at <span class="number">1</span>:<span class="number">35</span> am](http://mindhacks.cn/<span class="number">2008</span>/<span class="number">06</span>/<span class="number">13</span>/why-is-quicksort-so-quick/comment-page-<span class="number">1</span>/#comment-<span class="number">31876</span>) said:

鸡排之所以快，我觉得还可以用另一种说法（以<span class="number">13</span>张牌的例子为例）：第i张牌确定位置后，放第i+<span class="number">1</span>张牌时，桌上剩下的位置还有 <span class="number">13</span>-i 个，即放牌的可能性为<span class="number">13</span>-i种，然后，摸牌再看是什么点数就相当于公布答案，而这个答案刚好也是有 <span class="number">13</span>-i 种，即，<span class="number">13</span>-i种答案把<span class="number">13</span>-i种可能性平均分为了<span class="number">13</span>-i/<span class="number">13</span>-i = <span class="number">1</span>种，最后得到鸡排需要的时间复杂度为O（<span class="number">1</span>）
* imgen on [September <span class="number">29</span>, <span class="number">2012</span> at <span class="number">5</span>:<span class="number">45</span> pm](http://mindhacks.cn/<span class="number">2008</span>/<span class="number">06</span>/<span class="number">13</span>/why-is-quicksort-so-quick/comment-page-<span class="number">1</span>/#comment-<span class="number">31903</span>) said:

关于称球问题，我正是用了信息论的方法为指引，三分而称球，而且我也给出了推广到N的解法，从中获得了很多乐趣和满足。不过那是在大学时代了，久远了
* [icrt_](http://weibo.com/<span class="number">2177249280</span>) on [October <span class="number">10</span>, <span class="number">2012</span> at <span class="number">9</span>:<span class="number">03</span> pm](http://mindhacks.cn/<span class="number">2008</span>/<span class="number">06</span>/<span class="number">13</span>/why-is-quicksort-so-quick/comment-page-<span class="number">1</span>/#comment-<span class="number">31922</span>) said:

真心佩服了。之前觉得称球问题没有什么，看这文章才知道原来有这么多的东西！
* [_小毛童鞋_](http://weibo.com/<span class="number">1238983263</span>) on [October <span class="number">16</span>, <span class="number">2012</span> at <span class="number">6</span>:<span class="number">25</span> pm](http://mindhacks.cn/<span class="number">2008</span>/<span class="number">06</span>/<span class="number">13</span>/why-is-quicksort-so-quick/comment-page-<span class="number">1</span>/#comment-<span class="number">31942</span>) said:

高爷爷是谁？
* [鸡翅呀鸡翅](http://weibo.com/brightown) on [November <span class="number">6</span>, <span class="number">2012</span> at <span class="number">3</span>:<span class="number">21</span> pm](http://mindhacks.cn/<span class="number">2008</span>/<span class="number">06</span>/<span class="number">13</span>/why-is-quicksort-so-quick/comment-page-<span class="number">1</span>/#comment-<span class="number">32004</span>) said:

哇高爷爷果然是神人也，查了一下<span class="number">73</span>年v3的第一版就有神论~~~膜拜orz
</pre></td></tr></table></figure></p>
<ul>
<li><a href="http://weibo.com/xianqings" target="_blank">ouqi</a> on <a href="http://mindhacks.cn/2008/06/13/why-is-quicksort-so-quick/comment-page-1/#comment-32350" target="_blank">April 10, 2013 at 9:46 pm</a> said:</li>
</ul>
<p>同不明白这一块：
然而，快排的第二次比较就不那么高明了：我们不妨令轴元素为pivot，第一次比较结果是a1<pivot，那么可以证明第二次比较a2也小于pivot的可能性是2/3！这容易证明：如果a2>pivot的话，那么a1，a2，pivot这三个元素之间的关系就完全确定了——a1&lt;pivot&lt;a2，剩下来的元素排列的可能性我们不妨记为P（不需要具体算出来）。而如果a2&lt;pivot呢？那么a1和a2的关系就仍然是不确定的，也就是说，这个分支里面含有两种情况：a1&lt;a2&lt;pivot，以及a2&lt;a1&lt;pivot。对于其中任一种情况，剩下的元素排列的可能性都是P，于是这个分支里面剩下的排列可能性就是2P。所以当a2&lt;pivot的时候，还剩下2/3的可能性需要排查。</p>
<p>我的疑惑在于，第一次的a2是什么，为什么要把第二次的排序和第一次的排序相关联?
不明白您定义的第二次排序是什么，我以为的第二次排序是对第一次的起始位置到第一次的pivot之间的数字的排序，那么第二次的privot又是重新选定的。也就是说在第一次排序之后，任何一个值跟第一次的privot的大小关系都是确定了的，要么比他大 要么比他小。那您说a2是什么？</p>
<ul>
<li><a href="http://www.abcsnk.com/" target="_blank">ナイキ 通販</a> on <a href="http://mindhacks.cn/2008/06/13/why-is-quicksort-so-quick/comment-page-1/#comment-32490" target="_blank">June 19, 2013 at 10:11 am</a> said:</li>
</ul>
<p>searching is another thing no doubt you like to accomplish (specially me), when i don’t recognize how but searching is one particular activity which offers us eminence delight and relaxation whenever we are generally tired as well as frustrated as well as irritated, but while using ever raising targets along with office update they have became next to impossible for us to determine some time for it to hang out with his friends and enjoy that period while rooming around for the streets involving market.</p>
<p>But even as we always say there’s <a href="http://www.abcsnk.com/adidas-スパイクサッカー-アディピュア-11pro-c-22_23_29.html" target="_blank"><a href="http://www.abcsnk.com/adidas-スパイクサッカー-アディピュア-11pro-c-22_23_29.html">http://www.abcsnk.com/adidas-スパイクサッカー-アディピュア-11pro-c-22_23_29.html</a></a> アディピュア11pro a option for just about every problem along with situation on the <a href="http:/www.sportrakuten.com"><a href="http:///www.sportrakuten.com">http:///www.sportrakuten.com</a></a> サングラス通販 globe, all you want to do is seek out that option with <a href="http://www.sportrakuten.com/categories/1369471366-179.html" target="_blank"><a href="http://www.sportrakuten.com/categories/1369471366-179.html">http://www.sportrakuten.com/categories/1369471366-179.html</a></a> レイバン サングラス ‘something different’ perspective. And which is the very reason we invented a many new method involving shopping which in turn know while online searching method. But staying this strategy new types of quarries that happen to be there inside mind of folks related on the same and were here to unravel those themselves.</p>
<p>But today you’ll find thousands involving products that is purchased via an web shop starting coming from a bugger to your flat in fact it is impossible for individuals to cover hundreds of in one particular discussion themselves therefore today we’ll be only talking over facts pertains to <a href="http://www.abcsnk.com/" target="_blank"><a href="http://www.abcsnk.com">http://www.abcsnk.com</a></a> ナイキ 通販 online searching of sneakers for adult men.</p>
<p>Buying some your favourite Adidas <a href="http://www.abcsnk.com/adidas-スパイクサッカー-プレデター-アディダス-11-c-22_23_25.html" target="_blank"><a href="http://www.abcsnk.com/adidas-スパイクサッカー-プレデター-アディダス-11-c-22_23_25.html">http://www.abcsnk.com/adidas-スパイクサッカー-プレデター-アディダス-11-c-22_23_25.html</a></a> adidas プレデター sneakers from these websites is just about the easiest thing on the <a href="http:/www.sportrakuten.com/categories/1369471516-183.html"><a href="http:///www.sportrakuten.com/categories/1369471516-183.html">http:///www.sportrakuten.com/categories/1369471516-183.html</a></a> レイバン(RAY BAN) globe, but to generate it truly easy you’ve got to keep up few in the things as well as points that happen to be listed down below.</p>
<ul>
<li>wang on <a href="http://mindhacks.cn/2008/06/13/why-is-quicksort-so-quick/comment-page-1/#comment-32571" target="_blank">July 5, 2013 at 10:12 am</a> said:</li>
</ul>
<p><a href="http://www.allsnk.com/nddbc.html" target="_blank"><a href="http://www.allsnk.com/nddbc.html">http://www.allsnk.com/nddbc.html</a></a>
<a href="http://www.allsnk.com/nddbc.html" target="_blank"><a href="http://www.allsnk.com/nddbc.html">http://www.allsnk.com/nddbc.html</a></a>
<a href="http://www.allsnk.com/nddbc.html" target="_blank"><a href="http://www.allsnk.com/nddbc.html">http://www.allsnk.com/nddbc.html</a></a></p>
<ul>
<li><h3 id="-">关于</h3>
</li>
</ul>
<p>如果你对我的文章感兴趣，那么<strong>很可能你也对我平时的阅读感兴趣</strong>，以下是一些你可以参考或订阅的资源：</p>
<ol>
<li><p><a href="http://www.douban.com/people/pongba/" target="_blank">我在豆瓣</a>上的豆列列举了一些看过的好书：<a href="http://www.douban.com/doulist/46003/" target="_blank">[只读经典]思维改变生活</a> | <a href="http://www.douban.com/doulist/127649/" target="_blank">[只读经典]思考的技术与艺术</a> | <a href="http://www.douban.com/doulist/197706/" target="_blank">决策与判断</a> | <a href="http://www.douban.com/doulist/176513/" target="_blank">机器学习与人工智能书籍资源导引</a>
我翻译的书：</p>
</li>
<li><p><a href="http://book.douban.com/subject/1470838/" target="_blank">《Imperfect C++ 中文版》</a></p>
</li>
<li><a href="http://book.douban.com/subject/1470842/" target="_blank">《Exceptional C++ Style 中文版》</a></li>
<li><p><a href="http://book.douban.com/subject/2248759/" target="_blank">《修改代码的艺术》</a>
我写的书：</p>
</li>
<li><p><a href="http://book.douban.com/subject/6709809/" target="_blank"><img src="" alt=""></a></p>
</li>
<li><h3 id="-">被阅读得最多的</h3>
</li>
</ol>
<ul>
<li><a href="http://mindhacks.cn/2009/02/15/why-you-should-start-blogging-now/" title="[BetterExplained]为什么你应该（从现在开始就）写博客" target="_blank">[BetterExplained]为什么你应该（从现在开始就）写博客</a> - 210,263 views</li>
<li><a href="http://mindhacks.cn/2011/11/04/how-to-interview-a-person-for-two-years/" title="怎样花两年时间去面试一个人" target="_blank">怎样花两年时间去面试一个人</a> - 207,509 views</li>
<li><a href="http://mindhacks.cn/2009/03/15/preconception-explained/" title="逃出你的肖申克（二）：仁者见仁智者见智？从视觉错觉到偏见" target="_blank">逃出你的肖申克（二）：仁者见仁智者见智？从视觉错觉到偏见</a> - 194,733 views</li>
<li><a href="http://mindhacks.cn/2009/12/20/dark-time/" title="暗时间" target="_blank">暗时间</a> - 193,494 views</li>
<li><a href="http://mindhacks.cn/2009/05/17/seven-years-in-nju/" title="我在南大的七年" target="_blank">我在南大的七年</a> - 176,349 views</li>
<li><a href="http://mindhacks.cn/2009/03/28/effective-learning-and-memorization/" title="[BetterExplained]如何有效地记忆与学习" target="_blank">[BetterExplained]如何有效地记忆与学习</a> - 169,039 views</li>
<li><a href="http://mindhacks.cn/2008/09/21/the-magical-bayesian-method/" title="数学之美番外篇：平凡而又神奇的贝叶斯方法" target="_blank">数学之美番外篇：平凡而又神奇的贝叶斯方法</a> - 166,636 views</li>
<li><a href="http://mindhacks.cn/2009/01/18/escape-from-your-shawshank-part1/" title="逃出你的肖申克（一）：为什么一定要亲身经历了之后才能明白？" target="_blank">逃出你的肖申克（一）：为什么一定要亲身经历了之后才能明白？</a> - 139,011 views</li>
<li><a href="http://mindhacks.cn/2010/03/18/escape-from-your-shawshank-part3/" title="逃出你的肖申克（三）：遇见20万年前的自己" target="_blank">逃出你的肖申克（三）：遇见20万年前的自己</a> - 135,486 views</li>
<li><a href="http://mindhacks.cn/2009/02/09/writing-is-better-thinking/" title="[BetterExplained]书写是为了更好的思考" target="_blank">[BetterExplained]书写是为了更好的思考</a> - 118,613 views</li>
<li><h3 id="-">我的微博</h3>
</li>
<li><h3 id="-">你可能也会喜欢以下文章</h3>
</li>
<li><p><a href="http://mindhacks.cn/2008/09/21/the-magical-bayesian-method/" title="数学之美番外篇：平凡而又神奇的贝叶斯方法" target="_blank">数学之美番外篇：平凡而又神奇的贝叶斯方法</a> (113)</p>
</li>
<li><a href="http://mindhacks.cn/2007/12/02/probability-theory-in-evolution/" title="数学之美番外篇：进化论中的概率论" target="_blank">数学之美番外篇：进化论中的概率论</a> (16)</li>
<li><a href="http://mindhacks.cn/2006/10/15/cantor-godel-turing-an-eternal-golden-diagonal/" title="康托尔、哥德尔、图灵——永恒的金色对角线(rev#2)" target="_blank">康托尔、哥德尔、图灵——永恒的金色对角线(rev/#2)</a> (56)</li>
<li><a href="http://mindhacks.cn/2011/07/10/the-importance-of-knowing-why-part3/" title="知其所以然（三）：为什么算法这么难？" target="_blank">知其所以然（三）：为什么算法这么难？</a> (74)</li>
<li><a href="http://mindhacks.cn/2010/11/14/the-importance-of-knowing-why-part2/" title="知其所以然（续）" target="_blank">知其所以然（续）</a> (54)</li>
<li><a href="http://mindhacks.cn/2008/09/11/machine-learning-and-ai-resources/" title="机器学习与人工智能学习资源导引" target="_blank">机器学习与人工智能学习资源导引</a> (18)</li>
<li><a href="http://mindhacks.cn/2008/07/07/the-importance-of-knowing-why/" title="知其所以然（以算法学习为例）" target="_blank">知其所以然（以算法学习为例）</a> (46)</li>
<li><a href="http://mindhacks.cn/2008/04/18/learning-from-polya/" title="跟波利亚学解题(rev#3)" target="_blank">跟波利亚学解题(rev/#3)</a> (32)
*</li>
</ul>
<p>*</p>
<p><a href="http://www.arrastheme.com/" target="_blank"><strong>About Arras WordPress Theme</strong></a></p>
<p>Copyright 刘未鹏 | Mind Hacks. All Rights Reserved. <a href="http://www.miibeian.gov.cn/" target="_blank">苏ICP备09004067号</a>. Powered by <a href="http://wordpress.org/" target="_blank">Wordpress</a>. Using <a href="http://www.arrastheme.com/" target="_blank">Arras Theme</a>.</p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/算法&数组&优化/">算法&数组&优化</a></li><li><a href="/categories/Java&J2EE/算法&数组&优化/算法/">算法</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/算法/" class="label label-success">算法</a><a href="/tags/算法&数组&优化/" class="label label-info">算法&数组&优化</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:40"datetime="2014-03-07 09:54:40"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-算法数组优化-算法--数学之美番外篇：快排为什么那样快/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-算法数组优化-算法--数学之美番外篇：快排为什么那样快" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>





<ul id="pagination" class="pagination pagination-lg">
  <li><a class="extend prev" href="/page/68/">&laquo;</a></li><li><a class="page-number" href="/">1</a></li><li><a class="page-number" href="/page/2/">2</a></li><li><span class="space">&hellip;</span></li><li><a class="page-number" href="/page/66/">66</a></li><li><a class="page-number" href="/page/67/">67</a></li><li><a class="page-number" href="/page/68/">68</a></li><li class="active"><li><span class="page-number current">69</span></li><li><a class="page-number" href="/page/70/">70</a></li><li><a class="page-number" href="/page/71/">71</a></li><li><a class="page-number" href="/page/72/">72</a></li><li><span class="space">&hellip;</span></li></li><li><a class="page-number" href="/page/161/">161</a></li><li><a class="page-number" href="/page/162/">162</a></li><li><a class="extend next" href="/page/70/">&raquo;</a></li>
  <div class="clearfix"></div>
</ul></div><!--wapper-->
       </div><!-- ID main-col END -->
       <aside id="sidebar" class="alignright col-sx-6 col-sm-4 col-md-3 col-lg-3">
<div id="widget_search" class="widget panel panel-primary">
    <form action="//google.com/search" method="get" accept-charset="utf-8">
  <div class="input-group">
    <input class="form-control" id="searchbox" type="search" name="q" results="0" placeholder="search">
    <span class="input-group-btn">
      <button class="btn btn-default" type="submit">Go!</button>
    </span>
    <input type="hidden" name="q" value="site:itsolife.com">
  </div>
</form>
</div>

<div id="widget_category" class="widget panel panel-primary">
  <div class="panel-heading">category</div>  <div data-src='category' class='ajax_widgets'>正在加载...</div>
</div>

<div id="widget_recent_posts" class="widget panel panel-primary">
  <div class="panel-heading">recent posts</div>  <div data-src='recent_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_tagcloud" class="widget panel panel-primary">
  <div class="panel-heading">tagcloud</div>  <div data-src='tagcloud' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_latest_update_posts" class="widget panel panel-primary">
  <div class="panel-heading">最近更新</div>  <div data-src='latest_update_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_recent_comments" class="widget panel panel-primary">
  <div class="panel-heading">recent comments</div>  

<div class="list-group-item ds-recent-comments" data-num-items="6" data-show-avatars="1" data-show-time="1" data-show-title="1" data-show-admin="1" data-excerpt-length="50"></div>



</div>

</aside>
       <div class="clearfix"></div>
     </div><!-- row END -->
  </div>
  <footer id="footer" class="container">
  <div class="panel panel-info">
  <section id='footer_widget'></section>  <div class="panel-footer">
  <div id="site-info">
    <span class='author'>
  
  &copy; 2014 RobinChia
  
    &nbsp;&nbsp;</span>
  
  <span id='analytics-51la'></span><span id='analytics-google'>
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-48559895-1']);
  _gaq.push(['_trackPageview']);
  _js2load.push({src:('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'});
</script></span><span id='analytics-cnzz'>
<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_5774006'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s17.cnzz.com/stat.php%3Fid%3D5774006%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>
</span><span id='analytics-baidu'>
<script>
var _hmt = _hmt || [];
_js2load.push({src:"//hm.baidu.com/hm.js?1442f50724afc42380b51f097c43082c"});
</script>
</span>  </div>
  <div id="copyright">Site powered by <a href='http://zespia.tw/hexo/'><strong>hexo</strong></a>  update time: <em>2014-04-07 19:05:46</em></span></div>
</div>
<div class="clearfix"></div>


  </div>
  </footer>
  
        <script src="http://cdn.bootcss.com/jquery/1.10.2/jquery.min.js"></script>        
        <script src="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/js/bootstrap.min.js"></script>        
                
        <script src="http://cdn.bootcss.com/prettify/r298/prettify.min.js"></script>    <script type="text/javascript">
   var lang=["bsh", "c", "cc", "cpp", "cs", "csh", "cyc", "cv", "htm", "html",
    "java", "js", "m", "mxml", "perl", "pl", "pm", "py", "rb", "sh",
    "xhtml", "xml", "xsl"];
   var pretty_base='';
   $('script').each(function(){
	var c = $(this).attr('src');
	if (!c)
	    return;
	if (c.match(/(\/)?prettify(\.min)?\.js/i))
	{
	    var index = c.lastIndexOf('/');
	    if (index != -1)
		pretty_base = c.substr(0,index + 1);
	    return false;
	}
   })
   $('pre code').each(function(){
	var c = $(this).attr('class')
	if (!c)
	    return;
	c = c.match(/\s?(lang\-\w+)/i);
	if (c && lang.indexOf(c[1]) == -1)
	{
	    lang.push(c[1]);
	    $.getScript(pretty_base + c[1] + '.min.js');
	}
   })

    $(window).load(function(){
       $("pre").addClass("prettyprint");
       prettyPrint();
    })
</script>    
            <script type="text/javascript">
var duoshuoQuery = {short_name:"robinchia"};
_js2load.push({src:'http://static.duoshuo.com/embed.js',charset:'UTF-8'});
</script>
    
            <!--wumii_relatedItems-->
    
        <script src="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js"></script>    <script type="text/javascript">
(function($){
  $('.entry').each(function(i){
    $(this).find('img').each(function(){
      var alt = this.alt;

      if (alt){
        $(this).before('<span class="caption">' + alt + '</span>');
      }

      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox" rel="fancybox' + i + '" />');
    });
  });

  $('.fancybox').fancybox();
})(jQuery);
</script>    
        <script src="http://cdn.bootcss.com/mathjax/2.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>    <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>
    
<script type="text/javascript">
$('.ajax_widgets').each(function(){var src=$(this).attr('data-src');if(src)$(this).load('/widgets/'+src+'.html');});
$.each(_js2load,function(index,obj){loadjs(obj.src,obj.charset)});
</script>

<div id="scroll2top">
<img src="/scroll2top/arrow.png"/>
</div>
<script src="/scroll2top/scroll2top.min.js"></script>
<div id="winterland">
  <canvas></canvas>
</div>
<script src="/js/winterland.min.js"></script>

  </body>
</html>
