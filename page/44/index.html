
<!DOCTYPE HTML>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>The 44 Page | It so life</title>
<meta name="author" content="RobinChia">

<meta name="description" content="It so life">


<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<meta property="og:site_name" content="It so life"/>

<!--[if IE]><style>.testIE.IE{display:inline;}</style><![endif]-->
<!--[if lte IE 7]><link rel="stylesheet" href="/css/ie7.css" type="text/css"><![endif]-->
<!--[if (lt IE 9)&(gt IE 7)]><style>.testIE.IE8{display:inline;}</style><![endif]-->
<!--[if gt IE 8]><style>.testIE.IE9{display:inline;}</style><![endif]-->

<link href="/favicon.png" rel="icon">
<link rel="alternate" href="/atom.xml" title="It so life Feed" type="application/atom+xml">

<link rel="stylesheet" href="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/css/bootstrap.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/font-awesome/4.0.3/css/font-awesome.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/prettify/r298/prettify.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" type="text/css">
<link rel="stylesheet" href="/css/style.css" type="text/css">
<!--[if lt IE 9]>
   <style>article,aside,dialog,footer,header,section,footer,nav,figure,menu{display:block}</style>
   <script src="http://cdn.staticfile.org/html5shiv/r29/html5.min.js"></script>
   <script src="http://cdn.staticfile.org/respond.js/1.4.2/respond.min.js"></script>
<link href="http://cdn.staticfile.org/respond.js/1.4.2/respond-proxy.html" id="respond-proxy" rel="respond-proxy" />
<link href="/js/respond.proxy.gif" id="respond-redirect" rel="respond-redirect" />
<script src="/js/respond.proxy.js"></script>
   <script src="http://cdn.bootcss.com/selectivizr/1.0.2/selectivizr-min.js"></script>
<![endif]-->
<script type="text/javascript">
function loadjs(c,d){var a=document.createElement("script");a.async=!0;a.type="text/javascript";a.src=c;a.charset=d||"gbk";(document.getElementsByTagName("HEAD")[0]||document.getElementsByTagName("BODY")[0]).appendChild(a)};
var _protocol = (("https:" == document.location.protocol) ? " https://" : " http://");
var _js2load = [];
</script>

</head>
<body>
      <header id="header" class="container"><nav id="main-nav" class="navbar navbar-default navbar-fixed-top " role="navigation">
  <div class="container">
    <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
      <span class="sr-only">Toggle navigation</span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="/">It so life</a>
    </div>
    <div  class="collapse navbar-collapse">
      <ul  class="nav navbar-nav">
  
        <li><a href="/" title="Home">Home</a></li>      
        <li><a href="/about/" title="About">About</a></li>      
        <li><a href="/archives/" title="Archives">Archives</a></li>      
      <li class='dropdown'>
        <a class='dropdown-toggle' data-toggle='dropdown' href='#'>website<b class='caret'></b></a>
        <ul class='dropdown-menu pure-menu-selected'>
    
          <li><a href="//groups.google.com/forum/#!forum/pongba" title="TopLanguage">TopLanguage</a></li>    
          <li><a href="//itpub.net/" title="ITPub">ITPub</a></li>    
          <li><a href="//blog.jobbole.com/" title="Bole">Bole</a></li>    
          <li><a href="//nosql-database.org/" title="nosql">nosql</a></li>    
          <li><a href="//gitimmersion.googol.im/" title="Git">Git</a></li>    
        </ul>
      </li>
    
      </ul>
      <ul class="nav navbar-nav navbar-right">
      
        <li><a href="/atom.xml">RSS</a></li>
      
      
        <li><a href="https://twitter.com/robinchia">twitter</a></li>
      
      
      
      
        <li><a href="https://github.com/robinchia">github</a></li>
      
      </ul>
    </div>
  </div>
</nav>
<div class="clearfix"></div>
</header>
  <div id='content' class="container">
     <div class="page-header-wrapper">
      <!--[if lt IE 9]><div class="alert alert-warning alert-dismissable"><button type="button" class="close" data-dismiss="alert" aria-hidden="true">&times;</button><strong>提示:</strong>您的浏览器版本太低了,建议升级到 <strong><a href="http://windows.microsoft.com/zh-cn/internet-explorer/download-ie" title="IE9">IE9</a></strong> 以上,本站使用<a href="https://www.google.com/intl/zh-CN/chrome/">Chrome浏览器</a>可以获得最好的显示效果.</div><![endif]-->
      <div class="page-header"><h1 align="center"><big>It so life</big> </h1>
        <h5 align="center"><big>love as life</big></h5>
      </div>
     </div>
     <div class="row">
       <div id="main-col" class="alignleft col-sx-12 col-sm-8 col-md-9 col-lg-9">
      <section id='header_widget'></section>
          <div id="wrapper"><article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_总结类--java实现double的精确计算和四舍五入/">java实现double的精确计算和四舍五入</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:43.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_总结类--java实现double的精确计算和四舍五入/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="java-double-">java实现double的精确计算和四舍五入</h1>
<h1 id="-http-blog-csdn-net-a9529lty-"><a href="http://blog.csdn.net/a9529lty" target="_blank">遗忘的角落</a></h1>
<h1 id="-">#</h1>
<ul>
<li><a href="http://passport.csdn.net/UserLogin.aspx" target="_blank">登录</a></li>
<li><a href="http://passport.csdn.net/CSDNUserRegister.aspx" target="_blank">注册</a></li>
<li><a href="http://hi.csdn.net/" target="_blank">欢迎</a></li>
<li><a href="http://writeblog.csdn.net/Signout.aspx" target="_blank">退出</a></li>
<li><a href="http://blog.csdn.net/" target="_blank">我的博客</a></li>
<li><a href="http://writeblog.csdn.net/configure.aspx" target="_blank">配置</a></li>
<li><a href="http://writeblog.csdn.net/PostEdit.aspx" target="_blank">写文章</a></li>
<li><a href="http://writeblog.csdn.net/PostList.aspx" target="_blank">文章管理</a></li>
<li><a href="http://blog.csdn.net/" target="_blank">博客首页</a></li>
</ul>
<p>*</p>
<ul>
<li><p>全站 当前博客
*</p>
</li>
<li><p><a href="http://hi.csdn.net/a9529lty" target="_blank">空间</a></p>
</li>
<li><a href="http://blog.csdn.net/a9529lty" target="_blank">博客</a></li>
<li><a href="http://hi.csdn.net/!s/friend/list/a9529lty" target="_blank">好友</a></li>
<li><a href="http://hi.csdn.net/!s/album/list/a9529lty" target="_blank">相册</a></li>
<li><a href="http://hi.csdn.net/!s/wall/to/a9529lty" target="_blank">留言</a></li>
</ul>
<p>用户操作<a href="http://hi.csdn.net/!s/wall/to/a9529lty" target="_blank">[留言]</a>  <a href="http://hi.csdn.net/!s/msg/to/a9529lty" target="_blank">[发消息]</a>  <a href="http://hi.csdn.net/!s/friend/add/a9529lty" target="_blank">[加为好友]</a> 订阅我的博客<a href="http://feeds.feedsky.com/csdn.net/a9529lty" target="_blank"><img src="" alt="XML聚合"></a>   <a href="http://feeds.feedsky.com/csdn.net/a9529lty" target="_blank"><img src="" alt="FeedSky"></a><a href="http://www.xianguo.com/subscribe.php?url=http://feeds.feedsky.com/csdn.net/a9529lty" target="_blank"><img src="" alt="订阅到鲜果"></a><a href="http://fusion.google.com/add?feedurl=http://feeds.feedsky.com/csdn.net/a9529lty" target="_blank"><img src="" alt="订阅到Google"></a><a href="http://www.zhuaxia.com/add_channel.php?url=http://feeds.feedsky.com/csdn.net/a9529lty" target="_blank"><img src="" alt="订阅到抓虾"></a><a href="http://writeblog.csdn.net/configure.aspx" target="_blank">[编辑]</a>a9529lty的公告我的QQ是297453997欢迎大家加我一起讨论问题<a href="http://writeblog.csdn.net/EditCategories.aspx?catID=1" target="_blank">[编辑]</a>文章分类* <a href="http://blog.csdn.net/a9529lty/category/354401.aspx/rss" target="_blank"><img src="" alt="(RSS)"></a><a href="http://blog.csdn.net/a9529lty/category/354401.aspx" target="_blank">Ajax</a></p>
<ul>
<li><a href="http://blog.csdn.net/a9529lty/category/352346.aspx/rss" target="_blank"><img src="" alt="(RSS)"></a><a href="http://blog.csdn.net/a9529lty/category/352346.aspx" target="_blank">C/#</a></li>
<li><a href="http://blog.csdn.net/a9529lty/category/526658.aspx/rss" target="_blank"><img src="" alt="(RSS)"></a><a href="http://blog.csdn.net/a9529lty/category/526658.aspx" title="Eclipse" target="_blank">Eclipse</a></li>
<li><a href="http://blog.csdn.net/a9529lty/category/354338.aspx/rss" target="_blank"><img src="" alt="(RSS)"></a><a href="http://blog.csdn.net/a9529lty/category/354338.aspx" target="_blank">Hibernate</a></li>
<li><a href="http://blog.csdn.net/a9529lty/category/352340.aspx/rss" target="_blank"><img src="" alt="(RSS)"></a><a href="http://blog.csdn.net/a9529lty/category/352340.aspx" target="_blank">Java</a></li>
<li><a href="http://blog.csdn.net/a9529lty/category/352342.aspx/rss" target="_blank"><img src="" alt="(RSS)"></a><a href="http://blog.csdn.net/a9529lty/category/352342.aspx" target="_blank">Javascript</a></li>
<li><a href="http://blog.csdn.net/a9529lty/category/356239.aspx/rss" target="_blank"><img src="" alt="(RSS)"></a><a href="http://blog.csdn.net/a9529lty/category/356239.aspx" target="_blank">Jsf</a></li>
<li><a href="http://blog.csdn.net/a9529lty/category/356238.aspx/rss" target="_blank"><img src="" alt="(RSS)"></a><a href="http://blog.csdn.net/a9529lty/category/356238.aspx" target="_blank">Jsp</a></li>
<li><a href="http://blog.csdn.net/a9529lty/category/600868.aspx/rss" target="_blank"><img src="" alt="(RSS)"></a><a href="http://blog.csdn.net/a9529lty/category/600868.aspx" title="Lua " target="_blank">Lua</a></li>
<li><a href="http://blog.csdn.net/a9529lty/category/431500.aspx/rss" target="_blank"><img src="" alt="(RSS)"></a><a href="http://blog.csdn.net/a9529lty/category/431500.aspx" target="_blank">Mysql</a></li>
<li><a href="http://blog.csdn.net/a9529lty/category/352341.aspx/rss" target="_blank"><img src="" alt="(RSS)"></a><a href="http://blog.csdn.net/a9529lty/category/352341.aspx" target="_blank">Netbeans</a></li>
<li><a href="http://blog.csdn.net/a9529lty/category/353973.aspx/rss" target="_blank"><img src="" alt="(RSS)"></a><a href="http://blog.csdn.net/a9529lty/category/353973.aspx" target="_blank">Oracle</a></li>
<li><a href="http://blog.csdn.net/a9529lty/category/403584.aspx/rss" target="_blank"><img src="" alt="(RSS)"></a><a href="http://blog.csdn.net/a9529lty/category/403584.aspx" target="_blank">Sql</a></li>
<li><a href="http://blog.csdn.net/a9529lty/category/430229.aspx/rss" target="_blank"><img src="" alt="(RSS)"></a><a href="http://blog.csdn.net/a9529lty/category/430229.aspx" target="_blank">Struts</a></li>
<li><a href="http://blog.csdn.net/a9529lty/category/354337.aspx/rss" target="_blank"><img src="" alt="(RSS)"></a><a href="http://blog.csdn.net/a9529lty/category/354337.aspx" target="_blank">Tomcat</a></li>
<li><a href="http://blog.csdn.net/a9529lty/category/593722.aspx/rss" target="_blank"><img src="" alt="(RSS)"></a><a href="http://blog.csdn.net/a9529lty/category/593722.aspx" title="面试专用" target="_blank">基础知识(面试专用)</a></li>
<li><a href="http://blog.csdn.net/a9529lty/category/449114.aspx/rss" target="_blank"><img src="" alt="(RSS)"></a><a href="http://blog.csdn.net/a9529lty/category/449114.aspx" target="_blank">日语</a></li>
<li><a href="http://blog.csdn.net/a9529lty/category/507814.aspx/rss" target="_blank"><img src="" alt="(RSS)"></a><a href="http://blog.csdn.net/a9529lty/category/507814.aspx" target="_blank">算法</a></li>
<li><a href="http://blog.csdn.net/a9529lty/category/352351.aspx/rss" target="_blank"><img src="" alt="(RSS)"></a><a href="http://blog.csdn.net/a9529lty/category/352351.aspx" target="_blank">正则表达式</a><a href="http://writeblog.csdn.net/ArticleList.aspx" target="_blank">[编辑]</a>收藏<a href="http://blog.csdn.net/a9529lty/category/352350.aspx" target="_blank">正则表达式</a>存档* <a href="http://blog.csdn.net/a9529lty/archive/2009/10.aspx" target="_blank">2009年10月(7)</a></li>
<li><a href="http://blog.csdn.net/a9529lty/archive/2009/09.aspx" target="_blank">2009年09月(10)</a></li>
<li><a href="http://blog.csdn.net/a9529lty/archive/2009/07.aspx" target="_blank">2009年07月(4)</a></li>
<li><a href="http://blog.csdn.net/a9529lty/archive/2009/06.aspx" target="_blank">2009年06月(6)</a></li>
<li><a href="http://blog.csdn.net/a9529lty/archive/2009/05.aspx" target="_blank">2009年05月(9)</a></li>
<li><a href="http://blog.csdn.net/a9529lty/archive/2009/04.aspx" target="_blank">2009年04月(16)</a></li>
<li><a href="http://blog.csdn.net/a9529lty/archive/2009/03.aspx" target="_blank">2009年03月(9)</a></li>
<li><a href="http://blog.csdn.net/a9529lty/archive/2009/02.aspx" target="_blank">2009年02月(4)</a></li>
<li><a href="http://blog.csdn.net/a9529lty/archive/2009/01.aspx" target="_blank">2009年01月(17)</a></li>
<li><a href="http://blog.csdn.net/a9529lty/archive/2008/12.aspx" target="_blank">2008年12月(34)</a></li>
<li><a href="http://blog.csdn.net/a9529lty/archive/2008/11.aspx" target="_blank">2008年11月(23)</a></li>
<li><a href="http://blog.csdn.net/a9529lty/archive/2008/10.aspx" target="_blank">2008年10月(16)</a></li>
<li><a href="http://blog.csdn.net/a9529lty/archive/2008/09.aspx" target="_blank">2008年09月(13)</a></li>
<li><a href="http://blog.csdn.net/a9529lty/archive/2008/08.aspx" target="_blank">2008年08月(21)</a></li>
<li><a href="http://blog.csdn.net/a9529lty/archive/2008/07.aspx" target="_blank">2008年07月(20)</a></li>
<li><a href="http://blog.csdn.net/a9529lty/archive/2008/06.aspx" target="_blank">2008年06月(1)</a></li>
<li><a href="http://blog.csdn.net/a9529lty/archive/2008/05.aspx" target="_blank">2008年05月(12)</a></li>
<li><a href="http://blog.csdn.net/a9529lty/archive/2008/04.aspx" target="_blank">2008年04月(2)</a></li>
<li><a href="http://blog.csdn.net/a9529lty/archive/2008/03.aspx" target="_blank">2008年03月(3)</a></li>
<li><a href="http://blog.csdn.net/a9529lty/archive/2008/01.aspx" target="_blank">2008年01月(4)</a></li>
<li><a href="http://blog.csdn.net/a9529lty/archive/2007/12.aspx" target="_blank">2007年12月(51)</a><h1 id="java-double-">java实现double的精确计算和四舍五入 <a href="&quot;收藏到我的网摘中，并分享给我的朋友&quot;">收藏</a></h1>
</li>
</ul>
<hr>
<p><strong>Java中的简单浮点数类型float和double不能够进行运算。不光是Java，在其它很多编程语言中也有这样的问题。在大多数情况下，计算的结果是准确的，但是多试几次（可以做一个循环）就可以试出类似上面的错误。现在终于理解为什么要有BCD码了。
这个问题相当严重，如果你有9.999999999999元，你的计算机是不会认为你可以购买10元的商品的。
在有的编程语言中提供了专门的货币类型来处理这种情况，但是Java没有。现在让我们看看如何解决这个问题。
四舍五入
我们的第一个反应是做四舍五入。Math类中的round方法不能设置保留几位小数，我们只能象这样（保留两位）：
public double round(double value){
    return Math.round(value/<em>100)/100.0;
}
非常不幸，上面的代码并不能正常工作，给这个方法传入4.015它将返回4.01而不是4.02，如我们在上面看到的
4.015/</em>100=401.49999999999994
因此如果我们要做到精确的四舍五入，不能利用简单类型做任何运算
java.text.DecimalFormat也不能解决这个问题：
System.out.println(new java.text.DecimalFormat(&quot;0.00&quot;).format(4.025));
输出是4.02</strong>
**java 代码</p>
<p>import java.math.BigDecimal; public class Arith { private static final int DEF_DIV_SCALE = 10; private Arith() { } //<em>/</em> /<em> 提供精确的加法运算。 /</em> @param v1 被加数 /<em> @param v2 加数 /</em> @return 两个参数的和 /<em>/ public static double add(double v1,double v2) { BigDecimal b1 = new BigDecimal(Double.toString(v1)); BigDecimal b2 = new BigDecimal(Double.toString(v2)); return b1.add(b2).doubleValue(); } //</em>/<em> /</em> 提供精确的减法运算。 /<em> @param v1 被减数 /</em> @param v2 减数 /<em> @return 两个参数的差 /</em>/ public static double sub(double v1,double v2) { BigDecimal b1 = new BigDecimal(Double.toString(v1)); BigDecimal b2 = new BigDecimal(Double.toString(v2)); return b1.subtract(b2).doubleValue(); } //<em>/</em> /<em> 提供精确的乘法运算。 /</em> @param v1 被乘数 /<em> @param v2 乘数 /</em> @return 两个参数的积 /<em>/ public static double mul(double v1,double v2) { BigDecimal b1 = new BigDecimal(Double.toString(v1)); BigDecimal b2 = new BigDecimal(Double.toString(v2)); return b1.multiply(b2).doubleValue(); } //</em>/<em> /</em> 提供（相对）精确的除法运算，当发生除不尽的情况时，精确到 /<em> 小数点以后10位，以后的数字四舍五入。 /</em> @param v1 被除数 /<em> @param v2 除数 /</em> @return 两个参数的商 /<em>/ public static double div(double v1,double v2) { return div(v1,v2,DEF_DIV_SCALE); } //</em>/<em> /</em> 提供（相对）精确的除法运算。当发生除不尽的情况时，由scale参数指 /<em> 定精度，以后的数字四舍五入。 /</em> @param v1 被除数 /<em> @param v2 除数 /</em> @param scale 表示表示需要精确到小数点以后几位。 /<em> @return 两个参数的商 /</em>/ public static double div(double v1,double v2,int scale) { if(scale&lt;0) { throw new IllegalArgumentException(&quot;The scale must be a positive integer or zero&quot;); } BigDecimal b1 = new BigDecimal(Double.toString(v1)); BigDecimal b2 = new BigDecimal(Double.toString(v2)); return b1.divide(b2,scale,BigDecimal.ROUND_HALF_UP).doubleValue(); } //<em>/</em> /<em> 提供精确的小数位四舍五入处理。 /</em> @param v 需要四舍五入的数字 /<em> @param scale 小数点后保留几位 /</em> @return 四舍五入后的结果 /<em>/ public static double round(double v,int scale){ if(scale&lt;0) { throw new IllegalArgumentException(&quot;The scale must be a positive integer or zero&quot;); } BigDecimal b = new BigDecimal(Double.toString(v)); BigDecimal one = new BigDecimal(&quot;1&quot;); return b.divide(one,scale,BigDecimal.ROUND_HALF_UP).doubleValue(); } }
*</em></p>
<p>发表于 @ 2009年05月18日　23:07:00 | <a href="http://blog.csdn.net/a9529lty/archive/2009/05/18/4199684.aspx#FeedBack" title="评论" target="_blank">评论( loading...  )</a>| <a href="http://writeblog.csdn.net/PostEdit.aspx?entryId=4199684" title="编辑" target="_blank">编辑</a>| <a href="mailto:webmaster@csdn.net?subject=Article%20Report!!!&amp;body=Author:a9529lty%0D%0AURL:http://blog.csdn.net/ArticleContent.aspx?UserName=a9529lty&amp;Entryid=4199684">举报</a>| <a href="&quot;收藏到我的网摘中，并分享给我的朋友&quot;">收藏</a></p>
<h3 id="-http-blog-csdn-net-a9529lty-archive-2009-05-13-4179695-aspx-oracle-http-blog-csdn-net-a9529lty-archive-2009-05-27-4221509-aspx-"><a href="http://blog.csdn.net/a9529lty/archive/2009/05/13/4179695.aspx" target="_blank">旧一篇:淘宝生成预览图片</a> | <a href="http://blog.csdn.net/a9529lty/archive/2009/05/27/4221509.aspx" target="_blank">新一篇:Oracle层次查询和分析函数</a><a href=""></a></h3>
<p>Copyright © a9529ltyPowered by CSDN Blog<img src="" alt=""></p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/Java_总结类/">Java_总结类</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/Java_总结类/" class="label label-success">Java_总结类</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:43"datetime="2014-03-07 09:54:43"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-Java_总结类--java实现double的精确计算和四舍五入/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-Java_总结类--java实现double的精确计算和四舍五入" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-gitgithub--Git详解之一：Git起步/">Git详解之一：Git起步</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:43.000Z"> <a href="/2014/02/02/2014-02-02-gitgithub--Git详解之一：Git起步/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="git-git-">Git详解之一：Git起步</h1>
<p>原文：<a href="http://git-scm.com/book/zh" target="_blank">《Pro Git》</a></p>
<p><strong>起步</strong></p>
<p>本章介绍开始使用 Git 前的相关知识。我们会先了解一些版本控制工具的历史背景，然后试着让 Git 在你的系统上跑起来，直到最后配置好，可以正常开始开发工作。读完本章，你就会明白为什么 Git 会如此流行，为什么你应该立即开始使用它。（<a href="http://blog.jobbole.com/tag/git/" target="_blank">查看Git详解系列的全部文章</a>）</p>
<p><strong>1.1 关于版本控制
</strong></p>
<p>什么是版本控制？我真的需要吗？版本控制是一种记录若干文件内容变化，以便将来查阅特定版本修订情况的系统。在本书所展示的例子中，我们仅对保存着软件源代码的文本文件作版本控制管理，但实际上，你可以对任何类型的文件进行版本控制。</p>
<p>如果你是位图形或网页设计师，可能会需要保存某一幅图片或页面布局文件的所有修订版本（这或许是你非常渴望拥有的功能）。采用版本控制系统 （VCS）是个明智的选择。有了它你就可以将某个文件回溯到之前的状态，甚至将整个项目都回退到过去某个时间点的状态。你可以比较文件的变化细节，查出最 后是谁修改了哪个地方，从而导致出现怪异问题，又是谁在何时报告了某个功能缺陷等等。使用版本控制系统通常还意味着，就算你乱来一气把整个项目中的文件改 的改删的删，你也照样可以轻松恢复到原先的样子。但额外增加的工作量却微乎其微。</p>
<p><strong>本地版本控制系统</strong></p>
<p>许多人习惯用复制整个项目目录的方式来保存不同的版本，或许还会改名加上备份时间以示区别。这么做唯一的好处就是简单。不过坏处也不少：有时候会混淆所在的工作目录，一旦弄错文件丢了数据就没法撤销恢复。</p>
<p>为了解决这个问题，人们很久以前就开发了许多种本地版本控制系统，大多都是采用某种简单的数据库来记录文件的历次更新差异（见图 1-1）。</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-start1.png" title="Git详解之一：Git起步" target="_blank"><img src="&quot;Git详解之一：Git起步&quot;" alt="Git详解之一：Git起步"></a></p>
<p>图 1-1. 本地版本控制系统</p>
<p>其中最流行的一种叫做 rcs，现今许多计算机系统上都还看得到它的踪影。甚至在流行的 Mac OS X 系统上安装了开发者工具包之后，也可以使用 rcs 命令。它的工作原理基本上就是保存并管理文件补丁（patch）。文件补丁是一种特定格式的文本文件，记录着对应文件修订前后的内容变化。所以，根据每次 修订后的补丁，rcs 可以通过不断打补丁，计算出各个版本的文件内容。</p>
<p><strong>集中化的版本控制系统</strong></p>
<p>接下来人们又遇到一个问题，如何让在不同系统上的开发者协同工作？于是，集中化的版本控制系统（ Centralized Version Control Systems，简称 CVCS ）应运而生。这类系统，诸如 CVS，Subversion 以及 Perforce 等，都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。多年以来，这 已成为版本控制系统的标准做法（见图 1-2）。</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-start2.png" title="Git详解之一：Git起步" target="_blank"><img src="&quot;Git详解之一：Git起步&quot;" alt="Git详解之一：Git起步"></a></p>
<p>图 1-2. 集中化的版本控制系统</p>
<p>这种做法带来了许多好处，特别是相较于老式的本地 VCS 来说。现在，每个人都可以在一定程度上看到项目中的其他人正在做些什么。而管理员也可以轻松掌控每个开发者的权限，并且管理一个 CVCS 要远比在各个客户端上维护本地数据库来得轻松容易。</p>
<p>事分两面，有好有坏。这么做最显而易见的缺点是中央服务器的单点故障。如果宕机一小时，那么在这一小时内，谁都无法提交更新，也就无法协同工作。要 是中央服务器的磁盘发生故障，碰巧没做备份，或者备份不够及时，就还是会有丢失数据的风险。最坏的情况是彻底丢失整个项目的所有历史更改记录，而被客户端 提取出来的某些快照数据除外，但这样的话依然是个问题，你不能保证所有的数据都已经有人事先完整提取出来过。本地版本控制系统也存在类似问题，只要整个项 目的历史记录被保存在单一位置，就有丢失所有历史更新记录的风险。</p>
<p><strong>分布式版本控制系统</strong></p>
<p>于是分布式版本控制系统（ Distributed Version Control System，简称 DVCS ）面世了。在这类系统中，像 Git，Mercurial，Bazaar 以及 Darcs 等，客户端并不只提取最新版本的文件快照，而是把原始的代码仓库完整地镜像下来。这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜 像出来的本地仓库恢复。因为每一次的提取操作，实际上都是一次对代码仓库的完整备份（见图 1-3）。</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-start3.png" title="Git详解之一：Git起步" target="_blank"><img src="&quot;Git详解之一：Git起步&quot;" alt="Git详解之一：Git起步"></a>
图 1-3. 分布式版本控制系统</p>
<p>更进一步，许多这类系统都可以指定和若干不同的远端代码仓库进行交互。籍此，你就可以在同一个项目中，分别和不同工作小组的人相互协作。你可以根据需要设定不同的协作流程，比如层次模型式的工作流，而这在以前的集中式系统中是无法实现的。</p>
<p><strong>1.2 Git 简史</strong></p>
<p>同生活中的许多伟大事件一样，Git 诞生于一个极富纷争大举创新的年代。Linux 内核开源项目有着为数众广的参与者。绝大多数的 Linux 内核维护工作都花在了提交补丁和保存归档的繁琐事务上（1991－2002年间）。到 2002 年，整个项目组开始启用分布式版本控制系统 BitKeeper 来管理和维护代码。</p>
<p>到了 2005 年，开发 BitKeeper 的商业公司同 Linux 内核开源社区的合作关系结束，他们收回了免费使用 BitKeeper 的权力。这就迫使 Linux 开源社区（特别是 Linux 的缔造者 Linus Torvalds ）不得不吸取教训，只有开发一套属于自己的版本控制系统才不至于重蹈覆辙。他们对新的系统制订了若干目标：</p>
<p>/<em> 速度 /</em> 简单的设计 /<em> 对非线性开发模式的强力支持（允许上千个并行开发的分支） /</em> 完全分布式 /* 有能力高效管理类似 Linux 内核一样的超大规模项目（速度和数据量）</p>
<p>自诞生于 2005 年以来，Git 日臻成熟完善，在高度易用的同时，仍然保留着初期设定的目标。它的速度飞快，极其适合管理大项目，它还有着令人难以置信的非线性分支管理系统（见第三章），可以应付各种复杂的项目开发需求。</p>
<p><strong>1.3 Git 基础</strong></p>
<p>那么，简单地说，Git 究竟是怎样的一个系统呢？请注意，接下来的内容非常重要，若是理解了 Git 的思想和基本工作原理，用起来就会知其所以然，游刃有余。在开始学习 Git 的时候，请不要尝试把各种概念和其他版本控制系统（诸如 Subversion 和 Perforce 等）相比拟，否则容易混淆每个操作的实际意义。Git 在保存和处理各种信息的时候，虽然操作起来的命令形式非常相近，但它与其他版本控制系统的做法颇为不同。理解这些差异将有助于你准确地使用 Git 提供的各种工具。</p>
<p><strong>直接记录快照，而非差异比较</strong></p>
<p>Git 和其他版本控制系统的主要差别在于，Git 只关心文件数据的整体是否发生变化，而大多数其他系统则只关心文件内容的具体差异。这类系统 （CVS，Subversion，Perforce，Bazaar 等等）每次记录有哪些文件作了更新，以及都更新了哪些行的什么内容，请看图 1-4。</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-start4.png" title="Git详解之一：Git起步" target="_blank"><img src="&quot;Git详解之一：Git起步&quot;" alt="Git详解之一：Git起步"></a>
图 1-4. 其他系统在每个版本中记录着各个文件的具体差异</p>
<p>Git 并不保存这些前后变化的差异数据。实际上，Git 更像是把变化的文件作快照后，记录在一个微型的文件系统中。每次提交更新时，它会纵览一遍所有文件的指纹信息并对文件作一快照，然后保存一个指向这次快照 的索引。为提高性能，若文件没有变化，Git 不会再次保存，而只对上次保存的快照作一链接。Git 的工作方式就像图 1-5 所示。</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-start5.png" title="Git详解之一：Git起步" target="_blank"><img src="&quot;Git详解之一：Git起步&quot;" alt="Git详解之一：Git起步"></a>
图 1-5. Git 保存每次更新时的文件快照</p>
<p>这是 Git 同其他系统的重要区别。它完全颠覆了传统版本控制的套路，并对各个环节的实现方式作了新的设计。Git 更像是个小型的文件系统，但它同时还提供了许多以此为基础的超强工具，而不只是一个简单的 VCS。稍后在第三章讨论 Git 分支管理的时候，我们会再看看这样的设计究竟会带来哪些好处。</p>
<p><strong>近乎所有操作都是本地执行</strong></p>
<p>在 Git 中的绝大多数操作都只需要访问本地文件和资源，不用连网。但如果用 CVCS 的话，差不多所有操作都需要连接网络。因为 Git 在本地磁盘上就保存着所有当前项目的历史更新，所以处理起来速度飞快。</p>
<p>举个例子，如果要浏览项目的历史更新摘要，Git 不用跑到外面的服务器上去取数据回来，而直接从本地数据库读取后展示给你看。所以任何时候你都可以马上翻阅，无需等待。如果想要看当前版本的文件和一个月 前的版本之间有何差异，Git 会取出一个月前的快照和当前文件作一次差异运算，而不用请求远程服务器来做这件事，或是把老版本的文件拉到本地来作比较。</p>
<p>用 CVCS 的话，没有网络或者断开 VPN 你就无法做任何事情。但用 Git 的话，就算你在飞机或者火车上，都可以非常愉快地频繁提交更新，等到了有网络的时候再上传到远程仓库。同样，在回家的路上，不用连接 VPN 你也可以继续工作。换作其他版本控制系统，这么做几乎不可能，抑或非常麻烦。比如 Perforce，如果不连到服务器，几乎什么都做不了（译注：默认无法发出命令</p>
<p>p4 edit file
 开始编辑文件，因为 Perforce 需要联网通知系统声明该文件正在被谁修订。但实际上手工修改文件权限可以绕过这个限制，只是完成后还是无法提交更新。）；如果是 Subversion 或 CVS，虽然可以编辑文件，但无法提交更新，因为数据库在网络上。看上去好像这些都不是什么大问题，但实际体验过之后，你就会惊喜地发现，这其实是会带来很大不同的。</p>
<p><strong>时刻保持数据完整性</strong></p>
<p>在保存到 Git 之前，所有数据都要进行内容的校验和（checksum）计算，并将此结果作为数据的唯一标识和索引。换句话说，不可能在你修改了文件或目录之后，Git 一无所知。这项特性作为 Git 的设计哲学，建在整体架构的最底层。所以如果文件在传输时变得不完整，或者磁盘损坏导致文件数据缺失，Git 都能立即察觉。</p>
<p>Git 使用 SHA-1 算法计算数据的校验和，通过对文件的内容或目录的结构计算出一个 SHA-1 哈希值，作为指纹字符串。该字串由 40 个十六进制字符（0-9 及 a-f）组成，看起来就像是：
124b9da6552252987aa493b52f8696cd6d3b00373</p>
<p>Git 的工作完全依赖于这类指纹字串，所以你会经常看到这样的哈希值。实际上，所有保存在 Git 数据库中的东西都是用此哈希值来作索引的，而不是靠文件名。</p>
<p><strong>多数操作仅添加数据</strong></p>
<p>常用的 Git 操作大多仅仅是把数据添加到数据库。因为任何一种不可逆的操作，比如删除数据，都会使回退或重现历史版本变得困难重重。在别的 VCS 中，若还未提交更新，就有可能丢失或者混淆一些修改的内容，但在 Git 里，一旦提交快照之后就完全不用担心丢失数据，特别是养成定期推送到其他仓库的习惯的话。</p>
<p>这种高可靠性令我们的开发工作安心不少，尽管去做各种试验性的尝试好了，再怎样也不会弄丢数据。至于 Git 内部究竟是如何保存和恢复数据的，我们会在第九章讨论 Git 内部原理时再作详述。</p>
<p><strong>文件的三种状态</strong></p>
<p>好，现在请注意，接下来要讲的概念非常重要。对于任何一个文件，在 Git 内都只有三种状态：已提交（committed），已修改（modified）和已暂存（staged）。已提交表示该文件已经被安全地保存在本地数据库 中了；已修改表示修改了某个文件，但还没有提交保存；已暂存表示把已修改的文件放在下次提交时要保存的清单中。</p>
<p>由此我们看到 Git 管理项目时，文件流转的三个工作区域：Git 的工作目录，暂存区域，以及本地仓库。</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-start6.png" title="Git详解之一：Git起步" target="_blank"><img src="&quot;Git详解之一：Git起步&quot;" alt="Git详解之一：Git起步"></a></p>
<p>图 1-6. 工作目录，暂存区域，以及本地仓库</p>
<p>每个项目都有一个 Git 目录（译注：如果 </p>
<p>git clone
 出来的话，就是其中 </p>
<p>.git
 的目录；如果</p>
<p>git clone --bare
 的话，新建的目录本身就是 Git 目录。），它是 Git 用来保存元数据和对象数据库的地方。该目录非常重要，每次克隆镜像仓库的时候，实际拷贝的就是这个目录里面的数据。</p>
<p>从项目中取出某个版本的所有文件和目录，用以开始后续工作的叫做工作目录。这些文件实际上都是从 Git 目录中的压缩对象数据库中提取出来的，接下来就可以在工作目录中对这些文件进行编辑。</p>
<p>所谓的暂存区域只不过是个简单的文件，一般都放在 Git 目录中。有时候人们会把这个文件叫做索引文件，不过标准说法还是叫暂存区域。</p>
<p>基本的 Git 工作流程如下：</p>
<ol>
<li>在工作目录中修改某些文件。 2. 对修改后的文件进行快照，然后保存到暂存区域。 3. 提交更新，将保存在暂存区域的文件快照永久转储到 Git 目录中。</li>
</ol>
<p>所以，我们可以从文件所处的位置来判断状态：如果是 Git 目录中保存着的特定版本文件，就属于已提交状态；如果作了修改并已放入暂存区域，就属于已暂存状态；如果自上次取出后，作了修改但还没有放到暂存区域，就 是已修改状态。到第二章的时候，我们会进一步了解其中细节，并学会如何根据文件状态实施后续操作，以及怎样跳过暂存直接提交。</p>
<p><strong>1.4 安装 Git</strong></p>
<p>是时候动手尝试下 Git 了，不过得先安装好它。有许多种安装方式，主要分为两种，一种是通过编译源代码来安装；另一种是使用为特定平台预编译好的安装包。</p>
<p><strong>从源代码安装</strong></p>
<p>若是条件允许，从源代码安装有很多好处，至少可以安装最新的版本。Git 的每个版本都在不断尝试改进用户体验，所以能通过源代码自己编译安装最新版本就再好不过了。有些 Linux 版本自带的安装包更新起来并不及时，所以除非你在用最新的 distro 或者 backports，那么从源代码安装其实该算是最佳选择。</p>
<p>Git 的工作需要调用 curl，zlib，openssl，expat，libiconv 等库的代码，所以需要先安装这些依赖工具。在有 yum 的系统上（比如 Fedora）或者有 apt-get 的系统上（比如 Debian 体系），可以用下面的命令安装：
1</p>
<p>2
3</p>
<p>4
5$ yum</p>
<p>install</p>
<p>curl-devel expat-devel gettext-devel \</p>
<p>openssl-devel zlib-devel</p>
<p>$ apt-get</p>
<p>install</p>
<p>libcurl4-gnutls-dev libexpat1-dev gettext \</p>
<p>libz-dev libssl-dev</p>
<p>之后，从下面的 Git 官方站点下载最新版本源代码：</p>
<p>1http:</p>
<p>//git-scm</p>
<p>.com</p>
<p>/download</p>
<p>然后编译并安装：</p>
<p>1</p>
<p>2
3</p>
<p>4
$</p>
<p>tar</p>
<p>-zxf git-1.7.2.2.</p>
<p>tar</p>
<p>.gz</p>
<p>$</p>
<p>cd</p>
<p>git-1.7.2.2
$</p>
<p>make</p>
<p>prefix=</p>
<p>/usr/local</p>
<p>all</p>
<p>$</p>
<p>sudo</p>
<p>make</p>
<p>prefix=</p>
<p>/usr/local</p>
<p>install</p>
<p>现在已经可以用 </p>
<p>git
 命令了，用 </p>
<p>git
 把 Git 项目仓库克隆到本地，以便日后随时更新：</p>
<p>1$ git clone git:</p>
<p>//git</p>
<p>.kernel.org</p>
<p>/pub/scm/git/git</p>
<p>.git</p>
<p><strong>在 Linux 上安装</strong></p>
<p>如果要在 Linux 上安装预编译好的 Git 二进制安装包，可以直接用系统提供的包管理工具。在 Fedora 上用 yum 安装：
1$ yum</p>
<p>install</p>
<p>git-core</p>
<p>在 Ubuntu 这类 Debian 体系的系统上，可以用 apt-get 安装：</p>
<p>1$ apt-get</p>
<p>install</p>
<p>git-core</p>
<p><strong>在 Mac 上安装</strong></p>
<p>在 Mac 上安装 Git 有两种方式。最容易的当属使用图形化的 Git 安装工具，界面如图 1-7，下载地址在：
<a href="http://code.google.com/p/git-osx-installer" target="_blank">http://code.google.com/p/git-osx-installer</a></p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-start7.png" title="Git详解之一：Git起步" target="_blank"><img src="&quot;Git详解之一：Git起步&quot;" alt="Git详解之一：Git起步"></a>
图 1-7. Git OS X 安装工具</p>
<p>另一种是通过 MacPorts (</p>
<p><a href="http://www.macports.org" target="_blank">http://www.macports.org</a>
) 安装。如果已经装好了 MacPorts，用下面的命令安装 Git：
1$</p>
<p>sudo</p>
<p>port</p>
<p>install</p>
<p>git-core +svn +doc +bash_completion +gitweb</p>
<p>这种方式就不需要再自己安装依赖库了，Macports 会帮你<a href="http://www.amazon.cn/gp/product/B007XPTAIS/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;tag=vastwork-23&amp;linkCode=as2&amp;camp=536&amp;creative=3200&amp;creativeASIN=B007XPTAIS" title="搞定(套装共3册) " target="_blank">搞定</a>这些麻烦事。一般上面列出的安装选项已经够用，要是你想用 Git 连接 Subversion 的代码仓库，还可以加上 +svn 选项，具体将在第八章作介绍。（译注：还有一种是使用 homebrew（</p>
<p><a href="https://[GitHub](http://blog.jobbole.com/6492/" target="_blank">https://[GitHub](http://blog.jobbole.com/6492/</a> &quot;GitHub如何运作：时间并不决定一切&quot;).com/mxcl/homebrew
）：</p>
<p>brew install git
。）</p>
<p><strong>在 Windows 上安装</strong></p>
<p>在 Windows 上安装 Git 同样轻松，有个叫做 msysGit 的项目提供了安装包，可以到 Google Code 的页面上下载 exe 安装文件并运行：
1http:</p>
<p>//code</p>
<p>.google.com</p>
<p>/p/msysgit</p>
<p>完成安装之后，就可以使用命令行的 </p>
<p>git
 工具（已经自带了 ssh 客户端）了，另外还有一个图形界面的 Git 项目管理工具。</p>
<p><strong>1.5 初次运行 Git 前的配置</strong></p>
<p>一般在新的系统上，我们都需要先配置下自己的 Git 工作环境。配置工作只需一次，以后升级时还会沿用现在的配置。当然，如果需要，你随时可以用相同的命令修改已有的配置。</p>
<p>Git 提供了一个叫做 git config 的工具（译注：实际是 </p>
<p>git-config
 命令，只不过可以通过 </p>
<p>git
 加一个名字来呼叫此命令。），专门用来配置或读取相应的工作环境变量。而正是由这些环境变量，决定了 Git 在各个环节的具体工作方式和行为。这些变量可以存放在以下三个不同的地方：</p>
<p>●/etc/gitconfig
 文件：系统中对所有用户都普遍适用的配置。若使用 </p>
<p>git config
 时用</p>
<p>--system
 选项，读写的就是这个文件。</p>
<p>●~/.gitconfig
 文件：用户目录下的配置文件只适用于该用户。若使用 </p>
<p>git config
 时用</p>
<p>--global
 选项，读写的就是这个文件。</p>
<p>●当前项目的 git 目录中的配置文件（也就是工作目录中的 </p>
<p>.git/config
 文件）：这里的配置仅仅针对当前项目有效。每一个级别的配置都会覆盖上层的相同配置，所以</p>
<p>.git/config
 里的配置会覆盖</p>
<p>/etc/gitconfig
 中的同名变量。</p>
<p>在 Windows 系统上，Git 会找寻用户主目录下的 </p>
<p>.gitconfig
 文件。主目录即 </p>
<p>$HOME
 变量指定的目录，一般都是</p>
<p>C:\Documents and Settings\$USER
。此外，Git 还会尝试找寻</p>
<p>/etc/gitconfig
 文件，只不过看当初 Git 装在什么目录，就以此作为根目录来定位。</p>
<p><strong>用户信息</strong></p>
<p>第一个要配置的是你个人的用户名称和电子邮件地址。这两条配置很重要，每次 Git 提交时都会引用这两条信息，说明是谁提交了更新，所以会随更新内容一起被永久纳入历史记录：
1</p>
<p>2
$ git config --global user.name</p>
<p>&quot;John Doe&quot;</p>
<p>$ git config --global user.email johndoe@ example.com</p>
<p>如果用了 </p>
<p>--global
 选项，那么更改的配置文件就是位于你用户主目录下的那个，以后你所有的项目都会默认使用这里配置的用户信息。如果要在某个特定的项目中使用其他名字或者电邮，只要去掉</p>
<p>--global
 选项重新配置即可，新的设定保存在当前项目的</p>
<p>.git/config
 文件里。</p>
<p><strong>文本编辑器</strong></p>
<p>接下来要设置的是默认使用的文本编辑器。Git 需要你输入一些额外消息的时候，会自动调用一个外部文本编辑器给你用。默认会使用操作系统指定的默认编辑器，一般可能会是 Vi 或者 Vim。如果你有其他偏好，比如 Emacs 的话，可以重新设置：
1$ git config --global core.editor emacs</p>
<p><strong>差异分析工具</strong></p>
<p>还有一个比较常用的是，在解决合并冲突时使用哪种差异分析工具。比如要改用 vimdiff 的话：
1$ git config --global merge.tool vimdiff</p>
<p>Git 可以理解 kdiff3，tkdiff，meld，xxdiff，emerge，vimdiff，gvimdiff，ecmerge，和 opendiff 等合并工具的输出信息。当然，你也可以指定使用自己开发的工具，具体怎么做可以参阅第七章。</p>
<p><strong>查看配置信息</strong></p>
<p>要检查已有的配置信息，可以使用 </p>
<p>git config --list
 命令：
1</p>
<p>2
3</p>
<p>4
5</p>
<p>6
7</p>
<p>8
$ git config --list</p>
<p>user.name=Scott Chacon
user.email=schacon@ gmail.com</p>
<p>color.status=auto
color.branch=auto</p>
<p>color.interactive=auto
color.</p>
<p>diff</p>
<p>=auto</p>
<p>...</p>
<p>有时候会看到重复的变量名，那就说明它们来自不同的配置文件（比如 </p>
<p>/etc/gitconfig
 和 </p>
<p>~/.gitconfig
），不过最终 Git 实际采用的是最后一个。</p>
<p>也可以直接查阅某个环境变量的设定，只要把特定的名字跟在后面即可，像这样：
1$ git config user.name Scott Chacon</p>
<p><strong>1.6 获取帮助</strong></p>
<p>想了解 Git 的各式工具该怎么用，可以阅读它们的使用帮助，方法有三：
1</p>
<p>2
3</p>
<p>4
5</p>
<p>6
$ git help</p>
<p>$ git</p>
<p>--help</p>
<p>$</p>
<p>man</p>
<p>git-</p>
<p>比如，要学习 config 命令可以怎么用，运行：</p>
<p>1$ git help config</p>
<p>我们随时都可以浏览这些帮助信息而无需连网。不过，要是你觉得还不够，可以到 Frenode IRC 服务器（irc.freenode.net）上的 </p>
<p>/#git
 或 </p>
<p>/#github
 频道寻求他人帮助。这两个频道上总有着上百号人，大多都有着丰富的 git 知识，并且乐于助人。</p>
<hr>
<p><strong>1.7 小结</strong></p>
<p>至此，你该对 Git 有了点基本认识，包括它和以前你使用的 CVCS 之间的差别。现在，在你的系统上应该已经装好了 Git，设置了自己的名字和电邮。接下来让我们继续学习 Git 的基础知识。</p>
<p><img src="&quot;6 votes, average: 5.00 out of 5&quot;" alt="6 votes, average: 5.00 out of 5"><img src="&quot;6 votes, average: 5.00 out of 5&quot;" alt="6 votes, average: 5.00 out of 5"><img src="&quot;6 votes, average: 5.00 out of 5&quot;" alt="6 votes, average: 5.00 out of 5"><img src="&quot;6 votes, average: 5.00 out of 5&quot;" alt="6 votes, average: 5.00 out of 5"><img src="&quot;6 votes, average: 5.00 out of 5&quot;" alt="6 votes, average: 5.00 out of 5"> (<strong>*6</strong> 个评分，平均: <strong>5.00*</strong>)</p>
<p><img src="&quot;Loading ...&quot;" alt="Loading ..."> Loading ...</p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/git&github/">git&github</a></li></span></span> | <span class="tags">Tagged <a href="/tags/git&github/" class="label label-primary">git&github</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:43"datetime="2014-03-07 09:54:43"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-gitgithub--Git详解之一：Git起步/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-gitgithub--Git详解之一：Git起步" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--虚拟机随谈（一）：解释器，树遍历解释器，基于栈与基于寄存器，大杂烩/">虚拟机随谈（一）：解释器，树遍历解释器，基于栈与基于寄存器，大杂烩</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:42.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--虚拟机随谈（一）：解释器，树遍历解释器，基于栈与基于寄存器，大杂烩/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-">虚拟机随谈（一）：解释器，树遍历解释器，基于栈与基于寄存器，大杂烩</h1>
<p>（Disclaimer：如果需要转载请先与我联系；文中图片请不要直接链接
作者：<a href="http://weibo.com/rednaxelafx" target="_blank">@RednaxelaFX</a> -&gt; <a href="http://rednaxelafx.iteye.com/" target="_blank"><a href="http://rednaxelafx.iteye.com">http://rednaxelafx.iteye.com</a></a>）
大前天收到一条PM：
引用</p>
<p>你好，很冒昧的向你发短消息，我现在在看JS引擎，能过看博客发现你对js engine很了解，我想请教一下你 基于栈的解析器与基于寄存器的解析器有什么同，javascriptcore是基于寄存器的，V8是基于栈的，能不能说一下这两者有什么一样吗？能推荐一点资料吗？谢谢。
我刚收到的时候很兴奋，就开始写回复。写啊写发觉已经比我平时发的帖还要长了，想着干脆把回复直接发出来好了。于是下面就是回复：
你好 ^ ^ 很抱歉拖了这么久才回复。码字和画图太耗时间了。
别说冒昧了，我只是个普通的刚毕业的学生而已，担当不起啊 =<em>=||||
而且我也不敢说“很”了解，只是有所接触而已。很高兴有人来一起讨论JavaScript引擎的设计与实现，总觉得身边对这个有兴趣的人不多，或者是很少冒出来讨论。如果你发个帖或者blog来讨论这方面的内容我也会很感兴趣的～
想拿出几点来讨论一下。上面提出的问题我希望能够一一给予回答，不过首先得做些铺垫。
另外先提一点：JavaScriptCore从SquirrelFish版开始是“基于寄存器”的，V8则不适合用“基于栈”或者“基于寄存器”的说法来描述。
<strong>1、解析器与解释器</strong>
解析器是parser，而解释器是interpreter。两者不是同一样东西，不应该混用。
前者是编译器/解释器的重要组成部分，也可以用在IDE之类的地方；其主要作用是进行语法分析，提取出句子的结构。广义来说输入一般是程序的源码，输出一般是语法树（syntax tree，也叫parse tree等）或抽象语法树（abstract syntax tree，AST）。进一步剥开来，广义的解析器里一般会有扫描器（scanner，也叫tokenizer或者lexical analyzer，词法分析器），以及狭义的解析器（parser，也叫syntax analyzer，语法分析器）。扫描器的输入一般是文本，经过词法分析，输出是将文本切割为单词的流。狭义的解析器输入是单词的流，经过语法分析，输出是语法树或者精简过的AST。
（在一些编译器/解释器中，解析也可能与后续的语义分析、代码生成或解释执行等步骤融合在一起，不一定真的会构造出完整的语法树。但概念上说解析器就是用来抽取句子结构用的，而语法树就是表示句子结构的方式。关于边解析边解释执行的例子，可以看看<a href="http://rednaxelafx.iteye.com/blog/472113" target="_blank">这帖</a>的计算器。）
举例：将i = a + b /* c作为源代码输入到解析器里，则广义上的解析器的工作流程如下图：
<img src="" alt="">
其中词法分析由扫描器完成，语法分析由狭义的解析器完成。
（嗯，说来其实“解析器”这词还是按狭义用法比较准确。把扫描器和解析器合起来叫解析器总觉得怪怪的，但不少人这么用，这里就将就下吧 =</em>=
不过近来“<a href="http://en.wikipedia.org/wiki/Scannerless_parsing" target="_blank">scannerless parsing</a>”也挺流行的：不区分词法分析与语法分析，没有单独的扫描器，直接用解析器从源码生成语法树。这倒整个就是解析器了，没狭不狭义的问题）
后者则是实现程序执行的一种实现方式，与编译器相对。它直接实现程序源码的语义，输入是程序源码，输出则是执行源码得到的计算结果；编译器的输入与解释器相同，而输出是用别的语言实现了输入源码的语义的程序。通常编译器的输入语言比输出语言高级，但不一定；也有输入输出是同种语言的情况，此时编译器很可能主要用于优化代码。
举例：把同样的源码分别输入到编译器与解释器中，得到的输出不同：
<img src="" alt="">
值得留意的是，编译器生成出来的代码执行后的结果应该跟解释器输出的结果一样——它们都应该实现源码所指定的语义。
在很多地方都看到解析器与解释器两个不同的东西被混为一谈，感到十分无奈。
最近某本引起很多关注的书便在开篇给读者们当头一棒，介绍了“<a href="http://www.fecit.com.cn/%E7%AC%AC1%E7%AB%A0_%E4%B8%8E%E5%88%9D%E5%AD%A6%E8%80%85%E8%B0%88%E8%B0%88JavaScript%E5%AD%A6%E4%B9%A0.pdf" target="_blank">JavaScript解析机制</a>”。“编译”和“预处理”也顺带混为一谈了，还有“预编译” 0_0
我一直以为“预编译”应该是<a href="http://en.wikipedia.org/wiki/AOT_compiler" target="_blank">ahead-of-time compilation</a>的翻译，是与“即时编译”（just-in-time compilation，JIT）相对的概念。另外就是PCH（precompile header）这种用法，把以前的编译结果缓存下来称为“预编译”。把AOT、PCH跟“预处理”（<a href="http://en.wikipedia.org/wiki/Preprocessor" target="_blank">preprocess</a>）混为一谈真是诡异。算了，我还是不要淌这浑水的好……打住。
<strong>2、“解释器”到底是什么？“解释型语言”呢？</strong>
很多资料会说，Python、Ruby、JavaScript都是“解释型语言”，是通过解释器来实现的。这么说其实很容易引起误解：语言一般只会定义其抽象语义，而不会强制性要求采用某种实现方式。
例如说C一般被认为是“编译型语言”，但C的解释器也是存在的，例如<a href="http://www.softintegration.com/" target="_blank">Ch</a>。同样，C++也有解释器版本的实现，例如<a href="http://root.cern.ch/drupal/content/cint" target="_blank">Cint</a>。
一般被称为“解释型语言”的是主流实现为解释器的语言，但并不是说它就无法编译。例如说经常被认为是“解释型语言”的<a href="http://schemers.org/" target="_blank">Scheme</a>就有好几种编译器实现，其中率先支持<a href="http://www.r6rs.org/" target="_blank">R6RS</a>规范的大部分内容的是<a href="http://ikarus-scheme.org/" target="_blank">Ikarus</a>，支持在x86上编译Scheme；它最终不是生成某种虚拟机的字节码，而是直接生成x86机器码。
解释器就是个黑箱，输入是源码，输出就是输入程序的执行结果，对用户来说中间没有独立的“编译”步骤。这非常抽象，内部是怎么实现的都没关系，只要能实现语义就行。你可以写一个C语言的解释器，里面只是先用普通的C编译器把源码编译为in-memory image，然后直接调用那个image去得到运行结果；用户拿过去，发现直接输入源码可以得到源程序对应的运行结果就满足需求了，无需在意解释器这个“黑箱子”里到底是什么。
实际上很多解释器内部是以“编译器+虚拟机”的方式来实现的，先通过编译器将源码转换为AST或者字节码，然后由虚拟机去完成实际的执行。所谓“解释型语言”并不是不用编译，而只是不需要用户显式去使用编译器得到可执行代码而已。
那么虚拟机（<a href="http://en.wikipedia.org/wiki/Virtual_machine" target="_blank">virtual machine</a>，VM）又是什么？在许多不同的场合，VM有着不同的意义。如果上下文是Java、Python这类语言，那么一般指的是高级语言虚拟机（high-level language virtual machine，HLL VM），其意义是实现高级语言的语义。VM既然被称为“机器”，一般认为输入是满足某种指令集架构（<a href="http://en.wikipedia.org/wiki/Instruction_set" target="_blank">instruction set architecture</a>，ISA）的指令序列，中间转换为目标ISA的指令序列并加以执行，输出为程序的执行结果的，就是VM。源与目标ISA可以是同一种，这是所谓same-ISA VM。
前面提到解释器中的编译器的输出可能是AST，也可能是字节码之类的指令序列；一般会把执行后者的程序称为VM，而执行前者的还是笼统称为解释器或者树遍历式解释器（tree-walking interpreter）。这只是种习惯而已，并没有多少确凿的依据。只不过线性（相对于树形）的指令序列看起来更像一般真正机器会执行的指令序列而已。
其实我觉得把执行AST的也叫VM也没啥大问题。如果认同这个观点，那么把<a href="http://rednaxelafx.iteye.com/blog/241430" target="_blank">DLR</a>看作一种VM也就可以接受了——它的“指令集”就是树形的Expression Tree。
VM并不是神奇的就能执行代码了，它也得采用某种方式去实现输入程序的语义，并且同样有几种选择：“编译”，例如微软的.NET中的CLR；“解释”，例如CPython、CRuby 1.9，许多老的JavaScript引擎等；也有介于两者之间的混合式，例如Sun的JVM，<a href="http://en.wikipedia.org/wiki/HotSpot" target="_blank">HotSpot</a>。如果采用编译方式，VM会把输入的指令先转换为某种能被底下的系统直接执行的形式（一般就是native code），然后再执行之；如果采用解释方式，则VM会把输入的指令逐条直接执行。
换个角度说，我觉得采用编译和解释方式实现虚拟机最大的区别就在于是否存下目标代码：编译的话会把输入的源程序以某种单位（例如<a href="http://en.wikipedia.org/wiki/Basic_block" target="_blank">基本块</a>/函数/方法/trace等）翻译生成为目标代码，并存下来（无论是存在内存中还是磁盘上，无所谓），后续执行可以复用之；解释的话则是把源程序中的指令逐条解释，不生成也不存下目标代码，后续执行没有多少可复用的信息。有些稍微先进一点的解释器可能会优化输入的源程序，把满足某些模式的指令序列合并为“超级指令”；这么做就是朝着编译的方向推进。后面讲到解释器的演化时再讨论超级指令吧。
如果一种语言的主流实现是解释器，其内部是编译器+虚拟机，而虚拟机又是采用解释方式实现的，或者内部实现是编译器+树遍历解释器，那它就是名副其实的“解释型语言”。如果内部用的虚拟机是用编译方式实现的，其实跟普遍印象中的“解释器”还是挺不同的……
可以举这样一个例子：ActionScript 3，一般都被认为是“解释型语言”对吧？但这种观点到底是把FlashPlayer整体看成一个解释器，因而AS3是“解释型语言”呢？还是认为FlashPlayer中的虚拟机采用解释执行方案，因而AS3是“解释型语言”呢？
其实Flash或Flex等从AS3生成出来的SWF文件里就包含有AS字节码（ActionScript Byte Code，ABC）。等到FlashPlayer去执行SWF文件，或者说等到AVM2（ActionScript Virtual Machine 2）去执行ABC时，又有解释器和JIT编译器两种实现。这种需要让用户显式进行编译步骤的语言，到底是不是“解释型语言”呢？呵呵。所以我一直觉得“编译型语言”跟“解释型语言”的说法太模糊，不太好。
有兴趣想体验一下从命令行编译“裸”的AS3文件得到ABC文件，再从命令行调用AVM2去执行ABC文件的同学，可以从<a href="http://rednaxelafx.iteye.com/blog/196278" target="_blank">这帖</a>下载我之前从源码编译出来的AVM2，自己玩玩看。例如说要编译一个名为test.as的文件，用下列命令：
Command prompt代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>java -jar asc.jar -import builtin.abc -import toplevel.abc test.as  </li>
</ol>
<p>java -jar asc.jar -import builtin.abc -import toplevel.abc test.as
就是用ASC将test.as编译，得到test.abc。接着用：
Command prompt代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>avmplus test.abc  </li>
</ol>
<p>avmplus test.abc
就是用AVM2去执行程序了。很生动的体现出“编译器+虚拟机”的实现方式。
这个“裸”的AVM2没有带Flash或Flex的类库，能用的函数和类都有限。不过AS3语言实现是完整的。可以用print()函数来向标准输出流写东西。
Well……其实写Java程序不也是这样么？现在也确实还有很多人把Java称为“解释型语言”，完全无视Java代码通常是经过显式编译步骤才得到.class文件，而有些JVM是采用纯JIT编译方式实现的，内部没解释器，例如JRockit、<a href="https://wikis.oracle.com/display/MaxineVM/Home" target="_blank">Maxine VM</a>和<a href="http://jikesrvm.org/" target="_blank">Jikes RVM</a>。我愈发感到“解释型语言”是个应该避开的用语 =_=
关于虚拟机，有本很好的书绝对值得一读，《虚拟机——系统与进程的通用平台》（Virtual Machines: Versatile Platforms for Systems and Processes）。国内有影印版也有中文版，我是读了影印版，不太清楚中文版的翻译质量如何。据说翻译得还行，我无法印证。
<strong>3、基于栈与基于寄存器的指令集架构</strong>
用C的语法来写这么一个语句：
C代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>a = b + c;  </li>
</ol>
<p>a = b + c;
如果把它变成这种形式：
add a, b, c
那看起来就更像机器指令了，对吧？这种就是所谓“三地址指令”（3-address instruction），一般形式为：
op dest, src1, src2
许多操作都是二元运算+赋值。三地址指令正好可以指定两个源和一个目标，能非常灵活的支持二元操作与赋值的组合。ARM处理器的主要指令集就是三地址形式的。
C里要是这样写的话：
C代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>a += b;  </li>
</ol>
<p>a += b;
变成:
add a, b
这就是所谓“二地址指令”，一般形式为：
op dest, src
它要支持二元操作，就只能把其中一个源同时也作为目标。上面的add a, b在执行过后，就会破坏a原有的值，而b的值保持不变。x86系列的处理器就是二地址形式的。
上面提到的三地址与二地址形式的指令集，一般就是通过“基于寄存器的架构”来实现的。例如典型的RISC架构会要求除load和store以外，其它用于运算的指令的源与目标都要是寄存器。
显然，指令集可以是任意“n地址”的，n属于自然数。那么一地址形式的指令集是怎样的呢？
想像一下这样一组指令序列：
add 5
sub 3
这只指定了操作的源，那目标是什么？一般来说，这种运算的目标是被称为“累加器”（accumulator）的专用寄存器，所有运算都靠更新累加器的状态来完成。那么上面两条指令用C来写就类似：
C代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>acc += 5;  </li>
<li>acc -= 3;  </li>
</ol>
<p>acc += 5;</p>
<p>acc -= 3;
只不过acc是“隐藏”的目标。基于累加器的架构近来比较少见了，在很老的机器上繁荣过一段时间。
那“n地址”的n如果是0的话呢？
看这样一段Java字节码：
Java bytecode代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>iconst_1  </li>
<li>iconst_2  </li>
<li>iadd  </li>
<li>istore_0  </li>
</ol>
<p>iconst_1</p>
<p>iconst_2
iadd</p>
<p>istore_0
注意那个iadd（表示整型加法）指令并没有任何参数。连源都无法指定了，零地址指令有什么用？？
零地址意味着源与目标都是隐含参数，其实现依赖于一种常见的数据结构——没错，就是栈。上面的iconst_1、iconst_2两条指令，分别向一个叫做“求值栈”（evaluation stack，也叫做operand stack“操作数栈”或者expression stack“表达式栈”）的地方压入整型常量1、2。iadd指令则从求值栈顶弹出2个值，将值相加，然后把结果压回到栈顶。istore_0指令从求值栈顶弹出一个值，并将值保存到局部变量区的第一个位置（slot 0）。
零地址形式的指令集一般就是通过“基于栈的架构”来实现的。请一定要注意，这个栈是指“求值栈”，而不是与系统调用栈（system call stack，或者就叫system stack）。千万别弄混了。有些虚拟机把求值栈实现在系统调用栈上，但两者概念上不是一个东西。
由于指令的源与目标都是隐含的，零地址指令的“密度”可以非常高——可以用更少空间放下更多条指令。因此在空间紧缺的环境中，零地址指令是种可取的设计。但零地址指令要完成一件事情，一般会比二地址或者三地址指令许多更多条指令。上面Java字节码做的加法，如果用x86指令两条就能完成了：
X86 asm代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>mov  eax, 1  </li>
<li>add  eax, 2  </li>
</ol>
<p>mov  eax, 1</p>
<p>add  eax, 2
（好吧我犯规了，istore<em>0对应的保存我没写。但假如局部变量比较少的话也不必把EAX的值保存（“溢出”，register spilling）到调用栈上，就这样吧 =</em>=
其实就算把结果保存到栈上也就是多一条指令而已……）
一些比较老的解释器，例如<a href="http://www.ruby-lang.org/" target="_blank">CRuby</a>在1.9引入<a href="http://www.atdot.net/yarv/" target="_blank">YARV</a>作为新的VM之前的解释器，还有SquirrleFish之前的老JavaScriptCore以及它的前身KJS，它们内部是树遍历式解释器；解释器递归遍历树，树的每个节点的操作依赖于解释其各个子节点返回的值。这种解释器里没有所谓的求值栈，也没有所谓的虚拟寄存器，所以不适合以“基于栈”或“基于寄存器”去描述。
而像V8那样直接编译JavaScript生成机器码，而不通过中间的字节码的中间表示的JavaScript引擎，它内部有虚拟寄存器的概念，但那只是普通native编译器的正常组成部分。我觉得也不应该用“基于栈”或“基于寄存器”去描述它。
V8在内部也用了“求值栈”（在V8里具体叫“表达式栈”）的概念来简化生成代码的过程，在编译过程中进行“抽象解释”，使用所谓“虚拟栈帧”来记录局部变量与求值栈的状态；但在真正生成代码的时候会做窥孔优化，消除冗余的push/pop，将许多对求值栈的操作转变为对寄存器的操作，以此提高代码质量。于是最终生成出来的代码看起来就不像是基于栈的代码了。
关于JavaScript引擎的实现方式，下文会再提到。
<strong>4、基于栈与基于寄存器架构的VM，用哪个好？</strong>
如果是要模拟现有的处理器，那没什么可选的，原本处理器采用了什么架构就只能以它为源。但HLL VM的架构通常可以自由构造，有很大的选择余地。为什么许多主流HLL VM，诸如JVM、CLI、CPython、CRuby 1.9等，都采用了基于栈的架构呢？我觉得这有三个主要原因：
·实现简单
由于指令中不必显式指定源与目标，VM可以设计得很简单，不必考虑为临时变量分配空间的问题，求值过程中的临时数据存储都让求值栈包办就行。
更新：回帖中cscript指出了这句不太准确，应该是针对基于栈架构的指令集生成代码的编译器更容易实现，而不是VM更容易实现。
·该VM是为某类资源非常匮乏的硬件而设计的
这类硬件的存储器可能很小，每一字节的资源都要节省。零地址指令比其它形式的指令更紧凑，所以是个自然的选择。
·考虑到可移植性
处理器的特性各个不同：典型的CISC处理器的通用寄存器数量很少，例如32位的<a href="http://en.wikipedia.org/wiki/X86" target="_blank">x86</a>就只有8个32位通用寄存器（如果不算EBP和ESP那就是6个，现在一般都算上）；典型的RISC处理器的各种寄存器数量多一些，例如<a href="http://en.wikipedia.org/wiki/ARM_architecture" target="_blank">ARM</a>有16个32位通用寄存器，Sun的<a href="http://en.wikipedia.org/wiki/SPARC" target="_blank">SPARC</a>在一个寄存器窗口里则有24个通用寄存器（8 in，8 local，8 out）。
假如一个VM采用基于寄存器的架构（它接受的指令集大概就是二地址或者三地址形式的），为了高效执行，一般会希望能把源架构中的寄存器映射到实际机器上寄存器上。但是VM里有些很重要的辅助数据会经常被访问，例如一些VM会保存源指令序列的程序计数器（program counter，PC），为了效率，这些数据也得放在实际机器的寄存器里。如果源架构中寄存器的数量跟实际机器的一样，或者前者比后者更多，那源架构的寄存器就没办法都映射到实际机器的寄存器上；这样VM实现起来比较麻烦，与能够全部映射相比效率也会大打折扣。像Dalvik VM的解释器实现，就是把虚拟寄存器全部映射到栈帧（内存）里的，这跟把局部变量区与操作数栈都映射到内存里的JVM解释器实现相比实际区别不太大。
如果一个VM采用基于栈的架构，则无论在怎样的实际机器上，都很好实现——它的源架构里没有任何通用寄存器，所以实现VM时可以比较自由的分配实际机器的寄存器。于是这样的VM可移植性就比较高。作为优化，基于栈的VM可以用编译方式实现，“求值栈”实际上也可以由编译器映射到寄存器上，减轻数据移动的开销。
回到主题，基于栈与基于寄存器的架构，谁更快？看看现在的实际处理器，大多都是基于寄存器的架构，从侧面反映出它比基于栈的架构更优秀。
而对于VM来说，源架构的求值栈或者寄存器都可能是用实际机器的内存来模拟的，所以性能特性与实际硬件又有点不同。一般认为基于寄存器的架构对VM来说也是更快的，原因是：虽然零地址指令更紧凑，但完成操作需要更多的load/store指令，也意味着更多的指令分派（instruction dispatch）次数与内存访问次数；访问内存是执行速度的一个重要瓶颈，二地址或三地址指令虽然每条指令占的空间较多，但总体来说可以用更少的指令完成操作，指令分派与内存访问次数都较少。
这方面有篇被引用得很多的论文讲得比较清楚，<a href="http://www.usenix.org/events/vee05/full_papers/p153-yunhe.pdf" target="_blank">Virtual Machine Showdown: Stack Versus Registers</a>，是在VEE 2005发表的。VEE是Virtual Execution Environment的缩写，是ACM下SIGPLAN组织的一个会议，专门研讨虚拟机的设计与实现的。可以去找找这个会议往年的论文，很多都值得读。
<strong>5、树遍历解释器图解</strong>
在演示基于栈与基于寄存器的VM的例子前，先回头看看更原始的解释器形式。
前面提到解析器的时候用了i = a + b /<em> c的例子，现在让我们来看看由解析器生成的AST要是交给一个树遍历解释器，会如何被解释执行呢？
用文字说不够形象，还是看图吧：
<img src="" alt="">
这是对AST的后序遍历：假设有一个eval(Node n)函数，用于解释AST上的每个节点；在解释一个节点时如果依赖于子树的操作，则对子节点递归调用eval(Node n)，从这些递归调用的返回值获取需要的值（或副作用）——也就是说子节点都eval好了之后，父节点才能进行自己的eval——典型的后序遍历。
（话说，上图中节点左下角有蓝色标记的说明那是节点的“内在属性”。从<a href="http://en.wikipedia.org/wiki/Attribute_grammar" target="_blank">属性语法</a>的角度看，如果一个节点的某个属性的值只依赖于自身或子节点，则该属性被称为“综合属性”（synthesized attribute）；如果一个节点的某个属性只依赖于自身、父节点和兄弟节点，则该属性被称为“继承属性”（inherited attribute）。上图中节点右下角的红色标记都只依赖子节点来计算，显然是综合属性。）
SquirrelFish之前的JavaScriptCore、CRuby 1.9之前的CRuby就都是采用这种方式来解释执行的。
可能需要说明的：
·左值与右值
在源代码i = a + b /</em> c中，赋值符号左侧的i是一个标识符，表示一个变量，取的是变量的“左值”（也就是与变量i绑定的存储单元）；右侧的a、b、c虽然也是变量，但取的是它们的右值（也就是与变量绑定的存储单元内的值）。在许多编程语言中，左值与右值在语法上没有区别，它们实质的差异容易被忽视。一般来说左值可以作为右值使用，反之则不一定。例如数字1，它自身有值就是1，可以作为右值使用；但它没有与可赋值的存储单元相绑定，所以无法作为左值使用。
左值不一定只是简单的变量，还可以是数组元素或者结构体的域之类，可能由复杂的表达式所描述。因此左值也是需要计算的。
·优先级、结合性与求值顺序
这三个是不同的概念，却经常被混淆。通过AST来看就很容易理解：（假设源码是从左到右输入的）
所谓<strong>优先级</strong>，就是不同操作相邻出现时，AST节点与根的距离的关系。优先级高的操作会更远离根，优先级低的操作会更接近根。为什么？因为整棵AST是以后序遍历求值的，显然节点离根越远就越早被求值。
所谓<strong>结合性</strong>，就是当同类操作相邻出现时，操作的先后顺序同AST节点与根的距离的关系。如果是左结合，则先出现的操作对应的AST节点比后出现的操作的节点离根更远；换句话说，先出现的节点会是后出现节点的子节点。
所谓<strong>求值顺序</strong>，就是在遍历子节点时的顺序。对二元运算对应的节点来说，先遍历左子节点再遍历右子节点就是左结合，反之则是右结合。
这三个概念与运算的联系都很紧密，但实际描述的是不同的关系。前两者是解析器根据语法生成AST时就已经决定好的，后者则是解释执行或者生成代码而去遍历AST时决定的。
在没有副作用的环境中，给定优先级与结合性，则无论求值顺序是怎样的都能得到同样的结果；而在有副作用的环境中，求值顺序会影响结果。
赋值运算虽然是右结合的，但仍然可以用从左到右的求值顺序；事实上Java、C/#等许多语言都在规范里写明表达式的求值顺序是从左到右的。上面的例子中就先遍历的=的左侧，求得i的左值；再遍历=的右侧，得到表达式的值23；最后执行=自身，完成对i的赋值。
所以如果你要问：赋值在类似C的语言里明明是右结合的运算，为什么你先遍历左子树再遍历右子树？上面的说明应该能让你发现你把结合性与求值顺序混为一谈了。
看看Java从左到右求值顺序的例子：
Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>public class EvalOrderDemo {  </li>
<li>public static void main(String[] args) {  </li>
<li>int[] arr = new int[1];  </li>
<li>int a = 1;  </li>
<li>int b = 2;  </li>
<li>arr[0] = a + b;  </li>
<li>}  </li>
<li>}  </li>
</ol>
<p>public class EvalOrderDemo {</p>
<pre><code>public static void main(String[] args) {
    int[] arr = new int[1];

    int a = 1;
    int b = 2;

    arr[0] = a + b;
}
</code></pre><p>}
由javac编译，得到arr[0] = a + b对应的字节码是：
Java bytecode代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>// 左子树：数组下标  </li>
<li>// a[0]  </li>
<li>aload_1  </li>
<li>iconst_0  </li>
<li></li>
<li>// 右子树：加法  </li>
<li>// a  </li>
<li>iload_2  </li>
<li>// b  </li>
<li>iload_3  </li>
<li>// +  </li>
<li>iadd  </li>
<li></li>
<li>// 根节点：赋值  </li>
<li>iastore  </li>
</ol>
<p>// 左子树：数组下标</p>
<p>// a[0]
aload_1</p>
<p>iconst_0</p>
<p>// 右子树：加法
// a</p>
<p>iload_2
// b</p>
<p>iload_3
// +</p>
<p>iadd</p>
<p>// 根节点：赋值
iastore
<strong>6、从树遍历解释器进化为基于栈的字节码解释器的前端</strong>
如果你看到树形结构与后序遍历，并且知道后缀记法（或者逆波兰记法，<a href="http://en.wikipedia.org/wiki/Reverse_Polish_notation" target="_blank">reverse Polish notation</a>）的话，那敏锐的你或许已经察觉了：要解释执行AST，可以先通过后序遍历AST生成对应的后缀记法的操作序列，然后再解释执行该操作序列。这样就把树形结构压扁，成为了线性结构。
树遍历解释器对AST的求值其实隐式依赖于调用栈：eval(Node n)的递归调用关系是靠调用栈来维护的。后缀表达式的求值则通常显式依赖于一个栈，在遇到操作数时将其压入栈中，遇到运算时将合适数量的值从栈顶弹出进行运算，再将结果压回到栈上。这种描述看起来眼熟么？没错，后缀记法的求值中的核心数据结构就是前文提到过的“求值栈”（或者叫操作数栈，现在应该更好理解了）。后缀记法也就与基于栈的架构联系了起来：后者可以很方便的执行前者。同理，零地址指令也与树形结构联系了起来：可以通过一个栈方便的把零地址指令序列再转换回到树的形式。
Java字节码与Java源码联系紧密，前者可以看成后者的后缀记法。如果想在JVM上开发一种语义能直接映射到Java上的语言，那么编译器很好写：秘诀就是后序遍历AST。
那么让我们再来看看，同样是i = a + b /<em> c这段源码对应的AST，生成Java字节码的例子：
<img src="" alt="">
（假设a、b、c、i分别被分配到局部变量区的slot 0到slot 3）
能看出Java字节码与源码间的对应关系了么？
一个Java编译器的输入是Java源代码，输出是含有Java字节码的.class文件。它里面主要包含扫描器与解析器，语义分析器（包括类型检查器/类型推导器等），代码生成器等几大部分。上图所展示的就是代码生成器的工作。对Java编译器来说，代码生成就到字节码的层次就结束了；而对native编译器来说，这里刚到生成中间表示的部分，接下去是优化与最终的代码生成。
如果你对<a href="http://rednaxelafx.iteye.com/blog/382412" target="_blank">Python</a>、<a href="http://lifegoo.pluskid.org/upload/doc/yarv/yarv_iset.html" target="_blank">CRuby 1.9</a>之类有所了解，会发现它们的字节码跟Java字节码在“基于栈”的这一特征上非常相似。其实它们都是由“编译器+VM”构成的，概念上就像是Java编译器与JVM融为一体一般。
从这点看，Java与Python和Ruby可以说是一条船上的。虽说内部具体实现的显著差异使得先进的JVM比简单的JVM快很多，而JVM又普遍比Python和Ruby快很多。
当解释器中用于解释执行的中间代码是树形时，其中能被称为“编译器”的部分基本上就是解析器；中间代码是线性形式（如字节码）时，其中能被称为编译器的部分就包括上述的代码生成器部分，更接近于所谓“完整的编译器”；如果虚拟机是基于寄存器架构的，那么编译器里至少还得有虚拟寄存器分配器，又更接近“完整的编译器”了。
<em>*7、基于栈与基于寄存器架构的VM的一组图解</em></em>
要是拿两个分别实现了基于栈与基于寄存器架构、但没有直接联系的VM来对比，效果或许不会太好。现在恰巧有两者有紧密联系的例子——JVM与Dalvik VM。JVM的字节码主要是零地址形式的，概念上说JVM是基于栈的架构。Google Android平台上的应用程序的主要开发语言是Java，通过其中的<a href="http://en.wikipedia.org/wiki/Dalvik_virtual_machine" target="_blank">Dalvik VM</a>来运行Java程序。为了能正确实现语义，Dalvik VM的许多设计都考虑到与JVM的兼容性；但它却采用了基于寄存器的架构，其字节码主要是二地址/三地址混合形式的，乍一看可能让人纳闷。考虑到Android有明确的目标：面向移动设备，特别是最初要对ARM提供良好的支持。ARM9有16个32位通用寄存器，Dalvik VM的架构也常用16个虚拟寄存器（一样多……没办法把虚拟寄存器全部直接映射到硬件寄存器上了）；这样Dalvik VM就不用太顾虑可移植性的问题，优先考虑在ARM9上以高效的方式实现，发挥基于寄存器架构的优势。
Dalvik VM的主要设计者<a href="http://www.milk.com/home/danfuzz/" target="_blank">Dan Bornstein</a>在Google I/O 2008上做过一个<a href="http://sites.google.com/site/io/dalvik-vm-internals" target="_blank">关于Dalvik内部实现</a>的演讲；同一演讲也在Google Developer Day 2008 China和Japan等会议上重复过。这个演讲中Dan特别提到了Dalvik VM与JVM在字节码设计上的区别，指出Dalvik VM的字节码可以用更少指令条数、更少内存访问次数来完成操作。（看不到YouTube的请自行想办法）
眼见为实。要自己动手感受一下该例子，请先确保已经正确安装JDK 6，并从<a href="http://developer.android.com/sdk/" target="_blank">官网</a>获取Android SDK 1.6R1。连不上官网的也请自己想办法。
创建Demo.java文件，内容为：
Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>public class Demo {  </li>
<li>public static void foo() {  </li>
<li>int a = 1;  </li>
<li>int b = 2;  </li>
<li>int c = (a + b) /* 5;  </li>
<li>}  </li>
<li>}  </li>
</ol>
<p>public class Demo {</p>
<pre><code>public static void foo() {
    int a = 1;

    int b = 2;
    int c = (a + b) /* 5;

}
</code></pre><p>}
通过javac编译，得到Demo.class。通过javap可以看到foo()方法的字节码是：
Java bytecode代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>0:  iconst_1  </li>
<li>1:  istore_0  </li>
<li>2:  iconst_2  </li>
<li>3:  istore_1  </li>
<li>4:  iload_0  </li>
<li>5:  iload_1  </li>
<li>6:  iadd  </li>
<li>7:  iconst_5  </li>
<li>8:  imul  </li>
<li>9:  istore_2  </li>
<li>10: return  </li>
</ol>
<p>0:  iconst_1</p>
<p>1:  istore_0
2:  iconst_2</p>
<p>3:  istore_1
4:  iload_0</p>
<p>5:  iload_1
6:  iadd</p>
<p>7:  iconst_5
8:  imul</p>
<p>9:  istore_2
10: return
接着用Android SDK里platforms\android-1.6\tools目录中的dx工具将Demo.class转换为dex格式。转换时可以直接以文本形式dump出dex文件的内容。使用下面的命令：
Command prompt代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>dx --dex --verbose --dump-to=Demo.dex.txt --dump-method=Demo.foo --verbose-dump Demo.class  </li>
</ol>
<p>dx --dex --verbose --dump-to=Demo.dex.txt --dump-method=Demo.foo --verbose-dump Demo.class
可以看到foo()方法的字节码是：
Dalvik bytecode代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>0000: const/4       v0, /#int 1 // /#1  </li>
<li>0001: const/4       v1, /#int 2 // /#2  </li>
<li>0002: add-int/2addr v0, v1  </li>
<li>0003: mul-int/lit8  v0, v0, /#int 5 // /#05  </li>
<li>0005: return-void  </li>
</ol>
<p>0000: const/4       v0, /#int 1 // /#1</p>
<p>0001: const/4       v1, /#int 2 // /#2
0002: add-int/2addr v0, v1</p>
<p>0003: mul-int/lit8  v0, v0, /#int 5 // /#05
0005: return-void
（原本的输出里还有些code-address、local-snapshot等，那些不是字节码的部分，可以忽略。）
让我们看看两个版本在概念上是如何工作的。
JVM：
<img src="" alt="">
（图中数字均以十六进制表示。其中字节码的一列表示的是字节码指令的实际数值，后面跟着的助记符则是其对应的文字形式。标记为红色的值是相对上一条指令的执行状态有所更新的值。下同）
说明：Java字节码以1字节为单元。上面代码中有11条指令，每条都只占1单元，共11单元==11字节。
程序计数器是用于记录程序当前执行的位置用的。对Java程序来说，每个线程都有自己的PC。PC以字节为单位记录当前运行位置里方法开头的偏移量。
每个线程都有一个Java栈，用于记录Java方法调用的“活动记录”（activation record）。Java栈以帧（frame）为单位线程的运行状态，每调用一个方法就会分配一个新的栈帧压入Java栈上，每从一个方法返回则弹出并撤销相应的栈帧。
每个栈帧包括局部变量区、求值栈（JVM规范中将其称为“操作数栈”）和其它一些信息。局部变量区用于存储方法的参数与局部变量，其中参数按源码中从左到右顺序保存在局部变量区开头的几个slot。求值栈用于保存求值的中间结果和调用别的方法的参数等。两者都以字长（32位的字）为单位，每个slot可以保存byte、short、char、int、float、reference和returnAddress等长度小于或等于32位的类型的数据；相邻两项可用于保存long和double类型的数据。每个方法所需要的局部变量区与求值栈大小都能够在编译时确定，并且记录在.class文件里。
在上面的例子中，Demo.foo()方法所需要的局部变量区大小为3个slot，需要的求值栈大小为2个slot。Java源码的a、b、c分别被分配到局部变量区的slot 0、slot 1和slot 2。可以观察到Java字节码是如何指示JVM将数据压入或弹出栈，以及数据是如何在栈与局部变量区之前流动的；可以看到数据移动的次数特别多。动画里可能不太明显，iadd和imul指令都是要从求值栈弹出两个值运算，再把结果压回到栈上的；光这样一条指令就有3次概念上的数据移动了。
对了，想提醒一下：Java的局部变量区并不需要把某个局部变量固定分配在某个slot里；不仅如此，在一个方法内某个slot甚至可能保存不同类型的数据。如何分配slot是编译器的自由。从类型安全的角度看，只要对某个slot的一次load的类型与最近一次对它的store的类型匹配，JVM的字节码校验器就不会抱怨。以后再找时间写写这方面。
Dalvik VM：
<img src="" alt="">
说明：Dalvik字节码以16位为单元（或许叫“双字节码”更准确 =_=|||）。上面代码中有5条指令，其中mul-int/lit8指令占2单元，其余每条都只占1单元，共6单元==12字节。
与JVM相似，在Dalvik VM中每个线程都有自己的PC和调用栈，方法调用的活动记录以帧为单位保存在调用栈上。PC记录的是以16位为单位的偏移量而不是以字节为单位的。
与JVM不同的是，Dalvik VM的栈帧中没有局部变量区与求值栈，取而代之的是一组虚拟寄存器。每个方法被调用时都会得到自己的一组虚拟寄存器。常用v0-v15这16个，也有少数指令可以访问v0-v255范围内的256个虚拟寄存器。与JVM相同的是，每个方法所需要的虚拟寄存器个数都能够在编译时确定，并且记录在.dex文件里；每个寄存器都是字长（32位），相邻的一对寄存器可用于保存64位数据。方法的参数按源码中从左到右的顺序保存在末尾的几个虚拟寄存器里。
与JVM版相比，可以发现Dalvik版程序的指令数明显减少了，数据移动次数也明显减少了，用于保存临时结果的存储单元也减少了。
你可能会抱怨：上面两个版本的代码明明不对应：JVM版到return前完好持有a、b、c三个变量的值；而Dalvik版到return-void前只持有b与c的值（分别位于v0与v1），a的值被刷掉了。
但注意到a与b的特征：它们都只在声明时接受过一次赋值，赋值的源是常量。这样就可以对它们应用<a href="http://en.wikipedia.org/wiki/Constant_folding" target="_blank">常量传播</a>，将
Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>int c = (a + b) /* 5;  </li>
</ol>
<p>int c = (a + b) /* 5;
替换为
Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>int c = (1 + 2) /* 5;  </li>
</ol>
<p>int c = (1 + 2) /* 5;
然后可以再对c的初始化表达式应用常量折叠，进一步替换为：
Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>int c = 15;  </li>
</ol>
<p>int c = 15;
把变量的每次状态更新（包括初始赋值在内）称为变量的一次“定义”（definition），把每次访问变量（从变量读取值）称为变量的一次“使用”（use），则可以把代码整理为“使用-定义链”（简称UD链，<a href="http://en.wikipedia.org/wiki/Use-define_chain" target="_blank">use-define chain</a>）。显然，一个变量的某次定义要被使用过才有意义。上面的例子经过常量传播与折叠后，我们可以分析得知变量a、b、c都只被定义而没有被使用。于是它们的定义就成为了无用代码（dead code），可以安全的被消除。
上面一段的分析用一句话描述就是：由于foo()里没有产生外部可见的副作用，所以foo()的整个方法体都可以被优化为空。经过dx工具处理后，Dalvik版程序相对JVM版确实是稍微优化了一些，不过没有影响程序的语义，程序的正确性是没问题的。这是其一。
其二是Dalvik版代码只要多分配一个虚拟寄存器就能在return-void前同时持有a、b、c三个变量的值，指令几乎没有变化：
Dalvik bytecode代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>0000: const/4      v0, /#int 1 // /#1  </li>
<li>0001: const/4      v1, /#int 2 // /#2  </li>
<li>0002: add-int      v2, v0, v1  </li>
<li>0004: mul-int/lit8 v2, v2, /#int 5 // /#05  </li>
<li>0006: return-void  </li>
</ol>
<p>0000: const/4      v0, /#int 1 // /#1</p>
<p>0001: const/4      v1, /#int 2 // /#2
0002: add-int      v2, v0, v1</p>
<p>0004: mul-int/lit8 v2, v2, /#int 5 // /#05
0006: return-void
这样比原先的版本多使用了一个虚拟寄存器，指令方面也多用了一个单元（add-int指令占2单元）；但指令的条数没变，仍然是5条，数据移动的次数也没变。
题外话1：Dalvik VM是基于寄存器的，x86也是基于寄存器的，但两者的“寄存器”却相当不同：前者的寄存器是每个方法被调用时都有自己一组私有的，后者的寄存器则是全局的。也就是说，概念上Dalvik VM字节码中不用担心保护寄存器的问题，某个方法在调用了别的方法返回过来后自己的寄存器的值肯定跟调用前一样。而x86程序在调用函数时要考虑清楚<a href="http://en.wikipedia.org/wiki/Calling_convention" target="_blank">calling convention</a>，调用方在调用前要不要保护某些寄存器的当前状态，还是说被调用方会处理好这些问题，麻烦事不少。Dalvik VM这种虚拟寄存器让人想起一些实际处理器的“寄存器窗口”，例如SPARC的<a href="http://www.usenix.org/events/sec01/full_papers/frantzen/frantzen_html/node5.html" target="_blank">Register Windows</a>也是保证每个函数都觉得自己有“私有的一组寄存器”，减轻了在代码里处理寄存器保护的麻烦——扔给硬件和操作系统解决了。<a href="http://en.wikipedia.org/wiki/Itanium" target="_blank">IA-64</a>也有寄存器窗口的概念。
（当然，Dalvik VM与x86的“寄存器”一个是虚拟寄存器一个是真实硬件的ISA提供的寄存器，本来也不在一个级别上…上面这段只是讨论寄存器的语义。）
题外话2：Dalvik的.dex文件在未压缩状态下的体积通常比同等内容的.jar文件在deflate压缩后还要小。但光从字节码看，Java字节码几乎总是比Dalvik的小，那.dex文件的体积是从哪里来减出来的呢？这主要得益与.dex文件对常量池的压缩，一个.dex文件中所有类都共享常量池，使得相同的字符串、相同的数字常量等都只出现一次，自然能大大减小体积。相比之下，.jar文件中每个类都持有自己的常量池，诸如&quot;Ljava/lang/Object;&quot;这种常见的字符串会被重复多次。Sun自己也有进一步压缩JAR的工具，Pack200，对应的标准是<a href="http://jcp.org/en/jsr/detail?id=200" target="_blank">JSR 200</a>。它的主要应用场景是作为JAR的网络传输格式，以更高的压缩比来减少文件传输时间。在<a href="http://java.sun.com/j2se/1.5.0/docs/guide/deployment/deployment-guide/pack200.html" target="_blank">官方文档</a>提到了Pack200所用到的压缩技巧，
JDK 5.0 Documentation 写道</p>
<p>Pack200 works most efficiently on Java class files. It uses several techniques to efficiently reduce the size of JAR files:</p>
<ul>
<li>It merges and sorts the constant-pool data in the class files and co-locates them in the archive.</li>
<li>It removes redundant class attributes.</li>
<li>It stores internal data structures.</li>
<li>It use delta and variable length encoding.</li>
<li>It chooses optimum coding types for secondary compression.
可见.dex文件与Pack200采用了一些相似的减小体积的方法。很可惜目前还没有正式发布的JVM支持直接加载Pack200格式的归档，毕竟网络传输才是Pack200最初构想的应用场景。<h1 id="-jvm-dalvik-vm-vm-vm-">再次提醒注意，<strong>上面的描述是针对概念上的JVM与Dalvik VM，而不是针对它们的具体实现</strong>。实现VM时可以采用许多优化技巧去减少性能损失，使得实际的运行方式与概念中的不完全相符，只要最终的运行结果满足原本概念上的VM所实现的语义就行。</h1>
上面“简单”的提了些讨论点，不过还没具体到JavaScript引擎，抱歉。弄得太长了，只好在这里先拆分一次……有些东西想写的，洗个澡又忘记了。等想起来再补充 orz
“简单”是相对于实际应该掌握的信息量而言。上面写的都还没挠上痒痒，心虚。
Anyway。根据拆分的现状，下一篇应该是讨论动态语言与编译的问题，然后再下一篇会看看解释器的演化方法，再接着会看看JavaScript引擎的状况（主要针对V8和Nitro，也会谈谈Tamarin。就不讨论JScript了）。
关于推荐资料，在<a href="http://rednaxelafx.iteye.com/link?tag=virtual+machine" target="_blank">“我的收藏”的virtual machine标签</a>里就有不少值得一读的资料。如果只是对JavaScript引擎相关感兴趣的话也可以选着读些。我的收藏里还有v8和tamarin等标签的，资料有的是 ^ ^
能有耐心读到结尾的同学们，欢迎提出意见和建议，以及指出文中的错漏 ^<em>^
不像抓到虫就给美分的大师，我没那种信心……错漏难免，我也需要进一步学习。拜托大家了～
P.S. 画图真的很辛苦，加上JavaEye的带宽也不是无限的……所以拜托不要直接链接这帖里的图 &lt;(</em> _)&gt;
有需要原始图片的可以跟我联系。我是画成多帧PNG然后转换为GIF发出来的。上面的PNG图片都还保留有原始的图层信息，要拿去再编辑也很方便 ^ ^
更新1：
原本在树遍历解释器图解的小节中，我用的是这幅图：
<img src="" alt="">
其实上图画得不准确，a、b、c的右值不应该画在节点上的；节点应该只保存了它们的左值才对，要获取对应的右值就要查询变量表。我修改了图更新到正文了。原本的图里对i的赋值看起来很奇怪，就像是遍历过程经过了两次i节点一般，而事实不是那样的。</li>
</ul>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/JVM/">JVM</a></li></span></span> | <span class="tags">Tagged <a href="/tags/JVM/" class="label label-primary">JVM</a><a href="/tags/Java&J2EE/" class="label label-success">Java&J2EE</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:42"datetime="2014-03-07 09:54:42"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-JVM--虚拟机随谈（一）：解释器，树遍历解释器，基于栈与基于寄存器，大杂烩/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-JVM--虚拟机随谈（一）：解释器，树遍历解释器，基于栈与基于寄存器，大杂烩" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE--Java字节码工具ASM在WebService开发中的应用/">Java字节码工具ASM在Web Service开发中的应用</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:42.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE--Java字节码工具ASM在WebService开发中的应用/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="java-asm-web-service-">Java字节码工具ASM在Web Service开发中的应用</h1>
<p>在基于 JAX-WS 标准的 web services 的开发中，不少实际场景都是希望采用自底向上的开发方式， 即基于已有的 Java bean 来创建 web services 。WebSphere Application Server ( 以下简称 WAS ) 提供了命令行的工具 wsgen 和相对应的 Ant task 来支持这种开发过程，而且这两个工具比较适合大型项目的自动化构建。 这两个工具的使用前提是 Java bean 中事先添加有 web services 的 Annotation 标注，而在现有的业务系统中，class 文件一般是不带 Annotation 的，这就需要开发人员去修改现有的代码，以手工方式添加 Annotation，但这样带来的工作量太大且容易出错。本文介绍了一种解决途径，可以不用修改源代码，而是利用字节码工具 ASM 直接修改 class 文件， 在字节码文件中自动注入 Annotation ，然后再利用 wsgen 工具就可以很方便地生成 web services 应用。 本文同时也总结了使用 ASM 的一些实践。</p>
<p>本文首先介绍了和 ASM 使用相关的四种文件，以及它们之间的相互转化。然后结合 web services 开发实例，介绍了使用 wsgen 开发时遇到的实际问题，如何写一个 ASM 的适配器去修改现有 class，最终如何产生 web services 文件。</p>
<p>ASM 是一个多用途的 Java 字节码操控和分析框架。它能以二进制的形式直接修改现有的类或动态生成的类。 ASM 提供了常用的转换和分析算法，是一种允许用户方便的组装定制化的复杂转换和代码分析工具。 ASM 也提供和其它的字节码工具类似的功能，但 ASM 的重点是使用的简单和高性能。由于 ASM 在设计实现的时候尽可能 的小的内存占用和提供更高的性能；因此在动态系统中使用 ASM 是很有优势的。ASM 作为一种轻量级、高性能的 Java 字节码操控和分析框架，设计了一种更有效的方法、提供更好的性能和内存占用。今天， ASM 在许多领域都有应用，并已成为事实上的字节码处理框架标准。</p>
<p><a href="">问题的引入</a></p>
<p>先写一个不带 web services 标注的 SayHelloImpl 类。
<a href=""><strong>清单 1. 不带 web services 的 SayHelloImpl 类</strong></a>1</p>
<p>public</p>
<p>class</p>
<p>SayHelloImpl {</p>
<p>2</p>
<p>public</p>
<p>String sayHello(String s) {
3</p>
<p>return</p>
<p>“Hello: ” + s ;</p>
<p>4</p>
<p>}
5</p>
<p>}</p>
<p>再用 wsgen 来创建 web services，wsgen 的使用如下：
<a href=""><strong>清单 2. wsgen 实例</strong></a>1</p>
<p>wsgen.exe – </p>
<p>cp</p>
<p>bin – s output – d output – r output – wsdl ibm.was.asm.SayHelloImpl我们将会遇到如下错误： 
<a href=""><strong>清单 3. 根据不带 web services 标注的类创建 web services 时遇到的错误信息</strong></a> 
注释处理过程中遇到问题；</p>
<p>......
com.sun.tools.internal.ws.processor.modeler.ModelerException: [failed to localiz</p>
<p>e] A web service endpoint could not be found()
        at com.sun.tools.internal.ws.processor.modeler.annotation.WebServiceAP.o</p>
<p>nError(WebServiceAP.java:215)
        at com.sun.tools.internal.ws.processor.modeler.annotation.WebServiceAP.b</p>
<p>uildModel(WebServiceAP.java:322)
        at com.sun.tools.internal.ws.processor.modeler.annotation.WebServiceAP.p</p>
<p>rocess(WebServiceAP.java:256)
        at com.sun.mirror.apt.AnnotationProcessors$CompositeAnnotationProcessor.</p>
<p>process(AnnotationProcessors.java:60)</p>
<p>注意：我们通常是在 class 前使用 @WebService， 在方法前使用 @WebMethod 来将一个类标注为 web services 的。WAS 6.1 的 web services 功能部件包和 WAS 7 都支持基于 JAX-WS 标准 的 web services 的开发， 在 WAS 安装目录的 bin 目录下提供了命令行工具 wsgen，wsgen 支持自底向上的开发方式。 下面是 wsgen 的用法：
<a href=""><strong>清单 4. wsgen 命令格式</strong></a> 
注 wsgen [options]  [SEI]</p>
<p>主要选项：</p>
<ul>
<li>-d 指定生成的 class 文件位置；</li>
<li>-s 指定生成的 Java 源文件位置；</li>
<li>-r 指定生成的 resources 文件位置，如 wsdl，xsd；</li>
<li>-cp 指定服务实现类所在的位置；</li>
<li>-wsdl，-servicename，-portname 三个参数指定生成的 wsdl 文件中的 service 和 port 的名称。</li>
</ul>
<p>SEI(Service Endpoint Interface) 是一个 endpoint implementation class，不能是一个 interface。所以首先要开发一个 endpoint 的实现类，如本例中的 SayHelloImpl 。用 @WebService 声明 web services ，然后将它编译，才能提供给 wsgen 来创建 web services 。</p>
<p><a href="">四种文件之间的转换</a></p>
<p>下面介绍本文要用到的四个概念（Java Source，Java Class，ASM Code，ASM Source）</p>
<ul>
<li>Java Source: 即我们通常编写的 Java 源文件；</li>
<li>Java Class: Java 源文件编译后的字节码文件；</li>
<li>ASM Source : 类似于对 class 反编译后的源文件，也就是 &quot;textual byte code&quot;，但比原始的 Java Source 可读性要差， 参见清单 5。</li>
<li>ASM Code: 指读写 class 文件的 ASM 程序代码。需要用到 ASM 提供的 API， 参见清单 6。
<a href=""><strong>清单 5. SayHelloImpl 类对应的 ASM Source</strong></a>01</li>
</ul>
<p>// class version 50.0 (50)</p>
<p>02</p>
<p>// access flags 33
03</p>
<p>public</p>
<p>class</p>
<p>com/ibm/was/asm/SayHelloImpl {</p>
<p>04</p>
<p>05</p>
<p>// access flags 1</p>
<p>06</p>
<p>public</p>
<p><init>()V
07</p>
<p>ALOAD </p>
<p>0</p>
<p>08</p>
<p>INVOKESPECIAL java/lang/Object. <init> ()V
09</p>
<p>RETURN</p>
<p>10</p>
<p>MAXSTACK = </p>
<p>1
11</p>
<p>MAXLOCALS = </p>
<p>1</p>
<p>12</p>
<p>13</p>
<p>// access flags 1</p>
<p>14</p>
<p>public</p>
<p>sayHello(Ljava/lang/String;)Ljava/lang/String;
15</p>
<p>NEW java/lang/StringBuilder</p>
<p>16</p>
<p>DUP
17</p>
<p>LDC </p>
<p>&quot;Hello:&quot;</p>
<p>18</p>
<p>INVOKESPECIAL java/lang/StringBuilder. <init> (Ljava/lang/String;)V
19</p>
<p>ALOAD </p>
<p>1</p>
<p>20</p>
<p>INVOKEVIRTUAL java/lang/StringBuilder.append (Ljava/lang/String;)
21</p>
<p>Ljava/lang/StringBuilder;</p>
<p>22</p>
<p>INVOKEVIRTUAL java/lang/StringBuilder.toString ()Ljava/lang/String;
23</p>
<p>ARETURN</p>
<p>24</p>
<p>MAXSTACK = </p>
<p>3
25</p>
<p>MAXLOCALS = </p>
<p>2</p>
<p>26</p>
<p>}<a href=""><strong>清单 6. 生成 SayHelloImpl.class 的 ASM Code</strong></a><a href="http://www.oschina.net/question/129540_28430#viewSource" title="view source" target="_blank">view source</a><a href="http://www.oschina.net/question/129540_28430#printSource" title="print" target="_blank">print</a><a href="http://www.oschina.net/question/129540_28430#about" title="?" target="_blank">?</a></p>
<p>01</p>
<p>package</p>
<p>asm.com.ibm.was.asm;</p>
<p>02</p>
<p>import</p>
<p>java.util./*;
03</p>
<p>import</p>
<p>org.objectweb.asm./*;</p>
<p>04</p>
<p>import</p>
<p>org.objectweb.asm.attrs./*;
05</p>
<p>public</p>
<p>class</p>
<p>SayHelloImplDump </p>
<p>implements</p>
<p>Opcodes {</p>
<p>06</p>
<p>public</p>
<p>static</p>
<p>byte</p>
<p>[] dump () </p>
<p>throws</p>
<p>Exception {
07</p>
<p>ClassWriter cw = </p>
<p>new</p>
<p>ClassWriter(</p>
<p>0</p>
<p>);</p>
<p>08</p>
<p>FieldVisitor fv;
09</p>
<p>MethodVisitor mv;</p>
<p>10</p>
<p>AnnotationVisitor av0;
11</p>
<p>12</p>
<p>cw.visit(V1_6, ACC_PUBLIC + ACC_SUPER, </p>
<p>&quot;com/ibm/was/asm/SayHelloImpl&quot;</p>
<p>,
13</p>
<p>null</p>
<p>, </p>
<p>&quot;java/lang/Object&quot;</p>
<p>, </p>
<p>null</p>
<p>);</p>
<p>14</p>
<p>15</p>
<p>{</p>
<p>16</p>
<p>mv = cw.visitMethod(ACC_PUBLIC, </p>
<p>&quot;<init>&quot;</p>
<p>, </p>
<p>&quot;()V&quot;</p>
<p>, </p>
<p>null</p>
<p>, </p>
<p>null</p>
<p>);
17</p>
<p>mv.visitCode();</p>
<p>18</p>
<p>mv.visitVarInsn(ALOAD, </p>
<p>0</p>
<p>);
19</p>
<p>mv.visitMethodInsn(INVOKESPECIAL, </p>
<p>&quot;java/lang/Object&quot;</p>
<p>, </p>
<p>&quot;<init>&quot;</p>
<p>, </p>
<p>&quot;()V&quot;</p>
<p>);</p>
<p>20</p>
<p>mv.visitInsn(RETURN);
21</p>
<p>mv.visitMaxs(</p>
<p>1</p>
<p>, </p>
<p>1</p>
<p>);</p>
<p>22</p>
<p>mv.visitEnd();
23</p>
<p>}</p>
<p>24</p>
<p>{
25</p>
<p>mv = cw.visitMethod(ACC_PUBLIC, </p>
<p>&quot;sayHello&quot;</p>
<p>,</p>
<p>26</p>
<p>&quot;(Ljava/lang/String;)Ljava/lang/String;&quot;</p>
<p>, </p>
<p>null</p>
<p>, </p>
<p>null</p>
<p>);
27</p>
<p>mv.visitCode();</p>
<p>28</p>
<p>mv.visitTypeInsn(NEW, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>);
29</p>
<p>mv.visitInsn(DUP);</p>
<p>30</p>
<p>mv.visitLdcInsn(</p>
<p>&quot;Hello:&quot;</p>
<p>);
31</p>
<p>mv.visitMethodInsn(INVOKESPECIAL, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>,</p>
<p>32</p>
<p>&quot;<init>&quot;</p>
<p>, </p>
<p>&quot;(Ljava/lang/String;)V&quot;</p>
<p>);
33</p>
<p>mv.visitVarInsn(ALOAD, </p>
<p>1</p>
<p>);</p>
<p>34</p>
<p>mv.visitMethodInsn(INVOKEVIRTUAL, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>,
35</p>
<p>&quot;append&quot;</p>
<p>, </p>
<p>&quot;(Ljava/lang/String;)Ljava/lang/StringBuilder;&quot;</p>
<p>);</p>
<p>36</p>
<p>mv.visitMethodInsn(INVOKEVIRTUAL, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>,
37</p>
<p>&quot;toString&quot;</p>
<p>, </p>
<p>&quot;()Ljava/lang/String;&quot;</p>
<p>);</p>
<p>38</p>
<p>mv.visitInsn(ARETURN);
39</p>
<p>mv.visitMaxs(</p>
<p>3</p>
<p>, </p>
<p>2</p>
<p>);</p>
<p>40</p>
<p>mv.visitEnd();
41</p>
<p>}</p>
<p>42</p>
<p>cw.visitEnd();
43</p>
<p>return</p>
<p>cw.toByteArray();</p>
<p>44</p>
<p>}
45</p>
<p>}</p>
<p>图 1 描述了 Java Source 文件、Java Class 文件、ASM Code 文件和 ASM Source 文件之间的转换关系。
<a href=""><strong>图 1. 四种文件的转换图</strong></a> 
<a href="http://static.oschina.net/uploads/img/201109/26204312_QD65.jpg" target="_blank"><img src="" alt="图 1. 四种文件的转换图"></a> </p>
<p>如图 -1 所示，Java Source 文件通过 Javac 可以转换为 Java Class 文件。而相应的 Java Class 文件通过 Java 反编译器工具可转换为 Java Source 文件；</p>
<p>通 过 ASM Code 去创建和修改 Java Class 需要对 ASM API 比较熟悉才行，一个常见的问题时，怎么用 ASM Code 生成一个我们希望的 class 文件， 也就是说， 给定了 Java Class， 怎么得到其对应的 ASM Code 呢？ 所幸的是， ASM 框架为我们提供了 ASMifierClassVisitor 工具来产生 Java Class 对应的 ASM Code。代码如下：
<a href=""><strong>清单 7. 给定 class 文件，通过 ASMifierClassVisitor 获得其对应的 ASM Code</strong></a>01</p>
<p>public</p>
<p>void</p>
<p>showClassASMProcess() {</p>
<p>02</p>
<p>ClassReader cr;
03</p>
<p>final</p>
<p>String n = SayHelloImpl.</p>
<p>class</p>
<p>.getName();</p>
<p>04</p>
<p>05</p>
<p>try</p>
<p>{</p>
<p>06</p>
<p>cr = </p>
<p>new</p>
<p>ClassReader(n);<br>07</p>
<p>cr.accept(</p>
<p>new</p>
<p>ASMifierClassVisitor(</p>
<p>new</p>
<p>PrintWriter(System.out)),</p>
<p>08</p>
<p>new</p>
<p>Attribute[</p>
<p>0</p>
<p>],
09</p>
<p>ClassReader.SKIP_DEBUG);</p>
<p>10</p>
<p>11</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {</p>
<p>12</p>
<p>e.printStackTrace();
13</p>
<p>}</p>
<p>14</p>
<p>}</p>
<p>另外一个重要的转换就是， 给定了 Java Class 文件， 如何查看它的 ASM Source ？ 这点对于我们验证 ASM Code 生成的 class 是否正确很有用。ASM 提供了另外一个工具 TraceClassVisitor， 来获得一个 Java Class 对应的 ASM Source。代码如下：
<a href=""><strong>清单 8. 利用 TraceClassVisitor 查看 class 文件的 ASM Source</strong></a>01</p>
<p>//file 是 class 文件的全路径名</p>
<p>02</p>
<p>public</p>
<p>void</p>
<p>showClassSource(String file) {
03</p>
<p>FileInputStream is ;</p>
<p>04</p>
<p>ClassReader cr; 
05</p>
<p>06</p>
<p>try</p>
<p>{
07</p>
<p>is = </p>
<p>new</p>
<p>FileInputStream(file);     </p>
<p>08</p>
<p>cr = </p>
<p>new</p>
<p>ClassReader(is);
09</p>
<p>TraceClassVisitor trace = </p>
<p>new</p>
<p>TraceClassVisitor(</p>
<p>new</p>
<p>PrintWriter(System.out));</p>
<p>10</p>
<p>cr.accept(trace, ClassReader.SKIP_DEBUG);
11</p>
<p>12</p>
<p>is.close() ;
13</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {</p>
<p>14</p>
<p>e.printStackTrace() ;
15</p>
<p>}</p>
<p>16</p>
<p>}
17</p>
<p>{</p>
<p>18</p>
<p>e.printStackTrace();
19</p>
<p>}</p>
<p>20</p>
<p>}</p>
<p><a href="">ASM 类注入</a></p>
<p>ASM 类注入是指修改一个现有的 class 文件，在其中加入自己的代码。按通常思维，我们需要利用 ASM 提供的 reader 类去读取所要修改的类文件， 找到要修改的地方，如方法名或属性名，然后在该处插入自己的代码或修改现有的代码，这种思路将使问题复杂化。 ASM 为我们提供了访问类文件的 Visitor 模式，来遍历一个 class 文件，Visitor 是一个实现 ClassVisitor 接口的类。 要注入一个 class 文件，先要找到一个合适的 Visitor 做向导， ASM 提供了好几种 Visitor， 最常用的是 ClassWriter。同时我们需要提供一个适配器类 ClassAdapter， Visitor 会带着这个 Adapter 一起去遍历， 然后在遍历过程中回调 Adapter 提供的方法。我们在 Adapter 的这些方法中就可以实现我们的修改和定制逻辑。当然，如果你不想做任何修改，那 Visitor 遍历完后将得到一个和被遍历的 class 完全一样的拷贝。
<a href=""><strong>清单 9. 类注入的完整过程</strong></a>01</p>
<p>public</p>
<p>void</p>
<p>addAnnotationToExistingClass() {</p>
<p>02</p>
<p>FileInputStream is ;
03</p>
<p>ClassReader cr;          </p>
<p>04</p>
<p>try</p>
<p>{<br>05</p>
<p>String classfile = </p>
<p>&quot;E:\SayHelloImpl.class&quot;</p>
<p>; </p>
<p>// 待遍历的类</p>
<p>06</p>
<p>showClassSource(classfile) ;  </p>
<p>// 打印该类的 ASM source
07</p>
<p>08</p>
<p>is = </p>
<p>new</p>
<p>FileInputStream(classfile);<br>09</p>
<p>cr = </p>
<p>new</p>
<p>ClassReader(is);</p>
<p>10</p>
<p>// 此处我们使用 ClassWriter 做 Visitor
11</p>
<p>ClassWriter cw = </p>
<p>new</p>
<p>ClassWriter(ClassWriter.COMPUTE_MAXS);</p>
<p>12</p>
<p>// 给 Visitor 提供一个 Adapter
13</p>
<p>AddAnnotationAdapter adapter = </p>
<p>new</p>
<p>AddAnnotationAdapter(cw);           </p>
<p>14</p>
<p>cr.accept(adapter, ClassReader.SKIP_DEBUG);<br>15</p>
<p>16</p>
<p>// 遍历完后，生成的 class 保存在字节数组中
17</p>
<p>byte</p>
<p>[] b = cw.toByteArray();</p>
<p>18</p>
<p>19</p>
<p>try</p>
<p>{</p>
<p>20</p>
<p>// 将字节数组输出到文件中
21</p>
<p>// 为了不至于覆盖掉原有的 SayHelloImpl.class 文件，我们将结果输出到 _SayHelloImpl.class</p>
<p>22</p>
<p>FileOutputStream fout = </p>
<p>new</p>
<p>FileOutputStream(</p>
<p>&quot;E:\_SayHelloImpl.class&quot;</p>
<p>);
23</p>
<p>fout.write(b) ;</p>
<p>24</p>
<p>fout.flush();
25</p>
<p>fout.close() ;</p>
<p>26</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {
27</p>
<p>e.printStackTrace() ;</p>
<p>28</p>
<p>}
29</p>
<p>30</p>
<p>// 验证 _SayHelloImpl.class 是否包含我们注入的代码
31</p>
<p>showClassSource(</p>
<p>&quot;E:\_SayHelloImpl.class&quot;</p>
<p>) ;</p>
<p>32</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {
33</p>
<p>e.printStackTrace();</p>
<p>34</p>
<p>} 
35</p>
<p>}</p>
<p><a href="">web services 标记注入过程</a></p>
<p>我们已经知道了如何往 class 中注入自己的代码，那对于一个已有的 Java bean，怎么往里注入 @WebService 和 @WebMethod 呢？根据上面我们讲的转换关系，我们可以先写一个带 annotation 的 Java Source，编译得到 Java Class， 再得到其 ASM Code。下面是利用 ASM 给一个不带任何 Annotation 的 class 添加 @WebService 和 @WebMethod 的步骤。</p>
<ol>
<li>首先在 SayHelloImpl.java 中添加 @WebService 和 @WebMethod： 
<a href=""><strong>清单 10. 带 web services 标注的 SayHelloImpl 类</strong></a>1</li>
</ol>
<p>@WebService</p>
<p>2</p>
<p>public</p>
<p>class</p>
<p>SayHelloImpl {
3</p>
<p>@WebMethod</p>
<p>4</p>
<p>public</p>
<p>String sayHello(String s) {
5</p>
<p>return</p>
<p>&quot;Hello: &quot;</p>
<ul>
<li>s ;</li>
</ul>
<p>6</p>
<p>}
7</p>
<p>}</p>
<ol>
<li>通过 ASMifierClassVisitor 工具获得 SayHelloImpl class 的 ASM Code，见清单 6。</li>
<li>写一个 ClassAdapter 类， ClassAdapter 其实也是一个 Visitor。根据 ASM Code 的提示， 我们就可以知道如何利用 ASM API 去获得我们希望的 class 文件。下面是 Adapter 的示例代码。 
<a href=""><strong>清单 11. 添加 Annotation 的 Adapter 类</strong></a>01</li>
</ol>
<p>public</p>
<p>class</p>
<p>AddAnnotationAdapter </p>
<p>extends</p>
<p>ClassAdapter </p>
<p>implements</p>
<p>Opcodes{</p>
<p>02</p>
<p>//private String annotationDesc;
03</p>
<p>private</p>
<p>boolean</p>
<p>isAnnotationPresent;</p>
<p>04</p>
<p>05</p>
<p>public</p>
<p>AddAnnotationAdapter(ClassVisitor cv) {</p>
<p>06</p>
<p>super</p>
<p>(cv);
07</p>
<p>}</p>
<p>08</p>
<p>09</p>
<p>@Override</p>
<p>10</p>
<p>public</p>
<p>void</p>
<p>visit(</p>
<p>int</p>
<p>version, </p>
<p>int</p>
<p>access, String name, String signature,
11</p>
<p>String superName, String[] interfaces) {</p>
<p>12</p>
<p>13</p>
<p>cv.visit(V1_6, ACC_PUBLIC + ACC_SUPER, name, signature, superName,</p>
<p>14</p>
<p>interfaces);
15</p>
<p>AnnotationVisitor av0;</p>
<p>16</p>
<p>av0 = cv.visitAnnotation(</p>
<p>&quot;Ljavax/jws/WebService;&quot;</p>
<p>, </p>
<p>true</p>
<p>);
17</p>
<p>av0.visitEnd();</p>
<p>18</p>
<p>}
19</p>
<p>20</p>
<p>@Override
21</p>
<p>public</p>
<p>AnnotationVisitor visitAnnotation(String desc, </p>
<p>boolean</p>
<p>visible) {</p>
<p>22</p>
<p>return</p>
<p>cv.visitAnnotation(desc, visible);
23</p>
<p>}</p>
<p>24</p>
<p>25</p>
<p>@Override</p>
<p>26</p>
<p>public</p>
<p>void</p>
<p>visitInnerClass(String name, String outerName,
27</p>
<p>String innerName, </p>
<p>int</p>
<p>access) {</p>
<p>28</p>
<p>cv.visitInnerClass(name, outerName, innerName, access);
29</p>
<p>}</p>
<p>30</p>
<p>31</p>
<p>@Override</p>
<p>32</p>
<p>public</p>
<p>FieldVisitor visitField(</p>
<p>int</p>
<p>access, String name, String desc,
33</p>
<p>String signature, Object value) {</p>
<p>34</p>
<p>return</p>
<p>cv.visitField(access, name, desc, signature, value);
35</p>
<p>}</p>
<p>36</p>
<p>37</p>
<p>@Override</p>
<p>38</p>
<p>public</p>
<p>MethodVisitor visitMethod(</p>
<p>int</p>
<p>access, String name, String desc,
39</p>
<p>String signature, String[] exceptions) {   </p>
<p>40</p>
<p>MethodVisitor mv  = cv.visitMethod(access, name, desc, signature,
41</p>
<p>exceptions);</p>
<p>42</p>
<p>if</p>
<p>(!name.equals(</p>
<p>&quot;<init>&quot;</p>
<p>)) {
43</p>
<p>AnnotationVisitor av0;</p>
<p>44</p>
<p>av0 = mv.visitAnnotation(</p>
<p>&quot;Ljavax/jws/WebMethod;&quot;</p>
<p>, </p>
<p>true</p>
<p>);
45</p>
<p>av0.visitEnd();</p>
<p>46</p>
<p>}
47</p>
<p>return</p>
<p>mv;</p>
<p>48</p>
<p>}
49</p>
<p>50</p>
<p>@Override
51</p>
<p>public</p>
<p>void</p>
<p>visitEnd() {</p>
<p>52</p>
<p>cv.visitEnd();
53</p>
<p>}</p>
<p>54</p>
<p>55</p>
<p>}</p>
<p>最后，我们采用上面讲的类注入办法，即可得到一个带 @WebService 和 @WebMethod 标注的 class 文件。再通过 wsgen 工具即可成功创建 web services，该命令将会在 src 目录下生成 web services 描述文件：SayHelloImplService.wsdl，SayHelloImplService_schema1.xsd，同时生成了 2 个 JAX-WS 文件，分别为：SayHello.java，SayHelloResponse.java。</p>
<p>当然，在实际应用中，我们可能需要将一个 class 的某些特定方法发布为 web services，这就需要我们对 Adapter 做进一步的改造，在 visitMethod() 方法中根据方法名称等参数做进一步的处理。</p>
<p><a href="">结束语</a></p>
<p>本文简要介绍了 ASM 字节码工具及其在 web services 开发中的应用。web services 的使用已经越来越广泛， 但在改造遗留系统过程中会遇到不少问题，本文针对其中一个主要问题给出了解决办法，该方法无须对现有系统做大量的改动， 即可将现存的 Java bean 转化成 web services 。本文对那些正考虑迁移到 JAX-WS 编程模型上的项目有一定的参考价值。
来源： <a href="[http://www.oschina.net/question/129540_28430](http://www.oschina.net/question/129540_28430)">[http://www.oschina.net/question/129540_28430](http://www.oschina.net/question/129540_28430)</a> </p>
<p>在基于 JAX-WS 标准的 web services 的开发中，不少实际场景都是希望采用自底向上的开发方式， 即基于已有的 Java bean 来创建 web services 。WebSphere Application Server ( 以下简称 WAS ) 提供了命令行的工具 wsgen 和相对应的 Ant task 来支持这种开发过程，而且这两个工具比较适合大型项目的自动化构建。 这两个工具的使用前提是 Java bean 中事先添加有 web services 的 Annotation 标注，而在现有的业务系统中，class 文件一般是不带 Annotation 的，这就需要开发人员去修改现有的代码，以手工方式添加 Annotation，但这样带来的工作量太大且容易出错。本文介绍了一种解决途径，可以不用修改源代码，而是利用字节码工具 ASM 直接修改 class 文件， 在字节码文件中自动注入 Annotation ，然后再利用 wsgen 工具就可以很方便地生成 web services 应用。 本文同时也总结了使用 ASM 的一些实践。</p>
<p>本文首先介绍了和 ASM 使用相关的四种文件，以及它们之间的相互转化。然后结合 web services 开发实例，介绍了使用 wsgen 开发时遇到的实际问题，如何写一个 ASM 的适配器去修改现有 class，最终如何产生 web services 文件。</p>
<p>ASM 是一个多用途的 Java 字节码操控和分析框架。它能以二进制的形式直接修改现有的类或动态生成的类。 ASM 提供了常用的转换和分析算法，是一种允许用户方便的组装定制化的复杂转换和代码分析工具。 ASM 也提供和其它的字节码工具类似的功能，但 ASM 的重点是使用的简单和高性能。由于 ASM 在设计实现的时候尽可能 的小的内存占用和提供更高的性能；因此在动态系统中使用 ASM 是很有优势的。ASM 作为一种轻量级、高性能的 Java 字节码操控和分析框架，设计了一种更有效的方法、提供更好的性能和内存占用。今天， ASM 在许多领域都有应用，并已成为事实上的字节码处理框架标准。</p>
<p><a href="">问题的引入</a></p>
<p>先写一个不带 web services 标注的 SayHelloImpl 类。
<a href=""><strong>清单 1. 不带 web services 的 SayHelloImpl 类</strong></a>1</p>
<p>public</p>
<p>class</p>
<p>SayHelloImpl {</p>
<p>2</p>
<p>public</p>
<p>String sayHello(String s) {
3</p>
<p>return</p>
<p>“Hello: ” + s ;</p>
<p>4</p>
<p>}
5</p>
<p>}</p>
<p>再用 wsgen 来创建 web services，wsgen 的使用如下：
<a href=""><strong>清单 2. wsgen 实例</strong></a>1</p>
<p>wsgen.exe – </p>
<p>cp</p>
<p>bin – s output – d output – r output – wsdl ibm.was.asm.SayHelloImpl我们将会遇到如下错误： 
<a href=""><strong>清单 3. 根据不带 web services 标注的类创建 web services 时遇到的错误信息</strong></a> 
注释处理过程中遇到问题；</p>
<p>......
com.sun.tools.internal.ws.processor.modeler.ModelerException: [failed to localiz</p>
<p>e] A web service endpoint could not be found()
        at com.sun.tools.internal.ws.processor.modeler.annotation.WebServiceAP.o</p>
<p>nError(WebServiceAP.java:215)
        at com.sun.tools.internal.ws.processor.modeler.annotation.WebServiceAP.b</p>
<p>uildModel(WebServiceAP.java:322)
        at com.sun.tools.internal.ws.processor.modeler.annotation.WebServiceAP.p</p>
<p>rocess(WebServiceAP.java:256)
        at com.sun.mirror.apt.AnnotationProcessors$CompositeAnnotationProcessor.</p>
<p>process(AnnotationProcessors.java:60)</p>
<p>注意：我们通常是在 class 前使用 @WebService， 在方法前使用 @WebMethod 来将一个类标注为 web services 的。WAS 6.1 的 web services 功能部件包和 WAS 7 都支持基于 JAX-WS 标准 的 web services 的开发， 在 WAS 安装目录的 bin 目录下提供了命令行工具 wsgen，wsgen 支持自底向上的开发方式。 下面是 wsgen 的用法：
<a href=""><strong>清单 4. wsgen 命令格式</strong></a> 
注 wsgen [options]  [SEI]</p>
<p>主要选项：</p>
<ul>
<li>-d 指定生成的 class 文件位置；</li>
<li>-s 指定生成的 Java 源文件位置；</li>
<li>-r 指定生成的 resources 文件位置，如 wsdl，xsd；</li>
<li>-cp 指定服务实现类所在的位置；</li>
<li>-wsdl，-servicename，-portname 三个参数指定生成的 wsdl 文件中的 service 和 port 的名称。</li>
</ul>
<p>SEI(Service Endpoint Interface) 是一个 endpoint implementation class，不能是一个 interface。所以首先要开发一个 endpoint 的实现类，如本例中的 SayHelloImpl 。用 @WebService 声明 web services ，然后将它编译，才能提供给 wsgen 来创建 web services 。</p>
<p><a href="">四种文件之间的转换</a></p>
<p>下面介绍本文要用到的四个概念（Java Source，Java Class，ASM Code，ASM Source）</p>
<ul>
<li>Java Source: 即我们通常编写的 Java 源文件；</li>
<li>Java Class: Java 源文件编译后的字节码文件；</li>
<li>ASM Source : 类似于对 class 反编译后的源文件，也就是 &quot;textual byte code&quot;，但比原始的 Java Source 可读性要差， 参见清单 5。</li>
<li>ASM Code: 指读写 class 文件的 ASM 程序代码。需要用到 ASM 提供的 API， 参见清单 6。
<a href=""><strong>清单 5. SayHelloImpl 类对应的 ASM Source</strong></a>01</li>
</ul>
<p>// class version 50.0 (50)</p>
<p>02</p>
<p>// access flags 33
03</p>
<p>public</p>
<p>class</p>
<p>com/ibm/was/asm/SayHelloImpl {</p>
<p>04</p>
<p>05</p>
<p>// access flags 1</p>
<p>06</p>
<p>public</p>
<p><init>()V
07</p>
<p>ALOAD </p>
<p>0</p>
<p>08</p>
<p>INVOKESPECIAL java/lang/Object. <init> ()V
09</p>
<p>RETURN</p>
<p>10</p>
<p>MAXSTACK = </p>
<p>1
11</p>
<p>MAXLOCALS = </p>
<p>1</p>
<p>12</p>
<p>13</p>
<p>// access flags 1</p>
<p>14</p>
<p>public</p>
<p>sayHello(Ljava/lang/String;)Ljava/lang/String;
15</p>
<p>NEW java/lang/StringBuilder</p>
<p>16</p>
<p>DUP
17</p>
<p>LDC </p>
<p>&quot;Hello:&quot;</p>
<p>18</p>
<p>INVOKESPECIAL java/lang/StringBuilder. <init> (Ljava/lang/String;)V
19</p>
<p>ALOAD </p>
<p>1</p>
<p>20</p>
<p>INVOKEVIRTUAL java/lang/StringBuilder.append (Ljava/lang/String;)
21</p>
<p>Ljava/lang/StringBuilder;</p>
<p>22</p>
<p>INVOKEVIRTUAL java/lang/StringBuilder.toString ()Ljava/lang/String;
23</p>
<p>ARETURN</p>
<p>24</p>
<p>MAXSTACK = </p>
<p>3
25</p>
<p>MAXLOCALS = </p>
<p>2</p>
<p>26</p>
<p>}<a href=""><strong>清单 6. 生成 SayHelloImpl.class 的 ASM Code</strong></a>01</p>
<p>package</p>
<p>asm.com.ibm.was.asm;</p>
<p>02</p>
<p>import</p>
<p>java.util./*;
03</p>
<p>import</p>
<p>org.objectweb.asm./*;</p>
<p>04</p>
<p>import</p>
<p>org.objectweb.asm.attrs./*;
05</p>
<p>public</p>
<p>class</p>
<p>SayHelloImplDump </p>
<p>implements</p>
<p>Opcodes {</p>
<p>06</p>
<p>public</p>
<p>static</p>
<p>byte</p>
<p>[] dump () </p>
<p>throws</p>
<p>Exception {
07</p>
<p>ClassWriter cw = </p>
<p>new</p>
<p>ClassWriter(</p>
<p>0</p>
<p>);</p>
<p>08</p>
<p>FieldVisitor fv;
09</p>
<p>MethodVisitor mv;</p>
<p>10</p>
<p>AnnotationVisitor av0;
11</p>
<p>12</p>
<p>cw.visit(V1_6, ACC_PUBLIC + ACC_SUPER, </p>
<p>&quot;com/ibm/was/asm/SayHelloImpl&quot;</p>
<p>,
13</p>
<p>null</p>
<p>, </p>
<p>&quot;java/lang/Object&quot;</p>
<p>, </p>
<p>null</p>
<p>);</p>
<p>14</p>
<p>15</p>
<p>{</p>
<p>16</p>
<p>mv = cw.visitMethod(ACC_PUBLIC, </p>
<p>&quot;<init>&quot;</p>
<p>, </p>
<p>&quot;()V&quot;</p>
<p>, </p>
<p>null</p>
<p>, </p>
<p>null</p>
<p>);
17</p>
<p>mv.visitCode();</p>
<p>18</p>
<p>mv.visitVarInsn(ALOAD, </p>
<p>0</p>
<p>);
19</p>
<p>mv.visitMethodInsn(INVOKESPECIAL, </p>
<p>&quot;java/lang/Object&quot;</p>
<p>, </p>
<p>&quot;<init>&quot;</p>
<p>, </p>
<p>&quot;()V&quot;</p>
<p>);</p>
<p>20</p>
<p>mv.visitInsn(RETURN);
21</p>
<p>mv.visitMaxs(</p>
<p>1</p>
<p>, </p>
<p>1</p>
<p>);</p>
<p>22</p>
<p>mv.visitEnd();
23</p>
<p>}</p>
<p>24</p>
<p>{
25</p>
<p>mv = cw.visitMethod(ACC_PUBLIC, </p>
<p>&quot;sayHello&quot;</p>
<p>,</p>
<p>26</p>
<p>&quot;(Ljava/lang/String;)Ljava/lang/String;&quot;</p>
<p>, </p>
<p>null</p>
<p>, </p>
<p>null</p>
<p>);
27</p>
<p>mv.visitCode();</p>
<p>28</p>
<p>mv.visitTypeInsn(NEW, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>);
29</p>
<p>mv.visitInsn(DUP);</p>
<p>30</p>
<p>mv.visitLdcInsn(</p>
<p>&quot;Hello:&quot;</p>
<p>);
31</p>
<p>mv.visitMethodInsn(INVOKESPECIAL, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>,</p>
<p>32</p>
<p>&quot;<init>&quot;</p>
<p>, </p>
<p>&quot;(Ljava/lang/String;)V&quot;</p>
<p>);
33</p>
<p>mv.visitVarInsn(ALOAD, </p>
<p>1</p>
<p>);</p>
<p>34</p>
<p>mv.visitMethodInsn(INVOKEVIRTUAL, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>,
35</p>
<p>&quot;append&quot;</p>
<p>, </p>
<p>&quot;(Ljava/lang/String;)Ljava/lang/StringBuilder;&quot;</p>
<p>);</p>
<p>36</p>
<p>mv.visitMethodInsn(INVOKEVIRTUAL, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>,
37</p>
<p>&quot;toString&quot;</p>
<p>, </p>
<p>&quot;()Ljava/lang/String;&quot;</p>
<p>);</p>
<p>38</p>
<p>mv.visitInsn(ARETURN);
39</p>
<p>mv.visitMaxs(</p>
<p>3</p>
<p>, </p>
<p>2</p>
<p>);</p>
<p>40</p>
<p>mv.visitEnd();
41</p>
<p>}</p>
<p>42</p>
<p>cw.visitEnd();
43</p>
<p>return</p>
<p>cw.toByteArray();</p>
<p>44</p>
<p>}
45</p>
<p>}</p>
<p>图 1 描述了 Java Source 文件、Java Class 文件、ASM Code 文件和 ASM Source 文件之间的转换关系。
<a href=""><strong>图 1. 四种文件的转换图</strong></a> 
<a href=""><img src="" alt="图 1. 四种文件的转换图"></a> </p>
<p>如图 -1 所示，Java Source 文件通过 Javac 可以转换为 Java Class 文件。而相应的 Java Class 文件通过 Java 反编译器工具可转换为 Java Source 文件；</p>
<p>通 过 ASM Code 去创建和修改 Java Class 需要对 ASM API 比较熟悉才行，一个常见的问题时，怎么用 ASM Code 生成一个我们希望的 class 文件， 也就是说， 给定了 Java Class， 怎么得到其对应的 ASM Code 呢？ 所幸的是， ASM 框架为我们提供了 ASMifierClassVisitor 工具来产生 Java Class 对应的 ASM Code。代码如下：
<a href=""><strong>清单 7. 给定 class 文件，通过 ASMifierClassVisitor 获得其对应的 ASM Code</strong></a><a href="http://www.oschina.net/question/129540_28430#viewSource" title="view source" target="_blank">view source</a><a href="http://www.oschina.net/question/129540_28430#printSource" title="print" target="_blank">print</a><a href="http://www.oschina.net/question/129540_28430#about" title="?" target="_blank">?</a></p>
<p>01</p>
<p>public</p>
<p>void</p>
<p>showClassASMProcess() {</p>
<p>02</p>
<p>ClassReader cr;
03</p>
<p>final</p>
<p>String n = SayHelloImpl.</p>
<p>class</p>
<p>.getName();</p>
<p>04</p>
<p>05</p>
<p>try</p>
<p>{</p>
<p>06</p>
<p>cr = </p>
<p>new</p>
<p>ClassReader(n);<br>07</p>
<p>cr.accept(</p>
<p>new</p>
<p>ASMifierClassVisitor(</p>
<p>new</p>
<p>PrintWriter(System.out)),</p>
<p>08</p>
<p>new</p>
<p>Attribute[</p>
<p>0</p>
<p>],
09</p>
<p>ClassReader.SKIP_DEBUG);</p>
<p>10</p>
<p>11</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {</p>
<p>12</p>
<p>e.printStackTrace();
13</p>
<p>}</p>
<p>14</p>
<p>}</p>
<p>另外一个重要的转换就是， 给定了 Java Class 文件， 如何查看它的 ASM Source ？ 这点对于我们验证 ASM Code 生成的 class 是否正确很有用。ASM 提供了另外一个工具 TraceClassVisitor， 来获得一个 Java Class 对应的 ASM Source。代码如下：
<a href=""><strong>清单 8. 利用 TraceClassVisitor 查看 class 文件的 ASM Source</strong></a>01</p>
<p>//file 是 class 文件的全路径名</p>
<p>02</p>
<p>public</p>
<p>void</p>
<p>showClassSource(String file) {
03</p>
<p>FileInputStream is ;</p>
<p>04</p>
<p>ClassReader cr; 
05</p>
<p>06</p>
<p>try</p>
<p>{
07</p>
<p>is = </p>
<p>new</p>
<p>FileInputStream(file);     </p>
<p>08</p>
<p>cr = </p>
<p>new</p>
<p>ClassReader(is);
09</p>
<p>TraceClassVisitor trace = </p>
<p>new</p>
<p>TraceClassVisitor(</p>
<p>new</p>
<p>PrintWriter(System.out));</p>
<p>10</p>
<p>cr.accept(trace, ClassReader.SKIP_DEBUG);
11</p>
<p>12</p>
<p>is.close() ;
13</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {</p>
<p>14</p>
<p>e.printStackTrace() ;
15</p>
<p>}</p>
<p>16</p>
<p>}
17</p>
<p>{</p>
<p>18</p>
<p>e.printStackTrace();
19</p>
<p>}</p>
<p>20</p>
<p>}</p>
<p><a href="">ASM 类注入</a></p>
<p>ASM 类注入是指修改一个现有的 class 文件，在其中加入自己的代码。按通常思维，我们需要利用 ASM 提供的 reader 类去读取所要修改的类文件， 找到要修改的地方，如方法名或属性名，然后在该处插入自己的代码或修改现有的代码，这种思路将使问题复杂化。 ASM 为我们提供了访问类文件的 Visitor 模式，来遍历一个 class 文件，Visitor 是一个实现 ClassVisitor 接口的类。 要注入一个 class 文件，先要找到一个合适的 Visitor 做向导， ASM 提供了好几种 Visitor， 最常用的是 ClassWriter。同时我们需要提供一个适配器类 ClassAdapter， Visitor 会带着这个 Adapter 一起去遍历， 然后在遍历过程中回调 Adapter 提供的方法。我们在 Adapter 的这些方法中就可以实现我们的修改和定制逻辑。当然，如果你不想做任何修改，那 Visitor 遍历完后将得到一个和被遍历的 class 完全一样的拷贝。
<a href=""><strong>清单 9. 类注入的完整过程</strong></a>01</p>
<p>public</p>
<p>void</p>
<p>addAnnotationToExistingClass() {</p>
<p>02</p>
<p>FileInputStream is ;
03</p>
<p>ClassReader cr;          </p>
<p>04</p>
<p>try</p>
<p>{<br>05</p>
<p>String classfile = </p>
<p>&quot;E:\SayHelloImpl.class&quot;</p>
<p>; </p>
<p>// 待遍历的类</p>
<p>06</p>
<p>showClassSource(classfile) ;  </p>
<p>// 打印该类的 ASM source
07</p>
<p>08</p>
<p>is = </p>
<p>new</p>
<p>FileInputStream(classfile);<br>09</p>
<p>cr = </p>
<p>new</p>
<p>ClassReader(is);</p>
<p>10</p>
<p>// 此处我们使用 ClassWriter 做 Visitor
11</p>
<p>ClassWriter cw = </p>
<p>new</p>
<p>ClassWriter(ClassWriter.COMPUTE_MAXS);</p>
<p>12</p>
<p>// 给 Visitor 提供一个 Adapter
13</p>
<p>AddAnnotationAdapter adapter = </p>
<p>new</p>
<p>AddAnnotationAdapter(cw);           </p>
<p>14</p>
<p>cr.accept(adapter, ClassReader.SKIP_DEBUG);<br>15</p>
<p>16</p>
<p>// 遍历完后，生成的 class 保存在字节数组中
17</p>
<p>byte</p>
<p>[] b = cw.toByteArray();</p>
<p>18</p>
<p>19</p>
<p>try</p>
<p>{</p>
<p>20</p>
<p>// 将字节数组输出到文件中
21</p>
<p>// 为了不至于覆盖掉原有的 SayHelloImpl.class 文件，我们将结果输出到 _SayHelloImpl.class</p>
<p>22</p>
<p>FileOutputStream fout = </p>
<p>new</p>
<p>FileOutputStream(</p>
<p>&quot;E:\_SayHelloImpl.class&quot;</p>
<p>);
23</p>
<p>fout.write(b) ;</p>
<p>24</p>
<p>fout.flush();
25</p>
<p>fout.close() ;</p>
<p>26</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {
27</p>
<p>e.printStackTrace() ;</p>
<p>28</p>
<p>}
29</p>
<p>30</p>
<p>// 验证 _SayHelloImpl.class 是否包含我们注入的代码
31</p>
<p>showClassSource(</p>
<p>&quot;E:\_SayHelloImpl.class&quot;</p>
<p>) ;</p>
<p>32</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {
33</p>
<p>e.printStackTrace();</p>
<p>34</p>
<p>} 
35</p>
<p>}</p>
<p><a href="">web services 标记注入过程</a></p>
<p>我们已经知道了如何往 class 中注入自己的代码，那对于一个已有的 Java bean，怎么往里注入 @WebService 和 @WebMethod 呢？根据上面我们讲的转换关系，我们可以先写一个带 annotation 的 Java Source，编译得到 Java Class， 再得到其 ASM Code。下面是利用 ASM 给一个不带任何 Annotation 的 class 添加 @WebService 和 @WebMethod 的步骤。</p>
<ol>
<li>首先在 SayHelloImpl.java 中添加 @WebService 和 @WebMethod： 
<a href=""><strong>清单 10. 带 web services 标注的 SayHelloImpl 类</strong></a>1</li>
</ol>
<p>@WebService</p>
<p>2</p>
<p>public</p>
<p>class</p>
<p>SayHelloImpl {
3</p>
<p>@WebMethod</p>
<p>4</p>
<p>public</p>
<p>String sayHello(String s) {
5</p>
<p>return</p>
<p>&quot;Hello: &quot;</p>
<ul>
<li>s ;</li>
</ul>
<p>6</p>
<p>}
7</p>
<p>}</p>
<ol>
<li>通过 ASMifierClassVisitor 工具获得 SayHelloImpl class 的 ASM Code，见清单 6。</li>
<li>写一个 ClassAdapter 类， ClassAdapter 其实也是一个 Visitor。根据 ASM Code 的提示， 我们就可以知道如何利用 ASM API 去获得我们希望的 class 文件。下面是 Adapter 的示例代码。 
<a href=""><strong>清单 11. 添加 Annotation 的 Adapter 类</strong></a>01</li>
</ol>
<p>public</p>
<p>class</p>
<p>AddAnnotationAdapter </p>
<p>extends</p>
<p>ClassAdapter </p>
<p>implements</p>
<p>Opcodes{</p>
<p>02</p>
<p>//private String annotationDesc;
03</p>
<p>private</p>
<p>boolean</p>
<p>isAnnotationPresent;</p>
<p>04</p>
<p>05</p>
<p>public</p>
<p>AddAnnotationAdapter(ClassVisitor cv) {</p>
<p>06</p>
<p>super</p>
<p>(cv);
07</p>
<p>}</p>
<p>08</p>
<p>09</p>
<p>@Override</p>
<p>10</p>
<p>public</p>
<p>void</p>
<p>visit(</p>
<p>int</p>
<p>version, </p>
<p>int</p>
<p>access, String name, String signature,
11</p>
<p>String superName, String[] interfaces) {</p>
<p>12</p>
<p>13</p>
<p>cv.visit(V1_6, ACC_PUBLIC + ACC_SUPER, name, signature, superName,</p>
<p>14</p>
<p>interfaces);
15</p>
<p>AnnotationVisitor av0;</p>
<p>16</p>
<p>av0 = cv.visitAnnotation(</p>
<p>&quot;Ljavax/jws/WebService;&quot;</p>
<p>, </p>
<p>true</p>
<p>);
17</p>
<p>av0.visitEnd();</p>
<p>18</p>
<p>}
19</p>
<p>20</p>
<p>@Override
21</p>
<p>public</p>
<p>AnnotationVisitor visitAnnotation(String desc, </p>
<p>boolean</p>
<p>visible) {</p>
<p>22</p>
<p>return</p>
<p>cv.visitAnnotation(desc, visible);
23</p>
<p>}</p>
<p>24</p>
<p>25</p>
<p>@Override</p>
<p>26</p>
<p>public</p>
<p>void</p>
<p>visitInnerClass(String name, String outerName,
27</p>
<p>String innerName, </p>
<p>int</p>
<p>access) {</p>
<p>28</p>
<p>cv.visitInnerClass(name, outerName, innerName, access);
29</p>
<p>}</p>
<p>30</p>
<p>31</p>
<p>@Override</p>
<p>32</p>
<p>public</p>
<p>FieldVisitor visitField(</p>
<p>int</p>
<p>access, String name, String desc,
33</p>
<p>String signature, Object value) {</p>
<p>34</p>
<p>return</p>
<p>cv.visitField(access, name, desc, signature, value);
35</p>
<p>}</p>
<p>36</p>
<p>37</p>
<p>@Override</p>
<p>38</p>
<p>public</p>
<p>MethodVisitor visitMethod(</p>
<p>int</p>
<p>access, String name, String desc,
39</p>
<p>String signature, String[] exceptions) {   </p>
<p>40</p>
<p>MethodVisitor mv  = cv.visitMethod(access, name, desc, signature,
41</p>
<p>exceptions);</p>
<p>42</p>
<p>if</p>
<p>(!name.equals(</p>
<p>&quot;<init>&quot;</p>
<p>)) {
43</p>
<p>AnnotationVisitor av0;</p>
<p>44</p>
<p>av0 = mv.visitAnnotation(</p>
<p>&quot;Ljavax/jws/WebMethod;&quot;</p>
<p>, </p>
<p>true</p>
<p>);
45</p>
<p>av0.visitEnd();</p>
<p>46</p>
<p>}
47</p>
<p>return</p>
<p>mv;</p>
<p>48</p>
<p>}
49</p>
<p>50</p>
<p>@Override
51</p>
<p>public</p>
<p>void</p>
<p>visitEnd() {</p>
<p>52</p>
<p>cv.visitEnd();
53</p>
<p>}</p>
<p>54</p>
<p>55</p>
<p>}</p>
<p>最后，我们采用上面讲的类注入办法，即可得到一个带 @WebService 和 @WebMethod 标注的 class 文件。再通过 wsgen 工具即可成功创建 web services，该命令将会在 src 目录下生成 web services 描述文件：SayHelloImplService.wsdl，SayHelloImplService_schema1.xsd，同时生成了 2 个 JAX-WS 文件，分别为：SayHello.java，SayHelloResponse.java。</p>
<p>当然，在实际应用中，我们可能需要将一个 class 的某些特定方法发布为 web services，这就需要我们对 Adapter 做进一步的改造，在 visitMethod() 方法中根据方法名称等参数做进一步的处理。</p>
<p><a href="">结束语</a></p>
<p>本文简要介绍了 ASM 字节码工具及其在 web services 开发中的应用。web services 的使用已经越来越广泛， 但在改造遗留系统过程中会遇到不少问题，本文针对其中一个主要问题给出了解决办法，该方法无须对现有系统做大量的改动， 即可将现存的 Java bean 转化成 web services 。本文对那些正考虑迁移到 JAX-WS 编程模型上的项目有一定的参考价值。在基于 JAX-WS 标准的 web services 的开发中，不少实际场景都是希望采用自底向上的开发方式， 即基于已有的 Java bean 来创建 web services 。WebSphere Application Server ( 以下简称 WAS ) 提供了命令行的工具 wsgen 和相对应的 Ant task 来支持这种开发过程，而且这两个工具比较适合大型项目的自动化构建。 这两个工具的使用前提是 Java bean 中事先添加有 web services 的 Annotation 标注，而在现有的业务系统中，class 文件一般是不带 Annotation 的，这就需要开发人员去修改现有的代码，以手工方式添加 Annotation，但这样带来的工作量太大且容易出错。本文介绍了一种解决途径，可以不用修改源代码，而是利用字节码工具 ASM 直接修改 class 文件， 在字节码文件中自动注入 Annotation ，然后再利用 wsgen 工具就可以很方便地生成 web services 应用。 本文同时也总结了使用 ASM 的一些实践。</p>
<p>本文首先介绍了和 ASM 使用相关的四种文件，以及它们之间的相互转化。然后结合 web services 开发实例，介绍了使用 wsgen 开发时遇到的实际问题，如何写一个 ASM 的适配器去修改现有 class，最终如何产生 web services 文件。</p>
<p>ASM 是一个多用途的 Java 字节码操控和分析框架。它能以二进制的形式直接修改现有的类或动态生成的类。 ASM 提供了常用的转换和分析算法，是一种允许用户方便的组装定制化的复杂转换和代码分析工具。 ASM 也提供和其它的字节码工具类似的功能，但 ASM 的重点是使用的简单和高性能。由于 ASM 在设计实现的时候尽可能 的小的内存占用和提供更高的性能；因此在动态系统中使用 ASM 是很有优势的。ASM 作为一种轻量级、高性能的 Java 字节码操控和分析框架，设计了一种更有效的方法、提供更好的性能和内存占用。今天， ASM 在许多领域都有应用，并已成为事实上的字节码处理框架标准。</p>
<p><a href="">问题的引入</a></p>
<p>先写一个不带 web services 标注的 SayHelloImpl 类。
<a href=""><strong>清单 1. 不带 web services 的 SayHelloImpl 类</strong></a>1</p>
<p>public</p>
<p>class</p>
<p>SayHelloImpl {</p>
<p>2</p>
<p>public</p>
<p>String sayHello(String s) {
3</p>
<p>return</p>
<p>“Hello: ” + s ;</p>
<p>4</p>
<p>}
5</p>
<p>}</p>
<p>再用 wsgen 来创建 web services，wsgen 的使用如下：
<a href=""><strong>清单 2. wsgen 实例</strong></a>1</p>
<p>wsgen.exe – </p>
<p>cp</p>
<p>bin – s output – d output – r output – wsdl ibm.was.asm.SayHelloImpl我们将会遇到如下错误： 
<a href=""><strong>清单 3. 根据不带 web services 标注的类创建 web services 时遇到的错误信息</strong></a> 
注释处理过程中遇到问题；</p>
<p>......
com.sun.tools.internal.ws.processor.modeler.ModelerException: [failed to localiz</p>
<p>e] A web service endpoint could not be found()
        at com.sun.tools.internal.ws.processor.modeler.annotation.WebServiceAP.o</p>
<p>nError(WebServiceAP.java:215)
        at com.sun.tools.internal.ws.processor.modeler.annotation.WebServiceAP.b</p>
<p>uildModel(WebServiceAP.java:322)
        at com.sun.tools.internal.ws.processor.modeler.annotation.WebServiceAP.p</p>
<p>rocess(WebServiceAP.java:256)
        at com.sun.mirror.apt.AnnotationProcessors$CompositeAnnotationProcessor.</p>
<p>process(AnnotationProcessors.java:60)</p>
<p>注意：我们通常是在 class 前使用 @WebService， 在方法前使用 @WebMethod 来将一个类标注为 web services 的。WAS 6.1 的 web services 功能部件包和 WAS 7 都支持基于 JAX-WS 标准 的 web services 的开发， 在 WAS 安装目录的 bin 目录下提供了命令行工具 wsgen，wsgen 支持自底向上的开发方式。 下面是 wsgen 的用法：
<a href=""><strong>清单 4. wsgen 命令格式</strong></a> 
注 wsgen [options]  [SEI]</p>
<p>主要选项：</p>
<ul>
<li>-d 指定生成的 class 文件位置；</li>
<li>-s 指定生成的 Java 源文件位置；</li>
<li>-r 指定生成的 resources 文件位置，如 wsdl，xsd；</li>
<li>-cp 指定服务实现类所在的位置；</li>
<li>-wsdl，-servicename，-portname 三个参数指定生成的 wsdl 文件中的 service 和 port 的名称。</li>
</ul>
<p>SEI(Service Endpoint Interface) 是一个 endpoint implementation class，不能是一个 interface。所以首先要开发一个 endpoint 的实现类，如本例中的 SayHelloImpl 。用 @WebService 声明 web services ，然后将它编译，才能提供给 wsgen 来创建 web services 。</p>
<p><a href="">四种文件之间的转换</a></p>
<p>下面介绍本文要用到的四个概念（Java Source，Java Class，ASM Code，ASM Source）</p>
<ul>
<li>Java Source: 即我们通常编写的 Java 源文件；</li>
<li>Java Class: Java 源文件编译后的字节码文件；</li>
<li>ASM Source : 类似于对 class 反编译后的源文件，也就是 &quot;textual byte code&quot;，但比原始的 Java Source 可读性要差， 参见清单 5。</li>
<li>ASM Code: 指读写 class 文件的 ASM 程序代码。需要用到 ASM 提供的 API， 参见清单 6。
<a href=""><strong>清单 5. SayHelloImpl 类对应的 ASM Source</strong></a>01</li>
</ul>
<p>// class version 50.0 (50)</p>
<p>02</p>
<p>// access flags 33
03</p>
<p>public</p>
<p>class</p>
<p>com/ibm/was/asm/SayHelloImpl {</p>
<p>04</p>
<p>05</p>
<p>// access flags 1</p>
<p>06</p>
<p>public</p>
<p><init>()V
07</p>
<p>ALOAD </p>
<p>0</p>
<p>08</p>
<p>INVOKESPECIAL java/lang/Object. <init> ()V
09</p>
<p>RETURN</p>
<p>10</p>
<p>MAXSTACK = </p>
<p>1
11</p>
<p>MAXLOCALS = </p>
<p>1</p>
<p>12</p>
<p>13</p>
<p>// access flags 1</p>
<p>14</p>
<p>public</p>
<p>sayHello(Ljava/lang/String;)Ljava/lang/String;
15</p>
<p>NEW java/lang/StringBuilder</p>
<p>16</p>
<p>DUP
17</p>
<p>LDC </p>
<p>&quot;Hello:&quot;</p>
<p>18</p>
<p>INVOKESPECIAL java/lang/StringBuilder. <init> (Ljava/lang/String;)V
19</p>
<p>ALOAD </p>
<p>1</p>
<p>20</p>
<p>INVOKEVIRTUAL java/lang/StringBuilder.append (Ljava/lang/String;)
21</p>
<p>Ljava/lang/StringBuilder;</p>
<p>22</p>
<p>INVOKEVIRTUAL java/lang/StringBuilder.toString ()Ljava/lang/String;
23</p>
<p>ARETURN</p>
<p>24</p>
<p>MAXSTACK = </p>
<p>3
25</p>
<p>MAXLOCALS = </p>
<p>2</p>
<p>26</p>
<p>}<a href=""><strong>清单 6. 生成 SayHelloImpl.class 的 ASM Code</strong></a>01</p>
<p>package</p>
<p>asm.com.ibm.was.asm;</p>
<p>02</p>
<p>import</p>
<p>java.util./*;
03</p>
<p>import</p>
<p>org.objectweb.asm./*;</p>
<p>04</p>
<p>import</p>
<p>org.objectweb.asm.attrs./*;
05</p>
<p>public</p>
<p>class</p>
<p>SayHelloImplDump </p>
<p>implements</p>
<p>Opcodes {</p>
<p>06</p>
<p>public</p>
<p>static</p>
<p>byte</p>
<p>[] dump () </p>
<p>throws</p>
<p>Exception {
07</p>
<p>ClassWriter cw = </p>
<p>new</p>
<p>ClassWriter(</p>
<p>0</p>
<p>);</p>
<p>08</p>
<p>FieldVisitor fv;
09</p>
<p>MethodVisitor mv;</p>
<p>10</p>
<p>AnnotationVisitor av0;
11</p>
<p>12</p>
<p>cw.visit(V1_6, ACC_PUBLIC + ACC_SUPER, </p>
<p>&quot;com/ibm/was/asm/SayHelloImpl&quot;</p>
<p>,
13</p>
<p>null</p>
<p>, </p>
<p>&quot;java/lang/Object&quot;</p>
<p>, </p>
<p>null</p>
<p>);</p>
<p>14</p>
<p>15</p>
<p>{</p>
<p>16</p>
<p>mv = cw.visitMethod(ACC_PUBLIC, </p>
<p>&quot;<init>&quot;</p>
<p>, </p>
<p>&quot;()V&quot;</p>
<p>, </p>
<p>null</p>
<p>, </p>
<p>null</p>
<p>);
17</p>
<p>mv.visitCode();</p>
<p>18</p>
<p>mv.visitVarInsn(ALOAD, </p>
<p>0</p>
<p>);
19</p>
<p>mv.visitMethodInsn(INVOKESPECIAL, </p>
<p>&quot;java/lang/Object&quot;</p>
<p>, </p>
<p>&quot;<init>&quot;</p>
<p>, </p>
<p>&quot;()V&quot;</p>
<p>);</p>
<p>20</p>
<p>mv.visitInsn(RETURN);
21</p>
<p>mv.visitMaxs(</p>
<p>1</p>
<p>, </p>
<p>1</p>
<p>);</p>
<p>22</p>
<p>mv.visitEnd();
23</p>
<p>}</p>
<p>24</p>
<p>{
25</p>
<p>mv = cw.visitMethod(ACC_PUBLIC, </p>
<p>&quot;sayHello&quot;</p>
<p>,</p>
<p>26</p>
<p>&quot;(Ljava/lang/String;)Ljava/lang/String;&quot;</p>
<p>, </p>
<p>null</p>
<p>, </p>
<p>null</p>
<p>);
27</p>
<p>mv.visitCode();</p>
<p>28</p>
<p>mv.visitTypeInsn(NEW, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>);
29</p>
<p>mv.visitInsn(DUP);</p>
<p>30</p>
<p>mv.visitLdcInsn(</p>
<p>&quot;Hello:&quot;</p>
<p>);
31</p>
<p>mv.visitMethodInsn(INVOKESPECIAL, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>,</p>
<p>32</p>
<p>&quot;<init>&quot;</p>
<p>, </p>
<p>&quot;(Ljava/lang/String;)V&quot;</p>
<p>);
33</p>
<p>mv.visitVarInsn(ALOAD, </p>
<p>1</p>
<p>);</p>
<p>34</p>
<p>mv.visitMethodInsn(INVOKEVIRTUAL, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>,
35</p>
<p>&quot;append&quot;</p>
<p>, </p>
<p>&quot;(Ljava/lang/String;)Ljava/lang/StringBuilder;&quot;</p>
<p>);</p>
<p>36</p>
<p>mv.visitMethodInsn(INVOKEVIRTUAL, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>,
37</p>
<p>&quot;toString&quot;</p>
<p>, </p>
<p>&quot;()Ljava/lang/String;&quot;</p>
<p>);</p>
<p>38</p>
<p>mv.visitInsn(ARETURN);
39</p>
<p>mv.visitMaxs(</p>
<p>3</p>
<p>, </p>
<p>2</p>
<p>);</p>
<p>40</p>
<p>mv.visitEnd();
41</p>
<p>}</p>
<p>42</p>
<p>cw.visitEnd();
43</p>
<p>return</p>
<p>cw.toByteArray();</p>
<p>44</p>
<p>}
45</p>
<p>}</p>
<p>图 1 描述了 Java Source 文件、Java Class 文件、ASM Code 文件和 ASM Source 文件之间的转换关系。
<a href=""><strong>图 1. 四种文件的转换图</strong></a> 
<a href=""><img src="" alt="图 1. 四种文件的转换图"></a> </p>
<p>如图 -1 所示，Java Source 文件通过 Javac 可以转换为 Java Class 文件。而相应的 Java Class 文件通过 Java 反编译器工具可转换为 Java Source 文件；</p>
<p>通 过 ASM Code 去创建和修改 Java Class 需要对 ASM API 比较熟悉才行，一个常见的问题时，怎么用 ASM Code 生成一个我们希望的 class 文件， 也就是说， 给定了 Java Class， 怎么得到其对应的 ASM Code 呢？ 所幸的是， ASM 框架为我们提供了 ASMifierClassVisitor 工具来产生 Java Class 对应的 ASM Code。代码如下：
<a href=""><strong>清单 7. 给定 class 文件，通过 ASMifierClassVisitor 获得其对应的 ASM Code</strong></a><a href="http://www.oschina.net/question/129540_28430#viewSource" title="view source" target="_blank">view source</a><a href="http://www.oschina.net/question/129540_28430#printSource" title="print" target="_blank">print</a><a href="http://www.oschina.net/question/129540_28430#about" title="?" target="_blank">?</a></p>
<p>01</p>
<p>public</p>
<p>void</p>
<p>showClassASMProcess() {</p>
<p>02</p>
<p>ClassReader cr;
03</p>
<p>final</p>
<p>String n = SayHelloImpl.</p>
<p>class</p>
<p>.getName();</p>
<p>04</p>
<p>05</p>
<p>try</p>
<p>{</p>
<p>06</p>
<p>cr = </p>
<p>new</p>
<p>ClassReader(n);<br>07</p>
<p>cr.accept(</p>
<p>new</p>
<p>ASMifierClassVisitor(</p>
<p>new</p>
<p>PrintWriter(System.out)),</p>
<p>08</p>
<p>new</p>
<p>Attribute[</p>
<p>0</p>
<p>],
09</p>
<p>ClassReader.SKIP_DEBUG);</p>
<p>10</p>
<p>11</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {</p>
<p>12</p>
<p>e.printStackTrace();
13</p>
<p>}</p>
<p>14</p>
<p>}</p>
<p>另外一个重要的转换就是， 给定了 Java Class 文件， 如何查看它的 ASM Source ？ 这点对于我们验证 ASM Code 生成的 class 是否正确很有用。ASM 提供了另外一个工具 TraceClassVisitor， 来获得一个 Java Class 对应的 ASM Source。代码如下：
<a href=""><strong>清单 8. 利用 TraceClassVisitor 查看 class 文件的 ASM Source</strong></a>01</p>
<p>//file 是 class 文件的全路径名</p>
<p>02</p>
<p>public</p>
<p>void</p>
<p>showClassSource(String file) {
03</p>
<p>FileInputStream is ;</p>
<p>04</p>
<p>ClassReader cr; 
05</p>
<p>06</p>
<p>try</p>
<p>{
07</p>
<p>is = </p>
<p>new</p>
<p>FileInputStream(file);     </p>
<p>08</p>
<p>cr = </p>
<p>new</p>
<p>ClassReader(is);
09</p>
<p>TraceClassVisitor trace = </p>
<p>new</p>
<p>TraceClassVisitor(</p>
<p>new</p>
<p>PrintWriter(System.out));</p>
<p>10</p>
<p>cr.accept(trace, ClassReader.SKIP_DEBUG);
11</p>
<p>12</p>
<p>is.close() ;
13</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {</p>
<p>14</p>
<p>e.printStackTrace() ;
15</p>
<p>}</p>
<p>16</p>
<p>}
17</p>
<p>{</p>
<p>18</p>
<p>e.printStackTrace();
19</p>
<p>}</p>
<p>20</p>
<p>}</p>
<p><a href="">ASM 类注入</a></p>
<p>ASM 类注入是指修改一个现有的 class 文件，在其中加入自己的代码。按通常思维，我们需要利用 ASM 提供的 reader 类去读取所要修改的类文件， 找到要修改的地方，如方法名或属性名，然后在该处插入自己的代码或修改现有的代码，这种思路将使问题复杂化。 ASM 为我们提供了访问类文件的 Visitor 模式，来遍历一个 class 文件，Visitor 是一个实现 ClassVisitor 接口的类。 要注入一个 class 文件，先要找到一个合适的 Visitor 做向导， ASM 提供了好几种 Visitor， 最常用的是 ClassWriter。同时我们需要提供一个适配器类 ClassAdapter， Visitor 会带着这个 Adapter 一起去遍历， 然后在遍历过程中回调 Adapter 提供的方法。我们在 Adapter 的这些方法中就可以实现我们的修改和定制逻辑。当然，如果你不想做任何修改，那 Visitor 遍历完后将得到一个和被遍历的 class 完全一样的拷贝。
<a href=""><strong>清单 9. 类注入的完整过程</strong></a>01</p>
<p>public</p>
<p>void</p>
<p>addAnnotationToExistingClass() {</p>
<p>02</p>
<p>FileInputStream is ;
03</p>
<p>ClassReader cr;          </p>
<p>04</p>
<p>try</p>
<p>{<br>05</p>
<p>String classfile = </p>
<p>&quot;E:\SayHelloImpl.class&quot;</p>
<p>; </p>
<p>// 待遍历的类</p>
<p>06</p>
<p>showClassSource(classfile) ;  </p>
<p>// 打印该类的 ASM source
07</p>
<p>08</p>
<p>is = </p>
<p>new</p>
<p>FileInputStream(classfile);<br>09</p>
<p>cr = </p>
<p>new</p>
<p>ClassReader(is);</p>
<p>10</p>
<p>// 此处我们使用 ClassWriter 做 Visitor
11</p>
<p>ClassWriter cw = </p>
<p>new</p>
<p>ClassWriter(ClassWriter.COMPUTE_MAXS);</p>
<p>12</p>
<p>// 给 Visitor 提供一个 Adapter
13</p>
<p>AddAnnotationAdapter adapter = </p>
<p>new</p>
<p>AddAnnotationAdapter(cw);           </p>
<p>14</p>
<p>cr.accept(adapter, ClassReader.SKIP_DEBUG);<br>15</p>
<p>16</p>
<p>// 遍历完后，生成的 class 保存在字节数组中
17</p>
<p>byte</p>
<p>[] b = cw.toByteArray();</p>
<p>18</p>
<p>19</p>
<p>try</p>
<p>{</p>
<p>20</p>
<p>// 将字节数组输出到文件中
21</p>
<p>// 为了不至于覆盖掉原有的 SayHelloImpl.class 文件，我们将结果输出到 _SayHelloImpl.class</p>
<p>22</p>
<p>FileOutputStream fout = </p>
<p>new</p>
<p>FileOutputStream(</p>
<p>&quot;E:\_SayHelloImpl.class&quot;</p>
<p>);
23</p>
<p>fout.write(b) ;</p>
<p>24</p>
<p>fout.flush();
25</p>
<p>fout.close() ;</p>
<p>26</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {
27</p>
<p>e.printStackTrace() ;</p>
<p>28</p>
<p>}
29</p>
<p>30</p>
<p>// 验证 _SayHelloImpl.class 是否包含我们注入的代码
31</p>
<p>showClassSource(</p>
<p>&quot;E:\_SayHelloImpl.class&quot;</p>
<p>) ;</p>
<p>32</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {
33</p>
<p>e.printStackTrace();</p>
<p>34</p>
<p>} 
35</p>
<p>}</p>
<p><a href="">web services 标记注入过程</a></p>
<p>我们已经知道了如何往 class 中注入自己的代码，那对于一个已有的 Java bean，怎么往里注入 @WebService 和 @WebMethod 呢？根据上面我们讲的转换关系，我们可以先写一个带 annotation 的 Java Source，编译得到 Java Class， 再得到其 ASM Code。下面是利用 ASM 给一个不带任何 Annotation 的 class 添加 @WebService 和 @WebMethod 的步骤。</p>
<ol>
<li>首先在 SayHelloImpl.java 中添加 @WebService 和 @WebMethod： 
<a href=""><strong>清单 10. 带 web services 标注的 SayHelloImpl 类</strong></a>1</li>
</ol>
<p>@WebService</p>
<p>2</p>
<p>public</p>
<p>class</p>
<p>SayHelloImpl {
3</p>
<p>@WebMethod</p>
<p>4</p>
<p>public</p>
<p>String sayHello(String s) {
5</p>
<p>return</p>
<p>&quot;Hello: &quot;</p>
<ul>
<li>s ;</li>
</ul>
<p>6</p>
<p>}
7</p>
<p>}</p>
<ol>
<li>通过 ASMifierClassVisitor 工具获得 SayHelloImpl class 的 ASM Code，见清单 6。</li>
<li>写一个 ClassAdapter 类， ClassAdapter 其实也是一个 Visitor。根据 ASM Code 的提示， 我们就可以知道如何利用 ASM API 去获得我们希望的 class 文件。下面是 Adapter 的示例代码。 
<a href=""><strong>清单 11. 添加 Annotation 的 Adapter 类</strong></a>01</li>
</ol>
<p>public</p>
<p>class</p>
<p>AddAnnotationAdapter </p>
<p>extends</p>
<p>ClassAdapter </p>
<p>implements</p>
<p>Opcodes{</p>
<p>02</p>
<p>//private String annotationDesc;
03</p>
<p>private</p>
<p>boolean</p>
<p>isAnnotationPresent;</p>
<p>04</p>
<p>05</p>
<p>public</p>
<p>AddAnnotationAdapter(ClassVisitor cv) {</p>
<p>06</p>
<p>super</p>
<p>(cv);
07</p>
<p>}</p>
<p>08</p>
<p>09</p>
<p>@Override</p>
<p>10</p>
<p>public</p>
<p>void</p>
<p>visit(</p>
<p>int</p>
<p>version, </p>
<p>int</p>
<p>access, String name, String signature,
11</p>
<p>String superName, String[] interfaces) {</p>
<p>12</p>
<p>13</p>
<p>cv.visit(V1_6, ACC_PUBLIC + ACC_SUPER, name, signature, superName,</p>
<p>14</p>
<p>interfaces);
15</p>
<p>AnnotationVisitor av0;</p>
<p>16</p>
<p>av0 = cv.visitAnnotation(</p>
<p>&quot;Ljavax/jws/WebService;&quot;</p>
<p>, </p>
<p>true</p>
<p>);
17</p>
<p>av0.visitEnd();</p>
<p>18</p>
<p>}
19</p>
<p>20</p>
<p>@Override
21</p>
<p>public</p>
<p>AnnotationVisitor visitAnnotation(String desc, </p>
<p>boolean</p>
<p>visible) {</p>
<p>22</p>
<p>return</p>
<p>cv.visitAnnotation(desc, visible);
23</p>
<p>}</p>
<p>24</p>
<p>25</p>
<p>@Override</p>
<p>26</p>
<p>public</p>
<p>void</p>
<p>visitInnerClass(String name, String outerName,
27</p>
<p>String innerName, </p>
<p>int</p>
<p>access) {</p>
<p>28</p>
<p>cv.visitInnerClass(name, outerName, innerName, access);
29</p>
<p>}</p>
<p>30</p>
<p>31</p>
<p>@Override</p>
<p>32</p>
<p>public</p>
<p>FieldVisitor visitField(</p>
<p>int</p>
<p>access, String name, String desc,
33</p>
<p>String signature, Object value) {</p>
<p>34</p>
<p>return</p>
<p>cv.visitField(access, name, desc, signature, value);
35</p>
<p>}</p>
<p>36</p>
<p>37</p>
<p>@Override</p>
<p>38</p>
<p>public</p>
<p>MethodVisitor visitMethod(</p>
<p>int</p>
<p>access, String name, String desc,
39</p>
<p>String signature, String[] exceptions) {   </p>
<p>40</p>
<p>MethodVisitor mv  = cv.visitMethod(access, name, desc, signature,
41</p>
<p>exceptions);</p>
<p>42</p>
<p>if</p>
<p>(!name.equals(</p>
<p>&quot;<init>&quot;</p>
<p>)) {
43</p>
<p>AnnotationVisitor av0;</p>
<p>44</p>
<p>av0 = mv.visitAnnotation(</p>
<p>&quot;Ljavax/jws/WebMethod;&quot;</p>
<p>, </p>
<p>true</p>
<p>);
45</p>
<p>av0.visitEnd();</p>
<p>46</p>
<p>}
47</p>
<p>return</p>
<p>mv;</p>
<p>48</p>
<p>}
49</p>
<p>50</p>
<p>@Override
51</p>
<p>public</p>
<p>void</p>
<p>visitEnd() {</p>
<p>52</p>
<p>cv.visitEnd();
53</p>
<p>}</p>
<p>54</p>
<p>55</p>
<p>}</p>
<p>最后，我们采用上面讲的类注入办法，即可得到一个带 @WebService 和 @WebMethod 标注的 class 文件。再通过 wsgen 工具即可成功创建 web services，该命令将会在 src 目录下生成 web services 描述文件：SayHelloImplService.wsdl，SayHelloImplService_schema1.xsd，同时生成了 2 个 JAX-WS 文件，分别为：SayHello.java，SayHelloResponse.java。</p>
<p>当然，在实际应用中，我们可能需要将一个 class 的某些特定方法发布为 web services，这就需要我们对 Adapter 做进一步的改造，在 visitMethod() 方法中根据方法名称等参数做进一步的处理。</p>
<p><a href="">结束语</a></p>
<p>本文简要介绍了 ASM 字节码工具及其在 web services 开发中的应用。web services 的使用已经越来越广泛， 但在改造遗留系统过程中会遇到不少问题，本文针对其中一个主要问题给出了解决办法，该方法无须对现有系统做大量的改动， 即可将现存的 Java bean 转化成 web services 。本文对那些正考虑迁移到 JAX-WS 编程模型上的项目有一定的参考价值。在基于 JAX-WS 标准的 web services 的开发中，不少实际场景都是希望采用自底向上的开发方式， 即基于已有的 Java bean 来创建 web services 。WebSphere Application Server ( 以下简称 WAS ) 提供了命令行的工具 wsgen 和相对应的 Ant task 来支持这种开发过程，而且这两个工具比较适合大型项目的自动化构建。 这两个工具的使用前提是 Java bean 中事先添加有 web services 的 Annotation 标注，而在现有的业务系统中，class 文件一般是不带 Annotation 的，这就需要开发人员去修改现有的代码，以手工方式添加 Annotation，但这样带来的工作量太大且容易出错。本文介绍了一种解决途径，可以不用修改源代码，而是利用字节码工具 ASM 直接修改 class 文件， 在字节码文件中自动注入 Annotation ，然后再利用 wsgen 工具就可以很方便地生成 web services 应用。 本文同时也总结了使用 ASM 的一些实践。</p>
<p>本文首先介绍了和 ASM 使用相关的四种文件，以及它们之间的相互转化。然后结合 web services 开发实例，介绍了使用 wsgen 开发时遇到的实际问题，如何写一个 ASM 的适配器去修改现有 class，最终如何产生 web services 文件。</p>
<p>ASM 是一个多用途的 Java 字节码操控和分析框架。它能以二进制的形式直接修改现有的类或动态生成的类。 ASM 提供了常用的转换和分析算法，是一种允许用户方便的组装定制化的复杂转换和代码分析工具。 ASM 也提供和其它的字节码工具类似的功能，但 ASM 的重点是使用的简单和高性能。由于 ASM 在设计实现的时候尽可能 的小的内存占用和提供更高的性能；因此在动态系统中使用 ASM 是很有优势的。ASM 作为一种轻量级、高性能的 Java 字节码操控和分析框架，设计了一种更有效的方法、提供更好的性能和内存占用。今天， ASM 在许多领域都有应用，并已成为事实上的字节码处理框架标准。</p>
<p><a href="">问题的引入</a></p>
<p>先写一个不带 web services 标注的 SayHelloImpl 类。
<a href=""><strong>清单 1. 不带 web services 的 SayHelloImpl 类</strong></a>1</p>
<p>public</p>
<p>class</p>
<p>SayHelloImpl {</p>
<p>2</p>
<p>public</p>
<p>String sayHello(String s) {
3</p>
<p>return</p>
<p>“Hello: ” + s ;</p>
<p>4</p>
<p>}
5</p>
<p>}</p>
<p>再用 wsgen 来创建 web services，wsgen 的使用如下：
<a href=""><strong>清单 2. wsgen 实例</strong></a>1</p>
<p>wsgen.exe – </p>
<p>cp</p>
<p>bin – s output – d output – r output – wsdl ibm.was.asm.SayHelloImpl我们将会遇到如下错误： 
<a href=""><strong>清单 3. 根据不带 web services 标注的类创建 web services 时遇到的错误信息</strong></a> 
注释处理过程中遇到问题；</p>
<p>......
com.sun.tools.internal.ws.processor.modeler.ModelerException: [failed to localiz</p>
<p>e] A web service endpoint could not be found()
        at com.sun.tools.internal.ws.processor.modeler.annotation.WebServiceAP.o</p>
<p>nError(WebServiceAP.java:215)
        at com.sun.tools.internal.ws.processor.modeler.annotation.WebServiceAP.b</p>
<p>uildModel(WebServiceAP.java:322)
        at com.sun.tools.internal.ws.processor.modeler.annotation.WebServiceAP.p</p>
<p>rocess(WebServiceAP.java:256)
        at com.sun.mirror.apt.AnnotationProcessors$CompositeAnnotationProcessor.</p>
<p>process(AnnotationProcessors.java:60)</p>
<p>注意：我们通常是在 class 前使用 @WebService， 在方法前使用 @WebMethod 来将一个类标注为 web services 的。WAS 6.1 的 web services 功能部件包和 WAS 7 都支持基于 JAX-WS 标准 的 web services 的开发， 在 WAS 安装目录的 bin 目录下提供了命令行工具 wsgen，wsgen 支持自底向上的开发方式。 下面是 wsgen 的用法：
<a href=""><strong>清单 4. wsgen 命令格式</strong></a> 
注 wsgen [options]  [SEI]</p>
<p>主要选项：</p>
<ul>
<li>-d 指定生成的 class 文件位置；</li>
<li>-s 指定生成的 Java 源文件位置；</li>
<li>-r 指定生成的 resources 文件位置，如 wsdl，xsd；</li>
<li>-cp 指定服务实现类所在的位置；</li>
<li>-wsdl，-servicename，-portname 三个参数指定生成的 wsdl 文件中的 service 和 port 的名称。</li>
</ul>
<p>SEI(Service Endpoint Interface) 是一个 endpoint implementation class，不能是一个 interface。所以首先要开发一个 endpoint 的实现类，如本例中的 SayHelloImpl 。用 @WebService 声明 web services ，然后将它编译，才能提供给 wsgen 来创建 web services 。</p>
<p><a href="">四种文件之间的转换</a></p>
<p>下面介绍本文要用到的四个概念（Java Source，Java Class，ASM Code，ASM Source）</p>
<ul>
<li>Java Source: 即我们通常编写的 Java 源文件；</li>
<li>Java Class: Java 源文件编译后的字节码文件；</li>
<li>ASM Source : 类似于对 class 反编译后的源文件，也就是 &quot;textual byte code&quot;，但比原始的 Java Source 可读性要差， 参见清单 5。</li>
<li>ASM Code: 指读写 class 文件的 ASM 程序代码。需要用到 ASM 提供的 API， 参见清单 6。
<a href=""><strong>清单 5. SayHelloImpl 类对应的 ASM Source</strong></a>01</li>
</ul>
<p>// class version 50.0 (50)</p>
<p>02</p>
<p>// access flags 33
03</p>
<p>public</p>
<p>class</p>
<p>com/ibm/was/asm/SayHelloImpl {</p>
<p>04</p>
<p>05</p>
<p>// access flags 1</p>
<p>06</p>
<p>public</p>
<p><init>()V
07</p>
<p>ALOAD </p>
<p>0</p>
<p>08</p>
<p>INVOKESPECIAL java/lang/Object. <init> ()V
09</p>
<p>RETURN</p>
<p>10</p>
<p>MAXSTACK = </p>
<p>1
11</p>
<p>MAXLOCALS = </p>
<p>1</p>
<p>12</p>
<p>13</p>
<p>// access flags 1</p>
<p>14</p>
<p>public</p>
<p>sayHello(Ljava/lang/String;)Ljava/lang/String;
15</p>
<p>NEW java/lang/StringBuilder</p>
<p>16</p>
<p>DUP
17</p>
<p>LDC </p>
<p>&quot;Hello:&quot;</p>
<p>18</p>
<p>INVOKESPECIAL java/lang/StringBuilder. <init> (Ljava/lang/String;)V
19</p>
<p>ALOAD </p>
<p>1</p>
<p>20</p>
<p>INVOKEVIRTUAL java/lang/StringBuilder.append (Ljava/lang/String;)
21</p>
<p>Ljava/lang/StringBuilder;</p>
<p>22</p>
<p>INVOKEVIRTUAL java/lang/StringBuilder.toString ()Ljava/lang/String;
23</p>
<p>ARETURN</p>
<p>24</p>
<p>MAXSTACK = </p>
<p>3
25</p>
<p>MAXLOCALS = </p>
<p>2</p>
<p>26</p>
<p>}<a href=""><strong>清单 6. 生成 SayHelloImpl.class 的 ASM Code</strong></a>01</p>
<p>package</p>
<p>asm.com.ibm.was.asm;</p>
<p>02</p>
<p>import</p>
<p>java.util./*;
03</p>
<p>import</p>
<p>org.objectweb.asm./*;</p>
<p>04</p>
<p>import</p>
<p>org.objectweb.asm.attrs./*;
05</p>
<p>public</p>
<p>class</p>
<p>SayHelloImplDump </p>
<p>implements</p>
<p>Opcodes {</p>
<p>06</p>
<p>public</p>
<p>static</p>
<p>byte</p>
<p>[] dump () </p>
<p>throws</p>
<p>Exception {
07</p>
<p>ClassWriter cw = </p>
<p>new</p>
<p>ClassWriter(</p>
<p>0</p>
<p>);</p>
<p>08</p>
<p>FieldVisitor fv;
09</p>
<p>MethodVisitor mv;</p>
<p>10</p>
<p>AnnotationVisitor av0;
11</p>
<p>12</p>
<p>cw.visit(V1_6, ACC_PUBLIC + ACC_SUPER, </p>
<p>&quot;com/ibm/was/asm/SayHelloImpl&quot;</p>
<p>,
13</p>
<p>null</p>
<p>, </p>
<p>&quot;java/lang/Object&quot;</p>
<p>, </p>
<p>null</p>
<p>);</p>
<p>14</p>
<p>15</p>
<p>{</p>
<p>16</p>
<p>mv = cw.visitMethod(ACC_PUBLIC, </p>
<p>&quot;<init>&quot;</p>
<p>, </p>
<p>&quot;()V&quot;</p>
<p>, </p>
<p>null</p>
<p>, </p>
<p>null</p>
<p>);
17</p>
<p>mv.visitCode();</p>
<p>18</p>
<p>mv.visitVarInsn(ALOAD, </p>
<p>0</p>
<p>);
19</p>
<p>mv.visitMethodInsn(INVOKESPECIAL, </p>
<p>&quot;java/lang/Object&quot;</p>
<p>, </p>
<p>&quot;<init>&quot;</p>
<p>, </p>
<p>&quot;()V&quot;</p>
<p>);</p>
<p>20</p>
<p>mv.visitInsn(RETURN);
21</p>
<p>mv.visitMaxs(</p>
<p>1</p>
<p>, </p>
<p>1</p>
<p>);</p>
<p>22</p>
<p>mv.visitEnd();
23</p>
<p>}</p>
<p>24</p>
<p>{
25</p>
<p>mv = cw.visitMethod(ACC_PUBLIC, </p>
<p>&quot;sayHello&quot;</p>
<p>,</p>
<p>26</p>
<p>&quot;(Ljava/lang/String;)Ljava/lang/String;&quot;</p>
<p>, </p>
<p>null</p>
<p>, </p>
<p>null</p>
<p>);
27</p>
<p>mv.visitCode();</p>
<p>28</p>
<p>mv.visitTypeInsn(NEW, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>);
29</p>
<p>mv.visitInsn(DUP);</p>
<p>30</p>
<p>mv.visitLdcInsn(</p>
<p>&quot;Hello:&quot;</p>
<p>);
31</p>
<p>mv.visitMethodInsn(INVOKESPECIAL, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>,</p>
<p>32</p>
<p>&quot;<init>&quot;</p>
<p>, </p>
<p>&quot;(Ljava/lang/String;)V&quot;</p>
<p>);
33</p>
<p>mv.visitVarInsn(ALOAD, </p>
<p>1</p>
<p>);</p>
<p>34</p>
<p>mv.visitMethodInsn(INVOKEVIRTUAL, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>,
35</p>
<p>&quot;append&quot;</p>
<p>, </p>
<p>&quot;(Ljava/lang/String;)Ljava/lang/StringBuilder;&quot;</p>
<p>);</p>
<p>36</p>
<p>mv.visitMethodInsn(INVOKEVIRTUAL, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>,
37</p>
<p>&quot;toString&quot;</p>
<p>, </p>
<p>&quot;()Ljava/lang/String;&quot;</p>
<p>);</p>
<p>38</p>
<p>mv.visitInsn(ARETURN);
39</p>
<p>mv.visitMaxs(</p>
<p>3</p>
<p>, </p>
<p>2</p>
<p>);</p>
<p>40</p>
<p>mv.visitEnd();
41</p>
<p>}</p>
<p>42</p>
<p>cw.visitEnd();
43</p>
<p>return</p>
<p>cw.toByteArray();</p>
<p>44</p>
<p>}
45</p>
<p>}</p>
<p>图 1 描述了 Java Source 文件、Java Class 文件、ASM Code 文件和 ASM Source 文件之间的转换关系。
<a href=""><strong>图 1. 四种文件的转换图</strong></a> 
<a href=""><img src="" alt="图 1. 四种文件的转换图"></a> </p>
<p>如图 -1 所示，Java Source 文件通过 Javac 可以转换为 Java Class 文件。而相应的 Java Class 文件通过 Java 反编译器工具可转换为 Java Source 文件；</p>
<p>通 过 ASM Code 去创建和修改 Java Class 需要对 ASM API 比较熟悉才行，一个常见的问题时，怎么用 ASM Code 生成一个我们希望的 class 文件， 也就是说， 给定了 Java Class， 怎么得到其对应的 ASM Code 呢？ 所幸的是， ASM 框架为我们提供了 ASMifierClassVisitor 工具来产生 Java Class 对应的 ASM Code。代码如下：
<a href=""><strong>清单 7. 给定 class 文件，通过 ASMifierClassVisitor 获得其对应的 ASM Code</strong></a><a href="http://www.oschina.net/question/129540_28430#viewSource" title="view source" target="_blank">view source</a><a href="http://www.oschina.net/question/129540_28430#printSource" title="print" target="_blank">print</a><a href="http://www.oschina.net/question/129540_28430#about" title="?" target="_blank">?</a></p>
<p>01</p>
<p>public</p>
<p>void</p>
<p>showClassASMProcess() {</p>
<p>02</p>
<p>ClassReader cr;
03</p>
<p>final</p>
<p>String n = SayHelloImpl.</p>
<p>class</p>
<p>.getName();</p>
<p>04</p>
<p>05</p>
<p>try</p>
<p>{</p>
<p>06</p>
<p>cr = </p>
<p>new</p>
<p>ClassReader(n);<br>07</p>
<p>cr.accept(</p>
<p>new</p>
<p>ASMifierClassVisitor(</p>
<p>new</p>
<p>PrintWriter(System.out)),</p>
<p>08</p>
<p>new</p>
<p>Attribute[</p>
<p>0</p>
<p>],
09</p>
<p>ClassReader.SKIP_DEBUG);</p>
<p>10</p>
<p>11</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {</p>
<p>12</p>
<p>e.printStackTrace();
13</p>
<p>}</p>
<p>14</p>
<p>}</p>
<p>另外一个重要的转换就是， 给定了 Java Class 文件， 如何查看它的 ASM Source ？ 这点对于我们验证 ASM Code 生成的 class 是否正确很有用。ASM 提供了另外一个工具 TraceClassVisitor， 来获得一个 Java Class 对应的 ASM Source。代码如下：
<a href=""><strong>清单 8. 利用 TraceClassVisitor 查看 class 文件的 ASM Source</strong></a>01</p>
<p>//file 是 class 文件的全路径名</p>
<p>02</p>
<p>public</p>
<p>void</p>
<p>showClassSource(String file) {
03</p>
<p>FileInputStream is ;</p>
<p>04</p>
<p>ClassReader cr; 
05</p>
<p>06</p>
<p>try</p>
<p>{
07</p>
<p>is = </p>
<p>new</p>
<p>FileInputStream(file);     </p>
<p>08</p>
<p>cr = </p>
<p>new</p>
<p>ClassReader(is);
09</p>
<p>TraceClassVisitor trace = </p>
<p>new</p>
<p>TraceClassVisitor(</p>
<p>new</p>
<p>PrintWriter(System.out));</p>
<p>10</p>
<p>cr.accept(trace, ClassReader.SKIP_DEBUG);
11</p>
<p>12</p>
<p>is.close() ;
13</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {</p>
<p>14</p>
<p>e.printStackTrace() ;
15</p>
<p>}</p>
<p>16</p>
<p>}
17</p>
<p>{</p>
<p>18</p>
<p>e.printStackTrace();
19</p>
<p>}</p>
<p>20</p>
<p>}</p>
<p><a href="">ASM 类注入</a></p>
<p>ASM 类注入是指修改一个现有的 class 文件，在其中加入自己的代码。按通常思维，我们需要利用 ASM 提供的 reader 类去读取所要修改的类文件， 找到要修改的地方，如方法名或属性名，然后在该处插入自己的代码或修改现有的代码，这种思路将使问题复杂化。 ASM 为我们提供了访问类文件的 Visitor 模式，来遍历一个 class 文件，Visitor 是一个实现 ClassVisitor 接口的类。 要注入一个 class 文件，先要找到一个合适的 Visitor 做向导， ASM 提供了好几种 Visitor， 最常用的是 ClassWriter。同时我们需要提供一个适配器类 ClassAdapter， Visitor 会带着这个 Adapter 一起去遍历， 然后在遍历过程中回调 Adapter 提供的方法。我们在 Adapter 的这些方法中就可以实现我们的修改和定制逻辑。当然，如果你不想做任何修改，那 Visitor 遍历完后将得到一个和被遍历的 class 完全一样的拷贝。
<a href=""><strong>清单 9. 类注入的完整过程</strong></a>01</p>
<p>public</p>
<p>void</p>
<p>addAnnotationToExistingClass() {</p>
<p>02</p>
<p>FileInputStream is ;
03</p>
<p>ClassReader cr;          </p>
<p>04</p>
<p>try</p>
<p>{<br>05</p>
<p>String classfile = </p>
<p>&quot;E:\SayHelloImpl.class&quot;</p>
<p>; </p>
<p>// 待遍历的类</p>
<p>06</p>
<p>showClassSource(classfile) ;  </p>
<p>// 打印该类的 ASM source
07</p>
<p>08</p>
<p>is = </p>
<p>new</p>
<p>FileInputStream(classfile);<br>09</p>
<p>cr = </p>
<p>new</p>
<p>ClassReader(is);</p>
<p>10</p>
<p>// 此处我们使用 ClassWriter 做 Visitor
11</p>
<p>ClassWriter cw = </p>
<p>new</p>
<p>ClassWriter(ClassWriter.COMPUTE_MAXS);</p>
<p>12</p>
<p>// 给 Visitor 提供一个 Adapter
13</p>
<p>AddAnnotationAdapter adapter = </p>
<p>new</p>
<p>AddAnnotationAdapter(cw);           </p>
<p>14</p>
<p>cr.accept(adapter, ClassReader.SKIP_DEBUG);<br>15</p>
<p>16</p>
<p>// 遍历完后，生成的 class 保存在字节数组中
17</p>
<p>byte</p>
<p>[] b = cw.toByteArray();</p>
<p>18</p>
<p>19</p>
<p>try</p>
<p>{</p>
<p>20</p>
<p>// 将字节数组输出到文件中
21</p>
<p>// 为了不至于覆盖掉原有的 SayHelloImpl.class 文件，我们将结果输出到 _SayHelloImpl.class</p>
<p>22</p>
<p>FileOutputStream fout = </p>
<p>new</p>
<p>FileOutputStream(</p>
<p>&quot;E:\_SayHelloImpl.class&quot;</p>
<p>);
23</p>
<p>fout.write(b) ;</p>
<p>24</p>
<p>fout.flush();
25</p>
<p>fout.close() ;</p>
<p>26</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {
27</p>
<p>e.printStackTrace() ;</p>
<p>28</p>
<p>}
29</p>
<p>30</p>
<p>// 验证 _SayHelloImpl.class 是否包含我们注入的代码
31</p>
<p>showClassSource(</p>
<p>&quot;E:\_SayHelloImpl.class&quot;</p>
<p>) ;</p>
<p>32</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {
33</p>
<p>e.printStackTrace();</p>
<p>34</p>
<p>} 
35</p>
<p>}</p>
<p><a href="">web services 标记注入过程</a></p>
<p>我们已经知道了如何往 class 中注入自己的代码，那对于一个已有的 Java bean，怎么往里注入 @WebService 和 @WebMethod 呢？根据上面我们讲的转换关系，我们可以先写一个带 annotation 的 Java Source，编译得到 Java Class， 再得到其 ASM Code。下面是利用 ASM 给一个不带任何 Annotation 的 class 添加 @WebService 和 @WebMethod 的步骤。</p>
<ol>
<li>首先在 SayHelloImpl.java 中添加 @WebService 和 @WebMethod： 
<a href=""><strong>清单 10. 带 web services 标注的 SayHelloImpl 类</strong></a>1</li>
</ol>
<p>@WebService</p>
<p>2</p>
<p>public</p>
<p>class</p>
<p>SayHelloImpl {
3</p>
<p>@WebMethod</p>
<p>4</p>
<p>public</p>
<p>String sayHello(String s) {
5</p>
<p>return</p>
<p>&quot;Hello: &quot;</p>
<ul>
<li>s ;</li>
</ul>
<p>6</p>
<p>}
7</p>
<p>}</p>
<ol>
<li>通过 ASMifierClassVisitor 工具获得 SayHelloImpl class 的 ASM Code，见清单 6。</li>
<li>写一个 ClassAdapter 类， ClassAdapter 其实也是一个 Visitor。根据 ASM Code 的提示， 我们就可以知道如何利用 ASM API 去获得我们希望的 class 文件。下面是 Adapter 的示例代码。 
<a href=""><strong>清单 11. 添加 Annotation 的 Adapter 类</strong></a>01</li>
</ol>
<p>public</p>
<p>class</p>
<p>AddAnnotationAdapter </p>
<p>extends</p>
<p>ClassAdapter </p>
<p>implements</p>
<p>Opcodes{</p>
<p>02</p>
<p>//private String annotationDesc;
03</p>
<p>private</p>
<p>boolean</p>
<p>isAnnotationPresent;</p>
<p>04</p>
<p>05</p>
<p>public</p>
<p>AddAnnotationAdapter(ClassVisitor cv) {</p>
<p>06</p>
<p>super</p>
<p>(cv);
07</p>
<p>}</p>
<p>08</p>
<p>09</p>
<p>@Override</p>
<p>10</p>
<p>public</p>
<p>void</p>
<p>visit(</p>
<p>int</p>
<p>version, </p>
<p>int</p>
<p>access, String name, String signature,
11</p>
<p>String superName, String[] interfaces) {</p>
<p>12</p>
<p>13</p>
<p>cv.visit(V1_6, ACC_PUBLIC + ACC_SUPER, name, signature, superName,</p>
<p>14</p>
<p>interfaces);
15</p>
<p>AnnotationVisitor av0;</p>
<p>16</p>
<p>av0 = cv.visitAnnotation(</p>
<p>&quot;Ljavax/jws/WebService;&quot;</p>
<p>, </p>
<p>true</p>
<p>);
17</p>
<p>av0.visitEnd();</p>
<p>18</p>
<p>}
19</p>
<p>20</p>
<p>@Override
21</p>
<p>public</p>
<p>AnnotationVisitor visitAnnotation(String desc, </p>
<p>boolean</p>
<p>visible) {</p>
<p>22</p>
<p>return</p>
<p>cv.visitAnnotation(desc, visible);
23</p>
<p>}</p>
<p>24</p>
<p>25</p>
<p>@Override</p>
<p>26</p>
<p>public</p>
<p>void</p>
<p>visitInnerClass(String name, String outerName,
27</p>
<p>String innerName, </p>
<p>int</p>
<p>access) {</p>
<p>28</p>
<p>cv.visitInnerClass(name, outerName, innerName, access);
29</p>
<p>}</p>
<p>30</p>
<p>31</p>
<p>@Override</p>
<p>32</p>
<p>public</p>
<p>FieldVisitor visitField(</p>
<p>int</p>
<p>access, String name, String desc,
33</p>
<p>String signature, Object value) {</p>
<p>34</p>
<p>return</p>
<p>cv.visitField(access, name, desc, signature, value);
35</p>
<p>}</p>
<p>36</p>
<p>37</p>
<p>@Override</p>
<p>38</p>
<p>public</p>
<p>MethodVisitor visitMethod(</p>
<p>int</p>
<p>access, String name, String desc,
39</p>
<p>String signature, String[] exceptions) {   </p>
<p>40</p>
<p>MethodVisitor mv  = cv.visitMethod(access, name, desc, signature,
41</p>
<p>exceptions);</p>
<p>42</p>
<p>if</p>
<p>(!name.equals(</p>
<p>&quot;<init>&quot;</p>
<p>)) {
43</p>
<p>AnnotationVisitor av0;</p>
<p>44</p>
<p>av0 = mv.visitAnnotation(</p>
<p>&quot;Ljavax/jws/WebMethod;&quot;</p>
<p>, </p>
<p>true</p>
<p>);
45</p>
<p>av0.visitEnd();</p>
<p>46</p>
<p>}
47</p>
<p>return</p>
<p>mv;</p>
<p>48</p>
<p>}
49</p>
<p>50</p>
<p>@Override
51</p>
<p>public</p>
<p>void</p>
<p>visitEnd() {</p>
<p>52</p>
<p>cv.visitEnd();
53</p>
<p>}</p>
<p>54</p>
<p>55</p>
<p>}</p>
<p>最后，我们采用上面讲的类注入办法，即可得到一个带 @WebService 和 @WebMethod 标注的 class 文件。再通过 wsgen 工具即可成功创建 web services，该命令将会在 src 目录下生成 web services 描述文件：SayHelloImplService.wsdl，SayHelloImplService_schema1.xsd，同时生成了 2 个 JAX-WS 文件，分别为：SayHello.java，SayHelloResponse.java。</p>
<p>当然，在实际应用中，我们可能需要将一个 class 的某些特定方法发布为 web services，这就需要我们对 Adapter 做进一步的改造，在 visitMethod() 方法中根据方法名称等参数做进一步的处理。</p>
<p><a href="">结束语</a></p>
<p>本文简要介绍了 ASM 字节码工具及其在 web services 开发中的应用。web services 的使用已经越来越广泛， 但在改造遗留系统过程中会遇到不少问题，本文针对其中一个主要问题给出了解决办法，该方法无须对现有系统做大量的改动， 即可将现存的 Java bean 转化成 web services 。本文对那些正考虑迁移到 JAX-WS 编程模型上的项目有一定的参考价值。在基于 JAX-WS 标准的 web services 的开发中，不少实际场景都是希望采用自底向上的开发方式， 即基于已有的 Java bean 来创建 web services 。WebSphere Application Server ( 以下简称 WAS ) 提供了命令行的工具 wsgen 和相对应的 Ant task 来支持这种开发过程，而且这两个工具比较适合大型项目的自动化构建。 这两个工具的使用前提是 Java bean 中事先添加有 web services 的 Annotation 标注，而在现有的业务系统中，class 文件一般是不带 Annotation 的，这就需要开发人员去修改现有的代码，以手工方式添加 Annotation，但这样带来的工作量太大且容易出错。本文介绍了一种解决途径，可以不用修改源代码，而是利用字节码工具 ASM 直接修改 class 文件， 在字节码文件中自动注入 Annotation ，然后再利用 wsgen 工具就可以很方便地生成 web services 应用。 本文同时也总结了使用 ASM 的一些实践。</p>
<p>本文首先介绍了和 ASM 使用相关的四种文件，以及它们之间的相互转化。然后结合 web services 开发实例，介绍了使用 wsgen 开发时遇到的实际问题，如何写一个 ASM 的适配器去修改现有 class，最终如何产生 web services 文件。</p>
<p>ASM 是一个多用途的 Java 字节码操控和分析框架。它能以二进制的形式直接修改现有的类或动态生成的类。 ASM 提供了常用的转换和分析算法，是一种允许用户方便的组装定制化的复杂转换和代码分析工具。 ASM 也提供和其它的字节码工具类似的功能，但 ASM 的重点是使用的简单和高性能。由于 ASM 在设计实现的时候尽可能 的小的内存占用和提供更高的性能；因此在动态系统中使用 ASM 是很有优势的。ASM 作为一种轻量级、高性能的 Java 字节码操控和分析框架，设计了一种更有效的方法、提供更好的性能和内存占用。今天， ASM 在许多领域都有应用，并已成为事实上的字节码处理框架标准。</p>
<p><a href="">问题的引入</a></p>
<p>先写一个不带 web services 标注的 SayHelloImpl 类。
<a href=""><strong>清单 1. 不带 web services 的 SayHelloImpl 类</strong></a>1</p>
<p>public</p>
<p>class</p>
<p>SayHelloImpl {</p>
<p>2</p>
<p>public</p>
<p>String sayHello(String s) {
3</p>
<p>return</p>
<p>“Hello: ” + s ;</p>
<p>4</p>
<p>}
5</p>
<p>}</p>
<p>再用 wsgen 来创建 web services，wsgen 的使用如下：
<a href=""><strong>清单 2. wsgen 实例</strong></a>1</p>
<p>wsgen.exe – </p>
<p>cp</p>
<p>bin – s output – d output – r output – wsdl ibm.was.asm.SayHelloImpl我们将会遇到如下错误： 
<a href=""><strong>清单 3. 根据不带 web services 标注的类创建 web services 时遇到的错误信息</strong></a> 
注释处理过程中遇到问题；</p>
<p>......
com.sun.tools.internal.ws.processor.modeler.ModelerException: [failed to localiz</p>
<p>e] A web service endpoint could not be found()
        at com.sun.tools.internal.ws.processor.modeler.annotation.WebServiceAP.o</p>
<p>nError(WebServiceAP.java:215)
        at com.sun.tools.internal.ws.processor.modeler.annotation.WebServiceAP.b</p>
<p>uildModel(WebServiceAP.java:322)
        at com.sun.tools.internal.ws.processor.modeler.annotation.WebServiceAP.p</p>
<p>rocess(WebServiceAP.java:256)
        at com.sun.mirror.apt.AnnotationProcessors$CompositeAnnotationProcessor.</p>
<p>process(AnnotationProcessors.java:60)</p>
<p>注意：我们通常是在 class 前使用 @WebService， 在方法前使用 @WebMethod 来将一个类标注为 web services 的。WAS 6.1 的 web services 功能部件包和 WAS 7 都支持基于 JAX-WS 标准 的 web services 的开发， 在 WAS 安装目录的 bin 目录下提供了命令行工具 wsgen，wsgen 支持自底向上的开发方式。 下面是 wsgen 的用法：
<a href=""><strong>清单 4. wsgen 命令格式</strong></a> 
注 wsgen [options]  [SEI]</p>
<p>主要选项：</p>
<ul>
<li>-d 指定生成的 class 文件位置；</li>
<li>-s 指定生成的 Java 源文件位置；</li>
<li>-r 指定生成的 resources 文件位置，如 wsdl，xsd；</li>
<li>-cp 指定服务实现类所在的位置；</li>
<li>-wsdl，-servicename，-portname 三个参数指定生成的 wsdl 文件中的 service 和 port 的名称。</li>
</ul>
<p>SEI(Service Endpoint Interface) 是一个 endpoint implementation class，不能是一个 interface。所以首先要开发一个 endpoint 的实现类，如本例中的 SayHelloImpl 。用 @WebService 声明 web services ，然后将它编译，才能提供给 wsgen 来创建 web services 。</p>
<p><a href="">四种文件之间的转换</a></p>
<p>下面介绍本文要用到的四个概念（Java Source，Java Class，ASM Code，ASM Source）</p>
<ul>
<li>Java Source: 即我们通常编写的 Java 源文件；</li>
<li>Java Class: Java 源文件编译后的字节码文件；</li>
<li>ASM Source : 类似于对 class 反编译后的源文件，也就是 &quot;textual byte code&quot;，但比原始的 Java Source 可读性要差， 参见清单 5。</li>
<li>ASM Code: 指读写 class 文件的 ASM 程序代码。需要用到 ASM 提供的 API， 参见清单 6。
<a href=""><strong>清单 5. SayHelloImpl 类对应的 ASM Source</strong></a>01</li>
</ul>
<p>// class version 50.0 (50)</p>
<p>02</p>
<p>// access flags 33
03</p>
<p>public</p>
<p>class</p>
<p>com/ibm/was/asm/SayHelloImpl {</p>
<p>04</p>
<p>05</p>
<p>// access flags 1</p>
<p>06</p>
<p>public</p>
<p><init>()V
07</p>
<p>ALOAD </p>
<p>0</p>
<p>08</p>
<p>INVOKESPECIAL java/lang/Object. <init> ()V
09</p>
<p>RETURN</p>
<p>10</p>
<p>MAXSTACK = </p>
<p>1
11</p>
<p>MAXLOCALS = </p>
<p>1</p>
<p>12</p>
<p>13</p>
<p>// access flags 1</p>
<p>14</p>
<p>public</p>
<p>sayHello(Ljava/lang/String;)Ljava/lang/String;
15</p>
<p>NEW java/lang/StringBuilder</p>
<p>16</p>
<p>DUP
17</p>
<p>LDC </p>
<p>&quot;Hello:&quot;</p>
<p>18</p>
<p>INVOKESPECIAL java/lang/StringBuilder. <init> (Ljava/lang/String;)V
19</p>
<p>ALOAD </p>
<p>1</p>
<p>20</p>
<p>INVOKEVIRTUAL java/lang/StringBuilder.append (Ljava/lang/String;)
21</p>
<p>Ljava/lang/StringBuilder;</p>
<p>22</p>
<p>INVOKEVIRTUAL java/lang/StringBuilder.toString ()Ljava/lang/String;
23</p>
<p>ARETURN</p>
<p>24</p>
<p>MAXSTACK = </p>
<p>3
25</p>
<p>MAXLOCALS = </p>
<p>2</p>
<p>26</p>
<p>}<a href=""><strong>清单 6. 生成 SayHelloImpl.class 的 ASM Code</strong></a>01</p>
<p>package</p>
<p>asm.com.ibm.was.asm;</p>
<p>02</p>
<p>import</p>
<p>java.util./*;
03</p>
<p>import</p>
<p>org.objectweb.asm./*;</p>
<p>04</p>
<p>import</p>
<p>org.objectweb.asm.attrs./*;
05</p>
<p>public</p>
<p>class</p>
<p>SayHelloImplDump </p>
<p>implements</p>
<p>Opcodes {</p>
<p>06</p>
<p>public</p>
<p>static</p>
<p>byte</p>
<p>[] dump () </p>
<p>throws</p>
<p>Exception {
07</p>
<p>ClassWriter cw = </p>
<p>new</p>
<p>ClassWriter(</p>
<p>0</p>
<p>);</p>
<p>08</p>
<p>FieldVisitor fv;
09</p>
<p>MethodVisitor mv;</p>
<p>10</p>
<p>AnnotationVisitor av0;
11</p>
<p>12</p>
<p>cw.visit(V1_6, ACC_PUBLIC + ACC_SUPER, </p>
<p>&quot;com/ibm/was/asm/SayHelloImpl&quot;</p>
<p>,
13</p>
<p>null</p>
<p>, </p>
<p>&quot;java/lang/Object&quot;</p>
<p>, </p>
<p>null</p>
<p>);</p>
<p>14</p>
<p>15</p>
<p>{</p>
<p>16</p>
<p>mv = cw.visitMethod(ACC_PUBLIC, </p>
<p>&quot;<init>&quot;</p>
<p>, </p>
<p>&quot;()V&quot;</p>
<p>, </p>
<p>null</p>
<p>, </p>
<p>null</p>
<p>);
17</p>
<p>mv.visitCode();</p>
<p>18</p>
<p>mv.visitVarInsn(ALOAD, </p>
<p>0</p>
<p>);
19</p>
<p>mv.visitMethodInsn(INVOKESPECIAL, </p>
<p>&quot;java/lang/Object&quot;</p>
<p>, </p>
<p>&quot;<init>&quot;</p>
<p>, </p>
<p>&quot;()V&quot;</p>
<p>);</p>
<p>20</p>
<p>mv.visitInsn(RETURN);
21</p>
<p>mv.visitMaxs(</p>
<p>1</p>
<p>, </p>
<p>1</p>
<p>);</p>
<p>22</p>
<p>mv.visitEnd();
23</p>
<p>}</p>
<p>24</p>
<p>{
25</p>
<p>mv = cw.visitMethod(ACC_PUBLIC, </p>
<p>&quot;sayHello&quot;</p>
<p>,</p>
<p>26</p>
<p>&quot;(Ljava/lang/String;)Ljava/lang/String;&quot;</p>
<p>, </p>
<p>null</p>
<p>, </p>
<p>null</p>
<p>);
27</p>
<p>mv.visitCode();</p>
<p>28</p>
<p>mv.visitTypeInsn(NEW, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>);
29</p>
<p>mv.visitInsn(DUP);</p>
<p>30</p>
<p>mv.visitLdcInsn(</p>
<p>&quot;Hello:&quot;</p>
<p>);
31</p>
<p>mv.visitMethodInsn(INVOKESPECIAL, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>,</p>
<p>32</p>
<p>&quot;<init>&quot;</p>
<p>, </p>
<p>&quot;(Ljava/lang/String;)V&quot;</p>
<p>);
33</p>
<p>mv.visitVarInsn(ALOAD, </p>
<p>1</p>
<p>);</p>
<p>34</p>
<p>mv.visitMethodInsn(INVOKEVIRTUAL, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>,
35</p>
<p>&quot;append&quot;</p>
<p>, </p>
<p>&quot;(Ljava/lang/String;)Ljava/lang/StringBuilder;&quot;</p>
<p>);</p>
<p>36</p>
<p>mv.visitMethodInsn(INVOKEVIRTUAL, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>,
37</p>
<p>&quot;toString&quot;</p>
<p>, </p>
<p>&quot;()Ljava/lang/String;&quot;</p>
<p>);</p>
<p>38</p>
<p>mv.visitInsn(ARETURN);
39</p>
<p>mv.visitMaxs(</p>
<p>3</p>
<p>, </p>
<p>2</p>
<p>);</p>
<p>40</p>
<p>mv.visitEnd();
41</p>
<p>}</p>
<p>42</p>
<p>cw.visitEnd();
43</p>
<p>return</p>
<p>cw.toByteArray();</p>
<p>44</p>
<p>}
45</p>
<p>}</p>
<p>图 1 描述了 Java Source 文件、Java Class 文件、ASM Code 文件和 ASM Source 文件之间的转换关系。
<a href=""><strong>图 1. 四种文件的转换图</strong></a> 
<a href=""><img src="" alt="图 1. 四种文件的转换图"></a> </p>
<p>如图 -1 所示，Java Source 文件通过 Javac 可以转换为 Java Class 文件。而相应的 Java Class 文件通过 Java 反编译器工具可转换为 Java Source 文件；</p>
<p>通 过 ASM Code 去创建和修改 Java Class 需要对 ASM API 比较熟悉才行，一个常见的问题时，怎么用 ASM Code 生成一个我们希望的 class 文件， 也就是说， 给定了 Java Class， 怎么得到其对应的 ASM Code 呢？ 所幸的是， ASM 框架为我们提供了 ASMifierClassVisitor 工具来产生 Java Class 对应的 ASM Code。代码如下：
<a href=""><strong>清单 7. 给定 class 文件，通过 ASMifierClassVisitor 获得其对应的 ASM Code</strong></a><a href="http://www.oschina.net/question/129540_28430#viewSource" title="view source" target="_blank">view source</a><a href="http://www.oschina.net/question/129540_28430#printSource" title="print" target="_blank">print</a><a href="http://www.oschina.net/question/129540_28430#about" title="?" target="_blank">?</a></p>
<p>01</p>
<p>public</p>
<p>void</p>
<p>showClassASMProcess() {</p>
<p>02</p>
<p>ClassReader cr;
03</p>
<p>final</p>
<p>String n = SayHelloImpl.</p>
<p>class</p>
<p>.getName();</p>
<p>04</p>
<p>05</p>
<p>try</p>
<p>{</p>
<p>06</p>
<p>cr = </p>
<p>new</p>
<p>ClassReader(n);<br>07</p>
<p>cr.accept(</p>
<p>new</p>
<p>ASMifierClassVisitor(</p>
<p>new</p>
<p>PrintWriter(System.out)),</p>
<p>08</p>
<p>new</p>
<p>Attribute[</p>
<p>0</p>
<p>],
09</p>
<p>ClassReader.SKIP_DEBUG);</p>
<p>10</p>
<p>11</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {</p>
<p>12</p>
<p>e.printStackTrace();
13</p>
<p>}</p>
<p>14</p>
<p>}</p>
<p>另外一个重要的转换就是， 给定了 Java Class 文件， 如何查看它的 ASM Source ？ 这点对于我们验证 ASM Code 生成的 class 是否正确很有用。ASM 提供了另外一个工具 TraceClassVisitor， 来获得一个 Java Class 对应的 ASM Source。代码如下：
<a href=""><strong>清单 8. 利用 TraceClassVisitor 查看 class 文件的 ASM Source</strong></a>01</p>
<p>//file 是 class 文件的全路径名</p>
<p>02</p>
<p>public</p>
<p>void</p>
<p>showClassSource(String file) {
03</p>
<p>FileInputStream is ;</p>
<p>04</p>
<p>ClassReader cr; 
05</p>
<p>06</p>
<p>try</p>
<p>{
07</p>
<p>is = </p>
<p>new</p>
<p>FileInputStream(file);     </p>
<p>08</p>
<p>cr = </p>
<p>new</p>
<p>ClassReader(is);
09</p>
<p>TraceClassVisitor trace = </p>
<p>new</p>
<p>TraceClassVisitor(</p>
<p>new</p>
<p>PrintWriter(System.out));</p>
<p>10</p>
<p>cr.accept(trace, ClassReader.SKIP_DEBUG);
11</p>
<p>12</p>
<p>is.close() ;
13</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {</p>
<p>14</p>
<p>e.printStackTrace() ;
15</p>
<p>}</p>
<p>16</p>
<p>}
17</p>
<p>{</p>
<p>18</p>
<p>e.printStackTrace();
19</p>
<p>}</p>
<p>20</p>
<p>}</p>
<p><a href="">ASM 类注入</a></p>
<p>ASM 类注入是指修改一个现有的 class 文件，在其中加入自己的代码。按通常思维，我们需要利用 ASM 提供的 reader 类去读取所要修改的类文件， 找到要修改的地方，如方法名或属性名，然后在该处插入自己的代码或修改现有的代码，这种思路将使问题复杂化。 ASM 为我们提供了访问类文件的 Visitor 模式，来遍历一个 class 文件，Visitor 是一个实现 ClassVisitor 接口的类。 要注入一个 class 文件，先要找到一个合适的 Visitor 做向导， ASM 提供了好几种 Visitor， 最常用的是 ClassWriter。同时我们需要提供一个适配器类 ClassAdapter， Visitor 会带着这个 Adapter 一起去遍历， 然后在遍历过程中回调 Adapter 提供的方法。我们在 Adapter 的这些方法中就可以实现我们的修改和定制逻辑。当然，如果你不想做任何修改，那 Visitor 遍历完后将得到一个和被遍历的 class 完全一样的拷贝。
<a href=""><strong>清单 9. 类注入的完整过程</strong></a>01</p>
<p>public</p>
<p>void</p>
<p>addAnnotationToExistingClass() {</p>
<p>02</p>
<p>FileInputStream is ;
03</p>
<p>ClassReader cr;          </p>
<p>04</p>
<p>try</p>
<p>{<br>05</p>
<p>String classfile = </p>
<p>&quot;E:\SayHelloImpl.class&quot;</p>
<p>; </p>
<p>// 待遍历的类</p>
<p>06</p>
<p>showClassSource(classfile) ;  </p>
<p>// 打印该类的 ASM source
07</p>
<p>08</p>
<p>is = </p>
<p>new</p>
<p>FileInputStream(classfile);<br>09</p>
<p>cr = </p>
<p>new</p>
<p>ClassReader(is);</p>
<p>10</p>
<p>// 此处我们使用 ClassWriter 做 Visitor
11</p>
<p>ClassWriter cw = </p>
<p>new</p>
<p>ClassWriter(ClassWriter.COMPUTE_MAXS);</p>
<p>12</p>
<p>// 给 Visitor 提供一个 Adapter
13</p>
<p>AddAnnotationAdapter adapter = </p>
<p>new</p>
<p>AddAnnotationAdapter(cw);           </p>
<p>14</p>
<p>cr.accept(adapter, ClassReader.SKIP_DEBUG);<br>15</p>
<p>16</p>
<p>// 遍历完后，生成的 class 保存在字节数组中
17</p>
<p>byte</p>
<p>[] b = cw.toByteArray();</p>
<p>18</p>
<p>19</p>
<p>try</p>
<p>{</p>
<p>20</p>
<p>// 将字节数组输出到文件中
21</p>
<p>// 为了不至于覆盖掉原有的 SayHelloImpl.class 文件，我们将结果输出到 _SayHelloImpl.class</p>
<p>22</p>
<p>FileOutputStream fout = </p>
<p>new</p>
<p>FileOutputStream(</p>
<p>&quot;E:\_SayHelloImpl.class&quot;</p>
<p>);
23</p>
<p>fout.write(b) ;</p>
<p>24</p>
<p>fout.flush();
25</p>
<p>fout.close() ;</p>
<p>26</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {
27</p>
<p>e.printStackTrace() ;</p>
<p>28</p>
<p>}
29</p>
<p>30</p>
<p>// 验证 _SayHelloImpl.class 是否包含我们注入的代码
31</p>
<p>showClassSource(</p>
<p>&quot;E:\_SayHelloImpl.class&quot;</p>
<p>) ;</p>
<p>32</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {
33</p>
<p>e.printStackTrace();</p>
<p>34</p>
<p>} 
35</p>
<p>}</p>
<p><a href="">web services 标记注入过程</a></p>
<p>我们已经知道了如何往 class 中注入自己的代码，那对于一个已有的 Java bean，怎么往里注入 @WebService 和 @WebMethod 呢？根据上面我们讲的转换关系，我们可以先写一个带 annotation 的 Java Source，编译得到 Java Class， 再得到其 ASM Code。下面是利用 ASM 给一个不带任何 Annotation 的 class 添加 @WebService 和 @WebMethod 的步骤。</p>
<ol>
<li>首先在 SayHelloImpl.java 中添加 @WebService 和 @WebMethod： 
<a href=""><strong>清单 10. 带 web services 标注的 SayHelloImpl 类</strong></a>1</li>
</ol>
<p>@WebService</p>
<p>2</p>
<p>public</p>
<p>class</p>
<p>SayHelloImpl {
3</p>
<p>@WebMethod</p>
<p>4</p>
<p>public</p>
<p>String sayHello(String s) {
5</p>
<p>return</p>
<p>&quot;Hello: &quot;</p>
<ul>
<li>s ;</li>
</ul>
<p>6</p>
<p>}
7</p>
<p>}</p>
<ol>
<li>通过 ASMifierClassVisitor 工具获得 SayHelloImpl class 的 ASM Code，见清单 6。</li>
<li>写一个 ClassAdapter 类， ClassAdapter 其实也是一个 Visitor。根据 ASM Code 的提示， 我们就可以知道如何利用 ASM API 去获得我们希望的 class 文件。下面是 Adapter 的示例代码。 
<a href=""><strong>清单 11. 添加 Annotation 的 Adapter 类</strong></a>01</li>
</ol>
<p>public</p>
<p>class</p>
<p>AddAnnotationAdapter </p>
<p>extends</p>
<p>ClassAdapter </p>
<p>implements</p>
<p>Opcodes{</p>
<p>02</p>
<p>//private String annotationDesc;
03</p>
<p>private</p>
<p>boolean</p>
<p>isAnnotationPresent;</p>
<p>04</p>
<p>05</p>
<p>public</p>
<p>AddAnnotationAdapter(ClassVisitor cv) {</p>
<p>06</p>
<p>super</p>
<p>(cv);
07</p>
<p>}</p>
<p>08</p>
<p>09</p>
<p>@Override</p>
<p>10</p>
<p>public</p>
<p>void</p>
<p>visit(</p>
<p>int</p>
<p>version, </p>
<p>int</p>
<p>access, String name, String signature,
11</p>
<p>String superName, String[] interfaces) {</p>
<p>12</p>
<p>13</p>
<p>cv.visit(V1_6, ACC_PUBLIC + ACC_SUPER, name, signature, superName,</p>
<p>14</p>
<p>interfaces);
15</p>
<p>AnnotationVisitor av0;</p>
<p>16</p>
<p>av0 = cv.visitAnnotation(</p>
<p>&quot;Ljavax/jws/WebService;&quot;</p>
<p>, </p>
<p>true</p>
<p>);
17</p>
<p>av0.visitEnd();</p>
<p>18</p>
<p>}
19</p>
<p>20</p>
<p>@Override
21</p>
<p>public</p>
<p>AnnotationVisitor visitAnnotation(String desc, </p>
<p>boolean</p>
<p>visible) {</p>
<p>22</p>
<p>return</p>
<p>cv.visitAnnotation(desc, visible);
23</p>
<p>}</p>
<p>24</p>
<p>25</p>
<p>@Override</p>
<p>26</p>
<p>public</p>
<p>void</p>
<p>visitInnerClass(String name, String outerName,
27</p>
<p>String innerName, </p>
<p>int</p>
<p>access) {</p>
<p>28</p>
<p>cv.visitInnerClass(name, outerName, innerName, access);
29</p>
<p>}</p>
<p>30</p>
<p>31</p>
<p>@Override</p>
<p>32</p>
<p>public</p>
<p>FieldVisitor visitField(</p>
<p>int</p>
<p>access, String name, String desc,
33</p>
<p>String signature, Object value) {</p>
<p>34</p>
<p>return</p>
<p>cv.visitField(access, name, desc, signature, value);
35</p>
<p>}</p>
<p>36</p>
<p>37</p>
<p>@Override</p>
<p>38</p>
<p>public</p>
<p>MethodVisitor visitMethod(</p>
<p>int</p>
<p>access, String name, String desc,
39</p>
<p>String signature, String[] exceptions) {   </p>
<p>40</p>
<p>MethodVisitor mv  = cv.visitMethod(access, name, desc, signature,
41</p>
<p>exceptions);</p>
<p>42</p>
<p>if</p>
<p>(!name.equals(</p>
<p>&quot;<init>&quot;</p>
<p>)) {
43</p>
<p>AnnotationVisitor av0;</p>
<p>44</p>
<p>av0 = mv.visitAnnotation(</p>
<p>&quot;Ljavax/jws/WebMethod;&quot;</p>
<p>, </p>
<p>true</p>
<p>);
45</p>
<p>av0.visitEnd();</p>
<p>46</p>
<p>}
47</p>
<p>return</p>
<p>mv;</p>
<p>48</p>
<p>}
49</p>
<p>50</p>
<p>@Override
51</p>
<p>public</p>
<p>void</p>
<p>visitEnd() {</p>
<p>52</p>
<p>cv.visitEnd();
53</p>
<p>}</p>
<p>54</p>
<p>55</p>
<p>}</p>
<p>最后，我们采用上面讲的类注入办法，即可得到一个带 @WebService 和 @WebMethod 标注的 class 文件。再通过 wsgen 工具即可成功创建 web services，该命令将会在 src 目录下生成 web services 描述文件：SayHelloImplService.wsdl，SayHelloImplService_schema1.xsd，同时生成了 2 个 JAX-WS 文件，分别为：SayHello.java，SayHelloResponse.java。</p>
<p>当然，在实际应用中，我们可能需要将一个 class 的某些特定方法发布为 web services，这就需要我们对 Adapter 做进一步的改造，在 visitMethod() 方法中根据方法名称等参数做进一步的处理。</p>
<p><a href="">结束语</a></p>
<p>本文简要介绍了 ASM 字节码工具及其在 web services 开发中的应用。web services 的使用已经越来越广泛， 但在改造遗留系统过程中会遇到不少问题，本文针对其中一个主要问题给出了解决办法，该方法无须对现有系统做大量的改动， 即可将现存的 Java bean 转化成 web services 。本文对那些正考虑迁移到 JAX-WS 编程模型上的项目有一定的参考价值。在基于 JAX-WS 标准的 web services 的开发中，不少实际场景都是希望采用自底向上的开发方式， 即基于已有的 Java bean 来创建 web services 。WebSphere Application Server ( 以下简称 WAS ) 提供了命令行的工具 wsgen 和相对应的 Ant task 来支持这种开发过程，而且这两个工具比较适合大型项目的自动化构建。 这两个工具的使用前提是 Java bean 中事先添加有 web services 的 Annotation 标注，而在现有的业务系统中，class 文件一般是不带 Annotation 的，这就需要开发人员去修改现有的代码，以手工方式添加 Annotation，但这样带来的工作量太大且容易出错。本文介绍了一种解决途径，可以不用修改源代码，而是利用字节码工具 ASM 直接修改 class 文件， 在字节码文件中自动注入 Annotation ，然后再利用 wsgen 工具就可以很方便地生成 web services 应用。 本文同时也总结了使用 ASM 的一些实践。</p>
<p>本文首先介绍了和 ASM 使用相关的四种文件，以及它们之间的相互转化。然后结合 web services 开发实例，介绍了使用 wsgen 开发时遇到的实际问题，如何写一个 ASM 的适配器去修改现有 class，最终如何产生 web services 文件。</p>
<p>ASM 是一个多用途的 Java 字节码操控和分析框架。它能以二进制的形式直接修改现有的类或动态生成的类。 ASM 提供了常用的转换和分析算法，是一种允许用户方便的组装定制化的复杂转换和代码分析工具。 ASM 也提供和其它的字节码工具类似的功能，但 ASM 的重点是使用的简单和高性能。由于 ASM 在设计实现的时候尽可能 的小的内存占用和提供更高的性能；因此在动态系统中使用 ASM 是很有优势的。ASM 作为一种轻量级、高性能的 Java 字节码操控和分析框架，设计了一种更有效的方法、提供更好的性能和内存占用。今天， ASM 在许多领域都有应用，并已成为事实上的字节码处理框架标准。</p>
<p><a href="">问题的引入</a></p>
<p>先写一个不带 web services 标注的 SayHelloImpl 类。
<a href=""><strong>清单 1. 不带 web services 的 SayHelloImpl 类</strong></a>1</p>
<p>public</p>
<p>class</p>
<p>SayHelloImpl {</p>
<p>2</p>
<p>public</p>
<p>String sayHello(String s) {
3</p>
<p>return</p>
<p>“Hello: ” + s ;</p>
<p>4</p>
<p>}
5</p>
<p>}</p>
<p>再用 wsgen 来创建 web services，wsgen 的使用如下：
<a href=""><strong>清单 2. wsgen 实例</strong></a>1</p>
<p>wsgen.exe – </p>
<p>cp</p>
<p>bin – s output – d output – r output – wsdl ibm.was.asm.SayHelloImpl我们将会遇到如下错误： 
<a href=""><strong>清单 3. 根据不带 web services 标注的类创建 web services 时遇到的错误信息</strong></a> 
注释处理过程中遇到问题；</p>
<p>......
com.sun.tools.internal.ws.processor.modeler.ModelerException: [failed to localiz</p>
<p>e] A web service endpoint could not be found()
        at com.sun.tools.internal.ws.processor.modeler.annotation.WebServiceAP.o</p>
<p>nError(WebServiceAP.java:215)
        at com.sun.tools.internal.ws.processor.modeler.annotation.WebServiceAP.b</p>
<p>uildModel(WebServiceAP.java:322)
        at com.sun.tools.internal.ws.processor.modeler.annotation.WebServiceAP.p</p>
<p>rocess(WebServiceAP.java:256)
        at com.sun.mirror.apt.AnnotationProcessors$CompositeAnnotationProcessor.</p>
<p>process(AnnotationProcessors.java:60)</p>
<p>注意：我们通常是在 class 前使用 @WebService， 在方法前使用 @WebMethod 来将一个类标注为 web services 的。WAS 6.1 的 web services 功能部件包和 WAS 7 都支持基于 JAX-WS 标准 的 web services 的开发， 在 WAS 安装目录的 bin 目录下提供了命令行工具 wsgen，wsgen 支持自底向上的开发方式。 下面是 wsgen 的用法：
<a href=""><strong>清单 4. wsgen 命令格式</strong></a> 
注 wsgen [options]  [SEI]</p>
<p>主要选项：</p>
<ul>
<li>-d 指定生成的 class 文件位置；</li>
<li>-s 指定生成的 Java 源文件位置；</li>
<li>-r 指定生成的 resources 文件位置，如 wsdl，xsd；</li>
<li>-cp 指定服务实现类所在的位置；</li>
<li>-wsdl，-servicename，-portname 三个参数指定生成的 wsdl 文件中的 service 和 port 的名称。</li>
</ul>
<p>SEI(Service Endpoint Interface) 是一个 endpoint implementation class，不能是一个 interface。所以首先要开发一个 endpoint 的实现类，如本例中的 SayHelloImpl 。用 @WebService 声明 web services ，然后将它编译，才能提供给 wsgen 来创建 web services 。</p>
<p><a href="">四种文件之间的转换</a></p>
<p>下面介绍本文要用到的四个概念（Java Source，Java Class，ASM Code，ASM Source）</p>
<ul>
<li>Java Source: 即我们通常编写的 Java 源文件；</li>
<li>Java Class: Java 源文件编译后的字节码文件；</li>
<li>ASM Source : 类似于对 class 反编译后的源文件，也就是 &quot;textual byte code&quot;，但比原始的 Java Source 可读性要差， 参见清单 5。</li>
<li>ASM Code: 指读写 class 文件的 ASM 程序代码。需要用到 ASM 提供的 API， 参见清单 6。
<a href=""><strong>清单 5. SayHelloImpl 类对应的 ASM Source</strong></a>01</li>
</ul>
<p>// class version 50.0 (50)</p>
<p>02</p>
<p>// access flags 33
03</p>
<p>public</p>
<p>class</p>
<p>com/ibm/was/asm/SayHelloImpl {</p>
<p>04</p>
<p>05</p>
<p>// access flags 1</p>
<p>06</p>
<p>public</p>
<p><init>()V
07</p>
<p>ALOAD </p>
<p>0</p>
<p>08</p>
<p>INVOKESPECIAL java/lang/Object. <init> ()V
09</p>
<p>RETURN</p>
<p>10</p>
<p>MAXSTACK = </p>
<p>1
11</p>
<p>MAXLOCALS = </p>
<p>1</p>
<p>12</p>
<p>13</p>
<p>// access flags 1</p>
<p>14</p>
<p>public</p>
<p>sayHello(Ljava/lang/String;)Ljava/lang/String;
15</p>
<p>NEW java/lang/StringBuilder</p>
<p>16</p>
<p>DUP
17</p>
<p>LDC </p>
<p>&quot;Hello:&quot;</p>
<p>18</p>
<p>INVOKESPECIAL java/lang/StringBuilder. <init> (Ljava/lang/String;)V
19</p>
<p>ALOAD </p>
<p>1</p>
<p>20</p>
<p>INVOKEVIRTUAL java/lang/StringBuilder.append (Ljava/lang/String;)
21</p>
<p>Ljava/lang/StringBuilder;</p>
<p>22</p>
<p>INVOKEVIRTUAL java/lang/StringBuilder.toString ()Ljava/lang/String;
23</p>
<p>ARETURN</p>
<p>24</p>
<p>MAXSTACK = </p>
<p>3
25</p>
<p>MAXLOCALS = </p>
<p>2</p>
<p>26</p>
<p>}<a href=""><strong>清单 6. 生成 SayHelloImpl.class 的 ASM Code</strong></a>01</p>
<p>package</p>
<p>asm.com.ibm.was.asm;</p>
<p>02</p>
<p>import</p>
<p>java.util./*;
03</p>
<p>import</p>
<p>org.objectweb.asm./*;</p>
<p>04</p>
<p>import</p>
<p>org.objectweb.asm.attrs./*;
05</p>
<p>public</p>
<p>class</p>
<p>SayHelloImplDump </p>
<p>implements</p>
<p>Opcodes {</p>
<p>06</p>
<p>public</p>
<p>static</p>
<p>byte</p>
<p>[] dump () </p>
<p>throws</p>
<p>Exception {
07</p>
<p>ClassWriter cw = </p>
<p>new</p>
<p>ClassWriter(</p>
<p>0</p>
<p>);</p>
<p>08</p>
<p>FieldVisitor fv;
09</p>
<p>MethodVisitor mv;</p>
<p>10</p>
<p>AnnotationVisitor av0;
11</p>
<p>12</p>
<p>cw.visit(V1_6, ACC_PUBLIC + ACC_SUPER, </p>
<p>&quot;com/ibm/was/asm/SayHelloImpl&quot;</p>
<p>,
13</p>
<p>null</p>
<p>, </p>
<p>&quot;java/lang/Object&quot;</p>
<p>, </p>
<p>null</p>
<p>);</p>
<p>14</p>
<p>15</p>
<p>{</p>
<p>16</p>
<p>mv = cw.visitMethod(ACC_PUBLIC, </p>
<p>&quot;<init>&quot;</p>
<p>, </p>
<p>&quot;()V&quot;</p>
<p>, </p>
<p>null</p>
<p>, </p>
<p>null</p>
<p>);
17</p>
<p>mv.visitCode();</p>
<p>18</p>
<p>mv.visitVarInsn(ALOAD, </p>
<p>0</p>
<p>);
19</p>
<p>mv.visitMethodInsn(INVOKESPECIAL, </p>
<p>&quot;java/lang/Object&quot;</p>
<p>, </p>
<p>&quot;<init>&quot;</p>
<p>, </p>
<p>&quot;()V&quot;</p>
<p>);</p>
<p>20</p>
<p>mv.visitInsn(RETURN);
21</p>
<p>mv.visitMaxs(</p>
<p>1</p>
<p>, </p>
<p>1</p>
<p>);</p>
<p>22</p>
<p>mv.visitEnd();
23</p>
<p>}</p>
<p>24</p>
<p>{
25</p>
<p>mv = cw.visitMethod(ACC_PUBLIC, </p>
<p>&quot;sayHello&quot;</p>
<p>,</p>
<p>26</p>
<p>&quot;(Ljava/lang/String;)Ljava/lang/String;&quot;</p>
<p>, </p>
<p>null</p>
<p>, </p>
<p>null</p>
<p>);
27</p>
<p>mv.visitCode();</p>
<p>28</p>
<p>mv.visitTypeInsn(NEW, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>);
29</p>
<p>mv.visitInsn(DUP);</p>
<p>30</p>
<p>mv.visitLdcInsn(</p>
<p>&quot;Hello:&quot;</p>
<p>);
31</p>
<p>mv.visitMethodInsn(INVOKESPECIAL, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>,</p>
<p>32</p>
<p>&quot;<init>&quot;</p>
<p>, </p>
<p>&quot;(Ljava/lang/String;)V&quot;</p>
<p>);
33</p>
<p>mv.visitVarInsn(ALOAD, </p>
<p>1</p>
<p>);</p>
<p>34</p>
<p>mv.visitMethodInsn(INVOKEVIRTUAL, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>,
35</p>
<p>&quot;append&quot;</p>
<p>, </p>
<p>&quot;(Ljava/lang/String;)Ljava/lang/StringBuilder;&quot;</p>
<p>);</p>
<p>36</p>
<p>mv.visitMethodInsn(INVOKEVIRTUAL, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>,
37</p>
<p>&quot;toString&quot;</p>
<p>, </p>
<p>&quot;()Ljava/lang/String;&quot;</p>
<p>);</p>
<p>38</p>
<p>mv.visitInsn(ARETURN);
39</p>
<p>mv.visitMaxs(</p>
<p>3</p>
<p>, </p>
<p>2</p>
<p>);</p>
<p>40</p>
<p>mv.visitEnd();
41</p>
<p>}</p>
<p>42</p>
<p>cw.visitEnd();
43</p>
<p>return</p>
<p>cw.toByteArray();</p>
<p>44</p>
<p>}
45</p>
<p>}</p>
<p>图 1 描述了 Java Source 文件、Java Class 文件、ASM Code 文件和 ASM Source 文件之间的转换关系。
<a href=""><strong>图 1. 四种文件的转换图</strong></a> 
<a href=""><img src="" alt="图 1. 四种文件的转换图"></a> </p>
<p>如图 -1 所示，Java Source 文件通过 Javac 可以转换为 Java Class 文件。而相应的 Java Class 文件通过 Java 反编译器工具可转换为 Java Source 文件；</p>
<p>通 过 ASM Code 去创建和修改 Java Class 需要对 ASM API 比较熟悉才行，一个常见的问题时，怎么用 ASM Code 生成一个我们希望的 class 文件， 也就是说， 给定了 Java Class， 怎么得到其对应的 ASM Code 呢？ 所幸的是， ASM 框架为我们提供了 ASMifierClassVisitor 工具来产生 Java Class 对应的 ASM Code。代码如下：
<a href=""><strong>清单 7. 给定 class 文件，通过 ASMifierClassVisitor 获得其对应的 ASM Code</strong></a>01</p>
<p>public</p>
<p>void</p>
<p>showClassASMProcess() {</p>
<p>02</p>
<p>ClassReader cr;
03</p>
<p>final</p>
<p>String n = SayHelloImpl.</p>
<p>class</p>
<p>.getName();</p>
<p>04</p>
<p>05</p>
<p>try</p>
<p>{</p>
<p>06</p>
<p>cr = </p>
<p>new</p>
<p>ClassReader(n);<br>07</p>
<p>cr.accept(</p>
<p>new</p>
<p>ASMifierClassVisitor(</p>
<p>new</p>
<p>PrintWriter(System.out)),</p>
<p>08</p>
<p>new</p>
<p>Attribute[</p>
<p>0</p>
<p>],
09</p>
<p>ClassReader.SKIP_DEBUG);</p>
<p>10</p>
<p>11</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {</p>
<p>12</p>
<p>e.printStackTrace();
13</p>
<p>}</p>
<p>14</p>
<p>}</p>
<p>另外一个重要的转换就是， 给定了 Java Class 文件， 如何查看它的 ASM Source ？ 这点对于我们验证 ASM Code 生成的 class 是否正确很有用。ASM 提供了另外一个工具 TraceClassVisitor， 来获得一个 Java Class 对应的 ASM Source。代码如下：
<a href=""><strong>清单 8. 利用 TraceClassVisitor 查看 class 文件的 ASM Source</strong></a>01</p>
<p>//file 是 class 文件的全路径名</p>
<p>02</p>
<p>public</p>
<p>void</p>
<p>showClassSource(String file) {
03</p>
<p>FileInputStream is ;</p>
<p>04</p>
<p>ClassReader cr; 
05</p>
<p>06</p>
<p>try</p>
<p>{
07</p>
<p>is = </p>
<p>new</p>
<p>FileInputStream(file);     </p>
<p>08</p>
<p>cr = </p>
<p>new</p>
<p>ClassReader(is);
09</p>
<p>TraceClassVisitor trace = </p>
<p>new</p>
<p>TraceClassVisitor(</p>
<p>new</p>
<p>PrintWriter(System.out));</p>
<p>10</p>
<p>cr.accept(trace, ClassReader.SKIP_DEBUG);
11</p>
<p>12</p>
<p>is.close() ;
13</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {</p>
<p>14</p>
<p>e.printStackTrace() ;
15</p>
<p>}</p>
<p>16</p>
<p>}
17</p>
<p>{</p>
<p>18</p>
<p>e.printStackTrace();
19</p>
<p>}</p>
<p>20</p>
<p>}</p>
<p><a href="">ASM 类注入</a></p>
<p>ASM 类注入是指修改一个现有的 class 文件，在其中加入自己的代码。按通常思维，我们需要利用 ASM 提供的 reader 类去读取所要修改的类文件， 找到要修改的地方，如方法名或属性名，然后在该处插入自己的代码或修改现有的代码，这种思路将使问题复杂化。 ASM 为我们提供了访问类文件的 Visitor 模式，来遍历一个 class 文件，Visitor 是一个实现 ClassVisitor 接口的类。 要注入一个 class 文件，先要找到一个合适的 Visitor 做向导， ASM 提供了好几种 Visitor， 最常用的是 ClassWriter。同时我们需要提供一个适配器类 ClassAdapter， Visitor 会带着这个 Adapter 一起去遍历， 然后在遍历过程中回调 Adapter 提供的方法。我们在 Adapter 的这些方法中就可以实现我们的修改和定制逻辑。当然，如果你不想做任何修改，那 Visitor 遍历完后将得到一个和被遍历的 class 完全一样的拷贝。
<a href=""><strong>清单 9. 类注入的完整过程</strong></a>01</p>
<p>public</p>
<p>void</p>
<p>addAnnotationToExistingClass() {</p>
<p>02</p>
<p>FileInputStream is ;
03</p>
<p>ClassReader cr;          </p>
<p>04</p>
<p>try</p>
<p>{<br>05</p>
<p>String classfile = </p>
<p>&quot;E:\SayHelloImpl.class&quot;</p>
<p>; </p>
<p>// 待遍历的类</p>
<p>06</p>
<p>showClassSource(classfile) ;  </p>
<p>// 打印该类的 ASM source
07</p>
<p>08</p>
<p>is = </p>
<p>new</p>
<p>FileInputStream(classfile);<br>09</p>
<p>cr = </p>
<p>new</p>
<p>ClassReader(is);</p>
<p>10</p>
<p>// 此处我们使用 ClassWriter 做 Visitor
11</p>
<p>ClassWriter cw = </p>
<p>new</p>
<p>ClassWriter(ClassWriter.COMPUTE_MAXS);</p>
<p>12</p>
<p>// 给 Visitor 提供一个 Adapter
13</p>
<p>AddAnnotationAdapter adapter = </p>
<p>new</p>
<p>AddAnnotationAdapter(cw);           </p>
<p>14</p>
<p>cr.accept(adapter, ClassReader.SKIP_DEBUG);<br>15</p>
<p>16</p>
<p>// 遍历完后，生成的 class 保存在字节数组中
17</p>
<p>byte</p>
<p>[] b = cw.toByteArray();</p>
<p>18</p>
<p>19</p>
<p>try</p>
<p>{</p>
<p>20</p>
<p>// 将字节数组输出到文件中
21</p>
<p>// 为了不至于覆盖掉原有的 SayHelloImpl.class 文件，我们将结果输出到 _SayHelloImpl.class</p>
<p>22</p>
<p>FileOutputStream fout = </p>
<p>new</p>
<p>FileOutputStream(</p>
<p>&quot;E:\_SayHelloImpl.class&quot;</p>
<p>);
23</p>
<p>fout.write(b) ;</p>
<p>24</p>
<p>fout.flush();
25</p>
<p>fout.close() ;</p>
<p>26</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {
27</p>
<p>e.printStackTrace() ;</p>
<p>28</p>
<p>}
29</p>
<p>30</p>
<p>// 验证 _SayHelloImpl.class 是否包含我们注入的代码
31</p>
<p>showClassSource(</p>
<p>&quot;E:\_SayHelloImpl.class&quot;</p>
<p>) ;</p>
<p>32</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {
33</p>
<p>e.printStackTrace();</p>
<p>34</p>
<p>} 
35</p>
<p>}</p>
<p><a href="">web services 标记注入过程</a></p>
<p>我们已经知道了如何往 class 中注入自己的代码，那对于一个已有的 Java bean，怎么往里注入 @WebService 和 @WebMethod 呢？根据上面我们讲的转换关系，我们可以先写一个带 annotation 的 Java Source，编译得到 Java Class， 再得到其 ASM Code。下面是利用 ASM 给一个不带任何 Annotation 的 class 添加 @WebService 和 @WebMethod 的步骤。</p>
<ol>
<li>首先在 SayHelloImpl.java 中添加 @WebService 和 @WebMethod： 
<a href=""><strong>清单 10. 带 web services 标注的 SayHelloImpl 类</strong></a>1</li>
</ol>
<p>@WebService</p>
<p>2</p>
<p>public</p>
<p>class</p>
<p>SayHelloImpl {
3</p>
<p>@WebMethod</p>
<p>4</p>
<p>public</p>
<p>String sayHello(String s) {
5</p>
<p>return</p>
<p>&quot;Hello: &quot;</p>
<ul>
<li>s ;</li>
</ul>
<p>6</p>
<p>}
7</p>
<p>}</p>
<ol>
<li>通过 ASMifierClassVisitor 工具获得 SayHelloImpl class 的 ASM Code，见清单 6。</li>
<li>写一个 ClassAdapter 类， ClassAdapter 其实也是一个 Visitor。根据 ASM Code 的提示， 我们就可以知道如何利用 ASM API 去获得我们希望的 class 文件。下面是 Adapter 的示例代码。 
<a href=""><strong>清单 11. 添加 Annotation 的 Adapter 类</strong></a>01</li>
</ol>
<p>public</p>
<p>class</p>
<p>AddAnnotationAdapter </p>
<p>extends</p>
<p>ClassAdapter </p>
<p>implements</p>
<p>Opcodes{</p>
<p>02</p>
<p>//private String annotationDesc;
03</p>
<p>private</p>
<p>boolean</p>
<p>isAnnotationPresent;</p>
<p>04</p>
<p>05</p>
<p>public</p>
<p>AddAnnotationAdapter(ClassVisitor cv) {</p>
<p>06</p>
<p>super</p>
<p>(cv);
07</p>
<p>}</p>
<p>08</p>
<p>09</p>
<p>@Override</p>
<p>10</p>
<p>public</p>
<p>void</p>
<p>visit(</p>
<p>int</p>
<p>version, </p>
<p>int</p>
<p>access, String name, String signature,
11</p>
<p>String superName, String[] interfaces) {</p>
<p>12</p>
<p>13</p>
<p>cv.visit(V1_6, ACC_PUBLIC + ACC_SUPER, name, signature, superName,</p>
<p>14</p>
<p>interfaces);
15</p>
<p>AnnotationVisitor av0;</p>
<p>16</p>
<p>av0 = cv.visitAnnotation(</p>
<p>&quot;Ljavax/jws/WebService;&quot;</p>
<p>, </p>
<p>true</p>
<p>);
17</p>
<p>av0.visitEnd();</p>
<p>18</p>
<p>}
19</p>
<p>20</p>
<p>@Override
21</p>
<p>public</p>
<p>AnnotationVisitor visitAnnotation(String desc, </p>
<p>boolean</p>
<p>visible) {</p>
<p>22</p>
<p>return</p>
<p>cv.visitAnnotation(desc, visible);
23</p>
<p>}</p>
<p>24</p>
<p>25</p>
<p>@Override</p>
<p>26</p>
<p>public</p>
<p>void</p>
<p>visitInnerClass(String name, String outerName,
27</p>
<p>String innerName, </p>
<p>int</p>
<p>access) {</p>
<p>28</p>
<p>cv.visitInnerClass(name, outerName, innerName, access);
29</p>
<p>}</p>
<p>30</p>
<p>31</p>
<p>@Override</p>
<p>32</p>
<p>public</p>
<p>FieldVisitor visitField(</p>
<p>int</p>
<p>access, String name, String desc,
33</p>
<p>String signature, Object value) {</p>
<p>34</p>
<p>return</p>
<p>cv.visitField(access, name, desc, signature, value);
35</p>
<p>}</p>
<p>36</p>
<p>37</p>
<p>@Override</p>
<p>38</p>
<p>public</p>
<p>MethodVisitor visitMethod(</p>
<p>int</p>
<p>access, String name, String desc,
39</p>
<p>String signature, String[] exceptions) {   </p>
<p>40</p>
<p>MethodVisitor mv  = cv.visitMethod(access, name, desc, signature,
41</p>
<p>exceptions);</p>
<p>42</p>
<p>if</p>
<p>(!name.equals(</p>
<p>&quot;<init>&quot;</p>
<p>)) {
43</p>
<p>AnnotationVisitor av0;</p>
<p>44</p>
<p>av0 = mv.visitAnnotation(</p>
<p>&quot;Ljavax/jws/WebMethod;&quot;</p>
<p>, </p>
<p>true</p>
<p>);
45</p>
<p>av0.visitEnd();</p>
<p>46</p>
<p>}
47</p>
<p>return</p>
<p>mv;</p>
<p>48</p>
<p>}
49</p>
<p>50</p>
<p>@Override
51</p>
<p>public</p>
<p>void</p>
<p>visitEnd() {</p>
<p>52</p>
<p>cv.visitEnd();
53</p>
<p>}</p>
<p>54</p>
<p>55</p>
<p>}</p>
<p>最后，我们采用上面讲的类注入办法，即可得到一个带 @WebService 和 @WebMethod 标注的 class 文件。再通过 wsgen 工具即可成功创建 web services，该命令将会在 src 目录下生成 web services 描述文件：SayHelloImplService.wsdl，SayHelloImplService_schema1.xsd，同时生成了 2 个 JAX-WS 文件，分别为：SayHello.java，SayHelloResponse.java。</p>
<p>当然，在实际应用中，我们可能需要将一个 class 的某些特定方法发布为 web services，这就需要我们对 Adapter 做进一步的改造，在 visitMethod() 方法中根据方法名称等参数做进一步的处理。</p>
<p><a href="">结束语</a></p>
<p>本文简要介绍了 ASM 字节码工具及其在 web services 开发中的应用。web services 的使用已经越来越广泛， 但在改造遗留系统过程中会遇到不少问题，本文针对其中一个主要问题给出了解决办法，该方法无须对现有系统做大量的改动， 即可将现存的 Java bean 转化成 web services 。本文对那些正考虑迁移到 JAX-WS 编程模型上的项目有一定的参考价值。在基于 JAX-WS 标准的 web services 的开发中，不少实际场景都是希望采用自底向上的开发方式， 即基于已有的 Java bean 来创建 web services 。WebSphere Application Server ( 以下简称 WAS ) 提供了命令行的工具 wsgen 和相对应的 Ant task 来支持这种开发过程，而且这两个工具比较适合大型项目的自动化构建。 这两个工具的使用前提是 Java bean 中事先添加有 web services 的 Annotation 标注，而在现有的业务系统中，class 文件一般是不带 Annotation 的，这就需要开发人员去修改现有的代码，以手工方式添加 Annotation，但这样带来的工作量太大且容易出错。本文介绍了一种解决途径，可以不用修改源代码，而是利用字节码工具 ASM 直接修改 class 文件， 在字节码文件中自动注入 Annotation ，然后再利用 wsgen 工具就可以很方便地生成 web services 应用。 本文同时也总结了使用 ASM 的一些实践。</p>
<p>本文首先介绍了和 ASM 使用相关的四种文件，以及它们之间的相互转化。然后结合 web services 开发实例，介绍了使用 wsgen 开发时遇到的实际问题，如何写一个 ASM 的适配器去修改现有 class，最终如何产生 web services 文件。</p>
<p>ASM 是一个多用途的 Java 字节码操控和分析框架。它能以二进制的形式直接修改现有的类或动态生成的类。 ASM 提供了常用的转换和分析算法，是一种允许用户方便的组装定制化的复杂转换和代码分析工具。 ASM 也提供和其它的字节码工具类似的功能，但 ASM 的重点是使用的简单和高性能。由于 ASM 在设计实现的时候尽可能 的小的内存占用和提供更高的性能；因此在动态系统中使用 ASM 是很有优势的。ASM 作为一种轻量级、高性能的 Java 字节码操控和分析框架，设计了一种更有效的方法、提供更好的性能和内存占用。今天， ASM 在许多领域都有应用，并已成为事实上的字节码处理框架标准。</p>
<p><a href="">问题的引入</a></p>
<p>先写一个不带 web services 标注的 SayHelloImpl 类。
<a href=""><strong>清单 1. 不带 web services 的 SayHelloImpl 类</strong></a>1</p>
<p>public</p>
<p>class</p>
<p>SayHelloImpl {</p>
<p>2</p>
<p>public</p>
<p>String sayHello(String s) {
3</p>
<p>return</p>
<p>“Hello: ” + s ;</p>
<p>4</p>
<p>}
5</p>
<p>}</p>
<p>再用 wsgen 来创建 web services，wsgen 的使用如下：
<a href=""><strong>清单 2. wsgen 实例</strong></a>1</p>
<p>wsgen.exe – </p>
<p>cp</p>
<p>bin – s output – d output – r output – wsdl ibm.was.asm.SayHelloImpl我们将会遇到如下错误： 
<a href=""><strong>清单 3. 根据不带 web services 标注的类创建 web services 时遇到的错误信息</strong></a> 
注释处理过程中遇到问题；</p>
<p>......
com.sun.tools.internal.ws.processor.modeler.ModelerException: [failed to localiz</p>
<p>e] A web service endpoint could not be found()
        at com.sun.tools.internal.ws.processor.modeler.annotation.WebServiceAP.o</p>
<p>nError(WebServiceAP.java:215)
        at com.sun.tools.internal.ws.processor.modeler.annotation.WebServiceAP.b</p>
<p>uildModel(WebServiceAP.java:322)
        at com.sun.tools.internal.ws.processor.modeler.annotation.WebServiceAP.p</p>
<p>rocess(WebServiceAP.java:256)
        at com.sun.mirror.apt.AnnotationProcessors$CompositeAnnotationProcessor.</p>
<p>process(AnnotationProcessors.java:60)</p>
<p>注意：我们通常是在 class 前使用 @WebService， 在方法前使用 @WebMethod 来将一个类标注为 web services 的。WAS 6.1 的 web services 功能部件包和 WAS 7 都支持基于 JAX-WS 标准 的 web services 的开发， 在 WAS 安装目录的 bin 目录下提供了命令行工具 wsgen，wsgen 支持自底向上的开发方式。 下面是 wsgen 的用法：
<a href=""><strong>清单 4. wsgen 命令格式</strong></a> 
注 wsgen [options]  [SEI]</p>
<p>主要选项：</p>
<ul>
<li>-d 指定生成的 class 文件位置；</li>
<li>-s 指定生成的 Java 源文件位置；</li>
<li>-r 指定生成的 resources 文件位置，如 wsdl，xsd；</li>
<li>-cp 指定服务实现类所在的位置；</li>
<li>-wsdl，-servicename，-portname 三个参数指定生成的 wsdl 文件中的 service 和 port 的名称。</li>
</ul>
<p>SEI(Service Endpoint Interface) 是一个 endpoint implementation class，不能是一个 interface。所以首先要开发一个 endpoint 的实现类，如本例中的 SayHelloImpl 。用 @WebService 声明 web services ，然后将它编译，才能提供给 wsgen 来创建 web services 。</p>
<p><a href="">四种文件之间的转换</a></p>
<p>下面介绍本文要用到的四个概念（Java Source，Java Class，ASM Code，ASM Source）</p>
<ul>
<li>Java Source: 即我们通常编写的 Java 源文件；</li>
<li>Java Class: Java 源文件编译后的字节码文件；</li>
<li>ASM Source : 类似于对 class 反编译后的源文件，也就是 &quot;textual byte code&quot;，但比原始的 Java Source 可读性要差， 参见清单 5。</li>
<li>ASM Code: 指读写 class 文件的 ASM 程序代码。需要用到 ASM 提供的 API， 参见清单 6。
<a href=""><strong>清单 5. SayHelloImpl 类对应的 ASM Source</strong></a>01</li>
</ul>
<p>// class version 50.0 (50)</p>
<p>02</p>
<p>// access flags 33
03</p>
<p>public</p>
<p>class</p>
<p>com/ibm/was/asm/SayHelloImpl {</p>
<p>04</p>
<p>05</p>
<p>// access flags 1</p>
<p>06</p>
<p>public</p>
<p><init>()V
07</p>
<p>ALOAD </p>
<p>0</p>
<p>08</p>
<p>INVOKESPECIAL java/lang/Object. <init> ()V
09</p>
<p>RETURN</p>
<p>10</p>
<p>MAXSTACK = </p>
<p>1
11</p>
<p>MAXLOCALS = </p>
<p>1</p>
<p>12</p>
<p>13</p>
<p>// access flags 1</p>
<p>14</p>
<p>public</p>
<p>sayHello(Ljava/lang/String;)Ljava/lang/String;
15</p>
<p>NEW java/lang/StringBuilder</p>
<p>16</p>
<p>DUP
17</p>
<p>LDC </p>
<p>&quot;Hello:&quot;</p>
<p>18</p>
<p>INVOKESPECIAL java/lang/StringBuilder. <init> (Ljava/lang/String;)V
19</p>
<p>ALOAD </p>
<p>1</p>
<p>20</p>
<p>INVOKEVIRTUAL java/lang/StringBuilder.append (Ljava/lang/String;)
21</p>
<p>Ljava/lang/StringBuilder;</p>
<p>22</p>
<p>INVOKEVIRTUAL java/lang/StringBuilder.toString ()Ljava/lang/String;
23</p>
<p>ARETURN</p>
<p>24</p>
<p>MAXSTACK = </p>
<p>3
25</p>
<p>MAXLOCALS = </p>
<p>2</p>
<p>26</p>
<p>}<a href=""><strong>清单 6. 生成 SayHelloImpl.class 的 ASM Code</strong></a>01</p>
<p>package</p>
<p>asm.com.ibm.was.asm;</p>
<p>02</p>
<p>import</p>
<p>java.util./*;
03</p>
<p>import</p>
<p>org.objectweb.asm./*;</p>
<p>04</p>
<p>import</p>
<p>org.objectweb.asm.attrs./*;
05</p>
<p>public</p>
<p>class</p>
<p>SayHelloImplDump </p>
<p>implements</p>
<p>Opcodes {</p>
<p>06</p>
<p>public</p>
<p>static</p>
<p>byte</p>
<p>[] dump () </p>
<p>throws</p>
<p>Exception {
07</p>
<p>ClassWriter cw = </p>
<p>new</p>
<p>ClassWriter(</p>
<p>0</p>
<p>);</p>
<p>08</p>
<p>FieldVisitor fv;
09</p>
<p>MethodVisitor mv;</p>
<p>10</p>
<p>AnnotationVisitor av0;
11</p>
<p>12</p>
<p>cw.visit(V1_6, ACC_PUBLIC + ACC_SUPER, </p>
<p>&quot;com/ibm/was/asm/SayHelloImpl&quot;</p>
<p>,
13</p>
<p>null</p>
<p>, </p>
<p>&quot;java/lang/Object&quot;</p>
<p>, </p>
<p>null</p>
<p>);</p>
<p>14</p>
<p>15</p>
<p>{</p>
<p>16</p>
<p>mv = cw.visitMethod(ACC_PUBLIC, </p>
<p>&quot;<init>&quot;</p>
<p>, </p>
<p>&quot;()V&quot;</p>
<p>, </p>
<p>null</p>
<p>, </p>
<p>null</p>
<p>);
17</p>
<p>mv.visitCode();</p>
<p>18</p>
<p>mv.visitVarInsn(ALOAD, </p>
<p>0</p>
<p>);
19</p>
<p>mv.visitMethodInsn(INVOKESPECIAL, </p>
<p>&quot;java/lang/Object&quot;</p>
<p>, </p>
<p>&quot;<init>&quot;</p>
<p>, </p>
<p>&quot;()V&quot;</p>
<p>);</p>
<p>20</p>
<p>mv.visitInsn(RETURN);
21</p>
<p>mv.visitMaxs(</p>
<p>1</p>
<p>, </p>
<p>1</p>
<p>);</p>
<p>22</p>
<p>mv.visitEnd();
23</p>
<p>}</p>
<p>24</p>
<p>{
25</p>
<p>mv = cw.visitMethod(ACC_PUBLIC, </p>
<p>&quot;sayHello&quot;</p>
<p>,</p>
<p>26</p>
<p>&quot;(Ljava/lang/String;)Ljava/lang/String;&quot;</p>
<p>, </p>
<p>null</p>
<p>, </p>
<p>null</p>
<p>);
27</p>
<p>mv.visitCode();</p>
<p>28</p>
<p>mv.visitTypeInsn(NEW, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>);
29</p>
<p>mv.visitInsn(DUP);</p>
<p>30</p>
<p>mv.visitLdcInsn(</p>
<p>&quot;Hello:&quot;</p>
<p>);
31</p>
<p>mv.visitMethodInsn(INVOKESPECIAL, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>,</p>
<p>32</p>
<p>&quot;<init>&quot;</p>
<p>, </p>
<p>&quot;(Ljava/lang/String;)V&quot;</p>
<p>);
33</p>
<p>mv.visitVarInsn(ALOAD, </p>
<p>1</p>
<p>);</p>
<p>34</p>
<p>mv.visitMethodInsn(INVOKEVIRTUAL, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>,
35</p>
<p>&quot;append&quot;</p>
<p>, </p>
<p>&quot;(Ljava/lang/String;)Ljava/lang/StringBuilder;&quot;</p>
<p>);</p>
<p>36</p>
<p>mv.visitMethodInsn(INVOKEVIRTUAL, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>,
37</p>
<p>&quot;toString&quot;</p>
<p>, </p>
<p>&quot;()Ljava/lang/String;&quot;</p>
<p>);</p>
<p>38</p>
<p>mv.visitInsn(ARETURN);
39</p>
<p>mv.visitMaxs(</p>
<p>3</p>
<p>, </p>
<p>2</p>
<p>);</p>
<p>40</p>
<p>mv.visitEnd();
41</p>
<p>}</p>
<p>42</p>
<p>cw.visitEnd();
43</p>
<p>return</p>
<p>cw.toByteArray();</p>
<p>44</p>
<p>}
45</p>
<p>}</p>
<p>图 1 描述了 Java Source 文件、Java Class 文件、ASM Code 文件和 ASM Source 文件之间的转换关系。
<a href=""><strong>图 1. 四种文件的转换图</strong></a> 
<a href=""><img src="" alt="图 1. 四种文件的转换图"></a> </p>
<p>如图 -1 所示，Java Source 文件通过 Javac 可以转换为 Java Class 文件。而相应的 Java Class 文件通过 Java 反编译器工具可转换为 Java Source 文件；</p>
<p>通 过 ASM Code 去创建和修改 Java Class 需要对 ASM API 比较熟悉才行，一个常见的问题时，怎么用 ASM Code 生成一个我们希望的 class 文件， 也就是说， 给定了 Java Class， 怎么得到其对应的 ASM Code 呢？ 所幸的是， ASM 框架为我们提供了 ASMifierClassVisitor 工具来产生 Java Class 对应的 ASM Code。代码如下：
<a href=""><strong>清单 7. 给定 class 文件，通过 ASMifierClassVisitor 获得其对应的 ASM Code</strong></a>01</p>
<p>public</p>
<p>void</p>
<p>showClassASMProcess() {</p>
<p>02</p>
<p>ClassReader cr;
03</p>
<p>final</p>
<p>String n = SayHelloImpl.</p>
<p>class</p>
<p>.getName();</p>
<p>04</p>
<p>05</p>
<p>try</p>
<p>{</p>
<p>06</p>
<p>cr = </p>
<p>new</p>
<p>ClassReader(n);<br>07</p>
<p>cr.accept(</p>
<p>new</p>
<p>ASMifierClassVisitor(</p>
<p>new</p>
<p>PrintWriter(System.out)),</p>
<p>08</p>
<p>new</p>
<p>Attribute[</p>
<p>0</p>
<p>],
09</p>
<p>ClassReader.SKIP_DEBUG);</p>
<p>10</p>
<p>11</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {</p>
<p>12</p>
<p>e.printStackTrace();
13</p>
<p>}</p>
<p>14</p>
<p>}</p>
<p>另外一个重要的转换就是， 给定了 Java Class 文件， 如何查看它的 ASM Source ？ 这点对于我们验证 ASM Code 生成的 class 是否正确很有用。ASM 提供了另外一个工具 TraceClassVisitor， 来获得一个 Java Class 对应的 ASM Source。代码如下：
<a href=""><strong>清单 8. 利用 TraceClassVisitor 查看 class 文件的 ASM Source</strong></a>01</p>
<p>//file 是 class 文件的全路径名</p>
<p>02</p>
<p>public</p>
<p>void</p>
<p>showClassSource(String file) {
03</p>
<p>FileInputStream is ;</p>
<p>04</p>
<p>ClassReader cr; 
05</p>
<p>06</p>
<p>try</p>
<p>{
07</p>
<p>is = </p>
<p>new</p>
<p>FileInputStream(file);     </p>
<p>08</p>
<p>cr = </p>
<p>new</p>
<p>ClassReader(is);
09</p>
<p>TraceClassVisitor trace = </p>
<p>new</p>
<p>TraceClassVisitor(</p>
<p>new</p>
<p>PrintWriter(System.out));</p>
<p>10</p>
<p>cr.accept(trace, ClassReader.SKIP_DEBUG);
11</p>
<p>12</p>
<p>is.close() ;
13</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {</p>
<p>14</p>
<p>e.printStackTrace() ;
15</p>
<p>}</p>
<p>16</p>
<p>}
17</p>
<p>{</p>
<p>18</p>
<p>e.printStackTrace();
19</p>
<p>}</p>
<p>20</p>
<p>}</p>
<p><a href="">ASM 类注入</a></p>
<p>ASM 类注入是指修改一个现有的 class 文件，在其中加入自己的代码。按通常思维，我们需要利用 ASM 提供的 reader 类去读取所要修改的类文件， 找到要修改的地方，如方法名或属性名，然后在该处插入自己的代码或修改现有的代码，这种思路将使问题复杂化。 ASM 为我们提供了访问类文件的 Visitor 模式，来遍历一个 class 文件，Visitor 是一个实现 ClassVisitor 接口的类。 要注入一个 class 文件，先要找到一个合适的 Visitor 做向导， ASM 提供了好几种 Visitor， 最常用的是 ClassWriter。同时我们需要提供一个适配器类 ClassAdapter， Visitor 会带着这个 Adapter 一起去遍历， 然后在遍历过程中回调 Adapter 提供的方法。我们在 Adapter 的这些方法中就可以实现我们的修改和定制逻辑。当然，如果你不想做任何修改，那 Visitor 遍历完后将得到一个和被遍历的 class 完全一样的拷贝。
<a href=""><strong>清单 9. 类注入的完整过程</strong></a>01</p>
<p>public</p>
<p>void</p>
<p>addAnnotationToExistingClass() {</p>
<p>02</p>
<p>FileInputStream is ;
03</p>
<p>ClassReader cr;          </p>
<p>04</p>
<p>try</p>
<p>{<br>05</p>
<p>String classfile = </p>
<p>&quot;E:\SayHelloImpl.class&quot;</p>
<p>; </p>
<p>// 待遍历的类</p>
<p>06</p>
<p>showClassSource(classfile) ;  </p>
<p>// 打印该类的 ASM source
07</p>
<p>08</p>
<p>is = </p>
<p>new</p>
<p>FileInputStream(classfile);<br>09</p>
<p>cr = </p>
<p>new</p>
<p>ClassReader(is);</p>
<p>10</p>
<p>// 此处我们使用 ClassWriter 做 Visitor
11</p>
<p>ClassWriter cw = </p>
<p>new</p>
<p>ClassWriter(ClassWriter.COMPUTE_MAXS);</p>
<p>12</p>
<p>// 给 Visitor 提供一个 Adapter
13</p>
<p>AddAnnotationAdapter adapter = </p>
<p>new</p>
<p>AddAnnotationAdapter(cw);           </p>
<p>14</p>
<p>cr.accept(adapter, ClassReader.SKIP_DEBUG);<br>15</p>
<p>16</p>
<p>// 遍历完后，生成的 class 保存在字节数组中
17</p>
<p>byte</p>
<p>[] b = cw.toByteArray();</p>
<p>18</p>
<p>19</p>
<p>try</p>
<p>{</p>
<p>20</p>
<p>// 将字节数组输出到文件中
21</p>
<p>// 为了不至于覆盖掉原有的 SayHelloImpl.class 文件，我们将结果输出到 _SayHelloImpl.class</p>
<p>22</p>
<p>FileOutputStream fout = </p>
<p>new</p>
<p>FileOutputStream(</p>
<p>&quot;E:\_SayHelloImpl.class&quot;</p>
<p>);
23</p>
<p>fout.write(b) ;</p>
<p>24</p>
<p>fout.flush();
25</p>
<p>fout.close() ;</p>
<p>26</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {
27</p>
<p>e.printStackTrace() ;</p>
<p>28</p>
<p>}
29</p>
<p>30</p>
<p>// 验证 _SayHelloImpl.class 是否包含我们注入的代码
31</p>
<p>showClassSource(</p>
<p>&quot;E:\_SayHelloImpl.class&quot;</p>
<p>) ;</p>
<p>32</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {
33</p>
<p>e.printStackTrace();</p>
<p>34</p>
<p>} 
35</p>
<p>}</p>
<p><a href="">web services 标记注入过程</a></p>
<p>我们已经知道了如何往 class 中注入自己的代码，那对于一个已有的 Java bean，怎么往里注入 @WebService 和 @WebMethod 呢？根据上面我们讲的转换关系，我们可以先写一个带 annotation 的 Java Source，编译得到 Java Class， 再得到其 ASM Code。下面是利用 ASM 给一个不带任何 Annotation 的 class 添加 @WebService 和 @WebMethod 的步骤。</p>
<ol>
<li>首先在 SayHelloImpl.java 中添加 @WebService 和 @WebMethod： 
<a href=""><strong>清单 10. 带 web services 标注的 SayHelloImpl 类</strong></a>1</li>
</ol>
<p>@WebService</p>
<p>2</p>
<p>public</p>
<p>class</p>
<p>SayHelloImpl {
3</p>
<p>@WebMethod</p>
<p>4</p>
<p>public</p>
<p>String sayHello(String s) {
5</p>
<p>return</p>
<p>&quot;Hello: &quot;</p>
<ul>
<li>s ;</li>
</ul>
<p>6</p>
<p>}
7</p>
<p>}</p>
<ol>
<li>通过 ASMifierClassVisitor 工具获得 SayHelloImpl class 的 ASM Code，见清单 6。</li>
<li>写一个 ClassAdapter 类， ClassAdapter 其实也是一个 Visitor。根据 ASM Code 的提示， 我们就可以知道如何利用 ASM API 去获得我们希望的 class 文件。下面是 Adapter 的示例代码。 
<a href=""><strong>清单 11. 添加 Annotation 的 Adapter 类</strong></a>01</li>
</ol>
<p>public</p>
<p>class</p>
<p>AddAnnotationAdapter </p>
<p>extends</p>
<p>ClassAdapter </p>
<p>implements</p>
<p>Opcodes{</p>
<p>02</p>
<p>//private String annotationDesc;
03</p>
<p>private</p>
<p>boolean</p>
<p>isAnnotationPresent;</p>
<p>04</p>
<p>05</p>
<p>public</p>
<p>AddAnnotationAdapter(ClassVisitor cv) {</p>
<p>06</p>
<p>super</p>
<p>(cv);
07</p>
<p>}</p>
<p>08</p>
<p>09</p>
<p>@Override</p>
<p>10</p>
<p>public</p>
<p>void</p>
<p>visit(</p>
<p>int</p>
<p>version, </p>
<p>int</p>
<p>access, String name, String signature,
11</p>
<p>String superName, String[] interfaces) {</p>
<p>12</p>
<p>13</p>
<p>cv.visit(V1_6, ACC_PUBLIC + ACC_SUPER, name, signature, superName,</p>
<p>14</p>
<p>interfaces);
15</p>
<p>AnnotationVisitor av0;</p>
<p>16</p>
<p>av0 = cv.visitAnnotation(</p>
<p>&quot;Ljavax/jws/WebService;&quot;</p>
<p>, </p>
<p>true</p>
<p>);
17</p>
<p>av0.visitEnd();</p>
<p>18</p>
<p>}
19</p>
<p>20</p>
<p>@Override
21</p>
<p>public</p>
<p>AnnotationVisitor visitAnnotation(String desc, </p>
<p>boolean</p>
<p>visible) {</p>
<p>22</p>
<p>return</p>
<p>cv.visitAnnotation(desc, visible);
23</p>
<p>}</p>
<p>24</p>
<p>25</p>
<p>@Override</p>
<p>26</p>
<p>public</p>
<p>void</p>
<p>visitInnerClass(String name, String outerName,
27</p>
<p>String innerName, </p>
<p>int</p>
<p>access) {</p>
<p>28</p>
<p>cv.visitInnerClass(name, outerName, innerName, access);
29</p>
<p>}</p>
<p>30</p>
<p>31</p>
<p>@Override</p>
<p>32</p>
<p>public</p>
<p>FieldVisitor visitField(</p>
<p>int</p>
<p>access, String name, String desc,
33</p>
<p>String signature, Object value) {</p>
<p>34</p>
<p>return</p>
<p>cv.visitField(access, name, desc, signature, value);
35</p>
<p>}</p>
<p>36</p>
<p>37</p>
<p>@Override</p>
<p>38</p>
<p>public</p>
<p>MethodVisitor visitMethod(</p>
<p>int</p>
<p>access, String name, String desc,
39</p>
<p>String signature, String[] exceptions) {   </p>
<p>40</p>
<p>MethodVisitor mv  = cv.visitMethod(access, name, desc, signature,
41</p>
<p>exceptions);</p>
<p>42</p>
<p>if</p>
<p>(!name.equals(</p>
<p>&quot;<init>&quot;</p>
<p>)) {
43</p>
<p>AnnotationVisitor av0;</p>
<p>44</p>
<p>av0 = mv.visitAnnotation(</p>
<p>&quot;Ljavax/jws/WebMethod;&quot;</p>
<p>, </p>
<p>true</p>
<p>);
45</p>
<p>av0.visitEnd();</p>
<p>46</p>
<p>}
47</p>
<p>return</p>
<p>mv;</p>
<p>48</p>
<p>}
49</p>
<p>50</p>
<p>@Override
51</p>
<p>public</p>
<p>void</p>
<p>visitEnd() {</p>
<p>52</p>
<p>cv.visitEnd();
53</p>
<p>}</p>
<p>54</p>
<p>55</p>
<p>}</p>
<p>最后，我们采用上面讲的类注入办法，即可得到一个带 @WebService 和 @WebMethod 标注的 class 文件。再通过 wsgen 工具即可成功创建 web services，该命令将会在 src 目录下生成 web services 描述文件：SayHelloImplService.wsdl，SayHelloImplService_schema1.xsd，同时生成了 2 个 JAX-WS 文件，分别为：SayHello.java，SayHelloResponse.java。</p>
<p>当然，在实际应用中，我们可能需要将一个 class 的某些特定方法发布为 web services，这就需要我们对 Adapter 做进一步的改造，在 visitMethod() 方法中根据方法名称等参数做进一步的处理。</p>
<p><a href="">结束语</a></p>
<p>本文简要介绍了 ASM 字节码工具及其在 web services 开发中的应用。web services 的使用已经越来越广泛， 但在改造遗留系统过程中会遇到不少问题，本文针对其中一个主要问题给出了解决办法，该方法无须对现有系统做大量的改动， 即可将现存的 Java bean 转化成 web services 。本文对那些正考虑迁移到 JAX-WS 编程模型上的项目有一定的参考价值。</p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:42"datetime="2014-03-07 09:54:42"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE--Java字节码工具ASM在WebService开发中的应用/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE--Java字节码工具ASM在WebService开发中的应用" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_设计类--概要设计文档模板/">概要设计文档模板</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:42.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_设计类--概要设计文档模板/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-">概要设计文档模板</h1>
<p><img src="" alt=""></p>
<p><a href="http://www.cnblogs.com/campo/" target="_blank">campo</a>
态度和细节决定一切 专注 务实 探索
随笔- 55  文章- 2  评论- 151 </p>
<p><a href="http://www.cnblogs.com/" target="_blank">博客园</a>  <a href="http://www.cnblogs.com/campo/" target="_blank">首页</a>  <a href="http://www.cnblogs.com/campo/admin/EditPosts.aspx?opt=1" target="_blank">新随笔</a>  <a href="http://space.cnblogs.com/msg/send/campo" target="_blank">联系</a>  <a href="http://www.cnblogs.com/campo/admin/EditPosts.aspx" target="_blank">管理</a>  <a href="http://www.cnblogs.com/campo/rss" target="_blank">订阅</a> <a href="http://www.cnblogs.com/campo/rss" target="_blank"><img src="" alt="订阅"></a></p>
<h1 id="-http-www-cnblogs-com-campo-archive-2007-08-24-867923-html-"><a href="http://www.cnblogs.com/campo/archive/2007/08/24/867923.html" target="_blank">概要设计文档模板</a></h1>
<p><strong><a href=""></a>概要设计说明书</strong> <strong>一． 引言</strong> 1． 编写目的 <img src="" alt="">500){this.resized=true;this.style.width=500;}&quot; resized=&quot;0&quot;&gt;从该阶段开发正式进入软件的实际开发阶段，本阶段完成系统的大致设计并明确系统的数据结构与软件结构。在软件设计阶段主要是把一个软件需求转化为软件表示的过程，这种表示只是描绘出软件的总的概貌。本概要设计说明书的目的就是进一步细化软件设计阶段得出的软件总体概貌，把它加工成在程序细节上非常接近于源程序的软件表示。 2． 项目背景（略） 3． 定义 <img src="" alt="">500){this.resized=true;this.style.width=500;}&quot; resized=&quot;0&quot;&gt;在该概要设计说明书中的专门术语有：
<img src="" alt="">500){this.resized=true;this.style.width=500;}&quot; resized=&quot;0&quot;&gt;<strong>总体设计<strong>**</strong></strong><img src="" alt="">500){this.resized=true;this.style.width=500;}&quot; resized=&quot;0&quot;&gt;接口设计**</p>
<p><strong><img src="" alt="">500){this.resized=true;this.style.width=500;}&quot; resized=&quot;0&quot;&gt;数据结构设计</strong></p>
<p><strong><img src="" alt="">500){this.resized=true;this.style.width=500;}&quot; resized=&quot;0&quot;&gt;运行设计</strong></p>
<p><strong><img src="" alt="">500){this.resized=true;this.style.width=500;}&quot; resized=&quot;0&quot;&gt;出错设计</strong>
<img src="" alt="">500){this.resized=true;this.style.width=500;}&quot; resized=&quot;0&quot;&gt;具体的概念与含义在文档后将会解释。 4． 参考资料 <img src="" alt="">500){this.resized=true;this.style.width=500;}&quot; resized=&quot;0&quot;&gt;&lt;软件工程概论&gt; 李存珠 李宣东 编著 南京大学<a href="http://www.mflw.com/search.aspx?keyword=%BC%C6%CB%E3%BB%FA&amp;where=title" title="电脑和计算机方面" target="_blank">计算机</a>系出版 2001年8月 <strong>二． 任务概述</strong> 1． 目标 <img src="" alt="">500){this.resized=true;this.style.width=500;}&quot; resized=&quot;0&quot;&gt;该阶段目的在于明确系统的数据结构和软件结构，此外总体设计还将给出内部软件和外部系统部件之间的接口定义，各个软件模块的功能说明，数据结构的细节以及具体的装配要求。 2． 运行环境 <img src="" alt="">500){this.resized=true;this.style.width=500;}&quot; resized=&quot;0&quot;&gt;软件基本运行环境为Windows环境。 3． 需求概述（略） 4． 条件与限制 <img src="" alt="">500){this.resized=true;this.style.width=500;}&quot; resized=&quot;0&quot;&gt;为了评价该设计阶段的设计表示的“优劣程度”，必须遵循以下几个准则：
<img src="" alt="">500){this.resized=true;this.style.width=500;}&quot; resized=&quot;0&quot;&gt;1.软件设计应当表现出层次结构，它应巧妙地利用各个软件部件之间的控制关系。
<img src="" alt="">500){this.resized=true;this.style.width=500;}&quot; resized=&quot;0&quot;&gt;2.设计应当是模块化的，即该软件应当从逻辑上被划分成多个部件，分别实现各种特定功能和子功能。
<img src="" alt="">500){this.resized=true;this.style.width=500;}&quot; resized=&quot;0&quot;&gt;3.设计最终应当给出具体的模块（例如子程序或过程），这些模块就具有独立的功能特性。
<img src="" alt="">500){this.resized=true;this.style.width=500;}&quot; resized=&quot;0&quot;&gt;4.应当应用在软件需求分析期间得到的信息，采取循环反复的方法来获得设计。 <strong>三． 总体设计</strong> 1．处理流程 <img src="" alt="">500){this.resized=true;this.style.width=500;}&quot; resized=&quot;0&quot;&gt;系统的总体处理数据流程如下图： <img src="" alt="">500){this.resized=true;this.style.width=500;}&quot; resized=&quot;0&quot;&gt; <strong>图八</strong><img src="" alt="">500){this.resized=true;this.style.width=500;}&quot; resized=&quot;0&quot;&gt;<strong>总体处理流程图</strong>   2．总体结构和模块外部设计 <img src="" alt="">500){this.resized=true;this.style.width=500;}&quot; resized=&quot;0&quot;&gt;模块是软件结构的基础，软件结构的好坏完全由模块的属性体现出来，把软件模块化的目的是为了降低软件复杂性，使软件设计，测试，调试，维护等工作变得简易，但随着模块数目的增加，通过接口连接这些模块的工作量也随之增加。从这些特性可得出如图九的一条总的成本（或工作量）曲线，在考虑模块化时，应尽量使模块数接近于图中的M，它使得研制成本最小，而且应尽量避免不足的模块化或超量。 <img src="" alt="">500){this.resized=true;this.style.width=500;}&quot; resized=&quot;0&quot;&gt; <strong>图九</strong><img src="" alt="">500){this.resized=true;this.style.width=500;}&quot; resized=&quot;0&quot;&gt;<strong>模块化与总体成本</strong> 3．功能分配 <img src="" alt="">500){this.resized=true;this.style.width=500;}&quot; resized=&quot;0&quot;&gt;从程序的结构中可以看出，学生的信息输入输出功能是由学生管理系统进行的。课程的信息输入输出是由课程管理系统进行的，而班级的信息流动则是班级管理系统进行的。 <strong>四． 接口设计</strong> <img src="" alt="">500){this.resized=true;this.style.width=500;}&quot; resized=&quot;0&quot;&gt;由于系统的各种内外部接口是通过借助数据库开发软件来实现的，是完全在数据库内部操作的，故在此略过此内容。 1． 外部接口（略） 2． 内部接口（略） <strong>五． 数据结构设计</strong> 1． 逻辑结构设计 <strong>student_Info 学生基本信息表</strong> <strong>列名</strong> <strong>数据类型</strong> <strong>可否为空</strong> <strong>说明</strong> student_ID INT(4) NOT NULL 学生学号（主键） student_Name CHAR(10) NULL 学生姓名 student_Gender CHAR(2) NULL 学生性别 born_Date DATETIME(8) NULL 出生日期 class_No INT(4) NULL 班号 tele_Number CHAR(10) NULL 联系电话 ru_Date DATETIME(8) NULL 入校时间 address VARCHAR(50) NULL 家庭住址 comment VARCHAR(200) NULL 注释   <strong>class_Info 班级信息表格</strong> <strong>列名</strong> <strong>数据类型</strong> <strong>可否为空</strong> <strong>说明</strong> class_No INT(4) NOT NULL 班号(主键) grade CHAR(10) NULL 年级 Director CHAR(10) NULL 班主任 Classroom_No CHAR(10) NULL 教室   <strong>course_Info 课程基本信息表</strong> <strong>列名</strong> <strong>数据类型</strong> <strong>可否为空</strong> <strong>说明</strong> course_No INT(4) NOT NULL 课程编号(主键) course_Name CHAR(10) NULL 课程名称 course_Type CHAR(10) NULL 课程类型 course_Des CHAR(50) NULL 课程描述   <strong>gradecourse_Info 年级课程设置表</strong> <strong>列名</strong> <strong>数据类型</strong> <strong>可否为空</strong> <strong>说明</strong> grade CHAR(10) NULL 年级 course_Name CHAR(10) NULL 课程名称   <strong>result_Info 学生成绩信息表</strong> <strong>列名</strong> <strong>数据类型</strong> <strong>可否为空</strong> <strong>说明</strong> exam_No CHAR(10) NOT NULL 考试编号 student_ID INT(4) NOT NULL 学生学号 student_Name CHAR(10) NULL 学生姓名 class_No INT(4) NULL 学生班号 course_Name CHAR(10) NULL 课程名称 result FLOAT(8) NULL 分数   <strong>user_Info 系统用户表</strong> <strong>列名</strong> <strong>数据类型</strong> <strong>可否为空</strong> <strong>说明</strong> user_ID CHAR(10) NOT NULL 用户名称（主键） user_PWD CHAR(10) NULL 用户密码 user_DES CHAR(10) NULL 用户描述 <strong>图十</strong><img src="" alt="">500){this.resized=true;this.style.width=500;}&quot; resized=&quot;0&quot;&gt;<strong>数据库逻辑结构图表</strong> 2． 物理结构设计 <img src="" alt="">500){this.resized=true;this.style.width=500;}&quot; resized=&quot;0&quot;&gt;系统的物理结构具体由数据库来设计与生成，此处略。 3． 数据结构与程序的关系 <img src="" alt="">500){this.resized=true;this.style.width=500;}&quot; resized=&quot;0&quot;&gt;系统的数据结构由标准数据库语言SQL生成。
<img src="" alt="">500){this.resized=true;this.style.width=500;}&quot; resized=&quot;0&quot;&gt;具体的例如创建系统用户表格 user_Info的程序用SQL表示就是：
<img src="" alt="">500){this.resized=true;this.style.width=500;}&quot; resized=&quot;0&quot;&gt;<strong>CREATE TABLE[dbo].<a href="![](">user_Info</a>500){this.resized=true;this.style.width=500;}&quot; resized=&quot;0&quot;&gt;<img src="" alt="">500){this.resized=true;this.style.width=500;}&quot; resized=&quot;0&quot;&gt;[user_ID]<a href="10">char</a>COLLATE Chinese_PRC_CI_AS NOT NULL,
<img src="" alt="">500){this.resized=true;this.style.width=500;}&quot; resized=&quot;0&quot;&gt;<img src="" alt="">500){this.resized=true;this.style.width=500;}&quot; resized=&quot;0&quot;&gt;[user_PWD]<a href="10">char</a>COLLATE Chinese_PRC_CI_AS NULL,
<img src="" alt="">500){this.resized=true;this.style.width=500;}&quot; resized=&quot;0&quot;&gt;<img src="" alt="">500){this.resized=true;this.style.width=500;}&quot; resized=&quot;0&quot;&gt;[user_Des]<a href="10">char</a>COLLATE Chinese_PRC_CI_AS NULL
<img src="" alt="">500){this.resized=true;this.style.width=500;}&quot; resized=&quot;0&quot;&gt;) ON [PRIMARY]</strong> <strong>六． 运行设计</strong> 1． 运行模块的组合 <strong><img src="" alt="">500){this.resized=true;this.style.width=500;}&quot; resized=&quot;0&quot;&gt;</strong>具体软件的运行模块组合为程序多窗口的运行环境，各个模块在软件运行过程中能较好的交换信息，处理数据。 2． 运行控制 <strong><img src="" alt="">500){this.resized=true;this.style.width=500;}&quot; resized=&quot;0&quot;&gt;</strong>软件运行时有较友好的界面，基本能够实现用户的数据处理要求。 3． 运行时间 <strong><img src="" alt="">500){this.resized=true;this.style.width=500;}&quot; resized=&quot;0&quot;&gt;</strong>系统的运行时间基本可以达到用户所提出的要求。 <strong>七． 出错处理设计</strong> 1． 出错输出信息 <strong><img src="" alt="">500){this.resized=true;this.style.width=500;}&quot; resized=&quot;0&quot;&gt;</strong>在用户使用错误的数据或访问没有权限的数据后，系统给出提示：“对不起，你非法使用数据，没有权限！”而且用户的密码管理可以允许用户修改自己的密码，不允许用户的匿名登录。 2． 出错处理对策 <strong><img src="" alt="">500){this.resized=true;this.style.width=500;}&quot; resized=&quot;0&quot;&gt;</strong>由于数据在数据库中已经有备份，故在系统出错后可以依靠数据库的恢复功能，并且依靠日志文件使系统再启动，就算系统崩溃用户数据也不会丢失或遭到破坏。但有可能占用更多的数据存储空间，权衡措施由用户来决定。 <strong>八． 安全保密设计</strong> <strong><img src="" alt="">500){this.resized=true;this.style.width=500;}&quot; resized=&quot;0&quot;&gt;</strong>系统的系统用户管理保证了只有授权的用户才能进入系统进行数据操作，而且对一些重要数据，系统设置为只有更高权限的人员方可读取或是操作。系统安全保密性较高。 <strong>九． 维护设计</strong> <strong><img src="" alt="">500){this.resized=true;this.style.width=500;}&quot; resized=&quot;0&quot;&gt;</strong>由于系统较小没有外加维护模块，因为维护工作比较简单，仅靠数据库的一些基本维护</p>
<p>0</p>
<p>0
0</p>
<p>(请您对文章做出评价)
<a href="http://www.cnblogs.com/campo/archive/2007/07/26/832590.html" target="_blank">«</a>上一篇：<a href="http://www.cnblogs.com/campo/archive/2007/07/26/832590.html" title="发布于2007-07-26 17:53" target="_blank">windows文章串联</a>
<a href="http://www.cnblogs.com/campo/archive/2007/08/24/867928.html" target="_blank">»</a>下一篇：<a href="http://www.cnblogs.com/campo/archive/2007/08/24/867928.html" title="发布于2007-08-24 10:36" target="_blank">概要设计模板</a></p>
<p>posted @ 2007-08-24 10:33 <a href="http://www.cnblogs.com/campo/" target="_blank">campo</a> 阅读(6961) <a href="http://www.cnblogs.com/campo/archive/2007/08/24/867923.html#commentform" target="_blank">评论(3)</a>  <a href="http://www.cnblogs.com/campo/admin/EditPosts.aspx?postid=867923" target="_blank">编辑</a> <a href="http://www.cnblogs.com/campo/AddToFavorite.aspx?id=867923" target="_blank">收藏</a> <a href="http://www.cnblogs.com/campo/archive/2007/08/24/867923.html#" target="_blank">网摘</a>
<img src="" alt=""><a href=""></a></p>
<p>发表评论</p>
<p>1600226
  <a href="http://www.cnblogs.com/campo/archive/2007/08/24/867923.html#commentform" target="_blank">回复</a>  <a href="http://www.cnblogs.com/campo/archive/2007/08/24/867923.html#commentform" target="_blank">引用</a>  <a href=""></a>  <a href=""></a><a href="http://www.cnblogs.com/campo/archive/2007/08/24/867923.html#1013155" target="_blank">/#1楼</a><a href=""></a>2007-12-24 20:52 | <a href="http://www.cnitblog.com/r.aspx?url=http://dgdfg">fghfdsgh[未注册用户]</a></p>
<p>gsdfgdf
;asdlf
laji</p>
<p>  <a href="http://www.cnblogs.com/campo/archive/2007/08/24/867923.html#commentform" target="_blank">回复</a>  <a href="http://www.cnblogs.com/campo/archive/2007/08/24/867923.html#commentform" target="_blank">引用</a>  <a href=""></a>  <a href=""></a><a href="http://www.cnblogs.com/campo/archive/2007/08/24/867923.html#1600225" target="_blank">/#2楼</a><a href=""></a>2009-07-30 14:58 | <a href="">chris.wang[未注册用户]</a></p>
<p>十分感谢您发布的概要设计文档，对我的工作提供了很大的帮助。
祝您工作顺利！
  <a href="http://www.cnblogs.com/campo/archive/2007/08/24/867923.html#commentform" target="_blank">回复</a>  <a href="http://www.cnblogs.com/campo/archive/2007/08/24/867923.html#commentform" target="_blank">引用</a>  <a href=""></a>  <a href=""></a><a href="http://www.cnblogs.com/campo/archive/2007/08/24/867923.html#1600226" target="_blank">/#3楼</a><a href=""></a><a href=""></a>2009-07-30 14:58 | <a href="">chris.wang[未注册用户]</a></p>
<p>十分感谢您发布的概要设计文档，对我的工作提供了很大的帮助。
祝您工作顺利！
注册用户登录后才能发表评论，请 <a href="http://passport.cnblogs.com/login.aspx?ReturnUrl=http%3a%2f%2fwww.cnblogs.com%2fcampo%2farchive%2f2007%2f08%2f24%2f867923.html%3flogin%3d1%23commentform" target="_blank">登录</a> 或 <a href="http://passport.cnblogs.com/register.aspx?ReturnUrl=http%3a%2f%2fwww.cnblogs.com%2fcampo%2farchive%2f2007%2f08%2f24%2f867923.html%23Bottom2" target="_blank">注册</a> 。</p>
<p><a href="http://www.cnblogs.com/" target="_blank">博客园首页</a>  <a href="http://news.cnblogs.com/" target="_blank">IT新闻</a>  <a href="http://home.cnblogs.com/ing/" target="_blank">闪存</a>  <a href="http://kb.cnblogs.com/" target="_blank">知识库</a>  <a href="http://job.cnblogs.com/" target="_blank">招聘</a></p>
<p><a href="http://news.cnblogs.com/" target="_blank">IT新闻</a>:
· <a href="http://news.cnblogs.com/n/57476/" target="_blank">给Oracle支招：改善Java的15种方式</a>
· <a href="http://news.cnblogs.com/n/57475/" target="_blank">谷歌中国面临人才流失 猎头公司挖走多名员工</a>
· <a href="http://news.cnblogs.com/n/57474/" target="_blank">惠普正式开放新加坡云计算实验室</a>
· <a href="http://news.cnblogs.com/n/57473/" target="_blank">微软向美国联邦政府提供云计算服务</a>
· <a href="http://news.cnblogs.com/n/57472/" target="_blank">中国3G运营商 真正的大考才刚开始</a>
<a href="http://a4.yeshj.com/rd/34138/" target="_blank">每天10分钟，轻松学英语</a>
专题：<a href="http://kb.cnblogs.com/zt/iPad/" target="_blank">iPad</a>  <a href="http://kb.cnblogs.com/zt/jquery/" target="_blank">jQuery</a>  <a href="http://kb.cnblogs.com/zt/windows7/" target="_blank">Windows 7</a></p>
<p>网站导航：
<a href="http://www.cnblogs.com/" target="_blank">博客园首页</a>  <a href="http://news.cnblogs.com/" target="_blank">IT新闻</a>  <a href="http://home.cnblogs.com/" target="_blank">个人主页</a>  <a href="http://home.cnblogs.com/ing/" target="_blank">闪存</a>  <a href="http://job.cnblogs.com/" target="_blank">程序员招聘</a>  <a href="http://space.cnblogs.com/" target="_blank">社区</a>  <a href="http://space.cnblogs.com/q/" target="_blank">博问</a>  <a href="http://wz.cnblogs.com/" target="_blank">网摘</a>
<a href="http://www.china-pub.com/STATIC07/0912/zh_ndcx_091212.asp" target="_blank"><img src="" alt=""></a>
<a href="http://www.china-pub.com/itbook/" target="_blank">China-pub 计算机图书网上专卖店！6.5万品种2-8折！</a>
<a href="http://www.china-pub.com/static07/0901/zh_jueba_090121.asp" target="_blank">China-Pub 计算机绝版图书按需印刷服务</a></p>
<p><strong>在知识库中查看：</strong>
<a href="http://kb.cnblogs.com/a/867923/" target="_blank">概要设计文档模板</a></p>
<p>Copyright ©2010 campo</p>
<p><a href="http://home.cnblogs.com/campo/" target="_blank">我的主页</a>  <a href="http://home.cnblogs.com/campo/detail/" target="_blank">个人资料</a>
<a href="http://home.cnblogs.com/campo/ing/" target="_blank">我的闪存</a>  <a href="http://space.cnblogs.com/msg/send/campo" target="_blank">发短消息</a></p>
<p><a href="&quot;Go to the previous month&quot;">&lt;</a> 2007年8月 <a href="&quot;Go to the next month&quot;">&gt;</a> 日 一 二 三 四 五 六 29 30 31 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 <a href="http://www.cnblogs.com/campo/archive/2007/8/24.html" target="_blank">24</a> 25 26 27 28 29 <a href="http://www.cnblogs.com/campo/archive/2007/8/30.html" target="_blank">30</a> 31 1 2 3 4 5 6 7 8</p>
<h3 id="-">搜索</h3>
<h3 id="-">常用链接</h3>
<ul>
<li><a href="http://www.cnblogs.com/campo/MyPosts.html" target="_blank">我的随笔</a></li>
<li><a href="http://home.cnblogs.com/campo/" target="_blank">我的空间</a></li>
<li><a href="http://space.cnblogs.com/msg/recent" target="_blank">我的短信</a></li>
<li><a href="http://www.cnblogs.com/campo/MyComments.html" target="_blank">我的评论</a></li>
<li><a href="http://www.cnblogs.com/campo/archive/2007/08/24/867923.html#" target="_blank">更多链接</a></li>
<li><a href="http://www.cnblogs.com/campo/OtherPosts.html" title="我发表过评论的随笔" target="_blank">我的参与</a></li>
<li><a href="http://www.cnblogs.com/campo/MyNews.html" target="_blank">我的新闻</a></li>
<li><a href="http://www.cnblogs.com/campo/RecentComments.html" target="_blank">最新评论</a></li>
<li><p><a href="http://www.cnblogs.com/campo/tag/" target="_blank">我的标签</a></p>
<h3 id="-">我的标签</h3>
</li>
<li><p><a href="http://www.cnblogs.com/campo/tag/0x80040155++æ¥å£æ²¡ææ³¨å/" target="_blank">0x80040155 接口没有注册</a>(1)</p>
</li>
</ul>
<h1 id="-">随笔分类</h1>
<ul>
<li><a href="http://www.cnblogs.com/campo/category/133119.html" target="_blank">Asp.Net Ajax</a><a href="http://www.cnblogs.com/campo/archive/2007/08/24/867923.html###" title="Subscribe to Asp.Net Ajax" target="_blank"><img src="&quot;Subscribe to Asp.Net Ajax&quot;" alt=""></a></li>
<li><a href="http://www.cnblogs.com/campo/category/122183.html" target="_blank">CodeSmith</a><a href="http://www.cnblogs.com/campo/archive/2007/08/24/867923.html###" title="Subscribe to CodeSmith" target="_blank"><img src="&quot;Subscribe to CodeSmith&quot;" alt=""></a></li>
<li><a href="http://www.cnblogs.com/campo/category/78191.html" target="_blank">DotNet(9)</a><a href="http://www.cnblogs.com/campo/archive/2007/08/24/867923.html###" title="Subscribe to DotNet(9)" target="_blank"><img src="&quot;Subscribe to DotNet(9" alt="">&quot;)</a></li>
<li><a href="http://www.cnblogs.com/campo/category/122184.html" target="_blank">Enterprise Library</a><a href="http://www.cnblogs.com/campo/archive/2007/08/24/867923.html###" title="Subscribe to Enterprise Library" target="_blank"><img src="&quot;Subscribe to Enterprise Library&quot;" alt=""></a></li>
<li><a href="http://www.cnblogs.com/campo/category/78193.html" target="_blank">Java(1)</a><a href="http://www.cnblogs.com/campo/archive/2007/08/24/867923.html###" title="Subscribe to Java(1)" target="_blank"><img src="&quot;Subscribe to Java(1" alt="">&quot;)</a></li>
<li><a href="http://www.cnblogs.com/campo/category/125077.html" target="_blank">Javascript小技巧(1)</a><a href="http://www.cnblogs.com/campo/archive/2007/08/24/867923.html###" title="Subscribe to Javascript小技巧(1)" target="_blank"><img src="&quot;Subscribe to Javascript小技巧(1" alt="">&quot;)</a></li>
<li><a href="http://www.cnblogs.com/campo/category/95054.html" target="_blank">Linux(1)</a><a href="http://www.cnblogs.com/campo/archive/2007/08/24/867923.html###" title="Subscribe to Linux(1)" target="_blank"><img src="&quot;Subscribe to Linux(1" alt="">&quot;)</a></li>
<li><a href="http://www.cnblogs.com/campo/category/99054.html" target="_blank">OpenCms</a><a href="http://www.cnblogs.com/campo/archive/2007/08/24/867923.html###" title="Subscribe to OpenCms" target="_blank"><img src="&quot;Subscribe to OpenCms&quot;" alt=""></a></li>
<li><a href="http://www.cnblogs.com/campo/category/105128.html" target="_blank">PS(1)</a><a href="http://www.cnblogs.com/campo/archive/2007/08/24/867923.html###" title="Subscribe to PS(1)" target="_blank"><img src="&quot;Subscribe to PS(1" alt="">&quot;)</a></li>
<li><a href="http://www.cnblogs.com/campo/category/105561.html" target="_blank">程序员必经之路(2)</a><a href="http://www.cnblogs.com/campo/archive/2007/08/24/867923.html###" title="Subscribe to 程序员必经之路(2)" target="_blank"><img src="&quot;Subscribe to 程序员必经之路(2" alt="">&quot;)</a></li>
<li><a href="http://www.cnblogs.com/campo/category/133120.html" target="_blank">代码生产</a><a href="http://www.cnblogs.com/campo/archive/2007/08/24/867923.html###" title="Subscribe to 代码生产" target="_blank"><img src="&quot;Subscribe to 代码生产&quot;" alt=""></a></li>
<li><a href="http://www.cnblogs.com/campo/category/78195.html" target="_blank">软件工程</a><a href="http://www.cnblogs.com/campo/archive/2007/08/24/867923.html###" title="Subscribe to 软件工程" target="_blank"><img src="&quot;Subscribe to 软件工程&quot;" alt=""></a></li>
<li><a href="http://www.cnblogs.com/campo/category/78194.html" target="_blank">数据库(5)</a><a href="http://www.cnblogs.com/campo/archive/2007/08/24/867923.html###" title="Subscribe to 数据库(5)" target="_blank"><img src="&quot;Subscribe to 数据库(5" alt="">&quot;)</a></li>
</ul>
<h1 id="-">随笔档案</h1>
<ul>
<li><a href="http://www.cnblogs.com/campo/archive/2008/09.html" target="_blank">2008年9月 (1)</a></li>
<li><a href="http://www.cnblogs.com/campo/archive/2008/06.html" target="_blank">2008年6月 (1)</a></li>
<li><a href="http://www.cnblogs.com/campo/archive/2008/03.html" target="_blank">2008年3月 (2)</a></li>
<li><a href="http://www.cnblogs.com/campo/archive/2008/01.html" target="_blank">2008年1月 (1)</a></li>
<li><a href="http://www.cnblogs.com/campo/archive/2007/11.html" target="_blank">2007年11月 (3)</a></li>
<li><a href="http://www.cnblogs.com/campo/archive/2007/10.html" target="_blank">2007年10月 (4)</a></li>
<li><a href="http://www.cnblogs.com/campo/archive/2007/09.html" target="_blank">2007年9月 (9)</a></li>
<li><a href="http://www.cnblogs.com/campo/archive/2007/08.html" target="_blank">2007年8月 (3)</a></li>
<li><a href="http://www.cnblogs.com/campo/archive/2007/07.html" target="_blank">2007年7月 (7)</a></li>
<li><a href="http://www.cnblogs.com/campo/archive/2007/06.html" target="_blank">2007年6月 (2)</a></li>
<li><a href="http://www.cnblogs.com/campo/archive/2007/05.html" target="_blank">2007年5月 (1)</a></li>
<li><a href="http://www.cnblogs.com/campo/archive/2007/04.html" target="_blank">2007年4月 (2)</a></li>
<li><a href="http://www.cnblogs.com/campo/archive/2007/02.html" target="_blank">2007年2月 (2)</a></li>
<li><a href="http://www.cnblogs.com/campo/archive/2007/01.html" target="_blank">2007年1月 (2)</a></li>
</ul>
<h1 id="-">文章分类</h1>
<ul>
<li><a href="http://www.cnblogs.com/campo/category/80348.html" target="_blank">编程知识</a><a href="http://www.cnblogs.com/campo/archive/2007/08/24/867923.html###" title="Subscribe to 编程知识" target="_blank"><img src="&quot;Subscribe to 编程知识&quot;" alt=""></a></li>
</ul>
<h1 id="-">相册</h1>
<ul>
<li><a href="http://www.cnblogs.com/campo/gallery/105746.html" target="_blank">basketball</a></li>
</ul>
<h1 id="-">编程技术文章</h1>
<ul>
<li><a href="http://www.cnblogs.com/3echo/archive/2006/02/14/330579.html" target="_blank">C/#学习笔记之程序集</a></li>
<li><a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank">Jeffrey Zhao</a></li>
<li><a href="http://mail-ricklee.cnblogs.com/" target="_blank">NickLee</a></li>
<li><a href="http://blog.sina.com.cn/campoem" target="_blank">沉香</a></li>
<li><a href="http://www.cnblogs.com/ruxpinsp1/" target="_blank">大胡仔</a><h3 id="-rss-http-www-cnblogs-com-campo-commentsrss-aspx-rss-">最新评论<a href="http://www.cnblogs.com/campo/CommentsRSS.aspx" title="RSS订阅最最新评论" target="_blank"><img src="&quot;RSS订阅最最新评论&quot;" alt=""></a></h3>
</li>
</ul>
<p><a href="http://www.cnblogs.com/campo/archive/2007/08/24/867923.html#1600226" target="_blank">1. Re:概要设计文档模板</a></p>
<p>十分感谢您发布的概要设计文档，对我的工作提供了很大的帮助。祝您工作顺利！ (chris.wang)
<a href="http://www.cnblogs.com/campo/archive/2007/08/24/867923.html#1600225" target="_blank">2. Re:概要设计文档模板</a></p>
<p>十分感谢您发布的概要设计文档，对我的工作提供了很大的帮助。祝您工作顺利！ (chris.wang)
<a href="http://www.cnblogs.com/campo/archive/2007/10/05/914504.html#1429366" target="_blank">3. re: 2007IT业薪资调查，请注明城市</a></p>
<p>4000 应届 北京 (飞林沙)
<a href="http://www.cnblogs.com/campo/archive/2007/10/05/914504.html#1300074" target="_blank">4. re: 2007IT业薪资调查，请注明城市</a></p>
<p>1500 一年 青岛 唉 (随&amp;风)
<a href="http://www.cnblogs.com/campo/archive/2007/10/05/914504.html#1299291" target="_blank">5. re: 2007IT业薪资调查，请注明城市</a></p>
<p>6K-8K。 (养猪设备)</p>
<h3 id="-">阅读排行榜</h3>
<ul>
<li><a href="http://www.cnblogs.com/campo/archive/2007/08/24/867923.html" target="_blank">1. 概要设计文档模板(6961)</a></li>
<li><a href="http://www.cnblogs.com/campo/archive/2007/10/05/914504.html" target="_blank">2. 2007IT业薪资调查，请注明城市(6651)</a></li>
<li><a href="http://www.cnblogs.com/campo/archive/2007/09/07/885354.html" target="_blank">3. sqlserver2000下载地址(5108)</a></li>
<li><a href="http://www.cnblogs.com/campo/archive/2007/08/24/867928.html" target="_blank">4. 概要设计模板(4755)</a></li>
<li><p><a href="http://www.cnblogs.com/campo/archive/2007/09/07/885342.html" target="_blank">5. SQLServer2000安装图解(3051)</a></p>
<h3 id="-">评论排行榜</h3>
</li>
<li><p><a href="http://www.cnblogs.com/campo/archive/2007/10/05/914504.html" target="_blank">1. 2007IT业薪资调查，请注明城市(138)</a></p>
</li>
<li><a href="http://www.cnblogs.com/campo/archive/2007/08/24/867923.html" target="_blank">2. 概要设计文档模板(3)</a></li>
<li><a href="http://www.cnblogs.com/campo/archive/2007/06/28/798991.html" target="_blank">3. 工作流技术学习专题(3)</a></li>
<li><a href="http://www.cnblogs.com/campo/archive/2007/09/10/888924.html" target="_blank">4. 用例 UseCase(2)</a></li>
<li><a href="http://www.cnblogs.com/campo/archive/2008/01/07/1029353.html" target="_blank">5. 往消息队列传数据的存储过程(2)</a></li>
</ul>
<p>msn:campolake@hotmail.com</p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/Java_设计类/">Java_设计类</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/Java_设计类/" class="label label-success">Java_设计类</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:42"datetime="2014-03-07 09:54:42"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-Java_设计类--概要设计文档模板/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-Java_设计类--概要设计文档模板" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>





<ul id="pagination" class="pagination pagination-lg">
  <li><a class="extend prev" href="/page/43/">&laquo;</a></li><li><a class="page-number" href="/">1</a></li><li><a class="page-number" href="/page/2/">2</a></li><li><span class="space">&hellip;</span></li><li><a class="page-number" href="/page/41/">41</a></li><li><a class="page-number" href="/page/42/">42</a></li><li><a class="page-number" href="/page/43/">43</a></li><li class="active"><li><span class="page-number current">44</span></li><li><a class="page-number" href="/page/45/">45</a></li><li><a class="page-number" href="/page/46/">46</a></li><li><a class="page-number" href="/page/47/">47</a></li><li><span class="space">&hellip;</span></li></li><li><a class="page-number" href="/page/163/">163</a></li><li><a class="page-number" href="/page/164/">164</a></li><li><a class="extend next" href="/page/45/">&raquo;</a></li>
  <div class="clearfix"></div>
</ul></div><!--wapper-->
       </div><!-- ID main-col END -->
       <aside id="sidebar" class="alignright col-sx-6 col-sm-4 col-md-3 col-lg-3">
<div id="widget_search" class="widget panel panel-primary">
    <form action="//google.com/search" method="get" accept-charset="utf-8">
  <div class="input-group">
    <input class="form-control" id="searchbox" type="search" name="q" results="0" placeholder="search">
    <span class="input-group-btn">
      <button class="btn btn-default" type="submit">Go!</button>
    </span>
    <input type="hidden" name="q" value="site:itsolife.com">
  </div>
</form>
</div>

<div id="widget_category" class="widget panel panel-primary">
  <div class="panel-heading">category</div>  <div data-src='category' class='ajax_widgets'>正在加载...</div>
</div>

<div id="widget_recent_posts" class="widget panel panel-primary">
  <div class="panel-heading">recent posts</div>  <div data-src='recent_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_tagcloud" class="widget panel panel-primary">
  <div class="panel-heading">tagcloud</div>  <div data-src='tagcloud' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_latest_update_posts" class="widget panel panel-primary">
  <div class="panel-heading">最近更新</div>  <div data-src='latest_update_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_recent_comments" class="widget panel panel-primary">
  <div class="panel-heading">recent comments</div>  

<div class="list-group-item ds-recent-comments" data-num-items="6" data-show-avatars="1" data-show-time="1" data-show-title="1" data-show-admin="1" data-excerpt-length="50"></div>



</div>

</aside>
       <div class="clearfix"></div>
     </div><!-- row END -->
  </div>
  <footer id="footer" class="container">
  <div class="panel panel-info">
  <section id='footer_widget'></section>  <div class="panel-footer">
  <div id="site-info">
    <span class='author'>
  
  &copy; 2014 RobinChia
  
    &nbsp;&nbsp;</span>
  
  <span id='analytics-51la'></span><span id='analytics-google'>
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-48559895-1']);
  _gaq.push(['_trackPageview']);
  _js2load.push({src:('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'});
</script></span><span id='analytics-cnzz'>
<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_5774006'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s17.cnzz.com/stat.php%3Fid%3D5774006%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>
</span><span id='analytics-baidu'>
<script>
var _hmt = _hmt || [];
_js2load.push({src:"//hm.baidu.com/hm.js?1442f50724afc42380b51f097c43082c"});
</script>
</span>  </div>
  <div id="copyright">Site powered by <a href='http://zespia.tw/hexo/'><strong>hexo</strong></a>  update time: <em>2014-03-29 22:06:56</em></span></div>
</div>
<div class="clearfix"></div>


  </div>
  </footer>
  
        <script src="http://cdn.bootcss.com/jquery/1.10.2/jquery.min.js"></script>        
        <script src="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/js/bootstrap.min.js"></script>        
                
        <script src="http://cdn.bootcss.com/prettify/r298/prettify.min.js"></script>    <script type="text/javascript">
   var lang=["bsh", "c", "cc", "cpp", "cs", "csh", "cyc", "cv", "htm", "html",
    "java", "js", "m", "mxml", "perl", "pl", "pm", "py", "rb", "sh",
    "xhtml", "xml", "xsl"];
   var pretty_base='';
   $('script').each(function(){
	var c = $(this).attr('src');
	if (!c)
	    return;
	if (c.match(/(\/)?prettify(\.min)?\.js/i))
	{
	    var index = c.lastIndexOf('/');
	    if (index != -1)
		pretty_base = c.substr(0,index + 1);
	    return false;
	}
   })
   $('pre code').each(function(){
	var c = $(this).attr('class')
	if (!c)
	    return;
	c = c.match(/\s?(lang\-\w+)/i);
	if (c && lang.indexOf(c[1]) == -1)
	{
	    lang.push(c[1]);
	    $.getScript(pretty_base + c[1] + '.min.js');
	}
   })

    $(window).load(function(){
       $("pre").addClass("prettyprint");
       prettyPrint();
    })
</script>    
            <script type="text/javascript">
var duoshuoQuery = {short_name:"robinchia"};
_js2load.push({src:'http://static.duoshuo.com/embed.js',charset:'UTF-8'});
</script>
    
            <!--wumii_relatedItems-->
    
        <script src="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js"></script>    <script type="text/javascript">
(function($){
  $('.entry').each(function(i){
    $(this).find('img').each(function(){
      var alt = this.alt;

      if (alt){
        $(this).before('<span class="caption">' + alt + '</span>');
      }

      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox" rel="fancybox' + i + '" />');
    });
  });

  $('.fancybox').fancybox();
})(jQuery);
</script>    
        <script src="http://cdn.bootcss.com/mathjax/2.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>    <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>
    
<script type="text/javascript">
$('.ajax_widgets').each(function(){var src=$(this).attr('data-src');if(src)$(this).load('/widgets/'+src+'.html');});
$.each(_js2load,function(index,obj){loadjs(obj.src,obj.charset)});
</script>

<div id="scroll2top">
<img src="/scroll2top/arrow.png"/>
</div>
<script src="/scroll2top/scroll2top.min.js"></script>
<div id="winterland">
  <canvas></canvas>
</div>
<script src="/js/winterland.min.js"></script>

  </body>
</html>
