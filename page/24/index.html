
<!DOCTYPE HTML>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>The 24 Page | It so life</title>
<meta name="author" content="RobinChia">

<meta name="description" content="It so life">


<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<meta property="og:site_name" content="It so life"/>

<!--[if IE]><style>.testIE.IE{display:inline;}</style><![endif]-->
<!--[if lte IE 7]><link rel="stylesheet" href="/css/ie7.css" type="text/css"><![endif]-->
<!--[if (lt IE 9)&(gt IE 7)]><style>.testIE.IE8{display:inline;}</style><![endif]-->
<!--[if gt IE 8]><style>.testIE.IE9{display:inline;}</style><![endif]-->

<link href="/favicon.png" rel="icon">
<link rel="alternate" href="/atom.xml" title="It so life Feed" type="application/atom+xml">

<link rel="stylesheet" href="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/css/bootstrap.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/font-awesome/4.0.3/css/font-awesome.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/prettify/r298/prettify.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" type="text/css">
<link rel="stylesheet" href="/css/style.css" type="text/css">
<!--[if lt IE 9]>
   <style>article,aside,dialog,footer,header,section,footer,nav,figure,menu{display:block}</style>
   <script src="http://cdn.staticfile.org/html5shiv/r29/html5.min.js"></script>
   <script src="http://cdn.staticfile.org/respond.js/1.4.2/respond.min.js"></script>
<link href="http://cdn.staticfile.org/respond.js/1.4.2/respond-proxy.html" id="respond-proxy" rel="respond-proxy" />
<link href="/js/respond.proxy.gif" id="respond-redirect" rel="respond-redirect" />
<script src="/js/respond.proxy.js"></script>
   <script src="http://cdn.bootcss.com/selectivizr/1.0.2/selectivizr-min.js"></script>
<![endif]-->
<script type="text/javascript">
function loadjs(c,d){var a=document.createElement("script");a.async=!0;a.type="text/javascript";a.src=c;a.charset=d||"gbk";(document.getElementsByTagName("HEAD")[0]||document.getElementsByTagName("BODY")[0]).appendChild(a)};
var _protocol = (("https:" == document.location.protocol) ? " https://" : " http://");
var _js2load = [];
</script>

</head>
<body>
      <header id="header" class="container"><nav id="main-nav" class="navbar navbar-default navbar-fixed-top " role="navigation">
  <div class="container">
    <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
      <span class="sr-only">Toggle navigation</span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="/">It so life</a>
    </div>
    <div  class="collapse navbar-collapse">
      <ul  class="nav navbar-nav">
  
        <li><a href="/" title="Home">Home</a></li>      
        <li><a href="/about/" title="About">About</a></li>      
        <li><a href="/archives/" title="Archives">Archives</a></li>      
      <li class='dropdown'>
        <a class='dropdown-toggle' data-toggle='dropdown' href='#'>website<b class='caret'></b></a>
        <ul class='dropdown-menu pure-menu-selected'>
    
          <li><a href="//groups.google.com/forum/#!forum/pongba" title="TopLanguage">TopLanguage</a></li>    
          <li><a href="//itpub.net/" title="ITPub">ITPub</a></li>    
          <li><a href="//blog.jobbole.com/" title="Bole">Bole</a></li>    
          <li><a href="//nosql-database.org/" title="nosql">nosql</a></li>    
          <li><a href="//gitimmersion.googol.im/" title="Git">Git</a></li>    
        </ul>
      </li>
    
      </ul>
      <ul class="nav navbar-nav navbar-right">
      
        <li><a href="/atom.xml">RSS</a></li>
      
      
        <li><a href="https://twitter.com/robinchia">twitter</a></li>
      
      
      
      
        <li><a href="https://github.com/robinchia">github</a></li>
      
      </ul>
    </div>
  </div>
</nav>
<div class="clearfix"></div>
</header>
  <div id='content' class="container">
     <div class="page-header-wrapper">
      <!--[if lt IE 9]><div class="alert alert-warning alert-dismissable"><button type="button" class="close" data-dismiss="alert" aria-hidden="true">&times;</button><strong>提示:</strong>您的浏览器版本太低了,建议升级到 <strong><a href="http://windows.microsoft.com/zh-cn/internet-explorer/download-ie" title="IE9">IE9</a></strong> 以上,本站使用<a href="https://www.google.com/intl/zh-CN/chrome/">Chrome浏览器</a>可以获得最好的显示效果.</div><![endif]-->
      <div class="page-header"><h1 align="center"><big>It so life</big> </h1>
        <h5 align="center"><big>love as life</big></h5>
      </div>
     </div>
     <div class="row">
       <div id="main-col" class="alignleft col-sx-12 col-sm-8 col-md-9 col-lg-9">
      <section id='header_widget'></section>
          <div id="wrapper"><article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-xml-xstream--XStream使用方法总结附实例代码/">XStream使用方法总结附实例代码</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:44.000Z"> <a href="/2014/02/02/2014-02-02-xml-xstream--XStream使用方法总结附实例代码/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="xstream-">XStream使用方法总结附实例代码</h1>
<p>发布：dxy </p>
<p>XStream是一个Java对象和XML相互转换的工具，很好很强大。提供了所有的基础类型、数组、集合等类型直接转换的支持。因此XML常用于数据交换、对象序列化（这种序列化和Java对象的序列化技术有着本质的区别）。
XStream中的核心类就是XStream类，一般来说，熟悉这个类基本就够用了，如果你用的更多，估计是你设计有问题，否则不需要。 
XStream对象相当Java对象和XML之间的转换器，转换过程是双向的。创建XSteam对象的方式很简单，只需要new XStream()即可。 
Java到xml，用toXML()方法。 
Xml到Java，用fromXML()方法。 
在没有任何设置默认情况下，java到xml的映射，是java成员名对应xml的元素名，java类的全名对应xml根元素的名字。而实际中，往往是xml和java类都有了，要完成相互转换，必须进行别名映射。 
别名配置包含三种情况： 
1、类别名，用alias(String name, Class type)。 
2、类成员别名，用aliasField(String alias, Class definedIn, String fieldName) 
3、类成员作为属性别名，用 aliasAttribute(Class definedIn, String attributeName, String alias)，单独命名没有意义，还要通过useAttributeFor(Class definedIn, String fieldName) 应用到某个类上。 
别名的配置是非常重要的，但是其中有些细节问题很重要，在例子中会专门做详细说明。 
另外还有不太常用的方法： 
addImplicitCollection(Class ownerType, String fieldName)，去掉集合类型生成xml的父节点。 
registerConverter(Converter converter) ，注册一个转换器。 
如果你的xml很大，或者为了安全性，以流的方式传输，那么XStream也提供丰富的API， 
使用起来也非常简便。目前还用不到，暂不考虑。 
如果这些基本的操作还不能满足你应用的需求，XStream提供丰富的扩展点。你可以实现自己的转换器。还可以利用XStream完成更负责的功能，比如输出其他非xml格式的数据，还可以输出html，还支持XML Dom类型数据，这些应用起来稍微复杂些。当然这些不是XStream应用的重点，也不用理会，真正需要的时候再查看API和源码研究研究。 
XStream的优点很多，但是也有一些小bug，比如在定义别名中的下划线“<em>”转换为xml后会变成“_</em>”这个符号，很变态。因此，尽量避免在别名中实用任何符号，却是需要下划线的时候，可以考虑实用连接符“-”，这个没有问题。 
另外，我们的Java Bean中，常常有一些常量，在转换过程，XStream也会将这些常量转换过去，形成常量的xml节点，这显然不是想要的结果，对于常量字段，就不做转换了。 
下面给出一个非常典型的而且实用的例子，作为对总结的补充： 
package test; 
import java.util.List; 
//<em>/</em> 
/<em> Created by IntelliJ IDEA.<br> 
/</em> <b>User</b>: leizhimin<br> 
/<em> <b>Date</b>: 2008-5-22 21:10:13<br> 
/</em> <b>Note</b>: Please add comment here! 
/<em>/ 
public class Person { 
private String name; 
private String age; 
private Profile profile; 
private List<Address> addlist; 
public Person(String name, String age, Profile profile, List<Address> addlist) { 
this.name = name; 
this.age = age; 
this.profile = profile; 
this.addlist = addlist; 
} 
public String toString() { 
return &quot;Person{&quot; + 
&quot;name=&#39;&quot; + name + &#39;\&#39;&#39; + 
&quot;, age=&#39;&quot; + age + &#39;\&#39;&#39; + 
&quot;, profile=&quot; + profile + 
&quot;, addlist=&quot; + addlist + 
&#39;}&#39;; 
} 
} 
package test; 
import java.sql.Date; 
//</em>/<em> 
/</em> Created by IntelliJ IDEA.<br> 
/<em> <b>User</b>: leizhimin<br> 
/</em> <b>Date</b>: 2008-5-22 21:10:32<br> 
/<em> <b>Note</b>: Please add comment here! 
/</em>/ 
public class Profile { 
private String job; 
private String tel; 
private String remark; 
public Profile(String job, String tel, String remark) { 
this.job = job; 
this.tel = tel; 
this.remark = remark; 
} 
public String toString() { 
return &quot;Profile{&quot; + 
&quot;job=&#39;&quot; + job + &#39;\&#39;&#39; + 
&quot;, tel=&#39;&quot; + tel + &#39;\&#39;&#39; + 
&quot;, remark=&#39;&quot; + remark + &#39;\&#39;&#39; + 
&#39;}&#39;; 
} 
} 
package test; 
//<em>/</em> 
/<em> Created by IntelliJ IDEA.<br> 
/</em> <b>User</b>: leizhimin<br> 
/<em> <b>Date</b>: 2008-5-22 21:10:22<br> 
/</em> <b>Note</b>: Please add comment here! 
/<em>/ 
public class Address { 
private String add; 
private String zipcode; 
public Address(String add, String zipcode) { 
this.add = add; 
this.zipcode = zipcode; 
} 
public String toString() { 
return &quot;Address{&quot; + 
&quot;add=&#39;&quot; + add + &#39;\&#39;&#39; + 
&quot;, zipcode=&#39;&quot; + zipcode + &#39;\&#39;&#39; + 
&#39;}&#39;; 
} 
} 
package test; 
import com.thoughtworks.xstream.XStream; 
import java.util.List; 
import java.util.ArrayList; 
//</em>/<em> 
/</em> Created by IntelliJ IDEA.<br> 
/<em> <b>User</b>: leizhimin<br> 
/</em> <b>Date</b>: 2008-5-22 21:10:47<br> 
/<em> <b>Note</b>: XStream学习[<a href="http://lavasoft.blog.51cto.com" target="_blank">http://lavasoft.blog.51cto.com</a>] 
/</em>/ 
public class TestXStream { 
public static void main(String args[]) { 
test(); 
} 
public static void test() { 
System.out.println(&quot;----------XStream学习:<a href="http://lavasoft.blog.51cto.com----------" target="_blank">http://lavasoft.blog.51cto.com----------</a>&quot;); 
//目标对象 
Address address1 = new Address(&quot;郑州市经三路&quot;, &quot;450001&quot;); 
Address address2 = new Address(&quot;西安市雁塔路&quot;, &quot;710002&quot;); 
List<Address> addList = new ArrayList<Address>(); 
addList.add(address1); 
addList.add(address2); 
Profile profile = new Profile(&quot;软件工程师&quot;, &quot;13512129933&quot;, &quot;备注说明&quot;); 
Person person = new Person(&quot;熔岩&quot;, &quot;27&quot;, profile, addList); 
//转换装配 
XStream xStream = new XStream(); 
//<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em> 设置类别名 /<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/ 
xStream.alias(&quot;PERSON&quot;, test.Person.class); 
xStream.alias(&quot;PROFILE&quot;, test.Profile.class); 
xStream.alias(&quot;ADDRESS&quot;, test.Address.class); 
output(1, xStream, person); 
//<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em> 设置类成员的别名 /</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/ 
//设置Person类的name成员别名Name 
xStream.aliasField(&quot;Name&quot;, Person.class, &quot;name&quot;); 
//<em>[注意] 设置Person类的profile成员别名PROFILE,这个别名和Profile类的别名一致, 
/</em> 这样可以保持XStream对象可以从profile成员生成的xml片段直接转换为Profile成员, 
/<em> 如果成员profile的别名和Profile的别名不一致,则profile成员生成的xml片段不可 
/</em> 直接转换为Profile对象,需要重新创建XStream对象,这岂不给自己找麻烦? /<em>/ 
xStream.aliasField(&quot;PROFILE&quot;, test.Person.class, &quot;profile&quot;); 
xStream.aliasField(&quot;ADDLIST&quot;, test.Person.class, &quot;addlist&quot;); 
xStream.aliasField(&quot;Add&quot;, test.Address.class, &quot;add&quot;); 
xStream.aliasField(&quot;Job&quot;, test.Profile.class, &quot;job&quot;); 
output(2, xStream, person); 
//</em>/<em>/</em>/<em>/</em>/<em>/</em> 设置类成员为xml一个元素上的属性 /<em>/</em>/<em>/</em>/<em>/</em>/<em>/ 
xStream.useAttributeFor(Address.class, &quot;zipcode&quot;); 
//</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em> 设置属性的别名 /<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/ 
xStream.aliasAttribute(test.Address.class, &quot;zipcode&quot;, &quot;Zipcode&quot;); 
output(3, xStream, person); 
//</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em> 将xml转为java对象 /<em>/</em>/<em>/</em>/<em>/</em>×/<em>/</em>/<em>/</em>/ 
String person_xml = &quot;<PERSON>\n&quot; + 
&quot; <Name>熔岩</Name>\n&quot; + 
&quot; <age>27</age>\n&quot; + 
&quot; <PROFILE>\n&quot; + 
&quot; <Job>软件工程师</Job>\n&quot; + 
&quot; <tel>13512129933</tel>\n&quot; + 
&quot; <remark>备注说明</remark>\n&quot; + 
&quot; </PROFILE>\n&quot; + 
&quot; <ADDLIST>\n&quot; + 
&quot; <ADDRESS Zipcode=\"450001\">\n&quot; + 
&quot; <Add>郑州市经三路</Add>\n&quot; + 
&quot; </ADDRESS>\n&quot; + 
&quot; <ADDRESS Zipcode=\"710002\">\n&quot; + 
&quot; <Add>西安市雁塔路</Add>\n&quot; + 
&quot; </ADDRESS>\n&quot; + 
&quot; </ADDLIST>\n&quot; + 
&quot;</PERSON>&quot;; 
String profile_xml = &quot; <PROFILE>\n&quot; + 
&quot; <Job>软件工程师</Job>\n&quot; + 
&quot; <tel>13512129933</tel>\n&quot; + 
&quot; <remark>备注说明</remark>\n&quot; + 
&quot; </PROFILE>&quot;; 
String address_xml = &quot; <ADDRESS Zipcode=\"710002\">\n&quot; + 
&quot; <Add>西安市雁塔路</Add>\n&quot; + 
&quot; </ADDRESS>&quot;; 
//同样实用上面的XStream对象xStream 
System.out.println(xStream.fromXML(person_xml).toString()); 
System.out.println(xStream.fromXML(profile_xml).toString()); 
System.out.println(xStream.fromXML(address_xml).toString()); 
} 
public static void output(int i, XStream xStream, Object obj) { 
String xml = xStream.toXML(obj); 
System.out.println(&quot;&gt;&gt;&gt;第[ &quot; + i + &quot;]次输出\n&quot;); 
System.out.println(xml + &quot;\n&quot;); 
} 
} 
----------XStream学习:<a href="http://lavasoft.blog.51cto.com----------" target="_blank">http://lavasoft.blog.51cto.com----------</a> </p>
<blockquote>
<blockquote>
<blockquote>
<p>第[ 1]次输出 </p>
<p><PERSON> </p>
<p><name>熔岩</name> </p>
<p><age>27</age> </p>
<p><profile> </p>
<p><job>软件工程师</job> </p>
<p><tel>13512129933</tel> </p>
<p><remark>备注说明</remark> 
</profile> </p>
<p><addlist> </p>
<p><ADDRESS> </p>
<p><add>郑州市经三路</add> </p>
<p><zipcode>450001</zipcode> 
</ADDRESS> </p>
<p><ADDRESS> </p>
<p><add>西安市雁塔路</add> </p>
<p><zipcode>710002</zipcode> 
</ADDRESS> 
</addlist> 
</PERSON> 
第[ 2]次输出 </p>
<p><PERSON> </p>
<p><Name>熔岩</Name> </p>
<p><age>27</age> </p>
<p><PROFILE> </p>
<p><Job>软件工程师</Job> </p>
<p><tel>13512129933</tel> </p>
<p><remark>备注说明</remark> 
</PROFILE> </p>
<p><ADDLIST> </p>
<p><ADDRESS> </p>
<p><Add>郑州市经三路</Add> </p>
<p><zipcode>450001</zipcode> 
</ADDRESS> </p>
<p><ADDRESS> </p>
<p><Add>西安市雁塔路</Add> </p>
<p><zipcode>710002</zipcode> 
</ADDRESS> 
</ADDLIST> 
</PERSON> 
第[ 3]次输出 </p>
<p><PERSON> </p>
<p><Name>熔岩</Name> </p>
<p><age>27</age> </p>
<p><PROFILE> </p>
<p><Job>软件工程师</Job> </p>
<p><tel>13512129933</tel> </p>
<p><remark>备注说明</remark> 
</PROFILE> </p>
<p><ADDLIST> </p>
<p><ADDRESS Zipcode="450001"> </p>
<p><Add>郑州市经三路</Add> 
</ADDRESS> </p>
<p><ADDRESS Zipcode="710002"> </p>
<p><Add>西安市雁塔路</Add> 
</ADDRESS> 
</ADDLIST> 
</PERSON> 
Person{name=&#39;熔岩&#39;, age=&#39;27&#39;, profile=Profile{job=&#39;软件工程师&#39;, tel=&#39;13512129933&#39;, remark=&#39;备注说明&#39;}, addlist=[Address{add=&#39;郑州市经三路&#39;, zipcode=&#39;450001&#39;}, Address{add=&#39;西安市雁塔路&#39;, zipcode=&#39;710002&#39;}]} 
Profile{job=&#39;软件工程师&#39;, tel=&#39;13512129933&#39;, remark=&#39;备注说明&#39;} 
Address{add=&#39;西安市雁塔路&#39;, zipcode=&#39;710002&#39;} 
Process finished with exit code 0 
在实际中，类的属性很多，嵌套层次也很复杂，如果仅仅使用XStream原生API来硬编码设置别名等属性，显得太生硬也难以维护。完全可以考虑通过一个xml配置文件来定义所有用到的类的别名定义（包括其成员），然后，通过读取配置构建一个XStream的工厂，在用到时候直接去取，而不是让实用者组装。我目前的一个项目中，就是这么实现的，效果非常的好。 
下面我给出针对上面提出的问题一个解决方案： 
思想：考虑做一个过滤器，在xml转java之前，在Java转xml之后，应用这个过滤器。这个过滤器提供将xml中的“<strong>”替换为“-”，并且将xml中的不需要的节点剔除。 
在过滤之前，我实现了个转换器装配，这一步通过xml来配置，并在java中获取。 
代码就省略了，这一步很灵活，关键看你的应用了。 
为了能过滤xml，我们需要用Dom4j递归遍历xml文档。下面一些算法代码： 
//递归算法：遍历配置文件，找出所有有效的xpath 
private static void recursiveElement(Element element) { 
List<Element> elements = element.elements(); 
validXPathList.add(element.getPath()); 
if (elements.size() == 0) { 
//没有子元素 
} else { 
//有子元素 
for (Iterator<Element> it = elements.iterator(); it.hasNext();) { 
//递归遍历 
recursiveElement(it.next()); 
} 
} 
} 
//递归算法：遍历xml，标识无效的元素节点 
private static void recursiveFixElement(Element element) { 
List<Element> elements = element.elements(); 
if (!validXPathList.contains(element.getPath())) { 
element.addAttribute(&quot;delete&quot;, &quot;true&quot;); 
} 
if (elements.size() == 0) { 
//没有子元素 
} else { 
//有子元素 
for (Iterator<Element> it = elements.iterator(); it.hasNext();) { 
Element e = it.next(); 
if (!validXPathList.contains(e.getPath())) { 
e.addAttribute(&quot;delete&quot;, &quot;true&quot;); 
} 
//递归遍历 
recursiveFixElement(e); 
} 
} 
} 
//<em>/</em> 
/<em> 过滤器接口方法，转换不规范字符，剔除无效节点 
/</em> 
/<em> @param xmlStr 要过滤的xml 
/</em> @return 符合转换器要求的xml 
/*/ 
public static String filter(String xmlStr) { 
Document document = null; 
try { 
document = DocumentHelper.parseText(xmlStr.replaceAll(&quot;</strong>&quot;, &quot;_&quot;)); 
//递归的调用：标记要剔除的xml元素 
recursiveFixElement(document.getRootElement()); 
List<Node> nodeList = document.selectNodes(&quot;//@delete&quot;); 
for (Node node : nodeList) { 
node.getParent().detach(); //剔除xml元素 
} 
} catch (DocumentException e) { 
System.out.println(e.getMessage()); 
e.printStackTrace(); 
} 
return document.asXML(); 
} </p>
</blockquote>
</blockquote>
</blockquote>
<p>-</p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/xml/">xml</a></li></span><span class="breadcrumb"><li><a href="/categories/xml/">xml</a></li><li><a href="/categories/xml/xstream/">xstream</a></li></span></span> | <span class="tags">Tagged <a href="/tags/xml/" class="label label-primary">xml</a><a href="/tags/xstream/" class="label label-success">xstream</a></span> | <span class="time">recent updated:<time title="2014-04-07 16:44:38"datetime="2014-04-07 16:44:38"> abr. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-xml-xstream--XStream使用方法总结附实例代码/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-xml-xstream--XStream使用方法总结附实例代码" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-xml-xstream--XStream学习笔记-枫情的Blog-BlogJava/">XStream 学习笔记</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:44.000Z"> <a href="/2014/02/02/2014-02-02-xml-xstream--XStream学习笔记-枫情的Blog-BlogJava/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="xstream-">XStream 学习笔记</h1>
<p>  <a href="http://www.blogjava.net/zlkn2005/" target="_blank">枫情的Blog</a></p>
<p><strong>XStream</strong></p>
<p><strong>使用XStream**</strong>的初衷**</p>
<p>研究和使用XStream的原因是我在项目中的一个预研。在项目中需要应用到对XML文件的管理和配置，因此需要一个能够将对象保存为XML的工具库，在这里有多种方法实现，我也研究并进行了比对，比如与Zeus工具的比对，与Java自身的XML工具库的比对等。在这里，我就描述下我的XStream学习过程和研究结果。</p>
<p><strong>XStream**</strong>简单介绍**</p>
<p>XStream是一个开源项目，一套简单实用的类库，用于序列化对象与XML对象之间的相互转换。将XML文件内容解析为一个对象或将一个对象序列化为XML文件。</p>
<p>XStream可以用于JDK1.3以上的版本使用，我是在JDK1.5下使用它的。</p>
<p>XStream的相关信息可以到<a href="http://xstream.codehaus.org/下查看，它有专门的JavaDoc，可以方便的阅读Xstream的函数及方法。" target="_blank">http://xstream.codehaus.org/下查看，它有专门的JavaDoc，可以方便的阅读Xstream的函数及方法。</a></p>
<p>XStream中主要的类为XStream，它用于序列化对象与XML 对象之间的相互转换。简单的使用它就可以解决很多问题。</p>
<p>XStream中主要的方法也是我用的比较多的是fromXML()和toXML()。</p>
<p>fromXML用于从XML中将对象解析出来。</p>
<p>toXML用于将对象序列化为XML文件。</p>
<p>在XStream中我还使用HierarchicalStreamWriter，HierarchicalStreamReader，createObjectInputStream()，createObjectOutputStream()，主要是用于对象的输入输出。</p>
<p>下面我们来研究下XStream的工作方式。</p>
<p><strong>XStream**</strong>的实例——将一个序列化对象转化为XML<strong>**对象。</strong></p>
<p>一，创建XStream对象。</p>
<p>XStream xstream=new XStream();</p>
<p>用默认构造器构造了一个名为xstream的XStream的对象。默认构造器所使用XML解析库为Xpp3库，XPP3是一种运行效率非常高的XML全解析实现。</p>
<p>二，创建需要序列化的对象。</p>
<p>比如这个类就叫PrintUnit。</p>
<p>构造也比较简单，一个简单的JavaBean</p>
<pre><code>   public class PrintUnit

   {

          Private String a;

          Private String b;

          Private String c;



          Public PrintUnit(){}



          Public setA(String a)

          {

                 this.a=a;

          }



          Public getA()

          {

                 return a;

          }



          Public setB(String b)

          {

                 this.b=b;

          }



          Public getB()

          {

                 return b;

          }



          Public setC(String c)

          {

                 This.c=c;

          }



          Public getC()

          {

                 Return c;

          }

   }
</code></pre><p>在例子中使用这个JavaBean。</p>
<p>创建并初始化PrintUnit。</p>
<p>PrintUnit pu=new PrintUnit();</p>
<p>pu.setA(&quot;A11&quot;);</p>
<p>pu.setB(&quot;B22&quot;);</p>
<p>pu.setC(&quot;C33&quot;);</p>
<p>三，创建Writer。</p>
<p>创建一个输出流，至于怎么输出我发现可以使用多种方法，其实原理是一样的。</p>
<p>在这里就不得不提到HierarchicalStreamWriter,HierarchicalStreamWriter是一个接口，从字面上意思来说它是有等级的输入流。同样在XStream中也有不少这个接口的实现类用于输出。我现在所用过的有CompactWriter和PrettyPrintWriter这2个。</p>
<p>我是这样做的：</p>
<p>String str=&quot;stream.xml&quot;; //本目录下的一个名为stream的XML文件</p>
<p>PrintWriter pw=new PrintWriter(str);//创建一个PrintWriter对象，用于输出。</p>
<p>之后选用一个HierarchicalStreamWriter的实现类来创建输出。</p>
<p>选用CompactWriter创建：</p>
<p>CompactWriter cw=new CompactWriter(pw);</p>
<p>选用PrettyPrintWriter创建：</p>
<p>PrettyPrintWriter ppw=new PrettyPrintWriter(pw);</p>
<p>两者所使用的方法都是很简单的。</p>
<p>CompactWriter与PrettyPrintWriter的区别在于，以CompactWriter方法输出的为连续的没有分隔的XML文件，而用PrettyPrintWriter方法输出的为有分隔有一定格式的XML文件。</p>
<p>以CompactWriter方式生成的XML文件：</p>
<object-stream><PrintUnit><a>A11</a><b>B22</b><c>C33</c></PrintUnit></object-stream>



以PrettyPrintWriter方式生成的XML文件：

       <object-stream>

             <PrintUnit>

                  <a>A11</a>

                  <b>B22</b>

                  <c>C33</c>

             </PrintUnit>

       </object-stream>



       我想大家能很容易的分辨出它们的差异。



       四，输出操作<br>
以上步骤完成后就可以做输出操作了，XStream的输出方式有多种：toXML方式，ObjectOutputStream方式，marshal方式以及一些我尚未发现的一些其它方式。

先说下我所使用的方式它们各自的不同点，从工作原理上说它们是相似的，但是做法各不相同。

toXML()方法，本身toXML的方法就有2种：

第一种:java.lang.String toXML(java.lang.Object obj)

将对象序列化为XML格式并保存到一个String对象中。

第二种:void toXML(java.lang.Object obj, java.io.Writer out)

将对象序列化为XML格式后以Writer输出到某个地方存储。

我所使用的是第二种方式，使用前面已经做好的Pw就可以实现输出，它其实很简单不需要再去做其它定义，只需要一个PrintWriter对象和需要序列化的Object即可。

直接调用xstream.toXML(printUnit,pw);就能输出XML文件,在这里是输出到该目录下的stream.xml中。这里的输出都是覆盖性的，不是末尾添加形式。

使用ObjectOutputStream方式，简单说它就是生成一个对象输出流。

ObjectOutputStream obj<em>out = xstream.createObjectOutputStream(ppw);

使用XStream的createObjectOutputStream方法创建一个ObjectOutputStream对象，用于XML的输出。这里使用的是PrettyPrintWriter的方式。   之后调用writerObject方法既可，使用方法与其它输出流类似。

obj_out.writeObject(pu);

obj_out.close();

使用marshal方式，其实marshal方法和toXML方法是相同的。在调用toXML方法进行输出时，在XStream内部是需要调用marshal方法的，然后它再去调用对象marshallingStrategy的marshal方法。所以做toXML其实和marshal是相同的，在这里只是想更加说明它的工作方式。



使用 void marshal(java.lang.Object obj, HierarchicalStreamWriter writer)方法。

延续上面的例子，在这里可以这样写：xstream.marshal(pu,ppw);



需要注意的是，和toXML不同的是参数，一个是PrintWriter对象一个则是PrettyPrintWriter对象。因为marshal中需要

HierarchicalStreamWriter，而PrettyPrintWriter则是实现了HierarchicalStreamWriter接口的实现类。



结果和toXML是相同的。



五，结果：

       <object-stream>

             <PrintUnit>

                  <a>A11</a>

                  <b>B22</b>

                  <c>C33</c>

             </PrintUnit>

       </object-stream>



经过以上5步的操作既可将一个序列化对象转化为XML对象。





<strong>toXML**</strong>内部调用图：<strong>

</strong> <strong>

<img src="" alt="XStream.gif">toXML操作时的内部调用图，自己随意画的。有些没有详细说明。





</strong>XStream<strong><strong>的实例——将XML</strong></strong>文件转化为一个对象<strong>



通过上面的一个例子不难看出XStream简便性，既然有了输出就一定会有输入。

输入方我们将会使用ObjectInputStream。

与输出相同我们需要有一个XStream对象，暂且名为xstream。之后需要读取的XML文件地址目录信息。沿用上面的例子。

String inputStr=&quot;xstream.xml&quot;;

XStream xstream=new XStream();

我们需要通过对象流进行输入操作，所以需要FileReader和BufferedReader。

FileReader fr=new FileReader(inputStr);

BufferedReader br=new BufferedReader(fr);

创建对象输入流

ObjectInputStream obj_input=xstream.createObjectInputStream(br);

创建对象，还是使用PrintUnit这个对象。

PrintUnit pu2;

通过ObjectInputStream中的readObject()方法将对象从XML文件中读取出来。

pu2=(PrintUnit)obj_input.readObject();

获取值：

System.out.println(pu2.getB());

控制台：

B22 



从整个输入的过程来看，是一个文件的读取，将其中的对象数据取出来，然后再对这个对象数据进行操作。内容也比较简单通过ObjectInputStream输入对象。

通过以上的输入输出例子，我想大家应该很容易就能理解XStream是如何实现的。



</strong>FomXML<strong>



上面使用的是以ObjectInputStream的方式进行XML与对象之间进行转换的。下面我将使用XStream中的fromXML（）方法进行转换。

首先在使用fromXML我发现一个问题，它必须使用正确的解析方式或输出方式对应的输入方式才可以正常解析读取文件，这个问题有点怪，不过确实存在，当我使用前面ObjectOutputStream方式输出的XML文件,用fromXML（）解析读取时，它会报错。

错误信息：

Exception in thread &quot;main&quot; com.thoughtworks.xstream.alias.CannotResolveClassException: object$stream : object$stream

信息内容为：不能解析这个文件。我认为它和输出方式有关，因为上面例子中使用的是ObjectOutputStream，当我反过来做了一个实验后也证明了这一点。

实验大致内容：使用toXML()方法输出XML文件，使用ObjectInputStream解析，发现会在读取的时候抛出CannotResolveClassException异常。

错误信息：

Exception in thread &quot;main&quot; com.thoughtworks.xstream.alias.CannotResolveClassException:

a : a

       因此我认为在解析文件的时候必须先要确定这个文件是由什么方式生成的，然后在解析它，对于使用Dom,Dom4j,XPP等不同方式解析尚未尝试。以上测试是在默认的基础上实验的，默认为XPP3的解析器。



       使用fromXML的方法。



       public java.lang.Object fromXML(java.lang.String xml)

       public java.lang.Object fromXML(java.io.Reader xml)

public java.lang.Object fromXML(java.lang.String xml,java.lang.Object root)

public java.lang.Object fromXML(java.io.Reader xml,java.lang.Object root)



例子：

       PrintUnit puTwo=(PrintUnit)xstream.fromXML(xml);



这里的xml必须是使用toXML()生成出来的。对于Reader没有太多的要求。





</strong>XStream<strong><strong>与</strong></strong>Java.Bean<strong><strong>中</strong></strong>XML<strong><strong>工具的比较**</strong></strong>



       XStream主要作用是将序列化的对象转化为一个XML文件或将XML文件解析为一个对象。当然并非只有它可以做到，很多其它工具一样可以，在Java中存在这样两个类XMLDecoder和XMLEncoder，它们是在Java.Bean包下的，它们的作用是将JavaBean转化为XML或将XML文件转化为一个Java Bean。

       XMLDecoder是通过一个输入流将对象从输入流中取出并转化为一个实例的方法。它所需要的就是一个输入流及一个转化过程。



       XMLDecoder的实例：



       String fileStr=”xstream.xml”;//XML文件，在本目录下，延用上次使用文件。

       ObjectInputStream in=new ObjectInputStream(new FileInputStream(fileStr));//创建一个ObjectInputStream用于输入。

       XMLDecoder xmld=new XMLDecoder(in);//创建一个XMLDecoder对象。

       延用前面所使用PrintUnit这个Bean。

       PrintUnit pu=(PrintUnit)xmld.readObject();//通过XMLDecoder中的readObject方法获得PrintUnit对象。

如果获取到了这个对象那么pu中将有它的值a=A11,b=B22,c=C33。整个过程最好放try

…catch中去，能够捕获一些如：文件不存在等异常。

       从操作方式上看XMLDecoder似乎不比XStream差多少，同样是可以通过ObjectInputStream获取XML文件中的对象。它们的差异就是解析的方式不同，XMLDecoder是使用Java自带的XML解析方式，而XStream则是可以自定义的，它可以使用多中方式进行解析。这些是我个人所发现的一些不同点。



       XMLEncoder是通过一个输出流将对象序列化并输出为XML文件。它所需要的是一个输出流及一个输出方式。



       XMLEncoder的实例：



       String fileStr=”xstream.xml”;//定义一个输入的目标文件。

       ObjectOutputStream out=new ObjectOutputStream(new FileOutputStream(fileStr));//创建一个对象输出流。

       XMLEncoder xmle=new XMLEncoder(out);//创建一个XMLEncoder对象。

       延用前面所使用PrintUnit这个Bean。

//创建并初始化PrintUnit对象。

PrintUnit pu=new PrintUnit();

pu.setA(“AAA”);

pu.setB(“BBB”);

pu.setC(“CCC”);



       xmle.writeObject(pu);//使用XMLEncode的writeObject方法输出pu

       xmle.flush();//刷新

       xmle.close();//关闭输出流



       从上面的代码不难看出，使用XMLEncode方式将对象序列化并输出也是很方便的，简单调用writeObject方法能将普通Bean输出为XML文件。



       XML文件的内容：



�</em> &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;

<java version="1.5.0" class="java.beans.XMLDecoder">

 <object class="test.PrintUnit">

  <void property="a">

   <string>AAA</string>

  </void>

  <void property="b">

   <string>BBB</string>

  </void>

  <void property="c">

   <string>CCC</string>

  </void>

 </object>

<p>w   </java></p>
<pre><code>   不知道是我哪里没有处理，还是实际并不是像我想象的哪么简单，使用XMLEncoder所输出的XML文件中有一定的问题，虽然它很详细，比起XStream所生成的更多，包括了XML和Java的版本看上去更像是个完整的XML文件，不过再细看它们两生成的XML格式内容，完全不同，这个我想就是它们最大的区别。这让我想到了很多内容：工作方式，解析器，转换方式等。大家有没发现在开始和结束都存在一些乱码数据，难道在XMLEncoder输出过程中或数据转换中内容已经存在“脏”数据了？还是我所使用的输出方式存在问题？哎…一个又一个问题出现了。我想我需要再进一步的研究和学习才能得到答案。

   不过尽管有这个那个的问题，使用Java本身自带的XML工具还是一样很实用的，读取和输出一样可用，操作也很灵活。因此我觉得在某些场合使用特定的工具可能会更好，利用XMLEncoder和XMLDecoder同样可以解决一些问题。
</code></pre><p>我的这个使用XMLDecoder和XMLEncoder的序列化格式输出暂研究到这里。
枫情·太子爷
2005年12月16日</p>
<p>发表于 2005-12-16 16:22 <a href="http://www.blogjava.net/zlkn2005/" target="_blank">枫情·太子爷</a> 阅读(3625) <a href="http://www.blogjava.net/zlkn2005/archive/2005/12/16/24240.html#Post" target="_blank">评论(4)</a>  <a href="http://www.blogjava.net/zlkn2005/admin/EditPosts.aspx?postid=24240" target="_blank">编辑</a>  <a href="http://www.blogjava.net/zlkn2005/AddToFavorite.aspx?id=24240" target="_blank">收藏</a></p>
<p><img src="" alt=""></p>
<p><a href=""></a></p>
<p><a href=""></a></p>
<p><a href="">评论</a></p>
<p><a href=""></a></p>
<p><a href=""></a></p>
<p><a href=""></a><a href="http://www.blogjava.net/zlkn2005/archive/2005/12/16/24240.html#24242" title="permalink: re: XStream 学习笔记">/#</a> <a href=""></a>re: XStream 学习笔记  <a href="http://www.blogjava.net/zlkn2005/archive/2005/12/16/24240.html#post">回复</a>  <a href="http://www.blogjava.net/comment?author=fanta" title="查看该作者发表过的评论" target="_blank">更多评论</a>  <a href=""></a>  <a href=""></a>
好</p>
<p><a href="http://www.blogjava.net/fanscial/" target="_blank">fanta</a> 评论于 2005-12-16 16:45
<a href="http://www.blogjava.net/zlkn2005/archive/2005/12/16/24240.html#24616" title="permalink: re: XStream 学习笔记" target="_blank">/#</a> <a href=""></a>re: XStream 学习笔记  <a href="http://www.blogjava.net/zlkn2005/archive/2005/12/16/24240.html#post">回复</a>  <a href="http://www.blogjava.net/comment?author=xmlspy2004" title="查看该作者发表过的评论" target="_blank">更多评论</a>  <a href=""></a>  <a href=""></a></p>
<p>还有很多问题，比如：
当bean的字段为int类型，如果这个字段没有值，它默认输出是0
而实际应用中我们需要的是<intField></intField>.
类似的问题还很多，都需要你去处理。
但处理来处理去，你会发现，自己做的修改很多，还不如自己手动写xml的String。
<a href="">xmlspy2004</a> 评论于 2005-12-19 12:42</p>
<p><a href="http://www.blogjava.net/zlkn2005/archive/2005/12/16/24240.html#183462" title="permalink: re: XStream 学习笔记" target="_blank">/#</a> <a href=""></a>re: XStream 学习笔记  <a href="http://www.blogjava.net/zlkn2005/archive/2005/12/16/24240.html#post">回复</a>  <a href="http://www.blogjava.net/comment?author=%e5%bf%83%e6%97%a0%e7%97%95" title="查看该作者发表过的评论" target="_blank">更多评论</a>  <a href=""></a>  <a href=""></a></p>
<p>呵呵.在JAVA里面,INT类型的变量本来默认值就是0,你没有给它值,它也会默认将0作为这个变量的初始值....@xmlspy2004
<a href="http://www.blogjava.net/xinwuhen/" target="_blank">心无痕</a> 评论于 2008-03-03 14:39
<a href="http://www.blogjava.net/zlkn2005/archive/2005/12/16/24240.html#200051" title="permalink: re: XStream 学习笔记" target="_blank">/#</a> <a href=""></a>re: XStream 学习笔记<a href=""></a>  <a href="http://www.blogjava.net/zlkn2005/archive/2005/12/16/24240.html#post" target="_blank">回复</a>  <a href="http://www.blogjava.net/comment?author=jadar" title="查看该作者发表过的评论" target="_blank">更多评论</a>  <a href=""></a>  <a href=""></a></p>
<p>出现：Exception in thread &quot;main&quot; com.thoughtworks.xstream.alias.CannotResolveClassException:
的可能原因是:调用xStream.alias(&quot;PrintUnit &quot;,PrintUnit.class) 时写错了，
尤其是第一个参数，要跟xml中的大小写一致！
good Luck！
<a href="">jadar</a> 评论于 2008-05-12 16:52</p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/xml/">xml</a></li></span><span class="breadcrumb"><li><a href="/categories/xml/">xml</a></li><li><a href="/categories/xml/xstream/">xstream</a></li></span></span> | <span class="tags">Tagged <a href="/tags/xml/" class="label label-primary">xml</a><a href="/tags/xstream/" class="label label-success">xstream</a></span> | <span class="time">recent updated:<time title="2014-04-07 16:47:00"datetime="2014-04-07 16:47:00"> abr. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-xml-xstream--XStream学习笔记-枫情的Blog-BlogJava/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-xml-xstream--XStream学习笔记-枫情的Blog-BlogJava" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-xml-xstream--xStream完美转换XML、JSON/">xStream完美转换XML、JSON</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:44.000Z"> <a href="/2014/02/02/2014-02-02-xml-xstream--xStream完美转换XML、JSON/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="xstream-xml-json">xStream完美转换XML、JSON</h1>
<p><strong>xStream**</strong>框架<strong>**</strong></p>
<p>xStream可以轻易的将Java对象和xml文档相互转换，而且可以修改某个特定的属性和节点名称，而且也支持json的转换；</p>
<p>前面有介绍过json-lib这个框架，在线博文：<a href="http://www.cnblogs.com/hoojo/archive/2011/04/21/2023805.html" target="_blank"><a href="http://www.cnblogs.com/hoojo/archive/2011/04/21/2023805.html">http://www.cnblogs.com/hoojo/archive/2011/04/21/2023805.html</a></a></p>
<p>以及Jackson这个框架，在线博文：<a href="http://www.cnblogs.com/hoojo/archive/2011/04/22/2024628.html" target="_blank"><a href="http://www.cnblogs.com/hoojo/archive/2011/04/22/2024628.html">http://www.cnblogs.com/hoojo/archive/2011/04/22/2024628.html</a></a></p>
<p>它们都完美支持JSON，但是对xml的支持还不是很好。一定程度上限制了对Java对象的描述，不能让xml完全体现到对Java对象的描述。这里将会介绍xStream对JSON、XML的完美支持。xStream不仅对XML的转换非常友好，而且提供annotation注解，可以在JavaBean中完成对xml节点、属性的描述。以及对JSON也支持，只需要提供相关的JSONDriver就可以完成转换。</p>
<p><strong>一、**</strong>准备工作<strong>**</strong></p>
<p>1、 下载jar包、及官方资源</p>
<p>xStream的jar下载地址：</p>
<p><a href="https://nexus.codehaus.org/content/repositories/releases/com/thoughtworks/xstream/xstream-distribution/1.3.1/xstream-distribution-1.3.1-bin.zip" target="_blank"><a href="https://nexus.codehaus.org/content/repositories/releases/com/thoughtworks/xstream/xstream-distribution/1.3.1/xstream-distribution-1.3.1-bin.zip">https://nexus.codehaus.org/content/repositories/releases/com/thoughtworks/xstream/xstream-distribution/1.3.1/xstream-distribution-1.3.1-bin.zip</a></a></p>
<p>官方的示例很全，官方参考示例：<a href="http://xstream.codehaus.org/tutorial.html" target="_blank"><a href="http://xstream.codehaus.org/tutorial.html">http://xstream.codehaus.org/tutorial.html</a></a></p>
<p>添加xstream-1.3.1.jar文件到工程中，就可以开始下面的工作；需要的jar如下：</p>
<p><a href="http://images.cnblogs.com/cnblogs_com/hoojo/201104/201104221846024160.jpg" target="_blank"><img src="&quot;clip_image002&quot;" alt="clip_image002"></a></p>
<p>2、 测试用例代码
package com.hoo.test;</p>
<p>import java.io.IOException;
import java.io.ObjectInputStream;</p>
<p>import java.io.ObjectOutputStream;
import java.io.StringReader;</p>
<p>import java.io.Writer;
import java.util.ArrayList;</p>
<p>import java.util.HashMap;
import java.util.Iterator;</p>
<p>import java.util.List;
import java.util.Map;</p>
<p>import java.util.Set;
import org.codehaus.jettison.json.JSONException;</p>
<p>import org.junit.After;
import org.junit.Before;</p>
<p>import org.junit.Test;
import com.hoo.entity.Birthday;</p>
<p>import com.hoo.entity.Classes;
import com.hoo.entity.ListBean;</p>
<p>import com.hoo.entity.Student;
import com.thoughtworks.xstream.XStream;</p>
<p>import com.thoughtworks.xstream.io.HierarchicalStreamWriter;
import com.thoughtworks.xstream.io.json.JettisonMappedXmlDriver;</p>
<p>import com.thoughtworks.xstream.io.json.JsonHierarchicalStreamDriver;
import com.thoughtworks.xstream.io.json.JsonWriter;</p>
<p>//<em>/</em>
/* <b>function:</b>Java对象和XML字符串的相互转换</p>
<p>/<em> jar-lib-version: xstream-1.3.1
/</em> @author hoojo</p>
<p>/<em> @createDate Nov 27, 2010 12:15:15 PM
/</em> @file XStreamTest.java</p>
<p>/<em> @package com.hoo.test
/</em> @project WebHttpUtils</p>
<p>/<em> @blog <a href="http://blog.csdn.net/IBM_hoojo" target="_blank">http://blog.csdn.net/IBM_hoojo</a>
/</em> @email hoojo_@126.com</p>
<p>/<em> @version 1.0
/</em>/</p>
<p>@SuppressWarnings(&quot;unchecked&quot;)
public class XStreamTest {</p>
<p>private XStream xstream = null;
private ObjectOutputStream out = null;</p>
<p>private ObjectInputStream in = null;
private Student bean = null;</p>
<p>//<em>/</em>
/* <b>function:</b>初始化资源准备</p>
<p>/<em> @author hoojo
/</em> @createDate Nov 27, 2010 12:16:28 PM</p>
<p>/*/
@Before</p>
<p>public void init() {
try {</p>
<p>xstream = new XStream();
//xstream = new XStream(new DomDriver()); // 需要xpp3 jar</p>
<p>} catch (Exception e) {
e.printStackTrace();</p>
<p>}
bean = new Student();</p>
<p>bean.setAddress(&quot;china&quot;);
bean.setEmail(&quot;jack@email.com&quot;);</p>
<p>bean.setId(1);
bean.setName(&quot;jack&quot;);</p>
<p>Birthday day = new Birthday();
day.setBirthday(&quot;2010-11-22&quot;);</p>
<p>bean.setBirthday(day);
}</p>
<p>//<em>/</em>
/* <b>function:</b>释放对象资源</p>
<p>/<em> @author hoojo
/</em> @createDate Nov 27, 2010 12:16:38 PM</p>
<p>/*/
@After</p>
<p>public void destory() {
xstream = null;</p>
<p>bean = null;
try {</p>
<p>if (out != null) {
out.flush();</p>
<p>out.close();
}</p>
<p>if (in != null) {
in.close();</p>
<p>}
} catch (IOException e) {</p>
<p>e.printStackTrace();
}</p>
<p>System.gc();
}</p>
<p>public final void fail(String string) {
System.out.println(string);</p>
<p>}
public final void failRed(String string) {</p>
<p>System.err.println(string);
}</p>
<p>}</p>
<p>通过XStream对象的toXML方法就可以完成Java对象到XML的转换，toXML方法还有2个相同签名的方法，需要传递一个流。然后通过流来完成xml信息的输出。</p>
<p>3、 需要的JavaBean
package com.hoo.entity;</p>
<p>public class Student {
private int id;</p>
<p>private String name;
private String email;</p>
<p>private String address;
private Birthday birthday;</p>
<p>//getter、setter
public String toString() {</p>
<p>return this.name + &quot;/#&quot; + this.id + &quot;/#&quot; + this.address + &quot;/#&quot; + this.birthday + &quot;/#&quot; + this.email;
}</p>
<p>}</p>
<hr>
<p><strong>二、**</strong>Java<strong><strong>转换成</strong></strong>XML**</p>
<p>1、 JavaBean转换XM
//<em>/</em></p>
<p>/<em> <b>function:</b>Java对象转换成XML字符串
/</em> @author hoojo</p>
<p>/<em> @createDate Nov 27, 2010 12:19:01 PM
/</em>/</p>
<p>@Test
public void writeBean2XML() {</p>
<p>try {
fail(&quot;------------Bean-&gt;XML------------&quot;);</p>
<p>fail(xstream.toXML(bean));
fail(&quot;重命名后的XML&quot;);</p>
<p>//类重命名
//xstream.alias(&quot;account&quot;, Student.class);</p>
<p>//xstream.alias(&quot;生日&quot;, Birthday.class);
//xstream.aliasField(&quot;生日&quot;, Student.class, &quot;birthday&quot;);</p>
<p>//xstream.aliasField(&quot;生日&quot;, Birthday.class, &quot;birthday&quot;);
//fail(xstream.toXML(bean));</p>
<p>//属性重命名
xstream.aliasField(&quot;邮件&quot;, Student.class, &quot;email&quot;);</p>
<p>//包重命名
xstream.aliasPackage(&quot;hoo&quot;, &quot;com.hoo.entity&quot;);</p>
<p>fail(xstream.toXML(bean));
} catch (Exception e) {</p>
<p>e.printStackTrace();
}</p>
<p>}</p>
<p>看结果中的第一份xml内容，是没有经过然后修改或重命名的文档，按照原样输出。文档中的第二份文档的package经过重命名，email属性也经过重命名以及类名也可以进行重命名的。</p>
<p>运行后结果如下：
------------Bean-&gt;XML------------</p>
<p><com.hoo.entity.Student></p>
<id>1</id>

<name>jack</name>
<email>jack@email.com</email>

<address>china</address>
<birthday>

<birthday>2010-11-22</birthday>
</birthday>

</com.hoo.entity.Student>
重命名后的XML

<hoo.Student>
<id>1</id>

<name>jack</name>
&lt;邮件&gt;jack@email.com&lt;/邮件&gt;

<address>china</address>
<birthday>

<birthday>2010-11-22</birthday>
</birthday>

</hoo.Student>

2、 将List集合转换成xml文档

//<em>/</em>

/<em> <b>function:</b>将Java的List集合转换成XML对象
/</em> @author hoojo

/<em> @createDate Nov 27, 2010 12:20:07 PM
/</em>/

@Test
public void writeList2XML() {

try {
//修改元素名称

xstream.alias(&quot;beans&quot;, ListBean.class);
xstream.alias(&quot;student&quot;, Student.class);

fail(&quot;----------List--&gt;XML----------&quot;);
ListBean listBean = new ListBean();

listBean.setName(&quot;this is a List Collection&quot;);
List<Object> list = new ArrayList<Object>();

list.add(bean);
list.add(bean);//引用bean

//list.add(listBean);//引用listBean，父元素
bean = new Student();

bean.setAddress(&quot;china&quot;);
bean.setEmail(&quot;tom@125.com&quot;);

bean.setId(2);
bean.setName(&quot;tom&quot;);

Birthday day = new Birthday(&quot;2010-11-22&quot;);
bean.setBirthday(day);

list.add(bean);
listBean.setList(list);

//将ListBean中的集合设置空元素，即不显示集合元素标签
//xstream.addImplicitCollection(ListBean.class, &quot;list&quot;);

//设置reference模型
//xstream.setMode(XStream.NO_REFERENCES);//不引用

xstream.setMode(XStream.ID_REFERENCES);//id引用
//xstream.setMode(XStream.XPATH_ABSOLUTE_REFERENCES);//绝对路径引用

//将name设置为父类（Student）的元素的属性
xstream.useAttributeFor(Student.class, &quot;name&quot;);

xstream.useAttributeFor(Birthday.class, &quot;birthday&quot;);
//修改属性的name

xstream.aliasAttribute(&quot;姓名&quot;, &quot;name&quot;);
xstream.aliasField(&quot;生日&quot;, Birthday.class, &quot;birthday&quot;);

fail(xstream.toXML(listBean));
} catch (Exception e) {

e.printStackTrace();
}

}

上面的代码运行后，结果如下：

----------List--&gt;XML----------

<beans id="1">
<name>this is a List Collection</name>

<p><list id="2"></p>
<student id="3" 姓名="jack">

<id>1</id>
<email>jack@email.com</email>

<address>china</address>
<birthday id="4" 生日="2010-11-22"/>

</student>
<student reference="3"/>

<student id="5" 姓名="tom">
<id>2</id>

<email>tom@125.com</email>
<address>china</address>

<birthday id="6" 生日="2010-11-22"/>
</student>

<p></list>
</beans></p>
<p>如果不加xstream.addImplicitCollection(ListBean.<strong>class</strong>, &quot;list&quot;);</p>
<p>这个设置的话，会出现一个List节点包裹着Student节点元素。添加addImplicitCollection可以忽略这个list节点元素。那么上面的list节点就不存在，只会在beans元素中出现name、student这2个xml元素标签；</p>
<p>setMode是设置相同的对象的引用方式，如果设置XStream.NO_REFERENCES就是不引用，会输出2分相同的Student元素。如果是XStream.ID_REFERENCES会引用相同的那个对象的id属性，如果是XStream.XPATH_ABSOLUTE_REFERENCES引用，那么它将显示xpath路径。上面采用的id引用，<student reference="3"/>这个引用了id=3的那个student标签元素；</p>
<p>useAttributeFor是设置某个节点显示到父节点的属性中，也就是将指定class中的指定属性，在这个class元素节点的属性中显示。</p>
<p>如：<student><name>hoojo</name></student></p>
<p>设置好后就是这样的结果：<student name=”hoojo”></student></p>
<p>aliasAttribute是修改属性名称。</p>
<p>3、 在JavaBean中添加Annotation注解进行重命名设置</p>
<p>先看看JavaBean的代码
package com.hoo.entity;</p>
<p>import java.util.Arrays;
import java.util.Calendar;</p>
<p>import java.util.GregorianCalendar;
import java.util.List;</p>
<p>import com.thoughtworks.xstream.annotations.XStreamAlias;
import com.thoughtworks.xstream.annotations.XStreamAsAttribute;</p>
<p>import com.thoughtworks.xstream.annotations.XStreamConverter;
import com.thoughtworks.xstream.annotations.XStreamImplicit;</p>
<p>import com.thoughtworks.xstream.annotations.XStreamOmitField;
@XStreamAlias(&quot;class&quot;)</p>
<p>public class Classes {
//*</p>
<p>/<em> 设置属性显示
/</em>/</p>
<p>@XStreamAsAttribute
@XStreamAlias(&quot;名称&quot;)</p>
<p>private String name;
//*</p>
<p>/<em> 忽略
/</em>/</p>
<p>@XStreamOmitField
private int number;</p>
<p>@XStreamImplicit(itemFieldName = &quot;Students&quot;)
private List<Student> students;</p>
<p>@SuppressWarnings(&quot;unused&quot;)
@XStreamConverter(SingleValueCalendarConverter.class)</p>
<p>private Calendar created = new GregorianCalendar();
public Classes(){}</p>
<p>public Classes(String name, Student... stu) {
this.name = name;</p>
<p>this.students = Arrays.asList(stu);
}</p>
<p>//getter、setter
}</p>
<p>SingleValueCalendarConverter.java这个是一个类型转换器</p>
<p>package com.hoo.entity;</p>
<p>import java.util.Calendar;
import java.util.Date;</p>
<p>import java.util.GregorianCalendar;
import com.thoughtworks.xstream.converters.Converter;</p>
<p>import com.thoughtworks.xstream.converters.MarshallingContext;
import com.thoughtworks.xstream.converters.UnmarshallingContext;</p>
<p>import com.thoughtworks.xstream.io.HierarchicalStreamReader;
import com.thoughtworks.xstream.io.HierarchicalStreamWriter;</p>
<p>public class SingleValueCalendarConverter implements Converter {
public void marshal(Object source, HierarchicalStreamWriter writer,</p>
<p>MarshallingContext context) {
Calendar calendar = (Calendar) source;</p>
<p>writer.setValue(String.valueOf(calendar.getTime().getTime()));
}</p>
<p>public Object unmarshal(HierarchicalStreamReader reader,
UnmarshallingContext context) {</p>
<p>GregorianCalendar calendar = new GregorianCalendar();
calendar.setTime(new Date(Long.parseLong(reader.getValue())));</p>
<p>return calendar;
}</p>
<p>@SuppressWarnings(&quot;unchecked&quot;)
public boolean canConvert(Class type) {</p>
<p>return type.equals(GregorianCalendar.class);
}</p>
<p>}</p>
<p>再看看测试用例代码</p>
<p>@Test</p>
<p>public void writeList2XML4Annotation() {
try {</p>
<p>failRed(&quot;---------annotation Bean --&gt; XML---------&quot;);
Student stu = new Student();</p>
<p>stu.setName(&quot;jack&quot;);
Classes c = new Classes(&quot;一班&quot;, bean, stu);</p>
<p>c.setNumber(2);
//对指定的类使用Annotation</p>
<p>//xstream.processAnnotations(Classes.class);
//启用Annotation</p>
<p>//xstream.autodetectAnnotations(true);
xstream.alias(&quot;student&quot;, Student.class);</p>
<p>fail(xstream.toXML(c));
} catch (Exception e) {</p>
<p>e.printStackTrace();
}</p>
<p>}</p>
<p>当启用annotation或是对某个特定的类启用annotation时，上面的classes这个类才有效果。如果不启用annotation，运行后结果如下：</p>
<p>---------annotation Bean --&gt; XML---------</p>
<p><com.hoo.entity.Classes></p>
<name>一班</name>

<p><number>2</number></p>
<students class="java.util.Arrays$ArrayList">

<a class="student-array">
<student>

<id>1</id>
<name>jack</name>

<email>jack@email.com</email>
<address>china</address>

<birthday>
<birthday>2010-11-22</birthday>

</birthday>
</student>

<student>
<id>0</id>

<name>jack</name>
</student>

</a>
</students>

<created>
<time>1303292056718</time>

<timezone>Asia/Shanghai</timezone>
</created>

<p></com.hoo.entity.Classes></p>
<p>当启用annotation后xstream.processAnnotations(Classes.class)，结果如下：</p>
<p>---------annotation Bean --&gt; XML---------</p>
<class 名称="一班">
<Students>

<id>1</id>
<name>jack</name>

<email>jack@email.com</email>
<address>china</address>

<birthday>
<birthday>2010-11-22</birthday>

</birthday>
</Students>

<Students>
<id>0</id>

<name>jack</name>
</Students>

<created>1303292242937</created>
</class>

<p>4、 Map集合转换xml文档</p>
<p>//<em>/</em></p>
<p>/<em> <b>function:</b>Java Map集合转XML
/</em> @author hoojo</p>
<p>/<em> @createDate Nov 27, 2010 1:13:26 PM
/</em>/</p>
<p>@Test
public void writeMap2XML() {</p>
<p>try {
failRed(&quot;---------Map --&gt; XML---------&quot;);</p>
<p>Map<String, Student> map = new HashMap<String, Student>();
map.put(&quot;No.1&quot;, bean);//put</p>
<p>bean = new Student();
bean.setAddress(&quot;china&quot;);</p>
<p>bean.setEmail(&quot;tom@125.com&quot;);
bean.setId(2);</p>
<p>bean.setName(&quot;tom&quot;);
Birthday day = new Birthday(&quot;2010-11-22&quot;);</p>
<p>bean.setBirthday(day);
map.put(&quot;No.2&quot;, bean);//put</p>
<p>bean = new Student();
bean.setName(&quot;jack&quot;);</p>
<p>map.put(&quot;No.3&quot;, bean);//put
xstream.alias(&quot;student&quot;, Student.class);</p>
<p>xstream.alias(&quot;key&quot;, String.class);
xstream.useAttributeFor(Student.class, &quot;id&quot;);</p>
<p>xstream.useAttributeFor(&quot;birthday&quot;, String.class);
fail(xstream.toXML(map));</p>
<p>} catch (Exception e) {
e.printStackTrace();</p>
<p>}
}</p>
<p>运行后结果如下：</p>
<p>---------Map --&gt; XML---------</p>
<map>
<entry>

<key>No.3</key>
<student id="0">

<name>jack</name>
</student>

</entry>
<entry>

<key>No.1</key>
<student id="1">

<name>jack</name>
<email>jack@email.com</email>

<address>china</address>
<birthday birthday="2010-11-22"/>

</student>
</entry>

<entry>
<key>No.2</key>

<student id="2">
<name>tom</name>

<email>tom@125.com</email>
<address>china</address>

<birthday birthday="2010-11-22"/>
</student>

</entry>
</map>

<p>5、 用OutStream输出流写XML</p>
<p>//<em>/</em></p>
<p>/<em> <b>function:</b>用OutStream输出流写XML
/</em> @author hoojo</p>
<p>/<em> @createDate Nov 27, 2010 1:13:48 PM
/</em>/</p>
<p>@Test
public void writeXML4OutStream() {</p>
<p>try {
out = xstream.createObjectOutputStream(System.out);</p>
<p>Student stu = new Student();
stu.setName(&quot;jack&quot;);</p>
<p>Classes c = new Classes(&quot;一班&quot;, bean, stu);
c.setNumber(2);</p>
<p>failRed(&quot;---------ObjectOutputStream /# JavaObject--&gt; XML---------&quot;);
out.writeObject(stu);</p>
<p>out.writeObject(new Birthday(&quot;2010-05-33&quot;));
out.write(22);//byte</p>
<p>out.writeBoolean(true);
out.writeFloat(22.f);</p>
<p>out.writeUTF(&quot;hello&quot;);
} catch (Exception e) {</p>
<p>e.printStackTrace();
}</p>
<p>}</p>
<p>使用输出流后，可以通过流对象完成xml的构建，即使没有JavaBean对象，你可以用流来构建一个复杂的xml文档，运行后结果如下：</p>
<p>---------ObjectOutputStream /# JavaObject--&gt; XML---------</p>
<p><object-stream></p>
<com.hoo.entity.Student>

<p><id>0</id></p>
<name>jack</name>

<p></com.hoo.entity.Student></p>
<com.hoo.entity.Birthday>

<p><birthday>2010-05-33</birthday>
</com.hoo.entity.Birthday></p>
<p><byte>22</byte></p>
<boolean>true</boolean>

<p><float>22.0</float></p>
<string>hello</string>

<p></object-stream></p>
<hr>
<p><strong>三、**</strong>XML<strong><strong>内容转换</strong></strong>Java<strong><strong>对象**</strong></strong></p>
<p>1、 用InputStream将XML文档转换成java对象
//<em>/</em></p>
<p>/<em> <b>function:</b>用InputStream将XML文档转换成java对象
/</em> 需要额外的jar xpp3-main.jar</p>
<p>/<em> @author hoojo
/</em> @createDate Nov 27, 2010 1:14:52 PM</p>
<p>/*/
@Test</p>
<p>public void readXML4InputStream() {
try {</p>
<p>String s = &quot;<object-stream><com.hoo.entity.Student><id>0</id><name>jack</name>&quot; +
&quot;</com.hoo.entity.Student><com.hoo.entity.Birthday><birthday>2010-05-33</birthday>&quot; +</p>
<p>&quot;</com.hoo.entity.Birthday><byte>22</byte><boolean>true</boolean><float>22.0</float>&quot; +
&quot;<string>hello</string></object-stream>&quot;;</p>
<p>failRed(&quot;---------ObjectInputStream/#/# XML --&gt; javaObject---------&quot;);
StringReader reader = new StringReader(s);</p>
<p>in = xstream.createObjectInputStream(reader);
Student stu = (Student) in.readObject();</p>
<p>Birthday b = (Birthday) in.readObject();
byte i = in.readByte();</p>
<p>boolean bo = in.readBoolean();
float f = in.readFloat();</p>
<p>String str = in.readUTF();
System.out.println(stu);</p>
<p>System.out.println(b);
System.out.println(i);</p>
<p>System.out.println(bo);
System.out.println(f);</p>
<p>System.out.println(str);
} catch (Exception e) {</p>
<p>e.printStackTrace();
}</p>
<p>}</p>
<p>读取后，转换的Java对象，结果如下：</p>
<p>---------ObjectInputStream/#/# XML --&gt; javaObject---------</p>
<p>jack/#0/#null/#null/#null
2010-05-33</p>
<p>22
true</p>
<p>22.0
hello</p>
<p>2、 将xml文档转换成Java对象</p>
<p>//<em>/</em></p>
<p>/<em> <b>function:</b>将XML字符串转换成Java对象
/</em> @author hoojo</p>
<p>/<em> @createDate Nov 27, 2010 2:39:06 PM
/</em>/</p>
<p>@Test
public void readXml2Object() {</p>
<p>try {
failRed(&quot;-----------Xml &gt;&gt;&gt; Bean--------------&quot;);</p>
<p>Student stu = (Student) xstream.fromXML(xstream.toXML(bean));
fail(stu.toString());</p>
<p>List<Student> list = new ArrayList<Student>();
list.add(bean);//add</p>
<p>Map<String, Student> map = new HashMap<String, Student>();
map.put(&quot;No.1&quot;, bean);//put</p>
<p>bean = new Student();
bean.setAddress(&quot;china&quot;);</p>
<p>bean.setEmail(&quot;tom@125.com&quot;);
bean.setId(2);</p>
<p>bean.setName(&quot;tom&quot;);
Birthday day = new Birthday(&quot;2010-11-22&quot;);</p>
<p>bean.setBirthday(day);
list.add(bean);//add</p>
<p>map.put(&quot;No.2&quot;, bean);//put
bean = new Student();</p>
<p>bean.setName(&quot;jack&quot;);
list.add(bean);//add</p>
<p>map.put(&quot;No.3&quot;, bean);//put
failRed(&quot;==========XML &gt;&gt;&gt; List===========&quot;);</p>
<p>List<Student> studetns = (List<Student>) xstream.fromXML(xstream.toXML(list));
fail(&quot;size:&quot; + studetns.size());//3</p>
<p>for (Student s : studetns) {
fail(s.toString());</p>
<p>}
failRed(&quot;==========XML &gt;&gt;&gt; Map===========&quot;);</p>
<p>Map<String, Student> maps = (Map<String, Student>) xstream.fromXML(xstream.toXML(map));
fail(&quot;size:&quot; + maps.size());//3</p>
<p>Set<String> key = maps.keySet();
Iterator<String> iter = key.iterator();</p>
<p>while (iter.hasNext()) {
String k = iter.next();</p>
<p>fail(k + &quot;:&quot; + map.get(k));
}</p>
<p>} catch (Exception e) {
e.printStackTrace();</p>
<p>}
}</p>
<p>运行后结果如下：</p>
<p>-----------Xml &gt;&gt;&gt; Bean--------------</p>
<p>jack/#1/#china/#2010-11-22/#jack@email.com
==========XML &gt;&gt;&gt; List===========</p>
<p>size:3
jack/#1/#china/#2010-11-22/#jack@email.com</p>
<p>tom/#2/#china/#2010-11-22/#tom@125.com
jack/#0/#null/#null/#null</p>
<p>==========XML &gt;&gt;&gt; Map===========
size:3</p>
<p>No.3:jack/#0/#null/#null/#null
No.1:jack/#1/#china/#2010-11-22/#jack@email.com</p>
<p>No.2:tom/#2/#china/#2010-11-22/#tom@125.com</p>
<p>怎么样，成功的完成XML到JavaBean、List、Map的转换，更多对象转换还需要大家一一尝试。用法类似~这里就不一样赘述。</p>
<p><strong>四、**</strong>XStream<strong><strong>对</strong></strong>JSON<strong><strong>的支持**</strong></strong></p>
<p>xStream对JSON也有非常好的支持，它提供了2个模型驱动。用这2个驱动可以完成Java对象到JSON的相互转换。使用JettisonMappedXmlDriver驱动，将Java对象转换成json，需要添加jettison.jar</p>
<p>1、 用JettisonMappedXmlDriver完成Java对象到JSON的转换
//<em>/</em></p>
<p>/<em> <b>function:</b>XStream结合JettisonMappedXmlDriver驱动，转换Java对象到JSON
/</em> 需要添加jettison jar</p>
<p>/<em> @author hoojo
/</em> @createDate Nov 27, 2010 1:23:18 PM</p>
<p>/*/
@Test</p>
<p>public void writeEntity2JETTSON() {
failRed(&quot;=======JettisonMappedXmlDriver===JavaObject &gt;&gt;&gt;&gt; JaonString=========&quot;);</p>
<p>xstream = new XStream(new JettisonMappedXmlDriver());
xstream.setMode(XStream.NO_REFERENCES);</p>
<p>xstream.alias(&quot;student&quot;, Student.class);
fail(xstream.toXML(bean));</p>
<p>}</p>
<p>运行后结果如下：</p>
<p>=======JettisonMappedXmlDriver===JavaObject &gt;&gt;&gt;&gt; JaonString=========</p>
<p>{&quot;student&quot;:{&quot;id&quot;:1,&quot;name&quot;:&quot;jack&quot;,&quot;email&quot;:&quot;jack@email.com&quot;,&quot;address&quot;:&quot;china&quot;,&quot;birthday&quot;:[{},&quot;2010-11-22&quot;]}}</p>
<p>JSON的转换和XML的转换用法一样，只是创建XStream需要传递一个参数，这个参数就是xml到JSON映射转换的驱动。这里会降到两个驱动，分别是JettisonMappedXmlDriver、JsonHierarchicalStreamDriver。</p>
<p>2、 JsonHierarchicalStreamDriver完成Java对象到JSON的转换
//<em>/</em></p>
<p>/<em> <b>function:</b>用XStream结合JsonHierarchicalStreamDriver驱动
/</em> 转换java对象为JSON字符串</p>
<p>/<em> @author hoojo
/</em> @createDate Nov 27, 2010 1:16:46 PM</p>
<p>/*/
@Test</p>
<p>public void writeEntiry2JSON() {
failRed(&quot;======JsonHierarchicalStreamDriver====JavaObject &gt;&gt;&gt;&gt; JaonString=========&quot;);</p>
<p>xstream = new XStream(new JsonHierarchicalStreamDriver());
//xstream.setMode(XStream.NO_REFERENCES);</p>
<p>xstream.alias(&quot;student&quot;, Student.class);
failRed(&quot;-------Object &gt;&gt;&gt;&gt; JSON---------&quot;);</p>
<p>fail(xstream.toXML(bean));
//failRed(&quot;========JsonHierarchicalStreamDriver==删除根节点=========&quot;);</p>
<p>//删除根节点
xstream = new XStream(new JsonHierarchicalStreamDriver() {</p>
<p>public HierarchicalStreamWriter createWriter(Writer out) {
return new JsonWriter(out, JsonWriter.DROP_ROOT_MODE);</p>
<p>}
});</p>
<p>//xstream.setMode(XStream.NO_REFERENCES);
xstream.alias(&quot;student&quot;, Student.class);</p>
<p>fail(xstream.toXML(bean));
}</p>
<p>运行后结果如下：</p>
<p>======JsonHierarchicalStreamDriver====JavaObject &gt;&gt;&gt;&gt; JaonString=========</p>
<p>-------Object &gt;&gt;&gt;&gt; JSON---------
{&quot;student&quot;: {</p>
<p>&quot;id&quot;: 1,
&quot;name&quot;: &quot;jack&quot;,</p>
<p>&quot;email&quot;: &quot;jack@email.com&quot;,
&quot;address&quot;: &quot;china&quot;,</p>
<p>&quot;birthday&quot;: {
&quot;birthday&quot;: &quot;2010-11-22&quot;</p>
<p>}
}}</p>
<p>{
&quot;id&quot;: 1,</p>
<p>&quot;name&quot;: &quot;jack&quot;,
&quot;email&quot;: &quot;jack@email.com&quot;,</p>
<p>&quot;address&quot;: &quot;china&quot;,
&quot;birthday&quot;: {</p>
<p>&quot;birthday&quot;: &quot;2010-11-22&quot;
}</p>
<p>}</p>
<p>使用JsonHierarchicalStreamDriver转换默认会给转换后的对象添加一个根节点，但是在构建JsonHierarchicalStreamDriver驱动的时候，你可以重写createWriter方法，删掉根节点。</p>
<p>看上面的结果，一个是默认带根节点的JSON对象，它只是将类名作为一个属性，将对象作为该属性的一个值。而另一个没有带根属性的JSON就是通过重写createWriter方法完成的。</p>
<p>3、 将List集合转换成JSON字符串
@Test</p>
<p>public void writeList2JSON() {
failRed(&quot;======JsonHierarchicalStreamDriver====JavaObject &gt;&gt;&gt;&gt; JaonString=========&quot;);</p>
<p>JsonHierarchicalStreamDriver driver = new JsonHierarchicalStreamDriver();
xstream = new XStream(driver);</p>
<p>//xstream = new XStream(new JettisonMappedXmlDriver());//转换错误
//xstream.setMode(XStream.NO_REFERENCES);</p>
<p>xstream.alias(&quot;student&quot;, Student.class);
List<Student> list = new ArrayList<Student>();</p>
<p>list.add(bean);//add
bean = new Student();</p>
<p>bean.setAddress(&quot;china&quot;);
bean.setEmail(&quot;tom@125.com&quot;);</p>
<p>bean.setId(2);
bean.setName(&quot;tom&quot;);</p>
<p>Birthday day = new Birthday(&quot;2010-11-22&quot;);
bean.setBirthday(day);</p>
<p>list.add(bean);//add
bean = new Student();</p>
<p>bean.setName(&quot;jack&quot;);
list.add(bean);//add</p>
<p>fail(xstream.toXML(list));
//failRed(&quot;========JsonHierarchicalStreamDriver==删除根节点=========&quot;);</p>
<p>//删除根节点
xstream = new XStream(new JsonHierarchicalStreamDriver() {</p>
<p>public HierarchicalStreamWriter createWriter(Writer out) {
return new JsonWriter(out, JsonWriter.DROP_ROOT_MODE);</p>
<p>}
});</p>
<p>xstream.alias(&quot;student&quot;, Student.class);
fail(xstream.toXML(list));</p>
<p>}</p>
<p>运行后结果如下</p>
<p>======JsonHierarchicalStreamDriver====JavaObject &gt;&gt;&gt;&gt; JaonString=========</p>
<p>/#/#{&quot;list&quot;: [
{</p>
<p>&quot;id&quot;: 1,
&quot;name&quot;: &quot;jack&quot;,</p>
<p>&quot;email&quot;: &quot;jack@email.com&quot;,
&quot;address&quot;: &quot;china&quot;,</p>
<p>&quot;birthday&quot;: {
&quot;birthday&quot;: &quot;2010-11-22&quot;</p>
<p>}
},</p>
<p>{
&quot;id&quot;: 2,</p>
<p>&quot;name&quot;: &quot;tom&quot;,
&quot;email&quot;: &quot;tom@125.com&quot;,</p>
<p>&quot;address&quot;: &quot;china&quot;,
&quot;birthday&quot;: {</p>
<p>&quot;birthday&quot;: &quot;2010-11-22&quot;
}</p>
<p>},
{</p>
<p>&quot;id&quot;: 0,
&quot;name&quot;: &quot;jack&quot;</p>
<p>}
]}</p>
<p>/#[
{</p>
<p>&quot;id&quot;: 1,
&quot;name&quot;: &quot;jack&quot;,</p>
<p>&quot;email&quot;: &quot;jack@email.com&quot;,
&quot;address&quot;: &quot;china&quot;,</p>
<p>&quot;birthday&quot;: {
&quot;birthday&quot;: &quot;2010-11-22&quot;</p>
<p>}
},</p>
<p>{
&quot;id&quot;: 2,</p>
<p>&quot;name&quot;: &quot;tom&quot;,
&quot;email&quot;: &quot;tom@125.com&quot;,</p>
<p>&quot;address&quot;: &quot;china&quot;,
&quot;birthday&quot;: {</p>
<p>&quot;birthday&quot;: &quot;2010-11-22&quot;
}</p>
<p>},
{</p>
<p>&quot;id&quot;: 0,
&quot;name&quot;: &quot;jack&quot;</p>
<p>}
]</p>
<p>上面的list1是使用JsonHierarchicalStreamDriver 转换的，当然你也可以使用JettisonMappedXmlDriver驱动进行转换；用JettisonMappedXmlDriver转换后，你会发现格式不同而且没有根属性。</p>
<p>4、 Map转换json
@Test</p>
<p>public void writeMap2JSON() {
failRed(&quot;======JsonHierarchicalStreamDriver==== Map &gt;&gt;&gt;&gt; JaonString=========&quot;);</p>
<p>xstream = new XStream(new JsonHierarchicalStreamDriver());
//xstream = new XStream(new JettisonMappedXmlDriver());</p>
<p>xstream.alias(&quot;student&quot;, Student.class);
Map<String, Student> map = new HashMap<String, Student>();</p>
<p>map.put(&quot;No.1&quot;, bean);//put
bean = new Student();</p>
<p>bean.setAddress(&quot;china&quot;);
bean.setEmail(&quot;tom@125.com&quot;);</p>
<p>bean.setId(2);
bean.setName(&quot;tom&quot;);</p>
<p>bean.setBirthday(new Birthday(&quot;2010-11-21&quot;));
map.put(&quot;No.2&quot;, bean);//put</p>
<p>bean = new Student();
bean.setName(&quot;jack&quot;);</p>
<p>map.put(&quot;No.3&quot;, bean);//put
fail(xstream.toXML(map));</p>
<p>//failRed(&quot;========JsonHierarchicalStreamDriver==删除根节点=========&quot;);
//删除根节点</p>
<p>xstream = new XStream(new JsonHierarchicalStreamDriver() {
public HierarchicalStreamWriter createWriter(Writer out) {</p>
<p>return new JsonWriter(out, JsonWriter.DROP_ROOT_MODE);
}</p>
<p>});
xstream.alias(&quot;student&quot;, Student.class);</p>
<p>fail(xstream.toXML(map));
}</p>
<p>运行后结果如下：</p>
<p>======JsonHierarchicalStreamDriver==== Map &gt;&gt;&gt;&gt; JaonString=========</p>
<p>{&quot;map&quot;: [
[</p>
<p>&quot;No.3&quot;,
{</p>
<p>&quot;id&quot;: 0,
&quot;name&quot;: &quot;jack&quot;</p>
<p>}
],</p>
<p>[
&quot;No.1&quot;,</p>
<p>{
&quot;id&quot;: 1,</p>
<p>&quot;name&quot;: &quot;jack&quot;,
&quot;email&quot;: &quot;jack@email.com&quot;,</p>
<p>&quot;address&quot;: &quot;china&quot;,
&quot;birthday&quot;: {</p>
<p>&quot;birthday&quot;: &quot;2010-11-22&quot;
}</p>
<p>}
],</p>
<p>[
&quot;No.2&quot;,</p>
<p>{
&quot;id&quot;: 2,</p>
<p>&quot;name&quot;: &quot;tom&quot;,
&quot;email&quot;: &quot;tom@125.com&quot;,</p>
<p>&quot;address&quot;: &quot;china&quot;,
&quot;birthday&quot;: {</p>
<p>&quot;birthday&quot;: &quot;2010-11-21&quot;
}</p>
<p>}
]</p>
<p>]}
[</p>
<p>[
&quot;No.3&quot;,</p>
<p>{
&quot;id&quot;: 0,</p>
<p>&quot;name&quot;: &quot;jack&quot;
}</p>
<p>],
[</p>
<p>&quot;No.1&quot;,
{</p>
<p>&quot;id&quot;: 1,
&quot;name&quot;: &quot;jack&quot;,</p>
<p>&quot;email&quot;: &quot;jack@email.com&quot;,
&quot;address&quot;: &quot;china&quot;,</p>
<p>&quot;birthday&quot;: {
&quot;birthday&quot;: &quot;2010-11-22&quot;</p>
<p>}
}</p>
<p>],
[</p>
<p>&quot;No.2&quot;,
{</p>
<p>&quot;id&quot;: 2,
&quot;name&quot;: &quot;tom&quot;,</p>
<p>&quot;email&quot;: &quot;tom@125.com&quot;,
&quot;address&quot;: &quot;china&quot;,</p>
<p>&quot;birthday&quot;: {
&quot;birthday&quot;: &quot;2010-11-21&quot;</p>
<p>}
}</p>
<p>]
]</p>
<p>5、 将JSON转换java对象</p>
<p>//<em>/</em></p>
<p>/<em> <b>function:</b>JsonHierarchicalStreamDriver可以将简单的json字符串转换成java对象，list、map转换不成功；
/</em> JsonHierarchicalStreamDriver读取JSON字符串到java对象出错</p>
<p>/<em> @author hoojo
/</em> @createDate Nov 27, 2010 1:22:26 PM</p>
<p>/<em> @throws JSONException
/</em>/</p>
<p>@Test
public void readJSON2Object() throws JSONException {</p>
<p>String json = &quot;{\&quot;student\&quot;: {&quot; +
&quot;\&quot;id\&quot;: 1,&quot; +</p>
<p>&quot;\&quot;name\&quot;: \&quot;haha\&quot;,&quot; +
&quot;\&quot;email\&quot;: \&quot;email\&quot;,&quot; +</p>
<p>&quot;\&quot;address\&quot;: \&quot;address\&quot;,&quot; +
&quot;\&quot;birthday\&quot;: {&quot; +</p>
<p>&quot;\&quot;birthday\&quot;: \&quot;2010-11-22\&quot;&quot; +
&quot;}&quot; +</p>
<p>&quot;}}&quot;;
//JsonHierarchicalStreamDriver读取JSON字符串到java对象出错，但JettisonMappedXmlDriver可以</p>
<p>xstream = new XStream(new JettisonMappedXmlDriver());
xstream.alias(&quot;student&quot;, Student.class);</p>
<p>fail(xstream.fromXML(json).toString());
//JettisonMappedXmlDriver转换List集合出错，但JsonHierarchicalStreamDriver可以转换正确</p>
<p>//JettisonMappedXmlDriver 转换的字符串 {&quot;list&quot;:{&quot;student&quot;:[{&quot;id&quot;:1,&quot;name&quot;:&quot;haha&quot;,&quot;email&quot;:&quot;email&quot;,&quot;address&quot;:&quot;address&quot;,&quot;birthday&quot;:[{},&quot;2010-11-22&quot;]}]},&quot;student&quot;:{&quot;id&quot;:2,&quot;name&quot;:&quot;tom&quot;,&quot;email&quot;:&quot;tom@125.com&quot;,&quot;address&quot;:&quot;china&quot;,&quot;birthday&quot;:[{},&quot;2010-11-22&quot;]}}
json = &quot;{\&quot;list\&quot;: [{&quot; +</p>
<p>&quot;\&quot;id\&quot;: 1,&quot; +
&quot;\&quot;name\&quot;: \&quot;haha\&quot;,&quot; +</p>
<p>&quot;\&quot;email\&quot;: \&quot;email\&quot;,&quot; +
&quot;\&quot;address\&quot;: \&quot;address\&quot;,&quot; +</p>
<p>&quot;\&quot;birthday\&quot;: {&quot; +
&quot;\&quot;birthday\&quot;: \&quot;2010-11-22\&quot;&quot; +</p>
<p>&quot;}&quot; +
&quot;},{&quot; +</p>
<p>&quot;\&quot;id\&quot;: 2,&quot; +
&quot;\&quot;name\&quot;: \&quot;tom\&quot;,&quot; +</p>
<p>&quot;\&quot;email\&quot;: \&quot;tom@125.com\&quot;,&quot; +
&quot;\&quot;address\&quot;: \&quot;china\&quot;,&quot; +</p>
<p>&quot;\&quot;birthday\&quot;: {&quot; +
&quot;\&quot;birthday\&quot;: \&quot;2010-11-22\&quot;&quot; +</p>
<p>&quot;}&quot; +
&quot;}]}&quot;;</p>
<p>System.out.println(json);//用js转换成功
List list = (List) xstream.fromXML(json);</p>
<p>System.out.println(list.size());//0好像转换失败
}</p>
<p>运行后结果如下：</p>
<p>haha/#1/#address/#2010-11-22/#email</p>
<p>{&quot;list&quot;: [{&quot;id&quot;: 1,&quot;name&quot;: &quot;haha&quot;,&quot;email&quot;: &quot;email&quot;,&quot;address&quot;: &quot;address&quot;,&quot;birthday&quot;: {&quot;birthday&quot;: &quot;2010-11-22&quot;}},
{&quot;id&quot;: 2,&quot;name&quot;: &quot;tom&quot;,&quot;email&quot;: &quot;tom@125.com&quot;,&quot;address&quot;: &quot;china&quot;,&quot;birthday&quot;: {&quot;birthday&quot;: &quot;2010-11-22&quot;}}]}</p>
<p>0</p>
<p>JSON到Java的转换是fromXML方法。</p>
<p>作者：<a href="http://hoojo.cnblogs.com/" target="_blank">hoojo</a></p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/xml/">xml</a></li></span><span class="breadcrumb"><li><a href="/categories/xml/">xml</a></li><li><a href="/categories/xml/xstream/">xstream</a></li></span></span> | <span class="tags">Tagged <a href="/tags/xml/" class="label label-primary">xml</a><a href="/tags/xstream/" class="label label-success">xstream</a></span> | <span class="time">recent updated:<time title="2014-04-07 16:47:11"datetime="2014-04-07 16:47:11"> abr. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-xml-xstream--xStream完美转换XML、JSON/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-xml-xstream--xStream完美转换XML、JSON" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-xml-xstream--使用XStream序列化、反序列化XML数据时遇到的各种问题/">使用XStream序列化、反序列化XML数据时遇到的各种问题</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:44.000Z"> <a href="/2014/02/02/2014-02-02-xml-xstream--使用XStream序列化、反序列化XML数据时遇到的各种问题/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-xstream-xml-">使用XStream序列化、反序列化XML数据时遇到的各种问题</h1>
<p>现在参与的项目是一个纯Application Server，整个Server都是自己搭建的，使用JMS消息实现客户端和服务器的交互，交互的数据格式采用XML。说来惭愧，开始为了赶进度，所有XML消息都是使用字符串拼接的，而XML的解析则是使用DOM方式查找的。我很早就看这些代码不爽了，可惜一直没有时间去重构，最近项目加了几个人，而且美国那边也开始渐渐的把这个项目开发的控制权交给我们了，所以我开始有一些按自己的方式开发的机会了。因而最近动手开始重构这些字符串拼接的代码。</p>
<p>对XML到Java Bean的解析框架，熟悉一点的只有Digester和XStream，Digester貌似只能从XML文件解析成Java Bean对象，所以只能选择XStream来做了，而且同组的其他项目也有在用XStream。一直听说XStream的使用比较简单，而且我对ThoughtWorks这家公司一直比较有好感，所以还以为引入XStream不会花太多时间，然而使用以后才发现XStream并没有想象的你那么简单。不过这个也有可能是因为我不想改变原来的XML数据格式，而之前的XML数据格式的设计自然不会考虑到如何便利的使用XStream。因而记录在使用过程中遇到的问题，供后来人参考，也为自己以后如果打算开其源码提供参考。废话就到这里了，接下来步入正题。</p>
<p>首先对于简单的引用，XStream使用起来确实比较简单，比如自定义标签的属性、使用属性和使用子标签的定义等：
@XStreamAlias(&quot;request&quot;)
public class XmlRequest1 {
    private static XStream xstream;
    static {
        xstream = new XStream();
        xstream.autodetectAnnotations(true);
    }</p>
<pre><code>@XStreamAsAttribute
private String from;

@XStreamAsAttribute
@XStreamAlias(&quot;calculate-method&quot;)
private String calculateMethod;

@XStreamAlias(&quot;request-time&quot;)
private Date requestTime;

@XStreamAlias(&quot;input-files&quot;)
private List&lt;InputFileInfo&gt; inputFiles;

public static String toXml(XmlRequest1 request) {
    StringWriter writer = new StringWriter();
    writer.append(Constants.XML_HEADER);
    xstream.toXML(request, writer);
    return writer.toString();
}
public static XmlRequest1 toInstance(String xmlContent) {
    return (XmlRequest1)xstream.fromXML(xmlContent);
</code></pre><p>}
<img src="" alt="">
    @XStreamAlias(&quot;input-file&quot;)
    public static class InputFileInfo {
        private String type;
        private String fileName;
        <img src="" alt="">
    }
    public static void main(String[] args) {
        XmlRequest1 request = buildXmlRequest();
        System.out.println(XmlRequest1.toXml(request));
    }
    private static XmlRequest1 buildXmlRequest() {
        <img src="" alt="">
    }
}</p>
<p> 对以上Request定义，我们可以得到如下结果：</p>
<p>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</p>
<request from="levin@host" calculate-method="advanced">
 <request-time>2012-11-28 17:11:54.664 UTC</request-time>
 <input-files>
    <input-file>
      <type>DATA</type>
      <fileName>data.2012.11.29.dat</fileName>
    </input-file>
    <input-file>
      <type>CALENDAR</type>
      <fileName>calendar.2012.11.29.dat</fileName>
    </input-file>
 </input-files>
</request>

<p>可惜这个世界不会那么清净，这个格式有些时候貌似并不符合要求，比如request-time的格式、input-files的格式，我们实际需要的格式是这样的：</p>
<p>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</p>
<request from="levin@host" calculate-method="advanced">
 <request-time>20121128T17:51:05</request-time>
 <input-file type="DATA">data.2012.11.29.dat</input-file>
 <input-file type="CALENDAR">calendar.2012.11.29.dat</input-file>
</request>

<p>对不同Date格式的支持可以是用Converter实现，在XStream中默认使用自己实现的DateConverter，它支持的格式是：yyyy-MM-dd HH:mm:ss.S &#39;UTC&#39;，然而我们现在需要的格式是yyyy-MM-dd’T’HH:mm:ss，如果使用XStream直接注册DateConverter，可以使用配置自己的DateConverter，但是由于DateConverter的构造函数的定义以及@XStreamConverter的构造函数参数的支持方式的限制，貌似DateConverter不能很好的支持注解方式的注册，因而我时间了一个自己的DateConverter以支持注解：</p>
<p>public class LevinDateConverter extends DateConverter {
    public LevinDateConverter(String dateFormat) {
        super(dateFormat, new String[] { dateFormat });
    }
}</p>
<p>在requestTime字段中需要加入以下注解定义：</p>
<p>@XStreamConverter(value=LevinDateConverter.class, strings={&quot;yyyyMMdd&#39;T&#39;HH:mm:ss&quot;})
@XStreamAlias(&quot;request-time&quot;)
private Date requestTime;</p>
<p>对集合类，XStream提供了@XStreamImplicit注解，以将集合中的内容摊平到上一层XML元素中，其中itemFieldName的值为其使用的标签名，此时InputFileInfo类中不需要@XStreamAlias标签的定义：</p>
<p>@XStreamImplicit(itemFieldName=&quot;input-file&quot;)
private List<InputFileInfo> inputFiles;</p>
<p>对InputFileInfo中的字段，type作为属性很容易，只要为它加上@XStreamAsAttribute注解即可，而将fileName作为input-file标签的一个内容字符串，则需要使用ToAttributedValueConverter，其中Converter的参数为需要作为字符串内容的字段名：</p>
<p>@XStreamConverter(value=ToAttributedValueConverter.class, strings={&quot;fileName&quot;})
public static class InputFileInfo {
    @XStreamAsAttribute
    private String type;
private String fileName;
<img src="" alt="">
}</p>
<p>XStream对枚举类型的支持貌似不怎么好，默认注册的EnumSingleValueConverter只是使用了Enum提供的name()和静态的valueOf()方法将enum转换成String或将String转换回enum。然而有些时候XML的字符串和类定义的enum值并不完全匹配，最常见的就是大小写的不匹配，此时需要写自己的Converter。在这种情况下，我一般会在enum中定义一个name属性，这样就可以自定义enum的字符串表示。比如有TimePeriod的enum：</p>
<p>public enum TimePeriod {
    MONTHLY(&quot;monthly&quot;), WEEKLY(&quot;weekly&quot;), DAILY(&quot;daily&quot;);</p>
<pre><code>private String name;

public String getName() {
    return name;
}

private TimePeriod(String name) {
    this.name = name;
}

public static TimePeriod toEnum(String timePeriod) {
    try {
        return Enum.valueOf(TimePeriod.class, timePeriod);
    } catch(Exception ex) {
        for(TimePeriod period : TimePeriod.values()) {
            if(period.getName().equalsIgnoreCase(timePeriod)) {
                return period;
            }
        }
        throw new IllegalArgumentException(&quot;Cannot convert &lt;&quot; + timePeriod + &quot;&gt; to TimePeriod enum&quot;);
    }
}
</code></pre><p>}</p>
<p>我们可以编写以下Converter以实现对枚举类型的更宽的容错性：</p>
<p>public class LevinEnumSingleNameConverter extends EnumSingleValueConverter {
    private static final String CUSTOM_ENUM_NAME_METHOD = &quot;getName&quot;;
    private static final String CUSTOM_ENUM_VALUE_OF_METHOD = &quot;toEnum&quot;;</p>
<pre><code>private Class&lt;? extends Enum&lt;?&gt;&gt; enumType;

public LevinEnumSingleNameConverter(Class&lt;? extends Enum&lt;?&gt;&gt; type) {
    super(type);
    this.enumType = type;
}

@Override
public String toString(Object obj) {
    Method method = getCustomEnumNameMethod();
    if(method == null) {
        return super.toString(obj);
    } else {
        try {
            return (String)method.invoke(obj, (Object[])null);
        } catch(Exception ex) {
            return super.toString(obj);
        }
    }
}

@Override
public Object fromString(String str) {
    Method method = getCustomEnumStaticValueOfMethod();
    if(method == null) {
        return enhancedFromString(str);
    }
    try {
        return method.invoke(null, str);
    } catch(Exception ex) {
        return enhancedFromString(str);
    }
}

private Method getCustomEnumNameMethod() {
    try {
        return enumType.getMethod(CUSTOM_ENUM_NAME_METHOD, (Class&lt;?&gt;[])null);
    } catch(Exception ex) {
        return null;
    }
}

private Method getCustomEnumStaticValueOfMethod() {
    try {
        Method method = enumType.getMethod(CUSTOM_ENUM_VALUE_OF_METHOD, (Class&lt;?&gt;[])null);
        if(method.getModifiers() == Modifier.STATIC) {
            return method;
        }
        return null;
    } catch(Exception ex) {
        return null;
    }
}

private Object enhancedFromString(String str) {
    try {
        return super.fromString(str);
    } catch(Exception ex) {
        for(Enum&lt;?&gt; item : enumType.getEnumConstants()) {
            if(item.name().equalsIgnoreCase(str)) {
                return item;
            }
        }
        throw new IllegalStateException(&quot;Cannot converter &lt;&quot; + str + &quot;&gt; to enum &lt;&quot; + enumType + &quot;&gt;&quot;);
    }
}
</code></pre><p>}</p>
<p>如下方式使用即可：</p>
<p>@XStreamAsAttribute
@XStreamAlias(&quot;time-period&quot;)
@XStreamConverter(value=LevinEnumSingleNameConverter.class)
private TimePeriod timePeriod;</p>
<p>对double类型，貌似默认的DoubleConverter实现依然不给力，它不支持自定义的格式，比如我们想在序列化的时候用一下格式：” /#/#/#,/#/#0.0/#/#/#/#/#/#/#/#”，此时又需要编写自己的Converter：</p>
<p>public class FormatableDoubleConverter extends DoubleConverter {
    private String pattern;
    private DecimalFormat formatter;</p>
<pre><code>public FormatableDoubleConverter(String pattern) {
    this.pattern = pattern;
    this.formatter = new DecimalFormat(pattern);
}

@Override
public String toString(Object obj) {
    if(formatter == null) {
        return super.toString(obj);
    } else {
        return formatter.format(obj);
    }
}

@Override
public Object fromString(String str) {
    try {
        return super.fromString(str);
    } catch(Exception ex) {
        if(formatter != null) {
            try {
                return formatter.parse(str);
            } catch(Exception e) {
                throw new IllegalArgumentException(&quot;Cannot parse &lt;&quot; + str + &quot;&gt; to double value&quot;, e);
            }
        }
        throw new IllegalArgumentException(&quot;Cannot parse &lt;&quot; + str + &quot;&gt; to double value&quot;, ex);
    }
}

public String getPattern() {
    return pattern;
}
</code></pre><p>}</p>
<p>使用方式和之前的Converter类似：</p>
<p>@XStreamAsAttribute
@XStreamConverter(value=FormatableDoubleConverter.class, strings={&quot;/#/#/#,/#/#0.0/#/#/#/#/#/#/#/#&quot;})
private double value;</p>
<p>最后，还有两个XStream没法实现的，或者说我没有找到一个更好的实现方式的场景。<strong>第一种场景是**</strong>XStream<strong>**不能很好的处理对象组合问题：</strong></p>
<p>在面向对象编程中，一般尽量的倾向于抽取相同的数据成一个类，而通过组合的方式构建整个数据结构。比如Student类中有name、address，Address是一个类，它包含city、code、street等信息，此时如果要对Student对象做如下格式序列化：</p>
<student name=”Levin”>
 <city>shanghai</city>
 <street>zhangjiang</street>
 <code>201203</code>
</student>

<p>貌似我没有找到可以实现的方式，XStream能做是在中间加一层address标签。对这种场景的解决方案，一种是将Address中的属性平摊到Student类中，另一种是让Student继承自Address类。不过貌似这两种都不是比较理想的办法。</p>
<p><strong>第二种场景是XStream**</strong>不能很好的处理多态问题：**</p>
<p>比如我们有一个Trade类，它可能表示不同的产品：
public class Trade {
    private String tradeId;
    private Product product;
<img src="" alt="">
}
abstract class Product {
    private String name;
    public Product(String name) {
        this.name = name;
}
<img src="" alt="">
}
class FX extends Product {
    private double ratio;
    public FX() {
        super(&quot;fx&quot;);
    }
    <img src="" alt="">
}
class Future extends Product {
    private double maturity;
    public Future() {
        super(&quot;future&quot;);
    }
    <img src="" alt="">
}</p>
<p>通过一些简单的设置，我们能得到如下XML格式：</p>
<trades>
 <trade trade-id="001">
    <product class="levin.xstream.blog.FX" name="fx" ratio="0.59"/>
 </trade>
 <trade trade-id="002">
    <product class="levin.xstream.blog.Future" name="future" maturity="2.123"/>
 </trade>
</trades>

<p>作为数据文件，对Java类的定义显然是不合理的，因而简单一些，我们可以编写自己的Converter将class属性从product中去除：</p>
<p>xstream.registerConverter(new ProductConverter(
        xstream.getMapper(), xstream.getReflectionProvider()));</p>
<pre><code>public ProductConverter(Mapper mapper, ReflectionProvider reflectionProvider) {
    super(mapper, reflectionProvider);
}

@Override
public boolean canConvert(@SuppressWarnings(&quot;rawtypes&quot;) Class type) {
    return Product.class.isAssignableFrom(type);
}

@Override
protected Object instantiateNewInstance(HierarchicalStreamReader reader, UnmarshallingContext context) {
    Object currentObject = context.currentObject();
    if(currentObject != null) {
        return currentObject;
    }

    String name = reader.getAttribute(&quot;name&quot;);
    if(&quot;fx&quot;.equals(name)) {
        return reflectionProvider.newInstance(FX.class);
    } else if(&quot;future&quot;.equals(name)) {
        return reflectionProvider.newInstance(Future.class);
    }
    throw new IllegalStateException(&quot;Cannot convert &lt;&quot; + name + &quot;&gt; product&quot;);
}
</code></pre><p>}</p>
<p>在所有Production上定义@XStreamAlias(“product”)注解。这时的XML输出结果为：</p>
<trades>
 <trade trade-id="001">
    <product name="fx" ratio="0.59"/>
 </trade>
 <trade trade-id="002">
    <product name="future" maturity="2.123"/>
 </trade>
</trades>

<p>然而如果有人希望XML的输出结果如下呢?</p>
<trades>
 <trade trade-id="001">
    <fx ratio="0.59"/>
 </trade>
 <trade trade-id="002">
    <future maturity="2.123"/>
 </trade>
</trades>

<p>大概找了一下，可能可以定义自己的Mapper来解决，不过XStream的源码貌似比较复杂，没有时间深究这个问题，留着以后慢慢解决吧。</p>
<p><strong>补充：</strong></p>
<p>对Map类型数据，XStream默认使用以下格式显示：</p>
<map class="linked-hash-map">
    <entry>
      <string>key1</string>
      <string>value1</string>
    </entry>
    <entry>
      <string>key2</string>
      <string>value2</string>
    </entry>
 </map>



<p>但是对一些简单的Map，我们希望如下显示：
 <map>
    <entry key="key1" value="value1"/>
    <entry key="key2" value="value2"/>
 </map></p>
<p>对这种需求需要通过编写Converter解决，继承自MapConverter，覆盖以下函数，这里的Map默认key和value都是String类型，如果他们不是String类型，需要另外添加逻辑：
@SuppressWarnings(&quot;rawtypes&quot;)
@Override
public void marshal(Object source, HierarchicalStreamWriter writer,
        MarshallingContext context) {
    Map map = (Map) source;
    for (Iterator iterator = map.entrySet().iterator(); iterator.hasNext();) {
        Entry entry = (Entry) iterator.next();
        ExtendedHierarchicalStreamWriterHelper.startNode(writer, mapper()
                .serializedClass(Map.Entry.class), entry.getClass());</p>
<pre><code>    writer.addAttribute(&quot;key&quot;, entry.getKey().toString());
    writer.addAttribute(&quot;value&quot;, entry.getValue().toString());
    writer.endNode();
}
</code></pre><p>}</p>
<p>@Override
@SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
protected void putCurrentEntryIntoMap(HierarchicalStreamReader reader,
        UnmarshallingContext context, Map map, Map target) {
    Object key = reader.getAttribute(&quot;key&quot;);
    Object value = reader.getAttribute(&quot;value&quot;);</p>
<pre><code>target.put(key, value);
</code></pre><p>}</p>
<p>但是只是使用Converter，得到的结果多了一个class属性：
 <map class="linked-hash-map">
    <entry key="key1" value="value1"/>
    <entry key="key2" value="value2"/>
 </map></p>
<p>在XStream中，如果定义的字段是一个父类或接口，在序列化是会默认加入class属性以确定反序列化时用的类，为了去掉这个class属性，可以定义默认的实现类来解决（虽然感觉这种解决方案不太好，但是目前还没有找到更好的解决方案）。</p>
<p><em>*
</em>xstream.addDefaultImplementation(LinkedHashMap.class, Map.class);*</p>
<p>来源： <a href="[http://www.blogjava.net/DLevin/archive/2012/11/30/392240.html](http://www.blogjava.net/DLevin/archive/2012/11/30/392240.html)">[http://www.blogjava.net/DLevin/archive/2012/11/30/392240.html](http://www.blogjava.net/DLevin/archive/2012/11/30/392240.html)</a></p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/xml/">xml</a></li></span><span class="breadcrumb"><li><a href="/categories/xml/">xml</a></li><li><a href="/categories/xml/xstream/">xstream</a></li></span></span> | <span class="tags">Tagged <a href="/tags/xml/" class="label label-primary">xml</a><a href="/tags/xstream/" class="label label-success">xstream</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:44"datetime="2014-03-07 09:54:44"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-xml-xstream--使用XStream序列化、反序列化XML数据时遇到的各种问题/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-xml-xstream--使用XStream序列化、反序列化XML数据时遇到的各种问题" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-TCPIP--TCPIP传输层，你懂多少？--ITeye技术网站/">TCP IP传输层，你懂多少？ </a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:44.000Z"> <a href="/2014/02/02/2014-02-02-TCPIP--TCPIP传输层，你懂多少？--ITeye技术网站/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="tcp-ip-iteye-">TCP IP传输层，你懂多少？ - - ITeye技术网站</h1>
<p><a href="http://www.iteye.com/" target="_blank">首页</a> <a href="http://www.iteye.com/news" target="_blank">新闻</a> <a href="http://www.iteye.com/forums" target="_blank">论坛</a> <a href="http://www.iteye.com/ask" target="_blank">问答</a> <a href="http://www.iteye.com/blogs" target="_blank">博客</a> <a href="http://www.iteye.com/job" target="_blank">招聘</a> <a href="http://java-mzd.iteye.com/blog/1007577#" target="_blank">更多 ▼</a></p>
<p><a href="http://www.iteye.com/wiki" target="_blank">专栏</a>  <a href="http://www.iteye.com/groups" target="_blank">群组</a> <a href="http://www.iteye.com/search" target="_blank">搜索</a></p>
<p><a href="http://java-mzd.iteye.com/login" title="登录" target="_blank">您还未登录 !</a> <a href="http://www.iteye.com/all" target="_blank">我的应用</a> <a href="http://java-mzd.iteye.com/login" target="_blank">登录</a> <a href="http://java-mzd.iteye.com/signup" target="_blank">注册</a></p>
<h1 id="-java-mzd-http-java-mzd-iteye-com-"><a href="http://java-mzd.iteye.com/" target="_blank">java-mzd</a></h1>
<p>永久域名 <a href="http://java-mzd.iteye.com/" target="_blank"><a href="http://java-mzd.iteye.com">http://java-mzd.iteye.com</a></a></p>
<p><a href="http://java-mzd.iteye.com/blog/1007577#" target="_blank">141顶</a>
<a href="http://java-mzd.iteye.com/blog/1007577#" target="_blank">25踩</a></p>
<p><a href="http://java-mzd.iteye.com/blog/1019088" title="TCP/IP网络层谜云" target="_blank">TCP/IP网络层谜云</a> | <a href="http://java-mzd.iteye.com/blog/1005945" title="Jpcap简易教程" target="_blank">Jpcap简易教程</a></p>
<p>2011-04-19</p>
<h3 id="-tcp-ip-"><a href="">TCP/IP传输层，你懂多少？</a></h3>
<p><strong>文章分类:<a href="http://www.iteye.com/blogs/category/tech" target="_blank">综合技术</a></strong></p>
<p>你所不知道的传输层
题记：23页的文档上，满满当当的写满了笔记，纸质的东西，始终害怕丢失，还是选择把它总结到博客上来。</p>
<p>PS.老规矩，列出可能遇到的20个问题，如果您是都能回答的高手，请您绕道，我是小菜，只做自己的学习笔记。</p>
<ol>
<li>传输层的主要功能是什么？</li>
<li>传输层如何区分不同应用程序的数据流？</li>
<li>传输层有哪些协议？</li>
<li>什么是UDP协议？</li>
<li>为什么有了UDP，还需要TCP？</li>
<li>什么是TCP协议？</li>
<li>怎么理解协议和程序？</li>
<li>TCP是否真的有链接？</li>
<li>链接是如何建立的（逻辑上）？</li>
<li>所谓的建立TCP链接开销很大，具体是指什么？</li>
<li>三次握手的目的是什么？</li>
<li>TCP如何提供可靠性？</li>
<li>什么是预期确认？什么是肯定确认与重新传输？哪些情况会重传？</li>
<li>TCP中，序列号和应答号有哪些作用？</li>
<li>TCP链接中，网络失败，是怎么判断的？</li>
<li>为什么需要窗口技术？</li>
<li>如何实现流量控制？</li>
<li>UDP的开销很小，具体是指什么？</li>
<li>UDP数据包、TCP数据包大小如何确认？</li>
<li>UDP适合哪些环境？TCP适合哪些环境？</li>
</ol>
<hr>
<p><strong>一。传输层的主要功能是什么？</strong></p>
<p> 分割并重新组装上层提供的数据流，为数据流提供端到端的传输服务。</p>
<p><strong>二。传输层如何区分不同应用程序的数据流？</strong></p>
<hr>
<p>因为，对应传输层而言，它只需要知道目标主机上的哪个服务程序来响应这个程序，而不需要知道这个服务程序是干什么的。因此，我们只需要能够抽象的表示出来这些应用程序和服务程序即可。我们使用端口号来抽象标识每个网络程序。</p>
<p><strong>传输层的TCP和UDP可以接收来自多个应用程序的数据流，用端口号标识他们，然后把他们送给Internet层处理；</strong></p>
<p><strong>同时TCP和UDP接收来自Internet层的数据包，用端口号区分他们，然后交给不同的应用程序。</strong></p>
<p><img src="" alt=""></p>
<p>因此：在同一IP地址（同一个目标主机）上不同的端口号是两个不同的链接。IP地址和端口号用来唯一的确定网络上数据的目的地。</p>
<p><strong>三。传输层有哪些协议？</strong></p>
<p><strong>**传输层的两大协议：TCP（传输控制协议）UDP（用户数据包协议）
</strong>TCP是一个可靠的面向链接的协议，UDP是不可靠的或者说无连接的协议。**
可以用打电话和发短信来说明这种关系：</p>
<p>UDP就好似发短信，只管发出去，至于对方是不是空号（网络不可到达）能不能收到（丢包）等并不关心。</p>
<p>TCP好像打电话，双方要通话，首先，要确定对方不是开机（网络可以到达），然后要确定是不是没有信号（），然后还需要对方接听（通信链接）。</p>
<hr>
<p><strong>四。什么是UDP协议？</strong></p>
<hr>
<p>UDP数据包结构如下图所示</p>
<p>源端口(16)</p>
<p>目标端口(16) 报文长度(16)</p>
<p>校验和(16) 数据（可变）</p>
<p>UDP为应用程序提供的是一种不可靠的、无连接的分组交付，因此，UDP报文可能会出现丢失、乱序、重复、延时等问题。
因为它不提供可靠性，它的开销很小。（<strong>开销很小具体指什么？</strong>下文揭秘）</p>
<hr>
<p><strong>五。为什么有了UDP，还需要TCP？</strong></p>
<p>问题4中已经说到，UDP为应用程序提供的是一种无连接、不可靠的分组交付。当网络硬件失效或者负担太重时，数据包可能就会产生丢失、重复、延时、乱序的现象。这些都会导致我们的通信不正常。如果让应用程序来担负差错控制的工作，无疑将给程序员带来许多复杂的工作，于是，我们使用独立的通信协议来保证通信的可靠性是非常必要的。</p>
<hr>
<p><strong>六。什么是TCP协议？</strong></p>
<p> 传输控制协议TCP是一个面向链接的、可靠的通信协议。</p>
<ol>
<li>在开始传输前，需要进行三次握手建立链接</li>
<li>可靠性：在传输过程中，通信双方的协议模块继续进行通信</li>
<li>通信结束后，通信双方都会使用改进的三次握手来关闭链接</li>
</ol>
<p>TCP数据包结构如下图</p>
<p>源端口(16)</p>
<p>目标端口(16) 序号(32) 应答号(32) 头长度(4)</p>
<p>保留(6)</p>
<p>编码位(6)</p>
<p>窗口(16) 校验和(16)</p>
<p>紧急(16) 可选项(如果有，0或32) 数据(可变)</p>
<p><strong>/<em>/</em>七。怎么理解协议和程序？/<em>/</em></strong></p>
<p>如同我们自定义的应用层协议一样：<strong>协议只是给出了一组规范，规定我们应该怎么样（按什么规则）保存数据。</strong></p>
<p>在计算机间传输的永远都是二进制字节码（对于传输层，可以理解为传输的始终是下层的IP数据包），<strong>是**</strong>计算机中的程序通过对这些字节码进行逻辑分析、判断，来控制程序完成差错控制等功能。**
至于解析这些字节码的程序，则可以有不同的实现，只要我们按照规则来解析，并作出相应的控制，我们大可以自己写个程序是实现相应功能。</p>
<p>知道了这些后，显然，我们也可以使用前面说的Jpcap，来自己实现一个基于Java的TCP或者UDP协议。可以参考Linux下的Tcp源码。</p>
<p>/net/ipv4/udp.c
/net/ipv4/datagram.c
/net/ipv4/tcp_input.c
/net/ipv4//tcp_output.c
/net/ipv4/tcp.c  </p>
<p><strong>八。TCP是否真的有链接？</strong></p>
<p>我们都知道，TCP通过完成三次握手来建立链接的，但是这种连接是面向虚电路的，是物理上不存在的，<strong>只是双方的TCP程序，逻辑上的认为建立了这样的链接**</strong>。 **</p>
<hr>
<p><strong>九。链接是如何建立的（逻辑上）？</strong></p>
<p>假设：当我们在主机A上启动一个程序，通过TCP去链接主机B上的9091端口。</p>
<p><img src="" alt="">
 整个过程是怎么样的呢？逻辑上我们可以这么理解建立链接的过程：</p>
<p>1.SYN:seq=X;</p>
<p>1.1 A的TCP程序，为这个链接分配一个端口（设为9090）。
1.2 同时<strong>逻辑上</strong>的将TCP连接的状态设置为：正在连接。（通过在链接状态表中添加一条记录，记录中状态为：正在连接）</p>
<p>猜想：</p>
<p>TCP程序中， 应该有张表来保持链接的状态，其中每个状态应该有：</p>
<p>本机地址（IP加port）、对方地址、链接状态</p>
<p>1.3 同时，随机生成一个初始序列号X，生成一个TCP包，将初始化序列号X设置为TCP中的序列号，发送给主机B。</p>
<p><strong>2.SYN:seq=Y ACK:ack=X+1;</strong></p>
<p>2.1 B上TCP程序收到该数据包，查询9091端口状态，如果可以链接。
2.2 同样的，在逻辑上的将TCP连接的状态设置为：正在连接
2.3 同时，随机生成一个初始化序列号Y，根据接收的序列号X，生成应答号X+1，生成一个TCP包，将序列号和应答号分别设置到TCP包头中，将TCP数据包发给主机A。</p>
<p><strong>3.SYN:seq=X+1 ACK:ack=Y+1.</strong></p>
<p>3.1  A上的TCP程序接收到数据包，查询9090端口状态。
3.2 根据收到的SYN:seq=Y;ACK:ack=X+1; 封装一个TCP包 SYN:seq=x+1;ACK:ack=Y+1;发送给主机B。同时，TCP程序将链接状态表中该条记录状态设置为已连接。
3.3 主机B收到数据包，TCP程序将链接状态表中该条记录状态设置为已连接。</p>
<p>至此，一个TCP链接建立（三次握手）完成。
我们可以看到：
第一：传送的都是IP数据包，其实只是将收到的数据包交给TCP程序处理。
第二：<strong>链接状态，只是TCP程序中的一个逻辑状态。</strong></p>
<p><strong>十：所谓的建立TCP链接开销很大，具体是指什么？</strong></p>
<p>从九中，很容易看出。要简历TCP链接，必须进行三次IP数据包的成功传输。</p>
<p><strong>十一：三次握手的目的是什么？</strong></p>
<p>TCP是面向链接的，在面向链接的环境中，开始传输数据之前，在两个中端之间必须先建立一个链接。建立链接的过程可以确保通信双方在发送应用程序数据包之前，都已经准备好了传送和接收数据。并且使通信双方统一了初始化序列号。</p>
<p>十二：TCP如何提供可靠性？</p>
<p><strong>在传输过程中，通信双方的协议模块继续进行通信，从而确保了传输的可靠性。</strong>
<strong>针对乱序：</strong>在通过三次握手进行链接时，序列号被初始化。在传输过程中，TCP继续使用这个序列号来标记发送的每一个数据段，没传送一个数据段，序列号加一。接收方依据序列号重装收到的数据段。
<strong>针对丢包</strong>：在传输过程中，接收方收到一个数据段后，会用ACK应答码向发送端回复一个IP包进行应答，确认号ACK用来告诉发送端哪些数据包已经成功接收，发送方对未被应答的报文段提供重传。
<strong>针对重复</strong>：接收端收到数据段后，查看序列号，如果已经成功接收改数据包，则丢弃后面这个数据段。
<strong>针对延时</strong>：延时造成的第一个问题，就是数据包达到接收端时乱序。
当延时严重时，接收端一直未收到数据段，则不会回复ACK，发送端认为丢包，重发。</p>
<p><strong>十三：什么是预期确认？什么是肯定确认与重新传输？哪些情况会重传？</strong></p>
<p>1.确认号ACK会告诉发送端哪些数据段已经成功接收，并且确认号会向发送端指出接收端希望收到的下一个序列号。即，确实号ACK为上个数据序列号+1，这种机制称为<strong>预期确认</strong>。</p>
<p>2.为了提高效率，我们在发送端，将数据段保存在缓冲区中，直道发送端收到来自接收端的确认号。这种机制被称为“<strong>肯定确认与重新传输</strong>”。</p>
<p>3.当<strong>发送端在给定时间间隔内收不到那个数据段的应答时，发送端就会重传那个数据段**</strong>。**
情况1：网络延时/环路，数据段丢失
情况2：网络延时，数据段推迟到达
情况3：数据段成功到达，应答因为1.2不能达到。</p>
<p><strong>十四： TCP中，序列号和应答号有哪些作用？</strong></p>
<p>从以上10,11,12中，很明显的可以看到</p>
<ol>
<li></li>
<li></li>
<li><p>依靠序列号重组数据段</p>
</li>
<li>依靠数据包消除网络中的重复包</li>
<li>依靠序列号和应答号进行差错重传，提高了TCP的可靠性</li>
</ol>
<p><strong>十六：为什么需要窗口技术？</strong></p>
<p>前面我们已经说了，TCP的可靠性，是通过预期确认来实现的。即发送方发送一个数据段后，需要得到对方的确认后，才会发送下一个数据段。
因此，假设一个数据段大小为64KB（IP包最大值），一次发送和确认需要的时间为500MS，则，1S内，只能传送128KB的数据，如果带宽为1M，显然很浪费带宽。为了充分利用带宽，我们使用窗口技术。滑动窗口允许发送方在收到接收方的确认之前发送多个数据段。（窗口大小决定了在收到确认前可以发送的数据段数量）</p>
<p><strong>十七：如何实现流量控制？</strong></p>
<p><strong>窗口数决定了当前传输的最大流量</strong>。当我们在传输过程中，通信双方可以根据网络条件动态协商窗口大小，调整窗口大小时，即可实现流量控制。（在TCP的每个确认中，除了ACK外，还包括一个窗口通知）</p>
<p><strong>十八：UDP的开销很小，具体是指什么？</strong></p>
<p>1.因为UDP是无连接的。在传输数据之前，不需要进行复杂的三次握手来建立连接。
2.在传输数据时，没有协议间通信流量（确认信号），也不需要浪费不必要的处理时间（接收确认信号再发一下）。
3；传输结束后，也不用再用改进的三次握手来端口连接。</p>
<p><strong>十九：UDP数据包、TCP数据包大小如何确认？</strong></p>
<ol>
<li></li>
<li><p>无论TCP还是UDP数据包，都需要交给Internet层封装为IP包，而一个IP包，包头中的长度位为16位，所以IP包最大为2的16方，即<strong>65535</strong>（64KB还需要减去各种包头长度）。</p>
</li>
<li>TCP因为面向流，且可以凭借序列号对大文件进行分段和重组，因此，<strong>TCP可以用来传输较大的文件</strong>。而UDP，如果要传输大于64KB的数据，则需要自己在应用层进行差错控制。</li>
<li>为了提高传输效率和减少网络通信量（协议间的通信），TCP也会一次传输足够多的数据。</li>
<li>因为MTU的存在，TCP包和UDP包不是越大越好。（在路由中分包，在接收端重组，加大路由与接收端负担，增大丢包概率。分组丢失，整个数据包重传。）</li>
</ol>
<p><strong>二十：UDP适用哪些环境？TCP适用哪些环境？</strong></p>
<p>适合UDP的环境：
1.在<strong>高效可靠的网络</strong>环境中（不需要考虑网络不好导致的丢包、乱序、延时、重复等问题），因为UDP是无连接的服务，不用消耗不必要的网络资源（TCP中的协议间通信）和处理时间（预期确认需要的时间），从而效率要高的多。
2.在<strong>轻权通信</strong>中，当需要传输的数据量很小（可以装在一个IP数据包内）时。如果我们使用TCP协议，那么，先建立连接，一共需要发送3个IP数据包，然后数据传输，1个IP数据包，产生一个确认信号的IP包，然后关闭连接，需要传输5个IP数据包。使用TCP协议IP包的利用率为1/10。而使用UDP，只需要发送一个IP数据包。哪怕丢包（服务不成功），也可重新申请服务（重传）。
注：而且无论UDP还是TCP，传输的都是IP数据包。当网络环境不好导致丢包时，无论TCP还是UDP都会丢包，这是没有区别的。（如果考虑发送丢包，那么TCP效率更低），只是使用TCP，当连接建立成功后，TCP程序会进行可靠性控制。
<strong>UDP很适合这种客户机向服务器传送简单服务请求的环境</strong>。此类应用层协议包括TFTP , SNMP , DNS ,DHCP等。
3.在<strong>对实时性要求很强</strong>的通信中：在诸如实时视频直播等对实时性要求很高的环境中，从而允许一定量的丢包的情况下（直播比赛，前面丢失的包，重传出来已经意义不大了），UDP更适合。（可以根据具体需要通过应用层协议提供可靠性，不用像TCP那么严格。）</p>
<p>适合TCP协议的环境：</p>
<p>当网络硬件失效或者负担太重时，数据包可能就会产生丢失、重复、延时、乱序的现象。这些都会导致<strong>我们的通信不正常的时候</strong>。如果让应用程序来担负差错控制的工作，无疑将给程序员带来许多复杂的工作，于是，我们使用独立的通信协议来保证通信的可靠性是非常必要的。 </p>
<p><strong>PS.写博客真累。。</strong></p>
<p><strong>特别是根据一堆读书笔记写博客。。</strong></p>
<p><strong>特别是写4-5000字的总结博客。。</strong></p>
<p><strong>累的感觉瘫痪了两次。。唉。。伤不起啊。。</strong></p>
<ul>
<li><a href=""><img src="&quot;点击查看原始大小图片&quot;" alt=""></a></li>
<li><p>大小: 11.3 KB</p>
</li>
<li><p><a href=""><img src="&quot;点击查看原始大小图片&quot;" alt=""></a></p>
</li>
<li><p>大小: 11.7 KB</p>
</li>
<li><p><a href="http://java-mzd.iteye.com/blog/1007577#" target="_blank">查看图片附件</a>
<a href="http://java-mzd.iteye.com/blog/1007577#"><strong>141</strong>
顶</a><a href="http://java-mzd.iteye.com/blog/1007577#"><strong>25</strong>
踩</a></p>
</li>
</ul>
<p><a href="http://java-mzd.iteye.com/blog/1019088" title="TCP/IP网络层谜云" target="_blank">TCP/IP网络层谜云</a> | <a href="http://java-mzd.iteye.com/blog/1005945" title="Jpcap简易教程" target="_blank">Jpcap简易教程</a></p>
<ul>
<li>02:04</li>
<li>浏览 (11300)</li>
<li><a href="http://java-mzd.iteye.com/blog/1007577#comments" target="_blank">评论</a> (53)</li>
<li>分类: <a href="http://java-mzd.iteye.com/category/153171" target="_blank">TCP/IP</a></li>
<li><a href="http://www.iteye.com/wiki/topic/1007577" target="_blank">相关推荐</a></li>
</ul>
<h3 id="-">评论</h3>
<p><a href=""></a></p>
<p>53 楼 <a href="http://lucane.iteye.com/" target="_blank">lucane</a> 2011-05-14   <a href="http://java-mzd.iteye.com/blog/1007577#" target="_blank">引用</a></p>
<p>十：所谓的建立TCP链接开销很大，具体是指什么？
从九中，很容易看出。要&quot;简历&quot;TCP链接，必须进行三次IP数据包的成功传输。
52 楼 <a href="http://xsz.iteye.com/" target="_blank">xsz</a> 2011-05-14   <a href="http://java-mzd.iteye.com/blog/1007577#" target="_blank">引用</a></p>
<p>顶顶楼主。</p>
<p>51 楼 <a href="http://wgh596.iteye.com/" target="_blank">wgh596</a> 2011-05-14   <a href="http://java-mzd.iteye.com/blog/1007577#" target="_blank">引用</a></p>
<p><img src="" alt=""> 辛苦，辛苦。
50 楼 <a href="http://hbice.iteye.com/" target="_blank">hbice</a> 2011-05-14   <a href="http://java-mzd.iteye.com/blog/1007577#" target="_blank">引用</a></p>
<p>获益匪浅，lz辛苦，我也辛苦了，顶着牙疼看帖子。。。赶紧去看牙医了。。。</p>
<p>49 楼 <a href="http://lagunarock.iteye.com/" target="_blank">Lagunarock</a> 2011-05-14   <a href="http://java-mzd.iteye.com/blog/1007577#" target="_blank">引用</a></p>
<p>非常不错
涵盖面广，排版又好
值得学习
48 楼 <a href="http://adeline-pan.iteye.com/" target="_blank">adeline.pan</a> 2011-05-13   <a href="http://java-mzd.iteye.com/blog/1007577#" target="_blank">引用</a></p>
<p>写得很好，上学时候学的差不多都忘了，看了又都想起来了，收藏</p>
<p>47 楼 <a href="http://qq376727939.iteye.com/" target="_blank">qq376727939</a> 2011-05-12   <a href="http://java-mzd.iteye.com/blog/1007577#" target="_blank">引用</a></p>
<p>好贴啊,dou zhu
46 楼 <a href="http://vcloud.iteye.com/" target="_blank">gubingo</a> 2011-05-12   <a href="http://java-mzd.iteye.com/blog/1007577#" target="_blank">引用</a></p>
<p>议和程序？/<em>/</em></p>
<p>greatwqs 写道
<img src="" alt=""> 总结的很好!</p>
<p>45 楼 <a href="http://greatwqs.iteye.com/" target="_blank">greatwqs</a> 2011-05-10   <a href="http://java-mzd.iteye.com/blog/1007577#" target="_blank">引用</a></p>
<p><img src="" alt=""> 总结的很好!
44 楼 <a href="http://794217655-qq-com.iteye.com/" target="_blank">嘻哈方式</a> 2011-05-10   <a href="http://java-mzd.iteye.com/blog/1007577#" target="_blank">引用</a></p>
<p>这方面一直都是我的薄弱项 看后我的功力又增强啦！ 多谢楼主！！！</p>
<p>43 楼 <a href="http://steafler.iteye.com/" target="_blank">steafler</a> 2011-05-08   <a href="http://java-mzd.iteye.com/blog/1007577#" target="_blank">引用</a></p>
<p>IP是网络层协议
42 楼 <a href="http://wuhuajun.iteye.com/" target="_blank">wuhuajun</a> 2011-05-07   <a href="http://java-mzd.iteye.com/blog/1007577#" target="_blank">引用</a></p>
<p>好<img src="" alt=""></p>
<p>41 楼 <a href="http://pan-java.iteye.com/" target="_blank">pan_java</a> 2011-05-05   <a href="http://java-mzd.iteye.com/blog/1007577#" target="_blank">引用</a></p>
<p>顶楼主，不错！
40 楼 <a href="http://liuyes.iteye.com/" target="_blank">liuyes</a> 2011-05-05   <a href="http://java-mzd.iteye.com/blog/1007577#" target="_blank">引用</a></p>
<p>写得很好哈</p>
<p>39 楼 <a href="http://beiyangshuishi.iteye.com/" target="_blank">beiyangshuishi</a> 2011-05-03   <a href="http://java-mzd.iteye.com/blog/1007577#" target="_blank">引用</a></p>
<p>写的不错，增长知识了。以前我对网络知识一窍不通。
38 楼 <a href="http://gogopengyou.iteye.com/" target="_blank">gogopengyou</a> 2011-05-03   <a href="http://java-mzd.iteye.com/blog/1007577#" target="_blank">引用</a></p>
<p>基本都看明白了，总结的挺好的</p>
<p>37 楼 <a href="http://housonglin1122-163-com.iteye.com/" target="_blank">小猪笨笨</a> 2011-04-28   <a href="http://java-mzd.iteye.com/blog/1007577#" target="_blank">引用</a></p>
<p>哈哈，谢谢了，其实我对这些东西一直一知半解，看了你这篇文有很大收获
36 楼 <a href="http://torry-1979.iteye.com/" target="_blank">torry_1979</a> 2011-04-27   <a href="http://java-mzd.iteye.com/blog/1007577#" target="_blank">引用</a></p>
<p>作为一个普及性的资料还不错</p>
<p>35 楼 <a href="http://sswh.iteye.com/" target="_blank">sswh</a> 2011-04-27   <a href="http://java-mzd.iteye.com/blog/1007577#" target="_blank">引用</a></p>
<p>mark
谢谢分享。
34 楼 <a href="http://yanglijun888.iteye.com/" target="_blank">20444465</a> 2011-04-26   <a href="http://java-mzd.iteye.com/blog/1007577#" target="_blank">引用</a></p>
<p>做it的一家要懂</p>
<p>« 上一页 1 <a href="http://java-mzd.iteye.com/blog/1007577?page=2#comments" target="_blank">2</a> <a href="http://java-mzd.iteye.com/blog/1007577?page=3#comments" target="_blank">3</a> <a href="http://java-mzd.iteye.com/blog/1007577?page=2#comments" target="_blank">下一页 »</a></p>
<h3 id="-">发表评论</h3>
<h3 id="-">表情图标</h3>
<p><img src="" alt=""><img src="" alt=""><img src="" alt=""><img src="" alt=""><img src="" alt=""><img src="" alt=""><img src="" alt=""><img src="" alt=""><img src="" alt=""><img src="" alt=""><img src="" alt=""><img src="" alt=""><img src="" alt=""><img src="" alt=""><img src="" alt=""><img src="" alt=""><img src="" alt=""><img src="" alt=""><img src="" alt=""><img src="" alt=""></p>
<p>字体颜色: 标准深红红色橙色棕色黄色绿色橄榄青色蓝色深蓝靛蓝紫色灰色白色黑色 字体大小: 标准1 (xx-small)2 (x-small)3 (small)4 (medium)5 (large)6 (x-large)7 (xx-large) 对齐: 标准居左居中居右</p>
<p>提示：选择您需要装饰的文字, 按上列按钮即可添加上相应的标签</p>
<p>您还没有登录，请<a href="http://java-mzd.iteye.com/login" target="_blank">登录</a>后发表评论(快捷键 Alt+S / Ctrl+Enter)</p>
<p><a href="http://java-mzd.iteye.com/" target="_blank"><img src="&quot;java_mzd的博客: &quot;" alt="java_mzd的博客"></a></p>
<p>java_mzd</p>
<ul>
<li>浏览: 70746 次</li>
<li>性别: <img src="&quot;男&quot;" alt="Icon_minigender_1"></li>
<li>来自: 长沙</li>
<li><img src="" alt=""></li>
<li><a href="http://java-mzd.iteye.com/blog/profile" target="_blank">详细资料</a> <a href="http://java-mzd.iteye.com/blog/guest_book" target="_blank">留言簿</a></li>
</ul>
<h3 id="-">搜索本博客</h3>
<h3 id="-http-java-mzd-iteye-com-blog-user_visits-">最近访客 <a href="http://java-mzd.iteye.com/blog/user_visits" target="_blank">&gt;&gt;更多访客</a></h3>
<p><a href="http://zhxing.iteye.com/" target="_blank"><img src="&quot;zhxing的博客: ヾ孤星随缘ツ  http://t.sina.com.cn/samzhxing&quot;" alt="zhxing的博客"></a></p>
<p><a href="http://zhxing.iteye.com/" target="_blank">zhxing</a></p>
<p><a href="http://java-suddy.iteye.com/" target="_blank"><img src="&quot;java_suddy的博客: “平凡”的思想&quot;" alt="java_suddy的博客"></a></p>
<p><a href="http://java-suddy.iteye.com/" target="_blank">java_suddy</a>
<a href="http://liuxinglanyue.iteye.com/" target="_blank"><img src="&quot;liuxinglanyue的博客: liuxinglanyue&quot;" alt="liuxinglanyue的博客"></a></p>
<p><a href="http://liuxinglanyue.iteye.com/" target="_blank">liuxinglanyue</a></p>
<p><a href="http://libo-591.iteye.com/" target="_blank"><img src="&quot;libo_591的博客: 让更多的人站在巨人的肩膀上&quot;" alt="libo_591的博客"></a></p>
<p><a href="http://libo-591.iteye.com/" target="_blank">libo_591</a></p>
<h3 id="-">博客分类</h3>
<ul>
<li><a href="http://java-mzd.iteye.com/" target="_blank">全部博客 (43)</a></li>
<li><a href="http://java-mzd.iteye.com/category/133623" target="_blank">数据结构----------JAVA类集 (5)</a></li>
<li><p><a href="http://java-mzd.iteye.com/category/153171" target="_blank">TCP/IP (7)</a></p>
<h3 id="-http-java-mzd-iteye-com-blog-guest_book-">我的留言簿 <a href="http://java-mzd.iteye.com/blog/guest_book" target="_blank">&gt;&gt;更多留言</a></h3>
</li>
<li><p>楼主 你工作多久了。。。。
-- by <a href="http://java-mzd.iteye.com/blog/guest_book#39913" target="_blank">fanmingxing</a></p>
</li>
<li>写的不错，学习，谢谢！
-- by <a href="http://java-mzd.iteye.com/blog/guest_book#39693" target="_blank">chenge2k</a></li>
<li>看了LZ的文章，发现工作快两年的我，就像是一块浮起来的木头，真的很惭愧！也不怪我拿 ...
-- by <a href="http://java-mzd.iteye.com/blog/guest_book#39618" target="_blank">GoTiger</a></li>
</ul>
<h3 id="-">其他分类</h3>
<ul>
<li><a href="http://java-mzd.iteye.com/blog/favorite" target="_blank">我的收藏</a> (23)</li>
<li><a href="http://java-mzd.iteye.com/blog/code_favorite" target="_blank">我的代码</a> (0)</li>
<li><a href="http://java-mzd.iteye.com/blog/topic" target="_blank">我的论坛主题帖</a> (3)</li>
<li><a href="http://java-mzd.iteye.com/blog/post" target="_blank">我的所有论坛帖</a> (37)</li>
<li><p><a href="http://java-mzd.iteye.com/blog/article" target="_blank">我的精华良好帖</a> (0)</p>
<h3 id="-">最近加入群组</h3>
</li>
<li><p><a href="http://android.group.iteye.com/" target="_blank">Android</a></p>
</li>
</ul>
<h3 id="-">存档</h3>
<ul>
<li><a href="http://java-mzd.iteye.com/blog/monthblog/2011-05" target="_blank">2011-05</a> (2)</li>
<li><a href="http://java-mzd.iteye.com/blog/monthblog/2011-04" target="_blank">2011-04</a> (7)</li>
<li><a href="http://java-mzd.iteye.com/blog/monthblog/2011-03" target="_blank">2011-03</a> (2)</li>
<li><p><a href="http://java-mzd.iteye.com/blog/monthblog_more" target="_blank">更多存档...</a></p>
<h3 id="-">评论排行榜</h3>
</li>
<li><p><a href="http://java-mzd.iteye.com/blog/1050043" title="腾讯、淘宝、金山网络，实习生我该何去何从" target="_blank">腾讯、淘宝、金山网络，实习生我该何去何从</a></p>
</li>
<li><a href="http://java-mzd.iteye.com/blog/1050926" title="淘宝、金山网络，百感交集" target="_blank">淘宝、金山网络，百感交集</a></li>
<li><a href="&quot;TCP/IP传输层，你懂多少？&quot;">TCP/IP传输层，你懂多少？</a></li>
<li><a href="http://java-mzd.iteye.com/blog/1004784" title="淘宝武汉*面试归来" target="_blank">淘宝武汉/*面试归来</a></li>
<li><p><a href="http://java-mzd.iteye.com/blog/862787" title="开源软件？自由软件？免费软件？你了解多少？" target="_blank">开源软件？自由软件？免费软件？你了解多少 ...</a></p>
</li>
<li><p><a href="http://java-mzd.iteye.com/rss" target="_blank"><img src="" alt="Rss"></a></p>
</li>
<li><a href="http://fusion.google.com/add?feedurl=http://java-mzd.iteye.com/rss" target="_blank"><img src="" alt="Rss_google"></a>
声明：ITeye文章版权属于作者，受法律保护。没有作者书面许可不得转载。若作者同意转载，必须以超链接形式标明文章原始出处和作者。
© 2003-2011 ITeye.com. All rights reserved. [ 京ICP证110151号 ]
<img src="" alt=""></li>
</ul>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/TCPIP/">TCPIP</a></li></span></span> | <span class="tags">Tagged <a href="/tags/TCPIP/" class="label label-primary">TCPIP</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:44"datetime="2014-03-07 09:54:44"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-TCPIP--TCPIP传输层，你懂多少？--ITeye技术网站/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-TCPIP--TCPIP传输层，你懂多少？--ITeye技术网站" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>





<ul id="pagination" class="pagination pagination-lg">
  <li><a class="extend prev" href="/page/23/">&laquo;</a></li><li><a class="page-number" href="/">1</a></li><li><a class="page-number" href="/page/2/">2</a></li><li><span class="space">&hellip;</span></li><li><a class="page-number" href="/page/21/">21</a></li><li><a class="page-number" href="/page/22/">22</a></li><li><a class="page-number" href="/page/23/">23</a></li><li class="active"><li><span class="page-number current">24</span></li><li><a class="page-number" href="/page/25/">25</a></li><li><a class="page-number" href="/page/26/">26</a></li><li><a class="page-number" href="/page/27/">27</a></li><li><span class="space">&hellip;</span></li></li><li><a class="page-number" href="/page/161/">161</a></li><li><a class="page-number" href="/page/162/">162</a></li><li><a class="extend next" href="/page/25/">&raquo;</a></li>
  <div class="clearfix"></div>
</ul></div><!--wapper-->
       </div><!-- ID main-col END -->
       <aside id="sidebar" class="alignright col-sx-6 col-sm-4 col-md-3 col-lg-3">
<div id="widget_search" class="widget panel panel-primary">
    <form action="//google.com/search" method="get" accept-charset="utf-8">
  <div class="input-group">
    <input class="form-control" id="searchbox" type="search" name="q" results="0" placeholder="search">
    <span class="input-group-btn">
      <button class="btn btn-default" type="submit">Go!</button>
    </span>
    <input type="hidden" name="q" value="site:itsolife.com">
  </div>
</form>
</div>

<div id="widget_category" class="widget panel panel-primary">
  <div class="panel-heading">category</div>  <div data-src='category' class='ajax_widgets'>正在加载...</div>
</div>

<div id="widget_recent_posts" class="widget panel panel-primary">
  <div class="panel-heading">recent posts</div>  <div data-src='recent_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_tagcloud" class="widget panel panel-primary">
  <div class="panel-heading">tagcloud</div>  <div data-src='tagcloud' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_latest_update_posts" class="widget panel panel-primary">
  <div class="panel-heading">最近更新</div>  <div data-src='latest_update_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_recent_comments" class="widget panel panel-primary">
  <div class="panel-heading">recent comments</div>  

<div class="list-group-item ds-recent-comments" data-num-items="6" data-show-avatars="1" data-show-time="1" data-show-title="1" data-show-admin="1" data-excerpt-length="50"></div>



</div>

</aside>
       <div class="clearfix"></div>
     </div><!-- row END -->
  </div>
  <footer id="footer" class="container">
  <div class="panel panel-info">
  <section id='footer_widget'></section>  <div class="panel-footer">
  <div id="site-info">
    <span class='author'>
  
  &copy; 2014 RobinChia
  
    &nbsp;&nbsp;</span>
  
  <span id='analytics-51la'></span><span id='analytics-google'>
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-48559895-1']);
  _gaq.push(['_trackPageview']);
  _js2load.push({src:('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'});
</script></span><span id='analytics-cnzz'>
<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_5774006'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s17.cnzz.com/stat.php%3Fid%3D5774006%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>
</span><span id='analytics-baidu'>
<script>
var _hmt = _hmt || [];
_js2load.push({src:"//hm.baidu.com/hm.js?1442f50724afc42380b51f097c43082c"});
</script>
</span>  </div>
  <div id="copyright">Site powered by <a href='http://zespia.tw/hexo/'><strong>hexo</strong></a>  update time: <em>2014-04-07 18:24:57</em></span></div>
</div>
<div class="clearfix"></div>


  </div>
  </footer>
  
        <script src="http://cdn.bootcss.com/jquery/1.10.2/jquery.min.js"></script>        
        <script src="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/js/bootstrap.min.js"></script>        
                
        <script src="http://cdn.bootcss.com/prettify/r298/prettify.min.js"></script>    <script type="text/javascript">
   var lang=["bsh", "c", "cc", "cpp", "cs", "csh", "cyc", "cv", "htm", "html",
    "java", "js", "m", "mxml", "perl", "pl", "pm", "py", "rb", "sh",
    "xhtml", "xml", "xsl"];
   var pretty_base='';
   $('script').each(function(){
	var c = $(this).attr('src');
	if (!c)
	    return;
	if (c.match(/(\/)?prettify(\.min)?\.js/i))
	{
	    var index = c.lastIndexOf('/');
	    if (index != -1)
		pretty_base = c.substr(0,index + 1);
	    return false;
	}
   })
   $('pre code').each(function(){
	var c = $(this).attr('class')
	if (!c)
	    return;
	c = c.match(/\s?(lang\-\w+)/i);
	if (c && lang.indexOf(c[1]) == -1)
	{
	    lang.push(c[1]);
	    $.getScript(pretty_base + c[1] + '.min.js');
	}
   })

    $(window).load(function(){
       $("pre").addClass("prettyprint");
       prettyPrint();
    })
</script>    
            <script type="text/javascript">
var duoshuoQuery = {short_name:"robinchia"};
_js2load.push({src:'http://static.duoshuo.com/embed.js',charset:'UTF-8'});
</script>
    
            <!--wumii_relatedItems-->
    
        <script src="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js"></script>    <script type="text/javascript">
(function($){
  $('.entry').each(function(i){
    $(this).find('img').each(function(){
      var alt = this.alt;

      if (alt){
        $(this).before('<span class="caption">' + alt + '</span>');
      }

      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox" rel="fancybox' + i + '" />');
    });
  });

  $('.fancybox').fancybox();
})(jQuery);
</script>    
        <script src="http://cdn.bootcss.com/mathjax/2.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>    <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>
    
<script type="text/javascript">
$('.ajax_widgets').each(function(){var src=$(this).attr('data-src');if(src)$(this).load('/widgets/'+src+'.html');});
$.each(_js2load,function(index,obj){loadjs(obj.src,obj.charset)});
</script>

<div id="scroll2top">
<img src="/scroll2top/arrow.png"/>
</div>
<script src="/scroll2top/scroll2top.min.js"></script>
<div id="winterland">
  <canvas></canvas>
</div>
<script src="/js/winterland.min.js"></script>

  </body>
</html>
