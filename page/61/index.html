
<!DOCTYPE HTML>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>The 61 Page | It so life</title>
<meta name="author" content="RobinChia">

<meta name="description" content="It so life">


<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<meta property="og:site_name" content="It so life"/>

<!--[if IE]><style>.testIE.IE{display:inline;}</style><![endif]-->
<!--[if lte IE 7]><link rel="stylesheet" href="/css/ie7.css" type="text/css"><![endif]-->
<!--[if (lt IE 9)&(gt IE 7)]><style>.testIE.IE8{display:inline;}</style><![endif]-->
<!--[if gt IE 8]><style>.testIE.IE9{display:inline;}</style><![endif]-->

<link href="/favicon.png" rel="icon">
<link rel="alternate" href="/atom.xml" title="It so life Feed" type="application/atom+xml">

<link rel="stylesheet" href="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/css/bootstrap.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/font-awesome/4.0.3/css/font-awesome.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/prettify/r298/prettify.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" type="text/css">
<link rel="stylesheet" href="/css/style.css" type="text/css">
<!--[if lt IE 9]>
   <style>article,aside,dialog,footer,header,section,footer,nav,figure,menu{display:block}</style>
   <script src="http://cdn.staticfile.org/html5shiv/r29/html5.min.js"></script>
   <script src="http://cdn.staticfile.org/respond.js/1.4.2/respond.min.js"></script>
<link href="http://cdn.staticfile.org/respond.js/1.4.2/respond-proxy.html" id="respond-proxy" rel="respond-proxy" />
<link href="/js/respond.proxy.gif" id="respond-redirect" rel="respond-redirect" />
<script src="/js/respond.proxy.js"></script>
   <script src="http://cdn.bootcss.com/selectivizr/1.0.2/selectivizr-min.js"></script>
<![endif]-->
<script type="text/javascript">
function loadjs(c,d){var a=document.createElement("script");a.async=!0;a.type="text/javascript";a.src=c;a.charset=d||"gbk";(document.getElementsByTagName("HEAD")[0]||document.getElementsByTagName("BODY")[0]).appendChild(a)};
var _protocol = (("https:" == document.location.protocol) ? " https://" : " http://");
var _js2load = [];
</script>

</head>
<body>
      <header id="header" class="container"><nav id="main-nav" class="navbar navbar-default navbar-fixed-top " role="navigation">
  <div class="container">
    <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
      <span class="sr-only">Toggle navigation</span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="/">It so life</a>
    </div>
    <div  class="collapse navbar-collapse">
      <ul  class="nav navbar-nav">
  
        <li><a href="/" title="Home">Home</a></li>      
        <li><a href="/about/" title="About">About</a></li>      
        <li><a href="/archives/" title="Archives">Archives</a></li>      
      <li class='dropdown'>
        <a class='dropdown-toggle' data-toggle='dropdown' href='#'>website<b class='caret'></b></a>
        <ul class='dropdown-menu pure-menu-selected'>
    
          <li><a href="//groups.google.com/forum/#!forum/pongba" title="TopLanguage">TopLanguage</a></li>    
          <li><a href="//itpub.net/" title="ITPub">ITPub</a></li>    
          <li><a href="//blog.jobbole.com/" title="Bole">Bole</a></li>    
          <li><a href="//nosql-database.org/" title="nosql">nosql</a></li>    
          <li><a href="//gitimmersion.googol.im/" title="Git">Git</a></li>    
        </ul>
      </li>
    
      </ul>
      <ul class="nav navbar-nav navbar-right">
      
        <li><a href="/atom.xml">RSS</a></li>
      
      
        <li><a href="https://twitter.com/robinchia">twitter</a></li>
      
      
      
      
        <li><a href="https://github.com/robinchia">github</a></li>
      
      </ul>
    </div>
  </div>
</nav>
<div class="clearfix"></div>
</header>
  <div id='content' class="container">
     <div class="page-header-wrapper">
      <!--[if lt IE 9]><div class="alert alert-warning alert-dismissable"><button type="button" class="close" data-dismiss="alert" aria-hidden="true">&times;</button><strong>提示:</strong>您的浏览器版本太低了,建议升级到 <strong><a href="http://windows.microsoft.com/zh-cn/internet-explorer/download-ie" title="IE9">IE9</a></strong> 以上,本站使用<a href="https://www.google.com/intl/zh-CN/chrome/">Chrome浏览器</a>可以获得最好的显示效果.</div><![endif]-->
      <div class="page-header"><h1 align="center"><big>It so life</big> </h1>
        <h5 align="center"><big>love as life</big></h5>
      </div>
     </div>
     <div class="row">
       <div id="main-col" class="alignleft col-sx-12 col-sm-8 col-md-9 col-lg-9">
      <section id='header_widget'></section>
          <div id="wrapper"><article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE--Tomcat预编译JSP脚本/">Tomcat 预编译JSP 脚本</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:41.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE--Tomcat预编译JSP脚本/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="tomcat-jsp-">Tomcat 预编译JSP 脚本</h1>
<p>参考：</p>
<p>The Apache Jakarta Tomcat 5.5 Servlet/JSP Container Jasper 2 JSP Engine How To</p>
<p><a href="http://jakarta.apache.org/tomcat/tomcat-5.5-doc/jasper-howto.html" target="_blank"><a href="http://jakarta.apache.org/tomcat/tomcat-5.5-doc/jasper-howto.html">http://jakarta.apache.org/tomcat/tomcat-5.5-doc/jasper-howto.html</a></a></p>
<p>jspc</p>
<p><a href="http://ant.apache.org/manual/OptionalTasks/jspc.html" target="_blank"><a href="http://ant.apache.org/manual/OptionalTasks/jspc.html">http://ant.apache.org/manual/OptionalTasks/jspc.html</a></a></p>
<p>用Tomcat进行预编译的ant脚本如下：</p>
<p>build.properties的内容为：</p>
<p>tomcat.home=D:/Tomcat 5.5
webapp.name=blh
webapp.path=D:/Tomcat 5.5/webapps/blh</p>
<p>build.xml的内容为：</p>
<ol>
<li>&lt;?xml version=&quot;1.0&quot; encoding=&quot;GBK&quot;?&gt;</li>
<li><project name="WebApp Precompilation JSP to Java to Class to Jar" basedir="." default="help"></li>
<li><property file="build.properties"/></li>
<li><target name="all" depends="jsp2java,java2class,class2jar,clear"/></li>
<li><target name="help"></li>
<li><echo message="显示功能列表"/></li>
<li><echo message="jsp2java  通过JspC将JSP转换成Java源代码"/></li>
<li><echo message="java2class 将转换后的Java源代码进行编译成class文件"/></li>
<li><echo message="class2jar 将编译后的class文件打包"/></li>
<li><echo message="clear  清理现场"/></li>
<li></target></li>
<li><target name="jsp2java"></li>
<li><taskdef classname="org.apache.jasper.JspC" name="jsp2java"></li>
<li><classpath id="jsp2java.classpath"></li>
<li><fileset dir="${tomcat.home}/bin"></li>
<li><include name="/*.jar"/></li>
<li></fileset></li>
<li><fileset dir="${tomcat.home}/server/lib"></li>
<li><include name="/*.jar"/></li>
<li></fileset></li>
<li><fileset dir="${tomcat.home}/common/lib"></li>
<li><include name="/*.jar"/></li>
<li></fileset></li>
<li></classpath></li>
<li></taskdef></li>
<li><!-- 注意JSP文件要设置为UTF-8编码 --></li>
<li><jsp2java classpath="jsp2java.classpath" javaEncoding="UTF-8" validateXml="false" uriroot="${webapp.path}" webXmlFragment="${webapp.path}/WEB-INF/webJSP.xml" outputDir="${webapp.path}/WEB-INF/JspC/src"/></li>
<li></target></li>
<li><target name="java2class"></li>
<li><mkdir dir="${webapp.path}/WEB-INF/JspC/classes"/></li>
<li><!-- 同样Java文件要设置为UTF-8编码 --></li>
<li><javac srcdir="${webapp.path}/WEB-INF/JspC/src" destdir="${webapp.path}/WEB-INF/JspC/classes" encoding="UTF-8" optimize="off" debug="on" failonerror="false" excludes="/*/*//*.smap"></li>
<li><classpath id="java2class.classpath"></li>
<li><pathelement location="${webapp.path}/WEB-INF/classes"/></li>
<li><fileset dir="${webapp.path}/WEB-INF/lib"></li>
<li><include name="/*.jar"/></li>
<li></fileset></li>
<li><pathelement location="${tomcat.home}/common/classes"/></li>
<li><fileset dir="${tomcat.home}/common/lib"></li>
<li><include name="/*.jar"/></li>
<li></fileset></li>
<li><pathelement location="${tomcat.home}/shared/classes"/></li>
<li><fileset dir="${tomcat.home}/shared/lib"></li>
<li><include name="/*.jar"/></li>
<li></fileset></li>
<li><fileset dir="${tomcat.home}/bin"></li>
<li><include name="/*.jar"/></li>
<li></fileset></li>
<li></classpath></li>
<li><include name="/*/*"/></li>
<li><exclude name="tags//*/*" /></li>
<li></javac></li>
<li></target></li>
<li><target name="class2jar"></li>
<li><mkdir dir="${webapp.path}/WEB-INF/lib"/></li>
<li><jar basedir="${webapp.path}/WEB-INF/JspC/classes" jarfile="${webapp.path}/WEB-INF/lib/${webapp.name}JSP.jar"/></li>
<li></target></li>
<li><target name="clear"></li>
<li><delete dir="${webapp.path}/WEB-INF/JspC/classes"/></li>
<li><delete dir="${webapp.path}/WEB-INF/JspC/src"/></li>
<li><delete dir="${webapp.path}/WEB-INF/JspC"/></li>
<li></target></li>
<li></project></li>
</ol>
<hr>
<p>只需要设置好Ant的path环境变量，然后修改build.properties。执行ant all命令即可。
生成好的jar文件是{$webappname}JSP.jar。
在做为产品发布的时候，只需要你的类jar包和JSP预编译的包放到WEB-INF/lib/目录下即可，如${webappname}.jar和JSP预编译的包${webappname}JSP.jar；
然后删除掉你的所有的预编过的JSP源文件；
并且${webapp.path}/WEB-INF/webJSP.xml里的servlet映射，添加到${webapp.path}/WEB-INF/web.xml中。</p>
<p>来源： <a href="[http://blog.csdn.net/terry_f/article/details/3725382](http://blog.csdn.net/terry_f/article/details/3725382)">[http://blog.csdn.net/terry_f/article/details/3725382](http://blog.csdn.net/terry_f/article/details/3725382)</a> </p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:41"datetime="2014-03-07 09:54:41"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE--Tomcat预编译JSP脚本/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE--Tomcat预编译JSP脚本" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_多线程-内存--缓存算法/">缓存算法</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:41.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_多线程-内存--缓存算法/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-">缓存算法</h1>
<p><strong>缓存算法</strong></p>
<p>没有人能说清哪种缓存算法由于其他的缓存算法。（以下的几种缓存算法，有的我也理解不好，如果感兴趣，你可以Google一下 ）</p>
<p><strong>Least Frequently Used（LFU）</strong>：</p>
<p>大家好，我是 LFU，我会计算为每个缓存对象计算他们被使用的频率。我会把最不常用的缓存对象踢走。</p>
<p><strong>Least Recently User（LRU）</strong>：</p>
<p>我是LRU缓存算法，我把最近最少使用的缓存对象给踢走。</p>
<p>我总是需要去了解在什么时候，用了哪个缓存对象。如果有人想要了解我为什么总能把最近最少使用的对象踢掉，是非常困难的。</p>
<p>浏览器就是使用了我（LRU）作为缓存算法。新的对象会被放在缓存的顶部，当缓存达到了容量极限，我会把底部的对象踢走，而技巧就是：我会把最新被访问的缓存对象，放到缓存池的顶部。</p>
<p>所以，经常被读取的缓存对象就会一直呆在缓存池中。有两种方法可以实现我，array 或者是 linked list。</p>
<p>我的速度很快，我也可以被数据访问模式适配。我有一个大家庭，他们都可以完善我，甚至做的比我更好（我确实有时会嫉妒，但是没关系）。我家庭的一些成员包括LRU2 和 2Q，他们就是为了完善 LRU 而存在的。</p>
<p><strong>Least Recently Used 2（LRU2）</strong>：</p>
<p>我是 Least Recently Used 2，有人叫我最近最少使用twice，我更喜欢这个叫法。我会把被两次访问过的对象放入缓存池，当缓存池满了之后，我会把有两次最少使用的缓存对象踢走。 因为需要跟踪对象2次，访问负载就会随着缓存池的增加而增加。如果把我用在大容量的缓存池中，就会有问题。另外，我还需要跟踪那么不在缓存的对象，因为他 们还没有被第二次读取。我比LRU好，而且是 adoptive to access 模式 。</p>
<p><strong>Two Queues（2Q）</strong>：</p>
<p>我是 Two Queues；我把被访问的数据放到LRU的缓存中，如果这个对象再一次被访问，我就把他转移到第二个、更大的LRU缓存。</p>
<p>我踢走缓存对象是为了保持第一个缓存池是第二个缓存池的1/3。当缓存的访问负载是固定的时候，把 LRU 换成 LRU2，就比增加缓存的容量更好。这种机制使得我比 LRU2 更好，我也是 LRU 家族中的一员，而且是 adoptive to access 模式 。</p>
<p><strong>Adaptive Replacement Cache（ARC）</strong>：</p>
<p>我是 ARC，有人说我是介于 LRU 和 LFU 之间，为了提高效果，我是由2个 LRU 组成，第一个，也就是 L1，包含的条目是最近只被使用过一次的，而第二个 LRU，也就是 L2，包含的是最近被使用过两次的条目。因此， L1 放的是新的对象，而 L2 放的是常用的对象。所以，别人才会认为我是介于 LRU 和 LFU 之间的，不过没关系，我不介意。</p>
<p>我被认为是性能最好的缓存算法之一，能够自调，并且是低负载的。我也保存着历史对象，这样，我就可以记住那些被移除的对象，同时，也让我可以看到被移除的对象是否可以留下，取而代之的是踢走别的对象。我的记忆力很差，但是我很快，适用性也强。</p>
<p><strong>Most Recently Used（MRU）</strong>：</p>
<p>我是 MRU，和 LRU 是对应的。我会移除最近最多被使用的对象，你一定会问我为什么。好吧，让我告诉你，当一次访问过来的时候，有些事情是无法预测的，并且在缓存系统中找出最少最近使用的对象是一项时间复杂度非常高的运算，这就是为什么我是最好的选择。</p>
<p>我是数据库内存缓存中是多么的常见！每当一次缓存记录的使用，我会把它放到栈的顶端。当栈满了的时候，你猜怎么着？我会把栈顶的对象给换成新进来的对象！</p>
<p><strong>First in First out（FIFO）</strong>：</p>
<p>我是先进先出，我是一个低负载的算法，并且对缓存对象的管理要求不高。我通过一个队列去跟踪所有的缓存对象，最近最常用的缓存对象放在后面，而更早的缓存对象放在前面，当缓存容量满时，排在前面的缓存对象会被踢走，然后把新的缓存对象加进去。我很快，但是我并不适用。</p>
<p><strong>Second Chance</strong>：</p>
<p>大家好，我是 second chance，我是通过FIFO修改而来的，被大家叫做 second chance 缓存算法，我比 FIFO 好的地方是我改善了 FIFO 的成本。我是 FIFO 一样也是在观察队列的前端，但是很FIFO的立刻踢出不同，我会检查即将要被踢出的对象有没有之前被使用过的标志（1一个bit表示），没有没有被使用 过，我就把他踢出；否则，我会把这个标志位清除，然后把这个缓存对象当做新增缓存对象加入队列。你可以想象就这就像一个环队列。当我再一次在队头碰到这个 对象时，由于他已经没有这个标志位了，所以我立刻就把他踢开了。我在速度上比FIFO快。</p>
<p><strong>CLock</strong></p>
<p>我是Clock，一个更好的FIFO，也比 second chance更好。因为我不会像second chance那样把有标志的缓存对象放到队列的尾部，但是也可以达到second chance的效果。</p>
<p>我持有一个装有缓存对象的环形列表，头指针指向列表中最老的缓存对象。当缓存miss发生并且没有新的缓存空间时，我会问问指针指向的缓存对象的标 志位去决定我应该怎么做。如果标志是0，我会直接用新的缓存对象替代这个缓存对象；如果标志位是1，我会把头指针递增，然后重复这个过程，知道新的缓存对 象能够被放入。我比second chance更快。</p>
<p><strong>Simple time-based</strong>：</p>
<p>我是 simple time-based 缓存算法，我通过绝对的时间周期去失效那些缓存对象。对于新增的对象，我会保存特定的时间。我很快，但是我并不适用。</p>
<p><strong>Extended time-based expiration</strong>：</p>
<p>我是 extended time-based expiration 缓存算法，我是通过相对时间去失效缓存对象的；对于新增的缓存对象，我会保存特定的时间，比如是每5分钟，每天的12点。</p>
<p><strong>Sliding time-based expiration</strong>：</p>
<p>我是 sliding time-based expiration，与前面不同的是，被我管理的缓存对象的生命起点是在这个缓存的最后被访问时间算起的。我很快，但是我也不太适用。</p>
<p>好了！听了那么多缓存算法的自我介绍，其他的缓存算法还考虑到了下面几点：</p>
<p>成本。如果缓存对象有不同的成本，应该把那些难以获得的对象保存下来。
容量。如果缓存对象有不同的大小，应该把那些大的缓存对象清除，这样就可以让更多的小缓存对象进来了。
时间。一些缓存还保存着缓存的过期时间。电脑会失效他们，因为他们已经过期了。
根据缓存对象的大小而不管其他的缓存算法可能是有必要的。</p>
<p><strong>Random Cache</strong>：</p>
<p>我是随机缓存，我随意的替换缓存实体，没人敢抱怨。你可以说那个被替换的实体很倒霉。通过这些行为，我随意的去处缓存实体。我比FIFO机制好，在某些情况下，我甚至比 LRU 好，但是，通常LRU都会比我好。</p>
<p>看看缓存元素（缓存实体）
public class CacheElement {</p>
<p>private Object objectValue;</p>
<p>private Object objectKey;</p>
<p>private int index;</p>
<p>private int hitCount;</p>
<p>// getters and setters</p>
<p>}</p>
<p>这个缓存实体拥有缓存的key和value，这个实体的数据结构会被以下所有缓存算法用到。</p>
<p>缓存算法的公用代码
public final synchronized void addElement(Object key,Object value) {</p>
<p>int index;
Object obj;</p>
<p>// get the entry from the table
obj = table.get(key);</p>
<p>// If we have the entry already in our table
then get it and replace only its value.
if (obj != null) {
CacheElement element;</p>
<p>element = (CacheElement) obj;
element.setObjectValue(value);
element.setObjectKey(key);</p>
<p>return;
}
}</p>
<p>上面的代码会被所有的缓存算法实现用到。这段代码是用来检查缓存元素是否在缓存中了，如果是，我们就替换它，但是如果我们找不到这个key对应的缓存，我们会怎么做呢？那我们就来深入的看看会发生什么吧！</p>
<p>现场访问</p>
<p>今天的专题很特殊，因为我们有特殊的客人，事实上他们是我们想要听的与会者，但是首先，先介绍一下我们的客人：Random Cache，FIFO Cache。让我们从 Random Cache开始。</p>
<p>看看随机缓存的实现
public final synchronized void addElement(Object key,Object value) {</p>
<p>int index;
Object obj;</p>
<p>obj = table.get(key);</p>
<p>if (obj != null) {
CacheElement element;</p>
<p>// Just replace the value.
element = (CacheElement) obj;
element.setObjectValue(value);
element.setObjectKey(key);</p>
<p>return;
}</p>
<p>// If we haven’t
filled the cache yet, put it at the end.
if (!isFull()) {
index = numEntries;
++numEntries;
} else {
// Otherwise, replace a random entry.
index = (int) (cache.length /* random.nextFloat());
table.remove(cache[index].getObjectKey());
}</p>
<p>cache[index].setObjectValue(value);
cache[index].setObjectKey(key);
table.put(key, cache[index]);
}</p>
<p>看看FIFO缓存算法的实现</p>
<p>public final synchronized void addElement(Object
key,Object value) {
int index;
Object obj;</p>
<p>obj = table.get(key);</p>
<p>if (obj != null) {
CacheElement element;</p>
<p>// Just replace the value.
element = (CacheElement) obj;
element.setObjectValue(value);
element.setObjectKey(key);</p>
<p>return;
}</p>
<p>// If we haven’t filled the cache yet, put it at the end.
if (!isFull()) {
index = numEntries;
++numEntries;
} else {
// Otherwise, replace the current pointer, entry with the new one
index = current;
// in order to make Circular FIFO
if (++current &gt;= cache.length)
current = 0;</p>
<p>table.remove(cache[index].getObjectKey());
}</p>
<p>cache[index].setObjectValue(value);
cache[index].setObjectKey(key);
table.put(key, cache[index]);
}</p>
<p>看看LFU缓存算法的实现</p>
<p>public synchronized Object getElement(Object key) {</p>
<p>Object obj;</p>
<p>obj = table.get(key);</p>
<p>if (obj != null) {
CacheElement element = (CacheElement) obj;
element.setHitCount(element.getHitCount() + 1);
return element.getObjectValue();
}
return null;</p>
<p>}</p>
<p>public final synchronized void addElement(Object key, Object value) {</p>
<p>Object obj;</p>
<p>obj = table.get(key);</p>
<p>if (obj != null) {
CacheElement element;</p>
<p>// Just replace the value.
element = (CacheElement) obj;
element.setObjectValue(value);
element.setObjectKey(key);</p>
<p>return;
}</p>
<p>if (!isFull()) {</p>
<p>index = numEntries;
++numEntries;
} else {
CacheElement element = removeLfuElement();
index = element.getIndex();
table.remove(element.getObjectKey());
}</p>
<p>cache[index].setObjectValue(value);
cache[index].setObjectKey(key);
cache[index].setIndex(index);
table.put(key, cache[index]);
}</p>
<p>public CacheElement removeLfuElement() {</p>
<p>CacheElement[] elements = getElementsFromTable();
CacheElement leastElement = leastHit(elements);
return leastElement;
}</p>
<p>public static CacheElement leastHit(CacheElement[] elements) {</p>
<p>CacheElement lowestElement = null;
for (int i = 0; i &lt; elements.length; i++) {
CacheElement element = elements[i];
if (lowestElement == null) {
lowestElement = element;</p>
<p>} else {
if (element.getHitCount() &lt; lowestElement.getHitCount()) { lowestElement = element; }</p>
<p>}</p>
<p>}</p>
<p>return lowestElement;</p>
<p>}</p>
<p>最重点的代码，就应该是 leastHit 这个方法，这段代码就是把 hitCount 最低的元素找出来，然后删除，给新进的缓存元素留位置。 看看LRU缓存算法实现</p>
<p>private void moveToFront(int index) {</p>
<p>int nextIndex, prevIndex;</p>
<p>if(head != index) {</p>
<p>nextIndex = next[index];</p>
<p>prevIndex = prev[index]; // Only the head has a prev entry that is an invalid index so // we don’t check. next[prevIndex] = nextIndex; // Make sure index is valid. If it isn’t, we’re at the tail // and don’t set prev[next]. if(nextIndex &gt;= 0)
prev[nextIndex] = prevIndex;
else
tail = prevIndex;</p>
<p>prev[index] = -1;
next[index] = head;
prev[head] = index;
head = index;
}
}</p>
<p>public final synchronized void addElement(Object key, Object value) {
int index;
Object obj;</p>
<p>obj = table.get(key);</p>
<p>if(obj != null) {
CacheElement entry;</p>
<p>// Just replace the value, but move it to the front.
entry = (CacheElement)obj;
entry.setObjectValue(value);
entry.setObjectKey(key);</p>
<p>moveToFront(entry.getIndex());</p>
<p>return;
}</p>
<p>// If we haven’t filled the cache yet, place in next available spot
// and move to front.
if(!isFull()) {
if(_numEntries &gt; 0) {
prev[_numEntries] = tail;
next[_numEntries] = -1;
moveToFront(numEntries);
}
++numEntries;
} else {
// We replace the tail of the list.
table.remove(cache[tail].getObjectKey());
moveToFront(tail);
}</p>
<p>cache[head].setObjectValue(value);
cache[head].setObjectKey(key);
table.put(key, cache[head]);
}</p>
<p>这段代码的逻辑如 LRU算法 的描述一样，把再次用到的缓存提取到最前面，而每次删除的都是最后面的元素。</p>
<p>结论</p>
<p>我们已经看到 LFU缓存算法 和 LRU缓存算法的实现方式，至于如何实现，采用数组还是 LinkedHashMap，都由你决定，不够我一般是小的缓存容量用数组，大的用LinkedHashMap。
来源： <a href="[http://www.yiihsia.com/2011/01/%e7%bc%93%e5%ad%98%e7%ae%97%e6%b3%95/](http://www.yiihsia.com/2011/01/%e7%bc%93%e5%ad%98%e7%ae%97%e6%b3%95/)">[http://www.yiihsia.com/2011/01/%e7%bc%93%e5%ad%98%e7%ae%97%e6%b3%95/](http://www.yiihsia.com/2011/01/%e7%bc%93%e5%ad%98%e7%ae%97%e6%b3%95/)</a> 
Intro to Caching,Caching algorithms and caching frameworks part 2</p>
<p>Introduction:
In this part we are going to show how to implement some of the famous replacement algorithms as we mentioned in <a href="http://www.jtraining.com/blogs/intro-to-caching-caching-algorithms-and-caching-frameworks.html" target="_blank">part 1</a>, the code in this article is just for demonstration purpose which means you will have to do some extra effort if you want to make use of it in your application (if you are going to build your own implementation and wont use any caching frameworks)</p>
<p>The Leftover policy:</p>
<p>After programmer 1 read the article he proceeded to review the comments on this article, one of these comments were talking about leftover policy, which is named “Random Cache”</p>
<p>Random Cache:</p>
<p>I am random cache, I replace any cache entry I want, I just do that and no one can complain about that, you can say the unlucky entry, by doing this I remove any overhead of tracking references or so, am better than FIFO policy, in some cases I perform even better than LRU but in general LRU is better than me.</p>
<p>It is comment time:</p>
<p>While programmer 1 was reading the rest of the comments, he found very interesting comment about implementation of some of the famous replacement policies, actually it was a link to the commenter site which has the actual implementation so programmer 1 clicked the link and here what he got:</p>
<p>Meet the Cache Element:
public class CacheElement {
private Object objectValue;
private Object objectKey;
private int index;
private int
hitCount;
.
. // getters and setters
.
}</p>
<p>This is the cache entry which will use to hold the key and the value; this will be used in all the cache algorithms implementation</p>
<p>Common Code for All Caches:
public final synchronized void addElement(Object key,Object value) {
int index;
Object obj;
// get the entry from the table
obj = table.get(key);
// If we have the entry already in our table
then get it and replace only its value.
if (obj != null) {
CacheElement
element;
element = (CacheElement) obj;
element.setObjectValue(value);
element.setObjectKey(key);
return;
}
}</p>
<p>The above code will be common for all our implementation; it is about checking if the cacheElemnet already exists in our cache, if so then we just need to place its value and we don’t need to make anything else but what if we didn’t find it ? Then we will have to dig deeper and see what will happen below.</p>
<p>The Talk Show:</p>
<p>Today’s episode is a special episode , we have special guests , they are in fact compotators we are going to hear what everyone has to say but first lets introduce our guests:</p>
<p>Random Cache, FIFO Cache</p>
<p>Let’s start with the Random Cache.</p>
<p>Meet Random Cache implementation:
public final synchronized void addElement(Object key,Object value) {
int index;
Object obj;
obj = table.get(key);
if (obj
!= null) {
CacheElement element;
// Just replace the value.
element = (CacheElement) obj;
element.setObjectValue(value);
element.setObjectKey(key);
return;
}
// If we haven&#39;t
filled the cache yet, put it at the end.
if (!isFull()) {
index =
numEntries;
++numEntries;
} else {
// Otherwise, replace a random
entry.
index = (int) (cache.length /* random.nextFloat());
table.remove(cache[index].getObjectKey());
}
cache[index].setObjectValue(value);
cache[index].setObjectKey(key);
table.put(key, cache[index]);
}</p>
<p>Analyzing Random Cache Code (Talk show):</p>
<p>In today’s show the Random Cache is going to explain the code line by line and here we go.
I will go straight to the main point; if I am not full then I will place the new entry that the client requested at the end of the cache (in case there is a cache miss).</p>
<p>I do this by getting the number of entries that resides in the cache and assign it to index (which will be the index of the current entry the client is adding) after that I increment the number of entries.
if (!isFull()) {
index = numEntries;
++numEntries;
}</p>
<p>If I don’t have enough room for the current entry, I will have to kick out a random entry (totally random, bribing isn’t allowed).</p>
<p>In order to get the random entry, I will use the random util. shipped with java to generate a random index and ask the cache to remove the entry that its index equal to the generated index.
else {
// Otherwise, replace a random entry.
index = (int) (cache.length /* random.nextFloat());
table.remove(cache[index].getObjectKey());
}</p>
<p>At the end I just place the entry -either the cache was full or no- in the cache.</p>
<p>cache[index].setObjectValue(value);
cache[index].setObjectKey(key);
table.put(key, cache[index]);</p>
<p>Magnifying the Code:</p>
<p>It is said that when you look at stuff from a near view it is better to understand it, so that’s why we have a magnifying glass and we are going to magnify the code to get more near to it (and maybe understand it more).</p>
<p>Cache entries in the same voice: hi ho, hi ho, into cache we go.</p>
<p>New cache entry: excuse me; I have a question! (Asking a singing old cache entry near to him)</p>
<p>Old cache entry: go ahead.</p>
<p>New cache entry: I am new here and I don’t understand my role exactly, how will the algorithm handle us?</p>
<p>Old cache entry: cache! (Instead of man!), you remind me of myself when I was new (1st time I was added to the cache), I used to ask questions like that, let me show you what will happen.
<img src="" alt=""></p>
<p>Meet FIFO Cache Implementation:</p>
<p>public final synchronized void addElement(Object
key,Object value) {
int index;
Object obj;
obj = table.get(key);
if (obj != null) {
CacheElement element;
// Just replace the
value.
element = (CacheElement) obj;
element.setObjectValue(value);
element.setObjectKey(key);
return;
}
// If we haven&#39;t
filled the cache yet, put it at the end.
if (!isFull()) {
index =
numEntries;
++numEntries;
} else {
// Otherwise, replace the current
pointer, entry with the new one
index = current;
// in order to make
Circular FIFO
if (++current &gt;= cache.length)
current = 0;
table.remove(cache[index].getObjectKey());
}
cache[index].setObjectValue(value);
cache[index].setObjectKey(key);
table.put(key, cache[index]);
}</p>
<p>Analyzing FIFO Cache Code (Talk show):</p>
<p>After Random Cache, audience went crazy for random cache, which made FIFO a little bit jealous so FIFO started talking and said:</p>
<p>When there is no more rooms for the new cache entry , I will have to kick out the entry at the front (the one came first) as I work in a circular queue like manner, by default the current position is at the beginning of the queue(points to the beginning of the queue).</p>
<p>I assign current value to index (index of the current entry) and then check to see if the incremented current greater than or equals to the cache length(coz I want to reset current –pointer- position to the beginning of the queue) ,if so then I will set current to zero again ,after that I just kick the entry at the index position (Which is the first entry in the queue now) and place the new entry.
else {
// Otherwise, replace the current pointer,
which takes care of
// FIFO in a circular fashion.
index = current;
if (++current &gt;= cache.length)
current = 0;
table.remove(cache[index].getObjectKey());
}
cache[index].setObjectValue(value);
cache[index].setObjectKey(key);
table.put(key, cache[index]);</p>
<p>Magnifying the Code:</p>
<p>Back to our magnifying glass we can observe the following actions happening to our entries</p>
<p><img src="" alt="">Conclusion:</p>
<p>As we have seen in this article how to implement the FIFO replacement policy and also Random replacement policy, in the upcoming articles we will try to take our magnifying glass and magnify LFU, LRU replacement policy, till then stay tuned ;)</p>
<p>来源： <a href="[http://www.jtraining.com/component/content/article/35-jtraining-blog/137.html](http://www.jtraining.com/component/content/article/35-jtraining-blog/137.html)">[http://www.jtraining.com/component/content/article/35-jtraining-blog/137.html](http://www.jtraining.com/component/content/article/35-jtraining-blog/137.html)</a> </p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/Java_多线程/">Java_多线程</a></li><li><a href="/categories/Java&J2EE/Java_多线程/内存/">内存</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/Java_多线程/" class="label label-success">Java_多线程</a><a href="/tags/内存/" class="label label-info">内存</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:41"datetime="2014-03-07 09:54:41"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-Java_多线程-内存--缓存算法/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-Java_多线程-内存--缓存算法" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE--JSTL标签参考手册/">JSTL标签 参考手册</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:41.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE--JSTL标签参考手册/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="jstl-">JSTL标签 参考手册</h1>
<h3 id="-jstl-http-elf8848-iteye-com-blog-245559-"><a href="http://elf8848.iteye.com/blog/245559" target="_blank">JSTL标签 参考手册</a>**</h3>
<p><strong>博客分类：</strong> </p>
<ul>
<li><a href="http://elf8848.iteye.com/category/123165" target="_blank">Servlet/Jsp</a></li>
</ul>
<p><strong>前言</strong></p>
<p>=========================================================================</p>
<p>JSLT标签库，是日常开发经常使用的，也是众多标签中性能最好的。把常用的内容，放在这里备份一份，随用随查。尽量做到不用查，就可以随手就可以写出来。这算是Java程序员的基本功吧，一定要扎实。</p>
<p>JSTL全名为JavaServer Pages Standard Tag Library，目前最新的版本为1.1版。JSTL是由JCP(Java Community Process)所制定的标准规范，它主要提供给Java Web开发人员一个标准通用的标签函数库。
Web程序员能够利用JSTL和EL来开发Web程序，取代传统直接在页面上嵌入Java程序(Scripting)的做法，以提高程序的阅读性、维护性和方便性。
JSTL 1.1必须在支持Servlet 2.4且JSP 2.0以上版本的Container才可使用</p>
<p><strong>&lt;%@ taglib %&gt;引入标签库</strong></p>
<p>=========================================================================</p>
<p>1、以classPath中，加入jar包：  standard-1.1.2.jar ，  jstl-1.1.2.jar</p>
<p>2、在相目\WEB-INF\tld\文件夹中放入常用的tld文件：c.tld，fmt.tld</p>
<p>3、在jsp文件的顶部加入以下内容：
Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"></a></p>
<ol>
<li>&lt;%@ taglib uri=&quot;<a href="http://java.sun.com/jsp/jstl/core" target="_blank">http://java.sun.com/jsp/jstl/core</a>&quot; prefix=&quot;c&quot; %&gt;   </li>
<li>&lt;%@ taglib uri=&quot;<a href="http://java.sun.com/jsp/jstl/fmt" target="_blank">http://java.sun.com/jsp/jstl/fmt</a>&quot; prefix=&quot;fmt&quot;%&gt;  </li>
<li>&lt;%@ taglib uri=&quot;<a href="http://java.sun.com/jsp/jstl/functions" target="_blank">http://java.sun.com/jsp/jstl/functions</a>&quot; prefix=&quot;fn&quot; %&gt;  </li>
</ol>
<p><strong><c:> **</strong>核心标签库 **</p>
<p>==========================================================================</p>
<p>JSTL 核心标签库(C标签)标签共有13个，功能上分为4类：
1.表达式控制标签：out、set、remove、catch
2.流程控制标签：if、choose、when、otherwise
3.循环标签：forEach、forTokens
4.URL操作标签：import、url、redirect</p>
<p><strong><c:forEach> **</strong>标签**</p>
<hr>
<p>为循环控制，它可以将集合(Collection)中的成员循序浏览一遍。</p>
<p><strong> <c:forEach> 标签的语法</strong> <strong>说明</strong> <strong>：</strong></p>
<p>语法1：迭代一集合对象之所有成员
Html代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"></a></p>
<ol>
<li><c:forEach [var="varName"] items="collection" [varStatus="varStatusName"] [begin="begin"] [end="end"] [step="step"]>  </li>
<li>本体内容  </li>
<li></c:forEach>  </li>
</ol>
<p>语法2：迭代指定的次数</p>
<p>Html代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"></a></p>
<ol>
<li><c:forEach [var="varName"] [varStatus="varStatusName"] begin="begin" end="end" [step="step"]>  </li>
<li>本体内容  </li>
<li></c:forEach>  </li>
</ol>
<p><strong><c:forEach> 标签的</strong> <strong>属性说明</strong> <strong>：</strong></p>
<p><img src="&quot;点击查看原始大小图片&quot;" alt=""></p>
<p><strong><c:forEach> 标签的</strong> <strong>属性 ：</strong> varStatus属性： 它的提供另外四个属性:index,count,fist和last，它们个自的意义如下:
Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"></a></p>
<ol>
<li>属性                   类型                                  意义  </li>
<li>index                  number                    现在指到成员的索引  </li>
<li>count                  number                    总共指到成员的总和  </li>
<li>first                  boolean                   现在指到成员是否为第一个  </li>
<li>last                   boolean                   现在指到成员是否为最后一个   </li>
</ol>
<p><strong> <c:forEach> 遍历 List列表：</strong></p>
<p> 对于一个基本类型的数组，当前元素将作为相应包装类（Integer、Float等等）的一个实例提供。
Html代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"></a></p>
<ol>
<li><c:forEach items="${domainList }" var="item">  </li>
<li><tr>  </li>
<li><td align="center" valign="middle">${item[&quot;domain&quot;]==null?&quot;&nbsp;&quot;:item[&quot;domain&quot;]}</td>  </li>
<li><td align="center" valign="middle"><fmt:formatDate value="${item['bind_date']}" pattern="yyyy-MM-dd HH:mm:ss"/></td>  </li>
<li><td align="center" valign="middle">  </li>
<li><c:if test="${item['domain']!=null}">  </li>
<li><a href="javascript:;" id="${item['domain']}" class="del">&nbsp;</a>  </li>
<li></c:if>  </li>
<li></td>  </li>
<li></tr>    </li>
<li></c:forEach>  </li>
</ol>
<p><strong> <c:forEach> 遍历Map:</strong></p>
<p> 对于一个java.util.Map，当前元素则作为一个java.util.Map.Entry提供。
Html代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"></a></p>
<ol>
<li><c:if test="${!empty permissionMap}">    </li>
<li><c:forEach items="${permissionMap}" var="item">  </li>
<li><tr>  </li>
<li><td>${item.value.id}</td>  </li>
<li><td>${item.value.urlOnClass}</td>  </li>
<li><td>${item.value.urlOnMethod}</td>  </li>
<li></tr>  </li>
<li></c:forEach>  </li>
<li></c:if>    </li>
</ol>
<p><strong><c:forTokens> **</strong>标签**</p>
<hr>
<p>用来浏览一字符串中所有的成员，其成员是由定义符号(delimiters)所分隔的。</p>
<p><strong> <c:forTokens> 标签的语法</strong> <strong>说明</strong> <strong>：</strong>
Html代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"></a></p>
<ol>
<li>&lt;c:forTokens items=&quot;stringOfTokens&quot; delims=&quot;delimiters&quot; [var=&quot;varName&quot;]  </li>
<li>[varStatus=&quot;varStatusName&quot;] [begin=&quot;begin&quot;] [end=&quot;end&quot;] [step=&quot;step&quot;]&gt;  </li>
<li>本体内容  </li>
<li></c:forTokens>  </li>
</ol>
<p><strong><c:forTokens> 标签的</strong> <strong>属性说明</strong> <strong>：</strong></p>
<p><img src="" alt=""></p>
<p><strong><c:out> **</strong>标签**</p>
<hr>
<p>主要用来显示数据的内容</p>
<p><strong> <c:out> 标签的语法</strong> <strong>说明</strong> <strong>：</strong></p>
<p>语法1：没有本体(body)内容
Html代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"></a></p>
<ol>
<li><c:out value="value" [escapeXml="{true|false}"] [default="defaultValue"] />  


</li>
</ol>
<p>语法2：有本体内容</p>
<p>Html代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"></a></p>
<ol>
<li><c:out value="value" [escapeXml="{true|false}"]>  </li>
<li>default value  </li>
<li></c:out>  </li>
</ol>
<p><strong><c:forEach> 标签的</strong> <strong>属性说明</strong> <strong>：</strong> 略</p>
<p>一般来说，<c:out>默认会将&lt;、&gt;、’、” 和 &amp; 转换为 &lt;、&gt;、&amp;/#039;、&amp;/#034; 和&amp;。假若不想转换时，只需要设定<c:out>的escapeXml属性为fasle就可以了。</p>
<p><strong><c:set> **</strong>标签**</p>
<hr>
<p>主要用来将变量储存至JSP范围中或是JavaBean的属性中。</p>
<p><strong> <c:set> 标签的语法</strong> <strong>说明</strong> <strong>：</strong></p>
<p>语法1：将value的值储存至范围为scope的 varName 变量之中
Html代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"></a></p>
<ol>
<li><c:set value="value" var="varName" [scope="{ page|request|session|application }"]/>  


</li>
</ol>
<p>语法2：将本体内容的数据储存至范围为scope的 varName 变量之中</p>
<p>Html代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"></a></p>
<ol>
<li><c:set var="varName" [scope="{ page|request|session|application }"]>  </li>
<li>… 本体内容  </li>
<li></c:set>  </li>
</ol>
<p>语法3：将 value的值储存至 target 对象的属性中
Html代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"></a></p>
<ol>
<li><c:set value="value" target="target" property="propertyName" />  


</li>
</ol>
<p>语法4：将本体内容的数据储存至target 对象的属性中</p>
<p>Html代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"></a></p>
<ol>
<li><c:set target="target" property="propertyName">  </li>
<li>… 本体内容  </li>
<li></c:set>  </li>
</ol>
<p><strong><c:set> 标签的</strong> <strong>属性说明</strong> <strong>：</strong></p>
<p><img src="&quot;点击查看原始大小图片&quot;" alt=""></p>
<p><strong><c:remove> **</strong>标签**</p>
<hr>
<p>主要用来移除变量。</p>
<p><strong> <c:remove> 标签的语法</strong> <strong>说明</strong> <strong>：</strong>
Html代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"></a></p>
<ol>
<li><c:remove var="varName" [scope="{ age|request|session|application }"] />  



</li>
</ol>
<p><strong><c:catch> **</strong>标签**</p>
<hr>
<p>主要用来处理产生错误的异常状况，并且将错误信息储存起来。</p>
<p><strong> <c:catch> 标签的语法</strong> <strong>说明</strong> <strong>：</strong>
Html代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"></a></p>
<ol>
<li><c:catch [var="varName"] >  </li>
<li>… 欲抓取错误的部分  </li>
<li></c:catch>  </li>
</ol>
<p><strong><c:if> **</strong>标签**</p>
<hr>
<p>的用途就和我们一般在程序中用的if一样。</p>
<p><strong> <c:if> 标签的语法</strong> <strong>说明</strong> <strong>：</strong></p>
<p>语法1：没有本体内容(body)
Html代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"></a></p>
<ol>
<li><c:if test="testCondition" var="varName" [scope="{page|request|session|application}"]/>  



</li>
</ol>
<p>语法2：有本体内容
Html代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"></a></p>
<ol>
<li><c:if test="testCondition" [var="varName"] [scope="{page|request|session|application}"]>  </li>
<li>本体内容  </li>
<li></c:if>  </li>
</ol>
<p>示例：</p>
<p>Html代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"></a></p>
<ol>
<li><c:if test="${not empty item.publish_time}">  </li>
<li>内容  </li>
<li></c:if>  </li>
<li></li>
<li><c:if test="${item['domain']!=null}">  </li>
<li>内容  </li>
<li></c:if>  </li>
<li></li>
<li><c:if test="${!empty permissionMap}">   </li>
<li>内容  </li>
<li></c:if>  </li>
</ol>
<p><strong>c:choose&gt; <c:when> <c:otherwise>  </strong> <strong>标签</strong></p>
<hr>
<p><strong> <c:choose when otherwise> 标签的语法</strong> <strong>说明</strong> <strong>：</strong>
Html代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"></a></p>
<ol>
<li><c:set var="score">85</c:set>  </li>
<li><c:choose>  </li>
<li><c:when test="${score>=90}">  </li>
<li>你的成绩为优秀！  </li>
<li></c:when>  </li>
<li><c:when test="${score>=70&&score<90}">  </li>
<li>您的成绩为良好!  </li>
<li></c:when>  </li>
<li><c:when test="${score>60&&score<70}">  </li>
<li>您的成绩为及格  </li>
<li></c:when>  </li>
<li><c:otherwise>  </li>
<li>对不起，您没有通过考试！  </li>
<li></c:otherwise>  </li>
<li></c:choose>  </li>
</ol>
<p><strong><fmt:>  </strong> <strong>格式 化标签库 </strong></p>
<p>==========================================================================</p>
<p>一：JSTL格式化标签又称为I18N标签库，主要用来编写国际化的WEB应用，使用此功能可以对一个特定的语言请求做出合适的处理。</p>
<p>例如：中国内地用户将显示简体中文，台湾地区则显示繁体中文，使用I18N格式化标签库还可以格式化数字和日期，例如同一数字或日趋，在不同国家可能有不同的格式，使用I18N格式标签库可以将数字和日期格式为当地的格式。
在JSP页面中要使用到格式化标签，需要引入下面的语句：
&lt;%@ taglib uri=&quot;<a href="http://java.sun.com/jsp/jstl/fmt" target="_blank">http://java.sun.com/jsp/jstl/fmt</a>&quot; prefix=&quot;fmt&quot;% &gt;
<strong>二：概览</strong></p>
<hr>
<pre><code>格式化标签
&lt;fmt:fromatNumber&gt;
&lt;fmt:formatDate&gt;
&lt;fmt:parseDate&gt;
&lt;fmt:parseNumber&gt;
&lt;fmt:setTimeZone&gt;
&lt;fmt:timeZone&gt;
国际化标签
&lt;fmt:setLocale&gt;
&lt;fmt:requestEncoding&gt;
&lt;fmt:bundle&gt;
&lt;fmt:message&gt;
&lt;fmt:param&gt;
&lt;fmt:setBundle&gt;
</code></pre><p><strong>三：<fmt:formatNumber></strong></p>
<hr>
<pre><code>此标签会根据区域定制的方式将数字格式化成数字，货币，百分比。
此标签的属性：
value:要格式化的数字
type：按照什么类型格式化
pattern：自定义格式化样式
currencyCode:ISO-4721货币代码，只适用于按照货币格式化的数字
currencySymbol： 货币符号,如￥,只适用于按照货币格式化的数字
groupingUsed： 是否包含分隔符
maxIntegerDigits： 整数部分最多显示多少位
mixIntegerDigits： 整数部分最少显示多少位
maxFractionDigits： 小数部分最多显示多位位
minFractionDigits： 小数部分最少显示多位位
var:存储格式化后的结果
scope: 存储的范围
示例1：    
</code></pre><p>Java代码 
&lt;%@ page language=&quot;java&quot; pageEncoding=&quot;utf-8&quot;%&gt;<br>&lt;%@ taglib uri=&quot;<a href="http://java.sun.com/jsp/jstl/core" target="_blank">http://java.sun.com/jsp/jstl/core</a>&quot; prefix=&quot;c&quot;%&gt;<br>&lt;%@ taglib uri=&quot;<a href="http://java.sun.com/jsp/jstl/fmt" target="_blank">http://java.sun.com/jsp/jstl/fmt</a>&quot; prefix=&quot;fmt&quot; %&gt;<br>&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;   </p>
<html><br>    <head><br>        <title>chapter4.jsp</title><br>    </head><br>    <body><br>        <div><br>            <div><br>                <fmt:setLocale value="fr_fr"/><br>                <fmt:formatNumber value="123456789.012"/><br>                <br/><br>                <fmt:setLocale value="zh_cn"/><br>                <fmt:formatNumber value="123456789.012"/><br>                <br /><br>                <fmt:setLocale value="de_de"/><br>                <fmt:formatNumber value="123456789.012"/><br>                <br /><br>            </div><br>        </div><br>    </body><br></html><br>&lt;%@ page language=&quot;java&quot; pageEncoding=&quot;utf-8&quot;%&gt;
&lt;%@ taglib uri=&quot;<a href="http://java.sun.com/jsp/jstl/core" target="_blank">http://java.sun.com/jsp/jstl/core</a>&quot; prefix=&quot;c&quot;%&gt;
&lt;%@ taglib uri=&quot;<a href="http://java.sun.com/jsp/jstl/fmt" target="_blank">http://java.sun.com/jsp/jstl/fmt</a>&quot; prefix=&quot;fmt&quot; %&gt;
&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;
<html>
    <head>
        <title>chapter4.jsp</title>
    </head>
    <body>
        <div>
            <div>
                <fmt:setLocale value="fr_fr"/>
                <fmt:formatNumber value="123456789.012"/>
                <br/>
                <fmt:setLocale value="zh_cn"/>
                <fmt:formatNumber value="123456789.012"/>
                <br />
                <fmt:setLocale value="de_de"/>
                <fmt:formatNumber value="123456789.012"/>
                <br /><br>            </div>
        </div>
    </body>
</html>    注意:如果要实现国际化,那么编码格式要设置为utf-8.
          从程序运行效果可以看出,设定的区域不同,格式化数字的显示也会不同.

四：type属性：可以是数字(number),货币(currency),百分比(percent)
    示例2：<br>Java代码 
&lt;%@ page language=&quot;java&quot; pageEncoding=&quot;utf-8&quot;%&gt;<br>&lt;%@ taglib uri=&quot;<a href="http://java.sun.com/jsp/jstl/core" target="_blank">http://java.sun.com/jsp/jstl/core</a>&quot; prefix=&quot;c&quot;%&gt;<br>&lt;%@ taglib uri=&quot;<a href="http://java.sun.com/jsp/jstl/fmt" target="_blank">http://java.sun.com/jsp/jstl/fmt</a>&quot; prefix=&quot;fmt&quot; %&gt;<br>&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;<br><html><br>    <head><br>        <title>chapter4.jsp</title><br>    </head><br>    <body><br>        <div><br>            <div><br>                <fmt:setLocale value="zh_cn"/><br>                <fmt:formatNumber value="0.3" type="number"/><br /><br>                <fmt:formatNumber value="0.3" type="currency"/><br /><br>                <fmt:formatNumber value="0.3" type="percent"/><br /><br>            </div><br>        </div><br>    </body><br></html><br>&lt;%@ page language=&quot;java&quot; pageEncoding=&quot;utf-8&quot;%&gt;
&lt;%@ taglib uri=&quot;<a href="http://java.sun.com/jsp/jstl/core" target="_blank">http://java.sun.com/jsp/jstl/core</a>&quot; prefix=&quot;c&quot;%&gt;
&lt;%@ taglib uri=&quot;<a href="http://java.sun.com/jsp/jstl/fmt" target="_blank">http://java.sun.com/jsp/jstl/fmt</a>&quot; prefix=&quot;fmt&quot; %&gt;
&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;
<html>
    <head>
        <title>chapter4.jsp</title>
    </head>
    <body>
        <div>
            <div>
                <fmt:setLocale value="zh_cn"/>
                <fmt:formatNumber value="0.3" type="number"/><br />
                <fmt:formatNumber value="0.3" type="currency"/><br />
                <fmt:formatNumber value="0.3" type="percent"/><br /><br>            </div>
        </div>
    </body>
</html>     currencyCode为货币代码,例如美元为USD,人民币为CNY等
     currencySymbol为货币符号例如,人民币为￥,美元为$。
     如果不指定区域,则会根据语言区域自动选择currencySymbol
   示例3：<br>Java代码 
&lt;%@ page language=&quot;java&quot; pageEncoding=&quot;utf-8&quot;%&gt;<br>&lt;%@ taglib uri=&quot;<a href="http://java.sun.com/jsp/jstl/core" target="_blank">http://java.sun.com/jsp/jstl/core</a>&quot; prefix=&quot;c&quot;%&gt;<br>&lt;%@ taglib uri=&quot;<a href="http://java.sun.com/jsp/jstl/fmt" target="_blank">http://java.sun.com/jsp/jstl/fmt</a>&quot; prefix=&quot;fmt&quot; %&gt;<br>&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;<br><html><br>    <head><br>        <title>chapter4.jsp</title><br>    </head><br>    <body><br>        <div><br>            <div><br>                <fmt:setLocale value="zh_cn"/><br>                <fmt:formatNumber value="0.3" type="currency"/><br /><br>                <fmt:setLocale value="en_Us"/><br>                <fmt:formatNumber value="0.3" type="currency"/><br /><br>            </div><br>        </div><br>    </body><br></html><br>&lt;%@ page language=&quot;java&quot; pageEncoding=&quot;utf-8&quot;%&gt;
&lt;%@ taglib uri=&quot;<a href="http://java.sun.com/jsp/jstl/core" target="_blank">http://java.sun.com/jsp/jstl/core</a>&quot; prefix=&quot;c&quot;%&gt;
&lt;%@ taglib uri=&quot;<a href="http://java.sun.com/jsp/jstl/fmt" target="_blank">http://java.sun.com/jsp/jstl/fmt</a>&quot; prefix=&quot;fmt&quot; %&gt;
&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;
<html>
    <head>
        <title>chapter4.jsp</title>
    </head>
    <body>
        <div>
            <div>
                <fmt:setLocale value="zh_cn"/>
                <fmt:formatNumber value="0.3" type="currency"/><br />
                <fmt:setLocale value="en_Us"/>
                <fmt:formatNumber value="0.3" type="currency"/><br /><br>            </div>
        </div>
    </body>
</html><br>   currencySymbol属性还可以自定义要显示的头标识,但是一定得type=&quot;currency&quot;才会生效,例如:<br>Java代码 
&lt;%@ page language=&quot;java&quot; pageEncoding=&quot;utf-8&quot;%&gt;<br>&lt;%@ taglib uri=&quot;<a href="http://java.sun.com/jsp/jstl/core" target="_blank">http://java.sun.com/jsp/jstl/core</a>&quot; prefix=&quot;c&quot;%&gt;<br>&lt;%@ taglib uri=&quot;<a href="http://java.sun.com/jsp/jstl/fmt" target="_blank">http://java.sun.com/jsp/jstl/fmt</a>&quot; prefix=&quot;fmt&quot; %&gt;<br>&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;<br><html><br>    <head><br>        <title>chapter4.jsp</title><br>    </head><br>    <body><br>        <div><br>            <div><br>                <fmt:setLocale value="zh_cn"/><br>                <fmt:formatNumber value="0.3" type="currency" currencySymbol="/#"/><br /><br>                <fmt:setLocale value="en_Us"/><br>                <fmt:formatNumber value="0.3" type="currency" currencySymbol="/#"/><br /><br>            </div><br>        </div><br>    </body><br></html><br>&lt;%@ page language=&quot;java&quot; pageEncoding=&quot;utf-8&quot;%&gt;
&lt;%@ taglib uri=&quot;<a href="http://java.sun.com/jsp/jstl/core" target="_blank">http://java.sun.com/jsp/jstl/core</a>&quot; prefix=&quot;c&quot;%&gt;
&lt;%@ taglib uri=&quot;<a href="http://java.sun.com/jsp/jstl/fmt" target="_blank">http://java.sun.com/jsp/jstl/fmt</a>&quot; prefix=&quot;fmt&quot; %&gt;
&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;
<html>
    <head>
        <title>chapter4.jsp</title>
    </head>
    <body>
        <div>
            <div>
                <fmt:setLocale value="zh_cn"/>
                <fmt:formatNumber value="0.3" type="currency" currencySymbol="/#"/><br />
                <fmt:setLocale value="en_Us"/>
                <fmt:formatNumber value="0.3" type="currency" currencySymbol="/#"/><br /><br>            </div>
        </div>
    </body>
</html><br>    自定义数字样式
    <fmt:formatNumber value="12.31" pattern=".0000"/><br/>
    <fmt:formatNumber value="1234" pattern="/#/#/#./#/#E0"/>
    会显示:
    12.3100
    1.234E3
    会四舍五入
    var:定义一个变量,存储格式化后的结果,scope指定变量存储的范围.用法和前面讲的标签一致.

<strong>五：<fmt:parseNumber></strong>
-------------------------------------------------------------------
     此标签用来将字符串类型的数字,货币或百分比转换成数字类型,和<fmt:formatNumber>标签的作用正好相反.
     value: 要转换的字符串
     type: 指定要转换的字符串为什么类型,可取值:number,percent,currency
     pattern: 自定义格式化样式
     parseLocale: 指定区域来转换字符串
     IntegerOnly:  转换后的数字是否只显示整数部分
     var:  存储转换后的结果
     scope: 存储的范围
    示例1:
    <fmt:parseNumber value="500,800,200"/>
    显示: 500800200
    示例2:
    <fmt:parseNumber value="52%" type="percent" />
    显示: 0.52 (52%在这里是一个字符串, type指定这个字符串是什么类型的值)
    示例3:
    <fmt:parseNumber value="￥123" type="currency" />
    显示123, ￥123在这里是一个字符串, type指定这个字符串是什么类型的值
    示例4:
    <fmt:parseNumber value="123.333" type="number" /><br/>
    <fmt:parseNumber value="123.333" type="number"  integerOnly="true"/><br/> 
    显示:
    123.333
    123
    integerOnly确定是否只显示整数部分. 
    示例5:
   <fmt:parseNumber value="￥123.333" type="currency" parseLocale="zh_CN"/><br/>
   <fmt:parseNumber value="$123.333" type="currency" parseLocale="en_US"/><br/>
    parseLocale=&quot;en_US&quot;主要是配合当type=&quot;currency&quot;时用的,
    如果要转换货币的字符串类型为value=&quot;￥123.333&quot;,不设置语言环境的话,会取当前浏览器的默认设置,否则就要加上parseLocale=&quot;zh_CN&quot;,指定环境为中文环境
     如果要转换货币的字符串类型为value=&quot;$123.333&quot;,不设置语言环境的话,会取当前浏览器的默认设置,如果默认为zh_cn的话,程序会报错的,否则就要加上parseLocale=&quot;en_US&quot;,指定环境为英文美国环境
<strong>六：<fmt:formatDate /></strong>
-------------------------------------------------------------------
     此标签可以将日期格式化.
     属性介绍:
     value 用来格式化的时间或日期
     type 指定格式化的是日期还是时间,或者两者都是取值范围:date,time,both
     pattern 自定义格式化样式
     dateStyle 日期的格式化样式
     timeStyle 时间的格式化样式
     timeZone 指定使用的时区
     var 存储格式化后的结果
     scope 指定存储的范围



    自定义格式:<br>
--------------------------
Java代码 
<fmt:setLocale value="zh_cn" /><br><fmt:formatDate value="<%=new Date()%>" type="both" pattern="yyyy/MM/dd hh:mm:ss" /><br><br /><br><fmt:formatDate value="<%=new Date()%>" type="both" pattern="yyyy-MM-dd HH:mm:ss" /><br><br /><br><fmt:formatDate value="<%=new Date()%>" type="both" pattern="yyyy年MM月dd日 hh小时mm分钟ss秒" /><br><br /><br><fmt:formatDate value="<%=new Date()%>" type="both" pattern="yy/MM/dd hh:mm:ss" /><br><br /><br><fmt:setLocale value="zh_cn" />
<fmt:formatDate value="<%=new Date()%>" type="both" pattern="yyyy/MM/dd hh:mm:ss" />
<br />
<fmt:formatDate value="<%=new Date()%>" type="both" pattern="yyyy-MM-dd HH:mm:ss" />
<br />
<fmt:formatDate value="<%=new Date()%>" type="both" pattern="yyyy年MM月dd日 hh小时mm分钟ss秒" />
<br />
<fmt:formatDate value="<%=new Date()%>" type="both" pattern="yy/MM/dd hh:mm:ss" />
<br />     注意这里小时 hh表示12小时制, HH代表24小时制

     示例1：<br>--------------------------
Java代码 
<fmt:setLocale value="zh_cn" /><br><fmt:formatDate value="<%=new Date()%>" /><br><br /><br><fmt:setLocale value="zh_tw" /><br><fmt:formatDate value="<%=new Date()%>" /><br><fmt:setLocale value="zh_cn" />
<fmt:formatDate value="<%=new Date()%>" />
<br />
<fmt:setLocale value="zh_tw" />
<fmt:formatDate value="<%=new Date()%>" /><br>大家可以看到大陆和台湾显示日期的格式是有区别的.
    显示结果:
    2009-12-7 
    2009/12/7
    示例2：<br>--------------------------
Java代码 
<fmt:setLocale value="zh_cn" /><br><fmt:formatDate value="<%=new Date()%>" type="time"/><br><br /><br><fmt:setLocale value="zh_tw" /><br><fmt:formatDate value="<%=new Date()%>" type="time"/><br><fmt:setLocale value="zh_cn" />
<fmt:formatDate value="<%=new Date()%>" type="time"/>
<br />
<fmt:setLocale value="zh_tw" />
<fmt:formatDate value="<%=new Date()%>" type="time"/><br>显示结果:
    14:59:28 
    下午 02:59:28
     type可取值及意义:
     date 格式化日期
     time格式化时间
     both格式化日期时间
     示例3：<br>
--------------------------
Java代码 
<fmt:setLocale value="zh_cn" /><br><fmt:formatDate value="<%=new Date()%>" type="both" /><br><br /><br><fmt:setLocale value="zh_tw" /><br><fmt:formatDate value="<%=new Date()%>" type="both" /><br><fmt:setLocale value="zh_cn" />
<fmt:formatDate value="<%=new Date()%>" type="both" />
<br />
<fmt:setLocale value="zh_tw" />
<fmt:formatDate value="<%=new Date()%>" type="both" /><br>输出结果:
   2009-12-7 21:24:26 
   2009/12/7 下午 09:24:26
   dateStyle用来设定日期显示的样式,其值可以是default, short, medium, long, full,请看示例:<br>--------------------------
Java代码 
<fmt:setLocale value="zh_cn" /><br><fmt:formatDate value="<%=new Date()%>" type="both" dateStyle="default" /><br><br /><br><fmt:formatDate value="<%=new Date()%>" type="both" dateStyle="short" /><br><br /><br><fmt:formatDate value="<%=new Date()%>" type="both" dateStyle="medium" /><br><br /><br><fmt:formatDate value="<%=new Date()%>" type="both" dateStyle="long" /><br><br /><br><fmt:formatDate value="<%=new Date()%>" type="both" dateStyle="full" /><br><br /><br><fmt:setLocale value="zh_cn" />
<fmt:formatDate value="<%=new Date()%>" type="both" dateStyle="default" />
<br />
<fmt:formatDate value="<%=new Date()%>" type="both" dateStyle="short" />
<br />
<fmt:formatDate value="<%=new Date()%>" type="both" dateStyle="medium" />
<br />
<fmt:formatDate value="<%=new Date()%>" type="both" dateStyle="long" />
<br />
<fmt:formatDate value="<%=new Date()%>" type="both" dateStyle="full" />
<br /><br> 显示结果如下:
    2009-12-7 21:30:49 
    09-12-7 21:30:49 
    2009-12-7 21:30:49 
    2009年12月7日 21:30:49 
    2009年12月7日 星期一 21:30:49
    可以看到dateStyle属性只对日期部分起作用,时间部分没有作用.
    timeStyle用来显示时间部分的样式,取值范围同上<br>--------------------------
Java代码 
<fmt:setLocale value="zh_cn" /><br><fmt:formatDate value="<%=new Date()%>" type="both"    timeStyle="default" /><br><br /><br><fmt:formatDate value="<%=new Date()%>" type="both" timeStyle="short" /><br><br /><br><fmt:formatDate value="<%=new Date()%>" type="both" timeStyle="medium" /><br><br /><br><fmt:formatDate value="<%=new Date()%>" type="both" timeStyle="long" /><br><br /><br><fmt:formatDate value="<%=new Date()%>" type="both" timeStyle="full" /><br><br /><br><fmt:setLocale value="zh_cn" />
<fmt:formatDate value="<%=new Date()%>" type="both"    timeStyle="default" />
<br />
<fmt:formatDate value="<%=new Date()%>" type="both" timeStyle="short" />
<br />
<fmt:formatDate value="<%=new Date()%>" type="both" timeStyle="medium" />
<br />
<fmt:formatDate value="<%=new Date()%>" type="both" timeStyle="long" />
<br />
<fmt:formatDate value="<%=new Date()%>" type="both" timeStyle="full" />
<br /><br>输出:
    2009-12-7 21:35:52 
    2009-12-7 下午9:35 
    2009-12-7 21:35:52 
    2009-12-7 下午09时35分52秒 
    2009-12-7 下午09时35分52秒 CST
    timeZone用来设定时区,时区的意思类似于酒店里大堂放的几个时钟,比如现在时间会有北京时间,东京时间,纽约时间,伦墩时间,
   取值范围为:EST, CST, MST, PST<br>--------------------------
Java代码 
<fmt:setLocale value="zh_cn" /><br><fmt:formatDate value="<%=new Date()%>" type="time" timeStyle="full" /><br><br /><br><fmt:formatDate value="<%=new Date()%>" type="time" timeStyle="full" timeZone="EST" /><br><br /><br><fmt:formatDate value="<%=new Date()%>" type="time" timeStyle="full" timeZone="CST" /><br><br /><br><fmt:formatDate value="<%=new Date()%>" type="time" timeStyle="full" timeZone="MST" /><br><br /><br><fmt:formatDate value="<%=new Date()%>" type="time" timeStyle="full" timeZone="PST" /><br><br /><br><fmt:setLocale value="zh_cn" />
<fmt:formatDate value="<%=new Date()%>" type="time" timeStyle="full" />
<br />
<fmt:formatDate value="<%=new Date()%>" type="time" timeStyle="full" timeZone="EST" />
<br />
<fmt:formatDate value="<%=new Date()%>" type="time" timeStyle="full" timeZone="CST" />
<br />
<fmt:formatDate value="<%=new Date()%>" type="time" timeStyle="full" timeZone="MST" />
<br />
<fmt:formatDate value="<%=new Date()%>" type="time" timeStyle="full" timeZone="PST" />
<br />     输出结果:
    下午09时41分37秒 CST 
    上午08时41分37秒 EST 
    上午07时41分37秒 CST 
    上午06时41分37秒 MST 
    上午05时41分37秒 PST
<strong>七：<fmt:parseDate></strong>
-------------------------------------------------------------------
    将字符串类型的时间转换为日期类型.
    value 用来格式化的时间或日期的字符串
    type 指定格式化的是日期还是时间,或者两者都是取值范围:date,time,both
    pattern 自定义格式化样式
    dateStyle 日期的格式化样式
    timeStyle 时间的格式化样式
    timeZone 指定使用的时区
    var 存储格式化后的结果
    scope 指定存储的范围
   示例:
    <fmt:setLocale value="zh_cn" />
    <fmt:parseDate type="date" value="2008-4-5"/>
     输出: Sat Apr 05 00:00:00 CST 2008,
     这里已经将字符串” 2008-4-5”转换为了日期对象了.转换一定得注意,类似于2008-4-5这样的字符串,type必须为date,类似于12:34:56的字符串,type必须为time类似于2008-4-5 12:34:56这样的字符串,type必须为both还要注意浏览器的语言环境的设置,如果为zh_tw,那么字符串就必须得符合当地的标准,如为2009/12/7 下午 09:24:26就正确转换为日期对象,否则就会报错.
<strong>八：<fmt:setTimeZone></strong>
-------------------------------------------------------------------
    value 设定时区
    var 存储设定的时区
    scope 存储的范围
    value用来设定时区,可以是EST,CST,MST,PST等,如果有var属性,则将结果存储在所设定的范围之内.在属性范围内的页面都会使用该时区为默认时区.<br>Java代码 
<fmt:setLocale value="zh_cn" /><br><fmt:setTimeZone value="EST" /><br><fmt:formatDate value="<%=new Date()%>" type="time" timeStyle="full" /><br /><br><fmt:formatDate value="<%=new Date()%>" type="time" timeStyle="full" /><br /><br><fmt:formatDate value="<%=new Date()%>" type="time" timeStyle="full" /><br /><br><fmt:setLocale value="zh_cn" />
<fmt:setTimeZone value="EST" />
<fmt:formatDate value="<%=new Date()%>" type="time" timeStyle="full" /><br />
<fmt:formatDate value="<%=new Date()%>" type="time" timeStyle="full" /><br />
<fmt:formatDate value="<%=new Date()%>" type="time" timeStyle="full" /><br /><br>输出:
   上午09时25分12秒 EST
   上午09时25分12秒 EST
   上午09时25分12秒 EST
    此时区在该页面内都有效
<strong>九：<fmt:timeZone></strong>
-------------------------------------------------------------------
    用来暂时设置时区.<br>Java代码 
<fmt:setLocale value="zh_cn" /><br><fmt:timeZone value="EST"><br><fmt:formatDate value="<%=new Date()%>" type="time" timeStyle="full" /><br><br /><br><fmt:formatDate value="<%=new Date()%>" type="time" timeStyle="full" /><br><br /><br></fmt:timeZone><br><fmt:formatDate value="<%=new Date()%>" type="time" timeStyle="full" /><br><fmt:setLocale value="zh_cn" />
<fmt:timeZone value="EST">
<fmt:formatDate value="<%=new Date()%>" type="time" timeStyle="full" />
<br />
<fmt:formatDate value="<%=new Date()%>" type="time" timeStyle="full" />
<br />
</fmt:timeZone>
<fmt:formatDate value="<%=new Date()%>" type="time" timeStyle="full" /><br>此标签的时区只是部分,在标签开始至标签结束内有效,其它地方无效,其它地方还是会使用默认时区















<strong><fn:> Function标签 **</strong>库 **

==========================================================================



JSTL Functions 标签库中提供了一组常用的 EL 函数，主要用于处理字符串，在 JSP 中可以直接使用这些函数。

在 JSP 文件中使用 Functions 标签库，要先通过 taglib 指令引入该标签库：

&lt;%@taglib uri=”<a href="http://java.sun.com/jsp/jstl/functions”" target="_blank">http://java.sun.com/jsp/jstl/functions”</a> prefix=”fn” %.



## 18.1fn:contains 函数

       fn:contains 函数用于判断在源字符串中是否包含目标字符串，其语法为：

              fn:contains(String source,String target) -------boolean;

       以上 source 参数指定源字符串， target 参数指定目标字符串，返回类型为 boolean 。

       例如对于以下 EL 表达式：

              ${fn:contains(“Tomcat”,”cat”)}

${fn:contains(“Tomcat”,”CAT”)}

       第一个 EL 表达式的值为 true ，第二个 EL 表达式的值为 false 。

## 18.2fn:containsIgnoreCase 函数

       fn:containsIgnoreCase 函数用于判断在源字符串中是否包含目标字符串，并且在判断时忽略大小写，其语法为：

       fn: containsIgnoreCase (String source,String target) -------boolean;

       以上 source 参数指定源字符串， target 参数指定目标字符串，返回类型为 boolean 。

       例如对于以下 EL 表达式：

              ${fn: containsIgnoreCase (“Tomcat”,”CAT”)}

${fn: containsIgnoreCase (“Tomcat”,”Mike”)}

       第一个 EL 表达式的值为 true ，第二个 EL 表达式的值为 false 。

## 18.3 fn:startsWith 函数

       fn:startsWith 函数用于判断源字符串是否以指定的目标字符串开头，其语法为：

              fn:startsWith(String source,String target) ----boolean

       以上 source 参数指定源字符串， target 参数指定目标字符串，返回类型为 boolean 。

       例如对于以下 EL 表达式：

              ${fn: startsWith (“Tomcat”,”Tom”)}

              ${fn: startsWith (“Tomcat”,”cat”)}

       第一个 EL 表达式的值为 true ，第二个 EL 表达式的值为 false 。

## 18.4 fn:endsWith 函数

fn: endsWith 函数用于判断源字符串是否以指定的目标字符串结尾，其语法为：

              fn: endsWith (String source,String target) ----boolean

       以上 source 参数指定源字符串， target 参数指定目标字符串，返回类型为 boolean 。

       例如对于以下 EL 表达式：

              ${fn: endsWith (“Tomcat”,”cat”)}

              ${fn: endsWith (“Tomcat”,”Tom”)}

       第一个 EL 表达式的值为 true ，第二个 EL 表达式的值为 false 。

## 18.5 fn:indexOf 函数

       fn:indexOf 函数用于在源字符串中查找目标字符串，并返回源字符串中最先与目标字符串匹配的第一个字符的索引，如果在源字符串中不包含目标字符串，就返回 -1 ，源字符串中的第一个字符的索引为 0 。 fn:indexOf 函数的语法为：

              fn: indexOf (String source,String target) ----int

       以上 source 参数指定源字符串， target 参数指定目标字符串，返回类型为 int 。

       例如对于以下 EL 表达式：

              1     ${fn: indexOf (“Tomcat”,”cat”)}<br/>

              2     ${fn: indexOf (“2211221”,”21”)} <br/>

              3     ${fn: indexOf (“Tomcat”,”Mike”)} <br/>

       其输出结果为：

              1     3

              2     1

              3     -1

## 18.6 fn:replace 函数

       fn:replace 函数用于把源字符串中的一部分替换为另外的字符串，并返回替换后的字符串。 fn:replace 函数的语法为：

              fn: replace (String source,String before,String after) ----String

       以上 source 参数指定源字符串， before 参数指定源字符串中被替换的子字符串， after 参数指定用于替换的子字符串，返回类型为 String 。

       例如对于以下 EL 表达式：

              1     ${ fn: replace(“TomcAt”,”cAt”,”cat”)}<br/>

              2     ${ fn: replace(“2008/1/9”,”/”,”-”)}<br/>

       其输出结果为：

              1     Tomcat

              2     2008-1-9

## 18.7 fn:substring 函数

       fn:substring 函数用于获取源字符串中的特定子字符串，它的语法为：

              fn:substring(String source,int beginIndex,int endIndex) ------String

       以上 source 参数指定源字符串， beginIndex 参数表示子字符串中的第一个字符在源字符串中的索引，endIndex 参数表示子字符串的最后一个字符在源字符串中的索引加 1 ，返回类型为 String ，源字符串中的第一个字符的索引为 0 。

       例如对于以下 EL 表达式：

              1     ${ fn: substring (“Tomcat”,0,3)}<br/>

              2     ${ fn: substring (“Tomcat”,3,”6”)}<br/>

       其输出结果为：

              1     Tom

              2     cat

## 18.8 fn:substringBefore 函数

       fn:substringBefore 函数用于获取源字符串中指定子字符串之前的子字符串，其语法为：

              fn:substringBefore(String source,String target) ----String

       以上 source 参数指定源字符串， target 参数指定子字符串，返回类型为 String 。如果在源字符串中不包含特定子字符串，就返回空字符串。

       例如对于以下 EL 表达式：

              1     ${ fn: substringBefore (“Tomcat”,”cat”)}<br/>

              2     ${ fn: substringBefore (“mydata.txt”,”.txt”)}<br/>

       其输出结果为：

              1     Tom

              2     mydata

## 18.9 fn:substringAfter 函数

       fn: substringAfter 函数用于获取源字符串中指定子字符串之后的子字符串，其语法为：

              fn: substringAfter (String source,String target) ----String

       以上 source 参数指定源字符串， target 参数指定子字符串，返回类型为 String 。如果在源字符串中不包含特定子字符串，就返回空字符串。

       例如对于以下 EL 表达式：

              1     ${ fn: substringAfter (“Tomcat”,”Tom”)}<br/>

              2     ${ fn: substringAfter (“mydata.txt”,” mydata.”)}<br/>

       其输出结果为：

              1     cat

              2     txt

## 18.10 fn:split 函数

       fn:split 函数用于将源字符串拆分为一个字符串数组，其语法为：

              fn: split (String source,String delimiter) ----String[]

       以上 source 参数指定源字符串， delimiter 参数指定用于拆分源字符串的分隔符，返回类型为 String[] 。如果在源字符串中不包含 delimiter 参数指定的分隔符，或者 delimiter 参数为 null ，那么在返回的字符串数组中只有一个元素，为源字符串。

       例如对于以下 EL 表达式：

              <c:set value=’${ fn: split (“www.mywebsite.org”,”.”)}’ var=”strs”/>

              <c:forEach var=”token” item=”${strs}”>

                     ${token}<br/>

              </c:forEach>

其输出结果为：

       www

       mywebsite

       org

再例如对于以下代码：

       <c:set value=’${ fn: split (“www.mywebsite.org”,”-”)}’ var=”strs”/>

${strs[0]}

其输出结果为：

       www.mywebsite.org

## 18.11 fn:join 函数

       fn:join 函数用于将源字符串数组中的所有字符串连接为一个字符串，其语法为：

              fn:join(String source[],String separator) ----String

       以上 source 参数指定源字符串数组， separator 参数指定用于连接源字符串数组中的各个字符串的分隔符，返回类型为 String 。

       例如对于以下代码：

              &lt;%

              String strs[] = {“www”,”mywebsite”,”org”};

%&gt;

<c:set value=”<%=strs%>” var=”strs”/&gt;

${fn:join(strs,”.”)}

       其输出结果为：

              www. mywebsite. org

## 18.12 fn:toLowerCase 函数

       fn:toLowerCase 函数用于将源字符串中的所有字符改为小写，其语法为：

              fn:toLowerCase(String source)  -----String

       以上 source 参数指定源字符串，返回类型为 String 。

       例如对于以下 EL 表达式：

              fn:toLowerCase(“TomCat”)

       其输出结果为：

              tomcat

## 18.13 fn:toUpperCase 函数

       fn: toUpperCase 函数用于将源字符串中的所有字符改为大写，其语法为：

              fn: toUpperCase (String source)  -----String

       以上 source 参数指定源字符串，返回类型为 String 。

       例如对于以下 EL 表达式：

              fn: toUpperCase (“TomCat”)

       其输出结果为：

              TOMCAT

## 18.14 fn:trim 函数

       fn:trim 函数用于将源字符串中的开头和末尾的空格删除，其语法为：

              fn:trim(String source) ----String

       以上 source 参数指定源字符串，返回类型为 String 。

       例如对于以下 EL 表达式：

              fn:trim(“   Tomcat   ”)

       以上 EL 表达式的值为“ Tomcat ”。

## 18.15 fn:escapeXml 函数

       fn:escapeXml 函数用于将源字符串中的字符“ &lt; ”、“ &gt; ”、“ ” ”和“ &amp; ”等转换为转义字符，本书第 1 章的 1.2 节（ HTML 简介）介绍了转义字符的概念。 fn:escapeXml 函数的行为与 <c:out> 标签的 escapeXml 属性为 true 时的转换行为相同， fn:escapeXml 函数的语法为：

       fn:escapeXml(String source) ----String

       以上 source 参数指定源字符串，返回类型为 String 。

       例程 18-1 的 out.jsp 演示了 fn:escapeXml 函数的用法。

&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;

&lt;%@ taglib uri=&quot;<a href="http://java.sun.com/jsp/jstl/core" target="_blank">http://java.sun.com/jsp/jstl/core</a>&quot; prefix=&quot;c&quot;%&gt;

&lt;%@ taglib uri=&quot;<a href="http://java.sun.com/jsp/jstl/functions" target="_blank">http://java.sun.com/jsp/jstl/functions</a>&quot; prefix=&quot;fn&quot;%&gt;

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />

<title>out</title>

</head>

<body>

1.${fn:escapeXml(&quot;<b> 表示粗体字 </b>&quot;) }<br/>

2.<c:out value="<b> 表示粗体字 </b>" escapeXml="true"></c:out><br/>

3.${&quot;<b> 表示粗体字 </b>&quot;}<br/>

</body>

</html>



<pre><code>   对于 out.jsp 中的以下代码：

          1.${fn:escapeXml(&quot;&lt;b&gt; 表示粗体字 &lt;/b&gt;&quot;) }&lt;br/&gt;
</code></pre><p>2.<c:out value="<b> 表示粗体字 </b>" escapeXml="true"></c:out><br/></p>
<p>3.${&quot;<b> 表示粗体字 </b>&quot;}<br/></p>
<pre><code>   其输出结果为：

          1.&amp;lt;b&amp;gt; 表示粗体字 &amp;lt;/b&amp;gt;&lt;br/&gt;
</code></pre><p>2.&lt;b&gt; 表示粗体字 &lt;/b&gt;<br/></p>
<p>3.<b> 表示粗体字 </b><br/></p>
<h2 id="18-16-fn-length-">18.16 fn:length 函数</h2>
<pre><code>   fn:length 函数用于返回字符串中的字符的个数，或者集合和数组的元素的个数，其语法为：

          fn:length(source) ---- int

   以上 source 参数可以为字符串、集合或者数组，返回类型为 int 。
</code></pre><p>&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;</p>
<pre><code>pageEncoding=&quot;UTF-8&quot;%&gt;
</code></pre><p>&lt;%@ taglib uri=&quot;<a href="http://java.sun.com/jsp/jstl/core" target="_blank">http://java.sun.com/jsp/jstl/core</a>&quot; prefix=&quot;c&quot;%&gt;</p>
<p>&lt;%@ taglib uri=&quot;<a href="http://java.sun.com/jsp/jstl/functions" target="_blank">http://java.sun.com/jsp/jstl/functions</a>&quot; prefix=&quot;fn&quot;%&gt;</p>
<p>&lt;%@page import=&quot;java.util.ArrayList&quot;%&gt;</p>
<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />

<title>length</title>

</head>

<body>

&lt;%

int[] array = {1,2,3,4};

ArrayList list = new ArrayList();

list.add(&quot;one&quot;);

list.add(&quot;two&quot;);

list.add(&quot;three&quot;);

%&gt;

<c:set value="<%=array%>" var="array"></c:set>

<c:set value="<%=list%>" var="list"></c:set>

数组长度： ${fn:length(array)}<br/>

集合长度： ${fn:length(list)}<br/>

字符串长度： ${fn:length(&quot;Tomcat&quot;)}<br/>

</body>

</html>









<p><strong>Functions 标签库概览</strong></p>
<p>l  fn:contains 函数 ： 用于判断在源字符串中是否包含目标字符串。</p>
<p>l  fn:containsIgnoreCase 函数 ： 用于判断在源字符串中是否包含目标字符串 ， 并且在判断时忽略大小写。</p>
<p>l  fn:startsWith 函数 ： 用于判断源字符串是否以指定的目标字符串开头。</p>
<p>l  fn: endsWith 函数：用于判断源字符串是否以指定的目标字符串结尾。</p>
<p>l  fn:indexOf 函数：用于在源字符串中查找目标字符串，并返回源字符串中最先与目标字符串匹配的第一个字符的索引。</p>
<p>l  fn:replace 函数：用于把源字符串中的一部分替换为另外的字符串，并返回替换后的字符串。</p>
<p>l  fn:substring 函数：用于获取源字符串中的特定子字符串。</p>
<p>l  fn:substringBefore 函数：用于获取源字符串中指定子字符串之前的子字符串。</p>
<p>l  fn: substringAfter 函数：用于获取源字符串中指定子字符串之后的子字符串</p>
<p>l  fn:split 函数：用于将源字符串拆分为一个字符串数组。</p>
<p>l  fn:join 函数：用于将源字符串数组中的所有字符串连接为一个字符串。</p>
<p>l  fn:toLowerCase 函数：用于将源字符串中的所有字符改为小写。</p>
<p>l  fn: toUpperCase 函数：用于将源字符串中的所有字符改为大写。</p>
<p>l  fn:trim 函数：用于将源字符串中的开头和末尾的空格删除。</p>
<p>l  fn:escapeXml 函数：用于将源字符串中的字符“ &lt; ”、“ &gt; ”、“ ” ”和“ &amp; ”等转换为转义字符。</p>
<p>l  fn:length 函数：用于返回字符串中的字符的个数，或者集合和数组的元素的个数
来源： <a href="[http://elf8848.iteye.com/blog/245559](http://elf8848.iteye.com/blog/245559)">[http://elf8848.iteye.com/blog/245559](http://elf8848.iteye.com/blog/245559)</a> </p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:41"datetime="2014-03-07 09:54:41"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE--JSTL标签参考手册/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE--JSTL标签参考手册" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_多线程-并发--J2EE事务并发控制策略总结/">J2EE事务并发控制策略总结</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:41.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_多线程-并发--J2EE事务并发控制策略总结/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="j2ee-">J2EE事务并发控制策略总结</h1>
<p>J2EE事务并发控制策略总结</p>
<p>本文结合Hibernate以及JPA标准，对J2EE当前持久层设计所遇到的几个问题进行总结：</p>
<p>事务并发访问控制策略</p>
<p>当前J2EE项目中，面临的一个共同问题就是如果控制事务的并发访问，虽然有些持久层框架已经为我们做了很多工作，但是理解原理，对于我们开发来说还是很有用处的。</p>
<p>事务并发访问主要可以分为两类，分别是同一个系统事务和跨事务访问的并发访问控制，其中同一个系统事务可以采取乐观锁以及悲观锁策略，而跨多个系统事务时则需要乐观离线锁和悲观离线锁。在讨论这四种并发访问控制策略之前，先需要明确一下数据库事务隔离级别的问题，ANSI标准规定了四个数据库事务隔离级别，它们分别是：</p>
<p>读取未提交（Read Uncommitted)</p>
<p>这是最低的事务隔离级别，读事务不会阻塞读事务和写事务，写事务也不会阻塞读事务，但是会阻塞写事务。这样造成的一个结果就是当一个写事务没有提交的时候，读事务照样可以读取，那么造成了脏读的现象。</p>
<p>读取已提交(Read Committed)</p>
<p>采用此种隔离界别的时候，写事务就会阻塞读事务和写事务，但是读事务不会阻塞读事务和写事务，这样因为写事务会阻塞读取事务，那么从而读取事务就不能读到脏数据，但是因为读事务不会阻塞其它的事务，这样还是会造成不可重复读的问题。</p>
<p>可重复读（Repeatable Read)</p>
<p>采用此种隔离级别，读事务会阻塞写事务，但是读事务不会阻塞读事务，但是写事务会阻塞写事务和读事务。因为读事务阻塞了写事务，这样以来就不会造成不可重复读的问题，但是这样还是不能避免幻影读问题。</p>
<p>序列化（serializable)</p>
<p>此种隔离级别是最严格的隔离级别，如果设置成这个级别，那么就不会出现以上所有的问题（脏读，不可重复读，幻影读）。但是这样以来会极大的影响到我们系统的性能，因此我们应该避免设置成为这种隔离级别，相反的，我们应该采用较低的隔离界别，然后再采用并发控制策略来进行事务的并发访问控制）。</p>
<p>其实我们也可以把事务隔离级别设置为serializable，这样就不需要采用并发控制策略了，数据库就会为我们做好一切并发控制，但是这样以来会严重影响我们系统的伸缩性和性能，所以在实践中，我们一般采用读取已提交或者更低的事务隔离级别，配合各种并发访问控制策略来达到并发事务控制的目的。下面总结一下常用的控制策略：</p>
<p>1 乐观锁</p>
<p>乐观锁是在同一个数据库事务中我们常采取的策略，因为它能使得我们的系统保持高的性能的情况下，提高很好的并发访问控制。乐观锁，顾名思义就是保持一种乐观的态度，我们认为系统中的事务并发更新不会很频繁，即使冲突了也没事，大不了重新再来一次。它的基本思想就是每次提交一个事务更新时，我们想看看要修改的东西从上次读取以后有没有被其它事务修改过，如果修改过，那么更新就会失败,。</p>
<p>最后我们需要明确一个问题，因为乐观锁其实并不会锁定任何记录，所以如果我们数据库的事务隔离级别设置为读取已提交或者更低的隔离界别，那么是不能避免不可重复读问题的（因为此时读事务不会阻塞其它事务），所以采用乐观锁的时候，系统应该要容许不可重复读问题的出现。</p>
<p>了解了乐观锁的概念以后，那么当前我们系统中又是如何来使用这种策略的呢？一般可以采用以下三种方法：</p>
<p>版本(Version)字段：在我们的实体中增加一个版本控制字段，每次事务更新后就将版本字段的值加1.</p>
<p>时间戳（timestamps)：采取这种策略后，当每次要提交更新的时候就会将系统当前时间和实体加载时的时间进行比较，如果不一致，那么就报告乐观锁失败，从而回滚事务或者重新尝试提交。采用时间戳有一些不足，比如在集群环境下，每个节点的时间同步也许会成问题，并且如果并发事务间隔时间小于当前平台最小的时钟单位，那么就会发生覆盖前一个事务结果的问题。因此一般采用版本字段比较好。</p>
<p>基于所有属性进行检测：采用这种策略的时候，需要比较每个字段在读取以后有没有被修改过，所以这种策略实现起来比较麻烦，要求对每个属性都进行比较，如果采用hiernate的话，因为Hibernate在一级缓存中可以进行脏检测，那么可以判断那些字段被修改过，从而动态的生成sql语句进行更新。</p>
<p>下面再总结一下如何在JDBC和Hibernate中使用乐观锁：</p>
<p>JDBC中使用乐观锁：如果我们采用JDBC来实现持久层的话，那么就可以采用以上将的三种支持乐观锁的策略，在实体中增加一个version字段或者一个Date字段，也可以采用基于所有属性的策略，下面就采用version字段来做一演示：</p>
<p>假如系统中有一个Account的实体类，我们在Account中多加一个version字段，那么我们JDBC Sql语句将如下写：</p>
<p>Select a.version....from Account as a where (where condition..)
Update Account set version = version+1.....(another field) where version =?...(another contidition)</p>
<p>这样以来我们就可以通过更新结果的行数来进行判断，如果更新结果的行数为0，那么说明实体从加载以来已经被其它事务更改了，所以就抛出自定义的乐观锁定异常（或者也可以采用Spring封装的异常体系）。具体实例如下：</p>
<p>.......
int rowsUpdated = statement.executeUpdate(sql);
If(rowsUpdated= =0){
throws new OptimisticLockingFailureException();
}
........</p>
<p>在使用JDBC API的情况下，我们需要在每个update语句中，都要进行版本字段的更新以及判断，因此如果稍不小心就会出现版本字段没有更新的问题，相反当前的 ORM框架却为我们做好了一切，我们仅仅需要做的就是在每个实体中都增加version或者是Date字段。</p>
<p>Hibernate中使用乐观锁：如果我们采用Hibernate做为持久层的框架，那么实现乐观锁将变得非常容易，因为框架会帮我们生成相应的sql语句，不仅减少了开发人员的负担，而且不容易出错。下面同样采用version字段的方式来总结一下：</p>
<p>同样假如系统中有一个Account的实体类，我们在Account中多加一个version字段，</p>
<p>public class Account{
Long id ;
.......
@Version //也可以采用XML文件进行配置
Int version
.......
}</p>
<p>这样以来每次我们提交事务时，hibernate内部会生成相应的SQL语句将版本字段加1，并且进行相应的版本检测，如果检测到并发乐观锁定异常，那么就抛出StaleObjectStateException.</p>
<p>2 悲观锁</p>
<p>所谓悲观锁，顾名思义就是采用一种悲观的态度来对待事务并发问题，我们认为系统中的并发更新会非常频繁，并且事务失败了以后重来的开销很大，这样以来，我们就需要采用真正意义上的锁来进行实现。悲观锁的基本思想就是每次一个事务读取某一条记录后，就会把这条记录锁住，这样其它的事务要想更新，必须等以前的事务提交或者回滚解除锁。</p>
<p>最后我们还是需要明确一个问题，假如我们数据库事务的隔离级别设置为读取已提交或者更低，那么通过悲观锁，我们控制了不可重复读的问题，但是不能避免幻影读的问题（因为要想避免我们就需要设置数据库隔离级别为Serializable,而一般情况下我们都会采取读取已提交或者更低隔离级别，并配合乐观或者悲观锁来实现并发控制，所以幻影读问题是不能避免的，如果想避免幻影读问题，那么你只能依靠数据库的serializable隔离级别（幸运的是幻影读问题一般情况下不严重）。</p>
<p>下面就分别以JDBC和Hibernate来总结一下：</p>
<p>JDBC中使用悲观锁：在JDBC中使用悲观锁，需要使用select for update语句，假如我们系统中有一个Account的类，我们可以采用如下的方式来进行：</p>
<p>Select /* from Account where ...(where condition).. for update.</p>
<p>当使用了for update语句后，每次在读取或者加载一条记录的时候，都会锁住被加载的记录，那么当其他事务如果要更新或者是加载此条记录就会因为不能获得锁而阻塞，这样就避免了不可重复读以及脏读的问题，但是其他事务还是可以插入和删除记录，这样也许同一个事务中的两次读取会得到不同的结果集，但是这不是悲观锁锁造成的问题，这是我们数据库隔离级别所造成的问题。</p>
<p>最后还需要注意的一点就是每个冲突的事务中，我们必须使用select for update 语句来进行数据库的访问，如果一些事务没有使用select for update语句，那么就会很容易造成错误，这也是采用JDBC进行悲观控制的缺点。</p>
<p>Hibernate中使用悲观锁：相比于JDBC使用悲观锁来说，在Hibernate中使用悲观锁将会容易很多，因为Hibernate有API让我们来调用，从而避免直接写SQL语句。下面就Hibernate使用悲观锁做一总结：</p>
<p>首先先要明确一下Hibernate中支持悲观锁的两种模式LockMode.UPGRADE以LockMode.UPGRADE_NO_WAIT.(PS:在JPA中，对应的锁模式是LockModeType.Read，这与Hibernate是不一样的呵呵)</p>
<p>假如我们系统中有一个Account的类，那么具体的操作可以像这样：</p>
<p>.......
session.lock(account, LockMode.UPGRADE);
......</p>
<p>或者也可以采用如下方式来加载对象：</p>
<p>session.get(Account.class,identity,LockMode.UPGRADE).</p>
<p>这样以来当加载对象时，hibernate内部会生成相应的select for update语句来加载对象，从而锁定对应的记录，避免其它事务并发更新。</p>
<p>以上两种策略都是针对同一个事务而言的，如果我们要实现跨多个事务的并发控制就要采用其它两种并发控制策略了，下面做一总结：</p>
<p>C++与java是两种完全不同风格的东西，C++是由程序员创造的，由程序员完善的，然后才出的标准的，也就是说C++的标准完全落后与C++的发展。java恰好相反，它是先有标准（可能还没有实现），然后后有的实现，而且它是由公司主导开发的，虽然现在开源了，但是标准并不是谁都能定的。这就造就了C++是百花齐放，博大精深，很少有人敢说自己C++很厉害。java却是另外的一种感觉，一切都规定好了，你只需要按照规定去做，符合标准才可以的。所以C++是那种既可以做的堂堂正正，博大精深（比如标准库），又可以实现的匪夷所思，天马行空（写 Boost库的人太牛了）。java不行，java要求如此只能如此，不能越雷池一步。</p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/Java_多线程/">Java_多线程</a></li><li><a href="/categories/Java&J2EE/Java_多线程/并发/">并发</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/Java_多线程/" class="label label-success">Java_多线程</a><a href="/tags/并发/" class="label label-info">并发</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:41"datetime="2014-03-07 09:54:41"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-Java_多线程-并发--J2EE事务并发控制策略总结/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-Java_多线程-并发--J2EE事务并发控制策略总结" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_多线程-并发--Java并发编程之ConcurrentHashMap/">Java并发编程之ConcurrentHashMap</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:41.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_多线程-并发--Java并发编程之ConcurrentHashMap/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="java-concurrenthashmap">Java并发编程之ConcurrentHashMap</h1>
<h3 id="concurrenthashmap">ConcurrentHashMap</h3>
<p>ConcurrentHashMap是一个线程安全的Hash Table，它的主要功能是提供了一组和HashTable功能相同但是线程安全的方法。ConcurrentHashMap可以做到读取数据不加锁，并且其内部的结构可以让其在进行写操作的时候能够将锁的粒度保持地尽量地小，不用对整个ConcurrentHashMap加锁。</p>
<h3 id="concurrenthashmap-">ConcurrentHashMap的内部结构</h3>
<p>ConcurrentHashMap为了提高本身的并发能力，在内部采用了一个叫做Segment的结构，一个Segment其实就是一个类Hash Table的结构，Segment内部维护了一个链表数组，我们用下面这一幅图来看下ConcurrentHashMap的内部结构：
<a href="http://www.yupoo.com/photos/goldendoc/81556254/" title="图表1" target="_blank"><img src="" alt="图表1"></a>
从上面的结构我们可以了解到，ConcurrentHashMap定位一个元素的过程需要进行两次Hash操作，第一次Hash定位到Segment，第二次Hash定位到元素所在的链表的头部，因此，这一种结构的带来的副作用是Hash的过程要比普通的HashMap要长，但是带来的好处是写操作的时候可以只对元素所在的Segment进行加锁即可，不会影响到其他的Segment，这样，在最理想的情况下，ConcurrentHashMap可以最高同时支持Segment数量大小的写操作（刚好这些写操作都非常平均地分布在所有的Segment上），所以，通过这一种结构，ConcurrentHashMap的并发能力可以大大的提高。</p>
<h3 id="segment">Segment</h3>
<p>我们再来具体了解一下Segment的数据结构：
1</p>
<p>2
3</p>
<p>4
5</p>
<p>6
7 static</p>
<p>final</p>
<p>class</p>
<p>Segment<K,V></p>
<p>extends</p>
<p>ReentrantLock</p>
<p>implements</p>
<p>Serializable {</p>
<p>transient</p>
<p>volatile</p>
<p>int</p>
<p>count;</p>
<p>transient</p>
<p>int</p>
<p>modCount;</p>
<p>transient</p>
<p>int</p>
<p>threshold;</p>
<p>transient</p>
<p>volatile</p>
<p>HashEntry<K,V>[] table;</p>
<p>final</p>
<p>float</p>
<p>loadFactor;
}</p>
<p>详细解释一下Segment里面的成员变量的意义：</p>
<ul>
<li>count：Segment中元素的数量</li>
<li>modCount：对table的大小造成影响的操作的数量（比如put或者remove操作）</li>
<li>threshold：阈值，Segment里面元素的数量超过这个值依旧就会对Segment进行扩容</li>
<li>table：链表数组，数组中的每一个元素代表了一个链表的头部</li>
<li>loadFactor：负载因子，用于确定threshold</li>
</ul>
<h3 id="hashentry">HashEntry</h3>
<p>Segment中的元素是以HashEntry的形式存放在链表数组中的，看一下HashEntry的结构：
1</p>
<p>2
3</p>
<p>4
5</p>
<p>6
 static</p>
<p>final</p>
<p>class</p>
<p>HashEntry<K,V> {</p>
<p>final</p>
<p>K key;</p>
<p>final</p>
<p>int</p>
<p>hash;</p>
<p>volatile</p>
<p>V value;</p>
<p>final</p>
<p>HashEntry<K,V> next;</p>
<p>}</p>
<p>可以看到HashEntry的一个特点，除了value以外，其他的几个变量都是final的，这样做是为了防止链表结构被破坏，出现ConcurrentModification的情况。</p>
<h3 id="concurrenthashmap-">ConcurrentHashMap的初始化</h3>
<p>下面我们来结合源代码来具体分析一下ConcurrentHashMap的实现，先看下初始化方法：
1</p>
<p>2
3</p>
<p>4
5</p>
<p>6
7</p>
<p>8
9</p>
<p>10
11</p>
<p>12
13</p>
<p>14
15</p>
<p>16
17</p>
<p>18
19</p>
<p>20
21</p>
<p>22
23</p>
<p>24
25</p>
<p>26
27</p>
<p>28
29</p>
<p>30
31 public</p>
<p>ConcurrentHashMap(</p>
<p>int</p>
<p>initialCapacity,</p>
<p>float</p>
<p>loadFactor,</p>
<p>int</p>
<p>concurrencyLevel) {</p>
<p>if</p>
<p>(!(loadFactor &gt;</p>
<p>0</p>
<p>) || initialCapacity &lt;</p>
<p>0</p>
<p>|| concurrencyLevel &lt;=</p>
<p>0</p>
<p>)</p>
<p>throw</p>
<p>new</p>
<p>IllegalArgumentException();</p>
<p>if</p>
<p>(concurrencyLevel &gt; MAX_SEGMENTS)</p>
<p>concurrencyLevel = MAX_SEGMENTS;</p>
<p>int</p>
<p>sshift =</p>
<p>0</p>
<p>;</p>
<p>int</p>
<p>ssize =</p>
<p>1</p>
<p>;</p>
<p>while</p>
<p>(ssize &lt; concurrencyLevel) {</p>
<p>++sshift;</p>
<p>ssize &lt;&lt;=</p>
<p>1</p>
<p>;</p>
<p>}</p>
<p>segmentShift =</p>
<p>32</p>
<ul>
<li>sshift;</li>
</ul>
<p>segmentMask = ssize -</p>
<p>1</p>
<p>;</p>
<p>this</p>
<p>.segments = Segment.newArray(ssize);</p>
<p>if</p>
<p>(initialCapacity &gt; MAXIMUM_CAPACITY)</p>
<p>initialCapacity = MAXIMUM_CAPACITY;</p>
<p>int</p>
<p>c = initialCapacity / ssize;</p>
<p>if</p>
<p>(c /* ssize &lt; initialCapacity)</p>
<p>++c;</p>
<p>int</p>
<p>cap =</p>
<p>1</p>
<p>;</p>
<p>while</p>
<p>(cap &lt; c)</p>
<p>cap &lt;&lt;=</p>
<p>1</p>
<p>;</p>
<p>for</p>
<p>(</p>
<p>int</p>
<p>i =</p>
<p>0</p>
<p>; i &lt;</p>
<p>this</p>
<p>.segments.length; ++i)</p>
<p>this</p>
<p>.segments[i] =</p>
<p>new</p>
<p>Segment<K,V>(cap, loadFactor);
}</p>
<p>CurrentHashMap的初始化一共有三个参数，一个initialCapacity，表示初始的容量，一个loadFactor，表示负载参数，最后一个是concurrentLevel，代表ConcurrentHashMap内部的Segment的数量，ConcurrentLevel一经指定，不可改变，后续如果ConcurrentHashMap的元素数量增加导致ConrruentHashMap需要扩容，ConcurrentHashMap不会增加Segment的数量，而只会增加Segment中链表数组的容量大小，这样的好处是扩容过程不需要对整个ConcurrentHashMap做rehash，而只需要对Segment里面的元素做一次rehash就可以了。</p>
<p>整个ConcurrentHashMap的初始化方法还是非常简单的，先是根据concurrentLevel来new出Segment，这里Segment的数量是不小于concurrentLevel的最大的2的指数，就是说Segment的数量永远是2的指数个，这样的好处是方便采用移位操作来进行hash，加快hash的过程。接下来就是根据intialCapacity确定Segment的容量的大小，每一个Segment的容量大小也是2的指数，同样使为了加快hash的过程。</p>
<p>这边需要特别注意一下两个变量，分别是segmentShift和segmentMask，这两个变量在后面将会起到很大的作用，假设构造函数确定了Segment的数量是2的n次方，那么segmentShift就等于32减去n，而segmentMask就等于2的n次方减一。</p>
<h3 id="concurrenthashmap-get-">ConcurrentHashMap的get操作</h3>
<p>前面提到过ConcurrentHashMap的get操作是不用加锁的，我们这里看一下其实现：
1</p>
<p>2
3</p>
<p>4
 public</p>
<p>V get(Object key) {</p>
<p>int</p>
<p>hash = hash(key.hashCode());</p>
<p>return</p>
<p>segmentFor(hash).get(key, hash);</p>
<p>}</p>
<p>看第三行，segmentFor这个函数用于确定操作应该在哪一个segment中进行，几乎对ConcurrentHashMap的所有操作都需要用到这个函数，我们看下这个函数的实现：</p>
<p>1</p>
<p>2
3 final</p>
<p>Segment<K,V> segmentFor(</p>
<p>int</p>
<p>hash) {</p>
<p>return</p>
<p>segments[(hash &gt;&gt;&gt; segmentShift) &amp; segmentMask];
}</p>
<p>这个函数用了位操作来确定Segment，根据传入的hash值向右无符号右移segmentShift位，然后和segmentMask进行与操作，结合我们之前说的segmentShift和segmentMask的值，就可以得出以下结论：假设Segment的数量是2的n次方，根据元素的hash值的高n位就可以确定元素到底在哪一个Segment中。</p>
<p>在确定了需要在哪一个segment中进行操作以后，接下来的事情就是调用对应的Segment的get方法：
1</p>
<p>2
3</p>
<p>4
5</p>
<p>6
7</p>
<p>8
9</p>
<p>10
11</p>
<p>12
13</p>
<p>14
15 V get(Object key,</p>
<p>int</p>
<p>hash) {</p>
<p>if</p>
<p>(count !=</p>
<p>0</p>
<p>) {</p>
<p>HashEntry<K,V> e = getFirst(hash);</p>
<p>while</p>
<p>(e !=</p>
<p>null</p>
<p>) {</p>
<p>if</p>
<p>(e.hash == hash &amp;&amp; key.equals(e.key)) {</p>
<p>V v = e.value;</p>
<p>if</p>
<p>(v !=</p>
<p>null</p>
<p>)</p>
<p>return</p>
<p>v;</p>
<p>return</p>
<p>readValueUnderLock(e);</p>
<p>}</p>
<p>e = e.next;</p>
<p>}</p>
<p>}</p>
<p>return</p>
<p>null</p>
<p>;
}</p>
<p>先看第二行代码，这里对count进行了一次判断，其中count表示Segment中元素的数量，我们可以来看一下count的定义：</p>
<p>1 transient</p>
<p>volatile</p>
<p>int</p>
<p>count;</p>
<p>可以看到count是volatile的，实际上这里里面利用了volatile的语义：</p>
<p>对volatile字段的写入操作happens-before于每一个后续的同一个字段的读操作。</p>
<p>因为实际上put、remove等操作也会更新count的值，所以当竞争发生的时候，volatile的语义可以保证写操作在读操作之前，也就保证了写操作对后续的读操作都是可见的，这样后面get的后续操作就可以拿到完整的元素内容。</p>
<p>然后，在第三行，调用了getFirst()来取得链表的头部：
1</p>
<p>2
3</p>
<p>4
 HashEntry<K,V> getFirst(</p>
<p>int</p>
<p>hash) {</p>
<p>HashEntry<K,V>[] tab = table;</p>
<p>return</p>
<p>tab[hash &amp; (tab.length -</p>
<p>1</p>
<p>)];</p>
<p>}</p>
<p>同样，这里也是用位操作来确定链表的头部，hash值和HashTable的长度减一做与操作，最后的结果就是hash值的低n位，其中n是HashTable的长度以2为底的结果。</p>
<p>在确定了链表的头部以后，就可以对整个链表进行遍历，看第4行，取出key对应的value的值，如果拿出的value的值是null，则可能这个key，value对正在put的过程中，如果出现这种情况，那么就加锁来保证取出的value是完整的，如果不是null，则直接返回value。</p>
<h3 id="concurrenthashmap-put-">ConcurrentHashMap的put操作</h3>
<p>看完了get操作，再看下put操作，put操作的前面也是确定Segment的过程，这里不再赘述，直接看关键的segment的put方法：
1</p>
<p>2
3</p>
<p>4
5</p>
<p>6
7</p>
<p>8
9</p>
<p>10
11</p>
<p>12
13</p>
<p>14
15</p>
<p>16
17</p>
<p>18
19</p>
<p>20
21</p>
<p>22
23</p>
<p>24
25</p>
<p>26
27</p>
<p>28
29</p>
<p>30
 V put(K key,</p>
<p>int</p>
<p>hash, V value,</p>
<p>boolean</p>
<p>onlyIfAbsent) {</p>
<p>lock();</p>
<p>try</p>
<p>{</p>
<p>int</p>
<p>c = count;</p>
<p>if</p>
<p>(c++ &gt; threshold)</p>
<p>rehash();</p>
<p>HashEntry<K,V>[] tab = table;</p>
<p>int</p>
<p>index = hash &amp; (tab.length -</p>
<p>1</p>
<p>);</p>
<p>HashEntry<K,V> first = tab[index];</p>
<p>HashEntry<K,V> e = first;</p>
<p>while</p>
<p>(e !=</p>
<p>null</p>
<p>&amp;&amp; (e.hash != hash || !key.equals(e.key)))</p>
<p>e = e.next;</p>
<p>V oldValue;</p>
<p>if</p>
<p>(e !=</p>
<p>null</p>
<p>) {</p>
<p>oldValue = e.value;</p>
<p>if</p>
<p>(!onlyIfAbsent)</p>
<p>e.value = value;</p>
<p>}</p>
<p>else</p>
<p>{</p>
<p>oldValue =</p>
<p>null</p>
<p>;</p>
<p>++modCount;</p>
<p>tab[index] =</p>
<p>new</p>
<p>HashEntry<K,V>(key, hash, first, value);</p>
<p>count = c;</p>
<p>}</p>
<p>return</p>
<p>oldValue;</p>
<p>}</p>
<p>finally</p>
<p>{</p>
<p>unlock();</p>
<p>}</p>
<p>}</p>
<p>首先对Segment的put操作是加锁完成的，然后在第五行，如果Segment中元素的数量超过了阈值（由构造函数中的loadFactor算出）这需要进行对Segment扩容，并且要进行rehash，关于rehash的过程大家可以自己去了解，这里不详细讲了。</p>
<p>第8和第9行的操作就是getFirst的过程，确定链表头部的位置。</p>
<p>第11行这里的这个while循环是在链表中寻找和要put的元素相同key的元素，如果找到，就直接更新更新key的value，如果没有找到，则进入21行这里，生成一个新的HashEntry并且把它加到整个Segment的头部，然后再更新count的值。</p>
<h3 id="concurrenthashmap-remove-">ConcurrentHashMap的remove操作</h3>
<p>Remove操作的前面一部分和前面的get和put操作一样，都是定位Segment的过程，然后再调用Segment的remove方法：
1</p>
<p>2
3</p>
<p>4
5</p>
<p>6
7</p>
<p>8
9</p>
<p>10
11</p>
<p>12
13</p>
<p>14
15</p>
<p>16
17</p>
<p>18
19</p>
<p>20
21</p>
<p>22
23</p>
<p>24
25</p>
<p>26
27</p>
<p>28
29</p>
<p>30
31</p>
<p>32
33 V remove(Object key,</p>
<p>int</p>
<p>hash, Object value) {</p>
<p>lock();</p>
<p>try</p>
<p>{</p>
<p>int</p>
<p>c = count -</p>
<p>1</p>
<p>;</p>
<p>HashEntry<K,V>[] tab = table;</p>
<p>int</p>
<p>index = hash &amp; (tab.length -</p>
<p>1</p>
<p>);</p>
<p>HashEntry<K,V> first = tab[index];</p>
<p>HashEntry<K,V> e = first;</p>
<p>while</p>
<p>(e !=</p>
<p>null</p>
<p>&amp;&amp; (e.hash != hash || !key.equals(e.key)))</p>
<p>e = e.next;</p>
<p>V oldValue =</p>
<p>null</p>
<p>;</p>
<p>if</p>
<p>(e !=</p>
<p>null</p>
<p>) {</p>
<p>V v = e.value;</p>
<p>if</p>
<p>(value ==</p>
<p>null</p>
<p>|| value.equals(v)) {</p>
<p>oldValue = v;</p>
<p>++modCount;</p>
<p>HashEntry<K,V> newFirst = e.next;</p>
<p>for</p>
<p>(HashEntry<K,V> p = first; p != e; p = p.next)</p>
<p>newFirst =</p>
<p>new</p>
<p>HashEntry<K,V>(p.key, p.hash,</p>
<p>newFirst, p.value);</p>
<p>tab[index] = newFirst;</p>
<p>count = c;</p>
<p>}</p>
<p>}</p>
<p>return</p>
<p>oldValue;</p>
<p>}</p>
<p>finally</p>
<p>{</p>
<p>unlock();</p>
<p>}
}</p>
<p>首先remove操作也是确定需要删除的元素的位置，不过这里删除元素的方法不是简单地把待删除元素的前面的一个元素的next指向后面一个就完事了，我们之前已经说过HashEntry中的next是final的，一经赋值以后就不可修改，在定位到待删除元素的位置以后，程序就将待删除元素前面的那一些元素全部复制一遍，然后再一个一个重新接到链表上去，看一下下面这一幅图来了解这个过程：
<a href="http://www.yupoo.com/photos/goldendoc/81555357/" title="1" target="_blank"><img src="" alt="1"></a>
假设链表中原来的元素如上图所示，现在要删除元素3，那么删除元素3以后的链表就如下图所示：
<a href="http://www.yupoo.com/photos/goldendoc/81555358/" title="2" target="_blank"><img src="" alt="2"></a></p>
<h3 id="concurrenthashmap-size-">ConcurrentHashMap的size操作</h3>
<p>在前面的章节中，我们涉及到的操作都是在单个Segment中进行的，但是ConcurrentHashMap有一些操作是在多个Segment中进行，比如size操作，ConcurrentHashMap的size操作也采用了一种比较巧的方式，来尽量避免对所有的Segment都加锁。</p>
<p>前面我们提到了一个Segment中的有一个modCount变量，代表的是对Segment中元素的数量造成影响的操作的次数，这个值只增不减，size操作就是遍历了两次Segment，每次记录Segment的modCount值，然后将两次的modCount进行比较，如果相同，则表示期间没有发生过写入操作，就将原先遍历的结果返回，如果不相同，则把这个过程再重复做一次，如果再不相同，则就需要将所有的Segment都锁住，然后一个一个遍历了，具体的实现大家可以看ConcurrentHashMap的源码，这里就不贴了。
来源： <a href="[http://www.goldendoc.org/2011/06/juc_concurrenthashmap/](http://www.goldendoc.org/2011/06/juc_concurrenthashmap/)">[http://www.goldendoc.org/2011/06/juc_concurrenthashmap/](http://www.goldendoc.org/2011/06/juc_concurrenthashmap/)</a> </p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/Java_多线程/">Java_多线程</a></li><li><a href="/categories/Java&J2EE/Java_多线程/并发/">并发</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/Java_多线程/" class="label label-success">Java_多线程</a><a href="/tags/并发/" class="label label-info">并发</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:41"datetime="2014-03-07 09:54:41"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-Java_多线程-并发--Java并发编程之ConcurrentHashMap/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-Java_多线程-并发--Java并发编程之ConcurrentHashMap" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>





<ul id="pagination" class="pagination pagination-lg">
  <li><a class="extend prev" href="/page/60/">&laquo;</a></li><li><a class="page-number" href="/">1</a></li><li><a class="page-number" href="/page/2/">2</a></li><li><span class="space">&hellip;</span></li><li><a class="page-number" href="/page/58/">58</a></li><li><a class="page-number" href="/page/59/">59</a></li><li><a class="page-number" href="/page/60/">60</a></li><li class="active"><li><span class="page-number current">61</span></li><li><a class="page-number" href="/page/62/">62</a></li><li><a class="page-number" href="/page/63/">63</a></li><li><a class="page-number" href="/page/64/">64</a></li><li><span class="space">&hellip;</span></li></li><li><a class="page-number" href="/page/164/">164</a></li><li><a class="page-number" href="/page/165/">165</a></li><li><a class="extend next" href="/page/62/">&raquo;</a></li>
  <div class="clearfix"></div>
</ul></div><!--wapper-->
       </div><!-- ID main-col END -->
       <aside id="sidebar" class="alignright col-sx-6 col-sm-4 col-md-3 col-lg-3">
<div id="widget_search" class="widget panel panel-primary">
    <form action="//google.com/search" method="get" accept-charset="utf-8">
  <div class="input-group">
    <input class="form-control" id="searchbox" type="search" name="q" results="0" placeholder="search">
    <span class="input-group-btn">
      <button class="btn btn-default" type="submit">Go!</button>
    </span>
    <input type="hidden" name="q" value="site:itsolife.com">
  </div>
</form>
</div>

<div id="widget_category" class="widget panel panel-primary">
  <div class="panel-heading">category</div>  <div data-src='category' class='ajax_widgets'>正在加载...</div>
</div>

<div id="widget_recent_posts" class="widget panel panel-primary">
  <div class="panel-heading">recent posts</div>  <div data-src='recent_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_tagcloud" class="widget panel panel-primary">
  <div class="panel-heading">tagcloud</div>  <div data-src='tagcloud' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_latest_update_posts" class="widget panel panel-primary">
  <div class="panel-heading">最近更新</div>  <div data-src='latest_update_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_recent_comments" class="widget panel panel-primary">
  <div class="panel-heading">recent comments</div>  

<div class="list-group-item ds-recent-comments" data-num-items="6" data-show-avatars="1" data-show-time="1" data-show-title="1" data-show-admin="1" data-excerpt-length="50"></div>



</div>

</aside>
       <div class="clearfix"></div>
     </div><!-- row END -->
  </div>
  <footer id="footer" class="container">
  <div class="panel panel-info">
  <section id='footer_widget'></section>  <div class="panel-footer">
  <div id="site-info">
    <span class='author'>
  
  &copy; 2014 RobinChia
  
    &nbsp;&nbsp;</span>
  
  <span id='analytics-51la'></span><span id='analytics-google'>
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-48559895-1']);
  _gaq.push(['_trackPageview']);
  _js2load.push({src:('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'});
</script></span><span id='analytics-cnzz'>
<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_5774006'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s17.cnzz.com/stat.php%3Fid%3D5774006%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>
</span><span id='analytics-baidu'>
<script>
var _hmt = _hmt || [];
_js2load.push({src:"//hm.baidu.com/hm.js?1442f50724afc42380b51f097c43082c"});
</script>
</span>  </div>
  <div id="copyright">Blog powered by <a href='http://zespia.tw/hexo/'><strong>hexo</strong></a> Theme <strong><a href='https://github.com/chenall/hexo-theme-chenall'>chenall</a></strong>(Some change in it)<span class="pull-right"> 更新时间: <em>2014-03-26 21:21:33</em></span></div>
</div>
<div class="clearfix"></div>


  </div>
  </footer>
  
        <script src="http://cdn.bootcss.com/jquery/1.10.2/jquery.min.js"></script>        
        <script src="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/js/bootstrap.min.js"></script>        
                
        <script src="http://cdn.bootcss.com/prettify/r298/prettify.min.js"></script>    <script type="text/javascript">
   var lang=["bsh", "c", "cc", "cpp", "cs", "csh", "cyc", "cv", "htm", "html",
    "java", "js", "m", "mxml", "perl", "pl", "pm", "py", "rb", "sh",
    "xhtml", "xml", "xsl"];
   var pretty_base='';
   $('script').each(function(){
	var c = $(this).attr('src');
	if (!c)
	    return;
	if (c.match(/(\/)?prettify(\.min)?\.js/i))
	{
	    var index = c.lastIndexOf('/');
	    if (index != -1)
		pretty_base = c.substr(0,index + 1);
	    return false;
	}
   })
   $('pre code').each(function(){
	var c = $(this).attr('class')
	if (!c)
	    return;
	c = c.match(/\s?(lang\-\w+)/i);
	if (c && lang.indexOf(c[1]) == -1)
	{
	    lang.push(c[1]);
	    $.getScript(pretty_base + c[1] + '.min.js');
	}
   })

    $(window).load(function(){
       $("pre").addClass("prettyprint");
       prettyPrint();
    })
</script>    
            <script type="text/javascript">
var duoshuoQuery = {short_name:"robinchia"};
_js2load.push({src:'http://static.duoshuo.com/embed.js',charset:'UTF-8'});
</script>
    
            <!--wumii_relatedItems-->
    
        <script src="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js"></script>    <script type="text/javascript">
(function($){
  $('.entry').each(function(i){
    $(this).find('img').each(function(){
      var alt = this.alt;

      if (alt){
        $(this).before('<span class="caption">' + alt + '</span>');
      }

      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox" rel="fancybox' + i + '" />');
    });
  });

  $('.fancybox').fancybox();
})(jQuery);
</script>    
        <script src="http://cdn.bootcss.com/mathjax/2.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>    <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>
    
<script type="text/javascript">
$('.ajax_widgets').each(function(){var src=$(this).attr('data-src');if(src)$(this).load('/widgets/'+src+'.html');});
$.each(_js2load,function(index,obj){loadjs(obj.src,obj.charset)});
</script>

<div id="scroll2top">
<img src="/scroll2top/arrow.png"/>
</div>
<script src="/scroll2top/scroll2top.min.js"></script>
<div id="winterland">
  <canvas></canvas>
</div>
<script src="/js/winterland.min.js"></script>

  </body>
</html>
