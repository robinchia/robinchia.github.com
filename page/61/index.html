
<!DOCTYPE HTML>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>The 61 Page | It so life</title>
<meta name="author" content="RobinChia">

<meta name="description" content="It so life">


<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<meta property="og:site_name" content="It so life"/>

<!--[if IE]><style>.testIE.IE{display:inline;}</style><![endif]-->
<!--[if lte IE 7]><link rel="stylesheet" href="/css/ie7.css" type="text/css"><![endif]-->
<!--[if (lt IE 9)&(gt IE 7)]><style>.testIE.IE8{display:inline;}</style><![endif]-->
<!--[if gt IE 8]><style>.testIE.IE9{display:inline;}</style><![endif]-->

<link href="/favicon.png" rel="icon">
<link rel="alternate" href="/atom.xml" title="It so life Feed" type="application/atom+xml">

<link rel="stylesheet" href="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/css/bootstrap.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/font-awesome/4.0.3/css/font-awesome.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/prettify/r298/prettify.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" type="text/css">
<link rel="stylesheet" href="/css/style.css" type="text/css">
<!--[if lt IE 9]>
   <style>article,aside,dialog,footer,header,section,footer,nav,figure,menu{display:block}</style>
   <script src="http://cdn.staticfile.org/html5shiv/r29/html5.min.js"></script>
   <script src="http://cdn.staticfile.org/respond.js/1.4.2/respond.min.js"></script>
<link href="http://cdn.staticfile.org/respond.js/1.4.2/respond-proxy.html" id="respond-proxy" rel="respond-proxy" />
<link href="/js/respond.proxy.gif" id="respond-redirect" rel="respond-redirect" />
<script src="/js/respond.proxy.js"></script>
   <script src="http://cdn.bootcss.com/selectivizr/1.0.2/selectivizr-min.js"></script>
<![endif]-->
<script type="text/javascript">
function loadjs(c,d){var a=document.createElement("script");a.async=!0;a.type="text/javascript";a.src=c;a.charset=d||"gbk";(document.getElementsByTagName("HEAD")[0]||document.getElementsByTagName("BODY")[0]).appendChild(a)};
var _protocol = (("https:" == document.location.protocol) ? " https://" : " http://");
var _js2load = [];
</script>

</head>
<body>
      <header id="header" class="container"><nav id="main-nav" class="navbar navbar-default navbar-fixed-top " role="navigation">
  <div class="container">
    <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
      <span class="sr-only">Toggle navigation</span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="/">It so life</a>
    </div>
    <div  class="collapse navbar-collapse">
      <ul  class="nav navbar-nav">
  
        <li><a href="/" title="Home">Home</a></li>      
        <li><a href="/about/" title="About">About</a></li>      
        <li><a href="/archives/" title="Archives">Archives</a></li>      
      <li class='dropdown'>
        <a class='dropdown-toggle' data-toggle='dropdown' href='#'>website<b class='caret'></b></a>
        <ul class='dropdown-menu pure-menu-selected'>
    
          <li><a href="//groups.google.com/forum/#!forum/pongba" title="TopLanguage">TopLanguage</a></li>    
          <li><a href="//itpub.net/" title="ITPub">ITPub</a></li>    
          <li><a href="//blog.jobbole.com/" title="Bole">Bole</a></li>    
          <li><a href="//nosql-database.org/" title="nosql">nosql</a></li>    
          <li><a href="//gitimmersion.googol.im/" title="Git">Git</a></li>    
        </ul>
      </li>
    
      </ul>
      <ul class="nav navbar-nav navbar-right">
      
        <li><a href="/atom.xml">RSS</a></li>
      
      
        <li><a href="https://twitter.com/robinchia">twitter</a></li>
      
      
      
      
        <li><a href="https://github.com/robinchia">github</a></li>
      
      </ul>
    </div>
  </div>
</nav>
<div class="clearfix"></div>
</header>
  <div id='content' class="container">
     <div class="page-header-wrapper">
      <!--[if lt IE 9]><div class="alert alert-warning alert-dismissable"><button type="button" class="close" data-dismiss="alert" aria-hidden="true">&times;</button><strong>提示:</strong>您的浏览器版本太低了,建议升级到 <strong><a href="http://windows.microsoft.com/zh-cn/internet-explorer/download-ie" title="IE9">IE9</a></strong> 以上,本站使用<a href="https://www.google.com/intl/zh-CN/chrome/">Chrome浏览器</a>可以获得最好的显示效果.</div><![endif]-->
      <div class="page-header"><h1 align="center"><big>It so life</big> </h1>
        <h5 align="center"><big>love as life</big></h5>
      </div>
     </div>
     <div class="row">
       <div id="main-col" class="alignleft col-sx-12 col-sm-8 col-md-9 col-lg-9">
      <section id='header_widget'></section>
          <div id="wrapper"><article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE--Tomcat预编译JSP脚本/">Tomcat 预编译JSP 脚本</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:41.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE--Tomcat预编译JSP脚本/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="tomcat-jsp-">Tomcat 预编译JSP 脚本</h1>
<p>参考：</p>
<p>The Apache Jakarta Tomcat 5.5 Servlet/JSP Container Jasper 2 JSP Engine How To</p>
<p><a href="http://jakarta.apache.org/tomcat/tomcat-5.5-doc/jasper-howto.html" target="_blank"><a href="http://jakarta.apache.org/tomcat/tomcat-5.5-doc/jasper-howto.html">http://jakarta.apache.org/tomcat/tomcat-5.5-doc/jasper-howto.html</a></a></p>
<p>jspc</p>
<p><a href="http://ant.apache.org/manual/OptionalTasks/jspc.html" target="_blank"><a href="http://ant.apache.org/manual/OptionalTasks/jspc.html">http://ant.apache.org/manual/OptionalTasks/jspc.html</a></a></p>
<p>用Tomcat进行预编译的ant脚本如下：</p>
<p>build.properties的内容为：</p>
<p>tomcat.home=D:/Tomcat 5.5
webapp.name=blh
webapp.path=D:/Tomcat 5.5/webapps/blh</p>
<p>build.xml的内容为：</p>
<ol>
<li>&lt;?xml version=&quot;1.0&quot; encoding=&quot;GBK&quot;?&gt;</li>
<li><project name="WebApp Precompilation JSP to Java to Class to Jar" basedir="." default="help"></li>
<li><property file="build.properties"/></li>
<li><target name="all" depends="jsp2java,java2class,class2jar,clear"/></li>
<li><target name="help"></li>
<li><echo message="显示功能列表"/></li>
<li><echo message="jsp2java  通过JspC将JSP转换成Java源代码"/></li>
<li><echo message="java2class 将转换后的Java源代码进行编译成class文件"/></li>
<li><echo message="class2jar 将编译后的class文件打包"/></li>
<li><echo message="clear  清理现场"/></li>
<li></target></li>
<li><target name="jsp2java"></li>
<li><taskdef classname="org.apache.jasper.JspC" name="jsp2java"></li>
<li><classpath id="jsp2java.classpath"></li>
<li><fileset dir="${tomcat.home}/bin"></li>
<li><include name="/*.jar"/></li>
<li></fileset></li>
<li><fileset dir="${tomcat.home}/server/lib"></li>
<li><include name="/*.jar"/></li>
<li></fileset></li>
<li><fileset dir="${tomcat.home}/common/lib"></li>
<li><include name="/*.jar"/></li>
<li></fileset></li>
<li></classpath></li>
<li></taskdef></li>
<li><!-- 注意JSP文件要设置为UTF-8编码 --></li>
<li><jsp2java classpath="jsp2java.classpath" javaEncoding="UTF-8" validateXml="false" uriroot="${webapp.path}" webXmlFragment="${webapp.path}/WEB-INF/webJSP.xml" outputDir="${webapp.path}/WEB-INF/JspC/src"/></li>
<li></target></li>
<li><target name="java2class"></li>
<li><mkdir dir="${webapp.path}/WEB-INF/JspC/classes"/></li>
<li><!-- 同样Java文件要设置为UTF-8编码 --></li>
<li><javac srcdir="${webapp.path}/WEB-INF/JspC/src" destdir="${webapp.path}/WEB-INF/JspC/classes" encoding="UTF-8" optimize="off" debug="on" failonerror="false" excludes="/*/*//*.smap"></li>
<li><classpath id="java2class.classpath"></li>
<li><pathelement location="${webapp.path}/WEB-INF/classes"/></li>
<li><fileset dir="${webapp.path}/WEB-INF/lib"></li>
<li><include name="/*.jar"/></li>
<li></fileset></li>
<li><pathelement location="${tomcat.home}/common/classes"/></li>
<li><fileset dir="${tomcat.home}/common/lib"></li>
<li><include name="/*.jar"/></li>
<li></fileset></li>
<li><pathelement location="${tomcat.home}/shared/classes"/></li>
<li><fileset dir="${tomcat.home}/shared/lib"></li>
<li><include name="/*.jar"/></li>
<li></fileset></li>
<li><fileset dir="${tomcat.home}/bin"></li>
<li><include name="/*.jar"/></li>
<li></fileset></li>
<li></classpath></li>
<li><include name="/*/*"/></li>
<li><exclude name="tags//*/*" /></li>
<li></javac></li>
<li></target></li>
<li><target name="class2jar"></li>
<li><mkdir dir="${webapp.path}/WEB-INF/lib"/></li>
<li><jar basedir="${webapp.path}/WEB-INF/JspC/classes" jarfile="${webapp.path}/WEB-INF/lib/${webapp.name}JSP.jar"/></li>
<li></target></li>
<li><target name="clear"></li>
<li><delete dir="${webapp.path}/WEB-INF/JspC/classes"/></li>
<li><delete dir="${webapp.path}/WEB-INF/JspC/src"/></li>
<li><delete dir="${webapp.path}/WEB-INF/JspC"/></li>
<li></target></li>
<li></project></li>
</ol>
<hr>
<p>只需要设置好Ant的path环境变量，然后修改build.properties。执行ant all命令即可。
生成好的jar文件是{$webappname}JSP.jar。
在做为产品发布的时候，只需要你的类jar包和JSP预编译的包放到WEB-INF/lib/目录下即可，如${webappname}.jar和JSP预编译的包${webappname}JSP.jar；
然后删除掉你的所有的预编过的JSP源文件；
并且${webapp.path}/WEB-INF/webJSP.xml里的servlet映射，添加到${webapp.path}/WEB-INF/web.xml中。</p>
<p>来源： <a href="[http://blog.csdn.net/terry_f/article/details/3725382](http://blog.csdn.net/terry_f/article/details/3725382)">[http://blog.csdn.net/terry_f/article/details/3725382](http://blog.csdn.net/terry_f/article/details/3725382)</a> </p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:41"datetime="2014-03-07 09:54:41"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE--Tomcat预编译JSP脚本/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE--Tomcat预编译JSP脚本" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_多线程-并发--聊聊并发（三）——JAVA线程池的分析和使用/">聊聊并发（三）——JAVA线程池的分析和使用</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:41.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_多线程-并发--聊聊并发（三）——JAVA线程池的分析和使用/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-java-">聊聊并发（三）——JAVA线程池的分析和使用</h1>
<h3 id="-">分享到</h3>
<ul>
<li><a href="">一键分享</a></li>
<li><a href="">QQ空间</a></li>
<li><a href="">新浪微博</a></li>
<li><a href="">百度搜藏</a></li>
<li><a href="">人人网</a></li>
<li><a href="">腾讯微博</a></li>
<li><a href="">百度相册</a></li>
<li><a href="">开心网</a></li>
<li><a href="">腾讯朋友</a></li>
<li><a href="">百度贴吧</a></li>
<li><a href="">豆瓣网</a></li>
<li><a href="">搜狐微博</a></li>
<li><a href="">百度新首页</a></li>
<li><a href="">QQ好友</a></li>
<li><a href="">和讯微博</a></li>
<li><a href="">更多...</a></li>
</ul>
<p><a href="">百度分享</a></p>
<ul>
<li><a href="http://www.infoq.com/cn/aboutus" title="关于我们" target="_blank">关于我们</a></li>
<li><p><a href="http://www.infoq.com/cn/contribute" title="让大家在InfoQ上听见你的声音" target="_blank">让大家在InfoQ上听见你的声音</a></p>
</li>
<li><p><a href="http://e.weibo.com/infoqchina" target="_blank"><img src="" alt=""></a></p>
</li>
<li><a href="http://www.infoq.com/cn/news/2013/02/infoq-wechat" target="_blank"><img src="" alt=""></a></li>
<li><a href="http://www.infoq.com/cn/rss/rss.action?token=J6EBu2hcpyEuMs9msdo8GyNCZTcWG7pm" target="_blank"><img src="" alt=""></a></li>
</ul>
<h1 id="-java-">聊聊并发（三）——JAVA线程池的分析和使用</h1>
<p>作者 <a href="http://www.infoq.com/cn/author/%E6%96%B9%E8%85%BE%E9%A3%9E" target="_blank">方腾飞</a> 发布于 十一月 15, 2012 <em>|</em> <a href="">14 评论</a></p>
<h2 id="1-">1. 引言</h2>
<p>合理利用线程池能够带来三个好处。第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。第二：提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。第三：提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。但是要做到合理的利用线程池，必须对其原理了如指掌。</p>
<h2 id="2-">2. 线程池的使用</h2>
<p><strong>线程池的创建</strong></p>
<p>我们可以通过ThreadPoolExecutor来创建一个线程池。
new ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, milliseconds,runnableTaskQueue, handler);</p>
<p>创建一个线程池需要输入几个参数：</p>
<ul>
<li>corePoolSize（线程池的基本大小）：当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于线程池基本大小时就不再创建。如果调用了线程池的prestartAllCoreThreads方法，线程池会提前创建并启动所有基本线程。</li>
<li><p>runnableTaskQueue（任务队列）：用于保存等待执行的任务的阻塞队列。 可以选择以下几个阻塞队列。</p>
</li>
<li><p>ArrayBlockingQueue：是一个基于数组结构的有界阻塞队列，此队列按 FIFO（先进先出）原则对元素进行排序。</p>
</li>
<li>LinkedBlockingQueue：一个基于链表结构的阻塞队列，此队列按FIFO （先进先出） 排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列。</li>
<li>SynchronousQueue：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQueue，静态工厂方法Executors.newCachedThreadPool使用了这个队列。</li>
<li>PriorityBlockingQueue：一个具有优先级的无限阻塞队列。</li>
<li>maximumPoolSize（线程池最大大小）：线程池允许创建的最大线程数。如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。值得注意的是如果使用了无界的任务队列这个参数就没什么效果。</li>
<li>ThreadFactory：用于设置创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置更有意义的名字。</li>
<li><p>RejectedExecutionHandler（饱和策略）：当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。这个策略默认情况下是AbortPolicy，表示无法处理新任务时抛出异常。以下是JDK1.5提供的四种策略。</p>
</li>
<li><p>AbortPolicy：直接抛出异常。</p>
</li>
<li>CallerRunsPolicy：只用调用者所在线程来运行任务。</li>
<li>DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务。</li>
<li>DiscardPolicy：不处理，丢弃掉。</li>
<li>当然也可以根据应用场景需要来实现RejectedExecutionHandler接口自定义策略。如记录日志或持久化不能处理的任务。</li>
<li>keepAliveTime（线程活动保持时间）：线程池的工作线程空闲后，保持存活的时间。所以如果任务很多，并且每个任务执行的时间比较短，可以调大这个时间，提高线程的利用率。</li>
<li>TimeUnit（线程活动保持时间的单位）：可选的单位有天（DAYS），小时（HOURS），分钟（MINUTES），毫秒(MILLISECONDS)，微秒(MICROSECONDS, 千分之一毫秒)和毫微秒(NANOSECONDS, 千分之一微秒)。</li>
</ul>
<p><strong>向线程池提交任务</strong></p>
<p>我们可以使用execute提交的任务，但是execute方法没有返回值，所以无法判断任务是否被线程池执行成功。通过以下代码可知execute方法输入的任务是一个Runnable类的实例。
threadsPool.execute(new Runnable() { @Override public void run() { // TODO Auto-generated method stub } });</p>
<p>我们也可以使用submit 方法来提交任务，它会返回一个future,那么我们可以通过这个future来判断任务是否执行成功，通过future的get方法来获取返回值，get方法会阻塞住直到任务完成，而使用get(long timeout, TimeUnit unit)方法则会阻塞一段时间后立即返回，这时有可能任务没有执行完。</p>
<p>Future<Object> future = executor.submit(harReturnValuetask); try { Object s = future.get(); } catch (InterruptedException e) { // 处理中断异常 } catch (ExecutionException e) { // 处理无法执行任务异常 } finally { // 关闭线程池 executor.shutdown(); }</p>
<p><strong>线程池的关闭</strong></p>
<p>我们可以通过调用线程池的shutdown或shutdownNow方法来关闭线程池，它们的原理是遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法终止。但是它们存在一定的区别，shutdownNow首先将线程池的状态设置成STOP，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表，而shutdown只是将线程池的状态设置成SHUTDOWN状态，然后中断所有没有正在执行任务的线程。</p>
<p>只要调用了这两个关闭方法的其中一个，isShutdown方法就会返回true。当所有的任务都已关闭后,才表示线程池关闭成功，这时调用isTerminaed方法会返回true。至于我们应该调用哪一种方法来关闭线程池，应该由提交到线程池的任务特性决定，通常调用shutdown来关闭线程池，如果任务不一定要执行完，则可以调用shutdownNow。</p>
<h2 id="3-">3. 线程池的分析</h2>
<p>流程分析：线程池的主要工作流程如下图：</p>
<p><img src="" alt=""></p>
<p>从上图我们可以看出，当提交一个新任务到线程池时，线程池的处理流程如下：</p>
<ol>
<li>首先线程池判断<strong>基本线程池</strong>是否已满？没满，创建一个工作线程来执行任务。满了，则进入下个流程。</li>
<li>其次线程池判断<strong>工作队列</strong>是否已满？没满，则将新提交的任务存储在工作队列里。满了，则进入下个流程。</li>
<li>最后线程池判断<strong>整个线程池</strong>是否已满？没满，则创建一个新的工作线程来执行任务，满了，则交给饱和策略来处理这个任务。</li>
</ol>
<p><strong>源码分析</strong>。上面的流程分析让我们很直观的了解了线程池的工作原理，让我们再通过源代码来看看是如何实现的。线程池执行任务的方法如下：
public void execute(Runnable command) { if (command == null) throw new NullPointerException(); //如果线程数小于基本线程数，则创建线程并执行当前任务 if (poolSize &gt;= corePoolSize || !addIfUnderCorePoolSize(command)) { //如线程数大于等于基本线程数或线程创建失败，则将当前任务放到工作队列中。 if (runState == RUNNING &amp;&amp; workQueue.offer(command)) { if (runState != RUNNING || poolSize == 0) ensureQueuedTaskHandled(command); } //如果线程池不处于运行中或任务无法放入队列，并且当前线程数量小于最大允许的线程数量， 则创建一个线程执行任务。 else if (!addIfUnderMaximumPoolSize(command)) //抛出RejectedExecutionException异常 reject(command); // is shutdown or saturated } }</p>
<p><strong>工作线程</strong>。线程池创建线程时，会将线程封装成工作线程Worker，Worker在执行完任务后，还会无限循环获取工作队列里的任务来执行。我们可以从Worker的run方法里看到这点：</p>
<p>public void run() { try { Runnable task = firstTask; firstTask = null; while (task != null || (task = getTask()) != null) { runTask(task); task = null; } } finally { workerDone(this); } }</p>
<h2 id="4-">4. 合理的配置线程池</h2>
<p>要想合理的配置线程池，就必须首先分析任务特性，可以从以下几个角度来进行分析：</p>
<ol>
<li>任务的性质：CPU密集型任务，IO密集型任务和混合型任务。</li>
<li>任务的优先级：高，中和低。</li>
<li>任务的执行时间：长，中和短。</li>
<li>任务的依赖性：是否依赖其他系统资源，如数据库连接。</li>
</ol>
<p>任务性质不同的任务可以用不同规模的线程池分开处理。CPU密集型任务配置尽可能小的线程，如配置Ncpu+1个线程的线程池。IO密集型任务则由于线程并不是一直在执行任务，则配置尽可能多的线程，如2/*Ncpu。混合型的任务，如果可以拆分，则将其拆分成一个CPU密集型任务和一个IO密集型任务，只要这两个任务执行的时间相差不是太大，那么分解后执行的吞吐率要高于串行执行的吞吐率，如果这两个任务执行时间相差太大，则没必要进行分解。我们可以通过Runtime.getRuntime().availableProcessors()方法获得当前设备的CPU个数。</p>
<p>优先级不同的任务可以使用优先级队列PriorityBlockingQueue来处理。它可以让优先级高的任务先得到执行，需要注意的是如果一直有优先级高的任务提交到队列里，那么优先级低的任务可能永远不能执行。</p>
<p>执行时间不同的任务可以交给不同规模的线程池来处理，或者也可以使用优先级队列，让执行时间短的任务先执行。</p>
<p>依赖数据库连接池的任务，因为线程提交SQL后需要等待数据库返回结果，如果等待的时间越长CPU空闲时间就越长，那么线程数应该设置越大，这样才能更好的利用CPU。</p>
<p>建议使用有界队列，有界队列能增加系统的稳定性和预警能力，可以根据需要设大一点，比如几千。有一次我们组使用的后台任务线程池的队列和线程池全满了，不断的抛出抛弃任务的异常，通过排查发现是数据库出现了问题，导致执行SQL变得非常缓慢，因为后台任务线程池里的任务全是需要向数据库查询和插入数据的，所以导致线程池里的工作线程全部阻塞住，任务积压在线程池里。如果当时我们设置成无界队列，线程池的队列就会越来越多，有可能会撑满内存，导致整个系统不可用，而不只是后台任务出现问题。当然我们的系统所有的任务是用的单独的服务器部署的，而我们使用不同规模的线程池跑不同类型的任务，但是出现这样问题时也会影响到其他任务。</p>
<h2 id="5-">5. 线程池的监控</h2>
<p>通过线程池提供的参数进行监控。线程池里有一些属性在监控线程池的时候可以使用</p>
<ul>
<li>taskCount：线程池需要执行的任务数量。</li>
<li>completedTaskCount：线程池在运行过程中已完成的任务数量。小于或等于taskCount。</li>
<li>largestPoolSize：线程池曾经创建过的最大线程数量。通过这个数据可以知道线程池是否满过。如等于线程池的最大大小，则表示线程池曾经满了。</li>
<li>getPoolSize:线程池的线程数量。如果线程池不销毁的话，池里的线程不会自动销毁，所以这个大小只增不+ getActiveCount：获取活动的线程数。</li>
</ul>
<p>通过扩展线程池进行监控。通过继承线程池并重写线程池的beforeExecute，afterExecute和terminated方法，我们可以在任务执行前，执行后和线程池关闭前干一些事情。如监控任务的平均执行时间，最大执行时间和最小执行时间等。这几个方法在线程池里是空方法。如：
protected void beforeExecute(Thread t, Runnable r) { }</p>
<h2 id="6-">6. 参考资料</h2>
<ul>
<li>Java并发编程实战。</li>
<li>JDK1.6源码</li>
</ul>
<h2 id="-">作者介绍</h2>
<p><strong>方腾飞</strong>，花名清英，淘宝资深开发工程师，关注并发编程，目前在广告技术部从事无线广告联盟的开发和设计工作。个人博客：<a href="http://ifeve.com/" target="_blank"><a href="http://ifeve.com">http://ifeve.com</a></a> 微博：<a href="http://weibo.com/kirals" target="_blank"><a href="http://weibo.com/kirals">http://weibo.com/kirals</a></a> 欢迎通过我的微博进行技术交流。</p>
<p>感谢<a href="http://www.infoq.com/cn/bycategory.action?authorName=张龙" target="_blank">张龙</a>对本文的审校。</p>
<p>给InfoQ中文站投稿或者参与内容翻译工作，请邮件至<a href="mailto:editors@cn.infoq.com">editors@cn.infoq.com</a>。也欢迎大家通过新浪微博（<a href="http://www.weibo.com/infoqchina" target="_blank">@InfoQ</a>）或者腾讯微博（<a href="http://t.qq.com/infoqchina" target="_blank">@InfoQ</a>）关注我们，并与我们的编辑和其他读者朋友交流。</p>
<ul>
<li><a href="">Sections</a></li>
<li><a href="http://www.infoq.com/cn/development" target="_blank"><strong>语言 &amp; 开发</strong></a></li>
<li><a href="">Topics</a></li>
<li><a href="http://www.infoq.com/cn/threading" target="_blank">线程技术</a></li>
<li><a href="http://www.infoq.com/cn/Multi-threading" target="_blank">多线程</a></li>
<li><a href="http://www.infoq.com/cn/concurrency" target="_blank">并发</a></li>
<li><a href="http://www.infoq.com/cn/java" target="_blank">Java</a></li>
<li><a href="http://www.infoq.com/cn/threadPool" target="_blank">线程池</a></li>
<li><a href="http://www.infoq.com/cn/thread" target="_blank">线程</a></li>
</ul>
<p>相关内容</p>
<h3 id="-java-http-www-infoq-com-cn-articles-java-memory-model-7-utm_source-infoq-utm_medium-related_content_link-utm_campaign-relatedcontent_articles_clk-"><a href="http://www.infoq.com/cn/articles/java-memory-model-7?utm_source=infoq&amp;utm_medium=related_content_link&amp;utm_campaign=relatedContent_articles_clk" target="_blank">深入理解Java内存模型（七）——总结</a></h3>
<h3 id="-java-final-http-www-infoq-com-cn-articles-java-memory-model-6-utm_source-infoq-utm_medium-related_content_link-utm_campaign-relatedcontent_articles_clk-"><a href="http://www.infoq.com/cn/articles/java-memory-model-6?utm_source=infoq&amp;utm_medium=related_content_link&amp;utm_campaign=relatedContent_articles_clk" target="_blank">深入理解Java内存模型（六）——final</a></h3>
<h3 id="-java-http-www-infoq-com-cn-articles-java-memory-model-5-utm_source-infoq-utm_medium-related_content_link-utm_campaign-relatedcontent_articles_clk-"><a href="http://www.infoq.com/cn/articles/java-memory-model-5?utm_source=infoq&amp;utm_medium=related_content_link&amp;utm_campaign=relatedContent_articles_clk" target="_blank">深入理解Java内存模型（五）——锁</a></h3>
<h3 id="-concurrentlinkedqueue-http-www-infoq-com-cn-articles-concurrentlinkedqueue-utm_source-infoq-utm_medium-related_content_link-utm_campaign-relatedcontent_articles_clk-"><a href="http://www.infoq.com/cn/articles/ConcurrentLinkedQueue?utm_source=infoq&amp;utm_medium=related_content_link&amp;utm_campaign=relatedContent_articles_clk" target="_blank">聊聊并发（六）——ConcurrentLinkedQueue的实现原理分析</a></h3>
<h3 id="-http-www-infoq-com-cn-articles-atomic-operation-utm_source-infoq-utm_medium-related_content_link-utm_campaign-relatedcontent_articles_clk-"><a href="http://www.infoq.com/cn/articles/atomic-operation?utm_source=infoq&amp;utm_medium=related_content_link&amp;utm_campaign=relatedContent_articles_clk" target="_blank">聊聊并发（五）——原子操作的实现原理</a></h3>
<h3 id="-java-http-www-infoq-com-cn-articles-java-memory-model-7-utm_source-infoq-utm_medium-related_content_link-utm_campaign-relatedcontent_articles_clk-"><a href="http://www.infoq.com/cn/articles/java-memory-model-7?utm_source=infoq&amp;utm_medium=related_content_link&amp;utm_campaign=relatedContent_articles_clk" target="_blank">深入理解Java内存模型（七）——总结</a></h3>
<h3 id="-java-final-http-www-infoq-com-cn-articles-java-memory-model-6-utm_source-infoq-utm_medium-related_content_link-utm_campaign-relatedcontent_articles_clk-"><a href="http://www.infoq.com/cn/articles/java-memory-model-6?utm_source=infoq&amp;utm_medium=related_content_link&amp;utm_campaign=relatedContent_articles_clk" target="_blank">深入理解Java内存模型（六）——final</a></h3>
<h3 id="-java-http-www-infoq-com-cn-articles-java-memory-model-5-utm_source-infoq-utm_medium-related_content_link-utm_campaign-relatedcontent_articles_clk-"><a href="http://www.infoq.com/cn/articles/java-memory-model-5?utm_source=infoq&amp;utm_medium=related_content_link&amp;utm_campaign=relatedContent_articles_clk" target="_blank">深入理解Java内存模型（五）——锁</a></h3>
<h3 id="-java-http-www-infoq-com-cn-minibooks-java_memory_model-utm_source-infoq-utm_medium-related_content_link-utm_campaign-relatedcontent_articles_clk-"><a href="http://www.infoq.com/cn/minibooks/java_memory_model?utm_source=infoq&amp;utm_medium=related_content_link&amp;utm_campaign=relatedContent_articles_clk" target="_blank">深入理解Java内存模型</a></h3>
<h3 id="-java-volatile-http-www-infoq-com-cn-articles-java-memory-model-4-utm_source-infoq-utm_medium-related_content_link-utm_campaign-relatedcontent_articles_clk-"><a href="http://www.infoq.com/cn/articles/java-memory-model-4?utm_source=infoq&amp;utm_medium=related_content_link&amp;utm_campaign=relatedContent_articles_clk" target="_blank">深入理解Java内存模型（四）——volatile</a></h3>
<h2 id="-">您好，陌生人！</h2>
<p>您需要 <a href="http://www.infoq.com/reginit.action" target="_blank">注册一个InfoQ账号</a> 或者 <a href="">登录</a> 才能进行评论。在您完成注册后还需要进行一些设置。</p>
<h2 id="-infoq-">获得来自InfoQ的更多体验。<a href=""></a></h2>
<p>允许的HTML标签: a,b,br,blockquote,i,li,pre,u,ul,p</p>
<p>当有人回复此评论时请E-mail通知我</p>
<p>社区评论 <a href="">Watch Thread</a></p>
<p><a href=""><strong>拜读，有一些困惑望解答</strong> by 史 雨鑫 Posted 16/11/2012 03:19</a>
<a href=""><strong>Re: 拜读，有一些困惑望解答</strong> by 方 腾飞 Posted 16/11/2012 05:06</a></p>
<p><a href=""><strong>Re: 拜读，有一些困惑望解答</strong> by 萧 欢 Posted 18/11/2012 12:57</a>
<a href=""><strong>Re: 拜读，有一些困惑望解答</strong> by 方 腾飞 Posted 18/11/2012 02:43</a></p>
<p><a href=""><strong>能谈谈thread pool和多核CPU的关系吗？ 怎样能保证thread pool的配置，让其能够最大化的压栈多核cpu</strong> by biao jiang Posted 20/11/2012 11:02</a>
<a href=""><strong>Re: 能谈谈thread pool和多核CPU的关系吗？ 怎样能保证thread pool的配置，让其能够最大化的压栈多核cpu</strong> by 萧 欢 Posted 20/11/2012 02:26</a></p>
<p><a href=""><strong>Re: 能谈谈thread pool和多核CPU的关系吗？ 怎样能保证thread pool的配置，让其能够最大化的压栈多核cpu</strong> by 老 bull Posted 22/11/2012 11:48</a>
<a href=""><strong>Re: 能谈谈thread pool和多核CPU的关系吗？ 怎样能保证thread pool的配置，让其能够最大化的压栈多核cpu</strong> by 方 腾飞 Posted 26/11/2012 00:00</a></p>
<p><a href=""><strong>使用的一些问题?</strong> by Qiao stephen Posted 25/02/2013 02:23</a>
<a href=""><strong>Re: 使用的一些问题?</strong> by vince vince Posted 16/04/2013 02:45</a></p>
<p><a href=""><strong>不知道是不是错误</strong> by 高 鹏翔 Posted 29/03/2013 01:53</a>
<a href=""><strong>Re: 不知道是不是错误</strong> by 方 腾飞 Posted 18/05/2013 01:25</a></p>
<p><a href=""><strong>昨晚再次阅读了该文，有几个问题需要解答</strong> by 王 明军 Posted 27/05/2013 09:11</a>
<a href=""><strong>Re: 昨晚再次阅读了该文，有几个问题需要解答</strong> by 方 腾飞 Posted 13/06/2013 03:38</a>
<a href=""></a></p>
<p><strong>拜读，有一些困惑望解答</strong> 16/11/2012 03:19 by 史 雨鑫</p>
<p>腾飞，线程池分析小节中，“队列是否满了”-&gt;”线程池是否满了“过程中，假设使用ArrayBlockingQueue队列，文中提到如果队列满了，并且线程池没满，则会新建线程处理此任务，那问题是此任务有可能会在队列任务被执行前执行，这样就不满足”先进先出“原则了吧？望解答。</p>
<ul>
<li><a href="">回复</a></li>
<li><a href="">回到顶部</a></li>
</ul>
<p><a href=""></a></p>
<p><strong>Re: 拜读，有一些困惑望解答</strong> 16/11/2012 05:06 by 方 腾飞</p>
<p>此任务是提交给线程池执行的新任务，不在队列里。队列里的任务存储的都是以前提交的任务，它们需要等待线程空闲时来执行。</p>
<ul>
<li><a href="">回复</a></li>
<li><a href="">回到顶部</a>
<a href=""></a></li>
</ul>
<p><strong>Re: 拜读，有一些困惑望解答</strong> 18/11/2012 12:57 by 萧 欢</p>
<p>你的理解是对的。如果在创建线程池的时候，指定的corePoolSize<maximumPoolsize是会出现你说的这种情况，这在线程池机制中称为“应急处理”。如果你的线程池模型用于任务有严格的先后顺序的情况下，指定corePoolSize=maximumPoolsize就不会有你说的问题了。通常用newFixedThreadPool这个工厂方法创建的线程池是corePoolSize=maximumPoolsize，遵循先进先出></p>
<ul>
<li><a href="">回复</a></li>
<li><a href="">回到顶部</a></li>
</ul>
<p><a href=""></a></p>
<p><strong>Re: 拜读，有一些困惑望解答</strong> 18/11/2012 02:43 by 方 腾飞</p>
<p>是的。之前没理解你的问题。</p>
<ul>
<li><a href="">回复</a></li>
<li><a href="">回到顶部</a>
<a href=""></a></li>
</ul>
<p><strong>能谈谈thread pool和多核CPU的关系吗？ 怎样能保证thread pool的配置，让其能够最大化的压栈多核cpu</strong> 20/11/2012 11:02 by biao jiang</p>
<p>能谈谈thread pool和多核CPU的关系吗？ 怎样能保证thread pool的配置，让其能够最大化的压栈多核cpu</p>
<ul>
<li><a href="">回复</a></li>
<li><a href="">回到顶部</a></li>
</ul>
<p><a href=""></a></p>
<p><strong>Re: 能谈谈thread pool和多核CPU的关系吗？ 怎样能保证thread pool的配置，让其能够最大化的压栈多核cpu</strong> 20/11/2012 02:26 by 萧 欢</p>
<p>这个应该挺难的。只能说，理论上一个CPU分配一个线程是最优的情况，然而这只是理论上。线程池和CPU核数的关系也与线程池的任务模型息息相关，是CPU密集型还是I/O密集型。最简单的方式就是动态递增的增加线程池数目然后跑一段时间程序，观察系统吞吐率，寻找最适合你的那个高层点</p>
<ul>
<li><a href="">回复</a></li>
<li><a href="">回到顶部</a>
<a href=""></a></li>
</ul>
<p><strong>Re: 能谈谈thread pool和多核CPU的关系吗？ 怎样能保证thread pool的配置，让其能够最大化的压栈多核cpu</strong> 22/11/2012 11:48 by 老 bull</p>
<p>Java 1.2之后线程都是采用内核级线程（进程）实现的，一个JAVA用户线程最终会对应到一个内核线程上面托管，而内核线程在CPU上的调度是依赖操作系统的，这个问题可以从操作系统层面上解决或者寻求答案。</p>
<ul>
<li><a href="">回复</a></li>
<li><a href="">回到顶部</a></li>
</ul>
<p><a href=""></a></p>
<p><strong>Re: 能谈谈thread pool和多核CPU的关系吗？ 怎样能保证thread pool的配置，让其能够最大化的压栈多核cpu</strong> 26/11/2012 00:00 by 方 腾飞</p>
<p>文中有提到如果是CPU密集型任务，使用Ncpu+1个线程可以很好的压榨CPU。详细的可以参见“合理的配置线程池”章节。</p>
<ul>
<li><a href="">回复</a></li>
<li><a href="">回到顶部</a>
<a href=""></a></li>
</ul>
<p><strong>使用的一些问题?</strong> 25/02/2013 02:23 by Qiao stephen</p>
<p>如果我在一个应用中,存在多个小服务,每个服务都开启一个线程,请问那么是在整个应用中开启一个线程池还是每个小服务开启
一个线程池呢?如果是每个小服务开启一个,各个线程池之间又是怎么管理呢?
是不是使用一个线程池来管理上面的多个线程池呢?</p>
<ul>
<li><a href="">回复</a></li>
<li><a href="">回到顶部</a></li>
</ul>
<p><a href=""></a></p>
<p><strong>不知道是不是错误</strong> 29/03/2013 01:53 by 高 鹏翔</p>
<p>◦DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务。
这个策略,我看的时候有点疑惑,进入代码里面看了下,应该是丢弃待执行的任务队列的对首,但是这个队列是FIFO的,所以我觉得应该是丢弃最远的一个任务,不知道是否理解的有误解,忘指正</p>
<ul>
<li><a href="">回复</a></li>
<li><a href="">回到顶部</a>
<a href=""></a></li>
</ul>
<p><strong>Re: 使用的一些问题?</strong> 16/04/2013 02:45 by vince vince</p>
<p>应该是在应用中建一个线程池，把每个服务要执行的方法体封装成Runnable对象提交到线程池里执行吧，线程池顾名思义，就是一个线程库，事先为你建好，要用的时候丢给它，它给你返回结果，至于优势嘛开头说得很清楚了~这么做可以简化客户端代码复杂度，让他只关心自己的线程体逻辑，而线程本身的生命周期等都不需要自己操心~</p>
<ul>
<li><a href="">回复</a></li>
<li><a href="">回到顶部</a></li>
</ul>
<p><a href=""></a></p>
<p><strong>Re: 不知道是不是错误</strong> 18/05/2013 01:25 by 方 腾飞</p>
<p>的确是丢弃最远的任务，源码如下
public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
if (!e.isShutdown()) {
e.getQueue().poll();
e.execute(r);
}
}</p>
<ul>
<li><a href="">回复</a></li>
<li><a href="">回到顶部</a>
<a href=""></a></li>
</ul>
<p><strong>昨晚再次阅读了该文，有几个问题需要解答</strong> 27/05/2013 09:11 by 王 明军</p>
<p>1、文中提到了线程池的关闭，那么线程池在什么情况下执行关闭呢？
2、什么是CPU密集型任务？
谢谢！有个问题通过阅读评论已经解决，是丢弃任务那个问题。</p>
<ul>
<li><a href="">回复</a></li>
<li><a href="">回到顶部</a></li>
</ul>
<p><a href=""></a></p>
<p><strong>Re: 昨晚再次阅读了该文，有几个问题需要解答</strong> 13/06/2013 03:38 by 方 腾飞</p>
<p>1：不需要使用的时候就关闭。比如服务器暂停使用。
2：CPU密集型任务，如压缩和解压缩，这种需要CPU不停的计算的任务。</p>
<ul>
<li><a href="">回复</a></li>
<li><a href="">回到顶部</a></li>
</ul>
<p><a href="">关闭</a></p>
<h3 id="-by"><em>**</em>by</h3>
<p>发布于</p>
<ul>
<li><a href="">查看</a></li>
<li><a href="">回复</a></li>
<li><a href="">回到顶部</a>
<a href="">关闭</a> 主题  您的回复 <a href="">引用原消息</a></li>
</ul>
<p>允许的HTML标签: a,b,br,blockquote,i,li,pre,u,ul,p
当有人回复此评论时请E-mail通知我</p>
<p><a href="">关闭</a> 主题  您的回复</p>
<p>允许的HTML标签: a,b,br,blockquote,i,li,pre,u,ul,p
当有人回复此评论时请E-mail通知我
<a href="">关闭</a></p>
<ul>
<li>热点内容</li>
<li><a href="">本周</a></li>
<li><a href="">本月</a></li>
<li><a href="">近6个月</a><h3 id="-32-http-www-infoq-com-cn-news-2012-08-32-most-important-algorithms-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2012/08/32-most-important-algorithms?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">计算机科学中最重要的32个算法</a></h3>
</li>
</ul>
<h3 id="-thoughtworks-2013-5-http-www-infoq-com-cn-articles-thoughtworks-technology-radar-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/thoughtWorks-technology-radar?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">ThoughtWorks技术雷达（2013年5月）</a></h3>
<h3 id="-1-5-http-www-infoq-com-cn-articles-iqiyi-cloud-push-practices-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/iqiyi-cloud-push-practices?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">让1.5亿移动端用户第一时间获取消息</a></h3>
<h3 id="-thoughtworks-ceo-http-www-infoq-com-cn-news-2013-06-tw-guoxiao-on-talents-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2013/06/tw-guoxiao-on-talents?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">ThoughtWorks全球CEO郭晓谈软件人才的招聘与培养</a></h3>
<h3 id="-http-www-infoq-com-cn-news-2013-06-10-sins-for-scalability-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2013/06/10-sins-for-scalability?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">影响可扩展性的十宗罪</a></h3>
<h3 id="-6-http-www-infoq-com-cn-minibooks-architect-jun-10-2013-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/architect-jun-10-2013?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">架构师（6月刊）</a></h3>
<h3 id="-http-www-infoq-com-cn-articles-function-switch-realize-better-continuous-implementations-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/function-switch-realize-better-continuous-implementations?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">使用功能开关更好地实现持续部署</a></h3>
<h3 id="-eclipse-github-http-www-infoq-com-cn-news-2013-06-eclipse-github-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2013/06/eclipse-github?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">Eclipse迁移到GitHub</a></h3>
<h3 id="-newegg-com-http-www-infoq-com-cn-presentations-newegg-big-data-practice-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/presentations/newegg-big-data-practice?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">Newegg.com大数据实践</a></h3>
<h3 id="-http-www-infoq-com-cn-minibooks-software-sys-architect-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/software-sys-architect?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">软件系统架构：使用视点和视角与利益相关者合作</a></h3>
<h3 id="-32-http-www-infoq-com-cn-news-2012-08-32-most-important-algorithms-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2012/08/32-most-important-algorithms?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">计算机科学中最重要的32个算法</a></h3>
<h3 id="-6-http-www-infoq-com-cn-minibooks-architect-jun-10-2013-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/architect-jun-10-2013?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">架构师（6月刊）</a></h3>
<h3 id="-rest-http-www-infoq-com-cn-news-2013-06-rest-drawbacks-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2013/06/rest-drawbacks?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">REST的缺点是什么？</a></h3>
<h3 id="-google-web-ui-polymer-http-www-infoq-com-cn-news-2013-06-webcomponents-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2013/06/webcomponents?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">Google 发布新一代Web UI库Polymer</a></h3>
<h3 id="-http-www-infoq-com-cn-news-2013-06-dianping-xinnet-hacked-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2013/06/dianping-xinnet-hacked?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">大众点评网域名劫持事件概述</a></h3>
<h3 id="-node-js-grunt-js-http-www-infoq-com-cn-articles-gruntjs-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/GruntJs?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">基于Node.js的自动化构建工具Grunt.js</a></h3>
<h3 id="-node-js-node-js-http-www-infoq-com-cn-articles-what-is-nodejs-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/what-is-nodejs?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">深入浅出Node.js（一）：什么是Node.js</a></h3>
<h3 id="-http-www-infoq-com-cn-minibooks-i-m-wrights-hard-code-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/i-m-wrights-hard-code?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">代码之殇·第二版</a></h3>
<h3 id="-http-www-infoq-com-cn-minibooks-software-sys-architect-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/software-sys-architect?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">软件系统架构：使用视点和视角与利益相关者合作</a></h3>
<h3 id="-18-java-http-www-infoq-com-cn-news-2013-06-zhuhong-on-java-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2013/06/zhuhong-on-java?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">大家谈18岁的Java——朱鸿：开过跑车后再去开大巴车总是有点不爽的</a></h3>
<h3 id="-32-http-www-infoq-com-cn-news-2012-08-32-most-important-algorithms-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2012/08/32-most-important-algorithms?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">计算机科学中最重要的32个算法</a></h3>
<h3 id="-java-http-www-infoq-com-cn-articles-java-memory-model-1-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/java-memory-model-1?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">深入理解Java内存模型（一）——基础</a></h3>
<h3 id="-node-js-node-js-http-www-infoq-com-cn-articles-what-is-nodejs-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/what-is-nodejs?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">深入浅出Node.js（一）：什么是Node.js</a></h3>
<h3 id="-node-js-node-js-npm-http-www-infoq-com-cn-articles-nodejs-npm-install-config-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/nodejs-npm-install-config?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">深入浅出Node.js（二）：Node.js&amp;NPM的安装与配置</a></h3>
<h3 id="-3-http-www-infoq-com-cn-minibooks-architect-mar-10-2013-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/architect-mar-10-2013?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">架构师（3月刊）</a></h3>
<h3 id="-1-http-www-infoq-com-cn-minibooks-architect-jan-10-2013-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/architect-jan-10-2013?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">架构师（1月刊）</a></h3>
<h3 id="-4-http-www-infoq-com-cn-minibooks-architect-apr-10-2013-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/architect-apr-10-2013?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">架构师（4月刊）</a></h3>
<h3 id="-java-http-www-infoq-com-cn-articles-java-threadpool-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/java-threadPool?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">聊聊并发（三）——JAVA线程池的分析和使用</a></h3>
<h3 id="-2-http-www-infoq-com-cn-minibooks-architect-feb-10-2013-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/architect-feb-10-2013?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">架构师（2月刊）</a></h3>
<h3 id="-12306-github-http-www-infoq-com-cn-news-2013-01-12306-plugin-ddos-github-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2013/01/12306-plugin-ddos-github?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">12306订票助手插件拖垮GitHub事件原因始末</a></h3>
<h3 id="-32-http-www-infoq-com-cn-news-2012-08-32-most-important-algorithms-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2012/08/32-most-important-algorithms?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">计算机科学中最重要的32个算法</a></h3>
<h3 id="-thoughtworks-2013-5-http-www-infoq-com-cn-articles-thoughtworks-technology-radar-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/thoughtWorks-technology-radar?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">ThoughtWorks技术雷达（2013年5月）</a></h3>
<h3 id="-1-5-http-www-infoq-com-cn-articles-iqiyi-cloud-push-practices-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/iqiyi-cloud-push-practices?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">让1.5亿移动端用户第一时间获取消息</a></h3>
<h3 id="-thoughtworks-ceo-http-www-infoq-com-cn-news-2013-06-tw-guoxiao-on-talents-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2013/06/tw-guoxiao-on-talents?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">ThoughtWorks全球CEO郭晓谈软件人才的招聘与培养</a></h3>
<h3 id="-http-www-infoq-com-cn-news-2013-06-10-sins-for-scalability-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2013/06/10-sins-for-scalability?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">影响可扩展性的十宗罪</a></h3>
<h3 id="-6-http-www-infoq-com-cn-minibooks-architect-jun-10-2013-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/architect-jun-10-2013?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">架构师（6月刊）</a></h3>
<h3 id="-http-www-infoq-com-cn-articles-function-switch-realize-better-continuous-implementations-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/function-switch-realize-better-continuous-implementations?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">使用功能开关更好地实现持续部署</a></h3>
<h3 id="-eclipse-github-http-www-infoq-com-cn-news-2013-06-eclipse-github-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2013/06/eclipse-github?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">Eclipse迁移到GitHub</a></h3>
<h3 id="-newegg-com-http-www-infoq-com-cn-presentations-newegg-big-data-practice-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/presentations/newegg-big-data-practice?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">Newegg.com大数据实践</a></h3>
<h3 id="-http-www-infoq-com-cn-minibooks-software-sys-architect-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/software-sys-architect?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">软件系统架构：使用视点和视角与利益相关者合作</a></h3>
<h3 id="-32-http-www-infoq-com-cn-news-2012-08-32-most-important-algorithms-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2012/08/32-most-important-algorithms?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">计算机科学中最重要的32个算法</a></h3>
<h3 id="-6-http-www-infoq-com-cn-minibooks-architect-jun-10-2013-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/architect-jun-10-2013?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">架构师（6月刊）</a></h3>
<h3 id="-rest-http-www-infoq-com-cn-news-2013-06-rest-drawbacks-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2013/06/rest-drawbacks?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">REST的缺点是什么？</a></h3>
<h3 id="-google-web-ui-polymer-http-www-infoq-com-cn-news-2013-06-webcomponents-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2013/06/webcomponents?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">Google 发布新一代Web UI库Polymer</a></h3>
<h3 id="-http-www-infoq-com-cn-news-2013-06-dianping-xinnet-hacked-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2013/06/dianping-xinnet-hacked?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">大众点评网域名劫持事件概述</a></h3>
<h3 id="-node-js-grunt-js-http-www-infoq-com-cn-articles-gruntjs-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/GruntJs?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">基于Node.js的自动化构建工具Grunt.js</a></h3>
<h3 id="-node-js-node-js-http-www-infoq-com-cn-articles-what-is-nodejs-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/what-is-nodejs?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">深入浅出Node.js（一）：什么是Node.js</a></h3>
<h3 id="-http-www-infoq-com-cn-minibooks-i-m-wrights-hard-code-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/i-m-wrights-hard-code?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">代码之殇·第二版</a></h3>
<h3 id="-http-www-infoq-com-cn-minibooks-software-sys-architect-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/software-sys-architect?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">软件系统架构：使用视点和视角与利益相关者合作</a></h3>
<h3 id="-18-java-http-www-infoq-com-cn-news-2013-06-zhuhong-on-java-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2013/06/zhuhong-on-java?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">大家谈18岁的Java——朱鸿：开过跑车后再去开大巴车总是有点不爽的</a></h3>
<h3 id="-32-http-www-infoq-com-cn-news-2012-08-32-most-important-algorithms-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2012/08/32-most-important-algorithms?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">计算机科学中最重要的32个算法</a></h3>
<h3 id="-java-http-www-infoq-com-cn-articles-java-memory-model-1-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/java-memory-model-1?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">深入理解Java内存模型（一）——基础</a></h3>
<h3 id="-node-js-node-js-http-www-infoq-com-cn-articles-what-is-nodejs-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/what-is-nodejs?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">深入浅出Node.js（一）：什么是Node.js</a></h3>
<h3 id="-node-js-node-js-npm-http-www-infoq-com-cn-articles-nodejs-npm-install-config-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/nodejs-npm-install-config?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">深入浅出Node.js（二）：Node.js&amp;NPM的安装与配置</a></h3>
<h3 id="-3-http-www-infoq-com-cn-minibooks-architect-mar-10-2013-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/architect-mar-10-2013?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">架构师（3月刊）</a></h3>
<h3 id="-1-http-www-infoq-com-cn-minibooks-architect-jan-10-2013-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/architect-jan-10-2013?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">架构师（1月刊）</a></h3>
<h3 id="-4-http-www-infoq-com-cn-minibooks-architect-apr-10-2013-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/architect-apr-10-2013?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">架构师（4月刊）</a></h3>
<h3 id="-java-http-www-infoq-com-cn-articles-java-threadpool-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/java-threadPool?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">聊聊并发（三）——JAVA线程池的分析和使用</a></h3>
<h3 id="-2-http-www-infoq-com-cn-minibooks-architect-feb-10-2013-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/architect-feb-10-2013?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">架构师（2月刊）</a></h3>
<h3 id="-12306-github-http-www-infoq-com-cn-news-2013-01-12306-plugin-ddos-github-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2013/01/12306-plugin-ddos-github?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">12306订票助手插件拖垮GitHub事件原因始末</a></h3>
<h2 id="-">深度内容</h2>
<ul>
<li><a href="">全部</a></li>
<li><a href="">文章</a></li>
<li><a href="">演讲</a></li>
<li><a href="">访谈</a></li>
<li><a href="">迷你书</a></li>
</ul>
<h2 id="-juergen-fesslmeier-javascript-http-www-infoq-com-cn-interviews-end-to-end-javascript-juergen-fesslmeier-javascript-"><a href="http://www.infoq.com/cn/interviews/end-to-end-javascript" title="Juergen Fesslmeier谈端到端的JavaScript开发" target="_blank">Juergen Fesslmeier谈端到端的JavaScript开发</a></h2>
<p><a href="http://www.infoq.com/cn/author/Juergen-Fesslmeier" title="Juergen Fesslmeier" target="_blank">Juergen Fesslmeier</a> 七月 02, 2013</p>
<p><a href="http://www.infoq.com/cn/interviews/end-to-end-javascript" title="Juergen Fesslmeier谈端到端的JavaScript开发" target="_blank"><img src="" alt=""></a></p>
<h2 id="-http-www-infoq-com-cn-articles-design-pattern-automation-"><a href="http://www.infoq.com/cn/articles/Design-Pattern-Automation" title="设计模式自动化" target="_blank">设计模式自动化</a></h2>
<p><a href="http://www.infoq.com/cn/author/Gael-Fraiteur-and-Yan-Cui" title="Gael Fraiteur and Yan Cui" target="_blank">Gael Fraiteur and Yan Cui</a> 七月 01, 2013</p>
<p><a href="http://www.infoq.com/cn/articles/Design-Pattern-Automation" title="设计模式自动化" target="_blank"><img src="" alt=""></a></p>
<h2 id="-http-www-infoq-com-cn-articles-designing-a-world-at-your-fingertips-mobile-user-interfaces-"><a href="http://www.infoq.com/cn/articles/designing-a-world-at-your-fingertips-mobile-user-interfaces" title="设计指尖上的世界：移动用户界面一瞥" target="_blank">设计指尖上的世界：移动用户界面一瞥</a></h2>
<p><a href="http://www.infoq.com/cn/author/Forrest-Shull" title="Forrest Shull" target="_blank">Forrest Shull</a> 六月 28, 2013</p>
<p><a href="http://www.infoq.com/cn/articles/designing-a-world-at-your-fingertips-mobile-user-interfaces" title="设计指尖上的世界：移动用户界面一瞥" target="_blank"><img src="" alt=""></a></p>
<h2 id="-alm-http-www-infoq-com-cn-articles-integrated-alm-alm-"><a href="http://www.infoq.com/cn/articles/Integrated-ALM" title="成功的根本—集成的ALM工具" target="_blank">成功的根本—集成的ALM工具</a></h2>
<p><a href="http://www.infoq.com/cn/author/Dave-West" title="Dave West" target="_blank">Dave West</a> 六月 28, 2013</p>
<p><a href="http://www.infoq.com/cn/articles/Integrated-ALM" title="成功的根本—集成的ALM工具" target="_blank"><img src="" alt=""></a></p>
<h2 id="-http-www-infoq-com-cn-articles-atdd-by-example-book-"><a href="http://www.infoq.com/cn/articles/atdd-by-example-book" title="书评：验收测试驱动开发实践指南" target="_blank">书评：验收测试驱动开发实践指南</a></h2>
<p><a href="http://www.infoq.com/cn/author/Manuel-Pais" title="Manuel Pais" target="_blank">Manuel Pais</a> 六月 26, 2013</p>
<p><a href="http://www.infoq.com/cn/articles/atdd-by-example-book" title="书评：验收测试驱动开发实践指南" target="_blank"><img src="" alt=""></a></p>
<h2 id="-web-http-www-infoq-com-cn-presentations-across-device-web-web-"><a href="http://www.infoq.com/cn/presentations/across-device-web" title="跨终端的web" target="_blank">跨终端的web</a></h2>
<p><a href="http://www.infoq.com/cn/author/%E8%88%92%E6%96%87%E4%BA%AE" title="舒文亮" target="_blank">舒文亮</a> 六月 26, 2013</p>
<p><a href="http://www.infoq.com/cn/presentations/across-device-web" title="跨终端的web" target="_blank"><img src="" alt=""></a></p>
<ul>
<li><a href="">更早的 &gt;</a></li>
</ul>
<p>语言 &amp; 开发</p>
<p><a href="http://www.infoq.com/cn/interviews/end-to-end-javascript" title="Juergen Fesslmeier谈端到端的JavaScript开发" target="_blank">Juergen Fesslmeier谈端到端的JavaScript开发</a></p>
<p><a href="http://www.infoq.com/cn/news/2013/07/mobilecloud-tfs" title="MobileCloud for TFS支持测试Windows Phone,Android,iOS及BlackBerry应用" target="_blank">MobileCloud for TFS支持测试Windows Phone,Android,iOS及BlackBerry应用</a></p>
<p><a href="http://www.infoq.com/cn/news/2013/07/baidu-salon39-summary" title="百度技术沙龙第39期回顾：前端快速开发实践（含资料下载）" target="_blank">百度技术沙龙第39期回顾：前端快速开发实践（含资料下载）</a></p>
<p>架构 &amp; 设计</p>
<p><a href="http://www.infoq.com/cn/news/2013/07/Native-Performance" title="内存与本机代码的性能" target="_blank">内存与本机代码的性能</a></p>
<p><a href="http://www.infoq.com/cn/articles/Design-Pattern-Automation" title="设计模式自动化" target="_blank">设计模式自动化</a></p>
<p><a href="http://www.infoq.com/cn/news/2013/07/WinRT-Devices" title="连接设备编程" target="_blank">连接设备编程</a>
过程 &amp; 实践</p>
<p><a href="http://www.infoq.com/cn/articles/Integrated-ALM" title="成功的根本—集成的ALM工具" target="_blank">成功的根本—集成的ALM工具</a></p>
<p><a href="http://www.infoq.com/cn/news/2013/06/tw-guoxiao-on-talents" title="ThoughtWorks全球CEO郭晓谈软件人才的招聘与培养" target="_blank">ThoughtWorks全球CEO郭晓谈软件人才的招聘与培养</a></p>
<p><a href="http://www.infoq.com/cn/articles/atdd-by-example-book" title="书评：验收测试驱动开发实践指南" target="_blank">书评：验收测试驱动开发实践指南</a></p>
<p>运维 &amp; 基础架构</p>
<p><a href="http://www.infoq.com/cn/news/2013/06/devops-in-traditional-enterprise" title="在传统企业中引入DevOps" target="_blank">在传统企业中引入DevOps</a></p>
<p><a href="http://www.infoq.com/cn/news/2013/06/dod-ams-day1-s-is-for-security" title="安全性——“DevOpS”中的S" target="_blank">安全性——“DevOpS”中的S</a></p>
<p><a href="http://www.infoq.com/cn/articles/atdd-by-example-book" title="书评：验收测试驱动开发实践指南" target="_blank">书评：验收测试驱动开发实践指南</a>
企业架构</p>
<p><a href="http://www.infoq.com/cn/articles/designing-a-world-at-your-fingertips-mobile-user-interfaces" title="设计指尖上的世界：移动用户界面一瞥" target="_blank">设计指尖上的世界：移动用户界面一瞥</a></p>
<p><a href="http://www.infoq.com/cn/news/2013/06/stratos-2" title="Stratos 2.0已发布，支持所有运行时环境和30个IaaS" target="_blank">Stratos 2.0已发布，支持所有运行时环境和30个IaaS</a></p>
<p><a href="http://www.infoq.com/cn/articles/iqiyi-cloud-push-practices" title="让1.5亿移动端用户第一时间获取消息" target="_blank">让1.5亿移动端用户第一时间获取消息</a></p>
<p>语言 &amp; 开发</p>
<p><a href="http://www.infoq.com/cn/interviews/end-to-end-javascript" title="Juergen Fesslmeier谈端到端的JavaScript开发" target="_blank">Juergen Fesslmeier谈端到端的JavaScript开发</a></p>
<p><a href="http://www.infoq.com/cn/news/2013/07/mobilecloud-tfs" title="MobileCloud for TFS支持测试Windows Phone,Android,iOS及BlackBerry应用" target="_blank">MobileCloud for TFS支持测试Windows Phone,Android,iOS及BlackBerry应用</a></p>
<p><a href="http://www.infoq.com/cn/news/2013/07/baidu-salon39-summary" title="百度技术沙龙第39期回顾：前端快速开发实践（含资料下载）" target="_blank">百度技术沙龙第39期回顾：前端快速开发实践（含资料下载）</a>
架构 &amp; 设计</p>
<p><a href="http://www.infoq.com/cn/news/2013/07/Native-Performance" title="内存与本机代码的性能" target="_blank">内存与本机代码的性能</a></p>
<p><a href="http://www.infoq.com/cn/articles/Design-Pattern-Automation" title="设计模式自动化" target="_blank">设计模式自动化</a></p>
<p><a href="http://www.infoq.com/cn/news/2013/07/WinRT-Devices" title="连接设备编程" target="_blank">连接设备编程</a></p>
<p>过程 &amp; 实践</p>
<p><a href="http://www.infoq.com/cn/articles/Integrated-ALM" title="成功的根本—集成的ALM工具" target="_blank">成功的根本—集成的ALM工具</a></p>
<p><a href="http://www.infoq.com/cn/news/2013/06/tw-guoxiao-on-talents" title="ThoughtWorks全球CEO郭晓谈软件人才的招聘与培养" target="_blank">ThoughtWorks全球CEO郭晓谈软件人才的招聘与培养</a></p>
<p><a href="http://www.infoq.com/cn/articles/atdd-by-example-book" title="书评：验收测试驱动开发实践指南" target="_blank">书评：验收测试驱动开发实践指南</a>
运维 &amp; 基础架构</p>
<p><a href="http://www.infoq.com/cn/news/2013/06/devops-in-traditional-enterprise" title="在传统企业中引入DevOps" target="_blank">在传统企业中引入DevOps</a></p>
<p><a href="http://www.infoq.com/cn/news/2013/06/dod-ams-day1-s-is-for-security" title="安全性——“DevOpS”中的S" target="_blank">安全性——“DevOpS”中的S</a></p>
<p><a href="http://www.infoq.com/cn/articles/atdd-by-example-book" title="书评：验收测试驱动开发实践指南" target="_blank">书评：验收测试驱动开发实践指南</a></p>
<p>企业架构</p>
<p><a href="http://www.infoq.com/cn/articles/designing-a-world-at-your-fingertips-mobile-user-interfaces" title="设计指尖上的世界：移动用户界面一瞥" target="_blank">设计指尖上的世界：移动用户界面一瞥</a></p>
<p><a href="http://www.infoq.com/cn/news/2013/06/stratos-2" title="Stratos 2.0已发布，支持所有运行时环境和30个IaaS" target="_blank">Stratos 2.0已发布，支持所有运行时环境和30个IaaS</a></p>
<p><a href="http://www.infoq.com/cn/articles/iqiyi-cloud-push-practices" title="让1.5亿移动端用户第一时间获取消息" target="_blank">让1.5亿移动端用户第一时间获取消息</a>
<a href="">Close</a> E-mail  密码</p>
<p><a href="http://www.infoq.com/cn/social/googleLogin.action?fl=login" title="使用Google账号登录" target="_blank">使用Google账号登录</a> <a href="http://www.infoq.com/cn/social/liveLogin.action?fl=login" title="使用Microsoft账号登录" target="_blank">使用Microsoft账号登录</a>
<a href="">忘记密码？</a>
 InfoQ账号使用的E-mail 发送邮件</p>
<p><a href="">重新登录</a>
重新发送激活信息 重新发送</p>
<p><a href="">重新登录</a>
<a href="http://www.infoq.com/cn/reginit.action" target="_blank">没有用户名？</a></p>
<p><a href="http://www.infoq.com/cn/reginit.action" target="_blank">点击注册</a></p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/Java_多线程/">Java_多线程</a></li><li><a href="/categories/Java&J2EE/Java_多线程/并发/">并发</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/Java_多线程/" class="label label-success">Java_多线程</a><a href="/tags/并发/" class="label label-info">并发</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:41"datetime="2014-03-07 09:54:41"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-Java_多线程-并发--聊聊并发（三）——JAVA线程池的分析和使用/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-Java_多线程-并发--聊聊并发（三）——JAVA线程池的分析和使用" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE--JSTL标签参考手册/">JSTL标签 参考手册</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:41.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE--JSTL标签参考手册/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="jstl-">JSTL标签 参考手册</h1>
<h3 id="-jstl-http-elf8848-iteye-com-blog-245559-"><a href="http://elf8848.iteye.com/blog/245559" target="_blank">JSTL标签 参考手册</a>**</h3>
<p><strong>博客分类：</strong> </p>
<ul>
<li><a href="http://elf8848.iteye.com/category/123165" target="_blank">Servlet/Jsp</a></li>
</ul>
<p><strong>前言</strong></p>
<p>=========================================================================</p>
<p>JSLT标签库，是日常开发经常使用的，也是众多标签中性能最好的。把常用的内容，放在这里备份一份，随用随查。尽量做到不用查，就可以随手就可以写出来。这算是Java程序员的基本功吧，一定要扎实。</p>
<p>JSTL全名为JavaServer Pages Standard Tag Library，目前最新的版本为1.1版。JSTL是由JCP(Java Community Process)所制定的标准规范，它主要提供给Java Web开发人员一个标准通用的标签函数库。
Web程序员能够利用JSTL和EL来开发Web程序，取代传统直接在页面上嵌入Java程序(Scripting)的做法，以提高程序的阅读性、维护性和方便性。
JSTL 1.1必须在支持Servlet 2.4且JSP 2.0以上版本的Container才可使用</p>
<p><strong>&lt;%@ taglib %&gt;引入标签库</strong></p>
<p>=========================================================================</p>
<p>1、以classPath中，加入jar包：  standard-1.1.2.jar ，  jstl-1.1.2.jar</p>
<p>2、在相目\WEB-INF\tld\文件夹中放入常用的tld文件：c.tld，fmt.tld</p>
<p>3、在jsp文件的顶部加入以下内容：
Java代码  </p>
<ol>
<li>&lt;%@ taglib uri=&quot;<a href="http://java.sun.com/jsp/jstl/core" target="_blank">http://java.sun.com/jsp/jstl/core</a>&quot; prefix=&quot;c&quot; %&gt;   </li>
<li>&lt;%@ taglib uri=&quot;<a href="http://java.sun.com/jsp/jstl/fmt" target="_blank">http://java.sun.com/jsp/jstl/fmt</a>&quot; prefix=&quot;fmt&quot;%&gt;  </li>
<li>&lt;%@ taglib uri=&quot;<a href="http://java.sun.com/jsp/jstl/functions" target="_blank">http://java.sun.com/jsp/jstl/functions</a>&quot; prefix=&quot;fn&quot; %&gt;  </li>
</ol>
<p><strong><c:> **</strong>核心标签库 **</p>
<p>==========================================================================</p>
<p>JSTL 核心标签库(C标签)标签共有13个，功能上分为4类：
1.表达式控制标签：out、set、remove、catch
2.流程控制标签：if、choose、when、otherwise
3.循环标签：forEach、forTokens
4.URL操作标签：import、url、redirect</p>
<p><strong><c:forEach> **</strong>标签**</p>
<hr>
<p>为循环控制，它可以将集合(Collection)中的成员循序浏览一遍。</p>
<p><strong> <c:forEach> 标签的语法</strong> <strong>说明</strong> <strong>：</strong></p>
<p>语法1：迭代一集合对象之所有成员
Html代码  </p>
<ol>
<li><c:forEach [var="varName"] items="collection" [varStatus="varStatusName"] [begin="begin"] [end="end"] [step="step"]>  </li>
<li>本体内容  </li>
<li></c:forEach>  </li>
</ol>
<p>语法2：迭代指定的次数</p>
<p>Html代码  </p>
<ol>
<li><c:forEach [var="varName"] [varStatus="varStatusName"] begin="begin" end="end" [step="step"]>  </li>
<li>本体内容  </li>
<li></c:forEach>  </li>
</ol>
<p><strong><c:forEach> 标签的</strong> <strong>属性说明</strong> <strong>：</strong></p>
<p><img src="&quot;点击查看原始大小图片&quot;" alt=""></p>
<p><strong><c:forEach> 标签的</strong> <strong>属性 ：</strong> varStatus属性： 它的提供另外四个属性:index,count,fist和last，它们个自的意义如下:
Java代码  </p>
<ol>
<li>属性                   类型                                  意义  </li>
<li>index                  number                    现在指到成员的索引  </li>
<li>count                  number                    总共指到成员的总和  </li>
<li>first                  boolean                   现在指到成员是否为第一个  </li>
<li>last                   boolean                   现在指到成员是否为最后一个   </li>
</ol>
<p><strong> <c:forEach> 遍历 List列表：</strong></p>
<p> 对于一个基本类型的数组，当前元素将作为相应包装类（Integer、Float等等）的一个实例提供。
Html代码  </p>
<ol>
<li><c:forEach items="${domainList }" var="item">  </li>
<li><tr>  </li>
<li><td align="center" valign="middle">${item[&quot;domain&quot;]==null?&quot;&nbsp;&quot;:item[&quot;domain&quot;]}</td>  </li>
<li><td align="center" valign="middle"><fmt:formatDate value="${item['bind_date']}" pattern="yyyy-MM-dd HH:mm:ss"/></td>  </li>
<li><td align="center" valign="middle">  </li>
<li><c:if test="${item['domain']!=null}">  </li>
<li><a href="javascript:;" id="${item['domain']}" class="del">&nbsp;</a>  </li>
<li></c:if>  </li>
<li></td>  </li>
<li></tr>    </li>
<li></c:forEach>  </li>
</ol>
<p><strong> <c:forEach> 遍历Map:</strong></p>
<p> 对于一个java.util.Map，当前元素则作为一个java.util.Map.Entry提供。
Html代码  </p>
<ol>
<li><c:if test="${!empty permissionMap}">    </li>
<li><c:forEach items="${permissionMap}" var="item">  </li>
<li><tr>  </li>
<li><td>${item.value.id}</td>  </li>
<li><td>${item.value.urlOnClass}</td>  </li>
<li><td>${item.value.urlOnMethod}</td>  </li>
<li></tr>  </li>
<li></c:forEach>  </li>
<li></c:if>    </li>
</ol>
<p><strong><c:forTokens> **</strong>标签**</p>
<hr>
<p>用来浏览一字符串中所有的成员，其成员是由定义符号(delimiters)所分隔的。</p>
<p><strong> <c:forTokens> 标签的语法</strong> <strong>说明</strong> <strong>：</strong>
Html代码  </p>
<ol>
<li>&lt;c:forTokens items=&quot;stringOfTokens&quot; delims=&quot;delimiters&quot; [var=&quot;varName&quot;]  </li>
<li>[varStatus=&quot;varStatusName&quot;] [begin=&quot;begin&quot;] [end=&quot;end&quot;] [step=&quot;step&quot;]&gt;  </li>
<li>本体内容  </li>
<li></c:forTokens>  </li>
</ol>
<p><strong><c:forTokens> 标签的</strong> <strong>属性说明</strong> <strong>：</strong></p>
<p><img src="" alt=""></p>
<p><strong><c:out> **</strong>标签**</p>
<hr>
<p>主要用来显示数据的内容</p>
<p><strong> <c:out> 标签的语法</strong> <strong>说明</strong> <strong>：</strong></p>
<p>语法1：没有本体(body)内容
Html代码  </p>
<ol>
<li><c:out value="value" [escapeXml="{true|false}"] [default="defaultValue"] />  


</li>
</ol>
<p>语法2：有本体内容</p>
<p>Html代码  </p>
<ol>
<li><c:out value="value" [escapeXml="{true|false}"]>  </li>
<li>default value  </li>
<li></c:out>  </li>
</ol>
<p><strong><c:forEach> 标签的</strong> <strong>属性说明</strong> <strong>：</strong> 略</p>
<p>一般来说，<c:out>默认会将&lt;、&gt;、’、” 和 &amp; 转换为 &lt;、&gt;、&amp;/#039;、&amp;/#034; 和&amp;。假若不想转换时，只需要设定<c:out>的escapeXml属性为fasle就可以了。</p>
<p><strong><c:set> **</strong>标签**</p>
<hr>
<p>主要用来将变量储存至JSP范围中或是JavaBean的属性中。</p>
<p><strong> <c:set> 标签的语法</strong> <strong>说明</strong> <strong>：</strong></p>
<p>语法1：将value的值储存至范围为scope的 varName 变量之中
Html代码  </p>
<ol>
<li><c:set value="value" var="varName" [scope="{ page|request|session|application }"]/>  


</li>
</ol>
<p>语法2：将本体内容的数据储存至范围为scope的 varName 变量之中</p>
<p>Html代码  </p>
<ol>
<li><c:set var="varName" [scope="{ page|request|session|application }"]>  </li>
<li>… 本体内容  </li>
<li></c:set>  </li>
</ol>
<p>语法3：将 value的值储存至 target 对象的属性中
Html代码  </p>
<ol>
<li><c:set value="value" target="target" property="propertyName" />  


</li>
</ol>
<p>语法4：将本体内容的数据储存至target 对象的属性中</p>
<p>Html代码  </p>
<ol>
<li><c:set target="target" property="propertyName">  </li>
<li>… 本体内容  </li>
<li></c:set>  </li>
</ol>
<p><strong><c:set> 标签的</strong> <strong>属性说明</strong> <strong>：</strong></p>
<p><img src="&quot;点击查看原始大小图片&quot;" alt=""></p>
<p><strong><c:remove> **</strong>标签**</p>
<hr>
<p>主要用来移除变量。</p>
<p><strong> <c:remove> 标签的语法</strong> <strong>说明</strong> <strong>：</strong>
Html代码  </p>
<ol>
<li><c:remove var="varName" [scope="{ age|request|session|application }"] />  



</li>
</ol>
<p><strong><c:catch> **</strong>标签**</p>
<hr>
<p>主要用来处理产生错误的异常状况，并且将错误信息储存起来。</p>
<p><strong> <c:catch> 标签的语法</strong> <strong>说明</strong> <strong>：</strong>
Html代码  </p>
<ol>
<li><c:catch [var="varName"] >  </li>
<li>… 欲抓取错误的部分  </li>
<li></c:catch>  </li>
</ol>
<p><strong><c:if> **</strong>标签**</p>
<hr>
<p>的用途就和我们一般在程序中用的if一样。</p>
<p><strong> <c:if> 标签的语法</strong> <strong>说明</strong> <strong>：</strong></p>
<p>语法1：没有本体内容(body)
Html代码  </p>
<ol>
<li><c:if test="testCondition" var="varName" [scope="{page|request|session|application}"]/>  



</li>
</ol>
<p>语法2：有本体内容
Html代码  </p>
<ol>
<li><c:if test="testCondition" [var="varName"] [scope="{page|request|session|application}"]>  </li>
<li>本体内容  </li>
<li></c:if>  </li>
</ol>
<p>示例：</p>
<p>Html代码  </p>
<ol>
<li><c:if test="${not empty item.publish_time}">  </li>
<li>内容  </li>
<li></c:if>  </li>
<li></li>
<li><c:if test="${item['domain']!=null}">  </li>
<li>内容  </li>
<li></c:if>  </li>
<li></li>
<li><c:if test="${!empty permissionMap}">   </li>
<li>内容  </li>
<li></c:if>  </li>
</ol>
<p><strong>c:choose&gt; <c:when> <c:otherwise>  </strong> <strong>标签</strong></p>
<hr>
<p><strong> <c:choose when otherwise> 标签的语法</strong> <strong>说明</strong> <strong>：</strong>
Html代码  </p>
<ol>
<li><c:set var="score">85</c:set>  </li>
<li><c:choose>  </li>
<li><c:when test="${score>=90}">  </li>
<li>你的成绩为优秀！  </li>
<li></c:when>  </li>
<li><c:when test="${score>=70&&score<90}">  </li>
<li>您的成绩为良好!  </li>
<li></c:when>  </li>
<li><c:when test="${score>60&&score<70}">  </li>
<li>您的成绩为及格  </li>
<li></c:when>  </li>
<li><c:otherwise>  </li>
<li>对不起，您没有通过考试！  </li>
<li></c:otherwise>  </li>
<li></c:choose>  </li>
</ol>
<p><strong><fmt:>  </strong> <strong>格式 化标签库 </strong></p>
<p>==========================================================================</p>
<p>一：JSTL格式化标签又称为I18N标签库，主要用来编写国际化的WEB应用，使用此功能可以对一个特定的语言请求做出合适的处理。</p>
<p>例如：中国内地用户将显示简体中文，台湾地区则显示繁体中文，使用I18N格式化标签库还可以格式化数字和日期，例如同一数字或日趋，在不同国家可能有不同的格式，使用I18N格式标签库可以将数字和日期格式为当地的格式。
在JSP页面中要使用到格式化标签，需要引入下面的语句：
&lt;%@ taglib uri=&quot;<a href="http://java.sun.com/jsp/jstl/fmt" target="_blank">http://java.sun.com/jsp/jstl/fmt</a>&quot; prefix=&quot;fmt&quot;% &gt;
<strong>二：概览</strong></p>
<hr>
<pre><code>格式化标签
&lt;fmt:fromatNumber&gt;
&lt;fmt:formatDate&gt;
&lt;fmt:parseDate&gt;
&lt;fmt:parseNumber&gt;
&lt;fmt:setTimeZone&gt;
&lt;fmt:timeZone&gt;
国际化标签
&lt;fmt:setLocale&gt;
&lt;fmt:requestEncoding&gt;
&lt;fmt:bundle&gt;
&lt;fmt:message&gt;
&lt;fmt:param&gt;
&lt;fmt:setBundle&gt;
</code></pre><p><strong>三：<fmt:formatNumber></strong></p>
<hr>
<pre><code>此标签会根据区域定制的方式将数字格式化成数字，货币，百分比。
此标签的属性：
value:要格式化的数字
type：按照什么类型格式化
pattern：自定义格式化样式
currencyCode:ISO-4721货币代码，只适用于按照货币格式化的数字
currencySymbol： 货币符号,如￥,只适用于按照货币格式化的数字
groupingUsed： 是否包含分隔符
maxIntegerDigits： 整数部分最多显示多少位
mixIntegerDigits： 整数部分最少显示多少位
maxFractionDigits： 小数部分最多显示多位位
minFractionDigits： 小数部分最少显示多位位
var:存储格式化后的结果
scope: 存储的范围
示例1：    
</code></pre><p>Java代码 
&lt;%@ page language=&quot;java&quot; pageEncoding=&quot;utf-8&quot;%&gt;<br>&lt;%@ taglib uri=&quot;<a href="http://java.sun.com/jsp/jstl/core" target="_blank">http://java.sun.com/jsp/jstl/core</a>&quot; prefix=&quot;c&quot;%&gt;<br>&lt;%@ taglib uri=&quot;<a href="http://java.sun.com/jsp/jstl/fmt" target="_blank">http://java.sun.com/jsp/jstl/fmt</a>&quot; prefix=&quot;fmt&quot; %&gt;<br>&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;   </p>
<html><br>    <head><br>        <title>chapter4.jsp</title><br>    </head><br>    <body><br>        <div><br>            <div><br>                <fmt:setLocale value="fr_fr"/><br>                <fmt:formatNumber value="123456789.012"/><br>                <br/><br>                <fmt:setLocale value="zh_cn"/><br>                <fmt:formatNumber value="123456789.012"/><br>                <br /><br>                <fmt:setLocale value="de_de"/><br>                <fmt:formatNumber value="123456789.012"/><br>                <br /><br>            </div><br>        </div><br>    </body><br></html><br>&lt;%@ page language=&quot;java&quot; pageEncoding=&quot;utf-8&quot;%&gt;
&lt;%@ taglib uri=&quot;<a href="http://java.sun.com/jsp/jstl/core" target="_blank">http://java.sun.com/jsp/jstl/core</a>&quot; prefix=&quot;c&quot;%&gt;
&lt;%@ taglib uri=&quot;<a href="http://java.sun.com/jsp/jstl/fmt" target="_blank">http://java.sun.com/jsp/jstl/fmt</a>&quot; prefix=&quot;fmt&quot; %&gt;
&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;
<html>
    <head>
        <title>chapter4.jsp</title>
    </head>
    <body>
        <div>
            <div>
                <fmt:setLocale value="fr_fr"/>
                <fmt:formatNumber value="123456789.012"/>
                <br/>
                <fmt:setLocale value="zh_cn"/>
                <fmt:formatNumber value="123456789.012"/>
                <br />
                <fmt:setLocale value="de_de"/>
                <fmt:formatNumber value="123456789.012"/>
                <br /><br>            </div>
        </div>
    </body>
</html>    注意:如果要实现国际化,那么编码格式要设置为utf-8.
          从程序运行效果可以看出,设定的区域不同,格式化数字的显示也会不同.

四：type属性：可以是数字(number),货币(currency),百分比(percent)
    示例2：<br>Java代码 
&lt;%@ page language=&quot;java&quot; pageEncoding=&quot;utf-8&quot;%&gt;<br>&lt;%@ taglib uri=&quot;<a href="http://java.sun.com/jsp/jstl/core" target="_blank">http://java.sun.com/jsp/jstl/core</a>&quot; prefix=&quot;c&quot;%&gt;<br>&lt;%@ taglib uri=&quot;<a href="http://java.sun.com/jsp/jstl/fmt" target="_blank">http://java.sun.com/jsp/jstl/fmt</a>&quot; prefix=&quot;fmt&quot; %&gt;<br>&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;<br><html><br>    <head><br>        <title>chapter4.jsp</title><br>    </head><br>    <body><br>        <div><br>            <div><br>                <fmt:setLocale value="zh_cn"/><br>                <fmt:formatNumber value="0.3" type="number"/><br /><br>                <fmt:formatNumber value="0.3" type="currency"/><br /><br>                <fmt:formatNumber value="0.3" type="percent"/><br /><br>            </div><br>        </div><br>    </body><br></html><br>&lt;%@ page language=&quot;java&quot; pageEncoding=&quot;utf-8&quot;%&gt;
&lt;%@ taglib uri=&quot;<a href="http://java.sun.com/jsp/jstl/core" target="_blank">http://java.sun.com/jsp/jstl/core</a>&quot; prefix=&quot;c&quot;%&gt;
&lt;%@ taglib uri=&quot;<a href="http://java.sun.com/jsp/jstl/fmt" target="_blank">http://java.sun.com/jsp/jstl/fmt</a>&quot; prefix=&quot;fmt&quot; %&gt;
&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;
<html>
    <head>
        <title>chapter4.jsp</title>
    </head>
    <body>
        <div>
            <div>
                <fmt:setLocale value="zh_cn"/>
                <fmt:formatNumber value="0.3" type="number"/><br />
                <fmt:formatNumber value="0.3" type="currency"/><br />
                <fmt:formatNumber value="0.3" type="percent"/><br /><br>            </div>
        </div>
    </body>
</html>     currencyCode为货币代码,例如美元为USD,人民币为CNY等
     currencySymbol为货币符号例如,人民币为￥,美元为$。
     如果不指定区域,则会根据语言区域自动选择currencySymbol
   示例3：<br>Java代码 
&lt;%@ page language=&quot;java&quot; pageEncoding=&quot;utf-8&quot;%&gt;<br>&lt;%@ taglib uri=&quot;<a href="http://java.sun.com/jsp/jstl/core" target="_blank">http://java.sun.com/jsp/jstl/core</a>&quot; prefix=&quot;c&quot;%&gt;<br>&lt;%@ taglib uri=&quot;<a href="http://java.sun.com/jsp/jstl/fmt" target="_blank">http://java.sun.com/jsp/jstl/fmt</a>&quot; prefix=&quot;fmt&quot; %&gt;<br>&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;<br><html><br>    <head><br>        <title>chapter4.jsp</title><br>    </head><br>    <body><br>        <div><br>            <div><br>                <fmt:setLocale value="zh_cn"/><br>                <fmt:formatNumber value="0.3" type="currency"/><br /><br>                <fmt:setLocale value="en_Us"/><br>                <fmt:formatNumber value="0.3" type="currency"/><br /><br>            </div><br>        </div><br>    </body><br></html><br>&lt;%@ page language=&quot;java&quot; pageEncoding=&quot;utf-8&quot;%&gt;
&lt;%@ taglib uri=&quot;<a href="http://java.sun.com/jsp/jstl/core" target="_blank">http://java.sun.com/jsp/jstl/core</a>&quot; prefix=&quot;c&quot;%&gt;
&lt;%@ taglib uri=&quot;<a href="http://java.sun.com/jsp/jstl/fmt" target="_blank">http://java.sun.com/jsp/jstl/fmt</a>&quot; prefix=&quot;fmt&quot; %&gt;
&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;
<html>
    <head>
        <title>chapter4.jsp</title>
    </head>
    <body>
        <div>
            <div>
                <fmt:setLocale value="zh_cn"/>
                <fmt:formatNumber value="0.3" type="currency"/><br />
                <fmt:setLocale value="en_Us"/>
                <fmt:formatNumber value="0.3" type="currency"/><br /><br>            </div>
        </div>
    </body>
</html><br>   currencySymbol属性还可以自定义要显示的头标识,但是一定得type=&quot;currency&quot;才会生效,例如:<br>Java代码 
&lt;%@ page language=&quot;java&quot; pageEncoding=&quot;utf-8&quot;%&gt;<br>&lt;%@ taglib uri=&quot;<a href="http://java.sun.com/jsp/jstl/core" target="_blank">http://java.sun.com/jsp/jstl/core</a>&quot; prefix=&quot;c&quot;%&gt;<br>&lt;%@ taglib uri=&quot;<a href="http://java.sun.com/jsp/jstl/fmt" target="_blank">http://java.sun.com/jsp/jstl/fmt</a>&quot; prefix=&quot;fmt&quot; %&gt;<br>&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;<br><html><br>    <head><br>        <title>chapter4.jsp</title><br>    </head><br>    <body><br>        <div><br>            <div><br>                <fmt:setLocale value="zh_cn"/><br>                <fmt:formatNumber value="0.3" type="currency" currencySymbol="/#"/><br /><br>                <fmt:setLocale value="en_Us"/><br>                <fmt:formatNumber value="0.3" type="currency" currencySymbol="/#"/><br /><br>            </div><br>        </div><br>    </body><br></html><br>&lt;%@ page language=&quot;java&quot; pageEncoding=&quot;utf-8&quot;%&gt;
&lt;%@ taglib uri=&quot;<a href="http://java.sun.com/jsp/jstl/core" target="_blank">http://java.sun.com/jsp/jstl/core</a>&quot; prefix=&quot;c&quot;%&gt;
&lt;%@ taglib uri=&quot;<a href="http://java.sun.com/jsp/jstl/fmt" target="_blank">http://java.sun.com/jsp/jstl/fmt</a>&quot; prefix=&quot;fmt&quot; %&gt;
&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;
<html>
    <head>
        <title>chapter4.jsp</title>
    </head>
    <body>
        <div>
            <div>
                <fmt:setLocale value="zh_cn"/>
                <fmt:formatNumber value="0.3" type="currency" currencySymbol="/#"/><br />
                <fmt:setLocale value="en_Us"/>
                <fmt:formatNumber value="0.3" type="currency" currencySymbol="/#"/><br /><br>            </div>
        </div>
    </body>
</html><br>    自定义数字样式
    <fmt:formatNumber value="12.31" pattern=".0000"/><br/>
    <fmt:formatNumber value="1234" pattern="/#/#/#./#/#E0"/>
    会显示:
    12.3100
    1.234E3
    会四舍五入
    var:定义一个变量,存储格式化后的结果,scope指定变量存储的范围.用法和前面讲的标签一致.

<strong>五：<fmt:parseNumber></strong>
-------------------------------------------------------------------
     此标签用来将字符串类型的数字,货币或百分比转换成数字类型,和<fmt:formatNumber>标签的作用正好相反.
     value: 要转换的字符串
     type: 指定要转换的字符串为什么类型,可取值:number,percent,currency
     pattern: 自定义格式化样式
     parseLocale: 指定区域来转换字符串
     IntegerOnly:  转换后的数字是否只显示整数部分
     var:  存储转换后的结果
     scope: 存储的范围
    示例1:
    <fmt:parseNumber value="500,800,200"/>
    显示: 500800200
    示例2:
    <fmt:parseNumber value="52%" type="percent" />
    显示: 0.52 (52%在这里是一个字符串, type指定这个字符串是什么类型的值)
    示例3:
    <fmt:parseNumber value="￥123" type="currency" />
    显示123, ￥123在这里是一个字符串, type指定这个字符串是什么类型的值
    示例4:
    <fmt:parseNumber value="123.333" type="number" /><br/>
    <fmt:parseNumber value="123.333" type="number"  integerOnly="true"/><br/> 
    显示:
    123.333
    123
    integerOnly确定是否只显示整数部分. 
    示例5:
   <fmt:parseNumber value="￥123.333" type="currency" parseLocale="zh_CN"/><br/>
   <fmt:parseNumber value="$123.333" type="currency" parseLocale="en_US"/><br/>
    parseLocale=&quot;en_US&quot;主要是配合当type=&quot;currency&quot;时用的,
    如果要转换货币的字符串类型为value=&quot;￥123.333&quot;,不设置语言环境的话,会取当前浏览器的默认设置,否则就要加上parseLocale=&quot;zh_CN&quot;,指定环境为中文环境
     如果要转换货币的字符串类型为value=&quot;$123.333&quot;,不设置语言环境的话,会取当前浏览器的默认设置,如果默认为zh_cn的话,程序会报错的,否则就要加上parseLocale=&quot;en_US&quot;,指定环境为英文美国环境
<strong>六：<fmt:formatDate /></strong>
-------------------------------------------------------------------
     此标签可以将日期格式化.
     属性介绍:
     value 用来格式化的时间或日期
     type 指定格式化的是日期还是时间,或者两者都是取值范围:date,time,both
     pattern 自定义格式化样式
     dateStyle 日期的格式化样式
     timeStyle 时间的格式化样式
     timeZone 指定使用的时区
     var 存储格式化后的结果
     scope 指定存储的范围



    自定义格式:<br>
--------------------------
Java代码 
<fmt:setLocale value="zh_cn" /><br><fmt:formatDate value="<%=new Date()%>" type="both" pattern="yyyy/MM/dd hh:mm:ss" /><br><br /><br><fmt:formatDate value="<%=new Date()%>" type="both" pattern="yyyy-MM-dd HH:mm:ss" /><br><br /><br><fmt:formatDate value="<%=new Date()%>" type="both" pattern="yyyy年MM月dd日 hh小时mm分钟ss秒" /><br><br /><br><fmt:formatDate value="<%=new Date()%>" type="both" pattern="yy/MM/dd hh:mm:ss" /><br><br /><br><fmt:setLocale value="zh_cn" />
<fmt:formatDate value="<%=new Date()%>" type="both" pattern="yyyy/MM/dd hh:mm:ss" />
<br />
<fmt:formatDate value="<%=new Date()%>" type="both" pattern="yyyy-MM-dd HH:mm:ss" />
<br />
<fmt:formatDate value="<%=new Date()%>" type="both" pattern="yyyy年MM月dd日 hh小时mm分钟ss秒" />
<br />
<fmt:formatDate value="<%=new Date()%>" type="both" pattern="yy/MM/dd hh:mm:ss" />
<br />     注意这里小时 hh表示12小时制, HH代表24小时制

     示例1：<br>--------------------------
Java代码 
<fmt:setLocale value="zh_cn" /><br><fmt:formatDate value="<%=new Date()%>" /><br><br /><br><fmt:setLocale value="zh_tw" /><br><fmt:formatDate value="<%=new Date()%>" /><br><fmt:setLocale value="zh_cn" />
<fmt:formatDate value="<%=new Date()%>" />
<br />
<fmt:setLocale value="zh_tw" />
<fmt:formatDate value="<%=new Date()%>" /><br>大家可以看到大陆和台湾显示日期的格式是有区别的.
    显示结果:
    2009-12-7 
    2009/12/7
    示例2：<br>--------------------------
Java代码 
<fmt:setLocale value="zh_cn" /><br><fmt:formatDate value="<%=new Date()%>" type="time"/><br><br /><br><fmt:setLocale value="zh_tw" /><br><fmt:formatDate value="<%=new Date()%>" type="time"/><br><fmt:setLocale value="zh_cn" />
<fmt:formatDate value="<%=new Date()%>" type="time"/>
<br />
<fmt:setLocale value="zh_tw" />
<fmt:formatDate value="<%=new Date()%>" type="time"/><br>显示结果:
    14:59:28 
    下午 02:59:28
     type可取值及意义:
     date 格式化日期
     time格式化时间
     both格式化日期时间
     示例3：<br>
--------------------------
Java代码 
<fmt:setLocale value="zh_cn" /><br><fmt:formatDate value="<%=new Date()%>" type="both" /><br><br /><br><fmt:setLocale value="zh_tw" /><br><fmt:formatDate value="<%=new Date()%>" type="both" /><br><fmt:setLocale value="zh_cn" />
<fmt:formatDate value="<%=new Date()%>" type="both" />
<br />
<fmt:setLocale value="zh_tw" />
<fmt:formatDate value="<%=new Date()%>" type="both" /><br>输出结果:
   2009-12-7 21:24:26 
   2009/12/7 下午 09:24:26
   dateStyle用来设定日期显示的样式,其值可以是default, short, medium, long, full,请看示例:<br>--------------------------
Java代码 
<fmt:setLocale value="zh_cn" /><br><fmt:formatDate value="<%=new Date()%>" type="both" dateStyle="default" /><br><br /><br><fmt:formatDate value="<%=new Date()%>" type="both" dateStyle="short" /><br><br /><br><fmt:formatDate value="<%=new Date()%>" type="both" dateStyle="medium" /><br><br /><br><fmt:formatDate value="<%=new Date()%>" type="both" dateStyle="long" /><br><br /><br><fmt:formatDate value="<%=new Date()%>" type="both" dateStyle="full" /><br><br /><br><fmt:setLocale value="zh_cn" />
<fmt:formatDate value="<%=new Date()%>" type="both" dateStyle="default" />
<br />
<fmt:formatDate value="<%=new Date()%>" type="both" dateStyle="short" />
<br />
<fmt:formatDate value="<%=new Date()%>" type="both" dateStyle="medium" />
<br />
<fmt:formatDate value="<%=new Date()%>" type="both" dateStyle="long" />
<br />
<fmt:formatDate value="<%=new Date()%>" type="both" dateStyle="full" />
<br /><br> 显示结果如下:
    2009-12-7 21:30:49 
    09-12-7 21:30:49 
    2009-12-7 21:30:49 
    2009年12月7日 21:30:49 
    2009年12月7日 星期一 21:30:49
    可以看到dateStyle属性只对日期部分起作用,时间部分没有作用.
    timeStyle用来显示时间部分的样式,取值范围同上<br>--------------------------
Java代码 
<fmt:setLocale value="zh_cn" /><br><fmt:formatDate value="<%=new Date()%>" type="both"    timeStyle="default" /><br><br /><br><fmt:formatDate value="<%=new Date()%>" type="both" timeStyle="short" /><br><br /><br><fmt:formatDate value="<%=new Date()%>" type="both" timeStyle="medium" /><br><br /><br><fmt:formatDate value="<%=new Date()%>" type="both" timeStyle="long" /><br><br /><br><fmt:formatDate value="<%=new Date()%>" type="both" timeStyle="full" /><br><br /><br><fmt:setLocale value="zh_cn" />
<fmt:formatDate value="<%=new Date()%>" type="both"    timeStyle="default" />
<br />
<fmt:formatDate value="<%=new Date()%>" type="both" timeStyle="short" />
<br />
<fmt:formatDate value="<%=new Date()%>" type="both" timeStyle="medium" />
<br />
<fmt:formatDate value="<%=new Date()%>" type="both" timeStyle="long" />
<br />
<fmt:formatDate value="<%=new Date()%>" type="both" timeStyle="full" />
<br /><br>输出:
    2009-12-7 21:35:52 
    2009-12-7 下午9:35 
    2009-12-7 21:35:52 
    2009-12-7 下午09时35分52秒 
    2009-12-7 下午09时35分52秒 CST
    timeZone用来设定时区,时区的意思类似于酒店里大堂放的几个时钟,比如现在时间会有北京时间,东京时间,纽约时间,伦墩时间,
   取值范围为:EST, CST, MST, PST<br>--------------------------
Java代码 
<fmt:setLocale value="zh_cn" /><br><fmt:formatDate value="<%=new Date()%>" type="time" timeStyle="full" /><br><br /><br><fmt:formatDate value="<%=new Date()%>" type="time" timeStyle="full" timeZone="EST" /><br><br /><br><fmt:formatDate value="<%=new Date()%>" type="time" timeStyle="full" timeZone="CST" /><br><br /><br><fmt:formatDate value="<%=new Date()%>" type="time" timeStyle="full" timeZone="MST" /><br><br /><br><fmt:formatDate value="<%=new Date()%>" type="time" timeStyle="full" timeZone="PST" /><br><br /><br><fmt:setLocale value="zh_cn" />
<fmt:formatDate value="<%=new Date()%>" type="time" timeStyle="full" />
<br />
<fmt:formatDate value="<%=new Date()%>" type="time" timeStyle="full" timeZone="EST" />
<br />
<fmt:formatDate value="<%=new Date()%>" type="time" timeStyle="full" timeZone="CST" />
<br />
<fmt:formatDate value="<%=new Date()%>" type="time" timeStyle="full" timeZone="MST" />
<br />
<fmt:formatDate value="<%=new Date()%>" type="time" timeStyle="full" timeZone="PST" />
<br />     输出结果:
    下午09时41分37秒 CST 
    上午08时41分37秒 EST 
    上午07时41分37秒 CST 
    上午06时41分37秒 MST 
    上午05时41分37秒 PST
<strong>七：<fmt:parseDate></strong>
-------------------------------------------------------------------
    将字符串类型的时间转换为日期类型.
    value 用来格式化的时间或日期的字符串
    type 指定格式化的是日期还是时间,或者两者都是取值范围:date,time,both
    pattern 自定义格式化样式
    dateStyle 日期的格式化样式
    timeStyle 时间的格式化样式
    timeZone 指定使用的时区
    var 存储格式化后的结果
    scope 指定存储的范围
   示例:
    <fmt:setLocale value="zh_cn" />
    <fmt:parseDate type="date" value="2008-4-5"/>
     输出: Sat Apr 05 00:00:00 CST 2008,
     这里已经将字符串” 2008-4-5”转换为了日期对象了.转换一定得注意,类似于2008-4-5这样的字符串,type必须为date,类似于12:34:56的字符串,type必须为time类似于2008-4-5 12:34:56这样的字符串,type必须为both还要注意浏览器的语言环境的设置,如果为zh_tw,那么字符串就必须得符合当地的标准,如为2009/12/7 下午 09:24:26就正确转换为日期对象,否则就会报错.
<strong>八：<fmt:setTimeZone></strong>
-------------------------------------------------------------------
    value 设定时区
    var 存储设定的时区
    scope 存储的范围
    value用来设定时区,可以是EST,CST,MST,PST等,如果有var属性,则将结果存储在所设定的范围之内.在属性范围内的页面都会使用该时区为默认时区.<br>Java代码 
<fmt:setLocale value="zh_cn" /><br><fmt:setTimeZone value="EST" /><br><fmt:formatDate value="<%=new Date()%>" type="time" timeStyle="full" /><br /><br><fmt:formatDate value="<%=new Date()%>" type="time" timeStyle="full" /><br /><br><fmt:formatDate value="<%=new Date()%>" type="time" timeStyle="full" /><br /><br><fmt:setLocale value="zh_cn" />
<fmt:setTimeZone value="EST" />
<fmt:formatDate value="<%=new Date()%>" type="time" timeStyle="full" /><br />
<fmt:formatDate value="<%=new Date()%>" type="time" timeStyle="full" /><br />
<fmt:formatDate value="<%=new Date()%>" type="time" timeStyle="full" /><br /><br>输出:
   上午09时25分12秒 EST
   上午09时25分12秒 EST
   上午09时25分12秒 EST
    此时区在该页面内都有效
<strong>九：<fmt:timeZone></strong>
-------------------------------------------------------------------
    用来暂时设置时区.<br>Java代码 
<fmt:setLocale value="zh_cn" /><br><fmt:timeZone value="EST"><br><fmt:formatDate value="<%=new Date()%>" type="time" timeStyle="full" /><br><br /><br><fmt:formatDate value="<%=new Date()%>" type="time" timeStyle="full" /><br><br /><br></fmt:timeZone><br><fmt:formatDate value="<%=new Date()%>" type="time" timeStyle="full" /><br><fmt:setLocale value="zh_cn" />
<fmt:timeZone value="EST">
<fmt:formatDate value="<%=new Date()%>" type="time" timeStyle="full" />
<br />
<fmt:formatDate value="<%=new Date()%>" type="time" timeStyle="full" />
<br />
</fmt:timeZone>
<fmt:formatDate value="<%=new Date()%>" type="time" timeStyle="full" /><br>此标签的时区只是部分,在标签开始至标签结束内有效,其它地方无效,其它地方还是会使用默认时区















<strong><fn:> Function标签 **</strong>库 **

==========================================================================



JSTL Functions 标签库中提供了一组常用的 EL 函数，主要用于处理字符串，在 JSP 中可以直接使用这些函数。

在 JSP 文件中使用 Functions 标签库，要先通过 taglib 指令引入该标签库：

&lt;%@taglib uri=”<a href="http://java.sun.com/jsp/jstl/functions”" target="_blank">http://java.sun.com/jsp/jstl/functions”</a> prefix=”fn” %.



## 18.1fn:contains 函数

       fn:contains 函数用于判断在源字符串中是否包含目标字符串，其语法为：

              fn:contains(String source,String target) -------boolean;

       以上 source 参数指定源字符串， target 参数指定目标字符串，返回类型为 boolean 。

       例如对于以下 EL 表达式：

              ${fn:contains(“Tomcat”,”cat”)}

${fn:contains(“Tomcat”,”CAT”)}

       第一个 EL 表达式的值为 true ，第二个 EL 表达式的值为 false 。

## 18.2fn:containsIgnoreCase 函数

       fn:containsIgnoreCase 函数用于判断在源字符串中是否包含目标字符串，并且在判断时忽略大小写，其语法为：

       fn: containsIgnoreCase (String source,String target) -------boolean;

       以上 source 参数指定源字符串， target 参数指定目标字符串，返回类型为 boolean 。

       例如对于以下 EL 表达式：

              ${fn: containsIgnoreCase (“Tomcat”,”CAT”)}

${fn: containsIgnoreCase (“Tomcat”,”Mike”)}

       第一个 EL 表达式的值为 true ，第二个 EL 表达式的值为 false 。

## 18.3 fn:startsWith 函数

       fn:startsWith 函数用于判断源字符串是否以指定的目标字符串开头，其语法为：

              fn:startsWith(String source,String target) ----boolean

       以上 source 参数指定源字符串， target 参数指定目标字符串，返回类型为 boolean 。

       例如对于以下 EL 表达式：

              ${fn: startsWith (“Tomcat”,”Tom”)}

              ${fn: startsWith (“Tomcat”,”cat”)}

       第一个 EL 表达式的值为 true ，第二个 EL 表达式的值为 false 。

## 18.4 fn:endsWith 函数

fn: endsWith 函数用于判断源字符串是否以指定的目标字符串结尾，其语法为：

              fn: endsWith (String source,String target) ----boolean

       以上 source 参数指定源字符串， target 参数指定目标字符串，返回类型为 boolean 。

       例如对于以下 EL 表达式：

              ${fn: endsWith (“Tomcat”,”cat”)}

              ${fn: endsWith (“Tomcat”,”Tom”)}

       第一个 EL 表达式的值为 true ，第二个 EL 表达式的值为 false 。

## 18.5 fn:indexOf 函数

       fn:indexOf 函数用于在源字符串中查找目标字符串，并返回源字符串中最先与目标字符串匹配的第一个字符的索引，如果在源字符串中不包含目标字符串，就返回 -1 ，源字符串中的第一个字符的索引为 0 。 fn:indexOf 函数的语法为：

              fn: indexOf (String source,String target) ----int

       以上 source 参数指定源字符串， target 参数指定目标字符串，返回类型为 int 。

       例如对于以下 EL 表达式：

              1     ${fn: indexOf (“Tomcat”,”cat”)}<br/>

              2     ${fn: indexOf (“2211221”,”21”)} <br/>

              3     ${fn: indexOf (“Tomcat”,”Mike”)} <br/>

       其输出结果为：

              1     3

              2     1

              3     -1

## 18.6 fn:replace 函数

       fn:replace 函数用于把源字符串中的一部分替换为另外的字符串，并返回替换后的字符串。 fn:replace 函数的语法为：

              fn: replace (String source,String before,String after) ----String

       以上 source 参数指定源字符串， before 参数指定源字符串中被替换的子字符串， after 参数指定用于替换的子字符串，返回类型为 String 。

       例如对于以下 EL 表达式：

              1     ${ fn: replace(“TomcAt”,”cAt”,”cat”)}<br/>

              2     ${ fn: replace(“2008/1/9”,”/”,”-”)}<br/>

       其输出结果为：

              1     Tomcat

              2     2008-1-9

## 18.7 fn:substring 函数

       fn:substring 函数用于获取源字符串中的特定子字符串，它的语法为：

              fn:substring(String source,int beginIndex,int endIndex) ------String

       以上 source 参数指定源字符串， beginIndex 参数表示子字符串中的第一个字符在源字符串中的索引，endIndex 参数表示子字符串的最后一个字符在源字符串中的索引加 1 ，返回类型为 String ，源字符串中的第一个字符的索引为 0 。

       例如对于以下 EL 表达式：

              1     ${ fn: substring (“Tomcat”,0,3)}<br/>

              2     ${ fn: substring (“Tomcat”,3,”6”)}<br/>

       其输出结果为：

              1     Tom

              2     cat

## 18.8 fn:substringBefore 函数

       fn:substringBefore 函数用于获取源字符串中指定子字符串之前的子字符串，其语法为：

              fn:substringBefore(String source,String target) ----String

       以上 source 参数指定源字符串， target 参数指定子字符串，返回类型为 String 。如果在源字符串中不包含特定子字符串，就返回空字符串。

       例如对于以下 EL 表达式：

              1     ${ fn: substringBefore (“Tomcat”,”cat”)}<br/>

              2     ${ fn: substringBefore (“mydata.txt”,”.txt”)}<br/>

       其输出结果为：

              1     Tom

              2     mydata

## 18.9 fn:substringAfter 函数

       fn: substringAfter 函数用于获取源字符串中指定子字符串之后的子字符串，其语法为：

              fn: substringAfter (String source,String target) ----String

       以上 source 参数指定源字符串， target 参数指定子字符串，返回类型为 String 。如果在源字符串中不包含特定子字符串，就返回空字符串。

       例如对于以下 EL 表达式：

              1     ${ fn: substringAfter (“Tomcat”,”Tom”)}<br/>

              2     ${ fn: substringAfter (“mydata.txt”,” mydata.”)}<br/>

       其输出结果为：

              1     cat

              2     txt

## 18.10 fn:split 函数

       fn:split 函数用于将源字符串拆分为一个字符串数组，其语法为：

              fn: split (String source,String delimiter) ----String[]

       以上 source 参数指定源字符串， delimiter 参数指定用于拆分源字符串的分隔符，返回类型为 String[] 。如果在源字符串中不包含 delimiter 参数指定的分隔符，或者 delimiter 参数为 null ，那么在返回的字符串数组中只有一个元素，为源字符串。

       例如对于以下 EL 表达式：

              <c:set value=’${ fn: split (“www.mywebsite.org”,”.”)}’ var=”strs”/>

              <c:forEach var=”token” item=”${strs}”>

                     ${token}<br/>

              </c:forEach>

其输出结果为：

       www

       mywebsite

       org

再例如对于以下代码：

       <c:set value=’${ fn: split (“www.mywebsite.org”,”-”)}’ var=”strs”/>

${strs[0]}

其输出结果为：

       www.mywebsite.org

## 18.11 fn:join 函数

       fn:join 函数用于将源字符串数组中的所有字符串连接为一个字符串，其语法为：

              fn:join(String source[],String separator) ----String

       以上 source 参数指定源字符串数组， separator 参数指定用于连接源字符串数组中的各个字符串的分隔符，返回类型为 String 。

       例如对于以下代码：

              &lt;%

              String strs[] = {“www”,”mywebsite”,”org”};

%&gt;

<c:set value=”<%=strs%>” var=”strs”/&gt;

${fn:join(strs,”.”)}

       其输出结果为：

              www. mywebsite. org

## 18.12 fn:toLowerCase 函数

       fn:toLowerCase 函数用于将源字符串中的所有字符改为小写，其语法为：

              fn:toLowerCase(String source)  -----String

       以上 source 参数指定源字符串，返回类型为 String 。

       例如对于以下 EL 表达式：

              fn:toLowerCase(“TomCat”)

       其输出结果为：

              tomcat

## 18.13 fn:toUpperCase 函数

       fn: toUpperCase 函数用于将源字符串中的所有字符改为大写，其语法为：

              fn: toUpperCase (String source)  -----String

       以上 source 参数指定源字符串，返回类型为 String 。

       例如对于以下 EL 表达式：

              fn: toUpperCase (“TomCat”)

       其输出结果为：

              TOMCAT

## 18.14 fn:trim 函数

       fn:trim 函数用于将源字符串中的开头和末尾的空格删除，其语法为：

              fn:trim(String source) ----String

       以上 source 参数指定源字符串，返回类型为 String 。

       例如对于以下 EL 表达式：

              fn:trim(“   Tomcat   ”)

       以上 EL 表达式的值为“ Tomcat ”。

## 18.15 fn:escapeXml 函数

       fn:escapeXml 函数用于将源字符串中的字符“ &lt; ”、“ &gt; ”、“ ” ”和“ &amp; ”等转换为转义字符，本书第 1 章的 1.2 节（ HTML 简介）介绍了转义字符的概念。 fn:escapeXml 函数的行为与 <c:out> 标签的 escapeXml 属性为 true 时的转换行为相同， fn:escapeXml 函数的语法为：

       fn:escapeXml(String source) ----String

       以上 source 参数指定源字符串，返回类型为 String 。

       例程 18-1 的 out.jsp 演示了 fn:escapeXml 函数的用法。

&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;

&lt;%@ taglib uri=&quot;<a href="http://java.sun.com/jsp/jstl/core" target="_blank">http://java.sun.com/jsp/jstl/core</a>&quot; prefix=&quot;c&quot;%&gt;

&lt;%@ taglib uri=&quot;<a href="http://java.sun.com/jsp/jstl/functions" target="_blank">http://java.sun.com/jsp/jstl/functions</a>&quot; prefix=&quot;fn&quot;%&gt;

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />

<title>out</title>

</head>

<body>

1.${fn:escapeXml(&quot;<b> 表示粗体字 </b>&quot;) }<br/>

2.<c:out value="<b> 表示粗体字 </b>" escapeXml="true"></c:out><br/>

3.${&quot;<b> 表示粗体字 </b>&quot;}<br/>

</body>

</html>



<pre><code>   对于 out.jsp 中的以下代码：

          1.${fn:escapeXml(&quot;&lt;b&gt; 表示粗体字 &lt;/b&gt;&quot;) }&lt;br/&gt;
</code></pre><p>2.<c:out value="<b> 表示粗体字 </b>" escapeXml="true"></c:out><br/></p>
<p>3.${&quot;<b> 表示粗体字 </b>&quot;}<br/></p>
<pre><code>   其输出结果为：

          1.&amp;lt;b&amp;gt; 表示粗体字 &amp;lt;/b&amp;gt;&lt;br/&gt;
</code></pre><p>2.&lt;b&gt; 表示粗体字 &lt;/b&gt;<br/></p>
<p>3.<b> 表示粗体字 </b><br/></p>
<h2 id="18-16-fn-length-">18.16 fn:length 函数</h2>
<pre><code>   fn:length 函数用于返回字符串中的字符的个数，或者集合和数组的元素的个数，其语法为：

          fn:length(source) ---- int

   以上 source 参数可以为字符串、集合或者数组，返回类型为 int 。
</code></pre><p>&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;</p>
<pre><code>pageEncoding=&quot;UTF-8&quot;%&gt;
</code></pre><p>&lt;%@ taglib uri=&quot;<a href="http://java.sun.com/jsp/jstl/core" target="_blank">http://java.sun.com/jsp/jstl/core</a>&quot; prefix=&quot;c&quot;%&gt;</p>
<p>&lt;%@ taglib uri=&quot;<a href="http://java.sun.com/jsp/jstl/functions" target="_blank">http://java.sun.com/jsp/jstl/functions</a>&quot; prefix=&quot;fn&quot;%&gt;</p>
<p>&lt;%@page import=&quot;java.util.ArrayList&quot;%&gt;</p>
<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />

<title>length</title>

</head>

<body>

&lt;%

int[] array = {1,2,3,4};

ArrayList list = new ArrayList();

list.add(&quot;one&quot;);

list.add(&quot;two&quot;);

list.add(&quot;three&quot;);

%&gt;

<c:set value="<%=array%>" var="array"></c:set>

<c:set value="<%=list%>" var="list"></c:set>

数组长度： ${fn:length(array)}<br/>

集合长度： ${fn:length(list)}<br/>

字符串长度： ${fn:length(&quot;Tomcat&quot;)}<br/>

</body>

</html>









<p><strong>Functions 标签库概览</strong></p>
<p>l  fn:contains 函数 ： 用于判断在源字符串中是否包含目标字符串。</p>
<p>l  fn:containsIgnoreCase 函数 ： 用于判断在源字符串中是否包含目标字符串 ， 并且在判断时忽略大小写。</p>
<p>l  fn:startsWith 函数 ： 用于判断源字符串是否以指定的目标字符串开头。</p>
<p>l  fn: endsWith 函数：用于判断源字符串是否以指定的目标字符串结尾。</p>
<p>l  fn:indexOf 函数：用于在源字符串中查找目标字符串，并返回源字符串中最先与目标字符串匹配的第一个字符的索引。</p>
<p>l  fn:replace 函数：用于把源字符串中的一部分替换为另外的字符串，并返回替换后的字符串。</p>
<p>l  fn:substring 函数：用于获取源字符串中的特定子字符串。</p>
<p>l  fn:substringBefore 函数：用于获取源字符串中指定子字符串之前的子字符串。</p>
<p>l  fn: substringAfter 函数：用于获取源字符串中指定子字符串之后的子字符串</p>
<p>l  fn:split 函数：用于将源字符串拆分为一个字符串数组。</p>
<p>l  fn:join 函数：用于将源字符串数组中的所有字符串连接为一个字符串。</p>
<p>l  fn:toLowerCase 函数：用于将源字符串中的所有字符改为小写。</p>
<p>l  fn: toUpperCase 函数：用于将源字符串中的所有字符改为大写。</p>
<p>l  fn:trim 函数：用于将源字符串中的开头和末尾的空格删除。</p>
<p>l  fn:escapeXml 函数：用于将源字符串中的字符“ &lt; ”、“ &gt; ”、“ ” ”和“ &amp; ”等转换为转义字符。</p>
<p>l  fn:length 函数：用于返回字符串中的字符的个数，或者集合和数组的元素的个数
来源： <a href="[http://elf8848.iteye.com/blog/245559](http://elf8848.iteye.com/blog/245559)">[http://elf8848.iteye.com/blog/245559](http://elf8848.iteye.com/blog/245559)</a> </p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a></span> | <span class="time">recent updated:<time title="2014-03-30 13:01:46"datetime="2014-03-30 13:01:46"> mar. 30 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE--JSTL标签参考手册/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE--JSTL标签参考手册" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-java-com-jacob--java操作word文档jacob-poi/">java操作word文档(jacob</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:41.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-java-com-jacob--java操作word文档jacob-poi/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="java-word-jacob-poi-">java操作word文档(jacob,poi)</h1>
<p>项目需要，用户从系统里面下载word文档，该文档进行了填写限制和加密，用户只能在固定位置填写内容。现要求系统验证上传的附件是否从系统上下载下来的。</p>
<p>思路：系统上面的文档都加入一个固定书签，用户上传文档的时候，检验文档里是否包含这个书签。</p>
<p>采用jacob操作word文档</p>
<p>JACOB（java -com bridge）是一个 JAVA到微软的COM接口的桥梁。使用JACOB允许任何JVM访问COM对象，从而使JAVA应用程序能够调用COM对象。</p>
<p>下载地址：<a href="http://sourceforge.net/projects/jacob-project/" target="_blank"><a href="http://sourceforge.net/projects/jacob-project/">http://sourceforge.net/projects/jacob-project/</a></a></p>
<p>其中jacob-1.16.1-x64.dll 是用于64位机器上的，jacob-1.16.1-x86.dll用于32位的。</p>
<p>该dll放于 C:\Windows\system32 目录下。jacob.jar放于应用lib底下</p>
<p>测试代码
Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>ActiveXComponent    word = null;  </li>
<li>try {  </li>
<li>word = new ActiveXComponent(&quot;Word.Application&quot;);  </li>
<li>System.out.println(&quot;jacob当前版本：&quot;+word.getBuildVersion());  </li>
<li>}catch(Exception e ){  </li>
<li>e.printStackTrace();  </li>
<li>}  </li>
</ol>
<p>ActiveXComponent    word = null;</p>
<p>try {
        word = new ActiveXComponent(&quot;Word.Application&quot;);</p>
<pre><code>    System.out.println(&quot;jacob当前版本：&quot;+word.getBuildVersion());
</code></pre><p>}catch(Exception e ){</p>
<pre><code>     e.printStackTrace();
</code></pre><p>}</p>
<p>下面再贴出网上常见的代码+自己整理的几个方法（模糊查询书签等）</p>
<p>注意插入书签+书签值的方法，要先插入书签值再选中书签值，之后插入书签。这样根据书签名才能取得书签值。否则根据网络上很多方法，都取不到书签值或者取到空。因为书签值可以是一个点也可以是一大段内容。
Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>import java.io.File;  </li>
<li>import java.util.HashMap;  </li>
<li>import java.util.Map;  </li>
<li></li>
<li>import com.gdcn.bpaf.common.helper.StringHelper;  </li>
<li>import com.jacob.activeX.ActiveXComponent;  </li>
<li>import com.jacob.com.ComThread;  </li>
<li>import com.jacob.com.Dispatch;  </li>
<li>import com.jacob.com.Variant;  </li>
<li>//<em>/</em> </li>
<li>/<em>  /</em> </li>
<li>/* <p>Description: {jacob操作word类}    </p> </li>
<li>/* </li>
<li>/* <p>Copyright: Copyright (c) 2011</p> </li>
<li>/*  </li>
<li>/* <p>CreateDate: 2012-6-28</p> </li>
<li>/* </li>
<li>/* @author Beny </li>
<li>/* @version 1.0 </li>
<li>/*/  </li>
<li></li>
<li>public class JacobHelper {  </li>
<li>// word文档  </li>
<li>private Dispatch doc;  </li>
<li></li>
<li>// word运行程序对象  </li>
<li>private ActiveXComponent word;  </li>
<li></li>
<li>// 所有word文档集合  </li>
<li>private Dispatch documents;  </li>
<li></li>
<li>// 选定的范围或插入点  </li>
<li>private Dispatch selection;  </li>
<li></li>
<li>private boolean saveOnExit = true;  </li>
<li></li>
<li>public JacobHelper(boolean visible) throws Exception {  </li>
<li>ComThread.InitSTA();//线程启动  </li>
<li>if (word == null) {  </li>
<li>word = new ActiveXComponent(&quot;Word.Application&quot;);  </li>
<li>word.setProperty(&quot;Visible&quot;, new Variant(visible)); // 不可见打开word  </li>
<li>word.setProperty(&quot;AutomationSecurity&quot;, new Variant(3)); // 禁用宏  </li>
<li>}  </li>
<li>if (documents == null)  </li>
<li>documents = word.getProperty(&quot;Documents&quot;).toDispatch();  </li>
<li>}  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* 设置退出时参数 </li>
<li>/*  </li>
<li>/* @param saveOnExit </li>
<li>/*            boolean true-退出时保存文件，false-退出时不保存文件 </li>
<li>/*/  </li>
<li>public void setSaveOnExit(boolean saveOnExit) {  </li>
<li>this.saveOnExit = saveOnExit;  </li>
<li>}  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* 创建一个新的word文档 </li>
<li>/*  </li>
<li>/*/  </li>
<li>public void createNewDocument() {  </li>
<li>doc = Dispatch.call(documents, &quot;Add&quot;).toDispatch();  </li>
<li>selection = Dispatch.get(word, &quot;Selection&quot;).toDispatch();  </li>
<li>}  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* 打开一个已存在的文档 </li>
<li>/*  </li>
<li>/* @param docPath </li>
<li>/*/  </li>
<li>public void openDocument(String docPath) {  </li>
<li>//      closeDocument();  </li>
<li>doc = Dispatch.call(documents, &quot;Open&quot;, docPath).toDispatch();  </li>
<li>selection = Dispatch.get(word, &quot;Selection&quot;).toDispatch();  </li>
<li>}  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* 只读方式打开一个加密的文档 </li>
<li>/*  </li>
<li>/* @param docPath-文件全名 </li>
<li>/* @param pwd-密码 </li>
<li>/*/  </li>
<li>public void openDocumentOnlyRead(String docPath, String pwd)  </li>
<li>throws Exception {  </li>
<li>//      closeDocument();  </li>
<li>doc = Dispatch.callN(  </li>
<li>documents,  </li>
<li>&quot;Open&quot;,  </li>
<li>new Object[] { docPath, new Variant(false), new Variant(true),  </li>
<li>new Variant(true), pwd, &quot;&quot;, new Variant(false) })  </li>
<li>.toDispatch();  </li>
<li>selection = Dispatch.get(word, &quot;Selection&quot;).toDispatch();  </li>
<li>}  </li>
<li>//<em>/</em> </li>
<li>/* 打开一个加密的文档 </li>
<li>/* @param docPath </li>
<li>/* @param pwd </li>
<li>/* @throws Exception </li>
<li>/*/  </li>
<li>public void openDocument(String docPath, String pwd) throws Exception {  </li>
<li>//      closeDocument();  </li>
<li>doc = Dispatch.callN(  </li>
<li>documents,  </li>
<li>&quot;Open&quot;,  </li>
<li>new Object[] { docPath, new Variant(false), new Variant(false),  </li>
<li>new Variant(true), pwd }).toDispatch();  </li>
<li>selection = Dispatch.get(word, &quot;Selection&quot;).toDispatch();  </li>
<li>}  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* 从选定内容或插入点开始查找文本 </li>
<li>/*  </li>
<li>/* @param toFindText </li>
<li>/*            要查找的文本 </li>
<li>/* @return boolean true-查找到并选中该文本，false-未查找到文本 </li>
<li>/*/  </li>
<li>@SuppressWarnings(&quot;static-access&quot;)  </li>
<li>public boolean find(String toFindText) {  </li>
<li>if (toFindText == null || toFindText.equals(&quot;&quot;))  </li>
<li>return false;  </li>
<li>// 从selection所在位置开始查询  </li>
<li>Dispatch find = word.call(selection, &quot;Find&quot;).toDispatch();  </li>
<li>// 设置要查找的内容  </li>
<li>Dispatch.put(find, &quot;Text&quot;, toFindText);  </li>
<li>// 向前查找  </li>
<li>Dispatch.put(find, &quot;Forward&quot;, &quot;True&quot;);  </li>
<li>// 设置格式  </li>
<li>Dispatch.put(find, &quot;Format&quot;, &quot;True&quot;);  </li>
<li>// 大小写匹配  </li>
<li>Dispatch.put(find, &quot;MatchCase&quot;, &quot;True&quot;);  </li>
<li>// 全字匹配  </li>
<li>Dispatch.put(find, &quot;MatchWholeWord&quot;, &quot;false&quot;);  </li>
<li>// 查找并选中  </li>
<li>return Dispatch.call(find, &quot;Execute&quot;).getBoolean();  </li>
<li>}  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* 把选定选定内容设定为替换文本 </li>
<li>/*  </li>
<li>/* @param toFindText </li>
<li>/*            查找字符串 </li>
<li>/* @param newText </li>
<li>/*            要替换的内容 </li>
<li>/* @return </li>
<li>/*/  </li>
<li>public boolean replaceText(String toFindText, String newText) {  </li>
<li>if (!find(toFindText))  </li>
<li>return false;  </li>
<li>Dispatch.put(selection, &quot;Text&quot;, newText);  </li>
<li>return true;  </li>
<li>}  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* 全局替换文本 </li>
<li>/*  </li>
<li>/* @param toFindText </li>
<li>/*            查找字符串 </li>
<li>/* @param newText </li>
<li>/*            要替换的内容 </li>
<li>/*/  </li>
<li>public void replaceAllText(String toFindText, String newText) {  </li>
<li>while (find(toFindText)) {  </li>
<li>Dispatch.put(selection, &quot;Text&quot;, newText);  </li>
<li>Dispatch.call(selection, &quot;MoveRight&quot;);  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* 在当前插入点插入字符串 </li>
<li>/*  </li>
<li>/* @param newText </li>
<li>/*            要插入的新字符串 </li>
<li>/*/  </li>
<li>public void insertText(String newText) {  </li>
<li>Dispatch.put(selection, &quot;Text&quot;, newText);  </li>
<li>}  </li>
<li></li>
<li></li>
<li></li>
<li>//<em>/</em> </li>
<li>/* 设置当前选定内容的字体 </li>
<li>/*  </li>
<li>/* @param boldSize </li>
<li>/* @param italicSize </li>
<li>/* @param underLineSize </li>
<li>/*            下划线 </li>
<li>/* @param colorSize </li>
<li>/*            字体颜色 </li>
<li>/* @param size </li>
<li>/*            字体大小 </li>
<li>/* @param name </li>
<li>/*            字体名称 </li>
<li>/* @param hidden </li>
<li>/*            是否隐藏 </li>
<li>/*/  </li>
<li>public void setFont(boolean bold, boolean italic, boolean underLine,  </li>
<li>String colorSize, String size, String name,boolean hidden) {  </li>
<li>Dispatch font = Dispatch.get(selection, &quot;Font&quot;).toDispatch();  </li>
<li>Dispatch.put(font, &quot;Name&quot;, new Variant(name));  </li>
<li>Dispatch.put(font, &quot;Bold&quot;, new Variant(bold));  </li>
<li>Dispatch.put(font, &quot;Italic&quot;, new Variant(italic));  </li>
<li>Dispatch.put(font, &quot;Underline&quot;, new Variant(underLine));  </li>
<li>Dispatch.put(font, &quot;Color&quot;, colorSize);  </li>
<li>Dispatch.put(font, &quot;Size&quot;, size);  </li>
<li>Dispatch.put(font, &quot;Hidden&quot;, hidden);  </li>
<li>}  </li>
<li></li>
<li></li>
<li>//<em>/</em> </li>
<li>/* 文件保存或另存为 </li>
<li>/*  </li>
<li>/* @param savePath </li>
<li>/*            保存或另存为路径 </li>
<li>/*/  </li>
<li>public void save(String savePath) {  </li>
<li>Dispatch.call(Dispatch.call(word, &quot;WordBasic&quot;).getDispatch(),  </li>
<li>&quot;FileSaveAs&quot;, savePath);  </li>
<li>}  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* 文件保存为html格式 </li>
<li>/*  </li>
<li>/* @param savePath </li>
<li>/* @param htmlPath </li>
<li>/*/  </li>
<li>public void saveAsHtml(String htmlPath) {  </li>
<li>Dispatch.invoke(doc, &quot;SaveAs&quot;, Dispatch.Method, new Object[] {  </li>
<li>htmlPath, new Variant(8) }, new int[1]);  </li>
<li>}  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* 关闭文档 </li>
<li>/*  </li>
<li>/* @param val </li>
<li>/*            0不保存修改 -1 保存修改 -2 提示是否保存修改 </li>
<li>/*/  </li>
<li>public void closeDocument(int val) {  </li>
<li>Dispatch.call(doc, &quot;Close&quot;, new Variant(val));//注 是documents而不是doc  </li>
<li>documents = null;  </li>
<li>doc = null;  </li>
<li>}  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* 关闭当前word文档 </li>
<li>/*  </li>
<li>/*/  </li>
<li>public void closeDocument() {  </li>
<li>if (documents != null) {  </li>
<li>Dispatch.call(documents, &quot;Save&quot;);  </li>
<li>Dispatch.call(documents, &quot;Close&quot;, new Variant(saveOnExit));  </li>
<li>documents = null;  </li>
<li>doc = null;  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>public void closeDocumentWithoutSave() {  </li>
<li>if (documents != null) {  </li>
<li>Dispatch.call(documents, &quot;Close&quot;, new Variant(false));  </li>
<li>documents = null;  </li>
<li>doc = null;  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* 保存并关闭全部应用 </li>
<li>/*  </li>
<li>/*/  </li>
<li>public void close() {  </li>
<li>closeDocument(-1);  </li>
<li>if (word != null) {  </li>
<li>//          Dispatch.call(word, &quot;Quit&quot;);  </li>
<li>word.invoke(&quot;Quit&quot;, new Variant[] {});  </li>
<li>word = null;  </li>
<li>}  </li>
<li>selection = null;  </li>
<li>documents = null;  </li>
<li>ComThread.Release();//释放com线程。根据jacob的帮助文档，com的线程回收不由java的垃圾回收器处理  </li>
<li></li>
<li>}  </li>
<li>//<em>/</em> </li>
<li>/* 打印当前word文档 </li>
<li>/*  </li>
<li>/*/  </li>
<li>public void printFile() {  </li>
<li>if (doc != null) {  </li>
<li>Dispatch.call(doc, &quot;PrintOut&quot;);  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* 保护当前档,如果不存在, 使用expression.Protect(Type, NoReset, Password) </li>
<li>/*  </li>
<li>/* @param pwd </li>
<li>/* @param type </li>
<li>/*            WdProtectionType 常量之一(int 类型，只读)： </li>
<li>/*            1-wdAllowOnlyComments  仅批注 </li>
<li>/*            2-wdAllowOnlyFormFields 仅填写窗体 </li>
<li>/*            0-wdAllowOnlyRevisions 仅修订 </li>
<li>/*            -1-wdNoProtection 无保护,  </li>
<li>/*            3-wdAllowOnlyReading 只读 </li>
<li>/*  </li>
<li>/*/  </li>
<li>public void protectedWord(String pwd,String type) {  </li>
<li>String protectionType = Dispatch.get(doc, &quot;ProtectionType&quot;).toString();  </li>
<li>if (protectionType.equals(&quot;-1&quot;)) {  </li>
<li>Dispatch.call(doc, &quot;Protect&quot;, Integer.parseInt(type), new Variant(true),pwd);  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* 解除文档保护,如果存在 </li>
<li>/*  </li>
<li>/* @param pwd </li>
<li>/*            WdProtectionType 常量之一(int 类型，只读)： </li>
<li>/*            1-wdAllowOnlyComments  仅批注 </li>
<li>/*            2-wdAllowOnlyFormFields 仅填写窗体 </li>
<li>/*            0-wdAllowOnlyRevisions 仅修订 </li>
<li>/*            -1-wdNoProtection 无保护,  </li>
<li>/*            3-wdAllowOnlyReading 只读 </li>
<li>/*  </li>
<li>/*/  </li>
<li>public void unProtectedWord(String pwd) {  </li>
<li>String protectionType = Dispatch.get(doc, &quot;ProtectionType&quot;).toString();  </li>
<li>if (!protectionType.equals(&quot;0&quot;)&amp;&amp;!protectionType.equals(&quot;-1&quot;)) {  </li>
<li>Dispatch.call(doc, &quot;Unprotect&quot;, pwd);  </li>
<li>}  </li>
<li>}  </li>
<li>//<em>/</em> </li>
<li>/* 返回文档的保护类型 </li>
<li>/* @return </li>
<li>/*/  </li>
<li>public String getProtectedType(){  </li>
<li>return Dispatch.get(doc, &quot;ProtectionType&quot;).toString();  </li>
<li>}  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* 设置word文档安全级别 </li>
<li>/*  </li>
<li>/* @param value </li>
<li>/*            1-msoAutomationSecurityByUI 使用“安全”对话框指定的安全设置。 </li>
<li>/*            2-msoAutomationSecurityForceDisable </li>
<li>/*            在程序打开的所有文件中禁用所有宏，而不显示任何安全提醒。 3-msoAutomationSecurityLow </li>
<li>/*            启用所有宏，这是启动应用程序时的默认值。 </li>
<li>/*/  </li>
<li>public void setAutomationSecurity(int value) {  </li>
<li>word.setProperty(&quot;AutomationSecurity&quot;, new Variant(value));  </li>
<li>}  </li>
<li></li>
<li></li>
<li></li>
<li></li>
<li>//<em>/</em> </li>
<li>/* 在word中插入标签 labelName是标签名，labelValue是标签值 </li>
<li>/* @param labelName </li>
<li>/* @param labelValue </li>
<li>/*/  </li>
<li>public  void insertLabelValue(String labelName,String labelValue) {  </li>
<li></li>
<li>Dispatch bookMarks = Dispatch.call(doc, &quot;Bookmarks&quot;).toDispatch();  </li>
<li>boolean isExist = Dispatch.call(bookMarks, &quot;Exists&quot;, labelName).getBoolean();  </li>
<li>if (isExist == true) {  </li>
<li>Dispatch rangeItem1 = Dispatch.call(bookMarks, &quot;Item&quot;, labelName).toDispatch();  </li>
<li>Dispatch range1 = Dispatch.call(rangeItem1, &quot;Range&quot;).toDispatch();  </li>
<li>String bookMark1Value = Dispatch.get(range1, &quot;Text&quot;).toString();  </li>
<li>System.out.println(&quot;书签内容：&quot;+bookMark1Value);  </li>
<li>} else {  </li>
<li>System.out.println(&quot;当前书签不存在,重新建立!&quot;);  </li>
<li>//TODO 先插入文字，再查找选中文字，再插入标签  </li>
<li>this.insertText(labelValue);  </li>
<li>//          this.find(labelValue);//查找文字，并选中  </li>
<li>this.setFont(true, true,true,&quot;102,92,38&quot;, &quot;20&quot;, &quot;&quot;,true);  </li>
<li>Dispatch.call(bookMarks, &quot;Add&quot;, labelName, selection);  </li>
<li>Dispatch.call(bookMarks, &quot;Hidden&quot;, labelName);  </li>
<li>}  </li>
<li>}  </li>
<li>//<em>/</em> </li>
<li>/* 在word中插入标签 labelName是标签名 </li>
<li>/* @param labelName </li>
<li>/*/  </li>
<li>public  void insertLabel(String labelName) {  </li>
<li></li>
<li>Dispatch bookMarks = Dispatch.call(doc, &quot;Bookmarks&quot;).toDispatch();  </li>
<li>boolean isExist = Dispatch.call(bookMarks, &quot;Exists&quot;, labelName).getBoolean();  </li>
<li>if (isExist == true) {  </li>
<li>System.out.println(&quot;书签已存在&quot;);  </li>
<li>} else {  </li>
<li>System.out.println(&quot;建立书签：&quot;+labelName);  </li>
<li>Dispatch.call(bookMarks, &quot;Add&quot;, labelName, selection);  </li>
<li>}  </li>
<li>}     </li>
<li>//<em>/</em> </li>
<li>/* 查找书签 </li>
<li>/* @param labelName </li>
<li>/* @return </li>
<li>/*/  </li>
<li>public boolean findLabel(String labelName) {  </li>
<li>Dispatch bookMarks = Dispatch.call(doc, &quot;Bookmarks&quot;).toDispatch();  </li>
<li>boolean isExist = Dispatch.call(bookMarks, &quot;Exists&quot;, labelName).getBoolean();  </li>
<li>if (isExist == true) {  </li>
<li>return true;  </li>
<li>} else {  </li>
<li>System.out.println(&quot;当前书签不存在!&quot;);  </li>
<li>return false;  </li>
<li>}  </li>
<li>}  </li>
<li>//<em>/</em> </li>
<li>/* 模糊查找书签,并返回准确的书签名称 </li>
<li>/* @param labelName </li>
<li>/* @return </li>
<li>/*/  </li>
<li>public String findLabelLike(String labelName) {  </li>
<li>Dispatch bookMarks = Dispatch.call(doc, &quot;Bookmarks&quot;).toDispatch();  </li>
<li>int count = Dispatch.get(bookMarks, &quot;Count&quot;).getInt(); // 书签数  </li>
<li>Dispatch rangeItem = null;  </li>
<li>String lname = &quot;&quot;;  </li>
<li>for(int i=1;i&lt;=count;i++){  </li>
<li>rangeItem = Dispatch.call(bookMarks, &quot;Item&quot;, new Variant(i)).toDispatch();  </li>
<li>lname = Dispatch.call(rangeItem, &quot;Name&quot;).toString();//书签名称  </li>
<li>if(lname.startsWith(labelName)){//前面匹配  </li>
<li>//             return lname.replaceFirst(labelName, &quot;&quot;);//返回后面值  </li>
<li>return lname;  </li>
<li>}  </li>
<li>}  </li>
<li>return &quot;&quot;;  </li>
<li>}  </li>
<li>//<em>/</em> </li>
<li>/* 模糊删除书签 </li>
<li>/* @param labelName </li>
<li>/*/  </li>
<li>public void deleteLableLike(String labelName){  </li>
<li>Dispatch bookMarks = Dispatch.call(doc, &quot;Bookmarks&quot;).toDispatch();  </li>
<li>int count = Dispatch.get(bookMarks, &quot;Count&quot;).getInt(); // 书签数  </li>
<li>Dispatch rangeItem = null;  </li>
<li>String lname = &quot;&quot;;  </li>
<li>for(int i=1;i&lt;=count;i++){  </li>
<li>rangeItem = Dispatch.call(bookMarks, &quot;Item&quot;, new Variant(i)).toDispatch();  </li>
<li>lname = Dispatch.call(rangeItem, &quot;Name&quot;).toString();//书签名称  </li>
<li>if(lname.startsWith(labelName)){//前面匹配  </li>
<li>Dispatch.call(rangeItem, &quot;Delete&quot;);  </li>
<li>count--;//书签已被删除，书签数目和当前书签都要相应减1，否则会报错:集合找不到  </li>
<li>i--;  </li>
<li>}  </li>
<li>}  </li>
<li>}  </li>
<li>//<em>/</em> </li>
<li>/* 获取书签内容 </li>
<li>/* @param labelName </li>
<li>/* @return </li>
<li>/*/  </li>
<li>public String getLableValue(String labelName){  </li>
<li>if(this.findLabel(labelName)){  </li>
<li>Dispatch bookMarks = Dispatch.call(doc, &quot;Bookmarks&quot;).toDispatch();  </li>
<li>Dispatch rangeItem1 = Dispatch.call(bookMarks, &quot;Item&quot;, labelName).toDispatch();  </li>
<li>Dispatch range1 = Dispatch.call(rangeItem1, &quot;Range&quot;).toDispatch();  </li>
<li>Dispatch font = Dispatch.get(range1, &quot;Font&quot;).toDispatch();  </li>
<li>Dispatch.put(font, &quot;Hidden&quot;, new Variant(false)); //显示书签内容  </li>
<li>String bookMark1Value = Dispatch.get(range1, &quot;Text&quot;).toString();  </li>
<li>System.out.println(&quot;书签内容：&quot;+bookMark1Value);  </li>
<li>//            font = Dispatch.get(range1, &quot;Font&quot;).toDispatch();  </li>
<li>//              Dispatch.put(font, &quot;Hidden&quot;, new Variant(true)); //隐藏书签内容  </li>
<li>return bookMark1Value;  </li>
<li>}  </li>
<li>return &quot;&quot;;  </li>
<li>}  </li>
<li></li>
<li></li>
<li>public static void main(String[] args) throws Exception {  </li>
<li></li>
<li>}     </li>
<li></li>
<li>}  </li>
</ol>
<p>import java.io.File;</p>
<p>import java.util.HashMap;
import java.util.Map;</p>
<p>import com.gdcn.bpaf.common.helper.StringHelper;</p>
<p>import com.jacob.activeX.ActiveXComponent;
import com.jacob.com.ComThread;</p>
<p>import com.jacob.com.Dispatch;
import com.jacob.com.Variant;</p>
<p>//<em>/</em>
 /<em>  /</em></p>
<p> /<em> <p>Description: {jacob操作word类}    </p>
/</em></p>
<p>/<em> <p>Copyright: Copyright (c) 2011</p>
/</em></p>
<p>/<em> <p>CreateDate: 2012-6-28</p>
/</em></p>
<p>/<em> @author Beny
/</em> @version 1.0</p>
<p>/*/</p>
<p>public class JacobHelper {
    // word文档</p>
<pre><code>private Dispatch doc;


// word运行程序对象
private ActiveXComponent word;


// 所有word文档集合

private Dispatch documents;


// 选定的范围或插入点
private Dispatch selection;


private boolean saveOnExit = true;


public JacobHelper(boolean visible) throws Exception {

    ComThread.InitSTA();//线程启动
    if (word == null) {

        word = new ActiveXComponent(&quot;Word.Application&quot;);
        word.setProperty(&quot;Visible&quot;, new Variant(visible)); // 不可见打开word

        word.setProperty(&quot;AutomationSecurity&quot;, new Variant(3)); // 禁用宏
    }

    if (documents == null)
        documents = word.getProperty(&quot;Documents&quot;).toDispatch();

}


//*/*
 /* 设置退出时参数

 /*
 /* @param saveOnExit

 /*            boolean true-退出时保存文件，false-退出时不保存文件
 /*/

public void setSaveOnExit(boolean saveOnExit) {
    this.saveOnExit = saveOnExit;

}


//*/*
 /* 创建一个新的word文档

 /*
 /*/

public void createNewDocument() {
    doc = Dispatch.call(documents, &quot;Add&quot;).toDispatch();

    selection = Dispatch.get(word, &quot;Selection&quot;).toDispatch();
}


//*/*

 /* 打开一个已存在的文档
 /*

 /* @param docPath
 /*/

public void openDocument(String docPath) {
</code></pre><p>//        closeDocument();</p>
<pre><code>    doc = Dispatch.call(documents, &quot;Open&quot;, docPath).toDispatch();
    selection = Dispatch.get(word, &quot;Selection&quot;).toDispatch();

}


//*/*
 /* 只读方式打开一个加密的文档

 /*
 /* @param docPath-文件全名

 /* @param pwd-密码
 /*/

public void openDocumentOnlyRead(String docPath, String pwd)
        throws Exception {
</code></pre><p>//        closeDocument();
        doc = Dispatch.callN(</p>
<pre><code>            documents,
            &quot;Open&quot;,

            new Object[] { docPath, new Variant(false), new Variant(true),
                    new Variant(true), pwd, &quot;&quot;, new Variant(false) })

            .toDispatch();
    selection = Dispatch.get(word, &quot;Selection&quot;).toDispatch();

}
//*/*

 /* 打开一个加密的文档
 /* @param docPath

 /* @param pwd
 /* @throws Exception

 /*/
public void openDocument(String docPath, String pwd) throws Exception {
</code></pre><p>//        closeDocument();
        doc = Dispatch.callN(</p>
<pre><code>            documents,
            &quot;Open&quot;,

            new Object[] { docPath, new Variant(false), new Variant(false),
                    new Variant(true), pwd }).toDispatch();

    selection = Dispatch.get(word, &quot;Selection&quot;).toDispatch();
}


//*/*

 /* 从选定内容或插入点开始查找文本
 /*

 /* @param toFindText
 /*            要查找的文本

 /* @return boolean true-查找到并选中该文本，false-未查找到文本
 /*/

@SuppressWarnings(&quot;static-access&quot;)
public boolean find(String toFindText) {

    if (toFindText == null || toFindText.equals(&quot;&quot;))
        return false;

    // 从selection所在位置开始查询
    Dispatch find = word.call(selection, &quot;Find&quot;).toDispatch();

    // 设置要查找的内容
    Dispatch.put(find, &quot;Text&quot;, toFindText);

    // 向前查找
    Dispatch.put(find, &quot;Forward&quot;, &quot;True&quot;);

    // 设置格式
    Dispatch.put(find, &quot;Format&quot;, &quot;True&quot;);

    // 大小写匹配
    Dispatch.put(find, &quot;MatchCase&quot;, &quot;True&quot;);

    // 全字匹配
    Dispatch.put(find, &quot;MatchWholeWord&quot;, &quot;false&quot;);

    // 查找并选中
    return Dispatch.call(find, &quot;Execute&quot;).getBoolean();

}


//*/*
 /* 把选定选定内容设定为替换文本

 /*
 /* @param toFindText

 /*            查找字符串
 /* @param newText

 /*            要替换的内容
 /* @return

 /*/
public boolean replaceText(String toFindText, String newText) {

    if (!find(toFindText))
        return false;

    Dispatch.put(selection, &quot;Text&quot;, newText);
    return true;

}


//*/*
 /* 全局替换文本

 /*
 /* @param toFindText

 /*            查找字符串
 /* @param newText

 /*            要替换的内容
 /*/

public void replaceAllText(String toFindText, String newText) {
    while (find(toFindText)) {

        Dispatch.put(selection, &quot;Text&quot;, newText);
        Dispatch.call(selection, &quot;MoveRight&quot;);

    }
}


//*/*

 /* 在当前插入点插入字符串
 /*

 /* @param newText
 /*            要插入的新字符串

 /*/
public void insertText(String newText) {

    Dispatch.put(selection, &quot;Text&quot;, newText);
}





//*/*

 /* 设置当前选定内容的字体
 /*

 /* @param boldSize
 /* @param italicSize

 /* @param underLineSize
 /*            下划线

 /* @param colorSize
 /*            字体颜色

 /* @param size
 /*            字体大小

 /* @param name
 /*            字体名称

 /* @param hidden
 /*            是否隐藏

 /*/
public void setFont(boolean bold, boolean italic, boolean underLine,

        String colorSize, String size, String name,boolean hidden) {
    Dispatch font = Dispatch.get(selection, &quot;Font&quot;).toDispatch();

    Dispatch.put(font, &quot;Name&quot;, new Variant(name));
    Dispatch.put(font, &quot;Bold&quot;, new Variant(bold));

    Dispatch.put(font, &quot;Italic&quot;, new Variant(italic));
    Dispatch.put(font, &quot;Underline&quot;, new Variant(underLine));

    Dispatch.put(font, &quot;Color&quot;, colorSize);
    Dispatch.put(font, &quot;Size&quot;, size);

    Dispatch.put(font, &quot;Hidden&quot;, hidden);
}




//*/*
 /* 文件保存或另存为

 /*
 /* @param savePath

 /*            保存或另存为路径
 /*/

public void save(String savePath) {
    Dispatch.call(Dispatch.call(word, &quot;WordBasic&quot;).getDispatch(),

            &quot;FileSaveAs&quot;, savePath);
}


//*/*

 /* 文件保存为html格式
 /*

 /* @param savePath
 /* @param htmlPath

 /*/
public void saveAsHtml(String htmlPath) {

    Dispatch.invoke(doc, &quot;SaveAs&quot;, Dispatch.Method, new Object[] {
            htmlPath, new Variant(8) }, new int[1]);

}


//*/*
 /* 关闭文档

 /*
 /* @param val

 /*            0不保存修改 -1 保存修改 -2 提示是否保存修改
 /*/

public void closeDocument(int val) {
    Dispatch.call(doc, &quot;Close&quot;, new Variant(val));//注 是documents而不是doc

    documents = null;
    doc = null;

}


//*/*
 /* 关闭当前word文档

 /*
 /*/

public void closeDocument() {
    if (documents != null) {

        Dispatch.call(documents, &quot;Save&quot;);
        Dispatch.call(documents, &quot;Close&quot;, new Variant(saveOnExit));

        documents = null;
        doc = null;

    }
}


public void closeDocumentWithoutSave() {

    if (documents != null) {
        Dispatch.call(documents, &quot;Close&quot;, new Variant(false));

        documents = null;
        doc = null;

    }
}


//*/*

 /* 保存并关闭全部应用
 /*

 /*/
public void close() {

    closeDocument(-1);
    if (word != null) {
</code></pre><p>//            Dispatch.call(word, &quot;Quit&quot;);
            word.invoke(&quot;Quit&quot;, new Variant[] {});</p>
<pre><code>        word = null;
    }

    selection = null;
    documents = null;

    ComThread.Release();//释放com线程。根据jacob的帮助文档，com的线程回收不由java的垃圾回收器处理


}
//*/*

 /* 打印当前word文档
 /*

 /*/
public void printFile() {

    if (doc != null) {
        Dispatch.call(doc, &quot;PrintOut&quot;);

    }
}


//*/*

 /* 保护当前档,如果不存在, 使用expression.Protect(Type, NoReset, Password)
 /*

 /* @param pwd
 /* @param type

 /*            WdProtectionType 常量之一(int 类型，只读)：
 /*            1-wdAllowOnlyComments  仅批注

 /*            2-wdAllowOnlyFormFields 仅填写窗体
 /*            0-wdAllowOnlyRevisions 仅修订

 /*            -1-wdNoProtection 无保护,
 /*            3-wdAllowOnlyReading 只读

 /*
 /*/

public void protectedWord(String pwd,String type) {
    String protectionType = Dispatch.get(doc, &quot;ProtectionType&quot;).toString();

    if (protectionType.equals(&quot;-1&quot;)) {
        Dispatch.call(doc, &quot;Protect&quot;, Integer.parseInt(type), new Variant(true),pwd);

    }
}


//*/*

 /* 解除文档保护,如果存在
 /*

 /* @param pwd
 /*            WdProtectionType 常量之一(int 类型，只读)：

 /*            1-wdAllowOnlyComments  仅批注
 /*            2-wdAllowOnlyFormFields 仅填写窗体

 /*            0-wdAllowOnlyRevisions 仅修订
 /*            -1-wdNoProtection 无保护,

 /*            3-wdAllowOnlyReading 只读
 /*

 /*/
public void unProtectedWord(String pwd) {

    String protectionType = Dispatch.get(doc, &quot;ProtectionType&quot;).toString();
    if (!protectionType.equals(&quot;0&quot;)&amp;&amp;!protectionType.equals(&quot;-1&quot;)) {

        Dispatch.call(doc, &quot;Unprotect&quot;, pwd);
    }

}
//*/*

 /* 返回文档的保护类型
 /* @return

 /*/
public String getProtectedType(){

    return Dispatch.get(doc, &quot;ProtectionType&quot;).toString();
}


//*/*

 /* 设置word文档安全级别
 /*

 /* @param value
 /*            1-msoAutomationSecurityByUI 使用“安全”对话框指定的安全设置。

 /*            2-msoAutomationSecurityForceDisable
 /*            在程序打开的所有文件中禁用所有宏，而不显示任何安全提醒。 3-msoAutomationSecurityLow

 /*            启用所有宏，这是启动应用程序时的默认值。
 /*/

public void setAutomationSecurity(int value) {
    word.setProperty(&quot;AutomationSecurity&quot;, new Variant(value));

}






//*/*

 /* 在word中插入标签 labelName是标签名，labelValue是标签值
 /* @param labelName

 /* @param labelValue
 /*/

public  void insertLabelValue(String labelName,String labelValue) {


   Dispatch bookMarks = Dispatch.call(doc, &quot;Bookmarks&quot;).toDispatch();
   boolean isExist = Dispatch.call(bookMarks, &quot;Exists&quot;, labelName).getBoolean();

    if (isExist == true) {
        Dispatch rangeItem1 = Dispatch.call(bookMarks, &quot;Item&quot;, labelName).toDispatch();

        Dispatch range1 = Dispatch.call(rangeItem1, &quot;Range&quot;).toDispatch();
        String bookMark1Value = Dispatch.get(range1, &quot;Text&quot;).toString();

          System.out.println(&quot;书签内容：&quot;+bookMark1Value);
    } else {

        System.out.println(&quot;当前书签不存在,重新建立!&quot;);
        //TODO 先插入文字，再查找选中文字，再插入标签

        this.insertText(labelValue);
</code></pre><p>//            this.find(labelValue);//查找文字，并选中</p>
<pre><code>        this.setFont(true, true,true,&quot;102,92,38&quot;, &quot;20&quot;, &quot;&quot;,true);
         Dispatch.call(bookMarks, &quot;Add&quot;, labelName, selection);

         Dispatch.call(bookMarks, &quot;Hidden&quot;, labelName);
    }

}
//*/*

 /* 在word中插入标签 labelName是标签名
 /* @param labelName

 /*/
public  void insertLabel(String labelName) {


   Dispatch bookMarks = Dispatch.call(doc, &quot;Bookmarks&quot;).toDispatch();

   boolean isExist = Dispatch.call(bookMarks, &quot;Exists&quot;, labelName).getBoolean();
    if (isExist == true) {

          System.out.println(&quot;书签已存在&quot;);
    } else {

        System.out.println(&quot;建立书签：&quot;+labelName);
         Dispatch.call(bookMarks, &quot;Add&quot;, labelName, selection);

    }
}   

//*/*
 /* 查找书签

 /* @param labelName
 /* @return

 /*/
public boolean findLabel(String labelName) {

   Dispatch bookMarks = Dispatch.call(doc, &quot;Bookmarks&quot;).toDispatch();
   boolean isExist = Dispatch.call(bookMarks, &quot;Exists&quot;, labelName).getBoolean();

   if (isExist == true) {
          return true;

    } else {
        System.out.println(&quot;当前书签不存在!&quot;);

        return false;
    }

}
//*/*

 /* 模糊查找书签,并返回准确的书签名称
 /* @param labelName

 /* @return
 /*/

public String findLabelLike(String labelName) {
   Dispatch bookMarks = Dispatch.call(doc, &quot;Bookmarks&quot;).toDispatch();

   int count = Dispatch.get(bookMarks, &quot;Count&quot;).getInt(); // 书签数
   Dispatch rangeItem = null;

   String lname = &quot;&quot;;
   for(int i=1;i&lt;=count;i++){

       rangeItem = Dispatch.call(bookMarks, &quot;Item&quot;, new Variant(i)).toDispatch();
       lname = Dispatch.call(rangeItem, &quot;Name&quot;).toString();//书签名称

       if(lname.startsWith(labelName)){//前面匹配
</code></pre><p>//               return lname.replaceFirst(labelName, &quot;&quot;);//返回后面值</p>
<pre><code>           return lname;
       }

   }
   return &quot;&quot;;

}
//*/*

 /* 模糊删除书签
 /* @param labelName

 /*/
public void deleteLableLike(String labelName){

    Dispatch bookMarks = Dispatch.call(doc, &quot;Bookmarks&quot;).toDispatch();
   int count = Dispatch.get(bookMarks, &quot;Count&quot;).getInt(); // 书签数

   Dispatch rangeItem = null;
   String lname = &quot;&quot;;

   for(int i=1;i&lt;=count;i++){
       rangeItem = Dispatch.call(bookMarks, &quot;Item&quot;, new Variant(i)).toDispatch();

       lname = Dispatch.call(rangeItem, &quot;Name&quot;).toString();//书签名称
       if(lname.startsWith(labelName)){//前面匹配

           Dispatch.call(rangeItem, &quot;Delete&quot;);
           count--;//书签已被删除，书签数目和当前书签都要相应减1，否则会报错:集合找不到

           i--;
       }

   }
}

//*/*
 /* 获取书签内容

 /* @param labelName
 /* @return

 /*/
public String getLableValue(String labelName){

    if(this.findLabel(labelName)){
        Dispatch bookMarks = Dispatch.call(doc, &quot;Bookmarks&quot;).toDispatch();

        Dispatch rangeItem1 = Dispatch.call(bookMarks, &quot;Item&quot;, labelName).toDispatch();
        Dispatch range1 = Dispatch.call(rangeItem1, &quot;Range&quot;).toDispatch();

        Dispatch font = Dispatch.get(range1, &quot;Font&quot;).toDispatch();
        Dispatch.put(font, &quot;Hidden&quot;, new Variant(false)); //显示书签内容

        String bookMark1Value = Dispatch.get(range1, &quot;Text&quot;).toString();
          System.out.println(&quot;书签内容：&quot;+bookMark1Value);
</code></pre><p>//            font = Dispatch.get(range1, &quot;Font&quot;).toDispatch();
//              Dispatch.put(font, &quot;Hidden&quot;, new Variant(true)); //隐藏书签内容</p>
<pre><code>          return bookMark1Value;
    }

    return &quot;&quot;;
}




public static void main(String[] args) throws Exception {


}   
</code></pre><p>}</p>
<p> 采用jacob方式操作文档，经常会出现卡机的现象，所以最后采用poi方式来操作书签。若单纯的操作书签用poi方式还是比较简单的，但要操作表格、文档格式之类的还是用jacob功能比较强大。
Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>InputStream input = null;  </li>
<li>File docFile = new File( fileName );  </li>
<li>HWPFDocument document = null;  </li>
<li>try{  </li>
<li>input = new FileInputStream(docFile);//加载 doc 文档  </li>
<li>document = new HWPFDocument(input);//文件流方式创建hwpf  </li>
<li>Bookmarks bookmarks =  document.getBookmarks();//文档书签  </li>
<li>for(int i=0,length=bookmarks.getBookmarksCount();i&lt;length;i++){  </li>
<li>bookmarkName = bookmarks.getBookmark(i).getName();  </li>
<li>//.....  </li>
<li>}  </li>
<li></li>
<li>}catch( Exception e){  </li>
<li></li>
<li>}finally{  </li>
<li>if( null != input )  </li>
<li>input.close();  </li>
<li>}  </li>
</ol>
<p>InputStream input = null;</p>
<p>File docFile = new File( fileName );
HWPFDocument document = null;</p>
<p>try{
    input = new FileInputStream(docFile);//加载 doc 文档</p>
<pre><code>document = new HWPFDocument(input);//文件流方式创建hwpf
Bookmarks bookmarks =  document.getBookmarks();//文档书签

for(int i=0,length=bookmarks.getBookmarksCount();i&lt;length;i++){
    bookmarkName = bookmarks.getBookmark(i).getName();

    //.....
}
</code></pre><p>}catch( Exception e){</p>
<p>}finally{</p>
<pre><code>if( null != input )
        input.close();
</code></pre><p>}</p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/java-com/">java-com</a></li><li><a href="/categories/Java&J2EE/java-com/jacob/">jacob</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/jacob/" class="label label-success">jacob</a><a href="/tags/java-com/" class="label label-info">java-com</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:41"datetime="2014-03-07 09:54:41"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-java-com-jacob--java操作word文档jacob-poi/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-java-com-jacob--java操作word文档jacob-poi" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-java深入分析--Hash表分析以及Java实现/">Hash表分析以及Java实现</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:41.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-java深入分析--Hash表分析以及Java实现/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="hash-java-">Hash表分析以及Java实现</h1>
<p><strong><a href="http://java-mzd.iteye.com/blog/827523" target="_blank">Hash表分析以及Java实现</a></strong></p>
<p><strong>文章分类**</strong>:<a href="http://www.iteye.com/blogs/category/tech" target="_blank">综合技术</a>**</p>
<pre><code>   这篇博客主要探讨**Hash****表**中的一些原理/概念，及根据这些原理/概念，自己设计一个用来存放/查找数据的Hash表，并且与JDK中的HashMap类进行比较。
</code></pre><p>我们分一下七个步骤来进行。 </p>
<p><strong>一。**</strong>   Hash<strong>**表概念</strong></p>
<p><strong>二**</strong>.      Hash<strong>**构造函数的方法，及适用范围</strong></p>
<p><strong>三**</strong>.       Hash<strong>**处理冲突方法，各自特征</strong></p>
<p><strong>四**</strong>.       Hash<strong>**查找过程</strong></p>
<p><strong>五**</strong>.       <strong><strong>实现一个使用</strong></strong>Hash<strong><strong>存数据的场景</strong></strong>-------Hash<strong>**查找算法，插入算法</strong></p>
<p><strong>六**</strong>.       JDK<strong><strong>中</strong></strong>HashMap<strong>**的实现</strong></p>
<p><strong>七**</strong>.       Hash<strong><strong>表与</strong></strong>HashMap<strong>**的对比，性能分析</strong></p>
<p> <strong>一。**</strong>   Hash<strong><strong>表概念</strong></strong> **</p>
<pre><code>           在查找表中我们已经说过，在Hash表中，**记录在表中的位置和其关键字之间存在着一种确定的关系**。这样       我们就能预先知道所查关键字在表中的位置，从而直接通过下标找到记录。使ASL趋近与0.



          1) **  **哈希(Hash)函数是一个映象，即： 将关键字的集合映射到某个地址集合上，它的设置很灵活，只要这个地       址集合的大小不超出允许范围即可；

         2)  由于哈希函数是一个压缩映象，因此，在一般情况下，很容易产生“冲突”现象，即： key1¹ key2，而  f            (key1) = f(key2)。

          3).  只能尽量减少冲突而不能完全避免冲突，这是因为通常关键字集合比较大，其元素包括所有可能的关键字，       而地址集合的元素仅为哈希表中的地址值



   在构造这种特殊的“查找表” 时，除了需要选择一个**“****好****”(****尽可能少产生冲突****)**的哈希函数之外；还需要找到一      种**“****处理冲突****”** 的方法。
</code></pre><p><strong>二**</strong>.     Hash<strong>**构造函数的方法，及适用范围</strong></p>
<p>§    <strong>直接定址法</strong></p>
<p>§    <strong>数字分析法</strong></p>
<p>§    <strong>平方取中法</strong></p>
<p>§    <strong>折叠法</strong></p>
<p>§    <strong>除留余数法</strong></p>
<p>§    <strong>随机数法</strong>      </p>
<pre><code>  （1）直接定址法：

            哈希函数为关键字的线性函数，H(key) = key 或者 H(key) = a ´ key + b

          **此法仅适合于**：地址集合的大小 = = 关键字集合的大小，其中a和b为常数。

 （2）数字分析法：

         假设关键字集合中的每个关键字都是由 s 位数字组成 (u1, u2, …, us)，分析关键字集中的全体，                  并从中提取分布均匀的若干位或它们的组合作为地址。

         **此法适于:**能预先估计出全体关键字的每一位上各种数字出现的频度。

 （3）平方取中法：

           以关键字的平方值的中间几位作为存储地址。求“关键字的平方值” 的目的是“扩大差别” ，同                    时平方值的中间各位又能受到整个关键字中各位的影响。

         **此法适于:**关键字中的每一位都有某些数字重复出现频度很高的现象。

 （4）折叠法：

        将关键字分割成若干部分，然后取它们的叠加和为哈希地址。两种叠加处理的方法：移位叠加:将分                割后的几部分低位对齐相加；间界叠加:从一端沿分割界来回折叠，然后对齐相加。

        **此法适于：**关键字的数字位数特别多。

 （5）除留余数法：

         设定哈希函数为:H(key) = key MOD p   ( p≤m )，其中， m为表长，p 为不大于 m 的素数，或                 是不含 20 以下的质因子

 （6）随机数法：

       设定哈希函数为:H(key) = Random(key)其中，Random 为伪随机函数

       **此法适于：**对长度不等的关键字构造哈希函数。



     实际造表时，采用何种构造哈希函数的方法取决于建表的关键字集合的情况(包括关键字的范围和形态)，以及哈希表    长度（哈希地址范围），**总的原则是使产生冲突的可能性降到尽可能地小。**
</code></pre><p><strong>三**</strong>.       Hash<strong>**处理冲突方法，各自特征</strong></p>
<p> <strong>“**</strong>处理冲突” 的实际含义是：为产生冲突的关键字寻找下一个哈希地址。**</p>
<p>§    <strong>  **</strong>开放定址法**</p>
<p>§    <strong>  **</strong>再哈希法**</p>
<p>§    <strong>  **</strong>链地址法**</p>
<pre><code>  （1）开放定址法：

           为产生冲突的关键字地址 H(key) 求得一个地址序列： H0, H1, H2, …, Hs  1≤s≤m-1，Hi = ( H(key)                 +di  ) MOD m，其中： i=1, 2, …, s，H(key)为哈希函数;m为哈希表长;



  （2）链地址法：
</code></pre><p><img src="" alt="http://dl.iteye.com/upload/attachment/355453/2a1ac1de-80ef-33d5-a120-9a8f07dbf3e9.jpg"></p>
<pre><code>         将所有哈希地址相同的记录都链接在同一链表中。



  （3）再哈希法：

           方法：构造若干个哈希函数，当发生冲突时，根据另一个哈希函数计算下一个哈希地址，直到冲突不再发                  生。即：Hi=Rhi(key)     i=1,2,……k，其中：Rhi——不同的哈希函数，特点：计算时间增加
</code></pre><p> <strong>四**</strong>.       Hash<strong>**查找过程</strong></p>
<p><img src="" alt="http://dl.iteye.com/upload/attachment/355455/a946abd8-ba7b-3e4e-b5a5-b94059e086ac.png"></p>
<p><strong>  </strong>      对于给定值 K,计算哈希地址 i = H(K)，若 r[i] = NULL  则查找不成功，若 r[i].key = K  则查找成功， 否则 “求     下一地址 Hi” ，直至r[Hi] = NULL  (查找不成功)  或r[Hi].key = K  (查找成功) 为止。</p>
<p> <strong>五**</strong>.       <strong><strong>实现一个使用</strong></strong>Hash<strong><strong>存数据的场景</strong></strong>-------Hash<strong>**查找算法，插入算法</strong></p>
<pre><code>     假设我们要设计的是一个用来保存中南大学所有在校学生个人信息的数据表。因为在校学生数量也不是特别巨大(8W?)，每个学生的学号是唯一的,因此，我们可以简单的应用直接定址法，声明一个10W大小的数组，每个学生的学号作为主键。然后每次要添加或者查找学生，只需要根据需要去操作即可。

  但是，显然这样做是**很脑残**的。这样做系统的可拓展性和复用性就非常差了，比如有一天人数超过10W了？如果是用来保存别的数据呢？或者我只需要保存20条记录呢？声明大小为10W的数组显然是太浪费了的。



 如果我们是用来保存大数据量（比如银行的用户数，4大的用户数都应该有3-5亿了吧？），这时候我们计算出来的HashCode就很可能会有冲突了， 我们的系统应该有“处理冲突”的能力，此处我们**通过挂链法****“****处理冲突****”**。



 如果我们的数据量非常巨大，并且还持续在增加，如果我们仅仅只是通过挂链法来处理冲突，可能我们的链上挂了上万个数据后，这个时候再通过静态搜索来查找链表，显然性能也是非常低的。所以我们的系统应该还能实现自动扩容，**当容量达到某比例后，即自动扩容，使装载因子保存在一个固定的水平上**。
</code></pre><p>综上所述，我们对这个Hash容器的基本要求应该有如下几点：</p>
<pre><code>         **满足****Hash****表的查找要求（废话）**
</code></pre><p><strong>             **</strong>能支持从小数据量到大数据量的自动转变（自动扩容）**</p>
<p><strong>             **</strong>使用挂链法解决冲突**</p>
<p>好了，既然都分析到这一步了，咱就闲话少叙，直接开始上代码吧。</p>
<p><strong>Java**</strong>代码<strong><strong> </strong></strong> <strong>[</strong><img src="&quot;&quot;收藏这段代码&quot; &quot;" alt="收藏代码]()**"><em>**</em></p>
<ol>
<li><p><strong>package</strong> cn.javamzd.collection.search;  </p>
</li>
<li></li>
<li><p><strong>public</strong> <strong>class</strong> MyMap<K, V> {  </p>
</li>
<li><p><strong>private</strong> <strong>int</strong> size;// 当前容量  </p>
</li>
<li><p><strong>private</strong> <strong>static</strong> <strong>int</strong> INIT_CAPACITY = 16;// 默认容量  </p>
</li>
<li><p><strong>private</strong> Entry<K, V>[] container;// 实际存储数据的数组对象  </p>
</li>
<li><p><strong>private</strong> <strong>static</strong> <strong>float</strong> LOAD_FACTOR = 0.75f;// 装载因子  </p>
</li>
<li><p><strong>private</strong> <strong>int</strong> max;// 能存的最大的数=capacity/*factor  </p>
</li>
<li></li>
<li><p>// 自己设置容量和装载因子的构造器  </p>
</li>
<li><p><strong>public</strong> MyMap(<strong>int</strong> init_Capaticy, <strong>float</strong> load_factor) {  </p>
</li>
<li><p><strong>if</strong> (init_Capaticy &lt; 0)  </p>
</li>
<li><p><strong>throw</strong> <strong>new</strong> IllegalArgumentException(&quot;Illegal initial capacity: &quot;  </p>
</li>
<li><ul>
<li>init_Capaticy);  </li>
</ul>
</li>
<li><p><strong>if</strong> (load_factor &lt;= 0 || Float.isNaN(load_factor))  </p>
</li>
<li><p><strong>throw</strong> <strong>new</strong> IllegalArgumentException(&quot;Illegal load factor: &quot;  </p>
</li>
<li><ul>
<li>load_factor);  </li>
</ul>
</li>
<li><p><strong>this</strong>.LOAD_FACTOR = load_factor;  </p>
</li>
<li><p>max = (<strong>int</strong>) (init_Capaticy /* load_factor);  </p>
</li>
<li><p>container = <strong>new</strong> Entry[init_Capaticy];  </p>
</li>
<li><p>}  </p>
</li>
<li></li>
<li><p>// 使用默认参数的构造器  </p>
</li>
<li><p><strong>public</strong> MyMap() {  </p>
</li>
<li><p><strong>this</strong>(INIT_CAPACITY, LOAD_FACTOR);  </p>
</li>
<li><p>}  </p>
</li>
<li></li>
<li><p>//<em>/</em> </p>
</li>
<li><p>/* 存 </p>
</li>
<li><p>/*  </p>
</li>
<li><p>/* @param k </p>
</li>
<li><p>/* @param v </p>
</li>
<li><p>/* @return </p>
</li>
<li><p>/*/  </p>
</li>
<li><p><strong>public</strong> <strong>boolean</strong> put(K k, V v) {  </p>
</li>
<li><p>// 1.计算K的hash值  </p>
</li>
<li><p>// 因为自己很难写出对不同的类型都适用的Hash算法，故调用JDK给出的hashCode()方法来计算hash值  </p>
</li>
<li><p><strong>int</strong> hash = k.hashCode();  </p>
</li>
<li><p>//将所有信息封装为一个Entry  </p>
</li>
<li><p>Entry<K,V> temp=<strong>new</strong> Entry(k,v,hash);  </p>
</li>
<li><p><strong>if</strong>(setEntry(temp, container)){  </p>
</li>
<li><p>// 大小加一  </p>
</li>
<li><p>size++;  </p>
</li>
<li><p><strong>return</strong> <strong>true</strong>;  </p>
</li>
<li><p>}  </p>
</li>
<li><p><strong>return</strong> <strong>false</strong>;  </p>
</li>
<li><p>}  </p>
</li>
<li></li>
<li></li>
<li><p>//<em>/</em> </p>
</li>
<li><p>/* 扩容的方法 </p>
</li>
<li><p>/*  </p>
</li>
<li><p>/* @param newSize </p>
</li>
<li><p>/*            新的容器大小 </p>
</li>
<li><p>/*/  </p>
</li>
<li><p><strong>private</strong> <strong>void</strong> reSize(<strong>int</strong> newSize) {  </p>
</li>
<li><p>// 1.声明新数组  </p>
</li>
<li><p>Entry<K, V>[] newTable = <strong>new</strong> Entry[newSize];  </p>
</li>
<li><p>max = (<strong>int</strong>) (newSize /* LOAD_FACTOR);  </p>
</li>
<li><p>// 2.复制已有元素,即遍历所有元素，每个元素再存一遍  </p>
</li>
<li><p><strong>for</strong> (<strong>int</strong> j = 0; j &lt; container.length; j++) {  </p>
</li>
<li><p>Entry<K, V> entry = container[j];  </p>
</li>
<li><p>//因为每个数组元素其实为链表，所以…………  </p>
</li>
<li><p><strong>while</strong> (<strong>null</strong> != entry) {  </p>
</li>
<li><p>setEntry(entry, newTable);  </p>
</li>
<li><p>entry = entry.next;  </p>
</li>
<li><p>}  </p>
</li>
<li><p>}  </p>
</li>
<li><p>// 3.改变指向  </p>
</li>
<li><p>container = newTable;  </p>
</li>
<li></li>
<li><p>}  </p>
</li>
<li></li>
<li><p>//<em>/</em> </p>
</li>
<li><p>/*将指定的结点temp添加到指定的hash表table当中 </p>
</li>
<li><p>/* 添加时判断该结点是否已经存在 </p>
</li>
<li><p>/* 如果已经存在，返回false </p>
</li>
<li><p>/* 添加成功返回true </p>
</li>
<li><p>/* @param temp </p>
</li>
<li><p>/* @param table </p>
</li>
<li><p>/* @return </p>
</li>
<li><p>/*/  </p>
</li>
<li><p><strong>private</strong> <strong>boolean</strong> setEntry(Entry<K,V> temp,Entry[] table){  </p>
</li>
<li><p>// 根据hash值找到下标  </p>
</li>
<li><p><strong>int</strong> index = indexFor(temp.hash, table.length);  </p>
</li>
<li><p>//根据下标找到对应元素  </p>
</li>
<li><p>Entry<K, V> entry = table[index];  </p>
</li>
<li><p>// 3.若存在  </p>
</li>
<li><p><strong>if</strong> (<strong>null</strong> != entry) {  </p>
</li>
<li><p>// 3.1遍历整个链表，判断是否相等  </p>
</li>
<li><p><strong>while</strong> (<strong>null</strong> != entry) {  </p>
</li>
<li><p>//判断相等的条件时应该注意，除了比较地址相同外，引用传递的相等用equals()方法比较  </p>
</li>
<li><p>//相等则不存，返回false  </p>
</li>
<li><p><strong>if</strong> ((temp.key == entry.key||temp.key.equals(entry.key)) &amp;&amp; temp.hash == entry.hash&amp;&amp;(temp.value==entry.value||temp.value.equals(entry.value))) {  </p>
</li>
<li><p><strong>return</strong> <strong>false</strong>;  </p>
</li>
<li><p>}  </p>
</li>
<li><p>//不相等则比较下一个元素  </p>
</li>
<li><p><strong>else</strong> <strong>if</strong> (temp.key != entry.key &amp;&amp; temp.value != entry.value) {  </p>
</li>
<li><p>//到达队尾，中断循环  </p>
</li>
<li><p><strong>if</strong>(<strong>null</strong>==entry.next){  </p>
</li>
<li><p><strong>break</strong>;  </p>
</li>
<li><p>}  </p>
</li>
<li><p>// 没有到达队尾，继续遍历下一个元素  </p>
</li>
<li><p>entry = entry.next;  </p>
</li>
<li><p>}  </p>
</li>
<li><p>}  </p>
</li>
<li><p>// 3.2当遍历到了队尾，如果都没有相同的元素，则将该元素挂在队尾  </p>
</li>
<li><p>addEntry2Last(entry,temp);  </p>
</li>
<li></li>
<li><p>}  </p>
</li>
<li><p>// 4.若不存在,直接设置初始化元素  </p>
</li>
<li><p>setFirstEntry(temp,index,table);  </p>
</li>
<li><p><strong>return</strong> <strong>true</strong>;  </p>
</li>
<li><p>}  </p>
</li>
<li></li>
<li><p><strong>private</strong> <strong>void</strong> addEntry2Last(Entry<K, V> entry, Entry<K, V> temp) {  </p>
</li>
<li><p><strong>if</strong> (size &gt; max) {  </p>
</li>
<li><p>reSize(container.length /* 4);  </p>
</li>
<li><p>}  </p>
</li>
<li><p>entry.next=temp;  </p>
</li>
<li></li>
<li><p>}  </p>
</li>
<li></li>
<li><p>//<em>/</em> </p>
</li>
<li><p>/* 将指定结点temp，添加到指定的hash表table的指定下标index中 </p>
</li>
<li><p>/* @param temp </p>
</li>
<li><p>/* @param index </p>
</li>
<li><p>/* @param table </p>
</li>
<li><p>/*/  </p>
</li>
<li><p><strong>private</strong> <strong>void</strong> setFirstEntry(Entry<K, V> temp, <strong>int</strong> index, Entry[] table) {  </p>
</li>
<li><p>// 1.判断当前容量是否超标，如果超标，调用扩容方法  </p>
</li>
<li><p><strong>if</strong> (size &gt; max) {  </p>
</li>
<li><p>reSize(table.length /* 4);  </p>
</li>
<li><p>}  </p>
</li>
<li><p>// 2.不超标，或者扩容以后，设置元素  </p>
</li>
<li><p>table[index] = temp;  </p>
</li>
<li><p>//！！！！！！！！！！！！！！！  </p>
</li>
<li><p>//因为每次设置后都是新的链表，需要将其后接的结点都去掉  </p>
</li>
<li><p>//NND，少这一行代码卡了哥哥7个小时（代码重构）  </p>
</li>
<li><p>temp.next=<strong>null</strong>;  </p>
</li>
<li><p>}  </p>
</li>
<li></li>
<li><p>//<em>/</em> </p>
</li>
<li><p>/* 取 </p>
</li>
<li><p>/*  </p>
</li>
<li><p>/* @param k </p>
</li>
<li><p>/* @return </p>
</li>
<li><p>/*/  </p>
</li>
<li><p><strong>public</strong> V get(K k) {  </p>
</li>
<li><p>Entry<K, V> entry = <strong>null</strong>;  </p>
</li>
<li><p>// 1.计算K的hash值  </p>
</li>
<li><p><strong>int</strong> hash = k.hashCode();  </p>
</li>
<li><p>// 2.根据hash值找到下标  </p>
</li>
<li><p><strong>int</strong> index = indexFor(hash, container.length);  </p>
</li>
<li><p>// 3。根据index找到链表  </p>
</li>
<li><p>entry = container[index];  </p>
</li>
<li><p>// 3。若链表为空，返回null  </p>
</li>
<li><p><strong>if</strong> (<strong>null</strong> == entry) {  </p>
</li>
<li><p><strong>return</strong> <strong>null</strong>;  </p>
</li>
<li><p>}  </p>
</li>
<li><p>// 4。若不为空，遍历链表，比较k是否相等,如果k相等，则返回该value  </p>
</li>
<li><p><strong>while</strong> (<strong>null</strong> != entry) {  </p>
</li>
<li><p><strong>if</strong> (k == entry.key||entry.key.equals(k)) {  </p>
</li>
<li><p><strong>return</strong> entry.value;  </p>
</li>
<li><p>}  </p>
</li>
<li><p>entry = entry.next;  </p>
</li>
<li><p>}  </p>
</li>
<li><p>// 如果遍历完了不相等，则返回空  </p>
</li>
<li><p><strong>return</strong> <strong>null</strong>;  </p>
</li>
<li></li>
<li><p>}  </p>
</li>
<li></li>
<li><p>//<em>/</em> </p>
</li>
<li><p>/* 根据hash码，容器数组的长度,计算该哈希码在容器数组中的下标值 </p>
</li>
<li><p>/*  </p>
</li>
<li><p>/* @param hashcode </p>
</li>
<li><p>/* @param containerLength </p>
</li>
<li><p>/* @return </p>
</li>
<li><p>/*/  </p>
</li>
<li><p><strong>public</strong> <strong>int</strong> indexFor(<strong>int</strong> hashcode, <strong>int</strong> containerLength) {  </p>
</li>
<li><p><strong>return</strong> hashcode &amp; (containerLength - 1);  </p>
</li>
<li></li>
<li><p>}  </p>
</li>
<li></li>
<li><p>//<em>/</em> </p>
</li>
<li><p>/* 用来实际保存数据的内部类,因为采用挂链法解决冲突，此内部类设计为链表形式 </p>
</li>
<li><p>/*  </p>
</li>
<li><p>/* @param <K>key </p>
</li>
<li><p>/* @param <V> </p>
</li>
<li><p>/*            value </p>
</li>
<li><p>/*/  </p>
</li>
<li><p><strong>class</strong> Entry<K, V> {  </p>
</li>
<li><p>Entry<K, V> next;// 下一个结点  </p>
</li>
<li><p>K key;// key  </p>
</li>
<li><p>V value;// value  </p>
</li>
<li><p><strong>int</strong> hash;// 这个key对应的hash码，作为一个成员变量，当下次需要用的时候可以不用重新计算  </p>
</li>
<li></li>
<li><p>// 构造方法  </p>
</li>
<li><p>Entry(K k, V v, <strong>int</strong> hash) {  </p>
</li>
<li><p><strong>this</strong>.key = k;  </p>
</li>
<li><p><strong>this</strong>.value = v;  </p>
</li>
<li><p><strong>this</strong>.hash = hash;  </p>
</li>
<li></li>
<li><p>}  </p>
</li>
<li></li>
<li><p>//相应的getter()方法  </p>
</li>
<li></li>
<li><p>}  </p>
</li>
<li><p>}  </p>
</li>
</ol>
<p> 代码中有相当清楚的注释了</p>
<p>在文章的最后这里，我要强烈的宣泄下感情</p>
<p>MLGBD，本来以为分析的挺到位了，写出这个东西也就最多需要个把小时吧</p>
<p>结果因为通宵作业，脑袋运转不灵</p>
<p>硬是花了哥三个小时才写出了</p>
<p>好不容易些出来了</p>
<p>我日</p>
<p>看着代码比较混乱</p>
<p>然后就对代码重构了下</p>
<p>把逻辑抽象清楚，进行重构就花了个多小时</p>
<p>好不容易构造好了</p>
<p>就开始了TMD的一直报错了----------大数据量测试时到大概5000就死循环了</p>
<p>各种调试，各种分析都觉得没错误</p>
<p> 最后花了哥7个小时终于找出来了</p>
<p>我擦</p>
<p>第一次初始化加的时候，因为每个元素的next都是空的</p>
<p>而扩充容量resize()时，因为冲突处理是链式结构的</p>
<p>当将他们重新hash添加的时候，重复的这些鸟元素的next是有元素的</p>
<p>一定要设置为null</p>
<p><strong>七**</strong>.<strong>**性能分析：</strong></p>
<pre><code>  1.因为冲突的存在，其查找长度不可能达到O(1)

  2哈希表的平均查找长度是装载因子a 的函数，而不是 n 的函数。

  3.用哈希表构造查找表时，可以选择一个适当的装填因子 a ，使得平均查找长度限定在某个范围内。
</code></pre><p>   最后给出我们这个HashMap的性能</p>
<p>  测试代码</p>
<p><strong>Java**</strong>代码<strong><strong> </strong></strong> <strong>[</strong><img src="&quot;&quot;收藏这段代码&quot; &quot;" alt="收藏代码]()**"><em>**</em></p>
<ol>
<li><p><strong>public</strong> <strong>class</strong> Test {  </p>
</li>
<li></li>
<li><p><strong>public</strong> <strong>static</strong> <strong>void</strong> main(String[] args) {  </p>
</li>
<li><p>MyMap<String, String> mm = <strong>new</strong> MyMap<String, String>();   </p>
</li>
<li><p>Long aBeginTime=System.currentTimeMillis();//记录BeginTime  </p>
</li>
<li><p><strong>for</strong>(<strong>int</strong> i=0;i&lt;1000000;i++){  </p>
</li>
<li><p>mm.put(&quot;&quot;+i, &quot;&quot;+i/*100);  </p>
</li>
<li><p>}  </p>
</li>
<li><p>Long aEndTime=System.currentTimeMillis();//记录EndTime  </p>
</li>
<li><p>System.out.println(&quot;insert time--&gt;&quot;+(aEndTime-aBeginTime));  </p>
</li>
<li></li>
<li><p>Long lBeginTime=System.currentTimeMillis();//记录BeginTime  </p>
</li>
<li><p>mm.get(&quot;&quot;+100000);  </p>
</li>
<li><p>Long lEndTime=System.currentTimeMillis();//记录EndTime  </p>
</li>
<li><p>System.out.println(&quot;seach time---&gt;&quot;+(lEndTime-lBeginTime));  </p>
</li>
<li><p>}  </p>
</li>
<li><p>}  </p>
<p>100W个数据时，全部存储时间为1S多一点，而<strong>搜寻时间为**</strong>0 **</p>
</li>
</ol>
<p>insert time--&gt;1536
seach time---&gt;0</p>
<p>好了，牢骚发完了</p>
<p>本来今天想写个<strong>有关大访问量处理的一些基本概念</strong>的文章</p>
<p>全泡汤了,明天写吧</p>
<p>url: <a href="http://java-mzd.iteye.com/blog/827523" target="_blank">http://java-mzd.iteye.com/blog/827523</a></p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/java深入分析/">java深入分析</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/java深入分析/" class="label label-success">java深入分析</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:41"datetime="2014-03-07 09:54:41"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-java深入分析--Hash表分析以及Java实现/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-java深入分析--Hash表分析以及Java实现" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>





<ul id="pagination" class="pagination pagination-lg">
  <li><a class="extend prev" href="/page/60/">&laquo;</a></li><li><a class="page-number" href="/">1</a></li><li><a class="page-number" href="/page/2/">2</a></li><li><span class="space">&hellip;</span></li><li><a class="page-number" href="/page/58/">58</a></li><li><a class="page-number" href="/page/59/">59</a></li><li><a class="page-number" href="/page/60/">60</a></li><li class="active"><li><span class="page-number current">61</span></li><li><a class="page-number" href="/page/62/">62</a></li><li><a class="page-number" href="/page/63/">63</a></li><li><a class="page-number" href="/page/64/">64</a></li><li><span class="space">&hellip;</span></li></li><li><a class="page-number" href="/page/161/">161</a></li><li><a class="page-number" href="/page/162/">162</a></li><li><a class="extend next" href="/page/62/">&raquo;</a></li>
  <div class="clearfix"></div>
</ul></div><!--wapper-->
       </div><!-- ID main-col END -->
       <aside id="sidebar" class="alignright col-sx-6 col-sm-4 col-md-3 col-lg-3">
<div id="widget_search" class="widget panel panel-primary">
    <form action="//google.com/search" method="get" accept-charset="utf-8">
  <div class="input-group">
    <input class="form-control" id="searchbox" type="search" name="q" results="0" placeholder="search">
    <span class="input-group-btn">
      <button class="btn btn-default" type="submit">Go!</button>
    </span>
    <input type="hidden" name="q" value="site:itsolife.com">
  </div>
</form>
</div>

<div id="widget_category" class="widget panel panel-primary">
  <div class="panel-heading">category</div>  <div data-src='category' class='ajax_widgets'>正在加载...</div>
</div>

<div id="widget_recent_posts" class="widget panel panel-primary">
  <div class="panel-heading">recent posts</div>  <div data-src='recent_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_tagcloud" class="widget panel panel-primary">
  <div class="panel-heading">tagcloud</div>  <div data-src='tagcloud' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_latest_update_posts" class="widget panel panel-primary">
  <div class="panel-heading">最近更新</div>  <div data-src='latest_update_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_recent_comments" class="widget panel panel-primary">
  <div class="panel-heading">recent comments</div>  

<div class="list-group-item ds-recent-comments" data-num-items="6" data-show-avatars="1" data-show-time="1" data-show-title="1" data-show-admin="1" data-excerpt-length="50"></div>



</div>

</aside>
       <div class="clearfix"></div>
     </div><!-- row END -->
  </div>
  <footer id="footer" class="container">
  <div class="panel panel-info">
  <section id='footer_widget'></section>  <div class="panel-footer">
  <div id="site-info">
    <span class='author'>
  
  &copy; 2014 RobinChia
  
    &nbsp;&nbsp;</span>
  
  <span id='analytics-51la'></span><span id='analytics-google'>
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-48559895-1']);
  _gaq.push(['_trackPageview']);
  _js2load.push({src:('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'});
</script></span><span id='analytics-cnzz'>
<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_5774006'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s17.cnzz.com/stat.php%3Fid%3D5774006%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>
</span><span id='analytics-baidu'>
<script>
var _hmt = _hmt || [];
_js2load.push({src:"//hm.baidu.com/hm.js?1442f50724afc42380b51f097c43082c"});
</script>
</span>  </div>
  <div id="copyright">Site powered by <a href='http://zespia.tw/hexo/'><strong>hexo</strong></a>  update time: <em>2014-04-07 17:30:36</em></span></div>
</div>
<div class="clearfix"></div>


  </div>
  </footer>
  
        <script src="http://cdn.bootcss.com/jquery/1.10.2/jquery.min.js"></script>        
        <script src="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/js/bootstrap.min.js"></script>        
                
        <script src="http://cdn.bootcss.com/prettify/r298/prettify.min.js"></script>    <script type="text/javascript">
   var lang=["bsh", "c", "cc", "cpp", "cs", "csh", "cyc", "cv", "htm", "html",
    "java", "js", "m", "mxml", "perl", "pl", "pm", "py", "rb", "sh",
    "xhtml", "xml", "xsl"];
   var pretty_base='';
   $('script').each(function(){
	var c = $(this).attr('src');
	if (!c)
	    return;
	if (c.match(/(\/)?prettify(\.min)?\.js/i))
	{
	    var index = c.lastIndexOf('/');
	    if (index != -1)
		pretty_base = c.substr(0,index + 1);
	    return false;
	}
   })
   $('pre code').each(function(){
	var c = $(this).attr('class')
	if (!c)
	    return;
	c = c.match(/\s?(lang\-\w+)/i);
	if (c && lang.indexOf(c[1]) == -1)
	{
	    lang.push(c[1]);
	    $.getScript(pretty_base + c[1] + '.min.js');
	}
   })

    $(window).load(function(){
       $("pre").addClass("prettyprint");
       prettyPrint();
    })
</script>    
            <script type="text/javascript">
var duoshuoQuery = {short_name:"robinchia"};
_js2load.push({src:'http://static.duoshuo.com/embed.js',charset:'UTF-8'});
</script>
    
            <!--wumii_relatedItems-->
    
        <script src="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js"></script>    <script type="text/javascript">
(function($){
  $('.entry').each(function(i){
    $(this).find('img').each(function(){
      var alt = this.alt;

      if (alt){
        $(this).before('<span class="caption">' + alt + '</span>');
      }

      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox" rel="fancybox' + i + '" />');
    });
  });

  $('.fancybox').fancybox();
})(jQuery);
</script>    
        <script src="http://cdn.bootcss.com/mathjax/2.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>    <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>
    
<script type="text/javascript">
$('.ajax_widgets').each(function(){var src=$(this).attr('data-src');if(src)$(this).load('/widgets/'+src+'.html');});
$.each(_js2load,function(index,obj){loadjs(obj.src,obj.charset)});
</script>

<div id="scroll2top">
<img src="/scroll2top/arrow.png"/>
</div>
<script src="/scroll2top/scroll2top.min.js"></script>
<div id="winterland">
  <canvas></canvas>
</div>
<script src="/js/winterland.min.js"></script>

  </body>
</html>
