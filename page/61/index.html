
<!DOCTYPE HTML>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>The 61 Page | It so life</title>
<meta name="author" content="RobinChia">

<meta name="description" content="It so life">


<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<meta property="og:site_name" content="It so life"/>

<!--[if IE]><style>.testIE.IE{display:inline;}</style><![endif]-->
<!--[if lte IE 7]><link rel="stylesheet" href="/css/ie7.css" type="text/css"><![endif]-->
<!--[if (lt IE 9)&(gt IE 7)]><style>.testIE.IE8{display:inline;}</style><![endif]-->
<!--[if gt IE 8]><style>.testIE.IE9{display:inline;}</style><![endif]-->

<link href="/favicon.png" rel="icon">
<link rel="alternate" href="/atom.xml" title="It so life Feed" type="application/atom+xml">

<link rel="stylesheet" href="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/css/bootstrap.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/font-awesome/4.0.3/css/font-awesome.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/prettify/r298/prettify.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" type="text/css">
<link rel="stylesheet" href="/css/style.css" type="text/css">
<!--[if lt IE 9]>
   <style>article,aside,dialog,footer,header,section,footer,nav,figure,menu{display:block}</style>
   <script src="http://cdn.staticfile.org/html5shiv/r29/html5.min.js"></script>
   <script src="http://cdn.staticfile.org/respond.js/1.4.2/respond.min.js"></script>
<link href="http://cdn.staticfile.org/respond.js/1.4.2/respond-proxy.html" id="respond-proxy" rel="respond-proxy" />
<link href="/js/respond.proxy.gif" id="respond-redirect" rel="respond-redirect" />
<script src="/js/respond.proxy.js"></script>
   <script src="http://cdn.bootcss.com/selectivizr/1.0.2/selectivizr-min.js"></script>
<![endif]-->
<script type="text/javascript">
function loadjs(c,d){var a=document.createElement("script");a.async=!0;a.type="text/javascript";a.src=c;a.charset=d||"gbk";(document.getElementsByTagName("HEAD")[0]||document.getElementsByTagName("BODY")[0]).appendChild(a)};
var _protocol = (("https:" == document.location.protocol) ? " https://" : " http://");
var _js2load = [];
</script>

</head>
<body>
      <header id="header" class="container"><nav id="main-nav" class="navbar navbar-default navbar-fixed-top " role="navigation">
  <div class="container">
    <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
      <span class="sr-only">Toggle navigation</span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="/">It so life</a>
    </div>
    <div  class="collapse navbar-collapse">
      <ul  class="nav navbar-nav">
  
        <li><a href="/" title="Home">Home</a></li>      
        <li><a href="/about/" title="About">About</a></li>      
        <li><a href="/archives/" title="Archives">Archives</a></li>      
      <li class='dropdown'>
        <a class='dropdown-toggle' data-toggle='dropdown' href='#'>website<b class='caret'></b></a>
        <ul class='dropdown-menu pure-menu-selected'>
    
          <li><a href="//groups.google.com/forum/#!forum/pongba" title="TopLanguage">TopLanguage</a></li>    
          <li><a href="//itpub.net/" title="ITPub">ITPub</a></li>    
          <li><a href="//blog.jobbole.com/" title="Bole">Bole</a></li>    
          <li><a href="//nosql-database.org/" title="nosql">nosql</a></li>    
          <li><a href="//gitimmersion.googol.im/" title="Git">Git</a></li>    
        </ul>
      </li>
    
      </ul>
      <ul class="nav navbar-nav navbar-right">
      
        <li><a href="/atom.xml">RSS</a></li>
      
      
        <li><a href="https://twitter.com/robinchia">twitter</a></li>
      
      
      
      
        <li><a href="https://github.com/robinchia">github</a></li>
      
      </ul>
    </div>
  </div>
</nav>
<div class="clearfix"></div>
</header>
  <div id='content' class="container">
     <div class="page-header-wrapper">
      <!--[if lt IE 9]><div class="alert alert-warning alert-dismissable"><button type="button" class="close" data-dismiss="alert" aria-hidden="true">&times;</button><strong>提示:</strong>您的浏览器版本太低了,建议升级到 <strong><a href="http://windows.microsoft.com/zh-cn/internet-explorer/download-ie" title="IE9">IE9</a></strong> 以上,本站使用<a href="https://www.google.com/intl/zh-CN/chrome/">Chrome浏览器</a>可以获得最好的显示效果.</div><![endif]-->
      <div class="page-header"><h1 align="center"><big>It so life</big> </h1>
        <h5 align="center"><big>love as life</big></h5>
      </div>
     </div>
     <div class="row">
       <div id="main-col" class="alignleft col-sx-12 col-sm-8 col-md-9 col-lg-9">
      <section id='header_widget'></section>
          <div id="wrapper"><article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE--Tomcat预编译JSP脚本/">Tomcat 预编译JSP 脚本</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:41.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE--Tomcat预编译JSP脚本/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="tomcat-jsp-">Tomcat 预编译JSP 脚本</h1>
<p>参考：</p>
<p>The Apache Jakarta Tomcat 5.5 Servlet/JSP Container Jasper 2 JSP Engine How To</p>
<p><a href="http://jakarta.apache.org/tomcat/tomcat-5.5-doc/jasper-howto.html" target="_blank"><a href="http://jakarta.apache.org/tomcat/tomcat-5.5-doc/jasper-howto.html">http://jakarta.apache.org/tomcat/tomcat-5.5-doc/jasper-howto.html</a></a></p>
<p>jspc</p>
<p><a href="http://ant.apache.org/manual/OptionalTasks/jspc.html" target="_blank"><a href="http://ant.apache.org/manual/OptionalTasks/jspc.html">http://ant.apache.org/manual/OptionalTasks/jspc.html</a></a></p>
<p>用Tomcat进行预编译的ant脚本如下：</p>
<p>build.properties的内容为：</p>
<p>tomcat.home=D:/Tomcat 5.5
webapp.name=blh
webapp.path=D:/Tomcat 5.5/webapps/blh</p>
<p>build.xml的内容为：</p>
<ol>
<li>&lt;?xml version=&quot;1.0&quot; encoding=&quot;GBK&quot;?&gt;</li>
<li><project name="WebApp Precompilation JSP to Java to Class to Jar" basedir="." default="help"></li>
<li><property file="build.properties"/></li>
<li><target name="all" depends="jsp2java,java2class,class2jar,clear"/></li>
<li><target name="help"></li>
<li><echo message="显示功能列表"/></li>
<li><echo message="jsp2java  通过JspC将JSP转换成Java源代码"/></li>
<li><echo message="java2class 将转换后的Java源代码进行编译成class文件"/></li>
<li><echo message="class2jar 将编译后的class文件打包"/></li>
<li><echo message="clear  清理现场"/></li>
<li></target></li>
<li><target name="jsp2java"></li>
<li><taskdef classname="org.apache.jasper.JspC" name="jsp2java"></li>
<li><classpath id="jsp2java.classpath"></li>
<li><fileset dir="${tomcat.home}/bin"></li>
<li><include name="/*.jar"/></li>
<li></fileset></li>
<li><fileset dir="${tomcat.home}/server/lib"></li>
<li><include name="/*.jar"/></li>
<li></fileset></li>
<li><fileset dir="${tomcat.home}/common/lib"></li>
<li><include name="/*.jar"/></li>
<li></fileset></li>
<li></classpath></li>
<li></taskdef></li>
<li><!-- 注意JSP文件要设置为UTF-8编码 --></li>
<li><jsp2java classpath="jsp2java.classpath" javaEncoding="UTF-8" validateXml="false" uriroot="${webapp.path}" webXmlFragment="${webapp.path}/WEB-INF/webJSP.xml" outputDir="${webapp.path}/WEB-INF/JspC/src"/></li>
<li></target></li>
<li><target name="java2class"></li>
<li><mkdir dir="${webapp.path}/WEB-INF/JspC/classes"/></li>
<li><!-- 同样Java文件要设置为UTF-8编码 --></li>
<li><javac srcdir="${webapp.path}/WEB-INF/JspC/src" destdir="${webapp.path}/WEB-INF/JspC/classes" encoding="UTF-8" optimize="off" debug="on" failonerror="false" excludes="/*/*//*.smap"></li>
<li><classpath id="java2class.classpath"></li>
<li><pathelement location="${webapp.path}/WEB-INF/classes"/></li>
<li><fileset dir="${webapp.path}/WEB-INF/lib"></li>
<li><include name="/*.jar"/></li>
<li></fileset></li>
<li><pathelement location="${tomcat.home}/common/classes"/></li>
<li><fileset dir="${tomcat.home}/common/lib"></li>
<li><include name="/*.jar"/></li>
<li></fileset></li>
<li><pathelement location="${tomcat.home}/shared/classes"/></li>
<li><fileset dir="${tomcat.home}/shared/lib"></li>
<li><include name="/*.jar"/></li>
<li></fileset></li>
<li><fileset dir="${tomcat.home}/bin"></li>
<li><include name="/*.jar"/></li>
<li></fileset></li>
<li></classpath></li>
<li><include name="/*/*"/></li>
<li><exclude name="tags//*/*" /></li>
<li></javac></li>
<li></target></li>
<li><target name="class2jar"></li>
<li><mkdir dir="${webapp.path}/WEB-INF/lib"/></li>
<li><jar basedir="${webapp.path}/WEB-INF/JspC/classes" jarfile="${webapp.path}/WEB-INF/lib/${webapp.name}JSP.jar"/></li>
<li></target></li>
<li><target name="clear"></li>
<li><delete dir="${webapp.path}/WEB-INF/JspC/classes"/></li>
<li><delete dir="${webapp.path}/WEB-INF/JspC/src"/></li>
<li><delete dir="${webapp.path}/WEB-INF/JspC"/></li>
<li></target></li>
<li></project></li>
</ol>
<hr>
<p>只需要设置好Ant的path环境变量，然后修改build.properties。执行ant all命令即可。
生成好的jar文件是{$webappname}JSP.jar。
在做为产品发布的时候，只需要你的类jar包和JSP预编译的包放到WEB-INF/lib/目录下即可，如${webappname}.jar和JSP预编译的包${webappname}JSP.jar；
然后删除掉你的所有的预编过的JSP源文件；
并且${webapp.path}/WEB-INF/webJSP.xml里的servlet映射，添加到${webapp.path}/WEB-INF/web.xml中。</p>
<p>来源： <a href="[http://blog.csdn.net/terry_f/article/details/3725382](http://blog.csdn.net/terry_f/article/details/3725382)">[http://blog.csdn.net/terry_f/article/details/3725382](http://blog.csdn.net/terry_f/article/details/3725382)</a> </p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:41"datetime="2014-03-07 09:54:41"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE--Tomcat预编译JSP脚本/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE--Tomcat预编译JSP脚本" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_多线程-并发--深入浅出JavaConcurrency3-锁机制/">深入浅出 Java Concurrency (3)</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:41.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_多线程-并发--深入浅出JavaConcurrency3-锁机制/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-java-concurrency-3-">深入浅出 Java Concurrency (3): 锁机制</h1>
<p>前面的章节主要谈谈原子操作，至于与原子操作一些相关的问题或者说陷阱就放到最后的总结篇来整体说明。从这一章开始花少量的篇幅谈谈锁机制。</p>
<p><a href="http://www.blogjava.net/xylz/archive/2010/07/04/325206.html" target="_blank">上一个章节</a>中谈到了锁机制，并且针对于原子操作谈了一些相关的概念和设计思想。接下来的文章中，尽可能的深入研究锁机制，并且理解里面的原理和实际应用场合。</p>
<p>尽管synchronized在语法上已经足够简单了，在JDK 5之前只能借助此实现，但是由于是独占锁，性能却不高，因此JDK 5以后就开始借助于JNI来完成更高级的锁实现。</p>
<p>JDK 5中的锁是接口<strong>java.util.concurrent.locks.Lock</strong>。另外<strong>java.util.concurrent.locks.ReadWriteLock</strong>提供了一对可供读写并发的锁。根据前面的规则，我们从<strong>java.util.concurrent.locks.Lock</strong>的API开始。</p>
<p><strong>void lock();</strong></p>
<p>获取锁。</p>
<p>如果锁不可用，出于线程调度目的，将禁用当前线程，并且在获得锁之前，该线程将一直处于休眠状态。</p>
<p><strong>void lockInterruptibly() throws InterruptedException;</strong></p>
<p>如果当前线程未被中断，则获取锁。</p>
<p>如果锁可用，则获取锁，并立即返回。</p>
<p>如果锁不可用，出于线程调度目的，将禁用当前线程，并且在发生以下两种情况之一以前，该线程将一直处于休眠状态：</p>
<ul>
<li>锁由当前线程获得；或者</li>
<li>其他某个线程<a href="http://www.blogjava.net/xylz/java/lang/Thread.html#interrupt(" target="_blank">中断</a>)当前线程，并且支持对锁获取的中断。</li>
</ul>
<p>如果当前线程：</p>
<ul>
<li>在进入此方法时已经设置了该线程的中断状态；或者</li>
<li>在获取锁时被<a href="http://www.blogjava.net/xylz/java/lang/Thread.html#interrupt(" target="_blank">中断</a>)，并且支持对锁获取的中断，
则将抛出 </li>
</ul>
<p>InterruptedException
，并清除当前线程的已中断状态。</p>
<p><strong>Condition newCondition();</strong></p>
<p>返回绑定到此 </p>
<p>Lock
 实例的新 </p>
<p>Condition
 实例。下一小节中会重点谈Condition，此处不做过多的介绍。</p>
<p><strong>boolean tryLock();</strong></p>
<p>仅在调用时锁为空闲状态才获取该锁。</p>
<p>如果锁可用，则获取锁，并立即返回值 </p>
<p>true
。如果锁不可用，则此方法将立即返回值 </p>
<p>false
。</p>
<p>通常对于那些不是必须获取锁的操作可能有用。</p>
<p><strong>boolean tryLock(long time, TimeUnit unit) throws InterruptedException;</strong></p>
<p>如果锁在给定的等待时间内空闲，并且当前线程未被中断，则获取锁。</p>
<p>如果锁可用，则此方法将立即返回值 </p>
<p>true
。如果锁不可用，出于线程调度目的，将禁用当前线程，并且在发生以下三种情况之一前，该线程将一直处于休眠状态：</p>
<ul>
<li>锁由当前线程获得；或者</li>
<li>其他某个线程中断当前线程，并且支持对锁获取的中断；或者</li>
<li>已超过指定的等待时间</li>
</ul>
<p>如果获得了锁，则返回值 </p>
<p>true
。</p>
<p>如果当前线程：</p>
<ul>
<li>在进入此方法时已经设置了该线程的中断状态；或者</li>
<li>在获取锁时被中断，并且支持对锁获取的中断，
则将抛出 </li>
</ul>
<p>InterruptedException
，并会清除当前线程的已中断状态。</p>
<p>如果超过了指定的等待时间，则将返回值 </p>
<p>false
。如果 time 小于等于 0，该方法将完全不等待。</p>
<p><strong>void unlock();</strong></p>
<p>释放锁。对应于lock()、tryLock()、tryLock(xx)、lockInterruptibly()等操作，如果成功的话应该对应着一个unlock()，这样可以避免死锁或者资源浪费。</p>
<p>相对于比较空洞的API，来看一个实际的例子。下面的代码实现了一个类似于AtomicInteger的操作。
package xylz.study.concurrency.lock;</p>
<p>import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;</p>
<p>public class AtomicIntegerWithLock {</p>
<pre><code>private int value;

private Lock lock = new ReentrantLock();

public AtomicIntegerWithLock() {
    super();
}

public AtomicIntegerWithLock(int value) {
    this.value = value;
}

public final int get() {
    lock.lock();
    try {
        return value;
    } finally {
        lock.unlock();
    }
}

public final void set(int newValue) {
    lock.lock();
    try {
        value = newValue;
    } finally {
        lock.unlock();
    }

}

public final int getAndSet(int newValue) {
    lock.lock();
    try {
        int ret = value;
        value = newValue;
        return ret;
    } finally {
        lock.unlock();
    }
}

public final boolean compareAndSet(int expect, int update) {
    lock.lock();
    try {
        if (value == expect) {
            value = update;
            return true;
        }
        return false;
    } finally {
        lock.unlock();
    }
}

public final int getAndIncrement() {
    lock.lock();
    try {
        return value++;
    } finally {
        lock.unlock();
    }
}

public final int getAndDecrement() {
    lock.lock();
    try {
        return value--;
    } finally {
        lock.unlock();
    }
}

public final int incrementAndGet() {
    lock.lock();
    try {
        return ++value;
    } finally {
        lock.unlock();
    }
}

public final int decrementAndGet() {
    lock.lock();
    try {
        return --value;
    } finally {
        lock.unlock();
    }
}

public String toString() {
    return Integer.toString(get());
}
</code></pre><p>}</p>
<p>类<strong>AtomicIntegerWithLock</strong>是线程安全的，此结构中大量使用了Lock对象的lock/unlock方法对。同样可以看到的是对于自增和自减操作使用了++/--。之所以能够保证线程安全，是因为Lock对象的lock()方法保证了只有一个线程能够只有此锁。需要说明的是对于任何一个lock()方法，都需要一个unlock()方法与之对于，通常情况下为了保证unlock方法总是能够得到执行，unlock方法被置于finally块中。另外这里使用了<strong>java.util.concurrent.locks.ReentrantLock.ReentrantLock</strong>对象，下一个小节中会具体描述此类作为Lock的唯一实现是如何设计和实现的。</p>
<p>尽管synchronized实现Lock的相同语义，并且在语法上比Lock要简单多，但是前者却比后者的开销要大得多。做一个简单的测试。
public static void main(String[] args) throws Exception{
     final int max = 10;
     final int loopCount = 100000;
     long costTime = 0;
     for (int m = 0; m &lt; max; m++) {
         long start1 = System.nanoTime();
         final AtomicIntegerWithLock value1 = new AtomicIntegerWithLock(0);
         Thread[] ts = new Thread[max];
         for(int i=0;i&lt;max;i++) {
             ts[i] = new Thread() {
                 public void run() {
                     for (int i = 0; i &lt; loopCount; i++) {
                         value1.incrementAndGet();
                     }
                 }
             };
         }
         for(Thread t:ts) {
             t.start();
         }
         for(Thread t:ts) {
             t.join();
         }
         long end1 = System.nanoTime();
         costTime += (end1-start1);
     }
     System.out.println(&quot;cost1: &quot; + (costTime));
     //
     System.out.println();
     costTime = 0;
     //
     final Object lock = new Object();
     for (int m = 0; m &lt; max; m++) {
         staticValue=0;
         long start1 = System.nanoTime();
         Thread[] ts = new Thread[max];
         for(int i=0;i&lt;max;i++) {
             ts[i] = new Thread() {
                 public void run() {
                     for (int i = 0; i &lt; loopCount; i++) {
                         synchronized(lock) {
                             ++staticValue;
                         }
                     }
                 }
             };
         }
         for(Thread t:ts) {
             t.start();
         }
         for(Thread t:ts) {
             t.join();
         }
         long end1 = System.nanoTime();
         costTime += (end1-start1);
     }
     //
     System.out.println(&quot;cost2: &quot; + (costTime));
}</p>
<p>static int staticValue = 0;</p>
<p>在这个例子中每次启动10个线程，每个线程计算100000次自增操作，重复测试10次，下面是某此测试的结果：</p>
<p>cost1: 624071136</p>
<p>cost2: 2057847833</p>
<p>尽管上面的例子不是非常正式的测试案例，但上面的例子在于说明，Lock的性能比synchronized的要好得多。如果可以的话总是使用Lock替代synchronized是一个明智的选择。</p>
<p>来源： <a href="[http://www.blogjava.net/xylz/archive/2010/07/05/325274.html](http://www.blogjava.net/xylz/archive/2010/07/05/325274.html)">[http://www.blogjava.net/xylz/archive/2010/07/05/325274.html](http://www.blogjava.net/xylz/archive/2010/07/05/325274.html)</a> </p>
<p>在理解J.U.C原理以及锁机制之前，我们来介绍J.U.C框架最核心也是最复杂的一个基础类：<strong>java.util.concurrent.locks.AbstractQueuedSynchronizer</strong>。</p>
<p><strong>AQS</strong></p>
<p>AbstractQueuedSynchronizer，简称AQS，是J.U.C最复杂的一个类，导致绝大多数讲解并发原理或者实战的时候都不会提到此类。但是虚心的作者愿意借助自己有限的能力和精力来探讨一二（参考资源中也有一些作者做了部分的分析。）。</p>
<p>首先从理论知识开始，在了解了相关原理后会针对源码进行一些分析，最后加上一些实战来描述。</p>
<p><a href="http://www.blogjava.net/images/blogjava_net/xylz/WindowsLiveWriter/JavaConcurrency72_93BD/image_2.png" target="_blank"><img src="&quot;image&quot;" alt="image"></a></p>
<p>上面的继承体系中，AbstractQueuedSynchronizer是CountDownLatch/FutureTask/ReentrantLock/RenntrantReadWriteLock/Semaphore的基础，因此AbstractQueuedSynchronizer是Lock/Executor实现的前提。公平锁、不公平锁、Condition、CountDownLatch、Semaphore等放到后面的篇幅中说明。</p>
<p>完整的设计原理可以参考Doug Lea的论文 <a href="http://gee.cs.oswego.edu/dl/papers/aqs.pdf" target="_blank"><em>The java</em>.<em>util</em>.<em>concurrent Synchronizer Framework</em></a> ，这里做一些简要的分析。</p>
<p>基本的思想是表现为一个同步器，支持下面两个操作：</p>
<p>获取锁：首先判断当前状态是否允许获取锁，如果是就获取锁，否则就阻塞操作或者获取失败，也就是说如果是独占锁就可能阻塞，如果是共享锁就可能失败。另外如果是阻塞线程，那么线程就需要进入阻塞队列。当状态位允许获取锁时就修改状态，并且如果进了队列就从队列中移除。
while(synchronization state does not allow acquire){</p>
<pre><code>enqueue current thread if not already queued;

possibly block current thread;
</code></pre><p>}</p>
<p>dequeue current thread if it was queued;</p>
<p>释放锁:这个过程就是修改状态位，如果有线程因为状态位阻塞的话就唤醒队列中的一个或者更多线程。</p>
<p>update synchronization state;</p>
<p>if(state may permit a blocked thread to acquire)</p>
<pre><code>unlock one or more queued threads;
</code></pre><p>要支持上面两个操作就必须有下面的条件：</p>
<ul>
<li>原子性操作同步器的状态位</li>
<li>阻塞和唤醒线程</li>
<li>一个有序的队列</li>
</ul>
<p>目标明确，要解决的问题也清晰了，那么剩下的就是解决上面三个问题。</p>
<p><strong>状态位的原子操作</strong></p>
<p>这里使用一个32位的整数来描述状态位，前面章节的原子操作的理论知识整好派上用场，在这里依然使用CAS操作来解决这个问题。事实上这里还有一个64位版本的同步器（AbstractQueuedLongSynchronizer），这里暂且不谈。</p>
<p><strong>阻塞和唤醒线程</strong></p>
<p>标准的JAVA API里面是无法挂起（阻塞）一个线程，然后在将来某个时刻再唤醒它的。JDK 1.0的API里面有Thread.suspend和Thread.resume，并且一直延续了下来。但是这些都是过时的API，而且也是不推荐的做法。</p>
<p>在JDK 5.0以后利用JNI在LockSupport类中实现了此特性。
LockSupport.park()
LockSupport.park(Object)
LockSupport.parkNanos(Object, long)
LockSupport.parkNanos(long)
LockSupport.parkUntil(Object, long)
LockSupport.parkUntil(long)
LockSupport.unpark(Thread)</p>
<p>上面的API中park()是在当前线程中调用，导致线程阻塞，带参数的Object是挂起的对象，这样监视的时候就能够知道此线程是因为什么资源而阻塞的。由于park()立即返回，所以通常情况下需要在循环中去检测竞争资源来决定是否进行下一次阻塞。park()返回的原因有三：</p>
<ul>
<li>其他某个线程调用将当前线程作为目标调用 <a href="http://www.blogjava.net/xylz/java/util/concurrent/locks/LockSupport.html#unpark(java.lang.Thread">
unpark
</a>)；</li>
<li>其他某个线程<a href="http://www.blogjava.net/xylz/java/lang/Thread.html#interrupt(" target="_blank">中断</a>)当前线程；</li>
<li>该调用不合逻辑地（即毫无理由地）返回。</li>
</ul>
<p>其实第三条就决定了需要循环检测了，类似于通常写的while(checkCondition()){Thread.sleep(time);}类似的功能。</p>
<p><strong>有序队列</strong></p>
<p>在AQS中采用CHL列表来解决有序的队列的问题。</p>
<p><a href="http://www.blogjava.net/images/blogjava_net/xylz/WindowsLiveWriter/JavaConcurrency72_93BD/image_6.png" target="_blank"><img src="&quot;image&quot;" alt="image"></a>AQS采用的CHL模型采用下面的算法完成FIFO的入队列和出队列过程。</p>
<p>对于入队列(<em>enqueue)：</em>采用CAS操作，每次比较尾结点是否一致，然后插入的到尾结点中。
do {</p>
<pre><code>    pred = tail;
</code></pre><p>}while ( !compareAndSet(pred,tail,node) );</p>
<p>对于出队列(<em>dequeue</em>):由于每一个节点也缓存了一个状态，决定是否出队列，因此当不满足条件时就需要自旋等待，一旦满足条件就将头结点设置为下一个节点。</p>
<p>while (pred.status != RELEASED) ;</p>
<p>head  = node;</p>
<p>实际上这里自旋等待也是使用LockSupport.park()来实现的。</p>
<p>AQS里面有三个核心字段：
private volatile int state;</p>
<p>private transient volatile Node head;</p>
<p>private transient volatile Node tail;</p>
<p>其中state描述的有多少个线程取得了锁，对于互斥锁来说state&lt;=1。head/tail加上CAS操作就构成了一个CHL的FIFO队列。下面是Node节点的属性。</p>
<p><strong><em>volatile int waitStatus;</em></strong> 节点的等待状态，一个节点可能位于以下几种状态：</p>
<ul>
<li>CANCELLED = 1： 节点操作因为超时或者对应的线程被interrupt。节点不应该留在此状态，一旦达到此状态将从CHL队列中踢出。</li>
<li>SIGNAL = -1： 节点的继任节点是（或者将要成为）BLOCKED状态（例如通过LockSupport.park()操作），因此一个节点一旦被释放（解锁）或者取消就需要唤醒（LockSupport.unpack()）它的继任节点。</li>
<li>CONDITION = -2：表明节点对应的线程因为不满足一个条件（Condition）而被阻塞。</li>
<li>0： 正常状态，新生的非CONDITION节点都是此状态。</li>
<li>非负值标识节点不需要被通知（唤醒）。</li>
</ul>
<p><strong><em>volatile Node prev;</em></strong>此节点的前一个节点。节点的waitStatus依赖于前一个节点的状态。</p>
<p><strong><em>volatile Node next;</em></strong>此节点的后一个节点。后一个节点是否被唤醒（uppark()）依赖于当前节点是否被释放。</p>
<p><strong><em>volatile Thread thread;</em></strong>节点绑定的线程。</p>
<p><strong><em>Node nextWaiter;</em></strong>下一个等待条件（Condition）的节点，由于Condition是独占模式，因此这里有一个简单的队列来描述Condition上的线程节点。</p>
<p><strong>AQS 在J.U.C里面是一个非常核心的工具，而且也非常复杂，里面考虑到了非常多的逻辑实现，所以在后面的章节中总是不断的尝试介绍AQS的特性和实现。</strong></p>
<p>这一个小节主要介绍了一些理论背景和相关的数据结构，在下一个小节中将根据以上知识来了解Lock.lock/unlock是如何实现的。</p>
<p>参考资料：</p>
<p>（1）<a href="http://www.cnblogs.com/MichaelPeng/archive/2010/02/12/1667947.html" target="_blank">ReentrantLock代码剖析之ReentrantLock.lock</a> <a href="http://www.cnblogs.com/MichaelPeng/archive/2010/02/17/1668986.html" target="_blank">ReentrantLock代码剖析之ReentrantLock.unlock</a> <a href="http://www.cnblogs.com/MichaelPeng/archive/2010/02/18/1669150.html" target="_blank">ReentrantLock代码剖析之ReentrantLock.lockInterruptibly</a></p>
<p>（2）<a href="http://wagtto.javaeye.com/blog/607848" target="_blank">java多线程--java.util.concurrent.locks.AbstractQueuedSynchronizer解析(只包含多线程同步示例)</a></p>
<p>（3）<a href="http://www.ibm.com/developerworks/cn/java/j-jtp05236.html" target="_blank">处理 InterruptedException</a></p>
<p>（4）<a href="http://hi.baidu.com/gefforey520/blog/item/6f64eb442300a446500ffe3f.html" target="_blank">AbstractQueuedSynchronizer源码解析之ReentrantLock(一)</a>  <a href="http://hi.baidu.com/gefforey520/blog/item/ce633582511217a80df4d26c.html" target="_blank">AbstractQueuedSynchronizer源码解析之ReentrantLock(二)</a></p>
<p>（5）<a href="http://gee.cs.oswego.edu/dl/papers/aqs.pdf" target="_blank"><em>The java</em>.<em>util</em>.<em>concurrent Synchronizer Framework</em></a>
来源： <a href="[http://www.blogjava.net/xylz/archive/2010/07/06/325390.html](http://www.blogjava.net/xylz/archive/2010/07/06/325390.html)">[http://www.blogjava.net/xylz/archive/2010/07/06/325390.html](http://www.blogjava.net/xylz/archive/2010/07/06/325390.html)</a> </p>
<p>接上篇，这篇从Lock.lock/unlock开始。特别说明在没有特殊情况下所有程序、API、文档都是基于JDK 6.0的。</p>
<p><strong>public void java.util.concurrent.locks.ReentrantLock.lock()</strong>
<em>获取锁。</em></p>
<p><em>如果该锁没有被另一个线程保持，则获取该锁并立即返回，将锁的保持计数设置为 1。</em></p>
<p><em>如果当前线程已经保持该锁，则将保持计数加 1，并且该方法立即返回。</em></p>
<p><em>如果该锁被另一个线程保持，则出于线程调度的目的，禁用当前线程，并且在获得锁之前，该线程将一直处于休眠状态，此时锁保持计数被设置为 1。</em></p>
<p>从上面的文档可以看出ReentrantLock是可重入锁的实现。而内部是委托java.util.concurrent.locks.ReentrantLock.Sync.lock()实现的。java.util.concurrent.locks.ReentrantLock.Sync是抽象类，有java.util.concurrent.locks.ReentrantLock.FairSync和java.util.concurrent.locks.ReentrantLock.NonfairSync两个实现，也就是常说的公平锁和不公平锁。</p>
<p><strong>公平锁和非公平锁</strong>
如果获取一个锁是按照请求的顺序得到的，那么就是公平锁，否则就是非公平锁。</p>
<p>在没有深入了解内部机制及实现之前，先了解下为什么会存在公平锁和非公平锁。公平锁保证一个阻塞的线程最终能够获得锁，因为是有序的，所以总是可以按照请求的顺序获得锁。不公平锁意味着后请求锁的线程可能在其前面排列的休眠线程恢复前拿到锁，这样就有可能提高并发的性能。这是因为通常情况下挂起的线程重新开始与它真正开始运行，二者之间会产生严重的延时。因此非公平锁就可以利用这段时间完成操作。这是非公平锁在某些时候比公平锁性能要好的原因之一。</p>
<p>二者在实现上的区别会在后面介绍，我们先从公平锁（FairSync）开始。</p>
<p>前面说过<strong>java.util.concurrent.locks.AbstractQueuedSynchronizer （AQS)</strong>是Lock的基础，对于一个FairSync而言，lock()就直接调用AQS的acquire(int arg);
<strong>public final void acquire(int arg)</strong> <em>以独占模式获取对象，忽略中断。通过至少调用一次 </em><a href="http://www.blogjava.net/xylz/java/util/concurrent/locks/AbstractQueuedSynchronizer.html#tryAcquire(int">
<em>tryAcquire(int)</em>
</a>)<em> 来实现此方法，并在成功时返回。否则在成功之前，一直调用 </em><a href="http://www.blogjava.net/xylz/java/util/concurrent/locks/AbstractQueuedSynchronizer.html#tryAcquire(int">
<em>tryAcquire(int)</em>
</a>)<em> 将线程加入队列，线程可能重复被阻塞或不被阻塞。</em></p>
<p>在介绍实现之前先要补充上一节的知识，对于一个AQS的实现而言，通常情况下需要实现以下方法来描述如何锁定线程。</p>
<ul>
<li><strong>tryAcquire(int)</strong> 
试图在独占模式下获取对象状态。此方法应该查询是否允许它在独占模式下获取对象状态，如果允许，则获取它。</li>
</ul>
<p>此方法总是由执行 acquire 的线程来调用。如果此方法报告失败，则 acquire 方法可以将线程加入队列（如果还没有将它加入队列），直到获得其他某个线程释放了该线程的信号。也就是说此方法是一种尝试性方法，如果成功获取锁那最好，如果没有成功也没有关系，直接返回false。</p>
<ul>
<li><strong>tryRelease(int)</strong> 
试图设置状态来反映独占模式下的一个释放。 此方法总是由正在执行释放的线程调用。释放锁可能失败或者抛出异常，这个在后面会具体分析。</li>
<li><strong>tryAcquireShared(int)</strong> 试图在共享模式下获取对象状态。</li>
<li><strong>tryReleaseShared(int)</strong> 试图设置状态来反映共享模式下的一个释放。</li>
<li><strong>isHeldExclusively()</strong> 如果对于当前（正调用的）线程，同步是以独占方式进行的，则返回         true    。</li>
</ul>
<p>除了tryAcquire(int)外，其它方法会在后面具体介绍。首先对于ReentrantLock而言，不管是公平锁还是非公平锁，都是独占锁，也就是说同时能够有一个线程持有锁。因此对于acquire(int arg)而言，arg==1。在AQS中acquire的实现如下：</p>
<p>public final void acquire(int arg) {
    if (!tryAcquire(arg) &amp;&amp;
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        selfInterrupt();
}</p>
<p>这个看起来比较复杂，我们分解以下4个步骤。</p>
<ol>
<li>如果tryAcquire(arg)成功，那就没有问题，已经拿到锁，整个lock()过程就结束了。如果失败进行操作2。</li>
<li>创建一个独占节点（Node）并且此节点加入CHL队列末尾。进行操作3。</li>
<li>自旋尝试获取锁，失败根据前一个节点来决定是否挂起（park()），直到成功获取到锁。进行操作4。</li>
<li>如果当前线程已经中断过，那么就中断当前线程（清除中断位）。</li>
</ol>
<p>这是一个比较复杂的过程，我们按部就班一个一个分析。</p>
<p><strong>tryAcquire(acquires)</strong></p>
<p>对于公平锁而言，它的实现方式如下：
    protected final boolean tryAcquire(int acquires) {
        final Thread current = Thread.currentThread();
        int c = getState();
        if (c == 0) {
            if (isFirst(current) &amp;&amp;
                compareAndSetState(0, acquires)) {
                setExclusiveOwnerThread(current);
                return true;
            }
        }
        else if (current == getExclusiveOwnerThread()) {
            int nextc = c + acquires;
            if (nextc &lt; 0)
                throw new Error(&quot;Maximum lock count exceeded&quot;);
            setState(nextc);
            return true;
        }
        return false;
    }
}</p>
<p>在这段代码中，前面说明对于AQS存在一个state来描述当前有多少线程持有锁。由于AQS支持共享锁（例如读写锁，后面会继续讲），所以这里state&gt;=0，但是由于ReentrantLock是独占锁，所以这里不妨理解为0&lt;=state，acquires=1。isFirst(current)是一个很复杂的逻辑，包括踢出无用的节点等复杂过程，这里暂且不提，大体上的意思是说判断AQS是否为空或者当前线程是否在队列头（为了区分公平与非公平锁）。</p>
<ol>
<li>如果当前锁有其它线程持有，c!=0，进行操作2。否则，如果当前线程在AQS队列头部，则尝试将AQS状态state设为acquires（等于1），成功后将AQS独占线程设为当前线程返回true，否则进行2。这里可以看到compareAndSetState就是使用了CAS操作。</li>
<li>判断当前线程与AQS的独占线程是否相同，如果相同，那么就将当前状态位加1（这里+1后结果为负数后面会讲，这里暂且不理它），修改状态位，返回true，否则进行3。这里之所以不是将当前状态位设置为1，而是修改为旧值+1呢？这是因为ReentrantLock是可重入锁，同一个线程每持有一次就+1。</li>
<li>返回false。</li>
</ol>
<p>比较非公平锁的tryAcquire实现java.util.concurrent.locks.ReentrantLock.Sync.nonfairTryAcquire(int)，公平锁多了一个判断当前节点是否在队列头，这个就保证了是否按照请求锁的顺序来决定获取锁的顺序（同一个线程的多次获取锁除外）。</p>
<p>现在再回头看公平锁和非公平锁的lock()方法。公平锁只有一句acquire(1)；而非公平锁的调用如下：
final void lock() {
    if (compareAndSetState(0, 1))
        setExclusiveOwnerThread(Thread.currentThread());
    else
        acquire(1);
}</p>
<p>很显然，非公平锁在第一次获取锁，或者其它线程释放锁后（可能等待），优先采用compareAndSetState(0,1)然后设置AQS独占线程而持有锁，这样有时候比acquire(1)顺序检查锁持有而要高效。即使在重入锁上，也就是compareAndSetState(0,1)失败，但是是当前线程持有锁上，非公平锁也没有问题。</p>
<p><strong>addWaiter(mode)</strong></p>
<p>tryAcquire失败就意味着入队列了。此时AQS的队列中节点Node就开始发挥作用了。一般情况下AQS支持独占锁和共享锁，而独占锁在Node中就意味着条件（Condition）队列为空（上一篇中介绍过相关概念）。在java.util.concurrent.locks.AbstractQueuedSynchronizer.Node中有两个常量，
static final Node EXCLUSIVE = null; //独占节点模式</p>
<p>static final Node SHARED = new Node(); //共享节点模式</p>
<p>addWaiter(mode)中的mode就是节点模式，也就是共享锁还是独占锁模式。</p>
<p>前面一再强调ReentrantLock是独占锁模式。
private Node addWaiter(Node mode) {
     Node node = new Node(Thread.currentThread(), mode);
     // Try the fast path of enq; backup to full enq on failure
     Node pred = tail;
     if (pred != null) {
         node.prev = pred;
         if (compareAndSetTail(pred, node)) {
             pred.next = node;
             return node;
         }
     }
     enq(node);
     return node;
}</p>
<p>上面是节点如队列的一部分。当前仅当队列不为空并且将新节点插入尾部成功后直接返回新节点。否则进入enq(Node)进行操作。</p>
<p>private Node enq(final Node node) {
    for (;;) {
        Node t = tail;
        if (t == null) { // Must initialize
            Node h = new Node(); // Dummy header
            h.next = node;
            node.prev = h;
            if (compareAndSetHead(h)) {
                tail = node;
                return h;
            }
        }
        else {
            node.prev = t;
            if (compareAndSetTail(t, node)) {
                t.next = node;
                return t;
            }
        }
    }
}</p>
<p>enq(Node)去队列操作实现了CHL队列的算法，如果为空就创建头结点，然后同时比较节点尾部是否是改变来决定CAS操作是否成功，当且仅当成功后才将为不节点的下一个节点指向为新节点。可以看到这里仍然是CAS操作。</p>
<p><strong>acquireQueued(node,arg)</strong></p>
<p>自旋请求锁，如果可能的话挂起线程，直到得到锁，返回当前线程是否中断过（如果park()过并且中断过的话有一个interrupted中断位）。
final boolean acquireQueued(final Node node, int arg) {
    try {
        boolean interrupted = false;
        for (;;) {
            final Node p = node.predecessor();
            if (p == head &amp;&amp; tryAcquire(arg)) {
                setHead(node);
                p.next = null; // help GC
                return interrupted;
            }
            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;
                parkAndCheckInterrupt())
                interrupted = true;
        }
    } catch (RuntimeException ex) {
        cancelAcquire(node);
        throw ex;
    }
}</p>
<p>下面的分析就需要用到上节节点的状态描述了。acquireQueued过程是这样的：</p>
<ol>
<li>如果当前节点是AQS队列的头结点（如果第一个节点是DUMP节点也就是傀儡节点，那么第二个节点实际上就是头结点了），就尝试在此获取锁tryAcquire(arg)。如果成功就将头结点设置为当前节点（不管第一个结点是否是DUMP节点），返回中断位。否则进行2。</li>
<li>检测当前节点是否应该park()，如果应该park()就挂起当前线程并且返回当前线程中断位。进行操作1。</li>
</ol>
<p>一个节点是否该park()是关键，这是由方法java.util.concurrent.locks.AbstractQueuedSynchronizer.shouldParkAfterFailedAcquire(Node, Node)实现的。
private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {
    int s = pred.waitStatus;
    if (s &lt; 0) return true;
    if (s &gt; 0) {
        do {
            node.prev = pred = pred.prev;
        } while (pred.waitStatus &gt; 0);
        pred.next = node;
    } else compareAndSetWaitStatus(pred, 0, Node.SIGNAL);
    return false;
}</p>
<ol>
<li>如果前一个节点的等待状态waitStatus&lt;0，也就是前面的节点还没有获得到锁，那么返回true，表示当前节点（线程）就应该park()了。否则进行2。</li>
<li>如果前一个节点的等待状态waitStatus&gt;0，也就是前一个节点被CANCELLED了，那么就将前一个节点去掉，递归此操作直到所有前一个节点的waitStatus&lt;=0，进行4。否则进行3。</li>
<li>前一个节点等待状态waitStatus=0，修改前一个节点状态位为SINGAL，表示后面有节点等待你处理，需要根据它的等待状态来决定是否该park()。进行4。</li>
<li>返回false，表示线程不应该park()。</li>
</ol>
<p><strong>selfInterrupt()</strong>
private static void selfInterrupt() {
    Thread.currentThread().interrupt();
}</p>
<p>如果线程曾经中断过（或者阻塞过）（比如手动interrupt()或者超时等等，那么就再中断一次，中断两次的意思就是清除中断位）。</p>
<p>大体上整个Lock.lock()就这样一个流程。除了lock()方法外，还有lockInterruptibly()/tryLock()/unlock()/newCondition()等，在接下来的章节中会一一介绍。
来源： <a href="[http://www.blogjava.net/xylz/archive/2010/07/07/325410.html](http://www.blogjava.net/xylz/archive/2010/07/07/325410.html)">[http://www.blogjava.net/xylz/archive/2010/07/07/325410.html](http://www.blogjava.net/xylz/archive/2010/07/07/325410.html)</a> </p>
<p>本小节介绍锁释放Lock.unlock()。</p>
<p><strong>Release/TryRelease</strong></p>
<p>unlock操作实际上就调用了<a href="http://www.blogjava.net/xylz/archive/2010/07/06/325390.html" target="_blank"><strong>AQS</strong></a>的release操作，释放持有的锁。
public final boolean release(int arg) {
    if (tryRelease(arg)) {
        Node h = head;
        if (h != null &amp;&amp; h.waitStatus != 0)
            unparkSuccessor(h);
        return true;
    }
    return false;
}</p>
<p>前面提到过<strong><em>tryRelease(arg)</em></strong>操作，此操作里面总是尝试去释放锁，如果成功，说明锁确实被当前线程持有，那么就看<strong>AQS</strong>队列中的头结点是否为空并且能否被唤醒，如果可以的话就唤醒继任节点（下一个非CANCELLED节点，下面会具体分析）。</p>
<p>对于独占锁而言，java.util.concurrent.locks.ReentrantLock.Sync.tryRelease(int)展示了如何尝试释放锁(<strong><em>tryRelease</em></strong>)操作。
protected final boolean tryRelease(int releases) {
    int c = getState() - releases;
    if (Thread.currentThread() != getExclusiveOwnerThread())
        throw new IllegalMonitorStateException();
    boolean free = false;
    if (c == 0) {
        free = true;
        setExclusiveOwnerThread(null);
    }
    setState(c);
    return free;
}</p>
<p>整个<strong><em>tryRelease</em></strong>操作是这样的：</p>
<ol>
<li>判断持有锁的线程是否是当前线程，如果不是就抛出IllegalMonitorStateExeception()，因为一个线程是不能释放另一个线程持有的锁（否则锁就失去了意义）。否则进行2。</li>
<li>将AQS状态位减少要释放的次数（对于独占锁而言总是1），如果剩余的状态位0（也就是没有线程持有锁），那么当前线程就是最后一个持有锁的线程，清空AQS持有锁的独占线程。进行3。</li>
<li>将剩余的状态位写回AQS，如果没有线程持有锁就返回true，否则就是false。</li>
</ol>
<p>参考上一节的分析就可以知道，这里c==0决定了是否完全释放了锁。由于<strong><em>ReentrantLock</em></strong>是可重入锁，因此同一个线程可能多重持有锁，那么当且仅当最后一个持有锁的线程释放锁是才能将AQS中持有锁的独占线程清空，这样接下来的操作才需要唤醒下一个需要锁的<strong>AQS</strong>节点（Node），否则就只是减少锁持有的计数器，并不能改变其他操作。</p>
<p>当<strong><em>tryRelease</em></strong>操作成功后（也就是完全释放了锁），release操作才能检查是否需要唤醒下一个继任节点。这里的前提是<strong>AQS</strong>队列的头结点需要锁(<em>waitStatus!=0</em>)，如果头结点需要锁，就开始检测下一个继任节点是否需要锁操作。</p>
<p>在上一节中说道<strong><em>acquireQueued</em></strong>操作完成后（拿到了锁），会将当前持有锁的节点设为头结点，所以一旦头结点释放锁，那么就需要寻找头结点的下一个需要锁的继任节点，并唤醒它。
private void unparkSuccessor(Node node) {
        //此时node是需要是需要释放锁的头结点</p>
<pre><code>    //清空头结点的waitStatus，也就是不再需要锁了
    compareAndSetWaitStatus(node, Node.SIGNAL, 0);

    //从头结点的下一个节点开始寻找继任节点，当且仅当继任节点的waitStatus&lt;=0才是有效继任节点，否则将这些waitStatus&gt;0（也就是CANCELLED的节点）从AQS队列中剔除  
   //这里并没有从head-&gt;tail开始寻找，而是从tail-&gt;head寻找最后一个有效节点。
   //解释在这里 http://www.blogjava.net/xylz/archive/2010/07/08/325540.html/#377512

    Node s = node.next;
    if (s == null || s.waitStatus &gt; 0) {
        s = null;
        for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev)
            if (t.waitStatus &lt;= 0)
                s = t;
    }

    //如果找到一个有效的继任节点，就唤醒此节点线程
    if (s != null)
        LockSupport.unpark(s.thread);
}
</code></pre><p>这里再一次把<strong><em>acquireQueued</em></strong>的过程找出来。对比<strong><em>unparkSuccessor</em></strong>，一旦头节点的继任节点被唤醒，那么继任节点就会尝试去获取锁（在<strong><em>acquireQueued</em></strong>中node就是有效的继任节点，p就是唤醒它的头结点），如果成功就会将头结点设置为自身，并且将头结点的前任节点清空，这样前任节点（已经过时了）就可以被GC释放了。</p>
<p>final boolean acquireQueued(final Node node, int arg) {
    try {
        boolean interrupted = false;
        for (;;) {
            final Node p = node.predecessor();
            if (p == head &amp;&amp; tryAcquire(arg)) {
                setHead(node);
                p.next = null; // help GC
                return interrupted;
            }
            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;
                parkAndCheckInterrupt())
                interrupted = true;
        }
    } catch (RuntimeException ex) {
        cancelAcquire(node);
        throw ex;
    }
}</p>
<p>在<strong><em>setHead</em></strong>中，将头结点的前任节点清空并且将头结点的线程清空就是为了更好的GC，防止内存泄露。</p>
<p>private void setHead(Node node) {
    head = node;
    node.thread = null;
    node.prev = null;
}</p>
<p>对比lock()操作，unlock()操作还是比较简单的，主要就是释放响应的资源，并且唤醒<strong>AQS</strong>队列中有效的继任节点。这样所就按照请求的顺序去尝试获取锁了。</p>
<p>整个lock()/unlock()过程完成了，我们再回头看公平锁(FairSync)和非公平锁(NonfairSync)。</p>
<p>公平锁和非公平锁只是在获取锁的时候有差别，其它都是一样的。
final void lock() {
    if (compareAndSetState(0, 1))
        setExclusiveOwnerThread(Thread.currentThread());
    else
        acquire(1);
}</p>
<p>在上面非公平锁的代码中总是优先尝试当前是否有线程持有锁，一旦没有任何线程持有锁，那么非公平锁就霸道的尝试将锁“占为己有”。如果在抢占锁的时候失败就和公平锁一样老老实实的去排队。</p>
<p>也即是说公平锁和非公平锁只是在入<strong>AQS</strong>的<strong>CLH</strong>队列之前有所差别，一旦进入了队列，所有线程都是按照队列中先来后到的顺序请求锁。</p>
<p><strong>Condition</strong></p>
<p>条件变量很大一个程度上是为了解决Object.wait/notify/notifyAll难以使用的问题。</p>
<p>条件（也称为<em>条件队列</em> 或<em>条件变量</em>）为线程提供了一个含义，以便在某个状态条件现在可能为 true 的另一个线程通知它之前，一直挂起该线程（即让其“等待”）。因为访问此共享状态信息发生在不同的线程中，所以它必须受保护，因此要将某种形式的锁与该条件相关联。等待提供一个条件的主要属性是：<em>以原子方式</em> 释放相关的锁，并挂起当前线程，就像 </p>
<p>Object.wait
 做的那样。</p>
<p>上述API说明表明条件变量需要与锁绑定，而且多个Condition需要绑定到同一锁上。前面的<strong>Lock</strong>中提到，获取一个条件变量的方法是<strong>Lock.newCondition()</strong>。
void await() throws InterruptedException;
void awaitUninterruptibly();
long awaitNanos(long nanosTimeout) throws InterruptedException;
boolean await(long time, TimeUnit unit) throws InterruptedException;
boolean awaitUntil(Date deadline) throws InterruptedException;
void signal();
void signalAll();</p>
<p>以上是<strong>Condition</strong>接口定义的方法，<em>await/**对应于</em>Object.wait<em>，</em>signal<em>对应于</em>Object.notify<em>，</em>signalAll<em>对应于</em>Object.notifyAll<em>。特别说明的是<strong>Condition</strong>的接口改变名称就是为了避免与Object中的</em>wait/notify/notifyAll<em>的语义和使用上混淆，因为Condition同样有</em>wait/notify/notifyAll*方法。</p>
<p>每一个<strong>Lock</strong>可以有任意数据的<strong>Condition</strong>对象，<strong>Condition</strong>是与<strong>Lock</strong>绑定的，所以就有<strong>Lock</strong>的公平性特性：如果是公平锁，线程为按照FIFO的顺序从<em>Condition.await</em>中释放，如果是非公平锁，那么后续的锁竞争就不保证FIFO顺序了。</p>
<p>一个使用Condition实现生产者消费者的模型例子如下。
package xylz.study.concurrency.lock;</p>
<p>import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;</p>
<p>public class ProductQueue<T> {</p>
<pre><code>private final T[] items;

private final Lock lock = new ReentrantLock();

private Condition notFull = lock.newCondition();

private Condition notEmpty = lock.newCondition();

//
private int head, tail, count;

public ProductQueue(int maxSize) {
    items = (T[]) new Object[maxSize];
}

public ProductQueue() {
    this(10);
}

public void put(T t) throws InterruptedException {
    lock.lock();
    try {
        while (count == getCapacity()) {
            notFull.await();
        }
        items[tail] = t;
        if (++tail == getCapacity()) {
            tail = 0;
        }
        ++count;
        notEmpty.signalAll();
    } finally {
        lock.unlock();
    }
}

public T take() throws InterruptedException {
    lock.lock();
    try {
        while (count == 0) {
            notEmpty.await();
        }
        T ret = items[head];
        items[head] = null;//GC
        //
        if (++head == getCapacity()) {
            head = 0;
        }
        --count;
        notFull.signalAll();
        return ret;
    } finally {
        lock.unlock();
    }
}

public int getCapacity() {
    return items.length;
}

public int size() {
    lock.lock();
    try {
        return count;
    } finally {
        lock.unlock();
    }
}
</code></pre><p>}</p>
<p>在这个例子中消费<em>take()</em>需要 队列不为空，如果为空就挂起（<em>await()</em>），直到收到<em>notEmpty</em>的信号；生产<em>put()</em>需要队列不满，如果满了就挂起（<em>await()</em>），直到收到<em>notFull</em>的信号。</p>
<p>可能有人会问题，如果一个线程<em>lock()</em>对象后被挂起还没有<em>unlock</em>，那么另外一个线程就拿不到锁了（<em>lock()</em>操作会挂起），那么就无法通知(<em>notify</em>)前一个线程，这样岂不是“死锁”了？</p>
<p><strong>await/* 操作</strong></p>
<p>上一节中说过多次<em>ReentrantLock</em>是独占锁，一个线程拿到锁后如果不释放，那么另外一个线程肯定是拿不到锁，所以在<em>lock.lock()</em>和<em>lock.unlock()</em>之间可能有一次释放锁的操作（同样也必然还有一次获取锁的操作）。我们再回头看代码，不管<em>take()</em>还是<em>put()</em>，在进入<em>lock.lock()</em>后唯一可能释放锁的操作就是<em>await()</em>了。也就是说<em>await()</em>操作实际上就是释放锁，然后挂起线程，一旦条件满足就被唤醒，再次获取锁！
public final void await() throws InterruptedException {
    if (Thread.interrupted())
        throw new InterruptedException();
    Node node = addConditionWaiter();
    int savedState = fullyRelease(node);
    int interruptMode = 0;
    while (!isOnSyncQueue(node)) {
        LockSupport.park(this);
        if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)
            break;
    }
    if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)
        interruptMode = REINTERRUPT;
    if (node.nextWaiter != null)
        unlinkCancelledWaiters();
    if (interruptMode != 0)
        reportInterruptAfterWait(interruptMode);
}</p>
<p>上面是<em>await()</em>的代码片段。上一节中说过，<a href="http://www.blogjava.net/xylz/archive/2010/07/06/325390.html" target="_blank"><strong>AQS</strong></a>在获取锁的时候需要有一个<a href="http://www.blogjava.net/xylz/archive/2010/07/06/325390.html" target="_blank"><strong>CHL</strong></a>的FIFO队列，所以对于一个<em>Condition.await()</em>而言，如果释放了锁，要想再一次获取锁那么就需要进入队列，等待被通知获取锁。完整的await()操作是安装如下步骤进行的：</p>
<ol>
<li>将当前线程加入<em>Condition</em>锁队列。特别说明的是，这里不同于<a href="http://www.blogjava.net/xylz/archive/2010/07/06/325390.html" target="_blank"><strong>AQS</strong></a>的队列，这里进入的是<em>Condition</em>的FIFO队列。后面会具体谈到此结构。进行2。</li>
<li>释放锁。这里可以看到将锁释放了，否则别的线程就无法拿到锁而发生死锁。进行3。</li>
<li>自旋(while)挂起，直到被唤醒或者超时或者CACELLED等。进行4。</li>
<li>获取锁(<em>acquireQueued</em>)。并将自己从<em>Condition</em>的FIFO队列中释放，表明自己不再需要锁（我已经拿到锁了）。</li>
</ol>
<p>这里再回头介绍<em>Condition</em>的数据结构。我们知道一个<em>Condition</em>可以在多个地方被<em>await/</em>()<em>，那么就需要一个FIFO的结构将这些</em>Condition<em>串联起来，然后根据需要唤醒一个或者多个（通常是所有）。所以在</em>Condition*内部就需要一个FIFO的队列。
private transient Node firstWaiter;
private transient Node lastWaiter;</p>
<p>上面的两个节点就是描述一个FIFO的队列。我们再结合<a href="http://www.blogjava.net/xylz/archive/2010/07/06/325390.html" target="_blank">前面</a>提到的<a href="http://www.blogjava.net/xylz/archive/2010/07/06/325390.html" target="_blank">节点（Node）数据结构</a>。我们就发现<em>Node.nextWaiter</em>就派上用场了！<em>nextWaiter</em>就是将一系列的<em>Condition.await/*</em>串联起来组成一个FIFO的队列。</p>
<p><strong>signal/signalAll 操作</strong></p>
<p><em>await/</em>()<em>清楚了，现在再来看</em>signal/signalAll<em>就容易多了。按照</em>signal/signalAll<em>的需求，就是要将</em>Condition.await/<em>()</em>中FIFO队列中第一个<strong>Node</strong>唤醒（或者全部<strong>Node</strong>）唤醒。尽管所有<strong>Node</strong>可能都被唤醒，但是要知道的是仍然只有一个线程能够拿到锁，其它没有拿到锁的线程仍然需要自旋等待，就上上面提到的第4步(acquireQueued)。
private void doSignal(Node first) {
    do {
        if ( (firstWaiter = first.nextWaiter) == null)
            lastWaiter = null;
        first.nextWaiter = null;
    } while (!transferForSignal(first) &amp;&amp;
             (first = firstWaiter) != null);
}</p>
<p>private void doSignalAll(Node first) {
    lastWaiter = firstWaiter  = null;
    do {
        Node next = first.nextWaiter;
        first.nextWaiter = null;
        transferForSignal(first);
        first = next;
    } while (first != null);
}</p>
<p>上面的代码很容易看出来，<em>signal</em>就是唤醒<strong>Condition</strong>队列中的第一个非CANCELLED节点线程，而signalAll就是唤醒所有非CANCELLED节点线程。当然了遇到CANCELLED线程就需要将其从FIFO队列中剔除。</p>
<p>final boolean transferForSignal(Node node) {
    if (!compareAndSetWaitStatus(node, Node.CONDITION, 0))
        return false;</p>
<pre><code>Node p = enq(node);
int c = p.waitStatus;
if (c &gt; 0 || !compareAndSetWaitStatus(p, c, Node.SIGNAL))
    LockSupport.unpark(node.thread);
return true;
</code></pre><p>}</p>
<p>上面就是唤醒一个<em>await/</em>()<em>线程的过程，根据前面的小节介绍的，如果要</em>unpark<em>线程，并使线程拿到锁，那么就需要线程节点进入<strong>AQS</strong>的队列。所以可以看到在</em>LockSupport.unpark<em>之前调用了</em>enq(node)<em>操作，将当前节点加入到<em>*AQS</em></em>队列。</p>
<p>整个锁机制的原理就介绍完了，从下一节开始就进入了锁机制的应用了。</p>
<p>此小节介绍几个与锁有关的有用工具。</p>
<p><strong>闭锁（Latch）</strong></p>
<p>闭锁（Latch）：一种同步方法，可以延迟线程的进度直到线程到达某个终点状态。通俗的讲就是，一个闭锁相当于一扇大门，在大门打开之前所有线程都被阻断，一旦大门打开所有线程都将通过，但是一旦大门打开，所有线程都通过了，那么这个闭锁的状态就失效了，门的状态也就不能变了，只能是打开状态。也就是说闭锁的状态是一次性的，它确保在闭锁打开之前所有特定的活动都需要在闭锁打开之后才能完成。</p>
<p><strong>CountDownLatch</strong>是JDK 5+里面闭锁的一个实现，允许一个或者多个线程等待某个事件的发生。<strong>CountDownLatch</strong>有一个正数计数器，<em>countDown</em>方法对计数器做减操作，<em>await</em>方法等待计数器达到0。所有<em>await</em>的线程都会阻塞直到计数器为0或者等待线程中断或者超时。</p>
<p><strong>CountDownLatch</strong>的API如下。</p>
<ul>
<li>public void await() throws InterruptedException</li>
<li>public boolean await(long timeout, TimeUnit unit) throws InterruptedException</li>
<li>public void countDown()</li>
<li>public long getCount()</li>
</ul>
<p>其中<em>getCount()</em>描述的是当前计数，通常用于调试目的。</p>
<p>下面的例子中描述了闭锁的两种常见的用法。
package xylz.study.concurrency.lock;</p>
<p>import java.util.concurrent.CountDownLatch;</p>
<p>public class PerformanceTestTool {</p>
<pre><code>public long timecost(final int times, final Runnable task) throws InterruptedException {
    if (times &lt;= 0) throw new IllegalArgumentException();
    final CountDownLatch startLatch = new CountDownLatch(1);
    final CountDownLatch overLatch = new CountDownLatch(times);
    for (int i = 0; i &lt; times; i++) {
        new Thread(new Runnable() {
            public void run() {
                try {
                    startLatch.await();
                    //
                    task.run();
                } catch (InterruptedException ex) {
                    Thread.currentThread().interrupt();
                } finally {
                    overLatch.countDown();
                }
            }
        }).start();
    }
    //
    long start = System.nanoTime();
    startLatch.countDown();
    overLatch.await();
    return System.nanoTime() - start;
}
</code></pre><p>}</p>
<p>在上面的例子中使用了两个闭锁，第一个闭锁确保在所有线程开始执行任务前，所有准备工作都已经完成，一旦准备工作完成了就调用<em>startLatch.countDown()</em>打开闭锁，所有线程开始执行。第二个闭锁在于确保所有任务执行完成后主线程才能继续进行，这样保证了主线程等待所有任务线程执行完成后才能得到需要的结果。在第二个闭锁当中，初始化了一个N次的计数器，每个任务执行完成后都会将计数器减一，所有任务完成后计数器就变为了0，这样主线程闭锁overLatch拿到此信号后就可以继续往下执行了。</p>
<p>根据前面的<a href="http://www.blogjava.net/xylz/archive/2010/07/03/325168.html" target="_blank">happend-before法则</a>可以知道闭锁有以下特性：
**内存一致性效果：线程中调用 </p>
<p>countDown()
 之前的操作 <strong><a href="http://www.blogjava.net/xylz/archive/2010/07/03/325168.html" target="_blank">happen-before</a><strong>**</strong></strong> 紧跟在从另一个线程中对应 </p>
<p>await()
 成功返回的操作。**</p>
<p>在上面的例子中第二个闭锁相当于把一个任务拆分成N份，每一份独立完成任务，主线程等待所有任务完成后才能继续执行。这个特性在后面的线程池框架中会用到，其实<strong>FutureTask</strong>就可以看成一个闭锁。后面的章节还会具体分析<strong>FutureTask</strong>的。</p>
<p>同样基于探索精神，仍然需要“窥探”下<strong>CountDownLatch</strong>里面到底是如何实现<em>await/**和</em>countDown*的。</p>
<p>首先，研究下<em>await()</em>方法。内部直接调用了<a href="http://www.blogjava.net/xylz/archive/2010/07/06/325390.html" target="_blank"><strong>AQS</strong></a>的<em>acquireSharedInterruptibly(1)</em>。
public final void acquireSharedInterruptibly(int arg) throws InterruptedException {
    if (Thread.interrupted())
        throw new InterruptedException();
    if (tryAcquireShared(arg) &lt; 0)
        doAcquireSharedInterruptibly(arg);
}</p>
<p>前面一直提到的都是独占锁（排它锁、互斥锁），现在就用到了另外一种锁，共享锁。</p>
<p>所谓共享锁是说所有共享锁的线程共享同一个资源，一旦任意一个线程拿到共享资源，那么所有线程就都拥有的同一份资源。也就是通常情况下共享锁只是一个标志，所有线程都等待这个标识是否满足，一旦满足所有线程都被激活（相当于所有线程都拿到锁一样）。这里的闭锁<strong>CountDownLatch</strong>就是基于共享锁的实现。</p>
<p>闭锁中关于<strong>AQS</strong>的<em>tryAcquireShared</em>的实现是如下代码（<strong>java.util.concurrent.CountDownLatch.Sync.tryAcquireShared</strong>）：
public int tryAcquireShared(int acquires) {
    return getState() == 0? 1 : -1;
}</p>
<p>在这份逻辑中，对于闭锁而言第一次await时tryAcquireShared应该总是-1，因为对于闭锁<strong>CountDownLatch</strong>而言<em>state</em>的值就是初始化的<em>count</em>值。这也就解释了为什么在<em>countDown</em>调用之前闭锁的<em>count</em>总是&gt;0。</p>
<p>private void doAcquireSharedInterruptibly(int arg)
    throws InterruptedException {
    final Node node = addWaiter(Node.SHARED);
    try {
        for (;;) {
            final Node p = node.predecessor();
            if (p == head) {
                int r = tryAcquireShared(arg);
                if (r &gt;= 0) {
                    setHeadAndPropagate(node, r);
                    p.next = null; // help GC
                    return;
                }
            }
            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;
                parkAndCheckInterrupt())
                break;
        }
    } catch (RuntimeException ex) {
        cancelAcquire(node);
        throw ex;
    }
    // Arrive here only if interrupted
    cancelAcquire(node);
    throw new InterruptedException();
}</p>
<p>上面的逻辑展示了如何通过<em>await</em>将所有线程串联并挂起，直到被唤醒或者条件满足或者被中断。整个过程是这样的：</p>
<ol>
<li>将当前线程节点以共享模式加入<strong>AQS</strong>的<strong>CLH</strong>队列中（相关概念参考<a href="http://www.blogjava.net/xylz/archive/2010/07/06/325390.html" target="_blank">这里</a>和<a href="http://www.blogjava.net/xylz/archive/2010/07/07/325410.html" target="_blank">这里</a>）。进行2。</li>
<li>检查当前节点的前任节点，如果是头结点并且当前闭锁计数为0就将当前节点设置为头结点，唤醒继任节点，返回（结束线程阻塞）。否则进行3。</li>
<li>检查线程是否该阻塞，如果应该就阻塞(park)，直到被唤醒（unpark）。重复2。</li>
<li>如果2、3有异常就抛出异常（结束线程阻塞）。</li>
</ol>
<p>这里有一点值得说明下，设置头结点并唤醒继任节点<em>setHeadAndPropagate</em>。由于前面<em>tryAcquireShared</em>总是返回1或者-1，而进入<em>setHeadAndPropagate</em>时总是<em>propagate&gt;=0</em>，所以这里<em>propagate==1</em>。后面唤醒继任节点操作就非常熟悉了。
private void setHeadAndPropagate(Node node, int propagate) {
    setHead(node);
    if (propagate &gt; 0 &amp;&amp; node.waitStatus != 0) {
        Node s = node.next;
        if (s == null || s.isShared())
            unparkSuccessor(node);
    }
}</p>
<p>从上面的所有逻辑可以看出<em>countDown</em>应该就是在条件满足（计数为0）时唤醒头结点（时间最长的一个节点），然后头结点就会根据FIFO队列唤醒整个节点列表（如果有的话）。</p>
<p>从<strong>CountDownLatch</strong>的<em>countDown</em>代码中看到，直接调用的是<strong>AQS</strong>的<em>releaseShared(1)</em>，参考前面的知识，这就印证了上面的说法。</p>
<p><strong><em>tryReleaseShared</em></strong>中正是采用CAS操作减少计数（每次减-1）。
public boolean tryReleaseShared(int releases) {
    for (;;) {
        int c = getState();
        if (c == 0)
            return false;
        int nextc = c-1;
        if (compareAndSetState(c, nextc))
            return nextc == 0;
    }
}</p>
<p>整个<strong>CountDownLatch</strong>就是这个样子的。其实有了前面原子操作和<strong>AQS</strong>的原理及实现，分析<strong>CountDownLatch</strong>还是比较容易的。</p>
<p>来源： <a href="[http://www.blogjava.net/xylz/archive/2010/07/09/325612.html](http://www.blogjava.net/xylz/archive/2010/07/09/325612.html)">[http://www.blogjava.net/xylz/archive/2010/07/09/325612.html](http://www.blogjava.net/xylz/archive/2010/07/09/325612.html)</a> </p>
<p>如果说<a href="http://www.blogjava.net/xylz/archive/2010/07/09/325612.html" target="_blank">CountDownLatch</a>是一次性的，那么<strong>CyclicBarrier</strong>正好可以循环使用。它允许一组线程互相等待，直到到达某个公共屏障点 (common barrier point)。所谓屏障点就是一组任务执行完毕的时刻。</p>
<p><strong><em>清单1 一个使用CyclicBarrier的例子</em></strong>
package xylz.study.concurrency.lock;</p>
<p>import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.CyclicBarrier;</p>
<p>public class CyclicBarrierDemo {</p>
<pre><code>final CyclicBarrier barrier;

final int MAX_TASK;

public CyclicBarrierDemo(int cnt) {
    barrier = new CyclicBarrier(cnt + 1);
    MAX_TASK = cnt;
}

public void doWork(final Runnable work) {
    new Thread() {

        public void run() {
            work.run();
            try {
                int index = barrier.await();
                doWithIndex(index);
            } catch (InterruptedException e) {
                return;
            } catch (BrokenBarrierException e) {
                return;
            }
        }
    }.start();
}

private void doWithIndex(int index) {
    if (index == MAX_TASK / 3) {
        System.out.println(&quot;Left 30%.&quot;);
    } else if (index == MAX_TASK / 2) {
        System.out.println(&quot;Left 50%&quot;);
    } else if (index == 0) {
        System.out.println(&quot;run over&quot;);
    }
}

public void waitForNext() {
    try {
        doWithIndex(barrier.await());
    } catch (InterruptedException e) {
        return;
    } catch (BrokenBarrierException e) {
        return;
    }
}

public static void main(String[] args) {
    final int count = 10;
    CyclicBarrierDemo demo = new CyclicBarrierDemo(count);
    for (int i = 0; i &lt; 100; i++) {
        demo.doWork(new Runnable() {

            public void run() {
                //do something
                try {
                    Thread.sleep(1000L);
                } catch (Exception e) {
                    return;
                }
            }
        });
        if ((i + 1) % count == 0) {
            demo.waitForNext();
        }
    }
}
</code></pre><p>}</p>
<p>清单1描述的是一个周期性处理任务的例子，在这个例子中有一对的任务（100个），希望每10个为一组进行处理，当前仅当上一组任务处理完成后才能进行下一组，另外在每一组任务中，当任务剩下50%，30%以及所有任务执行完成时向观察者发出通知。</p>
<p>在这个例子中，CyclicBarrierDemo 构建了一个count+1的任务组（其中一个任务时为了外界方便挂起主线程）。每一个子任务里，人物本身执行完毕后都需要等待同组内其它任务执行完成后才能继续。同时在剩下任务50%、30%已经0时执行特殊的其他任务（发通知）。</p>
<p>很显然CyclicBarrier有以下几个特点：</p>
<ul>
<li>await()方法将挂起线程，直到同组的其它线程执行完毕才能继续</li>
<li>await()方法返回线程执行完毕的索引，注意，索引时从任务数-1开始的，也就是第一个执行完成的任务索引为parties-1,最后一个为0，这个parties为总任务数，清单中是cnt+1</li>
<li>CyclicBarrier 是可循环的，显然名称说明了这点。在清单1中，每一组任务执行完毕就能够执行下一组任务。</li>
</ul>
<p>另外除了CyclicBarrier除了以上特点外，还有以下几个特点：</p>
<ul>
<li>如果屏障操作不依赖于挂起的线程，那么任何线程都可以执行屏障操作。在清单1中可以看到并没有指定那个线程执行50%、30%、0%的操作，而是一组线程（cnt+1）个中任何一个线程只要到达了屏障点都可以执行相应的操作</li>
<li>CyclicBarrier 的构造函数允许携带一个任务，这个任务将在0%屏障点执行，它将在await()==0后执行。</li>
<li>CyclicBarrier 如果在await时因为中断、失败、超时等原因提前离开了屏障点，那么任务组中的其他任务将立即被中断，以InterruptedException异常离开线程。</li>
<li>所有await()之前的操作都将在屏障点之前运行，也就是CyclicBarrier 的内存一致性效果</li>
</ul>
<p>CyclicBarrier 的所有API如下：</p>
<ul>
<li><em>public CyclicBarrier(int parties)</em> 创建一个新的 CyclicBarrier，它将在给定数量的参与者（线程）处于等待状态时启动，但它不会在启动 barrier 时执行预定义的操作。</li>
<li><em>public CyclicBarrier(int parties, Runnable barrierAction)</em> 创建一个新的 CyclicBarrier，它将在给定数量的参与者（线程）处于等待状态时启动，并在启动 barrier 时执行给定的屏障操作，该操作由最后一个进入 barrier 的线程执行。</li>
<li><em>public int await() throws InterruptedException, BrokenBarrierException</em> 在所有参与者都已经在此 barrier 上调用 await 方法之前，将一直等待。</li>
<li><em>public int await(long timeout,TimeUnit unit) throws InterruptedException, BrokenBarrierException,TimeoutException</em> 在所有参与者都已经在此屏障上调用 await 方法之前将一直等待,或者超出了指定的等待时间。</li>
<li><em>public int getNumberWaiting() </em>返回当前在屏障处等待的参与者数目。此方法主要用于调试和断言。</li>
<li><em>public int getParties()</em> 返回要求启动此 barrier 的参与者数目。</li>
<li><em>public boolean isBroken()</em> 查询此屏障是否处于损坏状态。</li>
<li><em>public void reset()</em> 将屏障重置为其初始状态。</li>
</ul>
<p>针对以上API，下面来探讨下CyclicBarrier 的实现原理，以及为什么有这样的API。</p>
<p><strong><em>清单2 CyclicBarrier.await/</em>()的实现片段*</strong>
    private int dowait(boolean timed, long nanos)
    throws InterruptedException, BrokenBarrierException,
           TimeoutException {
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {
        final Generation g = generation;
        if (g.broken)
            throw new BrokenBarrierException();</p>
<pre><code>    if (Thread.interrupted()) {
        breakBarrier();
        throw new InterruptedException();
    }

   int index = --count;
   if (index == 0) {  // tripped
       boolean ranAction = false;
       try {
           final Runnable command = barrierCommand;
           if (command != null)
               command.run();
           ranAction = true;
           nextGeneration();
           return 0;
       } finally {
           if (!ranAction)
               breakBarrier();
       }
   }

    // loop until tripped, broken, interrupted, or timed out
    for (;;) {
        try {
            if (!timed)
                trip.await();
            else if (nanos &gt; 0L)
                nanos = trip.awaitNanos(nanos);
        } catch (InterruptedException ie) {
            if (g == generation &amp;&amp; ! g.broken) {
                breakBarrier();
                throw ie;
            } else {
                Thread.currentThread().interrupt();
            }
        }

        if (g.broken)
            throw new BrokenBarrierException();

        if (g != generation)
            return index;

        if (timed &amp;&amp; nanos &lt;= 0L) {
            breakBarrier();
            throw new TimeoutException();
        }
    }
} finally {
    lock.unlock();
}
</code></pre><p>}</p>
<p>清单2有点复杂，这里一点一点的剖析，并且还原到最原始的状态。</p>
<p>利用前面学到的知识，我们知道要想让线程等待其他线程执行完毕，那么已经执行完毕的线程（进入await/*()方法）就需要park()，直到超时或者被中断，或者被其它线程唤醒。</p>
<p>前面说过CyclicBarrier 的特点是要么大家都正常执行完毕，要么大家都异常被中断，不会其中有一个被中断而其它正常执行完毕的现象存在。这种特点叫all-or-none。类似的概念是原子操作中的要么大家都执行完，要么一个操作都不执行完。当前这其实是两个概念了。要完成这样的特点就必须有一个状态来描述曾经是否有过线程被中断（broken)了，这样后面执行完的线程就该知道是否需要继续等待了。而在CyclicBarrier 中Generation 就是为了完成这件事情的。Generation的定义非常简单，整个结构就只有一个变量<em>boolean broken = false;，</em>定义是否发生了broken操作。</p>
<p>由于有竞争资源的存在（broken/index），所以毫无疑问需要一把锁lock。拿到锁后整个过程是这样的：</p>
<ol>
<li>检查是否存在中断位(broken)，如果存在就立即以BrokenBarrierException异常返回。此异常描述的是线程进入屏障被破坏的等待状态。否则进行2。</li>
<li>检查当前线程是否被中断，如果是那么就设置中断位（使其它将要进入等待的线程知道），另外唤醒已经等待的线程，同时以InterruptedException异常返回，表示线程要处理中断。否则进行3。</li>
<li>将剩余任务数减1，如果此时剩下的任务数为0，也就是达到了公共屏障点，那么就执行屏障点任务（如果有的话），同时创建新的Generation（在这个过程中会唤醒其它所有线程，因此当前线程是屏障点线程，那么其它线程就都应该在等待状态）。否则进行4。</li>
<li>到这里说明还没有到达屏障点，那么此时线程就应该park()。很显然在下面的for循环中就是要park线程。这里park线程采用的是Condition.await()方法。也就是trip.await/<em>()。为什么需要Condition？因为所有的await/</em>()其实等待的都是一个条件，一旦条件满足就应该都被唤醒，所以Condition整好满足这个特点。所以到这里就会明白为什么在步骤3中到达屏障点时创建新的Generation的时候是一定要唤醒其它线程的原因了。</li>
</ol>
<p>上面4个步骤其实只是描述主体结构，事实上整个过程中有非常多的逻辑来处理异常引发的问题，比如执行屏障点任务引发的异常，park线程超时引发的中断异常和超时异常等等。所以对于await()而言，异常的处理比业务逻辑的处理更复杂，这就解释了为什么await()的时候可能引发<em>InterruptedException,BrokenBarrierException,TimeoutException</em> 三种异常。</p>
<p><strong><em>清单3 生成下一个循环周期并唤醒其它线程</em></strong>
private void nextGeneration() {
     trip.signalAll();
     count = parties;
     generation = new Generation();
}</p>
<p>清单3 描述了如何生成下一个循环周期的过程，在这个过程中当然需要使用Condition.signalAll()唤醒所有已经执行完成并且正在等待的线程。另外这里count描述的是还有多少线程需要执行，是为了线程执行完毕索引计数。</p>
<p>isBroken() 方法描述的就是generation.broken，也即线程组是否发生了异常。这里再一次解释下为什么要有这个状态的存在。</p>
<p>如果一个将要位于屏障点或者已经位于屏障点的而执行屏障点任务的线程发生了异常，那么即使唤醒了其它等待的线程，其它等待的线程也会因为循环等待而“死去”，因为再也没有一个线程来唤醒这些第二次进行park的线程了。还有一个意图是，如果屏障点都已经损坏了，那么其它将要等待屏障点的再线程挂起就没有意义了。
<em><a href="http://www.imxylz.info/p/336.html" target="_blank">写到这里的时候非常不幸，用了4年多了台灯终于“寿终正寝了”。</a></em></p>
<p>其实CyclicBarrier 还有一个reset方法，描述的是手动立即将所有线程中断，恢复屏障点，进行下一组任务的执行。也就是与重新创建一个新的屏障点相比，可能维护的代价要小一些（减少同步，减少上一个CyclicBarrier 的管理等等）。</p>
<p>本来是想和Semaphore 一起将的，最后发现铺开后就有点长了，而且也不利于理解和吸收，所以放到下一篇吧。</p>
<p><strong>参考资料：</strong></p>
<ol>
<li><a href="http://blog.sina.com.cn/s/blog_5ce5700e0100e44l.html" target="_blank">使用 CyclicBarrier 做线程间同步</a></li>
<li><a href="http://spring21.javaeye.com/blog/363149" target="_blank">CyclicBarrier And CountDownLatch Tutorial</a></li>
<li><a href="http://www.blogjava.net/kissyan4916/articles/307091.html" target="_blank">线程—CyclicBarrier</a></li>
<li><a href="http://www.javaeye.com/topic/657295" target="_blank">Java线程学习笔记（十）CountDownLatch 和CyclicBarrier</a></li>
<li><a href="http://www.jspcn.net/htmlnews/11500653090781610.html" target="_blank">关于多线程同步的初步教程－－Barrier的设计及使用</a></li>
<li><a href="http://tech.puredanger.com/2007/11/11/thread-coord/" target="_blank">Thread coordination with CountDownLatch and CyclicBarrier</a></li>
<li><a href="http://flysnow.javaeye.com/blog/711162" target="_blank">如何充分利用多核CPU，计算很大的List中所有整数的和</a>
来源： <a href="[http://www.blogjava.net/xylz/archive/2010/07/12/325913.html](http://www.blogjava.net/xylz/archive/2010/07/12/325913.html)">[http://www.blogjava.net/xylz/archive/2010/07/12/325913.html](http://www.blogjava.net/xylz/archive/2010/07/12/325913.html)</a> </li>
</ol>
<p>Semaphore 是一个计数信号量。从概念上讲，信号量维护了一个许可集。如有必要，在许可可用前会阻塞每一个 </p>
<p>acquire()
，然后再获取该许可。每个 </p>
<p>release()
 添加一个许可，从而可能释放一个正在阻塞的获取者。但是，不使用实际的许可对象，</p>
<p>Semaphore
 只对可用许可的号码进行计数，并采取相应的行动。</p>
<p>说白了，Semaphore是一个计数器，在计数器不为0的时候对线程就放行，一旦达到0，那么所有请求资源的新线程都会被阻塞，包括增加请求到许可的线程，也就是说Semaphore不是可重入的。每一次请求一个许可都会导致计数器减少1，同样每次释放一个许可都会导致计数器增加1，一旦达到了0，新的许可请求线程将被挂起。</p>
<p>缓存池整好使用此思想来实现的，比如链接池、对象池等。</p>
<p><strong><em>清单1 对象池</em></strong>
package xylz.study.concurrency.lock;</p>
<p>import java.util.concurrent.Semaphore;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;</p>
<p>public class ObjectCache<T> {</p>
<pre><code>public interface ObjectFactory&lt;T&gt; {

    T makeObject();
}

class Node {

    T obj;

    Node next;
}

final int capacity;

final ObjectFactory&lt;T&gt; factory;

final Lock lock = new ReentrantLock();

final Semaphore semaphore;

private Node head;

private Node tail;

public ObjectCache(int capacity, ObjectFactory&lt;T&gt; factory) {
    this.capacity = capacity;
    this.factory = factory;
    this.semaphore = new Semaphore(this.capacity);
    this.head = null;
    this.tail = null;
}

public T getObject() throws InterruptedException {
    semaphore.acquire();
    return getNextObject();
}

private T getNextObject() {
    lock.lock();
    try {
        if (head == null) {
            return factory.makeObject();
        } else {
            Node ret = head;
            head = head.next;
            if (head == null) tail = null;
            ret.next = null;//help GC
            return ret.obj;
        }
    } finally {
        lock.unlock();
    }
}

private void returnObjectToPool(T t) {
    lock.lock();
    try {
        Node node = new Node();
        node.obj = t;
        if (tail == null) {
            head = tail = node;
        } else {
            tail.next = node;
            tail = node;
        }

    } finally {
        lock.unlock();
    }
}

public void returnObject(T t) {
    returnObjectToPool(t);
    semaphore.release();
}
</code></pre><p>}</p>
<p>清单1描述了一个基于信号量Semaphore的对象池实现。此对象池最多支持capacity个对象，这在构造函数中传入。对象池有一个基于FIFO的队列，每次从对象池的头结点开始取对象，如果头结点为空就直接构造一个新的对象返回。否则将头结点对象取出，并且头结点往后移动。特别要说明的如果对象的个数用完了，那么新的线程将被阻塞，直到有对象被返回回来。返还对象时将对象加入FIFO的尾节点并且释放一个空闲的信号量，表示对象池中增加一个可用对象。</p>
<p>实际上对象池、线程池的原理大致上就是这样的，只不过真正的对象池、线程池要处理比较复杂的逻辑，所以实现起来还需要做很多的工作，例如超时机制，自动回收机制，对象的有效期等等问题。</p>
<p>这里特别说明的是信号量只是在信号不够的时候挂起线程，但是并不能保证信号量足够的时候获取对象和返还对象是线程安全的，所以在清单1中仍然需要锁Lock来保证并发的正确性。</p>
<p>将信号量初始化为 1，使得它在使用时最多只有一个可用的许可，从而可用作一个相互排斥的锁。这通常也称为<em>二进制信号量</em>，因为它只能有两种状态：一个可用的许可，或零个可用的许可。按此方式使用时，二进制信号量具有某种属性（与很多 </p>
<p>Lock
 实现不同），即可以由线程释放“锁”，而不是由所有者（因为信号量没有所有权的概念）。在某些专门的上下文（如死锁恢复）中这会很有用。</p>
<p>上面这段话的意思是说当某个线程A持有信号量数为1的信号量时，其它线程只能等待此线程释放资源才能继续，这时候持有信号量的线程A就相当于持有了“锁”，其它线程的继续就需要这把锁，于是线程A的释放才能决定其它线程的运行，相当于扮演了“锁”的角色。</p>
<p>另外同公平锁非公平锁一样，信号量也有公平性。如果一个信号量是公平的表示线程在获取信号量时按FIFO的顺序得到许可，也就是按照请求的顺序得到释放。这里特别说明的是：所谓请求的顺序是指在请求信号量而进入FIFO队列的顺序，有可能某个线程先请求信号而后进去请求队列，那么次线程获取信号量的顺序就会晚于其后请求但是先进入请求队列的线程。这个在公平锁和非公平锁中谈过很多。</p>
<p>除了acquire以外，Semaphore还有几种类似的acquire方法，这些方法可以更好的处理中断和超时或者异步等特性，可以参考JDK API。</p>
<p>按照同样的学习原则，下面对主要的实现进行分析。Semaphore的acquire方法实际上访问的是<strong>AQS</strong>的<em>acquireSharedInterruptibly(arg)</em>方法。这个可以参考<a href="http://www.blogjava.net/xylz/archive/2010/07/09/325612.html" target="_blank"><strong>CountDownLatch</strong></a>一节或者<a href="http://www.blogjava.net/xylz/archive/2010/07/06/325390.html" target="_blank"><strong>AQS</strong></a>一节。</p>
<p>所以Semaphore的await实现也是比较简单的。与CountDownLatch不同的是，Semaphore区分公平信号和非公平信号。</p>
<p><strong><em>清单2 公平信号获取方法</em></strong>
protected int tryAcquireShared(int acquires) {
    Thread current = Thread.currentThread();
    for (;;) {
        Thread first = getFirstQueuedThread();
        if (first != null &amp;&amp; first != current)
            return -1;
        int available = getState();
        int remaining = available - acquires;
        if (remaining &lt; 0 ||
            compareAndSetState(available, remaining))
            return remaining;
    }
}</p>
<p><strong><em>清单3 非公平信号获取方法</em></strong></p>
<p>protected int tryAcquireShared(int acquires) {
    return nonfairTryAcquireShared(acquires);
}</p>
<p>final int nonfairTryAcquireShared(int acquires) {
    for (;;) {
        int available = getState();
        int remaining = available - acquires;
        if (remaining &lt; 0 ||
            compareAndSetState(available, remaining))
            return remaining;
    }
}</p>
<p>对比清单2和清单3可以看到，公平信号和非公平信号在于第一次尝试能否获取信号时，公平信号量总是将当前线程进入AQS的CLH队列进行排队（因为第一次尝试时队列的头结点线程很有可能不是当前线程，当然不排除同一个线程第二次进入信号量），从而根据AQS的CLH队列的顺序FIFO依次获取信号量；而对于非公平信号量，第一次立即尝试能否拿到信号量，一旦信号量的剩余数available大于请求数（acquires通常为1），那么线程就立即得到了释放，而不需要进行AQS队列进行排队。只有remaining&lt;0的时候（也就是信号量不够的时候）才会进入AQS队列。</p>
<p>所以非公平信号量的吞吐量总是要比公平信号量的吞吐量要大，但是需要强调的是非公平信号量和非公平锁一样存在“饥渴死”的现象，也就是说活跃线程可能总是拿到信号量，而非活跃线程可能难以拿到信号量。而对于公平信号量由于总是靠请求的线程的顺序来获取信号量，所以不存在此问题。</p>
<p> <strong>参考资料：</strong></p>
<ol>
<li><a href="http://blog.csdn.net/java2000_net/archive/2009/03/17/3997449.aspx" target="_blank">信号量(Semaphore)在生产者和消费者模式的使用</a></li>
<li><a href="http://stackoverflow.com/questions/771347/what-is-mutex-and-semaphore-in-java-what-is-the-main-difference" target="_blank">What is mutex and semaphore in Java ? What is the main difference ?</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/java/j-5things5.html" target="_blank">关于 java.util.concurrent 您不知道的 5 件事，第 2 部分</a></li>
<li><a href="http://tutorials.jenkov.com/java-concurrency/semaphores.html" target="_blank">Semahores</a></li>
</ol>
<p>来源： <a href="[http://www.blogjava.net/xylz/archive/2010/07/13/326021.html](http://www.blogjava.net/xylz/archive/2010/07/13/326021.html)">[http://www.blogjava.net/xylz/archive/2010/07/13/326021.html](http://www.blogjava.net/xylz/archive/2010/07/13/326021.html)</a></p>
<p>从这一节开始介绍锁里面的最后一个工具：读写锁(ReadWriteLock)。</p>
<p>ReentrantLock 实现了标准的互斥操作，也就是一次只能有一个线程持有锁，也即所谓独占锁的概念。前面的章节中一直在强调这个特点。显然这个特点在一定程度上面减低了吞吐量，实际上独占锁是一种保守的锁策略，在这种情况下任何“读/读”，“写/读”，“写/写”操作都不能同时发生。但是同样需要强调的一个概念是，锁是有一定的开销的，当并发比较大的时候，锁的开销就比较客观了。所以如果可能的话就尽量少用锁，非要用锁的话就尝试看能否改造为读写锁。</p>
<p>ReadWriteLock描述的是：一个资源能够被多个读线程访问，或者被一个写线程访问，但是不能同时存在读写线程。也就是说读写锁使用的场合是一个共享资源被大量读取操作，而只有少量的写操作（修改数据）。清单1描述了ReadWriteLock的API。</p>
<p> <strong><em>清单1 ReadWriteLock 接口</em></strong>
public interface ReadWriteLock {
    Lock readLock();
    Lock writeLock();
}</p>
<p>清单1描述的ReadWriteLock结构，这里需要说明的是ReadWriteLock并不是Lock的子接口，只不过ReadWriteLock借助Lock来实现读写两个视角。在ReadWriteLock中每次读取共享数据就需要读取锁，当需要修改共享数据时就需要写入锁。看起来好像是两个锁，但其实不尽然，在下一节中的分析中会解释这点奥秘。</p>
<p>在JDK 6里面ReadWriteLock的实现是ReentrantReadWriteLock。</p>
<p><strong><em>清单2 SimpleConcurrentMap</em></strong>
package xylz.study.concurrency.lock;</p>
<p>import java.util.ArrayList;
import java.util.Collection;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;</p>
<p>public class SimpleConcurrentMap<K, V> implements Map<K, V> {</p>
<pre><code>final ReadWriteLock lock = new ReentrantReadWriteLock();

final Lock r = lock.readLock();

final Lock w = lock.writeLock();

final Map&lt;K, V&gt; map;

public SimpleConcurrentMap(Map&lt;K, V&gt; map) {
    this.map = map;
    if (map == null) throw new NullPointerException();
}

public void clear() {
    w.lock();
    try {
        map.clear();
    } finally {
        w.unlock();
    }
}

public boolean containsKey(Object key) {
    r.lock();
    try {
        return map.containsKey(key);
    } finally {
        r.unlock();
    }
}

public boolean containsValue(Object value) {
    r.lock();
    try {
        return map.containsValue(value);
    } finally {
        r.unlock();
    }
}

public Set&lt;java.util.Map.Entry&lt;K, V&gt;&gt; entrySet() {
    throw new UnsupportedOperationException();
}

public V get(Object key) {
    r.lock();
    try {
        return map.get(key);
    } finally {
        r.unlock();
    }
}

public boolean isEmpty() {
    r.lock();
    try {
        return map.isEmpty();
    } finally {
        r.unlock();
    }
}

public Set&lt;K&gt; keySet() {
    r.lock();
    try {
        return new HashSet&lt;K&gt;(map.keySet());
    } finally {
        r.unlock();
    }
}

public V put(K key, V value) {
    w.lock();
    try {
        return map.put(key, value);
    } finally {
        w.unlock();
    }
}

public void putAll(Map&lt;? extends K, ? extends V&gt; m) {
    w.lock();
    try {
        map.putAll(m);
    } finally {
        w.unlock();
    }
}

public V remove(Object key) {
    w.lock();
    try {
        return map.remove(key);
    } finally {
        w.unlock();
    }
}

public int size() {
    r.lock();
    try {
        return map.size();
    } finally {
        r.unlock();
    }
}

public Collection&lt;V&gt; values() {
    r.lock();
    try {
        return new ArrayList&lt;V&gt;(map.values());
    } finally {
        r.unlock();
    }
}
</code></pre><p>}</p>
<p>清单2描述的是用读写锁实现的一个线程安全的Map。其中需要特别说明的是并没有实现entrySet()方法，这是因为实现这个方法比较复杂，在后面章节中讲到ConcurrentHashMap的时候会具体谈这些细节。另外这里keySet()和values()也没有直接返回Map的视图，而是一个映射原有元素的新视图，其实这个entrySet()一样，是为了保护原始Map的数据逻辑，防止不正确的修改导致原始Map发生数据错误。特别说明的是在没有特别需求的情况下没有必要按照清单2写一个线程安全的Map实现，因为ConcurrentHashMap已经完成了此操作。</p>
<p>ReadWriteLock需要严格区分读写操作，如果读操作使用了写入锁，那么降低读操作的吞吐量，如果写操作使用了读取锁，那么就可能发生数据错误。</p>
<p>另外ReentrantReadWriteLock还有以下几个特性：</p>
<ul>
<li><p><strong>公平性</strong></p>
</li>
<li><p>非公平锁（默认） 这个和独占锁的非公平性一样，由于读线程之间没有锁竞争，所以读操作没有公平性和非公平性，写操作时，由于写操作可能立即获取到锁，所以会推迟一个或多个读操作或者写操作。因此非公平锁的吞吐量要高于公平锁。</p>
</li>
<li>公平锁 利用AQS的CLH队列，释放当前保持的锁（读锁或者写锁）时，优先为等待时间最长的那个写线程分配写入锁，当前前提是写线程的等待时间要比所有读线程的等待时间要长。同样一个线程持有写入锁或者有一个写线程已经在等待了，那么试图获取公平锁的（非重入）所有线程（包括读写线程）都将被阻塞，直到最先的写线程释放锁。如果读线程的等待时间比写线程的等待时间还有长，那么一旦上一个写线程释放锁，这一组读线程将获取锁。</li>
<li><p><strong>重入性</strong></p>
</li>
<li><p>读写锁允许读线程和写线程按照请求锁的顺序重新获取读取锁或者写入锁。当然了只有写线程释放了锁，读线程才能获取重入锁。</p>
</li>
<li>写线程获取写入锁后可以再次获取读取锁，但是读线程获取读取锁后却不能获取写入锁。</li>
<li>另外读写锁最多支持65535个递归写入锁和65535个递归读取锁。</li>
<li><p><strong>锁降级</strong></p>
</li>
<li><p>写线程获取写入锁后可以获取读取锁，然后释放写入锁，这样就从写入锁变成了读取锁，从而实现锁降级的特性。</p>
</li>
<li><p>锁升级</p>
</li>
<li><p>读取锁是不能直接升级为写入锁的。因为获取一个写入锁需要释放所有读取锁，所以如果有两个读取锁视图获取写入锁而都不释放读取锁时就会发生死锁。</p>
</li>
<li><p><strong>锁获取中断</strong></p>
</li>
<li><p>读取锁和写入锁都支持获取锁期间被中断。这个和独占锁一致。</p>
</li>
<li><p><strong>条件变量</strong></p>
</li>
<li><p>写入锁提供了条件变量(Condition)的支持，这个和独占锁一致，但是读取锁却不允许获取条件变量，将得到一个</p>
</li>
</ul>
<p>UnsupportedOperationException
异常。</p>
<ul>
<li><p><strong>重入数</strong></p>
</li>
<li><p>读取锁和写入锁的数量最大分别只能是65535（包括重入数）。这在下节中有介绍。</p>
</li>
</ul>
<p>上面几个特性对读写锁的理解很有帮助，而且也是必要的，另外在下一节中讲ReadWriteLock的实现会用到这些知识的。
来源： <a href="[http://www.blogjava.net/xylz/archive/2010/07/14/326080.html](http://www.blogjava.net/xylz/archive/2010/07/14/326080.html)">[http://www.blogjava.net/xylz/archive/2010/07/14/326080.html](http://www.blogjava.net/xylz/archive/2010/07/14/326080.html)</a> </p>
<p>这一节主要是谈谈读写锁的实现。</p>
<p>上一节中提到，ReadWriteLock看起来有两个锁：readLock/writeLock。如果真的是两个锁的话，它们之间又是如何相互影响的呢？</p>
<p>事实上在ReentrantReadWriteLock里锁的实现是靠java.util.concurrent.locks.ReentrantReadWriteLock.Sync完成的。这个类看起来比较眼熟，实际上它是AQS的一个子类，这中类似的结构在CountDownLatch、ReentrantLock、Semaphore里面都存在。同样它也有两种实现：公平锁和非公平锁，也就是java.util.concurrent.locks.ReentrantReadWriteLock.FairSync和java.util.concurrent.locks.ReentrantReadWriteLock.NonfairSync。这里暂且不提。</p>
<p>在ReentrantReadWriteLock里面的锁主体就是一个Sync，也就是上面提到的FairSync或者NonfairSync，所以说实际上只有一个锁，只是在获取读取锁和写入锁的方式上不一样，所以前面才有读写锁是独占锁的两个不同视图一说。</p>
<p>ReentrantReadWriteLock里面有两个类：ReadLock/WriteLock，这两个类都是Lock的实现。</p>
<p><strong><em>清单1 ReadLock 片段</em></strong>
public static class ReadLock implements Lock, java.io.Serializable  {
    private final Sync sync;</p>
<pre><code>protected ReadLock(ReentrantReadWriteLock lock) {
    sync = lock.sync;
}

public void lock() {
    sync.acquireShared(1);
}

public void lockInterruptibly() throws InterruptedException {
    sync.acquireSharedInterruptibly(1);
}

public  boolean tryLock() {
    return sync.tryReadLock();
}

public boolean tryLock(long timeout, TimeUnit unit) throws InterruptedException {
    return sync.tryAcquireSharedNanos(1, unit.toNanos(timeout));
}

public  void unlock() {
    sync.releaseShared(1);
}

public Condition newCondition() {
    throw new UnsupportedOperationException();
}
</code></pre><p>}</p>
<p><strong><em>清单2 WriteLock 片段</em></strong></p>
<p>public static class WriteLock implements Lock, java.io.Serializable  {
    private final Sync sync;
    protected WriteLock(ReentrantReadWriteLock lock) {
        sync = lock.sync;
    }
    public void lock() {
        sync.acquire(1);
    }</p>
<pre><code>public void lockInterruptibly() throws InterruptedException {
    sync.acquireInterruptibly(1);
}

public boolean tryLock( ) {
    return sync.tryWriteLock();
}

public boolean tryLock(long timeout, TimeUnit unit) throws InterruptedException {
    return sync.tryAcquireNanos(1, unit.toNanos(timeout));
}

public void unlock() {
    sync.release(1);
}

public Condition newCondition() {
    return sync.newCondition();
}

public boolean isHeldByCurrentThread() {
    return sync.isHeldExclusively();
}

public int getHoldCount() {
    return sync.getWriteHoldCount();
}
</code></pre><p>}</p>
<p>清单1描述的是读锁的实现，清单2描述的是写锁的实现。显然WriteLock就是一个独占锁，这和ReentrantLock里面的实现几乎相同，都是使用了AQS的acquire/release操作。当然了在内部处理方式上与ReentrantLock还是有一点不同的。对比清单1和清单2可以看到，ReadLock获取的是共享锁，WriteLock获取的是独占锁。</p>
<p>在AQS章节中介绍到AQS中有一个state字段（int类型，32位）用来描述有多少线程获持有锁。在独占锁的时代这个值通常是0或者1（如果是重入的就是重入的次数），在共享锁的时代就是持有锁的数量。在上一节中谈到，ReadWriteLock的读、写锁是相关但是又不一致的，所以需要两个数来描述读锁（共享锁）和写锁（独占锁）的数量。显然现在一个state就不够用了。于是在ReentrantReadWrilteLock里面将这个字段一分为二，高位16位表示共享锁的数量，低位16位表示独占锁的数量（或者重入数量）。2^16-1=65536，这就是上节中提到的为什么共享锁和独占锁的数量最大只能是65535的原因了。</p>
<p>有了上面的知识后再来分析读写锁的获取和释放就容易多了。</p>
<p><strong><em>清单3 写入锁获取片段</em></strong>
protected final boolean tryAcquire(int acquires) {
    Thread current = Thread.currentThread();
    int c = getState();
    int w = exclusiveCount(c);
    if (c != 0) {
        if (w == 0 || current != getExclusiveOwnerThread())
            return false;
        if (w + exclusiveCount(acquires) &gt; MAX_COUNT)
            throw new Error(&quot;Maximum lock count exceeded&quot;);
    }
    if ((w == 0 &amp;&amp; writerShouldBlock(current)) ||
        !compareAndSetState(c, c + acquires))
        return false;
    setExclusiveOwnerThread(current);
    return true;
}</p>
<p>清单3 是写入锁获取的逻辑片段，整个工作流程是这样的：</p>
<ol>
<li>持有锁线程数非0（c=getState()不为0），如果写线程数（w）为0（那么读线程数就不为0）或者独占锁线程（持有锁的线程）不是当前线程就返回失败，或者写入锁的数量（其实是重入数）大于65535就抛出一个Error异常。否则进行2。</li>
<li>如果当且写线程数位0（那么读线程也应该为0，因为步骤1已经处理c!=0的情况），并且当前线程需要阻塞那么就返回失败；如果增加写线程数失败也返回失败。否则进行3。</li>
<li>设置独占线程（写线程）为当前线程，返回true。</li>
</ol>
<p>清单3 中 exclusiveCount(c)就是获取写线程数（包括重入数），也就是state的低16位值。另外这里有一段逻辑是当前写线程是否需要阻塞writerShouldBlock(current)。清单4 和清单5 就是公平锁和非公平锁中是否需要阻塞的片段。很显然对于非公平锁而言总是不阻塞当前线程，而对于公平锁而言如果AQS队列不为空或者当前线程不是在AQS的队列头那么就阻塞线程，直到队列前面的线程处理完锁逻辑。</p>
<p><strong><em>清单4 公平读写锁写线程是否阻塞</em></strong>
final boolean writerShouldBlock(Thread current) {
    return !isFirst(current);
}</p>
<p><strong><em>清单5 非公平读写锁写线程是否阻塞</em></strong></p>
<p>final boolean writerShouldBlock(Thread current) {
    return false;
}</p>
<p>写入锁的获取逻辑清楚后，释放锁就比较简单了。清单6 描述的写入锁释放逻辑片段，其实就是检测下剩下的写入锁数量，如果是0就将独占锁线程清空（意味着没有线程获取锁），否则就是说当前是重入锁的一次释放，所以不能将独占锁线程清空。然后将剩余线程状态数写回AQS。</p>
<p><strong><em>清单6 写入锁释放逻辑片段</em></strong>
protected final boolean tryRelease(int releases) {
    int nextc = getState() - releases;
    if (Thread.currentThread() != getExclusiveOwnerThread())
        throw new IllegalMonitorStateException();
    if (exclusiveCount(nextc) == 0) {
        setExclusiveOwnerThread(null);
        setState(nextc);
        return true;
    } else {
        setState(nextc);
        return false;
    }
}</p>
<p>清单3~6 描述的写入锁的获取释放过程。读取锁的获取和释放过程要稍微复杂些。 清单7描述的是读取锁的获取过程。</p>
<p><strong><em>清单7 读取锁获取过程片段</em></strong>
protected final int tryAcquireShared(int unused) {
    Thread current = Thread.currentThread();
    int c = getState();
    if (exclusiveCount(c) != 0 &amp;&amp;
        getExclusiveOwnerThread() != current)
        return -1;
    if (sharedCount(c) == MAX_COUNT)
        throw new Error(&quot;Maximum lock count exceeded&quot;);
    if (!readerShouldBlock(current) &amp;&amp;
        compareAndSetState(c, c + SHARED_UNIT)) {
        HoldCounter rh = cachedHoldCounter;
        if (rh == null || rh.tid != current.getId())
            cachedHoldCounter = rh = readHolds.get();
        rh.count++;
        return 1;
    }
    return fullTryAcquireShared(current);
}</p>
<p>final int fullTryAcquireShared(Thread current) {
    HoldCounter rh = cachedHoldCounter;
    if (rh == null || rh.tid != current.getId())
        rh = readHolds.get();
    for (;;) {
        int c = getState();
        int w = exclusiveCount(c);
        if ((w != 0 &amp;&amp; getExclusiveOwnerThread() != current) ||
            ((rh.count | w) == 0 &amp;&amp; readerShouldBlock(current)))
            return -1;
        if (sharedCount(c) == MAX_COUNT)
            throw new Error(&quot;Maximum lock count exceeded&quot;);
        if (compareAndSetState(c, c + SHARED_UNIT)) {
            cachedHoldCounter = rh; // cache for release
            rh.count++;
            return 1;
        }
    }
}</p>
<p>读取锁获取的过程是这样的：</p>
<ol>
<li>如果写线程持有锁（也就是独占锁数量不为0），并且独占线程不是当前线程，那么就返回失败。因为允许写入线程获取锁的同时获取读取锁。否则进行2。</li>
<li>如果读线程请求锁数量达到了65535（包括重入锁），那么就跑出一个错误Error，否则进行3。</li>
<li>如果读线程不用等待（实际上是是否需要公平锁），并且增加读取锁状态数成功，那么就返回成功，否则进行4。</li>
<li>步骤3失败的原因是CAS操作修改状态数失败，那么就需要循环不断尝试去修改状态直到成功或者锁被写入线程占有。实际上是过程3的不断尝试直到CAS计数成功或者被写入线程占有锁。</li>
</ol>
<p>在清单7 中有一个对象HoldCounter，这里暂且不提这是什么结构和为什么存在这样一个结构。</p>
<p>接下来根据清单8 我们来看如何释放一个读取锁。同样先不理HoldCounter，关键的在于for循环里面，其实就是一个不断尝试的CAS操作，直到修改状态成功。前面说过state的高16位描述的共享锁（读取锁）的数量，所以每次都需要减去2^16，这样就相当于读取锁数量减1。实际上SHARED_UNIT=1&lt;&lt;16。</p>
<p><strong><em>清单8 读取锁释放过程</em></strong>
protected final boolean tryReleaseShared(int unused) {
    HoldCounter rh = cachedHoldCounter;
    Thread current = Thread.currentThread();
    if (rh == null || rh.tid != current.getId())
        rh = readHolds.get();
    if (rh.tryDecrement() &lt;= 0)
        throw new IllegalMonitorStateException();
    for (;;) {
        int c = getState();
        int nextc = c - SHARED_UNIT;
        if (compareAndSetState(c, nextc))
            return nextc == 0;
    }
}</p>
<p>好了，现在回头看HoldCounter到底是一个什么东西。首先我们可以看到只有在获取共享锁（读取锁）的时候加1，也只有在释放共享锁的时候减1有作用，并且在释放锁的时候抛出了一个IllegalMonitorStateException异常。而我们知道IllegalMonitorStateException通常描述的是一个线程操作一个不属于自己的监视器对象的引发的异常。也就是说这里的意思是一个线程释放了一个不属于自己或者不存在的共享锁。</p>
<p>前面的章节中一再强调，对于共享锁，其实并不是锁的概念，更像是计数器的概念。一个共享锁就相对于一次计数器操作，一次获取共享锁相当于计数器加1，释放一个共享锁就相当于计数器减1。显然只有线程持有了共享锁（也就是当前线程携带一个计数器，描述自己持有多少个共享锁或者多重共享锁），才能释放一个共享锁。否则一个没有获取共享锁的线程调用一次释放操作就会导致读写锁的state（持有锁的线程数，包括重入数）错误。</p>
<p>明白了HoldCounter的作用后我们就可以猜到它的作用其实就是当前线程持有共享锁（读取锁）的数量，包括重入的数量。那么这个数量就必须和线程绑定在一起。</p>
<p>在Java里面将一个对象和线程绑定在一起，就只有ThreadLocal才能实现了。所以毫无疑问HoldCounter就应该是绑定到线程上的一个计数器。</p>
<p><strong><em>清单9 线程持有读取锁数量的计数器</em></strong>
static final class HoldCounter {
    int count;
    final long tid = Thread.currentThread().getId();
    int tryDecrement() {
        int c = count;
        if (c &gt; 0)
            count = c - 1;
        return c;
    }
}</p>
<p>static final class ThreadLocalHoldCounter
    extends ThreadLocal<HoldCounter> {
    public HoldCounter initialValue() {
        return new HoldCounter();
    }
}</p>
<p>清单9 描述的是线程持有读取锁数量的计数器。可以看到这里使用ThreadLocal将HoldCounter绑定到当前线程上，同时HoldCounter也持有线程Id，这样在释放锁的时候才能知道ReadWriteLock里面缓存的上一个读取线程（cachedHoldCounter）是否是当前线程。这样做的好处是可以减少ThreadLocal.get()的次数，因为这也是一个耗时操作。需要说明的是这样HoldCounter绑定线程id而不绑定线程对象的原因是避免HoldCounter和ThreadLocal互相绑定而GC难以释放它们（尽管GC能够智能的发现这种引用而回收它们，但是这需要一定的代价），所以其实这样做只是为了帮助GC快速回收对象而已。</p>
<p>除了readLock()和writeLock()外，Lock对象还允许tryLock()，那么ReadLock和WriteLock的tryLock()不一样。清单10 和清单11 分别描述了读取锁的tryLock()和写入锁的tryLock()。</p>
<p>读取锁tryLock()也就是tryReadLock()成功的条件是：没有写入锁或者写入锁是当前线程，并且读线程共享锁数量没有超过65535个。</p>
<p>写入锁tryLock()也就是tryWriteLock()成功的条件是: 没有写入锁或者写入锁是当前线程，并且尝试一次修改state成功。</p>
<p><strong><em>清单10 读取锁的tryLock()</em></strong>
final boolean tryReadLock() {
    Thread current = Thread.currentThread();
    for (;;) {
        int c = getState();
        if (exclusiveCount(c) != 0 &amp;&amp;
            getExclusiveOwnerThread() != current)
            return false;
        if (sharedCount(c) == MAX_COUNT)
            throw new Error(&quot;Maximum lock count exceeded&quot;);
        if (compareAndSetState(c, c + SHARED_UNIT)) {
            HoldCounter rh = cachedHoldCounter;
            if (rh == null || rh.tid != current.getId())
                cachedHoldCounter = rh = readHolds.get();
            rh.count++;
            return true;
        }
    }
}</p>
<p><strong><em>清单11 写入锁的tryLock()</em></strong></p>
<p>final boolean tryWriteLock() {
    Thread current = Thread.currentThread();
    int c = getState();
    if (c != 0) {
        int w = exclusiveCount(c);
        if (w == 0 ||current != getExclusiveOwnerThread())
            return false;
        if (w == MAX_COUNT)
            throw new Error(&quot;Maximum lock count exceeded&quot;);
    }
    if (!compareAndSetState(c, c + 1))
        return false;
    setExclusiveOwnerThread(current);
    return true;
}</p>
<p>整个读写锁的逻辑大概就这么多，其实真正研究起来也不是很复杂，真正复杂的东西都在AQS里面。</p>
<p>锁部分的原理和思想都介绍完了，下一节里面会对锁机进行小节，并对线程并发也会有一些简单的小节。
来源： <a href="[http://www.blogjava.net/xylz/archive/2010/07/15/326152.html](http://www.blogjava.net/xylz/archive/2010/07/15/326152.html)">[http://www.blogjava.net/xylz/archive/2010/07/15/326152.html](http://www.blogjava.net/xylz/archive/2010/07/15/326152.html)</a> </p>
<p>主要谈谈锁的性能以及其它一些理论知识，内容主要的出处是《<a href="http://www.amazon.com/exec/obidos/ASIN/0321349601/ref=nosim/none0b69" target="_blank">Java Concurrency in Practice</a>》，结合自己的理解和实际应用对锁机制进行一个小小的总结。</p>
<p>首先需要强调的一点是：所有锁（包括内置锁和高级锁）都是有性能消耗的，也就是说在高并发的情况下，由于锁机制带来的上下文切换、资源同步等消耗是非常可观的。在某些极端情况下，线程在锁上的消耗可能比线程本身的消耗还要多。所以如果可能的话，在任何情况下都尽量少用锁，如果不可避免那么采用非阻塞算法是一个不错的解决方案，但是却也不是绝对的。</p>
<p><strong>内部锁</strong></p>
<p>Java语言通过synchronized关键字来保证原子性。这是因为每一个Object都有一个隐含的锁，这个也称作监视器对象。在进入synchronized之前自动获取此内部锁，而一旦离开此方式（不管通过和中方式离开此方法）都会自动释放锁。显然这是一个独占锁，每个锁请求之间是互斥的。相对于前面介绍的众多高级锁（Lock/ReadWriteLock等），synchronized的代价都比后者要高。但是synchronized的语法比较简单，而且也比较容易使用和理解，不容易写法上的错误。而我们知道Lock一旦调用了lock()方法获取到锁而未正确释放的话很有可能就死锁了。所以Lock的释放操作总是跟在finally代码块里面，这在代码结构上也是一次调整和冗余。另外前面介绍中说过Lock的实现已经将硬件资源用到了极致，所以未来可优化的空间不大，除非硬件有了更高的性能。但是synchronized只是规范的一种实现，这在不同的平台不同的硬件还有很高的提升空间，未来Java在锁上的优化也会主要在这上面。</p>
<p><strong>性能</strong></p>
<p>由于锁总是带了性能影响，所以是否使用锁和使用锁的场合就变得尤为重要。如果在一个高并发的Web请求中使用了强制的独占锁，那么就可以发现Web的吞吐量将急剧下降。</p>
<p>为了利用并发来提高性能，出发点就是：更有效的利用现有的资源，同时让程序尽可能的开拓更多可用的资源。这意味着机器尽可能的处于忙碌的状态，通常意义是说CPU忙于计算，而不是等待。当然CPU要做有用的事情，而不是进行无谓的循环。当然在实践中通常会预留一些资源出来以便应急特殊情况，这在以后的线程池并发中可以看到很多例子。</p>
<p><strong>线程阻塞</strong></p>
<p>锁机制的实现通常需要操作系统提供支持，显然这会增加开销。当锁竞争的时候，失败的线程必然会发生阻塞。JVM既能自旋等待（不断尝试，知道成功，很多CAS就是这样实现的），也能够在操作系统中挂起阻塞的线程，直到超时或者被唤醒。通常情况下这取决于上下文切换的开销以及与获取锁需要等待的时间二者之间的关系。自旋等待适合于比较短的等待，而挂起线程比较适合那些比较耗时的等待。</p>
<p>挂起一个线程可能是因为无法获取到锁，或者需要某个特定的条件，或者耗时的I/O操作。挂起一个线程需要两次额外的上下文切换以及操作系统、缓存等多资源的配合：如果线程被提前换出，那么一旦拿到锁或者条件满足，那么又需要将线程换回执行队列，这对线程而言，两次上下文切换可能比较耗时。</p>
<hr>
<p><strong>锁竞争</strong></p>
<p>影响锁竞争性的条件有两个：锁被请求的频率和每次持有锁的时间。显然当而这二者都很小的时候，锁竞争不会成为主要的瓶颈。但是如果锁使用不当，导致二者都比较大，那么很有可能CPU不能有效的处理任务，任务被大量堆积。</p>
<p>所以减少锁竞争的方式有下面三种：</p>
<ol>
<li>减少锁持有的时间</li>
<li>减少锁请求的频率</li>
<li>采用共享锁取代独占锁</li>
</ol>
<p><strong>死锁</strong></p>
<p>如果一个线程永远不释放另外一个线程需要的资源那么就会导致死锁。这有两种情况：一种情况是线程A永远不释放锁，结果B一直拿不到锁，所以线程B就“死掉”了；第二种情况下，线程A拥有线程B需要的锁Y，同时线程B拥有线程A需要的锁X，那么这时候线程A/B互相依赖对方释放锁，于是二者都“死掉”了。</p>
<p>还有一种情况为发生死锁，如果一个线程总是不能被调度，那么等待此线程结果的线程可能就死锁了。这种情况叫做线程饥饿死锁。比如说在前面介绍的非公平锁中，如果某些线程非常活跃，在高并发情况下这类线程可能总是拿到锁，那么那些活跃度低的线程可能就一直拿不到锁，这样就发生了“饥饿死”。</p>
<p>避免死锁的解决方案是：尽可能的按照锁的使用规范请求锁，另外锁的请求粒度要小（不要在不需要锁的地方占用锁，锁不用了尽快释放）；在高级锁里面总是使用tryLock或者定时机制（这个以后会讲，就是指定获取锁超时的时间，如果时间到了还没有获取到锁那么就放弃）。高级锁（Lock）里面的这两种方式可以有效的避免死锁。</p>
<p><strong>活锁</strong></p>
<p>活锁描述的是线程总是尝试某项操作却总是失败的情况。这种情况下尽管线程没有被阻塞，但是人物却总是不能被执行。比如在一个死循环里面总是尝试做某件事，结果却总是失败，现在线程将永远不能跳出这个循环。另外一种情况是在一个队列中每次从队列头取出一个任务来执行，每次都失败，然后将任务放入队列头，接下来再一次从队列头取出任务执行，仍然失败。</p>
<p>还有一种活锁方式发生在“碰撞协让”情况下：两个人过独木桥，如果在半路相撞，双方礼貌退出去然后再试一次。如果总是失败，那么这两个任务将一直无法得到执行。</p>
<p><strong>总之解决锁问题的关键就是：从简单的开始，先保证正确，然后再开始优化。</strong>
<strong>来源： <a href="[http://www.blogjava.net/xylz/archive/2010/07/16/326246.html](http://www.blogjava.net/xylz/archive/2010/07/16/326246.html)">[http://www.blogjava.net/xylz/archive/2010/07/16/326246.html](http://www.blogjava.net/xylz/archive/2010/07/16/326246.html)</a> </strong></p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/Java_多线程/">Java_多线程</a></li><li><a href="/categories/Java&J2EE/Java_多线程/并发/">并发</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/Java_多线程/" class="label label-success">Java_多线程</a><a href="/tags/并发/" class="label label-info">并发</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:41"datetime="2014-03-07 09:54:41"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-Java_多线程-并发--深入浅出JavaConcurrency3-锁机制/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-Java_多线程-并发--深入浅出JavaConcurrency3-锁机制" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-java-com-wmi-监控--使用J-Interop在Java中调用WMI/">使用 J</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:41.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-java-com-wmi-监控--使用J-Interop在Java中调用WMI/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-j-interop-java-wmi">使用 J-Interop 在 Java 中调用WMI</h1>
<p><a href="http://simpleframework.net/space.html" target="_blank">我的空间</a> <img src="" alt="">|<a href="http://simpleframework.net/invite.html" target="_blank">邀请</a> |<a href="">登录</a>|<a href="http://simpleframework.net/regist.html" target="_blank">注册</a> <a href="http://simpleframework.net/" target="_blank"> </a>  简单就是最好的，java web 开发，simple 让你化繁为简 !</p>
<p><a href="http://simpleframework.net/index.html" target="_blank">首页</a><a href=""></a><a href="http://simpleframework.net/news.html">新闻资讯</a><a href=""></a><a href="http://simpleframework.net/blog.html">博客</a><a href=""></a><a href="http://simpleframework.net/bbs.html">论坛</a><a href=""></a><a href="http://simpleframework.net/market.html">Simple市场</a><a href=""></a><a href="http://simpleframework.net/doc/d2.html">全面介绍</a><a href=""></a><a href="http://demo.simpleframework.net/simple3">simple3演示</a><a href=""></a><a href="http://simple4.simpleframework.net/simple4">simple4演示</a><a href=""></a><a href="http://simpleframework.net/home.html">My Portal</a></p>
<p><img src="" alt=""><a href="http://simpleframework.net/news/v/27953.html" target="_blank">SimpleFramework开发者必读</a></p>
<p><a href="http://simpleframework.net/space/176.html" target="_blank"><img src="" alt=""></a></p>
<p><a href="http://simpleframework.net/blog/176.html" target="_blank">赵老师的博客</a></p>
<ul>
<li><a href="http://simpleframework.net/blog.html" target="_blank">全部</a></li>
<li><a href="http://simpleframework.net/blog.html?t=recommended" target="_blank">推荐</a></li>
<li><a href="http://simpleframework.net/$resource/default/login/jsp/location.jsp" target="_blank">关注</a></li>
<li><a href="http://simpleframework.net/$resource/default/login/jsp/location.jsp" target="_blank">我的博客</a></li>
</ul>
<p><a href="">关注</a> (<a href="">1</a>)</p>
<p><a href="http://simpleframework.net/blog.html" target="_blank">博客</a>»<a href="http://simpleframework.net/blog/176.html" target="_blank">赵老师</a>»显示全文</p>
<p>使用 J-Interop 在 Java 中调用WMI
5评/3355阅</p>
<p>发表于: 2011-06-16 07:12</p>
<p><strong>有关**</strong>WMI<strong>**的小知识</strong></p>
<p><a href="http://msdn.microsoft.com/en-us/library/aa394582(VS.85" target="_blank"><strong>Windows**</strong>管理规范（<strong><strong>WMI</strong></strong>）**</a>.aspx)是微软对来自<a href="http://en.wikipedia.org/wiki/Distributed_Management_Task_Force" title="Distributed Management Task Force" target="_blank">分布式管理任务组</a>（<strong>DMTF</strong>）的<a href="http://en.wikipedia.org/wiki/Web-Based_Enterprise_Management" title="Web-Based Enterprise Management" target="_blank">基于Web的企业管理</a>（WBEM）和<a href="http://en.wikipedia.org/wiki/Common_Information_Model_(computing" target="_blank">通用信息模型</a> &quot;Common Information Model (computing)&quot;)（CIM）标准的实现。WMI用于访问Windows系统、应用、网络、设备等组件，并管理它们。连接到一台机器通过<strong>DCOM</strong>进行管理。因此，有关<strong>DCOM</strong>的小知识将有助于本文的理解。你可以到MSDN了解有关WMI的更多细节。</p>
<h3 id="-j-interop-"><strong>J-Interop</strong></h3>
<p>市场上有一些在使用 JAVA 调用 WMI 的好库，包括 <a href="http://www.j-interop.org/index.html" target="_blank">J-Interop</a>、<a href="http://sourceforge.net/projects/jacob-project/" target="_blank">JACOB-Project</a> 和 <a href="http://j-integra.intrinsyc.com/products/com/" target="_blank">J-Integra</a>。其中，我更喜欢J-Interop，因为它是完全免费和开源的API。它提供了没有任何依赖的纯DCOM桥，完全用Java编写的没有任何JNI代码。</p>
<h3 id="-wmi-windows-"><strong>使用**</strong>WMI<strong><strong>管理</strong></strong>Windows<strong>**服务</strong></h3>
<p>现在，来看一个使用JAVA调用WMI的例子。这个例子利用J-Interop的API使用Win32_Service类解释WMI操作，将启动和停止在这个例子中的窗口服务。</p>
<h3 id="-1-wbem-"><strong>步骤**</strong>1<strong><strong>：连接到</strong></strong>WBEM<strong>**服务</strong></h3>
<p>下面的代码示例显示了使用J-Interop如何初始化DCOM会话，并连接到远程DCOM服务使。它使用SWbemLocator对象连接到<strong>SWbemServices</strong>，<strong>SWbemServices</strong>对象提供对本地或远程计算机WMI的访问，它调用“ConnectServer”方法连接到<strong>SWbemServices**</strong>。在本例中，<em>提供管理员级别的用户连接到远程计算机。**</em>
JISessiondcomSession=JISession.createSession(domainName,userName,password); dcomSession.useSessionSecurity(false);   JIComServercomServer=newJIComServer(valueOf(&quot;WbemScripting.SWbemLocator&quot;),hostIP,dcomSession); IJIDispatchwbemLocator=(IJIDispatch)narrowObject(comServer.createInstance().queryInterface(IID)); //parameterstoconnecttoWbemScripting.SWbemLocator Object[]params=newObject[]{                           newJIString(hostIP),//strServer                           newJIString(win32_namespace),//strNamespace                           JIVariant.OPTIONAL_PARAM(),//strUser                           JIVariant.OPTIONAL_PARAM(),//strPassword                           JIVariant.OPTIONAL_PARAM(),//strLocale                           JIVariant.OPTIONAL_PARAM(),//strAuthority                           newInteger(0),//iSecurityFlags                           JIVariant.OPTIONAL_PARAM()//objwbemNamedValueSet                           };   JIVariantresults[]=wbemLocator.callMethodA(&quot;ConnectServer&quot;,params); IJIDispatchwbemServices=(IJIDispatch)narrowObject(results[0].getObjectAsComObject());</p>
<p>（<strong>domainName</strong>=远程计算机域名，<strong>hostIP</strong>=远程计算机IP地址,<strong>用户名</strong>=管理员级别的用户，<strong>密码</strong>=密码）</p>
<h3 id="-2-win32_service-"><strong>第**</strong>2<strong><strong>步：获取</strong></strong>Win32_Service<strong>**实例</strong></h3>
<p>一旦你获得对<strong>SWbemServices</strong>对象的引用，就可以调用这个类的任何方法。其中<strong>WbemServices.InstancesOf**</strong>方法获得任何<strong><strong>Win32</strong></strong>类的实例。**</p>
<p>也可以使用WMI查询语言(WQL)达到同样的目的，如下所示：
finalintRETURN_IMMEDIATE=0x10; finalintFORWARD_ONLY=0x20; Object[]params=newObject[]{ newJIString(&quot;SELECT/*FROMWin32_Service&quot;), JIVariant.OPTIONAL_PARAM(), newJIVariant(newInteger(RETURN_IMMEDIATE+FORWARD_ONLY)) }; JIVariant[]servicesSet=wbemServices.callMethodA(&quot;ExecQuery&quot;,params); IJIDispatchwbemObjectSet=(IJIDispatch)narrowObject(servicesSet[0].getObjectAsComObject());</p>
<h3 id="-"><strong>第三步：执行方法</strong></h3>
<p>现在，已得到<strong>Win32_Service</strong>类的实例，可采用下述代码来调用同一类的方法，因为，它返回多个服务实例，要列举它们以便获取IJIDispatcher服务。
JIVariant newEnumvariant = wbemObjectSet.get(&quot;_NewEnum&quot;); IJIComObject enumComObject = newEnumvariant.getObjectAsComObject(); IJIEnumVariant enumVariant = (IJIEnumVariant) narrowObject(enumComObject.queryInterface(IJIEnumVariant.IID));   Object[] elements = enumVariant.next(1); JIArray aJIArray = (JIArray) elements[0];   JIVariant[] array = (JIVariant[]) aJIArray.getArrayInstance(); for (JIVariant variant : array) {     IJIDispatch wbemObjectDispatch = (IJIDispatch) narrowObject(variant.getObjectAsComObject());       JIVariant returnStatus = wbemObjectDispatch.callMethodA(&quot;StopService&quot;);       System.out.println(returnStatus.getObjectAsInt()); }</p>
<p>现在，下面的代码显示了一个使用WMI启动和停止Windows服务的完整Java类。</p>
<p>packagecom.wmi.windows;   importstaticorg.jinterop.dcom.core.JIProgId.valueOf; importstaticorg.jinterop.dcom.impls.JIObjectFactory.narrowObject; importstaticorg.jinterop.dcom.impls.automation.IJIDispatch.IID; importjava.util.logging.Level; importorg.jinterop.dcom.common.JIException; importorg.jinterop.dcom.common.JIRuntimeException; importorg.jinterop.dcom.common.JISystem; importorg.jinterop.dcom.core.IJIComObject; importorg.jinterop.dcom.core.JIArray; importorg.jinterop.dcom.core.JIComServer; importorg.jinterop.dcom.core.JISession; importorg.jinterop.dcom.core.JIString; importorg.jinterop.dcom.core.JIVariant; importorg.jinterop.dcom.impls.automation.IJIDispatch; importorg.jinterop.dcom.impls.automation.IJIEnumVariant;   publicclassServiceManager{            privatestaticStringdomainName=&quot;&quot;;          privatestaticStringuserName=&quot;administrator&quot;;          privatestaticStringpassword=&quot;&quot;;          privatestaticStringhostIP=&quot;127.0.0.1&quot;;          privatestaticfinalStringwin32<em>namespace=&quot;ROOT\CIMV2&quot;;            privatestaticfinalintSTOP_SERVICE=0;          privatestaticfinalintSTART_SERVICE=1;            privateJISessiondcomSession=null;          //<em>/</em>          /<em>          /</em>@paramargs          /<em>/          publicstaticvoidmain(String[]args){                  ServiceManagermanager=newServiceManager();                   manager.stopService(domainName,hostIP,userName,password,&quot;MySql&quot;);//stopsaservicenamedMySql          }          //</em>/<em>          /</em>Startsagivenserviceifitsstopped.          /<em>          /</em>@paramdomainName          /<em>@paramhostname          /</em>@paramusername          /<em>@parampassword          /</em>@paramserviceName          /<em>/    publicvoidstartService(StringdomainName,Stringhostname,Stringusername,Stringpassword,StringserviceName){                  execute(domainName,hostname,username,password,serviceName,START_SERVICE);          }          //</em>/<em>          /</em>Stopsagivenserviceifitsrunning.          /<em>          /</em>@paramdomainName          /<em>@paramhostname          /</em>@paramusername          /<em>@parampassword          /</em>@paramserviceName          /<em>/     publicvoidstopService(StringdomainName,Stringhostname,Stringusername,Stringpassword,StringserviceName){                  execute(domainName,hostname,username,password,serviceName,STOP_SERVICE);          }          //</em>/<em>          /</em>Starts/Stopsagivenserviceofremotemachineashostname.          /<em>          /</em>@paramdomainName          /<em>@paramhostname          /</em>@paramusername          /<em>@parampassword          /</em>@paramserviceName          /<em>@paramaction          /</em>/ publicvoidexecute(StringdomainName,Stringhostname,Stringusername,Stringpassword,StringserviceName,intaction){                    try{                           IJIDispatchwbemServices=createCOMServer();                             finalintRETURN_IMMEDIATE=0x10;                           finalintFORWARD_ONLY=0x20;                           Object[]params=newObject[]{                                             newJIString(&quot;SELECT/*FROMWin32_ServiceWHEREName=&#39;&quot;+serviceName+&quot;&#39;&quot;),                                             JIVariant.OPTIONAL_PARAM(),                                             newJIVariant(newInteger(RETURN_IMMEDIATE+FORWARD_ONLY))                           };                           JIVariant[]servicesSet=wbemServices.callMethodA(&quot;ExecQuery&quot;,params);                           IJIDispatchwbemObjectSet=(IJIDispatch)narrowObject(servicesSet[0].getObjectAsComObject());                             JIVariantnewEnumvariant=wbemObjectSet.get(&quot;_NewEnum&quot;);                           IJIComObjectenumComObject=newEnumvariant.getObjectAsComObject();                    IJIEnumVariantenumVariant=(IJIEnumVariant)narrowObject(enumComObject.queryInterface(IJIEnumVariant.IID));                             Object[]elements=enumVariant.next(1);                           JIArrayaJIArray=(JIArray)elements[0];                             JIVariant[]array=(JIVariant[])aJIArray.getArrayInstance();                           for(JIVariantvariant:array){                                    IJIDispatchwbemObjectDispatch=(IJIDispatch)narrowObject(variant.getObjectAsComObject());                                      //Printobjectastext.                                    JIVariant[]v=wbemObjectDispatch.callMethodA(&quot;GetObjectText</em>&quot;,newObject[]{1});                                    System.out.println(v[0].getObjectAsString().getString());                                      //StartorStoptheservice                                    StringmethodToInvoke=(action==START_SERVICE)?&quot;StartService&quot;:&quot;StopService&quot;;                                    JIVariantreturnStatus=wbemObjectDispatch.callMethodA(methodToInvoke);                           System.out.println(&quot;Returnstatus:&quot;+returnStatus.getObjectAsInt());//ifreturncode=0success.Seemsdnformoredetailsaboutthemethod.                           }                  }catch(Exceptione){                           e.printStackTrace();                  }finally{                           if(dcomSession!=null){                                    try{                                             JISession.destroySession(dcomSession);                                    }catch(Exceptionex){                                             ex.printStackTrace();                                    }                           }                  }          }          //<em>/</em>          /<em>InitializeDCOMsessionandconnecttoSWBEMserviceongivenhostmachine.          /</em>@return          /*/          privateIJIDispatchcreateCOMServer(){                  JIComServercomServer;                  try{                           JISystem.getLogger().setLevel(Level.WARNING);                           JISystem.setAutoRegisteration(true);                           dcomSession=JISession.createSession(domainName,userName,password);                           dcomSession.useSessionSecurity(false);                           comServer=newJIComServer(valueOf(&quot;WbemScripting.SWbemLocator&quot;),hostIP,dcomSession);                             IJIDispatchwbemLocator=(IJIDispatch)narrowObject(comServer.createInstance().queryInterface(IID));                           //parameterstoconnecttoWbemScripting.SWbemLocator                           Object[]params=newObject[]{                                             newJIString(hostIP),//strServer                                             newJIString(win32_namespace),//strNamespace                                             JIVariant.OPTIONAL_PARAM(),//strUser                                             JIVariant.OPTIONAL_PARAM(),//strPassword                                             JIVariant.OPTIONAL_PARAM(),//strLocale                                             JIVariant.OPTIONAL_PARAM(),//strAuthority                                             newInteger(0),//iSecurityFlags                                             JIVariant.OPTIONAL_PARAM()//objwbemNamedValueSet                           };                           JIVariantresults[]=wbemLocator.callMethodA(&quot;ConnectServer&quot;,params);                           IJIDispatchwbemServices=(IJIDispatch)narrowObject(results[0].getObjectAsComObject());                           returnwbemServices;                  }catch(JIExceptionjie){                           System.out.println(jie.getMessage());                           jie.printStackTrace();                  }catch(JIRuntimeExceptionjire){                           jire.printStackTrace();                  }catch(Exceptione){                           e.printStackTrace();                  }finally{                           if(dcomSession!=null){                                    try{                                             JISession.destroySession(dcomSession);                                    }catch(JIExceptione){                                             e.printStackTrace();                                    }                           }                  }                  returnnull;          } }</p>
<p>【原文】<a href="http://nikunjp.wordpress.com/" target="_blank"><a href="http://nikunjp.wordpress.com/">http://nikunjp.wordpress.com/</a></a>
评论 (共 5 条评论)</p>
<p>匿名 (219.142.23.106), 475天前</p>
<p>j-interop 远程收集WIN7 的eventlog日志怎么不行啊，求助赵老师
<a href="">回复</a>|<a href="">支持</a>|<a href="">反对</a>
匿名 (219.142.23.106), 475天前</p>
<p>是啊，win7怎么不行呢。。
<a href="">回复</a>|<a href="">支持</a>|<a href="">反对</a></p>
<p>匿名 (59.40.119.215), 497天前</p>
<p>xp的开始Remote Register 服务就可以了。 win7还在研究中
<a href="">回复</a>|<a href="">支持</a>|<a href="">反对</a>
匿名 (219.133.0.1), 501天前</p>
<p>win7平台为什么会用不了呢？ 我也测试过了，xp的机器可以成功运行。
有些xp的也不行，我觉得可能是有什么配置项没有配置而导致。
<a href="">回复</a>|<a href="">支持</a>|<a href="">反对</a></p>
<p>匿名 (111.4.219.247), 722天前</p>
<p>我测试报错：The system cannot find the file specified. win7平台。
<a href="">回复</a>|<a href="">支持</a>|<a href="">反对</a> (共5, 显示全部)/</p>
<p><a href="">表情</a> 发表评论</p>
<p><img src="" alt=""></p>
<p><a href="">看不清楚，再换一张</a> <a href="">高级模式</a></p>
<p>相关主题</p>
<p><a href="http://simpleframework.net/blog/v/32903.html" target="_blank">JAVA问题定位技术</a> 2/3333</p>
<p><a href="http://simpleframework.net/space/26397.html" target="_blank">sword</a>, 799天前</p>
<p><a href="http://simpleframework.net/blog/v/18467.html" target="_blank">Java序列化和克隆</a> 0/1568</p>
<p><a href="http://simpleframework.net/space/534.html" target="_blank">书生</a>, 870天前
<a href="http://simpleframework.net/blog/v/46888.html" target="_blank">Java EE6中的装饰器，高级用法</a> 0/1163</p>
<p><a href="http://simpleframework.net/space/176.html" target="_blank">赵老师</a>, 733天前</p>
<p><a href="http://simpleframework.net/blog/v/16596.html" target="_blank">通过 Java 编程处理 XML 服务定义</a> 1/1691</p>
<p><a href="http://simpleframework.net/space/534.html" target="_blank">书生</a>, 877天前
<a href="http://simpleframework.net/blog/v/34389.html" target="_blank">解析Java软件开发中的五种认识误区</a> 0/1178</p>
<p><a href="http://simpleframework.net/space/534.html" target="_blank">书生</a>, 792天前</p>
<p><a href="http://simpleframework.net/blog/v/23210.html" target="_blank">Java内省和反射机制三步曲之(2)反射</a> 0/1409</p>
<p><a href="http://simpleframework.net/space/534.html" target="_blank">书生</a>, 854天前</p>
<p>一周点击排行
<a href="http://simpleframework.net/guestbook.html" target="_blank">留言</a>|<a href="http://simpleframework.net/contact.html" target="_blank">联系我们</a>|<a href="http://simpleframework.net/copyright.html" target="_blank">版权声明</a>|<a href="http://simpleframework.net/about.html" target="_blank">关于</a></p>
<p>simpleframework.net Copyright ©2011 版权所有</p>
<p>Powered by SimpleFramework [ 0.156 s ]</p>
<p>*</p>
<ul>
<li>数据装载中...
*</li>
</ul>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/java-com/">java-com</a></li><li><a href="/categories/Java&J2EE/java-com/wmi-监控/">wmi-监控</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/java-com/" class="label label-success">java-com</a><a href="/tags/wmi-监控/" class="label label-info">wmi-监控</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:41"datetime="2014-03-07 09:54:41"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-java-com-wmi-监控--使用J-Interop在Java中调用WMI/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-java-com-wmi-监控--使用J-Interop在Java中调用WMI" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE--JSTL标签参考手册/">JSTL标签 参考手册</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:41.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE--JSTL标签参考手册/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="jstl-">JSTL标签 参考手册</h1>
<h3 id="-jstl-http-elf8848-iteye-com-blog-245559-"><a href="http://elf8848.iteye.com/blog/245559" target="_blank">JSTL标签 参考手册</a>**</h3>
<p><strong>博客分类：</strong> </p>
<ul>
<li><a href="http://elf8848.iteye.com/category/123165" target="_blank">Servlet/Jsp</a></li>
</ul>
<p><strong>前言</strong></p>
<p>=========================================================================</p>
<p>JSLT标签库，是日常开发经常使用的，也是众多标签中性能最好的。把常用的内容，放在这里备份一份，随用随查。尽量做到不用查，就可以随手就可以写出来。这算是Java程序员的基本功吧，一定要扎实。</p>
<p>JSTL全名为JavaServer Pages Standard Tag Library，目前最新的版本为1.1版。JSTL是由JCP(Java Community Process)所制定的标准规范，它主要提供给Java Web开发人员一个标准通用的标签函数库。
Web程序员能够利用JSTL和EL来开发Web程序，取代传统直接在页面上嵌入Java程序(Scripting)的做法，以提高程序的阅读性、维护性和方便性。
JSTL 1.1必须在支持Servlet 2.4且JSP 2.0以上版本的Container才可使用</p>
<p><strong>&lt;%@ taglib %&gt;引入标签库</strong></p>
<p>=========================================================================</p>
<p>1、以classPath中，加入jar包：  standard-1.1.2.jar ，  jstl-1.1.2.jar</p>
<p>2、在相目\WEB-INF\tld\文件夹中放入常用的tld文件：c.tld，fmt.tld</p>
<p>3、在jsp文件的顶部加入以下内容：
Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"></a></p>
<ol>
<li>&lt;%@ taglib uri=&quot;<a href="http://java.sun.com/jsp/jstl/core" target="_blank">http://java.sun.com/jsp/jstl/core</a>&quot; prefix=&quot;c&quot; %&gt;   </li>
<li>&lt;%@ taglib uri=&quot;<a href="http://java.sun.com/jsp/jstl/fmt" target="_blank">http://java.sun.com/jsp/jstl/fmt</a>&quot; prefix=&quot;fmt&quot;%&gt;  </li>
<li>&lt;%@ taglib uri=&quot;<a href="http://java.sun.com/jsp/jstl/functions" target="_blank">http://java.sun.com/jsp/jstl/functions</a>&quot; prefix=&quot;fn&quot; %&gt;  </li>
</ol>
<p><strong><c:> **</strong>核心标签库 **</p>
<p>==========================================================================</p>
<p>JSTL 核心标签库(C标签)标签共有13个，功能上分为4类：
1.表达式控制标签：out、set、remove、catch
2.流程控制标签：if、choose、when、otherwise
3.循环标签：forEach、forTokens
4.URL操作标签：import、url、redirect</p>
<p><strong><c:forEach> **</strong>标签**</p>
<hr>
<p>为循环控制，它可以将集合(Collection)中的成员循序浏览一遍。</p>
<p><strong> <c:forEach> 标签的语法</strong> <strong>说明</strong> <strong>：</strong></p>
<p>语法1：迭代一集合对象之所有成员
Html代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"></a></p>
<ol>
<li><c:forEach [var="varName"] items="collection" [varStatus="varStatusName"] [begin="begin"] [end="end"] [step="step"]>  </li>
<li>本体内容  </li>
<li></c:forEach>  </li>
</ol>
<p>语法2：迭代指定的次数</p>
<p>Html代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"></a></p>
<ol>
<li><c:forEach [var="varName"] [varStatus="varStatusName"] begin="begin" end="end" [step="step"]>  </li>
<li>本体内容  </li>
<li></c:forEach>  </li>
</ol>
<p><strong><c:forEach> 标签的</strong> <strong>属性说明</strong> <strong>：</strong></p>
<p><img src="&quot;点击查看原始大小图片&quot;" alt=""></p>
<p><strong><c:forEach> 标签的</strong> <strong>属性 ：</strong> varStatus属性： 它的提供另外四个属性:index,count,fist和last，它们个自的意义如下:
Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"></a></p>
<ol>
<li>属性                   类型                                  意义  </li>
<li>index                  number                    现在指到成员的索引  </li>
<li>count                  number                    总共指到成员的总和  </li>
<li>first                  boolean                   现在指到成员是否为第一个  </li>
<li>last                   boolean                   现在指到成员是否为最后一个   </li>
</ol>
<p><strong> <c:forEach> 遍历 List列表：</strong></p>
<p> 对于一个基本类型的数组，当前元素将作为相应包装类（Integer、Float等等）的一个实例提供。
Html代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"></a></p>
<ol>
<li><c:forEach items="${domainList }" var="item">  </li>
<li><tr>  </li>
<li><td align="center" valign="middle">${item[&quot;domain&quot;]==null?&quot;&nbsp;&quot;:item[&quot;domain&quot;]}</td>  </li>
<li><td align="center" valign="middle"><fmt:formatDate value="${item['bind_date']}" pattern="yyyy-MM-dd HH:mm:ss"/></td>  </li>
<li><td align="center" valign="middle">  </li>
<li><c:if test="${item['domain']!=null}">  </li>
<li><a href="javascript:;" id="${item['domain']}" class="del">&nbsp;</a>  </li>
<li></c:if>  </li>
<li></td>  </li>
<li></tr>    </li>
<li></c:forEach>  </li>
</ol>
<p><strong> <c:forEach> 遍历Map:</strong></p>
<p> 对于一个java.util.Map，当前元素则作为一个java.util.Map.Entry提供。
Html代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"></a></p>
<ol>
<li><c:if test="${!empty permissionMap}">    </li>
<li><c:forEach items="${permissionMap}" var="item">  </li>
<li><tr>  </li>
<li><td>${item.value.id}</td>  </li>
<li><td>${item.value.urlOnClass}</td>  </li>
<li><td>${item.value.urlOnMethod}</td>  </li>
<li></tr>  </li>
<li></c:forEach>  </li>
<li></c:if>    </li>
</ol>
<p><strong><c:forTokens> **</strong>标签**</p>
<hr>
<p>用来浏览一字符串中所有的成员，其成员是由定义符号(delimiters)所分隔的。</p>
<p><strong> <c:forTokens> 标签的语法</strong> <strong>说明</strong> <strong>：</strong>
Html代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"></a></p>
<ol>
<li>&lt;c:forTokens items=&quot;stringOfTokens&quot; delims=&quot;delimiters&quot; [var=&quot;varName&quot;]  </li>
<li>[varStatus=&quot;varStatusName&quot;] [begin=&quot;begin&quot;] [end=&quot;end&quot;] [step=&quot;step&quot;]&gt;  </li>
<li>本体内容  </li>
<li></c:forTokens>  </li>
</ol>
<p><strong><c:forTokens> 标签的</strong> <strong>属性说明</strong> <strong>：</strong></p>
<p><img src="" alt=""></p>
<p><strong><c:out> **</strong>标签**</p>
<hr>
<p>主要用来显示数据的内容</p>
<p><strong> <c:out> 标签的语法</strong> <strong>说明</strong> <strong>：</strong></p>
<p>语法1：没有本体(body)内容
Html代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"></a></p>
<ol>
<li><c:out value="value" [escapeXml="{true|false}"] [default="defaultValue"] />  


</li>
</ol>
<p>语法2：有本体内容</p>
<p>Html代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"></a></p>
<ol>
<li><c:out value="value" [escapeXml="{true|false}"]>  </li>
<li>default value  </li>
<li></c:out>  </li>
</ol>
<p><strong><c:forEach> 标签的</strong> <strong>属性说明</strong> <strong>：</strong> 略</p>
<p>一般来说，<c:out>默认会将&lt;、&gt;、’、” 和 &amp; 转换为 &lt;、&gt;、&amp;/#039;、&amp;/#034; 和&amp;。假若不想转换时，只需要设定<c:out>的escapeXml属性为fasle就可以了。</p>
<p><strong><c:set> **</strong>标签**</p>
<hr>
<p>主要用来将变量储存至JSP范围中或是JavaBean的属性中。</p>
<p><strong> <c:set> 标签的语法</strong> <strong>说明</strong> <strong>：</strong></p>
<p>语法1：将value的值储存至范围为scope的 varName 变量之中
Html代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"></a></p>
<ol>
<li><c:set value="value" var="varName" [scope="{ page|request|session|application }"]/>  


</li>
</ol>
<p>语法2：将本体内容的数据储存至范围为scope的 varName 变量之中</p>
<p>Html代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"></a></p>
<ol>
<li><c:set var="varName" [scope="{ page|request|session|application }"]>  </li>
<li>… 本体内容  </li>
<li></c:set>  </li>
</ol>
<p>语法3：将 value的值储存至 target 对象的属性中
Html代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"></a></p>
<ol>
<li><c:set value="value" target="target" property="propertyName" />  


</li>
</ol>
<p>语法4：将本体内容的数据储存至target 对象的属性中</p>
<p>Html代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"></a></p>
<ol>
<li><c:set target="target" property="propertyName">  </li>
<li>… 本体内容  </li>
<li></c:set>  </li>
</ol>
<p><strong><c:set> 标签的</strong> <strong>属性说明</strong> <strong>：</strong></p>
<p><img src="&quot;点击查看原始大小图片&quot;" alt=""></p>
<p><strong><c:remove> **</strong>标签**</p>
<hr>
<p>主要用来移除变量。</p>
<p><strong> <c:remove> 标签的语法</strong> <strong>说明</strong> <strong>：</strong>
Html代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"></a></p>
<ol>
<li><c:remove var="varName" [scope="{ age|request|session|application }"] />  



</li>
</ol>
<p><strong><c:catch> **</strong>标签**</p>
<hr>
<p>主要用来处理产生错误的异常状况，并且将错误信息储存起来。</p>
<p><strong> <c:catch> 标签的语法</strong> <strong>说明</strong> <strong>：</strong>
Html代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"></a></p>
<ol>
<li><c:catch [var="varName"] >  </li>
<li>… 欲抓取错误的部分  </li>
<li></c:catch>  </li>
</ol>
<p><strong><c:if> **</strong>标签**</p>
<hr>
<p>的用途就和我们一般在程序中用的if一样。</p>
<p><strong> <c:if> 标签的语法</strong> <strong>说明</strong> <strong>：</strong></p>
<p>语法1：没有本体内容(body)
Html代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"></a></p>
<ol>
<li><c:if test="testCondition" var="varName" [scope="{page|request|session|application}"]/>  



</li>
</ol>
<p>语法2：有本体内容
Html代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"></a></p>
<ol>
<li><c:if test="testCondition" [var="varName"] [scope="{page|request|session|application}"]>  </li>
<li>本体内容  </li>
<li></c:if>  </li>
</ol>
<p>示例：</p>
<p>Html代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"></a></p>
<ol>
<li><c:if test="${not empty item.publish_time}">  </li>
<li>内容  </li>
<li></c:if>  </li>
<li></li>
<li><c:if test="${item['domain']!=null}">  </li>
<li>内容  </li>
<li></c:if>  </li>
<li></li>
<li><c:if test="${!empty permissionMap}">   </li>
<li>内容  </li>
<li></c:if>  </li>
</ol>
<p><strong>c:choose&gt; <c:when> <c:otherwise>  </strong> <strong>标签</strong></p>
<hr>
<p><strong> <c:choose when otherwise> 标签的语法</strong> <strong>说明</strong> <strong>：</strong>
Html代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"></a></p>
<ol>
<li><c:set var="score">85</c:set>  </li>
<li><c:choose>  </li>
<li><c:when test="${score>=90}">  </li>
<li>你的成绩为优秀！  </li>
<li></c:when>  </li>
<li><c:when test="${score>=70&&score<90}">  </li>
<li>您的成绩为良好!  </li>
<li></c:when>  </li>
<li><c:when test="${score>60&&score<70}">  </li>
<li>您的成绩为及格  </li>
<li></c:when>  </li>
<li><c:otherwise>  </li>
<li>对不起，您没有通过考试！  </li>
<li></c:otherwise>  </li>
<li></c:choose>  </li>
</ol>
<p><strong><fmt:>  </strong> <strong>格式 化标签库 </strong></p>
<p>==========================================================================</p>
<p>一：JSTL格式化标签又称为I18N标签库，主要用来编写国际化的WEB应用，使用此功能可以对一个特定的语言请求做出合适的处理。</p>
<p>例如：中国内地用户将显示简体中文，台湾地区则显示繁体中文，使用I18N格式化标签库还可以格式化数字和日期，例如同一数字或日趋，在不同国家可能有不同的格式，使用I18N格式标签库可以将数字和日期格式为当地的格式。
在JSP页面中要使用到格式化标签，需要引入下面的语句：
&lt;%@ taglib uri=&quot;<a href="http://java.sun.com/jsp/jstl/fmt" target="_blank">http://java.sun.com/jsp/jstl/fmt</a>&quot; prefix=&quot;fmt&quot;% &gt;
<strong>二：概览</strong></p>
<hr>
<pre><code>格式化标签
&lt;fmt:fromatNumber&gt;
&lt;fmt:formatDate&gt;
&lt;fmt:parseDate&gt;
&lt;fmt:parseNumber&gt;
&lt;fmt:setTimeZone&gt;
&lt;fmt:timeZone&gt;
国际化标签
&lt;fmt:setLocale&gt;
&lt;fmt:requestEncoding&gt;
&lt;fmt:bundle&gt;
&lt;fmt:message&gt;
&lt;fmt:param&gt;
&lt;fmt:setBundle&gt;
</code></pre><p><strong>三：<fmt:formatNumber></strong></p>
<hr>
<pre><code>此标签会根据区域定制的方式将数字格式化成数字，货币，百分比。
此标签的属性：
value:要格式化的数字
type：按照什么类型格式化
pattern：自定义格式化样式
currencyCode:ISO-4721货币代码，只适用于按照货币格式化的数字
currencySymbol： 货币符号,如￥,只适用于按照货币格式化的数字
groupingUsed： 是否包含分隔符
maxIntegerDigits： 整数部分最多显示多少位
mixIntegerDigits： 整数部分最少显示多少位
maxFractionDigits： 小数部分最多显示多位位
minFractionDigits： 小数部分最少显示多位位
var:存储格式化后的结果
scope: 存储的范围
示例1：    
</code></pre><p>Java代码 
&lt;%@ page language=&quot;java&quot; pageEncoding=&quot;utf-8&quot;%&gt;<br>&lt;%@ taglib uri=&quot;<a href="http://java.sun.com/jsp/jstl/core" target="_blank">http://java.sun.com/jsp/jstl/core</a>&quot; prefix=&quot;c&quot;%&gt;<br>&lt;%@ taglib uri=&quot;<a href="http://java.sun.com/jsp/jstl/fmt" target="_blank">http://java.sun.com/jsp/jstl/fmt</a>&quot; prefix=&quot;fmt&quot; %&gt;<br>&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;   </p>
<html><br>    <head><br>        <title>chapter4.jsp</title><br>    </head><br>    <body><br>        <div><br>            <div><br>                <fmt:setLocale value="fr_fr"/><br>                <fmt:formatNumber value="123456789.012"/><br>                <br/><br>                <fmt:setLocale value="zh_cn"/><br>                <fmt:formatNumber value="123456789.012"/><br>                <br /><br>                <fmt:setLocale value="de_de"/><br>                <fmt:formatNumber value="123456789.012"/><br>                <br /><br>            </div><br>        </div><br>    </body><br></html><br>&lt;%@ page language=&quot;java&quot; pageEncoding=&quot;utf-8&quot;%&gt;
&lt;%@ taglib uri=&quot;<a href="http://java.sun.com/jsp/jstl/core" target="_blank">http://java.sun.com/jsp/jstl/core</a>&quot; prefix=&quot;c&quot;%&gt;
&lt;%@ taglib uri=&quot;<a href="http://java.sun.com/jsp/jstl/fmt" target="_blank">http://java.sun.com/jsp/jstl/fmt</a>&quot; prefix=&quot;fmt&quot; %&gt;
&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;
<html>
    <head>
        <title>chapter4.jsp</title>
    </head>
    <body>
        <div>
            <div>
                <fmt:setLocale value="fr_fr"/>
                <fmt:formatNumber value="123456789.012"/>
                <br/>
                <fmt:setLocale value="zh_cn"/>
                <fmt:formatNumber value="123456789.012"/>
                <br />
                <fmt:setLocale value="de_de"/>
                <fmt:formatNumber value="123456789.012"/>
                <br /><br>            </div>
        </div>
    </body>
</html>    注意:如果要实现国际化,那么编码格式要设置为utf-8.
          从程序运行效果可以看出,设定的区域不同,格式化数字的显示也会不同.

四：type属性：可以是数字(number),货币(currency),百分比(percent)
    示例2：<br>Java代码 
&lt;%@ page language=&quot;java&quot; pageEncoding=&quot;utf-8&quot;%&gt;<br>&lt;%@ taglib uri=&quot;<a href="http://java.sun.com/jsp/jstl/core" target="_blank">http://java.sun.com/jsp/jstl/core</a>&quot; prefix=&quot;c&quot;%&gt;<br>&lt;%@ taglib uri=&quot;<a href="http://java.sun.com/jsp/jstl/fmt" target="_blank">http://java.sun.com/jsp/jstl/fmt</a>&quot; prefix=&quot;fmt&quot; %&gt;<br>&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;<br><html><br>    <head><br>        <title>chapter4.jsp</title><br>    </head><br>    <body><br>        <div><br>            <div><br>                <fmt:setLocale value="zh_cn"/><br>                <fmt:formatNumber value="0.3" type="number"/><br /><br>                <fmt:formatNumber value="0.3" type="currency"/><br /><br>                <fmt:formatNumber value="0.3" type="percent"/><br /><br>            </div><br>        </div><br>    </body><br></html><br>&lt;%@ page language=&quot;java&quot; pageEncoding=&quot;utf-8&quot;%&gt;
&lt;%@ taglib uri=&quot;<a href="http://java.sun.com/jsp/jstl/core" target="_blank">http://java.sun.com/jsp/jstl/core</a>&quot; prefix=&quot;c&quot;%&gt;
&lt;%@ taglib uri=&quot;<a href="http://java.sun.com/jsp/jstl/fmt" target="_blank">http://java.sun.com/jsp/jstl/fmt</a>&quot; prefix=&quot;fmt&quot; %&gt;
&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;
<html>
    <head>
        <title>chapter4.jsp</title>
    </head>
    <body>
        <div>
            <div>
                <fmt:setLocale value="zh_cn"/>
                <fmt:formatNumber value="0.3" type="number"/><br />
                <fmt:formatNumber value="0.3" type="currency"/><br />
                <fmt:formatNumber value="0.3" type="percent"/><br /><br>            </div>
        </div>
    </body>
</html>     currencyCode为货币代码,例如美元为USD,人民币为CNY等
     currencySymbol为货币符号例如,人民币为￥,美元为$。
     如果不指定区域,则会根据语言区域自动选择currencySymbol
   示例3：<br>Java代码 
&lt;%@ page language=&quot;java&quot; pageEncoding=&quot;utf-8&quot;%&gt;<br>&lt;%@ taglib uri=&quot;<a href="http://java.sun.com/jsp/jstl/core" target="_blank">http://java.sun.com/jsp/jstl/core</a>&quot; prefix=&quot;c&quot;%&gt;<br>&lt;%@ taglib uri=&quot;<a href="http://java.sun.com/jsp/jstl/fmt" target="_blank">http://java.sun.com/jsp/jstl/fmt</a>&quot; prefix=&quot;fmt&quot; %&gt;<br>&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;<br><html><br>    <head><br>        <title>chapter4.jsp</title><br>    </head><br>    <body><br>        <div><br>            <div><br>                <fmt:setLocale value="zh_cn"/><br>                <fmt:formatNumber value="0.3" type="currency"/><br /><br>                <fmt:setLocale value="en_Us"/><br>                <fmt:formatNumber value="0.3" type="currency"/><br /><br>            </div><br>        </div><br>    </body><br></html><br>&lt;%@ page language=&quot;java&quot; pageEncoding=&quot;utf-8&quot;%&gt;
&lt;%@ taglib uri=&quot;<a href="http://java.sun.com/jsp/jstl/core" target="_blank">http://java.sun.com/jsp/jstl/core</a>&quot; prefix=&quot;c&quot;%&gt;
&lt;%@ taglib uri=&quot;<a href="http://java.sun.com/jsp/jstl/fmt" target="_blank">http://java.sun.com/jsp/jstl/fmt</a>&quot; prefix=&quot;fmt&quot; %&gt;
&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;
<html>
    <head>
        <title>chapter4.jsp</title>
    </head>
    <body>
        <div>
            <div>
                <fmt:setLocale value="zh_cn"/>
                <fmt:formatNumber value="0.3" type="currency"/><br />
                <fmt:setLocale value="en_Us"/>
                <fmt:formatNumber value="0.3" type="currency"/><br /><br>            </div>
        </div>
    </body>
</html><br>   currencySymbol属性还可以自定义要显示的头标识,但是一定得type=&quot;currency&quot;才会生效,例如:<br>Java代码 
&lt;%@ page language=&quot;java&quot; pageEncoding=&quot;utf-8&quot;%&gt;<br>&lt;%@ taglib uri=&quot;<a href="http://java.sun.com/jsp/jstl/core" target="_blank">http://java.sun.com/jsp/jstl/core</a>&quot; prefix=&quot;c&quot;%&gt;<br>&lt;%@ taglib uri=&quot;<a href="http://java.sun.com/jsp/jstl/fmt" target="_blank">http://java.sun.com/jsp/jstl/fmt</a>&quot; prefix=&quot;fmt&quot; %&gt;<br>&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;<br><html><br>    <head><br>        <title>chapter4.jsp</title><br>    </head><br>    <body><br>        <div><br>            <div><br>                <fmt:setLocale value="zh_cn"/><br>                <fmt:formatNumber value="0.3" type="currency" currencySymbol="/#"/><br /><br>                <fmt:setLocale value="en_Us"/><br>                <fmt:formatNumber value="0.3" type="currency" currencySymbol="/#"/><br /><br>            </div><br>        </div><br>    </body><br></html><br>&lt;%@ page language=&quot;java&quot; pageEncoding=&quot;utf-8&quot;%&gt;
&lt;%@ taglib uri=&quot;<a href="http://java.sun.com/jsp/jstl/core" target="_blank">http://java.sun.com/jsp/jstl/core</a>&quot; prefix=&quot;c&quot;%&gt;
&lt;%@ taglib uri=&quot;<a href="http://java.sun.com/jsp/jstl/fmt" target="_blank">http://java.sun.com/jsp/jstl/fmt</a>&quot; prefix=&quot;fmt&quot; %&gt;
&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;
<html>
    <head>
        <title>chapter4.jsp</title>
    </head>
    <body>
        <div>
            <div>
                <fmt:setLocale value="zh_cn"/>
                <fmt:formatNumber value="0.3" type="currency" currencySymbol="/#"/><br />
                <fmt:setLocale value="en_Us"/>
                <fmt:formatNumber value="0.3" type="currency" currencySymbol="/#"/><br /><br>            </div>
        </div>
    </body>
</html><br>    自定义数字样式
    <fmt:formatNumber value="12.31" pattern=".0000"/><br/>
    <fmt:formatNumber value="1234" pattern="/#/#/#./#/#E0"/>
    会显示:
    12.3100
    1.234E3
    会四舍五入
    var:定义一个变量,存储格式化后的结果,scope指定变量存储的范围.用法和前面讲的标签一致.

<strong>五：<fmt:parseNumber></strong>
-------------------------------------------------------------------
     此标签用来将字符串类型的数字,货币或百分比转换成数字类型,和<fmt:formatNumber>标签的作用正好相反.
     value: 要转换的字符串
     type: 指定要转换的字符串为什么类型,可取值:number,percent,currency
     pattern: 自定义格式化样式
     parseLocale: 指定区域来转换字符串
     IntegerOnly:  转换后的数字是否只显示整数部分
     var:  存储转换后的结果
     scope: 存储的范围
    示例1:
    <fmt:parseNumber value="500,800,200"/>
    显示: 500800200
    示例2:
    <fmt:parseNumber value="52%" type="percent" />
    显示: 0.52 (52%在这里是一个字符串, type指定这个字符串是什么类型的值)
    示例3:
    <fmt:parseNumber value="￥123" type="currency" />
    显示123, ￥123在这里是一个字符串, type指定这个字符串是什么类型的值
    示例4:
    <fmt:parseNumber value="123.333" type="number" /><br/>
    <fmt:parseNumber value="123.333" type="number"  integerOnly="true"/><br/> 
    显示:
    123.333
    123
    integerOnly确定是否只显示整数部分. 
    示例5:
   <fmt:parseNumber value="￥123.333" type="currency" parseLocale="zh_CN"/><br/>
   <fmt:parseNumber value="$123.333" type="currency" parseLocale="en_US"/><br/>
    parseLocale=&quot;en_US&quot;主要是配合当type=&quot;currency&quot;时用的,
    如果要转换货币的字符串类型为value=&quot;￥123.333&quot;,不设置语言环境的话,会取当前浏览器的默认设置,否则就要加上parseLocale=&quot;zh_CN&quot;,指定环境为中文环境
     如果要转换货币的字符串类型为value=&quot;$123.333&quot;,不设置语言环境的话,会取当前浏览器的默认设置,如果默认为zh_cn的话,程序会报错的,否则就要加上parseLocale=&quot;en_US&quot;,指定环境为英文美国环境
<strong>六：<fmt:formatDate /></strong>
-------------------------------------------------------------------
     此标签可以将日期格式化.
     属性介绍:
     value 用来格式化的时间或日期
     type 指定格式化的是日期还是时间,或者两者都是取值范围:date,time,both
     pattern 自定义格式化样式
     dateStyle 日期的格式化样式
     timeStyle 时间的格式化样式
     timeZone 指定使用的时区
     var 存储格式化后的结果
     scope 指定存储的范围



    自定义格式:<br>
--------------------------
Java代码 
<fmt:setLocale value="zh_cn" /><br><fmt:formatDate value="<%=new Date()%>" type="both" pattern="yyyy/MM/dd hh:mm:ss" /><br><br /><br><fmt:formatDate value="<%=new Date()%>" type="both" pattern="yyyy-MM-dd HH:mm:ss" /><br><br /><br><fmt:formatDate value="<%=new Date()%>" type="both" pattern="yyyy年MM月dd日 hh小时mm分钟ss秒" /><br><br /><br><fmt:formatDate value="<%=new Date()%>" type="both" pattern="yy/MM/dd hh:mm:ss" /><br><br /><br><fmt:setLocale value="zh_cn" />
<fmt:formatDate value="<%=new Date()%>" type="both" pattern="yyyy/MM/dd hh:mm:ss" />
<br />
<fmt:formatDate value="<%=new Date()%>" type="both" pattern="yyyy-MM-dd HH:mm:ss" />
<br />
<fmt:formatDate value="<%=new Date()%>" type="both" pattern="yyyy年MM月dd日 hh小时mm分钟ss秒" />
<br />
<fmt:formatDate value="<%=new Date()%>" type="both" pattern="yy/MM/dd hh:mm:ss" />
<br />     注意这里小时 hh表示12小时制, HH代表24小时制

     示例1：<br>--------------------------
Java代码 
<fmt:setLocale value="zh_cn" /><br><fmt:formatDate value="<%=new Date()%>" /><br><br /><br><fmt:setLocale value="zh_tw" /><br><fmt:formatDate value="<%=new Date()%>" /><br><fmt:setLocale value="zh_cn" />
<fmt:formatDate value="<%=new Date()%>" />
<br />
<fmt:setLocale value="zh_tw" />
<fmt:formatDate value="<%=new Date()%>" /><br>大家可以看到大陆和台湾显示日期的格式是有区别的.
    显示结果:
    2009-12-7 
    2009/12/7
    示例2：<br>--------------------------
Java代码 
<fmt:setLocale value="zh_cn" /><br><fmt:formatDate value="<%=new Date()%>" type="time"/><br><br /><br><fmt:setLocale value="zh_tw" /><br><fmt:formatDate value="<%=new Date()%>" type="time"/><br><fmt:setLocale value="zh_cn" />
<fmt:formatDate value="<%=new Date()%>" type="time"/>
<br />
<fmt:setLocale value="zh_tw" />
<fmt:formatDate value="<%=new Date()%>" type="time"/><br>显示结果:
    14:59:28 
    下午 02:59:28
     type可取值及意义:
     date 格式化日期
     time格式化时间
     both格式化日期时间
     示例3：<br>
--------------------------
Java代码 
<fmt:setLocale value="zh_cn" /><br><fmt:formatDate value="<%=new Date()%>" type="both" /><br><br /><br><fmt:setLocale value="zh_tw" /><br><fmt:formatDate value="<%=new Date()%>" type="both" /><br><fmt:setLocale value="zh_cn" />
<fmt:formatDate value="<%=new Date()%>" type="both" />
<br />
<fmt:setLocale value="zh_tw" />
<fmt:formatDate value="<%=new Date()%>" type="both" /><br>输出结果:
   2009-12-7 21:24:26 
   2009/12/7 下午 09:24:26
   dateStyle用来设定日期显示的样式,其值可以是default, short, medium, long, full,请看示例:<br>--------------------------
Java代码 
<fmt:setLocale value="zh_cn" /><br><fmt:formatDate value="<%=new Date()%>" type="both" dateStyle="default" /><br><br /><br><fmt:formatDate value="<%=new Date()%>" type="both" dateStyle="short" /><br><br /><br><fmt:formatDate value="<%=new Date()%>" type="both" dateStyle="medium" /><br><br /><br><fmt:formatDate value="<%=new Date()%>" type="both" dateStyle="long" /><br><br /><br><fmt:formatDate value="<%=new Date()%>" type="both" dateStyle="full" /><br><br /><br><fmt:setLocale value="zh_cn" />
<fmt:formatDate value="<%=new Date()%>" type="both" dateStyle="default" />
<br />
<fmt:formatDate value="<%=new Date()%>" type="both" dateStyle="short" />
<br />
<fmt:formatDate value="<%=new Date()%>" type="both" dateStyle="medium" />
<br />
<fmt:formatDate value="<%=new Date()%>" type="both" dateStyle="long" />
<br />
<fmt:formatDate value="<%=new Date()%>" type="both" dateStyle="full" />
<br /><br> 显示结果如下:
    2009-12-7 21:30:49 
    09-12-7 21:30:49 
    2009-12-7 21:30:49 
    2009年12月7日 21:30:49 
    2009年12月7日 星期一 21:30:49
    可以看到dateStyle属性只对日期部分起作用,时间部分没有作用.
    timeStyle用来显示时间部分的样式,取值范围同上<br>--------------------------
Java代码 
<fmt:setLocale value="zh_cn" /><br><fmt:formatDate value="<%=new Date()%>" type="both"    timeStyle="default" /><br><br /><br><fmt:formatDate value="<%=new Date()%>" type="both" timeStyle="short" /><br><br /><br><fmt:formatDate value="<%=new Date()%>" type="both" timeStyle="medium" /><br><br /><br><fmt:formatDate value="<%=new Date()%>" type="both" timeStyle="long" /><br><br /><br><fmt:formatDate value="<%=new Date()%>" type="both" timeStyle="full" /><br><br /><br><fmt:setLocale value="zh_cn" />
<fmt:formatDate value="<%=new Date()%>" type="both"    timeStyle="default" />
<br />
<fmt:formatDate value="<%=new Date()%>" type="both" timeStyle="short" />
<br />
<fmt:formatDate value="<%=new Date()%>" type="both" timeStyle="medium" />
<br />
<fmt:formatDate value="<%=new Date()%>" type="both" timeStyle="long" />
<br />
<fmt:formatDate value="<%=new Date()%>" type="both" timeStyle="full" />
<br /><br>输出:
    2009-12-7 21:35:52 
    2009-12-7 下午9:35 
    2009-12-7 21:35:52 
    2009-12-7 下午09时35分52秒 
    2009-12-7 下午09时35分52秒 CST
    timeZone用来设定时区,时区的意思类似于酒店里大堂放的几个时钟,比如现在时间会有北京时间,东京时间,纽约时间,伦墩时间,
   取值范围为:EST, CST, MST, PST<br>--------------------------
Java代码 
<fmt:setLocale value="zh_cn" /><br><fmt:formatDate value="<%=new Date()%>" type="time" timeStyle="full" /><br><br /><br><fmt:formatDate value="<%=new Date()%>" type="time" timeStyle="full" timeZone="EST" /><br><br /><br><fmt:formatDate value="<%=new Date()%>" type="time" timeStyle="full" timeZone="CST" /><br><br /><br><fmt:formatDate value="<%=new Date()%>" type="time" timeStyle="full" timeZone="MST" /><br><br /><br><fmt:formatDate value="<%=new Date()%>" type="time" timeStyle="full" timeZone="PST" /><br><br /><br><fmt:setLocale value="zh_cn" />
<fmt:formatDate value="<%=new Date()%>" type="time" timeStyle="full" />
<br />
<fmt:formatDate value="<%=new Date()%>" type="time" timeStyle="full" timeZone="EST" />
<br />
<fmt:formatDate value="<%=new Date()%>" type="time" timeStyle="full" timeZone="CST" />
<br />
<fmt:formatDate value="<%=new Date()%>" type="time" timeStyle="full" timeZone="MST" />
<br />
<fmt:formatDate value="<%=new Date()%>" type="time" timeStyle="full" timeZone="PST" />
<br />     输出结果:
    下午09时41分37秒 CST 
    上午08时41分37秒 EST 
    上午07时41分37秒 CST 
    上午06时41分37秒 MST 
    上午05时41分37秒 PST
<strong>七：<fmt:parseDate></strong>
-------------------------------------------------------------------
    将字符串类型的时间转换为日期类型.
    value 用来格式化的时间或日期的字符串
    type 指定格式化的是日期还是时间,或者两者都是取值范围:date,time,both
    pattern 自定义格式化样式
    dateStyle 日期的格式化样式
    timeStyle 时间的格式化样式
    timeZone 指定使用的时区
    var 存储格式化后的结果
    scope 指定存储的范围
   示例:
    <fmt:setLocale value="zh_cn" />
    <fmt:parseDate type="date" value="2008-4-5"/>
     输出: Sat Apr 05 00:00:00 CST 2008,
     这里已经将字符串” 2008-4-5”转换为了日期对象了.转换一定得注意,类似于2008-4-5这样的字符串,type必须为date,类似于12:34:56的字符串,type必须为time类似于2008-4-5 12:34:56这样的字符串,type必须为both还要注意浏览器的语言环境的设置,如果为zh_tw,那么字符串就必须得符合当地的标准,如为2009/12/7 下午 09:24:26就正确转换为日期对象,否则就会报错.
<strong>八：<fmt:setTimeZone></strong>
-------------------------------------------------------------------
    value 设定时区
    var 存储设定的时区
    scope 存储的范围
    value用来设定时区,可以是EST,CST,MST,PST等,如果有var属性,则将结果存储在所设定的范围之内.在属性范围内的页面都会使用该时区为默认时区.<br>Java代码 
<fmt:setLocale value="zh_cn" /><br><fmt:setTimeZone value="EST" /><br><fmt:formatDate value="<%=new Date()%>" type="time" timeStyle="full" /><br /><br><fmt:formatDate value="<%=new Date()%>" type="time" timeStyle="full" /><br /><br><fmt:formatDate value="<%=new Date()%>" type="time" timeStyle="full" /><br /><br><fmt:setLocale value="zh_cn" />
<fmt:setTimeZone value="EST" />
<fmt:formatDate value="<%=new Date()%>" type="time" timeStyle="full" /><br />
<fmt:formatDate value="<%=new Date()%>" type="time" timeStyle="full" /><br />
<fmt:formatDate value="<%=new Date()%>" type="time" timeStyle="full" /><br /><br>输出:
   上午09时25分12秒 EST
   上午09时25分12秒 EST
   上午09时25分12秒 EST
    此时区在该页面内都有效
<strong>九：<fmt:timeZone></strong>
-------------------------------------------------------------------
    用来暂时设置时区.<br>Java代码 
<fmt:setLocale value="zh_cn" /><br><fmt:timeZone value="EST"><br><fmt:formatDate value="<%=new Date()%>" type="time" timeStyle="full" /><br><br /><br><fmt:formatDate value="<%=new Date()%>" type="time" timeStyle="full" /><br><br /><br></fmt:timeZone><br><fmt:formatDate value="<%=new Date()%>" type="time" timeStyle="full" /><br><fmt:setLocale value="zh_cn" />
<fmt:timeZone value="EST">
<fmt:formatDate value="<%=new Date()%>" type="time" timeStyle="full" />
<br />
<fmt:formatDate value="<%=new Date()%>" type="time" timeStyle="full" />
<br />
</fmt:timeZone>
<fmt:formatDate value="<%=new Date()%>" type="time" timeStyle="full" /><br>此标签的时区只是部分,在标签开始至标签结束内有效,其它地方无效,其它地方还是会使用默认时区















<strong><fn:> Function标签 **</strong>库 **

==========================================================================



JSTL Functions 标签库中提供了一组常用的 EL 函数，主要用于处理字符串，在 JSP 中可以直接使用这些函数。

在 JSP 文件中使用 Functions 标签库，要先通过 taglib 指令引入该标签库：

&lt;%@taglib uri=”<a href="http://java.sun.com/jsp/jstl/functions”" target="_blank">http://java.sun.com/jsp/jstl/functions”</a> prefix=”fn” %.



## 18.1fn:contains 函数

       fn:contains 函数用于判断在源字符串中是否包含目标字符串，其语法为：

              fn:contains(String source,String target) -------boolean;

       以上 source 参数指定源字符串， target 参数指定目标字符串，返回类型为 boolean 。

       例如对于以下 EL 表达式：

              ${fn:contains(“Tomcat”,”cat”)}

${fn:contains(“Tomcat”,”CAT”)}

       第一个 EL 表达式的值为 true ，第二个 EL 表达式的值为 false 。

## 18.2fn:containsIgnoreCase 函数

       fn:containsIgnoreCase 函数用于判断在源字符串中是否包含目标字符串，并且在判断时忽略大小写，其语法为：

       fn: containsIgnoreCase (String source,String target) -------boolean;

       以上 source 参数指定源字符串， target 参数指定目标字符串，返回类型为 boolean 。

       例如对于以下 EL 表达式：

              ${fn: containsIgnoreCase (“Tomcat”,”CAT”)}

${fn: containsIgnoreCase (“Tomcat”,”Mike”)}

       第一个 EL 表达式的值为 true ，第二个 EL 表达式的值为 false 。

## 18.3 fn:startsWith 函数

       fn:startsWith 函数用于判断源字符串是否以指定的目标字符串开头，其语法为：

              fn:startsWith(String source,String target) ----boolean

       以上 source 参数指定源字符串， target 参数指定目标字符串，返回类型为 boolean 。

       例如对于以下 EL 表达式：

              ${fn: startsWith (“Tomcat”,”Tom”)}

              ${fn: startsWith (“Tomcat”,”cat”)}

       第一个 EL 表达式的值为 true ，第二个 EL 表达式的值为 false 。

## 18.4 fn:endsWith 函数

fn: endsWith 函数用于判断源字符串是否以指定的目标字符串结尾，其语法为：

              fn: endsWith (String source,String target) ----boolean

       以上 source 参数指定源字符串， target 参数指定目标字符串，返回类型为 boolean 。

       例如对于以下 EL 表达式：

              ${fn: endsWith (“Tomcat”,”cat”)}

              ${fn: endsWith (“Tomcat”,”Tom”)}

       第一个 EL 表达式的值为 true ，第二个 EL 表达式的值为 false 。

## 18.5 fn:indexOf 函数

       fn:indexOf 函数用于在源字符串中查找目标字符串，并返回源字符串中最先与目标字符串匹配的第一个字符的索引，如果在源字符串中不包含目标字符串，就返回 -1 ，源字符串中的第一个字符的索引为 0 。 fn:indexOf 函数的语法为：

              fn: indexOf (String source,String target) ----int

       以上 source 参数指定源字符串， target 参数指定目标字符串，返回类型为 int 。

       例如对于以下 EL 表达式：

              1     ${fn: indexOf (“Tomcat”,”cat”)}<br/>

              2     ${fn: indexOf (“2211221”,”21”)} <br/>

              3     ${fn: indexOf (“Tomcat”,”Mike”)} <br/>

       其输出结果为：

              1     3

              2     1

              3     -1

## 18.6 fn:replace 函数

       fn:replace 函数用于把源字符串中的一部分替换为另外的字符串，并返回替换后的字符串。 fn:replace 函数的语法为：

              fn: replace (String source,String before,String after) ----String

       以上 source 参数指定源字符串， before 参数指定源字符串中被替换的子字符串， after 参数指定用于替换的子字符串，返回类型为 String 。

       例如对于以下 EL 表达式：

              1     ${ fn: replace(“TomcAt”,”cAt”,”cat”)}<br/>

              2     ${ fn: replace(“2008/1/9”,”/”,”-”)}<br/>

       其输出结果为：

              1     Tomcat

              2     2008-1-9

## 18.7 fn:substring 函数

       fn:substring 函数用于获取源字符串中的特定子字符串，它的语法为：

              fn:substring(String source,int beginIndex,int endIndex) ------String

       以上 source 参数指定源字符串， beginIndex 参数表示子字符串中的第一个字符在源字符串中的索引，endIndex 参数表示子字符串的最后一个字符在源字符串中的索引加 1 ，返回类型为 String ，源字符串中的第一个字符的索引为 0 。

       例如对于以下 EL 表达式：

              1     ${ fn: substring (“Tomcat”,0,3)}<br/>

              2     ${ fn: substring (“Tomcat”,3,”6”)}<br/>

       其输出结果为：

              1     Tom

              2     cat

## 18.8 fn:substringBefore 函数

       fn:substringBefore 函数用于获取源字符串中指定子字符串之前的子字符串，其语法为：

              fn:substringBefore(String source,String target) ----String

       以上 source 参数指定源字符串， target 参数指定子字符串，返回类型为 String 。如果在源字符串中不包含特定子字符串，就返回空字符串。

       例如对于以下 EL 表达式：

              1     ${ fn: substringBefore (“Tomcat”,”cat”)}<br/>

              2     ${ fn: substringBefore (“mydata.txt”,”.txt”)}<br/>

       其输出结果为：

              1     Tom

              2     mydata

## 18.9 fn:substringAfter 函数

       fn: substringAfter 函数用于获取源字符串中指定子字符串之后的子字符串，其语法为：

              fn: substringAfter (String source,String target) ----String

       以上 source 参数指定源字符串， target 参数指定子字符串，返回类型为 String 。如果在源字符串中不包含特定子字符串，就返回空字符串。

       例如对于以下 EL 表达式：

              1     ${ fn: substringAfter (“Tomcat”,”Tom”)}<br/>

              2     ${ fn: substringAfter (“mydata.txt”,” mydata.”)}<br/>

       其输出结果为：

              1     cat

              2     txt

## 18.10 fn:split 函数

       fn:split 函数用于将源字符串拆分为一个字符串数组，其语法为：

              fn: split (String source,String delimiter) ----String[]

       以上 source 参数指定源字符串， delimiter 参数指定用于拆分源字符串的分隔符，返回类型为 String[] 。如果在源字符串中不包含 delimiter 参数指定的分隔符，或者 delimiter 参数为 null ，那么在返回的字符串数组中只有一个元素，为源字符串。

       例如对于以下 EL 表达式：

              <c:set value=’${ fn: split (“www.mywebsite.org”,”.”)}’ var=”strs”/>

              <c:forEach var=”token” item=”${strs}”>

                     ${token}<br/>

              </c:forEach>

其输出结果为：

       www

       mywebsite

       org

再例如对于以下代码：

       <c:set value=’${ fn: split (“www.mywebsite.org”,”-”)}’ var=”strs”/>

${strs[0]}

其输出结果为：

       www.mywebsite.org

## 18.11 fn:join 函数

       fn:join 函数用于将源字符串数组中的所有字符串连接为一个字符串，其语法为：

              fn:join(String source[],String separator) ----String

       以上 source 参数指定源字符串数组， separator 参数指定用于连接源字符串数组中的各个字符串的分隔符，返回类型为 String 。

       例如对于以下代码：

              &lt;%

              String strs[] = {“www”,”mywebsite”,”org”};

%&gt;

<c:set value=”<%=strs%>” var=”strs”/&gt;

${fn:join(strs,”.”)}

       其输出结果为：

              www. mywebsite. org

## 18.12 fn:toLowerCase 函数

       fn:toLowerCase 函数用于将源字符串中的所有字符改为小写，其语法为：

              fn:toLowerCase(String source)  -----String

       以上 source 参数指定源字符串，返回类型为 String 。

       例如对于以下 EL 表达式：

              fn:toLowerCase(“TomCat”)

       其输出结果为：

              tomcat

## 18.13 fn:toUpperCase 函数

       fn: toUpperCase 函数用于将源字符串中的所有字符改为大写，其语法为：

              fn: toUpperCase (String source)  -----String

       以上 source 参数指定源字符串，返回类型为 String 。

       例如对于以下 EL 表达式：

              fn: toUpperCase (“TomCat”)

       其输出结果为：

              TOMCAT

## 18.14 fn:trim 函数

       fn:trim 函数用于将源字符串中的开头和末尾的空格删除，其语法为：

              fn:trim(String source) ----String

       以上 source 参数指定源字符串，返回类型为 String 。

       例如对于以下 EL 表达式：

              fn:trim(“   Tomcat   ”)

       以上 EL 表达式的值为“ Tomcat ”。

## 18.15 fn:escapeXml 函数

       fn:escapeXml 函数用于将源字符串中的字符“ &lt; ”、“ &gt; ”、“ ” ”和“ &amp; ”等转换为转义字符，本书第 1 章的 1.2 节（ HTML 简介）介绍了转义字符的概念。 fn:escapeXml 函数的行为与 <c:out> 标签的 escapeXml 属性为 true 时的转换行为相同， fn:escapeXml 函数的语法为：

       fn:escapeXml(String source) ----String

       以上 source 参数指定源字符串，返回类型为 String 。

       例程 18-1 的 out.jsp 演示了 fn:escapeXml 函数的用法。

&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;

&lt;%@ taglib uri=&quot;<a href="http://java.sun.com/jsp/jstl/core" target="_blank">http://java.sun.com/jsp/jstl/core</a>&quot; prefix=&quot;c&quot;%&gt;

&lt;%@ taglib uri=&quot;<a href="http://java.sun.com/jsp/jstl/functions" target="_blank">http://java.sun.com/jsp/jstl/functions</a>&quot; prefix=&quot;fn&quot;%&gt;

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />

<title>out</title>

</head>

<body>

1.${fn:escapeXml(&quot;<b> 表示粗体字 </b>&quot;) }<br/>

2.<c:out value="<b> 表示粗体字 </b>" escapeXml="true"></c:out><br/>

3.${&quot;<b> 表示粗体字 </b>&quot;}<br/>

</body>

</html>



<pre><code>   对于 out.jsp 中的以下代码：

          1.${fn:escapeXml(&quot;&lt;b&gt; 表示粗体字 &lt;/b&gt;&quot;) }&lt;br/&gt;
</code></pre><p>2.<c:out value="<b> 表示粗体字 </b>" escapeXml="true"></c:out><br/></p>
<p>3.${&quot;<b> 表示粗体字 </b>&quot;}<br/></p>
<pre><code>   其输出结果为：

          1.&amp;lt;b&amp;gt; 表示粗体字 &amp;lt;/b&amp;gt;&lt;br/&gt;
</code></pre><p>2.&lt;b&gt; 表示粗体字 &lt;/b&gt;<br/></p>
<p>3.<b> 表示粗体字 </b><br/></p>
<h2 id="18-16-fn-length-">18.16 fn:length 函数</h2>
<pre><code>   fn:length 函数用于返回字符串中的字符的个数，或者集合和数组的元素的个数，其语法为：

          fn:length(source) ---- int

   以上 source 参数可以为字符串、集合或者数组，返回类型为 int 。
</code></pre><p>&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;</p>
<pre><code>pageEncoding=&quot;UTF-8&quot;%&gt;
</code></pre><p>&lt;%@ taglib uri=&quot;<a href="http://java.sun.com/jsp/jstl/core" target="_blank">http://java.sun.com/jsp/jstl/core</a>&quot; prefix=&quot;c&quot;%&gt;</p>
<p>&lt;%@ taglib uri=&quot;<a href="http://java.sun.com/jsp/jstl/functions" target="_blank">http://java.sun.com/jsp/jstl/functions</a>&quot; prefix=&quot;fn&quot;%&gt;</p>
<p>&lt;%@page import=&quot;java.util.ArrayList&quot;%&gt;</p>
<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />

<title>length</title>

</head>

<body>

&lt;%

int[] array = {1,2,3,4};

ArrayList list = new ArrayList();

list.add(&quot;one&quot;);

list.add(&quot;two&quot;);

list.add(&quot;three&quot;);

%&gt;

<c:set value="<%=array%>" var="array"></c:set>

<c:set value="<%=list%>" var="list"></c:set>

数组长度： ${fn:length(array)}<br/>

集合长度： ${fn:length(list)}<br/>

字符串长度： ${fn:length(&quot;Tomcat&quot;)}<br/>

</body>

</html>









<p><strong>Functions 标签库概览</strong></p>
<p>l  fn:contains 函数 ： 用于判断在源字符串中是否包含目标字符串。</p>
<p>l  fn:containsIgnoreCase 函数 ： 用于判断在源字符串中是否包含目标字符串 ， 并且在判断时忽略大小写。</p>
<p>l  fn:startsWith 函数 ： 用于判断源字符串是否以指定的目标字符串开头。</p>
<p>l  fn: endsWith 函数：用于判断源字符串是否以指定的目标字符串结尾。</p>
<p>l  fn:indexOf 函数：用于在源字符串中查找目标字符串，并返回源字符串中最先与目标字符串匹配的第一个字符的索引。</p>
<p>l  fn:replace 函数：用于把源字符串中的一部分替换为另外的字符串，并返回替换后的字符串。</p>
<p>l  fn:substring 函数：用于获取源字符串中的特定子字符串。</p>
<p>l  fn:substringBefore 函数：用于获取源字符串中指定子字符串之前的子字符串。</p>
<p>l  fn: substringAfter 函数：用于获取源字符串中指定子字符串之后的子字符串</p>
<p>l  fn:split 函数：用于将源字符串拆分为一个字符串数组。</p>
<p>l  fn:join 函数：用于将源字符串数组中的所有字符串连接为一个字符串。</p>
<p>l  fn:toLowerCase 函数：用于将源字符串中的所有字符改为小写。</p>
<p>l  fn: toUpperCase 函数：用于将源字符串中的所有字符改为大写。</p>
<p>l  fn:trim 函数：用于将源字符串中的开头和末尾的空格删除。</p>
<p>l  fn:escapeXml 函数：用于将源字符串中的字符“ &lt; ”、“ &gt; ”、“ ” ”和“ &amp; ”等转换为转义字符。</p>
<p>l  fn:length 函数：用于返回字符串中的字符的个数，或者集合和数组的元素的个数
来源： <a href="[http://elf8848.iteye.com/blog/245559](http://elf8848.iteye.com/blog/245559)">[http://elf8848.iteye.com/blog/245559](http://elf8848.iteye.com/blog/245559)</a> </p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:41"datetime="2014-03-07 09:54:41"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE--JSTL标签参考手册/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE--JSTL标签参考手册" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_多线程-并发--聊聊并发（五）——原子操作的实现原理/">聊聊并发（五）——原子操作的实现原理</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:41.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_多线程-并发--聊聊并发（五）——原子操作的实现原理/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-">聊聊并发（五）——原子操作的实现原理</h1>
<h3 id="-">分享到</h3>
<ul>
<li><a href="">一键分享</a></li>
<li><a href="">QQ空间</a></li>
<li><a href="">新浪微博</a></li>
<li><a href="">百度搜藏</a></li>
<li><a href="">人人网</a></li>
<li><a href="">腾讯微博</a></li>
<li><a href="">百度相册</a></li>
<li><a href="">开心网</a></li>
<li><a href="">腾讯朋友</a></li>
<li><a href="">百度贴吧</a></li>
<li><a href="">豆瓣网</a></li>
<li><a href="">搜狐微博</a></li>
<li><a href="">百度新首页</a></li>
<li><a href="">QQ好友</a></li>
<li><a href="">和讯微博</a></li>
<li><a href="">更多...</a></li>
</ul>
<p><a href="">百度分享</a></p>
<h1 id="-">聊聊并发（五）——原子操作的实现原理</h1>
<p>作者 <a href="http://www.infoq.com/cn/author/%E6%96%B9%E8%85%BE%E9%A3%9E" target="_blank">方腾飞</a> 发布于 十一月 29, 2012 <em>|</em> <a href="">14 评论</a></p>
<h2 id="1-">1. 引言</h2>
<p>原子（atom）本意是“不能被进一步分割的最小粒子”，而原子操作（atomic operation）意为&quot;不可被中断的一个或一系列操作&quot; 。在多处理器上实现原子操作就变得有点复杂。本文让我们一起来聊一聊在Intel处理器和Java里是如何实现原子操作的。</p>
<h2 id="2-">2. 术语定义</h2>
<p>术语 英文 解释 缓存行 Cache line 缓存的最小操作单位 比较并交换 Compare and Swap CAS操作需要输入两个数值，一个旧值（期望操作前的值）和一个新值，在操作期间先比较下旧值有没有发生变化，如果没有发生变化，才交换成新值，发生了变化则不交换。 CPU流水线 CPU pipeline CPU流水线的工作方式就象工业生产上的装配流水线，在CPU中由5~6个不同功能的电路单元组成一条指令处理流水线，然后将一条X86指令分成5~6步后再由这些电路单元分别执行，这样就能实现在一个CPU时钟周期完成一条指令，因此提高CPU的运算速度。 内存顺序冲突 Memory order violation 内存顺序冲突一般是由假共享引起，假共享是指多个CPU同时修改同一个缓存行的不同部分而引起其中一个CPU的操作无效，当出现这个内存顺序冲突时，CPU必须清空流水线。</p>
<h2 id="3-">3. 处理器如何实现原子操作</h2>
<p>32位IA-32处理器使用基于对缓存加锁或总线加锁的方式来实现多处理器之间的原子操作。</p>
<h3 id="3-1-">3.1 处理器自动保证基本内存操作的原子性</h3>
<p>首先处理器会自动保证基本的内存操作的原子性。处理器保证从系统内存当中读取或者写入一个字节是原子的，意思是当一个处理器读取一个字节时，其他处理器不能访问这个字节的内存地址。奔腾6和最新的处理器能自动保证单处理器对同一个缓存行里进行16/32/64位的操作是原子的，但是复杂的内存操作处理器不能自动保证其原子性，比如跨总线宽度，跨多个缓存行，跨页表的访问。但是处理器提供总线锁定和缓存锁定两个机制来保证复杂内存操作的原子性。</p>
<h3 id="3-2-">3.2 使用总线锁保证原子性</h3>
<p>第一个机制是通过总线锁保证原子性。如果多个处理器同时对共享变量进行读改写（i++就是经典的读改写操作）操作，那么共享变量就会被多个处理器同时进行操作，这样读改写操作就不是原子的，操作完之后共享变量的值会和期望的不一致，举个例子：如果i=1,我们进行两次i++操作，我们期望的结果是3，但是有可能结果是2。如下图</p>
<p><img src="" alt=""></p>
<p>（例1）</p>
<p>原因是有可能多个处理器同时从各自的缓存中读取变量i，分别进行加一操作，然后分别写入系统内存当中。那么想要保证读改写共享变量的操作是原子的，就必须保证CPU1读改写共享变量的时候，CPU2不能操作缓存了该共享变量内存地址的缓存。</p>
<p>处理器使用总线锁就是来解决这个问题的。所谓总线锁就是使用处理器提供的一个LOCK＃信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住,那么该处理器可以独占使用共享内存。</p>
<h3 id="3-3-">3.3 使用缓存锁保证原子性</h3>
<p>第二个机制是通过缓存锁定保证原子性。在同一时刻我们只需保证对某个内存地址的操作是原子性即可，但总线锁定把CPU和内存之间通信锁住了，这使得锁定期间，其他处理器不能操作其他内存地址的数据，所以总线锁定的开销比较大，最近的处理器在某些场合下使用缓存锁定代替总线锁定来进行优化。</p>
<p>频繁使用的内存会缓存在处理器的L1，L2和L3高速缓存里，那么原子操作就可以直接在处理器内部缓存中进行，并不需要声明总线锁，在奔腾6和最近的处理器中可以使用“缓存锁定”的方式来实现复杂的原子性。所谓“缓存锁定”就是如果缓存在处理器缓存行中内存区域在LOCK操作期间被锁定，当它执行锁操作回写内存时，处理器不在总线上声言LOCK＃信号，而是修改内部的内存地址，并允许它的缓存一致性机制来保证操作的原子性，因为缓存一致性机制会阻止同时修改被两个以上处理器缓存的内存区域数据，当其他处理器回写已被锁定的缓存行的数据时会起缓存行无效，在例1中，当CPU1修改缓存行中的i时使用缓存锁定，那么CPU2就不能同时缓存了i的缓存行。</p>
<p>但是有两种情况下处理器不会使用缓存锁定。第一种情况是：当操作的数据不能被缓存在处理器内部，或操作的数据跨多个缓存行（cache line），则处理器会调用总线锁定。第二种情况是：有些处理器不支持缓存锁定。对于Inter486和奔腾处理器,就算锁定的内存区域在处理器的缓存行中也会调用总线锁定。</p>
<p>以上两个机制我们可以通过Inter处理器提供了很多LOCK前缀的指令来实现。比如位测试和修改指令BTS，BTR，BTC，交换指令XADD，CMPXCHG和其他一些操作数和逻辑指令，比如ADD（加），OR（或）等，被这些指令操作的内存区域就会加锁，导致其他处理器不能同时访问它。</p>
<h2 id="4-java-">4. JAVA如何实现原子操作</h2>
<p>在java中可以通过锁和循环CAS的方式来实现原子操作。</p>
<h3 id="4-1-cas-">4.1 使用循环CAS实现原子操作</h3>
<p>JVM中的CAS操作正是利用了上一节中提到的处理器提供的CMPXCHG指令实现的。自旋CAS实现的基本思路就是循环进行CAS操作直到成功为止，以下代码实现了一个基于CAS线程安全的计数器方法safeCount和一个非线程安全的计数器count。
public class Counter { private AtomicInteger atomicI = new AtomicInteger(0); private int i = 0; public static void main(String[] args) { final Counter cas = new Counter(); List<Thread> ts = new ArrayList<Thread>(600); long start = System.currentTimeMillis(); for (int j = 0; j &lt; 100; j++) { Thread t = new Thread(new Runnable() { @Override public void run() { for (int i = 0; i &lt; 10000; i++) { cas.count(); cas.safeCount(); } } }); ts.add(t); } for (Thread t : ts) { t.start(); } // 等待所有线程执行完成 for (Thread t : ts) { try { t.join(); } catch (InterruptedException e) { e.printStackTrace(); } } System.out.println(cas.i); System.out.println(cas.atomicI.get()); System.out.println(System.currentTimeMillis() - start); } //<em>/</em> /<em> 使用CAS实现线程安全计数器 /</em>/ private void safeCount() { for (;;) { int i = atomicI.get(); boolean suc = atomicI.compareAndSet(i, ++i); if (suc) { break; } } } //<em>/</em> /<em> 非线程安全计数器 /</em>/ private void count() { i++; } }</p>
<p>在java并发包中有一些并发框架也使用了自旋CAS的方式来实现原子操作，比如LinkedTransferQueue类的Xfer方法。CAS虽然很高效的解决原子操作，但是CAS仍然存在三大问题。ABA问题，循环时间长开销大和只能保证一个共享变量的原子操作。</p>
<ol>
<li>ABA问题。因为CAS需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么A－B－A 就会变成1A-2B－3A。
从Java1.5开始JDK的atomic包里提供了一个类AtomicStampedReference来解决ABA问题。这个类的compareAndSet方法作用是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。
public boolean compareAndSet (V expectedReference,//预期引用 V newReference,//更新后的引用 int expectedStamp, //预期标志 int newStamp) //更新后的标志</li>
<li>循环时间长开销大。自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。</li>
<li>只能保证一个共享变量的原子操作。当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁，或者有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如有两个共享变量i＝2,j=a，合并一下ij=2a，然后用CAS来操作ij。从Java1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行CAS操作。</li>
</ol>
<h3 id="4-2-">4.2 使用锁机制实现原子操作</h3>
<p>锁机制保证了只有获得锁的线程能够操作锁定的内存区域。JVM内部实现了很多种锁机制，有偏向锁，轻量级锁和互斥锁，有意思的是除了偏向锁，JVM实现锁的方式都用到的循环CAS，当一个线程想进入同步块的时候使用循环CAS的方式来获取锁，当它退出同步块的时候使用循环CAS释放锁。详细说明可以参见文章Java SE1.6中的Synchronized。</p>
<h2 id="5-">5. 参考资料</h2>
<ol>
<li><a href="http://www.infoq.com/cn/articles/java-se-16-synchronized" target="_blank">Java SE1.6中的Synchronized</a></li>
<li><a href="http://www.intel.com/products/processor/manuals/" target="_blank">Intel 64和IA-32架构软件开发人员手册</a></li>
<li><a href="http://www.infoq.com/cn/articles/ftf-java-volatile" target="_blank">深入分析Volatile的实现原理</a></li>
</ol>
<h2 id="-">作者介绍</h2>
<p><strong>方腾飞</strong>，花名清英，淘宝资深开发工程师，关注并发编程，目前在广告技术部从事无线广告联盟的开发和设计工作。个人博客：<a href="http://ifeve.com/" target="_blank"><a href="http://ifeve.com">http://ifeve.com</a></a> 微博：<a href="http://weibo.com/kirals" target="_blank"><a href="http://weibo.com/kirals">http://weibo.com/kirals</a></a> 欢迎通过我的微博进行技术交流。</p>
<p>感谢<a href="http://www.infoq.com/cn/bycategory.action?authorName=张龙" target="_blank">张龙</a>对本文的审校。</p>
<p>给InfoQ中文站投稿或者参与内容翻译工作，请邮件至<a href="mailto:editors@cn.infoq.com">editors@cn.infoq.com</a>。也欢迎大家通过新浪微博（<a href="http://www.weibo.com/infoqchina" target="_blank">@InfoQ</a>）或者腾讯微博（<a href="http://t.qq.com/infoqchina" target="_blank">@InfoQ</a>）关注我们，并与我们的编辑和其他读者朋友交流。</p>
<ul>
<li><a href="">Sections</a></li>
<li><a href="http://www.infoq.com/cn/architecture-design" target="_blank"><strong>架构 &amp; 设计</strong></a></li>
<li><a href="http://www.infoq.com/cn/development" target="_blank"><strong>语言 &amp; 开发</strong></a></li>
<li><a href="">Topics</a></li>
<li><a href="http://www.infoq.com/cn/cloud-computing" target="_blank">云计算</a></li>
<li><a href="http://www.infoq.com/cn/Multi-threading" target="_blank">多线程</a></li>
<li><a href="http://www.infoq.com/cn/atomic-operation" target="_blank">原子操作</a></li>
<li><a href="http://www.infoq.com/cn/Security" target="_blank">安全</a></li>
<li><a href="http://www.infoq.com/cn/concurrency" target="_blank">并发</a></li>
<li><a href="http://www.infoq.com/cn/soa_platforms" target="_blank">SOA平台</a></li>
<li><a href="http://www.infoq.com/cn/architecture" target="_blank">架构</a></li>
<li><a href="http://www.infoq.com/cn/java" target="_blank">Java</a></li>
<li><a href="http://www.infoq.com/cn/soa" target="_blank">SOA</a></li>
<li><a href="http://www.infoq.com/cn/enterprise-architecture" target="_blank">企业架构</a></li>
<li><a href="http://www.infoq.com/cn/intel" target="_blank">Intel</a></li>
</ul>
<p>相关内容</p>
<h3 id="-concurrentlinkedqueue-http-www-infoq-com-cn-articles-concurrentlinkedqueue-utm_source-infoq-utm_medium-related_content_link-utm_campaign-relatedcontent_articles_clk-"><a href="http://www.infoq.com/cn/articles/ConcurrentLinkedQueue?utm_source=infoq&amp;utm_medium=related_content_link&amp;utm_campaign=relatedContent_articles_clk" target="_blank">聊聊并发（六）——ConcurrentLinkedQueue的实现原理分析</a></h3>
<h3 id="-concurrenthashmap-http-www-infoq-com-cn-articles-concurrenthashmap-utm_source-infoq-utm_medium-related_content_link-utm_campaign-relatedcontent_articles_clk-"><a href="http://www.infoq.com/cn/articles/ConcurrentHashMap?utm_source=infoq&amp;utm_medium=related_content_link&amp;utm_campaign=relatedContent_articles_clk" target="_blank">聊聊并发（四）——深入分析ConcurrentHashMap</a></h3>
<h3 id="-java-http-www-infoq-com-cn-articles-java-threadpool-utm_source-infoq-utm_medium-related_content_link-utm_campaign-relatedcontent_articles_clk-"><a href="http://www.infoq.com/cn/articles/java-threadPool?utm_source=infoq&amp;utm_medium=related_content_link&amp;utm_campaign=relatedContent_articles_clk" target="_blank">聊聊并发（三）——JAVA线程池的分析和使用</a></h3>
<h3 id="-volatile-http-www-infoq-com-cn-articles-ftf-java-volatile-utm_source-infoq-utm_medium-related_content_link-utm_campaign-relatedcontent_articles_clk-"><a href="http://www.infoq.com/cn/articles/ftf-java-volatile?utm_source=infoq&amp;utm_medium=related_content_link&amp;utm_campaign=relatedContent_articles_clk" target="_blank">聊聊并发（一）——深入分析Volatile的实现原理</a></h3>
<h3 id="-intel-javascript-http-www-infoq-com-cn-news-2012-02-javascript-parallel-processing-utm_source-infoq-utm_medium-related_content_link-utm_campaign-relatedcontent_articles_clk-"><a href="http://www.infoq.com/cn/news/2012/02/javascript-parallel-processing?utm_source=infoq&amp;utm_medium=related_content_link&amp;utm_campaign=relatedContent_articles_clk" target="_blank">Intel发布JavaScript扩展以支持并行运算</a></h3>
<h2 id="-">您好，陌生人！</h2>
<p>您需要 <a href="http://www.infoq.com/reginit.action" target="_blank">注册一个InfoQ账号</a> 或者 <a href="">登录</a> 才能进行评论。在您完成注册后还需要进行一些设置。</p>
<h2 id="-infoq-">获得来自InfoQ的更多体验。<a href=""></a></h2>
<p>允许的HTML标签: a,b,br,blockquote,i,li,pre,u,ul,p</p>
<p>当有人回复此评论时请E-mail通知我</p>
<p>社区评论 <a href="">Watch Thread</a></p>
<p><a href=""><strong>您好，有个地方不太明白</strong> by 王 凯 Posted 30/11/2012 05:01</a>
<a href=""><strong>Re: 您好，有个地方不太明白</strong> by 方 腾飞 Posted 30/11/2012 05:14</a></p>
<p><a href=""><strong>Re: 您好，有个地方不太明白</strong> by 王 凯 Posted 30/11/2012 05:21</a>
<a href=""><strong>期待看到happens-before的深入解读</strong> by freish freish Posted 05/12/2012 08:54</a></p>
<p><a href=""><strong>Re: 期待看到happens-before的深入解读</strong> by 方 腾飞 Posted 05/12/2012 11:04</a>
<a href=""><strong>缓存锁定一处不太明白</strong> by 陈 良柱 Posted 18/12/2012 08:20</a></p>
<p><a href=""><strong>Re: 缓存锁定一处不太明白</strong> by 方 腾飞 Posted 27/12/2012 01:00</a>
<a href=""><strong>Re: 缓存锁定一处不太明白</strong> by Zhao Yu Posted 27/12/2012 10:20</a></p>
<p><a href=""><strong>Re: 缓存锁定一处不太明白</strong> by 方 腾飞 Posted 31/12/2012 10:28</a>
<a href=""><strong>Re: 缓存锁定一处不太明白</strong> by 陈 良柱 Posted 31/12/2012 09:29</a></p>
<p><a href=""><strong>缓存锁定</strong> by Zhao Yu Posted 25/12/2012 04:19</a>
<a href=""><strong>Re: 缓存锁定</strong> by 方 腾飞 Posted 27/12/2012 00:59</a></p>
<p><a href=""><strong>关于总线锁的问题</strong> by lee jw Posted 29/12/2012 12:54</a>
<a href=""><strong>Re: 关于总线锁的问题</strong> by 方 腾飞 Posted 31/12/2012 10:30</a>
<a href=""></a></p>
<p><strong>您好，有个地方不太明白</strong> 30/11/2012 05:01 by 王 凯</p>
<p>safeCount()方法有些看不明白，直接让atomicI自增不可以吗，AtomicInteger本身不就是原子方式增加的吗，谢谢。</p>
<ul>
<li><a href="">回复</a></li>
<li><a href="">回到顶部</a></li>
</ul>
<p><a href=""></a></p>
<p><strong>Re: 您好，有个地方不太明白</strong> 30/11/2012 05:14 by 方 腾飞</p>
<p>atomicI.compareAndSet(i, ++i);本身是原子方式的增加，但是有可能会增加失败，所以需要不停atomicI.compareAndSet(i, ++i);</p>
<ul>
<li><a href="">回复</a></li>
<li><a href="">回到顶部</a>
<a href=""></a></li>
</ul>
<p><strong>Re: 您好，有个地方不太明白</strong> 30/11/2012 05:21 by 王 凯</p>
<p>哦，明白了，我看了下AtomicInteger的源码，incrementAndGet方法实现，呵呵</p>
<ul>
<li><a href="">回复</a></li>
<li><a href="">回到顶部</a></li>
</ul>
<p><a href=""></a></p>
<p><strong>期待看到happens-before的深入解读</strong> 05/12/2012 08:54 by freish freish</p>
<p>期待看到happens-before的深入解读</p>
<ul>
<li><a href="">回复</a></li>
<li><a href="">回到顶部</a>
<a href=""></a></li>
</ul>
<p><strong>Re: 期待看到happens-before的深入解读</strong> 05/12/2012 11:04 by 方 腾飞</p>
<p>好的，没问题，在JMM文章里我会深入解读下。</p>
<ul>
<li><a href="">回复</a></li>
<li><a href="">回到顶部</a></li>
</ul>
<p><a href=""></a></p>
<p><strong>缓存锁定一处不太明白</strong> 18/12/2012 08:20 by 陈 良柱</p>
<p>缓存失效是在内存写回之前还是之后？如何使得其他cpu的缓存失效？是说内存到缓存的映射是一共享区域且回写内存包含对其的检查吗？</p>
<ul>
<li><a href="">回复</a></li>
<li><a href="">回到顶部</a>
<a href=""></a></li>
</ul>
<p><strong>缓存锁定</strong> 25/12/2012 04:19 by Zhao Yu</p>
<p>“所谓“缓存锁定”就是如果缓存在处理器缓存行中内存区域在LOCK操作期间被锁定，当它执行锁操作回写内存时，处理器不在总线上声言LOCK＃信号，而是修改内部的内存地址，并允许它的缓存一致性机制来保证操作的原子性”
这句实在不理解，首先什么是Lock操作期间？不是不锁总线了嘛？为什么还Lock？其次，处理器不发Lock信号而是修改内部的内存地址，到底是怎么保障在一个处理器修改缓存并回写期间，其它处理器不会执行同样操作？？？望作者解答一下</p>
<ul>
<li><a href="">回复</a></li>
<li><a href="">回到顶部</a></li>
</ul>
<p><a href=""></a></p>
<p><strong>Re: 缓存锁定</strong> 27/12/2012 00:59 by 方 腾飞</p>
<p>Lock操作期间，是指Lock指令执行期间，不锁总线但是锁缓存。
最后一个问题，这个是由缓存一致性协议保证的，详细参见：<a href="http://www.tektalk.org/2011/07/07/cache一致性与2种基本写策略1/" target="_blank">www.tektalk.org/2011/07/07/cache一致性与2种基本写策略1/</a></p>
<ul>
<li><a href="">回复</a></li>
<li><a href="">回到顶部</a>
<a href=""></a></li>
</ul>
<p><strong>Re: 缓存锁定一处不太明白</strong> 27/12/2012 01:00 by 方 腾飞</p>
<p>参见缓存一致性协议：www.tektalk.org/2011/07/07/cache一致性与2种基本写策略1/</p>
<ul>
<li><a href="">回复</a></li>
<li><a href="">回到顶部</a></li>
</ul>
<p><a href=""></a></p>
<p><strong>Re: 缓存锁定一处不太明白</strong> 27/12/2012 10:20 by Zhao Yu</p>
<p>好的～多谢作者的答复，这块内容关注很久了，多线程并发开发程序，那门语言和平台都是学到最后的最为重要，也是最深的地方，希望您继续发表相关博文～</p>
<ul>
<li><a href="">回复</a></li>
<li><a href="">回到顶部</a>
<a href=""></a></li>
</ul>
<p><strong>关于总线锁的问题</strong> 29/12/2012 12:54 by lee jw</p>
<p>您好，我想请问CPU在什么情况下会发出LOCK/#信号，是在冲突的时候发出，还是在读写内存的时候发出？看您的文章是说CPU1发出LOCK/#信号后，CPU2就不能读写内存，我想请问一下这里面是否有优先级的判断？谢谢</p>
<ul>
<li><a href="">回复</a></li>
<li><a href="">回到顶部</a></li>
</ul>
<p><a href=""></a></p>
<p><strong>Re: 缓存锁定一处不太明白</strong> 31/12/2012 10:28 by 方 腾飞</p>
<p>多谢你的关注，定期会发表新文章的。或者你也可以关注我的小站<a href="http://ifeve.com/" target="_blank">ifeve.com</a> 最近我在做国外并发编程文章的翻译，都是非常值得一看的文章，你也可以参与到我们的翻译当中来，一起促进并发编程的研究和推广 。</p>
<ul>
<li><a href="">回复</a></li>
<li><a href="">回到顶部</a>
<a href=""></a></li>
</ul>
<p><strong>Re: 关于总线锁的问题</strong> 31/12/2012 10:30 by 方 腾飞</p>
<p>指令触发的，比如使用lock前缀的指令。</p>
<ul>
<li><a href="">回复</a></li>
<li><a href="">回到顶部</a></li>
</ul>
<p><a href=""></a></p>
<p><strong>Re: 缓存锁定一处不太明白</strong> 31/12/2012 09:29 by 陈 良柱</p>
<p>你给的文章链接没有回答我的问题，不过write-invalidate和write-update两词很有用处。
找到一篇个人认为写得较为清楚的综述文章，在此分享：<a href="http://www.docin.com/p-92508695.html。" target="_blank">www.docin.com/p-92508695.html。</a></p>
<ul>
<li><a href="">回复</a></li>
<li><a href="">回到顶部</a></li>
</ul>
<p><a href="">关闭</a></p>
<h3 id="-by"><em>**</em>by</h3>
<p>发布于</p>
<ul>
<li><a href="">查看</a></li>
<li><a href="">回复</a></li>
<li><a href="">回到顶部</a>
<a href="">关闭</a> 主题  您的回复 <a href="">引用原消息</a></li>
</ul>
<p>允许的HTML标签: a,b,br,blockquote,i,li,pre,u,ul,p
当有人回复此评论时请E-mail通知我</p>
<p><a href="">关闭</a> 主题  您的回复</p>
<p>允许的HTML标签: a,b,br,blockquote,i,li,pre,u,ul,p
当有人回复此评论时请E-mail通知我
<a href="">关闭</a></p>
<ul>
<li>热点内容</li>
<li><a href="">本周</a></li>
<li><a href="">本月</a></li>
<li><a href="">近6个月</a><h3 id="-32-http-www-infoq-com-cn-news-2012-08-32-most-important-algorithms-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2012/08/32-most-important-algorithms?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">计算机科学中最重要的32个算法</a></h3>
</li>
</ul>
<h3 id="-thoughtworks-2013-5-http-www-infoq-com-cn-articles-thoughtworks-technology-radar-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/thoughtWorks-technology-radar?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">ThoughtWorks技术雷达（2013年5月）</a></h3>
<h3 id="-1-5-http-www-infoq-com-cn-articles-iqiyi-cloud-push-practices-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/iqiyi-cloud-push-practices?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">让1.5亿移动端用户第一时间获取消息</a></h3>
<h3 id="-thoughtworks-ceo-http-www-infoq-com-cn-news-2013-06-tw-guoxiao-on-talents-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2013/06/tw-guoxiao-on-talents?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">ThoughtWorks全球CEO郭晓谈软件人才的招聘与培养</a></h3>
<h3 id="-http-www-infoq-com-cn-news-2013-06-10-sins-for-scalability-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2013/06/10-sins-for-scalability?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">影响可扩展性的十宗罪</a></h3>
<h3 id="-6-http-www-infoq-com-cn-minibooks-architect-jun-10-2013-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/architect-jun-10-2013?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">架构师（6月刊）</a></h3>
<h3 id="-http-www-infoq-com-cn-articles-function-switch-realize-better-continuous-implementations-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/function-switch-realize-better-continuous-implementations?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">使用功能开关更好地实现持续部署</a></h3>
<h3 id="-eclipse-github-http-www-infoq-com-cn-news-2013-06-eclipse-github-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2013/06/eclipse-github?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">Eclipse迁移到GitHub</a></h3>
<h3 id="-newegg-com-http-www-infoq-com-cn-presentations-newegg-big-data-practice-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/presentations/newegg-big-data-practice?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">Newegg.com大数据实践</a></h3>
<h3 id="-http-www-infoq-com-cn-minibooks-software-sys-architect-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/software-sys-architect?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">软件系统架构：使用视点和视角与利益相关者合作</a></h3>
<h3 id="-32-http-www-infoq-com-cn-news-2012-08-32-most-important-algorithms-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2012/08/32-most-important-algorithms?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">计算机科学中最重要的32个算法</a></h3>
<h3 id="-6-http-www-infoq-com-cn-minibooks-architect-jun-10-2013-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/architect-jun-10-2013?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">架构师（6月刊）</a></h3>
<h3 id="-rest-http-www-infoq-com-cn-news-2013-06-rest-drawbacks-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2013/06/rest-drawbacks?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">REST的缺点是什么？</a></h3>
<h3 id="-google-web-ui-polymer-http-www-infoq-com-cn-news-2013-06-webcomponents-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2013/06/webcomponents?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">Google 发布新一代Web UI库Polymer</a></h3>
<h3 id="-http-www-infoq-com-cn-news-2013-06-dianping-xinnet-hacked-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2013/06/dianping-xinnet-hacked?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">大众点评网域名劫持事件概述</a></h3>
<h3 id="-node-js-grunt-js-http-www-infoq-com-cn-articles-gruntjs-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/GruntJs?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">基于Node.js的自动化构建工具Grunt.js</a></h3>
<h3 id="-node-js-node-js-http-www-infoq-com-cn-articles-what-is-nodejs-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/what-is-nodejs?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">深入浅出Node.js（一）：什么是Node.js</a></h3>
<h3 id="-http-www-infoq-com-cn-minibooks-i-m-wrights-hard-code-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/i-m-wrights-hard-code?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">代码之殇·第二版</a></h3>
<h3 id="-http-www-infoq-com-cn-minibooks-software-sys-architect-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/software-sys-architect?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">软件系统架构：使用视点和视角与利益相关者合作</a></h3>
<h3 id="-18-java-http-www-infoq-com-cn-news-2013-06-zhuhong-on-java-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2013/06/zhuhong-on-java?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">大家谈18岁的Java——朱鸿：开过跑车后再去开大巴车总是有点不爽的</a></h3>
<h3 id="-32-http-www-infoq-com-cn-news-2012-08-32-most-important-algorithms-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2012/08/32-most-important-algorithms?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">计算机科学中最重要的32个算法</a></h3>
<h3 id="-java-http-www-infoq-com-cn-articles-java-memory-model-1-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/java-memory-model-1?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">深入理解Java内存模型（一）——基础</a></h3>
<h3 id="-node-js-node-js-http-www-infoq-com-cn-articles-what-is-nodejs-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/what-is-nodejs?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">深入浅出Node.js（一）：什么是Node.js</a></h3>
<h3 id="-node-js-node-js-npm-http-www-infoq-com-cn-articles-nodejs-npm-install-config-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/nodejs-npm-install-config?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">深入浅出Node.js（二）：Node.js&amp;NPM的安装与配置</a></h3>
<h3 id="-3-http-www-infoq-com-cn-minibooks-architect-mar-10-2013-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/architect-mar-10-2013?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">架构师（3月刊）</a></h3>
<h3 id="-1-http-www-infoq-com-cn-minibooks-architect-jan-10-2013-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/architect-jan-10-2013?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">架构师（1月刊）</a></h3>
<h3 id="-4-http-www-infoq-com-cn-minibooks-architect-apr-10-2013-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/architect-apr-10-2013?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">架构师（4月刊）</a></h3>
<h3 id="-java-http-www-infoq-com-cn-articles-java-threadpool-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/java-threadPool?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">聊聊并发（三）——JAVA线程池的分析和使用</a></h3>
<h3 id="-2-http-www-infoq-com-cn-minibooks-architect-feb-10-2013-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/architect-feb-10-2013?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">架构师（2月刊）</a></h3>
<h3 id="-12306-github-http-www-infoq-com-cn-news-2013-01-12306-plugin-ddos-github-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2013/01/12306-plugin-ddos-github?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">12306订票助手插件拖垮GitHub事件原因始末</a></h3>
<h2 id="-">深度内容</h2>
<ul>
<li><a href="">全部</a></li>
<li><a href="">文章</a></li>
<li><a href="">演讲</a></li>
<li><a href="">访谈</a></li>
<li><a href="">迷你书</a><h2 id="-juergen-fesslmeier-javascript-http-www-infoq-com-cn-interviews-end-to-end-javascript-juergen-fesslmeier-javascript-"><a href="http://www.infoq.com/cn/interviews/end-to-end-javascript" title="Juergen Fesslmeier谈端到端的JavaScript开发" target="_blank">Juergen Fesslmeier谈端到端的JavaScript开发</a></h2>
</li>
</ul>
<p><a href="http://www.infoq.com/cn/author/Juergen-Fesslmeier" title="Juergen Fesslmeier" target="_blank">Juergen Fesslmeier</a> 七月 02, 2013</p>
<p><a href="http://www.infoq.com/cn/interviews/end-to-end-javascript" title="Juergen Fesslmeier谈端到端的JavaScript开发" target="_blank"><img src="" alt=""></a></p>
<h2 id="-http-www-infoq-com-cn-articles-design-pattern-automation-"><a href="http://www.infoq.com/cn/articles/Design-Pattern-Automation" title="设计模式自动化" target="_blank">设计模式自动化</a></h2>
<p><a href="http://www.infoq.com/cn/author/Gael-Fraiteur-and-Yan-Cui" title="Gael Fraiteur and Yan Cui" target="_blank">Gael Fraiteur and Yan Cui</a> 七月 01, 2013</p>
<p><a href="http://www.infoq.com/cn/articles/Design-Pattern-Automation" title="设计模式自动化" target="_blank"><img src="" alt=""></a></p>
<h2 id="-http-www-infoq-com-cn-articles-designing-a-world-at-your-fingertips-mobile-user-interfaces-"><a href="http://www.infoq.com/cn/articles/designing-a-world-at-your-fingertips-mobile-user-interfaces" title="设计指尖上的世界：移动用户界面一瞥" target="_blank">设计指尖上的世界：移动用户界面一瞥</a></h2>
<p><a href="http://www.infoq.com/cn/author/Forrest-Shull" title="Forrest Shull" target="_blank">Forrest Shull</a> 六月 28, 2013</p>
<p><a href="http://www.infoq.com/cn/articles/designing-a-world-at-your-fingertips-mobile-user-interfaces" title="设计指尖上的世界：移动用户界面一瞥" target="_blank"><img src="" alt=""></a></p>
<h2 id="-alm-http-www-infoq-com-cn-articles-integrated-alm-alm-"><a href="http://www.infoq.com/cn/articles/Integrated-ALM" title="成功的根本—集成的ALM工具" target="_blank">成功的根本—集成的ALM工具</a></h2>
<p><a href="http://www.infoq.com/cn/author/Dave-West" title="Dave West" target="_blank">Dave West</a> 六月 28, 2013</p>
<p><a href="http://www.infoq.com/cn/articles/Integrated-ALM" title="成功的根本—集成的ALM工具" target="_blank"><img src="" alt=""></a></p>
<h2 id="-http-www-infoq-com-cn-articles-atdd-by-example-book-"><a href="http://www.infoq.com/cn/articles/atdd-by-example-book" title="书评：验收测试驱动开发实践指南" target="_blank">书评：验收测试驱动开发实践指南</a></h2>
<p><a href="http://www.infoq.com/cn/author/Manuel-Pais" title="Manuel Pais" target="_blank">Manuel Pais</a> 六月 26, 2013</p>
<p><a href="http://www.infoq.com/cn/articles/atdd-by-example-book" title="书评：验收测试驱动开发实践指南" target="_blank"><img src="" alt=""></a></p>
<h2 id="-web-http-www-infoq-com-cn-presentations-across-device-web-web-"><a href="http://www.infoq.com/cn/presentations/across-device-web" title="跨终端的web" target="_blank">跨终端的web</a></h2>
<p><a href="http://www.infoq.com/cn/author/%E8%88%92%E6%96%87%E4%BA%AE" title="舒文亮" target="_blank">舒文亮</a> 六月 26, 2013</p>
<p><a href="http://www.infoq.com/cn/presentations/across-device-web" title="跨终端的web" target="_blank"><img src="" alt=""></a></p>
<ul>
<li><a href="">更早的 &gt;</a></li>
</ul>
<p>语言 &amp; 开发</p>
<p><a href="http://www.infoq.com/cn/interviews/end-to-end-javascript" title="Juergen Fesslmeier谈端到端的JavaScript开发" target="_blank">Juergen Fesslmeier谈端到端的JavaScript开发</a></p>
<p><a href="http://www.infoq.com/cn/news/2013/07/mobilecloud-tfs" title="MobileCloud for TFS支持测试Windows Phone,Android,iOS及BlackBerry应用" target="_blank">MobileCloud for TFS支持测试Windows Phone,Android,iOS及BlackBerry应用</a></p>
<p><a href="http://www.infoq.com/cn/news/2013/07/baidu-salon39-summary" title="百度技术沙龙第39期回顾：前端快速开发实践（含资料下载）" target="_blank">百度技术沙龙第39期回顾：前端快速开发实践（含资料下载）</a></p>
<p>架构 &amp; 设计</p>
<p><a href="http://www.infoq.com/cn/news/2013/07/Native-Performance" title="内存与本机代码的性能" target="_blank">内存与本机代码的性能</a></p>
<p><a href="http://www.infoq.com/cn/articles/Design-Pattern-Automation" title="设计模式自动化" target="_blank">设计模式自动化</a></p>
<p><a href="http://www.infoq.com/cn/news/2013/07/WinRT-Devices" title="连接设备编程" target="_blank">连接设备编程</a>
过程 &amp; 实践</p>
<p><a href="http://www.infoq.com/cn/articles/Integrated-ALM" title="成功的根本—集成的ALM工具" target="_blank">成功的根本—集成的ALM工具</a></p>
<p><a href="http://www.infoq.com/cn/news/2013/06/tw-guoxiao-on-talents" title="ThoughtWorks全球CEO郭晓谈软件人才的招聘与培养" target="_blank">ThoughtWorks全球CEO郭晓谈软件人才的招聘与培养</a></p>
<p><a href="http://www.infoq.com/cn/articles/atdd-by-example-book" title="书评：验收测试驱动开发实践指南" target="_blank">书评：验收测试驱动开发实践指南</a></p>
<p>运维 &amp; 基础架构</p>
<p><a href="http://www.infoq.com/cn/news/2013/06/devops-in-traditional-enterprise" title="在传统企业中引入DevOps" target="_blank">在传统企业中引入DevOps</a></p>
<p><a href="http://www.infoq.com/cn/news/2013/06/dod-ams-day1-s-is-for-security" title="安全性——“DevOpS”中的S" target="_blank">安全性——“DevOpS”中的S</a></p>
<p><a href="http://www.infoq.com/cn/articles/atdd-by-example-book" title="书评：验收测试驱动开发实践指南" target="_blank">书评：验收测试驱动开发实践指南</a>
企业架构</p>
<p><a href="http://www.infoq.com/cn/articles/designing-a-world-at-your-fingertips-mobile-user-interfaces" title="设计指尖上的世界：移动用户界面一瞥" target="_blank">设计指尖上的世界：移动用户界面一瞥</a></p>
<p><a href="http://www.infoq.com/cn/news/2013/06/stratos-2" title="Stratos 2.0已发布，支持所有运行时环境和30个IaaS" target="_blank">Stratos 2.0已发布，支持所有运行时环境和30个IaaS</a></p>
<p><a href="http://www.infoq.com/cn/articles/iqiyi-cloud-push-practices" title="让1.5亿移动端用户第一时间获取消息" target="_blank">让1.5亿移动端用户第一时间获取消息</a>
<a href="">Close</a> E-mail  密码</p>
<p><a href="http://www.infoq.com/cn/social/googleLogin.action?fl=login" title="使用Google账号登录" target="_blank">使用Google账号登录</a> <a href="http://www.infoq.com/cn/social/liveLogin.action?fl=login" title="使用Microsoft账号登录" target="_blank">使用Microsoft账号登录</a>
<a href="">忘记密码？</a>
 InfoQ账号使用的E-mail 发送邮件</p>
<p><a href="">重新登录</a>
重新发送激活信息 重新发送</p>
<p><a href="">重新登录</a>
<a href="http://www.infoq.com/cn/reginit.action" target="_blank">没有用户名？</a></p>
<p><a href="http://www.infoq.com/cn/reginit.action" target="_blank">点击注册</a></p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/Java_多线程/">Java_多线程</a></li><li><a href="/categories/Java&J2EE/Java_多线程/并发/">并发</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/Java_多线程/" class="label label-success">Java_多线程</a><a href="/tags/并发/" class="label label-info">并发</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:41"datetime="2014-03-07 09:54:41"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-Java_多线程-并发--聊聊并发（五）——原子操作的实现原理/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-Java_多线程-并发--聊聊并发（五）——原子操作的实现原理" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>





<ul id="pagination" class="pagination pagination-lg">
  <li><a class="extend prev" href="/page/60/">&laquo;</a></li><li><a class="page-number" href="/">1</a></li><li><a class="page-number" href="/page/2/">2</a></li><li><span class="space">&hellip;</span></li><li><a class="page-number" href="/page/58/">58</a></li><li><a class="page-number" href="/page/59/">59</a></li><li><a class="page-number" href="/page/60/">60</a></li><li class="active"><li><span class="page-number current">61</span></li><li><a class="page-number" href="/page/62/">62</a></li><li><a class="page-number" href="/page/63/">63</a></li><li><a class="page-number" href="/page/64/">64</a></li><li><span class="space">&hellip;</span></li></li><li><a class="page-number" href="/page/164/">164</a></li><li><a class="page-number" href="/page/165/">165</a></li><li><a class="extend next" href="/page/62/">&raquo;</a></li>
  <div class="clearfix"></div>
</ul></div><!--wapper-->
       </div><!-- ID main-col END -->
       <aside id="sidebar" class="alignright col-sx-6 col-sm-4 col-md-3 col-lg-3">
<div id="widget_search" class="widget panel panel-primary">
    <form action="//google.com/search" method="get" accept-charset="utf-8">
  <div class="input-group">
    <input class="form-control" id="searchbox" type="search" name="q" results="0" placeholder="search">
    <span class="input-group-btn">
      <button class="btn btn-default" type="submit">Go!</button>
    </span>
    <input type="hidden" name="q" value="site:itsolife.com">
  </div>
</form>
</div>

<div id="widget_category" class="widget panel panel-primary">
  <div class="panel-heading">category</div>  <div data-src='category' class='ajax_widgets'>正在加载...</div>
</div>

<div id="widget_recent_posts" class="widget panel panel-primary">
  <div class="panel-heading">recent posts</div>  <div data-src='recent_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_tagcloud" class="widget panel panel-primary">
  <div class="panel-heading">tagcloud</div>  <div data-src='tagcloud' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_latest_update_posts" class="widget panel panel-primary">
  <div class="panel-heading">最近更新</div>  <div data-src='latest_update_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_recent_comments" class="widget panel panel-primary">
  <div class="panel-heading">recent comments</div>  

<div class="list-group-item ds-recent-comments" data-num-items="6" data-show-avatars="1" data-show-time="1" data-show-title="1" data-show-admin="1" data-excerpt-length="50"></div>



</div>

</aside>
       <div class="clearfix"></div>
     </div><!-- row END -->
  </div>
  <footer id="footer" class="container">
  <div class="panel panel-info">
  <section id='footer_widget'></section>  <div class="panel-footer">
  <div id="site-info">
    <span class='author'>
  
  &copy; 2014 RobinChia
  
    &nbsp;&nbsp;</span>
  
  <span id='analytics-51la'></span><span id='analytics-google'>
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-48559895-1']);
  _gaq.push(['_trackPageview']);
  _js2load.push({src:('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'});
</script></span><span id='analytics-cnzz'>
<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_5774006'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s17.cnzz.com/stat.php%3Fid%3D5774006%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>
</span><span id='analytics-baidu'>
<script>
var _hmt = _hmt || [];
_js2load.push({src:"//hm.baidu.com/hm.js?1442f50724afc42380b51f097c43082c"});
</script>
</span>  </div>
  <div id="copyright">Blog powered by <a href='http://zespia.tw/hexo/'><strong>hexo</strong></a> Theme <strong><a href='https://github.com/chenall/hexo-theme-chenall'>chenall</a></strong>(Some change in it)<span class="pull-right"> 更新时间: <em>2014-03-15 16:55:36</em></span></div>
</div>
<div class="clearfix"></div>


  </div>
  </footer>
  
        <script src="http://cdn.bootcss.com/jquery/1.10.2/jquery.min.js"></script>        
        <script src="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/js/bootstrap.min.js"></script>        
                
        <script src="http://cdn.bootcss.com/prettify/r298/prettify.min.js"></script>    <script type="text/javascript">
   var lang=["bsh", "c", "cc", "cpp", "cs", "csh", "cyc", "cv", "htm", "html",
    "java", "js", "m", "mxml", "perl", "pl", "pm", "py", "rb", "sh",
    "xhtml", "xml", "xsl"];
   var pretty_base='';
   $('script').each(function(){
	var c = $(this).attr('src');
	if (!c)
	    return;
	if (c.match(/(\/)?prettify(\.min)?\.js/i))
	{
	    var index = c.lastIndexOf('/');
	    if (index != -1)
		pretty_base = c.substr(0,index + 1);
	    return false;
	}
   })
   $('pre code').each(function(){
	var c = $(this).attr('class')
	if (!c)
	    return;
	c = c.match(/\s?(lang\-\w+)/i);
	if (c && lang.indexOf(c[1]) == -1)
	{
	    lang.push(c[1]);
	    $.getScript(pretty_base + c[1] + '.min.js');
	}
   })

    $(window).load(function(){
       $("pre").addClass("prettyprint");
       prettyPrint();
    })
</script>    
            <script type="text/javascript">
var duoshuoQuery = {short_name:"robinchia"};
_js2load.push({src:'http://static.duoshuo.com/embed.js',charset:'UTF-8'});
</script>
    
            <!--wumii_relatedItems-->
    
        <script src="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js"></script>    <script type="text/javascript">
(function($){
  $('.entry').each(function(i){
    $(this).find('img').each(function(){
      var alt = this.alt;

      if (alt){
        $(this).before('<span class="caption">' + alt + '</span>');
      }

      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox" rel="fancybox' + i + '" />');
    });
  });

  $('.fancybox').fancybox();
})(jQuery);
</script>    
        <script src="http://cdn.bootcss.com/mathjax/2.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>    <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>
    
<script type="text/javascript">
$('.ajax_widgets').each(function(){var src=$(this).attr('data-src');if(src)$(this).load('/widgets/'+src+'.html');});
$.each(_js2load,function(index,obj){loadjs(obj.src,obj.charset)});
</script>

<div id="scroll2top">
<img src="/scroll2top/arrow.png"/>
</div>
<script src="/scroll2top/scroll2top.min.js"></script>
<div id="winterland">
  <canvas></canvas>
</div>
<script src="/js/winterland.min.js"></script>

  </body>
</html>
