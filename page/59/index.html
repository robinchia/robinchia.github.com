
<!DOCTYPE HTML>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>The 59 Page | It so life</title>
<meta name="author" content="RobinChia">

<meta name="description" content="It so life">


<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<meta property="og:site_name" content="It so life"/>

<!--[if IE]><style>.testIE.IE{display:inline;}</style><![endif]-->
<!--[if lte IE 7]><link rel="stylesheet" href="/css/ie7.css" type="text/css"><![endif]-->
<!--[if (lt IE 9)&(gt IE 7)]><style>.testIE.IE8{display:inline;}</style><![endif]-->
<!--[if gt IE 8]><style>.testIE.IE9{display:inline;}</style><![endif]-->

<link href="/favicon.png" rel="icon">
<link rel="alternate" href="/atom.xml" title="It so life Feed" type="application/atom+xml">

<link rel="stylesheet" href="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/css/bootstrap.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/font-awesome/4.0.3/css/font-awesome.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/prettify/r298/prettify.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" type="text/css">
<link rel="stylesheet" href="/css/style.css" type="text/css">
<!--[if lt IE 9]>
   <style>article,aside,dialog,footer,header,section,footer,nav,figure,menu{display:block}</style>
   <script src="http://cdn.staticfile.org/html5shiv/r29/html5.min.js"></script>
   <script src="http://cdn.staticfile.org/respond.js/1.4.2/respond.min.js"></script>
<link href="http://cdn.staticfile.org/respond.js/1.4.2/respond-proxy.html" id="respond-proxy" rel="respond-proxy" />
<link href="/js/respond.proxy.gif" id="respond-redirect" rel="respond-redirect" />
<script src="/js/respond.proxy.js"></script>
   <script src="http://cdn.bootcss.com/selectivizr/1.0.2/selectivizr-min.js"></script>
<![endif]-->
<script type="text/javascript">
function loadjs(c,d){var a=document.createElement("script");a.async=!0;a.type="text/javascript";a.src=c;a.charset=d||"gbk";(document.getElementsByTagName("HEAD")[0]||document.getElementsByTagName("BODY")[0]).appendChild(a)};
var _protocol = (("https:" == document.location.protocol) ? " https://" : " http://");
var _js2load = [];
</script>

</head>
<body>
      <header id="header" class="container"><nav id="main-nav" class="navbar navbar-default navbar-fixed-top " role="navigation">
  <div class="container">
    <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
      <span class="sr-only">Toggle navigation</span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="/">It so life</a>
    </div>
    <div  class="collapse navbar-collapse">
      <ul  class="nav navbar-nav">
  
        <li><a href="/" title="Home">Home</a></li>      
        <li><a href="/about/" title="About">About</a></li>      
        <li><a href="/archives/" title="Archives">Archives</a></li>      
      <li class='dropdown'>
        <a class='dropdown-toggle' data-toggle='dropdown' href='#'>website<b class='caret'></b></a>
        <ul class='dropdown-menu pure-menu-selected'>
    
          <li><a href="//groups.google.com/forum/#!forum/pongba" title="TopLanguage">TopLanguage</a></li>    
          <li><a href="//itpub.net/" title="ITPub">ITPub</a></li>    
          <li><a href="//blog.jobbole.com/" title="Bole">Bole</a></li>    
          <li><a href="//nosql-database.org/" title="nosql">nosql</a></li>    
          <li><a href="//gitimmersion.googol.im/" title="Git">Git</a></li>    
        </ul>
      </li>
    
      </ul>
      <ul class="nav navbar-nav navbar-right">
      
        <li><a href="/atom.xml">RSS</a></li>
      
      
        <li><a href="https://twitter.com/robinchia">twitter</a></li>
      
      
      
      
        <li><a href="https://github.com/robinchia">github</a></li>
      
      </ul>
    </div>
  </div>
</nav>
<div class="clearfix"></div>
</header>
  <div id='content' class="container">
     <div class="page-header-wrapper">
      <!--[if lt IE 9]><div class="alert alert-warning alert-dismissable"><button type="button" class="close" data-dismiss="alert" aria-hidden="true">&times;</button><strong>提示:</strong>您的浏览器版本太低了,建议升级到 <strong><a href="http://windows.microsoft.com/zh-cn/internet-explorer/download-ie" title="IE9">IE9</a></strong> 以上,本站使用<a href="https://www.google.com/intl/zh-CN/chrome/">Chrome浏览器</a>可以获得最好的显示效果.</div><![endif]-->
      <div class="page-header"><h1 align="center"><big>It so life</big> </h1>
        <h5 align="center"><big>love as life</big></h5>
      </div>
     </div>
     <div class="row">
       <div id="main-col" class="alignleft col-sx-12 col-sm-8 col-md-9 col-lg-9">
      <section id='header_widget'></section>
          <div id="wrapper"><article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-proguard--Android23代码混淆proguard技术介绍/">Android 2.3 代码混淆proguard技术介绍</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:41.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-proguard--Android23代码混淆proguard技术介绍/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="android-2-3-proguard-">Android 2.3 代码混淆proguard技术介绍</h1>
<p><a href="http://blog.csdn.net/zengyangtech/article/details/6127600" target="_blank">Android 2.3 代码混淆proguard技术介绍</a></p>
<p>由于各种反编译工具的泛滥，作为Android程序员在2.3版本以前只能通过手动添加proguard来实现代码混淆</p>
<p>proguard这个工具是一个java代码混淆的工具</p>
<p>在2.3版本的sdk中 我们可以看到在android-sdk-windows/tools/下面多了一个proguard文件夹</p>
<p>google已经把proguard技术放在了android sdk里面 可以通过正常的编译方式也能实现代码混淆了</p>
<p><img src="" alt=""></p>
<p>可以看见新建一个工程里面有default.properties和proguard.cfg</p>
<p>默认的default.properties代码如下</p>
<p><strong>[c-sharp]</strong> <a href="http://blog.csdn.net/Zengyangtech/article/details/6127600#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/Zengyangtech/article/details/6127600#" title="copy" target="_blank">copy</a></p>
<ol>
<li>/# This file is automatically generated by Android Tools.  </li>
<li>/# Do not modify this file -- YOUR CHANGES WILL BE ERASED!  </li>
<li>/#  </li>
<li>/# This file must be checked in Version Control Systems.  </li>
<li>/#  </li>
<li>/# To customize properties used by the Ant build system use,  </li>
<li>/# &quot;build.properties&quot;, and override values to adapt the script to your  </li>
<li>/# project structure.  </li>
<li>/# Project target.  </li>
<li>target=android-9  </li>
</ol>
<p>我们可以看到proguard.cfg已经帮我们写好了优化代码脚本</p>
<p><strong>[c-sharp]</strong> <a href="http://blog.csdn.net/Zengyangtech/article/details/6127600#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/Zengyangtech/article/details/6127600#" title="copy" target="_blank">copy</a></p>
<ol>
<li>-optimizationpasses 5  </li>
<li>-dontusemixedcaseclassnames  </li>
<li>-dontskipnonpubliclibraryclasses  </li>
<li>-dontpreverify  </li>
<li>-verbose  </li>
<li>-optimizations !code/simplification/arithmetic,!field//<em>,!class/merging//</em>  </li>
<li>-keep public class /* extends android.app.Activity  </li>
<li>-keep public class /* extends android.app.Application  </li>
<li>-keep public class /* extends android.app.Service  </li>
<li>-keep public class /* extends android.content.BroadcastReceiver  </li>
<li>-keep public class /* extends android.content.ContentProvider  </li>
<li>-keep public class com.android.vending.licensing.ILicensingService  </li>
<li>-keepclasseswithmembernames class /* {  </li>
<li>native <methods>;  </li>
<li>}  </li>
<li>-keepclasseswithmembernames class /* {  </li>
<li>public <init>(android.content.Context, android.util.AttributeSet);  </li>
<li>}  </li>
<li>-keepclasseswithmembernames class /* {  </li>
<li>public <init>(android.content.Context, android.util.AttributeSet, int);  </li>
<li>}  </li>
<li>-keepclassmembers enum /* {  </li>
<li>public static /<em>/</em>[] values();  </li>
<li>public static /<em>/</em> valueOf(java.lang.String);  </li>
<li>}  </li>
<li>-keep class /* implements android.os.Parcelable {  </li>
<li>public static final android.os.Parcelable$Creator /*;  </li>
<li>}  </li>
</ol>
<p>从脚本中可以看到，混淆中保留了继承自Activity、Service、Application、BroadcastReceiver、ContentProvider等基本组件以及com.android.vending.licensing.ILicensingService</p>
<p>并保留了所有的Native变量名及类名，所有类中部分以设定了固定参数格式的构造函数，枚举等等。(详细信息请参考<proguard_path>/examples中的例子及注释。)</p>
<p>接下来 按照google帮助文档里说的</p>
<p><strong>[c-sharp]</strong> <a href="http://blog.csdn.net/Zengyangtech/article/details/6127600#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/Zengyangtech/article/details/6127600#" title="copy" target="_blank">copy</a></p>
<ol>
<li>To enable ProGuard so that it runs as part of an Ant or Eclipse build, set the proguard.config property in the <project_root>/default.properties file. The path can be an absolute path or a path relative to the project&#39;s root.  </li>
</ol>
<p>所以我们修改default.properties file</p>
<p>加上一句</p>
<p>proguard.config=proguard.cfg</p>
<p>如下</p>
<p><strong>[c-sharp]</strong> <a href="http://blog.csdn.net/Zengyangtech/article/details/6127600#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/Zengyangtech/article/details/6127600#" title="copy" target="_blank">copy</a></p>
<ol>
<li>/# This file is automatically generated by Android Tools.  </li>
<li>/# Do not modify this file -- YOUR CHANGES WILL BE ERASED!  </li>
<li>/#  </li>
<li>/# This file must be checked in Version Control Systems.  </li>
<li>/#  </li>
<li>/# To customize properties used by the Ant build system use,  </li>
<li>/# &quot;build.properties&quot;, and override values to adapt the script to your  </li>
<li>/# project structure.  </li>
<li>/# Project target.  </li>
<li>target=android-9  </li>
<li>proguard.config=proguard.cfg  </li>
</ol>
<p>然后正常的编译签名即可</p>
<p>然后用Android Tools生成一个发布的apk即可</p>
<p><img src="" alt=""></p>
<p>然后用反编译工具查看dex文件</p>
<p>最后导出反编译之后的混淆代码如下图</p>
<p><img src="" alt=""></p>
<p>是不是很轻松加愉快!希望各位程序员都能保护好自己的Android代码!
来源： <a href="[http://blog.csdn.net/Zengyangtech/article/details/6127600](http://blog.csdn.net/Zengyangtech/article/details/6127600)">[http://blog.csdn.net/Zengyangtech/article/details/6127600](http://blog.csdn.net/Zengyangtech/article/details/6127600)</a> </p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/proguard/">proguard</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/proguard/" class="label label-success">proguard</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:41"datetime="2014-03-07 09:54:41"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-proguard--Android23代码混淆proguard技术介绍/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-proguard--Android23代码混淆proguard技术介绍" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-proguard--开源混淆工具ProGuard配置详解及配置实例/">开源混淆工具ProGuard配置详解及配置实例</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:41.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-proguard--开源混淆工具ProGuard配置详解及配置实例/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-proguard-">开源混淆工具ProGuard配置详解及配置实例</h1>
<p>开源混淆工具ProGuard配置详解及配置实例</p>
<p>ProGuard是一个免费的java类文件压缩,优化,混淆器.它探测并删除没有使用的类,字段,方法和属性.它删除没有用的说明并使用字节码得到最大优化.它使用无意义的名字来重命名类,字段和方法.</p>
<p>ProGuard的作用: </p>
<p>1.创建紧凑的代码文档是为了更快的网络传输,快速装载和更小的内存占用. 
2.创建的程序和程序库很难使用反向工程. 
3.所以它能删除来自源文件中的没有调用的代码 
4.充分利用java6的快速加载的优点来提前检测和返回java6中存在的类文件. </p>
<p><strong>参数： </strong></p>
<p>-include {filename}    从给定的文件中读取配置参数 
-basedirectory {directoryname}    指定基础目录为以后相对的档案名称 
-injars {class_path}    指定要处理的应用程序jar,war,ear和目录 
-outjars {class_path}    指定处理完后要输出的jar,war,ear和目录的名称 
-libraryjars {classpath}    指定要处理的应用程序jar,war,ear和目录所需要的程序库文件 
-dontskipnonpubliclibraryclasses    指定不去忽略非公共的库类。 
-dontskipnonpubliclibraryclassmembers    指定不去忽略包可见的库类的成员。 
<strong>保留选项 </strong>
-keep {Modifier} {class_specification}    保护指定的类文件和类的成员 
-keepclassmembers {modifier} {class_specification}    保护指定类的成员，如果此类受到保护他们会保护的更好 
-keepclasseswithmembers {class_specification}    保护指定的类和类的成员，但条件是所有指定的类和类成员是要存在。 
-keepnames {class_specification}    保护指定的类和类的成员的名称（如果他们不会压缩步骤中删除） 
-keepclassmembernames {class_specification}    保护指定的类的成员的名称（如果他们不会压缩步骤中删除） 
-keepclasseswithmembernames {class_specification}    保护指定的类和类的成员的名称，如果所有指定的类成员出席（在压缩步骤之后） 
-printseeds {filename}    列出类和类的成员-keep选项的清单，标准输出到给定的文件 </p>
<p><strong>压缩 </strong>
-dontshrink    不压缩输入的类文件 
-printusage {filename} 
-whyareyoukeeping {class_specification}     </p>
<p><strong>优化 </strong>
-dontoptimize    不优化输入的类文件 
-assumenosideeffects {class_specification}    优化时假设指定的方法，没有任何副作用 
-allowaccessmodification    优化时允许访问并修改有修饰符的类和类的成员 </p>
<p><strong>混淆 </strong>
-dontobfuscate    不混淆输入的类文件 
-printmapping {filename} 
-applymapping {filename}    重用映射增加混淆 
-obfuscationdictionary {filename}    使用给定文件中的关键字作为要混淆方法的名称 
-overloadaggressively    混淆时应用侵入式重载 
-useuniqueclassmembernames    确定统一的混淆类的成员名称来增加混淆 
-flattenpackagehierarchy {package_name}    重新包装所有重命名的包并放在给定的单一包中 
-repackageclass {package_name}    重新包装所有重命名的类文件中放在给定的单一包中 
-dontusemixedcaseclassnames    混淆时不会产生形形色色的类名 
-keepattributes {attribute_name,...}    保护给定的可选属性，例如LineNumberTable, LocalVariableTable, SourceFile, Deprecated, Synthetic, Signature, and InnerClasses. 
-renamesourcefileattribute {string}    设置源文件中给定的字符串常量
<strong>Ant Example:</strong>
<!-- This Ant build file illustrates how to process applications,
     by including ProGuard-style configuration options.
     Usage: ant -f applications2.xml --></p>
<p><project name="Applications" default="obfuscate" basedir="../.."></p>
<p><target name="obfuscate">
  <taskdef resource="proguard/ant/task.properties"
           classpath="lib/proguard.jar" />
  <proguard>
    <!-- Specify the input jars, output jars, and library jars. -->
    -injars  in.jar
    -outjars out.jar
    -libraryjars ${java.home}/lib/rt.jar
    <!-- -libraryjars junit.jar    -->
    <!-- -libraryjars servlet.jar  -->
    <!-- -libraryjars jai_core.jar -->
    <!-- ...                       -->
    <!-- Save the obfuscation mapping to a file, and preserve line numbers. -->
    -printmapping out.map
    -renamesourcefileattribute SourceFile
    -keepattributes SourceFile,LineNumberTable
    <!-- Preserve all annotations. -->
    -keepattributes /<em>Annotation/</em>
    <!-- Preserve all public applications. -->
    -keepclasseswithmembers public class /<em> {
        public static void main(java.lang.String[]);
    }
    <!-- Preserve all native method names and the names of their classes. -->
    -keepclasseswithmembernames class /</em> {
        native &lt;methods&gt;;
    }
    <!-- Preserve the methods that are required in all enumeration classes. -->
    -keepclassmembers class /<em> extends java.lang.Enum {
        public static /</em>/<em>[] values();
        public static /</em>/<em> valueOf(java.lang.String);
    }
    <!-- Explicitly preserve all serialization members. The Serializable
         interface is only a marker interface, so it wouldn't save them.
         You can comment this out if your library doesn't use serialization.
         If your code contains serializable classes that have to be backward
         compatible, please refer to the manual. -->
    -keepclassmembers class /</em> implements java.io.Serializable {
        static final long serialVersionUID;
        static final java.io.ObjectStreamField[] serialPersistentFields;
        private void writeObject(java.io.ObjectOutputStream);
        private void readObject(java.io.ObjectInputStream);
        java.lang.Object writeReplace();
        java.lang.Object readResolve();
    }
    <!-- Your application may contain more items that need to be preserved;
         typically classes that are dynamically created using Class.forName -->
  </proguard>
</target>
</project>
来源： <a href="[http://www.kaiyuanba.cn/html/1/131/138/7820.htm](http://www.kaiyuanba.cn/html/1/131/138/7820.htm)">[http://www.kaiyuanba.cn/html/1/131/138/7820.htm](http://www.kaiyuanba.cn/html/1/131/138/7820.htm)</a> </p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/proguard/">proguard</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/proguard/" class="label label-success">proguard</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:41"datetime="2014-03-07 09:54:41"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-proguard--开源混淆工具ProGuard配置详解及配置实例/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-proguard--开源混淆工具ProGuard配置详解及配置实例" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--JRockit读书笔记I—Java代码的高效执行/">JRockit读书笔记I — Java代码的高效执行</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:41.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--JRockit读书笔记I—Java代码的高效执行/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="jrockit-i-java-">JRockit读书笔记I — Java代码的高效执行</h1>
<h1 id="-bluedavy-blog-https-blog-bluedavy-com-"><a href="https://blog.bluedavy.com/" target="_blank">BlueDavy之技术blog</a></h1>
<p>{互联网，OSGi，Java, High Scalability, High Performance,HA}</p>
<ul>
<li><a href="https://blog.bluedavy.com/" target="_blank">Home</a></li>
<li><a href="https://blog.bluedavy.com/?page_id=2" target="_blank">About</a></li>
<li><a href="https://blog.bluedavy.com/?page_id=81" target="_blank">Photos</a></li>
</ul>
<h2 id="-jrockit-i-java-https-blog-bluedavy-com-p-198-jrockit-i-java-"><a href="https://blog.bluedavy.com/?p=198" title="JRockit读书笔记I — Java代码的高效执行" target="_blank">JRockit读书笔记I — Java代码的高效执行</a></h2>
<p>Dec 16</p>
<p><a href="http://bluedavy.com/" title="Visit bluedavy’s website" target="_blank">bluedavy</a><a href="https://blog.bluedavy.com/?cat=13" title="View all posts in jvm" target="_blank">jvm</a> <a href="https://blog.bluedavy.com/?tag=java-code-generation" target="_blank">java code generation</a>, <a href="https://blog.bluedavy.com/?tag=java%e4%bb%a3%e7%a0%81%e6%89%a7%e8%a1%8c" target="_blank">java代码执行</a>, <a href="https://blog.bluedavy.com/?tag=jit" target="_blank">jit</a>, <a href="https://blog.bluedavy.com/?tag=jvm" target="_blank">jvm</a> <a href="&quot;Comment on JRockit读书笔记I — Java代码的高效执行&quot;">10 Comments</a>
《Oracle JRockit: The Definitive Guide》一书是由Oracle JRockit的两位资深开发人员写的，其中的Marcus Hirt更是JRockit Mission Control的leader，这本书详细的对Oracle JRockit进行了介绍，最突出的特点非常系统化的介绍了一个JVM通常是如何实现的，而JRockit这样一个极为优秀的JVM又是做了哪些优化，为什么做这些优化，这本书对于对JVM感兴趣的同学而言应该是必读的一本书，其实即使对于JVM兴趣不强的同学，里面的优化思路的介绍也是值得学习，本系列的blog主要是总结看这本书得到的一些收获，由于书中知识量巨大，因此得分成多篇blog来总结了。</p>
<p>书的第二章为：Adaptive Code Generation，在这章中作者向我们讲解了一个优秀的JVM是如何来实现代码的高效执行的，感兴趣的同学其实可以在不看下面blog内容之前，先考虑下如果是你做的话，你会怎么做来实现Java代码的高效执行呢，然后再对比下这章的内容，我想你能学到很多的，:)</p>
<p>用过Java的同学都知道，Java是通过javac将Java源码编译为class文件，然后通过ClassLoader装载此class文件，之后就可执行此class了，要最高效的执行这个class，最好的方法莫过于class文件直接就是机器码，这样直接执行就可以了，但Java是跨平台的，因此class文件就不能是机器码了。</p>
<p>由于class文件不是直接的机器码，要执行它最简单的方法就是采用纯粹的解释方式，解释方式由于每次都得将class文件中的指令翻译为对应的机器环境的指令，效率是很低的。</p>
<p>为了能更高效的执行，同时又保持跨平台的特性，另外一个方法就是在执行class时再将其翻译为对应的机器码，这个方法是比较靠谱的，因此无论是Hotspot、还是JRockit，都采用了这种方式，也就是大家熟知的JIT(Just In Time) Compiler。</p>
<p>OK，既然觉得在装载class后翻译成机器码去执行可以比较高效，那这个时候又会出现两种状况，是执行class的时候就立刻翻译成机器码，还是先用解释模式执行，然后到一定时机再翻译成机器码呢，之所以出现这两种状况，原因在于将class翻译为机器码是需要消耗时间的，因此如果执行class的时候就立刻翻译成机器码的话，也就会导致Java程序启动速度会比较慢，JRockit是这么认为的，JRockit的服务对象是server级应用，这类应用的特点是没那么在乎启动速度，而更在乎的是执行时的高效，而且如果执行的时候就立刻翻译成机器码的话，就意味着压根不需要实现解释器，因此JRockit采取的方法是在执行class时直接编译为机器码，而Hotspot由于需要同时支持client和server应用，对于client应用而言，启动速度非常重要，因此Hotspot采用的是先解释执行，到了一定时机后再翻译成机器码。</p>
<p>如果认为就这样就完成了Java代码的执行的实现，那就太小看JVM了，由于JVM能够知道代码运行的全部状况，自然还可以做出更多更出色的提升代码执行速度的优化，例如标量替换、更好的inline等，后面再来细说，因此这样就出现了一个状况，什么时候对哪些代码来做这些更猛的优化呢。</p>
<p>真正值得做更猛的优化的代码自然是所谓的”热点”代码，如何来发现哪些代码是热点代码呢，通常有三种方法：
1、方法调用计数器
方法调用计数器是常见的方式，hotspot采用的即为这种，这种方式不好的地方就在于计数器本身经常是cpu cache misses的，因此稍微会有点影响性能。
2、对线程进行采样
可采用软件或硬件方式来实现，软件方式实现不好的地方在于采样的时候需要暂停线程，好处是因为是采样，不需要对所有方法进行计数，硬件方式自然是最好的，但不是所有的硬件都支持的，支持的硬件中最典型的是intel IA-64的CPU。</p>
<p>在有了发现热点代码的方法后，接下来需要做的就是更猛的优化，有很多种，例如Java的代码中，通常会是接口方式的调用，但因为是接口方式的调用，所以其实默认情况下是不好做inline处理的，但JVM为了更高效的执行代码，如发现这代码为热点代码，那么就会做一些激进的优化，例如会假设这个接口只有一个实现，然后就可以直接将此实现对应的代码inline进来了（至于为什么inline后效率更高，这个请参考编译原理之类的书），这些激进优化同样适合于if、抛异常这些状况，当然，当激进优化的条件失效时，就会逆优化回到之前基本编译的代码。
而其他的更猛的优化还包括根据线程执行路径进行逃逸分析等，后面再专门写一篇blog来讲解下一些翻译为机器码的优化吧，其实大多都是编译原理的一些东西。</p>
<p>书中在介绍JRockit如何实现自己的JIT Compiler时，提到了Bytecode混淆以及bytecode优化，JRockit的态度是bytecode混淆时将name进行混淆是靠谱的，但如果对control flow进行混淆，就不太好了，因为这有可能会导致jit compile时的有些优化也做不了了，而bytecode优化，JRockit的态度是应该避免，因为没什么太大的意义，更主要的优化还是得靠jit compiler。</p>
<p>JRockit的JIT Compiler的实现和Hotspot另外一个很大的不同在于JRockit并未采用on-stack replacement，据JRockit的研究，这个没有太大必要，当然，对于编写benchmark代码时则要注意这个不同。</p>
<p>JIT Compiler在compile时还需要考虑的几个重点问题：
1、为GC提供必要的信息；
2、为查错提供必要的信息，例如代码的行数、变量名等；</p>
<p>从这章的内容可以看到，JRockit为了能够让Java代码能够高效的执行，是做出了非常多的努力的，也可以看到很多JRockit与Hotspot不同的地方，甚至可以看出Java代码的执行比C代码的执行高效都是有可能的，:)。</p>
<p><a href="https://blog.bluedavy.com/?p=187" target="_blank">学习JVM的References</a> <a href="https://blog.bluedavy.com/?p=200" target="_blank">Sun JDK 1.6内存管理</a></p>
<h3 id="10-comments-add-yours-">10 Comments <em>(<a href="">+add yours?</a>)</em></h3>
<ol>
<li><img src="https://secure.gravatar.com/avatar/67ffe1e5c1e1114f9cd68a1d6770d528?s=48&amp;d=&lt;path_to_url&gt;&amp;r=G" alt=""> h
<strong>Dec 16, 2010</strong> @ 18:57:35
我还没有读完……啊……</li>
<li><img src="https://secure.gravatar.com/avatar/ba40b479e7eca4475a6a9c9d992d89b2?s=48&amp;d=&lt;path_to_url&gt;&amp;r=G" alt=""> cauherk
<strong>Dec 16, 2010</strong> @ 20:44:19
JRockit好像不是在执行的时候进行jit 编译操作的吧。
打开jrmc的flight record，可以详细的看到jit编译的情况，其中并没有列出所有执行过的代码。</li>
<li><img src="https://secure.gravatar.com/avatar/2c48e9c1957bc1e99f7508ab1aca3bcb?s=48&amp;d=&lt;path_to_url&gt;&amp;r=G" alt=""> jianying
<strong>Dec 16, 2010</strong> @ 23:09:24
运行时的内联优化的确是可能比C更快的。</li>
<li><img src="https://secure.gravatar.com/avatar/5267242305332fe1affd9c4788191e1d?s=48&amp;d=&lt;path_to_url&gt;&amp;r=G" alt=""> <a href="http://bluedavy.com/" target="_blank">bluedavy</a>
<strong>Dec 17, 2010</strong> @ 09:49:57
@cauherk
JRockit是没有解释器的，如果不编译，你觉得它该怎么执行呢，具体可以看看书中的这章。
“When the method is first called, and control jumps to the trampoline, all it does is execute a call that tells JRockit that the real method needs to be generated.”</li>
<li><img src="https://secure.gravatar.com/avatar/5267242305332fe1affd9c4788191e1d?s=48&amp;d=&lt;path_to_url&gt;&amp;r=G" alt=""> <a href="http://bluedavy.com/" target="_blank">bluedavy</a>
<strong>Dec 17, 2010</strong> @ 09:51:28
@cauherk
flight recorder多数情况是采样机制和阀值机制，因此没包含所有执行过的代码也是正常的。</li>
<li><img src="https://secure.gravatar.com/avatar/67e4249167a3260501c410623b7e9a83?s=48&amp;d=&lt;path_to_url&gt;&amp;r=G" alt=""> hanguokai
<strong>Dec 17, 2010</strong> @ 13:46:45
对线程进行采样，采了什么，如何判断热点？</li>
<li><img src="https://secure.gravatar.com/avatar/5267242305332fe1affd9c4788191e1d?s=48&amp;d=&lt;path_to_url&gt;&amp;r=G" alt=""> <a href="http://bluedavy.com/" target="_blank">bluedavy</a>
<strong>Dec 17, 2010</strong> @ 21:39:38
@hanguokai
对线程进行采样，看看线程在执行些什么方法，采样多次后，自然也就知道哪里是热点了。</li>
<li><img src="https://secure.gravatar.com/avatar/f1e9ff94f7de8e17b9bc4c60a6b246ee?s=48&amp;d=&lt;path_to_url&gt;&amp;r=G" alt=""> Wen
<strong>Jan 11, 2011</strong> @ 22:33:45
您好！我是一名在校大学生，看了您写的这篇博文，很感兴趣。我现在正在做一个关于JVM优化的问题，刚刚开始，用C写了一个简单的Bytecode解释器，能够进行类型转换，算术逻辑运算，控制转移等工作，我和我的同学希望能够做出一个面向移动嵌入式平台的小型JVM，现在遇到一些问题，能请您给我们一些建议吗？
我们的问题主要集中在优化的方向选择上，现在大致有两条思路：一个是将bytecode反编译为一种中间语言（比如C），再通过中间语言编译机器码实现其功能，另一个是优化bytecode编译的方式。这是大体思路，我们对JVM的理解还很粗浅，见笑了~
谢谢！</li>
<li><img src="https://secure.gravatar.com/avatar/d9b07be4b9b23099363ffcab6305cf88?s=48&amp;d=&lt;path_to_url&gt;&amp;r=G" alt=""> RednaxelaFX
<strong>Jan 14, 2011</strong> @ 15:36:25
@Wen
这两种思路都有现成的实现，如果想参考的话资源非常丰富。
例如说，同样是应用在嵌入式领域的小型JVM，Squawk（<a href="http://labs.oracle.com/projects/dashboard.php?id=155" target="_blank">http://labs.oracle.com/projects/dashboard.php?id=155</a> <a href="https://squawk.dev.java.net/）就是先将Java字节码编译为C，然后再用C编译器编译为native" target="_blank"><a href="https://squawk.dev.java.net/）就是先将Java字节码编译为C，然后再用C编译器编译为native">https://squawk.dev.java.net/）就是先将Java字节码编译为C，然后再用C编译器编译为native</a></a> code，再部署到设备上的。
如果想在运行时直接将字节码编译为native code，那么嵌入式领域可以参考phoneME（<a href="https://phoneme.dev.java.net/）开源的CDC" target="_blank">https://phoneme.dev.java.net/）开源的CDC</a> HotSpot Implementation或者CLDC HotSpot Implementation。或者像是Google Android里的Dalvik虚拟机，里面也有JIT编译器，并且使用的是最近比较流行的trace-based compiler。</li>
</ol>
<p>对这些感兴趣的话，也欢迎来JavaEye的高级语言虚拟机圈子来讨论 ^_^
<a href="http://hllvm.group.javaeye.com/" target="_blank"><a href="http://hllvm.group.javaeye.com/">http://hllvm.group.javaeye.com/</a></a></p>
<h3 id="leave-a-reply">Leave a Reply</h3>
<p><a href="">Cancel</a></p>
<p>Name (required)</p>
<p>Mail (required)</p>
<p>Website</p>
<p><img src="&quot;CAPTCHA Image&quot;" alt="CAPTCHA Image"></p>
<p><a href="&quot;Refresh Image&quot;"><img src="" alt="Refresh Image"></a></p>
<p>CAPTCHA Code /*</p>
<p><style type='text/css'>/#submit {display:none;}</style><br /> <input name="submit" type="submit" id="submit-alt" tabindex="6" value="Submit Comment" /></p>
<p>July 2013 M T W T F S S <a href="https://blog.bluedavy.com/?m=201303" title="View posts for March 2013" target="_blank">« Mar</a>     1234567 891011121314 15161718192021 22232425262728 293031  </p>
<h3 id="categories">Categories</h3>
<ul>
<li><a href="https://blog.bluedavy.com/?cat=63" title="View all posts filed under Java" target="_blank">Java</a> (10)</li>
<li><a href="https://blog.bluedavy.com/?cat=13" title="View all posts filed under jvm" target="_blank">jvm</a> (19)</li>
<li><a href="https://blog.bluedavy.com/?cat=56" title="View all posts filed under NoSQL" target="_blank">NoSQL</a> (7)</li>
<li><a href="https://blog.bluedavy.com/?cat=4" title="View all posts filed under SOA" target="_blank">SOA</a> (1)</li>
<li><a href="https://blog.bluedavy.com/?cat=11" title="关于《分布式Java应用：基础与实践》书部分章节的公开、书内容的纠错以及补充完善。" target="_blank">书:分布式Java应用</a> (5)</li>
<li><a href="https://blog.bluedavy.com/?cat=6" title="View all posts filed under 互联网" target="_blank">互联网</a> (5)</li>
<li><a href="https://blog.bluedavy.com/?cat=46" title="View all posts filed under 产品总结" target="_blank">产品总结</a> (1)</li>
<li><a href="https://blog.bluedavy.com/?cat=18" title="View all posts filed under 优化案例" target="_blank">优化案例</a> (1)</li>
<li><a href="https://blog.bluedavy.com/?cat=12" title="View all posts filed under 圆桌交流" target="_blank">圆桌交流</a> (2)</li>
<li><a href="https://blog.bluedavy.com/?cat=8" title="View all posts filed under 容量规划" target="_blank">容量规划</a> (2)</li>
<li><a href="https://blog.bluedavy.com/?cat=97" title="View all posts filed under 迁户口" target="_blank">迁户口</a> (1)</li>
<li><a href="https://blog.bluedavy.com/?cat=52" title="View all posts filed under 高可用" target="_blank">高可用</a> (1)</li>
<li><a href="https://blog.bluedavy.com/?cat=3" title="View all posts filed under 高并发" target="_blank">高并发</a> (3)</li>
<li><p><a href="https://blog.bluedavy.com/?cat=1" title="关于性能优化方面的一些东西。" target="_blank">高性能</a> (2)</p>
<h3 id="recent-comments">Recent Comments</h3>
</li>
<li><p><a href="http://code1.riaos.com/?p=5030138" target="_blank">JVM调优 | code1（code1.riaos.com）</a> on <a href="https://blog.bluedavy.com/?p=70&amp;cpage=1#comment-16520" target="_blank">说说MaxTenuringThreshold这个参数</a></p>
</li>
<li><a href="http://architecture1.riaos.com/?p=3063358" target="_blank">JVM调优 | architecture（riaos.com）</a> on <a href="https://blog.bluedavy.com/?p=70&amp;cpage=1#comment-16519" target="_blank">说说MaxTenuringThreshold这个参数</a></li>
<li><a href="http://bluedavy.com/" target="_blank">bluedavy</a> on <a href="https://blog.bluedavy.com/?p=409&amp;cpage=1#comment-16462" target="_blank">一个Java应用频繁抛异常导致cpu us诡异现象的案例</a></li>
<li>xiaobo on <a href="https://blog.bluedavy.com/?p=409&amp;cpage=1#comment-16460" target="_blank">一个Java应用频繁抛异常导致cpu us诡异现象的案例</a></li>
<li><a href="http://bluedavy.com/" target="_blank">bluedavy</a> on <a href="https://blog.bluedavy.com/?p=409&amp;cpage=1#comment-16459" target="_blank">一个Java应用频繁抛异常导致cpu us诡异现象的案例</a></li>
</ul>
<h3 id="tags">Tags</h3>
<p><a href="https://blog.bluedavy.com/?tag=btrace" title="2 topics" target="_blank">btrace</a> <a href="https://blog.bluedavy.com/?tag=c1" title="1 topic" target="_blank">c1</a> <a href="https://blog.bluedavy.com/?tag=c2" title="1 topic" target="_blank">c2</a> <a href="https://blog.bluedavy.com/?tag=deflater" title="1 topic" target="_blank">Deflater</a> <a href="https://blog.bluedavy.com/?tag=facebook" title="2 topics" target="_blank">facebook</a> <a href="https://blog.bluedavy.com/?tag=gc" title="4 topics" target="_blank">gc</a> <a href="https://blog.bluedavy.com/?tag=gc-tuning" title="2 topics" target="_blank">gc tuning</a> <a href="https://blog.bluedavy.com/?tag=grizzly" title="2 topics" target="_blank">Grizzly</a> <a href="https://blog.bluedavy.com/?tag=hbase" title="6 topics" target="_blank">HBase</a> <a href="https://blog.bluedavy.com/?tag=hotspot" title="1 topic" target="_blank">hotspot</a> <a href="https://blog.bluedavy.com/?tag=inflater" title="1 topic" target="_blank">Inflater</a> <a href="https://blog.bluedavy.com/?tag=interpreter" title="1 topic" target="_blank">interpreter</a> <a href="https://blog.bluedavy.com/?tag=javac" title="1 topic" target="_blank">javac</a> <a href="https://blog.bluedavy.com/?tag=java-code-generation" title="1 topic" target="_blank">java code generation</a> <a href="https://blog.bluedavy.com/?tag=javaone" title="4 topics" target="_blank">JavaOne</a> <a href="https://blog.bluedavy.com/?tag=javaone-general-technical-session" title="1 topic" target="_blank">javaone general technical session</a> <a href="https://blog.bluedavy.com/?tag=java%e4%bb%a3%e7%a0%81%e6%89%a7%e8%a1%8c" title="1 topic" target="_blank">java代码执行</a> <a href="https://blog.bluedavy.com/?tag=java-%e5%b9%b6%e5%8f%91" title="1 topic" target="_blank">Java 并发</a> <a href="https://blog.bluedavy.com/?tag=jit" title="1 topic" target="_blank">jit</a> <a href="https://blog.bluedavy.com/?tag=jvm" title="12 topics" target="_blank">jvm</a> <a href="https://blog.bluedavy.com/?tag=memory-management" title="1 topic" target="_blank">memory management</a> <a href="https://blog.bluedavy.com/?tag=native-memory-leak" title="1 topic" target="_blank">Native Memory Leak</a> <a href="https://blog.bluedavy.com/?tag=nosql" title="2 topics" target="_blank">NoSQL</a> <a href="https://blog.bluedavy.com/?tag=oom" title="1 topic" target="_blank">oom</a> <a href="https://blog.bluedavy.com/?tag=oracle-keynote" title="1 topic" target="_blank">oracle keynote</a> <a href="https://blog.bluedavy.com/?tag=pessimism-policy" title="1 topic" target="_blank">pessimism policy</a> <a href="https://blog.bluedavy.com/?tag=references" title="1 topic" target="_blank">references</a> <a href="https://blog.bluedavy.com/?tag=rpc" title="2 topics" target="_blank">RPC</a> <a href="https://blog.bluedavy.com/?tag=serial-gc" title="1 topic" target="_blank">serial gc</a> <a href="https://blog.bluedavy.com/?tag=soa" title="2 topics" target="_blank">SOA</a> <a href="https://blog.bluedavy.com/?tag=sun-jdk" title="1 topic" target="_blank">sun jdk</a> <a href="https://blog.bluedavy.com/?tag=sun-jdk-oom" title="1 topic" target="_blank">sun jdk oom</a> <a href="https://blog.bluedavy.com/?tag=web%e5%ae%b9%e9%87%8f%e8%a7%84%e5%88%92%e7%9a%84%e8%89%ba%e6%9c%af" title="1 topic" target="_blank">Web容量规划的艺术</a> <a href="https://blog.bluedavy.com/?tag=yuanzhuo" title="1 topic" target="_blank">yuanzhuo</a> <a href="https://blog.bluedavy.com/?tag=%e4%b9%a6" title="1 topic" target="_blank">书:分布式Java应用</a> <a href="https://blog.bluedavy.com/?tag=%e4%b9%a6%e8%af%84" title="1 topic" target="_blank">书评</a> <a href="https://blog.bluedavy.com/?tag=%e4%ba%92%e8%81%94%e7%bd%91%e6%8a%80%e6%9c%af" title="1 topic" target="_blank">互联网技术</a> <a href="https://blog.bluedavy.com/?tag=%e4%ba%a4%e6%b5%81" title="1 topic" target="_blank">交流</a> <a href="https://blog.bluedavy.com/?tag=%e5%86%85%e5%ad%98%e7%ae%a1%e7%90%86" title="1 topic" target="_blank">内存管理</a> <a href="https://blog.bluedavy.com/?tag=%e5%88%86%e5%b8%83%e5%bc%8fjava%e5%ba%94%e7%94%a8" title="2 topics" target="_blank">分布式Java应用</a> <a href="https://blog.bluedavy.com/?tag=%e5%9c%86%e6%a1%8c%e4%ba%a4%e6%b5%81" title="1 topic" target="_blank">圆桌交流</a> <a href="https://blog.bluedavy.com/?tag=%e5%ae%b9%e9%87%8f%e8%a7%84%e5%88%92" title="2 topics" target="_blank">容量规划</a> <a href="https://blog.bluedavy.com/?tag=%e6%82%b2%e8%a7%82%e7%ad%96%e7%95%a5" title="3 topics" target="_blank">悲观策略</a> <a href="https://blog.bluedavy.com/?tag=%e6%9c%8d%e5%8a%a1%e6%a1%86%e6%9e%b6" title="1 topic" target="_blank">服务框架</a> <a href="https://blog.bluedavy.com/?tag=%e7%a1%85%e8%b0%b7%e5%85%ac%e5%8f%b8" title="1 topic" target="_blank">硅谷公司</a></p>
<h3 id="-">订阅</h3>
<p><a href="http://feed.feedsky.com/bluedavy" target="_blank"><img src="" alt="feedsky"></a>
<a href="http://www.zhuaxia.com/add_channel.php?url=http://feed.feedsky.com/bluedavy" target="_blank"><img src="" alt="抓虾"></a>
<a href="http://fusion.google.com/add?feedurl=http://feed.feedsky.com/bluedavy" target="_blank"><img src="" alt="google reader"></a>
<a href="http://www.xianguo.com/subscribe.php?url=http://feed.feedsky.com/bluedavy" target="_blank"><img src="" alt="鲜果"></a>
<a href="http://9.douban.com/reader/subscribe?url=http://feed.feedsky.com/bluedavy" target="_blank"><img src="" alt="九点"></a></p>
<h3 id="-">推荐书籍</h3>
<h3 id="my-book">My Book</h3>
<p><a href="http://book.douban.com/subject/4848587/" title="分布式Java应用：基础与实践" target="_blank"><img src="" alt=""></a> <a href="http://book.douban.com/subject/3843896/" title="OSGi原理与最佳实践" target="_blank"><img src="" alt=""></a>
© <a href="https://blog.bluedavy.com/" target="_blank">BlueDavy之技术blog</a> 2013</p>
<p><a href="http://icondock.com/" target="_blank">Icons</a> &amp; <a href="http://www.ndesign-studio.com/wp-themes" target="_blank">Wordpress Theme</a> by <a href="http://www.ndesign-studio.com/" target="_blank">N.Design</a></p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/JVM/">JVM</a></li></span></span> | <span class="tags">Tagged <a href="/tags/JVM/" class="label label-primary">JVM</a><a href="/tags/Java&J2EE/" class="label label-success">Java&J2EE</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:41"datetime="2014-03-07 09:54:41"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-JVM--JRockit读书笔记I—Java代码的高效执行/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-JVM--JRockit读书笔记I—Java代码的高效执行" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-内存分析--Java内存泄露监控工具-JVM监控工具介绍jstack-jconsole-jinfo-/">Java 内存泄露监控工具</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:41.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-内存分析--Java内存泄露监控工具-JVM监控工具介绍jstack-jconsole-jinfo-/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="java-jvm-jstack-jconsole-jinfo-jmap-jdb-jstat">Java 内存泄露监控工具-- JVM监控工具介绍jstack, jconsole, jinfo, jmap, jdb, jstat</h1>
<hr>
<p><strong>jstack </strong>-- 如果java程序崩溃生成core文件，jstack工具可以用来获得core文件的java stack和native stack的信息，从而可以轻松地知道java程序是如何崩溃和在程序何处发生问题。另外，jstack工具还可以附属到正在运行的java程序中，看到 当时运行的java程序的java stack和native stack的信息, 如果现在运行的java程序呈现hung的状态，jstack是非常有用的。目前只有在Solaris和Linux的JDK版本里面才有。</p>
<p><strong>jconsole </strong>– jconsole是基于<a href="http://java.chinaitlab.com/" target="_blank">Java </a>Management Extensions (JMX)的实时图形化监测工具，这个工具利用了内建到JVM里面的JMX指令来提供实时的性能和资源的监控，包括了<a href="http://java.chinaitlab.com/" target="_blank">Java </a>程序的内存使用，Heap size, 线程的状态，类的分配状态和空间使用等等。</p>
<p><strong>jinfo </strong>– jinfo可以从core文件里面知道崩溃的Java应用程序的配置信息，目前只有在Solaris和Linux的JDK版本里面才有。</p>
<p><strong>jmap </strong>– jmap 可以从core文件或进程中获得内存的具体匹配情况，包括Heap size, Perm size等等，目前只有在Solaris和Linux的JDK版本里面才有。</p>
<p><strong>jdb </strong>– jdb 用来对core文件和正在运行的Java进程进行实时地调试，里面包含了丰富的命令帮助您进行调试，它的功能和Sun studio里面所带的dbx非常相似，但 jdb是专门用来针对Java应用程序的。</p>
<p><strong>jstat </strong>– jstat利用了JVM内建的指令对Java应用程序的资源和性能进行实时的命令行的监控，包括了对Heap size和垃圾回收状况的监控等等。</p>
<p><strong>jps </strong>– jps是用来查看JVM里面所有进程的具体状态, 包括进程ID，进程启动的路径等等。 </p>
<p><a href="http://java.sun.com/j2se/1.5.0/docs/tooldocs/share/jstatd.html" target="_blank"><strong>jstatd</strong> </a>
启动jvm监控服务。它是一个基于rmi的应用，向远程机器提供本机jvm应用程序的信息。默认端口1099。
实例：jstatd -J-Djava.security.policy=my.policy
my.policy文件需要自己建立，内如如下：
grant codebase &quot;file:$JAVA_HOME/lib/tools.jar&quot; {
permission java.security.AllPermission;
};
这是安全策略文件，因为jdk对jvm做了jaas的安全检测，所以我们必须设置一些策略，使得jstatd被允许作网络操作</p>
<p>上面的操作没有通过，出现：</p>
<p>Could not create remote object
access denied (java.util.PropertyPermission java.rmi.server.ignoreSubClasses write)
java.security.AccessControlException: access denied (java.util.PropertyPermission java.rmi.server.ignoreSubClasses write)
at java.security.AccessControlContext.checkPermission(AccessControlContext.java:323)
at java.security.AccessController.checkPermission(AccessController.java:546)
at java.lang.SecurityManager.checkPermission(SecurityManager.java:532)
at java.lang.System.setProperty(System.java:727)
at sun.tools.jstatd.Jstatd.main(Jstatd.java:122)</p>
<p>create in your usr/java/bin the jstatd.all.policy file, with the content must be</p>
<ol>
<li>grant codebase &quot;file:${java.home}/../lib/tools.jar&quot; {  </li>
<li>permission java.security.AllPermission;  </li>
<li>}; </li>
</ol>
<p><strong><a href="http://java.sun.com/j2se/1.5.0/docs/tooldocs/share/jps.html" target="_blank">jps </a></strong>
列出所有的jvm实例
实例：
jps
列出本机所有的jvm实例
jps 192.168.0.77
列出远程服务器192.168.0.77机器所有的jvm实例，采用rmi协议，默认连接端口为1099
（前提是远程服务器提供jstatd服务）
输出内容如下：
jones@jones:~/data/ebook/java/j2se/jdk_gc$ jps
6286 Jps
6174  Jstat
<strong>jconsole </strong>
一个图形化界面，可以观察到java进程的gc，class，内存等信息。虽然比较直观，但是个人还是比较倾向于使用jstat命令（在最后一部分会对jstat作详细的介绍）。
<strong><a href="http://java.sun.com/j2se/1.5.0/docs/tooldocs/share/jinfo.html" target="_blank">jinfo </a></strong>（linux下特有）
观察运行中的java程序的运行环境参数：参数包括Java System属性和JVM命令行参数
实例：jinfo 2083
其中2083就是java进程id号，可以用jps得到这个id号。
输出内容太多了，不在这里一一列举，大家可以自己尝试这个命令。
<strong><a href="http://java.sun.com/j2se/1.5.0/docs/tooldocs/share/jstack.html" target="_blank">jstack </a></strong>（linux下特有）
可以观察到jvm中当前所有线程的运行情况和线程当前状态
jstack 2083
输出内容如下：
<img src="" alt=""> 
<strong><a href="http://java.sun.com/j2se/1.5.0/docs/tooldocs/share/jmap.html" target="_blank">jmap </a></strong>（linux下特有，也是很常用的一个命令）
观察运行中的jvm物理内存的占用情况。
参数如下：<strong>-heap</strong> ：打印jvm heap的情况
<strong>-histo：</strong> 打印jvm heap的直方图。其输出信息包括类名，对象数量，对象占用大小。
<strong>-histo：live ：</strong> 同上，但是只答应存活对象的情况
<strong>-permstat：</strong> 打印permanent generation heap情况
命令使用：
jmap -heap 2083
可以观察到New Generation（Eden Space，From Space，To Space）,tenured generation,Perm Generation的内存使用情况
输出内容：
<img src="" alt=""> 
jmap -histo 2083 ｜ jmap -histo:live 2083
可以观察heap中所有对象的情况（heap中所有生存的对象的情况）。包括对象数量和所占空间大小。
输出内容：
<img src="" alt=""> 
写个脚本，可以很快把占用heap最大的对象找出来，对付内存泄漏特别有效。
<strong><a href="http://java.sun.com/j2se/1.5.0/docs/tooldocs/share/jstat.html" target="_blank">jstat </a>
</strong>最后要重点介绍下这个命令。
这是jdk命令中比较重要，也是相当实用的一个命令，可以观察到classloader，compiler，gc相关信息
具体参数如下：
-class：统计class loader行为信息
-compile：统计编译行为信息
-gc：统计jdk gc时heap信息
-gccapacity：统计不同的generations（不知道怎么翻译好，包括新生区，老年区，permanent区）相应的heap容量情况
-gccause：统计gc的情况，（同-gcutil）和引起gc的事件
-gcnew：统计gc时，新生代的情况
-gcnewcapacity：统计gc时，新生代heap容量
-gcold：统计gc时，老年区的情况
-gcoldcapacity：统计gc时，老年区heap容量
-gcpermcapacity：统计gc时，permanent区heap容量
-gcutil：统计gc时，heap情况
-printcompilation：不知道干什么的，一直没用过。
一般比较常用的几个参数是：
jstat -class 2083 1000 10 （每隔1秒监控一次，一共做10次）
输出内容含义如下：</p>
<p>Loaded Number of classes loaded. Bytes Number of Kbytes loaded. Unloaded Number of classes unloaded. Bytes Number of Kbytes unloaded. Time Time spent performing class load and unload operations.
jstat -gc 2083 2000 20（每隔2秒监控一次，共做10）
输出内容含义如下：
S0C Current survivor space 0 capacity (KB). EC Current eden space capacity (KB). EU Eden space utilization (KB). OC Current old space capacity (KB). OU Old space utilization (KB). PC Current permanent space capacity (KB). PU Permanent space utilization (KB). YGC Number of young generation GC Events. YGCT Young generation garbage collection time. FGC Number of full GC events. FGCT Full garbage collection time. GCT Total garbage collection time.
输出内容：
<img src="" alt="">
如果能熟练运用这些命令，尤其是在linux下，那么完全可以代替jprofile等监控工具了，谁让它收费呢。呵呵。
用命令的好处就是速度快，并且辅助于其他命令，比如grep gawk sed等，可以组装多种符合自己需求的工具。</p>
<h1 id="-u-jps-"><a href=""></a>u               jps 的用法</h1>
<p>用来查看 JVM 里面所有进程的具体状态 , 包括进程 ID ，进程启动的路径等等。 与 unix 上的 ps 类似，用来显示本地的java 进程，可以查看本地运行着几个 java 程序，并显示他们的进程号。</p>
<p><strong>[root@localhost ~]/# jps</strong></p>
<p>25517 Jps</p>
<p>25444 Bootstrap</p>
<h1 id="-u-jstack-"><a href=""></a>u               jstack 的用法</h1>
<p>如果 java 程序崩溃生成 core 文件， jstack 工具可以用来获得 core 文件的 java stack 和 native stack 的信息，从而可以轻松地知道 java 程序是如何崩溃和在程序何处发生问题。另外， jstack 工具还可以附属到正在运行的 java 程序中，看到当时运行的 java 程序的 java stack 和 native stack 的信息 , 如果现在运行的 java 程序呈现 hung 的状态， jstack 是非常有用的。目前只有在 Solaris 和 Linux 的 JDK 版本里面才有。</p>
<p><strong>[root@localhost bin]/# jstack **</strong>25444**</p>
<p>Attaching to process ID 25917, please wait...</p>
<p>Debugger attached successfully.</p>
<p>Client compiler detected.</p>
<p>JVM version is 1.5.0_08-b03</p>
<p>Thread 25964: (state = BLOCKED)</p>
<p>Error occurred during stack walking:</p>
<p>sun.jvm.hotspot.debugger.DebuggerException: sun.jvm.hotspot.debugger.DebuggerException: get_thread_regs failed for a lwp</p>
<pre><code>    at sun.jvm.hotspot.debugger.linux.LinuxDebuggerLocal$LinuxDebuggerLocalWorkerThread.execute(LinuxDebuggerLocal.java:134)

    at sun.jvm.hotspot.debugger.linux.LinuxDebuggerLocal.getThreadIntegerRegisterSet(LinuxDebuggerLocal.java:437)

    at sun.jvm.hotspot.debugger.linux.LinuxThread.getContext(LinuxThread.java:48)

    at
</code></pre><h1 id="-u-jstat-"><a href=""></a>u               jstat 的用法</h1>
<p>用以判断JVM 是否存在内存问题呢？如何判断JVM 垃圾回收是否正常？一般的top 指令基本上满足不了这样的需求，因为它主要监控的是总体的系统资源，很难定位到java 应用程序。</p>
<p>Jstat 是JDK 自带的一个轻量级小工具。全称“Java Virtual Machine statistics monitoring tool” ，它位于java 的bin 目录下，主要利用JVM 内建的指令对Java 应用程序的资源和性能进行实时的命令行的监控，包括了对Heap size 和垃圾回收状况的监控。可见，Jstat 是轻量级的、专门针对JVM 的工具，非常适用。由于JVM 内存设置较大，图中百分比变化不太明显</p>
<p>一个极强的监视 VM 内存工具。可以用来监视 VM 内存内的各种堆和非堆的大小及其内存使用量。</p>
<p>jstat 工具特别强大，有众多的可选项，详细查看堆内各个部分的使用量，以及加载类的数量。使用时，需加上查看进程的进程 id ，和所选参数。</p>
<p>语法结构：</p>
<p>Usage: jstat -help|-options</p>
<pre><code>   jstat -&lt;option&gt; [-t] [-h&lt;lines&gt;] &lt;vmid&gt; [&lt;interval&gt; [&lt;count&gt;]]
</code></pre><p>参数解释：</p>
<p>Options — 选项，我们一般使用 -gcutil 查看gc 情况</p>
<p>vmid    — VM 的进程号，即当前运行的java 进程号</p>
<p>interval– 间隔时间，单位为秒或者毫秒</p>
<p>count   — 打印次数，如果缺省则打印无数次</p>
<p>S0  — Heap 上的 Survivor space 0 区已使用空间的百分比 
S1  — Heap 上的 Survivor space 1 区已使用空间的百分比 
E   — Heap 上的 Eden space 区已使用空间的百分比 
O   — Heap 上的 Old space 区已使用空间的百分比 
P   — Perm space 区已使用空间的百分比 
YGC — 从应用程序启动到采样时发生 Young GC 的次数 
YGCT– 从应用程序启动到采样时 Young GC 所用的时间( 单位秒 )
FGC — 从应用程序启动到采样时发生 Full GC 的次数 
FGCT– 从应用程序启动到采样时 Full GC 所用的时间( 单位秒 )
GCT — 从应用程序启动到采样时用于垃圾回收的总时间( 单位秒)</p>
<p>实例使用1 ：</p>
<p><strong>[root@localhost bin]/# jstat -gcutil 25444</strong></p>
<p>  S0      S1     E      O      P     YGC     YGCT    FGC    FGCT     GCT</p>
<p>  11.63   0.00    56.46  66.92  98.49 162    0.248    6       0.331    0.579</p>
<p>实例使用 2 ：</p>
<p><strong>[root@localhost bin]/# jstat -gcutil 25444 1000 5</strong></p>
<p>  S0     S1     E      O      P     YGC     YGCT    FGC    FGCT     GCT</p>
<p>  73.54   0.00  99.04  67.52  98.49    166    0.252     6    0.331    0.583</p>
<p>  73.54   0.00  99.04  67.52  98.49    166    0.252     6    0.331    0.583</p>
<p>  73.54   0.00  99.04  67.52  98.49    166    0.252     6    0.331    0.583</p>
<p>  73.54   0.00  99.04  67.52  98.49    166    0.252     6    0.331    0.583</p>
<p>  73.54   0.00  99.04  67.52  98.49    166    0.252     6    0.331    0.583</p>
<p>我们可以看到，5 次young gc 之后，垃圾内存被从Eden space 区(E) 放入了Old space 区(O) ，并引起了百分比的变化，导致Survivor space 使用的百分比从73.54%(S0) 降到0%(S1) 。有效释放了内存空间。绿框中，我们可以看到，一次full gc 之后，Old space 区(O) 的内存被回收，从99.05% 降到67.52% 。</p>
<p>图中同时打印了young gc 和full gc 的总次数、总耗时。而，每次young gc 消耗的时间，可以用相间隔的两行YGCT 相减得到。每次full gc 消耗的时间，可以用相隔的两行FGCT 相减得到。例如红框中表示的第一行、第二行之间发生了1次young gc ，消耗的时间为0.252-0.252 ＝0.0 秒。</p>
<p>常驻内存区(P) 的使用率，始终停留在98.49% 左右，说明常驻内存没有突变，比较正常。</p>
<p>如果young gc 和full gc 能够正常发生，而且都能有效回收内存，常驻内存区变化不明显，则说明java 内存释放情况正常，垃圾回收及时，java 内存泄露的几率就会大大降低。但也不能说明一定没有内存泄露。</p>
<p>GCT 是YGCT 和FGCT 的时间总和。</p>
<p>以上，介绍了Jstat 按百分比查看gc 情况的功能。其实，它还有功能，例如加载类信息统计功能、内存池信息统计功能等，那些是以绝对值的形式打印出来的，比较少用，在此就不做介绍。</p>
<p><strong>[root@localhost bin]/# ps -ef | grep java</strong></p>
<p>root     25917     1  2 23:23 pts /2    00:00:05 /usr/local/jdk1.5/bin/java -Djava.endorsed.dirs=/usr/local/jakarta-tomcat-5.0.30/common/endorsed -classpath /usr/local/jdk1.5/lib/tools.jar:/usr/local/jakarta-tomcat-5.0.30/bin/bootstrap.jar:/usr/local/jakarta-tomcat-5.0.30/bin/commons-logging-api.jar -Dcatalina.base=/usr/local/jakarta-tomcat-5.0.30 -Dcatalina.home=/usr/local/jakarta-tomcat-5.0.30 -Djava.io.tmpdir=/usr/local/jakarta-tomcat-5.0.30/temp org.apache.catalina.startup.Bootstrap start</p>
<p>jstat -class pid: 显示加载 class 的数量，及所占空间等信息。</p>
<p>实例使用3 ：</p>
<p><strong>[root@localhost bin]/# jstat -class 25917</strong></p>
<p>Loaded  Bytes  Unloaded  Bytes     Time</p>
<p>2629     2916.8       29   24.6     0.90</p>
<p>jstat -compiler pid: 显示 VM 实时编译的数量等信息。</p>
<p>实例使用 4 ：</p>
<p><strong>[root@localhost bin]/# jstat -compiler 25917</strong></p>
<p>Compiled Failed Invalid   Time   FailedType FailedMethod</p>
<pre><code> 768      0       0   0.70             0
</code></pre><p>jstat –gccapacity : 可以显示， VM 内存中三代（ young,old,perm ）对象的使用和占用大小，如： PGCMN 显示的是最小 perm 的内存使用量， PGCMX 显示的是 perm 的内存最大使用量， PGC 是当前新生成的 perm 内存占用量， PC 是但前 perm 内存占用量。其他的可以根据这个类推， OC 是 old 内纯的占用量。</p>
<p><strong>[root@localhost bin]/# jstat -gccapacity 25917</strong></p>
<p>NGCMN       640.0</p>
<p>NGCMX       4992.0</p>
<p>NGC         832.0</p>
<p>S0C         64.0</p>
<p>S1C         64.0</p>
<p>EC          704.0</p>
<p>OGCMN       1408.0</p>
<p>OGCMX       60544.0</p>
<p>OGC         9504.0</p>
<p>OC          9504.0                  OC 是 old 内纯的占用量</p>
<p>PGCMN       8192.0                  PGCMN 显示的是最小 perm 的内存使用量</p>
<p>PGCMX       65536.0                 PGCMX 显示的是 perm 的内存最大使用量</p>
<p>PGC         12800.0                 PGC 是当前新生成的 perm 内存占用量</p>
<p>PC          12800.0                 PC 是但前 perm 内存占用量</p>
<p>YGC         164</p>
<p>FGC         6</p>
<p>jstat -gcnew pid: new 对象的信息</p>
<p><strong>[root@localhost bin]/# jstat -gcnew 25917</strong></p>
<p>  S0C    S1C    S0U    S1U   TT MTT  DSS      EC       EU     YGC     YGCT</p>
<p>  64.0   64.0   47.4   0.0    2  15   32.0    704.0    145.7    168    0.254</p>
<p>jstat -gcnewcapacity pid: new 对象的信息及其占用量</p>
<p><strong>[root@localhost bin]/# jstat -gcnewcapacity 25917</strong></p>
<p>  NGCMN   NGCMX    NGC    S0CMX  S0C    S1CMX   S1C   ECMX    EC      YGC   FGC</p>
<p>640.0   4992.0   832.0 64.0     448.0 448.0   64.0   4096.0   704.0  168     6</p>
<p>jstat -gcold pid: old 对象的信息。</p>
<p><strong>[root@localhost bin]/# jstat -gcold 25917</strong></p>
<p>   PC       PU        OC          OU       YGC    FGC    FGCT     GCT</p>
<p>  12800.0  12617.6     9504.0      6561.3   169     6    0.335    0.591</p>
<p>jstat -gcoldcapacity pid:old 对象的信息及其占用量。</p>
<p><strong>[root@localhost bin]/# jstat -gcoldcapacity 25917</strong></p>
<p>OGCMN      OGCMX        OGC         OC       YGC   FGC    FGCT     GCT</p>
<p>1408.0     60544.0      9504.0      9504.0   169     6    0.335    0.591</p>
<p>jstat -gcpermcapacity pid: perm 对象的信息及其占用量。</p>
<p>[root@localhost bin]/# jstat -gcpermcapacity 25917</p>
<p>PGCMN      PGCMX       PGC         PC      YGC   FGC    FGCT     GCT</p>
<p>8192.0    65536.0    12800.0    12800.0   169     6    0.335    0.591</p>
<p>jstat -printcompilation pid: 当前 VM 执行的信息。</p>
<p><strong>[root@localhost bin]/# jstat -printcompilation -h3  25917 1000 5</strong></p>
<p>每 1000 毫秒打印一次，一共打印 5 次，还可以加上 -h3 每三行显示一下标题。</p>
<p>Compiled  Size  Type Method</p>
<pre><code> 788     73    1 java/io/File &lt;init&gt;

 788     73    1 java/io/File &lt;init&gt;

 788     73    1 java/io/File &lt;init&gt;
</code></pre><p>Compiled  Size  Type Method</p>
<pre><code> 788     73    1 java/io/File &lt;init&gt;

 788     73    1 java/io/File &lt;init&gt;
</code></pre><h1 id="-u-jmap-"><a href=""></a>u               jmap 的用法</h1>
<p>打印出某个 java 进程（使用 pid ）内存内的，所有 ‘ 对象 ’ 的情况（如：产生那些对象，及其数量）。</p>
<p>可以输出所有内存中对象的工具，甚至可以将 VM 中的 heap ，以二进制输出成文本。使用方法 jmap -histo pid 。如果连用 SHELL jmap -histo pid&gt;a.log 可以将其保存到文本中去，在一段时间后，使用文本对比工具，可以对比出 GC 回收了哪些对象。 jmap -dump:format=b,file=String 3024 可以将 3024 进程的内存 heap 输出出来到 String 文件里。</p>
<p><strong>[root@localhost bin]/# jmap -histo  25917</strong></p>
<p>Attaching to process ID 26221, please wait...</p>
<p>Debugger attached successfully.</p>
<p>Client compiler detected.</p>
<p>JVM version is 1.5.0_08-b03</p>
<p>Iterating over heap. This may take a while...</p>
<p>Unknown oop at 0xaa6e42d0</p>
<p>Oop&#39;s klass is null</p>
<p>Object Histogram:</p>
<p>Size    Count   Class description</p>
<hr>
<p>3722768 30467    /* ConstMethodKlass</p>
<p>1976480 25334   char[]</p>
<p>1907880 46994   /* SymbolKlass</p>
<p>1762088 2947    byte[]</p>
<p>1709536 30467   /* MethodKlass</p>
<p>1487816 2600    /* ConstantPoolKlass</p>
<p>1009576 2600    /* InstanceKlassKlass</p>
<p>904880  2199    /* ConstantPoolCacheKlass</p>
<p>741432  30893   java.lang.String</p>
<p>653576  4785    int[]</p>
<p>351760  4397    java.lang.reflect.Method</p>
<p>277824  2894    java.lang.Class</p>
<p>248704  3401    short[]</p>
<p>200888  4411    java.lang.Object[]</p>
<p>193656  4045    java.lang.Object[]</p>
<p>179744  5617    java.util.TreeMap$Entry</p>
<p>175688  1800    java.util.HashMap$Entry[]</p>
<p>165288  6887    java.util.HashMap$Entry</p>
<p>104736  3273    java.lang.ref.SoftReference</p>
<p>104136  4339    java.lang.ref.WeakReference</p>
<p>96096   3521    java.lang.String[]</p>
<p>86160   3590    java.util.Hashtable$Entry</p>
<p>85584   3566    java.util.ArrayList</p>
<p>83472   1206    java.util.Hashtable$Entry[]</p>
<p>82944   1728    java.beans.MethodDescriptor</p>
<p>80560   265     /* ObjArrayKlassKlass</p>
<p>69120   1728    java.util.HashMap</p>
<p>52464   3055    java.lang.Class[]</p>
<p>43040   1076    java.util.Hashtable</p>
<p>42496   664     org.apache.commons.modeler.AttributeInfo</p>
<p>37880   947     java.util.TreeMap</p>
<p>33896   557     javax.management.modelmbean.ModelMBeanAttributeInfo[]</p>
<p>33152   518     java.beans.PropertyDescriptor</p>
<p>616     11      org.springframework.aop.framework.ProxyFactory</p>
<p>608     19      java.util.PropertyPermission</p>
<p>608     38      org.springframework.beans.MutablePropertyValues</p>
<p>608     38      org.springframework.beans.factory.support.MethodOverrides</p>
<p>608     2       /* ArrayKlassKlass</p>
<p>608     38      org.springframework.beans.factory.config.ConstructorArgumentValues</p>
<p>608     4       org.apache.xerces.impl.XMLDTDScannerImpl</p>
<p>576     24      java.util.Stack</p>
<p>576     36      java.util.regex.Pattern$Category</p>
<p>576     24      org.apache.naming.NamingEntry</p>
<p>560     7       java.net.URL[]</p>
<p>552     23      sun.management.MappedMXBeanType$BasicMXBeanType</p>
<p>552     1       java.util.Locale[]</p>
<p>552     22      java.io.ObjectStreamField[]</p>
<p>544     17      java.util.Collections$SynchronizedMap</p>
<p>176     11      java.util.regex.Pattern$Ctype</p>
<p>8        1       sun.reflect.GeneratedMethodAccessor49</p>
<p>8       1       sun.reflect.GeneratedMethodAccessor6</p>
<p>8       1       sun.reflect.GeneratedConstructorAccessor10</p>
<p>Heap traversal took 12.003 seconds.</p>
<h1 id="-u-jinfo-"><a href=""></a>u               jinfo 的用法</h1>
<p>可以输出并修改运行时的 java 进程的 opts 。用处比较简单，就是能输出并修改运行时的 java 进程的运行参数。用法是jinfo -opt  pid 如：查看 2788 的 MaxPerm 大小可以用   jinfo -flag MaxPermSize 2788 。</p>
<h1 id="-u-jconsole-"><a href=""></a>u               jconsole 的用法</h1>
<p>jconsole: 一个 java GUI 监视工具，可以以图表化的形式显示各种数据。并可通过远程连接监视远程的服务器 VM 。</p>
<p>用 java 写的 GUI 程序，用来监控 VM ，并可监控远程的 VM ，非常易用，而且功能非常强。命令行里打 jconsole ，选则进程就可以了</p>
<p>不过我没有运行起来，老是报下面的错。会的朋友，帮忙看看。</p>
<p><strong>  [root@localhost bin]/# jconsole</strong></p>
<p>Exception in thread &quot;AWT-EventQueue-0&quot; java.awt.HeadlessException:</p>
<p>No X11 DISPLAY variable was set, but this program performed an operation which requires it.        at java.awt.GraphicsEnvironment.checkHeadless(GraphicsEnvironment.java:159)</p>
<pre><code>    at java.awt.Window.&lt;init&gt;(Window.java:317)

    at java.awt.Frame.&lt;init&gt;(Frame.java:419)

    at javax.swing.JFrame.&lt;init&gt;(JFrame.java:194)

    at sun.tools.jconsole.JConsole.&lt;init&gt;(JConsole.java:65)

    at sun.tools.jconsole.JConsole$4.run(JConsole.java:666)

    at java.awt.event.InvocationEvent.dispatch(InvocationEvent.java:209)

    at java.awt.EventQueue.dispatchEvent(EventQueue.java:461)

    at java.awt.EventDispatchThread.pumpOneEventForHierarchy(EventDispatchThread.java:242)

    at java.awt.EventDispatchThread.pumpEventsForHierarchy(EventDispatchThread.java:163)

    at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:157)

    at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:149)

    at java.awt.EventDispatchThread.run(EventDispatchThread.java:110)
</code></pre><h1 id="-u-jdb-"><a href=""></a>u               jdb 的用法</h1>
<p>用来对 core 文件和正在运行的 Java 进程进行实时地调试，里面包含了丰富的命令帮助您进行调试，它的功能和 Sun studio 里面所带的 dbx 非常相似，但 jdb 是专门用来针对 Java 应用程序的。</p>
<h1 id="-u-jmap-"><a href=""></a>u               jmap 的用法</h1>
<p>打印出某个 java 进程（使用 pid ）内存内的，所有 ‘ 对象 ’ 的情况（如：产生那些对象，及其数量）。</p>
<p>可以输出所有内存中对象的工具，甚至可以将 VM 中的 heap ，以二进制输出成文本。使用方法 jmap -histo pid 。如果连用 SHELL jmap -histo pid&gt;a.log 可以将其保存到文本中去，在一段时间后，使用文本对比工具，可以对比出 GC 回收了哪些对象。 jmap -dump:format=b,file=String 3024 可以将 3024 进程的内存 heap 输出出来到 String 文件里。</p>
<p><strong>[root@localhost bin]/# jmap -histo  25917</strong></p>
<p>Attaching to process ID 26221, please wait...</p>
<p>Debugger attached successfully.</p>
<p>Client compiler detected.</p>
<p>JVM version is 1.5.0_08-b03</p>
<p>Iterating over heap. This may take a while...</p>
<p>Unknown oop at 0xaa6e42d0</p>
<p>Oop&#39;s klass is null</p>
<p>Object Histogram:</p>
<p>Size    Count   Class description</p>
<hr>
<p>3722768 30467    /* ConstMethodKlass</p>
<p>1976480 25334   char[]</p>
<p>1907880 46994   /* SymbolKlass</p>
<p>1762088 2947    byte[]</p>
<p>1709536 30467   /* MethodKlass</p>
<p>1487816 2600    /* ConstantPoolKlass</p>
<p>1009576 2600    /* InstanceKlassKlass</p>
<p>904880  2199    /* ConstantPoolCacheKlass</p>
<p>741432  30893   java.lang.String</p>
<p>653576  4785    int[]</p>
<p>351760  4397    java.lang.reflect.Method</p>
<p>277824  2894    java.lang.Class</p>
<p>248704  3401    short[]</p>
<p>200888  4411    java.lang.Object[]</p>
<p>193656  4045    java.lang.Object[]</p>
<p>179744  5617    java.util.TreeMap$Entry</p>
<p>175688  1800    java.util.HashMap$Entry[]</p>
<p>165288  6887    java.util.HashMap$Entry</p>
<p>104736  3273    java.lang.ref.SoftReference</p>
<p>104136  4339    java.lang.ref.WeakReference</p>
<p>96096   3521    java.lang.String[]</p>
<p>86160   3590    java.util.Hashtable$Entry</p>
<p>85584   3566    java.util.ArrayList</p>
<p>83472   1206    java.util.Hashtable$Entry[]</p>
<p>82944   1728    java.beans.MethodDescriptor</p>
<p>80560   265     /* ObjArrayKlassKlass</p>
<p>69120   1728    java.util.HashMap</p>
<p>52464   3055    java.lang.Class[]</p>
<p>43040   1076    java.util.Hashtable</p>
<p>42496   664     org.apache.commons.modeler.AttributeInfo</p>
<p>37880   947     java.util.TreeMap</p>
<p>33896   557     javax.management.modelmbean.ModelMBeanAttributeInfo[]</p>
<p>33152   518     java.beans.PropertyDescriptor</p>
<p>616     11      org.springframework.aop.framework.ProxyFactory</p>
<p>608     19      java.util.PropertyPermission</p>
<p>608     38      org.springframework.beans.MutablePropertyValues</p>
<p>608     38      org.springframework.beans.factory.support.MethodOverrides</p>
<p>608     2       /* ArrayKlassKlass</p>
<p>608     38      org.springframework.beans.factory.config.ConstructorArgumentValues</p>
<p>608     4       org.apache.xerces.impl.XMLDTDScannerImpl</p>
<p>576     24      java.util.Stack</p>
<p>576     36      java.util.regex.Pattern$Category</p>
<p>576     24      org.apache.naming.NamingEntry</p>
<p>560     7       java.net.URL[]</p>
<p>552     23      sun.management.MappedMXBeanType$BasicMXBeanType</p>
<p>552     1       java.util.Locale[]</p>
<p>552     22      java.io.ObjectStreamField[]</p>
<p>544     17      java.util.Collections$SynchronizedMap</p>
<p>176     11      java.util.regex.Pattern$Ctype</p>
<p>8        1       sun.reflect.GeneratedMethodAccessor49</p>
<p>8       1       sun.reflect.GeneratedMethodAccessor6</p>
<p>8       1       sun.reflect.GeneratedConstructorAccessor10</p>
<p>Heap traversal took 12.003 seconds.</p>
<h1 id="-u-jinfo-"><a href=""></a>u               jinfo 的用法</h1>
<p>可以输出并修改运行时的 java 进程的 opts 。用处比较简单，就是能输出并修改运行时的 java 进程的运行参数。用法是jinfo -opt  pid 如：查看 2788 的 MaxPerm 大小可以用   jinfo -flag MaxPermSize 2788 。</p>
<h1 id="-u-jconsole-"><a href=""></a>u               jconsole 的用法</h1>
<p>jconsole: 一个 java GUI 监视工具，可以以图表化的形式显示各种数据。并可通过远程连接监视远程的服务器 VM 。</p>
<p>用 java 写的 GUI 程序，用来监控 VM ，并可监控远程的 VM ，非常易用，而且功能非常强。命令行里打 jconsole ，选则进程就可以了</p>
<p>不过我没有运行起来，老是报下面的错。会的朋友，帮忙看看。</p>
<p><strong>  [root@localhost bin]/# jconsole</strong></p>
<p>Exception in thread &quot;AWT-EventQueue-0&quot; java.awt.HeadlessException:</p>
<p>No X11 DISPLAY variable was set, but this program performed an operation which requires it.        at java.awt.GraphicsEnvironment.checkHeadless(GraphicsEnvironment.java:159)</p>
<pre><code>    at java.awt.Window.&lt;init&gt;(Window.java:317)

    at java.awt.Frame.&lt;init&gt;(Frame.java:419)

    at javax.swing.JFrame.&lt;init&gt;(JFrame.java:194)

    at sun.tools.jconsole.JConsole.&lt;init&gt;(JConsole.java:65)

    at sun.tools.jconsole.JConsole$4.run(JConsole.java:666)

    at java.awt.event.InvocationEvent.dispatch(InvocationEvent.java:209)

    at java.awt.EventQueue.dispatchEvent(EventQueue.java:461)

    at java.awt.EventDispatchThread.pumpOneEventForHierarchy(EventDispatchThread.java:242)

    at java.awt.EventDispatchThread.pumpEventsForHierarchy(EventDispatchThread.java:163)

    at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:157)

    at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:149)

    at java.awt.EventDispatchThread.run(EventDispatchThread.java:110)
</code></pre><h1 id="-u-jdb-"><a href=""></a>u               jdb 的用法</h1>
<p>用来对 core 文件和正在运行的 Java 进程进行实时地调试，里面包含了丰富的命令帮助您进行调试，它的功能和 Sun studio 里面所带的 dbx 非常相似，但 jdb 是专门用来针对 Java 应用程序的。</p>
<p>来源： <a href="[http://blog.csdn.net/jacky0922/article/details/6201878](http://blog.csdn.net/jacky0922/article/details/6201878)">[http://blog.csdn.net/jacky0922/article/details/6201878](http://blog.csdn.net/jacky0922/article/details/6201878)</a></p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/内存分析/">内存分析</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/内存分析/" class="label label-success">内存分析</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:41"datetime="2014-03-07 09:54:41"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-内存分析--Java内存泄露监控工具-JVM监控工具介绍jstack-jconsole-jinfo-/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-内存分析--Java内存泄露监控工具-JVM监控工具介绍jstack-jconsole-jinfo-" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_多线程--多线程讲解/">多线程讲解</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:41.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_多线程--多线程讲解/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-">多线程讲解</h1>
<p>多线程是java应用程序的一个特点，掌握java的多线程也是作为一java程序员必备的知识。多线程指的是在单个程序中可以同时运行多个同的线程执行不同的任务.线程是程序内的顺序控制流，只能使用分配给序的资源和环境。还记得刚开始学习的时候总是和进程分不清，总是对这两个名词所迷惑。</p>
<p>下面就首先对这两个名词区分来作为本篇博客的开始：</p>
<p><strong>    一、线程与进程的区别</strong></p>
<p>多个进程的内部数据和状态都是完全独立的,而多线程是共享一块内存空间和一组系统资源,有可能互相影响. •线程本身的数据通常只有寄存器数据，以及一个程序执行时使用的堆栈，所以线程的切换比进程切换的负担要小。</p>
<p> 多线程编程的目的，就是&quot;最大限度地利用CPU资源&quot;，当某一线程的处理不需要占用CPU而只和I/O等资源打交道时，让需要占用CPU资源的其它线程有机会获得CPU资源。从根本上说，这就是多线程编程的最终目的。</p>
<p>二、了解一下java在多线程中的基础知识</p>
<p>1.Java中如果我们自己没有产生线程，那么系统就会给我们产生一个线程（主线程，main方法就在主线程上运行），我们的程序都是由线程来执行的。</p>
<ol>
<li>进程：执行中的程序（程序是静态的概念，进程是动态的概念）。 </li>
</ol>
<ol>
<li><p>线程的实现有两种方式，<strong>第一种方式是继承Thread类，然后重写run方法；第二种是实现Runnable接口，然后实现其run方法。 </strong></p>
</li>
<li><p>将我们希望线程执行的代码放到run方法中，然后通过start方法来启动线程，<strong>start方法首先为线程的执行准备好系统资源，然后再去调用run方法。</strong>当某个类继承了Thread类之后，该类就叫做一个线程类。 </p>
</li>
<li><p>一个进程至少要包含一个线程。 </p>
</li>
<li><p>对于单核CPU来说，某一时刻只能有一个线程在执行（微观串行），从宏观角度来看，多个线程在同时执行（宏观并行）。 </p>
</li>
<li><p>对于双核或双核以上的CPU来说，可以真正做到微观并行。</p>
</li>
</ol>
<p>三、Thread源码研究： </p>
<p>1) Thread类也实现了Runnable接口，因此实现了Runnable接口中的run方法； </p>
<p>2) 当生成一个线程对象时，如果没有为其设定名字，那么线程对象的名字将使用如下形式：Thread-number,该number将是自动增加的，并被所有的Thread对象所共享（因为它是static的成员变量）。 </p>
<p>3) 当使用第一种方式来生成线程对象时，我们需要重写run方法，因为Thread类的run方法此时什么事情也不做。</p>
<p>4）当使用第二种方式生成线程对象时，我们需要实现Runnable接口的run方法，然后使用new Thread（new MyThread（））（假如MyThread已经实现了Runnable接口）来生成线程对象，这时的线程对象的run方法或调就会MyThread类的run方法，这样我们自己编写的run方法就执行了。</p>
<p>说明： </p>
<p>Public void run(){</p>
<p>If(target!=null){</p>
<p>Target.run();</p>
<p>}}</p>
<p>当使用继承Thread生成线程对象时，target为空，什么也不执行，当使用第二种方式生成时，执行target.run（），target为runnable的实例对象，即为执行重写后的方法</p>
<p>总结：两种生成线程对象的区别：</p>
<p>1.两种方法均需执行线程的start方法为线程分配必须的系统资源、调度线程运行并执行线程的run方法。 </p>
<p>2.在具体应用中，采用哪种方法来构造线程体要视情况而定。通常，当一个线程已继承了另一个类时，就应该用第二种方法来构造，即实现Runnable接口。 </p>
<p><strong>四：线程的生命周期：</strong></p>
<p><img src="" alt=""></p>
<p>由上图可以看出，一个线程由出生到死亡分为五个阶段：</p>
<p><strong>1）.创建状态 </strong></p>
<p>•当用new操作符创建一个新的线程对象时，该线程处于创建状态。 </p>
<p>•处于创建状态的线程只是一个空的线程对象，系统不为它分配资源 </p>
<p><strong>2）. 可运行状态 </strong></p>
<p>•执行线程的start()方法将为线程分配必须的系统资源，安排其运行，并调用线程体—run()方法，这样就使得该线程处于可运行( Runnable )状态。 </p>
<p>•这一状态并不是运行中状态（Running )，因为线程也许实际上并未真正运行。 </p>
<p><strong>3）.不可运行状态 </strong></p>
<p>.当发生下列事件时，处于运行状态的线程会转入到不可运行状态。 </p>
<p>调用了sleep（）方法； </p>
<p>•线程调用wait方法等待特定条件的满足 </p>
<p>•线程输入/输出阻塞 </p>
<p><strong>4）返回可运行状态： </strong></p>
<p>•处于睡眠状态的线程在指定的时间过去后 </p>
<p>•如果线程在等待某一条件，另一个对象必须通过notify()或notifyAll()方法通知等待线程条件的改变 </p>
<p>•如果线程是因为输入/输出阻塞，等待输入/输出完成 </p>
<p><strong>5）. 消亡状态 </strong></p>
<p>当线程的run方法执行结束后，该线程自然消亡。 </p>
<p>注意：</p>
<p>1.停止线程的方式：不能使用Thread类的stop方法来终止线程的执行。一般要设定一个变量，在run方法中是一个循环，循环每次检查该变量，如果满足条件则继续执行，否则跳出循环，线程结束。 </p>
<p>2.不能依靠线程的优先级来决定线程的执行顺序。 </p>
<p><strong>五：多线程并发</strong></p>
<p>多线程并发是线程同步中比较常见的现象，java多线程为了避免多线程并发解决多线程共享数据同步问题提供了<strong>synchronized关键字</strong></p>
<p>synchronized关键字：当synchronized关键字修饰一个方法的时候，该方法叫做同步方法。 </p>
<p>1.Java中的每个对象都有一个锁（lock）或者叫做监视器（monitor），当访问某个对象的synchronized方法时，表示将该对象上锁，此时其他任何线程都无法再去访问该synchronized方法了，直到之前的那个线程执行方法完毕后（或者是抛出了异常），那么将该对象的锁释放掉，其他线程才有可能再去访问该synchronized方法。 </p>
<ol>
<li>如果一个对象有多个synchronized方法，某一时刻某个线程已经进入到了某个synchronized方法，那么在该方法没有执行完毕前，其他线程是无法访问该对象的任何synchronized方法的。 </li>
</ol>
<p>3.如果某个synchronized方法是static的，那么当线程访问该方法时，它锁的并不是synchronized方法所在的对象，而是synchronized方法所在的对象所对应的Class对象，因为Java中无论一个类有多少个对象，这些对象会对应唯一一个Class对象，因此当线程分别访问同一个类的两个对象的两个static，synchronized方法时，他们的执行顺序也是顺序的，也就是说一个线程先去执行方法，执行完毕后另一个线程才开始执行。 </p>
<ol>
<li>synchronized块，写法： </li>
</ol>
<p>synchronized(object) </p>
<p>{ </p>
<p>} </p>
<p>表示线程在执行的时候会对object对象上锁。 </p>
<p>5.synchronized方法是一种粗粒度的并发控制，某一时刻，只能有一个线程执行该synchronized方法;synchronized块则是一种细粒度的并发控制，只会将块中的代码同步，位于方法内、synchronized块之外的代码是可以被多个线程同时访问到的。 </p>
<p>同步的线程状态图：</p>
<p><img src="" alt=""></p>
<p><strong>六：wait与notify</strong></p>
<p>1.wait与notify方法都是定义在Object类中，而且是final的，因此会被所有的Java类所继承并且无法重写。这两个方法要求在调用时线程应该已经获得了对象的锁，因此对这两个方法的调用需要放在synchronized方法或块当中。当线程执行了wait方法时，它会释放掉对象的锁。 </p>
<ol>
<li>另一个会导致线程暂停的方法就是Thread类的sleep方法，它会导致线程睡眠指定的毫秒数，但线程在睡眠的过程中是不会释放掉对象的锁的。 </li>
</ol>
<p>3.notify():唤醒在此对象监视器上等待的单个线程。如果所有线程都在此对象上等待，则会选择唤醒其中一个线程。选择是任意性的，并在对实现做出决定时发生。线程通过调用其中一个 wait 方法，在对象的监视器上等待。 </p>
<p>直到当前线程放弃此对象上的锁定，才能继续执行被唤醒的线程。被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞争；例如，唤醒的线程在作为锁定此对象的下一个线程方面没有可靠的特权或劣势。</p>
<p>此方法只应由作为此对象监视器的所有者的线程来调用。通过以下三种方法之一，线程可以成为此对象监视器的所有者：</p>
<p>o 通过执行此对象的同步实例方法。</p>
<p>o 通过执行在此对象上进行同步的 synchronized 语句的正文。</p>
<p>o 对于 Class 类型的对象，可以通过执行该类的同步静态方法。</p>
<p>一次只能有一个线程拥有对象的监视器。</p>
<p><img src="" alt=""></p>
<p> <strong>关于成员变量与局部变量</strong>：如果一个变量是成员变量，那么多个线程对同一个对象的成员变量进行操作时，他们对该成员变量是彼此影响的（也就是说一个线程对成员变量的改变会影响到另一个线程）。  如果一个变量是局部变量，那么每个线程都会有一个该局部变量的拷贝，一个线程对该局部变量的改变不会影响到其他的线程。</p>
<p><strong>七：死锁的问题： </strong></p>
<p>定义：线程1锁住了对象A的监视器，等待对象B的监视器，线程2锁住了对象B的监视器，等待对象A的监视器，就造成了死锁。</p>
<pre><code> 导致死锁的根源在于不适当地运用“synchronized”关键词来管理线程对特定对象的访问。“synchronized”关键词的作用是，确保在某个时刻只有一个线程被允许执行特定的代码块，因此，被允许执行的线程首先必须拥有对变量或对象的排他性访问权。当线程访问对象时，线程会给对象加锁
</code></pre><p>Java中每个对象都有一把锁与之对应。但Java不提供单独的lock和unlock操作。下面笔者分析死锁的两个过程“上锁”和“锁死” 。</p>
<p>(1) 上锁
     许多线程在执行中必须考虑与其他线程之间共享数据或协调执行状态，就需要同步机制。因此大多数应用程序要求线程互相通信来同步它们的动作，在 Java 程序中最简单实现同步的方法就是上锁。在 Java 编程中，所有的对象都有锁。线程可以使用 synchronized 关键字来获得锁。在任一时刻对于给定的类的实例，方法或同步的代码块只能被一个线程执行。这是因为代码在执行之前要求获得对象的锁。</p>
<pre><code>为了防止同时访问共享资源，线程在使用资源的前后可以给该资源上锁和开锁。给共享变量上锁就使得 Java 线程能够快速方便地通信和同步。某个线程若给一个对象上了锁，就可以知道没有其他线程能够访问该对象。即使在抢占式模型中，其他线程也不能够访问此对象，直到上锁的线程被唤醒、完成工作并开锁。那些试图访问一个上锁对象的线程通常会进入睡眠状态，直到上锁的线程开锁。一旦锁被打开，这些睡眠进程就会被唤醒并移到准备就绪队列中。
</code></pre><p>(2)锁死
     如果程序中有几个竞争资源的并发线程,那么保证均衡是很重要的。系统均衡是指每个线程在执行过程中都能充分访问有限的资源，系统中没有饿死和死锁的线程。当多个并发的线程分别试图同时占有两个锁时，会出现加锁冲突的情形。如果一个线程占有了另一个线程必需的锁，互相等待时被阻塞就有可能出现死锁。</p>
<pre><code>在编写多线程代码时，笔者认为死锁是最难处理的问题之一。因为死锁可能在最意想不到的地方发生，所以查找和修正它既费时又费力。例如，常见的例子如下面这段程序。[print](http://write.blog.csdn.net/postedit#)[?](http://write.blog.csdn.net/postedit#)
</code></pre><p>1 public int sumArrays(int[] a1, int[] a2){  </p>
<p>2   int value = 0;  </p>
<p>3   int size = a1.length;  </p>
<p>4   if (size == a2.length) {  </p>
<p>5      synchronized(a1) { //1        </p>
<p>6        synchronized(a2) { //2          </p>
<p>7          for (int i=0; i&lt;size; i++)  </p>
<p>8             value += a1[i] + a2[i];  </p>
<p>9        }    </p>
<p>10      }    </p>
<p>11   } return value;  </p>
<p>12 }   </p>
<p>这段代码在求和操作中访问两个数组对象之前锁定了这两个数组对象。它形式简短，编写也适合所要执行的任务；但不幸的是，它有一个潜在的问题。这个问题就是它埋下了死锁的种子。</p>
<p><strong>ThreadLocal类（这个类本人没用过，暂时不太懂）</strong></p>
<p>首先，ThreadLocal 不是用来解决共享对象的多线程访问问题的，一般情况下，通过ThreadLocal.set() 到线程中的对象是该线程自己使用的对象，其他线程是不需要访问的，也访问不到的。各个线程中访问的是不同的对象。
另外，说ThreadLocal使得各线程能够保持各自独立的一个对象，并不是通过ThreadLocal.set()来实现的，而是通过每个线程中的new 对象 的操作来创建的对象，每个线程创建一个，不是什么对象的拷贝或副本。通过ThreadLocal.set()将这个新创建的对象的引用保存到各线程的自己的一个map中，每个线程都有这样一个map，执行ThreadLocal.get()时，各线程从自己的map中取出放进去的对象，因此取出来的是各自自己线程中的对象，ThreadLocal实例是作为map的key来使用的。
如果ThreadLocal.set()进去的东西本来就是多个线程共享的同一个对象，那么多个线程的ThreadLocal.get()取得的还是这个共享对象本身，还是有并发访问问题。</p>
<p><strong> 本文来自：曹胜欢博客专栏。转载请注明出处：<a href="http://blog.csdn.net/csh624366188" target="_blank"><a href="http://blog.csdn.net/csh624366188">http://blog.csdn.net/csh624366188</a></a></strong></p>
<p>来源： <a href="[http://blog.csdn.net/csh624366188/article/details/7318245](http://blog.csdn.net/csh624366188/article/details/7318245)">[http://blog.csdn.net/csh624366188/article/details/7318245](http://blog.csdn.net/csh624366188/article/details/7318245)</a> </p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/Java_多线程/">Java_多线程</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/Java_多线程/" class="label label-success">Java_多线程</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:41"datetime="2014-03-07 09:54:41"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-Java_多线程--多线程讲解/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-Java_多线程--多线程讲解" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>





<ul id="pagination" class="pagination pagination-lg">
  <li><a class="extend prev" href="/page/58/">&laquo;</a></li><li><a class="page-number" href="/">1</a></li><li><a class="page-number" href="/page/2/">2</a></li><li><span class="space">&hellip;</span></li><li><a class="page-number" href="/page/56/">56</a></li><li><a class="page-number" href="/page/57/">57</a></li><li><a class="page-number" href="/page/58/">58</a></li><li class="active"><li><span class="page-number current">59</span></li><li><a class="page-number" href="/page/60/">60</a></li><li><a class="page-number" href="/page/61/">61</a></li><li><a class="page-number" href="/page/62/">62</a></li><li><span class="space">&hellip;</span></li></li><li><a class="page-number" href="/page/164/">164</a></li><li><a class="page-number" href="/page/165/">165</a></li><li><a class="extend next" href="/page/60/">&raquo;</a></li>
  <div class="clearfix"></div>
</ul></div><!--wapper-->
       </div><!-- ID main-col END -->
       <aside id="sidebar" class="alignright col-sx-6 col-sm-4 col-md-3 col-lg-3">
<div id="widget_search" class="widget panel panel-primary">
    <form action="//google.com/search" method="get" accept-charset="utf-8">
  <div class="input-group">
    <input class="form-control" id="searchbox" type="search" name="q" results="0" placeholder="search">
    <span class="input-group-btn">
      <button class="btn btn-default" type="submit">Go!</button>
    </span>
    <input type="hidden" name="q" value="site:itsolife.com">
  </div>
</form>
</div>

<div id="widget_category" class="widget panel panel-primary">
  <div class="panel-heading">category</div>  <div data-src='category' class='ajax_widgets'>正在加载...</div>
</div>

<div id="widget_recent_posts" class="widget panel panel-primary">
  <div class="panel-heading">recent posts</div>  <div data-src='recent_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_tagcloud" class="widget panel panel-primary">
  <div class="panel-heading">tagcloud</div>  <div data-src='tagcloud' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_latest_update_posts" class="widget panel panel-primary">
  <div class="panel-heading">最近更新</div>  <div data-src='latest_update_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_recent_comments" class="widget panel panel-primary">
  <div class="panel-heading">recent comments</div>  

<div class="list-group-item ds-recent-comments" data-num-items="6" data-show-avatars="1" data-show-time="1" data-show-title="1" data-show-admin="1" data-excerpt-length="50"></div>



</div>

</aside>
       <div class="clearfix"></div>
     </div><!-- row END -->
  </div>
  <footer id="footer" class="container">
  <div class="panel panel-info">
  <section id='footer_widget'></section>  <div class="panel-footer">
  <div id="site-info">
    <span class='author'>
  
  &copy; 2014 RobinChia
  
    &nbsp;&nbsp;</span>
  
  <span id='analytics-51la'></span><span id='analytics-google'>
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-48559895-1']);
  _gaq.push(['_trackPageview']);
  _js2load.push({src:('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'});
</script></span><span id='analytics-cnzz'>
<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_5774006'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s17.cnzz.com/stat.php%3Fid%3D5774006%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>
</span><span id='analytics-baidu'>
<script>
var _hmt = _hmt || [];
_js2load.push({src:"//hm.baidu.com/hm.js?1442f50724afc42380b51f097c43082c"});
</script>
</span>  </div>
  <div id="copyright">Blog powered by <a href='http://zespia.tw/hexo/'><strong>hexo</strong></a> Theme <strong><a href='https://github.com/chenall/hexo-theme-chenall'>chenall</a></strong>(Some change in it)<span class="pull-right"> 更新时间: <em>2014-03-26 21:21:33</em></span></div>
</div>
<div class="clearfix"></div>


  </div>
  </footer>
  
        <script src="http://cdn.bootcss.com/jquery/1.10.2/jquery.min.js"></script>        
        <script src="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/js/bootstrap.min.js"></script>        
                
        <script src="http://cdn.bootcss.com/prettify/r298/prettify.min.js"></script>    <script type="text/javascript">
   var lang=["bsh", "c", "cc", "cpp", "cs", "csh", "cyc", "cv", "htm", "html",
    "java", "js", "m", "mxml", "perl", "pl", "pm", "py", "rb", "sh",
    "xhtml", "xml", "xsl"];
   var pretty_base='';
   $('script').each(function(){
	var c = $(this).attr('src');
	if (!c)
	    return;
	if (c.match(/(\/)?prettify(\.min)?\.js/i))
	{
	    var index = c.lastIndexOf('/');
	    if (index != -1)
		pretty_base = c.substr(0,index + 1);
	    return false;
	}
   })
   $('pre code').each(function(){
	var c = $(this).attr('class')
	if (!c)
	    return;
	c = c.match(/\s?(lang\-\w+)/i);
	if (c && lang.indexOf(c[1]) == -1)
	{
	    lang.push(c[1]);
	    $.getScript(pretty_base + c[1] + '.min.js');
	}
   })

    $(window).load(function(){
       $("pre").addClass("prettyprint");
       prettyPrint();
    })
</script>    
            <script type="text/javascript">
var duoshuoQuery = {short_name:"robinchia"};
_js2load.push({src:'http://static.duoshuo.com/embed.js',charset:'UTF-8'});
</script>
    
            <!--wumii_relatedItems-->
    
        <script src="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js"></script>    <script type="text/javascript">
(function($){
  $('.entry').each(function(i){
    $(this).find('img').each(function(){
      var alt = this.alt;

      if (alt){
        $(this).before('<span class="caption">' + alt + '</span>');
      }

      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox" rel="fancybox' + i + '" />');
    });
  });

  $('.fancybox').fancybox();
})(jQuery);
</script>    
        <script src="http://cdn.bootcss.com/mathjax/2.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>    <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>
    
<script type="text/javascript">
$('.ajax_widgets').each(function(){var src=$(this).attr('data-src');if(src)$(this).load('/widgets/'+src+'.html');});
$.each(_js2load,function(index,obj){loadjs(obj.src,obj.charset)});
</script>

<div id="scroll2top">
<img src="/scroll2top/arrow.png"/>
</div>
<script src="/scroll2top/scroll2top.min.js"></script>
<div id="winterland">
  <canvas></canvas>
</div>
<script src="/js/winterland.min.js"></script>

  </body>
</html>
