
<!DOCTYPE HTML>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>The 4 Page | It so life</title>
<meta name="author" content="RobinChia">

<meta name="description" content="It so life">


<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<meta property="og:site_name" content="It so life"/>

<!--[if IE]><style>.testIE.IE{display:inline;}</style><![endif]-->
<!--[if lte IE 7]><link rel="stylesheet" href="/css/ie7.css" type="text/css"><![endif]-->
<!--[if (lt IE 9)&(gt IE 7)]><style>.testIE.IE8{display:inline;}</style><![endif]-->
<!--[if gt IE 8]><style>.testIE.IE9{display:inline;}</style><![endif]-->

<link href="/favicon.png" rel="icon">
<link rel="alternate" href="/atom.xml" title="It so life Feed" type="application/atom+xml">

<link rel="stylesheet" href="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/css/bootstrap.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/font-awesome/4.0.3/css/font-awesome.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/prettify/r298/prettify.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" type="text/css">
<link rel="stylesheet" href="/css/style.css" type="text/css">
<!--[if lt IE 9]>
   <style>article,aside,dialog,footer,header,section,footer,nav,figure,menu{display:block}</style>
   <script src="http://cdn.staticfile.org/html5shiv/r29/html5.min.js"></script>
   <script src="http://cdn.staticfile.org/respond.js/1.4.2/respond.min.js"></script>
<link href="http://cdn.staticfile.org/respond.js/1.4.2/respond-proxy.html" id="respond-proxy" rel="respond-proxy" />
<link href="/js/respond.proxy.gif" id="respond-redirect" rel="respond-redirect" />
<script src="/js/respond.proxy.js"></script>
   <script src="http://cdn.bootcss.com/selectivizr/1.0.2/selectivizr-min.js"></script>
<![endif]-->
<script type="text/javascript">
function loadjs(c,d){var a=document.createElement("script");a.async=!0;a.type="text/javascript";a.src=c;a.charset=d||"gbk";(document.getElementsByTagName("HEAD")[0]||document.getElementsByTagName("BODY")[0]).appendChild(a)};
var _protocol = (("https:" == document.location.protocol) ? " https://" : " http://");
var _js2load = [];
</script>

</head>
<body>
      <header id="header" class="container"><nav id="main-nav" class="navbar navbar-default navbar-fixed-top " role="navigation">
  <div class="container">
    <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
      <span class="sr-only">Toggle navigation</span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="/">It so life</a>
    </div>
    <div  class="collapse navbar-collapse">
      <ul  class="nav navbar-nav">
  
        <li><a href="/" title="Home">Home</a></li>      
        <li><a href="/about/" title="About">About</a></li>      
        <li><a href="/archives/" title="Archives">Archives</a></li>      
      <li class='dropdown'>
        <a class='dropdown-toggle' data-toggle='dropdown' href='#'>website<b class='caret'></b></a>
        <ul class='dropdown-menu pure-menu-selected'>
    
          <li><a href="//groups.google.com/forum/#!forum/pongba" title="TopLanguage">TopLanguage</a></li>    
          <li><a href="//itpub.net/" title="ITPub">ITPub</a></li>    
          <li><a href="//blog.jobbole.com/" title="Bole">Bole</a></li>    
          <li><a href="//nosql-database.org/" title="nosql">nosql</a></li>    
          <li><a href="//gitimmersion.googol.im/" title="Git">Git</a></li>    
        </ul>
      </li>
    
      </ul>
      <ul class="nav navbar-nav navbar-right">
      
        <li><a href="/atom.xml">RSS</a></li>
      
      
        <li><a href="https://twitter.com/robinchia">twitter</a></li>
      
      
      
      
        <li><a href="https://github.com/robinchia">github</a></li>
      
      </ul>
    </div>
  </div>
</nav>
<div class="clearfix"></div>
</header>
  <div id='content' class="container">
     <div class="page-header-wrapper">
      <!--[if lt IE 9]><div class="alert alert-warning alert-dismissable"><button type="button" class="close" data-dismiss="alert" aria-hidden="true">&times;</button><strong>提示:</strong>您的浏览器版本太低了,建议升级到 <strong><a href="http://windows.microsoft.com/zh-cn/internet-explorer/download-ie" title="IE9">IE9</a></strong> 以上,本站使用<a href="https://www.google.com/intl/zh-CN/chrome/">Chrome浏览器</a>可以获得最好的显示效果.</div><![endif]-->
      <div class="page-header"><h1 align="center"><big>It so life</big> </h1>
        <h5 align="center"><big>love as life</big></h5>
      </div>
     </div>
     <div class="row">
       <div id="main-col" class="alignleft col-sx-12 col-sm-8 col-md-9 col-lg-9">
      <section id='header_widget'></section>
          <div id="wrapper"><article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/03/2014-02-03--知其所以然（三）：为什么算法这么难？/">知其所以然（三）：为什么算法这么难？</a></h1>
      
        <span>Posted on<time datetime="2014-02-03T03:24:29.000Z"> <a href="/2014/02/03/2014-02-03--知其所以然（三）：为什么算法这么难？/">feb. 3 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-">知其所以然（三）：为什么算法这么难？</h1>
<h1 id="-http-mindhacks-cn-2011-07-10-the-importance-of-knowing-why-part3-"><a href="http://mindhacks.cn/2011/07/10/the-importance-of-knowing-why-part3/" target="_blank">知其所以然（三）：为什么算法这么难？</a></h1>
<p>不知不觉《知其所以然》系列竟然也写到第三篇了，虽然前面两篇也说了不少，但是总觉得还有东西没有说“透”，或者说没有说“好”。所以这篇试图从不同的角度用更好的例子来继续深入阐述。（感谢<a href="http://www.douban.com/people/silwile/" target="_blank">silwile</a>对本文的review和意见）</p>
<p>广大码农同学们大多都有个共识，认为算法是个硬骨头，很难啃，悲剧的是啃完了还未必有用——除了面试的时候。实际工程中一般都是用现成的模块，一般只需了解算法的目的和时空复杂度即可。</p>
<p>不过话说回来，面试的时候面算法，包括面项目中几乎不大可能用到的算法，其实并不能说是毫无道理的。<strong>算法往往是对学习和理解能力的一块试金石</strong>，难的都能掌握，往往容易的事情不在话下。志于高者得于中。反之则不成立。另一方面，虽说教科书算法大多数都是那些即便用到也是直接拿模块用的，但不幸的是，我们这群搬砖头的有时候还非得做些发明家的事情：要么是得把算法当白盒加以改进以满足手头的特定需求；要么干脆就是要发明轮子。所以，虽说面试的算法本身未必用得到，但熟悉各种算法的人通常更可能熟悉算法的思想，从而更可能具备这里说的两种能力。</p>
<p>那么，为什么说算法很难呢？这个问题只有两种可能的原因：</p>
<ol>
<li>算法本身就很难。也就是说，算法这个东西对于人类的大脑来说本身就是个困难的事儿。</li>
<li>讲得太烂。</li>
</ol>
<p>下面会说明，算法之所以被绝大多数人认为很难，以上两个原因兼具。</p>
<p>我们说算法难的时候，有两种情况：<strong>一种是学算法难。第二种是设计算法难</strong>。对于前者，大多数人（至少我当年如此）学习算法几乎是在背算法，就跟背菜谱似的（“Cookbook”是深受广大码农喜爱的一类书），然而算法和菜谱的区别在于，算法包含的细节复杂度是菜谱的无数倍，算法的问题描述千变万化，逻辑过程百转千回，往往看得人愁肠百结，而相较之下任何菜谱涉及到的基本元素也就那么些（所以程序员肯定都具有成为好厨师的潜力:D）注意，即便你看了算法的证明，某种程度上还是“背”（为什么这么说，后面会详述）。我自己遇到新算法基本是会看证明的，但是发现没多久还是会忘掉，这是死记硬背的标准症状。如果你也啃过算法书，我相信很大可能性你会有同感：<em>为什么当时明明懂了，但没多久就忘掉了呢？为什么当时明明非常理解其证明，但没过多久想要自己去证明时却发现怎么都没法补上证明中缺失的一环呢？</em></p>
<p>初中学习几何证明的时候，你会不会傻到去背一个定理的证明？不会。你只会背结论。为什么？一方面，因为证明过程包含大量的细节。另一方面，证明的过程环环相扣，往往只需要注意其中关键的一两步，便能够自行推导出来。算法逻辑描述就好比定理，算法的证明的过程就好比定理的证明过程。但不幸的是，与数学里面大量简洁的基本结论不同，算法这个“结论”可不是那么好背的，许多时候，<strong>算法本身的逻辑就几乎包含了与其证明过程等同的信息量</strong>，甚至算法逻辑本身就是证明过程（随便翻开一本经典的算法书，看几个经典的教科书算法，你会发现算法逻辑和算法证明的联系有多紧密）。于是我们又回到刚才那个问题：你会去背数学证明么？<strong>既然没人会傻到去背整个证明，又为什么要生硬地去背算法呢</strong>？</p>
<p>那么，不背就不背，去理解算法的证明如何？理解了算法的证明过程，便更有可能记住算法的逻辑细节，理解记忆嘛。然而，仍然不幸的是，绝大多数算法书在这方面做的实在糟糕，证明倒是给全了，逻辑也倒是挺严谨的，可是似乎没有作者能真正还原算法发明者本身如何得到算法以及算法证明的思维过程，按理说，证明的过程应该反映了这个思维过程，但是在下文关于霍夫曼编码的例子中你会看到，其实饱受赞誉的<a href="http://www.amazon.com/Introduction-Algorithms-International-Thomas-Cormen/dp/0262533057" target="_blank">CLRS</a>和<a href="http://www.amazon.com/Algorithms-Sanjoy-Dasgupta/dp/0073523402" target="_blank">《Algorithms》</a><em>不仅没能还原这个过程，反而掩盖了这个过程</em>。</p>
<p>必须说明的是，没有哪位作者是故意这样做的，但任何人在讲解一个自己已经理解了的东西的时候，往往会无意识地对自己的讲解进行“线性化”，例如证明题，如果你回忆一下高中做平面几何证明题的经历，就会意识到，其实证明的过程是一个充满了试错，联想，反推，特例，修改问题条件，穷举等等一干“非线性”思维的，混乱不堪的过程，而并不像写在课本上那样——引理1，引理2，定理1，定理2，一口气直到最终结论。这样的证明过程也许容易理解，但绝对不容易记忆。过几天你就会忘记其中一个或几个引理，其中的一步或几步关键的手法，然后当你想要回过头来自己试着去证明的时候，就会发现卡在某个关键的地方，为什么会这样？因为证明当中并没有告诉你为什么作者当时会想到证明算法需要那么一个引理或手法，所以，<strong>虽说看完证明之后，对算法这个结论而言你是知其所以然了，但对于算法的证明过程你却还没知其所以然</strong>。在我们大脑的记忆系统当中，<strong>新的知识必须要和既有的知识建立联系，才容易被回忆起来</strong>（<a href="http://mindhacks.cn/2009/03/28/effective-learning-and-memorization/" target="_blank">《如何有效地学习与记忆》</a>）<strong>，联系越多，越容易回忆，而一个天外飞仙似地引理，和我们既有的知识没有半毛钱联系，没娘的孩子没人疼，自然容易被遗忘。</strong>（为什么还原思维过程如此困难呢？我曾经在<a href="http://mindhacks.cn/2008/07/07/the-importance-of-knowing-why/" target="_blank">知其所以然（一）</a>里详述）</p>
<p>正因为绝大多数算法书上悲剧的算法证明过程，很多人发现证明本身也不好记，于是宁可选择直接记结论。当年我在数学系，考试会考证明过程，但似乎计算机系的考试考算法证明过程就是荒谬的？作为“工程”性质的程序设计，似乎更注重使用和结果。但是如果是你需要在项目中自己设计一个算法呢？这种时候最起码需要做的就是证明算法的正确性吧。我们面试的时候往往都会遇到一些算法设计问题，我总是会让应聘者去证明算法的正确性，因为即便是<strong>一个“看上去”正确的算法，真正需要证明起来往往发现并不是那么容易</strong>。</p>
<p>所以说，绝大多数算法书在作为培养算法设计者的角度来说是失败的，比数学教育更失败。大多数人学完了初中平面几何都会做证明题（数学书不会要求你记住几何所有的定理），但很多人看完了一本算法书还是一团浆糊，不会证明一些起码的算法，我们背了一坨又一坨结论，非但这些结论许多根本用不上，就连用上的那些也不会证明。为什么会出现这样的差异？因为数学教育的理想目的是为了让你成为能够发现新定理的科学家，而码农系的算法教育的目的却更现实，是为了让你成为能够使用算法做事情的工程师。然而，事情真的如此简单么？如果真是这样的话干脆连算法结论都不要背了，只要知道算法做的是什么事情，时空复杂度各是多少即可。</p>
<p>如果说以上提到的算法难度（讲解和记忆的难度）属于<a href="http://en.wikipedia.org/wiki/Accidental_complexity" target="_blank">Accidental Complexity</a>的话，算法的另一个难处便是Essential Complexity了：算法设计。还是拿数学证明来类比（如果你看过《Introduction to Algorithms：A Creative Approach》就知道算法和数学证明是多么类似。），与单单只需证明相比，<strong>设计算法的难处在于，定理和证明都需要你去探索，尤其是前者</strong>——你需要去自行发现关键的那（几）个定理，跟证明已知结论相比（已经确定知道结论是正确的了，你只需要用逻辑来连接结论和条件），<strong>这件事情的复杂度往往又难上一个数量级。</strong></p>
<p>一个有趣的事实是，<strong>算法的探索过程往往蕴含算法的证明过程</strong>，理想的算法书应该通过还原算法的探索过程，从而让读者不仅能够自行推导出证明过程，同时还能够具备探索新算法的能力。之所以这么说，皆因为我是个懒人，懒人总梦想学点东西能够实现以下两个目的：</p>
<ol>
<li><strong>一劳永逸</strong>：程序员都知道“<a href="http://en.wikipedia.org/wiki/Write_once,_run_anywhere" target="_blank">一次编写到处运行</a>”的好处，多省事啊。学了就忘，忘了又得学，翻来覆去浪费生命。为什么不能看了一遍就再也不会忘掉呢？到底是教的不好，还是学得不好？</li>
<li><strong>事半功倍</strong>：事实上，程序员不仅讲究一次编写到处运行，更讲究“一次编写到处使用”（也就是俗称的“复用”）。如果学一个算法所得到的经验可以到处使用，学一当十，推而广之，时间的利用效率便会大大提高。究竟怎样学习，才能够使得经验的外推（extrapolate）效率达到最大呢？</li>
</ol>
<p>想要做到这两点就必须<strong>尽量从知识树的“根节点”入手</strong>，虽然这是一个美梦，例如数学界寻找“根节点”的<a href="http://mindhacks.cn/2008/04/18/learning-from-polya/" target="_blank">美梦由来已久</a>（《跟波利亚学解题》的“一点历史”小节），但哥德尔一个证明就<a href="http://mindhacks.cn/2006/10/15/cantor-godel-turing-an-eternal-golden-diagonal/" target="_blank">让美梦成了泡影</a>（《永恒的金色对角线》））；但是，这并不阻止我们去寻找更高层的节点——<a href="http://mindhacks.cn/2008/04/18/learning-from-polya/" target="_blank">更具普适性的解题原则和方法</a>。所以，理想的算法书或者算法讲解应该是从最具一般性的思维法则开始，顺理成章地推导出算法，这个过程应该尽量还原一个”普通人“思考的过程，而不是让人看了之后觉得”这怎么可能想到呢？</p>
<p>以本文上篇提到的霍夫曼编码为例，第一遍看霍夫曼编码的时候是在本科，只看了算法描述，觉得挺直观的，过了两年，忘了，因为不知道为什么要把两个节点的频率加在一起看做单个节点——一件事情不知道“为什么”就会记不牢，知道了“为什么”的话便给这件事情提供了必然性。不知道“为什么”这件事情便可此可彼，<strong>我们的大脑对于可此可彼的事情经常会弄混，它更容易记住有理有据的事情</strong>（<em>从信息论的角度来说，一件必然的事情概率为1，信息量为0，而一件可此可彼的事情信息量则是大于0的</em>）。第二遍看是在工作之后，终于知道要看证明了，拿出著名的《Algorithms》来看，边看边点头，觉得讲得真好，一看就理解了为什么要那样来构造最优编码树。可是没多久，又给忘了！这次忘了倒不是忘了要把两个节点的频率加起来算一个，而是忘了为什么要这么做，因为当时没有弄清霍夫曼为什么能够想到为什么应该那样来构造最优编码树。结果<em>只知其一不知其二</em>。</p>
<p>必须说明的是，如果只关心算法的结论（即算法逻辑），那么理解算法的证明就够了，光背算法逻辑难记住，理解了证明会容易记忆得多。但如果也想不忘算法的证明，那么不仅要理解证明，还要理解证明背后的思维，也就是<em>为什么背后的为什么</em>。后者一般很难在书和资料上找到，唯有自己多加揣摩。为什么要费这个神？只要不会忘记结论不就结了吗？取决于你想做什么，如果你想真正弄清算法设计背后的思想，不去揣摩算法原作者是怎么想出来的是不行的。</p>
<p>回到霍夫曼编码问题，我们首先看一看《Algorithms》上是怎么讲的：</p>
<p>首先它给出了一棵编码树的cost function：</p>
<p>cost of tree = Σ freq(i) /* depth(i)</p>
<p>这个cost function很直白，就是把编码的定义复述了一遍。但是接下来就说了：</p>
<p><em>There is another way to write this cost function that is very helpful.</em> Although we are only given frequencies for the leaves, we can define the frequency of any internal node to be the sum of the frequencies of its descendant leaves; this is, after all, the number of times the internal node is visited during encoding or decoding…</p>
<p>接着就按照这个思路把cost function转换了一下：</p>
<p>The cost of a tree is the sum of the frequencies of all leaves and internal nodes, except the root.</p>
<p>然后就开始得出算法逻辑了：</p>
<p>The <em>first formulation</em> of the cost function tells us that the <em>two symbols with the smallest frequencies must be at the bottom of the optimal tree</em>, as children of the lowest internal node (this internal node has two children since the tree is full). Otherwise, swapping these two symbols with whatever is lowest in the tree would improve the encoding.</p>
<p>This suggests that we start constructing the tree greedily: find the two symbols with the smallest frequencies, say i and j, and make them children of a new node, which then has frequency fi + fj. To keep the notation simple, let’s just assume these are f1 and f2. By the <em>second formulation</em> of the cost function, any tree in which f1 and f2 are sibling-leaves has cost f1 + f2 plus the cost for a tree with n – 1 leaves of frequencies (f1 + f2), f3, f4, .., fn. <em>The latter problem is just a smaller version of the one we started with</em>.</p>
<p>读到这里我想大多数人有两种反应：</p>
<ol>
<li>觉得理所当然。</li>
<li>觉得恍然大悟。</li>
</ol>
<p>因为我当时也是这么觉得的。可是后来当我发现自己无法从头证明一遍的时候，我知道肯定是理解的不够深刻。如果理解的够深刻，那么基本上是不会忘掉的。</p>
<p>如果看完霍夫曼编码这样一个简短证明你觉得顺理成章，一切都挺显然，<em>那就坏了</em>，即便是看上去最基本的性质也往往实际上没那么显然。“逢山开路，遇水架桥”在我们今天看来是无比显然的事实，但是试想在没有桥的远古时代，一个原始人走到一条湍急的河流前，他会怎么想，他又能有什么法子呢？这是个他从来没有遇见过的问题。如果后来有一天，他路过另外一条小溪，看到小溪上有一截被闪电劈断的枯树，于是他踏着树干走过了小溪，并意识到“树横过河面”可以达到“过河”这个目的，这就将条件和目的建立了直接的联系（事实上，是自然界展示了这个联系，我们的原始人只是记住了这个联系）。后来他又路过那条河流，他寻思如何达到“过河”这个目的的时候，忽然意识到在他的记忆中已经遇到过需要达成同样目的的时候了，那个时候的条件是“树横过河面”，于是问题便归结为如何满足这个“树横过河面”的条件，而后一个问题就简单多了。（事实上波利亚在他的著作《How to Solve it》中举的正是这么个例子）</p>
<p>为什么那么多的算法书，就看不到有一本讲得好的？因为我们求解问题过程中的思维步骤太容易被自己当作“显然”的了，但除了我们天生就会的认知模式（联系，类比），没有什么是应该觉得显然的，试错是我们天生就会的思维法则么？是的，但是可供尝试的方案究竟又是怎么来的呢？就拿上面的例子来说，一个从没有见过枯树干架在小溪上的原始人，怎么知道用树架桥是一种可选的方案呢？俗话说巧妇难为无米之炊啊。我们大脑的神经系统会的是将目的和条件联系起来，第一次原始人遇到小溪过不去，大脑中留下了一个未实现的目的，后来见到小溪上的树干，忽然意识到树干是实现这个目的的条件，两者便联系起来了，因此问题就规约为如何架树干了。</p>
<p>回到《Algorithms》中的证明上，这个看似简洁明了的证明其实有几处非常不显然的地方，甚至不严谨的地方，这些地方也正是你过段时间之后试图自己证明的话会发现卡住的地方：</p>
<ol>
<li>作者轻飘飘地就给出了cost function的另外一种关键的描述，而对于如何发现这种描述却只是一语带过：&quot;<em>There is another way to write this cost function that is very helpful.. </em>we can define the frequency of any internal node to be the sum of the frequencies of its descendant leaves“这其实就是我常常痛恨的“<em>我们考虑</em>…”，这里作者其实就是在说”让<em>我们考虑</em>下面这样一种<em>奇妙</em>的转换“，可是怎么来的却不说。但必须承认，《Algorithms》的作者还是算厚道的，因为后面他又稍微解释了一下：“this is, after all, the number of times the internal node is visited during encoding or decoding…”这个解释就有点让人恍然大悟了，但是千万别忘了，这种恍然大悟是一种错觉，你还是没明白为什么他会想到这一点。这就像是作者对你说“<em>仔细观察</em>问题条件，我们<em>容易发现</em>这样一种奇妙的性质..”，怎么个“仔细”法？凭什么我自己“观察”半天就是发现不了呢？霍夫曼本人难道也是死死盯着问题<a href="http://en.wikipedia.org/wiki/Huffman_tree#History" target="_blank">“观察”了一学期</a>然后就“发现”了么？我们有理由相信霍夫曼肯定尝试了各种各样的方法，作出了各种各样的努力，否则当年Shannon都没搞定的这个问题花了他一学期，难道他在这个学期里面大脑就一片空白（或者所有的尝试全都是完全不相干的徒劳），然后到学期末尾忽然“灵光一现”吗？</li>
<li>如果“仔细观察”:)，我们会发现两个cost function表达中frequency的概念有微妙的差异，在第一个cost function中，只有叶子节点有frequency，而这个frequency必须和叶子节点的深度相乘。而在第二个cost function中，内部节点也具有了frequency，可是所有节点的“frequency”忽然全都不跟深度相乘了。frequency的不同含义令人困惑。</li>
<li>作者提到：第一个cost function告诉我们频率最低的两个节点必然处于最优编码树的底端，作为最低内部节点的两个子节点。这是一个不严谨的说法，从前文给出的条件和性质，只能推导出编码树的最底层必然能找到频率最低的两个节点，但<em>它们未必一定要是兄弟节点</em>，如果树的最底层不止能容纳两个节点的话它们就可以有不同的父节点。“我们不妨考虑”这样一个例子：对A,B,C,D四个字母进行编码，假设它们的频率分别是1， 1， 2， 2。这个时候我们可以构造如下图所示的两棵树，两棵树的cost都是12，都是最优的。但其中一棵树中，两个频率最低的节点并非兄弟。 
<a href="http://mindhacks.cn/wp-content/uploads/2011/07/tree2.jpg" target="_blank"><img src="&quot;tree2&quot;" alt="tree2"></a></li>
</ol>
<p>为什么要提到上面这几点不显然和不严谨的地方，因为只要当你看到算法书上出现不显然和不严谨的地方，基本上就意味着作者其实跳过了关键的思维步骤。</p>
<p>不幸的是《Algorithms》这本书里面讲霍夫曼编码已经算是讲的好的了，如果你翻开著名的CLRS，看一看当中是怎么证明的，你就知道我说的什么意思了。有时候这些证明是如此的企图追求formal和严谨，一上来就定义符号一大摞，让人看了就想吐。</p>
<p>说了这么多，<em>有没有可能把霍夫曼编码讲的更好呢</em>？前面说过，霍夫曼编码我记了又忘，忘了又记，好几次了，有一次终于烦了，心想如果要自己去证明，会怎么去证，那个时候我已经忘了《Algorithms》里面怎么讲的了。所以我得从头来起，首先，对于算法问题，有一个一般性原则是，<strong>先看一看解空间的构成</strong>。尤其是对于搜索问题（最优化问题可以看做搜索问题的一个特例），这一点尤其重要。霍夫曼编码的可能的编码树是有穷的，如果穷举所有的编码树，然后找到那棵代价最小的，这种方法至少是可行的，有了可行的方法（即便是穷举）至少让我们内心感到踏实。</p>
<p>接下来便是提高搜寻效率的问题。而提高搜寻效率的关键（同样也是一个一般性原则），便是<strong>尽量去寻找问题条件能够推导出来的性质，**</strong>然后利用这些性质去避免不必要的搜寻**，只要你学过二分搜索就应该理解这个一般性原则：二分搜索的效率之所以高于“穷搜”（O(n)），便是因为它利用了问题中的性质（有序）来避免了不必要的搜寻。有时候这个性质甚至可以直接将时间降为O(1)，例如在一个有序数组中寻找出现次数大于n/2的数（假设该数存在），利用“该数一定出现在数组正中间”这个性质，我们直接就避免了所有的计算。</p>
<p>不过，话虽如此，有时候这些性质并不是那么“显然”的，需要对问题进行深入的折腾才能有可能发现。第三个一般原则：如果你要搜寻的元素是某个满足特定条件的元素（例如寻找最优解的时候，“最优”的定义就是这个“特定条件”），那么可以“<strong>倒过来推</strong>”（数学证明常用手法，结论当条件使），即假设你已经找到了你要找的元素，那么能得出哪些结论，每一个结论都是最优解的一个必要条件，而<em>每一个必要条件都能够帮助你避免不必要的搜寻</em>，因为你<em>只要发现某个候选解不满足某个必要条件，就可以立即将其丢弃</em>，前面提到的寻找出现次数大于n/2的例子是一个极端情况，我们得出的必要条件导致我们可以直接丢弃除中点元素之外的一切其他元素，再例如如果有人叫你寻找有序数组中最小元素，你会毫不犹豫地把该数组头尾元素中较小的那个给他，因为你知道“如果那个最小元素存在，那么它<em>必然</em>位于头尾”——这个必要条件直接允许你丢弃掉n-2个候选解。</p>
<p>回到霍夫曼编码问题，按照这个原则，我们会去<em>假设已经得到了最优编码树</em>，那么我们能够发现关于它的什么性质呢？这里又要提到另一个适用于很多最优化问题的原则（前面提到的原则适用于一般性搜索问题），<strong>所谓最优解，就是说比其他所有解都要更好</strong>，虽然这句话听上去像是废话，但是它的一个直接推论——<strong>比与它邻近的所有候选解都要好</strong>——就是一个非常有用的，不是废话的性质了。学过微积分的都知道，光滑函数的最值点必然是大（小）于其邻域内的所有点的，然后再根据这个就自然推出该点的一阶导数（切线斜率）必然为0的性质，这个性质（必要条件）让我们直接省掉了去整个区间内搜索的麻烦，从而可以直接锁定有限几个候选解。那么，既然我们说最优霍夫曼树一定比它“附近”的树更好，我们就想看看，怎么来找到它附近的树。我们知道要从一个点到它附近，往往是对这个点进行一些调整，例如N+1是到达附近的另一个整数。霍夫曼树是一棵树，所以对这棵树的所有的一次“改动”（或“折腾”）都能够到达与它的“改动”距离为1的点（是不是想起“编辑距离”这个概念），怎么改动呢？最符合直觉的（虽然并不是唯一的）改动便是把叶子节点进行互换。</p>
<p>于是我们得到一个重要的推论：</p>
<ul>
<li><em>在最优霍夫曼树中，无论互换哪两个叶子节点，得到的树都变得更“差”。（严格来说是不会变得更“好”，因为最优树未必唯一）</em></li>
</ul>
<p>这个性质看上去有点像废话，值得费这么多事么？值得。因为虽然前文说了很多，但都是大多数人大脑里面既有的，一般性的法则，前面说过，如果我们能够从我们已经掌握的一般法则出发来推导出问题的解，那么记忆负担是最小的，因为这里面用到的所有法则我们都很清楚，也知道怎么一步步往下走。</p>
<p>上面这个性质究竟意味着什么呢？如果你假设这两个叶子节点的频率为f1和f2，深度为d1和d2，互换它们的时候，其他叶子节点的cost保持不变，令为常量C，那么互换前总cost为C+f1d1+f2d2，互换后为C+f1d2+f2d1，既然互换之后的树一定更”差“那么就是说f1d1+f2d2 &lt; f1d2 + f2d1，简单变换一下就得到结论：f1(d1-d2)<f2(d1-d2)，也就是说如果d1<d2，那么f1必然>f2，如果d1&gt;d2，那么f1必然&lt;f2。换言之就是<em>叶子节点的深度越高，频率必须越低</em>，否则就不可能是最优霍夫曼树。那么，之前我们觉得不那么显然的结论便呼之欲出了：频率最低的叶子节点必然位于树的最底层，频率最高的叶子节点必然位于树的最高层。</p>
<p>有了这个结论之后，我们便能够对最优霍夫曼树的构建走出确定性的一步，即，将频率最低的两个叶子节点放在最底层。别小看这一步，这一步已经排除了大量的可能性。这里，我们容易一开始天真地觉得最底层只有这两个叶子节点，于是它们拥有共同父节点，<em>这样一来霍夫曼树的整个拼图便已经拼好了一个小小的角落</em>。</p>
<p>然后我们会发现，要是它们不是兄弟怎么办呢？这里提到另一个一般原则——<strong>归约</strong>。不是兄弟的情况能否归约为是兄弟的情况？反正我们要求的是<em>一个</em>最优解，而不是<em>所有的</em>最优解，我们只需证明，如果当这两个最低频率的叶子不是兄弟的时候的确存在着某棵最优霍夫曼树，那么通过交换它们各自的兄弟，从而让这两个叶子团聚之后，修改后的树仍然是最优的就可以了。事实情况也的确如此，证明非常直接——既然这里涉及到的所有4个节点都在最底层同一个高度上，那么互相交换的时候不会改变他们任何一个人的深度值，所以总cost不会改变。</p>
<p>但是接下来我们犯了难，整个树的一个小小的樱桃状的局部是确定下来了，接下来怎么办呢？一个最自然的思路就是考虑第三小的叶子，因为前面说了，元素频率越低就越位于树的底部嘛。第三小的叶子有两种可能的归属，一是跟最小的两个叶子同样位于最底层（这不会违反我们前面得到的推论），这个时候第三小的叶子的兄弟叶子肯定是第四小的叶子，如下图：</p>
<p><a href="http://mindhacks.cn/wp-content/uploads/2011/07/tree3.jpg" target="_blank"><img src="&quot;tree3&quot;" alt="tree3"></a></p>
<p>另一种归属就是往上一层去（注意，一旦第三小的叶子往上去了一层，那么剩下的所有叶子都必须至少在这个层以上），往上一层去了之后，它的兄弟是谁呢？不妨将它和刚才第一第二叶子的父节点结为兄弟（前面证明过，同层之前节点互换不会改变编码的cost），如下图：</p>
<p><a href="http://mindhacks.cn/wp-content/uploads/2011/07/tree5.jpg" target="_blank"><img src="&quot;tree5&quot;" alt="tree5"></a></p>
<p>可是现在问题出现了：虽然第一步构建（最小的两个叶子）是确定的，但是到了第二步摆在我们面前的就有两个选择了，到底选择哪个呢？一个办法就是把两种选择都记下来，然后继续往下走。可是别小看两种选择，接下去每一步都有两种选择的话就变成指数复杂度了。所以现在我们便有了动机<em>回头看一看</em>，<em>看问题中是否有什么没有发现的性质能够帮助我们再排除掉其中一个选择</em>。理想情况下如果每一步都是必然的，确定的，那么N步我们就可以构建出整棵树，这是我们希望看到的，抱着这个良好的愿望，我们仔细观察上面两种构型，一个自然而然的问题是：这两种构型都有潜质成为最优解吗？如果我们能够证明其中一种构型不能成为最优解那该多好？就省事多了嘛。这里引入另一个一般性的解题法则：<strong>特例</strong>。我们的<strong>大脑喜欢具体的东西，在特例中折腾和观察会方便的多</strong>。</p>
<p>上面这个{1, 2, 3, 4}的例子就是个很好的特例，如图（注：图中节点旁的数字一概为<em>频率值，</em>而非编号）：</p>
<p><a href="http://mindhacks.cn/wp-content/uploads/2011/07/tree31.jpg" target="_blank"><img src="&quot;tree3&quot;" alt="tree3"></a></p>
<p>多加折腾一番<em>也许</em>我们不难发现，如果将1，2及其父节点跟叶子4进行交换（注意：<em>交换的时候1，2也被一同带走了</em>，因为反正1，2两个节点已确定是好兄弟永远不会分家了，折腾的时候只能作为一个整体移动，所以这里也可以说是<strong>交换子树</strong>），那么树的编码将会变得更优，因为这样一次交换会将1和2的深度+1，意味着整棵树的代价+3，而同时会将叶子4的深度-1，也就是说整棵树的代价-4，总体上整棵树的代价就是+3-4=-1（注意，在计算的时候我们只需考虑被交换的局部，因为树的其他部分的代价保持不变）。如下图：</p>
<p><a href="http://mindhacks.cn/wp-content/uploads/2011/07/tree4.jpg" target="_blank"><img src="&quot;tree4&quot;" alt="tree4"></a></p>
<p>这个交换启发了我们，其实前面一开始说的交换两个叶子节点<em>可以推广为交换内部节点和叶子节点</em>，然后很快我们就会意识到其实可以推广到交换任意两个节点。（注意，<em>当我们说交换内部节点的时候，其实是连同该内部节点作为局部根节点的整个子树都交换过去</em>）于是前面我们的推论就可以推广为：</p>
<ul>
<li><em>在最优霍夫曼树中，无论互换哪两个节点，得到的树都变得更“差”（交换内部节点则是连同该内部节点作为局部根的子树一同带走）</em></li>
</ul>
<p>这个推论很容易理解，只不过是多增加了一种“编辑”最优霍夫曼树的方法罢了（记住<em>最优霍夫曼树无论怎么“编辑”都不会变得更“好”，包括“交换子树”这种“编辑”</em>），我们前面没有想到这种“编辑”方法是因为它不那么显然，而且当时我们已经想到一种最直接的“编辑”方法了，即交换叶子，就容易顺着那个思路一直走下去，直到我们发现必须寻找新的性质，才回过头来看看有没有其他法子。</p>
<p>当然，并不排除一开始就想到这种推广的可能性，问题求解的过程并不是这么线性的，如果我们习惯了推而广之的思维，也许一下就能想到这个推广来。类似的，也不排除从另一种思路出发想到这种推广的可能性。所以这里只是可能的思维轨迹中的一种，重点在于其中并没有某处忽然出现一个不知从哪里冒出来的，神启一般的结论。</p>
<p>刚才提到，构造最优树的第二步是考虑第三小的叶子，但也有另一种常见的思维：考虑到第一步（即选取频率最小的两个叶子）所做的事情是从N个叶子中选择两个黏在一起作为兄弟，那么也许对于一些人来说自然而然的第二步就是试图继续选取两个节点黏在一起作为兄弟（注意这里不仅可以选择叶子，也可以选择已经生成的内部节点），然后依次类推来拼完整棵树。按照这一思路，第二步的选项仍然还是集中在第三小的叶子上，因为这个选择要么是让第三第四小的叶子结拜为兄弟，要么是让最小两个叶子的父节点和第三小的叶子结拜。</p>
<p>回到刚才我们的推论：在最优霍夫曼树中，无论互换哪两个节点，得到的树都变得更“差”（交换内部节点则是连同该内部节点作为局部根的子树一同带走） 。根据这个推论我们容易计算出，<em>在最优霍夫曼树当中，两个内部节点n1和n2，如果n1比n2更深，那么n1下面的所有叶子的频率之和必然要小于n2下面所有叶子的频率之和</em>。如果交换的是一个内部节点和一个叶子节点，则道理是类似的。这个性质的证明和上面的类似，就不赘述了。</p>
<p>这个性质暗示了一个重要的推广结论：<em>如果我们把每个内部节点的所有叶子的频率之和标在它旁边，那么整棵树的每个节点便都有了一个数值，这个数值遵循统一的规律：即越往深层越小</em>。这就意味着，我们刚才的二选一困境有办法了！当我们将最小的两个叶子f1和f2合并的时候，生成了一个新的节点M，这个节点有一个数字（为两个叶子的频率之和f1+f2），根据上面的推论，<em>这个数字f1+f2跟所有频率一同，遵循最小的在最底层的原则</em>，所以我们下一步必须在剩下的那些互相之间关系待确定的节点（叶子节点和内部节点）之中，即{(f1 + f2), f3, f4}里面选择最小的两个数字结合成兄弟（由于f1和f2这两个节点已经铁板钉钉结为整体了，所以从集合里面可以看做移除）。到这里，我们就发现递归已经出现了，接下去的过程对于绝大多数人应该就真的很显然了。</p>
<p>以上的解释，比《Algorithms》更简短吗？显然不是。反而要长得多（其实真正的思维过程比这要更长，因为中间还会涉及各种不成功的尝试）。但是它比《Algorithms》当中的版本更不容易被忘记，因为其中关键的思维拐点并不是毫无来由的，而是从你已经熟知的，或者说虽然不知道，但容易理解的一般性解题法则出发自然推导出来的，所以你基本上不需要记忆什么东西，因为你需要记的已经在你脑海中了。</p>
<p>在上面的证明过程中，还有一个不像看上去那么显然的事情：在我们寻找最优霍夫曼树的时候，我们曾经试图去比较假想的最优树和它的“临近”的树，从而去探索最优树的性质。但是，究竟什么是临近的树？在前面的讲解中，我们说如果交换A和B这两个叶子节点，便得到一颗不同的树，可以看做和原树的“编辑距离”为1的树。但是，真的这么显然么？难道除了交换叶子的位置，就没有其他办法去“折腾”这棵树了？后来我们看到，可以<em>交换子树</em>而不仅仅是叶子，而交换子树让我们得到了至关重要的推论。此外，如果不是交换，而是像AVL树那样“旋转”呢？说到底，二叉树是一个离散的东西，并不像连续值那样，天生就有“距离”这个概念，如果我们离散而孤立地去看待所有的树，那么没有什么临近不临近的，临近本是一个距离的概念，除非我们定义树和树之间的距离函数，才能说临近与否，而距离函数怎么定义才是“显然”的呢？</p>
<p>还有，其实以上只是试图给出最优霍夫曼树的<em>证明</em>的一个更自然的过程，而<em>当年霍夫曼面临这个问题的时候根本还没有人想到要用二叉树呢！更不要说在二叉树的前提之下进行证明了</em>。根据wikipedia的介绍，霍夫曼同学（当年还在读Ph.D，所以的确是“同学”，而这个问题是坑爹的导师Robert M. Fano<a href="http://www.huffmancoding.com/my-family/my-uncle" target="_blank">给他们作为大作业的</a>，Fano自己和Shannon合作给出了一个suboptimal的编码方案，为得不到optimal的方案而寝食难安，情急之下便死马当活马医扔给他的学生们了）当年为这个问题憔悴了一个学期，最后就快到deadline的时候“忽然”想到二叉树这个等价模型，然后在这个模型下三下五除二就搞定了一篇流芳千古的论文，超越了其导师。</p>
<p>最后说两个有趣的现象：也许很多人会觉得，越是大师来写入门教科书越是好，其实很多时候并非如此，尤其是在算法设计和数学领域，往往越是在其中浸淫久了越是难写出贴近初学者的书，因为大量对初学者来说一点都不显然的事情在他看来已经是“不假思索”了，成了他的内隐记忆，尤其是当他想要和你解释一个复杂的东西的时候你就会发现他会常常逻辑跳跃，满嘴跑术语，根本没有意识到别人对有些术语和隐含的逻辑根本没有像他那样的理解。</p>
<p><strong>最适合将一个东西讲给别人听的时候并不是等懂了很多年以后，而是刚刚弄懂的时候</strong>，这个时候从不懂到懂的差别记忆还非常鲜明，能够清清楚楚地记得到底是哪些关键的地方是最折磨人的，也最能够站在不懂者的角度来思考问题。像波利亚这样，成了大师还能够站在不懂者角度去换位思考的，可以说是凤毛麟角。所以说前Amazon CAO（首席算法官）的<a href="http://www.amazon.com/Introduction-Algorithms-Creative-Udi-Manber/dp/0201120372/" target="_blank">《Introduction to Algorithms: a Creative Approach》</a>绝对是本罕见的好算法书）</p>
<p><a href="http://mindhacks.cn/2008/07/07/the-importance-of-knowing-why/" target="_blank">知其所以然（一）</a>里面曾经提到，要弄清来龙去脉，最好去看看原始作者是怎么想的，可是正如上文所说，即便是最初的发明者，在讲述的时候也会有意无意地“线性化”，我就去查看了霍夫曼最初的论文，那叫一个费解，不信你可以自己看看(<a href="http://compression.ru/download/articles/huff/huffman_1952_minimum-redundancy-codes.pdf" target="_blank">PDF</a>)。</p>
<p>可以归约为搜索算法的问题（非常多）一般来说相对还是有一些头绪的，因为搜索空间一般还比较容易界定，难点在于要从问题的条件中推导出用于节省搜索的性质。而策略设计问题则完全是另一个世界，因为策略的设计空间貌似是可列无穷的，常常让人感觉无从下手，摸不着头绪，许多让人挠头的智力问题就有这个特点（例如著名的100个囚徒和1个灯泡的房间就让很多人有这种感觉），策略设计问题也有一些较通用的法则，以后再说。</p>
<p>怎么才能在学算法的时候学到背后的东西呢？有以下几点很重要：</p>
<ol>
<li><strong>不要觉得每个步骤都很显然</strong>，每个nontrivial的算法背后都有一段艰辛的探索经历，觉得显然的话必然是一种幻觉。<strong>Stay foolish</strong>，才能发现某些环节其实并不是那么显然的。</li>
<li>检验是否真正理解的最佳方法就是<strong>过一段时间之后，自己试着证明一次</strong>。如果真正理解了的话，你的证明便会比较顺畅。如果当时没有真正理解，那么凡是那些你当时觉得显然但其实不显然的地方，都会成为你证明里面缺失的环节。</li>
<li>对于一个算法，<strong>多寻找各种来源的资料</strong>，也许能够找到一个讲的比较深刻的。我在<a href="http://mindhacks.cn/2008/06/13/why-is-quicksort-so-quick/" target="_blank">《数学之美番外篇：快排为什么那么快》</a>和<a href="http://mindhacks.cn/2008/07/07/the-importance-of-knowing-why/" target="_blank">《知其所以然（一）》</a>里面都举到了这样的例子。</li>
<li><strong>多试着去抽象背后的一般性法则</strong>，即便后来发现抽象得是错的，也比不去抽象要好。<a href="http://mindhacks.cn/2009/03/28/effective-learning-and-memorization/" target="_blank">抽象是推广的基础</a>。只有抽象出更深层的法则，才能让你事半功倍，触类旁通，否则一个萝卜永远是一个坑。（注意，其实我们的下意识是会进行一定程度的抽象的，例如前面提到的原始人的例子，小溪和小河（或者小沟）细节上是不同的，但本质上是一样的，我们的大脑会自动进行这种简单抽象，提出事物的共性。正因此，即便你不去有意识地总结一般规律，只要你看的足够多，练的足够多，必然就会越来越谙熟。）</li>
</ol>
<p>最后留个问题：虽然按照上文的方式来构造霍夫曼树一定能够得到<em>一个</em>最优树，但是怎么证明一定能得到呢？乍一看这个问题似乎很多余，因为证明很简单：我们拼装整棵树的每一步都没得选，而且每一步都必然拼凑出最优树的一个小小局部，如果最终还没有得到最优树的话，只能说最优树是不存在的了，然而最优树是一定存在的，因为所有树的集合是有穷的，有穷集必有最值，因此证毕。这个证明固然是没问题的，但它其实是一个间接证明，换句话说，我们在构建树的过程中的逻辑是这样的：“之所以我们选择粘结n1和n2，是因为其他粘法必然违反最优树的两个性质。所以我们别无选择。”但是，这并没有说，我们选择了粘结n1和n2，一定就<em>符合</em>了最优树的性质。（也就是说“其他做法都是错”并不能推出“这种做法必然对”，这就像是你在一大堆豆子当中寻找一个特殊的豆子，你拿起一个，看看不是，扔掉，又拿起一个，还不是，扔掉，排除到最后只剩一个豆子了，假设你又知道这个特殊的豆子必然存在，那么这个时候你根本不用看就知道这个豆子一定就是你要找的）那么，你能否直接证明，拼装最优树的过程每一步都<em>符合</em>最优树的性质呢？</p>
<p>P.S.</p>
<p>[1] 《逃出你的肖申克》和《BetterExplained》是我喜欢的两个系列，还会继续写，我有很多问题，也在Evernote里面记了不少零碎的思考和资料，但只有当我觉得理解的足够深入，系统，以及手头有足够的有意思和有说服力的例子的时候，我才会把整条线串起来成文，所以这事慢慢来不着急，反正这个博客也不会关掉。</p>
<p>[2] 工作之后可用业余时间急剧减少，已经陆续基本把GReader砍掉了，时间再往前推，砍掉邮件列表，再往前是Twitter，再往前是BBS。现在基本就只剩邮件了。越来越发现当时间有限的时候，看书比看网要有效得多，也不会那么信息焦虑，网络上的那些消息当中真正重要的会自己来找你，不用每天去刷屏。不过有个例外，我过一阵子就会去逛一下Amazon的个性化推荐项目。如果你已经工作，苦于时间有限，我建议你这么做。最近看过的几本值得好好推荐的书有：《Number Sense》，《Reading in the Brain》，《The Vision Revolution》，《The Tell-Tale Brain》，《Kluge》。</p>
<p>[3] 顺便吐槽国内出版社引进Pop Science类书籍的效率和质量，就我观察，台湾引进Pop Science类书籍需要延迟两年左右，大陆则从三四年到无限期不等（某种程度上，一个国家的出版方的认识水平，决定了这个国家大众的认识水平。你去看下我在豆瓣的书单就知道有多少好书与国内读者失之交臂了），例如《Number Sense》这本好书，到现在还没有引进，99年出版的书啊。《Kluge》更是译为《乱乱脑》这种坑爹的书名，封面搞得跟少儿读物一样。《Reading in the Brain》引入的算较快的，但也延迟了一年半了，而且翻译质量也不是很上乘（算是不功不过吧），说到这里要赞中信出版社，最近一年引入了很多给力的Pop Science畅销书，眼光还算不错。最近在Amazon上搜一些好的发展心理学的书，通过Amazon的推荐引擎看到了<a href="http://www.amazon.com/Pink-Brain-Blue-Differences-Troublesome/dp/0618393110" target="_blank">《Pink Brain，Blue Brain》</a>，这本受到因研究大脑记忆的分子机制而获诺奖的Eric Kandel盛赞的科普09年就出了，到现在国内影子都见不着，还好在卓越上买到了原版。虽然基本还没开始看，但可以郑重推荐给初为父母的同学们:)
来源： <a href="[http://mindhacks.cn/2011/07/10/the-importance-of-knowing-why-part3/](http://mindhacks.cn/2011/07/10/the-importance-of-knowing-why-part3/)">[http://mindhacks.cn/2011/07/10/the-importance-of-knowing-why-part3/](http://mindhacks.cn/2011/07/10/the-importance-of-knowing-why-part3/)</a> </p>
<ul>
<li>kw</li>
</ul>
<p>哇塞，又是不鸣则已，一鸣惊人！</p>
<p>2011年7月10日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="dribble"></li>
</ul>
<p>dribble</p>
<p>其实我倒真是觉得在算法证明的时候用一堆符号有什么不好，因为算法本身就是应用数学，数学需要符号化。算法的牛人们很多都有数学、物理的背景，我觉得就算是理解了某一个算法设计最像idea的地方，对自己设计算法并没有本质的帮助，只能帮助记住这个算法而已。</p>
<p>2011年7月10日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="felven"></li>
</ul>
<p>felven</p>
<p>沙发，正如老师所说的，把算法学好了去哪里都不成问题</p>
<p>2011年7月10日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="cacard"></li>
</ul>
<p>cacard</p>
<p>moring...</p>
<p>2011年7月10日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="sk.c"></li>
</ul>
<p>sk.c</p>
<p>沙发？？？好久没见更新了。。。^_^</p>
<p>2011年7月10日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="limitlimiter"></li>
</ul>
<p>limitlimiter</p>
<p>让我重新捡起算法，谢谢未鹏大牛</p>
<p>2011年7月10日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="佘明磊"></li>
</ul>
<p>佘明磊</p>
<p>谢谢你，虽然有技术壁垒我不大看懂！</p>
<p>2011年7月10日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://www.helishi.net/" title="ikbear" target="_blank"><img src="" alt="ikbear"></a></li>
</ul>
<p><a href="http://www.helishi.net/" target="_blank">ikbear</a></p>
<p>很多思维结论的背后，并不是有确定的东西。发明者之所以连自己都没法将其讲清楚，很可能是这确实无从谈起，因为它确实是一丝灵光的结果；也可能是他的思维确实无法轻易让普通人理解；或者他根本就表达不好。
虽然说，写书的人把那些探索算法的思维过程写出来能够很好的帮助读者理解，让读者跟深更快的掌握算法。但是这也仅限于让读者掌握，让读者接受。这样，读者不光要接受其结论，连其思考过程也要接受。这本身就扼杀了想象力，还是停留在“背”的阶段。拿毕达哥拉斯定理来说，几百种的证明，每一种证明都有不同的思维过程。如果你认为探索每一种证明的思维过程就认为掌握了它，那么它的第二种第三种第N种证明又是从何而来的？
真正要去探索算法，应该是在基本理解算法之后，再去自己思考。参考别人的思考过程可能可以帮助自己思考，但参考别人的思考过程并不代表自己思考，两者并不等同。不过，这正是常人无法得到的。</p>
<p>2011年7月10日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="dsigma"></li>
</ul>
<p>dsigma</p>
<p>我是菜鸟，我倒非常认同刘老师的观点，必须有所思考！
理解是一个思考的过程，而回味这个理解的过程才是我成长的过程。</p>
<p>2011年7月19日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://aboutminds.net/" title="kevinyzd" target="_blank"><img src="" alt="kevinyzd"></a></li>
</ul>
<p><a href="http://aboutminds.net/" target="_blank">kevinyzd</a></p>
<p>订阅你的blog很长时间。我喜欢这种典型的逻辑教程，我虽然数学不是非常好，但希望可以从中得到更多的了解，因为这确实是一个非常有意思的东西。另外你写文章的方式或多或少对我有所影响。</p>
<p>2011年7月10日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://workzen.net/" title="Fey" target="_blank"><img src="" alt="Fey"></a></li>
</ul>
<p><a href="http://workzen.net/" target="_blank">Fey</a></p>
<p>期待刘未鹏的书《暗时间》出版...</p>
<p>2011年7月10日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="feirainy"></li>
</ul>
<p>feirainy</p>
<p>&quot;大脑喜欢具体的东西，在特例中折腾和观察会方便的多，也许我们不难发现，如果交换1，2的父节点（因为反正1，2两个节点已确定是好兄弟永远不会分家了，折腾的时候只能作为一个整体移动）和叶子4，那么树的编码将会变得更优.&quot;－－在这里纠结了好一阵。。。</p>
<p>2011年7月10日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://weibo.com/pongba" title="刘未鹏pongba" target="_blank"><img src="" alt="刘未鹏pongba"></a></li>
</ul>
<p><a href="http://weibo.com/pongba" target="_blank">刘未鹏pongba</a></p>
<p>谢谢提醒，我已经根据你和楼下abellong的意见修改了那部分。我自己写到那里的时候也觉得似乎有点拗口，当时偷懒没改:D</p>
<p>2011年7月10日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="feirainy"></li>
</ul>
<p>feirainy</p>
<p>谢谢回复，关于特例的那一段，因为当时折腾了一阵，后面见到未鹏修改了却与我当时的理解不太一样，我表示提出一点点意见，本人只是菜鸟，如有错，请见谅。</p>
<ol>
<li>对特例的折腾，最后得出的启发是：“在最优霍夫曼树中，无论互换哪两个节点，得到的树都变得更“差””。
可是特例呈现出来的是，通过交换1、2的父结点与结点4（编号是频率），可以得到更“优”的树，这对交换后得出更“差”的启发刚好相反。
（不过因为情况只有两种，即结点3与结点12在同一层，以及结点3在上一层，所以拐个弯能够想到从情况1到情况2更优，即相当于从情况2到情况1更差）。</li>
<li>特例提出的是，在最小的4个频率值为1，2，3，4时，交换1，2的父结点与结点4可以减少树的总代价，得到更优的树。
然后我当时就觉得，如果最小的4个频率值为3，4，5，6时，以同样方式交换结点树的总代价却会增大。于是觉得这样交换代价可能增大，可能减少，不能确定什么呀。。。
后面终于注意到，因为第3个最小频率值的结点的情况只有两种，就是说两种情况有一种比另一种更优（至少不会更差？），于是第3个最小频率值的结点的位置就确定下来了，在此位置确定的基础上，交换确实会令树的代价增加（至少不减少），于是也可以推广交换的方式了。</li>
</ol>
<p>2011年7月11日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://weibo.com/pongba" title="刘未鹏pongba" target="_blank"><img src="" alt="刘未鹏pongba"></a></li>
</ul>
<p><a href="http://weibo.com/pongba" target="_blank">刘未鹏pongba</a></p>
<p>@feirainy，谢谢你提的疑惑。说明我还是没有讲好:)
是这样的，特例中得出的启发仅仅是“可以交换子树，而不仅仅是交换叶子”，仅此而已。至于“最优霍夫曼树中无论交换哪两个子树都使cost增加”并不是特例中得出的推论，而是最优霍夫曼树的“最优”性质得出的直接推论。</p>
<p>2011年7月11日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="abellong"></li>
</ul>
<p>abellong</p>
<p>&quot;频率最低的两个节点必然处于编码树的最底层，但未必一定要是兄弟节点&quot; 这个说法也不严谨，反例：1,1,1,3总有一个频率为1（最低）的在倒数第二层，不是最底层。
“在上面的例子中，我们已经有了特例”，表示不知道特例在哪里？因此，“如果交换1，2的父节点和叶子4，那么树的编码将会变得更优”这个结论也不是“不难发现”，甚至错误。
那个推广，似乎就是从“特例”里得到启发，并没有证明（至少是严格证明），让人不放心
总的感觉，此篇文章仍然让人费解……
我觉得一般书上让人难以理解的其中一点是略去了一些特例（比如频率相等的情况），这些可以通过“归约”解释，可以多花心思在这里：为什么可以只处理某一种情况，其他都可以归约为这种情况？</p>
<p>2011年7月10日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://weibo.com/pongba" title="刘未鹏pongba" target="_blank"><img src="" alt="刘未鹏pongba"></a></li>
</ul>
<p><a href="http://weibo.com/pongba" target="_blank">刘未鹏pongba</a></p>
<ol>
<li>“频率最低的两个节点必然处于编码树的最底层，但未必一定要是兄弟节点” 的确不严谨。谢谢指出。准备添加说明：“当频率最低的两个节点处于不同层的时候，必然可以归约为同层”</li>
<li>特例就是1,2,3,4那个例子。“交换1,2的父节点和叶子4”是指交换1,2那个子树（1,2和他们的父亲）和叶子4。交换后的情况我画了图。</li>
<li>那个推广的确是特例中的启发，然后后面是有证明的。如果你说的是“在最优霍夫曼树中，无论互换哪两个节点，得到的树都变得更“差”（交换内部节点则是连同该内部节点作为局部根的子树一同带走）”这个推广没有证明的话，我想说的是这个是“最优树”的定义的直接蕴含啊，不需要证明。如果你说的是“在最优霍夫曼树当中，两个内部节点n1和n2，如果n1比n2更深，那么n1下面的所有叶子的频率之和必然要小于n2下面所有叶子的频率之和。”这个推广没有证明的话，是因为证明和置换叶子节点的情况类似，文中提了“不加赘述”。
谢谢指正。</li>
</ol>
<p>2011年7月10日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="abellong"></li>
</ul>
<p>abellong</p>
<p>谢谢回复:)
第二个问题，回想我当时的理解：我把那俩幅图里的1、2、3、4默认成编号，即第1小、第2小（而不是理解成频率）…导致我错了。当时脑子短路，没转过来。 不过还是建议换个数字更好些
提的第三个问题 真完全是我的问题了，没有仔细考虑，胡乱就问了，惭愧
谢谢您的分享，从您博客我学到了很多:)</p>
<p>2011年7月10日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="abellong"></li>
</ul>
<p>abellong</p>
<p>回头再看，发现您修改后意思已非常明确了，忽略那个建议吧</p>
<p>2011年7月10日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://weibo.com/pongba" title="刘未鹏pongba" target="_blank"><img src="" alt="刘未鹏pongba"></a></li>
</ul>
<p><a href="http://weibo.com/pongba" target="_blank">刘未鹏pongba</a></p>
<p>@abellong
根据你的建议我仔细修改了那一段的细节，其实我当时写的时候也是觉得那段有点拗口。楼上的feirainy也提了类似的疑惑。
“1、2、3、4默认成编号，即第1小、第2小（而不是理解成频率）”，恩，这个我再想想，也许回头加个注。
再次感谢。</p>
<p>2011年7月10日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://weibo.com/pongba" title="刘未鹏pongba" target="_blank"><img src="" alt="刘未鹏pongba"></a></li>
</ul>
<p><a href="http://weibo.com/pongba" target="_blank">刘未鹏pongba</a></p>
<p><a href="">回复 abellong: </a>我回头看了一下，的确{1,2,3,4}有编号之嫌，因为前文提到第一第二小，和第三第四小，恰巧用的频率也是1，2，3，4，所以的确有点容易混淆。所以我在“特例”那个地方加了括号说明是频率。当然具体频率数字最好是改掉，不过还要重新作图，就懒了:)</p>
<p>2011年7月10日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://mindlee.net/" title="酷~行天下" target="_blank"><img src="" alt="酷~行天下"></a></li>
</ul>
<p><a href="http://mindlee.net/" target="_blank">酷~行天下</a></p>
<p>未鹏大牛终于更新了，学算法学的头大………</p>
<p>2011年7月10日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="Kejia"></li>
</ul>
<p>Kejia</p>
<p>你写的真好。</p>
<p>2011年7月11日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://moodylee.me/" title="moody" target="_blank"><img src="" alt="moody"></a></li>
</ul>
<p><a href="http://moodylee.me/" target="_blank">moody</a></p>
<p>时隔半年，ponba终于又出手了。</p>
<p>2011年7月11日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://www.bengogo.com/" title="好看的电影" target="_blank"><img src="" alt="好看的电影"></a></li>
</ul>
<p><a href="http://www.bengogo.com/" target="_blank">好看的电影</a></p>
<p>哈哈还好我以前的数学还算不错！算术这东西就要思考</p>
<p>2011年7月11日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="hlily"></li>
</ul>
<p>hlily</p>
<p>好吧。。我承认太长的博客。我总是看不下去~</p>
<p>2011年7月11日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="custqi"></li>
</ul>
<p>custqi</p>
<p>几乎所有的算法都来源于其背后的数学知识， 像图论， 贪心有拟阵， 动态规划出自运筹学，搜索其实也能从图论延伸出来，当然还有更难一些的搜索，数论也有专门的数学教材等等， 个人认为用一个学习算法 应该用一个 数学的头脑去学习，一些推导证明更应该用 数学的思维去验证，当然也可以用实例数据去手工执行代码，这样会好理解一些，仅一家之言，口水就不必了。</p>
<p>2011年7月11日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="gordon"></li>
</ul>
<p>gordon</p>
<p>何为“数学的头脑”？帅哥，你还没有说出来啊。呵呵
其实这篇文章已经讲的很清楚了，基本思想就是“读完以后，合上书，你把它复述出来。 ”
这个可是不容易啊，pongba做这个都很吃力的。
要什么自行车，搞的强盗不像强盗，猴子不像猴子的，还是干强盗这份比较有前途的职业吧。
------- 摘自《大话西游》和《卖拐》
当然个人爱好除外。</p>
<p>2011年7月12日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="gordon"></li>
</ul>
<p>gordon</p>
<p>算法在狭义上压根就不是计算机专业的内容，那是计算数学专业的内容。当然非要抬杠说，只要是涉及到计算的都属于计算科学，也属于计算机科学，我也无语。
但那真不是计算机科学的内容，计算科学不等于计算机科学，OK。</p>
<p>2011年9月16日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="gordon"></li>
</ul>
<p>gordon</p>
<p>计算机这个专业是讲什么的，就是讲什么是计算机，从底层硬件、接口技术到用晶体管做一个4位计算机的实现，再到内外存，硬件结束上升到系统软件；
操作系统如何管理硬件，内存管理、磁盘管理等东东，编译器，数据库；系统软件结束了就是应用软件。然后计算机和计算机之间有通讯，就是计算机网络。
完了，真的完了。
计算机专业的数学和其他专业需要计算机处理的数学要分清楚，要清楚的分开。
要搞清楚计算机专业的研究对象是什么，狭义的计算机专业压根就不研究算法，研究的是数据结构。
但是如何选择数据结构？却要把算法提出来，选择不同的数据结构，算法复杂度是不一样的，
也就是说数据结构定了，就会降低算法实现的复杂度。
就是为了讲清楚数据结构怎么选择的问题，所以稍带把算法也讲了，就是这样。</p>
<p>2011年9月16日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="黄铂钧"></li>
</ul>
<p>黄铂钧</p>
<p>计算机学科的“教学”和“研究”要分清楚，要清楚的分开。
要搞清楚计算机专业的教学对象是什么，狭义的计算专业压根就不教“计算机相关研究所需的知识”，教的是“如何把已有的计算机知识应用到实际中”
不过话说回来，现在计算机专业的教学确实很差，只是谁也没有能力去改进而已。</p>
<p>2011年11月12日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="gordon"></li>
</ul>
<p>gordon</p>
<p>码农要研究算法的原因是因为有其他行业的问题需要计算机来处理，这个在公司中一般应该专门设置这样的算法岗位，招聘“ 计算数学 “专业的人才。
小公司一般没有这个岗位，大多是拿开源的工具包在用，只要能看懂文档，会用就行了。</p>
<p>2011年9月16日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://www.iphonephysics.com/" title="iphysics" target="_blank"><img src="" alt="iphysics"></a></li>
</ul>
<p><a href="http://www.iphonephysics.com/" target="_blank">iphysics</a></p>
<p>大刘的想法和我非常相似，多年以来我在数学的学习过程中深有体会，
定理的探索 有很多失败，试错，摸索的过程， 《费马大定理》这本书就是一个揭示类似过程的好例子，可是在教科书和课堂上出现的都是千锤百炼的最精炼的结果，学生学不到如何去摸索，可是要完全再现摸索的过程，确实需要非常精深的学识与阅历。不是一般老师可以达到的</p>
<p>2011年7月12日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="Greg"></li>
</ul>
<p>Greg</p>
<p>您的文章阐述的观点很正确，给人很大启发。
但关于您的文章的表达方面，我从一个读者角度提出一个建议：
我希望您写文章能够更加深入浅出，就是能一目了然的明白文章的主旨。
拿这篇文章作例，我理解的主旨就是：学习算法的好途径是透彻地理解算法。也就是“知其所以然”的学习。（我十分赞同这个观点，自己也是努力这么做的。）
我希望您的表达能更直观，要做到这样本身就需要首先对自己的观点有透彻的理解，不然就容易东一句西一句，抓不住要领。
谢谢。</p>
<p>2011年7月12日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="jkryanchou"></li>
</ul>
<p>jkryanchou</p>
<p>终于更新了。。等过一个又一个季节。又是一篇佳作。。未鹏，一直期待你文章。。。持续关注中。</p>
<p>2011年7月12日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="4D"></li>
</ul>
<p>4D</p>
<p>光滑函数的最值点必然是大（小）于其邻域内的所有点的
这个好像不是最值点的定义吧，这个是极大值点的定义吧</p>
<p>2011年7月13日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://weibo.com/pongba" title="刘未鹏pongba" target="_blank"><img src="" alt="刘未鹏pongba"></a></li>
</ul>
<p><a href="http://weibo.com/pongba" target="_blank">刘未鹏pongba</a></p>
<p>不是定义，是必要条件。</p>
<p>2011年7月13日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="JOB"></li>
</ul>
<p>JOB</p>
<p>我是个大三的学生，您在例证中对哈夫树的讲解跟我们当年离散数学的老师讲的有异曲同工之妙，我现在倒是很感激那个老师了。</p>
<p>2011年7月13日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="JOB"></li>
</ul>
<p>JOB</p>
<p>对于在结尾处您埋下的问题，可否指点一二？</p>
<p>2011年7月14日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://weibo.com/sun0721?inviteCode=1715455645" title="miracle-light" target="_blank"><img src="" alt="miracle-light"></a></li>
</ul>
<p><a href="http://weibo.com/sun0721?inviteCode=1715455645" target="_blank">miracle-light</a></p>
<p>真是太感谢啦，这么好的内容怎么能错过呀，老天有眼！</p>
<p>2011年7月14日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://hi.baidu.com/gevolution90/" title="朱健强" target="_blank"><img src="" alt="朱健强"></a></li>
</ul>
<p><a href="http://hi.baidu.com/gevolution90/" target="_blank">朱健强</a></p>
<p>若是博主把使用 evernote 的方法，技巧，收获等写成一文，想必定是一篇佳作。</p>
<p>2011年7月15日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://www.nb-lz.com/" title="宁波餐饮管理" target="_blank"><img src="" alt="宁波餐饮管理"></a></li>
</ul>
<p><a href="http://www.nb-lz.com/" target="_blank">宁波餐饮管理</a></p>
<p>学习下，谢谢博主分享</p>
<p>2011年7月18日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="黄铂钧"></li>
</ul>
<p>黄铂钧</p>
<p>&quot;设计算法的难处在于，定理和证明都需要你去探索，尤其是前者&quot;
设计算法可以看成是在做解答题,而解答题比证明题难是共识吧.其实数学也一样,主要成果体现在定理的提出,而不在于证明
&quot;理想的算法书应该通过还原算法的探索过程&quot;
没有textbook会这么写的，因为那样写出来的书会奇厚无比，知识的传达应以简洁为好。只有&quot;how to solve it&quot;这种科普读物才有篇幅会讨论思考方法
“当年Shannon都没搞定的这个问题花了他一学期”
我听说的版本是Huffman只用了一个下午就证明了这个贪心算法的最优。就像你说的，huffman面对的问题，难点不在于证明最优性（他只用了半天），而在于提出这个greedy algorithm本身（他用了一个学期）。而通常算法书上只涉及最优树构建这个相对简单的子问题。
“有没有可能把霍夫曼编码讲的更好呢”
taocp里讲的很清楚（可能因为knuth当年专门研究过haffman algebra）</p>
<p>2011年7月20日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="黄铂钧"></li>
</ul>
<p>黄铂钧</p>
<p>解决huffman的最优编码问题，关键在于把它转化成tree construction问题；但有意思的是，想说清楚huffman算法却恰恰要避开tree construction这个视角。只要纠缠在“树”，“节点”，“叶子”这些概念上，无论你怎么解释都会显得cumbersome。
至于思考方法，对于huffman tree这个具体问题，我个人的经验是关键在于要意识到，所谓的&quot;optimal tree&quot;其实往往不止一个，也就是说，同时存在相当数量的彼此不同的树它们都是最优的。一旦意识到这一点证明思路就走上正轨了，后面那些“交换”什么的都是技术问题，仔细思考加上一些耐心就会自然得到。</p>
<p>2011年7月20日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://www.mllovw.info/" title="babyface" target="_blank"><img src="" alt="babyface"></a></li>
</ul>
<p><a href="http://www.mllovw.info/" target="_blank">babyface</a></p>
<p>不错，过来支持下~~</p>
<p>2011年8月2日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://www.hx569.com/" title="丰禾棋牌" target="_blank"><img src="" alt="丰禾棋牌"></a></li>
</ul>
<p><a href="http://www.hx569.com/" target="_blank">丰禾棋牌</a></p>
<p>你成功的让我把头都看大了。</p>
<p>2011年8月5日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://king.violinmm.com/" title="violin" target="_blank"><img src="" alt="violin"></a></li>
</ul>
<p><a href="http://king.violinmm.com/" target="_blank">violin</a></p>
<p>很是佩服楼主如此博学，真是值得学习的好地方！</p>
<p>2011年8月12日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://www.tong12.com/" title="北京时尚摄影" target="_blank"><img src="" alt="北京时尚摄影"></a></li>
</ul>
<p><a href="http://www.tong12.com/" target="_blank">北京时尚摄影</a></p>
<p>博主真是个用脑之人啊，这分析的，佩服佩服</p>
<p>2011年8月16日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://www.9sh.net/" title="仁心博客" target="_blank"><img src="" alt="仁心博客"></a></li>
</ul>
<p><a href="http://www.9sh.net/" target="_blank">仁心博客</a></p>
<p>文字好多 啊</p>
<p>2011年8月29日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://yaojingguo.iteye.com/" title="小雨" target="_blank"><img src="" alt="小雨"></a></li>
</ul>
<p><a href="http://yaojingguo.iteye.com/" target="_blank">小雨</a></p>
<p>有道理。</p>
<p>2011年9月19日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://zwl.me/" title="守候幸福" target="_blank"><img src="" alt="守候幸福"></a></li>
</ul>
<p><a href="http://zwl.me/" target="_blank">守候幸福</a></p>
<p>和高中学习一样，有些人一下子就会了 而且融汇贯通</p>
<p>2011年9月21日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://www.stonecrushermobile.org/" title="stone crusher" target="_blank"><img src="" alt="stone crusher"></a></li>
</ul>
<p><a href="http://www.stonecrushermobile.org/" target="_blank">stone crusher</a></p>
<p>不错。支持</p>
<p>2011年10月9日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://www.popbedding.com/" title="train quilt" target="_blank"><img src="" alt="train quilt"></a></li>
</ul>
<p><a href="http://www.popbedding.com/" target="_blank">train quilt</a></p>
<p>文章很好。另外，验证码也太长了···</p>
<p>2011年10月10日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://stackpop.org/blog/" title="stackpop" target="_blank"><img src="" alt="stackpop"></a></li>
</ul>
<p><a href="http://stackpop.org/blog/" target="_blank">stackpop</a></p>
<p>呵呵~算法到底是像奥数一样的东西还是什么？</p>
<p>2011年10月10日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://www.a891.com/" title="芳草集" target="_blank"><img src="" alt="芳草集"></a></li>
</ul>
<p><a href="http://www.a891.com/" target="_blank">芳草集</a></p>
<p>文字好多 啊</p>
<p>2011年10月27日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://blog.csdn.net/ty1921" title="Ty1921" target="_blank"><img src="" alt="Ty1921"></a></li>
</ul>
<p><a href="http://blog.csdn.net/ty1921" target="_blank">Ty1921</a></p>
<p>上班偷空来瞅着终于更新了，只是比以前长的多，晚上回去细看。
想起前两天的小事：看京东有卖大大的书，买回来一看，后面有一部分算法方面的，给读中学的小弟是不成了，又舍不得，最后让他撕了前一半（暗时间...），我撕了后一半 - -/#</p>
<p>2011年11月3日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="zy498420"></li>
</ul>
<p>zy498420</p>
<p>寻找特定解的过程是个构建无噪声有损信道的信息传递过程，前提条件是信源，信息量损失越小，所得结果更general的概率越高。对于有限字符集和离散无记忆信源寻找前缀码编码表的过程，显然码率越好结果算是更general。该问题信源中有效信息是（前提条件）：字符集对应分布值的比例（绝对值无意义，属于无效信息，信道可以丢失这个信息），互斥事件加法法则（不同字符独立且互斥，“或”的概率可以直接相加），对结果的最优化要求是一个约束，也就是对信道本身做了一些限制，要求某些结果集的概率为0。太困了，改日再说。</p>
<p>2011年12月6日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="haozijun"></li>
</ul>
<p>haozijun</p>
<p>第一次来到这里，作者写的真是深奥，5年没有碰数学了，关于信道什么的都忘光了，现在想要捡起来。向楼主学习。也希望能和楼主交流，我的QQ229742946，希望加我</p>
<p>2012年5月23日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="Zhen"></li>
</ul>
<p>Zhen</p>
<p>Hi, your word 事半功倍 is misused. It is 事倍功半 if I am right.
Thanks</p>
<p>2012年3月12日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="伊生臻爱"></li>
</ul>
<p>伊生臻爱</p>
<p>未鹏大哥，你应该是计算数学专业吧，现在改名叫信息与计算科学，我也是这个专业，但是觉悟远远不如你，像你看齐，还好现在才大二，大一基本玩过去的，专业课都没学，要补啦，像数分、高代的，全要补。。。</p>
<p>2012年3月28日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="raof01"></li>
</ul>
<p>raof01</p>
<p>且不说算法如何难，就尾递归而论，虽然不太复杂，也需要经过“试错、联想……”等一系列探索，才能真正掌握，才能应用到实际问题中去</p>
<p>2012年5月24日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="story"></li>
</ul>
<p>story</p>
<p>刘老师，不知道能否写写有关编程语言的学法，您的博客正是有种相见恨晚的感觉</p>
<p>2012年8月10日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://xq.com.nu/" title="haitao" target="_blank"><img src="" alt="haitao"></a></li>
</ul>
<p><a href="http://xq.com.nu/" target="_blank">haitao</a></p>
<p>构造算法不难，论证才难！
比如，我设计了一个加密算法、伪随机生成算法，怎么验证加密强度、随机程度，真的难！</p>
<p>2012年8月13日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="路人"></li>
</ul>
<p>路人</p>
<p>个人猜测整楼的评论没有一个学历超过研究生的</p>
<p>2012年8月18日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://blog.yejintao.cn/" title="叶金涛" target="_blank"><img src="" alt="叶金涛"></a></li>
</ul>
<p><a href="http://blog.yejintao.cn/" target="_blank">叶金涛</a></p>
<p>数学是计算机的根基，算法是编程的根本，知其所以然，才能用科学的眼光探讨问题。这也是专业培养所在——计算机科学与技术。</p>
<p>2012年8月21日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://www.zwjdjx.com/" title="折弯机模具" target="_blank"><img src="" alt="折弯机模具"></a></li>
</ul>
<p><a href="http://www.zwjdjx.com/" target="_blank">折弯机模具</a></p>
<p>算法总是在变啊，哎，计划永远赶不上变化啊</p>
<p>2012年10月26日<a href="">回复</a><a href="">顶</a><a href="">转发</a><a href="">举报</a></p>
<ul>
<li><a href="http://weibo.com/feiyuliu" title="Feythin Lau" target="_blank"><img src="" alt="Feythin Lau"></a></li>
</ul>
<p><a href="http://weibo.com/feiyuliu" target="_blank">Feythin Lau</a></p>
<p>数学是算法的基础，算法是程序的灵魂。。。</p>
<p>2012年11月3日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://www.renren.com/profile.do?id=282621198" title="杨翼" target="_blank"><img src="" alt="杨翼"></a></li>
</ul>
<p><a href="http://www.renren.com/profile.do?id=282621198" target="_blank">杨翼</a></p>
<p>总是知其然不知其所以然</p>
<p>1月3日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://ifeve.com/" title="并发编程" target="_blank"><img src="" alt="并发编程"></a></li>
</ul>
<p><a href="http://ifeve.com/" target="_blank">并发编程</a></p>
<p>知其然容易，知其所以然难。而对于算法必须要知其所以然。</p>
<p>1月21日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/好文摘录/">好文摘录</a></li></span></span> | <span class="time">recent updated:<time title="2014-03-07 11:24:29"datetime="2014-03-07 11:24:29"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/03/2014-02-03--知其所以然（三）：为什么算法这么难？/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-03--知其所以然（三）：为什么算法这么难？" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/03/2014-02-03--{技术}{多线程}实施并行编程的五大障碍/">{技术}{多线程}实施并行编程的五大障碍</a></h1>
      
        <span>Posted on<time datetime="2014-02-03T03:24:29.000Z"> <a href="/2014/02/03/2014-02-03--{技术}{多线程}实施并行编程的五大障碍/">feb. 3 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-">{技术}{多线程}实施并行编程的五大障碍</h1>
<p>要使用 Google·网上论坛讨论区，请在您的浏览器设置中启用 JavaScript，然后刷新该网页。   <plaintext/><xmp>.</p>
<ol>
<li><a href="https://plus.google.com/?gpsrc=ogpy0&amp;tab=gX" target="_blank">+你</a></li>
<li><a href="http://www.google.com/webhp?hl=zh-CN&amp;tab=gw" target="_blank">搜索</a></li>
<li><a href="http://www.google.com/imghp?hl=zh-CN&amp;tab=gi" target="_blank">图片</a></li>
<li><a href="https://maps.google.com/maps?hl=zh-CN&amp;tab=gl" target="_blank">地图</a></li>
<li><a href="https://play.google.com/?hl=zh-CN&amp;tab=g8" target="_blank">Play</a></li>
<li><a href="https://www.youtube.com/?tab=g1" target="_blank">YouTube</a></li>
<li><a href="https://news.google.com/nwshp?hl=zh-CN&amp;tab=gn" target="_blank">新闻</a></li>
<li><a href="https://mail.google.com/mail/?tab=gm" target="_blank">Gmail</a></li>
<li><a href="https://drive.google.com/?tab=go" target="_blank">云端硬盘</a></li>
<li><a href="https://www.google.com/calendar?tab=gc" target="_blank">日历</a></li>
<li><p><a href="http://www.google.com/intl/zh-CN/options/" target="_blank">更多</a></p>
</li>
<li><p><a href="https://translate.google.com/?hl=zh-CN&amp;tab=gT" target="_blank">翻译</a></p>
</li>
<li><a href="http://www.google.com/mobile/?hl=zh-CN&amp;tab=gD" target="_blank">移动</a></li>
<li><a href="http://books.google.com/bkshp?hl=zh-CN&amp;tab=gp" target="_blank">图书</a></li>
<li><a href="https://wallet.google.com/manage/?tab=ga" target="_blank">电子钱包</a></li>
<li><a href="https://www.blogger.com/?tab=gj" target="_blank">Blogger</a></li>
<li><a href="https://www.google.com/finance?tab=ge" target="_blank">财经</a></li>
<li><a href="https://plus.google.com/photos?tab=gq" target="_blank">相册</a></li>
<li><a href="http://video.google.com/?hl=zh-CN&amp;tab=gv" target="_blank">视频</a>
1.</li>
<li><a href="http://www.google.com/intl/zh-CN/options/" target="_blank">更多</a></li>
</ol>
<p><a href="https://groups.google.com/d/overview" title="Google 网上论坛"></a></p>
<p>隐藏字段搜索论坛或帖子</p>
<p><img src="" alt=""></p>
<h2 id="account-options">Account Options</h2>
<p>1.</p>
<ol>
<li><a href="https://www.google.com/a/UniversalLogin?continue=https%3A%2F%2Fgroups.google.com%2Fd%2Ftopic%2Fpongba%2FBPGNU3OJZos&amp;hl=zh-CN&amp;service=groups2&amp;hd=default" target="_blank">登录</a><h2 id="-"><a href="">网上论坛</a></h2>
</li>
</ol>
<p><img src="" alt=""><img src="" alt="">第  个，共  个（ 个未读）</p>
<p><img src="" alt="">
<img src="" alt=""></p>
<p><img src="" alt=""></p>
<p><img src="" alt=""></p>
<p><a href="">首页</a></p>
<p>导入预定义搜索，将它们添加到您保存的搜索结果中。</p>
<p>点击论坛的星标即可收藏它
[0</p>
<h3 id="-">最近看过的论坛</h3>
<p>]()</p>
<p><a href=""></a></p>
<p><a href="">0  TopLanguage</a></p>
<p>[0</p>
<h3 id="-">最近的搜索</h3>
<p>]()</p>
<p><a href=""></a>
[0</p>
<h3 id="-">最近发过帖的论坛</h3>
<p>]()</p>
<p><a href=""></a></p>
<p>请<a href="https://www.google.com/a/UniversalLogin?continue=https%3A%2F%2Fgroups.google.com%2Fd%2Ftopic%2Fpongba%2FBPGNU3OJZos&amp;hl=zh-CN&amp;service=groups2&amp;hd=default" target="_blank">登录</a>或开始浏览，以整理您的论坛并查看最近的项目。</p>
<p>©2013 Google
<a href="http://www.google.com/intl/zh-CN/policies/privacy/" target="_blank">隐私权政策</a>  -  <a href="http://www.google.com/intl/zh-CN/policies/terms/" target="_blank">服务条款</a>  -  <a href="http://www.google.com/" target="_blank">Google 首页</a></p>
<p><a href=""></a> <a href=""></a> <a href="">TopLanguage</a> › 由于长期没有活动，本主题已不再开放新回复。如果您要发帖，请在上方搜索更新的主题或发布新问题。 {技术}{多线程}实施并行编程的五大障碍</p>
<p>此主题和其他讨论重复。   <a href=""></a>
系统将您从重复的主题重定向到这里。   <a href=""></a></p>
<p>24 名作者发布了 95 个帖子</p>
<p><img src="" alt="">
上一页 <a href="">上一页</a>  </p>
<p>第 <strong>1</strong> 页
  下一页 <a href="">下一页</a></p>
<p><img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问“什么是实施并行编程的最大障
碍”时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看
<a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/" target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/</a></a>
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是“专家”们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了“编译指导”、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说“在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶……你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的”，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：“你觉得并行编程容易么？”，十有八九会说“我觉得很难”。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点“教育”有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。
<a href="">显示删减掉的内容</a></p>
</li>
</ol>
<p><img src="" alt=""> 机械唯物主义 : linjunhalida <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>恩恩，有些事情还是没有并行的必要。等光处理器出来就好了。
2010/3/22 Guancheng Chen <a href="&#109;&#97;&#x69;&#108;&#x74;&#111;&#x3a;&#91;&#99;&#x68;&#x65;&#x6e;&#103;&#x75;&#x2e;&#x2e;&#x2e;&#64;&#103;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#109;&#93;&#40;&#41;">&#91;&#99;&#x68;&#x65;&#x6e;&#103;&#x75;&#x2e;&#x2e;&#x2e;&#64;&#103;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#109;&#93;&#40;&#41;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问“什么是实施并行编程的最大障
碍”时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。
( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看
<a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/" target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/</a></a>
)</p>
<ol>
<li>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</li>
<li>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是“专家”们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了“编译指导”、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。
可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说“在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶……你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的”，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：“你觉得并行编程容易么？”，十有八九会说“我觉得很难”。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</li>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？
(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx
总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点“教育”有很大关系了。</li>
<li>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</li>
<li>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> 陨落雕 <img src="" alt=""></li>
</ol>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>呃，我想的障碍是: 1. 类C语言的统治地位; 2. 内存带宽不够; 3. 误导性宣传;</p>
<p>On Mar 21, 7:37 pm, Guancheng Chen <a href="&#x6d;&#x61;&#105;&#x6c;&#x74;&#111;&#x3a;&#91;&#x63;&#x68;&#101;&#x6e;&#103;&#x75;&#97;&#x6e;&#x63;&#104;&#46;&#x2e;&#46;&#x40;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#46;&#x63;&#111;&#x6d;&#93;&#40;&#41;">&#91;&#x63;&#x68;&#101;&#x6e;&#103;&#x75;&#97;&#x6e;&#x63;&#104;&#46;&#x2e;&#46;&#x40;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#46;&#x63;&#111;&#x6d;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看<a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..</p>
<p>)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。</p>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<blockquote>
<p>尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。
<a href="">显示删减掉的内容</a></p>
</li>
</ol>
</blockquote>
<p><img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>可是按现在的趋势，多核一定会在光处理器之前成为主流啊</p>
<p>On 3月22日, 上午12时42分, 机械唯物主义 : linjunhalida <a href="&#109;&#97;&#105;&#x6c;&#116;&#x6f;&#x3a;&#x5b;&#x6c;&#x69;&#x6e;&#x6a;&#117;&#110;&#x68;&#x61;&#x6c;&#46;&#x2e;&#46;&#64;&#103;&#109;&#97;&#105;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#41;">&#x5b;&#x6c;&#x69;&#x6e;&#x6a;&#117;&#110;&#x68;&#x61;&#x6c;&#46;&#x2e;&#46;&#64;&#103;&#109;&#97;&#105;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#41;</a>
wrote:</p>
<blockquote>
<p>恩恩，有些事情还是没有并行的必要。等光处理器出来就好了。</p>
<p>2010/3/22 Guancheng Chen <a href="&#109;&#x61;&#105;&#x6c;&#x74;&#x6f;&#x3a;&#x5b;&#x63;&#x68;&#101;&#110;&#x67;&#x75;&#x61;&#x6e;&#99;&#104;&#46;&#x2e;&#46;&#64;&#x67;&#x6d;&#x61;&#105;&#108;&#x2e;&#99;&#x6f;&#109;&#93;&#x28;&#x29;">&#x5b;&#x63;&#x68;&#101;&#110;&#x67;&#x75;&#x61;&#x6e;&#99;&#104;&#46;&#x2e;&#46;&#64;&#x67;&#x6d;&#x61;&#105;&#108;&#x2e;&#99;&#x6f;&#109;&#93;&#x28;&#x29;</a></p>
</blockquote>
<p>&gt;
&gt;
&gt;</p>
<blockquote>
<blockquote>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问“什么是实施并行编程的最大障
碍”时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..</p>
</blockquote>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<blockquote>
<blockquote>
<p>)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是“专家”们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了“编译指导”、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说“在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶……你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的”，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：“你觉得并行编程容易么？”，十有八九会说“我觉得很难”。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点“教育”有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。</p>
</li>
</ol>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
</blockquote>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<ol>
<li>C语言可以使用pthread等库实现并行化，C++ JAVA等已经会即将支持多线程 所以语言能实现并行化 只是难易问题</li>
<li>是指Shared memory模型，多核共享一条内存总线所以造成带宽问题么？这确实是个问题，不过我感觉硬件商家会负责为你带来越来越多的带
宽，而程序员的任务只是合理的利用好这些给定的带宽</li>
<li>能具体说说哪些误导宣传么？</li>
</ol>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>On 3月22日, 上午1时46分, 陨落雕 <a href="&#x6d;&#x61;&#x69;&#108;&#x74;&#x6f;&#x3a;&#91;&#103;&#101;&#111;&#46;&#46;&#x2e;&#46;&#64;&#103;&#109;&#97;&#x69;&#x6c;&#46;&#x63;&#111;&#109;&#93;&#x28;&#41;">&#91;&#103;&#101;&#111;&#46;&#46;&#x2e;&#46;&#64;&#103;&#109;&#97;&#x69;&#x6c;&#46;&#x63;&#111;&#109;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>呃，我想的障碍是: 1. 类C语言的统治地位; 2. 内存带宽不够; 3. 误导性宣传;</p>
<p>On Mar 21, 7:37 pm, Guancheng Chen <a href="&#109;&#x61;&#x69;&#x6c;&#116;&#x6f;&#58;&#91;&#x63;&#104;&#101;&#x6e;&#103;&#117;&#x61;&#x6e;&#99;&#104;&#x2e;&#46;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#105;&#108;&#46;&#x63;&#x6f;&#109;&#93;&#40;&#41;">&#91;&#x63;&#104;&#101;&#x6e;&#103;&#117;&#x61;&#x6e;&#99;&#104;&#x2e;&#46;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#105;&#108;&#46;&#x63;&#x6f;&#109;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看<a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。
<a href="">显示删减掉的内容</a></p>
</li>
</ol>
</blockquote>
</blockquote>
<p><img src="" alt=""> Jeffrey Zhao <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是“抽象”这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上……我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog: <a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter: <a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p><strong>From:</strong> <a href="&quot;chenguancheng@gmail.com&quot;">Guancheng Chen</a></p>
<p><strong>Sent:</strong> Monday, March 22, 2010 7:37 AM
<strong>To:</strong> <a href="&quot;pongba@googlegroups.com&quot;">TopLanguage</a></p>
<p><strong>Subject:</strong> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问“什么是实施并行编程的最大障
碍”时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。
( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看
<a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/" target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/</a></a>
)</p>
<ol>
<li>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</li>
<li>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是“专家”们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了“编译指导”、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。
可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说“在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶……你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的”，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：“你觉得并行编程容易么？”，十有八九会说“我觉得很难”。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</li>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？
(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx
总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点“教育”有很大关系了。</li>
<li>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</li>
<li>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> tinyfool <img src="" alt=""></li>
</ol>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？
还有支持显卡计算的OpenCL也是无比强大啊。
2010/3/22 Jeffrey Zhao <a href="&#x6d;&#x61;&#x69;&#x6c;&#116;&#x6f;&#58;&#91;&#x6a;&#x65;&#x2e;&#46;&#46;&#x40;&#x6c;&#105;&#118;&#x65;&#x2e;&#x63;&#x6f;&#109;&#93;&#40;&#41;">&#91;&#x6a;&#x65;&#x2e;&#46;&#46;&#x40;&#x6c;&#105;&#118;&#x65;&#x2e;&#x63;&#x6f;&#109;&#93;&#40;&#41;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是“抽象”这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上……我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog: <a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter: <a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p><strong>From:</strong> <a href="&quot;chenguancheng@gmail.com&quot;">Guancheng Chen</a></p>
<p><strong>Sent:</strong> Monday, March 22, 2010 7:37 AM
<strong>To:</strong> <a href="&quot;pongba@googlegroups.com&quot;">TopLanguage</a></p>
<p><strong>Subject:</strong> [TL] {技术}{多线程}实施并行编程的五大障碍
近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问“什么是实施并行编程的最大障
碍”时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。
( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看
<a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/" target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/</a></a>
)</p>
<ol>
<li>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</li>
<li>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是“专家”们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了“编译指导”、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。
可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说“在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶……你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的”，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：“你觉得并行编程容易么？”，十有八九会说“我觉得很难”。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</li>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？
(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx
总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点“教育”有很大关系了。</li>
<li>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</li>
<li>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</li>
</ol>
<h2 id="to-unsubscribe-from-this-group-send-email-to-pongba-unsubscribegooglegroups-com-http-unsubscribegooglegroups-com-or-reply-to-this-email-with-the-words-remove-me-as-the-subject-">To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</h2>
<p>Tinyfool的开发日记 <a href="http://www.tinydust.net/dev/" target="_blank"><a href="http://www.tinydust.net/dev/">http://www.tinydust.net/dev/</a></a>
代码中国网 <a href="http://www.codechina.org/" target="_blank"><a href="http://www.codechina.org">http://www.codechina.org</a></a>
myTwitter: <a href="http://twitter.com/tinyfool" target="_blank"><a href="http://twitter.com/tinyfool">http://twitter.com/tinyfool</a></a>
<a href="">显示删减掉的内容</a></p>
<p><img src="" alt=""> 陨落雕 <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<ol>
<li>这和第二个问题是连起来的，到最后，你还是操作的mutable object，就是无穷无尽的memory consistency的麻烦；</li>
<li>就是这个问题，可惜从来都没跟上来过，光传输是一个可行性，如果实现了的确会改变现在的处境；</li>
<li>说在shared memory模型上内核数量可以无限上去的误导宣传，可惜这个20年前就失败，现在在TOP500上能看到的
supercomputer都是distributed memory model；</li>
</ol>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>On Mar 21, 8:58 pm, Guancheng Chen <a href="&#x6d;&#x61;&#105;&#108;&#x74;&#111;&#x3a;&#x5b;&#99;&#104;&#x65;&#110;&#103;&#x75;&#97;&#110;&#99;&#x68;&#x2e;&#46;&#x2e;&#64;&#x67;&#x6d;&#x61;&#105;&#x6c;&#46;&#99;&#x6f;&#x6d;&#x5d;&#40;&#x29;">&#x5b;&#99;&#104;&#x65;&#110;&#103;&#x75;&#97;&#110;&#99;&#x68;&#x2e;&#46;&#x2e;&#64;&#x67;&#x6d;&#x61;&#105;&#x6c;&#46;&#99;&#x6f;&#x6d;&#x5d;&#40;&#x29;</a> wrote:</p>
<blockquote>
<ol>
<li>C语言可以使用pthread等库实现并行化，C++ JAVA等已经会即将支持多线程 所以语言能实现并行化 只是难易问题</li>
<li>是指Shared memory模型，多核共享一条内存总线所以造成带宽问题么？这确实是个问题，不过我感觉硬件商家会负责为你带来越来越多的带
宽，而程序员的任务只是合理的利用好这些给定的带宽</li>
<li>能具体说说哪些误导宣传么？</li>
</ol>
<p>On 3月22日, 上午1时46分, 陨落雕 <a href="&#109;&#97;&#x69;&#x6c;&#116;&#x6f;&#58;&#91;&#103;&#x65;&#111;&#x2e;&#46;&#x2e;&#x2e;&#64;&#x67;&#109;&#97;&#105;&#x6c;&#46;&#x63;&#111;&#x6d;&#x5d;&#x28;&#x29;">&#91;&#103;&#x65;&#111;&#x2e;&#46;&#x2e;&#x2e;&#64;&#x67;&#109;&#97;&#105;&#x6c;&#46;&#x63;&#111;&#x6d;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>呃，我想的障碍是: 1. 类C语言的统治地位; 2. 内存带宽不够; 3. 误导性宣传;</p>
<p>On Mar 21, 7:37 pm, Guancheng Chen <a href="&#x6d;&#97;&#105;&#x6c;&#x74;&#x6f;&#58;&#x5b;&#x63;&#x68;&#x65;&#110;&#103;&#x75;&#97;&#110;&#99;&#x68;&#x2e;&#46;&#x2e;&#64;&#x67;&#109;&#97;&#x69;&#108;&#x2e;&#99;&#111;&#x6d;&#93;&#40;&#x29;">&#x5b;&#x63;&#x68;&#x65;&#110;&#103;&#x75;&#97;&#110;&#99;&#x68;&#x2e;&#46;&#x2e;&#64;&#x67;&#109;&#97;&#x69;&#108;&#x2e;&#99;&#111;&#x6d;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看<a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。
<a href="">显示删减掉的内容</a>
<img src="" alt=""> 陨落雕 <img src="" alt=""></p>
</li>
</ol>
</blockquote>
</blockquote>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>OpenCL解决了一大类的问题（每个kernel只需要一小部分数据，类似rasterization的渲染），而且现在他们有动力解决另一大类的问
题（每个小的kernel需要查询大量数据，类似ray tracer的渲染）。但是现在移植还是好困难啊，特别是显存和内存通信时候的
consolation，头疼死了，显存不够要swap out的时候，也很头疼。</p>
<p>On Mar 21, 9:20 pm, Tinyfool <a href="&#x6d;&#x61;&#105;&#x6c;&#116;&#x6f;&#x3a;&#91;&#x74;&#105;&#110;&#x79;&#102;&#46;&#x2e;&#46;&#x40;&#x67;&#x6d;&#97;&#x69;&#108;&#46;&#x63;&#x6f;&#x6d;&#93;&#x28;&#41;">&#91;&#x74;&#105;&#110;&#x79;&#102;&#46;&#x2e;&#46;&#x40;&#x67;&#x6d;&#97;&#x69;&#108;&#46;&#x63;&#x6f;&#x6d;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#109;&#x61;&#105;&#x6c;&#116;&#111;&#58;&#91;&#x6a;&#x65;&#46;&#x2e;&#x2e;&#64;&#108;&#105;&#x76;&#101;&#46;&#x63;&#111;&#x6d;&#x5d;&#x28;&#x29;">&#91;&#x6a;&#x65;&#46;&#x2e;&#x2e;&#64;&#108;&#105;&#x76;&#101;&#46;&#x63;&#111;&#x6d;&#x5d;&#x28;&#x29;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
</blockquote>
</blockquote>
<p>&gt;</p>
<blockquote>
<blockquote>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#109;&#x61;&#x69;&#108;&#116;&#111;&#x3a;&#91;&#99;&#104;&#x65;&#110;&#x67;&#x75;&#x61;&#x6e;&#99;&#104;&#46;&#x2e;&#46;&#64;&#x67;&#109;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#111;&#109;&#93;&#x28;&#x29;">&#91;&#99;&#104;&#x65;&#110;&#x67;&#x75;&#x61;&#x6e;&#99;&#104;&#46;&#x2e;&#46;&#64;&#x67;&#109;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#111;&#109;&#93;&#x28;&#x29;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#109;&#x61;&#x69;&#108;&#x74;&#x6f;&#x3a;&#91;&#x70;&#x6f;&#x6e;&#46;&#x2e;&#x2e;&#x40;&#x67;&#111;&#111;&#x67;&#x6c;&#x65;&#103;&#114;&#111;&#x75;&#112;&#115;&#46;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#41;">&#91;&#x70;&#x6f;&#x6e;&#46;&#x2e;&#x2e;&#x40;&#x67;&#111;&#111;&#x67;&#x6c;&#x65;&#103;&#114;&#111;&#x75;&#112;&#115;&#46;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#41;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
</blockquote>
</blockquote>
<p>&gt;</p>
<blockquote>
<blockquote>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..</p>
<p>)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。</p>
</blockquote>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<blockquote>
<blockquote>
<p>尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。</p>
</li>
</ol>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>--
Tinyfool的开发日记<a href="http://www.tinydust.net/dev/" target="_blank"><a href="http://www.tinydust.net/dev/">http://www.tinydust.net/dev/</a></a>
代码中国网<a href="http://www.codechina.org/" target="_blank"><a href="http://www.codechina.org">http://www.codechina.org</a></a>
myTwitter:<a href="http://twitter.com/tinyfool" target="_blank"><a href="http://twitter.com/tinyfool">http://twitter.com/tinyfool</a></a>
<a href="">显示删减掉的内容</a></p>
</blockquote>
<p><img src="" alt=""> Jeffrey Zhao <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>哈哈，广告好，扩展视野，那我继续做广告了……</p>
<p>微软其实很早就在搞Microsoft Accelerator项目，旨在利用DirectX进行计算，.NET项目。 <a href="http://research.microsoft.com/en-us/projects/Accelerator/" title="http://research.microsoft.com/en-us/projects/Accelerator/
CTRL + 单击以下链接"><a href="http://research.microsoft.com/en-us/projects/Accelerator/" target="_blank">http://research.microsoft.com/en-us/projects/Accelerator/</a></a></p>
<p>然后F/#这边由于语言的支持良好，可以设计出丰富的表达式、DSL等Modeling Language，再由框架进行自动并行，解决问题可以很容易（已经2.0了）。</p>
<p>这篇文章是个简单介绍：<a href="http://strangelights.com/blog/archive/2008/09/21/1628.aspx" target="_blank"><a href="http://strangelights.com/blog/archive/2008/09/21/1628.aspx">http://strangelights.com/blog/archive/2008/09/21/1628.aspx</a></a></p>
<p>Microsoft Solver Foundation <a href="http://code.msdn.microsoft.com/solverfoundation" target="_blank"><a href="http://code.msdn.microsoft.com/solverfoundation">http://code.msdn.microsoft.com/solverfoundation</a></a></p>
<p>F/# Optimization Modeling Language Utilizing Microsoft Solver Foundation <a href="http://code.msdn.microsoft.com/solverfoundationfs1" title="http://code.msdn.microsoft.com/solverfoundationfs1
CTRL + 单击以下链接"><a href="http://code.msdn.microsoft.com/solverfoundationfs1" target="_blank">http://code.msdn.microsoft.com/solverfoundationfs1</a></a></p>
<p>现在就等OpenCL如果有标准出来，肯定立马可以跟上个类库，哦耶。</p>
<p>Jeffrey Zhao
Blog: <a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter: <a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a>
<strong>From:</strong> <a href="&quot;tinyfool@gmail.com&quot;">Tinyfool</a></p>
<p><strong>Sent:</strong> Monday, March 22, 2010 9:20 AM
<strong>To:</strong> <a href="&quot;pongba@googlegroups.com&quot;">pon...@googlegroups.com</a></p>
<p><strong>Subject:</strong> Re: [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？
还有支持显卡计算的OpenCL也是无比强大啊。
2010/3/22 Jeffrey Zhao <a href="&#x6d;&#97;&#x69;&#108;&#116;&#x6f;&#58;&#x5b;&#x6a;&#x65;&#x2e;&#x2e;&#46;&#x40;&#x6c;&#x69;&#x76;&#101;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#x29;">&#x5b;&#x6a;&#x65;&#x2e;&#x2e;&#46;&#x40;&#x6c;&#x69;&#x76;&#101;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#x29;</a>
我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是“抽象”这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上……我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog: <a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter: <a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p><strong>From:</strong> <a href="&quot;chenguancheng@gmail.com&quot;">Guancheng Chen</a></p>
<p><strong>Sent:</strong> Monday, March 22, 2010 7:37 AM
<strong>To:</strong> <a href="&quot;pongba@googlegroups.com&quot;">TopLanguage</a></p>
<p><strong>Subject:</strong> [TL] {技术}{多线程}实施并行编程的五大障碍
近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问“什么是实施并行编程的最大障
碍”时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。
( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看
<a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/" target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/</a></a>
)</p>
<ol>
<li>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</li>
<li>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是“专家”们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了“编译指导”、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。
可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说“在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶……你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的”，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：“你觉得并行编程容易么？”，十有八九会说“我觉得很难”。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</li>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？
(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx
总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点“教育”有很大关系了。</li>
<li>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</li>
<li>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</li>
</ol>
<h2 id="to-unsubscribe-from-this-group-send-email-to-pongba-unsubscribegooglegroups-com-http-unsubscribegooglegroups-com-or-reply-to-this-email-with-the-words-remove-me-as-the-subject-">To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</h2>
<p>Tinyfool的开发日记 <a href="http://www.tinydust.net/dev/" target="_blank"><a href="http://www.tinydust.net/dev/">http://www.tinydust.net/dev/</a></a>
代码中国网 <a href="http://www.codechina.org/" target="_blank"><a href="http://www.codechina.org">http://www.codechina.org</a></a>
myTwitter: <a href="http://twitter.com/tinyfool" target="_blank"><a href="http://twitter.com/tinyfool">http://twitter.com/tinyfool</a></a></p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> tinyfool <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>OpenCL早就出来标准了，而且在做各个平台的实现…</p>
<p>视野啊…
2010/3/22 Jeffrey Zhao <a href="&#x6d;&#97;&#105;&#108;&#116;&#111;&#x3a;&#91;&#106;&#x65;&#46;&#x2e;&#46;&#64;&#x6c;&#105;&#x76;&#101;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#41;">&#91;&#106;&#x65;&#46;&#x2e;&#46;&#64;&#x6c;&#105;&#x76;&#101;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#41;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>哈哈，广告好，扩展视野，那我继续做广告了……</p>
<p>微软其实很早就在搞Microsoft Accelerator项目，旨在利用DirectX进行计算，.NET项目。 <a href="http://research.microsoft.com/en-us/projects/Accelerator/" title="http://research.microsoft.com/en-us/projects/Accelerator/
CTRL + 单击以下链接"><a href="http://research.microsoft.com/en-us/projects/Accelerator/" target="_blank">http://research.microsoft.com/en-us/projects/Accelerator/</a></a></p>
<p>然后F/#这边由于语言的支持良好，可以设计出丰富的表达式、DSL等Modeling Language，再由框架进行自动并行，解决问题可以很容易（已经2.0了）。</p>
<p>这篇文章是个简单介绍：<a href="http://strangelights.com/blog/archive/2008/09/21/1628.aspx" target="_blank"><a href="http://strangelights.com/blog/archive/2008/09/21/1628.aspx">http://strangelights.com/blog/archive/2008/09/21/1628.aspx</a></a></p>
<p>Microsoft Solver Foundation <a href="http://code.msdn.microsoft.com/solverfoundation" target="_blank"><a href="http://code.msdn.microsoft.com/solverfoundation">http://code.msdn.microsoft.com/solverfoundation</a></a></p>
<p>F/# Optimization Modeling Language Utilizing Microsoft Solver Foundation <a href="http://code.msdn.microsoft.com/solverfoundationfs1" title="http://code.msdn.microsoft.com/solverfoundationfs1
CTRL + 单击以下链接"><a href="http://code.msdn.microsoft.com/solverfoundationfs1" target="_blank">http://code.msdn.microsoft.com/solverfoundationfs1</a></a></p>
<p>现在就等OpenCL如果有标准出来，肯定立马可以跟上个类库，哦耶。</p>
<p>Jeffrey Zhao
Blog: <a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter: <a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a>
<strong>From:</strong> <a href="&quot;tinyfool@gmail.com&quot;">Tinyfool</a></p>
<p><strong>Sent:</strong> Monday, March 22, 2010 9:20 AM
<strong>To:</strong> <a href="&quot;pongba@googlegroups.com&quot;">pon...@googlegroups.com</a></p>
<p><strong>Subject:</strong> Re: [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？
还有支持显卡计算的OpenCL也是无比强大啊。
2010/3/22 Jeffrey Zhao <a href="&#x6d;&#97;&#105;&#x6c;&#x74;&#x6f;&#x3a;&#x5b;&#106;&#x65;&#46;&#46;&#46;&#64;&#108;&#x69;&#118;&#x65;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#40;&#41;">&#x5b;&#106;&#x65;&#46;&#46;&#46;&#64;&#108;&#x69;&#118;&#x65;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#40;&#41;</a>
我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是“抽象”这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上……我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog: <a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter: <a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p><strong>From:</strong> <a href="&quot;chenguancheng@gmail.com&quot;">Guancheng Chen</a></p>
<p><strong>Sent:</strong> Monday, March 22, 2010 7:37 AM
<strong>To:</strong> <a href="&quot;pongba@googlegroups.com&quot;">TopLanguage</a></p>
<p><strong>Subject:</strong> [TL] {技术}{多线程}实施并行编程的五大障碍
近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问“什么是实施并行编程的最大障
碍”时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。
( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看
<a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/" target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/</a></a>
)</p>
<ol>
<li>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</li>
<li>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是“专家”们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了“编译指导”、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。
可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说“在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶……你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的”，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：“你觉得并行编程容易么？”，十有八九会说“我觉得很难”。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</li>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？
(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx
总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点“教育”有很大关系了。</li>
<li>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</li>
<li>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</li>
</ol>
<h2 id="to-unsubscribe-from-this-group-send-email-to-pongba-unsubscribegooglegroups-com-http-unsubscribegooglegroups-com-or-reply-to-this-email-with-the-words-remove-me-as-the-subject-">To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</h2>
<p>Tinyfool的开发日记 <a href="http://www.tinydust.net/dev/" target="_blank"><a href="http://www.tinydust.net/dev/">http://www.tinydust.net/dev/</a></a>
代码中国网 <a href="http://www.codechina.org/" target="_blank"><a href="http://www.codechina.org">http://www.codechina.org</a></a>
myTwitter: <a href="http://twitter.com/tinyfool" target="_blank"><a href="http://twitter.com/tinyfool">http://twitter.com/tinyfool</a></a></p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>--
Tinyfool的开发日记 <a href="http://www.tinydust.net/dev/" target="_blank"><a href="http://www.tinydust.net/dev/">http://www.tinydust.net/dev/</a></a>
代码中国网 <a href="http://www.codechina.org/" target="_blank"><a href="http://www.codechina.org">http://www.codechina.org</a></a>
myTwitter: <a href="http://twitter.com/tinyfool" target="_blank"><a href="http://twitter.com/tinyfool">http://twitter.com/tinyfool</a></a>
<a href="">显示删减掉的内容</a></p>
<p><img src="" alt=""> woo <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>C的pthread太重量级了，我觉得golang的go要好很多，虽然只是试验阶段</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>On 17:58 Sun 21 Mar     , Guancheng Chen wrote:</p>
<blockquote>
<ol>
<li>C语言可以使用pthread等库实现并行化，C++ JAVA等已经会即将支持多线程 所以语言能实现并行化 只是难易问题</li>
<li>是指Shared memory模型，多核共享一条内存总线所以造成带宽问题么？这确实是个问题，不过我感觉硬件商家会负责为你带来越来越多的带
宽，而程序员的任务只是合理的利用好这些给定的带宽</li>
<li>能具体说说哪些误导宣传么？</li>
</ol>
<p>On 3月22日, 上午1时46分, 陨落雕 <a href="&#x6d;&#97;&#x69;&#108;&#x74;&#x6f;&#x3a;&#x5b;&#x67;&#x65;&#111;&#46;&#46;&#x2e;&#46;&#x40;&#103;&#x6d;&#97;&#105;&#x6c;&#x2e;&#99;&#111;&#109;&#x5d;&#x28;&#x29;">&#x5b;&#x67;&#x65;&#111;&#46;&#46;&#x2e;&#46;&#x40;&#103;&#x6d;&#97;&#105;&#x6c;&#x2e;&#99;&#111;&#109;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>呃，我想的障碍是: 1. 类C语言的统治地位; 2. 内存带宽不够; 3. 误导性宣传;</p>
<p>On Mar 21, 7:37 pm, Guancheng Chen <a href="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#111;&#x3a;&#x5b;&#x63;&#x68;&#101;&#110;&#x67;&#x75;&#x61;&#110;&#x63;&#104;&#x2e;&#x2e;&#x2e;&#64;&#103;&#109;&#97;&#x69;&#108;&#46;&#x63;&#111;&#x6d;&#93;&#x28;&#41;">&#x5b;&#x63;&#x68;&#101;&#110;&#x67;&#x75;&#x61;&#110;&#x63;&#104;&#x2e;&#x2e;&#x2e;&#64;&#103;&#109;&#97;&#x69;&#108;&#46;&#x63;&#111;&#x6d;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看<a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。</p>
</li>
</ol>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> 陨落雕 <img src="" alt=""></p>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>言多必失啊，coalescing是写显存时候的问题，单词也拼错了......</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>On Mar 21, 9:33 pm, 陨落雕 <a href="&#x6d;&#97;&#105;&#108;&#116;&#x6f;&#x3a;&#x5b;&#103;&#x65;&#111;&#46;&#x2e;&#46;&#x2e;&#x40;&#103;&#109;&#x61;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#109;&#93;&#x28;&#x29;">&#x5b;&#103;&#x65;&#111;&#46;&#x2e;&#46;&#x2e;&#x40;&#103;&#109;&#x61;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#109;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>OpenCL解决了一大类的问题（每个kernel只需要一小部分数据，类似rasterization的渲染），而且现在他们有动力解决另一大类的问
题（每个小的kernel需要查询大量数据，类似ray tracer的渲染）。但是现在移植还是好困难啊，特别是显存和内存通信时候的
consolation，头疼死了，显存不够要swap out的时候，也很头疼。</p>
<p>On Mar 21, 9:20 pm, Tinyfool <a href="&#109;&#97;&#x69;&#108;&#116;&#111;&#58;&#91;&#116;&#105;&#x6e;&#121;&#102;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#93;&#x28;&#x29;">&#91;&#116;&#105;&#x6e;&#121;&#102;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#109;&#x61;&#105;&#x6c;&#116;&#x6f;&#x3a;&#x5b;&#x6a;&#101;&#x2e;&#x2e;&#46;&#x40;&#108;&#x69;&#118;&#101;&#46;&#x63;&#111;&#x6d;&#93;&#x28;&#41;">&#x5b;&#x6a;&#101;&#x2e;&#x2e;&#46;&#x40;&#108;&#x69;&#118;&#101;&#46;&#x63;&#111;&#x6d;&#93;&#x28;&#41;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#109;&#97;&#x69;&#x6c;&#116;&#111;&#x3a;&#x5b;&#99;&#x68;&#x65;&#x6e;&#103;&#x75;&#97;&#x6e;&#99;&#x68;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#46;&#x63;&#x6f;&#109;&#x5d;&#x28;&#x29;">&#x5b;&#99;&#x68;&#x65;&#x6e;&#103;&#x75;&#97;&#x6e;&#99;&#x68;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#46;&#x63;&#x6f;&#109;&#x5d;&#x28;&#x29;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#x6d;&#97;&#x69;&#108;&#x74;&#x6f;&#58;&#91;&#x70;&#x6f;&#110;&#46;&#x2e;&#46;&#64;&#103;&#111;&#111;&#x67;&#108;&#101;&#x67;&#x72;&#111;&#117;&#112;&#115;&#x2e;&#99;&#x6f;&#109;&#93;&#40;&#41;">&#91;&#x70;&#x6f;&#110;&#46;&#x2e;&#46;&#64;&#103;&#111;&#111;&#x67;&#108;&#101;&#x67;&#x72;&#111;&#117;&#112;&#115;&#x2e;&#99;&#x6f;&#109;&#93;&#40;&#41;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。</p>
</li>
</ol>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>--
Tinyfool的开发日记<a href="http://www.tinydust.net/dev/" target="_blank"><a href="http://www.tinydust.net/dev/">http://www.tinydust.net/dev/</a></a></p>
</blockquote>
<p>...</p>
<p>read more &gt;&gt;
<a href="">显示删减掉的内容</a></p>
</blockquote>
<p><img src="" alt=""> Jeffrey Zhao <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>是嘛，我记得是提交了标准还在审核。</p>
<p>好吧，我去查了一下果然在08年12月1.0 Stable release了。</p>
<p>Jeffrey Zhao
Blog: <a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter: <a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a>
<strong>From:</strong> <a href="&quot;tinyfool@gmail.com&quot;">Tinyfool</a></p>
<p><strong>Sent:</strong> Monday, March 22, 2010 9:46 AM</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p><strong>To:</strong> <a href="&quot;pongba@googlegroups.com&quot;">pon...@googlegroups.com</a></p>
<p><strong>Subject:</strong> Re: [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>OpenCL早就出来标准了，而且在做各个平台的实现…</p>
<p>视野啊…
2010/3/22 Jeffrey Zhao <a href="&#109;&#97;&#105;&#x6c;&#116;&#111;&#58;&#x5b;&#x6a;&#x65;&#46;&#46;&#x2e;&#64;&#x6c;&#105;&#x76;&#101;&#46;&#99;&#111;&#x6d;&#93;&#x28;&#41;">&#x5b;&#x6a;&#x65;&#46;&#46;&#x2e;&#64;&#x6c;&#105;&#x76;&#101;&#46;&#99;&#111;&#x6d;&#93;&#x28;&#41;</a>
哈哈，广告好，扩展视野，那我继续做广告了……</p>
<p>微软其实很早就在搞Microsoft Accelerator项目，旨在利用DirectX进行计算，.NET项目。 <a href="http://research.microsoft.com/en-us/projects/Accelerator/" title="http://research.microsoft.com/en-us/projects/Accelerator/
CTRL + 单击以下链接"><a href="http://research.microsoft.com/en-us/projects/Accelerator/" target="_blank">http://research.microsoft.com/en-us/projects/Accelerator/</a></a></p>
<p>然后F/#这边由于语言的支持良好，可以设计出丰富的表达式、DSL等Modeling Language，再由框架进行自动并行，解决问题可以很容易（已经2.0了）。</p>
<p>这篇文章是个简单介绍：<a href="http://strangelights.com/blog/archive/2008/09/21/1628.aspx" title="http://strangelights.com/blog/archive/2008/09/21/1628.aspx
CTRL + 单击以下链接"><a href="http://strangelights.com/blog/archive/2008/09/21/1628.aspx" target="_blank">http://strangelights.com/blog/archive/2008/09/21/1628.aspx</a></a></p>
<p>Microsoft Solver Foundation <a href="http://code.msdn.microsoft.com/solverfoundation" title="http://code.msdn.microsoft.com/solverfoundation
CTRL + 单击以下链接"><a href="http://code.msdn.microsoft.com/solverfoundation" target="_blank">http://code.msdn.microsoft.com/solverfoundation</a></a></p>
<p>F/# Optimization Modeling Language Utilizing Microsoft Solver Foundation <a href="http://code.msdn.microsoft.com/solverfoundationfs1" title="http://code.msdn.microsoft.com/solverfoundationfs1
CTRL + 单击以下链接"><a href="http://code.msdn.microsoft.com/solverfoundationfs1" target="_blank">http://code.msdn.microsoft.com/solverfoundationfs1</a></a></p>
<p>现在就等OpenCL如果有标准出来，肯定立马可以跟上个类库，哦耶。</p>
<p>Jeffrey Zhao
Blog: <a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter: <a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a>
<strong>From:</strong> <a href="&quot;tinyfool@gmail.com&quot;">Tinyfool</a></p>
<p><strong>Sent:</strong> Monday, March 22, 2010 9:20 AM
<strong>To:</strong> <a href="&quot;pongba@googlegroups.com&quot;">pon...@googlegroups.com</a></p>
<p><strong>Subject:</strong> Re: [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？
还有支持显卡计算的OpenCL也是无比强大啊。
2010/3/22 Jeffrey Zhao <a href="&#x6d;&#x61;&#105;&#x6c;&#x74;&#x6f;&#x3a;&#91;&#106;&#x65;&#x2e;&#46;&#x2e;&#x40;&#x6c;&#105;&#118;&#101;&#x2e;&#99;&#111;&#109;&#93;&#40;&#41;">&#91;&#106;&#x65;&#x2e;&#46;&#x2e;&#x40;&#x6c;&#105;&#118;&#101;&#x2e;&#99;&#111;&#109;&#93;&#40;&#41;</a>
我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是“抽象”这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上……我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog: <a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter: <a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p><strong>From:</strong> <a href="&quot;chenguancheng@gmail.com&quot;">Guancheng Chen</a></p>
<p><strong>Sent:</strong> Monday, March 22, 2010 7:37 AM
<strong>To:</strong> <a href="&quot;pongba@googlegroups.com&quot;">TopLanguage</a></p>
<p><strong>Subject:</strong> [TL] {技术}{多线程}实施并行编程的五大障碍
近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问“什么是实施并行编程的最大障
碍”时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。
( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看
<a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/" target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/</a></a>
)</p>
<ol>
<li>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</li>
<li>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是“专家”们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了“编译指导”、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。
可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说“在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶……你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的”，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：“你觉得并行编程容易么？”，十有八九会说“我觉得很难”。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</li>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？
(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx
总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点“教育”有很大关系了。</li>
<li>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</li>
<li>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</li>
</ol>
<h2 id="to-unsubscribe-from-this-group-send-email-to-pongba-unsubscribegooglegroups-com-http-unsubscribegooglegroups-com-or-reply-to-this-email-with-the-words-remove-me-as-the-subject-">To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</h2>
<p>Tinyfool的开发日记 <a href="http://www.tinydust.net/dev/" target="_blank"><a href="http://www.tinydust.net/dev/">http://www.tinydust.net/dev/</a></a>
代码中国网 <a href="http://www.codechina.org/" target="_blank"><a href="http://www.codechina.org">http://www.codechina.org</a></a>
myTwitter: <a href="http://twitter.com/tinyfool" target="_blank"><a href="http://twitter.com/tinyfool">http://twitter.com/tinyfool</a></a></p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<h2 id="to-unsubscribe-from-this-group-send-email-to-pongba-unsubscribegooglegroups-com-http-unsubscribegooglegroups-com-or-reply-to-this-email-with-the-words-remove-me-as-the-subject-">To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</h2>
<p>Tinyfool的开发日记 <a href="http://www.tinydust.net/dev/" target="_blank"><a href="http://www.tinydust.net/dev/">http://www.tinydust.net/dev/</a></a>
代码中国网 <a href="http://www.codechina.org/" target="_blank"><a href="http://www.codechina.org">http://www.codechina.org</a></a>
myTwitter: <a href="http://twitter.com/tinyfool" target="_blank"><a href="http://twitter.com/tinyfool">http://twitter.com/tinyfool</a></a></p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> changsheng <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>个人觉得最大障碍在工具上.</p>
<p>并行学术上研究得不少, 主要在算法和模型上. 工程上的工具, 多是自串行程序来设计的, 弄得复杂不堪. 并行需要语言和库两级支持, Pthreads 和 MPI 仅从库上入手, 让程序员处理各种重复且复杂的分发, 并发锁等. OpenMP好一些, 可惜目前只支持线程并行.
用 ErLang 等将并行设计在语言里的来做并行会容易得多, 得易于面向消息传递的隔离模型, 程序稳定易写. 模型和语言的性能是一个问题, 主要的问题还在用的人和实际并行项目不多.</p>
<p>调试工具就更少了. 有少数商业化的工具.
当然, 我是将可维护性归结为语言工具太差.</p>
<pre><code>                                                 Changsheng Jiang
</code></pre><p>2010/3/22 Guancheng Chen <a href="&#x6d;&#97;&#x69;&#x6c;&#x74;&#x6f;&#58;&#91;&#99;&#x68;&#101;&#x6e;&#x67;&#x75;&#x2e;&#x2e;&#46;&#x40;&#103;&#109;&#97;&#x69;&#108;&#46;&#99;&#x6f;&#109;&#x5d;&#x28;&#41;">&#91;&#99;&#x68;&#101;&#x6e;&#x67;&#x75;&#x2e;&#x2e;&#46;&#x40;&#103;&#109;&#97;&#x69;&#108;&#46;&#99;&#x6f;&#109;&#x5d;&#x28;&#41;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问“什么是实施并行编程的最大障
碍”时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。
( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看
<a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/" target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/</a></a>
)</p>
<ol>
<li>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</li>
<li>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是“专家”们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了“编译指导”、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。
可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说“在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶……你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的”，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：“你觉得并行编程容易么？”，十有八九会说“我觉得很难”。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</li>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？
(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx
总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点“教育”有很大关系了。</li>
<li>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</li>
<li>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。</li>
</ol>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a></p>
<p><img src="" alt=""> Milo Yip <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>我在等NVidia的Fermi和Nexus，想試做全域照明。
但怕買了Fermi後，機器也只是用來做做翻譯……</p>
<p>在 2010年3月22日上午9:51，Jeffrey Zhao <a href="&#109;&#97;&#105;&#108;&#x74;&#111;&#x3a;&#x5b;&#106;&#101;&#46;&#x2e;&#x2e;&#x40;&#x6c;&#x69;&#118;&#x65;&#46;&#x63;&#x6f;&#109;&#93;&#x28;&#41;">&#x5b;&#106;&#101;&#46;&#x2e;&#x2e;&#x40;&#x6c;&#x69;&#118;&#x65;&#46;&#x63;&#x6f;&#109;&#93;&#x28;&#41;</a> 寫道：</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<blockquote>
<p>是嘛，我记得是提交了标准还在审核。</p>
<p>好吧，我去查了一下果然在08年12月1.0 Stable release了。</p>
<p>Jeffrey Zhao
Blog: <a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter: <a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a>
From: Tinyfool
Sent: Monday, March 22, 2010 9:46 AM
To: <a href="">pon...@googlegroups.com</a>
Subject: Re: [TL] {技术}{多线程}实施并行编程的五大障碍
OpenCL早就出来标准了，而且在做各个平台的实现…
视野啊…</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#x6d;&#x61;&#105;&#x6c;&#x74;&#111;&#x3a;&#91;&#x6a;&#101;&#x2e;&#46;&#x2e;&#64;&#108;&#x69;&#x76;&#x65;&#x2e;&#99;&#x6f;&#x6d;&#93;&#x28;&#x29;">&#91;&#x6a;&#101;&#x2e;&#46;&#x2e;&#64;&#108;&#x69;&#x76;&#x65;&#x2e;&#99;&#x6f;&#x6d;&#93;&#x28;&#x29;</a>
&gt;</p>
<blockquote>
<p>哈哈，广告好，扩展视野，那我继续做广告了……</p>
<p>微软其实很早就在搞Microsoft Accelerator项目，旨在利用DirectX进行计算，.NET项目。
<a href="http://research.microsoft.com/en-us/projects/Accelerator/" target="_blank"><a href="http://research.microsoft.com/en-us/projects/Accelerator/">http://research.microsoft.com/en-us/projects/Accelerator/</a></a></p>
<p>然后F/#这边由于语言的支持良好，可以设计出丰富的表达式、DSL等Modeling
Language，再由框架进行自动并行，解决问题可以很容易（已经2.0了）。</p>
<p>这篇文章是个简单介绍：<a href="http://strangelights.com/blog/archive/2008/09/21/1628.aspx" target="_blank"><a href="http://strangelights.com/blog/archive/2008/09/21/1628.aspx">http://strangelights.com/blog/archive/2008/09/21/1628.aspx</a></a></p>
<p>Microsoft Solver Foundation
<a href="http://code.msdn.microsoft.com/solverfoundation" target="_blank"><a href="http://code.msdn.microsoft.com/solverfoundation">http://code.msdn.microsoft.com/solverfoundation</a></a></p>
<p>F/# Optimization Modeling Language Utilizing Microsoft Solver Foundation
<a href="http://code.msdn.microsoft.com/solverfoundationfs1" target="_blank"><a href="http://code.msdn.microsoft.com/solverfoundationfs1">http://code.msdn.microsoft.com/solverfoundationfs1</a></a></p>
<p>现在就等OpenCL如果有标准出来，肯定立马可以跟上个类库，哦耶。</p>
<p>Jeffrey Zhao
Blog: <a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter: <a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a>
From: Tinyfool
Sent: Monday, March 22, 2010 9:20 AM
To: <a href="">pon...@googlegroups.com</a>
Subject: Re: [TL] {技术}{多线程}实施并行编程的五大障碍
唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下
Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？
还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#109;&#97;&#105;&#108;&#x74;&#111;&#58;&#x5b;&#106;&#x65;&#46;&#46;&#x2e;&#x40;&#108;&#105;&#118;&#x65;&#x2e;&#x63;&#x6f;&#109;&#93;&#x28;&#x29;">&#x5b;&#106;&#x65;&#46;&#46;&#x2e;&#x40;&#108;&#105;&#118;&#x65;&#x2e;&#x63;&#x6f;&#109;&#93;&#x28;&#x29;</a>
&gt;</p>
<blockquote>
<p>我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是“抽象”这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上……我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog: <a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter: <a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a>
From: Guancheng Chen
Sent: Monday, March 22, 2010 7:37 AM
To: TopLanguage
Subject: [TL] {技术}{多线程}实施并行编程的五大障碍
近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问“什么是实施并行编程的最大障
碍”时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/" target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/</a></a>
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是“专家”们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了“编译指导”、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说“在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶……你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的”，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：“你觉得并行编程容易么？”，十有八九会说“我觉得很难”。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点“教育”有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。</p>
</li>
</ol>
<p>To unsubscribe from this group, send email to
pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to
pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>--
Tinyfool的开发日记 <a href="http://www.tinydust.net/dev/" target="_blank"><a href="http://www.tinydust.net/dev/">http://www.tinydust.net/dev/</a></a>
代码中国网 <a href="http://www.codechina.org/" target="_blank"><a href="http://www.codechina.org">http://www.codechina.org</a></a>
myTwitter: <a href="http://twitter.com/tinyfool" target="_blank"><a href="http://twitter.com/tinyfool">http://twitter.com/tinyfool</a></a></p>
<p>To unsubscribe from this group, send email to
pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to
pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>--
Tinyfool的开发日记 <a href="http://www.tinydust.net/dev/" target="_blank"><a href="http://www.tinydust.net/dev/">http://www.tinydust.net/dev/</a></a>
代码中国网 <a href="http://www.codechina.org/" target="_blank"><a href="http://www.codechina.org">http://www.codechina.org</a></a>
myTwitter: <a href="http://twitter.com/tinyfool" target="_blank"><a href="http://twitter.com/tinyfool">http://twitter.com/tinyfool</a></a></p>
<p>To unsubscribe from this group, send email to
pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to
pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>--
Milo Yip</p>
<p>Twitter @miloyip
<a href="http://www.cnblogs.com/miloyip/" target="_blank"><a href="http://www.cnblogs.com/miloyip/">http://www.cnblogs.com/miloyip/</a></a>
<a href="http://miloyip.seezone.net/" target="_blank"><a href="http://miloyip.seezone.net/">http://miloyip.seezone.net/</a></a>
<a href="">显示删减掉的内容</a>
<img src="" alt=""> Milo Yip <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>應該是「全局照明」</p>
<p>在 2010年3月22日上午10:20，Milo Yip <a href="&#109;&#x61;&#x69;&#x6c;&#116;&#x6f;&#58;&#x5b;&#109;&#x69;&#x6c;&#x2e;&#46;&#46;&#x40;&#x67;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#99;&#111;&#x6d;&#x5d;&#x28;&#x29;">&#x5b;&#109;&#x69;&#x6c;&#x2e;&#46;&#46;&#x40;&#x67;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#99;&#111;&#x6d;&#x5d;&#x28;&#x29;</a> 寫道：</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<blockquote>
<p>我在等NVidia的Fermi和Nexus，想試做全域照明。
但怕買了Fermi後，機器也只是用來做做翻譯……</p>
<p>在 2010年3月22日上午9:51，Jeffrey Zhao <a href="&#x6d;&#x61;&#105;&#x6c;&#116;&#x6f;&#x3a;&#91;&#x6a;&#x65;&#x2e;&#x2e;&#46;&#64;&#108;&#105;&#118;&#x65;&#46;&#x63;&#x6f;&#x6d;&#93;&#40;&#x29;">&#91;&#x6a;&#x65;&#x2e;&#x2e;&#46;&#64;&#108;&#105;&#118;&#x65;&#46;&#x63;&#x6f;&#x6d;&#93;&#40;&#x29;</a> 寫道：</p>
<blockquote>
<p>是嘛，我记得是提交了标准还在审核。</p>
<p>好吧，我去查了一下果然在08年12月1.0 Stable release了。</p>
<p>Jeffrey Zhao
Blog: <a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter: <a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a>
From: Tinyfool
Sent: Monday, March 22, 2010 9:46 AM
To: <a href="">pon...@googlegroups.com</a>
Subject: Re: [TL] {技术}{多线程}实施并行编程的五大障碍
OpenCL早就出来标准了，而且在做各个平台的实现…
视野啊…</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#109;&#x61;&#x69;&#x6c;&#x74;&#x6f;&#x3a;&#91;&#x6a;&#x65;&#x2e;&#46;&#x2e;&#x40;&#108;&#105;&#x76;&#101;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#40;&#41;">&#91;&#x6a;&#x65;&#x2e;&#46;&#x2e;&#x40;&#108;&#105;&#x76;&#101;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#40;&#41;</a>
&gt;</p>
<blockquote>
<p>哈哈，广告好，扩展视野，那我继续做广告了……</p>
<p>微软其实很早就在搞Microsoft Accelerator项目，旨在利用DirectX进行计算，.NET项目。
<a href="http://research.microsoft.com/en-us/projects/Accelerator/" target="_blank"><a href="http://research.microsoft.com/en-us/projects/Accelerator/">http://research.microsoft.com/en-us/projects/Accelerator/</a></a></p>
<p>然后F/#这边由于语言的支持良好，可以设计出丰富的表达式、DSL等Modeling
Language，再由框架进行自动并行，解决问题可以很容易（已经2.0了）。</p>
<p>这篇文章是个简单介绍：<a href="http://strangelights.com/blog/archive/2008/09/21/1628.aspx" target="_blank"><a href="http://strangelights.com/blog/archive/2008/09/21/1628.aspx">http://strangelights.com/blog/archive/2008/09/21/1628.aspx</a></a></p>
<p>Microsoft Solver Foundation
<a href="http://code.msdn.microsoft.com/solverfoundation" target="_blank"><a href="http://code.msdn.microsoft.com/solverfoundation">http://code.msdn.microsoft.com/solverfoundation</a></a></p>
<p>F/# Optimization Modeling Language Utilizing Microsoft Solver Foundation
<a href="http://code.msdn.microsoft.com/solverfoundationfs1" target="_blank"><a href="http://code.msdn.microsoft.com/solverfoundationfs1">http://code.msdn.microsoft.com/solverfoundationfs1</a></a></p>
<p>现在就等OpenCL如果有标准出来，肯定立马可以跟上个类库，哦耶。</p>
<p>Jeffrey Zhao
Blog: <a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter: <a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a>
From: Tinyfool
Sent: Monday, March 22, 2010 9:20 AM
To: <a href="">pon...@googlegroups.com</a>
Subject: Re: [TL] {技术}{多线程}实施并行编程的五大障碍
唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下
Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？
还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#109;&#97;&#x69;&#x6c;&#116;&#111;&#x3a;&#x5b;&#106;&#101;&#46;&#46;&#46;&#x40;&#x6c;&#105;&#118;&#101;&#46;&#99;&#111;&#109;&#x5d;&#x28;&#x29;">&#x5b;&#106;&#101;&#46;&#46;&#46;&#x40;&#x6c;&#105;&#118;&#101;&#46;&#99;&#111;&#109;&#x5d;&#x28;&#x29;</a>
&gt;</p>
<blockquote>
<p>我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是“抽象”这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上……我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog: <a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter: <a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a>
From: Guancheng Chen
Sent: Monday, March 22, 2010 7:37 AM
To: TopLanguage
Subject: [TL] {技术}{多线程}实施并行编程的五大障碍
近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问“什么是实施并行编程的最大障
碍”时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/" target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/</a></a>
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是“专家”们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了“编译指导”、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说“在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶……你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的”，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：“你觉得并行编程容易么？”，十有八九会说“我觉得很难”。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点“教育”有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。</p>
</li>
</ol>
<p>To unsubscribe from this group, send email to
pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to
pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>--
Tinyfool的开发日记 <a href="http://www.tinydust.net/dev/" target="_blank"><a href="http://www.tinydust.net/dev/">http://www.tinydust.net/dev/</a></a>
代码中国网 <a href="http://www.codechina.org/" target="_blank"><a href="http://www.codechina.org">http://www.codechina.org</a></a>
myTwitter: <a href="http://twitter.com/tinyfool" target="_blank"><a href="http://twitter.com/tinyfool">http://twitter.com/tinyfool</a></a></p>
<p>To unsubscribe from this group, send email to
pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to
pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>--
Tinyfool的开发日记 <a href="http://www.tinydust.net/dev/" target="_blank"><a href="http://www.tinydust.net/dev/">http://www.tinydust.net/dev/</a></a>
代码中国网 <a href="http://www.codechina.org/" target="_blank"><a href="http://www.codechina.org">http://www.codechina.org</a></a>
myTwitter: <a href="http://twitter.com/tinyfool" target="_blank"><a href="http://twitter.com/tinyfool">http://twitter.com/tinyfool</a></a></p>
<p>To unsubscribe from this group, send email to
pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to
pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>--
Milo Yip</p>
<p>Twitter @miloyip
<a href="http://www.cnblogs.com/miloyip/" target="_blank"><a href="http://www.cnblogs.com/miloyip/">http://www.cnblogs.com/miloyip/</a></a>
<a href="http://miloyip.seezone.net/" target="_blank"><a href="http://miloyip.seezone.net/">http://miloyip.seezone.net/</a></a></p>
</blockquote>
<p>--
Milo Yip</p>
<p>Twitter @miloyip
<a href="http://www.cnblogs.com/miloyip/" target="_blank"><a href="http://www.cnblogs.com/miloyip/">http://www.cnblogs.com/miloyip/</a></a>
<a href="http://miloyip.seezone.net/" target="_blank"><a href="http://miloyip.seezone.net/">http://miloyip.seezone.net/</a></a>
<a href="">显示删减掉的内容</a></p>
<p><img src="" alt=""> archerzz <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>工具的确是个问题，没有好的工具，很难快速推广。
2010/3/22 Changsheng Jiang <a href="&#x6d;&#x61;&#105;&#x6c;&#116;&#x6f;&#x3a;&#x5b;&#106;&#105;&#x61;&#110;&#103;&#46;&#46;&#46;&#x40;&#103;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#93;&#40;&#41;">&#x5b;&#106;&#105;&#x61;&#110;&#103;&#46;&#46;&#46;&#x40;&#103;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#93;&#40;&#41;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>个人觉得最大障碍在工具上.</p>
<p>并行学术上研究得不少, 主要在算法和模型上. 工程上的工具, 多是自串行程序来设计的, 弄得复杂不堪. 并行需要语言和库两级支持, Pthreads 和 MPI 仅从库上入手, 让程序员处理各种重复且复杂的分发, 并发锁等. OpenMP好一些, 可惜目前只支持线程并行.
用 ErLang 等将并行设计在语言里的来做并行会容易得多, 得易于面向消息传递的隔离模型, 程序稳定易写. 模型和语言的性能是一个问题, 主要的问题还在用的人和实际并行项目不多.</p>
<p>调试工具就更少了. 有少数商业化的工具.
当然, 我是将可维护性归结为语言工具太差.</p>
<pre><code>                                                 Changsheng Jiang
</code></pre><p>2010/3/22 Guancheng Chen <a href="&#109;&#x61;&#105;&#x6c;&#x74;&#x6f;&#58;&#x5b;&#x63;&#104;&#x65;&#110;&#x67;&#117;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#97;&#105;&#108;&#46;&#99;&#111;&#109;&#x5d;&#40;&#x29;">&#x5b;&#x63;&#104;&#x65;&#110;&#x67;&#117;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#97;&#105;&#108;&#46;&#99;&#111;&#109;&#x5d;&#40;&#x29;</a></p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问“什么是实施并行编程的最大障
碍”时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。
( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看
<a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/" target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/</a></a>
)</p>
<ol>
<li>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</li>
<li>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是“专家”们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了“编译指导”、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。
可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说“在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶……你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的”，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：“你觉得并行编程容易么？”，十有八九会说“我觉得很难”。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</li>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？
(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx
总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点“教育”有很大关系了。</li>
<li>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</li>
<li>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> 陨落雕 <img src="" alt=""></li>
</ol>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>我也想用Fermi来解一个和ray tracer类似的问题，话说NV招了好多搞ray tracer和hpc的大牛。</p>
<p>On Mar 21, 10:20 pm, Milo Yip <a href="&#109;&#97;&#x69;&#108;&#116;&#111;&#58;&#91;&#109;&#105;&#x6c;&#111;&#46;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#97;&#x69;&#108;&#46;&#x63;&#x6f;&#x6d;&#93;&#x28;&#x29;">&#91;&#109;&#105;&#x6c;&#111;&#46;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#97;&#x69;&#108;&#46;&#x63;&#x6f;&#x6d;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>我在等NVidia的Fermi和Nexus，想試做全域照明。
但怕買了Fermi後，機器也只是用來做做翻譯......</p>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>在 2010年3月22日上午9:51，Jeffrey Zhao <a href="&#x6d;&#97;&#105;&#108;&#x74;&#x6f;&#x3a;&#91;&#106;&#x65;&#46;&#46;&#x2e;&#64;&#108;&#105;&#118;&#x65;&#46;&#99;&#111;&#x6d;&#x5d;&#40;&#x29;">&#91;&#106;&#x65;&#46;&#46;&#x2e;&#64;&#108;&#105;&#118;&#x65;&#46;&#99;&#111;&#x6d;&#x5d;&#40;&#x29;</a> 寫道：</p>
<blockquote>
<p>是嘛，我记得是提交了标准还在审核。</p>
<p>好吧，我去查了一下果然在08年12月1.0 Stable release了。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a>
From: Tinyfool
Sent: Monday, March 22, 2010 9:46 AM
To: <a href="">pon...@googlegroups.com</a>
Subject: Re: [TL] {技术}{多线程}实施并行编程的五大障碍
OpenCL早就出来标准了，而且在做各个平台的实现...
视野啊...</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#x6f;&#x3a;&#91;&#106;&#101;&#46;&#x2e;&#46;&#64;&#108;&#x69;&#x76;&#x65;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#40;&#41;">&#91;&#106;&#101;&#46;&#x2e;&#46;&#64;&#108;&#x69;&#x76;&#x65;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#40;&#41;</a></p>
<blockquote>
<p>哈哈，广告好，扩展视野，那我继续做广告了......</p>
</blockquote>
</blockquote>
</blockquote>
<p>&gt;</p>
<blockquote>
<blockquote>
<blockquote>
<p>微软其实很早就在搞Microsoft Accelerator项目，旨在利用DirectX进行计算，.NET项目。
<a href="http://research.microsoft.com/en-us/projects/Accelerator/" target="_blank"><a href="http://research.microsoft.com/en-us/projects/Accelerator/">http://research.microsoft.com/en-us/projects/Accelerator/</a></a></p>
<p>然后F/#这边由于语言的支持良好，可以设计出丰富的表达式、DSL等Modeling
Language，再由框架进行自动并行，解决问题可以很容易（已经2.0了）。</p>
<p>这篇文章是个简单介绍：<a href="http://strangelights.com/blog/archive/2008/09/21/1628.aspx" target="_blank"><a href="http://strangelights.com/blog/archive/2008/09/21/1628.aspx">http://strangelights.com/blog/archive/2008/09/21/1628.aspx</a></a></p>
<p>Microsoft Solver Foundation
<a href="http://code.msdn.microsoft.com/solverfoundation" target="_blank"><a href="http://code.msdn.microsoft.com/solverfoundation">http://code.msdn.microsoft.com/solverfoundation</a></a></p>
<p>F/# Optimization Modeling Language Utilizing Microsoft Solver Foundation
<a href="http://code.msdn.microsoft.com/solverfoundationfs1" target="_blank"><a href="http://code.msdn.microsoft.com/solverfoundationfs1">http://code.msdn.microsoft.com/solverfoundationfs1</a></a></p>
<p>现在就等OpenCL如果有标准出来，肯定立马可以跟上个类库，哦耶。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a>
From: Tinyfool
Sent: Monday, March 22, 2010 9:20 AM
To: <a href="">pon...@googlegroups.com</a>
Subject: Re: [TL] {技术}{多线程}实施并行编程的五大障碍
唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下
Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？
还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#109;&#97;&#x69;&#108;&#x74;&#111;&#x3a;&#91;&#x6a;&#101;&#x2e;&#x2e;&#x2e;&#64;&#108;&#105;&#x76;&#x65;&#x2e;&#99;&#111;&#x6d;&#93;&#x28;&#41;">&#91;&#x6a;&#101;&#x2e;&#x2e;&#x2e;&#64;&#108;&#105;&#x76;&#x65;&#x2e;&#99;&#111;&#x6d;&#93;&#x28;&#41;</a></p>
<blockquote>
<p>我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>&gt;</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a>
From: Guancheng Chen
Sent: Monday, March 22, 2010 7:37 AM
To: TopLanguage
Subject: [TL] {技术}{多线程}实施并行编程的五大障碍
近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..</p>
<p>)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。</p>
<p>尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这</li>
</ol>
</blockquote>
</blockquote>
</blockquote>
<p>...</p>
<p>read more &gt;&gt;
<a href="">显示删减掉的内容</a></p>
</blockquote>
<p><img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>微软好像已经推出了跟OpenCL类似的Direct Compute，也能搞GPU CPU混合计算</p>
<p>On 3月22日, 上午2时42分, &quot;Jeffrey Zhao&quot; <a href="&#x6d;&#x61;&#x69;&#x6c;&#116;&#111;&#58;&#91;&#x6a;&#101;&#x2e;&#46;&#46;&#x40;&#108;&#105;&#118;&#x65;&#x2e;&#x63;&#111;&#109;&#93;&#x28;&#41;">&#91;&#x6a;&#101;&#x2e;&#46;&#46;&#x40;&#108;&#105;&#118;&#x65;&#x2e;&#x63;&#111;&#109;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>哈哈，广告好，扩展视野，那我继续做广告了......</p>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>微软其实很早就在搞Microsoft Accelerator项目，旨在利用DirectX进行计算，.NET项目。<a href="http://research.microsoft.com/en-us/projects/Accelerator/" target="_blank"><a href="http://research.microsoft.com/en-us/projects/Accelerator/">http://research.microsoft.com/en-us/projects/Accelerator/</a></a></p>
<p>然后F/#这边由于语言的支持良好，可以设计出丰富的表达式、DSL等Modeling Language，再由框架进行自动并行，解决问题可以很容易（已经2.0了）。</p>
<p>这篇文章是个简单介绍：<a href="http://strangelights.com/blog/archive/2008/09/21/1628.aspx" target="_blank"><a href="http://strangelights.com/blog/archive/2008/09/21/1628.aspx">http://strangelights.com/blog/archive/2008/09/21/1628.aspx</a></a></p>
<p>Microsoft Solver Foundation<a href="http://[code.msdn.microsoft.com/solverfoundation](http://code.msdn.microsoft.com/solverfoundation" target="_blank">http://[code.msdn.microsoft.com/solverfoundation](http://code.msdn.microsoft.com/solverfoundation</a>)</p>
<p>F/# Optimization Modeling Language Utilizing Microsoft Solver Foundation<a href="http://[code.msdn.microsoft.com/solverfoundationfs1](http://code.msdn.microsoft.com/solverfoundationfs1" target="_blank">http://[code.msdn.microsoft.com/solverfoundationfs1](http://code.msdn.microsoft.com/solverfoundationfs1</a>)</p>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>现在就等OpenCL如果有标准出来，肯定立马可以跟上个类库，哦耶。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p>From: Tinyfool
Sent: Monday, March 22, 2010 9:20 AM
To: <a href="">pon...@googlegroups.com</a>
Subject: Re: [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#109;&#97;&#105;&#x6c;&#x74;&#111;&#58;&#x5b;&#106;&#101;&#x2e;&#x2e;&#46;&#64;&#108;&#105;&#x76;&#x65;&#46;&#x63;&#111;&#109;&#x5d;&#x28;&#41;">&#x5b;&#106;&#101;&#x2e;&#x2e;&#46;&#64;&#108;&#105;&#x76;&#x65;&#46;&#x63;&#111;&#109;&#x5d;&#x28;&#41;</a></p>
<p>  我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>  其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>  例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>  至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>  例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>  Jeffrey Zhao
  Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
  Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p>  From: Guancheng Chen
  Sent: Monday, March 22, 2010 7:37 AM
  To: TopLanguage
  Subject: [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>  近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
  碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
  (fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
  Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
  的看法。</p>
<p>  ( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看
 <a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..</p>
<p>  )</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。</p>
<p>尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
</li>
<li><p>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</p>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
</li>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可...</p>
</li>
</ol>
<p>阅读更多 &gt;&gt;
<a href="">显示删减掉的内容</a>
<img src="" alt=""> 郑伟 <img src="" alt=""></p>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>我觉得 想要并行开发 必须绕开c/c++
2010/3/22 Guancheng Chen <a href="&#x6d;&#x61;&#x69;&#108;&#x74;&#x6f;&#x3a;&#91;&#99;&#104;&#101;&#x6e;&#x67;&#x75;&#46;&#x2e;&#x2e;&#64;&#103;&#x6d;&#97;&#x69;&#108;&#x2e;&#99;&#x6f;&#109;&#93;&#40;&#41;">&#91;&#99;&#104;&#101;&#x6e;&#x67;&#x75;&#46;&#x2e;&#x2e;&#64;&#103;&#x6d;&#97;&#x69;&#108;&#x2e;&#99;&#x6f;&#109;&#93;&#40;&#41;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>微软好像已经推出了跟OpenCL类似的Direct Compute，也能搞GPU CPU混合计算
On 3月22日, 上午2时42分, &quot;Jeffrey Zhao&quot; <a href="&#x6d;&#x61;&#105;&#108;&#x74;&#x6f;&#58;&#91;&#106;&#101;&#46;&#46;&#46;&#64;&#108;&#105;&#x76;&#101;&#x2e;&#x63;&#111;&#x6d;&#93;&#x28;&#x29;">&#91;&#106;&#101;&#46;&#46;&#46;&#64;&#108;&#105;&#x76;&#101;&#x2e;&#x63;&#111;&#x6d;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>哈哈，广告好，扩展视野，那我继续做广告了......</p>
<p>微软其实很早就在搞Microsoft Accelerator项目，旨在利用DirectX进行计算，.NET项目。<a href="http://research.microsoft.com/en-us/projects/Accelerator/" target="_blank"><a href="http://research.microsoft.com/en-us/projects/Accelerator/">http://research.microsoft.com/en-us/projects/Accelerator/</a></a></p>
<p>然后F/#这边由于语言的支持良好，可以设计出丰富的表达式、DSL等Modeling Language，再由框架进行自动并行，解决问题可以很容易（已经2.0了）。</p>
<p>这篇文章是个简单介绍：<a href="http://strangelights.com/blog/archive/2008/09/21/1628.aspx" target="_blank"><a href="http://strangelights.com/blog/archive/2008/09/21/1628.aspx">http://strangelights.com/blog/archive/2008/09/21/1628.aspx</a></a></p>
<p>Microsoft Solver Foundation<a href="http://[code.msdn.microsoft.com/solverfoundation](http://code.msdn.microsoft.com/solverfoundation" target="_blank">http://[code.msdn.microsoft.com/solverfoundation](http://code.msdn.microsoft.com/solverfoundation</a>)</p>
<p>F/# Optimization Modeling Language Utilizing Microsoft Solver Foundation<a href="http://[code.msdn.microsoft.com/solverfoundationfs1](http://code.msdn.microsoft.com/solverfoundationfs1" target="_blank">http://[code.msdn.microsoft.com/solverfoundationfs1](http://code.msdn.microsoft.com/solverfoundationfs1</a>)</p>
<p>现在就等OpenCL如果有标准出来，肯定立马可以跟上个类库，哦耶。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p>From: Tinyfool
Sent: Monday, March 22, 2010 9:20 AM
To: <a href="">pon...@googlegroups.com</a>
Subject: Re: [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#109;&#97;&#105;&#x6c;&#x74;&#x6f;&#58;&#x5b;&#x6a;&#101;&#x2e;&#x2e;&#46;&#64;&#x6c;&#x69;&#118;&#x65;&#x2e;&#99;&#111;&#109;&#x5d;&#x28;&#x29;">&#x5b;&#x6a;&#101;&#x2e;&#x2e;&#46;&#64;&#x6c;&#x69;&#118;&#x65;&#x2e;&#99;&#111;&#109;&#x5d;&#x28;&#x29;</a></p>
<p>  我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>  其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>  例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>  至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>  例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>  Jeffrey Zhao
  Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
  Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p>  From: Guancheng Chen
  Sent: Monday, March 22, 2010 7:37 AM
  To: TopLanguage
  Subject: [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>  近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
  碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
  (fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
  Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
  的看法。</p>
<p>  ( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看
 <a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
  )</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
</li>
<li><p>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</p>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
</li>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维&gt;   护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可...</p>
</li>
</ol>
<p>阅读更多 &gt;&gt;</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a></p>
<p><img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>很有意思的事情是我上次问过一个负责定制OpenCL的哥们，&quot;从商业角度上讲，苹果为什么要自己搞一个新标准？&quot; 他就说那个时候苹果意识到未来这种
通用并行计算平台的重要性，而为了保证最大的商业利益就选择自己重新搞一个新标准而不是跟当时已有CUDA的Nvidia合作，结果现在NV也开始支持
OpenCL，但是他们最新的一本教材里说到&quot;根据我们的经验，学习OpenCL最好的办法是先学CUDA&quot;</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>On 3月22日, 上午6时10分, 陨落雕 <a href="&#x6d;&#x61;&#105;&#108;&#116;&#x6f;&#58;&#91;&#x67;&#101;&#x6f;&#x2e;&#46;&#46;&#46;&#64;&#103;&#109;&#97;&#x69;&#x6c;&#46;&#x63;&#x6f;&#109;&#x5d;&#40;&#x29;">&#91;&#x67;&#101;&#x6f;&#x2e;&#46;&#46;&#46;&#64;&#103;&#109;&#97;&#x69;&#x6c;&#46;&#x63;&#x6f;&#109;&#x5d;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>我也想用Fermi来解一个和ray tracer类似的问题，话说NV招了好多搞ray tracer和hpc的大牛。</p>
<p>On Mar 21, 10:20 pm, Milo Yip <a href="&#109;&#97;&#105;&#x6c;&#x74;&#111;&#58;&#91;&#109;&#105;&#x6c;&#111;&#46;&#46;&#46;&#x40;&#x67;&#109;&#x61;&#x69;&#108;&#x2e;&#x63;&#111;&#109;&#93;&#40;&#41;">&#91;&#109;&#105;&#x6c;&#111;&#46;&#46;&#46;&#x40;&#x67;&#109;&#x61;&#x69;&#108;&#x2e;&#x63;&#111;&#109;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>我在等NVidia的Fermi和Nexus，想試做全域照明。
但怕買了Fermi後，機器也只是用來做做翻譯......</p>
<p>在 2010年3月22日上午9:51，Jeffrey Zhao <a href="&#109;&#97;&#105;&#x6c;&#x74;&#x6f;&#x3a;&#x5b;&#106;&#x65;&#x2e;&#46;&#46;&#64;&#108;&#x69;&#118;&#x65;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#x29;">&#x5b;&#106;&#x65;&#x2e;&#46;&#46;&#64;&#108;&#x69;&#118;&#x65;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#x29;</a> 寫道：</p>
<blockquote>
<p>是嘛，我记得是提交了标准还在审核。</p>
<p>好吧，我去查了一下果然在08年12月1.0 Stable release了。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a>
From: Tinyfool
Sent: Monday, March 22, 2010 9:46 AM
To: <a href="">pon...@googlegroups.com</a>
Subject: Re: [TL] {技术}{多线程}实施并行编程的五大障碍
OpenCL早就出来标准了，而且在做各个平台的实现...
视野啊...</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#109;&#97;&#105;&#108;&#x74;&#111;&#x3a;&#x5b;&#x6a;&#101;&#x2e;&#x2e;&#46;&#x40;&#x6c;&#105;&#118;&#x65;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#40;&#41;">&#x5b;&#x6a;&#101;&#x2e;&#x2e;&#46;&#x40;&#x6c;&#105;&#118;&#x65;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#40;&#41;</a></p>
<blockquote>
<p>哈哈，广告好，扩展视野，那我继续做广告了......</p>
<p>微软其实很早就在搞Microsoft Accelerator项目，旨在利用DirectX进行计算，.NET项目。
<a href="http://research.microsoft.com/en-us/projects/Accelerator/" target="_blank"><a href="http://research.microsoft.com/en-us/projects/Accelerator/">http://research.microsoft.com/en-us/projects/Accelerator/</a></a></p>
<p>然后F/#这边由于语言的支持良好，可以设计出丰富的表达式、DSL等Modeling
Language，再由框架进行自动并行，解决问题可以很容易（已经2.0了）。</p>
<p>这篇文章是个简单介绍：<a href="http://strangelights.com/blog/archive/2008/09/21/1628.aspx" target="_blank"><a href="http://strangelights.com/blog/archive/2008/09/21/1628.aspx">http://strangelights.com/blog/archive/2008/09/21/1628.aspx</a></a></p>
<p>Microsoft Solver Foundation
<a href="http://code.msdn.microsoft.com/solverfoundation" target="_blank"><a href="http://code.msdn.microsoft.com/solverfoundation">http://code.msdn.microsoft.com/solverfoundation</a></a></p>
<p>F/# Optimization Modeling Language Utilizing Microsoft Solver Foundation
<a href="http://code.msdn.microsoft.com/solverfoundationfs1" target="_blank"><a href="http://code.msdn.microsoft.com/solverfoundationfs1">http://code.msdn.microsoft.com/solverfoundationfs1</a></a></p>
<p>现在就等OpenCL如果有标准出来，肯定立马可以跟上个类库，哦耶。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a>
From: Tinyfool
Sent: Monday, March 22, 2010 9:20 AM
To: <a href="">pon...@googlegroups.com</a>
Subject: Re: [TL] {技术}{多线程}实施并行编程的五大障碍
唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下
Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？
还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#109;&#x61;&#105;&#x6c;&#x74;&#x6f;&#58;&#91;&#x6a;&#101;&#46;&#46;&#46;&#x40;&#x6c;&#105;&#x76;&#101;&#46;&#99;&#111;&#109;&#93;&#40;&#41;">&#91;&#x6a;&#101;&#46;&#46;&#46;&#x40;&#x6c;&#105;&#x76;&#101;&#46;&#99;&#111;&#109;&#93;&#40;&#41;</a></p>
<blockquote>
<p>我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a>
From: Guancheng Chen
Sent: Monday, March 22, 2010 7:37 AM
To: TopLanguage
Subject: [TL] {技术}{多线程}实施并行编程的五大障碍
近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li>对众核的恐惧...</li>
</ol>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>阅读更多 &gt;&gt;
<a href="">显示删减掉的内容</a>
<img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>不知道您觉得现有的工具哪些个最趁手呢？</p>
<p>On 3月22日, 上午3时19分, Changsheng Jiang <a href="&#x6d;&#97;&#105;&#108;&#116;&#111;&#x3a;&#91;&#x6a;&#105;&#97;&#x6e;&#103;&#x7a;&#117;&#x6f;&#x2e;&#46;&#46;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#x6d;&#x5d;&#40;&#41;">&#91;&#x6a;&#105;&#97;&#x6e;&#103;&#x7a;&#117;&#x6f;&#x2e;&#46;&#46;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#x6d;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>个人觉得最大障碍在工具上.</p>
<p>并行学术上研究得不少, 主要在算法和模型上. 工程上的工具, 多是自串行程序来设计的, 弄得复杂不堪. 并行需要语言和库两级支持, Pthreads 和
MPI 仅从库上入手, 让程序员处理各种重复且复杂的分发, 并发锁等. OpenMP好一些, 可惜目前只支持线程并行.</p>
<p>用 ErLang 等将并行设计在语言里的来做并行会容易得多, 得易于面向消息传递的隔离模型, 程序稳定易写. 模型和语言的性能是一个问题,
主要的问题还在用的人和实际并行项目不多.</p>
<p>调试工具就更少了. 有少数商业化的工具.</p>
<p>当然, 我是将可维护性归结为语言工具太差.</p>
<pre><code>                                                 Changsheng Jiang
</code></pre><p>2010/3/22 Guancheng Chen <a href="&#x6d;&#x61;&#x69;&#108;&#x74;&#111;&#x3a;&#91;&#x63;&#104;&#x65;&#x6e;&#x67;&#x75;&#97;&#110;&#99;&#104;&#x2e;&#46;&#x2e;&#64;&#103;&#109;&#x61;&#x69;&#108;&#46;&#x63;&#111;&#109;&#93;&#x28;&#x29;">&#91;&#x63;&#104;&#x65;&#x6e;&#x67;&#x75;&#97;&#110;&#99;&#104;&#x2e;&#46;&#x2e;&#64;&#103;&#109;&#x61;&#x69;&#108;&#46;&#x63;&#111;&#109;&#93;&#x28;&#x29;</a></p>
</blockquote>
<p>&gt;
&gt;
&gt;</p>
<blockquote>
<blockquote>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..</p>
<p>)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。</p>
</blockquote>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<blockquote>
<blockquote>
<p>尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。</p>
</li>
</ol>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
<a href="">显示删减掉的内容</a></p>
</blockquote>
</blockquote>
<p><img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>哈哈 是想绕开C++那些本来就复杂的要死的feature么？是不是如果有一门新的易用的编程语言会比诸如给C++添加thread特性的方法要
好？</p>
<p>On 3月22日, 上午6时48分, Kula <a href="&#109;&#x61;&#x69;&#108;&#x74;&#x6f;&#x3a;&#x5b;&#107;&#117;&#x6c;&#x61;&#115;&#46;&#x2e;&#x2e;&#64;&#103;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#x63;&#111;&#109;&#93;&#40;&#x29;">&#x5b;&#107;&#117;&#x6c;&#x61;&#115;&#46;&#x2e;&#x2e;&#64;&#103;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#x63;&#111;&#109;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>我觉得 想要并行开发 必须绕开c/c++</p>
<p>2010/3/22 Guancheng Chen <a href="&#109;&#x61;&#x69;&#108;&#x74;&#x6f;&#x3a;&#x5b;&#x63;&#x68;&#101;&#x6e;&#103;&#x75;&#x61;&#x6e;&#99;&#x68;&#46;&#46;&#x2e;&#64;&#103;&#109;&#x61;&#105;&#x6c;&#x2e;&#99;&#111;&#109;&#x5d;&#40;&#x29;">&#x5b;&#x63;&#x68;&#101;&#x6e;&#103;&#x75;&#x61;&#x6e;&#99;&#x68;&#46;&#46;&#x2e;&#64;&#103;&#109;&#x61;&#105;&#x6c;&#x2e;&#99;&#111;&#109;&#x5d;&#40;&#x29;</a></p>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>&gt;
&gt;
&gt;</p>
<blockquote>
<blockquote>
<p>微软好像已经推出了跟OpenCL类似的Direct Compute，也能搞GPU CPU混合计算</p>
<p>On 3月22日, 上午2时42分, &quot;Jeffrey Zhao&quot; <a href="&#x6d;&#97;&#x69;&#x6c;&#116;&#x6f;&#x3a;&#91;&#x6a;&#101;&#x2e;&#x2e;&#x2e;&#x40;&#108;&#105;&#118;&#x65;&#46;&#x63;&#x6f;&#109;&#x5d;&#40;&#x29;">&#91;&#x6a;&#101;&#x2e;&#x2e;&#x2e;&#x40;&#108;&#105;&#118;&#x65;&#46;&#x63;&#x6f;&#109;&#x5d;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>哈哈，广告好，扩展视野，那我继续做广告了......</p>
<p>微软其实很早就在搞Microsoft Accelerator项目，旨在利用DirectX进行计算，.NET项目。
<a href="http://research.microsoft.com/en-us/projects/Accelerator/" target="_blank"><a href="http://research.microsoft.com/en-us/projects/Accelerator/">http://research.microsoft.com/en-us/projects/Accelerator/</a></a></p>
<p>然后F/#这边由于语言的支持良好，可以设计出丰富的表达式、DSL等Modeling
Language，再由框架进行自动并行，解决问题可以很容易（已经2.0了）。</p>
<p>这篇文章是个简单介绍：<a href="http://strangelights.com/blog/archive/2008/09/21/1628.aspx" target="_blank"><a href="http://strangelights.com/blog/archive/2008/09/21/1628.aspx">http://strangelights.com/blog/archive/2008/09/21/1628.aspx</a></a></p>
<p>Microsoft Solver Foundationhttp://
<a href="http://code.msdn.microsoft.com/solverfoundation" target="_blank">code.msdn.microsoft.com/solverfoundation</a></p>
<p>F/# Optimization Modeling Language Utilizing Microsoft Solver
Foundation<a href="http://[code.msdn.microsoft.com/solverfoundationfs1](http://code.msdn.microsoft.com/solverfoundationfs1" target="_blank">http://[code.msdn.microsoft.com/solverfoundationfs1](http://code.msdn.microsoft.com/solverfoundationfs1</a>)</p>
<p>现在就等OpenCL如果有标准出来，肯定立马可以跟上个类库，哦耶。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p>From: Tinyfool
Sent: Monday, March 22, 2010 9:20 AM
To: <a href="">pon...@googlegroups.com</a>
Subject: Re: [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#x6d;&#x61;&#105;&#x6c;&#116;&#111;&#x3a;&#x5b;&#106;&#x65;&#x2e;&#46;&#46;&#64;&#108;&#105;&#x76;&#101;&#x2e;&#x63;&#111;&#109;&#x5d;&#x28;&#41;">&#x5b;&#106;&#x65;&#x2e;&#46;&#46;&#64;&#108;&#105;&#x76;&#101;&#x2e;&#x63;&#111;&#109;&#x5d;&#x28;&#41;</a></p>
<p>  我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>  其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>  例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>  至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>  例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>  Jeffrey Zhao
  Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
  Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p>  From: Guancheng Chen
  Sent: Monday, March 22, 2010 7:37 AM
  To: TopLanguage
  Subject: [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>  近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
  碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
  (fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
  Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
  的看法。</p>
<p>  ( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看
 <a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-" target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a></a>.
..
  )</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线</p>
</li>
</ol>
</blockquote>
<p>程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。</p>
<blockquote>
<p>  尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
  并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
  好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
  和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
  OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
  训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li><p>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</p>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
</li>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false...</p>
</li>
</ol>
</blockquote>
</blockquote>
<p>阅读更多 &gt;&gt;
<a href="">显示删减掉的内容</a>
<img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>On 3月22日, 上午2时20分, Tinyfool <a href="&#x6d;&#x61;&#105;&#108;&#116;&#x6f;&#x3a;&#x5b;&#116;&#105;&#110;&#121;&#x66;&#46;&#x2e;&#x2e;&#64;&#103;&#109;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#x28;&#41;">&#x5b;&#116;&#105;&#110;&#121;&#x66;&#46;&#x2e;&#x2e;&#64;&#103;&#109;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#x6d;&#x61;&#x69;&#x6c;&#116;&#x6f;&#x3a;&#91;&#106;&#101;&#46;&#46;&#x2e;&#x40;&#108;&#105;&#118;&#x65;&#x2e;&#99;&#111;&#x6d;&#93;&#x28;&#41;">&#91;&#106;&#101;&#46;&#46;&#x2e;&#x40;&#108;&#105;&#118;&#x65;&#x2e;&#99;&#111;&#x6d;&#93;&#x28;&#41;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
</blockquote>
</blockquote>
<p>&gt;</p>
<blockquote>
<blockquote>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#x6d;&#97;&#x69;&#108;&#x74;&#x6f;&#x3a;&#91;&#x63;&#104;&#101;&#x6e;&#x67;&#117;&#97;&#110;&#x63;&#104;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#109;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#111;&#109;&#x5d;&#40;&#41;">&#91;&#x63;&#104;&#101;&#x6e;&#x67;&#117;&#97;&#110;&#x63;&#104;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#109;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#111;&#109;&#x5d;&#40;&#41;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#x6d;&#97;&#x69;&#108;&#116;&#111;&#58;&#91;&#x70;&#x6f;&#110;&#x2e;&#46;&#x2e;&#64;&#x67;&#x6f;&#x6f;&#103;&#108;&#x65;&#x67;&#x72;&#111;&#117;&#x70;&#115;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#41;">&#91;&#x70;&#x6f;&#110;&#x2e;&#46;&#x2e;&#64;&#x67;&#x6f;&#x6f;&#103;&#108;&#x65;&#x67;&#x72;&#111;&#117;&#x70;&#115;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#41;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
</blockquote>
</blockquote>
<p>&gt;</p>
<blockquote>
<blockquote>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..</p>
<p>)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。</p>
</blockquote>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<blockquote>
<blockquote>
<p>尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。</p>
</li>
</ol>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>--
Tinyfool的开发日记<a href="http://www.tinydust.net/dev/" target="_blank"><a href="http://www.tinydust.net/dev/">http://www.tinydust.net/dev/</a></a>
代码中国网<a href="http://www.codechina.org/" target="_blank"><a href="http://www.codechina.org">http://www.codechina.org</a></a>
myTwitter:<a href="http://twitter.com/tinyfool" target="_blank"><a href="http://twitter.com/tinyfool">http://twitter.com/tinyfool</a></a>
<a href="">显示删减掉的内容</a></p>
</blockquote>
<p><img src="" alt=""> changsheng <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>说来惭愧, 接触并行时间不长, 没什么实际经验, 只写过几个并行程序.</p>
<p>感觉 MPI + OpenMP 倒算好用. 简单的单机程序, 用OpenMP并行, 添加几个编译指令就可以. 复杂点的, 用MPI, 也能忍, 只是需要重新设计一下程序和算法.
除了简单的打印, 跟踪一个进程, 不知道怎么调试并行程序. 没有专用平台如NUMA等的编程经验.</p>
<pre><code>                                                 Changsheng Jiang
</code></pre><p>2010/3/22 Guancheng Chen <a href="&#x6d;&#97;&#105;&#108;&#116;&#x6f;&#x3a;&#91;&#99;&#104;&#101;&#x6e;&#x67;&#117;&#x2e;&#x2e;&#46;&#x40;&#x67;&#x6d;&#x61;&#105;&#108;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#41;">&#91;&#99;&#104;&#101;&#x6e;&#x67;&#117;&#x2e;&#x2e;&#46;&#x40;&#x67;&#x6d;&#x61;&#105;&#108;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#41;</a>
不知道您觉得现有的工具哪些个最趁手呢？
On 3月22日, 上午3时19分, Changsheng Jiang <a href="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#x6f;&#58;&#x5b;&#106;&#x69;&#97;&#x6e;&#x67;&#122;&#x75;&#111;&#46;&#46;&#46;&#64;&#103;&#x6d;&#97;&#x69;&#108;&#x2e;&#99;&#111;&#x6d;&#x5d;&#40;&#x29;">&#x5b;&#106;&#x69;&#97;&#x6e;&#x67;&#122;&#x75;&#111;&#46;&#46;&#46;&#64;&#103;&#x6d;&#97;&#x69;&#108;&#x2e;&#99;&#111;&#x6d;&#x5d;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>个人觉得最大障碍在工具上.</p>
<p>并行学术上研究得不少, 主要在算法和模型上. 工程上的工具, 多是自串行程序来设计的, 弄得复杂不堪. 并行需要语言和库两级支持, Pthreads 和
MPI 仅从库上入手, 让程序员处理各种重复且复杂的分发, 并发锁等. OpenMP好一些, 可惜目前只支持线程并行.</p>
<p>用 ErLang 等将并行设计在语言里的来做并行会容易得多, 得易于面向消息传递的隔离模型, 程序稳定易写. 模型和语言的性能是一个问题,
主要的问题还在用的人和实际并行项目不多.</p>
<p>调试工具就更少了. 有少数商业化的工具.</p>
<p>当然, 我是将可维护性归结为语言工具太差.</p>
<pre><code>                                                 Changsheng Jiang
</code></pre><p>2010/3/22 Guancheng Chen <a href="&#109;&#97;&#105;&#x6c;&#x74;&#111;&#x3a;&#91;&#x63;&#104;&#101;&#x6e;&#x67;&#117;&#x61;&#x6e;&#x63;&#x68;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#109;&#97;&#105;&#x6c;&#46;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#41;">&#91;&#x63;&#104;&#101;&#x6e;&#x67;&#117;&#x61;&#x6e;&#x63;&#x68;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#109;&#97;&#105;&#x6c;&#46;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#41;</a></p>
<blockquote>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。</p>
</li>
</ol>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> doyle <img src="" alt=""></p>
</blockquote>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>2010/3/22 Guancheng Chen <a href="&#109;&#97;&#x69;&#x6c;&#116;&#111;&#58;&#91;&#x63;&#x68;&#101;&#110;&#103;&#117;&#x2e;&#46;&#x2e;&#64;&#x67;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#40;&#41;">&#91;&#x63;&#x68;&#101;&#110;&#103;&#117;&#x2e;&#46;&#x2e;&#64;&#x67;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#40;&#41;</a>
我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>我也是被蛊惑了...所以向老婆提申请来着,结果被否掉了...
 On 3月22日, 上午2时20分, Tinyfool <a href="&#109;&#97;&#x69;&#x6c;&#x74;&#x6f;&#x3a;&#x5b;&#116;&#105;&#110;&#121;&#x66;&#x2e;&#46;&#46;&#64;&#103;&#109;&#97;&#105;&#x6c;&#46;&#x63;&#111;&#x6d;&#93;&#x28;&#x29;">&#x5b;&#116;&#105;&#110;&#121;&#x66;&#x2e;&#46;&#46;&#64;&#103;&#109;&#97;&#105;&#x6c;&#46;&#x63;&#111;&#x6d;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#x6d;&#97;&#105;&#x6c;&#x74;&#x6f;&#58;&#x5b;&#x6a;&#x65;&#x2e;&#x2e;&#46;&#64;&#x6c;&#105;&#118;&#101;&#x2e;&#x63;&#111;&#x6d;&#93;&#40;&#41;">&#x5b;&#x6a;&#x65;&#x2e;&#x2e;&#46;&#64;&#x6c;&#105;&#118;&#101;&#x2e;&#x63;&#111;&#x6d;&#93;&#40;&#41;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#109;&#97;&#105;&#x6c;&#x74;&#x6f;&#58;&#91;&#x63;&#104;&#101;&#110;&#103;&#117;&#x61;&#x6e;&#x63;&#x68;&#46;&#x2e;&#x2e;&#64;&#103;&#x6d;&#x61;&#x69;&#x6c;&#46;&#99;&#111;&#x6d;&#x5d;&#40;&#x29;">&#91;&#x63;&#104;&#101;&#110;&#103;&#117;&#x61;&#x6e;&#x63;&#x68;&#46;&#x2e;&#x2e;&#64;&#103;&#x6d;&#x61;&#x69;&#x6c;&#46;&#99;&#111;&#x6d;&#x5d;&#40;&#x29;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#109;&#97;&#x69;&#x6c;&#116;&#111;&#x3a;&#91;&#112;&#x6f;&#x6e;&#46;&#46;&#x2e;&#64;&#x67;&#x6f;&#x6f;&#103;&#x6c;&#x65;&#x67;&#114;&#111;&#x75;&#x70;&#115;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#41;">&#91;&#112;&#x6f;&#x6e;&#46;&#46;&#x2e;&#64;&#x67;&#x6f;&#x6f;&#103;&#x6c;&#x65;&#x67;&#114;&#111;&#x75;&#x70;&#115;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#41;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
</blockquote>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>&gt;</p>
<blockquote>
<blockquote>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。</p>
</li>
</ol>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>--</p>
<p>Tinyfool的开发日记<a href="http://www.tinydust.net/dev/" target="_blank"><a href="http://www.tinydust.net/dev/">http://www.tinydust.net/dev/</a></a>
代码中国网<a href="http://www.codechina.org/" target="_blank"><a href="http://www.codechina.org">http://www.codechina.org</a></a>
myTwitter:<a href="http://twitter.com/tinyfool" target="_blank"><a href="http://twitter.com/tinyfool">http://twitter.com/tinyfool</a></a></p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a></p>
<p><img src="" alt=""> tinyfool <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>热烈支持，哈哈
2010/3/22 Guancheng Chen <a href="&#109;&#x61;&#105;&#x6c;&#x74;&#x6f;&#x3a;&#x5b;&#x63;&#x68;&#101;&#x6e;&#x67;&#x75;&#x2e;&#46;&#46;&#64;&#x67;&#x6d;&#97;&#105;&#x6c;&#46;&#x63;&#111;&#x6d;&#x5d;&#40;&#41;">&#x5b;&#x63;&#x68;&#101;&#x6e;&#x67;&#x75;&#x2e;&#46;&#46;&#64;&#x67;&#x6d;&#97;&#105;&#x6c;&#46;&#x63;&#111;&#x6d;&#x5d;&#40;&#41;</a>
我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>On 3月22日, 上午2时20分, Tinyfool <a href="&#x6d;&#x61;&#x69;&#x6c;&#116;&#111;&#x3a;&#91;&#116;&#x69;&#110;&#x79;&#x66;&#46;&#46;&#46;&#64;&#x67;&#x6d;&#x61;&#105;&#x6c;&#46;&#99;&#x6f;&#109;&#93;&#x28;&#x29;">&#91;&#116;&#x69;&#110;&#x79;&#x66;&#46;&#46;&#46;&#64;&#x67;&#x6d;&#x61;&#105;&#x6c;&#46;&#99;&#x6f;&#109;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p><a href="">显示删减掉的内容</a>
<img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>我个人也觉得OpenMP是目前比较好用的并行方式。像您这样设计算法的程序员，是不是基本上也是只对串行算法做优化改进，然后性能瓶颈比较大的部分才
考虑实施并行化？</p>
<p>On 3月22日, 上午7时09分, Changsheng Jiang <a href="&#109;&#x61;&#105;&#108;&#116;&#x6f;&#58;&#x5b;&#x6a;&#x69;&#97;&#x6e;&#103;&#x7a;&#117;&#111;&#46;&#46;&#x2e;&#64;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#93;&#40;&#x29;">&#x5b;&#x6a;&#x69;&#97;&#x6e;&#103;&#x7a;&#117;&#111;&#46;&#46;&#x2e;&#64;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>说来惭愧, 接触并行时间不长, 没什么实际经验, 只写过几个并行程序.</p>
<p>感觉 MPI + OpenMP 倒算好用. 简单的单机程序, 用OpenMP并行, 添加几个编译指令就可以. 复杂点的, 用MPI, 也能忍,
只是需要重新设计一下程序和算法.</p>
<p>除了简单的打印, 跟踪一个进程, 不知道怎么调试并行程序. 没有专用平台如NUMA等的编程经验.</p>
<pre><code>                                                 Changsheng Jiang
</code></pre><p>2010/3/22 Guancheng Chen <a href="&#109;&#97;&#105;&#108;&#116;&#x6f;&#x3a;&#91;&#x63;&#x68;&#x65;&#x6e;&#103;&#117;&#x61;&#110;&#99;&#x68;&#x2e;&#x2e;&#46;&#x40;&#x67;&#109;&#x61;&#x69;&#x6c;&#46;&#99;&#111;&#109;&#93;&#40;&#x29;">&#91;&#x63;&#x68;&#x65;&#x6e;&#103;&#117;&#x61;&#110;&#99;&#x68;&#x2e;&#x2e;&#46;&#x40;&#x67;&#109;&#x61;&#x69;&#x6c;&#46;&#99;&#111;&#109;&#93;&#40;&#x29;</a></p>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>&gt;
&gt;
&gt;</p>
<blockquote>
<blockquote>
<p>不知道您觉得现有的工具哪些个最趁手呢？</p>
<p>On 3月22日, 上午3时19分, Changsheng Jiang <a href="&#109;&#97;&#x69;&#x6c;&#116;&#x6f;&#58;&#91;&#106;&#x69;&#x61;&#x6e;&#103;&#x7a;&#117;&#x6f;&#x2e;&#46;&#x2e;&#64;&#x67;&#109;&#97;&#x69;&#108;&#x2e;&#99;&#x6f;&#x6d;&#93;&#40;&#x29;">&#91;&#106;&#x69;&#x61;&#x6e;&#103;&#x7a;&#117;&#x6f;&#x2e;&#46;&#x2e;&#64;&#x67;&#109;&#97;&#x69;&#108;&#x2e;&#99;&#x6f;&#x6d;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>个人觉得最大障碍在工具上.</p>
<p>并行学术上研究得不少, 主要在算法和模型上. 工程上的工具, 多是自串行程序来设计的, 弄得复杂不堪. 并行需要语言和库两级支持,
Pthreads 和
MPI 仅从库上入手, 让程序员处理各种重复且复杂的分发, 并发锁等. OpenMP好一些, 可惜目前只支持线程并行.</p>
<p>用 ErLang 等将并行设计在语言里的来做并行会容易得多, 得易于面向消息传递的隔离模型, 程序稳定易写. 模型和语言的性能是一个问题,
主要的问题还在用的人和实际并行项目不多.</p>
<p>调试工具就更少了. 有少数商业化的工具.</p>
<p>当然, 我是将可维护性归结为语言工具太差.</p>
<pre><code>                                                 Changsheng Jiang
</code></pre><p>2010/3/22 Guancheng Chen <a href="&#x6d;&#97;&#105;&#x6c;&#x74;&#x6f;&#x3a;&#x5b;&#99;&#x68;&#101;&#110;&#x67;&#117;&#97;&#x6e;&#x63;&#x68;&#x2e;&#46;&#x2e;&#64;&#x67;&#109;&#97;&#x69;&#x6c;&#46;&#x63;&#x6f;&#109;&#x5d;&#x28;&#x29;">&#x5b;&#99;&#x68;&#101;&#110;&#x67;&#117;&#97;&#x6e;&#x63;&#x68;&#x2e;&#46;&#x2e;&#64;&#x67;&#109;&#97;&#x69;&#x6c;&#46;&#x63;&#x6f;&#109;&#x5d;&#x28;&#x29;</a></p>
<blockquote>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-" target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a></a>.
..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线</p>
</blockquote>
</blockquote>
<p>程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。</p>
<blockquote>
<blockquote>
<p>尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。</p>
</li>
</ol>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
<a href="">显示删减掉的内容</a></p>
</blockquote>
</blockquote>
<p><img src="" alt=""> changsheng <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>说设计算法, 其实, 是实现算法, 找到合适的算法实现了.</p>
<p>五个障碍中的第一条在, 人力有限, 只能并行不并行不行的部分.
                                                     Changsheng Jiang
2010/3/22 Guancheng Chen <a href="&#x6d;&#97;&#105;&#x6c;&#x74;&#x6f;&#x3a;&#91;&#99;&#x68;&#x65;&#x6e;&#103;&#x75;&#46;&#x2e;&#x2e;&#64;&#103;&#109;&#x61;&#x69;&#108;&#46;&#x63;&#x6f;&#109;&#93;&#x28;&#x29;">&#91;&#99;&#x68;&#x65;&#x6e;&#103;&#x75;&#46;&#x2e;&#x2e;&#64;&#103;&#109;&#x61;&#x69;&#108;&#46;&#x63;&#x6f;&#109;&#93;&#x28;&#x29;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>我个人也觉得OpenMP是目前比较好用的并行方式。像您这样设计算法的程序员，是不是基本上也是只对串行算法做优化改进，然后性能瓶颈比较大的部分才
考虑实施并行化？
On 3月22日, 上午7时09分, Changsheng Jiang <a href="&#x6d;&#x61;&#x69;&#108;&#116;&#x6f;&#58;&#91;&#x6a;&#x69;&#97;&#x6e;&#x67;&#122;&#117;&#111;&#46;&#x2e;&#46;&#x40;&#103;&#x6d;&#97;&#x69;&#x6c;&#46;&#x63;&#111;&#109;&#93;&#x28;&#x29;">&#91;&#x6a;&#x69;&#97;&#x6e;&#x67;&#122;&#117;&#111;&#46;&#x2e;&#46;&#x40;&#103;&#x6d;&#97;&#x69;&#x6c;&#46;&#x63;&#111;&#109;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>说来惭愧, 接触并行时间不长, 没什么实际经验, 只写过几个并行程序.</p>
<p>感觉 MPI + OpenMP 倒算好用. 简单的单机程序, 用OpenMP并行, 添加几个编译指令就可以. 复杂点的, 用MPI, 也能忍,
只是需要重新设计一下程序和算法.</p>
<p>除了简单的打印, 跟踪一个进程, 不知道怎么调试并行程序. 没有专用平台如NUMA等的编程经验.</p>
<pre><code>                                                 Changsheng Jiang
</code></pre><p>2010/3/22 Guancheng Chen <a href="&#x6d;&#x61;&#105;&#x6c;&#116;&#111;&#58;&#x5b;&#99;&#x68;&#x65;&#110;&#103;&#x75;&#97;&#110;&#99;&#x68;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#97;&#105;&#x6c;&#x2e;&#99;&#111;&#109;&#x5d;&#40;&#x29;">&#x5b;&#99;&#x68;&#x65;&#110;&#103;&#x75;&#97;&#110;&#99;&#x68;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#97;&#105;&#x6c;&#x2e;&#99;&#111;&#109;&#x5d;&#40;&#x29;</a></p>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>&gt;
&gt;
&gt;</p>
<blockquote>
<blockquote>
<p>不知道您觉得现有的工具哪些个最趁手呢？</p>
<p>On 3月22日, 上午3时19分, Changsheng Jiang <a href="&#109;&#97;&#x69;&#108;&#116;&#111;&#x3a;&#91;&#106;&#x69;&#97;&#x6e;&#x67;&#122;&#x75;&#111;&#46;&#x2e;&#x2e;&#64;&#103;&#x6d;&#97;&#x69;&#108;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#40;&#41;">&#91;&#106;&#x69;&#97;&#x6e;&#x67;&#122;&#x75;&#111;&#46;&#x2e;&#x2e;&#64;&#103;&#x6d;&#97;&#x69;&#108;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>个人觉得最大障碍在工具上.</p>
<p>并行学术上研究得不少, 主要在算法和模型上. 工程上的工具, 多是自串行程序来设计的, 弄得复杂不堪. 并行需要语言和库两级支持,
Pthreads 和
MPI 仅从库上入手, 让程序员处理各种重复且复杂的分发, 并发锁等. OpenMP好一些, 可惜目前只支持线程并行.</p>
<p>用 ErLang 等将并行设计在语言里的来做并行会容易得多, 得易于面向消息传递的隔离模型, 程序稳定易写. 模型和语言的性能是一个问题,
主要的问题还在用的人和实际并行项目不多.</p>
<p>调试工具就更少了. 有少数商业化的工具.</p>
<p>当然, 我是将可维护性归结为语言工具太差.</p>
<pre><code>                                                 Changsheng Jiang
</code></pre><p>2010/3/22 Guancheng Chen <a href="&#109;&#x61;&#x69;&#x6c;&#116;&#x6f;&#x3a;&#91;&#99;&#104;&#101;&#110;&#x67;&#117;&#97;&#x6e;&#99;&#104;&#x2e;&#x2e;&#x2e;&#64;&#103;&#109;&#x61;&#105;&#x6c;&#x2e;&#x63;&#111;&#109;&#93;&#40;&#41;">&#91;&#99;&#104;&#101;&#110;&#x67;&#117;&#97;&#x6e;&#99;&#104;&#x2e;&#x2e;&#x2e;&#64;&#103;&#109;&#x61;&#105;&#x6c;&#x2e;&#x63;&#111;&#109;&#93;&#40;&#41;</a></p>
<blockquote>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-" target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a></a>.
..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线</p>
</blockquote>
</blockquote>
<p>程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。</p>
<blockquote>
<blockquote>
<p>尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。</p>
</li>
</ol>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
 To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> Alleluia <img src="" alt=""></p>
</blockquote>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>Parallelism 说到底是算法问题.Parallelism与Concurrency不同,Concurrency所面对的问题相对的单一可以
让一群有经验的专家来实现一套通用库或者语言来提供一个基本的编程框架.而在Parallelism上,具体的不同问题,其所需要并行的算法是根本不同
的.原因在于不同的问题,其内部的DataDependency的结构完全不同,不同的Data Dependency的结构,需要构造不同的算法.即
便是相同的Data Dependency,在不同的颗粒度下，在不同的硬件条件下所采用的算法也是完全不同的.因为一旦出现Data
Dependency也就意味着并行计算模块之间需要进行通信.从以计算节点为单位的分布式并行,到多核CPU上的Numa结构,到SIMD上的向量处
理器,其计算单元之间的通信手段,通信效率简直天差地别.比如说,在SMP上最常见的并行算法,work stealing也就是Intel的TBB,
是建立在两个条件下第一个是CPU的Cache机制上,这使得通常在内存的之间的数据搬运消耗非常小,第二个是SMP上计算单元相对的少,因此每个计算
单元被分配到的任务就相对的重。其开销远远大于通信的开销,因此这种机制在SMP上相对的划算.但是如果你要在GPU上做Work Stealing就
完全不可行,因为GPU的运算单元数量极多,被分配到的任务就相对来说的非常轻量,CUDA上的一个thread很多时候运算一次的时间不会超过
10us,而一次跨Block的线程之间的通信开销就往往要达到100us左右,再加上目前GPU上的Cache机制非常落后导致了需要频繁的通信开销
的Work Stealing在GPU上是非常不划算得.
所以我个人认为在硬件架构没有更多的突破之前,OpenCL这种东西是没有任何生命力的.不要说CPU的并行与GPU之间差异巨大,就是不同的GPU之
间AMD与Nvidia两个也是各自为政,一个平台上跑得非常快的东西,在另外一个平台极大的可能是龟速.其最终的结果估计就是跟Java的
write once run everywhere一样是个大笑话.</p>
<p>On 3月22日, 下午2时06分, Guancheng Chen <a href="&#x6d;&#x61;&#x69;&#108;&#116;&#111;&#58;&#x5b;&#x63;&#104;&#x65;&#x6e;&#x67;&#x75;&#x61;&#x6e;&#99;&#104;&#x2e;&#x2e;&#46;&#x40;&#x67;&#109;&#97;&#105;&#108;&#x2e;&#99;&#x6f;&#x6d;&#93;&#x28;&#x29;">&#x5b;&#x63;&#104;&#x65;&#x6e;&#x67;&#x75;&#x61;&#x6e;&#99;&#104;&#x2e;&#x2e;&#46;&#x40;&#x67;&#109;&#97;&#105;&#108;&#x2e;&#99;&#x6f;&#x6d;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>On 3月22日, 上午2时20分, Tinyfool <a href="&#109;&#97;&#x69;&#108;&#x74;&#111;&#x3a;&#x5b;&#x74;&#105;&#110;&#x79;&#x66;&#x2e;&#46;&#46;&#x40;&#103;&#109;&#97;&#x69;&#x6c;&#46;&#x63;&#111;&#109;&#93;&#40;&#41;">&#x5b;&#x74;&#105;&#110;&#x79;&#x66;&#x2e;&#46;&#46;&#x40;&#103;&#109;&#97;&#x69;&#x6c;&#46;&#x63;&#111;&#109;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#109;&#97;&#x69;&#x6c;&#116;&#111;&#x3a;&#x5b;&#x6a;&#x65;&#x2e;&#46;&#x2e;&#x40;&#108;&#105;&#118;&#101;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#40;&#41;">&#x5b;&#x6a;&#x65;&#x2e;&#46;&#x2e;&#x40;&#108;&#105;&#118;&#101;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#40;&#41;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#x6d;&#x61;&#x69;&#108;&#116;&#111;&#x3a;&#91;&#99;&#104;&#x65;&#x6e;&#103;&#117;&#97;&#110;&#x63;&#x68;&#46;&#46;&#46;&#x40;&#103;&#x6d;&#97;&#x69;&#108;&#46;&#99;&#111;&#x6d;&#93;&#x28;&#x29;">&#91;&#99;&#104;&#x65;&#x6e;&#103;&#117;&#97;&#110;&#x63;&#x68;&#46;&#46;&#46;&#x40;&#103;&#x6d;&#97;&#x69;&#108;&#46;&#99;&#111;&#x6d;&#93;&#x28;&#x29;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#109;&#97;&#105;&#x6c;&#x74;&#x6f;&#58;&#91;&#112;&#111;&#x6e;&#x2e;&#46;&#x2e;&#64;&#x67;&#111;&#111;&#103;&#x6c;&#x65;&#x67;&#114;&#x6f;&#117;&#x70;&#x73;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#40;&#x29;">&#91;&#112;&#111;&#x6e;&#x2e;&#46;&#x2e;&#64;&#x67;&#111;&#111;&#103;&#x6c;&#x65;&#x67;&#114;&#x6f;&#117;&#x70;&#x73;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#40;&#x29;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
</blockquote>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<blockquote>
<blockquote>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。</p>
</li>
</ol>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>--
Tinyfool的开发日记<a href="http://www.tinydust.net/dev/" target="_blank"><a href="http://www.tinydust.net/dev/">http://www.tinydust.net/dev/</a></a>
代码中国网<a href="http://www.codechina.org/" target="_blank"><a href="http://www.codechina.org">http://www.codechina.org</a></a>
myTwitter:<a href="http://twitter.com/tinyfool" target="_blank"><a href="http://twitter.com/tinyfool">http://twitter.com/tinyfool</a></a>
<a href="">显示删减掉的内容</a></p>
</blockquote>
</blockquote>
<p><img src="" alt=""> Alleluia <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>其实并行计算这个东西,对现有的基于文本内容的程序意义不是很大.因为文本内容的数据量增加是线性的.而相对来说,视频音频的数据就完全不同是按平方甚
至是指数增加的.一个文本长度增加一倍,数据量也就增加一倍.而一张图片,长宽增加一倍,数据量要增加四倍.一个既有的算法在没有大的理论突破的前提
下,在特定的硬件平台上能够优化加速5-6倍已经是了不得了.但是对于多媒体数据来说,这个加速真的不算什么.一个算法在720p上快3,4倍,换到
1080p的也就是达到了720p上不加速的效果而已.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>绝大部分的观点Can&#39;t agree more.其实这也是为什么我引用了高老爷子那段话的原因，因为程序的本质就是数据结构和算法，你要没有非常适
合并行的算法那简直就是巧妇难为无米之炊。但是有疑问的一点是关于Parallelism和Concurrency这两个单词的区别，实际上这也是非常
有意思的一件事情，Sun的多线程指南上写的是： Parallelism is a condition that arises when at
least two threads are executing simultaneously, while concurrency is a
condition that exists when at least two threads are making progress.
Therefore concurrency is a more generalized form of parallelism that
can include time-slicing as a form of virtual parallelism.不知道您怎么看？</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>On 3月22日, 上午8时06分, Alleluia <a href="&#x6d;&#97;&#x69;&#108;&#x74;&#x6f;&#58;&#x5b;&#x61;&#x6c;&#x6c;&#117;&#108;&#46;&#46;&#x2e;&#x40;&#103;&#x6d;&#97;&#105;&#108;&#46;&#x63;&#x6f;&#109;&#93;&#x28;&#41;">&#x5b;&#x61;&#x6c;&#x6c;&#117;&#108;&#46;&#46;&#x2e;&#x40;&#103;&#x6d;&#97;&#105;&#108;&#46;&#x63;&#x6f;&#109;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>Parallelism 说到底是算法问题.Parallelism与Concurrency不同,Concurrency所面对的问题相对的单一可以
让一群有经验的专家来实现一套通用库或者语言来提供一个基本的编程框架.而在Parallelism上,具体的不同问题,其所需要并行的算法是根本不同
的.原因在于不同的问题,其内部的DataDependency的结构完全不同,不同的Data Dependency的结构,需要构造不同的算法.即
便是相同的Data Dependency,在不同的颗粒度下，在不同的硬件条件下所采用的算法也是完全不同的.因为一旦出现Data
Dependency也就意味着并行计算模块之间需要进行通信.从以计算节点为单位的分布式并行,到多核CPU上的Numa结构,到SIMD上的向量处
理器,其计算单元之间的通信手段,通信效率简直天差地别.比如说,在SMP上最常见的并行算法,work stealing也就是Intel的TBB,
是建立在两个条件下第一个是CPU的Cache机制上,这使得通常在内存的之间的数据搬运消耗非常小,第二个是SMP上计算单元相对的少,因此每个计算
单元被分配到的任务就相对的重。其开销远远大于通信的开销,因此这种机制在SMP上相对的划算.但是如果你要在GPU上做Work Stealing就
完全不可行,因为GPU的运算单元数量极多,被分配到的任务就相对来说的非常轻量,CUDA上的一个thread很多时候运算一次的时间不会超过
10us,而一次跨Block的线程之间的通信开销就往往要达到100us左右,再加上目前GPU上的Cache机制非常落后导致了需要频繁的通信开销
的Work Stealing在GPU上是非常不划算得.
所以我个人认为在硬件架构没有更多的突破之前,OpenCL这种东西是没有任何生命力的.不要说CPU的并行与GPU之间差异巨大,就是不同的GPU之
间AMD与Nvidia两个也是各自为政,一个平台上跑得非常快的东西,在另外一个平台极大的可能是龟速.其最终的结果估计就是跟Java的
write once run everywhere一样是个大笑话.</p>
<p>On 3月22日, 下午2时06分, Guancheng Chen <a href="&#x6d;&#97;&#105;&#108;&#x74;&#x6f;&#58;&#x5b;&#99;&#x68;&#x65;&#110;&#x67;&#117;&#x61;&#x6e;&#x63;&#x68;&#46;&#x2e;&#x2e;&#64;&#103;&#109;&#97;&#x69;&#108;&#x2e;&#99;&#111;&#109;&#x5d;&#x28;&#41;">&#x5b;&#99;&#x68;&#x65;&#110;&#x67;&#117;&#x61;&#x6e;&#x63;&#x68;&#46;&#x2e;&#x2e;&#64;&#103;&#109;&#97;&#x69;&#108;&#x2e;&#99;&#111;&#109;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>On 3月22日, 上午2时20分, Tinyfool <a href="&#109;&#97;&#105;&#108;&#x74;&#x6f;&#58;&#x5b;&#x74;&#105;&#110;&#x79;&#x66;&#46;&#46;&#46;&#x40;&#103;&#x6d;&#97;&#x69;&#108;&#46;&#x63;&#111;&#109;&#x5d;&#40;&#41;">&#x5b;&#x74;&#105;&#110;&#x79;&#x66;&#46;&#46;&#46;&#x40;&#103;&#x6d;&#97;&#x69;&#108;&#46;&#x63;&#111;&#109;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#109;&#97;&#105;&#x6c;&#x74;&#x6f;&#58;&#91;&#106;&#x65;&#x2e;&#46;&#x2e;&#x40;&#108;&#105;&#118;&#x65;&#x2e;&#99;&#x6f;&#x6d;&#93;&#40;&#41;">&#91;&#106;&#x65;&#x2e;&#46;&#x2e;&#x40;&#108;&#105;&#118;&#x65;&#x2e;&#99;&#x6f;&#x6d;&#93;&#40;&#41;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#109;&#x61;&#x69;&#108;&#x74;&#111;&#58;&#x5b;&#x63;&#104;&#101;&#x6e;&#103;&#117;&#97;&#110;&#x63;&#x68;&#x2e;&#x2e;&#46;&#64;&#103;&#x6d;&#97;&#x69;&#x6c;&#46;&#x63;&#x6f;&#109;&#x5d;&#40;&#41;">&#x5b;&#x63;&#104;&#101;&#x6e;&#103;&#117;&#97;&#110;&#x63;&#x68;&#x2e;&#x2e;&#46;&#64;&#103;&#x6d;&#97;&#x69;&#x6c;&#46;&#x63;&#x6f;&#109;&#x5d;&#40;&#41;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#109;&#x61;&#105;&#x6c;&#x74;&#111;&#x3a;&#x5b;&#112;&#x6f;&#110;&#x2e;&#46;&#46;&#64;&#x67;&#x6f;&#x6f;&#x67;&#108;&#x65;&#x67;&#x72;&#111;&#x75;&#x70;&#115;&#x2e;&#x63;&#x6f;&#109;&#93;&#40;&#41;">&#x5b;&#112;&#x6f;&#110;&#x2e;&#46;&#46;&#64;&#x67;&#x6f;&#x6f;&#x67;&#108;&#x65;&#x67;&#x72;&#111;&#x75;&#x70;&#115;&#x2e;&#x63;&#x6f;&#109;&#93;&#40;&#41;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，...</p>
</blockquote>
</blockquote>
</blockquote>
<p>阅读更多 &gt;&gt;
<a href="">显示删减掉的内容</a></p>
</blockquote>
<p><img src="" alt=""> Alleluia <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>Concurrency 说到底纯粹就是一个IO问题.而IO问题本质上是和计算完全无关的事情,不存在能不能行可不可计算的问题.因此它相对来说非常
单纯。他更多的是一种类似时钟同步的问题,如果你把IO事件想像成一种时钟信号.其实时钟本来也就是一堆信号而已.如果你做过Circuit 的东西就
会明白,IO只是在不同的时序下进行数据采样.比如最简单的同步时钟,所有的时序电路公用一个时钟,把不同的电路安排在不同的时序边沿上触发.当然更复
杂异步逻辑的道理也是一样的.放到宏观的Concurrency的问题的实质并没有多大改变,只不过CPU依靠PC指针的移动把这种电路上的时序处理软
件化了.</p>
<p>而Parallelism更多的是需要考虑计算问题同时还要兼顾IO.Parallelism首先要回答的是一个东西是不是可并行的.回答完这个问题
后,如果可并行那么在什么样的硬件设备上并行是最合适的这样一个问题.在Parallelism中需要考虑的的IO也不仅仅是来自于网络更多是,缓存,
内存,磁盘,总线等等.其实我觉得,在Parallelism下你总是处于一个矛盾状态,颗粒度越小的并行获得的计算资源的利用率也就越大加速比就越
大,但是同时通信系统的工作也就越是繁忙整个运算过程浪费在通信消耗上的时间也就越多.
这个当中的tradeoff是非常困难的.很多时候速度不快,完全不是因为你的核心不够多,而是你的通信速度不够高.</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>On 3月22日, 下午3时21分, Guancheng Chen <a href="&#x6d;&#x61;&#105;&#108;&#x74;&#x6f;&#58;&#91;&#x63;&#104;&#101;&#110;&#103;&#117;&#x61;&#x6e;&#x63;&#104;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#109;&#97;&#x69;&#x6c;&#46;&#99;&#x6f;&#109;&#x5d;&#x28;&#x29;">&#91;&#x63;&#104;&#101;&#110;&#103;&#117;&#x61;&#x6e;&#x63;&#104;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#109;&#97;&#x69;&#x6c;&#46;&#99;&#x6f;&#109;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>绝大部分的观点Can&#39;t agree more.其实这也是为什么我引用了高老爷子那段话的原因，因为程序的本质就是数据结构和算法，你要没有非常适
合并行的算法那简直就是巧妇难为无米之炊。但是有疑问的一点是关于Parallelism和Concurrency这两个单词的区别，实际上这也是非常
有意思的一件事情，Sun的多线程指南上写的是： Parallelism is a condition that arises when at
least two threads are executing simultaneously, while concurrency is a
condition that exists when at least two threads are making progress.
Therefore concurrency is a more generalized form of parallelism that
can include time-slicing as a form of virtual parallelism.不知道您怎么看？</p>
<p>On 3月22日, 上午8时06分, Alleluia <a href="&#x6d;&#97;&#x69;&#x6c;&#116;&#111;&#58;&#x5b;&#97;&#x6c;&#x6c;&#117;&#108;&#x2e;&#46;&#x2e;&#x40;&#103;&#109;&#97;&#x69;&#108;&#46;&#x63;&#111;&#109;&#x5d;&#40;&#41;">&#x5b;&#97;&#x6c;&#x6c;&#117;&#108;&#x2e;&#46;&#x2e;&#x40;&#103;&#109;&#97;&#x69;&#108;&#46;&#x63;&#111;&#109;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>Parallelism 说到底是算法问题.Parallelism与Concurrency不同,Concurrency所面对的问题相对的单一可以
让一群有经验的专家来实现一套通用库或者语言来提供一个基本的编程框架.而在Parallelism上,具体的不同问题,其所需要并行的算法是根本不同
的.原因在于不同的问题,其内部的DataDependency的结构完全不同,不同的Data Dependency的结构,需要构造不同的算法.即
便是相同的Data Dependency,在不同的颗粒度下，在不同的硬件条件下所采用的算法也是完全不同的.因为一旦出现Data
Dependency也就意味着并行计算模块之间需要进行通信.从以计算节点为单位的分布式并行,到多核CPU上的Numa结构,到SIMD上的向量处
理器,其计算单元之间的通信手段,通信效率简直天差地别.比如说,在SMP上最常见的并行算法,work stealing也就是Intel的TBB,
是建立在两个条件下第一个是CPU的Cache机制上,这使得通常在内存的之间的数据搬运消耗非常小,第二个是SMP上计算单元相对的少,因此每个计算
单元被分配到的任务就相对的重。其开销远远大于通信的开销,因此这种机制在SMP上相对的划算.但是如果你要在GPU上做Work Stealing就
完全不可行,因为GPU的运算单元数量极多,被分配到的任务就相对来说的非常轻量,CUDA上的一个thread很多时候运算一次的时间不会超过
10us,而一次跨Block的线程之间的通信开销就往往要达到100us左右,再加上目前GPU上的Cache机制非常落后导致了需要频繁的通信开销
的Work Stealing在GPU上是非常不划算得.
所以我个人认为在硬件架构没有更多的突破之前,OpenCL这种东西是没有任何生命力的.不要说CPU的并行与GPU之间差异巨大,就是不同的GPU之
间AMD与Nvidia两个也是各自为政,一个平台上跑得非常快的东西,在另外一个平台极大的可能是龟速.其最终的结果估计就是跟Java的
write once run everywhere一样是个大笑话.</p>
<p>On 3月22日, 下午2时06分, Guancheng Chen <a href="&#x6d;&#97;&#x69;&#x6c;&#116;&#111;&#x3a;&#91;&#x63;&#104;&#101;&#x6e;&#x67;&#x75;&#x61;&#110;&#x63;&#x68;&#x2e;&#46;&#x2e;&#64;&#103;&#109;&#97;&#x69;&#108;&#46;&#99;&#111;&#x6d;&#93;&#40;&#x29;">&#91;&#x63;&#104;&#101;&#x6e;&#x67;&#x75;&#x61;&#110;&#x63;&#x68;&#x2e;&#46;&#x2e;&#64;&#103;&#109;&#97;&#x69;&#108;&#46;&#99;&#111;&#x6d;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>On 3月22日, 上午2时20分, Tinyfool <a href="&#x6d;&#97;&#105;&#108;&#116;&#x6f;&#58;&#x5b;&#x74;&#105;&#110;&#121;&#x66;&#x2e;&#46;&#x2e;&#x40;&#103;&#x6d;&#x61;&#105;&#x6c;&#46;&#99;&#111;&#x6d;&#93;&#40;&#41;">&#x5b;&#x74;&#105;&#110;&#121;&#x66;&#x2e;&#46;&#x2e;&#x40;&#103;&#x6d;&#x61;&#105;&#x6c;&#46;&#99;&#111;&#x6d;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#x6d;&#x61;&#x69;&#x6c;&#116;&#111;&#x3a;&#91;&#x6a;&#x65;&#x2e;&#46;&#46;&#x40;&#108;&#x69;&#x76;&#x65;&#46;&#x63;&#111;&#109;&#x5d;&#x28;&#41;">&#91;&#x6a;&#x65;&#x2e;&#46;&#46;&#x40;&#108;&#x69;&#x76;&#x65;&#46;&#x63;&#111;&#109;&#x5d;&#x28;&#41;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#x6d;&#x61;&#105;&#108;&#116;&#111;&#x3a;&#x5b;&#99;&#104;&#101;&#x6e;&#x67;&#x75;&#x61;&#110;&#99;&#x68;&#46;&#x2e;&#46;&#64;&#103;&#x6d;&#97;&#x69;&#108;&#46;&#x63;&#111;&#x6d;&#x5d;&#40;&#x29;">&#x5b;&#99;&#104;&#101;&#x6e;&#x67;&#x75;&#x61;&#110;&#99;&#x68;&#46;&#x2e;&#46;&#64;&#103;&#x6d;&#97;&#x69;&#108;&#46;&#x63;&#111;&#x6d;&#x5d;&#40;&#x29;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#109;&#97;&#105;&#x6c;&#x74;&#111;&#x3a;&#x5b;&#112;&#111;&#110;&#46;&#x2e;&#46;&#64;&#x67;&#x6f;&#x6f;&#103;&#108;&#101;&#103;&#x72;&#x6f;&#117;&#112;&#x73;&#x2e;&#x63;&#111;&#x6d;&#93;&#x28;&#41;">&#x5b;&#112;&#111;&#110;&#46;&#x2e;&#46;&#64;&#x67;&#x6f;&#x6f;&#103;&#108;&#101;&#103;&#x72;&#x6f;&#117;&#112;&#x73;&#x2e;&#x63;&#111;&#x6d;&#93;&#x28;&#41;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>...</p>
<p>阅读更多 &gt;&gt;
<a href="">显示删减掉的内容</a>
<img src="" alt=""> Alleluia <img src="" alt=""></p>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>Microsoft Accelerator稍稍看了一下这个东西,是05年的工作.这个东西其实已经不新鲜了.大概跟PyCUDA
array-processing operations such as those which frequently arise in
domains.
但是我要说的是,这个领域相对于真正需要的并行计算实在是太少太少.比如说他强调的 image processing and
scientific computing,当中很多非线性滤波的并行算法就不能用这个架构来做.</p>
<p>On 3月22日, 上午9时42分, &quot;Jeffrey Zhao&quot; <a href="&#x6d;&#97;&#x69;&#x6c;&#116;&#111;&#58;&#91;&#x6a;&#101;&#46;&#46;&#46;&#x40;&#x6c;&#x69;&#118;&#101;&#x2e;&#99;&#111;&#x6d;&#x5d;&#x28;&#41;">&#91;&#x6a;&#101;&#46;&#46;&#46;&#x40;&#x6c;&#x69;&#118;&#101;&#x2e;&#99;&#111;&#x6d;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>哈哈，广告好，扩展视野，那我继续做广告了......</p>
<p>微软其实很早就在搞Microsoft Accelerator项目，旨在利用DirectX进行计算，.NET项目。<a href="http://research.microsoft.com/en-us/projects/Accelerator/" target="_blank"><a href="http://research.microsoft.com/en-us/projects/Accelerator/">http://research.microsoft.com/en-us/projects/Accelerator/</a></a></p>
<p>然后F/#这边由于语言的支持良好，可以设计出丰富的表达式、DSL等Modeling Language，再由框架进行自动并行，解决问题可以很容易（已经2.0了）。</p>
<p>这篇文章是个简单介绍：<a href="http://strangelights.com/blog/archive/2008/09/21/1628.aspx" target="_blank"><a href="http://strangelights.com/blog/archive/2008/09/21/1628.aspx">http://strangelights.com/blog/archive/2008/09/21/1628.aspx</a></a></p>
<p>Microsoft Solver Foundation<a href="http://[code.msdn.microsoft.com/solverfoundation](http://code.msdn.microsoft.com/solverfoundation" target="_blank">http://[code.msdn.microsoft.com/solverfoundation](http://code.msdn.microsoft.com/solverfoundation</a>)</p>
<p>F/# Optimization Modeling Language Utilizing Microsoft Solver Foundation<a href="http://[code.msdn.microsoft.com/solverfoundationfs1](http://code.msdn.microsoft.com/solverfoundationfs1" target="_blank">http://[code.msdn.microsoft.com/solverfoundationfs1](http://code.msdn.microsoft.com/solverfoundationfs1</a>)</p>
<p>现在就等OpenCL如果有标准出来，肯定立马可以跟上个类库，哦耶。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p>From: Tinyfool
Sent: Monday, March 22, 2010 9:20 AM
To: <a href="">pon...@googlegroups.com</a>
Subject: Re: [TL] {技术}{多线程}实施并行编程的五大障碍</p>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#x6d;&#x61;&#105;&#x6c;&#116;&#111;&#58;&#x5b;&#106;&#x65;&#x2e;&#x2e;&#x2e;&#64;&#108;&#x69;&#x76;&#101;&#46;&#99;&#x6f;&#x6d;&#93;&#x28;&#x29;">&#x5b;&#106;&#x65;&#x2e;&#x2e;&#x2e;&#64;&#108;&#x69;&#x76;&#101;&#46;&#99;&#x6f;&#x6d;&#93;&#x28;&#x29;</a></p>
<p>  我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>  其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>  例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>  至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>  例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>  Jeffrey Zhao
  Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
  Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p>  From: Guancheng Chen
  Sent: Monday, March 22, 2010 7:37 AM
  To: TopLanguage
  Subject: [TL] {技术}{多线程}实施并行编程的五大障碍</p>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>&gt;</p>
<blockquote>
<p>  近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
  碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
  (fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
  Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
  的看法。</p>
<p>  ( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看
 <a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
  )</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
</li>
<li><p>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</p>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，</p>
<p>Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
</li>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
...</p>
</li>
</ol>
<p>阅读更多 &gt;&gt;
<a href="">显示删减掉的内容</a></p>
</blockquote>
<p><img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>您的观点很有新意，我以前没有过用IO来区分Concurrency和Parallelism的想法，我猜测可能跟您的网络/通信背景有关。其实我觉得
从广义上来讲Parallelism和Concurrency是基本重合的两个概念，只不过可能Concurrency稍微偏工程一点，
Parallelism稍微偏研究一点。例如Herb Sutter要出的新书叫Effective Concurrency,而市面上其他讲并行计算
的书不少也使用Parallel相关的词汇。</p>
<p>另外您这句话我有些不赞同：&quot;颗粒度越小的并行获得的计算资源的利用率也就越大加速比就越大&quot;，拿一个计算密集型的嵌套循环举例，对比并行外层循环和并
行内层循环，无疑你在并行化外层循环时的性能加速比更好，而这时候你的并行度是粗粒度的(内循环并行相对来说是细粒度的)。当然，粗/细粒度的选择确实
是个tradeoff，拿锁竞争来说，细粒度的锁意味着更好的Scalability，但是你加锁/解锁的次数相比组粒度所来说增加了，而这种加锁/解
锁的操作是有开销的，所以需要在锁操作本身的开销和程序的Scalability中做一个平衡。</p>
<p>多谢指教！</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>On 3月22日, 上午10时19分, Alleluia <a href="&#x6d;&#97;&#x69;&#108;&#x74;&#x6f;&#58;&#91;&#x61;&#108;&#x6c;&#117;&#x6c;&#46;&#46;&#46;&#64;&#x67;&#x6d;&#97;&#105;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#93;&#40;&#41;">&#91;&#x61;&#108;&#x6c;&#117;&#x6c;&#46;&#46;&#46;&#64;&#x67;&#x6d;&#97;&#105;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>Concurrency 说到底纯粹就是一个IO问题.而IO问题本质上是和计算完全无关的事情,不存在能不能行可不可计算的问题.因此它相对来说非常
单纯。他更多的是一种类似时钟同步的问题,如果你把IO事件想像成一种时钟信号.其实时钟本来也就是一堆信号而已.如果你做过Circuit 的东西就
会明白,IO只是在不同的时序下进行数据采样.比如最简单的同步时钟,所有的时序电路公用一个时钟,把不同的电路安排在不同的时序边沿上触发.当然更复
杂异步逻辑的道理也是一样的.放到宏观的Concurrency的问题的实质并没有多大改变,只不过CPU依靠PC指针的移动把这种电路上的时序处理软
件化了.</p>
<p>而Parallelism更多的是需要考虑计算问题同时还要兼顾IO.Parallelism首先要回答的是一个东西是不是可并行的.回答完这个问题
后,如果可并行那么在什么样的硬件设备上并行是最合适的这样一个问题.在Parallelism中需要考虑的的IO也不仅仅是来自于网络更多是,缓存,
内存,磁盘,总线等等.其实我觉得,在Parallelism下你总是处于一个矛盾状态,颗粒度越小的并行获得的计算资源的利用率也就越大加速比就越
大,但是同时通信系统的工作也就越是繁忙整个运算过程浪费在通信消耗上的时间也就越多.
这个当中的tradeoff是非常困难的.很多时候速度不快,完全不是因为你的核心不够多,而是你的通信速度不够高.</p>
<p>On 3月22日, 下午3时21分, Guancheng Chen <a href="&#x6d;&#x61;&#105;&#108;&#x74;&#x6f;&#x3a;&#x5b;&#x63;&#x68;&#101;&#x6e;&#103;&#117;&#97;&#110;&#x63;&#x68;&#x2e;&#x2e;&#46;&#x40;&#103;&#109;&#97;&#x69;&#108;&#46;&#99;&#x6f;&#x6d;&#x5d;&#40;&#x29;">&#x5b;&#x63;&#x68;&#101;&#x6e;&#103;&#117;&#97;&#110;&#x63;&#x68;&#x2e;&#x2e;&#46;&#x40;&#103;&#109;&#97;&#x69;&#108;&#46;&#99;&#x6f;&#x6d;&#x5d;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>绝大部分的观点Can&#39;t agree more.其实这也是为什么我引用了高老爷子那段话的原因，因为程序的本质就是数据结构和算法，你要没有非常适
合并行的算法那简直就是巧妇难为无米之炊。但是有疑问的一点是关于Parallelism和Concurrency这两个单词的区别，实际上这也是非常
有意思的一件事情，Sun的多线程指南上写的是： Parallelism is a condition that arises when at
least two threads are executing simultaneously, while concurrency is a
condition that exists when at least two threads are making progress.
Therefore concurrency is a more generalized form of parallelism that
can include time-slicing as a form of virtual parallelism.不知道您怎么看？</p>
<p>On 3月22日, 上午8时06分, Alleluia <a href="&#109;&#x61;&#x69;&#108;&#x74;&#x6f;&#x3a;&#x5b;&#97;&#108;&#108;&#x75;&#x6c;&#x2e;&#46;&#46;&#64;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#109;&#93;&#x28;&#x29;">&#x5b;&#97;&#108;&#108;&#x75;&#x6c;&#x2e;&#46;&#46;&#64;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#109;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>Parallelism 说到底是算法问题.Parallelism与Concurrency不同,Concurrency所面对的问题相对的单一可以
让一群有经验的专家来实现一套通用库或者语言来提供一个基本的编程框架.而在Parallelism上,具体的不同问题,其所需要并行的算法是根本不同
的.原因在于不同的问题,其内部的DataDependency的结构完全不同,不同的Data Dependency的结构,需要构造不同的算法.即
便是相同的Data Dependency,在不同的颗粒度下，在不同的硬件条件下所采用的算法也是完全不同的.因为一旦出现Data
Dependency也就意味着并行计算模块之间需要进行通信.从以计算节点为单位的分布式并行,到多核CPU上的Numa结构,到SIMD上的向量处
理器,其计算单元之间的通信手段,通信效率简直天差地别.比如说,在SMP上最常见的并行算法,work stealing也就是Intel的TBB,
是建立在两个条件下第一个是CPU的Cache机制上,这使得通常在内存的之间的数据搬运消耗非常小,第二个是SMP上计算单元相对的少,因此每个计算
单元被分配到的任务就相对的重。其开销远远大于通信的开销,因此这种机制在SMP上相对的划算.但是如果你要在GPU上做Work Stealing就
完全不可行,因为GPU的运算单元数量极多,被分配到的任务就相对来说的非常轻量,CUDA上的一个thread很多时候运算一次的时间不会超过
10us,而一次跨Block的线程之间的通信开销就往往要达到100us左右,再加上目前GPU上的Cache机制非常落后导致了需要频繁的通信开销
的Work Stealing在GPU上是非常不划算得.
所以我个人认为在硬件架构没有更多的突破之前,OpenCL这种东西是没有任何生命力的.不要说CPU的并行与GPU之间差异巨大,就是不同的GPU之
间AMD与Nvidia两个也是各自为政,一个平台上跑得非常快的东西,在另外一个平台极大的可能是龟速.其最终的结果估计就是跟Java的
write once run everywhere一样是个大笑话.</p>
<p>On 3月22日, 下午2时06分, Guancheng Chen <a href="&#x6d;&#x61;&#105;&#x6c;&#x74;&#111;&#58;&#91;&#99;&#x68;&#x65;&#110;&#x67;&#117;&#x61;&#x6e;&#x63;&#104;&#46;&#46;&#46;&#x40;&#x67;&#109;&#x61;&#x69;&#108;&#x2e;&#99;&#111;&#109;&#x5d;&#x28;&#41;">&#91;&#99;&#x68;&#x65;&#110;&#x67;&#117;&#x61;&#x6e;&#x63;&#104;&#46;&#46;&#46;&#x40;&#x67;&#109;&#x61;&#x69;&#108;&#x2e;&#99;&#111;&#109;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>On 3月22日, 上午2时20分, Tinyfool <a href="&#x6d;&#x61;&#105;&#108;&#x74;&#111;&#58;&#91;&#116;&#105;&#110;&#x79;&#102;&#x2e;&#x2e;&#46;&#x40;&#x67;&#x6d;&#x61;&#105;&#108;&#46;&#99;&#111;&#109;&#x5d;&#x28;&#x29;">&#91;&#116;&#105;&#110;&#x79;&#102;&#x2e;&#x2e;&#46;&#x40;&#x67;&#x6d;&#x61;&#105;&#108;&#46;&#99;&#111;&#109;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#109;&#x61;&#105;&#108;&#x74;&#x6f;&#58;&#x5b;&#106;&#101;&#46;&#x2e;&#46;&#x40;&#x6c;&#x69;&#x76;&#x65;&#46;&#x63;&#111;&#x6d;&#x5d;&#40;&#41;">&#x5b;&#106;&#101;&#46;&#x2e;&#46;&#x40;&#x6c;&#x69;&#x76;&#x65;&#46;&#x63;&#111;&#x6d;&#x5d;&#40;&#41;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#x6d;&#97;&#105;&#108;&#x74;&#111;&#58;&#91;&#x63;&#104;&#101;&#x6e;&#103;&#117;&#97;&#110;&#x63;&#104;&#x2e;&#46;&#46;&#x40;&#x67;&#109;&#x61;&#105;&#108;&#46;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#x29;">&#91;&#x63;&#104;&#101;&#x6e;&#103;&#117;&#97;&#110;&#x63;&#104;&#x2e;&#46;&#46;&#x40;&#x67;&#109;&#x61;&#105;&#108;&#46;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#x29;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#109;&#97;&#105;&#108;&#x74;&#x6f;&#58;&#x5b;&#112;&#111;&#110;&#x2e;&#x2e;&#46;&#64;&#x67;&#x6f;&#111;&#x67;&#x6c;&#101;&#103;&#x72;&#111;&#x75;&#112;&#115;&#46;&#99;&#111;&#x6d;&#93;&#x28;&#x29;">&#x5b;&#112;&#111;&#110;&#x2e;&#x2e;&#46;&#64;&#x67;&#x6f;&#111;&#x67;&#x6c;&#101;&#103;&#x72;&#111;&#x75;&#112;&#115;&#46;&#99;&#111;&#x6d;&#93;&#x28;&#x29;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也...</p>
</li>
</ol>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>阅读更多 &gt;&gt;
<a href="">显示删减掉的内容</a>
<img src="" alt=""> Googol Lee <img src="" alt=""></p>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>彻底来晚了......我是来广告golang的！大并发IO还是csp模型的语言更靠谱！</p>
<p>不过golang在cpu密集的并发上不知道效果会怎么样，就现在的表现来看比erlang好，但还赶不上c/c++</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>On Mar 22, 9:20 am, Tinyfool <a href="&#x6d;&#97;&#105;&#108;&#x74;&#111;&#x3a;&#x5b;&#116;&#105;&#110;&#121;&#x66;&#x2e;&#46;&#46;&#x40;&#103;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#109;&#93;&#x28;&#41;">&#x5b;&#116;&#105;&#110;&#121;&#x66;&#x2e;&#46;&#46;&#x40;&#103;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#109;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#x6d;&#97;&#105;&#x6c;&#x74;&#x6f;&#x3a;&#91;&#x6a;&#x65;&#x2e;&#46;&#x2e;&#64;&#x6c;&#x69;&#x76;&#x65;&#x2e;&#99;&#x6f;&#x6d;&#93;&#x28;&#x29;">&#91;&#x6a;&#x65;&#x2e;&#46;&#x2e;&#64;&#x6c;&#x69;&#x76;&#x65;&#x2e;&#99;&#x6f;&#x6d;&#93;&#x28;&#x29;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#109;&#x61;&#105;&#108;&#116;&#111;&#58;&#x5b;&#99;&#104;&#101;&#x6e;&#x67;&#x75;&#97;&#x6e;&#99;&#104;&#x2e;&#x2e;&#46;&#x40;&#x67;&#109;&#x61;&#x69;&#108;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#41;">&#x5b;&#99;&#104;&#101;&#x6e;&#x67;&#x75;&#97;&#x6e;&#99;&#104;&#x2e;&#x2e;&#46;&#x40;&#x67;&#109;&#x61;&#x69;&#108;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#41;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#x6d;&#x61;&#105;&#x6c;&#116;&#111;&#x3a;&#x5b;&#x70;&#x6f;&#110;&#46;&#x2e;&#x2e;&#x40;&#103;&#111;&#111;&#x67;&#108;&#x65;&#x67;&#114;&#x6f;&#117;&#112;&#x73;&#46;&#99;&#x6f;&#109;&#93;&#40;&#41;">&#x5b;&#x70;&#x6f;&#110;&#46;&#x2e;&#x2e;&#x40;&#103;&#111;&#111;&#x67;&#108;&#x65;&#x67;&#114;&#x6f;&#117;&#112;&#x73;&#46;&#99;&#x6f;&#109;&#93;&#40;&#41;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄</p>
</li>
</ol>
</blockquote>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<blockquote>
<blockquote>
<p>了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。</p>
</li>
</ol>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>--
Tinyfool的开发日记<a href="http://www.tinydust.net/dev/" target="_blank"><a href="http://www.tinydust.net/dev/">http://www.tinydust.net/dev/</a></a>
代码中国网<a href="http://www.codechina.org/" target="_blank"><a href="http://www.codechina.org">http://www.codechina.org</a></a>
myTwitter:<a href="http://twitter.com/tinyfool" target="_blank"><a href="http://twitter.com/tinyfool">http://twitter.com/tinyfool</a></a>
<a href="">显示删减掉的内容</a></p>
</blockquote>
<p><img src="" alt=""> Jeffrey Zhao <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>锟斤拷锟斤拷锟斤拷F/#锟斤拷锟斤拷锟斤拷锟斤拷锟揭伙拷锟斤拷锟斤拷诺姆锟绞斤拷锟绞碉拷锟紺SP锟侥★拷</p>
<p>锟斤拷锟斤拷锟斤拷锟斤拷锟节达拷锟斤拷院锟节诧拷锟斤拷锟斤拷锟斤拷锟较斤拷锟斤拷F/#锟狡广，锟斤拷锟斤拷锟斤拷</p>
<p>Jeffrey Zhao
Blog: <a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter: @jeffz_cn</p>
<hr>
<p>From: &quot;Googol Lee&quot; <a href="&#109;&#x61;&#x69;&#108;&#x74;&#111;&#58;&#91;&#103;&#111;&#111;&#x67;&#x2e;&#x2e;&#46;&#64;&#103;&#109;&#97;&#x69;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#40;&#x29;">&#91;&#103;&#111;&#111;&#x67;&#x2e;&#x2e;&#46;&#64;&#103;&#109;&#97;&#x69;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#40;&#x29;</a>
Sent: Monday, March 22, 2010 8:30 PM
To: &quot;TopLanguage&quot; <a href="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#x6f;&#x3a;&#x5b;&#x70;&#111;&#110;&#x2e;&#x2e;&#46;&#64;&#103;&#x6f;&#111;&#103;&#x6c;&#x65;&#x67;&#x72;&#x6f;&#117;&#112;&#x73;&#46;&#x63;&#111;&#109;&#93;&#40;&#x29;">&#x5b;&#x70;&#111;&#110;&#x2e;&#x2e;&#46;&#64;&#103;&#x6f;&#111;&#103;&#x6c;&#x65;&#x67;&#x72;&#x6f;&#117;&#112;&#x73;&#46;&#x63;&#111;&#109;&#93;&#40;&#x29;</a>
Subject: [TL] Re: {锟斤拷锟斤拷}{锟斤拷锟竭筹拷}实施锟斤拷锟叫憋拷痰锟斤拷锟斤拷锟较帮拷</p>
<blockquote>
<p>锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷......锟斤拷锟斤拷锟斤拷锟斤拷锟絞olang锟侥ｏ拷锟襟并凤拷IO锟斤拷锟斤拷csp模锟酵碉拷锟斤拷锟皆革拷锟阶ｏ拷</p>
<p>锟斤拷锟斤拷golang锟斤拷cpu锟杰硷拷锟侥诧拷锟斤拷锟较诧拷知锟斤拷效锟斤拷锟斤拷锟矫达拷锟斤拷锟斤拷锟节的憋拷锟斤拷锟斤拷锟斤拷锟斤拷erlang锟矫ｏ拷锟斤拷锟斤拷锟较诧拷锟斤拷c/c++</p>
<p>On Mar 22, 9:20 am, Tinyfool <a href="&#x6d;&#97;&#105;&#108;&#116;&#111;&#x3a;&#91;&#116;&#x69;&#x6e;&#121;&#102;&#x2e;&#x2e;&#x2e;&#64;&#103;&#x6d;&#97;&#x69;&#108;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#40;&#41;">&#91;&#116;&#x69;&#x6e;&#121;&#102;&#x2e;&#x2e;&#x2e;&#64;&#103;&#x6d;&#97;&#x69;&#108;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷模锟斤拷锟饺伙拷越锟斤拷冒锟斤拷锟斤拷锟剿ｏ拷锟斤拷也锟斤拷锟斤拷锟揭伙拷锟�</p>
<p>Mac OS X锟斤拷锟铰的诧拷锟叫伙拷锟狡斤拷锟斤拷GCD锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟街撅拷知锟斤拷锟睫憋拷强锟斤拷锟剿吧ｏ拷</p>
<p>锟斤拷锟斤拷支锟斤拷锟皆匡拷锟斤拷锟斤拷锟絆penCL也锟斤拷锟睫憋拷强锟襟啊★拷</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#109;&#x61;&#105;&#x6c;&#x74;&#x6f;&#58;&#x5b;&#x6a;&#x65;&#x2e;&#46;&#x2e;&#x40;&#108;&#x69;&#x76;&#x65;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#40;&#41;">&#x5b;&#x6a;&#x65;&#x2e;&#46;&#x2e;&#x40;&#108;&#x69;&#x76;&#x65;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#40;&#41;</a></p>
<blockquote>
<p> 锟斤拷锟斤拷锟斤拷锟斤拷妫猴拷锟斤拷瞬锟斤拷锌狻拷锟斤拷锟紽/#锟斤拷锟斤拷锟斤拷锟皆碉拷支锟街ｏ拷锟斤拷锟叫憋拷锟斤拷丫锟斤拷锟斤拷缀芏锟斤拷恕锟斤拷锟斤拷锟叫э拷剩锟街达拷锟叫э拷剩锟斤拷锟轿拷锟斤拷远锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟竭★拷</p>
<p>锟斤拷实锟斤拷锟斤拷&quot;锟斤拷锟斤拷&quot;锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷茫锟街灰拷锟脚ｏ拷税锟斤拷锟斤拷壮锟斤拷锟斤拷锟侥讹拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷装锟斤拷锟斤拷锟斤拷锟斤拷一锟斤拷锟斤拷锟矫的筹拷锟襟，对大部分筹拷锟斤拷员锟斤拷说锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷唷�</p>
<p>锟斤拷锟斤拷Memory Consistency锟斤拷锟斤拷JVM锟斤拷CLR锟斤拷锟斤拷锟节革拷CPU锟杰癸拷锟斤拷统一锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷没锟叫诧拷锟叫匡拷锟街э拷郑锟叫达拷锟斤拷谐锟斤拷锟斤拷丫锟斤拷锟斤拷锟斤拷锟斤拷珊芏锟斤拷恕锟�</p>
<p>锟斤拷锟节斤拷锟斤拷锟斤拷......锟揭撅拷锟斤拷锟斤拷实锟斤拷锟斤拷锟斤拷獾癸拷锟斤拷遣锟斤拷锟斤拷锟斤拷械模锟揭诧拷锟斤拷遣锟斤拷锟斤拷锟斤拷锟斤拷锟街的革拷祝锟斤拷锟斤拷牵锟斤拷锟斤拷冢锟斤拷锟斤拷锟斤拷锟矫伙拷锟斤拷锟斤拷吮锟斤拷锟斤拷锟矫★拷</p>
<p>锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷系锟结构锟斤拷锟斤拷锟斤拷系统锟饺等★拷锟斤拷锟斤拷然锟酵诧拷锟斤拷锟叫关ｏ拷锟斤拷也锟斤拷锟角诧拷锟斤拷锟斤拷锟叫的讹拷锟斤拷锟斤拷</p>
</blockquote>
</blockquote>
<p>&gt;</p>
<blockquote>
<blockquote>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#x6d;&#97;&#x69;&#x6c;&#x74;&#111;&#58;&#x5b;&#99;&#x68;&#101;&#x6e;&#103;&#x75;&#97;&#110;&#99;&#x68;&#x2e;&#46;&#x2e;&#64;&#x67;&#x6d;&#97;&#x69;&#x6c;&#46;&#x63;&#x6f;&#109;&#93;&#40;&#x29;">&#x5b;&#99;&#x68;&#101;&#x6e;&#103;&#x75;&#97;&#110;&#99;&#x68;&#x2e;&#46;&#x2e;&#64;&#x67;&#x6d;&#97;&#x69;&#x6c;&#46;&#x63;&#x6f;&#109;&#93;&#40;&#x29;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#109;&#x61;&#105;&#108;&#116;&#x6f;&#58;&#x5b;&#x70;&#x6f;&#110;&#46;&#46;&#46;&#64;&#x67;&#111;&#x6f;&#103;&#x6c;&#101;&#x67;&#114;&#x6f;&#117;&#112;&#x73;&#x2e;&#x63;&#x6f;&#109;&#93;&#40;&#x29;">&#x5b;&#x70;&#x6f;&#110;&#46;&#46;&#46;&#64;&#x67;&#111;&#x6f;&#103;&#x6c;&#101;&#x67;&#114;&#x6f;&#117;&#112;&#x73;&#x2e;&#x63;&#x6f;&#109;&#93;&#40;&#x29;</a>
/<em>Subject:/</em> [TL] {锟斤拷锟斤拷}{锟斤拷锟竭筹拷}实施锟斤拷锟叫憋拷痰锟斤拷锟斤拷锟较帮拷</p>
<p>锟斤拷锟节匡拷锟斤拷一篇锟斤拷锟斤拷Intel锟侥猴拷锟斤拷锟斤拷思锟侥凤拷锟斤拷锟斤拷锟铰ｏ拷锟斤拷锟斤拷锟结到锟斤拷锟斤拷锟斤拷45锟斤拷锟斤拷锟侥革拷锟斤拷司锟斤拷锟斤拷员/锟斤拷锟斤拷锟斤拷锟斤拷/战锟斤拷师锟斤拷锟斤拷&quot;什么锟斤拷实施锟斤拷锟叫憋拷痰锟斤拷锟斤拷锟斤拷
锟斤拷&quot;时锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷乇锟斤拷峒帮拷拇锟斤拷锟斤拷锟洁：锟斤拷锟斤拷锟斤拷锟斤拷(legacy code)锟斤拷锟斤拷锟斤拷(education)锟斤拷锟斤拷锟斤拷(tools)锟斤拷锟斤拷锟节猴拷锟斤拷锟狡的恐撅拷
(fear of many cores)锟皆硷拷锟斤拷维锟斤拷锟斤拷(maintainability)锟斤拷锟斤拷锟斤拷锟斤拷然锟斤拷一篇Intel
Parallel
Studio锟斤拷锟斤拷锟侥ｏ拷锟斤拷锟斤拷锟斤拷锟斤拷锟结及锟斤拷锟斤拷锟斤拷锟斤拷习锟饺达拷浅锟街碉拷锟斤拷锟斤拷郏锟斤拷锟斤拷锟斤拷锟斤拷叶锟斤拷锟斤拷锟斤拷锟较帮拷锟斤拷一些锟斤拷浅锟斤拷锟斤拷锟斤拷希锟斤拷锟斤拷锟斤拷一锟斤拷锟斤拷砖锟斤拷锟斤拷锟斤拷锟斤拷茫锟斤拷锟接拷锟揭革拷锟斤拷锟斤拷锟�
锟侥匡拷锟斤拷锟斤拷</p>
<p>( 注锟斤拷锟斤拷锟斤拷Google Group锟斤拷锟斤拷原锟侥碉拷一些锟斤拷锟斤拷锟接讹拷失效锟剿ｏ拷锟斤拷锟斤拷锟斤拷懈锟矫碉拷锟侥讹拷锟斤拷锟介，锟诫看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>锟斤拷锟斤拷锟斤拷锟斤拷
锟斤拷锟斤拷锟斤拷知锟斤拷锟斤拷锟叫伙拷实施锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷压锟剿撅拷锟斤拷锟叫╋拷锟斤拷锟斤拷锟斤拷锟斤拷锟叫伙拷锟斤拷100K~1000K锟侥达拷锟斤拷锟斤拷锟斤拷锟角筹拷锟斤拷锟斤拷斜锟教憋拷锟斤拷锟斤拷锟角非筹拷锟斤拷锟阶筹拷锟斤拷模锟�
一锟斤拷锟斤拷锟斤拷锟絛ata race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe锟饺碉拷锟斤拷锟斤拷锟斤拷锟斤拷锟揭伙拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟酵凤拷螅锟斤拷说要锟斤拷
效锟缴匡拷锟侥诧拷锟叫伙拷锟斤拷些锟接达拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷恕锟斤拷锟斤拷锟斤拷训锟斤拷呛芏锟斤拷锟斤拷锟斤拷锟斤拷牖癸拷斜锟叫达拷锟斤拷丫锟斤拷锟街帮拷锟斤拷牡锟阶拷筒锟饺拷锟斤拷锟斤拷猓拷锟斤拷锟斤拷锟斤拷锟窖╋拷霞锟剿拷锟斤拷映杀锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷通锟斤拷一
些锟斤拷锟斤拷谋锟斤拷锟斤拷锟�(锟斤拷锟斤拷Intel锟斤拷ICC)锟皆讹拷锟斤拷锟叫伙拷一些锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷省钱锟侥ｏ拷锟斤拷锟斤拷锟斤拷锟街凤拷锟斤拷锟斤拷锟斤拷缺锟捷撅拷锟斤拷锟斤拷锟斤拷Intel ICC锟斤拷锟斤拷锟皆讹拷锟酵憋拷锟斤拷锟斤拷
锟斤拷锟皆讹拷锟斤拷锟叫伙拷锟侥达拷锟斤拷浅锟斤拷伲锟斤拷佣锟斤拷锟斤拷锟斤拷锟斤拷峁╋拷锟斤拷锟斤拷锟斤拷呕锟斤拷浅锟斤拷锟斤拷蓿锟斤拷锟斤拷揖锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷芑锟斤拷speedup锟侥达拷锟斤拷也锟叫很讹拷约锟斤拷锟斤拷锟斤拷(锟斤拷锟斤拷loop锟斤拷循锟斤拷之锟斤拷
没锟斤拷dependence锟斤拷锟斤拷锟揭革拷loop应锟斤拷锟斤拷一锟斤拷锟斤拷锟斤拷锟饺碉拷)锟斤拷锟斤拷锟斤拷目前锟斤拷锟斤拷状锟斤拷锟角达拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟诫并锟斤拷锟斤拷锟斤拷效锟侥憋拷锟斤拷锟叫伙拷锟斤拷锟斤拷锟斤拷业锟侥角讹拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟�
锟斤拷一锟街斤拷锟斤拷锟斤拷锟斤拷锟斤拷诙锟绞憋拷锟斤拷诳锟斤拷倏煽锟斤拷锟酵拷锟绞凳╋拷锟斤拷谢锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟�%~30%锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷么锟斤拷锟斤拷丫锟斤拷锟轿拷锟剿撅拷锟绞★拷锟斤拷锟斤拷杀锟斤拷恕锟�</p>
</li>
<li><p>锟斤拷锟斤拷
锟节讹拷锟斤拷锟斤拷习锟斤拷锟斤拷芫锟斤拷浅锟斤拷锟皆比憋拷锟斤拷锟斤拷斜锟教凤拷锟斤拷慕锟斤拷锟斤拷恕锟斤拷锟绞碉拷锟斤拷斜锟斤拷锟窖撅拷锟叫讹拷锟斤拷十锟斤拷锟斤拷锟绞凤拷耍锟斤拷锟斤拷锟斤拷诙锟斤拷CPU锟斤拷锟斤拷之前锟斤拷些锟斤拷锟叫憋拷潭锟斤拷锟�&quot;专锟斤拷&quot;锟角碉拷锟斤拷
锟竭★拷锟斤拷时锟斤拷牟锟斤拷斜锟教达拷锟斤拷锟斤拷锟节硷拷群锟斤拷锟斤拷锟酵伙拷锟斤拷叻锟斤拷锟斤拷锟斤拷希锟酵拷锟組PI(message
passing model)锟斤拷锟斤拷SMP(锟皆称多处锟斤拷锟斤拷锟斤拷锟斤拷一
锟斤拷锟斤拷锟斤拷锟斤拷锟叫讹拷锟斤拷锟斤拷锟紺PU锟斤拷锟斤拷锟斤拷shared memory model)锟斤拷锟斤拷刹锟斤拷屑锟斤拷恪thread锟斤拷准锟斤拷1995锟疥建锟斤拷锟侥ｏ拷之锟斤拷锟斤拷锟斤拷锟�
Windows锟斤拷锟絎in32 thread锟斤拷锟斤拷锟斤拷锟街筹拷锟斤拷锟斤拷&quot;锟斤拷锟斤拷指锟斤拷&quot;锟斤拷锟斤拷锟斤拷data parallel模锟酵碉拷OpenMP(OpenMP 3.0锟斤拷
锟斤拷锟斤拷task parallel支锟斤拷)锟斤拷task parallel锟侥憋拷锟斤拷Click锟斤拷Intel锟斤拷Intel Thread
Building
Block(task parallel)锟斤拷Java 1.5锟斤拷始锟皆讹拷锟竭筹拷锟结供锟较好碉拷支锟斤拷(锟斤拷锟斤拷锟斤拷Java
Memory Model)锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷
GPU锟侥凤拷展锟斤拷Nvidia锟街匡拷始锟斤拷CUDA(data-parallel)锟斤拷Apple一锟斤拷锟斤拷锟皆ｏ拷锟斤拷锟叫憋拷锟斤拷院锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷业貌锟揭伙拷郑锟斤拷锟斤拷锟斤拷约锟斤拷锟斤拷锟脚�
锟剿革拷锟斤拷锟紺PU锟斤拷GPU锟斤拷媳锟教碉拷OpenCL锟斤拷微锟斤拷一锟斤拷也锟斤拷住锟斤拷也要锟斤拷锟斤拷Visual
Studio2010锟斤拷始锟斤拷C/#锟侥诧拷锟叫库，锟斤拷锟斤拷C++0x也
要锟斤拷锟斤拷锟斤拷叱锟街э拷郑锟斤拷锟斤拷锟斤拷锟斤拷瞎哦锟紼rlang也锟斤拷为锟斤拷锟斤拷支锟街诧拷锟叫憋拷锟斤拷锟斤拷锟饺筹拷锟斤拷锟斤拷之锟斤拷锟斤拷摩锟斤拷锟斤拷锟节达拷锟斤拷锟斤拷锟斤拷锟绞э拷锟斤拷锟斤拷业锟界都锟斤拷始锟斤拷锟斤拷锟斤拷锟叫憋拷谭锟斤拷锟�
展锟斤拷</p>
</li>
</ol>
<p>锟斤拷锟角对筹拷锟斤拷员锟斤拷说锟斤拷锟斤拷什么锟斤拷锟斤拷兀锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟杰的斤拷锟斤拷蠖蓟锟斤拷谴锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷些锟姐法锟斤拷锟斤拷萁峁癸拷锟斤拷叩锟斤拷锟斤拷锟揭黄拷锟教革拷锟剿�&quot;锟斤拷锟揭匡拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟�
锟斤拷硬锟斤拷锟斤拷锟斤拷锟斤拷丫锟斤拷藜瓶锟绞╋拷说锟斤拷碌模锟斤拷锟斤拷墙锟組oore锟斤拷锟斤拷失效锟斤拷锟斤拷锟斤拷锟斤拷锟窖革拷锟斤拷锟斤拷锟斤拷锟斤拷撸锟斤拷锟斤拷锟斤拷歉锟斤拷锟斤拷堑幕锟斤拷锟街伙拷锟斤拷锟侥承┲革拷锟斤拷锟斤拷锟斤拷械酶锟斤拷锟剿讹拷锟窖★拷锟斤拷锟斤拷锟斤拷
锟教碉拷锟诫法锟斤拷证锟斤拷锟斤拷失锟杰的ｏ拷锟斤拷一锟姐都锟斤拷锟斤拷械锟斤拷锟斤拷锟�......锟斤拷锟斤拷说锟斤拷锟叫讹拷锟劫筹拷锟斤拷员锟斤拷锟斤拷锟斤拷未锟斤拷一片锟斤拷锟斤拷锟侥伙拷锟斤拷锟斤拷锟斤拷强锟揭碉拷锟斤拷趣锟斤拷锟揭硷拷锟斤拷没锟斤拷锟斤拷说锟斤拷锟斤拷锟斤拷锟斤拷堑锟斤拷呖唷�
锟斤拷锟斤拷锟斤拷锟斤拷学院锟斤拷些锟斤拷硬锟斤拷锟侥家伙拷一直锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟角达拷锟�&quot;锟斤拷锟缴硷拷硬锟斤拷锟斤拷展锟斤拷锟斤拷锟斤拷锟斤拷转锟斤拷直锟接碉拷锟铰筹拷锟斤拷员锟斤拷锟斤拷训锟斤拷锟斤拷锟窖撅拷锟斤拷锟斤拷锟剿★拷锟斤拷么锟斤拷锟斤拷员锟斤拷锟斤拷锟杰碉拷锟斤拷锟矫碉拷
锟斤拷锟叫憋拷探锟斤拷锟斤拷锟斤拷穑亢锟斤拷锟饺伙拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷一锟斤拷锟斤拷通锟侥筹拷锟斤拷员锟斤拷&quot;锟斤拷锟斤拷貌锟斤拷斜锟斤拷锟斤拷锟斤拷么锟斤拷&quot;锟斤拷十锟叫八九伙拷说&quot;锟揭撅拷锟矫猴拷锟斤拷&quot;锟斤拷前一锟斤拷锟斤拷锟斤拷锟斤拷锟桔凤拷锟斤拷锟斤拷锟斤拷锟斤拷枚锟斤拷叱锟�
锟矫伙拷锟角讹拷锟教好ｏ拷锟斤拷实锟斤拷原锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷露锟斤拷叱锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷疲锟斤拷锟斤拷锟絠solation锟侥讹拷锟斤拷模式锟斤拷锟斤拷programming productivity
锟斤拷performance之锟斤拷锟揭碉拷锟饺较好碉拷锟斤拷锟皆ｏ拷锟斤拷锟皆癸拷锟节猴拷锟叫凤拷锟斤拷锟斤拷锟斤拷锟斤拷锟竭讹拷选锟斤拷锟剿讹拷锟斤拷(锟斤拷锟斤拷锟狡凤拷)锟斤拷锟接达拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟叫撅拷锟斤拷系锟斤拷模锟斤拷锟斤拷锟叫�
OS/Compiler锟侥ｏ拷锟斤拷锟角讹拷锟斤拷锟斤拷锟斤拷锟皆的ｏ拷锟斤拷锟节讹拷锟节伙拷努锟斤拷锟斤拷为锟斤拷锟侥筹拷锟斤拷员锟结供一锟斤拷锟斤拷锟斤拷锟斤拷使锟矫的诧拷锟叫憋拷锟侥ｏ拷停锟絀ntel锟解几锟疥不也锟节革拷锟斤拷锟斤拷
训么锟斤拷锟解都锟角猴拷锟斤拷锟襟，碉拷锟角ｏ拷锟斤拷锟斤拷锟斤拷锟饺拷锟斤拷斜锟斤拷时锟斤拷锟斤拷锟洁当锟斤拷锟斤拷路要锟竭★拷锟斤拷锟斤拷锟絀T锟斤拷锟斤拷锟斤拷锟斤拷锟介单锟斤拷锟斤拷锟斤拷锟斤拷胁锟斤拷斜锟教碉拷锟介籍锟斤拷锟角革拷锟杰好碉拷写锟秸★拷</p>
<ol>
<li>锟斤拷锟斤拷
锟斤拷锟斤拷锟斤拷锟斤拷锟铰ｏ拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷么锟街阶讹拷锟斤拷锟斤拷锟斤拷锟矫的ｏ拷锟斤拷锟揭猴拷锟矫的诧拷锟叫憋拷坦锟斤拷锟斤拷卸锟斤拷锟斤拷兀锟斤拷锟接拷锟揭诧拷锟戒）锟斤拷</li>
</ol>
<p>(1) IDE: Intel Parallel Studio锟斤拷微锟斤拷锟斤拷锟较筹拷锟斤拷锟斤拷VS2010锟斤拷一锟斤拷锟斤拷Sun锟斤拷Sun
Studio(锟斤拷知锟斤拷锟斤拷锟轿达拷锟斤拷锟�
锟轿ｏ拷锟斤拷锟斤拷锟斤拷锟斤拷锟酵猴拷小锟斤拷)锟斤拷Nvidia锟斤拷CUDA平台什么锟侥撅拷锟饺诧拷锟斤拷锟斤拷
(2) Compiler: Intel锟斤拷ICC(锟斤拷锟皆讹拷锟斤拷锟叫伙拷一些锟斤拷锟斤拷)锟斤拷Nema Labs锟斤拷FASThread(锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟侥斤拷锟斤拷锟斤拷锟斤拷锟斤拷芸锟斤拷锟�
锟缴匡拷锟斤拷指锟斤拷锟斤拷锟斤拷员实施锟斤拷锟叫伙拷)
(3) Performance Tuning: Intel Vtune Analyzer(锟桔猴拷锟斤拷锟杰凤拷锟斤拷)锟斤拷Thread
profiler锟斤拷
Acumem锟斤拷Thread Spotter(锟斤拷远锟斤拷Cache锟斤拷锟斤拷锟杰凤拷锟斤拷锟斤拷锟脚伙拷)
(4) Debugging: Petra锟斤拷Jinx</p>
<p>锟斤拷锟斤拷锟斤拷锟揭革拷锟剿撅拷锟斤拷锟斤拷锟角对筹拷锟斤拷员锟斤拷说确实锟斤拷锟矫ｏ拷锟斤拷锟斤拷前锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷要锟斤拷锟矫★拷锟斤拷锟斤拷实锟街革拷诙锟斤拷锟�&quot;锟斤拷锟斤拷&quot;锟叫很达拷锟较碉拷恕锟�</p>
<ol>
<li><p>锟斤拷锟节核的恐撅拷
锟斤拷锟斤拷锟斤拷锟角匡拷锟斤拷4锟斤拷锟窖撅拷锟角筹拷锟秸憋拷锟剿ｏ拷锟饺癸拷锟斤拷锟角可撅拷锟斤拷8锟剿ｏ拷16锟剿ｏ拷32锟斤拷锟剿★拷锟斤拷锟斤拷确锟斤拷锟斤拷拇锟斤拷锟斤拷诤锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷泻芎玫锟斤拷锟斤拷埽锟斤拷芎玫目锟斤拷锟斤拷锟斤拷裕锟斤拷锟�
锟斤拷锟斤拷歉锟斤拷锟斤拷狻ｏ拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷芯锟斤拷锟斤拷嵌锟斤拷叱坛锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟杰凤拷锟斤拷锟斤拷目锟侥撅拷锟斤拷为锟剿帮拷锟斤拷锟斤拷锟皆憋拷锟矫的斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟缴碉拷锟斤拷锟斤拷瓶锟斤拷锟斤拷实锟斤拷锟较ｏ拷为锟剿得碉拷锟杰好碉拷
锟斤拷锟斤拷锟斤拷锟皆ｏ拷锟斤拷锟斤拷员锟斤拷要锟斤拷锟斤拷锟斤拷要使锟矫诧拷锟斤拷锟窖好碉拷锟斤拷萁峁�(锟斤拷锟斤拷concurrent hash
map)锟斤拷使锟斤拷细锟斤拷锟饺碉拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟教ｏ拷锟斤拷锟絛ata
parallel锟斤拷锟姐法锟斤拷锟斤拷锟杰碉拷锟斤拷(锟斤拷锟斤拷锟斤拷偷锟絝alse sharing锟斤拷锟斤拷)锟饺等等等ｏ拷锟斤拷锟斤拷锟斤拷每一锟筋都锟角诧拷小锟斤拷锟斤拷战锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷一篇锟斤拷锟铰讹拷锟斤拷锟�
锟斤拷锟竭程筹拷锟斤拷锟结供锟斤拷一些锟斤拷锟矫的斤拷锟介。</p>
</li>
<li><p>锟斤拷维锟斤拷锟斤拷
锟斤拷锟斤拷锟斤拷锟绞ｏ拷锟斤拷锟斤拷希锟斤拷锟叫达拷锟斤拷锟杰癸拷锟斤拷锟街达拷锟絩untime系统锟斤拷build系统锟皆硷拷锟斤拷锟斤拷锟斤拷锟叫达拷锟斤拷一锟斤拷锟斤拷确锟侥癸拷锟斤拷锟斤拷锟斤拷锟角革拷希锟斤拷锟斤拷些锟斤拷锟叫达拷锟斤拷锟斤拷锟斤拷锟斤拷狻拷锟斤拷锟轿�
锟斤拷锟斤拷锟斤拷锟叫较筹拷锟斤拷锟斤拷锟斤拷锟斤拷锟节★拷锟斤拷锟斤拷锟街阶讹拷锟斤拷锟斤拷锟斤拷锟秸诧拷锟叫憋拷痰某锟斤拷锟皆憋拷锟街拷锟斤拷伲锟斤拷锟斤拷也锟斤拷斜锟斤拷锟斤拷锟斤拷锟斤拷么锟斤拷锟窖ｏ拷锟斤拷锟斤拷锟斤拷锟斤拷锟叫╋拷锟斤拷写锟斤拷锟街伙拷锟斤拷锟揭恍┬⌒★拷母亩锟斤拷锟斤拷锟斤拷锌锟�
锟杰碉拷锟斤拷锟铰碉拷bug锟斤拷锟铰碉拷锟斤拷锟斤拷瓶锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟揭伙拷锟斤拷浅锟酵达拷锟斤拷锟斤拷锟介。</p>
</li>
</ol>
</blockquote>
</blockquote>
<p>&gt;</p>
<blockquote>
<blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE
ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>--
Tinyfool锟侥匡拷锟斤拷锟秸硷拷<a href="http://www.tinydust.net/dev/" target="_blank"><a href="http://www.tinydust.net/dev/">http://www.tinydust.net/dev/</a></a>
锟斤拷锟斤拷锟叫癸拷锟斤拷<a href="http://www.codechina.org/" target="_blank"><a href="http://www.codechina.org">http://www.codechina.org</a></a>
myTwitter:<a href="http://twitter.com/tinyfool" target="_blank"><a href="http://twitter.com/tinyfool">http://twitter.com/tinyfool</a></a></p>
</blockquote>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>To unsubscribe from this group, send email to
pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
<p><a href="">显示删减掉的内容</a>
<img src="" alt=""> Lai Jiangshan <img src="" alt=""></p>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>由于内存/cache模型和编译器/cpu的优化, 并行化是不可能通过库来实现的.
我认为最大的障碍是支持并行化的语言.
2010/3/22 Guancheng Chen <a href="&#x6d;&#x61;&#105;&#108;&#x74;&#111;&#x3a;&#91;&#99;&#104;&#101;&#x6e;&#x67;&#x75;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#105;&#x6c;&#46;&#99;&#111;&#109;&#x5d;&#40;&#41;">&#91;&#99;&#104;&#101;&#x6e;&#x67;&#x75;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#105;&#x6c;&#46;&#99;&#111;&#109;&#x5d;&#40;&#41;</a></p>
<ol>
<li>C语言可以使用pthread等库实现并行化，C++ JAVA等已经会即将支持多线程 所以语言能实现并行化 只是难易问题</li>
<li>是指Shared memory模型，多核共享一条内存总线所以造成带宽问题么？这确实是个问题，不过我感觉硬件商家会负责为你带来越来越多的带
宽，而程序员的任务只是合理的利用好这些给定的带宽</li>
<li>能具体说说哪些误导宣传么？
On 3月22日, 上午1时46分, 陨落雕 <a href="&#109;&#x61;&#105;&#x6c;&#116;&#x6f;&#58;&#91;&#103;&#101;&#111;&#46;&#x2e;&#x2e;&#x2e;&#64;&#103;&#109;&#x61;&#105;&#108;&#46;&#99;&#x6f;&#x6d;&#93;&#40;&#41;">&#91;&#103;&#101;&#111;&#46;&#x2e;&#x2e;&#x2e;&#64;&#103;&#109;&#x61;&#105;&#108;&#46;&#99;&#x6f;&#x6d;&#93;&#40;&#41;</a> wrote:<blockquote>
<p>呃，我想的障碍是: 1. 类C语言的统治地位; 2. 内存带宽不够; 3. 误导性宣传;</p>
</blockquote>
</li>
</ol>
<p>&gt;</p>
<blockquote>
<p>On Mar 21, 7:37 pm, Guancheng Chen <a href="&#109;&#97;&#105;&#108;&#x74;&#111;&#58;&#x5b;&#99;&#104;&#101;&#110;&#103;&#x75;&#x61;&#x6e;&#99;&#104;&#46;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#x61;&#105;&#108;&#x2e;&#99;&#111;&#109;&#93;&#40;&#x29;">&#x5b;&#99;&#104;&#101;&#110;&#103;&#x75;&#x61;&#x6e;&#99;&#104;&#46;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#x61;&#105;&#108;&#x2e;&#99;&#111;&#109;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看<a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..</p>
</blockquote>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<blockquote>
<blockquote>
<p>)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a></p>
</li>
</ol>
</blockquote>
</blockquote>
<p><img src="" alt=""> Jeffrey Zhao <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>能详细说说为什么“由于内存/cache模型和编译器/cpu的优化, 并行化是不可能通过库来实现的”吗？</p>
<p>Jeffrey Zhao
Blog: <a href="http://www.cnblogs.com/JeffreyZhao/" title="http://www.cnblogs.com/JeffreyZhao/
CTRL + Click to follow link"><a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter: @jeffz_cn
<strong>From:</strong> <a href="&quot;mailto:eag0628@gmail.com
CTRL + Click to follow link&quot;">Lai Jiangshan</a></p>
<p><strong>Sent:</strong> Monday, March 22, 2010 10:17 PM
<strong>To:</strong> <a href="&quot;mailto:pongba@googlegroups.com
CTRL + Click to follow link&quot;">pon...@googlegroups.com</a></p>
<p><strong>Subject:</strong> Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>由于内存/cache模型和编译器/cpu的优化, 并行化是不可能通过库来实现的.
我认为最大的障碍是支持并行化的语言.
2010/3/22 Guancheng Chen <a href="&#x6d;&#x61;&#105;&#x6c;&#116;&#x6f;&#58;&#x5b;&#99;&#104;&#x65;&#110;&#x67;&#117;&#x2e;&#x2e;&#46;&#x40;&#103;&#109;&#97;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#x29;">&#x5b;&#99;&#104;&#x65;&#110;&#x67;&#117;&#x2e;&#x2e;&#46;&#x40;&#103;&#109;&#97;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#x29;</a></p>
<ol>
<li>C语言可以使用pthread等库实现并行化，C++ JAVA等已经会即将支持多线程 所以语言能实现并行化 只是难易问题</li>
<li>是指Shared memory模型，多核共享一条内存总线所以造成带宽问题么？这确实是个问题，不过我感觉硬件商家会负责为你带来越来越多的带
宽，而程序员的任务只是合理的利用好这些给定的带宽</li>
<li>能具体说说哪些误导宣传么？
On 3月22日, 上午1时46分, 陨落雕 <a href="&#x6d;&#97;&#x69;&#108;&#x74;&#x6f;&#58;&#x5b;&#103;&#x65;&#111;&#x2e;&#x2e;&#x2e;&#46;&#x40;&#x67;&#x6d;&#97;&#x69;&#108;&#x2e;&#99;&#x6f;&#109;&#93;&#40;&#41;">&#x5b;&#103;&#x65;&#111;&#x2e;&#x2e;&#x2e;&#46;&#x40;&#x67;&#x6d;&#97;&#x69;&#108;&#x2e;&#99;&#x6f;&#109;&#93;&#40;&#41;</a> wrote:<blockquote>
<p>呃，我想的障碍是: 1. 类C语言的统治地位; 2. 内存带宽不够; 3. 误导性宣传;</p>
<p>On Mar 21, 7:37 pm, Guancheng Chen <a href="&#109;&#x61;&#x69;&#x6c;&#x74;&#111;&#58;&#91;&#x63;&#x68;&#101;&#110;&#103;&#x75;&#x61;&#110;&#x63;&#x68;&#x2e;&#x2e;&#46;&#x40;&#x67;&#109;&#x61;&#105;&#x6c;&#46;&#x63;&#111;&#109;&#93;&#40;&#x29;">&#91;&#x63;&#x68;&#101;&#110;&#103;&#x75;&#x61;&#110;&#x63;&#x68;&#x2e;&#x2e;&#46;&#x40;&#x67;&#109;&#x61;&#105;&#x6c;&#46;&#x63;&#111;&#109;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看<a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
</li>
</ol>
</blockquote>
</blockquote>
</li>
</ol>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>您值得是那篇著名的“Threads Cannot be Implemented as a Library”吧？恩，好用的并行语言确实关键，虽然
C++0x和Java都会加入memory model，但是要程序员来手动负责这些事情确实还是挺约束生产力的。</p>
<p>On 3月22日, 下午3时17分, Lai Jiangshan <a href="&#x6d;&#97;&#x69;&#108;&#116;&#x6f;&#x3a;&#91;&#101;&#x61;&#103;&#x30;&#x2e;&#46;&#46;&#64;&#103;&#109;&#x61;&#x69;&#108;&#x2e;&#x63;&#111;&#109;&#93;&#40;&#x29;">&#91;&#101;&#x61;&#103;&#x30;&#x2e;&#46;&#46;&#64;&#103;&#109;&#x61;&#x69;&#108;&#x2e;&#x63;&#111;&#109;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>由于内存/cache模型和编译器/cpu的优化, 并行化是不可能通过库来实现的.</p>
<p>我认为最大的障碍是支持并行化的语言.</p>
<p>2010/3/22 Guancheng Chen <a href="&#109;&#x61;&#x69;&#108;&#x74;&#111;&#x3a;&#x5b;&#x63;&#104;&#x65;&#110;&#x67;&#117;&#x61;&#x6e;&#99;&#x68;&#46;&#x2e;&#46;&#x40;&#x67;&#x6d;&#x61;&#x69;&#108;&#46;&#x63;&#111;&#x6d;&#x5d;&#40;&#41;">&#x5b;&#x63;&#104;&#x65;&#110;&#x67;&#117;&#x61;&#x6e;&#99;&#x68;&#46;&#x2e;&#46;&#x40;&#x67;&#x6d;&#x61;&#x69;&#108;&#46;&#x63;&#111;&#x6d;&#x5d;&#40;&#41;</a></p>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>&gt;
&gt;
&gt;</p>
<blockquote>
<blockquote>
<ol>
<li>C语言可以使用pthread等库实现并行化，C++ JAVA等已经会即将支持多线程 所以语言能实现并行化 只是难易问题</li>
<li>是指Shared memory模型，多核共享一条内存总线所以造成带宽问题么？这确实是个问题，不过我感觉硬件商家会负责为你带来越来越多的带
宽，而程序员的任务只是合理的利用好这些给定的带宽</li>
<li>能具体说说哪些误导宣传么？</li>
</ol>
<p>On 3月22日, 上午1时46分, 陨落雕 <a href="&#109;&#x61;&#x69;&#x6c;&#x74;&#x6f;&#x3a;&#91;&#x67;&#101;&#111;&#46;&#46;&#46;&#46;&#x40;&#x67;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#111;&#x6d;&#93;&#x28;&#x29;">&#91;&#x67;&#101;&#111;&#46;&#46;&#46;&#46;&#x40;&#x67;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#111;&#x6d;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>呃，我想的障碍是: 1. 类C语言的统治地位; 2. 内存带宽不够; 3. 误导性宣传;</p>
<p>On Mar 21, 7:37 pm, Guancheng Chen <a href="&#x6d;&#97;&#105;&#x6c;&#116;&#111;&#x3a;&#91;&#x63;&#104;&#x65;&#x6e;&#x67;&#x75;&#97;&#x6e;&#99;&#x68;&#46;&#x2e;&#x2e;&#x40;&#x67;&#109;&#x61;&#x69;&#x6c;&#x2e;&#99;&#111;&#109;&#93;&#x28;&#41;">&#91;&#x63;&#104;&#x65;&#x6e;&#x67;&#x75;&#97;&#x6e;&#99;&#x68;&#46;&#x2e;&#x2e;&#x40;&#x67;&#109;&#x61;&#x69;&#x6c;&#x2e;&#99;&#111;&#109;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看
<a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线</p>
</blockquote>
</blockquote>
<p>程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。</p>
<blockquote>
<blockquote>
<p>尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。</p>
</li>
</ol>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
<a href="">显示删减掉的内容</a></p>
</blockquote>
</blockquote>
<p><img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>主要就是那篇《Threads Cannot be Implemented as a Library》的论文，跟我以前发帖说的
Sequential Consistency，memory model有关</p>
<p>On 3月22日, 下午3时38分, &quot;Jeffrey Zhao&quot; <a href="&#109;&#x61;&#x69;&#x6c;&#x74;&#x6f;&#58;&#91;&#106;&#x65;&#x2e;&#46;&#x2e;&#x40;&#108;&#105;&#118;&#101;&#46;&#99;&#111;&#x6d;&#93;&#x28;&#x29;">&#91;&#106;&#x65;&#x2e;&#46;&#x2e;&#x40;&#108;&#105;&#118;&#101;&#46;&#99;&#111;&#x6d;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>能详细说说为什么&quot;由于内存/cache模型和编译器/cpu的优化, 并行化是不可能通过库来实现的&quot;吗？</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter: @jeffz_cn</p>
<p>From: Lai Jiangshan
Sent: Monday, March 22, 2010 10:17 PM
To: <a href="">pon...@googlegroups.com</a>
Subject: Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>由于内存/cache模型和编译器/cpu的优化, 并行化是不可能通过库来实现的.</p>
<p>我认为最大的障碍是支持并行化的语言.</p>
<p>2010/3/22 Guancheng Chen <a href="&#109;&#x61;&#105;&#108;&#x74;&#111;&#x3a;&#91;&#99;&#x68;&#101;&#x6e;&#x67;&#x75;&#97;&#110;&#x63;&#x68;&#x2e;&#46;&#46;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#x6f;&#x6d;&#93;&#x28;&#41;">&#91;&#99;&#x68;&#101;&#x6e;&#x67;&#x75;&#97;&#110;&#x63;&#x68;&#x2e;&#46;&#46;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#x6f;&#x6d;&#93;&#x28;&#41;</a></p>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>&gt;</p>
<blockquote>
<ol>
<li>C语言可以使用pthread等库实现并行化，C++ JAVA等已经会即将支持多线程 所以语言能实现并行化 只是难易问题</li>
<li>是指Shared memory模型，多核共享一条内存总线所以造成带宽问题么？这确实是个问题，不过我感觉硬件商家会负责为你带来越来越多的带
宽，而程序员的任务只是合理的利用好这些给定的带宽</li>
<li><p>能具体说说哪些误导宣传么？</p>
<p>On 3月22日, 上午1时46分, 陨落雕 <a href="&#109;&#97;&#x69;&#x6c;&#x74;&#111;&#x3a;&#x5b;&#103;&#x65;&#111;&#x2e;&#x2e;&#46;&#46;&#x40;&#103;&#x6d;&#97;&#105;&#108;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#x28;&#41;">&#x5b;&#103;&#x65;&#111;&#x2e;&#x2e;&#46;&#46;&#x40;&#103;&#x6d;&#97;&#105;&#108;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>呃，我想的障碍是: 1. 类C语言的统治地位; 2. 内存带宽不够; 3. 误导性宣传;</p>
<p>On Mar 21, 7:37 pm, Guancheng Chen <a href="&#x6d;&#97;&#105;&#x6c;&#116;&#111;&#x3a;&#91;&#x63;&#x68;&#101;&#110;&#103;&#117;&#97;&#x6e;&#x63;&#x68;&#x2e;&#46;&#46;&#64;&#x67;&#109;&#x61;&#105;&#x6c;&#x2e;&#99;&#111;&#109;&#x5d;&#40;&#x29;">&#91;&#x63;&#x68;&#101;&#110;&#103;&#117;&#97;&#x6e;&#x63;&#x68;&#x2e;&#46;&#46;&#64;&#x67;&#109;&#x61;&#105;&#x6c;&#x2e;&#99;&#111;&#109;&#x5d;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看<a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。</p>
</li>
</ol>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
</li>
</ol>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> Alleluia <img src="" alt=""></p>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>no no.其实Concurrency和Parallelism完全是两码事情,IO来区分它们其实完全是从最基本的体系结构上来说就是如此的.你把
IO理解为网络通信,磁盘读写就太狭隘了.
比如看这个图
<a href="http://ian--king.javaeye.com/upload/picture/pic/57449/40915ec8-f578-3398-9931-1afa4364a2b9.jpg" target="_blank"><a href="http://ian--king.javaeye.com/upload/picture/pic/57449/40915ec8-f578-3398-9931-1afa4364a2b9.jpg">http://ian--king.javaeye.com/upload/picture/pic/57449/40915ec8-f578-3398-9931-1afa4364a2b9.jpg</a></a>
,我们要计算一个ax^2+bx+c的一元二次方程,左边的是并行计算,右边的是顺序计算.这两者完全就是两个体系结构,我们现在所使用的计算机是右边
那个图是由Control Flow Drive的.左边是Data Flow Drive的是典型的并行计算机的结构.其中最大的区别就是,右边的架
构采用了PC指针和Assignment.Assignment本身不是一个计算过程,仅仅是一次IO操作,从存储器里拿出数据/程序灌入运算器或者相
反.那么Assignment跟Concurrency有什么关系呢?为了响应Assigment这种基础的IO,那么冯结构必须依靠CPU时钟来驱动
PC指针的移动.因此控制流驱动模式构成了CPU响应外界IO的最基本的模式.无论是内存还是磁盘或者网络,CPU要获取外部设备的IO最基本模式,只
能是通过本地时钟触发控制流，周期性发起状态查询.CPU在某个周期向其他设备发送信号，在收到远端设备的反馈信号后计算得出本地代码序列上的程序段地
址,然后移动PC指针指向该地址进行处理。无论是早期的轮询模式还是现在广泛采用的中断方式，其基本的IO模式并没有改变,只不过查询对象由最初的IO
设备演变为中断寄存器.
因此你可以看到,Concurrency其实只是在讨论如何能够利用外设信号与CPU时钟之间的差异,让CPU在一定的时钟周期内尽可能多的响应不同外
设信号。一个通常的程序仅仅只需要通过Assigment响应内存IO,而Concurrency程序需要相应成千上万个外部设备,这仅仅是量上的区别
并没有到任何质上的区别,Concurrency程序本质上仍然是一个顺序执行的程序而已.采用恰当的技术比如完成端口之类的,可以在单核CPU机器上
仅仅采用单线程模型就能得到极高的并发性.当然多核同时处理可以进一步提高并发量,但是这不是必须的.
换一句话说,目前的CPU架构本身就是一种具备了Concurrency能力的顺序型架构.甚至在当初冯诺伊曼设计这个架构的时候,就极力杜绝并行计算
的指令在这种机器上出现在程序里,因为他认为并行执行的指令会让人发疯.而你再看右边的计算机构,与冯结构完全不同.他的计算是彻底并行的,这就是所谓
的数据流驱动.虽然说冯结构本身不利于并行,但是这个体系发展到现在,已经在不同层面上用冯结构模拟数据流计算.往小里说,CPU上最典型的顺序型程序
在微指令层面上有很大一部分就是数据流驱动并行执行的,因为要做OOO.往大了说,并行在若干个独立内核上的线程组之间的互相通信,也是一种数据流驱
动.并行必定是数据流驱动的.这是两者本质上的不同.如果你去看GPU上的并行就更接近这个模型,所有的计算都是分成若干个stage,数据依次从
stage上流过,stage上的并行计算单元对数据进行高密度的并行计算.这就是所谓的流处理器.当然现在的流处理器还是非常的简单,未来的GPU会
像Dataflow machine的方向发展.当然DataFlow machine也有自己的问题，比如说的指令牌粒度太小了，这导致两个重要缺
点，一个是通信代价非常高，另一个是指令牌点火代价很高。而Standford的ImagineGPU流处理器引擎可以看作介于数据流机和指令流机之间
的架构，所作的一个重要权衡就是增加指令牌的粒度，从而减小点火代价和利用赠大的Token粒度去减小通信代价</p>
<p>至于粒度问题,关键是看你的计算资源有多少.比如说CPU目前最多8核,16核.那么你所谓的按照循环来进行并行自然是可行的,但是你放到CUDA上
去,GTX295有250个内核,你为了让他所有的内核处于工作繁忙的状态,就根本不可能按照循环层次来进行并行,在这个上面并行的粒度是需要划分的极
为纤细的。更诡异的是有些算法,处理的数据量很小,但是计算量可能极为庞大.比如一些运动估计算法,在一个16/*16的像素区域内要完成256×256
次sad运算.这种数据量和计算完全非常不成比例的.怎么对并行粒度的进行有效的划分,非常考算法功夫的.并行计算最好是通过算法杜绝锁,这也是非常困
难的地方.</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>On 3月22日, 下午7时04分, Guancheng Chen <a href="&#109;&#x61;&#x69;&#x6c;&#116;&#x6f;&#x3a;&#x5b;&#99;&#104;&#x65;&#110;&#103;&#x75;&#x61;&#110;&#99;&#104;&#46;&#x2e;&#x2e;&#64;&#x67;&#109;&#x61;&#105;&#x6c;&#x2e;&#99;&#111;&#x6d;&#93;&#40;&#x29;">&#x5b;&#99;&#104;&#x65;&#110;&#103;&#x75;&#x61;&#110;&#99;&#104;&#46;&#x2e;&#x2e;&#64;&#x67;&#109;&#x61;&#105;&#x6c;&#x2e;&#99;&#111;&#x6d;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>您的观点很有新意，我以前没有过用IO来区分Concurrency和Parallelism的想法，我猜测可能跟您的网络/通信背景有关。其实我觉得
从广义上来讲Parallelism和Concurrency是基本重合的两个概念，只不过可能Concurrency稍微偏工程一点，
Parallelism稍微偏研究一点。例如Herb Sutter要出的新书叫Effective Concurrency,而市面上其他讲并行计算
的书不少也使用Parallel相关的词汇。</p>
<p>另外您这句话我有些不赞同：&quot;颗粒度越小的并行获得的计算资源的利用率也就越大加速比就越大&quot;，拿一个计算密集型的嵌套循环举例，对比并行外层循环和并
行内层循环，无疑你在并行化外层循环时的性能加速比更好，而这时候你的并行度是粗粒度的(内循环并行相对来说是细粒度的)。当然，粗/细粒度的选择确实
是个tradeoff，拿锁竞争来说，细粒度的锁意味着更好的Scalability，但是你加锁/解锁的次数相比组粒度所来说增加了，而这种加锁/解
锁的操作是有开销的，所以需要在锁操作本身的开销和程序的Scalability中做一个平衡。</p>
<p>多谢指教！</p>
<p>On 3月22日, 上午10时19分, Alleluia <a href="&#109;&#97;&#x69;&#108;&#x74;&#x6f;&#x3a;&#91;&#97;&#x6c;&#108;&#117;&#108;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#109;&#x61;&#105;&#108;&#46;&#99;&#111;&#109;&#93;&#40;&#x29;">&#91;&#97;&#x6c;&#108;&#117;&#108;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#109;&#x61;&#105;&#108;&#46;&#99;&#111;&#109;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>Concurrency 说到底纯粹就是一个IO问题.而IO问题本质上是和计算完全无关的事情,不存在能不能行可不可计算的问题.因此它相对来说非常
单纯。他更多的是一种类似时钟同步的问题,如果你把IO事件想像成一种时钟信号.其实时钟本来也就是一堆信号而已.如果你做过Circuit 的东西就
会明白,IO只是在不同的时序下进行数据采样.比如最简单的同步时钟,所有的时序电路公用一个时钟,把不同的电路安排在不同的时序边沿上触发.当然更复
杂异步逻辑的道理也是一样的.放到宏观的Concurrency的问题的实质并没有多大改变,只不过CPU依靠PC指针的移动把这种电路上的时序处理软
件化了.</p>
<p>而Parallelism更多的是需要考虑计算问题同时还要兼顾IO.Parallelism首先要回答的是一个东西是不是可并行的.回答完这个问题
后,如果可并行那么在什么样的硬件设备上并行是最合适的这样一个问题.在Parallelism中需要考虑的的IO也不仅仅是来自于网络更多是,缓存,
内存,磁盘,总线等等.其实我觉得,在Parallelism下你总是处于一个矛盾状态,颗粒度越小的并行获得的计算资源的利用率也就越大加速比就越
大,但是同时通信系统的工作也就越是繁忙整个运算过程浪费在通信消耗上的时间也就越多.
这个当中的tradeoff是非常困难的.很多时候速度不快,完全不是因为你的核心不够多,而是你的通信速度不够高.</p>
<p>On 3月22日, 下午3时21分, Guancheng Chen <a href="&#109;&#x61;&#x69;&#x6c;&#x74;&#x6f;&#58;&#91;&#x63;&#104;&#101;&#110;&#x67;&#x75;&#x61;&#110;&#99;&#x68;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#109;&#97;&#105;&#x6c;&#46;&#99;&#x6f;&#x6d;&#93;&#x28;&#x29;">&#91;&#x63;&#104;&#101;&#110;&#x67;&#x75;&#x61;&#110;&#99;&#x68;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#109;&#97;&#105;&#x6c;&#46;&#99;&#x6f;&#x6d;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>绝大部分的观点Can&#39;t agree more.其实这也是为什么我引用了高老爷子那段话的原因，因为程序的本质就是数据结构和算法，你要没有非常适
合并行的算法那简直就是巧妇难为无米之炊。但是有疑问的一点是关于Parallelism和Concurrency这两个单词的区别，实际上这也是非常
有意思的一件事情，Sun的多线程指南上写的是： Parallelism is a condition that arises when at
least two threads are executing simultaneously, while concurrency is a
condition that exists when at least two threads are making progress.
Therefore concurrency is a more generalized form of parallelism that
can include time-slicing as a form of virtual parallelism.不知道您怎么看？</p>
<p>On 3月22日, 上午8时06分, Alleluia <a href="&#109;&#97;&#x69;&#x6c;&#116;&#111;&#x3a;&#x5b;&#x61;&#x6c;&#x6c;&#117;&#x6c;&#46;&#46;&#46;&#x40;&#103;&#109;&#x61;&#105;&#x6c;&#x2e;&#99;&#111;&#x6d;&#x5d;&#40;&#41;">&#x5b;&#x61;&#x6c;&#x6c;&#117;&#x6c;&#46;&#46;&#46;&#x40;&#103;&#109;&#x61;&#105;&#x6c;&#x2e;&#99;&#111;&#x6d;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>Parallelism 说到底是算法问题.Parallelism与Concurrency不同,Concurrency所面对的问题相对的单一可以
让一群有经验的专家来实现一套通用库或者语言来提供一个基本的编程框架.而在Parallelism上,具体的不同问题,其所需要并行的算法是根本不同
的.原因在于不同的问题,其内部的DataDependency的结构完全不同,不同的Data Dependency的结构,需要构造不同的算法.即
便是相同的Data Dependency,在不同的颗粒度下，在不同的硬件条件下所采用的算法也是完全不同的.因为一旦出现Data
Dependency也就意味着并行计算模块之间需要进行通信.从以计算节点为单位的分布式并行,到多核CPU上的Numa结构,到SIMD上的向量处
理器,其计算单元之间的通信手段,通信效率简直天差地别.比如说,在SMP上最常见的并行算法,work stealing也就是Intel的TBB,
是建立在两个条件下第一个是CPU的Cache机制上,这使得通常在内存的之间的数据搬运消耗非常小,第二个是SMP上计算单元相对的少,因此每个计算
单元被分配到的任务就相对的重。其开销远远大于通信的开销,因此这种机制在SMP上相对的划算.但是如果你要在GPU上做Work Stealing就
完全不可行,因为GPU的运算单元数量极多,被分配到的任务就相对来说的非常轻量,CUDA上的一个thread很多时候运算一次的时间不会超过
10us,而一次跨Block的线程之间的通信开销就往往要达到100us左右,再加上目前GPU上的Cache机制非常落后导致了需要频繁的通信开销
的Work Stealing在GPU上是非常不划算得.
所以我个人认为在硬件架构没有更多的突破之前,OpenCL这种东西是没有任何生命力的.不要说CPU的并行与GPU之间差异巨大,就是不同的GPU之
间AMD与Nvidia两个也是各自为政,一个平台上跑得非常快的东西,在另外一个平台极大的可能是龟速.其最终的结果估计就是跟Java的
write once run everywhere一样是个大笑话.</p>
<p>On 3月22日, 下午2时06分, Guancheng Chen <a href="&#109;&#x61;&#105;&#108;&#x74;&#x6f;&#58;&#91;&#99;&#x68;&#101;&#x6e;&#x67;&#x75;&#97;&#110;&#x63;&#x68;&#46;&#46;&#46;&#64;&#x67;&#109;&#x61;&#105;&#x6c;&#46;&#99;&#x6f;&#x6d;&#93;&#x28;&#x29;">&#91;&#99;&#x68;&#101;&#x6e;&#x67;&#x75;&#97;&#110;&#x63;&#x68;&#46;&#46;&#46;&#64;&#x67;&#109;&#x61;&#105;&#x6c;&#46;&#99;&#x6f;&#x6d;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>On 3月22日, 上午2时20分, Tinyfool <a href="&#x6d;&#97;&#x69;&#x6c;&#x74;&#x6f;&#58;&#x5b;&#116;&#105;&#110;&#x79;&#x66;&#46;&#x2e;&#46;&#x40;&#103;&#x6d;&#97;&#x69;&#108;&#x2e;&#99;&#x6f;&#109;&#x5d;&#x28;&#41;">&#x5b;&#116;&#105;&#110;&#x79;&#x66;&#46;&#x2e;&#46;&#x40;&#103;&#x6d;&#97;&#x69;&#108;&#x2e;&#99;&#x6f;&#109;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#x3a;&#x5b;&#106;&#x65;&#46;&#x2e;&#46;&#64;&#108;&#105;&#118;&#101;&#46;&#99;&#111;&#109;&#x5d;&#x28;&#41;">&#x5b;&#106;&#x65;&#46;&#x2e;&#46;&#64;&#108;&#105;&#118;&#101;&#46;&#99;&#111;&#109;&#x5d;&#x28;&#41;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a></p>
<p>Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#x6d;&#97;&#105;&#x6c;&#116;&#111;&#x3a;&#x5b;&#99;&#x68;&#x65;&#x6e;&#103;&#x75;&#x61;&#x6e;&#99;&#x68;&#x2e;&#46;&#46;&#64;&#x67;&#109;&#97;&#x69;&#108;&#46;&#x63;&#x6f;&#109;&#93;&#x28;&#x29;">&#x5b;&#99;&#x68;&#x65;&#x6e;&#103;&#x75;&#x61;&#x6e;&#99;&#x68;&#x2e;&#46;&#46;&#64;&#x67;&#109;&#97;&#x69;&#108;&#46;&#x63;&#x6f;&#109;&#93;&#x28;&#x29;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#x6d;&#97;&#x69;&#108;&#x74;&#111;&#x3a;&#91;&#x70;&#111;&#110;&#46;&#46;&#x2e;&#64;&#x67;&#111;&#111;&#103;&#108;&#101;&#103;&#114;&#111;&#117;&#x70;&#115;&#46;&#99;&#111;&#x6d;&#x5d;&#40;&#41;">&#91;&#x70;&#111;&#110;&#46;&#46;&#x2e;&#64;&#x67;&#111;&#111;&#103;&#108;&#101;&#103;&#114;&#111;&#117;&#x70;&#115;&#46;&#99;&#111;&#x6d;&#x5d;&#40;&#41;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>&gt;</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间</li>
</ol>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>...</p>
<p>阅读更多 &gt;&gt;
<a href="">显示删减掉的内容</a></p>
</blockquote>
<p><img src="" alt=""> Alleluia <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>且抛开,流处理器这种异构的内核,SMP和Numa之间的差异.就说说单个CPU上做SIMD并行化的需要考虑的内存/cache问题.
比如作矩阵乘法运算,如果矩阵都是按照行存储, 则在A/*B中, 乘法对B的访问是按列的. 假设B一行有N个元素, 那么在存储器中, 两个同列不同
行的元素所在的存储单元相差N. 对B的访问并不是局部化的. 因为访问不局部化, 所以每次乘法, 都需要从内存中调一个 cache 单元到
CPU. 这个极大的降低了处理器的执行速度. 因此, 矩阵乘法的优化的核心, 在于局部化B的访问. 反过来, 如果矩阵按照列存储, 则要局部化
对A的访问. 关于怎样局部化访问还能获得正确的乘法,那就要针对具体的情况设计正确的算法.
为何并行化不可能用库来实现呢?其实问题根源在于,并行颗粒度的变化,导致对IO,算法的乃至硬件结构产生天差地别的变化.一个顺序型的问题,可以划分
成不同的颗粒度.比如说一个100M的Byte型数组,要求和,你可以按照1M的颗粒度进行划分,也可以按照1K,甚至256，128，乃至
4byte,8byte进行划分.每种划分,产生的数据搬运的次数,每次数据搬运的大小,乃至缓存命中率都是不同。
再进一步说,颗粒度划分的越细,意味着计算单元就需要增加,否则就没有意义.但是一旦运算单元的增加到一个的极限,就会引起硬件结构的改变,比如说
SMP根本无法支撑超过16Core的架构,超过这个限度你就得换Nehalem那种Numa架构.在Numa结构下你就不得不考虑,本地内存和远端内
存的区别。
目前没有一个很好的方案来统一不同等级并行计算的架构,在8核之下你用Numa就是杀鸡用牛刀了,而超过32核Numa也不堪重负需要像GPU那样去设
计硬件架构这也就是为什么Intel的Larrebe会难产的原因.每个X86内核都要顶着一个硕大的Deocder还有branch
prediction,OOO之类的庞然大物,用PII来做Larrebe都非常的头大的事情.所以,我个人认为,并行化本身就是和硬件结构极为相关的
事情,这一切都不太可能由一个统一的计算库来完成统一的封装.</p>
<p>On 3月22日, 下午10时38分, &quot;Jeffrey Zhao&quot; <a href="&#109;&#97;&#x69;&#108;&#116;&#111;&#58;&#91;&#106;&#x65;&#46;&#46;&#46;&#64;&#108;&#x69;&#x76;&#x65;&#46;&#99;&#111;&#x6d;&#x5d;&#x28;&#x29;">&#91;&#106;&#x65;&#46;&#46;&#46;&#64;&#108;&#x69;&#x76;&#x65;&#46;&#99;&#111;&#x6d;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>能详细说说为什么&quot;由于内存/cache模型和编译器/cpu的优化, 并行化是不可能通过库来实现的&quot;吗？</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter: @jeffz_cn</p>
<p>From: Lai Jiangshan
Sent: Monday, March 22, 2010 10:17 PM
To: <a href="">pon...@googlegroups.com</a>
Subject: Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>由于内存/cache模型和编译器/cpu的优化, 并行化是不可能通过库来实现的.</p>
<p>我认为最大的障碍是支持并行化的语言.</p>
<p>2010/3/22 Guancheng Chen <a href="&#x6d;&#97;&#x69;&#x6c;&#x74;&#x6f;&#58;&#91;&#x63;&#x68;&#x65;&#x6e;&#x67;&#x75;&#x61;&#110;&#x63;&#104;&#46;&#46;&#46;&#64;&#103;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#93;&#40;&#x29;">&#91;&#x63;&#x68;&#x65;&#x6e;&#x67;&#x75;&#x61;&#110;&#x63;&#104;&#46;&#46;&#46;&#64;&#103;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#93;&#40;&#x29;</a></p>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>&gt;</p>
<blockquote>
<ol>
<li>C语言可以使用pthread等库实现并行化，C++ JAVA等已经会即将支持多线程 所以语言能实现并行化 只是难易问题</li>
<li>是指Shared memory模型，多核共享一条内存总线所以造成带宽问题么？这确实是个问题，不过我感觉硬件商家会负责为你带来越来越多的带
宽，而程序员的任务只是合理的利用好这些给定的带宽</li>
<li><p>能具体说说哪些误导宣传么？</p>
<p>On 3月22日, 上午1时46分, 陨落雕 <a href="&#109;&#97;&#x69;&#x6c;&#116;&#111;&#58;&#91;&#x67;&#101;&#x6f;&#46;&#46;&#46;&#x2e;&#x40;&#103;&#x6d;&#97;&#x69;&#x6c;&#46;&#x63;&#111;&#109;&#93;&#x28;&#x29;">&#91;&#x67;&#101;&#x6f;&#46;&#46;&#46;&#x2e;&#x40;&#103;&#x6d;&#97;&#x69;&#x6c;&#46;&#x63;&#111;&#109;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>呃，我想的障碍是: 1. 类C语言的统治地位; 2. 内存带宽不够; 3. 误导性宣传;</p>
<p>On Mar 21, 7:37 pm, Guancheng Chen <a href="&#109;&#97;&#105;&#x6c;&#x74;&#x6f;&#x3a;&#x5b;&#99;&#104;&#101;&#110;&#x67;&#x75;&#97;&#110;&#99;&#x68;&#46;&#x2e;&#46;&#x40;&#103;&#109;&#97;&#105;&#x6c;&#46;&#99;&#x6f;&#x6d;&#93;&#40;&#x29;">&#x5b;&#99;&#104;&#101;&#110;&#x67;&#x75;&#97;&#110;&#99;&#x68;&#46;&#x2e;&#46;&#x40;&#103;&#109;&#97;&#105;&#x6c;&#46;&#99;&#x6f;&#x6d;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看<a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。</p>
</li>
</ol>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
</li>
</ol>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> 郑伟 <img src="" alt=""></p>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>我对这个比较感兴趣，能详细介绍一下golang在多核下的表现吗？</p>
<p>2010/3/22 Googol Lee <a href="&#109;&#x61;&#x69;&#108;&#x74;&#111;&#58;&#91;&#x67;&#111;&#x6f;&#103;&#x2e;&#x2e;&#46;&#64;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#46;&#x63;&#111;&#109;&#x5d;&#40;&#x29;">&#91;&#x67;&#111;&#x6f;&#103;&#x2e;&#x2e;&#46;&#64;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#46;&#x63;&#111;&#109;&#x5d;&#40;&#x29;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>彻底来晚了......我是来广告golang的！大并发IO还是csp模型的语言更靠谱！
不过golang在cpu密集的并发上不知道效果会怎么样，就现在的表现来看比erlang好，但还赶不上c/c++
On Mar 22, 9:20 am, Tinyfool <a href="&#109;&#x61;&#x69;&#x6c;&#116;&#111;&#x3a;&#x5b;&#x74;&#105;&#110;&#121;&#102;&#46;&#x2e;&#46;&#x40;&#x67;&#109;&#97;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#93;&#x28;&#41;">&#x5b;&#x74;&#105;&#110;&#121;&#102;&#46;&#x2e;&#46;&#x40;&#x67;&#109;&#97;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#109;&#x61;&#x69;&#x6c;&#x74;&#x6f;&#x3a;&#91;&#x6a;&#101;&#46;&#x2e;&#46;&#x40;&#x6c;&#x69;&#118;&#x65;&#46;&#x63;&#111;&#x6d;&#93;&#x28;&#41;">&#91;&#x6a;&#101;&#46;&#x2e;&#46;&#x40;&#x6c;&#x69;&#118;&#x65;&#46;&#x63;&#111;&#x6d;&#93;&#x28;&#41;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#109;&#97;&#105;&#108;&#116;&#x6f;&#58;&#91;&#x63;&#104;&#x65;&#x6e;&#x67;&#x75;&#97;&#x6e;&#99;&#104;&#x2e;&#46;&#46;&#x40;&#103;&#109;&#x61;&#x69;&#108;&#46;&#x63;&#x6f;&#x6d;&#93;&#40;&#x29;">&#91;&#x63;&#104;&#x65;&#x6e;&#x67;&#x75;&#97;&#x6e;&#99;&#104;&#x2e;&#46;&#46;&#x40;&#103;&#109;&#x61;&#x69;&#108;&#46;&#x63;&#x6f;&#x6d;&#93;&#40;&#x29;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#x6d;&#97;&#x69;&#x6c;&#116;&#x6f;&#58;&#x5b;&#x70;&#111;&#110;&#46;&#46;&#x2e;&#64;&#x67;&#x6f;&#x6f;&#x67;&#x6c;&#101;&#x67;&#114;&#111;&#117;&#x70;&#x73;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#40;&#x29;">&#x5b;&#x70;&#111;&#110;&#46;&#46;&#x2e;&#64;&#x67;&#x6f;&#x6f;&#x67;&#x6c;&#101;&#x67;&#114;&#111;&#117;&#x70;&#x73;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#40;&#x29;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。</p>
</li>
</ol>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>--</p>
<p>Tinyfool的开发日记<a href="http://www.tinydust.net/dev/" target="_blank"><a href="http://www.tinydust.net/dev/">http://www.tinydust.net/dev/</a></a>
代码中国网<a href="http://www.codechina.org/" target="_blank"><a href="http://www.codechina.org">http://www.codechina.org</a></a></p>
<p>myTwitter:<a href="http://twitter.com/tinyfool" target="_blank"><a href="http://twitter.com/tinyfool">http://twitter.com/tinyfool</a></a>
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a></p>
</blockquote>
<p><img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-23</p>
<p>其他收件人：</p>
<p>您说的可能跟那个问题不是一回事情，窃以为Lai Jiangshan所说的是指CPU和编译器会对并行程序做违反程序semantics的优化（例如
reordering），导致破坏Memory Consistency，例如大牛HJ Boehm的一篇论文《Threads Cannot be
Implemented as a Library》，我之前也写过一篇浅显小文：<a href="http://www.parallellabs.com/2010/03/06/why-should-programmer-care-about-sequential-consistency-rather-than-cache-coherence/" target="_blank"><a href="http://www.parallellabs.com/">http://www.parallellabs.com/</a>
2010/03/06/why-should-programmer-care-about-sequential-consistency-
rather-than-cache-coherence/</a></p>
<p>另外对于您的Concurrency和Parallelism的看法，我大致理解了您所指的&quot;Concurrency&quot;的含义，它跟我所认为的软件层面
的Concurrency不太一样，您的含义更宏观一些，但是感觉我还没有抓住它的精要，不知道能否推荐几篇文献供我参考？</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>On 3月22日, 下午4时35分, Alleluia <a href="&#x6d;&#97;&#105;&#108;&#116;&#x6f;&#x3a;&#91;&#x61;&#x6c;&#x6c;&#x75;&#x6c;&#x2e;&#46;&#x2e;&#64;&#103;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#93;&#40;&#41;">&#91;&#x61;&#x6c;&#x6c;&#x75;&#x6c;&#x2e;&#46;&#x2e;&#64;&#103;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>且抛开,流处理器这种异构的内核,SMP和Numa之间的差异.就说说单个CPU上做SIMD并行化的需要考虑的内存/cache问题.
比如作矩阵乘法运算,如果矩阵都是按照行存储, 则在A/*B中, 乘法对B的访问是按列的. 假设B一行有N个元素, 那么在存储器中, 两个同列不同
行的元素所在的存储单元相差N. 对B的访问并不是局部化的. 因为访问不局部化, 所以每次乘法, 都需要从内存中调一个 cache 单元到
CPU. 这个极大的降低了处理器的执行速度. 因此, 矩阵乘法的优化的核心, 在于局部化B的访问. 反过来, 如果矩阵按照列存储, 则要局部化
对A的访问. 关于怎样局部化访问还能获得正确的乘法,那就要针对具体的情况设计正确的算法.
为何并行化不可能用库来实现呢?其实问题根源在于,并行颗粒度的变化,导致对IO,算法的乃至硬件结构产生天差地别的变化.一个顺序型的问题,可以划分
成不同的颗粒度.比如说一个100M的Byte型数组,要求和,你可以按照1M的颗粒度进行划分,也可以按照1K,甚至256，128，乃至
4byte,8byte进行划分.每种划分,产生的数据搬运的次数,每次数据搬运的大小,乃至缓存命中率都是不同。
再进一步说,颗粒度划分的越细,意味着计算单元就需要增加,否则就没有意义.但是一旦运算单元的增加到一个的极限,就会引起硬件结构的改变,比如说
SMP根本无法支撑超过16Core的架构,超过这个限度你就得换Nehalem那种Numa架构.在Numa结构下你就不得不考虑,本地内存和远端内
存的区别。
目前没有一个很好的方案来统一不同等级并行计算的架构,在8核之下你用Numa就是杀鸡用牛刀了,而超过32核Numa也不堪重负需要像GPU那样去设
计硬件架构这也就是为什么Intel的Larrebe会难产的原因.每个X86内核都要顶着一个硕大的Deocder还有branch
prediction,OOO之类的庞然大物,用PII来做Larrebe都非常的头大的事情.所以,我个人认为,并行化本身就是和硬件结构极为相关的
事情,这一切都不太可能由一个统一的计算库来完成统一的封装.</p>
<p>On 3月22日, 下午10时38分, &quot;Jeffrey Zhao&quot; <a href="&#x6d;&#97;&#x69;&#108;&#x74;&#x6f;&#58;&#91;&#x6a;&#101;&#x2e;&#x2e;&#x2e;&#64;&#x6c;&#105;&#118;&#101;&#x2e;&#x63;&#x6f;&#109;&#93;&#40;&#x29;">&#91;&#x6a;&#101;&#x2e;&#x2e;&#x2e;&#64;&#x6c;&#105;&#118;&#101;&#x2e;&#x63;&#x6f;&#109;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>能详细说说为什么&quot;由于内存/cache模型和编译器/cpu的优化, 并行化是不可能通过库来实现的&quot;吗？</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter: @jeffz_cn</p>
<p>From: Lai Jiangshan
Sent: Monday, March 22, 2010 10:17 PM
To: <a href="">pon...@googlegroups.com</a>
Subject: Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>由于内存/cache模型和编译器/cpu的优化, 并行化是不可能通过库来实现的.</p>
<p>我认为最大的障碍是支持并行化的语言.</p>
<p>2010/3/22 Guancheng Chen <a href="&#109;&#97;&#x69;&#x6c;&#x74;&#111;&#x3a;&#91;&#99;&#x68;&#101;&#x6e;&#103;&#x75;&#x61;&#110;&#x63;&#104;&#x2e;&#46;&#46;&#64;&#103;&#109;&#x61;&#x69;&#x6c;&#46;&#x63;&#111;&#109;&#93;&#40;&#x29;">&#91;&#99;&#x68;&#101;&#x6e;&#103;&#x75;&#x61;&#110;&#x63;&#104;&#x2e;&#46;&#46;&#64;&#103;&#109;&#x61;&#x69;&#x6c;&#46;&#x63;&#111;&#109;&#93;&#40;&#x29;</a></p>
<ol>
<li>C语言可以使用pthread等库实现并行化，C++ JAVA等已经会即将支持多线程 所以语言能实现并行化 只是难易问题</li>
<li>是指Shared memory模型，多核共享一条内存总线所以造成带宽问题么？这确实是个问题，不过我感觉硬件商家会负责为你带来越来越多的带
宽，而程序员的任务只是合理的利用好这些给定的带宽</li>
<li><p>能具体说说哪些误导宣传么？</p>
<p>On 3月22日, 上午1时46分, 陨落雕 <a href="&#109;&#x61;&#105;&#108;&#116;&#111;&#58;&#91;&#103;&#x65;&#111;&#46;&#x2e;&#46;&#46;&#64;&#103;&#109;&#97;&#x69;&#108;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#x28;&#41;">&#91;&#103;&#x65;&#111;&#46;&#x2e;&#46;&#46;&#64;&#103;&#109;&#97;&#x69;&#108;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>呃，我想的障碍是: 1. 类C语言的统治地位; 2. 内存带宽不够; 3. 误导性宣传;</p>
<p>On Mar 21, 7:37 pm, Guancheng Chen <a href="&#109;&#97;&#105;&#108;&#116;&#x6f;&#x3a;&#91;&#99;&#104;&#x65;&#x6e;&#x67;&#x75;&#97;&#110;&#x63;&#x68;&#x2e;&#46;&#x2e;&#64;&#x67;&#x6d;&#97;&#105;&#108;&#x2e;&#99;&#111;&#x6d;&#93;&#40;&#x29;">&#91;&#99;&#104;&#x65;&#x6e;&#x67;&#x75;&#97;&#110;&#x63;&#x68;&#x2e;&#46;&#x2e;&#64;&#x67;&#x6d;&#97;&#105;&#108;&#x2e;&#99;&#111;&#x6d;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看<a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx...</p>
</blockquote>
</blockquote>
</li>
</ol>
</blockquote>
<p>阅读更多 &gt;&gt;
<a href="">显示删减掉的内容</a>
<img src="" alt=""> windstorm <img src="" alt=""></p>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-23</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>实在是不能同意你更多......很早很早以前我就在这里和人争论过，GPU的并行计算平台不可能一统天下的。CUDA也不是救世主。OpenCL更不是。</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p><a href="http://www.kunli.info/" target="_blank">www.kunli.info</a>
<a href="http://twitter.com/cnbuff" target="_blank"><a href="http://twitter.com/cnbuff">http://twitter.com/cnbuff</a></a></p>
<p>2010/3/22 Alleluia <a href="&#x6d;&#x61;&#x69;&#x6c;&#116;&#x6f;&#58;&#x5b;&#x61;&#108;&#108;&#x75;&#x2e;&#x2e;&#46;&#x40;&#103;&#109;&#97;&#105;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#41;">&#x5b;&#x61;&#108;&#108;&#x75;&#x2e;&#x2e;&#46;&#x40;&#103;&#109;&#97;&#105;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#41;</a>:</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<blockquote>
<p>Parallelism 说到底是算法问题.Parallelism与Concurrency不同,Concurrency所面对的问题相对的单一可以
让一群有经验的专家来实现一套通用库或者语言来提供一个基本的编程框架.而在Parallelism上,具体的不同问题,其所需要并行的算法是根本不同
的.原因在于不同的问题,其内部的DataDependency的结构完全不同,不同的Data Dependency的结构,需要构造不同的算法.即
便是相同的Data Dependency,在不同的颗粒度下，在不同的硬件条件下所采用的算法也是完全不同的.因为一旦出现Data
Dependency也就意味着并行计算模块之间需要进行通信.从以计算节点为单位的分布式并行,到多核CPU上的Numa结构,到SIMD上的向量处
理器,其计算单元之间的通信手段,通信效率简直天差地别.比如说,在SMP上最常见的并行算法,work stealing也就是Intel的TBB,
是建立在两个条件下第一个是CPU的Cache机制上,这使得通常在内存的之间的数据搬运消耗非常小,第二个是SMP上计算单元相对的少,因此每个计算
单元被分配到的任务就相对的重。其开销远远大于通信的开销,因此这种机制在SMP上相对的划算.但是如果你要在GPU上做Work Stealing就
完全不可行,因为GPU的运算单元数量极多,被分配到的任务就相对来说的非常轻量,CUDA上的一个thread很多时候运算一次的时间不会超过
10us,而一次跨Block的线程之间的通信开销就往往要达到100us左右,再加上目前GPU上的Cache机制非常落后导致了需要频繁的通信开销
的Work Stealing在GPU上是非常不划算得.
所以我个人认为在硬件架构没有更多的突破之前,OpenCL这种东西是没有任何生命力的.不要说CPU的并行与GPU之间差异巨大,就是不同的GPU之
间AMD与Nvidia两个也是各自为政,一个平台上跑得非常快的东西,在另外一个平台极大的可能是龟速.其最终的结果估计就是跟Java的
write once run everywhere一样是个大笑话.</p>
<p>On 3月22日, 下午2时06分, Guancheng Chen <a href="&#109;&#x61;&#105;&#x6c;&#116;&#111;&#x3a;&#91;&#99;&#104;&#101;&#x6e;&#x67;&#x75;&#x61;&#x6e;&#x63;&#x68;&#46;&#x2e;&#x2e;&#64;&#x67;&#109;&#x61;&#x69;&#108;&#46;&#99;&#x6f;&#109;&#x5d;&#40;&#41;">&#91;&#99;&#104;&#101;&#x6e;&#x67;&#x75;&#x61;&#x6e;&#x63;&#x68;&#46;&#x2e;&#x2e;&#64;&#x67;&#109;&#x61;&#x69;&#108;&#46;&#99;&#x6f;&#109;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>On 3月22日, 上午2时20分, Tinyfool <a href="&#109;&#x61;&#105;&#x6c;&#116;&#111;&#x3a;&#91;&#x74;&#105;&#x6e;&#x79;&#x66;&#x2e;&#46;&#x2e;&#x40;&#x67;&#109;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#111;&#109;&#93;&#40;&#x29;">&#91;&#x74;&#105;&#x6e;&#x79;&#x66;&#x2e;&#46;&#x2e;&#x40;&#x67;&#109;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#111;&#109;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#109;&#97;&#x69;&#108;&#x74;&#111;&#x3a;&#x5b;&#106;&#x65;&#x2e;&#46;&#x2e;&#64;&#x6c;&#x69;&#118;&#101;&#x2e;&#99;&#x6f;&#109;&#x5d;&#40;&#x29;">&#x5b;&#106;&#x65;&#x2e;&#46;&#x2e;&#64;&#x6c;&#x69;&#118;&#101;&#x2e;&#99;&#x6f;&#109;&#x5d;&#40;&#x29;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#x6d;&#97;&#105;&#108;&#116;&#111;&#x3a;&#x5b;&#x63;&#x68;&#101;&#110;&#x67;&#117;&#97;&#x6e;&#99;&#x68;&#46;&#46;&#x2e;&#64;&#103;&#x6d;&#97;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#93;&#40;&#41;">&#x5b;&#x63;&#x68;&#101;&#110;&#x67;&#117;&#97;&#x6e;&#99;&#x68;&#46;&#46;&#x2e;&#64;&#103;&#x6d;&#97;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#93;&#40;&#41;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#x6d;&#97;&#105;&#108;&#x74;&#x6f;&#58;&#x5b;&#112;&#111;&#x6e;&#x2e;&#x2e;&#46;&#64;&#103;&#x6f;&#111;&#103;&#x6c;&#101;&#x67;&#x72;&#x6f;&#x75;&#x70;&#115;&#46;&#99;&#x6f;&#109;&#93;&#x28;&#41;">&#x5b;&#112;&#111;&#x6e;&#x2e;&#x2e;&#46;&#64;&#103;&#x6f;&#111;&#103;&#x6c;&#101;&#x67;&#x72;&#x6f;&#x75;&#x70;&#115;&#46;&#99;&#x6f;&#109;&#93;&#x28;&#41;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。</p>
</li>
</ol>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>--
Tinyfool的开发日记<a href="http://www.tinydust.net/dev/" target="_blank"><a href="http://www.tinydust.net/dev/">http://www.tinydust.net/dev/</a></a>
代码中国网<a href="http://www.codechina.org/" target="_blank"><a href="http://www.codechina.org">http://www.codechina.org</a></a>
myTwitter:<a href="http://twitter.com/tinyfool" target="_blank"><a href="http://twitter.com/tinyfool">http://twitter.com/tinyfool</a></a></p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p><a href="">显示删减掉的内容</a></p>
</blockquote>
<p><img src="" alt=""> Juv...@gmail.com <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-23</p>
<p>其他收件人：</p>
<p>好像大家说的concurrency和parallelism不是一个东西？
<a href="">显示删减掉的内容</a>
<img src="" alt=""> windstorm <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-23</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>我觉得这两个东西，sun的多线程编程手册说得很清楚了，没必要重新定义。</p>
<p>Parallelism is a condition that arises when at least two threads are
executing simultaneously, while concurrency is a condition that exists
when at least two threads are making progress.</p>
<p>也就是说concurrency有点像更通用化，限制条件更低的parallelism，而某些case下两者完全不同。比如单核多线程程序，你可以叫它是concurrent
program，但不能叫它是parallel
program。Concurrency在现有体系的处理器架构下都可以做到。和Alleluia说的一样，只是一个时钟周期同步的问题。写过硬件编程的人，几乎都算是写过concurrent
program，但很少写过parallel program</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p><a href="http://www.kunli.info/" target="_blank">www.kunli.info</a>
<a href="http://twitter.com/cnbuff" target="_blank"><a href="http://twitter.com/cnbuff">http://twitter.com/cnbuff</a></a></p>
<p>2010/3/22 <a href="">Juv...@gmail.com</a> <a href="&#x6d;&#97;&#105;&#x6c;&#116;&#x6f;&#x3a;&#x5b;&#x6a;&#117;&#118;&#46;&#x2e;&#46;&#64;&#103;&#109;&#97;&#105;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#40;&#41;">&#x5b;&#x6a;&#117;&#118;&#46;&#x2e;&#46;&#64;&#103;&#109;&#97;&#105;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#40;&#41;</a>:</p>
<blockquote>
<p>好像大家说的concurrency和parallelism不是一个东西？</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p><a href="">显示删减掉的内容</a></p>
</blockquote>
<p><img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-23</p>
<p>其他收件人：</p>
<p>我觉得现有的OpenCL确实非常不成熟，但是从纯性能角度上来讲，我看好Heterogeneous架构，尽管它们的编程难度太大，就像前面提到的不
同架构需要做不同优化等。CPU的性能是latency-oriented，GPU是throughput-oriented,Intel的
Larrabee虽然现在来看不成功，但是业界都在朝着那个方向努力。</p>
<p>On 3月22日, 下午6时18分, windstorm <a href="&#x6d;&#x61;&#105;&#x6c;&#x74;&#111;&#x3a;&#x5b;&#108;&#x69;&#107;&#117;&#x6e;&#x61;&#x72;&#109;&#x73;&#x74;&#114;&#x2e;&#46;&#x2e;&#x40;&#x67;&#x6d;&#97;&#x69;&#108;&#x2e;&#x63;&#111;&#x6d;&#93;&#x28;&#41;">&#x5b;&#108;&#x69;&#107;&#117;&#x6e;&#x61;&#x72;&#109;&#x73;&#x74;&#114;&#x2e;&#46;&#x2e;&#x40;&#x67;&#x6d;&#97;&#x69;&#108;&#x2e;&#x63;&#111;&#x6d;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>实在是不能同意你更多......很早很早以前我就在这里和人争论过，GPU的并行计算平台不可能一统天下的。CUDA也不是救世主。OpenCL更不是。</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Alleluia <a href="&#109;&#97;&#105;&#x6c;&#116;&#111;&#58;&#x5b;&#x61;&#x6c;&#x6c;&#x75;&#108;&#46;&#x2e;&#46;&#64;&#103;&#x6d;&#x61;&#x69;&#108;&#46;&#x63;&#x6f;&#x6d;&#93;&#x28;&#41;">&#x5b;&#x61;&#x6c;&#x6c;&#x75;&#108;&#46;&#x2e;&#46;&#64;&#103;&#x6d;&#x61;&#x69;&#108;&#46;&#x63;&#x6f;&#x6d;&#93;&#x28;&#41;</a>:</p>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>&gt;
&gt;
&gt;</p>
<blockquote>
<blockquote>
<p>Parallelism 说到底是算法问题.Parallelism与Concurrency不同,Concurrency所面对的问题相对的单一可以
让一群有经验的专家来实现一套通用库或者语言来提供一个基本的编程框架.而在Parallelism上,具体的不同问题,其所需要并行的算法是根本不同
的.原因在于不同的问题,其内部的DataDependency的结构完全不同,不同的Data Dependency的结构,需要构造不同的算法.即
便是相同的Data Dependency,在不同的颗粒度下，在不同的硬件条件下所采用的算法也是完全不同的.因为一旦出现Data
Dependency也就意味着并行计算模块之间需要进行通信.从以计算节点为单位的分布式并行,到多核CPU上的Numa结构,到SIMD上的向量处
理器,其计算单元之间的通信手段,通信效率简直天差地别.比如说,在SMP上最常见的并行算法,work stealing也就是Intel的TBB,
是建立在两个条件下第一个是CPU的Cache机制上,这使得通常在内存的之间的数据搬运消耗非常小,第二个是SMP上计算单元相对的少,因此每个计算
单元被分配到的任务就相对的重。其开销远远大于通信的开销,因此这种机制在SMP上相对的划算.但是如果你要在GPU上做Work Stealing就
完全不可行,因为GPU的运算单元数量极多,被分配到的任务就相对来说的非常轻量,CUDA上的一个thread很多时候运算一次的时间不会超过
10us,而一次跨Block的线程之间的通信开销就往往要达到100us左右,再加上目前GPU上的Cache机制非常落后导致了需要频繁的通信开销
的Work Stealing在GPU上是非常不划算得.
所以我个人认为在硬件架构没有更多的突破之前,OpenCL这种东西是没有任何生命力的.不要说CPU的并行与GPU之间差异巨大,就是不同的GPU之
间AMD与Nvidia两个也是各自为政,一个平台上跑得非常快的东西,在另外一个平台极大的可能是龟速.其最终的结果估计就是跟Java的
write once run everywhere一样是个大笑话.</p>
<p>On 3月22日, 下午2时06分, Guancheng Chen <a href="&#x6d;&#97;&#105;&#x6c;&#x74;&#x6f;&#x3a;&#x5b;&#x63;&#x68;&#101;&#x6e;&#x67;&#117;&#97;&#110;&#99;&#x68;&#46;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#105;&#108;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#40;&#41;">&#x5b;&#x63;&#x68;&#101;&#x6e;&#x67;&#117;&#97;&#110;&#99;&#x68;&#46;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#105;&#108;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>On 3月22日, 上午2时20分, Tinyfool <a href="&#x6d;&#97;&#x69;&#x6c;&#116;&#x6f;&#x3a;&#91;&#x74;&#105;&#x6e;&#121;&#102;&#46;&#x2e;&#x2e;&#64;&#x67;&#109;&#x61;&#105;&#108;&#46;&#99;&#x6f;&#109;&#x5d;&#40;&#x29;">&#91;&#x74;&#105;&#x6e;&#121;&#102;&#46;&#x2e;&#x2e;&#64;&#x67;&#109;&#x61;&#105;&#108;&#46;&#99;&#x6f;&#109;&#x5d;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#x6d;&#97;&#105;&#108;&#116;&#111;&#58;&#91;&#x6a;&#101;&#x2e;&#x2e;&#x2e;&#64;&#x6c;&#x69;&#x76;&#x65;&#46;&#x63;&#x6f;&#109;&#x5d;&#x28;&#x29;">&#91;&#x6a;&#101;&#x2e;&#x2e;&#x2e;&#64;&#x6c;&#x69;&#x76;&#x65;&#46;&#x63;&#x6f;&#109;&#x5d;&#x28;&#x29;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#x6d;&#x61;&#x69;&#108;&#x74;&#111;&#x3a;&#91;&#99;&#104;&#x65;&#110;&#103;&#117;&#97;&#110;&#99;&#x68;&#46;&#46;&#46;&#64;&#103;&#109;&#x61;&#x69;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#40;&#x29;">&#91;&#99;&#104;&#x65;&#110;&#103;&#117;&#97;&#110;&#99;&#x68;&#46;&#46;&#46;&#64;&#103;&#109;&#x61;&#x69;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#40;&#x29;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#x6d;&#97;&#105;&#x6c;&#116;&#x6f;&#x3a;&#x5b;&#112;&#x6f;&#110;&#46;&#46;&#46;&#64;&#x67;&#111;&#x6f;&#103;&#x6c;&#x65;&#103;&#x72;&#111;&#117;&#x70;&#115;&#46;&#x63;&#x6f;&#109;&#93;&#40;&#x29;">&#x5b;&#112;&#x6f;&#110;&#46;&#46;&#46;&#64;&#x67;&#111;&#x6f;&#103;&#x6c;&#x65;&#103;&#x72;&#111;&#117;&#x70;&#115;&#46;&#x63;&#x6f;&#109;&#93;&#40;&#x29;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？...</li>
</ol>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>阅读更多 &gt;&gt;
<a href="">显示删减掉的内容</a>
<img src="" alt=""> windstorm <img src="" alt=""></p>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-23</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>Larrabee当初我还是很看好的，它的架构比其他的更像一个统一的方案，可惜后来Intel自己经验不足搞不好。</p>
<p>OPENCL还是主要面向multimedia吧，CUDA/OpenCL在业界代表了流处理的方向，从GPU针对任务的角度讲是好的。其他的就算了。就像Alleluia说的那样，在硬件架构没有更多的突破之前，不说没有生命力，至少想取得任何进一步的突破都太难。</p>
<p>现在这个领域，你吹你的水，我吹我的水。至于谁的泡泡大，我看不清。所以真要选东西学，最好还是针对自己的application选靠谱。这也是并行编程教育难的问题。大家需求完全不一样。</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p><a href="http://www.kunli.info/" target="_blank">www.kunli.info</a>
<a href="http://twitter.com/cnbuff" target="_blank"><a href="http://twitter.com/cnbuff">http://twitter.com/cnbuff</a></a></p>
<p>2010/3/22 Guancheng Chen <a href="&#109;&#x61;&#105;&#108;&#116;&#111;&#x3a;&#x5b;&#x63;&#x68;&#x65;&#x6e;&#103;&#117;&#46;&#x2e;&#46;&#64;&#103;&#109;&#x61;&#105;&#108;&#46;&#x63;&#111;&#x6d;&#93;&#40;&#x29;">&#x5b;&#x63;&#x68;&#x65;&#x6e;&#103;&#117;&#46;&#x2e;&#46;&#64;&#103;&#109;&#x61;&#105;&#108;&#46;&#x63;&#111;&#x6d;&#93;&#40;&#x29;</a>:</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<blockquote>
<p>我觉得现有的OpenCL确实非常不成熟，但是从纯性能角度上来讲，我看好Heterogeneous架构，尽管它们的编程难度太大，就像前面提到的不
同架构需要做不同优化等。CPU的性能是latency-oriented，GPU是throughput-oriented,Intel的
Larrabee虽然现在来看不成功，但是业界都在朝着那个方向努力。</p>
<p>On 3月22日, 下午6时18分, windstorm <a href="&#x6d;&#97;&#x69;&#x6c;&#x74;&#x6f;&#x3a;&#x5b;&#x6c;&#x69;&#x6b;&#x75;&#x6e;&#x61;&#114;&#109;&#x73;&#x74;&#114;&#46;&#x2e;&#46;&#64;&#x67;&#x6d;&#97;&#105;&#x6c;&#46;&#99;&#x6f;&#109;&#x5d;&#40;&#x29;">&#x5b;&#x6c;&#x69;&#x6b;&#x75;&#x6e;&#x61;&#114;&#109;&#x73;&#x74;&#114;&#46;&#x2e;&#46;&#64;&#x67;&#x6d;&#97;&#105;&#x6c;&#46;&#99;&#x6f;&#109;&#x5d;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>实在是不能同意你更多......很早很早以前我就在这里和人争论过，GPU的并行计算平台不可能一统天下的。CUDA也不是救世主。OpenCL更不是。</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Alleluia <a href="&#x6d;&#97;&#x69;&#x6c;&#116;&#111;&#58;&#91;&#97;&#108;&#x6c;&#117;&#x6c;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#x61;&#x69;&#108;&#46;&#x63;&#111;&#109;&#x5d;&#40;&#x29;">&#91;&#97;&#108;&#x6c;&#117;&#x6c;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#x61;&#x69;&#108;&#46;&#x63;&#111;&#109;&#x5d;&#40;&#x29;</a>:</p>
<blockquote>
<p>Parallelism 说到底是算法问题.Parallelism与Concurrency不同,Concurrency所面对的问题相对的单一可以
让一群有经验的专家来实现一套通用库或者语言来提供一个基本的编程框架.而在Parallelism上,具体的不同问题,其所需要并行的算法是根本不同
的.原因在于不同的问题,其内部的DataDependency的结构完全不同,不同的Data Dependency的结构,需要构造不同的算法.即
便是相同的Data Dependency,在不同的颗粒度下，在不同的硬件条件下所采用的算法也是完全不同的.因为一旦出现Data
Dependency也就意味着并行计算模块之间需要进行通信.从以计算节点为单位的分布式并行,到多核CPU上的Numa结构,到SIMD上的向量处
理器,其计算单元之间的通信手段,通信效率简直天差地别.比如说,在SMP上最常见的并行算法,work stealing也就是Intel的TBB,
是建立在两个条件下第一个是CPU的Cache机制上,这使得通常在内存的之间的数据搬运消耗非常小,第二个是SMP上计算单元相对的少,因此每个计算
单元被分配到的任务就相对的重。其开销远远大于通信的开销,因此这种机制在SMP上相对的划算.但是如果你要在GPU上做Work Stealing就
完全不可行,因为GPU的运算单元数量极多,被分配到的任务就相对来说的非常轻量,CUDA上的一个thread很多时候运算一次的时间不会超过
10us,而一次跨Block的线程之间的通信开销就往往要达到100us左右,再加上目前GPU上的Cache机制非常落后导致了需要频繁的通信开销
的Work Stealing在GPU上是非常不划算得.
所以我个人认为在硬件架构没有更多的突破之前,OpenCL这种东西是没有任何生命力的.不要说CPU的并行与GPU之间差异巨大,就是不同的GPU之
间AMD与Nvidia两个也是各自为政,一个平台上跑得非常快的东西,在另外一个平台极大的可能是龟速.其最终的结果估计就是跟Java的
write once run everywhere一样是个大笑话.</p>
<p>On 3月22日, 下午2时06分, Guancheng Chen <a href="&#109;&#97;&#x69;&#108;&#x74;&#111;&#58;&#x5b;&#99;&#x68;&#101;&#x6e;&#x67;&#x75;&#97;&#110;&#x63;&#x68;&#46;&#46;&#x2e;&#64;&#103;&#109;&#97;&#x69;&#108;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#41;">&#x5b;&#99;&#x68;&#101;&#x6e;&#x67;&#x75;&#97;&#110;&#x63;&#x68;&#46;&#46;&#x2e;&#64;&#103;&#109;&#97;&#x69;&#108;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>On 3月22日, 上午2时20分, Tinyfool <a href="&#109;&#x61;&#x69;&#108;&#x74;&#111;&#x3a;&#91;&#x74;&#105;&#110;&#121;&#102;&#x2e;&#x2e;&#46;&#64;&#103;&#109;&#x61;&#105;&#108;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#x29;">&#91;&#x74;&#105;&#110;&#121;&#102;&#x2e;&#x2e;&#46;&#64;&#103;&#109;&#x61;&#105;&#108;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#109;&#x61;&#x69;&#x6c;&#116;&#111;&#x3a;&#91;&#x6a;&#101;&#46;&#x2e;&#46;&#64;&#x6c;&#105;&#118;&#x65;&#46;&#x63;&#x6f;&#x6d;&#93;&#x28;&#x29;">&#91;&#x6a;&#101;&#46;&#x2e;&#46;&#64;&#x6c;&#105;&#118;&#x65;&#46;&#x63;&#x6f;&#x6d;&#93;&#x28;&#x29;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#109;&#97;&#x69;&#108;&#116;&#111;&#x3a;&#91;&#x63;&#104;&#x65;&#x6e;&#103;&#x75;&#97;&#x6e;&#x63;&#x68;&#x2e;&#x2e;&#46;&#x40;&#x67;&#109;&#x61;&#x69;&#108;&#46;&#99;&#x6f;&#109;&#93;&#x28;&#41;">&#91;&#x63;&#104;&#x65;&#x6e;&#103;&#x75;&#97;&#x6e;&#x63;&#x68;&#x2e;&#x2e;&#46;&#x40;&#x67;&#109;&#x61;&#x69;&#108;&#46;&#99;&#x6f;&#109;&#93;&#x28;&#41;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#x6f;&#58;&#x5b;&#x70;&#x6f;&#110;&#x2e;&#x2e;&#46;&#64;&#x67;&#111;&#111;&#103;&#x6c;&#101;&#103;&#114;&#111;&#x75;&#112;&#115;&#46;&#x63;&#x6f;&#x6d;&#93;&#x28;&#x29;">&#x5b;&#x70;&#x6f;&#110;&#x2e;&#x2e;&#46;&#64;&#x67;&#111;&#111;&#103;&#x6c;&#101;&#103;&#114;&#111;&#x75;&#112;&#115;&#46;&#x63;&#x6f;&#x6d;&#93;&#x28;&#x29;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？...</li>
</ol>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>阅读更多 &gt;&gt;</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p><a href="">显示删减掉的内容</a></p>
</blockquote>
<p><img src="" alt=""> Alleluia <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-23</p>
<p>其他收件人：</p>
<p>对于Concurrency和Parallelism之间混乱的根源就是多线程/进程模型.Concurrrency可以用multithread/
process,也可以不用.一个单核单线程的Concurrency程序只要写的好,对于几万个并发连接不是问题.但是Parallelism必须要
用到multithread.对于Concurrency来说,multithread只是一种可选的方案.
当然,在CPU架构上Concurrency和Parallelism的很多设施都是可以复用的,比如高性能的线程池,以及细粒度的锁等等.</p>
<p>On 3月23日, 上午4时32分, windstorm <a href="&#109;&#x61;&#105;&#x6c;&#116;&#x6f;&#58;&#91;&#108;&#105;&#x6b;&#117;&#110;&#97;&#x72;&#109;&#x73;&#116;&#x72;&#46;&#46;&#46;&#64;&#103;&#x6d;&#97;&#105;&#x6c;&#46;&#99;&#x6f;&#x6d;&#x5d;&#40;&#x29;">&#91;&#108;&#105;&#x6b;&#117;&#110;&#97;&#x72;&#109;&#x73;&#116;&#x72;&#46;&#46;&#46;&#64;&#103;&#x6d;&#97;&#105;&#x6c;&#46;&#99;&#x6f;&#x6d;&#x5d;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>我觉得这两个东西，sun的多线程编程手册说得很清楚了，没必要重新定义。</p>
<p>Parallelism is a condition that arises when at least two threads are
executing simultaneously, while concurrency is a condition that exists
when at least two threads are making progress.</p>
<p>也就是说concurrency有点像更通用化，限制条件更低的parallelism，而某些case下两者完全不同。比如单核多线程程序，你可以叫它是co ncurrent
program，但不能叫它是parallel
program。Concurrency在现有体系的处理器架构下都可以做到。和Alleluia说的一样，只是一个时钟周期同步的问题。写过硬件编程的人，几 乎都算是写过concurrent
program，但很少写过parallel program</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>2010/3/22 <a href="">Juv...@gmail.com</a> <a href="&#x6d;&#97;&#x69;&#108;&#x74;&#x6f;&#x3a;&#91;&#x6a;&#x75;&#x76;&#46;&#46;&#46;&#x40;&#103;&#109;&#x61;&#x69;&#108;&#x2e;&#99;&#111;&#109;&#93;&#x28;&#41;">&#91;&#x6a;&#x75;&#x76;&#46;&#46;&#46;&#x40;&#103;&#109;&#x61;&#x69;&#108;&#x2e;&#99;&#111;&#109;&#93;&#x28;&#41;</a>:</p>
<blockquote>
<p>好像大家说的concurrency和parallelism不是一个东西？</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> Alleluia <img src="" alt=""></p>
</blockquote>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-23</p>
<p>其他收件人：</p>
<p>Heterogeneous目前来看也是一个暂时的过渡性的东西. Heterogeneous架构最大的问题还是硬件,CPU和GPU之间的
PCIE2的bus带宽太窄了.在上面来回传递一次几M的内存可能需要化掉500us左右.如果一个算法本来就是在3-4ms级别的,你要用GPU去优
化,内存带宽的消耗就占了1/10,这是非常可怕的事情.或许像AMD那种Fusion架构是一种趋势,但是目前来说没有太大的进展.貌似AMD出了一
款混合的CPU,但是貌似还没有看到有多大的优势.</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>On 3月23日, 上午5时02分, Guancheng Chen <a href="&#x6d;&#x61;&#105;&#x6c;&#116;&#111;&#58;&#91;&#99;&#104;&#101;&#110;&#x67;&#117;&#97;&#110;&#99;&#x68;&#x2e;&#46;&#x2e;&#64;&#x67;&#109;&#97;&#105;&#108;&#x2e;&#99;&#111;&#x6d;&#93;&#x28;&#41;">&#91;&#99;&#104;&#101;&#110;&#x67;&#117;&#97;&#110;&#99;&#x68;&#x2e;&#46;&#x2e;&#64;&#x67;&#109;&#97;&#105;&#108;&#x2e;&#99;&#111;&#x6d;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>我觉得现有的OpenCL确实非常不成熟，但是从纯性能角度上来讲，我看好Heterogeneous架构，尽管它们的编程难度太大，就像前面提到的不
同架构需要做不同优化等。CPU的性能是latency-oriented，GPU是throughput-oriented,Intel的
Larrabee虽然现在来看不成功，但是业界都在朝着那个方向努力。</p>
<p>On 3月22日, 下午6时18分, windstorm <a href="&#x6d;&#x61;&#105;&#108;&#x74;&#111;&#58;&#91;&#x6c;&#x69;&#107;&#117;&#x6e;&#97;&#x72;&#109;&#115;&#x74;&#x72;&#46;&#x2e;&#46;&#64;&#x67;&#109;&#97;&#x69;&#x6c;&#46;&#99;&#111;&#x6d;&#x5d;&#40;&#x29;">&#91;&#x6c;&#x69;&#107;&#117;&#x6e;&#97;&#x72;&#109;&#115;&#x74;&#x72;&#46;&#x2e;&#46;&#64;&#x67;&#109;&#97;&#x69;&#x6c;&#46;&#99;&#111;&#x6d;&#x5d;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>实在是不能同意你更多......很早很早以前我就在这里和人争论过，GPU的并行计算平台不可能一统天下的。CUDA也不是救世主。OpenCL更不是。</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Alleluia <a href="&#109;&#x61;&#105;&#x6c;&#x74;&#111;&#x3a;&#91;&#97;&#108;&#x6c;&#117;&#x6c;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#x61;&#x69;&#x6c;&#46;&#99;&#x6f;&#x6d;&#x5d;&#40;&#x29;">&#91;&#97;&#108;&#x6c;&#117;&#x6c;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#x61;&#x69;&#x6c;&#46;&#99;&#x6f;&#x6d;&#x5d;&#40;&#x29;</a>:</p>
<blockquote>
<p>Parallelism 说到底是算法问题.Parallelism与Concurrency不同,Concurrency所面对的问题相对的单一可以
让一群有经验的专家来实现一套通用库或者语言来提供一个基本的编程框架.而在Parallelism上,具体的不同问题,其所需要并行的算法是根本不同
的.原因在于不同的问题,其内部的DataDependency的结构完全不同,不同的Data Dependency的结构,需要构造不同的算法.即
便是相同的Data Dependency,在不同的颗粒度下，在不同的硬件条件下所采用的算法也是完全不同的.因为一旦出现Data
Dependency也就意味着并行计算模块之间需要进行通信.从以计算节点为单位的分布式并行,到多核CPU上的Numa结构,到SIMD上的向量处
理器,其计算单元之间的通信手段,通信效率简直天差地别.比如说,在SMP上最常见的并行算法,work stealing也就是Intel的TBB,
是建立在两个条件下第一个是CPU的Cache机制上,这使得通常在内存的之间的数据搬运消耗非常小,第二个是SMP上计算单元相对的少,因此每个计算
单元被分配到的任务就相对的重。其开销远远大于通信的开销,因此这种机制在SMP上相对的划算.但是如果你要在GPU上做Work Stealing就
完全不可行,因为GPU的运算单元数量极多,被分配到的任务就相对来说的非常轻量,CUDA上的一个thread很多时候运算一次的时间不会超过
10us,而一次跨Block的线程之间的通信开销就往往要达到100us左右,再加上目前GPU上的Cache机制非常落后导致了需要频繁的通信开销
的Work Stealing在GPU上是非常不划算得.
所以我个人认为在硬件架构没有更多的突破之前,OpenCL这种东西是没有任何生命力的.不要说CPU的并行与GPU之间差异巨大,就是不同的GPU之
间AMD与Nvidia两个也是各自为政,一个平台上跑得非常快的东西,在另外一个平台极大的可能是龟速.其最终的结果估计就是跟Java的
write once run everywhere一样是个大笑话.</p>
<p>On 3月22日, 下午2时06分, Guancheng Chen <a href="&#109;&#x61;&#105;&#x6c;&#x74;&#111;&#58;&#x5b;&#99;&#x68;&#x65;&#x6e;&#x67;&#x75;&#97;&#x6e;&#99;&#104;&#x2e;&#x2e;&#46;&#x40;&#x67;&#109;&#x61;&#105;&#x6c;&#46;&#x63;&#111;&#109;&#x5d;&#40;&#x29;">&#x5b;&#99;&#x68;&#x65;&#x6e;&#x67;&#x75;&#97;&#x6e;&#99;&#104;&#x2e;&#x2e;&#46;&#x40;&#x67;&#109;&#x61;&#105;&#x6c;&#46;&#x63;&#111;&#109;&#x5d;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>On 3月22日, 上午2时20分, Tinyfool <a href="&#x6d;&#x61;&#105;&#x6c;&#116;&#x6f;&#x3a;&#91;&#116;&#105;&#110;&#x79;&#x66;&#46;&#x2e;&#46;&#x40;&#x67;&#109;&#x61;&#x69;&#108;&#x2e;&#99;&#111;&#x6d;&#93;&#x28;&#41;">&#91;&#116;&#105;&#110;&#x79;&#x66;&#46;&#x2e;&#46;&#x40;&#x67;&#109;&#x61;&#x69;&#108;&#x2e;&#99;&#111;&#x6d;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#x6d;&#97;&#105;&#108;&#x74;&#111;&#58;&#x5b;&#106;&#101;&#x2e;&#x2e;&#46;&#x40;&#108;&#105;&#x76;&#101;&#x2e;&#99;&#x6f;&#109;&#x5d;&#40;&#x29;">&#x5b;&#106;&#101;&#x2e;&#x2e;&#46;&#x40;&#108;&#105;&#x76;&#101;&#x2e;&#99;&#x6f;&#109;&#x5d;&#40;&#x29;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#x6d;&#x61;&#x69;&#108;&#x74;&#x6f;&#58;&#91;&#99;&#104;&#101;&#x6e;&#x67;&#x75;&#x61;&#110;&#99;&#x68;&#x2e;&#46;&#46;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#x6f;&#x6d;&#93;&#x28;&#41;">&#91;&#99;&#104;&#101;&#x6e;&#x67;&#x75;&#x61;&#110;&#99;&#x68;&#x2e;&#46;&#46;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#x6f;&#x6d;&#93;&#x28;&#41;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#x6d;&#97;&#x69;&#x6c;&#116;&#111;&#58;&#x5b;&#x70;&#111;&#x6e;&#x2e;&#46;&#46;&#x40;&#103;&#x6f;&#x6f;&#103;&#108;&#x65;&#103;&#x72;&#111;&#x75;&#x70;&#x73;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#40;&#41;">&#x5b;&#x70;&#111;&#x6e;&#x2e;&#46;&#46;&#x40;&#103;&#x6f;&#x6f;&#103;&#108;&#x65;&#103;&#x72;&#111;&#x75;&#x70;&#x73;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#40;&#41;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>...</p>
<p>阅读更多 &gt;&gt;
<a href="">显示删减掉的内容</a></p>
</blockquote>
<p><img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-23</p>
<p>其他收件人：</p>
<p>恩 您也是搞体系结构的么？
现在我在跟瑞典这边的爱立信合作做毕设 不过对象不是他们的Erlang 而是传统的C/C++程序 下半年可能我也去搞GPGPU了 因为它的
data parallel模型对遗留代码的并行化很有搞头，现在我粗略的想法是把Compute sensitive的任务放一部分到GPU上去做，
当然我也对GPU目前的一些限制有所了解 但是一些探索工作还是非常值得的 到时候还想向前辈多多请教</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>On 3月22日, 下午11时30分, Alleluia <a href="&#x6d;&#97;&#105;&#x6c;&#116;&#111;&#x3a;&#91;&#97;&#x6c;&#x6c;&#x75;&#108;&#x2e;&#46;&#46;&#x40;&#x67;&#109;&#x61;&#x69;&#108;&#46;&#x63;&#x6f;&#109;&#93;&#x28;&#41;">&#91;&#97;&#x6c;&#x6c;&#x75;&#108;&#x2e;&#46;&#46;&#x40;&#x67;&#109;&#x61;&#x69;&#108;&#46;&#x63;&#x6f;&#109;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>Heterogeneous目前来看也是一个暂时的过渡性的东西. Heterogeneous架构最大的问题还是硬件,CPU和GPU之间的
PCIE2的bus带宽太窄了.在上面来回传递一次几M的内存可能需要化掉500us左右.如果一个算法本来就是在3-4ms级别的,你要用GPU去优
化,内存带宽的消耗就占了1/10,这是非常可怕的事情.或许像AMD那种Fusion架构是一种趋势,但是目前来说没有太大的进展.貌似AMD出了一
款混合的CPU,但是貌似还没有看到有多大的优势.
On 3月23日, 上午5时02分, Guancheng Chen <a href="&#x6d;&#97;&#105;&#108;&#x74;&#x6f;&#x3a;&#91;&#x63;&#x68;&#101;&#x6e;&#x67;&#x75;&#97;&#110;&#x63;&#104;&#46;&#46;&#x2e;&#64;&#x67;&#x6d;&#97;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#x28;&#41;">&#91;&#x63;&#x68;&#101;&#x6e;&#x67;&#x75;&#97;&#110;&#x63;&#104;&#46;&#46;&#x2e;&#64;&#x67;&#x6d;&#97;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>我觉得现有的OpenCL确实非常不成熟，但是从纯性能角度上来讲，我看好Heterogeneous架构，尽管它们的编程难度太大，就像前面提到的不
同架构需要做不同优化等。CPU的性能是latency-oriented，GPU是throughput-oriented,Intel的
Larrabee虽然现在来看不成功，但是业界都在朝着那个方向努力。</p>
<p>On 3月22日, 下午6时18分, windstorm <a href="&#x6d;&#x61;&#x69;&#108;&#116;&#111;&#x3a;&#91;&#108;&#x69;&#107;&#x75;&#x6e;&#x61;&#114;&#109;&#115;&#116;&#114;&#46;&#46;&#x2e;&#64;&#x67;&#x6d;&#97;&#105;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#41;">&#91;&#108;&#x69;&#107;&#x75;&#x6e;&#x61;&#114;&#109;&#115;&#116;&#114;&#46;&#46;&#x2e;&#64;&#x67;&#x6d;&#97;&#105;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>实在是不能同意你更多......很早很早以前我就在这里和人争论过，GPU的并行计算平台不可能一统天下的。CUDA也不是救世主。OpenCL更不是。</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Alleluia <a href="&#x6d;&#x61;&#105;&#x6c;&#x74;&#x6f;&#58;&#91;&#97;&#108;&#x6c;&#x75;&#108;&#46;&#x2e;&#x2e;&#x40;&#103;&#109;&#97;&#105;&#x6c;&#46;&#99;&#x6f;&#x6d;&#93;&#x28;&#x29;">&#91;&#97;&#108;&#x6c;&#x75;&#108;&#46;&#x2e;&#x2e;&#x40;&#103;&#109;&#97;&#105;&#x6c;&#46;&#99;&#x6f;&#x6d;&#93;&#x28;&#x29;</a>:</p>
<blockquote>
<p>Parallelism 说到底是算法问题.Parallelism与Concurrency不同,Concurrency所面对的问题相对的单一可以
让一群有经验的专家来实现一套通用库或者语言来提供一个基本的编程框架.而在Parallelism上,具体的不同问题,其所需要并行的算法是根本不同
的.原因在于不同的问题,其内部的DataDependency的结构完全不同,不同的Data Dependency的结构,需要构造不同的算法.即
便是相同的Data Dependency,在不同的颗粒度下，在不同的硬件条件下所采用的算法也是完全不同的.因为一旦出现Data
Dependency也就意味着并行计算模块之间需要进行通信.从以计算节点为单位的分布式并行,到多核CPU上的Numa结构,到SIMD上的向量处
理器,其计算单元之间的通信手段,通信效率简直天差地别.比如说,在SMP上最常见的并行算法,work stealing也就是Intel的TBB,
是建立在两个条件下第一个是CPU的Cache机制上,这使得通常在内存的之间的数据搬运消耗非常小,第二个是SMP上计算单元相对的少,因此每个计算
单元被分配到的任务就相对的重。其开销远远大于通信的开销,因此这种机制在SMP上相对的划算.但是如果你要在GPU上做Work Stealing就
完全不可行,因为GPU的运算单元数量极多,被分配到的任务就相对来说的非常轻量,CUDA上的一个thread很多时候运算一次的时间不会超过
10us,而一次跨Block的线程之间的通信开销就往往要达到100us左右,再加上目前GPU上的Cache机制非常落后导致了需要频繁的通信开销
的Work Stealing在GPU上是非常不划算得.
所以我个人认为在硬件架构没有更多的突破之前,OpenCL这种东西是没有任何生命力的.不要说CPU的并行与GPU之间差异巨大,就是不同的GPU之
间AMD与Nvidia两个也是各自为政,一个平台上跑得非常快的东西,在另外一个平台极大的可能是龟速.其最终的结果估计就是跟Java的
write once run everywhere一样是个大笑话.</p>
<p>On 3月22日, 下午2时06分, Guancheng Chen <a href="&#109;&#x61;&#105;&#108;&#x74;&#x6f;&#58;&#x5b;&#x63;&#x68;&#101;&#x6e;&#103;&#117;&#x61;&#x6e;&#x63;&#104;&#46;&#x2e;&#46;&#x40;&#x67;&#109;&#x61;&#x69;&#x6c;&#46;&#99;&#111;&#109;&#x5d;&#x28;&#x29;">&#x5b;&#x63;&#x68;&#101;&#x6e;&#103;&#117;&#x61;&#x6e;&#x63;&#104;&#46;&#x2e;&#46;&#x40;&#x67;&#109;&#x61;&#x69;&#x6c;&#46;&#99;&#111;&#109;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>On 3月22日, 上午2时20分, Tinyfool <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#x5b;&#x74;&#105;&#110;&#x79;&#x66;&#x2e;&#x2e;&#46;&#x40;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#93;&#x28;&#41;">&#x5b;&#x74;&#105;&#110;&#x79;&#x66;&#x2e;&#x2e;&#46;&#x40;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#109;&#97;&#x69;&#x6c;&#x74;&#x6f;&#58;&#x5b;&#106;&#101;&#x2e;&#x2e;&#x2e;&#64;&#x6c;&#x69;&#118;&#101;&#46;&#x63;&#x6f;&#x6d;&#93;&#40;&#41;">&#x5b;&#106;&#101;&#x2e;&#x2e;&#x2e;&#64;&#x6c;&#x69;&#118;&#101;&#46;&#x63;&#x6f;&#x6d;&#93;&#40;&#41;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#109;&#x61;&#x69;&#x6c;&#x74;&#x6f;&#58;&#x5b;&#x63;&#x68;&#101;&#x6e;&#x67;&#117;&#97;&#x6e;&#99;&#x68;&#46;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#x61;&#x69;&#108;&#46;&#99;&#x6f;&#x6d;&#93;&#x28;&#41;">&#x5b;&#x63;&#x68;&#101;&#x6e;&#x67;&#117;&#97;&#x6e;&#99;&#x68;&#46;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#x61;&#x69;&#108;&#46;&#99;&#x6f;&#x6d;&#93;&#x28;&#41;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#x6d;&#97;&#x69;&#x6c;&#x74;&#111;&#x3a;&#x5b;&#112;&#111;&#110;&#46;&#x2e;&#x2e;&#x40;&#103;&#111;&#111;&#x67;&#108;&#x65;&#103;&#114;&#x6f;&#117;&#112;&#x73;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#x29;">&#x5b;&#112;&#111;&#110;&#46;&#x2e;&#x2e;&#x40;&#103;&#111;&#111;&#x67;&#108;&#x65;&#103;&#114;&#x6f;&#117;&#112;&#x73;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#x29;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。...</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>阅读更多 &gt;&gt;
<a href="">显示删减掉的内容</a>
<img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-23</p>
<p>其他收件人：</p>
<p>教育以人为本，最终决定使用何种并行技术的还是程序员。目前业界对程序员并没有并行编程的技能要求，全民并行编程的时代什么时候才能到来？这是个问
题。</p>
<p>On 3月22日, 下午10时41分, windstorm <a href="&#x6d;&#97;&#x69;&#x6c;&#x74;&#x6f;&#x3a;&#x5b;&#108;&#105;&#x6b;&#x75;&#x6e;&#97;&#x72;&#109;&#x73;&#116;&#x72;&#46;&#x2e;&#x2e;&#64;&#x67;&#109;&#x61;&#105;&#108;&#x2e;&#x63;&#111;&#109;&#93;&#x28;&#x29;">&#x5b;&#108;&#105;&#x6b;&#x75;&#x6e;&#97;&#x72;&#109;&#x73;&#116;&#x72;&#46;&#x2e;&#x2e;&#64;&#x67;&#109;&#x61;&#105;&#108;&#x2e;&#x63;&#111;&#109;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>Larrabee当初我还是很看好的，它的架构比其他的更像一个统一的方案，可惜后来Intel自己经验不足搞不好。</p>
<p>OPENCL还是主要面向multimedia吧，CUDA/OpenCL在业界代表了流处理的方向，从GPU针对任务的角度讲是好的。其他的就算了。就像Al leluia说的那样，在硬件架构没有更多的突破之前，不说没有生命力，至少想取得任何进一步的突破都太难。</p>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>现在这个领域，你吹你的水，我吹我的水。至于谁的泡泡大，我看不清。所以真要选东西学，最好还是针对自己的application选靠谱。这也是并行编程教育难 的问题。大家需求完全不一样。</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Guancheng Chen <a href="&#109;&#97;&#105;&#x6c;&#116;&#x6f;&#x3a;&#91;&#x63;&#104;&#101;&#110;&#103;&#117;&#97;&#110;&#99;&#x68;&#46;&#x2e;&#x2e;&#x40;&#103;&#109;&#x61;&#105;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#93;&#40;&#41;">&#91;&#x63;&#104;&#101;&#110;&#103;&#117;&#97;&#110;&#99;&#x68;&#46;&#x2e;&#x2e;&#x40;&#103;&#109;&#x61;&#105;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#93;&#40;&#41;</a>:</p>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>&gt;
&gt;
&gt;</p>
<blockquote>
<blockquote>
<p>我觉得现有的OpenCL确实非常不成熟，但是从纯性能角度上来讲，我看好Heterogeneous架构，尽管它们的编程难度太大，就像前面提到的不
同架构需要做不同优化等。CPU的性能是latency-oriented，GPU是throughput-oriented,Intel的
Larrabee虽然现在来看不成功，但是业界都在朝着那个方向努力。</p>
<p>On 3月22日, 下午6时18分, windstorm <a href="&#x6d;&#x61;&#x69;&#108;&#x74;&#111;&#58;&#91;&#x6c;&#x69;&#107;&#117;&#110;&#x61;&#114;&#x6d;&#x73;&#116;&#114;&#x2e;&#x2e;&#46;&#64;&#x67;&#x6d;&#97;&#x69;&#108;&#x2e;&#99;&#111;&#x6d;&#93;&#40;&#41;">&#91;&#x6c;&#x69;&#107;&#117;&#110;&#x61;&#114;&#x6d;&#x73;&#116;&#114;&#x2e;&#x2e;&#46;&#64;&#x67;&#x6d;&#97;&#x69;&#108;&#x2e;&#99;&#111;&#x6d;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>实在是不能同意你更多......很早很早以前我就在这里和人争论过，GPU的并行计算平台不可能一统天下的。CUDA也不是救世主。OpenCL更不是。</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Alleluia <a href="&#x6d;&#97;&#x69;&#108;&#x74;&#111;&#58;&#x5b;&#x61;&#x6c;&#x6c;&#x75;&#108;&#x2e;&#46;&#x2e;&#x40;&#103;&#x6d;&#97;&#105;&#x6c;&#46;&#99;&#111;&#x6d;&#x5d;&#x28;&#x29;">&#x5b;&#x61;&#x6c;&#x6c;&#x75;&#108;&#x2e;&#46;&#x2e;&#x40;&#103;&#x6d;&#97;&#105;&#x6c;&#46;&#99;&#111;&#x6d;&#x5d;&#x28;&#x29;</a>:</p>
<blockquote>
<p>Parallelism 说到底是算法问题.Parallelism与Concurrency不同,Concurrency所面对的问题相对的单一可以
让一群有经验的专家来实现一套通用库或者语言来提供一个基本的编程框架.而在Parallelism上,具体的不同问题,其所需要并行的算法是根本不同
的.原因在于不同的问题,其内部的DataDependency的结构完全不同,不同的Data Dependency的结构,需要构造不同的算法.即
便是相同的Data Dependency,在不同的颗粒度下，在不同的硬件条件下所采用的算法也是完全不同的.因为一旦出现Data
Dependency也就意味着并行计算模块之间需要进行通信.从以计算节点为单位的分布式并行,到多核CPU上的Numa结构,到SIMD上的向量处
理器,其计算单元之间的通信手段,通信效率简直天差地别.比如说,在SMP上最常见的并行算法,work stealing也就是Intel的TBB,
是建立在两个条件下第一个是CPU的Cache机制上,这使得通常在内存的之间的数据搬运消耗非常小,第二个是SMP上计算单元相对的少,因此每个计算
单元被分配到的任务就相对的重。其开销远远大于通信的开销,因此这种机制在SMP上相对的划算.但是如果你要在GPU上做Work Stealing就
完全不可行,因为GPU的运算单元数量极多,被分配到的任务就相对来说的非常轻量,CUDA上的一个thread很多时候运算一次的时间不会超过
10us,而一次跨Block的线程之间的通信开销就往往要达到100us左右,再加上目前GPU上的Cache机制非常落后导致了需要频繁的通信开销
的Work Stealing在GPU上是非常不划算得.
所以我个人认为在硬件架构没有更多的突破之前,OpenCL这种东西是没有任何生命力的.不要说CPU的并行与GPU之间差异巨大,就是不同的GPU之
间AMD与Nvidia两个也是各自为政,一个平台上跑得非常快的东西,在另外一个平台极大的可能是龟速.其最终的结果估计就是跟Java的
write once run everywhere一样是个大笑话.</p>
<p>On 3月22日, 下午2时06分, Guancheng Chen <a href="&#109;&#97;&#x69;&#108;&#116;&#111;&#58;&#x5b;&#99;&#x68;&#101;&#x6e;&#x67;&#117;&#97;&#110;&#99;&#x68;&#x2e;&#x2e;&#46;&#64;&#103;&#x6d;&#x61;&#105;&#108;&#46;&#99;&#x6f;&#x6d;&#93;&#x28;&#41;">&#x5b;&#99;&#x68;&#101;&#x6e;&#x67;&#117;&#97;&#110;&#99;&#x68;&#x2e;&#x2e;&#46;&#64;&#103;&#x6d;&#x61;&#105;&#108;&#46;&#99;&#x6f;&#x6d;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>On 3月22日, 上午2时20分, Tinyfool <a href="&#x6d;&#x61;&#105;&#108;&#116;&#111;&#58;&#x5b;&#x74;&#x69;&#110;&#x79;&#x66;&#46;&#46;&#x2e;&#64;&#103;&#x6d;&#97;&#105;&#x6c;&#x2e;&#99;&#111;&#109;&#93;&#40;&#41;">&#x5b;&#x74;&#x69;&#110;&#x79;&#x66;&#46;&#46;&#x2e;&#64;&#103;&#x6d;&#97;&#105;&#x6c;&#x2e;&#99;&#111;&#109;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#109;&#x61;&#105;&#108;&#116;&#111;&#58;&#91;&#106;&#101;&#x2e;&#x2e;&#46;&#x40;&#108;&#105;&#118;&#101;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#40;&#41;">&#91;&#106;&#101;&#x2e;&#x2e;&#46;&#x40;&#108;&#105;&#118;&#101;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#40;&#41;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#x6d;&#97;&#x69;&#108;&#x74;&#x6f;&#x3a;&#x5b;&#x63;&#104;&#x65;&#110;&#103;&#x75;&#x61;&#110;&#99;&#x68;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#109;&#x61;&#105;&#x6c;&#46;&#99;&#111;&#109;&#93;&#x28;&#41;">&#x5b;&#x63;&#104;&#x65;&#110;&#103;&#x75;&#x61;&#110;&#99;&#x68;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#109;&#x61;&#105;&#x6c;&#46;&#99;&#111;&#109;&#93;&#x28;&#41;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#109;&#x61;&#x69;&#x6c;&#116;&#x6f;&#58;&#x5b;&#112;&#111;&#110;&#46;&#46;&#x2e;&#x40;&#x67;&#111;&#111;&#103;&#108;&#x65;&#x67;&#114;&#111;&#117;&#x70;&#115;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#41;">&#x5b;&#112;&#111;&#110;&#46;&#46;&#x2e;&#x40;&#x67;&#111;&#111;&#103;&#108;&#x65;&#x67;&#114;&#111;&#117;&#x70;&#115;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#41;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线...</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>阅读更多 &gt;&gt;
<a href="">显示删减掉的内容</a></p>
</blockquote>
<p><img src="" alt=""> windstorm <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-23</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>全民并行编程的时代，只有在全民能够并行编程的时候才会到来嘛，现在不是这个时候</p>
<p>我个人倾向于等待一个比较好的统一性架构。两条路：</p>
<p>一是某一个全新概念的提出，这个要看学术界的努力，而且在某种意义上讲，学术界搞出一个真正可行的并行架构的可能性比工业界更高。虽说今天多核的发展是工业界引领的，但是点子还是最早学术界提出的。典型的有几个：斯坦福的Hydra（1996），斯坦福的Imagine(2000)，MIT的RAW（2002），以及UT奥斯丁的TRIPS（2003）。在这个问题上，是不得不佩服美国的创造力，要知道直到在2000年左右，所有的人都还在为处理器频率按照摩尔定律翻翻而狂热，美国的顶尖研究员就早已看到了这条路的尽头并指出未来处理器的发展之路。</p>
<p>二是你用现有的架构，但是application引导。如果要找一个面向多application
domain的话，刚才说了，本来看好Larrabee，因为它的架构解决了CUDA一个很大的潜在问题，而且允许现有程序员不经过任何特殊training就上手编程，包括图形图像，科学计算，或者网络处理，各个领域。</p>
<p>不过可能就是因为这个solution的过于理想化导致结构的过于复杂化，才让其目前暂时流产。</p>
<p>总的来说，现在的问题就是软件发展不成熟，硬件发展不完善，你没法靠程序员决定使用什么并行技术，完全靠应用主导，这套技术在这个应用上如鱼得水，在那个应用上完全不罩，作为程序员，有什么办法？</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p><a href="http://www.kunli.info/" target="_blank">www.kunli.info</a>
<a href="http://twitter.com/cnbuff" target="_blank"><a href="http://twitter.com/cnbuff">http://twitter.com/cnbuff</a></a></p>
<p>2010/3/22 Guancheng Chen <a href="&#x6d;&#97;&#105;&#x6c;&#x74;&#111;&#58;&#91;&#99;&#x68;&#101;&#x6e;&#x67;&#117;&#46;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#x61;&#105;&#x6c;&#46;&#99;&#x6f;&#x6d;&#93;&#x28;&#x29;">&#91;&#99;&#x68;&#101;&#x6e;&#x67;&#117;&#46;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#x61;&#105;&#x6c;&#46;&#99;&#x6f;&#x6d;&#93;&#x28;&#x29;</a>:</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<blockquote>
<p>教育以人为本，最终决定使用何种并行技术的还是程序员。目前业界对程序员并没有并行编程的技能要求，全民并行编程的时代什么时候才能到来？这是个问
题。</p>
<p>On 3月22日, 下午10时41分, windstorm <a href="&#109;&#97;&#x69;&#108;&#x74;&#x6f;&#x3a;&#91;&#108;&#105;&#107;&#x75;&#110;&#x61;&#114;&#x6d;&#x73;&#116;&#x72;&#x2e;&#46;&#46;&#x40;&#x67;&#109;&#97;&#105;&#x6c;&#46;&#99;&#x6f;&#109;&#93;&#40;&#41;">&#91;&#108;&#105;&#107;&#x75;&#110;&#x61;&#114;&#x6d;&#x73;&#116;&#x72;&#x2e;&#46;&#46;&#x40;&#x67;&#109;&#97;&#105;&#x6c;&#46;&#99;&#x6f;&#109;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>Larrabee当初我还是很看好的，它的架构比其他的更像一个统一的方案，可惜后来Intel自己经验不足搞不好。</p>
<p>OPENCL还是主要面向multimedia吧，CUDA/OpenCL在业界代表了流处理的方向，从GPU针对任务的角度讲是好的。其他的就算了。就像Al leluia说的那样，在硬件架构没有更多的突破之前，不说没有生命力，至少想取得任何进一步的突破都太难。</p>
<p>现在这个领域，你吹你的水，我吹我的水。至于谁的泡泡大，我看不清。所以真要选东西学，最好还是针对自己的application选靠谱。这也是并行编程教育难 的问题。大家需求完全不一样。</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Guancheng Chen <a href="&#109;&#x61;&#105;&#108;&#116;&#111;&#58;&#x5b;&#x63;&#x68;&#101;&#x6e;&#103;&#x75;&#x61;&#x6e;&#99;&#104;&#46;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#97;&#105;&#108;&#46;&#99;&#x6f;&#109;&#93;&#x28;&#41;">&#x5b;&#x63;&#x68;&#101;&#x6e;&#103;&#x75;&#x61;&#x6e;&#99;&#104;&#46;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#97;&#105;&#108;&#46;&#99;&#x6f;&#109;&#93;&#x28;&#41;</a>:</p>
<blockquote>
<p>我觉得现有的OpenCL确实非常不成熟，但是从纯性能角度上来讲，我看好Heterogeneous架构，尽管它们的编程难度太大，就像前面提到的不
同架构需要做不同优化等。CPU的性能是latency-oriented，GPU是throughput-oriented,Intel的
Larrabee虽然现在来看不成功，但是业界都在朝着那个方向努力。</p>
<p>On 3月22日, 下午6时18分, windstorm <a href="&#109;&#x61;&#x69;&#108;&#116;&#x6f;&#x3a;&#x5b;&#108;&#x69;&#107;&#117;&#110;&#x61;&#114;&#109;&#115;&#116;&#114;&#46;&#x2e;&#x2e;&#64;&#103;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#109;&#93;&#40;&#41;">&#x5b;&#108;&#x69;&#107;&#117;&#110;&#x61;&#114;&#109;&#115;&#116;&#114;&#46;&#x2e;&#x2e;&#64;&#103;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#109;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>实在是不能同意你更多......很早很早以前我就在这里和人争论过，GPU的并行计算平台不可能一统天下的。CUDA也不是救世主。OpenCL更不是。</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Alleluia <a href="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#x6f;&#58;&#91;&#97;&#x6c;&#x6c;&#x75;&#108;&#46;&#x2e;&#x2e;&#64;&#103;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#109;&#x5d;&#x28;&#x29;">&#91;&#97;&#x6c;&#x6c;&#x75;&#108;&#46;&#x2e;&#x2e;&#64;&#103;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#109;&#x5d;&#x28;&#x29;</a>:</p>
<blockquote>
<p>Parallelism 说到底是算法问题.Parallelism与Concurrency不同,Concurrency所面对的问题相对的单一可以
让一群有经验的专家来实现一套通用库或者语言来提供一个基本的编程框架.而在Parallelism上,具体的不同问题,其所需要并行的算法是根本不同
的.原因在于不同的问题,其内部的DataDependency的结构完全不同,不同的Data Dependency的结构,需要构造不同的算法.即
便是相同的Data Dependency,在不同的颗粒度下，在不同的硬件条件下所采用的算法也是完全不同的.因为一旦出现Data
Dependency也就意味着并行计算模块之间需要进行通信.从以计算节点为单位的分布式并行,到多核CPU上的Numa结构,到SIMD上的向量处
理器,其计算单元之间的通信手段,通信效率简直天差地别.比如说,在SMP上最常见的并行算法,work stealing也就是Intel的TBB,
是建立在两个条件下第一个是CPU的Cache机制上,这使得通常在内存的之间的数据搬运消耗非常小,第二个是SMP上计算单元相对的少,因此每个计算
单元被分配到的任务就相对的重。其开销远远大于通信的开销,因此这种机制在SMP上相对的划算.但是如果你要在GPU上做Work Stealing就
完全不可行,因为GPU的运算单元数量极多,被分配到的任务就相对来说的非常轻量,CUDA上的一个thread很多时候运算一次的时间不会超过
10us,而一次跨Block的线程之间的通信开销就往往要达到100us左右,再加上目前GPU上的Cache机制非常落后导致了需要频繁的通信开销
的Work Stealing在GPU上是非常不划算得.
所以我个人认为在硬件架构没有更多的突破之前,OpenCL这种东西是没有任何生命力的.不要说CPU的并行与GPU之间差异巨大,就是不同的GPU之
间AMD与Nvidia两个也是各自为政,一个平台上跑得非常快的东西,在另外一个平台极大的可能是龟速.其最终的结果估计就是跟Java的
write once run everywhere一样是个大笑话.</p>
<p>On 3月22日, 下午2时06分, Guancheng Chen <a href="&#x6d;&#97;&#105;&#x6c;&#116;&#x6f;&#x3a;&#x5b;&#x63;&#x68;&#x65;&#110;&#x67;&#x75;&#97;&#110;&#99;&#104;&#46;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#97;&#105;&#108;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#x28;&#41;">&#x5b;&#x63;&#x68;&#x65;&#110;&#x67;&#x75;&#97;&#110;&#99;&#104;&#46;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#97;&#105;&#108;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>On 3月22日, 上午2时20分, Tinyfool <a href="&#109;&#97;&#105;&#x6c;&#x74;&#111;&#x3a;&#91;&#x74;&#105;&#110;&#121;&#x66;&#46;&#46;&#x2e;&#x40;&#x67;&#109;&#97;&#105;&#x6c;&#46;&#99;&#111;&#109;&#93;&#40;&#41;">&#91;&#x74;&#105;&#110;&#121;&#x66;&#46;&#46;&#x2e;&#x40;&#x67;&#109;&#97;&#105;&#x6c;&#46;&#99;&#111;&#109;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#109;&#x61;&#105;&#108;&#116;&#x6f;&#58;&#x5b;&#106;&#101;&#x2e;&#x2e;&#x2e;&#64;&#x6c;&#x69;&#x76;&#101;&#46;&#x63;&#111;&#109;&#93;&#40;&#x29;">&#x5b;&#106;&#101;&#x2e;&#x2e;&#x2e;&#64;&#x6c;&#x69;&#x76;&#101;&#46;&#x63;&#111;&#109;&#93;&#40;&#x29;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#109;&#x61;&#x69;&#x6c;&#116;&#x6f;&#x3a;&#91;&#x63;&#104;&#x65;&#x6e;&#x67;&#x75;&#97;&#x6e;&#x63;&#104;&#x2e;&#46;&#x2e;&#x40;&#103;&#109;&#x61;&#x69;&#108;&#x2e;&#x63;&#111;&#x6d;&#93;&#x28;&#x29;">&#91;&#x63;&#104;&#x65;&#x6e;&#x67;&#x75;&#97;&#x6e;&#x63;&#104;&#x2e;&#46;&#x2e;&#x40;&#103;&#109;&#x61;&#x69;&#108;&#x2e;&#x63;&#111;&#x6d;&#93;&#x28;&#x29;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#x6d;&#97;&#105;&#x6c;&#116;&#111;&#58;&#91;&#112;&#x6f;&#110;&#x2e;&#x2e;&#46;&#64;&#103;&#x6f;&#x6f;&#x67;&#108;&#x65;&#x67;&#114;&#x6f;&#117;&#x70;&#x73;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#40;&#x29;">&#91;&#112;&#x6f;&#110;&#x2e;&#x2e;&#46;&#64;&#103;&#x6f;&#x6f;&#x67;&#108;&#x65;&#x67;&#114;&#x6f;&#117;&#x70;&#x73;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#40;&#x29;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线...</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>阅读更多 &gt;&gt;</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p><a href="">显示删减掉的内容</a>
<img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-23</p>
<p>其他收件人：</p>
<p>恩</p>
<p>第二点其实我就是指程序员根据他自己的程序领域选择合适的并行技术。Top Language真是藏龙卧虎啊。你是在Boulder么?我一个大学女同
学在你那读MIS的phd</p>
<p>On 3月23日, 上午12时04分, windstorm <a href="&#109;&#97;&#105;&#x6c;&#x74;&#111;&#58;&#91;&#x6c;&#105;&#x6b;&#117;&#x6e;&#x61;&#x72;&#x6d;&#115;&#x74;&#114;&#46;&#46;&#46;&#64;&#103;&#x6d;&#97;&#x69;&#108;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#x28;&#x29;">&#91;&#x6c;&#105;&#x6b;&#117;&#x6e;&#x61;&#x72;&#x6d;&#115;&#x74;&#114;&#46;&#46;&#46;&#64;&#103;&#x6d;&#97;&#x69;&#108;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>全民并行编程的时代，只有在全民能够并行编程的时候才会到来嘛，现在不是这个时候</p>
<p>我个人倾向于等待一个比较好的统一性架构。两条路：</p>
<p>一是某一个全新概念的提出，这个要看学术界的努力，而且在某种意义上讲，学术界搞出一个真正可行的并行架构的可能性比工业界更高。虽说今天多核的发展是工业界引 领的，但是点子还是最早学术界提出的。典型的有几个：斯坦福的Hydra（1996），斯坦福的Imagine(2000)，MIT的RAW（2002），以及 UT奥斯丁的TRIPS（2003）。在这个问题上，是不得不佩服美国的创造力，要知道直到在2000年左右，所有的人都还在为处理器频率按照摩尔定律翻翻而狂 热，美国的顶尖研究员就早已看到了这条路的尽头并指出未来处理器的发展之路。</p>
<p>二是你用现有的架构，但是application引导。如果要找一个面向多application
domain的话，刚才说了，本来看好Larrabee，因为它的架构解决了CUDA一个很大的潜在问题，而且允许现有程序员不经过任何特殊training就 上手编程，包括图形图像，科学计算，或者网络处理，各个领域。</p>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>不过可能就是因为这个solution的过于理想化导致结构的过于复杂化，才让其目前暂时流产。</p>
<p>总的来说，现在的问题就是软件发展不成熟，硬件发展不完善，你没法靠程序员决定使用什么并行技术，完全靠应用主导，这套技术在这个应用上如鱼得水，在那个应用上 完全不罩，作为程序员，有什么办法？</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Guancheng Chen <a href="&#x6d;&#97;&#105;&#x6c;&#x74;&#x6f;&#58;&#91;&#99;&#104;&#101;&#x6e;&#x67;&#117;&#x61;&#x6e;&#x63;&#104;&#46;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#99;&#111;&#x6d;&#x5d;&#40;&#x29;">&#91;&#99;&#104;&#101;&#x6e;&#x67;&#117;&#x61;&#x6e;&#x63;&#104;&#46;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#99;&#111;&#x6d;&#x5d;&#40;&#x29;</a>:</p>
<blockquote>
<p>教育以人为本，最终决定使用何种并行技术的还是程序员。目前业界对程序员并没有并行编程的技能要求，全民并行编程的时代什么时候才能到来？这是个问
题。</p>
<p>On 3月22日, 下午10时41分, windstorm <a href="&#109;&#x61;&#x69;&#x6c;&#116;&#x6f;&#x3a;&#91;&#x6c;&#105;&#x6b;&#x75;&#x6e;&#x61;&#x72;&#x6d;&#115;&#x74;&#x72;&#x2e;&#46;&#x2e;&#x40;&#103;&#x6d;&#97;&#x69;&#108;&#46;&#99;&#x6f;&#109;&#93;&#x28;&#41;">&#91;&#x6c;&#105;&#x6b;&#x75;&#x6e;&#x61;&#x72;&#x6d;&#115;&#x74;&#x72;&#x2e;&#46;&#x2e;&#x40;&#103;&#x6d;&#97;&#x69;&#108;&#46;&#99;&#x6f;&#109;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>Larrabee当初我还是很看好的，它的架构比其他的更像一个统一的方案，可惜后来Intel自己经验不足搞不好。</p>
<p>OPENCL还是主要面向multimedia吧，CUDA/OpenCL在业界代表了流处理的方向，从GPU针对任务的角度讲是好的。其他的就算了。就像Al leluia说的那样，在硬件架构没有更多的突破之前，不说没有生命力，至少想取得任何进一步的突破都太难。</p>
<p>现在这个领域，你吹你的水，我吹我的水。至于谁的泡泡大，我看不清。所以真要选东西学，最好还是针对自己的application选靠谱。这也是并行编程教育难 的问题。大家需求完全不一样。</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Guancheng Chen <a href="&#x6d;&#97;&#105;&#108;&#116;&#111;&#x3a;&#x5b;&#99;&#104;&#x65;&#110;&#103;&#117;&#97;&#x6e;&#99;&#x68;&#46;&#46;&#x2e;&#x40;&#103;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#93;&#40;&#x29;">&#x5b;&#99;&#104;&#x65;&#110;&#103;&#117;&#97;&#x6e;&#99;&#x68;&#46;&#46;&#x2e;&#x40;&#103;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#93;&#40;&#x29;</a>:</p>
<blockquote>
<p>我觉得现有的OpenCL确实非常不成熟，但是从纯性能角度上来讲，我看好Heterogeneous架构，尽管它们的编程难度太大，就像前面提到的不
同架构需要做不同优化等。CPU的性能是latency-oriented，GPU是throughput-oriented,Intel的
Larrabee虽然现在来看不成功，但是业界都在朝着那个方向努力。</p>
<p>On 3月22日, 下午6时18分, windstorm <a href="&#109;&#97;&#105;&#x6c;&#116;&#111;&#58;&#x5b;&#108;&#105;&#x6b;&#x75;&#x6e;&#x61;&#x72;&#109;&#x73;&#116;&#114;&#x2e;&#x2e;&#46;&#x40;&#103;&#109;&#97;&#105;&#108;&#x2e;&#99;&#111;&#109;&#x5d;&#40;&#x29;">&#x5b;&#108;&#105;&#x6b;&#x75;&#x6e;&#x61;&#x72;&#109;&#x73;&#116;&#114;&#x2e;&#x2e;&#46;&#x40;&#103;&#109;&#97;&#105;&#108;&#x2e;&#99;&#111;&#109;&#x5d;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>实在是不能同意你更多......很早很早以前我就在这里和人争论过，GPU的并行计算平台不可能一统天下的。CUDA也不是救世主。OpenCL更不是。</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Alleluia <a href="&#109;&#x61;&#x69;&#108;&#116;&#111;&#x3a;&#91;&#x61;&#x6c;&#x6c;&#117;&#x6c;&#46;&#46;&#x2e;&#64;&#x67;&#x6d;&#x61;&#105;&#108;&#x2e;&#99;&#x6f;&#109;&#93;&#x28;&#41;">&#91;&#x61;&#x6c;&#x6c;&#117;&#x6c;&#46;&#46;&#x2e;&#64;&#x67;&#x6d;&#x61;&#105;&#108;&#x2e;&#99;&#x6f;&#109;&#93;&#x28;&#41;</a>:</p>
<blockquote>
<p>Parallelism 说到底是算法问题.Parallelism与Concurrency不同,Concurrency所面对的问题相对的单一可以
让一群有经验的专家来实现一套通用库或者语言来提供一个基本的编程框架.而在Parallelism上,具体的不同问题,其所需要并行的算法是根本不同
的.原因在于不同的问题,其内部的DataDependency的结构完全不同,不同的Data Dependency的结构,需要构造不同的算法.即
便是相同的Data Dependency,在不同的颗粒度下，在不同的硬件条件下所采用的算法也是完全不同的.因为一旦出现Data
Dependency也就意味着并行计算模块之间需要进行通信.从以计算节点为单位的分布式并行,到多核CPU上的Numa结构,到SIMD上的向量处
理器,其计算单元之间的通信手段,通信效率简直天差地别.比如说,在SMP上最常见的并行算法,work stealing也就是Intel的TBB,
是建立在两个条件下第一个是CPU的Cache机制上,这使得通常在内存的之间的数据搬运消耗非常小,第二个是SMP上计算单元相对的少,因此每个计算
单元被分配到的任务就相对的重。其开销远远大于通信的开销,因此这种机制在SMP上相对的划算.但是如果你要在GPU上做Work Stealing就
完全不可行,因为GPU的运算单元数量极多,被分配到的任务就相对来说的非常轻量,CUDA上的一个thread很多时候运算一次的时间不会超过
10us,而一次跨Block的线程之间的通信开销就往往要达到100us左右,再加上目前GPU上的Cache机制非常落后导致了需要频繁的通信开销
的Work Stealing在GPU上是非常不划算得.
所以我个人认为在硬件架构没有更多的突破之前,OpenCL这种东西是没有任何生命力的.不要说CPU的并行与GPU之间差异巨大,就是不同的GPU之
间AMD与Nvidia两个也是各自为政,一个平台上跑得非常快的东西,在另外一个平台极大的可能是龟速.其最终的结果估计就是跟Java的
write once run everywhere一样是个大笑话.</p>
<p>On 3月22日, 下午2时06分, Guancheng Chen <a href="&#109;&#97;&#105;&#108;&#x74;&#111;&#58;&#91;&#x63;&#x68;&#101;&#x6e;&#x67;&#x75;&#x61;&#x6e;&#x63;&#104;&#46;&#x2e;&#x2e;&#64;&#103;&#109;&#x61;&#105;&#108;&#x2e;&#99;&#x6f;&#109;&#93;&#x28;&#x29;">&#91;&#x63;&#x68;&#101;&#x6e;&#x67;&#x75;&#x61;&#x6e;&#x63;&#104;&#46;&#x2e;&#x2e;&#64;&#103;&#109;&#x61;&#105;&#108;&#x2e;&#99;&#x6f;&#109;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>On 3月22日, 上午2时20分, Tinyfool <a href="&#x6d;&#97;&#x69;&#x6c;&#x74;&#111;&#58;&#91;&#x74;&#105;&#110;&#x79;&#102;&#46;&#46;&#46;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#x63;&#x6f;&#x6d;&#93;&#x28;&#41;">&#91;&#x74;&#105;&#110;&#x79;&#102;&#46;&#46;&#46;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#x63;&#x6f;&#x6d;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#109;&#x61;&#105;&#108;&#116;&#x6f;&#x3a;&#x5b;&#x6a;&#101;&#46;&#x2e;&#46;&#64;&#108;&#105;&#x76;&#101;&#46;&#99;&#111;&#109;&#93;&#x28;&#x29;">&#x5b;&#x6a;&#101;&#46;&#x2e;&#46;&#64;&#108;&#105;&#x76;&#101;&#46;&#99;&#111;&#109;&#93;&#x28;&#x29;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#x6d;&#x61;&#105;&#108;&#x74;&#x6f;&#58;&#x5b;&#x63;&#104;&#x65;&#x6e;&#103;&#x75;&#97;&#110;&#99;&#104;&#x2e;&#46;&#46;&#x40;&#103;&#109;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#x28;&#x29;">&#x5b;&#x63;&#104;&#x65;&#x6e;&#103;&#x75;&#97;&#110;&#99;&#104;&#x2e;&#46;&#46;&#x40;&#103;&#109;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#x28;&#x29;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#x6d;&#x61;&#x69;&#108;&#116;&#111;&#58;&#x5b;&#x70;&#111;&#110;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#x6f;&#x6f;&#103;&#108;&#101;&#103;&#114;&#x6f;&#117;&#x70;&#115;&#x2e;&#x63;&#x6f;&#109;&#93;&#x28;&#x29;">&#x5b;&#x70;&#111;&#110;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#x6f;&#x6f;&#103;&#108;&#101;&#103;&#114;&#x6f;&#117;&#x70;&#115;&#x2e;&#x63;&#x6f;&#109;&#93;&#x28;&#x29;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器...</li>
</ol>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>阅读更多 &gt;&gt;
<a href="">显示删减掉的内容</a></p>
</blockquote>
<p><img src="" alt=""> Alleluia <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-23</p>
<p>其他收件人：</p>
<p>我不是搞体系结构的.但是我认为目前来说做Parallelism的人首先不是去熟悉什么API或者Libarary,而是要熟悉两样东西体系结构和算
法.没有这两样,几乎写不出什么高效率的并行程序.当然你的需求只是并行化循环这种简单的东西当然可以里例外.呵呵.
我觉得你最好放弃用GPGPU去搞遗留代码的想法.现在市面上的GPU产品无论是A记的还是N记的其编程架构与CPU完全不同,你不要想把一个循环简单
的porting到GPU上就能并行了.那是几乎不可能的,比如最简单的你如何处理branch?如果branch非常多,divergence会把速
度拖得比CPU版本还慢.你如何处理CPU代码里的数组随机访问,在GPU上无论是片上的还是片外的内存是不能随机访问的,最要命的是没有cache,
随机访问的代价极其高昂.你几乎需要把CPU上的代码面目全非地从新写一遍,遗留代码除了用作调试测试做结果比对之外几乎要全部抛弃.</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>On 3月23日, 上午6时42分, Guancheng Chen <a href="&#x6d;&#97;&#x69;&#108;&#x74;&#111;&#58;&#91;&#99;&#104;&#101;&#110;&#103;&#x75;&#97;&#110;&#x63;&#104;&#46;&#x2e;&#46;&#x40;&#x67;&#x6d;&#x61;&#105;&#x6c;&#46;&#x63;&#x6f;&#109;&#x5d;&#40;&#41;">&#91;&#99;&#104;&#101;&#110;&#103;&#x75;&#97;&#110;&#x63;&#104;&#46;&#x2e;&#46;&#x40;&#x67;&#x6d;&#x61;&#105;&#x6c;&#46;&#x63;&#x6f;&#109;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>恩 您也是搞体系结构的么？
现在我在跟瑞典这边的爱立信合作做毕设 不过对象不是他们的Erlang 而是传统的C/C++程序 下半年可能我也去搞GPGPU了 因为它的
data parallel模型对遗留代码的并行化很有搞头，现在我粗略的想法是把Compute sensitive的任务放一部分到GPU上去做，
当然我也对GPU目前的一些限制有所了解 但是一些探索工作还是非常值得的 到时候还想向前辈多多请教</p>
<p>On 3月22日, 下午11时30分, Alleluia <a href="&#x6d;&#x61;&#x69;&#x6c;&#116;&#x6f;&#x3a;&#x5b;&#97;&#x6c;&#x6c;&#x75;&#108;&#x2e;&#46;&#x2e;&#64;&#103;&#x6d;&#97;&#105;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#x29;">&#x5b;&#97;&#x6c;&#x6c;&#x75;&#108;&#x2e;&#46;&#x2e;&#64;&#103;&#x6d;&#97;&#105;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>Heterogeneous目前来看也是一个暂时的过渡性的东西. Heterogeneous架构最大的问题还是硬件,CPU和GPU之间的
PCIE2的bus带宽太窄了.在上面来回传递一次几M的内存可能需要化掉500us左右.如果一个算法本来就是在3-4ms级别的,你要用GPU去优
化,内存带宽的消耗就占了1/10,这是非常可怕的事情.或许像AMD那种Fusion架构是一种趋势,但是目前来说没有太大的进展.貌似AMD出了一
款混合的CPU,但是貌似还没有看到有多大的优势.
On 3月23日, 上午5时02分, Guancheng Chen <a href="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#111;&#x3a;&#91;&#99;&#x68;&#x65;&#x6e;&#x67;&#117;&#x61;&#110;&#99;&#x68;&#46;&#x2e;&#x2e;&#x40;&#x67;&#109;&#x61;&#105;&#108;&#46;&#99;&#x6f;&#109;&#93;&#x28;&#x29;">&#91;&#99;&#x68;&#x65;&#x6e;&#x67;&#117;&#x61;&#110;&#99;&#x68;&#46;&#x2e;&#x2e;&#x40;&#x67;&#109;&#x61;&#105;&#108;&#46;&#99;&#x6f;&#109;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>我觉得现有的OpenCL确实非常不成熟，但是从纯性能角度上来讲，我看好Heterogeneous架构，尽管它们的编程难度太大，就像前面提到的不
同架构需要做不同优化等。CPU的性能是latency-oriented，GPU是throughput-oriented,Intel的
Larrabee虽然现在来看不成功，但是业界都在朝着那个方向努力。</p>
<p>On 3月22日, 下午6时18分, windstorm <a href="&#x6d;&#x61;&#x69;&#x6c;&#116;&#111;&#x3a;&#91;&#108;&#x69;&#107;&#117;&#110;&#x61;&#x72;&#x6d;&#x73;&#116;&#114;&#x2e;&#x2e;&#46;&#64;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#46;&#99;&#x6f;&#x6d;&#93;&#x28;&#x29;">&#91;&#108;&#x69;&#107;&#117;&#110;&#x61;&#x72;&#x6d;&#x73;&#116;&#114;&#x2e;&#x2e;&#46;&#64;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#46;&#99;&#x6f;&#x6d;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>实在是不能同意你更多......很早很早以前我就在这里和人争论过，GPU的并行计算平台不可能一统天下的。CUDA也不是救世主。OpenCL更不是。</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Alleluia <a href="&#x6d;&#97;&#x69;&#108;&#116;&#111;&#x3a;&#91;&#97;&#108;&#108;&#x75;&#108;&#x2e;&#x2e;&#46;&#x40;&#x67;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#109;&#93;&#x28;&#41;">&#91;&#97;&#108;&#108;&#x75;&#108;&#x2e;&#x2e;&#46;&#x40;&#x67;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#109;&#93;&#x28;&#41;</a>:</p>
<blockquote>
<p>Parallelism 说到底是算法问题.Parallelism与Concurrency不同,Concurrency所面对的问题相对的单一可以
让一群有经验的专家来实现一套通用库或者语言来提供一个基本的编程框架.而在Parallelism上,具体的不同问题,其所需要并行的算法是根本不同
的.原因在于不同的问题,其内部的DataDependency的结构完全不同,不同的Data Dependency的结构,需要构造不同的算法.即
便是相同的Data Dependency,在不同的颗粒度下，在不同的硬件条件下所采用的算法也是完全不同的.因为一旦出现Data
Dependency也就意味着并行计算模块之间需要进行通信.从以计算节点为单位的分布式并行,到多核CPU上的Numa结构,到SIMD上的向量处
理器,其计算单元之间的通信手段,通信效率简直天差地别.比如说,在SMP上最常见的并行算法,work stealing也就是Intel的TBB,
是建立在两个条件下第一个是CPU的Cache机制上,这使得通常在内存的之间的数据搬运消耗非常小,第二个是SMP上计算单元相对的少,因此每个计算
单元被分配到的任务就相对的重。其开销远远大于通信的开销,因此这种机制在SMP上相对的划算.但是如果你要在GPU上做Work Stealing就
完全不可行,因为GPU的运算单元数量极多,被分配到的任务就相对来说的非常轻量,CUDA上的一个thread很多时候运算一次的时间不会超过
10us,而一次跨Block的线程之间的通信开销就往往要达到100us左右,再加上目前GPU上的Cache机制非常落后导致了需要频繁的通信开销
的Work Stealing在GPU上是非常不划算得.
所以我个人认为在硬件架构没有更多的突破之前,OpenCL这种东西是没有任何生命力的.不要说CPU的并行与GPU之间差异巨大,就是不同的GPU之
间AMD与Nvidia两个也是各自为政,一个平台上跑得非常快的东西,在另外一个平台极大的可能是龟速.其最终的结果估计就是跟Java的
write once run everywhere一样是个大笑话.</p>
<p>On 3月22日, 下午2时06分, Guancheng Chen <a href="&#x6d;&#x61;&#x69;&#108;&#x74;&#x6f;&#x3a;&#91;&#99;&#104;&#x65;&#110;&#x67;&#x75;&#x61;&#110;&#99;&#x68;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#105;&#108;&#46;&#99;&#x6f;&#109;&#x5d;&#x28;&#x29;">&#91;&#99;&#104;&#x65;&#110;&#x67;&#x75;&#x61;&#110;&#99;&#x68;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#105;&#108;&#46;&#99;&#x6f;&#109;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>On 3月22日, 上午2时20分, Tinyfool <a href="&#109;&#x61;&#x69;&#108;&#116;&#x6f;&#58;&#x5b;&#116;&#105;&#x6e;&#x79;&#102;&#x2e;&#x2e;&#46;&#x40;&#x67;&#x6d;&#x61;&#x69;&#108;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#41;">&#x5b;&#116;&#105;&#x6e;&#x79;&#102;&#x2e;&#x2e;&#46;&#x40;&#x67;&#x6d;&#x61;&#x69;&#108;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#x6d;&#97;&#x69;&#108;&#116;&#x6f;&#58;&#91;&#x6a;&#101;&#46;&#46;&#x2e;&#x40;&#x6c;&#x69;&#x76;&#x65;&#46;&#99;&#x6f;&#109;&#93;&#x28;&#41;">&#91;&#x6a;&#101;&#46;&#46;&#x2e;&#x40;&#x6c;&#x69;&#x76;&#x65;&#46;&#99;&#x6f;&#109;&#93;&#x28;&#41;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#x6d;&#97;&#x69;&#x6c;&#x74;&#x6f;&#x3a;&#x5b;&#99;&#x68;&#x65;&#110;&#103;&#x75;&#x61;&#110;&#x63;&#104;&#46;&#x2e;&#x2e;&#64;&#103;&#x6d;&#97;&#x69;&#x6c;&#46;&#99;&#111;&#109;&#93;&#x28;&#x29;">&#x5b;&#99;&#x68;&#x65;&#110;&#103;&#x75;&#x61;&#110;&#x63;&#104;&#46;&#x2e;&#x2e;&#64;&#103;&#x6d;&#97;&#x69;&#x6c;&#46;&#99;&#111;&#109;&#93;&#x28;&#x29;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#109;&#x61;&#x69;&#108;&#116;&#x6f;&#x3a;&#x5b;&#112;&#x6f;&#x6e;&#x2e;&#x2e;&#46;&#x40;&#103;&#111;&#111;&#x67;&#108;&#x65;&#103;&#114;&#x6f;&#x75;&#112;&#115;&#x2e;&#x63;&#x6f;&#109;&#93;&#40;&#41;">&#x5b;&#112;&#x6f;&#x6e;&#x2e;&#x2e;&#46;&#x40;&#103;&#111;&#111;&#x67;&#108;&#x65;&#103;&#114;&#x6f;&#x75;&#112;&#115;&#x2e;&#x63;&#x6f;&#109;&#93;&#40;&#41;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发</p>
</li>
</ol>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>...</p>
<p>阅读更多 &gt;&gt;
<a href="">显示删减掉的内容</a>
<img src="" alt=""> Alleluia <img src="" alt=""></p>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-23</p>
<p>其他收件人：</p>
<p>我当初就不看好Larrabee这个东西,想想一个Core上一个Decoder就要消耗1瓦的功率,32个捆起来这个Core的功率要多大啊.我觉得
一捆Arm棒在一起都比PII靠谱.</p>
<p>On 3月23日, 上午5时41分, windstorm <a href="&#x6d;&#x61;&#x69;&#x6c;&#116;&#x6f;&#x3a;&#x5b;&#x6c;&#x69;&#x6b;&#117;&#x6e;&#x61;&#114;&#x6d;&#x73;&#116;&#x72;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#97;&#x69;&#x6c;&#46;&#x63;&#x6f;&#109;&#93;&#x28;&#41;">&#x5b;&#x6c;&#x69;&#x6b;&#117;&#x6e;&#x61;&#114;&#x6d;&#x73;&#116;&#x72;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#97;&#x69;&#x6c;&#46;&#x63;&#x6f;&#109;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>Larrabee当初我还是很看好的，它的架构比其他的更像一个统一的方案，可惜后来Intel自己经验不足搞不好。</p>
<p>OPENCL还是主要面向multimedia吧，CUDA/OpenCL在业界代表了流处理的方向，从GPU针对任务的角度讲是好的。其他的就算了。就像Al leluia说的那样，在硬件架构没有更多的突破之前，不说没有生命力，至少想取得任何进一步的突破都太难。</p>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>现在这个领域，你吹你的水，我吹我的水。至于谁的泡泡大，我看不清。所以真要选东西学，最好还是针对自己的application选靠谱。这也是并行编程教育难 的问题。大家需求完全不一样。</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Guancheng Chen <a href="&#109;&#x61;&#105;&#108;&#116;&#111;&#x3a;&#x5b;&#x63;&#104;&#101;&#110;&#x67;&#117;&#x61;&#110;&#99;&#x68;&#46;&#46;&#x2e;&#64;&#103;&#x6d;&#97;&#105;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#41;">&#x5b;&#x63;&#104;&#101;&#110;&#x67;&#117;&#x61;&#110;&#99;&#x68;&#46;&#46;&#x2e;&#64;&#103;&#x6d;&#97;&#105;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#41;</a>:</p>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>&gt;
&gt;
&gt;</p>
<blockquote>
<blockquote>
<p>我觉得现有的OpenCL确实非常不成熟，但是从纯性能角度上来讲，我看好Heterogeneous架构，尽管它们的编程难度太大，就像前面提到的不
同架构需要做不同优化等。CPU的性能是latency-oriented，GPU是throughput-oriented,Intel的
Larrabee虽然现在来看不成功，但是业界都在朝着那个方向努力。</p>
<p>On 3月22日, 下午6时18分, windstorm <a href="&#x6d;&#x61;&#105;&#x6c;&#x74;&#x6f;&#58;&#91;&#108;&#x69;&#x6b;&#x75;&#x6e;&#97;&#x72;&#109;&#x73;&#x74;&#x72;&#46;&#46;&#46;&#x40;&#103;&#109;&#x61;&#x69;&#x6c;&#46;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#41;">&#91;&#108;&#x69;&#x6b;&#x75;&#x6e;&#97;&#x72;&#109;&#x73;&#x74;&#x72;&#46;&#46;&#46;&#x40;&#103;&#109;&#x61;&#x69;&#x6c;&#46;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>实在是不能同意你更多......很早很早以前我就在这里和人争论过，GPU的并行计算平台不可能一统天下的。CUDA也不是救世主。OpenCL更不是。</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Alleluia <a href="&#x6d;&#97;&#x69;&#x6c;&#116;&#x6f;&#58;&#x5b;&#97;&#x6c;&#108;&#117;&#108;&#46;&#46;&#x2e;&#x40;&#103;&#x6d;&#97;&#x69;&#108;&#46;&#x63;&#111;&#x6d;&#x5d;&#40;&#41;">&#x5b;&#97;&#x6c;&#108;&#117;&#108;&#46;&#46;&#x2e;&#x40;&#103;&#x6d;&#97;&#x69;&#108;&#46;&#x63;&#111;&#x6d;&#x5d;&#40;&#41;</a>:</p>
<blockquote>
<p>Parallelism 说到底是算法问题.Parallelism与Concurrency不同,Concurrency所面对的问题相对的单一可以
让一群有经验的专家来实现一套通用库或者语言来提供一个基本的编程框架.而在Parallelism上,具体的不同问题,其所需要并行的算法是根本不同
的.原因在于不同的问题,其内部的DataDependency的结构完全不同,不同的Data Dependency的结构,需要构造不同的算法.即
便是相同的Data Dependency,在不同的颗粒度下，在不同的硬件条件下所采用的算法也是完全不同的.因为一旦出现Data
Dependency也就意味着并行计算模块之间需要进行通信.从以计算节点为单位的分布式并行,到多核CPU上的Numa结构,到SIMD上的向量处
理器,其计算单元之间的通信手段,通信效率简直天差地别.比如说,在SMP上最常见的并行算法,work stealing也就是Intel的TBB,
是建立在两个条件下第一个是CPU的Cache机制上,这使得通常在内存的之间的数据搬运消耗非常小,第二个是SMP上计算单元相对的少,因此每个计算
单元被分配到的任务就相对的重。其开销远远大于通信的开销,因此这种机制在SMP上相对的划算.但是如果你要在GPU上做Work Stealing就
完全不可行,因为GPU的运算单元数量极多,被分配到的任务就相对来说的非常轻量,CUDA上的一个thread很多时候运算一次的时间不会超过
10us,而一次跨Block的线程之间的通信开销就往往要达到100us左右,再加上目前GPU上的Cache机制非常落后导致了需要频繁的通信开销
的Work Stealing在GPU上是非常不划算得.
所以我个人认为在硬件架构没有更多的突破之前,OpenCL这种东西是没有任何生命力的.不要说CPU的并行与GPU之间差异巨大,就是不同的GPU之
间AMD与Nvidia两个也是各自为政,一个平台上跑得非常快的东西,在另外一个平台极大的可能是龟速.其最终的结果估计就是跟Java的
write once run everywhere一样是个大笑话.</p>
<p>On 3月22日, 下午2时06分, Guancheng Chen <a href="&#109;&#x61;&#x69;&#x6c;&#116;&#x6f;&#58;&#x5b;&#x63;&#x68;&#101;&#110;&#103;&#x75;&#97;&#110;&#x63;&#x68;&#46;&#46;&#46;&#x40;&#103;&#109;&#x61;&#x69;&#108;&#x2e;&#x63;&#111;&#109;&#93;&#x28;&#41;">&#x5b;&#x63;&#x68;&#101;&#110;&#103;&#x75;&#97;&#110;&#x63;&#x68;&#46;&#46;&#46;&#x40;&#103;&#109;&#x61;&#x69;&#108;&#x2e;&#x63;&#111;&#109;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>On 3月22日, 上午2时20分, Tinyfool <a href="&#109;&#97;&#105;&#x6c;&#x74;&#111;&#x3a;&#x5b;&#x74;&#105;&#x6e;&#x79;&#x66;&#x2e;&#x2e;&#46;&#x40;&#x67;&#109;&#x61;&#x69;&#x6c;&#46;&#99;&#111;&#x6d;&#93;&#40;&#x29;">&#x5b;&#x74;&#105;&#x6e;&#x79;&#x66;&#x2e;&#x2e;&#46;&#x40;&#x67;&#109;&#x61;&#x69;&#x6c;&#46;&#99;&#111;&#x6d;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#x6d;&#97;&#105;&#108;&#116;&#x6f;&#58;&#91;&#106;&#101;&#46;&#x2e;&#46;&#64;&#108;&#x69;&#118;&#x65;&#46;&#99;&#x6f;&#109;&#x5d;&#x28;&#41;">&#91;&#106;&#101;&#46;&#x2e;&#46;&#64;&#108;&#x69;&#118;&#x65;&#46;&#99;&#x6f;&#109;&#x5d;&#x28;&#41;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#x6d;&#x61;&#x69;&#108;&#x74;&#111;&#x3a;&#x5b;&#99;&#x68;&#101;&#110;&#x67;&#x75;&#97;&#110;&#x63;&#104;&#x2e;&#46;&#x2e;&#64;&#x67;&#x6d;&#x61;&#105;&#x6c;&#46;&#99;&#x6f;&#109;&#x5d;&#x28;&#x29;">&#x5b;&#99;&#x68;&#101;&#110;&#x67;&#x75;&#97;&#110;&#x63;&#104;&#x2e;&#46;&#x2e;&#64;&#x67;&#x6d;&#x61;&#105;&#x6c;&#46;&#99;&#x6f;&#109;&#x5d;&#x28;&#x29;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#x6d;&#x61;&#x69;&#108;&#116;&#111;&#58;&#91;&#x70;&#111;&#x6e;&#46;&#x2e;&#46;&#x40;&#x67;&#x6f;&#x6f;&#103;&#108;&#101;&#x67;&#114;&#x6f;&#x75;&#112;&#x73;&#x2e;&#x63;&#111;&#109;&#x5d;&#40;&#41;">&#91;&#x70;&#111;&#x6e;&#46;&#x2e;&#46;&#x40;&#x67;&#x6f;&#x6f;&#103;&#108;&#101;&#x67;&#114;&#x6f;&#x75;&#112;&#x73;&#x2e;&#x63;&#111;&#109;&#x5d;&#40;&#41;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>...</p>
<p>阅读更多 &gt;&gt;
<a href="">显示删减掉的内容</a></p>
</blockquote>
<p><img src="" alt=""> windstorm <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-23</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>显然不是简单捆绑那么简单阿。</p>
<p>而且我看好它，并不是它将来会一统天下，而是说它相对革命性的架构部分程度上满足了线程完备，从而扩展了GPU的使用领域，所以我看好以它为代表的这种架构的发展。同类型的还有Sun当年的Rock和Niagara
1/2</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p><a href="http://www.kunli.info/" target="_blank">www.kunli.info</a>
<a href="http://twitter.com/cnbuff" target="_blank"><a href="http://twitter.com/cnbuff">http://twitter.com/cnbuff</a></a></p>
<p>2010/3/22 Alleluia <a href="&#x6d;&#97;&#x69;&#108;&#x74;&#111;&#x3a;&#91;&#x61;&#x6c;&#x6c;&#117;&#46;&#46;&#x2e;&#x40;&#x67;&#x6d;&#97;&#105;&#108;&#46;&#99;&#111;&#x6d;&#x5d;&#x28;&#41;">&#91;&#x61;&#x6c;&#x6c;&#117;&#46;&#46;&#x2e;&#x40;&#x67;&#x6d;&#97;&#105;&#108;&#46;&#99;&#111;&#x6d;&#x5d;&#x28;&#41;</a>:</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<blockquote>
<p>我当初就不看好Larrabee这个东西,想想一个Core上一个Decoder就要消耗1瓦的功率,32个捆起来这个Core的功率要多大啊.我觉得
一捆Arm棒在一起都比PII靠谱.</p>
<p>On 3月23日, 上午5时41分, windstorm <a href="&#109;&#97;&#105;&#x6c;&#x74;&#x6f;&#x3a;&#x5b;&#x6c;&#105;&#107;&#117;&#x6e;&#x61;&#x72;&#109;&#115;&#116;&#x72;&#46;&#46;&#46;&#x40;&#103;&#109;&#x61;&#105;&#x6c;&#46;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#x29;">&#x5b;&#x6c;&#105;&#107;&#117;&#x6e;&#x61;&#x72;&#109;&#115;&#116;&#x72;&#46;&#46;&#46;&#x40;&#103;&#109;&#x61;&#105;&#x6c;&#46;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>Larrabee当初我还是很看好的，它的架构比其他的更像一个统一的方案，可惜后来Intel自己经验不足搞不好。</p>
<p>OPENCL还是主要面向multimedia吧，CUDA/OpenCL在业界代表了流处理的方向，从GPU针对任务的角度讲是好的。其他的就算了。就像Al leluia说的那样，在硬件架构没有更多的突破之前，不说没有生命力，至少想取得任何进一步的突破都太难。</p>
<p>现在这个领域，你吹你的水，我吹我的水。至于谁的泡泡大，我看不清。所以真要选东西学，最好还是针对自己的application选靠谱。这也是并行编程教育难 的问题。大家需求完全不一样。</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Guancheng Chen <a href="&#x6d;&#x61;&#105;&#x6c;&#116;&#x6f;&#x3a;&#x5b;&#x63;&#104;&#101;&#110;&#103;&#117;&#97;&#x6e;&#99;&#x68;&#46;&#46;&#46;&#x40;&#x67;&#109;&#97;&#105;&#x6c;&#46;&#99;&#x6f;&#109;&#x5d;&#40;&#x29;">&#x5b;&#x63;&#104;&#101;&#110;&#103;&#117;&#97;&#x6e;&#99;&#x68;&#46;&#46;&#46;&#x40;&#x67;&#109;&#97;&#105;&#x6c;&#46;&#99;&#x6f;&#109;&#x5d;&#40;&#x29;</a>:</p>
<blockquote>
<p>我觉得现有的OpenCL确实非常不成熟，但是从纯性能角度上来讲，我看好Heterogeneous架构，尽管它们的编程难度太大，就像前面提到的不
同架构需要做不同优化等。CPU的性能是latency-oriented，GPU是throughput-oriented,Intel的
Larrabee虽然现在来看不成功，但是业界都在朝着那个方向努力。</p>
<p>On 3月22日, 下午6时18分, windstorm <a href="&#109;&#x61;&#x69;&#x6c;&#116;&#x6f;&#58;&#91;&#x6c;&#105;&#x6b;&#117;&#110;&#x61;&#x72;&#x6d;&#115;&#116;&#x72;&#46;&#x2e;&#46;&#64;&#103;&#109;&#x61;&#105;&#108;&#46;&#99;&#111;&#x6d;&#x5d;&#40;&#41;">&#91;&#x6c;&#105;&#x6b;&#117;&#110;&#x61;&#x72;&#x6d;&#115;&#116;&#x72;&#46;&#x2e;&#46;&#64;&#103;&#109;&#x61;&#105;&#108;&#46;&#99;&#111;&#x6d;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>实在是不能同意你更多......很早很早以前我就在这里和人争论过，GPU的并行计算平台不可能一统天下的。CUDA也不是救世主。OpenCL更不是。</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Alleluia <a href="&#x6d;&#97;&#x69;&#x6c;&#116;&#x6f;&#x3a;&#91;&#97;&#108;&#x6c;&#117;&#x6c;&#x2e;&#46;&#x2e;&#64;&#x67;&#x6d;&#97;&#x69;&#108;&#x2e;&#99;&#111;&#x6d;&#x5d;&#x28;&#x29;">&#91;&#97;&#108;&#x6c;&#117;&#x6c;&#x2e;&#46;&#x2e;&#64;&#x67;&#x6d;&#97;&#x69;&#108;&#x2e;&#99;&#111;&#x6d;&#x5d;&#x28;&#x29;</a>:</p>
<blockquote>
<p>Parallelism 说到底是算法问题.Parallelism与Concurrency不同,Concurrency所面对的问题相对的单一可以
让一群有经验的专家来实现一套通用库或者语言来提供一个基本的编程框架.而在Parallelism上,具体的不同问题,其所需要并行的算法是根本不同
的.原因在于不同的问题,其内部的DataDependency的结构完全不同,不同的Data Dependency的结构,需要构造不同的算法.即
便是相同的Data Dependency,在不同的颗粒度下，在不同的硬件条件下所采用的算法也是完全不同的.因为一旦出现Data
Dependency也就意味着并行计算模块之间需要进行通信.从以计算节点为单位的分布式并行,到多核CPU上的Numa结构,到SIMD上的向量处
理器,其计算单元之间的通信手段,通信效率简直天差地别.比如说,在SMP上最常见的并行算法,work stealing也就是Intel的TBB,
是建立在两个条件下第一个是CPU的Cache机制上,这使得通常在内存的之间的数据搬运消耗非常小,第二个是SMP上计算单元相对的少,因此每个计算
单元被分配到的任务就相对的重。其开销远远大于通信的开销,因此这种机制在SMP上相对的划算.但是如果你要在GPU上做Work Stealing就
完全不可行,因为GPU的运算单元数量极多,被分配到的任务就相对来说的非常轻量,CUDA上的一个thread很多时候运算一次的时间不会超过
10us,而一次跨Block的线程之间的通信开销就往往要达到100us左右,再加上目前GPU上的Cache机制非常落后导致了需要频繁的通信开销
的Work Stealing在GPU上是非常不划算得.
所以我个人认为在硬件架构没有更多的突破之前,OpenCL这种东西是没有任何生命力的.不要说CPU的并行与GPU之间差异巨大,就是不同的GPU之
间AMD与Nvidia两个也是各自为政,一个平台上跑得非常快的东西,在另外一个平台极大的可能是龟速.其最终的结果估计就是跟Java的
write once run everywhere一样是个大笑话.</p>
<p>On 3月22日, 下午2时06分, Guancheng Chen <a href="&#x6d;&#97;&#x69;&#108;&#x74;&#111;&#58;&#x5b;&#99;&#x68;&#x65;&#x6e;&#x67;&#x75;&#x61;&#110;&#x63;&#x68;&#x2e;&#46;&#x2e;&#x40;&#103;&#109;&#x61;&#x69;&#x6c;&#46;&#x63;&#x6f;&#109;&#93;&#x28;&#x29;">&#x5b;&#99;&#x68;&#x65;&#x6e;&#x67;&#x75;&#x61;&#110;&#x63;&#x68;&#x2e;&#46;&#x2e;&#x40;&#103;&#109;&#x61;&#x69;&#x6c;&#46;&#x63;&#x6f;&#109;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>On 3月22日, 上午2时20分, Tinyfool <a href="&#x6d;&#97;&#105;&#108;&#x74;&#x6f;&#x3a;&#x5b;&#116;&#105;&#110;&#121;&#x66;&#x2e;&#x2e;&#46;&#64;&#x67;&#x6d;&#x61;&#105;&#108;&#x2e;&#99;&#x6f;&#109;&#93;&#40;&#41;">&#x5b;&#116;&#105;&#110;&#121;&#x66;&#x2e;&#x2e;&#46;&#64;&#x67;&#x6d;&#x61;&#105;&#108;&#x2e;&#99;&#x6f;&#109;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#109;&#x61;&#x69;&#x6c;&#x74;&#x6f;&#58;&#91;&#106;&#101;&#46;&#46;&#x2e;&#64;&#108;&#x69;&#x76;&#x65;&#46;&#x63;&#111;&#x6d;&#93;&#40;&#x29;">&#91;&#106;&#101;&#46;&#46;&#x2e;&#64;&#108;&#x69;&#x76;&#x65;&#46;&#x63;&#111;&#x6d;&#93;&#40;&#x29;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#x6d;&#x61;&#105;&#x6c;&#x74;&#x6f;&#x3a;&#x5b;&#x63;&#104;&#x65;&#x6e;&#x67;&#117;&#97;&#110;&#99;&#x68;&#46;&#x2e;&#46;&#64;&#x67;&#x6d;&#97;&#105;&#x6c;&#46;&#x63;&#x6f;&#109;&#93;&#x28;&#41;">&#x5b;&#x63;&#104;&#x65;&#x6e;&#x67;&#117;&#97;&#110;&#99;&#x68;&#46;&#x2e;&#46;&#64;&#x67;&#x6d;&#97;&#105;&#x6c;&#46;&#x63;&#x6f;&#109;&#93;&#x28;&#41;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#109;&#97;&#x69;&#x6c;&#116;&#x6f;&#58;&#91;&#112;&#x6f;&#110;&#46;&#x2e;&#46;&#64;&#x67;&#x6f;&#x6f;&#103;&#108;&#101;&#x67;&#x72;&#111;&#x75;&#x70;&#115;&#46;&#99;&#x6f;&#109;&#x5d;&#x28;&#41;">&#91;&#112;&#x6f;&#110;&#46;&#x2e;&#46;&#64;&#x67;&#x6f;&#x6f;&#103;&#108;&#101;&#x67;&#x72;&#111;&#x75;&#x70;&#115;&#46;&#99;&#x6f;&#109;&#x5d;&#x28;&#41;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>...</p>
<p>阅读更多 &gt;&gt;</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p><a href="">显示删减掉的内容</a>
<img src="" alt=""> windstorm <img src="" alt=""></p>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-23</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>女生？LJJ？</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p><a href="http://www.kunli.info/" target="_blank">www.kunli.info</a>
<a href="http://twitter.com/cnbuff" target="_blank"><a href="http://twitter.com/cnbuff">http://twitter.com/cnbuff</a></a></p>
<p>2010/3/22 Guancheng Chen <a href="&#x6d;&#x61;&#105;&#108;&#116;&#111;&#58;&#x5b;&#x63;&#x68;&#101;&#x6e;&#x67;&#x75;&#46;&#46;&#46;&#64;&#103;&#x6d;&#97;&#x69;&#108;&#x2e;&#99;&#x6f;&#x6d;&#93;&#x28;&#41;">&#x5b;&#x63;&#x68;&#101;&#x6e;&#x67;&#x75;&#46;&#46;&#46;&#64;&#103;&#x6d;&#97;&#x69;&#108;&#x2e;&#99;&#x6f;&#x6d;&#93;&#x28;&#41;</a>:</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<blockquote>
<p>恩</p>
<p>第二点其实我就是指程序员根据他自己的程序领域选择合适的并行技术。Top Language真是藏龙卧虎啊。你是在Boulder么?我一个大学女同
学在你那读MIS的phd</p>
<p>On 3月23日, 上午12时04分, windstorm <a href="&#x6d;&#x61;&#x69;&#x6c;&#116;&#111;&#x3a;&#x5b;&#108;&#105;&#107;&#117;&#110;&#97;&#114;&#109;&#115;&#x74;&#x72;&#46;&#46;&#x2e;&#64;&#103;&#109;&#97;&#x69;&#108;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#40;&#41;">&#x5b;&#108;&#105;&#107;&#117;&#110;&#97;&#114;&#109;&#115;&#x74;&#x72;&#46;&#46;&#x2e;&#64;&#103;&#109;&#97;&#x69;&#108;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>全民并行编程的时代，只有在全民能够并行编程的时候才会到来嘛，现在不是这个时候</p>
<p>我个人倾向于等待一个比较好的统一性架构。两条路：</p>
<p>一是某一个全新概念的提出，这个要看学术界的努力，而且在某种意义上讲，学术界搞出一个真正可行的并行架构的可能性比工业界更高。虽说今天多核的发展是工业界引 领的，但是点子还是最早学术界提出的。典型的有几个：斯坦福的Hydra（1996），斯坦福的Imagine(2000)，MIT的RAW（2002），以及 UT奥斯丁的TRIPS（2003）。在这个问题上，是不得不佩服美国的创造力，要知道直到在2000年左右，所有的人都还在为处理器频率按照摩尔定律翻翻而狂 热，美国的顶尖研究员就早已看到了这条路的尽头并指出未来处理器的发展之路。</p>
<p>二是你用现有的架构，但是application引导。如果要找一个面向多application
domain的话，刚才说了，本来看好Larrabee，因为它的架构解决了CUDA一个很大的潜在问题，而且允许现有程序员不经过任何特殊training就 上手编程，包括图形图像，科学计算，或者网络处理，各个领域。</p>
<p>不过可能就是因为这个solution的过于理想化导致结构的过于复杂化，才让其目前暂时流产。</p>
<p>总的来说，现在的问题就是软件发展不成熟，硬件发展不完善，你没法靠程序员决定使用什么并行技术，完全靠应用主导，这套技术在这个应用上如鱼得水，在那个应用上 完全不罩，作为程序员，有什么办法？</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Guancheng Chen <a href="&#109;&#x61;&#105;&#x6c;&#x74;&#111;&#x3a;&#91;&#x63;&#104;&#101;&#x6e;&#x67;&#x75;&#x61;&#110;&#x63;&#104;&#46;&#46;&#x2e;&#x40;&#103;&#x6d;&#x61;&#x69;&#x6c;&#46;&#99;&#111;&#109;&#93;&#40;&#41;">&#91;&#x63;&#104;&#101;&#x6e;&#x67;&#x75;&#x61;&#110;&#x63;&#104;&#46;&#46;&#x2e;&#x40;&#103;&#x6d;&#x61;&#x69;&#x6c;&#46;&#99;&#111;&#109;&#93;&#40;&#41;</a>:</p>
<blockquote>
<p>教育以人为本，最终决定使用何种并行技术的还是程序员。目前业界对程序员并没有并行编程的技能要求，全民并行编程的时代什么时候才能到来？这是个问
题。</p>
<p>On 3月22日, 下午10时41分, windstorm <a href="&#109;&#x61;&#105;&#x6c;&#116;&#111;&#58;&#91;&#108;&#x69;&#x6b;&#x75;&#110;&#97;&#114;&#109;&#x73;&#x74;&#x72;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#109;&#x61;&#x69;&#108;&#x2e;&#x63;&#111;&#109;&#93;&#40;&#41;">&#91;&#108;&#x69;&#x6b;&#x75;&#110;&#97;&#114;&#109;&#x73;&#x74;&#x72;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#109;&#x61;&#x69;&#108;&#x2e;&#x63;&#111;&#109;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>Larrabee当初我还是很看好的，它的架构比其他的更像一个统一的方案，可惜后来Intel自己经验不足搞不好。</p>
<p>OPENCL还是主要面向multimedia吧，CUDA/OpenCL在业界代表了流处理的方向，从GPU针对任务的角度讲是好的。其他的就算了。就像Al leluia说的那样，在硬件架构没有更多的突破之前，不说没有生命力，至少想取得任何进一步的突破都太难。</p>
<p>现在这个领域，你吹你的水，我吹我的水。至于谁的泡泡大，我看不清。所以真要选东西学，最好还是针对自己的application选靠谱。这也是并行编程教育难 的问题。大家需求完全不一样。</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Guancheng Chen <a href="&#109;&#x61;&#105;&#x6c;&#116;&#111;&#x3a;&#x5b;&#x63;&#104;&#x65;&#110;&#x67;&#117;&#x61;&#x6e;&#99;&#x68;&#x2e;&#x2e;&#x2e;&#64;&#103;&#109;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#x29;">&#x5b;&#x63;&#104;&#x65;&#110;&#x67;&#117;&#x61;&#x6e;&#99;&#x68;&#x2e;&#x2e;&#x2e;&#64;&#103;&#109;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#x29;</a>:</p>
<blockquote>
<p>我觉得现有的OpenCL确实非常不成熟，但是从纯性能角度上来讲，我看好Heterogeneous架构，尽管它们的编程难度太大，就像前面提到的不
同架构需要做不同优化等。CPU的性能是latency-oriented，GPU是throughput-oriented,Intel的
Larrabee虽然现在来看不成功，但是业界都在朝着那个方向努力。</p>
<p>On 3月22日, 下午6时18分, windstorm <a href="&#109;&#97;&#x69;&#x6c;&#x74;&#x6f;&#x3a;&#x5b;&#x6c;&#105;&#107;&#117;&#110;&#x61;&#x72;&#109;&#x73;&#x74;&#114;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#x61;&#x69;&#108;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#41;">&#x5b;&#x6c;&#105;&#107;&#117;&#110;&#x61;&#x72;&#109;&#x73;&#x74;&#114;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#x61;&#x69;&#108;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>实在是不能同意你更多......很早很早以前我就在这里和人争论过，GPU的并行计算平台不可能一统天下的。CUDA也不是救世主。OpenCL更不是。</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Alleluia <a href="&#109;&#x61;&#105;&#108;&#116;&#x6f;&#x3a;&#x5b;&#97;&#x6c;&#108;&#117;&#x6c;&#x2e;&#x2e;&#46;&#64;&#103;&#x6d;&#97;&#105;&#108;&#46;&#x63;&#111;&#109;&#x5d;&#x28;&#41;">&#x5b;&#97;&#x6c;&#108;&#117;&#x6c;&#x2e;&#x2e;&#46;&#64;&#103;&#x6d;&#97;&#105;&#108;&#46;&#x63;&#111;&#109;&#x5d;&#x28;&#41;</a>:</p>
<blockquote>
<p>Parallelism 说到底是算法问题.Parallelism与Concurrency不同,Concurrency所面对的问题相对的单一可以
让一群有经验的专家来实现一套通用库或者语言来提供一个基本的编程框架.而在Parallelism上,具体的不同问题,其所需要并行的算法是根本不同
的.原因在于不同的问题,其内部的DataDependency的结构完全不同,不同的Data Dependency的结构,需要构造不同的算法.即
便是相同的Data Dependency,在不同的颗粒度下，在不同的硬件条件下所采用的算法也是完全不同的.因为一旦出现Data
Dependency也就意味着并行计算模块之间需要进行通信.从以计算节点为单位的分布式并行,到多核CPU上的Numa结构,到SIMD上的向量处
理器,其计算单元之间的通信手段,通信效率简直天差地别.比如说,在SMP上最常见的并行算法,work stealing也就是Intel的TBB,
是建立在两个条件下第一个是CPU的Cache机制上,这使得通常在内存的之间的数据搬运消耗非常小,第二个是SMP上计算单元相对的少,因此每个计算
单元被分配到的任务就相对的重。其开销远远大于通信的开销,因此这种机制在SMP上相对的划算.但是如果你要在GPU上做Work Stealing就
完全不可行,因为GPU的运算单元数量极多,被分配到的任务就相对来说的非常轻量,CUDA上的一个thread很多时候运算一次的时间不会超过
10us,而一次跨Block的线程之间的通信开销就往往要达到100us左右,再加上目前GPU上的Cache机制非常落后导致了需要频繁的通信开销
的Work Stealing在GPU上是非常不划算得.
所以我个人认为在硬件架构没有更多的突破之前,OpenCL这种东西是没有任何生命力的.不要说CPU的并行与GPU之间差异巨大,就是不同的GPU之
间AMD与Nvidia两个也是各自为政,一个平台上跑得非常快的东西,在另外一个平台极大的可能是龟速.其最终的结果估计就是跟Java的
write once run everywhere一样是个大笑话.</p>
<p>On 3月22日, 下午2时06分, Guancheng Chen <a href="&#x6d;&#x61;&#105;&#108;&#x74;&#111;&#x3a;&#x5b;&#99;&#x68;&#x65;&#x6e;&#103;&#x75;&#x61;&#110;&#99;&#104;&#46;&#46;&#46;&#64;&#103;&#109;&#97;&#105;&#x6c;&#x2e;&#99;&#x6f;&#109;&#x5d;&#x28;&#41;">&#x5b;&#99;&#x68;&#x65;&#x6e;&#103;&#x75;&#x61;&#110;&#99;&#104;&#46;&#46;&#46;&#64;&#103;&#109;&#97;&#105;&#x6c;&#x2e;&#99;&#x6f;&#109;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>On 3月22日, 上午2时20分, Tinyfool <a href="&#109;&#97;&#105;&#x6c;&#116;&#111;&#58;&#91;&#x74;&#105;&#x6e;&#x79;&#102;&#46;&#x2e;&#46;&#64;&#103;&#x6d;&#97;&#x69;&#108;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#40;&#x29;">&#91;&#x74;&#105;&#x6e;&#x79;&#102;&#46;&#x2e;&#46;&#64;&#103;&#x6d;&#97;&#x69;&#108;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#109;&#x61;&#x69;&#x6c;&#116;&#111;&#58;&#x5b;&#x6a;&#x65;&#x2e;&#x2e;&#x2e;&#x40;&#108;&#x69;&#x76;&#x65;&#x2e;&#99;&#111;&#x6d;&#93;&#x28;&#x29;">&#x5b;&#x6a;&#x65;&#x2e;&#x2e;&#x2e;&#x40;&#108;&#x69;&#x76;&#x65;&#x2e;&#99;&#111;&#x6d;&#93;&#x28;&#x29;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#109;&#x61;&#x69;&#x6c;&#x74;&#x6f;&#58;&#91;&#x63;&#x68;&#101;&#110;&#x67;&#117;&#97;&#110;&#99;&#104;&#46;&#x2e;&#46;&#x40;&#x67;&#109;&#97;&#105;&#108;&#x2e;&#99;&#x6f;&#x6d;&#93;&#40;&#x29;">&#91;&#x63;&#x68;&#101;&#110;&#x67;&#117;&#97;&#110;&#99;&#104;&#46;&#x2e;&#46;&#x40;&#x67;&#109;&#97;&#105;&#108;&#x2e;&#99;&#x6f;&#x6d;&#93;&#40;&#x29;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#109;&#x61;&#x69;&#x6c;&#x74;&#x6f;&#x3a;&#91;&#112;&#111;&#x6e;&#x2e;&#46;&#46;&#x40;&#x67;&#111;&#x6f;&#103;&#108;&#101;&#103;&#114;&#x6f;&#x75;&#x70;&#115;&#46;&#99;&#111;&#x6d;&#x5d;&#40;&#41;">&#91;&#112;&#111;&#x6e;&#x2e;&#46;&#46;&#x40;&#x67;&#111;&#x6f;&#103;&#108;&#101;&#103;&#114;&#x6f;&#x75;&#x70;&#115;&#46;&#99;&#111;&#x6d;&#x5d;&#40;&#41;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器...</li>
</ol>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>阅读更多 &gt;&gt;</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p><a href="">显示删减掉的内容</a></p>
</blockquote>
<p><img src="" alt=""> SevenCat <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-23</p>
<p>其他收件人：</p>
<p>大家在什么项目上用到并行编程？
<a href="">显示删减掉的内容</a>
<img src="" alt=""> qiaojie <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-23</p>
<p>其他收件人：</p>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1) = 5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？
<a href="">显示删减掉的内容</a></p>
<p><img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-23</p>
<p>其他收件人：</p>
<p>多谢大牛指教。我之所以提到并行化循环，是因为我以前实习过的公司的解决方案就是以data parallel模型的把循环并行化为主，其实新编写的代
码也可以用他们的技术。我之所以要提到遗留代码，是因为如果针对只对遗留代码的循环进行并行化就已经能取得比较可观的speedup(如果本身该循环是
热点，经过一些指导被程序员正确改成independent的之后即可并行化)，同时又不会引入太多的并行编程的复杂度。我原来测试它的时候一般1-3
个小时就能出结果，speedup在1.2~1.6之间(dual core, quad core 2.X)。</p>
<p>另外想请教您的实际工作中一般适用什么样的并行算法？任务分解(如TBB)？还是数据分解？</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>On 3月23日, 上午3时09分, Alleluia <a href="&#109;&#x61;&#105;&#x6c;&#116;&#111;&#x3a;&#x5b;&#x61;&#108;&#108;&#x75;&#108;&#46;&#46;&#x2e;&#x40;&#x67;&#109;&#97;&#x69;&#108;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#41;">&#x5b;&#x61;&#108;&#108;&#x75;&#108;&#46;&#46;&#x2e;&#x40;&#x67;&#109;&#97;&#x69;&#108;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>我不是搞体系结构的.但是我认为目前来说做Parallelism的人首先不是去熟悉什么API或者Libarary,而是要熟悉两样东西体系结构和算
法.没有这两样,几乎写不出什么高效率的并行程序.当然你的需求只是并行化循环这种简单的东西当然可以里例外.呵呵.
我觉得你最好放弃用GPGPU去搞遗留代码的想法.现在市面上的GPU产品无论是A记的还是N记的其编程架构与CPU完全不同,你不要想把一个循环简单
的porting到GPU上就能并行了.那是几乎不可能的,比如最简单的你如何处理branch?如果branch非常多,divergence会把速
度拖得比CPU版本还慢.你如何处理CPU代码里的数组随机访问,在GPU上无论是片上的还是片外的内存是不能随机访问的,最要命的是没有cache,
随机访问的代价极其高昂.你几乎需要把CPU上的代码面目全非地从新写一遍,遗留代码除了用作调试测试做结果比对之外几乎要全部抛弃.</p>
<p>On 3月23日, 上午6时42分, Guancheng Chen <a href="&#109;&#97;&#105;&#108;&#x74;&#111;&#58;&#x5b;&#x63;&#x68;&#x65;&#x6e;&#103;&#117;&#97;&#110;&#x63;&#104;&#x2e;&#x2e;&#46;&#64;&#103;&#x6d;&#x61;&#x69;&#x6c;&#46;&#x63;&#x6f;&#109;&#93;&#x28;&#x29;">&#x5b;&#x63;&#x68;&#x65;&#x6e;&#103;&#117;&#97;&#110;&#x63;&#104;&#x2e;&#x2e;&#46;&#64;&#103;&#x6d;&#x61;&#x69;&#x6c;&#46;&#x63;&#x6f;&#109;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>恩 您也是搞体系结构的么？
现在我在跟瑞典这边的爱立信合作做毕设 不过对象不是他们的Erlang 而是传统的C/C++程序 下半年可能我也去搞GPGPU了 因为它的
data parallel模型对遗留代码的并行化很有搞头，现在我粗略的想法是把Compute sensitive的任务放一部分到GPU上去做，
当然我也对GPU目前的一些限制有所了解 但是一些探索工作还是非常值得的 到时候还想向前辈多多请教</p>
<p>On 3月22日, 下午11时30分, Alleluia <a href="&#109;&#97;&#x69;&#108;&#x74;&#x6f;&#x3a;&#91;&#x61;&#x6c;&#x6c;&#x75;&#x6c;&#x2e;&#46;&#46;&#64;&#x67;&#109;&#97;&#x69;&#x6c;&#46;&#99;&#x6f;&#x6d;&#93;&#x28;&#41;">&#91;&#x61;&#x6c;&#x6c;&#x75;&#x6c;&#x2e;&#46;&#46;&#64;&#x67;&#109;&#97;&#x69;&#x6c;&#46;&#99;&#x6f;&#x6d;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>Heterogeneous目前来看也是一个暂时的过渡性的东西. Heterogeneous架构最大的问题还是硬件,CPU和GPU之间的
PCIE2的bus带宽太窄了.在上面来回传递一次几M的内存可能需要化掉500us左右.如果一个算法本来就是在3-4ms级别的,你要用GPU去优
化,内存带宽的消耗就占了1/10,这是非常可怕的事情.或许像AMD那种Fusion架构是一种趋势,但是目前来说没有太大的进展.貌似AMD出了一
款混合的CPU,但是貌似还没有看到有多大的优势.
On 3月23日, 上午5时02分, Guancheng Chen <a href="&#109;&#97;&#x69;&#x6c;&#116;&#111;&#x3a;&#x5b;&#x63;&#x68;&#101;&#110;&#103;&#117;&#97;&#110;&#x63;&#104;&#x2e;&#46;&#x2e;&#x40;&#103;&#109;&#x61;&#x69;&#108;&#46;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#41;">&#x5b;&#x63;&#x68;&#101;&#110;&#103;&#117;&#97;&#110;&#x63;&#104;&#x2e;&#46;&#x2e;&#x40;&#103;&#109;&#x61;&#x69;&#108;&#46;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>我觉得现有的OpenCL确实非常不成熟，但是从纯性能角度上来讲，我看好Heterogeneous架构，尽管它们的编程难度太大，就像前面提到的不
同架构需要做不同优化等。CPU的性能是latency-oriented，GPU是throughput-oriented,Intel的
Larrabee虽然现在来看不成功，但是业界都在朝着那个方向努力。</p>
<p>On 3月22日, 下午6时18分, windstorm <a href="&#109;&#x61;&#105;&#108;&#x74;&#111;&#58;&#x5b;&#108;&#x69;&#107;&#x75;&#110;&#x61;&#114;&#109;&#115;&#116;&#114;&#46;&#46;&#46;&#64;&#103;&#x6d;&#x61;&#x69;&#108;&#x2e;&#99;&#x6f;&#109;&#x5d;&#40;&#x29;">&#x5b;&#108;&#x69;&#107;&#x75;&#110;&#x61;&#114;&#109;&#115;&#116;&#114;&#46;&#46;&#46;&#64;&#103;&#x6d;&#x61;&#x69;&#108;&#x2e;&#99;&#x6f;&#109;&#x5d;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>实在是不能同意你更多......很早很早以前我就在这里和人争论过，GPU的并行计算平台不可能一统天下的。CUDA也不是救世主。OpenCL更不是。</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Alleluia <a href="&#x6d;&#x61;&#105;&#x6c;&#116;&#x6f;&#x3a;&#91;&#x61;&#108;&#108;&#x75;&#108;&#46;&#46;&#x2e;&#x40;&#103;&#109;&#97;&#105;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#x28;&#41;">&#91;&#x61;&#108;&#108;&#x75;&#108;&#46;&#46;&#x2e;&#x40;&#103;&#109;&#97;&#105;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#x28;&#41;</a>:</p>
<blockquote>
<p>Parallelism 说到底是算法问题.Parallelism与Concurrency不同,Concurrency所面对的问题相对的单一可以
让一群有经验的专家来实现一套通用库或者语言来提供一个基本的编程框架.而在Parallelism上,具体的不同问题,其所需要并行的算法是根本不同
的.原因在于不同的问题,其内部的DataDependency的结构完全不同,不同的Data Dependency的结构,需要构造不同的算法.即
便是相同的Data Dependency,在不同的颗粒度下，在不同的硬件条件下所采用的算法也是完全不同的.因为一旦出现Data
Dependency也就意味着并行计算模块之间需要进行通信.从以计算节点为单位的分布式并行,到多核CPU上的Numa结构,到SIMD上的向量处
理器,其计算单元之间的通信手段,通信效率简直天差地别.比如说,在SMP上最常见的并行算法,work stealing也就是Intel的TBB,
是建立在两个条件下第一个是CPU的Cache机制上,这使得通常在内存的之间的数据搬运消耗非常小,第二个是SMP上计算单元相对的少,因此每个计算
单元被分配到的任务就相对的重。其开销远远大于通信的开销,因此这种机制在SMP上相对的划算.但是如果你要在GPU上做Work Stealing就
完全不可行,因为GPU的运算单元数量极多,被分配到的任务就相对来说的非常轻量,CUDA上的一个thread很多时候运算一次的时间不会超过
10us,而一次跨Block的线程之间的通信开销就往往要达到100us左右,再加上目前GPU上的Cache机制非常落后导致了需要频繁的通信开销
的Work Stealing在GPU上是非常不划算得.
所以我个人认为在硬件架构没有更多的突破之前,OpenCL这种东西是没有任何生命力的.不要说CPU的并行与GPU之间差异巨大,就是不同的GPU之
间AMD与Nvidia两个也是各自为政,一个平台上跑得非常快的东西,在另外一个平台极大的可能是龟速.其最终的结果估计就是跟Java的
write once run everywhere一样是个大笑话.</p>
<p>On 3月22日, 下午2时06分, Guancheng Chen <a href="&#109;&#97;&#x69;&#108;&#x74;&#111;&#58;&#91;&#99;&#104;&#101;&#x6e;&#x67;&#x75;&#97;&#110;&#99;&#104;&#46;&#46;&#x2e;&#x40;&#x67;&#109;&#x61;&#x69;&#x6c;&#46;&#x63;&#111;&#109;&#x5d;&#40;&#x29;">&#91;&#99;&#104;&#101;&#x6e;&#x67;&#x75;&#97;&#110;&#99;&#104;&#46;&#46;&#x2e;&#x40;&#x67;&#109;&#x61;&#x69;&#x6c;&#46;&#x63;&#111;&#109;&#x5d;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>On 3月22日, 上午2时20分, Tinyfool <a href="&#109;&#x61;&#105;&#108;&#x74;&#x6f;&#x3a;&#x5b;&#116;&#x69;&#x6e;&#121;&#102;&#46;&#46;&#46;&#64;&#103;&#x6d;&#97;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#41;">&#x5b;&#116;&#x69;&#x6e;&#121;&#102;&#46;&#46;&#46;&#64;&#103;&#x6d;&#97;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#x6f;&#x3a;&#x5b;&#x6a;&#x65;&#46;&#x2e;&#46;&#x40;&#x6c;&#105;&#x76;&#101;&#x2e;&#99;&#111;&#109;&#x5d;&#x28;&#x29;">&#x5b;&#x6a;&#x65;&#46;&#x2e;&#46;&#x40;&#x6c;&#105;&#x76;&#101;&#x2e;&#99;&#111;&#109;&#x5d;&#x28;&#x29;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#109;&#97;&#105;&#x6c;&#x74;&#x6f;&#x3a;&#x5b;&#99;&#104;&#x65;&#110;&#x67;&#117;&#97;&#110;&#x63;&#x68;&#46;&#46;&#46;&#x40;&#103;&#x6d;&#97;&#x69;&#108;&#46;&#x63;&#111;&#x6d;&#x5d;&#x28;&#41;">&#x5b;&#99;&#104;&#x65;&#110;&#x67;&#117;&#97;&#110;&#x63;&#x68;&#46;&#46;&#46;&#x40;&#103;&#x6d;&#97;&#x69;&#108;&#46;&#x63;&#111;&#x6d;&#x5d;&#x28;&#41;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#x6d;&#97;&#105;&#x6c;&#x74;&#x6f;&#x3a;&#x5b;&#112;&#x6f;&#110;&#46;&#46;&#x2e;&#64;&#x67;&#111;&#x6f;&#x67;&#108;&#x65;&#103;&#x72;&#111;&#117;&#112;&#115;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#x28;&#x29;">&#x5b;&#112;&#x6f;&#110;&#46;&#46;&#x2e;&#64;&#x67;&#111;&#x6f;&#x67;&#108;&#x65;&#103;&#x72;&#111;&#117;&#112;&#115;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#x28;&#x29;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育...</p>
</li>
</ol>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>阅读更多 &gt;&gt;
<a href="">显示删减掉的内容</a>
<img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-23</p>
<p>其他收件人：</p>
<p>Yeap.</p>
<p>On 3月23日, 上午3时37分, windstorm <a href="&#x6d;&#97;&#105;&#x6c;&#116;&#111;&#58;&#x5b;&#x6c;&#105;&#x6b;&#x75;&#x6e;&#x61;&#x72;&#x6d;&#x73;&#x74;&#114;&#x2e;&#46;&#x2e;&#64;&#x67;&#109;&#97;&#x69;&#x6c;&#x2e;&#99;&#111;&#x6d;&#93;&#40;&#41;">&#x5b;&#x6c;&#105;&#x6b;&#x75;&#x6e;&#x61;&#x72;&#x6d;&#x73;&#x74;&#114;&#x2e;&#46;&#x2e;&#64;&#x67;&#109;&#97;&#x69;&#x6c;&#x2e;&#99;&#111;&#x6d;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>女生？LJJ？</p>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>&gt;</p>
<blockquote>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Guancheng Chen <a href="&#109;&#97;&#105;&#108;&#116;&#x6f;&#x3a;&#x5b;&#x63;&#x68;&#101;&#x6e;&#103;&#117;&#x61;&#x6e;&#99;&#104;&#46;&#x2e;&#46;&#x40;&#103;&#109;&#97;&#105;&#108;&#46;&#x63;&#x6f;&#109;&#x5d;&#x28;&#x29;">&#x5b;&#x63;&#x68;&#101;&#x6e;&#103;&#117;&#x61;&#x6e;&#99;&#104;&#46;&#x2e;&#46;&#x40;&#103;&#109;&#97;&#105;&#108;&#46;&#x63;&#x6f;&#109;&#x5d;&#x28;&#x29;</a>:</p>
<blockquote>
<p>恩</p>
<p>第二点其实我就是指程序员根据他自己的程序领域选择合适的并行技术。Top Language真是藏龙卧虎啊。你是在Boulder么?我一个大学女同
学在你那读MIS的phd</p>
<p>On 3月23日, 上午12时04分, windstorm <a href="&#x6d;&#x61;&#x69;&#108;&#x74;&#x6f;&#58;&#91;&#x6c;&#105;&#107;&#x75;&#110;&#97;&#x72;&#x6d;&#115;&#x74;&#x72;&#46;&#x2e;&#46;&#x40;&#103;&#109;&#x61;&#x69;&#108;&#46;&#x63;&#111;&#x6d;&#93;&#x28;&#x29;">&#91;&#x6c;&#105;&#107;&#x75;&#110;&#97;&#x72;&#x6d;&#115;&#x74;&#x72;&#46;&#x2e;&#46;&#x40;&#103;&#109;&#x61;&#x69;&#108;&#46;&#x63;&#111;&#x6d;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>全民并行编程的时代，只有在全民能够并行编程的时候才会到来嘛，现在不是这个时候</p>
<p>我个人倾向于等待一个比较好的统一性架构。两条路：</p>
<p>一是某一个全新概念的提出，这个要看学术界的努力，而且在某种意义上讲，学术界搞出一个真正可行的并行架构的可能性比工业界更高。虽说今天多核的发展是工业界引 领的，但是点子还是最早学术界提出的。典型的有几个：斯坦福的Hydra（1996），斯坦福的Imagine(2000)，MIT的RAW（2002），以及 UT奥斯丁的TRIPS（2003）。在这个问题上，是不得不佩服美国的创造力，要知道直到在2000年左右，所有的人都还在为处理器频率按照摩尔定律翻翻而狂 热，美国的顶尖研究员就早已看到了这条路的尽头并指出未来处理器的发展之路。</p>
<p>二是你用现有的架构，但是application引导。如果要找一个面向多application
domain的话，刚才说了，本来看好Larrabee，因为它的架构解决了CUDA一个很大的潜在问题，而且允许现有程序员不经过任何特殊training就 上手编程，包括图形图像，科学计算，或者网络处理，各个领域。</p>
<p>不过可能就是因为这个solution的过于理想化导致结构的过于复杂化，才让其目前暂时流产。</p>
<p>总的来说，现在的问题就是软件发展不成熟，硬件发展不完善，你没法靠程序员决定使用什么并行技术，完全靠应用主导，这套技术在这个应用上如鱼得水，在那个应用上 完全不罩，作为程序员，有什么办法？</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Guancheng Chen <a href="&#109;&#97;&#x69;&#108;&#x74;&#x6f;&#58;&#91;&#x63;&#x68;&#x65;&#x6e;&#103;&#117;&#97;&#110;&#x63;&#104;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#99;&#111;&#109;&#93;&#40;&#41;">&#91;&#x63;&#x68;&#x65;&#x6e;&#103;&#117;&#97;&#110;&#x63;&#104;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#99;&#111;&#109;&#93;&#40;&#41;</a>:</p>
<blockquote>
<p>教育以人为本，最终决定使用何种并行技术的还是程序员。目前业界对程序员并没有并行编程的技能要求，全民并行编程的时代什么时候才能到来？这是个问
题。</p>
<p>On 3月22日, 下午10时41分, windstorm <a href="&#109;&#97;&#x69;&#108;&#116;&#x6f;&#58;&#91;&#108;&#x69;&#x6b;&#117;&#x6e;&#97;&#x72;&#x6d;&#115;&#x74;&#x72;&#46;&#46;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#x69;&#108;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#41;">&#91;&#108;&#x69;&#x6b;&#117;&#x6e;&#97;&#x72;&#x6d;&#115;&#x74;&#x72;&#46;&#46;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#x69;&#108;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>Larrabee当初我还是很看好的，它的架构比其他的更像一个统一的方案，可惜后来Intel自己经验不足搞不好。</p>
<p>OPENCL还是主要面向multimedia吧，CUDA/OpenCL在业界代表了流处理的方向，从GPU针对任务的角度讲是好的。其他的就算了。就像Al leluia说的那样，在硬件架构没有更多的突破之前，不说没有生命力，至少想取得任何进一步的突破都太难。</p>
<p>现在这个领域，你吹你的水，我吹我的水。至于谁的泡泡大，我看不清。所以真要选东西学，最好还是针对自己的application选靠谱。这也是并行编程教育难 的问题。大家需求完全不一样。</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Guancheng Chen <a href="&#x6d;&#x61;&#105;&#x6c;&#x74;&#x6f;&#x3a;&#x5b;&#x63;&#x68;&#101;&#x6e;&#103;&#117;&#x61;&#110;&#99;&#x68;&#x2e;&#46;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#46;&#99;&#111;&#x6d;&#x5d;&#40;&#x29;">&#x5b;&#x63;&#x68;&#101;&#x6e;&#103;&#117;&#x61;&#110;&#99;&#x68;&#x2e;&#46;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#46;&#99;&#111;&#x6d;&#x5d;&#40;&#x29;</a>:</p>
<blockquote>
<p>我觉得现有的OpenCL确实非常不成熟，但是从纯性能角度上来讲，我看好Heterogeneous架构，尽管它们的编程难度太大，就像前面提到的不
同架构需要做不同优化等。CPU的性能是latency-oriented，GPU是throughput-oriented,Intel的
Larrabee虽然现在来看不成功，但是业界都在朝着那个方向努力。</p>
<p>On 3月22日, 下午6时18分, windstorm <a href="&#x6d;&#97;&#x69;&#108;&#x74;&#111;&#58;&#91;&#x6c;&#105;&#x6b;&#117;&#110;&#x61;&#114;&#x6d;&#x73;&#116;&#x72;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#40;&#41;">&#91;&#x6c;&#105;&#x6b;&#117;&#110;&#x61;&#114;&#x6d;&#x73;&#116;&#x72;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>实在是不能同意你更多......很早很早以前我就在这里和人争论过，GPU的并行计算平台不可能一统天下的。CUDA也不是救世主。OpenCL更不是。</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Alleluia <a href="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#111;&#x3a;&#91;&#97;&#x6c;&#x6c;&#117;&#x6c;&#x2e;&#46;&#46;&#64;&#x67;&#109;&#x61;&#105;&#108;&#46;&#99;&#111;&#x6d;&#x5d;&#x28;&#x29;">&#91;&#97;&#x6c;&#x6c;&#117;&#x6c;&#x2e;&#46;&#46;&#64;&#x67;&#109;&#x61;&#105;&#108;&#46;&#99;&#111;&#x6d;&#x5d;&#x28;&#x29;</a>:</p>
<blockquote>
<p>Parallelism 说到底是算法问题.Parallelism与Concurrency不同,Concurrency所面对的问题相对的单一可以
让一群有经验的专家来实现一套通用库或者语言来提供一个基本的编程框架.而在Parallelism上,具体的不同问题,其所需要并行的算法是根本不同
的.原因在于不同的问题,其内部的DataDependency的结构完全不同,不同的Data Dependency的结构,需要构造不同的算法.即
便是相同的Data Dependency,在不同的颗粒度下，在不同的硬件条件下所采用的算法也是完全不同的.因为一旦出现Data
Dependency也就意味着并行计算模块之间需要进行通信.从以计算节点为单位的分布式并行,到多核CPU上的Numa结构,到SIMD上的向量处
理器,其计算单元之间的通信手段,通信效率简直天差地别.比如说,在SMP上最常见的并行算法,work stealing也就是Intel的TBB,
是建立在两个条件下第一个是CPU的Cache机制上,这使得通常在内存的之间的数据搬运消耗非常小,第二个是SMP上计算单元相对的少,因此每个计算
单元被分配到的任务就相对的重。其开销远远大于通信的开销,因此这种机制在SMP上相对的划算.但是如果你要在GPU上做Work Stealing就
完全不可行,因为GPU的运算单元数量极多,被分配到的任务就相对来说的非常轻量,CUDA上的一个thread很多时候运算一次的时间不会超过
10us,而一次跨Block的线程之间的通信开销就往往要达到100us左右,再加上目前GPU上的Cache机制非常落后导致了需要频繁的通信开销
的Work Stealing在GPU上是非常不划算得.
所以我个人认为在硬件架构没有更多的突破之前,OpenCL这种东西是没有任何生命力的.不要说CPU的并行与GPU之间差异巨大,就是不同的GPU之
间AMD与Nvidia两个也是各自为政,一个平台上跑得非常快的东西,在另外一个平台极大的可能是龟速.其最终的结果估计就是跟Java的
write once run everywhere一样是个大笑话.</p>
<p>On 3月22日, 下午2时06分, Guancheng Chen <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#x3a;&#91;&#99;&#x68;&#x65;&#110;&#103;&#x75;&#97;&#x6e;&#x63;&#104;&#46;&#x2e;&#46;&#64;&#103;&#x6d;&#97;&#x69;&#x6c;&#46;&#99;&#111;&#x6d;&#x5d;&#40;&#x29;">&#91;&#99;&#x68;&#x65;&#110;&#103;&#x75;&#97;&#x6e;&#x63;&#104;&#46;&#x2e;&#46;&#64;&#103;&#x6d;&#97;&#x69;&#x6c;&#46;&#99;&#111;&#x6d;&#x5d;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>On 3月22日, 上午2时20分, Tinyfool <a href="&#109;&#97;&#x69;&#108;&#x74;&#x6f;&#x3a;&#x5b;&#116;&#x69;&#110;&#121;&#102;&#x2e;&#46;&#46;&#x40;&#x67;&#109;&#97;&#x69;&#x6c;&#46;&#x63;&#111;&#x6d;&#x5d;&#x28;&#41;">&#x5b;&#116;&#x69;&#110;&#121;&#102;&#x2e;&#46;&#46;&#x40;&#x67;&#109;&#97;&#x69;&#x6c;&#46;&#x63;&#111;&#x6d;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#109;&#97;&#x69;&#x6c;&#x74;&#x6f;&#58;&#x5b;&#x6a;&#x65;&#46;&#46;&#46;&#64;&#x6c;&#105;&#x76;&#101;&#x2e;&#x63;&#111;&#109;&#93;&#x28;&#41;">&#x5b;&#x6a;&#x65;&#46;&#46;&#46;&#64;&#x6c;&#105;&#x76;&#101;&#x2e;&#x63;&#111;&#109;&#93;&#x28;&#41;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#109;&#97;&#x69;&#108;&#116;&#x6f;&#x3a;&#91;&#x63;&#104;&#x65;&#110;&#103;&#117;&#x61;&#x6e;&#99;&#x68;&#46;&#46;&#x2e;&#64;&#x67;&#109;&#x61;&#105;&#108;&#46;&#x63;&#x6f;&#109;&#x5d;&#40;&#x29;">&#91;&#x63;&#104;&#x65;&#110;&#103;&#117;&#x61;&#x6e;&#99;&#x68;&#46;&#46;&#x2e;&#64;&#x67;&#109;&#x61;&#105;&#108;&#46;&#x63;&#x6f;&#109;&#x5d;&#40;&#x29;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#109;&#x61;&#105;&#108;&#116;&#111;&#58;&#x5b;&#x70;&#111;&#110;&#46;&#x2e;&#46;&#64;&#x67;&#x6f;&#111;&#103;&#x6c;&#101;&#x67;&#114;&#x6f;&#117;&#x70;&#115;&#46;&#99;&#x6f;&#x6d;&#x5d;&#40;&#41;">&#x5b;&#x70;&#111;&#110;&#46;&#x2e;&#46;&#64;&#x67;&#x6f;&#111;&#103;&#x6c;&#101;&#x67;&#114;&#x6f;&#117;&#x70;&#115;&#46;&#99;&#x6f;&#x6d;&#x5d;&#40;&#41;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，...</li>
</ol>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>阅读更多 &gt;&gt;
<a href="">显示删减掉的内容</a></p>
</blockquote>
<p><img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-23</p>
<p>其他收件人：</p>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>On 3月23日, 上午9时15分, qiaojie <a href="&#109;&#97;&#x69;&#x6c;&#116;&#x6f;&#x3a;&#91;&#113;&#105;&#97;&#x6f;&#46;&#x2e;&#46;&#64;&#x67;&#109;&#97;&#105;&#108;&#x2e;&#99;&#x6f;&#x6d;&#93;&#x28;&#x29;">&#91;&#113;&#105;&#97;&#x6f;&#46;&#x2e;&#46;&#64;&#x67;&#109;&#97;&#105;&#108;&#x2e;&#99;&#x6f;&#x6d;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1) =
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？
<a href="">显示删减掉的内容</a>
<img src="" alt=""> qiaojie <img src="" alt=""></p>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-23</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>目前正在写的是一个软件渲染器，采用了光栅化和光线跟踪混合算法，渲染算法已经完全并行化了，</p>
<p>在4核系统上基本可以达到线性加速比，更多核的系统暂时还没测试。kd-tree的构造暂时还没有并
行化，以后有空了再研究。</p>
<p>2010/3/23 Guancheng Chen <a href="&#x6d;&#97;&#x69;&#x6c;&#116;&#x6f;&#58;&#91;&#99;&#104;&#x65;&#110;&#103;&#117;&#x2e;&#46;&#46;&#x40;&#103;&#109;&#x61;&#105;&#108;&#x2e;&#99;&#111;&#x6d;&#93;&#x28;&#x29;">&#91;&#99;&#104;&#x65;&#110;&#103;&#117;&#x2e;&#46;&#46;&#x40;&#103;&#109;&#x61;&#105;&#108;&#x2e;&#99;&#111;&#x6d;&#93;&#x28;&#x29;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？
On 3月23日, 上午9时15分, qiaojie <a href="&#x6d;&#97;&#x69;&#x6c;&#116;&#111;&#58;&#91;&#113;&#105;&#97;&#x6f;&#46;&#x2e;&#46;&#x40;&#x67;&#x6d;&#97;&#105;&#x6c;&#x2e;&#99;&#111;&#109;&#93;&#x28;&#41;">&#91;&#113;&#105;&#97;&#x6f;&#46;&#x2e;&#46;&#x40;&#x67;&#x6d;&#97;&#105;&#x6c;&#x2e;&#99;&#111;&#109;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1) =
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a></p>
<p><img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-24</p>
<p>其他收件人：</p>
<p>Nice 大胆预测Linear speedup应该是每个程序员十年后的目标 呵呵</p>
<p>On 3月23日, 上午10时43分, qiaojie <a href="&#109;&#x61;&#x69;&#x6c;&#116;&#x6f;&#58;&#91;&#113;&#105;&#97;&#111;&#x2e;&#46;&#46;&#64;&#103;&#x6d;&#97;&#105;&#108;&#x2e;&#99;&#111;&#109;&#93;&#40;&#41;">&#91;&#113;&#105;&#97;&#111;&#x2e;&#46;&#46;&#64;&#103;&#x6d;&#97;&#105;&#108;&#x2e;&#99;&#111;&#109;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>目前正在写的是一个软件渲染器，采用了光栅化和光线跟踪混合算法，渲染算法已经完全并行化了，
在4核系统上基本可以达到线性加速比，更多核的系统暂时还没测试。kd-tree的构造暂时还没有并
行化，以后有空了再研究。</p>
<p>2010/3/23 Guancheng Chen <a href="&#x6d;&#97;&#x69;&#x6c;&#116;&#x6f;&#x3a;&#91;&#x63;&#104;&#x65;&#x6e;&#103;&#117;&#x61;&#110;&#x63;&#x68;&#x2e;&#x2e;&#46;&#x40;&#x67;&#x6d;&#x61;&#105;&#x6c;&#46;&#99;&#111;&#x6d;&#x5d;&#x28;&#x29;">&#91;&#x63;&#104;&#x65;&#x6e;&#103;&#117;&#x61;&#110;&#x63;&#x68;&#x2e;&#x2e;&#46;&#x40;&#x67;&#x6d;&#x61;&#105;&#x6c;&#46;&#99;&#111;&#x6d;&#x5d;&#x28;&#x29;</a></p>
</blockquote>
<p>&gt;
&gt;
&gt;</p>
<blockquote>
<blockquote>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？</p>
<p>On 3月23日, 上午9时15分, qiaojie <a href="&#109;&#x61;&#105;&#108;&#x74;&#111;&#x3a;&#91;&#113;&#105;&#97;&#111;&#46;&#46;&#x2e;&#64;&#103;&#109;&#x61;&#x69;&#108;&#46;&#99;&#x6f;&#109;&#x5d;&#x28;&#41;">&#91;&#113;&#105;&#97;&#111;&#46;&#46;&#x2e;&#64;&#103;&#109;&#x61;&#x69;&#108;&#46;&#99;&#x6f;&#109;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1) =
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？</p>
</blockquote>
<p> To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> longshanksmo <img src="" alt=""></p>
</blockquote>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-24</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<h2 id="-cerl-2-0-">凑个热闹，也来个广告：CERL 2.0初具雏形。</h2>
<p>反者道之动，弱者道之用
<a href="">longsh...@gmail.com</a>
<a href="http://blog.csdn.net/longshanks/" target="_blank"><a href="http://blog.csdn.net/longshanks/">http://blog.csdn.net/longshanks/</a></a>
wave开通
<a href="">显示删减掉的内容</a></p>
<p><img src="" alt=""> qiaojie <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-24</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>不是所有的程序都需要并行化的，能用串行化解决的问题没必要并行，所以即使将来many-core系统成为主流，大部分程序员也没必要去搞并行计算。</p>
<p>我觉得未来的主流应该是类似cell这样一颗全功能核心带众多协处理核心的异构系统，这样才能达到最优的 性能/核心面积比。
2010/3/24 Guancheng Chen <a href="&#x6d;&#x61;&#105;&#x6c;&#116;&#111;&#x3a;&#x5b;&#x63;&#104;&#x65;&#110;&#x67;&#x75;&#46;&#46;&#x2e;&#x40;&#103;&#109;&#97;&#105;&#108;&#x2e;&#99;&#111;&#x6d;&#93;&#40;&#x29;">&#x5b;&#x63;&#104;&#x65;&#110;&#x67;&#x75;&#46;&#46;&#x2e;&#x40;&#103;&#109;&#97;&#105;&#108;&#x2e;&#99;&#111;&#x6d;&#93;&#40;&#x29;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>Nice 大胆预测Linear speedup应该是每个程序员十年后的目标 呵呵
On 3月23日, 上午10时43分, qiaojie <a href="&#x6d;&#97;&#x69;&#108;&#116;&#111;&#x3a;&#x5b;&#x71;&#x69;&#97;&#111;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#109;&#x61;&#105;&#x6c;&#46;&#99;&#111;&#109;&#93;&#40;&#x29;">&#x5b;&#x71;&#x69;&#97;&#111;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#109;&#x61;&#105;&#x6c;&#46;&#99;&#111;&#109;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>目前正在写的是一个软件渲染器，采用了光栅化和光线跟踪混合算法，渲染算法已经完全并行化了，
在4核系统上基本可以达到线性加速比，更多核的系统暂时还没测试。kd-tree的构造暂时还没有并
行化，以后有空了再研究。</p>
<p>2010/3/23 Guancheng Chen <a href="&#109;&#97;&#105;&#x6c;&#x74;&#111;&#58;&#x5b;&#99;&#104;&#x65;&#110;&#x67;&#117;&#97;&#x6e;&#99;&#104;&#x2e;&#46;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#93;&#40;&#x29;">&#x5b;&#99;&#104;&#x65;&#110;&#x67;&#117;&#97;&#x6e;&#99;&#104;&#x2e;&#46;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#93;&#40;&#x29;</a></p>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>&gt;
&gt;
&gt;</p>
<blockquote>
<blockquote>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？</p>
<p>On 3月23日, 上午9时15分, qiaojie <a href="&#x6d;&#97;&#x69;&#x6c;&#x74;&#x6f;&#58;&#91;&#x71;&#105;&#97;&#111;&#46;&#x2e;&#46;&#64;&#x67;&#109;&#97;&#x69;&#x6c;&#46;&#99;&#x6f;&#x6d;&#x5d;&#40;&#x29;">&#91;&#x71;&#105;&#97;&#111;&#46;&#x2e;&#46;&#64;&#x67;&#109;&#97;&#x69;&#x6c;&#46;&#99;&#x6f;&#x6d;&#x5d;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1) =
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？</p>
</blockquote>
<p> To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> 机械唯物主义 : linjunhalida <img src="" alt=""></p>
</blockquote>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-24</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>我猜测未来的主流是数据中心，动态分配运算，存储资源。CPU，内存集群。
加上本地终端，运行一些本地进程，比如GUI，实时视频采集和分析什么的。CPU＋GPU。
根据需求和成本来考虑程序在本地或者数据中心。
其实好像这就是现在的状况？
未来的状况还是要局限于成本和性能，
如果瓶颈在数据传输，那么中心化趋势会很明显。
如果瓶颈在运算，那么程序员要花很多时间在并行处理上。
2010/3/24 qiaojie <a href="&#109;&#x61;&#x69;&#108;&#x74;&#111;&#58;&#x5b;&#113;&#105;&#97;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#109;&#97;&#105;&#108;&#x2e;&#x63;&#111;&#109;&#93;&#40;&#41;">&#x5b;&#113;&#105;&#97;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#109;&#97;&#105;&#108;&#x2e;&#x63;&#111;&#109;&#93;&#40;&#41;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>不是所有的程序都需要并行化的，能用串行化解决的问题没必要并行，所以即使将来many-core系统成为主流，大部分程序员也没必要去搞并行计算。</p>
<p>我觉得未来的主流应该是类似cell这样一颗全功能核心带众多协处理核心的异构系统，这样才能达到最优的 性能/核心面积比。
2010/3/24 Guancheng Chen <a href="&#x6d;&#x61;&#x69;&#x6c;&#116;&#x6f;&#58;&#91;&#x63;&#104;&#x65;&#110;&#103;&#x75;&#x2e;&#46;&#x2e;&#64;&#x67;&#109;&#x61;&#x69;&#108;&#46;&#99;&#x6f;&#x6d;&#93;&#x28;&#x29;">&#91;&#x63;&#104;&#x65;&#110;&#103;&#x75;&#x2e;&#46;&#x2e;&#64;&#x67;&#109;&#x61;&#x69;&#108;&#46;&#99;&#x6f;&#x6d;&#93;&#x28;&#x29;</a></p>
<p>Nice 大胆预测Linear speedup应该是每个程序员十年后的目标 呵呵
On 3月23日, 上午10时43分, qiaojie <a href="&#109;&#x61;&#x69;&#x6c;&#116;&#x6f;&#x3a;&#x5b;&#113;&#105;&#x61;&#111;&#x2e;&#46;&#46;&#x40;&#x67;&#x6d;&#97;&#105;&#x6c;&#46;&#x63;&#x6f;&#109;&#93;&#x28;&#x29;">&#x5b;&#113;&#105;&#x61;&#111;&#x2e;&#46;&#46;&#x40;&#x67;&#x6d;&#97;&#105;&#x6c;&#46;&#x63;&#x6f;&#109;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>目前正在写的是一个软件渲染器，采用了光栅化和光线跟踪混合算法，渲染算法已经完全并行化了，
在4核系统上基本可以达到线性加速比，更多核的系统暂时还没测试。kd-tree的构造暂时还没有并
行化，以后有空了再研究。</p>
<p>2010/3/23 Guancheng Chen <a href="&#109;&#97;&#105;&#x6c;&#x74;&#111;&#x3a;&#x5b;&#x63;&#104;&#x65;&#x6e;&#103;&#117;&#x61;&#x6e;&#99;&#104;&#46;&#x2e;&#x2e;&#x40;&#x67;&#109;&#97;&#105;&#108;&#x2e;&#99;&#111;&#x6d;&#x5d;&#40;&#x29;">&#x5b;&#x63;&#104;&#x65;&#x6e;&#103;&#117;&#x61;&#x6e;&#99;&#104;&#46;&#x2e;&#x2e;&#x40;&#x67;&#109;&#97;&#105;&#108;&#x2e;&#99;&#111;&#x6d;&#x5d;&#40;&#x29;</a></p>
<blockquote>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？</p>
<p>On 3月23日, 上午9时15分, qiaojie <a href="&#109;&#97;&#x69;&#108;&#x74;&#x6f;&#58;&#x5b;&#113;&#x69;&#x61;&#x6f;&#46;&#46;&#x2e;&#x40;&#x67;&#x6d;&#97;&#105;&#108;&#46;&#99;&#111;&#x6d;&#x5d;&#x28;&#x29;">&#x5b;&#113;&#x69;&#x61;&#x6f;&#46;&#46;&#x2e;&#x40;&#x67;&#x6d;&#97;&#105;&#108;&#46;&#99;&#111;&#x6d;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1) =
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？</p>
</blockquote>
<p> To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a></p>
<p><img src="" alt=""> Hongzh...@gmail.com <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-24</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>异构平台如果编程复杂度降不下来的话很难流行起来。cell已经死了...
2010/3/24 qiaojie <a href="&#109;&#x61;&#x69;&#108;&#x74;&#111;&#x3a;&#x5b;&#113;&#x69;&#97;&#46;&#x2e;&#46;&#64;&#x67;&#x6d;&#97;&#x69;&#108;&#46;&#99;&#111;&#x6d;&#93;&#40;&#41;">&#x5b;&#113;&#x69;&#97;&#46;&#x2e;&#46;&#64;&#x67;&#x6d;&#97;&#x69;&#108;&#46;&#99;&#111;&#x6d;&#93;&#40;&#41;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>不是所有的程序都需要并行化的，能用串行化解决的问题没必要并行，所以即使将来many-core系统成为主流，大部分程序员也没必要去搞并行计算。</p>
<p>我觉得未来的主流应该是类似cell这样一颗全功能核心带众多协处理核心的异构系统，这样才能达到最优的 性能/核心面积比。
2010/3/24 Guancheng Chen <a href="&#x6d;&#x61;&#105;&#x6c;&#x74;&#x6f;&#58;&#x5b;&#99;&#x68;&#101;&#110;&#103;&#x75;&#46;&#x2e;&#46;&#64;&#x67;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#111;&#x6d;&#93;&#x28;&#x29;">&#x5b;&#99;&#x68;&#101;&#110;&#103;&#x75;&#46;&#x2e;&#46;&#64;&#x67;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#111;&#x6d;&#93;&#x28;&#x29;</a></p>
<p>Nice 大胆预测Linear speedup应该是每个程序员十年后的目标 呵呵
On 3月23日, 上午10时43分, qiaojie <a href="&#109;&#97;&#105;&#x6c;&#x74;&#111;&#58;&#91;&#113;&#x69;&#97;&#111;&#x2e;&#x2e;&#46;&#x40;&#x67;&#109;&#x61;&#105;&#x6c;&#x2e;&#99;&#x6f;&#109;&#x5d;&#40;&#x29;">&#91;&#113;&#x69;&#97;&#111;&#x2e;&#x2e;&#46;&#x40;&#x67;&#109;&#x61;&#105;&#x6c;&#x2e;&#99;&#x6f;&#109;&#x5d;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>目前正在写的是一个软件渲染器，采用了光栅化和光线跟踪混合算法，渲染算法已经完全并行化了，
在4核系统上基本可以达到线性加速比，更多核的系统暂时还没测试。kd-tree的构造暂时还没有并
行化，以后有空了再研究。</p>
<p>2010/3/23 Guancheng Chen <a href="&#109;&#x61;&#105;&#x6c;&#x74;&#111;&#x3a;&#x5b;&#x63;&#x68;&#x65;&#x6e;&#103;&#x75;&#x61;&#110;&#x63;&#104;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#109;&#97;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#41;">&#x5b;&#x63;&#x68;&#x65;&#x6e;&#103;&#x75;&#x61;&#110;&#x63;&#104;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#109;&#97;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#41;</a></p>
<blockquote>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？</p>
<p>On 3月23日, 上午9时15分, qiaojie <a href="&#x6d;&#x61;&#x69;&#108;&#x74;&#x6f;&#x3a;&#91;&#113;&#105;&#x61;&#111;&#x2e;&#46;&#46;&#64;&#103;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#93;&#x28;&#x29;">&#91;&#113;&#105;&#x61;&#111;&#x2e;&#46;&#46;&#64;&#103;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1) =
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？</p>
</blockquote>
<p> To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> qiaojie <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-24</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>说的没错，cell已经成了先烈了。不过这不代表异构的方向不对，CUDA，OpenCL也都是异构平台，以后我们会越来越习惯异构平台的。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#109;&#97;&#105;&#x6c;&#x74;&#111;&#58;&#91;&#104;&#111;&#110;&#103;&#122;&#x68;&#46;&#x2e;&#x2e;&#x40;&#103;&#109;&#x61;&#105;&#108;&#x2e;&#99;&#x6f;&#109;&#x5d;&#40;&#41;">&#91;&#104;&#111;&#110;&#103;&#122;&#x68;&#46;&#x2e;&#x2e;&#x40;&#103;&#109;&#x61;&#105;&#108;&#x2e;&#99;&#x6f;&#109;&#x5d;&#40;&#41;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>异构平台如果编程复杂度降不下来的话很难流行起来。cell已经死了...
2010/3/24 qiaojie <a href="&#x6d;&#97;&#105;&#108;&#x74;&#111;&#58;&#x5b;&#x71;&#105;&#97;&#x2e;&#46;&#x2e;&#64;&#x67;&#x6d;&#97;&#x69;&#x6c;&#46;&#99;&#111;&#x6d;&#x5d;&#x28;&#x29;">&#x5b;&#x71;&#105;&#97;&#x2e;&#46;&#x2e;&#64;&#x67;&#x6d;&#97;&#x69;&#x6c;&#46;&#99;&#111;&#x6d;&#x5d;&#x28;&#x29;</a>
 不是所有的程序都需要并行化的，能用串行化解决的问题没必要并行，所以即使将来many-core系统成为主流，大部分程序员也没必要去搞并行计算。</p>
<p>我觉得未来的主流应该是类似cell这样一颗全功能核心带众多协处理核心的异构系统，这样才能达到最优的 性能/核心面积比。</p>
<p>2010/3/24 Guancheng Chen <a href="&#109;&#97;&#x69;&#108;&#116;&#x6f;&#x3a;&#91;&#99;&#x68;&#101;&#x6e;&#x67;&#117;&#x2e;&#46;&#46;&#64;&#x67;&#109;&#97;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#x29;">&#91;&#99;&#x68;&#101;&#x6e;&#x67;&#117;&#x2e;&#46;&#46;&#64;&#x67;&#109;&#97;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#x29;</a></p>
<p>Nice 大胆预测Linear speedup应该是每个程序员十年后的目标 呵呵
On 3月23日, 上午10时43分, qiaojie <a href="&#109;&#x61;&#105;&#x6c;&#116;&#x6f;&#58;&#x5b;&#113;&#105;&#x61;&#111;&#46;&#46;&#46;&#x40;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#46;&#99;&#x6f;&#x6d;&#x5d;&#40;&#41;">&#x5b;&#113;&#105;&#x61;&#111;&#46;&#46;&#46;&#x40;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#46;&#99;&#x6f;&#x6d;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>目前正在写的是一个软件渲染器，采用了光栅化和光线跟踪混合算法，渲染算法已经完全并行化了，
在4核系统上基本可以达到线性加速比，更多核的系统暂时还没测试。kd-tree的构造暂时还没有并
行化，以后有空了再研究。</p>
<p>2010/3/23 Guancheng Chen <a href="&#x6d;&#97;&#105;&#108;&#116;&#x6f;&#x3a;&#91;&#x63;&#x68;&#101;&#110;&#103;&#x75;&#x61;&#x6e;&#99;&#104;&#46;&#46;&#46;&#64;&#x67;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#40;&#41;">&#91;&#x63;&#x68;&#101;&#110;&#103;&#x75;&#x61;&#x6e;&#99;&#104;&#46;&#46;&#46;&#64;&#x67;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#40;&#41;</a></p>
<blockquote>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？</p>
<p>On 3月23日, 上午9时15分, qiaojie <a href="&#x6d;&#x61;&#x69;&#x6c;&#116;&#111;&#58;&#91;&#113;&#105;&#97;&#111;&#x2e;&#46;&#x2e;&#64;&#103;&#109;&#x61;&#105;&#x6c;&#46;&#x63;&#x6f;&#109;&#93;&#40;&#41;">&#91;&#113;&#105;&#97;&#111;&#x2e;&#46;&#x2e;&#64;&#103;&#109;&#x61;&#105;&#x6c;&#46;&#x63;&#x6f;&#109;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1) =
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？</p>
</blockquote>
<p> To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a></p>
<p><img src="" alt=""> sunjoy <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-24</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>挺有意思的，我之前没有接触过并行计算的相关理论，按照你的公式我花了个图，反映并行度、加速比以及CPU核之间的关系。</p>
<p>2010/3/23 qiaojie <a href="&#109;&#97;&#105;&#x6c;&#x74;&#x6f;&#58;&#91;&#113;&#x69;&#x61;&#x2e;&#46;&#x2e;&#x40;&#x67;&#109;&#97;&#105;&#108;&#x2e;&#99;&#111;&#x6d;&#93;&#x28;&#x29;">&#91;&#113;&#x69;&#x61;&#x2e;&#46;&#x2e;&#x40;&#x67;&#109;&#97;&#105;&#108;&#x2e;&#99;&#111;&#x6d;&#93;&#x28;&#x29;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1) = 5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？
 To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a></p>
<p>附件 (1)</p>
<p><a href="https://groups.google.com/group/pongba/attach/53e12db326792d31/parallelism.png?part=4&amp;authuser=0&amp;view=1" title="parallelism.png"></a></p>
<p>parallelism.png 23 KB   <a href="https://groups.google.com/group/pongba/attach/53e12db326792d31/parallelism.png?part=4&amp;authuser=0&amp;view=1" target="_blank">查看</a>   <a href="https://groups.google.com/group/pongba/attach/53e12db326792d31/parallelism.png?part=4&amp;authuser=0" target="_blank">下载</a>
<img src="" alt=""> Hongzh...@gmail.com <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-24</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>异构平台从网络处理器算起已经快10年了，现在情况仍然不明朗。就我看到的，异构平台要想高效，就必须向程序员暴露非常多的硬件细节，这必然导致编程的复杂性。曲高和寡，要想渗透到应用程序这一块，我觉得很难。</p>
<p>2010/3/24 qiaojie <a href="&#109;&#97;&#105;&#108;&#x74;&#x6f;&#58;&#x5b;&#x71;&#105;&#97;&#x2e;&#46;&#46;&#x40;&#x67;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#99;&#x6f;&#109;&#93;&#40;&#x29;">&#x5b;&#x71;&#105;&#97;&#x2e;&#46;&#46;&#x40;&#x67;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#99;&#x6f;&#109;&#93;&#40;&#x29;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>说的没错，cell已经成了先烈了。不过这不代表异构的方向不对，CUDA，OpenCL也都是异构平台，以后我们会越来越习惯异构平台的。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#x6d;&#97;&#105;&#x6c;&#x74;&#x6f;&#x3a;&#x5b;&#x68;&#111;&#x6e;&#103;&#x7a;&#104;&#46;&#x2e;&#46;&#64;&#103;&#x6d;&#97;&#105;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#93;&#x28;&#x29;">&#x5b;&#x68;&#111;&#x6e;&#103;&#x7a;&#104;&#46;&#x2e;&#46;&#64;&#103;&#x6d;&#97;&#105;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#93;&#x28;&#x29;</a></p>
<p>异构平台如果编程复杂度降不下来的话很难流行起来。cell已经死了...
2010/3/24 qiaojie <a href="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#111;&#x3a;&#x5b;&#x71;&#105;&#97;&#46;&#x2e;&#46;&#x40;&#x67;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#x6f;&#109;&#93;&#40;&#x29;">&#x5b;&#x71;&#105;&#97;&#46;&#x2e;&#46;&#x40;&#x67;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#x6f;&#109;&#93;&#40;&#x29;</a>
 不是所有的程序都需要并行化的，能用串行化解决的问题没必要并行，所以即使将来many-core系统成为主流，大部分程序员也没必要去搞并行计算。</p>
<p>我觉得未来的主流应该是类似cell这样一颗全功能核心带众多协处理核心的异构系统，这样才能达到最优的 性能/核心面积比。</p>
<p>2010/3/24 Guancheng Chen <a href="&#x6d;&#97;&#x69;&#108;&#116;&#x6f;&#x3a;&#x5b;&#99;&#104;&#101;&#x6e;&#x67;&#117;&#46;&#46;&#46;&#x40;&#103;&#109;&#x61;&#105;&#108;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#41;">&#x5b;&#99;&#104;&#101;&#x6e;&#x67;&#117;&#46;&#46;&#46;&#x40;&#103;&#109;&#x61;&#105;&#108;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#41;</a></p>
<p>Nice 大胆预测Linear speedup应该是每个程序员十年后的目标 呵呵
On 3月23日, 上午10时43分, qiaojie <a href="&#x6d;&#97;&#105;&#x6c;&#116;&#x6f;&#x3a;&#91;&#x71;&#x69;&#x61;&#x6f;&#46;&#x2e;&#46;&#x40;&#103;&#109;&#97;&#x69;&#x6c;&#46;&#x63;&#111;&#109;&#93;&#x28;&#x29;">&#91;&#x71;&#x69;&#x61;&#x6f;&#46;&#x2e;&#46;&#x40;&#103;&#109;&#97;&#x69;&#x6c;&#46;&#x63;&#111;&#109;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>目前正在写的是一个软件渲染器，采用了光栅化和光线跟踪混合算法，渲染算法已经完全并行化了，
在4核系统上基本可以达到线性加速比，更多核的系统暂时还没测试。kd-tree的构造暂时还没有并
行化，以后有空了再研究。</p>
<p>2010/3/23 Guancheng Chen <a href="&#109;&#x61;&#x69;&#108;&#x74;&#x6f;&#x3a;&#91;&#x63;&#x68;&#101;&#x6e;&#103;&#117;&#97;&#110;&#x63;&#x68;&#46;&#x2e;&#46;&#x40;&#x67;&#109;&#97;&#105;&#108;&#x2e;&#x63;&#111;&#109;&#x5d;&#x28;&#x29;">&#91;&#x63;&#x68;&#101;&#x6e;&#103;&#117;&#97;&#110;&#x63;&#x68;&#46;&#x2e;&#46;&#x40;&#x67;&#109;&#97;&#105;&#108;&#x2e;&#x63;&#111;&#109;&#x5d;&#x28;&#x29;</a></p>
<blockquote>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？</p>
<p>On 3月23日, 上午9时15分, qiaojie <a href="&#109;&#97;&#x69;&#108;&#116;&#x6f;&#58;&#91;&#113;&#105;&#97;&#111;&#46;&#46;&#x2e;&#x40;&#103;&#x6d;&#97;&#105;&#x6c;&#46;&#99;&#111;&#x6d;&#93;&#40;&#41;">&#91;&#113;&#105;&#97;&#111;&#46;&#46;&#x2e;&#x40;&#103;&#x6d;&#97;&#105;&#x6c;&#46;&#99;&#111;&#x6d;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1) =
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？</p>
</blockquote>
<p> To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a></p>
<p><img src="" alt=""> qiaojie <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-24</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>并行计算本来就是曲高和寡的东西，就跟3D渲染一样，能开发引擎的毕竟只是小部分人，大多数人在引擎的基础上做应用。关键在于是否有杀手应用，只要有大量的需求，自然会有人去做开发。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#x6d;&#x61;&#105;&#x6c;&#x74;&#111;&#x3a;&#x5b;&#104;&#x6f;&#110;&#x67;&#x7a;&#x68;&#46;&#x2e;&#x2e;&#64;&#x67;&#109;&#x61;&#x69;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#x29;">&#x5b;&#104;&#x6f;&#110;&#x67;&#x7a;&#x68;&#46;&#x2e;&#x2e;&#64;&#x67;&#109;&#x61;&#x69;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#x29;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>异构平台从网络处理器算起已经快10年了，现在情况仍然不明朗。就我看到的，异构平台要想高效，就必须向程序员暴露非常多的硬件细节，这必然导致编程的复杂性。曲高和寡，要想渗透到应用程序这一块，我觉得很难。</p>
<p>2010/3/24 qiaojie <a href="&#109;&#97;&#105;&#x6c;&#116;&#x6f;&#58;&#x5b;&#x71;&#x69;&#97;&#46;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#40;&#41;">&#x5b;&#x71;&#x69;&#97;&#46;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#40;&#41;</a>
说的没错，cell已经成了先烈了。不过这不代表异构的方向不对，CUDA，OpenCL也都是异构平台，以后我们会越来越习惯异构平台的。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#109;&#x61;&#105;&#108;&#116;&#x6f;&#58;&#x5b;&#104;&#111;&#110;&#x67;&#x7a;&#x68;&#46;&#x2e;&#46;&#64;&#x67;&#109;&#97;&#105;&#108;&#x2e;&#99;&#x6f;&#109;&#93;&#40;&#x29;">&#x5b;&#104;&#111;&#110;&#x67;&#x7a;&#x68;&#46;&#x2e;&#46;&#64;&#x67;&#109;&#97;&#105;&#108;&#x2e;&#99;&#x6f;&#109;&#93;&#40;&#x29;</a></p>
<p>异构平台如果编程复杂度降不下来的话很难流行起来。cell已经死了...
2010/3/24 qiaojie <a href="&#x6d;&#97;&#x69;&#x6c;&#116;&#x6f;&#x3a;&#x5b;&#113;&#x69;&#97;&#46;&#x2e;&#x2e;&#64;&#103;&#109;&#97;&#105;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#41;">&#x5b;&#113;&#x69;&#97;&#46;&#x2e;&#x2e;&#64;&#103;&#109;&#97;&#105;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#41;</a>
 不是所有的程序都需要并行化的，能用串行化解决的问题没必要并行，所以即使将来many-core系统成为主流，大部分程序员也没必要去搞并行计算。</p>
<p>我觉得未来的主流应该是类似cell这样一颗全功能核心带众多协处理核心的异构系统，这样才能达到最优的 性能/核心面积比。</p>
<p>2010/3/24 Guancheng Chen <a href="&#x6d;&#x61;&#x69;&#x6c;&#116;&#111;&#x3a;&#x5b;&#99;&#x68;&#101;&#110;&#103;&#117;&#x2e;&#46;&#x2e;&#64;&#x67;&#x6d;&#x61;&#x69;&#108;&#x2e;&#99;&#111;&#109;&#x5d;&#x28;&#x29;">&#x5b;&#99;&#x68;&#101;&#110;&#103;&#117;&#x2e;&#46;&#x2e;&#64;&#x67;&#x6d;&#x61;&#x69;&#108;&#x2e;&#99;&#111;&#109;&#x5d;&#x28;&#x29;</a></p>
<p>Nice 大胆预测Linear speedup应该是每个程序员十年后的目标 呵呵
On 3月23日, 上午10时43分, qiaojie <a href="&#x6d;&#97;&#105;&#108;&#116;&#111;&#x3a;&#x5b;&#113;&#105;&#97;&#x6f;&#x2e;&#46;&#46;&#x40;&#x67;&#109;&#x61;&#x69;&#x6c;&#46;&#x63;&#111;&#x6d;&#x5d;&#x28;&#41;">&#x5b;&#113;&#105;&#97;&#x6f;&#x2e;&#46;&#46;&#x40;&#x67;&#109;&#x61;&#x69;&#x6c;&#46;&#x63;&#111;&#x6d;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>目前正在写的是一个软件渲染器，采用了光栅化和光线跟踪混合算法，渲染算法已经完全并行化了，
在4核系统上基本可以达到线性加速比，更多核的系统暂时还没测试。kd-tree的构造暂时还没有并
行化，以后有空了再研究。</p>
<p>2010/3/23 Guancheng Chen <a href="&#x6d;&#97;&#105;&#108;&#116;&#111;&#x3a;&#x5b;&#x63;&#x68;&#101;&#110;&#103;&#117;&#x61;&#x6e;&#x63;&#x68;&#x2e;&#x2e;&#46;&#64;&#x67;&#x6d;&#97;&#105;&#108;&#46;&#99;&#x6f;&#109;&#x5d;&#40;&#x29;">&#x5b;&#x63;&#x68;&#101;&#110;&#103;&#117;&#x61;&#x6e;&#x63;&#x68;&#x2e;&#x2e;&#46;&#64;&#x67;&#x6d;&#97;&#105;&#108;&#46;&#99;&#x6f;&#109;&#x5d;&#40;&#x29;</a></p>
<blockquote>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？</p>
<p>On 3月23日, 上午9时15分, qiaojie <a href="&#x6d;&#x61;&#x69;&#x6c;&#116;&#111;&#58;&#x5b;&#x71;&#x69;&#97;&#x6f;&#46;&#x2e;&#x2e;&#x40;&#103;&#109;&#97;&#105;&#108;&#x2e;&#99;&#111;&#109;&#93;&#40;&#41;">&#x5b;&#x71;&#x69;&#97;&#x6f;&#46;&#x2e;&#x2e;&#x40;&#103;&#109;&#97;&#105;&#108;&#x2e;&#99;&#111;&#109;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1) =
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？</p>
</blockquote>
<p> To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-25</p>
<p>其他收件人：</p>
<p>杀手应用一般来说是指什么样的应用呢？比如用户群特别大的网游？还是那些专有的科学计算用的软件？</p>
<p>On 3月24日, 下午12时36分, qiaojie <a href="&#109;&#x61;&#x69;&#x6c;&#116;&#x6f;&#58;&#91;&#113;&#x69;&#x61;&#x6f;&#46;&#46;&#46;&#x40;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#93;&#40;&#41;">&#91;&#113;&#x69;&#x61;&#x6f;&#46;&#46;&#46;&#x40;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>并行计算本来就是曲高和寡的东西，就跟3D渲染一样，能开发引擎的毕竟只是小部分人，大多数人在引擎的基础上做应用。关键在于是否有杀手应用，只要有大量的需求 ，自然会有人去做开发。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#109;&#x61;&#105;&#x6c;&#116;&#111;&#x3a;&#x5b;&#x68;&#x6f;&#110;&#x67;&#122;&#x68;&#97;&#x6e;&#103;&#46;&#46;&#46;&#x2e;&#64;&#103;&#x6d;&#97;&#x69;&#108;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#x28;&#41;">&#x5b;&#x68;&#x6f;&#110;&#x67;&#122;&#x68;&#97;&#x6e;&#103;&#46;&#46;&#46;&#x2e;&#64;&#103;&#x6d;&#97;&#x69;&#108;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#x28;&#41;</a></p>
</blockquote>
<p>&gt;
&gt;
&gt;</p>
<blockquote>
<blockquote>
<p>异构平台从网络处理器算起已经快10年了，现在情况仍然不明朗。就我看到的，异构平台要想高效，就必须向程序员暴露非常多的硬件细节，这必然导致编程的复杂性。 曲高和寡，要想渗透到应用程序这一块，我觉得很难。</p>
<p>2010/3/24 qiaojie <a href="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#111;&#58;&#91;&#113;&#x69;&#97;&#x6f;&#x2e;&#46;&#x2e;&#64;&#x67;&#x6d;&#97;&#105;&#x6c;&#46;&#x63;&#x6f;&#109;&#x5d;&#x28;&#x29;">&#91;&#113;&#x69;&#97;&#x6f;&#x2e;&#46;&#x2e;&#64;&#x67;&#x6d;&#97;&#105;&#x6c;&#46;&#x63;&#x6f;&#109;&#x5d;&#x28;&#x29;</a></p>
</blockquote>
</blockquote>
<p>&gt;</p>
<blockquote>
<blockquote>
<blockquote>
<p>说的没错，cell已经成了先烈了。不过这不代表异构的方向不对，CUDA，OpenCL也都是异构平台，以后我们会越来越习惯异构平台的。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#x3a;&#91;&#x68;&#x6f;&#x6e;&#103;&#x7a;&#104;&#x61;&#110;&#x67;&#x2e;&#x2e;&#x2e;&#x2e;&#64;&#103;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#99;&#111;&#x6d;&#x5d;&#x28;&#x29;">&#91;&#x68;&#x6f;&#x6e;&#103;&#x7a;&#104;&#x61;&#110;&#x67;&#x2e;&#x2e;&#x2e;&#x2e;&#64;&#103;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#99;&#111;&#x6d;&#x5d;&#x28;&#x29;</a></p>
<p>异构平台如果编程复杂度降不下来的话很难流行起来。cell已经死了...</p>
<blockquote>
<p> 2010/3/24 qiaojie <a href="&#109;&#97;&#105;&#x6c;&#x74;&#111;&#x3a;&#x5b;&#x71;&#x69;&#x61;&#111;&#x2e;&#46;&#x2e;&#x40;&#103;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#99;&#111;&#x6d;&#x5d;&#40;&#x29;">&#x5b;&#x71;&#x69;&#x61;&#111;&#x2e;&#46;&#x2e;&#x40;&#103;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#99;&#111;&#x6d;&#x5d;&#40;&#x29;</a></p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>&gt;</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>不是所有的程序都需要并行化的，能用串行化解决的问题没必要并行，所以即使将来many-core系统成为主流，大部分程序员也没必要去搞并行计算。
  我觉得未来的主流应该是类似cell这样一颗全功能核心带众多协处理核心的异构系统，这样才能达到最优的 性能/核心面积比。</p>
<p>2010/3/24 Guancheng Chen <a href="&#109;&#97;&#x69;&#108;&#x74;&#x6f;&#x3a;&#x5b;&#99;&#104;&#x65;&#110;&#103;&#x75;&#97;&#x6e;&#x63;&#x68;&#x2e;&#x2e;&#46;&#x40;&#103;&#x6d;&#97;&#x69;&#108;&#46;&#x63;&#x6f;&#109;&#x5d;&#40;&#41;">&#x5b;&#99;&#104;&#x65;&#110;&#103;&#x75;&#97;&#x6e;&#x63;&#x68;&#x2e;&#x2e;&#46;&#x40;&#103;&#x6d;&#97;&#x69;&#108;&#46;&#x63;&#x6f;&#109;&#x5d;&#40;&#41;</a></p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>&gt;</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>Nice 大胆预测Linear speedup应该是每个程序员十年后的目标 呵呵</p>
<blockquote>
<p>On 3月23日, 上午10时43分, qiaojie <a href="&#109;&#97;&#x69;&#108;&#x74;&#111;&#58;&#91;&#x71;&#x69;&#x61;&#x6f;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#109;&#97;&#x69;&#108;&#46;&#99;&#111;&#109;&#x5d;&#40;&#x29;">&#91;&#x71;&#x69;&#x61;&#x6f;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#109;&#97;&#x69;&#108;&#46;&#99;&#111;&#109;&#x5d;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>目前正在写的是一个软件渲染器，采用了光栅化和光线跟踪混合算法，渲染算法已经完全并行化了，
在4核系统上基本可以达到线性加速比，更多核的系统暂时还没测试。kd-tree的构造暂时还没有并
行化，以后有空了再研究。</p>
<p>2010/3/23 Guancheng Chen <a href="&#109;&#x61;&#x69;&#108;&#x74;&#111;&#58;&#x5b;&#99;&#104;&#x65;&#x6e;&#103;&#117;&#x61;&#110;&#x63;&#104;&#x2e;&#x2e;&#46;&#x40;&#x67;&#109;&#x61;&#105;&#108;&#x2e;&#99;&#111;&#109;&#x5d;&#x28;&#x29;">&#x5b;&#99;&#104;&#x65;&#x6e;&#103;&#117;&#x61;&#110;&#x63;&#104;&#x2e;&#x2e;&#46;&#x40;&#x67;&#109;&#x61;&#105;&#108;&#x2e;&#99;&#111;&#109;&#x5d;&#x28;&#x29;</a></p>
<blockquote>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？</p>
<p>On 3月23日, 上午9时15分, qiaojie <a href="&#x6d;&#x61;&#x69;&#x6c;&#116;&#x6f;&#58;&#x5b;&#113;&#x69;&#x61;&#111;&#46;&#46;&#46;&#64;&#x67;&#109;&#x61;&#x69;&#x6c;&#46;&#99;&#111;&#x6d;&#93;&#40;&#x29;">&#x5b;&#113;&#x69;&#x61;&#111;&#46;&#46;&#46;&#64;&#x67;&#109;&#x61;&#x69;&#x6c;&#46;&#99;&#111;&#x6d;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1)
=
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank
Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？</p>
</blockquote>
<p> To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
<a href="">显示删减掉的内容</a></p>
</blockquote>
</blockquote>
<p><img src="" alt=""> qiaojie <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-25</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>3D游戏就是一类杀手应用，由此支撑起了一个庞大的GPU市场，芯片行业的研发成本是很高的，没有一个庞大的市场是做不起来的。目前的消费者对于多核系统显然还没有强烈的需求，因为应用跟不上，i7发布快2年了还没进入主流市场，这种情况延续下去的话摩尔定律将因此失效。不过我相信杀手级应用总会出现的，这可能要硬件性能突破一个临界点，比方说目前GPU的性能再提升一个数量级的话，光线跟踪算法就可以提供流畅的接近CG的画质，倒是此类应用便会流行开来。</p>
<p>2010/3/25 Guancheng Chen <a href="&#109;&#x61;&#105;&#108;&#x74;&#111;&#x3a;&#x5b;&#99;&#104;&#x65;&#110;&#103;&#117;&#x2e;&#x2e;&#x2e;&#64;&#103;&#109;&#97;&#x69;&#108;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#x28;&#x29;">&#x5b;&#99;&#104;&#x65;&#110;&#103;&#117;&#x2e;&#x2e;&#x2e;&#64;&#103;&#109;&#97;&#x69;&#108;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#x28;&#x29;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>杀手应用一般来说是指什么样的应用呢？比如用户群特别大的网游？还是那些专有的科学计算用的软件？
On 3月24日, 下午12时36分, qiaojie <a href="&#109;&#x61;&#x69;&#108;&#x74;&#x6f;&#58;&#x5b;&#113;&#x69;&#97;&#111;&#x2e;&#46;&#x2e;&#64;&#103;&#x6d;&#97;&#x69;&#x6c;&#46;&#x63;&#x6f;&#109;&#93;&#40;&#x29;">&#x5b;&#113;&#x69;&#97;&#111;&#x2e;&#46;&#x2e;&#64;&#103;&#x6d;&#97;&#x69;&#x6c;&#46;&#x63;&#x6f;&#109;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>并行计算本来就是曲高和寡的东西，就跟3D渲染一样，能开发引擎的毕竟只是小部分人，大多数人在引擎的基础上做应用。关键在于是否有杀手应用，只要有大量的需求 ，自然会有人去做开发。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#x6d;&#x61;&#105;&#108;&#x74;&#111;&#58;&#x5b;&#x68;&#111;&#x6e;&#103;&#122;&#104;&#97;&#110;&#x67;&#x2e;&#46;&#46;&#x2e;&#64;&#x67;&#109;&#97;&#105;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#40;&#x29;">&#x5b;&#x68;&#111;&#x6e;&#103;&#122;&#104;&#97;&#110;&#x67;&#x2e;&#46;&#46;&#x2e;&#64;&#x67;&#109;&#97;&#105;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#40;&#x29;</a></p>
<blockquote>
<p>异构平台从网络处理器算起已经快10年了，现在情况仍然不明朗。就我看到的，异构平台要想高效，就必须向程序员暴露非常多的硬件细节，这必然导致编程的复杂性。 曲高和寡，要想渗透到应用程序这一块，我觉得很难。</p>
<p>2010/3/24 qiaojie <a href="&#109;&#x61;&#x69;&#x6c;&#116;&#x6f;&#x3a;&#x5b;&#113;&#105;&#x61;&#111;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#97;&#105;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#93;&#40;&#x29;">&#x5b;&#113;&#105;&#x61;&#111;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#97;&#105;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#93;&#40;&#x29;</a></p>
<blockquote>
<p>说的没错，cell已经成了先烈了。不过这不代表异构的方向不对，CUDA，OpenCL也都是异构平台，以后我们会越来越习惯异构平台的。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#109;&#x61;&#x69;&#108;&#x74;&#111;&#58;&#91;&#x68;&#x6f;&#x6e;&#x67;&#x7a;&#x68;&#x61;&#110;&#103;&#x2e;&#x2e;&#46;&#x2e;&#x40;&#x67;&#109;&#x61;&#105;&#108;&#x2e;&#99;&#111;&#x6d;&#93;&#40;&#x29;">&#91;&#x68;&#x6f;&#x6e;&#x67;&#x7a;&#x68;&#x61;&#110;&#103;&#x2e;&#x2e;&#46;&#x2e;&#x40;&#x67;&#109;&#x61;&#105;&#108;&#x2e;&#99;&#111;&#x6d;&#93;&#40;&#x29;</a></p>
<p>异构平台如果编程复杂度降不下来的话很难流行起来。cell已经死了...</p>
<blockquote>
<p> 2010/3/24 qiaojie <a href="&#x6d;&#97;&#105;&#108;&#x74;&#x6f;&#x3a;&#91;&#113;&#x69;&#x61;&#111;&#x2e;&#46;&#46;&#64;&#x67;&#x6d;&#97;&#105;&#x6c;&#46;&#99;&#111;&#x6d;&#x5d;&#x28;&#x29;">&#91;&#113;&#x69;&#x61;&#111;&#x2e;&#46;&#46;&#64;&#x67;&#x6d;&#97;&#105;&#x6c;&#46;&#99;&#111;&#x6d;&#x5d;&#x28;&#x29;</a></p>
<blockquote>
<p>不是所有的程序都需要并行化的，能用串行化解决的问题没必要并行，所以即使将来many-core系统成为主流，大部分程序员也没必要去搞并行计算。
  我觉得未来的主流应该是类似cell这样一颗全功能核心带众多协处理核心的异构系统，这样才能达到最优的 性能/核心面积比。</p>
<p>2010/3/24 Guancheng Chen <a href="&#109;&#x61;&#105;&#108;&#x74;&#x6f;&#58;&#x5b;&#x63;&#x68;&#x65;&#x6e;&#x67;&#117;&#97;&#110;&#x63;&#x68;&#46;&#46;&#46;&#64;&#x67;&#109;&#x61;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#93;&#x28;&#x29;">&#x5b;&#x63;&#x68;&#x65;&#x6e;&#x67;&#117;&#97;&#110;&#x63;&#x68;&#46;&#46;&#46;&#64;&#x67;&#109;&#x61;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#93;&#x28;&#x29;</a></p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>&gt;</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>Nice 大胆预测Linear speedup应该是每个程序员十年后的目标 呵呵</p>
<blockquote>
<p>On 3月23日, 上午10时43分, qiaojie <a href="&#x6d;&#x61;&#x69;&#108;&#x74;&#x6f;&#x3a;&#x5b;&#113;&#x69;&#97;&#111;&#46;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#97;&#105;&#108;&#46;&#x63;&#111;&#x6d;&#x5d;&#40;&#41;">&#x5b;&#113;&#x69;&#97;&#111;&#46;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#97;&#105;&#108;&#46;&#x63;&#111;&#x6d;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>目前正在写的是一个软件渲染器，采用了光栅化和光线跟踪混合算法，渲染算法已经完全并行化了，
在4核系统上基本可以达到线性加速比，更多核的系统暂时还没测试。kd-tree的构造暂时还没有并
行化，以后有空了再研究。</p>
<p>2010/3/23 Guancheng Chen <a href="&#x6d;&#x61;&#105;&#x6c;&#116;&#111;&#x3a;&#91;&#99;&#x68;&#x65;&#110;&#x67;&#x75;&#97;&#x6e;&#x63;&#104;&#x2e;&#46;&#46;&#x40;&#x67;&#109;&#97;&#105;&#x6c;&#46;&#x63;&#111;&#109;&#x5d;&#x28;&#x29;">&#91;&#99;&#x68;&#x65;&#110;&#x67;&#x75;&#97;&#x6e;&#x63;&#104;&#x2e;&#46;&#46;&#x40;&#x67;&#109;&#97;&#105;&#x6c;&#46;&#x63;&#111;&#109;&#x5d;&#x28;&#x29;</a></p>
<blockquote>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？</p>
<p>On 3月23日, 上午9时15分, qiaojie <a href="&#109;&#97;&#x69;&#x6c;&#x74;&#111;&#x3a;&#x5b;&#x71;&#105;&#x61;&#111;&#46;&#46;&#46;&#64;&#103;&#x6d;&#x61;&#105;&#108;&#46;&#99;&#111;&#109;&#x5d;&#x28;&#x29;">&#x5b;&#x71;&#105;&#x61;&#111;&#46;&#46;&#46;&#64;&#103;&#x6d;&#x61;&#105;&#108;&#46;&#99;&#111;&#109;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1)
=
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank
Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？</p>
</blockquote>
<p> To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> 机械唯物主义 : linjunhalida <img src="" alt=""></p>
</blockquote>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-25</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>一个谬误：刺激需求
产能=消费，产能才是主动力。技术成长是随着产能成长而起来的。
而产能多的结果就是满足了需求，造成一种需求带来技术进步的假像。
而技术和产能之间的关系又错综复杂。。
2010/3/25 qiaojie <a href="&#x6d;&#x61;&#105;&#108;&#116;&#111;&#58;&#91;&#113;&#105;&#x61;&#46;&#46;&#46;&#64;&#x67;&#x6d;&#97;&#105;&#108;&#x2e;&#99;&#111;&#109;&#x5d;&#x28;&#x29;">&#91;&#113;&#105;&#x61;&#46;&#46;&#46;&#64;&#x67;&#x6d;&#97;&#105;&#108;&#x2e;&#99;&#111;&#109;&#x5d;&#x28;&#x29;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>3D游戏就是一类杀手应用，由此支撑起了一个庞大的GPU市场，芯片行业的研发成本是很高的，没有一个庞大的市场是做不起来的。目前的消费者对于多核系统显然还没有强烈的需求，因为应用跟不上，i7发布快2年了还没进入主流市场，这种情况延续下去的话摩尔定律将因此失效。不过我相信杀手级应用总会出现的，这可能要硬件性能突破一个临界点，比方说目前GPU的性能再提升一个数量级的话，光线跟踪算法就可以提供流畅的接近CG的画质，倒是此类应用便会流行开来。</p>
<p>2010/3/25 Guancheng Chen <a href="&#x6d;&#97;&#105;&#x6c;&#x74;&#111;&#58;&#x5b;&#x63;&#104;&#101;&#110;&#x67;&#x75;&#x2e;&#46;&#x2e;&#x40;&#103;&#x6d;&#97;&#105;&#x6c;&#46;&#x63;&#111;&#x6d;&#93;&#40;&#41;">&#x5b;&#x63;&#104;&#101;&#110;&#x67;&#x75;&#x2e;&#46;&#x2e;&#x40;&#103;&#x6d;&#97;&#105;&#x6c;&#46;&#x63;&#111;&#x6d;&#93;&#40;&#41;</a></p>
<p>杀手应用一般来说是指什么样的应用呢？比如用户群特别大的网游？还是那些专有的科学计算用的软件？
On 3月24日, 下午12时36分, qiaojie <a href="&#x6d;&#97;&#105;&#108;&#116;&#111;&#58;&#x5b;&#x71;&#105;&#97;&#x6f;&#46;&#x2e;&#x2e;&#64;&#103;&#109;&#x61;&#105;&#108;&#46;&#99;&#x6f;&#109;&#93;&#40;&#41;">&#x5b;&#x71;&#105;&#97;&#x6f;&#46;&#x2e;&#x2e;&#64;&#103;&#109;&#x61;&#105;&#108;&#46;&#99;&#x6f;&#109;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>并行计算本来就是曲高和寡的东西，就跟3D渲染一样，能开发引擎的毕竟只是小部分人，大多数人在引擎的基础上做应用。关键在于是否有杀手应用，只要有大量的需求 ，自然会有人去做开发。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#x6d;&#x61;&#105;&#x6c;&#116;&#x6f;&#58;&#91;&#104;&#x6f;&#110;&#x67;&#x7a;&#104;&#97;&#x6e;&#103;&#x2e;&#46;&#46;&#x2e;&#x40;&#x67;&#109;&#x61;&#105;&#108;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#41;">&#91;&#104;&#x6f;&#110;&#x67;&#x7a;&#104;&#97;&#x6e;&#103;&#x2e;&#46;&#46;&#x2e;&#x40;&#x67;&#109;&#x61;&#105;&#108;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#41;</a></p>
<blockquote>
<p>异构平台从网络处理器算起已经快10年了，现在情况仍然不明朗。就我看到的，异构平台要想高效，就必须向程序员暴露非常多的硬件细节，这必然导致编程的复杂性。 曲高和寡，要想渗透到应用程序这一块，我觉得很难。</p>
<p>2010/3/24 qiaojie <a href="&#x6d;&#97;&#x69;&#x6c;&#116;&#x6f;&#58;&#x5b;&#113;&#105;&#x61;&#x6f;&#46;&#x2e;&#46;&#64;&#x67;&#x6d;&#97;&#x69;&#108;&#46;&#99;&#111;&#x6d;&#x5d;&#x28;&#x29;">&#x5b;&#113;&#105;&#x61;&#x6f;&#46;&#x2e;&#46;&#64;&#x67;&#x6d;&#97;&#x69;&#108;&#46;&#99;&#111;&#x6d;&#x5d;&#x28;&#x29;</a></p>
<blockquote>
<p>说的没错，cell已经成了先烈了。不过这不代表异构的方向不对，CUDA，OpenCL也都是异构平台，以后我们会越来越习惯异构平台的。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#109;&#x61;&#105;&#x6c;&#x74;&#x6f;&#58;&#x5b;&#104;&#x6f;&#110;&#x67;&#x7a;&#104;&#x61;&#110;&#103;&#46;&#46;&#x2e;&#46;&#x40;&#103;&#109;&#97;&#105;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#40;&#41;">&#x5b;&#104;&#x6f;&#110;&#x67;&#x7a;&#104;&#x61;&#110;&#103;&#46;&#46;&#x2e;&#46;&#x40;&#103;&#109;&#97;&#105;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#40;&#41;</a></p>
<p>异构平台如果编程复杂度降不下来的话很难流行起来。cell已经死了...</p>
<blockquote>
<p> 2010/3/24 qiaojie <a href="&#x6d;&#x61;&#105;&#x6c;&#116;&#111;&#x3a;&#x5b;&#113;&#x69;&#x61;&#111;&#46;&#x2e;&#46;&#64;&#103;&#x6d;&#97;&#x69;&#x6c;&#46;&#x63;&#x6f;&#109;&#x5d;&#x28;&#x29;">&#x5b;&#113;&#x69;&#x61;&#111;&#46;&#x2e;&#46;&#64;&#103;&#x6d;&#97;&#x69;&#x6c;&#46;&#x63;&#x6f;&#109;&#x5d;&#x28;&#x29;</a></p>
<blockquote>
<p>不是所有的程序都需要并行化的，能用串行化解决的问题没必要并行，所以即使将来many-core系统成为主流，大部分程序员也没必要去搞并行计算。
  我觉得未来的主流应该是类似cell这样一颗全功能核心带众多协处理核心的异构系统，这样才能达到最优的 性能/核心面积比。</p>
<p>2010/3/24 Guancheng Chen <a href="&#109;&#97;&#105;&#x6c;&#116;&#111;&#58;&#x5b;&#99;&#x68;&#101;&#110;&#103;&#117;&#97;&#x6e;&#99;&#x68;&#x2e;&#46;&#46;&#64;&#x67;&#109;&#97;&#x69;&#108;&#x2e;&#99;&#111;&#x6d;&#x5d;&#40;&#x29;">&#x5b;&#99;&#x68;&#101;&#110;&#103;&#117;&#97;&#x6e;&#99;&#x68;&#x2e;&#46;&#46;&#64;&#x67;&#109;&#97;&#x69;&#108;&#x2e;&#99;&#111;&#x6d;&#x5d;&#40;&#x29;</a></p>
<p>Nice 大胆预测Linear speedup应该是每个程序员十年后的目标 呵呵</p>
<blockquote>
<p>On 3月23日, 上午10时43分, qiaojie <a href="&#x6d;&#x61;&#x69;&#x6c;&#116;&#111;&#58;&#x5b;&#x71;&#x69;&#x61;&#x6f;&#46;&#46;&#46;&#64;&#103;&#109;&#x61;&#105;&#108;&#46;&#99;&#x6f;&#x6d;&#93;&#x28;&#x29;">&#x5b;&#x71;&#x69;&#x61;&#x6f;&#46;&#46;&#46;&#64;&#103;&#109;&#x61;&#105;&#108;&#46;&#99;&#x6f;&#x6d;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>目前正在写的是一个软件渲染器，采用了光栅化和光线跟踪混合算法，渲染算法已经完全并行化了，
在4核系统上基本可以达到线性加速比，更多核的系统暂时还没测试。kd-tree的构造暂时还没有并
行化，以后有空了再研究。</p>
<p>2010/3/23 Guancheng Chen <a href="&#109;&#x61;&#x69;&#x6c;&#x74;&#111;&#58;&#x5b;&#99;&#104;&#x65;&#110;&#103;&#117;&#x61;&#110;&#x63;&#104;&#46;&#46;&#x2e;&#x40;&#103;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#99;&#111;&#x6d;&#93;&#x28;&#x29;">&#x5b;&#99;&#104;&#x65;&#110;&#103;&#117;&#x61;&#110;&#x63;&#104;&#46;&#46;&#x2e;&#x40;&#103;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#99;&#111;&#x6d;&#93;&#x28;&#x29;</a></p>
<blockquote>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？</p>
<p>On 3月23日, 上午9时15分, qiaojie <a href="&#x6d;&#97;&#105;&#x6c;&#x74;&#x6f;&#x3a;&#91;&#113;&#105;&#x61;&#x6f;&#46;&#x2e;&#46;&#64;&#103;&#x6d;&#97;&#x69;&#x6c;&#46;&#99;&#x6f;&#109;&#x5d;&#40;&#x29;">&#91;&#113;&#105;&#x61;&#x6f;&#46;&#x2e;&#46;&#64;&#103;&#x6d;&#97;&#x69;&#x6c;&#46;&#99;&#x6f;&#109;&#x5d;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1)
=
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank
Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？</p>
</blockquote>
<p> To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a></p>
</blockquote>
</blockquote>
<p><img src="" alt=""> qiaojie <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-25</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>如果产能=消费的话就没有产能过剩这一说了。</p>
<p>2010/3/25 机械唯物主义 : linjunhalida <a href="&#x6d;&#x61;&#x69;&#108;&#x74;&#x6f;&#x3a;&#x5b;&#x6c;&#105;&#110;&#x6a;&#x75;&#110;&#46;&#46;&#46;&#x40;&#103;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#x63;&#111;&#109;&#93;&#40;&#41;">&#x5b;&#x6c;&#105;&#110;&#x6a;&#x75;&#110;&#46;&#46;&#46;&#x40;&#103;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#x63;&#111;&#109;&#93;&#40;&#41;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>一个谬误：刺激需求
产能=消费，产能才是主动力。技术成长是随着产能成长而起来的。
而产能多的结果就是满足了需求，造成一种需求带来技术进步的假像。
而技术和产能之间的关系又错综复杂。。
2010/3/25 qiaojie <a href="&#109;&#97;&#105;&#x6c;&#x74;&#111;&#58;&#91;&#113;&#105;&#x61;&#46;&#x2e;&#46;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#x6f;&#109;&#93;&#40;&#x29;">&#91;&#113;&#105;&#x61;&#46;&#x2e;&#46;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#x6f;&#109;&#93;&#40;&#x29;</a></p>
<p>3D游戏就是一类杀手应用，由此支撑起了一个庞大的GPU市场，芯片行业的研发成本是很高的，没有一个庞大的市场是做不起来的。目前的消费者对于多核系统显然还没有强烈的需求，因为应用跟不上，i7发布快2年了还没进入主流市场，这种情况延续下去的话摩尔定律将因此失效。不过我相信杀手级应用总会出现的，这可能要硬件性能突破一个临界点，比方说目前GPU的性能再提升一个数量级的话，光线跟踪算法就可以提供流畅的接近CG的画质，倒是此类应用便会流行开来。</p>
<p>2010/3/25 Guancheng Chen <a href="&#109;&#x61;&#105;&#x6c;&#x74;&#x6f;&#58;&#91;&#x63;&#x68;&#101;&#110;&#x67;&#x75;&#46;&#x2e;&#46;&#64;&#103;&#109;&#x61;&#x69;&#108;&#46;&#99;&#x6f;&#x6d;&#93;&#x28;&#x29;">&#91;&#x63;&#x68;&#101;&#110;&#x67;&#x75;&#46;&#x2e;&#46;&#64;&#103;&#109;&#x61;&#x69;&#108;&#46;&#99;&#x6f;&#x6d;&#93;&#x28;&#x29;</a></p>
<p>杀手应用一般来说是指什么样的应用呢？比如用户群特别大的网游？还是那些专有的科学计算用的软件？
On 3月24日, 下午12时36分, qiaojie <a href="&#109;&#x61;&#105;&#x6c;&#116;&#111;&#58;&#91;&#113;&#105;&#x61;&#x6f;&#x2e;&#46;&#46;&#x40;&#103;&#x6d;&#97;&#x69;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#x29;">&#91;&#113;&#105;&#x61;&#x6f;&#x2e;&#46;&#46;&#x40;&#103;&#x6d;&#97;&#x69;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>并行计算本来就是曲高和寡的东西，就跟3D渲染一样，能开发引擎的毕竟只是小部分人，大多数人在引擎的基础上做应用。关键在于是否有杀手应用，只要有大量的需求 ，自然会有人去做开发。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#109;&#97;&#105;&#108;&#x74;&#111;&#x3a;&#91;&#x68;&#x6f;&#110;&#x67;&#x7a;&#x68;&#97;&#x6e;&#103;&#x2e;&#x2e;&#x2e;&#46;&#x40;&#103;&#x6d;&#x61;&#x69;&#108;&#46;&#x63;&#111;&#109;&#93;&#x28;&#41;">&#91;&#x68;&#x6f;&#110;&#x67;&#x7a;&#x68;&#97;&#x6e;&#103;&#x2e;&#x2e;&#x2e;&#46;&#x40;&#103;&#x6d;&#x61;&#x69;&#108;&#46;&#x63;&#111;&#109;&#93;&#x28;&#41;</a></p>
<blockquote>
<p>异构平台从网络处理器算起已经快10年了，现在情况仍然不明朗。就我看到的，异构平台要想高效，就必须向程序员暴露非常多的硬件细节，这必然导致编程的复杂性。 曲高和寡，要想渗透到应用程序这一块，我觉得很难。</p>
<p>2010/3/24 qiaojie <a href="&#x6d;&#97;&#x69;&#108;&#116;&#x6f;&#58;&#x5b;&#x71;&#105;&#x61;&#111;&#46;&#46;&#46;&#x40;&#103;&#109;&#x61;&#x69;&#108;&#46;&#x63;&#111;&#109;&#93;&#x28;&#41;">&#x5b;&#x71;&#105;&#x61;&#111;&#46;&#46;&#46;&#x40;&#103;&#109;&#x61;&#x69;&#108;&#46;&#x63;&#111;&#109;&#93;&#x28;&#41;</a></p>
<blockquote>
<p>说的没错，cell已经成了先烈了。不过这不代表异构的方向不对，CUDA，OpenCL也都是异构平台，以后我们会越来越习惯异构平台的。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#109;&#97;&#x69;&#x6c;&#116;&#111;&#x3a;&#91;&#104;&#111;&#x6e;&#x67;&#x7a;&#104;&#x61;&#x6e;&#x67;&#46;&#46;&#x2e;&#46;&#64;&#x67;&#x6d;&#x61;&#105;&#108;&#46;&#99;&#x6f;&#x6d;&#93;&#40;&#41;">&#91;&#104;&#111;&#x6e;&#x67;&#x7a;&#104;&#x61;&#x6e;&#x67;&#46;&#46;&#x2e;&#46;&#64;&#x67;&#x6d;&#x61;&#105;&#108;&#46;&#99;&#x6f;&#x6d;&#93;&#40;&#41;</a></p>
<p>异构平台如果编程复杂度降不下来的话很难流行起来。cell已经死了...</p>
<blockquote>
<p> 2010/3/24 qiaojie <a href="&#x6d;&#x61;&#x69;&#x6c;&#116;&#x6f;&#58;&#x5b;&#x71;&#x69;&#x61;&#111;&#x2e;&#46;&#x2e;&#64;&#103;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#99;&#111;&#109;&#93;&#40;&#41;">&#x5b;&#x71;&#x69;&#x61;&#111;&#x2e;&#46;&#x2e;&#64;&#103;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#99;&#111;&#109;&#93;&#40;&#41;</a></p>
<blockquote>
<p>不是所有的程序都需要并行化的，能用串行化解决的问题没必要并行，所以即使将来many-core系统成为主流，大部分程序员也没必要去搞并行计算。
  我觉得未来的主流应该是类似cell这样一颗全功能核心带众多协处理核心的异构系统，这样才能达到最优的 性能/核心面积比。</p>
<p>2010/3/24 Guancheng Chen <a href="&#x6d;&#x61;&#x69;&#108;&#116;&#111;&#x3a;&#x5b;&#x63;&#x68;&#101;&#110;&#103;&#117;&#x61;&#110;&#99;&#x68;&#x2e;&#46;&#46;&#x40;&#x67;&#x6d;&#97;&#x69;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#93;&#x28;&#41;">&#x5b;&#x63;&#x68;&#101;&#110;&#103;&#117;&#x61;&#110;&#99;&#x68;&#x2e;&#46;&#46;&#x40;&#x67;&#x6d;&#97;&#x69;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#93;&#x28;&#41;</a></p>
<p>Nice 大胆预测Linear speedup应该是每个程序员十年后的目标 呵呵</p>
<blockquote>
<p>On 3月23日, 上午10时43分, qiaojie <a href="&#x6d;&#97;&#105;&#108;&#116;&#111;&#x3a;&#91;&#113;&#105;&#97;&#x6f;&#46;&#46;&#x2e;&#x40;&#x67;&#109;&#97;&#x69;&#108;&#46;&#x63;&#111;&#109;&#93;&#40;&#x29;">&#91;&#113;&#105;&#97;&#x6f;&#46;&#46;&#x2e;&#x40;&#x67;&#109;&#97;&#x69;&#108;&#46;&#x63;&#111;&#109;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>目前正在写的是一个软件渲染器，采用了光栅化和光线跟踪混合算法，渲染算法已经完全并行化了，
在4核系统上基本可以达到线性加速比，更多核的系统暂时还没测试。kd-tree的构造暂时还没有并
行化，以后有空了再研究。</p>
<p>2010/3/23 Guancheng Chen <a href="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#x6f;&#x3a;&#x5b;&#x63;&#104;&#x65;&#110;&#x67;&#117;&#97;&#x6e;&#99;&#104;&#46;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#93;&#x28;&#x29;">&#x5b;&#x63;&#104;&#x65;&#110;&#x67;&#117;&#97;&#x6e;&#99;&#104;&#46;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#93;&#x28;&#x29;</a></p>
<blockquote>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？</p>
<p>On 3月23日, 上午9时15分, qiaojie <a href="&#109;&#97;&#x69;&#x6c;&#x74;&#x6f;&#x3a;&#91;&#113;&#x69;&#x61;&#111;&#46;&#46;&#x2e;&#64;&#x67;&#109;&#97;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#x28;&#x29;">&#91;&#113;&#x69;&#x61;&#111;&#46;&#46;&#x2e;&#64;&#x67;&#109;&#97;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1)
=
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank
Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？</p>
</blockquote>
<p> To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> 机械唯物主义 : linjunhalida <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-25</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>产能过剩的说法本来就不对。
产出的东西没有价值，这样的活动就不能说是生产。
比如我这个程序员，花了1周写了一个垃圾程序，然后被开除了。
然后1个月闲着，这是我产能过剩吗？
而闲着的原因是政府给我失业金，我就不需要工作闲起来了。。。
2010/3/25 qiaojie <a href="&#x6d;&#97;&#105;&#x6c;&#116;&#111;&#58;&#91;&#x71;&#x69;&#97;&#x2e;&#46;&#46;&#x40;&#x67;&#109;&#x61;&#x69;&#108;&#46;&#x63;&#111;&#109;&#93;&#40;&#41;">&#91;&#x71;&#x69;&#97;&#x2e;&#46;&#46;&#x40;&#x67;&#109;&#x61;&#x69;&#108;&#46;&#x63;&#111;&#109;&#93;&#40;&#41;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>如果产能=消费的话就没有产能过剩这一说了。</p>
<p>2010/3/25 机械唯物主义 : linjunhalida <a href="&#x6d;&#97;&#x69;&#108;&#116;&#x6f;&#x3a;&#x5b;&#x6c;&#x69;&#110;&#x6a;&#x75;&#x6e;&#46;&#46;&#x2e;&#64;&#103;&#109;&#x61;&#105;&#108;&#46;&#x63;&#x6f;&#109;&#93;&#x28;&#x29;">&#x5b;&#x6c;&#x69;&#110;&#x6a;&#x75;&#x6e;&#46;&#46;&#x2e;&#64;&#103;&#109;&#x61;&#105;&#108;&#46;&#x63;&#x6f;&#109;&#93;&#x28;&#x29;</a></p>
<p>一个谬误：刺激需求
产能=消费，产能才是主动力。技术成长是随着产能成长而起来的。
而产能多的结果就是满足了需求，造成一种需求带来技术进步的假像。
而技术和产能之间的关系又错综复杂。。
2010/3/25 qiaojie <a href="&#x6d;&#97;&#105;&#108;&#x74;&#111;&#58;&#x5b;&#113;&#x69;&#x61;&#x2e;&#46;&#x2e;&#x40;&#103;&#109;&#97;&#x69;&#108;&#46;&#x63;&#111;&#109;&#x5d;&#x28;&#x29;">&#x5b;&#113;&#x69;&#x61;&#x2e;&#46;&#x2e;&#x40;&#103;&#109;&#97;&#x69;&#108;&#46;&#x63;&#111;&#109;&#x5d;&#x28;&#x29;</a></p>
<p>3D游戏就是一类杀手应用，由此支撑起了一个庞大的GPU市场，芯片行业的研发成本是很高的，没有一个庞大的市场是做不起来的。目前的消费者对于多核系统显然还没有强烈的需求，因为应用跟不上，i7发布快2年了还没进入主流市场，这种情况延续下去的话摩尔定律将因此失效。不过我相信杀手级应用总会出现的，这可能要硬件性能突破一个临界点，比方说目前GPU的性能再提升一个数量级的话，光线跟踪算法就可以提供流畅的接近CG的画质，倒是此类应用便会流行开来。</p>
<p>2010/3/25 Guancheng Chen <a href="&#x6d;&#x61;&#x69;&#108;&#x74;&#111;&#58;&#91;&#x63;&#x68;&#101;&#x6e;&#x67;&#x75;&#46;&#x2e;&#x2e;&#x40;&#103;&#109;&#97;&#x69;&#108;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#41;">&#91;&#x63;&#x68;&#101;&#x6e;&#x67;&#x75;&#46;&#x2e;&#x2e;&#x40;&#103;&#109;&#97;&#x69;&#108;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#41;</a></p>
<p>杀手应用一般来说是指什么样的应用呢？比如用户群特别大的网游？还是那些专有的科学计算用的软件？
On 3月24日, 下午12时36分, qiaojie <a href="&#x6d;&#x61;&#105;&#108;&#x74;&#x6f;&#x3a;&#91;&#113;&#x69;&#97;&#x6f;&#x2e;&#46;&#x2e;&#x40;&#103;&#x6d;&#x61;&#x69;&#108;&#46;&#99;&#111;&#109;&#93;&#40;&#41;">&#91;&#113;&#x69;&#97;&#x6f;&#x2e;&#46;&#x2e;&#x40;&#103;&#x6d;&#x61;&#x69;&#108;&#46;&#99;&#111;&#109;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>并行计算本来就是曲高和寡的东西，就跟3D渲染一样，能开发引擎的毕竟只是小部分人，大多数人在引擎的基础上做应用。关键在于是否有杀手应用，只要有大量的需求 ，自然会有人去做开发。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#109;&#97;&#x69;&#108;&#x74;&#111;&#58;&#x5b;&#x68;&#x6f;&#110;&#x67;&#122;&#x68;&#x61;&#x6e;&#103;&#46;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#109;&#x61;&#x69;&#x6c;&#46;&#x63;&#111;&#x6d;&#93;&#40;&#41;">&#x5b;&#x68;&#x6f;&#110;&#x67;&#122;&#x68;&#x61;&#x6e;&#103;&#46;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#109;&#x61;&#x69;&#x6c;&#46;&#x63;&#111;&#x6d;&#93;&#40;&#41;</a></p>
<blockquote>
<p>异构平台从网络处理器算起已经快10年了，现在情况仍然不明朗。就我看到的，异构平台要想高效，就必须向程序员暴露非常多的硬件细节，这必然导致编程的复杂性。 曲高和寡，要想渗透到应用程序这一块，我觉得很难。</p>
<p>2010/3/24 qiaojie <a href="&#109;&#97;&#105;&#x6c;&#x74;&#x6f;&#58;&#x5b;&#113;&#105;&#97;&#x6f;&#46;&#46;&#x2e;&#64;&#103;&#x6d;&#97;&#x69;&#108;&#x2e;&#99;&#x6f;&#109;&#93;&#x28;&#x29;">&#x5b;&#113;&#105;&#97;&#x6f;&#46;&#46;&#x2e;&#64;&#103;&#x6d;&#97;&#x69;&#108;&#x2e;&#99;&#x6f;&#109;&#93;&#x28;&#x29;</a></p>
<blockquote>
<p>说的没错，cell已经成了先烈了。不过这不代表异构的方向不对，CUDA，OpenCL也都是异构平台，以后我们会越来越习惯异构平台的。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#109;&#x61;&#105;&#108;&#116;&#111;&#x3a;&#x5b;&#104;&#x6f;&#x6e;&#103;&#122;&#104;&#x61;&#110;&#x67;&#x2e;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#109;&#97;&#105;&#x6c;&#46;&#99;&#x6f;&#109;&#x5d;&#x28;&#41;">&#x5b;&#104;&#x6f;&#x6e;&#103;&#122;&#104;&#x61;&#110;&#x67;&#x2e;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#109;&#97;&#105;&#x6c;&#46;&#99;&#x6f;&#109;&#x5d;&#x28;&#41;</a></p>
<p>异构平台如果编程复杂度降不下来的话很难流行起来。cell已经死了...</p>
<blockquote>
<p> 2010/3/24 qiaojie <a href="&#109;&#97;&#x69;&#x6c;&#116;&#x6f;&#58;&#x5b;&#113;&#x69;&#x61;&#111;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#109;&#x61;&#105;&#108;&#x2e;&#x63;&#x6f;&#109;&#93;&#x28;&#41;">&#x5b;&#113;&#x69;&#x61;&#111;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#109;&#x61;&#105;&#108;&#x2e;&#x63;&#x6f;&#109;&#93;&#x28;&#41;</a></p>
<blockquote>
<p>不是所有的程序都需要并行化的，能用串行化解决的问题没必要并行，所以即使将来many-core系统成为主流，大部分程序员也没必要去搞并行计算。
  我觉得未来的主流应该是类似cell这样一颗全功能核心带众多协处理核心的异构系统，这样才能达到最优的 性能/核心面积比。</p>
<p>2010/3/24 Guancheng Chen <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#x3a;&#x5b;&#x63;&#x68;&#101;&#x6e;&#103;&#x75;&#x61;&#x6e;&#x63;&#x68;&#x2e;&#x2e;&#x2e;&#64;&#103;&#109;&#x61;&#105;&#108;&#x2e;&#99;&#x6f;&#x6d;&#93;&#40;&#x29;">&#x5b;&#x63;&#x68;&#101;&#x6e;&#103;&#x75;&#x61;&#x6e;&#x63;&#x68;&#x2e;&#x2e;&#x2e;&#64;&#103;&#109;&#x61;&#105;&#108;&#x2e;&#99;&#x6f;&#x6d;&#93;&#40;&#x29;</a></p>
<p>Nice 大胆预测Linear speedup应该是每个程序员十年后的目标 呵呵</p>
<blockquote>
<p>On 3月23日, 上午10时43分, qiaojie <a href="&#109;&#97;&#x69;&#108;&#x74;&#x6f;&#58;&#91;&#x71;&#x69;&#97;&#x6f;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#93;&#x28;&#x29;">&#91;&#x71;&#x69;&#97;&#x6f;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>目前正在写的是一个软件渲染器，采用了光栅化和光线跟踪混合算法，渲染算法已经完全并行化了，
在4核系统上基本可以达到线性加速比，更多核的系统暂时还没测试。kd-tree的构造暂时还没有并
行化，以后有空了再研究。</p>
<p>2010/3/23 Guancheng Chen <a href="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#111;&#58;&#91;&#99;&#104;&#x65;&#110;&#x67;&#x75;&#x61;&#110;&#x63;&#104;&#46;&#46;&#46;&#64;&#103;&#109;&#97;&#x69;&#108;&#x2e;&#x63;&#111;&#x6d;&#93;&#x28;&#41;">&#91;&#99;&#104;&#x65;&#110;&#x67;&#x75;&#x61;&#110;&#x63;&#104;&#46;&#46;&#46;&#64;&#103;&#109;&#97;&#x69;&#108;&#x2e;&#x63;&#111;&#x6d;&#93;&#x28;&#41;</a></p>
<blockquote>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？</p>
<p>On 3月23日, 上午9时15分, qiaojie <a href="&#x6d;&#97;&#105;&#x6c;&#116;&#x6f;&#x3a;&#91;&#x71;&#105;&#97;&#x6f;&#x2e;&#46;&#46;&#64;&#x67;&#x6d;&#x61;&#105;&#108;&#46;&#x63;&#111;&#x6d;&#93;&#x28;&#41;">&#91;&#x71;&#105;&#97;&#x6f;&#x2e;&#46;&#46;&#64;&#x67;&#x6d;&#x61;&#105;&#108;&#46;&#x63;&#111;&#x6d;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1)
=
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank
Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？</p>
</blockquote>
<p> To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a></p>
<p><img src="" alt=""> 机械唯物主义 : linjunhalida <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-25</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>扯远了。我觉得并行和串行应该是信息处理本质上的2种方式，
在不同的场景下，可以采用不同的方式进行。
重要的是能够“又好又快”地实现需求，以及根据场景，把一个需求进行实现方式的伸缩。
不过看起来这样的工作还是要靠程序员来实现？而体系架构设计者要根据对应问题的本质特性来设计架构？
2010/3/25 机械唯物主义 : linjunhalida <a href="&#109;&#x61;&#x69;&#x6c;&#x74;&#111;&#58;&#x5b;&#108;&#105;&#110;&#106;&#x75;&#110;&#46;&#46;&#x2e;&#x40;&#x67;&#109;&#97;&#105;&#108;&#x2e;&#99;&#111;&#x6d;&#93;&#40;&#x29;">&#x5b;&#108;&#105;&#110;&#106;&#x75;&#110;&#46;&#46;&#x2e;&#x40;&#x67;&#109;&#97;&#105;&#108;&#x2e;&#99;&#111;&#x6d;&#93;&#40;&#x29;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>产能过剩的说法本来就不对。
产出的东西没有价值，这样的活动就不能说是生产。
比如我这个程序员，花了1周写了一个垃圾程序，然后被开除了。
然后1个月闲着，这是我产能过剩吗？
而闲着的原因是政府给我失业金，我就不需要工作闲起来了。。。</p>
<p>2010/3/25 qiaojie <a href="&#109;&#x61;&#105;&#108;&#116;&#x6f;&#x3a;&#x5b;&#113;&#105;&#x61;&#46;&#46;&#46;&#64;&#103;&#x6d;&#97;&#x69;&#x6c;&#46;&#99;&#x6f;&#109;&#93;&#40;&#x29;">&#x5b;&#113;&#105;&#x61;&#46;&#46;&#46;&#64;&#103;&#x6d;&#97;&#x69;&#x6c;&#46;&#99;&#x6f;&#109;&#93;&#40;&#x29;</a>
如果产能=消费的话就没有产能过剩这一说了。</p>
<p>2010/3/25 机械唯物主义 : linjunhalida <a href="&#109;&#x61;&#105;&#108;&#x74;&#111;&#58;&#x5b;&#108;&#105;&#110;&#x6a;&#117;&#x6e;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#109;&#x61;&#105;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#93;&#40;&#x29;">&#x5b;&#108;&#105;&#110;&#x6a;&#117;&#x6e;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#109;&#x61;&#105;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#93;&#40;&#x29;</a></p>
<p>一个谬误：刺激需求
产能=消费，产能才是主动力。技术成长是随着产能成长而起来的。
而产能多的结果就是满足了需求，造成一种需求带来技术进步的假像。
而技术和产能之间的关系又错综复杂。。
2010/3/25 qiaojie <a href="&#109;&#97;&#105;&#108;&#116;&#x6f;&#58;&#91;&#113;&#105;&#97;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#97;&#x69;&#x6c;&#46;&#99;&#111;&#109;&#x5d;&#x28;&#41;">&#91;&#113;&#105;&#97;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#97;&#x69;&#x6c;&#46;&#99;&#111;&#109;&#x5d;&#x28;&#41;</a></p>
<p>3D游戏就是一类杀手应用，由此支撑起了一个庞大的GPU市场，芯片行业的研发成本是很高的，没有一个庞大的市场是做不起来的。目前的消费者对于多核系统显然还没有强烈的需求，因为应用跟不上，i7发布快2年了还没进入主流市场，这种情况延续下去的话摩尔定律将因此失效。不过我相信杀手级应用总会出现的，这可能要硬件性能突破一个临界点，比方说目前GPU的性能再提升一个数量级的话，光线跟踪算法就可以提供流畅的接近CG的画质，倒是此类应用便会流行开来。</p>
<p>2010/3/25 Guancheng Chen <a href="&#109;&#97;&#x69;&#108;&#116;&#111;&#x3a;&#91;&#x63;&#x68;&#x65;&#110;&#103;&#x75;&#x2e;&#x2e;&#x2e;&#64;&#103;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#111;&#109;&#x5d;&#40;&#41;">&#91;&#x63;&#x68;&#x65;&#110;&#103;&#x75;&#x2e;&#x2e;&#x2e;&#64;&#103;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#111;&#109;&#x5d;&#40;&#41;</a></p>
<p>杀手应用一般来说是指什么样的应用呢？比如用户群特别大的网游？还是那些专有的科学计算用的软件？
On 3月24日, 下午12时36分, qiaojie <a href="&#109;&#x61;&#x69;&#108;&#116;&#x6f;&#58;&#x5b;&#x71;&#105;&#97;&#x6f;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#99;&#111;&#x6d;&#x5d;&#40;&#x29;">&#x5b;&#x71;&#105;&#97;&#x6f;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#99;&#111;&#x6d;&#x5d;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>并行计算本来就是曲高和寡的东西，就跟3D渲染一样，能开发引擎的毕竟只是小部分人，大多数人在引擎的基础上做应用。关键在于是否有杀手应用，只要有大量的需求 ，自然会有人去做开发。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#109;&#97;&#x69;&#x6c;&#116;&#x6f;&#x3a;&#x5b;&#104;&#111;&#110;&#x67;&#122;&#104;&#97;&#x6e;&#x67;&#46;&#x2e;&#46;&#x2e;&#x40;&#x67;&#x6d;&#97;&#x69;&#108;&#x2e;&#99;&#111;&#109;&#93;&#40;&#41;">&#x5b;&#104;&#111;&#110;&#x67;&#122;&#104;&#97;&#x6e;&#x67;&#46;&#x2e;&#46;&#x2e;&#x40;&#x67;&#x6d;&#97;&#x69;&#108;&#x2e;&#99;&#111;&#109;&#93;&#40;&#41;</a></p>
<blockquote>
<p>异构平台从网络处理器算起已经快10年了，现在情况仍然不明朗。就我看到的，异构平台要想高效，就必须向程序员暴露非常多的硬件细节，这必然导致编程的复杂性。 曲高和寡，要想渗透到应用程序这一块，我觉得很难。</p>
<p>2010/3/24 qiaojie <a href="&#109;&#97;&#105;&#x6c;&#116;&#x6f;&#x3a;&#x5b;&#113;&#105;&#97;&#111;&#46;&#46;&#46;&#x40;&#103;&#109;&#x61;&#x69;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#40;&#41;">&#x5b;&#113;&#105;&#97;&#111;&#46;&#46;&#46;&#x40;&#103;&#109;&#x61;&#x69;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#40;&#41;</a></p>
<blockquote>
<p>说的没错，cell已经成了先烈了。不过这不代表异构的方向不对，CUDA，OpenCL也都是异构平台，以后我们会越来越习惯异构平台的。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#x6d;&#97;&#105;&#108;&#x74;&#x6f;&#x3a;&#x5b;&#x68;&#x6f;&#x6e;&#103;&#122;&#104;&#x61;&#110;&#x67;&#46;&#46;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#x61;&#105;&#108;&#46;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#41;">&#x5b;&#x68;&#x6f;&#x6e;&#103;&#122;&#104;&#x61;&#110;&#x67;&#46;&#46;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#x61;&#105;&#108;&#46;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#41;</a></p>
<p>异构平台如果编程复杂度降不下来的话很难流行起来。cell已经死了...</p>
<blockquote>
<p> 2010/3/24 qiaojie <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#x3a;&#91;&#x71;&#105;&#x61;&#x6f;&#46;&#x2e;&#x2e;&#64;&#x67;&#109;&#x61;&#105;&#x6c;&#46;&#99;&#x6f;&#x6d;&#93;&#40;&#x29;">&#91;&#x71;&#105;&#x61;&#x6f;&#46;&#x2e;&#x2e;&#64;&#x67;&#109;&#x61;&#105;&#x6c;&#46;&#99;&#x6f;&#x6d;&#93;&#40;&#x29;</a></p>
<blockquote>
<p>不是所有的程序都需要并行化的，能用串行化解决的问题没必要并行，所以即使将来many-core系统成为主流，大部分程序员也没必要去搞并行计算。
  我觉得未来的主流应该是类似cell这样一颗全功能核心带众多协处理核心的异构系统，这样才能达到最优的 性能/核心面积比。</p>
<p>2010/3/24 Guancheng Chen <a href="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#x6f;&#x3a;&#91;&#99;&#x68;&#101;&#x6e;&#103;&#x75;&#x61;&#110;&#x63;&#x68;&#x2e;&#46;&#x2e;&#64;&#x67;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#93;&#40;&#41;">&#91;&#99;&#x68;&#101;&#x6e;&#103;&#x75;&#x61;&#110;&#x63;&#x68;&#x2e;&#46;&#x2e;&#64;&#x67;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#93;&#40;&#41;</a></p>
<p>Nice 大胆预测Linear speedup应该是每个程序员十年后的目标 呵呵</p>
<blockquote>
<p>On 3月23日, 上午10时43分, qiaojie <a href="&#x6d;&#97;&#105;&#x6c;&#116;&#111;&#x3a;&#x5b;&#113;&#105;&#x61;&#x6f;&#x2e;&#x2e;&#46;&#64;&#103;&#x6d;&#97;&#x69;&#108;&#46;&#x63;&#x6f;&#109;&#93;&#x28;&#x29;">&#x5b;&#113;&#105;&#x61;&#x6f;&#x2e;&#x2e;&#46;&#64;&#103;&#x6d;&#97;&#x69;&#108;&#46;&#x63;&#x6f;&#109;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>目前正在写的是一个软件渲染器，采用了光栅化和光线跟踪混合算法，渲染算法已经完全并行化了，
在4核系统上基本可以达到线性加速比，更多核的系统暂时还没测试。kd-tree的构造暂时还没有并
行化，以后有空了再研究。</p>
<p>2010/3/23 Guancheng Chen <a href="&#x6d;&#x61;&#105;&#x6c;&#116;&#111;&#58;&#x5b;&#x63;&#x68;&#x65;&#110;&#103;&#117;&#x61;&#110;&#x63;&#104;&#46;&#46;&#x2e;&#64;&#103;&#x6d;&#97;&#x69;&#108;&#46;&#x63;&#x6f;&#109;&#93;&#x28;&#x29;">&#x5b;&#x63;&#x68;&#x65;&#110;&#103;&#117;&#x61;&#110;&#x63;&#104;&#46;&#46;&#x2e;&#64;&#103;&#x6d;&#97;&#x69;&#108;&#46;&#x63;&#x6f;&#109;&#93;&#x28;&#x29;</a></p>
<blockquote>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？</p>
<p>On 3月23日, 上午9时15分, qiaojie <a href="&#x6d;&#97;&#x69;&#x6c;&#x74;&#111;&#58;&#91;&#x71;&#x69;&#97;&#111;&#46;&#x2e;&#x2e;&#x40;&#x67;&#109;&#x61;&#105;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#40;&#x29;">&#91;&#x71;&#x69;&#97;&#111;&#46;&#x2e;&#x2e;&#x40;&#x67;&#109;&#x61;&#105;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1)
=
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank
Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？</p>
</blockquote>
<p> To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> qiaojie <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-25</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>什么叫产能过剩？假设全世界每年消费10000亿斤粮食，结果今年收成好，生产了15000亿斤，</p>
<p>那多出来的5000亿斤无法被市场消化掉，就是产能过剩。那5000亿斤没价值，是垃圾？生产那
5000亿斤的农民是闲的蛋疼没事干？靠政府失业金养？</p>
<p>2010/3/25 机械唯物主义 : linjunhalida <a href="&#109;&#97;&#x69;&#x6c;&#116;&#111;&#58;&#91;&#108;&#x69;&#110;&#x6a;&#117;&#x6e;&#46;&#46;&#46;&#64;&#103;&#109;&#x61;&#105;&#108;&#x2e;&#99;&#111;&#109;&#x5d;&#40;&#41;">&#91;&#108;&#x69;&#110;&#x6a;&#117;&#x6e;&#46;&#46;&#46;&#64;&#103;&#109;&#x61;&#105;&#108;&#x2e;&#99;&#111;&#109;&#x5d;&#40;&#41;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>产能过剩的说法本来就不对。
产出的东西没有价值，这样的活动就不能说是生产。
比如我这个程序员，花了1周写了一个垃圾程序，然后被开除了。
然后1个月闲着，这是我产能过剩吗？
而闲着的原因是政府给我失业金，我就不需要工作闲起来了。。。</p>
<p>2010/3/25 qiaojie <a href="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#111;&#x3a;&#91;&#x71;&#x69;&#x61;&#x2e;&#x2e;&#46;&#x40;&#103;&#x6d;&#97;&#105;&#x6c;&#x2e;&#99;&#x6f;&#109;&#x5d;&#x28;&#x29;">&#91;&#x71;&#x69;&#x61;&#x2e;&#x2e;&#46;&#x40;&#103;&#x6d;&#97;&#105;&#x6c;&#x2e;&#99;&#x6f;&#109;&#x5d;&#x28;&#x29;</a>
如果产能=消费的话就没有产能过剩这一说了。</p>
<p>2010/3/25 机械唯物主义 : linjunhalida <a href="&#109;&#97;&#105;&#108;&#116;&#x6f;&#x3a;&#91;&#108;&#x69;&#110;&#106;&#117;&#x6e;&#46;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#x63;&#111;&#109;&#93;&#x28;&#41;">&#91;&#108;&#x69;&#110;&#106;&#117;&#x6e;&#46;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#x63;&#111;&#109;&#93;&#x28;&#41;</a></p>
<p>一个谬误：刺激需求
产能=消费，产能才是主动力。技术成长是随着产能成长而起来的。
而产能多的结果就是满足了需求，造成一种需求带来技术进步的假像。
而技术和产能之间的关系又错综复杂。。
2010/3/25 qiaojie <a href="&#109;&#x61;&#x69;&#108;&#116;&#111;&#58;&#x5b;&#113;&#105;&#x61;&#x2e;&#46;&#x2e;&#64;&#x67;&#x6d;&#97;&#105;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#41;">&#x5b;&#113;&#105;&#x61;&#x2e;&#46;&#x2e;&#64;&#x67;&#x6d;&#97;&#105;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#41;</a></p>
<p>3D游戏就是一类杀手应用，由此支撑起了一个庞大的GPU市场，芯片行业的研发成本是很高的，没有一个庞大的市场是做不起来的。目前的消费者对于多核系统显然还没有强烈的需求，因为应用跟不上，i7发布快2年了还没进入主流市场，这种情况延续下去的话摩尔定律将因此失效。不过我相信杀手级应用总会出现的，这可能要硬件性能突破一个临界点，比方说目前GPU的性能再提升一个数量级的话，光线跟踪算法就可以提供流畅的接近CG的画质，倒是此类应用便会流行开来。</p>
<p>2010/3/25 Guancheng Chen <a href="&#x6d;&#97;&#x69;&#x6c;&#x74;&#111;&#58;&#x5b;&#99;&#104;&#101;&#110;&#103;&#x75;&#x2e;&#46;&#46;&#x40;&#x67;&#109;&#97;&#x69;&#108;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#40;&#x29;">&#x5b;&#99;&#104;&#101;&#110;&#103;&#x75;&#x2e;&#46;&#46;&#x40;&#x67;&#109;&#97;&#x69;&#108;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#40;&#x29;</a></p>
<p>杀手应用一般来说是指什么样的应用呢？比如用户群特别大的网游？还是那些专有的科学计算用的软件？
On 3月24日, 下午12时36分, qiaojie <a href="&#x6d;&#97;&#105;&#108;&#x74;&#111;&#58;&#91;&#x71;&#x69;&#x61;&#x6f;&#x2e;&#46;&#x2e;&#64;&#103;&#109;&#97;&#x69;&#108;&#x2e;&#x63;&#111;&#109;&#93;&#40;&#41;">&#91;&#x71;&#x69;&#x61;&#x6f;&#x2e;&#46;&#x2e;&#64;&#103;&#109;&#97;&#x69;&#108;&#x2e;&#x63;&#111;&#109;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>并行计算本来就是曲高和寡的东西，就跟3D渲染一样，能开发引擎的毕竟只是小部分人，大多数人在引擎的基础上做应用。关键在于是否有杀手应用，只要有大量的需求 ，自然会有人去做开发。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#x6d;&#97;&#105;&#108;&#x74;&#x6f;&#58;&#x5b;&#104;&#111;&#110;&#103;&#122;&#x68;&#x61;&#110;&#x67;&#x2e;&#x2e;&#46;&#x2e;&#x40;&#x67;&#x6d;&#97;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#93;&#x28;&#x29;">&#x5b;&#104;&#111;&#110;&#103;&#122;&#x68;&#x61;&#110;&#x67;&#x2e;&#x2e;&#46;&#x2e;&#x40;&#x67;&#x6d;&#97;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#93;&#x28;&#x29;</a></p>
<blockquote>
<p>异构平台从网络处理器算起已经快10年了，现在情况仍然不明朗。就我看到的，异构平台要想高效，就必须向程序员暴露非常多的硬件细节，这必然导致编程的复杂性。 曲高和寡，要想渗透到应用程序这一块，我觉得很难。</p>
<p>2010/3/24 qiaojie <a href="&#109;&#x61;&#x69;&#x6c;&#x74;&#x6f;&#x3a;&#x5b;&#x71;&#x69;&#x61;&#111;&#x2e;&#x2e;&#46;&#64;&#x67;&#109;&#97;&#x69;&#x6c;&#x2e;&#99;&#111;&#x6d;&#93;&#40;&#x29;">&#x5b;&#x71;&#x69;&#x61;&#111;&#x2e;&#x2e;&#46;&#64;&#x67;&#109;&#97;&#x69;&#x6c;&#x2e;&#99;&#111;&#x6d;&#93;&#40;&#x29;</a></p>
<blockquote>
<p>说的没错，cell已经成了先烈了。不过这不代表异构的方向不对，CUDA，OpenCL也都是异构平台，以后我们会越来越习惯异构平台的。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#x6d;&#97;&#x69;&#x6c;&#x74;&#x6f;&#x3a;&#91;&#104;&#111;&#110;&#103;&#x7a;&#x68;&#97;&#x6e;&#x67;&#x2e;&#46;&#46;&#46;&#x40;&#x67;&#x6d;&#97;&#x69;&#x6c;&#46;&#99;&#111;&#x6d;&#x5d;&#40;&#x29;">&#91;&#104;&#111;&#110;&#103;&#x7a;&#x68;&#97;&#x6e;&#x67;&#x2e;&#46;&#46;&#46;&#x40;&#x67;&#x6d;&#97;&#x69;&#x6c;&#46;&#99;&#111;&#x6d;&#x5d;&#40;&#x29;</a></p>
<p>异构平台如果编程复杂度降不下来的话很难流行起来。cell已经死了...</p>
<blockquote>
<p> 2010/3/24 qiaojie <a href="&#109;&#97;&#105;&#x6c;&#x74;&#111;&#x3a;&#x5b;&#x71;&#105;&#x61;&#111;&#x2e;&#46;&#46;&#x40;&#103;&#109;&#x61;&#105;&#x6c;&#x2e;&#99;&#111;&#109;&#x5d;&#x28;&#41;">&#x5b;&#x71;&#105;&#x61;&#111;&#x2e;&#46;&#46;&#x40;&#103;&#109;&#x61;&#105;&#x6c;&#x2e;&#99;&#111;&#109;&#x5d;&#x28;&#41;</a></p>
<blockquote>
<p>不是所有的程序都需要并行化的，能用串行化解决的问题没必要并行，所以即使将来many-core系统成为主流，大部分程序员也没必要去搞并行计算。
  我觉得未来的主流应该是类似cell这样一颗全功能核心带众多协处理核心的异构系统，这样才能达到最优的 性能/核心面积比。</p>
<p>2010/3/24 Guancheng Chen <a href="&#109;&#97;&#x69;&#108;&#x74;&#x6f;&#58;&#91;&#99;&#104;&#101;&#110;&#x67;&#x75;&#97;&#110;&#x63;&#x68;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#109;&#97;&#105;&#108;&#46;&#x63;&#111;&#x6d;&#x5d;&#40;&#x29;">&#91;&#99;&#104;&#101;&#110;&#x67;&#x75;&#97;&#110;&#x63;&#x68;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#109;&#97;&#105;&#108;&#46;&#x63;&#111;&#x6d;&#x5d;&#40;&#x29;</a></p>
<p>Nice 大胆预测Linear speedup应该是每个程序员十年后的目标 呵呵</p>
<blockquote>
<p>On 3月23日, 上午10时43分, qiaojie <a href="&#x6d;&#97;&#x69;&#x6c;&#x74;&#111;&#x3a;&#x5b;&#x71;&#x69;&#97;&#111;&#46;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#x61;&#105;&#x6c;&#46;&#x63;&#x6f;&#109;&#93;&#40;&#x29;">&#x5b;&#x71;&#x69;&#97;&#111;&#46;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#x61;&#105;&#x6c;&#46;&#x63;&#x6f;&#109;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>目前正在写的是一个软件渲染器，采用了光栅化和光线跟踪混合算法，渲染算法已经完全并行化了，
在4核系统上基本可以达到线性加速比，更多核的系统暂时还没测试。kd-tree的构造暂时还没有并
行化，以后有空了再研究。</p>
<p>2010/3/23 Guancheng Chen <a href="&#x6d;&#97;&#105;&#108;&#116;&#111;&#x3a;&#x5b;&#x63;&#104;&#101;&#110;&#x67;&#x75;&#97;&#110;&#x63;&#104;&#46;&#46;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#x29;">&#x5b;&#x63;&#104;&#101;&#110;&#x67;&#x75;&#97;&#110;&#x63;&#104;&#46;&#46;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#x29;</a></p>
<blockquote>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？</p>
<p>On 3月23日, 上午9时15分, qiaojie <a href="&#x6d;&#x61;&#105;&#108;&#116;&#x6f;&#58;&#x5b;&#113;&#x69;&#97;&#111;&#46;&#46;&#x2e;&#64;&#x67;&#x6d;&#97;&#105;&#108;&#x2e;&#99;&#111;&#x6d;&#x5d;&#40;&#41;">&#x5b;&#113;&#x69;&#97;&#111;&#46;&#46;&#x2e;&#64;&#x67;&#x6d;&#97;&#105;&#108;&#x2e;&#99;&#111;&#x6d;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1)
=
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank
Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？</p>
</blockquote>
<p> To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a></p>
<p><img src="" alt=""> tinyfool <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-25</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>哈哈，终于从技术聊到经济了</p>
<p>在 2010-3-25，下午2:11， qiaojie 写道：</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>什么叫产能过剩？假设全世界每年消费10000亿斤粮食，结果今年收成好，生产了15000亿斤，</p>
<p>那多出来的5000亿斤无法被市场消化掉，就是产能过剩。那5000亿斤没价值，是垃圾？生产那
5000亿斤的农民是闲的蛋疼没事干？靠政府失业金养？</p>
<p>2010/3/25 机械唯物主义 : linjunhalida <a href="&#x6d;&#x61;&#x69;&#x6c;&#116;&#111;&#x3a;&#x5b;&#x6c;&#x69;&#110;&#106;&#x75;&#110;&#x2e;&#x2e;&#46;&#64;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#99;&#111;&#109;&#93;&#x28;&#x29;">&#x5b;&#x6c;&#x69;&#110;&#106;&#x75;&#110;&#x2e;&#x2e;&#46;&#64;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#99;&#111;&#109;&#93;&#x28;&#x29;</a>
产能过剩的说法本来就不对。
产出的东西没有价值，这样的活动就不能说是生产。
比如我这个程序员，花了1周写了一个垃圾程序，然后被开除了。
然后1个月闲着，这是我产能过剩吗？
而闲着的原因是政府给我失业金，我就不需要工作闲起来了。。。</p>
<p>2010/3/25 qiaojie <a href="&#109;&#x61;&#105;&#x6c;&#116;&#111;&#58;&#x5b;&#x71;&#105;&#x61;&#46;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#97;&#x69;&#108;&#46;&#x63;&#x6f;&#x6d;&#93;&#40;&#41;">&#x5b;&#x71;&#105;&#x61;&#46;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#97;&#x69;&#108;&#46;&#x63;&#x6f;&#x6d;&#93;&#40;&#41;</a>
如果产能=消费的话就没有产能过剩这一说了。</p>
<p>2010/3/25 机械唯物主义 : linjunhalida <a href="&#x6d;&#97;&#x69;&#x6c;&#x74;&#x6f;&#x3a;&#91;&#108;&#x69;&#x6e;&#x6a;&#117;&#110;&#x2e;&#46;&#46;&#64;&#103;&#x6d;&#x61;&#105;&#108;&#46;&#x63;&#x6f;&#x6d;&#93;&#40;&#x29;">&#91;&#108;&#x69;&#x6e;&#x6a;&#117;&#110;&#x2e;&#46;&#46;&#64;&#103;&#x6d;&#x61;&#105;&#108;&#46;&#x63;&#x6f;&#x6d;&#93;&#40;&#x29;</a></p>
<p>一个谬误：刺激需求
产能=消费，产能才是主动力。技术成长是随着产能成长而起来的。
而产能多的结果就是满足了需求，造成一种需求带来技术进步的假像。
而技术和产能之间的关系又错综复杂。。
2010/3/25 qiaojie <a href="&#x6d;&#x61;&#105;&#x6c;&#x74;&#x6f;&#x3a;&#91;&#x71;&#105;&#x61;&#x2e;&#46;&#46;&#x40;&#103;&#109;&#x61;&#105;&#x6c;&#46;&#99;&#x6f;&#109;&#93;&#x28;&#x29;">&#91;&#x71;&#105;&#x61;&#x2e;&#46;&#46;&#x40;&#103;&#109;&#x61;&#105;&#x6c;&#46;&#99;&#x6f;&#109;&#93;&#x28;&#x29;</a></p>
<p>3D游戏就是一类杀手应用，由此支撑起了一个庞大的GPU市场，芯片行业的研发成本是很高的，没有一个庞大的市场是做不起来的。目前的消费者对于多核系统显然还没有强烈的需求，因为应用跟不上，i7发布快2年了还没进入主流市场，这种情况延续下去的话摩尔定律将因此失效。不过我相信杀手级应用总会出现的，这可能要硬件性能突破一个临界点，比方说目前GPU的性能再提升一个数量级的话，光线跟踪算法就可以提供流畅的接近CG的画质，倒是此类应用便会流行开来。</p>
<p>2010/3/25 Guancheng Chen <a href="&#109;&#97;&#x69;&#108;&#x74;&#111;&#58;&#x5b;&#99;&#x68;&#101;&#110;&#103;&#x75;&#46;&#46;&#46;&#64;&#x67;&#x6d;&#97;&#105;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#93;&#x28;&#41;">&#x5b;&#99;&#x68;&#101;&#110;&#103;&#x75;&#46;&#46;&#46;&#64;&#x67;&#x6d;&#97;&#105;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#93;&#x28;&#41;</a></p>
<p>杀手应用一般来说是指什么样的应用呢？比如用户群特别大的网游？还是那些专有的科学计算用的软件？
On 3月24日, 下午12时36分, qiaojie <a href="&#109;&#97;&#105;&#108;&#x74;&#111;&#58;&#91;&#x71;&#105;&#x61;&#x6f;&#46;&#46;&#46;&#x40;&#x67;&#x6d;&#97;&#x69;&#x6c;&#46;&#99;&#x6f;&#109;&#x5d;&#40;&#x29;">&#91;&#x71;&#105;&#x61;&#x6f;&#46;&#46;&#46;&#x40;&#x67;&#x6d;&#97;&#x69;&#x6c;&#46;&#99;&#x6f;&#109;&#x5d;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>并行计算本来就是曲高和寡的东西，就跟3D渲染一样，能开发引擎的毕竟只是小部分人，大多数人在引擎的基础上做应用。关键在于是否有杀手应用，只要有大量的需求 ，自然会有人去做开发。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#x6d;&#x61;&#x69;&#108;&#116;&#111;&#x3a;&#91;&#104;&#x6f;&#110;&#103;&#x7a;&#104;&#97;&#110;&#x67;&#46;&#x2e;&#46;&#46;&#x40;&#x67;&#109;&#97;&#105;&#x6c;&#46;&#99;&#x6f;&#109;&#x5d;&#40;&#41;">&#91;&#104;&#x6f;&#110;&#103;&#x7a;&#104;&#97;&#110;&#x67;&#46;&#x2e;&#46;&#46;&#x40;&#x67;&#109;&#97;&#105;&#x6c;&#46;&#99;&#x6f;&#109;&#x5d;&#40;&#41;</a></p>
<blockquote>
<p>异构平台从网络处理器算起已经快10年了，现在情况仍然不明朗。就我看到的，异构平台要想高效，就必须向程序员暴露非常多的硬件细节，这必然导致编程的复杂性。 曲高和寡，要想渗透到应用程序这一块，我觉得很难。</p>
<p>2010/3/24 qiaojie <a href="&#x6d;&#97;&#x69;&#108;&#x74;&#x6f;&#58;&#91;&#113;&#105;&#x61;&#x6f;&#x2e;&#x2e;&#46;&#x40;&#x67;&#109;&#97;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#109;&#93;&#40;&#x29;">&#91;&#113;&#105;&#x61;&#x6f;&#x2e;&#x2e;&#46;&#x40;&#x67;&#109;&#97;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#109;&#93;&#40;&#x29;</a></p>
<blockquote>
<p>说的没错，cell已经成了先烈了。不过这不代表异构的方向不对，CUDA，OpenCL也都是异构平台，以后我们会越来越习惯异构平台的。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#x6d;&#97;&#x69;&#108;&#116;&#111;&#58;&#91;&#104;&#x6f;&#x6e;&#103;&#x7a;&#104;&#97;&#110;&#x67;&#46;&#46;&#x2e;&#46;&#x40;&#103;&#109;&#97;&#x69;&#108;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#40;&#x29;">&#91;&#104;&#x6f;&#x6e;&#103;&#x7a;&#104;&#97;&#110;&#x67;&#46;&#46;&#x2e;&#46;&#x40;&#103;&#109;&#97;&#x69;&#108;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#40;&#x29;</a></p>
<p>异构平台如果编程复杂度降不下来的话很难流行起来。cell已经死了...</p>
<blockquote>
<p> 2010/3/24 qiaojie <a href="&#109;&#x61;&#x69;&#108;&#x74;&#111;&#x3a;&#91;&#x71;&#x69;&#x61;&#x6f;&#46;&#46;&#x2e;&#x40;&#x67;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#99;&#111;&#109;&#93;&#x28;&#41;">&#91;&#x71;&#x69;&#x61;&#x6f;&#46;&#46;&#x2e;&#x40;&#x67;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#99;&#111;&#109;&#93;&#x28;&#41;</a></p>
<blockquote>
<p>不是所有的程序都需要并行化的，能用串行化解决的问题没必要并行，所以即使将来many-core系统成为主流，大部分程序员也没必要去搞并行计算。
  我觉得未来的主流应该是类似cell这样一颗全功能核心带众多协处理核心的异构系统，这样才能达到最优的 性能/核心面积比。</p>
<p>2010/3/24 Guancheng Chen <a href="&#109;&#97;&#105;&#108;&#116;&#x6f;&#58;&#x5b;&#99;&#x68;&#101;&#x6e;&#103;&#x75;&#x61;&#x6e;&#x63;&#104;&#x2e;&#46;&#46;&#64;&#103;&#109;&#x61;&#105;&#x6c;&#46;&#99;&#111;&#x6d;&#93;&#40;&#41;">&#x5b;&#99;&#x68;&#101;&#x6e;&#103;&#x75;&#x61;&#x6e;&#x63;&#104;&#x2e;&#46;&#46;&#64;&#103;&#109;&#x61;&#105;&#x6c;&#46;&#99;&#111;&#x6d;&#93;&#40;&#41;</a></p>
<p>Nice 大胆预测Linear speedup应该是每个程序员十年后的目标 呵呵</p>
<blockquote>
<p>On 3月23日, 上午10时43分, qiaojie <a href="&#x6d;&#x61;&#105;&#x6c;&#116;&#x6f;&#58;&#91;&#x71;&#105;&#97;&#111;&#x2e;&#46;&#x2e;&#64;&#x67;&#109;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#41;">&#91;&#x71;&#105;&#97;&#111;&#x2e;&#46;&#x2e;&#64;&#x67;&#109;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>目前正在写的是一个软件渲染器，采用了光栅化和光线跟踪混合算法，渲染算法已经完全并行化了，
在4核系统上基本可以达到线性加速比，更多核的系统暂时还没测试。kd-tree的构造暂时还没有并
行化，以后有空了再研究。</p>
<p>2010/3/23 Guancheng Chen <a href="&#x6d;&#97;&#x69;&#108;&#x74;&#x6f;&#58;&#x5b;&#x63;&#x68;&#x65;&#110;&#x67;&#x75;&#x61;&#x6e;&#99;&#104;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#97;&#x69;&#108;&#46;&#x63;&#x6f;&#109;&#93;&#x28;&#x29;">&#x5b;&#x63;&#x68;&#x65;&#110;&#x67;&#x75;&#x61;&#x6e;&#99;&#104;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#97;&#x69;&#108;&#46;&#x63;&#x6f;&#109;&#93;&#x28;&#x29;</a></p>
<blockquote>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？</p>
<p>On 3月23日, 上午9时15分, qiaojie <a href="&#109;&#x61;&#105;&#x6c;&#116;&#111;&#58;&#x5b;&#x71;&#105;&#97;&#x6f;&#x2e;&#x2e;&#46;&#x40;&#103;&#109;&#x61;&#105;&#x6c;&#46;&#99;&#x6f;&#x6d;&#x5d;&#40;&#x29;">&#x5b;&#x71;&#105;&#97;&#x6f;&#x2e;&#x2e;&#46;&#x40;&#103;&#109;&#x61;&#105;&#x6c;&#46;&#99;&#x6f;&#x6d;&#x5d;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1)
=
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank
Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？</p>
</blockquote>
<p> To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> 机械唯物主义 : linjunhalida <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-25</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>本来就不该生产那么多的粮食，多余的人力和土地可以用来做别的事情。
问题在于为什么他们估算错误？
2010/3/25 qiaojie <a href="&#x6d;&#97;&#x69;&#x6c;&#116;&#111;&#58;&#91;&#x71;&#105;&#x61;&#46;&#x2e;&#x2e;&#64;&#x67;&#109;&#97;&#x69;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#41;">&#91;&#x71;&#105;&#x61;&#46;&#x2e;&#x2e;&#64;&#x67;&#109;&#97;&#x69;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#41;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>什么叫产能过剩？假设全世界每年消费10000亿斤粮食，结果今年收成好，生产了15000亿斤，</p>
<p>那多出来的5000亿斤无法被市场消化掉，就是产能过剩。那5000亿斤没价值，是垃圾？生产那
5000亿斤的农民是闲的蛋疼没事干？靠政府失业金养？</p>
<p>2010/3/25 机械唯物主义 : linjunhalida <a href="&#x6d;&#x61;&#x69;&#x6c;&#116;&#111;&#x3a;&#91;&#108;&#105;&#110;&#x6a;&#117;&#x6e;&#x2e;&#46;&#x2e;&#x40;&#x67;&#109;&#97;&#105;&#x6c;&#46;&#99;&#x6f;&#109;&#x5d;&#x28;&#41;">&#91;&#108;&#105;&#110;&#x6a;&#117;&#x6e;&#x2e;&#46;&#x2e;&#x40;&#x67;&#109;&#97;&#105;&#x6c;&#46;&#99;&#x6f;&#109;&#x5d;&#x28;&#41;</a>
产能过剩的说法本来就不对。
产出的东西没有价值，这样的活动就不能说是生产。
比如我这个程序员，花了1周写了一个垃圾程序，然后被开除了。
然后1个月闲着，这是我产能过剩吗？
而闲着的原因是政府给我失业金，我就不需要工作闲起来了。。。</p>
<p>2010/3/25 qiaojie <a href="&#109;&#x61;&#x69;&#108;&#116;&#x6f;&#x3a;&#x5b;&#x71;&#x69;&#x61;&#x2e;&#46;&#x2e;&#x40;&#103;&#109;&#x61;&#x69;&#x6c;&#46;&#99;&#111;&#x6d;&#93;&#40;&#x29;">&#x5b;&#x71;&#x69;&#x61;&#x2e;&#46;&#x2e;&#x40;&#103;&#109;&#x61;&#x69;&#x6c;&#46;&#99;&#111;&#x6d;&#93;&#40;&#x29;</a>
如果产能=消费的话就没有产能过剩这一说了。</p>
<p>2010/3/25 机械唯物主义 : linjunhalida <a href="&#x6d;&#97;&#x69;&#108;&#x74;&#111;&#58;&#91;&#x6c;&#x69;&#x6e;&#x6a;&#x75;&#x6e;&#x2e;&#x2e;&#46;&#64;&#103;&#109;&#x61;&#105;&#108;&#x2e;&#99;&#x6f;&#109;&#93;&#40;&#41;">&#91;&#x6c;&#x69;&#x6e;&#x6a;&#x75;&#x6e;&#x2e;&#x2e;&#46;&#64;&#103;&#109;&#x61;&#105;&#108;&#x2e;&#99;&#x6f;&#109;&#93;&#40;&#41;</a></p>
<p>一个谬误：刺激需求
产能=消费，产能才是主动力。技术成长是随着产能成长而起来的。
而产能多的结果就是满足了需求，造成一种需求带来技术进步的假像。
而技术和产能之间的关系又错综复杂。。
2010/3/25 qiaojie <a href="&#109;&#97;&#x69;&#x6c;&#x74;&#111;&#58;&#91;&#113;&#x69;&#x61;&#x2e;&#x2e;&#46;&#x40;&#x67;&#109;&#x61;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#40;&#41;">&#91;&#113;&#x69;&#x61;&#x2e;&#x2e;&#46;&#x40;&#x67;&#109;&#x61;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#40;&#41;</a></p>
<p>3D游戏就是一类杀手应用，由此支撑起了一个庞大的GPU市场，芯片行业的研发成本是很高的，没有一个庞大的市场是做不起来的。目前的消费者对于多核系统显然还没有强烈的需求，因为应用跟不上，i7发布快2年了还没进入主流市场，这种情况延续下去的话摩尔定律将因此失效。不过我相信杀手级应用总会出现的，这可能要硬件性能突破一个临界点，比方说目前GPU的性能再提升一个数量级的话，光线跟踪算法就可以提供流畅的接近CG的画质，倒是此类应用便会流行开来。</p>
<p>2010/3/25 Guancheng Chen <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#x3a;&#x5b;&#x63;&#x68;&#x65;&#110;&#x67;&#x75;&#46;&#46;&#46;&#64;&#103;&#x6d;&#x61;&#105;&#108;&#x2e;&#x63;&#111;&#109;&#93;&#40;&#41;">&#x5b;&#x63;&#x68;&#x65;&#110;&#x67;&#x75;&#46;&#46;&#46;&#64;&#103;&#x6d;&#x61;&#105;&#108;&#x2e;&#x63;&#111;&#109;&#93;&#40;&#41;</a></p>
<p>杀手应用一般来说是指什么样的应用呢？比如用户群特别大的网游？还是那些专有的科学计算用的软件？
On 3月24日, 下午12时36分, qiaojie <a href="&#x6d;&#97;&#105;&#x6c;&#x74;&#111;&#58;&#91;&#x71;&#x69;&#97;&#111;&#46;&#x2e;&#46;&#64;&#103;&#x6d;&#97;&#105;&#108;&#46;&#99;&#x6f;&#109;&#x5d;&#x28;&#x29;">&#91;&#x71;&#x69;&#97;&#111;&#46;&#x2e;&#46;&#64;&#103;&#x6d;&#97;&#105;&#108;&#46;&#99;&#x6f;&#109;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>并行计算本来就是曲高和寡的东西，就跟3D渲染一样，能开发引擎的毕竟只是小部分人，大多数人在引擎的基础上做应用。关键在于是否有杀手应用，只要有大量的需求 ，自然会有人去做开发。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#x6d;&#97;&#x69;&#108;&#x74;&#x6f;&#x3a;&#x5b;&#104;&#x6f;&#110;&#x67;&#122;&#x68;&#x61;&#x6e;&#103;&#x2e;&#x2e;&#46;&#46;&#64;&#x67;&#x6d;&#x61;&#105;&#108;&#x2e;&#99;&#x6f;&#x6d;&#93;&#40;&#41;">&#x5b;&#104;&#x6f;&#110;&#x67;&#122;&#x68;&#x61;&#x6e;&#103;&#x2e;&#x2e;&#46;&#46;&#64;&#x67;&#x6d;&#x61;&#105;&#108;&#x2e;&#99;&#x6f;&#x6d;&#93;&#40;&#41;</a></p>
<blockquote>
<p>异构平台从网络处理器算起已经快10年了，现在情况仍然不明朗。就我看到的，异构平台要想高效，就必须向程序员暴露非常多的硬件细节，这必然导致编程的复杂性。 曲高和寡，要想渗透到应用程序这一块，我觉得很难。</p>
<p>2010/3/24 qiaojie <a href="&#x6d;&#x61;&#x69;&#108;&#x74;&#111;&#58;&#91;&#113;&#x69;&#x61;&#111;&#x2e;&#46;&#x2e;&#x40;&#103;&#x6d;&#x61;&#x69;&#108;&#46;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#41;">&#91;&#113;&#x69;&#x61;&#111;&#x2e;&#46;&#x2e;&#x40;&#103;&#x6d;&#x61;&#x69;&#108;&#46;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#41;</a></p>
<blockquote>
<p>说的没错，cell已经成了先烈了。不过这不代表异构的方向不对，CUDA，OpenCL也都是异构平台，以后我们会越来越习惯异构平台的。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#x6d;&#97;&#105;&#108;&#116;&#x6f;&#x3a;&#x5b;&#x68;&#111;&#x6e;&#x67;&#x7a;&#x68;&#97;&#110;&#x67;&#46;&#x2e;&#46;&#x2e;&#x40;&#103;&#109;&#x61;&#105;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#40;&#x29;">&#x5b;&#x68;&#111;&#x6e;&#x67;&#x7a;&#x68;&#97;&#110;&#x67;&#46;&#x2e;&#46;&#x2e;&#x40;&#103;&#109;&#x61;&#105;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#40;&#x29;</a></p>
<p>异构平台如果编程复杂度降不下来的话很难流行起来。cell已经死了...</p>
<blockquote>
<p> 2010/3/24 qiaojie <a href="&#x6d;&#97;&#105;&#108;&#x74;&#111;&#58;&#x5b;&#113;&#x69;&#97;&#111;&#46;&#46;&#x2e;&#64;&#x67;&#109;&#97;&#105;&#x6c;&#46;&#x63;&#111;&#x6d;&#x5d;&#40;&#x29;">&#x5b;&#113;&#x69;&#97;&#111;&#46;&#46;&#x2e;&#64;&#x67;&#109;&#97;&#105;&#x6c;&#46;&#x63;&#111;&#x6d;&#x5d;&#40;&#x29;</a></p>
<blockquote>
<p>不是所有的程序都需要并行化的，能用串行化解决的问题没必要并行，所以即使将来many-core系统成为主流，大部分程序员也没必要去搞并行计算。
  我觉得未来的主流应该是类似cell这样一颗全功能核心带众多协处理核心的异构系统，这样才能达到最优的 性能/核心面积比。</p>
<p>2010/3/24 Guancheng Chen <a href="&#x6d;&#x61;&#x69;&#x6c;&#116;&#x6f;&#x3a;&#91;&#x63;&#x68;&#x65;&#x6e;&#x67;&#117;&#97;&#x6e;&#x63;&#x68;&#46;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#x61;&#x69;&#108;&#x2e;&#99;&#111;&#109;&#x5d;&#x28;&#x29;">&#91;&#x63;&#x68;&#x65;&#x6e;&#x67;&#117;&#97;&#x6e;&#x63;&#x68;&#46;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#x61;&#x69;&#108;&#x2e;&#99;&#111;&#109;&#x5d;&#x28;&#x29;</a></p>
<p>Nice 大胆预测Linear speedup应该是每个程序员十年后的目标 呵呵</p>
<blockquote>
<p>On 3月23日, 上午10时43分, qiaojie <a href="&#109;&#97;&#105;&#x6c;&#116;&#111;&#58;&#91;&#113;&#105;&#x61;&#x6f;&#x2e;&#x2e;&#46;&#64;&#103;&#x6d;&#x61;&#x69;&#108;&#46;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#x29;">&#91;&#113;&#105;&#x61;&#x6f;&#x2e;&#x2e;&#46;&#64;&#103;&#x6d;&#x61;&#x69;&#108;&#46;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>目前正在写的是一个软件渲染器，采用了光栅化和光线跟踪混合算法，渲染算法已经完全并行化了，
在4核系统上基本可以达到线性加速比，更多核的系统暂时还没测试。kd-tree的构造暂时还没有并
行化，以后有空了再研究。</p>
<p>2010/3/23 Guancheng Chen <a href="&#109;&#97;&#x69;&#x6c;&#116;&#111;&#58;&#91;&#99;&#x68;&#101;&#110;&#x67;&#117;&#x61;&#x6e;&#x63;&#x68;&#46;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#x63;&#111;&#109;&#x5d;&#x28;&#x29;">&#91;&#99;&#x68;&#101;&#110;&#x67;&#117;&#x61;&#x6e;&#x63;&#x68;&#46;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#x63;&#111;&#109;&#x5d;&#x28;&#x29;</a></p>
<blockquote>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？</p>
<p>On 3月23日, 上午9时15分, qiaojie <a href="&#x6d;&#x61;&#105;&#108;&#x74;&#x6f;&#58;&#91;&#113;&#x69;&#97;&#x6f;&#x2e;&#46;&#x2e;&#64;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#41;">&#91;&#113;&#x69;&#97;&#x6f;&#x2e;&#46;&#x2e;&#64;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1)
=
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank
Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？</p>
</blockquote>
<p> To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a></p>
<p><img src="" alt=""> qiaojie <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-25</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>产能过剩和短缺导致的价格波动是市场经济的典型特征，想要消除过剩和短缺那叫计划经济，</p>
<p>学点经济学常识再来讨论这些问题吧。
2010/3/25 机械唯物主义 : linjunhalida <a href="&#109;&#x61;&#105;&#x6c;&#x74;&#111;&#58;&#x5b;&#108;&#x69;&#110;&#x6a;&#117;&#x6e;&#46;&#x2e;&#x2e;&#64;&#103;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#40;&#x29;">&#x5b;&#108;&#x69;&#110;&#x6a;&#117;&#x6e;&#46;&#x2e;&#x2e;&#64;&#103;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#40;&#x29;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>本来就不该生产那么多的粮食，多余的人力和土地可以用来做别的事情。
问题在于为什么他们估算错误？</p>
<p>2010/3/25 qiaojie <a href="&#109;&#x61;&#105;&#x6c;&#116;&#111;&#58;&#91;&#113;&#105;&#97;&#46;&#x2e;&#x2e;&#x40;&#103;&#109;&#97;&#x69;&#x6c;&#46;&#x63;&#111;&#109;&#x5d;&#x28;&#41;">&#91;&#113;&#105;&#97;&#46;&#x2e;&#x2e;&#x40;&#103;&#109;&#97;&#x69;&#x6c;&#46;&#x63;&#111;&#109;&#x5d;&#x28;&#41;</a>
什么叫产能过剩？假设全世界每年消费10000亿斤粮食，结果今年收成好，生产了15000亿斤，</p>
<p>那多出来的5000亿斤无法被市场消化掉，就是产能过剩。那5000亿斤没价值，是垃圾？生产那
5000亿斤的农民是闲的蛋疼没事干？靠政府失业金养？</p>
<p>2010/3/25 机械唯物主义 : linjunhalida <a href="&#x6d;&#97;&#105;&#108;&#x74;&#x6f;&#x3a;&#91;&#108;&#105;&#x6e;&#106;&#117;&#110;&#x2e;&#46;&#x2e;&#64;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#x29;">&#91;&#108;&#105;&#x6e;&#106;&#117;&#110;&#x2e;&#46;&#x2e;&#64;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#x29;</a>
产能过剩的说法本来就不对。
产出的东西没有价值，这样的活动就不能说是生产。
比如我这个程序员，花了1周写了一个垃圾程序，然后被开除了。
然后1个月闲着，这是我产能过剩吗？
而闲着的原因是政府给我失业金，我就不需要工作闲起来了。。。</p>
<p>2010/3/25 qiaojie <a href="&#109;&#97;&#105;&#x6c;&#116;&#x6f;&#58;&#91;&#x71;&#x69;&#97;&#46;&#46;&#46;&#64;&#x67;&#109;&#x61;&#x69;&#108;&#x2e;&#99;&#111;&#x6d;&#x5d;&#40;&#41;">&#91;&#x71;&#x69;&#97;&#46;&#46;&#46;&#64;&#x67;&#109;&#x61;&#x69;&#108;&#x2e;&#99;&#111;&#x6d;&#x5d;&#40;&#41;</a>
如果产能=消费的话就没有产能过剩这一说了。</p>
<p>2010/3/25 机械唯物主义 : linjunhalida <a href="&#109;&#97;&#x69;&#108;&#x74;&#x6f;&#58;&#x5b;&#108;&#105;&#x6e;&#x6a;&#x75;&#x6e;&#46;&#46;&#46;&#x40;&#103;&#x6d;&#97;&#105;&#x6c;&#46;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#41;">&#x5b;&#108;&#105;&#x6e;&#x6a;&#x75;&#x6e;&#46;&#46;&#46;&#x40;&#103;&#x6d;&#97;&#105;&#x6c;&#46;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#41;</a></p>
<p>一个谬误：刺激需求
产能=消费，产能才是主动力。技术成长是随着产能成长而起来的。
而产能多的结果就是满足了需求，造成一种需求带来技术进步的假像。
而技术和产能之间的关系又错综复杂。。
2010/3/25 qiaojie <a href="&#109;&#x61;&#x69;&#x6c;&#x74;&#x6f;&#58;&#91;&#x71;&#105;&#97;&#46;&#46;&#x2e;&#x40;&#x67;&#109;&#97;&#105;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#40;&#x29;">&#91;&#x71;&#105;&#97;&#46;&#46;&#x2e;&#x40;&#x67;&#109;&#97;&#105;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#40;&#x29;</a></p>
<p>3D游戏就是一类杀手应用，由此支撑起了一个庞大的GPU市场，芯片行业的研发成本是很高的，没有一个庞大的市场是做不起来的。目前的消费者对于多核系统显然还没有强烈的需求，因为应用跟不上，i7发布快2年了还没进入主流市场，这种情况延续下去的话摩尔定律将因此失效。不过我相信杀手级应用总会出现的，这可能要硬件性能突破一个临界点，比方说目前GPU的性能再提升一个数量级的话，光线跟踪算法就可以提供流畅的接近CG的画质，倒是此类应用便会流行开来。</p>
<p>2010/3/25 Guancheng Chen <a href="&#109;&#97;&#x69;&#108;&#116;&#111;&#58;&#91;&#99;&#104;&#101;&#110;&#x67;&#x75;&#x2e;&#x2e;&#46;&#64;&#x67;&#109;&#x61;&#105;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#93;&#x28;&#41;">&#91;&#99;&#104;&#101;&#110;&#x67;&#x75;&#x2e;&#x2e;&#46;&#64;&#x67;&#109;&#x61;&#105;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#93;&#x28;&#41;</a></p>
<p>杀手应用一般来说是指什么样的应用呢？比如用户群特别大的网游？还是那些专有的科学计算用的软件？
On 3月24日, 下午12时36分, qiaojie <a href="&#x6d;&#x61;&#x69;&#108;&#116;&#x6f;&#58;&#91;&#113;&#105;&#97;&#x6f;&#x2e;&#46;&#x2e;&#x40;&#103;&#x6d;&#97;&#105;&#x6c;&#46;&#x63;&#x6f;&#109;&#x5d;&#40;&#x29;">&#91;&#113;&#105;&#97;&#x6f;&#x2e;&#46;&#x2e;&#x40;&#103;&#x6d;&#97;&#105;&#x6c;&#46;&#x63;&#x6f;&#109;&#x5d;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>并行计算本来就是曲高和寡的东西，就跟3D渲染一样，能开发引擎的毕竟只是小部分人，大多数人在引擎的基础上做应用。关键在于是否有杀手应用，只要有大量的需求 ，自然会有人去做开发。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#109;&#97;&#105;&#x6c;&#x74;&#111;&#58;&#x5b;&#104;&#x6f;&#110;&#x67;&#122;&#104;&#97;&#110;&#x67;&#46;&#46;&#x2e;&#46;&#64;&#x67;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#111;&#109;&#x5d;&#40;&#41;">&#x5b;&#104;&#x6f;&#110;&#x67;&#122;&#104;&#97;&#110;&#x67;&#46;&#46;&#x2e;&#46;&#64;&#x67;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#111;&#109;&#x5d;&#40;&#41;</a></p>
<blockquote>
<p>异构平台从网络处理器算起已经快10年了，现在情况仍然不明朗。就我看到的，异构平台要想高效，就必须向程序员暴露非常多的硬件细节，这必然导致编程的复杂性。 曲高和寡，要想渗透到应用程序这一块，我觉得很难。</p>
<p>2010/3/24 qiaojie <a href="&#x6d;&#97;&#x69;&#108;&#x74;&#111;&#x3a;&#x5b;&#x71;&#x69;&#x61;&#111;&#46;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#105;&#x6c;&#46;&#99;&#111;&#109;&#93;&#x28;&#41;">&#x5b;&#x71;&#x69;&#x61;&#111;&#46;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#105;&#x6c;&#46;&#99;&#111;&#109;&#93;&#x28;&#41;</a></p>
<blockquote>
<p>说的没错，cell已经成了先烈了。不过这不代表异构的方向不对，CUDA，OpenCL也都是异构平台，以后我们会越来越习惯异构平台的。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#x6d;&#97;&#105;&#108;&#116;&#x6f;&#x3a;&#91;&#x68;&#x6f;&#x6e;&#x67;&#122;&#x68;&#x61;&#x6e;&#x67;&#46;&#x2e;&#46;&#x2e;&#x40;&#103;&#x6d;&#97;&#105;&#x6c;&#x2e;&#x63;&#111;&#109;&#93;&#40;&#x29;">&#91;&#x68;&#x6f;&#x6e;&#x67;&#122;&#x68;&#x61;&#x6e;&#x67;&#46;&#x2e;&#46;&#x2e;&#x40;&#103;&#x6d;&#97;&#105;&#x6c;&#x2e;&#x63;&#111;&#109;&#93;&#40;&#x29;</a></p>
<p>异构平台如果编程复杂度降不下来的话很难流行起来。cell已经死了...</p>
<blockquote>
<p> 2010/3/24 qiaojie <a href="&#109;&#97;&#x69;&#x6c;&#116;&#111;&#58;&#x5b;&#113;&#x69;&#97;&#111;&#46;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#46;&#x63;&#x6f;&#109;&#x5d;&#40;&#41;">&#x5b;&#113;&#x69;&#97;&#111;&#46;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#46;&#x63;&#x6f;&#109;&#x5d;&#40;&#41;</a></p>
<blockquote>
<p>不是所有的程序都需要并行化的，能用串行化解决的问题没必要并行，所以即使将来many-core系统成为主流，大部分程序员也没必要去搞并行计算。
  我觉得未来的主流应该是类似cell这样一颗全功能核心带众多协处理核心的异构系统，这样才能达到最优的 性能/核心面积比。</p>
<p>2010/3/24 Guancheng Chen <a href="&#x6d;&#x61;&#105;&#x6c;&#x74;&#111;&#58;&#x5b;&#x63;&#x68;&#101;&#110;&#103;&#x75;&#x61;&#110;&#99;&#104;&#x2e;&#46;&#x2e;&#x40;&#103;&#109;&#97;&#x69;&#x6c;&#x2e;&#99;&#111;&#109;&#x5d;&#40;&#41;">&#x5b;&#x63;&#x68;&#101;&#110;&#103;&#x75;&#x61;&#110;&#99;&#104;&#x2e;&#46;&#x2e;&#x40;&#103;&#109;&#97;&#x69;&#x6c;&#x2e;&#99;&#111;&#109;&#x5d;&#40;&#41;</a></p>
<p>Nice 大胆预测Linear speedup应该是每个程序员十年后的目标 呵呵</p>
<blockquote>
<p>On 3月23日, 上午10时43分, qiaojie <a href="&#109;&#x61;&#105;&#108;&#x74;&#x6f;&#58;&#91;&#113;&#105;&#x61;&#111;&#x2e;&#x2e;&#46;&#x40;&#103;&#109;&#x61;&#x69;&#108;&#x2e;&#99;&#111;&#x6d;&#x5d;&#40;&#x29;">&#91;&#113;&#105;&#x61;&#111;&#x2e;&#x2e;&#46;&#x40;&#103;&#109;&#x61;&#x69;&#108;&#x2e;&#99;&#111;&#x6d;&#x5d;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>目前正在写的是一个软件渲染器，采用了光栅化和光线跟踪混合算法，渲染算法已经完全并行化了，
在4核系统上基本可以达到线性加速比，更多核的系统暂时还没测试。kd-tree的构造暂时还没有并
行化，以后有空了再研究。</p>
<p>2010/3/23 Guancheng Chen <a href="&#109;&#x61;&#105;&#x6c;&#x74;&#111;&#x3a;&#x5b;&#x63;&#x68;&#101;&#110;&#103;&#117;&#97;&#110;&#x63;&#104;&#46;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#x61;&#x69;&#108;&#46;&#99;&#111;&#x6d;&#93;&#40;&#41;">&#x5b;&#x63;&#x68;&#101;&#110;&#103;&#117;&#97;&#110;&#x63;&#104;&#46;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#x61;&#x69;&#108;&#46;&#99;&#111;&#x6d;&#93;&#40;&#41;</a></p>
<blockquote>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？</p>
<p>On 3月23日, 上午9时15分, qiaojie <a href="&#109;&#x61;&#x69;&#x6c;&#116;&#x6f;&#58;&#91;&#113;&#x69;&#97;&#x6f;&#x2e;&#46;&#x2e;&#64;&#103;&#x6d;&#x61;&#x69;&#x6c;&#46;&#x63;&#x6f;&#109;&#93;&#x28;&#x29;">&#91;&#113;&#x69;&#97;&#x6f;&#x2e;&#46;&#x2e;&#64;&#103;&#x6d;&#x61;&#x69;&#x6c;&#46;&#x63;&#x6f;&#109;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1)
=
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank
Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？</p>
</blockquote>
<p> To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> 机械唯物主义 : linjunhalida <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-25</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>小规模的，市场会自动调节。
如果出现大规模的问题，就有可能是信息错误——货币的币值变了。
2010/3/25 qiaojie <a href="&#109;&#x61;&#105;&#108;&#x74;&#111;&#x3a;&#91;&#113;&#105;&#97;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#109;&#97;&#x69;&#x6c;&#x2e;&#99;&#111;&#109;&#x5d;&#x28;&#x29;">&#91;&#113;&#105;&#97;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#109;&#97;&#x69;&#x6c;&#x2e;&#99;&#111;&#109;&#x5d;&#x28;&#x29;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>产能过剩和短缺导致的价格波动是市场经济的典型特征，想要消除过剩和短缺那叫计划经济，</p>
<p>学点经济学常识再来讨论这些问题吧。
2010/3/25 机械唯物主义 : linjunhalida <a href="&#x6d;&#97;&#105;&#108;&#x74;&#111;&#58;&#91;&#108;&#x69;&#x6e;&#106;&#x75;&#110;&#x2e;&#x2e;&#46;&#x40;&#x67;&#x6d;&#97;&#105;&#108;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#x28;&#x29;">&#91;&#108;&#x69;&#x6e;&#106;&#x75;&#110;&#x2e;&#x2e;&#46;&#x40;&#x67;&#x6d;&#97;&#105;&#108;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#x28;&#x29;</a>
本来就不该生产那么多的粮食，多余的人力和土地可以用来做别的事情。
问题在于为什么他们估算错误？</p>
<p>2010/3/25 qiaojie <a href="&#x6d;&#97;&#x69;&#108;&#x74;&#111;&#58;&#x5b;&#x71;&#105;&#97;&#46;&#x2e;&#x2e;&#64;&#103;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#99;&#111;&#109;&#x5d;&#40;&#x29;">&#x5b;&#x71;&#105;&#97;&#46;&#x2e;&#x2e;&#64;&#103;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#99;&#111;&#109;&#x5d;&#40;&#x29;</a>
什么叫产能过剩？假设全世界每年消费10000亿斤粮食，结果今年收成好，生产了15000亿斤，</p>
<p>那多出来的5000亿斤无法被市场消化掉，就是产能过剩。那5000亿斤没价值，是垃圾？生产那
5000亿斤的农民是闲的蛋疼没事干？靠政府失业金养？</p>
<p>2010/3/25 机械唯物主义 : linjunhalida <a href="&#x6d;&#97;&#x69;&#x6c;&#x74;&#x6f;&#58;&#x5b;&#108;&#105;&#x6e;&#106;&#117;&#110;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#97;&#105;&#108;&#x2e;&#x63;&#111;&#109;&#x5d;&#x28;&#41;">&#x5b;&#108;&#105;&#x6e;&#106;&#117;&#110;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#97;&#105;&#108;&#x2e;&#x63;&#111;&#109;&#x5d;&#x28;&#41;</a>
产能过剩的说法本来就不对。
产出的东西没有价值，这样的活动就不能说是生产。
比如我这个程序员，花了1周写了一个垃圾程序，然后被开除了。
然后1个月闲着，这是我产能过剩吗？
而闲着的原因是政府给我失业金，我就不需要工作闲起来了。。。</p>
<p>2010/3/25 qiaojie <a href="&#109;&#97;&#105;&#108;&#x74;&#111;&#58;&#x5b;&#x71;&#105;&#x61;&#x2e;&#x2e;&#x2e;&#64;&#103;&#x6d;&#97;&#105;&#108;&#46;&#x63;&#x6f;&#109;&#93;&#40;&#x29;">&#x5b;&#x71;&#105;&#x61;&#x2e;&#x2e;&#x2e;&#64;&#103;&#x6d;&#97;&#105;&#108;&#46;&#x63;&#x6f;&#109;&#93;&#40;&#x29;</a>
如果产能=消费的话就没有产能过剩这一说了。</p>
<p>2010/3/25 机械唯物主义 : linjunhalida <a href="&#109;&#x61;&#105;&#x6c;&#116;&#111;&#x3a;&#x5b;&#108;&#105;&#110;&#106;&#117;&#110;&#46;&#x2e;&#x2e;&#64;&#103;&#109;&#97;&#x69;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#93;&#x28;&#x29;">&#x5b;&#108;&#105;&#110;&#106;&#117;&#110;&#46;&#x2e;&#x2e;&#64;&#103;&#109;&#97;&#x69;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#93;&#x28;&#x29;</a></p>
<p>一个谬误：刺激需求
产能=消费，产能才是主动力。技术成长是随着产能成长而起来的。
而产能多的结果就是满足了需求，造成一种需求带来技术进步的假像。
而技术和产能之间的关系又错综复杂。。
2010/3/25 qiaojie <a href="&#109;&#x61;&#105;&#108;&#116;&#x6f;&#58;&#x5b;&#113;&#105;&#97;&#x2e;&#46;&#x2e;&#64;&#103;&#x6d;&#x61;&#105;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#x28;&#41;">&#x5b;&#113;&#105;&#97;&#x2e;&#46;&#x2e;&#64;&#103;&#x6d;&#x61;&#105;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#x28;&#41;</a></p>
<p>3D游戏就是一类杀手应用，由此支撑起了一个庞大的GPU市场，芯片行业的研发成本是很高的，没有一个庞大的市场是做不起来的。目前的消费者对于多核系统显然还没有强烈的需求，因为应用跟不上，i7发布快2年了还没进入主流市场，这种情况延续下去的话摩尔定律将因此失效。不过我相信杀手级应用总会出现的，这可能要硬件性能突破一个临界点，比方说目前GPU的性能再提升一个数量级的话，光线跟踪算法就可以提供流畅的接近CG的画质，倒是此类应用便会流行开来。</p>
<p>2010/3/25 Guancheng Chen <a href="&#109;&#97;&#x69;&#x6c;&#116;&#x6f;&#58;&#x5b;&#x63;&#104;&#101;&#x6e;&#x67;&#x75;&#x2e;&#x2e;&#46;&#64;&#x67;&#109;&#x61;&#105;&#108;&#46;&#99;&#111;&#x6d;&#93;&#x28;&#41;">&#x5b;&#x63;&#104;&#101;&#x6e;&#x67;&#x75;&#x2e;&#x2e;&#46;&#64;&#x67;&#109;&#x61;&#105;&#108;&#46;&#99;&#111;&#x6d;&#93;&#x28;&#41;</a></p>
<p>杀手应用一般来说是指什么样的应用呢？比如用户群特别大的网游？还是那些专有的科学计算用的软件？
On 3月24日, 下午12时36分, qiaojie <a href="&#109;&#x61;&#105;&#x6c;&#116;&#111;&#58;&#x5b;&#x71;&#x69;&#97;&#x6f;&#46;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#x61;&#105;&#x6c;&#46;&#99;&#x6f;&#x6d;&#x5d;&#40;&#41;">&#x5b;&#x71;&#x69;&#97;&#x6f;&#46;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#x61;&#105;&#x6c;&#46;&#99;&#x6f;&#x6d;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>并行计算本来就是曲高和寡的东西，就跟3D渲染一样，能开发引擎的毕竟只是小部分人，大多数人在引擎的基础上做应用。关键在于是否有杀手应用，只要有大量的需求 ，自然会有人去做开发。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#109;&#x61;&#105;&#108;&#116;&#111;&#58;&#x5b;&#104;&#x6f;&#110;&#x67;&#x7a;&#104;&#x61;&#x6e;&#x67;&#x2e;&#x2e;&#46;&#x2e;&#64;&#103;&#x6d;&#97;&#x69;&#108;&#46;&#99;&#x6f;&#109;&#93;&#40;&#x29;">&#x5b;&#104;&#x6f;&#110;&#x67;&#x7a;&#104;&#x61;&#x6e;&#x67;&#x2e;&#x2e;&#46;&#x2e;&#64;&#103;&#x6d;&#97;&#x69;&#108;&#46;&#99;&#x6f;&#109;&#93;&#40;&#x29;</a></p>
<blockquote>
<p>异构平台从网络处理器算起已经快10年了，现在情况仍然不明朗。就我看到的，异构平台要想高效，就必须向程序员暴露非常多的硬件细节，这必然导致编程的复杂性。 曲高和寡，要想渗透到应用程序这一块，我觉得很难。</p>
<p>2010/3/24 qiaojie <a href="&#109;&#x61;&#x69;&#x6c;&#x74;&#111;&#58;&#x5b;&#x71;&#105;&#x61;&#111;&#46;&#x2e;&#x2e;&#x40;&#x67;&#109;&#x61;&#105;&#108;&#x2e;&#x63;&#111;&#109;&#93;&#x28;&#41;">&#x5b;&#x71;&#105;&#x61;&#111;&#46;&#x2e;&#x2e;&#x40;&#x67;&#109;&#x61;&#105;&#108;&#x2e;&#x63;&#111;&#109;&#93;&#x28;&#41;</a></p>
<blockquote>
<p>说的没错，cell已经成了先烈了。不过这不代表异构的方向不对，CUDA，OpenCL也都是异构平台，以后我们会越来越习惯异构平台的。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#x6d;&#97;&#x69;&#x6c;&#116;&#x6f;&#58;&#91;&#104;&#111;&#x6e;&#x67;&#x7a;&#104;&#x61;&#x6e;&#x67;&#x2e;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#x61;&#105;&#108;&#46;&#x63;&#111;&#x6d;&#93;&#40;&#x29;">&#91;&#104;&#111;&#x6e;&#x67;&#x7a;&#104;&#x61;&#x6e;&#x67;&#x2e;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#x61;&#105;&#108;&#46;&#x63;&#111;&#x6d;&#93;&#40;&#x29;</a></p>
<p>异构平台如果编程复杂度降不下来的话很难流行起来。cell已经死了...</p>
<blockquote>
<p> 2010/3/24 qiaojie <a href="&#109;&#x61;&#x69;&#x6c;&#116;&#x6f;&#58;&#x5b;&#x71;&#105;&#x61;&#111;&#x2e;&#x2e;&#46;&#x40;&#103;&#109;&#97;&#x69;&#108;&#46;&#99;&#x6f;&#x6d;&#x5d;&#40;&#x29;">&#x5b;&#x71;&#105;&#x61;&#111;&#x2e;&#x2e;&#46;&#x40;&#103;&#109;&#97;&#x69;&#108;&#46;&#99;&#x6f;&#x6d;&#x5d;&#40;&#x29;</a></p>
<blockquote>
<p>不是所有的程序都需要并行化的，能用串行化解决的问题没必要并行，所以即使将来many-core系统成为主流，大部分程序员也没必要去搞并行计算。
  我觉得未来的主流应该是类似cell这样一颗全功能核心带众多协处理核心的异构系统，这样才能达到最优的 性能/核心面积比。</p>
<p>2010/3/24 Guancheng Chen <a href="&#x6d;&#97;&#x69;&#108;&#x74;&#111;&#58;&#x5b;&#99;&#x68;&#x65;&#x6e;&#x67;&#x75;&#x61;&#x6e;&#x63;&#104;&#x2e;&#46;&#46;&#64;&#x67;&#x6d;&#97;&#x69;&#x6c;&#46;&#99;&#111;&#109;&#x5d;&#x28;&#41;">&#x5b;&#99;&#x68;&#x65;&#x6e;&#x67;&#x75;&#x61;&#x6e;&#x63;&#104;&#x2e;&#46;&#46;&#64;&#x67;&#x6d;&#97;&#x69;&#x6c;&#46;&#99;&#111;&#109;&#x5d;&#x28;&#41;</a></p>
<p>Nice 大胆预测Linear speedup应该是每个程序员十年后的目标 呵呵</p>
<blockquote>
<p>On 3月23日, 上午10时43分, qiaojie <a href="&#109;&#x61;&#105;&#x6c;&#116;&#x6f;&#x3a;&#x5b;&#113;&#x69;&#x61;&#x6f;&#46;&#46;&#x2e;&#x40;&#x67;&#109;&#x61;&#x69;&#108;&#x2e;&#99;&#111;&#109;&#x5d;&#x28;&#41;">&#x5b;&#113;&#x69;&#x61;&#x6f;&#46;&#46;&#x2e;&#x40;&#x67;&#109;&#x61;&#x69;&#108;&#x2e;&#99;&#111;&#109;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>目前正在写的是一个软件渲染器，采用了光栅化和光线跟踪混合算法，渲染算法已经完全并行化了，
在4核系统上基本可以达到线性加速比，更多核的系统暂时还没测试。kd-tree的构造暂时还没有并
行化，以后有空了再研究。</p>
<p>2010/3/23 Guancheng Chen <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#x3a;&#x5b;&#x63;&#x68;&#x65;&#x6e;&#103;&#117;&#x61;&#110;&#x63;&#x68;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#x61;&#x69;&#108;&#46;&#x63;&#x6f;&#109;&#93;&#x28;&#41;">&#x5b;&#x63;&#x68;&#x65;&#x6e;&#103;&#117;&#x61;&#110;&#x63;&#x68;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#x61;&#x69;&#108;&#46;&#x63;&#x6f;&#109;&#93;&#x28;&#41;</a></p>
<blockquote>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？</p>
<p>On 3月23日, 上午9时15分, qiaojie <a href="&#x6d;&#x61;&#105;&#x6c;&#116;&#x6f;&#x3a;&#91;&#x71;&#x69;&#97;&#111;&#x2e;&#x2e;&#46;&#x40;&#x67;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#x63;&#111;&#109;&#93;&#40;&#41;">&#91;&#x71;&#x69;&#97;&#111;&#x2e;&#x2e;&#46;&#x40;&#x67;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#x63;&#111;&#109;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1)
=
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank
Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？</p>
</blockquote>
<p> To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a></p>
<p><img src="" alt=""> qiaojie <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-25</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>恩，很快会被升华成为政治问题
2010/3/25 郝培强 tinyfool <a href="&#109;&#97;&#x69;&#x6c;&#x74;&#x6f;&#x3a;&#91;&#x74;&#105;&#x6e;&#x79;&#x2e;&#46;&#x2e;&#x40;&#x67;&#109;&#97;&#x69;&#108;&#46;&#x63;&#x6f;&#x6d;&#93;&#40;&#x29;">&#91;&#x74;&#105;&#x6e;&#x79;&#x2e;&#46;&#x2e;&#x40;&#x67;&#109;&#97;&#x69;&#108;&#46;&#x63;&#x6f;&#x6d;&#93;&#40;&#x29;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>哈哈，终于从技术聊到经济了</p>
<p>在 2010-3-25，下午2:11， qiaojie 写道：</p>
<p>什么叫产能过剩？假设全世界每年消费10000亿斤粮食，结果今年收成好，生产了15000亿斤，</p>
<p>那多出来的5000亿斤无法被市场消化掉，就是产能过剩。那5000亿斤没价值，是垃圾？生产那
5000亿斤的农民是闲的蛋疼没事干？靠政府失业金养？</p>
<p>2010/3/25 机械唯物主义 : linjunhalida <a href="&#x6d;&#97;&#x69;&#108;&#116;&#x6f;&#58;&#x5b;&#x6c;&#x69;&#110;&#x6a;&#117;&#110;&#x2e;&#x2e;&#46;&#x40;&#x67;&#109;&#x61;&#x69;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#41;">&#x5b;&#x6c;&#x69;&#110;&#x6a;&#117;&#110;&#x2e;&#x2e;&#46;&#x40;&#x67;&#109;&#x61;&#x69;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#41;</a>
产能过剩的说法本来就不对。
产出的东西没有价值，这样的活动就不能说是生产。
比如我这个程序员，花了1周写了一个垃圾程序，然后被开除了。
然后1个月闲着，这是我产能过剩吗？
而闲着的原因是政府给我失业金，我就不需要工作闲起来了。。。</p>
<p>2010/3/25 qiaojie <a href="&#x6d;&#97;&#x69;&#108;&#116;&#111;&#58;&#91;&#113;&#x69;&#97;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#40;&#x29;">&#91;&#113;&#x69;&#97;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#40;&#x29;</a>
如果产能=消费的话就没有产能过剩这一说了。</p>
<p>2010/3/25 机械唯物主义 : linjunhalida <a href="&#109;&#x61;&#x69;&#x6c;&#x74;&#111;&#x3a;&#x5b;&#108;&#x69;&#110;&#x6a;&#x75;&#110;&#46;&#46;&#x2e;&#64;&#x67;&#109;&#x61;&#x69;&#x6c;&#46;&#99;&#111;&#109;&#x5d;&#x28;&#x29;">&#x5b;&#108;&#x69;&#110;&#x6a;&#x75;&#110;&#46;&#46;&#x2e;&#64;&#x67;&#109;&#x61;&#x69;&#x6c;&#46;&#99;&#111;&#109;&#x5d;&#x28;&#x29;</a></p>
<p>一个谬误：刺激需求
产能=消费，产能才是主动力。技术成长是随着产能成长而起来的。
而产能多的结果就是满足了需求，造成一种需求带来技术进步的假像。
而技术和产能之间的关系又错综复杂。。
2010/3/25 qiaojie <a href="&#x6d;&#x61;&#x69;&#x6c;&#116;&#x6f;&#58;&#91;&#113;&#105;&#x61;&#x2e;&#46;&#46;&#x40;&#103;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#93;&#x28;&#x29;">&#91;&#113;&#105;&#x61;&#x2e;&#46;&#46;&#x40;&#103;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#93;&#x28;&#x29;</a></p>
<p>3D游戏就是一类杀手应用，由此支撑起了一个庞大的GPU市场，芯片行业的研发成本是很高的，没有一个庞大的市场是做不起来的。目前的消费者对于多核系统显然还没有强烈的需求，因为应用跟不上，i7发布快2年了还没进入主流市场，这种情况延续下去的话摩尔定律将因此失效。不过我相信杀手级应用总会出现的，这可能要硬件性能突破一个临界点，比方说目前GPU的性能再提升一个数量级的话，光线跟踪算法就可以提供流畅的接近CG的画质，倒是此类应用便会流行开来。</p>
<p>2010/3/25 Guancheng Chen <a href="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#111;&#58;&#91;&#x63;&#104;&#101;&#x6e;&#x67;&#117;&#46;&#46;&#x2e;&#64;&#103;&#109;&#x61;&#x69;&#108;&#x2e;&#x63;&#111;&#109;&#93;&#40;&#x29;">&#91;&#x63;&#104;&#101;&#x6e;&#x67;&#117;&#46;&#46;&#x2e;&#64;&#103;&#109;&#x61;&#x69;&#108;&#x2e;&#x63;&#111;&#109;&#93;&#40;&#x29;</a></p>
<p>杀手应用一般来说是指什么样的应用呢？比如用户群特别大的网游？还是那些专有的科学计算用的软件？
On 3月24日, 下午12时36分, qiaojie <a href="&#109;&#x61;&#x69;&#x6c;&#x74;&#111;&#58;&#91;&#113;&#x69;&#97;&#111;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#109;&#97;&#x69;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#40;&#41;">&#91;&#113;&#x69;&#97;&#111;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#109;&#97;&#x69;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>并行计算本来就是曲高和寡的东西，就跟3D渲染一样，能开发引擎的毕竟只是小部分人，大多数人在引擎的基础上做应用。关键在于是否有杀手应用，只要有大量的需求 ，自然会有人去做开发。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#x6d;&#x61;&#105;&#x6c;&#116;&#111;&#x3a;&#91;&#x68;&#x6f;&#110;&#x67;&#x7a;&#104;&#97;&#110;&#103;&#x2e;&#46;&#x2e;&#46;&#x40;&#103;&#109;&#97;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#x28;&#41;">&#91;&#x68;&#x6f;&#110;&#x67;&#x7a;&#104;&#97;&#110;&#103;&#x2e;&#46;&#x2e;&#46;&#x40;&#103;&#109;&#97;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#x28;&#41;</a></p>
<blockquote>
<p>异构平台从网络处理器算起已经快10年了，现在情况仍然不明朗。就我看到的，异构平台要想高效，就必须向程序员暴露非常多的硬件细节，这必然导致编程的复杂性。 曲高和寡，要想渗透到应用程序这一块，我觉得很难。</p>
<p>2010/3/24 qiaojie <a href="&#109;&#x61;&#x69;&#x6c;&#116;&#111;&#x3a;&#91;&#113;&#x69;&#x61;&#111;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#109;&#97;&#105;&#x6c;&#46;&#99;&#111;&#109;&#93;&#x28;&#x29;">&#91;&#113;&#x69;&#x61;&#111;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#109;&#97;&#105;&#x6c;&#46;&#99;&#111;&#109;&#93;&#x28;&#x29;</a></p>
<blockquote>
<p>说的没错，cell已经成了先烈了。不过这不代表异构的方向不对，CUDA，OpenCL也都是异构平台，以后我们会越来越习惯异构平台的。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#x6d;&#97;&#x69;&#108;&#x74;&#x6f;&#x3a;&#91;&#x68;&#x6f;&#x6e;&#103;&#x7a;&#x68;&#x61;&#x6e;&#103;&#46;&#46;&#x2e;&#46;&#x40;&#x67;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#99;&#x6f;&#109;&#x5d;&#40;&#x29;">&#91;&#x68;&#x6f;&#x6e;&#103;&#x7a;&#x68;&#x61;&#x6e;&#103;&#46;&#46;&#x2e;&#46;&#x40;&#x67;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#99;&#x6f;&#109;&#x5d;&#40;&#x29;</a></p>
<p>异构平台如果编程复杂度降不下来的话很难流行起来。cell已经死了...</p>
<blockquote>
<p> 2010/3/24 qiaojie <a href="&#x6d;&#x61;&#105;&#108;&#x74;&#111;&#x3a;&#x5b;&#113;&#105;&#x61;&#111;&#46;&#46;&#46;&#64;&#x67;&#109;&#97;&#105;&#x6c;&#x2e;&#99;&#111;&#x6d;&#93;&#x28;&#41;">&#x5b;&#113;&#105;&#x61;&#111;&#46;&#46;&#46;&#64;&#x67;&#109;&#97;&#105;&#x6c;&#x2e;&#99;&#111;&#x6d;&#93;&#x28;&#41;</a></p>
<blockquote>
<p>不是所有的程序都需要并行化的，能用串行化解决的问题没必要并行，所以即使将来many-core系统成为主流，大部分程序员也没必要去搞并行计算。
  我觉得未来的主流应该是类似cell这样一颗全功能核心带众多协处理核心的异构系统，这样才能达到最优的 性能/核心面积比。</p>
<p>2010/3/24 Guancheng Chen <a href="&#109;&#97;&#x69;&#108;&#116;&#x6f;&#58;&#x5b;&#99;&#x68;&#101;&#110;&#x67;&#x75;&#97;&#x6e;&#99;&#104;&#x2e;&#x2e;&#x2e;&#64;&#103;&#x6d;&#97;&#105;&#108;&#46;&#x63;&#x6f;&#109;&#93;&#40;&#41;">&#x5b;&#99;&#x68;&#101;&#110;&#x67;&#x75;&#97;&#x6e;&#99;&#104;&#x2e;&#x2e;&#x2e;&#64;&#103;&#x6d;&#97;&#105;&#108;&#46;&#x63;&#x6f;&#109;&#93;&#40;&#41;</a></p>
<p>Nice 大胆预测Linear speedup应该是每个程序员十年后的目标 呵呵</p>
<blockquote>
<p>On 3月23日, 上午10时43分, qiaojie <a href="&#x6d;&#x61;&#x69;&#108;&#116;&#111;&#x3a;&#91;&#113;&#x69;&#97;&#x6f;&#46;&#46;&#x2e;&#64;&#103;&#x6d;&#97;&#105;&#108;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#41;">&#91;&#113;&#x69;&#97;&#x6f;&#46;&#46;&#x2e;&#64;&#103;&#x6d;&#97;&#105;&#108;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>目前正在写的是一个软件渲染器，采用了光栅化和光线跟踪混合算法，渲染算法已经完全并行化了，
在4核系统上基本可以达到线性加速比，更多核的系统暂时还没测试。kd-tree的构造暂时还没有并
行化，以后有空了再研究。</p>
<p>2010/3/23 Guancheng Chen <a href="&#109;&#97;&#x69;&#x6c;&#116;&#111;&#x3a;&#91;&#99;&#x68;&#101;&#110;&#x67;&#117;&#97;&#110;&#x63;&#104;&#46;&#46;&#46;&#x40;&#103;&#109;&#x61;&#105;&#x6c;&#x2e;&#99;&#x6f;&#109;&#x5d;&#40;&#41;">&#91;&#99;&#x68;&#101;&#110;&#x67;&#117;&#97;&#110;&#x63;&#104;&#46;&#46;&#46;&#x40;&#103;&#109;&#x61;&#105;&#x6c;&#x2e;&#99;&#x6f;&#109;&#x5d;&#40;&#41;</a></p>
<blockquote>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？</p>
<p>On 3月23日, 上午9时15分, qiaojie <a href="&#109;&#x61;&#105;&#x6c;&#116;&#111;&#x3a;&#91;&#113;&#x69;&#97;&#x6f;&#46;&#46;&#46;&#x40;&#x67;&#109;&#97;&#105;&#108;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#40;&#41;">&#91;&#113;&#x69;&#97;&#x6f;&#46;&#46;&#46;&#x40;&#x67;&#109;&#97;&#105;&#108;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1)
=
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank
Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？</p>
</blockquote>
<p> To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> tinyfool <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-25</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>哈哈，二位都平和一点，咱们继续回到技术讨论的主线吧</p>
<p>在 2010-3-25，下午2:40， qiaojie 写道：</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>恩，很快会被升华成为政治问题
2010/3/25 郝培强 tinyfool <a href="&#109;&#97;&#105;&#x6c;&#116;&#x6f;&#x3a;&#91;&#x74;&#x69;&#x6e;&#x79;&#x2e;&#x2e;&#46;&#64;&#103;&#x6d;&#97;&#x69;&#108;&#x2e;&#99;&#111;&#109;&#93;&#40;&#41;">&#91;&#x74;&#x69;&#x6e;&#x79;&#x2e;&#x2e;&#46;&#64;&#103;&#x6d;&#97;&#x69;&#108;&#x2e;&#99;&#111;&#109;&#93;&#40;&#41;</a>
哈哈，终于从技术聊到经济了</p>
<p>在 2010-3-25，下午2:11， qiaojie 写道：</p>
<p>什么叫产能过剩？假设全世界每年消费10000亿斤粮食，结果今年收成好，生产了15000亿斤，</p>
<p>那多出来的5000亿斤无法被市场消化掉，就是产能过剩。那5000亿斤没价值，是垃圾？生产那
5000亿斤的农民是闲的蛋疼没事干？靠政府失业金养？</p>
<p>2010/3/25 机械唯物主义 : linjunhalida <a href="&#x6d;&#97;&#x69;&#108;&#x74;&#111;&#58;&#91;&#x6c;&#x69;&#x6e;&#106;&#117;&#x6e;&#46;&#x2e;&#46;&#x40;&#103;&#109;&#x61;&#x69;&#108;&#46;&#x63;&#111;&#109;&#x5d;&#40;&#x29;">&#91;&#x6c;&#x69;&#x6e;&#106;&#117;&#x6e;&#46;&#x2e;&#46;&#x40;&#103;&#109;&#x61;&#x69;&#108;&#46;&#x63;&#111;&#109;&#x5d;&#40;&#x29;</a>
产能过剩的说法本来就不对。
产出的东西没有价值，这样的活动就不能说是生产。
比如我这个程序员，花了1周写了一个垃圾程序，然后被开除了。
然后1个月闲着，这是我产能过剩吗？
而闲着的原因是政府给我失业金，我就不需要工作闲起来了。。。</p>
<p>2010/3/25 qiaojie <a href="&#x6d;&#97;&#x69;&#x6c;&#x74;&#111;&#58;&#91;&#113;&#105;&#97;&#46;&#x2e;&#46;&#x40;&#x67;&#x6d;&#97;&#105;&#x6c;&#46;&#x63;&#111;&#109;&#x5d;&#x28;&#x29;">&#91;&#113;&#105;&#97;&#46;&#x2e;&#46;&#x40;&#x67;&#x6d;&#97;&#105;&#x6c;&#46;&#x63;&#111;&#109;&#x5d;&#x28;&#x29;</a>
如果产能=消费的话就没有产能过剩这一说了。</p>
<p>2010/3/25 机械唯物主义 : linjunhalida <a href="&#109;&#97;&#x69;&#108;&#116;&#111;&#58;&#91;&#108;&#x69;&#110;&#106;&#117;&#x6e;&#x2e;&#x2e;&#46;&#x40;&#103;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#x63;&#111;&#109;&#93;&#40;&#41;">&#91;&#108;&#x69;&#110;&#106;&#117;&#x6e;&#x2e;&#x2e;&#46;&#x40;&#103;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#x63;&#111;&#109;&#93;&#40;&#41;</a></p>
<p>一个谬误：刺激需求
产能=消费，产能才是主动力。技术成长是随着产能成长而起来的。
而产能多的结果就是满足了需求，造成一种需求带来技术进步的假像。
而技术和产能之间的关系又错综复杂。。
2010/3/25 qiaojie <a href="&#x6d;&#x61;&#x69;&#108;&#116;&#111;&#x3a;&#x5b;&#113;&#105;&#97;&#x2e;&#x2e;&#46;&#64;&#x67;&#x6d;&#97;&#x69;&#108;&#46;&#x63;&#x6f;&#x6d;&#93;&#x28;&#41;">&#x5b;&#113;&#105;&#97;&#x2e;&#x2e;&#46;&#64;&#x67;&#x6d;&#97;&#x69;&#108;&#46;&#x63;&#x6f;&#x6d;&#93;&#x28;&#41;</a></p>
<p>3D游戏就是一类杀手应用，由此支撑起了一个庞大的GPU市场，芯片行业的研发成本是很高的，没有一个庞大的市场是做不起来的。目前的消费者对于多核系统显然还没有强烈的需求，因为应用跟不上，i7发布快2年了还没进入主流市场，这种情况延续下去的话摩尔定律将因此失效。不过我相信杀手级应用总会出现的，这可能要硬件性能突破一个临界点，比方说目前GPU的性能再提升一个数量级的话，光线跟踪算法就可以提供流畅的接近CG的画质，倒是此类应用便会流行开来。</p>
<p>2010/3/25 Guancheng Chen <a href="&#109;&#97;&#x69;&#x6c;&#116;&#111;&#x3a;&#91;&#x63;&#104;&#101;&#x6e;&#103;&#117;&#x2e;&#46;&#x2e;&#x40;&#x67;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#x28;&#41;">&#91;&#x63;&#104;&#101;&#x6e;&#103;&#117;&#x2e;&#46;&#x2e;&#x40;&#x67;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#x28;&#41;</a></p>
<p>杀手应用一般来说是指什么样的应用呢？比如用户群特别大的网游？还是那些专有的科学计算用的软件？
On 3月24日, 下午12时36分, qiaojie <a href="&#109;&#x61;&#x69;&#108;&#x74;&#111;&#58;&#x5b;&#113;&#105;&#x61;&#111;&#x2e;&#46;&#46;&#64;&#x67;&#109;&#x61;&#105;&#108;&#46;&#99;&#x6f;&#109;&#x5d;&#40;&#41;">&#x5b;&#113;&#105;&#x61;&#111;&#x2e;&#46;&#46;&#64;&#x67;&#109;&#x61;&#105;&#108;&#46;&#99;&#x6f;&#109;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>并行计算本来就是曲高和寡的东西，就跟3D渲染一样，能开发引擎的毕竟只是小部分人，大多数人在引擎的基础上做应用。关键在于是否有杀手应用，只要有大量的需求 ，自然会有人去做开发。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#x6d;&#97;&#105;&#108;&#116;&#111;&#x3a;&#x5b;&#x68;&#111;&#x6e;&#103;&#x7a;&#104;&#x61;&#110;&#103;&#x2e;&#46;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#93;&#x28;&#x29;">&#x5b;&#x68;&#111;&#x6e;&#103;&#x7a;&#104;&#x61;&#110;&#103;&#x2e;&#46;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#93;&#x28;&#x29;</a></p>
<blockquote>
<p>异构平台从网络处理器算起已经快10年了，现在情况仍然不明朗。就我看到的，异构平台要想高效，就必须向程序员暴露非常多的硬件细节，这必然导致编程的复杂性。 曲高和寡，要想渗透到应用程序这一块，我觉得很难。</p>
<p>2010/3/24 qiaojie <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#91;&#113;&#x69;&#x61;&#x6f;&#46;&#46;&#46;&#64;&#x67;&#109;&#x61;&#105;&#x6c;&#46;&#x63;&#111;&#x6d;&#x5d;&#40;&#x29;">&#91;&#113;&#x69;&#x61;&#x6f;&#46;&#46;&#46;&#64;&#x67;&#109;&#x61;&#105;&#x6c;&#46;&#x63;&#111;&#x6d;&#x5d;&#40;&#x29;</a></p>
<blockquote>
<p>说的没错，cell已经成了先烈了。不过这不代表异构的方向不对，CUDA，OpenCL也都是异构平台，以后我们会越来越习惯异构平台的。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#x3a;&#91;&#104;&#111;&#110;&#103;&#122;&#104;&#x61;&#110;&#x67;&#46;&#46;&#46;&#46;&#64;&#x67;&#x6d;&#97;&#105;&#108;&#x2e;&#99;&#111;&#109;&#93;&#40;&#41;">&#91;&#104;&#111;&#110;&#103;&#122;&#104;&#x61;&#110;&#x67;&#46;&#46;&#46;&#46;&#64;&#x67;&#x6d;&#97;&#105;&#108;&#x2e;&#99;&#111;&#109;&#93;&#40;&#41;</a></p>
<p>异构平台如果编程复杂度降不下来的话很难流行起来。cell已经死了...</p>
<blockquote>
<p> 2010/3/24 qiaojie <a href="&#x6d;&#97;&#x69;&#108;&#116;&#111;&#x3a;&#91;&#113;&#x69;&#97;&#111;&#x2e;&#46;&#46;&#x40;&#x67;&#x6d;&#97;&#x69;&#108;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#x29;">&#91;&#113;&#x69;&#97;&#111;&#x2e;&#46;&#46;&#x40;&#x67;&#x6d;&#97;&#x69;&#108;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#x29;</a></p>
<blockquote>
<p>不是所有的程序都需要并行化的，能用串行化解决的问题没必要并行，所以即使将来many-core系统成为主流，大部分程序员也没必要去搞并行计算。
  我觉得未来的主流应该是类似cell这样一颗全功能核心带众多协处理核心的异构系统，这样才能达到最优的 性能/核心面积比。</p>
<p>2010/3/24 Guancheng Chen <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#x3a;&#x5b;&#99;&#104;&#x65;&#x6e;&#103;&#117;&#97;&#110;&#99;&#104;&#46;&#x2e;&#46;&#64;&#103;&#109;&#x61;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#40;&#x29;">&#x5b;&#99;&#104;&#x65;&#x6e;&#103;&#117;&#97;&#110;&#99;&#104;&#46;&#x2e;&#46;&#64;&#103;&#109;&#x61;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#40;&#x29;</a></p>
<p>Nice 大胆预测Linear speedup应该是每个程序员十年后的目标 呵呵</p>
<blockquote>
<p>On 3月23日, 上午10时43分, qiaojie <a href="&#x6d;&#97;&#105;&#x6c;&#x74;&#x6f;&#x3a;&#x5b;&#x71;&#x69;&#97;&#x6f;&#46;&#46;&#x2e;&#64;&#x67;&#109;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#x28;&#x29;">&#x5b;&#x71;&#x69;&#97;&#x6f;&#46;&#46;&#x2e;&#64;&#x67;&#109;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>目前正在写的是一个软件渲染器，采用了光栅化和光线跟踪混合算法，渲染算法已经完全并行化了，
在4核系统上基本可以达到线性加速比，更多核的系统暂时还没测试。kd-tree的构造暂时还没有并
行化，以后有空了再研究。</p>
<p>2010/3/23 Guancheng Chen <a href="&#109;&#97;&#x69;&#x6c;&#x74;&#111;&#x3a;&#x5b;&#99;&#104;&#x65;&#110;&#103;&#x75;&#x61;&#x6e;&#99;&#104;&#46;&#46;&#46;&#x40;&#x67;&#x6d;&#97;&#105;&#108;&#x2e;&#99;&#x6f;&#x6d;&#93;&#x28;&#x29;">&#x5b;&#99;&#104;&#x65;&#110;&#103;&#x75;&#x61;&#x6e;&#99;&#104;&#46;&#46;&#46;&#x40;&#x67;&#x6d;&#97;&#105;&#108;&#x2e;&#99;&#x6f;&#x6d;&#93;&#x28;&#x29;</a></p>
<blockquote>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？</p>
<p>On 3月23日, 上午9时15分, qiaojie <a href="&#x6d;&#97;&#x69;&#108;&#x74;&#111;&#58;&#91;&#x71;&#x69;&#97;&#x6f;&#x2e;&#46;&#x2e;&#x40;&#x67;&#109;&#x61;&#105;&#108;&#x2e;&#x63;&#x6f;&#109;&#93;&#40;&#41;">&#91;&#x71;&#x69;&#97;&#x6f;&#x2e;&#46;&#x2e;&#x40;&#x67;&#109;&#x61;&#105;&#108;&#x2e;&#x63;&#x6f;&#109;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1)
=
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank
Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？</p>
</blockquote>
<p> To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a></p>
<p><img src="" alt=""> 机械唯物主义 : linjunhalida <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-25</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>恩，离题远了。不再讨论经济。</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>2010/3/25 郝培强 tinyfool <a href="&#x6d;&#x61;&#x69;&#108;&#x74;&#111;&#x3a;&#x5b;&#116;&#x69;&#110;&#121;&#x2e;&#x2e;&#46;&#64;&#x67;&#109;&#x61;&#x69;&#108;&#46;&#99;&#111;&#x6d;&#93;&#40;&#41;">&#x5b;&#116;&#x69;&#110;&#121;&#x2e;&#x2e;&#46;&#64;&#x67;&#109;&#x61;&#x69;&#108;&#46;&#99;&#111;&#x6d;&#93;&#40;&#41;</a>
哈哈，二位都平和一点，咱们继续回到技术讨论的主线吧</p>
<p>在 2010-3-25，下午2:40， qiaojie 写道：</p>
<p>恩，很快会被升华成为政治问题
2010/3/25 郝培强 tinyfool <a href="&#109;&#x61;&#x69;&#108;&#116;&#111;&#58;&#x5b;&#116;&#x69;&#110;&#x79;&#x2e;&#46;&#x2e;&#64;&#x67;&#x6d;&#97;&#x69;&#x6c;&#46;&#x63;&#x6f;&#109;&#x5d;&#40;&#41;">&#x5b;&#116;&#x69;&#110;&#x79;&#x2e;&#46;&#x2e;&#64;&#x67;&#x6d;&#97;&#x69;&#x6c;&#46;&#x63;&#x6f;&#109;&#x5d;&#40;&#41;</a>
哈哈，终于从技术聊到经济了</p>
<p>在 2010-3-25，下午2:11， qiaojie 写道：</p>
<p>什么叫产能过剩？假设全世界每年消费10000亿斤粮食，结果今年收成好，生产了15000亿斤，</p>
<p>那多出来的5000亿斤无法被市场消化掉，就是产能过剩。那5000亿斤没价值，是垃圾？生产那
5000亿斤的农民是闲的蛋疼没事干？靠政府失业金养？</p>
<p>2010/3/25 机械唯物主义 : linjunhalida <a href="&#109;&#x61;&#105;&#108;&#116;&#x6f;&#x3a;&#x5b;&#x6c;&#105;&#x6e;&#106;&#x75;&#110;&#46;&#x2e;&#x2e;&#x40;&#x67;&#109;&#97;&#x69;&#x6c;&#46;&#x63;&#111;&#109;&#93;&#x28;&#41;">&#x5b;&#x6c;&#105;&#x6e;&#106;&#x75;&#110;&#46;&#x2e;&#x2e;&#x40;&#x67;&#109;&#97;&#x69;&#x6c;&#46;&#x63;&#111;&#109;&#93;&#x28;&#41;</a>
产能过剩的说法本来就不对。
产出的东西没有价值，这样的活动就不能说是生产。
比如我这个程序员，花了1周写了一个垃圾程序，然后被开除了。
然后1个月闲着，这是我产能过剩吗？
而闲着的原因是政府给我失业金，我就不需要工作闲起来了。。。</p>
<p>2010/3/25 qiaojie <a href="&#x6d;&#x61;&#105;&#x6c;&#x74;&#x6f;&#x3a;&#91;&#x71;&#105;&#97;&#x2e;&#46;&#46;&#x40;&#x67;&#109;&#97;&#105;&#108;&#46;&#x63;&#111;&#x6d;&#93;&#x28;&#x29;">&#91;&#x71;&#105;&#97;&#x2e;&#46;&#46;&#x40;&#x67;&#109;&#97;&#105;&#108;&#46;&#x63;&#111;&#x6d;&#93;&#x28;&#x29;</a>
如果产能=消费的话就没有产能过剩这一说了。</p>
<p>2010/3/25 机械唯物主义 : linjunhalida <a href="&#109;&#97;&#x69;&#x6c;&#x74;&#111;&#x3a;&#x5b;&#x6c;&#x69;&#x6e;&#x6a;&#x75;&#x6e;&#46;&#46;&#x2e;&#64;&#103;&#x6d;&#97;&#x69;&#108;&#46;&#x63;&#111;&#x6d;&#93;&#x28;&#x29;">&#x5b;&#x6c;&#x69;&#x6e;&#x6a;&#x75;&#x6e;&#46;&#46;&#x2e;&#64;&#103;&#x6d;&#97;&#x69;&#108;&#46;&#x63;&#111;&#x6d;&#93;&#x28;&#x29;</a></p>
<p>一个谬误：刺激需求
产能=消费，产能才是主动力。技术成长是随着产能成长而起来的。
而产能多的结果就是满足了需求，造成一种需求带来技术进步的假像。
而技术和产能之间的关系又错综复杂。。
2010/3/25 qiaojie <a href="&#109;&#x61;&#x69;&#108;&#x74;&#111;&#58;&#x5b;&#113;&#x69;&#97;&#x2e;&#46;&#46;&#x40;&#x67;&#x6d;&#x61;&#105;&#108;&#46;&#x63;&#x6f;&#x6d;&#93;&#x28;&#41;">&#x5b;&#113;&#x69;&#97;&#x2e;&#46;&#46;&#x40;&#x67;&#x6d;&#x61;&#105;&#108;&#46;&#x63;&#x6f;&#x6d;&#93;&#x28;&#41;</a></p>
<p>3D游戏就是一类杀手应用，由此支撑起了一个庞大的GPU市场，芯片行业的研发成本是很高的，没有一个庞大的市场是做不起来的。目前的消费者对于多核系统显然还没有强烈的需求，因为应用跟不上，i7发布快2年了还没进入主流市场，这种情况延续下去的话摩尔定律将因此失效。不过我相信杀手级应用总会出现的，这可能要硬件性能突破一个临界点，比方说目前GPU的性能再提升一个数量级的话，光线跟踪算法就可以提供流畅的接近CG的画质，倒是此类应用便会流行开来。</p>
<p>2010/3/25 Guancheng Chen <a href="&#x6d;&#x61;&#105;&#x6c;&#116;&#111;&#x3a;&#91;&#99;&#x68;&#x65;&#110;&#x67;&#117;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#97;&#105;&#108;&#46;&#x63;&#x6f;&#109;&#x5d;&#40;&#x29;">&#91;&#99;&#x68;&#x65;&#110;&#x67;&#117;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#97;&#105;&#108;&#46;&#x63;&#x6f;&#109;&#x5d;&#40;&#x29;</a></p>
<p>杀手应用一般来说是指什么样的应用呢？比如用户群特别大的网游？还是那些专有的科学计算用的软件？
On 3月24日, 下午12时36分, qiaojie <a href="&#109;&#x61;&#105;&#108;&#x74;&#x6f;&#x3a;&#91;&#x71;&#105;&#x61;&#x6f;&#46;&#46;&#x2e;&#x40;&#103;&#109;&#97;&#x69;&#108;&#46;&#x63;&#x6f;&#x6d;&#93;&#x28;&#41;">&#91;&#x71;&#105;&#x61;&#x6f;&#46;&#46;&#x2e;&#x40;&#103;&#109;&#97;&#x69;&#108;&#46;&#x63;&#x6f;&#x6d;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>并行计算本来就是曲高和寡的东西，就跟3D渲染一样，能开发引擎的毕竟只是小部分人，大多数人在引擎的基础上做应用。关键在于是否有杀手应用，只要有大量的需求 ，自然会有人去做开发。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#109;&#x61;&#x69;&#108;&#x74;&#111;&#58;&#x5b;&#104;&#x6f;&#110;&#x67;&#122;&#104;&#x61;&#110;&#103;&#x2e;&#x2e;&#46;&#46;&#x40;&#103;&#x6d;&#97;&#105;&#108;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#40;&#x29;">&#x5b;&#104;&#x6f;&#110;&#x67;&#122;&#104;&#x61;&#110;&#103;&#x2e;&#x2e;&#46;&#46;&#x40;&#103;&#x6d;&#97;&#105;&#108;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#40;&#x29;</a></p>
<blockquote>
<p>异构平台从网络处理器算起已经快10年了，现在情况仍然不明朗。就我看到的，异构平台要想高效，就必须向程序员暴露非常多的硬件细节，这必然导致编程的复杂性。 曲高和寡，要想渗透到应用程序这一块，我觉得很难。</p>
<p>2010/3/24 qiaojie <a href="&#109;&#x61;&#105;&#108;&#116;&#111;&#x3a;&#x5b;&#113;&#105;&#x61;&#x6f;&#46;&#x2e;&#46;&#64;&#103;&#x6d;&#97;&#105;&#108;&#46;&#x63;&#111;&#x6d;&#x5d;&#40;&#41;">&#x5b;&#113;&#105;&#x61;&#x6f;&#46;&#x2e;&#46;&#64;&#103;&#x6d;&#97;&#105;&#108;&#46;&#x63;&#111;&#x6d;&#x5d;&#40;&#41;</a></p>
<blockquote>
<p>说的没错，cell已经成了先烈了。不过这不代表异构的方向不对，CUDA，OpenCL也都是异构平台，以后我们会越来越习惯异构平台的。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#109;&#97;&#x69;&#108;&#116;&#111;&#58;&#91;&#x68;&#x6f;&#110;&#103;&#x7a;&#x68;&#97;&#110;&#103;&#x2e;&#x2e;&#46;&#x2e;&#x40;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#x6f;&#x6d;&#93;&#40;&#x29;">&#91;&#x68;&#x6f;&#110;&#103;&#x7a;&#x68;&#97;&#110;&#103;&#x2e;&#x2e;&#46;&#x2e;&#x40;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#x6f;&#x6d;&#93;&#40;&#x29;</a></p>
<p>异构平台如果编程复杂度降不下来的话很难流行起来。cell已经死了...</p>
<blockquote>
<p> 2010/3/24 qiaojie <a href="&#x6d;&#97;&#105;&#108;&#x74;&#x6f;&#x3a;&#x5b;&#113;&#x69;&#97;&#x6f;&#x2e;&#46;&#46;&#x40;&#103;&#x6d;&#97;&#x69;&#108;&#46;&#99;&#x6f;&#109;&#93;&#40;&#41;">&#x5b;&#113;&#x69;&#97;&#x6f;&#x2e;&#46;&#46;&#x40;&#103;&#x6d;&#97;&#x69;&#108;&#46;&#99;&#x6f;&#109;&#93;&#40;&#41;</a></p>
<blockquote>
<p>不是所有的程序都需要并行化的，能用串行化解决的问题没必要并行，所以即使将来many-core系统成为主流，大部分程序员也没必要去搞并行计算。
  我觉得未来的主流应该是类似cell这样一颗全功能核心带众多协处理核心的异构系统，这样才能达到最优的 性能/核心面积比。</p>
<p>2010/3/24 Guancheng Chen <a href="&#x6d;&#97;&#x69;&#108;&#116;&#x6f;&#58;&#x5b;&#x63;&#104;&#101;&#110;&#103;&#x75;&#97;&#110;&#x63;&#x68;&#46;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#x28;&#41;">&#x5b;&#x63;&#104;&#101;&#110;&#103;&#x75;&#97;&#110;&#x63;&#x68;&#46;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#x28;&#41;</a></p>
<p>Nice 大胆预测Linear speedup应该是每个程序员十年后的目标 呵呵</p>
<blockquote>
<p>On 3月23日, 上午10时43分, qiaojie <a href="&#109;&#97;&#105;&#x6c;&#116;&#x6f;&#x3a;&#91;&#113;&#105;&#97;&#x6f;&#46;&#x2e;&#46;&#64;&#103;&#109;&#x61;&#x69;&#108;&#x2e;&#x63;&#111;&#x6d;&#93;&#x28;&#41;">&#91;&#113;&#105;&#97;&#x6f;&#46;&#x2e;&#46;&#64;&#103;&#109;&#x61;&#x69;&#108;&#x2e;&#x63;&#111;&#x6d;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>目前正在写的是一个软件渲染器，采用了光栅化和光线跟踪混合算法，渲染算法已经完全并行化了，
在4核系统上基本可以达到线性加速比，更多核的系统暂时还没测试。kd-tree的构造暂时还没有并
行化，以后有空了再研究。</p>
<p>2010/3/23 Guancheng Chen <a href="&#x6d;&#x61;&#x69;&#108;&#x74;&#x6f;&#x3a;&#x5b;&#99;&#104;&#101;&#110;&#103;&#117;&#97;&#110;&#99;&#104;&#x2e;&#46;&#46;&#64;&#x67;&#x6d;&#x61;&#105;&#108;&#x2e;&#99;&#111;&#109;&#x5d;&#x28;&#41;">&#x5b;&#99;&#104;&#101;&#110;&#103;&#117;&#97;&#110;&#99;&#104;&#x2e;&#46;&#46;&#64;&#x67;&#x6d;&#x61;&#105;&#108;&#x2e;&#99;&#111;&#109;&#x5d;&#x28;&#41;</a></p>
<blockquote>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？</p>
<p>On 3月23日, 上午9时15分, qiaojie <a href="&#109;&#x61;&#x69;&#108;&#116;&#111;&#x3a;&#91;&#x71;&#x69;&#97;&#x6f;&#46;&#46;&#46;&#x40;&#x67;&#109;&#x61;&#x69;&#108;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#x28;&#41;">&#91;&#x71;&#x69;&#97;&#x6f;&#46;&#46;&#46;&#x40;&#x67;&#109;&#x61;&#x69;&#108;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1)
=
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank
Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？</p>
</blockquote>
<p> To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> 居振梁 <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-25</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>哈哈，估计有人想说“这次居然是收敛的”</p>
<p>2010/3/25 机械唯物主义 : linjunhalida <a href="&#x6d;&#97;&#105;&#x6c;&#x74;&#111;&#58;&#91;&#x6c;&#105;&#x6e;&#106;&#117;&#x6e;&#x2e;&#46;&#x2e;&#x40;&#103;&#x6d;&#97;&#105;&#108;&#46;&#99;&#111;&#109;&#x5d;&#x28;&#x29;">&#91;&#x6c;&#105;&#x6e;&#106;&#117;&#x6e;&#x2e;&#46;&#x2e;&#x40;&#103;&#x6d;&#97;&#105;&#108;&#46;&#99;&#111;&#109;&#x5d;&#x28;&#x29;</a></p>
<h2 id="-">恩，离题远了。不再讨论经济。</h2>
<p>御剑乘风来，除魔天地间。有酒乐逍遥，无酒我亦颠。
<a href="http://www.xspirithack.org/" target="_blank"><a href="http://www.xspirithack.org">http://www.xspirithack.org</a></a>
一饮尽江河，再饮吞日月。千杯醉不倒，唯我酒剑仙。
<a href="">显示删减掉的内容</a></p>
<p><img src="" alt=""> qiaojie <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-25</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>淡定....
2010/3/25 居振梁 <a href="&#x6d;&#97;&#105;&#x6c;&#x74;&#x6f;&#58;&#x5b;&#x6a;&#x75;&#x7a;&#104;&#101;&#46;&#46;&#x2e;&#x40;&#103;&#109;&#x61;&#105;&#108;&#46;&#99;&#x6f;&#109;&#93;&#x28;&#x29;">&#x5b;&#x6a;&#x75;&#x7a;&#104;&#101;&#46;&#46;&#x2e;&#x40;&#103;&#109;&#x61;&#105;&#108;&#46;&#99;&#x6f;&#109;&#93;&#x28;&#x29;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>哈哈，估计有人想说“这次居然是收敛的”</p>
<p>2010/3/25 机械唯物主义 : linjunhalida <a href="&#x6d;&#97;&#x69;&#x6c;&#x74;&#x6f;&#58;&#x5b;&#108;&#x69;&#110;&#x6a;&#117;&#x6e;&#x2e;&#x2e;&#46;&#64;&#x67;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#99;&#111;&#109;&#93;&#x28;&#x29;">&#x5b;&#108;&#x69;&#110;&#x6a;&#117;&#x6e;&#x2e;&#x2e;&#46;&#64;&#x67;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#99;&#111;&#109;&#93;&#x28;&#x29;</a></p>
<h2 id="-"> 恩，离题远了。不再讨论经济。</h2>
<p>御剑乘风来，除魔天地间。有酒乐逍遥，无酒我亦颠。
<a href="http://www.xspirithack.org/" target="_blank"><a href="http://www.xspirithack.org">http://www.xspirithack.org</a></a>
一饮尽江河，再饮吞日月。千杯醉不倒，唯我酒剑仙。</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> tinyfool <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-25</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>呵呵，其实咱们组真的已经是互联网上讨论组里面，最平和，最专业的一个了。</p>
<p>大家有时候稍微相互包容点，就不至于弄得大家都不愉快的，我们还是挺好的。
不准老幸灾乐祸，惟恐天下不乱的，哈哈</p>
<p>技术讨论技术吧
我继续鼓吹OPENCL，哈哈</p>
<p>在 2010-3-25，下午2:44， 居振梁 写道：</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>哈哈，估计有人想说“这次居然是收敛的”</p>
<p>2010/3/25 机械唯物主义 : linjunhalida <a href="&#x6d;&#x61;&#105;&#x6c;&#x74;&#x6f;&#x3a;&#x5b;&#108;&#105;&#x6e;&#x6a;&#x75;&#110;&#46;&#x2e;&#x2e;&#64;&#103;&#109;&#97;&#x69;&#x6c;&#46;&#99;&#x6f;&#109;&#93;&#40;&#41;">&#x5b;&#108;&#105;&#x6e;&#x6a;&#x75;&#110;&#46;&#x2e;&#x2e;&#64;&#103;&#109;&#97;&#x69;&#x6c;&#46;&#99;&#x6f;&#109;&#93;&#40;&#41;</a></p>
<h2 id="-">恩，离题远了。不再讨论经济。</h2>
<p>御剑乘风来，除魔天地间。有酒乐逍遥，无酒我亦颠。
<a href="http://www.xspirithack.org/" target="_blank"><a href="http://www.xspirithack.org">http://www.xspirithack.org</a></a>
一饮尽江河，再饮吞日月。千杯醉不倒，唯我酒剑仙。</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a></p>
<p><img src="" alt=""> fxc...@gmail.com <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-26</p>
<p>其他收件人：</p>
<p>好吧，俺也打个广告。
既然大家都说tools是concurrent的一个大issue。那不妨看看MS的Concurrency工具包：Parallel
Debugger/Parallel Profiler. 在下一个版本VS里面会加入Static Analysis的support。
<a href="http://msdn.microsoft.com/en-us/concurrency/default.aspx" target="_blank">msdn.microsoft.com/en-us/concurrency/default.aspx</a></p>
<p>On Mar 24, 9:04 am, 莫华枫 <a href="&#109;&#97;&#105;&#x6c;&#x74;&#111;&#x3a;&#x5b;&#108;&#x6f;&#x6e;&#x67;&#x73;&#104;&#x61;&#x6e;&#x6b;&#x2e;&#46;&#46;&#64;&#103;&#109;&#x61;&#x69;&#108;&#x2e;&#99;&#111;&#x6d;&#x5d;&#40;&#41;">&#x5b;&#108;&#x6f;&#x6e;&#x67;&#x73;&#104;&#x61;&#x6e;&#x6b;&#x2e;&#46;&#46;&#64;&#103;&#109;&#x61;&#x69;&#108;&#x2e;&#99;&#111;&#x6d;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>凑个热闹，也来个广告：CERL 2.0初具雏形。</p>
<p>--
反者道之动，弱者道之用
longshank...@gmail.com<a href="http://[blog.csdn.net/longshanks/](http://blog.csdn.net/longshanks/" target="_blank">http://[blog.csdn.net/longshanks/](http://blog.csdn.net/longshanks/</a>)
wave开通
<a href="">显示删减掉的内容</a>
<img src="" alt=""> AWu <img src="" alt=""></p>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-28</p>
<p>其他收件人：</p>
<p>这不是逼俺买MBP嘛？</p>
<p>感觉并行需要有足够简单，足够可靠的工程实施方法才能够大规模得被应用～
毕竟IT业从业人员不是所有人都足够聪明能够写得了、分析得了并行</p>
<p>一个可靠的工程方法来规避并行可能引发的性能或者功能缺陷，如果能够抽象到库里面规避当然更好，但是库这个东西得有足够多的工程实践才能做得出来吧，所
以我认为第一步是有一个可行的并行工程实施方法。</p>
<p>On 3月22日, 下午2时06分, Guancheng Chen <a href="&#x6d;&#x61;&#x69;&#x6c;&#116;&#111;&#x3a;&#91;&#x63;&#104;&#101;&#x6e;&#103;&#117;&#x61;&#110;&#99;&#x68;&#46;&#46;&#46;&#64;&#x67;&#x6d;&#97;&#105;&#108;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#40;&#x29;">&#91;&#x63;&#104;&#101;&#x6e;&#103;&#117;&#x61;&#110;&#99;&#x68;&#46;&#46;&#46;&#64;&#x67;&#x6d;&#97;&#105;&#108;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>On 3月22日, 上午2时20分, Tinyfool <a href="&#x6d;&#97;&#x69;&#x6c;&#116;&#111;&#x3a;&#x5b;&#x74;&#x69;&#110;&#121;&#102;&#x2e;&#46;&#x2e;&#x40;&#103;&#x6d;&#x61;&#105;&#108;&#46;&#x63;&#111;&#x6d;&#x5d;&#40;&#41;">&#x5b;&#x74;&#x69;&#110;&#121;&#102;&#x2e;&#46;&#x2e;&#x40;&#103;&#x6d;&#x61;&#105;&#108;&#46;&#x63;&#111;&#x6d;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#x6d;&#97;&#x69;&#108;&#116;&#111;&#x3a;&#x5b;&#106;&#x65;&#x2e;&#46;&#x2e;&#x40;&#108;&#x69;&#118;&#101;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#40;&#41;">&#x5b;&#106;&#x65;&#x2e;&#46;&#x2e;&#x40;&#108;&#x69;&#118;&#101;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#40;&#41;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#109;&#x61;&#105;&#108;&#x74;&#111;&#58;&#x5b;&#x63;&#104;&#x65;&#x6e;&#103;&#x75;&#97;&#x6e;&#x63;&#104;&#x2e;&#46;&#46;&#x40;&#103;&#109;&#x61;&#105;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#93;&#x28;&#x29;">&#x5b;&#x63;&#104;&#x65;&#x6e;&#103;&#x75;&#97;&#x6e;&#x63;&#104;&#x2e;&#46;&#46;&#x40;&#103;&#109;&#x61;&#105;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#93;&#x28;&#x29;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#x6d;&#97;&#105;&#x6c;&#116;&#111;&#x3a;&#91;&#x70;&#x6f;&#110;&#x2e;&#46;&#46;&#64;&#x67;&#111;&#x6f;&#x67;&#108;&#x65;&#103;&#x72;&#x6f;&#117;&#112;&#x73;&#46;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#x29;">&#91;&#x70;&#x6f;&#110;&#x2e;&#46;&#46;&#64;&#x67;&#111;&#x6f;&#x67;&#108;&#x65;&#103;&#x72;&#x6f;&#117;&#112;&#x73;&#46;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#x29;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。</p>
</li>
</ol>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>--
Tinyfool的开发日记<a href="http://www.tinydust.net/dev/" target="_blank"><a href="http://www.tinydust.net/dev/">http://www.tinydust.net/dev/</a></a>
代码中国网<a href="http://www.codechina.org/" target="_blank"><a href="http://www.codechina.org">http://www.codechina.org</a></a>
myTwitter:<a href="http://twitter.com/tinyfool" target="_blank"><a href="http://twitter.com/tinyfool">http://twitter.com/tinyfool</a></a>
<a href="">显示删减掉的内容</a>
上一页 <a href="">上一页</a>  </p>
</blockquote>
</blockquote>
<p>第 <strong>1</strong> 页
  下一页 <a href="">下一页</a></p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/好文摘录/">好文摘录</a></li></span></span> | <span class="time">recent updated:<time title="2014-03-07 11:24:30"datetime="2014-03-07 11:24:30"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/03/2014-02-03--{技术}{多线程}实施并行编程的五大障碍/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-03--{技术}{多线程}实施并行编程的五大障碍" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/03/2014-02-03--如何理解当代中国----《十亿消费者》读后感/">如何理解当代中国</a></h1>
      
        <span>Posted on<time datetime="2014-02-03T03:24:28.000Z"> <a href="/2014/02/03/2014-02-03--如何理解当代中国----《十亿消费者》读后感/">feb. 3 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-">如何理解当代中国----《十亿消费者》读后感</h1>
<p>作者： <a href="http://www.ruanyifeng.com/" target="_blank">阮一峰</a> </p>
<p>日期： <a href="http://www.ruanyifeng.com/blog/2013/05/" target="_blank">2013年5月21日</a> （网址：<a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html" target="_blank"><a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html">http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html</a></a>）</p>
<p>前几天，我读完的美国人 <a href="http://en.wikipedia.org/wiki/James_L._McGregor" target="_blank">James McGregor</a> 写的《<a href="http://book.douban.com/subject/2791877/" target="_blank">十亿消费者</a>》（<a href="http://www.onebillioncustomers.com/" target="_blank">One Billion Customers</a>）。</p>
<p><img src="" alt=""></p>
<p>James McGregor 本来是《华尔街日报》和道琼斯集团在华负责人，后来辞职经商。为了对记者生涯做总结，他就写了这本书，让西方人了解如何在中国做生意。</p>
<p><img src="" alt=""></p>
<p>在书中，他通过对一些涉及高层的案例介绍，披露了中国政府商业管理的内幕，对中国社会有精准深刻的分析。很难相信，一个外国人如此懂中国。</p>
<p>我认为，对于想在中国经商的人，这本书是必读的。尤其是如何处理与中国政府的商业关系，大概很难找到比它更好的读物了。</p>
<p>此书不太可能在国内正式出版，译言网有一个网友翻译的<a href="http://group.yeeyan.org/translations/one-billion-consumers" target="_blank">中文版</a>，质量相当好，推荐阅读。</p>
<p>下面就是我整理的一些摘录。</p>
<p>========================================</p>
<p><strong>《十亿消费者》摘录</strong></p>
<p>作者： [美] James McGregor</p>
<p><img src="" alt=""></p>
<p>（题图：<a href="http://article.yeeyan.org/view/168647/150280" target="_blank">刘勃麟</a>的 Hiding in the City 系列）</p>
<p><strong>一、 中国文化</strong></p>
<p>1.</p>
<p>贤明君主自上而下的管理，是中国数千年社会秩序的基础。直到今天，也是中国普遍流行的商业管理模式。</p>
<p>2.</p>
<p>中国文化的核心，就是追求和谐，哪怕这种和谐是表面的。</p>
<p>3.</p>
<p>中国文化提倡，个人追求恭顺和礼仪，接受来自上层的命令和决策。</p>
<p>4.</p>
<p>中国儿童在生活中学到的第一课就是纪律，家长教育孩子遵守纪律。</p>
<p>5.</p>
<p>中国文化提倡克制、克制、再克制。</p>
<p>6.</p>
<p>中国人习惯服从领导。领导人可以对所有问题下命令，甚至包括下属的家庭矛盾。</p>
<p>7.</p>
<p>由于推崇稳定和强调服从，中国人对那些充满魅力、照顾属下、发号施令的领袖惟命是从。</p>
<p>8.</p>
<p>中国人的这种服从性格，在制造业中颇有成效。但是一旦走出国门，或者进入需要更具创造力的领域如研发，中国模式的缺点就暴露无遗。</p>
<p>9.</p>
<p>什么是中国公司中最常见的四个字？&quot;听领导的！&quot;</p>
<p><strong>二、 重视稳定和秩序</strong></p>
<p>10.</p>
<p>中国政府最重视的，就是稳定和秩序。</p>
<p>11.</p>
<p>不管能否控制，中国政府假装一切皆在控制之中。</p>
<p>12.</p>
<p>任何敢于公开与政府对抗的人，都将在国家稳定的名义下遭到无情镇压。</p>
<p>13.</p>
<p>想在中国生存，你不能让这个体制感到为难。</p>
<p>14.</p>
<p>如果想要打击对手，你可以把对手描绘成破坏体制的人。</p>
<p>15.</p>
<p>与中国政府产生矛盾时，你要说明你公司的业务是如何有利于中国，而不是政府如何错了。你不能让人觉得体制很差。</p>
<p>16.</p>
<p>为了维持表面上的秩序，中国人的行为准则，不是有没有内疚，而是会不会被揭露。</p>
<p>17.</p>
<p>只要不被抓住，中国人做任何事都可以心安理得。在这种环境下，政府不得不变得强权和无所不在，加大你作恶之后被抓住的可能。</p>
<p>18.</p>
<p>中国的法律假设，一切皆在政府控制之下，除非法律明文允许，否则你做的事情都是不合法的。而美国法律假设，政府不得干涉人民自由，除非法律明文禁止，否则你可以做任何事情。</p>
<p>19.</p>
<p>为什么中国的交通很乱？因为各种政治压制和社会控制的存在，中国人把油门和方向盘当作发泄工具。</p>
<p><strong>三、 教育和思想控制</strong></p>
<p>20.</p>
<p>中国教育体制培养出来的人是被领导的，而不是领导别人。</p>
<p>21.</p>
<p>这种教育体制的结果，就是强大但却缺乏主动的劳动力大军，而创新性的商业领袖和各种经理人非常之少。</p>
<p>22.</p>
<p>教育在中国是最大的优势，也是最大的劣势。</p>
<p>23.</p>
<p>中国人记忆超群，精于数学，安于枯燥冗长工作。但是死记硬背的教育体系大大削弱了人们的分析和领导能力。</p>
<p>24.</p>
<p>为了维持秩序，中国政府对信息和思想实施控制。这样必然会扼杀创新。</p>
<p>25.</p>
<p>政府相信必须控制信息才能保住权力，但是中国需要公民掌握充分的信息，才能在全球经济中竞争。这使得媒体得以探索自己的笼子到底有多大。</p>
<p>26.</p>
<p>自由意味着知道你自己的笼子有多大。</p>
<p><strong>四、 官员的务实性</strong></p>
<p>27.</p>
<p>表面上要维护秩序，但实际上，为了有效管理国家，中国政府官员在效率和私人问题上是非常务实的。</p>
<p>28.</p>
<p>从高级到基层的党政官员，满嘴都是最新的口号，但是一旦这些官方的政治反刍完毕，谈话立刻就转到经商。</p>
<p>29.</p>
<p>对于大多数中国官员来说，生活的准则就是&quot;指鹿为马&quot;。说的是一套，做的是另一套，因为否则就会威胁到整个体制的稳定。</p>
<p>30.</p>
<p>由于这种两面性的存在，中国的反腐收效甚微，因为整个体制与诚实正直格格不入。</p>
<p>31.</p>
<p>中国政府在决策和处理与人民关系的时候，更像在经营一家公司。就像在公司里一样，党的高层有一些民主，但是在基层则几乎没有。</p>
<p>32.</p>
<p>由于人民不相信政府，政府只能通过促进经济增长，来保持威信。加快经济发展速度，政府只有两个药方：私有化和大量投资。</p>
<p>33.</p>
<p>中国政府喜欢那些能帮助国家解决困难的公司。</p>
<p><strong>五、 重视金钱利益</strong></p>
<p>34.</p>
<p>对政治体系的不信任、腐败、快速的形势变化，又没有社会保障，一切让中国人惴惴不安。大家都觉得，获得安全感的唯一方法，就是快速获得财富。</p>
<p>35.</p>
<p>很多中国人只信任钱。</p>
<p>36.</p>
<p>在葬礼上，一个核心环节就是烧纸钱，给死人送去资产。</p>
<p>37.</p>
<p>在婚礼上，来宾们在公然注视下，排队送礼金，每个人的信封被撕开、清点、并纪录下来。</p>
<p>38.</p>
<p>由于急于致富，除非被迫，否则没有人会排队。每个人都拼命往前挤。这也是商业的运作模式。</p>
<p>39.</p>
<p>快速致富的必然推论是&quot;谁也不要相信&quot;。中国人对体制、对陌生人有着深深的不信任。结果就是商业环境中到处是不诚实。</p>
<p>40.</p>
<p>中国人之间毫无信任可言。在中国做买卖，人们的预期就是对方会骗自己。</p>
<p>41.</p>
<p>中国社会是自私的。中国人竞争能力很强，合作能力很弱。</p>
<p>42.</p>
<p>中国人是全世界最自我、最自私的民族之一。</p>
<p>43.</p>
<p>单个来说，中国人是凶猛可怕的商人。但是，中国人很难组建大型组织，这样的组织需要人们分享观点、平等共处。</p>
<p>44.</p>
<p>在中国，你要么有钱，要么听话。</p>
<p><strong>六、 人际关系与法律</strong></p>
<p>45.</p>
<p>因为表面上需要维持秩序，而实际上又是另一套做法，所以，人际关系在中国社会的重要性，远大于西方。</p>
<p>46.</p>
<p>法律和合同的规定，不如人际关系重要。</p>
<p>47.</p>
<p>在中国做生意，不要完全依赖于法律，你会输的。法律只是你商业行为的一种论据。</p>
<p>48.</p>
<p>中国人事部门主管的权力远高过西方，因为那些被录用的人往往对他们心怀感激。</p>
<p>49.</p>
<p>机会来自和有权有势的人的交往。</p>
<p>50.</p>
<p>在这个需要和层层官僚及个人利益打交道的国家，单靠个人能力是无法成事的。</p>
<p>51.</p>
<p>在一个缺乏公平和公正的法律体系中，你的人际网络能确保你的安全。</p>
<p>52.</p>
<p>商业公司如果不把政府关系当作业务最关键的一部分，那么它的业务就会出现问题。</p>
<p>53.</p>
<p>在中国，市场总能取得胜利。</p>
<p>54.</p>
<p>亲吻干部，拥抱客户。</p>
<p>（完）</p>
<h3 id="-">文档信息</h3>
<ul>
<li>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank">Creative Commons BY-NC-ND 3.0</a></li>
<li>原文网址：<a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html" target="_blank"><a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html">http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html</a></a></li>
<li>最后修改时间：2013年6月14日 21:41</li>
<li>付费支持：<a href="https://me.alipay.com/ruanyf" target="_blank"><img src="&quot;人民币&quot;" alt="人民币 - 支付宝"></a> | <a href="https://www.paypal.com/cgi-bin/webscr?cmd=_xclick&amp;business=yifeng.ruan@gmail.com&amp;currency_code=USD&amp;amount=0.99&amp;return=http://www.ruanyifeng.com/thank.html&amp;item_name=Ruan%20YiFeng&#39;s%20Blog&amp;undefined_quantity=1&amp;no_note=0" target="_blank"><img src="&quot;美元&quot;" alt="美元 - paypal"></a></li>
</ul>
<p><a href="http://www.hi-vps.com/?utm_source=ruanyifeng.com"></a></p>
<h2 id="-">相关文章</h2>
<ul>
<li><strong>2013.04.09: <a href="http://www.ruanyifeng.com/blog/2013/04/entropy.html" target="_blank">熵的社会学意义</a></strong></li>
</ul>
<ol>
<li>上周，我读完了《熵：一种新的世界观》。</li>
</ol>
<ul>
<li><strong>2013.03.08: <a href="http://www.ruanyifeng.com/blog/2013/03/apple_inc_and_division_of_labor.html" target="_blank">苹果公司与分工原理</a></strong></li>
</ul>
<p>我终于读完了《乔布斯传》。这是一本好书，我应该早点读的。</p>
<h2 id="-">功能链接</h2>
<ul>
<li><strong>前一篇：</strong><a href="http://www.ruanyifeng.com/blog/2013/05/jquery-free.html" target="_blank">如何做到 jQuery-free？</a></li>
<li><strong>后一篇：</strong><a href="http://www.ruanyifeng.com/blog/2013/06/emmet_and_haml.html" target="_blank">HTML代码简写法：Emmet和Haml</a></li>
<li><strong>更多内容请访问：</strong><a href="http://www.ruanyifeng.com/blog/" target="_blank">首页</a> » <a href="http://www.ruanyifeng.com/blog/archives.html" target="_blank">档案</a> » <a href="http://www.ruanyifeng.com/blog/books/" target="_blank">读书</a></li>
<li><strong>站内搜索：</strong> </li>
<li><strong>Feed订阅：</strong> <a href="http://feeds.feedburner.com/ruanyifeng" target="_blank"><img src="" alt=""></a><h2 id="-http-www-ruanyifeng-com-ads-html-">广告<a href="http://www.ruanyifeng.com/ads.html" target="_blank">（购买广告位）</a></h2>
</li>
</ul>
<p><a href="http://www.ushan.cn/?act=suit" target="_blank"><img src="" alt=""></a></p>
<h2 id="-54-">留言（54条）</h2>
<p><a href="http://bulaoge.net/?ilovesuede" title="http://bulaoge.net/?ilovesuede" target="_blank">微蓝</a> 说：</p>
<p>要么有钱，要么听话……</p>
<p>p.s.这是沙发么……
<a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-271647" target="_blank">2013年5月21日 11:39</a> | <a href="http://www.ruanyifeng.com/blog/user/%E5%BE%AE%E8%93%9D.html" title="微蓝的全部留言" target="_blank">档案</a> | <a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-text" title="引用微蓝的这条留言" target="_blank">引用</a></p>
<p>某某读者 说：</p>
<p>很喜欢读你的博客，文章真实但不残酷。这个世界很美好，这个世界很丑陋。或者，这个世界很精彩（无论是美的，还是丑的）
<a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-271648" target="_blank">2013年5月21日 11:44</a> | <a href="http://www.ruanyifeng.com/blog/user/%E6%9F%90%E6%9F%90%E8%AF%BB%E8%80%85.html" title="某某读者的全部留言" target="_blank">档案</a> | <a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-text" title="引用某某读者的这条留言" target="_blank">引用</a>
betwinyou 说：</p>
<p>有才啊。文章让我更理解现在的中国
<a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-271649" target="_blank">2013年5月21日 11:54</a> | <a href="http://www.ruanyifeng.com/blog/user/betwinyou.html" title="betwinyou的全部留言" target="_blank">档案</a> | <a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-text" title="引用betwinyou的这条留言" target="_blank">引用</a></p>
<p>dYb 说：</p>
<p>社会环境如此，有好处，必然也有坏处。
<a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-271650" target="_blank">2013年5月21日 11:56</a> | <a href="http://www.ruanyifeng.com/blog/user/dYb.html" title="dYb的全部留言" target="_blank">档案</a> | <a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-text" title="引用dYb的这条留言" target="_blank">引用</a>
<a href="http://kongxz.com/" title="http://kongxz.com/" target="_blank">kmxz</a> 说：</p>
<p>确确实实鞭辟入里，观察透彻
<a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-271651" target="_blank">2013年5月21日 12:31</a> | <a href="http://www.ruanyifeng.com/blog/user/kmxz.html" title="kmxz的全部留言" target="_blank">档案</a> | <a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-text" title="引用kmxz的这条留言" target="_blank">引用</a></p>
<p>Hongye 说：</p>
<p>大部分都是缺点或不好的方面。嗨。有的也不仅限于中国。
<a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-271652" target="_blank">2013年5月21日 12:46</a> | <a href="http://www.ruanyifeng.com/blog/user/Hongye.html" title="Hongye的全部留言" target="_blank">档案</a> | <a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-text" title="引用Hongye的这条留言" target="_blank">引用</a>
alex 说：</p>
<p>深刻的吐槽，但是担心被...
<a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-271653" target="_blank">2013年5月21日 12:48</a> | <a href="http://www.ruanyifeng.com/blog/user/alex.html" title="alex的全部留言" target="_blank">档案</a> | <a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-text" title="引用alex的这条留言" target="_blank">引用</a></p>
<p><a href="http://s5s5.me/" title="http://s5s5.me" target="_blank">s5s5</a> 说：</p>
<p>亲吻干部，拥抱客户。
<a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-271654" target="_blank">2013年5月21日 12:54</a> | <a href="http://www.ruanyifeng.com/blog/user/s5s5.html" title="s5s5的全部留言" target="_blank">档案</a> | <a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-text" title="引用s5s5的这条留言" target="_blank">引用</a>
[0,1] 说：</p>
<p>应该说，这些东西并非新鲜，只要你关注，这些东西中国公知都告诉你了。相比中国公知而言，该书作者言论显得柔和多了。</p>
<p>54点多数都是模糊观点，对之不可能绝对同意或者反对。这模糊的东西也有不少不是中国所特有的，而是举世皆然的东西。</p>
<p>人到了一定年纪，看问题还是如此模糊、极端；或者换一个视角，这样模糊甚至极端的言论有更多的人认同，这也是极为悲哀的。</p>
<p>中国确实问题多多，但也不是54点描述的这样非人类。我相信，中国的艰难前进，能够影响世界，必然有他的大量优点。
<a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-271657" target="_blank">2013年5月21日 13:31</a> | <a href="http://www.ruanyifeng.com/blog/user/[0,1].html" title="[0,1]的全部留言" target="_blank">档案</a> | <a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-text" title="引用[0,1]的这条留言" target="_blank">引用</a></p>
<p>Timesand 说：</p>
<p>太经典了！就是这么回事！
<a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-271663" target="_blank">2013年5月21日 14:54</a> | <a href="http://www.ruanyifeng.com/blog/user/Timesand.html" title="Timesand的全部留言" target="_blank">档案</a> | <a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-text" title="引用Timesand的这条留言" target="_blank">引用</a>
lagolas 说：</p>
<p>书中的观点好像很极端，几乎没有一句好话，都是些陈词滥调，真是无趣。只是把外国人对中国的批评汇总了一下。动不动就说中国人就会死记硬背，不懂创新。
<a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-271664" target="_blank">2013年5月21日 14:56</a> | <a href="http://www.ruanyifeng.com/blog/user/lagolas.html" title="lagolas的全部留言" target="_blank">档案</a> | <a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-text" title="引用lagolas的这条留言" target="_blank">引用</a></p>
<p>若水 说：</p>
<p>那话怎么说的，宁愿信什么什么，别信媒体人那张嘴。这货坑美国自己人的，都这样子了，60年能把经济搞到世界第二，一定是火星人在帮中国
<a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-271665" target="_blank">2013年5月21日 15:12</a> | <a href="http://www.ruanyifeng.com/blog/user/%E8%8B%A5%E6%B0%B4.html" title="若水的全部留言" target="_blank">档案</a> | <a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-text" title="引用若水的这条留言" target="_blank">引用</a>
gj1827 说：</p>
<p>引用若水的发言：</p>
<p>那话怎么说的，宁愿信什么什么，别信媒体人那张嘴。这货坑美国自己人的，都这样子了，60年能把经济搞到世界第二，一定是火星人在帮中国</p>
<p>占世界1/5的人口，经济不是世界第一才是怪闻。
<a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-271669" target="_blank">2013年5月21日 17:14</a> | <a href="http://www.ruanyifeng.com/blog/user/gj1827.html" title="gj1827的全部留言" target="_blank">档案</a> | <a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-text" title="引用gj1827的这条留言" target="_blank">引用</a></p>
<p>密斯颜 说：</p>
<p>观点犀利
<a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-271673" target="_blank">2013年5月21日 18:43</a> | <a href="http://www.ruanyifeng.com/blog/user/%E5%AF%86%E6%96%AF%E9%A2%9C.html" title="密斯颜的全部留言" target="_blank">档案</a> | <a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-text" title="引用密斯颜的这条留言" target="_blank">引用</a>
Whiskier 说：</p>
<p>引用gj1827的发言：</p>
<p>占世界1/5的人口，经济不是世界第一才是怪闻。</p>
<p>印度人咧？
<a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-271674" target="_blank">2013年5月21日 19:55</a> | <a href="http://www.ruanyifeng.com/blog/user/Whiskier.html" title="Whiskier的全部留言" target="_blank">档案</a> | <a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-text" title="引用Whiskier的这条留言" target="_blank">引用</a></p>
<p><a href="http://www.cyfseo.com/" title="http://www.cyfseo.com" target="_blank">陈羽凡</a> 说：</p>
<p>真的说到一针见血哈！
<a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-271677" target="_blank">2013年5月21日 20:58</a> | <a href="http://www.ruanyifeng.com/blog/user/%E9%99%88%E7%BE%BD%E5%87%A1.html" title="陈羽凡的全部留言" target="_blank">档案</a> | <a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-text" title="引用陈羽凡的这条留言" target="_blank">引用</a>
<a href="http://blog.sina.com.cn/laoguo2" title="http://blog.sina.com.cn/laoguo2" target="_blank">laoguo</a> 说：</p>
<p>中国是地球上典型的＂服务自我的社会＂。连听都没听过这种说法的中国人以后在研究＂服务自我的社会＂和＂服务他者的社会＂之间在学术上的定义和表现上的区别的时候，会有得天独厚的理解上的优势。
<a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-271678" target="_blank">2013年5月21日 21:03</a> | <a href="http://www.ruanyifeng.com/blog/user/laoguo.html" title="laoguo的全部留言" target="_blank">档案</a> | <a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-text" title="引用laoguo的这条留言" target="_blank">引用</a></p>
<p>吴佳斌 说：</p>
<p>跟彼得·海斯勒的中国纪实三部曲一样好看
<a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-271679" target="_blank">2013年5月21日 21:53</a> | <a href="http://www.ruanyifeng.com/blog/user/%E5%90%B4%E4%BD%B3%E6%96%8C.html" title="吴佳斌的全部留言" target="_blank">档案</a> | <a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-text" title="引用吴佳斌的这条留言" target="_blank">引用</a>
waveacme 说：</p>
<p>不得不说，他很了解中国。
<a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-271680" target="_blank">2013年5月21日 22:30</a> | <a href="http://www.ruanyifeng.com/blog/user/waveacme.html" title="waveacme的全部留言" target="_blank">档案</a> | <a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-text" title="引用waveacme的这条留言" target="_blank">引用</a></p>
<p>iyutao 说：</p>
<p>是很精准的描述了当下中国的环境氛围，国与国的交往似个人与个人的交往，受个人的背景、品格等等因素影响，所以我开始以此来反思自己
<a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-271683" target="_blank">2013年5月22日 08:52</a> | <a href="http://www.ruanyifeng.com/blog/user/iyutao.html" title="iyutao的全部留言" target="_blank">档案</a> | <a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-text" title="引用iyutao的这条留言" target="_blank">引用</a>
Tony Stark 说：</p>
<p>看后真的是感觉无力又无耐！但不管如何，身在这样的社会当中，你要适应并利用他，为你创造价值。
我们没有安全感，即使你有很多钱，因为我们没有自我保护的方式，我们现在所拥有的，都很有可能在下一刻就被剥夺！筒子们，移民吧
<a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-271684" target="_blank">2013年5月22日 09:27</a> | <a href="http://www.ruanyifeng.com/blog/user/Tony%20Stark.html" title="Tony Stark的全部留言" target="_blank">档案</a> | <a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-text" title="引用Tony Stark的这条留言" target="_blank">引用</a></p>
<p><a href="http://blog.bomoo.com/pin/" title="http://blog.bomoo.com/pin/" target="_blank">pin</a> 说：</p>
<p>这本很早在译言上看到，放在kindle里，一直读不完。往往是看了后面忘了前面讲啥。
<a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-271685" target="_blank">2013年5月22日 10:04</a> | <a href="http://www.ruanyifeng.com/blog/user/pin.html" title="pin的全部留言" target="_blank">档案</a> | <a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-text" title="引用pin的这条留言" target="_blank">引用</a>
lking 说：</p>
<p>说的太好了！！！！ 狂赞！
<a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-271686" target="_blank">2013年5月22日 11:03</a> | <a href="http://www.ruanyifeng.com/blog/user/lking.html" title="lking的全部留言" target="_blank">档案</a> | <a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-text" title="引用lking的这条留言" target="_blank">引用</a></p>
<p>阿斯大声的 说：</p>
<p>印度是奇葩
<a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-271687" target="_blank">2013年5月22日 11:10</a> | <a href="http://www.ruanyifeng.com/blog/user/%E9%98%BF%E6%96%AF%E5%A4%A7%E5%A3%B0%E7%9A%84.html" title="阿斯大声的的全部留言" target="_blank">档案</a> | <a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-text" title="引用阿斯大声的的这条留言" target="_blank">引用</a>
<a href="http://service.weibo.com/reg/ajaxlogin.php?framelogin=1&amp;callback=parent.sinaSSOController.feedBackUrlCallBack" title="http://service.weibo.com/reg/ajaxlogin.php?framelogin=1&amp;callback=parent.sinaSSOController.feedBackUrlCallBack" target="_blank">cctv</a> 说：</p>
<p>在中国，你要么有钱，要么听话。
<a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-271688" target="_blank">2013年5月22日 11:58</a> | <a href="http://www.ruanyifeng.com/blog/user/cctv.html" title="cctv的全部留言" target="_blank">档案</a> | <a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-text" title="引用cctv的这条留言" target="_blank">引用</a></p>
<p>zhouzhou2043 说：</p>
<p>人性本身如此，只是我们希望的太多了，徒增痛苦，阮兄何必。
<a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-271689" target="_blank">2013年5月22日 12:17</a> | <a href="http://www.ruanyifeng.com/blog/user/zhouzhou2043.html" title="zhouzhou2043的全部留言" target="_blank">档案</a> | <a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-text" title="引用zhouzhou2043的这条留言" target="_blank">引用</a>
<a href="http://www.dubbofeng.com/" title="http://www.dubbofeng.com" target="_blank">冯大宝</a> 说：</p>
<p>其实这也不是理解当代中国的方法，就像James McGregor说的，这些规则在中国已经适用上千年了。
<a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-271690" target="_blank">2013年5月22日 14:23</a> | <a href="http://www.ruanyifeng.com/blog/user/%E5%86%AF%E5%A4%A7%E5%AE%9D.html" title="冯大宝的全部留言" target="_blank">档案</a> | <a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-text" title="引用冯大宝的这条留言" target="_blank">引用</a></p>
<p>兵马 说：</p>
<p>引用若水的发言：</p>
<p>那话怎么说的，宁愿信什么什么，别信媒体人那张嘴。这货坑美国自己人的，都这样子了，60年能把经济搞到世界第二，一定是火星人在帮中国</p>
<p>改革了，开放了，朝鲜，越南也可以把经济搞上去，一定是火星人折腾了我们前30年。
<a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-271695" target="_blank">2013年5月22日 18:02</a> | <a href="http://www.ruanyifeng.com/blog/user/%E5%85%B5%E9%A9%AC.html" title="兵马的全部留言" target="_blank">档案</a> | <a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-text" title="引用兵马的这条留言" target="_blank">引用</a>
<a href="http://imoshui.blog.163.com/" title="http://imoshui.blog.163.com" target="_blank">墨水</a> 说：</p>
<p>很难相信，一个外国人如此懂中国。对中国国情呵呵一笑，扬长而去。
<a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-271704" target="_blank">2013年5月23日 10:44</a> | <a href="http://www.ruanyifeng.com/blog/user/%E5%A2%A8%E6%B0%B4.html" title="墨水的全部留言" target="_blank">档案</a> | <a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-text" title="引用墨水的这条留言" target="_blank">引用</a></p>
<p><a href="http://www.callmewind.info/" title="http://www.callmewind.info" target="_blank">rain</a> 说：</p>
<p>“法律和合同的规定，不如人际关系重要”。中国人就是不讲制度的，所以有这样那样的纠纷，无论是大事还是小事，所以制度很重要
<a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-271710" target="_blank">2013年5月23日 21:18</a> | <a href="http://www.ruanyifeng.com/blog/user/rain.html" title="rain的全部留言" target="_blank">档案</a> | <a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-text" title="引用rain的这条留言" target="_blank">引用</a>
<a href="http://cfvwmg.com/" title="http://cfvwmg.com/" target="_blank">怼</a> 说：</p>
<p>水太深，单听净是坑害。要么谷歌，要么雅虎。
<a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-271712" target="_blank">2013年5月24日 08:48</a> | <a href="http://www.ruanyifeng.com/blog/user/%E6%80%BC.html" title="怼的全部留言" target="_blank">档案</a> | <a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-text" title="引用怼的这条留言" target="_blank">引用</a></p>
<p>舒思文 说：</p>
<p>可悲的是外国人比中国人自己更了解我们，我比较好奇的是你是从哪里找到这些比较有价值的书的呢？
<a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-271725" target="_blank">2013年5月24日 17:42</a> | <a href="http://www.ruanyifeng.com/blog/user/%E8%88%92%E6%80%9D%E6%96%87.html" title="舒思文的全部留言" target="_blank">档案</a> | <a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-text" title="引用舒思文的这条留言" target="_blank">引用</a>
<a href="http://chshouyu.com/" title="http://chshouyu.com" target="_blank">轻扬</a> 说：</p>
<p>阮兄不怕被请喝茶啊
<a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-271748" target="_blank">2013年5月26日 11:04</a> | <a href="http://www.ruanyifeng.com/blog/user/%E8%BD%BB%E6%89%AC.html" title="轻扬的全部留言" target="_blank">档案</a> | <a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-text" title="引用轻扬的这条留言" target="_blank">引用</a></p>
<p>BARRY LEE 说：</p>
<p>阮先生，我已付一些费用，转发微信去。
<a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-271753" target="_blank">2013年5月26日 21:16</a> | <a href="http://www.ruanyifeng.com/blog/user/BARRY%20LEE.html" title="BARRY LEE的全部留言" target="_blank">档案</a> | <a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-text" title="引用BARRY LEE的这条留言" target="_blank">引用</a>
<a href="http://dingsanlang.tap.cn/" title="http://dingsanlang.tap.cn/" target="_blank">丁三郎</a> 说：</p>
<p>我也想写一本《两亿乡绅》，招招点向美国人的死穴！不过不知阮兄是否可以代劳？
<a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-271754" target="_blank">2013年5月26日 21:32</a> | <a href="http://www.ruanyifeng.com/blog/user/%E4%B8%81%E4%B8%89%E9%83%8E.html" title="丁三郎的全部留言" target="_blank">档案</a> | <a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-text" title="引用丁三郎的这条留言" target="_blank">引用</a></p>
<p>nuke 说：</p>
<p>引用lagolas的发言：</p>
<p>书中的观点好像很极端，几乎没有一句好话，都是些陈词滥调，真是无趣。只是把外国人对中国的批评汇总了一下。动不动就说中国人就会死记硬背，不懂创新。</p>
<p>这个是摘录的部分，整本书没这么偏激
<a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-271764" target="_blank">2013年5月27日 11:00</a> | <a href="http://www.ruanyifeng.com/blog/user/nuke.html" title="nuke的全部留言" target="_blank">档案</a> | <a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-text" title="引用nuke的这条留言" target="_blank">引用</a>
nuke 说：</p>
<p>其中关于运10的失败，很有学习的价值
<a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-271765" target="_blank">2013年5月27日 11:01</a> | <a href="http://www.ruanyifeng.com/blog/user/nuke.html" title="nuke的全部留言" target="_blank">档案</a> | <a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-text" title="引用nuke的这条留言" target="_blank">引用</a></p>
<p>鱼 说：</p>
<p>引用Whiskier的发言：</p>
<p>印度人咧？</p>
<p>装：野史也疯狂
【中国是富了，还是穷了】四十年间，中国的GDP世界排名变化顺序如下：1978年第15名；1990年第10名；1995年第7名；2000年第6名；2007年第4名；2010年第2名；中国人均收入的世界排名变化顺序如下：1960年第78名；1970年第82名；1980年第94名；1990年第105名；2008年第106名；2010年第127名。来自皮皮精灵4月7日 09:38 阅读(1.6万) 全部转播和评论(236)
<a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-271773" target="_blank">2013年5月27日 16:24</a> | <a href="http://www.ruanyifeng.com/blog/user/%E9%B1%BC.html" title="鱼的全部留言" target="_blank">档案</a> | <a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-text" title="引用鱼的这条留言" target="_blank">引用</a>
kz 说：</p>
<p>当然，还有一种促成这种“现实”的原因：因为大家都是这样认为的。
<a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-271776" target="_blank">2013年5月27日 18:23</a> | <a href="http://www.ruanyifeng.com/blog/user/kz.html" title="kz的全部留言" target="_blank">档案</a> | <a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-text" title="引用kz的这条留言" target="_blank">引用</a></p>
<p><a href="http://www.anxinblog.org/" title="http://www.anxinblog.org" target="_blank">安心博客</a> 说：</p>
<p>亲吻干部，拥抱客户。这真是现实的真实写照！
<a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-271787" target="_blank">2013年5月28日 09:03</a> | <a href="http://www.ruanyifeng.com/blog/user/%E5%AE%89%E5%BF%83%E5%8D%9A%E5%AE%A2.html" title="安心博客的全部留言" target="_blank">档案</a> | <a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-text" title="引用安心博客的这条留言" target="_blank">引用</a>
<a href="http://www.yesnotes.net/" title="http://www.yesnotes.net" target="_blank">卡布奇诺</a> 说：</p>
<p>写到了许多我们不愿意承认但确实存在的问题,鞭辟入里.一个内心虚伪却要外表忠良的国度.
<a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-271792" target="_blank">2013年5月28日 13:10</a> | <a href="http://www.ruanyifeng.com/blog/user/%E5%8D%A1%E5%B8%83%E5%A5%87%E8%AF%BA.html" title="卡布奇诺的全部留言" target="_blank">档案</a> | <a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-text" title="引用卡布奇诺的这条留言" target="_blank">引用</a></p>
<p><a href="http://get-set.cn/wordpress" title="http://get-set.cn/wordpress" target="_blank">hurry</a> 说：</p>
<p>说实话，我不了解我的祖国
<a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-271796" target="_blank">2013年5月28日 14:34</a> | <a href="http://www.ruanyifeng.com/blog/user/hurry.html" title="hurry的全部留言" target="_blank">档案</a> | <a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-text" title="引用hurry的这条留言" target="_blank">引用</a>
luochen1990 说：</p>
<p>为了维持表面上的秩序，中国人的行为准则，不是有没有内疚，而是会不会被揭露。</p>
<p>只要不被抓住，中国人做任何事都可以心安理得。</p>
<p>这两句话太一针见血了,想到不久前的偷车弃婴案,想到无数次的食品安全问题,无不是这两句话的真实反映.
<a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-271808" target="_blank">2013年5月29日 14:33</a> | <a href="http://www.ruanyifeng.com/blog/user/luochen1990.html" title="luochen1990的全部留言" target="_blank">档案</a> | <a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-text" title="引用luochen1990的这条留言" target="_blank">引用</a></p>
<p><a href="http://levin.sinaapp.com/" title="http://levin.sinaapp.com" target="_blank">levin</a> 说：</p>
<p>确实，稳定是压倒一切的。
<a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-271819" target="_blank">2013年5月30日 01:02</a> | <a href="http://www.ruanyifeng.com/blog/user/levin.html" title="levin的全部留言" target="_blank">档案</a> | <a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-text" title="引用levin的这条留言" target="_blank">引用</a>
inspironX 说：</p>
<p>阮兄,还是少谈政治吧.这些话题总会引起大量评论,有人会觉得你想搞个阵地啥的,随时可以封你.
国外虚拟主机的站能被看到就算是开恩了,要珍惜.不要去挑战那些我们无法改变的事情.
<a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-271895" target="_blank">2013年6月 1日 23:17</a> | <a href="http://www.ruanyifeng.com/blog/user/inspironX.html" title="inspironX的全部留言" target="_blank">档案</a> | <a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-text" title="引用inspironX的这条留言" target="_blank">引用</a></p>
<p><a href="http://aviot.us/" title="http://aviot.us" target="_blank">aviot</a> 说：</p>
<p>好多自阉
<a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-271898" target="_blank">2013年6月 2日 01:54</a> | <a href="http://www.ruanyifeng.com/blog/user/aviot.html" title="aviot的全部留言" target="_blank">档案</a> | <a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-text" title="引用aviot的这条留言" target="_blank">引用</a>
钱烨 说：</p>
<p>中国追求的是国家的稳定与秩序。</p>
<p>美国的追求的是世界的稳定与秩序。</p>
<p>这两个国家都有一个共同点，他们的追求都是为了自己的国家。</p>
<p>但是他们又是不同的，中国的追求依靠人民的自我实现，美国依靠强大的武力。</p>
<p>世界的发展终将打破这个世界旧有的秩序和稳定，在世界经济一体化的大潮下，国家之间的平等和民主必将实现，到那个时候，每个国家都能享受到稳定与秩序带来的荣光。谁在与世界为敌，谁在阻挡历史的潮流，谁将成为历史的弃儿，在下一个10年内必见分晓。
<a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-271903" target="_blank">2013年6月 2日 11:29</a> | <a href="http://www.ruanyifeng.com/blog/user/%E9%92%B1%E7%83%A8.html" title="钱烨的全部留言" target="_blank">档案</a> | <a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-text" title="引用钱烨的这条留言" target="_blank">引用</a></p>
<p>小扁豆 说：</p>
<p>这才是中国通
<a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-271910" target="_blank">2013年6月 2日 23:19</a> | <a href="http://www.ruanyifeng.com/blog/user/%E5%B0%8F%E6%89%81%E8%B1%86.html" title="小扁豆的全部留言" target="_blank">档案</a> | <a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-text" title="引用小扁豆的这条留言" target="_blank">引用</a>
左村 说：</p>
<p>推荐看一下韩国电影《新世界》有点象《无间道》，绝对不比《无间道》差，甚至略有胜出
<a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-271956" target="_blank">2013年6月 5日 20:18</a> | <a href="http://www.ruanyifeng.com/blog/user/%E5%B7%A6%E6%9D%91.html" title="左村的全部留言" target="_blank">档案</a> | <a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-text" title="引用左村的这条留言" target="_blank">引用</a></p>
<p><a href="http://www.mingdeng.net/" title="http://www.mingdeng.net" target="_blank">明灯博客</a> 说：</p>
<p>外国人写的比较河蟹的书。
中国特色很鲜明。
<a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-271959" target="_blank">2013年6月 5日 21:37</a> | <a href="http://www.ruanyifeng.com/blog/user/%E6%98%8E%E7%81%AF%E5%8D%9A%E5%AE%A2.html" title="明灯博客的全部留言" target="_blank">档案</a> | <a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-text" title="引用明灯博客的这条留言" target="_blank">引用</a>
fygate 说：</p>
<p>引用inspironX的发言：</p>
<p>阮兄,还是少谈政治吧.这些话题总会引起大量评论,有人会觉得你想搞个阵地啥的,随时可以封你.
国外虚拟主机的站能被看到就算是开恩了,要珍惜.不要去挑战那些我们无法改变的事情.</p>
<p>有些事,总需要有人去做的!什么叫无法改变,如果每个人都沉默,那才真的叫无法改变!虽然我知道你是关心阮兄的!
<a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-271977" target="_blank">2013年6月 7日 12:22</a> | <a href="http://www.ruanyifeng.com/blog/user/fygate.html" title="fygate的全部留言" target="_blank">档案</a> | <a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-text" title="引用fygate的这条留言" target="_blank">引用</a></p>
<p>Sharks 说：</p>
<p>引用inspironX的发言：</p>
<p>阮兄,还是少谈政治吧.这些话题总会引起大量评论,有人会觉得你想搞个阵地啥的,随时可以封你.
国外虚拟主机的站能被看到就算是开恩了,要珍惜.不要去挑战那些我们无法改变的事情.</p>
<p>哪里有压迫，那里就忍着
<a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-271984" target="_blank">2013年6月 8日 05:34</a> | <a href="http://www.ruanyifeng.com/blog/user/Sharks.html" title="Sharks的全部留言" target="_blank">档案</a> | <a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-text" title="引用Sharks的这条留言" target="_blank">引用</a>
伊格尔 说：</p>
<p>正反两面都是需要听听看看的。中国的文化环境是中央集权，家长制，在当今的社会中必然不适合，所以会出现种种的不和谐现象和两面派
<a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-272018" target="_blank">2013年6月 9日 18:00</a> | <a href="http://www.ruanyifeng.com/blog/user/%E4%BC%8A%E6%A0%BC%E5%B0%94.html" title="伊格尔的全部留言" target="_blank">档案</a> | <a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-text" title="引用伊格尔的这条留言" target="_blank">引用</a></p>
<p>巴马奥 说：</p>
<p>你问问奥巴马是不是很乐意让位给麦凯恩？</p>
<p>谁在这个位子上都想着如何做好，如何长久，干嘛只盯着中国不放？
<a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-272071" target="_blank">2013年6月12日 21:28</a> | <a href="http://www.ruanyifeng.com/blog/user/%E5%B7%B4%E9%A9%AC%E5%A5%A5.html" title="巴马奥的全部留言" target="_blank">档案</a> | <a href="http://www.ruanyifeng.com/blog/2013/05/one-billion-consumers.html#comment-text" title="引用巴马奥的这条留言" target="_blank">引用</a></p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/好文摘录/">好文摘录</a></li></span></span> | <span class="time">recent updated:<time title="2014-03-07 11:24:28"datetime="2014-03-07 11:24:28"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/03/2014-02-03--如何理解当代中国----《十亿消费者》读后感/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-03--如何理解当代中国----《十亿消费者》读后感" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/03/2014-02-03--逃出你的肖申克（五）：看不见的牢笼（上）/">逃出你的肖申克（五）：看不见的牢笼（上）</a></h1>
      
        <span>Posted on<time datetime="2014-02-03T03:24:28.000Z"> <a href="/2014/02/03/2014-02-03--逃出你的肖申克（五）：看不见的牢笼（上）/">feb. 3 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-">逃出你的肖申克（五）：看不见的牢笼（上）</h1>
<h1 id="-http-mindhacks-cn-2012-06-04-escape-from-your-shawshank-part5-the-invisible-cage-"><a href="http://mindhacks.cn/2012/06/04/escape-from-your-shawshank-part5-the-invisible-cage/" target="_blank">逃出你的肖申克（五）：看不见的牢笼（上）</a></h1>
<p>《逃出你的肖申克》系列是从<a href="http://mindhacks.cn/2009/01/18/escape-from-your-shawshank-part1/" target="_blank">09年1月开始写的</a>，到现在已经三年半了，这个系列几乎是我从03年写博客以来时间跨度最长的一个系列。从08年开始，我就开始大量阅读心理学、认知科学、神经科学方面的书籍，对于我们的思维如何工作，我有着深深的着迷（事实也证明心理学是一个太有趣的学科，例如这个系列最受欢迎的一篇文章<a href="http://mindhacks.cn/2009/03/15/preconception-explained/" target="_blank">《逃出你的肖申克（二）：从视觉错觉到偏见》</a>单单在<a href="http://mindhacks.cn/" target="_blank"><a href="http://mindhacks.cn">http://mindhacks.cn</a></a>上就有15万的访问量），虽然不能从事这方面的研究，但另一方面也避开了研究中难免的繁琐技术细节，从局外人的角度纯粹去欣赏也许更为有乐趣，而即便从现实的角度来说，心理学也俨然已成为当下社会的显学（我最爱的科幻作家刘慈欣在《三体》系列中甚至也涉猎到了进化心理学），其实这很容易理解，所谓心理学就是关于人脑如何工作的科学，既然社会是由一个个的人构成，而人的行为很大程度上又由我们的大脑所支配，那么从这个根本上去理解很多问题便非常深入本质，所以在科研方面心理学正在渗透进越来越多关于“人”的科学，形成一个个蓬勃的交叉学科，例如<a href="http://en.wikipedia.org/wiki/Behavioral_economics" target="_blank">行为经济学</a>（甚至还有叫<a href="http://en.wikipedia.org/wiki/Neuroeconomics" target="_blank">神经经济学</a>的）、<a href="http://en.wikipedia.org/wiki/Computational_neuroscience" target="_blank">计算神经科学</a>等等，而心理学的现世价值更是无处不在（甚至都被有些书搞的有点恶俗了），例如工作中的问题解决、决策判断、人际关系，家庭中的亲密关系、<a href="http://book.douban.com/doulist/1327794/" target="_blank">育儿</a>，个人成长方面更是有无数关于心智成熟的书，国内在近几年引进的国外经典的书籍也呈加速势态（但仍然跟国外市场有严重时滞，有些好书引进到国内居然跨度相差20年）。《逃出你的肖申克》系列就是源于我阅读国外的泛心理学书籍的一个不断积累的读书笔记，其中有我自己的思考，但更多的是对我看过的知识的归纳和贯通，这个系列的文章有一个鲜明的特点，就是其中有无数的外链，因为我觉得能在一篇文章中归纳的东西实在太少，好的文章并不是体现在文章本身，而是体现在它为读者打开的一扇扇窗。</p>
<p><a href="http://mindhacks.cn/wp-content/uploads/2012/06/windows.jpg" target="_blank"><img src="&quot;windows&quot;" alt="windows"></a></p>
<p><strong>一，知识的诅咒</strong></p>
<p>著名科幻作家阿瑟·克拉克有一句名言（这句话是如此有名以至于被人尊称为“<a href="http://en.wikipedia.org/wiki/Clarke%27s_three_laws" target="_blank">克拉克第一定律</a>”）：“如果一位有名望的老科学家告诉你某件事情是可能的，那么他很可能是对的。然而如果他说某件事情是不可能的，那么他极有可能是错的。”</p>
<p>所谓成也萧何败萧何，“知识是一把双刃剑”这个道理在心理学领域其实并不新鲜，<a href="http://www.amazon.com/Made-Stick-Ideas-Survive-Others/dp/1400064287/" target="_blank">《Made To Stick》</a>上面就提到这样一个经典的实验：A心里想一首曲子，然后用打拍子的方式打出来，B听着A的拍子要去猜测A打的实际是哪个曲子。参与者选的是一些非常简单的曲子，如“世上只有妈妈好”（此处根据中国国情稍加演绎）。这个实验的亮点在于，往往A认为“那么简单的曲子”怎么可能听不出来呢？而实际上B听了却就是猜不出来。A对B能否猜中的概率估计，与B实际猜中的概率之间，有一个巨大的落差（A以为50%的人能猜出来，而实际上只有可怜的2.5%）。</p>
<p>原因？因为A心里本来就知道答案（曲子本来就是A定的），所以对于A来说这是“显然”的，但B只听到拍子，对B来说再简单的拍子也并不是“显然”的。关键在于，由于A心里明知答案，<em>就无法去设想不知道答案的B听到那样的拍子时是什么感觉</em>，也就无法真正准确地推测出B猜中的概率了。</p>
<p>实验者把这个现象称为“<a href="http://en.wikipedia.org/wiki/Curse_of_knowledge" target="_blank">知识的诅咒</a>”：由于知道某个知识，反而影响了判断。在以上的实验当中，如果A自己并不知道曲子，（曲子是实验者选的，拍子也是实验者打的），那么A就能够体会到B的感觉了。</p>
<p>以上这个例子，只要稍加引申一下，就不难类推到一个日常现象：为什么说大多数时候换位思考只是个陷阱。因为真正的换位思考，意味着你必须知道对方大脑中所有真正影响他决策和行为的因素，这包含太多的东西：对方的价值系统，习惯，观念，道德观，甚至对方那一刻的情绪。一个人的行为由众多因素来决定，其中绝大多数因素常常隐藏在我们根本觉察不到的潜意识层面（<a href="http://www.amazon.com/Strangers-Ourselves-Discovering-Adaptive-Unconscious/dp/0674013824/" target="_blank">《Strangers to Ourselves》</a>），连当事人自己都未必知道其自己行为的真正原因，更不用说要别人还能够真正的“换位”了。不仅如此，你还必须摆脱自己大脑中的价值系统、习惯、观念、道德观、情绪的影响。这两者本身都极其困难，乘起来更是难于登天。所以说现实当中的大多所谓换位思考一不小心就沦为以己度人。</p>
<p>有时候，当事情所涉及到的是人之常情，的确是可以以己度人（因为有些事情大家都差不多），例如说每个人都不希望自己的隐私被侵犯，那么当侵犯别人隐私的时候只要想想自己愿不愿意成为对方就可以了，“己所不欲勿施于人”。但当涉及到的是人与人之间不同的观念的时候，例如价值观，那么就会落入以己度人的陷阱，最典型的例子就是当代家庭中父母对子女的人生规划，往往抱着好心，办着坏事，因为当父母“换位思考”什么是“为子女好”的时候，无法摆脱自己价值观的影响，因为价值观是一个人内心非常强大而又隐蔽的东西，我们很难摆脱自己的价值观而真正从另外一个人的价值观角度去考虑（要是真的能够在内心那么容易地“切换”价值观的话，价值观就不叫价值观了），于是父母将“己所欲”施于“子女”。这里父母们自己的价值观，就仿佛前面那个实验当中被试A心里所想的曲子。因此，原则上不仅己所不欲勿施于人，还要<em>己所欲勿施于人</em>。</p>
<p>如果你对于<a href="http://en.wikipedia.org/wiki/Critical_thinking" target="_blank">Critical Thinking</a>有所了解，你应该知道这样一个有名的谬误（<a href="http://en.wikipedia.org/wiki/Logical_fallacy" target="_blank">Fallacy</a>），叫<a href="http://en.wikipedia.org/wiki/Affirming_the_consequent" target="_blank">Affirming the consequent</a>，例如：所有植物都需要水，玫瑰需要水，所以玫瑰是植物。这个逻辑咋听起来非常正确，但却是完全错误的。这是我们的“直觉逻辑”常犯的错误之一，由于所有人脑袋里都知道“玫瑰是植物”这个“知识”是正确的，所以爱屋及乌地也认可了它的“伪前提”（也就是说“结论是对的”意味着“逻辑是对的”）。如果把这里的结论换成错误的，你就摆脱了“知识的诅咒”，例如：所有植物都需要水，人需要水，所以人是植物。</p>
<p>以上只是两个简单的例子，实际上，知识的诅咒只是我们大脑中的众多看不见的牢笼之一。</p>
<p><strong>二，思维的牢笼</strong></p>
<p>关于创造性的研究有一个经典的问题，叫做<a href="http://en.wikipedia.org/wiki/Candle_problem" target="_blank">Candle Problem</a>（Pop Science畅销书作者Daniel Pinker在TED演讲<a href="http://www.ted.com/talks/dan_pink_on_motivation.html" target="_blank">The Surprising Science of Motivation</a>中也用到了这个例子），它的描述是这样的：
给你一堆火柴，一盒大头钉，一根蜡烛。问题：如何将燃烧的蜡烛固定在墙上，从而让它燃烧的时候蜡烛油不至于滴到桌上。 如下图：</p>
<p><a href="http://mindhacks.cn/wp-content/uploads/2012/06/Image.png" target="_blank"><img src="&quot;Image&quot;" alt="Image"></a></p>
<p>这个问题由心理学家Karl Duncker于1945年提出，在问题的最初描述下，被试百分之九十的人都大致会尝试两种徒劳无功的做法（<a href="http://www.amazon.com/Imagine-Creativity-Works-Jonah-Lehrer/dp/0547386079/" target="_blank">《Imagine》</a>）：</p>
<ol>
<li>试图直接用大头钉把蜡烛钉在墙上（蜡烛会碎掉）。</li>
<li>试图将蜡烛烧融之后粘在墙上（蜡油粘性不足以支撑蜡烛的重量）。</li>
</ol>
<p>在两次失败之后，大多数人都会放弃，认为问题无解。事实上只有极少数人最终得出了正解，即：<em>把蜡烛放在装大头钉的盒子当中，然后把盒子用大头钉钉到墙上</em>。如下图：</p>
<p><a href="http://mindhacks.cn/wp-content/uploads/2012/06/Image1.png" target="_blank"><img src="&quot;Image(1" alt="Image(1)">&quot;)</a></p>
<p>之所以这个小问题如此困难，心理学家推测，乃是因为我们下意识里面认为<em>大头钉的盒子就是用来装大头钉的</em>，压根就从来没有想过还可以用来做其他事情，心理学家把这个称作<em>功能定势</em>（<a href="http://en.wikipedia.org/wiki/Functional_fixedness" target="_blank">Functional Fixedness</a>）。由于这种思维定势在我们根本意识不到的下意识层面，所以我们自然也就很难打破他们——<strong>如果你都不知道你大脑中做了哪些假定，又怎么去打破那些假定呢？</strong></p>
<p>对于盒子的既有功能的知识，成了一个思维的牢笼，<em>这其实也是知识的诅咒的一种</em>。（知识的诅咒对创造性构成的扼杀是如此的显著，以至于Simonton声称大学本科头两年的教育之后所学的东西可能反而对创造性的抑制效果更大。（<a href="http://www.amazon.com/Imagine-Creativity-Works-Jonah-Lehrer/dp/0547386079/" target="_blank">《Imagine: How Creativity Works》</a>）</p>
<p>知识的诅咒是如此的隐蔽和难以摆脱，以至于创造性思维的一个重要技巧就是跟不同思维方式和知识背景的人交流，这里的理念是，<strong>如果你自己没法跳出框框，那么至少找一个跟你拥有不同框框的人对照一下</strong>，这样一对比便可以明白自己的框在什么地方。这也是为什么<em>“局外人”在一些问题上往往有新鲜而富于创造性思路</em>的原因。</p>
<p>如何打破这种牢笼呢？Ellen Langer在<a href="http://www.amazon.com/Mindfulness-A-Merloyd-Lawrence-Book/dp/0201523418/" target="_blank">《Mindfulness》</a>里面提到了一个很有创造性的实验，这个实验的目的是要被试去想出物品（例如锤子）尽量多的用途，当Langer把物品递给她的学生的时候，她分别尝试了两种说法，第一种说法是“这是一个锤子”，第二种说法是“这可能是一个锤子”，仅仅加上了一个词“可能”，同学们所给出的用途就大大增加了。这种条件式的表达非常有助于思维突破功能定势。</p>
<p>Candle Problem还有许多很有意思的变种，例如下面这个：</p>
<p><a href="http://mindhacks.cn/wp-content/uploads/2012/06/Image2.png" target="_blank"><img src="&quot;Image(2" alt="Image(2)">&quot;)</a></p>
<p>当实验者把大头针放在盒子外面，而非盒子里头的时候。几乎所有人都想到了答案。</p>
<p>此外还有，当用书面语言来描述问题的时候，如果说“盒子和大头钉”（而不是“一盒子大头钉”），会增加解出来的概率。此外，即便说“一盒子大头钉”，只要把“盒子”和“大头钉”加下划线也能显著增加成功率。我们可以看到，所有这些变种，都是启发问题解决者“不把装大头钉的盒子仅仅看作装大头钉的盒子”。</p>
<p>当我们谈论创造性的时候，我们通常谈论的是以下几个东西：</p>
<ol>
<li>跳出常规框框的思考（think out-of-the-box）</li>
<li>将两个东西/概念以前人没有想到的方式联系/结合起来</li>
<li>将既有方案推广到全新的问题场景中</li>
</ol>
<p>后两点我曾在之前的文章<a href="http://mindhacks.cn/2009/01/16/hammers-and-nails/" target="_blank">《锤子和钉子》</a>和<a href="http://mindhacks.cn/2008/04/18/learning-from-polya/" target="_blank">《跟波利亚学解题》</a>中有所提及。而第一点，即thinking out-of-the-box则一般被认为是创造性的标志性问题。</p>
<p>out-of-the-box这个说法源自一个非常古老的问题（笔不离纸（一笔画），不重复描线，不多于4条线段，经过所有9个点）：</p>
<p><a href="http://mindhacks.cn/wp-content/uploads/2012/06/Image3.png" target="_blank"><img src="&quot;Image(3" alt="Image(3)">&quot;)</a></p>
<p>这个问题大家都不陌生，但是相信大多数人在第一次面对这个问题的时候都是抓耳挠腮的。因为9个点的“隐形”边界构成了一个框，我们在画线条的时候下意识地就被束缚在了这个框内，而在框内是无解的，<em>可是框内的画法偏偏又有好多种，直到你遍历所有框内画法之前是没法确定框内无解的</em>，所以我们会花大量的时间在框内徒劳地画来画去。</p>
<p>思维中的这些隐形的“框”就是扼杀创造性的罪魁祸首。要想意识到这些框的存在，就必须对自己的思维过程本身有一定程度的了解，虽然心理学上<a href="http://scholar.google.com/scholar?hl=en&amp;q=+Telling+More+Than+We+Can+Know&amp;btnG=&amp;as_sdt=1%2C5&amp;as_sdtp=" target="_blank">已经证明这几乎是不可能的任务</a>（我们的思维过程绝大部分对意识而言是“不透明的”），但长期留意倾听自己思维的声音、善于反省的人还是较其他人更可能注意到思维过程的一个个关键的中间步骤。<strong>而就像黑夜中的萤火虫飞舞的轨迹可以通过它一闪一闪的亮光推断出来一样</strong>，通过注意我们思维的这些中间步骤，便有可能大致推断思维过程的全貌。</p>
<p>更重要的是，如果我们注意这些一个个的思维中间步骤，我们就有机会停下来，对它们进行“取反”操作，打破这一条因果链，从而在思维走上错误的岔路之前就避免它（实际上，这种对自己思维的“取反”操作是如此的重要，以至于有这样一本书，叫<a href="http://www.amazon.com/Whatever-You-Think-Opposite/dp/1591841216/" target="_blank">《Whatever You Think, Think The Opposite》</a>，还有一本叫《<a href="http://www.amazon.com/Makes-Brain-Happy-Should-Opposite/dp/1616144831/" target="_blank">What Makes Your Brain Happy and Why You Should Do The Opposite</a>》）。例如下面这个大家耳熟能详的问题（摘自<a href="http://www.amazon.com/Algorithmic-Puzzles-Anany-Levitin/dp/0199740445/" target="_blank">《Algorithm Puzzles》</a>）：
你站在一条河边要过河，你带着一头狮子，一只羊，和一颗大白菜。你的小船一次只能承载你和另外一样东西。如果你把狮子和羊留一块，狮子会吃掉羊。如果你把羊和白菜留一块，羊会吃白菜。怎么才能保证狮子、羊、和白菜都到达对面。</p>
<p>这个问题，但凡卡住的人，都卡在同一个地方，即：把羊带过去了，回头下一步到底是再把狮子带过去还是把白菜带过去呢？把狮子带过去，回头拿白菜的时候，狮子吃掉羊。把白菜带过去，羊吃掉白菜。似乎是一个无解的问题。但是，如果注意审视自己思维的每一个细小的步骤，把思维拆分为最小的原子单元，每一步只往前推必要的一步，不作跳跃，就有可能意识到关键的环节，并从思维的惯性中解脱出来。</p>
<p>我们的惯性思维，便是把N个东西紧密地绑定在一起，而没法拆分开来，每次都是直接跳到结论。如果把思维过程比作一棵树，在每个阶段基于特定的假设走上其中一条分支，有时候我们会觉得已经遍历了所有的情况，还没有解，所以就想放弃了，但是却没有意识到其实早在这棵思维之树的最根部节点我们就走上了一条其中不存在最终解的分支，例如上面的那个经典的9点问题，其根部的分叉就是：到底是在框内找还是在框外找，如果限定在“在框内找”这个假设/分支之下，那么无论你怎么遍历，最终都不会有解。你可能觉得已经穷举了所有的情况，但其实并没有，还有一半的解空间没有探索。而这一切发生的原因，便是因为隐含的一个假设把你限制在了某个框/分支内。如果对自己的思维过程足够细致，就有可能注意到原本很隐蔽的假设，从而从思维“树根”开始就走上另一条“少有人走的路”。</p>
<p><a href="http://mindhacks.cn/wp-content/uploads/2012/06/Manual_decision_tree.jpg" target="_blank"><img src="&quot;Manual_decision_tree&quot;" alt="Manual_decision_tree"></a></p>
<p>这虽然是一个小智力题，但是背后所蕴含的心理学原理是一样的：创造性意味着跳出你自己思维的惯性步骤，跳出你的下意识思维在某一个隐蔽的环节设下的隐蔽的假设。而要想打破铁屋子，必须首先知道铁屋子在哪，否则就是在黑暗中抓瞎。而想知道铁屋子在哪，则是通过对自己的思维过程仔细的观察来实现的（有的富有创造性的人已经把对自己思维的“取反”无意识化了，他们不管想什么都会下意识地想一想反面）。</p>
<p>要想观察自己的思维，最有效的技术之一就是“出声的思考”（think outloud），程序员们所熟知的“<a href="http://en.wikipedia.org/wiki/Rubber_duck_debugging" target="_blank">橡皮鸭子调试法</a>”便属此例，很多人在工作中也许都会有这样的体会：遇到一个问题，百思不得其解，于是想找个同事请教请教，但<em>就在把问题描述给同事听的过程当中，电光火石之间，答案自动蹦了出来</em>（这也是为什么Dr. House总是要找他的团队讨论的原因，而当团队不在的时候就算找个扫地的清洁工也行。这里的原理是：<strong>把思考过程转化成语言表达出来，就让它成为了思考本身的对象，即“对你的思考进行思考”</strong>，便有助于发现思考过程中的隐含假设或者步骤。</p>
<p>另一个极其重要的做法就是与人讨论，因为讨论不可避免涉及到两个环节：</p>
<ol>
<li><strong>表达自己的思维</strong>：这就是前面说的，把自己的思维表达出来，思维本身就变成了你思考的对象，你就有可能注意到思维环节当中之前没有注意到的隐蔽的环节，并对其“取反”，跳出原本的框框。</li>
<li><strong>参照别人的思维</strong>：由于每个人思维的框框（隐含假设）未必一样，所以你的“显然”可能是别人的“不一定吧？”。通过对比，之前隐形的思维边界就会显现出来，这就<em>好像在黑夜中没法看到黑色的字，而在白色背景的映衬下就会一目了然</em>。</li>
</ol>
<p>另一方面，隐蔽的假设又是从哪里来的呢？一方面，从人的知觉系统的固有“偏见”中来，例如九点问题中那个隐形的框就是格式塔心理学的一个经典例子（<a href="http://mindhacks.cn/2009/03/15/preconception-explained/" target="_blank">《逃出你的肖申克：从视觉错觉到偏见》</a>）。另一方面，从之前所掌握的知识当中来。例如<a href="http://www.amazon.com/Mindfulness-Merloyd-Lawrence-Ellen-Langer/dp/0201523418/" target="_blank">《Mindfulness》</a>里面这样一个实验：
先让你做这样一道题：A、B、C三个容量分别为21、127和3夸脱的罐子，用他们取100夸脱的水。很快你想到了方法：先装满B罐，然后减去A罐，再减去两次C罐（即B-A-2C）。127-21-3-3=100。接下来再给你做另一个类似的问题，只是容量不一样：A=23，B=49，C=3。目的是得到20夸脱的水。答过前一个问题的人很多都会直接发现B-A-2C同样适用于这个问题，而看不到那个更简单的答案：23-3（A-C）。而没有前一个问题干扰的人则更容易看到最简单的答案。知识的双刃剑效应在这个小小的实验里面体现得淋漓尽致。</p>
<p>这种效应在知觉上也存在，例如下面这个例子（<a href="http://www.amazon.com/Mindfulness-Solution-Everyday-Practices-Problems/dp/1606232940/" target="_blank">《The Mindfulness Solution》</a>）：</p>
<p><a href="http://mindhacks.cn/wp-content/uploads/2012/06/Image7.png" target="_blank"><img src="&quot;Image(7" alt="Image(7)">&quot;)</a></p>
<p>在上图中你看到了什么？一个英文单词：Perception。</p>
<p>那么下图中呢？</p>
<p><a href="http://mindhacks.cn/wp-content/uploads/2012/06/Image8.png" target="_blank"><img src="&quot;Image(8" alt="Image(8)">&quot;)</a></p>
<p>一堆蚯蚓一样弯弯曲曲的线条？其实这是阿拉伯语的Perception。如果你仔细想一想：其实图1的Perception归根结底不也是一堆弯曲的线条吗？但是你能够把它<em>真正看作</em>是一堆线条吗？很难。因为作为一个你已经认识的单词，其含义会自动从你脑海中蹦出来（这种<a href="http://en.wikipedia.org/wiki/Gestalt_psychology#Emergence" target="_blank">“蹦出来”效应</a>是一种自动的、自下而上的效应，你没法用意志去“抑制”它），Perception这个单词自动蹦出来的含义会阻止你去带着“<a href="http://en.wikipedia.org/wiki/Beginners_Mind" target="_blank">初心</a>”看待“这堆线条”，在你的眼中这不再是一堆单纯的，无意义的线条了。但是图2中的文字就不一样了，由于你根本不认识它（没有先入为主的观念的限制），你就能够仍然“看山是山”了。这个例子是不是也让你想起本文开头的“知识”的诅咒呢？没有知识是万万不行的，但知识有时候的确会掩盖你对于世界的真相的观察。</p>
<p>再看一个经典的例子：</p>
<p><a href="http://mindhacks.cn/wp-content/uploads/2012/06/Image9.png" target="_blank"><img src="&quot;Image(9" alt="Image(9)">&quot;)</a></p>
<p>这幅图相信大家都见过。在没有看到那只狗之前，图中只是一堆混乱的斑点，而一旦看见了狗，你就无法再视而不见了，那只狗会顽固地从你的视野中“蹦出来”，那堆原本看上去混乱无序的斑点便失去了其混乱的本质，你的知觉被锚定在这个唯一解释上。在上文的“倒水问题”中，那个既有的解法就像是上面图片中的斑点狗，会第一时间顽固地蹦出来，占据你的注意力，遮蔽你的思维，让你注意不到其他可能性的存在。</p>
<p>有这样一个笑话：
在美国/墨西哥边境，看守警卫看到一个男人，骑着自行车，把手上放着一个箱子，警卫把那个男人叫下来，让他打开箱子，结果发现箱子里面全是沙子。第二天，这个男人又来了，还是骑着自行车带着个箱子，警卫打开一看还是沙子，如此两个月，这个男人每天都穿过边境，每次都带着一箱沙子。警卫哥终于崩溃了：“大哥你快把我们逼疯了，两个月以来你每天都骑着你的自行车，带着一箱沙子穿过边境，你这到底是走私什么呢？”。男人回答：“自行车”。(<a href="http://en.wikipedia.org/wiki/Think_outside_the_box#The_.22Youngman_Technique.22_for_problem_solving" target="_blank">/#</a>)</p>
<p><strong>不要只关心箱子里面是什么，要“跳出箱子思考”。</strong></p>
<p>跳出箱子当然不是一件容易的事情，<strong>我们自己的心智模式对于我们而言就像空气一样，身处其中根本就浑然不觉</strong>。前面提到的“出声思考”和与人讨论固然是很好的办法，但并不能解决所有的问题，真正需要创造性的困难问题往往命中的是大多数人的思维盲点，所以讨论可能也还是无济于事。另一方面，虽然说创造性需要打破既有知识的限制，但毕竟巧妇难为无米之炊，<em>足够的知识却又不可或缺</em>。人们常常用牛顿因为苹果落地而发现万有引力，或者爱因斯坦的自由落体思想实验来说明灵感的重要性，然而没有牛顿和爱因斯坦的物理和数学知识作为铺垫，就算有人告诉你苹果落地是由于地球的作用，你也没法得出万有引力公式，就算有人把你放到一个自由落体的电梯中让你真实感受运动与静止的相对性，你也没法导出相对论。如何在掌握必要知识的同时又不会被其限制住思维，才是保持创造性的关键，如何走得了这个微妙的平衡木，在人类对于自身大脑的认知的历史上一直是最困难的问题之一，无数卓越的头脑前仆后继（包括像庞加莱本身也对他为什么能够在一瞬间灵感顿现也非常有兴趣并有一些很有价值的思考），直到今天，心理科学似乎才刚刚开始揭开创造性和灵感的面纱。</p>
<p><strong>三，情绪的牢笼</strong></p>
<p>情绪是人类最强大的能力之一，我们有丰富而微妙的情感世界，我们大脑中有众多<a href="http://en.wikipedia.org/wiki/Affective_neuroscience#Brain_areas_related_to_emotion" target="_blank">涉及到情感的模块</a>，如杏仁核、前额叶皮层、前扣带皮层等等，我们强大的情绪脑使我们能够在一瞬间对事物贴上“喜欢”、“没感觉”或“厌恶”的标签（从而迅速作出“趋向”、“无所谓”还是“回避”的选择）（<a href="http://www.amazon.com/The-Happiness-Hypothesis-Finding-Ancient/dp/0465028020/" target="_blank">《The Happiness Hypothesis》</a>，<a href="http://www.amazon.com/The-Mindfulness-Solution-Everyday-Practices/dp/1606232940/" target="_blank">《The Mindfulness Solution》</a>），能够对复杂的道德情境作出众口一词的判断（<a href="http://www.amazon.com/The-Moral-Animal-Evolutionary-Psychology/dp/0679763996" target="_blank">《The Moral Animal》</a>），能够体会蕴含着无限微妙情愫、只能意会不可言传的隐喻（<a href="http://www.amazon.com/Is-Other-Secret-Metaphor-Shapes/dp/0061710288/" target="_blank">《I Is an Other》</a>）。</p>
<p>然而，另一方面，我们的情感世界也是我们大脑中牢笼最多的地方。要理解这一点，需明白情绪大脑的几个基本属性：<em>高优先级</em>、<em>黑盒</em>、<em>迅速但粗糙</em>。</p>
<p>大脑中的情绪模块属于进化年代较为古老的部分（《Synaptic Self》），其掌管的事情往往是关乎生存繁衍利益，所以权力至高无上，例如你走在河边，忽然看到一条弯弯曲曲的东西横在路边，还没等你的理性大脑反应过来你就一跳三丈高了，这个让你一跳三丈高的信号便源于我们情绪大脑的一个重要模块——杏仁核（Amygdala）。我们的视觉信号进入大脑之后兵分两路，其中一路（high road）通往我们大脑的“高级”区域做详细但较慢的计算，另一路（low road）则到达我们的杏仁核，进行迅速但粗糙的计算，我们的立即行为受到low road的支配（<a href="http://en.wikipedia.org/wiki/Amygdala_hijack" target="_blank">被杏仁核绑架了</a>），因为该路的计算速度较快（但很遗憾“快”跟“准”是一对矛盾），如果疑似遇到对我们可能有威胁的场景，我们立即就会进入所谓的“战斗或逃跑”（<a href="http://en.wikipedia.org/wiki/Fight-or-flight_response" target="_blank">fight-or-flight</a>）状态。</p>
<p>由此可见，情绪大脑并不那么“聪明”，它要的是“快”（因为所涉及的决策往往生死攸关），而未必是“准”，就像我们设计计算机算法一样，为了“快”，有时候必须以牺牲“准”为代价。此外，当牺牲“准”的时候，情绪大脑也不是胡乱牺牲，而是会有特定的倾向性，它会倾向于宁可错在保守的一边，即宁可把绳子错当成蛇，也不可把蛇错当成绳子，因为把绳子错当蛇只不过是吓一跳而已，没什么代价，而把蛇错当成绳子可能就犯下了生死攸关的大错。大脑中的这种固定的、有章可循的倾向性就是所谓的“认知偏差”（<a href="http://en.wikipedia.org/wiki/Cognitive_bias" target="_blank">cognitive bias</a>）（<a href="http://www.amazon.com/Predictably-Irrational-Revised-Expanded-Edition/dp/0061353248/" target="_blank">《Predictably Irrational》</a>）</p>
<p>此外，我们的情绪大脑还是一个黑盒模块，绝大多数时候，我们只能感受到其<em>输出</em>（情绪体验），而对于为什么我们会产生这样或那样的情绪，却一无所知。有些时候，我们甚至都不知道我们对某些人和事的真实情感是什么（例如人们常说的“总是在失去以后才知道珍惜”）（<a href="http://www.amazon.com/Strangers-Ourselves-Discovering-Adaptive-Unconscious/dp/0674013824/" target="_blank">《Strangers to Ourselves》</a>）。很多时候我们认为很了解自己，是因为我们的理性大脑非常善于为自己的情绪或行为寻找看上去合乎情理的解释（<a href="http://mindhacks.cn/2011/01/23/escape-from-your-shawshank-4/" target="_blank">《逃出你的肖申克（四）：理智与情感》</a>）</p>
<p>有这样一个有名的心理学实验，由心理学家Donald G. Dutton和Arthur P. Aron在1974年设计，实验名叫“悬索桥上的爱”（<a href="http://www.amazon.com/Sway-Irresistible-Pull-Irrational-Behavior/dp/0385530609/" target="_blank">《Sway》</a>）。实验者招聘了一些被试，表面上称实验的目的是为了研究优美的风景对人的创造力的影响，实验的场所在一处风景名胜，被试需要穿过一座悬索桥，如图：</p>
<p><a href="http://mindhacks.cn/wp-content/uploads/2012/06/Image4.png" target="_blank"><img src="&quot;Image(4" alt="Image(4)">&quot;)</a></p>
<p>一位漂亮的女助手会拦住被试，请求填写问卷。对于其中一部分被试，女助手在他们已经穿过了悬索桥之后拦住他们，而对于另一些被试，则在悬索桥中间拦住他们。在问卷填写完毕之后，女助手会留下自己的电话号码，并对对方说“如果你有兴趣，欢迎打电话给我，我很愿意进一步解释实验的细节”。</p>
<p>然而，这个实验的真实意图却是想要知道到底是哪组被试中有更多的人对女助手动心，实验人员事后会统计哪组被试当中有更多的人会打电话约女助手出去。</p>
<p>这个实验之所以有名，是因为其结果很令人掉下巴：两组被试唯一的区别便是在<em>桥上</em>还是<em>桥头</em>被拦下来，这个无关紧要的区别跟女助手的吸引力究竟能有什么关系呢？然而，包括后续的类似实验也证实了确有关系：在桥上被拦下来的被试当中有更多的人打电话约女助手。为什么？心理学家认为，当被试处在悬索桥上的时候，情绪处于高唤起状态，心跳加速，手心湿润，这跟异性吸引所致的唤起状态很相似，人们的下意识会将这种唤起状态部分<a href="http://en.wikipedia.org/wiki/Misattribution_of_arousal" target="_blank">错误归因</a>为女助手的吸引力。而实验最关键的地方在于，被试自己<em>并不认为</em>是这种错误归因让他们觉得女助手更加具有吸引力，而是真诚地认为女助手<em>就是</em>更有吸引力。</p>
<p>类似的，我们都知道，热恋中的情侣，父母越是干涉，往往会反而导致他们情感越发热烈。但这儿的关键在于，他们不会觉得这是家长干涉的“功劳”，而是真心觉得情感越发强烈。心理学家把这种现象称为“罗密欧与朱丽叶效应”。“罗密欧与朱丽叶效应”体现了一个一般性原则：由于我们的大脑<em>每秒接受的信息里面只有少得可怜的一部分到达意识层面</em>，绝大多数都在下意识层面处理掉了。因此<strong>我们无法直接洞察大脑中发生了什么，绝大多数时候，我们之所以感觉“知道”我们为什么这样那样做，是由于我们的大脑无时无刻不在推理“为什么我会那么做”</strong>，<em>对于了解自己的人来说，这种推理往往正确，但如果不够了解自己，那么就有可能错误地推断了自己行为的动因</em>。</p>
<p>心理学对我们行为的动机有一个基本的区分：外部动机和内部动机。前者例如：金钱、物质、惩罚，等等。后者例如：好奇心、成就感、价值观等等。一个重要的观察是：当内部动机和外部动机同时存在的时候，我们常常会下意识倾向于把自己的行为的动机归因于外部动机，因为外部动机更为看得见摸得着，而内部动机则较为隐蔽（文艺一点的说法就是<em>内心的小声音</em>太容易被外界的喧哗所遮蔽）。</p>
<p>心理类和育儿类的书籍中经常可见引用这样的一个故事（此处的版本稍加演绎，原版记不大清了）：
一位老人住在一个小木屋中，经常有小孩来他的木屋旁边玩闹，喜欢安静的老人不胜其扰，老人知道赶他们走也没有用，甚至可能适得其反。有一天，老人把孩子们叫过来，给了他们每人五毛钱，说“我很喜欢你们，以后你们每天都过来玩，每次都都会给你们每人五毛钱”。孩子们听了之后当然很开心，居然还有这等好事，还有人愿意花钱让他们玩，于是他们每天过去玩。如此过了一阵之后，老人又把他们叫过来，说“最近我没什么钱了，只能给你们每人两毛钱”，孩子们听了之后虽然有些不快，但总比没钱好吧，所以还是过来玩，但劲头已经大不如前了。如此又过了一阵，老人说“虽然我很想你们过来玩，但我真的没钱了，以后不能再给你们钱了”。孩子们听了很生气，后果很严重，心想“没钱还指望我们来玩吗？”，于是都散了。</p>
<p>育儿类的书籍用这个故事来告诫父母，毁掉孩子对事情本身的兴趣的最好的办法就是给物质奖励。当物质奖励和兴趣同事存在的时候，由于前者更为看得见摸得着，而且我们的大脑对于物质激励更为敏感，所以更容易推测自己的行为的动机为物质激励，而一旦大脑将这两者挂上了因果关系就坏事了，因为一旦以后“因”（物质激励）被撤掉，“果”（好好学习）也就消失了。（当然，如果孩子本身就对什么都没有兴趣，那么使用物质激励来作为初始动因也无不可。由于本就没有内部动机，所以外部激励不会让事情更糟，<a href="http://www.amazon.com/Redirect-Surprising-Science-Psychological-Change/dp/0316051888/" target="_blank">《Redirect：The Surprising New Science of Psychological Change》</a>第四章对此有非常详细的分析）</p>
<p>反过来说，当外部动机看上去不足以解释行为的时候，我们也会（同样错误）地把动机归结为“我想这么做”。社会心理学有一个有名的说服技巧叫<a href="http://en.wikipedia.org/wiki/Foot-in-the-door" target="_blank">“登门槛效应”</a>（<a href="http://www.amazon.com/Yes-Scientifically-Proven-Ways-Persuasive/dp/1416576142/" target="_blank">《Yes!: 50 Scientifically Proven Ways to Be Persuasive》</a>），其原理也与此类似。</p>
<p>类似的情况还有很多，它们统称Overshadowing Effect（遮蔽效应），当行为存在多个可能的解释的时候，更“吸引眼球”的解释往往会占上风，不管其是否真正的解释。换句话说，“吸引眼球”的外部动因会“遮蔽”内心的微弱的小声音。</p>
<p>面对选择也是如此，我们究竟是因为什么原因选择这个而不是那个呢？可口可乐和百事可乐口味的双盲实验相信大家都耳熟能详了——人们<em>相信</em>他们选择可口可乐而不是百事可乐是因为前者味道更好。然而一旦把标签撕掉，人们往往惊讶地发现自己选择的却是百事可乐。实际上，<em>标价</em>、<em>品牌</em>、甚至<em>放在货架上靠左还是靠右的位置</em>、<em>菜单上的字体</em>是否美观，这些都在下意识层面对我们的行为产生实质性的影响，但由于种种原因我们往往错误地将自己的选择或体验归因为商品本身的质量或者味道。（<a href="http://www.amazon.com/Subliminal-Your-Unconscious-Rules-Behavior/dp/0307378217/" target="_blank">《Subliminal》</a>）。我们倾向于相信自己的决策是理性的，基于正确的信息的，这种<a href="http://en.wikipedia.org/wiki/Wishful_thinking" target="_blank">Wishful Thinking</a>使得我们推测自己之所以选择一种商品肯定是基于其质量（“否则自己就太傻了”，我们当然不希望自己很傻），这种自我认知的需要掩盖了真正的动因。</p>
<p>有这样一个有趣的实验（这个实验有各种变种，也许你也可以在自己的现实生活中找到自己的版本）：
实验者雇了两组人，给他们一些艺术海报让他们选择，其中一组人让他们<em>在选择之前先</em>详细罗列自己认为每一张海报好在哪里或不好在哪里（就像本杰明·富兰克林著名的列表决策法一样），另一组人则不这么做，而是直接遵循自己的喜好进行选择。在实验结束之后若干天，实验者回访了这些人，发现第二批人（直接选择的）很明显比第一批人（先罗列原因的）更中意他们当初的选择。</p>
<p>这个实验的原理是这样的：由于我们的情绪大脑是个黑盒，它选择喜好的时候有自己的一套逻辑，而我们所意识到的只是结论（“一眼眼上去就喜欢，也说不清为什么”），但是第一组被试却<em>试图去推测</em>这个黑盒内部的逻辑到底是什么，而<em>推测往往是错误的</em>，但他们<em>却相信自己的推测是正确（理性）的</em>，于是他们基于这些推测出来的（往往不正确）的逻辑进行决策，之后发现自己的情绪大脑却并不买账，因为理性大脑猜猜看猜错了。这里，后者的“理性”分析遮蔽（Overshadow）了情绪大脑真正的动机。</p>
<p>Overshadowing Effect是一个比较一般性的现象，不仅体现在心理动机方面。例如早在1950年的时候，人们就发现，对视觉记忆进行语言描述不仅不会帮助深化记忆，反而还会损害记忆。Schooler和Engstler-Schooler两位心理学家在1990年做了一个很经典的实验（<a href="http://www.amazon.com/The-Invisible-Gorilla-Intuitions-Deceive/dp/0307459667/" target="_blank">《The Invisible Gorilla》</a>），这篇论文的标题是这样的：“语言对视觉记忆的遮蔽效应：有些事情不可说，一说便破”。其中“不可说，一说便破”是我意译的，原文是“Some Things Are Better Left Unsaid”，这个实验模拟的是当时目击证人指认犯罪嫌疑人的过程：
两组被试首先观看30秒银行被抢现场录像，其中犯罪嫌疑人露了一下脸。之后，其中一组被试被要求花五分钟“尽可能详细”地描绘他所看到的犯罪分子的脸，另一组被试在这五分钟内则什么都不做。接着，两组被试都被要求从一组嫌疑人当中进行指认。</p>
<p>猜怎么着？前后一组被试指认的准确率为64%，而后前一组被试，也就是那组被要求尽量详细地描绘录像中看到的嫌疑人的脸的被试，他们的准确率竟反而只有可怜的38%。</p>
<p>正如前面提到的选艺术海报的实验一样，当我们被要求对自己无法获知其内部状态的大脑黑盒模块（不管是情绪模块还是视觉记忆模块）进行分析的时候，我们的分析只是推测，或者只是在用有限描述能力的语言去试图逼近无限微妙的视觉记忆，而我们又倾向于相信自己的推测或分析，并进而仅依据他们来做判断决策（而将真正拥有信息的大脑模块抛弃在一旁），于是遮蔽效应就发生了。</p>
<p>我们知道，很多时候我们的行为的最深层动机来源于情绪大脑，情绪大脑指引着我们绝大多数的日常行为，而既然如上面所说，情绪大脑“并不总是对的”，但又是一个黑盒，无法窥其内部，所以出错了也很难“调试”和“纠错”，那么当情绪大脑出错的时候会出现什么情况呢？</p>
<p>二战之后，由于战争的创伤，很多儿童无家可归，无人照料，这些孩子在成年之后，在人际关系相处交往方面出现了诸多的困难，联合国遂派心理医生、心理分析学家John Bowlby去做调研。Bowlby后来便由此提出了著名的<a href="http://en.wikipedia.org/wiki/Attachment_theory" target="_blank">Attachment Theory</a>（依恋理论）。虽然心理分析学派后来<a href="http://en.wikipedia.org/wiki/Psychoanalysis#Criticism" target="_blank">饱受批判</a>，但Bowlby的依恋理论本身却是一个很成功的经典理论，并且<a href="http://internal.psychology.illinois.edu/~rcfraley/attachment.htm" target="_blank">在后来被拓展到两性关系当中</a>。</p>
<p>最简单的来说，依恋理论认为一个人成年之后在亲密关系中的行为模式与其儿童时期与主要照顾者（通常是父母）的相处模式有很大的因果关联。</p>
<p>与心理分析学派试图把任何成年的行为模式都往童年归根溯源不同（这属于<a href="http://en.wikipedia.org/wiki/Golden_hammer" target="_blank">拿着锤子找钉子</a>），依恋理论基于一个很“现实”的假设：对刚出生不久的幼儿来说，有两个关键的需求：1. 生存需求。2. 探索环境的需求。前者要求父母在视线之内，后者则往往意味着离开父母。Bowlby认为，漫长的进化中的自然选择使得我们大脑中形成了一个动机调节/控制系统，这个系统的第一要义是满足安全感（生存）需求，在此前提之下，去努力探索环境。就像我家宝宝总喜欢玩楼下某户人家门口蹲着的一只惟妙惟肖的石膏狗，但是很显然她觉得那是只真动物，所以有点害怕，所以她的折衷方案就是拉着我的手要我跟她一块过去，然后她就放心地调戏人家的门神了:)</p>
<p>Bowlby用负反馈系统来打比方，例如空调中的自动控温系统，当室内温度达到某个阈值之下的时候就自动启动空调，到达阈值之后便关闭，从而使室温稳定在一个温度。我们大脑中的安全感控制系统也是如此，当安全感降到某个阈值之下的时候，便开启大家都熟悉的一种叫“焦虑”的情绪，驱使宝宝去寻找他/她的照料者，而找到了之后，焦虑便逐渐降低。当第一需求——安全感——得到满足之后，便启动第二个需求——探索，而探索的过程中一旦感知到不安全因素的存在（例如父母离开、环境陌生，等等），则探索行为会立即停止，安全感的调节器再次打开。由此可见这是一个在两个需求之间去的平衡的动态控制系统。</p>
<p>但以上只是理想情况，基于父母的不同行为，孩子的行为也会有显著的不同，以下是依恋理论当中的三个比较主要和典型的类型：</p>
<p>安全依恋型，即安全感较强，相信妈妈总会在身边，所以探索行为较多，即便因妈妈离开而焦虑哭泣，一旦妈妈回到身边也会很快回复到探索状态。这个被认为是理想的依恋模型，形成这种依恋模型的前提是父母总能够在宝宝需要的时候满足其安全感需求。</p>
<p>逃避型，这种类型的孩子不管对父母还是对陌生人都表现漠然，也不会去探索环境，比较孤僻。依恋理论认为这种行为的成因是父母总是不能给与足够的安全感，例如没有耐心，对孩子的需求不敏感，拒绝身体接触，以及其他负面反馈，久而久之孩子会形成“我也并不需要你”的心理，因为没有人能够长期生活在期望得不到满足的焦虑中，要么改变现实使希望成真，要么改变期望以适应现实，在这种类型的依恋关系中，由于父母无法满足孩子对于亲密关系的期望的现实，所以孩子只能降低心理期望。但是，由于前面提到的控制系统把安全感放在首位，安全感得不到满足就不能去探索环境，所以这类孩子可能会陷在这个阶段很久。其实，心理学家通过检测心跳、压力荷尔蒙水平发现这类孩子并非真的通过调节期望从而完全没有焦虑，其实在平静的表面下，他们仍然期望得到父母的关爱（你可能会觉得奇怪，人说天下没有不爱孩子的父母，怎么会出现这种情况呢？原因很多，以后慢慢再说）</p>
<p>矛盾型，表现出对于亲密感的过分渴求，不能很快得到安全感满足并探索环境。分离焦虑很高，而当父母真正返回的时候又表现出愤怒和反抗以惩罚父母。这种类型的形成往往由于父母不能<em>一致性</em>地给予关爱，时而关心时而冷淡，往往当孩子表现得强烈需要关爱的时候才会去关爱。这种不确定性带来的后果就是孩子总是焦虑着想去争取多一些关爱，并且希望通过惩罚去减少父母“不打招呼就闪人”的几率。</p>
<p>在儿童时期形成的依恋模型很可能会成为成年之后人际关系（特别是亲密关系）的<em>参照系</em>，当和他人建立亲密关系的时候，很可能会沿用当年在亲密关系中形成的一些下意识的假设（“我知道在你需要的时候你总是会在我身边”，“我不知道你什么时候就会离开我消失了”，“我不需要你”），例如逃避型的孩子可能较难建立真正互相信任的亲密感，而矛盾型的则可能会表现出对亲密关系丧失的高度焦虑、总是寻求蛛丝马迹要确信对方是爱自己的。我们的大脑最具有可塑性的年龄就是在童年（当然，<a href="http://en.wikipedia.org/wiki/Neuroplasticity" target="_blank">在人的整个一生中大脑都是具有可塑性</a>，并且观念都是可能发生根本转变的，这里只是相对而言），而对于世界的一些基本方面（如亲密关系）所形成的心智模式更是在最初与人（父母）相处的过程中就萌芽了，可以说，早年的经历在某些方面是我们成年后理解外部世界的样板，我们通过这些经历建立心智模式，并通过心智模式的滤镜审视未知的世界（尽管世界可能早已经跟他们想象中的不一样）。</p>
<p>实际上，所谓的心智模型就是我们的过往经历所形成的一些泛化的模型，以<a href="http://en.wikipedia.org/wiki/Implicit_memory" target="_blank">内隐记忆</a>的形式存在，这些内隐记忆一般不以语言的形式表现出来，而是以情绪的形式，我们往往会感觉到一种不可抗拒的情绪压力，驱使着我们去做（或不去做）某件事情。例如<a href="http://www.amazon.com/Parenting-From-Inside-Daniel-Siegel/dp/1585422959/" target="_blank">《Parenting from the inside out》</a>中的一个故事：一位父亲由于早年当实习医生的时候一段压力极大的儿科护士的经历所形成的心智模式，使得后来他自己成为父亲的时候，一旦宝宝哭，就发现自己情绪仿佛陷入了一个黑洞，无法提供宝宝需要的安慰。</p>
<p>心智模式是一把双刃剑，没有心智模式，我们就没有了理解世界的参照系，但难以改变的错误心智模式会成为我们的心智牢笼，有些心智模式干脆就是<strong>心智黑洞</strong>，什么都无法从中逃逸。</p>
<p><strong>世界上最难以改变的心智模式有两种</strong>：</p>
<ol>
<li><a href="http://en.wikipedia.org/wiki/Self-fulfilling_prophecy" target="_blank"><strong>自我实现的预言</strong></a>：例如：“我就是没有数学天分”。既然自认没有数学天分，那么就不会去花时间钻研数学，自然不会在数学上有所提高，那么结果也就反过来证实了最初的预期，即“我就是没有数学天分”。自我实现的预言是一种非常广泛存在的心智模式，在育儿理论上，有一个大忌就是给孩子这样的观念：智力是天生的。或者通过种种言语让孩子形成这样的观念，例如总是夸孩子<em>聪明</em>，而不是夸他/她<em>努力</em>（<a href="http://www.amazon.com/NurtureShock-New-Thinking-About-Children/dp/0446504122" target="_blank">《NurtureShock》</a>）。因为一旦形成智力天生的观念，孩子就会避开高难度的事情，因为做的不好就会对自尊形成打击（“看来我还是不够聪明”），而不去尝试的话还可以骗骗自己（“我只是不想做罢了”）。而不尝试也就不会有提高，从而在那些他认为自己不够聪明的地方永远也不能“聪明”起来。</li>
<li><strong>无法</strong><a href="http://en.wikipedia.org/wiki/Falsifiability" target="_blank"><strong>证伪</strong></a><strong>的命题</strong>：例如假定别人总是怀着恶意的，恶意这种东西，永远无法证伪，不管别人行为多么看上去没有恶意，你都可以从恶意的角度给出解释，即便没法从恶意的角度进行解释，最不济也可以说别人心里就是怀的就是恶意，只不过行为受到种种其他限制而已。这类心智模式就像<a href="http://www.users.qwest.net/~jcosta3/article_dragon.htm" target="_blank">卡尔·萨根的龙</a>一样，你永远都无法证伪，就像阴谋论永远都有其立足之地一样，除非人类能够直接观察思维。这种心智模式的特点是，无论现实给出的证据如何强，都没法对其构成根本威胁，只要不能百分之百证伪，他就可以选择相信那个他愿意相信的假设。</li>
</ol>
<p>最后，即便不属于上面两类的心智模式，仍然还是难以改变，因为一旦成为了心智模式，便跟情绪挂上了钩，一旦跟情绪挂上了钩，便难以逃脱<a href="http://en.wikipedia.org/wiki/Confirmation_bias" target="_blank">证实偏差</a>的影响，作为情绪大脑的“律师”的理性大脑会忠实地履行律师的义务，为它寻找单方面的证据和解释。（<a href="http://mindhacks.cn/2011/01/23/escape-from-your-shawshank-4/" target="_blank">《逃出你的肖申克（四）：理智与情感》</a>）</p>
<p>某种程度上说，<strong>生活就像是一系列不断进行的微实验</strong>，我们根据所遭遇的现实形成一些假设（观念），然后根据这些假设行事，而我们的行为进而又会触发周遭的反馈，我们于是根据这些反馈再调整自己的观念，这就是<em>一个不断假设检验的过程</em>。遗憾的是，在这个实验面前，有的人是不合格的科学家，因为在实验里面，首先必须提出可证伪的假设（上文的第二点），其次，必须收集两方面的证据（上文第一点），像“我没有数学天分”这种假设，具有这种观念的人根本就不会去收集反面证据，既然没有反面证据，又怎么谈得上推翻呢？这就像一个科学家，盲目地声称一个假设，然后根本连实验都不屑于做就发表了一样。你可能会觉得，拿生活跟科学实验比，具有可比性吗？有。实际上，每个宝宝都是天生的科学家（<a href="http://www.amazon.com/The-Scientist-Crib-Early-Learning/dp/0688177883" target="_blank">《The Scientist in the Crib》</a>），从开始探索环境起就不断地对世界进行着假设检验，我们每个人其实都比你想象得更像科学家，对世界进行着各种猜测与检验，或者说，对于生活，<strong>每个人心中都有一个科学家，只不过有的人比较民科罢了</strong>。</p>
<p>还有一种最常见、也是最重要的情绪陷阱，就是<em>对于负面情绪的下意识回避</em>。据传释迦牟尼曾对众生讲过这样一个寓言，其大意如下：
当一个人被一支箭射中的时候，他其实被两支箭射中，第一支箭就是那支物理意义上的箭，这支箭带来皮肉痛感。而第二支箭则是心理意义上的，其源于你想要回避痛苦的期望跟无法回避的痛苦之现实之间无奈落差带来的“二阶”痛苦（“为什么偏偏是我被射中了呢？真郁闷啊！”）。而这个二阶痛苦才是真正狠的那支箭。其实不仅仅是第二支箭，现实中往往伴随着第三支箭第四支箭第五支箭，一个负面的事件引发情绪系统的雪崩，例如没有赶上deadline，导致担心被老板责怪，导致担心丢掉工作，导致担心还不上房贷，再一念想及那些看上去仕途顺利的当年同学，更是各种情绪纷至沓来。然后由最后两支，也是最狠的两支箭来收尾：1) 对负面情绪本身的负面情绪（“我不想情绪这么糟糕，可是现在情绪却又怎么糟糕，好郁闷啊”）2) 因无法扫除负面情绪而带来的无力感。</p>
<p>村上春树在《我在跑步的时候谈些什么》里也提到，“痛是不可避免的，但苦却是你自己选的”（Pain is inevitable, but suffering is optional）。现代社会中，很少有人会肉体累死（甚至我们还会花钱找累——一种叫做“锻炼”的活动），但有各种烦死，因情绪紧张、压力、焦虑等等而郁闷死，这里的“死”未必是个比喻，因为压力和焦虑的确能够对人的身体造成非常大的伤害，著名生物学家Robert M. Sapolsky就写过一本非常畅销的书<a href="http://www.amazon.com/Zebras-Dont-Ulcers-Third-Edition/dp/0805073698/" target="_blank">《Why Zebras Don’t Get Ulcers》</a>讲压力所带来的种种生理伤害，例如胃溃疡、心血管疾病、免疫系统衰退等等，从生物进化的角度来说，当生物面对需要紧急应对的压力源的时候，符合生存要义的做法就是把身体的能量调集到肌肉上，以应付<a href="http://en.wikipedia.org/wiki/Fight-or-flight_response" target="_blank">fight-or-flight</a>需求，这种时候有些虽长远看重要但不紧急的事情就不可能兼顾了（因为身体能调遣的能量是有限的），例如免疫系统、消化系统、排泄系统等等，极度紧张中甚至连痛感都会暂时关闭（战场之上中枪了还浑然不觉，只觉得肋下忽然一阵麻木，血就流了下来），这里的进化论意义上的原则是很显然的：如果紧急的事情应付不好，可能连明天都没有了，还谈什么免疫消化呢？</p>
<p>那么，我们的身体为了应付紧急情况牺牲那么多是不是值得呢？这里的关键在于，当需要应急的情况并不是很多的时候，这并不构成牺牲，只是<em>暂时</em>关闭消化免疫等等系统，等危机解除了之后身体会立即回复平衡状态。Sapolsky在他的书中想要说明的一点就是，绝大多数其他动物的生活就是这样的：应急是少数情况，大多数时候身体处于平衡状态。然而，人类不一样，人类有一个强大的能力就是能够在大脑中虚拟推演未来，一方面，这种能力带给我们卓越的未雨绸缪的能力，能够远在灾难发生之前就做些什么从而避免灾难，或者做好准备使得当灾难发生的时候的损失降到最低，但另一方面，错综复杂的现代社会也令我们在推演未来的时候有太多需要担心的损失，有太多的事情不受我们的控制。在我们大脑所适应的远古时代（<a href="http://mindhacks.cn/2010/03/18/escape-from-your-shawshank-part3/" target="_blank">《逃出你的肖申克（三）：遇见20万年前的自己》</a>）这一机制是完美的，而在如此复杂的现代社会，它就成了双刃剑。我们的大脑就像一架时光机器，未来可能存在的灾难、过去曾经受到的苦难，穿越到现在，纷至沓来，使得我们在任何一个时间断面都可能承受前后几年跨度之内需要担心的事情，使得我们活在过去活在未来，但惟独不活在现在。</p>
<p>可是，你可能仍然疑惑：我们可以理解在草原上当狮子跑过来的时候，身体调集所有能量应付肌肉的需要是应该的，但是为什么当我们担心考试考砸、丢掉工作、演讲搞砸等等也会带来同样的生理反应呢？这些莫非也需要肌肉来完成吗？情况可能是这样的：<a href="http://en.wikipedia.org/wiki/Evolutionary_psychology#Premises" target="_blank">由于我们的大脑仍然处于石器时代</a>（生物进化的速率远远小于社会进化），而在石器时代，绝大多数问题都是需要武力来解决的，文字的发明是很晚近的事情，相对于人类几十万年的历史，灵长类几千万年的历史而言，只不过是一瞬。在漫长的进化阶梯上，我们的大脑首先需要解决的就是不断出现的生存和繁衍竞争，而这两者都是得靠肌肉的:) 由于我们的大脑还没来得及进化就被带入了现代社会（基因的进化存在显著的<a href="http://www.blackwellpublishing.com/ridley/a-z/Time_lags.asp" target="_blank">时滞效应</a>，其实别说基因了，我们的社会进化得如此之快，以至于连符合拉马克进化的<a href="http://en.wikipedia.org/wiki/Cultural_lag" target="_blank">“文化”都存在时滞效应</a>），所以很多地方我们的语言当中的隐喻也都处处折射出我们的“远古思维”，例如当我们非常想要得到一个东西我们会说“<em>力争</em>”（英文则有&quot;<em>fight for it</em>&quot;，就更形象了），我们也常说“努力”，“用力过猛”、“尽力”等等，而实际上很多时候当我们说这些的时候，我们实际上并不用“力”，而是用“脑”。那么，既然我们的原始大脑遇到任何潜在的负面后果，都会紧张起来做好迎战的准备，而我们的现代理性大脑又会把考试考砸认知为“负面后果”，那么一想到考试考砸就肾上腺激素分泌增加也就不奇怪了，虽然更适应现代社会的大脑显然应该“越重要的考试越冷静”。</p>
<p>其实，所谓情绪的牢笼是一个泛指，情绪的牢笼效应多种多样，例如习惯，为什么习惯难以改变，一个重要的原因是很多习惯往往伴随情绪，想要改变习惯的企图总是撞在负面情绪的南（难？）墙上，而如果对负面情绪没有宽容度，既希望能够按照自己的理性想法去做，同时又希望避免负面情绪。结果只能是发现两者不可得兼，天人交战一番之后往往最终还是情绪说了算。再如<strong>自尊的牢笼</strong>，如果说心智模式是一间屋子，那么自尊就好比是把这间屋子加了一扇无比坚固的铁门，任何企图颠覆原有心智模式的信息都会触发脆弱的自尊，引发内心巨大的反抗情绪，而一来二去由于受不了其他人提供的威胁到自己心智模式的信息，自尊便会逐渐演变成自闭，到这一步便是把铁门又加上了铁锁贴上了封条，而隔绝了外界信息的结果便是，原有的心智模式更加不可能改变了。</p>
<p>情绪的牢笼是最强大的，其强大之处在于，即便你意识到了，也未必能够挣脱它，因为挣脱的过程不可避免会带来负面情绪（情绪大脑就像是一个不听话的孩子，你怎么劝他就是不依不挠），而我们对于负面情绪天然的回避倾向会把我们拉回到顺从的老路上去。到目前为止，心理科学能够给予我们逃出情绪牢笼的最有效的手段有两个，一是改变行为，观念会自动跟上，但如果没有外力的情况下，单凭个人自身的力量先去改变行为相当于是一个先有鸡还是先有蛋的问题。二是改变观念，行为会自动改变。但改变观念说起来容易，做起来真是难于登天。尽管如此，在这方面还是有两派卓有成效的做法，一是对事实<a href="http://en.wikipedia.org/wiki/Cognitive_therapy" target="_blank">重新认知</a>（或者叫“再认知”），二就是当下很火的<a href="http://en.wikipedia.org/wiki/Mindfulness_(psychology" target="_blank">Mindfulness</a>)。后者某种程度上也包含前者。</p>
<p>要理解这两派做法，须首先理解我们的情绪大脑工作的方式，有一个著名的模型叫ABC模型，描述的是情绪产生的过程，首先是A（Activating Event）：即最原始的客观事实，然后是B（Beliefs about the event）：即我们内心的各种内隐的心智模式。最后才是C（Consequence）：即引发的情绪。而我们很多时候只直接体验到C，既看不到原始的事实（A），更觉察不到我们自己的心智模式（B）。</p>
<p>ABC模型描述的是情绪产生之前的事情，那么情绪产生之<em>后</em>呢？负面情绪是一个<a href="http://en.wikipedia.org/wiki/Negative_feedback" target="_blank">负反馈系统</a>，<em>其产生的目的就是要驱使你去做点什么从而消除它</em>。所以负面情绪具有强大的<em>执行力</em>。我们不妨把这最后一步称为D（Drive）。于是我们得到一个完整的链条：ABCD。</p>
<p>“再认知”方法着眼于环节B，其逻辑是这样的：既然情绪的产生是<em>心智模式作用于现实</em>的结果，那么改变心智模式，也就从根本上杜绝了负面情绪的产生，属于防火型策略。再认知在很多时候是非常有用的，因为很多事情确实可以从不同的角度去看，例如你一想到房价这么高就恨不能省下每一分钱（《蜗居》中海萍同学的做法），你也可以一想到房价这么高，再怎么省也是杯水车薪，还不如好好对待自己明天去买个iPhone，反正相比于高房价而言什么东西都不显得那么贵了。</p>
<p>而Mindfulness的理念就更微妙了，这是一门非常古老的思维技术，源于佛教，但正在跟现代心理学和神经科学结合并产生像<a href="http://en.wikipedia.org/wiki/Mindfulness-based_stress_reduction" target="_blank">MBSR</a>和<a href="http://en.wikipedia.org/wiki/Mindfulness-based_cognitive_therapy" target="_blank">MBCT</a>这样对日常心智成熟非常有效的技术：神经科学家们发现长期冥想训练的喇嘛们的大脑中的神经回路产生了一些永久性的变化，使得他们更能够让自己的情绪大脑平静下来。Mindfulness很多时候着眼于D环节，即虽然负面情绪已经产生了，但我们可以训练自己对负面情绪的<em>宽容度</em>（佛教将之称为<em>慈悲心</em>，现在一些文艺化的Mindfulness书籍则将之称为对自己要有<em>柔软的心</em>），从而让自己不像拉磨驴一样被它驱使着走。Mindfulness经常用像这样的隐喻来描述我们的意识跟情绪的关系：情绪就像是一场忽如其来的大雨，我们的本能总是赶紧找个屋檐躲起来，而Mindfulness训练的目的就是要让我们能够安然地走在雨中。佛教古老的智慧当中，有“妄念”这一说法，<em>这一说法跟现代心理学所说的心智模式其实非常接近</em>，正如科学家们所领悟到的：<strong>所有模型都是错的，只不过有些模型更错</strong>。心理学家们也逐渐认识到：<strong>所有心智模型也都是错的，只不过有些心智模型让你更苦逼</strong>。而妄念的说法正符合这一要旨，你所感知到的情绪乃是你自己都未必知道其对错的心智模式所带来的结果。而通过训练对负面情绪的宽容度，我们便能够逐渐不为这些念头所驱使，而是能够比较平静地看着情绪来来去去。对此也有人用这样一个隐喻：你的意识是一个空屋子，而来来去去的情绪则是到来的客人，客人会不期而至也会离去。或者这样一个意向：情绪就像一波一波的浪潮，你是冲浪者，而浪尖总会过去。由于对Mindfulness这一古老技术的研究才刚刚开始（<a href="http://www.amazon.com/Buddhas-Brain-Practical-Neuroscience-Happiness/dp/1572246952/" target="_blank">《Buddha’s Brain》</a>），所以Mindfulness相关的书仍然只能大量使用隐喻来传达一些微妙的含义。</p>
<p>但是，不管是再认知还是Mindfulness，都不是速效药，心智模式不仅隐蔽，而且有情绪作后台，特别强大，所以心智成熟必然是一个长期的过程，既需要知识，也需要耐心。借用软件工程的一句话就是“没有银弹”。</p>
<p>罗素曾经说过，“我是不会为信仰而死的，因为万一我错了怎么办？”对于我们的（负面）情绪，我们也应是类似的态度，既然我们那么讨厌负面情绪，唯恐避之而不及，那么就应该不要动不动就调动负面情绪，因为，万一我错了怎么办（岂不是白白(生气|郁闷|焦虑|担心|etc.)了么）？别忘了<strong>在事实和情绪之间，潜藏着纷繁复杂而隐蔽的心智模式，他们就像暗物质一样，看不见摸不着，但对你的行为产生巨大的引力。</strong></p>
<p><a href="http://mindhacks.cn/wp-content/uploads/2012/06/road-less-traveled.jpg" target="_blank"><img src="&quot;road-less-traveled&quot;" alt="road-less-traveled"></a></p>
<p>写到这里发现已经太长了，只能分成上下两部分了，下部分打算写一写“认知的牢笼”、“知觉的牢笼”、“习惯的牢笼”和“个体经验的牢笼”。文中提到的链接，可以集中参照我的豆列：<a href="http://book.douban.com/doulist/46003/" target="_blank">【只读经典】思维改变生活</a>，<a href="http://book.douban.com/doulist/1327794/" target="_blank">【只读经典】育儿即育己</a>。
来源： <a href="[http://mindhacks.cn/2012/06/04/escape-from-your-shawshank-part5-the-invisible-cage/](http://mindhacks.cn/2012/06/04/escape-from-your-shawshank-part5-the-invisible-cage/)">[http://mindhacks.cn/2012/06/04/escape-from-your-shawshank-part5-the-invisible-cage/](http://mindhacks.cn/2012/06/04/escape-from-your-shawshank-part5-the-invisible-cage/)</a> </p>
<ul>
<li>tangkai</li>
</ul>
<p>能一直坚持写出这么好的博客，很敬佩。一直在学习中。</p>
<p>2012年6月4日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="loyi"></li>
</ul>
<p>loyi</p>
<p>敬佩已久，没想到今天到来就更新了。</p>
<p>2012年6月4日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="yuhao"></li>
</ul>
<p>yuhao</p>
<p>银行抢劫录像那个例子，前后者写反了？</p>
<p>2012年6月5日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="木叶下"></li>
</ul>
<p>木叶下</p>
<p>很精彩,一口气读完了,对很多事情很有指导意义
觉得应该分享一些育儿的经验,估计会很有启发意义</p>
<p>2012年6月5日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="Mist"></li>
</ul>
<p>Mist</p>
<p>逃出你的肖申克这个系列很不错，我有个建议，这个系列其实我觉得配合之前学习方法的博文效果更好，这样我觉得使文中推荐的书能起到更大的作用，可以考虑吧之前的学习方法的文章放到文章结尾试试。</p>
<p>2012年6月5日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="woo-nuo"></li>
</ul>
<p>woo-nuo</p>
<p>做好人生的实验ing~</p>
<p>2012年6月5日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="摩卡"></li>
</ul>
<p>摩卡</p>
<p>有些实验以前读到过，现在再看才发现自己全忘干净了。</p>
<p>2012年6月5日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="liulei"></li>
</ul>
<p>liulei</p>
<p>敬佩，博主那篇贝叶斯我看了好长时间……</p>
<p>2012年6月5日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://www.itingting.com/" title="想买橘子" target="_blank"><img src="" alt="想买橘子"></a></li>
</ul>
<p><a href="http://www.itingting.com/" target="_blank">想买橘子</a></p>
<p>赶上了楼主的最新一篇，哈哈。不错，先留个言再看。
楼主的这个系列都非常不错，受楼主的启发，我也在研究神经学之类的东西，确实收益颇丰。</p>
<p>2012年6月5日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://www.pureage.info/" title="strider" target="_blank"><img src="" alt="strider"></a></li>
</ul>
<p><a href="http://www.pureage.info/" target="_blank">strider</a></p>
<p>刘未鹏的博客真是价值博客,慢功出细活.</p>
<p>2012年6月5日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://xbeta.info/" title="善用佳软" target="_blank"><img src="" alt="善用佳软"></a></li>
</ul>
<p><a href="http://xbeta.info/" target="_blank">善用佳软</a></p>
<p>勘误：The Invisible Gorilla 节中：案例描述段与结论段的“前一组/后一组”排序，似乎反了。</p>
<p>2012年6月5日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://weibo.com/pongba" title="刘未鹏pongba" target="_blank"><img src="" alt="刘未鹏pongba"></a></li>
</ul>
<p><a href="http://weibo.com/pongba" target="_blank">刘未鹏pongba</a></p>
<p>谢谢xbeta。已订正。</p>
<p>2012年6月5日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://xbeta.info/" title="善用佳软" target="_blank"><img src="" alt="善用佳软"></a></li>
</ul>
<p><a href="http://xbeta.info/" target="_blank">善用佳软</a></p>
<p>观点补充。Sway一节：心理学家认为是“错误归因”，其隐含的假设是——在桥上与遇到女助手，是两个平行、独立事件。试验者误把在桥上的反应，当作遇到女士的反应。但此两件事件不是互相影响的吗？从约会结果来看，在桥上是一个环境事件，强化了遇到女士的反应；或者说提升了受试者的敏感度，从而让女助手留下了更深好感。</p>
<p>2012年6月5日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="kk"></li>
</ul>
<p>kk</p>
<p>这实验其实有个漏洞，就是选择走桥上的人可能通常是比较喜欢冒险的人.....</p>
<p>2012年6月29日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://xbeta.info/" title="善用佳软" target="_blank"><img src="" alt="善用佳软"></a></li>
</ul>
<p><a href="http://xbeta.info/" target="_blank">善用佳软</a></p>
<p>“据传释迦牟尼曾对众生讲过这样一个寓言，其大意如下…… ” 是否为佛祖所说，略存疑，求出处。
自己感觉，Viktor Frankl 在集中营苦难中感悟到的 人类终极的自由 (the last of the human freedoms) 也是一个极好的佐证。他明白了这个自由，便不再受后续N重苦。</p>
<p>2012年6月5日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://xbeta.info/" title="善用佳软" target="_blank"><img src="" alt="善用佳软"></a></li>
</ul>
<p><a href="http://xbeta.info/" target="_blank">善用佳软</a></p>
<p>进一步搜索了一下，中英文皆有如此说法，但都是以故事流传，并无具体经卷出处。
或许不应该太执着于相。</p>
<p>2012年6月5日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://www.the5fire.net/" title="胡阳" target="_blank"><img src="" alt="胡阳"></a></li>
</ul>
<p><a href="http://www.the5fire.net/" target="_blank">胡阳</a></p>
<p>又是一篇很长很经典的文章，对人类本身的认知是任何学问最本质的基础</p>
<p>2012年6月5日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="Fey"></li>
</ul>
<p>Fey</p>
<p>一直对佛教的修炼模式对大脑的影响感兴趣
现在居然有了科学研究了 <img src="&quot;:-" alt=":-)">&quot;)</p>
<p>2012年6月5日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://www.thoughts-of.me/" title="t.k." target="_blank"><img src="" alt="t.k."></a></li>
</ul>
<p><a href="http://www.thoughts-of.me/" target="_blank">t.k.</a></p>
<p>受益了，留个名。。</p>
<p>2012年6月5日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="liang"></li>
</ul>
<p>liang</p>
<p>Thanks a lot.</p>
<p>2012年6月5日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://www.eaglefantasy.com/" title="Eagle_Fantasy" target="_blank"><img src="" alt="Eagle_Fantasy"></a></li>
</ul>
<p><a href="http://www.eaglefantasy.com/" target="_blank">Eagle_Fantasy</a></p>
<p>写的太赞了~！</p>
<p>2012年6月5日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="liang"></li>
</ul>
<p>liang</p>
<p>”由此可见这是一个在两个需求之间去的平衡的动态控制系统。 “
这里有个错字。 ^取得</p>
<p>2012年6月5日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="贝贝"></li>
</ul>
<p>贝贝</p>
<p>非常好的博客，一直都关注。每一次看都觉得是自己解剖自己的时候，那么透彻！你对心理学的认识不仅深刻，而且能够言简意赅说明现实问题，佩服！也向上面一位读者说的一样，希望你也写点“育儿”的内容吧。</p>
<p>2012年6月5日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://www.felix021.com/" title="felix021" target="_blank"><img src="" alt="felix021"></a></li>
</ul>
<p><a href="http://www.felix021.com/" target="_blank">felix021</a></p>
<p>非常感谢刘同学的这一系列文章，受益匪浅。
看完后发现两个错字，建议修改：
当物质奖励和兴趣同事（同时）存在
或者这样一个意向（意象）：情绪就像一波一波的浪潮</p>
<p>2012年6月5日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://www.itingting.com/" title="想买橘子" target="_blank"><img src="" alt="想买橘子"></a></li>
</ul>
<p><a href="http://www.itingting.com/" target="_blank">想买橘子</a></p>
<p>勘误：（小瑕疵，其实不足为道）最后一句：在事实和情绪之间，潜藏着纷繁复杂而隐蔽的心智模式，他们就像暗物质一样，看不见摸不着，但对你的行为产生巨大的引力。
他们-&gt;它们，但对你的行为产生巨大的引力-&gt;却能对你的行为产生巨大的引力。</p>
<p>2012年6月5日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://cnlox.is-programmer.com/" title="xiaohanyu" target="_blank"><img src="" alt="xiaohanyu"></a></li>
</ul>
<p><a href="http://cnlox.is-programmer.com/" target="_blank">xiaohanyu</a></p>
<p>慢工出细活，等了这么久，博主终于又更新了。</p>
<p>2012年6月5日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://weibo.com/pongba" title="刘未鹏pongba" target="_blank"><img src="" alt="刘未鹏pongba"></a></li>
</ul>
<p><a href="http://weibo.com/pongba" target="_blank">刘未鹏pongba</a></p>
<p>谢谢 @felix @橘子 @xiaohanyu @liang 各位的勘误，等几天我一并更正（现在豆瓣9点RSS抓取似乎出了点问题，一更新之后最新文章就从列表里消失了）</p>
<p>2012年6月5日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://weibo.com/runningwaterpro" title="李二嫂的猪" target="_blank"><img src="" alt="李二嫂的猪"></a></li>
</ul>
<p><a href="http://weibo.com/runningwaterpro" target="_blank">李二嫂的猪</a></p>
<p>刚刚看完第一节，太精彩了……</p>
<p>2012年6月5日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="Mong"></li>
</ul>
<p>Mong</p>
<p>“而Mindfulness的理念就更微妙了，这是一门非常古老的思维技术......使得他们更能够让自己的情绪大脑平静下来。” 看到这段我想起一本书《箭术与禅心》，讲的是一个哲学博士在日本通过学习箭术悟出了“只可意会不可言传”的禅道。看他禅悟过程的经历和体会，还是或多或少可以“意会”出点东西的，不像大量的隐喻那样难理解。虽然跟Mindfulness方法不同但是我感觉他们的目的和结果都是相同的。推荐看一看。</p>
<p>2012年6月5日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="雅讶"></li>
</ul>
<p>雅讶</p>
<h2 id="-">这种“蹦出来”效应是一种自动的、自下而上的效应，你没法用意志去“抑制”它</h2>
<p>这里自下而上的效应，是不是应为 自上而下？？自上而下对应着自动加工，自下而上对应着的为自下而上的加工</p>
<p>2012年6月5日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="空山"></li>
</ul>
<p>空山</p>
<p>所有植物都需要水，玫瑰需要水，所以玫瑰是植物。 有点像玩文字游戏
其实早已有的知识,并且共识,
其实我最近在想的一个问题和你的中心观点一样,只是你比较细化了
我的观点是,人的判断是没有根据的,他根据的是他的根据,而非宇宙的根据.
email</p>
<p>2012年6月6日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="ivan"></li>
</ul>
<p>ivan</p>
<p>一直关注刘老师的博客，虽然更新很慢，但篇篇都是精品！
无意间发现了这次的更新，还未来得及仔细阅读，喜悦之情溢于言表！</p>
<p>2012年6月6日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="lvlvbuaa"></li>
</ul>
<p>lvlvbuaa</p>
<p>终于更新了啊！！！！！！</p>
<p>2012年6月6日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="corner"></li>
</ul>
<p>corner</p>
<p>pongba的文章总是很耐读，看了第一遍，说几点：
1、“Some Things Are Better Left Unsaid”那个抢银行的例子后面pongba为什么要写上前后两个字然后分别划掉一个？有什么特殊的目的吗？
2、依恋理论中矛盾型的情况，孩子是希望惩罚父母以减少父母离去的概率才伤害反抗父母吗？根据个人理解，有没有可能是因为内心假设父母很可能随时离去，惧怕再次受到伤害所以下意识地不想跟他们太好来减少下次他们离去时自己的难过？
3、关于知识的诅咒问题，想起以前看过《犹太人思考术》中的那句“我们都是大脑的奴隶却甘之如饴”，pongba用大量的实验和图例把这个问题解析地很形象，但有时又难免有无力感：我们这种追求打破牢笼的行为，本身也在我们自身思维的牢笼中进行的，我们又怎么判断我们是不是真的跳出了自己的牢笼？或许没有打破牢笼的人，有的只是比别人看到更多牢笼外风景的努力罢了。
另外由于信仰的原因（基督徒），有些观点理解起来有点困难，过阵子来看第二遍的时候看看有没有更多收获。
PS：这篇文章育儿的例子明显多了，看得出pongba为孩子付出的苦心呢，祝小家伙一切都好</p>
<p>2012年6月7日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://weibo.com/pongba" title="刘未鹏pongba" target="_blank"><img src="" alt="刘未鹏pongba"></a></li>
</ul>
<p><a href="http://weibo.com/pongba" target="_blank">刘未鹏pongba</a></p>
<p>谢谢corner，我只能回答前两个问题，呵呵:) 1. 那个是勘误更正。划掉的是原文。2. 据我所知两者可能都有。</p>
<p>2012年6月7日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="apdiagm"></li>
</ul>
<p>apdiagm</p>
<p>想问下pongba，对你的妻子你会要求她跟你一样对生活有那么多深刻的思考吗？你觉得这个重要吗？万分抱歉这个问题问的过于隐私，但我真的很想知道你对这个问题的看法。如果可以的话，给我回封邮件好吗？如果你觉得不方面答也没有关系。谢谢！</p>
<p>2012年6月7日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://www.zzinit.com/" title="ZZ" target="_blank"><img src="" alt="ZZ"></a></li>
</ul>
<p><a href="http://www.zzinit.com/" target="_blank">ZZ</a></p>
<p>我说，那个育儿的豆列太长了...精选两本给我这个苦逼当爹的吧。 -ZZ</p>
<p>2012年6月7日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://weibo.com/pongba" title="刘未鹏pongba" target="_blank"><img src="" alt="刘未鹏pongba"></a></li>
</ul>
<p><a href="http://weibo.com/pongba" target="_blank">刘未鹏pongba</a></p>
<p>一本国外的翻译本，一本国内的：《教养大震撼》、《好妈妈胜过好老师》 <img src="&quot;:" alt=":)">&quot;) 不过我觉得你不需要，有的人育儿就是有正确的直觉，你就是其一。别看了书反而迷茫了啊:P</p>
<p>2012年6月7日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://www.zzinit.com/" title="ZZ" target="_blank"><img src="" alt="ZZ"></a></li>
</ul>
<p><a href="http://www.zzinit.com/" target="_blank">ZZ</a></p>
<p>谢咯！</p>
<p>2012年6月11日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="Sexymind"></li>
</ul>
<p>Sexymind</p>
<p>嗨，我的朋友。我自今年四月开始阅读你的书籍《暗时间》，从此一发不可收拾。基于原来对生活的思考和感悟，我在读你写的书时，和你有太多的共鸣。并在旁边记录了大量的感想和读书笔记，以及一些对于一个话题的补充，很有收获。谢谢你带给我的精彩。自此我也开始写博客，想法很多。但是由于某些原因目前只写了一篇。假期我会有更多的书写和记录。我想在这里把它复制过来让你看看，算是一种交流吧。作为一个大二的学生，能结识到你这位朋友，受益匪浅。下面是我写的文章：
. 持之以恒才会有结果 
忍耐和坚持虽是痛苦的事情，但却能渐渐地为你带来好处。——奥维德，古罗马诗人 坚持，似乎是我们从小喊到大的口号。并且被我们广泛的运用到生活的方方面面。校运会上的播音员会为即将冲过终点的运动员大喊：“加油啊，坚持！胜利是属于你的！” ；高三的学生听到最多的一句话想必应该是“坚持就是胜利” ；化妆品导购会甜美的对你说：“坚持用就有效果啦！” 。然而作为一个学生，我最常听到的关于坚持的话是被用在五花八门的学习方法上，每一种看似是新出炉的XX学习法，都告诉你要坚持下去才会收到成效。为什么我说是看似新出炉呢，因为这些方法都有一个换汤不换药的本质：需要坚持。
但是，又有多少人真正吃过坚持到底的甜果呢？
关于方法论
很多时候我们都以为方法很重要，于是为了达到目标或者为了获取理想的结果，我们总在乐此不疲的寻找最好的方法，探求A到B的最优途径，更换之前使用的方法。忙碌的像一只旋转的陀螺。可怕的是，我们还沾沾自喜的以为自己在充实度日。
方法真的有那么重要吗？下面先简单跟大家分享一下两个关于我的小故事：第一个是关于学英语的故事：小的时候老妈早早就把我送去学英语，那时候什么都不懂，市面上也没有五花八门的学习方法和教材。老妈只是让我听着磁带一遍一遍的跟着原声念课文，同时把声调标出来，然后把课文背给她听。那时候以为学英语就是这样，天天如此照做，有时候为了等老妈回家“验收” ，都差点要头悬梁了。从幼儿园大班开始，一路学下来，小学开始在少年宫一学就是七年。也没想那么多，觉得报了班就一定要去，所以不管风吹雨打电闪雷鸣，只要到了上课时间就一定会准时到。于是我的英语慢慢的居然就比别的孩子要学的好了，语感就是在那时候培养起来的。后来上初中高中一点都没学过英语，单词语法碰都没碰，靠着吃老底也混了出来。第二个是练习打字：家里刚有电脑的时候，老妈利用我的好奇心教我练打字，我记得很清楚：她先从网上调了正确的指法说明让我看，然后又找了一些英语文章，让我用正确的指法跟着打出来。剩下的就是天天中午放学回家吃过饭后坐在电脑前不停的练指法。慢慢的我可以不看键盘打字了。熟练之后老妈对我狡黠一笑说有个游戏。那是一款专门练速度的游戏。我一下子来了兴趣，乐此不疲的玩那个游戏，有时候水平上了一个台阶的时候还把老妈老爸一起拉过来玩，测试我们三个的速度。于是我的盲打就这么练成了。到现在都是我的一大优势。
我们再问一遍自己：方法真的有那么重要吗？在信息还尚不发达的时候，在物质条件还没这么优越的年代里，学习方法单一的厉害，为什么也有那么多人获得了成功？文革时期的人们，只有那么几本教科书，但是他们天天捧着读，一种方法坚持到底，却能够在恢复高考的时候金榜题名。我不禁想，有时候方法太多会让人迷乱，尤其在当下，有太多太多的选择，于是我们总是不断的重复做一件事：找到新方法，换掉旧方法。可是过了一段时间就会发现，我们总是在原地打转。我们在各种方法之间不停的转换，于是时间就被这样浪费掉了。相反如果摆在你面前的方法少的可怜，没有多余的选择，那么剩下的就是坚持。于是在我们心里，需要有一个过滤器，把除过自己目前正在使用的方法都过滤掉，统统忽视。请相信，只要你选的方法不是太不靠谱，坚持一条道走到底，就会好的。关于学习，李笑来老师说，最好的途径就是策略和坚持，而坚持本身就是最好的策略。其实不管学哪一样东西，方法永远就那么几个，简单的可怕。因为这些方法我们都知道，可是我们缺乏坚持，所以连成功的尾巴都没摸到过。
有人会说，努力不一定有结果啊。的确如此。但是，你先问问自己，你学的是前所未有的东西吗？如果不是，那我想你应该走的是一条大多数人都走过的路。很多时候的努力无果，其实只是我们在遇到困难的时候选择了退缩。我们总把困难无数倍的放大，为自己的懒惰找借口，认为自己遇到的困难前无古人后无来者，然而事实证明，我们孤单的机会很少。无数次，我们在困难面前低头、逃避。如果肯稍微花一点心思，如果肯把放大困难的时间稍微抽出来一点点，我们就不难发现，绝大多数人都面临过这样的境地。网络信息发达的一个好处就在于：我们可以把自己的问题丢给别人解决。换句话说就是，我们可以把自己当前遇到的困难通过利用他人的经验和智慧而得到解决。而且让你足不出户，不花一分钱（当然有些提问需要各种金币的除外），就能在最短的时间里获得最多、最有效的解决途径。绝对的多、快、好、省。除此之外，解决困难还有一点要注意, 就是有必要了解一下你的困难到底有多困难，是否值得你放弃。不妨从一下几个方面去考虑：身边有没有可以利用的资源去解决、大概要分那几个步棸，需要多久才能得到解决，以及是否可以借鉴他人的经验智慧。
关于兴趣论
我们受过的很多教育都灌输了一个这样的观念：兴趣很重要。的确如此。兴趣可以让人打心底里迸发出对某一种事物的热爱，能够大大提高我们学习的效率和专注力。但是兴趣绝对不是最重要的。很多大学生常说其实自己一直喜欢的是某某专业，要是当初能被分到那个专业，现在不知道学的有多好。其实在我看来，这只是对现状的一种开脱。很多时候对一件事情感兴趣，抱着很大的热情，往往是因为我们还没有真正涉足这个领域。等可以学习自己喜欢的东西了，过了段时间后却遇到了困难，遇到了瓶颈，而往往热情也没当初那么炽烈的时候，很多人就会选择放弃，然后美其名曰：这不适合我。每个领域，不是你对它感兴趣就能一帆风顺的，总会遇到各种各样的困难，可是很多人都退缩了。其实维持事情发展的，还是靠坚持。成功的人和无果的人区别在于是否有把事情做到底的毅力。不管你学的什么专业，只要坚持做，就能做好，即便是在一个毫不感兴趣的领域。这个年代的技能五花八门，行业多的像天上的繁星，最不缺的就是兴趣。然而一切都是贵在坚持。更何况，当你把一项技能掌握好了以后，你会自然而然对它产生兴趣，而且越做越喜欢。
速成班响应了这个浮躁的年代
自从人类跨入工业革命的时代，就一下子加快了社会发展的步伐。每一项新技术的诞生，都意味着效率的提高。随着效率的提高，人们的生活压力也越来越大，因为和过去相比，要在相同的时间内做更多的事情，而且要做的更好。于是时间就变得越来越宝贵，以至于人们天天都在说：Time is money. 时间成为了这年代的宠儿，金贵的要命，人们开始用各种各样的方式来节约时间。嫌火车慢就有了高铁，嫌开会碰面耽搁时间就有了网络会议，没多少时间吃饭就有了快餐……凡此种种，举不胜举。于是人们在有了学习需求但缺乏学习时间的时候，各种各样的速成班便如雨后春笋般蹦跳着来到了我们面前。可是在进行了一场价格不菲的投资并且投入了一段时间、精力以后，绝大多数人并没有速成。原因何在？因为速成班教的方法也是需要时间和毅力来不断练习掌握的。学一项技能的时候，我们总是希望自己能够很快收到成效。如果学习是如此容易的一件事情，又谈何坚持呢？我们总是无法将自己那颗浮躁的心沉静下来。因此速成班才会如此满足人们的需求。有句话叫，欲速则不达。不管是学习一项技能也好，一门知识也罢，永远都离不开坚持。而坚持本身就是一个漫长的过程。
坚持，意味着要经得起困难的挑战，要有足够的耐心面对无止境、枯燥乏味的练习，要有信心面对看似毫无进展的瓶颈期，还要静得下那颗浮躁的心。坚持是不容易做到的，可是一旦做到了，你就碉堡了。:-) <img src="&quot;:-" alt=":-)">&quot;) <img src="&quot;:-" alt=":-)">&quot;) 
注意：当然，坚持的前提是明白你的问题关键所在。只有找准了自身的问题，打开这个缺口，才能运用有效的对策。否则会很费力气。就像我学英语，其实单词就是我的瓶颈，导致阅读文章的能力很有限。但是当我还没真正意识到这一点的时候，却一直在搞什么快速阅读，其实快速阅读也要建立在理解文章的基础上才好提高速度。因此在读不懂的基础上不停的换方法，所以可想而知我费了多少力。功夫好的人，就是随便给他个道具，他都能运用自如。而手无缚鸡之力的人，认识不到问题的关键，就是给他再好的经验都会失败。当自己明白了问题所在之后，自然就知道怎么去做了。剩下的就是不断的坚持。
祝大家在坚持的道路上越走越顺畅！</p>
<p>2012年6月10日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://weibo.com/pongba" title="刘未鹏pongba" target="_blank"><img src="" alt="刘未鹏pongba"></a></li>
</ul>
<p><a href="http://weibo.com/pongba" target="_blank">刘未鹏pongba</a></p>
<p>谢谢你认真的回复:) 开个博客吧</p>
<p>2012年6月18日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="Sexymind"></li>
</ul>
<p>Sexymind</p>
<p>开了，在豆瓣网上开了个小站，叫原来要这样想。期待你的关注。</p>
<p>2012年6月19日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="leeloo"></li>
</ul>
<p>leeloo</p>
<p>很不错的文章，尤其看到ABC模型，突然想到自己是心理学科班出身的学生，只是繁琐杂事忘记了这些严密的逻辑带给生活的惊喜。加油！</p>
<p>2012年6月11日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="Sexymind"></li>
</ul>
<p>Sexymind</p>
<p>呜呜，期待你的回音啊，我好想通过我写的东西跟你交流。。</p>
<p>2012年6月11日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="RaySaint"></li>
</ul>
<p>RaySaint</p>
<p>看了博主的这篇文章获益匪浅啊，和其中的很多内容都产生了共鸣</p>
<p>2012年6月12日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="Albert"></li>
</ul>
<p>Albert</p>
<p>您好.我是一名大二的学生. 非常喜欢你的博客.看您的博客好久了.你的&lt;&gt;看过后很有感触. 刘老师,:)你的心理学豆列,看后非常喜欢,现在在不断的阅读(希望能紧跟你的脚步呵呵) 李笑来老师通过 &quot;想明白&quot;,指点众人的迷惑.而您则让大家逃出自己的&quot;肖申克&quot; . 在这里我想问一下,刘老师.我读您和李老师等博客很久了. 自己感觉却没有很好的吸收您的东西,使自己提高.我该怎么做,才能不陷入&quot;泛泛只读&quot;的困境. 请刘老师指教:)</p>
<p>2012年6月13日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://viaxl.com/" title="Viaxl" target="_blank"><img src="" alt="Viaxl"></a></li>
</ul>
<p><a href="http://viaxl.com/" target="_blank">Viaxl</a></p>
<p>右上有神牛的书单，想看原版的话买个kindle，淘宝有4块钱一本的盗版ebook :O</p>
<p>2012年6月14日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://viaxl.com/" title="Viaxl" target="_blank"><img src="" alt="Viaxl"></a></li>
</ul>
<p><a href="http://viaxl.com/" target="_blank">Viaxl</a></p>
<p>看不到狗什么水平。</p>
<p>2012年6月14日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://viaxl.com/" title="Viaxl" target="_blank"><img src="" alt="Viaxl"></a></li>
</ul>
<p><a href="http://viaxl.com/" target="_blank">Viaxl</a></p>
<p>看完了，好看！别偷懒快写下篇啊！</p>
<p>2012年6月14日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://viaxl.com/" title="Viaxl" target="_blank"><img src="" alt="Viaxl"></a></li>
</ul>
<p><a href="http://viaxl.com/" target="_blank">Viaxl</a></p>
<p>仔细看的话狗里有只面向观众的浣熊类似物.. 嗯, 我先看到浣熊的, 我一定是坏了</p>
<p>2012年6月14日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="Z_Q_D"></li>
</ul>
<p>Z_Q_D</p>
<p>刷屏吗这是</p>
<p>2012年6月20日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://viaxl.com/" title="Viaxl" target="_blank"><img src="" alt="Viaxl"></a></li>
</ul>
<p><a href="http://viaxl.com/" target="_blank">Viaxl</a></p>
<p>你对刷屏的理解还真是天真。</p>
<p>2012年6月20日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://www.mall2china.com/" title="luoochaoo" target="_blank"><img src="" alt="luoochaoo"></a></li>
</ul>
<p><a href="http://www.mall2china.com/" target="_blank">luoochaoo</a></p>
<p>学长终于更新了，这篇博文太深了，读了好几遍。人脑、思维、情绪真是最奇妙的系统。</p>
<p>2012年6月15日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://wenshanren.org/" title="任文山" target="_blank"><img src="" alt="任文山"></a></li>
</ul>
<p><a href="http://wenshanren.org/" target="_blank">任文山</a></p>
<p>好长的更新间隔啊，但写的很棒，颇有收获。
我对Mindfulness那块儿挺感兴趣的，对我而言是很新奇的东西，能推荐些这方面的文章么？paper或是科普类的都可以。</p>
<p>2012年6月18日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://imlcl.com/" title="slackcode" target="_blank"><img src="" alt="slackcode"></a></li>
</ul>
<p><a href="http://imlcl.com/" target="_blank">slackcode</a></p>
<p>好久没更新过，写得很用心</p>
<p>2012年6月19日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://yuhaitao.com/" title="海涛" target="_blank"><img src="" alt="海涛"></a></li>
</ul>
<p><a href="http://yuhaitao.com/" target="_blank">海涛</a></p>
<p>数年磨一剑，佩服！</p>
<p>2012年6月27日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="kk"></li>
</ul>
<p>kk</p>
<p>看到更新了灰常激动！
我觉得mindfulness的作用应该是让你去意识到和感受到体内的负面情绪，去接受它，而不是去抵制它。
另外我想知道刘老师是否对内在动机和激励有所研究呢，如果有的话，希望你下一个博客中提到一些相关内容。</p>
<p>2012年6月29日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="xiaodai"></li>
</ul>
<p>xiaodai</p>
<p>对我来说有点深奥了，呵呵……看几遍才勉强意会博主的思想。</p>
<p>2012年6月29日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://blankyao.com/" title="blankyao" target="_blank"><img src="" alt="blankyao"></a></li>
</ul>
<p><a href="http://blankyao.com/" target="_blank">blankyao</a></p>
<p>这个有点《盗梦空间》的意思了，哈哈</p>
<p>2012年7月1日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="qumino2"></li>
</ul>
<p>qumino2</p>
<p>所以说一定要带女朋友去走个独木桥 走个钢丝 蹦个极什么的！</p>
<p>2012年7月7日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="Jimmy"></li>
</ul>
<p>Jimmy</p>
<p>文章写得真好，佩服博主深刻的思考能力和如花妙笔！
纠正一个小错误：自由落体的思想实验应该是伽利略提出的，不是爱因斯坦。</p>
<p>2012年7月11日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://weibo.com/pongba" title="刘未鹏pongba" target="_blank"><img src="" alt="刘未鹏pongba"></a></li>
</ul>
<p><a href="http://weibo.com/pongba" target="_blank">刘未鹏pongba</a></p>
<p>恩，但文中说的是爱因斯坦的电梯实验，不是伽利略的两个小球同时落地的思想实验哦。</p>
<p>2012年9月12日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="rubber soul"></li>
</ul>
<p>rubber soul</p>
<p>这个系列，感觉这篇写的尤其好，最后形成了比较成型的结论。也许我感觉它【好】的情绪也来自于对【系统性】偏爱的心智模式。
可惜没时间去看那些原著啊，郁闷，接连中箭中。。。</p>
<p>2012年7月13日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://weibo.com/pongba" title="刘未鹏pongba" target="_blank"><img src="" alt="刘未鹏pongba"></a></li>
</ul>
<p><a href="http://weibo.com/pongba" target="_blank">刘未鹏pongba</a></p>
<p>谢谢，我也在不断的改进写作风格 <img src="&quot;:" alt=":)">&quot;)</p>
<p>2012年9月12日<a href="">回复</a><a href="">顶</a><a href="">转发</a><a href="">举报</a></p>
<ul>
<li><img src="" alt="eureka"></li>
</ul>
<p>eureka</p>
<p>非常敬佩你多年坚持写这么好的博客，但是非常遗憾的是我竟然没完成这一篇博客的阅读（在还有1/10的时候直接看评论了），这就是差距啊</p>
<p>2012年7月15日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://www.nbdc56.com/" title="宁波物流公司" target="_blank"><img src="" alt="宁波物流公司"></a></li>
</ul>
<p><a href="http://www.nbdc56.com/" target="_blank">宁波物流公司</a></p>
<p>博客不错，很用心的博主，关注与学习中！谢谢</p>
<p>2012年7月22日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="rubber soul"></li>
</ul>
<p>rubber soul</p>
<p>再来复习了一下
关于ABC模型
因为我是做物理研究的，我觉得A到B的过程并不简单。
有些Activation event只靠简单的原始认知就能理解，比如别人的表情、动作、情绪，这些可算是先天本能或者后天习得的条件反射
而现代社会许多复杂的情形，A激发B的过程是需要思考才能产生的，当你不能判断event的reality是怎么样时，只会产生疑惑，A就不是一个有效输入了。而更多的情况，尤其是不理智的情形下，会发生误判，产生很多不必要的误会，继而产生策略上错误的B,C,D。
所以冷静、理性的思考，就如博主所说的意思，才是现代人类应该保持的习惯，避免原始大脑在ABCD整过程上开玩笑</p>
<p>2012年7月24日<a href="">回复</a><a href="">顶</a><a href="">转发</a><a href="">举报</a></p>
<ul>
<li><a href="http://weibo.com/wangjianfei" title="减肥不减肥" target="_blank"><img src="" alt="减肥不减肥"></a></li>
</ul>
<p><a href="http://weibo.com/wangjianfei" target="_blank">减肥不减肥</a></p>
<p>伯恩斯的情绪疗法 就是讲改变认知的</p>
<p>2012年12月27日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="Rainsho"></li>
</ul>
<p>Rainsho</p>
<p>低产但绝对优秀的作家。很喜欢这种科学的论述风格，偶尔来一下总是能让人思考。加油，期待你的好文。</p>
<p>2012年7月26日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="张永田"></li>
</ul>
<p>张永田</p>
<p>多谢好文的指点！现在自己就陷在情绪的牢笼里，对未来各种问题——已知的和未知的——各种担忧，对过去犯的错误的负罪感，感觉已经绑架了自己——心理和身体都是这样。我一直以为这是进化中的突变呢，只能靠我这个个体的消亡才能解决，现在看来这是可以通过心理训练来治愈的，就像看病一样。“一直活在过去与未来，却从没有活在现在”，这句话太有帮助了，终于可以解放自己的心了。感谢刘未鹏神医！哈哈！</p>
<p>2012年8月29日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://www.renren.com/profile.do?id=289246222" title="徐堂浩" target="_blank"><img src="" alt="徐堂浩"></a></li>
</ul>
<p><a href="http://www.renren.com/profile.do?id=289246222" target="_blank">徐堂浩</a></p>
<ul>
<li>, -</li>
</ul>
<p>2012年9月11日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://www.renren.com/profile.do?id=280725066" title="易洪帅" target="_blank"><img src="" alt="易洪帅"></a></li>
</ul>
<p><a href="http://www.renren.com/profile.do?id=280725066" target="_blank">易洪帅</a></p>
<p>读读挺好的。</p>
<p>2012年9月12日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="qzuser"></li>
</ul>
<p>qzuser</p>
<p>看得蛮过瘾</p>
<p>2012年9月17日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://smlme.com/" title="neugls" target="_blank"><img src="" alt="neugls"></a></li>
</ul>
<p><a href="http://smlme.com/" target="_blank">neugls</a></p>
<p>很感谢博主这么认真的写出这样好的文章，我看了你这一系列的文章之后，对思维，心理有了更深的认识，在《遇见末知的自己》这本书中有很多观点在文章中都有体现，我让受益匪浅！PS：今天我看到了一些关于洗脑的问题，说重复性的刺激（同样的观点，不同的说法让人多次接触）是洗脑的一种形式，不过我乐于被这种观点洗脑，因为它在我身上有证实！</p>
<p>2012年9月18日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://weibo.com/1788750653" title="xiaoyibaiyu" target="_blank"><img src="" alt="xiaoyibaiyu"></a></li>
</ul>
<p><a href="http://weibo.com/1788750653" target="_blank">xiaoyibaiyu</a></p>
<p>受教中。。。 感谢！</p>
<p>2012年9月19日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://weibo.com/1873928701" title="还是那么坚持" target="_blank"><img src="" alt="还是那么坚持"></a></li>
</ul>
<p><a href="http://weibo.com/1873928701" target="_blank">还是那么坚持</a></p>
<p>看了一下午！总觉得心智有不成熟的地方，总觉得自己的经验束缚了自己的创造力！</p>
<p>2012年9月21日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="qzuser"></li>
</ul>
<p>qzuser</p>
<p><img src="&quot;[给力]&quot;" alt="[给力]"></p>
<p>2012年9月24日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="qzuser"></li>
</ul>
<p>qzuser</p>
<p><img src="&quot;[嘻嘻]&quot;" alt="[嘻嘻]"></p>
<p>2012年9月24日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="牛一"></li>
</ul>
<p>牛一</p>
<p>解答我平时在思考的很疑问。不知是否会出书呢？我想买一本，然后写上自己感悟。</p>
<p>2012年10月13日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://weibo.com/wangjianfei" title="减肥不减肥" target="_blank"><img src="" alt="减肥不减肥"></a></li>
</ul>
<p><a href="http://weibo.com/wangjianfei" target="_blank">减肥不减肥</a></p>
<p>很厉害很厉害，希望发博能更频繁一些。这个系列的已经看了好几遍了，每次看完还想再看</p>
<p>2012年10月17日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="假小子"></li>
</ul>
<p>假小子</p>
<p>师兄反复向我们推荐你的博客 <img src="&quot;[赞]&quot;" alt="[赞]"></p>
<p>2012年10月19日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://www.datacentersky.com/" title="www.datacentersky.com" target="_blank"><img src="" alt="www.datacentersky.com"></a></li>
</ul>
<p><a href="http://www.datacentersky.com/" target="_blank">www.datacentersky.com</a></p>
<p>博主是做技术的还是写作的 感觉都有深度啊。</p>
<p>2012年10月23日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://www.qian999.com/" title="融资" target="_blank"><img src="" alt="融资"></a></li>
</ul>
<p><a href="http://www.qian999.com/" target="_blank">融资</a></p>
<p>这个肖申克的救赎看过很多遍，很爱，不幸的是当年遇上了阿甘正传</p>
<p>2012年10月29日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://weibo.com/1720794040" title="湖蓝的海" target="_blank"><img src="" alt="湖蓝的海"></a></li>
</ul>
<p><a href="http://weibo.com/1720794040" target="_blank">湖蓝的海</a></p>
<p>看了您这一系列的东西，觉得很受启发~沃伦·巴菲特的副手，伯克希尔公司的亚圣查理·芒格先生有一篇关于《人类误判心理学》的演讲，里面有些观点和您的很像，比如心理学、生物学在人类社会中的应用等~不知道您对他的观点怎么看，希望能交流！</p>
<p>2012年11月1日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="尼罗河"></li>
</ul>
<p>尼罗河</p>
<p>这个系列写得真好！很多道理和实验大家都有知道（实际上是一知半解），读到了博主的文之后又发现了不少深意~</p>
<p>2012年11月13日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://weibo.com/zdx3578" title="zdx3578" target="_blank"><img src="" alt="zdx3578"></a></li>
</ul>
<p><a href="http://weibo.com/zdx3578" target="_blank">zdx3578</a></p>
<p>Stop Living In This Land. Go To The Everlasting World Of Happiness . Live There Forever.，这个书有吗？有看过吗？</p>
<p>2012年12月1日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://weibo.com/90manly" title="老老丑要开挂了" target="_blank"><img src="" alt="老老丑要开挂了"></a></li>
</ul>
<p><a href="http://weibo.com/90manly" target="_blank">老老丑要开挂了</a></p>
<p>滞后了半年才看到这牛文，用个半钟读完，那种灵魂被抽离而变得虚脱的快感真是难以言喻啊@刘未鹏pongba</p>
<p>2012年12月7日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="卡萨布兰卡"></li>
</ul>
<p>卡萨布兰卡</p>
<p>我认为无法证明的伪问题，一部分基于心理沉没成本，之前坚持了某种信念，然后发现不符合自己信念的现象，一部分被有意识的忽略，一部分寻找其他的证据来证明自己的坚持，要是推翻了自己，那么之前的付出将复制东流，内心与理性不一致，产生矛盾，也会怀疑自己的认知，导致没有安全感。我认为人所有的表现都是意图在证明自己是对的。一是自己认可自己，还有就是与周围的环境保持同调，这样我们就同时环境的组成成分，群体的力量要强于自己一个人，这样更容易生存。而对于自己认可自己与得到外界的认可不能同时满足，得看个人的生存认知强度，前者有伦勃朗，后者有指鹿为马。</p>
<p>2012年12月16日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://www.nbpgy.net/" title="宁波工作服" target="_blank"><img src="" alt="宁波工作服"></a></li>
</ul>
<p><a href="http://www.nbpgy.net/" target="_blank">宁波工作服</a></p>
<p>不错的博客，记住了</p>
<p>2012年12月23日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://weibo.com/lueying" title="四海沉烟" target="_blank"><img src="" alt="四海沉烟"></a></li>
</ul>
<p><a href="http://weibo.com/lueying" target="_blank">四海沉烟</a></p>
<p>算是几年来的一个集大成品了！~</p>
<p>1月3日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://weibo.com/idushusxl" title="茶艾尔_XL" target="_blank"><img src="" alt="茶艾尔_XL"></a></li>
</ul>
<p><a href="http://weibo.com/idushusxl" target="_blank">茶艾尔_XL</a></p>
<p>人的决策机制、反应模式总是如此有趣</p>
<p>1月15日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://www.zjybzl.cm/" title="宁波展览公司" target="_blank"><img src="" alt="宁波展览公司"></a></li>
</ul>
<p><a href="http://www.zjybzl.cm/" target="_blank">宁波展览公司</a></p>
<p>容易记的博客，支持</p>
<p>3月3日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://xianhuo.org/" title="鲜活优惠码" target="_blank"><img src="" alt="鲜活优惠码"></a></li>
</ul>
<p><a href="http://xianhuo.org/" target="_blank">鲜活优惠码</a></p>
<p>我都还没看这电影呢</p>
<p>3月19日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="zol"></li>
</ul>
<p>zol</p>
<p>刘未鹏你好。我是一名学计算机的学生，但其实我更喜欢你的写的关于思维与心理的文章。想问的是，为什么思维科学与心理学经常放在一起来讨论。我记得你在豆瓣上给出了两个书单，那是系统学习思维科学的书单吗？那么，能否请你也推进一些书目能够我系统地学习心理学？感激不尽。</p>
<p>4月27日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="撒加加"></li>
</ul>
<p>撒加加</p>
<p>精彩！信息量很大，保留下来多看几遍。很多事例已在我的生活中得到印证。支持你！</p>
<p>4月27日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://t.qq.com/lu_sc04" title="蔬菜" target="_blank"><img src="" alt="蔬菜"></a></li>
</ul>
<p><a href="http://t.qq.com/lu_sc04" target="_blank">蔬菜</a></p>
<p>写的真不错~~~</p>
<p>5月15日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://www.renren.com/profile.do?id=349480276" title="梁小辉" target="_blank"><img src="" alt="梁小辉"></a></li>
</ul>
<p><a href="http://www.renren.com/profile.do?id=349480276" target="_blank">梁小辉</a></p>
<p>经典</p>
<p>6月13日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://t.qq.com/holzkopf" title="holzkopf" target="_blank"><img src="" alt="holzkopf"></a></li>
</ul>
<p><a href="http://t.qq.com/holzkopf" target="_blank">holzkopf</a></p>
<p>极有深度的文章。</p>
<p>6月17日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://www.renren.com/profile.do?id=246743213" title="周全♪" target="_blank"><img src="" alt="周全♪"></a></li>
</ul>
<p><a href="http://www.renren.com/profile.do?id=246743213" target="_blank">周全♪</a></p>
<p>（五）</p>
<p>6月20日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="阳光太过刺眼"></li>
</ul>
<p>阳光太过刺眼</p>
<p>好</p>
<p>6月20日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="xinfei_lin"></li>
</ul>
<p>xinfei_lin</p>
<p>写的很好。但是太复杂了。建议关注亲密之旅，黄维仁博士归纳的比这些深入浅出。而且他的团体学习可以在创设安全的环境，让小时没有建立起安全的依附关系的人在这个环境中让情绪的大脑重新连线，重新建立情绪反应模式</p>
<p>6月23日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="vincent"></li>
</ul>
<p>vincent</p>
<p>刘老师,看完你的几篇文章之后,再发现还有很长的路要走.
但对于这些文章,我想必须要有一个凡人的感情色彩去品味,否则的话大脑真会很难受的,谢谢.
我可以转你几篇文章??谢谢.</p>
<p>6月28日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/好文摘录/">好文摘录</a></li></span></span> | <span class="time">recent updated:<time title="2014-03-07 11:24:28"datetime="2014-03-07 11:24:28"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/03/2014-02-03--逃出你的肖申克（五）：看不见的牢笼（上）/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-03--逃出你的肖申克（五）：看不见的牢笼（上）" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/03/2014-02-03--知其所以然（续）/">知其所以然（续）</a></h1>
      
        <span>Posted on<time datetime="2014-02-03T03:24:28.000Z"> <a href="/2014/02/03/2014-02-03--知其所以然（续）/">feb. 3 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-">知其所以然（续）</h1>
<h1 id="-http-mindhacks-cn-2010-11-14-the-importance-of-knowing-why-part2-"><a href="http://mindhacks.cn/2010/11/14/the-importance-of-knowing-why-part2/" target="_blank">知其所以然（续）</a></h1>
<p>查了一下，上篇<a href="http://mindhacks.cn/2008/07/07/the-importance-of-knowing-why/" target="_blank">知其所以然（以学习算法为例）</a>是08年7月写的，现在已经是10年11月，过去了两年零4个月，这说明了三件事情：1，一个问题其实你可以一直放在脑子里面，利用<a href="http://mindhacks.cn/2009/12/20/dark-time/" target="_blank">暗时间</a>对其软泡硬磨，时间足够久你总会有一点新的感悟，问题其实就像那句老话说的那样，不怕贼偷就怕贼惦记，聚精会神的思考一天，也许比不上惦记一个星期（据说<a href="http://blog.csdn.net/pongba/archive/2008/07/24/2705151.aspx" target="_blank">数学家庞加莱就特别会惦记问题</a>）。2，事实上，当你感觉懂了的时候，你至少得反问自己一句，真的懂了吗？当你确信自己真的懂了的时候，你至少得讲给别人听，别人听懂了吗？考察你自己是否真懂了的一个很好的依据是，你是否有一种“哦，原来是这样啊，这下再也不可能忘记了”的感觉。3，我其实没有忘记这个博客。如我之前说的，<a href="http://mindhacks.cn/2009/02/15/why-you-should-start-blogging-now/" target="_blank">记录只是学习和思考的副作用</a>，只要还在学习和思考，就必然会有新的记录。</p>
<p>我有一个习惯，看定理必看证明。一个你不明白其证明的定理在我看来比不知道这个定理还要糟糕，因它给你造成一种懂了的错觉。<strong>在没有明白背后的证明之前，任何一个定理对你来说都是等价的——等价于背乘法口诀</strong>（只不过有的长一点有的短一点）。一个原本美妙的定理，把其证明扔掉就是真正的买椟还珠，暴殄天物。</p>
<p>从现实意义来说，<strong>去理解一个定理的证明会带来巨大的好处，首当其冲的好处就是你很难再忘掉它</strong>。这一点其实很容易解释——在理解一个定理的证明之前，定理对你而言是一堆没有内在联系的词句，而在理解了证明之后，定理就<strong>归约为</strong>证明它所需的条件加上逻辑，“逻辑”本来就存在于你的大脑里面，而证明的过程中除了公理和用到的常见定理（往往没几条）之外，宽泛地说，需要你去记的，一般来说也只有一个或两个关键的insights，也就是我们常说的证明中的神来之笔，比如几何证明里面的某条看上去莫名其妙的辅助线，一旦你知道了这条辅助线，那么整个证明就毫无难处，那么该定理的信息量便直接缩减为一条辅助线的信息量；虽然看上去这一步信息并没有缩减多少，但是如果你考虑到类似的辅助线不仅会用在这个特定的定理上，往往会在很多地方用到。很多关键的证明手法是通用的。那么其实你就是把所有以这个辅助线为关键证明手法的定理的集合的信息量归约为了这条辅助线。如果你进而甚至能够理解了作这条辅助线的思想精髓，那就更牛逼了，因为解决问题的思路更具有一般性，理解了寻找正确的辅助线的思路，你就根本不需要去记得某条特定辅助线的作法，你就把所有以作一条或几条辅助线为证明核心的定理的集合的信息量归约为了这个“寻找辅助线的思路”。</p>
<p><strong>这是一个树状的知识结构，越往上层走，需要记忆的节点就越少</strong>。所谓触类旁通者，其实便是因为他擅长去理解解法背后的更具一般性的东西。所以我还有一个习惯，就是看到美妙的证明和解法总是会去一遍又一遍的去反复揣摩，试图理解想出这个证明的人到底是怎么想出来的，有没有什么一般性的方法可循，很多时候，在这样揣摩的过程中，你会理解到更深刻的东西，对问题性质更深刻的认识，对解决问题的思路更深刻的认识，这些认识不仅对于你理解当前这个定理或问题有极大的帮助，同时也有助于你解决以后会遇到的表面不同但本质一样的问题。</p>
<p>与看定理必看证明类似，看一个问题的解法，必然要看解法所诞生的过程，背后是否隐藏着更具一般性的解决问题的思路和原则。否则一个解法就只是一个问题的解法，跟背口诀一样。即便记住了也无法推广，即便当时记住了也容易遗忘。</p>
<p>举个经典的例子：每本算法书都会讲动态规划，每本讲动态规划的书都会讲背包问题，每次讲背包问题都会讲可重复背包和01背包，我们就拿《Algorithms》这本<a href="http://book.douban.com/review/1325850/" target="_blank">还算不错</a>的算法书对背包问题的讲解来说吧，重复背包问题的递归公式是这样的：</p>
<p>K(W) = max { K(W-Wi) + Vi : Wi &lt;= W }</p>
<p>这个公式的理解倒是很简单：为了把问题降阶，我们在最终的最优解里面去掉一个元素，对这个元素的可能性进行讨论，它必然是任何Vi之一（前提是Wi &lt;= W，否则就装不下），而在去掉这个元素之后，剩下的元素肯定构成问题 K(W-Wi) 的最优解，于是递归关系出现了。</p>
<p>此外也可以这样来理解：要拿一组最优元素，那么总得开始一个个拿吧，对第一个拿的元素进行讨论，而问题的最优解等于讨论的各个分支的最优解中的最优者；如果拿掉Vi之后，剩下来要怎么拿才能最优呢？这就是一个 K(W-Wi) 的问题了。</p>
<p>01背包问题就大不一样了——每个物品都只有一件，拿掉之后就不能再拿了。我们不妨看看重复背包问题的解法是不是能用到01背包上呢？还是讨论第一个拿的元素，设被拿掉的是第i个元素，问题就归结为把剩下的物品（注意，可拿的物品少了一件）最优地装入容量为 W-Wi 的包里，所以，问题的参数便变成了两个，一个是背包剩余容量 W-Wi，另一个是剩余可拿的物品集合 S{i} （表示去掉i之后的子集），显而易见第二个参数是物品集合的各种可能的子集，那么其可能性个数就是 2^n ，这就导致子问题的个数是 2^n， 由于要依次计算每个子问题，那么算法复杂度显然也是 2^n ，是不可接受的。</p>
<p>那么，《Algorithms》上又是怎么来讲解01背包问题的解法的呢？以下是原文：</p>
<p>Our earlier subproblems now become completely useless. We must therefore refine our concept of a subproblem to carry additional information about the items being used. We add a second parameter, 0 &lt;= j &lt;= n: K(W, j) = maximum value achievable using a knapsack of capacity w and items 1..j: The answer we seek is K(W, n).</p>
<p>首先作者说了，之前重复背包问题的解法在这里完全废掉了，所以我们必须重新定义子问题，并且子问题的条件必须要包含目前拿剩下的物品。以上这些都还不错，关键是接下来就让人吐血了。作者接着说道，<strong>我们</strong>给子问题加上一个新的参数j…</p>
<p>凭什么啊？</p>
<p>还是让我们回顾一下<a href="http://images.google.com/images?hl=en&amp;source=imghp&amp;biw=1024&amp;bih=620&amp;q=then+a+miracle+occurs&amp;gbv=2&amp;aq=f&amp;aqi=g3g-m6&amp;aql=&amp;oq=&amp;gs_rfai=" target="_blank">这样一幅经典的漫画</a>吧：</p>
<p><img src="" alt=""></p>
<p>“我们给子问题加上一个参数j”，这就像你在看数学证明时看到无比邪恶的“<strong>我们考虑</strong>…“一样，一看到这样的句子，你就知道，这个问题的证明远远不像看上去那么简单，之所以你一路看下去理解上全无困难，那完全是因为作者直接把最重要的一个insight告诉你了，举个很简单的例子，证明素数无最大，谁都会第一时间想到去反证：假设存在一个最大的素数P，那么找到比P大的素数就是证明中最关键的一步，怎么找的？一般书上是不会说的，你会看到书上这样说：假设P是最大的素数，那么我们考虑P’ = 小于等于P的所有素数的乘积+1。那么P’一来显然大于P，二来不能被小于它的所有素数整除，那么P’就成了大于P的素数。</p>
<p>如果你经常注意反证法，你会发现一个有趣的现象，反证法里面经常会有这样一句“我们考虑”，而“我们考虑”后面几乎肯定接着一个天外飞仙一般的insight。素数无最大这个古老的证明里面的“我们考虑”尚算是比较有迹可循的（我们想要构造一个更大的素数，而素数的等价定义就是“不能被小于它的所有素数整除，为了达到这个目的，构造的方法就较明显了）。但是有非常非常多的证明，其中关键的一步就跟嗑药磕出来做梦做出来走路跌跟头跌出来的一样（不信去翻一翻《<a href="http://www.amazon.com/Proofs-BOOK-Martin-Aigner/dp/3540404600" target="_blank">Proofs from THE Book</a>》），让你完全不知道他怎么想到的。</p>
<p>话说回来，虽然有很多数学证明的关键步骤是很难逆向工程的（因为很多时候想出那个关键步骤的本人其实也是尝试了各种方法，撞了无数堵墙，在寻求证法的尝试空间中作了N次回溯才“妙手偶得”，与其说是妙手偶得，不如说是绞尽脑汁），但并非全无章法可循，否则陶哲轩也不会写出《<a href="http://www.amazon.com/Solving-Mathematical-Problems-Personal-Perspective/dp/0199205604" target="_blank">Solving Mathematical Problems</a>》这样的著作来，而求解问题也就成了真正的Black Art了。</p>
<p>算法的解法则比精妙的数学证明稍加更容易逆向工程一点。只要你有耐心仔细地去琢磨算法的关键步骤和本质，总能从中窥探到一些更general的思想和思路来。</p>
<p>此外，很多经典问题，算法书上的讲法虽然时时令我们失望，但如果去网上一搜，则通常会发现更优秀的解释来。比如<a href="http://www.google.com/webhp?hl=en#sclient=psy&amp;hl=en&amp;site=webhp&amp;source=hp&amp;q=%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98+%E8%A7%A3%E7%A9%BA%E9%97%B4&amp;aq=f&amp;aqi=&amp;aql=&amp;oq=&amp;gs_rfai=&amp;pbx=1&amp;fp=ab43752bbefd1914" target="_blank">背包问题就是如此</a>。</p>
<p>简单地说，如果你对于每个问题都能真正弄清以下这几个问题的答案，那么可以肯定的是，你的理解，记忆，以及学习的效率都会得到质的提高：</p>
<ul>
<li>为什么这种解法是对的？</li>
<li>为什么那种解法是错的？</li>
<li>为什么这种解法不是最优的？</li>
<li>证明为什么没有更优的解法。</li>
</ul>
<p>回到人民群众喜闻乐见的经典例子：背包问题。为什么01背包问题的正确（高效）算法是正确（高效）的。表面的解释是，因为01背包问题的子问题定义是 K(W, j)，其两个维度相乘的可能性一共有nW种，也就是说一共要计算nW个子问题，而计算每个子问题的复杂度是O(1)的。</p>
<p>但是如果仅仅满足于这样的解释，可以说是隔靴搔痒，并没有触及到本质。算法本质上可以看做是在一个解空间当中的搜索问题，所以要分析一个算法的好坏，首先弄清它的解空间的结构，然后分析它是怎么来探索这个解空间的。</p>
<p>弄清解空间的是第一步，例如排序算法，其解空间可以看做是所有可能的下标排列组合，其中有且仅有一个排列是正确的排序排列（简单起见假设元素各不相同）。那么一个算法在探索这个解空间方面的行为就决定了它的效率高低，最简单的，如果一个算法每次只能检查解空间中的一个点，那么这个算法的复杂度就是解空间的大小。对排序算法而言也就是n!。从这个角度来看，我们就会很容易的发现，所有基于比较的排序算法，其复杂度为什么是以O(nlogn)为下界的，因为一次比较操作最多有两个结果，a&gt;b或a&lt;b，既然只有两种结果，那么最多只能将解空间进行2分，如果每次都能完美的2分，那么找到那个唯一点最终需要的步骤就是log(n!) = O(nlogn)。如此就不难理解<a href="http://mindhacks.cn/2008/06/13/why-is-quicksort-so-quick/" target="_blank">什么基于比较的排序算法的复杂度最好不过如此了</a>。</p>
<p>回到01背包问题，01背包问题的解空间其实也是类似的。一次选取就是一个01数组，其中每个元素代表其所对应的物品要不要选取。很显然，这个解空间的大小是2^n。在01背包的算法里面，每当我们解出K(W, j)（需要O(W)次计算）之后，解空间就会被折半（排除掉1/2的可能性），一共如此做n次，就能得到最终解。由于每次折半的代价是O(W)，便不难理解为什么算法复杂度是O(nW)了。</p>
<p>那么，为什么每次计算出K(W,j)就能使解空间折半呢？那就需要来看看这个算法是如何探索解空间的，算法探索解空间的方式在其递归公式里面：</p>
<p>K(W, j) = max { K(W, j-1), K(W-Wj, j – 1)  + Vj }</p>
<p>也就是说，首先看你要不要选取第一个物品，有两种可能性（两个分支），每个分支都是一个更低阶的子问题，即在其中的任意一个分支下都要决定要不要选取第二个物品（又是两个分支），如此下递归去，可以构建出一棵有2^n方个叶子节点的树，每条从根结点到叶子节点的路径“01..101”就对应一个解，其中每个分叉代表“选”或“不选”当前的物品。</p>
<p>建立在对这个解空间的理解上，我们再来看为什么01背包问题的正确解法能做到O(nW)。（首先你最好将这棵树画在纸上，其中每个节点都是一个子问题K(W,j)，每条分叉都是0或1。）当我们计算出所有的K(W, 1)（需要O(W)次操作）之后，我们容易注意到，所有离叶子节点的距离为1的内部节点K(W, 2)到叶子节点的两个分支都必然只能取其一了，也就是说，有一半的叶子节点被排除掉了（对解空间折半）。当我们进而计算出K(W,2)之后，同样的道理，我们容易看到，到叶子节点距离为2的内部节点的两个分支也只能取其一了，这就进而再次将解空间折半。由于每次折半需要O(W)的复杂度，所以就不难理解算法的总复杂度为O(nW)了。另一种理解的方法是，当我们计算出K(W,j)的时候，从内部节点K(W,j)到根节点的唯一路径便确定了。经过O(nW)次计算，从根节点到那个唯一解（叶子节点）的路径便完全确定了。</p>
<p><strong>知道怎么做是从正确（高效）解法得到的，而知道为什么必须得那样做则往往是从错误（低效）的解法当中得到的。</strong></p>
<p>然而遗憾的是，绝大多数算法书或教程都只顾一上来就告诉你正确的做法是什么，对于一些常见的错误解法，或者常见的低效解法，却根本不加分析。经验告诉我们，理解错误的做法为什么错误同样甚至更为重要，往往是在理解了错误的解法为什么错误之后，我们才能深刻的体会到为什么正确的解法是如此正确。</p>
<p>还是拿经典的背包问题来作例子，你几乎看不到哪本书会告诉你一个典型的低效解法为什么低效的深刻原因。我们都知道动态规划的核心在于子问题的划分，同样的问题，不同的划分办法得到的复杂度完全不一样。前面已经提到了，重复背包问题的思路在01背包问题上会带来指数级的复杂度，但是为什么呢？如果你满足于说：因为如果拿重复背包问题的思路来解01背包问题，那么子问题定义的第二个维度（物品的子集）（见前文）是指数级的，那么要计算所有子问题，当然是指数级的。那么你只是看到这个问题的表象。</p>
<p>如果从对解空间的探索方式来说，可以容易看出这个现象的本质，我们回顾一下01背包问题的正确（高效）算法：</p>
<p>K(W, j) = max { K(W, j-1), K(W-Wj, j – 1)  + Vj }</p>
<p>这个算法讨论的是两种情况，“要”或者“不要”选取第j个物品，这两种情况所对应的解空间是完全不交的，这就有效地将解空间划分为了不重复的两个部分。</p>
<p>而再来看利用重复背包问题思路的解法：</p>
<p>K(W, S) = max { K(W-Wi, S{i}) + Vi : Wi &lt;= W }</p>
<p>这里讨论的是首先拿掉哪一个物品，还是那句话，讨论的每一个分支都对应了算法对解空间的一个切分，我们容易看出，在“先拿物品i”和”先拿物品j“这两个分支里面，存在大量的重复，因为先拿物品i再拿j，和先拿物品j再拿i对应的是完全一样的一组选取。事实上，如果你将这个递归公式画成树状结构，会发现有n!个叶子节点。n!是什么概念？01背包问题的解空间大小本质上就只有2^n次方，穷举也不过O(2^n)的复杂度，结果这样一切分却变成了n!，可见这种对解空间的切分方法的冗余度是多么高了。你不妨看看，每一次计算K(W, S)子问题能对解空间排查多少呢？是否能像前面正确的算法那样，每次都能有效排查一半情况？理解了这一点之后，我们便注意到在划分解空间，也就是定义子问题的时候的一个原则，就是在建立递归公式的时候，尽量将解空间进行不交的切分。同时我们便有了趁手的工具去分析一个动态规划的解法的效率。</p>
<p>最后再举一个例子：算法书上几乎必讲的霍夫曼树。你所看的算法书在讲霍夫曼树的时候给了证明吗？讲过霍夫曼树的<a href="http://en.wikipedia.org/wiki/Huffman_tree#History" target="_blank">历史八卦</a>吗？也许你看了霍夫曼树的构造方法之后觉得：“哦，这样啊，显然”。但是你可曾想到，在最优编码这个问题上，连<a href="http://en.wikipedia.org/wiki/Shannon-Fano_coding" target="_blank">香农本人之前给出的解法</a>都只是suboptimal的，而且霍夫曼本人在得到这个算法之前也是绞尽脑汁几近放弃。<strong>如果你10分钟就“理解”了，那么百分之百只是背了课文而已。</strong>
**来源： <a href="[http://mindhacks.cn/2010/11/14/the-importance-of-knowing-why-part2/](http://mindhacks.cn/2010/11/14/the-importance-of-knowing-why-part2/)">[http://mindhacks.cn/2010/11/14/the-importance-of-knowing-why-part2/](http://mindhacks.cn/2010/11/14/the-importance-of-knowing-why-part2/)</a> </p>
<ul>
<li>小屋</li>
</ul>
<p>太好了，，我还以为再也不更新了呢
T<strong>__</strong>T</p>
<p>2010年11月25日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="Andy"></li>
</ul>
<p>Andy</p>
<p>有道无术，术可求
有术无道，止于术
根据文章看来，未鹏兄是领悟了数学的道，也领悟了对待科学与真理的道</p>
<p>2010年11月25日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://hi.baidu.com/Akagi201" title="Akagi201" target="_blank"><img src="" alt="Akagi201"></a></li>
</ul>
<p><a href="http://hi.baidu.com/Akagi201" target="_blank">Akagi201</a></p>
<p>不更则已，一更惊人！</p>
<p>2010年11月25日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="pengde"></li>
</ul>
<p>pengde</p>
<p>等你的文章等了好久哟</p>
<p>2010年11月26日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="demo_world"></li>
</ul>
<p>demo_world</p>
<p>就像您说的那样..记录是学习和思考的副作用!!
总是感觉能从您的文章中读处那么一点不一样的味道....
所以我们更加急切希望您的最新文章,殊不知沉淀过后的思想才是你的追求。
我们会继续支持下去，能给我们带来更多更好的思想....</p>
<p>2010年11月27日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="温海"></li>
</ul>
<p>温海</p>
<p>朋友，您好！我是武汉博文视点的编辑温海。我们打算为刘未鹏出版一本书，暂定《暗时间》书名，我们现在想邀请您作为我们的读者顾问团成员，一起为这本书的内容和版式设计出谋划策。不知您是否方便？我的联系地址是wenhai.no.2@gmail.com 如果您方便的时候请跟我联系。谢谢！</p>
<p>2010年12月6日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="hugo"></li>
</ul>
<p>hugo</p>
<p>等了我不少时日啊 ：）
文章还是一贯的深入浅出，很有味道 ：）</p>
<p>2010年11月27日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://wang4747.javaeye.com/" title="lele" target="_blank"><img src="" alt="lele"></a></li>
</ul>
<p><a href="http://wang4747.javaeye.com/" target="_blank">lele</a></p>
<p>等了好久。</p>
<p>2010年11月28日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="breaker"></li>
</ul>
<p>breaker</p>
<p>一直用Google Reader读你的文章，这次来看发现主题变了，你侧边那个“作为信息源的我”和有推荐的书籍怎么没有了？</p>
<p>2010年11月28日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://weibo.com/pongba" title="刘未鹏pongba" target="_blank"><img src="" alt="刘未鹏pongba"></a></li>
</ul>
<p><a href="http://weibo.com/pongba" target="_blank">刘未鹏pongba</a></p>
<p>不好意思，忘了加上去了。稍后加上。</p>
<p>2010年11月28日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="breaker"></li>
</ul>
<p>breaker</p>
<p>动作真快啊，我已经看到了。</p>
<p>2010年11月28日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="Tradition"></li>
</ul>
<p>Tradition</p>
<p>如同法国大餐一样值得等待和回味</p>
<p>2010年11月29日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://www.cncasting-forging.com/" title="bronze casting" target="_blank"><img src="" alt="bronze casting"></a></li>
</ul>
<p><a href="http://www.cncasting-forging.com/" target="_blank">bronze casting</a></p>
<p>终于见到博主更新了，围观围观</p>
<p>2010年11月29日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="gordon"></li>
</ul>
<p>gordon</p>
<p>其实都是凑出来的，但是这个凑合和试错还不相同，在数学上的俚语叫两头凑，没办法当
时我们老师就是这么教的。
证明有从已知出发，有从结论出发，然后构造一个中间层。
其实很多东西都是引入一个中间层的概念，数学推理过程中的很多中间公式是无法用实验
方法实验出来的，那就是构造出来的一个中间层。
知道做什么比知道怎么做重要的多，这就相当于老板和打工仔的关系，
老板其实不知道怎么干，但他知道做什么，他会招来一个数学系的马仔说：
我有一个很漂亮的证明，但是这页纸写不下了，你去把它证明一下。
然后老板去喝酒泡miss、调情去了。理工男“哼哧哼哧”干了半天。
提出命题和猜想的都是牛大的人，
不过引入中间层构造命题，到最后会成圆环套圆环，恶心的跟屎一样，就需要用批判性思
维雕出来，成为瀑布流水式的证明。数学之美从此产生，以前的证明太恶心；终于有个好
的证明了，简捷、明快犹如一件艺术品。
感谢陈凯歌大导演的电影，《无极》给华夏大地的语言增添了很多新元素。
古希腊和文艺复兴时期的人一直有这么一个认知情节，不知道从哪里来的，
每一个石头里都有一个大卫，每一个人身体里都有一个米开朗基罗，
去掉不对，它的轮廓自然清晰的显现出来了。
为什么要知其所以然，不知其所以然到底行不行？
学校里成绩一直不好的同学飘过。。。
为什么要知其所以然，
除了归约为有限集的好处之外，还有推广的好处。
一个技巧变成一个方法，一个方法成为一种思想，这是一种方法的推广。
我早就对数学没什么兴趣了，倒是对数学之外的美比较有兴趣，比如美丽女教师之类的，
当然穿上紧身裙更棒了。让那些糟老头滚蛋，但是如果糟老头穿上豹纹装，跳个草裙舞之
类的也能接受。数学系漂亮女生不多哪能发现数学之美啊，也没兴趣知其所以然。</p>
<p>2010年11月29日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="gordon"></li>
</ul>
<p>gordon</p>
<p>倒数第六行
“为什么要知其所以然” 改为 “对已知的学习为什么要知其所以然”</p>
<p>2010年11月29日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="温海"></li>
</ul>
<p>温海</p>
<p>朋友，您好！我是武汉博文视点的编辑温海。我们打算为刘未鹏出版一本书，暂定《暗时间》书名，我们现在想邀请您作为我们的读者顾问团成员，一起为这本书的内容和版式设计出谋划策。不知您是否方便？我的联系地址是wenhai.no.2@gmail.com 如果您方便的时候请跟我联系。谢谢！</p>
<p>2010年12月6日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="Semloh"></li>
</ul>
<p>Semloh</p>
<p>正好再看算法，不错</p>
<p>2010年12月4日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://www.justuggg.net/" title="ugg Bailey Button Boots" target="_blank"><img src="" alt="ugg Bailey Button Boots"></a></li>
</ul>
<p><a href="http://www.justuggg.net/" target="_blank">ugg Bailey Button Boots</a></p>
<p>真强悍，很不错的文采。、</p>
<p>2010年12月4日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="bigeast"></li>
</ul>
<p>bigeast</p>
<p>可是现在大学课堂上一节课能将N个定理，为了赶进度完成任务，定理的证明几乎从来不讲。自己一个个看也感到力不从心。</p>
<p>2010年12月9日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="InitialG"></li>
</ul>
<p>InitialG</p>
<p>我晕 我的留言很2吗 怎么被删除了》？</p>
<p>2010年12月10日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://weibo.com/pongba" title="刘未鹏pongba" target="_blank"><img src="" alt="刘未鹏pongba"></a></li>
</ul>
<p><a href="http://weibo.com/pongba" target="_blank">刘未鹏pongba</a></p>
<p>不好意思，有一次误操作把这篇文章的所有留言批量删除了 <img src="&quot;:(&quot;" alt=":("></p>
<p>2010年12月13日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://www.wutianqi.com/" title="Tanky Woo" target="_blank"><img src="" alt="Tanky Woo"></a></li>
</ul>
<p><a href="http://www.wutianqi.com/" target="_blank">Tanky Woo</a></p>
<p>收藏了！</p>
<p>2010年12月12日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="LGyuan"></li>
</ul>
<p>LGyuan</p>
<p>读你的文章好有激情啊！</p>
<p>2010年12月14日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="gordon"></li>
</ul>
<p>gordon</p>
<p>顺便说一句，从低效解法的分析得出高效解法，只限定在一类的问题内，例如局部最优问题。
原因是人能够发挥主观能动性，在寻找道路的时候可以记录信息，从而在搜索N次以后，终于可以找到从A到B的路。
在另外一类问题中，这种方法是无效的。
其实得不得出解法根本不是本质，本质是你对这个问题或者说命题的本质认识，不断求解
的过程其实就是你对信系丰富，对问题本质认识深化的过程。其实这些解法根本就是练练
手，就像美工做个小样或者程序开发的快速原型，这里引入了一个词Enrichment——事件
丰富，其实就是侦察一下，看看怎么回事。
其实就是信息丰富的一个过程，对命题本质的理解要深化了。
其实是这三个概念，事件丰富，事件关联，事件压缩。
enrichment、correlation、deduplication</p>
<p>2010年12月18日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="gordon"></li>
</ul>
<p>gordon</p>
<p>我这都是瞎说的，一时手贱打上去了</p>
<p>2010年12月18日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="miley"></li>
</ul>
<p>miley</p>
<p>我倒是觉得你的reply更charming一些呢</p>
<p>2011年1月29日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://www.nbled.net/" title="宁波led显示屏" target="_blank"><img src="" alt="宁波led显示屏"></a></li>
</ul>
<p><a href="http://www.nbled.net/" target="_blank">宁波led显示屏</a></p>
<p>读一遍没感觉，再读一遍，就不信了</p>
<p>2010年12月21日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="ymliu"></li>
</ul>
<p>ymliu</p>
<p>知行合一。
知识的积累固然重要，但是能否把知识转换为生产力，做出实际的贡献也是非常重要的。</p>
<p>2010年12月23日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://t.sina.com.cn/imissyoucj" title="iMissYouCJ" target="_blank"><img src="" alt="iMissYouCJ"></a></li>
</ul>
<p><a href="http://t.sina.com.cn/imissyoucj" target="_blank">iMissYouCJ</a></p>
<p>好久都不更新了</p>
<p>2010年12月25日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://www.noblepen.com/blog/" title="诺贝笔" target="_blank"><img src="" alt="诺贝笔"></a></li>
</ul>
<p><a href="http://www.noblepen.com/blog/" target="_blank">诺贝笔</a></p>
<p>排序算法一直没理解透</p>
<p>2010年12月29日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://www.auggbootsclearance.com/" title="ugg boots clearance" target="_blank"><img src="" alt="ugg boots clearance"></a></li>
</ul>
<p><a href="http://www.auggbootsclearance.com/" target="_blank">ugg boots clearance</a></p>
<p>很给力的文章啊。。呵呵
祝博主新年快乐哦。</p>
<p>2010年12月31日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://www.dino-power.com/" title="spray gun" target="_blank"><img src="" alt="spray gun"></a></li>
</ul>
<p><a href="http://www.dino-power.com/" target="_blank">spray gun</a></p>
<p>没太看明白，感觉很乱</p>
<p>2011年1月5日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="Cross"></li>
</ul>
<p>Cross</p>
<p>哥，更新的太少了啊，所有文章都看了几遍了！ 咕~~(╯﹏╰)</p>
<p>2011年1月16日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://blog.sina.com.cn/enterpriseword" title="侯轲" target="_blank"><img src="" alt="侯轲"></a></li>
</ul>
<p><a href="http://blog.sina.com.cn/enterpriseword" target="_blank">侯轲</a></p>
<p>您好！认识你很高兴！</p>
<p>2011年2月5日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://www.taobaowang-gw.com/" title="taobaowang" target="_blank"><img src="" alt="taobaowang"></a></li>
</ul>
<p><a href="http://www.taobaowang-gw.com/" target="_blank">taobaowang</a></p>
<p>牛人,学习了</p>
<p>2011年2月15日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="kisswind"></li>
</ul>
<p>kisswind</p>
<p>公理是最重要的，对于定理没必要每个都要证明，可以当成已知。“我有一个习惯，看定理必看证明”，这样会很花时间，假如要造个汽车，你不必每个零件都了解它怎么生产的，你只需要了解每个零件的特性，使用方法。就像写程序，你不必了解每个模块的原理，只要理解它的使用方法，只要按照它定的规则使用就绝对不会有问题(前提是每个模块要像定理一样被别人证明正确了)。知识是有层级的，每一个上层的知识都建立在它的下一层级基础之上，你的应用是在哪一级的，对构成它基础的知识就没必要怀疑, 这种怀疑可以是向下没有限度的。</p>
<p>2011年2月28日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="firo"></li>
</ul>
<p>firo</p>
<p>pongba,《Introduction to the design and analysis of algorithms》这本书和作者对于算法的学习观点，基本上和你的一只，很给力！！最近正在拜读中，主要观点可见他的文章 Do We Teach the Right Algorithm Design Techniques ? 这是地址：<a href="http://www.csc.villanova.edu/~levitin/paper.html" target="_blank"><a href="http://www.csc.villanova.edu/~levitin/paper.html">http://www.csc.villanova.edu/~levitin/paper.html</a></a> 
另外感谢你的文章为我学习前行的道路，指明方向。</p>
<p>2011年3月30日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://qmzh.net/" title="xRan" target="_blank"><img src="" alt="xRan"></a></li>
</ul>
<p><a href="http://qmzh.net/" target="_blank">xRan</a></p>
<p>请问您的空间是哪里购买的？ 速度很快，我也想购买。</p>
<p>2011年8月26日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://www.popbedding.com/" title="train quilt" target="_blank"><img src="" alt="train quilt"></a></li>
</ul>
<p><a href="http://www.popbedding.com/" target="_blank">train quilt</a></p>
<p>看了三，再看看二吧！</p>
<p>2011年10月10日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://hi.baidu.com/%E5%9F%BA%E7%9D%A3%E5%B1%B1%E5%94%90%E5%A4%AA%E6%96%AF/home" title="Pencilman" target="_blank"><img src="" alt="Pencilman"></a></li>
</ul>
<p><a href="http://hi.baidu.com/%E5%9F%BA%E7%9D%A3%E5%B1%B1%E5%94%90%E5%A4%AA%E6%96%AF/home" target="_blank">Pencilman</a></p>
<p>很感谢，排序复杂度的那个分析。这样来看自己以前学算法的时候确实没有想得很深入。但我以前学习有个习惯，就是自已用的定理一定要使自己随时都能推出来的定理，但随着课程的深入我发现这样有个弊端：精力花费太大了！不断地模拟定理退出来的过程，固然可以加强自己的理解，但这样成本太大，而且有些东西根本几乎就是自己再怎么想都想不出来的啊！我们学算法当然、一定要去思考这个算法是怎么出来的，但要有个度（也许是我愚蠢的想法），我觉得更好的方式就是和大家一起来探讨这个问题，感觉这样效率会高很多。</p>
<p>2011年10月20日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="jier-liao"></li>
</ul>
<p>jier-liao</p>
<p>&quot;二来不能被小于它的所有素数整除，&quot;可以证明p‘，是素数吗？</p>
<p>2011年12月7日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="ArchNew"></li>
</ul>
<p>ArchNew</p>
<p>现在N多的教材有一个习惯，就是N多的定理不给出证明。原因有很多，有的纯粹是作者问题，有的是篇幅问题，还有的就是这些定理的证明要用到还未介绍的知识。不过真正的好教材，前两种问题对它来说都不是问题。即便碰到最后一种问题，教材的作者也会像一个科普书的作家一样，尽量地给出直觉式的理由。遗憾的是，这样的书太少。</p>
<p>2011年12月18日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://www.vivilli.com/118-sunglasses/" title="cheap sunglasses online" target="_blank"><img src="" alt="cheap sunglasses online"></a></li>
</ul>
<p><a href="http://www.vivilli.com/118-sunglasses/" target="_blank">cheap sunglasses online</a></p>
<p>谢谢您的分享</p>
<p>2012年6月21日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://www.vivilli.com/118-sunglasses/" title="fashion sunglasses" target="_blank"><img src="" alt="fashion sunglasses"></a></li>
</ul>
<p><a href="http://www.vivilli.com/118-sunglasses/" target="_blank">fashion sunglasses</a></p>
<p>呵呵，有道理啊</p>
<p>2012年6月29日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://www.seobokes.com/" title="Lee小漫" target="_blank"><img src="" alt="Lee小漫"></a></li>
</ul>
<p><a href="http://www.seobokes.com/" target="_blank">Lee小漫</a></p>
<p>很给力的文章啊。。呵呵</p>
<p>2012年6月29日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="wclssdn"></li>
</ul>
<p>wclssdn</p>
<p>你的公式只写了出来. 没有对公式中每个字母的含义进行说明.. 菜鸟看不懂啊...</p>
<p>2012年7月4日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="Sen Li"></li>
</ul>
<p>Sen Li</p>
<p>很喜欢你的博文，总是喜欢看看以前看过的看看有没有新的理解
貌似有一个小错误。。
那么我们考虑P’ = 小于等于P的所有素数的乘积+1
应该是 那么我们考虑P’ = 小于等于P的&gt;&gt;所有正整数&lt;&lt;的乘积+1 吧- -
看了半天。。。</p>
<p>2012年8月6日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="Sen Li"></li>
</ul>
<p>Sen Li</p>
<p>还有 而素数的等价定义就是“不能被小于它的所有素数整除。。。貌似也应该是正整数</p>
<p>2012年8月6日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://weibo.com/2836493162" title="messi--forever" target="_blank"><img src="" alt="messi--forever"></a></li>
</ul>
<p><a href="http://weibo.com/2836493162" target="_blank">messi--forever</a></p>
<p>博主写得也没错吧。如果不能被小于它的所有素数整除，那肯定不能被正整数整除啊。你倒过来想，如果一个数n可以被小于它的正整数整除，那n就一定可以被某个小于n的素数整除。因为如果那个正整数是素数，自然成立；如果那个正整数是合数，那么n肯定能被这个整数的素因数整除（合数至少有一个素因子）。</p>
<p>2012年12月14日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="imao"></li>
</ul>
<p>imao</p>
<p>“首当其冲”的好处么？</p>
<p>2012年9月21日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://weibo.com/ericv72" title="Eric_V72" target="_blank"><img src="" alt="Eric_V72"></a></li>
</ul>
<p><a href="http://weibo.com/ericv72" target="_blank">Eric_V72</a></p>
<p>不错</p>
<p>2012年12月3日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><a href="http://weibo.com/2708024482" title="陈文哲yy" target="_blank"><img src="" alt="陈文哲yy"></a></li>
</ul>
<p><a href="http://weibo.com/2708024482" target="_blank">陈文哲yy</a></p>
<p>其实做任何事情都要有个度，过犹不及，重要的是怎么把握这个度..</p>
<p>4月27日<a href="">回复</a><a href="">顶</a><a href="">转发</a></p>
<ul>
<li><img src="" alt="wang"></li>
</ul>
<p>wang</p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/好文摘录/">好文摘录</a></li></span></span> | <span class="time">recent updated:<time title="2014-03-07 11:29:23"datetime="2014-03-07 11:29:23"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/03/2014-02-03--知其所以然（续）/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-03--知其所以然（续）" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>





<ul id="pagination" class="pagination pagination-lg">
  <li><a class="extend prev" href="/page/3/">&laquo;</a></li><li><a class="page-number" href="/">1</a></li><li><a class="page-number" href="/page/2/">2</a></li><li><a class="page-number" href="/page/3/">3</a></li><li class="active"><li><span class="page-number current">4</span></li><li><a class="page-number" href="/page/5/">5</a></li><li><a class="page-number" href="/page/6/">6</a></li><li><a class="page-number" href="/page/7/">7</a></li><li><span class="space">&hellip;</span></li></li><li><a class="page-number" href="/page/164/">164</a></li><li><a class="page-number" href="/page/165/">165</a></li><li><a class="extend next" href="/page/5/">&raquo;</a></li>
  <div class="clearfix"></div>
</ul></div><!--wapper-->
       </div><!-- ID main-col END -->
       <aside id="sidebar" class="alignright col-sx-6 col-sm-4 col-md-3 col-lg-3">
<div id="widget_search" class="widget panel panel-primary">
    <form action="//google.com/search" method="get" accept-charset="utf-8">
  <div class="input-group">
    <input class="form-control" id="searchbox" type="search" name="q" results="0" placeholder="search">
    <span class="input-group-btn">
      <button class="btn btn-default" type="submit">Go!</button>
    </span>
    <input type="hidden" name="q" value="site:itsolife.com">
  </div>
</form>
</div>

<div id="widget_category" class="widget panel panel-primary">
  <div class="panel-heading">category</div>  <div data-src='category' class='ajax_widgets'>正在加载...</div>
</div>

<div id="widget_recent_posts" class="widget panel panel-primary">
  <div class="panel-heading">recent posts</div>  <div data-src='recent_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_tagcloud" class="widget panel panel-primary">
  <div class="panel-heading">tagcloud</div>  <div data-src='tagcloud' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_latest_update_posts" class="widget panel panel-primary">
  <div class="panel-heading">最近更新</div>  <div data-src='latest_update_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_recent_comments" class="widget panel panel-primary">
  <div class="panel-heading">recent comments</div>  

<div class="list-group-item ds-recent-comments" data-num-items="6" data-show-avatars="1" data-show-time="1" data-show-title="1" data-show-admin="1" data-excerpt-length="50"></div>



</div>

</aside>
       <div class="clearfix"></div>
     </div><!-- row END -->
  </div>
  <footer id="footer" class="container">
  <div class="panel panel-info">
  <section id='footer_widget'></section>  <div class="panel-footer">
  <div id="site-info">
    <span class='author'>
  
  &copy; 2014 RobinChia
  
    &nbsp;&nbsp;</span>
  
  <span id='analytics-51la'></span><span id='analytics-google'>
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-48559895-1']);
  _gaq.push(['_trackPageview']);
  _js2load.push({src:('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'});
</script></span><span id='analytics-cnzz'>
<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_5774006'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s17.cnzz.com/stat.php%3Fid%3D5774006%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>
</span><span id='analytics-baidu'>
<script>
var _hmt = _hmt || [];
_js2load.push({src:"//hm.baidu.com/hm.js?1442f50724afc42380b51f097c43082c"});
</script>
</span>  </div>
  <div id="copyright">Blog powered by <a href='http://zespia.tw/hexo/'><strong>hexo</strong></a> Theme <strong><a href='https://github.com/chenall/hexo-theme-chenall'>chenall</a></strong>(Some change in it)<span class="pull-right"> 更新时间: <em>2014-03-23 21:54:37</em></span></div>
</div>
<div class="clearfix"></div>


  </div>
  </footer>
  
        <script src="http://cdn.bootcss.com/jquery/1.10.2/jquery.min.js"></script>        
        <script src="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/js/bootstrap.min.js"></script>        
                
        <script src="http://cdn.bootcss.com/prettify/r298/prettify.min.js"></script>    <script type="text/javascript">
   var lang=["bsh", "c", "cc", "cpp", "cs", "csh", "cyc", "cv", "htm", "html",
    "java", "js", "m", "mxml", "perl", "pl", "pm", "py", "rb", "sh",
    "xhtml", "xml", "xsl"];
   var pretty_base='';
   $('script').each(function(){
	var c = $(this).attr('src');
	if (!c)
	    return;
	if (c.match(/(\/)?prettify(\.min)?\.js/i))
	{
	    var index = c.lastIndexOf('/');
	    if (index != -1)
		pretty_base = c.substr(0,index + 1);
	    return false;
	}
   })
   $('pre code').each(function(){
	var c = $(this).attr('class')
	if (!c)
	    return;
	c = c.match(/\s?(lang\-\w+)/i);
	if (c && lang.indexOf(c[1]) == -1)
	{
	    lang.push(c[1]);
	    $.getScript(pretty_base + c[1] + '.min.js');
	}
   })

    $(window).load(function(){
       $("pre").addClass("prettyprint");
       prettyPrint();
    })
</script>    
            <script type="text/javascript">
var duoshuoQuery = {short_name:"robinchia"};
_js2load.push({src:'http://static.duoshuo.com/embed.js',charset:'UTF-8'});
</script>
    
            <!--wumii_relatedItems-->
    
        <script src="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js"></script>    <script type="text/javascript">
(function($){
  $('.entry').each(function(i){
    $(this).find('img').each(function(){
      var alt = this.alt;

      if (alt){
        $(this).before('<span class="caption">' + alt + '</span>');
      }

      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox" rel="fancybox' + i + '" />');
    });
  });

  $('.fancybox').fancybox();
})(jQuery);
</script>    
        <script src="http://cdn.bootcss.com/mathjax/2.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>    <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>
    
<script type="text/javascript">
$('.ajax_widgets').each(function(){var src=$(this).attr('data-src');if(src)$(this).load('/widgets/'+src+'.html');});
$.each(_js2load,function(index,obj){loadjs(obj.src,obj.charset)});
</script>

<div id="scroll2top">
<img src="/scroll2top/arrow.png"/>
</div>
<script src="/scroll2top/scroll2top.min.js"></script>
<div id="winterland">
  <canvas></canvas>
</div>
<script src="/js/winterland.min.js"></script>

  </body>
</html>
