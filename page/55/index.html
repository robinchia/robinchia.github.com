
<!DOCTYPE HTML>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>The 55 Page | It so life</title>
<meta name="author" content="RobinChia">

<meta name="description" content="It so life">


<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<meta property="og:site_name" content="It so life"/>

<!--[if IE]><style>.testIE.IE{display:inline;}</style><![endif]-->
<!--[if lte IE 7]><link rel="stylesheet" href="/css/ie7.css" type="text/css"><![endif]-->
<!--[if (lt IE 9)&(gt IE 7)]><style>.testIE.IE8{display:inline;}</style><![endif]-->
<!--[if gt IE 8]><style>.testIE.IE9{display:inline;}</style><![endif]-->

<link href="/favicon.png" rel="icon">
<link rel="alternate" href="/atom.xml" title="It so life Feed" type="application/atom+xml">

<link rel="stylesheet" href="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/css/bootstrap.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/font-awesome/4.0.3/css/font-awesome.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/prettify/r298/prettify.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" type="text/css">
<link rel="stylesheet" href="/css/style.css" type="text/css">
<!--[if lt IE 9]>
   <style>article,aside,dialog,footer,header,section,footer,nav,figure,menu{display:block}</style>
   <script src="http://cdn.staticfile.org/html5shiv/r29/html5.min.js"></script>
   <script src="http://cdn.staticfile.org/respond.js/1.4.2/respond.min.js"></script>
<link href="http://cdn.staticfile.org/respond.js/1.4.2/respond-proxy.html" id="respond-proxy" rel="respond-proxy" />
<link href="/js/respond.proxy.gif" id="respond-redirect" rel="respond-redirect" />
<script src="/js/respond.proxy.js"></script>
   <script src="http://cdn.bootcss.com/selectivizr/1.0.2/selectivizr-min.js"></script>
<![endif]-->
<script type="text/javascript">
function loadjs(c,d){var a=document.createElement("script");a.async=!0;a.type="text/javascript";a.src=c;a.charset=d||"gbk";(document.getElementsByTagName("HEAD")[0]||document.getElementsByTagName("BODY")[0]).appendChild(a)};
var _protocol = (("https:" == document.location.protocol) ? " https://" : " http://");
var _js2load = [];
</script>

</head>
<body>
      <header id="header" class="container"><nav id="main-nav" class="navbar navbar-default navbar-fixed-top " role="navigation">
  <div class="container">
    <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
      <span class="sr-only">Toggle navigation</span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="/">It so life</a>
    </div>
    <div  class="collapse navbar-collapse">
      <ul  class="nav navbar-nav">
  
        <li><a href="/" title="Home">Home</a></li>      
        <li><a href="/about/" title="About">About</a></li>      
        <li><a href="/archives/" title="Archives">Archives</a></li>      
      <li class='dropdown'>
        <a class='dropdown-toggle' data-toggle='dropdown' href='#'>website<b class='caret'></b></a>
        <ul class='dropdown-menu pure-menu-selected'>
    
          <li><a href="//groups.google.com/forum/#!forum/pongba" title="TopLanguage">TopLanguage</a></li>    
          <li><a href="//itpub.net/" title="ITPub">ITPub</a></li>    
          <li><a href="//blog.jobbole.com/" title="Bole">Bole</a></li>    
          <li><a href="//nosql-database.org/" title="nosql">nosql</a></li>    
          <li><a href="//gitimmersion.googol.im/" title="Git">Git</a></li>    
        </ul>
      </li>
    
      </ul>
      <ul class="nav navbar-nav navbar-right">
      
        <li><a href="/atom.xml">RSS</a></li>
      
      
        <li><a href="https://twitter.com/robinchia">twitter</a></li>
      
      
      
      
        <li><a href="https://github.com/robinchia">github</a></li>
      
      </ul>
    </div>
  </div>
</nav>
<div class="clearfix"></div>
</header>
  <div id='content' class="container">
     <div class="page-header-wrapper">
      <!--[if lt IE 9]><div class="alert alert-warning alert-dismissable"><button type="button" class="close" data-dismiss="alert" aria-hidden="true">&times;</button><strong>提示:</strong>您的浏览器版本太低了,建议升级到 <strong><a href="http://windows.microsoft.com/zh-cn/internet-explorer/download-ie" title="IE9">IE9</a></strong> 以上,本站使用<a href="https://www.google.com/intl/zh-CN/chrome/">Chrome浏览器</a>可以获得最好的显示效果.</div><![endif]-->
      <div class="page-header"><h1 align="center"><big>It so life</big> </h1>
        <h5 align="center"><big>love as life</big></h5>
      </div>
     </div>
     <div class="row">
       <div id="main-col" class="alignleft col-sx-12 col-sm-8 col-md-9 col-lg-9">
      <section id='header_widget'></section>
          <div id="wrapper"><article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-NIO--JAVANIO总结/">JAVA NIO总结</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:41.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-NIO--JAVANIO总结/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="java-nio-">JAVA NIO总结</h1>
<p>（一）—基本概念</p>
<h2 id="1-">1、输入/输出：概念性描述</h2>
<h3 id="-1-1-i-o-"><a href=""></a>1.1） I/O简介</h3>
<p>I/O  或者输入/输出指的是计算机与外部世界或者一个程序与计算机的其余部分的之间的接口。它对于任何计算机系统都非常关键，因而所有 I/O 的主体实际上是内置在操作系统中的。单独的程序一般是让系统为它们完成大部分的工作。</p>
<p>在 Java 编程中，直到最近一直使用<strong>流</strong>的方式完成 I/O。所有 I/O 都被视为单个的字节的移动，通过一个称为 Stream 的对象一次移动一个字节。流 I/O 用于与外部世界接触。它也在内部使用，用于将对象转换为字节，然后再转换回对象。NIO 与原来的 I/O 有同样的作用和目的，但是它使用不同的方式? <strong>块 I/O</strong>。正如您将在本教程中学到的，块 I/O 的效率可以比流 I/O 高许多。</p>
<h3 id="-1-2-nio-"><a href=""></a>1.2）为什么要使用NIO？</h3>
<p>NIO 的创建目的是为了让 Java 程序员可以实现高速 I/O 而无需编写自定义的本机代码。NIO 将最耗时的 I/O 操作(即填充和提取缓冲区)转移回操作系统，因而可以极大地提高速度。</p>
<h3 id="-1-3-"><a href=""></a>1.3）流与块的比较</h3>
<p>原来的 I/O 库(在 </p>
<p>java.io./*
中) 与 NIO 最重要的区别是数据打包和传输的方式。正如前面提到的，原来的 I/O 以流的方式处理数据，而 NIO 以块的方式处理数据。</p>
<p><strong>面向流*</strong> *的 I/O 系统一次一个字节地处理数据。一个输入流产生一个字节的数据，一个输出流消费一个字节的数据。为流式数据创建过滤器非常容易。链接几个过滤器，以便每个过滤器只负责单个复杂处理机制的一部分，这样也是相对简单的。不利的一面是，面向流的 I/O 通常相当慢。</p>
<p>一个 <strong>面向块*</strong> *的 I/O 系统以块的形式处理数据。每一个操作都在一步中产生或者消费一个数据块。按块处理数据比按(流式的)字节处理数据要快得多。但是面向块的 I/O 缺少一些面向流的 I/O 所具有的优雅性和简单性。</p>
<h3 id="-1-4-io"><a href=""></a>1.4）集成的IO</h3>
<p>在 JDK 1.4 中原来的 I/O 包和 NIO 已经很好地集成了。 </p>
<p>java.io./*
 已经以 NIO 为基础重新实现了，所以现在它可以利用 NIO 的一些特性。例如， </p>
<p>java.io./*
 包中的一些类包含以块的形式读写数据的方法，这使得即使在更面向流的系统中，处理速度也会更快。</p>
<p>也可以用 NIO 库实现标准 I/O 功能。例如，可以容易地使用块 I/O 一次一个字节地移动数据。但是正如您会看到的，NIO 还提供了原 I/O 包中所没有的许多好处。</p>
<h2 id="-2-"><a href=""></a>2、通道和缓冲区</h2>
<h3 id="-2-1-"><a href=""></a>2.1）概述</h3>
<p>通道 
和 </p>
<p>缓冲区 
是 NIO 中的核心对象，几乎在每一个 I/O 操作中都要使用它们。</p>
<p>通道是对原 I/O 包中的流的模拟。到任何目的地(或来自任何地方)的所有数据都必须通过一个 Channel 对象。一个 Buffer 实质上是一个容器对象。发送给一个通道的所有对象都必须首先放到缓冲区中；同样地，从通道中读取的任何数据都要读到缓冲区中。</p>
<p>在本节中，您会了解到 NIO 中通道和缓冲区是如何工作的。</p>
<h3 id="-2-2-"><a href=""></a>2.2）什么是缓冲区</h3>
<p>Buffer
 是一个对象， 它包含一些要写入或者刚读出的数据。 在 NIO 中加入 </p>
<p>Buffer
 对象，体现了新库与原 I/O 的一个重要区别。在面向流的 I/O 中，您将数据直接写入或者将数据直接读到 </p>
<p>Stream
 对象中。</p>
<p>在 NIO 库中，所有数据都是用缓冲区处理的。在读取数据时，它是直接读到缓冲区中的。在写入数据时，它是写入到缓冲区中的。任何时候访问 NIO 中的数据，您都是将它放到缓冲区中。</p>
<p>缓冲区实质上是一个数组。通常它是一个字节数组，但是也可以使用其他种类的数组。但是一个缓冲区不 <em>仅仅 </em>是一个数组。缓冲区提供了对数据的结构化访问，而且还可以跟踪系统的读/写进程。</p>
<h3 id="-2-3-"><a href=""></a>2.3）缓冲区类型</h3>
<p>最常用的缓冲区类型是 </p>
<p>ByteBuffer
。一个 </p>
<p>ByteBuffer
 可以在其底层字节数组上进行 get/set 操作(即字节的获取和设置)。</p>
<p>ByteBuffer
 不是 NIO 中唯一的缓冲区类型。事实上，对于每一种基本 Java 类型都有一种缓冲区类型：</p>
<ul>
<li>ByteBuffer</li>
<li>CharBuffer</li>
<li>ShortBuffer</li>
<li>IntBuffer</li>
<li>LongBuffer</li>
<li>FloatBuffer</li>
<li>DoubleBuffer</li>
</ul>
<p>每一个 </p>
<p>Buffer
 类都是 </p>
<p>Buffer
 接口的一个实例。 除了 </p>
<p>ByteBuffer
，每一个 Buffer 类都有完全一样的操作，只是它们所处理的数据类型不一样。因为大多数标准 I/O 操作都使用 </p>
<p>ByteBuffer
，所以它具有所有共享的缓冲区操作以及一些特有的操作。</p>
<p>现在您可以花一点时间运行 UseFloatBuffer.java，它包含了类型化的缓冲区的一个应用例子。</p>
<h3 id="-2-4-"><a href=""></a>2.4）什么是通道</h3>
<p>Channel
是一个对象，可以通过它读取和写入数据。拿 NIO 与原来的 I/O 做个比较，通道就像是流。</p>
<p>正如前面提到的，所有数据都通过 </p>
<p>Buffer
 对象来处理。您永远不会将字节直接写入通道中，相反，您是将数据写入包含一个或者多个字节的缓冲区。同样，您不会直接从通道中读取字节，而是将数据从通道读入缓冲区，再从缓冲区获取这个字节。</p>
<h3 id="-2-5-"><a href=""></a>2.5）通道类型</h3>
<p>通道与流的不同之处在于通道是双向的。而流只是在一个方向上移动(一个流必须是 </p>
<p>InputStream
 或者 </p>
<p>OutputStream
 的子类)， 而 </p>
<p>通道 
可以用于读、写或者同时用于读写。因为它们是双向的，所以通道可以比流更好地反映底层操作系统的真实情况。特别是在 UNIX 模型中，底层操作系统通道是双向的。</p>
<h2 id="-3-nio-"><a href=""></a>3、从理论到实践：NIO的读和写</h2>
<h3 id="-3-1-"><a href=""></a>3.1）概述</h3>
<p>读和写是 I/O 的基本过程。从一个通道中读取很简单：只需创建一个缓冲区，然后让通道将数据读到这个缓冲区中。写入也相当简单：创建一个缓冲区，用数据填充它，然后让通道用这些数据来执行写入操作。</p>
<p>在本节中，我们将学习有关在 Java 程序中读取和写入数据的一些知识。我们将回顾 NIO 的主要组件(缓冲区、通道和一些相关的方法)，看看它们是如何交互以进行读写的。在接下来的几节中，我们将更详细地分析这其中的每个组件以及其交互。<strong>所有例子代码下载请点击<a href="http://www.ibm.com/developerworks/cn/education/java/j-nio/nio-src.zip" target="_blank">例子代码</a>。</strong></p>
<h3 id="-3-2-"><a href=""></a>3.2）从文件中读取</h3>
<p>在我们第一个练习中，我们将从一个文件中读取一些数据。如果使用原来的 I/O，那么我们只需创建一个 </p>
<p>FileInputStream
 并从它那里读取。而在 NIO 中，情况稍有不同：我们首先从 </p>
<p>FileInputStream
 获取一个 </p>
<p>FileInputStream
 对象，然后使用这个通道来读取数据。</p>
<p>在 NIO 系统中，任何时候执行一个读操作，您都是从通道中读取，但是您<strong>不是直接*</strong> *从通道读取。因为所有数据最终都驻留在缓冲区中，所以您是从通道读到缓冲区中。</p>
<p>因此读取文件涉及三个步骤：(1) 从 </p>
<p>FileInputStream
 获取 </p>
<p>Channel
，(2) 创建 </p>
<p>Buffer
，(3) 将数据从 </p>
<p>Channel
 读到 </p>
<p>Buffer 
中。现在，让我们看一下这个过程。</p>
<h3 id="-3-3-"><a href=""></a>3.3）三个容易的步骤</h3>
<p>第一步是获取通道。我们从 </p>
<p>FileInputStream
 获取通道：
FileInputStream fin = new FileInputStream( &quot;readandshow.txt&quot; );</p>
<p>FileChannel fc = fin.getChannel();</p>
<p>下一步是创建缓冲区：
ByteBuffer buffer = ByteBuffer.allocate( 1024 );</p>
<p>最后，需要将数据从通道读到缓冲区中，如下所示：
fc.read( buffer );</p>
<p>您会注意到，我们不需要告诉通道要读 <em>多少数据 </em>到缓冲区中。每一个缓冲区都有复杂的内部统计机制，它会跟踪已经读了多少数据以及还有多少空间可以容纳更多的数据。我们将在 <strong>缓冲区内部细节</strong> 中介绍更多关于缓冲区统计机制的内容。</p>
<h3 id="-3-4-"><a href=""></a>3.4）写入文件</h3>
<p>在 NIO 中写入文件类似于从文件中读取。首先从 </p>
<p>FileOutputStream
 获取一个通道：
FileOutputStream fout = new FileOutputStream( &quot;writesomebytes.txt&quot; );</p>
<p>FileChannel fc = fout.getChannel();</p>
<p>下一步是创建一个缓冲区并在其中放入一些数据 - 在这里，数据将从一个名为 </p>
<p>message
 的数组中取出，这个数组包含字符串 &quot;Some bytes&quot; 的 ASCII 字节(本教程后面将会解释 </p>
<p>buffer.flip()
 和 </p>
<p>buffer.put()
 调用)。
ByteBuffer buffer = ByteBuffer.allocate( 1024 );</p>
<p>for (int i=0; i&lt;message.length; ++i) {</p>
<pre><code> buffer.put( message[i] );
</code></pre><p>}</p>
<p>buffer.flip();</p>
<p>最后一步是写入通道中：
fc.write( buffer );</p>
<p>注意在这里同样不需要告诉通道要写入多数据。缓冲区的内部统计机制会跟踪它包含多少数据以及还有多少数据要写入。</p>
<h3 id="-3-5-"><a href=""></a>3.5）读写结合</h3>
<p>下面我们将看一下在结合读和写时会有什么情况。我们以一个名为 CopyFile.java 的简单程序作为这个练习的基础，它将一个文件的所有内容拷贝到另一个文件中。CopyFile.java 执行三个基本操作：首先创建一个 </p>
<p>Buffer
，然后从源文件中将数据读到这个缓冲区中，然后将缓冲区写入目标文件。这个程序不断重复 ― 读、写、读、写 ― 直到源文件结束。</p>
<p>CopyFile 程序让您看到我们如何检查操作的状态，以及如何使用 </p>
<p>clear()
 和 </p>
<p>flip()
 方法重设缓冲区，并准备缓冲区以便将新读取的数据写到另一个通道中。</p>
<h3 id="-copyfile-"><a href=""></a>运行CopyFile例子</h3>
<p>因为缓冲区会跟踪它自己的数据，所以 CopyFile 程序的内部循环 (inner loop) 非常简单，如下所示：
fcin.read( buffer );</p>
<p>fcout.write( buffer );</p>
<p>第一行将数据从输入通道 </p>
<p>fcin
 中读入缓冲区，第二行将这些数据写到输出通道 </p>
<p>fcout
 。</p>
<h3 id="-"><a href=""></a>检查状态</h3>
<p>下一步是检查拷贝何时完成。当没有更多的数据时，拷贝就算完成，并且可以在 </p>
<p>read()
 方法返回 -1 是判断这一点，如下所示：
int r = fcin.read( buffer );</p>
<p>if (r==-1) {</p>
<pre><code> break;
</code></pre><p>}</p>
<h3 id="-"><a href=""></a>重设缓冲区</h3>
<p>最后，在从输入通道读入缓冲区之前，我们调用 </p>
<p>clear()
 方法。同样，在将缓冲区写入输出通道之前，我们调用 </p>
<p>flip()
 方法，如下所示：</p>
<p>buffer.clear();</p>
<p>int r = fcin.read( buffer );</p>
<p>if (r==-1) {
     break;</p>
<p>}</p>
<p>buffer.flip();
fcout.write( buffer );</p>
<p>clear()
 方法重设缓冲区，使它可以接受读入的数据。 </p>
<p>flip()
 方法让缓冲区可以将新读入的数据写入另一个通道。</p>
<p>来源： <a href="[http://blog.csdn.net/ssjhust123/article/details/7904757](http://blog.csdn.net/ssjhust123/article/details/7904757)">[http://blog.csdn.net/ssjhust123/article/details/7904757](http://blog.csdn.net/ssjhust123/article/details/7904757)</a> </p>
<p><a href="http://blog.csdn.net/ssjhust123/article/details/7905278" target="_blank">（二）—缓冲区原理</a></p>
<h2 id="4-">4、缓冲区的内部细节</h2>
<h3 id="-"><a href=""></a><strong>概述</strong></h3>
<p>本节将介绍 NIO 中两个重要的缓冲区组件：状态变量和访问方法 (accessor)。</p>
<p>状态变量是前一节中提到的&quot;内部统计机制&quot;的关键。每一个读/写操作都会改变缓冲区的状态。通过记录和跟踪这些变化，缓冲区就可能够内部地管理自己的资源。</p>
<p>在从通道读取数据时，数据被放入到缓冲区。在有些情况下，可以将这个缓冲区直接写入另一个通道，但是在一般情况下，您还需要查看数据。这是使用 <em>访问方法 </em></p>
<p>get()
 来完成的。同样，如果要将原始数据放入缓冲区中，就要使用访问方法 </p>
<p>put()
。</p>
<p>在本节中，您将学习关于 NIO 中的状态变量和访问方法的内容。我们将描述每一个组件，并让您有机会看到它的实际应用。虽然 NIO 的内部统计机制初看起来可能很复杂，但是您很快就会看到大部分的实际工作都已经替您完成了。您可能习惯于通过手工编码进行簿记 ― 即使用字节数组和索引变量，现在它已在 NIO 中内部地处理了。</p>
<h3 id="-"><a href=""></a>状态变量</h3>
<p>可以用三个值指定缓冲区在任意时刻的状态：</p>
<ul>
<li>position</li>
<li>limit</li>
<li>capacity</li>
</ul>
<p>这三个变量一起可以跟踪缓冲区的状态和它所包含的数据。我们将在下面的小节中详细分析每一个变量，还要介绍它们如何适应典型的读/写(输入/输出)进程。在这个例子中，我们假定要将数据从一个输入通道拷贝到一个输出通道。</p>
<h3 id="-position"><a href=""></a>position</h3>
<p>您可以回想一下，缓冲区实际上就是美化了的数组。在从通道读取时，您将所读取的数据放到底层的数组中。 </p>
<p>position
 变量跟踪已经写了多少数据。更准确地说，它指定了下一个字节将放到数组的哪一个元素中。因此，如果您从通道中读三个字节到缓冲区中，那么缓冲区的 </p>
<p>position
 将会设置为3，指向数组中第四个元素。</p>
<p>同样，在写入通道时，您是从缓冲区中获取数据。 </p>
<p>position
 值跟踪从缓冲区中获取了多少数据。更准确地说，它指定下一个字节来自数组的哪一个元素。因此如果从缓冲区写了5个字节到通道中，那么缓冲区的 </p>
<p>position
 将被设置为5，指向数组的第六个元素。</p>
<h3 id="-"><a href=""></a></h3>
<p>limit</p>
<p>limit
 变量表明还有多少数据需要取出(在从缓冲区写入通道时)，或者还有多少空间可以放入数据(在从通道读入缓冲区时)。</p>
<p>position
 总是小于或者等于 </p>
<p>limit
。</p>
<h3 id="-capacity-"><a href=""></a><strong>capacity</strong></h3>
<p>缓冲区的 </p>
<p>capacity
 表明可以储存在缓冲区中的最大数据容量。实际上，它指定了底层数组的大小 ― 或者至少是指定了准许我们使用的底层数组的容量。</p>
<p>limit
 决不能大于 </p>
<p>capacity
。</p>
<h3 id="-"><a href=""></a><strong>观察变量</strong></h3>
<p>我们首先观察一个新创建的缓冲区。出于本例子的需要，我们假设这个缓冲区的 </p>
<p>总容量 
为8个字节。 </p>
<p>Buffer
 的状态如下所示：
<img src="" alt="Buffer state"> </p>
<p>回想一下 ，</p>
<p>limit
 决不能大于 </p>
<p>capacity
，此例中这两个值都被设置为 8。我们通过将它们指向数组的尾部之后(如果有第8个槽，则是第8个槽所在的位置)来说明这点。
<img src="" alt="Array"> </p>
<p>position
 设置为0。如果我们读一些数据到缓冲区中，那么下一个读取的数据就进入 slot 0 。如果我们从缓冲区写一些数据，从缓冲区读取的下一个字节就来自 slot 0 。 </p>
<p>position
 设置如下所示：
<img src="" alt="Position setting"> </p>
<p>由于 </p>
<p>capacity
 不会改变，所以我们在下面的讨论中可以忽略它。</p>
<h3 id="-"><a href=""></a><strong>第一次读取</strong></h3>
<p>现在我们可以开始在新创建的缓冲区上进行读/写操作。首先从输入通道中读一些数据到缓冲区中。第一次读取得到三个字节。它们被放到数组中从 </p>
<p>position
 开始的位置，这时 position 被设置为 0。读完之后，position 就增加到 3，如下所示：
<img src="" alt="Position increased to 3"> </p>
<p>limit
 没有改变。</p>
<h3 id="-"><a href=""></a><strong>第二次读取</strong></h3>
<p>在第二次读取时，我们从输入通道读取另外两个字节到缓冲区中。这两个字节储存在由 </p>
<p>position
 所指定的位置上， </p>
<p>position
 因而增加 2：
<img src="" alt="Position increased by 2"> </p>
<p>limit
 没有改变。</p>
<h3 id="-flip-"><a href=""></a><strong>flip</strong></h3>
<p>现在我们要将数据写到输出通道中。在这之前，我们必须调用 </p>
<p>flip()
 方法。这个方法做两件非常重要的事：</p>
<ol>
<li>它将 </li>
</ol>
<p>limit
 设置为当前 </p>
<p>position
。</p>
<ol>
<li>它将 </li>
</ol>
<p>position
 设置为 0。</p>
<p>前一小节中的图显示了在 flip 之前缓冲区的情况。下面是在 flip 之后的缓冲区：
<img src="" alt="Buffer after the flip"> </p>
<p>我们现在可以将数据从缓冲区写入通道了。 </p>
<p>position
 被设置为 0，这意味着我们得到的下一个字节是第一个字节。 </p>
<p>limit
 已被设置为原来的 </p>
<p>position
，这意味着它包括以前读到的所有字节，并且一个字节也不多。</p>
<h3 id="-"><a href=""></a><strong>第一次写入</strong></h3>
<p>在第一次写入时，我们从缓冲区中取四个字节并将它们写入输出通道。这使得 </p>
<p>position
 增加到 4，而 </p>
<p>limit
 不变，如下所示：
<img src="" alt="Position advanced to 4, limit unchanged"> </p>
<h3 id="-"><a href=""></a><strong>第二次写入</strong></h3>
<p>我们只剩下一个字节可写了。 </p>
<p>limit
在我们调用 </p>
<p>flip()
 时被设置为 5，并且 </p>
<p>position
 不能超过 </p>
<p>limit
。所以最后一次写入操作从缓冲区取出一个字节并将它写入输出通道。这使得 </p>
<p>position
 增加到 5，并保持 </p>
<p>limit
 不变，如下所示：
<img src="" alt="Position advanced to 5, limit unchanged"> </p>
<h3 id="-clear-"><a href=""></a><strong>clear</strong></h3>
<p>最后一步是调用缓冲区的 </p>
<p>clear()
 方法。这个方法重设缓冲区以便接收更多的字节。 </p>
<p>Clear
 做两种非常重要的事情：</p>
<ol>
<li>它将 </li>
</ol>
<p>limit
 设置为与 </p>
<p>capacity
 相同。</p>
<ol>
<li>它设置 </li>
</ol>
<p>position
 为 0。</p>
<p>下图显示了在调用 </p>
<p>clear()
 后缓冲区的状态：
<img src="" alt="State of the buffer after clear() has been called"> </p>
<p>缓冲区现在可以接收新的数据了。</p>
<p><strong>访问方法</strong></p>
<p>到目前为止，我们只是使用缓冲区将数据从一个通道转移到另一个通道。然而，程序经常需要直接处理数据。例如，您可能需要将用户数据保存到磁盘。在这种情况下，您必须将这些数据直接放入缓冲区，然后用通道将缓冲区写入磁盘。</p>
<p>或者，您可能想要从磁盘读取用户数据。在这种情况下，您要将数据从通道读到缓冲区中，然后检查缓冲区中的数据。</p>
<p>在本节的最后，我们将详细分析如何使用 </p>
<p>ByteBuffer
 类的 </p>
<p>get()
 和 </p>
<p>put()
 方法直接访问缓冲区中的数据</p>
<h3 id="-"><a href=""></a></h3>
<p>get()方法</p>
<p>ByteBuffer
 类中有四个 </p>
<p>get()
 方法：</p>
<ol>
<li>byte get();</li>
<li>ByteBuffer get( byte dst[] );</li>
<li>ByteBuffer get( byte dst[], int offset, int length );</li>
<li>byte get( int index );</li>
</ol>
<p>第一个方法获取单个字节。第二和第三个方法将一组字节读到一个数组中。第四个方法从缓冲区中的特定位置获取字节。那些返回</p>
<p>ByteBuffer
 的方法只是返回调用它们的缓冲区的 </p>
<p>this
 值。</p>
<p>此外，我们认为前三个 </p>
<p>get()
 方法是相对的，而最后一个方法是绝对的。 <em>相对 </em>意味着 </p>
<p>get()
 操作服从 </p>
<p>limit
 和 </p>
<p>position
 值 ― 更明确地说，字节是从当前 </p>
<p>position
 读取的，而 </p>
<p>position
 在 </p>
<p>get
 之后会增加。另一方面，一个 <em>绝对 </em>方法会忽略 </p>
<p>limit
 和 </p>
<p>position
 值，也不会影响它们。事实上，它完全绕过了缓冲区的统计方法。</p>
<p>上面列出的方法对应于 </p>
<p>ByteBuffer
 类。其他类有等价的 </p>
<p>get()
 方法，这些方法除了不是处理字节外，其它方面是是完全一样的，它们处理的是与该缓冲区类相适应的类型。</p>
<h3 id="-put-"><a href=""></a><strong>put()方法</strong></h3>
<p>ByteBuffer
 类中有五个 </p>
<p>put()
 方法：</p>
<ol>
<li>ByteBuffer put( byte b );</li>
<li>ByteBuffer put( byte src[] );</li>
<li>ByteBuffer put( byte src[], int offset, int length );</li>
<li>ByteBuffer put( ByteBuffer src );</li>
<li>ByteBuffer put( int index, byte b );</li>
</ol>
<p>第一个方法 </p>
<p>写入（put） 
单个字节。第二和第三个方法写入来自一个数组的一组字节。第四个方法将数据从一个给定的源</p>
<p>ByteBuffer
 写入这个 </p>
<p>ByteBuffer
。第五个方法将字节写入缓冲区中特定的 </p>
<p>位置 
。那些返回 </p>
<p>ByteBuffer
 的方法只是返回调用它们的缓冲区的 </p>
<p>this
 值。</p>
<p>与 </p>
<p>get()
 方法一样，我们将把 </p>
<p>put()
 方法划分为 <em>相对 </em>或者 <em>绝对 </em>的。前四个方法是相对的，而第五个方法是绝对的。</p>
<p>上面显示的方法对应于 </p>
<p>ByteBuffer
 类。其他类有等价的 </p>
<p>put()
 方法，这些方法除了不是处理字节之外，其它方面是完全一样的。它们处理的是与该缓冲区类相适应的类型。</p>
<h3 id="-get-put-"><a href=""></a>类型化的 get() 和 put() 方法</h3>
<p>除了前些小节中描述的 </p>
<p>get()
 和 </p>
<p>put()
 方法， </p>
<p>ByteBuffer
 还有用于读写不同类型的值的其他方法，如下所示：</p>
<ul>
<li>getByte()</li>
<li>getChar()</li>
<li>getShort()</li>
<li>getInt()</li>
<li>getLong()</li>
<li>getFloat()</li>
<li>getDouble()</li>
<li>putByte()</li>
<li>putChar()</li>
<li>putShort()</li>
<li>putInt()</li>
<li>putLong()</li>
<li>putFloat()</li>
<li>putDouble()</li>
</ul>
<p>事实上，这其中的每个方法都有两种类型 ― 一种是相对的，另一种是绝对的。它们对于读取格式化的二进制数据（如图像文件的头部）很有用。</p>
<p>您可以在例子程序 TypesInByteBuffer.java 中看到这些方法的实际应用。</p>
<h3 id="-"><a href=""></a><strong>缓冲区的使用：一个内部循环</strong></h3>
<p>下面的内部循环概括了使用缓冲区将数据从输入通道拷贝到输出通道的过程。
while (true) {</p>
<pre><code> buffer.clear();
 int r = fcin.read( buffer );


 if (r==-1) {

   break;
 }


 buffer.flip();

 fcout.write( buffer );
</code></pre><p>}</p>
<p>read()
 和 </p>
<p>write()
 调用得到了极大的简化，因为许多工作细节都由缓冲区完成了。 </p>
<p>clear()
 和 </p>
<p>flip()
 方法用于让缓冲区在读和写之间切换。</p>
<p>5、关于缓冲区的更多内容</p>
<p><strong>概述</strong></p>
<p>到目前为止，您已经学习了使用缓冲区进行日常工作所需要掌握的大部分内容。我们的例子没怎么超出标准的读/写过程种类，在原来的 I/O 中可以像在 NIO 中一样容易地实现这样的标准读写过程。</p>
<p>本节将讨论使用缓冲区的一些更复杂的方面，比如缓冲区分配、包装和分片。我们还会讨论 NIO 带给 Java 平台的一些新功能。您将学到如何创建不同类型的缓冲区以达到不同的目的，如可保护数据不被修改的 <em>只读 </em>缓冲区，和直接映射到底层操作系统缓冲区的 <em>直接 </em>缓冲区。我们将在本节的最后介绍如何在 NIO 中创建内存映射文件。</p>
<p><strong>缓冲区分配和包装</strong></p>
<p>在能够读和写之前，必须有一个缓冲区。要创建缓冲区，您必须 <em>分配 </em>它。我们使用静态方法 </p>
<p>allocate()
 来分配缓冲区：
ByteBuffer buffer = ByteBuffer.allocate( 1024 );</p>
<p>allocate()
 方法分配一个具有指定大小的底层数组，并将它包装到一个缓冲区对象中 ― 在本例中是一个 </p>
<p>ByteBuffer
。</p>
<p>您还可以将一个现有的数组转换为缓冲区，如下所示：
byte array[] = new byte[1024];</p>
<p>ByteBuffer buffer = ByteBuffer.wrap( array );</p>
<p>本例使用了 </p>
<p>wrap()
 方法将一个数组包装为缓冲区。必须非常小心地进行这类操作。一旦完成包装，底层数据就可以通过缓冲区或者直接访问。</p>
<p><strong>缓冲区分片</strong></p>
<p>slice()
 方法根据现有的缓冲区创建一种 <em>子缓冲区 </em>。也就是说，它创建一个新的缓冲区，新缓冲区与原来的缓冲区的一部分共享数据。</p>
<p>使用例子可以最好地说明这点。让我们首先创建一个长度为 10 的 </p>
<p>ByteBuffer
：
ByteBuffer buffer = ByteBuffer.allocate( 10 );</p>
<p>然后使用数据来填充这个缓冲区，在第 <em>n</em> 个槽中放入数字 <em>n</em>：
for (int i=0; i&lt;buffer.capacity(); ++i) {</p>
<pre><code> buffer.put( (byte)i );
</code></pre><p>}</p>
<p>现在我们对这个缓冲区 <em>分片 </em>，以创建一个包含槽 3 到槽 6 的子缓冲区。在某种意义上，子缓冲区就像原来的缓冲区中的一个 <em>窗口 </em>。</p>
<p>窗口的起始和结束位置通过设置 </p>
<p>position
 和 </p>
<p>limit
 值来指定，然后调用 </p>
<p>Buffer
 的 </p>
<p>slice()
 方法：
buffer.position( 3 );</p>
<p>buffer.limit( 7 );
ByteBuffer slice = buffer.slice();</p>
<p>片段
是缓冲区的 </p>
<p>子缓冲区 
。不过， </p>
<p>片段
和 </p>
<p>缓冲区
共享同一个底层数据数组，我们在下一节将会看到这一点。</p>
<p><strong>缓冲区分片和数据共享</strong></p>
<p>我们已经创建了原缓冲区的子缓冲区，并且我们知道缓冲区和子缓冲区共享同一个底层数据数组。让我们看看这意味着什么。</p>
<p>我们遍历子缓冲区，将每一个元素乘以 11 来改变它。例如，5 会变成 55。
for (int i=0; i&lt;slice.capacity(); ++i) {</p>
<pre><code> byte b = slice.get( i );
 b /*= 11;

 slice.put( i, b );
</code></pre><p>}</p>
<p>最后，再看一下原缓冲区中的内容：
buffer.position( 0 );</p>
<p>buffer.limit( buffer.capacity() );</p>
<p>while (buffer.remaining()&gt;0) {
     System.out.println( buffer.get() );</p>
<p>}</p>
<p>结果表明只有在子缓冲区窗口中的元素被改变了：
$ java SliceBuffer</p>
<p>0
1</p>
<p>2
33</p>
<p>44
55</p>
<p>66
7</p>
<p>8
9</p>
<p>缓冲区片对于促进抽象非常有帮助。可以编写自己的函数处理整个缓冲区，而且如果想要将这个过程应用于子缓冲区上，您只需取主缓冲区的一个片，并将它传递给您的函数。这比编写自己的函数来取额外的参数以指定要对缓冲区的哪一部分进行操作更容易。</p>
<p><strong>只读缓冲区</strong></p>
<p>只读缓冲区非常简单 ― 您可以读取它们，但是不能向它们写入。可以通过调用缓冲区的 </p>
<p>asReadOnlyBuffer()
 方法，将任何常规缓冲区转换为只读缓冲区，这个方法返回一个与原缓冲区完全相同的缓冲区(并与其共享数据)，只不过它是只读的。</p>
<p>只读缓冲区对于保护数据很有用。在将缓冲区传递给某个对象的方法时，您无法知道这个方法是否会修改缓冲区中的数据。创建一个只读的缓冲区可以 <em>保证 </em>该缓冲区不会被修改。</p>
<p>不能将只读的缓冲区转换为可写的缓冲区。</p>
<p><strong>直接和间接缓冲区</strong></p>
<p>另一种有用的 </p>
<p>ByteBuffer
 是直接缓冲区。 <em>直接缓冲区 </em>是为加快 I/O 速度，而以一种特殊的方式分配其内存的缓冲区。</p>
<p>实际上，直接缓冲区的准确定义是与实现相关的。Sun 的文档是这样描述直接缓冲区的：</p>
<p><em>给定一个直接字节缓冲区，Java 虚拟机将尽最大努力直接对它执行本机 I/O 操作。也就是说，它会在每一次调用底层操作系统的本机 I/O 操作之前(或之后)，尝试避免将缓冲区的内容拷贝到一个中间缓冲区中(或者从一个中间缓冲区中拷贝数据)。</em></p>
<p>您可以在例子程序 FastCopyFile.java 中看到直接缓冲区的实际应用，这个程序是 CopyFile.java 的另一个版本，它使用了直接缓冲区以提高速度。</p>
<p>还可以用内存映射文件创建直接缓冲区。</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/ssjhust123/article/details/7905278#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/ssjhust123/article/details/7905278#" title="copy" target="_blank">copy</a></p>
<ol>
<li>ByteBuffer buffer = ByteBuffer.allocateDirect( 1024 ); //直接缓冲区  </li>
</ol>
<p><strong>内存映射文件I/O</strong></p>
<p>内存映射文件 I/O 是一种读和写文件数据的方法，它可以比常规的基于流或者基于通道的 I/O 快得多。</p>
<p>内存映射文件 I/O 是通过使文件中的数据神奇般地出现为内存数组的内容来完成的。这其初听起来似乎不过就是将整个文件读到内存中，但是事实上并不是这样。一般来说，只有文件中实际读取或者写入的部分才会送入（或者 <em>映射 </em>）到内存中。</p>
<p>内存映射并不真的神奇或者多么不寻常。现代操作系统一般根据需要将文件的部分映射为内存的部分，从而实现文件系统。Java 内存映射机制不过是在底层操作系统中可以采用这种机制时，提供了对该机制的访问。</p>
<p>尽管创建内存映射文件相当简单，但是向它写入可能是危险的。仅只是改变数组的单个元素这样的简单操作，就可能会直接修改磁盘上的文件。修改数据与将数据保存到磁盘是没有分开的。</p>
<p><strong>将文件映射到内存</strong></p>
<p>了解内存映射的最好方法是使用例子。在下面的例子中，我们要将一个 </p>
<p>FileChannel
 (它的全部或者部分)映射到内存中。为此我们将使用 </p>
<p>FileChannel.map()
 方法。下面代码行将文件的前 1024 个字节映射到内存中：
MappedByteBuffer mbb = fc.map( FileChannel.MapMode.READ_WRITE,</p>
<pre><code> 0, 1024 );
</code></pre><p>map()
 方法返回一个 </p>
<p>MappedByteBuffer
，它是 </p>
<p>ByteBuffer
 的子类。因此，您可以像使用其他任何 </p>
<p>ByteBuffer
 一样使用新映射的缓冲区，操作系统会在需要时负责执行行映射。
来源： <a href="[http://blog.csdn.net/ssjhust123/article/details/7905278](http://blog.csdn.net/ssjhust123/article/details/7905278)">[http://blog.csdn.net/ssjhust123/article/details/7905278](http://blog.csdn.net/ssjhust123/article/details/7905278)</a> </p>
<p><a href="http://blog.csdn.net/ssjhust123/article/details/7905367" target="_blank">（三）—分散聚集、文件锁定、字符集</a></p>
<h2 id="6-">6、分散和聚集</h2>
<p><strong>概述</strong></p>
<p>分散/聚集 I/O 是使用多个而不是单个缓冲区来保存数据的读写方法。</p>
<p>一个分散的读取就像一个常规通道读取，只不过它是将数据读到一个缓冲区数组中而不是读到单个缓冲区中。同样地，一个聚集写入是向缓冲区数组而不是向单个缓冲区写入数据。分散/聚集 I/O 对于将数据流划分为单独的部分很有用，这有助于实现复杂的数据格式。</p>
<p><strong>分散/聚集IO</strong></p>
<p>通道可以有选择地实现两个新的接口： </p>
<p>ScatteringByteChannel
 和 </p>
<p>GatheringByteChannel
。一个 </p>
<p>ScatteringByteChannel
 是一个具有两个附加读方法的通道：</p>
<ul>
<li>long read( ByteBuffer[] dsts );</li>
<li>long read( ByteBuffer[] dsts, int offset, int length );</li>
</ul>
<p>这些 </p>
<p>long read()
 方法很像标准的 </p>
<p>read
 方法，只不过它们不是取单个缓冲区而是取一个缓冲区数组。</p>
<p>在 <em>分散读取 </em>中，通道依次填充每个缓冲区。填满一个缓冲区后，它就开始填充下一个。在某种意义上，缓冲区数组就像一个大缓冲区。</p>
<p><em>聚集写入 </em>类似于分散读取，只不过是用来写入。它也有接受缓冲区数组的方法：</p>
<ul>
<li>long write( ByteBuffer[] srcs );</li>
<li>long write( ByteBuffer[] srcs, int offset, int length );</li>
</ul>
<p>聚集写对于把一组单独的缓冲区中组成单个数据流很有用。为了与上面的消息例子保持一致，您可以使用聚集写入来自动将网络消息的各个部分组装为单个数据流，以便跨越网络传输消息。</p>
<p>从例子程序 UseScatterGather.java 中可以看到分散读取和聚集写入的实际应用。</p>
<p><strong>分散/聚集的应用</strong></p>
<p>分散/聚集 I/O 对于将数据划分为几个部分很有用。例如，您可能在编写一个使用消息对象的网络应用程序，每一个消息被划分为固定长度的头部和固定长度的正文。您可以创建一个刚好可以容纳头部的缓冲区和另一个刚好可以容难正文的缓冲区。当您将它们放入一个数组中并使用分散读取来向它们读入消息时，头部和正文将整齐地划分到这两个缓冲区中。</p>
<p>我们从缓冲区所得到的方便性对于缓冲区数组同样有效。因为每一个缓冲区都跟踪自己还可以接受多少数据，所以分散读取会自动找到有空间接受数据的第一个缓冲区。在这个缓冲区填满后，它就会移动到下一个缓冲区。</p>
<h2 id="-7-"><a href=""></a>7、文件锁定</h2>
<p><strong>概述</strong></p>
<p>文件锁定初看起来可能让人迷惑。它 <em>似乎 </em>指的是防止程序或者用户访问特定文件。事实上，文件锁就像常规的 Java 对象锁 ― 它们是 <em>劝告式的（advisory） </em>锁。它们不阻止任何形式的数据访问，相反，它们通过锁的共享和获取赖允许系统的不同部分相互协调。</p>
<p>您可以锁定整个文件或者文件的一部分。如果您获取一个排它锁，那么其他人就不能获得同一个文件或者文件的一部分上的锁。如果您获得一个共享锁，那么其他人可以获得同一个文件或者文件一部分上的共享锁，但是不能获得排它锁。文件锁定并不总是出于保护数据的目的。例如，您可能临时锁定一个文件以保证特定的写操作成为原子的，而不会有其他程序的干扰。</p>
<p>大多数操作系统提供了文件系统锁，但是它们并不都是采用同样的方式。有些实现提供了共享锁，而另一些仅提供了排它锁。事实上，有些实现使得文件的锁定部分不可访问，尽管大多数实现不是这样的。</p>
<p>在本节中，您将学习如何在 NIO 中执行简单的文件锁过程，我们还将探讨一些保证被锁定的文件尽可能可移植的方法。</p>
<p><strong>锁定文件</strong></p>
<p>要获取文件的一部分上的锁，您要调用一个打开的 </p>
<p>FileChannel
 上的 </p>
<p>lock()
 方法。注意，如果要获取一个排它锁，您必须以写方式打开文件。
RandomAccessFile raf = new RandomAccessFile( &quot;usefilelocks.txt&quot;, &quot;rw&quot; );</p>
<p>FileChannel fc = raf.getChannel();
FileLock lock = fc.lock( start, end, false );</p>
<p>在拥有锁之后，您可以执行需要的任何敏感操作，然后再释放锁：
lock.release();</p>
<p>在释放锁后，尝试获得锁的其他任何程序都有机会获得它。</p>
<p>本小节的例子程序 UseFileLocks.java 必须与它自己并行运行。这个程序获取一个文件上的锁，持有三秒钟，然后释放它。如果同时运行这个程序的多个实例，您会看到每个实例依次获得锁。如果两个程序分别获取同一个文件不同位置的锁，则不会阻塞。比如第一个程序获取文件范围为0-20的锁，而第二个程序获取21-40的锁，则会正常执行。</p>
<p><strong>文件锁定和可移植性</strong></p>
<p>文件锁定可能是一个复杂的操作，特别是考虑到不同的操作系统是以不同的方式实现锁这一事实。下面的指导原则将帮助您尽可能保持代码的可移植性：</p>
<ul>
<li>只使用排它锁。</li>
<li>将所有的锁视为劝告式的（advisory）。</li>
</ul>
<p>8、字符集</p>
<p><strong>概述</strong></p>
<p>根据 Sun 的文档，一个 </p>
<p>Charset
 是“十六位 Unicode 字符序列与字节序列之间的一个命名的映射”。实际上，一个 </p>
<p>Charset
 允许您以尽可能最具可移植性的方式读写字符序列。</p>
<p>Java 语言被定义为基于 Unicode。然而在实际上，许多人编写代码时都假设一个字符在磁盘上或者在网络流中用一个字节表示。这种假设在许多情况下成立，但是并不是在所有情况下都成立，而且随着计算机变得对 Unicode 越来越友好，这个假设就日益变得不能成立了。</p>
<p>在本节中，我们将看一下如何使用 </p>
<p>Charsets
 以适合现代文本格式的方式处理文本数据。这里将使用的示例程序相当简单，不过，它触及了使用 </p>
<p>Charset
 的所有关键方面：为给定的字符编码创建 </p>
<p>Charset
，以及使用该 </p>
<p>Charset
 解码和编码文本数据。</p>
<p><a href="http://www.ibm.com/developerworks/cn/education/java/j-nio/section10.html#ibm-pcon" target="_blank">回页首</a></p>
<p><strong>编码/解码</strong></p>
<p>要读和写文本，我们要分别使用 </p>
<p>CharsetDecoder
 和 </p>
<p>CharsetEncoder
。将它们称为 <em>编码器 </em>和 <em>解码器 </em>是有道理的。一个 <em>字符 </em>不再表示一个特定的位模式，而是表示字符系统中的一个实体。因此，由某个实际的位模式表示的字符必须以某种特定的 <em>编码 </em>来表示。</p>
<p>CharsetDecoder
 用于将逐位表示的一串字符转换为具体的 </p>
<p>char
 值。同样，一个 </p>
<p>CharsetEncoder
 用于将字符转换回位。</p>
<p>在下一个小节中，我们将考察一个使用这些对象来读写数据的程序。</p>
<p><a href="http://www.ibm.com/developerworks/cn/education/java/j-nio/section10.html#ibm-pcon" target="_blank">回页首</a></p>
<p><strong>处理文本的正确方式</strong></p>
<p>现在我们将分析这个例子程序 UseCharsets.java。这个程序非常简单 ― 它从一个文件中读取一些文本，并将该文本写入另一个文件。但是它把该数据当作文本数据，并使用 </p>
<p>CharBuffer
 来将该数句读入一个 </p>
<p>CharsetDecoder
 中。同样，它使用 </p>
<p>CharsetEncoder
 来写回该数据。</p>
<p>我们将假设字符以 ISO-8859-1(Latin1) 字符集（这是 ASCII 的标准扩展）的形式储存在磁盘上。尽管我们必须为使用 Unicode 做好准备，但是也必须认识到不同的文件是以不同的格式储存的，而 ASCII 无疑是非常普遍的一种格式。事实上，每种 Java 实现都要求对以下字符编码提供完全的支持：</p>
<ul>
<li>US-ASCII</li>
<li>ISO-8859-1</li>
<li>UTF-8</li>
<li>UTF-16BE</li>
<li>UTF-16LE</li>
<li>UTF-16</li>
</ul>
<p><a href="http://www.ibm.com/developerworks/cn/education/java/j-nio/section10.html#ibm-pcon" target="_blank">回页首</a></p>
<p><strong>示例程序</strong></p>
<p>在打开相应的文件、将输入数据读入名为 </p>
<p>inputData
 的 </p>
<p>ByteBuffer
 之后，我们的程序必须创建 ISO-8859-1 (Latin1) 字符集的一个实例：
Charset latin1 = Charset.forName( &quot;ISO-8859-1&quot; );</p>
<p>然后，创建一个解码器（用于读取）和一个编码器 （用于写入）：
CharsetDecoder decoder = latin1.newDecoder();</p>
<p>CharsetEncoder encoder = latin1.newEncoder();</p>
<p>为了将字节数据解码为一组字符，我们把 </p>
<p>ByteBuffer
 传递给 </p>
<p>CharsetDecoder
，结果得到一个 </p>
<p>CharBuffer
：
CharBuffer cb = decoder.decode( inputData );</p>
<p>如果想要处理字符，我们可以在程序的此处进行。但是我们只想无改变地将它写回，所以没有什么要做的。</p>
<p>要写回数据，我们必须使用 </p>
<p>CharsetEncoder
 将它转换回字节：
ByteBuffer outputData = encoder.encode( cb );</p>
<p>在转换完成之后，我们就可以将数据写到文件中了。
来源： <a href="[http://blog.csdn.net/ssjhust123/article/details/7905367](http://blog.csdn.net/ssjhust123/article/details/7905367)">[http://blog.csdn.net/ssjhust123/article/details/7905367](http://blog.csdn.net/ssjhust123/article/details/7905367)</a> <a href="http://blog.csdn.net/ssjhust123/article/details/7905401" target="_blank">（四）—网络和异步IO</a></p>
<p>9、连网和异步 I/O</p>
<p><strong>概述</strong></p>
<p>连网是学习异步 I/O 的很好基础，而异步 I/O 对于在 Java 语言中执行任何输入/输出过程的人来说，无疑都是必须具备的知识。NIO 中的连网与 NIO 中的其他任何操作没有什么不同 ― 它依赖通道和缓冲区，而您通常使用 </p>
<p>InputStream
 和 </p>
<p>OutputStream
 来获得通道。</p>
<p>本节首先介绍异步 I/O 的基础 ― 它是什么以及它不是什么，然后转向更实用的、程序性的例子。</p>
<p><strong>异步I/O</strong></p>
<p>异步 I/O 是一种 <em>没有阻塞地 </em>读写数据的方法。通常，在代码进行 </p>
<p>read()
 调用时，代码会阻塞直至有可供读取的数据。同样，</p>
<p>write()
 调用将会阻塞直至数据能够写入。</p>
<p>另一方面，异步 I/O 调用不会阻塞。相反，您将注册对特定 I/O 事件的兴趣 ― 可读的数据的到达、新的套接字连接，等等，而在发生这样的事件时，系统将会告诉您。</p>
<p>异步 I/O 的一个优势在于，它允许您同时根据大量的输入和输出执行 I/O。同步程序常常要求助于轮询，或者创建许许多多的线程以处理大量的连接。使用异步 I/O，您可以监听任何数量的通道上的事件，不用轮询，也不用额外的线程。</p>
<p>我们将通过研究一个名为 MultiPortEcho.java 的例子程序来查看异步 I/O 的实际应用。这个程序就像传统的 <em>echo server</em>，它接受网络连接并向它们回响它们可能发送的数据。不过它有一个附加的特性，就是它能同时监听多个端口，并处理来自所有这些端口的连接。并且它只在单个线程中完成所有这些工作。</p>
<p><strong>Selectors</strong></p>
<p>本节的阐述对应于 </p>
<p>MultiPortEcho
 的源代码中的 </p>
<p>go()
 方法的实现，因此应该看一下源代码，以便对所发生的事情有个更全面的了解。</p>
<p>异步 I/O 中的核心对象名为 </p>
<p>Selector
。</p>
<p>Selector
 就是您注册对各种 I/O 事件的兴趣的地方，而且当那些事件发生时，就是这个对象告诉您所发生的事件。</p>
<p>所以，我们需要做的第一件事就是创建一个 </p>
<p>Selector
：
Selector selector = Selector.open();</p>
<p>然后，我们将对不同的通道对象调用 </p>
<p>register()
 方法，以便注册我们对这些对象中发生的 I/O 事件的兴趣。</p>
<p>register()
 的第一个参数总是这个 </p>
<p>Selector
。</p>
<p><strong>打开一个Server Socket Channel</strong></p>
<p>为了接收连接，我们需要一个 </p>
<p>ServerSocketChannel
。事实上，我们要监听的每一个端口都需要有一个 </p>
<p>ServerSocketChannel
 。对于每一个端口，我们打开一个 </p>
<p>ServerSocketChannel
，如下所示：
ServerSocketChannel ssc = ServerSocketChannel.open();</p>
<p>ssc.configureBlocking( false );</p>
<p>ServerSocket ss = ssc.socket();
InetSocketAddress address = new InetSocketAddress( ports[i] );</p>
<p>ss.bind( address );</p>
<p>第一行创建一个新的 </p>
<p>ServerSocketChannel
 ，最后三行将它绑定到给定的端口。第二行将 </p>
<p>ServerSocketChannel
 设置为 <em>非阻塞的 </em>。我们必须对每一个要使用的套接字通道调用这个方法，否则异步 I/O 就不能工作。</p>
<p><strong>选择键</strong></p>
<p>下一步是将新打开的 </p>
<p>ServerSocketChannels
 注册到 </p>
<p>Selector
上。为此我们使用 ServerSocketChannel.register() 方法，如下所示：
SelectionKey key = ssc.register( selector, SelectionKey.OP_ACCEPT );</p>
<p>register()
 的第一个参数总是这个 </p>
<p>Selector
。第二个参数是 </p>
<p>OP_ACCEPT
，这里它指定我们想要监听 <em>accept</em> 事件，也就是在新的连接建立时所发生的事件。这是适用于 </p>
<p>ServerSocketChannel
 的唯一事件类型。</p>
<p>请注意对 </p>
<p>register()
 的调用的返回值。 </p>
<p>SelectionKey
 代表这个通道在此 </p>
<p>Selector
 上的这个注册。当某个 </p>
<p>Selector
 通知您某个传入事件时，它是通过提供对应于该事件的 </p>
<p>SelectionKey
 来进行的。</p>
<p>SelectionKey
 还可以用于取消通道的注册。</p>
<p><strong>内部循环</strong></p>
<p>现在已经注册了我们对一些 I/O 事件的兴趣，下面将进入主循环。使用 </p>
<p>Selectors
 的几乎每个程序都像下面这样使用内部循环：
int num = selector.select();</p>
<p>Set selectedKeys = selector.selectedKeys();</p>
<p>Iterator it = selectedKeys.iterator();</p>
<p>while (it.hasNext()) {
     SelectionKey key = (SelectionKey)it.next();</p>
<pre><code> // ... deal with I/O event ...
</code></pre><p>}</p>
<p>首先，我们调用 </p>
<p>Selector
 的 </p>
<p>select()
 方法。这个方法会阻塞，直到至少有一个已注册的事件发生。当一个或者更多的事件发生时，</p>
<p>select()
 方法将返回所发生的事件的数量。</p>
<p>接下来，我们调用 </p>
<p>Selector
 的 </p>
<p>selectedKeys()
 方法，它返回发生了事件的 </p>
<p>SelectionKey
 对象的一个 </p>
<p>集合 
。</p>
<p>我们通过迭代 </p>
<p>SelectionKeys
 并依次处理每个 </p>
<p>SelectionKey
 来处理事件。对于每一个 </p>
<p>SelectionKey
，您必须确定发生的是什么 I/O 事件，以及这个事件影响哪些 I/O 对象。</p>
<p><strong>监听新连接</strong></p>
<p>程序执行到这里，我们仅注册了 </p>
<p>ServerSocketChannel
，并且仅注册它们“接收”事件。为确认这一点，我们对 </p>
<p>SelectionKey
 调用</p>
<p>readyOps()
 方法，并检查发生了什么类型的事件：
if ((key.readyOps() &amp; SelectionKey.OP_ACCEPT)</p>
<pre><code> == SelectionKey.OP_ACCEPT) {


 // Accept the new connection
 // ...
</code></pre><p>}</p>
<p>可以肯定地说， </p>
<p>readOps()
 方法告诉我们该事件是新的连接。</p>
<p><strong>接收新的连接</strong></p>
<p>因为我们知道这个服务器套接字上有一个传入连接在等待，所以可以安全地接受它；也就是说，不用担心 </p>
<p>accept()
 操作会阻塞：
ServerSocketChannel ssc = (ServerSocketChannel)key.channel();</p>
<p>SocketChannel sc = ssc.accept();</p>
<p>下一步是将新连接的 </p>
<p>SocketChannel
 配置为非阻塞的。而且由于接受这个连接的目的是为了读取来自套接字的数据，所以我们还必须将 </p>
<p>SocketChannel
 注册到 </p>
<p>Selector
上，如下所示：
sc.configureBlocking( false );</p>
<p>SelectionKey newKey = sc.register( selector, SelectionKey.OP_READ );</p>
<p>注意我们使用 </p>
<p>register()
 的 </p>
<p>OP_READ
 参数，将 </p>
<p>SocketChannel
 注册用于 <em>读取 </em>而不是 <em>接受 </em>新连接。</p>
<p><strong>删除处理过的SelectionKey</strong></p>
<p>在处理 </p>
<p>SelectionKey
 之后，我们几乎可以返回主循环了。但是我们必须首先将处理过的 </p>
<p>SelectionKey
 从选定的键集合中删除。如果我们没有删除处理过的键，那么它仍然会在主集合中以一个激活的键出现，这会导致我们尝试再次处理它。我们调用迭代器的</p>
<p>remove()
 方法来删除处理过的 </p>
<p>SelectionKey
：
it.remove();</p>
<p>现在我们可以返回主循环并接受从一个套接字中传入的数据(或者一个传入的 I/O 事件)了。</p>
<p><strong>传入的I/O</strong></p>
<p>当来自一个套接字的数据到达时，它会触发一个 I/O 事件。这会导致在主循环中调用 </p>
<p>Selector.select()
，并返回一个或者多个 I/O 事件。这一次， </p>
<p>SelectionKey
 将被标记为 </p>
<p>OP_READ
 事件，如下所示：
} else if ((key.readyOps() &amp; SelectionKey.OP_READ)</p>
<pre><code> == SelectionKey.OP_READ) {
 // Read the data

 SocketChannel sc = (SocketChannel)key.channel();
 // ...
</code></pre><p>}</p>
<p>与以前一样，我们取得发生 I/O 事件的通道并处理它。在本例中，由于这是一个 echo server，我们只希望从套接字中读取数据并马上将它发送回去。关于这个过程的细节，请参见代码中的源代码 (MultiPortEcho.java)。</p>
<p><strong>回到主循环</strong></p>
<p>每次返回主循环，我们都要调用 </p>
<p>select
 的 </p>
<p>Selector()
方法，并取得一组 </p>
<p>SelectionKey
。每个键代表一个 I/O 事件。我们处理事件，从选定的键集中删除 </p>
<p>SelectionKey
，然后返回主循环的顶部。</p>
<p>这个程序有点过于简单，因为它的目的只是展示异步 I/O 所涉及的技术。在现实的应用程序中，您需要通过将通道从 </p>
<p>Selector
 中删除来处理关闭的通道。而且您可能要使用多个线程。这个程序可以仅使用一个线程，因为它只是一个演示，但是在现实场景中，创建一个线程池来负责 I/O 事件处理中的耗时部分会更有意义。
来源： <a href="[http://blog.csdn.net/ssjhust123/article/details/7905401](http://blog.csdn.net/ssjhust123/article/details/7905401)">[http://blog.csdn.net/ssjhust123/article/details/7905401](http://blog.csdn.net/ssjhust123/article/details/7905401)</a> </p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/NIO/">NIO</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/NIO/" class="label label-success">NIO</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:41"datetime="2014-03-07 09:54:41"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-NIO--JAVANIO总结/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-NIO--JAVANIO总结" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-NIO--JavaNIOAPI详解/">Java NIO API详解</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:41.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-NIO--JavaNIOAPI详解/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="java-nio-api-">Java NIO API详解</h1>
<p><a href="http://www.blogjava.net/19851985lili/" target="_blank">【永恒的瞬间】</a>
☜Give me hapy ☞</p>
<p><a href="http://www.blogjava.net/" target="_blank">BlogJava</a>   <a href="http://www.blogjava.net/19851985lili/" target="_blank">首页</a>      <a href="http://www.blogjava.net/EnterMyBlog.aspx?NewArticle=1" target="_blank">新文章</a>   <a href="http://www.blogjava.net/19851985lili/contact.aspx?id=1" target="_blank">联系</a>   <a href="http://www.blogjava.net/19851985lili/rss" target="_blank">聚合</a><a href="http://www.blogjava.net/19851985lili/rss" target="_blank"><img src="" alt=""></a>   <a href="http://www.blogjava.net/19851985lili/admin/EditPosts.aspx" target="_blank">管理</a>
诱惑的世界,难以自我!
名利的生活,面具包裹!
我们的人生,充当角色!
寂静的深夜,真实自我!
<img src="" alt=""></p>
<h3 id="-">常用链接</h3>
<ul>
<li><a href="http://www.blogjava.net/19851985lili/MyPosts.html" target="_blank">我的随笔</a></li>
<li><a href="http://www.blogjava.net/19851985lili/MyComments.html" target="_blank">我的评论</a></li>
<li><a href="http://www.blogjava.net/19851985lili/OtherPosts.html" target="_blank">我的参与</a></li>
<li><a href="http://www.blogjava.net/19851985lili/RecentComments.html" target="_blank">最新评论</a></li>
</ul>
<h3 id="-3-">留言簿(3)</h3>
<ul>
<li><a href="http://www.blogjava.net/19851985lili/Contact.aspx?id=1" target="_blank">给我留言</a></li>
<li><a href="http://www.blogjava.net/19851985lili/default.aspx?opt=msg" target="_blank">查看公开留言</a></li>
<li><a href="http://www.blogjava.net/19851985lili/admin/MyMessages.aspx" target="_blank">查看私人留言</a></li>
</ul>
<h1 id="-6-">随笔档案(6)</h1>
<ul>
<li><a href="http://www.blogjava.net/19851985lili/archive/2008/05.html" target="_blank">2008年5月 (1)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/archive/2007/05.html" target="_blank">2007年5月 (1)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/archive/2007/04.html" target="_blank">2007年4月 (2)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/archive/2007/02.html" target="_blank">2007年2月 (1)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/archive/2007/01.html" target="_blank">2007年1月 (1)</a></li>
</ul>
<h1 id="-188-">文章分类(188)</h1>
<ul>
<li><a href="http://www.blogjava.net/19851985lili/category/27256.html" target="_blank">Canada (Independent Skilled Worker)(2)</a><a href="http://www.blogjava.net/19851985lili/category/27256.html/rss" title="Subscribe to Canada (Independent Skilled Worker)(2)" target="_blank"><img src="&quot;Subscribe to Canada (Independent Skilled Worker" alt="">(2)&quot;)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/category/26726.html" target="_blank">EJB3.0(4)</a><a href="http://www.blogjava.net/19851985lili/category/26726.html/rss" title="Subscribe to EJB3.0(4)" target="_blank"><img src="&quot;Subscribe to EJB3.0(4" alt="">&quot;)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/category/19161.html" target="_blank">flex2.0(40)</a><a href="http://www.blogjava.net/19851985lili/category/19161.html/rss" title="Subscribe to flex2.0(40)" target="_blank"><img src="&quot;Subscribe to flex2.0(40" alt="">&quot;)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/category/19815.html" target="_blank">flex2Cairngorm(6)</a><a href="http://www.blogjava.net/19851985lili/category/19815.html/rss" title="Subscribe to flex2Cairngorm(6)" target="_blank"><img src="&quot;Subscribe to flex2Cairngorm(6" alt="">&quot;)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/category/18358.html" target="_blank">hibernate(17)</a><a href="http://www.blogjava.net/19851985lili/category/18358.html/rss" title="Subscribe to hibernate(17)" target="_blank"><img src="&quot;Subscribe to hibernate(17" alt="">&quot;)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/category/19706.html" target="_blank">java_code(7)</a><a href="http://www.blogjava.net/19851985lili/category/19706.html/rss" title="Subscribe to java_code(7)" target="_blank"><img src="&quot;Subscribe to java_code(7" alt="">&quot;)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/category/18943.html" target="_blank">JavaBasic(15)</a><a href="http://www.blogjava.net/19851985lili/category/18943.html/rss" title="Subscribe to JavaBasic(15)" target="_blank"><img src="&quot;Subscribe to JavaBasic(15" alt="">&quot;)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/category/18368.html" target="_blank">JAVAEE(20)</a><a href="http://www.blogjava.net/19851985lili/category/18368.html/rss" title="Subscribe to JAVAEE(20)" target="_blank"><img src="&quot;Subscribe to JAVAEE(20" alt="">&quot;)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/category/19705.html" target="_blank">javamail(4)</a><a href="http://www.blogjava.net/19851985lili/category/19705.html/rss" title="Subscribe to javamail(4)" target="_blank"><img src="&quot;Subscribe to javamail(4" alt="">&quot;)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/category/18934.html" target="_blank">Log4j(8)</a><a href="http://www.blogjava.net/19851985lili/category/18934.html/rss" title="Subscribe to Log4j(8)" target="_blank"><img src="&quot;Subscribe to Log4j(8" alt="">&quot;)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/category/22482.html" target="_blank">meshwork(1)</a><a href="http://www.blogjava.net/19851985lili/category/22482.html/rss" title="Subscribe to meshwork(1)" target="_blank"><img src="&quot;Subscribe to meshwork(1" alt="">&quot;)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/category/20441.html" target="_blank">ORACLE(13)</a><a href="http://www.blogjava.net/19851985lili/category/20441.html/rss" title="Subscribe to ORACLE(13)" target="_blank"><img src="&quot;Subscribe to ORACLE(13" alt="">&quot;)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/category/19306.html" target="_blank">server(5)</a><a href="http://www.blogjava.net/19851985lili/category/19306.html/rss" title="Subscribe to server(5)" target="_blank"><img src="&quot;Subscribe to server(5" alt="">&quot;)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/category/18359.html" target="_blank">Spring(6)</a><a href="http://www.blogjava.net/19851985lili/category/18359.html/rss" title="Subscribe to Spring(6)" target="_blank"><img src="&quot;Subscribe to Spring(6" alt="">&quot;)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/category/18360.html" target="_blank">struts(8)</a><a href="http://www.blogjava.net/19851985lili/category/18360.html/rss" title="Subscribe to struts(8)" target="_blank"><img src="&quot;Subscribe to struts(8" alt="">&quot;)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/category/20166.html" target="_blank">Sun_Solaris(11)</a><a href="http://www.blogjava.net/19851985lili/category/20166.html/rss" title="Subscribe to Sun_Solaris(11)" target="_blank"><img src="&quot;Subscribe to Sun_Solaris(11" alt="">&quot;)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/category/19127.html" target="_blank">Tomcat(2)</a><a href="http://www.blogjava.net/19851985lili/category/19127.html/rss" title="Subscribe to Tomcat(2)" target="_blank"><img src="&quot;Subscribe to Tomcat(2" alt="">&quot;)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/category/20208.html" target="_blank">UML(2)</a><a href="http://www.blogjava.net/19851985lili/category/20208.html/rss" title="Subscribe to UML(2)" target="_blank"><img src="&quot;Subscribe to UML(2" alt="">&quot;)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/category/19707.html" target="_blank">Vmware(2)</a><a href="http://www.blogjava.net/19851985lili/category/19707.html/rss" title="Subscribe to Vmware(2)" target="_blank"><img src="&quot;Subscribe to Vmware(2" alt="">&quot;)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/category/20445.html" target="_blank">VSS(2)</a><a href="http://www.blogjava.net/19851985lili/category/20445.html/rss" title="Subscribe to VSS(2)" target="_blank"><img src="&quot;Subscribe to VSS(2" alt="">&quot;)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/category/19285.html" target="_blank">webotx(5)</a><a href="http://www.blogjava.net/19851985lili/category/19285.html/rss" title="Subscribe to webotx(5)" target="_blank"><img src="&quot;Subscribe to webotx(5" alt="">&quot;)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/category/21579.html" target="_blank">Windows x(3)</a><a href="http://www.blogjava.net/19851985lili/category/21579.html/rss" title="Subscribe to Windows x(3)" target="_blank"><img src="&quot;Subscribe to Windows x(3" alt="">&quot;)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/category/19189.html" target="_blank">常用正则表达式 (5)</a><a href="http://www.blogjava.net/19851985lili/category/19189.html/rss" title="Subscribe to 常用正则表达式 (5)" target="_blank"><img src="&quot;Subscribe to 常用正则表达式 (5" alt="">&quot;)</a></li>
</ul>
<h1 id="-206-">文章档案(206)</h1>
<ul>
<li><a href="http://www.blogjava.net/19851985lili/archives/2008/05.html" target="_blank">2008年5月 (10)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/archives/2007/11.html" target="_blank">2007年11月 (2)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/archives/2007/10.html" target="_blank">2007年10月 (4)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/archives/2007/06.html" target="_blank">2007年6月 (5)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/archives/2007/05.html" target="_blank">2007年5月 (21)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/archives/2007/04.html" target="_blank">2007年4月 (33)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/archives/2007/03.html" target="_blank">2007年3月 (10)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/archives/2007/02.html" target="_blank">2007年2月 (58)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/archives/2007/01.html" target="_blank">2007年1月 (63)</a></li>
</ul>
<h1 id="url">URL</h1>
<ul>
<li><a href="http://www.w3school.com.cn/index.html" target="_blank">Web 技术教程</a><a href="http://www.w3school.com.cn/index.html" title="Subscribe to Web 技术教程" target="_blank"><img src="&quot;Subscribe to Web 技术教程&quot;" alt=""></a></li>
<li><a href="http://www.forbeschina.com/cmslive/index.jsp" target="_blank">福布斯中文版</a><a href="http://www.forbeschina.com/cmslive/index.jsp" title="Subscribe to 福布斯中文版" target="_blank"><img src="&quot;Subscribe to 福布斯中文版&quot;" alt=""></a></li>
<li><a href="http://rt.openfoundry.org/Foundry/" target="_blank">自由软体铸造场</a><a href="http://rt.openfoundry.org/Foundry/" title="Subscribe to 自由软体铸造场" target="_blank"><img src="&quot;Subscribe to 自由软体铸造场&quot;" alt=""></a></li>
<li><a href="http://caterpillar.onlyfun.net/GossipCN/index.html" target="_blank">良葛格学习笔记</a><a href="http://caterpillar.onlyfun.net/GossipCN/index.html" title="Subscribe to 良葛格学习笔记" target="_blank"><img src="&quot;Subscribe to 良葛格学习笔记&quot;" alt=""></a></li>
</ul>
<h3 id="-">搜索</h3>
<p>*</p>
<ul>
<li></li>
</ul>
<h3 id="-http-www-blogjava-net-19851985lili-commentsrss-aspx-">最新评论 <a href="http://www.blogjava.net/19851985lili/CommentsRSS.aspx" target="_blank"><img src="" alt=""></a></h3>
<ul>
<li><a href="http://www.blogjava.net/19851985lili/archive/2012/08/27/98475.html#386372" target="_blank">1. re: 研究一下springside的核心部分源代码</a></li>
<li><a href="http://www.easy518.com/" target="_blank"><a href="http://www.easy518.com">http://www.easy518.com</a></a></li>
<li>--美丽说</li>
<li><a href="http://www.blogjava.net/19851985lili/archive/2012/06/08/154836.html#380302" target="_blank">2. re: EJB 简介</a></li>
<li>垃圾</li>
<li>--fff</li>
<li><a href="http://www.blogjava.net/19851985lili/archive/2011/12/27/93705.html#367319" target="_blank">3. webotx https 如何配置</a></li>
<li>你好，请问WebOTX如何配置https服务呢？
如果可以，在线等哦。 谢谢。。。。</li>
<li>--janson</li>
<li><a href="http://www.blogjava.net/19851985lili/archive/2010/11/22/97631.html#338704" target="_blank">4. 你好</a></li>
<li>长须鲸努力掉书袋事故 GUDDSUDUSADSIAUDSFYDIDFSLIFAFSDYIO8YFDOS</li>
<li>--余风好</li>
<li><a href="http://www.blogjava.net/19851985lili/archive/2010/06/08/97622.html#323049" target="_blank">5. re: Flex2 发现之旅：AS3中新的XML处理方法 - E4X</a></li>
<li>不知道为什么，如果使用item.title访问title节点的话，返回是空的</li>
</ul>
<hr>
<p>这个跟返回的XML的namespace有关。</p>
<ul>
<li>--kennethpoon</li>
</ul>
<h3 id="-">阅读排行榜</h3>
<ul>
<li><a href="http://www.blogjava.net/19851985lili/archive/2007/02/06/98199.html" target="_blank">1. explorer.exe文件损坏，如何修复(12012)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/archive/2007/05/23/119380.html" target="_blank">2. 如何解决cmd.exe占CPU资源100%问题(560)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/archive/2007/04/13/110320.html" target="_blank">3. 亲情之歌(346)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/archive/2007/01/03/91573.html" target="_blank">4. 数码相机的原理(336)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/archive/2008/05/29/203793.html" target="_blank">5. 防止IE被黑的技巧(318)</a></li>
</ul>
<h3 id="-">评论排行榜</h3>
<ul>
<li><a href="http://www.blogjava.net/19851985lili/archive/2007/02/06/98199.html" target="_blank">1. explorer.exe文件损坏，如何修复(1)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/archive/2007/01/03/91573.html" target="_blank">2. 数码相机的原理(0)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/archive/2008/05/29/203793.html" target="_blank">3. 防止IE被黑的技巧(0)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/archive/2007/05/23/119380.html" target="_blank">4. 如何解决cmd.exe占CPU资源100%问题(0)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/archive/2007/04/13/110320.html" target="_blank">5. 亲情之歌(0)</a></li>
</ul>
<p><a href="http://www.blogjava.net/19851985lili/articles/93524.html" target="_blank">Java NIO API详解</a></p>
<p>NIO API 主要集中在 java.nio 和它的 subpackages 中：</p>
<p>java.nio</p>
<p>定义了 Buffer 及其数据类型相关的子类。其中被 java.nio.channels 中的类用来进行 IO 操作的 ByteBuffer 的作用非常重要。</p>
<p>java.nio.channels</p>
<p>定义了一系列处理 IO 的 Channel 接口以及这些接口在文件系统和网络通讯上的实现。通过 Selector 这个类，还提供了进行非阻塞 IO 操作的办法。这个包可以说是 NIO API 的核心。</p>
<p>java.nio.channels.spi</p>
<p>定义了可用来实现 channel 和 selector API 的抽象类。</p>
<p>java.nio.charset</p>
<pre><code>     定义了处理字符编码和解码的类。
</code></pre><p>java.nio.charset.spi</p>
<pre><code>     定义了可用来实现 charset API 的抽象类。
</code></pre><p>java.nio.channels.spi 和 java.nio.charset.spi 这两个包主要被用来对现有 NIO API 进行扩展，在实际的使用中，我们一般只和另外的 3 个包打交道。下面将对这 3 个包一一介绍。</p>
<p>Package java.nio</p>
<p>这个包主要定义了 Buffer 及其子类。 Buffer 定义了一个线性存放 primitive type 数据的容器接口。对于除 boolean 以外的其他 primitive type ，都有一个相应的 Buffer 子类， ByteBuffer 是其中最重要的一个子类。</p>
<p>下面这张 UML 类图描述了 java.nio 中的类的关系：</p>
<p><img src="" alt=""></p>
<p><strong>Buffer</strong></p>
<p>定义了一个可以线性存放 primitive type 数据的容器接口。 Buffer 主要包含了与类型（ byte, char… ）无关的功能。值得注意的是 Buffer 及其子类都不是线程安全的。</p>
<p>每个 Buffer 都有以下的属性：</p>
<p>capacity</p>
<p>这个 Buffer 最多能放多少数据。 capacity 一般在 buffer 被创建的时候指定。</p>
<p>limit</p>
<p>在 Buffer 上进行的读写操作都不能越过这个下标。当写数据到 buffer 中时， limit 一般和 capacity 相等，当读数据时， limit 代表 buffer 中有效数据的长度。</p>
<p>position</p>
<p>读 / 写操作的当前下标。当使用 buffer 的相对位置进行读 / 写操作时，读 / 写会从这个下标进行，并在操作完成后， buffer 会更新下标的值。</p>
<p>mark</p>
<p>一个临时存放的位置下标。调用 mark() 会将 mark 设为当前的 position 的值，以后调用 reset() 会将 position 属性设置为 mark 的值。 mark 的值总是小于等于 position 的值，如果将 position 的值设的比 mark 小，当前的 mark 值会被抛弃掉。</p>
<p>这些属性总是满足以下条件：</p>
<p>0 &lt;= mark &lt;= position &lt;= limit &lt;= capacity</p>
<p>limit 和 position 的值除了通过 limit() 和 position() 函数来设置，也可以通过下面这些函数来改变：</p>
<p>Buffer clear()</p>
<p>把 position 设为 0 ，把 limit 设为 capacity ，一般在把数据写入 Buffer 前调用。</p>
<p>Buffer flip()</p>
<p>把 limit 设为当前 position ，把 position 设为 0 ，一般在从 Buffer 读出数据前调用。</p>
<p>Buffer rewind()</p>
<p>把 position 设为 0 ， limit 不变，一般在把数据重写入 Buffer 前调用。</p>
<p>Buffer 对象有可能是只读的，这时，任何对该对象的写操作都会触发一个 ReadOnlyBufferException 。 isReadOnly() 方法可以用来判断一个 Buffer 是否只读。</p>
<p><strong>ByteBuffer</strong></p>
<p>在 Buffer 的子类中， ByteBuffer 是一个地位较为特殊的类，因为在 java.io.channels 中定义的各种 channel 的 IO 操作基本上都是围绕 ByteBuffer 展开的。</p>
<p>ByteBuffer 定义了 4 个 static 方法来做创建工作：</p>
<p>ByteBuffer allocate(int capacity)</p>
<p>创建一个指定 capacity 的 ByteBuffer 。</p>
<p>ByteBuffer allocateDirect(int capacity)</p>
<p>创建一个 direct 的 ByteBuffer ，这样的 ByteBuffer 在参与 IO 操作时性能会更好（很有可能是在底层的实现使用了 DMA 技术），相应的，创建和回收 direct 的 ByteBuffer 的代价也会高一些。 isDirect() 方法可以检查一个 buffer 是否是 direct 的。</p>
<p>ByteBuffer wrap(byte [] array)</p>
<p>ByteBuffer wrap(byte [] array, int offset, int length)</p>
<p>把一个 byte 数组或 byte 数组的一部分包装成 ByteBuffer 。</p>
<p>ByteBuffer 定义了一系列 get 和 put 操作来从中读写 byte 数据，如下面几个：</p>
<p>byte get()</p>
<p>ByteBuffer get(byte [] dst)</p>
<p>byte get(int index)</p>
<p>ByteBuffer put(byte b)</p>
<p>ByteBuffer put(byte [] src)</p>
<p>ByteBuffer put(int index, byte b)</p>
<p>这些操作可分为绝对定位和相对定为两种，相对定位的读写操作依靠 position 来定位 Buffer 中的位置，并在操作完成后会更新 position 的值。</p>
<p>在其它类型的 buffer 中，也定义了相同的函数来读写数据，唯一不同的就是一些参数和返回值的类型。</p>
<p>除了读写 byte 类型数据的函数， ByteBuffer 的一个特别之处是它还定义了读写其它 primitive 数据的方法，如：</p>
<p>int getInt()</p>
<pre><code>     从 ByteBuffer 中读出一个 int 值。
</code></pre><p>ByteBuffer putInt(int value)</p>
<pre><code>     写入一个 int 值到 ByteBuffer 中。
</code></pre><p>读写其它类型的数据牵涉到字节序问题， ByteBuffer 会按其字节序（大字节序或小字节序）写入或读出一个其它类型的数据（ int,long… ）。字节序可以用 order 方法来取得和设置：</p>
<p>ByteOrder order()</p>
<pre><code>     返回 ByteBuffer 的字节序。
</code></pre><p>ByteBuffer order(ByteOrder bo)</p>
<pre><code>     设置 ByteBuffer 的字节序。
</code></pre><p>ByteBuffer 另一个特别的地方是可以在它的基础上得到其它类型的 buffer 。如：</p>
<p>CharBuffer asCharBuffer()</p>
<p>为当前的 ByteBuffer 创建一个 CharBuffer 的视图。在该视图 buffer 中的读写操作会按照 ByteBuffer 的字节序作用到 ByteBuffer 中的数据上。</p>
<p>用这类方法创建出来的 buffer 会从 ByteBuffer 的 position 位置开始到 limit 位置结束，可以看作是这段数据的视图。视图 buffer 的 readOnly 属性和 direct 属性与 ByteBuffer 的一致，而且也只有通过这种方法，才可以得到其他数据类型的 direct buffer 。</p>
<p><strong>ByteOrder</strong></p>
<p>用来表示 ByteBuffer 字节序的类，可将其看成 java 中的 enum 类型。主要定义了下面几个 static 方法和属性：</p>
<p>ByteOrder BIG_ENDIAN</p>
<pre><code>     代表大字节序的 ByteOrder 。
</code></pre><p>ByteOrder LITTLE_ENDIAN</p>
<pre><code>     代表小字节序的 ByteOrder 。
</code></pre><p>ByteOrder nativeOrder()</p>
<pre><code>     返回当前硬件平台的字节序。
</code></pre><p><strong>MappedByteBuffer</strong></p>
<p>ByteBuffer 的子类，是文件内容在内存中的映射。这个类的实例需要通过 FileChannel 的 map() 方法来创建。</p>
<p>接下来看看一个使用 ByteBuffer 的例子，这个例子从标准输入不停地读入字符，当读满一行后，将收集的字符写到标准输出：</p>
<pre><code> **public** **static** **void** main(String [] args)

    **throws** IOException

 {

    //   创建一个 capacity 为 256 的 ByteBuffer

    ByteBuffer buf = ByteBuffer.allocate(256);

    **while** ( **true** ) {

        //   从标准输入流读入一个字符

        **int** c = System.in.read();

        //   当读到输入流结束时，退出循环

        **if** (c == -1)

           **break** ;



        //   把读入的字符写入 ByteBuffer 中

        buf.put(( **byte** ) c);

        //   当读完一行时，输出收集的字符

        **if** (c == &#39;\n&#39; ) {

           //   调用 flip() 使 limit 变为当前的 position 的值 ,position 变为 0,

           //   为接下来从 ByteBuffer 读取做准备

           buf.flip();

           //   构建一个 byte 数组

           **byte** [] content = **new** **byte** [buf.limit()];

           //   从 ByteBuffer 中读取数据到 byte 数组中

           buf.get(content);

             //   把 byte 数组的内容写到标准输出

           System.out.print( **new** String(content));

           //   调用 clear() 使 position 变为 0,limit 变为 capacity 的值，

           //   为接下来写入数据到 ByteBuffer 中做准备

           buf.clear();

        }

    }

 }
</code></pre><p>Package java.nio.channels</p>
<p>这个包定义了 Channel 的概念， Channel 表现了一个可以进行 IO 操作的通道（比如，通过 FileChannel ，我们可以对文件进行读写操作）。 java.nio.channels 包含了文件系统和网络通讯相关的 channel 类。这个包通过 Selector 和 SelectableChannel 这两个类，还定义了一个进行非阻塞（ non-blocking ） IO 操作的 API ，这对需要高性能 IO 的应用非常重要。</p>
<p>下面这张 UML 类图描述了 java.nio.channels 中 interface 的关系：</p>
<p><img src="" alt=""></p>
<p><strong>Channel</strong></p>
<p>Channel 表现了一个可以进行 IO 操作的通道，该 interface 定义了以下方法：</p>
<p>boolean isOpen()</p>
<pre><code>     该 Channel 是否是打开的。
</code></pre><p>void close()</p>
<pre><code>     关闭这个 Channel ，相关的资源会被释放。
</code></pre><p><strong>ReadableByteChannel</strong></p>
<p>定义了一个可从中读取 byte 数据的 channel interface 。</p>
<p>int read(ByteBuffer dst)</p>
<p>从 channel 中读取 byte 数据并写到 ByteBuffer 中。返回读取的 byte 数。</p>
<p><strong>WritableByteChannel</strong></p>
<p>定义了一个可向其写 byte 数据的 channel interface 。</p>
<p>int write(ByteBuffer src)</p>
<pre><code>     从 ByteBuffer 中读取 byte 数据并写到 channel 中。返回写出的 byte 数。
</code></pre><p><strong>ByteChannel</strong></p>
<p>ByteChannel 并没有定义新的方法，它的作用只是把 ReadableByteChannel 和 WritableByteChannel 合并在一起。</p>
<p><strong>ScatteringByteChannel</strong></p>
<p>继承了 ReadableByteChannel 并提供了同时往几个 ByteBuffer 中写数据的能力。</p>
<p><strong>GatheringByteChannel</strong></p>
<p>继承了 WritableByteChannel 并提供了同时从几个 ByteBuffer 中读数据的能力。</p>
<p><strong>InterruptibleChannel</strong></p>
<p>用来表现一个可以被异步关闭的 Channel 。这表现在两方面：</p>
<p>1．     当一个 InterruptibleChannel 的 close() 方法被调用时，其它 block 在这个 InterruptibleChannel 的 IO 操作上的线程会接收到一个 AsynchronousCloseException 。</p>
<p>2．     当一个线程 block 在 InterruptibleChannel 的 IO 操作上时，另一个线程调用该线程的 interrupt() 方法会导致 channel 被关闭，该线程收到一个 ClosedByInterruptException ，同时线程的 interrupt 状态会被设置。</p>
<p>接下来的这张 UML 类图描述了 java.nio.channels 中类的关系：</p>
<p><img src="" alt=""></p>
<p><strong>非阻塞 IO</strong></p>
<p>非阻塞 IO 的支持可以算是 NIO API 中最重要的功能，非阻塞 IO 允许应用程序同时监控多个 channel 以提高性能，这一功能是通过 Selector ， SelectableChannel 和 SelectionKey 这 3 个类来实现的。</p>
<p>SelectableChannel 代表了可以支持非阻塞 IO 操作的 channel ，可以将其注册在 Selector 上，这种注册的关系由 SelectionKey 这个类来表现（见 UML 图）。 Selector 这个类通过 select() 函数，给应用程序提供了一个可以同时监控多个 IO channel 的方法：</p>
<p>应用程序通过调用 select() 函数，让 Selector 监控注册在其上的多个 SelectableChannel ，当有 channel 的 IO 操作可以进行时， select() 方法就会返回以让应用程序检查 channel 的状态，并作相应的处理。</p>
<p>下面是 JDK 1.4 中非阻塞 IO 的一个例子，这段 code 使用了非阻塞 IO 实现了一个 time server ：</p>
<pre><code> **private** **static** **void** acceptConnections( **int** port) **throws** Exception {

    //   打开一个 Selector

    Selector acceptSelector =

        SelectorProvider.provider().openSelector();



    //   创建一个 ServerSocketChannel ，这是一个 SelectableChannel 的子类

    ServerSocketChannel ssc = ServerSocketChannel.open();

    //   将其设为 non-blocking 状态，这样才能进行非阻塞 IO 操作

    ssc.configureBlocking( **false** );



    //   给 ServerSocketChannel 对应的 socket 绑定 IP 和端口

    InetAddress lh = InetAddress.getLocalHost();

    InetSocketAddress isa = **new** InetSocketAddress(lh, port);

    ssc.socket().bind(isa);



    //   将 ServerSocketChannel 注册到 Selector 上，返回对应的 SelectionKey

    SelectionKey acceptKey =

        ssc.register(acceptSelector, SelectionKey.OP_ACCEPT);



    **int** keysAdded = 0;



    //   用 select() 函数来监控注册在 Selector 上的 SelectableChannel

    //   返回值代表了有多少 channel 可以进行 IO 操作  (ready for IO)

    **while** ((keysAdded = acceptSelector.select()) &gt; 0) {

        // selectedKeys()  返回一个 SelectionKey 的集合，

        //   其中每个 SelectionKey 代表了一个可以进行 IO 操作的 channel 。

        //   一个 ServerSocketChannel 可以进行 IO 操作意味着有新的 TCP 连接连入了

        Set readyKeys = acceptSelector.selectedKeys();

        Iterator i = readyKeys.iterator();



        **while** (i.hasNext()) {

           SelectionKey sk = (SelectionKey) i.next();

           //   需要将处理过的 key 从 selectedKeys 这个集合中删除

           i.remove();

           //   从 SelectionKey 得到对应的 channel

           ServerSocketChannel nextReady =

               (ServerSocketChannel) sk.channel();

           //   接受新的 TCP 连接

           Socket s = nextReady.accept().socket();

           //   把当前的时间写到这个新的 TCP 连接中

           PrintWriter out =

               **new** PrintWriter(s.getOutputStream(), **true** );

           Date now = **new** Date();

           out.println(now);

           //   关闭连接

           out.close();

        }

    }

 }
</code></pre><p>这是个纯粹用于演示的例子，因为只有一个 ServerSocketChannel 需要监控，所以其实并不真的需要使用到非阻塞 IO 。不过正因为它的简单，可以很容易地看清楚非阻塞 IO 是如何工作的。</p>
<p><strong>SelectableChannel</strong></p>
<p>这个抽象类是所有支持非阻塞 IO 操作的 channel （如 DatagramChannel 、 SocketChannel ）的父类。 SelectableChannel 可以注册到一个或多个 Selector 上以进行非阻塞 IO 操作。</p>
<p>SelectableChannel 可以是 blocking 和 non-blocking 模式（所有 channel 创建的时候都是 blocking 模式），只有 non-blocking 的 SelectableChannel 才可以参与非阻塞 IO 操作。</p>
<p>SelectableChannel configureBlocking(boolean block)</p>
<pre><code>     设置 blocking 模式。
</code></pre><p>boolean isBlocking()</p>
<pre><code>     返回 blocking 模式。
</code></pre><p>通过 register() 方法， SelectableChannel 可以注册到 Selector 上。</p>
<p>int validOps()</p>
<p>返回一个 bit mask ，表示这个 channel 上支持的 IO 操作。当前在 SelectionKey 中，用静态常量定义了 4 种 IO 操作的 bit 值： OP_ACCEPT ， OP_CONNECT ， OP_READ 和 OP_WRITE 。</p>
<p>SelectionKey register(Selector sel, int ops)</p>
<p>将当前 channel 注册到一个 Selector 上并返回对应的 SelectionKey 。在这以后，通过调用 Selector 的 select() 函数就可以监控这个 channel 。 ops 这个参数是一个 bit mask ，代表了需要监控的 IO 操作。</p>
<p>SelectionKey register(Selector sel, int ops, Object att)</p>
<p>这个函数和上一个的意义一样，多出来的 att 参数会作为 attachment 被存放在返回的 SelectionKey 中，这在需要存放一些 session state 的时候非常有用。</p>
<p>boolean isRegistered()</p>
<pre><code>     该 channel 是否已注册在一个或多个 Selector 上。
</code></pre><p>SelectableChannel 还提供了得到对应 SelectionKey 的方法：</p>
<p>SelectionKey keyFor(Selector sel)</p>
<p>返回该 channe 在 Selector 上的注册关系所对应的 SelectionKey 。若无注册关系，返回 null 。</p>
<p><strong>Selector</strong></p>
<p>Selector 可以同时监控多个 SelectableChannel 的 IO 状况，是非阻塞 IO 的核心。</p>
<p>Selector open()</p>
<pre><code>   Selector 的一个静态方法，用于创建实例。
</code></pre><p>在一个 Selector 中，有 3 个 SelectionKey 的集合：</p>
<p>1． key set 代表了所有注册在这个 Selector 上的 channel ，这个集合可以通过 keys() 方法拿到。</p>
<p>2． Selected-key set 代表了所有通过 select() 方法监测到可以进行 IO 操作的 channel ，这个集合可以通过 selectedKeys() 拿到。</p>
<p>3． Cancelled-key set 代表了已经 cancel 了注册关系的 channel ，在下一个 select() 操作中，这些 channel 对应的 SelectionKey 会从 key set 和 cancelled-key set 中移走。这个集合无法直接访问。</p>
<p>以下是 select() 相关方法的说明：</p>
<p>int select()</p>
<p>监控所有注册的 channel ，当其中有注册的 IO 操作可以进行时，该函数返回，并将对应的 SelectionKey 加入 selected-key set 。</p>
<p>int select(long timeout)</p>
<pre><code>     可以设置超时的 select() 操作。
</code></pre><p>int selectNow()</p>
<pre><code>     进行一个立即返回的 select() 操作。
</code></pre><p>Selector wakeup()</p>
<pre><code>     使一个还未返回的 select() 操作立刻返回。
</code></pre><p><strong>SelectionKey</strong></p>
<p>代表了 Selector 和 SelectableChannel 的注册关系。</p>
<p>Selector 定义了 4 个静态常量来表示 4 种 IO 操作，这些常量可以进行位操作组合成一个 bit mask 。</p>
<p>int OP_ACCEPT</p>
<p>有新的网络连接可以 accept ， ServerSocketChannel 支持这一非阻塞 IO 。</p>
<p>int OP_CONNECT</p>
<pre><code>     代表连接已经建立（或出错）， SocketChannel 支持这一非阻塞 IO 。
</code></pre><p>int OP_READ</p>
<p>int OP_WRITE</p>
<pre><code>     代表了读、写操作。
</code></pre><p>以下是其主要方法：</p>
<p>Object attachment()</p>
<p>返回 SelectionKey 的 attachment ， attachment 可以在注册 channel 的时候指定。</p>
<p>Object attach(Object ob)</p>
<pre><code>     设置 SelectionKey 的 attachment 。
</code></pre><p>SelectableChannel channel()</p>
<pre><code>     返回该 SelectionKey 对应的 channel 。
</code></pre><p>Selector selector()</p>
<pre><code>     返回该 SelectionKey 对应的 Selector 。
</code></pre><p>void cancel()</p>
<pre><code>   cancel 这个 SelectionKey 所对应的注册关系。
</code></pre><p>int interestOps()</p>
<pre><code>     返回代表需要 Selector 监控的 IO 操作的 bit mask 。
</code></pre><p>SelectionKey interestOps(int ops)</p>
<pre><code>     设置 interestOps 。
</code></pre><p>int readyOps()</p>
<pre><code>     返回一个 bit mask ，代表在相应 channel 上可以进行的 IO 操作。
</code></pre><p><strong>ServerSocketChannel</strong></p>
<p>支持非阻塞操作，对应于 java.net.ServerSocket 这个类，提供了 TCP 协议 IO 接口，支持 OP_ACCEPT 操作。</p>
<p>ServerSocket socket()</p>
<pre><code>     返回对应的 ServerSocket 对象。
</code></pre><p>SocketChannel accept()</p>
<pre><code>     接受一个连接，返回代表这个连接的 SocketChannel 对象。
</code></pre><p><strong>SocketChannel</strong></p>
<p>支持非阻塞操作，对应于 java.net.Socket 这个类，提供了 TCP 协议 IO 接口，支持 OP_CONNECT ， OP_READ 和 OP_WRITE 操作。这个类还实现了 ByteChannel ， ScatteringByteChannel 和 GatheringByteChannel 接口。</p>
<p>DatagramChannel 和这个类比较相似，其对应于 java.net.DatagramSocket ，提供了 UDP 协议 IO 接口。</p>
<p>Socket socket()</p>
<pre><code>     返回对应的 Socket 对象。
</code></pre><p>boolean connect(SocketAddress remote)</p>
<p>boolean finishConnect()</p>
<p>connect() 进行一个连接操作。如果当前 SocketChannel 是 blocking 模式，这个函数会等到连接操作完成或错误发生才返回。如果当前 SocketChannel 是 non-blocking 模式，函数在连接能立刻被建立时返回 true ，否则函数返回 false ，应用程序需要在以后用 finishConnect() 方法来完成连接操作。</p>
<p><strong>Pipe</strong></p>
<p>包含了一个读和一个写的 channel(Pipe.SourceChannel 和 Pipe.SinkChannel) ，这对 channel 可以用于进程中的通讯。</p>
<p><strong>FileChannel</strong></p>
<p>用于对文件的读、写、映射、锁定等操作。和映射操作相关的类有 FileChannel.MapMode ，和锁定操作相关的类有 FileLock 。值得注意的是 FileChannel 并不支持非阻塞操作。</p>
<p><strong>Channels</strong></p>
<p>这个类提供了一系列 static 方法来支持 stream 类和 channel 类之间的互操作。这些方法可以将 channel 类包装为 stream 类，比如，将 ReadableByteChannel 包装为 InputStream 或 Reader ；也可以将 stream 类包装为 channel 类，比如，将 OutputStream 包装为 WritableByteChannel 。</p>
<p>Package java.nio.charset</p>
<p>这个包定义了 Charset 及相应的 encoder 和 decoder 。下面这张 UML 类图描述了这个包中类的关系，可以将其中 Charset ， CharsetDecoder 和 CharsetEncoder 理解成一个 Abstract Factory 模式的实现：</p>
<p><img src="" alt=""></p>
<p><strong>Charset</strong></p>
<p>代表了一个字符集，同时提供了 factory method 来构建相应的 CharsetDecoder 和 CharsetEncoder 。</p>
<p>Charset 提供了以下 static 的方法：</p>
<p>SortedMap availableCharsets()</p>
<pre><code>     返回当前系统支持的所有 Charset 对象，用 charset 的名字作为 set 的 key 。
</code></pre><p>boolean isSupported(String charsetName)</p>
<pre><code>     判断该名字对应的字符集是否被当前系统支持。
</code></pre><p>Charset forName(String charsetName)</p>
<pre><code>     返回该名字对应的 Charset 对象。
</code></pre><p>Charset 中比较重要的方法有：</p>
<p>String name()</p>
<pre><code>     返回该字符集的规范名。
</code></pre><p>Set aliases()</p>
<pre><code>     返回该字符集的所有别名。
</code></pre><p>CharsetDecoder newDecoder()</p>
<pre><code>     创建一个对应于这个 Charset 的 decoder 。
</code></pre><p>CharsetEncoder newEncoder()</p>
<pre><code>     创建一个对应于这个 Charset 的 encoder 。
</code></pre><p><strong>CharsetDecoder</strong></p>
<p>将按某种字符集编码的字节流解码为 unicode 字符数据的引擎。</p>
<p>CharsetDecoder 的输入是 ByteBuffer ，输出是 CharBuffer 。进行 decode 操作时一般按如下步骤进行：</p>
<p>1． 调用 CharsetDecoder 的 reset() 方法。（第一次使用时可不调用）</p>
<p>2． 调用 decode() 方法 0 到 n 次，将 endOfInput 参数设为 false ，告诉 decoder 有可能还有新的数据送入。</p>
<p>3． 调用 decode() 方法最后一次，将 endOfInput 参数设为 true ，告诉 decoder 所有数据都已经送入。</p>
<p>4． 调用 decoder 的 flush() 方法。让 decoder 有机会把一些内部状态写到输出的 CharBuffer 中。</p>
<p>CharsetDecoder reset()</p>
<pre><code>     重置 decoder ，并清除 decoder 中的一些内部状态。
</code></pre><p>CoderResult decode(ByteBuffer in, CharBuffer out, boolean endOfInput)</p>
<p>从 ByteBuffer 类型的输入中 decode 尽可能多的字节，并将结果写到 CharBuffer 类型的输出中。根据 decode 的结果，可能返回 3 种 CoderResult ： CoderResult.UNDERFLOW 表示已经没有输入可以 decode ； CoderResult.OVERFLOW 表示输出已满；其它的 CoderResult 表示 decode 过程中有错误发生。根据返回的结果，应用程序可以采取相应的措施，比如，增加输入，清除输出等等，然后再次调用 decode() 方法。</p>
<p>CoderResult flush(CharBuffer out)</p>
<p>有些 decoder 会在 decode 的过程中保留一些内部状态，调用这个方法让这些 decoder 有机会将这些内部状态写到输出的 CharBuffer 中。调用成功返回 CoderResult.UNDERFLOW 。如果输出的空间不够，该函数返回 CoderResult.OVERFLOW ，这时应用程序应该扩大输出 CharBuffer 的空间，然后再次调用该方法。</p>
<p>CharBuffer decode(ByteBuffer in)</p>
<p>一个便捷的方法把 ByteBuffer 中的内容 decode 到一个新创建的 CharBuffer 中。在这个方法中包括了前面提到的 4 个步骤，所以不能和前 3 个函数一起使用。</p>
<p>decode 过程中的错误有两种： malformed-input CoderResult 表示输入中数据有误； unmappable-character CoderResult 表示输入中有数据无法被解码成 unicode 的字符。如何处理 decode 过程中的错误取决于 decoder 的设置。对于这两种错误， decoder 可以通过 CodingErrorAction 设置成：</p>
<p>1． 忽略错误</p>
<p>2． 报告错误。（这会导致错误发生时， decode() 方法返回一个表示该错误的 CoderResult 。）</p>
<p>3． 替换错误，用 decoder 中的替换字串替换掉有错误的部分。</p>
<p>CodingErrorAction malformedInputAction()</p>
<pre><code>     返回 malformed-input 的出错处理。
</code></pre><p>CharsetDecoder onMalformedInput(CodingErrorAction newAction)</p>
<pre><code>     设置 malformed-input 的出错处理。
</code></pre><p>CodingErrorAction unmappableCharacterAction()</p>
<pre><code>     返回 unmappable-character 的出错处理。
</code></pre><p>CharsetDecoder onUnmappableCharacter(CodingErrorAction newAction)</p>
<pre><code>     设置 unmappable-character 的出错处理。
</code></pre><p>String replacement()</p>
<pre><code>     返回 decoder 的替换字串。
</code></pre><p>CharsetDecoder replaceWith(String newReplacement)</p>
<pre><code>     设置 decoder 的替换字串。
</code></pre><p><strong>CharsetEncoder</strong></p>
<p>将 unicode 字符数据编码为特定字符集的字节流的引擎。其接口和 CharsetDecoder 相类似。</p>
<p><strong>CoderResult</strong></p>
<p>描述 encode/decode 操作结果的类。</p>
<p>CodeResult 包含两个 static 成员：</p>
<p>CoderResult OVERFLOW</p>
<pre><code>     表示输出已满
</code></pre><p>CoderResult UNDERFLOW</p>
<pre><code>     表示输入已无数据可用。
</code></pre><p>其主要的成员函数有：</p>
<p>boolean isError()</p>
<p>boolean isMalformed()</p>
<p>boolean isUnmappable()</p>
<p>boolean isOverflow()</p>
<p>boolean isUnderflow()</p>
<pre><code>     用于判断该 CoderResult 描述的错误。
</code></pre><p>int length()</p>
<pre><code>     返回错误的长度，比如，无法被转换成 unicode 的字节长度。
</code></pre><p>void throwException()</p>
<pre><code>     抛出一个和这个 CoderResult 相对应的 exception 。
</code></pre><p><strong>CodingErrorAction</strong></p>
<p>表示 encoder/decoder 中错误处理方法的类。可将其看成一个 enum 类型。有以下 static 属性：</p>
<p>CodingErrorAction IGNORE</p>
<pre><code>     忽略错误。
</code></pre><p>CodingErrorAction REPLACE</p>
<pre><code>     用替换字串替换有错误的部分。
</code></pre><p>CodingErrorAction REPORT</p>
<p>报告错误，对于不同的函数，有可能是返回一个和错误有关的 CoderResult ，也有可能是抛出一个 CharacterCodingException 。
posted on 2007-01-12 20:07 <a href="http://www.blogjava.net/19851985lili/" target="_blank">☜♥☞MengChuChen</a> 阅读(6999) <a href="">评论(0)</a>  <a href="http://www.blogjava.net/19851985lili/admin/EditArticles.aspx?postid=93524" target="_blank">编辑</a>  <a href="http://www.blogjava.net/19851985lili/AddToFavorite.aspx?id=93524" target="_blank">收藏</a> <img src="" alt=""></p>
<p><a href="http://www.blogjava.net/RequireRegister.aspx" target="_blank">新用户注册</a>  <a href="">刷新评论列表</a>  </p>
<p><a href=""></a> <a href="http://www.aliyun.com/cps/channel?channel_id=1306&amp;user=0&amp;lv=1">推荐购买云服务器（15%返利+最高千元奖金）</a>   <a href="http://www.cnblogs.com/" target="_blank">博客园</a>  <a href="http://q.cnblogs.com/" target="_blank">博问</a>  <a href="http://news.cnblogs.com/" target="_blank">IT新闻</a>  <a href="http://job.cnblogs.com/cate-java_programmer/" target="_blank">Java程序员招聘</a> 标题  请输入标题 姓名  请输入你的姓名 主页 请输入验证码 验证码 /*  <img src="http://www.blogjava.net/Modules/CaptchaImage/JpegImage.aspx?cacheid=20130718160740" alt=""> 内容(请不要发表任何与政治相关的内容) 请输入评论内容 Remember Me?   <a href="http://www.blogjava.net/login.aspx?ReturnURL=http://www.blogjava.net/19851985lili/articles/93524.html&amp;SourceURL=/19851985lili/articles/93524.html" target="_blank">登录</a>       [使用Ctrl+Enter键可以直接提交]      网站导航:</p>
<p><a href="http://www.cnblogs.com/" title="程序员的网上家园" target="_blank">博客园</a>   <a href="http://news.cnblogs.com/" target="_blank">IT新闻</a>   <a href="http://kb.cnblogs.com/" target="_blank">知识库</a>   <a href="http://www.cppblog.com/" target="_blank">C++博客</a>   <a href="http://job.cnblogs.com/" target="_blank">程序员招聘</a>   <a href="http://www.blogjava.net/19851985lili/articles/93524.html?opt=admin" target="_blank">管理</a><br>Copyright ©2013 ☜♥☞MengChuChen Powered By<a href="http://www.blogjava.net/" target="_blank">博客园</a> 模板提供：<a href="http://blog.hjenglish.com/" target="_blank">沪江博客</a></p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/NIO/">NIO</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/NIO/" class="label label-success">NIO</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:41"datetime="2014-03-07 09:54:41"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-NIO--JavaNIOAPI详解/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-NIO--JavaNIOAPI详解" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-NIO--Javaaio异步网络IO初探/">Java aio(异步网络IO)初探</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:41.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-NIO--Javaaio异步网络IO初探/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="java-aio-io-">Java aio(异步网络IO)初探</h1>
<p><a href="">&lt;</a> <a href="">&gt;</a>  猎头职位: <a href="http://www.iteye.com/jobs/2509" target="_blank">上海:  Junior Product Manager</a></p>
<p>相关文章: <a href="&quot;关闭&quot;"> </a></p>
<ul>
<li><a href="http://www.iteye.com/topic/1113611" title="JDK7 AIO 初体验" target="_blank">JDK7 AIO 初体验</a></li>
<li><a href="http://www.iteye.com/topic/446298" title="JavaSE7新特性 异步非阻塞I/O 网络通信 AIO" target="_blank">JavaSE7新特性 异步非阻塞I/O 网络通信 AIO</a></li>
<li><p><a href="http://www.iteye.com/topic/834447" title="JAVA NIO 简介" target="_blank">JAVA NIO 简介</a>
推荐群组: <a href="http://dlang.group.iteye.com/" target="_blank">D语言</a>
<a href="http://www.iteye.com/wiki/topic/472333" target="_blank">更多相关推荐</a>
<a href="http://www.iteye.com/forums/tag/%E4%BC%81%E4%B8%9A%E5%BA%94%E7%94%A8" target="_blank">企业应用</a></p>
<p>  按照《Unix网络编程》的划分，IO模型可以分为：阻塞IO、非阻塞IO、IO复用、信号驱动IO和异步IO，按照POSIX标准来划分只分为两类：同步IO和异步IO。如何区分呢？首先一个IO操作其实分成了两个步骤：发起IO请求和实际的IO操作，同步IO和异步IO的区别就在于第二个步骤是否阻塞，如果实际的IO读写阻塞请求进程，那么就是同步IO，因此阻塞IO、非阻塞IO、IO服用、信号驱动IO都是同步IO，如果不阻塞，而是操作系统帮你做完IO操作再将结果返回给你，那么就是异步IO。阻塞IO和非阻塞IO的区别在于第一步，发起IO请求是否会被阻塞，如果阻塞直到完成那么就是传统的阻塞IO，如果不阻塞，那么就是非阻塞IO。
 Java nio 2.0的主要改进就是引入了异步IO（包括文件和网络），这里主要介绍下异步网络IO API的使用以及框架的设计，以TCP服务端为例。首先看下为了支持AIO引入的新的类和接口：
<strong>java.nio.channels.AsynchronousChannel</strong></p>
<pre><code> 标记一个channel支持异步IO操作。
</code></pre><p><strong> java.nio.channels.AsynchronousServerSocketChannel</strong></p>
<pre><code> ServerSocket的aio版本，创建TCP服务端，绑定地址，监听端口等。
</code></pre><p><strong> java.nio.channels.AsynchronousSocketChannel</strong></p>
<pre><code> 面向流的异步socket channel，表示一个连接。
</code></pre><p><strong> java.nio.channels.AsynchronousChannelGroup</strong></p>
<pre><code> 异步channel的分组管理，目的是为了资源共享。一个AsynchronousChannelGroup绑定一个线程池，这个线程池执行两个任务：处理IO事件和派发CompletionHandler。AsynchronousServerSocketChannel创建的时候可以传入一个 AsynchronousChannelGroup，那么通过AsynchronousServerSocketChannel创建的 AsynchronousSocketChannel将同属于一个组，共享资源。
</code></pre><p><strong> java.nio.channels.CompletionHandler</strong></p>
<pre><code> 异步IO操作结果的回调接口，用于定义在IO操作完成后所作的回调工作。AIO的API允许两种方式来处理异步操作的结果：返回的Future模式或者注册CompletionHandler，我更推荐用CompletionHandler的方式，这些handler的调用是由 AsynchronousChannelGroup的线程池派发的。显然，线程池的大小是性能的关键因素。AsynchronousChannelGroup允许绑定不同的线程池，通过三个静态方法来创建：
</code></pre></li>
</ul>
<p>Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>public static AsynchronousChannelGroup withFixedThreadPool(int nThreads,  </li>
<li>ThreadFactory threadFactory)  </li>
<li>throws IOException  </li>
<li></li>
<li>public static AsynchronousChannelGroup withCachedThreadPool(ExecutorService executor,  </li>
<li>int initialSize)  </li>
<li></li>
<li>public static AsynchronousChannelGroup withThreadPool(ExecutorService executor)  </li>
<li>throws IOException  </li>
</ol>
<p>public static AsynchronousChannelGroup withFixedThreadPool(int nThreads,</p>
<pre><code>                                                           ThreadFactory threadFactory)
    throws IOException
</code></pre><p>public static AsynchronousChannelGroup withCachedThreadPool(ExecutorService executor,</p>
<pre><code>                                                            int initialSize)
</code></pre><p>public static AsynchronousChannelGroup withThreadPool(ExecutorService executor)
        throws IOException</p>
<pre><code> 需要根据具体应用相应调整，从框架角度出发，需要暴露这样的配置选项给用户。
 在介绍完了aio引入的TCP的主要接口和类之后，我们来设想下一个aio框架应该怎么设计。参考非阻塞nio框架的设计，一般都是采用**Reactor**模式，Reacot负责事件的注册、select、事件的派发；相应地，异步IO有个**Proactor**模式，Proactor负责 CompletionHandler的派发，查看一个典型的IO写操作的流程来看两者的区别：
 Reactor:  send(msg) -&gt; 消息队列是否为空，如果为空  -&gt; 向Reactor注册OP_WRITE，然后返回 -&gt; Reactor select -&gt; 触发Writable，通知用户线程去处理 -&gt;先注销Writable(很多人遇到的cpu 100%的问题就在于没有注销）,处理Writeable，如果没有完全写入，继续注册OP_WRITE。注意到，写入的工作还是用户线程在处理。
 Proactor: send(msg) -&gt; 消息队列是否为空，如果为空,发起read异步调用，并注册CompletionHandler，然后返回。 -&gt; 操作系统负责将你的消息写入，并返回结果（写入的字节数）给Proactor -&gt; Proactor派发CompletionHandler。可见，写入的工作是操作系统在处理，无需用户线程参与。事实上在aio的API 中,**AsynchronousChannelGroup就扮演了Proactor的角色**。
CompletionHandler有三个方法，分别对应于处理成功、失败、被取消（通过返回的Future)情况下的回调处理：
</code></pre><p>Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>public interface CompletionHandler<V,A> {  </li>
<li></li>
<li>void completed(V result, A attachment);  </li>
<li></li>
<li>void failed(Throwable exc, A attachment);  </li>
<li></li>
<li></li>
<li>void cancelled(A attachment);  </li>
<li>}  </li>
</ol>
<p>public interface CompletionHandler<V,A> {</p>
<pre><code> void completed(V result, A attachment);


void failed(Throwable exc, A attachment);




void cancelled(A attachment);
</code></pre><p>}</p>
<pre><code>其中的泛型参数V表示IO调用的结果，而A是发起调用时传入的attchment。
在初步介绍完aio引入的类和接口后，我们看看一个典型的tcp服务端是怎么启动的，怎么接受连接并处理读和写，这里引用的代码都是yanf4j 的aio分支中的代码，可以从svn checkout，svn地址: [http://yanf4j.googlecode.com/svn/branches/yanf4j-aio](http://yanf4j.googlecode.com/svn/branches/yanf4j-aio)
第一步，创建一个AsynchronousServerSocketChannel，创建之前先创建一个 AsynchronousChannelGroup，上文提到AsynchronousServerSocketChannel可以绑定一个 AsynchronousChannelGroup，那么通过这个AsynchronousServerSocketChannel建立的连接都将同属于一个AsynchronousChannelGroup并共享资源：
</code></pre><p>Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>this.asynchronousChannelGroup = AsynchronousChannelGroup  </li>
<li>.withCachedThreadPool(Executors.newCachedThreadPool(),  </li>
<li>this.threadPoolSize);  </li>
</ol>
<p>this.asynchronousChannelGroup = AsynchronousChannelGroup</p>
<pre><code>                .withCachedThreadPool(Executors.newCachedThreadPool(),
                        this.threadPoolSize);

 然后初始化一个AsynchronousServerSocketChannel，通过open方法：
</code></pre><p>Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>this.serverSocketChannel = AsynchronousServerSocketChannel  </li>
<li>.open(this.asynchronousChannelGroup);  </li>
</ol>
<p>this.serverSocketChannel = AsynchronousServerSocketChannel</p>
<pre><code>            .open(this.asynchronousChannelGroup);


通过nio 2.0引入的SocketOption类设置一些TCP选项：
</code></pre><p>Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>this.serverSocketChannel  </li>
<li>.setOption(  </li>
<li>StandardSocketOption.SO_REUSEADDR,true);  </li>
<li>this.serverSocketChannel  </li>
<li>.setOption(  </li>
<li>StandardSocketOption.SO_RCVBUF,16/*1024);  </li>
</ol>
<p>this.serverSocketChannel</p>
<pre><code>                .setOption(
                        StandardSocketOption.SO_REUSEADDR,true);
</code></pre><p>this.serverSocketChannel
                    .setOption(</p>
<pre><code>                        StandardSocketOption.SO_RCVBUF,16/*1024);


绑定本地地址：
</code></pre><p>Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>this.serverSocketChannel  </li>
<li>.bind(new InetSocketAddress(&quot;localhost&quot;,8080), 100);  </li>
</ol>
<p>this.serverSocketChannel</p>
<pre><code>                .bind(new InetSocketAddress(&quot;localhost&quot;,8080), 100);



其中的100用于指定等待连接的队列大小(backlog)。完了吗？还没有，最重要的**监听**工作还没开始，监听端口是为了等待连接上来以便accept产生一个AsynchronousSocketChannel来表示一个新建立的连接，因此需要发起一个accept调用，调用是异步的，操作系统将在连接建立后，将最后的结果——**AsynchronousSocketChannel**返回给你：
</code></pre><p>Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>public void pendingAccept() {  </li>
<li>if (this.started &amp;&amp; this.serverSocketChannel.isOpen()) {  </li>
<li>this.acceptFuture = this.serverSocketChannel.accept(null,  </li>
<li>new AcceptCompletionHandler());  </li>
<li></li>
<li>} else {  </li>
<li>throw new IllegalStateException(&quot;Controller has been closed&quot;);  </li>
<li>}  </li>
<li>}  </li>
</ol>
<p>public void pendingAccept() {</p>
<pre><code>    if (this.started &amp;&amp; this.serverSocketChannel.isOpen()) {
        this.acceptFuture = this.serverSocketChannel.accept(null,

                new AcceptCompletionHandler());


    } else {
        throw new IllegalStateException(&quot;Controller has been closed&quot;);

    }
}
</code></pre><p>   注意，重复的accept调用将会抛出PendingAcceptException，后文提到的read和write也是如此。accept方法的第一个参数是你想传给CompletionHandler的attchment，第二个参数就是注册的用于回调的CompletionHandler，最后返回结果Future<AsynchronousSocketChannel>。你可以对future做处理，这里采用更推荐的方式就是注册一个CompletionHandler。那么accept的CompletionHandler中做些什么工作呢？显然一个赤裸裸的 AsynchronousSocketChannel是不够的，我们需要将它封装成session，一个session表示一个连接（mina里就叫 IoSession了），里面带了一个缓冲的消息队列以及一些其他资源等。在连接建立后，除非你的服务器只准备接受一个连接，不然你需要在后面<strong>继续调用pendingAccept来发起另一个accept请求</strong>：</p>
<p>Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>private final class AcceptCompletionHandler implements  </li>
<li>CompletionHandler<AsynchronousSocketChannel, Object> {  </li>
<li></li>
<li>@Override  </li>
<li>public void cancelled(Object attachment) {  </li>
<li>logger.warn(&quot;Accept operation was canceled&quot;);  </li>
<li>}  </li>
<li></li>
<li>@Override  </li>
<li>public void completed(AsynchronousSocketChannel socketChannel,  </li>
<li>Object attachment) {  </li>
<li>try {  </li>
<li>logger.debug(&quot;Accept connection from &quot;  </li>
<li><ul>
<li>socketChannel.getRemoteAddress());  </li>
</ul>
</li>
<li>configureChannel(socketChannel);  </li>
<li>AioSessionConfig sessionConfig = buildSessionConfig(socketChannel);  </li>
<li>Session session = new AioTCPSession(sessionConfig,  </li>
<li>AioTCPController.this.configuration  </li>
<li>.getSessionReadBufferSize(),  </li>
<li>AioTCPController.this.sessionTimeout);  </li>
<li>session.start();  </li>
<li>registerSession(session);  </li>
<li>} catch (Exception e) {  </li>
<li>e.printStackTrace();  </li>
<li>logger.error(&quot;Accept error&quot;, e);  </li>
<li>notifyException(e);  </li>
<li>} finally {  </li>
<li><strong>pendingAccept</strong>();  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>@Override  </li>
<li>public void failed(Throwable exc, Object attachment) {  </li>
<li>logger.error(&quot;Accept error&quot;, exc);  </li>
<li>try {  </li>
<li>notifyException(exc);  </li>
<li>} finally {  </li>
<li><strong>pendingAccept</strong>();  </li>
<li>}  </li>
<li>}  </li>
<li>}  </li>
</ol>
<p>private final class AcceptCompletionHandler implements</p>
<pre><code>        CompletionHandler&lt;AsynchronousSocketChannel, Object&gt; {


    @Override
    public void cancelled(Object attachment) {

        logger.warn(&quot;Accept operation was canceled&quot;);
    }


    @Override

    public void completed(AsynchronousSocketChannel socketChannel,
            Object attachment) {

        try {
            logger.debug(&quot;Accept connection from &quot;

                    + socketChannel.getRemoteAddress());
            configureChannel(socketChannel);

            AioSessionConfig sessionConfig = buildSessionConfig(socketChannel);
            Session session = new AioTCPSession(sessionConfig,

                    AioTCPController.this.configuration
                            .getSessionReadBufferSize(),

                    AioTCPController.this.sessionTimeout);
            session.start();

            registerSession(session);
        } catch (Exception e) {

            e.printStackTrace();
            logger.error(&quot;Accept error&quot;, e);

            notifyException(e);
        } finally {
</code></pre><p><strong>pendingAccept</strong></p>
<p>();
            }</p>
<pre><code>    }


    @Override
    public void failed(Throwable exc, Object attachment) {

        logger.error(&quot;Accept error&quot;, exc);
        try {

            notifyException(exc);
        } finally {
</code></pre><p><strong>pendingAccept</strong></p>
<p>();
            }</p>
<pre><code>    }
}



注意到了吧，我们在failed和completed方法中在最后都调用了pendingAccept来继续发起accept调用，等待新的连接上来。有的同学可能要说了，这样搞是不是递归调用，会不会堆栈溢出？实际上不会，因为发起accept调用的线程与CompletionHandler回调的线程并非同一个，不是一个上下文中，两者之间没有耦合关系。要注意到，CompletionHandler的回调共用的是 AsynchronousChannelGroup绑定的线程池，因此**千万别在CompletionHandler回调方法中调用阻塞或者长时间的操作**，例如sleep，回调方法最好能支持超时，防止线程池耗尽。
连接建立后，怎么读和写呢？回忆下在nonblocking nio框架中，连接建立后的第一件事是干什么？注册OP_READ事件等待socket可读。异步IO也同样如此，连接建立后马上发起一个异步read调用，等待socket可读，这个是Session.start方法中所做的事情：
</code></pre><p>Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>public class AioTCPSession {  </li>
<li>protected void start0() {  </li>
<li>pendingRead();  </li>
<li>}  </li>
<li></li>
<li>protected final void pendingRead() {  </li>
<li>if (!isClosed() &amp;&amp; this.asynchronousSocketChannel.isOpen()) {  </li>
<li>if (!this.readBuffer.hasRemaining()) {  </li>
<li>this.readBuffer = ByteBufferUtils  </li>
<li>.increaseBufferCapatity(this.readBuffer);  </li>
<li>}  </li>
<li>this.readFuture = this.asynchronousSocketChannel.read(  </li>
<li>this.readBuffer, this, this.readCompletionHandler);  </li>
<li>} else {  </li>
<li>throw new IllegalStateException(  </li>
<li>&quot;Session Or Channel has been closed&quot;);  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>}  </li>
</ol>
<p>public class AioTCPSession {</p>
<pre><code>protected void start0() {
    pendingRead();

}


protected final void pendingRead() {
    if (!isClosed() &amp;&amp; this.asynchronousSocketChannel.isOpen()) {

        if (!this.readBuffer.hasRemaining()) {
            this.readBuffer = ByteBufferUtils

                    .increaseBufferCapatity(this.readBuffer);
        }

        this.readFuture = this.asynchronousSocketChannel.read(
                this.readBuffer, this, this.readCompletionHandler);

    } else {
        throw new IllegalStateException(

                &quot;Session Or Channel has been closed&quot;);
    }

}
</code></pre><p>}</p>
<pre><code> AsynchronousSocketChannel的read调用与AsynchronousServerSocketChannel的accept调用类似，同样是非阻塞的，返回结果也是一个Future，但是写的结果是整数，表示写入了多少字节，因此read调用返回的是 **Future&lt;Integer&gt;**，方法的第一个参数是读的缓冲区，操作系统将IO读到数据拷贝到这个缓冲区，第二个参数是传递给 CompletionHandler的attchment，第三个参数就是注册的用于回调的CompletionHandler。这里保存了read的结果Future，这是为了在关闭连接的时候能够主动取消调用，accept也是如此。现在可以看看read的CompletionHandler的实现：
</code></pre><p>Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>public final class ReadCompletionHandler implements  </li>
<li>CompletionHandler<Integer, AbstractAioSession> {  </li>
<li></li>
<li>private static final Logger log = LoggerFactory  </li>
<li>.getLogger(ReadCompletionHandler.class);  </li>
<li>protected final AioTCPController controller;  </li>
<li></li>
<li>public ReadCompletionHandler(AioTCPController controller) {  </li>
<li>this.controller = controller;  </li>
<li>}  </li>
<li></li>
<li>@Override  </li>
<li>public void cancelled(AbstractAioSession session) {  </li>
<li>log.warn(&quot;Session(&quot; + session.getRemoteSocketAddress()  </li>
<li><ul>
<li>&quot;) read operation was canceled&quot;);  </li>
</ul>
</li>
<li>}  </li>
<li></li>
<li>@Override  </li>
<li>public void completed(Integer result, AbstractAioSession session) {  </li>
<li>if (log.isDebugEnabled())  </li>
<li>log.debug(&quot;Session(&quot; + session.getRemoteSocketAddress()  </li>
<li><ul>
<li>&quot;) read +&quot; + result + &quot; bytes&quot;);  </li>
</ul>
</li>
<li>if (result &lt; 0) {  </li>
<li>session.close();  </li>
<li>return;  </li>
<li>}  </li>
<li>try {  </li>
<li>if (result &gt; 0) {  </li>
<li>session.updateTimeStamp();  </li>
<li>session.getReadBuffer().flip();  </li>
<li>session.decode();  </li>
<li>session.getReadBuffer().compact();  </li>
<li>}  </li>
<li>} finally {  </li>
<li>try {  </li>
<li>session.pendingRead();  </li>
<li>} catch (IOException e) {  </li>
<li>session.onException(e);  </li>
<li>session.close();  </li>
<li>}  </li>
<li>}  </li>
<li>controller.checkSessionTimeout();  </li>
<li>}  </li>
<li></li>
<li>@Override  </li>
<li>public void failed(Throwable exc, AbstractAioSession session) {  </li>
<li>log.error(&quot;Session read error&quot;, exc);  </li>
<li>session.onException(exc);  </li>
<li>session.close();  </li>
<li>}  </li>
<li></li>
<li>}  </li>
</ol>
<p>public final class ReadCompletionHandler implements</p>
<pre><code>    CompletionHandler&lt;Integer, AbstractAioSession&gt; {


private static final Logger log = LoggerFactory
        .getLogger(ReadCompletionHandler.class);

protected final AioTCPController controller;


public ReadCompletionHandler(AioTCPController controller) {
    this.controller = controller;

}


@Override
public void cancelled(AbstractAioSession session) {

    log.warn(&quot;Session(&quot; + session.getRemoteSocketAddress()
            + &quot;) read operation was canceled&quot;);

}


@Override
public void completed(Integer result, AbstractAioSession session) {

    if (log.isDebugEnabled())
        log.debug(&quot;Session(&quot; + session.getRemoteSocketAddress()

                + &quot;) read +&quot; + result + &quot; bytes&quot;);
    if (result &lt; 0) {

        session.close();
        return;

    }
    try {

        if (result &gt; 0) {
            session.updateTimeStamp();

            session.getReadBuffer().flip();
            session.decode();

            session.getReadBuffer().compact();
        }

    } finally {
        try {

            session.pendingRead();
        } catch (IOException e) {

            session.onException(e);
            session.close();

        }
    }

    controller.checkSessionTimeout();
}


@Override

public void failed(Throwable exc, AbstractAioSession session) {
    log.error(&quot;Session read error&quot;, exc);

    session.onException(exc);
    session.close();

}
</code></pre><p>}</p>
<p>   如果IO读失败，会返回失败产生的异常，这种情况下我们就主动关闭连接，通过session.close()方法，这个方法干了两件事情：关闭channel和取消read调用：</p>
<p>Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>if (null != this.readFuture) {  </li>
<li>this.readFuture.cancel(true);  </li>
<li>}  </li>
<li>this.asynchronousSocketChannel.close();  </li>
</ol>
<p>if (null != this.readFuture) {</p>
<pre><code>        this.readFuture.cancel(true);
    }
</code></pre><p>this.asynchronousSocketChannel.close();</p>
<p>   在读成功的情况下，我们还需要判断结果result是否小于0，<strong>如果小于0就表示对端关闭了</strong>，这种情况下我们也主动关闭连接并返回。如果读到一定字节，也就是result大于0的情况下，我们就尝试从读缓冲区中decode出消息，并派发给业务处理器的回调方法，最终<strong>通过pendingRead继续发起read调用等待socket的下一次可读</strong>。可见，我们并不需要自己去调用channel来进行IO读，而是操作系统帮你直接读到了缓冲区，然后给你一个结果表示读入了多少字节，你处理这个结果即可。而nonblocking IO框架中，是reactor通知用户线程socket可读了，然后用户线程自己去调用read进行实际读操作。这里还有个需要注意的地方，就是decode出来的消息的派发给业务处理器工作最好交给一个线程池来处理，避免阻塞group绑定的线程池。</p>
<p>   IO写的操作与此类似，不过通常写的话我们会在session中关联一个缓冲队列来处理，没有完全写入或者等待写入的消息都存放在队列中，队列为空的情况下发起write调用：</p>
<p>Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>protected void write0(WriteMessage message) {  </li>
<li>boolean needWrite = false;  </li>
<li>synchronized (this.writeQueue) {  </li>
<li>needWrite = this.writeQueue.isEmpty();  </li>
<li>this.writeQueue.offer(message);  </li>
<li>}  </li>
<li>if (needWrite) {  </li>
<li>pendingWrite(message);  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>protected final void pendingWrite(WriteMessage message) {  </li>
<li>message = preprocessWriteMessage(message);  </li>
<li>if (!isClosed() &amp;&amp; this.asynchronousSocketChannel.isOpen()) {  </li>
<li>this.asynchronousSocketChannel.write(message.getWriteBuffer(),  </li>
<li>this, this.writeCompletionHandler);  </li>
<li>} else {  </li>
<li>throw new IllegalStateException(  </li>
<li>&quot;Session Or Channel has been closed&quot;);  </li>
<li>}  </li>
<li><p>}  </p>
<p>protected void write0(WriteMessage message) {</p>
<p>   boolean needWrite = false;
   synchronized (this.writeQueue) {</p>
<pre><code>   needWrite = this.writeQueue.isEmpty();
   this.writeQueue.offer(message);
</code></pre><p>   }
   if (needWrite) {</p>
<pre><code>   pendingWrite(message);
</code></pre><p>   }</p>
<p>}</p>
</li>
</ol>
<pre><code>protected final void pendingWrite(WriteMessage message) {
    message = preprocessWriteMessage(message);

    if (!isClosed() &amp;&amp; this.asynchronousSocketChannel.isOpen()) {
        this.asynchronousSocketChannel.write(message.getWriteBuffer(),

                this, this.writeCompletionHandler);
    } else {

        throw new IllegalStateException(
                &quot;Session Or Channel has been closed&quot;);

    }
}




write调用返回的结果与read一样是一个Future&lt;Integer&gt;，而write的CompletionHandler处理的核心逻辑大概是这样：
</code></pre><p>Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>@Override  </li>
<li>public void completed(Integer result, AbstractAioSession session) {  </li>
<li>if (log.isDebugEnabled())  </li>
<li>log.debug(&quot;Session(&quot; + session.getRemoteSocketAddress()  </li>
<li><ul>
<li>&quot;) writen &quot; + result + &quot; bytes&quot;);  </li>
</ul>
</li>
<li></li>
<li>WriteMessage writeMessage;  </li>
<li>Queue<WriteMessage> writeQueue = session.getWriteQueue();  </li>
<li>synchronized (writeQueue) {  </li>
<li>writeMessage = writeQueue.peek();  </li>
<li>if (writeMessage.getWriteBuffer() == null  </li>
<li>|| !writeMessage.getWriteBuffer().hasRemaining()) {  </li>
<li>writeQueue.remove();  </li>
<li>if (writeMessage.getWriteFuture() != null) {  </li>
<li>writeMessage.getWriteFuture().setResult(Boolean.TRUE);  </li>
<li>}  </li>
<li>try {  </li>
<li>session.getHandler().onMessageSent(session,  </li>
<li>writeMessage.getMessage());  </li>
<li>} catch (Exception e) {  </li>
<li>session.onException(e);  </li>
<li>}  </li>
<li>writeMessage = writeQueue.peek();  </li>
<li>}  </li>
<li>}  </li>
<li>if (writeMessage != null) {  </li>
<li>try {  </li>
<li>session.pendingWrite(writeMessage);  </li>
<li>} catch (IOException e) {  </li>
<li>session.onException(e);  </li>
<li>session.close();  </li>
<li>}  </li>
<li>}  </li>
<li>}  </li>
</ol>
<p>@Override</p>
<pre><code>public void completed(Integer result, AbstractAioSession session) {
    if (log.isDebugEnabled())

        log.debug(&quot;Session(&quot; + session.getRemoteSocketAddress()
                + &quot;) writen &quot; + result + &quot; bytes&quot;);


    WriteMessage writeMessage;

    Queue&lt;WriteMessage&gt; writeQueue = session.getWriteQueue();
    synchronized (writeQueue) {

        writeMessage = writeQueue.peek();
        if (writeMessage.getWriteBuffer() == null

                || !writeMessage.getWriteBuffer().hasRemaining()) {
            writeQueue.remove();

            if (writeMessage.getWriteFuture() != null) {
                writeMessage.getWriteFuture().setResult(Boolean.TRUE);

            }
            try {

                session.getHandler().onMessageSent(session,
                        writeMessage.getMessage());

            } catch (Exception e) {
                session.onException(e);

            }
            writeMessage = writeQueue.peek();

        }
    }

    if (writeMessage != null) {
        try {

            session.pendingWrite(writeMessage);
        } catch (IOException e) {

            session.onException(e);
            session.close();

        }
    }

}
</code></pre><p>   compete方法中的result就是实际写入的字节数，然后我们判断消息的缓冲区是否还有剩余，如果没有就将消息从队列中移除，如果队列中还有消息，那么继续发起write调用。
   重复一下，这里引用的代码都是yanf4j aio分支中的源码，感兴趣的朋友可以直接check out出来看看: <a href="http://yanf4j.googlecode.com/svn/branches/yanf4j-aio" target="_blank"><a href="http://yanf4j.googlecode.com/svn/branches/yanf4j-aio">http://yanf4j.googlecode.com/svn/branches/yanf4j-aio</a></a>。
   在引入了aio之后，java对于网络层的支持已经非常完善，该有的都有了，java也已经成为服务器开发的首选语言之一。java的弱项在于对内存的管理上，由于这一切都交给了GC，因此在高性能的网络服务器上还是Cpp的天下。java这种单一堆模型比之erlang的进程内堆模型还是有差距，很难做到高效的垃圾回收和细粒度的内存管理。
   这里仅仅是介绍了aio开发的核心流程，对于一个网络框架来说，还需要考虑超时的处理、缓冲buffer的处理、业务层和网络层的切分、可扩展性、性能的可调性以及一定的通用性要求。</p>
<p>刚看了一点，第一行有个错别字，不是IO服用，是复用，嘿嘿
老大终于开始介绍java NIO了。。
还有一点，看过一些源代码，对事件驱动还是理解不深，也请老大介绍下把。
rain2005 写道</p>
<p>刚看了一点，第一行有个错别字，不是IO服用，是复用，嘿嘿
老大终于开始介绍java NIO了。。
还有一点，看过一些源代码，对事件驱动还是理解不深，也请老大介绍下把。
多谢指正，关于事件机制，我会画个UML图可能比较清晰</p>
<p>上面提到几个类 怎么在jdk6中没发现那
是不是要下载第三方框架
正好想研究一下
收藏啦
xly_971223 写道</p>
<p>上面提到几个类 怎么在jdk6中没发现那
是不是要下载第三方框架
正好想研究一下
收藏啦
aio是在jdk7引入的，请下载JDK7 preview1版本，或者open jdk</p>
<p>dennis_zane 写道</p>
<p>xly_971223 写道</p>
<p>上面提到几个类 怎么在jdk6中没发现那
是不是要下载第三方框架
正好想研究一下
收藏啦
aio是在jdk7引入的，请下载JDK7 preview1版本，或者open jdk
是不是这个意思。
jdk7以前的nio是非阻塞IO,操作系统底层比方说linux,是用IO复用select实现的
jdk7用的是真正的异步IO,操作系统底层是用epoll实现的
是这样的吗？
rain2005 写道</p>
<p>dennis_zane 写道</p>
<p>xly_971223 写道</p>
<p>上面提到几个类 怎么在jdk6中没发现那
是不是要下载第三方框架
正好想研究一下
收藏啦
aio是在jdk7引入的，请下载JDK7 preview1版本，或者open jdk
是不是这个意思。
jdk7以前的nio是非阻塞IO,操作系统底层比方说linux,是用IO复用select实现的
jdk7用的是真正的异步IO,操作系统底层是用epoll实现的
是这样的吗？
epoll也不是异步IO啊。异步IO在linux上目前仅限于文件系统，并且还没有得到广泛应用，很多平台都没有这玩意。
java aio在windows上是利用iocp实现的，这是真正的异步IO。而在linux上，是通过epoll模拟的。</p>
<p>楼主，你好，我写的server是p2p的应用，恩，想请教一下，因为我对数据库这一块的操作并不是特别的多，基本是客户自己也有很多是服务器，不知道是否可以在事件响应的当前线程来对数据库操作呢？前提是把线程池子的数目设的大些？或者用那个JDK提供的可自己增加线程的池子？
因为如果在弄个池子来处理数据库的话，担心线程太多了，
你如果时间充分心情好的话，真希望你能讲解一下和别人公用一台服务器（主机）是怎么用的呢。。。
总之要谢谢你对这段代码的讲解，kang sang mi da
wujingsong 写道</p>
<p>楼主，你好，我写的server是p2p的应用，恩，想请教一下，因为我对数据库这一块的操作并不是特别的多，基本是客户自己也有很多是服务器，不知道是否可以在事件响应的当前线程来对数据库操作呢？前提是把线程池子的数目设的大些？或者用那个JDK提供的可自己增加线程的池子？
因为如果在弄个池子来处理数据库的话，担心线程太多了，
你如果时间充分心情好的话，真希望你能讲解一下和别人公用一台服务器（主机）是怎么用的呢。。。
总之要谢谢你对这段代码的讲解，kang sang mi da
按我的经验来说，类似数据库操作这样的IO操作，最好还是起个线程池来处理，防止阻塞框架内部的处理线程。如果这样的操作不是特别多，那么直接在响应线程处理也未尝不可，还是建议你自己搞两个版本性能对比一下。
wujingsong 写道</p>
<p>和别人公用一台是怎么用的呢？
我还真不明白什么意思，现在我们的应用基本都跑在虚拟机上了，几个应用跑在一个物理机上。虚拟化我不懂，就不乱弹了。</p>
<p>kang sa mi da,谢谢楼主的回复,确实是个很好的建议.
闲聊啊,今天无意看到Google 上一个音乐的图片链接,点进去后,看到了一个不大容易理解的词,说什么
            &quot;在南中国常年保持高收听率的极有个性的节目&quot;,
费解.....广东那边是这么叫的吗?不大可能吧..</p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/NIO/">NIO</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/NIO/" class="label label-success">NIO</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:41"datetime="2014-03-07 09:54:41"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-NIO--Javaaio异步网络IO初探/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-NIO--Javaaio异步网络IO初探" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-NIO--javanio网络编程的一点心得/">java nio网络编程的一点心得</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:41.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-NIO--javanio网络编程的一点心得/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="java-nio-">java nio网络编程的一点心得</h1>
<p>前几日用java nio写了一个<a href="http://code.google.com/p/marlon-tools/source/browse/tools/tcpmon/TCPMonitorSelect.java" target="_blank">tcp端口转发小工具</a>，还颇费周折，其中一个原因在于网上资料很混乱，不少还是错误的。这篇文章中我会以一个EchoServer作为例子。先看<a href="http://book.douban.com/subject/1438754/" target="_blank">《Java网络编程》</a>中的写法，这也是在网上颇为常见的一个写法。
Java代码  <a href="&quot;收藏这段代码&quot;"><img src="http://marlonyao.iteye.com/images/icon_star.png" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>public class EchoServer {  </li>
<li>public static int DEFAULT_PORT = 7777;  </li>
<li></li>
<li>public static void main(String[] args) throws IOException {  </li>
<li>System.out.println(&quot;Listening for connection on port &quot; + DEFAULT_PORT);  </li>
<li></li>
<li>Selector selector = Selector.open();  </li>
<li>initServer(selector);  </li>
<li></li>
<li>while (true) {  </li>
<li>selector.select();  </li>
<li></li>
<li>for (Iterator<SelectionKey> itor = selector.selectedKeys().iterator(); itor.hasNext();) {  </li>
<li>SelectionKey key = (SelectionKey) itor.next();  </li>
<li>itor.remove();  </li>
<li>try {  </li>
<li>if (key.isAcceptable()) {  </li>
<li>ServerSocketChannel server = (ServerSocketChannel) key.channel();  </li>
<li>SocketChannel client = server.accept();  </li>
<li>System.out.println(&quot;Accepted connection from &quot; + client);  </li>
<li>client.configureBlocking(false);  </li>
<li>SelectionKey clientKey = client.register(selector, SelectionKey.OP_WRITE|SelectionKey.OP_READ);  </li>
<li>ByteBuffer buffer = ByteBuffer.allocate(100);  </li>
<li>clientKey.attach(buffer);  </li>
<li>}  </li>
<li>if (key.isReadable()) {  </li>
<li>SocketChannel client = (SocketChannel) key.channel();  </li>
<li>ByteBuffer buffer = (ByteBuffer) key.attachment();  </li>
<li>client.read(buffer);  </li>
<li>}  </li>
<li>if (key.isWritable()) {  </li>
<li>// System.out.println(&quot;is writable...&quot;);  </li>
<li>SocketChannel client = (SocketChannel) key.channel();  </li>
<li>ByteBuffer buffer = (ByteBuffer) key.attachment();  </li>
<li>buffer.flip();  </li>
<li>client.write(buffer);  </li>
<li>buffer.compact();  </li>
<li>}  </li>
<li>} catch (IOException e) {  </li>
<li>key.cancel();  </li>
<li>try { key.channel().close(); } catch (IOException ioe) { }  </li>
<li>}  </li>
<li>}  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>private static void initServer(Selector selector) throws IOException,  </li>
<li>ClosedChannelException {  </li>
<li>ServerSocketChannel serverChannel = ServerSocketChannel.open();  </li>
<li>ServerSocket ss = serverChannel.socket();  </li>
<li>ss.bind(new InetSocketAddress(DEFAULT_PORT));  </li>
<li>serverChannel.configureBlocking(false);  </li>
<li>serverChannel.register(selector, SelectionKey.OP_ACCEPT);  </li>
<li>}  </li>
<li>}  </li>
</ol>
<p>public class EchoServer {</p>
<pre><code>public static int DEFAULT_PORT = 7777;


public static void main(String[] args) throws IOException {
    System.out.println(&quot;Listening for connection on port &quot; + DEFAULT_PORT);


    Selector selector = Selector.open();

    initServer(selector);


    while (true) {
        selector.select();


        for (Iterator&lt;SelectionKey&gt; itor = selector.selectedKeys().iterator(); itor.hasNext();) {

            SelectionKey key = (SelectionKey) itor.next();
            itor.remove();

            try {
                if (key.isAcceptable()) {

                    ServerSocketChannel server = (ServerSocketChannel) key.channel();
                    SocketChannel client = server.accept();

                    System.out.println(&quot;Accepted connection from &quot; + client);
                    client.configureBlocking(false);

                    SelectionKey clientKey = client.register(selector, SelectionKey.OP_WRITE|SelectionKey.OP_READ);
                    ByteBuffer buffer = ByteBuffer.allocate(100);

                    clientKey.attach(buffer);
                }

                if (key.isReadable()) {
                    SocketChannel client = (SocketChannel) key.channel();

                    ByteBuffer buffer = (ByteBuffer) key.attachment();
                    client.read(buffer);

                }
                if (key.isWritable()) {

                    // System.out.println(&quot;is writable...&quot;);
                    SocketChannel client = (SocketChannel) key.channel();

                    ByteBuffer buffer = (ByteBuffer) key.attachment();
                    buffer.flip();

                    client.write(buffer);
                    buffer.compact();

                }
            } catch (IOException e) {

                key.cancel();
                try { key.channel().close(); } catch (IOException ioe) { }

            }
        }

    }
}


private static void initServer(Selector selector) throws IOException,

        ClosedChannelException {
    ServerSocketChannel serverChannel = ServerSocketChannel.open();

    ServerSocket ss = serverChannel.socket();
    ss.bind(new InetSocketAddress(DEFAULT_PORT));

    serverChannel.configureBlocking(false);
    serverChannel.register(selector, SelectionKey.OP_ACCEPT);

}
</code></pre><p>}
上面的代码很典型，运行结果似乎也是正确的。
Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>marlon$ java EchoServer&amp;  </li>
<li>--&gt; Listening for connection on port 7777  </li>
<li>marlon$ telnet localhost 7777  </li>
<li>--&gt; Accepted connection from java.nio.channels.SocketChannel[connected local=/127.0.0.1:7777 remote=/127.0.0.1:65030]  </li>
<li>hello  </li>
<li>--&gt; hello  </li>
<li>world  </li>
<li>--&gt;world  </li>
</ol>
<p>marlon$ java EchoServer&amp;</p>
<p>--&gt; Listening for connection on port 7777
marlon$ telnet localhost 7777</p>
<p>--&gt; Accepted connection from java.nio.channels.SocketChannel[connected local=/127.0.0.1:7777 remote=/127.0.0.1:65030]
hello</p>
<p>--&gt; hello
world</p>
<p>--&gt;world
但是如果你这时top用看一下发现服务器进程CPU占用到95%以上，如果取消掉32行的注释，服务器会不断地输出&quot;is writable...&quot;，这是为什么呢？让我们来分析当第一个客户端连接上时发生什么情况。</p>
<ol>
<li>在连接之前，服务器第11行：selector.select()处阻塞。当阻塞时，内核会将这个进程调度至休眠状态，此时基本不耗CPU。</li>
<li>当客户端发起一个连接时，服务器检测到客户端连接，selector.select()返回。selector.selectedKeys()返回已就绪的SelectionKey的集合，在这种情况下，它只包含一个key，也就是53行注册的acceptable key。服务器开始运行17-25行的代码，server.accept()返回代码客户端连接的socket，第22行在socket上注册OP_READ和OP_WRITE，表示当socket可读或者可写时就会通知selector。</li>
<li>接着服务器又回到第11行，尽管这时客户端还没有任何输入，但这时selector.select()不会阻塞，因为22行在socket注册了写操作，而socket只要send buffer不满就可以写，刚开始send buffer为空，socket总是可以写，于是server.select()立即返回，包含在22行注册的key。由于这个key可写，所以服务器会运行31-38行的代码，但是这时buffer为空，client.write(buffer)没有向socket写任何东西，立即返回0。</li>
<li><p>接着服务器又回到第11行，由于客户端连接socket可以写，这时selector.select()会立即返回，然后运行31-38行的代码，像步骤3一样，由于buffer为空，服务器没有干任何事又返回到第11行，这样不断循环，服务器却实际没有干事情，却耗大量的CPU。
从上面的分析可以看出问题在于我们在没有数据可写时就在socket上注册了OP_WRITE，导致服务器浪费大量CPU资源，解决办法是<strong>只有数据可以写时才注册OP_WRITE操作</strong>。上面的版本还不只浪费CPU那么简单，它还可能导致潜在的死锁。虽然死锁在我的机器上没有发生，对于这个简单的例子似乎也不大可能发生在别的机器上，但是在对于复杂的情况，比如我写的端口转发工具中就发生了，这还依赖于jdk的实现。对于上面的EchoServer，出现死锁的场景是这样的：</p>
</li>
<li><p>假设服务器已经启动，并且已经有一个客户端与它相连，此时正如上面的分析，服务器在不断地循环做无用功。这时用户在客户端输入&quot;hello&quot;。</p>
</li>
<li><p>当服务器运行到第11行：selector.select()时，这时selector.selectedKeys()会返回一个代表客户端连接的key，显然这时客户端socket是既可读又可写，但jdk却并不保证能够检测到两种状态。如果它检测到key既可读又可写，那么服务器会执行26-38行的代码。如果只检测到可读，那么服务器会执行26-30行的代码。如果只检测到可写，那么会执行31－38行的代码。对于前两种情况，不会造成死锁，因为当执行完29行，buffer会读到用户输入的内容，下次再运行到36行就可以将用户输入内容echo回。但是对最后一种情况，服务器完全忽略了客户端发过来的内容，如果每次selector.select()都只能检测到socket可写，那么服务器永远不能将echo回客户端输入的内容。
避免死锁的一个简单方法就是<strong>不要在同一个socket同时注册多个操作</strong>。对于上面的EchoServer来说就是不要同时注册OP_READ和OP_WRITE，要么只注册OP_READ，要么只注册OP_WRITE。下面的EchoServer修正了以上的错误：
Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>public static void main(String[] args) throws IOException {  </p>
</li>
<li>System.out.println(&quot;Listening for connection on port &quot; + DEFAULT_PORT);  </li>
<li></li>
<li>Selector selector = Selector.open();  </li>
<li>initServer(selector);  </li>
<li></li>
<li>while (true) {  </li>
<li>selector.select();  </li>
<li></li>
<li>for (Iterator<SelectionKey> itor = selector.selectedKeys().iterator(); itor.hasNext();) {  </li>
<li>SelectionKey key = (SelectionKey) itor.next();  </li>
<li>itor.remove();  </li>
<li>try {  </li>
<li>if (key.isAcceptable()) {  </li>
<li>ServerSocketChannel server = (ServerSocketChannel) key.channel();  </li>
<li>SocketChannel client = server.accept();  </li>
<li>System.out.println(&quot;Accepted connection from &quot; + client);  </li>
<li>client.configureBlocking(false);  </li>
<li>SelectionKey clientKey = client.register(selector, SelectionKey.OP_READ);  </li>
<li>ByteBuffer buffer = ByteBuffer.allocate(100);  </li>
<li>clientKey.attach(buffer);  </li>
<li>} else if (key.isReadable()) {  </li>
<li>SocketChannel client = (SocketChannel) key.channel();  </li>
<li>ByteBuffer buffer = (ByteBuffer) key.attachment();  </li>
<li>int n = client.read(buffer);  </li>
<li>if (n &gt; 0) {  </li>
<li>buffer.flip();  </li>
<li>key.interestOps(SelectionKey.OP_WRITE);     // switch to OP_WRITE  </li>
<li>}  </li>
<li>} else if (key.isWritable()) {  </li>
<li>System.out.println(&quot;is writable...&quot;);  </li>
<li>SocketChannel client = (SocketChannel) key.channel();  </li>
<li>ByteBuffer buffer = (ByteBuffer) key.attachment();  </li>
<li>client.write(buffer);  </li>
<li>if (buffer.remaining() == 0) {  // write finished, switch to OP_READ  </li>
<li>buffer.clear();  </li>
<li>key.interestOps(SelectionKey.OP_READ);  </li>
<li>}  </li>
<li>}  </li>
<li>} catch (IOException e) {  </li>
<li>key.cancel();  </li>
<li>try { key.channel().close(); } catch (IOException ioe) { }  </li>
<li>}  </li>
<li>}  </li>
<li>}  </li>
<li><p>}  </p>
<p> public static void main(String[] args) throws IOException {</p>
<pre><code> System.out.println(&quot;Listening for connection on port &quot; + DEFAULT_PORT);
</code></pre></li>
</ol>
<pre><code>    Selector selector = Selector.open();
    initServer(selector);


    while (true) {

        selector.select();


        for (Iterator&lt;SelectionKey&gt; itor = selector.selectedKeys().iterator(); itor.hasNext();) {
            SelectionKey key = (SelectionKey) itor.next();

            itor.remove();
            try {

                if (key.isAcceptable()) {
                    ServerSocketChannel server = (ServerSocketChannel) key.channel();

                    SocketChannel client = server.accept();
                    System.out.println(&quot;Accepted connection from &quot; + client);

                    client.configureBlocking(false);
                    SelectionKey clientKey = client.register(selector, SelectionKey.OP_READ);

                    ByteBuffer buffer = ByteBuffer.allocate(100);
                    clientKey.attach(buffer);

                } else if (key.isReadable()) {
                    SocketChannel client = (SocketChannel) key.channel();

                    ByteBuffer buffer = (ByteBuffer) key.attachment();
                    int n = client.read(buffer);

                    if (n &gt; 0) {
                        buffer.flip();

                        key.interestOps(SelectionKey.OP_WRITE);        // switch to OP_WRITE
                    }

                } else if (key.isWritable()) {
                    System.out.println(&quot;is writable...&quot;);

                    SocketChannel client = (SocketChannel) key.channel();
                    ByteBuffer buffer = (ByteBuffer) key.attachment();

                    client.write(buffer);
                    if (buffer.remaining() == 0) {    // write finished, switch to OP_READ

                        buffer.clear();
                        key.interestOps(SelectionKey.OP_READ);

                    }
                }

            } catch (IOException e) {
                key.cancel();

                try { key.channel().close(); } catch (IOException ioe) { }
            }

        }
    }

}
</code></pre><p>主要变化，在第19行接受客户端连接时只注册OP_READ操作，第28行当读到数据时才切换到OP_WRITE操作，第35-38行，当写操作完成时再切换到OP_READ操作。由于一个key同时只能执行一个操作，我将原来三个并行if换成了if...else。
上面的代码不够优雅，它将处理服务器Socket和客户连接Socket的代码搅在一起，对于简单的EchoServer这样做没什么问题，当服务器变得复杂，使用命令模式将它们分开变显得非常必要。首先创建一个接口来抽象对SelectionKey的处理。
Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>interface Handler {  </li>
<li>void execute(Selector selector, SelectionKey key);  </li>
<li><p>}  </p>
<p> interface Handler {</p>
<pre><code> void execute(Selector selector, SelectionKey key);
</code></pre><p> }
再来看main函数：
Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>public static void main(String[] args) throws IOException {  </p>
</li>
<li>System.out.println(&quot;Listening for connection on port &quot; + DEFAULT_PORT);  </li>
<li></li>
<li>Selector selector = Selector.open();  </li>
<li>initServer(selector);  </li>
<li></li>
<li>while (true) {  </li>
<li>selector.select();  </li>
<li></li>
<li>for (Iterator<SelectionKey> itor = selector.selectedKeys().iterator(); itor.hasNext();) {  </li>
<li>SelectionKey key = (SelectionKey) itor.next();  </li>
<li>itor.remove();  </li>
<li>Handler handler = (Handler) key.attachment();  </li>
<li>handler.execute(selector, key);  </li>
<li>}  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>private static void initServer(Selector selector) throws IOException,  </li>
<li>ClosedChannelException {  </li>
<li>ServerSocketChannel serverChannel = ServerSocketChannel.open();  </li>
<li>ServerSocket ss = serverChannel.socket();  </li>
<li>ss.bind(new InetSocketAddress(DEFAULT_PORT));  </li>
<li>serverChannel.configureBlocking(false);  </li>
<li>SelectionKey serverKey = serverChannel.register(selector, SelectionKey.OP_ACCEPT);  </li>
<li>serverKey.attach(new ServerHandler());  </li>
<li><p>}  </p>
<p> public static void main(String[] args) throws IOException {</p>
<pre><code> System.out.println(&quot;Listening for connection on port &quot; + DEFAULT_PORT);
</code></pre></li>
</ol>
<pre><code>    Selector selector = Selector.open();
    initServer(selector);


    while (true) {

        selector.select();


        for (Iterator&lt;SelectionKey&gt; itor = selector.selectedKeys().iterator(); itor.hasNext();) {
            SelectionKey key = (SelectionKey) itor.next();

            itor.remove();
            Handler handler = (Handler) key.attachment();

            handler.execute(selector, key);
        }

    }
}


private static void initServer(Selector selector) throws IOException,

        ClosedChannelException {
    ServerSocketChannel serverChannel = ServerSocketChannel.open();

    ServerSocket ss = serverChannel.socket();
    ss.bind(new InetSocketAddress(DEFAULT_PORT));

    serverChannel.configureBlocking(false);
    SelectionKey serverKey = serverChannel.register(selector, SelectionKey.OP_ACCEPT);

    serverKey.attach(new ServerHandler());
}
</code></pre><p>main函数非常简单，迭代SelectionKey，对每个key的attachment为Handler，调用它的execute的方法，不用管它是服务器Socket还是客户Socket。注意initServer方法将serverKey附加了一个ServerHandler。下面是ServerHandler的代码：
Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>class ServerHandler implements Handler {  </li>
<li>public void execute(Selector selector, SelectionKey key) {  </li>
<li>ServerSocketChannel server = (ServerSocketChannel) key.channel();  </li>
<li>SocketChannel client = null;  </li>
<li>try {  </li>
<li>client = server.accept();  </li>
<li>System.out.println(&quot;Accepted connection from &quot; + client);  </li>
<li>} catch (IOException e) {  </li>
<li>e.printStackTrace();  </li>
<li>return;  </li>
<li>}  </li>
<li></li>
<li>SelectionKey clientKey = null;  </li>
<li>try {  </li>
<li>client.configureBlocking(false);  </li>
<li>clientKey = client.register(selector, SelectionKey.OP_READ);  </li>
<li>clientKey.attach(new ClientHandler());  </li>
<li>} catch (IOException e) {  </li>
<li>if (clientKey != null)  </li>
<li>clientKey.cancel();  </li>
<li>try { client.close(); } catch (IOException ioe) { }  </li>
<li>}  </li>
<li>}  </li>
<li><p>}  </p>
<p> class ServerHandler implements Handler {</p>
<pre><code> public void execute(Selector selector, SelectionKey key) {
     ServerSocketChannel server = (ServerSocketChannel) key.channel();

     SocketChannel client = null;
     try {

         client = server.accept();
         System.out.println(&quot;Accepted connection from &quot; + client);

     } catch (IOException e) {
         e.printStackTrace();

         return;
     }
</code></pre></li>
</ol>
<pre><code>        SelectionKey clientKey = null;

        try {
            client.configureBlocking(false);

            clientKey = client.register(selector, SelectionKey.OP_READ);
            clientKey.attach(new ClientHandler());

        } catch (IOException e) {
            if (clientKey != null)

                clientKey.cancel();
            try { client.close(); } catch (IOException ioe) { }

        }
    }

}
</code></pre><p>ServerHandler接收连接，为每个客户Socket注册OP_READ操作，返回的clientKey附加上ClientHandler。
Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>class ClientHandler implements Handler {  </li>
<li>private ByteBuffer buffer;  </li>
<li></li>
<li>public ClientHandler() {  </li>
<li>buffer = ByteBuffer.allocate(100);  </li>
<li>}  </li>
<li></li>
<li>public void execute(Selector selector, SelectionKey key) {  </li>
<li>try {  </li>
<li>if (key.isReadable()) {  </li>
<li>readKey(selector, key);  </li>
<li>} else if (key.isWritable()) {  </li>
<li>writeKey(selector, key);  </li>
<li>}  </li>
<li>} catch (IOException e) {  </li>
<li>key.cancel();  </li>
<li>try { key.channel().close(); } catch (IOException ioe) { }  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>private void readKey(Selector selector, SelectionKey key) throws IOException {  </li>
<li>SocketChannel client = (SocketChannel) key.channel();  </li>
<li>int n = client.read(buffer);  </li>
<li>if (n &gt; 0) {  </li>
<li>buffer.flip();  </li>
<li>key.interestOps(SelectionKey.OP_WRITE);     // switch to OP_WRITE  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>private void writeKey(Selector selector, SelectionKey key) throws IOException {  </li>
<li>// System.out.println(&quot;is writable...&quot;);  </li>
<li>SocketChannel client = (SocketChannel) key.channel();  </li>
<li>client.write(buffer);  </li>
<li>if (buffer.remaining() == 0) {  // write finished, switch to OP_READ  </li>
<li>buffer.clear();  </li>
<li>key.interestOps(SelectionKey.OP_READ);  </li>
<li>}  </li>
<li>}  </li>
<li><p>}  </p>
<p> class ClientHandler implements Handler {</p>
<pre><code> private ByteBuffer buffer;
</code></pre></li>
</ol>
<pre><code>    public ClientHandler() {
        buffer = ByteBuffer.allocate(100);

    }


    public void execute(Selector selector, SelectionKey key) {
        try {

            if (key.isReadable()) {
                readKey(selector, key);

            } else if (key.isWritable()) {
                writeKey(selector, key);

            }
        } catch (IOException e) {

            key.cancel();
            try { key.channel().close(); } catch (IOException ioe) { }

        }
    }


    private void readKey(Selector selector, SelectionKey key) throws IOException {

        SocketChannel client = (SocketChannel) key.channel();
        int n = client.read(buffer);

        if (n &gt; 0) {
            buffer.flip();

            key.interestOps(SelectionKey.OP_WRITE);        // switch to OP_WRITE
        }

    }


    private void writeKey(Selector selector, SelectionKey key) throws IOException {
        // System.out.println(&quot;is writable...&quot;);

        SocketChannel client = (SocketChannel) key.channel();
        client.write(buffer);

        if (buffer.remaining() == 0) {    // write finished, switch to OP_READ
            buffer.clear();

            key.interestOps(SelectionKey.OP_READ);
        }

    }
}
</code></pre><p>这个代码没有什么新内容，只是将根据key是可读还可写拆分为两个方法，代码结构显得更清晰。对于EchoServer，这么做确实有些过度工程，对于稍微复杂一点的服务器这么做是很值得的。
代码：<a href="http://pastebin.com/de64ZzUy" target="_blank">EchoServer.java</a>, <a href="http://pastebin.com/fFy0Uhbm" target="_blank">EchoServer2.java</a>, <a href="http://pastebin.com/DRMT4LdJ" target="_blank">EchoServer3.java</a>
参考：</p>
<ol>
<li><a href="http://rox-xmlrpc.sourceforge.net/niotut/" target="_blank">The Rox Java NIO Tutorial</a></li>
<li><a href="http://today.java.net/pub/a/today/2007/02/13/architecture-of-highly-scalable-nio-server.html" target="_blank">Architecture of a Highly Scalable NIO-Based Server</a></li>
</ol>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/NIO/">NIO</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/NIO/" class="label label-success">NIO</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:41"datetime="2014-03-07 09:54:41"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-NIO--javanio网络编程的一点心得/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-NIO--javanio网络编程的一点心得" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-SQL_Java--Java中，获得ResultSet的总行数与总列数/">Java中，获得ResultSet的总行数与总列数</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:41.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-SQL_Java--Java中，获得ResultSet的总行数与总列数/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="java-resultset-">Java中，获得ResultSet的总行数与总列数</h1>
<h2 id="java-resultset-">Java中，获得ResultSet的总行数与总列数</h2>
<p>在Java中，获得ResultSet的总行数的方法有以下几种。</p>
<p><strong>第一种：利用ResultSet的getRow方法来获得ResultSet的总行数</strong></p>
<p>Statement stmt = con.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_UPDATABLE);
ResultSet rset = stmt.executeQuery(&quot;select /* from yourTableName&quot;);
rset.last();
int rowCount = rset.getRow(); //获得ResultSet的总行数</p>
<p><strong>第二种：利用循环ResultSet的元素来获得ResultSet的总行数</strong></p>
<p>ResultSet rset = stmt.executeQuery(&quot;select /* from yourTableName&quot;);
int rowCount = 0;
while(rset.next()) {
rowCount++;
}</p>
<p>rowCount就是ResultSet的总行数。</p>
<p><strong>第三种：利用sql语句中的count函数获得ResultSet的总行数</strong></p>
<p>ResultSet rset = stmt.executeQuery(&quot;select count(/*) totalCount from yourTableName&quot;);
int rowCount = 0;
if(rset.next()) {
rowCount=rset .getInt(&quot;totalCount &quot;);
}</p>
<p>rowCount就是ResultSet的总行数。</p>
<ul>
<li>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/*</li>
<li>Java中获得ResultSet的总列数是非常简单事情，因为Java中ResultSet提供了ResultSetMetaData工具类,ResultSetMetaData 是ResultSet的元数据的集合说明。</li>
</ul>
<p>java获得ResultSet总列数的代码如下：</p>
<p>Statement stmt = con.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_UPDATABLE);
ResultSet rset = stmt.executeQuery(&quot;select /* from yourtable&quot;);
ResultSetMetaData rsmd = rset.getMetaData() ;
int columnCount = rsmd.getColumnCount();</p>
<p>columnCount 就是ResultSet的总列数。</p>
<hr>
<p>例子：
Statement stmt = conn.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,  ResultSet.CONCUR_READ_ONLY);   ResultSet rs = stmt.executeQuery(sql);   rs.last();   int length = rs.getRow();</p>
<p>如上，length的值，就是行数了。如果在获取了行数后，还需要继续使用当前数据集rs，则需要rs.beforeFirst();一次，将游标回到初始位置。
ResultSet.TYPE_SCROLL_INSENSITIVE 结果集的游标可以上下移动，当数据库变化时，当前结果集不变。
ResultSet.CONCUR_READ_ONLY 不能用结果集更新数据库中的表。</p>
<p>此外，给出Statement创建时的其他说明：
通用格式为：Statement stmt=con.createStatement(int type，int concurrency);我们在访问数据库的时候，在读取返回结果的时候，可能要前后移动指针，比如我们先计算有多少条信息，这是我们就需要把指针移到最后来计算，然后再把指针移到最前面，逐条读取，有时我们只需要逐条读取就可以了。还有就是有只我们只需要读取数据，为了不破坏数据，我们可采用只读模式，有时我们需要望数据库里添加记录，这是我们就要采用可更新数据库的模式。
下面是所有参数的说明：
参数 int type
ResultSet.TYPE_FORWORD_ONLY 结果集的游标只能向下滚动。
ResultSet.TYPE_SCROLL_INSENSITIVE 结果集的游标可以上下移动，当数据库变化时，当前结果集不变。
ResultSet.TYPE_SCROLL_SENSITIVE 返回可滚动的结果集，当数据库变化时，当前结果集同步改变。</p>
<p>参数 int concurrency</p>
<p>ResultSet.CONCUR_READ_ONLY 不能用结果集更新数据库中的表。
ResultSet.CONCUR_UPDATETABLE 能用结果集更新数据库中的表。</p>
<p>此外，当我们使用ResultSet re=stmt.executeQuery(SQL语句）查询后，我们可以使用下列方法获得信息：</p>
<p>public boolean previous() 将游标向上移动，该方法返回boolean型数据，当移到结果集第一行之前时，返回false。
public void beforeFirst 将游标移动到结果集的初始位置，即在第一行之前。
public void afterLast() 将游标移到结果集最后一行之后。
public void first() 将游标移到结果集的第一行。
public void last() 将游标移到结果集的最后一行。
public boolean isAfterLast() 判断游标是否在最后一行之后。
public boolean isBeforeFirst() 判断游标是否在第一行之前。
public boolean ifFirst() 判断游标是否指向结果集的第一行。
public boolean isLast() 判断游标是否指向结果集的最后一行。
public int getRow() 得到当前游标所指向行的行号，行号从1开始，如果结果集没有行，返回0。
public boolean absolute(int row) 将游标移到参数row指定的行号。如果row取负值，就是倒数的行数，absolute(-1)表示移到最后一行，absolute(-2)表示移到倒数第2行。当移动到第一行前面或最后一行的后面时，该方法返回false。</p>
<p>ResultSetMetaData rsmd = this.rs.getMetaData();
this.columnCount = rsmd.getColumnCount();</p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/SQL_Java/">SQL_Java</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/SQL_Java/" class="label label-success">SQL_Java</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:41"datetime="2014-03-07 09:54:41"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-SQL_Java--Java中，获得ResultSet的总行数与总列数/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-SQL_Java--Java中，获得ResultSet的总行数与总列数" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>





<ul id="pagination" class="pagination pagination-lg">
  <li><a class="extend prev" href="/page/54/">&laquo;</a></li><li><a class="page-number" href="/">1</a></li><li><a class="page-number" href="/page/2/">2</a></li><li><span class="space">&hellip;</span></li><li><a class="page-number" href="/page/52/">52</a></li><li><a class="page-number" href="/page/53/">53</a></li><li><a class="page-number" href="/page/54/">54</a></li><li class="active"><li><span class="page-number current">55</span></li><li><a class="page-number" href="/page/56/">56</a></li><li><a class="page-number" href="/page/57/">57</a></li><li><a class="page-number" href="/page/58/">58</a></li><li><span class="space">&hellip;</span></li></li><li><a class="page-number" href="/page/161/">161</a></li><li><a class="page-number" href="/page/162/">162</a></li><li><a class="extend next" href="/page/56/">&raquo;</a></li>
  <div class="clearfix"></div>
</ul></div><!--wapper-->
       </div><!-- ID main-col END -->
       <aside id="sidebar" class="alignright col-sx-6 col-sm-4 col-md-3 col-lg-3">
<div id="widget_search" class="widget panel panel-primary">
    <form action="//google.com/search" method="get" accept-charset="utf-8">
  <div class="input-group">
    <input class="form-control" id="searchbox" type="search" name="q" results="0" placeholder="search">
    <span class="input-group-btn">
      <button class="btn btn-default" type="submit">Go!</button>
    </span>
    <input type="hidden" name="q" value="site:itsolife.com">
  </div>
</form>
</div>

<div id="widget_category" class="widget panel panel-primary">
  <div class="panel-heading">category</div>  <div data-src='category' class='ajax_widgets'>正在加载...</div>
</div>

<div id="widget_recent_posts" class="widget panel panel-primary">
  <div class="panel-heading">recent posts</div>  <div data-src='recent_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_tagcloud" class="widget panel panel-primary">
  <div class="panel-heading">tagcloud</div>  <div data-src='tagcloud' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_latest_update_posts" class="widget panel panel-primary">
  <div class="panel-heading">最近更新</div>  <div data-src='latest_update_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_recent_comments" class="widget panel panel-primary">
  <div class="panel-heading">recent comments</div>  

<div class="list-group-item ds-recent-comments" data-num-items="6" data-show-avatars="1" data-show-time="1" data-show-title="1" data-show-admin="1" data-excerpt-length="50"></div>



</div>

</aside>
       <div class="clearfix"></div>
     </div><!-- row END -->
  </div>
  <footer id="footer" class="container">
  <div class="panel panel-info">
  <section id='footer_widget'></section>  <div class="panel-footer">
  <div id="site-info">
    <span class='author'>
  
  &copy; 2014 RobinChia
  
    &nbsp;&nbsp;</span>
  
  <span id='analytics-51la'></span><span id='analytics-google'>
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-48559895-1']);
  _gaq.push(['_trackPageview']);
  _js2load.push({src:('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'});
</script></span><span id='analytics-cnzz'>
<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_5774006'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s17.cnzz.com/stat.php%3Fid%3D5774006%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>
</span><span id='analytics-baidu'>
<script>
var _hmt = _hmt || [];
_js2load.push({src:"//hm.baidu.com/hm.js?1442f50724afc42380b51f097c43082c"});
</script>
</span>  </div>
  <div id="copyright">Site powered by <a href='http://zespia.tw/hexo/'><strong>hexo</strong></a>  update time: <em>2014-04-07 17:30:36</em></span></div>
</div>
<div class="clearfix"></div>


  </div>
  </footer>
  
        <script src="http://cdn.bootcss.com/jquery/1.10.2/jquery.min.js"></script>        
        <script src="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/js/bootstrap.min.js"></script>        
                
        <script src="http://cdn.bootcss.com/prettify/r298/prettify.min.js"></script>    <script type="text/javascript">
   var lang=["bsh", "c", "cc", "cpp", "cs", "csh", "cyc", "cv", "htm", "html",
    "java", "js", "m", "mxml", "perl", "pl", "pm", "py", "rb", "sh",
    "xhtml", "xml", "xsl"];
   var pretty_base='';
   $('script').each(function(){
	var c = $(this).attr('src');
	if (!c)
	    return;
	if (c.match(/(\/)?prettify(\.min)?\.js/i))
	{
	    var index = c.lastIndexOf('/');
	    if (index != -1)
		pretty_base = c.substr(0,index + 1);
	    return false;
	}
   })
   $('pre code').each(function(){
	var c = $(this).attr('class')
	if (!c)
	    return;
	c = c.match(/\s?(lang\-\w+)/i);
	if (c && lang.indexOf(c[1]) == -1)
	{
	    lang.push(c[1]);
	    $.getScript(pretty_base + c[1] + '.min.js');
	}
   })

    $(window).load(function(){
       $("pre").addClass("prettyprint");
       prettyPrint();
    })
</script>    
            <script type="text/javascript">
var duoshuoQuery = {short_name:"robinchia"};
_js2load.push({src:'http://static.duoshuo.com/embed.js',charset:'UTF-8'});
</script>
    
            <!--wumii_relatedItems-->
    
        <script src="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js"></script>    <script type="text/javascript">
(function($){
  $('.entry').each(function(i){
    $(this).find('img').each(function(){
      var alt = this.alt;

      if (alt){
        $(this).before('<span class="caption">' + alt + '</span>');
      }

      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox" rel="fancybox' + i + '" />');
    });
  });

  $('.fancybox').fancybox();
})(jQuery);
</script>    
        <script src="http://cdn.bootcss.com/mathjax/2.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>    <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>
    
<script type="text/javascript">
$('.ajax_widgets').each(function(){var src=$(this).attr('data-src');if(src)$(this).load('/widgets/'+src+'.html');});
$.each(_js2load,function(index,obj){loadjs(obj.src,obj.charset)});
</script>

<div id="scroll2top">
<img src="/scroll2top/arrow.png"/>
</div>
<script src="/scroll2top/scroll2top.min.js"></script>
<div id="winterland">
  <canvas></canvas>
</div>
<script src="/js/winterland.min.js"></script>

  </body>
</html>
