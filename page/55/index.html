
<!DOCTYPE HTML>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>The 55 Page | It so life</title>
<meta name="author" content="RobinChia">

<meta name="description" content="It so life">


<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<meta property="og:site_name" content="It so life"/>

<!--[if IE]><style>.testIE.IE{display:inline;}</style><![endif]-->
<!--[if lte IE 7]><link rel="stylesheet" href="/css/ie7.css" type="text/css"><![endif]-->
<!--[if (lt IE 9)&(gt IE 7)]><style>.testIE.IE8{display:inline;}</style><![endif]-->
<!--[if gt IE 8]><style>.testIE.IE9{display:inline;}</style><![endif]-->

<link href="/favicon.png" rel="icon">
<link rel="alternate" href="/atom.xml" title="It so life Feed" type="application/atom+xml">

<link rel="stylesheet" href="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/css/bootstrap.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/font-awesome/4.0.3/css/font-awesome.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/prettify/r298/prettify.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" type="text/css">
<link rel="stylesheet" href="/css/style.css" type="text/css">
<!--[if lt IE 9]>
   <style>article,aside,dialog,footer,header,section,footer,nav,figure,menu{display:block}</style>
   <script src="http://cdn.staticfile.org/html5shiv/r29/html5.min.js"></script>
   <script src="http://cdn.staticfile.org/respond.js/1.4.2/respond.min.js"></script>
<link href="http://cdn.staticfile.org/respond.js/1.4.2/respond-proxy.html" id="respond-proxy" rel="respond-proxy" />
<link href="/js/respond.proxy.gif" id="respond-redirect" rel="respond-redirect" />
<script src="/js/respond.proxy.js"></script>
   <script src="http://cdn.bootcss.com/selectivizr/1.0.2/selectivizr-min.js"></script>
<![endif]-->
<script type="text/javascript">
function loadjs(c,d){var a=document.createElement("script");a.async=!0;a.type="text/javascript";a.src=c;a.charset=d||"gbk";(document.getElementsByTagName("HEAD")[0]||document.getElementsByTagName("BODY")[0]).appendChild(a)};
var _protocol = (("https:" == document.location.protocol) ? " https://" : " http://");
var _js2load = [];
</script>

</head>
<body>
      <header id="header" class="container"><nav id="main-nav" class="navbar navbar-default navbar-fixed-top " role="navigation">
  <div class="container">
    <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
      <span class="sr-only">Toggle navigation</span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="/">It so life</a>
    </div>
    <div  class="collapse navbar-collapse">
      <ul  class="nav navbar-nav">
  
        <li><a href="/" title="Home">Home</a></li>      
        <li><a href="/about/" title="About">About</a></li>      
        <li><a href="/archives/" title="Archives">Archives</a></li>      
      <li class='dropdown'>
        <a class='dropdown-toggle' data-toggle='dropdown' href='#'>website<b class='caret'></b></a>
        <ul class='dropdown-menu pure-menu-selected'>
    
          <li><a href="//groups.google.com/forum/#!forum/pongba" title="TopLanguage">TopLanguage</a></li>    
          <li><a href="//itpub.net/" title="ITPub">ITPub</a></li>    
          <li><a href="//blog.jobbole.com/" title="Bole">Bole</a></li>    
          <li><a href="//nosql-database.org/" title="nosql">nosql</a></li>    
          <li><a href="//gitimmersion.googol.im/" title="Git">Git</a></li>    
        </ul>
      </li>
    
      </ul>
      <ul class="nav navbar-nav navbar-right">
      
        <li><a href="/atom.xml">RSS</a></li>
      
      
        <li><a href="https://twitter.com/robinchia">twitter</a></li>
      
      
      
      
        <li><a href="https://github.com/robinchia">github</a></li>
      
      </ul>
    </div>
  </div>
</nav>
<div class="clearfix"></div>
</header>
  <div id='content' class="container">
     <div class="page-header-wrapper">
      <!--[if lt IE 9]><div class="alert alert-warning alert-dismissable"><button type="button" class="close" data-dismiss="alert" aria-hidden="true">&times;</button><strong>提示:</strong>您的浏览器版本太低了,建议升级到 <strong><a href="http://windows.microsoft.com/zh-cn/internet-explorer/download-ie" title="IE9">IE9</a></strong> 以上,本站使用<a href="https://www.google.com/intl/zh-CN/chrome/">Chrome浏览器</a>可以获得最好的显示效果.</div><![endif]-->
      <div class="page-header"><h1 align="center"><big>It so life</big> </h1>
        <h5 align="center"><big>love as life</big></h5>
      </div>
     </div>
     <div class="row">
       <div id="main-col" class="alignleft col-sx-12 col-sm-8 col-md-9 col-lg-9">
      <section id='header_widget'></section>
          <div id="wrapper"><article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_常用--javaenum/">java enum</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:41.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_常用--javaenum/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="java-enum">java enum</h1>
<p>Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"></a></p>
<ol>
<li>public enum Operation {  </li>
<li></li>
<li>PLUS    { double eval(double x, double y) { return x + y; } },  </li>
<li></li>
<li>MINUS   { double eval(double x, double y) { return x - y; } },  </li>
<li></li>
<li>TIMES   { double eval(double x, double y) { return x /* y; } },  </li>
<li></li>
<li>DIVIDE { double eval(double x, double y) { return x / y; } };  </li>
<li></li>
<li></li>
<li>// Do arithmetic op represented by this constant  </li>
<li></li>
<li>abstract double eval(double x, double y);  </li>
<li></li>
<li>public static void main(String args[]) {  </li>
<li></li>
<li>double x = Double.parseDouble(&quot;3&quot;);  </li>
<li></li>
<li>double y = Double.parseDouble(&quot;2&quot;);  </li>
<li></li>
<li>for (Operation op : Operation.values())  </li>
<li></li>
<li>System.out.printf(&quot;%f %s %f = %f%n&quot;, x, op, y, op.eval(x, y));  </li>
<li></li>
<li>System.out.println(Operation.valueOf(&quot;PLUS&quot;).eval(x, y));  </li>
<li>}  </li>
<li></li>
<li>}  </li>
<li>public enum RandomStr {  </li>
<li>//<em>/</em> </li>
<li>/* 只有数字 </li>
<li>/*/  </li>
<li>Number(&quot;0123456789&quot;),  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* 包含数字和大小写字符 </li>
<li>/*/  </li>
<li>NumberAndChar(&quot;abcdefghjkmnpqrstuvwxyz23456789ABCDEFGHJKLMNPQRSTUVWXYZ&quot;),  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* 包含数字和大写字符 </li>
<li>/*/  </li>
<li>NumberAndCharIgnoreCase(&quot;ABCDEFGHJKLMNPQRSTUVWXYZ23456789&quot;),  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* 数字和字符平均出现 </li>
<li>/*/  </li>
<li>AvgNumberAndCharIgnoreCase(  </li>
<li>&quot;ABCDEFGHJKLMNPQRSTUVWXYZ234567892345678923456789&quot;);  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* 原始值 </li>
<li>/*/  </li>
<li>private String original;  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* 产生指定长度的随机码。 </li>
<li>/*/  </li>
<li>public String rand(int length) {  </li>
<li>String codes = &quot;&quot;;  </li>
<li>if (length &gt; 0) {  </li>
<li>int max = original.length();  </li>
<li>long seed = System.currentTimeMillis();  </li>
<li>Random random = new Random(seed);  </li>
<li>for (int i = 0; i &lt; length; i++) {  </li>
<li>codes += original.charAt(random.nextInt(max));  </li>
<li>}  </li>
<li>}  </li>
<li>return codes;  </li>
<li>}  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* 私有构造器。 </li>
<li>/*/  </li>
<li>private RandomStr(String original) {  </li>
<li>this.original = original;  </li>
<li>}  </li>
<li></li>
<li>}<br>注意：JDK4.0以前的都不支持，转成5.0以上才支持 
jdk5.0发布以后，添加了枚举类型，其实当初在从Delphi转向Java的时候，我就在为java中没有枚举这个功能感到不可思议。因为枚举类型在很多方面有着独特作用，现在好了，java中添加了这项功能，今天我就试了试，还满好的。 </li>
</ol>
<p>java中的枚举类型包括了其他语言中枚举类型的一般特性。 
class EnumDemo{ 
   public enum Seasons { 
    winter,spring,summer,fall; 
    } </p>
<pre><code>public static void main(String[] args){ 

   for(Seasons s:Seasons.values()) 
    System.out.println(s); 

    } 
</code></pre><p>} 
运行结果： 
winter 
spring 
summer 
fall 
上面这个例子，展示了枚举类型的一般用法，在java的枚举类中提供了静态values()方法以供循环迭代时使用。大家再看一看下面这个例子： 
public enum Seasons { 
winter, 
spring, 
summer, 
fall; 
//list the values 
public static void main(String[] args) { 
for(Seasons s:Seasons.values()) 
   { 
      System.out.println(s); 
   } 
} 
} 
这两个例子得出的是一样的结果。由此可知enum关键字是代表一个类相当于class的意思，但是它又比class的范围要小，仅仅代表枚举类而已。 
java中的枚举类除了有这些一般的功能外还包括一些特殊的功能，例如：枚举类型可以有构造函数、可以添加任意多的方法和属性；同时枚举类型还可以为不同的属性添加不同的方法。 
在这里我们假设你希望向一个枚举类中添加数据和行为。例如我们可以设想一下银河系的星球。每个星球的它自己的特定数据，由此来计算物体在其表面上的重量。下面就是实例： 
public enum Planet { 
     MERCURY (3.303e+23, 2.4397e6), //水星 
     VENUS    (4.869e+24, 6.0518e6), //金星 
     EARTH    (5.976e+24, 6.37814e6), //地球 
     MARS     (6.421e+23, 3.3972e6), //火星 
     JUPITER (1.9e+27,    7.1492e7), //木星 
     SATURN   (5.688e+26, 6.0268e7), //土星 
     URANUS   (8.686e+25, 2.5559e7), //天王星 
     NEPTUNE (1.024e+26, 2.4746e7),  //海王星 
     PLUTO    (1.27e+22,   1.137e6); //冥王星 
     private final double mass;    // in kilograms 
     private final double radius; // in meters 
     Planet(double mass, double radius) {   //枚举类不需要被实例化，所以构造器是私有的private,不加默认为私有类型 
         this.mass = mass; 
         this.radius = radius; 
     } 
     public double mass()    { return mass; } 
     public double radius() { return radius; } 
     // universal gravitational constant   (m 3 kg -1 s-2) 
     public static final double G = 6.67300E-11; 
     public double surfaceGravity() { 
         return G /<em> mass / (radius /</em> radius); 
     } 
     public double surfaceWeight(double otherMass) { 
         return otherMass /<em> surfaceGravity(); 
     } 
     public static void main(String[] args) { 
         double earthWeight = Double.parseDouble(args[0]); 
         double mass = earthWeight/EARTH.surfaceGravity(); 
         for (Planet p : Planet.values()) 
            System.out.printf(&quot;Your weight on %s is %f%n&quot;, 
                              p, p.surfaceWeight(mass)); 
     } 
} 
运行结果： 
C:\java&gt;java Planet 60 
Your weight on MERCURY is 22.665457 
Your weight on VENUS is 54.299946 
Your weight on EARTH is 60.000000 
Your weight on MARS is 22.724231 
Your weight on JUPITER is 151.833452 
Your weight on SATURN is 63.960932 
Your weight on URANUS is 54.307632 
Your weight on NEPTUNE is 68.299684 
Your weight on PLUTO is 4.012468 
在这里我们可以看到这个枚举类中含有一个带有两个参数的构造函数。通过构造函数我们可以产生含有不同数据特征的星球对象。Planet 的构造函数参数值从枚举常量里获取，如： 
当遍历到水星时 MERCURY (3.303e+23, 2.4397e6), //水星 
就会把里面的值3.303e+23传给mass, 而2.4397e6传给radius 
Planet(double mass, double radius) { 
         this.mass = mass; 
         this.radius = radius; 
     } 
在main()函数中，我们通过有不同的星球调用相同的方法来得到物体在该星球上的重量。 
我们可以把为枚举常量添加行为的主意更向前推进一步。我们可以为不同枚举常量添加不同的行为。通过使用switch语句是达到这个目的的一种方法。下面就有一个实例： 
public enum Operation { 
     PLUS, MINUS, TIMES, DIVIDE; 
     // Do arithmetic op represented by this constant 
     double eval(double x, double y){ 
         switch(this) { 
             case PLUS:    return x + y; 
             case MINUS:   return x - y; 
             case TIMES:   return x /</em> y; 
             case DIVIDE: return x / y; 
         } 
         throw new AssertionError(&quot;Unknown op: &quot; + this); 
     } 
} 
它工作的非常好，当时如果没有throw语句的话，它将不能通过编译，因此它就显得不是那么完美了。更加糟糕的是，你一定要记住在你向枚举类中添加枚举变量时，你要为这个变量添加操作。如果你忘了的话，eval方法将会操作失败。 
这里有另外一种给枚举常量添加行为的方法。使用这种方法你可以避免上面说提到的问题。你可以在枚举类型中添加一个abstract方法，然后在每一个枚举常量中重载它。这就是有名的constant-specific方法。下面就是用这种技术对以前实例的重写： 
public enum Operation { 
   PLUS    { double eval(double x, double y) { return x + y; } }, 
   MINUS   { double eval(double x, double y) { return x - y; } }, 
   TIMES   { double eval(double x, double y) { return x /<em> y; } }, 
   DIVIDE { double eval(double x, double y) { return x / y; } }; 
   // Do arithmetic op represented by this constant 
   abstract double eval(double x, double y); 
   public static void main(String args[]) { 
         double x = Double.parseDouble(args[0]); 
         double y = Double.parseDouble(args[1]); 
         for (Operation op : Operation.values()) 
             System.out.printf(&quot;%f %s %f = %f%n&quot;, x, op, y, op.eval(x, y)); 
     } 
} 
运行结果： 
C:\java&gt;java Operation 24 56 
24.000000 PLUS 56.000000 = 80.000000 
24.000000 MINUS 56.000000 = -32.000000 
24.000000 TIMES 56.000000 = 1344.000000 
24.000000 DIVIDE 56.000000 = 0.428571 
大家可能会不太明白“PLUS    { double eval(double x, double y) { return x + y; } }”的意思。其实如果大家理解内部类的话，可能就不难理解这句话的含义了。我的理解是: 
class MyenumOperation implements enumOperation 
{ 
     double eval(double x, double y) { return x + y; } 
} 
MyenumOperation plus = new MyenumOperation(); 
与枚举类型一起添加进来的还有enumset和enummap，我会在下一篇文章中介绍。 
Enum是enumeration(列举)的简写形式,包含在java.lang包中.熟悉C, C++, C 
/#, 或 Pascal人应该对列举有所了解,先看个例子: 
public enum Season { winter, spring, summer, fall } 
一个enum是定义一组值的对象,它可以包括零个或多个值成员.它是属于enum类型的,一个enum对象中不可有两个或多个相同的属性或值.在次之前的java程序员一般是 用接口的方法实现列举的,如 : 
public interface Season { 
    static winter = 0; 
    static spring = 1; //etc.. 
} 
引入了enum的java的列举的编写方便了许多,只须定义一个enum型的对象.enum对象的值都回自动获得一个数字值,从0开始,依次递增.看一个比较简单的enum实现的例子: 
EnumDemo.java 
package net.javagarage.enums; 
//</em> 
We can loop over the values we put into the enum 
using the values() method. 
Note that the enum Seasons is compiled into a 
separate unit, called EnumDemo$Seasons.class 
/<em>/ 
public class EnumDemo { 
       //</em>declare the enum and add values to it. note that, like in C/#, we don&#39;t use a ; to 
end this statement and we use commas to separate the values /<em>/ 
       private enum Seasons { winter, spring, 
        summer, fall } 
       //list the values 
       public static void main(String[] args) { 
             for (Seasons s : Seasons.values()){ 
                   System.out.println(s); 
             } 
       } 
} 
运行上述代码你回得到 以下结果: 
winter 
spring 
summer 
fall 
Enum的属性调用: 
下面的代码展示了调用enum对象的方法,这也是它通常的用法: 
package net.javagarage.enums; 
//</em> 
File: EnumSwitch.java 
Purpose: show how to switch against the values in an enum. 
/<em>/ 
public class EnumSwitch { 
       private enum Color { red, blue, green } 
       //list the values 
       public static void main(String[] args) { 
             //refer to the qualified value 
             doIt(Color.red); 
       } 
       //</em>note that you switch against the UNQUALIFIED name. that is, &quot;case Color.red:&quot; is a 
compiler error /<em>/ 
       private static void doIt(Color c){ 
       switch (c) { 
       case red: 
             System.out.println(&quot;value is &quot; + Color.red); 
             break; 
       case green: 
             System.out.println(&quot;value is &quot; + Color.green); 
             break; 
       case blue: 
             System.out.println(&quot;value is : &quot; + Color.blue); 
             break; 
       default : 
             System.out.println(&quot;default&quot;); 
       } 
       } 
} 
为enums添加属性和方法 
enums也可以象一般的类一样添加方法和属性,你可以为它添加静态和非静态的属性或方法,这一切都象你在一般的类中做的那样. 
package net.javagarage.enums; 
//</em> 
File: EnumDemo.java 
Purpose: show how to use an enum that also defines its own fields and methods 
/*/ 
public class EnumWithMethods { 
//declare the enum and add values to it. 
public enum Season { 
       winter, spring, summer, fall; 
       private final static String location = &quot;Phoenix&quot;; 
       public static Season getBest(){ 
             if (location.equals(&quot;Phoenix&quot;)) 
                   return winter; 
             else 
                   return summer; 
       } 
       public static void main(String[] args) { 
       System.out.println(Season.getBest()); 
       } 
} 
就是这么的简单.但是有一点是需要注意的,那就是enums的值列表必须紧跟在enum声明,不然编译时将会出错. 
Enums构造函数: 
和类一样enums也可以有自己的构造函数,如下: 
package net.javagarage.enums; 
public class EnumConstructor { 
       public static void main(String[] a) { 
             //call our enum using the values method 
             for (Temp t : Temp.values()) 
                   System.out.println(t + &quot; is : &quot; + t.getValue()); 
       } 
       //make the enum 
       public enum Temp { 
             absoluteZero(-459), freezing(32), 
             boiling(212), paperBurns(451); 
       //constructor here 
       Temp(int value) { 
             this.value = value; 
       } 
       //regular field?but make it final, 
       //since that is the point, to make constants 
       private final int value; 
       //regular get method 
       public int getValue() { 
       return value; 
       } 
       } 
} 
输出结果是: 
absoluteZero is : -459 
freezing is : 32 
boiling is : 212 
paperBurns is : 451 
尽管enums有这么多的属性,但并不是用的越多越好,如果那样还不如直接用类来的直接.enums的优势在定义int最终变量仅当这些值有一定特殊含义时.但是如果你需要的是一个类,就定义一个类,而不是enum.</p>
<p>来源： <a href="[http://xiewenbo.iteye.com/blog/1313676](http://xiewenbo.iteye.com/blog/1313676)">[http://xiewenbo.iteye.com/blog/1313676](http://xiewenbo.iteye.com/blog/1313676)</a></p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/Java_常用/">Java_常用</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/Java_常用/" class="label label-success">Java_常用</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:41"datetime="2014-03-07 09:54:41"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-Java_常用--javaenum/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-Java_常用--javaenum" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_常用--jsp-include与include的区别/">jsp</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:41.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_常用--jsp-include与include的区别/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="jsp-include-include-">jsp:include与include的区别</h1>
<p>（题外话：引入的文件如果是jsp则应定义为/<em>/</em>/<em>.jspf文件，如果其他文件可定义为/</em>/<em>/</em>.inc文件，即include file。而且&lt;%@ inlucde page=&quot;&quot; %&gt;除了可以引jspf还可以引servlet——很重要）
近日做一项目要用到JSP动态包含JSP，本想肯定很简单，但不想这么复杂，而且目前还没有求到好的答案，问题如下：
/#文件：one.jsp
1</p>
<p>2
3 &lt;%!</p>
<p>String var1=</p>
<p>&quot;China&quot;</p>
<p>;
%&gt;
/#文件 two.jsp
1</p>
<p>2
3</p>
<p>4
 &lt;%!</p>
<p>String var1=</p>
<p>&quot;America&quot;</p>
<p>;
String var2=</p>
<p>&quot;England&quot;</p>
<p>;</p>
<p>%&gt;
/#文件 three.jsp
1</p>
<p>2
3</p>
<p>4
5</p>
<p>6
7</p>
<p>8
9</p>
<p>10
11</p>
<p>12
 &lt;%</p>
<p>int j=1;
if</p>
<p>(j==1){</p>
<p>%&gt;
&lt;%@ include file=</p>
<p>&quot;one.jsp&quot;</p>
<p>%&gt;</p>
<p>&lt;%
}</p>
<p>else</p>
<p>{</p>
<p>%&gt;
&lt;%@ include file=</p>
<p>&quot;two.jsp&quot;</p>
<p>%&gt;</p>
<p>&lt;%}%&gt;
&lt;%=var1%&gt;</p>
<p>&lt;%=var2%&gt;
执行three.jsp会出什么结果？
a.编译错误
b.显示China England
很多人理所当然的觉得肯定是a,因为j=1所以只包含one.jsp,two.jsp不会包含进来，但答案是b,上机测试就知道。
为什么？
因为@include要先于jsp的其他代码执行，所以两个文件都会被包含进来！
－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－
如果你说用jsp:include可以解决问题，好，把three.jsp改成如下：
＃文件 three.jsp
1</p>
<p>2
3</p>
<p>4
5</p>
<p>6
7</p>
<p>8
9</p>
<p>10
11 &lt;%</p>
<p>int j=1;
String includeFile=</p>
<p>&quot;&quot;</p>
<p>;</p>
<p>if</p>
<p>(j==1){
includeFile =</p>
<p>&quot;one.jsp&quot;</p>
<p>;</p>
<p>}</p>
<p>else</p>
<p>{
includeFile =</p>
<p>&quot;two.jsp&quot;</p>
<p>;</p>
<p>}
%&gt;</p>
<p><jsp:include page=′<%=includeFile%>′ /&gt;
&lt;%=var1%&gt;
－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－
结果是什么？
a.编译错误
b.显示 China
是b吗，不，是a,编译错误！提示var1未定义。
为什么？因为jsp:include是动态包含，相当于把包含文件与被包含文件分开编译。
－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－
现把include的问题总结如下：
【引用 gfzhx(小小)的话】
    动态包含相当于作了一个页面跳转，也就是相当于重新访问了另一个servlet，所以当然会提示变量没有定义，你想一想，一个类中申明了一个变量，第二个类直接是用这个变量，你说可以吗？其实你的情况和这个例子很像，这就是动态包含，而静态包含你可以看一看jsp编译后的java文件就知道了，它是直接将你包含的页面直接包含进去，然后再编译的。所以你的问题采用静态包含就可以了。不过不管怎么，还是不推荐采用这种形式，会给程序造成很多问题，至少比较难以维护了，可以说是一种不好的编程风格。建议采用其他方法解决问题。
【引用 xiao_yuer(小鱼儿)的话】
要使用引入文件中定义的变量，只能用@include指令。
也就是&lt;%@ include file=&quot;one.jsp&quot; %&gt;,但这在一般情况下都不是动态的，是在jsp页面第一次编译时，把它导入的。而jsp编译后，这两个文件再作修改很多jsp服务器都不会侦测到，因为包含这两的jsp的jsp文件本身并没有发生变化。但很奇怪，weblogic6好像可以。你可以试试，不过不要抱太大希望，因为你这种要求不是很合理。向你这种情况，完全应该引入一个java类，这个类中定义一些变量（按你的说法都应该算是常量了，jsp取出来直接用而不会修改它再存回去），然后再jsp中得到那个类的实例，来进行处理。那样如果你要修改这些常量的值，就修改java类，而不用修改jsp.
【自己的:-))】
@include包含是静态包含，是把被包含文件加入到包含文件中然后进行编译，所以这种包含与解释执行的语言很象（例如php)，而且JSP中@开头的语句都要先于其他语句执行，所以如上，用if.else来判断然后包含是不行的，所以以前如果是做PHP这种解释语言的人会觉得不适应。
jsp:include是既可以静态包含又可以动态包含，与@include不同的是，jsp:include没有@include那样的优先权，即不是现于其他语句执行的，所以jsp:include可以又选择性的包含。不过更重要的一点是，用jsp:include相当于编译两个不同的文件，所以如果被包含文件中仅仅是显示某些东西（例如被包含文件是纯HTML）的话，这种情况下，用jsp:include和@include来包含文件的效果是一样的，但如果要用jsp:include来显示被包含文件中定义的变量就不行了（为什么？见上面的引用吧，就不赘述了）。
【感谢】
gfzhx(小小)、xiao_yuer(小鱼儿)
来源： <a href="[http://www.wudongqi.com/article/529.htm](http://www.wudongqi.com/article/529.htm)">[http://www.wudongqi.com/article/529.htm](http://www.wudongqi.com/article/529.htm)</a> </p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/Java_常用/">Java_常用</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/Java_常用/" class="label label-success">Java_常用</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:41"datetime="2014-03-07 09:54:41"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-Java_常用--jsp-include与include的区别/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-Java_常用--jsp-include与include的区别" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_常用--switch之enum/">switch之enum</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:41.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_常用--switch之enum/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="switch-enum">switch之enum</h1>
<h3 id="-switch-enum-http-blog-csdn-net-wzju64676266-article-details-6140871-"><a href="http://blog.csdn.net/wzju64676266/article/details/6140871" target="_blank">switch之enum</a></h3>
<p>2011-01-14 23:46 
<a href="http://blog.csdn.net/tag/details.html?tag=spring" target="_blank">spring</a><a href="http://blog.csdn.net/tag/details.html?tag=table" target="_blank">table</a><a href="http://blog.csdn.net/tag/details.html?tag=class" target="_blank">class</a><a href="http://blog.csdn.net/tag/details.html?tag=string" target="_blank">string</a><a href="http://blog.csdn.net/tag/details.html?tag=%e7%bc%96%e8%af%91%e5%99%a8" target="_blank">编译器</a><a href="http://blog.csdn.net/tag/details.html?tag=byte" target="_blank">byte</a></p>
<p>记得曾经去一家公司面试，那时啥也不懂，面试我的那个人好像呆过IBM，数据结构、编译原理这些都很NB。</p>
<p>问答环节</p>
<p>他：java switch中能支持什么类型？</p>
<p>我：byte short char int ，jdk1.5出来了enum，同样也支持enum</p>
<p>他：为什么能支持byte short char int   而long不行？</p>
<p>我：这个可能是设计问题</p>
<p>他：其实jvm执行class文件的时候，byte short char int这些都是当int类型来执行的，long不能直接转换成int，编译阶段就通不过了。</p>
<p>我：我那个时候不太理解他说的那个意思，只能点点头</p>
<p>他：好，那接着讨论switch为什么支持enum，刚才也讨论过switch其实都是int类型，也只支持int，那enum不是int类型，是个对象，那为什么支持呢！</p>
<p>我：那个时候我就蒙了（心里想着，你这家伙，就胡扯），但我讲不出理由，就直接说不知道</p>
<p>他：其实在switch中enum也是int类型</p>
<p>我：心想----我不知道你说的是对还是错，你怎么说都行</p>
<p>自从那以后，哥去研究虚拟机，java指令</p>
<p> <strong>好，废话不多说了，现在来看一下代码，代码比较简单！</strong></p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/wzju64676266/article/details/6140871#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/wzju64676266/article/details/6140871#" title="copy" target="_blank">copy</a></p>
<ol>
<li>//<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/* </li>
<li>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/* </li>
<li>源代码 </li>
<li>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/* </li>
<li>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/*/  </li>
<li>public static void testSwitchInt() {  </li>
<li>int intElement = 3;  </li>
<li>switch (intElement) {  </li>
<li>case 3:  </li>
<li>System.out.println(&quot;3&quot;);  </li>
<li>break;  </li>
<li>default:  </li>
<li>System.out.println(&quot;int DEFAULT&quot;);  </li>
<li>break;  </li>
<li>}  </li>
<li>}  </li>
<li>//int 类型反编译跟源代码是一样的  </li>
<li></li>
<li>//<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/* </li>
<li>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/* </li>
<li>用javap工具看class指令 </li>
<li>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/* </li>
<li>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/*/  </li>
<li>//case 的值本来就是int，这没什么好说的  </li>
<li>public static void testSwitchInt();  </li>
<li>Code:  </li>
<li>Stack=2, Locals=1, Args_size=0  </li>
<li>0:   iconst_3      //解释：加载int常量3  </li>
<li>1:   istore_0     //解释：保存int类型到局部变量表index为0的位置（其实保存的就是3）  </li>
<li>2:   iload_0      //加载局部变量表index为0的位置的int变量，用于switch里面  </li>
<li>3:   lookupswitch{ //1  </li>
<li>3: 20;  </li>
<li>default: 31 }  </li>
<li>20:  getstatic       /#9; //Field java/lang/System.out:Ljava/io/PrintStream;  </li>
<li>23:  ldc     /#13; //String 3  </li>
<li>25:  invokevirtual   /#11; //Method java/io/PrintStream.println:(Ljava/lang/St  </li>
<li>ring;)V  </li>
<li>28:  goto    39  </li>
<li>31:  getstatic       /#9; //Field java/lang/System.out:Ljava/io/PrintStream;  </li>
<li>34:  ldc     /#14; //String int DEFAULT  </li>
<li>36:  invokevirtual   /#11; //Method java/io/PrintStream.println:(Ljava/lang/St  </li>
<li>ring;)V  </li>
<li>39:  return  </li>
<li></li>
<li><hr>
</li>
<li><hr>
</li>
<li></li>
<li></li>
<li>//<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/* </li>
<li>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/* </li>
<li>源代码 </li>
<li>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/* </li>
<li>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/*/  </li>
<li>public static void testSwitchChar() {  </li>
<li>int charElement = &#39;a&#39;;   //ascii对应的是97，编译器直接把这个值编译成97，case里面也是这样的  </li>
<li>switch (charElement) {  </li>
<li>case &#39;a&#39;:  </li>
<li>System.out.println(&quot;a&quot;);  </li>
<li>break;  </li>
<li>default:  </li>
<li>System.out.println(&quot;char DEFAULT&quot;);  </li>
<li>break;  </li>
<li>}  </li>
<li>}  </li>
<li>//<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/* </li>
<li>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/* </li>
<li>编译后的代码 </li>
<li>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/* </li>
<li>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/*/  </li>
<li>public static void testSwitchChar()  </li>
<li>{  </li>
<li>int charElement = 97;     </li>
<li>switch(charElement)  </li>
<li>{  </li>
<li>case 97: // &#39;a&#39;  </li>
<li>System.out.println(&quot;a&quot;);  </li>
<li>break;  </li>
<li>default:  </li>
<li>System.out.println(&quot;char DEFAULT&quot;);  </li>
<li>break;  </li>
<li>}  </li>
<li>}  </li>
<li>//<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/* </li>
<li>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/* </li>
<li>用javap工具看class指令 </li>
<li>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/* </li>
<li>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/*/  </li>
<li>//case 的值本来就是char类型，但被编译器处理成int   </li>
<li>public static void testSwitchChar();  </li>
<li>Code:  </li>
<li>Stack=2, Locals=1, Args_size=0  </li>
<li>0:   bipush  97   //解释：加载int常量97,a的ascii码  </li>
<li>2:   istore_0    //接下来和上面都一样的  </li>
<li>3:   iload_0      </li>
<li>4:   tableswitch{ //97 to 97  </li>
<li>97: 24;  </li>
<li>default: 35 }  </li>
<li>24:  getstatic       /#46; //Field java/lang/System.out:Ljava/io/PrintStream;  </li>
<li>27:  ldc     /#68; //String a  </li>
<li>29:  invokevirtual   /#53; //Method java/io/PrintStream.println:(Ljava/lang/St  </li>
<li>ring;)V  </li>
<li>32:  goto    43  </li>
<li>35:  getstatic       /#46; //Field java/lang/System.out:Ljava/io/PrintStream;  </li>
<li>38:  ldc     /#70; //String char DEFAULT  </li>
<li>40:  invokevirtual   /#53; //Method java/io/PrintStream.println:(Ljava/lang/St  </li>
<li>ring;)V  </li>
<li>43:  return  </li>
<li>byte  short  也是同理，都会编译成int  </li>
<li></li>
<li><hr>
</li>
<li><hr>
</li>
<li>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>上面的例子都比较好理解，enum大家可能也会有点疑惑/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>  </li>
<li></li>
<li>//<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/* </li>
<li>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/* </li>
<li>源代码 </li>
<li>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/* </li>
<li>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/*/  </li>
<li>enum EnumTest {  </li>
<li>WINTER, SUMMER, SPRING, AUTUMN;  </li>
<li>}  </li>
<li>public static void testSwitchEnum() {  </li>
<li>EnumTest enumElement = EnumTest.AUTUMN;  </li>
<li>switch (enumElement) {  </li>
<li>case AUTUMN:  </li>
<li>System.out.println(&quot;AUTUMN&quot;);  </li>
<li>break;  </li>
<li>default:  </li>
<li>System.out.println(&quot;enum DEFAULT&quot;);  </li>
<li>break;  </li>
<li>}  </li>
<li>}  </li>
<li>//<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/* </li>
<li>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/* </li>
<li>enum类编译后的代码 </li>
<li>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/* </li>
<li>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/*/  </li>
<li>//enum其实也就是个普通的类，继承Enum  </li>
<li>public final class EnumTest extends Enum  </li>
<li>{  </li>
<li>private EnumTest(String s, int i)  </li>
<li>{  </li>
<li>super(s, i);      </li>
<li></li>
<li>//*调用父类的构造函数 </li>
<li>protected Enum(String name, int ordinal) { </li>
<li>this.name = name;    //名称 </li>
<li>this.ordinal = ordinal;   元素位置 </li>
<li>} </li>
<li>/*/  </li>
<li>}  </li>
<li>public static EnumTest[] values()  </li>
<li>{  </li>
<li>EnumTest aenumtest[];  </li>
<li>int i;  </li>
<li>EnumTest aenumtest1[];  </li>
<li>System.arraycopy(aenumtest = ENUM$VALUES, 0, aenumtest1 = new EnumTest[i = aenumtest.length], 0, i);  </li>
<li>return aenumtest1;  </li>
<li>}  </li>
<li>public static EnumTest valueOf(String s)  </li>
<li>{  </li>
<li>return (EnumTest)Enum.valueOf(meiju/EnumTest, s);  </li>
<li>}  </li>
<li>public static final EnumTest WINTER;  </li>
<li>public static final EnumTest SUMMER;  </li>
<li>public static final EnumTest SPRING;  </li>
<li>public static final EnumTest AUTUMN;  </li>
<li>private static final EnumTest ENUM$VALUES[];  </li>
<li>static   </li>
<li>{  </li>
<li>//enum的位置的排好的，想数组一样，enum元素最终都保存在ENUM$VALUES数组  </li>
<li>WINTER = new EnumTest(&quot;WINTER&quot;, 0);    </li>
<li>SUMMER = new EnumTest(&quot;SUMMER&quot;, 1);  </li>
<li>SPRING = new EnumTest(&quot;SPRING&quot;, 2);  </li>
<li>AUTUMN = new EnumTest(&quot;AUTUMN&quot;, 3);  </li>
<li>ENUM$VALUES = (new EnumTest[] {  </li>
<li>WINTER, SUMMER, SPRING, AUTUMN  </li>
<li>});  </li>
<li>}  </li>
<li>}  </li>
<li>//<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/* </li>
<li>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/* </li>
<li>testSwitchEnum方法编译后的代码 </li>
<li>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/* </li>
<li>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/*/  </li>
<li>用到enum元素，所以会在当前类中多生成一个$SWITCH_TABLE$meiju$EnumTest()方法和$SWITCH_TABLE$meiju$EnumTest[]变量，用于switch  </li>
<li>static int[] $SWITCH_TABLE$meiju$EnumTest()  </li>
<li>{  </li>
<li>$SWITCH_TABLE$meiju$EnumTest;  </li>
<li>if($SWITCH_TABLE$meiju$EnumTest == null) goto _L2; else goto _L1  </li>
<li>_L1:  </li>
<li>return;  </li>
<li>_L2:  </li>
<li>JVM INSTR pop ;  </li>
<li>int ai[] = new int[EnumTest.values().length];  </li>
<li>try  </li>
<li>{  </li>
<li>ai[EnumTest.AUTUMN.ordinal()] = 4;  </li>
<li>}  </li>
<li>catch(NoSuchFieldError _ex) { }  </li>
<li>try  </li>
<li>{  </li>
<li>ai[EnumTest.SPRING.ordinal()] = 3;  </li>
<li>}  </li>
<li>catch(NoSuchFieldError _ex) { }  </li>
<li>try  </li>
<li>{  </li>
<li>ai[EnumTest.SUMMER.ordinal()] = 2;  </li>
<li>}  </li>
<li>catch(NoSuchFieldError _ex) { }  </li>
<li>try  </li>
<li>{  </li>
<li>ai[EnumTest.WINTER.ordinal()] = 1;  </li>
<li>}  </li>
<li>catch(NoSuchFieldError _ex) { }  </li>
<li>return $SWITCH_TABLE$meiju$EnumTest = ai;  </li>
<li>}  </li>
<li>private static int $SWITCH_TABLE$meiju$EnumTest[];//保存的是enum的index  </li>
<li></li>
<li>public static void testSwitchEnum()  </li>
<li>{  </li>
<li>EnumTest enumElement = EnumTest.AUTUMN;  </li>
<li>//这个就是上面所用到的变量  </li>
<li>switch($SWITCH_TABLE$meiju$EnumTest()[enumElement.ordinal()])  </li>
<li>{  </li>
<li>case 4: // &#39;/004&#39;     因为enum类的元素其实就是个常量，在编译阶段就能确定值，在源代码的case AUTUMN:   其实也就被他所在的ordinal()给替换掉了，其实就是索引  </li>
<li>System.out.println(&quot;AUTUMN&quot;);  </li>
<li>break;  </li>
<li>default:  </li>
<li>System.out.println(&quot;enum DEFAULT&quot;);  </li>
<li>break;  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>//<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/* </li>
<li>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/* </li>
<li>用javap工具看class指令 </li>
<li>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/* </li>
<li>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/*/  </li>
<li>public static void testSwitchEnum();  </li>
<li>Code:  </li>
<li>Stack=2, Locals=1, Args_size=0  </li>
<li>0:   getstatic       /#6; //Field meiju/EnumTest.AUTUMN:Lmeiju/EnumTest;  </li>
<li>3:   astore_0  </li>
<li>4:   getstatic       /#7; //Field meiju/SwitchEnum$1.$SwitchMap$meiju$EnumTest  </li>
<li>:[I  </li>
<li>7:   aload_0  </li>
<li>8:   invokevirtual   /#8; //Method meiju/EnumTest.ordinal:()I  </li>
<li>11:  iaload  </li>
<li>12:  lookupswitch{ //1  </li>
<li>1: 32;  </li>
<li>default: 43 }  </li>
<li>32:  getstatic       /#9; //Field java/lang/System.out:Ljava/io/PrintStream;  </li>
<li>35:  ldc     /#10; //String AUTUMN  </li>
<li>37:  invokevirtual   /#11; //Method java/io/PrintStream.println:(Ljava/lang/St  </li>
<li>ring;)V  </li>
<li>40:  goto    51  </li>
<li>43:  getstatic       /#9; //Field java/lang/System.out:Ljava/io/PrintStream;  </li>
<li>46:  ldc     /#12; //String enum DEFAULT  </li>
<li>48:  invokevirtual   /#11; //Method java/io/PrintStream.println:(Ljava/lang/St  </li>
<li>ring;)V  </li>
<li>51:  return  </li>
</ol>
<p>事实证明当时他不是忽悠我，确实是这样的:)</p>
<p>来源： <a href="[http://blog.csdn.net/wzju64676266/article/details/6140871](http://blog.csdn.net/wzju64676266/article/details/6140871)">[http://blog.csdn.net/wzju64676266/article/details/6140871](http://blog.csdn.net/wzju64676266/article/details/6140871)</a> </p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/Java_常用/">Java_常用</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/Java_常用/" class="label label-success">Java_常用</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:41"datetime="2014-03-07 09:54:41"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-Java_常用--switch之enum/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-Java_常用--switch之enum" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-NIO--JAVANIO总结/">JAVA NIO总结</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:41.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-NIO--JAVANIO总结/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="java-nio-">JAVA NIO总结</h1>
<p>（一）—基本概念</p>
<h2 id="1-">1、输入/输出：概念性描述</h2>
<h3 id="-1-1-i-o-"><a href=""></a>1.1） I/O简介</h3>
<p>I/O  或者输入/输出指的是计算机与外部世界或者一个程序与计算机的其余部分的之间的接口。它对于任何计算机系统都非常关键，因而所有 I/O 的主体实际上是内置在操作系统中的。单独的程序一般是让系统为它们完成大部分的工作。</p>
<p>在 Java 编程中，直到最近一直使用<strong>流</strong>的方式完成 I/O。所有 I/O 都被视为单个的字节的移动，通过一个称为 Stream 的对象一次移动一个字节。流 I/O 用于与外部世界接触。它也在内部使用，用于将对象转换为字节，然后再转换回对象。NIO 与原来的 I/O 有同样的作用和目的，但是它使用不同的方式? <strong>块 I/O</strong>。正如您将在本教程中学到的，块 I/O 的效率可以比流 I/O 高许多。</p>
<h3 id="-1-2-nio-"><a href=""></a>1.2）为什么要使用NIO？</h3>
<p>NIO 的创建目的是为了让 Java 程序员可以实现高速 I/O 而无需编写自定义的本机代码。NIO 将最耗时的 I/O 操作(即填充和提取缓冲区)转移回操作系统，因而可以极大地提高速度。</p>
<h3 id="-1-3-"><a href=""></a>1.3）流与块的比较</h3>
<p>原来的 I/O 库(在 </p>
<p>java.io./*
中) 与 NIO 最重要的区别是数据打包和传输的方式。正如前面提到的，原来的 I/O 以流的方式处理数据，而 NIO 以块的方式处理数据。</p>
<p><strong>面向流*</strong> *的 I/O 系统一次一个字节地处理数据。一个输入流产生一个字节的数据，一个输出流消费一个字节的数据。为流式数据创建过滤器非常容易。链接几个过滤器，以便每个过滤器只负责单个复杂处理机制的一部分，这样也是相对简单的。不利的一面是，面向流的 I/O 通常相当慢。</p>
<p>一个 <strong>面向块*</strong> *的 I/O 系统以块的形式处理数据。每一个操作都在一步中产生或者消费一个数据块。按块处理数据比按(流式的)字节处理数据要快得多。但是面向块的 I/O 缺少一些面向流的 I/O 所具有的优雅性和简单性。</p>
<h3 id="-1-4-io"><a href=""></a>1.4）集成的IO</h3>
<p>在 JDK 1.4 中原来的 I/O 包和 NIO 已经很好地集成了。 </p>
<p>java.io./*
 已经以 NIO 为基础重新实现了，所以现在它可以利用 NIO 的一些特性。例如， </p>
<p>java.io./*
 包中的一些类包含以块的形式读写数据的方法，这使得即使在更面向流的系统中，处理速度也会更快。</p>
<p>也可以用 NIO 库实现标准 I/O 功能。例如，可以容易地使用块 I/O 一次一个字节地移动数据。但是正如您会看到的，NIO 还提供了原 I/O 包中所没有的许多好处。</p>
<h2 id="-2-"><a href=""></a>2、通道和缓冲区</h2>
<h3 id="-2-1-"><a href=""></a>2.1）概述</h3>
<p>通道 
和 </p>
<p>缓冲区 
是 NIO 中的核心对象，几乎在每一个 I/O 操作中都要使用它们。</p>
<p>通道是对原 I/O 包中的流的模拟。到任何目的地(或来自任何地方)的所有数据都必须通过一个 Channel 对象。一个 Buffer 实质上是一个容器对象。发送给一个通道的所有对象都必须首先放到缓冲区中；同样地，从通道中读取的任何数据都要读到缓冲区中。</p>
<p>在本节中，您会了解到 NIO 中通道和缓冲区是如何工作的。</p>
<h3 id="-2-2-"><a href=""></a>2.2）什么是缓冲区</h3>
<p>Buffer
 是一个对象， 它包含一些要写入或者刚读出的数据。 在 NIO 中加入 </p>
<p>Buffer
 对象，体现了新库与原 I/O 的一个重要区别。在面向流的 I/O 中，您将数据直接写入或者将数据直接读到 </p>
<p>Stream
 对象中。</p>
<p>在 NIO 库中，所有数据都是用缓冲区处理的。在读取数据时，它是直接读到缓冲区中的。在写入数据时，它是写入到缓冲区中的。任何时候访问 NIO 中的数据，您都是将它放到缓冲区中。</p>
<p>缓冲区实质上是一个数组。通常它是一个字节数组，但是也可以使用其他种类的数组。但是一个缓冲区不 <em>仅仅 </em>是一个数组。缓冲区提供了对数据的结构化访问，而且还可以跟踪系统的读/写进程。</p>
<h3 id="-2-3-"><a href=""></a>2.3）缓冲区类型</h3>
<p>最常用的缓冲区类型是 </p>
<p>ByteBuffer
。一个 </p>
<p>ByteBuffer
 可以在其底层字节数组上进行 get/set 操作(即字节的获取和设置)。</p>
<p>ByteBuffer
 不是 NIO 中唯一的缓冲区类型。事实上，对于每一种基本 Java 类型都有一种缓冲区类型：</p>
<ul>
<li>ByteBuffer</li>
<li>CharBuffer</li>
<li>ShortBuffer</li>
<li>IntBuffer</li>
<li>LongBuffer</li>
<li>FloatBuffer</li>
<li>DoubleBuffer</li>
</ul>
<p>每一个 </p>
<p>Buffer
 类都是 </p>
<p>Buffer
 接口的一个实例。 除了 </p>
<p>ByteBuffer
，每一个 Buffer 类都有完全一样的操作，只是它们所处理的数据类型不一样。因为大多数标准 I/O 操作都使用 </p>
<p>ByteBuffer
，所以它具有所有共享的缓冲区操作以及一些特有的操作。</p>
<p>现在您可以花一点时间运行 UseFloatBuffer.java，它包含了类型化的缓冲区的一个应用例子。</p>
<h3 id="-2-4-"><a href=""></a>2.4）什么是通道</h3>
<p>Channel
是一个对象，可以通过它读取和写入数据。拿 NIO 与原来的 I/O 做个比较，通道就像是流。</p>
<p>正如前面提到的，所有数据都通过 </p>
<p>Buffer
 对象来处理。您永远不会将字节直接写入通道中，相反，您是将数据写入包含一个或者多个字节的缓冲区。同样，您不会直接从通道中读取字节，而是将数据从通道读入缓冲区，再从缓冲区获取这个字节。</p>
<h3 id="-2-5-"><a href=""></a>2.5）通道类型</h3>
<p>通道与流的不同之处在于通道是双向的。而流只是在一个方向上移动(一个流必须是 </p>
<p>InputStream
 或者 </p>
<p>OutputStream
 的子类)， 而 </p>
<p>通道 
可以用于读、写或者同时用于读写。因为它们是双向的，所以通道可以比流更好地反映底层操作系统的真实情况。特别是在 UNIX 模型中，底层操作系统通道是双向的。</p>
<h2 id="-3-nio-"><a href=""></a>3、从理论到实践：NIO的读和写</h2>
<h3 id="-3-1-"><a href=""></a>3.1）概述</h3>
<p>读和写是 I/O 的基本过程。从一个通道中读取很简单：只需创建一个缓冲区，然后让通道将数据读到这个缓冲区中。写入也相当简单：创建一个缓冲区，用数据填充它，然后让通道用这些数据来执行写入操作。</p>
<p>在本节中，我们将学习有关在 Java 程序中读取和写入数据的一些知识。我们将回顾 NIO 的主要组件(缓冲区、通道和一些相关的方法)，看看它们是如何交互以进行读写的。在接下来的几节中，我们将更详细地分析这其中的每个组件以及其交互。<strong>所有例子代码下载请点击<a href="http://www.ibm.com/developerworks/cn/education/java/j-nio/nio-src.zip" target="_blank">例子代码</a>。</strong></p>
<h3 id="-3-2-"><a href=""></a>3.2）从文件中读取</h3>
<p>在我们第一个练习中，我们将从一个文件中读取一些数据。如果使用原来的 I/O，那么我们只需创建一个 </p>
<p>FileInputStream
 并从它那里读取。而在 NIO 中，情况稍有不同：我们首先从 </p>
<p>FileInputStream
 获取一个 </p>
<p>FileInputStream
 对象，然后使用这个通道来读取数据。</p>
<p>在 NIO 系统中，任何时候执行一个读操作，您都是从通道中读取，但是您<strong>不是直接*</strong> *从通道读取。因为所有数据最终都驻留在缓冲区中，所以您是从通道读到缓冲区中。</p>
<p>因此读取文件涉及三个步骤：(1) 从 </p>
<p>FileInputStream
 获取 </p>
<p>Channel
，(2) 创建 </p>
<p>Buffer
，(3) 将数据从 </p>
<p>Channel
 读到 </p>
<p>Buffer 
中。现在，让我们看一下这个过程。</p>
<h3 id="-3-3-"><a href=""></a>3.3）三个容易的步骤</h3>
<p>第一步是获取通道。我们从 </p>
<p>FileInputStream
 获取通道：
FileInputStream fin = new FileInputStream( &quot;readandshow.txt&quot; );</p>
<p>FileChannel fc = fin.getChannel();</p>
<p>下一步是创建缓冲区：
ByteBuffer buffer = ByteBuffer.allocate( 1024 );</p>
<p>最后，需要将数据从通道读到缓冲区中，如下所示：
fc.read( buffer );</p>
<p>您会注意到，我们不需要告诉通道要读 <em>多少数据 </em>到缓冲区中。每一个缓冲区都有复杂的内部统计机制，它会跟踪已经读了多少数据以及还有多少空间可以容纳更多的数据。我们将在 <strong>缓冲区内部细节</strong> 中介绍更多关于缓冲区统计机制的内容。</p>
<h3 id="-3-4-"><a href=""></a>3.4）写入文件</h3>
<p>在 NIO 中写入文件类似于从文件中读取。首先从 </p>
<p>FileOutputStream
 获取一个通道：
FileOutputStream fout = new FileOutputStream( &quot;writesomebytes.txt&quot; );</p>
<p>FileChannel fc = fout.getChannel();</p>
<p>下一步是创建一个缓冲区并在其中放入一些数据 - 在这里，数据将从一个名为 </p>
<p>message
 的数组中取出，这个数组包含字符串 &quot;Some bytes&quot; 的 ASCII 字节(本教程后面将会解释 </p>
<p>buffer.flip()
 和 </p>
<p>buffer.put()
 调用)。
ByteBuffer buffer = ByteBuffer.allocate( 1024 );</p>
<p>for (int i=0; i&lt;message.length; ++i) {</p>
<pre><code> buffer.put( message[i] );
</code></pre><p>}</p>
<p>buffer.flip();</p>
<p>最后一步是写入通道中：
fc.write( buffer );</p>
<p>注意在这里同样不需要告诉通道要写入多数据。缓冲区的内部统计机制会跟踪它包含多少数据以及还有多少数据要写入。</p>
<h3 id="-3-5-"><a href=""></a>3.5）读写结合</h3>
<p>下面我们将看一下在结合读和写时会有什么情况。我们以一个名为 CopyFile.java 的简单程序作为这个练习的基础，它将一个文件的所有内容拷贝到另一个文件中。CopyFile.java 执行三个基本操作：首先创建一个 </p>
<p>Buffer
，然后从源文件中将数据读到这个缓冲区中，然后将缓冲区写入目标文件。这个程序不断重复 ― 读、写、读、写 ― 直到源文件结束。</p>
<p>CopyFile 程序让您看到我们如何检查操作的状态，以及如何使用 </p>
<p>clear()
 和 </p>
<p>flip()
 方法重设缓冲区，并准备缓冲区以便将新读取的数据写到另一个通道中。</p>
<h3 id="-copyfile-"><a href=""></a>运行CopyFile例子</h3>
<p>因为缓冲区会跟踪它自己的数据，所以 CopyFile 程序的内部循环 (inner loop) 非常简单，如下所示：
fcin.read( buffer );</p>
<p>fcout.write( buffer );</p>
<p>第一行将数据从输入通道 </p>
<p>fcin
 中读入缓冲区，第二行将这些数据写到输出通道 </p>
<p>fcout
 。</p>
<h3 id="-"><a href=""></a>检查状态</h3>
<p>下一步是检查拷贝何时完成。当没有更多的数据时，拷贝就算完成，并且可以在 </p>
<p>read()
 方法返回 -1 是判断这一点，如下所示：
int r = fcin.read( buffer );</p>
<p>if (r==-1) {</p>
<pre><code> break;
</code></pre><p>}</p>
<h3 id="-"><a href=""></a>重设缓冲区</h3>
<p>最后，在从输入通道读入缓冲区之前，我们调用 </p>
<p>clear()
 方法。同样，在将缓冲区写入输出通道之前，我们调用 </p>
<p>flip()
 方法，如下所示：</p>
<p>buffer.clear();</p>
<p>int r = fcin.read( buffer );</p>
<p>if (r==-1) {
     break;</p>
<p>}</p>
<p>buffer.flip();
fcout.write( buffer );</p>
<p>clear()
 方法重设缓冲区，使它可以接受读入的数据。 </p>
<p>flip()
 方法让缓冲区可以将新读入的数据写入另一个通道。</p>
<p>来源： <a href="[http://blog.csdn.net/ssjhust123/article/details/7904757](http://blog.csdn.net/ssjhust123/article/details/7904757)">[http://blog.csdn.net/ssjhust123/article/details/7904757](http://blog.csdn.net/ssjhust123/article/details/7904757)</a> </p>
<p><a href="http://blog.csdn.net/ssjhust123/article/details/7905278" target="_blank">（二）—缓冲区原理</a></p>
<h2 id="4-">4、缓冲区的内部细节</h2>
<h3 id="-"><a href=""></a><strong>概述</strong></h3>
<p>本节将介绍 NIO 中两个重要的缓冲区组件：状态变量和访问方法 (accessor)。</p>
<p>状态变量是前一节中提到的&quot;内部统计机制&quot;的关键。每一个读/写操作都会改变缓冲区的状态。通过记录和跟踪这些变化，缓冲区就可能够内部地管理自己的资源。</p>
<p>在从通道读取数据时，数据被放入到缓冲区。在有些情况下，可以将这个缓冲区直接写入另一个通道，但是在一般情况下，您还需要查看数据。这是使用 <em>访问方法 </em></p>
<p>get()
 来完成的。同样，如果要将原始数据放入缓冲区中，就要使用访问方法 </p>
<p>put()
。</p>
<p>在本节中，您将学习关于 NIO 中的状态变量和访问方法的内容。我们将描述每一个组件，并让您有机会看到它的实际应用。虽然 NIO 的内部统计机制初看起来可能很复杂，但是您很快就会看到大部分的实际工作都已经替您完成了。您可能习惯于通过手工编码进行簿记 ― 即使用字节数组和索引变量，现在它已在 NIO 中内部地处理了。</p>
<h3 id="-"><a href=""></a>状态变量</h3>
<p>可以用三个值指定缓冲区在任意时刻的状态：</p>
<ul>
<li>position</li>
<li>limit</li>
<li>capacity</li>
</ul>
<p>这三个变量一起可以跟踪缓冲区的状态和它所包含的数据。我们将在下面的小节中详细分析每一个变量，还要介绍它们如何适应典型的读/写(输入/输出)进程。在这个例子中，我们假定要将数据从一个输入通道拷贝到一个输出通道。</p>
<h3 id="-position"><a href=""></a>position</h3>
<p>您可以回想一下，缓冲区实际上就是美化了的数组。在从通道读取时，您将所读取的数据放到底层的数组中。 </p>
<p>position
 变量跟踪已经写了多少数据。更准确地说，它指定了下一个字节将放到数组的哪一个元素中。因此，如果您从通道中读三个字节到缓冲区中，那么缓冲区的 </p>
<p>position
 将会设置为3，指向数组中第四个元素。</p>
<p>同样，在写入通道时，您是从缓冲区中获取数据。 </p>
<p>position
 值跟踪从缓冲区中获取了多少数据。更准确地说，它指定下一个字节来自数组的哪一个元素。因此如果从缓冲区写了5个字节到通道中，那么缓冲区的 </p>
<p>position
 将被设置为5，指向数组的第六个元素。</p>
<h3 id="-"><a href=""></a></h3>
<p>limit</p>
<p>limit
 变量表明还有多少数据需要取出(在从缓冲区写入通道时)，或者还有多少空间可以放入数据(在从通道读入缓冲区时)。</p>
<p>position
 总是小于或者等于 </p>
<p>limit
。</p>
<h3 id="-capacity-"><a href=""></a><strong>capacity</strong></h3>
<p>缓冲区的 </p>
<p>capacity
 表明可以储存在缓冲区中的最大数据容量。实际上，它指定了底层数组的大小 ― 或者至少是指定了准许我们使用的底层数组的容量。</p>
<p>limit
 决不能大于 </p>
<p>capacity
。</p>
<h3 id="-"><a href=""></a><strong>观察变量</strong></h3>
<p>我们首先观察一个新创建的缓冲区。出于本例子的需要，我们假设这个缓冲区的 </p>
<p>总容量 
为8个字节。 </p>
<p>Buffer
 的状态如下所示：
<img src="" alt="Buffer state"> </p>
<p>回想一下 ，</p>
<p>limit
 决不能大于 </p>
<p>capacity
，此例中这两个值都被设置为 8。我们通过将它们指向数组的尾部之后(如果有第8个槽，则是第8个槽所在的位置)来说明这点。
<img src="" alt="Array"> </p>
<p>position
 设置为0。如果我们读一些数据到缓冲区中，那么下一个读取的数据就进入 slot 0 。如果我们从缓冲区写一些数据，从缓冲区读取的下一个字节就来自 slot 0 。 </p>
<p>position
 设置如下所示：
<img src="" alt="Position setting"> </p>
<p>由于 </p>
<p>capacity
 不会改变，所以我们在下面的讨论中可以忽略它。</p>
<h3 id="-"><a href=""></a><strong>第一次读取</strong></h3>
<p>现在我们可以开始在新创建的缓冲区上进行读/写操作。首先从输入通道中读一些数据到缓冲区中。第一次读取得到三个字节。它们被放到数组中从 </p>
<p>position
 开始的位置，这时 position 被设置为 0。读完之后，position 就增加到 3，如下所示：
<img src="" alt="Position increased to 3"> </p>
<p>limit
 没有改变。</p>
<h3 id="-"><a href=""></a><strong>第二次读取</strong></h3>
<p>在第二次读取时，我们从输入通道读取另外两个字节到缓冲区中。这两个字节储存在由 </p>
<p>position
 所指定的位置上， </p>
<p>position
 因而增加 2：
<img src="" alt="Position increased by 2"> </p>
<p>limit
 没有改变。</p>
<h3 id="-flip-"><a href=""></a><strong>flip</strong></h3>
<p>现在我们要将数据写到输出通道中。在这之前，我们必须调用 </p>
<p>flip()
 方法。这个方法做两件非常重要的事：</p>
<ol>
<li>它将 </li>
</ol>
<p>limit
 设置为当前 </p>
<p>position
。</p>
<ol>
<li>它将 </li>
</ol>
<p>position
 设置为 0。</p>
<p>前一小节中的图显示了在 flip 之前缓冲区的情况。下面是在 flip 之后的缓冲区：
<img src="" alt="Buffer after the flip"> </p>
<p>我们现在可以将数据从缓冲区写入通道了。 </p>
<p>position
 被设置为 0，这意味着我们得到的下一个字节是第一个字节。 </p>
<p>limit
 已被设置为原来的 </p>
<p>position
，这意味着它包括以前读到的所有字节，并且一个字节也不多。</p>
<h3 id="-"><a href=""></a><strong>第一次写入</strong></h3>
<p>在第一次写入时，我们从缓冲区中取四个字节并将它们写入输出通道。这使得 </p>
<p>position
 增加到 4，而 </p>
<p>limit
 不变，如下所示：
<img src="" alt="Position advanced to 4, limit unchanged"> </p>
<h3 id="-"><a href=""></a><strong>第二次写入</strong></h3>
<p>我们只剩下一个字节可写了。 </p>
<p>limit
在我们调用 </p>
<p>flip()
 时被设置为 5，并且 </p>
<p>position
 不能超过 </p>
<p>limit
。所以最后一次写入操作从缓冲区取出一个字节并将它写入输出通道。这使得 </p>
<p>position
 增加到 5，并保持 </p>
<p>limit
 不变，如下所示：
<img src="" alt="Position advanced to 5, limit unchanged"> </p>
<h3 id="-clear-"><a href=""></a><strong>clear</strong></h3>
<p>最后一步是调用缓冲区的 </p>
<p>clear()
 方法。这个方法重设缓冲区以便接收更多的字节。 </p>
<p>Clear
 做两种非常重要的事情：</p>
<ol>
<li>它将 </li>
</ol>
<p>limit
 设置为与 </p>
<p>capacity
 相同。</p>
<ol>
<li>它设置 </li>
</ol>
<p>position
 为 0。</p>
<p>下图显示了在调用 </p>
<p>clear()
 后缓冲区的状态：
<img src="" alt="State of the buffer after clear() has been called"> </p>
<p>缓冲区现在可以接收新的数据了。</p>
<p><strong>访问方法</strong></p>
<p>到目前为止，我们只是使用缓冲区将数据从一个通道转移到另一个通道。然而，程序经常需要直接处理数据。例如，您可能需要将用户数据保存到磁盘。在这种情况下，您必须将这些数据直接放入缓冲区，然后用通道将缓冲区写入磁盘。</p>
<p>或者，您可能想要从磁盘读取用户数据。在这种情况下，您要将数据从通道读到缓冲区中，然后检查缓冲区中的数据。</p>
<p>在本节的最后，我们将详细分析如何使用 </p>
<p>ByteBuffer
 类的 </p>
<p>get()
 和 </p>
<p>put()
 方法直接访问缓冲区中的数据</p>
<h3 id="-"><a href=""></a></h3>
<p>get()方法</p>
<p>ByteBuffer
 类中有四个 </p>
<p>get()
 方法：</p>
<ol>
<li>byte get();</li>
<li>ByteBuffer get( byte dst[] );</li>
<li>ByteBuffer get( byte dst[], int offset, int length );</li>
<li>byte get( int index );</li>
</ol>
<p>第一个方法获取单个字节。第二和第三个方法将一组字节读到一个数组中。第四个方法从缓冲区中的特定位置获取字节。那些返回</p>
<p>ByteBuffer
 的方法只是返回调用它们的缓冲区的 </p>
<p>this
 值。</p>
<p>此外，我们认为前三个 </p>
<p>get()
 方法是相对的，而最后一个方法是绝对的。 <em>相对 </em>意味着 </p>
<p>get()
 操作服从 </p>
<p>limit
 和 </p>
<p>position
 值 ― 更明确地说，字节是从当前 </p>
<p>position
 读取的，而 </p>
<p>position
 在 </p>
<p>get
 之后会增加。另一方面，一个 <em>绝对 </em>方法会忽略 </p>
<p>limit
 和 </p>
<p>position
 值，也不会影响它们。事实上，它完全绕过了缓冲区的统计方法。</p>
<p>上面列出的方法对应于 </p>
<p>ByteBuffer
 类。其他类有等价的 </p>
<p>get()
 方法，这些方法除了不是处理字节外，其它方面是是完全一样的，它们处理的是与该缓冲区类相适应的类型。</p>
<h3 id="-put-"><a href=""></a><strong>put()方法</strong></h3>
<p>ByteBuffer
 类中有五个 </p>
<p>put()
 方法：</p>
<ol>
<li>ByteBuffer put( byte b );</li>
<li>ByteBuffer put( byte src[] );</li>
<li>ByteBuffer put( byte src[], int offset, int length );</li>
<li>ByteBuffer put( ByteBuffer src );</li>
<li>ByteBuffer put( int index, byte b );</li>
</ol>
<p>第一个方法 </p>
<p>写入（put） 
单个字节。第二和第三个方法写入来自一个数组的一组字节。第四个方法将数据从一个给定的源</p>
<p>ByteBuffer
 写入这个 </p>
<p>ByteBuffer
。第五个方法将字节写入缓冲区中特定的 </p>
<p>位置 
。那些返回 </p>
<p>ByteBuffer
 的方法只是返回调用它们的缓冲区的 </p>
<p>this
 值。</p>
<p>与 </p>
<p>get()
 方法一样，我们将把 </p>
<p>put()
 方法划分为 <em>相对 </em>或者 <em>绝对 </em>的。前四个方法是相对的，而第五个方法是绝对的。</p>
<p>上面显示的方法对应于 </p>
<p>ByteBuffer
 类。其他类有等价的 </p>
<p>put()
 方法，这些方法除了不是处理字节之外，其它方面是完全一样的。它们处理的是与该缓冲区类相适应的类型。</p>
<h3 id="-get-put-"><a href=""></a>类型化的 get() 和 put() 方法</h3>
<p>除了前些小节中描述的 </p>
<p>get()
 和 </p>
<p>put()
 方法， </p>
<p>ByteBuffer
 还有用于读写不同类型的值的其他方法，如下所示：</p>
<ul>
<li>getByte()</li>
<li>getChar()</li>
<li>getShort()</li>
<li>getInt()</li>
<li>getLong()</li>
<li>getFloat()</li>
<li>getDouble()</li>
<li>putByte()</li>
<li>putChar()</li>
<li>putShort()</li>
<li>putInt()</li>
<li>putLong()</li>
<li>putFloat()</li>
<li>putDouble()</li>
</ul>
<p>事实上，这其中的每个方法都有两种类型 ― 一种是相对的，另一种是绝对的。它们对于读取格式化的二进制数据（如图像文件的头部）很有用。</p>
<p>您可以在例子程序 TypesInByteBuffer.java 中看到这些方法的实际应用。</p>
<h3 id="-"><a href=""></a><strong>缓冲区的使用：一个内部循环</strong></h3>
<p>下面的内部循环概括了使用缓冲区将数据从输入通道拷贝到输出通道的过程。
while (true) {</p>
<pre><code> buffer.clear();
 int r = fcin.read( buffer );


 if (r==-1) {

   break;
 }


 buffer.flip();

 fcout.write( buffer );
</code></pre><p>}</p>
<p>read()
 和 </p>
<p>write()
 调用得到了极大的简化，因为许多工作细节都由缓冲区完成了。 </p>
<p>clear()
 和 </p>
<p>flip()
 方法用于让缓冲区在读和写之间切换。</p>
<p>5、关于缓冲区的更多内容</p>
<p><strong>概述</strong></p>
<p>到目前为止，您已经学习了使用缓冲区进行日常工作所需要掌握的大部分内容。我们的例子没怎么超出标准的读/写过程种类，在原来的 I/O 中可以像在 NIO 中一样容易地实现这样的标准读写过程。</p>
<p>本节将讨论使用缓冲区的一些更复杂的方面，比如缓冲区分配、包装和分片。我们还会讨论 NIO 带给 Java 平台的一些新功能。您将学到如何创建不同类型的缓冲区以达到不同的目的，如可保护数据不被修改的 <em>只读 </em>缓冲区，和直接映射到底层操作系统缓冲区的 <em>直接 </em>缓冲区。我们将在本节的最后介绍如何在 NIO 中创建内存映射文件。</p>
<p><strong>缓冲区分配和包装</strong></p>
<p>在能够读和写之前，必须有一个缓冲区。要创建缓冲区，您必须 <em>分配 </em>它。我们使用静态方法 </p>
<p>allocate()
 来分配缓冲区：
ByteBuffer buffer = ByteBuffer.allocate( 1024 );</p>
<p>allocate()
 方法分配一个具有指定大小的底层数组，并将它包装到一个缓冲区对象中 ― 在本例中是一个 </p>
<p>ByteBuffer
。</p>
<p>您还可以将一个现有的数组转换为缓冲区，如下所示：
byte array[] = new byte[1024];</p>
<p>ByteBuffer buffer = ByteBuffer.wrap( array );</p>
<p>本例使用了 </p>
<p>wrap()
 方法将一个数组包装为缓冲区。必须非常小心地进行这类操作。一旦完成包装，底层数据就可以通过缓冲区或者直接访问。</p>
<p><strong>缓冲区分片</strong></p>
<p>slice()
 方法根据现有的缓冲区创建一种 <em>子缓冲区 </em>。也就是说，它创建一个新的缓冲区，新缓冲区与原来的缓冲区的一部分共享数据。</p>
<p>使用例子可以最好地说明这点。让我们首先创建一个长度为 10 的 </p>
<p>ByteBuffer
：
ByteBuffer buffer = ByteBuffer.allocate( 10 );</p>
<p>然后使用数据来填充这个缓冲区，在第 <em>n</em> 个槽中放入数字 <em>n</em>：
for (int i=0; i&lt;buffer.capacity(); ++i) {</p>
<pre><code> buffer.put( (byte)i );
</code></pre><p>}</p>
<p>现在我们对这个缓冲区 <em>分片 </em>，以创建一个包含槽 3 到槽 6 的子缓冲区。在某种意义上，子缓冲区就像原来的缓冲区中的一个 <em>窗口 </em>。</p>
<p>窗口的起始和结束位置通过设置 </p>
<p>position
 和 </p>
<p>limit
 值来指定，然后调用 </p>
<p>Buffer
 的 </p>
<p>slice()
 方法：
buffer.position( 3 );</p>
<p>buffer.limit( 7 );
ByteBuffer slice = buffer.slice();</p>
<p>片段
是缓冲区的 </p>
<p>子缓冲区 
。不过， </p>
<p>片段
和 </p>
<p>缓冲区
共享同一个底层数据数组，我们在下一节将会看到这一点。</p>
<p><strong>缓冲区分片和数据共享</strong></p>
<p>我们已经创建了原缓冲区的子缓冲区，并且我们知道缓冲区和子缓冲区共享同一个底层数据数组。让我们看看这意味着什么。</p>
<p>我们遍历子缓冲区，将每一个元素乘以 11 来改变它。例如，5 会变成 55。
for (int i=0; i&lt;slice.capacity(); ++i) {</p>
<pre><code> byte b = slice.get( i );
 b /*= 11;

 slice.put( i, b );
</code></pre><p>}</p>
<p>最后，再看一下原缓冲区中的内容：
buffer.position( 0 );</p>
<p>buffer.limit( buffer.capacity() );</p>
<p>while (buffer.remaining()&gt;0) {
     System.out.println( buffer.get() );</p>
<p>}</p>
<p>结果表明只有在子缓冲区窗口中的元素被改变了：
$ java SliceBuffer</p>
<p>0
1</p>
<p>2
33</p>
<p>44
55</p>
<p>66
7</p>
<p>8
9</p>
<p>缓冲区片对于促进抽象非常有帮助。可以编写自己的函数处理整个缓冲区，而且如果想要将这个过程应用于子缓冲区上，您只需取主缓冲区的一个片，并将它传递给您的函数。这比编写自己的函数来取额外的参数以指定要对缓冲区的哪一部分进行操作更容易。</p>
<p><strong>只读缓冲区</strong></p>
<p>只读缓冲区非常简单 ― 您可以读取它们，但是不能向它们写入。可以通过调用缓冲区的 </p>
<p>asReadOnlyBuffer()
 方法，将任何常规缓冲区转换为只读缓冲区，这个方法返回一个与原缓冲区完全相同的缓冲区(并与其共享数据)，只不过它是只读的。</p>
<p>只读缓冲区对于保护数据很有用。在将缓冲区传递给某个对象的方法时，您无法知道这个方法是否会修改缓冲区中的数据。创建一个只读的缓冲区可以 <em>保证 </em>该缓冲区不会被修改。</p>
<p>不能将只读的缓冲区转换为可写的缓冲区。</p>
<p><strong>直接和间接缓冲区</strong></p>
<p>另一种有用的 </p>
<p>ByteBuffer
 是直接缓冲区。 <em>直接缓冲区 </em>是为加快 I/O 速度，而以一种特殊的方式分配其内存的缓冲区。</p>
<p>实际上，直接缓冲区的准确定义是与实现相关的。Sun 的文档是这样描述直接缓冲区的：</p>
<p><em>给定一个直接字节缓冲区，Java 虚拟机将尽最大努力直接对它执行本机 I/O 操作。也就是说，它会在每一次调用底层操作系统的本机 I/O 操作之前(或之后)，尝试避免将缓冲区的内容拷贝到一个中间缓冲区中(或者从一个中间缓冲区中拷贝数据)。</em></p>
<p>您可以在例子程序 FastCopyFile.java 中看到直接缓冲区的实际应用，这个程序是 CopyFile.java 的另一个版本，它使用了直接缓冲区以提高速度。</p>
<p>还可以用内存映射文件创建直接缓冲区。</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/ssjhust123/article/details/7905278#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/ssjhust123/article/details/7905278#" title="copy" target="_blank">copy</a></p>
<ol>
<li>ByteBuffer buffer = ByteBuffer.allocateDirect( 1024 ); //直接缓冲区  </li>
</ol>
<p><strong>内存映射文件I/O</strong></p>
<p>内存映射文件 I/O 是一种读和写文件数据的方法，它可以比常规的基于流或者基于通道的 I/O 快得多。</p>
<p>内存映射文件 I/O 是通过使文件中的数据神奇般地出现为内存数组的内容来完成的。这其初听起来似乎不过就是将整个文件读到内存中，但是事实上并不是这样。一般来说，只有文件中实际读取或者写入的部分才会送入（或者 <em>映射 </em>）到内存中。</p>
<p>内存映射并不真的神奇或者多么不寻常。现代操作系统一般根据需要将文件的部分映射为内存的部分，从而实现文件系统。Java 内存映射机制不过是在底层操作系统中可以采用这种机制时，提供了对该机制的访问。</p>
<p>尽管创建内存映射文件相当简单，但是向它写入可能是危险的。仅只是改变数组的单个元素这样的简单操作，就可能会直接修改磁盘上的文件。修改数据与将数据保存到磁盘是没有分开的。</p>
<p><strong>将文件映射到内存</strong></p>
<p>了解内存映射的最好方法是使用例子。在下面的例子中，我们要将一个 </p>
<p>FileChannel
 (它的全部或者部分)映射到内存中。为此我们将使用 </p>
<p>FileChannel.map()
 方法。下面代码行将文件的前 1024 个字节映射到内存中：
MappedByteBuffer mbb = fc.map( FileChannel.MapMode.READ_WRITE,</p>
<pre><code> 0, 1024 );
</code></pre><p>map()
 方法返回一个 </p>
<p>MappedByteBuffer
，它是 </p>
<p>ByteBuffer
 的子类。因此，您可以像使用其他任何 </p>
<p>ByteBuffer
 一样使用新映射的缓冲区，操作系统会在需要时负责执行行映射。
来源： <a href="[http://blog.csdn.net/ssjhust123/article/details/7905278](http://blog.csdn.net/ssjhust123/article/details/7905278)">[http://blog.csdn.net/ssjhust123/article/details/7905278](http://blog.csdn.net/ssjhust123/article/details/7905278)</a> </p>
<p><a href="http://blog.csdn.net/ssjhust123/article/details/7905367" target="_blank">（三）—分散聚集、文件锁定、字符集</a></p>
<h2 id="6-">6、分散和聚集</h2>
<p><strong>概述</strong></p>
<p>分散/聚集 I/O 是使用多个而不是单个缓冲区来保存数据的读写方法。</p>
<p>一个分散的读取就像一个常规通道读取，只不过它是将数据读到一个缓冲区数组中而不是读到单个缓冲区中。同样地，一个聚集写入是向缓冲区数组而不是向单个缓冲区写入数据。分散/聚集 I/O 对于将数据流划分为单独的部分很有用，这有助于实现复杂的数据格式。</p>
<p><strong>分散/聚集IO</strong></p>
<p>通道可以有选择地实现两个新的接口： </p>
<p>ScatteringByteChannel
 和 </p>
<p>GatheringByteChannel
。一个 </p>
<p>ScatteringByteChannel
 是一个具有两个附加读方法的通道：</p>
<ul>
<li>long read( ByteBuffer[] dsts );</li>
<li>long read( ByteBuffer[] dsts, int offset, int length );</li>
</ul>
<p>这些 </p>
<p>long read()
 方法很像标准的 </p>
<p>read
 方法，只不过它们不是取单个缓冲区而是取一个缓冲区数组。</p>
<p>在 <em>分散读取 </em>中，通道依次填充每个缓冲区。填满一个缓冲区后，它就开始填充下一个。在某种意义上，缓冲区数组就像一个大缓冲区。</p>
<p><em>聚集写入 </em>类似于分散读取，只不过是用来写入。它也有接受缓冲区数组的方法：</p>
<ul>
<li>long write( ByteBuffer[] srcs );</li>
<li>long write( ByteBuffer[] srcs, int offset, int length );</li>
</ul>
<p>聚集写对于把一组单独的缓冲区中组成单个数据流很有用。为了与上面的消息例子保持一致，您可以使用聚集写入来自动将网络消息的各个部分组装为单个数据流，以便跨越网络传输消息。</p>
<p>从例子程序 UseScatterGather.java 中可以看到分散读取和聚集写入的实际应用。</p>
<p><strong>分散/聚集的应用</strong></p>
<p>分散/聚集 I/O 对于将数据划分为几个部分很有用。例如，您可能在编写一个使用消息对象的网络应用程序，每一个消息被划分为固定长度的头部和固定长度的正文。您可以创建一个刚好可以容纳头部的缓冲区和另一个刚好可以容难正文的缓冲区。当您将它们放入一个数组中并使用分散读取来向它们读入消息时，头部和正文将整齐地划分到这两个缓冲区中。</p>
<p>我们从缓冲区所得到的方便性对于缓冲区数组同样有效。因为每一个缓冲区都跟踪自己还可以接受多少数据，所以分散读取会自动找到有空间接受数据的第一个缓冲区。在这个缓冲区填满后，它就会移动到下一个缓冲区。</p>
<h2 id="-7-"><a href=""></a>7、文件锁定</h2>
<p><strong>概述</strong></p>
<p>文件锁定初看起来可能让人迷惑。它 <em>似乎 </em>指的是防止程序或者用户访问特定文件。事实上，文件锁就像常规的 Java 对象锁 ― 它们是 <em>劝告式的（advisory） </em>锁。它们不阻止任何形式的数据访问，相反，它们通过锁的共享和获取赖允许系统的不同部分相互协调。</p>
<p>您可以锁定整个文件或者文件的一部分。如果您获取一个排它锁，那么其他人就不能获得同一个文件或者文件的一部分上的锁。如果您获得一个共享锁，那么其他人可以获得同一个文件或者文件一部分上的共享锁，但是不能获得排它锁。文件锁定并不总是出于保护数据的目的。例如，您可能临时锁定一个文件以保证特定的写操作成为原子的，而不会有其他程序的干扰。</p>
<p>大多数操作系统提供了文件系统锁，但是它们并不都是采用同样的方式。有些实现提供了共享锁，而另一些仅提供了排它锁。事实上，有些实现使得文件的锁定部分不可访问，尽管大多数实现不是这样的。</p>
<p>在本节中，您将学习如何在 NIO 中执行简单的文件锁过程，我们还将探讨一些保证被锁定的文件尽可能可移植的方法。</p>
<p><strong>锁定文件</strong></p>
<p>要获取文件的一部分上的锁，您要调用一个打开的 </p>
<p>FileChannel
 上的 </p>
<p>lock()
 方法。注意，如果要获取一个排它锁，您必须以写方式打开文件。
RandomAccessFile raf = new RandomAccessFile( &quot;usefilelocks.txt&quot;, &quot;rw&quot; );</p>
<p>FileChannel fc = raf.getChannel();
FileLock lock = fc.lock( start, end, false );</p>
<p>在拥有锁之后，您可以执行需要的任何敏感操作，然后再释放锁：
lock.release();</p>
<p>在释放锁后，尝试获得锁的其他任何程序都有机会获得它。</p>
<p>本小节的例子程序 UseFileLocks.java 必须与它自己并行运行。这个程序获取一个文件上的锁，持有三秒钟，然后释放它。如果同时运行这个程序的多个实例，您会看到每个实例依次获得锁。如果两个程序分别获取同一个文件不同位置的锁，则不会阻塞。比如第一个程序获取文件范围为0-20的锁，而第二个程序获取21-40的锁，则会正常执行。</p>
<p><strong>文件锁定和可移植性</strong></p>
<p>文件锁定可能是一个复杂的操作，特别是考虑到不同的操作系统是以不同的方式实现锁这一事实。下面的指导原则将帮助您尽可能保持代码的可移植性：</p>
<ul>
<li>只使用排它锁。</li>
<li>将所有的锁视为劝告式的（advisory）。</li>
</ul>
<p>8、字符集</p>
<p><strong>概述</strong></p>
<p>根据 Sun 的文档，一个 </p>
<p>Charset
 是“十六位 Unicode 字符序列与字节序列之间的一个命名的映射”。实际上，一个 </p>
<p>Charset
 允许您以尽可能最具可移植性的方式读写字符序列。</p>
<p>Java 语言被定义为基于 Unicode。然而在实际上，许多人编写代码时都假设一个字符在磁盘上或者在网络流中用一个字节表示。这种假设在许多情况下成立，但是并不是在所有情况下都成立，而且随着计算机变得对 Unicode 越来越友好，这个假设就日益变得不能成立了。</p>
<p>在本节中，我们将看一下如何使用 </p>
<p>Charsets
 以适合现代文本格式的方式处理文本数据。这里将使用的示例程序相当简单，不过，它触及了使用 </p>
<p>Charset
 的所有关键方面：为给定的字符编码创建 </p>
<p>Charset
，以及使用该 </p>
<p>Charset
 解码和编码文本数据。</p>
<p><a href="http://www.ibm.com/developerworks/cn/education/java/j-nio/section10.html#ibm-pcon" target="_blank">回页首</a></p>
<p><strong>编码/解码</strong></p>
<p>要读和写文本，我们要分别使用 </p>
<p>CharsetDecoder
 和 </p>
<p>CharsetEncoder
。将它们称为 <em>编码器 </em>和 <em>解码器 </em>是有道理的。一个 <em>字符 </em>不再表示一个特定的位模式，而是表示字符系统中的一个实体。因此，由某个实际的位模式表示的字符必须以某种特定的 <em>编码 </em>来表示。</p>
<p>CharsetDecoder
 用于将逐位表示的一串字符转换为具体的 </p>
<p>char
 值。同样，一个 </p>
<p>CharsetEncoder
 用于将字符转换回位。</p>
<p>在下一个小节中，我们将考察一个使用这些对象来读写数据的程序。</p>
<p><a href="http://www.ibm.com/developerworks/cn/education/java/j-nio/section10.html#ibm-pcon" target="_blank">回页首</a></p>
<p><strong>处理文本的正确方式</strong></p>
<p>现在我们将分析这个例子程序 UseCharsets.java。这个程序非常简单 ― 它从一个文件中读取一些文本，并将该文本写入另一个文件。但是它把该数据当作文本数据，并使用 </p>
<p>CharBuffer
 来将该数句读入一个 </p>
<p>CharsetDecoder
 中。同样，它使用 </p>
<p>CharsetEncoder
 来写回该数据。</p>
<p>我们将假设字符以 ISO-8859-1(Latin1) 字符集（这是 ASCII 的标准扩展）的形式储存在磁盘上。尽管我们必须为使用 Unicode 做好准备，但是也必须认识到不同的文件是以不同的格式储存的，而 ASCII 无疑是非常普遍的一种格式。事实上，每种 Java 实现都要求对以下字符编码提供完全的支持：</p>
<ul>
<li>US-ASCII</li>
<li>ISO-8859-1</li>
<li>UTF-8</li>
<li>UTF-16BE</li>
<li>UTF-16LE</li>
<li>UTF-16</li>
</ul>
<p><a href="http://www.ibm.com/developerworks/cn/education/java/j-nio/section10.html#ibm-pcon" target="_blank">回页首</a></p>
<p><strong>示例程序</strong></p>
<p>在打开相应的文件、将输入数据读入名为 </p>
<p>inputData
 的 </p>
<p>ByteBuffer
 之后，我们的程序必须创建 ISO-8859-1 (Latin1) 字符集的一个实例：
Charset latin1 = Charset.forName( &quot;ISO-8859-1&quot; );</p>
<p>然后，创建一个解码器（用于读取）和一个编码器 （用于写入）：
CharsetDecoder decoder = latin1.newDecoder();</p>
<p>CharsetEncoder encoder = latin1.newEncoder();</p>
<p>为了将字节数据解码为一组字符，我们把 </p>
<p>ByteBuffer
 传递给 </p>
<p>CharsetDecoder
，结果得到一个 </p>
<p>CharBuffer
：
CharBuffer cb = decoder.decode( inputData );</p>
<p>如果想要处理字符，我们可以在程序的此处进行。但是我们只想无改变地将它写回，所以没有什么要做的。</p>
<p>要写回数据，我们必须使用 </p>
<p>CharsetEncoder
 将它转换回字节：
ByteBuffer outputData = encoder.encode( cb );</p>
<p>在转换完成之后，我们就可以将数据写到文件中了。
来源： <a href="[http://blog.csdn.net/ssjhust123/article/details/7905367](http://blog.csdn.net/ssjhust123/article/details/7905367)">[http://blog.csdn.net/ssjhust123/article/details/7905367](http://blog.csdn.net/ssjhust123/article/details/7905367)</a> <a href="http://blog.csdn.net/ssjhust123/article/details/7905401" target="_blank">（四）—网络和异步IO</a></p>
<p>9、连网和异步 I/O</p>
<p><strong>概述</strong></p>
<p>连网是学习异步 I/O 的很好基础，而异步 I/O 对于在 Java 语言中执行任何输入/输出过程的人来说，无疑都是必须具备的知识。NIO 中的连网与 NIO 中的其他任何操作没有什么不同 ― 它依赖通道和缓冲区，而您通常使用 </p>
<p>InputStream
 和 </p>
<p>OutputStream
 来获得通道。</p>
<p>本节首先介绍异步 I/O 的基础 ― 它是什么以及它不是什么，然后转向更实用的、程序性的例子。</p>
<p><strong>异步I/O</strong></p>
<p>异步 I/O 是一种 <em>没有阻塞地 </em>读写数据的方法。通常，在代码进行 </p>
<p>read()
 调用时，代码会阻塞直至有可供读取的数据。同样，</p>
<p>write()
 调用将会阻塞直至数据能够写入。</p>
<p>另一方面，异步 I/O 调用不会阻塞。相反，您将注册对特定 I/O 事件的兴趣 ― 可读的数据的到达、新的套接字连接，等等，而在发生这样的事件时，系统将会告诉您。</p>
<p>异步 I/O 的一个优势在于，它允许您同时根据大量的输入和输出执行 I/O。同步程序常常要求助于轮询，或者创建许许多多的线程以处理大量的连接。使用异步 I/O，您可以监听任何数量的通道上的事件，不用轮询，也不用额外的线程。</p>
<p>我们将通过研究一个名为 MultiPortEcho.java 的例子程序来查看异步 I/O 的实际应用。这个程序就像传统的 <em>echo server</em>，它接受网络连接并向它们回响它们可能发送的数据。不过它有一个附加的特性，就是它能同时监听多个端口，并处理来自所有这些端口的连接。并且它只在单个线程中完成所有这些工作。</p>
<p><strong>Selectors</strong></p>
<p>本节的阐述对应于 </p>
<p>MultiPortEcho
 的源代码中的 </p>
<p>go()
 方法的实现，因此应该看一下源代码，以便对所发生的事情有个更全面的了解。</p>
<p>异步 I/O 中的核心对象名为 </p>
<p>Selector
。</p>
<p>Selector
 就是您注册对各种 I/O 事件的兴趣的地方，而且当那些事件发生时，就是这个对象告诉您所发生的事件。</p>
<p>所以，我们需要做的第一件事就是创建一个 </p>
<p>Selector
：
Selector selector = Selector.open();</p>
<p>然后，我们将对不同的通道对象调用 </p>
<p>register()
 方法，以便注册我们对这些对象中发生的 I/O 事件的兴趣。</p>
<p>register()
 的第一个参数总是这个 </p>
<p>Selector
。</p>
<p><strong>打开一个Server Socket Channel</strong></p>
<p>为了接收连接，我们需要一个 </p>
<p>ServerSocketChannel
。事实上，我们要监听的每一个端口都需要有一个 </p>
<p>ServerSocketChannel
 。对于每一个端口，我们打开一个 </p>
<p>ServerSocketChannel
，如下所示：
ServerSocketChannel ssc = ServerSocketChannel.open();</p>
<p>ssc.configureBlocking( false );</p>
<p>ServerSocket ss = ssc.socket();
InetSocketAddress address = new InetSocketAddress( ports[i] );</p>
<p>ss.bind( address );</p>
<p>第一行创建一个新的 </p>
<p>ServerSocketChannel
 ，最后三行将它绑定到给定的端口。第二行将 </p>
<p>ServerSocketChannel
 设置为 <em>非阻塞的 </em>。我们必须对每一个要使用的套接字通道调用这个方法，否则异步 I/O 就不能工作。</p>
<p><strong>选择键</strong></p>
<p>下一步是将新打开的 </p>
<p>ServerSocketChannels
 注册到 </p>
<p>Selector
上。为此我们使用 ServerSocketChannel.register() 方法，如下所示：
SelectionKey key = ssc.register( selector, SelectionKey.OP_ACCEPT );</p>
<p>register()
 的第一个参数总是这个 </p>
<p>Selector
。第二个参数是 </p>
<p>OP_ACCEPT
，这里它指定我们想要监听 <em>accept</em> 事件，也就是在新的连接建立时所发生的事件。这是适用于 </p>
<p>ServerSocketChannel
 的唯一事件类型。</p>
<p>请注意对 </p>
<p>register()
 的调用的返回值。 </p>
<p>SelectionKey
 代表这个通道在此 </p>
<p>Selector
 上的这个注册。当某个 </p>
<p>Selector
 通知您某个传入事件时，它是通过提供对应于该事件的 </p>
<p>SelectionKey
 来进行的。</p>
<p>SelectionKey
 还可以用于取消通道的注册。</p>
<p><strong>内部循环</strong></p>
<p>现在已经注册了我们对一些 I/O 事件的兴趣，下面将进入主循环。使用 </p>
<p>Selectors
 的几乎每个程序都像下面这样使用内部循环：
int num = selector.select();</p>
<p>Set selectedKeys = selector.selectedKeys();</p>
<p>Iterator it = selectedKeys.iterator();</p>
<p>while (it.hasNext()) {
     SelectionKey key = (SelectionKey)it.next();</p>
<pre><code> // ... deal with I/O event ...
</code></pre><p>}</p>
<p>首先，我们调用 </p>
<p>Selector
 的 </p>
<p>select()
 方法。这个方法会阻塞，直到至少有一个已注册的事件发生。当一个或者更多的事件发生时，</p>
<p>select()
 方法将返回所发生的事件的数量。</p>
<p>接下来，我们调用 </p>
<p>Selector
 的 </p>
<p>selectedKeys()
 方法，它返回发生了事件的 </p>
<p>SelectionKey
 对象的一个 </p>
<p>集合 
。</p>
<p>我们通过迭代 </p>
<p>SelectionKeys
 并依次处理每个 </p>
<p>SelectionKey
 来处理事件。对于每一个 </p>
<p>SelectionKey
，您必须确定发生的是什么 I/O 事件，以及这个事件影响哪些 I/O 对象。</p>
<p><strong>监听新连接</strong></p>
<p>程序执行到这里，我们仅注册了 </p>
<p>ServerSocketChannel
，并且仅注册它们“接收”事件。为确认这一点，我们对 </p>
<p>SelectionKey
 调用</p>
<p>readyOps()
 方法，并检查发生了什么类型的事件：
if ((key.readyOps() &amp; SelectionKey.OP_ACCEPT)</p>
<pre><code> == SelectionKey.OP_ACCEPT) {


 // Accept the new connection
 // ...
</code></pre><p>}</p>
<p>可以肯定地说， </p>
<p>readOps()
 方法告诉我们该事件是新的连接。</p>
<p><strong>接收新的连接</strong></p>
<p>因为我们知道这个服务器套接字上有一个传入连接在等待，所以可以安全地接受它；也就是说，不用担心 </p>
<p>accept()
 操作会阻塞：
ServerSocketChannel ssc = (ServerSocketChannel)key.channel();</p>
<p>SocketChannel sc = ssc.accept();</p>
<p>下一步是将新连接的 </p>
<p>SocketChannel
 配置为非阻塞的。而且由于接受这个连接的目的是为了读取来自套接字的数据，所以我们还必须将 </p>
<p>SocketChannel
 注册到 </p>
<p>Selector
上，如下所示：
sc.configureBlocking( false );</p>
<p>SelectionKey newKey = sc.register( selector, SelectionKey.OP_READ );</p>
<p>注意我们使用 </p>
<p>register()
 的 </p>
<p>OP_READ
 参数，将 </p>
<p>SocketChannel
 注册用于 <em>读取 </em>而不是 <em>接受 </em>新连接。</p>
<p><strong>删除处理过的SelectionKey</strong></p>
<p>在处理 </p>
<p>SelectionKey
 之后，我们几乎可以返回主循环了。但是我们必须首先将处理过的 </p>
<p>SelectionKey
 从选定的键集合中删除。如果我们没有删除处理过的键，那么它仍然会在主集合中以一个激活的键出现，这会导致我们尝试再次处理它。我们调用迭代器的</p>
<p>remove()
 方法来删除处理过的 </p>
<p>SelectionKey
：
it.remove();</p>
<p>现在我们可以返回主循环并接受从一个套接字中传入的数据(或者一个传入的 I/O 事件)了。</p>
<p><strong>传入的I/O</strong></p>
<p>当来自一个套接字的数据到达时，它会触发一个 I/O 事件。这会导致在主循环中调用 </p>
<p>Selector.select()
，并返回一个或者多个 I/O 事件。这一次， </p>
<p>SelectionKey
 将被标记为 </p>
<p>OP_READ
 事件，如下所示：
} else if ((key.readyOps() &amp; SelectionKey.OP_READ)</p>
<pre><code> == SelectionKey.OP_READ) {
 // Read the data

 SocketChannel sc = (SocketChannel)key.channel();
 // ...
</code></pre><p>}</p>
<p>与以前一样，我们取得发生 I/O 事件的通道并处理它。在本例中，由于这是一个 echo server，我们只希望从套接字中读取数据并马上将它发送回去。关于这个过程的细节，请参见代码中的源代码 (MultiPortEcho.java)。</p>
<p><strong>回到主循环</strong></p>
<p>每次返回主循环，我们都要调用 </p>
<p>select
 的 </p>
<p>Selector()
方法，并取得一组 </p>
<p>SelectionKey
。每个键代表一个 I/O 事件。我们处理事件，从选定的键集中删除 </p>
<p>SelectionKey
，然后返回主循环的顶部。</p>
<p>这个程序有点过于简单，因为它的目的只是展示异步 I/O 所涉及的技术。在现实的应用程序中，您需要通过将通道从 </p>
<p>Selector
 中删除来处理关闭的通道。而且您可能要使用多个线程。这个程序可以仅使用一个线程，因为它只是一个演示，但是在现实场景中，创建一个线程池来负责 I/O 事件处理中的耗时部分会更有意义。
来源： <a href="[http://blog.csdn.net/ssjhust123/article/details/7905401](http://blog.csdn.net/ssjhust123/article/details/7905401)">[http://blog.csdn.net/ssjhust123/article/details/7905401](http://blog.csdn.net/ssjhust123/article/details/7905401)</a> </p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/NIO/">NIO</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/NIO/" class="label label-success">NIO</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:41"datetime="2014-03-07 09:54:41"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-NIO--JAVANIO总结/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-NIO--JAVANIO总结" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-NIO--JavaNIOAPI详解/">Java NIO API详解</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:41.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-NIO--JavaNIOAPI详解/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="java-nio-api-">Java NIO API详解</h1>
<p><a href="http://www.blogjava.net/19851985lili/" target="_blank">【永恒的瞬间】</a>
☜Give me hapy ☞</p>
<p><a href="http://www.blogjava.net/" target="_blank">BlogJava</a>   <a href="http://www.blogjava.net/19851985lili/" target="_blank">首页</a>      <a href="http://www.blogjava.net/EnterMyBlog.aspx?NewArticle=1" target="_blank">新文章</a>   <a href="http://www.blogjava.net/19851985lili/contact.aspx?id=1" target="_blank">联系</a>   <a href="http://www.blogjava.net/19851985lili/rss" target="_blank">聚合</a><a href="http://www.blogjava.net/19851985lili/rss" target="_blank"><img src="" alt=""></a>   <a href="http://www.blogjava.net/19851985lili/admin/EditPosts.aspx" target="_blank">管理</a>
诱惑的世界,难以自我!
名利的生活,面具包裹!
我们的人生,充当角色!
寂静的深夜,真实自我!
<img src="" alt=""></p>
<h3 id="-">常用链接</h3>
<ul>
<li><a href="http://www.blogjava.net/19851985lili/MyPosts.html" target="_blank">我的随笔</a></li>
<li><a href="http://www.blogjava.net/19851985lili/MyComments.html" target="_blank">我的评论</a></li>
<li><a href="http://www.blogjava.net/19851985lili/OtherPosts.html" target="_blank">我的参与</a></li>
<li><a href="http://www.blogjava.net/19851985lili/RecentComments.html" target="_blank">最新评论</a></li>
</ul>
<h3 id="-3-">留言簿(3)</h3>
<ul>
<li><a href="http://www.blogjava.net/19851985lili/Contact.aspx?id=1" target="_blank">给我留言</a></li>
<li><a href="http://www.blogjava.net/19851985lili/default.aspx?opt=msg" target="_blank">查看公开留言</a></li>
<li><a href="http://www.blogjava.net/19851985lili/admin/MyMessages.aspx" target="_blank">查看私人留言</a></li>
</ul>
<h1 id="-6-">随笔档案(6)</h1>
<ul>
<li><a href="http://www.blogjava.net/19851985lili/archive/2008/05.html" target="_blank">2008年5月 (1)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/archive/2007/05.html" target="_blank">2007年5月 (1)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/archive/2007/04.html" target="_blank">2007年4月 (2)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/archive/2007/02.html" target="_blank">2007年2月 (1)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/archive/2007/01.html" target="_blank">2007年1月 (1)</a></li>
</ul>
<h1 id="-188-">文章分类(188)</h1>
<ul>
<li><a href="http://www.blogjava.net/19851985lili/category/27256.html" target="_blank">Canada (Independent Skilled Worker)(2)</a><a href="http://www.blogjava.net/19851985lili/category/27256.html/rss" title="Subscribe to Canada (Independent Skilled Worker)(2)" target="_blank"><img src="&quot;Subscribe to Canada (Independent Skilled Worker" alt="">(2)&quot;)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/category/26726.html" target="_blank">EJB3.0(4)</a><a href="http://www.blogjava.net/19851985lili/category/26726.html/rss" title="Subscribe to EJB3.0(4)" target="_blank"><img src="&quot;Subscribe to EJB3.0(4" alt="">&quot;)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/category/19161.html" target="_blank">flex2.0(40)</a><a href="http://www.blogjava.net/19851985lili/category/19161.html/rss" title="Subscribe to flex2.0(40)" target="_blank"><img src="&quot;Subscribe to flex2.0(40" alt="">&quot;)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/category/19815.html" target="_blank">flex2Cairngorm(6)</a><a href="http://www.blogjava.net/19851985lili/category/19815.html/rss" title="Subscribe to flex2Cairngorm(6)" target="_blank"><img src="&quot;Subscribe to flex2Cairngorm(6" alt="">&quot;)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/category/18358.html" target="_blank">hibernate(17)</a><a href="http://www.blogjava.net/19851985lili/category/18358.html/rss" title="Subscribe to hibernate(17)" target="_blank"><img src="&quot;Subscribe to hibernate(17" alt="">&quot;)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/category/19706.html" target="_blank">java_code(7)</a><a href="http://www.blogjava.net/19851985lili/category/19706.html/rss" title="Subscribe to java_code(7)" target="_blank"><img src="&quot;Subscribe to java_code(7" alt="">&quot;)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/category/18943.html" target="_blank">JavaBasic(15)</a><a href="http://www.blogjava.net/19851985lili/category/18943.html/rss" title="Subscribe to JavaBasic(15)" target="_blank"><img src="&quot;Subscribe to JavaBasic(15" alt="">&quot;)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/category/18368.html" target="_blank">JAVAEE(20)</a><a href="http://www.blogjava.net/19851985lili/category/18368.html/rss" title="Subscribe to JAVAEE(20)" target="_blank"><img src="&quot;Subscribe to JAVAEE(20" alt="">&quot;)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/category/19705.html" target="_blank">javamail(4)</a><a href="http://www.blogjava.net/19851985lili/category/19705.html/rss" title="Subscribe to javamail(4)" target="_blank"><img src="&quot;Subscribe to javamail(4" alt="">&quot;)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/category/18934.html" target="_blank">Log4j(8)</a><a href="http://www.blogjava.net/19851985lili/category/18934.html/rss" title="Subscribe to Log4j(8)" target="_blank"><img src="&quot;Subscribe to Log4j(8" alt="">&quot;)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/category/22482.html" target="_blank">meshwork(1)</a><a href="http://www.blogjava.net/19851985lili/category/22482.html/rss" title="Subscribe to meshwork(1)" target="_blank"><img src="&quot;Subscribe to meshwork(1" alt="">&quot;)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/category/20441.html" target="_blank">ORACLE(13)</a><a href="http://www.blogjava.net/19851985lili/category/20441.html/rss" title="Subscribe to ORACLE(13)" target="_blank"><img src="&quot;Subscribe to ORACLE(13" alt="">&quot;)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/category/19306.html" target="_blank">server(5)</a><a href="http://www.blogjava.net/19851985lili/category/19306.html/rss" title="Subscribe to server(5)" target="_blank"><img src="&quot;Subscribe to server(5" alt="">&quot;)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/category/18359.html" target="_blank">Spring(6)</a><a href="http://www.blogjava.net/19851985lili/category/18359.html/rss" title="Subscribe to Spring(6)" target="_blank"><img src="&quot;Subscribe to Spring(6" alt="">&quot;)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/category/18360.html" target="_blank">struts(8)</a><a href="http://www.blogjava.net/19851985lili/category/18360.html/rss" title="Subscribe to struts(8)" target="_blank"><img src="&quot;Subscribe to struts(8" alt="">&quot;)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/category/20166.html" target="_blank">Sun_Solaris(11)</a><a href="http://www.blogjava.net/19851985lili/category/20166.html/rss" title="Subscribe to Sun_Solaris(11)" target="_blank"><img src="&quot;Subscribe to Sun_Solaris(11" alt="">&quot;)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/category/19127.html" target="_blank">Tomcat(2)</a><a href="http://www.blogjava.net/19851985lili/category/19127.html/rss" title="Subscribe to Tomcat(2)" target="_blank"><img src="&quot;Subscribe to Tomcat(2" alt="">&quot;)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/category/20208.html" target="_blank">UML(2)</a><a href="http://www.blogjava.net/19851985lili/category/20208.html/rss" title="Subscribe to UML(2)" target="_blank"><img src="&quot;Subscribe to UML(2" alt="">&quot;)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/category/19707.html" target="_blank">Vmware(2)</a><a href="http://www.blogjava.net/19851985lili/category/19707.html/rss" title="Subscribe to Vmware(2)" target="_blank"><img src="&quot;Subscribe to Vmware(2" alt="">&quot;)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/category/20445.html" target="_blank">VSS(2)</a><a href="http://www.blogjava.net/19851985lili/category/20445.html/rss" title="Subscribe to VSS(2)" target="_blank"><img src="&quot;Subscribe to VSS(2" alt="">&quot;)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/category/19285.html" target="_blank">webotx(5)</a><a href="http://www.blogjava.net/19851985lili/category/19285.html/rss" title="Subscribe to webotx(5)" target="_blank"><img src="&quot;Subscribe to webotx(5" alt="">&quot;)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/category/21579.html" target="_blank">Windows x(3)</a><a href="http://www.blogjava.net/19851985lili/category/21579.html/rss" title="Subscribe to Windows x(3)" target="_blank"><img src="&quot;Subscribe to Windows x(3" alt="">&quot;)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/category/19189.html" target="_blank">常用正则表达式 (5)</a><a href="http://www.blogjava.net/19851985lili/category/19189.html/rss" title="Subscribe to 常用正则表达式 (5)" target="_blank"><img src="&quot;Subscribe to 常用正则表达式 (5" alt="">&quot;)</a></li>
</ul>
<h1 id="-206-">文章档案(206)</h1>
<ul>
<li><a href="http://www.blogjava.net/19851985lili/archives/2008/05.html" target="_blank">2008年5月 (10)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/archives/2007/11.html" target="_blank">2007年11月 (2)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/archives/2007/10.html" target="_blank">2007年10月 (4)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/archives/2007/06.html" target="_blank">2007年6月 (5)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/archives/2007/05.html" target="_blank">2007年5月 (21)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/archives/2007/04.html" target="_blank">2007年4月 (33)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/archives/2007/03.html" target="_blank">2007年3月 (10)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/archives/2007/02.html" target="_blank">2007年2月 (58)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/archives/2007/01.html" target="_blank">2007年1月 (63)</a></li>
</ul>
<h1 id="url">URL</h1>
<ul>
<li><a href="http://www.w3school.com.cn/index.html" target="_blank">Web 技术教程</a><a href="http://www.w3school.com.cn/index.html" title="Subscribe to Web 技术教程" target="_blank"><img src="&quot;Subscribe to Web 技术教程&quot;" alt=""></a></li>
<li><a href="http://www.forbeschina.com/cmslive/index.jsp" target="_blank">福布斯中文版</a><a href="http://www.forbeschina.com/cmslive/index.jsp" title="Subscribe to 福布斯中文版" target="_blank"><img src="&quot;Subscribe to 福布斯中文版&quot;" alt=""></a></li>
<li><a href="http://rt.openfoundry.org/Foundry/" target="_blank">自由软体铸造场</a><a href="http://rt.openfoundry.org/Foundry/" title="Subscribe to 自由软体铸造场" target="_blank"><img src="&quot;Subscribe to 自由软体铸造场&quot;" alt=""></a></li>
<li><a href="http://caterpillar.onlyfun.net/GossipCN/index.html" target="_blank">良葛格学习笔记</a><a href="http://caterpillar.onlyfun.net/GossipCN/index.html" title="Subscribe to 良葛格学习笔记" target="_blank"><img src="&quot;Subscribe to 良葛格学习笔记&quot;" alt=""></a></li>
</ul>
<h3 id="-">搜索</h3>
<p>*</p>
<ul>
<li></li>
</ul>
<h3 id="-http-www-blogjava-net-19851985lili-commentsrss-aspx-">最新评论 <a href="http://www.blogjava.net/19851985lili/CommentsRSS.aspx" target="_blank"><img src="" alt=""></a></h3>
<ul>
<li><a href="http://www.blogjava.net/19851985lili/archive/2012/08/27/98475.html#386372" target="_blank">1. re: 研究一下springside的核心部分源代码</a></li>
<li><a href="http://www.easy518.com/" target="_blank"><a href="http://www.easy518.com">http://www.easy518.com</a></a></li>
<li>--美丽说</li>
<li><a href="http://www.blogjava.net/19851985lili/archive/2012/06/08/154836.html#380302" target="_blank">2. re: EJB 简介</a></li>
<li>垃圾</li>
<li>--fff</li>
<li><a href="http://www.blogjava.net/19851985lili/archive/2011/12/27/93705.html#367319" target="_blank">3. webotx https 如何配置</a></li>
<li>你好，请问WebOTX如何配置https服务呢？
如果可以，在线等哦。 谢谢。。。。</li>
<li>--janson</li>
<li><a href="http://www.blogjava.net/19851985lili/archive/2010/11/22/97631.html#338704" target="_blank">4. 你好</a></li>
<li>长须鲸努力掉书袋事故 GUDDSUDUSADSIAUDSFYDIDFSLIFAFSDYIO8YFDOS</li>
<li>--余风好</li>
<li><a href="http://www.blogjava.net/19851985lili/archive/2010/06/08/97622.html#323049" target="_blank">5. re: Flex2 发现之旅：AS3中新的XML处理方法 - E4X</a></li>
<li>不知道为什么，如果使用item.title访问title节点的话，返回是空的</li>
</ul>
<hr>
<p>这个跟返回的XML的namespace有关。</p>
<ul>
<li>--kennethpoon</li>
</ul>
<h3 id="-">阅读排行榜</h3>
<ul>
<li><a href="http://www.blogjava.net/19851985lili/archive/2007/02/06/98199.html" target="_blank">1. explorer.exe文件损坏，如何修复(12012)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/archive/2007/05/23/119380.html" target="_blank">2. 如何解决cmd.exe占CPU资源100%问题(560)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/archive/2007/04/13/110320.html" target="_blank">3. 亲情之歌(346)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/archive/2007/01/03/91573.html" target="_blank">4. 数码相机的原理(336)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/archive/2008/05/29/203793.html" target="_blank">5. 防止IE被黑的技巧(318)</a></li>
</ul>
<h3 id="-">评论排行榜</h3>
<ul>
<li><a href="http://www.blogjava.net/19851985lili/archive/2007/02/06/98199.html" target="_blank">1. explorer.exe文件损坏，如何修复(1)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/archive/2007/01/03/91573.html" target="_blank">2. 数码相机的原理(0)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/archive/2008/05/29/203793.html" target="_blank">3. 防止IE被黑的技巧(0)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/archive/2007/05/23/119380.html" target="_blank">4. 如何解决cmd.exe占CPU资源100%问题(0)</a></li>
<li><a href="http://www.blogjava.net/19851985lili/archive/2007/04/13/110320.html" target="_blank">5. 亲情之歌(0)</a></li>
</ul>
<p><a href="http://www.blogjava.net/19851985lili/articles/93524.html" target="_blank">Java NIO API详解</a></p>
<p>NIO API 主要集中在 java.nio 和它的 subpackages 中：</p>
<p>java.nio</p>
<p>定义了 Buffer 及其数据类型相关的子类。其中被 java.nio.channels 中的类用来进行 IO 操作的 ByteBuffer 的作用非常重要。</p>
<p>java.nio.channels</p>
<p>定义了一系列处理 IO 的 Channel 接口以及这些接口在文件系统和网络通讯上的实现。通过 Selector 这个类，还提供了进行非阻塞 IO 操作的办法。这个包可以说是 NIO API 的核心。</p>
<p>java.nio.channels.spi</p>
<p>定义了可用来实现 channel 和 selector API 的抽象类。</p>
<p>java.nio.charset</p>
<pre><code>     定义了处理字符编码和解码的类。
</code></pre><p>java.nio.charset.spi</p>
<pre><code>     定义了可用来实现 charset API 的抽象类。
</code></pre><p>java.nio.channels.spi 和 java.nio.charset.spi 这两个包主要被用来对现有 NIO API 进行扩展，在实际的使用中，我们一般只和另外的 3 个包打交道。下面将对这 3 个包一一介绍。</p>
<p>Package java.nio</p>
<p>这个包主要定义了 Buffer 及其子类。 Buffer 定义了一个线性存放 primitive type 数据的容器接口。对于除 boolean 以外的其他 primitive type ，都有一个相应的 Buffer 子类， ByteBuffer 是其中最重要的一个子类。</p>
<p>下面这张 UML 类图描述了 java.nio 中的类的关系：</p>
<p><img src="" alt=""></p>
<p><strong>Buffer</strong></p>
<p>定义了一个可以线性存放 primitive type 数据的容器接口。 Buffer 主要包含了与类型（ byte, char… ）无关的功能。值得注意的是 Buffer 及其子类都不是线程安全的。</p>
<p>每个 Buffer 都有以下的属性：</p>
<p>capacity</p>
<p>这个 Buffer 最多能放多少数据。 capacity 一般在 buffer 被创建的时候指定。</p>
<p>limit</p>
<p>在 Buffer 上进行的读写操作都不能越过这个下标。当写数据到 buffer 中时， limit 一般和 capacity 相等，当读数据时， limit 代表 buffer 中有效数据的长度。</p>
<p>position</p>
<p>读 / 写操作的当前下标。当使用 buffer 的相对位置进行读 / 写操作时，读 / 写会从这个下标进行，并在操作完成后， buffer 会更新下标的值。</p>
<p>mark</p>
<p>一个临时存放的位置下标。调用 mark() 会将 mark 设为当前的 position 的值，以后调用 reset() 会将 position 属性设置为 mark 的值。 mark 的值总是小于等于 position 的值，如果将 position 的值设的比 mark 小，当前的 mark 值会被抛弃掉。</p>
<p>这些属性总是满足以下条件：</p>
<p>0 &lt;= mark &lt;= position &lt;= limit &lt;= capacity</p>
<p>limit 和 position 的值除了通过 limit() 和 position() 函数来设置，也可以通过下面这些函数来改变：</p>
<p>Buffer clear()</p>
<p>把 position 设为 0 ，把 limit 设为 capacity ，一般在把数据写入 Buffer 前调用。</p>
<p>Buffer flip()</p>
<p>把 limit 设为当前 position ，把 position 设为 0 ，一般在从 Buffer 读出数据前调用。</p>
<p>Buffer rewind()</p>
<p>把 position 设为 0 ， limit 不变，一般在把数据重写入 Buffer 前调用。</p>
<p>Buffer 对象有可能是只读的，这时，任何对该对象的写操作都会触发一个 ReadOnlyBufferException 。 isReadOnly() 方法可以用来判断一个 Buffer 是否只读。</p>
<p><strong>ByteBuffer</strong></p>
<p>在 Buffer 的子类中， ByteBuffer 是一个地位较为特殊的类，因为在 java.io.channels 中定义的各种 channel 的 IO 操作基本上都是围绕 ByteBuffer 展开的。</p>
<p>ByteBuffer 定义了 4 个 static 方法来做创建工作：</p>
<p>ByteBuffer allocate(int capacity)</p>
<p>创建一个指定 capacity 的 ByteBuffer 。</p>
<p>ByteBuffer allocateDirect(int capacity)</p>
<p>创建一个 direct 的 ByteBuffer ，这样的 ByteBuffer 在参与 IO 操作时性能会更好（很有可能是在底层的实现使用了 DMA 技术），相应的，创建和回收 direct 的 ByteBuffer 的代价也会高一些。 isDirect() 方法可以检查一个 buffer 是否是 direct 的。</p>
<p>ByteBuffer wrap(byte [] array)</p>
<p>ByteBuffer wrap(byte [] array, int offset, int length)</p>
<p>把一个 byte 数组或 byte 数组的一部分包装成 ByteBuffer 。</p>
<p>ByteBuffer 定义了一系列 get 和 put 操作来从中读写 byte 数据，如下面几个：</p>
<p>byte get()</p>
<p>ByteBuffer get(byte [] dst)</p>
<p>byte get(int index)</p>
<p>ByteBuffer put(byte b)</p>
<p>ByteBuffer put(byte [] src)</p>
<p>ByteBuffer put(int index, byte b)</p>
<p>这些操作可分为绝对定位和相对定为两种，相对定位的读写操作依靠 position 来定位 Buffer 中的位置，并在操作完成后会更新 position 的值。</p>
<p>在其它类型的 buffer 中，也定义了相同的函数来读写数据，唯一不同的就是一些参数和返回值的类型。</p>
<p>除了读写 byte 类型数据的函数， ByteBuffer 的一个特别之处是它还定义了读写其它 primitive 数据的方法，如：</p>
<p>int getInt()</p>
<pre><code>     从 ByteBuffer 中读出一个 int 值。
</code></pre><p>ByteBuffer putInt(int value)</p>
<pre><code>     写入一个 int 值到 ByteBuffer 中。
</code></pre><p>读写其它类型的数据牵涉到字节序问题， ByteBuffer 会按其字节序（大字节序或小字节序）写入或读出一个其它类型的数据（ int,long… ）。字节序可以用 order 方法来取得和设置：</p>
<p>ByteOrder order()</p>
<pre><code>     返回 ByteBuffer 的字节序。
</code></pre><p>ByteBuffer order(ByteOrder bo)</p>
<pre><code>     设置 ByteBuffer 的字节序。
</code></pre><p>ByteBuffer 另一个特别的地方是可以在它的基础上得到其它类型的 buffer 。如：</p>
<p>CharBuffer asCharBuffer()</p>
<p>为当前的 ByteBuffer 创建一个 CharBuffer 的视图。在该视图 buffer 中的读写操作会按照 ByteBuffer 的字节序作用到 ByteBuffer 中的数据上。</p>
<p>用这类方法创建出来的 buffer 会从 ByteBuffer 的 position 位置开始到 limit 位置结束，可以看作是这段数据的视图。视图 buffer 的 readOnly 属性和 direct 属性与 ByteBuffer 的一致，而且也只有通过这种方法，才可以得到其他数据类型的 direct buffer 。</p>
<p><strong>ByteOrder</strong></p>
<p>用来表示 ByteBuffer 字节序的类，可将其看成 java 中的 enum 类型。主要定义了下面几个 static 方法和属性：</p>
<p>ByteOrder BIG_ENDIAN</p>
<pre><code>     代表大字节序的 ByteOrder 。
</code></pre><p>ByteOrder LITTLE_ENDIAN</p>
<pre><code>     代表小字节序的 ByteOrder 。
</code></pre><p>ByteOrder nativeOrder()</p>
<pre><code>     返回当前硬件平台的字节序。
</code></pre><p><strong>MappedByteBuffer</strong></p>
<p>ByteBuffer 的子类，是文件内容在内存中的映射。这个类的实例需要通过 FileChannel 的 map() 方法来创建。</p>
<p>接下来看看一个使用 ByteBuffer 的例子，这个例子从标准输入不停地读入字符，当读满一行后，将收集的字符写到标准输出：</p>
<pre><code> **public** **static** **void** main(String [] args)

    **throws** IOException

 {

    //   创建一个 capacity 为 256 的 ByteBuffer

    ByteBuffer buf = ByteBuffer.allocate(256);

    **while** ( **true** ) {

        //   从标准输入流读入一个字符

        **int** c = System.in.read();

        //   当读到输入流结束时，退出循环

        **if** (c == -1)

           **break** ;



        //   把读入的字符写入 ByteBuffer 中

        buf.put(( **byte** ) c);

        //   当读完一行时，输出收集的字符

        **if** (c == &#39;\n&#39; ) {

           //   调用 flip() 使 limit 变为当前的 position 的值 ,position 变为 0,

           //   为接下来从 ByteBuffer 读取做准备

           buf.flip();

           //   构建一个 byte 数组

           **byte** [] content = **new** **byte** [buf.limit()];

           //   从 ByteBuffer 中读取数据到 byte 数组中

           buf.get(content);

             //   把 byte 数组的内容写到标准输出

           System.out.print( **new** String(content));

           //   调用 clear() 使 position 变为 0,limit 变为 capacity 的值，

           //   为接下来写入数据到 ByteBuffer 中做准备

           buf.clear();

        }

    }

 }
</code></pre><p>Package java.nio.channels</p>
<p>这个包定义了 Channel 的概念， Channel 表现了一个可以进行 IO 操作的通道（比如，通过 FileChannel ，我们可以对文件进行读写操作）。 java.nio.channels 包含了文件系统和网络通讯相关的 channel 类。这个包通过 Selector 和 SelectableChannel 这两个类，还定义了一个进行非阻塞（ non-blocking ） IO 操作的 API ，这对需要高性能 IO 的应用非常重要。</p>
<p>下面这张 UML 类图描述了 java.nio.channels 中 interface 的关系：</p>
<p><img src="" alt=""></p>
<p><strong>Channel</strong></p>
<p>Channel 表现了一个可以进行 IO 操作的通道，该 interface 定义了以下方法：</p>
<p>boolean isOpen()</p>
<pre><code>     该 Channel 是否是打开的。
</code></pre><p>void close()</p>
<pre><code>     关闭这个 Channel ，相关的资源会被释放。
</code></pre><p><strong>ReadableByteChannel</strong></p>
<p>定义了一个可从中读取 byte 数据的 channel interface 。</p>
<p>int read(ByteBuffer dst)</p>
<p>从 channel 中读取 byte 数据并写到 ByteBuffer 中。返回读取的 byte 数。</p>
<p><strong>WritableByteChannel</strong></p>
<p>定义了一个可向其写 byte 数据的 channel interface 。</p>
<p>int write(ByteBuffer src)</p>
<pre><code>     从 ByteBuffer 中读取 byte 数据并写到 channel 中。返回写出的 byte 数。
</code></pre><p><strong>ByteChannel</strong></p>
<p>ByteChannel 并没有定义新的方法，它的作用只是把 ReadableByteChannel 和 WritableByteChannel 合并在一起。</p>
<p><strong>ScatteringByteChannel</strong></p>
<p>继承了 ReadableByteChannel 并提供了同时往几个 ByteBuffer 中写数据的能力。</p>
<p><strong>GatheringByteChannel</strong></p>
<p>继承了 WritableByteChannel 并提供了同时从几个 ByteBuffer 中读数据的能力。</p>
<p><strong>InterruptibleChannel</strong></p>
<p>用来表现一个可以被异步关闭的 Channel 。这表现在两方面：</p>
<p>1．     当一个 InterruptibleChannel 的 close() 方法被调用时，其它 block 在这个 InterruptibleChannel 的 IO 操作上的线程会接收到一个 AsynchronousCloseException 。</p>
<p>2．     当一个线程 block 在 InterruptibleChannel 的 IO 操作上时，另一个线程调用该线程的 interrupt() 方法会导致 channel 被关闭，该线程收到一个 ClosedByInterruptException ，同时线程的 interrupt 状态会被设置。</p>
<p>接下来的这张 UML 类图描述了 java.nio.channels 中类的关系：</p>
<p><img src="" alt=""></p>
<p><strong>非阻塞 IO</strong></p>
<p>非阻塞 IO 的支持可以算是 NIO API 中最重要的功能，非阻塞 IO 允许应用程序同时监控多个 channel 以提高性能，这一功能是通过 Selector ， SelectableChannel 和 SelectionKey 这 3 个类来实现的。</p>
<p>SelectableChannel 代表了可以支持非阻塞 IO 操作的 channel ，可以将其注册在 Selector 上，这种注册的关系由 SelectionKey 这个类来表现（见 UML 图）。 Selector 这个类通过 select() 函数，给应用程序提供了一个可以同时监控多个 IO channel 的方法：</p>
<p>应用程序通过调用 select() 函数，让 Selector 监控注册在其上的多个 SelectableChannel ，当有 channel 的 IO 操作可以进行时， select() 方法就会返回以让应用程序检查 channel 的状态，并作相应的处理。</p>
<p>下面是 JDK 1.4 中非阻塞 IO 的一个例子，这段 code 使用了非阻塞 IO 实现了一个 time server ：</p>
<pre><code> **private** **static** **void** acceptConnections( **int** port) **throws** Exception {

    //   打开一个 Selector

    Selector acceptSelector =

        SelectorProvider.provider().openSelector();



    //   创建一个 ServerSocketChannel ，这是一个 SelectableChannel 的子类

    ServerSocketChannel ssc = ServerSocketChannel.open();

    //   将其设为 non-blocking 状态，这样才能进行非阻塞 IO 操作

    ssc.configureBlocking( **false** );



    //   给 ServerSocketChannel 对应的 socket 绑定 IP 和端口

    InetAddress lh = InetAddress.getLocalHost();

    InetSocketAddress isa = **new** InetSocketAddress(lh, port);

    ssc.socket().bind(isa);



    //   将 ServerSocketChannel 注册到 Selector 上，返回对应的 SelectionKey

    SelectionKey acceptKey =

        ssc.register(acceptSelector, SelectionKey.OP_ACCEPT);



    **int** keysAdded = 0;



    //   用 select() 函数来监控注册在 Selector 上的 SelectableChannel

    //   返回值代表了有多少 channel 可以进行 IO 操作  (ready for IO)

    **while** ((keysAdded = acceptSelector.select()) &gt; 0) {

        // selectedKeys()  返回一个 SelectionKey 的集合，

        //   其中每个 SelectionKey 代表了一个可以进行 IO 操作的 channel 。

        //   一个 ServerSocketChannel 可以进行 IO 操作意味着有新的 TCP 连接连入了

        Set readyKeys = acceptSelector.selectedKeys();

        Iterator i = readyKeys.iterator();



        **while** (i.hasNext()) {

           SelectionKey sk = (SelectionKey) i.next();

           //   需要将处理过的 key 从 selectedKeys 这个集合中删除

           i.remove();

           //   从 SelectionKey 得到对应的 channel

           ServerSocketChannel nextReady =

               (ServerSocketChannel) sk.channel();

           //   接受新的 TCP 连接

           Socket s = nextReady.accept().socket();

           //   把当前的时间写到这个新的 TCP 连接中

           PrintWriter out =

               **new** PrintWriter(s.getOutputStream(), **true** );

           Date now = **new** Date();

           out.println(now);

           //   关闭连接

           out.close();

        }

    }

 }
</code></pre><p>这是个纯粹用于演示的例子，因为只有一个 ServerSocketChannel 需要监控，所以其实并不真的需要使用到非阻塞 IO 。不过正因为它的简单，可以很容易地看清楚非阻塞 IO 是如何工作的。</p>
<p><strong>SelectableChannel</strong></p>
<p>这个抽象类是所有支持非阻塞 IO 操作的 channel （如 DatagramChannel 、 SocketChannel ）的父类。 SelectableChannel 可以注册到一个或多个 Selector 上以进行非阻塞 IO 操作。</p>
<p>SelectableChannel 可以是 blocking 和 non-blocking 模式（所有 channel 创建的时候都是 blocking 模式），只有 non-blocking 的 SelectableChannel 才可以参与非阻塞 IO 操作。</p>
<p>SelectableChannel configureBlocking(boolean block)</p>
<pre><code>     设置 blocking 模式。
</code></pre><p>boolean isBlocking()</p>
<pre><code>     返回 blocking 模式。
</code></pre><p>通过 register() 方法， SelectableChannel 可以注册到 Selector 上。</p>
<p>int validOps()</p>
<p>返回一个 bit mask ，表示这个 channel 上支持的 IO 操作。当前在 SelectionKey 中，用静态常量定义了 4 种 IO 操作的 bit 值： OP_ACCEPT ， OP_CONNECT ， OP_READ 和 OP_WRITE 。</p>
<p>SelectionKey register(Selector sel, int ops)</p>
<p>将当前 channel 注册到一个 Selector 上并返回对应的 SelectionKey 。在这以后，通过调用 Selector 的 select() 函数就可以监控这个 channel 。 ops 这个参数是一个 bit mask ，代表了需要监控的 IO 操作。</p>
<p>SelectionKey register(Selector sel, int ops, Object att)</p>
<p>这个函数和上一个的意义一样，多出来的 att 参数会作为 attachment 被存放在返回的 SelectionKey 中，这在需要存放一些 session state 的时候非常有用。</p>
<p>boolean isRegistered()</p>
<pre><code>     该 channel 是否已注册在一个或多个 Selector 上。
</code></pre><p>SelectableChannel 还提供了得到对应 SelectionKey 的方法：</p>
<p>SelectionKey keyFor(Selector sel)</p>
<p>返回该 channe 在 Selector 上的注册关系所对应的 SelectionKey 。若无注册关系，返回 null 。</p>
<p><strong>Selector</strong></p>
<p>Selector 可以同时监控多个 SelectableChannel 的 IO 状况，是非阻塞 IO 的核心。</p>
<p>Selector open()</p>
<pre><code>   Selector 的一个静态方法，用于创建实例。
</code></pre><p>在一个 Selector 中，有 3 个 SelectionKey 的集合：</p>
<p>1． key set 代表了所有注册在这个 Selector 上的 channel ，这个集合可以通过 keys() 方法拿到。</p>
<p>2． Selected-key set 代表了所有通过 select() 方法监测到可以进行 IO 操作的 channel ，这个集合可以通过 selectedKeys() 拿到。</p>
<p>3． Cancelled-key set 代表了已经 cancel 了注册关系的 channel ，在下一个 select() 操作中，这些 channel 对应的 SelectionKey 会从 key set 和 cancelled-key set 中移走。这个集合无法直接访问。</p>
<p>以下是 select() 相关方法的说明：</p>
<p>int select()</p>
<p>监控所有注册的 channel ，当其中有注册的 IO 操作可以进行时，该函数返回，并将对应的 SelectionKey 加入 selected-key set 。</p>
<p>int select(long timeout)</p>
<pre><code>     可以设置超时的 select() 操作。
</code></pre><p>int selectNow()</p>
<pre><code>     进行一个立即返回的 select() 操作。
</code></pre><p>Selector wakeup()</p>
<pre><code>     使一个还未返回的 select() 操作立刻返回。
</code></pre><p><strong>SelectionKey</strong></p>
<p>代表了 Selector 和 SelectableChannel 的注册关系。</p>
<p>Selector 定义了 4 个静态常量来表示 4 种 IO 操作，这些常量可以进行位操作组合成一个 bit mask 。</p>
<p>int OP_ACCEPT</p>
<p>有新的网络连接可以 accept ， ServerSocketChannel 支持这一非阻塞 IO 。</p>
<p>int OP_CONNECT</p>
<pre><code>     代表连接已经建立（或出错）， SocketChannel 支持这一非阻塞 IO 。
</code></pre><p>int OP_READ</p>
<p>int OP_WRITE</p>
<pre><code>     代表了读、写操作。
</code></pre><p>以下是其主要方法：</p>
<p>Object attachment()</p>
<p>返回 SelectionKey 的 attachment ， attachment 可以在注册 channel 的时候指定。</p>
<p>Object attach(Object ob)</p>
<pre><code>     设置 SelectionKey 的 attachment 。
</code></pre><p>SelectableChannel channel()</p>
<pre><code>     返回该 SelectionKey 对应的 channel 。
</code></pre><p>Selector selector()</p>
<pre><code>     返回该 SelectionKey 对应的 Selector 。
</code></pre><p>void cancel()</p>
<pre><code>   cancel 这个 SelectionKey 所对应的注册关系。
</code></pre><p>int interestOps()</p>
<pre><code>     返回代表需要 Selector 监控的 IO 操作的 bit mask 。
</code></pre><p>SelectionKey interestOps(int ops)</p>
<pre><code>     设置 interestOps 。
</code></pre><p>int readyOps()</p>
<pre><code>     返回一个 bit mask ，代表在相应 channel 上可以进行的 IO 操作。
</code></pre><p><strong>ServerSocketChannel</strong></p>
<p>支持非阻塞操作，对应于 java.net.ServerSocket 这个类，提供了 TCP 协议 IO 接口，支持 OP_ACCEPT 操作。</p>
<p>ServerSocket socket()</p>
<pre><code>     返回对应的 ServerSocket 对象。
</code></pre><p>SocketChannel accept()</p>
<pre><code>     接受一个连接，返回代表这个连接的 SocketChannel 对象。
</code></pre><p><strong>SocketChannel</strong></p>
<p>支持非阻塞操作，对应于 java.net.Socket 这个类，提供了 TCP 协议 IO 接口，支持 OP_CONNECT ， OP_READ 和 OP_WRITE 操作。这个类还实现了 ByteChannel ， ScatteringByteChannel 和 GatheringByteChannel 接口。</p>
<p>DatagramChannel 和这个类比较相似，其对应于 java.net.DatagramSocket ，提供了 UDP 协议 IO 接口。</p>
<p>Socket socket()</p>
<pre><code>     返回对应的 Socket 对象。
</code></pre><p>boolean connect(SocketAddress remote)</p>
<p>boolean finishConnect()</p>
<p>connect() 进行一个连接操作。如果当前 SocketChannel 是 blocking 模式，这个函数会等到连接操作完成或错误发生才返回。如果当前 SocketChannel 是 non-blocking 模式，函数在连接能立刻被建立时返回 true ，否则函数返回 false ，应用程序需要在以后用 finishConnect() 方法来完成连接操作。</p>
<p><strong>Pipe</strong></p>
<p>包含了一个读和一个写的 channel(Pipe.SourceChannel 和 Pipe.SinkChannel) ，这对 channel 可以用于进程中的通讯。</p>
<p><strong>FileChannel</strong></p>
<p>用于对文件的读、写、映射、锁定等操作。和映射操作相关的类有 FileChannel.MapMode ，和锁定操作相关的类有 FileLock 。值得注意的是 FileChannel 并不支持非阻塞操作。</p>
<p><strong>Channels</strong></p>
<p>这个类提供了一系列 static 方法来支持 stream 类和 channel 类之间的互操作。这些方法可以将 channel 类包装为 stream 类，比如，将 ReadableByteChannel 包装为 InputStream 或 Reader ；也可以将 stream 类包装为 channel 类，比如，将 OutputStream 包装为 WritableByteChannel 。</p>
<p>Package java.nio.charset</p>
<p>这个包定义了 Charset 及相应的 encoder 和 decoder 。下面这张 UML 类图描述了这个包中类的关系，可以将其中 Charset ， CharsetDecoder 和 CharsetEncoder 理解成一个 Abstract Factory 模式的实现：</p>
<p><img src="" alt=""></p>
<p><strong>Charset</strong></p>
<p>代表了一个字符集，同时提供了 factory method 来构建相应的 CharsetDecoder 和 CharsetEncoder 。</p>
<p>Charset 提供了以下 static 的方法：</p>
<p>SortedMap availableCharsets()</p>
<pre><code>     返回当前系统支持的所有 Charset 对象，用 charset 的名字作为 set 的 key 。
</code></pre><p>boolean isSupported(String charsetName)</p>
<pre><code>     判断该名字对应的字符集是否被当前系统支持。
</code></pre><p>Charset forName(String charsetName)</p>
<pre><code>     返回该名字对应的 Charset 对象。
</code></pre><p>Charset 中比较重要的方法有：</p>
<p>String name()</p>
<pre><code>     返回该字符集的规范名。
</code></pre><p>Set aliases()</p>
<pre><code>     返回该字符集的所有别名。
</code></pre><p>CharsetDecoder newDecoder()</p>
<pre><code>     创建一个对应于这个 Charset 的 decoder 。
</code></pre><p>CharsetEncoder newEncoder()</p>
<pre><code>     创建一个对应于这个 Charset 的 encoder 。
</code></pre><p><strong>CharsetDecoder</strong></p>
<p>将按某种字符集编码的字节流解码为 unicode 字符数据的引擎。</p>
<p>CharsetDecoder 的输入是 ByteBuffer ，输出是 CharBuffer 。进行 decode 操作时一般按如下步骤进行：</p>
<p>1． 调用 CharsetDecoder 的 reset() 方法。（第一次使用时可不调用）</p>
<p>2． 调用 decode() 方法 0 到 n 次，将 endOfInput 参数设为 false ，告诉 decoder 有可能还有新的数据送入。</p>
<p>3． 调用 decode() 方法最后一次，将 endOfInput 参数设为 true ，告诉 decoder 所有数据都已经送入。</p>
<p>4． 调用 decoder 的 flush() 方法。让 decoder 有机会把一些内部状态写到输出的 CharBuffer 中。</p>
<p>CharsetDecoder reset()</p>
<pre><code>     重置 decoder ，并清除 decoder 中的一些内部状态。
</code></pre><p>CoderResult decode(ByteBuffer in, CharBuffer out, boolean endOfInput)</p>
<p>从 ByteBuffer 类型的输入中 decode 尽可能多的字节，并将结果写到 CharBuffer 类型的输出中。根据 decode 的结果，可能返回 3 种 CoderResult ： CoderResult.UNDERFLOW 表示已经没有输入可以 decode ； CoderResult.OVERFLOW 表示输出已满；其它的 CoderResult 表示 decode 过程中有错误发生。根据返回的结果，应用程序可以采取相应的措施，比如，增加输入，清除输出等等，然后再次调用 decode() 方法。</p>
<p>CoderResult flush(CharBuffer out)</p>
<p>有些 decoder 会在 decode 的过程中保留一些内部状态，调用这个方法让这些 decoder 有机会将这些内部状态写到输出的 CharBuffer 中。调用成功返回 CoderResult.UNDERFLOW 。如果输出的空间不够，该函数返回 CoderResult.OVERFLOW ，这时应用程序应该扩大输出 CharBuffer 的空间，然后再次调用该方法。</p>
<p>CharBuffer decode(ByteBuffer in)</p>
<p>一个便捷的方法把 ByteBuffer 中的内容 decode 到一个新创建的 CharBuffer 中。在这个方法中包括了前面提到的 4 个步骤，所以不能和前 3 个函数一起使用。</p>
<p>decode 过程中的错误有两种： malformed-input CoderResult 表示输入中数据有误； unmappable-character CoderResult 表示输入中有数据无法被解码成 unicode 的字符。如何处理 decode 过程中的错误取决于 decoder 的设置。对于这两种错误， decoder 可以通过 CodingErrorAction 设置成：</p>
<p>1． 忽略错误</p>
<p>2． 报告错误。（这会导致错误发生时， decode() 方法返回一个表示该错误的 CoderResult 。）</p>
<p>3． 替换错误，用 decoder 中的替换字串替换掉有错误的部分。</p>
<p>CodingErrorAction malformedInputAction()</p>
<pre><code>     返回 malformed-input 的出错处理。
</code></pre><p>CharsetDecoder onMalformedInput(CodingErrorAction newAction)</p>
<pre><code>     设置 malformed-input 的出错处理。
</code></pre><p>CodingErrorAction unmappableCharacterAction()</p>
<pre><code>     返回 unmappable-character 的出错处理。
</code></pre><p>CharsetDecoder onUnmappableCharacter(CodingErrorAction newAction)</p>
<pre><code>     设置 unmappable-character 的出错处理。
</code></pre><p>String replacement()</p>
<pre><code>     返回 decoder 的替换字串。
</code></pre><p>CharsetDecoder replaceWith(String newReplacement)</p>
<pre><code>     设置 decoder 的替换字串。
</code></pre><p><strong>CharsetEncoder</strong></p>
<p>将 unicode 字符数据编码为特定字符集的字节流的引擎。其接口和 CharsetDecoder 相类似。</p>
<p><strong>CoderResult</strong></p>
<p>描述 encode/decode 操作结果的类。</p>
<p>CodeResult 包含两个 static 成员：</p>
<p>CoderResult OVERFLOW</p>
<pre><code>     表示输出已满
</code></pre><p>CoderResult UNDERFLOW</p>
<pre><code>     表示输入已无数据可用。
</code></pre><p>其主要的成员函数有：</p>
<p>boolean isError()</p>
<p>boolean isMalformed()</p>
<p>boolean isUnmappable()</p>
<p>boolean isOverflow()</p>
<p>boolean isUnderflow()</p>
<pre><code>     用于判断该 CoderResult 描述的错误。
</code></pre><p>int length()</p>
<pre><code>     返回错误的长度，比如，无法被转换成 unicode 的字节长度。
</code></pre><p>void throwException()</p>
<pre><code>     抛出一个和这个 CoderResult 相对应的 exception 。
</code></pre><p><strong>CodingErrorAction</strong></p>
<p>表示 encoder/decoder 中错误处理方法的类。可将其看成一个 enum 类型。有以下 static 属性：</p>
<p>CodingErrorAction IGNORE</p>
<pre><code>     忽略错误。
</code></pre><p>CodingErrorAction REPLACE</p>
<pre><code>     用替换字串替换有错误的部分。
</code></pre><p>CodingErrorAction REPORT</p>
<p>报告错误，对于不同的函数，有可能是返回一个和错误有关的 CoderResult ，也有可能是抛出一个 CharacterCodingException 。
posted on 2007-01-12 20:07 <a href="http://www.blogjava.net/19851985lili/" target="_blank">☜♥☞MengChuChen</a> 阅读(6999) <a href="">评论(0)</a>  <a href="http://www.blogjava.net/19851985lili/admin/EditArticles.aspx?postid=93524" target="_blank">编辑</a>  <a href="http://www.blogjava.net/19851985lili/AddToFavorite.aspx?id=93524" target="_blank">收藏</a> <img src="" alt=""></p>
<p><a href="http://www.blogjava.net/RequireRegister.aspx" target="_blank">新用户注册</a>  <a href="">刷新评论列表</a>  </p>
<p><a href=""></a> <a href="http://www.aliyun.com/cps/channel?channel_id=1306&amp;user=0&amp;lv=1">推荐购买云服务器（15%返利+最高千元奖金）</a>   <a href="http://www.cnblogs.com/" target="_blank">博客园</a>  <a href="http://q.cnblogs.com/" target="_blank">博问</a>  <a href="http://news.cnblogs.com/" target="_blank">IT新闻</a>  <a href="http://job.cnblogs.com/cate-java_programmer/" target="_blank">Java程序员招聘</a> 标题  请输入标题 姓名  请输入你的姓名 主页 请输入验证码 验证码 /*  <img src="http://www.blogjava.net/Modules/CaptchaImage/JpegImage.aspx?cacheid=20130718160740" alt=""> 内容(请不要发表任何与政治相关的内容) 请输入评论内容 Remember Me?   <a href="http://www.blogjava.net/login.aspx?ReturnURL=http://www.blogjava.net/19851985lili/articles/93524.html&amp;SourceURL=/19851985lili/articles/93524.html" target="_blank">登录</a>       [使用Ctrl+Enter键可以直接提交]      网站导航:</p>
<p><a href="http://www.cnblogs.com/" title="程序员的网上家园" target="_blank">博客园</a>   <a href="http://news.cnblogs.com/" target="_blank">IT新闻</a>   <a href="http://kb.cnblogs.com/" target="_blank">知识库</a>   <a href="http://www.cppblog.com/" target="_blank">C++博客</a>   <a href="http://job.cnblogs.com/" target="_blank">程序员招聘</a>   <a href="http://www.blogjava.net/19851985lili/articles/93524.html?opt=admin" target="_blank">管理</a><br>Copyright ©2013 ☜♥☞MengChuChen Powered By<a href="http://www.blogjava.net/" target="_blank">博客园</a> 模板提供：<a href="http://blog.hjenglish.com/" target="_blank">沪江博客</a></p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/NIO/">NIO</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/NIO/" class="label label-success">NIO</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:41"datetime="2014-03-07 09:54:41"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-NIO--JavaNIOAPI详解/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-NIO--JavaNIOAPI详解" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>





<ul id="pagination" class="pagination pagination-lg">
  <li><a class="extend prev" href="/page/54/">&laquo;</a></li><li><a class="page-number" href="/">1</a></li><li><a class="page-number" href="/page/2/">2</a></li><li><span class="space">&hellip;</span></li><li><a class="page-number" href="/page/52/">52</a></li><li><a class="page-number" href="/page/53/">53</a></li><li><a class="page-number" href="/page/54/">54</a></li><li class="active"><li><span class="page-number current">55</span></li><li><a class="page-number" href="/page/56/">56</a></li><li><a class="page-number" href="/page/57/">57</a></li><li><a class="page-number" href="/page/58/">58</a></li><li><span class="space">&hellip;</span></li></li><li><a class="page-number" href="/page/164/">164</a></li><li><a class="page-number" href="/page/165/">165</a></li><li><a class="extend next" href="/page/56/">&raquo;</a></li>
  <div class="clearfix"></div>
</ul></div><!--wapper-->
       </div><!-- ID main-col END -->
       <aside id="sidebar" class="alignright col-sx-6 col-sm-4 col-md-3 col-lg-3">
<div id="widget_search" class="widget panel panel-primary">
    <form action="//google.com/search" method="get" accept-charset="utf-8">
  <div class="input-group">
    <input class="form-control" id="searchbox" type="search" name="q" results="0" placeholder="search">
    <span class="input-group-btn">
      <button class="btn btn-default" type="submit">Go!</button>
    </span>
    <input type="hidden" name="q" value="site:itsolife.com">
  </div>
</form>
</div>

<div id="widget_category" class="widget panel panel-primary">
  <div class="panel-heading">category</div>  <div data-src='category' class='ajax_widgets'>正在加载...</div>
</div>

<div id="widget_recent_posts" class="widget panel panel-primary">
  <div class="panel-heading">recent posts</div>  <div data-src='recent_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_tagcloud" class="widget panel panel-primary">
  <div class="panel-heading">tagcloud</div>  <div data-src='tagcloud' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_latest_update_posts" class="widget panel panel-primary">
  <div class="panel-heading">最近更新</div>  <div data-src='latest_update_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_recent_comments" class="widget panel panel-primary">
  <div class="panel-heading">recent comments</div>  

<div class="list-group-item ds-recent-comments" data-num-items="6" data-show-avatars="1" data-show-time="1" data-show-title="1" data-show-admin="1" data-excerpt-length="50"></div>



</div>

</aside>
       <div class="clearfix"></div>
     </div><!-- row END -->
  </div>
  <footer id="footer" class="container">
  <div class="panel panel-info">
  <section id='footer_widget'></section>  <div class="panel-footer">
  <div id="site-info">
    <span class='author'>
  
  &copy; 2014 RobinChia
  
    &nbsp;&nbsp;</span>
  
  <span id='analytics-51la'></span><span id='analytics-google'>
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-48559895-1']);
  _gaq.push(['_trackPageview']);
  _js2load.push({src:('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'});
</script></span><span id='analytics-cnzz'>
<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_5774006'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s17.cnzz.com/stat.php%3Fid%3D5774006%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>
</span><span id='analytics-baidu'>
<script>
var _hmt = _hmt || [];
_js2load.push({src:"//hm.baidu.com/hm.js?1442f50724afc42380b51f097c43082c"});
</script>
</span>  </div>
  <div id="copyright">Blog powered by <a href='http://zespia.tw/hexo/'><strong>hexo</strong></a> Theme <strong><a href='https://github.com/chenall/hexo-theme-chenall'>chenall</a></strong>(Some change in it)<span class="pull-right"> 更新时间: <em>2014-03-26 21:21:33</em></span></div>
</div>
<div class="clearfix"></div>


  </div>
  </footer>
  
        <script src="http://cdn.bootcss.com/jquery/1.10.2/jquery.min.js"></script>        
        <script src="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/js/bootstrap.min.js"></script>        
                
        <script src="http://cdn.bootcss.com/prettify/r298/prettify.min.js"></script>    <script type="text/javascript">
   var lang=["bsh", "c", "cc", "cpp", "cs", "csh", "cyc", "cv", "htm", "html",
    "java", "js", "m", "mxml", "perl", "pl", "pm", "py", "rb", "sh",
    "xhtml", "xml", "xsl"];
   var pretty_base='';
   $('script').each(function(){
	var c = $(this).attr('src');
	if (!c)
	    return;
	if (c.match(/(\/)?prettify(\.min)?\.js/i))
	{
	    var index = c.lastIndexOf('/');
	    if (index != -1)
		pretty_base = c.substr(0,index + 1);
	    return false;
	}
   })
   $('pre code').each(function(){
	var c = $(this).attr('class')
	if (!c)
	    return;
	c = c.match(/\s?(lang\-\w+)/i);
	if (c && lang.indexOf(c[1]) == -1)
	{
	    lang.push(c[1]);
	    $.getScript(pretty_base + c[1] + '.min.js');
	}
   })

    $(window).load(function(){
       $("pre").addClass("prettyprint");
       prettyPrint();
    })
</script>    
            <script type="text/javascript">
var duoshuoQuery = {short_name:"robinchia"};
_js2load.push({src:'http://static.duoshuo.com/embed.js',charset:'UTF-8'});
</script>
    
            <!--wumii_relatedItems-->
    
        <script src="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js"></script>    <script type="text/javascript">
(function($){
  $('.entry').each(function(i){
    $(this).find('img').each(function(){
      var alt = this.alt;

      if (alt){
        $(this).before('<span class="caption">' + alt + '</span>');
      }

      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox" rel="fancybox' + i + '" />');
    });
  });

  $('.fancybox').fancybox();
})(jQuery);
</script>    
        <script src="http://cdn.bootcss.com/mathjax/2.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>    <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>
    
<script type="text/javascript">
$('.ajax_widgets').each(function(){var src=$(this).attr('data-src');if(src)$(this).load('/widgets/'+src+'.html');});
$.each(_js2load,function(index,obj){loadjs(obj.src,obj.charset)});
</script>

<div id="scroll2top">
<img src="/scroll2top/arrow.png"/>
</div>
<script src="/scroll2top/scroll2top.min.js"></script>
<div id="winterland">
  <canvas></canvas>
</div>
<script src="/js/winterland.min.js"></script>

  </body>
</html>
