
<!DOCTYPE HTML>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>The 9 Page | It so life</title>
<meta name="author" content="RobinChia">

<meta name="description" content="It so life">


<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<meta property="og:site_name" content="It so life"/>

<!--[if IE]><style>.testIE.IE{display:inline;}</style><![endif]-->
<!--[if lte IE 7]><link rel="stylesheet" href="/css/ie7.css" type="text/css"><![endif]-->
<!--[if (lt IE 9)&(gt IE 7)]><style>.testIE.IE8{display:inline;}</style><![endif]-->
<!--[if gt IE 8]><style>.testIE.IE9{display:inline;}</style><![endif]-->

<link href="/favicon.png" rel="icon">
<link rel="alternate" href="/atom.xml" title="It so life Feed" type="application/atom+xml">

<link rel="stylesheet" href="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/css/bootstrap.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/font-awesome/4.0.3/css/font-awesome.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/prettify/r298/prettify.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" type="text/css">
<link rel="stylesheet" href="/css/style.css" type="text/css">
<!--[if lt IE 9]>
   <style>article,aside,dialog,footer,header,section,footer,nav,figure,menu{display:block}</style>
   <script src="http://cdn.staticfile.org/html5shiv/r29/html5.min.js"></script>
   <script src="http://cdn.staticfile.org/respond.js/1.4.2/respond.min.js"></script>
<link href="http://cdn.staticfile.org/respond.js/1.4.2/respond-proxy.html" id="respond-proxy" rel="respond-proxy" />
<link href="/js/respond.proxy.gif" id="respond-redirect" rel="respond-redirect" />
<script src="/js/respond.proxy.js"></script>
   <script src="http://cdn.bootcss.com/selectivizr/1.0.2/selectivizr-min.js"></script>
<![endif]-->
<script type="text/javascript">
function loadjs(c,d){var a=document.createElement("script");a.async=!0;a.type="text/javascript";a.src=c;a.charset=d||"gbk";(document.getElementsByTagName("HEAD")[0]||document.getElementsByTagName("BODY")[0]).appendChild(a)};
var _protocol = (("https:" == document.location.protocol) ? " https://" : " http://");
var _js2load = [];
</script>

</head>
<body>
      <header id="header" class="container"><nav id="main-nav" class="navbar navbar-default navbar-fixed-top " role="navigation">
  <div class="container">
    <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
      <span class="sr-only">Toggle navigation</span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="/">It so life</a>
    </div>
    <div  class="collapse navbar-collapse">
      <ul  class="nav navbar-nav">
  
        <li><a href="/" title="Home">Home</a></li>      
        <li><a href="/about/" title="About">About</a></li>      
        <li><a href="/archives/" title="Archives">Archives</a></li>      
      <li class='dropdown'>
        <a class='dropdown-toggle' data-toggle='dropdown' href='#'>website<b class='caret'></b></a>
        <ul class='dropdown-menu pure-menu-selected'>
    
          <li><a href="//groups.google.com/forum/#!forum/pongba" title="TopLanguage">TopLanguage</a></li>    
          <li><a href="//itpub.net/" title="ITPub">ITPub</a></li>    
          <li><a href="//blog.jobbole.com/" title="Bole">Bole</a></li>    
          <li><a href="//nosql-database.org/" title="nosql">nosql</a></li>    
          <li><a href="//gitimmersion.googol.im/" title="Git">Git</a></li>    
        </ul>
      </li>
    
      </ul>
      <ul class="nav navbar-nav navbar-right">
      
        <li><a href="/atom.xml">RSS</a></li>
      
      
        <li><a href="https://twitter.com/robinchia">twitter</a></li>
      
      
      
      
        <li><a href="https://github.com/robinchia">github</a></li>
      
      </ul>
    </div>
  </div>
</nav>
<div class="clearfix"></div>
</header>
  <div id='content' class="container">
     <div class="page-header-wrapper">
      <!--[if lt IE 9]><div class="alert alert-warning alert-dismissable"><button type="button" class="close" data-dismiss="alert" aria-hidden="true">&times;</button><strong>提示:</strong>您的浏览器版本太低了,建议升级到 <strong><a href="http://windows.microsoft.com/zh-cn/internet-explorer/download-ie" title="IE9">IE9</a></strong> 以上,本站使用<a href="https://www.google.com/intl/zh-CN/chrome/">Chrome浏览器</a>可以获得最好的显示效果.</div><![endif]-->
      <div class="page-header"><h1 align="center"><big>It so life</big> </h1>
        <h5 align="center"><big>love as life</big></h5>
      </div>
     </div>
     <div class="row">
       <div id="main-col" class="alignleft col-sx-12 col-sm-8 col-md-9 col-lg-9">
      <section id='header_widget'></section>
          <div id="wrapper"><article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-webservice-CXF--ApacheCXF/">Apache CXF</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:45.000Z"> <a href="/2014/02/02/2014-02-02-webservice-CXF--ApacheCXF/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="apache-cxf">Apache CXF</h1>
<p>CXF是基于JAX-WS实现的，JAX-WS规范是一组XML web services的JAVA API，它使用户无需编写复杂的SOAP ENV,WSDL。在 JAX-WS中，一个远程调用可以转换为一个基于XML的协议例如SOAP。在使用JAX-WS过程中，开发者不需要编写任何生成和处理SOAP消息的代码。JAX-WS的运行时实现会将这些API的调用转换成为对于SOAP消息。</p>
<p>在服务器端，用户只需要通过Java语言定义远程调用所需要实现的接口SEI (service endpoint interface)，并提供相关的实现，通过调用JAX-WS的服务发布接口就可以将其发布为WebService接口。 
在客户端，用户可以通过JAX-WS的API创建一个代理（用本地对象来替代远程的服务）来实现对于远程服务器端的调用。
来源： <a href="[http://blog.csdn.net/chjttony/article/details/6196289](http://blog.csdn.net/chjttony/article/details/6196289)">[http://blog.csdn.net/chjttony/article/details/6196289](http://blog.csdn.net/chjttony/article/details/6196289)</a> </p>
<p>一、与Axis2的不同之处
1、Apache CXF 支持 WS-Addressing、WS-Policy、WS-RM、WS-Security和WS-I BasicProfile 
2、Axis2 支持 WS-Addressing、WS-RM、WS-Security和WS-I BasicProfile，WS-Policy将在新版本里得到支持 
3、Apache CXF 是根据Spring哲学来进行编写的，即可以无缝地与Spring进行整合 
4、Axis2 不是 
5、Axis2 支持更多的 data bindings，包括 XMLBeans、JiBX、JaxMe 和 JaxBRI，以及它原生的 data binding（ADB）。 
6、Apache CXF 目前仅支持 JAXB 和 Aegis，并且默认是 JAXB 2.0，与 XFire 默认是支持 Aegis 不同，XMLBeans、JiBX 和 Castor 将在 CXF 2.1 版本中得到支持，目前版本是 2.0.2 
7、Axis2 支持多种语言，它有 C/C++ 版本。 
8、Apache CXF 提供方便的Spring整合方法，可以通过注解、Spring标签式配置来暴露Web Services和消费Web Services</p>
<p>二、A simple JAX-WS service
原文见<a href="http://cwiki.apache.org/CXF20DOC/a-simple-jax-ws-service.html" target="_blank"><a href="http://cwiki.apache.org/CXF20DOC/a-simple-jax-ws-service.html">http://cwiki.apache.org/CXF20DOC/a-simple-jax-ws-service.html</a></a></p>
<p> 来源： <a href="http://www.iteye.com/topic/143877" target="_blank"><a href="http://www.iteye.com/topic/143877">http://www.iteye.com/topic/143877</a></a>
CXF旨在为服务创建必要的基础设施，它的整体架构主要由以下几个部分组成：</p>
<p>1.Bus</p>
<p>它是C X F架构的主干，为共享资源提供了一个可配置的场所，作用非常类似于S p r i n g的ApplicationContext。这些共享资源包括WSDL管理器、绑定工厂等。通过对Bus进行扩展，可以方便地容纳自己的资源，或替换现有的资源。默认Bus实现是基于Spring的，通过依赖注入，将运行时组件串起来。Bus的创建由BusFactory负责，默认是 SpringBusFactory，对应于默认Bus实现。在构造过程中，SpringBusFactory会搜索META-INF/cxf（就包含在 CXF的Jar中）下的所有Bean配置文件，根据它们构建一个ApplicationContext。开发者也可提供自己的配置文件来定制Bus。</p>
<p>2.消息传递和拦截器（Interceptor）</p>
<p>CXF建立于一个通用的消息层之上，主要由消息、拦截器和拦截器链（InterceptorChain）组成。CXF是以消息处理为中心的，熟悉 JSP/Servlet的开发者可以将拦截器视为CXF架构中的“Filter”，拦截器链也与“FilterChain”类似。通过拦截器，开发者可以方便地在消息传递、处理的整个过程中对CXF进行扩展。拦截器的方法主要有两个：handleMessage和handleFault，分别对应消息处理和错误处理。在开发拦截器的时候需要注意两点：</p>
<p>拦截器不是线程安全的，不建议在拦截器中定义实例变量并使用它。这一点跟JSP/Servlet中对于Filter的处理是一样的；</p>
<p>不要调用下一个拦截器的handleMessage或handleFault，这个工作由InterceptorChain来完成。</p>
<p>3.前端（Front End）</p>
<p>它为CXF提供了创建服务的编程模型，当前主要的前端就是JAX-WS。</p>
<p>4.服务模型</p>
<p>CXF中的服务通过服务模型来表示。它主要有两部分：ServiceInfo和服务本身。ServiceInfo作用类似WSDL，包含接口信息、绑定、端点（EndPoint）等信息；服务则包含了ServiceInfo、数据绑定、拦截器和服务属性等信息。可使用Java类和WSDL来创建服务。一般是由前端负责服务的创建，它通过ServiceFactory来完成。</p>
<p>5.绑定（Binding）</p>
<p>绑定提供了在传输之上映射具体格式和协议的方法，主要的两个类是Binding和BindingFactory。BindingFactory负责创建Binding。</p>
<p>6.传输（Transport）</p>
<p>为了向绑定和前端屏蔽传输细节，CXF提供了自己的传输抽象。其中主要有两个对象：Conduit和Destination。前者是消息发送的基础，后者则对应消息接收。开发者还可以给Conduit和Destination注册MessageObserver，以便在消息发送和接收时获得通知。</p>
<p><strong>开发方法</strong></p>
<p>CXF 可以创建的Web 服务应用有两种：服务提供者和服务消费者。这种结构可类比客户端/ 服务器结构，服务消费者类似于客户端，服务提供者类似于服务器。使用CXF 创建应用时，服务提供者和服务消费者并不需要同时出现，因为有可能应用只是作为服务提供者或服务消费者单独出现。
来源： <a href="[http://blog.csdn.net/jacklee_6297/article/details/5888232](http://blog.csdn.net/jacklee_6297/article/details/5888232)">[http://blog.csdn.net/jacklee_6297/article/details/5888232](http://blog.csdn.net/jacklee_6297/article/details/5888232)</a><strong> 开发Webservice工程步骤：</strong></p>
<p>2.使用CXF开发Webservice工程步骤： </p>
<p>1).为CXF设置编译和开发环境 
在<a href="http://cxf.apache.org/download.html" target="_blank">http://cxf.apache.org/download.html</a> 下载相应的CXF包，/lib目录下的jar 文件引入工程 
2).创建基于XCF的Webservice服务端工程。
3).编写Webservice的客户端程序，调用服务端服务。</p>
<p>3.CXF中的Factory：</p>
<p>CXF不但可以使用JAX-WS开发web服务，也可以将POJO发布为web服务，对于这两种不同的方式，对应的factory如下：</p>
<pre><code>                             服务端                               客户端  
</code></pre><p>JAX-WS                      JaxWsServerFactoryBean             JaxWsProxyFactoryBean</p>
<p>POJO                           ServiceFactoryBean                     ClientProxyFactoryBean</p>
<p>4.CXF使用JAX-WS开发服务端：</p>
<p>(1).定义服务接口：</p>
<p>在接口上添加Webservice注解：@WebService。如：</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/chjttony/article/details/6196289#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/chjttony/article/details/6196289#" title="copy" target="_blank">copy</a></p>
<ol>
<li>package service;  </li>
<li>import javax.jws.WebService;  </li>
<li>@WebService  </li>
<li>public interface OrderProcess {  </li>
<li>String processOrder(Order order);  </li>
<li>}  </li>
</ol>
<p>(2).实现服务接口：</p>
<p>在实现类上也添加Webservice注解：@WebService(endpointInterface = 服务接口全路径,   serviceName = 对外发布的服务名)。如：</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/chjttony/article/details/6196289#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/chjttony/article/details/6196289#" title="copy" target="_blank">copy</a></p>
<ol>
<li>package service;  </li>
<li>import javax.jws.WebService;  </li>
<li>@WebService(endpointInterface = &quot;service.OrderProcess&quot;，serviceName=”order”)  </li>
<li>public class OrderProcessImpl implements OrderProcess {  </li>
<li>public String processOrder(Order order) {  </li>
<li>return &quot;hello world&quot;+order;  </li>
<li>}  </li>
<li>}  </li>
</ol>
<p>(3).对外发布服务：</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/chjttony/article/details/6196289#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/chjttony/article/details/6196289#" title="copy" target="_blank">copy</a></p>
<ol>
<li>//创建web服务工厂  </li>
<li>JaxWsServerFactoryBean factory = new JaxWsServerFactoryBean();  </li>
<li>//设置服务类  </li>
<li>factory.setServiceClass(服务接口实现类.class);  </li>
<li>//设置对外发布服务地址  </li>
<li>factory.setAddress(对外发布的服务地址);  </li>
<li>//创建服务  </li>
<li>Server server = factory.create();  </li>
<li>//启动服务  </li>
<li>server.start();  </li>
</ol>
<p>5.CXF使用JAX-WS开发客户端：</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/chjttony/article/details/6196289#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/chjttony/article/details/6196289#" title="copy" target="_blank">copy</a></p>
<ol>
<li>//创建web服务代理工厂  </li>
<li>JaxWsProxyFactoryBean factory = new JaxWsProxyFactoryBean();  </li>
<li>//设置要调用的web服务服务端发布地址  </li>
<li>factory.setAddress(web服务的发布地址);  </li>
<li>//设置要调用的web服务  </li>
<li>factory.setServiceClass(web服务接口.class);  </li>
<li>//创建web服务对象  </li>
<li>服务接口 对象 = (服务接口) factory.create();  </li>
<li>通过对象调用web服务的方法  </li>
<li>6.CXF使用POJO开发服务端：  </li>
<li>和使用JAX-WS开发方式前两步完全一样，第三步稍有不同如下：  </li>
<li>//创建web服务工厂  </li>
<li>ServiceFactoryBean svrFactory = new ServiceFactoryBean();  </li>
<li>//设置服务类  </li>
<li>svrFactory.setServiceClass(服务接口实现类.class);  </li>
<li>//设置对外发布服务地址  </li>
<li>svrFactory.setAddress(对外发布的服务地址);  </li>
<li>//创建服务  </li>
<li>Server server = svrFactory.create();  </li>
<li>//启动服务  </li>
<li>server.start();  </li>
</ol>
<p>6.CXF使用POJO开发客户端：</p>
<p>和JAX-WS方式除了代理工厂不同以外，其他均相同：</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/chjttony/article/details/6196289#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/chjttony/article/details/6196289#" title="copy" target="_blank">copy</a></p>
<ol>
<li>//创建web服务代理工厂  </li>
<li>ClientProxyFactoryBean factory = new ClientProxyFactoryBean();  </li>
<li>//设置要调用的web服务服务端发布地址  </li>
<li>factory.setAddress(web服务的发布地址);  </li>
<li>//设置要调用的web服务  </li>
<li>factory.setServiceClass(web服务接口.class);  </li>
<li>//创建web服务对象  </li>
<li>服务接口 对象 = (服务接口) factory.create();  </li>
</ol>
<p>通过对象调用web服务的方法</p>
<p>7.CXF与Spring的集成：</p>
<p>(1).对工程引入spring支持。</p>
<p>(2).在web.xml文件中添加spring和CXF相应的配置如下：</p>
<p><strong>[xhtml]</strong> <a href="http://blog.csdn.net/chjttony/article/details/6196289#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/chjttony/article/details/6196289#" title="copy" target="_blank">copy</a></p>
<ol>
<li><web-app>  </li>
<li><context-param>  </li>
<li><param-name>contextConfigLocation</param-name>  </li>
<li><param-value>spring配置文件路径</param-value>  </li>
<li></context-param>  </li>
<li><listener>  </li>
<li><listener-class>  </li>
<li>org.springframework.web.context.ContextLoaderListener  </li>
<li></listener-class>  </li>
<li></listener>  </li>
<li><servlet>  </li>
<li><servlet-name>CXFServlet</servlet-name>  </li>
<li><display-name>CXF Servlet</display-name>  </li>
<li><servlet-class>  </li>
<li>org.apache.cxf.transport.servlet.CXFServlet  </li>
<li></servlet-class>  </li>
<li><load-on-startup>1</load-on-startup>  </li>
<li></servlet>  </li>
<li><servlet-mapping>  </li>
<li><servlet-name>CXFServlet</servlet-name>  </li>
<li><url-pattern>/service//*</url-pattern>  </li>
<li></servlet-mapping>  </li>
<li></web-app>  </li>
</ol>
<p>(3).在spring配置文件中导入CXF的相关配置如下：</p>
<p><strong>[xhtml]</strong> <a href="http://blog.csdn.net/chjttony/article/details/6196289#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/chjttony/article/details/6196289#" title="copy" target="_blank">copy</a></p>
<ol>
<li><import resource="classpath:META-INF/cxf/cxf.xml" />  </li>
<li><import resource="classpath:META-INF/cxf/cxf-extension-soap.xml" />  </li>
<li><import resource="classpath:META-INF/cxf/cxf-servlet.xml" />  



</li>
</ol>
<p>(4).在spring配置文件中配置要发布的web服务如下：</p>
<p><strong>[xhtml]</strong> <a href="http://blog.csdn.net/chjttony/article/details/6196289#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/chjttony/article/details/6196289#" title="copy" target="_blank">copy</a></p>
<ol>
<li>&lt;jaxws:endpoint  </li>
<li>id=&quot;……&quot;  </li>
<li>implementor=&quot;服务接口实现类全路径&quot;  </li>
<li><p>address=&quot;/web服务发布地址(相对地址)&quot; /&gt;  </p>
<p>来源：<a href="http://blog.csdn.net/chjttony/article/details/6196289" target="_blank"><a href="http://blog.csdn.net/chjttony/article/details/6196289">http://blog.csdn.net/chjttony/article/details/6196289</a></a></p>
</li>
</ol>
<p><strong>拦截器方式的使用实例：</strong></p>
<p>基于CXF2.0前2个学习笔记，对原先服务端与客户端进行修改，实现在SOAP Header里面添加自定义的数据进行认证
在做之前，先要理解如下的信息
<strong>拦截器(Interceptor)简单说明</strong>
      Interceptor是CXF架构中一个很有特色的模式。你可以在不对核心模块进行修改的情况下，动态添加很多功能。这对于CXF这个以处理消息为中心的服务框架来说是非常有用的，CXF通过在Interceptor中对消息进行特殊处理，实现了很多重要功能模块，例如：日志记录，Soap消息处理，消息的压缩处。简单的说，可以在收到请求后，还未进行业务处理前，进行处理。或者在请求包发送前，进行报文的处理。
<strong>几个的API的介绍</strong>
<strong>Interceptor</strong></p>
<p>定义两个方法，一个处理消息 handleMessage， 一个是处理错误 handleFault。</p>
<p><strong>InterceptorChain
</strong>  单个的Interceptor功能有限，CXF要实现一个SOAP消息处理，需要将许许多多的Interceptor组合在一起使用。因此设计了 InterceptorChain，在我看了InterceptorChain就像是一个Interceptor的小队长。 小队长有调配安置Interceptor的权力（add，remove），也有控制消息处理的权力（doInterceptor，pause，resume，reset，abort），同时也有交付错误处理的权力（ {get|set}FaultObserver）。更有意思的是为灵活控制Interceptor的处理消息顺序（doInterceptStartingAt，doInterceptorStartingAfter），这也是InterceptorChain比较难理解的地方。
<strong>Fault</strong>
  定义了CXF中的错误消息。
<strong>InterceptorProvider</strong>
这里定义了Interceptor的后备保障部队。我们可以在InterceptorProvider中设置In，Out，InFault，OutFault 后备小分队，添加我们所希望添加的Interceptor。而InterceptorChain会根据这些后备小分队，组建自己的小分队实例，完成具体的作战功能任务。
<strong>AbstractAttributedInterceptorProvider</strong>
   InterceptorProvider实现的抽象类，由于这个类来继承了HashMap，我们可以像这个类中存储一些属性信息。
<strong>AbstractBasicInterceptorProvider</strong>
   与AbstractAttributedInterceptorProvider不同，这个Interceptor只是简单实现了InterceptorProvider的功能，并不提供对其属性存储的扩展。
<strong>Message</strong>
   由于Interceptor是针对Message来进行处理的，当你打开Message这个类文件时，你会发现在Message中定义了很多常量，同时你还可以从Message中获取到很多与Message操作相关的信息。可以获取设置的对象有InterceptorChain Exchange Destination，还有获取设置Content的泛型接口，是不是感觉Message和Bus差不多，都成了大杂货铺，一切与消息处理相关的信息都可以放在Message中。</p>
<p>理解了Interceptor功能，下面的修改就很简单了</p>
<p><strong>服务端修改</strong>
1.新建一个拦截器(Interceptor)
<img src="" alt="">package hs.cxf.soapHeader;
<img src="" alt="">
<img src="" alt="">import javax.xml.soap.SOAPException;
<img src="" alt="">import javax.xml.soap.SOAPHeader;
<img src="" alt="">import javax.xml.soap.SOAPMessage;
<img src="" alt="">import org.apache.cxf.binding.soap.SoapMessage;
<img src="" alt="">import org.apache.cxf.binding.soap.saaj.SAAJInInterceptor;
<img src="" alt="">import org.apache.cxf.interceptor.Fault;
<img src="" alt="">import org.apache.cxf.phase.AbstractPhaseInterceptor;
<img src="" alt="">import org.apache.cxf.phase.Phase;
<img src="" alt="">import org.w3c.dom.NodeList;
<img src="" alt="">
<img src="" alt="">//<em>/</em>
<img src="" alt=""> /<em> 
<img src="" alt=""> /</em> @Title:获取soap头信息
<img src="" alt=""> /<em> 
<img src="" alt=""> /</em> @Description:
<img src="" alt=""> /<em> 
<img src="" alt=""> /</em> @Copyright:
<img src="" alt=""> /<em> 
<img src="" alt=""> /</em> @author zz
<img src="" alt=""> /<em> @version 1.00.000
<img src="" alt=""> /</em> 
<img src="" alt=""> /<em>/
<img src="" alt="">public class ReadSoapHeader extends AbstractPhaseInterceptor<SoapMessage> {
<img src="" alt="">
<img src="" alt="">    private SAAJInInterceptor saa = new SAAJInInterceptor();
<img src="" alt="">
<img src="" alt="">    public ReadSoapHeader() {
<img src="" alt="">        super(Phase.PRE_PROTOCOL);
<img src="" alt="">        getAfter().add(SAAJInInterceptor.class.getName());
<img src="" alt="">    }
<img src="" alt="">
<img src="" alt="">    public void handleMessage(SoapMessage message) throws Fault {
<img src="" alt="">
<img src="" alt="">        SOAPMessage mess = message.getContent(SOAPMessage.class);
<img src="" alt="">        if (mess == null) {
<img src="" alt="">            saa.handleMessage(message);
<img src="" alt="">            mess = message.getContent(SOAPMessage.class);
<img src="" alt="">        }
<img src="" alt="">        SOAPHeader head = null;
<img src="" alt="">        try {
<img src="" alt="">            head = mess.getSOAPHeader();
<img src="" alt="">        } catch (SOAPException e) {
<img src="" alt="">            e.printStackTrace();
<img src="" alt="">        }
<img src="" alt="">        if (head == null) {
<img src="" alt="">            return;
<img src="" alt="">        }
<img src="" alt="">        try {
<img src="" alt="">            //读取自定义的节点
<img src="" alt="">            NodeList nodes = head.getElementsByTagName(&quot;tns:spId&quot;);
<img src="" alt="">            NodeList nodepass = head.getElementsByTagName(&quot;tns:spPassword&quot;);
<img src="" alt="">            //获取节点值，简单认证
<img src="" alt="">            if (nodes.item(0).getTextContent().equals(&quot;wdw&quot;)) {
<img src="" alt="">                if (nodepass.item(0).getTextContent().equals(&quot;wdwsb&quot;)) {
<img src="" alt="">                    System.out.println(&quot;认证成功&quot;);
<img src="" alt="">                }
<img src="" alt="">            } else {
<img src="" alt="">                SOAPException soapExc = new SOAPException(&quot;认证错误&quot;);
<img src="" alt="">                throw new Fault(soapExc);
<img src="" alt="">            }
<img src="" alt="">
<img src="" alt="">        } catch (Exception e) {
<img src="" alt="">            SOAPException soapExc = new SOAPException(&quot;认证错误&quot;);
<img src="" alt="">            throw new Fault(soapExc);
<img src="" alt="">        }
<img src="" alt="">    }
<img src="" alt="">
<img src="" alt="">}
2.配置文件中新增拦截器配置
<img src="" alt=""><beans xmlns="http://www.springframework.org/schema/beans"  
![]()    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
![]()    xmlns:jaxws="http://cxf.apache.org/jaxws"  
![]()    xsi:schemaLocation="   
![]()http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd   
![]()http://cxf.apache.org/jaxws http://cxf.apache.org/schemas/jaxws.xsd"><br><img src="" alt=""><br><img src="" alt="">    <import resource="classpath:META-INF/cxf/cxf.xml" /><br><img src="" alt="">    <import resource="classpath:META-INF/cxf/cxf-extension-soap.xml" /><br><img src="" alt="">    <import resource="classpath:META-INF/cxf/cxf-servlet.xml" /><br><img src="" alt=""><br><img src="" alt="">    <bean id="jaxWsServiceFactoryBean"  
![]()        class="org.apache.cxf.jaxws.support.JaxWsServiceFactoryBean"><br><img src="" alt="">        <property name="wrapped" value="true" /><br><img src="" alt="">        <property name="dataBinding" ref="aegisBean" /><br><img src="" alt="">    </bean><br><img src="" alt=""><br><img src="" alt="">    <bean id="aegisBean"  
![]()        class="org.apache.cxf.aegis.databinding.AegisDatabinding" /><br><img src="" alt=""><br><img src="" alt="">    <jaxws:endpoint id="CollectiveServices"  
![]()        implementor="hs.cxf.server.WebServiceSampleImpl" address="/HelloWorld"><br><img src="" alt="">        <jaxws:inInterceptors><br><img src="" alt="">          <!-- 日志拦截器 --><br><img src="" alt="">          <bean class="org.apache.cxf.interceptor.LoggingOutInterceptor"/><br><img src="" alt="">          <!-- 自定义拦截器 --> 
<img src="" alt="">          <bean class="hs.cxf.soapHeader.ReadSoapHeader"/><br><img src="" alt="">          </jaxws:inInterceptors><br><img src="" alt="">        <jaxws:serviceFactory><br><img src="" alt="">            <ref bean="jaxWsServiceFactoryBean"/><br><img src="" alt="">        </jaxws:serviceFactory><br><img src="" alt="">    </jaxws:endpoint><br><img src="" alt=""></beans><br><img src="" alt="">
服务端的配置就告一段落了，接下来是客户端的修改
<strong>客户端
</strong>1.同样新增一个Interceptor
<img src="" alt="">package hs.cxf.client.SoapHeader;
<img src="" alt="">
<img src="" alt="">
<img src="" alt="">import java.util.List;
<img src="" alt="">import javax.xml.namespace.QName;
<img src="" alt="">import org.apache.cxf.binding.soap.SoapHeader;
<img src="" alt="">import org.apache.cxf.binding.soap.SoapMessage;
<img src="" alt="">import org.apache.cxf.binding.soap.interceptor.AbstractSoapInterceptor;
<img src="" alt="">import org.apache.cxf.headers.Header;
<img src="" alt="">import org.apache.cxf.helpers.DOMUtils;
<img src="" alt="">import org.apache.cxf.interceptor.Fault;
<img src="" alt="">import org.apache.cxf.phase.Phase;
<img src="" alt="">import org.w3c.dom.Document;
<img src="" alt="">import org.w3c.dom.Element;
<img src="" alt="">//</em>/<em>
<img src="" alt=""> /</em> 
<img src="" alt=""> /<em> @Title:在发送消息前，封装Soap Header 信息
<img src="" alt=""> /</em> 
<img src="" alt=""> /<em> @Description:
<img src="" alt=""> /</em> 
<img src="" alt=""> /<em> @Copyright: 
<img src="" alt=""> /</em>
<img src="" alt=""> /<em> @author zz
<img src="" alt=""> /</em> @version 1.00.000
<img src="" alt=""> /<em>
<img src="" alt=""> /</em>/
<img src="" alt="">
<img src="" alt="">public class AddSoapHeader extends AbstractSoapInterceptor {
<img src="" alt="">      private static String nameURI=&quot;<a href="http://127.0.0.1:8080/cxfTest/ws/HelloWorld" target="_blank">http://127.0.0.1:8080/cxfTest/ws/HelloWorld</a>&quot;;<br><img src="" alt=""><br><img src="" alt="">        public AddSoapHeader(){<br><img src="" alt="">            super(Phase.WRITE);<br><img src="" alt="">        }<br><img src="" alt=""><br><img src="" alt="">        public void handleMessage(SoapMessage message) throws Fault {<br><img src="" alt="">            String spPassword=&quot;wdwsb&quot;;<br><img src="" alt="">            String spName=&quot;wdw&quot;;<br><img src="" alt=""><br><img src="" alt="">            QName qname=new QName(&quot;RequestSOAPHeader&quot;);<br><img src="" alt="">            Document doc=DOMUtils.createDocument();<br><img src="" alt="">            //自定义节点
<img src="" alt="">            Element spId=doc.createElement(&quot;tns:spId&quot;);<br><img src="" alt="">            spId.setTextContent(spName);<br><img src="" alt="">            //自定义节点
<img src="" alt="">            Element spPass=doc.createElement(&quot;tns:spPassword&quot;);<br><img src="" alt="">            spPass.setTextContent(spPassword);<br><img src="" alt=""><br><img src="" alt="">            Element root=doc.createElementNS(nameURI, &quot;tns:RequestSOAPHeader&quot;);<br><img src="" alt="">            root.appendChild(spId);<br><img src="" alt="">            root.appendChild(spPass);<br><img src="" alt=""><br><img src="" alt="">            SoapHeader head=new SoapHeader(qname,root);<br><img src="" alt="">            List<Header> headers=message.getHeaders();<br><img src="" alt="">            headers.add(head);<br><img src="" alt="">            System.out.println(&quot;&gt;&gt;&gt;&gt;&gt;添加header&lt;&lt;&lt;&lt;&lt;&lt;&lt;&quot;);
<img src="" alt="">        }<br><img src="" alt="">
<img src="" alt="">}
<img src="" alt="">
2.客户端调用程序修改
<img src="" alt="">package hs.cxf.client;
<img src="" alt="">
<img src="" alt="">import hs.cxf.client.SoapHeader.AddSoapHeader;
<img src="" alt="">import java.util.ArrayList;
<img src="" alt="">import javax.xml.bind.JAXBElement;
<img src="" alt="">import javax.xml.namespace.QName;
<img src="" alt="">import org.apache.cxf.endpoint.Client;
<img src="" alt="">import org.apache.cxf.frontend.ClientProxy;
<img src="" alt="">import org.apache.cxf.interceptor.Interceptor;
<img src="" alt="">import org.apache.cxf.jaxws.JaxWsProxyFactoryBean;
<img src="" alt="">import org.apache.cxf.transport.http.HTTPConduit;
<img src="" alt="">import org.apache.cxf.transports.http.configuration.HTTPClientPolicy;
<img src="" alt="">
<img src="" alt="">//<em>/</em>
<img src="" alt=""> /<em> @Title:
<img src="" alt=""> /</em> 
<img src="" alt=""> /<em> @Description:
<img src="" alt=""> /</em> 
<img src="" alt=""> /<em> @Copyright: 
<img src="" alt=""> /</em> 
<img src="" alt=""> /<em> @author zz
<img src="" alt=""> /</em> @version 1.00.000
<img src="" alt=""> /<em> 
<img src="" alt=""> /</em>/
<img src="" alt="">public class TestClient {
<img src="" alt="">
<img src="" alt="">    //<em>/</em>
<img src="" alt="">     /<em> 测试1
<img src="" alt="">     /</em>/
<img src="" alt="">    @SuppressWarnings(&quot;unchecked&quot;)
<img src="" alt="">    public void testSend1() {
<img src="" alt="">        try {
<img src="" alt="">            JaxWsProxyFactoryBean factory = new JaxWsProxyFactoryBean();
<img src="" alt="">
<img src="" alt="">            ArrayList<Interceptor> list = new ArrayList<Interceptor>();
<img src="" alt="">            // 添加soap header 
<img src="" alt="">            list.add(new AddSoapHeader());
<img src="" alt="">            // 添加soap消息日志打印
<img src="" alt="">            list.add(new org.apache.cxf.interceptor.LoggingOutInterceptor());
<img src="" alt="">            factory.setOutInterceptors(list);
<img src="" alt="">            factory.setServiceClass(WebServiceSample.class);
<img src="" alt="">            factory.setAddress(&quot;<a href="http://127.0.0.1:8080/cxfTest/ws/HelloWorld" target="_blank">http://127.0.0.1:8080/cxfTest/ws/HelloWorld</a>&quot;);
<img src="" alt="">
<img src="" alt="">            Object obj = factory.create();
<img src="" alt="">            System.out.println(obj == null ? &quot;NULL&quot; : obj.getClass().getName());
<img src="" alt="">            if (obj != null) {
<img src="" alt="">                WebServiceSample ws = (WebServiceSample) obj;
<img src="" alt="">                String str = ws.say(&quot;test&quot;);
<img src="" alt="">                System.out.println(str);
<img src="" alt="">
<img src="" alt="">                str = ws.say(&quot;1111&quot;);
<img src="" alt="">                System.out.println(str);
<img src="" alt="">
<img src="" alt="">                User u = new User();
<img src="" alt="">                JAXBElement<String> je = new JAXBElement<String>(new QName(
<img src="" alt="">                        &quot;<a href="http://bean.cxf.hs" target="_blank">http://bean.cxf.hs</a>&quot;, &quot;name&quot;), String.class, &quot;张三&quot;);
<img src="" alt="">                u.setName(je);
<img src="" alt="">                str = ws.sayUserName(u);
<img src="" alt="">                System.out.println(str);
<img src="" alt="">
<img src="" alt="">                // 通过对象来交互
<img src="" alt="">                ReqBean req = new ReqBean();
<img src="" alt="">                req.setExp(new JAXBElement<String>(new QName(
<img src="" alt="">                        &quot;<a href="http://bean.cxf.hs" target="_blank">http://bean.cxf.hs</a>&quot;, &quot;exp&quot;), String.class,
<img src="" alt="">                        &quot;<exp>111<exp>&quot;));
<img src="" alt="">                req.setSeqId(new JAXBElement<String>(new QName(
<img src="" alt="">                        &quot;<a href="http://bean.cxf.hs" target="_blank">http://bean.cxf.hs</a>&quot;, &quot;seqId&quot;), String.class,
<img src="" alt="">                        &quot;12345678&quot;));
<img src="" alt="">                RespBean resp = ws.action(req);
<img src="" alt="">                System.out.println(&quot;resp_id:&quot; + resp.getRespId().getValue());
<img src="" alt="">                System.out.println(&quot;resp_exp:&quot; + resp.getExp().getValue());
<img src="" alt="">            }
<img src="" alt="">        } catch (Exception ex) {
<img src="" alt="">            ex.printStackTrace();
<img src="" alt="">        }
<img src="" alt="">    }
<img src="" alt="">
<img src="" alt="">    //<em>/</em>
<img src="" alt="">     /<em> 测试2
<img src="" alt="">     /</em>/
<img src="" alt="">    @SuppressWarnings(&quot;unchecked&quot;)
<img src="" alt="">    public void testSend2() {
<img src="" alt="">        String webServiceUrl = &quot;<a href="http://127.0.0.1:8080/cxfTest/ws/HelloWorld" target="_blank">http://127.0.0.1:8080/cxfTest/ws/HelloWorld</a>&quot;;
<img src="" alt="">        String webServiceConTimeout = &quot;60000&quot;;
<img src="" alt="">        String webServiceRevTimeout = &quot;60000&quot;;
<img src="" alt="">        JaxWsProxyFactoryBean factory = new JaxWsProxyFactoryBean();
<img src="" alt="">
<img src="" alt="">        ArrayList<Interceptor> list = new ArrayList<Interceptor>();
<img src="" alt="">        // 添加soap header 信息
<img src="" alt="">        list.add(new AddSoapHeader());
<img src="" alt="">        // 添加soap消息日志打印
<img src="" alt="">        list.add(new org.apache.cxf.interceptor.LoggingOutInterceptor());
<img src="" alt="">        factory.setOutInterceptors(list);
<img src="" alt="">        factory.setServiceClass(WebServiceSample.class);
<img src="" alt="">        factory.setAddress(webServiceUrl);
<img src="" alt="">        WebServiceSample service = (WebServiceSample) factory.create();
<img src="" alt="">
<img src="" alt="">        //超时时间设置
<img src="" alt="">        Client clientP = ClientProxy.getClient(service);
<img src="" alt="">        HTTPConduit http = (HTTPConduit) clientP.getConduit();
<img src="" alt="">        HTTPClientPolicy httpClientPolicy = new HTTPClientPolicy();
<img src="" alt="">        httpClientPolicy.setConnectionTimeout(Integer
<img src="" alt="">                .valueOf(webServiceConTimeout));
<img src="" alt="">        httpClientPolicy.setReceiveTimeout(Integer
<img src="" alt="">                .valueOf(webServiceRevTimeout));
<img src="" alt="">        httpClientPolicy.setAllowChunking(false);
<img src="" alt="">        http.setClient(httpClientPolicy);
<img src="" alt=""><br><img src="" alt=""><br><img src="" alt="">        // 通过对象来交互
<img src="" alt="">        ReqBean req = new ReqBean();
<img src="" alt="">        req.setExp(new JAXBElement<String>(new QName(
<img src="" alt="">                &quot;<a href="http://bean.cxf.hs" target="_blank">http://bean.cxf.hs</a>&quot;, &quot;exp&quot;), String.class,
<img src="" alt="">                &quot;<exp>111<exp>&quot;));
<img src="" alt="">        req.setSeqId(new JAXBElement<String>(new QName(
<img src="" alt="">                &quot;<a href="http://bean.cxf.hs" target="_blank">http://bean.cxf.hs</a>&quot;, &quot;seqId&quot;), String.class,
<img src="" alt="">                &quot;12345678&quot;));
<img src="" alt="">        System.out.println(&quot;&gt;&gt;&gt;&gt;&gt;&gt;发送消息&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&quot;);
<img src="" alt="">        RespBean resp = service.action(req);
<img src="" alt="">        System.out.println(&quot;resp_id:&quot; + resp.getRespId().getValue());
<img src="" alt="">        System.out.println(&quot;resp_exp:&quot; + resp.getExp().getValue());
<img src="" alt="">
<img src="" alt="">    }
<img src="" alt="">
<img src="" alt="">    //<em>/</em>
<img src="" alt="">     /<em> @param args
<img src="" alt="">     /</em>/
<img src="" alt="">    public static void main(String[] args) {
<img src="" alt="">        TestClient tc = new TestClient();
<img src="" alt="">        tc.testSend1();
<img src="" alt="">        System.out.println(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;2&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&quot;);
<img src="" alt="">        tc.testSend2();
<img src="" alt="">        System.out.println(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;END&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&quot;);
<img src="" alt="">    }
<img src="" alt="">
<img src="" alt="">}
到这里就结束了，可以进行测试了</p>
<p>posted on 2011-04-19 14:23 <a href="http://www.blogjava.net/fatbear/" target="_blank">fatbear</a> 阅读(3424) <a href="http://www.blogjava.net/fatbear/archive/2011/04/19/348567.html#Post" target="_blank">评论(10)</a>  <a href="http://www.blogjava.net/fatbear/admin/EditPosts.aspx?postid=348567" target="_blank">编辑</a>  <a href="http://www.blogjava.net/fatbear/AddToFavorite.aspx?id=348567" target="_blank">收藏</a> 所属分类: <a href="http://www.blogjava.net/fatbear/category/38312.html" target="_blank">web service</a>
<img src="" alt=""></p>
<p><a href=""></a><a href=""></a></p>
<p>[</p>
<h3 id="-">评论</h3>
<p>]()</p>
<h3 id="-http-www-blogjava-net-fatbear-archive-2011-04-19-348567-html-348729-permalink-re-cxf2-0-3-soap-header-re-cxf2-0-3-soap-header-2011-04-21-19-01-akana-"><a href=""></a><a href="http://www.blogjava.net/fatbear/archive/2011/04/19/348567.html#348729" title="permalink: re: CXF2.0学习笔记-3 SOAP Header">/#</a> <a href=""></a>re: CXF2.0学习笔记-3 SOAP Header 2011-04-21 19:01 <a href="">akana</a></h3>
<p>hello，我想问一下你的ReadSoapHeader这个服务端读取soap header实现成功了吗？我这里用这种方式总是出错： head = mess.getSOAPHeader();出现java.lang.NullPointerException错误。。  <a href="http://www.blogjava.net/fatbear/archive/2011/04/19/348567.html#post" target="_blank">回复</a>  <a href="http://www.blogjava.net/comment?author=akana" title="查看该作者发表过的评论" target="_blank">更多评论</a><a href=""></a>  <a href=""></a></p>
<h3 id="-http-www-blogjava-net-fatbear-archive-2011-04-19-348567-html-348730-permalink-re-cxf2-0-3-soap-header-re-cxf2-0-3-soap-header-2011-04-21-19-02-akana-"><a href="http://www.blogjava.net/fatbear/archive/2011/04/19/348567.html#348730" title="permalink: re: CXF2.0学习笔记-3 SOAP Header" target="_blank">/#</a> <a href=""></a>re: CXF2.0学习笔记-3 SOAP Header 2011-04-21 19:02 <a href="">akana</a></h3>
<p>另外问一下你学习CXF2.0的资料有哪些呢？可以推荐一下吗？  <a href="http://www.blogjava.net/fatbear/archive/2011/04/19/348567.html#post" target="_blank">回复</a>  <a href="http://www.blogjava.net/comment?author=akana" title="查看该作者发表过的评论" target="_blank">更多评论</a> <a href=""></a>  <a href=""></a></p>
<h3 id="-http-www-blogjava-net-fatbear-archive-2011-04-19-348567-html-348785-permalink-re-cxf2-0-3-soap-header-re-cxf2-0-3-soap-header-2011-04-22-11-55-akana-"><a href="http://www.blogjava.net/fatbear/archive/2011/04/19/348567.html#348785" title="permalink: re: CXF2.0学习笔记-3 SOAP Header" target="_blank">/#</a> <a href=""></a>re: CXF2.0学习笔记-3 SOAP Header 2011-04-22 11:55 <a href="">akana</a></h3>
<p>@akana 
找到错误了。我的ReadSoapHeader引用了 
import org.apache.xmlbeans.impl.soap.SOAPException; 
import org.apache.xmlbeans.impl.soap.SOAPHeader; 
import org.apache.xmlbeans.impl.soap.SOAPMessage; 
而应该是 
import javax.xml.soap.SOAPException; 
import javax.xml.soap.SOAPHeader; 
import javax.xml.soap.SOAPMessage;  <a href="http://www.blogjava.net/fatbear/archive/2011/04/19/348567.html#post" target="_blank">回复</a>  <a href="http://www.blogjava.net/comment?author=akana" title="查看该作者发表过的评论" target="_blank">更多评论</a> <a href=""></a>  <a href=""></a></p>
<h3 id="-http-www-blogjava-net-fatbear-archive-2011-04-19-348567-html-348838-permalink-re-cxf2-0-3-soap-header-re-cxf2-0-3-soap-header-2011-04-22-21-53-fatbear-http-www-blogjava-net-fatbear-"><a href="http://www.blogjava.net/fatbear/archive/2011/04/19/348567.html#348838" title="permalink: re: CXF2.0学习笔记-3 SOAP Header" target="_blank">/#</a> <a href=""></a>re: CXF2.0学习笔记-3 SOAP Header 2011-04-22 21:53 <a href="http://www.blogjava.net/fatbear/">fatbear</a></h3>
<p>@akana 
呵呵，我也是看官方文档与网络上的资料后，自己写的，一般都有经过测试的  <a href="http://www.blogjava.net/fatbear/archive/2011/04/19/348567.html#post" target="_blank">回复</a>  <a href="http://www.blogjava.net/comment?author=fatbear" title="查看该作者发表过的评论" target="_blank">更多评论</a> <a href=""></a>  <a href=""></a></p>
<h3 id="-http-www-blogjava-net-fatbear-archive-2011-04-19-348567-html-357625-permalink-re-cxf-2-0-3-soap-header-re-cxf-2-0-3-soap-header-2011-08-31-11-08-"><a href="http://www.blogjava.net/fatbear/archive/2011/04/19/348567.html#357625" title="permalink: re: CXF 2.0 学习笔记-3 SOAP Header" target="_blank">/#</a> <a href=""></a>re: CXF 2.0 学习笔记-3 SOAP Header 2011-08-31 11:08 <a href="">无</a></h3>
<p>您好，ReadSoapHeader这个服务端读取soap header时，mess这个一直都是空的，这是怎么回事呀？  <a href="http://www.blogjava.net/fatbear/archive/2011/04/19/348567.html#post" target="_blank">回复</a>  <a href="http://www.blogjava.net/comment?author=%e6%97%a0" title="查看该作者发表过的评论" target="_blank">更多评论</a> <a href=""></a>  <a href=""></a></p>
<h3 id="-http-www-blogjava-net-fatbear-archive-2011-04-19-348567-html-382882-permalink-re-cxf-2-0-3-soap-header-re-cxf-2-0-3-soap-header-2012-07-12-15-27-"><a href="http://www.blogjava.net/fatbear/archive/2011/04/19/348567.html#382882" title="permalink: re: CXF 2.0 学习笔记-3 SOAP Header" target="_blank">/#</a> <a href=""></a>re: CXF 2.0 学习笔记-3 SOAP Header 2012-07-12 15:27 <a href="">林子</a></h3>
<p>factory.setOutInterceptors(list); 
factory.setServiceClass(WebServiceSample.class); 
factory.setAddress(&quot;<a href="http://127.0.0.1:8080/cxfTest/ws/HelloWorld%22" target="_blank"><a href="http://127.0.0.1:8080/cxfTest/ws/HelloWorld">http://127.0.0.1:8080/cxfTest/ws/HelloWorld</a>&quot;</a>); 
类org.apache.cxf.jaxws.JaxWsProxyFactoryBean 没有以上3个方法，引用的路径完全一样。。  <a href="http://www.blogjava.net/fatbear/archive/2011/04/19/348567.html#post" target="_blank">回复</a>  <a href="http://www.blogjava.net/comment?author=%e6%9e%97%e5%ad%90" title="查看该作者发表过的评论" target="_blank">更多评论</a> <a href=""></a>  <a href=""></a></p>
<h3 id="-http-www-blogjava-net-fatbear-archive-2011-04-19-348567-html-382899-permalink-re-cxf-2-0-3-soap-header-re-cxf-2-0-3-soap-header-2012-07-12-16-45-"><a href="http://www.blogjava.net/fatbear/archive/2011/04/19/348567.html#382899" title="permalink: re: CXF 2.0 学习笔记-3 SOAP Header" target="_blank">/#</a> <a href=""></a>re: CXF 2.0 学习笔记-3 SOAP Header 2012-07-12 16:45 <a href="">林子</a></h3>
<p>@林子 
我找到原因了，那是因为这3个方法时父类的方法而我没导入他父类的jar包，但是又抛了一个新异常： 
Exception in thread &quot;main&quot; javax.xml.ws.soap.SOAPFaultException: Could not find conduit initiator for transport <a href="http://schemas.xmlsoap.org/soap/http" target="_blank"><a href="http://schemas.xmlsoap.org/soap/http">http://schemas.xmlsoap.org/soap/http</a></a> 
at org.apache.cxf.jaxws.JaxWsClientProxy.invoke(JaxWsClientProxy.java:146) 
at $Proxy25.sendSms(Unknown Source) 
at Test.main(Test.java:48) 
Caused by: java.lang.RuntimeException: Could not find conduit initiator for transport <a href="http://schemas.xmlsoap.org/soap/http" target="_blank"><a href="http://schemas.xmlsoap.org/soap/http">http://schemas.xmlsoap.org/soap/http</a></a> 
at org.apache.cxf.binding.soap.SoapTransportFactory.getConduit(SoapTransportFactory.java:230) 
at org.apache.cxf.endpoint.AbstractConduitSelector.getSelectedConduit(AbstractConduitSelector.java:81) 
at org.apache.cxf.endpoint.UpfrontConduitSelector.prepare(UpfrontConduitSelector.java:61) 
at org.apache.cxf.endpoint.ClientImpl.prepareConduitSelector(ClientImpl.java:809) 
at org.apache.cxf.endpoint.ClientImpl.doInvoke(ClientImpl.java:505) 
at org.apache.cxf.endpoint.ClientImpl.invoke(ClientImpl.java:440) 
at org.apache.cxf.endpoint.ClientImpl.invoke(ClientImpl.java:343) 
at org.apache.cxf.endpoint.ClientImpl.invoke(ClientImpl.java:295) 
at org.apache.cxf.frontend.ClientProxy.invokeSync(ClientProxy.java:73) 
at org.apache.cxf.jaxws.JaxWsClientProxy.invoke(JaxWsClientProxy.java:124) 
... 2 more 
  <a href="http://www.blogjava.net/fatbear/archive/2011/04/19/348567.html#post" target="_blank">回复</a>  <a href="http://www.blogjava.net/comment?author=%e6%9e%97%e5%ad%90" title="查看该作者发表过的评论" target="_blank">更多评论</a> <a href=""></a>  <a href=""></a></p>
<h3 id="-http-www-blogjava-net-fatbear-archive-2011-04-19-348567-html-384016-permalink-re-cxf-2-0-3-soap-header-re-cxf-2-0-3-soap-header-2012-07-26-08-45-fatbear-http-www-blogjava-net-fatbear-"><a href="http://www.blogjava.net/fatbear/archive/2011/04/19/348567.html#384016" title="permalink: re: CXF 2.0 学习笔记-3 SOAP Header" target="_blank">/#</a> <a href=""></a>re: CXF 2.0 学习笔记-3 SOAP Header 2012-07-26 08:45 <a href="http://www.blogjava.net/fatbear/">fatbear</a></h3>
<p>@林子 
现在开发cxf已经很简单了，eclipse3.7已经自带有cxf插件，可以很方便的生成服务端与客户端，你可以用那个来弄，基本就不会有问题了  <a href="http://www.blogjava.net/fatbear/archive/2011/04/19/348567.html#post" target="_blank">回复</a>  <a href="http://www.blogjava.net/comment?author=fatbear" title="查看该作者发表过的评论" target="_blank">更多评论</a> <a href=""></a>  <a href=""></a></p>
<h3 id="-http-www-blogjava-net-fatbear-archive-2011-04-19-348567-html-393143-permalink-re-cxf-2-0-3-soap-header-re-cxf-2-0-3-soap-header-2012-12-18-14-40-randy-"><a href="http://www.blogjava.net/fatbear/archive/2011/04/19/348567.html#393143" title="permalink: re: CXF 2.0 学习笔记-3 SOAP Header[未登录]" target="_blank">/#</a> <a href=""></a>re: CXF 2.0 学习笔记-3 SOAP Header[未登录] 2012-12-18 14:40 <a href="">randy</a></h3>
<p>能解释下这两句代码的意思吗？ 
if (mess == null) { 
saa.handleMessage(message); 
mess = message.getContent(SOAPMessage.class); 
} 
还有什么情况下mess会为null？谢谢  <a href="http://www.blogjava.net/fatbear/archive/2011/04/19/348567.html#post" target="_blank">回复</a>  <a href="http://www.blogjava.net/comment?author=randy" title="查看该作者发表过的评论" target="_blank">更多评论</a> <a href=""></a>  <a href=""></a></p>
<h3 id="-http-www-blogjava-net-fatbear-archive-2011-04-19-348567-html-400293-permalink-re-cxf-2-0-3-soap-header-re-cxf-2-0-3-soap-header-2013-06-06-12-08-eason-"><a href="http://www.blogjava.net/fatbear/archive/2011/04/19/348567.html#400293" title="permalink: re: CXF 2.0 学习笔记-3 SOAP Header[未登录]" target="_blank">/#</a> <a href=""></a>re: CXF 2.0 学习笔记-3 SOAP Header[未登录]<a href=""></a> 2013-06-06 12:08 <a href="">Eason</a></h3>
<p>xml格式： </p>
<p><soap:Header> </p>
<p><auth:authentication xmlns:auth="[http://gd.chinamobile.com//authentication">](<a href="http://gd.chinamobile.com//authentication%22%3E">http://gd.chinamobile.com//authentication%22%3E</a>) </p>
<p><auth:systemID>1</auth:systemID> </p>
<p><auth:userID>test</auth:userID> </p>
<p><auth:password>test</auth:password> 
</auth:authentication> 
</soap:Header> 这个如何生成？  <a href="http://www.blogjava.net/fatbear/archive/2011/04/19/348567.html#post" target="_blank">回复</a>  <a href="http://www.blogjava.net/comment?author=Eason" title="查看该作者发表过的评论" target="_blank">更多评论</a> <a href=""></a><br>来源： <a href="[http://www.blogjava.net/fatbear/archive/2011/04/19/348567.html](http://www.blogjava.net/fatbear/archive/2011/04/19/348567.html)">[http://www.blogjava.net/fatbear/archive/2011/04/19/348567.html](http://www.blogjava.net/fatbear/archive/2011/04/19/348567.html)</a> </p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/webservice/">webservice</a></li></span><span class="breadcrumb"><li><a href="/categories/webservice/">webservice</a></li><li><a href="/categories/webservice/CXF/">CXF</a></li></span></span> | <span class="tags">Tagged <a href="/tags/CXF/" class="label label-primary">CXF</a><a href="/tags/webservice/" class="label label-success">webservice</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:45"datetime="2014-03-07 09:54:45"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-webservice-CXF--ApacheCXF/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-webservice-CXF--ApacheCXF" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-服务器-tomcat--tomcat详解/">tomcat详解</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:45.000Z"> <a href="/2014/02/02/2014-02-02-服务器-tomcat--tomcat详解/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="tomcat-">tomcat详解</h1>
<p><strong>一、Tomcat简介</strong></p>
<hr>
<p><strong>1、Tomcat</strong></p>
<p>Tomcat在严格意义上并不是一个真正的应用服务器，它只是一个可以支持运行Serlvet/JSP的Web容器，不过Tomcat也扩展了一些应用服务器的功能，如JNDI，数据库连接池，用户事务处理等等。Tomcat是Apache组织下Jakarta项目下的一个子项目，目前Tomcat被非常广泛的应用在中小规模的Java Web应用中。</p>
<p>Tomcat 是一种具有JSP环境的Servlet容器。Servlet容器是代替用户管理和调用 Servlet的运行时外壳。作为一个开放源代码的软件， Jakarta -Tomcat有着自己独特的优势：</p>
<p>l         首先，它容易得到。事实上，任何人都可以从互联网上自由地下载这个软件。无论从<a href="http://jakarta.Apache.org还是从其他网站（Jakarta" target="_blank">http://jakarta.Apache.org还是从其他网站（Jakarta</a> Tomcat是Apache软件基金会开发的一个开放源码的应用服务器）。</p>
<p>l         其次，对于开发人员，特别是Java开发人员，Tomcat提供了全部的源代码，包括Servlet引擎、JSP引擎、HTTP服务器。无论是对哪一方面感兴趣的程序员，都可以从这些由世界顶尖的程序员书写的代码中获得收益。</p>
<p>l         最后，由于源代码的开放及世界上许多程序员的卓有成效的工作， Tomcat已经可以和大部分的主流服务器一起工作，而且是以相当高的效率一起工作。如：以模块的形式被载入Apache，以ISAPI形式被载入IIS或PWS，以NSAPI的形式被载入Netscape Enterprise Server。</p>
<p>l         由于Java的跨平台特性，基于Java的Tomcat也具有跨平台性。</p>
<hr>
<hr>
<p><strong>2、Tomcat5.0包含三个主要的部分</strong></p>
<p>包括：
/<em> Catalina - 一个符合Servlet API规范2.3的Servlet Container
/</em> Jasper - 一个符合JSP规范1.2的JSP编译器和运行环境
/* Webapps - Tomcat中包含的一些例子和用于测试的web例程，以及相关文档。</p>
<hr>
<hr>
<p><strong>3、应用服务器（如WebLogic）与Tomcat有何区别。</strong></p>
<pre><code>   应用服务器提供更多的J2EE特征，如EJB，JMS，JAAS等，同时也支持Jsp和Servlet。而Tomcat则功能没有那么强大，它不提供EJB等支持。但如果与JBoss（一个开源的应用服务器）集成到一块，则可以实现J2EE的全部功能。
</code></pre><hr>
<hr>
<p><strong>4、Tomcat 目录的结构</strong></p>
<hr>
<p><strong>（1）Tomcat的安装</strong></p>
<hr>
<pre><code>其实对于完全由Java写成的Tomcat，Win32版本和Linux版本没有多大区别，比如Linux版本，在Solaris下也没有问题。这里，主要以Win32版本作为示例。
</code></pre><p>注意：在安装使用Tomcat之前，先安装JDK，最好是Sun的JDK 1 .2 以上版。</p>
<hr>
<p><strong>（2）Tomcat的目录结构</strong></p>
<p>首先，下载jakarta-tomcat.zip包，解压缩到一个目录下，如：“c:/tomcat”。这时，会得到如下的Tomcat的目录结构：</p>
<ul>
<li><ul>
<li><ul>
<li>jakarta - tomcat</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>| - - - bin             Tomcat执行脚本目录</p>
<p>| - - - Common          放置一些通用类（如JDBC的驱动程序等）</p>
<p>| - - - conf               Tomcat配置文件</p>
<p>| - - - doc                 Tomcat文档</p>
<p>| - - - lib                 Tomcat运行需要的库文件（JARS）</p>
<p>| - - - logs               Tomcat执行时的LOG文件</p>
<p>| - - - src            Tomcat的源代码</p>
<p>| - - - webapps             Tomcat的主要Web发布目录（存放我们自己的JSP,SERVLET,类）</p>
<p>| - - - work            Tomcat的工作目录，Tomcat将翻译JSP文件到的Java文件和class文件放在这里。
<strong>目 录 名</strong></p>
<p><strong>该目录内的文件的一般功能描述</strong>bin</p>
<p>包含有Startup.bat（启动服务器）与shutdown.bat（关闭服务器）文件conf</p>
<p>包含设置部署在Tomcat上的Web应用的变量的初始值的设置文件，包括 <em>server.xml</em> (Tomcat的全局配置文件) 和 <em>web.xml</em> （为不同的Tomcat配置的web应用设置缺省值的文件）doc</p>
<p>包含关于Tomcat的各种各样的文档。common</p>
<p>在其lib目录下，主要存放如JDBC的驱动程序等lib</p>
<p>包含被Tomcat使用的各种各样的jar文件。在UNIX上，任何这个目录中的文件将被附加到Tomcat的classpath中。logs</p>
<p>Tomcat的log文件。src</p>
<p>servlet API的源文件。webapps</p>
<p>包含Web应用的程序 （JSP、Servlet和JavaBean等）work</p>
<p>由Tomcat自动生成，这是Tomcat放置它运行期间的中间(intermediate)文件(诸如编译的JSP文件)地方。 如果当Tomcat运行时，你删除了这个目录那么将不能够执行包含JSP的页面。</p>
<hr>
<p><strong>（3）、各个目录下所应该存放的文件：</strong>按照Tomcat的规范，Tomcat的Web应用程序应该由如下目录组成</p>
<pre><code>     页面内容等文件的存放位置：/*.html, /*.jsp等可以有许多目录层次，由用户的网站结构而定，实现的功能应该是网站的界面，也就是用户主要的可见部分。除了HTML文件、JSP文件外，还有js（JavaScript）文件和css（样式表）文件以及其他多媒体文件等。



     Web-INF/web.xml这是一个Web应用程序的描述文件。这个文件是一个XML文件，描述了Servlet和这个Web应用程序的其他组件信息，此外还包括一些初始化信息和安全约束等等。



    Web-INF/classes/这个目录及其下的子目录应该包括这个Web应用程序的所有JavaBean及Servlet等编译好的Java类文件（/*.class）文件，以及没有被压缩打入JAR包的其他class文件和相关资源。注意，在这个目录下的Java类应该按照其所属的包层次组织目录（即如果该/*.class文件具有包的定义，则该/*.class文件应该放在./WEB-INF/classes/包名下）。









    通常Web-INF/classes/这个目录下的类文件也可以打包成JAR文件,并可以放到WEB-INF下的lib目录下。如将 classes目录下的各个/*.class文件打包成WebMis.jar文件（jar cvf WebMis.jar /*./*）
</code></pre><p><strong>注意：</strong></p>
<p>（1）WEB-INF目录中包含应用软件所使用的资源，但是WEB-INF却不在公共文档根目录之中。在这个目录中所包含的文件都不能被客户机所访问。</p>
<p>（2）类目录中（在WEB-INF下）包含运行Web应用程序时所需的Servlets，Beans等类。</p>
<p>（3）lib目录（在WEB-INF下）包含有Java archive files (JARs)，例如标签库或者Servlets，Beans等类的/*.jar文件。</p>
<p>（4）如果一个类出现在JAR文件中同时也出现在类的目录中，类加载器会加载位于类目录中的那一个。</p>
<pre><code>     common/lib/ 这个目录下包含了所有压缩到JAR文件中的类文件和相关文件。比如：第三方提供的Java库文件、JDBC驱动程序等。

     其中msbase.jar、mssqlserver.jar、msutil.jar文件为SqlServer2000的JDBC驱动程序

     其中servlet-api.jar和jsp-api.jar为Servlet和JSP的API所在的包
</code></pre><p><strong>二、Tomcat的环境配置</strong></p>
<hr>
<hr>
<p><strong>1、启动Tomcat</strong></p>
<p>在Bin目录下，有一个名为startup.bat的脚本文件，执行这个脚本文件，就可以启动Tomcat服务器，不过，在启动服务器之前，还需要进行一些设置。</p>
<p>l         <strong>首先，设置系统的环境变量。</strong></p>
<pre><code>     **TOMCAT_HOME（或者：CATALINA_HOME）值：**
</code></pre><p>d:/jakarta-tomcat-5.0.16 (用TOMCAT_HOME指示Tomcat根目录，下面以Tomcat 5.0.16版为例)。</p>
<pre><code>     **JAVA_HOME值：**
</code></pre><p>c:/j2sdk1.4.0(用JAVA_HOME指示jdk1.4的安装目录)。</p>
<p><strong>注意</strong>：对于设置Windows的系统环境变量，可以打开控制面板中的“系统”程序；在“系统环境变量”中增加两个环境变量项目JAVA_HOME（最好为大写）指向JDK的目录和TOMCAT_HOME（最好为大写）指向所安装的tomcat的目录。</p>
<p><strong>2、启动和关闭Tomcat服务器</strong></p>
<p>（1）启动Tomcat服务器：执行在Bin目录下的名为startup.bat的脚本文件可以启动Tomcat服务器</p>
<p>现在可以运行TOMCAT并作为一个独立的Servlet容器。</p>
<hr>
<p><strong>（2）测试Tomcat的服务器启动与否：</strong></p>
<p>可以在浏览器中输入<a href="http://127.0.0.1:8080/index.html" target="_blank"><a href="http://127.0.0.1:8080/index.jsp">http://127.0.0.1:8080/index.jsp</a></a>，是否出现如下内容。</p>
<hr>
<hr>
<p><strong>（3）启动本站点的JSP页面：</strong>在Tomcat中的JSP文件和JavaBean程序的存放位置</p>
<pre><code>     JSP文件放在“Webapps/站点名称”的目录下

    自定义的JavaBean程序/*.java文件（可以不需要它）及/*.class类文件存放在“Webapps/站点名称/ WEB-INF/classes/”目录下****
</code></pre><p>因此，将/*.jsp文件拷贝到“TOMCAT_HOME/Webapps/站点名称”目录下，然后输入其URL地址</p>
<p><strong>（4）关闭Tomcat服务器：</strong>执行在Bin目录下的名为shutdown.bat的脚本文件可以终止Tomcat服务器。</p>
<hr>
<p><strong>三、配置Tomcat服务器</strong></p>
<hr>
<p><strong>1、概述</strong></p>
<p>Tomcat为用户提供了一系列的配置文件来帮助用户配置自己的Tomcat，Tomcat的配置文件主要是基于XML的；如server.xml、web.xml等，下面将详细讨论Tomcat的主要配置文件以及如何利用这些配置文件解决常见问题。</p>
<hr>
<p><strong>2、server.xml 主配置文件</strong></p>
<p>server.xml是Tomcat的主配置文件，主要完成如下两个目标：</p>
<pre><code>     提供Tomcat组件的初始配置；

     说明Tomcat的结构,含义,使得Tomcat通过实例化组件完成起动及构建自身。
</code></pre><p>观察<strong>server.xml</strong>，可以发现其中有如下的一些元素。</p>
<p>（1）Server元素：</p>
<p>Server元素是<strong>server.xml</strong>文件的最高级别的元素， Server元素描述一个Tomcat服务器，一般来说用户不用关心这个元素。一个Server元素一般会包括Logger和ContextManager两个元素</p>
<pre><code>     Logger：Logger元素定义了一个日志对象，一个日志对象包含有如下属性：
</code></pre><p>1) name：表示这个日志对象的名称。</p>
<p>2) path：表示这个日志对象包含的日志内容要输出到哪一个日志文件。</p>
<p>3) verbosityLevel：表示这个日志文件记录的日志的级别。</p>
<p>一般来说，Logger对象是对Java Servlet、JSP和Tomcat运行期事件的记录</p>
<pre><code>     ContextManager：ContextManager定义了一组ContextInterceptors（ContextManager的事件监听器） , RequestInterceptors（的事件监听器）、Contexts（Web应用程序的上下文目录）和它们的Connectors（连接器）的结构和配置。ContextManager包含如下一些属性：
</code></pre><p>1) debug：记录日志记录调试信息的等级。</p>
<p>2) home：webapps /、conf /、logs /和所有Context的根目录信息。这个属性的作用是从一个不同于TOMCAT _ HOME的目录启动Tomcat。</p>
<p>3) workDir：Tomcat工作目录。</p>
<p>ContextInterceptor 和RequestInterceptors两者都是监听ContextManager的特定事件的拦截器。ContextInterceptor监听Tomcat的启动和结束事件信息。而RequestInterceptors监听用户对服务器发出的请求信息。一般用户无需关心这些拦截器，对于开发人员需要了解这就是全局性的操作得以实现的方法</p>
<hr>
<p><strong>（2）Connector元素：</strong></p>
<p>Connector（连接器）元素描述了一个到用户的连接，不管是直接由Tomcat到用户的浏览器还是通过一个Web服务器。Tomcat的工作进程和由不同的用户建立的连接传来的读/写信息和请求/答复信息都是由连接器对象管理的。对连接器对象的配置中应当包含管理类、TCP/IP端口等内容。<em>**</em></p>
<hr>
<p><strong>（3）Context元素：</strong></p>
<p>每一个Context都描述了一个Tomcat的Web应用程序的目录。这个对象包含以下属性：</p>
<p>1)docBase。这是Context的目录。可以是绝对目录也可以是基于ContextManage的根目录的相对目录。</p>
<p>2)path。这是Context在Web服务时的虚拟目录位置和目录名。</p>
<p>3)debug。日志记录的调试信息记录等级。</p>
<p>4)reloadable。这是为了方便Servlet的开发人员而设置的，当这个属性开关打开的时候，Tomcat将检查Servlet是否被更新而决定是否自动重新载入它</p>
<p>3、<strong>配置实例</strong>：打开Tomcat下的conf文件夹下的server.xml文件</p>
<p>（1）改变Tomcat服务器的端口号</p>
<p>需要使用Connector 元素，Connector表示一个到用户的联接,不管是通过web服务器或直接到用户浏览器(在一个独立配置中)。Connector负责管理Tomcat的工作线程和读/写连接到不同用户的端口的请求/响应。Connector的配置包含如下信息：句柄类、句柄监听的TCP/IP端口、句柄服务器端口的TCP/IP的backlog。修改后，必须重新启动Tomcat的服务器。</p>
<p><strong>注意：</strong>可以将端口号改变为80，单要保证80端口没有被占用；另外，也可以同时分配两个端口号，只要产生两个Connector的配置信息。</p>
<p><strong>    <!-- Define a non-SSL Coyote HTTP/1.1 Connector on port 8080 --></strong></p>
<p><strong>   &lt;Connector port=&quot;8080&quot;    maxThreads=&quot;150&quot; minSpareThreads=&quot;25&quot; maxSpareThreads=&quot;75&quot;</strong></p>
<p><strong>     enableLookups=&quot;false&quot; redirectPort=&quot;8443&quot; acceptCount=&quot;100&quot;  debug=&quot;0&quot; connectionTimeout=&quot;20000&quot;  disableUploadTimeout=&quot;true&quot; /&gt;</strong></p>
<hr>
<p><strong>    <!-- Define a non-SSL Coyote HTTP/1.1 Connector on port 8000 --></strong></p>
<p><strong>    &lt;Connector port=&quot;8000&quot;    maxThreads=&quot;150&quot; minSpareThreads=&quot;25&quot; maxSpareThreads=&quot;75&quot;</strong></p>
<p><strong>enableLookups=&quot;false&quot; redirectPort=&quot;8443&quot; acceptCount=&quot;100&quot;  debug=&quot;0&quot; connectionTimeout=&quot;20000&quot;  disableUploadTimeout=&quot;true&quot; /&gt;</strong></p>
<p>（2）增加新的虚拟目录并指向物理目录</p>
<p>设立一个虚拟工作目录是比较简单的，只需要在server.xml文件中添加一个Context对象就可以了。如，要在webapps/下增加一个WebMis文件夹以存放jsp页面文件，并且让用户可以使用<a href="http://127.0.0.1:8080/WebMis虚拟目录访问，则：需要使用Context" target="_blank">http://127.0.0.1:8080/WebMis虚拟目录访问，则：需要使用Context</a> 元素，每个Context提供一个指向你放置你Web项目的Tomcat的下属目录。每个Context包含如下配置：  </p>
<p>l         Context放置的路径，可以是与ContextManager主目录相关的路径；</p>
<p>l         纪录调试信息的调试级别；</p>
<p>l         可重载的标志，开发Servlet时，重载更改后的Servlet。这是一个非常便利的特性,你可以调试或用Tomcat测试新代码而不用停止或重新启动Tomcat。要打开重载,把reloadable设为true即可。</p>
<p>其中：path=&quot;/WebMis&quot;说明其相对web URL的路径，是一个虚拟的路径，如：<a href="http://127.0.0.1:8080/WebMis" target="_blank"><a href="http://127.0.0.1:8080/WebMis">http://127.0.0.1:8080/WebMis</a></a>，docBase=&quot;WebMis&quot;说明其相对webapps的位置，是物理存在的目录，同时需要在webapps/下增加一个WebMis物理文件夹。</p>
<p>（3）       加入自己的日志文件</p>
<p>添加Logger对象就可以加入自己的日志文件，添加工作相当简单，只需要将作为示例的Logger对象复制一份，然后修改一下前面介绍的几个属性就可以了。在设定了Logger以后，就可以在自己的Servlet中使用ServletContext.log()方法来建立自己的日志文件。</p>
<p>4、<strong>配置实例</strong>：打开conf文件夹下的web.xml文件</p>
<p>（1）web.xml文件：它包含了描述整个Web应用程序（Web应用程序由一整套Web文件jsp、servlet、html、jpg、gif、class等组成）的信息。下面以一个web.xml文件为例，讲解里面的各个对象。</p>
<p>&lt;!DOCTYPE web-app PUBLIC &quot;-//Sun Microsystems, Inc.//DTD Web Application 2.2//EN&quot;</p>
<p>&quot;<a href="http://java.sun.com/j2ee/dtds/web-app_2_2.dtd&quot;&gt;" target="_blank">http://java.sun.com/j2ee/dtds/web-app_2_2.dtd&quot;&gt;</a></p>
<web-app>

<p><display-name>My Web Application</display-name></p>
<description>在这里加入Web应用程序的描述信息</description>

<p>&lt;!-</p>
<p>下面定义了Web应用程序的初始化参数，在JSP或Servlet文件中使用下面的语句</p>
<p>来得到初始化参数</p>
<p>String value =</p>
<p>getServletContext().getInitParameter(&quot;name&quot;);</p>
<p>这里可以定义任意多的初始化参数</p>
<p>--&gt;</p>
<context-param>

<p><param-name>webmaster</param-name></p>
<p><param-value>myaddress@mycompany.com</param-value></p>
<description>这里包含了初始化参数的描述</description>

<p></context-param></p>
<p>&lt;!-</p>
<p>下面的定义描述了组成这个Web应用程序的Servlet，还包含初始化参数。在Tomcat中，也可以将放在Web-INF/classes中的Servlet直接以servlet/Servlet名访问，但是一般来说，不推荐这样使用。而且这样的使用方法还会导致Servlet的相关资源组织的复杂性。所以一般来说推荐将所有的Servlet在这里定义出来。初始化参数可以在Servlet中使用如下语句来获得：</p>
<p>String value =getServletConfig().getInitParameter(&quot;name&quot;);</p>
<p>--&gt;</p>
<servlet>

<servlet-name>controller</servlet-name>

<description>这里加入这个Servlet的描述</description>

<servlet-class>com.mycompany.mypackage.ControllerServlet</servlet-class>

<strong><init-param></strong>

<strong><param-name>listOrders</paramName></strong>

<strong><param-value>com.mycompany.myactions.ListOrdersAction</param-value></strong>

<strong></init-param></strong>

<init-param>

<param-name>saveCustomer</paramName>

<param-value>com.mycompany.myactions.SaveCustomerAction</param-value>

</init-param>

&lt;!-

服务器启动后这个Servlet加载的时间

--&gt;

<load-on-startup>5</load-on-startup>

</servlet>

<servlet>

<servlet-name>graph</servlet-name>

<description>这个Servlet的描述</description>

</servlet>

<p>&lt;!-</p>
<p>Servlet映射对应了一个特殊的URI请求到一个特殊的Servlet的关系</p>
<p>--&gt;</p>
<servlet-mapping>

<p><servlet-name>controller</servlet-name></p>
<p><url-pattern>/*.do</url-pattern></p>
<p></servlet-mapping></p>
<servlet-mapping>

<p><servlet-name>graph</servlet-name></p>
<p><url-pattern>/graph</url-pattern></p>
<p></servlet-mapping></p>
<p>&lt;!-</p>
<p>设定缺省的Session过期时间（单位为分）</p>
<p>--&gt;</p>
<session-config>

<p><session-timeout>30</session-timeout></p>
<p></session-config></p>
<p></web-app><em>**</em></p>
<p><strong>（2）配置实例：会话(session)超时修改，</strong>修改conf/web.xml中的如下数据值（单位为分）</p>
<p><strong>5、在Tomcat中实现利用JDBC驱动程序访问SQLServer2000数据库</strong></p>
<p>只需要将SQLServer2000的JDBC驱动程序的三个/<em>.jar（msbase.jar、mssqlserver.jar和msutil.jar）文件放在/common/lib目录下，然后在/</em>.java程序中访问它。</p>
<p><strong>四、在Tomcat5中配置连接池和数据源</strong></p>
<hr>
<p><strong>1、DataSource接口介绍</strong></p>
<hr>
<p><strong>（1）DataSource 概述</strong></p>
<p>JDBC1.0原来是用DriverManager类来产生一个对数据源的连接。JDBC2.0用一种替代的方法，使用DataSource的实现，代码变的更小巧精致，也更容易控制。</p>
<p>一个DataSource对象代表了一个真正的数据源。根据DataSource的实现方法，数据源既可以是从关系数据库，也电子表格，还可以是一个表格形式的文件。当一个DataSource对象注册到名字服务中（JNDI），应用程序就可以通过名字服务获得DataSource对象，并用它来产生一个与DataSource代表的数据源之间的连接。</p>
<p>javax.sql包中的DataSource接口，可以采用三种实现形式：简单的实现（只提供Connection对象）、连接池形式的实现和分布式事务形式的实现。</p>
<p>javax.sql包中的ConnectionPoolDataSource提供对连接池实现的接口。</p>
<p><strong>（2）使用DataSource的优点</strong></p>
<p>l         DataSource与DriverManager的不同</p>
<p>关于数据源的信息和如何来定位数据源，例如数据库服务器的名字，在哪台机器上，端口号等等，都包含在DataSource对象的属性里面去了。这样，对应用程序的设计来说是更方便了，因为并不需要硬性的把驱动的名字写死到程序里面去。通常驱动名字中都包含了驱动提供商的名字，而在DriverManager类中通常是这么做的。</p>
<p>l         可移植性</p>
<p>如果数据源要移植到另一个数据库驱动中，代码也很容易做修改。所需要做的修改只是更改DataSource的相关的属性。而使用DataSource对象的代码不需要做任何改动。</p>
<p><strong>（3）配置DataSource</strong></p>
<p>主要包括设定DataSource的属性，然后将它注册到JNDI名字服务中去。在注册DataSource对象的的过程中，系统管理员需要把DataSource对象和一个逻辑名字关联起来。名字可以是任意的，通常取成能代表数据源并且容易记住的名字。</p>
<p>在下面的例子中，名字起为：WebMisDB，按照惯例，逻辑名字通常都在jdbc的子上下文中。这样，逻辑名字的全名就是：jdbc/WebMisDB。</p>
<p><strong>（4）产生一个与数据源的连接</strong></p>
<p>一旦配置好了数据源对象，应用程序设计者就可以用它来产生一个与数据源的连接。下面的代码片段示例了如何用JNDI上下文获得一个数据源对象，然后如何用数据源对象产生一个与数据源的连接。开始的两行用的是JNDI API，第三行用的才是JDBC的API： 
Context ctx = new InitialContext(); </p>
<p>DataSource ds = (DataSource)ctx.lookup(&quot;jdbc/WebMisDB&quot;);</p>
<p>Connection con = ds.getConnection(&quot;myPassword&quot;, &quot;myUserName&quot;); 
在一个基本的DataSource实现中，DataSource.getConnection方法返回的Connection对象和用DriverManager.getConnection方法返回的Connection对象是一样的。因为DataSource提供的方便性，我们推荐使用DataSource对象来得到一个Connection对象。</p>
<p><strong>（5）DataSource的应用场合</strong></p>
<p>对于普通的应用程序设计者，是否使用DataSource对象只是一个选择问题。但是，对于那些需要用的连接池或者分布式的事务的应用程序设计者来说，就必须使用DataSource对象来获得Connection。需要注意的是对Tomcat而言，在JNDI的名称前面应该加上&quot;java:comp/env/&quot; </p>
<p><strong>（6）数据源（DataSource）的作用</strong></p>
<p>它相当于客户端程序和连接池的中介，想要获得连接池中的连接对象，必须建立一个与该连接池相应的数据源，然后通过该数据源获得连接。</p>
<p><strong>2、JNDI（</strong>JAVA NAMING AND DIRECTORY INTERFACE---Java 命名和目录接口<strong>）</strong></p>
<p><strong>（1）</strong>JNDI简介<em>**</em></p>
<p>分布式计算环境通常使用命名和目录服务来获取共享的组件和资源。命名和目录服务将名称与位置、服务、信息和资源关联起来。它是一个为JAVA应用程序提供命名服务的应用程序编程接口（API）。</p>
<p>命名服务提供了一种为对象命名的机制，这样你就可以在无需知道对象位置的情况下获取和使用对象。只要该对象在命名服务器上注册过，且你必须知道命名服务器的地址和该对象在命名服务器上注册的JNDI名。就可以找到该对象，获得其引用，从而运用它提供的服务。</p>
<p>命名服务提供名称—对象的映射。目录服务提供有关对象的信息，并提供定位这些对象所需的搜索工具。</p>
<p>Java 命名和目录接口或 JNDI 提供了一个用于访问不同的命名和目录服务的公共接口（JAVA API）。运用一个命名服务来查找与一个特定名字相关的一个对象，JDBC可以用JNDI来访问一个关系数据库。</p>
<p><strong>（2）获得JNDI的初始环境</strong></p>
<p>在JNDI中，在目录结构中的每一个结点称为Context 。每一个JNDI名字都是相对于Context 的。这里没有绝对名字的概念存在。对一个应用来说，它可以通过使用InitialContext 类来得到其第一个Context：</p>
<p>Context  ctx = new InitialContext ();</p>
<p>应用可以通过这个初始化的Context经由这个目录树来定位它所需要的资源或对象。InitialContext在网页应用程序初始化时被设置，用来支持网页应用程序组件。所有的入口和资源都放在JNDI命名空间里的java:comp/env段里。</p>
<p><strong>（3）查找已绑定的对象</strong></p>
<p>用ctx..lookup(String name); 根据name找对象</p>
<p>例：</p>
<p>import javax.naming./*;</p>
<p>public class TestJNDI</p>
<p>{    </p>
<p>public static void main(String[] args)</p>
<p>{</p>
<pre><code>    try
</code></pre><p>{</p>
<pre><code>    Context ctx=new InitialContext();

    Object object=ctx.lookup(“JNDIName”);       //根据JNDI名查找绑定的对象

    String str=(String) object;                                 //强制转换

    }
</code></pre><p>catch(NamingException e)</p>
<p>{    e.printStackTrace();</p>
<pre><code>    }
</code></pre><p>catch(ClassCastException e)</p>
<p>{    e.printStackTrace();</p>
<pre><code>    }
</code></pre><p>   }</p>
<p>}<em>**</em></p>
<hr>
<p><strong>3、数据库连接池技术</strong></p>
<hr>
<p><strong>（1）</strong>传统的Web数据库编程模式</p>
<p>l         在主程序（如Servlet、Beans）中建立数据库连接。</p>
<p>l         进行SQL操作，取出数据。</p>
<p>l         断开数据库连接。</p>
<p>使用这种模式开发，存在很多问题。</p>
<p>l         首先，我们要为每一次WEB请求（例如察看某一篇文章的内容）建立一次数据库连接，对于一次或几次操作来讲，或许你觉察不到系统的开销，但是，对于WEB程序来讲，即使在某一较短的时间段内，其操作请求数也远远不是一两次，而是数十上百次（想想全世界的网友都有可能在您的网页上查找资料），在这种情况下，系统开销是相当大的。事实上，在一个基于数据库的WEB系统中，建立数据库连接的操作将是系统中代价最大的操作之一。很多时候，可能您的网站速度瓶颈就在于此。</p>
<p>l         其次，使用传统的模式，你必须去管理每一个连接，确保他们能被正确关闭，如果出现程序异常而导致某些连接未能关闭，将导致数据库系统中的内存泄露，最终我们将不得不重启数据库。<em>**</em></p>
<p>l         频繁的建立、关闭连接，会极大的减低系统的性能，因为对于连接的使用成了系统性能的瓶颈。<em>**</em></p>
<hr>
<p><strong>（2）数据库连接是一种关键的有限的昂贵的资源</strong></p>
<p>这一点在多用户的网页应用程序中体现得尤为突出。对数据库连接的管理能显著影响到整个应用程序的伸缩性和健壮性，影响到程序的性能指标。数据库连接池正是针对这个问题提出来的。</p>
<p>连接池是这么一种机制，当应用程序关闭一个Connection的时候，这个连接被回收，而不是被destroy，因为建立一个连接是一个很费资源的操作。如果能把回收的连接重新利用，会减少新创建连接的数目，显著的提高运行的性能。该策略的核心思想是：连接复用。</p>
<p>通过采用连接池的方法，服务器在启动时先打开一定数量的连接。当应用需要连接时，就可以从服务器请求一个连接。当应用结束该连接时，服务器就把它释放到连接池，以备其他客户机使用。
客户获得连接并访问数据库以后结束客户获得连接并访问数据库以后结束客户获得连接并访问数据库以后结束开始停止服务吗</p>
<p>？产生新的连接等待引入的连接结束是服务器监听客户的连接请求                    客户获得连接</p>
<p><strong>（3）连接池的主要作用</strong></p>
<p>l         减少了建立和释放数据库连接的消耗</p>
<p>l         数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而再不是重新建立一个；</p>
<p>l         释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏。这项技术能明显提高对数据库操作的性能。</p>
<p>l         封装用户信息  使用连接池可以封装连接数据库系统所用的用户信息（帐号和密码），这样客户端程序在建立连接时不用考虑安全信息。</p>
<p><strong>（4）数据库连接池的工作原理</strong></p>
<pre><code>   当程序中需要建立数据库连接时，只须从内存中取一个来用而不用新建。同样，使用完毕后，只需放回内存即可。而连接的建立、断开都有连接池自身来管理。同时，我们还可以通过设置连接池的参数来控制连接池中的连接数、每个连接的最大使用次数等等
</code></pre><p><strong>（5）数据库连接池的最小连接数和最大连接数</strong></p>
<p>数据库连接池的最小连接数和最大连接数的设置要考虑到下列几个因素：</p>
<p>l         最小连接数是连接池一直保持的数据库连接，所以如果应用程序对数据库连接的使用量不大，将会有大量的数据库连接资源被浪费；</p>
<p>l         最大连接数是连接池能申请的最大连接数，如果数据库连接请求超过此数，后面的数据库连接请求将被加入到等待队列中，这会影响之后的数据库操作。</p>
<p>如果最小连接数与最大连接数相差太大，那么最先的连接请求将会获利，之后超过最小连接数量的连接请求等价于建立一个新的数据库连接。不过，这些大于最小连接数的数据库连接在使用完不会马上被释放，它将被放到连接池中等待重复使用或是空闲超时后被释放。</p>
<p><strong>（6）使用连接池得到连接</strong>
假设应用程序需要建立到一个名字为EmpolyeeDB的DataSource的连接。使用连接池得到连接的代码如下： 
Context ctx = new InitialContext(); </p>
<p>DataSource ds = (DataSource)ctx.lookup(&quot;jdbc/EmployeeDB&quot;);</p>
<p>Connection con = ds.getConnection(&quot;myPassword&quot;, &quot;myUserName&quot;);</p>
<p>或者：</p>
<p>Context ctx = new InitialContext(); </p>
<p>ConnectionPoolDataSource ds = (ConnectionPoolDataSource)ctx.lookup(&quot;jdbc/EmployeeDB&quot;);</p>
<p>PooledConnection con = ds.getConnection(&quot;myPassword&quot;, &quot;myUserName&quot;);</p>
<p>是否使用连接池获得一个连接，在应用程序的代码上是看不出不同的。在使用这个Connection连接上也没有什么不一样的地方，唯一的不同是在java的finally语句块中来关闭一个连接。在finally中关闭连接是一个好的编程习惯。这样，即使方法抛出异常，Connection也会被关闭并回收到连接池中去。代码应该如下所示： 
try</p>
<p>{… 
}</p>
<p>catch（）</p>
<p>{… 
}</p>
<p>finally</p>
<p>{ </p>
<p>if（con!=null）</p>
<p>con.close();</p>
<p>}<em>**</em></p>
<hr>
<p><strong>4、在Tomcat中配置数据库的连接池</strong></p>
<hr>
<p><strong>（1）连接池配置(Database Connection Pool (DBCP) Configurations)</strong></p>
<p>DBCP使用的是Jakarta-Commons Database Connection Pool 要使用连接池需要如下的组件即jar文件。</p>
<p>l         Jakarta-Commons DBCP 1.1 对应commons-dbcp-1.1.jar。</p>
<p>l         Jakarta-Commons Collections 2.0 对应commons-collections.jar。</p>
<p>l         Jakarta-Commons Pool 1.1 对应commons-pool-1.1.jar。</p>
<p>这三个jar文件要与你的JDBC驱动程序一起放到【TOMCAT_HOME】/common/lib目录下以便让tomcat和你的web应用都能够找到。</p>
<hr>
<p><strong>注：</strong></p>
<p>l         这三个jar文件是默认存在与【TOMCAT_HOME】/common/lib下的。</p>
<p>l         需要注意的地方：第三方的驱动程序或者其他类只能以/<em>.jar的形式放到Tomcat的common/lib目录中,因为Tomcat只把/</em>.jar文件加到CLASSPATH中。</p>
<p>l         不要把上诉三个文件放到WEB-INF/lib或者其他地方因为这样会引起混淆。<em>**</em></p>
<hr>
<p><strong>（2）通过配置阻止连接池漏洞</strong></p>
<p>数据库连接池创建和管理连接池中建立好的数据库连接，循环使用这些连接以得到更好的效率。这样比始终为一个用户保持一个连接和为用户的请求频繁的建立和销毁数据库连接要高效的多。</p>
<p>这样就有一个问题出现了，一个Web应用程序必须显示的释放ResultSet，Statement和Connection。如果在关闭这些资源的过程中失败将导致这些资源永远不在可用，这就是所谓的连接池漏洞。这个漏洞最终会导致连接池中所有的连接不可用。</p>
<p>通过配置Jakarta Common DBCP可以跟踪和恢复那些被遗弃的数据库连接。</p>
<p>以下是一系列相关配置：</p>
<p>l         通过配置DBCP数据源中的参数removeAbandoned来保证删除被遗弃的连接使其可以被重新利用。</p>
<p>为ResourceParams(见下文的数据源配置)标签添加参数removeAbandoned</p>
<parameter>

<name>removeAbandoned</name>

<value>true</value>

</parameter>

<p>通过这样配置的以后当连接池中的有效连接接近用完时DBCP将试图恢复和重用被遗弃的连接。这个参数的值默认是false。</p>
<p>l         通过设置removeAbandonedTimeout来设置被遗弃的连接的超时的时间，即当一个连接连接被遗弃的时间超过设置的时间时那么它会自动转换成可利用的连接。</p>
<pre><code>&lt;parameter&gt;

 &lt;name&gt;removeAbandonedTimeout&lt;/name&gt;

 &lt;value&gt;60&lt;/value&gt;

 &lt;/parameter&gt;

默认的超时时间是300秒。
</code></pre><p>l         设置logAbandoned参数，以将被遗弃的数据库连接的回收记入日志中</p>
<parameter>

<name>logAbandoned</name>

<value>true</value>

</parameter>

<p>这个参数默认为false。<em>**</em></p>
<p><strong>（3）修改server.xml文件</strong></p>
<pre><code>   &lt;Context path=&quot;/WebMis&quot; docBase=&quot;WebMis&quot; debug=&quot;0&quot; reloadable=&quot;true&quot;&gt;



               &lt;Resource name=&quot;jdbc/webmis&quot; auth=&quot;Container&quot; type=&quot;javax.sql.DataSource&quot;/&gt;  

               &lt;ResourceParams** name=&quot;jdbc/webmis&quot;**&gt;      

                             &lt;parameter&gt;             

                                     &lt;name&gt;

                                            factory

                                     &lt;/name&gt;        

                                     &lt;value&gt;org.apache.commons.dbcp.BasicDataSourceFactory

                                     &lt;/value&gt;        

                          &lt;/parameter&gt;

                          &lt;parameter&gt;             

                                   &lt;name&gt;

                                          driverClassName

                                   &lt;/name&gt;        

                                     &lt;value&gt;**com.microsoft.jdbc.sqlserver.SQLServerDriver**

                                     &lt;/value&gt;        

                              &lt;/parameter&gt;

                             &lt;parameter&gt;      

                                     &lt;name&gt;

                                            url

                                     &lt;/name&gt;        

                           &lt;value&gt;**jdbc:microsoft:sqlserver://127.0.0.1:1433;DatabaseName=DataBase**

                          &lt;/value&gt;

                             &lt;/parameter&gt;            

                             &lt;parameter&gt;

                                        &lt;name&gt;

                                               username

                                         &lt;/name&gt;             

                                     &lt;value&gt;

                                          **sa**

                                     &lt;/value&gt;

                            &lt;/parameter&gt;            

                             &lt;parameter&gt;

                                        &lt;name&gt;

                                               password

                                        &lt;/name&gt;

                                        &lt;value&gt;
</code></pre><p>maxActive 连接池的最大数据库连接数。设为0表示无限制。                                            </value> </p>
<pre><code>                             &lt;/parameter&gt;            

                             &lt;parameter&gt;



                                        &lt;name&gt;

                                               maxActive

                                        &lt;/name&gt;

                                        &lt;value&gt;

                                               20
</code></pre><p>回收被遗弃的（一般是忘了释放的）数据库连接到连接池中，设为－1表示无限制。maxIdle  数据库连接的最大空闲时间。超过此空闲时间，数据库连接将被标记为不可用，然后被释放。设为0表示无限制。                                            </value></p>
<pre><code>                             &lt;/parameter&gt;

                             &lt;parameter&gt;             

                                    &lt;name&gt;

                                             maxIdle

                                      &lt;/name&gt;
</code></pre><p>maxWait 最大建立连接等待时间。如果超过此时间将接到异常。设为－1表示无限制。                                        <value>10</value></p>
<pre><code>                            &lt;/parameter&gt;

                            &lt;parameter&gt;

                                        &lt;name&gt;maxWait&lt;/name&gt;

                                        &lt;value&gt;-1&lt;/value&gt;

                          &lt;/parameter&gt; 
</code></pre><parameter>
  <name>removeAbandoned</name>
  <!-- Abandoned DB connections are removed and recycled -->
  <value>true</value>
 </parameter>
 <parameter>
  <name>removeAbandonedTimeout</name>
  <!-- Use the removeAbandonedTimeout parameter to set the number of seconds a DB connection has been idle before it is considered abandoned.  -->
  <value>60</value>
 </parameter>
 <parameter>
  <name>logAbandoned</name>
  <!-- Log a stack trace of the code which abandoned -->
  <value>false</value>
 </parameter>    

<p>数据库连接过多长时间不用将被视为被遗弃而收回连接池中将被遗弃的数据库连接的回收记入日志                   </ResourceParams></p>
<pre><code>          &lt;/Context&gt;
</code></pre><p>注意：</p>
<p>l         所有的入口和资源都放在JNDI命名空间里的java:comp/env段里</p>
<p>l         设置JNDI资源要在$CATALINA_HOME/conf/server.xml文件里使用下列标志符：
1) <Resource>--设置应用程序可用的资源的名字和类型（同上面说的<resource-ref>等价）。
2) <ResourceParams>--设置Java资源类工厂的名称或将用的JavaBean属性。
上述这些标志符必须放在<Context>和</Context>之间</p>
<hr>
<p><strong>（2）、拷贝SQLServer的JDBC驱动程序到Tomcat的/common/lib目录下</strong></p>
<hr>
<p><strong>（3）、在程序中利用数据源来访问数据库</strong></p>
<pre><code>          try

          {

                 Context initCtx = new InitialContext();

               Context envCtx = (Context) initCtx.lookup(&quot;java:comp/env&quot;);

            DataSource ds = (DataSource)envCtx.lookup(&quot;jdbc/webmis&quot;);

             Connection con=ds.getConnection();

      }

    catch (NamingException e)

       {

               e.printStackTrace();

        }

        catch (SQLException e)

       {

               e.printStackTrace();

         }
</code></pre><hr>
<p><strong>5、在server.xml文件中与数据源的描述相关的标签含义</strong></p>
<p>l         maxActive 连接池的最大数据库连接数。设为0表示无限制。<em>**</em></p>
<p>l         maxIdle  数据库连接的最大空闲时间。超过此空闲时间，数据库连接将被标记为不可用，然后被释放。设为0表示无限制。<em>**</em></p>
<p>l         maxWait 最大建立连接等待时间。如果超过此时间将接到异常。设为－1表示无限制。<em>**</em></p>
<p>l         removeAbandoned 回收被遗弃的（一般是忘了释放的）数据库连接到连接池中。<em>**</em></p>
<p>l         removeAbandonedTimeout 数据库连接过多长时间不用将被视为被遗弃而收回连接池中。<em>**</em></p>
<p>l         logAbandoned 将被遗弃的数据库连接的回收记入日志。<em>**</em></p>
<p>l         driverClassName JDBC驱动程序。<em>**</em></p>
<p>l         url   数据库DSN连接字符串<em>**</em></p>
<p><strong>6**</strong>、在Web应用的web.xml文件中引用该资源**</p>
<p>将下面的标签放在放在<web-app>和</web-app>中间</p>
<p><strong><!-- Database Config start --></strong></p>
<p><strong><resource-ref></strong></p>
<p><strong><description>connectDB test</description></strong></p>
<p><strong><res-ref-name>jdbc/webmis</res-ref-name></strong></p>
<p><strong><res-type>javax.sql.DataSource</res-type></strong></p>
<p><strong><res-auth>Container</res-auth></strong></p>
<p><strong></resource-ref></strong></p>
<p><strong><!-- Database Config end --></strong></p>
<p><strong>4，综合配置实例</strong></p>
<p>首先在C:根目录下建立文件夹mywebapp，作为一个虚拟目录的位置。</p>
<p>建立一个Sql Server数据库DataBonus</p>
<p>找到C:/jakarta-tomcat-5.0.19/conf/server.xml，打开。</p>
<p>加入：</p>
 <Context path="/mywebapp" docBase="C:/mywebapp" debug="0" reloadable="true">



       <Resource name="jdbc/mybonusds" auth="Container" type="javax.sql.DataSource"/><br>
<ResourceParams name="jdbc/mybonusds"><br>
              <parameter><br>
                 <name>factory</name><br>
                 <value>org.apache.commons.dbcp.BasicDataSourceFactory</value><br>
              </parameter>

              <parameter><br>
                 <name>driverClassName</name><br>
                 <value>com.microsoft.jdbc.sqlserver.SQLServerDriver</value><br>
              </parameter>

              <parameter><br>
                  <name>url</name><br>
                  <value>

jdbc:microsoft:sqlserver://127.0.0.1:1433;DatabaseName=DataBonus

                   </value>

               </parameter><br>
               <parameter>

                 <name>username</name><br>
                 <value>sa</value>

                </parameter><br>
                <parameter>

                   <name>password</name>

                   <value></value><br>
                </parameter><br>
                <parameter>

<name>maxActive</name>

                    <value>20</value>

                </parameter>

                <parameter><br>
                   <name>maxIdle</name>

                   <value>10</value>

                </parameter>

                <parameter><br>
                   <name>maxWait</name>

                   <value>-1</value>

                </parameter><br>
<parameter>

             <name>removeAbandoned</name>

             <!-- Abandoned DB connections are removed and recycled -->

             <value>true</value>

          </parameter>

          <parameter>

              <name>removeAbandonedTimeout</name>

  <!-- Use the removeAbandonedTimeout parameter to set the number of seconds a DB connection has been idle before it is considered abandoned.  -->

              <value>60</value>

           </parameter>

           <parameter>

              <name>logAbandoned</name>

            <!-- Log a stack trace of the code which abandoned -->

              <value>false</value>

           </parameter><br>
         </ResourceParams>

</Context>



<p>   做一个JSP页面index.jsp放到mywebapp下面，代码：</p>
<p>&lt;%--字符集设为&quot;gb2312&quot;,使动态页面支持中文--%&gt;</p>
<p>&lt;%@ page contentType=&quot;text/html; charset=GB2312&quot;%&gt;</p>
<!-- 这里使用一个字串变量 ("PAGETITLE") 保持题目和主标题的一致性。-->

<html>

<head>

<title>

&lt;%= pagetitle %&gt;

</title>

</head>



<body bgcolor=/#FFFFFF>



<font face="Helvetica">



<h2>

<font color=/#DB1260>

&lt;%= pagetitle %&gt;

</font>

</h2>



<!-- 导入必要的类和类库 -->



&lt;%@ page import=&quot;

    javax.naming./<em>,

    java.sql./</em>,

    javax.sql.DataSource

&quot;%&gt;



<!-- 声明一个类方法 -->



&lt;%!

//声明变量

//标题

  String pagetitle = &quot;这是JSP调用数据库的例子&quot;;



%&gt;



<!-- 下面这些代码将被插入到servlet中 -->



&lt;%



   java.sql.Connection conn= null;

   java.sql.Statement stmt =null;

   java.sql.ResultSet rs=null;



  try {

    // 通过JNDI获取主接口



     Context initCtx = new InitialContext();

     Context envCtx = (Context) initCtx.lookup(&quot;java:comp/env&quot;);

     DataSource ds = (DataSource)envCtx.lookup(&quot;jdbc/mybonusds&quot;);

     conn=ds.getConnection();



      stmt = conn.createStatement();





           //执行SQL语句

      stmt.execute(&quot;select /* from 奖金&quot;);

    //取得结果集

      rs = stmt.getResultSet();



    %&gt;



  <table border="1">

   <tr>

      <td width="60" height="20">&lt;% out.print(&quot;编号&quot;); %&gt;</td>

      <td width="80" height="20">&lt;% out.print(&quot;姓名&quot;); %&gt;</td>

      <td width="200" height="20">&lt;% out.print(&quot;发奖名称&quot;); %&gt;</td>

      <td width="100" height="20">&lt;% out.print(&quot;金额&quot;); %&gt;</td>

      <td width="200" height="20">&lt;% out.print(&quot;备注&quot;); %&gt;</td>

   </tr>

  &lt;%   while (rs.next()) {



  %&gt;

    <tr>

      <td width="60" height="20">&lt;% out.print(rs.getString(&quot;编号&quot;)); %&gt;</td>

      <td width="80" height="20">&lt;% out.print(rs.getString(&quot;姓名&quot;)); %&gt;</td>

      <td width="200" height="20">&lt;% out.print(rs.getString(&quot;发奖名称&quot;)); %&gt;</td>

      <td width="100" height="20">&lt;% out.print(rs.getString(&quot;金额&quot;)); %&gt;</td>

      <td width="200" height="20">&lt;% out.print(rs.getString(&quot;备注&quot;)); %&gt;</td>

   </tr>

     &lt;%  } %&gt;

  </table>





&lt;%

 // Catch exceptions

  }



  catch (Exception e) {

  }

  finally {



 if (rs != null)

     {

      try{rs.close();}catch(Exception ignore){};

      }



     if (stmt != null)

     {

      try{stmt.close();}catch(Exception ignore){};

      }

     if (conn != null)

     {

      try{conn.close();}catch(Exception ignore){};

      }





 %&gt;





&lt;%

  }

%&gt;



</font>

</body>

</html>



<p>启动Tomcat。</p>
<p>浏览：<a href="http://127.0.0.1:8080/mywebapp/index.jsp" target="_blank">http://127.0.0.1:8080/mywebapp/index.jsp</a></p>
<p><strong>四、在Tomcat中实现系统和Web管理的配置</strong></p>
<hr>
<p><strong>1、配置系统管理（Admin Web Application）</strong></p>
<hr>
<p><strong>（1）概述</strong></p>
<p>大多数商业化的J2EE服务器都提供一个功能强大的管理界面（如Weblogic的管理控制台），且大都采用易于理解的Web应用界面。Tomcat按照自己的方式，同样提供一个成熟的管理工具，并且丝毫不逊于那些商业化的竞争对手。</p>
<p>Tomcat的Admin Web Application最初在4.1版本时出现，当时的功能包括管理context、data source、user和group等。当然也可以管理像初始化参数，user、group、role的多种数据库管理等。在后续的版本中，这些功能将得到很大的扩展，但现有的功能已经非常实用了。</p>
<hr>
<p><strong>（2）系统管理Web应用程序</strong></p>
<p>Tomcat中的Admin Web Application被定义在自动部署文件：C:/jakarta-tomcat-5.0.19/server/webapps/admin/ admin.xml 中（请见下图所示）。</p>
<hr>
<p><strong>（3）编辑admin.xml文件</strong></p>
<p>通过编辑admin.xml文件，以确定Context中的docBase参数设置为Admin Web Application所在的目录路径（应该是绝对路径）。作为另外一种选择，你也可以删除这个自动部署文件，而在C:/jakarta-tomcat-5.0.19/conf/server.xml文件中建立一个Admin Web Application的context，效果是一样的。</p>
<pre><code>   你不能管理Admin Web Application这个应用，换而言之，除了删除CATALINA_BASE/webapps/admin.xml ，你可能什么都做不了。
</code></pre><p><strong>注意：</strong>如果将其中的被注释掉的&lt;Valve className=&quot;org.apache.catalina.valves.RemoteAddrValve&quot;</p>
<pre><code>allow=&quot;127.0.0.1&quot;/&gt;打开，将能够限制访问Admin Web Application的程序主机为本机（服务器主机）；当然也可以设置为其它的主机IP地址（如设置为 Web管理员所的工作主机）。
</code></pre><hr>
<p><strong>（4）在C:/jakarta-tomcat-5.0.19/conf/ tomcat-users.xml 文件中添加系统管理员的角色和系统管理员</strong></p>
<p>Tomcat中提供UserDatabaseRealm（默认），这样我们可以根据管理的需要添加不同的用户角色和与该角色相配置的用户名称和密码</p>
<p>l         添加用户角色</p>
<role name="admin"/>

<p>l         添加与该角色相配置的用户名称和密码</p>
<user name="admin" password="12345678" roles="admin"/>

<p>当你完成这些步骤后，请重新启动Tomcat，访问<a href="http://localhost:8080/admin，你将看到一个登录界面。Admin" target="_blank">http://localhost:8080/admin，你将看到一个登录界面。Admin</a> Web Application程序采用基于容器管理的安全机制，并采用了Jakarta Struts框架。下面是在原来的tomcat-users.xml 文件中再添加了两个角色admin和manager，同时也添加了与该两个角色相配置的用户admin和manager。</p>
<p>&lt;?xml version=&#39;1.0&#39; encoding=&#39;utf-8&#39;?&gt;</p>
<tomcat-users>

  <role rolename="role1"/>

  <role rolename="tomcat"/>

<p><strong>  <role rolename="admin"/></strong></p>
<p><strong>  <role rolename="manager"/></strong></p>
<p>  <strong><user username="admin" password="12345678" roles="admin"/></strong></p>
<p><strong>  <user name="manager" password="12345678" roles="manager"/></strong></p>
  <user username="role1" password="tomcat" roles="role1"/>

  <user username="tomcat" password="tomcat" roles="tomcat"/>

  <user username="both" password="tomcat" roles="tomcat,role1"/>

<p></tomcat-users></p>
<p><strong>（5）登录Admin Web Application程序</strong></p>
<p>输入<a href="http://localhost:8080/admin/" target="_blank"><a href="http://localhost:8080/admin/">http://localhost:8080/admin/</a></a>进入系统管理员的登录页，然后在页中</p>
<p>输入用户名称：admin</p>
<p>密码： 12345678</p>
<pre><code>   将进入系统管理的界面，在该系统管理的程序中将可以配置各种资源如Data Sources、Mail Sessions、Environment Entries，并且也可以管理Users 和Groups 以及Roles等功能。
</code></pre><hr>
<p><strong>2、配置应用管理（Manager Web Application）</strong></p>
<hr>
<p><strong>（1）概述</strong></p>
<p>Tomcat中所提供的Manager Web Application让你通过一个比Admin Web Application更为简单的用户界面，执行一些与Web应用任务相关的一些管理功能。</p>
<hr>
<p><strong>（2）Manager Web Application程序</strong></p>
<p>Manager Web Application被被定义在一个自动部署文件中C:/jakarta-tomcat-5.0.19/server/webapps/manager/manager.xml 。</p>
<hr>
<p><strong>（3）编辑manager.xml文件</strong></p>
<p>通过编辑这个文件，以确保其中的context中的docBase属性参数是C:/jakarta-tomcat-5.0.19/server/webapps/manager的绝对路径。</p>
<hr>
<p><strong>（4）在C:/jakarta-tomcat-5.0.19/conf/ tomcat-users.xml 文件中添加Web管理员的角色和Web管理员</strong></p>
<p>l         添加用户角色</p>
<p><strong><role name=" manager "/></strong></p>
<p>l         添加与该角色相配置的用户名称和密码</p>
<p><strong>  <user name="manager" password="12345678" roles="manager"/></strong></p>
<hr>
<p><strong>（5）登录Web管理员的页面</strong></p>
<p>l         文本型管理界面</p>
<p>然后重新启动Tomcat，输入<a href="http://localhost:8080/manager/" target="_blank"><a href="http://localhost:8080/manager/">http://localhost:8080/manager/</a></a>，将进入看到一个很朴素的文本型管理界面</p>
<p>如果输入<a href="http://localhost:8080/manager/" target="_blank"><a href="http://localhost:8080/manager/">http://localhost:8080/manager/</a></a>list，将进入一个登录管理界面，然后</p>
<p>输入用户名称：manager（前面在tomcat-users.xml中设置的）</p>
<p>密码：12345678</p>
<p>将显示出</p>
<p>l         HTML 型管理界面</p>
<p>输入<a href="http://localhost:8080/manager/html/list" target="_blank"><a href="http://localhost:8080/manager/html/list">http://localhost:8080/manager/html/list</a></a>，将出现如下的页面，然后再</p>
<p>输入用户名称：manager</p>
<p>密码：12345678</p>
<p>将出现Web方式的管理页面</p>
<p>Manager application可以让用户在没有系统管理特权的基础上，部署安装新的Web应用，以用于测试。同时也可以对所部署的Web应用程序的工作状态进行控制（Start 或者 Stop），以免重新启动服务器（这在对web.xml等配置的内容发生改变的情况下，特别有效）。当有用户尝试访问这个被停止的应用时，将看到一个503的错误——“503 - This application is not currently available”。</p>
<hr>
<p><strong>3、配置各种用户角色、用户组和用户</strong></p>
<p>（1）添加用户角色：在 admin的界面中点击左面的Roles节点，然后在右面的下拉列表框中选择Create New Role项目。</p>
<p>然后输入角色的名称和描述</p>
<pre><code>   最后点击“保存”，将存储在C:/jakarta-tomcat-5.0.19/conf/tomcat-users.xml文件中并且在管理界面中显示出。
</code></pre><p><strong>（2）添加用户组：</strong>在 admin的界面中点击左面的Groups节点，然后在右面的下拉列表框中选择Create New Group项目。</p>
<hr>
<p>然后输入组的名称和描述，并且设置该组的角色。所应该注意的是，给组分配角色，则意味着该组中的各个成员（用户）将具有该角色所分配的各种权限。</p>
<hr>
<p>最后点击“Save”以保存它（仍然放在C:/jakarta-tomcat-5.0.19/conf/tomcat-users.xml文件中）</p>
<hr>
<p><strong>（3）添加属于某一用户组内的用户</strong></p>
<p>在 admin的界面中点击左面的Users节点，然后在右面的下拉列表框中选择Create New User项目。</p>
<p>然后该用户的名称同时包括全名称、密谋，并且设置该用户所属的用户组；同时也可以为该用户再设置其它的角色以使该用户除了具有用户组的通用的权利以外，还具有其他方面的权利。</p>
<p>下面对“teacherZhang”这个用户进行设置，同时他也是系统管理员，因此将下面的admin的角色也选中。</p>
<p>最后点击保存（仍然放在C:/jakarta-tomcat-5.0.19/conf/tomcat-users.xml文件中）</p>
<hr>
<p><strong>4、添加其它的系统资源</strong></p>
<hr>
<p><strong>（1）DataSource</strong></p>
<pre><code>   在 admin的界面中点击左面的DataSourcs节点，然后在右面的下拉列表框中选择Create New DataSource项目。

   在各个输入的项目中根据数据库的特性进行输入。最后点击“Save”以保存。
</code></pre><hr>
<p><strong>（2）添加环境变量</strong></p>
<pre><code>   在 admin的界面中点击左面的Environment Entries节点，然后在右面的下拉列表框中选择Create New Env Entry项目。

   在各个输入的项目中根据数据库的特性进行输入。最后点击“Save”以保存。****
</code></pre><hr>
<p><strong>5、对Web应用程序进行管理</strong></p>
<p>（1）输入<a href="http://localhost:8080/manager/html/list" target="_blank"><a href="http://localhost:8080/manager/html/list">http://localhost:8080/manager/html/list</a></a>，将出现登录页并且进行登录，然后再进入Tomcat Web Application Manager</p>
<p>（2）查看在Web服务中所发布的各个Web应用</p>
<hr>
<p><strong>（3）启动或者终止、移除某一Web应用：</strong></p>
<p>点击该 Web应用右面的Stop链接，也可以点击Start再次启动它。Undeploy（移除）一个Web应用，只是指从Tomcat的运行拷贝中删除了该应用，如果你重新启动Tomcat，被删除的应用将再次出现（也就是说，移除并不是指从硬盘上删除）。</p>
<hr>
<p><strong>（4）部署某一Web应用</strong></p>
<p>有三种方式可以在Tomcat系统中部署Web应用。</p>
<p>l         直接拷贝你的WAR文件或者你的Web应用文件夹（包括该Web应用的所有内容）到C:/jakarta-tomcat-5.0.19/webapps目录下。</p>
<p>该文件必须以“.war”作为扩展名。一旦Tomcat监听到这个文件，它将（缺省的）解开该文件包作为一个子目录，并以WAR文件的文件名作为子目录的名字。接下来，Tomcat将在内存中建立一个context，就好象你在server.xml文件里建立一样。当然，其他必需的内容，将从server.xml中的DefaultContext获得。</p>
<p>l         部署web应用的另一种方式是写一个Context XML片断文件，然后把该文件拷贝到C:/jakarta-tomcat-5.0.19/webapps目录下。</p>
<p>一个Context片断并非一个完整的XML文件，而只是一个Context元素，以及对该应用的相应描述。这种片断文件就像是从server.xml中切取出来的context元素一样，所以这种片断被命名为“context片断”。这个web应用本身可以存储在硬盘上的任何地方。</p>
<p>举个例子，如果我们想部署一个名叫JspExamples的Web应用，该应用使用realm作为访问控制方式，我们可以使用下面这个片断：</p>
<!-- 

 Context fragment for deploying JspExamples 

-->

<Context path="/JspExamples" docBase="JspExamples" debug="0" reloadable="true">

<RealmclassName="org.apache.catalina.realm.UserDatabaseRealm"  resourceName="UserDatabase"/>

</Context>

<p>把该片断命名为“JspExamples.xml”，然后拷贝到C:/jakarta-tomcat-5.0.19/webapps目录下。这种Context片断提供了一种便利的方法来部署web应用，你不需要编辑server.xml，除非你想改变缺省的部署特性，安装一个新的Web应用时不需要重启动Tomcat。</p>
<p>l         采用GUI管理界面进行发布</p>
<p>如果提供了该Web应用的/*.war文件，直接浏览并发布它</p>
<p>如果Web应用是以目录形式存在的，则可以：</p>
<p><strong>五、Tomcat服务器的Web安全的解决方法</strong></p>
<hr>
<p><strong>1、概述</strong></p>
<p>在任何一种WEB应用开发中，不论大中小规模的，每个开发者都会遇到一些需要保护程序数据的问题，涉及到用户的LOGIN ID和PASSWORD。那么如何执行验证方式更好呢？实际上，有很多方式来实现。</p>
<p>下面将讨论在Tomcat中实现基本的（BASIC）和基于表单的（FORM-BASED）验证方式。它通过server.xml和web.xml文件提供基本的和基于表单的验证。</p>
<p>对于采用基于表单的（FORM-BASED）验证方式，只是要求在登录的JSP页面中的j_security_check 表单(for FORM-based) 需要两个参数：j_username和j_password。</p>
<p>对于用户的登录的名称和密码在Tomcat中可以以两种形式来存放，一是采用server.xml；另一种也可以采用用户自己的数据库表来存储。</p>
<hr>
<p><strong>2、设计系统中的各种人员的角色</strong></p>
<hr>
<p><strong>（1）设计思想</strong></p>
<p>l         统一用户管理，实现基于角色、粗粒度（基于URL）和细粒度（基于应用组件的方法调用）的访问策略管理体系，</p>
<p>l         基于分级角色的权限管理、统一证书管理和统一资源管理</p>
<hr>
<p><strong>（2）设计目标</strong></p>
<p>一般采用数据库表（对于复杂的也可以采用LDAP）记录每个系统用户的帐号信息、功能权限和数据权限信息，这样能够增加用户管理和权限设置的灵活性，同时也避免多个用户共用一个帐号的情况。</p>
<p><strong>（3）优点</strong></p>
<hr>
<p>l         从用户角度来看，登录所有应用系统都使用唯一的用户名和口令（数字证书）同时在访问系统时，也只需要登录一次（单点登录全网漫游---SSO（Single Sign-On））。</p>
<p>l        从管理者角度来看，提供了统一、集中、有效的用户管理。</p>
<p><strong>七、在Tomcat中采用基于表单的安全验证</strong></p>
<hr>
<p><strong>1、概述</strong></p>
<hr>
<p><strong>（1）基于表单的验证</strong></p>
<p>基于From的安全认证可以通过Tomcat Server对Form表单中所提供的数据进行验证，基于表单的验证使系统开发者可以自定义用户的登陆页面和报错页面。这种验证方法与基本HTTP的验证方法的唯一区别就在于它可以根据用户的要求制定登陆和出错页面。</p>
<p>通过拦截并检查用户的请求，检查用户是否在应用系统中已经创建好login session。如果没有，则将用户转向到认证服务的登录页面。但在Tomcat中的基于表单的验证凭证不被保护并以纯文本发送。</p>
<hr>
<p><strong>（2）在Tomcat 中的实现</strong></p>
<p>在Tomcat中，用户、用户组和角色都是在XML配置文件（C:/jakarta-tomcat-5.0.19/conf/tomcat-users.xml）中指定的，我们只需要提供一个登陆页面，包含一个名为j_security_check的Form表单，一个名为j_username的TextBox和一个名为j_password的PasswordBox，然后在/WEB-INF/web.xml中配置即可使用Tomcat默认的JAAS身份验证。</p>
<p>使用JAAS验证的好处是，验证逻辑从页面中分离，对页面的限制访问是通过/WEB-INF/web.xml中的配置指定的，无需自定义过滤器。</p>
<hr>
<p><strong>（3）为了实现Web应用程序的安全，Tomcat Web容器执行下面的步骤：</strong></p>
<p>l         在受保护的Web资源被访问时，判断用户是否被认证。</p>
<p>l         如果用户没有得到认证，则通过重定向到部署描述符中定义的注册页面，要求用户提供安全信任状。</p>
<p>l         根据为该容器配置的安全领域，确认用户的信任状有效。</p>
<p>l         判断得到认证的用户是否被授权访问部署描述符（web.xml）中定义的Web资源。<em>**</em></p>
<hr>
<hr>
<p><strong>2、设计步骤</strong></p>
<hr>
<hr>
<p><strong>（1）编写登录页面和错误处理页面：</strong>请见FormSafeWebApp 程序中的页面</p>
<hr>
<hr>
<hr>
<p><strong>（2）登录的页面文件的内容如下</strong></p>
<p>基于FORM的用户认证要求你返回一个包括用户名和密码的HTML表单，这个表单相对应与用户名和密码的元素必须是j_username和j_password，并且表单的action描述必须为j_security_check（其实是一个Servlet）。该表单的具体操作以及j_username和j_password名字在Servlet中定义。当这个表单到达服务器的时候，由内部的Tomcat Server安全区对它进行确认。</p>
<p>包括这个表单的资源可以是一个HTML页面、一个JSP页面或者一个Servlet。你可以在<form-login-page>元素中定义。基于表单的认证能够使开发人员定制认证的用户界面。在web.xml的login-config标签项目定义了认证机制的类型、登录的URI和错误页面。</p>
<p>下面为该页面的内容：</p>
<p>&lt;%@ page contentType=&quot;text/html; charset=GBK&quot; %&gt;</p>
<p><strong>注意：</strong>action应该为j_security_check<html><head><title>在Tomcat 中采用Form 验证方式实现的安全Web应用程序的登录页</title></p>
<p></head><body bgcolor="/#ffffff"></p>
<form method="post" name="Login" **action="j_security_check"**>

<p><table width="500" border="1" align="center"> <tr></p>
<p><strong>注意：</strong>用户名称和密码的输入应该为j_username 和j_password    <td colspan="2"> <div align="center"><strong>在Tomcat中采用</strong><strong>基于表单的安全验证的登录表单 </strong> </div></td> </tr></p>
  <tr><td width="224"><div align="right">用户名称：</div></td>

    <td width="260"><input type="text" **name="j_username"**></td> </tr>

  <tr> <td><div align="right">密码：</div></td>

<td><input type="password" **name="j_password"**></td>

  </tr>

<p>  <tr><td><div align="right"><input type="submit" name="Submit" value="提交"></p>
<pre><code>&lt;/div&gt;&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;reset&quot; name=&quot;Submit2&quot; value=&quot;重置&quot;&gt;&lt;/td&gt;
</code></pre><p>  </tr></table></form></body></html><em>**</em></p>
<hr>
<p><strong>（3）修改web.xml文件</strong></p>
<p>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</p>
<p>定义本Web应用的默认启始页面&lt;!DOCTYPE web-app PUBLIC &quot;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN&quot; &quot;<a href="http://java.sun.com/dtd/web-app_2_3.dtd&quot;&gt;" target="_blank">http://java.sun.com/dtd/web-app_2_3.dtd&quot;&gt;</a></p>
<web-app>

<pre><code>   &lt;welcome-file-list&gt;

       &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt;

    &lt;/welcome-file-list&gt;
</code></pre> <!-- Security is active on entire directory -->

<p> <strong> <security-constraint></strong></p>
<p><strong>    <display-name>Tomcat Server Form Security Constraint</display-name></strong></p>
<p><strong>    <web-resource-collection></strong></p>
<p><strong>     <web-resource-name>Protected Area</web-resource-name></strong></p>
<p><strong>      <description>A Page of Login Success</description></strong></p>
<p><strong>       <url-pattern>/ProtectedDirOne/index.jsp</url-pattern></strong></p>
<p><strong>      </web-resource-collection></strong></p>
<p><strong>    <auth-constraint></strong></p>
<p>指定Form验证的用户的角色名称<strong>      <!-- Anyone with one of the listed roles may access this area --></strong></p>
<p><strong>      <role-name>admin</role-name></strong></p>
<p><strong>    </auth-constraint></strong></p>
<p>指定验证的方式为Form<strong>  </security-constraint></strong></p>
<p><strong>  <!-- Login configuration uses form-based authentication --></strong></p>
<p><strong>  <login-config></strong></p>
<p><strong>    <auth-method>FORM</auth-method></strong></p>
<p><strong>    <realm-name>Tomcat Server Configuration Form-Based Authentication Area</realm-name></strong></p>
<p><strong>    <form-login-config></strong></p>
<p><strong>             <form-login-page>/login.jsp </form-login-page></strong></p>
<p><strong>              <form-error-page>/Error.htm </form-error-page></strong></p>
<hr>
<p><strong>    </form-login-config></strong></p>
<p><strong>  </login-config></strong></p>
<p><strong>  <!-- Security roles referenced by this web application --></strong></p>
<p><strong>  <security-role></strong></p>
<p>关联Tomcat中的admin的角色<strong>    <description></strong></p>
<p><strong>      The role is Administration</strong></p>
<p><strong>    </description></strong></p>
<p><strong>    <role-name>admin</role-name></strong></p>
<p><strong>  </security-role></strong></p>
<p></web-app></p>
<hr>
<p><strong>（4）在C:/jakarta-tomcat-5.0.19/conf/tomcat-users.xml文件</strong>中配置admin的角色以及与该 admin角色相匹配的用户名称和密码</p>
<hr>
<hr>
<p><strong>（5）执行该页面</strong></p>
<p>在浏览器中直接输入受保护的页面的URL地址：</p>
<p><a href="http://127.0.0.1:8080/FormSafeWebApp/ProtectedDirOne/" target="_blank"><a href="http://127.0.0.1:8080/FormSafeWebApp/ProtectedDirOne/">http://127.0.0.1:8080/FormSafeWebApp/ProtectedDirOne/</a></a>，将出现要求登录的页面。</p>
<hr>
<p>在表单中输入用户名称为admin（前面在tomcat-users.xml文件中所设置的某一用户名称），密码为12345678。然后点击“提交”，将出现如下页面</p>
<p>如果用户名称或者密码输入不正确，将出现如下的页面也就是错误页面</p>
<p><strong>（6）在页面中获得当前登录成功后的用户名称和实体名称</strong></p>
<pre><code>   利用request对象中的getRemoteUser()方法获得当前登录成功后的用户名称和利用getUserPrincipal()方法获得当前登录成功后的实体名称。
</code></pre><hr>
<hr>
<p><strong>八、在Tomcat中配置单点登录（Single Sign-On）</strong></p>
<hr>
<p><strong>1、概述</strong></p>
<p>一旦你设置了realm和验证的方法，你就需要进行实际的用户登录处理。一般说来，对用户而言登录系统是一件很麻烦的事情，你必须尽量减少用户登录验证的次数。作为缺省的情况，当用户第一次请求受保护的资源时，每一个Web应用都会要求用户登录。</p>
<p>如果你运行了多个Web应用，并且每个应用都需要进行单独的用户验证，那这看起来就有点像你在与你的用户搏斗。用户们不知道怎样才能把多个分离的应用整合成一个单独的系统，所有他们也就不知道他们需要访问多少个不同的应用，只是很迷惑，为什么总要不停的登录。</p>
<hr>
<p><strong>2、Tomcat 中的“Single Sign-On”特性及配置</strong></p>
<p>其主要的特性是能够允许用户在访问同一虚拟主机下所有Web应用时，只需登录一次。为了使用这个功能，你只需要在C:/jakarta-tomcat-5.0.19/conf /server.xml文件中的Host标签上添加一个SingleSignOn Valve元素即可，如下所示：</p>
<Valve className="org.apache.catalina.authenticator.SingleSignOn"   debug="0"/>

<p>在Tomcat初始安装后，server.xml的注释里面包括SingleSignOn Valve配置的例子，你只需要去掉注释（<strong>在339行左右</strong>），即可使用。那么，任何用户只要登录过一个应用，则对于同一虚拟主机下的所有应用同样有效。</p>
<hr>
<p><strong>3、测试单点登录</strong></p>
<hr>
<p><strong>（1）      直接进入前面的Form验证所产生的Web应用</strong></p>
<p><strong>（<a href="http://127.0.0.1:8080/FormSafeWebApp/ProtectedDirOne/" target="_blank"><a href="http://127.0.0.1:8080/FormSafeWebApp/ProtectedDirOne/">http://127.0.0.1:8080/FormSafeWebApp/ProtectedDirOne/</a></a>）将出现要求登录的页面</strong></p>
<hr>
<hr>
<p>在表单中输入用户名称为admin（前面在tomcat-users.xml文件中所设置的某一用户名称），密码为12345678。然后点击“提交”，将以用户名admin进行成功登录该Web应用。</p>
<p>（2）再在该浏览器窗口内（不能在新窗口，否则会成为另一用户）直接输入<a href="http://127.0.0.1:8080/admin/frameset.jsp" target="_blank"><a href="http://127.0.0.1:8080/admin/frameset.jsp">http://127.0.0.1:8080/admin/frameset.jsp</a></a>，此时将以admin的用户浏览另一Web应用。观察能否直接进入Tomcat的系统管理的页面，此时应该可以并且出现下面的页面。</p>
<hr>
<pre><code>   如果新开一浏览器窗口并直接输入[http://127.0.0.1:8080/admin/frameset.jsp](http://127.0.0.1:8080/admin/frameset.jsp)，看能否直接进入Tomcat的系统管理的页面，此时将会出现要求登录的页面。
</code></pre><hr>
<hr>
<p><strong>4、使用single sign-on valve所应该注意的问题</strong></p>
<p>l         value必须被配置和嵌套在相同的Host元素里，并且所有需要进行单点验证的web应用（必须通过context元素定义）都位于该Host下。</p>
<p>l         包括共享用户信息的realm必须被设置在同一级Host中或者嵌套之外。</p>
<p>l         不能被context中的realm覆盖。</p>
<p>l         使用单点登录的web应用最好使用一个Tomcat的内置的验证方式（Basic或者Form）（被定义在web.xml中的<auth-method>中），这比自定义的验证方式强。</p>
<p>l         单点登录需要使用cookies。
来源： <a href="[http://blog.csdn.net/haojun186/article/details/7564174](http://blog.csdn.net/haojun186/article/details/7564174)">[http://blog.csdn.net/haojun186/article/details/7564174](http://blog.csdn.net/haojun186/article/details/7564174)</a> </p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/服务器/">服务器</a></li></span><span class="breadcrumb"><li><a href="/categories/服务器/">服务器</a></li><li><a href="/categories/服务器/tomcat/">tomcat</a></li></span></span> | <span class="tags">Tagged <a href="/tags/tomcat/" class="label label-primary">tomcat</a><a href="/tags/服务器/" class="label label-success">服务器</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:45"datetime="2014-03-07 09:54:45"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-服务器-tomcat--tomcat详解/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-服务器-tomcat--tomcat详解" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-服务器-tomcat--Tomcat源码分析/">Tomcat源码分析</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:45.000Z"> <a href="/2014/02/02/2014-02-02-服务器-tomcat--Tomcat源码分析/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="tomcat-">Tomcat源码分析</h1>
<p><a href="http://blog.csdn.net/haojun186/article/details/7464912" target="_blank">Tomcat源码分析</a></p>
<p>TOMCAT源码分析(启动框架)
前言：
   本文是我阅读了TOMCAT源码后的一些心得。 主要是讲解TOMCAT的系统框架， 以及启动流程。若有错漏之处，敬请批评指教！
建议：
   毕竟TOMCAT的框架还是比较复杂的， 单是从文字上理解， 是不那么容易掌握TOMCAT的框架的。 所以得实践、实践、再实践。 建议下载一份TOMCAT的源码， 调试通过， 然后单步跟踪其启动过程。 如果有不明白的地方， 再来查阅本文， 看是否能得到帮助。 我相信这样效果以及学习速度都会好很多！</p>
<ol>
<li><p>Tomcat的整体框架结构
Tomcat的基本框架， 分为4个层次。
Top Level Elements:
 Server
 Service<br>Connector
 HTTP
 AJP
Container
Engine
  Host
Context
Component<br> manager
logger
loader
pipeline
valve</p>
<pre><code>  ...
</code></pre><p>站在框架的顶层的是Server和Service
Server:  其实就是BackGroud程序， 在Tomcat里面的Server的用处是启动和监听服务端事件（诸如重启、关闭等命令。 在tomcat的标准配置文件：server.xml里面， 我们可以看到“<Server port="8005" shutdown="SHUTDOWN" debug="0">;”这里的&quot;SHUTDOWN&quot;就是server在监听服务端事件的时候所使用的命令字）
Service： 在tomcat里面，service是指一类问题的解决方案。  通常我们会默认使用tomcat提供的：Tomcat-Standalone 模式的service。 在这种方式下的service既给我们提供解析jsp和servlet的服务， 同时也提供给我们解析静态文本的服务。</p>
<p>Connector: Tomcat都是在容器里面处理问题的， 而容器又到哪里去取得输入信息呢？
Connector就是专干这个的。 他会把从socket传递过来的数据， 封装成Request, 传递给容器来处理。
通常我们会用到两种Connector,一种叫http connectoer， 用来传递http需求的。 另一种叫AJP， 在我们整合apache与tomcat工作的时候，apache与tomcat之间就是通过这个协议来互动的。 （说到apache与tomcat的整合工作， 通常我们的目的是为了让apache 获取静态资源， 而让tomcat来解析动态的jsp或者servlet。）
Container: 当http connector把需求传递给顶级的container: Engin的时候， 我们的视线就应该移动到Container这个层面来了。
在Container这个层， 我们包含了3种容器：Engin, Host, Context.
Engin: 收到service传递过来的需求， 处理后， 将结果返回给service( service 是通过connector 这个媒介来和Engin互动的).
Host: Engin收到service传递过来的需求后，不会自己处理， 而是交给合适的Host来处理。
Host在这里就是<a href="http://www.honhei.com/" target="_blank">虚拟主机</a>的意思， 通常我们都只会使用一个主机，既“localhost”本地机来处理。
Context: Host接到了从Host传过来的需求后， 也不会自己处理， 而是交给合适的Context来处理。
比如：<a href="http://127.0.0.1:8080/foo/index.jsp" target="_blank">http://127.0.0.1:8080/foo/index.jsp</a>;</p>
<pre><code>  &lt;http://127.0.1:8080/bar/index.jsp&gt;;
</code></pre><p>前者交给foo这个Context来处理， 后者交给bar这个Context来处理。
很明显吧！context的意思其实就是一个web app的意思。
我们通常都会在server.xml里面做这样的配置
<Context path="/foo" docBase="D:/project/foo/web" />;
这个context容器，就是用来干我们该干的事儿的地方的。</p>
<p>Compenent: 接下来， 我们继续讲讲component是干什么用的。
我们得先理解一下容器和组件的关系。
需求被传递到了容器里面， 在合适的时候， 会传递给下一个容器处理。
而容器里面又盛装着各种各样的组件， 我们可以理解为提供各种各样的增值服务。
manager: 当一个容器里面装了manager组件后，这个容器就支持session管理了， 事实上在tomcat里面的session管理， 就是靠的在context里面装的manager component.
logger: 当一个容器里面装了logger组件后， 这个容器里所发生的事情， 就被该组件记录下来啦！ 我们通常会在logs/ 这个目录下看见catalina_log.time.txt 以及localhost.time.txt 和localhost_examples_log.time.txt。 这就是因为我们分别为：engin, host以及context(examples)这三个容器安装了logger组件， 这也是默认安装， 又叫做标配 ：）
loader: loader这个组件通常只会给我们的context容器使用，loader是用来启动context以及管理这个context的classloader用的。
 pipline: pipeline是这样一个东西， 当一个容器决定了要把从上级传递过来的需求交给子容器的时候， 他就把这个需求放进容器的管道(pipeline)里面去。 而需求傻呼呼得在管道里面流动的时候， 就会被管道里面的各个阀门拦截下来。 比如管道里面放了两个阀门。 第一个阀门叫做“access_allow_vavle”， 也就是说需求流过来的时候，它会看这个需求是哪个IP过来的， 如果这个IP已经在黑名单里面了，sure, 杀！ 第二个阀门叫做“defaul_access_valve”它会做例行的检查， 如果通过的话，OK， 把需求传递给当前容器的子容器。 就是通过这种方式， 需求就在各个容器里面传递，流动， 最后抵达目的地的了。
 valve: 就是上面所说的阀门啦。
Tomcat里面大概就是这么些东西， 我们可以简单地这么理解tomcat的框架，它是一种自上而下， 容器里又包含子容器的这样一种结构。</p>
</li>
<li><p>Tomcat的启动流程
这篇文章是讲tomcat怎么启动的，既然我们大体上了解了TOMCAT的框架结构了， 那么我们可以望文生意地就猜到tomcat的启动， 会先启动父容器，然后逐个启动里面的子容器。 启动每一个容器的时候， 都会启动安插在他身上的组件。 当所有的组件启动完毕， 所有的容器启动完毕的时候，tomcat本身也就启动完毕了。
顺理成章地， 我们同样可以猜到，tomcat的启动会分成两大部分， 第一步是装配工作。 第二步是启动工作。
装配工作就是为父容器装上子容器， 为各个容器安插进组件的工作。 这个地方我们会用到digester模式， 至于digester模式什么， 有什么用， 怎么工作的. 请参考<a href="http://software.ccidnet.com/pub/article/c322_a31671_p2.html" target="_blank">http://software.ccidnet.com/pub/article/c322_a31671_p2.html</a>;
启动工作是在装配工作之后， 一旦装配成功了， 我们就只需要点燃最上面的一根导线， 整个tomcat就会被激活起来。 这就好比我们要开一辆已经装配好了的汽车的时候一样，我们只要把钥匙插进钥匙孔，一拧，汽车的引擎就会发动起来，空调就会开起来， 安全装置就会生效， 如此一来，汽车整个就发动起来了。（这个过程确实和TOMCAT的启动过程不谋而和， 让我们不得不怀疑TOMCAT的设计者是在GE做JAVA开发的）。
2.1 一些有意思的名称：
Catalina
Tomcat
Bootstrap
Engin
Host
Context
他们的意思很有意思：
Catalina: 远程轰炸机
Tomcat: 熊猫轰炸机-- 轰炸机的一种（这让我想起了让国人引以为豪的熊猫手机，是不是英文可以叫做tomcat??? ， 又让我想起了另一则广告： 波导-手机中的战斗机、波音-客机中的战斗机 ）
Bootstap: 引导
Engin: 发动机
Host: 主机，领土
Context: 内容， 目标， 上下文</p>
<p>... 在许多许多年后， 现代人类已经灭绝。 后现代生物发现了这些单词零落零落在一块。 一个自以为聪明的家伙把这些东西翻译出来了：
在地勤人员的引导(bootstrap)下， 一架轰炸架(catalina)腾空跃起， 远看是熊猫轰炸机(tomcat)， 近看还是熊猫轰炸机！ 凭借着优秀的发动机技术(engin)， 这架熊猫轰炸机飞临了敌国的领土上空(host)， 对准目标(context)投下了毁天灭地的核弹头，波~ 现代生物就这么隔屁了~</p>
<p>综上所述， 这又不得不让人联想到GE是不是也参与了军事设备的生产呢？
反对美帝国主义！ 反对美霸权主义！ 和平万岁！ 自由万岁！</p>
</li>
</ol>
<p>2.2  历史就是那么惊人的相似！tomcat的启动就是从org.apache.catalina.startup.Bootstrap这个类悍然启动的！
   在Bootstrap里做了两件事：</p>
<ol>
<li>指定了3种类型classloader:
commonLoader: common/classes、common/lib、common/endorsed
catalinaLoader: server/classes、server/lib、commonLoader
sharedLoader：  shared/classes、shared/lib、commonLoader</li>
<li>引导Catalina的启动。
用Reflection技术调用org.apache.catalina.startup.Catalina的process方法， 并传递参数过去。</li>
</ol>
<p>2.3 Catalina.java
   Catalina完成了几个重要的任务：</p>
<ol>
<li>使用Digester技术装配tomcat各个容器与组件。
1.1 装配工作的主要内容是安装各个大件。 比如server下有什么样的servcie。Host会容纳多少个context。Context都会使用到哪些组件等等。
1.2 同时呢， 在装配工作这一步， 还完成了mbeans的配置工作。 在这里，我简单地但不十分精确地描述一下mbean是什么，干什么用的。<pre><code>我们自己生成的对象， 自己管理， 天经地义！ 但是如果我们创建了对象了， 想让别人来管， 怎么办呢？ 我想至少得告诉别人我们都有什么， 以及通过什么方法可以找到  吧！JMX技术给我们提供了一种手段。JMX里面主要有3种东西。Mbean, agent, connector.
</code></pre> Mbean： 用来映射我们的对象。也许mbean就是我们创建的对象， 也许不是， 但有了它， 就可以引用到我们的对象了。
 Agent:  通过它， 就可以找到mbean了。
 Connector: 连接Agent的方式。 可以是http的， 也可以是rmi的，还可以直接通过socket。
发生在tomcat 装配过程中的事情:  GlobalResourcesLifecycleListener 类的初始化会被触发：
   protected static Registry registry = MBeanUtils.createRegistry();  会运行
   MBeanUtils.createRegistry()  会依据/org/apache/catalina/mbeans/mbeans- descriptors.xml这个配置文件创建mbeans. Ok, 外界就有了条途径访问tomcat中的各个组件了。（有点像后门儿）</li>
<li>为top level 的server 做初始化工作。 实际上就是做通常会配置给service的两条connector.(http, ajp)</li>
<li>从server这个容器开始启动， 点燃整个tomcat.</li>
<li>为server做一个hook程序， 检测当server shutdown的时候， 关闭tomcat的各个容器用。</li>
<li>监听8005端口， 如果发送&quot;SHUTDOWN&quot;（默认培植下字符串）过来， 关闭8005serverSocket。
2.4 启动各个容器</li>
<li>Server
触发Server容器启动前(before_start)， 启动中(start)， 启动后(after_start)3个事件， 并运行相应的事件处理器。
启动Server的子容器：Servcie.</li>
<li>Service
启动Service的子容器：Engin
启动Connector</li>
<li><p>Engin
到了Engin这个层次，以及以下级别的容器，Tomcat就使用了比较一致的启动方式了。
首先，  运行各个容器自己特有一些任务
随后，  触发启动前事件
立即，  设置标签，就表示该容器已经启动
接着，  启动容器中的各个组件：loader, logger, manager等等
再接着，启动mapping组件。（注1）
紧跟着，启动子容器。
接下来，启动该容器的管道(pipline)
然后，  触发启动中事件
最后，  触发启动后事件。</p>
<p>Engin大致会这么做，Host大致也会这么做， Context大致还是会这么做。 那么很显然地， 我们需要在这里使用到代码复用的技术。tomcat在处理这个问题的时候， 漂亮地使用了抽象类来处理。ContainerBase. 最后使得这部分完成复杂功能的代码显得干净利落， 干练爽快， 实在是令人觉得叹为观止， 细细品来， 直觉如享佳珍， 另人齿颊留香， 留恋往返啊！</p>
<p>Engin的触发启动前事件里， 会激活绑定在Engin上的唯一一个Listener：EnginConfig。
这个EnginConfig类基本上没有做什么事情， 就是把EnginConfig的调试级别设置为和Engin相当。 另外就是输出几行文本， 表示Engin已经配置完毕， 并没有做什么实质性的工作。
注1: mapping组件的用处是， 当一个需求将要从父容器传递到子容器的时候， 而父容器又有多个子容器的话， 那么应该选择哪个子容器来处理需求呢？ 这个由mapping 组件来定夺。</p>
</li>
<li><p>Host
 同Engin一样， 也是调用ContainerBase里面的start()方法， 不过之前做了些自个儿的任务,就是往Host这个容器的通道（pipline）里面， 安装了一个叫做
“org.apache.catalina.valves.ErrorReportValve”的阀门。
 这个阀门的用处是这样的：  需求在被Engin传递给Host后， 会继续传递给Context做具体的处理。 这里需求其实就是作为参数传递的Request, Response。 所以在context把需求处理完后， 通常会改动response。 而这个org.apache.catalina.valves.ErrorReportValve的作用就是检察response是否包含错误， 如果有就做相应的处理。</p>
</li>
<li>Context
 到了这里， 就终于轮到了tomcat启动中真正的重头戏，启动Context了。
StandardContext.start() 这个启动Context容器的方法被StandardHost调用.
5.1 webappResources 该context所指向的具体目录
5.2 安装defaultContex, DefaultContext 就是默认Context。 如果我们在一个Host下面安装了DefaultContext，而且defaultContext里面又安装了一个数据库连接池资源的话。 那么其他所有的在该Host下的Context, 都可以直接使用这个数据库连接池， 而不用格外做配置了。
5.3 指定Loader. 通常用默认的org.apache.catalina.loader.WebappLoader这个类。   Loader就是用来指定这个context会用到哪些类啊， 哪些jar包啊这些什么的。
5.4 指定Manager. 通常使用默认的org.apache.catalina.session. StandardManager 。Manager是用来管理session的。
其实session的管理也很好实现。 以一种简单的session管理为例。 当需求传递过来的时候， 在Request对象里面有一个sessionId 属性。OK， 得到这个sessionId后， 我们就可以把它作为map的key，而value我们可以放置一个HashMap. HashMap里边儿， 再放我们想放的东西。
5.5 postWorkDirectory (). Tomcat下面有一个work目录。 我们把临时文件都扔在那儿去。 这个步骤就是在那里创建一个目录。 一般说来会在%CATALINA_HOME%/work/Standalone\localhost\ 这个地方生成一个目录。
5.6  Binding thread。到了这里， 就应该发生class Loader 互换了。 之前是看得见tomcat下面所有的class和lib. 接下来需要看得见当前context下的class。 所以要设置contextClassLoader, 同时还要把旧的ClassLoader记录下来，因为以后还要用的。
5.7  启动Loader. 指定这个Context具体要使用哪些classes， 用到哪些jar文件。 如果reloadable设置成了true, 就会启动一个线程来监视classes的变化， 如果有变化就重新启动Context。
5.8  启动logger
5.9  触发安装在它身上的一个监听器。
lifecycle.fireLifecycleEvent(START_EVENT, null);
作为监听器之一，ContextConfig会被启动. ContextConfig就是用来配置web.xml的。 比如这个Context有多少Servlet， 又有多少Filter， 就是在这里给Context装上去的。
5.9.1 defaultConfig. 每个context都得配置tomcat/conf/web.xml 这个文件。
5.9.2 applicationConfig 配置自己的WEB-INF/web.xml 文件
5.9.3 validateSecurityRoles 权限验证。 通常我们在访问/admin 或者/manager的时候，需要用户要么是admin的要么是manager的， 才能访问。 而且我们还可以限制那些资源可以访问， 而哪些不能。 都是在这里实现的。
5.9.4 tldScan: 扫描一下， 需要用到哪些标签(tag lab)
5.10 启动manager
5.11 postWelcomeFiles() 我们通常会用到的3个启动文件的名称：
index.html、index.htm、index.jsp 就被默认地绑在了这个context上
5.12 listenerStart 配置listener
5.13 filterStart 配置filter
5.14 启动带有<load-on-startup>;1</load-on-startup>;的Servlet.
顺序是从小到大：1,2,3… 最后是0
默认情况下， 至少会启动如下3个的Servlet:
org.apache.catalina.servlets.DefaultServlet<br>处理静态资源的Servlet. 什么图片啊，html啊，css啊，js啊都找他
org.apache.catalina.servlets.InvokerServlet
处理没有做Servlet Mapping的那些Servlet.
org.apache.jasper.servlet.JspServlet
处理JSP文件的.
 5.15  标识context已经启动完毕。
走了多少个步骤啊，Context总算是启动完毕喽。
OK! 走到了这里， 每个容器以及组件都启动完毕。Tomcat终于不辞辛劳地为人民服务了！<ol>
<li>参考文献：
<a href="http://jakarta.apache.org/tomcat/" target="_blank">http://jakarta.apache.org/tomcat/</a>;
<a href="http://www.onjava.com/pub/a/onjava/2003/05/14/java_webserver.html" target="_blank">http://www.onjava.com/pub/a/onjava/2003/05/14/java_webserver.html</a>;</li>
</ol>
</li>
</ol>
<ol>
<li><p>后记
 这篇文章是讲解tomcat启动框架的，还有篇文章是讲解TOMCAT里面的消息处理流程的细节的。 文章内容已经写好了， 现在正在整理阶段。 相信很快就可以做出来， 大家共同研究共同进步。
 这篇文章是独自分析TOMCAT<a href="http://www.2cto.com/ym" target="_blank">源码</a>所写的， 所以一定有地方是带有个人主观色彩， 难免会有片面之处。若有不当之处敬请批评指教，这样不仅可以使刚开始研究TOMCAT的兄弟们少走弯路， 我也可以学到东西。</p>
</li>
<li><p>tomcat源码分析(消息处理)</p>
</li>
</ol>
<p>[ZT]TOMCAT源码分析
0：前言
我们知道了tomcat的整体框架了， 也明白了里面都有些什么组件， 以及各个组件是干什么用的了。</p>
<p><a href="http://www.csdn.net/Develop/read_article.[asp](http://www.2cto.com/kf/web/asp/)?id=27225" target="_blank">http://www.csdn.net/Develop/read_article.[asp](http://www.2cto.com/kf/web/asp/)?id=27225</a></p>
<p>我想，接下来我们应该去了解一下tomcat 是如何处理<a href="http://www.2cto.com/kf/web/jsp/" target="_blank">jsp</a>和servlet请求的。</p>
<ol>
<li>我们以一个具体的例子，来跟踪TOMCAT， 看看它是如何把Request一层一层地递交给下一个容器， 并最后交给Wrapper来处理的。</li>
</ol>
<p>以<a href="http://localhost:8080/web/login.jsp为例子" target="_blank">http://localhost:8080/web/login.jsp为例子</a></p>
<p>（以下例子， 都是以tomcat4 源码为参考）</p>
<p>这篇心得主要分为3个部分： 前期， 中期， 和末期。</p>
<p>前期：讲解了在<a href="http://www.2cto.com/os/liulanqi/" target="_blank">浏览器</a>里面输入一个URL，是怎么被tomcat抓住的。</p>
<p>中期：讲解了被tomcat抓住后，又是怎么在各个容器里面穿梭， 最后到达最后的处理地点。</p>
<p>末期：讲解到达最后的处理地点后，又是怎么具体处理的。</p>
<p>2、  前期Request的born.</p>
<pre><code>在这里我先简单讲一下request这个东西。

 我们先看着这个URL：http://localhost:8080/web/login.jsp  它是动用了8080端口来进行socket通讯的。

 我们知道, 通过

   InputStream in = socket.getInputStream() 和

   OutputStream out = socket.getOutputStream()

 就可以实现消息的来来往往了。

 但是如果把Stream给应用层看，显然操作起来不方便。

 所以，在tomcat 的Connector里面，socket被封装成了Request和Response这两个对象。

 我们可以简单地把Request看成管发到服务器来的数据，把Response看成想发出服务器的数据。



 但是这样又有其他问题了啊？Request这个对象是把socket封装起来了， 但是他提供的又东西太多了。

 诸如Request.getAuthorization(), Request.getSocket()。  像Authorization这种东西开发人员拿来基本上用不太着，而像socket这种东西，暴露给开发 人员又有潜在的危险。 而且啊， 在Servlet Specification里面标准的通信类是ServletRequest和HttpServletRequest，而非这个Request类。So, So, So. Tomcat必须得捣持捣持Request才行。 最后tomcat选择了使用捣持模式（应该叫适配器模式）来解决这个问题。它把org.apache.catalina.Request 捣持成了org.apache.coyote.tomcat4.CoyoteRequest。 而CoyoteRequest又实现了ServletRequest和HttpServletRequest 这两种接口。 这样就提供给开发人员需要且刚刚需要的方法了。



ok, 让我们在tomcat的顶层容器- StandardEngin 的invoke()方法这里设置一个断点， 然后访问

http://localhost:8080/web/login.jsp ， 我们来看看在前期都会路过哪些地方：

   1. run(): 536, java.lang.Thread, Thread.java

   CurrentThread

  2.  run():666, org.apache.tomcat.util.threads.ThreadPool$ControlRunnable, ThreadPool.java

           ThreadPool

   3.  runIt():589, org.apache.tomcat.util.net.TcpWorkerThread, PoolTcpEndpoint.java

      ThreadWorker
</code></pre><ol>
<li>processConnection():  549</li>
</ol>
<p>org.apache.coyote.http11.Http11Protocol$Http11ConnectionHandler, Http11Protocol.java</p>
<pre><code>              http protocol parser

  5.  Process(): 781, org.apache.coyote.http11.Http11Processor, Http11Processor.java

      http request processor

   6. service(): 193, org.apache.coyote.tomcat4.CoyoteAdapter,CoyoteAdapter.java

      adapter

   7. invoke(): 995, org.apache.catalina.core.ContainerBase, ContainerBase.java
</code></pre><p>   StandardEngin</p>
<pre><code>1. 主线程

2. 启动线程池.

3. 调出线程池里面空闲的工作线程。

4. 把8080端口传过来由httpd协议封装的数据，解析成Request和Response对象。

5. 使用Http11Processor来处理request

6. 在Http11Processor里面， 又会call CoyoteAdapter来进行适配处理，把Request适配成实现了ServletRequest和HttpServletRequest接口的CoyoteRequest.
</code></pre><ol>
<li>到了这里，前期的去毛拔皮工作就基本上搞定，可以交给StandardEngin 做核心的处理工作了。</li>
</ol>
<ol>
<li><p>中期。 在各个容器间的穿梭。</p>
<p> Request在各个容器里面的穿梭大致是这样一种方式：</p>
<p> 每个容器里面都有一个管道（pipline）， 专门用来传送Request用的。</p>
<p> 管道里面又有好几个阀门（valve）， 专门用来过滤Request用的。</p>
<p> 在管道的低部通常都会放上一个默认的阀们。 这个阀们至少会做一件事情，就是把Request交给子容器。</p>
<p> 让我们来想象一下：</p>
<p>  当一个Request进入一个容器后， 它就在管道里面流动，波罗~ 波罗~ 波罗~ 地穿过各个阀门。在流到最后一个阀门的时候，吧唧~ 那个该死的阀门就把它扔给了子容器。 然后又开始 波罗~ 波罗~ 波罗~ ... 吧唧~....  波罗~  波罗~ 波罗~ ....吧唧~....</p>
<p> 就是通过这种方式，Request 走完了所有的容器。（ 感觉有点像消化系统，最后一个地方有点像那里~  ）</p>
<p> OK， 让我们具体看看都有些什么容器， 各个容器里面又都有些什么阀门，这些阀们都对我们的Request做了些什么吧：</p>
</li>
</ol>
<p>3.1 StandardEngin 的pipeline里面放的是：StandardEnginValve</p>
<p>在这里，VALVE做了三件事：</p>
<ol>
<li>验证传递过来的request是不是httpservletRequest.</li>
</ol>
<p>2    验证传递过来的request 是否携带了host header信息.</p>
<p>3    选择相应的host去处理它。（一般我们都只有一个host:localhost，也就是127.0.0.1）。</p>
<p>到了这个地方， 我们的request就已经完成了在Engin这个部分的历史使命， 通向前途未卜的下一站：host了。</p>
<p>3.2 StandardHost 的pipline里面放的是：StandardHostValve</p>
<ol>
<li><p>验证传递过来的request是不是httpservletRequest.</p>
</li>
<li><p>根据Request来确定哪个Context来处理。</p>
</li>
</ol>
<p>Context其实就是webapp， 比如<a href="http://localhost:8080/web/login.jsp" target="_blank">http://localhost:8080/web/login.jsp</a></p>
<p>这里web就是Context罗！</p>
<ol>
<li><p>既然确定了是哪个Context了，那么就应该把那个Context的classloader付给当前线程了。</p>
<p>   Thread.currentThread().setContextClassLoader(context.getLoader().getClassLoader());</p>
<p>这样request就只看得见指定的context下面的classes啊，jar啊这些， 而看不见tomcat本身的类， 什么Engin啊，Valve啊。 不然还得了啊！</p>
</li>
<li><p>既然request到了这里了，看来用户是准备访问web这个web app了，咋们得更新一下这个用户的session不是！Ok , 就由manager更新一下用户的session信息</p>
</li>
<li><p>交给具体的Context 容器去继续处理Request.</p>
</li>
<li><p>Context处理完毕了，把classloader还回来。</p>
</li>
</ol>
<p>3.3 StandardContext 的pipline里面放的是：StandardContextValve</p>
<ol>
<li><p>验证传递过来的request是不是httpservletRequest.</p>
</li>
<li><p>如果request意图不轨，想要访问/meta-inf, /web-inf这些目录下的东西，呵呵，没有用D!</p>
</li>
<li><p>这个时候就会根据Request到底是Servlet，还是jsp，还是静态资源来决定到底用哪种Wrapper来处理这个Reqeust了。</p>
</li>
<li><p>一旦决定了到底用哪种Wrapper，OK，交给那个Wrapper处理。</p>
</li>
</ol>
<ol>
<li>末期。 不同的需求是怎么处理的.</li>
</ol>
<p>StandardWrapper</p>
<p>之前对Wrapper没有做过讲解，其实它是这样一种东西。</p>
<p>我们在处理Request的时候，可以分成3种。</p>
<p>处理静态的：org.apache.catalina.servlets.DefaultServlet  </p>
<p>处理jsp的：org.apache.jasper.servlet.JspServlet</p>
<p>处理servlet的：org.apache.catalina.servlets.InvokerServlet</p>
<p>不同的request就用这3种不同的servlet去处理。</p>
<p>Wrapper就是对它们的一种简单的封装，有了Wrapper后，我们就可以轻松地拦截每次的Request。也可以容易地调用servlet的init()和destroy()方法， 便于管理嘛！</p>
<p>具体情况是这么滴：</p>
<p>   如果request是找jsp文件，StandardWrapper里面就会封装一个org.apache.jasper.servlet.JspServlet去处理它。</p>
<p>   如果request是找 静态资源 ，StandardWrapper里面就会封装一个org.apache.jasper.servlet.DefaultServlet  去处理它。</p>
<p>   如果request是找servlet ，StandardWrapper里面就会封装一个org.apache.jasper.servlet.InvokerServlet 去处理它。</p>
<p>StandardWrapper同样也是容器，既然是容器， 那么里面一定留了一个管道给request去穿，管道低部肯定也有一个阀门(注1)，用来做最后一道拦截工作.</p>
<p>在这最底部的阀门里，其实就主要做了两件事:</p>
<p>   一是启动过滤器，让request在N个过滤器里面筛一通，如果OK！ 那就PASS。 否则就跳到其他地方去了。</p>
<p>   二是servlet.service((HttpServletRequest) request,(HttpServletResponse) response); 这个方法.</p>
<pre><code> 如果是JspServlet， 那么先把jsp文件编译成servlet_xxx, 再invoke servlet_xxx的servie()方法。

 如果是DefaultServlet， 就直接找到静态资源，取出内容， 发送出去。

 如果是InvokerServlet， 就调用那个具体的servlet的service()方法。
</code></pre><p>   ok! 完毕。</p>
<p>注1: StandardWrapper 里面的阀门是最后一道关口了。 如果这个阀门欲意把request交给StandardWrapper 的子容器处理。 对不起， 在设计考虑的时候，Wrapper就被考虑成最末的一个容器， 压根儿就不会给Wrapper添加子容器的机会！ 如果硬是要调用addChild(), 立马抛出IllegalArgumentException！</p>
<p>参考：</p>
<pre><code> &lt;http://jakarta.apache.org/tomcat/&gt;;
</code></pre><p>   <a href="http://www.onjava.com/pub/a/onjava/2003/05/14/java_webserver.html" target="_blank">http://www.onjava.com/pub/a/onjava/2003/05/14/java_webserver.html</a>;</p>
<p><a href="http://www.2cto.com/os/201202/119145.html" target="_blank">http://www.2cto.com/os/201202/119145.html</a>
来源： <a href="[http://blog.csdn.net/haojun186/article/details/7464912](http://blog.csdn.net/haojun186/article/details/7464912)">[http://blog.csdn.net/haojun186/article/details/7464912](http://blog.csdn.net/haojun186/article/details/7464912)</a> </p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/服务器/">服务器</a></li></span><span class="breadcrumb"><li><a href="/categories/服务器/">服务器</a></li><li><a href="/categories/服务器/tomcat/">tomcat</a></li></span></span> | <span class="tags">Tagged <a href="/tags/tomcat/" class="label label-primary">tomcat</a><a href="/tags/服务器/" class="label label-success">服务器</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:45"datetime="2014-03-07 09:54:45"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-服务器-tomcat--Tomcat源码分析/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-服务器-tomcat--Tomcat源码分析" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-wrapper--使用JavaServiceWrapper把Java程序作为Windows系统服务--IT/">使用Java Service Wrapper 把Java程序作为Windows系统服务 </a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:45.000Z"> <a href="/2014/02/02/2014-02-02-wrapper--使用JavaServiceWrapper把Java程序作为Windows系统服务--IT/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-java-service-wrapper-java-windows-iteye-">使用Java Service Wrapper 把Java程序作为Windows系统服务 - - ITeye技术网站</h1>
<p><a href="http://www.iteye.com/" target="_blank">首页</a> <a href="http://www.iteye.com/news" target="_blank">资讯</a> <a href="http://www.iteye.com/magazines" target="_blank">精华</a> <a href="http://www.iteye.com/forums" target="_blank">论坛</a> <a href="http://www.iteye.com/ask" target="_blank">问答</a> <a href="http://www.iteye.com/blogs" target="_blank">博客</a> <a href="http://www.iteye.com/blogs/subjects" target="_blank">专栏</a> <a href="http://www.iteye.com/groups" target="_blank">群组</a> <a href="http://lbyzx123.iteye.com/blog/248210#" target="_blank">更多 ▼</a></p>
<p><a href="http://www.iteye.com/job" target="_blank">招聘</a> <a href="http://www.iteye.com/search" target="_blank">搜索</a></p>
<p><a href="http://lbyzx123.iteye.com/login" title="登录" target="_blank">您还未登录 !</a> <a href="http://lbyzx123.iteye.com/login" target="_blank">登录</a> <a href="http://lbyzx123.iteye.com/signup" target="_blank">注册</a></p>
<h1 id="-lbyzx123-http-lbyzx123-iteye-com-"><a href="http://lbyzx123.iteye.com/" target="_blank">lbyzx123</a></h1>
<ul>
<li><a href="http://lbyzx123.iteye.com/" target="_blank"><strong>博客</strong></a></li>
<li><a href="http://lbyzx123.iteye.com/weibo" target="_blank">微博</a></li>
<li><a href="http://lbyzx123.iteye.com/album" target="_blank">相册</a></li>
<li><a href="http://lbyzx123.iteye.com/link" target="_blank">收藏</a></li>
<li><a href="http://lbyzx123.iteye.com/blog/guest_book" target="_blank">留言</a></li>
<li><a href="http://lbyzx123.iteye.com/blog/profile" target="_blank">关于我</a></li>
</ul>
<h3 id="-java-service-wrapper-java-windows-"><a href="">使用Java Service Wrapper 把Java程序作为Windows系统服务</a> **</h3>
<p><a href="http://www.iteye.com/blogs/tag/Java" target="_blank">Java</a><a href="http://www.iteye.com/blogs/tag/Windows" target="_blank">Windows</a><a href="http://www.iteye.com/blogs/tag/Tomcat" target="_blank">Tomcat</a><a href="http://www.iteye.com/blogs/tag/%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86" target="_blank">配置管理</a><a href="http://www.iteye.com/blogs/tag/C%23" target="_blank">C/#</a></p>
<p>Java程序很多情况下是作为服务程序运行的，在Un/<em>x平台下可以利用在命令后加“&amp;”把程序作为后台服务运行，但在Windows下看作那个Console窗口在桌面上，你是否一直担心别的同时把你的Console窗口关闭？是否怀念用VC写的Win32服务程序？
翻开JBOSS、Tomcat的发布包，发现他们都使用了一个Open source——Java Service Wrapper。用Java Service Wrapper可以轻松解决我们的需求，让我们的服务程序成为 Win32系统服务。
当然，在Un/</em>x下也可以使用Java Service Wrapper，可以避免加“&amp;”的粗暴方式，导致每天收到一堆mail，通过Java Service Wrapper提供的日志方式查看运行信息。
Java Service Wrapper功能很强大，同时支持Windows及Un/*x平台，提供三种方式把你的Java程序包装成系统服务，这里只介绍最简单的一种方式，因这种方式无需对已有的服务程序作任何改变，仅仅增加几个script、配置文件就可以把你的Java服务程序改造成系统服务程序了。
当然在使用之前需要到<a href="http://sourceforge.net/project/showfiles.php?group_id=39428下载Java" target="_blank">http://sourceforge.net/project/showfiles.php?group_id=39428下载Java</a> Service Wrapper的发布包。
下面简单介绍一下具体的使用步骤：</p>
<ol>
<li>将下载的Java Service Wrapper包解压到本地，目录为{WRAPPER_HOME}；</li>
<li>服务应用程序名为MyServApp，在目录d:\MyServApp下建立bin、conf、logs、lib目录；并把你的已有应用程序如NioBlockingServer.class拷贝到该目录下；</li>
<li>将{WRAPPER_HOME}\src\bin\下的遗以下文件拷贝到MyServApp目录下，并重命名。
{WRAPPER_HOME}\bin\Wrapper.exe  C:\ MyServApp \bin\Wrapper.exe
{WRAPPER_HOME}\src\bin\App.bat.in  C:\ MyServApp\bin\MyApp.bat
{WRAPPER_HOME}\src\bin\InstallApp-NT.bat.in  C:\ MyServApp\bin\InstallMyApp-NT.bat
{WRAPPER_HOME}\src\bin\UninstallApp-NT.bat.in  C:\ MyServApp\bin\UninstallMyApp-NT.bat</li>
<li>将{WRAPPER_HOME}\lib下的以下文件拷贝到C:\ MyServApp \lib目录下
{WRAPPER_HOME}\lib\Wrapper.DLL
{WRAPPER_HOME}\lib\wrapper.jar</li>
<li>将{WRAPPER_HOME}\src\conf\wrapper.conf.in拷贝到C:\ MyServApp \conf目录下并命名为wrapper.conf；并修改wrapper.conf文件，在其中配置您的应用服务。
主要修改以下几项即可：
/#你的JVM位置：
wrapper.java.command=D:\Sun\j2sdk1.4.0_03\bin\java
/#运行参数：如：
wrapper.java.additional.1=-Dprogram.name=run.bat
/#classpath：
wrapper.java.classpath.1=../lib/wrapper.jar
wrapper.java.classpath.2=../bin/.
/# Java Library Path (location of Wrapper.DLL or libwrapper.so)
wrapper.java.library.path.1=../lib
/#MAIN CLASS 此处决定了使用Java Service Wrapper的方式
wrapper.java.mainclass=org.tanukisoftware.wrapper.WrapperSimpleApp
/#你的Java应用类
wrapper.app.parameter.1= NonBlockingServer
/# 服务名
wrapper.ntservice.name=NB
/# Display name of the service
wrapper.ntservice.displayname=Nio Nonblocking Server
/# 服务描述
wrapper.ntservice.description=Nio Nonblocking Server
其他的配置根据你的需要改变即可</li>
<li>对以上配置的MyApp.bat进行测试，运行MyApp.bat，就像在Console窗口下运行Tomcat一样；</li>
<li>对以上配置的服务进行测试，运行C:\ MyServApp\bin\InstallMyApp-NT.bat将把你的应用（此处为NioBlockingServer）安装到Win32系统服务中了。</li>
<li>打开控制面板－管理程序－服务，看到Nio Nonblocking Server已经在系统服务中了，其他用法就与我们熟悉的Windows服务一样了。
Tomcat使用的是Java Service Wrapper模式二，这种方式需要对已有的程序进行小的改动，但可以通过Socket端口的方式控制服务程序核心的启动，更加灵活。Java Service Wrapper提供的模式三比较复杂，需要作出更多的编码，我没有研究。
采用模式一，即可简单有效的把我们的服务程序包装成为系统服务程序，并增强了日志功能，我们可以把MyServApp的几个文件做成模板，每次修改文件名，配置文件就可以了，有精力的朋友更可以做成Eclipse的plugin，鼠标点点就把应用配成服务了。
附件是一个模板，可以直接修改文件名和配置文件就可以把服务改造了。
希望本文能对大家有所帮助，当然也申请加分了，我的2分实在不够混的了。 <h1 id="-files-cai9911-ntservicewrappertemplate-rar-http-files-cnblogs-com-cai9911-ntservicewrappertemplate-rar-"><a href="http://files.cnblogs.com/cai9911/NTServiceWrapperTemplate.rar" target="_blank">/Files/cai9911/NTServiceWrapperTemplate.rar</a></h1>
自己做的一个例子,可以直接拿来修改:
(写下来备忘)
主要修改config/wrapper.conf 一个地方:
wrapper.app.parameter.1= HelloWorld  &lt;要启动的类&gt;
其他的可以修改应用程序的服务名称等.
<a href="http://files.cnblogs.com/cai9911/JavaService.rar" target="_blank">/Files/cai9911/JavaService.rar</a>
分享到： <a href="&quot;分享到新浪微博&quot;"><img src="" alt=""></a> <a href="&quot;分享到腾讯微博&quot;"><img src="" alt=""></a></li>
</ol>
<p><a href="http://lbyzx123.iteye.com/blog/258505" title="javascript中如何给二维数组赋值？" target="_blank">javascript中如何给二维数组赋值？</a> | <a href="http://lbyzx123.iteye.com/blog/248209" title="an error has occurred.See error log for more deta." target="_blank">an error has occurred.See error log for ...</a></p>
<ul>
<li>2008-09-30 13:40:07</li>
<li>浏览 4068</li>
<li><a href="http://lbyzx123.iteye.com/blog/248210#comments" target="_blank">评论(0)</a></li>
<li><a href="http://www.iteye.com/wiki/blog/248210" target="_blank">相关推荐</a></li>
</ul>
<h3 id="-">评论</h3>
<p><a href=""></a></p>
<h3 id="-">发表评论</h3>
<p><a href="http://lbyzx123.iteye.com/login" target="_blank"><img src="" alt=""></a><a href="http://lbyzx123.iteye.com/login" target="_blank">您还没有登录,请您登录后再发表评论</a></p>
<p><a href="http://lbyzx123.iteye.com/" target="_blank"><img src="&quot;lbyzx123的博客: &quot;" alt="lbyzx123的博客"></a></p>
<p>lbyzx123</p>
<ul>
<li>浏览: 51258 次</li>
<li>性别: <img src="&quot;男&quot;" alt="Icon_minigender_1"></li>
<li>来自: 杭州</li>
<li><img src="" alt=""><h3 id="-http-lbyzx123-iteye-com-blog-user_visits-">最近访客 <a href="http://lbyzx123.iteye.com/blog/user_visits" target="_blank">更多访客&gt;&gt;</a></h3>
</li>
</ul>
<p><a href="http://zhaoyijun.iteye.com/" target="_blank"><img src="&quot;zhaoyijun的博客: &quot;" alt="zhaoyijun的博客"></a></p>
<p><a href="http://zhaoyijun.iteye.com/" target="_blank">zhaoyijun</a></p>
<p><a href="http://yang8580330.iteye.com/" target="_blank"><img src="&quot;yang8580330的博客: &quot;" alt="yang8580330的博客"></a></p>
<p><a href="http://yang8580330.iteye.com/" target="_blank">yang8580330</a>
<a href="http://bgvhuy38.iteye.com/" target="_blank"><img src="&quot;bgvhuy38的博客: &quot;" alt="bgvhuy38的博客"></a></p>
<p><a href="http://bgvhuy38.iteye.com/" target="_blank">bgvhuy38</a></p>
<p><a href="http://taibin.iteye.com/" target="_blank"><img src="&quot;taibin的博客: &quot;" alt="taibin的博客"></a></p>
<p><a href="http://taibin.iteye.com/" target="_blank">taibin</a></p>
<h3 id="-">文章分类</h3>
<ul>
<li><a href="http://lbyzx123.iteye.com/" target="_blank">全部博客 (93)</a></li>
<li><a href="http://lbyzx123.iteye.com/category/42284" target="_blank">AJAX (0)</a></li>
<li><a href="http://lbyzx123.iteye.com/category/42285" target="_blank">J2EE (11)</a></li>
<li><a href="http://lbyzx123.iteye.com/category/42283" target="_blank">数据库 (14)</a></li>
<li><a href="http://lbyzx123.iteye.com/category/42286" target="_blank">JAVASCRIPT (16)</a></li>
<li><a href="http://lbyzx123.iteye.com/category/42287" target="_blank">哲理 (6)</a></li>
<li><a href="http://lbyzx123.iteye.com/category/42315" target="_blank">开发工具问题 (12)</a></li>
<li><a href="http://lbyzx123.iteye.com/category/42316" target="_blank">设计模式 (0)</a></li>
<li><a href="http://lbyzx123.iteye.com/category/44335" target="_blank">ExtJS (10)</a></li>
<li><a href="http://lbyzx123.iteye.com/category/122708" target="_blank">java (9)</a></li>
<li><a href="http://lbyzx123.iteye.com/category/137565" target="_blank">测试 (2)</a></li>
<li><p><a href="http://lbyzx123.iteye.com/category/191171" target="_blank">c++ (1)</a></p>
<h3 id="-">社区版块</h3>
</li>
<li><p><a href="http://lbyzx123.iteye.com/blog/news" target="_blank">我的资讯</a> (0)</p>
</li>
<li><a href="http://lbyzx123.iteye.com/blog/post" target="_blank">我的论坛</a> (1)</li>
<li><a href="http://lbyzx123.iteye.com/blog/solution" target="_blank">我解决的问题</a> (0)</li>
</ul>
<h3 id="-">存档分类</h3>
<ul>
<li><a href="http://lbyzx123.iteye.com/blog/monthblog/2012-01" target="_blank">2012-01</a> (1)</li>
<li><a href="http://lbyzx123.iteye.com/blog/monthblog/2011-12" target="_blank">2011-12</a> (4)</li>
<li><a href="http://lbyzx123.iteye.com/blog/monthblog/2011-11" target="_blank">2011-11</a> (3)</li>
<li><p><a href="http://lbyzx123.iteye.com/blog/monthblog_more" target="_blank">更多存档...</a></p>
<h3 id="-">评论排行榜</h3>
</li>
<li><p><a href="http://lbyzx123.iteye.com/blog/1139428" title="extjs4 异步树的写法" target="_blank">extjs4 异步树的写法</a></p>
</li>
<li><a href="http://lbyzx123.iteye.com/blog/1073789" title="请问一下mysql是不是限制了单个表的容量，能改吗" target="_blank">请问一下mysql是不是限制了单个表的容量， ...</a></li>
<li><a href="http://lbyzx123.iteye.com/blog/1172418" title="三个故事说穿许多人" target="_blank">三个故事说穿许多人</a></li>
</ul>
<h3 id="-">最新评论</h3>
<ul>
<li><a href="http://paradigm.iteye.com/" target="_blank">paradigm</a>： 谢谢
<a href="http://lbyzx123.iteye.com/blog/764985#bc2227490" target="_blank">WebSphere7.0数据源配置与应用程序发布之创建数据源</a></li>
<li><a href="http://gooderlee.iteye.com/" target="_blank">maozilee</a>： windows下面就用NTFS，没事儿！
<a href="http://lbyzx123.iteye.com/blog/1073789#bc2218928" target="_blank">请问一下mysql是不是限制了单个表的容量，能改吗</a></li>
<li><a href="http://lljjssljseye.iteye.com/" target="_blank">lljjssljseye</a>： ...
<a href="http://lbyzx123.iteye.com/blog/1172418#bc2216979" target="_blank">三个故事说穿许多人</a></li>
<li><a href="http://lbyzx123.iteye.com/" target="_blank">lbyzx123</a>： hable 写道看不明白啊,能不能加点注释 很简单呀，既然是异 ...
<a href="http://lbyzx123.iteye.com/blog/1139428#bc2213672" target="_blank">extjs4 异步树的写法</a></li>
<li><a href="http://hable.iteye.com/" target="_blank">hable</a>： 看不明白啊,能不能加点注释
<a href="http://lbyzx123.iteye.com/blog/1139428#bc2213623" target="_blank">extjs4 异步树的写法</a>
声明：ITeye文章版权属于作者，受法律保护。没有作者书面许可不得转载。若作者同意转载，必须以超链接形式标明文章原始出处和作者。
© 2003-2011 ITeye.com. All rights reserved. [ 京ICP证110151号 京公网安备110105010620 ]
<img src="" alt=""></li>
</ul>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/wrapper/">wrapper</a></li></span></span> | <span class="tags">Tagged <a href="/tags/wrapper/" class="label label-primary">wrapper</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:45"datetime="2014-03-07 09:54:45"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-wrapper--使用JavaServiceWrapper把Java程序作为Windows系统服务--IT/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-wrapper--使用JavaServiceWrapper把Java程序作为Windows系统服务--IT" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-服务器-tomcat--Servlet工作原理/">Servlet工作原理</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:45.000Z"> <a href="/2014/02/02/2014-02-02-服务器-tomcat--Servlet工作原理/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="servlet-">Servlet工作原理</h1>
<p><a href="http://blog.csdn.net/haojun186/article/details/7467100" target="_blank">Servlet工作原理</a></p>
<p><a href="">从 Servlet 容器说起</a></p>
<p>要介绍 Servlet 必须要先把 Servlet 容器说清楚，Servlet 与 Servlet 容器的关系有点像枪和子弹的关系，枪是为子弹而生，而子弹又让枪有了杀伤力。虽然它们是彼此依存的，但是又相互独立发展，这一切都是为了适应工业化生产的结果。从技术角度来说是为了解耦，通过标准化接口来相互协作。既然接口是连接 Servlet 与 Servlet 容器的关键，那我们就从它们的接口说起。</p>
<p>前面说了 Servlet 容器作为一个独立发展的标准化产品，目前它的种类很多，但是它们都有自己的市场定位，很难说谁优谁劣，各有特点。例如现在比较流行的 Jetty，在定制化和移动领域有不错的发展，我们这里还是以大家最为熟悉 Tomcat 为例来介绍 Servlet 容器如何管理 Servlet。Tomcat 本身也很复杂，我们只从 Servlet 与 Servlet 容器的接口部分开始介绍，关于 Tomcat 的详细介绍可以参考我的另外一篇文章《 Tomcat 系统架构与模式设计分析》。</p>
<p>Tomcat 的容器等级中，Context 容器是直接管理 Servlet 在容器中的包装类 Wrapper，所以 Context 容器如何运行将直接影响 Servlet 的工作方式。
<a href=""><strong>图 1 . Tomcat 容器模型</strong></a>
<img src="" alt="图 1 . Tomcat 容器模型"></p>
<p>从上图可以看出 Tomcat 的容器分为四个等级，真正管理 Servlet 的容器是 Context 容器，一个 Context 对应一个 Web 工程，在 Tomcat 的配置文件中可以很容易发现这一点，如下：
<a href=""><strong>清单 1 Context 配置参数</strong></a></p>
<Context path="/projectOne " docBase="D:\projects\projectOne"
reloadable="true" />

<p>下面详细介绍一下 Tomcat 解析 Context 容器的过程，包括如何构建 Servlet 的过程。</p>
<p><a href="">Servlet 容器的启动过程</a></p>
<p>Tomcat7 也开始支持嵌入式功能，增加了一个启动类 org.apache.catalina.startup.Tomcat。创建一个实例对象并调用 start 方法就可以很容易启动 Tomcat，我们还可以通过这个对象来增加和修改 Tomcat 的配置参数，如可以动态增加 Context、Servlet 等。下面我们就利用这个 Tomcat 类来管理新增的一个 Context 容器，我们就选择 Tomcat7 自带的 examples Web 工程，并看看它是如何加到这个 Context 容器中的。
<a href=""><strong>清单 2 . 给 Tomcat 增加一个 Web 工程</strong></a></p>
<p>Tomcat tomcat = getTomcatInstance();
File appDir = new File(getBuildDirectory(), &quot;webapps/examples&quot;);</p>
<p>tomcat.addWebapp(null, &quot;/examples&quot;, appDir.getAbsolutePath());
tomcat.start();</p>
<p>ByteChunk res = getUrl(&quot;<a href="http://localhost" target="_blank">http://localhost</a>:&quot; + getPort() +
               &quot;/examples/servlets/servlet/HelloWorldExample&quot;);</p>
<p>assertTrue(res.toString().indexOf(&quot;<h1>Hello World!</h1>&quot;) &gt; 0);</p>
<p>清单 1 的代码是创建一个 Tomcat 实例并新增一个 Web 应用，然后启动 Tomcat 并调用其中的一个 HelloWorldExample Servlet，看有没有正确返回预期的数据。</p>
<p>Tomcat 的 addWebapp 方法的代码如下：
<a href=""><strong>清单 3 .Tomcat.addWebapp</strong></a></p>
<p>public Context addWebapp(Host host, String url, String path) {
        silence(url);</p>
<pre><code>    Context ctx = new StandardContext();
    ctx.setPath( url );

    ctx.setDocBase(path);
    if (defaultRealm == null) {

        initSimpleAuth();
    }

    ctx.setRealm(defaultRealm);
    ctx.addLifecycleListener(new DefaultWebXmlListener());

    ContextConfig ctxCfg = new ContextConfig();
    ctx.addLifecycleListener(ctxCfg);

    ctxCfg.setDefaultWebXml(&quot;org/apache/catalin/startup/NO_DEFAULT_XML&quot;);
    if (host == null) {

        getHost().addChild(ctx);
    } else {

        host.addChild(ctx);
    }

    return ctx;
</code></pre><p>}</p>
<p>前面已经介绍了一个 Web 应用对应一个 Context 容器，也就是 Servlet 运行时的 Servlet 容器，添加一个 Web 应用时将会创建一个 StandardContext 容器，并且给这个 Context 容器设置必要的参数，url 和 path 分别代表这个应用在 Tomcat 中的访问路径和这个应用实际的物理路径，这个两个参数与清单 1 中的两个参数是一致的。其中最重要的一个配置是 ContextConfig，这个类将会负责整个 Web 应用配置的解析工作，后面将会详细介绍。最后将这个 Context 容器加到父容器 Host 中。</p>
<p>接下去将会调用 Tomcat 的 start 方法启动 Tomcat，如果你清楚 Tomcat 的系统架构，你会容易理解 Tomcat 的启动逻辑，Tomcat 的启动逻辑是基于观察者模式设计的，所有的容器都会继承 Lifecycle 接口，它管理者容器的整个生命周期，所有容器的的修改和状态的改变都会由它去通知已经注册的观察者（Listener），关于这个设计模式可以参考《 Tomcat 的系统架构与设计模式，第二部分：设计模式》。Tomcat 启动的时序图可以用图 2 表示。
<a href=""><strong>图 2. Tomcat 主要类的启动时序图（</strong></a><strong><a href="http://www.ibm.com/developerworks/cn/java/j-lo-servlet/image003.jpg" target="_blank">查看大图</a>）</strong>
<img src="" alt="图 2. Tomcat 主要类的启动时序图"></p>
<p>上图描述了 Tomcat 启动过程中，主要类之间的时序关系，下面我们将会重点关注添加 examples 应用所对应的 StandardContext 容器的启动过程。</p>
<p>当 Context 容器初始化状态设为 init 时，添加在 Contex 容器的 Listener 将会被调用。ContextConfig 继承了 LifecycleListener 接口，它是在调用清单 3 时被加入到 StandardContext 容器中。ContextConfig 类会负责整个 Web 应用的配置文件的解析工作。</p>
<p>ContextConfig 的 init 方法将会主要完成以下工作：</p>
<ol>
<li>创建用于解析 xml 配置文件的 contextDigester 对象</li>
<li>读取默认 context.xml 配置文件，如果存在解析它</li>
<li>读取默认 Host 配置文件，如果存在解析它</li>
<li>读取默认 Context 自身的配置文件，如果存在解析它</li>
<li>设置 Context 的 DocBase</li>
</ol>
<p>ContextConfig 的 init 方法完成后，Context 容器的会执行 startInternal 方法，这个方法启动逻辑比较复杂，主要包括如下几个部分：</p>
<ol>
<li>创建读取资源文件的对象</li>
<li>创建 ClassLoader 对象</li>
<li>设置应用的工作目录</li>
<li>启动相关的辅助类如：logger、realm、resources 等</li>
<li>修改启动状态，通知感兴趣的观察者（Web 应用的配置）</li>
<li>子容器的初始化</li>
<li>获取 ServletContext 并设置必要的参数</li>
<li>初始化“load on startup”的 Servlet</li>
</ol>
<p><a href="">Web 应用的初始化工作</a></p>
<p>Web 应用的初始化工作是在 ContextConfig 的 configureStart 方法中实现的，应用的初始化主要是要解析 web.xml 文件，这个文件描述了一个 Web 应用的关键信息，也是一个 Web 应用的入口。</p>
<p>Tomcat 首先会找 globalWebXml 这个文件的搜索路径是在 engine 的工作目录下寻找以下两个文件中的任一个 org/apache/catalin/startup/NO_DEFAULT_XML 或 conf/web.xml。接着会找 hostWebXml 这个文件可能会在 System.getProperty(&quot;catalina.base&quot;)/conf/${EngineName}/${HostName}/web.xml.default，接着寻找应用的配置文件 examples/WEB-INF/web.xml。web.xml 文件中的各个配置项将会被解析成相应的属性保存在 WebXml 对象中。如果当前应用支持 Servlet3.0，解析还将完成额外 9 项工作，这个额外的 9 项工作主要是为 Servlet3.0 新增的特性，包括 jar 包中的 META-INF/web-fragment.xml 的解析以及对 annotations 的支持。</p>
<p>接下去将会将 WebXml 对象中的属性设置到 Context 容器中，这里包括创建 Servlet 对象、filter、listener 等等。这段代码在 WebXml 的 configureContext 方法中。下面是解析 Servlet 的代码片段：
<a href=""><strong>清单 4. 创建 Wrapper 实例</strong></a></p>
<p>for (ServletDef servlet : servlets.values()) {
            Wrapper wrapper = context.createWrapper();</p>
<pre><code>        String jspFile = servlet.getJspFile();
        if (jspFile != null) {

            wrapper.setJspFile(jspFile);
        }

        if (servlet.getLoadOnStartup() != null) {
            wrapper.setLoadOnStartup(servlet.getLoadOnStartup().intValue());

        }
        if (servlet.getEnabled() != null) {

            wrapper.setEnabled(servlet.getEnabled().booleanValue());
        }

        wrapper.setName(servlet.getServletName());
        Map&lt;String,String&gt; params = servlet.getParameterMap();

        for (Entry&lt;String, String&gt; entry : params.entrySet()) {
            wrapper.addInitParameter(entry.getKey(), entry.getValue());

        }
        wrapper.setRunAs(servlet.getRunAs());

        Set&lt;SecurityRoleRef&gt; roleRefs = servlet.getSecurityRoleRefs();
        for (SecurityRoleRef roleRef : roleRefs) {

            wrapper.addSecurityReference(
                    roleRef.getName(), roleRef.getLink());

        }
        wrapper.setServletClass(servlet.getServletClass());

        MultipartDef multipartdef = servlet.getMultipartDef();
        if (multipartdef != null) {

            if (multipartdef.getMaxFileSize() != null &amp;&amp;
                    multipartdef.getMaxRequestSize()!= null &amp;&amp;

                    multipartdef.getFileSizeThreshold() != null) {
                wrapper.setMultipartConfigElement(new
</code></pre><p>MultipartConfigElement(
                            multipartdef.getLocation(),</p>
<pre><code>                        Long.parseLong(multipartdef.getMaxFileSize()),
                        Long.parseLong(multipartdef.getMaxRequestSize()),

                        Integer.parseInt(
                                multipartdef.getFileSizeThreshold())));

            } else {
                wrapper.setMultipartConfigElement(new
</code></pre><p>MultipartConfigElement(
                            multipartdef.getLocation()));</p>
<pre><code>            }
        }

        if (servlet.getAsyncSupported() != null) {
            wrapper.setAsyncSupported(

                    servlet.getAsyncSupported().booleanValue());
        }

        context.addChild(wrapper);
</code></pre><p>}</p>
<p>这段代码清楚的描述了如何将 Servlet 包装成 Context 容器中的 StandardWrapper，这里有个疑问，为什么要将 Servlet 包装成 StandardWrapper 而不直接是 Servlet 对象。这里 StandardWrapper 是 Tomcat 容器中的一部分，它具有容器的特征，而 Servlet 为了一个独立的 web 开发标准，不应该强耦合在 Tomcat 中。</p>
<p>除了将 Servlet 包装成 StandardWrapper 并作为子容器添加到 Context 中，其它的所有 web.xml 属性都被解析到 Context 中，所以说 Context 容器才是真正运行 Servlet 的 Servlet 容器。一个 Web 应用对应一个 Context 容器，容器的配置属性由应用的 web.xml 指定，这样我们就能理解 web.xml 到底起到什么作用了。</p>
<p><a href="http://www.ibm.com/developerworks/cn/java/j-lo-servlet/#ibm-pcon" target="_blank">回页首</a></p>
<p><a href="">创建 Servlet 实例</a></p>
<p>前面已经完成了 Servlet 的解析工作，并且被包装成 StandardWrapper 添加在 Context 容器中，但是它仍然不能为我们工作，它还没有被实例化。下面我们将介绍 Servlet 对象是如何创建的，以及如何被初始化的。</p>
<p><a href="">创建 Servlet 对象</a></p>
<p>如果 Servlet 的 load-on-startup 配置项大于 0，那么在 Context 容器启动的时候就会被实例化，前面提到在解析配置文件时会读取默认的 globalWebXml，在 conf 下的 web.xml 文件中定义了一些默认的配置项，其定义了两个 Servlet，分别是：org.apache.catalina.servlets.DefaultServlet 和 org.apache.jasper.servlet.JspServlet 它们的 load-on-startup 分别是 1 和 3，也就是当 Tomcat 启动时这两个 Servlet 就会被启动。</p>
<p>创建 Servlet 实例的方法是从 Wrapper. loadServlet 开始的。loadServlet 方法要完成的就是获取 servletClass 然后把它交给 InstanceManager 去创建一个基于 servletClass.class 的对象。如果这个 Servlet 配置了 jsp-file，那么这个 servletClass 就是 conf/web.xml 中定义的 org.apache.jasper.servlet.JspServlet 了。</p>
<p>创建 Servlet 对象的相关类结构图如下：
<a href=""><strong>图 3. 创建 Servlet 对象的相关类结构</strong></a>
<img src="" alt="图 3. 创建 Servlet 对象的相关类结构"></p>
<p><a href="">初始化 Servlet</a></p>
<p>初始化 Servlet 在 StandardWrapper 的 initServlet 方法中，这个方法很简单就是调用 Servlet 的 init 的方法，同时把包装了 StandardWrapper 对象的 StandardWrapperFacade 作为 ServletConfig 传给 Servlet。Tomcat 容器为何要传 StandardWrapperFacade 给 Servlet 对象将在后面做详细解析。</p>
<p>如果该 Servlet 关联的是一个 jsp 文件，那么前面初始化的就是 JspServlet，接下去会模拟一次简单请求，请求调用这个 jsp 文件，以便编译这个 jsp 文件为 class，并初始化这个 class。</p>
<p>这样 Servlet 对象就初始化完成了，事实上 Servlet 从被 web.xml 中解析到完成初始化，这个过程非常复杂，中间有很多过程，包括各种容器状态的转化引起的监听事件的触发、各种访问权限的控制和一些不可预料的错误发生的判断行为等等。我们这里只抓了一些关键环节进行阐述，试图让大家有个总体脉络。</p>
<p>下面是这个过程的一个完整的时序图，其中也省略了一些细节。
<a href=""><strong>图 4. 初始化 Servlet 的时序图（</strong></a><strong><a href="http://www.ibm.com/developerworks/cn/java/j-lo-servlet/image007.jpg" target="_blank">查看大图</a>）</strong>
<img src="" alt="图 4. 初始化 Servlet 的时序图"></p>
<p><a href="http://www.ibm.com/developerworks/cn/java/j-lo-servlet/#ibm-pcon" target="_blank">回页首</a></p>
<p><a href="">Servlet 体系结构</a></p>
<p>我们知道 Java Web 应用是基于 Servlet 规范运转的，那么 Servlet 本身又是如何运转的呢？为何要设计这样的体系结构。
<a href=""><strong>图 5.Servlet 顶层类关联图</strong></a>
<img src="" alt="图 5.Servlet 顶层类关联图"></p>
<p>从上图可以看出 Servlet 规范就是基于这几个类运转的，与 Servlet 主动关联的是三个类，分别是 ServletConfig、ServletRequest 和 ServletResponse。这三个类都是通过容器传递给 Servlet 的，其中 ServletConfig 是在 Servlet 初始化时就传给 Servlet 了，而后两个是在请求达到时调用 Servlet 时传递过来的。我们很清楚 ServletRequest 和 ServletResponse 在 Servlet 运行的意义，但是 ServletConfig 和 ServletContext 对 Servlet 有何价值？仔细查看 ServletConfig 接口中声明的方法发现，这些方法都是为了获取这个 Servlet 的一些配置属性，而这些配置属性可能在 Servlet 运行时被用到。而 ServletContext 又是干什么的呢？ Servlet 的运行模式是一个典型的“握手型的交互式”运行模式。所谓“握手型的交互式”就是两个模块为了交换数据通常都会准备一个交易场景，这个场景一直跟随个这个交易过程直到这个交易完成为止。这个交易场景的初始化是根据这次交易对象指定的参数来定制的，这些指定参数通常就会是一个配置类。所以对号入座，交易场景就由 ServletContext 来描述，而定制的参数集合就由 ServletConfig 来描述。而 ServletRequest 和 ServletResponse 就是要交互的具体对象了，它们通常都是作为运输工具来传递交互结果。</p>
<p>ServletConfig 是在 Servlet init 时由容器传过来的，那么 ServletConfig 到底是个什么对象呢？</p>
<p>下图是 ServletConfig 和 ServletContext 在 Tomcat 容器中的类关系图。
<a href=""><strong>图 6. ServletConfig 在容器中的类关联图</strong></a>
<img src="" alt="图 6. ServletConfig 在容器中的类关联图"></p>
<p>上图可以看出 StandardWrapper 和 StandardWrapperFacade 都实现了 ServletConfig 接口，而 StandardWrapperFacade 是 StandardWrapper 门面类。所以传给 Servlet 的是 StandardWrapperFacade 对象，这个类能够保证从 StandardWrapper 中拿到 ServletConfig 所规定的数据，而又不把 ServletConfig 不关心的数据暴露给 Servlet。</p>
<p>同样 ServletContext 也与 ServletConfig 有类似的结构，Servlet 中能拿到的 ServletContext 的实际对象也是 ApplicationContextFacade 对象。ApplicationContextFacade 同样保证 ServletContex 只能从容器中拿到它该拿的数据，它们都起到对数据的封装作用，它们使用的都是门面设计模式。</p>
<p>通过 ServletContext 可以拿到 Context 容器中一些必要信息，比如应用的工作路径，容器支持的 Servlet 最小版本等。</p>
<p>Servlet 中定义的两个 ServletRequest 和 ServletResponse 它们实际的对象又是什么呢？，我们在创建自己的 Servlet 类时通常使用的都是 HttpServletRequest 和 HttpServletResponse，它们继承了 ServletRequest 和 ServletResponse。为何 Context 容器传过来的 ServletRequest、ServletResponse 可以被转化为 HttpServletRequest 和 HttpServletResponse 呢？
<a href=""><strong>图 7.Request 相关类结构图</strong></a>
<img src="" alt="图 7.Request 相关类结构图"></p>
<p>上图是 Tomcat 创建的 Request 和 Response 的类结构图。Tomcat 一接受到请求首先将会创建 org.apache.coyote.Request 和 org.apache.coyote.Response，这两个类是 Tomcat 内部使用的描述一次请求和相应的信息类它们是一个轻量级的类，它们作用就是在服务器接收到请求后，经过简单解析将这个请求快速的分配给后续线程去处理，所以它们的对象很小，很容易被 JVM 回收。接下去当交给一个用户线程去处理这个请求时又创建 org.apache.catalina.connector. Request 和 org.apache.catalina.connector. Response 对象。这两个对象一直穿越整个 Servlet 容器直到要传给 Servlet，传给 Servlet 的是 Request 和 Response 的门面类 RequestFacade 和 RequestFacade，这里使用门面模式与前面一样都是基于同样的目的——封装容器中的数据。一次请求对应的 Request 和 Response 的类转化如下图所示：
<a href=""><strong>图 8.Request 和 Response 的转变过程</strong></a>
<img src="" alt="图 8.Request 和 Response 的转变过程"></p>
<p><a href="http://www.ibm.com/developerworks/cn/java/j-lo-servlet/#ibm-pcon" target="_blank">回页首</a></p>
<p><a href="">Servlet 如何工作</a></p>
<p>我们已经清楚了 Servlet 是如何被加载的、Servlet 是如何被初始化的，以及 Servlet 的体系结构，现在的问题就是它是如何被调用的。</p>
<p>当用户从浏览器向服务器发起一个请求，通常会包含如下信息：<a href="http://hostname" target="_blank">http://hostname</a>: port /contextpath/servletpath，hostname 和 port 是用来与服务器建立 TCP 连接，而后面的 URL 才是用来选择服务器中那个子容器服务用户的请求。那服务器是如何根据这个 URL 来达到正确的 Servlet 容器中的呢？</p>
<p>Tomcat7.0 中这件事很容易解决，因为这种映射工作有专门一个类来完成的，这个就是 org.apache.tomcat.util.http.mapper，这个类保存了 Tomcat 的 Container 容器中的所有子容器的信息，当 org.apache.catalina.connector. Request 类在进入 Container 容器之前，mapper 将会根据这次请求的 hostnane 和 contextpath 将 host 和 context 容器设置到 Request 的 mappingData 属性中。所以当 Request 进入 Container 容器之前，它要访问那个子容器这时就已经确定了。
<a href=""><strong>图 9.Request 的 Mapper 类关系图</strong></a>
<img src="" alt="图 9.Request 的 Mapper 类关系图"></p>
<p>可能你有疑问，mapper 中怎么会有容器的完整关系，这要回到图 2 中 19 步 MapperListener 类的初始化过程，下面是 MapperListener 的 init 方法代码 :
<a href=""><strong>清单 5. MapperListener.init</strong></a></p>
<p>public void init() {
        findDefaultHost();</p>
<pre><code>    Engine engine = (Engine) connector.getService().getContainer();
    engine.addContainerListener(this);

    Container[] conHosts = engine.findChildren();
    for (Container conHost : conHosts) {

        Host host = (Host) conHost;
        if (!LifecycleState.NEW.equals(host.getState())) {

            host.addLifecycleListener(this);
            registerHost(host);

        }
    }
</code></pre><p>}</p>
<p>这段代码的作用就是将 MapperListener 类作为一个监听者加到整个 Container 容器中的每个子容器中，这样只要任何一个容器发生变化，MapperListener 都将会被通知，相应的保存容器关系的 MapperListener 的 mapper 属性也会修改。for 循环中就是将 host 及下面的子容器注册到 mapper 中。
<a href=""><strong>图 10.Request 在容器中的路由图</strong></a>
<img src="" alt="图 10.Request 在容器中的路由图"></p>
<p>上图描述了一次 Request 请求是如何达到最终的 Wrapper 容器的，我们现正知道了请求是如何达到正确的 Wrapper 容器，但是请求到达最终的 Servlet 还要完成一些步骤，必须要执行 Filter 链，以及要通知你在 web.xml 中定义的 listener。</p>
<p>接下去就要执行 Servlet 的 service 方法了，通常情况下，我们自己定义的 servlet 并不是直接去实现 javax.servlet.servlet 接口，而是去继承更简单的 HttpServlet 类或者 GenericServlet 类，我们可以有选择的覆盖相应方法去实现我们要完成的工作。</p>
<p>Servlet 的确已经能够帮我们完成所有的工作了，但是现在的 web 应用很少有直接将交互全部页面都用 servlet 来实现，而是采用更加高效的 MVC 框架来实现。这些 MVC 框架基本的原理都是将所有的请求都映射到一个 Servlet，然后去实现 service 方法，这个方法也就是 MVC 框架的入口。</p>
<p>当 Servlet 从 Servlet 容器中移除时，也就表明该 Servlet 的生命周期结束了，这时 Servlet 的 destroy 方法将被调用，做一些扫尾工作。</p>
<p><a href="http://www.ibm.com/developerworks/cn/java/j-lo-servlet/#ibm-pcon" target="_blank">回页首</a></p>
<p><a href="">Session 与 Cookie</a></p>
<p>前面我们已经说明了 Servlet 如何被调用，我们基于 Servlet 来构建应用程序，那么我们能从 Servlet 获得哪些数据信息呢？</p>
<p>Servlet 能够给我们提供两部分数据，一个是在 Servlet 初始化时调用 init 方法时设置的 ServletConfig，这个类基本上含有了 Servlet 本身和 Servlet 所运行的 Servlet 容器中的基本信息。根据前面的介绍 ServletConfig 的实际对象是 StandardWrapperFacade，到底能获得哪些容器信息可以看看这类提供了哪些接口。还有一部分数据是由 ServletRequest 类提供，它的实际对象是 RequestFacade，从提供的方法中发现主要是描述这次请求的 HTTP 协议的信息。所以要掌握 Servlet 的工作方式必须要很清楚 HTTP 协议，如果你还不清楚赶紧去找一些参考资料。关于这一块还有一个让很多人迷惑的 Session 与 Cookie。</p>
<p>Session 与 Cookie 不管是对 Java Web 的熟练使用者还是初学者来说都是一个令人头疼的东西。Session 与 Cookie 的作用都是为了保持访问用户与后端服务器的交互状态。它们有各自的优点也有各自的缺陷。然而具有讽刺意味的是它们优点和它们的使用场景又是矛盾的，例如使用 Cookie 来传递信息时，随着 Cookie 个数的增多和访问量的增加，它占用的网络带宽也很大，试想假如 Cookie 占用 200 个字节，如果一天的 PV 有几亿的时候，它要占用多少带宽。所以大访问量的时候希望用 Session，但是 Session 的致命弱点是不容易在多台服务器之间共享，所以这也限制了 Session 的使用。</p>
<p>不管 Session 和 Cookie 有什么不足，我们还是要用它们。下面详细讲一下，Session 如何基于 Cookie 来工作。实际上有三种方式能可以让 Session 正常工作：</p>
<ol>
<li>基于 URL Path Parameter，默认就支持</li>
<li>基于 Cookie，如果你没有修改 Context 容器个 cookies 标识的话，默认也是支持的</li>
<li>基于 SSL，默认不支持，只有 connector.getAttribute(&quot;SSLEnabled&quot;) 为 TRUE 时才支持</li>
</ol>
<p>第一种情况下，当浏览器不支持 Cookie 功能时，浏览器会将用户的 SessionCookieName 重写到用户请求的 URL 参数中，它的传递格式如 /path/Servlet;name=value;name2=value2? Name3=value3，其中“Servlet；”后面的 K-V 对就是要传递的 Path Parameters，服务器会从这个 Path Parameters 中拿到用户配置的 SessionCookieName。关于这个 SessionCookieName，如果你在 web.xml 中配置 session-config 配置项的话，其 cookie-config 下的 name 属性就是这个 SessionCookieName 值，如果你没有配置 session-config 配置项，默认的 SessionCookieName 就是大家熟悉的“JSESSIONID”。接着 Request 根据这个 SessionCookieName 到 Parameters 拿到 Session ID 并设置到 request.setRequestedSessionId 中。</p>
<p>请注意如果客户端也支持 Cookie 的话，Tomcat 仍然会解析 Cookie 中的 Session ID，并会覆盖 URL 中的 Session ID。</p>
<p>如果是第三种情况的话将会根据 javax.servlet.request.ssl_session 属性值设置 Session ID。</p>
<p>有了 Session ID 服务器端就可以创建 HttpSession 对象了，第一次触发是通过 request. getSession() 方法，如果当前的 Session ID 还没有对应的 HttpSession 对象那么就创建一个新的，并将这个对象加到 org.apache.catalina. Manager 的 sessions 容器中保存，Manager 类将管理所有 Session 的生命周期，Session 过期将被回收，服务器关闭，Session 将被序列化到磁盘等。只要这个 HttpSession 对象存在，用户就可以根据 Session ID 来获取到这个对象，也就达到了状态的保持。
<a href=""><strong>图 11.Session 相关类图</strong></a>
<img src="" alt="图 11.Session 相关类图"></p>
<p>上从图中可以看出从 request.getSession 中获取的 HttpSession 对象实际上是 StandardSession 对象的门面对象，这与前面的 Request 和 Servlet 是一样的原理。下图是 Session 工作的时序图：
<a href=""><strong>图 12.Session 工作的时序图（</strong></a><strong><a href="http://www.ibm.com/developerworks/cn/java/j-lo-servlet/image023.jpg" target="_blank">查看大图</a>）</strong>
<img src="" alt="图 12.Session 工作的时序图"></p>
<p>还有一点与 Session 关联的 Cookie 与其它 Cookie 没有什么不同，这个配置的配置可以通过 web.xml 中的 session-config 配置项来指定。</p>
<p><a href="http://www.ibm.com/developerworks/cn/java/j-lo-servlet/#ibm-pcon" target="_blank">回页首</a></p>
<p><a href="">Servlet 中的 Listener</a></p>
<p>整个 Tomcat 服务器中 Listener 使用的非常广泛，它是基于观察者模式设计的，Listener 的设计对开发 Servlet 应用程序提供了一种快捷的手段，能够方便的从另一个纵向维度控制程序和数据。目前 Servlet 中提供了 5 种两类事件的观察者接口，它们分别是：4 个 EventListeners 类型的，ServletContextAttributeListener、ServletRequestAttributeListener、ServletRequestListener、HttpSessionAttributeListener 和 2 个 LifecycleListeners 类型的，ServletContextListener、HttpSessionListener。如下图所示：
<a href=""><strong>图 13.Servlet 中的 Listener（</strong></a><strong><a href="http://www.ibm.com/developerworks/cn/java/j-lo-servlet/image025.png" target="_blank">查看大图</a>）</strong>
<img src="" alt="图 13.Servlet 中的 Listener"></p>
<p>它们基本上涵盖了整个 Servlet 生命周期中，你感兴趣的每种事件。这些 Listener 的实现类可以配置在 web.xml 中的 <listener> 标签中。当然也可以在应用程序中动态添加 Listener，需要注意的是 ServletContextListener 在容器启动之后就不能再添加新的，因为它所监听的事件已经不会再出现。掌握这些 Listener 的使用，能够让我们的程序设计的更加灵活。
来源： <a href="[http://blog.csdn.net/haojun186/article/details/7467100](http://blog.csdn.net/haojun186/article/details/7467100)">[http://blog.csdn.net/haojun186/article/details/7467100](http://blog.csdn.net/haojun186/article/details/7467100)</a> </p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/服务器/">服务器</a></li></span><span class="breadcrumb"><li><a href="/categories/服务器/">服务器</a></li><li><a href="/categories/服务器/tomcat/">tomcat</a></li></span></span> | <span class="tags">Tagged <a href="/tags/tomcat/" class="label label-primary">tomcat</a><a href="/tags/服务器/" class="label label-success">服务器</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:45"datetime="2014-03-07 09:54:45"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-服务器-tomcat--Servlet工作原理/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-服务器-tomcat--Servlet工作原理" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>





<ul id="pagination" class="pagination pagination-lg">
  <li><a class="extend prev" href="/page/8/">&laquo;</a></li><li><a class="page-number" href="/">1</a></li><li><a class="page-number" href="/page/2/">2</a></li><li><span class="space">&hellip;</span></li><li><a class="page-number" href="/page/6/">6</a></li><li><a class="page-number" href="/page/7/">7</a></li><li><a class="page-number" href="/page/8/">8</a></li><li class="active"><li><span class="page-number current">9</span></li><li><a class="page-number" href="/page/10/">10</a></li><li><a class="page-number" href="/page/11/">11</a></li><li><a class="page-number" href="/page/12/">12</a></li><li><span class="space">&hellip;</span></li></li><li><a class="page-number" href="/page/164/">164</a></li><li><a class="page-number" href="/page/165/">165</a></li><li><a class="extend next" href="/page/10/">&raquo;</a></li>
  <div class="clearfix"></div>
</ul></div><!--wapper-->
       </div><!-- ID main-col END -->
       <aside id="sidebar" class="alignright col-sx-6 col-sm-4 col-md-3 col-lg-3">
<div id="widget_search" class="widget panel panel-primary">
    <form action="//google.com/search" method="get" accept-charset="utf-8">
  <div class="input-group">
    <input class="form-control" id="searchbox" type="search" name="q" results="0" placeholder="search">
    <span class="input-group-btn">
      <button class="btn btn-default" type="submit">Go!</button>
    </span>
    <input type="hidden" name="q" value="site:itsolife.com">
  </div>
</form>
</div>

<div id="widget_category" class="widget panel panel-primary">
  <div class="panel-heading">category</div>  <div data-src='category' class='ajax_widgets'>正在加载...</div>
</div>

<div id="widget_recent_posts" class="widget panel panel-primary">
  <div class="panel-heading">recent posts</div>  <div data-src='recent_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_tagcloud" class="widget panel panel-primary">
  <div class="panel-heading">tagcloud</div>  <div data-src='tagcloud' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_latest_update_posts" class="widget panel panel-primary">
  <div class="panel-heading">最近更新</div>  <div data-src='latest_update_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_recent_comments" class="widget panel panel-primary">
  <div class="panel-heading">recent comments</div>  

<div class="list-group-item ds-recent-comments" data-num-items="6" data-show-avatars="1" data-show-time="1" data-show-title="1" data-show-admin="1" data-excerpt-length="50"></div>



</div>

</aside>
       <div class="clearfix"></div>
     </div><!-- row END -->
  </div>
  <footer id="footer" class="container">
  <div class="panel panel-info">
  <section id='footer_widget'></section>  <div class="panel-footer">
  <div id="site-info">
    <span class='author'>
  
  &copy; 2014 RobinChia
  
    &nbsp;&nbsp;</span>
  
  <span id='analytics-51la'></span><span id='analytics-google'>
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-48559895-1']);
  _gaq.push(['_trackPageview']);
  _js2load.push({src:('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'});
</script></span><span id='analytics-cnzz'>
<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_5774006'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s17.cnzz.com/stat.php%3Fid%3D5774006%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>
</span><span id='analytics-baidu'>
<script>
var _hmt = _hmt || [];
_js2load.push({src:"//hm.baidu.com/hm.js?1442f50724afc42380b51f097c43082c"});
</script>
</span>  </div>
  <div id="copyright">Blog powered by <a href='http://zespia.tw/hexo/'><strong>hexo</strong></a> Theme <strong><a href='https://github.com/chenall/hexo-theme-chenall'>chenall</a></strong>(Some change in it)<span class="pull-right"> 更新时间: <em>2014-03-15 17:28:49</em></span></div>
</div>
<div class="clearfix"></div>


  </div>
  </footer>
  
        <script src="http://cdn.bootcss.com/jquery/1.10.2/jquery.min.js"></script>        
        <script src="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/js/bootstrap.min.js"></script>        
                
        <script src="http://cdn.bootcss.com/prettify/r298/prettify.min.js"></script>    <script type="text/javascript">
   var lang=["bsh", "c", "cc", "cpp", "cs", "csh", "cyc", "cv", "htm", "html",
    "java", "js", "m", "mxml", "perl", "pl", "pm", "py", "rb", "sh",
    "xhtml", "xml", "xsl"];
   var pretty_base='';
   $('script').each(function(){
	var c = $(this).attr('src');
	if (!c)
	    return;
	if (c.match(/(\/)?prettify(\.min)?\.js/i))
	{
	    var index = c.lastIndexOf('/');
	    if (index != -1)
		pretty_base = c.substr(0,index + 1);
	    return false;
	}
   })
   $('pre code').each(function(){
	var c = $(this).attr('class')
	if (!c)
	    return;
	c = c.match(/\s?(lang\-\w+)/i);
	if (c && lang.indexOf(c[1]) == -1)
	{
	    lang.push(c[1]);
	    $.getScript(pretty_base + c[1] + '.min.js');
	}
   })

    $(window).load(function(){
       $("pre").addClass("prettyprint");
       prettyPrint();
    })
</script>    
            <script type="text/javascript">
var duoshuoQuery = {short_name:"robinchia"};
_js2load.push({src:'http://static.duoshuo.com/embed.js',charset:'UTF-8'});
</script>
    
            <!--wumii_relatedItems-->
    
        <script src="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js"></script>    <script type="text/javascript">
(function($){
  $('.entry').each(function(i){
    $(this).find('img').each(function(){
      var alt = this.alt;

      if (alt){
        $(this).before('<span class="caption">' + alt + '</span>');
      }

      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox" rel="fancybox' + i + '" />');
    });
  });

  $('.fancybox').fancybox();
})(jQuery);
</script>    
        <script src="http://cdn.bootcss.com/mathjax/2.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>    <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>
    
<script type="text/javascript">
$('.ajax_widgets').each(function(){var src=$(this).attr('data-src');if(src)$(this).load('/widgets/'+src+'.html');});
$.each(_js2load,function(index,obj){loadjs(obj.src,obj.charset)});
</script>

<div id="scroll2top">
<img src="/scroll2top/arrow.png"/>
</div>
<script src="/scroll2top/scroll2top.min.js"></script>
<div id="winterland">
  <canvas></canvas>
</div>
<script src="/js/winterland.min.js"></script>

  </body>
</html>
