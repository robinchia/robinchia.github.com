
<!DOCTYPE HTML>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>The 53 Page | It so life</title>
<meta name="author" content="RobinChia">

<meta name="description" content="It so life">


<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<meta property="og:site_name" content="It so life"/>

<!--[if IE]><style>.testIE.IE{display:inline;}</style><![endif]-->
<!--[if lte IE 7]><link rel="stylesheet" href="/css/ie7.css" type="text/css"><![endif]-->
<!--[if (lt IE 9)&(gt IE 7)]><style>.testIE.IE8{display:inline;}</style><![endif]-->
<!--[if gt IE 8]><style>.testIE.IE9{display:inline;}</style><![endif]-->

<link href="/favicon.png" rel="icon">
<link rel="alternate" href="/atom.xml" title="It so life Feed" type="application/atom+xml">

<link rel="stylesheet" href="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/css/bootstrap.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/font-awesome/4.0.3/css/font-awesome.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/prettify/r298/prettify.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" type="text/css">
<link rel="stylesheet" href="/css/style.css" type="text/css">
<!--[if lt IE 9]>
   <style>article,aside,dialog,footer,header,section,footer,nav,figure,menu{display:block}</style>
   <script src="http://cdn.staticfile.org/html5shiv/r29/html5.min.js"></script>
   <script src="http://cdn.staticfile.org/respond.js/1.4.2/respond.min.js"></script>
<link href="http://cdn.staticfile.org/respond.js/1.4.2/respond-proxy.html" id="respond-proxy" rel="respond-proxy" />
<link href="/js/respond.proxy.gif" id="respond-redirect" rel="respond-redirect" />
<script src="/js/respond.proxy.js"></script>
   <script src="http://cdn.bootcss.com/selectivizr/1.0.2/selectivizr-min.js"></script>
<![endif]-->
<script type="text/javascript">
function loadjs(c,d){var a=document.createElement("script");a.async=!0;a.type="text/javascript";a.src=c;a.charset=d||"gbk";(document.getElementsByTagName("HEAD")[0]||document.getElementsByTagName("BODY")[0]).appendChild(a)};
var _protocol = (("https:" == document.location.protocol) ? " https://" : " http://");
var _js2load = [];
</script>

</head>
<body>
      <header id="header" class="container"><nav id="main-nav" class="navbar navbar-default navbar-fixed-top " role="navigation">
  <div class="container">
    <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
      <span class="sr-only">Toggle navigation</span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="/">It so life</a>
    </div>
    <div  class="collapse navbar-collapse">
      <ul  class="nav navbar-nav">
  
        <li><a href="/" title="Home">Home</a></li>      
        <li><a href="/about/" title="About">About</a></li>      
        <li><a href="/archives/" title="Archives">Archives</a></li>      
      <li class='dropdown'>
        <a class='dropdown-toggle' data-toggle='dropdown' href='#'>website<b class='caret'></b></a>
        <ul class='dropdown-menu pure-menu-selected'>
    
          <li><a href="//groups.google.com/forum/#!forum/pongba" title="TopLanguage">TopLanguage</a></li>    
          <li><a href="//itpub.net/" title="ITPub">ITPub</a></li>    
          <li><a href="//blog.jobbole.com/" title="Bole">Bole</a></li>    
          <li><a href="//nosql-database.org/" title="nosql">nosql</a></li>    
          <li><a href="//gitimmersion.googol.im/" title="Git">Git</a></li>    
        </ul>
      </li>
    
      </ul>
      <ul class="nav navbar-nav navbar-right">
      
        <li><a href="/atom.xml">RSS</a></li>
      
      
        <li><a href="https://twitter.com/robinchia">twitter</a></li>
      
      
      
      
        <li><a href="https://github.com/robinchia">github</a></li>
      
      </ul>
    </div>
  </div>
</nav>
<div class="clearfix"></div>
</header>
  <div id='content' class="container">
     <div class="page-header-wrapper">
      <!--[if lt IE 9]><div class="alert alert-warning alert-dismissable"><button type="button" class="close" data-dismiss="alert" aria-hidden="true">&times;</button><strong>提示:</strong>您的浏览器版本太低了,建议升级到 <strong><a href="http://windows.microsoft.com/zh-cn/internet-explorer/download-ie" title="IE9">IE9</a></strong> 以上,本站使用<a href="https://www.google.com/intl/zh-CN/chrome/">Chrome浏览器</a>可以获得最好的显示效果.</div><![endif]-->
      <div class="page-header"><h1 align="center"><big>It so life</big> </h1>
        <h5 align="center"><big>love as life</big></h5>
      </div>
     </div>
     <div class="row">
       <div id="main-col" class="alignleft col-sx-12 col-sm-8 col-md-9 col-lg-9">
      <section id='header_widget'></section>
          <div id="wrapper"><article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--Java垃圾回收策略调优-实践篇/">Java 垃圾回收策略调优</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:42.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--Java垃圾回收策略调优-实践篇/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="java-">Java 垃圾回收策略调优-实践篇</h1>
<p><a href="http://www.douban.com/accounts/login?source=group" target="_blank">登录</a> <a href="http://www.douban.com/accounts/register?source=group" target="_blank">注册</a></p>
<ul>
<li><a href="http://www.douban.com/" target="_blank">豆瓣</a></li>
<li><a href="http://book.douban.com/" target="_blank">读书</a></li>
<li><a href="http://movie.douban.com/" target="_blank">电影</a></li>
<li><a href="http://music.douban.com/" target="_blank">音乐</a></li>
<li><a href="http://www.douban.com/location/" target="_blank">同城</a></li>
<li><a href="http://www.douban.com/group/" target="_blank">小组</a></li>
<li><a href="http://read.douban.com/?dcs=top-nav&amp;dcm=douban" target="_blank">阅读</a></li>
<li><a href="http://douban.fm/" target="_blank">豆瓣FM</a></li>
<li><a href="">更多</a></li>
</ul>
<p><a href="http://9.douban.com/" target="_blank">九点</a> <a href="http://alphatown.com/" target="_blank">阿尔法城</a> <a href="http://www.douban.com/mobile/" target="_blank">移动应用</a></p>
<p><a href="http://www.douban.com/group/" target="_blank">豆瓣小组</a></p>
<ul>
<li><a href="http://www.douban.com/group/explore" target="_blank">发现小组</a></li>
<li><a href="http://www.douban.com/group/explore_topic" target="_blank">发现话题</a>
搜索：  小组、话题<h1 id="java-">Java 垃圾回收策略调优，实践篇</h1>
</li>
</ul>
<p><a href="http://www.douban.com/people/1851090/" target="_blank"><img src="" alt="KK"></a></p>
<h3 id="-kk-http-www-douban-com-people-1851090-2008-10-22-13-26-30">来自: <a href="http://www.douban.com/people/1851090/" target="_blank">KK</a> 2008-10-22 13:26:30</h3>
<p>JVM参数调优是一个很头痛的问题，可能和应用有关系，下面是本人一些调优的实践经验，希望对读者能有帮助，环境LinuxAS4,resin2.1.17,JDK6.0,2CPU,4G内存,dell2950服务器，网站是shedewang.com，新手可能觉得这文章没有用。
一：串行垃圾回收，也就是默认配置，完成10万request用时153秒，JVM参数配置如下
$JAVA_ARGS .= &quot; -Dresin.home=$SERVER_ROOT -server -Xms2048M -Xmx2048M -Xmn512M -XX:PermSize=256M -XX:MaxPermSize=256M -XX:MaxTenuringThreshold=7 -XX:GCTimeRatio=19 -Xnoclassgc -Xloggc:log/gc.log -XX:+PrintGCDetails -XX:+PrintGCTimeStamps &quot;;
这种配置一般在resin启动24小时内似乎没有大问题，网站可以正常访问，但查看日志发现，在接近24小时时，Full GC执行越来越频繁，大约每隔3分钟就有一次Full GC，每次Full GC系统会停顿6秒左右，作为一个网站来说，用户等待6秒恐怕太长了，所以这种方式有待改善。MaxTenuringThreshold=7表示一个对象如果在救助空间移动7次还没有被回收就放入年老代，GCTimeRatio=19表示java可以用5%的时间来做垃圾回收，1/(1+19)=1 /20=5%。
二：并行回收，完成10万request用时117秒，配置如下：
$JAVA_ARGS .= &quot; -Dresin.home=$SERVER_ROOT -server -Xmx2048M -Xms2048M -Xmn512M -XX:PermSize=256M -XX:MaxPermSize=256M -Xnoclassgc -Xloggc:log/gc.log -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+UseParallelGC -XX:ParallelGCThreads=20 -XX:+UseParallelOldGC -XX:MaxGCPauseMillis=500 -XX:+UseAdaptiveSizePolicy -XX:MaxTenuringThreshold=7 -XX:GCTimeRatio=19 &quot;;
并行回收我尝试过多种组合配置，似乎都没什么用，resin启动3小时左右就会停顿，时间超过10 秒。也有可能是参数设置不够好的原因，MaxGCPauseMillis表示GC最大停顿时间，在resin刚启动还没有执行Full GC时系统是正常的，但一旦执行Full GC，MaxGCPauseMillis根本没有用，停顿时间可能超过20秒，之后会发生什么我也不再关心了，赶紧重启resin，尝试其他回收策略。
三：并发回收，完成10万request用时60秒，比并行回收差不多快一倍，是默认回收策略性能的2.5倍，配置如下：
$JAVA_ARGS .= &quot; -Dresin.home=$SERVER_ROOT -server -Xms2048M -Xmx2048M -Xmn512M -XX:PermSize=256M -XX:MaxPermSize=256M -XX:+UseConcMarkSweepGC -XX:MaxTenuringThreshold=7 -XX:GCTimeRatio=19 -Xnoclassgc -Xloggc:log/gc.log -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+UseCMSCompactAtFullCollection -XX:CMSFullGCsBeforeCompaction=0 &quot;;
这个配置虽然不会出现10秒连不上的情况，但系统重启3个小时左右，每隔几分钟就会有5秒连不上的情况，查看gc.log，发现在执行ParNewGC时有个promotion failed错误，从而转向执行Full GC，造成系统停顿，而且会很频繁，每隔几分钟就有一次，所以还得改善。UseCMSCompactAtFullCollection是表是执行Full GC后对内存进行整理压缩，免得产生内存碎片，CMSFullGCsBeforeCompaction=N表示执行N次Full GC后执行内存压缩。
四：增量回收，完成10万request用时171秒，太慢了，配置如下
$JAVA_ARGS .= &quot; -Dresin.home=$SERVER_ROOT -server -Xms2048M -Xmx2048M -Xmn512M -XX:PermSize=256M -XX:MaxPermSize=256M -XX:MaxTenuringThreshold=7 -XX:GCTimeRatio=19 -Xnoclassgc -Xloggc:log/gc.log -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -Xincgc &quot;;
似乎回收得也不太干净，而且也对性能有较大影响，不值得试。
五：并发回收的I-CMS模式，和增量回收差不多，完成10万request用时170秒。
$JAVA_ARGS .= &quot; -Dresin.home=$SERVER_ROOT -server -Xms2048M -Xmx2048M -Xmn512M -XX:PermSize=256M -XX:MaxPermSize=256M -XX:MaxTenuringThreshold=7 -XX:GCTimeRatio=19 -Xnoclassgc -Xloggc:log/gc.log -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+UseConcMarkSweepGC -XX:+CMSIncrementalMode -XX:+CMSIncrementalPacing -XX:CMSIncrementalDutyCycleMin=0 -XX:CMSIncrementalDutyCycle=10 -XX:-TraceClassUnloading &quot;;
采用了sun推荐的参数，回收效果不好，照样有停顿，数小时之内就会频繁出现停顿，什么sun推荐的参数，照样不好使。
六：递增式低暂停收集器，还叫什么火车式回收，不知道属于哪个系，完成10万request用时153秒
$JAVA_ARGS .= &quot; -Dresin.home=$SERVER_ROOT -server -Xms2048M -Xmx2048M -Xmn512M -XX:PermSize=256M -XX:MaxPermSize=256M -XX:MaxTenuringThreshold=7 -XX:GCTimeRatio=19 -Xnoclassgc -Xloggc:log/gc.log -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+UseTrainGC &quot;;
该配置效果也不好，影响性能，所以没试。
七：相比之下，还是并发回收比较好，性能比较高，只要能解决ParNewGC（并行回收年轻代）时的promotion failed错误就一切好办了，查了很多文章，发现引起promotion failed错误的原因是CMS来不及回收（CMS默认在年老代占到90%左右才会执行），年老代又没有足够的空间供GC把一些活的对象从年轻代移到年老代，所以执行Full GC。CMSInitiatingOccupancyFraction=70表示年老代占到约70%时就开始执行CMS，这样就不会出现Full GC了。SoftRefLRUPolicyMSPerMB这个参数也是我认为比较有用的，官方解释是softly reachable objects will remain alive for some amount of time after the last time they were referenced. The default value is one second of lifetime per free megabyte in the heap，我觉得没必要等1秒，所以设置成0。配置如下
$JAVA_ARGS .= &quot; -Dresin.home=$SERVER_ROOT -server -Xms2048M -Xmx2048M -Xmn512M -XX:PermSize=256M -XX:MaxPermSize=256M -XX:SurvivorRatio=8 -XX:MaxTenuringThreshold=7 -XX:GCTimeRatio=19 -Xnoclassgc -XX:+DisableExplicitGC -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:+CMSPermGenSweepingEnabled -XX:+UseCMSCompactAtFullCollection -XX:CMSFullGCsBeforeCompaction=0 -XX:+CMSClassUnloadingEnabled -XX:-CMSParallelRemarkEnabled -XX:CMSInitiatingOccupancyFraction=70 -XX:SoftRefLRUPolicyMSPerMB=0 -XX:+PrintClassHistogram -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintGCApplicationConcurrentTime -XX:+PrintGCApplicationStoppedTime -Xloggc:log/gc.log &quot;;
上面这个配置内存上升的很慢，24小时之内几乎没有停顿现象，最长的只停滞了0.8s，ParNew GC每30秒左右才执行一次，每次回收约0.2秒，看来问题应该暂时解决了。
参数不明白的可以上网查，本人认为比较重要的几个参数是：-Xms -Xmx -Xmn MaxTenuringThreshold GCTimeRatio UseConcMarkSweepGC CMSInitiatingOccupancyFraction SoftRefLRUPolicyMSPerMB
<a href="http://www.douban.com/group/topic/4450520/?type=like#sep" target="_blank">7人</a> 喜欢  <a href="http://www.douban.com/accounts/register?reason=like" title="标为喜欢？" target="_blank">喜欢</a></p>
<p><a href="">回应</a> <a href="http://www.douban.com/group/topic/4450520/?type=rec#sep" target="_blank">推荐</a> <a href="http://www.douban.com/group/topic/4450520/?type=like#sep" target="_blank">喜欢</a>  <a href="http://www.douban.com/group/topic/4450520/?author=1#sep" target="_blank">只看楼主</a></p>
<ul>
<li><a href="http://www.douban.com/people/xds2000/" target="_blank"><img src="" alt="肖"></a></li>
</ul>
<h3 id="-http-www-douban-com-people-xds2000-beijing-2008-10-22-22-53-34"><a href="http://www.douban.com/people/xds2000/" target="_blank">肖</a> (@Beijing) 2008-10-22 22:53:34</h3>
<p>首先使用64 bit os,是一个提高性能的不二法规.
第二,任何调优应该有场景,在未知情况应该使用loggc导出日志分析,再加参数.对于参数的好与坏,我希望楼主能贴出更多的自已的思路</p>
<p><a href="http://www.douban.com/group/topic/4450520/?cid=36481624#last" target="_blank">回应</a> <a href="&quot;真的要删除肖的发言?&quot;">删除</a></p>
<ul>
<li><a href="http://www.douban.com/people/1851090/" target="_blank"><img src="" alt="KK"></a></li>
</ul>
<h3 id="-kk-http-www-douban-com-people-1851090-2008-10-27-15-32-12"><a href="http://www.douban.com/people/1851090/" target="_blank">KK</a> 2008-10-27 15:32:12</h3>
<p>还有，如果遇到内存泄漏，要用jstack和jmap、jstat等多看看，应该可以找到问题，还要多看看gc日志各个区域内存使用情况和gc频率，这样才可以作出最佳配置。Good Luck</p>
<p><a href="http://www.douban.com/group/topic/4450520/?cid=36890822#last" target="_blank">回应</a> <a href="&quot;真的要删除KK的发言?&quot;">删除</a></p>
<ul>
<li><a href="http://www.douban.com/people/1851090/" target="_blank"><img src="" alt="KK"></a></li>
</ul>
<h3 id="-kk-http-www-douban-com-people-1851090-2008-11-03-17-37-21"><a href="http://www.douban.com/people/1851090/" target="_blank">KK</a> 2008-11-03 17:37:21</h3>
<p>内存问题和应用有很大关系，我的应用因为用到了缓存，所以年老代比较大，多看看gc日志，出了问题多用Jstack,jmap等工具查看，这样才可以最大的优化JVM参数。经过进两个星期的调试，我的配置是/usr/local/jdk/bin/java -Dresin.home=/usr/local/resin -server -Xms1800M -Xmx1800M -Xmn300M -Xss512K -XX:PermSize=300M -XX:MaxPermSize=300M -XX:SurvivorRatio=8 -XX:MaxTenuringThreshold=5 -XX:GCTimeRatio=19 -Xnoclassgc -XX:+DisableExplicitGC -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:+UseCMSCompactAtFullCollection -XX:CMSFullGCsBeforeCompaction=0 -XX:-CMSParallelRemarkEnabled -XX:CMSInitiatingOccupancyFraction=70 -XX:SoftRefLRUPolicyMSPerMB=0 -XX:+PrintClassHistogram -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintHeapAtGC -Xloggc:log/gc.log
72小时之内没有一点停顿，我是32位LinuxAS4操作系统。</p>
<p><a href="http://www.douban.com/group/topic/4450520/?cid=37459097#last" target="_blank">回应</a> <a href="&quot;真的要删除KK的发言?&quot;">删除</a></p>
<ul>
<li><a href="http://www.douban.com/people/foxswily/" target="_blank"><img src="" alt="Foxswily"></a></li>
</ul>
<h3 id="-foxswily-http-www-douban-com-people-foxswily-2008-11-03-17-45-09"><a href="http://www.douban.com/people/foxswily/" target="_blank">Foxswily</a> 2008-11-03 17:45:09</h3>
<p>mark先，前一段做一个对性能要求高的项目，典型的高DB负载，把着眼点都放在了DB优化上(最终效果也不错，大概提高了40倍左右的性能)，一直没有考虑jvm优化，疏忽了。
but，jvm的优化性价比貌似不是很高，化很大力气得到回报如何有待实践检验。</p>
<p><a href="http://www.douban.com/group/topic/4450520/?cid=37459727#last" target="_blank">回应</a> <a href="&quot;真的要删除Foxswily的发言?&quot;">删除</a></p>
<ul>
<li><a href="http://www.douban.com/people/1851090/" target="_blank"><img src="" alt="KK"></a></li>
</ul>
<h3 id="-kk-http-www-douban-com-people-1851090-2008-11-03-17-55-02"><a href="http://www.douban.com/people/1851090/" target="_blank">KK</a> 2008-11-03 17:55:02</h3>
<p>不是纯粹性能问题，到一定时候JVM参数必须优化，不然访问量大的时候会造成频繁的Full GC或者CMS，Full GC有时能让整个系统停顿10秒，10秒内用户的任何点击都在等待状态，要是隔2分钟就来一次Full GC，恐怕用户和老板都受不了了。
并发回收如果配置的不好照样会产生Full GC。:)</p>
<p><a href="http://www.douban.com/group/topic/4450520/?cid=37460534#last" target="_blank">回应</a> <a href="&quot;真的要删除KK的发言?&quot;">删除</a></p>
<ul>
<li><a href="http://www.douban.com/people/foxswily/" target="_blank"><img src="" alt="Foxswily"></a></li>
</ul>
<h3 id="-foxswily-http-www-douban-com-people-foxswily-2008-11-03-17-58-43"><a href="http://www.douban.com/people/foxswily/" target="_blank">Foxswily</a> 2008-11-03 17:58:43</h3>
<p>有道理，支持这种有内容、有见地的讨论贴。</p>
<p><a href="http://www.douban.com/group/topic/4450520/?cid=37460849#last" target="_blank">回应</a> <a href="&quot;真的要删除Foxswily的发言?&quot;">删除</a></p>
<ul>
<li><a href="http://www.douban.com/people/lozen/" target="_blank"><img src="" alt="洛臻星轮"></a></li>
</ul>
<h3 id="-http-www-douban-com-people-lozen-2012-05-22-23-22-11"><a href="http://www.douban.com/people/lozen/" target="_blank">洛臻星轮</a> 2012-05-22 23:22:11</h3>
<p>感谢下，用了里面的很多参数，目前好使了，让它再多跑跑
项目中Full GC一次停顿了个快十秒，一停顿事件就积压，隔段时间又停顿，事件积压得越来越严重，程序就崩了...</p>
<p><a href="http://www.douban.com/group/topic/4450520/?cid=347193386#last" target="_blank">回应</a> <a href="&quot;真的要删除洛臻星轮的发言?&quot;">删除</a></p>
<ul>
<li><h3 id="-alzq-http-www-douban-com-people-55956054-2012-07-20-13-00-19"><a href="http://www.douban.com/people/55956054/" target="_blank">alzq</a> 2012-07-20 13:00:19</h3>
</li>
</ul>
<p>好配置，实验中……效果不错～</p>
<p><a href="http://www.douban.com/group/topic/4450520/?cid=364769409#last" target="_blank">回应</a> <a href="&quot;真的要删除alzq的发言?&quot;">删除</a></p>
<h2 id="-">你的回应</h2>
<p>回应请先 <a href="http://www.douban.com/accounts/register?reason=discuss" target="_blank">登录</a> , 或 <a href="http://www.douban.com/accounts/register?reason=discuss" target="_blank">注册</a></p>
<p>推荐到广播</p>
<p><a href="http://www.douban.com/group/java/?ref=sidebar" target="_blank"><img src="" alt=""></a></p>
<p><a href="http://www.douban.com/group/java/?ref=sidebar" target="_blank">Java&amp;Android移动应用编程</a></p>
<p>9641 人聚集在这个小组
 <a href="">加入小组</a></p>
<h2 id="-http-www-douban-com-group-java-topics-">最新话题  ( <a href="http://www.douban.com/group/java/#topics" target="_blank">更多</a> )</h2>
<ul>
<li><a href="http://www.douban.com/group/topic/41487832/" title="[Java开发] Java怎么用POI读取Excel函数" target="_blank">[Java开发] Java怎么用POI读取Excel函数</a>   (若水520sunny)</li>
<li><a href="http://www.douban.com/group/topic/41485336/" title="帮5买-招聘ETL开发工程师" target="_blank">帮5买-招聘ETL开发工程师</a>   (挚爱Bernabeu)</li>
<li><a href="http://www.douban.com/group/topic/41482883/" title="搜狗-招聘Java软件工程师" target="_blank">搜狗-招聘Java软件工程师</a>   (挚爱Bernabeu)</li>
<li><a href="http://www.douban.com/group/topic/41472005/" title="谁能稍稍帮我分析下Logcat，给个提示，感激不尽！" target="_blank">谁能稍稍帮我分析下Logcat，给个提示，感激不尽！</a>   (shanby)</li>
<li><p><a href="http://www.douban.com/group/topic/41466302/" title="推荐一个很好的android&amp;ios学习网站" target="_blank">推荐一个很好的android&amp;ios学习网站</a>   (　)</p>
<h2 id="-">全站热点话题:</h2>
</li>
<li><p><a href="http://www.douban.com/group/topic/41486032/?r=1" title="【搬运中】别小看吃货的智慧 818某些外面卖的看起来挺贵的甜品饮料 很多可以自己在家做" target="_blank">【搬运中】别小看吃货的智慧 818某些外面...</a>   37回应</p>
</li>
<li><a href="http://www.douban.com/group/topic/41483943/?r=1" title="【推荐】夏日彩妆routine" target="_blank">【推荐】夏日彩妆routine</a>   55回应</li>
<li><a href="http://www.douban.com/group/topic/41414533/?r=1" title="有关毕业报到证，公务员，事业单位考试面试神马的都可以问我" target="_blank">有关毕业报到证，公务员，事业单位考试面...</a>   197回应</li>
<li><a href="http://www.douban.com/group/topic/41448032/?r=1" title="【意向】Mitsui.家的男装" target="_blank">【意向】Mitsui.家的男装</a>   45回应</li>
<li><a href="http://www.douban.com/group/topic/41321572/?r=1" title="【异国】分享一点关于西方世界的看法" target="_blank">【异国】分享一点关于西方世界的看法</a>   184回应</li>
<li><a href="http://www.douban.com/group/topic/41462291/?r=1" title="【住在我房子里的美女到底是个什么东西？？？!!!】" target="_blank">【住在我房子里的美女到底是个什么东西？...</a>   63回应</li>
<li><a href="http://www.douban.com/group/topic/41358235/?r=1" title="关于天蝎男喜欢女生类型的讨论" target="_blank">关于天蝎男喜欢女生类型的讨论</a>   283回应</li>
<li><a href="http://www.douban.com/group/topic/41460023/?r=1" title="求扒苏见信！！！196的黑料有木有？" target="_blank">求扒苏见信！！！196的黑料有木有？</a>   285回应</li>
</ul>
<h3 id="-">手机扫描二维码，让小组随时陪伴你</h3>
<p><img src="" alt=""></p>
<p><a href="http://www.douban.com/mobile/ipa?app_name=group" target="_blank">App Store下载</a> <a href="http://www.douban.com/j/app/apk?app_name=group_android" target="_blank">点击直接下载</a></p>
<p>© 2005－2013 douban.com, all rights reserved   <a href="http://www.douban.com/about" target="_blank">关于豆瓣</a> · <a href="http://www.douban.com/jobs" target="_blank">在豆瓣工作</a> · <a href="http://www.douban.com/about?topic=contactus" target="_blank">联系我们</a> · <a href="http://www.douban.com/about?policy=disclaimer" target="_blank">免责声明</a> · <a href="http://www.douban.com/help/group" target="_blank">帮助中心</a> · <a href="http://developers.douban.com/" target="_blank">开发者</a> · <a href="http://www.douban.com/mobile/group" target="_blank">手机小组</a> · <a href="http://www.douban.com/partner/" target="_blank">豆瓣广告</a></p>
<p><a href="">↑回顶部</a>
<a href="">×</a></p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/JVM/">JVM</a></li></span></span> | <span class="tags">Tagged <a href="/tags/JVM/" class="label label-primary">JVM</a><a href="/tags/Java&J2EE/" class="label label-success">Java&J2EE</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:42"datetime="2014-03-07 09:54:42"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-JVM--Java垃圾回收策略调优-实践篇/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-JVM--Java垃圾回收策略调优-实践篇" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--JVM调优的-标准参数-的各种陷阱/">JVM调优的</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:42.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--JVM调优的-标准参数-的各种陷阱/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="jvm-">JVM调优的&quot;标准参数&quot;的各种陷阱</h1>
<p><a href="http://hllvm.group.iteye.com/login" title="登录" target="_blank">您还未登录 !</a> <a href="http://hllvm.group.iteye.com/login" target="_blank">登录</a> <a href="http://hllvm.group.iteye.com/signup" target="_blank">注册</a></p>
<p><a href="http://www.iteye.com/" target="_blank"><img src="&quot;ITeye-最棒的软件开发交流社区&quot;" alt="ITeye3.0"></a></p>
<p><a href="http://www.iteye.com/groups" target="_blank">群组首页</a> → <a href="http://hllvm.group.iteye.com/groups/category/language" target="_blank">编程语言</a> → <a href="http://hllvm.group.iteye.com/" target="_blank">高级语言虚拟机</a> → <a href="http://hllvm.group.iteye.com/group/forum" target="_blank">论坛</a></p>
<p><img src="" alt=""> <a href="http://hllvm.group.iteye.com/group/topic/27945/post/new" target="_blank">发表回复</a></p>
<p>« 上一页 1 <a href="http://hllvm.group.iteye.com/group/topic/27945?page=2" target="_blank">2</a> <a href="http://hllvm.group.iteye.com/group/topic/27945?page=3" target="_blank">3</a> <a href="http://hllvm.group.iteye.com/group/topic/27945?page=2" target="_blank">下一页 »</a></p>
<h3 id="-http-hllvm-group-iteye-com-group-forum-tag_id-690-jvm-"><a href="http://hllvm.group.iteye.com/group/forum?tag_id=690" target="_blank">[讨论]</a> <a href="">JVM调优的&quot;标准参数&quot;的各种陷阱</a></h3>
<p><a href="http://rednaxelafx.iteye.com/" target="_blank"><img src="&quot;RednaxelaFX的博客: Script Ahead, Code Behind&quot;" alt="RednaxelaFX的博客"></a> <a href="http://rednaxelafx.iteye.com/" title="RednaxelaFX" target="_blank">RednaxelaFX</a> 2011-10-23</p>
<p>开个帖大家来讨论下自己遇到过的情况吧？我在顶楼举几个例子。
开这帖的目的是想让大家了解到，所谓“标准参数”是件很微妙的事情。确实有许多前辈经过多年开发积累下了许多有用的调优经验，但向他们问“标准参数”并照单全收是件危险的事情。
前辈们提供的“标准参数”或许适用于他们的应用场景，他们或许也知道这些参数里隐含的陷阱；但听众却不一定知道各种参数背后的缘由。
原则上说，在生产环境使用非标准参数（这里指的是在各JDK/JRE实现特有的、相互之间不通用的参数）应该尽量避免。这些参数与具体实现密切相关，不是光了解很抽象的“JVM原理”就足以理解的；即便在同一系列的JDK/JRE实现中，非标准参数也不保证在各版本间有一样的作用；而且许多人只看名字就猜想参数的左右，做“调优”却适得其反。
非标准参数的默认值在不同版本间或许会悄然发生变化。这些变化的背后多半有合理的理由。设了一大堆非标准参数、不明就里的同学在升级JDK/JRE的时候也容易掉坑里。
下面用<strong>Oracle/Sun JDK 6</strong>来举几个例子。这帖顶楼里的讨论如果没明确指出JDK版本的都是指Oracle/Sun JDK 6（OpenJDK 6也可以算在内）。</p>
<h1 id="-sun-jdk-1-4-2-sun-jdk-5-oracle-jdk-7-">经验不一定适用于Sun JDK 1.4.2、Sun JDK 5、Oracle JDK 7。</h1>
<p>0、各参数的默认值
在讨论HotSpot VM的各参数的陷阱前，大家应该先了解HotSpot VM到底有哪些参数可以设置，这些参数的默认值都是什么。
有几种办法可以帮助大家获取参数的信息。首先为了大致了解都有些什么参数可以设置，可以参考HotSpot VM里的各个globals.hpp文件：（以下链接取自HotSpot 20.0，与JDK 6 update 25对应）
<a href="http://hg.openjdk.java.net/hsx/hsx20/master/file/f0f676c5a2c6/src/share/vm/runtime/globals.hpp" target="_blank">globals.hpp</a>
<a href="http://hg.openjdk.java.net/hsx/hsx20/master/file/f0f676c5a2c6/src/share/vm/runtime/globals_extension.hpp" target="_blank">globals_extension.hpp</a>
<a href="http://hg.openjdk.java.net/hsx/hsx20/master/file/f0f676c5a2c6/src/share/vm/c1/c1_globals.hpp" target="_blank">c1_globals.hpp</a>
<a href="http://hg.openjdk.java.net/hsx/hsx20/master/file/f0f676c5a2c6/src/os/linux/vm/c1_globals_linux.hpp" target="_blank">c1_globals_linux.hpp</a>
<a href="http://hg.openjdk.java.net/hsx/hsx20/master/file/f0f676c5a2c6/src/os/solaris/vm/c1_globals_solaris.hpp" target="_blank">c1_globals_solaris.hpp</a>
<a href="http://hg.openjdk.java.net/hsx/hsx20/master/file/f0f676c5a2c6/src/cpu/sparc/vm/c1_globals_sparc.hpp" target="_blank">c1_globals_sparc.hpp</a>
<a href="http://hg.openjdk.java.net/hsx/hsx20/master/file/f0f676c5a2c6/src/os/windows/vm/c1_globals_windows.hpp" target="_blank">c1_globals_windows.hpp</a>
<a href="http://hg.openjdk.java.net/hsx/hsx20/master/file/f0f676c5a2c6/src/cpu/x86/vm/c1_globals_x86.hpp" target="_blank">c1_globals_x86.hpp</a>
<a href="http://hg.openjdk.java.net/hsx/hsx20/master/file/f0f676c5a2c6/src/share/vm/opto/c2_globals.hpp" target="_blank">c2_globals.hpp</a>
<a href="http://hg.openjdk.java.net/hsx/hsx20/master/file/f0f676c5a2c6/src/os/linux/vm/c2_globals_linux.hpp" target="_blank">c2_globals_linux.hpp</a>
<a href="http://hg.openjdk.java.net/hsx/hsx20/master/file/f0f676c5a2c6/src/os/solaris/vm/c2_globals_solaris.hpp" target="_blank">c2_globals_solaris.hpp</a>
<a href="http://hg.openjdk.java.net/hsx/hsx20/master/file/f0f676c5a2c6/src/cpu/sparc/vm/c2_globals_sparc.hpp" target="_blank">c2_globals_sparc.hpp</a>
<a href="http://hg.openjdk.java.net/hsx/hsx20/master/file/f0f676c5a2c6/src/os/windows/vm/c2_globals_windows.hpp" target="_blank">c2_globals_windows.hpp</a>
<a href="http://hg.openjdk.java.net/hsx/hsx20/master/file/f0f676c5a2c6/src/cpu/x86/vm/c2_globals_x86.hpp" target="_blank">c2_globals_x86.hpp</a>
<a href="http://hg.openjdk.java.net/hsx/hsx20/master/file/f0f676c5a2c6/src/share/vm/gc_implementation/g1/g1_globals.hpp" target="_blank">g1_globals.hpp</a>
<a href="http://hg.openjdk.java.net/hsx/hsx20/master/file/f0f676c5a2c6/src/os/linux/vm/globals_linux.hpp" target="_blank">globals_linux.hpp</a>
<a href="http://hg.openjdk.java.net/hsx/hsx20/master/file/f0f676c5a2c6/src/os_cpu/linux_sparc/vm/globals_linux_sparc.hpp" target="_blank">globals_linux_sparc.hpp</a>
<a href="http://hg.openjdk.java.net/hsx/hsx20/master/file/f0f676c5a2c6/src/os_cpu/linux_x86/vm/globals_linux_x86.hpp" target="_blank">globals_linux_x86.hpp</a>
<a href="http://hg.openjdk.java.net/hsx/hsx20/master/file/f0f676c5a2c6/src/os_cpu/linux_zero/vm/globals_linux_zero.hpp" target="_blank">globals_linux_zero.hpp</a>
<a href="http://hg.openjdk.java.net/hsx/hsx20/master/file/f0f676c5a2c6/src/os/solaris/vm/globals_solaris.hpp" target="_blank">globals_solaris.hpp</a>
<a href="http://hg.openjdk.java.net/hsx/hsx20/master/file/f0f676c5a2c6/src/os_cpu/solaris_sparc/vm/globals_solaris_sparc.hpp" target="_blank">globals_solaris_sparc.hpp</a>
<a href="http://hg.openjdk.java.net/hsx/hsx20/master/file/f0f676c5a2c6/src/os_cpu/solaris_x86/vm/globals_solaris_x86.hpp" target="_blank">globals_solaris_x86.hpp</a>
<a href="http://hg.openjdk.java.net/hsx/hsx20/master/file/f0f676c5a2c6/src/cpu/sparc/vm/globals_sparc.hpp" target="_blank">globals_sparc.hpp</a>
<a href="http://hg.openjdk.java.net/hsx/hsx20/master/file/f0f676c5a2c6/src/os/windows/vm/globals_windows.hpp" target="_blank">globals_windows.hpp</a>
<a href="http://hg.openjdk.java.net/hsx/hsx20/master/file/f0f676c5a2c6/src/os_cpu/windows_x86/vm/globals_windows_x86.hpp" target="_blank">globals_windows_x86.hpp</a>
<a href="http://hg.openjdk.java.net/hsx/hsx20/master/file/f0f676c5a2c6/src/cpu/x86/vm/globals_x86.hpp" target="_blank">globals_x86.hpp</a>
<a href="http://hg.openjdk.java.net/hsx/hsx20/master/file/f0f676c5a2c6/src/cpu/zero/vm/globals_zero.hpp" target="_blank">globals_zero.hpp</a>
<a href="http://hg.openjdk.java.net/hsx/hsx20/master/file/f0f676c5a2c6/src/share/vm/shark/shark_globals.hpp" target="_blank">shark_globals.hpp</a>
<a href="http://hg.openjdk.java.net/hsx/hsx20/master/file/f0f676c5a2c6/src/cpu/zero/vm/shark_globals_zero.hpp" target="_blank">shark_globals_zero.hpp</a>
<a href="http://hg.openjdk.java.net/hsx/hsx20/master/file/f0f676c5a2c6/src/share/vm/runtime/arguments.cpp" target="_blank">arguments.cpp</a>
然后是 <strong>-XX:+PrintCommandLineFlags</strong> 。这个参数的作用是显示出VM初始化完毕后所有跟最初的默认值不同的参数及它们的值。
这个参数至少在Sun JDK 5上已经开始支持，Oracle/Sun JDK 6以及Oracle JDK 7上也可以使用。Sun JDK 1.4.2还不支持这个参数。
例子：
Command prompt代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>$ java -XX:+PrintCommandLineFlags  </li>
<li>VM option &#39;+PrintCommandLineFlags&#39;  </li>
<li><p>-XX:InitialHeapSize=57344000 -XX:MaxHeapSize=917504000 -XX:ParallelGCThreads=4 -XX:+PrintCommandLineFlags -XX:+UseCompressedOops -XX:+UseParallelGC<br>$ java -XX:+PrintCommandLineFlags VM option &#39;+PrintCommandLineFlags&#39; -XX:InitialHeapSize=57344000 -XX:MaxHeapSize=917504000 -XX:ParallelGCThreads=4 -XX:+PrintCommandLineFlags -XX:+UseCompressedOops -XX:+UseParallelGC
<a href="http://book.douban.com/annotation/15146892/" target="_blank">《Java Performance》一书</a>主要是用这个参数来介绍HotSpot VM各参数的效果的。
接着是 <strong>-XX:+PrintFlagsFinal</strong> 。前一个参数只显示跟默认值不同的，而这个参数则可以显示所有可设置的参数及它们的值。不过这个参数本身只从JDK 6 update 21开始才可以用，之前的Oracle/Sun JDK则用不了。
可以设置的参数默认是不包括diagnostic或experimental系的。要在-XX:+PrintFlagsFinal的输出里看到这两种参数的信息，分别需要显式指定<strong>-XX:+UnlockDiagnosticVMOptions</strong> / <strong>-XX:+UnlockExperimentalVMOptions</strong> 。
再下来，<strong>-XX:+PrintFlagsInitial</strong> 。这个参数显示在处理参数之前所有可设置的参数及它们的值，然后直接退出程序。“参数处理”包括许多步骤，例如说检查参数之间是否有冲突，通过ergonomics调整某些参数的值，之类的。
结合-XX:+PrintFlagsInitial与-XX:+PrintFlagsFinal，对比两者的差异，就可以知道ergonomics对哪些参数做了怎样的调整。
这两个参数的例子：
Command prompt代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>$ java -version  </p>
</li>
<li>java version &quot;1.6.0_29&quot;  </li>
<li>Java(TM) SE Runtime Environment (build 1.6.0_29-b11)  </li>
<li>Java HotSpot(TM) 64-Bit Server VM (build 20.4-b02, mixed mode)  </li>
<li>$ java -XX:+PrintFlagsInitial | grep UseCompressedOops  </li>
<li>bool UseCompressedOops                         = false           {lp64_product}        </li>
<li>$ java -XX:+PrintFlagsFinal | grep UseCompressedOops  </li>
<li><p>bool UseCompressedOops                        := true            {lp64_product}<br>$ java -version java version &quot;1.6.0_29&quot; Java(TM) SE Runtime Environment (build 1.6.0_29-b11) Java HotSpot(TM) 64-Bit Server VM (build 20.4-b02, mixed mode) $ java -XX:+PrintFlagsInitial | grep UseCompressedOops bool UseCompressedOops = false {lp64_product} $ java -XX:+PrintFlagsFinal | grep UseCompressedOops bool UseCompressedOops := true {lp64_product}
<a href="http://rednaxelafx.iteye.com/blog/1010079" target="_blank">Oracle/Sun JDK 6从update 23开始会由ergonomics在合适的条件下默认启用压缩指针功能</a>。这个例子演示的是UseCompressedOops的初始默认值是false，由PrintFlagsInitial的输出可以看到；然后经过ergonomics自动调整后，最终采用的默认值是true，由PrintFlagsFinal的输出可以看到。
输出里“=”表示使用的是初始默认值，而“:=”表示使用的不是初始默认值，可能是命令行传进来的参数、配置文件里的参数或者是ergonomics自动选择了别的值。
除了在VM启动时传些特殊的参数让它打印出自己的各参数外，<strong>jinfo -flag</strong> 可以用来查看某个参数的值，也可以用来设定manageable系参数的值。请参考这帖的例子：<a href="http://rednaxelafx.iteye.com/blog/1049240" target="_blank">通过jinfo工具在full GC前后做heap dump</a></p>
<h1 id="-hotspot-vm-http-rednaxelafx-iteye-com-blog-906807-">之前发过<a href="http://rednaxelafx.iteye.com/blog/906807" target="_blank">某些环境中HotSpot VM的各参数的默认值</a>，可以参考一下。</h1>
<p>1、-XX:+DisableExplicitGC 与 NIO的direct memory
很多人都见过JVM调优建议里使用这个参数，对吧？但是为什么要用它，什么时候应该用而什么时候用了会掉坑里呢？
首先要了解的是这个参数的作用。在Oracle/Sun JDK这个具体实现上，System.gc()的默认效果是引发一次stop-the-world的full GC，对整个GC堆做收集。有几个参数可以改变默认行为，之前<a href="http://rednaxelafx.iteye.com/blog/1042471" target="_blank">发过一帖简单描述</a>过，这里就不重复了。关键点是，用了-XX:+DisableExplicitGC参数后，System.gc()的调用就会变成一个空调用，完全不会触发任何GC（但是“函数调用”本身的开销还是存在的哦～）。
为啥要用这个参数呢？最主要的原因是为了防止某些手贱的同学在代码里到处写System.gc()的调用而干扰了程序的正常运行吧。有些应用程序本来可能正常跑一天也不会出一次full GC，但就是因为有人在代码里调用了System.gc()而不得不间歇性被暂停。也有些时候这些调用是在某些库或框架里写的，改不了它们的代码但又不想被这些调用干扰也会用这参数。
OK。看起来这参数应该总是开着嘛。有啥坑呢？
其中一种情况是下述三个条件同时满足时会发生的：
1、应用本身在GC堆内的对象行为良好，正常情况下很久都不发生full GC；
2、应用大量使用了NIO的direct memory，经常、反复的申请DirectByteBuffer
3、使用了-XX:+DisableExplicitGC
能观察到的现象是：
Log代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>java.lang.OutOfMemoryError: Direct buffer memory  </p>
</li>
<li>at java.nio.Bits.reserveMemory(Bits.java:633)  </li>
<li>at java.nio.DirectByteBuffer.<init>(DirectByteBuffer.java:98)  </li>
<li>at java.nio.ByteBuffer.allocateDirect(ByteBuffer.java:288)  </li>
<li><p>...<br>java.lang.OutOfMemoryError: Direct buffer memory at java.nio.Bits.reserveMemory(Bits.java:633) at java.nio.DirectByteBuffer.<init>(DirectByteBuffer.java:98) at java.nio.ByteBuffer.allocateDirect(ByteBuffer.java:288) ...
做个简单的例子来演示这现象：
Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>import java.nio./*;  </p>
</li>
<li></li>
<li>public class DisableExplicitGCDemo {  </li>
<li>public static void main(String[] args) {  </li>
<li>for (int i = 0; i &lt; 100000; i++) {  </li>
<li>ByteBuffer.allocateDirect(128);  </li>
<li>}  </li>
<li>System.out.println(&quot;Done&quot;);  </li>
<li>}  </li>
<li><p>}<br>import java.nio./*; public class DisableExplicitGCDemo { public static void main(String[] args) { for (int i = 0; i &lt; 100000; i++) { ByteBuffer.allocateDirect(128); } System.out.println(&quot;Done&quot;); } }
然后编译、运行之：
Command prompt代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>$ java -version  </p>
</li>
<li>java version &quot;1.6.0_25&quot;  </li>
<li>Java(TM) SE Runtime Environment (build 1.6.0_25-b06)  </li>
<li>Java HotSpot(TM) 64-Bit Server VM (build 20.0-b11, mixed mode)  </li>
<li>$ javac DisableExplicitGCDemo.java   </li>
<li>$ java -XX:MaxDirectMemorySize=10m -XX:+PrintGC -XX:+DisableExplicitGC DisableExplicitGCDemo  </li>
<li>Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Direct buffer memory  </li>
<li>at java.nio.Bits.reserveMemory(Bits.java:633)  </li>
<li>at java.nio.DirectByteBuffer.<init>(DirectByteBuffer.java:98)  </li>
<li>at java.nio.ByteBuffer.allocateDirect(ByteBuffer.java:288)  </li>
<li>at DisableExplicitGCDemo.main(DisableExplicitGCDemo.java:6)  </li>
<li>$ java -XX:MaxDirectMemorySize=10m -XX:+PrintGC DisableExplicitGCDemo  </li>
<li>[GC 10996K-&gt;10480K(120704K), 0.0433980 secs]  </li>
<li>[Full GC 10480K-&gt;10415K(120704K), 0.0359420 secs]  </li>
<li><p>Done<br>$ java -version java version &quot;1.6.0_25&quot; Java(TM) SE Runtime Environment (build 1.6.0_25-b06) Java HotSpot(TM) 64-Bit Server VM (build 20.0-b11, mixed mode) $ javac DisableExplicitGCDemo.java $ java -XX:MaxDirectMemorySize=10m -XX:+PrintGC -XX:+DisableExplicitGC DisableExplicitGCDemo Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Direct buffer memory at java.nio.Bits.reserveMemory(Bits.java:633) at java.nio.DirectByteBuffer.<init>(DirectByteBuffer.java:98) at java.nio.ByteBuffer.allocateDirect(ByteBuffer.java:288) at DisableExplicitGCDemo.main(DisableExplicitGCDemo.java:6) $ java -XX:MaxDirectMemorySize=10m -XX:+PrintGC DisableExplicitGCDemo [GC 10996K-&gt;10480K(120704K), 0.0433980 secs] [Full GC 10480K-&gt;10415K(120704K), 0.0359420 secs] Done
可以看到，同样的程序，不带-XX:+DisableExplicitGC时能正常完成运行，而带上这个参数后却出现了OOM。
例子里用-XX:MaxDirectMemorySize=10m限制了DirectByteBuffer能分配的空间的限额，以便问题更容易展现出来。不用这个参数就得多跑一会儿了。
在这个例子里，main()里的循环不断申请DirectByteBuffer但并没有引用、使用它们，所以这些DirectByteBuffer应该刚创建出来就已经满足被GC的条件，等下次GC运行的时候就应该可以被回收。
实际上却没这么简单。DirectByteBuffer是种典型的“冰山”对象，也就是说它的Java对象虽然很小很无辜，但它背后却会关联着一定量的native memory资源，而这些资源并不在GC的控制之下，需要自己注意控制好。对JVM如何使用native memory不熟悉的同学可以参考去年JavaOne上IBM的一个演讲，“Where Does All the Native Memory Go”。
Oracle/Sun JDK的实现里，DirectByteBuffer有几处值得注意的地方。
1、DirectByteBuffer没有finalizer，它的native memory的清理工作是通过sun.misc.Cleaner自动完成的。
2、sun.misc.Cleaner是一种基于PhantomReference的清理工具，比普通的finalizer轻量些。对PhantomReference不熟悉的同学请参考Bob Lee最近几年在JavaOne上做的演讲，<a href="http://www.parleys.com/d/2657" target="_blank">&quot;The Ghost in the Virtual Machine: A Reference to References&quot;</a>。<a href="https://oracleus.wingateweb.com/scheduler/eventcatalog/eventCatalogJavaOne.do" target="_blank">今年的JavaOne</a>上他也讲了同一个主题，内容比前几年的稍微更新了些。PPT可以从链接里的页面下载到。
Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>//<em>/</em> </p>
</li>
<li>/* General-purpose phantom-reference-based cleaners. </li>
<li>/* </li>
<li>/* <p> Cleaners are a lightweight and more robust alternative to finalization. </li>
<li>/* They are lightweight because they are not created by the VM and thus do not </li>
<li>/* require a JNI upcall to be created, and because their cleanup code is </li>
<li>/* invoked directly by the reference-handler thread rather than by the </li>
<li>/* finalizer thread.  They are more robust because they use phantom references, </li>
<li>/* the weakest type of reference object, thereby avoiding the nasty ordering </li>
<li>/* problems inherent to finalization. </li>
<li>/* </li>
<li>/* <p> A cleaner tracks a referent object and encapsulates a thunk of arbitrary </li>
<li>/* cleanup code.  Some time after the GC detects that a cleaner&#39;s referent has </li>
<li>/* become phantom-reachable, the reference-handler thread will run the cleaner. </li>
<li>/* Cleaners may also be invoked directly; they are thread safe and ensure that </li>
<li>/* they run their thunks at most once. </li>
<li>/* </li>
<li>/* <p> Cleaners are not a replacement for finalization.  They should be used </li>
<li>/* only when the cleanup code is extremely simple and straightforward. </li>
<li>/* Nontrivial cleaners are inadvisable since they risk blocking the </li>
<li>/* reference-handler thread and delaying further cleanup and finalization. </li>
<li>/* </li>
<li>/* </li>
<li>/* @author Mark Reinhold </li>
<li>/* @version %I%, %E% </li>
<li><p>/<em>/<br>//</em>/<em> /</em> General-purpose phantom-reference-based cleaners. /<em> /</em> <p> Cleaners are a lightweight and more robust alternative to finalization. /<em> They are lightweight because they are not created by the VM and thus do not /</em> require a JNI upcall to be created, and because their cleanup code is /<em> invoked directly by the reference-handler thread rather than by the /</em> finalizer thread. They are more robust because they use phantom references, /<em> the weakest type of reference object, thereby avoiding the nasty ordering /</em> problems inherent to finalization. /<em> /</em> <p> A cleaner tracks a referent object and encapsulates a thunk of arbitrary /<em> cleanup code. Some time after the GC detects that a cleaner&#39;s referent has /</em> become phantom-reachable, the reference-handler thread will run the cleaner. /<em> Cleaners may also be invoked directly; they are thread safe and ensure that /</em> they run their thunks at most once. /<em> /</em> <p> Cleaners are not a replacement for finalization. They should be used /<em> only when the cleanup code is extremely simple and straightforward. /</em> Nontrivial cleaners are inadvisable since they risk blocking the /<em> reference-handler thread and delaying further cleanup and finalization. /</em> /<em> /</em> @author Mark Reinhold /<em> @version %I%, %E% /</em>/
重点是这两句：&quot;A cleaner tracks a referent object and encapsulates a thunk of arbitrary cleanup code.  Some time after the GC detects that a cleaner&#39;s referent has become phantom-reachable, the reference-handler thread will run the cleaner.&quot;
Oracle/Sun JDK 6中的HotSpot VM只会在old gen GC（full GC/major GC或者concurrent GC都算）的时候才会对old gen中的对象做reference processing，而在young GC/minor GC时只会对young gen里的对象做reference processing。
（死在young gen中的DirectByteBuffer对象会在young GC时被处理的例子，请参考这里：<a href="https://gist.github.com/1614952" target="_blank"><a href="https://gist.github.com/1614952">https://gist.github.com/1614952</a></a>）
也就是说，做full GC的话会对old gen做reference processing，进而能触发Cleaner对已死的DirectByteBuffer对象做清理工作。而如果很长一段时间里没做过GC或者只做了young GC的话则不会在old gen触发Cleaner的工作，那么就可能让本来已经死了的、但已经晋升到old gen的DirectByteBuffer关联的native memory得不到及时释放。
3、为DirectByteBuffer分配空间过程中会显式调用System.gc()，以期通过full GC来强迫已经无用的DirectByteBuffer对象释放掉它们关联的native memory：
Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>// These methods should be called whenever direct memory is allocated or  </p>
</li>
<li>// freed.  They allow the user to control the amount of direct memory  </li>
<li>// which a process may access.  All sizes are specified in bytes.  </li>
<li>static void reserveMemory(long size) {  </li>
<li></li>
<li>synchronized (Bits.class) {  </li>
<li>if (!memoryLimitSet &amp;&amp; VM.isBooted()) {  </li>
<li>maxMemory = VM.maxDirectMemory();  </li>
<li>memoryLimitSet = true;  </li>
<li>}  </li>
<li>if (size &lt;= maxMemory - reservedMemory) {  </li>
<li>reservedMemory += size;  </li>
<li>return;  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>System.gc();  </li>
<li>try {  </li>
<li>Thread.sleep(100);  </li>
<li>} catch (InterruptedException x) {  </li>
<li>// Restore interrupt status  </li>
<li>Thread.currentThread().interrupt();  </li>
<li>}  </li>
<li>synchronized (Bits.class) {  </li>
<li>if (reservedMemory + size &gt; maxMemory)  </li>
<li>throw new OutOfMemoryError(&quot;Direct buffer memory&quot;);  </li>
<li>reservedMemory += size;  </li>
<li>}  </li>
<li></li>
<li>}<br>// These methods should be called whenever direct memory is allocated or // freed. They allow the user to control the amount of direct memory // which a process may access. All sizes are specified in bytes. static void reserveMemory(long size) { synchronized (Bits.class) { if (!memoryLimitSet &amp;&amp; VM.isBooted()) { maxMemory = VM.maxDirectMemory(); memoryLimitSet = true; } if (size &lt;= maxMemory - reservedMemory) { reservedMemory += size; return; } } System.gc(); try { Thread.sleep(100); } catch (InterruptedException x) { // Restore interrupt status Thread.currentThread().interrupt(); } synchronized (Bits.class) { if (reservedMemory + size &gt; maxMemory) throw new OutOfMemoryError(&quot;Direct buffer memory&quot;); reservedMemory += size; } }
这几个实现特征使得Oracle/Sun JDK 6依赖于System.gc()触发GC来保证DirectByteMemory的清理工作能及时完成。如果打开了-XX:+DisableExplicitGC，清理工作就可能得不到及时完成，于是就有机会见到direct memory的OOM，也就是上面的例子演示的情况。我们这边在实际生产环境中确实遇到过这样的问题。<h1 id="-oracle-sun-jdk-6-direct-memory-xx-disableexplicitgc-direct-memory-oom-oom-system-gc-full-gc-xx-explicitgcinvokesconcurrent-">教训是：如果你在使用Oracle/Sun JDK 6，应用里有任何地方用了direct memory，那么使用-XX:+DisableExplicitGC要小心。如果用了该参数而且遇到direct memory的OOM，可以尝试去掉该参数看是否能避开这种OOM。如果担心System.gc()调用造成full GC频繁，可以尝试下面提到 -XX:+ExplicitGCInvokesConcurrent 参数</h1>
2、-XX:+DisableExplicitGC 与 Remote Method Invocation (RMI) 与 -Dsun.rmi.dgc.{server|client}.gcInterval=
看了上一个例子有没有觉得-XX:+DisableExplicitGC参数用起来很危险？那干脆完全不要用这个参数吧。又有什么坑呢？
前段时间有个应用的开发来抱怨，说某次升级JDK之前那应用的GC状况都很好，很长时间都不会发生full GC，但升级后发现每一小时左右就会发生一次。经过对比发现，升级的同时也吧启动参数改了，把原本有的-XX:+DisableExplicitGC给去掉了。
观察到的日志有明显特征。一位同事表示：
引用</li>
</ol>
<p>线上机器出现一个场景；每隔1小时出现一次Full GC,用btrace看了一下调用地：
who call system.gc :
sun.misc.GC$Daemon.run(GC.java:92)
预发机没什么流量，也会每一小时一次Full GC
频率正好是一小时一次
Gc log代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>2011-09-23T10:49:38.071+0800: 327692.227: [Full GC (System) 327692.227: [CMS: 75793K-&gt;75759K(2097152K), 0.6923690 secs] 430298K-&gt;75759K(3984640K), [CMS Perm : 104136K-&gt;104124K(173932K)], 0.6925570 secs]<br>2011-09-23T10:49:38.071+0800: 327692.227: [Full GC (System) 327692.227: [CMS: 75793K-&gt;75759K(2097152K), 0.6923690 secs] 430298K-&gt;75759K(3984640K), [CMS Perm : 104136K-&gt;104124K(173932K)], 0.6925570 secs]
实际上这里在做的是分布式GC。Sun JDK的分布式GC是用纯Java实现的，为RMI服务。
RMI DGC相关参数的介绍文档：<a href="http://docs.oracle.com/javase/6/docs/technotes/guides/rmi/sunrmiproperties.html" target="_blank"><a href="http://docs.oracle.com/javase/6/docs/technotes/guides/rmi/sunrmiproperties.html">http://docs.oracle.com/javase/6/docs/technotes/guides/rmi/sunrmiproperties.html</a></a>
（后面回头再补…先睡觉去了）
资料：
<a href="http://java.sun.com/developer/onlineTraining/rmi/exercises/DistributedGarbageCollector/index.html" target="_blank">jGuru: Distributed Garbage Collection</a>
<a href="http://mail.openjdk.java.net/pipermail/hotspot-dev/2011-December/004909.html" target="_blank"><a href="http://mail.openjdk.java.net/pipermail/hotspot-dev/2011-December/004909.html">http://mail.openjdk.java.net/pipermail/hotspot-dev/2011-December/004909.html</a></a>
Tony Printezis 写道</li>
</ol>
<p>RMI has a distributed GC that relies on reference processing to allow
each node to recognize that some objects are unreachable so it can
notify a remote node (or nodes) that some remote references to them do
not exist any more. The remote node might then be able to reclaim
objects that are only remotely reachable. (Or this is how I understood
it at least.)
RMI used to call System.gc() once a minute (!!!) but after some
encouragement from yours truly they changed the default to once an hour
(this is configurable using a property). Note that a STW Full GC is not
really required as long as references are processed. So, in CMS (and
G1), a concurrent cycle is fine which is why we recommend to use
-XX:+ExplicitGCInvokesConcurrent in this case.
I had been warned by the RMI folks against totally disabling those
System.gc()&#39;s (e.g., using -XX:+DisableExplicitGC) given that if Full
GCs / concurrent cycles do not otherwise happen at a reasonable
frequency then remote nodes might experience memory leaks since they
will consider that some otherwise unreachable remote references are
still live. I have no idea how severe such memory leaks would be. I
guess they&#39;d be very application-dependent.
An additional thought that just occurred to me: instead of calling
System.gc() every hour what RMI should really be doing is calling
System.gc() every hour provided no old gen GC has taken place during the
last hour. This would be relatively easy to implement by accessing the
old GC counter through the GC MXBeans.
Tony
再加俩链接：<a href="http://mail.openjdk.java.net/pipermail/hotspot-dev/2012-January/004929.html" target="_blank"><a href="http://mail.openjdk.java.net/pipermail/hotspot-dev/2012-January/004929.html">http://mail.openjdk.java.net/pipermail/hotspot-dev/2012-January/004929.html</a></a>
<a href="http://mail.openjdk.java.net/pipermail/hotspot-dev/2012-January/004946.html" target="_blank"><a href="http://mail.openjdk.java.net/pipermail/hotspot-dev/2012-January/004946.html">http://mail.openjdk.java.net/pipermail/hotspot-dev/2012-January/004946.html</a></a></p>
<h1 id="-java-performance-303-411-xx-disableexplicitgc-rmi-">《Java Performance》的303和411页正好也提到了-XX:+DisableExplicitGC与RMI之间的干扰的事情，有兴趣可以读一下，虽然只有一小段。</h1>
<p>3、-XX:+ExplicitGCInvokesConcurrent 或 -XX:+ExplicitGCInvokesConcurrentAndUnloadsClasses
C++代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>product(bool, ExplicitGCInvokesConcurrent, false,                  \  </li>
<li>&quot;A System.gc() request invokes a concurrent collection;&quot;         \  </li>
<li>&quot; (effective only when UseConcMarkSweepGC)&quot;)                     \  </li>
<li>\  </li>
<li>product(bool, ExplicitGCInvokesConcurrentAndUnloadsClasses, false, \  </li>
<li>&quot;A System.gc() request invokes a concurrent collection and &quot;     \  </li>
<li>&quot;also unloads classes during such a concurrent gc cycle &quot;        \  </li>
<li><p>&quot;(effective only when UseConcMarkSweepGC)&quot;)                      \<br>product(bool, ExplicitGCInvokesConcurrent, false, \ &quot;A System.gc() request invokes a concurrent collection;&quot; \ &quot; (effective only when UseConcMarkSweepGC)&quot;) \ \ product(bool, ExplicitGCInvokesConcurrentAndUnloadsClasses, false, \ &quot;A System.gc() request invokes a concurrent collection and &quot; \ &quot;also unloads classes during such a concurrent gc cycle &quot; \ &quot;(effective only when UseConcMarkSweepGC)&quot;) \
跟上面的第一个例子的-XX:+DisableExplicitGC一样，这两个参数也是用来改变System.gc()的默认行为用的；不同的是这两个参数只能配合CMS使用（-XX:+UseConcMarkSweepGC），而且System.gc()还是会触发GC的，只不过不是触发一个完全stop-the-world的full GC，而是一次并发GC周期。
CMS GC周期中也会做reference processing。所以如果用这两个参数的其中一个，而不是用-XX:+DisableExplicitGC的话，就避开了由full GC带来的长GC pause，同时NIO direct memory的OOM也不会那么容易发生。
做了个跟第一个例子类似的例子，在这里：<a href="https://gist.github.com/1344251" target="_blank"><a href="https://gist.github.com/1344251">https://gist.github.com/1344251</a></a>
《Java Performance》的303页有讲到这俩参数。
相关bug：<a href="http://bugs.sun.com/view_bug.do?bug_id=6919638" target="_blank">6919638 CMS: ExplicitGCInvokesConcurrent misinteracts with gc locker</a></p>
<h1 id="-jdk6u23-">&lt;&lt; JDK6u23修复了这个问题</h1>
<p>4、-XX:+GCLockerInvokesConcurrent
C++代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>product(bool, GCLockerInvokesConcurrent, false,        \  </p>
</li>
<li>&quot;The exit of a JNI CS necessitating a scavenge also&quot; \  </li>
<li><p>&quot; kicks off a bkgrd concurrent collection&quot;)          \<br>product(bool, GCLockerInvokesConcurrent, false, \ &quot;The exit of a JNI CS necessitating a scavenge also&quot; \ &quot; kicks off a bkgrd concurrent collection&quot;) \</p>
<h1 id="-">（内容回头补…）</h1>
<p>5、MaxDirectMemorySize 与 NIO direct memory 的默认上限
<strong>-XX:MaxDirectMemorySize</strong> 是用来配置NIO direct memory上限用的VM参数。
C++代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>product(intx, MaxDirectMemorySize, -1,                         \  </p>
</li>
<li><p>&quot;Maximum total size of NIO direct-buffer allocations&quot;) \<br>product(intx, MaxDirectMemorySize, -1, \ &quot;Maximum total size of NIO direct-buffer allocations&quot;) \
但如果不配置它的话，direct memory默认最多能申请多少内存呢？这个参数默认值是-1，显然不是一个“有效值”。所以真正的默认值肯定是从别的地方来的。
在Sun JDK 6和OpenJDK 6里，有这样一段代码，sun.misc.VM：
Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>// A user-settable upper limit on the maximum amount of allocatable direct  </p>
</li>
<li>// buffer memory.  This value may be changed during VM initialization if  </li>
<li>// &quot;java&quot; is launched with &quot;-XX:MaxDirectMemorySize=<size>&quot;.  </li>
<li>//  </li>
<li>// The initial value of this field is arbitrary; during JRE initialization  </li>
<li>// it will be reset to the value specified on the command line, if any,  </li>
<li>// otherwise to Runtime.getRuntime().maxMemory().  </li>
<li>//  </li>
<li>private static long directMemory = 64 /<em> 1024 /</em> 1024;  </li>
<li></li>
<li>// If this method is invoked during VM initialization, it initializes the  </li>
<li>// maximum amount of allocatable direct buffer memory (in bytes) from the  </li>
<li>// system property sun.nio.MaxDirectMemorySize.  The system property will  </li>
<li>// be removed when it is accessed.  </li>
<li>//  </li>
<li>// If this method is invoked after the VM is booted, it returns the  </li>
<li>// maximum amount of allocatable direct buffer memory.  </li>
<li>//  </li>
<li>public static long maxDirectMemory() {  </li>
<li>if (booted)  </li>
<li>return directMemory;  </li>
<li></li>
<li>Properties p = System.getProperties();  </li>
<li>String s = (String)p.remove(&quot;sun.nio.MaxDirectMemorySize&quot;);  </li>
<li>System.setProperties(p);  </li>
<li></li>
<li>if (s != null) {  </li>
<li>if (s.equals(&quot;-1&quot;)) {  </li>
<li>// -XX:MaxDirectMemorySize not given, take default  </li>
<li>directMemory = Runtime.getRuntime().maxMemory();  </li>
<li>} else {  </li>
<li>long l = Long.parseLong(s);  </li>
<li>if (l &gt; -1)  </li>
<li>directMemory = l;  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>return directMemory;  </li>
<li><p>}<br>// A user-settable upper limit on the maximum amount of allocatable direct // buffer memory. This value may be changed during VM initialization if // &quot;java&quot; is launched with &quot;-XX:MaxDirectMemorySize=<size>&quot;. // // The initial value of this field is arbitrary; during JRE initialization // it will be reset to the value specified on the command line, if any, // otherwise to Runtime.getRuntime().maxMemory(). // private static long directMemory = 64 /<em> 1024 /</em> 1024; // If this method is invoked during VM initialization, it initializes the // maximum amount of allocatable direct buffer memory (in bytes) from the // system property sun.nio.MaxDirectMemorySize. The system property will // be removed when it is accessed. // // If this method is invoked after the VM is booted, it returns the // maximum amount of allocatable direct buffer memory. // public static long maxDirectMemory() { if (booted) return directMemory; Properties p = System.getProperties(); String s = (String)p.remove(&quot;sun.nio.MaxDirectMemorySize&quot;); System.setProperties(p); if (s != null) { if (s.equals(&quot;-1&quot;)) { // -XX:MaxDirectMemorySize not given, take default directMemory = Runtime.getRuntime().maxMemory(); } else { long l = Long.parseLong(s); if (l &gt; -1) directMemory = l; } } return directMemory; }
（代码里原本的注释有个写错的地方，上面有修正）
当MaxDirectMemorySize参数没被显式设置时它的值就是-1，在Java类库初始化时maxDirectMemory()被java.lang.System的静态构造器调用，走的路径就是这条：
Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>if (s.equals(&quot;-1&quot;)) {  </p>
</li>
<li>// -XX:MaxDirectMemorySize not given, take default  </li>
<li>directMemory = Runtime.getRuntime().maxMemory();  </li>
<li><p>}<br>if (s.equals(&quot;-1&quot;)) { // -XX:MaxDirectMemorySize not given, take default directMemory = Runtime.getRuntime().maxMemory(); }
而Runtime.maxMemory()在HotSpot VM里的实现是：
C++代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>JVM_ENTRY_NO_ENV(jlong, JVM_MaxMemory(void))  </p>
</li>
<li>JVMWrapper(&quot;JVM_MaxMemory&quot;);  </li>
<li>size_t n = Universe::heap()-&gt;max_capacity();  </li>
<li>return convert_size_t_to_jlong(n);  </li>
<li><p>JVM_END<br>JVM_ENTRY_NO_ENV(jlong, JVM_MaxMemory(void)) JVMWrapper(&quot;JVM_MaxMemory&quot;); size_t n = Universe::heap()-&gt;max_capacity(); return convert_size_t_to_jlong(n); JVM_END
这个max_capacity()实际返回的是 -Xmx减去一个survivor space的预留大小（G1除外）。
结论：MaxDirectMemorySize没显式配置的时候，NIO direct memory可申请的空间的上限就是<strong>-Xmx减去一个survivor space的预留大小</strong>。
大家感兴趣的话可以试试在不同的-Xmx的条件下不设置MaxDirectMemorySize，并且调用一下sun.misc.VM.maxDirectMemory()看得到的值的相关性。</p>
<h1 id="-jdk7-http-hg-openjdk-java-net-jdk7-jdk7-jdk-rev-b444f86c4abe-http-hg-openjdk-java-net-jdk7-jdk7-jdk-rev-b444f86c4abe-">该行为在JDK7里没变，虽然具体实现的代码有些变化。请参考<a href="http://hg.openjdk.java.net/jdk7/jdk7/jdk/rev/b444f86c4abe" target="_blank"><a href="http://hg.openjdk.java.net/jdk7/jdk7/jdk/rev/b444f86c4abe">http://hg.openjdk.java.net/jdk7/jdk7/jdk/rev/b444f86c4abe</a></a></h1>
<p>6、-verbose:gc 与 -XX:+PrintGCDetails
经常能看到在推荐的标准参数里这两个参数一起出现。实际上它们有啥关系？
在Oracle/Sun JDK 6里，&quot;java&quot;这个启动程序遇到&quot;-verbosegc&quot;会将其转换为&quot;-verbose:gc&quot;，将启动参数传给HotSpot VM后，HotSpot VM遇到&quot;-verbose:gc&quot;则会当作&quot;-XX:+PrintGC&quot;来处理。
也就是说 -verbosegc、-verbose:gc、-XX:+PrintGC 三者的作用是完全一样的。
而当HotSpot VM遇到 -XX:+PrintGCDetails 参数时，会顺带把 -XX:+PrintGC 给设置上。
也就是说 -XX:+PrintGCDetails 包含 -XX:+PrintGC，进而也就包含 -verbose:gc。</p>
<h1 id="-verbose-gc-">既然 -verbose:gc 都被包含了，何必在命令行参数里显式设置它呢？<img src="" alt=""></h1>
<p>7、-XX:+UseFastEmptyMethods 与 -XX:+UseFastAccessorMethods
虽然不常见，但偶尔也会见到推荐的标准参数上有这俩的身影。
empty method顾名思义就是空方法，也就是方法体只包含一条return指令、返回值类型为void的Java方法。
accessor method在这里则有很具体的定义：
C++代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>bool methodOopDesc::is_accessor() const {  </p>
</li>
<li>if (code_size() != 5) return false;  </li>
<li>if (size_of_parameters() != 1) return false;  </li>
<li>if (java_code_at(0) != Bytecodes::_aload_0 ) return false;  </li>
<li>if (java_code_at(1) != Bytecodes::_getfield) return false;  </li>
<li>if (java_code_at(4) != Bytecodes::_areturn &amp;&amp;  </li>
<li>java_code_at(4) != Bytecodes::_ireturn ) return false;  </li>
<li>return true;  </li>
<li><p>}<br>bool methodOopDesc::is_accessor() const { if (code_size() != 5) return false; if (size_of_parameters() != 1) return false; if (java_code_at(0) != Bytecodes::_aload_0 ) return false; if (java_code_at(1) != Bytecodes::_getfield) return false; if (java_code_at(4) != Bytecodes::_areturn &amp;&amp; java_code_at(4) != Bytecodes::_ireturn ) return false; return true; }
如果从Java源码的角度来理解，accessor method就是形如这样的：
Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>public class Foo {  </p>
</li>
<li>private int value;  </li>
<li></li>
<li>public int getValue() {  </li>
<li>return this.value;  </li>
<li>}  </li>
<li><p>}<br>public class Foo { private int value; public int getValue() { return this.value; } }
关键点是：
1、必须是成员方法；静态方法不行
2、返回值类型必须是引用类型或者int，其它都不算
3、方法体的代码必须满足aload_0; getfield /#index; areturn或ireturn这样的模式。
留意：方法名是什么都没关系，是不是get、is、has开头都不重要。
那么这俩有啥问题？
取自JDK 6 update 27：
C++代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>product(bool, UseFastEmptyMethods, true,                   \  </p>
</li>
<li>&quot;Use fast method entry code for empty methods&quot;)    \  </li>
<li>\  </li>
<li>product(bool, UseFastAccessorMethods, true,                \  </li>
<li><p>&quot;Use fast method entry code for accessor methods&quot;) \<br>product(bool, UseFastEmptyMethods, true, \ &quot;Use fast method entry code for empty methods&quot;) \ \ product(bool, UseFastAccessorMethods, true, \ &quot;Use fast method entry code for accessor methods&quot;) \
看到这俩参数的默认值都是true了么？也就是说，在Oracle/Sun JDK 6上设置这参数其实也是没意义的，跟默认一样，一直到最新的JDK 6 update 29都是如此。
不过在Oracle/Sun JDK 7里，情况有变化。
<a href="http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6385687" target="_blank">Bug ID: 6385687 UseFastEmptyMethods/UseFastAccessorMethods considered harmful</a>
在<a href="http://hg.openjdk.java.net/jdk7/hotspot-comp/hotspot/rev/c2323e2ea62b" target="_blank">上述bug对应的代码变更</a>后，这俩参数的默认值改为了false。
本来想多写点这块的…算，还是长话短说。
Oracle JDK 7里的HotSpot VM已经开始有比较好的<a href="http://rednaxelafx.iteye.com/blog/1022095" target="_blank">多层编译（tiered compilation）支持</a>，可以预见在不久的将来该模式将成为HotSpot VM默认的执行模式。当前该模式尚未默认开启；可以通过 <strong>-XX:+TieredCompilation</strong> 来开启。
有趣的是，在使用多层编译模式时，如果UseFastAccessorMethods/UseFastEmptyMethods是开着的，有些多态方法调用点的性能反而会显著下降。所以，为了适应多层编译模式，JDK 7里这两个参数的默认值就被改为false了。</p>
<h1 id="-review-for-6385687-usefastemptymethods-usefastaccessormethods-considered-harmful-http-mail-openjdk-java-net-pipermail-hotspot-compiler-dev-2011-march-005057-html-">在邮件列表上有过相关讨论：<a href="http://mail.openjdk.java.net/pipermail/hotspot-compiler-dev/2011-March/005057.html" target="_blank">review for 6385687: UseFastEmptyMethods/UseFastAccessorMethods considered harmful</a></h1>
<p>8、-XX:+UseCMSCompactAtFullCollection
这个参数在Oracle/Sun JDK 6里一直都默认是true，完全没必要显式设置，设了也不会有啥不同的效果。
C++代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>product(bool, UseCMSCompactAtFullCollection, true,    \  </p>
</li>
<li><p>&quot;Use mark sweep compact at full collections&quot;) \<br>product(bool, UseCMSCompactAtFullCollection, true, \ &quot;Use mark sweep compact at full collections&quot;) \
我不认为显式设置一个跟默认值相同的参数有什么维护上的好处。要维护的参数多了反而更容易成为维护的噩梦吧。后面的人会不知道到底当初为什么要设置这个参数。
相关的有个 <strong>CMSFullGCsBeforeCompaction</strong> 参数，请参考另一帖里的讨论：<a href="http://hllvm.group.iteye.com/group/topic/28854#209294" target="_blank"><a href="http://hllvm.group.iteye.com/group/topic/28854/#209294">http://hllvm.group.iteye.com/group/topic/28854/#209294</a></a>
同样，在Oracle/Sun JDK 6和OpenJDK 6里，<strong>CMSParallelRemarkEnabled</strong> 也一直默认是true，没必要显式设置-XX:+CMSParallelRemarkEnabled。
有很多bool类型的参数默认都是true，显式设置它们之前最好先用这帖开头介绍的办法看看默认值是否已经是想要的值了。
C++代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>product(bool, CMSScavengeBeforeRemark, false,          \  </p>
</li>
<li><p>&quot;Attempt scavenge before the CMS remark step&quot;) \<br>product(bool, CMSScavengeBeforeRemark, false, \ &quot;Attempt scavenge before the CMS remark step&quot;) \</p>
<h1 id="-false-young-gc-cms-remark-remark-young-gc-remark-">这个默认倒是false。如果一个应用统计到的young GC时间都比较短而CMS remark的时间比较长，那么可以试试打开这个参数，在做remark之前先做一次young GC。是否能有效缩短remark的时间视应用情况而异，所以开这个参数的话请一定做好测试。</h1>
<p>9、-XX:CMSMaxAbortablePrecleanTime=5000
同上…默认就是5000
C++代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>product(intx, CMSMaxAbortablePrecleanTime, 5000,    \  </p>
</li>
<li>&quot;(Temporary, subject to experimentation)&quot;   \  </li>
<li><p>&quot;Maximum time in abortable preclean in ms&quot;) \<br>product(intx, CMSMaxAbortablePrecleanTime, 5000, \ &quot;(Temporary, subject to experimentation)&quot; \ &quot;Maximum time in abortable preclean in ms&quot;) \</p>
<h1 id="-">还是不要设跟默认值一样的参数了吧。</h1>
<p>10、-Xss 与 -XX:ThreadStackSize
参考我之前发过的两帖：
<a href="http://mail.openjdk.java.net/pipermail/hotspot-dev/2011-June/004272.html" target="_blank">What the difference between -Xss and -XX:ThreadStackSize is?</a>
<a href="http://mail.openjdk.java.net/pipermail/hotspot-dev/2011-July/004288.html" target="_blank">Inconsistency between -Xss and -XX:ThreadStackSize in the java launcher</a></p>
<h1 id="-">（详情回头补～）</h1>
<p>11、-Xmn 与 -XX:NewSize、-XX:MaxNewSize</p>
<h1 id="-xx-newsize-xx-maxnewsize-could-not-reserve-enough-space-for-object-heap-http-hllvm-group-iteye-com-group-topic-28467-206341-jdk-6-jdk-6-update-14-">如果同时设置了-XX:NewSize与-XX:MaxNewSize遇到“Could not reserve enough space for object heap”错误的话，请看看是不是<a href="http://hllvm.group.iteye.com/group/topic/28467#206341" target="_blank">这帖所说的问题</a>。早期JDK 6似乎都受这问题影响，一直到JDK 6 update 14才修复。</h1>
<h1 id="12-xmn-xx-newratio">12、-Xmn 与 -XX:NewRatio</h1>
<h1 id="13-xx-newratio-xx-newsize-xx-oldsize">13、-XX:NewRatio 与 -XX:NewSize、-XX:OldSize</h1>
<p>14、jmap -heap看到的参数值与实际起作用的参数的关系？
发了几个例子在这里：<a href="https://gist.github.com/1363195" target="_blank"><a href="https://gist.github.com/1363195">https://gist.github.com/1363195</a></a>
其中有个看起来很恐怖的值：
Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>MaxNewSize       = 17592186044415 MB<br>MaxNewSize = 17592186044415 MB
这是啥来的？
C++代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>product(uintx, MaxNewSize, max_uintx,                                  \  </p>
</li>
<li>&quot;Maximum new generation size (in bytes), max_uintx means set &quot; \  </li>
<li><p>&quot;ergonomically&quot;)<br>product(uintx, MaxNewSize, max_uintx, \ &quot;Maximum new generation size (in bytes), max_uintx means set &quot; \ &quot;ergonomically&quot;)
在HotSpot VM里，intx是跟平台字长一样宽的带符号整型，uintx是其无符号版。
max_uintx是(uintx) -1，也就是说在32位平台上是无符号的0xFFFFFFFF，64位平台上则是0xFFFFFFFFFFFFFFFF。
jmap -heap显示的部分参数是以MB为单位来显示的，而MaxNewSize的单位是byte。我跑例子的平台是64位的，于是算一下 0xFFFFFFFFFFFFFFFF / 1024 / 1024 = 17592186044415 MB 。
参数的说明告诉我们，当MaxNewSize的值等于max_uintx时，意思就是交由ergonomics来自动选择young gen的最大大小。<strong>并不是说young gen的最大大小真的有0xFFFFFFFFFFFFFFFF这么大</strong>。
要注意的是，HotSpot VM有大量可调节的参数，并不是所有参数在某次运行的时候都有效。
例如说设置了-Xmn的话，NewRatio就没作用了。
又例如说，
C++代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>product(uintx, OldSize, ScaleForWordSize(4/*M),        \  </p>
</li>
<li><p>&quot;Initial tenured generation size (in bytes)&quot;) \<br>product(uintx, OldSize, ScaleForWordSize(4/*M), \ &quot;Initial tenured generation size (in bytes)&quot;) \
-XX:OldSize参数的默认值在32位平台上是4M，在64位平台上是5M多。但如果这个参数没有被显式设置过，那它实际上是没作用的；old gen的大小会通过Java heap的整体大小与young gen的大小配置计算出来，但OldSize参数却没有被更新（因为根本没用它）。于是这个参数的值与实际运行的状况就可能会不相符。
一种例外的情况是，如果-Xmx非常小，比NewSize+OldSize的默认值还小，那这个OldSize的默认值就会起作用，把MaxHeapSize给撑大。
C++代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>void TwoGenerationCollectorPolicy::initialize_flags() {  </p>
</li>
<li>GenCollectorPolicy::initialize_flags();  </li>
<li></li>
<li>OldSize = align_size_down(OldSize, min_alignment());  </li>
<li>if (NewSize + OldSize &gt; MaxHeapSize) {  </li>
<li>MaxHeapSize = NewSize + OldSize;  </li>
<li>}  </li>
<li>MaxHeapSize = align_size_up(MaxHeapSize, max_alignment());  </li>
<li>//...  </li>
<li><p>}<br>void TwoGenerationCollectorPolicy::initialize_flags() { GenCollectorPolicy::initialize_flags(); OldSize = align_size_down(OldSize, min_alignment()); if (NewSize + OldSize &gt; MaxHeapSize) { MaxHeapSize = NewSize + OldSize; } MaxHeapSize = align_size_up(MaxHeapSize, max_alignment()); //... }</p>
<h1 id="-https-gist-github-com-1375782-https-gist-github-com-1375782-">可以看这边的一个例子：<a href="https://gist.github.com/1375782" target="_blank"><a href="https://gist.github.com/1375782">https://gist.github.com/1375782</a></a></h1>
<p>15、-XX:+AlwaysTenure、-XX:+NeverTenure、-XX:MaxTenuringThreshold=0 或 &quot;-XX:MaxTenuringThreshold=markOopDesc::max_age + 1&quot;
ParNew的时候，设定-XX:+AlwaysTenure隐含-XX:MaxTenuringThreshold=0；不过-XX:+NeverTenure却没啥特别的作用。</p>
<h1 id="-xx-alwaystenure-xx-nevertenure-">-XX:+AlwaysTenure 与 -XX:+NeverTenure 是互斥的，最后一个出现的那个会同时决定这两个参数的值。</h1>
<p>16、-XX:MaxTenuringThreshold 的默认值？
C++代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>product(intx, MaxTenuringThreshold,    15, \  </p>
</li>
<li><p>&quot;Maximum value for tenuring threshold&quot;)  \<br>product(intx, MaxTenuringThreshold, 15, \ &quot;Maximum value for tenuring threshold&quot;) \
Oracle/Sun JDK 6中，选择CMS之外的GC时，MaxTenuringThreshold（以下简称MTT）的默认值是15；而选择了CMS的时候，MTT的默认值是4而不是15。设定是在 Arguments::set_cms_and_parnew_gc_flags() 里做的。
在Sun JDK 6之前（1.4.2、5），选择CMS的时候MTT的默认值则是0，也就是等于设定了-XX:+AlwaysTenure——所有eden里的活对象在经历第一次minor GC的时候就会直接晋升到old gen，而survivor space直接就没用了。
Command prompt代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>$ java -version  </p>
</li>
<li>java version &quot;1.6.0_25&quot;  </li>
<li>Java(TM) SE Runtime Environment (build 1.6.0_25-b06)  </li>
<li>Java HotSpot(TM) 64-Bit Server VM (build 20.0-b11, mixed mode)  </li>
<li>$ java -XX:+PrintFlagsFinal | egrep &#39;MaxTenuringThreshold|UseParallelGC|UseConcMarkSweepGC&#39;  </li>
<li>intx MaxTenuringThreshold                      = 15              {product}             </li>
<li>bool UseConcMarkSweepGC                        = false           {product}             </li>
<li>bool UseParallelGC                            := true            {product}             </li>
<li>$ java -XX:+PrintFlagsFinal -XX:+UseConcMarkSweepGC | egrep &#39;MaxTenuringThreshold|UseParallelGC|UseConcMarkSweepGC&#39;  </li>
<li>intx MaxTenuringThreshold                     := 4               {product}             </li>
<li>bool UseConcMarkSweepGC                       := true            {product}             </li>
<li><p>bool UseParallelGC                             = false           {product}             </p>
<h1 id="-java-version-java-version-1-6-0_25-java-tm-se-runtime-environment-build-1-6-0_25-b06-java-hotspot-tm-64-bit-server-vm-build-20-0-b11-mixed-mode-java-xx-printflagsfinal-egrep-maxtenuringthreshold-useparallelgc-useconcmarksweepgc-intx-maxtenuringthreshold-15-product-bool-useconcmarksweepgc-false-product-bool-useparallelgc-true-product-java-xx-printflagsfinal-xx-useconcmarksweepgc-egrep-maxtenuringthreshold-useparallelgc-useconcmarksweepgc-intx-maxtenuringthreshold-4-product-bool-useconcmarksweepgc-true-product-bool-useparallelgc-false-product-">$ java -version java version &quot;1.6.0_25&quot; Java(TM) SE Runtime Environment (build 1.6.0_25-b06) Java HotSpot(TM) 64-Bit Server VM (build 20.0-b11, mixed mode) $ java -XX:+PrintFlagsFinal | egrep &#39;MaxTenuringThreshold|UseParallelGC|UseConcMarkSweepGC&#39; intx MaxTenuringThreshold = 15 {product} bool UseConcMarkSweepGC = false {product} bool UseParallelGC := true {product} $ java -XX:+PrintFlagsFinal -XX:+UseConcMarkSweepGC | egrep &#39;MaxTenuringThreshold|UseParallelGC|UseConcMarkSweepGC&#39; intx MaxTenuringThreshold := 4 {product} bool UseConcMarkSweepGC := true {product} bool UseParallelGC = false {product}</h1>
<p>17、-XX:+CMSClassUnloadingEnabled</p>
<h1 id="cms-remark-string-intern-">CMS remark暂停时间会增加，所以如果类加载并不频繁、String的intern也没有大量使用的话，这个参数还是不开的好。</h1>
<h1 id="18-xx-aggressiveheap">18、-XX:+AggressiveHeap</h1>
<p>19、-XX:+UseCompressedOops 有益？有害？
先把微博上回复别人问题的解答放这边。
本来如果功能没bug的话，Oracle/Sun JDK 6的64位HotSpot上，GC堆在26G以下（-Xmx + -XX:MaxPermSize）的时候用多数都是有益的。
开启压缩指针后，从代码路径（code path）和CPI（cycles per instruction）两个角度看，情况是不一样的：
·开启压缩指针会使代码路径变长，因为所有在GC堆里的、指向GC堆内对象的指针都会被压缩，这些指针的访问就需要更多的代码才可以实现。不要以为只是读写字段才受影响，其实实例方法调用、子类型检查等操作也受影响——“klass”也是一个指针，也被压缩了。
·但从CPI的角度看，由于压缩指针使需要拷贝的数据量变小了，cache miss的几率随之降低，结果CPI可能会比压缩前降低。综合来看，开了压缩指针通常能大幅降低GC堆内存的消耗，同时维持或略提高Java程序的速度。
但，JDK6u23之前那个参数的bug实在太多，最好别用；而6u23之后它就由ergonomics自动开启了，不用自己设。如果在6u23或更高版本碰到压缩指针造成的问题的话，显式设置 <strong>-XX:-UseCompressedOops</strong> 。
我能做的建议是如果在64位Oracle/Sun JDK 6/7上，那个参数不要显式设置。
关于HotSpot VM的ergonomics自动开启压缩指针功能，请参考<a href="http://rednaxelafx.iteye.com/blog/1010079" target="_blank">之前的一帖</a>。</p>
<h1 id="-vm-berkeley-db-java-edition-http-www-oracle-com-technetwork-database-berkeleydb-overview-index-093405-html-bdb-je-xx-usecompressedoops-bdb-je-java-permgen-32gb-xx-usecompressedoops-warning-on-compressed-oops-https-forums-oracle-com-forums-thread-jspa-messageid-10017916-">有些库比较“聪明”，会自行读取VM参数来调整自己的一些参数，例如<a href="http://www.oracle.com/technetwork/database/berkeleydb/overview/index-093405.html" target="_blank">Berkeley DB Java Edition</a>。但这些库实现得不好的时候反而会带来一些麻烦：BDB JE要求<strong>显式指定-XX:+UseCompressedOops</strong>才能有效的调整它的缓存大小。所以在用BDB JE并且Java堆+PermGen大小小于32GB的时候，请显式指定-XX:+UseCompressedOops吧。参考<a href="https://forums.oracle.com/forums/thread.jspa?messageID=10017916" target="_blank">Warning on Compressed Oops</a></h1>
<p>20、-XX:LargePageSizeInBytes=128m ？
或者是 -XX:LargePageSizeInBytes=256m ？
其实这个参数的值是多少不是问题，问题是这个参数到底有没有起作用。
或许有人读过很老的调优建议资料，例如这个：
<a href="http://java.sun.com/performance/reference/whitepapers/tuning.html#section4.2.3" target="_blank">(2005) Java Tuning White Paper - 4.2.3 Tuning Example 3: Try 256 MB pages</a>
或者是别的一些内容很老的资料。它们提到了-XX:LargePageSizeInBytes=参数。这些老资料也没说错，在Sun JDK 5里 -XX:LargePageSizeInBytes= 参数只在Solaris上有效，使用的时候没有别的参数保护。
但是，实际上这个参数在Oracle/Sun JDK 6里不配合-XX:+UseLargePages的话是不会起任何作用的。
JDK 6里的JVM的Linux版上初始化large page的地方：
C++代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>bool os::large_page_init() {  </p>
</li>
<li>if (!UseLargePages) return false;  </li>
<li></li>
<li>if (LargePageSizeInBytes) {  </li>
<li>_large_page_size = LargePageSizeInBytes;  </li>
<li>} else {  </li>
<li>// ...  </li>
<li>}  </li>
<li></li>
<li>// ...  </li>
<li></li>
<li>// Large page support is available on 2.6 or newer kernel, some vendors  </li>
<li>// (e.g. Redhat) have backported it to their 2.4 based distributions.  </li>
<li>// We optimistically assume the support is available. If later it turns out  </li>
<li>// not true, VM will automatically switch to use regular page size.  </li>
<li>return true;  </li>
<li><p>}<br>bool os::large_page_init() { if (!UseLargePages) return false; if (LargePageSizeInBytes) { _large_page_size = LargePageSizeInBytes; } else { // ... } // ... // Large page support is available on 2.6 or newer kernel, some vendors // (e.g. Redhat) have backported it to their 2.4 based distributions. // We optimistically assume the support is available. If later it turns out // not true, VM will automatically switch to use regular page size. return true; }
看到了么，没有将UseLargePages设置为true的话，LargePageSizeInBytes根本没机会被用上。
对应的，Solaris版：
C++代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>bool os::large_page_init() {  </p>
</li>
<li>if (!UseLargePages) {  </li>
<li>UseISM = false;  </li>
<li>UseMPSS = false;  </li>
<li>return false;  </li>
<li>}  </li>
<li></li>
<li>// ...  </li>
<li><p>}<br>bool os::large_page_init() { if (!UseLargePages) { UseISM = false; UseMPSS = false; return false; } // ... }
以及Windows版：
C++代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>bool os::large_page_init() {  </p>
</li>
<li>if (!UseLargePages) return false;  </li>
<li></li>
<li>// ...  </li>
<li>}<br>bool os::large_page_init() { if (!UseLargePages) return false; // ... }<h1 id="-oracle-sun-jdk-6-oracle-jdk-7-xx-largepagesizeinbytes-xx-uselargepages-large-pages-regular-pages-">在Oracle/Sun JDK 6以及Oracle JDK 7上要使用 -XX:LargePageSizeInBytes= 的话，请务必也设置上 -XX:+UseLargePages 。使用这两个参数之前最好先确认操作系统是否真的只是large pages；操作系统不支持的话，设置这两个参数也没作用，只会退回到使用regular pages而已。</h1>
21、-XX:+AlwaysPreTouch
会把commit的空间跑循环赋值为0以达到“pretouch”的目的。开这个参数会增加VM初始化时的开销，但后面涉及虚拟内存的开销可能降低。<h1 id="-http-hllvm-group-iteye-com-group-topic-28839-209144-http-hllvm-group-iteye-com-group-topic-28839-209144-">在另一个讨论帖里有讲该参数：<a href="http://hllvm.group.iteye.com/group/topic/28839#209144" target="_blank"><a href="http://hllvm.group.iteye.com/group/topic/28839/#209144">http://hllvm.group.iteye.com/group/topic/28839/#209144</a></a></h1>
<h1 id="22-xx-usetlab-runtime-freememory-">22、-XX:+UseTLAB 与 Runtime.freeMemory()</h1>
23、-XX:+ParallelRefProcEnabled
这个功能可以加速reference processing，但在JDK6u25和6u26上不要使用，有bug：<h1 id="-bug-id-7028845-cms-6984287-broke-parallel-reference-processing-in-cms-http-bugs-sun-com-bugdatabase-view_bug-do-bug_id-7028845-"><a href="http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=7028845" target="_blank">Bug ID 7028845: CMS: 6984287 broke parallel reference processing in CMS</a></h1>
24、-XX:+UseConcMarkSweepGC 与 -XX:+UseAdaptiveSizePolicy
这两个选项在现有的Oracle/Sun JDK 6和Oracle JDK 7上都不要搭配在一起使用——CMS用的adaptive size policy还没实现完，用的话可能会crash。
目前HotSpot VM上只有ParallelScavenge系的GC才可以配合-XX:+UseAdaptiveSizePolicy使用；也就是只有-XX:+UseParallelGC或者-XX:+UseParallelOldGC。<a href="http://mail.openjdk.java.net/pipermail/hotspot-gc-use/2011-November/000954.html" target="_blank">Jon Masamitsu在邮件列表上提到过</a>。<h1 id="-useadaptivesizepolicy-parallelscavenge-survivor-space-jon-masamitsu-http-mail-openjdk-java-net-pipermail-hotspot-gc-use-2012-october-001390-html-">题外话：开着UseAdaptiveSizePolicy的ParallelScavenge会动态调整各空间的大小，有可能会造成两个survivor space的大小被调整得不一样大。Jon Masamitsu在<a href="http://mail.openjdk.java.net/pipermail/hotspot-gc-use/2012-October/001390.html" target="_blank">这封邮件</a>里解释了原因。</h1>
25、-XX:+UseAdaptiveGCBoundary<h1 id="jdk-6-bug-">JDK 6里不要用这个选项，有bug。</h1>
26、-XX:HeapDumpPath 与 -XX:+HeapDumpBeforeFullGC、-XX:+HeapDumpAfterFullGC、-XX:+HeapDumpOnOutOfMemoryError
-XX:+HeapDumpBeforeFullGC、-XX:+HeapDumpAfterFullGC、-XX:+HeapDumpOnOutOfMemoryError 这几个参数可以在不同条件下做出HPROF格式的heap dump。但很多人都会疑惑：做出来的heap dump存到哪里去了？
如果不想费神去摸索到底各种环境被配置成什么样、“working directory”到底在哪里的话，就在VM启动参数里加上 <strong>-XX:HeapDumpPath=一个绝对路径</strong> 吧。这样，自动做出的heap dump就会被存到指定的目录里去。<h1 id="-working-directory-">当然相对路径也支持，不过用了相对路径就又得弄清楚当前的“working directory”在哪里了。</h1>
26、UseDepthFirstScavengeOrder
以前有过这样一个参数可以设置young gen遍历对象图的顺序，深度还是广度优先不过高于JDK 6 update 22就没用了，ParallelScavenge变为只用深度优先而不用广度优先。
具体的changeset在这里：<a href="http://hg.openjdk.java.net/hsx/hotspot-main/hotspot/rev/9d7a8ab3736b" target="_blank"><a href="http://hg.openjdk.java.net/hsx/hotspot-main/hotspot/rev/9d7a8ab3736b">http://hg.openjdk.java.net/hsx/hotspot-main/hotspot/rev/9d7a8ab3736b</a></a>
HotSpot VM里的arguments.cpp文件里有obsolete_jvm_flags数组，那边声明的参数都要留意是已经没用的。
（下文待续～）
<img src="" alt="Spinner"> <a href="http://learnworld.iteye.com/" target="_blank"><img src="&quot;learnworld的博客: 一路远行&quot;" alt="learnworld的博客"></a> <a href="http://learnworld.iteye.com/" title="learnworld" target="_blank">learnworld</a> 2011-10-23</li>
</ol>
<p>好贴，坐等下文。
<img src="" alt="Spinner"> <a href="http://jolestar.iteye.com/" target="_blank"><img src="&quot;jolestar的博客: 午夜咖啡&quot;" alt="jolestar的博客"></a> <a href="http://jolestar.iteye.com/" title="jolestar" target="_blank">jolestar</a> 2011-10-23</p>
<p>lz不厚道，说了个半句话就闪了。太吊胃口了。
<img src="" alt="Spinner"> <a href="http://boy00fly.iteye.com/" target="_blank"><img src="&quot;boy00fly的博客: 石头边的老牛&quot;" alt="boy00fly的博客"></a> <a href="http://boy00fly.iteye.com/" title="boy00fly" target="_blank">boy00fly</a> 2011-10-24</p>
<p>jolestar 写道</p>
<p>lz不厚道，说了个半句话就闪了。太吊胃口了。
哈哈，确实吊胃口。。下文呢？
<img src="" alt="Spinner"> <a href="http://icanfly.iteye.com/" target="_blank"><img src="&quot;icanfly的博客: 老罗宣言&quot;" alt="icanfly的博客"></a> <a href="http://icanfly.iteye.com/" title="icanfly" target="_blank">icanfly</a> 2011-10-24</p>
<p>好文。<img src="" alt="">
<img src="" alt="Spinner"> <a href="http://liuyes.iteye.com/" target="_blank"><img src="&quot;liuyes的博客: &quot;" alt="liuyes的博客"></a> <a href="http://liuyes.iteye.com/" title="liuyes" target="_blank">liuyes</a> 2011-10-24</p>
<p>楼主人呢？这发文的也有坑<img src="" alt="">
<img src="" alt="Spinner"> <a href="http://khotyn.iteye.com/" target="_blank"><img src="&quot;khotyn的博客: 码工作坊&quot;" alt="khotyn的博客"></a> <a href="http://khotyn.iteye.com/" title="khotyn" target="_blank">khotyn</a> 2011-10-24</p>
<p>坐等R大把坑填上～～
<img src="" alt="Spinner"> <a href="http://furturestrategist.iteye.com/" target="_blank"><img src="&quot;程序新手的博客: HappyProgramme&quot;" alt="程序新手的博客"></a> <a href="http://furturestrategist.iteye.com/" title="程序新手" target="_blank">程序新手</a> 2011-10-24</p>
<p>内容受益、风格简洁，期待下文
  另外大胆猜测从日志中获取的信息是部分FULL GC由System.gc()引发的
  Full GC (System)
<img src="" alt="Spinner"> <a href="http://furturestrategist.iteye.com/" target="_blank"><img src="&quot;程序新手的博客: HappyProgramme&quot;" alt="程序新手的博客"></a> <a href="http://furturestrategist.iteye.com/" title="程序新手" target="_blank">程序新手</a> 2011-10-25</p>
<p>又受益了 <img src="" alt=""> ..想了解大大收集这些知识点的方法~
<img src="" alt="Spinner"> <a href="http://hittyt.iteye.com/" target="_blank"><img src="&quot;hittyt的博客: 笨小孩&quot;" alt="hittyt的博客"></a> <a href="http://hittyt.iteye.com/" title="hittyt" target="_blank">hittyt</a> 2011-11-08</p>
<p>本人的java环境如下：
Command line代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>java -version  </li>
<li>java version &quot;1.6.0_18&quot;  </li>
<li>Java(TM) SE Runtime Environment (build 1.6.0_18-b07)  </li>
<li><p>Java HotSpot(TM) 64-Bit Server VM (build 16.0-b13, mixed mode)<br>java -version java version &quot;1.6.0_18&quot; Java(TM) SE Runtime Environment (build 1.6.0_18-b07) Java HotSpot(TM) 64-Bit Server VM (build 16.0-b13, mixed mode)
但使用PrintFlagsFinal时得到的输出却是下面的结果：
Command line代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>java -XX:+PrintFlagsFinal  </p>
</li>
<li>Unrecognized VM option &#39;+PrintFlagsFinal&#39;  </li>
<li>Could not create the Java virtual machine.<br>java -XX:+PrintFlagsFinal Unrecognized VM option &#39;+PrintFlagsFinal&#39; Could not create the Java virtual machine.
求LZ解答问题在哪里呢？
<img src="" alt="Spinner"></li>
</ol>
<p><img src="" alt=""> <a href="http://hllvm.group.iteye.com/group/topic/27945/post/new" target="_blank">发表回复</a></p>
<p>« 上一页 1 <a href="http://hllvm.group.iteye.com/group/topic/27945?page=2" target="_blank">2</a> <a href="http://hllvm.group.iteye.com/group/topic/27945?page=3" target="_blank">3</a> <a href="http://hllvm.group.iteye.com/group/topic/27945?page=2" target="_blank">下一页 »</a></p>
<p><a href="http://hllvm.group.iteye.com/" target="_blank">&gt;&gt;返回群组首页</a></p>
<p><a href="http://hllvm.group.iteye.com/" target="_blank"><img src="&quot;高级语言虚拟机: 关注各种高级语言虚拟机（high-level language virtual machine，HLL VM）的设计与实现，泛化至各种高级语言的运行时的设计与实现。讨论范围包括JVM、CLI、Parrot等当前流行的VM平台，也包括Python、Ruby、JavaScript、Lua、Perl、Forth、Smalltalk等众多语言的引擎，还有历史上有影响的各种高级语言虚拟机，如SECD等。&quot;" alt="高级语言虚拟机群组"></a></p>
<h3 id="-">相关讨论</h3>
<ul>
<li><a href="http://www.iteye.com/topic/212967" target="_blank">一次Java垃圾收集调优实战</a></li>
<li><a href="http://www.iteye.com/topic/894148" target="_blank">HotSpot VM 内存堆的两个Servivor区</a></li>
<li><a href="http://www.iteye.com/topic/802638" target="_blank">JVM内存管理：深入垃圾收集器与内存分配策略</a></li>
<li><a href="http://www.iteye.com/topic/473874" target="_blank">CMS gc实践总结</a></li>
<li><a href="http://www.iteye.com/topic/756538" target="_blank">优化JVM参数提高eclipse运行速度</a></li>
<li><a href="http://www.iteye.com/" target="_blank">首页</a></li>
<li><a href="http://www.iteye.com/news" target="_blank">资讯</a></li>
<li><a href="http://www.iteye.com/magazines" target="_blank">精华</a></li>
<li><a href="http://www.iteye.com/forums" target="_blank">论坛</a></li>
<li><a href="http://www.iteye.com/ask" target="_blank">问答</a></li>
<li><a href="http://www.iteye.com/blogs" target="_blank">博客</a></li>
<li><a href="http://www.iteye.com/blogs/subjects" target="_blank">专栏</a></li>
<li><a href="http://www.iteye.com/groups" target="_blank">群组</a></li>
<li><a href="http://job.iteye.com/iteye" target="_blank">招聘</a></li>
<li><a href="http://www.iteye.com/search" target="_blank">搜索</a></li>
<li><a href="http://hllvm.group.iteye.com/index/service" target="_blank">广告服务</a></li>
<li><a href="http://webmaster.iteye.com/" target="_blank">ITeye黑板报</a></li>
<li><a href="http://hllvm.group.iteye.com/index/contactus" target="_blank">联系我们</a></li>
<li><a href="http://hllvm.group.iteye.com/index/friend_links" target="_blank">友情链接</a></li>
</ul>
<p>© 2003-2012 ITeye.com. [ <a href="http://www.miibeian.gov.cn/" target="_blank">京ICP证110151号</a> 京公网安备110105010620 ]
百联优力(北京)投资有限公司 版权所有 <img src="http://stat.iteye.com/?url=http%3A%2F%2Fhllvm.group.iteye.com%2Fgroup%2Ftopic%2F27945&amp;referrer=http%3A%2F%2Fhllvm.group.iteye.com%2F&amp;user_id=" alt=""></p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/JVM/">JVM</a></li></span></span> | <span class="tags">Tagged <a href="/tags/JVM/" class="label label-primary">JVM</a><a href="/tags/Java&J2EE/" class="label label-success">Java&J2EE</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:42"datetime="2014-03-07 09:54:42"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-JVM--JVM调优的-标准参数-的各种陷阱/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-JVM--JVM调优的-标准参数-的各种陷阱" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--JVM调优总结（四）-垃圾回收面临的问题/">JVM调优总结（四）</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:42.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--JVM调优总结（四）-垃圾回收面临的问题/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="jvm-">JVM调优总结（四）-垃圾回收面临的问题</h1>
<p>如何区分垃圾</p>
<pre><code>上面说到的“引用计数”法，通过统计控制生成对象和删除对象时的引用数来判断。垃圾回收程序收集计数为0的对象即可。但是这种方法无法解决循环引用。所以，后来实现的垃圾判断算法中，都是从程序运行的根节点出发，遍历整个对象引用，查找存活的对象。那么在这种方式的实现中，**垃圾回收从哪儿开始的呢**？即，从哪儿开始查找哪些对象是正在被当前系统使用的。上面分析的堆和栈的区别，其中栈是真正进行程序执行地方，所以要获取哪些对象正在被使用，则需要从Java栈开始。同时，一个栈是与一个线程对应的，因此，如果有多个线程的话，则必须对这些线程对应的所有的栈进行检查。
</code></pre><p><img src="" alt=""></p>
<pre><code>同时，除了栈外，还有系统运行时的寄存器等，也是存储程序运行数据的。这样，以栈或寄存器中的引用为起点，我们可以找到堆中的对象，又从这些对象找到对堆中其他对象的引用，这种引用逐步扩展，最终以null引用或者基本类型结束，这样就形成了一颗以Java栈中引用所对应的对象为根节点的一颗对象树，如果栈中有多个引用，则最终会形成多颗对象树。在这些对象树上的对象，都是当前系统运行所需要的对象，不能被垃圾回收。而其他剩余对象，则可以视为无法被引用到的对象，可以被当做垃圾进行回收。
</code></pre><p>因此，<strong>垃圾回收的起点是一些根对象（java栈, 静态变量, 寄存器...）</strong>。而最简单的Java栈就是Java程序执行的main函数。这种回收方式，也是上面提到的“标记-清除”的回收方式</p>
<h2 id="-">如何处理碎片</h2>
<p>   由于不同Java对象存活时间是不一定的，因此，在程序运行一段时间以后，如果不进行内存整理，就会出现零散的内存碎片。碎片最直接的问题就是会导致无法分配大块的内存空间，以及程序运行效率降低。所以，在上面提到的基本垃圾回收算法中，“复制”方式和“标记-整理”方式，都可以解决碎片的问题。</p>
<h2 id="-">如何解决同时存在的对象创建和对象回收问题</h2>
<pre><code>垃圾回收线程是回收内存的，而程序运行线程则是消耗（或分配）内存的，**一个回收内存，一个分配内存**，从这点看，两者是矛盾的。因此，在现有的垃圾回收方式中，要进行垃圾回收前，一般都需要暂停整个应用（即：暂停内存的分配），然后进行垃圾回收，回收完成后再继续应用。这种实现方式是最直接，而且最有效的解决二者矛盾的方式。
</code></pre><p>但是<strong>这种方式有一个很明显的弊端，就是当堆空间持续增大时，垃圾回收的时间也将会相应的持续增大，对应应用暂停的时间也会相应的增大</strong>。一些对相应时间要求很高的应用，比如最大暂停时间要求是几百毫秒，那么当堆空间大于几个G时，就很有可能超过这个限制，在这种情况下，垃圾回收将会成为系统运行的一个瓶颈。为解决这种矛盾，有了<strong>并发垃圾回收算法</strong>，使用这种算法，垃圾回收线程与程序运行线程同时运行。在这种方式下，解决了暂停的问题，但是因为需要在新生成对象的同时又要回收对象，算法复杂性会大大增加，系统的处理能力也会相应降低，同时，“碎片”问题将会比较难解决。</p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/JVM/">JVM</a></li></span></span> | <span class="tags">Tagged <a href="/tags/JVM/" class="label label-primary">JVM</a><a href="/tags/Java&J2EE/" class="label label-success">Java&J2EE</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:42"datetime="2014-03-07 09:54:42"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-JVM--JVM调优总结（四）-垃圾回收面临的问题/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-JVM--JVM调优总结（四）-垃圾回收面临的问题" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--JVM调优总结（一）--一些概念-高级语言虚拟机/">JVM调优总结（一）</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:42.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--JVM调优总结（一）--一些概念-高级语言虚拟机/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="jvm-">JVM调优总结（一）-- 一些概念 - 高级语言虚拟机</h1>
<p><a href="http://hllvm.group.iteye.com/login" title="登录" target="_blank">您还未登录 !</a> <a href="http://hllvm.group.iteye.com/login" target="_blank">登录</a> <a href="http://hllvm.group.iteye.com/signup" target="_blank">注册</a></p>
<p><a href="http://www.iteye.com/" target="_blank"><img src="&quot;ITeye-最棒的软件开发交流社区&quot;" alt="ITeye3.0"></a></p>
<p><a href=""></a></p>
<p><a href="http://www.iteye.com/groups" target="_blank">群组首页</a> → <a href="http://hllvm.group.iteye.com/groups/category/language" target="_blank">编程语言</a> → <a href="http://hllvm.group.iteye.com/" target="_blank">高级语言虚拟机</a> → <a href="http://hllvm.group.iteye.com/group/wiki" target="_blank">知识库</a> → <a href="http://hllvm.group.iteye.com/group/wiki?category_id=301" target="_blank">JVM调优</a> → <a href="">JVM调优总结（一）-- 一些概念</a>
原创作者: <a href="http://www.javaeye.com/topic/518623" target="_blank">和你在一起</a>   阅读:8621次   评论:14条   更新时间:2011-05-26    </p>
<h2 id="-"><strong>数据类型</strong></h2>
<pre><code>Java虚拟机中，数据类型可以分为两类：**基本类型**和**引用类型**。基本类型的变量保存原始值，即：他代表的值就是数值本身；而引用类型的变量保存引用值。“引用值”代表了某个对象的引用，而不是对象本身，对象本身存放在这个引用值所表示的地址的位置。
</code></pre><p>基本类型包括：byte,short,int,long,char,float,double,Boolean,returnAddress</p>
<p>引用类型包括：<strong>类类型</strong>，<strong>接口类型</strong>和<strong>数组</strong>。</p>
<h2 id="-"><strong>堆与栈</strong></h2>
<pre><code>堆和栈是程序运行的关键，很有必要把他们的关系说清楚。
</code></pre><p>   <img src="" alt=""></p>
<h3 id="-"><strong>栈是运行时的单位，而堆是存储的单位</strong>。</h3>
<pre><code>栈解决程序的运行问题，即程序如何执行，或者说如何处理数据；堆解决的是数据存储的问题，即数据怎么放、放在哪儿。

在Java中一个线程就会相应有一个线程栈与之对应，这点很容易理解，因为不同的线程执行逻辑有所不同，因此需要一个独立的线程栈。而堆则是所有线程共享的。栈因为是运行单位，因此里面存储的信息都是跟当前线程（或程序）相关信息的。包括局部变量、程序运行状态、方法返回值等等；而堆只负责存储对象信息。
</code></pre><h3 id="-"><strong>    为什么要把堆和栈区分出来呢？栈中不是也可以存储数据吗</strong>？</h3>
<pre><code>第一，从软件设计的角度看，栈代表了处理逻辑，而堆代表了数据。这样分开，使得处理逻辑更为清晰。分而治之的思想。这种隔离、模块化的思想在软件设计的方方面面都有体现。

第二，堆与栈的分离，使得堆中的内容可以被多个栈共享（也可以理解为多个线程访问同一个对象）。这种共享的收益是很多的。一方面这种共享提供了一种有效的数据交互方式(如：共享内存)，另一方面，堆中的共享常量和缓存可以被所有栈访问，节省了空间。

第三，栈因为运行时的需要，比如保存系统运行的上下文，需要进行地址段的划分。由于栈只能向上增长，因此就会限制住栈存储内容的能力。而堆不同，堆中的对象是可以根据需要动态增长的，因此栈和堆的拆分，使得动态增长成为可能，相应栈中只需记录堆中的一个地址即可。

第四，面向对象就是堆和栈的完美结合。其实，面向对象方式的程序与以前结构化的程序在执行上没有任何区别。但是，面向对象的引入，使得对待问题的思考方式发生了改变，而更接近于自然方式的思考。当我们把对象拆开，你会发现，对象的属性其实就是数据，存放在堆中；而对象的行为（方法），就是运行逻辑，放在栈中。我们在编写对象的时候，其实即编写了数据结构，也编写的处理数据的逻辑。不得不承认，面向对象的设计，确实很美。
</code></pre><h3 id="-java-main-"><strong>在Java中，Main函数就是栈的起始点，也是程序的起始点</strong>。</h3>
<pre><code>程序要运行总是有一个起点的。同C语言一样，java中的Main就是那个起点。无论什么java程序，找到main就找到了程序执行的入口：）
</code></pre><h3 id="-"><strong>堆中存什么？栈中存什么</strong>？</h3>
<pre><code>堆中存的是对象。栈中存的是基本数据类型和堆中对象的引用。一个对象的大小是不可估计的，或者说是可以动态变化的，但是在栈中，一个对象只对应了一个4btye的引用（堆栈分离的好处：））。

为什么不把基本类型放堆中呢？因为其占用的空间一般是1~8个字节——需要空间比较少，而且因为是基本类型，所以不会出现动态增长的情况——长度固定，因此栈中存储就够了，如果把他存在堆中是没有什么意义的（还会浪费空间，后面说明）。可以这么说，基本类型和对象的引用都是存放在栈中，而且都是几个字节的一个数，因此在程序运行时，他们的处理方式是统一的。但是基本类型、对象引用和对象本身就有所区别了，因为一个是栈中的数据一个是堆中的数据。最常见的一个问题就是，Java中参数传递时的问题。
</code></pre><h3 id="-java-"><strong>Java中的参数传递时传值呢？还是传引用</strong>？</h3>
<pre><code>要说明这个问题，先要明确两点：

     1. **不要试图与C进行类比，Java中没有指针的概念**

     2. **程序运行永远都是在栈中进行的，因而参数传递时，只存在传递基本类型和对象引用的问题**。不会直接传对象本身。

明确以上两点后。Java在方法调用传递参数时，因为没有指针，所以**它都是进行传值调用**（这点可以参考C的传值调用）。因此，很多书里面都说Java是进行传值调用，这点没有问题，而且也简化的C中复杂性。

*但是传引用的错觉是如何造成的呢？*在运行栈中，基本类型和引用的处理是一样的，都是传值，所以，如果是传引用的方法调用，也同时可以理解为“传引用值”的传值调用，即引用的处理跟基本类型是完全一样的。但是当进入被调用方法时，被传递的这个引用的值，被程序解释（或者查找）到堆中的对象，这个时候才对应到真正的对象。如果此时进行修改，修改的是引用对应的对象，而不是引用本身，即：修改的是堆中的数据。所以这个修改是可以保持的了。

对象，从某种意义上说，是由基本类型组成的。可以把一个对象看作为一棵树，对象的属性如果还是对象，则还是一颗树（即非叶子节点），基本类型则为树的叶子节点。程序参数传递时，被传递的值本身都是不能进行修改的，但是，如果这个值是一个非叶子节点（即一个对象引用），则可以修改这个节点下面的所有内容。



堆和栈中，栈是程序运行最根本的东西。程序运行可以没有堆，但是不能没有栈。而堆是为栈进行数据存储服务，说白了堆就是一块共享的内存。不过，正是因为堆和栈的分离的思想，才使得Java的垃圾回收成为可能。

 Java中，栈的大小通过-Xss来设置，当栈中存储数据比较多时，需要适当调大这个值，否则会出现java.lang.StackOverflowError异常。常见的出现这个异常的是无法返回的递归，因为此时栈中保存的信息都是方法返回的记录点。
</code></pre><p><a href="http://hllvm.group.iteye.com/group/wiki/2860-JVM" title="JVM调优总结（二）-一些概念" target="_blank">JVM调优总结（二）-一些概念</a></p>
<p>评论 共 14 条 请<a href="http://hllvm.group.iteye.com/login" target="_blank">登录</a>后发表评论 <a href=""></a></p>
<h3 id="14-yangpanwww-http-yangpanwww-iteye-com-yangpanwww-2013-05-24-10-44">14 楼 <a href="http://yangpanwww.iteye.com/" title="yangpanwww" target="_blank">yangpanwww</a> 2013-05-24 10:44</h3>
<p><img src="" alt=""> <img src="" alt=""> <img src="" alt="">   受益匪浅</p>
<h3 id="13-wangpeihu-http-wangpeihu-iteye-com-wangpeihu-2013-03-22-10-48">13 楼 <a href="http://wangpeihu.iteye.com/" title="wangpeihu" target="_blank">wangpeihu</a> 2013-03-22 10:48</h3>
<p>楼主分析的很透彻，很到位。
在这里我有2个问题想请教楼主：
引用</p>
<p>栈因为是运行单位，因此里面存储的信息都是跟当前线程（或程序）相关信息的。包括局部变量、程序运行状态、方法返回值等等
能否将这些局部变量、程序运行状态、方法返回值等放在堆里，而堆里的对象放在栈里呢？说白了，就是他俩的工作职责对调一下可以吗？
我经常看到人说，栈的运行效率较高，堆的效率较低（相对于栈而言），是否是因为这个原因，而促成了堆栈现在的功能分配呢？</p>
<h3 id="12-chancong-http-chancong-iteye-com-chancong-2013-03-21-17-42">12 楼 <a href="http://chancong.iteye.com/" title="chancong" target="_blank">chancong</a> 2013-03-21 17:42</h3>
<p>学习了，受益匪浅</p>
<h3 id="11-xwl1991-http-xwl1990-iteye-com-xwl1991-2013-02-18-10-05">11 楼 <a href="http://xwl1990.iteye.com/" title="xwl1991" target="_blank">xwl1991</a> 2013-02-18 10:05</h3>
<p>受益匪浅 非常感谢！<img src="" alt=""></p>
<h3 id="10-xiaodatao-http-xiaodatao-iteye-com-xiaodatao-2012-01-19-16-33">10 楼 <a href="http://xiaodatao.iteye.com/" title="xiaodatao" target="_blank">xiaodatao</a> 2012-01-19 16:33</h3>
<pre><code>程序运行永远都是在栈中进行的，因而参数传递时，只存在传递基本类型和对象引用的问题。不会直接传对象本身。
</code></pre><p>栈解决程序的运行问题，即程序如何执行，或者说如何处理数据；堆解决的是数据存储的问题，即数据怎么放、放在哪儿。
在Java中一个线程就会相应有一个线程栈与之对应，因为不同的线程执行逻辑有所不同，因此需要一个独立的线程栈。而堆则是所有线程共享的。栈因为是运行单位，因此里面存储的信息都是跟当前线程（或程序）相关信息的。包括局部变量、程序运行状态、方法返回值等等；而堆只负责存储对象信息。
堆和栈中，栈是程序运行最根本的东西。程序运行可以没有堆，但是不能没有栈。而堆是为栈进行数据存储服务，说白了堆就是一块共享的内存。不过，正是因为堆和栈的分离的思想，才使得Java的垃圾回收成为可能。<img src="" alt=""> <img src="" alt=""></p>
<h3 id="9-diecui1202-http-diecui1202-iteye-com-diecui1202-2012-01-05-14-16">9 楼 <a href="http://diecui1202.iteye.com/" title="diecui1202" target="_blank">diecui1202</a> 2012-01-05 14:16</h3>
<p>楼主Boolean是不是写错了？是boolean吧！</p>
<h3 id="8-bsr1983-http-bsr1983-iteye-com-bsr1983-2011-12-16-22-54">8 楼 <a href="http://bsr1983.iteye.com/" title="bsr1983" target="_blank">bsr1983</a> 2011-12-16 22:54</h3>
<p>写的很不错，赞一个！<img src="" alt=""></p>
<h3 id="7-lknh-http-chenzone-iteye-com-lknh-2011-09-22-23-46">7 楼 <a href="http://chenzone.iteye.com/" title="lknh" target="_blank">lknh</a> 2011-09-22 23:46</h3>
<p>学习了，写得很好，很详细、易懂！</p>
<h3 id="6-shaomeng95-http-shaomeng95-iteye-com-shaomeng95-2011-07-08-10-37">6 楼 <a href="http://shaomeng95.iteye.com/" title="shaomeng95" target="_blank">shaomeng95</a> 2011-07-08 10:37</h3>
<p>写的很好，通俗易懂！</p>
<h3 id="5-smalltalker-http-smalltalker-iteye-com-smalltalker-2011-05-30-13-47">5 楼 <a href="http://smalltalker.iteye.com/" title="smalltalker" target="_blank">smalltalker</a> 2011-05-30 13:47</h3>
<p>非常不错。文章讲的很透彻，和容易让人理解，看了之后有种豁然开朗的感觉。<img src="" alt=""></p>
<h3 id="4-ivin-http-ivin-iteye-com-ivin-2011-03-15-11-56">4 楼 <a href="http://ivin.iteye.com/" title="ivin" target="_blank">ivin</a> 2011-03-15 11:56</h3>
<p>不错啊，非常透彻，感谢感谢！</p>
<h3 id="3-suxianchun-http-suxianchun-iteye-com-suxianchun-2011-01-13-17-25">3 楼 <a href="http://suxianchun.iteye.com/" title="suxianchun" target="_blank">suxianchun</a> 2011-01-13 17:25</h3>
<p>gauge</p>
<h3 id="2-suxianchun-http-suxianchun-iteye-com-suxianchun-2011-01-13-17-24">2 楼 <a href="http://suxianchun.iteye.com/" title="suxianchun" target="_blank">suxianchun</a> 2011-01-13 17:24</h3>
<p><img src="" alt=""></p>
<h3 id="1-suxianchun-http-suxianchun-iteye-com-suxianchun-2011-01-13-17-24">1 楼 <a href="http://suxianchun.iteye.com/" title="suxianchun" target="_blank">suxianchun</a> 2011-01-13 17:24</h3>
<p><img src="" alt=""></p>
<h3 id="-">发表评论</h3>
<p><a href="http://hllvm.group.iteye.com/login" target="_blank"><img src="" alt=""> 您还没有登录,请您登录后再发表评论</a></p>
<p><a href="http://hllvm.group.iteye.com/group/wiki/new" target="_blank"><img src="" alt="New-page"></a></p>
<h3 id="-">文章信息</h3>
<p><a href="http://hllvm.group.iteye.com/group/wiki/" target="_blank">知识库: 高级语言虚拟机</a></p>
<ul>
<li>由<a href="http://kiral.iteye.com/" title="fantasy" target="_blank">fantasy</a>在2010-11-08创建</li>
<li><p>由<a href="http://kiral.iteye.com/" title="fantasy" target="_blank">fantasy</a>在2011-05-26更新</p>
<h3 id="-">相关新闻</h3>
</li>
<li><p><a href="http://hllvm.group.iteye.com/news/4407" target="_blank">ruby内存泄漏的罪魁祸首 - 幽灵指针</a></p>
</li>
<li><a href="http://hllvm.group.iteye.com/news/16601" target="_blank">Azul Systems将要开源Managed Runtime Initiative中的重要技术</a></li>
<li><a href="http://hllvm.group.iteye.com/news/8909" target="_blank">离开Java，寻找更佳语言的10大理由</a></li>
</ul>
<h3 id="-">相关讨论</h3>
<ul>
<li><a href="http://hllvm.group.iteye.com/topic/941682" target="_blank">Java中堆内存与栈内存分配浅析</a></li>
<li><a href="http://hllvm.group.iteye.com/topic/634530" target="_blank">Java堆.栈和常量池 笔记</a></li>
<li><a href="http://hllvm.group.iteye.com/topic/821872" target="_blank">慢慢琢磨JVM——恭喜JavaEye重新开张</a></li>
<li><a href="http://hllvm.group.iteye.com/topic/1097896" target="_blank">Java堆、栈和常量池详解</a></li>
<li><p><a href="http://hllvm.group.iteye.com/topic/4189" target="_blank">一个绝对害了不少人的Java技术问题！</a></p>
<h3 id="-">相关博客</h3>
</li>
<li><p><a href="http://hy90171.iteye.com/blog/1879242" target="_blank">JVM基础：深入学习JVM堆与JVM栈</a></p>
</li>
<li><a href="http://tangchenglin.iteye.com/blog/701681" target="_blank">JVM基础概念总结：数据类型、堆与栈</a></li>
<li><a href="http://jiaozhiguang-126-com.iteye.com/blog/1701015" target="_blank">JVM调优总结（一）一些概念</a></li>
<li><a href="http://pengjiaheng.iteye.com/blog/518623" target="_blank">JVM调优总结（一）-- 一些概念</a></li>
<li><a href="http://bobostudio.iteye.com/blog/602519" target="_blank">JVM 概念总结 数据类型、堆与栈</a></li>
<li><a href="http://www.iteye.com/" target="_blank">首页</a></li>
<li><a href="http://www.iteye.com/news" target="_blank">资讯</a></li>
<li><a href="http://www.iteye.com/magazines" target="_blank">精华</a></li>
<li><a href="http://www.iteye.com/forums" target="_blank">论坛</a></li>
<li><a href="http://www.iteye.com/ask" target="_blank">问答</a></li>
<li><a href="http://www.iteye.com/blogs" target="_blank">博客</a></li>
<li><a href="http://www.iteye.com/blogs/subjects" target="_blank">专栏</a></li>
<li><a href="http://www.iteye.com/groups" target="_blank">群组</a></li>
<li><a href="http://job.iteye.com/iteye" target="_blank">招聘</a></li>
<li><a href="http://www.iteye.com/search" target="_blank">搜索</a></li>
<li><a href="http://hllvm.group.iteye.com/index/service" target="_blank">广告服务</a></li>
<li><a href="http://webmaster.iteye.com/" target="_blank">ITeye黑板报</a></li>
<li><a href="http://hllvm.group.iteye.com/index/contactus" target="_blank">联系我们</a></li>
<li><a href="http://hllvm.group.iteye.com/index/friend_links" target="_blank">友情链接</a></li>
</ul>
<p>© 2003-2012 ITeye.com. [ <a href="http://www.miibeian.gov.cn/" target="_blank">京ICP证110151号</a> 京公网安备110105010620 ]
百联优力(北京)投资有限公司 版权所有 <img src="http://stat.iteye.com/?url=http%3A%2F%2Fhllvm.group.iteye.com%2Fgroup%2Fwiki%2F2858-JVM&amp;referrer=&amp;user_id=" alt=""></p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/JVM/">JVM</a></li></span></span> | <span class="tags">Tagged <a href="/tags/JVM/" class="label label-primary">JVM</a><a href="/tags/Java&J2EE/" class="label label-success">Java&J2EE</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:42"datetime="2014-03-07 09:54:42"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-JVM--JVM调优总结（一）--一些概念-高级语言虚拟机/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-JVM--JVM调优总结（一）--一些概念-高级语言虚拟机" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-NIO--JAVANIO总结/">JAVA NIO总结</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:41.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-NIO--JAVANIO总结/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="java-nio-">JAVA NIO总结</h1>
<p>（一）—基本概念</p>
<h2 id="1-">1、输入/输出：概念性描述</h2>
<h3 id="-1-1-i-o-"><a href=""></a>1.1） I/O简介</h3>
<p>I/O  或者输入/输出指的是计算机与外部世界或者一个程序与计算机的其余部分的之间的接口。它对于任何计算机系统都非常关键，因而所有 I/O 的主体实际上是内置在操作系统中的。单独的程序一般是让系统为它们完成大部分的工作。</p>
<p>在 Java 编程中，直到最近一直使用<strong>流</strong>的方式完成 I/O。所有 I/O 都被视为单个的字节的移动，通过一个称为 Stream 的对象一次移动一个字节。流 I/O 用于与外部世界接触。它也在内部使用，用于将对象转换为字节，然后再转换回对象。NIO 与原来的 I/O 有同样的作用和目的，但是它使用不同的方式? <strong>块 I/O</strong>。正如您将在本教程中学到的，块 I/O 的效率可以比流 I/O 高许多。</p>
<h3 id="-1-2-nio-"><a href=""></a>1.2）为什么要使用NIO？</h3>
<p>NIO 的创建目的是为了让 Java 程序员可以实现高速 I/O 而无需编写自定义的本机代码。NIO 将最耗时的 I/O 操作(即填充和提取缓冲区)转移回操作系统，因而可以极大地提高速度。</p>
<h3 id="-1-3-"><a href=""></a>1.3）流与块的比较</h3>
<p>原来的 I/O 库(在 </p>
<p>java.io./*
中) 与 NIO 最重要的区别是数据打包和传输的方式。正如前面提到的，原来的 I/O 以流的方式处理数据，而 NIO 以块的方式处理数据。</p>
<p><strong>面向流*</strong> *的 I/O 系统一次一个字节地处理数据。一个输入流产生一个字节的数据，一个输出流消费一个字节的数据。为流式数据创建过滤器非常容易。链接几个过滤器，以便每个过滤器只负责单个复杂处理机制的一部分，这样也是相对简单的。不利的一面是，面向流的 I/O 通常相当慢。</p>
<p>一个 <strong>面向块*</strong> *的 I/O 系统以块的形式处理数据。每一个操作都在一步中产生或者消费一个数据块。按块处理数据比按(流式的)字节处理数据要快得多。但是面向块的 I/O 缺少一些面向流的 I/O 所具有的优雅性和简单性。</p>
<h3 id="-1-4-io"><a href=""></a>1.4）集成的IO</h3>
<p>在 JDK 1.4 中原来的 I/O 包和 NIO 已经很好地集成了。 </p>
<p>java.io./*
 已经以 NIO 为基础重新实现了，所以现在它可以利用 NIO 的一些特性。例如， </p>
<p>java.io./*
 包中的一些类包含以块的形式读写数据的方法，这使得即使在更面向流的系统中，处理速度也会更快。</p>
<p>也可以用 NIO 库实现标准 I/O 功能。例如，可以容易地使用块 I/O 一次一个字节地移动数据。但是正如您会看到的，NIO 还提供了原 I/O 包中所没有的许多好处。</p>
<h2 id="-2-"><a href=""></a>2、通道和缓冲区</h2>
<h3 id="-2-1-"><a href=""></a>2.1）概述</h3>
<p>通道 
和 </p>
<p>缓冲区 
是 NIO 中的核心对象，几乎在每一个 I/O 操作中都要使用它们。</p>
<p>通道是对原 I/O 包中的流的模拟。到任何目的地(或来自任何地方)的所有数据都必须通过一个 Channel 对象。一个 Buffer 实质上是一个容器对象。发送给一个通道的所有对象都必须首先放到缓冲区中；同样地，从通道中读取的任何数据都要读到缓冲区中。</p>
<p>在本节中，您会了解到 NIO 中通道和缓冲区是如何工作的。</p>
<h3 id="-2-2-"><a href=""></a>2.2）什么是缓冲区</h3>
<p>Buffer
 是一个对象， 它包含一些要写入或者刚读出的数据。 在 NIO 中加入 </p>
<p>Buffer
 对象，体现了新库与原 I/O 的一个重要区别。在面向流的 I/O 中，您将数据直接写入或者将数据直接读到 </p>
<p>Stream
 对象中。</p>
<p>在 NIO 库中，所有数据都是用缓冲区处理的。在读取数据时，它是直接读到缓冲区中的。在写入数据时，它是写入到缓冲区中的。任何时候访问 NIO 中的数据，您都是将它放到缓冲区中。</p>
<p>缓冲区实质上是一个数组。通常它是一个字节数组，但是也可以使用其他种类的数组。但是一个缓冲区不 <em>仅仅 </em>是一个数组。缓冲区提供了对数据的结构化访问，而且还可以跟踪系统的读/写进程。</p>
<h3 id="-2-3-"><a href=""></a>2.3）缓冲区类型</h3>
<p>最常用的缓冲区类型是 </p>
<p>ByteBuffer
。一个 </p>
<p>ByteBuffer
 可以在其底层字节数组上进行 get/set 操作(即字节的获取和设置)。</p>
<p>ByteBuffer
 不是 NIO 中唯一的缓冲区类型。事实上，对于每一种基本 Java 类型都有一种缓冲区类型：</p>
<ul>
<li>ByteBuffer</li>
<li>CharBuffer</li>
<li>ShortBuffer</li>
<li>IntBuffer</li>
<li>LongBuffer</li>
<li>FloatBuffer</li>
<li>DoubleBuffer</li>
</ul>
<p>每一个 </p>
<p>Buffer
 类都是 </p>
<p>Buffer
 接口的一个实例。 除了 </p>
<p>ByteBuffer
，每一个 Buffer 类都有完全一样的操作，只是它们所处理的数据类型不一样。因为大多数标准 I/O 操作都使用 </p>
<p>ByteBuffer
，所以它具有所有共享的缓冲区操作以及一些特有的操作。</p>
<p>现在您可以花一点时间运行 UseFloatBuffer.java，它包含了类型化的缓冲区的一个应用例子。</p>
<h3 id="-2-4-"><a href=""></a>2.4）什么是通道</h3>
<p>Channel
是一个对象，可以通过它读取和写入数据。拿 NIO 与原来的 I/O 做个比较，通道就像是流。</p>
<p>正如前面提到的，所有数据都通过 </p>
<p>Buffer
 对象来处理。您永远不会将字节直接写入通道中，相反，您是将数据写入包含一个或者多个字节的缓冲区。同样，您不会直接从通道中读取字节，而是将数据从通道读入缓冲区，再从缓冲区获取这个字节。</p>
<h3 id="-2-5-"><a href=""></a>2.5）通道类型</h3>
<p>通道与流的不同之处在于通道是双向的。而流只是在一个方向上移动(一个流必须是 </p>
<p>InputStream
 或者 </p>
<p>OutputStream
 的子类)， 而 </p>
<p>通道 
可以用于读、写或者同时用于读写。因为它们是双向的，所以通道可以比流更好地反映底层操作系统的真实情况。特别是在 UNIX 模型中，底层操作系统通道是双向的。</p>
<h2 id="-3-nio-"><a href=""></a>3、从理论到实践：NIO的读和写</h2>
<h3 id="-3-1-"><a href=""></a>3.1）概述</h3>
<p>读和写是 I/O 的基本过程。从一个通道中读取很简单：只需创建一个缓冲区，然后让通道将数据读到这个缓冲区中。写入也相当简单：创建一个缓冲区，用数据填充它，然后让通道用这些数据来执行写入操作。</p>
<p>在本节中，我们将学习有关在 Java 程序中读取和写入数据的一些知识。我们将回顾 NIO 的主要组件(缓冲区、通道和一些相关的方法)，看看它们是如何交互以进行读写的。在接下来的几节中，我们将更详细地分析这其中的每个组件以及其交互。<strong>所有例子代码下载请点击<a href="http://www.ibm.com/developerworks/cn/education/java/j-nio/nio-src.zip" target="_blank">例子代码</a>。</strong></p>
<h3 id="-3-2-"><a href=""></a>3.2）从文件中读取</h3>
<p>在我们第一个练习中，我们将从一个文件中读取一些数据。如果使用原来的 I/O，那么我们只需创建一个 </p>
<p>FileInputStream
 并从它那里读取。而在 NIO 中，情况稍有不同：我们首先从 </p>
<p>FileInputStream
 获取一个 </p>
<p>FileInputStream
 对象，然后使用这个通道来读取数据。</p>
<p>在 NIO 系统中，任何时候执行一个读操作，您都是从通道中读取，但是您<strong>不是直接*</strong> *从通道读取。因为所有数据最终都驻留在缓冲区中，所以您是从通道读到缓冲区中。</p>
<p>因此读取文件涉及三个步骤：(1) 从 </p>
<p>FileInputStream
 获取 </p>
<p>Channel
，(2) 创建 </p>
<p>Buffer
，(3) 将数据从 </p>
<p>Channel
 读到 </p>
<p>Buffer 
中。现在，让我们看一下这个过程。</p>
<h3 id="-3-3-"><a href=""></a>3.3）三个容易的步骤</h3>
<p>第一步是获取通道。我们从 </p>
<p>FileInputStream
 获取通道：
FileInputStream fin = new FileInputStream( &quot;readandshow.txt&quot; );</p>
<p>FileChannel fc = fin.getChannel();</p>
<p>下一步是创建缓冲区：
ByteBuffer buffer = ByteBuffer.allocate( 1024 );</p>
<p>最后，需要将数据从通道读到缓冲区中，如下所示：
fc.read( buffer );</p>
<p>您会注意到，我们不需要告诉通道要读 <em>多少数据 </em>到缓冲区中。每一个缓冲区都有复杂的内部统计机制，它会跟踪已经读了多少数据以及还有多少空间可以容纳更多的数据。我们将在 <strong>缓冲区内部细节</strong> 中介绍更多关于缓冲区统计机制的内容。</p>
<h3 id="-3-4-"><a href=""></a>3.4）写入文件</h3>
<p>在 NIO 中写入文件类似于从文件中读取。首先从 </p>
<p>FileOutputStream
 获取一个通道：
FileOutputStream fout = new FileOutputStream( &quot;writesomebytes.txt&quot; );</p>
<p>FileChannel fc = fout.getChannel();</p>
<p>下一步是创建一个缓冲区并在其中放入一些数据 - 在这里，数据将从一个名为 </p>
<p>message
 的数组中取出，这个数组包含字符串 &quot;Some bytes&quot; 的 ASCII 字节(本教程后面将会解释 </p>
<p>buffer.flip()
 和 </p>
<p>buffer.put()
 调用)。
ByteBuffer buffer = ByteBuffer.allocate( 1024 );</p>
<p>for (int i=0; i&lt;message.length; ++i) {</p>
<pre><code> buffer.put( message[i] );
</code></pre><p>}</p>
<p>buffer.flip();</p>
<p>最后一步是写入通道中：
fc.write( buffer );</p>
<p>注意在这里同样不需要告诉通道要写入多数据。缓冲区的内部统计机制会跟踪它包含多少数据以及还有多少数据要写入。</p>
<h3 id="-3-5-"><a href=""></a>3.5）读写结合</h3>
<p>下面我们将看一下在结合读和写时会有什么情况。我们以一个名为 CopyFile.java 的简单程序作为这个练习的基础，它将一个文件的所有内容拷贝到另一个文件中。CopyFile.java 执行三个基本操作：首先创建一个 </p>
<p>Buffer
，然后从源文件中将数据读到这个缓冲区中，然后将缓冲区写入目标文件。这个程序不断重复 ― 读、写、读、写 ― 直到源文件结束。</p>
<p>CopyFile 程序让您看到我们如何检查操作的状态，以及如何使用 </p>
<p>clear()
 和 </p>
<p>flip()
 方法重设缓冲区，并准备缓冲区以便将新读取的数据写到另一个通道中。</p>
<h3 id="-copyfile-"><a href=""></a>运行CopyFile例子</h3>
<p>因为缓冲区会跟踪它自己的数据，所以 CopyFile 程序的内部循环 (inner loop) 非常简单，如下所示：
fcin.read( buffer );</p>
<p>fcout.write( buffer );</p>
<p>第一行将数据从输入通道 </p>
<p>fcin
 中读入缓冲区，第二行将这些数据写到输出通道 </p>
<p>fcout
 。</p>
<h3 id="-"><a href=""></a>检查状态</h3>
<p>下一步是检查拷贝何时完成。当没有更多的数据时，拷贝就算完成，并且可以在 </p>
<p>read()
 方法返回 -1 是判断这一点，如下所示：
int r = fcin.read( buffer );</p>
<p>if (r==-1) {</p>
<pre><code> break;
</code></pre><p>}</p>
<h3 id="-"><a href=""></a>重设缓冲区</h3>
<p>最后，在从输入通道读入缓冲区之前，我们调用 </p>
<p>clear()
 方法。同样，在将缓冲区写入输出通道之前，我们调用 </p>
<p>flip()
 方法，如下所示：</p>
<p>buffer.clear();</p>
<p>int r = fcin.read( buffer );</p>
<p>if (r==-1) {
     break;</p>
<p>}</p>
<p>buffer.flip();
fcout.write( buffer );</p>
<p>clear()
 方法重设缓冲区，使它可以接受读入的数据。 </p>
<p>flip()
 方法让缓冲区可以将新读入的数据写入另一个通道。</p>
<p>来源： <a href="[http://blog.csdn.net/ssjhust123/article/details/7904757](http://blog.csdn.net/ssjhust123/article/details/7904757)">[http://blog.csdn.net/ssjhust123/article/details/7904757](http://blog.csdn.net/ssjhust123/article/details/7904757)</a> </p>
<p><a href="http://blog.csdn.net/ssjhust123/article/details/7905278" target="_blank">（二）—缓冲区原理</a></p>
<h2 id="4-">4、缓冲区的内部细节</h2>
<h3 id="-"><a href=""></a><strong>概述</strong></h3>
<p>本节将介绍 NIO 中两个重要的缓冲区组件：状态变量和访问方法 (accessor)。</p>
<p>状态变量是前一节中提到的&quot;内部统计机制&quot;的关键。每一个读/写操作都会改变缓冲区的状态。通过记录和跟踪这些变化，缓冲区就可能够内部地管理自己的资源。</p>
<p>在从通道读取数据时，数据被放入到缓冲区。在有些情况下，可以将这个缓冲区直接写入另一个通道，但是在一般情况下，您还需要查看数据。这是使用 <em>访问方法 </em></p>
<p>get()
 来完成的。同样，如果要将原始数据放入缓冲区中，就要使用访问方法 </p>
<p>put()
。</p>
<p>在本节中，您将学习关于 NIO 中的状态变量和访问方法的内容。我们将描述每一个组件，并让您有机会看到它的实际应用。虽然 NIO 的内部统计机制初看起来可能很复杂，但是您很快就会看到大部分的实际工作都已经替您完成了。您可能习惯于通过手工编码进行簿记 ― 即使用字节数组和索引变量，现在它已在 NIO 中内部地处理了。</p>
<h3 id="-"><a href=""></a>状态变量</h3>
<p>可以用三个值指定缓冲区在任意时刻的状态：</p>
<ul>
<li>position</li>
<li>limit</li>
<li>capacity</li>
</ul>
<p>这三个变量一起可以跟踪缓冲区的状态和它所包含的数据。我们将在下面的小节中详细分析每一个变量，还要介绍它们如何适应典型的读/写(输入/输出)进程。在这个例子中，我们假定要将数据从一个输入通道拷贝到一个输出通道。</p>
<h3 id="-position"><a href=""></a>position</h3>
<p>您可以回想一下，缓冲区实际上就是美化了的数组。在从通道读取时，您将所读取的数据放到底层的数组中。 </p>
<p>position
 变量跟踪已经写了多少数据。更准确地说，它指定了下一个字节将放到数组的哪一个元素中。因此，如果您从通道中读三个字节到缓冲区中，那么缓冲区的 </p>
<p>position
 将会设置为3，指向数组中第四个元素。</p>
<p>同样，在写入通道时，您是从缓冲区中获取数据。 </p>
<p>position
 值跟踪从缓冲区中获取了多少数据。更准确地说，它指定下一个字节来自数组的哪一个元素。因此如果从缓冲区写了5个字节到通道中，那么缓冲区的 </p>
<p>position
 将被设置为5，指向数组的第六个元素。</p>
<h3 id="-"><a href=""></a></h3>
<p>limit</p>
<p>limit
 变量表明还有多少数据需要取出(在从缓冲区写入通道时)，或者还有多少空间可以放入数据(在从通道读入缓冲区时)。</p>
<p>position
 总是小于或者等于 </p>
<p>limit
。</p>
<h3 id="-capacity-"><a href=""></a><strong>capacity</strong></h3>
<p>缓冲区的 </p>
<p>capacity
 表明可以储存在缓冲区中的最大数据容量。实际上，它指定了底层数组的大小 ― 或者至少是指定了准许我们使用的底层数组的容量。</p>
<p>limit
 决不能大于 </p>
<p>capacity
。</p>
<h3 id="-"><a href=""></a><strong>观察变量</strong></h3>
<p>我们首先观察一个新创建的缓冲区。出于本例子的需要，我们假设这个缓冲区的 </p>
<p>总容量 
为8个字节。 </p>
<p>Buffer
 的状态如下所示：
<img src="" alt="Buffer state"> </p>
<p>回想一下 ，</p>
<p>limit
 决不能大于 </p>
<p>capacity
，此例中这两个值都被设置为 8。我们通过将它们指向数组的尾部之后(如果有第8个槽，则是第8个槽所在的位置)来说明这点。
<img src="" alt="Array"> </p>
<p>position
 设置为0。如果我们读一些数据到缓冲区中，那么下一个读取的数据就进入 slot 0 。如果我们从缓冲区写一些数据，从缓冲区读取的下一个字节就来自 slot 0 。 </p>
<p>position
 设置如下所示：
<img src="" alt="Position setting"> </p>
<p>由于 </p>
<p>capacity
 不会改变，所以我们在下面的讨论中可以忽略它。</p>
<h3 id="-"><a href=""></a><strong>第一次读取</strong></h3>
<p>现在我们可以开始在新创建的缓冲区上进行读/写操作。首先从输入通道中读一些数据到缓冲区中。第一次读取得到三个字节。它们被放到数组中从 </p>
<p>position
 开始的位置，这时 position 被设置为 0。读完之后，position 就增加到 3，如下所示：
<img src="" alt="Position increased to 3"> </p>
<p>limit
 没有改变。</p>
<h3 id="-"><a href=""></a><strong>第二次读取</strong></h3>
<p>在第二次读取时，我们从输入通道读取另外两个字节到缓冲区中。这两个字节储存在由 </p>
<p>position
 所指定的位置上， </p>
<p>position
 因而增加 2：
<img src="" alt="Position increased by 2"> </p>
<p>limit
 没有改变。</p>
<h3 id="-flip-"><a href=""></a><strong>flip</strong></h3>
<p>现在我们要将数据写到输出通道中。在这之前，我们必须调用 </p>
<p>flip()
 方法。这个方法做两件非常重要的事：</p>
<ol>
<li>它将 </li>
</ol>
<p>limit
 设置为当前 </p>
<p>position
。</p>
<ol>
<li>它将 </li>
</ol>
<p>position
 设置为 0。</p>
<p>前一小节中的图显示了在 flip 之前缓冲区的情况。下面是在 flip 之后的缓冲区：
<img src="" alt="Buffer after the flip"> </p>
<p>我们现在可以将数据从缓冲区写入通道了。 </p>
<p>position
 被设置为 0，这意味着我们得到的下一个字节是第一个字节。 </p>
<p>limit
 已被设置为原来的 </p>
<p>position
，这意味着它包括以前读到的所有字节，并且一个字节也不多。</p>
<h3 id="-"><a href=""></a><strong>第一次写入</strong></h3>
<p>在第一次写入时，我们从缓冲区中取四个字节并将它们写入输出通道。这使得 </p>
<p>position
 增加到 4，而 </p>
<p>limit
 不变，如下所示：
<img src="" alt="Position advanced to 4, limit unchanged"> </p>
<h3 id="-"><a href=""></a><strong>第二次写入</strong></h3>
<p>我们只剩下一个字节可写了。 </p>
<p>limit
在我们调用 </p>
<p>flip()
 时被设置为 5，并且 </p>
<p>position
 不能超过 </p>
<p>limit
。所以最后一次写入操作从缓冲区取出一个字节并将它写入输出通道。这使得 </p>
<p>position
 增加到 5，并保持 </p>
<p>limit
 不变，如下所示：
<img src="" alt="Position advanced to 5, limit unchanged"> </p>
<h3 id="-clear-"><a href=""></a><strong>clear</strong></h3>
<p>最后一步是调用缓冲区的 </p>
<p>clear()
 方法。这个方法重设缓冲区以便接收更多的字节。 </p>
<p>Clear
 做两种非常重要的事情：</p>
<ol>
<li>它将 </li>
</ol>
<p>limit
 设置为与 </p>
<p>capacity
 相同。</p>
<ol>
<li>它设置 </li>
</ol>
<p>position
 为 0。</p>
<p>下图显示了在调用 </p>
<p>clear()
 后缓冲区的状态：
<img src="" alt="State of the buffer after clear() has been called"> </p>
<p>缓冲区现在可以接收新的数据了。</p>
<p><strong>访问方法</strong></p>
<p>到目前为止，我们只是使用缓冲区将数据从一个通道转移到另一个通道。然而，程序经常需要直接处理数据。例如，您可能需要将用户数据保存到磁盘。在这种情况下，您必须将这些数据直接放入缓冲区，然后用通道将缓冲区写入磁盘。</p>
<p>或者，您可能想要从磁盘读取用户数据。在这种情况下，您要将数据从通道读到缓冲区中，然后检查缓冲区中的数据。</p>
<p>在本节的最后，我们将详细分析如何使用 </p>
<p>ByteBuffer
 类的 </p>
<p>get()
 和 </p>
<p>put()
 方法直接访问缓冲区中的数据</p>
<h3 id="-"><a href=""></a></h3>
<p>get()方法</p>
<p>ByteBuffer
 类中有四个 </p>
<p>get()
 方法：</p>
<ol>
<li>byte get();</li>
<li>ByteBuffer get( byte dst[] );</li>
<li>ByteBuffer get( byte dst[], int offset, int length );</li>
<li>byte get( int index );</li>
</ol>
<p>第一个方法获取单个字节。第二和第三个方法将一组字节读到一个数组中。第四个方法从缓冲区中的特定位置获取字节。那些返回</p>
<p>ByteBuffer
 的方法只是返回调用它们的缓冲区的 </p>
<p>this
 值。</p>
<p>此外，我们认为前三个 </p>
<p>get()
 方法是相对的，而最后一个方法是绝对的。 <em>相对 </em>意味着 </p>
<p>get()
 操作服从 </p>
<p>limit
 和 </p>
<p>position
 值 ― 更明确地说，字节是从当前 </p>
<p>position
 读取的，而 </p>
<p>position
 在 </p>
<p>get
 之后会增加。另一方面，一个 <em>绝对 </em>方法会忽略 </p>
<p>limit
 和 </p>
<p>position
 值，也不会影响它们。事实上，它完全绕过了缓冲区的统计方法。</p>
<p>上面列出的方法对应于 </p>
<p>ByteBuffer
 类。其他类有等价的 </p>
<p>get()
 方法，这些方法除了不是处理字节外，其它方面是是完全一样的，它们处理的是与该缓冲区类相适应的类型。</p>
<h3 id="-put-"><a href=""></a><strong>put()方法</strong></h3>
<p>ByteBuffer
 类中有五个 </p>
<p>put()
 方法：</p>
<ol>
<li>ByteBuffer put( byte b );</li>
<li>ByteBuffer put( byte src[] );</li>
<li>ByteBuffer put( byte src[], int offset, int length );</li>
<li>ByteBuffer put( ByteBuffer src );</li>
<li>ByteBuffer put( int index, byte b );</li>
</ol>
<p>第一个方法 </p>
<p>写入（put） 
单个字节。第二和第三个方法写入来自一个数组的一组字节。第四个方法将数据从一个给定的源</p>
<p>ByteBuffer
 写入这个 </p>
<p>ByteBuffer
。第五个方法将字节写入缓冲区中特定的 </p>
<p>位置 
。那些返回 </p>
<p>ByteBuffer
 的方法只是返回调用它们的缓冲区的 </p>
<p>this
 值。</p>
<p>与 </p>
<p>get()
 方法一样，我们将把 </p>
<p>put()
 方法划分为 <em>相对 </em>或者 <em>绝对 </em>的。前四个方法是相对的，而第五个方法是绝对的。</p>
<p>上面显示的方法对应于 </p>
<p>ByteBuffer
 类。其他类有等价的 </p>
<p>put()
 方法，这些方法除了不是处理字节之外，其它方面是完全一样的。它们处理的是与该缓冲区类相适应的类型。</p>
<h3 id="-get-put-"><a href=""></a>类型化的 get() 和 put() 方法</h3>
<p>除了前些小节中描述的 </p>
<p>get()
 和 </p>
<p>put()
 方法， </p>
<p>ByteBuffer
 还有用于读写不同类型的值的其他方法，如下所示：</p>
<ul>
<li>getByte()</li>
<li>getChar()</li>
<li>getShort()</li>
<li>getInt()</li>
<li>getLong()</li>
<li>getFloat()</li>
<li>getDouble()</li>
<li>putByte()</li>
<li>putChar()</li>
<li>putShort()</li>
<li>putInt()</li>
<li>putLong()</li>
<li>putFloat()</li>
<li>putDouble()</li>
</ul>
<p>事实上，这其中的每个方法都有两种类型 ― 一种是相对的，另一种是绝对的。它们对于读取格式化的二进制数据（如图像文件的头部）很有用。</p>
<p>您可以在例子程序 TypesInByteBuffer.java 中看到这些方法的实际应用。</p>
<h3 id="-"><a href=""></a><strong>缓冲区的使用：一个内部循环</strong></h3>
<p>下面的内部循环概括了使用缓冲区将数据从输入通道拷贝到输出通道的过程。
while (true) {</p>
<pre><code> buffer.clear();
 int r = fcin.read( buffer );


 if (r==-1) {

   break;
 }


 buffer.flip();

 fcout.write( buffer );
</code></pre><p>}</p>
<p>read()
 和 </p>
<p>write()
 调用得到了极大的简化，因为许多工作细节都由缓冲区完成了。 </p>
<p>clear()
 和 </p>
<p>flip()
 方法用于让缓冲区在读和写之间切换。</p>
<p>5、关于缓冲区的更多内容</p>
<p><strong>概述</strong></p>
<p>到目前为止，您已经学习了使用缓冲区进行日常工作所需要掌握的大部分内容。我们的例子没怎么超出标准的读/写过程种类，在原来的 I/O 中可以像在 NIO 中一样容易地实现这样的标准读写过程。</p>
<p>本节将讨论使用缓冲区的一些更复杂的方面，比如缓冲区分配、包装和分片。我们还会讨论 NIO 带给 Java 平台的一些新功能。您将学到如何创建不同类型的缓冲区以达到不同的目的，如可保护数据不被修改的 <em>只读 </em>缓冲区，和直接映射到底层操作系统缓冲区的 <em>直接 </em>缓冲区。我们将在本节的最后介绍如何在 NIO 中创建内存映射文件。</p>
<p><strong>缓冲区分配和包装</strong></p>
<p>在能够读和写之前，必须有一个缓冲区。要创建缓冲区，您必须 <em>分配 </em>它。我们使用静态方法 </p>
<p>allocate()
 来分配缓冲区：
ByteBuffer buffer = ByteBuffer.allocate( 1024 );</p>
<p>allocate()
 方法分配一个具有指定大小的底层数组，并将它包装到一个缓冲区对象中 ― 在本例中是一个 </p>
<p>ByteBuffer
。</p>
<p>您还可以将一个现有的数组转换为缓冲区，如下所示：
byte array[] = new byte[1024];</p>
<p>ByteBuffer buffer = ByteBuffer.wrap( array );</p>
<p>本例使用了 </p>
<p>wrap()
 方法将一个数组包装为缓冲区。必须非常小心地进行这类操作。一旦完成包装，底层数据就可以通过缓冲区或者直接访问。</p>
<p><strong>缓冲区分片</strong></p>
<p>slice()
 方法根据现有的缓冲区创建一种 <em>子缓冲区 </em>。也就是说，它创建一个新的缓冲区，新缓冲区与原来的缓冲区的一部分共享数据。</p>
<p>使用例子可以最好地说明这点。让我们首先创建一个长度为 10 的 </p>
<p>ByteBuffer
：
ByteBuffer buffer = ByteBuffer.allocate( 10 );</p>
<p>然后使用数据来填充这个缓冲区，在第 <em>n</em> 个槽中放入数字 <em>n</em>：
for (int i=0; i&lt;buffer.capacity(); ++i) {</p>
<pre><code> buffer.put( (byte)i );
</code></pre><p>}</p>
<p>现在我们对这个缓冲区 <em>分片 </em>，以创建一个包含槽 3 到槽 6 的子缓冲区。在某种意义上，子缓冲区就像原来的缓冲区中的一个 <em>窗口 </em>。</p>
<p>窗口的起始和结束位置通过设置 </p>
<p>position
 和 </p>
<p>limit
 值来指定，然后调用 </p>
<p>Buffer
 的 </p>
<p>slice()
 方法：
buffer.position( 3 );</p>
<p>buffer.limit( 7 );
ByteBuffer slice = buffer.slice();</p>
<p>片段
是缓冲区的 </p>
<p>子缓冲区 
。不过， </p>
<p>片段
和 </p>
<p>缓冲区
共享同一个底层数据数组，我们在下一节将会看到这一点。</p>
<p><strong>缓冲区分片和数据共享</strong></p>
<p>我们已经创建了原缓冲区的子缓冲区，并且我们知道缓冲区和子缓冲区共享同一个底层数据数组。让我们看看这意味着什么。</p>
<p>我们遍历子缓冲区，将每一个元素乘以 11 来改变它。例如，5 会变成 55。
for (int i=0; i&lt;slice.capacity(); ++i) {</p>
<pre><code> byte b = slice.get( i );
 b /*= 11;

 slice.put( i, b );
</code></pre><p>}</p>
<p>最后，再看一下原缓冲区中的内容：
buffer.position( 0 );</p>
<p>buffer.limit( buffer.capacity() );</p>
<p>while (buffer.remaining()&gt;0) {
     System.out.println( buffer.get() );</p>
<p>}</p>
<p>结果表明只有在子缓冲区窗口中的元素被改变了：
$ java SliceBuffer</p>
<p>0
1</p>
<p>2
33</p>
<p>44
55</p>
<p>66
7</p>
<p>8
9</p>
<p>缓冲区片对于促进抽象非常有帮助。可以编写自己的函数处理整个缓冲区，而且如果想要将这个过程应用于子缓冲区上，您只需取主缓冲区的一个片，并将它传递给您的函数。这比编写自己的函数来取额外的参数以指定要对缓冲区的哪一部分进行操作更容易。</p>
<p><strong>只读缓冲区</strong></p>
<p>只读缓冲区非常简单 ― 您可以读取它们，但是不能向它们写入。可以通过调用缓冲区的 </p>
<p>asReadOnlyBuffer()
 方法，将任何常规缓冲区转换为只读缓冲区，这个方法返回一个与原缓冲区完全相同的缓冲区(并与其共享数据)，只不过它是只读的。</p>
<p>只读缓冲区对于保护数据很有用。在将缓冲区传递给某个对象的方法时，您无法知道这个方法是否会修改缓冲区中的数据。创建一个只读的缓冲区可以 <em>保证 </em>该缓冲区不会被修改。</p>
<p>不能将只读的缓冲区转换为可写的缓冲区。</p>
<p><strong>直接和间接缓冲区</strong></p>
<p>另一种有用的 </p>
<p>ByteBuffer
 是直接缓冲区。 <em>直接缓冲区 </em>是为加快 I/O 速度，而以一种特殊的方式分配其内存的缓冲区。</p>
<p>实际上，直接缓冲区的准确定义是与实现相关的。Sun 的文档是这样描述直接缓冲区的：</p>
<p><em>给定一个直接字节缓冲区，Java 虚拟机将尽最大努力直接对它执行本机 I/O 操作。也就是说，它会在每一次调用底层操作系统的本机 I/O 操作之前(或之后)，尝试避免将缓冲区的内容拷贝到一个中间缓冲区中(或者从一个中间缓冲区中拷贝数据)。</em></p>
<p>您可以在例子程序 FastCopyFile.java 中看到直接缓冲区的实际应用，这个程序是 CopyFile.java 的另一个版本，它使用了直接缓冲区以提高速度。</p>
<p>还可以用内存映射文件创建直接缓冲区。</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/ssjhust123/article/details/7905278#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/ssjhust123/article/details/7905278#" title="copy" target="_blank">copy</a></p>
<ol>
<li>ByteBuffer buffer = ByteBuffer.allocateDirect( 1024 ); //直接缓冲区  </li>
</ol>
<p><strong>内存映射文件I/O</strong></p>
<p>内存映射文件 I/O 是一种读和写文件数据的方法，它可以比常规的基于流或者基于通道的 I/O 快得多。</p>
<p>内存映射文件 I/O 是通过使文件中的数据神奇般地出现为内存数组的内容来完成的。这其初听起来似乎不过就是将整个文件读到内存中，但是事实上并不是这样。一般来说，只有文件中实际读取或者写入的部分才会送入（或者 <em>映射 </em>）到内存中。</p>
<p>内存映射并不真的神奇或者多么不寻常。现代操作系统一般根据需要将文件的部分映射为内存的部分，从而实现文件系统。Java 内存映射机制不过是在底层操作系统中可以采用这种机制时，提供了对该机制的访问。</p>
<p>尽管创建内存映射文件相当简单，但是向它写入可能是危险的。仅只是改变数组的单个元素这样的简单操作，就可能会直接修改磁盘上的文件。修改数据与将数据保存到磁盘是没有分开的。</p>
<p><strong>将文件映射到内存</strong></p>
<p>了解内存映射的最好方法是使用例子。在下面的例子中，我们要将一个 </p>
<p>FileChannel
 (它的全部或者部分)映射到内存中。为此我们将使用 </p>
<p>FileChannel.map()
 方法。下面代码行将文件的前 1024 个字节映射到内存中：
MappedByteBuffer mbb = fc.map( FileChannel.MapMode.READ_WRITE,</p>
<pre><code> 0, 1024 );
</code></pre><p>map()
 方法返回一个 </p>
<p>MappedByteBuffer
，它是 </p>
<p>ByteBuffer
 的子类。因此，您可以像使用其他任何 </p>
<p>ByteBuffer
 一样使用新映射的缓冲区，操作系统会在需要时负责执行行映射。
来源： <a href="[http://blog.csdn.net/ssjhust123/article/details/7905278](http://blog.csdn.net/ssjhust123/article/details/7905278)">[http://blog.csdn.net/ssjhust123/article/details/7905278](http://blog.csdn.net/ssjhust123/article/details/7905278)</a> </p>
<p><a href="http://blog.csdn.net/ssjhust123/article/details/7905367" target="_blank">（三）—分散聚集、文件锁定、字符集</a></p>
<h2 id="6-">6、分散和聚集</h2>
<p><strong>概述</strong></p>
<p>分散/聚集 I/O 是使用多个而不是单个缓冲区来保存数据的读写方法。</p>
<p>一个分散的读取就像一个常规通道读取，只不过它是将数据读到一个缓冲区数组中而不是读到单个缓冲区中。同样地，一个聚集写入是向缓冲区数组而不是向单个缓冲区写入数据。分散/聚集 I/O 对于将数据流划分为单独的部分很有用，这有助于实现复杂的数据格式。</p>
<p><strong>分散/聚集IO</strong></p>
<p>通道可以有选择地实现两个新的接口： </p>
<p>ScatteringByteChannel
 和 </p>
<p>GatheringByteChannel
。一个 </p>
<p>ScatteringByteChannel
 是一个具有两个附加读方法的通道：</p>
<ul>
<li>long read( ByteBuffer[] dsts );</li>
<li>long read( ByteBuffer[] dsts, int offset, int length );</li>
</ul>
<p>这些 </p>
<p>long read()
 方法很像标准的 </p>
<p>read
 方法，只不过它们不是取单个缓冲区而是取一个缓冲区数组。</p>
<p>在 <em>分散读取 </em>中，通道依次填充每个缓冲区。填满一个缓冲区后，它就开始填充下一个。在某种意义上，缓冲区数组就像一个大缓冲区。</p>
<p><em>聚集写入 </em>类似于分散读取，只不过是用来写入。它也有接受缓冲区数组的方法：</p>
<ul>
<li>long write( ByteBuffer[] srcs );</li>
<li>long write( ByteBuffer[] srcs, int offset, int length );</li>
</ul>
<p>聚集写对于把一组单独的缓冲区中组成单个数据流很有用。为了与上面的消息例子保持一致，您可以使用聚集写入来自动将网络消息的各个部分组装为单个数据流，以便跨越网络传输消息。</p>
<p>从例子程序 UseScatterGather.java 中可以看到分散读取和聚集写入的实际应用。</p>
<p><strong>分散/聚集的应用</strong></p>
<p>分散/聚集 I/O 对于将数据划分为几个部分很有用。例如，您可能在编写一个使用消息对象的网络应用程序，每一个消息被划分为固定长度的头部和固定长度的正文。您可以创建一个刚好可以容纳头部的缓冲区和另一个刚好可以容难正文的缓冲区。当您将它们放入一个数组中并使用分散读取来向它们读入消息时，头部和正文将整齐地划分到这两个缓冲区中。</p>
<p>我们从缓冲区所得到的方便性对于缓冲区数组同样有效。因为每一个缓冲区都跟踪自己还可以接受多少数据，所以分散读取会自动找到有空间接受数据的第一个缓冲区。在这个缓冲区填满后，它就会移动到下一个缓冲区。</p>
<h2 id="-7-"><a href=""></a>7、文件锁定</h2>
<p><strong>概述</strong></p>
<p>文件锁定初看起来可能让人迷惑。它 <em>似乎 </em>指的是防止程序或者用户访问特定文件。事实上，文件锁就像常规的 Java 对象锁 ― 它们是 <em>劝告式的（advisory） </em>锁。它们不阻止任何形式的数据访问，相反，它们通过锁的共享和获取赖允许系统的不同部分相互协调。</p>
<p>您可以锁定整个文件或者文件的一部分。如果您获取一个排它锁，那么其他人就不能获得同一个文件或者文件的一部分上的锁。如果您获得一个共享锁，那么其他人可以获得同一个文件或者文件一部分上的共享锁，但是不能获得排它锁。文件锁定并不总是出于保护数据的目的。例如，您可能临时锁定一个文件以保证特定的写操作成为原子的，而不会有其他程序的干扰。</p>
<p>大多数操作系统提供了文件系统锁，但是它们并不都是采用同样的方式。有些实现提供了共享锁，而另一些仅提供了排它锁。事实上，有些实现使得文件的锁定部分不可访问，尽管大多数实现不是这样的。</p>
<p>在本节中，您将学习如何在 NIO 中执行简单的文件锁过程，我们还将探讨一些保证被锁定的文件尽可能可移植的方法。</p>
<p><strong>锁定文件</strong></p>
<p>要获取文件的一部分上的锁，您要调用一个打开的 </p>
<p>FileChannel
 上的 </p>
<p>lock()
 方法。注意，如果要获取一个排它锁，您必须以写方式打开文件。
RandomAccessFile raf = new RandomAccessFile( &quot;usefilelocks.txt&quot;, &quot;rw&quot; );</p>
<p>FileChannel fc = raf.getChannel();
FileLock lock = fc.lock( start, end, false );</p>
<p>在拥有锁之后，您可以执行需要的任何敏感操作，然后再释放锁：
lock.release();</p>
<p>在释放锁后，尝试获得锁的其他任何程序都有机会获得它。</p>
<p>本小节的例子程序 UseFileLocks.java 必须与它自己并行运行。这个程序获取一个文件上的锁，持有三秒钟，然后释放它。如果同时运行这个程序的多个实例，您会看到每个实例依次获得锁。如果两个程序分别获取同一个文件不同位置的锁，则不会阻塞。比如第一个程序获取文件范围为0-20的锁，而第二个程序获取21-40的锁，则会正常执行。</p>
<p><strong>文件锁定和可移植性</strong></p>
<p>文件锁定可能是一个复杂的操作，特别是考虑到不同的操作系统是以不同的方式实现锁这一事实。下面的指导原则将帮助您尽可能保持代码的可移植性：</p>
<ul>
<li>只使用排它锁。</li>
<li>将所有的锁视为劝告式的（advisory）。</li>
</ul>
<p>8、字符集</p>
<p><strong>概述</strong></p>
<p>根据 Sun 的文档，一个 </p>
<p>Charset
 是“十六位 Unicode 字符序列与字节序列之间的一个命名的映射”。实际上，一个 </p>
<p>Charset
 允许您以尽可能最具可移植性的方式读写字符序列。</p>
<p>Java 语言被定义为基于 Unicode。然而在实际上，许多人编写代码时都假设一个字符在磁盘上或者在网络流中用一个字节表示。这种假设在许多情况下成立，但是并不是在所有情况下都成立，而且随着计算机变得对 Unicode 越来越友好，这个假设就日益变得不能成立了。</p>
<p>在本节中，我们将看一下如何使用 </p>
<p>Charsets
 以适合现代文本格式的方式处理文本数据。这里将使用的示例程序相当简单，不过，它触及了使用 </p>
<p>Charset
 的所有关键方面：为给定的字符编码创建 </p>
<p>Charset
，以及使用该 </p>
<p>Charset
 解码和编码文本数据。</p>
<p><a href="http://www.ibm.com/developerworks/cn/education/java/j-nio/section10.html#ibm-pcon" target="_blank">回页首</a></p>
<p><strong>编码/解码</strong></p>
<p>要读和写文本，我们要分别使用 </p>
<p>CharsetDecoder
 和 </p>
<p>CharsetEncoder
。将它们称为 <em>编码器 </em>和 <em>解码器 </em>是有道理的。一个 <em>字符 </em>不再表示一个特定的位模式，而是表示字符系统中的一个实体。因此，由某个实际的位模式表示的字符必须以某种特定的 <em>编码 </em>来表示。</p>
<p>CharsetDecoder
 用于将逐位表示的一串字符转换为具体的 </p>
<p>char
 值。同样，一个 </p>
<p>CharsetEncoder
 用于将字符转换回位。</p>
<p>在下一个小节中，我们将考察一个使用这些对象来读写数据的程序。</p>
<p><a href="http://www.ibm.com/developerworks/cn/education/java/j-nio/section10.html#ibm-pcon" target="_blank">回页首</a></p>
<p><strong>处理文本的正确方式</strong></p>
<p>现在我们将分析这个例子程序 UseCharsets.java。这个程序非常简单 ― 它从一个文件中读取一些文本，并将该文本写入另一个文件。但是它把该数据当作文本数据，并使用 </p>
<p>CharBuffer
 来将该数句读入一个 </p>
<p>CharsetDecoder
 中。同样，它使用 </p>
<p>CharsetEncoder
 来写回该数据。</p>
<p>我们将假设字符以 ISO-8859-1(Latin1) 字符集（这是 ASCII 的标准扩展）的形式储存在磁盘上。尽管我们必须为使用 Unicode 做好准备，但是也必须认识到不同的文件是以不同的格式储存的，而 ASCII 无疑是非常普遍的一种格式。事实上，每种 Java 实现都要求对以下字符编码提供完全的支持：</p>
<ul>
<li>US-ASCII</li>
<li>ISO-8859-1</li>
<li>UTF-8</li>
<li>UTF-16BE</li>
<li>UTF-16LE</li>
<li>UTF-16</li>
</ul>
<p><a href="http://www.ibm.com/developerworks/cn/education/java/j-nio/section10.html#ibm-pcon" target="_blank">回页首</a></p>
<p><strong>示例程序</strong></p>
<p>在打开相应的文件、将输入数据读入名为 </p>
<p>inputData
 的 </p>
<p>ByteBuffer
 之后，我们的程序必须创建 ISO-8859-1 (Latin1) 字符集的一个实例：
Charset latin1 = Charset.forName( &quot;ISO-8859-1&quot; );</p>
<p>然后，创建一个解码器（用于读取）和一个编码器 （用于写入）：
CharsetDecoder decoder = latin1.newDecoder();</p>
<p>CharsetEncoder encoder = latin1.newEncoder();</p>
<p>为了将字节数据解码为一组字符，我们把 </p>
<p>ByteBuffer
 传递给 </p>
<p>CharsetDecoder
，结果得到一个 </p>
<p>CharBuffer
：
CharBuffer cb = decoder.decode( inputData );</p>
<p>如果想要处理字符，我们可以在程序的此处进行。但是我们只想无改变地将它写回，所以没有什么要做的。</p>
<p>要写回数据，我们必须使用 </p>
<p>CharsetEncoder
 将它转换回字节：
ByteBuffer outputData = encoder.encode( cb );</p>
<p>在转换完成之后，我们就可以将数据写到文件中了。
来源： <a href="[http://blog.csdn.net/ssjhust123/article/details/7905367](http://blog.csdn.net/ssjhust123/article/details/7905367)">[http://blog.csdn.net/ssjhust123/article/details/7905367](http://blog.csdn.net/ssjhust123/article/details/7905367)</a> <a href="http://blog.csdn.net/ssjhust123/article/details/7905401" target="_blank">（四）—网络和异步IO</a></p>
<p>9、连网和异步 I/O</p>
<p><strong>概述</strong></p>
<p>连网是学习异步 I/O 的很好基础，而异步 I/O 对于在 Java 语言中执行任何输入/输出过程的人来说，无疑都是必须具备的知识。NIO 中的连网与 NIO 中的其他任何操作没有什么不同 ― 它依赖通道和缓冲区，而您通常使用 </p>
<p>InputStream
 和 </p>
<p>OutputStream
 来获得通道。</p>
<p>本节首先介绍异步 I/O 的基础 ― 它是什么以及它不是什么，然后转向更实用的、程序性的例子。</p>
<p><strong>异步I/O</strong></p>
<p>异步 I/O 是一种 <em>没有阻塞地 </em>读写数据的方法。通常，在代码进行 </p>
<p>read()
 调用时，代码会阻塞直至有可供读取的数据。同样，</p>
<p>write()
 调用将会阻塞直至数据能够写入。</p>
<p>另一方面，异步 I/O 调用不会阻塞。相反，您将注册对特定 I/O 事件的兴趣 ― 可读的数据的到达、新的套接字连接，等等，而在发生这样的事件时，系统将会告诉您。</p>
<p>异步 I/O 的一个优势在于，它允许您同时根据大量的输入和输出执行 I/O。同步程序常常要求助于轮询，或者创建许许多多的线程以处理大量的连接。使用异步 I/O，您可以监听任何数量的通道上的事件，不用轮询，也不用额外的线程。</p>
<p>我们将通过研究一个名为 MultiPortEcho.java 的例子程序来查看异步 I/O 的实际应用。这个程序就像传统的 <em>echo server</em>，它接受网络连接并向它们回响它们可能发送的数据。不过它有一个附加的特性，就是它能同时监听多个端口，并处理来自所有这些端口的连接。并且它只在单个线程中完成所有这些工作。</p>
<p><strong>Selectors</strong></p>
<p>本节的阐述对应于 </p>
<p>MultiPortEcho
 的源代码中的 </p>
<p>go()
 方法的实现，因此应该看一下源代码，以便对所发生的事情有个更全面的了解。</p>
<p>异步 I/O 中的核心对象名为 </p>
<p>Selector
。</p>
<p>Selector
 就是您注册对各种 I/O 事件的兴趣的地方，而且当那些事件发生时，就是这个对象告诉您所发生的事件。</p>
<p>所以，我们需要做的第一件事就是创建一个 </p>
<p>Selector
：
Selector selector = Selector.open();</p>
<p>然后，我们将对不同的通道对象调用 </p>
<p>register()
 方法，以便注册我们对这些对象中发生的 I/O 事件的兴趣。</p>
<p>register()
 的第一个参数总是这个 </p>
<p>Selector
。</p>
<p><strong>打开一个Server Socket Channel</strong></p>
<p>为了接收连接，我们需要一个 </p>
<p>ServerSocketChannel
。事实上，我们要监听的每一个端口都需要有一个 </p>
<p>ServerSocketChannel
 。对于每一个端口，我们打开一个 </p>
<p>ServerSocketChannel
，如下所示：
ServerSocketChannel ssc = ServerSocketChannel.open();</p>
<p>ssc.configureBlocking( false );</p>
<p>ServerSocket ss = ssc.socket();
InetSocketAddress address = new InetSocketAddress( ports[i] );</p>
<p>ss.bind( address );</p>
<p>第一行创建一个新的 </p>
<p>ServerSocketChannel
 ，最后三行将它绑定到给定的端口。第二行将 </p>
<p>ServerSocketChannel
 设置为 <em>非阻塞的 </em>。我们必须对每一个要使用的套接字通道调用这个方法，否则异步 I/O 就不能工作。</p>
<p><strong>选择键</strong></p>
<p>下一步是将新打开的 </p>
<p>ServerSocketChannels
 注册到 </p>
<p>Selector
上。为此我们使用 ServerSocketChannel.register() 方法，如下所示：
SelectionKey key = ssc.register( selector, SelectionKey.OP_ACCEPT );</p>
<p>register()
 的第一个参数总是这个 </p>
<p>Selector
。第二个参数是 </p>
<p>OP_ACCEPT
，这里它指定我们想要监听 <em>accept</em> 事件，也就是在新的连接建立时所发生的事件。这是适用于 </p>
<p>ServerSocketChannel
 的唯一事件类型。</p>
<p>请注意对 </p>
<p>register()
 的调用的返回值。 </p>
<p>SelectionKey
 代表这个通道在此 </p>
<p>Selector
 上的这个注册。当某个 </p>
<p>Selector
 通知您某个传入事件时，它是通过提供对应于该事件的 </p>
<p>SelectionKey
 来进行的。</p>
<p>SelectionKey
 还可以用于取消通道的注册。</p>
<p><strong>内部循环</strong></p>
<p>现在已经注册了我们对一些 I/O 事件的兴趣，下面将进入主循环。使用 </p>
<p>Selectors
 的几乎每个程序都像下面这样使用内部循环：
int num = selector.select();</p>
<p>Set selectedKeys = selector.selectedKeys();</p>
<p>Iterator it = selectedKeys.iterator();</p>
<p>while (it.hasNext()) {
     SelectionKey key = (SelectionKey)it.next();</p>
<pre><code> // ... deal with I/O event ...
</code></pre><p>}</p>
<p>首先，我们调用 </p>
<p>Selector
 的 </p>
<p>select()
 方法。这个方法会阻塞，直到至少有一个已注册的事件发生。当一个或者更多的事件发生时，</p>
<p>select()
 方法将返回所发生的事件的数量。</p>
<p>接下来，我们调用 </p>
<p>Selector
 的 </p>
<p>selectedKeys()
 方法，它返回发生了事件的 </p>
<p>SelectionKey
 对象的一个 </p>
<p>集合 
。</p>
<p>我们通过迭代 </p>
<p>SelectionKeys
 并依次处理每个 </p>
<p>SelectionKey
 来处理事件。对于每一个 </p>
<p>SelectionKey
，您必须确定发生的是什么 I/O 事件，以及这个事件影响哪些 I/O 对象。</p>
<p><strong>监听新连接</strong></p>
<p>程序执行到这里，我们仅注册了 </p>
<p>ServerSocketChannel
，并且仅注册它们“接收”事件。为确认这一点，我们对 </p>
<p>SelectionKey
 调用</p>
<p>readyOps()
 方法，并检查发生了什么类型的事件：
if ((key.readyOps() &amp; SelectionKey.OP_ACCEPT)</p>
<pre><code> == SelectionKey.OP_ACCEPT) {


 // Accept the new connection
 // ...
</code></pre><p>}</p>
<p>可以肯定地说， </p>
<p>readOps()
 方法告诉我们该事件是新的连接。</p>
<p><strong>接收新的连接</strong></p>
<p>因为我们知道这个服务器套接字上有一个传入连接在等待，所以可以安全地接受它；也就是说，不用担心 </p>
<p>accept()
 操作会阻塞：
ServerSocketChannel ssc = (ServerSocketChannel)key.channel();</p>
<p>SocketChannel sc = ssc.accept();</p>
<p>下一步是将新连接的 </p>
<p>SocketChannel
 配置为非阻塞的。而且由于接受这个连接的目的是为了读取来自套接字的数据，所以我们还必须将 </p>
<p>SocketChannel
 注册到 </p>
<p>Selector
上，如下所示：
sc.configureBlocking( false );</p>
<p>SelectionKey newKey = sc.register( selector, SelectionKey.OP_READ );</p>
<p>注意我们使用 </p>
<p>register()
 的 </p>
<p>OP_READ
 参数，将 </p>
<p>SocketChannel
 注册用于 <em>读取 </em>而不是 <em>接受 </em>新连接。</p>
<p><strong>删除处理过的SelectionKey</strong></p>
<p>在处理 </p>
<p>SelectionKey
 之后，我们几乎可以返回主循环了。但是我们必须首先将处理过的 </p>
<p>SelectionKey
 从选定的键集合中删除。如果我们没有删除处理过的键，那么它仍然会在主集合中以一个激活的键出现，这会导致我们尝试再次处理它。我们调用迭代器的</p>
<p>remove()
 方法来删除处理过的 </p>
<p>SelectionKey
：
it.remove();</p>
<p>现在我们可以返回主循环并接受从一个套接字中传入的数据(或者一个传入的 I/O 事件)了。</p>
<p><strong>传入的I/O</strong></p>
<p>当来自一个套接字的数据到达时，它会触发一个 I/O 事件。这会导致在主循环中调用 </p>
<p>Selector.select()
，并返回一个或者多个 I/O 事件。这一次， </p>
<p>SelectionKey
 将被标记为 </p>
<p>OP_READ
 事件，如下所示：
} else if ((key.readyOps() &amp; SelectionKey.OP_READ)</p>
<pre><code> == SelectionKey.OP_READ) {
 // Read the data

 SocketChannel sc = (SocketChannel)key.channel();
 // ...
</code></pre><p>}</p>
<p>与以前一样，我们取得发生 I/O 事件的通道并处理它。在本例中，由于这是一个 echo server，我们只希望从套接字中读取数据并马上将它发送回去。关于这个过程的细节，请参见代码中的源代码 (MultiPortEcho.java)。</p>
<p><strong>回到主循环</strong></p>
<p>每次返回主循环，我们都要调用 </p>
<p>select
 的 </p>
<p>Selector()
方法，并取得一组 </p>
<p>SelectionKey
。每个键代表一个 I/O 事件。我们处理事件，从选定的键集中删除 </p>
<p>SelectionKey
，然后返回主循环的顶部。</p>
<p>这个程序有点过于简单，因为它的目的只是展示异步 I/O 所涉及的技术。在现实的应用程序中，您需要通过将通道从 </p>
<p>Selector
 中删除来处理关闭的通道。而且您可能要使用多个线程。这个程序可以仅使用一个线程，因为它只是一个演示，但是在现实场景中，创建一个线程池来负责 I/O 事件处理中的耗时部分会更有意义。
来源： <a href="[http://blog.csdn.net/ssjhust123/article/details/7905401](http://blog.csdn.net/ssjhust123/article/details/7905401)">[http://blog.csdn.net/ssjhust123/article/details/7905401](http://blog.csdn.net/ssjhust123/article/details/7905401)</a> </p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/NIO/">NIO</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/NIO/" class="label label-success">NIO</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:41"datetime="2014-03-07 09:54:41"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-NIO--JAVANIO总结/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-NIO--JAVANIO总结" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>





<ul id="pagination" class="pagination pagination-lg">
  <li><a class="extend prev" href="/page/52/">&laquo;</a></li><li><a class="page-number" href="/">1</a></li><li><a class="page-number" href="/page/2/">2</a></li><li><span class="space">&hellip;</span></li><li><a class="page-number" href="/page/50/">50</a></li><li><a class="page-number" href="/page/51/">51</a></li><li><a class="page-number" href="/page/52/">52</a></li><li class="active"><li><span class="page-number current">53</span></li><li><a class="page-number" href="/page/54/">54</a></li><li><a class="page-number" href="/page/55/">55</a></li><li><a class="page-number" href="/page/56/">56</a></li><li><span class="space">&hellip;</span></li></li><li><a class="page-number" href="/page/162/">162</a></li><li><a class="page-number" href="/page/163/">163</a></li><li><a class="extend next" href="/page/54/">&raquo;</a></li>
  <div class="clearfix"></div>
</ul></div><!--wapper-->
       </div><!-- ID main-col END -->
       <aside id="sidebar" class="alignright col-sx-6 col-sm-4 col-md-3 col-lg-3">
<div id="widget_search" class="widget panel panel-primary">
    <form action="//google.com/search" method="get" accept-charset="utf-8">
  <div class="input-group">
    <input class="form-control" id="searchbox" type="search" name="q" results="0" placeholder="search">
    <span class="input-group-btn">
      <button class="btn btn-default" type="submit">Go!</button>
    </span>
    <input type="hidden" name="q" value="site:itsolife.com">
  </div>
</form>
</div>

<div id="widget_category" class="widget panel panel-primary">
  <div class="panel-heading">category</div>  <div data-src='category' class='ajax_widgets'>正在加载...</div>
</div>

<div id="widget_recent_posts" class="widget panel panel-primary">
  <div class="panel-heading">recent posts</div>  <div data-src='recent_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_tagcloud" class="widget panel panel-primary">
  <div class="panel-heading">tagcloud</div>  <div data-src='tagcloud' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_latest_update_posts" class="widget panel panel-primary">
  <div class="panel-heading">最近更新</div>  <div data-src='latest_update_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_recent_comments" class="widget panel panel-primary">
  <div class="panel-heading">recent comments</div>  

<div class="list-group-item ds-recent-comments" data-num-items="6" data-show-avatars="1" data-show-time="1" data-show-title="1" data-show-admin="1" data-excerpt-length="50"></div>



</div>

</aside>
       <div class="clearfix"></div>
     </div><!-- row END -->
  </div>
  <footer id="footer" class="container">
  <div class="panel panel-info">
  <section id='footer_widget'></section>  <div class="panel-footer">
  <div id="site-info">
    <span class='author'>
  
  &copy; 2014 RobinChia
  
    &nbsp;&nbsp;</span>
  
  <span id='analytics-51la'></span><span id='analytics-google'>
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-48559895-1']);
  _gaq.push(['_trackPageview']);
  _js2load.push({src:('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'});
</script></span><span id='analytics-cnzz'>
<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_5774006'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s17.cnzz.com/stat.php%3Fid%3D5774006%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>
</span><span id='analytics-baidu'>
<script>
var _hmt = _hmt || [];
_js2load.push({src:"//hm.baidu.com/hm.js?1442f50724afc42380b51f097c43082c"});
</script>
</span>  </div>
  <div id="copyright">Site powered by <a href='http://zespia.tw/hexo/'><strong>hexo</strong></a>  update time: <em>2014-03-30 14:30:15</em></span></div>
</div>
<div class="clearfix"></div>


  </div>
  </footer>
  
        <script src="http://cdn.bootcss.com/jquery/1.10.2/jquery.min.js"></script>        
        <script src="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/js/bootstrap.min.js"></script>        
                
        <script src="http://cdn.bootcss.com/prettify/r298/prettify.min.js"></script>    <script type="text/javascript">
   var lang=["bsh", "c", "cc", "cpp", "cs", "csh", "cyc", "cv", "htm", "html",
    "java", "js", "m", "mxml", "perl", "pl", "pm", "py", "rb", "sh",
    "xhtml", "xml", "xsl"];
   var pretty_base='';
   $('script').each(function(){
	var c = $(this).attr('src');
	if (!c)
	    return;
	if (c.match(/(\/)?prettify(\.min)?\.js/i))
	{
	    var index = c.lastIndexOf('/');
	    if (index != -1)
		pretty_base = c.substr(0,index + 1);
	    return false;
	}
   })
   $('pre code').each(function(){
	var c = $(this).attr('class')
	if (!c)
	    return;
	c = c.match(/\s?(lang\-\w+)/i);
	if (c && lang.indexOf(c[1]) == -1)
	{
	    lang.push(c[1]);
	    $.getScript(pretty_base + c[1] + '.min.js');
	}
   })

    $(window).load(function(){
       $("pre").addClass("prettyprint");
       prettyPrint();
    })
</script>    
            <script type="text/javascript">
var duoshuoQuery = {short_name:"robinchia"};
_js2load.push({src:'http://static.duoshuo.com/embed.js',charset:'UTF-8'});
</script>
    
            <!--wumii_relatedItems-->
    
        <script src="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js"></script>    <script type="text/javascript">
(function($){
  $('.entry').each(function(i){
    $(this).find('img').each(function(){
      var alt = this.alt;

      if (alt){
        $(this).before('<span class="caption">' + alt + '</span>');
      }

      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox" rel="fancybox' + i + '" />');
    });
  });

  $('.fancybox').fancybox();
})(jQuery);
</script>    
        <script src="http://cdn.bootcss.com/mathjax/2.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>    <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>
    
<script type="text/javascript">
$('.ajax_widgets').each(function(){var src=$(this).attr('data-src');if(src)$(this).load('/widgets/'+src+'.html');});
$.each(_js2load,function(index,obj){loadjs(obj.src,obj.charset)});
</script>

<div id="scroll2top">
<img src="/scroll2top/arrow.png"/>
</div>
<script src="/scroll2top/scroll2top.min.js"></script>
<div id="winterland">
  <canvas></canvas>
</div>
<script src="/js/winterland.min.js"></script>

  </body>
</html>
