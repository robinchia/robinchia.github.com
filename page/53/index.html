
<!DOCTYPE HTML>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>The 53 Page | It so life</title>
<meta name="author" content="RobinChia">

<meta name="description" content="It so life">


<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<meta property="og:site_name" content="It so life"/>

<!--[if IE]><style>.testIE.IE{display:inline;}</style><![endif]-->
<!--[if lte IE 7]><link rel="stylesheet" href="/css/ie7.css" type="text/css"><![endif]-->
<!--[if (lt IE 9)&(gt IE 7)]><style>.testIE.IE8{display:inline;}</style><![endif]-->
<!--[if gt IE 8]><style>.testIE.IE9{display:inline;}</style><![endif]-->

<link href="/favicon.png" rel="icon">
<link rel="alternate" href="/atom.xml" title="It so life Feed" type="application/atom+xml">

<link rel="stylesheet" href="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/css/bootstrap.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/font-awesome/4.0.3/css/font-awesome.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/prettify/r298/prettify.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" type="text/css">
<link rel="stylesheet" href="/css/style.css" type="text/css">
<!--[if lt IE 9]>
   <style>article,aside,dialog,footer,header,section,footer,nav,figure,menu{display:block}</style>
   <script src="http://cdn.staticfile.org/html5shiv/r29/html5.min.js"></script>
   <script src="http://cdn.staticfile.org/respond.js/1.4.2/respond.min.js"></script>
<link href="http://cdn.staticfile.org/respond.js/1.4.2/respond-proxy.html" id="respond-proxy" rel="respond-proxy" />
<link href="/js/respond.proxy.gif" id="respond-redirect" rel="respond-redirect" />
<script src="/js/respond.proxy.js"></script>
   <script src="http://cdn.bootcss.com/selectivizr/1.0.2/selectivizr-min.js"></script>
<![endif]-->
<script type="text/javascript">
function loadjs(c,d){var a=document.createElement("script");a.async=!0;a.type="text/javascript";a.src=c;a.charset=d||"gbk";(document.getElementsByTagName("HEAD")[0]||document.getElementsByTagName("BODY")[0]).appendChild(a)};
var _protocol = (("https:" == document.location.protocol) ? " https://" : " http://");
var _js2load = [];
</script>

</head>
<body>
      <header id="header" class="container"><nav id="main-nav" class="navbar navbar-default navbar-fixed-top " role="navigation">
  <div class="container">
    <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
      <span class="sr-only">Toggle navigation</span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="/">It so life</a>
    </div>
    <div  class="collapse navbar-collapse">
      <ul  class="nav navbar-nav">
  
        <li><a href="/" title="Home">Home</a></li>      
        <li><a href="/about/" title="About">About</a></li>      
        <li><a href="/archives/" title="Archives">Archives</a></li>      
      <li class='dropdown'>
        <a class='dropdown-toggle' data-toggle='dropdown' href='#'>website<b class='caret'></b></a>
        <ul class='dropdown-menu pure-menu-selected'>
    
          <li><a href="//groups.google.com/forum/#!forum/pongba" title="TopLanguage">TopLanguage</a></li>    
          <li><a href="//itpub.net/" title="ITPub">ITPub</a></li>    
          <li><a href="//blog.jobbole.com/" title="Bole">Bole</a></li>    
          <li><a href="//nosql-database.org/" title="nosql">nosql</a></li>    
          <li><a href="//gitimmersion.googol.im/" title="Git">Git</a></li>    
        </ul>
      </li>
    
      </ul>
      <ul class="nav navbar-nav navbar-right">
      
        <li><a href="/atom.xml">RSS</a></li>
      
      
        <li><a href="https://twitter.com/robinchia">twitter</a></li>
      
      
      
      
        <li><a href="https://github.com/robinchia">github</a></li>
      
      </ul>
    </div>
  </div>
</nav>
<div class="clearfix"></div>
</header>
  <div id='content' class="container">
     <div class="page-header-wrapper">
      <!--[if lt IE 9]><div class="alert alert-warning alert-dismissable"><button type="button" class="close" data-dismiss="alert" aria-hidden="true">&times;</button><strong>提示:</strong>您的浏览器版本太低了,建议升级到 <strong><a href="http://windows.microsoft.com/zh-cn/internet-explorer/download-ie" title="IE9">IE9</a></strong> 以上,本站使用<a href="https://www.google.com/intl/zh-CN/chrome/">Chrome浏览器</a>可以获得最好的显示效果.</div><![endif]-->
      <div class="page-header"><h1 align="center"><big>It so life</big> </h1>
        <h5 align="center"><big>love as life</big></h5>
      </div>
     </div>
     <div class="row">
       <div id="main-col" class="alignleft col-sx-12 col-sm-8 col-md-9 col-lg-9">
      <section id='header_widget'></section>
          <div id="wrapper"><article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--JVM调优的-标准参数-的各种陷阱/">JVM调优的</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:42.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--JVM调优的-标准参数-的各种陷阱/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="jvm-">JVM调优的&quot;标准参数&quot;的各种陷阱</h1>
<p><a href="http://hllvm.group.iteye.com/login" title="登录" target="_blank">您还未登录 !</a> <a href="http://hllvm.group.iteye.com/login" target="_blank">登录</a> <a href="http://hllvm.group.iteye.com/signup" target="_blank">注册</a></p>
<p><a href="http://www.iteye.com/" target="_blank"><img src="&quot;ITeye-最棒的软件开发交流社区&quot;" alt="ITeye3.0"></a></p>
<p><a href="http://www.iteye.com/groups" target="_blank">群组首页</a> → <a href="http://hllvm.group.iteye.com/groups/category/language" target="_blank">编程语言</a> → <a href="http://hllvm.group.iteye.com/" target="_blank">高级语言虚拟机</a> → <a href="http://hllvm.group.iteye.com/group/forum" target="_blank">论坛</a></p>
<p><img src="" alt=""> <a href="http://hllvm.group.iteye.com/group/topic/27945/post/new" target="_blank">发表回复</a></p>
<p>« 上一页 1 <a href="http://hllvm.group.iteye.com/group/topic/27945?page=2" target="_blank">2</a> <a href="http://hllvm.group.iteye.com/group/topic/27945?page=3" target="_blank">3</a> <a href="http://hllvm.group.iteye.com/group/topic/27945?page=2" target="_blank">下一页 »</a></p>
<h3 id="-http-hllvm-group-iteye-com-group-forum-tag_id-690-jvm-"><a href="http://hllvm.group.iteye.com/group/forum?tag_id=690" target="_blank">[讨论]</a> <a href="">JVM调优的&quot;标准参数&quot;的各种陷阱</a></h3>
<p><a href="http://rednaxelafx.iteye.com/" target="_blank"><img src="&quot;RednaxelaFX的博客: Script Ahead, Code Behind&quot;" alt="RednaxelaFX的博客"></a> <a href="http://rednaxelafx.iteye.com/" title="RednaxelaFX" target="_blank">RednaxelaFX</a> 2011-10-23</p>
<p>开个帖大家来讨论下自己遇到过的情况吧？我在顶楼举几个例子。
开这帖的目的是想让大家了解到，所谓“标准参数”是件很微妙的事情。确实有许多前辈经过多年开发积累下了许多有用的调优经验，但向他们问“标准参数”并照单全收是件危险的事情。
前辈们提供的“标准参数”或许适用于他们的应用场景，他们或许也知道这些参数里隐含的陷阱；但听众却不一定知道各种参数背后的缘由。
原则上说，在生产环境使用非标准参数（这里指的是在各JDK/JRE实现特有的、相互之间不通用的参数）应该尽量避免。这些参数与具体实现密切相关，不是光了解很抽象的“JVM原理”就足以理解的；即便在同一系列的JDK/JRE实现中，非标准参数也不保证在各版本间有一样的作用；而且许多人只看名字就猜想参数的左右，做“调优”却适得其反。
非标准参数的默认值在不同版本间或许会悄然发生变化。这些变化的背后多半有合理的理由。设了一大堆非标准参数、不明就里的同学在升级JDK/JRE的时候也容易掉坑里。
下面用<strong>Oracle/Sun JDK 6</strong>来举几个例子。这帖顶楼里的讨论如果没明确指出JDK版本的都是指Oracle/Sun JDK 6（OpenJDK 6也可以算在内）。</p>
<h1 id="-sun-jdk-1-4-2-sun-jdk-5-oracle-jdk-7-">经验不一定适用于Sun JDK 1.4.2、Sun JDK 5、Oracle JDK 7。</h1>
<p>0、各参数的默认值
在讨论HotSpot VM的各参数的陷阱前，大家应该先了解HotSpot VM到底有哪些参数可以设置，这些参数的默认值都是什么。
有几种办法可以帮助大家获取参数的信息。首先为了大致了解都有些什么参数可以设置，可以参考HotSpot VM里的各个globals.hpp文件：（以下链接取自HotSpot 20.0，与JDK 6 update 25对应）
<a href="http://hg.openjdk.java.net/hsx/hsx20/master/file/f0f676c5a2c6/src/share/vm/runtime/globals.hpp" target="_blank">globals.hpp</a>
<a href="http://hg.openjdk.java.net/hsx/hsx20/master/file/f0f676c5a2c6/src/share/vm/runtime/globals_extension.hpp" target="_blank">globals_extension.hpp</a>
<a href="http://hg.openjdk.java.net/hsx/hsx20/master/file/f0f676c5a2c6/src/share/vm/c1/c1_globals.hpp" target="_blank">c1_globals.hpp</a>
<a href="http://hg.openjdk.java.net/hsx/hsx20/master/file/f0f676c5a2c6/src/os/linux/vm/c1_globals_linux.hpp" target="_blank">c1_globals_linux.hpp</a>
<a href="http://hg.openjdk.java.net/hsx/hsx20/master/file/f0f676c5a2c6/src/os/solaris/vm/c1_globals_solaris.hpp" target="_blank">c1_globals_solaris.hpp</a>
<a href="http://hg.openjdk.java.net/hsx/hsx20/master/file/f0f676c5a2c6/src/cpu/sparc/vm/c1_globals_sparc.hpp" target="_blank">c1_globals_sparc.hpp</a>
<a href="http://hg.openjdk.java.net/hsx/hsx20/master/file/f0f676c5a2c6/src/os/windows/vm/c1_globals_windows.hpp" target="_blank">c1_globals_windows.hpp</a>
<a href="http://hg.openjdk.java.net/hsx/hsx20/master/file/f0f676c5a2c6/src/cpu/x86/vm/c1_globals_x86.hpp" target="_blank">c1_globals_x86.hpp</a>
<a href="http://hg.openjdk.java.net/hsx/hsx20/master/file/f0f676c5a2c6/src/share/vm/opto/c2_globals.hpp" target="_blank">c2_globals.hpp</a>
<a href="http://hg.openjdk.java.net/hsx/hsx20/master/file/f0f676c5a2c6/src/os/linux/vm/c2_globals_linux.hpp" target="_blank">c2_globals_linux.hpp</a>
<a href="http://hg.openjdk.java.net/hsx/hsx20/master/file/f0f676c5a2c6/src/os/solaris/vm/c2_globals_solaris.hpp" target="_blank">c2_globals_solaris.hpp</a>
<a href="http://hg.openjdk.java.net/hsx/hsx20/master/file/f0f676c5a2c6/src/cpu/sparc/vm/c2_globals_sparc.hpp" target="_blank">c2_globals_sparc.hpp</a>
<a href="http://hg.openjdk.java.net/hsx/hsx20/master/file/f0f676c5a2c6/src/os/windows/vm/c2_globals_windows.hpp" target="_blank">c2_globals_windows.hpp</a>
<a href="http://hg.openjdk.java.net/hsx/hsx20/master/file/f0f676c5a2c6/src/cpu/x86/vm/c2_globals_x86.hpp" target="_blank">c2_globals_x86.hpp</a>
<a href="http://hg.openjdk.java.net/hsx/hsx20/master/file/f0f676c5a2c6/src/share/vm/gc_implementation/g1/g1_globals.hpp" target="_blank">g1_globals.hpp</a>
<a href="http://hg.openjdk.java.net/hsx/hsx20/master/file/f0f676c5a2c6/src/os/linux/vm/globals_linux.hpp" target="_blank">globals_linux.hpp</a>
<a href="http://hg.openjdk.java.net/hsx/hsx20/master/file/f0f676c5a2c6/src/os_cpu/linux_sparc/vm/globals_linux_sparc.hpp" target="_blank">globals_linux_sparc.hpp</a>
<a href="http://hg.openjdk.java.net/hsx/hsx20/master/file/f0f676c5a2c6/src/os_cpu/linux_x86/vm/globals_linux_x86.hpp" target="_blank">globals_linux_x86.hpp</a>
<a href="http://hg.openjdk.java.net/hsx/hsx20/master/file/f0f676c5a2c6/src/os_cpu/linux_zero/vm/globals_linux_zero.hpp" target="_blank">globals_linux_zero.hpp</a>
<a href="http://hg.openjdk.java.net/hsx/hsx20/master/file/f0f676c5a2c6/src/os/solaris/vm/globals_solaris.hpp" target="_blank">globals_solaris.hpp</a>
<a href="http://hg.openjdk.java.net/hsx/hsx20/master/file/f0f676c5a2c6/src/os_cpu/solaris_sparc/vm/globals_solaris_sparc.hpp" target="_blank">globals_solaris_sparc.hpp</a>
<a href="http://hg.openjdk.java.net/hsx/hsx20/master/file/f0f676c5a2c6/src/os_cpu/solaris_x86/vm/globals_solaris_x86.hpp" target="_blank">globals_solaris_x86.hpp</a>
<a href="http://hg.openjdk.java.net/hsx/hsx20/master/file/f0f676c5a2c6/src/cpu/sparc/vm/globals_sparc.hpp" target="_blank">globals_sparc.hpp</a>
<a href="http://hg.openjdk.java.net/hsx/hsx20/master/file/f0f676c5a2c6/src/os/windows/vm/globals_windows.hpp" target="_blank">globals_windows.hpp</a>
<a href="http://hg.openjdk.java.net/hsx/hsx20/master/file/f0f676c5a2c6/src/os_cpu/windows_x86/vm/globals_windows_x86.hpp" target="_blank">globals_windows_x86.hpp</a>
<a href="http://hg.openjdk.java.net/hsx/hsx20/master/file/f0f676c5a2c6/src/cpu/x86/vm/globals_x86.hpp" target="_blank">globals_x86.hpp</a>
<a href="http://hg.openjdk.java.net/hsx/hsx20/master/file/f0f676c5a2c6/src/cpu/zero/vm/globals_zero.hpp" target="_blank">globals_zero.hpp</a>
<a href="http://hg.openjdk.java.net/hsx/hsx20/master/file/f0f676c5a2c6/src/share/vm/shark/shark_globals.hpp" target="_blank">shark_globals.hpp</a>
<a href="http://hg.openjdk.java.net/hsx/hsx20/master/file/f0f676c5a2c6/src/cpu/zero/vm/shark_globals_zero.hpp" target="_blank">shark_globals_zero.hpp</a>
<a href="http://hg.openjdk.java.net/hsx/hsx20/master/file/f0f676c5a2c6/src/share/vm/runtime/arguments.cpp" target="_blank">arguments.cpp</a>
然后是 <strong>-XX:+PrintCommandLineFlags</strong> 。这个参数的作用是显示出VM初始化完毕后所有跟最初的默认值不同的参数及它们的值。
这个参数至少在Sun JDK 5上已经开始支持，Oracle/Sun JDK 6以及Oracle JDK 7上也可以使用。Sun JDK 1.4.2还不支持这个参数。
例子：
Command prompt代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>$ java -XX:+PrintCommandLineFlags  </li>
<li>VM option &#39;+PrintCommandLineFlags&#39;  </li>
<li><p>-XX:InitialHeapSize=57344000 -XX:MaxHeapSize=917504000 -XX:ParallelGCThreads=4 -XX:+PrintCommandLineFlags -XX:+UseCompressedOops -XX:+UseParallelGC<br>$ java -XX:+PrintCommandLineFlags VM option &#39;+PrintCommandLineFlags&#39; -XX:InitialHeapSize=57344000 -XX:MaxHeapSize=917504000 -XX:ParallelGCThreads=4 -XX:+PrintCommandLineFlags -XX:+UseCompressedOops -XX:+UseParallelGC
<a href="http://book.douban.com/annotation/15146892/" target="_blank">《Java Performance》一书</a>主要是用这个参数来介绍HotSpot VM各参数的效果的。
接着是 <strong>-XX:+PrintFlagsFinal</strong> 。前一个参数只显示跟默认值不同的，而这个参数则可以显示所有可设置的参数及它们的值。不过这个参数本身只从JDK 6 update 21开始才可以用，之前的Oracle/Sun JDK则用不了。
可以设置的参数默认是不包括diagnostic或experimental系的。要在-XX:+PrintFlagsFinal的输出里看到这两种参数的信息，分别需要显式指定<strong>-XX:+UnlockDiagnosticVMOptions</strong> / <strong>-XX:+UnlockExperimentalVMOptions</strong> 。
再下来，<strong>-XX:+PrintFlagsInitial</strong> 。这个参数显示在处理参数之前所有可设置的参数及它们的值，然后直接退出程序。“参数处理”包括许多步骤，例如说检查参数之间是否有冲突，通过ergonomics调整某些参数的值，之类的。
结合-XX:+PrintFlagsInitial与-XX:+PrintFlagsFinal，对比两者的差异，就可以知道ergonomics对哪些参数做了怎样的调整。
这两个参数的例子：
Command prompt代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>$ java -version  </p>
</li>
<li>java version &quot;1.6.0_29&quot;  </li>
<li>Java(TM) SE Runtime Environment (build 1.6.0_29-b11)  </li>
<li>Java HotSpot(TM) 64-Bit Server VM (build 20.4-b02, mixed mode)  </li>
<li>$ java -XX:+PrintFlagsInitial | grep UseCompressedOops  </li>
<li>bool UseCompressedOops                         = false           {lp64_product}        </li>
<li>$ java -XX:+PrintFlagsFinal | grep UseCompressedOops  </li>
<li><p>bool UseCompressedOops                        := true            {lp64_product}<br>$ java -version java version &quot;1.6.0_29&quot; Java(TM) SE Runtime Environment (build 1.6.0_29-b11) Java HotSpot(TM) 64-Bit Server VM (build 20.4-b02, mixed mode) $ java -XX:+PrintFlagsInitial | grep UseCompressedOops bool UseCompressedOops = false {lp64_product} $ java -XX:+PrintFlagsFinal | grep UseCompressedOops bool UseCompressedOops := true {lp64_product}
<a href="http://rednaxelafx.iteye.com/blog/1010079" target="_blank">Oracle/Sun JDK 6从update 23开始会由ergonomics在合适的条件下默认启用压缩指针功能</a>。这个例子演示的是UseCompressedOops的初始默认值是false，由PrintFlagsInitial的输出可以看到；然后经过ergonomics自动调整后，最终采用的默认值是true，由PrintFlagsFinal的输出可以看到。
输出里“=”表示使用的是初始默认值，而“:=”表示使用的不是初始默认值，可能是命令行传进来的参数、配置文件里的参数或者是ergonomics自动选择了别的值。
除了在VM启动时传些特殊的参数让它打印出自己的各参数外，<strong>jinfo -flag</strong> 可以用来查看某个参数的值，也可以用来设定manageable系参数的值。请参考这帖的例子：<a href="http://rednaxelafx.iteye.com/blog/1049240" target="_blank">通过jinfo工具在full GC前后做heap dump</a></p>
<h1 id="-hotspot-vm-http-rednaxelafx-iteye-com-blog-906807-">之前发过<a href="http://rednaxelafx.iteye.com/blog/906807" target="_blank">某些环境中HotSpot VM的各参数的默认值</a>，可以参考一下。</h1>
<p>1、-XX:+DisableExplicitGC 与 NIO的direct memory
很多人都见过JVM调优建议里使用这个参数，对吧？但是为什么要用它，什么时候应该用而什么时候用了会掉坑里呢？
首先要了解的是这个参数的作用。在Oracle/Sun JDK这个具体实现上，System.gc()的默认效果是引发一次stop-the-world的full GC，对整个GC堆做收集。有几个参数可以改变默认行为，之前<a href="http://rednaxelafx.iteye.com/blog/1042471" target="_blank">发过一帖简单描述</a>过，这里就不重复了。关键点是，用了-XX:+DisableExplicitGC参数后，System.gc()的调用就会变成一个空调用，完全不会触发任何GC（但是“函数调用”本身的开销还是存在的哦～）。
为啥要用这个参数呢？最主要的原因是为了防止某些手贱的同学在代码里到处写System.gc()的调用而干扰了程序的正常运行吧。有些应用程序本来可能正常跑一天也不会出一次full GC，但就是因为有人在代码里调用了System.gc()而不得不间歇性被暂停。也有些时候这些调用是在某些库或框架里写的，改不了它们的代码但又不想被这些调用干扰也会用这参数。
OK。看起来这参数应该总是开着嘛。有啥坑呢？
其中一种情况是下述三个条件同时满足时会发生的：
1、应用本身在GC堆内的对象行为良好，正常情况下很久都不发生full GC；
2、应用大量使用了NIO的direct memory，经常、反复的申请DirectByteBuffer
3、使用了-XX:+DisableExplicitGC
能观察到的现象是：
Log代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>java.lang.OutOfMemoryError: Direct buffer memory  </p>
</li>
<li>at java.nio.Bits.reserveMemory(Bits.java:633)  </li>
<li>at java.nio.DirectByteBuffer.<init>(DirectByteBuffer.java:98)  </li>
<li>at java.nio.ByteBuffer.allocateDirect(ByteBuffer.java:288)  </li>
<li><p>...<br>java.lang.OutOfMemoryError: Direct buffer memory at java.nio.Bits.reserveMemory(Bits.java:633) at java.nio.DirectByteBuffer.<init>(DirectByteBuffer.java:98) at java.nio.ByteBuffer.allocateDirect(ByteBuffer.java:288) ...
做个简单的例子来演示这现象：
Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>import java.nio./*;  </p>
</li>
<li></li>
<li>public class DisableExplicitGCDemo {  </li>
<li>public static void main(String[] args) {  </li>
<li>for (int i = 0; i &lt; 100000; i++) {  </li>
<li>ByteBuffer.allocateDirect(128);  </li>
<li>}  </li>
<li>System.out.println(&quot;Done&quot;);  </li>
<li>}  </li>
<li><p>}<br>import java.nio./*; public class DisableExplicitGCDemo { public static void main(String[] args) { for (int i = 0; i &lt; 100000; i++) { ByteBuffer.allocateDirect(128); } System.out.println(&quot;Done&quot;); } }
然后编译、运行之：
Command prompt代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>$ java -version  </p>
</li>
<li>java version &quot;1.6.0_25&quot;  </li>
<li>Java(TM) SE Runtime Environment (build 1.6.0_25-b06)  </li>
<li>Java HotSpot(TM) 64-Bit Server VM (build 20.0-b11, mixed mode)  </li>
<li>$ javac DisableExplicitGCDemo.java   </li>
<li>$ java -XX:MaxDirectMemorySize=10m -XX:+PrintGC -XX:+DisableExplicitGC DisableExplicitGCDemo  </li>
<li>Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Direct buffer memory  </li>
<li>at java.nio.Bits.reserveMemory(Bits.java:633)  </li>
<li>at java.nio.DirectByteBuffer.<init>(DirectByteBuffer.java:98)  </li>
<li>at java.nio.ByteBuffer.allocateDirect(ByteBuffer.java:288)  </li>
<li>at DisableExplicitGCDemo.main(DisableExplicitGCDemo.java:6)  </li>
<li>$ java -XX:MaxDirectMemorySize=10m -XX:+PrintGC DisableExplicitGCDemo  </li>
<li>[GC 10996K-&gt;10480K(120704K), 0.0433980 secs]  </li>
<li>[Full GC 10480K-&gt;10415K(120704K), 0.0359420 secs]  </li>
<li><p>Done<br>$ java -version java version &quot;1.6.0_25&quot; Java(TM) SE Runtime Environment (build 1.6.0_25-b06) Java HotSpot(TM) 64-Bit Server VM (build 20.0-b11, mixed mode) $ javac DisableExplicitGCDemo.java $ java -XX:MaxDirectMemorySize=10m -XX:+PrintGC -XX:+DisableExplicitGC DisableExplicitGCDemo Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Direct buffer memory at java.nio.Bits.reserveMemory(Bits.java:633) at java.nio.DirectByteBuffer.<init>(DirectByteBuffer.java:98) at java.nio.ByteBuffer.allocateDirect(ByteBuffer.java:288) at DisableExplicitGCDemo.main(DisableExplicitGCDemo.java:6) $ java -XX:MaxDirectMemorySize=10m -XX:+PrintGC DisableExplicitGCDemo [GC 10996K-&gt;10480K(120704K), 0.0433980 secs] [Full GC 10480K-&gt;10415K(120704K), 0.0359420 secs] Done
可以看到，同样的程序，不带-XX:+DisableExplicitGC时能正常完成运行，而带上这个参数后却出现了OOM。
例子里用-XX:MaxDirectMemorySize=10m限制了DirectByteBuffer能分配的空间的限额，以便问题更容易展现出来。不用这个参数就得多跑一会儿了。
在这个例子里，main()里的循环不断申请DirectByteBuffer但并没有引用、使用它们，所以这些DirectByteBuffer应该刚创建出来就已经满足被GC的条件，等下次GC运行的时候就应该可以被回收。
实际上却没这么简单。DirectByteBuffer是种典型的“冰山”对象，也就是说它的Java对象虽然很小很无辜，但它背后却会关联着一定量的native memory资源，而这些资源并不在GC的控制之下，需要自己注意控制好。对JVM如何使用native memory不熟悉的同学可以参考去年JavaOne上IBM的一个演讲，“Where Does All the Native Memory Go”。
Oracle/Sun JDK的实现里，DirectByteBuffer有几处值得注意的地方。
1、DirectByteBuffer没有finalizer，它的native memory的清理工作是通过sun.misc.Cleaner自动完成的。
2、sun.misc.Cleaner是一种基于PhantomReference的清理工具，比普通的finalizer轻量些。对PhantomReference不熟悉的同学请参考Bob Lee最近几年在JavaOne上做的演讲，<a href="http://www.parleys.com/d/2657" target="_blank">&quot;The Ghost in the Virtual Machine: A Reference to References&quot;</a>。<a href="https://oracleus.wingateweb.com/scheduler/eventcatalog/eventCatalogJavaOne.do" target="_blank">今年的JavaOne</a>上他也讲了同一个主题，内容比前几年的稍微更新了些。PPT可以从链接里的页面下载到。
Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>//<em>/</em> </p>
</li>
<li>/* General-purpose phantom-reference-based cleaners. </li>
<li>/* </li>
<li>/* <p> Cleaners are a lightweight and more robust alternative to finalization. </li>
<li>/* They are lightweight because they are not created by the VM and thus do not </li>
<li>/* require a JNI upcall to be created, and because their cleanup code is </li>
<li>/* invoked directly by the reference-handler thread rather than by the </li>
<li>/* finalizer thread.  They are more robust because they use phantom references, </li>
<li>/* the weakest type of reference object, thereby avoiding the nasty ordering </li>
<li>/* problems inherent to finalization. </li>
<li>/* </li>
<li>/* <p> A cleaner tracks a referent object and encapsulates a thunk of arbitrary </li>
<li>/* cleanup code.  Some time after the GC detects that a cleaner&#39;s referent has </li>
<li>/* become phantom-reachable, the reference-handler thread will run the cleaner. </li>
<li>/* Cleaners may also be invoked directly; they are thread safe and ensure that </li>
<li>/* they run their thunks at most once. </li>
<li>/* </li>
<li>/* <p> Cleaners are not a replacement for finalization.  They should be used </li>
<li>/* only when the cleanup code is extremely simple and straightforward. </li>
<li>/* Nontrivial cleaners are inadvisable since they risk blocking the </li>
<li>/* reference-handler thread and delaying further cleanup and finalization. </li>
<li>/* </li>
<li>/* </li>
<li>/* @author Mark Reinhold </li>
<li>/* @version %I%, %E% </li>
<li><p>/<em>/<br>//</em>/<em> /</em> General-purpose phantom-reference-based cleaners. /<em> /</em> <p> Cleaners are a lightweight and more robust alternative to finalization. /<em> They are lightweight because they are not created by the VM and thus do not /</em> require a JNI upcall to be created, and because their cleanup code is /<em> invoked directly by the reference-handler thread rather than by the /</em> finalizer thread. They are more robust because they use phantom references, /<em> the weakest type of reference object, thereby avoiding the nasty ordering /</em> problems inherent to finalization. /<em> /</em> <p> A cleaner tracks a referent object and encapsulates a thunk of arbitrary /<em> cleanup code. Some time after the GC detects that a cleaner&#39;s referent has /</em> become phantom-reachable, the reference-handler thread will run the cleaner. /<em> Cleaners may also be invoked directly; they are thread safe and ensure that /</em> they run their thunks at most once. /<em> /</em> <p> Cleaners are not a replacement for finalization. They should be used /<em> only when the cleanup code is extremely simple and straightforward. /</em> Nontrivial cleaners are inadvisable since they risk blocking the /<em> reference-handler thread and delaying further cleanup and finalization. /</em> /<em> /</em> @author Mark Reinhold /<em> @version %I%, %E% /</em>/
重点是这两句：&quot;A cleaner tracks a referent object and encapsulates a thunk of arbitrary cleanup code.  Some time after the GC detects that a cleaner&#39;s referent has become phantom-reachable, the reference-handler thread will run the cleaner.&quot;
Oracle/Sun JDK 6中的HotSpot VM只会在old gen GC（full GC/major GC或者concurrent GC都算）的时候才会对old gen中的对象做reference processing，而在young GC/minor GC时只会对young gen里的对象做reference processing。
（死在young gen中的DirectByteBuffer对象会在young GC时被处理的例子，请参考这里：<a href="https://gist.github.com/1614952" target="_blank"><a href="https://gist.github.com/1614952">https://gist.github.com/1614952</a></a>）
也就是说，做full GC的话会对old gen做reference processing，进而能触发Cleaner对已死的DirectByteBuffer对象做清理工作。而如果很长一段时间里没做过GC或者只做了young GC的话则不会在old gen触发Cleaner的工作，那么就可能让本来已经死了的、但已经晋升到old gen的DirectByteBuffer关联的native memory得不到及时释放。
3、为DirectByteBuffer分配空间过程中会显式调用System.gc()，以期通过full GC来强迫已经无用的DirectByteBuffer对象释放掉它们关联的native memory：
Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>// These methods should be called whenever direct memory is allocated or  </p>
</li>
<li>// freed.  They allow the user to control the amount of direct memory  </li>
<li>// which a process may access.  All sizes are specified in bytes.  </li>
<li>static void reserveMemory(long size) {  </li>
<li></li>
<li>synchronized (Bits.class) {  </li>
<li>if (!memoryLimitSet &amp;&amp; VM.isBooted()) {  </li>
<li>maxMemory = VM.maxDirectMemory();  </li>
<li>memoryLimitSet = true;  </li>
<li>}  </li>
<li>if (size &lt;= maxMemory - reservedMemory) {  </li>
<li>reservedMemory += size;  </li>
<li>return;  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>System.gc();  </li>
<li>try {  </li>
<li>Thread.sleep(100);  </li>
<li>} catch (InterruptedException x) {  </li>
<li>// Restore interrupt status  </li>
<li>Thread.currentThread().interrupt();  </li>
<li>}  </li>
<li>synchronized (Bits.class) {  </li>
<li>if (reservedMemory + size &gt; maxMemory)  </li>
<li>throw new OutOfMemoryError(&quot;Direct buffer memory&quot;);  </li>
<li>reservedMemory += size;  </li>
<li>}  </li>
<li></li>
<li>}<br>// These methods should be called whenever direct memory is allocated or // freed. They allow the user to control the amount of direct memory // which a process may access. All sizes are specified in bytes. static void reserveMemory(long size) { synchronized (Bits.class) { if (!memoryLimitSet &amp;&amp; VM.isBooted()) { maxMemory = VM.maxDirectMemory(); memoryLimitSet = true; } if (size &lt;= maxMemory - reservedMemory) { reservedMemory += size; return; } } System.gc(); try { Thread.sleep(100); } catch (InterruptedException x) { // Restore interrupt status Thread.currentThread().interrupt(); } synchronized (Bits.class) { if (reservedMemory + size &gt; maxMemory) throw new OutOfMemoryError(&quot;Direct buffer memory&quot;); reservedMemory += size; } }
这几个实现特征使得Oracle/Sun JDK 6依赖于System.gc()触发GC来保证DirectByteMemory的清理工作能及时完成。如果打开了-XX:+DisableExplicitGC，清理工作就可能得不到及时完成，于是就有机会见到direct memory的OOM，也就是上面的例子演示的情况。我们这边在实际生产环境中确实遇到过这样的问题。<h1 id="-oracle-sun-jdk-6-direct-memory-xx-disableexplicitgc-direct-memory-oom-oom-system-gc-full-gc-xx-explicitgcinvokesconcurrent-">教训是：如果你在使用Oracle/Sun JDK 6，应用里有任何地方用了direct memory，那么使用-XX:+DisableExplicitGC要小心。如果用了该参数而且遇到direct memory的OOM，可以尝试去掉该参数看是否能避开这种OOM。如果担心System.gc()调用造成full GC频繁，可以尝试下面提到 -XX:+ExplicitGCInvokesConcurrent 参数</h1>
2、-XX:+DisableExplicitGC 与 Remote Method Invocation (RMI) 与 -Dsun.rmi.dgc.{server|client}.gcInterval=
看了上一个例子有没有觉得-XX:+DisableExplicitGC参数用起来很危险？那干脆完全不要用这个参数吧。又有什么坑呢？
前段时间有个应用的开发来抱怨，说某次升级JDK之前那应用的GC状况都很好，很长时间都不会发生full GC，但升级后发现每一小时左右就会发生一次。经过对比发现，升级的同时也吧启动参数改了，把原本有的-XX:+DisableExplicitGC给去掉了。
观察到的日志有明显特征。一位同事表示：
引用</li>
</ol>
<p>线上机器出现一个场景；每隔1小时出现一次Full GC,用btrace看了一下调用地：
who call system.gc :
sun.misc.GC$Daemon.run(GC.java:92)
预发机没什么流量，也会每一小时一次Full GC
频率正好是一小时一次
Gc log代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>2011-09-23T10:49:38.071+0800: 327692.227: [Full GC (System) 327692.227: [CMS: 75793K-&gt;75759K(2097152K), 0.6923690 secs] 430298K-&gt;75759K(3984640K), [CMS Perm : 104136K-&gt;104124K(173932K)], 0.6925570 secs]<br>2011-09-23T10:49:38.071+0800: 327692.227: [Full GC (System) 327692.227: [CMS: 75793K-&gt;75759K(2097152K), 0.6923690 secs] 430298K-&gt;75759K(3984640K), [CMS Perm : 104136K-&gt;104124K(173932K)], 0.6925570 secs]
实际上这里在做的是分布式GC。Sun JDK的分布式GC是用纯Java实现的，为RMI服务。
RMI DGC相关参数的介绍文档：<a href="http://docs.oracle.com/javase/6/docs/technotes/guides/rmi/sunrmiproperties.html" target="_blank"><a href="http://docs.oracle.com/javase/6/docs/technotes/guides/rmi/sunrmiproperties.html">http://docs.oracle.com/javase/6/docs/technotes/guides/rmi/sunrmiproperties.html</a></a>
（后面回头再补…先睡觉去了）
资料：
<a href="http://java.sun.com/developer/onlineTraining/rmi/exercises/DistributedGarbageCollector/index.html" target="_blank">jGuru: Distributed Garbage Collection</a>
<a href="http://mail.openjdk.java.net/pipermail/hotspot-dev/2011-December/004909.html" target="_blank"><a href="http://mail.openjdk.java.net/pipermail/hotspot-dev/2011-December/004909.html">http://mail.openjdk.java.net/pipermail/hotspot-dev/2011-December/004909.html</a></a>
Tony Printezis 写道</li>
</ol>
<p>RMI has a distributed GC that relies on reference processing to allow
each node to recognize that some objects are unreachable so it can
notify a remote node (or nodes) that some remote references to them do
not exist any more. The remote node might then be able to reclaim
objects that are only remotely reachable. (Or this is how I understood
it at least.)
RMI used to call System.gc() once a minute (!!!) but after some
encouragement from yours truly they changed the default to once an hour
(this is configurable using a property). Note that a STW Full GC is not
really required as long as references are processed. So, in CMS (and
G1), a concurrent cycle is fine which is why we recommend to use
-XX:+ExplicitGCInvokesConcurrent in this case.
I had been warned by the RMI folks against totally disabling those
System.gc()&#39;s (e.g., using -XX:+DisableExplicitGC) given that if Full
GCs / concurrent cycles do not otherwise happen at a reasonable
frequency then remote nodes might experience memory leaks since they
will consider that some otherwise unreachable remote references are
still live. I have no idea how severe such memory leaks would be. I
guess they&#39;d be very application-dependent.
An additional thought that just occurred to me: instead of calling
System.gc() every hour what RMI should really be doing is calling
System.gc() every hour provided no old gen GC has taken place during the
last hour. This would be relatively easy to implement by accessing the
old GC counter through the GC MXBeans.
Tony
再加俩链接：<a href="http://mail.openjdk.java.net/pipermail/hotspot-dev/2012-January/004929.html" target="_blank"><a href="http://mail.openjdk.java.net/pipermail/hotspot-dev/2012-January/004929.html">http://mail.openjdk.java.net/pipermail/hotspot-dev/2012-January/004929.html</a></a>
<a href="http://mail.openjdk.java.net/pipermail/hotspot-dev/2012-January/004946.html" target="_blank"><a href="http://mail.openjdk.java.net/pipermail/hotspot-dev/2012-January/004946.html">http://mail.openjdk.java.net/pipermail/hotspot-dev/2012-January/004946.html</a></a></p>
<h1 id="-java-performance-303-411-xx-disableexplicitgc-rmi-">《Java Performance》的303和411页正好也提到了-XX:+DisableExplicitGC与RMI之间的干扰的事情，有兴趣可以读一下，虽然只有一小段。</h1>
<p>3、-XX:+ExplicitGCInvokesConcurrent 或 -XX:+ExplicitGCInvokesConcurrentAndUnloadsClasses
C++代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>product(bool, ExplicitGCInvokesConcurrent, false,                  \  </li>
<li>&quot;A System.gc() request invokes a concurrent collection;&quot;         \  </li>
<li>&quot; (effective only when UseConcMarkSweepGC)&quot;)                     \  </li>
<li>\  </li>
<li>product(bool, ExplicitGCInvokesConcurrentAndUnloadsClasses, false, \  </li>
<li>&quot;A System.gc() request invokes a concurrent collection and &quot;     \  </li>
<li>&quot;also unloads classes during such a concurrent gc cycle &quot;        \  </li>
<li><p>&quot;(effective only when UseConcMarkSweepGC)&quot;)                      \<br>product(bool, ExplicitGCInvokesConcurrent, false, \ &quot;A System.gc() request invokes a concurrent collection;&quot; \ &quot; (effective only when UseConcMarkSweepGC)&quot;) \ \ product(bool, ExplicitGCInvokesConcurrentAndUnloadsClasses, false, \ &quot;A System.gc() request invokes a concurrent collection and &quot; \ &quot;also unloads classes during such a concurrent gc cycle &quot; \ &quot;(effective only when UseConcMarkSweepGC)&quot;) \
跟上面的第一个例子的-XX:+DisableExplicitGC一样，这两个参数也是用来改变System.gc()的默认行为用的；不同的是这两个参数只能配合CMS使用（-XX:+UseConcMarkSweepGC），而且System.gc()还是会触发GC的，只不过不是触发一个完全stop-the-world的full GC，而是一次并发GC周期。
CMS GC周期中也会做reference processing。所以如果用这两个参数的其中一个，而不是用-XX:+DisableExplicitGC的话，就避开了由full GC带来的长GC pause，同时NIO direct memory的OOM也不会那么容易发生。
做了个跟第一个例子类似的例子，在这里：<a href="https://gist.github.com/1344251" target="_blank"><a href="https://gist.github.com/1344251">https://gist.github.com/1344251</a></a>
《Java Performance》的303页有讲到这俩参数。
相关bug：<a href="http://bugs.sun.com/view_bug.do?bug_id=6919638" target="_blank">6919638 CMS: ExplicitGCInvokesConcurrent misinteracts with gc locker</a></p>
<h1 id="-jdk6u23-">&lt;&lt; JDK6u23修复了这个问题</h1>
<p>4、-XX:+GCLockerInvokesConcurrent
C++代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>product(bool, GCLockerInvokesConcurrent, false,        \  </p>
</li>
<li>&quot;The exit of a JNI CS necessitating a scavenge also&quot; \  </li>
<li><p>&quot; kicks off a bkgrd concurrent collection&quot;)          \<br>product(bool, GCLockerInvokesConcurrent, false, \ &quot;The exit of a JNI CS necessitating a scavenge also&quot; \ &quot; kicks off a bkgrd concurrent collection&quot;) \</p>
<h1 id="-">（内容回头补…）</h1>
<p>5、MaxDirectMemorySize 与 NIO direct memory 的默认上限
<strong>-XX:MaxDirectMemorySize</strong> 是用来配置NIO direct memory上限用的VM参数。
C++代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>product(intx, MaxDirectMemorySize, -1,                         \  </p>
</li>
<li><p>&quot;Maximum total size of NIO direct-buffer allocations&quot;) \<br>product(intx, MaxDirectMemorySize, -1, \ &quot;Maximum total size of NIO direct-buffer allocations&quot;) \
但如果不配置它的话，direct memory默认最多能申请多少内存呢？这个参数默认值是-1，显然不是一个“有效值”。所以真正的默认值肯定是从别的地方来的。
在Sun JDK 6和OpenJDK 6里，有这样一段代码，sun.misc.VM：
Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>// A user-settable upper limit on the maximum amount of allocatable direct  </p>
</li>
<li>// buffer memory.  This value may be changed during VM initialization if  </li>
<li>// &quot;java&quot; is launched with &quot;-XX:MaxDirectMemorySize=<size>&quot;.  </li>
<li>//  </li>
<li>// The initial value of this field is arbitrary; during JRE initialization  </li>
<li>// it will be reset to the value specified on the command line, if any,  </li>
<li>// otherwise to Runtime.getRuntime().maxMemory().  </li>
<li>//  </li>
<li>private static long directMemory = 64 /<em> 1024 /</em> 1024;  </li>
<li></li>
<li>// If this method is invoked during VM initialization, it initializes the  </li>
<li>// maximum amount of allocatable direct buffer memory (in bytes) from the  </li>
<li>// system property sun.nio.MaxDirectMemorySize.  The system property will  </li>
<li>// be removed when it is accessed.  </li>
<li>//  </li>
<li>// If this method is invoked after the VM is booted, it returns the  </li>
<li>// maximum amount of allocatable direct buffer memory.  </li>
<li>//  </li>
<li>public static long maxDirectMemory() {  </li>
<li>if (booted)  </li>
<li>return directMemory;  </li>
<li></li>
<li>Properties p = System.getProperties();  </li>
<li>String s = (String)p.remove(&quot;sun.nio.MaxDirectMemorySize&quot;);  </li>
<li>System.setProperties(p);  </li>
<li></li>
<li>if (s != null) {  </li>
<li>if (s.equals(&quot;-1&quot;)) {  </li>
<li>// -XX:MaxDirectMemorySize not given, take default  </li>
<li>directMemory = Runtime.getRuntime().maxMemory();  </li>
<li>} else {  </li>
<li>long l = Long.parseLong(s);  </li>
<li>if (l &gt; -1)  </li>
<li>directMemory = l;  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>return directMemory;  </li>
<li><p>}<br>// A user-settable upper limit on the maximum amount of allocatable direct // buffer memory. This value may be changed during VM initialization if // &quot;java&quot; is launched with &quot;-XX:MaxDirectMemorySize=<size>&quot;. // // The initial value of this field is arbitrary; during JRE initialization // it will be reset to the value specified on the command line, if any, // otherwise to Runtime.getRuntime().maxMemory(). // private static long directMemory = 64 /<em> 1024 /</em> 1024; // If this method is invoked during VM initialization, it initializes the // maximum amount of allocatable direct buffer memory (in bytes) from the // system property sun.nio.MaxDirectMemorySize. The system property will // be removed when it is accessed. // // If this method is invoked after the VM is booted, it returns the // maximum amount of allocatable direct buffer memory. // public static long maxDirectMemory() { if (booted) return directMemory; Properties p = System.getProperties(); String s = (String)p.remove(&quot;sun.nio.MaxDirectMemorySize&quot;); System.setProperties(p); if (s != null) { if (s.equals(&quot;-1&quot;)) { // -XX:MaxDirectMemorySize not given, take default directMemory = Runtime.getRuntime().maxMemory(); } else { long l = Long.parseLong(s); if (l &gt; -1) directMemory = l; } } return directMemory; }
（代码里原本的注释有个写错的地方，上面有修正）
当MaxDirectMemorySize参数没被显式设置时它的值就是-1，在Java类库初始化时maxDirectMemory()被java.lang.System的静态构造器调用，走的路径就是这条：
Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>if (s.equals(&quot;-1&quot;)) {  </p>
</li>
<li>// -XX:MaxDirectMemorySize not given, take default  </li>
<li>directMemory = Runtime.getRuntime().maxMemory();  </li>
<li><p>}<br>if (s.equals(&quot;-1&quot;)) { // -XX:MaxDirectMemorySize not given, take default directMemory = Runtime.getRuntime().maxMemory(); }
而Runtime.maxMemory()在HotSpot VM里的实现是：
C++代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>JVM_ENTRY_NO_ENV(jlong, JVM_MaxMemory(void))  </p>
</li>
<li>JVMWrapper(&quot;JVM_MaxMemory&quot;);  </li>
<li>size_t n = Universe::heap()-&gt;max_capacity();  </li>
<li>return convert_size_t_to_jlong(n);  </li>
<li><p>JVM_END<br>JVM_ENTRY_NO_ENV(jlong, JVM_MaxMemory(void)) JVMWrapper(&quot;JVM_MaxMemory&quot;); size_t n = Universe::heap()-&gt;max_capacity(); return convert_size_t_to_jlong(n); JVM_END
这个max_capacity()实际返回的是 -Xmx减去一个survivor space的预留大小（G1除外）。
结论：MaxDirectMemorySize没显式配置的时候，NIO direct memory可申请的空间的上限就是<strong>-Xmx减去一个survivor space的预留大小</strong>。
大家感兴趣的话可以试试在不同的-Xmx的条件下不设置MaxDirectMemorySize，并且调用一下sun.misc.VM.maxDirectMemory()看得到的值的相关性。</p>
<h1 id="-jdk7-http-hg-openjdk-java-net-jdk7-jdk7-jdk-rev-b444f86c4abe-http-hg-openjdk-java-net-jdk7-jdk7-jdk-rev-b444f86c4abe-">该行为在JDK7里没变，虽然具体实现的代码有些变化。请参考<a href="http://hg.openjdk.java.net/jdk7/jdk7/jdk/rev/b444f86c4abe" target="_blank"><a href="http://hg.openjdk.java.net/jdk7/jdk7/jdk/rev/b444f86c4abe">http://hg.openjdk.java.net/jdk7/jdk7/jdk/rev/b444f86c4abe</a></a></h1>
<p>6、-verbose:gc 与 -XX:+PrintGCDetails
经常能看到在推荐的标准参数里这两个参数一起出现。实际上它们有啥关系？
在Oracle/Sun JDK 6里，&quot;java&quot;这个启动程序遇到&quot;-verbosegc&quot;会将其转换为&quot;-verbose:gc&quot;，将启动参数传给HotSpot VM后，HotSpot VM遇到&quot;-verbose:gc&quot;则会当作&quot;-XX:+PrintGC&quot;来处理。
也就是说 -verbosegc、-verbose:gc、-XX:+PrintGC 三者的作用是完全一样的。
而当HotSpot VM遇到 -XX:+PrintGCDetails 参数时，会顺带把 -XX:+PrintGC 给设置上。
也就是说 -XX:+PrintGCDetails 包含 -XX:+PrintGC，进而也就包含 -verbose:gc。</p>
<h1 id="-verbose-gc-">既然 -verbose:gc 都被包含了，何必在命令行参数里显式设置它呢？<img src="" alt=""></h1>
<p>7、-XX:+UseFastEmptyMethods 与 -XX:+UseFastAccessorMethods
虽然不常见，但偶尔也会见到推荐的标准参数上有这俩的身影。
empty method顾名思义就是空方法，也就是方法体只包含一条return指令、返回值类型为void的Java方法。
accessor method在这里则有很具体的定义：
C++代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>bool methodOopDesc::is_accessor() const {  </p>
</li>
<li>if (code_size() != 5) return false;  </li>
<li>if (size_of_parameters() != 1) return false;  </li>
<li>if (java_code_at(0) != Bytecodes::_aload_0 ) return false;  </li>
<li>if (java_code_at(1) != Bytecodes::_getfield) return false;  </li>
<li>if (java_code_at(4) != Bytecodes::_areturn &amp;&amp;  </li>
<li>java_code_at(4) != Bytecodes::_ireturn ) return false;  </li>
<li>return true;  </li>
<li><p>}<br>bool methodOopDesc::is_accessor() const { if (code_size() != 5) return false; if (size_of_parameters() != 1) return false; if (java_code_at(0) != Bytecodes::_aload_0 ) return false; if (java_code_at(1) != Bytecodes::_getfield) return false; if (java_code_at(4) != Bytecodes::_areturn &amp;&amp; java_code_at(4) != Bytecodes::_ireturn ) return false; return true; }
如果从Java源码的角度来理解，accessor method就是形如这样的：
Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>public class Foo {  </p>
</li>
<li>private int value;  </li>
<li></li>
<li>public int getValue() {  </li>
<li>return this.value;  </li>
<li>}  </li>
<li><p>}<br>public class Foo { private int value; public int getValue() { return this.value; } }
关键点是：
1、必须是成员方法；静态方法不行
2、返回值类型必须是引用类型或者int，其它都不算
3、方法体的代码必须满足aload_0; getfield /#index; areturn或ireturn这样的模式。
留意：方法名是什么都没关系，是不是get、is、has开头都不重要。
那么这俩有啥问题？
取自JDK 6 update 27：
C++代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>product(bool, UseFastEmptyMethods, true,                   \  </p>
</li>
<li>&quot;Use fast method entry code for empty methods&quot;)    \  </li>
<li>\  </li>
<li>product(bool, UseFastAccessorMethods, true,                \  </li>
<li><p>&quot;Use fast method entry code for accessor methods&quot;) \<br>product(bool, UseFastEmptyMethods, true, \ &quot;Use fast method entry code for empty methods&quot;) \ \ product(bool, UseFastAccessorMethods, true, \ &quot;Use fast method entry code for accessor methods&quot;) \
看到这俩参数的默认值都是true了么？也就是说，在Oracle/Sun JDK 6上设置这参数其实也是没意义的，跟默认一样，一直到最新的JDK 6 update 29都是如此。
不过在Oracle/Sun JDK 7里，情况有变化。
<a href="http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6385687" target="_blank">Bug ID: 6385687 UseFastEmptyMethods/UseFastAccessorMethods considered harmful</a>
在<a href="http://hg.openjdk.java.net/jdk7/hotspot-comp/hotspot/rev/c2323e2ea62b" target="_blank">上述bug对应的代码变更</a>后，这俩参数的默认值改为了false。
本来想多写点这块的…算，还是长话短说。
Oracle JDK 7里的HotSpot VM已经开始有比较好的<a href="http://rednaxelafx.iteye.com/blog/1022095" target="_blank">多层编译（tiered compilation）支持</a>，可以预见在不久的将来该模式将成为HotSpot VM默认的执行模式。当前该模式尚未默认开启；可以通过 <strong>-XX:+TieredCompilation</strong> 来开启。
有趣的是，在使用多层编译模式时，如果UseFastAccessorMethods/UseFastEmptyMethods是开着的，有些多态方法调用点的性能反而会显著下降。所以，为了适应多层编译模式，JDK 7里这两个参数的默认值就被改为false了。</p>
<h1 id="-review-for-6385687-usefastemptymethods-usefastaccessormethods-considered-harmful-http-mail-openjdk-java-net-pipermail-hotspot-compiler-dev-2011-march-005057-html-">在邮件列表上有过相关讨论：<a href="http://mail.openjdk.java.net/pipermail/hotspot-compiler-dev/2011-March/005057.html" target="_blank">review for 6385687: UseFastEmptyMethods/UseFastAccessorMethods considered harmful</a></h1>
<p>8、-XX:+UseCMSCompactAtFullCollection
这个参数在Oracle/Sun JDK 6里一直都默认是true，完全没必要显式设置，设了也不会有啥不同的效果。
C++代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>product(bool, UseCMSCompactAtFullCollection, true,    \  </p>
</li>
<li><p>&quot;Use mark sweep compact at full collections&quot;) \<br>product(bool, UseCMSCompactAtFullCollection, true, \ &quot;Use mark sweep compact at full collections&quot;) \
我不认为显式设置一个跟默认值相同的参数有什么维护上的好处。要维护的参数多了反而更容易成为维护的噩梦吧。后面的人会不知道到底当初为什么要设置这个参数。
相关的有个 <strong>CMSFullGCsBeforeCompaction</strong> 参数，请参考另一帖里的讨论：<a href="http://hllvm.group.iteye.com/group/topic/28854#209294" target="_blank"><a href="http://hllvm.group.iteye.com/group/topic/28854/#209294">http://hllvm.group.iteye.com/group/topic/28854/#209294</a></a>
同样，在Oracle/Sun JDK 6和OpenJDK 6里，<strong>CMSParallelRemarkEnabled</strong> 也一直默认是true，没必要显式设置-XX:+CMSParallelRemarkEnabled。
有很多bool类型的参数默认都是true，显式设置它们之前最好先用这帖开头介绍的办法看看默认值是否已经是想要的值了。
C++代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>product(bool, CMSScavengeBeforeRemark, false,          \  </p>
</li>
<li><p>&quot;Attempt scavenge before the CMS remark step&quot;) \<br>product(bool, CMSScavengeBeforeRemark, false, \ &quot;Attempt scavenge before the CMS remark step&quot;) \</p>
<h1 id="-false-young-gc-cms-remark-remark-young-gc-remark-">这个默认倒是false。如果一个应用统计到的young GC时间都比较短而CMS remark的时间比较长，那么可以试试打开这个参数，在做remark之前先做一次young GC。是否能有效缩短remark的时间视应用情况而异，所以开这个参数的话请一定做好测试。</h1>
<p>9、-XX:CMSMaxAbortablePrecleanTime=5000
同上…默认就是5000
C++代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>product(intx, CMSMaxAbortablePrecleanTime, 5000,    \  </p>
</li>
<li>&quot;(Temporary, subject to experimentation)&quot;   \  </li>
<li><p>&quot;Maximum time in abortable preclean in ms&quot;) \<br>product(intx, CMSMaxAbortablePrecleanTime, 5000, \ &quot;(Temporary, subject to experimentation)&quot; \ &quot;Maximum time in abortable preclean in ms&quot;) \</p>
<h1 id="-">还是不要设跟默认值一样的参数了吧。</h1>
<p>10、-Xss 与 -XX:ThreadStackSize
参考我之前发过的两帖：
<a href="http://mail.openjdk.java.net/pipermail/hotspot-dev/2011-June/004272.html" target="_blank">What the difference between -Xss and -XX:ThreadStackSize is?</a>
<a href="http://mail.openjdk.java.net/pipermail/hotspot-dev/2011-July/004288.html" target="_blank">Inconsistency between -Xss and -XX:ThreadStackSize in the java launcher</a></p>
<h1 id="-">（详情回头补～）</h1>
<p>11、-Xmn 与 -XX:NewSize、-XX:MaxNewSize</p>
<h1 id="-xx-newsize-xx-maxnewsize-could-not-reserve-enough-space-for-object-heap-http-hllvm-group-iteye-com-group-topic-28467-206341-jdk-6-jdk-6-update-14-">如果同时设置了-XX:NewSize与-XX:MaxNewSize遇到“Could not reserve enough space for object heap”错误的话，请看看是不是<a href="http://hllvm.group.iteye.com/group/topic/28467#206341" target="_blank">这帖所说的问题</a>。早期JDK 6似乎都受这问题影响，一直到JDK 6 update 14才修复。</h1>
<h1 id="12-xmn-xx-newratio">12、-Xmn 与 -XX:NewRatio</h1>
<h1 id="13-xx-newratio-xx-newsize-xx-oldsize">13、-XX:NewRatio 与 -XX:NewSize、-XX:OldSize</h1>
<p>14、jmap -heap看到的参数值与实际起作用的参数的关系？
发了几个例子在这里：<a href="https://gist.github.com/1363195" target="_blank"><a href="https://gist.github.com/1363195">https://gist.github.com/1363195</a></a>
其中有个看起来很恐怖的值：
Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>MaxNewSize       = 17592186044415 MB<br>MaxNewSize = 17592186044415 MB
这是啥来的？
C++代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>product(uintx, MaxNewSize, max_uintx,                                  \  </p>
</li>
<li>&quot;Maximum new generation size (in bytes), max_uintx means set &quot; \  </li>
<li><p>&quot;ergonomically&quot;)<br>product(uintx, MaxNewSize, max_uintx, \ &quot;Maximum new generation size (in bytes), max_uintx means set &quot; \ &quot;ergonomically&quot;)
在HotSpot VM里，intx是跟平台字长一样宽的带符号整型，uintx是其无符号版。
max_uintx是(uintx) -1，也就是说在32位平台上是无符号的0xFFFFFFFF，64位平台上则是0xFFFFFFFFFFFFFFFF。
jmap -heap显示的部分参数是以MB为单位来显示的，而MaxNewSize的单位是byte。我跑例子的平台是64位的，于是算一下 0xFFFFFFFFFFFFFFFF / 1024 / 1024 = 17592186044415 MB 。
参数的说明告诉我们，当MaxNewSize的值等于max_uintx时，意思就是交由ergonomics来自动选择young gen的最大大小。<strong>并不是说young gen的最大大小真的有0xFFFFFFFFFFFFFFFF这么大</strong>。
要注意的是，HotSpot VM有大量可调节的参数，并不是所有参数在某次运行的时候都有效。
例如说设置了-Xmn的话，NewRatio就没作用了。
又例如说，
C++代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>product(uintx, OldSize, ScaleForWordSize(4/*M),        \  </p>
</li>
<li><p>&quot;Initial tenured generation size (in bytes)&quot;) \<br>product(uintx, OldSize, ScaleForWordSize(4/*M), \ &quot;Initial tenured generation size (in bytes)&quot;) \
-XX:OldSize参数的默认值在32位平台上是4M，在64位平台上是5M多。但如果这个参数没有被显式设置过，那它实际上是没作用的；old gen的大小会通过Java heap的整体大小与young gen的大小配置计算出来，但OldSize参数却没有被更新（因为根本没用它）。于是这个参数的值与实际运行的状况就可能会不相符。
一种例外的情况是，如果-Xmx非常小，比NewSize+OldSize的默认值还小，那这个OldSize的默认值就会起作用，把MaxHeapSize给撑大。
C++代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>void TwoGenerationCollectorPolicy::initialize_flags() {  </p>
</li>
<li>GenCollectorPolicy::initialize_flags();  </li>
<li></li>
<li>OldSize = align_size_down(OldSize, min_alignment());  </li>
<li>if (NewSize + OldSize &gt; MaxHeapSize) {  </li>
<li>MaxHeapSize = NewSize + OldSize;  </li>
<li>}  </li>
<li>MaxHeapSize = align_size_up(MaxHeapSize, max_alignment());  </li>
<li>//...  </li>
<li><p>}<br>void TwoGenerationCollectorPolicy::initialize_flags() { GenCollectorPolicy::initialize_flags(); OldSize = align_size_down(OldSize, min_alignment()); if (NewSize + OldSize &gt; MaxHeapSize) { MaxHeapSize = NewSize + OldSize; } MaxHeapSize = align_size_up(MaxHeapSize, max_alignment()); //... }</p>
<h1 id="-https-gist-github-com-1375782-https-gist-github-com-1375782-">可以看这边的一个例子：<a href="https://gist.github.com/1375782" target="_blank"><a href="https://gist.github.com/1375782">https://gist.github.com/1375782</a></a></h1>
<p>15、-XX:+AlwaysTenure、-XX:+NeverTenure、-XX:MaxTenuringThreshold=0 或 &quot;-XX:MaxTenuringThreshold=markOopDesc::max_age + 1&quot;
ParNew的时候，设定-XX:+AlwaysTenure隐含-XX:MaxTenuringThreshold=0；不过-XX:+NeverTenure却没啥特别的作用。</p>
<h1 id="-xx-alwaystenure-xx-nevertenure-">-XX:+AlwaysTenure 与 -XX:+NeverTenure 是互斥的，最后一个出现的那个会同时决定这两个参数的值。</h1>
<p>16、-XX:MaxTenuringThreshold 的默认值？
C++代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>product(intx, MaxTenuringThreshold,    15, \  </p>
</li>
<li><p>&quot;Maximum value for tenuring threshold&quot;)  \<br>product(intx, MaxTenuringThreshold, 15, \ &quot;Maximum value for tenuring threshold&quot;) \
Oracle/Sun JDK 6中，选择CMS之外的GC时，MaxTenuringThreshold（以下简称MTT）的默认值是15；而选择了CMS的时候，MTT的默认值是4而不是15。设定是在 Arguments::set_cms_and_parnew_gc_flags() 里做的。
在Sun JDK 6之前（1.4.2、5），选择CMS的时候MTT的默认值则是0，也就是等于设定了-XX:+AlwaysTenure——所有eden里的活对象在经历第一次minor GC的时候就会直接晋升到old gen，而survivor space直接就没用了。
Command prompt代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>$ java -version  </p>
</li>
<li>java version &quot;1.6.0_25&quot;  </li>
<li>Java(TM) SE Runtime Environment (build 1.6.0_25-b06)  </li>
<li>Java HotSpot(TM) 64-Bit Server VM (build 20.0-b11, mixed mode)  </li>
<li>$ java -XX:+PrintFlagsFinal | egrep &#39;MaxTenuringThreshold|UseParallelGC|UseConcMarkSweepGC&#39;  </li>
<li>intx MaxTenuringThreshold                      = 15              {product}             </li>
<li>bool UseConcMarkSweepGC                        = false           {product}             </li>
<li>bool UseParallelGC                            := true            {product}             </li>
<li>$ java -XX:+PrintFlagsFinal -XX:+UseConcMarkSweepGC | egrep &#39;MaxTenuringThreshold|UseParallelGC|UseConcMarkSweepGC&#39;  </li>
<li>intx MaxTenuringThreshold                     := 4               {product}             </li>
<li>bool UseConcMarkSweepGC                       := true            {product}             </li>
<li><p>bool UseParallelGC                             = false           {product}             </p>
<h1 id="-java-version-java-version-1-6-0_25-java-tm-se-runtime-environment-build-1-6-0_25-b06-java-hotspot-tm-64-bit-server-vm-build-20-0-b11-mixed-mode-java-xx-printflagsfinal-egrep-maxtenuringthreshold-useparallelgc-useconcmarksweepgc-intx-maxtenuringthreshold-15-product-bool-useconcmarksweepgc-false-product-bool-useparallelgc-true-product-java-xx-printflagsfinal-xx-useconcmarksweepgc-egrep-maxtenuringthreshold-useparallelgc-useconcmarksweepgc-intx-maxtenuringthreshold-4-product-bool-useconcmarksweepgc-true-product-bool-useparallelgc-false-product-">$ java -version java version &quot;1.6.0_25&quot; Java(TM) SE Runtime Environment (build 1.6.0_25-b06) Java HotSpot(TM) 64-Bit Server VM (build 20.0-b11, mixed mode) $ java -XX:+PrintFlagsFinal | egrep &#39;MaxTenuringThreshold|UseParallelGC|UseConcMarkSweepGC&#39; intx MaxTenuringThreshold = 15 {product} bool UseConcMarkSweepGC = false {product} bool UseParallelGC := true {product} $ java -XX:+PrintFlagsFinal -XX:+UseConcMarkSweepGC | egrep &#39;MaxTenuringThreshold|UseParallelGC|UseConcMarkSweepGC&#39; intx MaxTenuringThreshold := 4 {product} bool UseConcMarkSweepGC := true {product} bool UseParallelGC = false {product}</h1>
<p>17、-XX:+CMSClassUnloadingEnabled</p>
<h1 id="cms-remark-string-intern-">CMS remark暂停时间会增加，所以如果类加载并不频繁、String的intern也没有大量使用的话，这个参数还是不开的好。</h1>
<h1 id="18-xx-aggressiveheap">18、-XX:+AggressiveHeap</h1>
<p>19、-XX:+UseCompressedOops 有益？有害？
先把微博上回复别人问题的解答放这边。
本来如果功能没bug的话，Oracle/Sun JDK 6的64位HotSpot上，GC堆在26G以下（-Xmx + -XX:MaxPermSize）的时候用多数都是有益的。
开启压缩指针后，从代码路径（code path）和CPI（cycles per instruction）两个角度看，情况是不一样的：
·开启压缩指针会使代码路径变长，因为所有在GC堆里的、指向GC堆内对象的指针都会被压缩，这些指针的访问就需要更多的代码才可以实现。不要以为只是读写字段才受影响，其实实例方法调用、子类型检查等操作也受影响——“klass”也是一个指针，也被压缩了。
·但从CPI的角度看，由于压缩指针使需要拷贝的数据量变小了，cache miss的几率随之降低，结果CPI可能会比压缩前降低。综合来看，开了压缩指针通常能大幅降低GC堆内存的消耗，同时维持或略提高Java程序的速度。
但，JDK6u23之前那个参数的bug实在太多，最好别用；而6u23之后它就由ergonomics自动开启了，不用自己设。如果在6u23或更高版本碰到压缩指针造成的问题的话，显式设置 <strong>-XX:-UseCompressedOops</strong> 。
我能做的建议是如果在64位Oracle/Sun JDK 6/7上，那个参数不要显式设置。
关于HotSpot VM的ergonomics自动开启压缩指针功能，请参考<a href="http://rednaxelafx.iteye.com/blog/1010079" target="_blank">之前的一帖</a>。</p>
<h1 id="-vm-berkeley-db-java-edition-http-www-oracle-com-technetwork-database-berkeleydb-overview-index-093405-html-bdb-je-xx-usecompressedoops-bdb-je-java-permgen-32gb-xx-usecompressedoops-warning-on-compressed-oops-https-forums-oracle-com-forums-thread-jspa-messageid-10017916-">有些库比较“聪明”，会自行读取VM参数来调整自己的一些参数，例如<a href="http://www.oracle.com/technetwork/database/berkeleydb/overview/index-093405.html" target="_blank">Berkeley DB Java Edition</a>。但这些库实现得不好的时候反而会带来一些麻烦：BDB JE要求<strong>显式指定-XX:+UseCompressedOops</strong>才能有效的调整它的缓存大小。所以在用BDB JE并且Java堆+PermGen大小小于32GB的时候，请显式指定-XX:+UseCompressedOops吧。参考<a href="https://forums.oracle.com/forums/thread.jspa?messageID=10017916" target="_blank">Warning on Compressed Oops</a></h1>
<p>20、-XX:LargePageSizeInBytes=128m ？
或者是 -XX:LargePageSizeInBytes=256m ？
其实这个参数的值是多少不是问题，问题是这个参数到底有没有起作用。
或许有人读过很老的调优建议资料，例如这个：
<a href="http://java.sun.com/performance/reference/whitepapers/tuning.html#section4.2.3" target="_blank">(2005) Java Tuning White Paper - 4.2.3 Tuning Example 3: Try 256 MB pages</a>
或者是别的一些内容很老的资料。它们提到了-XX:LargePageSizeInBytes=参数。这些老资料也没说错，在Sun JDK 5里 -XX:LargePageSizeInBytes= 参数只在Solaris上有效，使用的时候没有别的参数保护。
但是，实际上这个参数在Oracle/Sun JDK 6里不配合-XX:+UseLargePages的话是不会起任何作用的。
JDK 6里的JVM的Linux版上初始化large page的地方：
C++代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>bool os::large_page_init() {  </p>
</li>
<li>if (!UseLargePages) return false;  </li>
<li></li>
<li>if (LargePageSizeInBytes) {  </li>
<li>_large_page_size = LargePageSizeInBytes;  </li>
<li>} else {  </li>
<li>// ...  </li>
<li>}  </li>
<li></li>
<li>// ...  </li>
<li></li>
<li>// Large page support is available on 2.6 or newer kernel, some vendors  </li>
<li>// (e.g. Redhat) have backported it to their 2.4 based distributions.  </li>
<li>// We optimistically assume the support is available. If later it turns out  </li>
<li>// not true, VM will automatically switch to use regular page size.  </li>
<li>return true;  </li>
<li><p>}<br>bool os::large_page_init() { if (!UseLargePages) return false; if (LargePageSizeInBytes) { _large_page_size = LargePageSizeInBytes; } else { // ... } // ... // Large page support is available on 2.6 or newer kernel, some vendors // (e.g. Redhat) have backported it to their 2.4 based distributions. // We optimistically assume the support is available. If later it turns out // not true, VM will automatically switch to use regular page size. return true; }
看到了么，没有将UseLargePages设置为true的话，LargePageSizeInBytes根本没机会被用上。
对应的，Solaris版：
C++代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>bool os::large_page_init() {  </p>
</li>
<li>if (!UseLargePages) {  </li>
<li>UseISM = false;  </li>
<li>UseMPSS = false;  </li>
<li>return false;  </li>
<li>}  </li>
<li></li>
<li>// ...  </li>
<li><p>}<br>bool os::large_page_init() { if (!UseLargePages) { UseISM = false; UseMPSS = false; return false; } // ... }
以及Windows版：
C++代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>bool os::large_page_init() {  </p>
</li>
<li>if (!UseLargePages) return false;  </li>
<li></li>
<li>// ...  </li>
<li>}<br>bool os::large_page_init() { if (!UseLargePages) return false; // ... }<h1 id="-oracle-sun-jdk-6-oracle-jdk-7-xx-largepagesizeinbytes-xx-uselargepages-large-pages-regular-pages-">在Oracle/Sun JDK 6以及Oracle JDK 7上要使用 -XX:LargePageSizeInBytes= 的话，请务必也设置上 -XX:+UseLargePages 。使用这两个参数之前最好先确认操作系统是否真的只是large pages；操作系统不支持的话，设置这两个参数也没作用，只会退回到使用regular pages而已。</h1>
21、-XX:+AlwaysPreTouch
会把commit的空间跑循环赋值为0以达到“pretouch”的目的。开这个参数会增加VM初始化时的开销，但后面涉及虚拟内存的开销可能降低。<h1 id="-http-hllvm-group-iteye-com-group-topic-28839-209144-http-hllvm-group-iteye-com-group-topic-28839-209144-">在另一个讨论帖里有讲该参数：<a href="http://hllvm.group.iteye.com/group/topic/28839#209144" target="_blank"><a href="http://hllvm.group.iteye.com/group/topic/28839/#209144">http://hllvm.group.iteye.com/group/topic/28839/#209144</a></a></h1>
<h1 id="22-xx-usetlab-runtime-freememory-">22、-XX:+UseTLAB 与 Runtime.freeMemory()</h1>
23、-XX:+ParallelRefProcEnabled
这个功能可以加速reference processing，但在JDK6u25和6u26上不要使用，有bug：<h1 id="-bug-id-7028845-cms-6984287-broke-parallel-reference-processing-in-cms-http-bugs-sun-com-bugdatabase-view_bug-do-bug_id-7028845-"><a href="http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=7028845" target="_blank">Bug ID 7028845: CMS: 6984287 broke parallel reference processing in CMS</a></h1>
24、-XX:+UseConcMarkSweepGC 与 -XX:+UseAdaptiveSizePolicy
这两个选项在现有的Oracle/Sun JDK 6和Oracle JDK 7上都不要搭配在一起使用——CMS用的adaptive size policy还没实现完，用的话可能会crash。
目前HotSpot VM上只有ParallelScavenge系的GC才可以配合-XX:+UseAdaptiveSizePolicy使用；也就是只有-XX:+UseParallelGC或者-XX:+UseParallelOldGC。<a href="http://mail.openjdk.java.net/pipermail/hotspot-gc-use/2011-November/000954.html" target="_blank">Jon Masamitsu在邮件列表上提到过</a>。<h1 id="-useadaptivesizepolicy-parallelscavenge-survivor-space-jon-masamitsu-http-mail-openjdk-java-net-pipermail-hotspot-gc-use-2012-october-001390-html-">题外话：开着UseAdaptiveSizePolicy的ParallelScavenge会动态调整各空间的大小，有可能会造成两个survivor space的大小被调整得不一样大。Jon Masamitsu在<a href="http://mail.openjdk.java.net/pipermail/hotspot-gc-use/2012-October/001390.html" target="_blank">这封邮件</a>里解释了原因。</h1>
25、-XX:+UseAdaptiveGCBoundary<h1 id="jdk-6-bug-">JDK 6里不要用这个选项，有bug。</h1>
26、-XX:HeapDumpPath 与 -XX:+HeapDumpBeforeFullGC、-XX:+HeapDumpAfterFullGC、-XX:+HeapDumpOnOutOfMemoryError
-XX:+HeapDumpBeforeFullGC、-XX:+HeapDumpAfterFullGC、-XX:+HeapDumpOnOutOfMemoryError 这几个参数可以在不同条件下做出HPROF格式的heap dump。但很多人都会疑惑：做出来的heap dump存到哪里去了？
如果不想费神去摸索到底各种环境被配置成什么样、“working directory”到底在哪里的话，就在VM启动参数里加上 <strong>-XX:HeapDumpPath=一个绝对路径</strong> 吧。这样，自动做出的heap dump就会被存到指定的目录里去。<h1 id="-working-directory-">当然相对路径也支持，不过用了相对路径就又得弄清楚当前的“working directory”在哪里了。</h1>
26、UseDepthFirstScavengeOrder
以前有过这样一个参数可以设置young gen遍历对象图的顺序，深度还是广度优先不过高于JDK 6 update 22就没用了，ParallelScavenge变为只用深度优先而不用广度优先。
具体的changeset在这里：<a href="http://hg.openjdk.java.net/hsx/hotspot-main/hotspot/rev/9d7a8ab3736b" target="_blank"><a href="http://hg.openjdk.java.net/hsx/hotspot-main/hotspot/rev/9d7a8ab3736b">http://hg.openjdk.java.net/hsx/hotspot-main/hotspot/rev/9d7a8ab3736b</a></a>
HotSpot VM里的arguments.cpp文件里有obsolete_jvm_flags数组，那边声明的参数都要留意是已经没用的。
（下文待续～）
<img src="" alt="Spinner"> <a href="http://learnworld.iteye.com/" target="_blank"><img src="&quot;learnworld的博客: 一路远行&quot;" alt="learnworld的博客"></a> <a href="http://learnworld.iteye.com/" title="learnworld" target="_blank">learnworld</a> 2011-10-23</li>
</ol>
<p>好贴，坐等下文。
<img src="" alt="Spinner"> <a href="http://jolestar.iteye.com/" target="_blank"><img src="&quot;jolestar的博客: 午夜咖啡&quot;" alt="jolestar的博客"></a> <a href="http://jolestar.iteye.com/" title="jolestar" target="_blank">jolestar</a> 2011-10-23</p>
<p>lz不厚道，说了个半句话就闪了。太吊胃口了。
<img src="" alt="Spinner"> <a href="http://boy00fly.iteye.com/" target="_blank"><img src="&quot;boy00fly的博客: 石头边的老牛&quot;" alt="boy00fly的博客"></a> <a href="http://boy00fly.iteye.com/" title="boy00fly" target="_blank">boy00fly</a> 2011-10-24</p>
<p>jolestar 写道</p>
<p>lz不厚道，说了个半句话就闪了。太吊胃口了。
哈哈，确实吊胃口。。下文呢？
<img src="" alt="Spinner"> <a href="http://icanfly.iteye.com/" target="_blank"><img src="&quot;icanfly的博客: 老罗宣言&quot;" alt="icanfly的博客"></a> <a href="http://icanfly.iteye.com/" title="icanfly" target="_blank">icanfly</a> 2011-10-24</p>
<p>好文。<img src="" alt="">
<img src="" alt="Spinner"> <a href="http://liuyes.iteye.com/" target="_blank"><img src="&quot;liuyes的博客: &quot;" alt="liuyes的博客"></a> <a href="http://liuyes.iteye.com/" title="liuyes" target="_blank">liuyes</a> 2011-10-24</p>
<p>楼主人呢？这发文的也有坑<img src="" alt="">
<img src="" alt="Spinner"> <a href="http://khotyn.iteye.com/" target="_blank"><img src="&quot;khotyn的博客: 码工作坊&quot;" alt="khotyn的博客"></a> <a href="http://khotyn.iteye.com/" title="khotyn" target="_blank">khotyn</a> 2011-10-24</p>
<p>坐等R大把坑填上～～
<img src="" alt="Spinner"> <a href="http://furturestrategist.iteye.com/" target="_blank"><img src="&quot;程序新手的博客: HappyProgramme&quot;" alt="程序新手的博客"></a> <a href="http://furturestrategist.iteye.com/" title="程序新手" target="_blank">程序新手</a> 2011-10-24</p>
<p>内容受益、风格简洁，期待下文
  另外大胆猜测从日志中获取的信息是部分FULL GC由System.gc()引发的
  Full GC (System)
<img src="" alt="Spinner"> <a href="http://furturestrategist.iteye.com/" target="_blank"><img src="&quot;程序新手的博客: HappyProgramme&quot;" alt="程序新手的博客"></a> <a href="http://furturestrategist.iteye.com/" title="程序新手" target="_blank">程序新手</a> 2011-10-25</p>
<p>又受益了 <img src="" alt=""> ..想了解大大收集这些知识点的方法~
<img src="" alt="Spinner"> <a href="http://hittyt.iteye.com/" target="_blank"><img src="&quot;hittyt的博客: 笨小孩&quot;" alt="hittyt的博客"></a> <a href="http://hittyt.iteye.com/" title="hittyt" target="_blank">hittyt</a> 2011-11-08</p>
<p>本人的java环境如下：
Command line代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>java -version  </li>
<li>java version &quot;1.6.0_18&quot;  </li>
<li>Java(TM) SE Runtime Environment (build 1.6.0_18-b07)  </li>
<li><p>Java HotSpot(TM) 64-Bit Server VM (build 16.0-b13, mixed mode)<br>java -version java version &quot;1.6.0_18&quot; Java(TM) SE Runtime Environment (build 1.6.0_18-b07) Java HotSpot(TM) 64-Bit Server VM (build 16.0-b13, mixed mode)
但使用PrintFlagsFinal时得到的输出却是下面的结果：
Command line代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>java -XX:+PrintFlagsFinal  </p>
</li>
<li>Unrecognized VM option &#39;+PrintFlagsFinal&#39;  </li>
<li>Could not create the Java virtual machine.<br>java -XX:+PrintFlagsFinal Unrecognized VM option &#39;+PrintFlagsFinal&#39; Could not create the Java virtual machine.
求LZ解答问题在哪里呢？
<img src="" alt="Spinner"></li>
</ol>
<p><img src="" alt=""> <a href="http://hllvm.group.iteye.com/group/topic/27945/post/new" target="_blank">发表回复</a></p>
<p>« 上一页 1 <a href="http://hllvm.group.iteye.com/group/topic/27945?page=2" target="_blank">2</a> <a href="http://hllvm.group.iteye.com/group/topic/27945?page=3" target="_blank">3</a> <a href="http://hllvm.group.iteye.com/group/topic/27945?page=2" target="_blank">下一页 »</a></p>
<p><a href="http://hllvm.group.iteye.com/" target="_blank">&gt;&gt;返回群组首页</a></p>
<p><a href="http://hllvm.group.iteye.com/" target="_blank"><img src="&quot;高级语言虚拟机: 关注各种高级语言虚拟机（high-level language virtual machine，HLL VM）的设计与实现，泛化至各种高级语言的运行时的设计与实现。讨论范围包括JVM、CLI、Parrot等当前流行的VM平台，也包括Python、Ruby、JavaScript、Lua、Perl、Forth、Smalltalk等众多语言的引擎，还有历史上有影响的各种高级语言虚拟机，如SECD等。&quot;" alt="高级语言虚拟机群组"></a></p>
<h3 id="-">相关讨论</h3>
<ul>
<li><a href="http://www.iteye.com/topic/212967" target="_blank">一次Java垃圾收集调优实战</a></li>
<li><a href="http://www.iteye.com/topic/894148" target="_blank">HotSpot VM 内存堆的两个Servivor区</a></li>
<li><a href="http://www.iteye.com/topic/802638" target="_blank">JVM内存管理：深入垃圾收集器与内存分配策略</a></li>
<li><a href="http://www.iteye.com/topic/473874" target="_blank">CMS gc实践总结</a></li>
<li><a href="http://www.iteye.com/topic/756538" target="_blank">优化JVM参数提高eclipse运行速度</a></li>
<li><a href="http://www.iteye.com/" target="_blank">首页</a></li>
<li><a href="http://www.iteye.com/news" target="_blank">资讯</a></li>
<li><a href="http://www.iteye.com/magazines" target="_blank">精华</a></li>
<li><a href="http://www.iteye.com/forums" target="_blank">论坛</a></li>
<li><a href="http://www.iteye.com/ask" target="_blank">问答</a></li>
<li><a href="http://www.iteye.com/blogs" target="_blank">博客</a></li>
<li><a href="http://www.iteye.com/blogs/subjects" target="_blank">专栏</a></li>
<li><a href="http://www.iteye.com/groups" target="_blank">群组</a></li>
<li><a href="http://job.iteye.com/iteye" target="_blank">招聘</a></li>
<li><a href="http://www.iteye.com/search" target="_blank">搜索</a></li>
<li><a href="http://hllvm.group.iteye.com/index/service" target="_blank">广告服务</a></li>
<li><a href="http://webmaster.iteye.com/" target="_blank">ITeye黑板报</a></li>
<li><a href="http://hllvm.group.iteye.com/index/contactus" target="_blank">联系我们</a></li>
<li><a href="http://hllvm.group.iteye.com/index/friend_links" target="_blank">友情链接</a></li>
</ul>
<p>© 2003-2012 ITeye.com. [ <a href="http://www.miibeian.gov.cn/" target="_blank">京ICP证110151号</a> 京公网安备110105010620 ]
百联优力(北京)投资有限公司 版权所有 <img src="http://stat.iteye.com/?url=http%3A%2F%2Fhllvm.group.iteye.com%2Fgroup%2Ftopic%2F27945&amp;referrer=http%3A%2F%2Fhllvm.group.iteye.com%2F&amp;user_id=" alt=""></p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/JVM/">JVM</a></li></span></span> | <span class="tags">Tagged <a href="/tags/JVM/" class="label label-primary">JVM</a><a href="/tags/Java&J2EE/" class="label label-success">Java&J2EE</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:42"datetime="2014-03-07 09:54:42"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-JVM--JVM调优的-标准参数-的各种陷阱/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-JVM--JVM调优的-标准参数-的各种陷阱" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--JVM调优总结（四）-垃圾回收面临的问题/">JVM调优总结（四）</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:42.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--JVM调优总结（四）-垃圾回收面临的问题/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="jvm-">JVM调优总结（四）-垃圾回收面临的问题</h1>
<p>如何区分垃圾</p>
<pre><code>上面说到的“引用计数”法，通过统计控制生成对象和删除对象时的引用数来判断。垃圾回收程序收集计数为0的对象即可。但是这种方法无法解决循环引用。所以，后来实现的垃圾判断算法中，都是从程序运行的根节点出发，遍历整个对象引用，查找存活的对象。那么在这种方式的实现中，**垃圾回收从哪儿开始的呢**？即，从哪儿开始查找哪些对象是正在被当前系统使用的。上面分析的堆和栈的区别，其中栈是真正进行程序执行地方，所以要获取哪些对象正在被使用，则需要从Java栈开始。同时，一个栈是与一个线程对应的，因此，如果有多个线程的话，则必须对这些线程对应的所有的栈进行检查。
</code></pre><p><img src="" alt=""></p>
<pre><code>同时，除了栈外，还有系统运行时的寄存器等，也是存储程序运行数据的。这样，以栈或寄存器中的引用为起点，我们可以找到堆中的对象，又从这些对象找到对堆中其他对象的引用，这种引用逐步扩展，最终以null引用或者基本类型结束，这样就形成了一颗以Java栈中引用所对应的对象为根节点的一颗对象树，如果栈中有多个引用，则最终会形成多颗对象树。在这些对象树上的对象，都是当前系统运行所需要的对象，不能被垃圾回收。而其他剩余对象，则可以视为无法被引用到的对象，可以被当做垃圾进行回收。
</code></pre><p>因此，<strong>垃圾回收的起点是一些根对象（java栈, 静态变量, 寄存器...）</strong>。而最简单的Java栈就是Java程序执行的main函数。这种回收方式，也是上面提到的“标记-清除”的回收方式</p>
<h2 id="-">如何处理碎片</h2>
<p>   由于不同Java对象存活时间是不一定的，因此，在程序运行一段时间以后，如果不进行内存整理，就会出现零散的内存碎片。碎片最直接的问题就是会导致无法分配大块的内存空间，以及程序运行效率降低。所以，在上面提到的基本垃圾回收算法中，“复制”方式和“标记-整理”方式，都可以解决碎片的问题。</p>
<h2 id="-">如何解决同时存在的对象创建和对象回收问题</h2>
<pre><code>垃圾回收线程是回收内存的，而程序运行线程则是消耗（或分配）内存的，**一个回收内存，一个分配内存**，从这点看，两者是矛盾的。因此，在现有的垃圾回收方式中，要进行垃圾回收前，一般都需要暂停整个应用（即：暂停内存的分配），然后进行垃圾回收，回收完成后再继续应用。这种实现方式是最直接，而且最有效的解决二者矛盾的方式。
</code></pre><p>但是<strong>这种方式有一个很明显的弊端，就是当堆空间持续增大时，垃圾回收的时间也将会相应的持续增大，对应应用暂停的时间也会相应的增大</strong>。一些对相应时间要求很高的应用，比如最大暂停时间要求是几百毫秒，那么当堆空间大于几个G时，就很有可能超过这个限制，在这种情况下，垃圾回收将会成为系统运行的一个瓶颈。为解决这种矛盾，有了<strong>并发垃圾回收算法</strong>，使用这种算法，垃圾回收线程与程序运行线程同时运行。在这种方式下，解决了暂停的问题，但是因为需要在新生成对象的同时又要回收对象，算法复杂性会大大增加，系统的处理能力也会相应降低，同时，“碎片”问题将会比较难解决。</p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/JVM/">JVM</a></li></span></span> | <span class="tags">Tagged <a href="/tags/JVM/" class="label label-primary">JVM</a><a href="/tags/Java&J2EE/" class="label label-success">Java&J2EE</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:42"datetime="2014-03-07 09:54:42"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-JVM--JVM调优总结（四）-垃圾回收面临的问题/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-JVM--JVM调优总结（四）-垃圾回收面临的问题" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--JVM调优总结（十）-调优方法/">JVM调优总结（十）</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:42.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--JVM调优总结（十）-调优方法/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="jvm-">JVM调优总结（十）-调优方法</h1>
<h2 id="jvm-">JVM调优工具</h2>
<p><strong>Jconsole，jProfile，VisualVM</strong></p>
<hr>
<p><strong>Jconsole :</strong> jdk自带，功能简单，但是可以在系统有一定负荷的情况下使用。对垃圾回收算法有很详细的跟踪。详细说明参考<a href="http://pengjiaheng.spaces.live.com/blog/cns!2DAA368B386E6AEA!687.entry" target="_blank">这里</a></p>
<p><strong>JProfiler</strong>：商业软件，需要付费。功能强大。详细说明参考<a href="http://pengjiaheng.spaces.live.com/blog/cns!2DAA368B386E6AEA!685.entry" target="_blank">这里</a></p>
<p><strong>VisualVM</strong>：JDK自带，功能强大，与JProfiler类似。推荐。</p>
<h2 id="-">如何调优</h2>
<p>观察内存释放情况、集合类检查、对象树</p>
<p>上面这些调优工具都提供了强大的功能，但是总的来说一般分为以下几类功能</p>
<p><strong>堆信息查看</strong></p>
<p><a href=""></a></p>
<p><img src="" alt=""> 
可查看堆空间大小分配（年轻代、年老代、持久代分配）</p>
<p>提供即时的垃圾回收功能</p>
<p>垃圾监控（长时间监控回收情况）</p>
<p><a href=""></a></p>
<p><img src="" alt=""> 
查看堆内类、对象信息查看：数量、类型等</p>
<p><a href=""></a></p>
<p><img src="" alt=""> 
对象引用情况查看</p>
<p>有了堆信息查看方面的功能，我们一般可以顺利解决以下问题：</p>
<p>  --年老代年轻代大小划分是否合理</p>
<p>  --内存泄漏</p>
<p>  --垃圾回收算法设置是否合理</p>
<h2 id="-">线程监控</h2>
<p><a href=""></a></p>
<p><img src="" alt=""> 
线程信息监控：系统线程数量。</p>
<p>线程状态监控：各个线程都处在什么样的状态下</p>
<p><a href=""></a></p>
<p><img src="" alt=""> 
Dump线程详细信息：查看线程内部运行情况</p>
<p>死锁检查</p>
<p><strong>热点分析</strong></p>
<p><a href=""></a></p>
<p><img src="" alt=""> </p>
<p><strong>    CPU热点</strong>：检查系统哪些方法占用的大量CPU时间</p>
<p><strong>    内存热点</strong>：检查哪些对象在系统中数量最大（一定时间内存活对象和销毁对象一起统计）</p>
<pre><code>这两个东西对于系统优化很有帮助。我们可以根据找到的热点，有针对性的进行系统的瓶颈查找和进行系统优化，而不是漫无目的的进行所有代码的优化。
</code></pre><p><strong>快照</strong></p>
<pre><code>快照是系统运行到某一时刻的一个定格。在我们进行调优的时候，不可能用眼睛去跟踪所有系统变化，依赖快照功能，我们就可以进行系统两个不同运行时刻，对象（或类、线程等）的不同，以便快速找到问题

举例说，我要检查系统进行垃圾回收以后，是否还有该收回的对象被遗漏下来的了。那么，我可以在进行垃圾回收前后，分别进行一次堆情况的快照，然后对比两次快照的对象情况。
</code></pre><h2 id="-">内存泄漏检查</h2>
<pre><code>内存泄漏是比较常见的问题，而且解决方法也比较通用，这里可以重点说一下，而线程、热点方面的问题则是具体问题具体分析了。

内存泄漏一般可以理解为系统资源（各方面的资源，堆、栈、线程等）在错误使用的情况下，导致使用完毕的资源无法回收（或没有回收），从而导致新的资源分配请求无法完成，引起系统错误。

内存泄漏对系统危害比较大，因为他可以直接导致系统的崩溃。

需要区别一下，内存泄漏和系统超负荷两者是有区别的，虽然可能导致的最终结果是一样的。内存泄漏是用完的资源没有回收引起错误，而系统超负荷则是系统确实没有那么多资源可以分配了（其他的资源都在使用）。
</code></pre><p><strong>年老代堆空间被占满</strong></p>
<p><strong>异常：</strong> java.lang.OutOfMemoryError: Java heap space</p>
<p><strong>说明：</strong></p>
<p><a href=""></a></p>
<p><img src="" alt=""></p>
<pre><code>这是最典型的内存泄漏方式，简单说就是所有堆空间都被无法回收的垃圾对象占满，虚拟机无法再在分配新空间。

如上图所示，这是非常典型的内存泄漏的垃圾回收情况图。所有峰值部分都是一次垃圾回收点，所有谷底部分表示是一次垃圾回收后剩余的内存。连接所有谷底的点，可以发现一条由底到高的线，这说明，随时间的推移，系统的堆空间被不断占满，最终会占满整个堆空间。因此可以初步认为系统内部可能有内存泄漏。（上面的图仅供示例，在实际情况下收集数据的时间需要更长，比如几个小时或者几天）
</code></pre><p><strong>解决：</strong></p>
<pre><code>这种方式解决起来也比较容易，一般就是根据垃圾回收前后情况对比，同时根据对象引用情况（常见的集合对象引用）分析，基本都可以找到泄漏点。
</code></pre><p><strong>持久代被占满</strong></p>
<p><strong>异常：</strong>java.lang.OutOfMemoryError: PermGen space</p>
<p><strong>说明：</strong></p>
<pre><code>Perm空间被占满。无法为新的class分配存储空间而引发的异常。这个异常以前是没有的，但是在Java反射大量使用的今天这个异常比较常见了。主要原因就是大量动态反射生成的类不断被加载，最终导致Perm区被占满。

更可怕的是，不同的classLoader即便使用了相同的类，但是都会对其进行加载，相当于同一个东西，如果有N个classLoader那么他将会被加载N次。因此，某些情况下，这个问题基本视为无解。当然，存在大量classLoader和大量反射类的情况其实也不多。
</code></pre><p><strong>解决：</strong></p>
<pre><code>1. -XX:MaxPermSize=16m

2. 换用JDK。比如JRocket。
</code></pre><p><strong>堆栈溢出</strong></p>
<p><strong>异常：</strong>java.lang.StackOverflowError</p>
<p><strong>说明：</strong>这个就不多说了，一般就是递归没返回，或者循环调用造成</p>
<p><strong>线程堆栈满</strong></p>
<p><strong>异常</strong>：Fatal: Stack size too small</p>
<p><strong>说明</strong>：java中一个线程的空间大小是有限制的。JDK5.0以后这个值是1M。与这个线程相关的数据将会保存在其中。但是当线程空间满了以后，将会出现上面异常。</p>
<p><strong>解决</strong>：增加线程栈大小。-Xss2m。但这个配置无法解决根本问题，还要看代码部分是否有造成泄漏的部分。</p>
<p><strong>系统内存被占满</strong></p>
<p><strong>异常</strong>：java.lang.OutOfMemoryError: unable to create new native thread</p>
<p><strong>说明</strong>：</p>
<pre><code>这个异常是由于操作系统没有足够的资源来产生这个线程造成的。系统创建线程时，除了要在Java堆中分配内存外，操作系统本身也需要分配资源来创建线程。因此，当线程数量大到一定程度以后，堆中或许还有空间，但是操作系统分配不出资源来了，就出现这个异常了。
</code></pre><p>分配给Java虚拟机的内存愈多，系统剩余的资源就越少，因此，当系统内存固定时，分配给Java虚拟机的内存越多，那么，系统总共能够产生的线程也就越少，两者成反比的关系。同时，可以通过修改-Xss来减少分配给单个线程的空间，也可以增加系统总共内生产的线程数。</p>
<p><strong>解决：</strong></p>
<pre><code>1. 重新设计系统减少线程数量。

2. 线程数量不能减少的情况下，通过-Xss减小单个线程大小。以便能生产更多的线程。
</code></pre>
      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/JVM/">JVM</a></li></span></span> | <span class="tags">Tagged <a href="/tags/JVM/" class="label label-primary">JVM</a><a href="/tags/Java&J2EE/" class="label label-success">Java&J2EE</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:42"datetime="2014-03-07 09:54:42"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-JVM--JVM调优总结（十）-调优方法/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-JVM--JVM调优总结（十）-调优方法" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_多线程-并发--聊聊并发（四）——深入分析ConcurrentHashMap/">聊聊并发（四）——深入分析ConcurrentHashMap</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:41.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_多线程-并发--聊聊并发（四）——深入分析ConcurrentHashMap/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-concurrenthashmap">聊聊并发（四）——深入分析ConcurrentHashMap</h1>
<h2 id="-">术语定义</h2>
<p>术语 英文 解释 哈希算法 hash algorithm 是一种将任意内容的输入转换成相同长度输出的加密方式，其输出被称为哈希值。 哈希表 hash table 根据设定的哈希函数H(key)和处理冲突方法将一组关键字映象到一个有限的地址区间上，并以关键字在地址区间中的象作为记录在表中的存储位置，这种表称为哈希表或散列，所得存储位置称为哈希地址或散列地址。</p>
<h2 id="-hashmap">线程不安全的HashMap</h2>
<p>因为多线程环境下，使用HashMap进行put操作会引起死循环，导致CPU利用率接近100%，所以在并发情况下不能使用HashMap，如以下代码
final HashMap<String, String> map = new HashMap<String, String>(2);</p>
<p>Thread t = new Thread(new Runnable() {
@Override</p>
<p>public void run() {
for (int i = 0; i &lt; 10000; i++) {</p>
<p>new Thread(new Runnable() {
@Override</p>
<p>public void run() {
map.put(UUID.randomUUID().toString(), &quot;&quot;);</p>
<p>}
}, &quot;ftf&quot; + i).start();</p>
<p>}
}</p>
<p>}, &quot;ftf&quot;);
t.start();</p>
<p>t.join();</p>
<h2 id="-hashtable-">效率低下的HashTable容器</h2>
<p>HashTable容器使用synchronized来保证线程安全，但在线程竞争激烈的情况下HashTable的效率非常低下。因为当一个线程访问HashTable的同步方法时，其他线程访问HashTable的同步方法时，可能会进入阻塞或轮询状态。如线程1使用put进行添加元素，线程2不但不能使用put方法添加元素，并且也不能使用get方法来获取元素，所以竞争越激烈效率越低。</p>
<h2 id="-">锁分段技术</h2>
<p>HashTable容器在竞争激烈的并发环境下表现出效率低下的原因是所有访问HashTable的线程都必须竞争同一把锁，那假如容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效的提高并发访问效率，这就是ConcurrentHashMap所使用的锁分段技术，首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。</p>
<h2 id="concurrenthashmap-">ConcurrentHashMap的结构</h2>
<p>我们通过ConcurrentHashMap的类图来分析ConcurrentHashMap的结构。</p>
<p><img src="" alt=""></p>
<p>ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。Segment是一种可重入锁ReentrantLock，在ConcurrentHashMap里扮演锁的角色，HashEntry则用于存储键值对数据。一个ConcurrentHashMap里包含一个Segment数组，Segment的结构和HashMap类似，是一种数组和链表结构， 一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素， 每个Segment守护者一个HashEntry数组里的元素,当对HashEntry数组的数据进行修改时，必须首先获得它对应的Segment锁。</p>
<p><img src="" alt=""></p>
<h2 id="concurrenthashmap-">ConcurrentHashMap的初始化</h2>
<p>ConcurrentHashMap初始化方法是通过initialCapacity，loadFactor, concurrencyLevel几个参数来初始化segments数组，段偏移量segmentShift，段掩码segmentMask和每个segment里的HashEntry数组 。</p>
<p>初始化segments数组。让我们来看一下初始化segmentShift，segmentMask和segments数组的源代码。
if (concurrencyLevel &gt; MAX_SEGMENTS)</p>
<p>concurrencyLevel = MAX_SEGMENTS;
// Find power-of-two sizes best matching arguments</p>
<p>int sshift = 0;
int ssize = 1;</p>
<p>while (ssize &lt; concurrencyLevel) {
++sshift;</p>
<p>ssize &lt;&lt;= 1;
}</p>
<p>segmentShift = 32 - sshift;
segmentMask = ssize - 1;</p>
<p>this.segments = Segment.newArray(ssize);</p>
<p>由上面的代码可知segments数组的长度ssize通过concurrencyLevel计算得出。为了能通过按位与的哈希算法来定位segments数组的索引，必须保证segments数组的长度是2的N次方（power-of-two size），所以必须计算出一个是大于或等于concurrencyLevel的最小的2的N次方值来作为segments数组的长度。假如concurrencyLevel等于14，15或16，ssize都会等于16，即容器里锁的个数也是16。注意concurrencyLevel的最大大小是65535，意味着segments数组的长度最大为65536，对应的二进制是16位。</p>
<p>初始化segmentShift和segmentMask。这两个全局变量在定位segment时的哈希算法里需要使用，sshift等于ssize从1向左移位的次数，在默认情况下concurrencyLevel等于16，1需要向左移位移动4次，所以sshift等于4。segmentShift用于定位参与hash运算的位数，segmentShift等于32减sshift，所以等于28，这里之所以用32是因为ConcurrentHashMap里的hash()方法输出的最大数是32位的，后面的测试中我们可以看到这点。segmentMask是哈希运算的掩码，等于ssize减1，即15，掩码的二进制各个位的值都是1。因为ssize的最大长度是65536，所以segmentShift最大值是16，segmentMask最大值是65535，对应的二进制是16位，每个位都是1。</p>
<p>初始化每个Segment。输入参数initialCapacity是ConcurrentHashMap的初始化容量，loadfactor是每个segment的负载因子，在构造方法里需要通过这两个参数来初始化数组中的每个segment。
if (initialCapacity &gt; MAXIMUM_CAPACITY)</p>
<p>initialCapacity = MAXIMUM_CAPACITY;
int c = initialCapacity / ssize;</p>
<p>if (c /* ssize &lt; initialCapacity)
++c;</p>
<p>int cap = 1;
while (cap &lt; c)</p>
<p>cap &lt;&lt;= 1;
for (int i = 0; i &lt; this.segments.length; ++i)</p>
<p>this.segments[i] = new Segment<K,V>(cap, loadFactor);</p>
<p>上面代码中的变量cap就是segment里HashEntry数组的长度，它等于initialCapacity除以ssize的倍数c，如果c大于1，就会取大于等于c的2的N次方值，所以cap不是1，就是2的N次方。segment的容量threshold＝(int)cap/*loadFactor，默认情况下initialCapacity等于16，loadfactor等于0.75，通过运算cap等于1，threshold等于零。</p>
<h2 id="-segment">定位Segment</h2>
<p>既然ConcurrentHashMap使用分段锁Segment来保护不同段的数据，那么在插入和获取元素的时候，必须先通过哈希算法定位到Segment。可以看到ConcurrentHashMap会首先使用Wang/Jenkins hash的变种算法对元素的hashCode进行一次再哈希。
private static int hash(int h) {</p>
<p>h += (h &lt;&lt; 15) ^ 0xffffcd7d;
h ^= (h &gt;&gt;&gt; 10);</p>
<p>h += (h &lt;&lt; 3);
h ^= (h &gt;&gt;&gt; 6);</p>
<p>h += (h &lt;&lt; 2) + (h &lt;&lt; 14);
return h ^ (h &gt;&gt;&gt; 16);</p>
<p>}</p>
<p>之所以进行再哈希，其目的是为了减少哈希冲突，使元素能够均匀的分布在不同的Segment上，从而提高容器的存取效率。假如哈希的质量差到极点，那么所有的元素都在一个Segment中，不仅存取元素缓慢，分段锁也会失去意义。我做了一个测试，不通过再哈希而直接执行哈希计算。</p>
<p>System.out.println(Integer.parseInt(&quot;0001111&quot;, 2) &amp; 15);</p>
<p>System.out.println(Integer.parseInt(&quot;0011111&quot;, 2) &amp; 15);
System.out.println(Integer.parseInt(&quot;0111111&quot;, 2) &amp; 15);</p>
<p>System.out.println(Integer.parseInt(&quot;1111111&quot;, 2) &amp; 15);</p>
<p>计算后输出的哈希值全是15，通过这个例子可以发现如果不进行再哈希，哈希冲突会非常严重，因为只要低位一样，无论高位是什么数，其哈希值总是一样。我们再把上面的二进制数据进行再哈希后结果如下，为了方便阅读，不足32位的高位补了0，每隔四位用竖线分割下。</p>
<p>0100｜0111｜0110｜0111｜1101｜1010｜0100｜1110</p>
<p>1111｜0111｜0100｜0011｜0000｜0001｜1011｜1000
0111｜0111｜0110｜1001｜0100｜0110｜0011｜1110</p>
<p>1000｜0011｜0000｜0000｜1100｜1000｜0001｜1010</p>
<p>可以发现每一位的数据都散列开了，通过这种再哈希能让数字的每一位都能参加到哈希运算当中，从而减少哈希冲突。ConcurrentHashMap通过以下哈希算法定位segment。</p>
<p>final Segment<K,V> segmentFor(int hash) {</p>
<p>return segments[(hash &gt;&gt;&gt; segmentShift) &amp; segmentMask];
}</p>
<p>默认情况下segmentShift为28，segmentMask为15，再哈希后的数最大是32位二进制数据，向右无符号移动28位，意思是让高4位参与到hash运算中， (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask的运算结果分别是4，15，7和8，可以看到hash值没有发生冲突。</p>
<h2 id="concurrenthashmap-get-">ConcurrentHashMap的get操作</h2>
<p>Segment的get操作实现非常简单和高效。先经过一次再哈希，然后使用这个哈希值通过哈希运算定位到segment，再通过哈希算法定位到元素，代码如下：
public V get(Object key) {</p>
<p>int hash = hash(key.hashCode());
return segmentFor(hash).get(key, hash);</p>
<p>}</p>
<p>get操作的高效之处在于整个get过程不需要加锁，除非读到的值是空的才会加锁重读，我们知道HashTable容器的get方法是需要加锁的，那么ConcurrentHashMap的get操作是如何做到不加锁的呢？原因是它的get方法里将要使用的共享变量都定义成volatile，如用于统计当前Segement大小的count字段和用于存储值的HashEntry的value。定义成volatile的变量，能够在线程之间保持可见性，能够被多线程同时读，并且保证不会读到过期的值，但是只能被单线程写（有一种情况可以被多线程写，就是写入的值不依赖于原值），在get操作里只需要读不需要写共享变量count和value，所以可以不用加锁。之所以不会读到过期的值，是根据java内存模型的happen before原则，对volatile字段的写入操作先于读操作，即使两个线程同时修改和获取volatile变量，get操作也能拿到最新的值，这是用volatile替换锁的经典应用场景。</p>
<p>transient volatile int count;</p>
<p>volatile V value;</p>
<p>在定位元素的代码里我们可以发现定位HashEntry和定位Segment的哈希算法虽然一样，都与数组的长度减去一相与，但是相与的值不一样，定位Segment使用的是元素的hashcode通过再哈希后得到的值的高位，而定位HashEntry直接使用的是再哈希后的值。其目的是避免两次哈希后的值一样，导致元素虽然在Segment里散列开了，但是却没有在HashEntry里散列开。</p>
<p>hash &gt;&gt;&gt; segmentShift) &amp; segmentMask//定位Segment所使用的hash算法</p>
<p>int index = hash &amp; (tab.length - 1);// 定位HashEntry所使用的hash算法</p>
<h2 id="concurrenthashmap-put-">ConcurrentHashMap的Put操作</h2>
<p>由于put方法里需要对共享变量进行写入操作，所以为了线程安全，在操作共享变量时必须得加锁。Put方法首先定位到Segment，然后在Segment里进行插入操作。插入操作需要经历两个步骤，第一步判断是否需要对Segment里的HashEntry数组进行扩容，第二步定位添加元素的位置然后放在HashEntry数组里。</p>
<p>是否需要扩容。在插入元素前会先判断Segment里的HashEntry数组是否超过容量（threshold），如果超过阀值，数组进行扩容。值得一提的是，Segment的扩容判断比HashMap更恰当，因为HashMap是在插入元素后判断元素是否已经到达容量的，如果到达了就进行扩容，但是很有可能扩容之后没有新元素插入，这时HashMap就进行了一次无效的扩容。</p>
<p>如何扩容。扩容的时候首先会创建一个两倍于原容量的数组，然后将原数组里的元素进行再hash后插入到新的数组里。为了高效ConcurrentHashMap不会对整个容器进行扩容，而只对某个segment进行扩容。</p>
<h2 id="concurrenthashmap-size-">ConcurrentHashMap的size操作</h2>
<p>如果我们要统计整个ConcurrentHashMap里元素的大小，就必须统计所有Segment里元素的大小后求和。Segment里的全局变量count是一个volatile变量，那么在多线程场景下，我们是不是直接把所有Segment的count相加就可以得到整个ConcurrentHashMap大小了呢？不是的，虽然相加时可以获取每个Segment的count的最新值，但是拿到之后可能累加前使用的count发生了变化，那么统计结果就不准了。所以最安全的做法，是在统计size的时候把所有Segment的put，remove和clean方法全部锁住，但是这种做法显然非常低效。 因为在累加count操作过程中，之前累加过的count发生变化的几率非常小，所以ConcurrentHashMap的做法是先尝试2次通过不锁住Segment的方式来统计各个Segment大小，如果统计的过程中，容器的count发生了变化，则再采用加锁的方式来统计所有Segment的大小。</p>
<p>那么ConcurrentHashMap是如何判断在统计的时候容器是否发生了变化呢？使用modCount变量，在put , remove和clean方法里操作元素前都会将变量modCount进行加1，那么在统计size前后比较modCount是否发生变化，从而得知容器的大小是否发生变化。</p>
<h2 id="-">参考资料</h2>
<ol>
<li>JDK1.6源代码。</li>
<li>《Java并发编程实践》。</li>
<li><a href="http://www.goldendoc.org/2011/06/juc_concurrenthashmap/" target="_blank">Java并发编程之ConcurrentHashMap</a> 。</li>
</ol>
<h2 id="-">作者介绍</h2>
<p><strong>方腾飞</strong>，花名清英，淘宝资深开发工程师，关注并发编程，目前在广告技术部从事无线广告联盟的开发和设计工作。个人博客：<a href="http://ifeve.com/" target="_blank"><a href="http://ifeve.com">http://ifeve.com</a></a> 微博：<a href="http://weibo.com/kirals" target="_blank"><a href="http://weibo.com/kirals">http://weibo.com/kirals</a></a> 欢迎通过我的微博进行技术交流。</p>
<p>感谢<a href="http://www.infoq.com/cn/bycategory.action?authorName=%E5%BC%A0%E9%BE%99" target="_blank">张龙</a>对本文的审校。
来源： <a href="[http://www.infoq.com/cn/articles/ConcurrentHashMap](http://www.infoq.com/cn/articles/ConcurrentHashMap)">[http://www.infoq.com/cn/articles/ConcurrentHashMap](http://www.infoq.com/cn/articles/ConcurrentHashMap)</a></p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/Java_多线程/">Java_多线程</a></li><li><a href="/categories/Java&J2EE/Java_多线程/并发/">并发</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/Java_多线程/" class="label label-success">Java_多线程</a><a href="/tags/并发/" class="label label-info">并发</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:41"datetime="2014-03-07 09:54:41"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-Java_多线程-并发--聊聊并发（四）——深入分析ConcurrentHashMap/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-Java_多线程-并发--聊聊并发（四）——深入分析ConcurrentHashMap" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_多线程-并发--聊聊并发（六）——ConcurrentLinkedQueue的实现原理分析/">聊聊并发（六）——ConcurrentLinkedQueue的实现原理分析</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:41.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_多线程-并发--聊聊并发（六）——ConcurrentLinkedQueue的实现原理分析/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-concurrentlinkedqueue-">聊聊并发（六）——ConcurrentLinkedQueue的实现原理分析</h1>
<h3 id="-">分享到</h3>
<ul>
<li><a href="">一键分享</a></li>
<li><a href="">QQ空间</a></li>
<li><a href="">新浪微博</a></li>
<li><a href="">百度搜藏</a></li>
<li><a href="">人人网</a></li>
<li><a href="">腾讯微博</a></li>
<li><a href="">百度相册</a></li>
<li><a href="">开心网</a></li>
<li><a href="">腾讯朋友</a></li>
<li><a href="">百度贴吧</a></li>
<li><a href="">豆瓣网</a></li>
<li><a href="">搜狐微博</a></li>
<li><a href="">百度新首页</a></li>
<li><a href="">QQ好友</a></li>
<li><a href="">和讯微博</a></li>
<li><a href="">更多...</a></li>
</ul>
<p><a href="">百度分享</a></p>
<ul>
<li><a href="http://www.infoq.com/cn/aboutus" title="关于我们" target="_blank">关于我们</a></li>
<li><p><a href="http://www.infoq.com/cn/contribute" title="让大家在InfoQ上听见你的声音" target="_blank">让大家在InfoQ上听见你的声音</a></p>
</li>
<li><p>欢迎关注我们的：</p>
</li>
<li><a href="http://e.weibo.com/infoqchina" target="_blank"><img src="" alt=""></a></li>
<li><a href="http://www.infoq.com/cn/news/2013/02/infoq-wechat" target="_blank"><img src="" alt=""></a></li>
<li><a href="http://www.infoq.com/cn/rss/rss.action?token=J6EBu2hcpyEuMs9msdo8GyNCZTcWG7pm" target="_blank"><img src="" alt=""></a></li>
</ul>
<h1 id="-concurrentlinkedqueue-">聊聊并发（六）——ConcurrentLinkedQueue的实现原理分析</h1>
<p>作者 <a href="http://www.infoq.com/cn/author/%E6%96%B9%E8%85%BE%E9%A3%9E" target="_blank">方腾飞</a> 发布于 一月 09, 2013 <em>|</em> <a href="">5 评论</a></p>
<h2 id="1-">1. 引言</h2>
<p>在并发编程中我们有时候需要使用线程安全的队列。如果我们要实现一个线程安全的队列有两种实现方式：一种是使用阻塞算法，另一种是使用非阻塞算法。使用阻塞算法的队列可以用一个锁（入队和出队用同一把锁）或两个锁（入队和出队用不同的锁）等方式来实现，而非阻塞的实现方式则可以使用循环CAS的方式来实现，本文让我们一起来研究下Doug Lea是如何使用非阻塞的方式来实现线程安全队列ConcurrentLinkedQueue的，相信从大师身上我们能学到不少并发编程的技巧。</p>
<h2 id="2-concurrentlinkedqueue-">2. ConcurrentLinkedQueue的介绍</h2>
<p>ConcurrentLinkedQueue是一个基于链接节点的无界线程安全队列，它采用先进先出的规则对节点进行排序，当我们添加一个元素的时候，它会添加到队列的尾部，当我们获取一个元素时，它会返回队列头部的元素。它采用了“wait－free”算法来实现，该算法在Michael &amp; Scott算法上进行了一些修改, Michael &amp; Scott算法的详细信息可以参见<a href="http://www.cs.rochester.edu/u/michael/PODC96.html" target="_blank">参考资料一</a>。</p>
<h2 id="3-concurrentlinkedqueue-">3. ConcurrentLinkedQueue的结构</h2>
<p>我们通过ConcurrentLinkedQueue的类图来分析一下它的结构。</p>
<p><img src="" alt=""></p>
<p>（图1）</p>
<p>ConcurrentLinkedQueue由head节点和tair节点组成，每个节点（Node）由节点元素（item）和指向下一个节点的引用(next)组成，节点与节点之间就是通过这个next关联起来，从而组成一张链表结构的队列。默认情况下head节点存储的元素为空，tair节点等于head节点。
private transient volatile Node tail = head;</p>
<h2 id="4-">4. 入队列</h2>
<p><strong>入队列就是将入队节点添加到队列的尾部</strong>。为了方便理解入队时队列的变化，以及head节点和tair节点的变化，每添加一个节点我就做了一个队列的快照图。</p>
<p><img src="" alt=""></p>
<p>（图二）</p>
<ul>
<li>第一步添加元素1。队列更新head节点的next节点为元素1节点。又因为tail节点默认情况下等于head节点，所以它们的next节点都指向元素1节点。</li>
<li>第二步添加元素2。队列首先设置元素1节点的next节点为元素2节点，然后更新tail节点指向元素2节点。</li>
<li>第三步添加元素3，设置tail节点的next节点为元素3节点。</li>
<li>第四步添加元素4，设置元素3的next节点为元素4节点，然后将tail节点指向元素4节点。</li>
</ul>
<p>通过debug入队过程并观察head节点和tail节点的变化，发现入队主要做两件事情，第一是将入队节点设置成当前队列尾节点的下一个节点。第二是更新tail节点，如果tail节点的next节点不为空，则将入队节点设置成tail节点，如果tail节点的next节点为空，则将入队节点设置成tail的next节点，所以tail节点不总是尾节点，理解这一点对于我们研究源码会非常有帮助。</p>
<p>上面的分析让我们从单线程入队的角度来理解入队过程，但是多个线程同时进行入队情况就变得更加复杂，因为可能会出现其他线程插队的情况。如果有一个线程正在入队，那么它必须先获取尾节点，然后设置尾节点的下一个节点为入队节点，但这时可能有另外一个线程插队了，那么队列的尾节点就会发生变化，这时当前线程要暂停入队操作，然后重新获取尾节点。让我们再通过源码来详细分析下它是如何使用CAS算法来入队的。
public boolean offer(E e) { if (e == null) throw new NullPointerException(); //入队前，创建一个入队节点 Node<E> n = new Node<E>(e); retry: //死循环，入队不成功反复入队。 for (;;) { //创建一个指向tail节点的引用 Node<E> t = tail; //p用来表示队列的尾节点，默认情况下等于tail节点。 Node<E> p = t; for (int hops = 0; ; hops++) { //获得p节点的下一个节点。 Node<E> next = succ(p); //next节点不为空，说明p不是尾节点，需要更新p后在将它指向next节点 if (next != null) { //循环了两次及其以上，并且当前节点还是不等于尾节点 if (hops &gt; HOPS &amp;&amp; t != tail) continue retry; p = next; } //如果p是尾节点，则设置p节点的next节点为入队节点。 else if (p.casNext(null, n)) { //如果tail节点有大于等于1个next节点，则将入队节点设置成tair节点，更新失败了也 没关系，因为失败了表示有其他线程成功更新了tair节点。 if (hops &gt;= HOPS) casTail(t, n); // 更新tail节点，允许失败 return true; } // p有next节点,表示p的next节点是尾节点，则重新设置p节点 else { p = succ(p); } } } }</p>
<p><strong>从源代码角度来看整个入队过程主要做二件事情</strong>。第一是定位出尾节点，第二是使用CAS算法能将入队节点设置成尾节点的next节点，如不成功则重试。</p>
<p><strong>第一步定位尾节点</strong>。tail节点并不总是尾节点，所以每次入队都必须先通过tail节点来找到尾节点，尾节点可能就是tail节点，也可能是tail节点的next节点。代码中循环体中的第一个if就是判断tail是否有next节点，有则表示next节点可能是尾节点。获取tail节点的next节点需要注意的是p节点等于p的next节点的情况，只有一种可能就是p节点和p的next节点都等于空，表示这个队列刚初始化，正准备添加第一次节点，所以需要返回head节点。获取p节点的next节点代码如下
final Node<E> succ(Node<E> p) { Node<E> next = p.getNext(); return (p == next) ? head : next; }</p>
<p><strong>第二步设置入队节点为尾节点</strong>。p.casNext(null, n)方法用于将入队节点设置为当前队列尾节点的next节点，p如果是null表示p是当前队列的尾节点，如果不为null表示有其他线程更新了尾节点，则需要重新获取当前队列的尾节点。</p>
<p><strong>hops的设计意图</strong>。上面分析过对于先进先出的队列入队所要做的事情就是将入队节点设置成尾节点，doug lea写的代码和逻辑还是稍微有点复杂。那么我用以下方式来实现行不行？
public boolean offer(E e) { if (e == null) throw new NullPointerException(); Node<E> n = new Node<E>(e); for (;;) { Node<E> t = tail; if (t.casNext(null, n) &amp;&amp; casTail(t, n)) { return true; } } }</p>
<p>让tail节点永远作为队列的尾节点，这样实现代码量非常少，而且逻辑非常清楚和易懂。但是这么做有个缺点就是每次都需要使用循环CAS更新tail节点。如果能减少CAS更新tail节点的次数，就能提高入队的效率，所以doug lea使用hops变量来控制并减少tail节点的更新频率，并不是每次节点入队后都将 tail节点更新成尾节点，而是当 tail节点和尾节点的距离大于等于常量HOPS的值（默认等于1）时才更新tail节点，tail和尾节点的距离越长使用CAS更新tail节点的次数就会越少，但是距离越长带来的负面效果就是每次入队时定位尾节点的时间就越长，因为循环体需要多循环一次来定位出尾节点，但是这样仍然能提高入队的效率，因为从本质上来看它通过增加对volatile变量的读操作来减少了对volatile变量的写操作，而对volatile变量的写操作开销要远远大于读操作，所以入队效率会有所提升。</p>
<p>private static final int HOPS = 1;</p>
<p>还有一点需要注意的是入队方法永远返回true，所以不要通过返回值判断入队是否成功。</p>
<h2 id="5-">5. 出队列</h2>
<p>出队列的就是从队列里返回一个节点元素，并清空该节点对元素的引用。让我们通过每个节点出队的快照来观察下head节点的变化。</p>
<p><img src="" alt=""></p>
<p>从上图可知，并不是每次出队时都更新head节点，当head节点里有元素时，直接弹出head节点里的元素，而不会更新head节点。只有当head节点里没有元素时，出队操作才会更新head节点。这种做法也是通过hops变量来减少使用CAS更新head节点的消耗，从而提高出队效率。让我们再通过源码来深入分析下出队过程。
public E poll() { Node<E> h = head; // p表示头节点，需要出队的节点 Node<E> p = h; for (int hops = 0;; hops++) { // 获取p节点的元素 E item = p.getItem(); // 如果p节点的元素不为空，使用CAS设置p节点引用的元素为null,如果成功则返回p节点的元素。 if (item != null &amp;&amp; p.casItem(item, null)) { if (hops &gt;= HOPS) { //将p节点下一个节点设置成head节点 Node<E> q = p.getNext(); updateHead(h, (q != null) ? q : p); } return item; } // 如果头节点的元素为空或头节点发生了变化，这说明头节点已经被另外一个线程修改了。那么获取p节点的下一个节点 Node&lt;&gt; next = succ(p); // 如果p的下一个节点也为空，说明这个队列已经空了 if (next == null) { // 更新头节点。 updateHead(h, p); break; } // 如果下一个元素不为空，则将头节点的下一个节点设置成头节点 p = next; } return null; }</p>
<p>首先获取头节点的元素，然后判断头节点元素是否为空，如果为空，表示另外一个线程已经进行了一次出队操作将该节点的元素取走，如果不为空，则使用CAS的方式将头节点的引用设置成null，如果CAS成功，则直接返回头节点的元素，如果不成功，表示另外一个线程已经进行了一次出队操作更新了head节点，导致元素发生了变化，需要重新获取头节点。</p>
<h2 id="6-">6. 参考资料</h2>
<ul>
<li><a href="http://www.cs.rochester.edu/u/scott/papers/1996_PODC_queues.pdf" target="_blank">简单，快速和实用的阻塞和非阻塞并发队列算法</a>。</li>
<li><a href="http://www.ibm.com/developerworks/cn/java/j-lo-concurrent/index.html" target="_blank">非阻塞算法在容器里的实现</a>。</li>
<li>JDK1.6中ConcurrentLinkedQueue源码和注释。</li>
</ul>
<h1 id="-">#</h1>
<h2 id="-">作者介绍</h2>
<p><strong>方腾飞</strong>，花名清英，淘宝资深开发工程师，关注并发编程，目前在广告技术部从事无线广告联盟的开发和设计工作。个人博客：<a href="http://ifeve.com/" target="_blank"><a href="http://ifeve.com">http://ifeve.com</a></a> 微博：<a href="http://weibo.com/kirals" target="_blank"><a href="http://weibo.com/kirals">http://weibo.com/kirals</a></a>欢迎通过我的微博进行技术交流。</p>
<p>感谢<a href="http://www.infoq.com/cn/bycategory.action?authorName=张龙" target="_blank">张龙</a>对本文的审校。</p>
<p>给InfoQ中文站投稿或者参与内容翻译工作，请邮件至<a href="mailto:editors@cn.infoq.com">editors@cn.infoq.com</a>。也欢迎大家通过新浪微博（<a href="http://www.weibo.com/infoqchina" target="_blank">@InfoQ</a>）或者腾讯微博（<a href="http://t.qq.com/infoqchina" target="_blank">@InfoQ</a>）关注我们，并与我们的编辑和其他读者朋友交流。</p>
<ul>
<li><a href="">Sections</a></li>
<li><a href="http://www.infoq.com/cn/development" target="_blank"><strong>语言 &amp; 开发</strong></a></li>
<li><a href="">Topics</a></li>
<li><a href="http://www.infoq.com/cn/Multi-threading" target="_blank">多线程</a></li>
<li><a href="http://www.infoq.com/cn/concurrency" target="_blank">并发</a></li>
<li><a href="http://www.infoq.com/cn/java" target="_blank">Java</a></li>
</ul>
<p>相关内容</p>
<h3 id="-http-www-infoq-com-cn-articles-atomic-operation-utm_source-infoq-utm_medium-related_content_link-utm_campaign-relatedcontent_articles_clk-"><a href="http://www.infoq.com/cn/articles/atomic-operation?utm_source=infoq&amp;utm_medium=related_content_link&amp;utm_campaign=relatedContent_articles_clk" target="_blank">聊聊并发（五）——原子操作的实现原理</a></h3>
<h3 id="-concurrenthashmap-http-www-infoq-com-cn-articles-concurrenthashmap-utm_source-infoq-utm_medium-related_content_link-utm_campaign-relatedcontent_articles_clk-"><a href="http://www.infoq.com/cn/articles/ConcurrentHashMap?utm_source=infoq&amp;utm_medium=related_content_link&amp;utm_campaign=relatedContent_articles_clk" target="_blank">聊聊并发（四）——深入分析ConcurrentHashMap</a></h3>
<h3 id="-java-http-www-infoq-com-cn-articles-java-threadpool-utm_source-infoq-utm_medium-related_content_link-utm_campaign-relatedcontent_articles_clk-"><a href="http://www.infoq.com/cn/articles/java-threadPool?utm_source=infoq&amp;utm_medium=related_content_link&amp;utm_campaign=relatedContent_articles_clk" target="_blank">聊聊并发（三）——JAVA线程池的分析和使用</a></h3>
<h3 id="-volatile-http-www-infoq-com-cn-articles-ftf-java-volatile-utm_source-infoq-utm_medium-related_content_link-utm_campaign-relatedcontent_articles_clk-"><a href="http://www.infoq.com/cn/articles/ftf-java-volatile?utm_source=infoq&amp;utm_medium=related_content_link&amp;utm_campaign=relatedContent_articles_clk" target="_blank">聊聊并发（一）——深入分析Volatile的实现原理</a></h3>
<h3 id="-java-http-www-infoq-com-cn-articles-java-memory-model-7-utm_source-infoq-utm_medium-related_content_link-utm_campaign-relatedcontent_articles_clk-"><a href="http://www.infoq.com/cn/articles/java-memory-model-7?utm_source=infoq&amp;utm_medium=related_content_link&amp;utm_campaign=relatedContent_articles_clk" target="_blank">深入理解Java内存模型（七）——总结</a></h3>
<h3 id="-java-http-www-infoq-com-cn-articles-java-memory-model-7-utm_source-infoq-utm_medium-related_content_link-utm_campaign-relatedcontent_articles_clk-"><a href="http://www.infoq.com/cn/articles/java-memory-model-7?utm_source=infoq&amp;utm_medium=related_content_link&amp;utm_campaign=relatedContent_articles_clk" target="_blank">深入理解Java内存模型（七）——总结</a></h3>
<h3 id="-java-final-http-www-infoq-com-cn-articles-java-memory-model-6-utm_source-infoq-utm_medium-related_content_link-utm_campaign-relatedcontent_articles_clk-"><a href="http://www.infoq.com/cn/articles/java-memory-model-6?utm_source=infoq&amp;utm_medium=related_content_link&amp;utm_campaign=relatedContent_articles_clk" target="_blank">深入理解Java内存模型（六）——final</a></h3>
<h3 id="-java-http-www-infoq-com-cn-articles-java-memory-model-5-utm_source-infoq-utm_medium-related_content_link-utm_campaign-relatedcontent_articles_clk-"><a href="http://www.infoq.com/cn/articles/java-memory-model-5?utm_source=infoq&amp;utm_medium=related_content_link&amp;utm_campaign=relatedContent_articles_clk" target="_blank">深入理解Java内存模型（五）——锁</a></h3>
<h3 id="-http-www-infoq-com-cn-articles-atomic-operation-utm_source-infoq-utm_medium-related_content_link-utm_campaign-relatedcontent_articles_clk-"><a href="http://www.infoq.com/cn/articles/atomic-operation?utm_source=infoq&amp;utm_medium=related_content_link&amp;utm_campaign=relatedContent_articles_clk" target="_blank">聊聊并发（五）——原子操作的实现原理</a></h3>
<h3 id="-concurrenthashmap-http-www-infoq-com-cn-articles-concurrenthashmap-utm_source-infoq-utm_medium-related_content_link-utm_campaign-relatedcontent_articles_clk-"><a href="http://www.infoq.com/cn/articles/ConcurrentHashMap?utm_source=infoq&amp;utm_medium=related_content_link&amp;utm_campaign=relatedContent_articles_clk" target="_blank">聊聊并发（四）——深入分析ConcurrentHashMap</a></h3>
<h2 id="-">您好，陌生人！</h2>
<p>您需要 <a href="http://www.infoq.com/reginit.action" target="_blank">注册一个InfoQ账号</a> 或者 <a href="">登录</a> 才能进行评论。在您完成注册后还需要进行一些设置。</p>
<h2 id="-infoq-">获得来自InfoQ的更多体验。<a href=""></a></h2>
<p>允许的HTML标签: a,b,br,blockquote,i,li,pre,u,ul,p</p>
<p>当有人回复此评论时请E-mail通知我</p>
<p>社区评论 <a href="">Watch Thread</a></p>
<p><a href=""><strong>CAS 描述有错</strong> by lin lirs Posted 10/01/2013 05:35</a>
<a href=""><strong>Re: CAS 描述有错</strong> by 方 腾飞 Posted 11/01/2013 03:10</a></p>
<p><a href=""><strong>请教大师，有个地方不是很明白</strong> by huang shuihua Posted 18/01/2013 02:58</a>
<a href=""><strong>Re: 请教大师，有个地方不是很明白</strong> by 方 腾飞 Posted 18/01/2013 03:40</a></p>
<p><a href=""><strong>看着不过瘾，买了本书</strong> by 杨 亮 Posted 04/03/2013 01:42</a>
<a href=""></a></p>
<p><strong>CAS 描述有错</strong> 10/01/2013 05:35 by lin lirs</p>
<p>“它采用了“wait－free”算法（即CAS算法）来实现”， CAS不是指算法，而是一个原子操作，wait-free不等同CAS。
<a href="http://en.wikipedia.org/wiki/Compare-and-swap" target="_blank">en.wikipedia.org/wiki/Compare-and-swap</a></p>
<ul>
<li><a href="">回复</a></li>
<li><a href="">回到顶部</a></li>
</ul>
<p><a href=""></a></p>
<p><strong>Re: CAS 描述有错</strong> 11/01/2013 03:10 by 方 腾飞</p>
<p>的确！CAS是一个原子操作指令，可以用来实现“wait－free”算法。这里用“既CAS算法”的确不太合适，我加上的初衷是希望读者能很好的理解“wait－free”算法，但这样会产生一些歧义，所以还是删掉比较合适，感谢您的纠正。</p>
<ul>
<li><a href="">回复</a></li>
<li><a href="">回到顶部</a>
<a href=""></a></li>
</ul>
<p><strong>请教大师，有个地方不是很明白</strong> 18/01/2013 02:58 by huang shuihua</p>
<p>(如果tail节点的next节点不为空，则将入队节点设置成tail节点，如果tail节点的next节点为空，则将入队节点设置成tail的next节点，所以tail节点不总是尾节点),这个还是不是很明白，能否有更加清晰一点的原理图show一下，谢谢!</p>
<ul>
<li><a href="">回复</a></li>
<li><a href="">回到顶部</a></li>
</ul>
<p><a href=""></a></p>
<p><strong>Re: 请教大师，有个地方不是很明白</strong> 18/01/2013 03:40 by 方 腾飞</p>
<p>tail节点并总是尾节点。入队的时候，入队节点要放在队列的尾部，那首先要定位尾节点是哪个节点？所以这里通过tail节点来定位尾节点。尾节点要么是tail节点，要么是tail的next节点。所以入队会有两种情况
情况1：tail节点的next节点不为空，那么插入后队列变成
旧的tail节点-&gt;旧tail节点的next节点-&gt;入队节点（新tail节点）
情况2：tail节点的next节点为空，那么插入后队列变成
tail节点-&gt;入队节点</p>
<ul>
<li><a href="">回复</a></li>
<li><a href="">回到顶部</a>
<a href=""></a></li>
</ul>
<p><strong>看着不过瘾，买了本书</strong> 04/03/2013 01:42 by 杨 亮</p>
<p>聊聊并发这个系列都看了，结合内存模型系列，但还是看着不过瘾，买了本书看。</p>
<ul>
<li><a href="">回复</a></li>
<li><a href="">回到顶部</a></li>
</ul>
<p><a href="">关闭</a></p>
<h3 id="-by"><em>**</em>by</h3>
<p>发布于</p>
<ul>
<li><a href="">查看</a></li>
<li><a href="">回复</a></li>
<li><a href="">回到顶部</a>
<a href="">关闭</a> 主题  您的回复 <a href="">引用原消息</a></li>
</ul>
<p>允许的HTML标签: a,b,br,blockquote,i,li,pre,u,ul,p
当有人回复此评论时请E-mail通知我</p>
<p><a href="">关闭</a> 主题  您的回复</p>
<p>允许的HTML标签: a,b,br,blockquote,i,li,pre,u,ul,p
当有人回复此评论时请E-mail通知我
<a href="">关闭</a></p>
<ul>
<li>热点内容</li>
<li><a href="">本周</a></li>
<li><a href="">本月</a></li>
<li><a href="">近6个月</a><h3 id="-32-http-www-infoq-com-cn-news-2012-08-32-most-important-algorithms-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2012/08/32-most-important-algorithms?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">计算机科学中最重要的32个算法</a></h3>
</li>
</ul>
<h3 id="-thoughtworks-2013-5-http-www-infoq-com-cn-articles-thoughtworks-technology-radar-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/thoughtWorks-technology-radar?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">ThoughtWorks技术雷达（2013年5月）</a></h3>
<h3 id="-1-5-http-www-infoq-com-cn-articles-iqiyi-cloud-push-practices-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/iqiyi-cloud-push-practices?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">让1.5亿移动端用户第一时间获取消息</a></h3>
<h3 id="-thoughtworks-ceo-http-www-infoq-com-cn-news-2013-06-tw-guoxiao-on-talents-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2013/06/tw-guoxiao-on-talents?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">ThoughtWorks全球CEO郭晓谈软件人才的招聘与培养</a></h3>
<h3 id="-http-www-infoq-com-cn-news-2013-06-10-sins-for-scalability-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2013/06/10-sins-for-scalability?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">影响可扩展性的十宗罪</a></h3>
<h3 id="-6-http-www-infoq-com-cn-minibooks-architect-jun-10-2013-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/architect-jun-10-2013?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">架构师（6月刊）</a></h3>
<h3 id="-http-www-infoq-com-cn-articles-function-switch-realize-better-continuous-implementations-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/function-switch-realize-better-continuous-implementations?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">使用功能开关更好地实现持续部署</a></h3>
<h3 id="-eclipse-github-http-www-infoq-com-cn-news-2013-06-eclipse-github-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2013/06/eclipse-github?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">Eclipse迁移到GitHub</a></h3>
<h3 id="-newegg-com-http-www-infoq-com-cn-presentations-newegg-big-data-practice-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/presentations/newegg-big-data-practice?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">Newegg.com大数据实践</a></h3>
<h3 id="-http-www-infoq-com-cn-minibooks-software-sys-architect-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/software-sys-architect?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">软件系统架构：使用视点和视角与利益相关者合作</a></h3>
<h3 id="-32-http-www-infoq-com-cn-news-2012-08-32-most-important-algorithms-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2012/08/32-most-important-algorithms?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">计算机科学中最重要的32个算法</a></h3>
<h3 id="-6-http-www-infoq-com-cn-minibooks-architect-jun-10-2013-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/architect-jun-10-2013?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">架构师（6月刊）</a></h3>
<h3 id="-rest-http-www-infoq-com-cn-news-2013-06-rest-drawbacks-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2013/06/rest-drawbacks?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">REST的缺点是什么？</a></h3>
<h3 id="-google-web-ui-polymer-http-www-infoq-com-cn-news-2013-06-webcomponents-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2013/06/webcomponents?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">Google 发布新一代Web UI库Polymer</a></h3>
<h3 id="-http-www-infoq-com-cn-news-2013-06-dianping-xinnet-hacked-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2013/06/dianping-xinnet-hacked?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">大众点评网域名劫持事件概述</a></h3>
<h3 id="-node-js-grunt-js-http-www-infoq-com-cn-articles-gruntjs-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/GruntJs?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">基于Node.js的自动化构建工具Grunt.js</a></h3>
<h3 id="-node-js-node-js-http-www-infoq-com-cn-articles-what-is-nodejs-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/what-is-nodejs?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">深入浅出Node.js（一）：什么是Node.js</a></h3>
<h3 id="-http-www-infoq-com-cn-minibooks-i-m-wrights-hard-code-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/i-m-wrights-hard-code?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">代码之殇·第二版</a></h3>
<h3 id="-http-www-infoq-com-cn-minibooks-software-sys-architect-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/software-sys-architect?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">软件系统架构：使用视点和视角与利益相关者合作</a></h3>
<h3 id="-18-java-http-www-infoq-com-cn-news-2013-06-zhuhong-on-java-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2013/06/zhuhong-on-java?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">大家谈18岁的Java——朱鸿：开过跑车后再去开大巴车总是有点不爽的</a></h3>
<h3 id="-32-http-www-infoq-com-cn-news-2012-08-32-most-important-algorithms-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2012/08/32-most-important-algorithms?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">计算机科学中最重要的32个算法</a></h3>
<h3 id="-java-http-www-infoq-com-cn-articles-java-memory-model-1-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/java-memory-model-1?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">深入理解Java内存模型（一）——基础</a></h3>
<h3 id="-node-js-node-js-http-www-infoq-com-cn-articles-what-is-nodejs-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/what-is-nodejs?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">深入浅出Node.js（一）：什么是Node.js</a></h3>
<h3 id="-node-js-node-js-npm-http-www-infoq-com-cn-articles-nodejs-npm-install-config-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/nodejs-npm-install-config?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">深入浅出Node.js（二）：Node.js&amp;NPM的安装与配置</a></h3>
<h3 id="-3-http-www-infoq-com-cn-minibooks-architect-mar-10-2013-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/architect-mar-10-2013?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">架构师（3月刊）</a></h3>
<h3 id="-1-http-www-infoq-com-cn-minibooks-architect-jan-10-2013-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/architect-jan-10-2013?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">架构师（1月刊）</a></h3>
<h3 id="-4-http-www-infoq-com-cn-minibooks-architect-apr-10-2013-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/architect-apr-10-2013?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">架构师（4月刊）</a></h3>
<h3 id="-java-http-www-infoq-com-cn-articles-java-threadpool-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/java-threadPool?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">聊聊并发（三）——JAVA线程池的分析和使用</a></h3>
<h3 id="-2-http-www-infoq-com-cn-minibooks-architect-feb-10-2013-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/architect-feb-10-2013?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">架构师（2月刊）</a></h3>
<h3 id="-12306-github-http-www-infoq-com-cn-news-2013-01-12306-plugin-ddos-github-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2013/01/12306-plugin-ddos-github?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">12306订票助手插件拖垮GitHub事件原因始末</a></h3>
<h3 id="-32-http-www-infoq-com-cn-news-2012-08-32-most-important-algorithms-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2012/08/32-most-important-algorithms?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">计算机科学中最重要的32个算法</a></h3>
<h3 id="-thoughtworks-2013-5-http-www-infoq-com-cn-articles-thoughtworks-technology-radar-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/thoughtWorks-technology-radar?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">ThoughtWorks技术雷达（2013年5月）</a></h3>
<h3 id="-1-5-http-www-infoq-com-cn-articles-iqiyi-cloud-push-practices-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/iqiyi-cloud-push-practices?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">让1.5亿移动端用户第一时间获取消息</a></h3>
<h3 id="-thoughtworks-ceo-http-www-infoq-com-cn-news-2013-06-tw-guoxiao-on-talents-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2013/06/tw-guoxiao-on-talents?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">ThoughtWorks全球CEO郭晓谈软件人才的招聘与培养</a></h3>
<h3 id="-http-www-infoq-com-cn-news-2013-06-10-sins-for-scalability-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2013/06/10-sins-for-scalability?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">影响可扩展性的十宗罪</a></h3>
<h3 id="-6-http-www-infoq-com-cn-minibooks-architect-jun-10-2013-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/architect-jun-10-2013?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">架构师（6月刊）</a></h3>
<h3 id="-http-www-infoq-com-cn-articles-function-switch-realize-better-continuous-implementations-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/function-switch-realize-better-continuous-implementations?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">使用功能开关更好地实现持续部署</a></h3>
<h3 id="-eclipse-github-http-www-infoq-com-cn-news-2013-06-eclipse-github-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2013/06/eclipse-github?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">Eclipse迁移到GitHub</a></h3>
<h3 id="-newegg-com-http-www-infoq-com-cn-presentations-newegg-big-data-practice-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/presentations/newegg-big-data-practice?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">Newegg.com大数据实践</a></h3>
<h3 id="-http-www-infoq-com-cn-minibooks-software-sys-architect-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/software-sys-architect?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">软件系统架构：使用视点和视角与利益相关者合作</a></h3>
<h3 id="-32-http-www-infoq-com-cn-news-2012-08-32-most-important-algorithms-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2012/08/32-most-important-algorithms?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">计算机科学中最重要的32个算法</a></h3>
<h3 id="-6-http-www-infoq-com-cn-minibooks-architect-jun-10-2013-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/architect-jun-10-2013?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">架构师（6月刊）</a></h3>
<h3 id="-rest-http-www-infoq-com-cn-news-2013-06-rest-drawbacks-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2013/06/rest-drawbacks?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">REST的缺点是什么？</a></h3>
<h3 id="-google-web-ui-polymer-http-www-infoq-com-cn-news-2013-06-webcomponents-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2013/06/webcomponents?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">Google 发布新一代Web UI库Polymer</a></h3>
<h3 id="-http-www-infoq-com-cn-news-2013-06-dianping-xinnet-hacked-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2013/06/dianping-xinnet-hacked?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">大众点评网域名劫持事件概述</a></h3>
<h3 id="-node-js-grunt-js-http-www-infoq-com-cn-articles-gruntjs-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/GruntJs?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">基于Node.js的自动化构建工具Grunt.js</a></h3>
<h3 id="-node-js-node-js-http-www-infoq-com-cn-articles-what-is-nodejs-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/what-is-nodejs?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">深入浅出Node.js（一）：什么是Node.js</a></h3>
<h3 id="-http-www-infoq-com-cn-minibooks-i-m-wrights-hard-code-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/i-m-wrights-hard-code?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">代码之殇·第二版</a></h3>
<h3 id="-http-www-infoq-com-cn-minibooks-software-sys-architect-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/software-sys-architect?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">软件系统架构：使用视点和视角与利益相关者合作</a></h3>
<h3 id="-18-java-http-www-infoq-com-cn-news-2013-06-zhuhong-on-java-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2013/06/zhuhong-on-java?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">大家谈18岁的Java——朱鸿：开过跑车后再去开大巴车总是有点不爽的</a></h3>
<h3 id="-32-http-www-infoq-com-cn-news-2012-08-32-most-important-algorithms-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2012/08/32-most-important-algorithms?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">计算机科学中最重要的32个算法</a></h3>
<h3 id="-java-http-www-infoq-com-cn-articles-java-memory-model-1-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/java-memory-model-1?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">深入理解Java内存模型（一）——基础</a></h3>
<h3 id="-node-js-node-js-http-www-infoq-com-cn-articles-what-is-nodejs-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/what-is-nodejs?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">深入浅出Node.js（一）：什么是Node.js</a></h3>
<h3 id="-node-js-node-js-npm-http-www-infoq-com-cn-articles-nodejs-npm-install-config-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/nodejs-npm-install-config?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">深入浅出Node.js（二）：Node.js&amp;NPM的安装与配置</a></h3>
<h3 id="-3-http-www-infoq-com-cn-minibooks-architect-mar-10-2013-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/architect-mar-10-2013?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">架构师（3月刊）</a></h3>
<h3 id="-1-http-www-infoq-com-cn-minibooks-architect-jan-10-2013-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/architect-jan-10-2013?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">架构师（1月刊）</a></h3>
<h3 id="-4-http-www-infoq-com-cn-minibooks-architect-apr-10-2013-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/architect-apr-10-2013?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">架构师（4月刊）</a></h3>
<h3 id="-java-http-www-infoq-com-cn-articles-java-threadpool-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/java-threadPool?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">聊聊并发（三）——JAVA线程池的分析和使用</a></h3>
<h3 id="-2-http-www-infoq-com-cn-minibooks-architect-feb-10-2013-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/architect-feb-10-2013?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">架构师（2月刊）</a></h3>
<h3 id="-12306-github-http-www-infoq-com-cn-news-2013-01-12306-plugin-ddos-github-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2013/01/12306-plugin-ddos-github?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">12306订票助手插件拖垮GitHub事件原因始末</a></h3>
<h2 id="-">深度内容</h2>
<ul>
<li><a href="">全部</a></li>
<li><a href="">文章</a></li>
<li><a href="">演讲</a></li>
<li><a href="">访谈</a></li>
<li><a href="">迷你书</a></li>
</ul>
<h2 id="-juergen-fesslmeier-javascript-http-www-infoq-com-cn-interviews-end-to-end-javascript-juergen-fesslmeier-javascript-"><a href="http://www.infoq.com/cn/interviews/end-to-end-javascript" title="Juergen Fesslmeier谈端到端的JavaScript开发" target="_blank">Juergen Fesslmeier谈端到端的JavaScript开发</a></h2>
<p><a href="http://www.infoq.com/cn/author/Juergen-Fesslmeier" title="Juergen Fesslmeier" target="_blank">Juergen Fesslmeier</a> 七月 02, 2013</p>
<p><a href="http://www.infoq.com/cn/interviews/end-to-end-javascript" title="Juergen Fesslmeier谈端到端的JavaScript开发" target="_blank"><img src="" alt=""></a></p>
<h2 id="-http-www-infoq-com-cn-articles-design-pattern-automation-"><a href="http://www.infoq.com/cn/articles/Design-Pattern-Automation" title="设计模式自动化" target="_blank">设计模式自动化</a></h2>
<p><a href="http://www.infoq.com/cn/author/Gael-Fraiteur-and-Yan-Cui" title="Gael Fraiteur and Yan Cui" target="_blank">Gael Fraiteur and Yan Cui</a> 七月 01, 2013</p>
<p><a href="http://www.infoq.com/cn/articles/Design-Pattern-Automation" title="设计模式自动化" target="_blank"><img src="" alt=""></a></p>
<h2 id="-http-www-infoq-com-cn-articles-designing-a-world-at-your-fingertips-mobile-user-interfaces-"><a href="http://www.infoq.com/cn/articles/designing-a-world-at-your-fingertips-mobile-user-interfaces" title="设计指尖上的世界：移动用户界面一瞥" target="_blank">设计指尖上的世界：移动用户界面一瞥</a></h2>
<p><a href="http://www.infoq.com/cn/author/Forrest-Shull" title="Forrest Shull" target="_blank">Forrest Shull</a> 六月 28, 2013</p>
<p><a href="http://www.infoq.com/cn/articles/designing-a-world-at-your-fingertips-mobile-user-interfaces" title="设计指尖上的世界：移动用户界面一瞥" target="_blank"><img src="" alt=""></a></p>
<h2 id="-alm-http-www-infoq-com-cn-articles-integrated-alm-alm-"><a href="http://www.infoq.com/cn/articles/Integrated-ALM" title="成功的根本—集成的ALM工具" target="_blank">成功的根本—集成的ALM工具</a></h2>
<p><a href="http://www.infoq.com/cn/author/Dave-West" title="Dave West" target="_blank">Dave West</a> 六月 28, 2013</p>
<p><a href="http://www.infoq.com/cn/articles/Integrated-ALM" title="成功的根本—集成的ALM工具" target="_blank"><img src="" alt=""></a></p>
<h2 id="-http-www-infoq-com-cn-articles-atdd-by-example-book-"><a href="http://www.infoq.com/cn/articles/atdd-by-example-book" title="书评：验收测试驱动开发实践指南" target="_blank">书评：验收测试驱动开发实践指南</a></h2>
<p><a href="http://www.infoq.com/cn/author/Manuel-Pais" title="Manuel Pais" target="_blank">Manuel Pais</a> 六月 26, 2013</p>
<p><a href="http://www.infoq.com/cn/articles/atdd-by-example-book" title="书评：验收测试驱动开发实践指南" target="_blank"><img src="" alt=""></a></p>
<h2 id="-web-http-www-infoq-com-cn-presentations-across-device-web-web-"><a href="http://www.infoq.com/cn/presentations/across-device-web" title="跨终端的web" target="_blank">跨终端的web</a></h2>
<p><a href="http://www.infoq.com/cn/author/%E8%88%92%E6%96%87%E4%BA%AE" title="舒文亮" target="_blank">舒文亮</a> 六月 26, 2013</p>
<p><a href="http://www.infoq.com/cn/presentations/across-device-web" title="跨终端的web" target="_blank"><img src="" alt=""></a></p>
<ul>
<li><a href="">更早的 &gt;</a></li>
</ul>
<p><a href="">Close</a> E-mail  密码</p>
<p><a href="http://www.infoq.com/cn/social/googleLogin.action?fl=login" title="使用Google账号登录" target="_blank">使用Google账号登录</a> <a href="http://www.infoq.com/cn/social/liveLogin.action?fl=login" title="使用Microsoft账号登录" target="_blank">使用Microsoft账号登录</a>
<a href="">忘记密码？</a>
 InfoQ账号使用的E-mail 发送邮件</p>
<p><a href="">重新登录</a>
重新发送激活信息 重新发送</p>
<p><a href="">重新登录</a>
<a href="http://www.infoq.com/cn/reginit.action" target="_blank">没有用户名？</a></p>
<p><a href="http://www.infoq.com/cn/reginit.action" target="_blank">点击注册</a>
<img src="&quot;定义(粉红" alt="">&quot;)<img src="&quot;假设(蓝色" alt="">&quot;)<img src="&quot;分析(黄色" alt="">&quot;)<img src="&quot;结论(橘红" alt="">&quot;)<img src="&quot;优势(绿色" alt="">&quot;)<img src="&quot;缺陷(紫色" alt="">&quot;)<img src="&quot;注意(红色" alt="">&quot;)<img src="&quot;清除背景色&quot;" alt=""><img src="&quot;书签&quot;" alt=""><img src="&quot;设为目录项&quot;" alt=""><img src="&quot;在Google中搜索&quot;" alt=""><img src="&quot;查找解释&quot;" alt=""><img src="&quot;标注&quot;" alt=""><img src="&quot;链接到所选文件夹/标签/样式/文件&quot;" alt=""><img src="&quot;Wiz助手&quot;" alt=""><img src="&quot;稍后阅读(tag" alt="">&quot;)</p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/Java_多线程/">Java_多线程</a></li><li><a href="/categories/Java&J2EE/Java_多线程/并发/">并发</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/Java_多线程/" class="label label-success">Java_多线程</a><a href="/tags/并发/" class="label label-info">并发</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:41"datetime="2014-03-07 09:54:41"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-Java_多线程-并发--聊聊并发（六）——ConcurrentLinkedQueue的实现原理分析/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-Java_多线程-并发--聊聊并发（六）——ConcurrentLinkedQueue的实现原理分析" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>





<ul id="pagination" class="pagination pagination-lg">
  <li><a class="extend prev" href="/page/52/">&laquo;</a></li><li><a class="page-number" href="/">1</a></li><li><a class="page-number" href="/page/2/">2</a></li><li><span class="space">&hellip;</span></li><li><a class="page-number" href="/page/50/">50</a></li><li><a class="page-number" href="/page/51/">51</a></li><li><a class="page-number" href="/page/52/">52</a></li><li class="active"><li><span class="page-number current">53</span></li><li><a class="page-number" href="/page/54/">54</a></li><li><a class="page-number" href="/page/55/">55</a></li><li><a class="page-number" href="/page/56/">56</a></li><li><span class="space">&hellip;</span></li></li><li><a class="page-number" href="/page/161/">161</a></li><li><a class="page-number" href="/page/162/">162</a></li><li><a class="extend next" href="/page/54/">&raquo;</a></li>
  <div class="clearfix"></div>
</ul></div><!--wapper-->
       </div><!-- ID main-col END -->
       <aside id="sidebar" class="alignright col-sx-6 col-sm-4 col-md-3 col-lg-3">
<div id="widget_search" class="widget panel panel-primary">
    <form action="//google.com/search" method="get" accept-charset="utf-8">
  <div class="input-group">
    <input class="form-control" id="searchbox" type="search" name="q" results="0" placeholder="search">
    <span class="input-group-btn">
      <button class="btn btn-default" type="submit">Go!</button>
    </span>
    <input type="hidden" name="q" value="site:itsolife.com">
  </div>
</form>
</div>

<div id="widget_category" class="widget panel panel-primary">
  <div class="panel-heading">category</div>  <div data-src='category' class='ajax_widgets'>正在加载...</div>
</div>

<div id="widget_recent_posts" class="widget panel panel-primary">
  <div class="panel-heading">recent posts</div>  <div data-src='recent_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_tagcloud" class="widget panel panel-primary">
  <div class="panel-heading">tagcloud</div>  <div data-src='tagcloud' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_latest_update_posts" class="widget panel panel-primary">
  <div class="panel-heading">最近更新</div>  <div data-src='latest_update_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_recent_comments" class="widget panel panel-primary">
  <div class="panel-heading">recent comments</div>  

<div class="list-group-item ds-recent-comments" data-num-items="6" data-show-avatars="1" data-show-time="1" data-show-title="1" data-show-admin="1" data-excerpt-length="50"></div>



</div>

</aside>
       <div class="clearfix"></div>
     </div><!-- row END -->
  </div>
  <footer id="footer" class="container">
  <div class="panel panel-info">
  <section id='footer_widget'></section>  <div class="panel-footer">
  <div id="site-info">
    <span class='author'>
  
  &copy; 2014 RobinChia
  
    &nbsp;&nbsp;</span>
  
  <span id='analytics-51la'></span><span id='analytics-google'>
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-48559895-1']);
  _gaq.push(['_trackPageview']);
  _js2load.push({src:('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'});
</script></span><span id='analytics-cnzz'>
<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_5774006'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s17.cnzz.com/stat.php%3Fid%3D5774006%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>
</span><span id='analytics-baidu'>
<script>
var _hmt = _hmt || [];
_js2load.push({src:"//hm.baidu.com/hm.js?1442f50724afc42380b51f097c43082c"});
</script>
</span>  </div>
  <div id="copyright">Site powered by <a href='http://zespia.tw/hexo/'><strong>hexo</strong></a>  update time: <em>2014-04-07 18:24:57</em></span></div>
</div>
<div class="clearfix"></div>


  </div>
  </footer>
  
        <script src="http://cdn.bootcss.com/jquery/1.10.2/jquery.min.js"></script>        
        <script src="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/js/bootstrap.min.js"></script>        
                
        <script src="http://cdn.bootcss.com/prettify/r298/prettify.min.js"></script>    <script type="text/javascript">
   var lang=["bsh", "c", "cc", "cpp", "cs", "csh", "cyc", "cv", "htm", "html",
    "java", "js", "m", "mxml", "perl", "pl", "pm", "py", "rb", "sh",
    "xhtml", "xml", "xsl"];
   var pretty_base='';
   $('script').each(function(){
	var c = $(this).attr('src');
	if (!c)
	    return;
	if (c.match(/(\/)?prettify(\.min)?\.js/i))
	{
	    var index = c.lastIndexOf('/');
	    if (index != -1)
		pretty_base = c.substr(0,index + 1);
	    return false;
	}
   })
   $('pre code').each(function(){
	var c = $(this).attr('class')
	if (!c)
	    return;
	c = c.match(/\s?(lang\-\w+)/i);
	if (c && lang.indexOf(c[1]) == -1)
	{
	    lang.push(c[1]);
	    $.getScript(pretty_base + c[1] + '.min.js');
	}
   })

    $(window).load(function(){
       $("pre").addClass("prettyprint");
       prettyPrint();
    })
</script>    
            <script type="text/javascript">
var duoshuoQuery = {short_name:"robinchia"};
_js2load.push({src:'http://static.duoshuo.com/embed.js',charset:'UTF-8'});
</script>
    
            <!--wumii_relatedItems-->
    
        <script src="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js"></script>    <script type="text/javascript">
(function($){
  $('.entry').each(function(i){
    $(this).find('img').each(function(){
      var alt = this.alt;

      if (alt){
        $(this).before('<span class="caption">' + alt + '</span>');
      }

      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox" rel="fancybox' + i + '" />');
    });
  });

  $('.fancybox').fancybox();
})(jQuery);
</script>    
        <script src="http://cdn.bootcss.com/mathjax/2.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>    <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>
    
<script type="text/javascript">
$('.ajax_widgets').each(function(){var src=$(this).attr('data-src');if(src)$(this).load('/widgets/'+src+'.html');});
$.each(_js2load,function(index,obj){loadjs(obj.src,obj.charset)});
</script>

<div id="scroll2top">
<img src="/scroll2top/arrow.png"/>
</div>
<script src="/scroll2top/scroll2top.min.js"></script>
<div id="winterland">
  <canvas></canvas>
</div>
<script src="/js/winterland.min.js"></script>

  </body>
</html>
