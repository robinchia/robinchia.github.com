
<!DOCTYPE HTML>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>The 53 Page | It so life</title>
<meta name="author" content="RobinChia">

<meta name="description" content="It so life">


<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<meta property="og:site_name" content="It so life"/>

<!--[if IE]><style>.testIE.IE{display:inline;}</style><![endif]-->
<!--[if lte IE 7]><link rel="stylesheet" href="/css/ie7.css" type="text/css"><![endif]-->
<!--[if (lt IE 9)&(gt IE 7)]><style>.testIE.IE8{display:inline;}</style><![endif]-->
<!--[if gt IE 8]><style>.testIE.IE9{display:inline;}</style><![endif]-->

<link href="/favicon.png" rel="icon">
<link rel="alternate" href="/atom.xml" title="It so life Feed" type="application/atom+xml">

<link rel="stylesheet" href="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/css/bootstrap.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/font-awesome/4.0.3/css/font-awesome.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/prettify/r298/prettify.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" type="text/css">
<link rel="stylesheet" href="/css/style.css" type="text/css">
<!--[if lt IE 9]>
   <style>article,aside,dialog,footer,header,section,footer,nav,figure,menu{display:block}</style>
   <script src="http://cdn.staticfile.org/html5shiv/r29/html5.min.js"></script>
   <script src="http://cdn.staticfile.org/respond.js/1.4.2/respond.min.js"></script>
<link href="http://cdn.staticfile.org/respond.js/1.4.2/respond-proxy.html" id="respond-proxy" rel="respond-proxy" />
<link href="/js/respond.proxy.gif" id="respond-redirect" rel="respond-redirect" />
<script src="/js/respond.proxy.js"></script>
   <script src="http://cdn.bootcss.com/selectivizr/1.0.2/selectivizr-min.js"></script>
<![endif]-->
<script type="text/javascript">
function loadjs(c,d){var a=document.createElement("script");a.async=!0;a.type="text/javascript";a.src=c;a.charset=d||"gbk";(document.getElementsByTagName("HEAD")[0]||document.getElementsByTagName("BODY")[0]).appendChild(a)};
var _protocol = (("https:" == document.location.protocol) ? " https://" : " http://");
var _js2load = [];
</script>

</head>
<body>
      <header id="header" class="container"><nav id="main-nav" class="navbar navbar-default navbar-fixed-top " role="navigation">
  <div class="container">
    <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
      <span class="sr-only">Toggle navigation</span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="/">It so life</a>
    </div>
    <div  class="collapse navbar-collapse">
      <ul  class="nav navbar-nav">
  
        <li><a href="/" title="Home">Home</a></li>      
        <li><a href="/about/" title="About">About</a></li>      
        <li><a href="/archives/" title="Archives">Archives</a></li>      
      <li class='dropdown'>
        <a class='dropdown-toggle' data-toggle='dropdown' href='#'>website<b class='caret'></b></a>
        <ul class='dropdown-menu pure-menu-selected'>
    
          <li><a href="//groups.google.com/forum/#!forum/pongba" title="TopLanguage">TopLanguage</a></li>    
          <li><a href="//itpub.net/" title="ITPub">ITPub</a></li>    
          <li><a href="//blog.jobbole.com/" title="Bole">Bole</a></li>    
          <li><a href="//nosql-database.org/" title="nosql">nosql</a></li>    
          <li><a href="//gitimmersion.googol.im/" title="Git">Git</a></li>    
        </ul>
      </li>
    
      </ul>
      <ul class="nav navbar-nav navbar-right">
      
        <li><a href="/atom.xml">RSS</a></li>
      
      
        <li><a href="https://twitter.com/robinchia">twitter</a></li>
      
      
      
      
        <li><a href="https://github.com/robinchia">github</a></li>
      
      </ul>
    </div>
  </div>
</nav>
<div class="clearfix"></div>
</header>
  <div id='content' class="container">
     <div class="page-header-wrapper">
      <!--[if lt IE 9]><div class="alert alert-warning alert-dismissable"><button type="button" class="close" data-dismiss="alert" aria-hidden="true">&times;</button><strong>提示:</strong>您的浏览器版本太低了,建议升级到 <strong><a href="http://windows.microsoft.com/zh-cn/internet-explorer/download-ie" title="IE9">IE9</a></strong> 以上,本站使用<a href="https://www.google.com/intl/zh-CN/chrome/">Chrome浏览器</a>可以获得最好的显示效果.</div><![endif]-->
      <div class="page-header"><h1 align="center"><big>It so life</big> </h1>
        <h5 align="center"><big>love as life</big></h5>
      </div>
     </div>
     <div class="row">
       <div id="main-col" class="alignleft col-sx-12 col-sm-8 col-md-9 col-lg-9">
      <section id='header_widget'></section>
          <div id="wrapper"><article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--通过Java-JMX得到fullGC次数？-高级语言虚拟机/">通过Java</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:42.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--通过Java-JMX得到fullGC次数？-高级语言虚拟机/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-java-jmx-full-gc-">通过Java/JMX得到full GC次数？ - 高级语言虚拟机</h1>
<p><a href="http://hllvm.group.iteye.com/login" title="登录" target="_blank">您还未登录 !</a> <a href="http://hllvm.group.iteye.com/login" target="_blank">登录</a> <a href="http://hllvm.group.iteye.com/signup" target="_blank">注册</a></p>
<p><a href="http://www.iteye.com/" target="_blank"><img src="&quot;ITeye-最棒的软件开发交流社区&quot;" alt="ITeye3.0"></a></p>
<p><a href=""></a></p>
<p><a href="http://www.iteye.com/groups" target="_blank">群组首页</a> → <a href="http://hllvm.group.iteye.com/groups/category/language" target="_blank">编程语言</a> → <a href="http://hllvm.group.iteye.com/" target="_blank">高级语言虚拟机</a> → <a href="http://hllvm.group.iteye.com/group/wiki" target="_blank">知识库</a> → <a href="http://hllvm.group.iteye.com/group/wiki?category_id=315" target="_blank">JVM实战</a> → <a href="">通过Java/JMX得到full GC次数？</a>
原创作者: <a href="http://www.javaeye.com/topic/790015" target="_blank">RednaxelaFX</a>   阅读:2261次   评论:1条   更新时间:2011-05-26    </p>
<p>今天有个同事问如何能通过<a href="http://java.sun.com/javase/technologies/core/mntr-mgmt/javamanagement/" target="_blank">JMX</a>获取到某个Java进程的full GC次数：
引用</p>
<p>hi,问个问题，怎们在java中获取到full gc的次数呢？
我现在用jmx的那个得到了gc次数，不过不能细化出来full gc的次数
Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>for (final GarbageCollectorMXBean garbageCollector  </li>
<li>: ManagementFactory.getGarbageCollectorMXBeans()) {  </li>
<li>gcCounts += garbageCollector.getCollectionCount();  </li>
<li><p>}<br>for (final GarbageCollectorMXBean garbageCollector : ManagementFactory.getGarbageCollectorMXBeans()) { gcCounts += garbageCollector.getCollectionCount(); }
你比如我现在是这样拿次数的
我回答说因为full GC概念只有在分代式GC的上下文中才存在，而JVM并不强制要求GC使用分代式实现，所以JMX提供的标准<a href="http://download-llnw.oracle.com/javase/6/docs/technotes/guides/management/mxbeans.html" target="_blank">MXBean</a> API里不提供“full GC次数”这样的方法也正常。
既然“full GC”本来就是非常平台相关的概念，那就hack一点，用平台相关的代码来解决问题好了。这些GC的MXBean都是有名字的，而主流的JVM的GC名字相对稳定，非要通过JMX得到full GC次数的话，用名字来判断一下就好了。
举个例子来看看。通过JDK 6自带的<a href="http://download-llnw.oracle.com/javase/6/docs/technotes/guides/management/jconsole.html" target="_blank">JConsole</a>工具来查看相关的MXBean的话，可以看到，
GC的MXBean在这个位置：
<img src="&quot;点击查看原始大小图片&quot;" alt="">
这个例子是用server模式启动JConsole的，使用的是ParallelScavenge GC，它的年老代对应的收集器在这里：
<img src="&quot;点击查看原始大小图片&quot;" alt="">
该收集器的总收集次数在此，这也就是full GC的次数：
<img src="&quot;点击查看原始大小图片&quot;" alt="">
于是只要知道我们用的JVM提供的GC MXBean的名字与分代的关系，就可以知道full GC的次数了。
Java代码写起来冗长，这帖就不用Java来写例子了，反正API是一样的，意思能表达清楚就OK。
用一个<a href="http://groovy.codehaus.org/" target="_blank">Groovy</a>脚本简单演示一下适用于Oracle (Sun) HotSpot与Oracle (BEA) JRockit的GC统计程序：
Groovy代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>import java.lang.management.ManagementFactory  </p>
</li>
<li></li>
<li>printGCStats = {  </li>
<li>def youngGenCollectorNames = [  </li>
<li>// Oracle (Sun) HotSpot  </li>
<li>// -XX:+UseSerialGC  </li>
<li>&#39;Copy&#39;,  </li>
<li>// -XX:+UseParNewGC  </li>
<li>&#39;ParNew&#39;,  </li>
<li>// -XX:+UseParallelGC  </li>
<li>&#39;PS Scavenge&#39;,  </li>
<li></li>
<li>// Oracle (BEA) JRockit  </li>
<li>// -XgcPrio:pausetime  </li>
<li>&#39;Garbage collection optimized for short pausetimes Young Collector&#39;,  </li>
<li>// -XgcPrio:throughput  </li>
<li>&#39;Garbage collection optimized for throughput Young Collector&#39;,  </li>
<li>// -XgcPrio:deterministic  </li>
<li>&#39;Garbage collection optimized for deterministic pausetimes Young Collector&#39;  </li>
<li>]  </li>
<li></li>
<li>def oldGenCollectorNames = [  </li>
<li>// Oracle (Sun) HotSpot  </li>
<li>// -XX:+UseSerialGC  </li>
<li>&#39;MarkSweepCompact&#39;,  </li>
<li>// -XX:+UseParallelGC and (-XX:+UseParallelOldGC or -XX:+UseParallelOldGCCompacting)  </li>
<li>&#39;PS MarkSweep&#39;,  </li>
<li>// -XX:+UseConcMarkSweepGC  </li>
<li>&#39;ConcurrentMarkSweep&#39;,  </li>
<li></li>
<li>// Oracle (BEA) JRockit  </li>
<li>// -XgcPrio:pausetime  </li>
<li>&#39;Garbage collection optimized for short pausetimes Old Collector&#39;,  </li>
<li>// -XgcPrio:throughput  </li>
<li>&#39;Garbage collection optimized for throughput Old Collector&#39;,  </li>
<li>// -XgcPrio:deterministic  </li>
<li>&#39;Garbage collection optimized for deterministic pausetimes Old Collector&#39;  </li>
<li>]  </li>
<li></li>
<li>R: {  </li>
<li>ManagementFactory.garbageCollectorMXBeans.each {  </li>
<li>def name  = it.name  </li>
<li>def count = it.collectionCount  </li>
<li>def gcType;  </li>
<li>switch (name) {  </li>
<li>case youngGenCollectorNames:  </li>
<li>gcType = &#39;Minor Collection&#39;  </li>
<li>break  </li>
<li>case oldGenCollectorNames:  </li>
<li>gcType = &#39;Major Collection&#39;  </li>
<li>break  </li>
<li>default:  </li>
<li>gcType = &#39;Unknown Collection Type&#39;  </li>
<li>break  </li>
<li>}  </li>
<li>println &quot;$count &lt;- $gcType: $name&quot;  </li>
<li>}  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li><p>printGCStats()<br>import java.lang.management.ManagementFactory printGCStats = { def youngGenCollectorNames = [ // Oracle (Sun) HotSpot // -XX:+UseSerialGC &#39;Copy&#39;, // -XX:+UseParNewGC &#39;ParNew&#39;, // -XX:+UseParallelGC &#39;PS Scavenge&#39;, // Oracle (BEA) JRockit // -XgcPrio:pausetime &#39;Garbage collection optimized for short pausetimes Young Collector&#39;, // -XgcPrio:throughput &#39;Garbage collection optimized for throughput Young Collector&#39;, // -XgcPrio:deterministic &#39;Garbage collection optimized for deterministic pausetimes Young Collector&#39; ] def oldGenCollectorNames = [ // Oracle (Sun) HotSpot // -XX:+UseSerialGC &#39;MarkSweepCompact&#39;, // -XX:+UseParallelGC and (-XX:+UseParallelOldGC or -XX:+UseParallelOldGCCompacting) &#39;PS MarkSweep&#39;, // -XX:+UseConcMarkSweepGC &#39;ConcurrentMarkSweep&#39;, // Oracle (BEA) JRockit // -XgcPrio:pausetime &#39;Garbage collection optimized for short pausetimes Old Collector&#39;, // -XgcPrio:throughput &#39;Garbage collection optimized for throughput Old Collector&#39;, // -XgcPrio:deterministic &#39;Garbage collection optimized for deterministic pausetimes Old Collector&#39; ] R: { ManagementFactory.garbageCollectorMXBeans.each { def name = it.name def count = it.collectionCount def gcType; switch (name) { case youngGenCollectorNames: gcType = &#39;Minor Collection&#39; break case oldGenCollectorNames: gcType = &#39;Major Collection&#39; break default: gcType = &#39;Unknown Collection Type&#39; break } println &quot;$count &lt;- $gcType: $name&quot; } } } printGCStats()
执行可以看到类似这样的输出：
Command prompt代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>5 &lt;- Minor Collection: Copy  </p>
</li>
<li><p>0 &lt;- Major Collection: MarkSweepCompact<br>5 &lt;- Minor Collection: Copy 0 &lt;- Major Collection: MarkSweepCompact
↑这是用client模式的HotSpot执行得到的；
Command prompt代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>0 &lt;- Minor Collection: Garbage collection optimized for throughput Young Collector  </p>
</li>
<li><p>0 &lt;- Major Collection: Garbage collection optimized for throughput Old Collector<br>0 &lt;- Minor Collection: Garbage collection optimized for throughput Young Collector 0 &lt;- Major Collection: Garbage collection optimized for throughput Old Collector
↑这是用JRockit R28在32位Windows上的默认模式得到的。
通过上述方法，要包装起来方便以后使用的话也很简单，例如下面Groovy程序：
Groovy代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>import java.lang.management.ManagementFactory  </p>
</li>
<li></li>
<li>class GCStats {  </li>
<li>static final List<String> YoungGenCollectorNames = [  </li>
<li>// Oracle (Sun) HotSpot  </li>
<li>// -XX:+UseSerialGC  </li>
<li>&#39;Copy&#39;,  </li>
<li>// -XX:+UseParNewGC  </li>
<li>&#39;ParNew&#39;,  </li>
<li>// -XX:+UseParallelGC  </li>
<li>&#39;PS Scavenge&#39;,  </li>
<li></li>
<li>// Oracle (BEA) JRockit  </li>
<li>// -XgcPrio:pausetime  </li>
<li>&#39;Garbage collection optimized for short pausetimes Young Collector&#39;,  </li>
<li>// -XgcPrio:throughput  </li>
<li>&#39;Garbage collection optimized for throughput Young Collector&#39;,  </li>
<li>// -XgcPrio:deterministic  </li>
<li>&#39;Garbage collection optimized for deterministic pausetimes Young Collector&#39;  </li>
<li>]  </li>
<li></li>
<li>static final List<String> OldGenCollectorNames = [  </li>
<li>// Oracle (Sun) HotSpot  </li>
<li>// -XX:+UseSerialGC  </li>
<li>&#39;MarkSweepCompact&#39;,  </li>
<li>// -XX:+UseParallelGC and (-XX:+UseParallelOldGC or -XX:+UseParallelOldGCCompacting)  </li>
<li>&#39;PS MarkSweep&#39;,  </li>
<li>// -XX:+UseConcMarkSweepGC  </li>
<li>&#39;ConcurrentMarkSweep&#39;,  </li>
<li></li>
<li>// Oracle (BEA) JRockit  </li>
<li>// -XgcPrio:pausetime  </li>
<li>&#39;Garbage collection optimized for short pausetimes Old Collector&#39;,  </li>
<li>// -XgcPrio:throughput  </li>
<li>&#39;Garbage collection optimized for throughput Old Collector&#39;,  </li>
<li>// -XgcPrio:deterministic  </li>
<li>&#39;Garbage collection optimized for deterministic pausetimes Old Collector&#39;  </li>
<li>]  </li>
<li></li>
<li>static int getYoungGCCount() {  </li>
<li>ManagementFactory.garbageCollectorMXBeans.inject(0) { youngGCCount, gc -&gt;  </li>
<li>if (YoungGenCollectorNames.contains(gc.name))  </li>
<li>youngGCCount + gc.collectionCount  </li>
<li>else  </li>
<li>youngGCCount  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>static int getFullGCCount() {  </li>
<li>ManagementFactory.garbageCollectorMXBeans.inject(0) { fullGCCount, gc -&gt;  </li>
<li>if (OldGenCollectorNames.contains(gc.name))  </li>
<li>fullGCCount + gc.collectionCount  </li>
<li>else  </li>
<li>fullGCCount  </li>
<li>}  </li>
<li>}  </li>
<li><p>}<br>import java.lang.management.ManagementFactory class GCStats { static final List<String> YoungGenCollectorNames = [ // Oracle (Sun) HotSpot // -XX:+UseSerialGC &#39;Copy&#39;, // -XX:+UseParNewGC &#39;ParNew&#39;, // -XX:+UseParallelGC &#39;PS Scavenge&#39;, // Oracle (BEA) JRockit // -XgcPrio:pausetime &#39;Garbage collection optimized for short pausetimes Young Collector&#39;, // -XgcPrio:throughput &#39;Garbage collection optimized for throughput Young Collector&#39;, // -XgcPrio:deterministic &#39;Garbage collection optimized for deterministic pausetimes Young Collector&#39; ] static final List<String> OldGenCollectorNames = [ // Oracle (Sun) HotSpot // -XX:+UseSerialGC &#39;MarkSweepCompact&#39;, // -XX:+UseParallelGC and (-XX:+UseParallelOldGC or -XX:+UseParallelOldGCCompacting) &#39;PS MarkSweep&#39;, // -XX:+UseConcMarkSweepGC &#39;ConcurrentMarkSweep&#39;, // Oracle (BEA) JRockit // -XgcPrio:pausetime &#39;Garbage collection optimized for short pausetimes Old Collector&#39;, // -XgcPrio:throughput &#39;Garbage collection optimized for throughput Old Collector&#39;, // -XgcPrio:deterministic &#39;Garbage collection optimized for deterministic pausetimes Old Collector&#39; ] static int getYoungGCCount() { ManagementFactory.garbageCollectorMXBeans.inject(0) { youngGCCount, gc -&gt; if (YoungGenCollectorNames.contains(gc.name)) youngGCCount + gc.collectionCount else youngGCCount } } static int getFullGCCount() { ManagementFactory.garbageCollectorMXBeans.inject(0) { fullGCCount, gc -&gt; if (OldGenCollectorNames.contains(gc.name)) fullGCCount + gc.collectionCount else fullGCCount } } }
用的时候：
Groovysh代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>D:>\sdk\groovy-1.7.2\bin\groovysh  </p>
</li>
<li>Groovy Shell (1.7.2, JVM: 1.6.0_20)  </li>
<li>Type &#39;help&#39; or &#39;\h&#39; for help.  </li>
<li><hr>
</li>
<li>groovy:000&gt; GCStats.fullGCCount  </li>
<li>===&gt; 0  </li>
<li>groovy:000&gt; System.gc()  </li>
<li>===&gt; null  </li>
<li>groovy:000&gt; GCStats.fullGCCount  </li>
<li>===&gt; 1  </li>
<li>groovy:000&gt; System.gc()  </li>
<li>===&gt; null  </li>
<li>groovy:000&gt; System.gc()  </li>
<li>===&gt; null  </li>
<li>groovy:000&gt; GCStats.fullGCCount  </li>
<li>===&gt; 3  </li>
<li>groovy:000&gt; GCStats.youngGCCount  </li>
<li>===&gt; 9  </li>
<li>groovy:000&gt; GCStats.youngGCCount  </li>
<li>===&gt; 9  </li>
<li>groovy:000&gt; GCStats.youngGCCount  </li>
<li>===&gt; 9  </li>
<li>groovy:000&gt; System.gc()  </li>
<li>===&gt; null  </li>
<li>groovy:000&gt; GCStats.youngGCCount  </li>
<li>===&gt; 9  </li>
<li>groovy:000&gt; GCStats.fullGCCount  </li>
<li>===&gt; 4  </li>
<li>groovy:000&gt; quit<br>D:>\sdk\groovy-1.7.2\bin\groovysh Groovy Shell (1.7.2, JVM: 1.6.0_20) Type &#39;help&#39; or &#39;\h&#39; for help. -------------------------------------------------- groovy:000&gt; GCStats.fullGCCount ===&gt; 0 groovy:000&gt; System.gc() ===&gt; null groovy:000&gt; GCStats.fullGCCount ===&gt; 1 groovy:000&gt; System.gc() ===&gt; null groovy:000&gt; System.gc() ===&gt; null groovy:000&gt; GCStats.fullGCCount ===&gt; 3 groovy:000&gt; GCStats.youngGCCount ===&gt; 9 groovy:000&gt; GCStats.youngGCCount ===&gt; 9 groovy:000&gt; GCStats.youngGCCount ===&gt; 9 groovy:000&gt; System.gc() ===&gt; null groovy:000&gt; GCStats.youngGCCount ===&gt; 9 groovy:000&gt; GCStats.fullGCCount ===&gt; 4 groovy:000&gt; quit
这是在Sun JDK 6 update 20上跑的。顺带一提，如果这是跑在JRockit上的话，那full GC的次数就不会增加——因为JRockit里System.gc()默认是触发young GC的；请不要因为Sun HotSpot的默认行为而认为System.gc()总是会触发full GC的。
关于JMX的MXBean的使用，也可以参考下面两篇文档：
<a href="http://docs.codehaus.org/display/GROOVY/Groovy+and+JMX" target="_blank">Groovy and JMX</a>
<a href="http://www.engineyard.com/blog/2010/monitoring-the-jvm-heap-with-jruby/" target="_blank">Monitoring the JVM Heap with JRuby</a>
<a href="http://hllvm.group.iteye.com/group/wiki/3042-JVM-eclipse" title="如何更快的启动eclipse" target="_blank">如何更快的启动eclipse</a></li>
</ol>
<p>评论 共 1 条 请<a href="http://hllvm.group.iteye.com/login" target="_blank">登录</a>后发表评论 <a href=""></a></p>
<h3 id="1-xgj1988-http-xgj1988-iteye-com-xgj1988-2011-04-27-15-07">1 楼 <a href="http://xgj1988.iteye.com/" title="xgj1988" target="_blank">xgj1988</a> 2011-04-27 15:07</h3>
<p>SUN jdk   使用FULL GC 是如下的几种之一？
Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>static final List<String> OldGenCollectorNames = [     </li>
<li>// Oracle (Sun) HotSpot     </li>
<li>// -XX:+UseSerialGC     </li>
<li>&#39;MarkSweepCompact&#39;,     </li>
<li>// -XX:+UseParallelGC and (-XX:+UseParallelOldGC or -XX:+UseParallelOldGCCompacting)     </li>
<li>&#39;PS MarkSweep&#39;,     </li>
<li>// -XX:+UseConcMarkSweepGC     </li>
<li>&#39;ConcurrentMarkSweep&#39;,     </li>
<li></li>
<li><p>]<br>static final List<String> OldGenCollectorNames = [ // Oracle (Sun) HotSpot // -XX:+UseSerialGC &#39;MarkSweepCompact&#39;, // -XX:+UseParallelGC and (-XX:+UseParallelOldGC or -XX:+UseParallelOldGCCompacting) &#39;PS MarkSweep&#39;, // -XX:+UseConcMarkSweepGC &#39;ConcurrentMarkSweep&#39;, ]
这几个是young gc?
Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>&#39;Copy&#39;,     </p>
</li>
<li>// -XX:+UseParNewGC     </li>
<li>&#39;ParNew&#39;,     </li>
<li>// -XX:+UseParallelGC     </li>
<li>&#39;PS Scavenge&#39;,     </li>
<li>&#39;Copy&#39;, // -XX:+UseParNewGC &#39;ParNew&#39;, // -XX:+UseParallelGC &#39;PS Scavenge&#39;,
根据名字判断来获取full gc<img src="" alt=""><h3 id="-">发表评论</h3>
</li>
</ol>
<p><a href="http://hllvm.group.iteye.com/login" target="_blank"><img src="" alt=""> 您还没有登录,请您登录后再发表评论</a></p>
<p><a href="http://hllvm.group.iteye.com/group/wiki/new" target="_blank"><img src="" alt="New-page"></a></p>
<h3 id="-">文章信息</h3>
<p><a href="http://hllvm.group.iteye.com/group/wiki/" target="_blank">知识库: 高级语言虚拟机</a></p>
<ul>
<li>由<a href="http://kiral.iteye.com/" title="fantasy" target="_blank">fantasy</a>在2010-12-16创建</li>
<li><p>由<a href="http://kiral.iteye.com/" title="fantasy" target="_blank">fantasy</a>在2011-05-26更新</p>
<h3 id="-">相关新闻</h3>
</li>
<li><p><a href="http://hllvm.group.iteye.com/news/6318-java-se-6-update-14-early-access-version" target="_blank">Java SE 6 Update 14 Early Access 早期使用版本现已发布</a></p>
</li>
<li><a href="http://hllvm.group.iteye.com/news/4146-jdk-7-in-the-new-garbage-collection-mechanism" target="_blank">JDK 7 中新的垃圾收集机制</a></li>
<li><a href="http://hllvm.group.iteye.com/news/10069" target="_blank">Java 7的新功能和Java 1.5,1.6,1.7的性能测试比较</a></li>
</ul>
<h3 id="-">相关讨论</h3>
<ul>
<li><a href="http://hllvm.group.iteye.com/topic/894148" target="_blank">HotSpot VM 内存堆的两个Servivor区</a></li>
<li><a href="http://hllvm.group.iteye.com/topic/976522" target="_blank">java内存管理以及GC</a></li>
<li><a href="http://hllvm.group.iteye.com/topic/802638" target="_blank">JVM内存管理：深入垃圾收集器与内存分配策略</a></li>
<li><a href="http://hllvm.group.iteye.com/topic/212967" target="_blank">一次Java垃圾收集调优实战</a></li>
<li><p><a href="http://hllvm.group.iteye.com/topic/262541" target="_blank">JVM的GC-生命不能承受之重</a></p>
<h3 id="-">相关博客</h3>
</li>
<li><p><a href="http://rednaxelafx.iteye.com/blog/790015" target="_blank">通过Java/JMX得到full GC次数？</a></p>
</li>
<li><a href="http://millerhu.iteye.com/blog/890724" target="_blank">通过Java/JMX得到full GC次数？</a></li>
<li><a href="http://rednaxelafx.iteye.com/blog/790864" target="_blank">用Java获取full GC的次数？（2）</a></li>
<li><a href="http://tianshibaijia.iteye.com/blog/1343308" target="_blank">常用垃圾收集器在Mbean上的名称</a></li>
<li><a href="http://rednaxelafx.iteye.com/blog/1042471" target="_blank">答复: HotSpot VM 内存堆的两个Survivor区</a></li>
<li><a href="http://www.iteye.com/" target="_blank">首页</a></li>
<li><a href="http://www.iteye.com/news" target="_blank">资讯</a></li>
<li><a href="http://www.iteye.com/magazines" target="_blank">精华</a></li>
<li><a href="http://www.iteye.com/forums" target="_blank">论坛</a></li>
<li><a href="http://www.iteye.com/ask" target="_blank">问答</a></li>
<li><a href="http://www.iteye.com/blogs" target="_blank">博客</a></li>
<li><a href="http://www.iteye.com/blogs/subjects" target="_blank">专栏</a></li>
<li><a href="http://www.iteye.com/groups" target="_blank">群组</a></li>
<li><a href="http://job.iteye.com/iteye" target="_blank">招聘</a></li>
<li><a href="http://www.iteye.com/search" target="_blank">搜索</a></li>
<li><a href="http://hllvm.group.iteye.com/index/service" target="_blank">广告服务</a></li>
<li><a href="http://webmaster.iteye.com/" target="_blank">ITeye黑板报</a></li>
<li><a href="http://hllvm.group.iteye.com/index/contactus" target="_blank">联系我们</a></li>
<li><a href="http://hllvm.group.iteye.com/index/friend_links" target="_blank">友情链接</a></li>
</ul>
<p>© 2003-2012 ITeye.com. [ <a href="http://www.miibeian.gov.cn/" target="_blank">京ICP证110151号</a> 京公网安备110105010620 ]
百联优力(北京)投资有限公司 版权所有 <img src="http://stat.iteye.com/?url=http%3A%2F%2Fhllvm.group.iteye.com%2Fgroup%2Fwiki%2F2950-gc&amp;referrer=&amp;user_id=" alt=""></p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/JVM/">JVM</a></li></span></span> | <span class="tags">Tagged <a href="/tags/JVM/" class="label label-primary">JVM</a><a href="/tags/Java&J2EE/" class="label label-success">Java&J2EE</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:42"datetime="2014-03-07 09:54:42"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-JVM--通过Java-JMX得到fullGC次数？-高级语言虚拟机/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-JVM--通过Java-JMX得到fullGC次数？-高级语言虚拟机" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--豆列：从表到里学习JVM实现/">豆列：从表到里学习JVM实现</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:42.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--豆列：从表到里学习JVM实现/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-jvm-">豆列：从表到里学习JVM实现</h1>
<p>刚写了个学习JVM用的豆列跟大家分享。
豆列地址：<a href="http://book.douban.com/doulist/2545443/" target="_blank"><a href="http://book.douban.com/doulist/2545443/">http://book.douban.com/doulist/2545443/</a></a>
下面把豆列的介绍贴过来。具体书单请到上面的豆列地址那边去看。
在社会化分工、软件行业细分专业化的趋势下，会真的参与到底层系统实现的人肯定是越来越少（比例上说）。真的会参与到JVM实现的人肯定是少数。
但如果您对JVM是如何实现的有兴趣、充满好奇，却苦于没有足够系统的知识去深入，那么这个豆列就是为您打好基础而准备的。
如果只想用用Java用用JVM，对深入到实现细节无甚兴趣的话，这个豆列就请不必参考了，免得浪费钱浪费时间精力，呵呵 :-)
本豆列的脉络是：</p>
<ol>
<li>JVM与Java语言规范
要了解JVM是如何实现的，首先必须要知道JVM到底是什么、不是什么，表面上应该提供怎样的功能。为此，JVM规范必读，而且应该时常放在手边参考。
而JVM的主要服务对象是Java编程语言。虽然JVM也可以支持众多其它语言，但JVM里的“J”仍然最重要，Java的语言特性影响了JVM的原始设计，所以Java语言规范也应该阅读。特别是，JVM关于线程和同步相关的规定都是交由Java语言规范的相关章节定义的。</li>
<li>虚拟机概论
这里选取《Virtual Machines: Versatile Platforms for Systems and Processes》，帮助您了解“虚拟机”一词到底指代什么，有什么不同类型，大概有哪些实现方法，等等。读完这本书有助获得一个清晰的大局观。</li>
<li>为Java程序员从用户的角度介绍JVM的使用经验的几本书
虽然这几本并没有深入到JVM实现的非常细节的角落，但对已经习惯用Java语言编程的程序员来说，有这么几本书带领自己从熟悉的领域进入不熟悉的领域总是件好事。
这几本书中，最深入JVM内部的是《Oracle JRockit: The Definitive Guide》；有丰富调优建议的是《Java Performance》；结合实现大概介绍JVM的抽象概念的是周志明的《深入理解Java虚拟机》。</li>
<li>虚拟机的入门级实现
先通过《Language Implementation Patterns》了解编程语言的一些入门级实现方式，把高级语言编译器与虚拟机两个概念联系起来。
然后通过《プログラミング言語を作る》了解非常简易的、用树遍历式以及字节码式解释器实现虚拟机大概是个怎么回事。虽然这本书没有实现JVM，但它介绍的Diksam与早期JVM的实现颇有相似之处，可参考。
接下来《深入嵌入式Java虚拟机》介绍了一种实际的JVM——KVM的实现细节。KVM是CLDC的参考实现（RI）里的JVM，结构简单，资源消耗小，适合入门阅读。
这部分最后是《The School of Niklaus Wirth》，里面有一章介绍了HotSpot Client Compiler (C1)的原始设计思路。这是个非常简单、但相对来说性能还不错的JIT编译器，可用于对JIT编译器的基本了解。这本书本身就很赞，不为学习虚拟机也可以一读。
需要注意的是从“简易的JVM实现”到“高性能、复杂的JVM实现”跨度非常大；前者的许多部分的实现方式与后者相当不同。先从简易的实现开始入手主要是为了对JVM里大概都有些什么组件有所了解。但如果目标是了解高性能JVM的实现，那就必须在GC、编译原理方面打下更好的基础，重新洗一次脑。</li>
<li>C++基础书
下面要开始逐渐深入JVM的内部实现，如果没有良好的C或（与？）C++基础会比较吃力。虽然也有几乎完全用Java语言实现的高性能JVM，例如Maxine VM与Jikes RVM，但它们都是研究性质的；商用JVM实现仍然是C与C++的天下。
这里我先推荐C++之父自己写的那本书来入门。虽然BS巨巨后来还出过本新书，而近来也渐渐开始有介绍C++11的入门书，但实际上现在多数JVM实现用的还是C99或非常古老的C++（连C++03都不一定用到了），所以用这本老书应该就够了。
然后通过《深度探索C++对象模型》来学习C++对象模型的常见实现方式。这对后面理解Java对象模型的实现很有帮助。</li>
<li>GC与编译原理的入门书
GC书总共就那么几本，倒也没啥可挑的。《The Garbage Collection Handbook》是绝对必读。
编译原理的书就稍微尴尬些。现有的编译原理书大都针对静态编译器、针对像C或C++那样的偏静态、偏native的语言。我还没读到过什么编译原理书是专门介绍JIT编译器或者说动态编译器的。静态与动态编译器会有些取舍上、实现策略上的差异，不过还好其核心的原理都是一样的，所以还是可以推荐几本书。龙书用来最初入门，鲸书用来补充一些优化相关的知识，EAC第二版用来学习编译器一种比较良好的逻辑组织方式，最后学一下针对现代机器的优化。</li>
<li>介绍计算机体系结构的书
实际JVM实现里，如果有JIT编译器或者动态编译器那它们的编译目标多半是底层机器的机器码。这就涉及到计算机体系结构了。
如果您只对Java语言和抽象的JVM有一定了解，那可以用《计算机组成及汇编语言原理》来入门。这本书比较奇葩，用JVM的字节码指令集来当作真实机器介绍体系结构的概念。我并不太喜欢这本书，但感觉它对有Java背景的初学者来说应该有点用。要注意的是千万别只读这本书来入门，请结合下面要介绍的一本书来重新洗一次脑。
如果对C或C++已经有所了解，那《深入理解计算机系统》（CSAPP）是计算机体系结构入门的最适合的书了。</li>
<li>进一步阅读
到此为止各种抽象概念应该都了解得差不多了。那么要在真实的机器上实现高性能JVM，就必须要对真实机器的指令集细节有所了解。x86/x86-64、SPARC、ARM、MIPS，要在哪个平台上做高性能实现就要学习哪个平台的指令集及指令级别优化技巧。这里就不具体推荐书了。
操作系统层面的知识同样重要。像是说JVM要实现线程、内存分配啥的，都可能要跟系统调用或CRT对系统调用的包装打交道。这部分也需要另外找书来读。我回头再考虑下要不要加几本道这个豆列里来。
另外，从80年代开始高级语言虚拟机的实现技术有了突飞猛进的发展，但却没有专门的书对这个领域做综述和导读。多数有用的资料其实还是在论文里。光靠读书是远远不够用的，论文这块也请关注。<h1 id="-http-rednaxelafx-iteye-com-blog-362738-http-rednaxelafx-iteye-com-blog-362738-">顺便广告一下：我的博客里关于虚拟机的文章也推荐给大家参考：<a href="http://rednaxelafx.iteye.com/blog/362738" target="_blank"><a href="http://rednaxelafx.iteye.com/blog/362738">http://rednaxelafx.iteye.com/blog/362738</a></a></h1>
这个豆列没有漏掉 <a href="http://book.douban.com/subject/1788390/" target="_blank">《Inside the Java Virtual Machine, Second Edition》</a> ，中文版<a href="http://book.douban.com/subject/1138768/" target="_blank">《深入Java虚拟机(原书第2版)》</a>，只是我现在已经不再推荐它。这本书刚出版的时候确实引起了一番学习Java虚拟机的热潮，但其部分内容从现在的角度看已经过时，特别是涉及JVM实现的部分。像火车算法什么的现在已经没有JVM实现使用。不过话说回来，了解了解这些过时的信息也没什么不好，前提是能自己分辨清楚哪些信息是适用于现在的JVM的，而哪些已经成为了历史。</li>
</ol>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/JVM/">JVM</a></li></span></span> | <span class="tags">Tagged <a href="/tags/JVM/" class="label label-primary">JVM</a><a href="/tags/Java&J2EE/" class="label label-success">Java&J2EE</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:42"datetime="2014-03-07 09:54:42"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-JVM--豆列：从表到里学习JVM实现/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-JVM--豆列：从表到里学习JVM实现" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--虚拟机随谈（一）：解释器，树遍历解释器，基于栈与基于寄存器，大杂烩/">虚拟机随谈（一）：解释器，树遍历解释器，基于栈与基于寄存器，大杂烩</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:42.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--虚拟机随谈（一）：解释器，树遍历解释器，基于栈与基于寄存器，大杂烩/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-">虚拟机随谈（一）：解释器，树遍历解释器，基于栈与基于寄存器，大杂烩</h1>
<p>（Disclaimer：如果需要转载请先与我联系；文中图片请不要直接链接
作者：<a href="http://weibo.com/rednaxelafx" target="_blank">@RednaxelaFX</a> -&gt; <a href="http://rednaxelafx.iteye.com/" target="_blank"><a href="http://rednaxelafx.iteye.com">http://rednaxelafx.iteye.com</a></a>）
大前天收到一条PM：
引用</p>
<p>你好，很冒昧的向你发短消息，我现在在看JS引擎，能过看博客发现你对js engine很了解，我想请教一下你 基于栈的解析器与基于寄存器的解析器有什么同，javascriptcore是基于寄存器的，V8是基于栈的，能不能说一下这两者有什么一样吗？能推荐一点资料吗？谢谢。
我刚收到的时候很兴奋，就开始写回复。写啊写发觉已经比我平时发的帖还要长了，想着干脆把回复直接发出来好了。于是下面就是回复：
你好 ^ ^ 很抱歉拖了这么久才回复。码字和画图太耗时间了。
别说冒昧了，我只是个普通的刚毕业的学生而已，担当不起啊 =<em>=||||
而且我也不敢说“很”了解，只是有所接触而已。很高兴有人来一起讨论JavaScript引擎的设计与实现，总觉得身边对这个有兴趣的人不多，或者是很少冒出来讨论。如果你发个帖或者blog来讨论这方面的内容我也会很感兴趣的～
想拿出几点来讨论一下。上面提出的问题我希望能够一一给予回答，不过首先得做些铺垫。
另外先提一点：JavaScriptCore从SquirrelFish版开始是“基于寄存器”的，V8则不适合用“基于栈”或者“基于寄存器”的说法来描述。
<strong>1、解析器与解释器</strong>
解析器是parser，而解释器是interpreter。两者不是同一样东西，不应该混用。
前者是编译器/解释器的重要组成部分，也可以用在IDE之类的地方；其主要作用是进行语法分析，提取出句子的结构。广义来说输入一般是程序的源码，输出一般是语法树（syntax tree，也叫parse tree等）或抽象语法树（abstract syntax tree，AST）。进一步剥开来，广义的解析器里一般会有扫描器（scanner，也叫tokenizer或者lexical analyzer，词法分析器），以及狭义的解析器（parser，也叫syntax analyzer，语法分析器）。扫描器的输入一般是文本，经过词法分析，输出是将文本切割为单词的流。狭义的解析器输入是单词的流，经过语法分析，输出是语法树或者精简过的AST。
（在一些编译器/解释器中，解析也可能与后续的语义分析、代码生成或解释执行等步骤融合在一起，不一定真的会构造出完整的语法树。但概念上说解析器就是用来抽取句子结构用的，而语法树就是表示句子结构的方式。关于边解析边解释执行的例子，可以看看<a href="http://rednaxelafx.iteye.com/blog/472113" target="_blank">这帖</a>的计算器。）
举例：将i = a + b /* c作为源代码输入到解析器里，则广义上的解析器的工作流程如下图：
<img src="" alt="">
其中词法分析由扫描器完成，语法分析由狭义的解析器完成。
（嗯，说来其实“解析器”这词还是按狭义用法比较准确。把扫描器和解析器合起来叫解析器总觉得怪怪的，但不少人这么用，这里就将就下吧 =</em>=
不过近来“<a href="http://en.wikipedia.org/wiki/Scannerless_parsing" target="_blank">scannerless parsing</a>”也挺流行的：不区分词法分析与语法分析，没有单独的扫描器，直接用解析器从源码生成语法树。这倒整个就是解析器了，没狭不狭义的问题）
后者则是实现程序执行的一种实现方式，与编译器相对。它直接实现程序源码的语义，输入是程序源码，输出则是执行源码得到的计算结果；编译器的输入与解释器相同，而输出是用别的语言实现了输入源码的语义的程序。通常编译器的输入语言比输出语言高级，但不一定；也有输入输出是同种语言的情况，此时编译器很可能主要用于优化代码。
举例：把同样的源码分别输入到编译器与解释器中，得到的输出不同：
<img src="" alt="">
值得留意的是，编译器生成出来的代码执行后的结果应该跟解释器输出的结果一样——它们都应该实现源码所指定的语义。
在很多地方都看到解析器与解释器两个不同的东西被混为一谈，感到十分无奈。
最近某本引起很多关注的书便在开篇给读者们当头一棒，介绍了“<a href="http://www.fecit.com.cn/%E7%AC%AC1%E7%AB%A0_%E4%B8%8E%E5%88%9D%E5%AD%A6%E8%80%85%E8%B0%88%E8%B0%88JavaScript%E5%AD%A6%E4%B9%A0.pdf" target="_blank">JavaScript解析机制</a>”。“编译”和“预处理”也顺带混为一谈了，还有“预编译” 0_0
我一直以为“预编译”应该是<a href="http://en.wikipedia.org/wiki/AOT_compiler" target="_blank">ahead-of-time compilation</a>的翻译，是与“即时编译”（just-in-time compilation，JIT）相对的概念。另外就是PCH（precompile header）这种用法，把以前的编译结果缓存下来称为“预编译”。把AOT、PCH跟“预处理”（<a href="http://en.wikipedia.org/wiki/Preprocessor" target="_blank">preprocess</a>）混为一谈真是诡异。算了，我还是不要淌这浑水的好……打住。
<strong>2、“解释器”到底是什么？“解释型语言”呢？</strong>
很多资料会说，Python、Ruby、JavaScript都是“解释型语言”，是通过解释器来实现的。这么说其实很容易引起误解：语言一般只会定义其抽象语义，而不会强制性要求采用某种实现方式。
例如说C一般被认为是“编译型语言”，但C的解释器也是存在的，例如<a href="http://www.softintegration.com/" target="_blank">Ch</a>。同样，C++也有解释器版本的实现，例如<a href="http://root.cern.ch/drupal/content/cint" target="_blank">Cint</a>。
一般被称为“解释型语言”的是主流实现为解释器的语言，但并不是说它就无法编译。例如说经常被认为是“解释型语言”的<a href="http://schemers.org/" target="_blank">Scheme</a>就有好几种编译器实现，其中率先支持<a href="http://www.r6rs.org/" target="_blank">R6RS</a>规范的大部分内容的是<a href="http://ikarus-scheme.org/" target="_blank">Ikarus</a>，支持在x86上编译Scheme；它最终不是生成某种虚拟机的字节码，而是直接生成x86机器码。
解释器就是个黑箱，输入是源码，输出就是输入程序的执行结果，对用户来说中间没有独立的“编译”步骤。这非常抽象，内部是怎么实现的都没关系，只要能实现语义就行。你可以写一个C语言的解释器，里面只是先用普通的C编译器把源码编译为in-memory image，然后直接调用那个image去得到运行结果；用户拿过去，发现直接输入源码可以得到源程序对应的运行结果就满足需求了，无需在意解释器这个“黑箱子”里到底是什么。
实际上很多解释器内部是以“编译器+虚拟机”的方式来实现的，先通过编译器将源码转换为AST或者字节码，然后由虚拟机去完成实际的执行。所谓“解释型语言”并不是不用编译，而只是不需要用户显式去使用编译器得到可执行代码而已。
那么虚拟机（<a href="http://en.wikipedia.org/wiki/Virtual_machine" target="_blank">virtual machine</a>，VM）又是什么？在许多不同的场合，VM有着不同的意义。如果上下文是Java、Python这类语言，那么一般指的是高级语言虚拟机（high-level language virtual machine，HLL VM），其意义是实现高级语言的语义。VM既然被称为“机器”，一般认为输入是满足某种指令集架构（<a href="http://en.wikipedia.org/wiki/Instruction_set" target="_blank">instruction set architecture</a>，ISA）的指令序列，中间转换为目标ISA的指令序列并加以执行，输出为程序的执行结果的，就是VM。源与目标ISA可以是同一种，这是所谓same-ISA VM。
前面提到解释器中的编译器的输出可能是AST，也可能是字节码之类的指令序列；一般会把执行后者的程序称为VM，而执行前者的还是笼统称为解释器或者树遍历式解释器（tree-walking interpreter）。这只是种习惯而已，并没有多少确凿的依据。只不过线性（相对于树形）的指令序列看起来更像一般真正机器会执行的指令序列而已。
其实我觉得把执行AST的也叫VM也没啥大问题。如果认同这个观点，那么把<a href="http://rednaxelafx.iteye.com/blog/241430" target="_blank">DLR</a>看作一种VM也就可以接受了——它的“指令集”就是树形的Expression Tree。
VM并不是神奇的就能执行代码了，它也得采用某种方式去实现输入程序的语义，并且同样有几种选择：“编译”，例如微软的.NET中的CLR；“解释”，例如CPython、CRuby 1.9，许多老的JavaScript引擎等；也有介于两者之间的混合式，例如Sun的JVM，<a href="http://en.wikipedia.org/wiki/HotSpot" target="_blank">HotSpot</a>。如果采用编译方式，VM会把输入的指令先转换为某种能被底下的系统直接执行的形式（一般就是native code），然后再执行之；如果采用解释方式，则VM会把输入的指令逐条直接执行。
换个角度说，我觉得采用编译和解释方式实现虚拟机最大的区别就在于是否存下目标代码：编译的话会把输入的源程序以某种单位（例如<a href="http://en.wikipedia.org/wiki/Basic_block" target="_blank">基本块</a>/函数/方法/trace等）翻译生成为目标代码，并存下来（无论是存在内存中还是磁盘上，无所谓），后续执行可以复用之；解释的话则是把源程序中的指令逐条解释，不生成也不存下目标代码，后续执行没有多少可复用的信息。有些稍微先进一点的解释器可能会优化输入的源程序，把满足某些模式的指令序列合并为“超级指令”；这么做就是朝着编译的方向推进。后面讲到解释器的演化时再讨论超级指令吧。
如果一种语言的主流实现是解释器，其内部是编译器+虚拟机，而虚拟机又是采用解释方式实现的，或者内部实现是编译器+树遍历解释器，那它就是名副其实的“解释型语言”。如果内部用的虚拟机是用编译方式实现的，其实跟普遍印象中的“解释器”还是挺不同的……
可以举这样一个例子：ActionScript 3，一般都被认为是“解释型语言”对吧？但这种观点到底是把FlashPlayer整体看成一个解释器，因而AS3是“解释型语言”呢？还是认为FlashPlayer中的虚拟机采用解释执行方案，因而AS3是“解释型语言”呢？
其实Flash或Flex等从AS3生成出来的SWF文件里就包含有AS字节码（ActionScript Byte Code，ABC）。等到FlashPlayer去执行SWF文件，或者说等到AVM2（ActionScript Virtual Machine 2）去执行ABC时，又有解释器和JIT编译器两种实现。这种需要让用户显式进行编译步骤的语言，到底是不是“解释型语言”呢？呵呵。所以我一直觉得“编译型语言”跟“解释型语言”的说法太模糊，不太好。
有兴趣想体验一下从命令行编译“裸”的AS3文件得到ABC文件，再从命令行调用AVM2去执行ABC文件的同学，可以从<a href="http://rednaxelafx.iteye.com/blog/196278" target="_blank">这帖</a>下载我之前从源码编译出来的AVM2，自己玩玩看。例如说要编译一个名为test.as的文件，用下列命令：
Command prompt代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>java -jar asc.jar -import builtin.abc -import toplevel.abc test.as  </li>
</ol>
<p>java -jar asc.jar -import builtin.abc -import toplevel.abc test.as
就是用ASC将test.as编译，得到test.abc。接着用：
Command prompt代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>avmplus test.abc  </li>
</ol>
<p>avmplus test.abc
就是用AVM2去执行程序了。很生动的体现出“编译器+虚拟机”的实现方式。
这个“裸”的AVM2没有带Flash或Flex的类库，能用的函数和类都有限。不过AS3语言实现是完整的。可以用print()函数来向标准输出流写东西。
Well……其实写Java程序不也是这样么？现在也确实还有很多人把Java称为“解释型语言”，完全无视Java代码通常是经过显式编译步骤才得到.class文件，而有些JVM是采用纯JIT编译方式实现的，内部没解释器，例如JRockit、<a href="https://wikis.oracle.com/display/MaxineVM/Home" target="_blank">Maxine VM</a>和<a href="http://jikesrvm.org/" target="_blank">Jikes RVM</a>。我愈发感到“解释型语言”是个应该避开的用语 =_=
关于虚拟机，有本很好的书绝对值得一读，《虚拟机——系统与进程的通用平台》（Virtual Machines: Versatile Platforms for Systems and Processes）。国内有影印版也有中文版，我是读了影印版，不太清楚中文版的翻译质量如何。据说翻译得还行，我无法印证。
<strong>3、基于栈与基于寄存器的指令集架构</strong>
用C的语法来写这么一个语句：
C代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>a = b + c;  </li>
</ol>
<p>a = b + c;
如果把它变成这种形式：
add a, b, c
那看起来就更像机器指令了，对吧？这种就是所谓“三地址指令”（3-address instruction），一般形式为：
op dest, src1, src2
许多操作都是二元运算+赋值。三地址指令正好可以指定两个源和一个目标，能非常灵活的支持二元操作与赋值的组合。ARM处理器的主要指令集就是三地址形式的。
C里要是这样写的话：
C代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>a += b;  </li>
</ol>
<p>a += b;
变成:
add a, b
这就是所谓“二地址指令”，一般形式为：
op dest, src
它要支持二元操作，就只能把其中一个源同时也作为目标。上面的add a, b在执行过后，就会破坏a原有的值，而b的值保持不变。x86系列的处理器就是二地址形式的。
上面提到的三地址与二地址形式的指令集，一般就是通过“基于寄存器的架构”来实现的。例如典型的RISC架构会要求除load和store以外，其它用于运算的指令的源与目标都要是寄存器。
显然，指令集可以是任意“n地址”的，n属于自然数。那么一地址形式的指令集是怎样的呢？
想像一下这样一组指令序列：
add 5
sub 3
这只指定了操作的源，那目标是什么？一般来说，这种运算的目标是被称为“累加器”（accumulator）的专用寄存器，所有运算都靠更新累加器的状态来完成。那么上面两条指令用C来写就类似：
C代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>acc += 5;  </li>
<li>acc -= 3;  </li>
</ol>
<p>acc += 5;</p>
<p>acc -= 3;
只不过acc是“隐藏”的目标。基于累加器的架构近来比较少见了，在很老的机器上繁荣过一段时间。
那“n地址”的n如果是0的话呢？
看这样一段Java字节码：
Java bytecode代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>iconst_1  </li>
<li>iconst_2  </li>
<li>iadd  </li>
<li>istore_0  </li>
</ol>
<p>iconst_1</p>
<p>iconst_2
iadd</p>
<p>istore_0
注意那个iadd（表示整型加法）指令并没有任何参数。连源都无法指定了，零地址指令有什么用？？
零地址意味着源与目标都是隐含参数，其实现依赖于一种常见的数据结构——没错，就是栈。上面的iconst_1、iconst_2两条指令，分别向一个叫做“求值栈”（evaluation stack，也叫做operand stack“操作数栈”或者expression stack“表达式栈”）的地方压入整型常量1、2。iadd指令则从求值栈顶弹出2个值，将值相加，然后把结果压回到栈顶。istore_0指令从求值栈顶弹出一个值，并将值保存到局部变量区的第一个位置（slot 0）。
零地址形式的指令集一般就是通过“基于栈的架构”来实现的。请一定要注意，这个栈是指“求值栈”，而不是与系统调用栈（system call stack，或者就叫system stack）。千万别弄混了。有些虚拟机把求值栈实现在系统调用栈上，但两者概念上不是一个东西。
由于指令的源与目标都是隐含的，零地址指令的“密度”可以非常高——可以用更少空间放下更多条指令。因此在空间紧缺的环境中，零地址指令是种可取的设计。但零地址指令要完成一件事情，一般会比二地址或者三地址指令许多更多条指令。上面Java字节码做的加法，如果用x86指令两条就能完成了：
X86 asm代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>mov  eax, 1  </li>
<li>add  eax, 2  </li>
</ol>
<p>mov  eax, 1</p>
<p>add  eax, 2
（好吧我犯规了，istore<em>0对应的保存我没写。但假如局部变量比较少的话也不必把EAX的值保存（“溢出”，register spilling）到调用栈上，就这样吧 =</em>=
其实就算把结果保存到栈上也就是多一条指令而已……）
一些比较老的解释器，例如<a href="http://www.ruby-lang.org/" target="_blank">CRuby</a>在1.9引入<a href="http://www.atdot.net/yarv/" target="_blank">YARV</a>作为新的VM之前的解释器，还有SquirrleFish之前的老JavaScriptCore以及它的前身KJS，它们内部是树遍历式解释器；解释器递归遍历树，树的每个节点的操作依赖于解释其各个子节点返回的值。这种解释器里没有所谓的求值栈，也没有所谓的虚拟寄存器，所以不适合以“基于栈”或“基于寄存器”去描述。
而像V8那样直接编译JavaScript生成机器码，而不通过中间的字节码的中间表示的JavaScript引擎，它内部有虚拟寄存器的概念，但那只是普通native编译器的正常组成部分。我觉得也不应该用“基于栈”或“基于寄存器”去描述它。
V8在内部也用了“求值栈”（在V8里具体叫“表达式栈”）的概念来简化生成代码的过程，在编译过程中进行“抽象解释”，使用所谓“虚拟栈帧”来记录局部变量与求值栈的状态；但在真正生成代码的时候会做窥孔优化，消除冗余的push/pop，将许多对求值栈的操作转变为对寄存器的操作，以此提高代码质量。于是最终生成出来的代码看起来就不像是基于栈的代码了。
关于JavaScript引擎的实现方式，下文会再提到。
<strong>4、基于栈与基于寄存器架构的VM，用哪个好？</strong>
如果是要模拟现有的处理器，那没什么可选的，原本处理器采用了什么架构就只能以它为源。但HLL VM的架构通常可以自由构造，有很大的选择余地。为什么许多主流HLL VM，诸如JVM、CLI、CPython、CRuby 1.9等，都采用了基于栈的架构呢？我觉得这有三个主要原因：
·实现简单
由于指令中不必显式指定源与目标，VM可以设计得很简单，不必考虑为临时变量分配空间的问题，求值过程中的临时数据存储都让求值栈包办就行。
更新：回帖中cscript指出了这句不太准确，应该是针对基于栈架构的指令集生成代码的编译器更容易实现，而不是VM更容易实现。
·该VM是为某类资源非常匮乏的硬件而设计的
这类硬件的存储器可能很小，每一字节的资源都要节省。零地址指令比其它形式的指令更紧凑，所以是个自然的选择。
·考虑到可移植性
处理器的特性各个不同：典型的CISC处理器的通用寄存器数量很少，例如32位的<a href="http://en.wikipedia.org/wiki/X86" target="_blank">x86</a>就只有8个32位通用寄存器（如果不算EBP和ESP那就是6个，现在一般都算上）；典型的RISC处理器的各种寄存器数量多一些，例如<a href="http://en.wikipedia.org/wiki/ARM_architecture" target="_blank">ARM</a>有16个32位通用寄存器，Sun的<a href="http://en.wikipedia.org/wiki/SPARC" target="_blank">SPARC</a>在一个寄存器窗口里则有24个通用寄存器（8 in，8 local，8 out）。
假如一个VM采用基于寄存器的架构（它接受的指令集大概就是二地址或者三地址形式的），为了高效执行，一般会希望能把源架构中的寄存器映射到实际机器上寄存器上。但是VM里有些很重要的辅助数据会经常被访问，例如一些VM会保存源指令序列的程序计数器（program counter，PC），为了效率，这些数据也得放在实际机器的寄存器里。如果源架构中寄存器的数量跟实际机器的一样，或者前者比后者更多，那源架构的寄存器就没办法都映射到实际机器的寄存器上；这样VM实现起来比较麻烦，与能够全部映射相比效率也会大打折扣。像Dalvik VM的解释器实现，就是把虚拟寄存器全部映射到栈帧（内存）里的，这跟把局部变量区与操作数栈都映射到内存里的JVM解释器实现相比实际区别不太大。
如果一个VM采用基于栈的架构，则无论在怎样的实际机器上，都很好实现——它的源架构里没有任何通用寄存器，所以实现VM时可以比较自由的分配实际机器的寄存器。于是这样的VM可移植性就比较高。作为优化，基于栈的VM可以用编译方式实现，“求值栈”实际上也可以由编译器映射到寄存器上，减轻数据移动的开销。
回到主题，基于栈与基于寄存器的架构，谁更快？看看现在的实际处理器，大多都是基于寄存器的架构，从侧面反映出它比基于栈的架构更优秀。
而对于VM来说，源架构的求值栈或者寄存器都可能是用实际机器的内存来模拟的，所以性能特性与实际硬件又有点不同。一般认为基于寄存器的架构对VM来说也是更快的，原因是：虽然零地址指令更紧凑，但完成操作需要更多的load/store指令，也意味着更多的指令分派（instruction dispatch）次数与内存访问次数；访问内存是执行速度的一个重要瓶颈，二地址或三地址指令虽然每条指令占的空间较多，但总体来说可以用更少的指令完成操作，指令分派与内存访问次数都较少。
这方面有篇被引用得很多的论文讲得比较清楚，<a href="http://www.usenix.org/events/vee05/full_papers/p153-yunhe.pdf" target="_blank">Virtual Machine Showdown: Stack Versus Registers</a>，是在VEE 2005发表的。VEE是Virtual Execution Environment的缩写，是ACM下SIGPLAN组织的一个会议，专门研讨虚拟机的设计与实现的。可以去找找这个会议往年的论文，很多都值得读。
<strong>5、树遍历解释器图解</strong>
在演示基于栈与基于寄存器的VM的例子前，先回头看看更原始的解释器形式。
前面提到解析器的时候用了i = a + b /<em> c的例子，现在让我们来看看由解析器生成的AST要是交给一个树遍历解释器，会如何被解释执行呢？
用文字说不够形象，还是看图吧：
<img src="" alt="">
这是对AST的后序遍历：假设有一个eval(Node n)函数，用于解释AST上的每个节点；在解释一个节点时如果依赖于子树的操作，则对子节点递归调用eval(Node n)，从这些递归调用的返回值获取需要的值（或副作用）——也就是说子节点都eval好了之后，父节点才能进行自己的eval——典型的后序遍历。
（话说，上图中节点左下角有蓝色标记的说明那是节点的“内在属性”。从<a href="http://en.wikipedia.org/wiki/Attribute_grammar" target="_blank">属性语法</a>的角度看，如果一个节点的某个属性的值只依赖于自身或子节点，则该属性被称为“综合属性”（synthesized attribute）；如果一个节点的某个属性只依赖于自身、父节点和兄弟节点，则该属性被称为“继承属性”（inherited attribute）。上图中节点右下角的红色标记都只依赖子节点来计算，显然是综合属性。）
SquirrelFish之前的JavaScriptCore、CRuby 1.9之前的CRuby就都是采用这种方式来解释执行的。
可能需要说明的：
·左值与右值
在源代码i = a + b /</em> c中，赋值符号左侧的i是一个标识符，表示一个变量，取的是变量的“左值”（也就是与变量i绑定的存储单元）；右侧的a、b、c虽然也是变量，但取的是它们的右值（也就是与变量绑定的存储单元内的值）。在许多编程语言中，左值与右值在语法上没有区别，它们实质的差异容易被忽视。一般来说左值可以作为右值使用，反之则不一定。例如数字1，它自身有值就是1，可以作为右值使用；但它没有与可赋值的存储单元相绑定，所以无法作为左值使用。
左值不一定只是简单的变量，还可以是数组元素或者结构体的域之类，可能由复杂的表达式所描述。因此左值也是需要计算的。
·优先级、结合性与求值顺序
这三个是不同的概念，却经常被混淆。通过AST来看就很容易理解：（假设源码是从左到右输入的）
所谓<strong>优先级</strong>，就是不同操作相邻出现时，AST节点与根的距离的关系。优先级高的操作会更远离根，优先级低的操作会更接近根。为什么？因为整棵AST是以后序遍历求值的，显然节点离根越远就越早被求值。
所谓<strong>结合性</strong>，就是当同类操作相邻出现时，操作的先后顺序同AST节点与根的距离的关系。如果是左结合，则先出现的操作对应的AST节点比后出现的操作的节点离根更远；换句话说，先出现的节点会是后出现节点的子节点。
所谓<strong>求值顺序</strong>，就是在遍历子节点时的顺序。对二元运算对应的节点来说，先遍历左子节点再遍历右子节点就是左结合，反之则是右结合。
这三个概念与运算的联系都很紧密，但实际描述的是不同的关系。前两者是解析器根据语法生成AST时就已经决定好的，后者则是解释执行或者生成代码而去遍历AST时决定的。
在没有副作用的环境中，给定优先级与结合性，则无论求值顺序是怎样的都能得到同样的结果；而在有副作用的环境中，求值顺序会影响结果。
赋值运算虽然是右结合的，但仍然可以用从左到右的求值顺序；事实上Java、C/#等许多语言都在规范里写明表达式的求值顺序是从左到右的。上面的例子中就先遍历的=的左侧，求得i的左值；再遍历=的右侧，得到表达式的值23；最后执行=自身，完成对i的赋值。
所以如果你要问：赋值在类似C的语言里明明是右结合的运算，为什么你先遍历左子树再遍历右子树？上面的说明应该能让你发现你把结合性与求值顺序混为一谈了。
看看Java从左到右求值顺序的例子：
Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>public class EvalOrderDemo {  </li>
<li>public static void main(String[] args) {  </li>
<li>int[] arr = new int[1];  </li>
<li>int a = 1;  </li>
<li>int b = 2;  </li>
<li>arr[0] = a + b;  </li>
<li>}  </li>
<li>}  </li>
</ol>
<p>public class EvalOrderDemo {</p>
<pre><code>public static void main(String[] args) {
    int[] arr = new int[1];

    int a = 1;
    int b = 2;

    arr[0] = a + b;
}
</code></pre><p>}
由javac编译，得到arr[0] = a + b对应的字节码是：
Java bytecode代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>// 左子树：数组下标  </li>
<li>// a[0]  </li>
<li>aload_1  </li>
<li>iconst_0  </li>
<li></li>
<li>// 右子树：加法  </li>
<li>// a  </li>
<li>iload_2  </li>
<li>// b  </li>
<li>iload_3  </li>
<li>// +  </li>
<li>iadd  </li>
<li></li>
<li>// 根节点：赋值  </li>
<li>iastore  </li>
</ol>
<p>// 左子树：数组下标</p>
<p>// a[0]
aload_1</p>
<p>iconst_0</p>
<p>// 右子树：加法
// a</p>
<p>iload_2
// b</p>
<p>iload_3
// +</p>
<p>iadd</p>
<p>// 根节点：赋值
iastore
<strong>6、从树遍历解释器进化为基于栈的字节码解释器的前端</strong>
如果你看到树形结构与后序遍历，并且知道后缀记法（或者逆波兰记法，<a href="http://en.wikipedia.org/wiki/Reverse_Polish_notation" target="_blank">reverse Polish notation</a>）的话，那敏锐的你或许已经察觉了：要解释执行AST，可以先通过后序遍历AST生成对应的后缀记法的操作序列，然后再解释执行该操作序列。这样就把树形结构压扁，成为了线性结构。
树遍历解释器对AST的求值其实隐式依赖于调用栈：eval(Node n)的递归调用关系是靠调用栈来维护的。后缀表达式的求值则通常显式依赖于一个栈，在遇到操作数时将其压入栈中，遇到运算时将合适数量的值从栈顶弹出进行运算，再将结果压回到栈上。这种描述看起来眼熟么？没错，后缀记法的求值中的核心数据结构就是前文提到过的“求值栈”（或者叫操作数栈，现在应该更好理解了）。后缀记法也就与基于栈的架构联系了起来：后者可以很方便的执行前者。同理，零地址指令也与树形结构联系了起来：可以通过一个栈方便的把零地址指令序列再转换回到树的形式。
Java字节码与Java源码联系紧密，前者可以看成后者的后缀记法。如果想在JVM上开发一种语义能直接映射到Java上的语言，那么编译器很好写：秘诀就是后序遍历AST。
那么让我们再来看看，同样是i = a + b /<em> c这段源码对应的AST，生成Java字节码的例子：
<img src="" alt="">
（假设a、b、c、i分别被分配到局部变量区的slot 0到slot 3）
能看出Java字节码与源码间的对应关系了么？
一个Java编译器的输入是Java源代码，输出是含有Java字节码的.class文件。它里面主要包含扫描器与解析器，语义分析器（包括类型检查器/类型推导器等），代码生成器等几大部分。上图所展示的就是代码生成器的工作。对Java编译器来说，代码生成就到字节码的层次就结束了；而对native编译器来说，这里刚到生成中间表示的部分，接下去是优化与最终的代码生成。
如果你对<a href="http://rednaxelafx.iteye.com/blog/382412" target="_blank">Python</a>、<a href="http://lifegoo.pluskid.org/upload/doc/yarv/yarv_iset.html" target="_blank">CRuby 1.9</a>之类有所了解，会发现它们的字节码跟Java字节码在“基于栈”的这一特征上非常相似。其实它们都是由“编译器+VM”构成的，概念上就像是Java编译器与JVM融为一体一般。
从这点看，Java与Python和Ruby可以说是一条船上的。虽说内部具体实现的显著差异使得先进的JVM比简单的JVM快很多，而JVM又普遍比Python和Ruby快很多。
当解释器中用于解释执行的中间代码是树形时，其中能被称为“编译器”的部分基本上就是解析器；中间代码是线性形式（如字节码）时，其中能被称为编译器的部分就包括上述的代码生成器部分，更接近于所谓“完整的编译器”；如果虚拟机是基于寄存器架构的，那么编译器里至少还得有虚拟寄存器分配器，又更接近“完整的编译器”了。
<em>*7、基于栈与基于寄存器架构的VM的一组图解</em></em>
要是拿两个分别实现了基于栈与基于寄存器架构、但没有直接联系的VM来对比，效果或许不会太好。现在恰巧有两者有紧密联系的例子——JVM与Dalvik VM。JVM的字节码主要是零地址形式的，概念上说JVM是基于栈的架构。Google Android平台上的应用程序的主要开发语言是Java，通过其中的<a href="http://en.wikipedia.org/wiki/Dalvik_virtual_machine" target="_blank">Dalvik VM</a>来运行Java程序。为了能正确实现语义，Dalvik VM的许多设计都考虑到与JVM的兼容性；但它却采用了基于寄存器的架构，其字节码主要是二地址/三地址混合形式的，乍一看可能让人纳闷。考虑到Android有明确的目标：面向移动设备，特别是最初要对ARM提供良好的支持。ARM9有16个32位通用寄存器，Dalvik VM的架构也常用16个虚拟寄存器（一样多……没办法把虚拟寄存器全部直接映射到硬件寄存器上了）；这样Dalvik VM就不用太顾虑可移植性的问题，优先考虑在ARM9上以高效的方式实现，发挥基于寄存器架构的优势。
Dalvik VM的主要设计者<a href="http://www.milk.com/home/danfuzz/" target="_blank">Dan Bornstein</a>在Google I/O 2008上做过一个<a href="http://sites.google.com/site/io/dalvik-vm-internals" target="_blank">关于Dalvik内部实现</a>的演讲；同一演讲也在Google Developer Day 2008 China和Japan等会议上重复过。这个演讲中Dan特别提到了Dalvik VM与JVM在字节码设计上的区别，指出Dalvik VM的字节码可以用更少指令条数、更少内存访问次数来完成操作。（看不到YouTube的请自行想办法）
眼见为实。要自己动手感受一下该例子，请先确保已经正确安装JDK 6，并从<a href="http://developer.android.com/sdk/" target="_blank">官网</a>获取Android SDK 1.6R1。连不上官网的也请自己想办法。
创建Demo.java文件，内容为：
Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>public class Demo {  </li>
<li>public static void foo() {  </li>
<li>int a = 1;  </li>
<li>int b = 2;  </li>
<li>int c = (a + b) /* 5;  </li>
<li>}  </li>
<li>}  </li>
</ol>
<p>public class Demo {</p>
<pre><code>public static void foo() {
    int a = 1;

    int b = 2;
    int c = (a + b) /* 5;

}
</code></pre><p>}
通过javac编译，得到Demo.class。通过javap可以看到foo()方法的字节码是：
Java bytecode代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>0:  iconst_1  </li>
<li>1:  istore_0  </li>
<li>2:  iconst_2  </li>
<li>3:  istore_1  </li>
<li>4:  iload_0  </li>
<li>5:  iload_1  </li>
<li>6:  iadd  </li>
<li>7:  iconst_5  </li>
<li>8:  imul  </li>
<li>9:  istore_2  </li>
<li>10: return  </li>
</ol>
<p>0:  iconst_1</p>
<p>1:  istore_0
2:  iconst_2</p>
<p>3:  istore_1
4:  iload_0</p>
<p>5:  iload_1
6:  iadd</p>
<p>7:  iconst_5
8:  imul</p>
<p>9:  istore_2
10: return
接着用Android SDK里platforms\android-1.6\tools目录中的dx工具将Demo.class转换为dex格式。转换时可以直接以文本形式dump出dex文件的内容。使用下面的命令：
Command prompt代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>dx --dex --verbose --dump-to=Demo.dex.txt --dump-method=Demo.foo --verbose-dump Demo.class  </li>
</ol>
<p>dx --dex --verbose --dump-to=Demo.dex.txt --dump-method=Demo.foo --verbose-dump Demo.class
可以看到foo()方法的字节码是：
Dalvik bytecode代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>0000: const/4       v0, /#int 1 // /#1  </li>
<li>0001: const/4       v1, /#int 2 // /#2  </li>
<li>0002: add-int/2addr v0, v1  </li>
<li>0003: mul-int/lit8  v0, v0, /#int 5 // /#05  </li>
<li>0005: return-void  </li>
</ol>
<p>0000: const/4       v0, /#int 1 // /#1</p>
<p>0001: const/4       v1, /#int 2 // /#2
0002: add-int/2addr v0, v1</p>
<p>0003: mul-int/lit8  v0, v0, /#int 5 // /#05
0005: return-void
（原本的输出里还有些code-address、local-snapshot等，那些不是字节码的部分，可以忽略。）
让我们看看两个版本在概念上是如何工作的。
JVM：
<img src="" alt="">
（图中数字均以十六进制表示。其中字节码的一列表示的是字节码指令的实际数值，后面跟着的助记符则是其对应的文字形式。标记为红色的值是相对上一条指令的执行状态有所更新的值。下同）
说明：Java字节码以1字节为单元。上面代码中有11条指令，每条都只占1单元，共11单元==11字节。
程序计数器是用于记录程序当前执行的位置用的。对Java程序来说，每个线程都有自己的PC。PC以字节为单位记录当前运行位置里方法开头的偏移量。
每个线程都有一个Java栈，用于记录Java方法调用的“活动记录”（activation record）。Java栈以帧（frame）为单位线程的运行状态，每调用一个方法就会分配一个新的栈帧压入Java栈上，每从一个方法返回则弹出并撤销相应的栈帧。
每个栈帧包括局部变量区、求值栈（JVM规范中将其称为“操作数栈”）和其它一些信息。局部变量区用于存储方法的参数与局部变量，其中参数按源码中从左到右顺序保存在局部变量区开头的几个slot。求值栈用于保存求值的中间结果和调用别的方法的参数等。两者都以字长（32位的字）为单位，每个slot可以保存byte、short、char、int、float、reference和returnAddress等长度小于或等于32位的类型的数据；相邻两项可用于保存long和double类型的数据。每个方法所需要的局部变量区与求值栈大小都能够在编译时确定，并且记录在.class文件里。
在上面的例子中，Demo.foo()方法所需要的局部变量区大小为3个slot，需要的求值栈大小为2个slot。Java源码的a、b、c分别被分配到局部变量区的slot 0、slot 1和slot 2。可以观察到Java字节码是如何指示JVM将数据压入或弹出栈，以及数据是如何在栈与局部变量区之前流动的；可以看到数据移动的次数特别多。动画里可能不太明显，iadd和imul指令都是要从求值栈弹出两个值运算，再把结果压回到栈上的；光这样一条指令就有3次概念上的数据移动了。
对了，想提醒一下：Java的局部变量区并不需要把某个局部变量固定分配在某个slot里；不仅如此，在一个方法内某个slot甚至可能保存不同类型的数据。如何分配slot是编译器的自由。从类型安全的角度看，只要对某个slot的一次load的类型与最近一次对它的store的类型匹配，JVM的字节码校验器就不会抱怨。以后再找时间写写这方面。
Dalvik VM：
<img src="" alt="">
说明：Dalvik字节码以16位为单元（或许叫“双字节码”更准确 =_=|||）。上面代码中有5条指令，其中mul-int/lit8指令占2单元，其余每条都只占1单元，共6单元==12字节。
与JVM相似，在Dalvik VM中每个线程都有自己的PC和调用栈，方法调用的活动记录以帧为单位保存在调用栈上。PC记录的是以16位为单位的偏移量而不是以字节为单位的。
与JVM不同的是，Dalvik VM的栈帧中没有局部变量区与求值栈，取而代之的是一组虚拟寄存器。每个方法被调用时都会得到自己的一组虚拟寄存器。常用v0-v15这16个，也有少数指令可以访问v0-v255范围内的256个虚拟寄存器。与JVM相同的是，每个方法所需要的虚拟寄存器个数都能够在编译时确定，并且记录在.dex文件里；每个寄存器都是字长（32位），相邻的一对寄存器可用于保存64位数据。方法的参数按源码中从左到右的顺序保存在末尾的几个虚拟寄存器里。
与JVM版相比，可以发现Dalvik版程序的指令数明显减少了，数据移动次数也明显减少了，用于保存临时结果的存储单元也减少了。
你可能会抱怨：上面两个版本的代码明明不对应：JVM版到return前完好持有a、b、c三个变量的值；而Dalvik版到return-void前只持有b与c的值（分别位于v0与v1），a的值被刷掉了。
但注意到a与b的特征：它们都只在声明时接受过一次赋值，赋值的源是常量。这样就可以对它们应用<a href="http://en.wikipedia.org/wiki/Constant_folding" target="_blank">常量传播</a>，将
Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>int c = (a + b) /* 5;  </li>
</ol>
<p>int c = (a + b) /* 5;
替换为
Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>int c = (1 + 2) /* 5;  </li>
</ol>
<p>int c = (1 + 2) /* 5;
然后可以再对c的初始化表达式应用常量折叠，进一步替换为：
Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>int c = 15;  </li>
</ol>
<p>int c = 15;
把变量的每次状态更新（包括初始赋值在内）称为变量的一次“定义”（definition），把每次访问变量（从变量读取值）称为变量的一次“使用”（use），则可以把代码整理为“使用-定义链”（简称UD链，<a href="http://en.wikipedia.org/wiki/Use-define_chain" target="_blank">use-define chain</a>）。显然，一个变量的某次定义要被使用过才有意义。上面的例子经过常量传播与折叠后，我们可以分析得知变量a、b、c都只被定义而没有被使用。于是它们的定义就成为了无用代码（dead code），可以安全的被消除。
上面一段的分析用一句话描述就是：由于foo()里没有产生外部可见的副作用，所以foo()的整个方法体都可以被优化为空。经过dx工具处理后，Dalvik版程序相对JVM版确实是稍微优化了一些，不过没有影响程序的语义，程序的正确性是没问题的。这是其一。
其二是Dalvik版代码只要多分配一个虚拟寄存器就能在return-void前同时持有a、b、c三个变量的值，指令几乎没有变化：
Dalvik bytecode代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>0000: const/4      v0, /#int 1 // /#1  </li>
<li>0001: const/4      v1, /#int 2 // /#2  </li>
<li>0002: add-int      v2, v0, v1  </li>
<li>0004: mul-int/lit8 v2, v2, /#int 5 // /#05  </li>
<li>0006: return-void  </li>
</ol>
<p>0000: const/4      v0, /#int 1 // /#1</p>
<p>0001: const/4      v1, /#int 2 // /#2
0002: add-int      v2, v0, v1</p>
<p>0004: mul-int/lit8 v2, v2, /#int 5 // /#05
0006: return-void
这样比原先的版本多使用了一个虚拟寄存器，指令方面也多用了一个单元（add-int指令占2单元）；但指令的条数没变，仍然是5条，数据移动的次数也没变。
题外话1：Dalvik VM是基于寄存器的，x86也是基于寄存器的，但两者的“寄存器”却相当不同：前者的寄存器是每个方法被调用时都有自己一组私有的，后者的寄存器则是全局的。也就是说，概念上Dalvik VM字节码中不用担心保护寄存器的问题，某个方法在调用了别的方法返回过来后自己的寄存器的值肯定跟调用前一样。而x86程序在调用函数时要考虑清楚<a href="http://en.wikipedia.org/wiki/Calling_convention" target="_blank">calling convention</a>，调用方在调用前要不要保护某些寄存器的当前状态，还是说被调用方会处理好这些问题，麻烦事不少。Dalvik VM这种虚拟寄存器让人想起一些实际处理器的“寄存器窗口”，例如SPARC的<a href="http://www.usenix.org/events/sec01/full_papers/frantzen/frantzen_html/node5.html" target="_blank">Register Windows</a>也是保证每个函数都觉得自己有“私有的一组寄存器”，减轻了在代码里处理寄存器保护的麻烦——扔给硬件和操作系统解决了。<a href="http://en.wikipedia.org/wiki/Itanium" target="_blank">IA-64</a>也有寄存器窗口的概念。
（当然，Dalvik VM与x86的“寄存器”一个是虚拟寄存器一个是真实硬件的ISA提供的寄存器，本来也不在一个级别上…上面这段只是讨论寄存器的语义。）
题外话2：Dalvik的.dex文件在未压缩状态下的体积通常比同等内容的.jar文件在deflate压缩后还要小。但光从字节码看，Java字节码几乎总是比Dalvik的小，那.dex文件的体积是从哪里来减出来的呢？这主要得益与.dex文件对常量池的压缩，一个.dex文件中所有类都共享常量池，使得相同的字符串、相同的数字常量等都只出现一次，自然能大大减小体积。相比之下，.jar文件中每个类都持有自己的常量池，诸如&quot;Ljava/lang/Object;&quot;这种常见的字符串会被重复多次。Sun自己也有进一步压缩JAR的工具，Pack200，对应的标准是<a href="http://jcp.org/en/jsr/detail?id=200" target="_blank">JSR 200</a>。它的主要应用场景是作为JAR的网络传输格式，以更高的压缩比来减少文件传输时间。在<a href="http://java.sun.com/j2se/1.5.0/docs/guide/deployment/deployment-guide/pack200.html" target="_blank">官方文档</a>提到了Pack200所用到的压缩技巧，
JDK 5.0 Documentation 写道</p>
<p>Pack200 works most efficiently on Java class files. It uses several techniques to efficiently reduce the size of JAR files:</p>
<ul>
<li>It merges and sorts the constant-pool data in the class files and co-locates them in the archive.</li>
<li>It removes redundant class attributes.</li>
<li>It stores internal data structures.</li>
<li>It use delta and variable length encoding.</li>
<li>It chooses optimum coding types for secondary compression.
可见.dex文件与Pack200采用了一些相似的减小体积的方法。很可惜目前还没有正式发布的JVM支持直接加载Pack200格式的归档，毕竟网络传输才是Pack200最初构想的应用场景。<h1 id="-jvm-dalvik-vm-vm-vm-">再次提醒注意，<strong>上面的描述是针对概念上的JVM与Dalvik VM，而不是针对它们的具体实现</strong>。实现VM时可以采用许多优化技巧去减少性能损失，使得实际的运行方式与概念中的不完全相符，只要最终的运行结果满足原本概念上的VM所实现的语义就行。</h1>
上面“简单”的提了些讨论点，不过还没具体到JavaScript引擎，抱歉。弄得太长了，只好在这里先拆分一次……有些东西想写的，洗个澡又忘记了。等想起来再补充 orz
“简单”是相对于实际应该掌握的信息量而言。上面写的都还没挠上痒痒，心虚。
Anyway。根据拆分的现状，下一篇应该是讨论动态语言与编译的问题，然后再下一篇会看看解释器的演化方法，再接着会看看JavaScript引擎的状况（主要针对V8和Nitro，也会谈谈Tamarin。就不讨论JScript了）。
关于推荐资料，在<a href="http://rednaxelafx.iteye.com/link?tag=virtual+machine" target="_blank">“我的收藏”的virtual machine标签</a>里就有不少值得一读的资料。如果只是对JavaScript引擎相关感兴趣的话也可以选着读些。我的收藏里还有v8和tamarin等标签的，资料有的是 ^ ^
能有耐心读到结尾的同学们，欢迎提出意见和建议，以及指出文中的错漏 ^<em>^
不像抓到虫就给美分的大师，我没那种信心……错漏难免，我也需要进一步学习。拜托大家了～
P.S. 画图真的很辛苦，加上JavaEye的带宽也不是无限的……所以拜托不要直接链接这帖里的图 &lt;(</em> _)&gt;
有需要原始图片的可以跟我联系。我是画成多帧PNG然后转换为GIF发出来的。上面的PNG图片都还保留有原始的图层信息，要拿去再编辑也很方便 ^ ^
更新1：
原本在树遍历解释器图解的小节中，我用的是这幅图：
<img src="" alt="">
其实上图画得不准确，a、b、c的右值不应该画在节点上的；节点应该只保存了它们的左值才对，要获取对应的右值就要查询变量表。我修改了图更新到正文了。原本的图里对i的赋值看起来很奇怪，就像是遍历过程经过了两次i节点一般，而事实不是那样的。</li>
</ul>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/JVM/">JVM</a></li></span></span> | <span class="tags">Tagged <a href="/tags/JVM/" class="label label-primary">JVM</a><a href="/tags/Java&J2EE/" class="label label-success">Java&J2EE</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:42"datetime="2014-03-07 09:54:42"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-JVM--虚拟机随谈（一）：解释器，树遍历解释器，基于栈与基于寄存器，大杂烩/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-JVM--虚拟机随谈（一）：解释器，树遍历解释器，基于栈与基于寄存器，大杂烩" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--JVM调优总结（十二）-参考资料/">JVM调优总结（十二）</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:42.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--JVM调优总结（十二）-参考资料/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="jvm-">JVM调优总结（十二）-参考资料</h1>
<pre><code>能整理出上面一些东西，也是因为站在巨人的肩上。下面是一些参考资料，供大家学习，大家有更好的，可以继续完善：）
</code></pre><p>· <a href="http://www.ibm.com/developerworks/cn/java/j-jtp10283/" target="_blank">Java 理论与实践: 垃圾收集简史</a></p>
<p>· <a href="http://pengjiaheng.iteye.com/admin/blogs/#resources" target="_blank">Java SE 6 HotSpot[tm] Virtual Machine Garbage Collection Tuning</a></p>
<p>· <a href="http://pengjiaheng.iteye.com/admin/blogs/#16.2.6" target="_blank">Improving Java Application Performance and Scalability by Reducing Garbage Collection Times and Sizing Memory Using JDK 1.4.1</a></p>
<p>· <a href="https://java.sun.com/j2se/reference/whitepapers/memorymanagement_whitepaper.pdf" target="_blank">Hotspot memory management whitepaper</a></p>
<p>· <a href="http://java.sun.com/performance/reference/whitepapers/tuning.html" target="_blank">Java Tuning White Paper</a></p>
<p>· <a href="http://java.sun.com/docs/hotspot/gc1.4.2/example.html" target="_blank">Diagnosing a Garbage Collection problem</a></p>
<p>· <a href="http://java.sun.com/javase/technologies/hotspot/vmoptions.jsp" target="_blank">Java HotSpot VM Options</a></p>
<p>· <a href="http://blogs.sun.com/watt/resource/jvm-options-list.html" target="_blank">A Collection of JVM Options</a></p>
<p>· <a href="http://research.sun.com/jtech/pubs/04-g1-paper-ismm.pdf" target="_blank">Garbage-First Garbage Collection</a></p>
<p>· <a href="http://java.sun.com/docs/hotspot/gc1.4.2/faq.html" target="_blank">Frequently Asked Questions about Garbage Collection in the HotspotTM JavaTM Virtual Machine</a></p>
<p>· <a href="http://pengjiaheng.spaces.live.com/blog/cns!2DAA368B386E6AEA!685.entry" target="_blank">JProfiler试用手记</a></p>
<p>· <a href="http://kenwu.me/java6-jvm-options-chinese-edition-published" target="_blank">Java6 JVM参数选项大全</a></p>
<p>· <a href="http://www.douban.com/subject/1138768/" target="_blank">《深入Java虚拟机》</a>。虽然过去了很多年，但这本书依旧是经典。</p>
<pre><code>这里是本系列的最后一篇了，很高兴大家能够喜欢这系列的文章。期间也提了很多问题，其中有些是我之前没有想到的或者考虑欠妥的，感谢提出这些问题的朋友，我也学到的不少东西。
</code></pre>
      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/JVM/">JVM</a></li></span></span> | <span class="tags">Tagged <a href="/tags/JVM/" class="label label-primary">JVM</a><a href="/tags/Java&J2EE/" class="label label-success">Java&J2EE</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:42"datetime="2014-03-07 09:54:42"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-JVM--JVM调优总结（十二）-参考资料/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-JVM--JVM调优总结（十二）-参考资料" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_字符集--URL特殊字符详解-没有所谓的失败！除非你不再尝试！-PHPChina开源社区门户-P/">URL特殊字符详解 </a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:41.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_字符集--URL特殊字符详解-没有所谓的失败！除非你不再尝试！-PHPChina开源社区门户-P/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="url-phpchina-powered-by-x-space">URL特殊字符详解 - 没有所谓的失败！除非你不再尝试！ - PHPChina 开源社区门户 - Powered by X-Space</h1>
<p><strong>没有所谓的失败！除非你不再尝试！</strong></p>
<p><a href="&quot;复制地址&quot;">copy</a> <a href="http://smarty.blog.phpchina.com/" title="加入收藏" target="_blank">Bookmark</a> <a href="http://smarty.blog.phpchina.com" target="_blank">http://smarty.blog.phpchina.com</a></p>
<ul>
<li><a href="http://www.phpchina.com/?uid-26354-action-spacelist-type-friend" target="_blank">好友</a></li>
<li><a href="http://www.phpchina.com/?uid-26354-action-spacelist-type-bbs" target="_blank">论坛</a></li>
<li><a href="http://www.phpchina.com/?uid-26354-action-viewpro" target="_blank">留言</a></li>
</ul>
<p><a href="http://www.phpchina.com/batch.manage.php?uid=26354" target="_blank">空间管理</a> 您的位置: <a href="http://www.phpchina.com/" target="_blank">PHPChina 开源社区门户</a> » <a href="http://www.phpchina.com/?uid-26354" target="_blank">没有所谓的失败！除非你不再尝试！</a> » <a href="http://www.phpchina.com/?uid-26354-action-spacelist-type-blog" target="_blank">日志</a></p>
<p>每天都在进步一点点，在这里我将记下我的点点滴滴，希望和大家一起进步，一起学习，一起共同成长PHPer之路！ PHPer成长群(49052575)欢迎各界精英加入，互相学习，互补不足。空间不再更新：如有需要请进 <a href="http://www.phpcake.cn" target="_blank">http://www.phpcake.cn</a></p>
<h1 id="url-">URL特殊字符详解</h1>
<p><a href="http://www.phpchina.com/batch.common.php?action=viewspace&amp;op=up&amp;itemid=32317&amp;uid=26354" target="_blank">上一篇</a> / <a href="http://www.phpchina.com/batch.common.php?action=viewspace&amp;op=next&amp;itemid=32317&amp;uid=26354" target="_blank">下一篇</a>  2008-04-11 19:48:57 / 个人分类：<a href="http://www.phpchina.com/?uid-26354-action-spacelist-type-blog-itemtypeid-3538" target="_blank">url特殊字符</a>
<a href="http://www.phpchina.com/html/54/26354-32317.html#xspace-tracks" target="_blank">查看( 386 )</a> / <a href="http://www.phpchina.com/html/54/26354-32317.html#xspace-itemreply" target="_blank">评论( 2 )</a> / <a href="http://www.phpchina.com/html/54/26354-32317.html#xspace-itemform" target="_blank">评分( 1 / 0 )</a></p>
<p>有些符号在URL中是不能直接传递的，如果要在URL中传递这些特殊符号，那么就要使用他们的编码了。编码的格式为：%加字符的ASCII码，即一个百分号%，后面跟对应字符的ASCII（16进制）码值。例如 空格的编码值是”%20″。
下表中列出了一些URL特殊符号及编码
十六进制值 1. + URL 中+号表示空格 %2B 2. 空格 URL中的空格可以用+号或者编码 %20 3. / 分隔目录和子目录 %2F 4. ? 分隔实际的 URL 和参数 %3F 5. % 指定特殊字符 %25 6. /# 表示书签 %23 7. &amp; URL 中指定的参数间的分隔符 %26 8. = URL 中指定参数的值 %3D</p>
<p>例：要传递字符串“this%is/#te=st&amp;o k?+/”作为参数t传给te.asp，则URL可以是:
te.asp?t=this%25is%23te%3Dst%26o%20k%3F%2B%2F 或者
te.asp?t=this%25is%23te%3Dst%26o+k%3F%2B%2F （空格可以用%20或+代替）java中URL 的编码和解码函数
java.net.URLEncoder.encode(String s)和java.net.URLDecoder.decode(String s);
注：encode(String s)<a href=""><strong>方法</strong></a>过期了，现在一般用encode(String s, “GBK”);</p>
<p>在javascrīpt 中URL 的编码和解码函数
<a href=""><strong>escape</strong></a>(String s)和<a href=""><strong>unescape</strong></a>(String s) ;</p>
<h3 id="-">相关阅读:</h3>
<ul>
<li><a href="http://www.phpchina.com/?uid-26354-action-viewspace-itemid-20379" target="_blank">encodeURIComponent应用</a> (<a href="http://www.phpchina.com/?uid-26354" target="_blank">design_dd</a>, 2007-12-06)</li>
<li><a href="http://www.phpchina.com/?uid-50821-action-viewspace-itemid-30743" target="_blank">FLEAPHP 的一些基础学习连接</a> (<a href="http://www.phpchina.com/?uid-50821" target="_blank">brucehawking</a>, 2008-3-30)</li>
</ul>
<p><a href="">导入论坛</a> <a href="">收藏</a> <a href="">分享给好友</a> <a href="http://www.phpchina.com/batch.manage.php?itemid=32317" target="_blank">管理</a> <a href="">举报</a></p>
<p>TAG: <a href="http://www.phpchina.com/?action-tag-tagname-url" target="_blank">url</a> <a href="http://www.phpchina.com/?action-tag-tagname-escape" target="_blank">escape</a> <a href="http://www.phpchina.com/?action-tag-tagname-unescape" target="_blank">unescape</a> <a href="http://www.phpchina.com/?action-tag-tagname-url%CC%D8%CA%E2%D7%D6%B7%FB" target="_blank">url特殊字符</a>
<a href="http://www.phpchina.com/?uid-26354" target="_blank"><img src="" alt="没有所谓的失败！除非你不再尝试！"></a> <a href="">引用</a> <a href="">删除</a> <a href="http://www.phpchina.com/?uid-26354" target="_blank">design_dd</a>   /   2008-04-19 16:11:49 谢谢支持^_^ <img src="" alt=""> <a href="">引用</a> <a href="">删除</a> 废墟   /   2008-04-17 21:36:42 评 1 分
不错。。怎么没人顶啊  。。这些人 就知道看 也不顶。。</p>
<p><a href="">查看全部评论</a></p>
<p><a href="">-5</a> <a href="">-3</a> <a href="">-1</a> <a href="">-</a> <a href="">+1</a> <a href="">+3</a> <a href="">+5</a></p>
<p>评分：0</p>
<p>我来说两句</p>
<p>显示全部</p>
<p><img src="" alt=":loveliness:"> <img src="" alt=":handshake"> <img src="" alt=":victory:"> <img src="" alt=":funk:"> <img src="" alt=":time:"> <img src="" alt=":kiss:"> <img src="" alt=":call:"> <img src="" alt=":hug:"> <img src="" alt=":lol"> <img src="" alt=":&#39;("> <img src="" alt=":Q"> <img src="" alt=":L"> <img src="" alt=";P"> <img src="" alt=":$"> <img src="" alt=":P"> <img src="" alt=":o"> <img src="" alt=":@"> <img src="" alt=":D"> <img src="" alt=":("> <img src="" alt=":)"></p>
<p>内容</p>
<p>昵称</p>
<p>加入事件</p>
<p>提交评论</p>
<p><img src="" alt="design_dd"></p>
<p><a href="http://www.phpchina.com/?uid-26354-action-viewpro-showpro-1" target="_blank">design_dd</a></p>
<h3 id="-">用户菜单</h3>
<ul>
<li><a href="http://www.phpchina.com/?uid-26354-action-viewpro" target="_blank">给我留言</a></li>
<li><a href="">加入好友</a></li>
<li><a href="http://bbs.phpchina.com/pm.php?action=send&amp;uid=26354" target="_blank">发短消息</a></li>
<li><a href="http://www.phpchina.com/?uid-26354-action-viewpro-showpro-1" target="_blank">我的介绍</a></li>
<li><a href="http://bbs.phpchina.com/viewpro.php?uid=26354" target="_blank">论坛资料</a></li>
<li><a href="http://www.phpchina.com/batch.manage.php?uid=26354" target="_blank">空间管理</a><h3 id="-">标题搜索</h3>
</li>
</ul>
<h3 id="-">我的存档</h3>
<ul>
<li><a href="http://www.phpchina.com/?uid-26354-action-spacelist-starttime-1206979200-endtime-1209571200" target="_blank">2008年04月</a></li>
<li><a href="http://www.phpchina.com/?uid-26354-action-spacelist-starttime-1204300800-endtime-1206979200" target="_blank">2008年03月</a></li>
<li><a href="http://www.phpchina.com/?uid-26354-action-spacelist-starttime-1201795200-endtime-1204300800" target="_blank">2008年02月</a></li>
<li><a href="http://www.phpchina.com/?uid-26354-action-spacelist-starttime-1199116800-endtime-1201795200" target="_blank">2008年01月</a></li>
<li><a href="http://www.phpchina.com/?uid-26354-action-spacelist-starttime-1196438400-endtime-1199116800" target="_blank">2007年12月</a></li>
<li><a href="http://www.phpchina.com/?uid-26354-action-spacelist-starttime-1193846400-endtime-1196438400" target="_blank">2007年11月</a></li>
<li><a href="http://www.phpchina.com/?uid-26354-action-spacelist-starttime-1191168000-endtime-1193846400" target="_blank">2007年10月</a></li>
<li><a href="http://www.phpchina.com/?uid-26354-action-spacelist-starttime-1188576000-endtime-1191168000" target="_blank">2007年09月</a></li>
<li><a href="http://www.phpchina.com/?uid-26354-action-spacelist-starttime-1185897600-endtime-1188576000" target="_blank">2007年08月</a></li>
<li><a href="http://www.phpchina.com/?uid-26354-action-spacelist-starttime-1183219200-endtime-1185897600" target="_blank">2007年07月</a></li>
<li><a href="http://www.phpchina.com/?uid-26354-action-spacelist-starttime-1180627200-endtime-1183219200" target="_blank">2007年06月</a></li>
<li><p><a href="http://www.phpchina.com/?uid-26354-action-spacelist-starttime-1177948800-endtime-1180627200" target="_blank">2007年05月</a></p>
<h3 id="-">数据统计</h3>
</li>
<li><p>访问量: 30236</p>
</li>
<li>日志数: 69</li>
<li>建立时间: 2007-05-14</li>
<li>更新时间: 2008-04-11</li>
</ul>
<h3 id="rss-">RSS订阅</h3>
<ul>
<li><a href="http://www.phpchina.com/?uid-26354-action-rss-type-blog" target="_blank"><img src="" alt="RSS订阅"></a></li>
</ul>
<p><a href="http://www.phpchina.com/batch.login.php?action=logout" target="_blank">清空Cookie</a> - <a href="mailto:PHPChina">联系我们</a> - <a href="http://www.phpchina.com/" target="_blank">PHPChina 开源社区门户</a> - <a href="http://bbs.phpchina.com/" target="_blank">交流论坛</a> - <a href="http://www.phpchina.com/?action/spaces" target="_blank">空间列表</a> - <a href="http://www.phpchina.com/archiver/" target="_blank">站点存档</a> - <a href="http://www.phpchina.com/?action/register" target="_blank">升级自己的空间</a></p>
<p>Powered by <a href="http://www.supesite.com/" target="_blank"><strong>X-Space</strong></a> <em>4.0 UC</em> © 2001-2008 <a href="http://www.comsenz.com/" target="_blank">Comsenz Inc.</a>
<a href="http://www.miibeian.gov.cn/" target="_blank">京ICP备07504665号</a>
<a href="">Open Toolbar</a></p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/Java_字符集/">Java_字符集</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/Java_字符集/" class="label label-success">Java_字符集</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:41"datetime="2014-03-07 09:54:41"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-Java_字符集--URL特殊字符详解-没有所谓的失败！除非你不再尝试！-PHPChina开源社区门户-P/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-Java_字符集--URL特殊字符详解-没有所谓的失败！除非你不再尝试！-PHPChina开源社区门户-P" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>





<ul id="pagination" class="pagination pagination-lg">
  <li><a class="extend prev" href="/page/52/">&laquo;</a></li><li><a class="page-number" href="/">1</a></li><li><a class="page-number" href="/page/2/">2</a></li><li><span class="space">&hellip;</span></li><li><a class="page-number" href="/page/50/">50</a></li><li><a class="page-number" href="/page/51/">51</a></li><li><a class="page-number" href="/page/52/">52</a></li><li class="active"><li><span class="page-number current">53</span></li><li><a class="page-number" href="/page/54/">54</a></li><li><a class="page-number" href="/page/55/">55</a></li><li><a class="page-number" href="/page/56/">56</a></li><li><span class="space">&hellip;</span></li></li><li><a class="page-number" href="/page/164/">164</a></li><li><a class="page-number" href="/page/165/">165</a></li><li><a class="extend next" href="/page/54/">&raquo;</a></li>
  <div class="clearfix"></div>
</ul></div><!--wapper-->
       </div><!-- ID main-col END -->
       <aside id="sidebar" class="alignright col-sx-6 col-sm-4 col-md-3 col-lg-3">
<div id="widget_search" class="widget panel panel-primary">
    <form action="//google.com/search" method="get" accept-charset="utf-8">
  <div class="input-group">
    <input class="form-control" id="searchbox" type="search" name="q" results="0" placeholder="search">
    <span class="input-group-btn">
      <button class="btn btn-default" type="submit">Go!</button>
    </span>
    <input type="hidden" name="q" value="site:itsolife.com">
  </div>
</form>
</div>

<div id="widget_category" class="widget panel panel-primary">
  <div class="panel-heading">category</div>  <div data-src='category' class='ajax_widgets'>正在加载...</div>
</div>

<div id="widget_recent_posts" class="widget panel panel-primary">
  <div class="panel-heading">recent posts</div>  <div data-src='recent_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_tagcloud" class="widget panel panel-primary">
  <div class="panel-heading">tagcloud</div>  <div data-src='tagcloud' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_latest_update_posts" class="widget panel panel-primary">
  <div class="panel-heading">最近更新</div>  <div data-src='latest_update_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_recent_comments" class="widget panel panel-primary">
  <div class="panel-heading">recent comments</div>  

<div class="list-group-item ds-recent-comments" data-num-items="6" data-show-avatars="1" data-show-time="1" data-show-title="1" data-show-admin="1" data-excerpt-length="50"></div>



</div>

</aside>
       <div class="clearfix"></div>
     </div><!-- row END -->
  </div>
  <footer id="footer" class="container">
  <div class="panel panel-info">
  <section id='footer_widget'></section>  <div class="panel-footer">
  <div id="site-info">
    <span class='author'>
  
  &copy; 2014 RobinChia
  
    &nbsp;&nbsp;</span>
  
  <span id='analytics-51la'></span><span id='analytics-google'>
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-48559895-1']);
  _gaq.push(['_trackPageview']);
  _js2load.push({src:('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'});
</script></span><span id='analytics-cnzz'>
<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_5774006'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s17.cnzz.com/stat.php%3Fid%3D5774006%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>
</span><span id='analytics-baidu'>
<script>
var _hmt = _hmt || [];
_js2load.push({src:"//hm.baidu.com/hm.js?1442f50724afc42380b51f097c43082c"});
</script>
</span>  </div>
  <div id="copyright">Blog powered by <a href='http://zespia.tw/hexo/'><strong>hexo</strong></a> Theme <strong><a href='https://github.com/chenall/hexo-theme-chenall'>chenall</a></strong>(Some change in it)<span class="pull-right"> 更新时间: <em>2014-03-26 21:21:33</em></span></div>
</div>
<div class="clearfix"></div>


  </div>
  </footer>
  
        <script src="http://cdn.bootcss.com/jquery/1.10.2/jquery.min.js"></script>        
        <script src="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/js/bootstrap.min.js"></script>        
                
        <script src="http://cdn.bootcss.com/prettify/r298/prettify.min.js"></script>    <script type="text/javascript">
   var lang=["bsh", "c", "cc", "cpp", "cs", "csh", "cyc", "cv", "htm", "html",
    "java", "js", "m", "mxml", "perl", "pl", "pm", "py", "rb", "sh",
    "xhtml", "xml", "xsl"];
   var pretty_base='';
   $('script').each(function(){
	var c = $(this).attr('src');
	if (!c)
	    return;
	if (c.match(/(\/)?prettify(\.min)?\.js/i))
	{
	    var index = c.lastIndexOf('/');
	    if (index != -1)
		pretty_base = c.substr(0,index + 1);
	    return false;
	}
   })
   $('pre code').each(function(){
	var c = $(this).attr('class')
	if (!c)
	    return;
	c = c.match(/\s?(lang\-\w+)/i);
	if (c && lang.indexOf(c[1]) == -1)
	{
	    lang.push(c[1]);
	    $.getScript(pretty_base + c[1] + '.min.js');
	}
   })

    $(window).load(function(){
       $("pre").addClass("prettyprint");
       prettyPrint();
    })
</script>    
            <script type="text/javascript">
var duoshuoQuery = {short_name:"robinchia"};
_js2load.push({src:'http://static.duoshuo.com/embed.js',charset:'UTF-8'});
</script>
    
            <!--wumii_relatedItems-->
    
        <script src="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js"></script>    <script type="text/javascript">
(function($){
  $('.entry').each(function(i){
    $(this).find('img').each(function(){
      var alt = this.alt;

      if (alt){
        $(this).before('<span class="caption">' + alt + '</span>');
      }

      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox" rel="fancybox' + i + '" />');
    });
  });

  $('.fancybox').fancybox();
})(jQuery);
</script>    
        <script src="http://cdn.bootcss.com/mathjax/2.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>    <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>
    
<script type="text/javascript">
$('.ajax_widgets').each(function(){var src=$(this).attr('data-src');if(src)$(this).load('/widgets/'+src+'.html');});
$.each(_js2load,function(index,obj){loadjs(obj.src,obj.charset)});
</script>

<div id="scroll2top">
<img src="/scroll2top/arrow.png"/>
</div>
<script src="/scroll2top/scroll2top.min.js"></script>
<div id="winterland">
  <canvas></canvas>
</div>
<script src="/js/winterland.min.js"></script>

  </body>
</html>
