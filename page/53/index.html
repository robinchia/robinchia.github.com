
<!DOCTYPE HTML>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>The 53 Page | It so life</title>
<meta name="author" content="RobinChia">

<meta name="description" content="It so life">


<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<meta property="og:site_name" content="It so life"/>

<!--[if IE]><style>.testIE.IE{display:inline;}</style><![endif]-->
<!--[if lte IE 7]><link rel="stylesheet" href="/css/ie7.css" type="text/css"><![endif]-->
<!--[if (lt IE 9)&(gt IE 7)]><style>.testIE.IE8{display:inline;}</style><![endif]-->
<!--[if gt IE 8]><style>.testIE.IE9{display:inline;}</style><![endif]-->

<link href="/favicon.png" rel="icon">
<link rel="alternate" href="/atom.xml" title="It so life Feed" type="application/atom+xml">

<link rel="stylesheet" href="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/css/bootstrap.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/font-awesome/4.0.3/css/font-awesome.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/prettify/r298/prettify.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" type="text/css">
<link rel="stylesheet" href="/css/style.css" type="text/css">
<!--[if lt IE 9]>
   <style>article,aside,dialog,footer,header,section,footer,nav,figure,menu{display:block}</style>
   <script src="http://cdn.staticfile.org/html5shiv/r29/html5.min.js"></script>
   <script src="http://cdn.staticfile.org/respond.js/1.4.2/respond.min.js"></script>
<link href="http://cdn.staticfile.org/respond.js/1.4.2/respond-proxy.html" id="respond-proxy" rel="respond-proxy" />
<link href="/js/respond.proxy.gif" id="respond-redirect" rel="respond-redirect" />
<script src="/js/respond.proxy.js"></script>
   <script src="http://cdn.bootcss.com/selectivizr/1.0.2/selectivizr-min.js"></script>
<![endif]-->
<script type="text/javascript">
function loadjs(c,d){var a=document.createElement("script");a.async=!0;a.type="text/javascript";a.src=c;a.charset=d||"gbk";(document.getElementsByTagName("HEAD")[0]||document.getElementsByTagName("BODY")[0]).appendChild(a)};
var _protocol = (("https:" == document.location.protocol) ? " https://" : " http://");
var _js2load = [];
</script>

</head>
<body>
      <header id="header" class="container"><nav id="main-nav" class="navbar navbar-default navbar-fixed-top " role="navigation">
  <div class="container">
    <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
      <span class="sr-only">Toggle navigation</span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="/">It so life</a>
    </div>
    <div  class="collapse navbar-collapse">
      <ul  class="nav navbar-nav">
  
        <li><a href="/" title="Home">Home</a></li>      
        <li><a href="/about/" title="About">About</a></li>      
        <li><a href="/archives/" title="Archives">Archives</a></li>      
      <li class='dropdown'>
        <a class='dropdown-toggle' data-toggle='dropdown' href='#'>website<b class='caret'></b></a>
        <ul class='dropdown-menu pure-menu-selected'>
    
          <li><a href="//groups.google.com/forum/#!forum/pongba" title="TopLanguage">TopLanguage</a></li>    
          <li><a href="//itpub.net/" title="ITPub">ITPub</a></li>    
          <li><a href="//blog.jobbole.com/" title="Bole">Bole</a></li>    
          <li><a href="//nosql-database.org/" title="nosql">nosql</a></li>    
          <li><a href="//gitimmersion.googol.im/" title="Git">Git</a></li>    
        </ul>
      </li>
    
      </ul>
      <ul class="nav navbar-nav navbar-right">
      
        <li><a href="/atom.xml">RSS</a></li>
      
      
        <li><a href="https://twitter.com/robinchia">twitter</a></li>
      
      
      
      
        <li><a href="https://github.com/robinchia">github</a></li>
      
      </ul>
    </div>
  </div>
</nav>
<div class="clearfix"></div>
</header>
  <div id='content' class="container">
     <div class="page-header-wrapper">
      <!--[if lt IE 9]><div class="alert alert-warning alert-dismissable"><button type="button" class="close" data-dismiss="alert" aria-hidden="true">&times;</button><strong>提示:</strong>您的浏览器版本太低了,建议升级到 <strong><a href="http://windows.microsoft.com/zh-cn/internet-explorer/download-ie" title="IE9">IE9</a></strong> 以上,本站使用<a href="https://www.google.com/intl/zh-CN/chrome/">Chrome浏览器</a>可以获得最好的显示效果.</div><![endif]-->
      <div class="page-header"><h1 align="center"><big>It so life</big> </h1>
        <h5 align="center"><big>love as life</big></h5>
      </div>
     </div>
     <div class="row">
       <div id="main-col" class="alignleft col-sx-12 col-sm-8 col-md-9 col-lg-9">
      <section id='header_widget'></section>
          <div id="wrapper"><article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--GarbageFirst介绍/">Garbage First介绍</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:42.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--GarbageFirst介绍/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="garbage-first-">Garbage First介绍</h1>
<h1 id="-bluedavy-blog-http-www-blogjava-net-bluedavy-"><a href="http://www.blogjava.net/BlueDavy/" target="_blank">BlueDavy之技术Blog</a></h1>
<p>理论不懂就实践，实践不会就学理论！</p>
<h2 id="-garbage-first-http-www-blogjava-net-bluedavy-archive-2009-03-11-259230-html-"><a href="http://www.blogjava.net/BlueDavy/archive/2009/03/11/259230.html" target="_blank">Garbage First介绍</a></h2>
<p>本文摘自《构建高性能的大型分布式Java应用》一书，Garbage First简称G1，它的目标是要做到尽量减少GC所导致的应用暂停的时间，让应用达到准实时的效果，同时保持JVM堆空间的利用率，将作为CMS的替代者在JDK 7中闪亮登场，其最大的特色在于允许指定在某个时间段内GC所导致的应用暂停的时间最大为多少，例如在100秒内最多允许GC导致的应用暂停时间为1秒，这个特性对于准实时响应的系统而言非常的吸引人，这样就再也不用担心系统突然会暂停个两三秒了。</p>
<p>G1要做到这样的效果，也是有前提的，一方面是硬件环境的要求，必须是多核的CPU以及较大的内存（从规范来看，512M以上就满足条件了），另外一方面是需要接受吞吐量的稍微降低，对于实时性要求高的系统而言，这点应该是可以接受的。</p>
<p>为了能够达到这样的效果，G1在原有的各种GC策略上进行了吸收和改进，在G1中可以看到增量收集器和CMS的影子，但它不仅仅是吸收原有GC策略的优点，并在此基础上做出了很多的改进，简单来说，G1吸收了增量GC以及CMS的精髓，将整个jvm Heap划分为多个固定大小的region，扫描时采用Snapshot-at-the-beginning的并发marking算法（具体在后面内容详细解释）对整个heap中的region进行mark，回收时根据region中活跃对象的bytes进行排序，首先回收活跃对象bytes小以及回收耗时短（预估出来的时间）的region，回收的方法为将此region中的活跃对象复制到另外的region中，根据指定的GC所能占用的时间来估算能回收多少region，这点和以前版本的Full GC时得处理整个heap非常不同，这样就做到了能够尽量短时间的暂停应用，又能回收内存，由于这种策略在回收时首先回收的是垃圾对象所占空间最多的region，因此称为Garbage First。</p>
<p>看完上面对于G1策略的简短描述，并不能清楚的掌握G1，在继续详细看G1的步骤之前，必须先明白G1对于JVM Heap的改造，这些对于习惯了划分为new generation、old generation的大家来说都有不少的新意。</p>
<p>G1将Heap划分为多个固定大小的region，这也是G1能够实现控制GC导致的应用暂停时间的前提，region之间的对象引用通过remembered set来维护，每个region都有一个remembered set，remembered set中包含了引用当前region中对象的region的对象的pointer，由于同时应用也会造成这些region中对象的引用关系不断的发生改变，G1采用了Card Table来用于应用通知region修改remembered sets，Card Table由多个512字节的Card构成，这些Card在Card Table中以1个字节来标识，每个应用的线程都有一个关联的remembered set log，用于缓存和顺序化线程运行时造成的对于card的修改，另外，还有一个全局的filled RS buffers，当应用线程执行时修改了card后，如果造成的改变仅为同一region中的对象之间的关联，则不记录remembered set log，如造成的改变为跨region中的对象的关联，则记录到线程的remembered set log，如线程的remembered set log满了，则放入全局的filled RS buffers中，线程自身则重新创建一个新的remembered set log，remembered set本身也是一个由一堆cards构成的哈希表。</p>
<p>尽管G1将Heap划分为了多个region，但其默认采用的仍然是分代的方式，只是仅简单的划分为了年轻代（young）和非年轻代，这也是由于G1仍然坚信大多数新创建的对象都是不需要长的生命周期的，对于应用新创建的对象，G1将其放入标识为young的region中，对于这些region，并不记录remembered set logs，扫描时只需扫描活跃的对象，G1在分代的方式上还可更细的划分为：fully young或partially young，fully young方式暂停的时候仅处理young regions，partially同样处理所有的young regions，但它还会根据允许的GC的暂停时间来决定是否要加入其他的非young regions，G1是运行到fully-young方式还是partially young方式，外部是不能决定的，在启动时，G1采用的为fully-young方式，当G1完成一次Concurrent Marking后，则切换为partially young方式，随后G1跟踪每次回收的效率，如果回收fully-young中的regions已经可以满足内存需要的话，那么就切换回fully young方式，但当heap size的大小接近满的情况下，G1会切换到partially young方式，以保证能提供足够的内存空间给应用使用。</p>
<p>除了分代方式的划分外，G1还支持另外一种pure G1的方式，也就是不进行代的划分，pure方式和分代方式的具体不同在下面的具体执行步骤中进行描述。</p>
<p>掌握了这些概念后，继续来看G1的具体执行步骤：</p>
<ol>
<li>Initial Marking</li>
</ol>
<p>G1对于每个region都保存了两个标识用的bitmap，一个为previous marking bitmap，一个为next marking bitmap，bitmap中包含了一个bit的地址信息来指向对象的起始点。</p>
<p>开始Initial Marking之前，首先并发的清空next marking bitmap，然后停止所有应用线程，并扫描标识出每个region中root可直接访问到的对象，将region中top的值放入next top at mark start（TAMS）中，之后恢复所有应用线程。</p>
<p>触发这个步骤执行的条件为：</p>
<p>l  G1定义了一个JVM Heap大小的百分比的阀值，称为h，另外还有一个H，H的值为(1-h)/<em>Heap Size，目前这个h的值是固定的，后续G1也许会将其改为动态的，根据jvm的运行情况来动态的调整，在分代方式下，G1还定义了一个u以及soft limit，soft limit的值为H-u/</em>Heap Size，当Heap中使用的内存超过了soft limit值时，就会在一次clean up执行完毕后在应用允许的GC暂停时间范围内尽快的执行此步骤；</p>
<p>l  在pure方式下，G1将marking与clean up组成一个环，以便clean up能充分的使用marking的信息，当clean up开始回收时，首先回收能够带来最多内存空间的regions，当经过多次的clean up，回收到没多少空间的regions时，G1重新初始化一个新的marking与clean up构成的环。</p>
<ol>
<li>Concurrent Marking</li>
</ol>
<p>按照之前Initial Marking扫描到的对象进行遍历，以识别这些对象的下层对象的活跃状态，对于在此期间应用线程并发修改的对象的以来关系则记录到remembered set logs中，新创建的对象则放入比top值更高的地址区间中，这些新创建的对象默认状态即为活跃的，同时修改top值。</p>
<ol>
<li>Final Marking Pause</li>
</ol>
<p>当应用线程的remembered set logs未满时，是不会放入filled RS buffers中的，在这样的情况下，这些remebered set logs中记录的card的修改就会被更新了，因此需要这一步，这一步要做的就是把应用线程中存在的remembered set logs的内容进行处理，并相应的修改remembered sets，这一步需要暂停应用，并行的运行。</p>
<ol>
<li>Live Data Counting and Cleanup</li>
</ol>
<p>值得注意的是，在G1中，并不是说Final Marking Pause执行完了，就肯定执行Cleanup这步的，由于这步需要暂停应用，G1为了能够达到准实时的要求，需要根据用户指定的最大的GC造成的暂停时间来合理的规划什么时候执行Cleanup，另外还有几种情况也是会触发这个步骤的执行的：</p>
<p>l  G1采用的是复制方法来进行收集，必须保证每次的”to space”的空间都是够的，因此G1采取的策略是当已经使用的内存空间达到了H时，就执行Cleanup这个步骤；</p>
<p>l  对于full-young和partially-young的分代模式的G1而言，则还有情况会触发Cleanup的执行，full-young模式下，G1根据应用可接受的暂停时间、回收young regions需要消耗的时间来估算出一个yound regions的数量值，当JVM中分配对象的young regions的数量达到此值时，Cleanup就会执行；partially-young模式下，则会尽量频繁的在应用可接受的暂停时间范围内执行Cleanup，并最大限度的去执行non-young regions的Cleanup。</p>
<p>这一步中GC线程并行的扫描所有region，计算每个region中低于next TAMS值中marked data的大小，然后根据应用所期望的GC的短延时以及G1对于region回收所需的耗时的预估，排序region，将其中活跃的对象复制到其他region中。</p>
<p>G1为了能够尽量的做到准实时的响应，例如估算暂停时间的算法、对于经常被引用的对象的特殊处理等，G1为了能够让GC既能够充分的回收内存，又能够尽量少的导致应用的暂停，可谓费尽心思，从G1的论文中的性能评测来看效果也是不错的，不过如果G1能允许开发人员在编写代码时指定哪些对象是不用mark的就更完美了，这对于有巨大缓存的应用而言，会有很大的帮助，G1将随JDK 6 Update 14 beta发布。</p>
<p>posted on 2009-03-11 22:18 <a href="http://www.blogjava.net/BlueDavy/" target="_blank">BlueDavy</a> 阅读(5465) <a href="">评论(3)</a>  <a href="http://www.blogjava.net/BlueDavy/admin/EditPosts.aspx?postid=259230" target="_blank">编辑</a>  <a href="http://www.blogjava.net/BlueDavy/AddToFavorite.aspx?id=259230" target="_blank">收藏</a> 所属分类: <a href="http://www.blogjava.net/BlueDavy/category/1366.html" target="_blank">Java</a></p>
<p> <img src="" alt=""></p>
<p><a href=""></a> <a href=""></a></p>
<p>[</p>
<h3 id="-">评论</h3>
<p>]()</p>
<h3 id="-permalink-re-garbage-first-re-garbage-first-2009-03-14-13-37-phpxer-http-www-blogjava-net-phpxer-"><a href=""></a><a href="&quot;permalink: re: Garbage First介绍&quot;">/#</a> <a href=""></a>re: Garbage First介绍  2009-03-14 13:37  <a href="http://www.blogjava.net/phpxer/">phpxer</a></h3>
<p>Mark  <a href="">回复</a>  <a href="http://www.blogjava.net/comment?author=phpxer" title="查看该作者发表过的评论" target="_blank">更多评论</a> <a href=""></a>  <a href=""></a></p>
<h3 id="-permalink-re-garbage-first-re-garbage-first-2009-04-01-12-14-http-www-owner0571-com-about-asp-c-cs-"><a href="&quot;permalink: re: Garbage First介绍&quot;">/#</a> <a href=""></a>re: Garbage First介绍  2009-04-01 12:14  <a href="http://www.owner0571.com/about.asp?c=CS">中国兄弟连</a></h3>
<p>给你踩踩哈!  <a href="">回复</a>  <a href="http://www.blogjava.net/comment?author=%e4%b8%ad%e5%9b%bd%e5%85%84%e5%bc%9f%e8%bf%9e" title="查看该作者发表过的评论" target="_blank">更多评论</a> <a href=""></a>  <a href=""></a></p>
<h3 id="-permalink-re-garbage-first-re-garbage-first-2013-03-04-23-52-http-www-helemao-com-"><a href="&quot;permalink: re: Garbage First介绍&quot;">/#</a> <a href=""></a>re: Garbage First介绍<a href=""></a>  2013-03-04 23:52  <a href="http://www.helemao.com/" target="_blank">呵乐猫</a></h3>
<p>学习了。  <a href="">回复</a>  <a href="http://www.blogjava.net/comment?author=%e5%91%b5%e4%b9%90%e7%8c%ab" title="查看该作者发表过的评论" target="_blank">更多评论</a> <a href=""></a>  <a href=""></a>
<a href="http://www.blogjava.net/RequireRegister.aspx" target="_blank">新用户注册</a>  <a href="">刷新评论列表</a>  </p>
<p><a href=""></a> <a href="http://www.aliyun.com/cps/channel?channel_id=1306&amp;user=0&amp;lv=1">推荐购买云服务器（15%返利+最高千元奖金）</a>   <a href="http://www.cnblogs.com/" target="_blank">博客园</a>  <a href="http://q.cnblogs.com/" target="_blank">博问</a>  <a href="http://news.cnblogs.com/" target="_blank">IT新闻</a>  <a href="http://job.cnblogs.com/cate-java_programmer/" target="_blank">Java程序员招聘</a> 标题  请输入标题 姓名  请输入你的姓名 主页 请输入验证码 验证码 /*  <img src="http://www.blogjava.net/Modules/CaptchaImage/JpegImage.aspx?cacheid=20130727130737" alt=""> 内容(请不要发表任何与政治相关的内容) 请输入评论内容 Remember Me?   <a href="http://www.blogjava.net/login.aspx?ReturnURL=http://www.blogjava.net/BlueDavy/archive/2009/03/11/259230.html&amp;SourceURL=/BlueDavy/archive/2009/03/11/259230.html" target="_blank">登录</a>       [使用Ctrl+Enter键可以直接提交]      网站导航:</p>
<p><a href="http://www.cnblogs.com/" title="程序员的网上家园" target="_blank">博客园</a>   <a href="http://news.cnblogs.com/" target="_blank">IT新闻</a>   <a href="http://kb.cnblogs.com/" target="_blank">知识库</a>   <a href="http://www.cppblog.com/" target="_blank">C++博客</a>   <a href="http://job.cnblogs.com/" target="_blank">程序员招聘</a>   <a href="http://www.blogjava.net/BlueDavy/archive/2009/03/11/259230.html?opt=admin" target="_blank">管理</a> 相关文章:</p>
<ul>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2010/05/25/321796.html" target="_blank">关于《分布式Java应用：基础与实践》一书</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2010/04/30/319794.html" target="_blank">杭州程序员圆桌交流第二期视频</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2010/03/22/316148.html" target="_blank">第一次杭州程序员交流会总结</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2010/03/19/315989.html" target="_blank">杭州程序员圆桌交流第一期–并发编程PPT</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/12/03/304597.html" target="_blank">GCLogViewer(tool to visualize gc log) V0.2 Release</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/11/25/303662.html" target="_blank">Simple Scala actor Vs java Thread Vs Kilim Test</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/11/06/301448.html" target="_blank">《构建高性能的大型分布式Java应用》目录&amp;试读样章</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/10/10/297661.html" target="_blank">动态跟踪Java代码的执行状况工具--BTrace</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/10/09/297562.html" target="_blank">GC策略的调优</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/08/06/290003.html" target="_blank">Hessian 3.2.0的两个bug</a><br>Powered by: <a href="http://www.blogjava.net/" target="_blank">BlogJava</a> Copyright © BlueDavy<h3 id="-">公告</h3>
</li>
</ul>
<p><a href="http://www.douban.com/subject/3843896/" target="_blank"><img src="" alt=""></a> 
<a href="http://china.osgiusers.org/" target="_blank"><img src="" alt=""></a>
<a href="http://feed.feedsky.com/bluedavy" title="BlogJava-BlueDavy之技术Blog" target="_blank"><img src="" alt=""></a> <a href="http://feed.feedsky.com/bluedavy" target="_blank"><img src="" alt="feedsky"></a>
<a href="http://www.zhuaxia.com/add_channel.php?url=http://feed.feedsky.com/bluedavy" target="_blank"><img src="" alt="抓虾"></a>
<a href="http://fusion.google.com/add?feedurl=http://feed.feedsky.com/bluedavy" target="_blank"><img src="" alt="google reader"></a>
<a href="http://www.xianguo.com/subscribe.php?url=http://feed.feedsky.com/bluedavy" target="_blank"><img src="" alt="鲜果"></a></p>
<h3 id="-">导航</h3>
<ul>
<li><a href="http://www.blogjava.net/" target="_blank">BlogJava</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/" target="_blank">首页</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/admin/EditPosts.aspx?opt=1" target="_blank">新随笔</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/contact.aspx?id=1" target="_blank">联系</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/rss" target="_blank">聚合</a><a href="http://www.blogjava.net/BlueDavy/rss" target="_blank"><img src="" alt=""></a></li>
<li><a href="http://www.blogjava.net/BlueDavy/admin/EditPosts.aspx" target="_blank">管理</a>
<a href="&quot;转到上一个月&quot;">&lt;</a>2009年3月<a href="&quot;转到下一个月&quot;">&gt;</a>日一二三四五六222324252627281234<a href="http://www.blogjava.net/BlueDavy/archive/2009/03/05.html" target="_blank">5</a><a href="http://www.blogjava.net/BlueDavy/archive/2009/03/06.html" target="_blank">6</a>78910<a href="http://www.blogjava.net/BlueDavy/archive/2009/03/11.html" target="_blank">11</a><a href="http://www.blogjava.net/BlueDavy/archive/2009/03/12.html" target="_blank">12</a>1314151617181920212223242526<a href="http://www.blogjava.net/BlueDavy/archive/2009/03/27.html" target="_blank">27</a>282930311234</li>
</ul>
<h3 id="-">统计</h3>
<ul>
<li>随笔 - 294</li>
<li>文章 - 2</li>
<li>评论 - 2068</li>
<li>引用 - 1</li>
</ul>
<h3 id="-">随笔分类</h3>
<ul>
<li><a href="http://www.blogjava.net/BlueDavy/category/10609.html" target="_blank">@RIAWork(10)</a> <a href="http://www.blogjava.net/BlueDavy/category/10609.html/rss" title="Subscribe to @RIAWork(10)" target="_blank">(rss)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/category/32839.html" target="_blank">Internet(20)</a> <a href="http://www.blogjava.net/BlueDavy/category/32839.html/rss" title="Subscribe to Internet(20)" target="_blank">(rss)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/category/1366.html" target="_blank">Java(82)</a> <a href="http://www.blogjava.net/BlueDavy/category/1366.html/rss" title="Subscribe to Java(82)" target="_blank">(rss)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/category/8127.html" target="_blank">Javascript(7)</a> <a href="http://www.blogjava.net/BlueDavy/category/8127.html/rss" title="Subscribe to Javascript(7)" target="_blank">(rss)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/category/18356.html" target="_blank">OSGi、SOA、SCA(81)</a> <a href="http://www.blogjava.net/BlueDavy/category/18356.html/rss" title="Subscribe to OSGi、SOA、SCA(81)" target="_blank">(rss)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/category/1514.html" target="_blank">Plugin Architecture(10)</a> <a href="http://www.blogjava.net/BlueDavy/category/1514.html/rss" title="Subscribe to Plugin Architecture(10)" target="_blank">(rss)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/category/1513.html" target="_blank">Workflow(4)</a> <a href="http://www.blogjava.net/BlueDavy/category/1513.html/rss" title="Subscribe to Workflow(4)" target="_blank">(rss)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/category/11559.html" target="_blank">业界随想(28)</a> <a href="http://www.blogjava.net/BlueDavy/category/11559.html/rss" title="Subscribe to 业界随想(28)" target="_blank">(rss)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/category/22527.html" target="_blank">数据集成(8)</a> <a href="http://www.blogjava.net/BlueDavy/category/22527.html/rss" title="Subscribe to 数据集成(8)" target="_blank">(rss)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/category/1911.html" target="_blank">系统设计(38)</a> <a href="http://www.blogjava.net/BlueDavy/category/1911.html/rss" title="Subscribe to 系统设计(38)" target="_blank">(rss)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/category/1367.html" target="_blank">软件工程(22)</a> <a href="http://www.blogjava.net/BlueDavy/category/1367.html/rss" title="Subscribe to 软件工程(22)" target="_blank">(rss)</a></li>
</ul>
<h3 id="-">随笔档案</h3>
<ul>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2010/05.html" target="_blank">2010年5月 (3)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2010/04.html" target="_blank">2010年4月 (4)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2010/03.html" target="_blank">2010年3月 (3)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2010/02.html" target="_blank">2010年2月 (1)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2010/01.html" target="_blank">2010年1月 (2)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/12.html" target="_blank">2009年12月 (1)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/11.html" target="_blank">2009年11月 (3)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/10.html" target="_blank">2009年10月 (2)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/09.html" target="_blank">2009年9月 (2)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/08.html" target="_blank">2009年8月 (2)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/07.html" target="_blank">2009年7月 (3)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/06.html" target="_blank">2009年6月 (1)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/05.html" target="_blank">2009年5月 (4)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/04.html" target="_blank">2009年4月 (5)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/03.html" target="_blank">2009年3月 (5)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/01.html" target="_blank">2009年1月 (1)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2008/11.html" target="_blank">2008年11月 (3)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2008/10.html" target="_blank">2008年10月 (1)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2008/09.html" target="_blank">2008年9月 (2)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2008/08.html" target="_blank">2008年8月 (1)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2008/07.html" target="_blank">2008年7月 (4)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2008/06.html" target="_blank">2008年6月 (4)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2008/05.html" target="_blank">2008年5月 (3)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2008/04.html" target="_blank">2008年4月 (1)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2008/03.html" target="_blank">2008年3月 (3)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2008/02.html" target="_blank">2008年2月 (1)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2008/01.html" target="_blank">2008年1月 (10)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2007/12.html" target="_blank">2007年12月 (2)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2007/11.html" target="_blank">2007年11月 (2)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2007/10.html" target="_blank">2007年10月 (6)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2007/09.html" target="_blank">2007年9月 (2)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2007/08.html" target="_blank">2007年8月 (4)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2007/07.html" target="_blank">2007年7月 (5)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2007/06.html" target="_blank">2007年6月 (2)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2007/05.html" target="_blank">2007年5月 (4)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2007/04.html" target="_blank">2007年4月 (2)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2007/03.html" target="_blank">2007年3月 (2)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2007/02.html" target="_blank">2007年2月 (2)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2007/01.html" target="_blank">2007年1月 (1)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/12.html" target="_blank">2006年12月 (6)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/11.html" target="_blank">2006年11月 (5)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/10.html" target="_blank">2006年10月 (8)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/09.html" target="_blank">2006年9月 (13)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/08.html" target="_blank">2006年8月 (15)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/07.html" target="_blank">2006年7月 (3)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/06.html" target="_blank">2006年6月 (7)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/05.html" target="_blank">2006年5月 (9)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/04.html" target="_blank">2006年4月 (12)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/03.html" target="_blank">2006年3月 (13)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/02.html" target="_blank">2006年2月 (9)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/01.html" target="_blank">2006年1月 (14)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2005/12.html" target="_blank">2005年12月 (11)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2005/11.html" target="_blank">2005年11月 (14)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2005/10.html" target="_blank">2005年10月 (9)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2005/09.html" target="_blank">2005年9月 (10)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2005/08.html" target="_blank">2005年8月 (5)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2005/07.html" target="_blank">2005年7月 (9)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2005/06.html" target="_blank">2005年6月 (9)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2005/05.html" target="_blank">2005年5月 (2)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2005/02.html" target="_blank">2005年2月 (1)</a></li>
</ul>
<h3 id="-">文章档案</h3>
<ul>
<li><a href="http://www.blogjava.net/BlueDavy/archives/2005/05.html" target="_blank">2005年5月 (2)</a></li>
</ul>
<h3 id="blogger-s">Blogger&#39;s</h3>
<ul>
<li><a href="http://www.dbanotes.net/" target="_blank">DBANotes</a></li>
<li>大名鼎鼎了，勿需多说</li>
<li><a href="http://www.esbzone.net/" target="_blank">ESBZone</a> <a href="http://www.esbzone.net/feed" title="Subscribe to ESBZone" target="_blank">(rss)</a></li>
<li>SOA实战者，强烈推荐</li>
<li><a href="http://kenwublog.com/" target="_blank">kenwu&#39;s blog[推荐]</a> <a href="http://feed.kenwublog.com/" title="Subscribe to kenwu&#39;s blog[推荐]" target="_blank">(rss)</a></li>
<li>Java底层和JVM的很多文章，强烈推荐。</li>
<li><a href="http://dreamhead.blogbus.com/" target="_blank">梦想风暴</a></li>
<li><a href="http://www.blogjava.net/cenwenchu/" target="_blank">西湖边的穷秀才</a></li>
</ul>
<h3 id="-">搜索</h3>
<p>*</p>
<ul>
<li></li>
</ul>
<h3 id="-http-www-blogjava-net-bluedavy-commentsrss-aspx-">最新评论 <a href="http://www.blogjava.net/BlueDavy/CommentsRSS.aspx" target="_blank"><img src="" alt=""></a></h3>
<ul>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2013/07/19/321796.html#401750" target="_blank">1. re: 关于《分布式Java应用：基础与实践》一书</a></li>
<li>博主 大神啊 这个博客很久没有更新了</li>
<li>--1836567962@qq.com</li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2013/07/11/267970.html#401444" target="_blank">2. re: 网站架构相关PPT、文章整理（更新于2009-7-15）</a></li>
<li>这个文章很有用，收藏</li>
<li>--度哥网</li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2013/05/28/267968.html#399877" target="_blank">3. re: OSGi Opendoc &amp; Book</a></li>
<li>评论内容较长,点击标题查看</li>
<li>--stono</li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2013/05/28/267968.html#399865" target="_blank">4. re: OSGi Opendoc &amp; Book</a></li>
<li>我再看《OSGi》原理与最佳实践，可是源码没有办法下载呀；
有没有什么办法呢？</li>
<li>--stono</li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2013/05/27/321796.html#399801" target="_blank">5. re: 关于《分布式Java应用：基础与实践》一书</a></li>
<li>在这篇blog中放置了我收集的一些网站架构相关的PPT和文章</li>
<li>--色都</li>
</ul>
<h3 id="-">阅读排行榜</h3>
<ul>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2008/09/03/226749.html" target="_blank">1. 大型网站架构演变和知识体系(57638)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/04/28/267970.html" target="_blank">2. 网站架构相关PPT、文章整理（更新于2009-7-15）(38732)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/03/27/37582.html" target="_blank">3. Hibernate实践(31780)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2005/06/13/6037.html" target="_blank">4. 系统设计说明书(架构、概要、详细)目录结构(24258)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/08/25/65741.html" target="_blank">5. 发布《OSGi实战》正式版(17725)</a></li>
</ul>
<h3 id="-">评论排行榜</h3>
<ul>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2008/09/03/226749.html" target="_blank">1. 大型网站架构演变和知识体系(96)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2005/09/07/12340.html" target="_blank">2. 漫谈CMS(88)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/04/28/267970.html" target="_blank">3. 网站架构相关PPT、文章整理（更新于2009-7-15）(66)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2007/09/29/149631.html" target="_blank">4. 《OSGi进阶》预览版发布(59)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/08/25/65741.html" target="_blank">5. 发布《OSGi实战》正式版(54)</a></li>
</ul>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/JVM/">JVM</a></li></span></span> | <span class="tags">Tagged <a href="/tags/JVM/" class="label label-primary">JVM</a><a href="/tags/Java&J2EE/" class="label label-success">Java&J2EE</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:42"datetime="2014-03-07 09:54:42"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-JVM--GarbageFirst介绍/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-JVM--GarbageFirst介绍" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE--Java字节码工具ASM在WebService开发中的应用/">Java字节码工具ASM在Web Service开发中的应用</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:42.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE--Java字节码工具ASM在WebService开发中的应用/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="java-asm-web-service-">Java字节码工具ASM在Web Service开发中的应用</h1>
<p>在基于 JAX-WS 标准的 web services 的开发中，不少实际场景都是希望采用自底向上的开发方式， 即基于已有的 Java bean 来创建 web services 。WebSphere Application Server ( 以下简称 WAS ) 提供了命令行的工具 wsgen 和相对应的 Ant task 来支持这种开发过程，而且这两个工具比较适合大型项目的自动化构建。 这两个工具的使用前提是 Java bean 中事先添加有 web services 的 Annotation 标注，而在现有的业务系统中，class 文件一般是不带 Annotation 的，这就需要开发人员去修改现有的代码，以手工方式添加 Annotation，但这样带来的工作量太大且容易出错。本文介绍了一种解决途径，可以不用修改源代码，而是利用字节码工具 ASM 直接修改 class 文件， 在字节码文件中自动注入 Annotation ，然后再利用 wsgen 工具就可以很方便地生成 web services 应用。 本文同时也总结了使用 ASM 的一些实践。</p>
<p>本文首先介绍了和 ASM 使用相关的四种文件，以及它们之间的相互转化。然后结合 web services 开发实例，介绍了使用 wsgen 开发时遇到的实际问题，如何写一个 ASM 的适配器去修改现有 class，最终如何产生 web services 文件。</p>
<p>ASM 是一个多用途的 Java 字节码操控和分析框架。它能以二进制的形式直接修改现有的类或动态生成的类。 ASM 提供了常用的转换和分析算法，是一种允许用户方便的组装定制化的复杂转换和代码分析工具。 ASM 也提供和其它的字节码工具类似的功能，但 ASM 的重点是使用的简单和高性能。由于 ASM 在设计实现的时候尽可能 的小的内存占用和提供更高的性能；因此在动态系统中使用 ASM 是很有优势的。ASM 作为一种轻量级、高性能的 Java 字节码操控和分析框架，设计了一种更有效的方法、提供更好的性能和内存占用。今天， ASM 在许多领域都有应用，并已成为事实上的字节码处理框架标准。</p>
<p><a href="">问题的引入</a></p>
<p>先写一个不带 web services 标注的 SayHelloImpl 类。
<a href=""><strong>清单 1. 不带 web services 的 SayHelloImpl 类</strong></a>1</p>
<p>public</p>
<p>class</p>
<p>SayHelloImpl {</p>
<p>2</p>
<p>public</p>
<p>String sayHello(String s) {
3</p>
<p>return</p>
<p>“Hello: ” + s ;</p>
<p>4</p>
<p>}
5</p>
<p>}</p>
<p>再用 wsgen 来创建 web services，wsgen 的使用如下：
<a href=""><strong>清单 2. wsgen 实例</strong></a>1</p>
<p>wsgen.exe – </p>
<p>cp</p>
<p>bin – s output – d output – r output – wsdl ibm.was.asm.SayHelloImpl我们将会遇到如下错误： 
<a href=""><strong>清单 3. 根据不带 web services 标注的类创建 web services 时遇到的错误信息</strong></a> 
注释处理过程中遇到问题；</p>
<p>......
com.sun.tools.internal.ws.processor.modeler.ModelerException: [failed to localiz</p>
<p>e] A web service endpoint could not be found()
        at com.sun.tools.internal.ws.processor.modeler.annotation.WebServiceAP.o</p>
<p>nError(WebServiceAP.java:215)
        at com.sun.tools.internal.ws.processor.modeler.annotation.WebServiceAP.b</p>
<p>uildModel(WebServiceAP.java:322)
        at com.sun.tools.internal.ws.processor.modeler.annotation.WebServiceAP.p</p>
<p>rocess(WebServiceAP.java:256)
        at com.sun.mirror.apt.AnnotationProcessors$CompositeAnnotationProcessor.</p>
<p>process(AnnotationProcessors.java:60)</p>
<p>注意：我们通常是在 class 前使用 @WebService， 在方法前使用 @WebMethod 来将一个类标注为 web services 的。WAS 6.1 的 web services 功能部件包和 WAS 7 都支持基于 JAX-WS 标准 的 web services 的开发， 在 WAS 安装目录的 bin 目录下提供了命令行工具 wsgen，wsgen 支持自底向上的开发方式。 下面是 wsgen 的用法：
<a href=""><strong>清单 4. wsgen 命令格式</strong></a> 
注 wsgen [options]  [SEI]</p>
<p>主要选项：</p>
<ul>
<li>-d 指定生成的 class 文件位置；</li>
<li>-s 指定生成的 Java 源文件位置；</li>
<li>-r 指定生成的 resources 文件位置，如 wsdl，xsd；</li>
<li>-cp 指定服务实现类所在的位置；</li>
<li>-wsdl，-servicename，-portname 三个参数指定生成的 wsdl 文件中的 service 和 port 的名称。</li>
</ul>
<p>SEI(Service Endpoint Interface) 是一个 endpoint implementation class，不能是一个 interface。所以首先要开发一个 endpoint 的实现类，如本例中的 SayHelloImpl 。用 @WebService 声明 web services ，然后将它编译，才能提供给 wsgen 来创建 web services 。</p>
<p><a href="">四种文件之间的转换</a></p>
<p>下面介绍本文要用到的四个概念（Java Source，Java Class，ASM Code，ASM Source）</p>
<ul>
<li>Java Source: 即我们通常编写的 Java 源文件；</li>
<li>Java Class: Java 源文件编译后的字节码文件；</li>
<li>ASM Source : 类似于对 class 反编译后的源文件，也就是 &quot;textual byte code&quot;，但比原始的 Java Source 可读性要差， 参见清单 5。</li>
<li>ASM Code: 指读写 class 文件的 ASM 程序代码。需要用到 ASM 提供的 API， 参见清单 6。
<a href=""><strong>清单 5. SayHelloImpl 类对应的 ASM Source</strong></a>01</li>
</ul>
<p>// class version 50.0 (50)</p>
<p>02</p>
<p>// access flags 33
03</p>
<p>public</p>
<p>class</p>
<p>com/ibm/was/asm/SayHelloImpl {</p>
<p>04</p>
<p>05</p>
<p>// access flags 1</p>
<p>06</p>
<p>public</p>
<p><init>()V
07</p>
<p>ALOAD </p>
<p>0</p>
<p>08</p>
<p>INVOKESPECIAL java/lang/Object. <init> ()V
09</p>
<p>RETURN</p>
<p>10</p>
<p>MAXSTACK = </p>
<p>1
11</p>
<p>MAXLOCALS = </p>
<p>1</p>
<p>12</p>
<p>13</p>
<p>// access flags 1</p>
<p>14</p>
<p>public</p>
<p>sayHello(Ljava/lang/String;)Ljava/lang/String;
15</p>
<p>NEW java/lang/StringBuilder</p>
<p>16</p>
<p>DUP
17</p>
<p>LDC </p>
<p>&quot;Hello:&quot;</p>
<p>18</p>
<p>INVOKESPECIAL java/lang/StringBuilder. <init> (Ljava/lang/String;)V
19</p>
<p>ALOAD </p>
<p>1</p>
<p>20</p>
<p>INVOKEVIRTUAL java/lang/StringBuilder.append (Ljava/lang/String;)
21</p>
<p>Ljava/lang/StringBuilder;</p>
<p>22</p>
<p>INVOKEVIRTUAL java/lang/StringBuilder.toString ()Ljava/lang/String;
23</p>
<p>ARETURN</p>
<p>24</p>
<p>MAXSTACK = </p>
<p>3
25</p>
<p>MAXLOCALS = </p>
<p>2</p>
<p>26</p>
<p>}<a href=""><strong>清单 6. 生成 SayHelloImpl.class 的 ASM Code</strong></a><a href="http://www.oschina.net/question/129540_28430#viewSource" title="view source" target="_blank">view source</a><a href="http://www.oschina.net/question/129540_28430#printSource" title="print" target="_blank">print</a><a href="http://www.oschina.net/question/129540_28430#about" title="?" target="_blank">?</a></p>
<p>01</p>
<p>package</p>
<p>asm.com.ibm.was.asm;</p>
<p>02</p>
<p>import</p>
<p>java.util./*;
03</p>
<p>import</p>
<p>org.objectweb.asm./*;</p>
<p>04</p>
<p>import</p>
<p>org.objectweb.asm.attrs./*;
05</p>
<p>public</p>
<p>class</p>
<p>SayHelloImplDump </p>
<p>implements</p>
<p>Opcodes {</p>
<p>06</p>
<p>public</p>
<p>static</p>
<p>byte</p>
<p>[] dump () </p>
<p>throws</p>
<p>Exception {
07</p>
<p>ClassWriter cw = </p>
<p>new</p>
<p>ClassWriter(</p>
<p>0</p>
<p>);</p>
<p>08</p>
<p>FieldVisitor fv;
09</p>
<p>MethodVisitor mv;</p>
<p>10</p>
<p>AnnotationVisitor av0;
11</p>
<p>12</p>
<p>cw.visit(V1_6, ACC_PUBLIC + ACC_SUPER, </p>
<p>&quot;com/ibm/was/asm/SayHelloImpl&quot;</p>
<p>,
13</p>
<p>null</p>
<p>, </p>
<p>&quot;java/lang/Object&quot;</p>
<p>, </p>
<p>null</p>
<p>);</p>
<p>14</p>
<p>15</p>
<p>{</p>
<p>16</p>
<p>mv = cw.visitMethod(ACC_PUBLIC, </p>
<p>&quot;<init>&quot;</p>
<p>, </p>
<p>&quot;()V&quot;</p>
<p>, </p>
<p>null</p>
<p>, </p>
<p>null</p>
<p>);
17</p>
<p>mv.visitCode();</p>
<p>18</p>
<p>mv.visitVarInsn(ALOAD, </p>
<p>0</p>
<p>);
19</p>
<p>mv.visitMethodInsn(INVOKESPECIAL, </p>
<p>&quot;java/lang/Object&quot;</p>
<p>, </p>
<p>&quot;<init>&quot;</p>
<p>, </p>
<p>&quot;()V&quot;</p>
<p>);</p>
<p>20</p>
<p>mv.visitInsn(RETURN);
21</p>
<p>mv.visitMaxs(</p>
<p>1</p>
<p>, </p>
<p>1</p>
<p>);</p>
<p>22</p>
<p>mv.visitEnd();
23</p>
<p>}</p>
<p>24</p>
<p>{
25</p>
<p>mv = cw.visitMethod(ACC_PUBLIC, </p>
<p>&quot;sayHello&quot;</p>
<p>,</p>
<p>26</p>
<p>&quot;(Ljava/lang/String;)Ljava/lang/String;&quot;</p>
<p>, </p>
<p>null</p>
<p>, </p>
<p>null</p>
<p>);
27</p>
<p>mv.visitCode();</p>
<p>28</p>
<p>mv.visitTypeInsn(NEW, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>);
29</p>
<p>mv.visitInsn(DUP);</p>
<p>30</p>
<p>mv.visitLdcInsn(</p>
<p>&quot;Hello:&quot;</p>
<p>);
31</p>
<p>mv.visitMethodInsn(INVOKESPECIAL, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>,</p>
<p>32</p>
<p>&quot;<init>&quot;</p>
<p>, </p>
<p>&quot;(Ljava/lang/String;)V&quot;</p>
<p>);
33</p>
<p>mv.visitVarInsn(ALOAD, </p>
<p>1</p>
<p>);</p>
<p>34</p>
<p>mv.visitMethodInsn(INVOKEVIRTUAL, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>,
35</p>
<p>&quot;append&quot;</p>
<p>, </p>
<p>&quot;(Ljava/lang/String;)Ljava/lang/StringBuilder;&quot;</p>
<p>);</p>
<p>36</p>
<p>mv.visitMethodInsn(INVOKEVIRTUAL, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>,
37</p>
<p>&quot;toString&quot;</p>
<p>, </p>
<p>&quot;()Ljava/lang/String;&quot;</p>
<p>);</p>
<p>38</p>
<p>mv.visitInsn(ARETURN);
39</p>
<p>mv.visitMaxs(</p>
<p>3</p>
<p>, </p>
<p>2</p>
<p>);</p>
<p>40</p>
<p>mv.visitEnd();
41</p>
<p>}</p>
<p>42</p>
<p>cw.visitEnd();
43</p>
<p>return</p>
<p>cw.toByteArray();</p>
<p>44</p>
<p>}
45</p>
<p>}</p>
<p>图 1 描述了 Java Source 文件、Java Class 文件、ASM Code 文件和 ASM Source 文件之间的转换关系。
<a href=""><strong>图 1. 四种文件的转换图</strong></a> 
<a href="http://static.oschina.net/uploads/img/201109/26204312_QD65.jpg" target="_blank"><img src="" alt="图 1. 四种文件的转换图"></a> </p>
<p>如图 -1 所示，Java Source 文件通过 Javac 可以转换为 Java Class 文件。而相应的 Java Class 文件通过 Java 反编译器工具可转换为 Java Source 文件；</p>
<p>通 过 ASM Code 去创建和修改 Java Class 需要对 ASM API 比较熟悉才行，一个常见的问题时，怎么用 ASM Code 生成一个我们希望的 class 文件， 也就是说， 给定了 Java Class， 怎么得到其对应的 ASM Code 呢？ 所幸的是， ASM 框架为我们提供了 ASMifierClassVisitor 工具来产生 Java Class 对应的 ASM Code。代码如下：
<a href=""><strong>清单 7. 给定 class 文件，通过 ASMifierClassVisitor 获得其对应的 ASM Code</strong></a>01</p>
<p>public</p>
<p>void</p>
<p>showClassASMProcess() {</p>
<p>02</p>
<p>ClassReader cr;
03</p>
<p>final</p>
<p>String n = SayHelloImpl.</p>
<p>class</p>
<p>.getName();</p>
<p>04</p>
<p>05</p>
<p>try</p>
<p>{</p>
<p>06</p>
<p>cr = </p>
<p>new</p>
<p>ClassReader(n);<br>07</p>
<p>cr.accept(</p>
<p>new</p>
<p>ASMifierClassVisitor(</p>
<p>new</p>
<p>PrintWriter(System.out)),</p>
<p>08</p>
<p>new</p>
<p>Attribute[</p>
<p>0</p>
<p>],
09</p>
<p>ClassReader.SKIP_DEBUG);</p>
<p>10</p>
<p>11</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {</p>
<p>12</p>
<p>e.printStackTrace();
13</p>
<p>}</p>
<p>14</p>
<p>}</p>
<p>另外一个重要的转换就是， 给定了 Java Class 文件， 如何查看它的 ASM Source ？ 这点对于我们验证 ASM Code 生成的 class 是否正确很有用。ASM 提供了另外一个工具 TraceClassVisitor， 来获得一个 Java Class 对应的 ASM Source。代码如下：
<a href=""><strong>清单 8. 利用 TraceClassVisitor 查看 class 文件的 ASM Source</strong></a>01</p>
<p>//file 是 class 文件的全路径名</p>
<p>02</p>
<p>public</p>
<p>void</p>
<p>showClassSource(String file) {
03</p>
<p>FileInputStream is ;</p>
<p>04</p>
<p>ClassReader cr; 
05</p>
<p>06</p>
<p>try</p>
<p>{
07</p>
<p>is = </p>
<p>new</p>
<p>FileInputStream(file);     </p>
<p>08</p>
<p>cr = </p>
<p>new</p>
<p>ClassReader(is);
09</p>
<p>TraceClassVisitor trace = </p>
<p>new</p>
<p>TraceClassVisitor(</p>
<p>new</p>
<p>PrintWriter(System.out));</p>
<p>10</p>
<p>cr.accept(trace, ClassReader.SKIP_DEBUG);
11</p>
<p>12</p>
<p>is.close() ;
13</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {</p>
<p>14</p>
<p>e.printStackTrace() ;
15</p>
<p>}</p>
<p>16</p>
<p>}
17</p>
<p>{</p>
<p>18</p>
<p>e.printStackTrace();
19</p>
<p>}</p>
<p>20</p>
<p>}</p>
<p><a href="">ASM 类注入</a></p>
<p>ASM 类注入是指修改一个现有的 class 文件，在其中加入自己的代码。按通常思维，我们需要利用 ASM 提供的 reader 类去读取所要修改的类文件， 找到要修改的地方，如方法名或属性名，然后在该处插入自己的代码或修改现有的代码，这种思路将使问题复杂化。 ASM 为我们提供了访问类文件的 Visitor 模式，来遍历一个 class 文件，Visitor 是一个实现 ClassVisitor 接口的类。 要注入一个 class 文件，先要找到一个合适的 Visitor 做向导， ASM 提供了好几种 Visitor， 最常用的是 ClassWriter。同时我们需要提供一个适配器类 ClassAdapter， Visitor 会带着这个 Adapter 一起去遍历， 然后在遍历过程中回调 Adapter 提供的方法。我们在 Adapter 的这些方法中就可以实现我们的修改和定制逻辑。当然，如果你不想做任何修改，那 Visitor 遍历完后将得到一个和被遍历的 class 完全一样的拷贝。
<a href=""><strong>清单 9. 类注入的完整过程</strong></a>01</p>
<p>public</p>
<p>void</p>
<p>addAnnotationToExistingClass() {</p>
<p>02</p>
<p>FileInputStream is ;
03</p>
<p>ClassReader cr;          </p>
<p>04</p>
<p>try</p>
<p>{<br>05</p>
<p>String classfile = </p>
<p>&quot;E:\SayHelloImpl.class&quot;</p>
<p>; </p>
<p>// 待遍历的类</p>
<p>06</p>
<p>showClassSource(classfile) ;  </p>
<p>// 打印该类的 ASM source
07</p>
<p>08</p>
<p>is = </p>
<p>new</p>
<p>FileInputStream(classfile);<br>09</p>
<p>cr = </p>
<p>new</p>
<p>ClassReader(is);</p>
<p>10</p>
<p>// 此处我们使用 ClassWriter 做 Visitor
11</p>
<p>ClassWriter cw = </p>
<p>new</p>
<p>ClassWriter(ClassWriter.COMPUTE_MAXS);</p>
<p>12</p>
<p>// 给 Visitor 提供一个 Adapter
13</p>
<p>AddAnnotationAdapter adapter = </p>
<p>new</p>
<p>AddAnnotationAdapter(cw);           </p>
<p>14</p>
<p>cr.accept(adapter, ClassReader.SKIP_DEBUG);<br>15</p>
<p>16</p>
<p>// 遍历完后，生成的 class 保存在字节数组中
17</p>
<p>byte</p>
<p>[] b = cw.toByteArray();</p>
<p>18</p>
<p>19</p>
<p>try</p>
<p>{</p>
<p>20</p>
<p>// 将字节数组输出到文件中
21</p>
<p>// 为了不至于覆盖掉原有的 SayHelloImpl.class 文件，我们将结果输出到 _SayHelloImpl.class</p>
<p>22</p>
<p>FileOutputStream fout = </p>
<p>new</p>
<p>FileOutputStream(</p>
<p>&quot;E:\_SayHelloImpl.class&quot;</p>
<p>);
23</p>
<p>fout.write(b) ;</p>
<p>24</p>
<p>fout.flush();
25</p>
<p>fout.close() ;</p>
<p>26</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {
27</p>
<p>e.printStackTrace() ;</p>
<p>28</p>
<p>}
29</p>
<p>30</p>
<p>// 验证 _SayHelloImpl.class 是否包含我们注入的代码
31</p>
<p>showClassSource(</p>
<p>&quot;E:\_SayHelloImpl.class&quot;</p>
<p>) ;</p>
<p>32</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {
33</p>
<p>e.printStackTrace();</p>
<p>34</p>
<p>} 
35</p>
<p>}</p>
<p><a href="">web services 标记注入过程</a></p>
<p>我们已经知道了如何往 class 中注入自己的代码，那对于一个已有的 Java bean，怎么往里注入 @WebService 和 @WebMethod 呢？根据上面我们讲的转换关系，我们可以先写一个带 annotation 的 Java Source，编译得到 Java Class， 再得到其 ASM Code。下面是利用 ASM 给一个不带任何 Annotation 的 class 添加 @WebService 和 @WebMethod 的步骤。</p>
<ol>
<li>首先在 SayHelloImpl.java 中添加 @WebService 和 @WebMethod： 
<a href=""><strong>清单 10. 带 web services 标注的 SayHelloImpl 类</strong></a>1</li>
</ol>
<p>@WebService</p>
<p>2</p>
<p>public</p>
<p>class</p>
<p>SayHelloImpl {
3</p>
<p>@WebMethod</p>
<p>4</p>
<p>public</p>
<p>String sayHello(String s) {
5</p>
<p>return</p>
<p>&quot;Hello: &quot;</p>
<ul>
<li>s ;</li>
</ul>
<p>6</p>
<p>}
7</p>
<p>}</p>
<ol>
<li>通过 ASMifierClassVisitor 工具获得 SayHelloImpl class 的 ASM Code，见清单 6。</li>
<li>写一个 ClassAdapter 类， ClassAdapter 其实也是一个 Visitor。根据 ASM Code 的提示， 我们就可以知道如何利用 ASM API 去获得我们希望的 class 文件。下面是 Adapter 的示例代码。 
<a href=""><strong>清单 11. 添加 Annotation 的 Adapter 类</strong></a>01</li>
</ol>
<p>public</p>
<p>class</p>
<p>AddAnnotationAdapter </p>
<p>extends</p>
<p>ClassAdapter </p>
<p>implements</p>
<p>Opcodes{</p>
<p>02</p>
<p>//private String annotationDesc;
03</p>
<p>private</p>
<p>boolean</p>
<p>isAnnotationPresent;</p>
<p>04</p>
<p>05</p>
<p>public</p>
<p>AddAnnotationAdapter(ClassVisitor cv) {</p>
<p>06</p>
<p>super</p>
<p>(cv);
07</p>
<p>}</p>
<p>08</p>
<p>09</p>
<p>@Override</p>
<p>10</p>
<p>public</p>
<p>void</p>
<p>visit(</p>
<p>int</p>
<p>version, </p>
<p>int</p>
<p>access, String name, String signature,
11</p>
<p>String superName, String[] interfaces) {</p>
<p>12</p>
<p>13</p>
<p>cv.visit(V1_6, ACC_PUBLIC + ACC_SUPER, name, signature, superName,</p>
<p>14</p>
<p>interfaces);
15</p>
<p>AnnotationVisitor av0;</p>
<p>16</p>
<p>av0 = cv.visitAnnotation(</p>
<p>&quot;Ljavax/jws/WebService;&quot;</p>
<p>, </p>
<p>true</p>
<p>);
17</p>
<p>av0.visitEnd();</p>
<p>18</p>
<p>}
19</p>
<p>20</p>
<p>@Override
21</p>
<p>public</p>
<p>AnnotationVisitor visitAnnotation(String desc, </p>
<p>boolean</p>
<p>visible) {</p>
<p>22</p>
<p>return</p>
<p>cv.visitAnnotation(desc, visible);
23</p>
<p>}</p>
<p>24</p>
<p>25</p>
<p>@Override</p>
<p>26</p>
<p>public</p>
<p>void</p>
<p>visitInnerClass(String name, String outerName,
27</p>
<p>String innerName, </p>
<p>int</p>
<p>access) {</p>
<p>28</p>
<p>cv.visitInnerClass(name, outerName, innerName, access);
29</p>
<p>}</p>
<p>30</p>
<p>31</p>
<p>@Override</p>
<p>32</p>
<p>public</p>
<p>FieldVisitor visitField(</p>
<p>int</p>
<p>access, String name, String desc,
33</p>
<p>String signature, Object value) {</p>
<p>34</p>
<p>return</p>
<p>cv.visitField(access, name, desc, signature, value);
35</p>
<p>}</p>
<p>36</p>
<p>37</p>
<p>@Override</p>
<p>38</p>
<p>public</p>
<p>MethodVisitor visitMethod(</p>
<p>int</p>
<p>access, String name, String desc,
39</p>
<p>String signature, String[] exceptions) {   </p>
<p>40</p>
<p>MethodVisitor mv  = cv.visitMethod(access, name, desc, signature,
41</p>
<p>exceptions);</p>
<p>42</p>
<p>if</p>
<p>(!name.equals(</p>
<p>&quot;<init>&quot;</p>
<p>)) {
43</p>
<p>AnnotationVisitor av0;</p>
<p>44</p>
<p>av0 = mv.visitAnnotation(</p>
<p>&quot;Ljavax/jws/WebMethod;&quot;</p>
<p>, </p>
<p>true</p>
<p>);
45</p>
<p>av0.visitEnd();</p>
<p>46</p>
<p>}
47</p>
<p>return</p>
<p>mv;</p>
<p>48</p>
<p>}
49</p>
<p>50</p>
<p>@Override
51</p>
<p>public</p>
<p>void</p>
<p>visitEnd() {</p>
<p>52</p>
<p>cv.visitEnd();
53</p>
<p>}</p>
<p>54</p>
<p>55</p>
<p>}</p>
<p>最后，我们采用上面讲的类注入办法，即可得到一个带 @WebService 和 @WebMethod 标注的 class 文件。再通过 wsgen 工具即可成功创建 web services，该命令将会在 src 目录下生成 web services 描述文件：SayHelloImplService.wsdl，SayHelloImplService_schema1.xsd，同时生成了 2 个 JAX-WS 文件，分别为：SayHello.java，SayHelloResponse.java。</p>
<p>当然，在实际应用中，我们可能需要将一个 class 的某些特定方法发布为 web services，这就需要我们对 Adapter 做进一步的改造，在 visitMethod() 方法中根据方法名称等参数做进一步的处理。</p>
<p><a href="">结束语</a></p>
<p>本文简要介绍了 ASM 字节码工具及其在 web services 开发中的应用。web services 的使用已经越来越广泛， 但在改造遗留系统过程中会遇到不少问题，本文针对其中一个主要问题给出了解决办法，该方法无须对现有系统做大量的改动， 即可将现存的 Java bean 转化成 web services 。本文对那些正考虑迁移到 JAX-WS 编程模型上的项目有一定的参考价值。
来源： <a href="[http://www.oschina.net/question/129540_28430](http://www.oschina.net/question/129540_28430)">[http://www.oschina.net/question/129540_28430](http://www.oschina.net/question/129540_28430)</a> </p>
<p>在基于 JAX-WS 标准的 web services 的开发中，不少实际场景都是希望采用自底向上的开发方式， 即基于已有的 Java bean 来创建 web services 。WebSphere Application Server ( 以下简称 WAS ) 提供了命令行的工具 wsgen 和相对应的 Ant task 来支持这种开发过程，而且这两个工具比较适合大型项目的自动化构建。 这两个工具的使用前提是 Java bean 中事先添加有 web services 的 Annotation 标注，而在现有的业务系统中，class 文件一般是不带 Annotation 的，这就需要开发人员去修改现有的代码，以手工方式添加 Annotation，但这样带来的工作量太大且容易出错。本文介绍了一种解决途径，可以不用修改源代码，而是利用字节码工具 ASM 直接修改 class 文件， 在字节码文件中自动注入 Annotation ，然后再利用 wsgen 工具就可以很方便地生成 web services 应用。 本文同时也总结了使用 ASM 的一些实践。</p>
<p>本文首先介绍了和 ASM 使用相关的四种文件，以及它们之间的相互转化。然后结合 web services 开发实例，介绍了使用 wsgen 开发时遇到的实际问题，如何写一个 ASM 的适配器去修改现有 class，最终如何产生 web services 文件。</p>
<p>ASM 是一个多用途的 Java 字节码操控和分析框架。它能以二进制的形式直接修改现有的类或动态生成的类。 ASM 提供了常用的转换和分析算法，是一种允许用户方便的组装定制化的复杂转换和代码分析工具。 ASM 也提供和其它的字节码工具类似的功能，但 ASM 的重点是使用的简单和高性能。由于 ASM 在设计实现的时候尽可能 的小的内存占用和提供更高的性能；因此在动态系统中使用 ASM 是很有优势的。ASM 作为一种轻量级、高性能的 Java 字节码操控和分析框架，设计了一种更有效的方法、提供更好的性能和内存占用。今天， ASM 在许多领域都有应用，并已成为事实上的字节码处理框架标准。</p>
<p><a href="">问题的引入</a></p>
<p>先写一个不带 web services 标注的 SayHelloImpl 类。
<a href=""><strong>清单 1. 不带 web services 的 SayHelloImpl 类</strong></a>1</p>
<p>public</p>
<p>class</p>
<p>SayHelloImpl {</p>
<p>2</p>
<p>public</p>
<p>String sayHello(String s) {
3</p>
<p>return</p>
<p>“Hello: ” + s ;</p>
<p>4</p>
<p>}
5</p>
<p>}</p>
<p>再用 wsgen 来创建 web services，wsgen 的使用如下：
<a href=""><strong>清单 2. wsgen 实例</strong></a>1</p>
<p>wsgen.exe – </p>
<p>cp</p>
<p>bin – s output – d output – r output – wsdl ibm.was.asm.SayHelloImpl我们将会遇到如下错误： 
<a href=""><strong>清单 3. 根据不带 web services 标注的类创建 web services 时遇到的错误信息</strong></a> 
注释处理过程中遇到问题；</p>
<p>......
com.sun.tools.internal.ws.processor.modeler.ModelerException: [failed to localiz</p>
<p>e] A web service endpoint could not be found()
        at com.sun.tools.internal.ws.processor.modeler.annotation.WebServiceAP.o</p>
<p>nError(WebServiceAP.java:215)
        at com.sun.tools.internal.ws.processor.modeler.annotation.WebServiceAP.b</p>
<p>uildModel(WebServiceAP.java:322)
        at com.sun.tools.internal.ws.processor.modeler.annotation.WebServiceAP.p</p>
<p>rocess(WebServiceAP.java:256)
        at com.sun.mirror.apt.AnnotationProcessors$CompositeAnnotationProcessor.</p>
<p>process(AnnotationProcessors.java:60)</p>
<p>注意：我们通常是在 class 前使用 @WebService， 在方法前使用 @WebMethod 来将一个类标注为 web services 的。WAS 6.1 的 web services 功能部件包和 WAS 7 都支持基于 JAX-WS 标准 的 web services 的开发， 在 WAS 安装目录的 bin 目录下提供了命令行工具 wsgen，wsgen 支持自底向上的开发方式。 下面是 wsgen 的用法：
<a href=""><strong>清单 4. wsgen 命令格式</strong></a> 
注 wsgen [options]  [SEI]</p>
<p>主要选项：</p>
<ul>
<li>-d 指定生成的 class 文件位置；</li>
<li>-s 指定生成的 Java 源文件位置；</li>
<li>-r 指定生成的 resources 文件位置，如 wsdl，xsd；</li>
<li>-cp 指定服务实现类所在的位置；</li>
<li>-wsdl，-servicename，-portname 三个参数指定生成的 wsdl 文件中的 service 和 port 的名称。</li>
</ul>
<p>SEI(Service Endpoint Interface) 是一个 endpoint implementation class，不能是一个 interface。所以首先要开发一个 endpoint 的实现类，如本例中的 SayHelloImpl 。用 @WebService 声明 web services ，然后将它编译，才能提供给 wsgen 来创建 web services 。</p>
<p><a href="">四种文件之间的转换</a></p>
<p>下面介绍本文要用到的四个概念（Java Source，Java Class，ASM Code，ASM Source）</p>
<ul>
<li>Java Source: 即我们通常编写的 Java 源文件；</li>
<li>Java Class: Java 源文件编译后的字节码文件；</li>
<li>ASM Source : 类似于对 class 反编译后的源文件，也就是 &quot;textual byte code&quot;，但比原始的 Java Source 可读性要差， 参见清单 5。</li>
<li>ASM Code: 指读写 class 文件的 ASM 程序代码。需要用到 ASM 提供的 API， 参见清单 6。
<a href=""><strong>清单 5. SayHelloImpl 类对应的 ASM Source</strong></a>01</li>
</ul>
<p>// class version 50.0 (50)</p>
<p>02</p>
<p>// access flags 33
03</p>
<p>public</p>
<p>class</p>
<p>com/ibm/was/asm/SayHelloImpl {</p>
<p>04</p>
<p>05</p>
<p>// access flags 1</p>
<p>06</p>
<p>public</p>
<p><init>()V
07</p>
<p>ALOAD </p>
<p>0</p>
<p>08</p>
<p>INVOKESPECIAL java/lang/Object. <init> ()V
09</p>
<p>RETURN</p>
<p>10</p>
<p>MAXSTACK = </p>
<p>1
11</p>
<p>MAXLOCALS = </p>
<p>1</p>
<p>12</p>
<p>13</p>
<p>// access flags 1</p>
<p>14</p>
<p>public</p>
<p>sayHello(Ljava/lang/String;)Ljava/lang/String;
15</p>
<p>NEW java/lang/StringBuilder</p>
<p>16</p>
<p>DUP
17</p>
<p>LDC </p>
<p>&quot;Hello:&quot;</p>
<p>18</p>
<p>INVOKESPECIAL java/lang/StringBuilder. <init> (Ljava/lang/String;)V
19</p>
<p>ALOAD </p>
<p>1</p>
<p>20</p>
<p>INVOKEVIRTUAL java/lang/StringBuilder.append (Ljava/lang/String;)
21</p>
<p>Ljava/lang/StringBuilder;</p>
<p>22</p>
<p>INVOKEVIRTUAL java/lang/StringBuilder.toString ()Ljava/lang/String;
23</p>
<p>ARETURN</p>
<p>24</p>
<p>MAXSTACK = </p>
<p>3
25</p>
<p>MAXLOCALS = </p>
<p>2</p>
<p>26</p>
<p>}<a href=""><strong>清单 6. 生成 SayHelloImpl.class 的 ASM Code</strong></a>01</p>
<p>package</p>
<p>asm.com.ibm.was.asm;</p>
<p>02</p>
<p>import</p>
<p>java.util./*;
03</p>
<p>import</p>
<p>org.objectweb.asm./*;</p>
<p>04</p>
<p>import</p>
<p>org.objectweb.asm.attrs./*;
05</p>
<p>public</p>
<p>class</p>
<p>SayHelloImplDump </p>
<p>implements</p>
<p>Opcodes {</p>
<p>06</p>
<p>public</p>
<p>static</p>
<p>byte</p>
<p>[] dump () </p>
<p>throws</p>
<p>Exception {
07</p>
<p>ClassWriter cw = </p>
<p>new</p>
<p>ClassWriter(</p>
<p>0</p>
<p>);</p>
<p>08</p>
<p>FieldVisitor fv;
09</p>
<p>MethodVisitor mv;</p>
<p>10</p>
<p>AnnotationVisitor av0;
11</p>
<p>12</p>
<p>cw.visit(V1_6, ACC_PUBLIC + ACC_SUPER, </p>
<p>&quot;com/ibm/was/asm/SayHelloImpl&quot;</p>
<p>,
13</p>
<p>null</p>
<p>, </p>
<p>&quot;java/lang/Object&quot;</p>
<p>, </p>
<p>null</p>
<p>);</p>
<p>14</p>
<p>15</p>
<p>{</p>
<p>16</p>
<p>mv = cw.visitMethod(ACC_PUBLIC, </p>
<p>&quot;<init>&quot;</p>
<p>, </p>
<p>&quot;()V&quot;</p>
<p>, </p>
<p>null</p>
<p>, </p>
<p>null</p>
<p>);
17</p>
<p>mv.visitCode();</p>
<p>18</p>
<p>mv.visitVarInsn(ALOAD, </p>
<p>0</p>
<p>);
19</p>
<p>mv.visitMethodInsn(INVOKESPECIAL, </p>
<p>&quot;java/lang/Object&quot;</p>
<p>, </p>
<p>&quot;<init>&quot;</p>
<p>, </p>
<p>&quot;()V&quot;</p>
<p>);</p>
<p>20</p>
<p>mv.visitInsn(RETURN);
21</p>
<p>mv.visitMaxs(</p>
<p>1</p>
<p>, </p>
<p>1</p>
<p>);</p>
<p>22</p>
<p>mv.visitEnd();
23</p>
<p>}</p>
<p>24</p>
<p>{
25</p>
<p>mv = cw.visitMethod(ACC_PUBLIC, </p>
<p>&quot;sayHello&quot;</p>
<p>,</p>
<p>26</p>
<p>&quot;(Ljava/lang/String;)Ljava/lang/String;&quot;</p>
<p>, </p>
<p>null</p>
<p>, </p>
<p>null</p>
<p>);
27</p>
<p>mv.visitCode();</p>
<p>28</p>
<p>mv.visitTypeInsn(NEW, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>);
29</p>
<p>mv.visitInsn(DUP);</p>
<p>30</p>
<p>mv.visitLdcInsn(</p>
<p>&quot;Hello:&quot;</p>
<p>);
31</p>
<p>mv.visitMethodInsn(INVOKESPECIAL, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>,</p>
<p>32</p>
<p>&quot;<init>&quot;</p>
<p>, </p>
<p>&quot;(Ljava/lang/String;)V&quot;</p>
<p>);
33</p>
<p>mv.visitVarInsn(ALOAD, </p>
<p>1</p>
<p>);</p>
<p>34</p>
<p>mv.visitMethodInsn(INVOKEVIRTUAL, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>,
35</p>
<p>&quot;append&quot;</p>
<p>, </p>
<p>&quot;(Ljava/lang/String;)Ljava/lang/StringBuilder;&quot;</p>
<p>);</p>
<p>36</p>
<p>mv.visitMethodInsn(INVOKEVIRTUAL, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>,
37</p>
<p>&quot;toString&quot;</p>
<p>, </p>
<p>&quot;()Ljava/lang/String;&quot;</p>
<p>);</p>
<p>38</p>
<p>mv.visitInsn(ARETURN);
39</p>
<p>mv.visitMaxs(</p>
<p>3</p>
<p>, </p>
<p>2</p>
<p>);</p>
<p>40</p>
<p>mv.visitEnd();
41</p>
<p>}</p>
<p>42</p>
<p>cw.visitEnd();
43</p>
<p>return</p>
<p>cw.toByteArray();</p>
<p>44</p>
<p>}
45</p>
<p>}</p>
<p>图 1 描述了 Java Source 文件、Java Class 文件、ASM Code 文件和 ASM Source 文件之间的转换关系。
<a href=""><strong>图 1. 四种文件的转换图</strong></a> 
<a href=""><img src="" alt="图 1. 四种文件的转换图"></a> </p>
<p>如图 -1 所示，Java Source 文件通过 Javac 可以转换为 Java Class 文件。而相应的 Java Class 文件通过 Java 反编译器工具可转换为 Java Source 文件；</p>
<p>通 过 ASM Code 去创建和修改 Java Class 需要对 ASM API 比较熟悉才行，一个常见的问题时，怎么用 ASM Code 生成一个我们希望的 class 文件， 也就是说， 给定了 Java Class， 怎么得到其对应的 ASM Code 呢？ 所幸的是， ASM 框架为我们提供了 ASMifierClassVisitor 工具来产生 Java Class 对应的 ASM Code。代码如下：
<a href=""><strong>清单 7. 给定 class 文件，通过 ASMifierClassVisitor 获得其对应的 ASM Code</strong></a><a href="http://www.oschina.net/question/129540_28430#viewSource" title="view source" target="_blank">view source</a><a href="http://www.oschina.net/question/129540_28430#printSource" title="print" target="_blank">print</a><a href="http://www.oschina.net/question/129540_28430#about" title="?" target="_blank">?</a></p>
<p>01</p>
<p>public</p>
<p>void</p>
<p>showClassASMProcess() {</p>
<p>02</p>
<p>ClassReader cr;
03</p>
<p>final</p>
<p>String n = SayHelloImpl.</p>
<p>class</p>
<p>.getName();</p>
<p>04</p>
<p>05</p>
<p>try</p>
<p>{</p>
<p>06</p>
<p>cr = </p>
<p>new</p>
<p>ClassReader(n);<br>07</p>
<p>cr.accept(</p>
<p>new</p>
<p>ASMifierClassVisitor(</p>
<p>new</p>
<p>PrintWriter(System.out)),</p>
<p>08</p>
<p>new</p>
<p>Attribute[</p>
<p>0</p>
<p>],
09</p>
<p>ClassReader.SKIP_DEBUG);</p>
<p>10</p>
<p>11</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {</p>
<p>12</p>
<p>e.printStackTrace();
13</p>
<p>}</p>
<p>14</p>
<p>}</p>
<p>另外一个重要的转换就是， 给定了 Java Class 文件， 如何查看它的 ASM Source ？ 这点对于我们验证 ASM Code 生成的 class 是否正确很有用。ASM 提供了另外一个工具 TraceClassVisitor， 来获得一个 Java Class 对应的 ASM Source。代码如下：
<a href=""><strong>清单 8. 利用 TraceClassVisitor 查看 class 文件的 ASM Source</strong></a>01</p>
<p>//file 是 class 文件的全路径名</p>
<p>02</p>
<p>public</p>
<p>void</p>
<p>showClassSource(String file) {
03</p>
<p>FileInputStream is ;</p>
<p>04</p>
<p>ClassReader cr; 
05</p>
<p>06</p>
<p>try</p>
<p>{
07</p>
<p>is = </p>
<p>new</p>
<p>FileInputStream(file);     </p>
<p>08</p>
<p>cr = </p>
<p>new</p>
<p>ClassReader(is);
09</p>
<p>TraceClassVisitor trace = </p>
<p>new</p>
<p>TraceClassVisitor(</p>
<p>new</p>
<p>PrintWriter(System.out));</p>
<p>10</p>
<p>cr.accept(trace, ClassReader.SKIP_DEBUG);
11</p>
<p>12</p>
<p>is.close() ;
13</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {</p>
<p>14</p>
<p>e.printStackTrace() ;
15</p>
<p>}</p>
<p>16</p>
<p>}
17</p>
<p>{</p>
<p>18</p>
<p>e.printStackTrace();
19</p>
<p>}</p>
<p>20</p>
<p>}</p>
<p><a href="">ASM 类注入</a></p>
<p>ASM 类注入是指修改一个现有的 class 文件，在其中加入自己的代码。按通常思维，我们需要利用 ASM 提供的 reader 类去读取所要修改的类文件， 找到要修改的地方，如方法名或属性名，然后在该处插入自己的代码或修改现有的代码，这种思路将使问题复杂化。 ASM 为我们提供了访问类文件的 Visitor 模式，来遍历一个 class 文件，Visitor 是一个实现 ClassVisitor 接口的类。 要注入一个 class 文件，先要找到一个合适的 Visitor 做向导， ASM 提供了好几种 Visitor， 最常用的是 ClassWriter。同时我们需要提供一个适配器类 ClassAdapter， Visitor 会带着这个 Adapter 一起去遍历， 然后在遍历过程中回调 Adapter 提供的方法。我们在 Adapter 的这些方法中就可以实现我们的修改和定制逻辑。当然，如果你不想做任何修改，那 Visitor 遍历完后将得到一个和被遍历的 class 完全一样的拷贝。
<a href=""><strong>清单 9. 类注入的完整过程</strong></a>01</p>
<p>public</p>
<p>void</p>
<p>addAnnotationToExistingClass() {</p>
<p>02</p>
<p>FileInputStream is ;
03</p>
<p>ClassReader cr;          </p>
<p>04</p>
<p>try</p>
<p>{<br>05</p>
<p>String classfile = </p>
<p>&quot;E:\SayHelloImpl.class&quot;</p>
<p>; </p>
<p>// 待遍历的类</p>
<p>06</p>
<p>showClassSource(classfile) ;  </p>
<p>// 打印该类的 ASM source
07</p>
<p>08</p>
<p>is = </p>
<p>new</p>
<p>FileInputStream(classfile);<br>09</p>
<p>cr = </p>
<p>new</p>
<p>ClassReader(is);</p>
<p>10</p>
<p>// 此处我们使用 ClassWriter 做 Visitor
11</p>
<p>ClassWriter cw = </p>
<p>new</p>
<p>ClassWriter(ClassWriter.COMPUTE_MAXS);</p>
<p>12</p>
<p>// 给 Visitor 提供一个 Adapter
13</p>
<p>AddAnnotationAdapter adapter = </p>
<p>new</p>
<p>AddAnnotationAdapter(cw);           </p>
<p>14</p>
<p>cr.accept(adapter, ClassReader.SKIP_DEBUG);<br>15</p>
<p>16</p>
<p>// 遍历完后，生成的 class 保存在字节数组中
17</p>
<p>byte</p>
<p>[] b = cw.toByteArray();</p>
<p>18</p>
<p>19</p>
<p>try</p>
<p>{</p>
<p>20</p>
<p>// 将字节数组输出到文件中
21</p>
<p>// 为了不至于覆盖掉原有的 SayHelloImpl.class 文件，我们将结果输出到 _SayHelloImpl.class</p>
<p>22</p>
<p>FileOutputStream fout = </p>
<p>new</p>
<p>FileOutputStream(</p>
<p>&quot;E:\_SayHelloImpl.class&quot;</p>
<p>);
23</p>
<p>fout.write(b) ;</p>
<p>24</p>
<p>fout.flush();
25</p>
<p>fout.close() ;</p>
<p>26</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {
27</p>
<p>e.printStackTrace() ;</p>
<p>28</p>
<p>}
29</p>
<p>30</p>
<p>// 验证 _SayHelloImpl.class 是否包含我们注入的代码
31</p>
<p>showClassSource(</p>
<p>&quot;E:\_SayHelloImpl.class&quot;</p>
<p>) ;</p>
<p>32</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {
33</p>
<p>e.printStackTrace();</p>
<p>34</p>
<p>} 
35</p>
<p>}</p>
<p><a href="">web services 标记注入过程</a></p>
<p>我们已经知道了如何往 class 中注入自己的代码，那对于一个已有的 Java bean，怎么往里注入 @WebService 和 @WebMethod 呢？根据上面我们讲的转换关系，我们可以先写一个带 annotation 的 Java Source，编译得到 Java Class， 再得到其 ASM Code。下面是利用 ASM 给一个不带任何 Annotation 的 class 添加 @WebService 和 @WebMethod 的步骤。</p>
<ol>
<li>首先在 SayHelloImpl.java 中添加 @WebService 和 @WebMethod： 
<a href=""><strong>清单 10. 带 web services 标注的 SayHelloImpl 类</strong></a>1</li>
</ol>
<p>@WebService</p>
<p>2</p>
<p>public</p>
<p>class</p>
<p>SayHelloImpl {
3</p>
<p>@WebMethod</p>
<p>4</p>
<p>public</p>
<p>String sayHello(String s) {
5</p>
<p>return</p>
<p>&quot;Hello: &quot;</p>
<ul>
<li>s ;</li>
</ul>
<p>6</p>
<p>}
7</p>
<p>}</p>
<ol>
<li>通过 ASMifierClassVisitor 工具获得 SayHelloImpl class 的 ASM Code，见清单 6。</li>
<li>写一个 ClassAdapter 类， ClassAdapter 其实也是一个 Visitor。根据 ASM Code 的提示， 我们就可以知道如何利用 ASM API 去获得我们希望的 class 文件。下面是 Adapter 的示例代码。 
<a href=""><strong>清单 11. 添加 Annotation 的 Adapter 类</strong></a>01</li>
</ol>
<p>public</p>
<p>class</p>
<p>AddAnnotationAdapter </p>
<p>extends</p>
<p>ClassAdapter </p>
<p>implements</p>
<p>Opcodes{</p>
<p>02</p>
<p>//private String annotationDesc;
03</p>
<p>private</p>
<p>boolean</p>
<p>isAnnotationPresent;</p>
<p>04</p>
<p>05</p>
<p>public</p>
<p>AddAnnotationAdapter(ClassVisitor cv) {</p>
<p>06</p>
<p>super</p>
<p>(cv);
07</p>
<p>}</p>
<p>08</p>
<p>09</p>
<p>@Override</p>
<p>10</p>
<p>public</p>
<p>void</p>
<p>visit(</p>
<p>int</p>
<p>version, </p>
<p>int</p>
<p>access, String name, String signature,
11</p>
<p>String superName, String[] interfaces) {</p>
<p>12</p>
<p>13</p>
<p>cv.visit(V1_6, ACC_PUBLIC + ACC_SUPER, name, signature, superName,</p>
<p>14</p>
<p>interfaces);
15</p>
<p>AnnotationVisitor av0;</p>
<p>16</p>
<p>av0 = cv.visitAnnotation(</p>
<p>&quot;Ljavax/jws/WebService;&quot;</p>
<p>, </p>
<p>true</p>
<p>);
17</p>
<p>av0.visitEnd();</p>
<p>18</p>
<p>}
19</p>
<p>20</p>
<p>@Override
21</p>
<p>public</p>
<p>AnnotationVisitor visitAnnotation(String desc, </p>
<p>boolean</p>
<p>visible) {</p>
<p>22</p>
<p>return</p>
<p>cv.visitAnnotation(desc, visible);
23</p>
<p>}</p>
<p>24</p>
<p>25</p>
<p>@Override</p>
<p>26</p>
<p>public</p>
<p>void</p>
<p>visitInnerClass(String name, String outerName,
27</p>
<p>String innerName, </p>
<p>int</p>
<p>access) {</p>
<p>28</p>
<p>cv.visitInnerClass(name, outerName, innerName, access);
29</p>
<p>}</p>
<p>30</p>
<p>31</p>
<p>@Override</p>
<p>32</p>
<p>public</p>
<p>FieldVisitor visitField(</p>
<p>int</p>
<p>access, String name, String desc,
33</p>
<p>String signature, Object value) {</p>
<p>34</p>
<p>return</p>
<p>cv.visitField(access, name, desc, signature, value);
35</p>
<p>}</p>
<p>36</p>
<p>37</p>
<p>@Override</p>
<p>38</p>
<p>public</p>
<p>MethodVisitor visitMethod(</p>
<p>int</p>
<p>access, String name, String desc,
39</p>
<p>String signature, String[] exceptions) {   </p>
<p>40</p>
<p>MethodVisitor mv  = cv.visitMethod(access, name, desc, signature,
41</p>
<p>exceptions);</p>
<p>42</p>
<p>if</p>
<p>(!name.equals(</p>
<p>&quot;<init>&quot;</p>
<p>)) {
43</p>
<p>AnnotationVisitor av0;</p>
<p>44</p>
<p>av0 = mv.visitAnnotation(</p>
<p>&quot;Ljavax/jws/WebMethod;&quot;</p>
<p>, </p>
<p>true</p>
<p>);
45</p>
<p>av0.visitEnd();</p>
<p>46</p>
<p>}
47</p>
<p>return</p>
<p>mv;</p>
<p>48</p>
<p>}
49</p>
<p>50</p>
<p>@Override
51</p>
<p>public</p>
<p>void</p>
<p>visitEnd() {</p>
<p>52</p>
<p>cv.visitEnd();
53</p>
<p>}</p>
<p>54</p>
<p>55</p>
<p>}</p>
<p>最后，我们采用上面讲的类注入办法，即可得到一个带 @WebService 和 @WebMethod 标注的 class 文件。再通过 wsgen 工具即可成功创建 web services，该命令将会在 src 目录下生成 web services 描述文件：SayHelloImplService.wsdl，SayHelloImplService_schema1.xsd，同时生成了 2 个 JAX-WS 文件，分别为：SayHello.java，SayHelloResponse.java。</p>
<p>当然，在实际应用中，我们可能需要将一个 class 的某些特定方法发布为 web services，这就需要我们对 Adapter 做进一步的改造，在 visitMethod() 方法中根据方法名称等参数做进一步的处理。</p>
<p><a href="">结束语</a></p>
<p>本文简要介绍了 ASM 字节码工具及其在 web services 开发中的应用。web services 的使用已经越来越广泛， 但在改造遗留系统过程中会遇到不少问题，本文针对其中一个主要问题给出了解决办法，该方法无须对现有系统做大量的改动， 即可将现存的 Java bean 转化成 web services 。本文对那些正考虑迁移到 JAX-WS 编程模型上的项目有一定的参考价值。在基于 JAX-WS 标准的 web services 的开发中，不少实际场景都是希望采用自底向上的开发方式， 即基于已有的 Java bean 来创建 web services 。WebSphere Application Server ( 以下简称 WAS ) 提供了命令行的工具 wsgen 和相对应的 Ant task 来支持这种开发过程，而且这两个工具比较适合大型项目的自动化构建。 这两个工具的使用前提是 Java bean 中事先添加有 web services 的 Annotation 标注，而在现有的业务系统中，class 文件一般是不带 Annotation 的，这就需要开发人员去修改现有的代码，以手工方式添加 Annotation，但这样带来的工作量太大且容易出错。本文介绍了一种解决途径，可以不用修改源代码，而是利用字节码工具 ASM 直接修改 class 文件， 在字节码文件中自动注入 Annotation ，然后再利用 wsgen 工具就可以很方便地生成 web services 应用。 本文同时也总结了使用 ASM 的一些实践。</p>
<p>本文首先介绍了和 ASM 使用相关的四种文件，以及它们之间的相互转化。然后结合 web services 开发实例，介绍了使用 wsgen 开发时遇到的实际问题，如何写一个 ASM 的适配器去修改现有 class，最终如何产生 web services 文件。</p>
<p>ASM 是一个多用途的 Java 字节码操控和分析框架。它能以二进制的形式直接修改现有的类或动态生成的类。 ASM 提供了常用的转换和分析算法，是一种允许用户方便的组装定制化的复杂转换和代码分析工具。 ASM 也提供和其它的字节码工具类似的功能，但 ASM 的重点是使用的简单和高性能。由于 ASM 在设计实现的时候尽可能 的小的内存占用和提供更高的性能；因此在动态系统中使用 ASM 是很有优势的。ASM 作为一种轻量级、高性能的 Java 字节码操控和分析框架，设计了一种更有效的方法、提供更好的性能和内存占用。今天， ASM 在许多领域都有应用，并已成为事实上的字节码处理框架标准。</p>
<p><a href="">问题的引入</a></p>
<p>先写一个不带 web services 标注的 SayHelloImpl 类。
<a href=""><strong>清单 1. 不带 web services 的 SayHelloImpl 类</strong></a>1</p>
<p>public</p>
<p>class</p>
<p>SayHelloImpl {</p>
<p>2</p>
<p>public</p>
<p>String sayHello(String s) {
3</p>
<p>return</p>
<p>“Hello: ” + s ;</p>
<p>4</p>
<p>}
5</p>
<p>}</p>
<p>再用 wsgen 来创建 web services，wsgen 的使用如下：
<a href=""><strong>清单 2. wsgen 实例</strong></a>1</p>
<p>wsgen.exe – </p>
<p>cp</p>
<p>bin – s output – d output – r output – wsdl ibm.was.asm.SayHelloImpl我们将会遇到如下错误： 
<a href=""><strong>清单 3. 根据不带 web services 标注的类创建 web services 时遇到的错误信息</strong></a> 
注释处理过程中遇到问题；</p>
<p>......
com.sun.tools.internal.ws.processor.modeler.ModelerException: [failed to localiz</p>
<p>e] A web service endpoint could not be found()
        at com.sun.tools.internal.ws.processor.modeler.annotation.WebServiceAP.o</p>
<p>nError(WebServiceAP.java:215)
        at com.sun.tools.internal.ws.processor.modeler.annotation.WebServiceAP.b</p>
<p>uildModel(WebServiceAP.java:322)
        at com.sun.tools.internal.ws.processor.modeler.annotation.WebServiceAP.p</p>
<p>rocess(WebServiceAP.java:256)
        at com.sun.mirror.apt.AnnotationProcessors$CompositeAnnotationProcessor.</p>
<p>process(AnnotationProcessors.java:60)</p>
<p>注意：我们通常是在 class 前使用 @WebService， 在方法前使用 @WebMethod 来将一个类标注为 web services 的。WAS 6.1 的 web services 功能部件包和 WAS 7 都支持基于 JAX-WS 标准 的 web services 的开发， 在 WAS 安装目录的 bin 目录下提供了命令行工具 wsgen，wsgen 支持自底向上的开发方式。 下面是 wsgen 的用法：
<a href=""><strong>清单 4. wsgen 命令格式</strong></a> 
注 wsgen [options]  [SEI]</p>
<p>主要选项：</p>
<ul>
<li>-d 指定生成的 class 文件位置；</li>
<li>-s 指定生成的 Java 源文件位置；</li>
<li>-r 指定生成的 resources 文件位置，如 wsdl，xsd；</li>
<li>-cp 指定服务实现类所在的位置；</li>
<li>-wsdl，-servicename，-portname 三个参数指定生成的 wsdl 文件中的 service 和 port 的名称。</li>
</ul>
<p>SEI(Service Endpoint Interface) 是一个 endpoint implementation class，不能是一个 interface。所以首先要开发一个 endpoint 的实现类，如本例中的 SayHelloImpl 。用 @WebService 声明 web services ，然后将它编译，才能提供给 wsgen 来创建 web services 。</p>
<p><a href="">四种文件之间的转换</a></p>
<p>下面介绍本文要用到的四个概念（Java Source，Java Class，ASM Code，ASM Source）</p>
<ul>
<li>Java Source: 即我们通常编写的 Java 源文件；</li>
<li>Java Class: Java 源文件编译后的字节码文件；</li>
<li>ASM Source : 类似于对 class 反编译后的源文件，也就是 &quot;textual byte code&quot;，但比原始的 Java Source 可读性要差， 参见清单 5。</li>
<li>ASM Code: 指读写 class 文件的 ASM 程序代码。需要用到 ASM 提供的 API， 参见清单 6。
<a href=""><strong>清单 5. SayHelloImpl 类对应的 ASM Source</strong></a>01</li>
</ul>
<p>// class version 50.0 (50)</p>
<p>02</p>
<p>// access flags 33
03</p>
<p>public</p>
<p>class</p>
<p>com/ibm/was/asm/SayHelloImpl {</p>
<p>04</p>
<p>05</p>
<p>// access flags 1</p>
<p>06</p>
<p>public</p>
<p><init>()V
07</p>
<p>ALOAD </p>
<p>0</p>
<p>08</p>
<p>INVOKESPECIAL java/lang/Object. <init> ()V
09</p>
<p>RETURN</p>
<p>10</p>
<p>MAXSTACK = </p>
<p>1
11</p>
<p>MAXLOCALS = </p>
<p>1</p>
<p>12</p>
<p>13</p>
<p>// access flags 1</p>
<p>14</p>
<p>public</p>
<p>sayHello(Ljava/lang/String;)Ljava/lang/String;
15</p>
<p>NEW java/lang/StringBuilder</p>
<p>16</p>
<p>DUP
17</p>
<p>LDC </p>
<p>&quot;Hello:&quot;</p>
<p>18</p>
<p>INVOKESPECIAL java/lang/StringBuilder. <init> (Ljava/lang/String;)V
19</p>
<p>ALOAD </p>
<p>1</p>
<p>20</p>
<p>INVOKEVIRTUAL java/lang/StringBuilder.append (Ljava/lang/String;)
21</p>
<p>Ljava/lang/StringBuilder;</p>
<p>22</p>
<p>INVOKEVIRTUAL java/lang/StringBuilder.toString ()Ljava/lang/String;
23</p>
<p>ARETURN</p>
<p>24</p>
<p>MAXSTACK = </p>
<p>3
25</p>
<p>MAXLOCALS = </p>
<p>2</p>
<p>26</p>
<p>}<a href=""><strong>清单 6. 生成 SayHelloImpl.class 的 ASM Code</strong></a>01</p>
<p>package</p>
<p>asm.com.ibm.was.asm;</p>
<p>02</p>
<p>import</p>
<p>java.util./*;
03</p>
<p>import</p>
<p>org.objectweb.asm./*;</p>
<p>04</p>
<p>import</p>
<p>org.objectweb.asm.attrs./*;
05</p>
<p>public</p>
<p>class</p>
<p>SayHelloImplDump </p>
<p>implements</p>
<p>Opcodes {</p>
<p>06</p>
<p>public</p>
<p>static</p>
<p>byte</p>
<p>[] dump () </p>
<p>throws</p>
<p>Exception {
07</p>
<p>ClassWriter cw = </p>
<p>new</p>
<p>ClassWriter(</p>
<p>0</p>
<p>);</p>
<p>08</p>
<p>FieldVisitor fv;
09</p>
<p>MethodVisitor mv;</p>
<p>10</p>
<p>AnnotationVisitor av0;
11</p>
<p>12</p>
<p>cw.visit(V1_6, ACC_PUBLIC + ACC_SUPER, </p>
<p>&quot;com/ibm/was/asm/SayHelloImpl&quot;</p>
<p>,
13</p>
<p>null</p>
<p>, </p>
<p>&quot;java/lang/Object&quot;</p>
<p>, </p>
<p>null</p>
<p>);</p>
<p>14</p>
<p>15</p>
<p>{</p>
<p>16</p>
<p>mv = cw.visitMethod(ACC_PUBLIC, </p>
<p>&quot;<init>&quot;</p>
<p>, </p>
<p>&quot;()V&quot;</p>
<p>, </p>
<p>null</p>
<p>, </p>
<p>null</p>
<p>);
17</p>
<p>mv.visitCode();</p>
<p>18</p>
<p>mv.visitVarInsn(ALOAD, </p>
<p>0</p>
<p>);
19</p>
<p>mv.visitMethodInsn(INVOKESPECIAL, </p>
<p>&quot;java/lang/Object&quot;</p>
<p>, </p>
<p>&quot;<init>&quot;</p>
<p>, </p>
<p>&quot;()V&quot;</p>
<p>);</p>
<p>20</p>
<p>mv.visitInsn(RETURN);
21</p>
<p>mv.visitMaxs(</p>
<p>1</p>
<p>, </p>
<p>1</p>
<p>);</p>
<p>22</p>
<p>mv.visitEnd();
23</p>
<p>}</p>
<p>24</p>
<p>{
25</p>
<p>mv = cw.visitMethod(ACC_PUBLIC, </p>
<p>&quot;sayHello&quot;</p>
<p>,</p>
<p>26</p>
<p>&quot;(Ljava/lang/String;)Ljava/lang/String;&quot;</p>
<p>, </p>
<p>null</p>
<p>, </p>
<p>null</p>
<p>);
27</p>
<p>mv.visitCode();</p>
<p>28</p>
<p>mv.visitTypeInsn(NEW, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>);
29</p>
<p>mv.visitInsn(DUP);</p>
<p>30</p>
<p>mv.visitLdcInsn(</p>
<p>&quot;Hello:&quot;</p>
<p>);
31</p>
<p>mv.visitMethodInsn(INVOKESPECIAL, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>,</p>
<p>32</p>
<p>&quot;<init>&quot;</p>
<p>, </p>
<p>&quot;(Ljava/lang/String;)V&quot;</p>
<p>);
33</p>
<p>mv.visitVarInsn(ALOAD, </p>
<p>1</p>
<p>);</p>
<p>34</p>
<p>mv.visitMethodInsn(INVOKEVIRTUAL, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>,
35</p>
<p>&quot;append&quot;</p>
<p>, </p>
<p>&quot;(Ljava/lang/String;)Ljava/lang/StringBuilder;&quot;</p>
<p>);</p>
<p>36</p>
<p>mv.visitMethodInsn(INVOKEVIRTUAL, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>,
37</p>
<p>&quot;toString&quot;</p>
<p>, </p>
<p>&quot;()Ljava/lang/String;&quot;</p>
<p>);</p>
<p>38</p>
<p>mv.visitInsn(ARETURN);
39</p>
<p>mv.visitMaxs(</p>
<p>3</p>
<p>, </p>
<p>2</p>
<p>);</p>
<p>40</p>
<p>mv.visitEnd();
41</p>
<p>}</p>
<p>42</p>
<p>cw.visitEnd();
43</p>
<p>return</p>
<p>cw.toByteArray();</p>
<p>44</p>
<p>}
45</p>
<p>}</p>
<p>图 1 描述了 Java Source 文件、Java Class 文件、ASM Code 文件和 ASM Source 文件之间的转换关系。
<a href=""><strong>图 1. 四种文件的转换图</strong></a> 
<a href=""><img src="" alt="图 1. 四种文件的转换图"></a> </p>
<p>如图 -1 所示，Java Source 文件通过 Javac 可以转换为 Java Class 文件。而相应的 Java Class 文件通过 Java 反编译器工具可转换为 Java Source 文件；</p>
<p>通 过 ASM Code 去创建和修改 Java Class 需要对 ASM API 比较熟悉才行，一个常见的问题时，怎么用 ASM Code 生成一个我们希望的 class 文件， 也就是说， 给定了 Java Class， 怎么得到其对应的 ASM Code 呢？ 所幸的是， ASM 框架为我们提供了 ASMifierClassVisitor 工具来产生 Java Class 对应的 ASM Code。代码如下：
<a href=""><strong>清单 7. 给定 class 文件，通过 ASMifierClassVisitor 获得其对应的 ASM Code</strong></a><a href="http://www.oschina.net/question/129540_28430#viewSource" title="view source" target="_blank">view source</a><a href="http://www.oschina.net/question/129540_28430#printSource" title="print" target="_blank">print</a><a href="http://www.oschina.net/question/129540_28430#about" title="?" target="_blank">?</a></p>
<p>01</p>
<p>public</p>
<p>void</p>
<p>showClassASMProcess() {</p>
<p>02</p>
<p>ClassReader cr;
03</p>
<p>final</p>
<p>String n = SayHelloImpl.</p>
<p>class</p>
<p>.getName();</p>
<p>04</p>
<p>05</p>
<p>try</p>
<p>{</p>
<p>06</p>
<p>cr = </p>
<p>new</p>
<p>ClassReader(n);<br>07</p>
<p>cr.accept(</p>
<p>new</p>
<p>ASMifierClassVisitor(</p>
<p>new</p>
<p>PrintWriter(System.out)),</p>
<p>08</p>
<p>new</p>
<p>Attribute[</p>
<p>0</p>
<p>],
09</p>
<p>ClassReader.SKIP_DEBUG);</p>
<p>10</p>
<p>11</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {</p>
<p>12</p>
<p>e.printStackTrace();
13</p>
<p>}</p>
<p>14</p>
<p>}</p>
<p>另外一个重要的转换就是， 给定了 Java Class 文件， 如何查看它的 ASM Source ？ 这点对于我们验证 ASM Code 生成的 class 是否正确很有用。ASM 提供了另外一个工具 TraceClassVisitor， 来获得一个 Java Class 对应的 ASM Source。代码如下：
<a href=""><strong>清单 8. 利用 TraceClassVisitor 查看 class 文件的 ASM Source</strong></a>01</p>
<p>//file 是 class 文件的全路径名</p>
<p>02</p>
<p>public</p>
<p>void</p>
<p>showClassSource(String file) {
03</p>
<p>FileInputStream is ;</p>
<p>04</p>
<p>ClassReader cr; 
05</p>
<p>06</p>
<p>try</p>
<p>{
07</p>
<p>is = </p>
<p>new</p>
<p>FileInputStream(file);     </p>
<p>08</p>
<p>cr = </p>
<p>new</p>
<p>ClassReader(is);
09</p>
<p>TraceClassVisitor trace = </p>
<p>new</p>
<p>TraceClassVisitor(</p>
<p>new</p>
<p>PrintWriter(System.out));</p>
<p>10</p>
<p>cr.accept(trace, ClassReader.SKIP_DEBUG);
11</p>
<p>12</p>
<p>is.close() ;
13</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {</p>
<p>14</p>
<p>e.printStackTrace() ;
15</p>
<p>}</p>
<p>16</p>
<p>}
17</p>
<p>{</p>
<p>18</p>
<p>e.printStackTrace();
19</p>
<p>}</p>
<p>20</p>
<p>}</p>
<p><a href="">ASM 类注入</a></p>
<p>ASM 类注入是指修改一个现有的 class 文件，在其中加入自己的代码。按通常思维，我们需要利用 ASM 提供的 reader 类去读取所要修改的类文件， 找到要修改的地方，如方法名或属性名，然后在该处插入自己的代码或修改现有的代码，这种思路将使问题复杂化。 ASM 为我们提供了访问类文件的 Visitor 模式，来遍历一个 class 文件，Visitor 是一个实现 ClassVisitor 接口的类。 要注入一个 class 文件，先要找到一个合适的 Visitor 做向导， ASM 提供了好几种 Visitor， 最常用的是 ClassWriter。同时我们需要提供一个适配器类 ClassAdapter， Visitor 会带着这个 Adapter 一起去遍历， 然后在遍历过程中回调 Adapter 提供的方法。我们在 Adapter 的这些方法中就可以实现我们的修改和定制逻辑。当然，如果你不想做任何修改，那 Visitor 遍历完后将得到一个和被遍历的 class 完全一样的拷贝。
<a href=""><strong>清单 9. 类注入的完整过程</strong></a>01</p>
<p>public</p>
<p>void</p>
<p>addAnnotationToExistingClass() {</p>
<p>02</p>
<p>FileInputStream is ;
03</p>
<p>ClassReader cr;          </p>
<p>04</p>
<p>try</p>
<p>{<br>05</p>
<p>String classfile = </p>
<p>&quot;E:\SayHelloImpl.class&quot;</p>
<p>; </p>
<p>// 待遍历的类</p>
<p>06</p>
<p>showClassSource(classfile) ;  </p>
<p>// 打印该类的 ASM source
07</p>
<p>08</p>
<p>is = </p>
<p>new</p>
<p>FileInputStream(classfile);<br>09</p>
<p>cr = </p>
<p>new</p>
<p>ClassReader(is);</p>
<p>10</p>
<p>// 此处我们使用 ClassWriter 做 Visitor
11</p>
<p>ClassWriter cw = </p>
<p>new</p>
<p>ClassWriter(ClassWriter.COMPUTE_MAXS);</p>
<p>12</p>
<p>// 给 Visitor 提供一个 Adapter
13</p>
<p>AddAnnotationAdapter adapter = </p>
<p>new</p>
<p>AddAnnotationAdapter(cw);           </p>
<p>14</p>
<p>cr.accept(adapter, ClassReader.SKIP_DEBUG);<br>15</p>
<p>16</p>
<p>// 遍历完后，生成的 class 保存在字节数组中
17</p>
<p>byte</p>
<p>[] b = cw.toByteArray();</p>
<p>18</p>
<p>19</p>
<p>try</p>
<p>{</p>
<p>20</p>
<p>// 将字节数组输出到文件中
21</p>
<p>// 为了不至于覆盖掉原有的 SayHelloImpl.class 文件，我们将结果输出到 _SayHelloImpl.class</p>
<p>22</p>
<p>FileOutputStream fout = </p>
<p>new</p>
<p>FileOutputStream(</p>
<p>&quot;E:\_SayHelloImpl.class&quot;</p>
<p>);
23</p>
<p>fout.write(b) ;</p>
<p>24</p>
<p>fout.flush();
25</p>
<p>fout.close() ;</p>
<p>26</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {
27</p>
<p>e.printStackTrace() ;</p>
<p>28</p>
<p>}
29</p>
<p>30</p>
<p>// 验证 _SayHelloImpl.class 是否包含我们注入的代码
31</p>
<p>showClassSource(</p>
<p>&quot;E:\_SayHelloImpl.class&quot;</p>
<p>) ;</p>
<p>32</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {
33</p>
<p>e.printStackTrace();</p>
<p>34</p>
<p>} 
35</p>
<p>}</p>
<p><a href="">web services 标记注入过程</a></p>
<p>我们已经知道了如何往 class 中注入自己的代码，那对于一个已有的 Java bean，怎么往里注入 @WebService 和 @WebMethod 呢？根据上面我们讲的转换关系，我们可以先写一个带 annotation 的 Java Source，编译得到 Java Class， 再得到其 ASM Code。下面是利用 ASM 给一个不带任何 Annotation 的 class 添加 @WebService 和 @WebMethod 的步骤。</p>
<ol>
<li>首先在 SayHelloImpl.java 中添加 @WebService 和 @WebMethod： 
<a href=""><strong>清单 10. 带 web services 标注的 SayHelloImpl 类</strong></a>1</li>
</ol>
<p>@WebService</p>
<p>2</p>
<p>public</p>
<p>class</p>
<p>SayHelloImpl {
3</p>
<p>@WebMethod</p>
<p>4</p>
<p>public</p>
<p>String sayHello(String s) {
5</p>
<p>return</p>
<p>&quot;Hello: &quot;</p>
<ul>
<li>s ;</li>
</ul>
<p>6</p>
<p>}
7</p>
<p>}</p>
<ol>
<li>通过 ASMifierClassVisitor 工具获得 SayHelloImpl class 的 ASM Code，见清单 6。</li>
<li>写一个 ClassAdapter 类， ClassAdapter 其实也是一个 Visitor。根据 ASM Code 的提示， 我们就可以知道如何利用 ASM API 去获得我们希望的 class 文件。下面是 Adapter 的示例代码。 
<a href=""><strong>清单 11. 添加 Annotation 的 Adapter 类</strong></a>01</li>
</ol>
<p>public</p>
<p>class</p>
<p>AddAnnotationAdapter </p>
<p>extends</p>
<p>ClassAdapter </p>
<p>implements</p>
<p>Opcodes{</p>
<p>02</p>
<p>//private String annotationDesc;
03</p>
<p>private</p>
<p>boolean</p>
<p>isAnnotationPresent;</p>
<p>04</p>
<p>05</p>
<p>public</p>
<p>AddAnnotationAdapter(ClassVisitor cv) {</p>
<p>06</p>
<p>super</p>
<p>(cv);
07</p>
<p>}</p>
<p>08</p>
<p>09</p>
<p>@Override</p>
<p>10</p>
<p>public</p>
<p>void</p>
<p>visit(</p>
<p>int</p>
<p>version, </p>
<p>int</p>
<p>access, String name, String signature,
11</p>
<p>String superName, String[] interfaces) {</p>
<p>12</p>
<p>13</p>
<p>cv.visit(V1_6, ACC_PUBLIC + ACC_SUPER, name, signature, superName,</p>
<p>14</p>
<p>interfaces);
15</p>
<p>AnnotationVisitor av0;</p>
<p>16</p>
<p>av0 = cv.visitAnnotation(</p>
<p>&quot;Ljavax/jws/WebService;&quot;</p>
<p>, </p>
<p>true</p>
<p>);
17</p>
<p>av0.visitEnd();</p>
<p>18</p>
<p>}
19</p>
<p>20</p>
<p>@Override
21</p>
<p>public</p>
<p>AnnotationVisitor visitAnnotation(String desc, </p>
<p>boolean</p>
<p>visible) {</p>
<p>22</p>
<p>return</p>
<p>cv.visitAnnotation(desc, visible);
23</p>
<p>}</p>
<p>24</p>
<p>25</p>
<p>@Override</p>
<p>26</p>
<p>public</p>
<p>void</p>
<p>visitInnerClass(String name, String outerName,
27</p>
<p>String innerName, </p>
<p>int</p>
<p>access) {</p>
<p>28</p>
<p>cv.visitInnerClass(name, outerName, innerName, access);
29</p>
<p>}</p>
<p>30</p>
<p>31</p>
<p>@Override</p>
<p>32</p>
<p>public</p>
<p>FieldVisitor visitField(</p>
<p>int</p>
<p>access, String name, String desc,
33</p>
<p>String signature, Object value) {</p>
<p>34</p>
<p>return</p>
<p>cv.visitField(access, name, desc, signature, value);
35</p>
<p>}</p>
<p>36</p>
<p>37</p>
<p>@Override</p>
<p>38</p>
<p>public</p>
<p>MethodVisitor visitMethod(</p>
<p>int</p>
<p>access, String name, String desc,
39</p>
<p>String signature, String[] exceptions) {   </p>
<p>40</p>
<p>MethodVisitor mv  = cv.visitMethod(access, name, desc, signature,
41</p>
<p>exceptions);</p>
<p>42</p>
<p>if</p>
<p>(!name.equals(</p>
<p>&quot;<init>&quot;</p>
<p>)) {
43</p>
<p>AnnotationVisitor av0;</p>
<p>44</p>
<p>av0 = mv.visitAnnotation(</p>
<p>&quot;Ljavax/jws/WebMethod;&quot;</p>
<p>, </p>
<p>true</p>
<p>);
45</p>
<p>av0.visitEnd();</p>
<p>46</p>
<p>}
47</p>
<p>return</p>
<p>mv;</p>
<p>48</p>
<p>}
49</p>
<p>50</p>
<p>@Override
51</p>
<p>public</p>
<p>void</p>
<p>visitEnd() {</p>
<p>52</p>
<p>cv.visitEnd();
53</p>
<p>}</p>
<p>54</p>
<p>55</p>
<p>}</p>
<p>最后，我们采用上面讲的类注入办法，即可得到一个带 @WebService 和 @WebMethod 标注的 class 文件。再通过 wsgen 工具即可成功创建 web services，该命令将会在 src 目录下生成 web services 描述文件：SayHelloImplService.wsdl，SayHelloImplService_schema1.xsd，同时生成了 2 个 JAX-WS 文件，分别为：SayHello.java，SayHelloResponse.java。</p>
<p>当然，在实际应用中，我们可能需要将一个 class 的某些特定方法发布为 web services，这就需要我们对 Adapter 做进一步的改造，在 visitMethod() 方法中根据方法名称等参数做进一步的处理。</p>
<p><a href="">结束语</a></p>
<p>本文简要介绍了 ASM 字节码工具及其在 web services 开发中的应用。web services 的使用已经越来越广泛， 但在改造遗留系统过程中会遇到不少问题，本文针对其中一个主要问题给出了解决办法，该方法无须对现有系统做大量的改动， 即可将现存的 Java bean 转化成 web services 。本文对那些正考虑迁移到 JAX-WS 编程模型上的项目有一定的参考价值。在基于 JAX-WS 标准的 web services 的开发中，不少实际场景都是希望采用自底向上的开发方式， 即基于已有的 Java bean 来创建 web services 。WebSphere Application Server ( 以下简称 WAS ) 提供了命令行的工具 wsgen 和相对应的 Ant task 来支持这种开发过程，而且这两个工具比较适合大型项目的自动化构建。 这两个工具的使用前提是 Java bean 中事先添加有 web services 的 Annotation 标注，而在现有的业务系统中，class 文件一般是不带 Annotation 的，这就需要开发人员去修改现有的代码，以手工方式添加 Annotation，但这样带来的工作量太大且容易出错。本文介绍了一种解决途径，可以不用修改源代码，而是利用字节码工具 ASM 直接修改 class 文件， 在字节码文件中自动注入 Annotation ，然后再利用 wsgen 工具就可以很方便地生成 web services 应用。 本文同时也总结了使用 ASM 的一些实践。</p>
<p>本文首先介绍了和 ASM 使用相关的四种文件，以及它们之间的相互转化。然后结合 web services 开发实例，介绍了使用 wsgen 开发时遇到的实际问题，如何写一个 ASM 的适配器去修改现有 class，最终如何产生 web services 文件。</p>
<p>ASM 是一个多用途的 Java 字节码操控和分析框架。它能以二进制的形式直接修改现有的类或动态生成的类。 ASM 提供了常用的转换和分析算法，是一种允许用户方便的组装定制化的复杂转换和代码分析工具。 ASM 也提供和其它的字节码工具类似的功能，但 ASM 的重点是使用的简单和高性能。由于 ASM 在设计实现的时候尽可能 的小的内存占用和提供更高的性能；因此在动态系统中使用 ASM 是很有优势的。ASM 作为一种轻量级、高性能的 Java 字节码操控和分析框架，设计了一种更有效的方法、提供更好的性能和内存占用。今天， ASM 在许多领域都有应用，并已成为事实上的字节码处理框架标准。</p>
<p><a href="">问题的引入</a></p>
<p>先写一个不带 web services 标注的 SayHelloImpl 类。
<a href=""><strong>清单 1. 不带 web services 的 SayHelloImpl 类</strong></a>1</p>
<p>public</p>
<p>class</p>
<p>SayHelloImpl {</p>
<p>2</p>
<p>public</p>
<p>String sayHello(String s) {
3</p>
<p>return</p>
<p>“Hello: ” + s ;</p>
<p>4</p>
<p>}
5</p>
<p>}</p>
<p>再用 wsgen 来创建 web services，wsgen 的使用如下：
<a href=""><strong>清单 2. wsgen 实例</strong></a>1</p>
<p>wsgen.exe – </p>
<p>cp</p>
<p>bin – s output – d output – r output – wsdl ibm.was.asm.SayHelloImpl我们将会遇到如下错误： 
<a href=""><strong>清单 3. 根据不带 web services 标注的类创建 web services 时遇到的错误信息</strong></a> 
注释处理过程中遇到问题；</p>
<p>......
com.sun.tools.internal.ws.processor.modeler.ModelerException: [failed to localiz</p>
<p>e] A web service endpoint could not be found()
        at com.sun.tools.internal.ws.processor.modeler.annotation.WebServiceAP.o</p>
<p>nError(WebServiceAP.java:215)
        at com.sun.tools.internal.ws.processor.modeler.annotation.WebServiceAP.b</p>
<p>uildModel(WebServiceAP.java:322)
        at com.sun.tools.internal.ws.processor.modeler.annotation.WebServiceAP.p</p>
<p>rocess(WebServiceAP.java:256)
        at com.sun.mirror.apt.AnnotationProcessors$CompositeAnnotationProcessor.</p>
<p>process(AnnotationProcessors.java:60)</p>
<p>注意：我们通常是在 class 前使用 @WebService， 在方法前使用 @WebMethod 来将一个类标注为 web services 的。WAS 6.1 的 web services 功能部件包和 WAS 7 都支持基于 JAX-WS 标准 的 web services 的开发， 在 WAS 安装目录的 bin 目录下提供了命令行工具 wsgen，wsgen 支持自底向上的开发方式。 下面是 wsgen 的用法：
<a href=""><strong>清单 4. wsgen 命令格式</strong></a> 
注 wsgen [options]  [SEI]</p>
<p>主要选项：</p>
<ul>
<li>-d 指定生成的 class 文件位置；</li>
<li>-s 指定生成的 Java 源文件位置；</li>
<li>-r 指定生成的 resources 文件位置，如 wsdl，xsd；</li>
<li>-cp 指定服务实现类所在的位置；</li>
<li>-wsdl，-servicename，-portname 三个参数指定生成的 wsdl 文件中的 service 和 port 的名称。</li>
</ul>
<p>SEI(Service Endpoint Interface) 是一个 endpoint implementation class，不能是一个 interface。所以首先要开发一个 endpoint 的实现类，如本例中的 SayHelloImpl 。用 @WebService 声明 web services ，然后将它编译，才能提供给 wsgen 来创建 web services 。</p>
<p><a href="">四种文件之间的转换</a></p>
<p>下面介绍本文要用到的四个概念（Java Source，Java Class，ASM Code，ASM Source）</p>
<ul>
<li>Java Source: 即我们通常编写的 Java 源文件；</li>
<li>Java Class: Java 源文件编译后的字节码文件；</li>
<li>ASM Source : 类似于对 class 反编译后的源文件，也就是 &quot;textual byte code&quot;，但比原始的 Java Source 可读性要差， 参见清单 5。</li>
<li>ASM Code: 指读写 class 文件的 ASM 程序代码。需要用到 ASM 提供的 API， 参见清单 6。
<a href=""><strong>清单 5. SayHelloImpl 类对应的 ASM Source</strong></a>01</li>
</ul>
<p>// class version 50.0 (50)</p>
<p>02</p>
<p>// access flags 33
03</p>
<p>public</p>
<p>class</p>
<p>com/ibm/was/asm/SayHelloImpl {</p>
<p>04</p>
<p>05</p>
<p>// access flags 1</p>
<p>06</p>
<p>public</p>
<p><init>()V
07</p>
<p>ALOAD </p>
<p>0</p>
<p>08</p>
<p>INVOKESPECIAL java/lang/Object. <init> ()V
09</p>
<p>RETURN</p>
<p>10</p>
<p>MAXSTACK = </p>
<p>1
11</p>
<p>MAXLOCALS = </p>
<p>1</p>
<p>12</p>
<p>13</p>
<p>// access flags 1</p>
<p>14</p>
<p>public</p>
<p>sayHello(Ljava/lang/String;)Ljava/lang/String;
15</p>
<p>NEW java/lang/StringBuilder</p>
<p>16</p>
<p>DUP
17</p>
<p>LDC </p>
<p>&quot;Hello:&quot;</p>
<p>18</p>
<p>INVOKESPECIAL java/lang/StringBuilder. <init> (Ljava/lang/String;)V
19</p>
<p>ALOAD </p>
<p>1</p>
<p>20</p>
<p>INVOKEVIRTUAL java/lang/StringBuilder.append (Ljava/lang/String;)
21</p>
<p>Ljava/lang/StringBuilder;</p>
<p>22</p>
<p>INVOKEVIRTUAL java/lang/StringBuilder.toString ()Ljava/lang/String;
23</p>
<p>ARETURN</p>
<p>24</p>
<p>MAXSTACK = </p>
<p>3
25</p>
<p>MAXLOCALS = </p>
<p>2</p>
<p>26</p>
<p>}<a href=""><strong>清单 6. 生成 SayHelloImpl.class 的 ASM Code</strong></a>01</p>
<p>package</p>
<p>asm.com.ibm.was.asm;</p>
<p>02</p>
<p>import</p>
<p>java.util./*;
03</p>
<p>import</p>
<p>org.objectweb.asm./*;</p>
<p>04</p>
<p>import</p>
<p>org.objectweb.asm.attrs./*;
05</p>
<p>public</p>
<p>class</p>
<p>SayHelloImplDump </p>
<p>implements</p>
<p>Opcodes {</p>
<p>06</p>
<p>public</p>
<p>static</p>
<p>byte</p>
<p>[] dump () </p>
<p>throws</p>
<p>Exception {
07</p>
<p>ClassWriter cw = </p>
<p>new</p>
<p>ClassWriter(</p>
<p>0</p>
<p>);</p>
<p>08</p>
<p>FieldVisitor fv;
09</p>
<p>MethodVisitor mv;</p>
<p>10</p>
<p>AnnotationVisitor av0;
11</p>
<p>12</p>
<p>cw.visit(V1_6, ACC_PUBLIC + ACC_SUPER, </p>
<p>&quot;com/ibm/was/asm/SayHelloImpl&quot;</p>
<p>,
13</p>
<p>null</p>
<p>, </p>
<p>&quot;java/lang/Object&quot;</p>
<p>, </p>
<p>null</p>
<p>);</p>
<p>14</p>
<p>15</p>
<p>{</p>
<p>16</p>
<p>mv = cw.visitMethod(ACC_PUBLIC, </p>
<p>&quot;<init>&quot;</p>
<p>, </p>
<p>&quot;()V&quot;</p>
<p>, </p>
<p>null</p>
<p>, </p>
<p>null</p>
<p>);
17</p>
<p>mv.visitCode();</p>
<p>18</p>
<p>mv.visitVarInsn(ALOAD, </p>
<p>0</p>
<p>);
19</p>
<p>mv.visitMethodInsn(INVOKESPECIAL, </p>
<p>&quot;java/lang/Object&quot;</p>
<p>, </p>
<p>&quot;<init>&quot;</p>
<p>, </p>
<p>&quot;()V&quot;</p>
<p>);</p>
<p>20</p>
<p>mv.visitInsn(RETURN);
21</p>
<p>mv.visitMaxs(</p>
<p>1</p>
<p>, </p>
<p>1</p>
<p>);</p>
<p>22</p>
<p>mv.visitEnd();
23</p>
<p>}</p>
<p>24</p>
<p>{
25</p>
<p>mv = cw.visitMethod(ACC_PUBLIC, </p>
<p>&quot;sayHello&quot;</p>
<p>,</p>
<p>26</p>
<p>&quot;(Ljava/lang/String;)Ljava/lang/String;&quot;</p>
<p>, </p>
<p>null</p>
<p>, </p>
<p>null</p>
<p>);
27</p>
<p>mv.visitCode();</p>
<p>28</p>
<p>mv.visitTypeInsn(NEW, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>);
29</p>
<p>mv.visitInsn(DUP);</p>
<p>30</p>
<p>mv.visitLdcInsn(</p>
<p>&quot;Hello:&quot;</p>
<p>);
31</p>
<p>mv.visitMethodInsn(INVOKESPECIAL, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>,</p>
<p>32</p>
<p>&quot;<init>&quot;</p>
<p>, </p>
<p>&quot;(Ljava/lang/String;)V&quot;</p>
<p>);
33</p>
<p>mv.visitVarInsn(ALOAD, </p>
<p>1</p>
<p>);</p>
<p>34</p>
<p>mv.visitMethodInsn(INVOKEVIRTUAL, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>,
35</p>
<p>&quot;append&quot;</p>
<p>, </p>
<p>&quot;(Ljava/lang/String;)Ljava/lang/StringBuilder;&quot;</p>
<p>);</p>
<p>36</p>
<p>mv.visitMethodInsn(INVOKEVIRTUAL, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>,
37</p>
<p>&quot;toString&quot;</p>
<p>, </p>
<p>&quot;()Ljava/lang/String;&quot;</p>
<p>);</p>
<p>38</p>
<p>mv.visitInsn(ARETURN);
39</p>
<p>mv.visitMaxs(</p>
<p>3</p>
<p>, </p>
<p>2</p>
<p>);</p>
<p>40</p>
<p>mv.visitEnd();
41</p>
<p>}</p>
<p>42</p>
<p>cw.visitEnd();
43</p>
<p>return</p>
<p>cw.toByteArray();</p>
<p>44</p>
<p>}
45</p>
<p>}</p>
<p>图 1 描述了 Java Source 文件、Java Class 文件、ASM Code 文件和 ASM Source 文件之间的转换关系。
<a href=""><strong>图 1. 四种文件的转换图</strong></a> 
<a href=""><img src="" alt="图 1. 四种文件的转换图"></a> </p>
<p>如图 -1 所示，Java Source 文件通过 Javac 可以转换为 Java Class 文件。而相应的 Java Class 文件通过 Java 反编译器工具可转换为 Java Source 文件；</p>
<p>通 过 ASM Code 去创建和修改 Java Class 需要对 ASM API 比较熟悉才行，一个常见的问题时，怎么用 ASM Code 生成一个我们希望的 class 文件， 也就是说， 给定了 Java Class， 怎么得到其对应的 ASM Code 呢？ 所幸的是， ASM 框架为我们提供了 ASMifierClassVisitor 工具来产生 Java Class 对应的 ASM Code。代码如下：
<a href=""><strong>清单 7. 给定 class 文件，通过 ASMifierClassVisitor 获得其对应的 ASM Code</strong></a><a href="http://www.oschina.net/question/129540_28430#viewSource" title="view source" target="_blank">view source</a><a href="http://www.oschina.net/question/129540_28430#printSource" title="print" target="_blank">print</a><a href="http://www.oschina.net/question/129540_28430#about" title="?" target="_blank">?</a></p>
<p>01</p>
<p>public</p>
<p>void</p>
<p>showClassASMProcess() {</p>
<p>02</p>
<p>ClassReader cr;
03</p>
<p>final</p>
<p>String n = SayHelloImpl.</p>
<p>class</p>
<p>.getName();</p>
<p>04</p>
<p>05</p>
<p>try</p>
<p>{</p>
<p>06</p>
<p>cr = </p>
<p>new</p>
<p>ClassReader(n);<br>07</p>
<p>cr.accept(</p>
<p>new</p>
<p>ASMifierClassVisitor(</p>
<p>new</p>
<p>PrintWriter(System.out)),</p>
<p>08</p>
<p>new</p>
<p>Attribute[</p>
<p>0</p>
<p>],
09</p>
<p>ClassReader.SKIP_DEBUG);</p>
<p>10</p>
<p>11</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {</p>
<p>12</p>
<p>e.printStackTrace();
13</p>
<p>}</p>
<p>14</p>
<p>}</p>
<p>另外一个重要的转换就是， 给定了 Java Class 文件， 如何查看它的 ASM Source ？ 这点对于我们验证 ASM Code 生成的 class 是否正确很有用。ASM 提供了另外一个工具 TraceClassVisitor， 来获得一个 Java Class 对应的 ASM Source。代码如下：
<a href=""><strong>清单 8. 利用 TraceClassVisitor 查看 class 文件的 ASM Source</strong></a>01</p>
<p>//file 是 class 文件的全路径名</p>
<p>02</p>
<p>public</p>
<p>void</p>
<p>showClassSource(String file) {
03</p>
<p>FileInputStream is ;</p>
<p>04</p>
<p>ClassReader cr; 
05</p>
<p>06</p>
<p>try</p>
<p>{
07</p>
<p>is = </p>
<p>new</p>
<p>FileInputStream(file);     </p>
<p>08</p>
<p>cr = </p>
<p>new</p>
<p>ClassReader(is);
09</p>
<p>TraceClassVisitor trace = </p>
<p>new</p>
<p>TraceClassVisitor(</p>
<p>new</p>
<p>PrintWriter(System.out));</p>
<p>10</p>
<p>cr.accept(trace, ClassReader.SKIP_DEBUG);
11</p>
<p>12</p>
<p>is.close() ;
13</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {</p>
<p>14</p>
<p>e.printStackTrace() ;
15</p>
<p>}</p>
<p>16</p>
<p>}
17</p>
<p>{</p>
<p>18</p>
<p>e.printStackTrace();
19</p>
<p>}</p>
<p>20</p>
<p>}</p>
<p><a href="">ASM 类注入</a></p>
<p>ASM 类注入是指修改一个现有的 class 文件，在其中加入自己的代码。按通常思维，我们需要利用 ASM 提供的 reader 类去读取所要修改的类文件， 找到要修改的地方，如方法名或属性名，然后在该处插入自己的代码或修改现有的代码，这种思路将使问题复杂化。 ASM 为我们提供了访问类文件的 Visitor 模式，来遍历一个 class 文件，Visitor 是一个实现 ClassVisitor 接口的类。 要注入一个 class 文件，先要找到一个合适的 Visitor 做向导， ASM 提供了好几种 Visitor， 最常用的是 ClassWriter。同时我们需要提供一个适配器类 ClassAdapter， Visitor 会带着这个 Adapter 一起去遍历， 然后在遍历过程中回调 Adapter 提供的方法。我们在 Adapter 的这些方法中就可以实现我们的修改和定制逻辑。当然，如果你不想做任何修改，那 Visitor 遍历完后将得到一个和被遍历的 class 完全一样的拷贝。
<a href=""><strong>清单 9. 类注入的完整过程</strong></a>01</p>
<p>public</p>
<p>void</p>
<p>addAnnotationToExistingClass() {</p>
<p>02</p>
<p>FileInputStream is ;
03</p>
<p>ClassReader cr;          </p>
<p>04</p>
<p>try</p>
<p>{<br>05</p>
<p>String classfile = </p>
<p>&quot;E:\SayHelloImpl.class&quot;</p>
<p>; </p>
<p>// 待遍历的类</p>
<p>06</p>
<p>showClassSource(classfile) ;  </p>
<p>// 打印该类的 ASM source
07</p>
<p>08</p>
<p>is = </p>
<p>new</p>
<p>FileInputStream(classfile);<br>09</p>
<p>cr = </p>
<p>new</p>
<p>ClassReader(is);</p>
<p>10</p>
<p>// 此处我们使用 ClassWriter 做 Visitor
11</p>
<p>ClassWriter cw = </p>
<p>new</p>
<p>ClassWriter(ClassWriter.COMPUTE_MAXS);</p>
<p>12</p>
<p>// 给 Visitor 提供一个 Adapter
13</p>
<p>AddAnnotationAdapter adapter = </p>
<p>new</p>
<p>AddAnnotationAdapter(cw);           </p>
<p>14</p>
<p>cr.accept(adapter, ClassReader.SKIP_DEBUG);<br>15</p>
<p>16</p>
<p>// 遍历完后，生成的 class 保存在字节数组中
17</p>
<p>byte</p>
<p>[] b = cw.toByteArray();</p>
<p>18</p>
<p>19</p>
<p>try</p>
<p>{</p>
<p>20</p>
<p>// 将字节数组输出到文件中
21</p>
<p>// 为了不至于覆盖掉原有的 SayHelloImpl.class 文件，我们将结果输出到 _SayHelloImpl.class</p>
<p>22</p>
<p>FileOutputStream fout = </p>
<p>new</p>
<p>FileOutputStream(</p>
<p>&quot;E:\_SayHelloImpl.class&quot;</p>
<p>);
23</p>
<p>fout.write(b) ;</p>
<p>24</p>
<p>fout.flush();
25</p>
<p>fout.close() ;</p>
<p>26</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {
27</p>
<p>e.printStackTrace() ;</p>
<p>28</p>
<p>}
29</p>
<p>30</p>
<p>// 验证 _SayHelloImpl.class 是否包含我们注入的代码
31</p>
<p>showClassSource(</p>
<p>&quot;E:\_SayHelloImpl.class&quot;</p>
<p>) ;</p>
<p>32</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {
33</p>
<p>e.printStackTrace();</p>
<p>34</p>
<p>} 
35</p>
<p>}</p>
<p><a href="">web services 标记注入过程</a></p>
<p>我们已经知道了如何往 class 中注入自己的代码，那对于一个已有的 Java bean，怎么往里注入 @WebService 和 @WebMethod 呢？根据上面我们讲的转换关系，我们可以先写一个带 annotation 的 Java Source，编译得到 Java Class， 再得到其 ASM Code。下面是利用 ASM 给一个不带任何 Annotation 的 class 添加 @WebService 和 @WebMethod 的步骤。</p>
<ol>
<li>首先在 SayHelloImpl.java 中添加 @WebService 和 @WebMethod： 
<a href=""><strong>清单 10. 带 web services 标注的 SayHelloImpl 类</strong></a>1</li>
</ol>
<p>@WebService</p>
<p>2</p>
<p>public</p>
<p>class</p>
<p>SayHelloImpl {
3</p>
<p>@WebMethod</p>
<p>4</p>
<p>public</p>
<p>String sayHello(String s) {
5</p>
<p>return</p>
<p>&quot;Hello: &quot;</p>
<ul>
<li>s ;</li>
</ul>
<p>6</p>
<p>}
7</p>
<p>}</p>
<ol>
<li>通过 ASMifierClassVisitor 工具获得 SayHelloImpl class 的 ASM Code，见清单 6。</li>
<li>写一个 ClassAdapter 类， ClassAdapter 其实也是一个 Visitor。根据 ASM Code 的提示， 我们就可以知道如何利用 ASM API 去获得我们希望的 class 文件。下面是 Adapter 的示例代码。 
<a href=""><strong>清单 11. 添加 Annotation 的 Adapter 类</strong></a>01</li>
</ol>
<p>public</p>
<p>class</p>
<p>AddAnnotationAdapter </p>
<p>extends</p>
<p>ClassAdapter </p>
<p>implements</p>
<p>Opcodes{</p>
<p>02</p>
<p>//private String annotationDesc;
03</p>
<p>private</p>
<p>boolean</p>
<p>isAnnotationPresent;</p>
<p>04</p>
<p>05</p>
<p>public</p>
<p>AddAnnotationAdapter(ClassVisitor cv) {</p>
<p>06</p>
<p>super</p>
<p>(cv);
07</p>
<p>}</p>
<p>08</p>
<p>09</p>
<p>@Override</p>
<p>10</p>
<p>public</p>
<p>void</p>
<p>visit(</p>
<p>int</p>
<p>version, </p>
<p>int</p>
<p>access, String name, String signature,
11</p>
<p>String superName, String[] interfaces) {</p>
<p>12</p>
<p>13</p>
<p>cv.visit(V1_6, ACC_PUBLIC + ACC_SUPER, name, signature, superName,</p>
<p>14</p>
<p>interfaces);
15</p>
<p>AnnotationVisitor av0;</p>
<p>16</p>
<p>av0 = cv.visitAnnotation(</p>
<p>&quot;Ljavax/jws/WebService;&quot;</p>
<p>, </p>
<p>true</p>
<p>);
17</p>
<p>av0.visitEnd();</p>
<p>18</p>
<p>}
19</p>
<p>20</p>
<p>@Override
21</p>
<p>public</p>
<p>AnnotationVisitor visitAnnotation(String desc, </p>
<p>boolean</p>
<p>visible) {</p>
<p>22</p>
<p>return</p>
<p>cv.visitAnnotation(desc, visible);
23</p>
<p>}</p>
<p>24</p>
<p>25</p>
<p>@Override</p>
<p>26</p>
<p>public</p>
<p>void</p>
<p>visitInnerClass(String name, String outerName,
27</p>
<p>String innerName, </p>
<p>int</p>
<p>access) {</p>
<p>28</p>
<p>cv.visitInnerClass(name, outerName, innerName, access);
29</p>
<p>}</p>
<p>30</p>
<p>31</p>
<p>@Override</p>
<p>32</p>
<p>public</p>
<p>FieldVisitor visitField(</p>
<p>int</p>
<p>access, String name, String desc,
33</p>
<p>String signature, Object value) {</p>
<p>34</p>
<p>return</p>
<p>cv.visitField(access, name, desc, signature, value);
35</p>
<p>}</p>
<p>36</p>
<p>37</p>
<p>@Override</p>
<p>38</p>
<p>public</p>
<p>MethodVisitor visitMethod(</p>
<p>int</p>
<p>access, String name, String desc,
39</p>
<p>String signature, String[] exceptions) {   </p>
<p>40</p>
<p>MethodVisitor mv  = cv.visitMethod(access, name, desc, signature,
41</p>
<p>exceptions);</p>
<p>42</p>
<p>if</p>
<p>(!name.equals(</p>
<p>&quot;<init>&quot;</p>
<p>)) {
43</p>
<p>AnnotationVisitor av0;</p>
<p>44</p>
<p>av0 = mv.visitAnnotation(</p>
<p>&quot;Ljavax/jws/WebMethod;&quot;</p>
<p>, </p>
<p>true</p>
<p>);
45</p>
<p>av0.visitEnd();</p>
<p>46</p>
<p>}
47</p>
<p>return</p>
<p>mv;</p>
<p>48</p>
<p>}
49</p>
<p>50</p>
<p>@Override
51</p>
<p>public</p>
<p>void</p>
<p>visitEnd() {</p>
<p>52</p>
<p>cv.visitEnd();
53</p>
<p>}</p>
<p>54</p>
<p>55</p>
<p>}</p>
<p>最后，我们采用上面讲的类注入办法，即可得到一个带 @WebService 和 @WebMethod 标注的 class 文件。再通过 wsgen 工具即可成功创建 web services，该命令将会在 src 目录下生成 web services 描述文件：SayHelloImplService.wsdl，SayHelloImplService_schema1.xsd，同时生成了 2 个 JAX-WS 文件，分别为：SayHello.java，SayHelloResponse.java。</p>
<p>当然，在实际应用中，我们可能需要将一个 class 的某些特定方法发布为 web services，这就需要我们对 Adapter 做进一步的改造，在 visitMethod() 方法中根据方法名称等参数做进一步的处理。</p>
<p><a href="">结束语</a></p>
<p>本文简要介绍了 ASM 字节码工具及其在 web services 开发中的应用。web services 的使用已经越来越广泛， 但在改造遗留系统过程中会遇到不少问题，本文针对其中一个主要问题给出了解决办法，该方法无须对现有系统做大量的改动， 即可将现存的 Java bean 转化成 web services 。本文对那些正考虑迁移到 JAX-WS 编程模型上的项目有一定的参考价值。在基于 JAX-WS 标准的 web services 的开发中，不少实际场景都是希望采用自底向上的开发方式， 即基于已有的 Java bean 来创建 web services 。WebSphere Application Server ( 以下简称 WAS ) 提供了命令行的工具 wsgen 和相对应的 Ant task 来支持这种开发过程，而且这两个工具比较适合大型项目的自动化构建。 这两个工具的使用前提是 Java bean 中事先添加有 web services 的 Annotation 标注，而在现有的业务系统中，class 文件一般是不带 Annotation 的，这就需要开发人员去修改现有的代码，以手工方式添加 Annotation，但这样带来的工作量太大且容易出错。本文介绍了一种解决途径，可以不用修改源代码，而是利用字节码工具 ASM 直接修改 class 文件， 在字节码文件中自动注入 Annotation ，然后再利用 wsgen 工具就可以很方便地生成 web services 应用。 本文同时也总结了使用 ASM 的一些实践。</p>
<p>本文首先介绍了和 ASM 使用相关的四种文件，以及它们之间的相互转化。然后结合 web services 开发实例，介绍了使用 wsgen 开发时遇到的实际问题，如何写一个 ASM 的适配器去修改现有 class，最终如何产生 web services 文件。</p>
<p>ASM 是一个多用途的 Java 字节码操控和分析框架。它能以二进制的形式直接修改现有的类或动态生成的类。 ASM 提供了常用的转换和分析算法，是一种允许用户方便的组装定制化的复杂转换和代码分析工具。 ASM 也提供和其它的字节码工具类似的功能，但 ASM 的重点是使用的简单和高性能。由于 ASM 在设计实现的时候尽可能 的小的内存占用和提供更高的性能；因此在动态系统中使用 ASM 是很有优势的。ASM 作为一种轻量级、高性能的 Java 字节码操控和分析框架，设计了一种更有效的方法、提供更好的性能和内存占用。今天， ASM 在许多领域都有应用，并已成为事实上的字节码处理框架标准。</p>
<p><a href="">问题的引入</a></p>
<p>先写一个不带 web services 标注的 SayHelloImpl 类。
<a href=""><strong>清单 1. 不带 web services 的 SayHelloImpl 类</strong></a>1</p>
<p>public</p>
<p>class</p>
<p>SayHelloImpl {</p>
<p>2</p>
<p>public</p>
<p>String sayHello(String s) {
3</p>
<p>return</p>
<p>“Hello: ” + s ;</p>
<p>4</p>
<p>}
5</p>
<p>}</p>
<p>再用 wsgen 来创建 web services，wsgen 的使用如下：
<a href=""><strong>清单 2. wsgen 实例</strong></a>1</p>
<p>wsgen.exe – </p>
<p>cp</p>
<p>bin – s output – d output – r output – wsdl ibm.was.asm.SayHelloImpl我们将会遇到如下错误： 
<a href=""><strong>清单 3. 根据不带 web services 标注的类创建 web services 时遇到的错误信息</strong></a> 
注释处理过程中遇到问题；</p>
<p>......
com.sun.tools.internal.ws.processor.modeler.ModelerException: [failed to localiz</p>
<p>e] A web service endpoint could not be found()
        at com.sun.tools.internal.ws.processor.modeler.annotation.WebServiceAP.o</p>
<p>nError(WebServiceAP.java:215)
        at com.sun.tools.internal.ws.processor.modeler.annotation.WebServiceAP.b</p>
<p>uildModel(WebServiceAP.java:322)
        at com.sun.tools.internal.ws.processor.modeler.annotation.WebServiceAP.p</p>
<p>rocess(WebServiceAP.java:256)
        at com.sun.mirror.apt.AnnotationProcessors$CompositeAnnotationProcessor.</p>
<p>process(AnnotationProcessors.java:60)</p>
<p>注意：我们通常是在 class 前使用 @WebService， 在方法前使用 @WebMethod 来将一个类标注为 web services 的。WAS 6.1 的 web services 功能部件包和 WAS 7 都支持基于 JAX-WS 标准 的 web services 的开发， 在 WAS 安装目录的 bin 目录下提供了命令行工具 wsgen，wsgen 支持自底向上的开发方式。 下面是 wsgen 的用法：
<a href=""><strong>清单 4. wsgen 命令格式</strong></a> 
注 wsgen [options]  [SEI]</p>
<p>主要选项：</p>
<ul>
<li>-d 指定生成的 class 文件位置；</li>
<li>-s 指定生成的 Java 源文件位置；</li>
<li>-r 指定生成的 resources 文件位置，如 wsdl，xsd；</li>
<li>-cp 指定服务实现类所在的位置；</li>
<li>-wsdl，-servicename，-portname 三个参数指定生成的 wsdl 文件中的 service 和 port 的名称。</li>
</ul>
<p>SEI(Service Endpoint Interface) 是一个 endpoint implementation class，不能是一个 interface。所以首先要开发一个 endpoint 的实现类，如本例中的 SayHelloImpl 。用 @WebService 声明 web services ，然后将它编译，才能提供给 wsgen 来创建 web services 。</p>
<p><a href="">四种文件之间的转换</a></p>
<p>下面介绍本文要用到的四个概念（Java Source，Java Class，ASM Code，ASM Source）</p>
<ul>
<li>Java Source: 即我们通常编写的 Java 源文件；</li>
<li>Java Class: Java 源文件编译后的字节码文件；</li>
<li>ASM Source : 类似于对 class 反编译后的源文件，也就是 &quot;textual byte code&quot;，但比原始的 Java Source 可读性要差， 参见清单 5。</li>
<li>ASM Code: 指读写 class 文件的 ASM 程序代码。需要用到 ASM 提供的 API， 参见清单 6。
<a href=""><strong>清单 5. SayHelloImpl 类对应的 ASM Source</strong></a>01</li>
</ul>
<p>// class version 50.0 (50)</p>
<p>02</p>
<p>// access flags 33
03</p>
<p>public</p>
<p>class</p>
<p>com/ibm/was/asm/SayHelloImpl {</p>
<p>04</p>
<p>05</p>
<p>// access flags 1</p>
<p>06</p>
<p>public</p>
<p><init>()V
07</p>
<p>ALOAD </p>
<p>0</p>
<p>08</p>
<p>INVOKESPECIAL java/lang/Object. <init> ()V
09</p>
<p>RETURN</p>
<p>10</p>
<p>MAXSTACK = </p>
<p>1
11</p>
<p>MAXLOCALS = </p>
<p>1</p>
<p>12</p>
<p>13</p>
<p>// access flags 1</p>
<p>14</p>
<p>public</p>
<p>sayHello(Ljava/lang/String;)Ljava/lang/String;
15</p>
<p>NEW java/lang/StringBuilder</p>
<p>16</p>
<p>DUP
17</p>
<p>LDC </p>
<p>&quot;Hello:&quot;</p>
<p>18</p>
<p>INVOKESPECIAL java/lang/StringBuilder. <init> (Ljava/lang/String;)V
19</p>
<p>ALOAD </p>
<p>1</p>
<p>20</p>
<p>INVOKEVIRTUAL java/lang/StringBuilder.append (Ljava/lang/String;)
21</p>
<p>Ljava/lang/StringBuilder;</p>
<p>22</p>
<p>INVOKEVIRTUAL java/lang/StringBuilder.toString ()Ljava/lang/String;
23</p>
<p>ARETURN</p>
<p>24</p>
<p>MAXSTACK = </p>
<p>3
25</p>
<p>MAXLOCALS = </p>
<p>2</p>
<p>26</p>
<p>}<a href=""><strong>清单 6. 生成 SayHelloImpl.class 的 ASM Code</strong></a>01</p>
<p>package</p>
<p>asm.com.ibm.was.asm;</p>
<p>02</p>
<p>import</p>
<p>java.util./*;
03</p>
<p>import</p>
<p>org.objectweb.asm./*;</p>
<p>04</p>
<p>import</p>
<p>org.objectweb.asm.attrs./*;
05</p>
<p>public</p>
<p>class</p>
<p>SayHelloImplDump </p>
<p>implements</p>
<p>Opcodes {</p>
<p>06</p>
<p>public</p>
<p>static</p>
<p>byte</p>
<p>[] dump () </p>
<p>throws</p>
<p>Exception {
07</p>
<p>ClassWriter cw = </p>
<p>new</p>
<p>ClassWriter(</p>
<p>0</p>
<p>);</p>
<p>08</p>
<p>FieldVisitor fv;
09</p>
<p>MethodVisitor mv;</p>
<p>10</p>
<p>AnnotationVisitor av0;
11</p>
<p>12</p>
<p>cw.visit(V1_6, ACC_PUBLIC + ACC_SUPER, </p>
<p>&quot;com/ibm/was/asm/SayHelloImpl&quot;</p>
<p>,
13</p>
<p>null</p>
<p>, </p>
<p>&quot;java/lang/Object&quot;</p>
<p>, </p>
<p>null</p>
<p>);</p>
<p>14</p>
<p>15</p>
<p>{</p>
<p>16</p>
<p>mv = cw.visitMethod(ACC_PUBLIC, </p>
<p>&quot;<init>&quot;</p>
<p>, </p>
<p>&quot;()V&quot;</p>
<p>, </p>
<p>null</p>
<p>, </p>
<p>null</p>
<p>);
17</p>
<p>mv.visitCode();</p>
<p>18</p>
<p>mv.visitVarInsn(ALOAD, </p>
<p>0</p>
<p>);
19</p>
<p>mv.visitMethodInsn(INVOKESPECIAL, </p>
<p>&quot;java/lang/Object&quot;</p>
<p>, </p>
<p>&quot;<init>&quot;</p>
<p>, </p>
<p>&quot;()V&quot;</p>
<p>);</p>
<p>20</p>
<p>mv.visitInsn(RETURN);
21</p>
<p>mv.visitMaxs(</p>
<p>1</p>
<p>, </p>
<p>1</p>
<p>);</p>
<p>22</p>
<p>mv.visitEnd();
23</p>
<p>}</p>
<p>24</p>
<p>{
25</p>
<p>mv = cw.visitMethod(ACC_PUBLIC, </p>
<p>&quot;sayHello&quot;</p>
<p>,</p>
<p>26</p>
<p>&quot;(Ljava/lang/String;)Ljava/lang/String;&quot;</p>
<p>, </p>
<p>null</p>
<p>, </p>
<p>null</p>
<p>);
27</p>
<p>mv.visitCode();</p>
<p>28</p>
<p>mv.visitTypeInsn(NEW, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>);
29</p>
<p>mv.visitInsn(DUP);</p>
<p>30</p>
<p>mv.visitLdcInsn(</p>
<p>&quot;Hello:&quot;</p>
<p>);
31</p>
<p>mv.visitMethodInsn(INVOKESPECIAL, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>,</p>
<p>32</p>
<p>&quot;<init>&quot;</p>
<p>, </p>
<p>&quot;(Ljava/lang/String;)V&quot;</p>
<p>);
33</p>
<p>mv.visitVarInsn(ALOAD, </p>
<p>1</p>
<p>);</p>
<p>34</p>
<p>mv.visitMethodInsn(INVOKEVIRTUAL, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>,
35</p>
<p>&quot;append&quot;</p>
<p>, </p>
<p>&quot;(Ljava/lang/String;)Ljava/lang/StringBuilder;&quot;</p>
<p>);</p>
<p>36</p>
<p>mv.visitMethodInsn(INVOKEVIRTUAL, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>,
37</p>
<p>&quot;toString&quot;</p>
<p>, </p>
<p>&quot;()Ljava/lang/String;&quot;</p>
<p>);</p>
<p>38</p>
<p>mv.visitInsn(ARETURN);
39</p>
<p>mv.visitMaxs(</p>
<p>3</p>
<p>, </p>
<p>2</p>
<p>);</p>
<p>40</p>
<p>mv.visitEnd();
41</p>
<p>}</p>
<p>42</p>
<p>cw.visitEnd();
43</p>
<p>return</p>
<p>cw.toByteArray();</p>
<p>44</p>
<p>}
45</p>
<p>}</p>
<p>图 1 描述了 Java Source 文件、Java Class 文件、ASM Code 文件和 ASM Source 文件之间的转换关系。
<a href=""><strong>图 1. 四种文件的转换图</strong></a> 
<a href=""><img src="" alt="图 1. 四种文件的转换图"></a> </p>
<p>如图 -1 所示，Java Source 文件通过 Javac 可以转换为 Java Class 文件。而相应的 Java Class 文件通过 Java 反编译器工具可转换为 Java Source 文件；</p>
<p>通 过 ASM Code 去创建和修改 Java Class 需要对 ASM API 比较熟悉才行，一个常见的问题时，怎么用 ASM Code 生成一个我们希望的 class 文件， 也就是说， 给定了 Java Class， 怎么得到其对应的 ASM Code 呢？ 所幸的是， ASM 框架为我们提供了 ASMifierClassVisitor 工具来产生 Java Class 对应的 ASM Code。代码如下：
<a href=""><strong>清单 7. 给定 class 文件，通过 ASMifierClassVisitor 获得其对应的 ASM Code</strong></a><a href="http://www.oschina.net/question/129540_28430#viewSource" title="view source" target="_blank">view source</a><a href="http://www.oschina.net/question/129540_28430#printSource" title="print" target="_blank">print</a><a href="http://www.oschina.net/question/129540_28430#about" title="?" target="_blank">?</a></p>
<p>01</p>
<p>public</p>
<p>void</p>
<p>showClassASMProcess() {</p>
<p>02</p>
<p>ClassReader cr;
03</p>
<p>final</p>
<p>String n = SayHelloImpl.</p>
<p>class</p>
<p>.getName();</p>
<p>04</p>
<p>05</p>
<p>try</p>
<p>{</p>
<p>06</p>
<p>cr = </p>
<p>new</p>
<p>ClassReader(n);<br>07</p>
<p>cr.accept(</p>
<p>new</p>
<p>ASMifierClassVisitor(</p>
<p>new</p>
<p>PrintWriter(System.out)),</p>
<p>08</p>
<p>new</p>
<p>Attribute[</p>
<p>0</p>
<p>],
09</p>
<p>ClassReader.SKIP_DEBUG);</p>
<p>10</p>
<p>11</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {</p>
<p>12</p>
<p>e.printStackTrace();
13</p>
<p>}</p>
<p>14</p>
<p>}</p>
<p>另外一个重要的转换就是， 给定了 Java Class 文件， 如何查看它的 ASM Source ？ 这点对于我们验证 ASM Code 生成的 class 是否正确很有用。ASM 提供了另外一个工具 TraceClassVisitor， 来获得一个 Java Class 对应的 ASM Source。代码如下：
<a href=""><strong>清单 8. 利用 TraceClassVisitor 查看 class 文件的 ASM Source</strong></a>01</p>
<p>//file 是 class 文件的全路径名</p>
<p>02</p>
<p>public</p>
<p>void</p>
<p>showClassSource(String file) {
03</p>
<p>FileInputStream is ;</p>
<p>04</p>
<p>ClassReader cr; 
05</p>
<p>06</p>
<p>try</p>
<p>{
07</p>
<p>is = </p>
<p>new</p>
<p>FileInputStream(file);     </p>
<p>08</p>
<p>cr = </p>
<p>new</p>
<p>ClassReader(is);
09</p>
<p>TraceClassVisitor trace = </p>
<p>new</p>
<p>TraceClassVisitor(</p>
<p>new</p>
<p>PrintWriter(System.out));</p>
<p>10</p>
<p>cr.accept(trace, ClassReader.SKIP_DEBUG);
11</p>
<p>12</p>
<p>is.close() ;
13</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {</p>
<p>14</p>
<p>e.printStackTrace() ;
15</p>
<p>}</p>
<p>16</p>
<p>}
17</p>
<p>{</p>
<p>18</p>
<p>e.printStackTrace();
19</p>
<p>}</p>
<p>20</p>
<p>}</p>
<p><a href="">ASM 类注入</a></p>
<p>ASM 类注入是指修改一个现有的 class 文件，在其中加入自己的代码。按通常思维，我们需要利用 ASM 提供的 reader 类去读取所要修改的类文件， 找到要修改的地方，如方法名或属性名，然后在该处插入自己的代码或修改现有的代码，这种思路将使问题复杂化。 ASM 为我们提供了访问类文件的 Visitor 模式，来遍历一个 class 文件，Visitor 是一个实现 ClassVisitor 接口的类。 要注入一个 class 文件，先要找到一个合适的 Visitor 做向导， ASM 提供了好几种 Visitor， 最常用的是 ClassWriter。同时我们需要提供一个适配器类 ClassAdapter， Visitor 会带着这个 Adapter 一起去遍历， 然后在遍历过程中回调 Adapter 提供的方法。我们在 Adapter 的这些方法中就可以实现我们的修改和定制逻辑。当然，如果你不想做任何修改，那 Visitor 遍历完后将得到一个和被遍历的 class 完全一样的拷贝。
<a href=""><strong>清单 9. 类注入的完整过程</strong></a>01</p>
<p>public</p>
<p>void</p>
<p>addAnnotationToExistingClass() {</p>
<p>02</p>
<p>FileInputStream is ;
03</p>
<p>ClassReader cr;          </p>
<p>04</p>
<p>try</p>
<p>{<br>05</p>
<p>String classfile = </p>
<p>&quot;E:\SayHelloImpl.class&quot;</p>
<p>; </p>
<p>// 待遍历的类</p>
<p>06</p>
<p>showClassSource(classfile) ;  </p>
<p>// 打印该类的 ASM source
07</p>
<p>08</p>
<p>is = </p>
<p>new</p>
<p>FileInputStream(classfile);<br>09</p>
<p>cr = </p>
<p>new</p>
<p>ClassReader(is);</p>
<p>10</p>
<p>// 此处我们使用 ClassWriter 做 Visitor
11</p>
<p>ClassWriter cw = </p>
<p>new</p>
<p>ClassWriter(ClassWriter.COMPUTE_MAXS);</p>
<p>12</p>
<p>// 给 Visitor 提供一个 Adapter
13</p>
<p>AddAnnotationAdapter adapter = </p>
<p>new</p>
<p>AddAnnotationAdapter(cw);           </p>
<p>14</p>
<p>cr.accept(adapter, ClassReader.SKIP_DEBUG);<br>15</p>
<p>16</p>
<p>// 遍历完后，生成的 class 保存在字节数组中
17</p>
<p>byte</p>
<p>[] b = cw.toByteArray();</p>
<p>18</p>
<p>19</p>
<p>try</p>
<p>{</p>
<p>20</p>
<p>// 将字节数组输出到文件中
21</p>
<p>// 为了不至于覆盖掉原有的 SayHelloImpl.class 文件，我们将结果输出到 _SayHelloImpl.class</p>
<p>22</p>
<p>FileOutputStream fout = </p>
<p>new</p>
<p>FileOutputStream(</p>
<p>&quot;E:\_SayHelloImpl.class&quot;</p>
<p>);
23</p>
<p>fout.write(b) ;</p>
<p>24</p>
<p>fout.flush();
25</p>
<p>fout.close() ;</p>
<p>26</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {
27</p>
<p>e.printStackTrace() ;</p>
<p>28</p>
<p>}
29</p>
<p>30</p>
<p>// 验证 _SayHelloImpl.class 是否包含我们注入的代码
31</p>
<p>showClassSource(</p>
<p>&quot;E:\_SayHelloImpl.class&quot;</p>
<p>) ;</p>
<p>32</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {
33</p>
<p>e.printStackTrace();</p>
<p>34</p>
<p>} 
35</p>
<p>}</p>
<p><a href="">web services 标记注入过程</a></p>
<p>我们已经知道了如何往 class 中注入自己的代码，那对于一个已有的 Java bean，怎么往里注入 @WebService 和 @WebMethod 呢？根据上面我们讲的转换关系，我们可以先写一个带 annotation 的 Java Source，编译得到 Java Class， 再得到其 ASM Code。下面是利用 ASM 给一个不带任何 Annotation 的 class 添加 @WebService 和 @WebMethod 的步骤。</p>
<ol>
<li>首先在 SayHelloImpl.java 中添加 @WebService 和 @WebMethod： 
<a href=""><strong>清单 10. 带 web services 标注的 SayHelloImpl 类</strong></a>1</li>
</ol>
<p>@WebService</p>
<p>2</p>
<p>public</p>
<p>class</p>
<p>SayHelloImpl {
3</p>
<p>@WebMethod</p>
<p>4</p>
<p>public</p>
<p>String sayHello(String s) {
5</p>
<p>return</p>
<p>&quot;Hello: &quot;</p>
<ul>
<li>s ;</li>
</ul>
<p>6</p>
<p>}
7</p>
<p>}</p>
<ol>
<li>通过 ASMifierClassVisitor 工具获得 SayHelloImpl class 的 ASM Code，见清单 6。</li>
<li>写一个 ClassAdapter 类， ClassAdapter 其实也是一个 Visitor。根据 ASM Code 的提示， 我们就可以知道如何利用 ASM API 去获得我们希望的 class 文件。下面是 Adapter 的示例代码。 
<a href=""><strong>清单 11. 添加 Annotation 的 Adapter 类</strong></a>01</li>
</ol>
<p>public</p>
<p>class</p>
<p>AddAnnotationAdapter </p>
<p>extends</p>
<p>ClassAdapter </p>
<p>implements</p>
<p>Opcodes{</p>
<p>02</p>
<p>//private String annotationDesc;
03</p>
<p>private</p>
<p>boolean</p>
<p>isAnnotationPresent;</p>
<p>04</p>
<p>05</p>
<p>public</p>
<p>AddAnnotationAdapter(ClassVisitor cv) {</p>
<p>06</p>
<p>super</p>
<p>(cv);
07</p>
<p>}</p>
<p>08</p>
<p>09</p>
<p>@Override</p>
<p>10</p>
<p>public</p>
<p>void</p>
<p>visit(</p>
<p>int</p>
<p>version, </p>
<p>int</p>
<p>access, String name, String signature,
11</p>
<p>String superName, String[] interfaces) {</p>
<p>12</p>
<p>13</p>
<p>cv.visit(V1_6, ACC_PUBLIC + ACC_SUPER, name, signature, superName,</p>
<p>14</p>
<p>interfaces);
15</p>
<p>AnnotationVisitor av0;</p>
<p>16</p>
<p>av0 = cv.visitAnnotation(</p>
<p>&quot;Ljavax/jws/WebService;&quot;</p>
<p>, </p>
<p>true</p>
<p>);
17</p>
<p>av0.visitEnd();</p>
<p>18</p>
<p>}
19</p>
<p>20</p>
<p>@Override
21</p>
<p>public</p>
<p>AnnotationVisitor visitAnnotation(String desc, </p>
<p>boolean</p>
<p>visible) {</p>
<p>22</p>
<p>return</p>
<p>cv.visitAnnotation(desc, visible);
23</p>
<p>}</p>
<p>24</p>
<p>25</p>
<p>@Override</p>
<p>26</p>
<p>public</p>
<p>void</p>
<p>visitInnerClass(String name, String outerName,
27</p>
<p>String innerName, </p>
<p>int</p>
<p>access) {</p>
<p>28</p>
<p>cv.visitInnerClass(name, outerName, innerName, access);
29</p>
<p>}</p>
<p>30</p>
<p>31</p>
<p>@Override</p>
<p>32</p>
<p>public</p>
<p>FieldVisitor visitField(</p>
<p>int</p>
<p>access, String name, String desc,
33</p>
<p>String signature, Object value) {</p>
<p>34</p>
<p>return</p>
<p>cv.visitField(access, name, desc, signature, value);
35</p>
<p>}</p>
<p>36</p>
<p>37</p>
<p>@Override</p>
<p>38</p>
<p>public</p>
<p>MethodVisitor visitMethod(</p>
<p>int</p>
<p>access, String name, String desc,
39</p>
<p>String signature, String[] exceptions) {   </p>
<p>40</p>
<p>MethodVisitor mv  = cv.visitMethod(access, name, desc, signature,
41</p>
<p>exceptions);</p>
<p>42</p>
<p>if</p>
<p>(!name.equals(</p>
<p>&quot;<init>&quot;</p>
<p>)) {
43</p>
<p>AnnotationVisitor av0;</p>
<p>44</p>
<p>av0 = mv.visitAnnotation(</p>
<p>&quot;Ljavax/jws/WebMethod;&quot;</p>
<p>, </p>
<p>true</p>
<p>);
45</p>
<p>av0.visitEnd();</p>
<p>46</p>
<p>}
47</p>
<p>return</p>
<p>mv;</p>
<p>48</p>
<p>}
49</p>
<p>50</p>
<p>@Override
51</p>
<p>public</p>
<p>void</p>
<p>visitEnd() {</p>
<p>52</p>
<p>cv.visitEnd();
53</p>
<p>}</p>
<p>54</p>
<p>55</p>
<p>}</p>
<p>最后，我们采用上面讲的类注入办法，即可得到一个带 @WebService 和 @WebMethod 标注的 class 文件。再通过 wsgen 工具即可成功创建 web services，该命令将会在 src 目录下生成 web services 描述文件：SayHelloImplService.wsdl，SayHelloImplService_schema1.xsd，同时生成了 2 个 JAX-WS 文件，分别为：SayHello.java，SayHelloResponse.java。</p>
<p>当然，在实际应用中，我们可能需要将一个 class 的某些特定方法发布为 web services，这就需要我们对 Adapter 做进一步的改造，在 visitMethod() 方法中根据方法名称等参数做进一步的处理。</p>
<p><a href="">结束语</a></p>
<p>本文简要介绍了 ASM 字节码工具及其在 web services 开发中的应用。web services 的使用已经越来越广泛， 但在改造遗留系统过程中会遇到不少问题，本文针对其中一个主要问题给出了解决办法，该方法无须对现有系统做大量的改动， 即可将现存的 Java bean 转化成 web services 。本文对那些正考虑迁移到 JAX-WS 编程模型上的项目有一定的参考价值。在基于 JAX-WS 标准的 web services 的开发中，不少实际场景都是希望采用自底向上的开发方式， 即基于已有的 Java bean 来创建 web services 。WebSphere Application Server ( 以下简称 WAS ) 提供了命令行的工具 wsgen 和相对应的 Ant task 来支持这种开发过程，而且这两个工具比较适合大型项目的自动化构建。 这两个工具的使用前提是 Java bean 中事先添加有 web services 的 Annotation 标注，而在现有的业务系统中，class 文件一般是不带 Annotation 的，这就需要开发人员去修改现有的代码，以手工方式添加 Annotation，但这样带来的工作量太大且容易出错。本文介绍了一种解决途径，可以不用修改源代码，而是利用字节码工具 ASM 直接修改 class 文件， 在字节码文件中自动注入 Annotation ，然后再利用 wsgen 工具就可以很方便地生成 web services 应用。 本文同时也总结了使用 ASM 的一些实践。</p>
<p>本文首先介绍了和 ASM 使用相关的四种文件，以及它们之间的相互转化。然后结合 web services 开发实例，介绍了使用 wsgen 开发时遇到的实际问题，如何写一个 ASM 的适配器去修改现有 class，最终如何产生 web services 文件。</p>
<p>ASM 是一个多用途的 Java 字节码操控和分析框架。它能以二进制的形式直接修改现有的类或动态生成的类。 ASM 提供了常用的转换和分析算法，是一种允许用户方便的组装定制化的复杂转换和代码分析工具。 ASM 也提供和其它的字节码工具类似的功能，但 ASM 的重点是使用的简单和高性能。由于 ASM 在设计实现的时候尽可能 的小的内存占用和提供更高的性能；因此在动态系统中使用 ASM 是很有优势的。ASM 作为一种轻量级、高性能的 Java 字节码操控和分析框架，设计了一种更有效的方法、提供更好的性能和内存占用。今天， ASM 在许多领域都有应用，并已成为事实上的字节码处理框架标准。</p>
<p><a href="">问题的引入</a></p>
<p>先写一个不带 web services 标注的 SayHelloImpl 类。
<a href=""><strong>清单 1. 不带 web services 的 SayHelloImpl 类</strong></a>1</p>
<p>public</p>
<p>class</p>
<p>SayHelloImpl {</p>
<p>2</p>
<p>public</p>
<p>String sayHello(String s) {
3</p>
<p>return</p>
<p>“Hello: ” + s ;</p>
<p>4</p>
<p>}
5</p>
<p>}</p>
<p>再用 wsgen 来创建 web services，wsgen 的使用如下：
<a href=""><strong>清单 2. wsgen 实例</strong></a>1</p>
<p>wsgen.exe – </p>
<p>cp</p>
<p>bin – s output – d output – r output – wsdl ibm.was.asm.SayHelloImpl我们将会遇到如下错误： 
<a href=""><strong>清单 3. 根据不带 web services 标注的类创建 web services 时遇到的错误信息</strong></a> 
注释处理过程中遇到问题；</p>
<p>......
com.sun.tools.internal.ws.processor.modeler.ModelerException: [failed to localiz</p>
<p>e] A web service endpoint could not be found()
        at com.sun.tools.internal.ws.processor.modeler.annotation.WebServiceAP.o</p>
<p>nError(WebServiceAP.java:215)
        at com.sun.tools.internal.ws.processor.modeler.annotation.WebServiceAP.b</p>
<p>uildModel(WebServiceAP.java:322)
        at com.sun.tools.internal.ws.processor.modeler.annotation.WebServiceAP.p</p>
<p>rocess(WebServiceAP.java:256)
        at com.sun.mirror.apt.AnnotationProcessors$CompositeAnnotationProcessor.</p>
<p>process(AnnotationProcessors.java:60)</p>
<p>注意：我们通常是在 class 前使用 @WebService， 在方法前使用 @WebMethod 来将一个类标注为 web services 的。WAS 6.1 的 web services 功能部件包和 WAS 7 都支持基于 JAX-WS 标准 的 web services 的开发， 在 WAS 安装目录的 bin 目录下提供了命令行工具 wsgen，wsgen 支持自底向上的开发方式。 下面是 wsgen 的用法：
<a href=""><strong>清单 4. wsgen 命令格式</strong></a> 
注 wsgen [options]  [SEI]</p>
<p>主要选项：</p>
<ul>
<li>-d 指定生成的 class 文件位置；</li>
<li>-s 指定生成的 Java 源文件位置；</li>
<li>-r 指定生成的 resources 文件位置，如 wsdl，xsd；</li>
<li>-cp 指定服务实现类所在的位置；</li>
<li>-wsdl，-servicename，-portname 三个参数指定生成的 wsdl 文件中的 service 和 port 的名称。</li>
</ul>
<p>SEI(Service Endpoint Interface) 是一个 endpoint implementation class，不能是一个 interface。所以首先要开发一个 endpoint 的实现类，如本例中的 SayHelloImpl 。用 @WebService 声明 web services ，然后将它编译，才能提供给 wsgen 来创建 web services 。</p>
<p><a href="">四种文件之间的转换</a></p>
<p>下面介绍本文要用到的四个概念（Java Source，Java Class，ASM Code，ASM Source）</p>
<ul>
<li>Java Source: 即我们通常编写的 Java 源文件；</li>
<li>Java Class: Java 源文件编译后的字节码文件；</li>
<li>ASM Source : 类似于对 class 反编译后的源文件，也就是 &quot;textual byte code&quot;，但比原始的 Java Source 可读性要差， 参见清单 5。</li>
<li>ASM Code: 指读写 class 文件的 ASM 程序代码。需要用到 ASM 提供的 API， 参见清单 6。
<a href=""><strong>清单 5. SayHelloImpl 类对应的 ASM Source</strong></a>01</li>
</ul>
<p>// class version 50.0 (50)</p>
<p>02</p>
<p>// access flags 33
03</p>
<p>public</p>
<p>class</p>
<p>com/ibm/was/asm/SayHelloImpl {</p>
<p>04</p>
<p>05</p>
<p>// access flags 1</p>
<p>06</p>
<p>public</p>
<p><init>()V
07</p>
<p>ALOAD </p>
<p>0</p>
<p>08</p>
<p>INVOKESPECIAL java/lang/Object. <init> ()V
09</p>
<p>RETURN</p>
<p>10</p>
<p>MAXSTACK = </p>
<p>1
11</p>
<p>MAXLOCALS = </p>
<p>1</p>
<p>12</p>
<p>13</p>
<p>// access flags 1</p>
<p>14</p>
<p>public</p>
<p>sayHello(Ljava/lang/String;)Ljava/lang/String;
15</p>
<p>NEW java/lang/StringBuilder</p>
<p>16</p>
<p>DUP
17</p>
<p>LDC </p>
<p>&quot;Hello:&quot;</p>
<p>18</p>
<p>INVOKESPECIAL java/lang/StringBuilder. <init> (Ljava/lang/String;)V
19</p>
<p>ALOAD </p>
<p>1</p>
<p>20</p>
<p>INVOKEVIRTUAL java/lang/StringBuilder.append (Ljava/lang/String;)
21</p>
<p>Ljava/lang/StringBuilder;</p>
<p>22</p>
<p>INVOKEVIRTUAL java/lang/StringBuilder.toString ()Ljava/lang/String;
23</p>
<p>ARETURN</p>
<p>24</p>
<p>MAXSTACK = </p>
<p>3
25</p>
<p>MAXLOCALS = </p>
<p>2</p>
<p>26</p>
<p>}<a href=""><strong>清单 6. 生成 SayHelloImpl.class 的 ASM Code</strong></a>01</p>
<p>package</p>
<p>asm.com.ibm.was.asm;</p>
<p>02</p>
<p>import</p>
<p>java.util./*;
03</p>
<p>import</p>
<p>org.objectweb.asm./*;</p>
<p>04</p>
<p>import</p>
<p>org.objectweb.asm.attrs./*;
05</p>
<p>public</p>
<p>class</p>
<p>SayHelloImplDump </p>
<p>implements</p>
<p>Opcodes {</p>
<p>06</p>
<p>public</p>
<p>static</p>
<p>byte</p>
<p>[] dump () </p>
<p>throws</p>
<p>Exception {
07</p>
<p>ClassWriter cw = </p>
<p>new</p>
<p>ClassWriter(</p>
<p>0</p>
<p>);</p>
<p>08</p>
<p>FieldVisitor fv;
09</p>
<p>MethodVisitor mv;</p>
<p>10</p>
<p>AnnotationVisitor av0;
11</p>
<p>12</p>
<p>cw.visit(V1_6, ACC_PUBLIC + ACC_SUPER, </p>
<p>&quot;com/ibm/was/asm/SayHelloImpl&quot;</p>
<p>,
13</p>
<p>null</p>
<p>, </p>
<p>&quot;java/lang/Object&quot;</p>
<p>, </p>
<p>null</p>
<p>);</p>
<p>14</p>
<p>15</p>
<p>{</p>
<p>16</p>
<p>mv = cw.visitMethod(ACC_PUBLIC, </p>
<p>&quot;<init>&quot;</p>
<p>, </p>
<p>&quot;()V&quot;</p>
<p>, </p>
<p>null</p>
<p>, </p>
<p>null</p>
<p>);
17</p>
<p>mv.visitCode();</p>
<p>18</p>
<p>mv.visitVarInsn(ALOAD, </p>
<p>0</p>
<p>);
19</p>
<p>mv.visitMethodInsn(INVOKESPECIAL, </p>
<p>&quot;java/lang/Object&quot;</p>
<p>, </p>
<p>&quot;<init>&quot;</p>
<p>, </p>
<p>&quot;()V&quot;</p>
<p>);</p>
<p>20</p>
<p>mv.visitInsn(RETURN);
21</p>
<p>mv.visitMaxs(</p>
<p>1</p>
<p>, </p>
<p>1</p>
<p>);</p>
<p>22</p>
<p>mv.visitEnd();
23</p>
<p>}</p>
<p>24</p>
<p>{
25</p>
<p>mv = cw.visitMethod(ACC_PUBLIC, </p>
<p>&quot;sayHello&quot;</p>
<p>,</p>
<p>26</p>
<p>&quot;(Ljava/lang/String;)Ljava/lang/String;&quot;</p>
<p>, </p>
<p>null</p>
<p>, </p>
<p>null</p>
<p>);
27</p>
<p>mv.visitCode();</p>
<p>28</p>
<p>mv.visitTypeInsn(NEW, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>);
29</p>
<p>mv.visitInsn(DUP);</p>
<p>30</p>
<p>mv.visitLdcInsn(</p>
<p>&quot;Hello:&quot;</p>
<p>);
31</p>
<p>mv.visitMethodInsn(INVOKESPECIAL, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>,</p>
<p>32</p>
<p>&quot;<init>&quot;</p>
<p>, </p>
<p>&quot;(Ljava/lang/String;)V&quot;</p>
<p>);
33</p>
<p>mv.visitVarInsn(ALOAD, </p>
<p>1</p>
<p>);</p>
<p>34</p>
<p>mv.visitMethodInsn(INVOKEVIRTUAL, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>,
35</p>
<p>&quot;append&quot;</p>
<p>, </p>
<p>&quot;(Ljava/lang/String;)Ljava/lang/StringBuilder;&quot;</p>
<p>);</p>
<p>36</p>
<p>mv.visitMethodInsn(INVOKEVIRTUAL, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>,
37</p>
<p>&quot;toString&quot;</p>
<p>, </p>
<p>&quot;()Ljava/lang/String;&quot;</p>
<p>);</p>
<p>38</p>
<p>mv.visitInsn(ARETURN);
39</p>
<p>mv.visitMaxs(</p>
<p>3</p>
<p>, </p>
<p>2</p>
<p>);</p>
<p>40</p>
<p>mv.visitEnd();
41</p>
<p>}</p>
<p>42</p>
<p>cw.visitEnd();
43</p>
<p>return</p>
<p>cw.toByteArray();</p>
<p>44</p>
<p>}
45</p>
<p>}</p>
<p>图 1 描述了 Java Source 文件、Java Class 文件、ASM Code 文件和 ASM Source 文件之间的转换关系。
<a href=""><strong>图 1. 四种文件的转换图</strong></a> 
<a href=""><img src="" alt="图 1. 四种文件的转换图"></a> </p>
<p>如图 -1 所示，Java Source 文件通过 Javac 可以转换为 Java Class 文件。而相应的 Java Class 文件通过 Java 反编译器工具可转换为 Java Source 文件；</p>
<p>通 过 ASM Code 去创建和修改 Java Class 需要对 ASM API 比较熟悉才行，一个常见的问题时，怎么用 ASM Code 生成一个我们希望的 class 文件， 也就是说， 给定了 Java Class， 怎么得到其对应的 ASM Code 呢？ 所幸的是， ASM 框架为我们提供了 ASMifierClassVisitor 工具来产生 Java Class 对应的 ASM Code。代码如下：
<a href=""><strong>清单 7. 给定 class 文件，通过 ASMifierClassVisitor 获得其对应的 ASM Code</strong></a>01</p>
<p>public</p>
<p>void</p>
<p>showClassASMProcess() {</p>
<p>02</p>
<p>ClassReader cr;
03</p>
<p>final</p>
<p>String n = SayHelloImpl.</p>
<p>class</p>
<p>.getName();</p>
<p>04</p>
<p>05</p>
<p>try</p>
<p>{</p>
<p>06</p>
<p>cr = </p>
<p>new</p>
<p>ClassReader(n);<br>07</p>
<p>cr.accept(</p>
<p>new</p>
<p>ASMifierClassVisitor(</p>
<p>new</p>
<p>PrintWriter(System.out)),</p>
<p>08</p>
<p>new</p>
<p>Attribute[</p>
<p>0</p>
<p>],
09</p>
<p>ClassReader.SKIP_DEBUG);</p>
<p>10</p>
<p>11</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {</p>
<p>12</p>
<p>e.printStackTrace();
13</p>
<p>}</p>
<p>14</p>
<p>}</p>
<p>另外一个重要的转换就是， 给定了 Java Class 文件， 如何查看它的 ASM Source ？ 这点对于我们验证 ASM Code 生成的 class 是否正确很有用。ASM 提供了另外一个工具 TraceClassVisitor， 来获得一个 Java Class 对应的 ASM Source。代码如下：
<a href=""><strong>清单 8. 利用 TraceClassVisitor 查看 class 文件的 ASM Source</strong></a>01</p>
<p>//file 是 class 文件的全路径名</p>
<p>02</p>
<p>public</p>
<p>void</p>
<p>showClassSource(String file) {
03</p>
<p>FileInputStream is ;</p>
<p>04</p>
<p>ClassReader cr; 
05</p>
<p>06</p>
<p>try</p>
<p>{
07</p>
<p>is = </p>
<p>new</p>
<p>FileInputStream(file);     </p>
<p>08</p>
<p>cr = </p>
<p>new</p>
<p>ClassReader(is);
09</p>
<p>TraceClassVisitor trace = </p>
<p>new</p>
<p>TraceClassVisitor(</p>
<p>new</p>
<p>PrintWriter(System.out));</p>
<p>10</p>
<p>cr.accept(trace, ClassReader.SKIP_DEBUG);
11</p>
<p>12</p>
<p>is.close() ;
13</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {</p>
<p>14</p>
<p>e.printStackTrace() ;
15</p>
<p>}</p>
<p>16</p>
<p>}
17</p>
<p>{</p>
<p>18</p>
<p>e.printStackTrace();
19</p>
<p>}</p>
<p>20</p>
<p>}</p>
<p><a href="">ASM 类注入</a></p>
<p>ASM 类注入是指修改一个现有的 class 文件，在其中加入自己的代码。按通常思维，我们需要利用 ASM 提供的 reader 类去读取所要修改的类文件， 找到要修改的地方，如方法名或属性名，然后在该处插入自己的代码或修改现有的代码，这种思路将使问题复杂化。 ASM 为我们提供了访问类文件的 Visitor 模式，来遍历一个 class 文件，Visitor 是一个实现 ClassVisitor 接口的类。 要注入一个 class 文件，先要找到一个合适的 Visitor 做向导， ASM 提供了好几种 Visitor， 最常用的是 ClassWriter。同时我们需要提供一个适配器类 ClassAdapter， Visitor 会带着这个 Adapter 一起去遍历， 然后在遍历过程中回调 Adapter 提供的方法。我们在 Adapter 的这些方法中就可以实现我们的修改和定制逻辑。当然，如果你不想做任何修改，那 Visitor 遍历完后将得到一个和被遍历的 class 完全一样的拷贝。
<a href=""><strong>清单 9. 类注入的完整过程</strong></a>01</p>
<p>public</p>
<p>void</p>
<p>addAnnotationToExistingClass() {</p>
<p>02</p>
<p>FileInputStream is ;
03</p>
<p>ClassReader cr;          </p>
<p>04</p>
<p>try</p>
<p>{<br>05</p>
<p>String classfile = </p>
<p>&quot;E:\SayHelloImpl.class&quot;</p>
<p>; </p>
<p>// 待遍历的类</p>
<p>06</p>
<p>showClassSource(classfile) ;  </p>
<p>// 打印该类的 ASM source
07</p>
<p>08</p>
<p>is = </p>
<p>new</p>
<p>FileInputStream(classfile);<br>09</p>
<p>cr = </p>
<p>new</p>
<p>ClassReader(is);</p>
<p>10</p>
<p>// 此处我们使用 ClassWriter 做 Visitor
11</p>
<p>ClassWriter cw = </p>
<p>new</p>
<p>ClassWriter(ClassWriter.COMPUTE_MAXS);</p>
<p>12</p>
<p>// 给 Visitor 提供一个 Adapter
13</p>
<p>AddAnnotationAdapter adapter = </p>
<p>new</p>
<p>AddAnnotationAdapter(cw);           </p>
<p>14</p>
<p>cr.accept(adapter, ClassReader.SKIP_DEBUG);<br>15</p>
<p>16</p>
<p>// 遍历完后，生成的 class 保存在字节数组中
17</p>
<p>byte</p>
<p>[] b = cw.toByteArray();</p>
<p>18</p>
<p>19</p>
<p>try</p>
<p>{</p>
<p>20</p>
<p>// 将字节数组输出到文件中
21</p>
<p>// 为了不至于覆盖掉原有的 SayHelloImpl.class 文件，我们将结果输出到 _SayHelloImpl.class</p>
<p>22</p>
<p>FileOutputStream fout = </p>
<p>new</p>
<p>FileOutputStream(</p>
<p>&quot;E:\_SayHelloImpl.class&quot;</p>
<p>);
23</p>
<p>fout.write(b) ;</p>
<p>24</p>
<p>fout.flush();
25</p>
<p>fout.close() ;</p>
<p>26</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {
27</p>
<p>e.printStackTrace() ;</p>
<p>28</p>
<p>}
29</p>
<p>30</p>
<p>// 验证 _SayHelloImpl.class 是否包含我们注入的代码
31</p>
<p>showClassSource(</p>
<p>&quot;E:\_SayHelloImpl.class&quot;</p>
<p>) ;</p>
<p>32</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {
33</p>
<p>e.printStackTrace();</p>
<p>34</p>
<p>} 
35</p>
<p>}</p>
<p><a href="">web services 标记注入过程</a></p>
<p>我们已经知道了如何往 class 中注入自己的代码，那对于一个已有的 Java bean，怎么往里注入 @WebService 和 @WebMethod 呢？根据上面我们讲的转换关系，我们可以先写一个带 annotation 的 Java Source，编译得到 Java Class， 再得到其 ASM Code。下面是利用 ASM 给一个不带任何 Annotation 的 class 添加 @WebService 和 @WebMethod 的步骤。</p>
<ol>
<li>首先在 SayHelloImpl.java 中添加 @WebService 和 @WebMethod： 
<a href=""><strong>清单 10. 带 web services 标注的 SayHelloImpl 类</strong></a>1</li>
</ol>
<p>@WebService</p>
<p>2</p>
<p>public</p>
<p>class</p>
<p>SayHelloImpl {
3</p>
<p>@WebMethod</p>
<p>4</p>
<p>public</p>
<p>String sayHello(String s) {
5</p>
<p>return</p>
<p>&quot;Hello: &quot;</p>
<ul>
<li>s ;</li>
</ul>
<p>6</p>
<p>}
7</p>
<p>}</p>
<ol>
<li>通过 ASMifierClassVisitor 工具获得 SayHelloImpl class 的 ASM Code，见清单 6。</li>
<li>写一个 ClassAdapter 类， ClassAdapter 其实也是一个 Visitor。根据 ASM Code 的提示， 我们就可以知道如何利用 ASM API 去获得我们希望的 class 文件。下面是 Adapter 的示例代码。 
<a href=""><strong>清单 11. 添加 Annotation 的 Adapter 类</strong></a>01</li>
</ol>
<p>public</p>
<p>class</p>
<p>AddAnnotationAdapter </p>
<p>extends</p>
<p>ClassAdapter </p>
<p>implements</p>
<p>Opcodes{</p>
<p>02</p>
<p>//private String annotationDesc;
03</p>
<p>private</p>
<p>boolean</p>
<p>isAnnotationPresent;</p>
<p>04</p>
<p>05</p>
<p>public</p>
<p>AddAnnotationAdapter(ClassVisitor cv) {</p>
<p>06</p>
<p>super</p>
<p>(cv);
07</p>
<p>}</p>
<p>08</p>
<p>09</p>
<p>@Override</p>
<p>10</p>
<p>public</p>
<p>void</p>
<p>visit(</p>
<p>int</p>
<p>version, </p>
<p>int</p>
<p>access, String name, String signature,
11</p>
<p>String superName, String[] interfaces) {</p>
<p>12</p>
<p>13</p>
<p>cv.visit(V1_6, ACC_PUBLIC + ACC_SUPER, name, signature, superName,</p>
<p>14</p>
<p>interfaces);
15</p>
<p>AnnotationVisitor av0;</p>
<p>16</p>
<p>av0 = cv.visitAnnotation(</p>
<p>&quot;Ljavax/jws/WebService;&quot;</p>
<p>, </p>
<p>true</p>
<p>);
17</p>
<p>av0.visitEnd();</p>
<p>18</p>
<p>}
19</p>
<p>20</p>
<p>@Override
21</p>
<p>public</p>
<p>AnnotationVisitor visitAnnotation(String desc, </p>
<p>boolean</p>
<p>visible) {</p>
<p>22</p>
<p>return</p>
<p>cv.visitAnnotation(desc, visible);
23</p>
<p>}</p>
<p>24</p>
<p>25</p>
<p>@Override</p>
<p>26</p>
<p>public</p>
<p>void</p>
<p>visitInnerClass(String name, String outerName,
27</p>
<p>String innerName, </p>
<p>int</p>
<p>access) {</p>
<p>28</p>
<p>cv.visitInnerClass(name, outerName, innerName, access);
29</p>
<p>}</p>
<p>30</p>
<p>31</p>
<p>@Override</p>
<p>32</p>
<p>public</p>
<p>FieldVisitor visitField(</p>
<p>int</p>
<p>access, String name, String desc,
33</p>
<p>String signature, Object value) {</p>
<p>34</p>
<p>return</p>
<p>cv.visitField(access, name, desc, signature, value);
35</p>
<p>}</p>
<p>36</p>
<p>37</p>
<p>@Override</p>
<p>38</p>
<p>public</p>
<p>MethodVisitor visitMethod(</p>
<p>int</p>
<p>access, String name, String desc,
39</p>
<p>String signature, String[] exceptions) {   </p>
<p>40</p>
<p>MethodVisitor mv  = cv.visitMethod(access, name, desc, signature,
41</p>
<p>exceptions);</p>
<p>42</p>
<p>if</p>
<p>(!name.equals(</p>
<p>&quot;<init>&quot;</p>
<p>)) {
43</p>
<p>AnnotationVisitor av0;</p>
<p>44</p>
<p>av0 = mv.visitAnnotation(</p>
<p>&quot;Ljavax/jws/WebMethod;&quot;</p>
<p>, </p>
<p>true</p>
<p>);
45</p>
<p>av0.visitEnd();</p>
<p>46</p>
<p>}
47</p>
<p>return</p>
<p>mv;</p>
<p>48</p>
<p>}
49</p>
<p>50</p>
<p>@Override
51</p>
<p>public</p>
<p>void</p>
<p>visitEnd() {</p>
<p>52</p>
<p>cv.visitEnd();
53</p>
<p>}</p>
<p>54</p>
<p>55</p>
<p>}</p>
<p>最后，我们采用上面讲的类注入办法，即可得到一个带 @WebService 和 @WebMethod 标注的 class 文件。再通过 wsgen 工具即可成功创建 web services，该命令将会在 src 目录下生成 web services 描述文件：SayHelloImplService.wsdl，SayHelloImplService_schema1.xsd，同时生成了 2 个 JAX-WS 文件，分别为：SayHello.java，SayHelloResponse.java。</p>
<p>当然，在实际应用中，我们可能需要将一个 class 的某些特定方法发布为 web services，这就需要我们对 Adapter 做进一步的改造，在 visitMethod() 方法中根据方法名称等参数做进一步的处理。</p>
<p><a href="">结束语</a></p>
<p>本文简要介绍了 ASM 字节码工具及其在 web services 开发中的应用。web services 的使用已经越来越广泛， 但在改造遗留系统过程中会遇到不少问题，本文针对其中一个主要问题给出了解决办法，该方法无须对现有系统做大量的改动， 即可将现存的 Java bean 转化成 web services 。本文对那些正考虑迁移到 JAX-WS 编程模型上的项目有一定的参考价值。在基于 JAX-WS 标准的 web services 的开发中，不少实际场景都是希望采用自底向上的开发方式， 即基于已有的 Java bean 来创建 web services 。WebSphere Application Server ( 以下简称 WAS ) 提供了命令行的工具 wsgen 和相对应的 Ant task 来支持这种开发过程，而且这两个工具比较适合大型项目的自动化构建。 这两个工具的使用前提是 Java bean 中事先添加有 web services 的 Annotation 标注，而在现有的业务系统中，class 文件一般是不带 Annotation 的，这就需要开发人员去修改现有的代码，以手工方式添加 Annotation，但这样带来的工作量太大且容易出错。本文介绍了一种解决途径，可以不用修改源代码，而是利用字节码工具 ASM 直接修改 class 文件， 在字节码文件中自动注入 Annotation ，然后再利用 wsgen 工具就可以很方便地生成 web services 应用。 本文同时也总结了使用 ASM 的一些实践。</p>
<p>本文首先介绍了和 ASM 使用相关的四种文件，以及它们之间的相互转化。然后结合 web services 开发实例，介绍了使用 wsgen 开发时遇到的实际问题，如何写一个 ASM 的适配器去修改现有 class，最终如何产生 web services 文件。</p>
<p>ASM 是一个多用途的 Java 字节码操控和分析框架。它能以二进制的形式直接修改现有的类或动态生成的类。 ASM 提供了常用的转换和分析算法，是一种允许用户方便的组装定制化的复杂转换和代码分析工具。 ASM 也提供和其它的字节码工具类似的功能，但 ASM 的重点是使用的简单和高性能。由于 ASM 在设计实现的时候尽可能 的小的内存占用和提供更高的性能；因此在动态系统中使用 ASM 是很有优势的。ASM 作为一种轻量级、高性能的 Java 字节码操控和分析框架，设计了一种更有效的方法、提供更好的性能和内存占用。今天， ASM 在许多领域都有应用，并已成为事实上的字节码处理框架标准。</p>
<p><a href="">问题的引入</a></p>
<p>先写一个不带 web services 标注的 SayHelloImpl 类。
<a href=""><strong>清单 1. 不带 web services 的 SayHelloImpl 类</strong></a>1</p>
<p>public</p>
<p>class</p>
<p>SayHelloImpl {</p>
<p>2</p>
<p>public</p>
<p>String sayHello(String s) {
3</p>
<p>return</p>
<p>“Hello: ” + s ;</p>
<p>4</p>
<p>}
5</p>
<p>}</p>
<p>再用 wsgen 来创建 web services，wsgen 的使用如下：
<a href=""><strong>清单 2. wsgen 实例</strong></a>1</p>
<p>wsgen.exe – </p>
<p>cp</p>
<p>bin – s output – d output – r output – wsdl ibm.was.asm.SayHelloImpl我们将会遇到如下错误： 
<a href=""><strong>清单 3. 根据不带 web services 标注的类创建 web services 时遇到的错误信息</strong></a> 
注释处理过程中遇到问题；</p>
<p>......
com.sun.tools.internal.ws.processor.modeler.ModelerException: [failed to localiz</p>
<p>e] A web service endpoint could not be found()
        at com.sun.tools.internal.ws.processor.modeler.annotation.WebServiceAP.o</p>
<p>nError(WebServiceAP.java:215)
        at com.sun.tools.internal.ws.processor.modeler.annotation.WebServiceAP.b</p>
<p>uildModel(WebServiceAP.java:322)
        at com.sun.tools.internal.ws.processor.modeler.annotation.WebServiceAP.p</p>
<p>rocess(WebServiceAP.java:256)
        at com.sun.mirror.apt.AnnotationProcessors$CompositeAnnotationProcessor.</p>
<p>process(AnnotationProcessors.java:60)</p>
<p>注意：我们通常是在 class 前使用 @WebService， 在方法前使用 @WebMethod 来将一个类标注为 web services 的。WAS 6.1 的 web services 功能部件包和 WAS 7 都支持基于 JAX-WS 标准 的 web services 的开发， 在 WAS 安装目录的 bin 目录下提供了命令行工具 wsgen，wsgen 支持自底向上的开发方式。 下面是 wsgen 的用法：
<a href=""><strong>清单 4. wsgen 命令格式</strong></a> 
注 wsgen [options]  [SEI]</p>
<p>主要选项：</p>
<ul>
<li>-d 指定生成的 class 文件位置；</li>
<li>-s 指定生成的 Java 源文件位置；</li>
<li>-r 指定生成的 resources 文件位置，如 wsdl，xsd；</li>
<li>-cp 指定服务实现类所在的位置；</li>
<li>-wsdl，-servicename，-portname 三个参数指定生成的 wsdl 文件中的 service 和 port 的名称。</li>
</ul>
<p>SEI(Service Endpoint Interface) 是一个 endpoint implementation class，不能是一个 interface。所以首先要开发一个 endpoint 的实现类，如本例中的 SayHelloImpl 。用 @WebService 声明 web services ，然后将它编译，才能提供给 wsgen 来创建 web services 。</p>
<p><a href="">四种文件之间的转换</a></p>
<p>下面介绍本文要用到的四个概念（Java Source，Java Class，ASM Code，ASM Source）</p>
<ul>
<li>Java Source: 即我们通常编写的 Java 源文件；</li>
<li>Java Class: Java 源文件编译后的字节码文件；</li>
<li>ASM Source : 类似于对 class 反编译后的源文件，也就是 &quot;textual byte code&quot;，但比原始的 Java Source 可读性要差， 参见清单 5。</li>
<li>ASM Code: 指读写 class 文件的 ASM 程序代码。需要用到 ASM 提供的 API， 参见清单 6。
<a href=""><strong>清单 5. SayHelloImpl 类对应的 ASM Source</strong></a>01</li>
</ul>
<p>// class version 50.0 (50)</p>
<p>02</p>
<p>// access flags 33
03</p>
<p>public</p>
<p>class</p>
<p>com/ibm/was/asm/SayHelloImpl {</p>
<p>04</p>
<p>05</p>
<p>// access flags 1</p>
<p>06</p>
<p>public</p>
<p><init>()V
07</p>
<p>ALOAD </p>
<p>0</p>
<p>08</p>
<p>INVOKESPECIAL java/lang/Object. <init> ()V
09</p>
<p>RETURN</p>
<p>10</p>
<p>MAXSTACK = </p>
<p>1
11</p>
<p>MAXLOCALS = </p>
<p>1</p>
<p>12</p>
<p>13</p>
<p>// access flags 1</p>
<p>14</p>
<p>public</p>
<p>sayHello(Ljava/lang/String;)Ljava/lang/String;
15</p>
<p>NEW java/lang/StringBuilder</p>
<p>16</p>
<p>DUP
17</p>
<p>LDC </p>
<p>&quot;Hello:&quot;</p>
<p>18</p>
<p>INVOKESPECIAL java/lang/StringBuilder. <init> (Ljava/lang/String;)V
19</p>
<p>ALOAD </p>
<p>1</p>
<p>20</p>
<p>INVOKEVIRTUAL java/lang/StringBuilder.append (Ljava/lang/String;)
21</p>
<p>Ljava/lang/StringBuilder;</p>
<p>22</p>
<p>INVOKEVIRTUAL java/lang/StringBuilder.toString ()Ljava/lang/String;
23</p>
<p>ARETURN</p>
<p>24</p>
<p>MAXSTACK = </p>
<p>3
25</p>
<p>MAXLOCALS = </p>
<p>2</p>
<p>26</p>
<p>}<a href=""><strong>清单 6. 生成 SayHelloImpl.class 的 ASM Code</strong></a>01</p>
<p>package</p>
<p>asm.com.ibm.was.asm;</p>
<p>02</p>
<p>import</p>
<p>java.util./*;
03</p>
<p>import</p>
<p>org.objectweb.asm./*;</p>
<p>04</p>
<p>import</p>
<p>org.objectweb.asm.attrs./*;
05</p>
<p>public</p>
<p>class</p>
<p>SayHelloImplDump </p>
<p>implements</p>
<p>Opcodes {</p>
<p>06</p>
<p>public</p>
<p>static</p>
<p>byte</p>
<p>[] dump () </p>
<p>throws</p>
<p>Exception {
07</p>
<p>ClassWriter cw = </p>
<p>new</p>
<p>ClassWriter(</p>
<p>0</p>
<p>);</p>
<p>08</p>
<p>FieldVisitor fv;
09</p>
<p>MethodVisitor mv;</p>
<p>10</p>
<p>AnnotationVisitor av0;
11</p>
<p>12</p>
<p>cw.visit(V1_6, ACC_PUBLIC + ACC_SUPER, </p>
<p>&quot;com/ibm/was/asm/SayHelloImpl&quot;</p>
<p>,
13</p>
<p>null</p>
<p>, </p>
<p>&quot;java/lang/Object&quot;</p>
<p>, </p>
<p>null</p>
<p>);</p>
<p>14</p>
<p>15</p>
<p>{</p>
<p>16</p>
<p>mv = cw.visitMethod(ACC_PUBLIC, </p>
<p>&quot;<init>&quot;</p>
<p>, </p>
<p>&quot;()V&quot;</p>
<p>, </p>
<p>null</p>
<p>, </p>
<p>null</p>
<p>);
17</p>
<p>mv.visitCode();</p>
<p>18</p>
<p>mv.visitVarInsn(ALOAD, </p>
<p>0</p>
<p>);
19</p>
<p>mv.visitMethodInsn(INVOKESPECIAL, </p>
<p>&quot;java/lang/Object&quot;</p>
<p>, </p>
<p>&quot;<init>&quot;</p>
<p>, </p>
<p>&quot;()V&quot;</p>
<p>);</p>
<p>20</p>
<p>mv.visitInsn(RETURN);
21</p>
<p>mv.visitMaxs(</p>
<p>1</p>
<p>, </p>
<p>1</p>
<p>);</p>
<p>22</p>
<p>mv.visitEnd();
23</p>
<p>}</p>
<p>24</p>
<p>{
25</p>
<p>mv = cw.visitMethod(ACC_PUBLIC, </p>
<p>&quot;sayHello&quot;</p>
<p>,</p>
<p>26</p>
<p>&quot;(Ljava/lang/String;)Ljava/lang/String;&quot;</p>
<p>, </p>
<p>null</p>
<p>, </p>
<p>null</p>
<p>);
27</p>
<p>mv.visitCode();</p>
<p>28</p>
<p>mv.visitTypeInsn(NEW, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>);
29</p>
<p>mv.visitInsn(DUP);</p>
<p>30</p>
<p>mv.visitLdcInsn(</p>
<p>&quot;Hello:&quot;</p>
<p>);
31</p>
<p>mv.visitMethodInsn(INVOKESPECIAL, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>,</p>
<p>32</p>
<p>&quot;<init>&quot;</p>
<p>, </p>
<p>&quot;(Ljava/lang/String;)V&quot;</p>
<p>);
33</p>
<p>mv.visitVarInsn(ALOAD, </p>
<p>1</p>
<p>);</p>
<p>34</p>
<p>mv.visitMethodInsn(INVOKEVIRTUAL, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>,
35</p>
<p>&quot;append&quot;</p>
<p>, </p>
<p>&quot;(Ljava/lang/String;)Ljava/lang/StringBuilder;&quot;</p>
<p>);</p>
<p>36</p>
<p>mv.visitMethodInsn(INVOKEVIRTUAL, </p>
<p>&quot;java/lang/StringBuilder&quot;</p>
<p>,
37</p>
<p>&quot;toString&quot;</p>
<p>, </p>
<p>&quot;()Ljava/lang/String;&quot;</p>
<p>);</p>
<p>38</p>
<p>mv.visitInsn(ARETURN);
39</p>
<p>mv.visitMaxs(</p>
<p>3</p>
<p>, </p>
<p>2</p>
<p>);</p>
<p>40</p>
<p>mv.visitEnd();
41</p>
<p>}</p>
<p>42</p>
<p>cw.visitEnd();
43</p>
<p>return</p>
<p>cw.toByteArray();</p>
<p>44</p>
<p>}
45</p>
<p>}</p>
<p>图 1 描述了 Java Source 文件、Java Class 文件、ASM Code 文件和 ASM Source 文件之间的转换关系。
<a href=""><strong>图 1. 四种文件的转换图</strong></a> 
<a href=""><img src="" alt="图 1. 四种文件的转换图"></a> </p>
<p>如图 -1 所示，Java Source 文件通过 Javac 可以转换为 Java Class 文件。而相应的 Java Class 文件通过 Java 反编译器工具可转换为 Java Source 文件；</p>
<p>通 过 ASM Code 去创建和修改 Java Class 需要对 ASM API 比较熟悉才行，一个常见的问题时，怎么用 ASM Code 生成一个我们希望的 class 文件， 也就是说， 给定了 Java Class， 怎么得到其对应的 ASM Code 呢？ 所幸的是， ASM 框架为我们提供了 ASMifierClassVisitor 工具来产生 Java Class 对应的 ASM Code。代码如下：
<a href=""><strong>清单 7. 给定 class 文件，通过 ASMifierClassVisitor 获得其对应的 ASM Code</strong></a>01</p>
<p>public</p>
<p>void</p>
<p>showClassASMProcess() {</p>
<p>02</p>
<p>ClassReader cr;
03</p>
<p>final</p>
<p>String n = SayHelloImpl.</p>
<p>class</p>
<p>.getName();</p>
<p>04</p>
<p>05</p>
<p>try</p>
<p>{</p>
<p>06</p>
<p>cr = </p>
<p>new</p>
<p>ClassReader(n);<br>07</p>
<p>cr.accept(</p>
<p>new</p>
<p>ASMifierClassVisitor(</p>
<p>new</p>
<p>PrintWriter(System.out)),</p>
<p>08</p>
<p>new</p>
<p>Attribute[</p>
<p>0</p>
<p>],
09</p>
<p>ClassReader.SKIP_DEBUG);</p>
<p>10</p>
<p>11</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {</p>
<p>12</p>
<p>e.printStackTrace();
13</p>
<p>}</p>
<p>14</p>
<p>}</p>
<p>另外一个重要的转换就是， 给定了 Java Class 文件， 如何查看它的 ASM Source ？ 这点对于我们验证 ASM Code 生成的 class 是否正确很有用。ASM 提供了另外一个工具 TraceClassVisitor， 来获得一个 Java Class 对应的 ASM Source。代码如下：
<a href=""><strong>清单 8. 利用 TraceClassVisitor 查看 class 文件的 ASM Source</strong></a>01</p>
<p>//file 是 class 文件的全路径名</p>
<p>02</p>
<p>public</p>
<p>void</p>
<p>showClassSource(String file) {
03</p>
<p>FileInputStream is ;</p>
<p>04</p>
<p>ClassReader cr; 
05</p>
<p>06</p>
<p>try</p>
<p>{
07</p>
<p>is = </p>
<p>new</p>
<p>FileInputStream(file);     </p>
<p>08</p>
<p>cr = </p>
<p>new</p>
<p>ClassReader(is);
09</p>
<p>TraceClassVisitor trace = </p>
<p>new</p>
<p>TraceClassVisitor(</p>
<p>new</p>
<p>PrintWriter(System.out));</p>
<p>10</p>
<p>cr.accept(trace, ClassReader.SKIP_DEBUG);
11</p>
<p>12</p>
<p>is.close() ;
13</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {</p>
<p>14</p>
<p>e.printStackTrace() ;
15</p>
<p>}</p>
<p>16</p>
<p>}
17</p>
<p>{</p>
<p>18</p>
<p>e.printStackTrace();
19</p>
<p>}</p>
<p>20</p>
<p>}</p>
<p><a href="">ASM 类注入</a></p>
<p>ASM 类注入是指修改一个现有的 class 文件，在其中加入自己的代码。按通常思维，我们需要利用 ASM 提供的 reader 类去读取所要修改的类文件， 找到要修改的地方，如方法名或属性名，然后在该处插入自己的代码或修改现有的代码，这种思路将使问题复杂化。 ASM 为我们提供了访问类文件的 Visitor 模式，来遍历一个 class 文件，Visitor 是一个实现 ClassVisitor 接口的类。 要注入一个 class 文件，先要找到一个合适的 Visitor 做向导， ASM 提供了好几种 Visitor， 最常用的是 ClassWriter。同时我们需要提供一个适配器类 ClassAdapter， Visitor 会带着这个 Adapter 一起去遍历， 然后在遍历过程中回调 Adapter 提供的方法。我们在 Adapter 的这些方法中就可以实现我们的修改和定制逻辑。当然，如果你不想做任何修改，那 Visitor 遍历完后将得到一个和被遍历的 class 完全一样的拷贝。
<a href=""><strong>清单 9. 类注入的完整过程</strong></a>01</p>
<p>public</p>
<p>void</p>
<p>addAnnotationToExistingClass() {</p>
<p>02</p>
<p>FileInputStream is ;
03</p>
<p>ClassReader cr;          </p>
<p>04</p>
<p>try</p>
<p>{<br>05</p>
<p>String classfile = </p>
<p>&quot;E:\SayHelloImpl.class&quot;</p>
<p>; </p>
<p>// 待遍历的类</p>
<p>06</p>
<p>showClassSource(classfile) ;  </p>
<p>// 打印该类的 ASM source
07</p>
<p>08</p>
<p>is = </p>
<p>new</p>
<p>FileInputStream(classfile);<br>09</p>
<p>cr = </p>
<p>new</p>
<p>ClassReader(is);</p>
<p>10</p>
<p>// 此处我们使用 ClassWriter 做 Visitor
11</p>
<p>ClassWriter cw = </p>
<p>new</p>
<p>ClassWriter(ClassWriter.COMPUTE_MAXS);</p>
<p>12</p>
<p>// 给 Visitor 提供一个 Adapter
13</p>
<p>AddAnnotationAdapter adapter = </p>
<p>new</p>
<p>AddAnnotationAdapter(cw);           </p>
<p>14</p>
<p>cr.accept(adapter, ClassReader.SKIP_DEBUG);<br>15</p>
<p>16</p>
<p>// 遍历完后，生成的 class 保存在字节数组中
17</p>
<p>byte</p>
<p>[] b = cw.toByteArray();</p>
<p>18</p>
<p>19</p>
<p>try</p>
<p>{</p>
<p>20</p>
<p>// 将字节数组输出到文件中
21</p>
<p>// 为了不至于覆盖掉原有的 SayHelloImpl.class 文件，我们将结果输出到 _SayHelloImpl.class</p>
<p>22</p>
<p>FileOutputStream fout = </p>
<p>new</p>
<p>FileOutputStream(</p>
<p>&quot;E:\_SayHelloImpl.class&quot;</p>
<p>);
23</p>
<p>fout.write(b) ;</p>
<p>24</p>
<p>fout.flush();
25</p>
<p>fout.close() ;</p>
<p>26</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {
27</p>
<p>e.printStackTrace() ;</p>
<p>28</p>
<p>}
29</p>
<p>30</p>
<p>// 验证 _SayHelloImpl.class 是否包含我们注入的代码
31</p>
<p>showClassSource(</p>
<p>&quot;E:\_SayHelloImpl.class&quot;</p>
<p>) ;</p>
<p>32</p>
<p>} </p>
<p>catch</p>
<p>(Exception e) {
33</p>
<p>e.printStackTrace();</p>
<p>34</p>
<p>} 
35</p>
<p>}</p>
<p><a href="">web services 标记注入过程</a></p>
<p>我们已经知道了如何往 class 中注入自己的代码，那对于一个已有的 Java bean，怎么往里注入 @WebService 和 @WebMethod 呢？根据上面我们讲的转换关系，我们可以先写一个带 annotation 的 Java Source，编译得到 Java Class， 再得到其 ASM Code。下面是利用 ASM 给一个不带任何 Annotation 的 class 添加 @WebService 和 @WebMethod 的步骤。</p>
<ol>
<li>首先在 SayHelloImpl.java 中添加 @WebService 和 @WebMethod： 
<a href=""><strong>清单 10. 带 web services 标注的 SayHelloImpl 类</strong></a>1</li>
</ol>
<p>@WebService</p>
<p>2</p>
<p>public</p>
<p>class</p>
<p>SayHelloImpl {
3</p>
<p>@WebMethod</p>
<p>4</p>
<p>public</p>
<p>String sayHello(String s) {
5</p>
<p>return</p>
<p>&quot;Hello: &quot;</p>
<ul>
<li>s ;</li>
</ul>
<p>6</p>
<p>}
7</p>
<p>}</p>
<ol>
<li>通过 ASMifierClassVisitor 工具获得 SayHelloImpl class 的 ASM Code，见清单 6。</li>
<li>写一个 ClassAdapter 类， ClassAdapter 其实也是一个 Visitor。根据 ASM Code 的提示， 我们就可以知道如何利用 ASM API 去获得我们希望的 class 文件。下面是 Adapter 的示例代码。 
<a href=""><strong>清单 11. 添加 Annotation 的 Adapter 类</strong></a>01</li>
</ol>
<p>public</p>
<p>class</p>
<p>AddAnnotationAdapter </p>
<p>extends</p>
<p>ClassAdapter </p>
<p>implements</p>
<p>Opcodes{</p>
<p>02</p>
<p>//private String annotationDesc;
03</p>
<p>private</p>
<p>boolean</p>
<p>isAnnotationPresent;</p>
<p>04</p>
<p>05</p>
<p>public</p>
<p>AddAnnotationAdapter(ClassVisitor cv) {</p>
<p>06</p>
<p>super</p>
<p>(cv);
07</p>
<p>}</p>
<p>08</p>
<p>09</p>
<p>@Override</p>
<p>10</p>
<p>public</p>
<p>void</p>
<p>visit(</p>
<p>int</p>
<p>version, </p>
<p>int</p>
<p>access, String name, String signature,
11</p>
<p>String superName, String[] interfaces) {</p>
<p>12</p>
<p>13</p>
<p>cv.visit(V1_6, ACC_PUBLIC + ACC_SUPER, name, signature, superName,</p>
<p>14</p>
<p>interfaces);
15</p>
<p>AnnotationVisitor av0;</p>
<p>16</p>
<p>av0 = cv.visitAnnotation(</p>
<p>&quot;Ljavax/jws/WebService;&quot;</p>
<p>, </p>
<p>true</p>
<p>);
17</p>
<p>av0.visitEnd();</p>
<p>18</p>
<p>}
19</p>
<p>20</p>
<p>@Override
21</p>
<p>public</p>
<p>AnnotationVisitor visitAnnotation(String desc, </p>
<p>boolean</p>
<p>visible) {</p>
<p>22</p>
<p>return</p>
<p>cv.visitAnnotation(desc, visible);
23</p>
<p>}</p>
<p>24</p>
<p>25</p>
<p>@Override</p>
<p>26</p>
<p>public</p>
<p>void</p>
<p>visitInnerClass(String name, String outerName,
27</p>
<p>String innerName, </p>
<p>int</p>
<p>access) {</p>
<p>28</p>
<p>cv.visitInnerClass(name, outerName, innerName, access);
29</p>
<p>}</p>
<p>30</p>
<p>31</p>
<p>@Override</p>
<p>32</p>
<p>public</p>
<p>FieldVisitor visitField(</p>
<p>int</p>
<p>access, String name, String desc,
33</p>
<p>String signature, Object value) {</p>
<p>34</p>
<p>return</p>
<p>cv.visitField(access, name, desc, signature, value);
35</p>
<p>}</p>
<p>36</p>
<p>37</p>
<p>@Override</p>
<p>38</p>
<p>public</p>
<p>MethodVisitor visitMethod(</p>
<p>int</p>
<p>access, String name, String desc,
39</p>
<p>String signature, String[] exceptions) {   </p>
<p>40</p>
<p>MethodVisitor mv  = cv.visitMethod(access, name, desc, signature,
41</p>
<p>exceptions);</p>
<p>42</p>
<p>if</p>
<p>(!name.equals(</p>
<p>&quot;<init>&quot;</p>
<p>)) {
43</p>
<p>AnnotationVisitor av0;</p>
<p>44</p>
<p>av0 = mv.visitAnnotation(</p>
<p>&quot;Ljavax/jws/WebMethod;&quot;</p>
<p>, </p>
<p>true</p>
<p>);
45</p>
<p>av0.visitEnd();</p>
<p>46</p>
<p>}
47</p>
<p>return</p>
<p>mv;</p>
<p>48</p>
<p>}
49</p>
<p>50</p>
<p>@Override
51</p>
<p>public</p>
<p>void</p>
<p>visitEnd() {</p>
<p>52</p>
<p>cv.visitEnd();
53</p>
<p>}</p>
<p>54</p>
<p>55</p>
<p>}</p>
<p>最后，我们采用上面讲的类注入办法，即可得到一个带 @WebService 和 @WebMethod 标注的 class 文件。再通过 wsgen 工具即可成功创建 web services，该命令将会在 src 目录下生成 web services 描述文件：SayHelloImplService.wsdl，SayHelloImplService_schema1.xsd，同时生成了 2 个 JAX-WS 文件，分别为：SayHello.java，SayHelloResponse.java。</p>
<p>当然，在实际应用中，我们可能需要将一个 class 的某些特定方法发布为 web services，这就需要我们对 Adapter 做进一步的改造，在 visitMethod() 方法中根据方法名称等参数做进一步的处理。</p>
<p><a href="">结束语</a></p>
<p>本文简要介绍了 ASM 字节码工具及其在 web services 开发中的应用。web services 的使用已经越来越广泛， 但在改造遗留系统过程中会遇到不少问题，本文针对其中一个主要问题给出了解决办法，该方法无须对现有系统做大量的改动， 即可将现存的 Java bean 转化成 web services 。本文对那些正考虑迁移到 JAX-WS 编程模型上的项目有一定的参考价值。</p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:42"datetime="2014-03-07 09:54:42"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE--Java字节码工具ASM在WebService开发中的应用/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE--Java字节码工具ASM在WebService开发中的应用" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--perftools查看堆外内存并解决hbase内存溢出/">perftools查看堆外内存并解决hbase内存溢出</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:42.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--perftools查看堆外内存并解决hbase内存溢出/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="perftools-hbase-">perftools查看堆外内存并解决hbase内存溢出</h1>
<pre><code>最近线上运行的hbase发现分配了16g内存，但是实际使用了22g，堆外内存达到6g。感觉非常诡异。堆外内存用一般的工具很难查看，可以通过google-perftools来跟踪：
</code></pre><p><a href="http://code.google.com/p/google-perftools/downloads/list" target="_blank"><a href="http://code.google.com/p/google-perftools/downloads/list">http://code.google.com/p/google-perftools/downloads/list</a></a>
    它的原理是在java应用程序运行时，当调用malloc时换用它的libtcmalloc.so，这样就能做一些统计了</p>
<ul>
<li>下载<a href="http://download.savannah.gnu.org/releases/libunwind/libunwind-0.99-beta.tar.gz" target="_blank"><a href="http://download.savannah.gnu.org/releases/libunwind/libunwind-0.99-beta.tar.gz">http://download.savannah.gnu.org/releases/libunwind/libunwind-0.99-beta.tar.gz</a></a>，configure;make;sudo make install</li>
<li>下载<a href="http://google-perftools.googlecode.com/files/google-perftools-1.8.1.tar.gz" target="_blank"><a href="http://google-perftools.googlecode.com/files/google-perftools-1.8.1.tar.gz">http://google-perftools.googlecode.com/files/google-perftools-1.8.1.tar.gz</a></a>, configure --prefix=/home/user/perftools;make;sudo make install</li>
<li>在应用程序启动前加入：export LD_PRELOAD=/home/hadoop/perftools/lib/libtcmalloc.so以及export HEAPPROFILE=/home/user/perftools/test</li>
<li>修改lc_config:sudo vi /etc/ld.so.conf.d/usr_local_lib.conf，加入/usr/local/lib(libunwind的lib所在目录)</li>
<li>执行sudo /sbin/ldconfig，使libunwind生效</li>
<li>启动应用程序，此时会在/home/user/perftools/下看到诸如test_pid.xxxx.heap的heap文件，可使用bin/pprof --text $JAVA_HOME/bin/java test_pid.xxxx.heap来查看
  通过perftools查看到以下内容：
Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></li>
</ul>
<ol>
<li>Total: 3263.2 MB  </li>
<li>3145.2  96.4%  96.4%   3145.2  96.4% zcalloc  </li>
<li>83.8   2.6%  99.0%     83.8   2.6% os::malloc  </li>
<li>30.0   0.9%  99.9%     30.0   0.9% init  </li>
<li>2.2   0.1%  99.9%      2.2   0.1% ObjectSynchronizer::omAlloc  </li>
<li>1.0   0.0% 100.0%   3144.1  96.4% Java_java_util_zip_Deflater_init  </li>
<li>0.6   0.0% 100.0%      0.7   0.0% readCEN  </li>
</ol>
<p>Total: 3263.2 MB</p>
<p>  3145.2  96.4%  96.4%   3145.2  96.4% zcalloc
    83.8   2.6%  99.0%     83.8   2.6% os::malloc</p>
<pre><code>30.0   0.9%  99.9%     30.0   0.9% init
 2.2   0.1%  99.9%      2.2   0.1% ObjectSynchronizer::omAlloc

 1.0   0.0% 100.0%   3144.1  96.4% Java_java_util_zip_Deflater_init
 0.6   0.0% 100.0%      0.7   0.0% readCEN
可见调用了java.util.zip.Deflater占用绝大多数。了解到这个deflater存在无法释放内存的bug，于是编写btrace查看是否进入了这个函数：
</code></pre><p>Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>import static com.sun.btrace.BTraceUtils./*;  </li>
<li>import com.sun.btrace.annotations./*;  </li>
<li></li>
<li>import java.nio.ByteBuffer;  </li>
<li>import java.lang.Thread;  </li>
<li></li>
<li>@BTrace public class TestRegion1{  </li>
<li>@OnMethod(  </li>
<li>clazz=&quot;java.util.zip.Deflater&quot;,  </li>
<li>method=&quot;deflate&quot;  </li>
<li>)  </li>
<li>public static void traceCacheBlock(){  </li>
<li>println(&quot;deflate?&quot;);  </li>
<li>}  </li>
<li>}  </li>
</ol>
<p>import static com.sun.btrace.BTraceUtils./*;</p>
<p>import com.sun.btrace.annotations./*;</p>
<p>import java.nio.ByteBuffer;
import java.lang.Thread;</p>
<p>@BTrace public class TestRegion1{</p>
<p>   @OnMethod(
      clazz=&quot;java.util.zip.Deflater&quot;,</p>
<pre><code>  method=&quot;deflate&quot;
</code></pre><p>   )</p>
<p>   public static void traceCacheBlock(){
println(&quot;deflate?&quot;);</p>
<p>   }
}
    发现果然在不停调用这行代码。应该如何办呢？
由于deflater是gzip需要使用的代码，查看用户创建的表，发现COMPRESSOR设置的是GZ，尝试调整为LZO，结果发现btrace无法进入上述代码，再通过perftools查看时，堆内存不再申请，完全不再申请...
小插曲，perftools的作者是个老实人，提供了zip版下载，但是不提供安装文件，原因？在README中有以下一段话：
Html代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>I don&#39;t know very much about how to install DLLs on Windows, so you&#39;ll  </li>
<li>have to figure out that part for yourself.  </li>
</ol>
<p>I don&#39;t know very much about how to install DLLs on Windows, so you&#39;ll</p>
<p>have to figure out that part for yourself.</p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/JVM/">JVM</a></li></span></span> | <span class="tags">Tagged <a href="/tags/JVM/" class="label label-primary">JVM</a><a href="/tags/Java&J2EE/" class="label label-success">Java&J2EE</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:42"datetime="2014-03-07 09:54:42"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-JVM--perftools查看堆外内存并解决hbase内存溢出/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-JVM--perftools查看堆外内存并解决hbase内存溢出" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_多线程--用apache的configuration实现实时配置-steven_cheng-ITeye/">用apache的configuration实现实时配置 </a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:41.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_多线程--用apache的configuration实现实时配置-steven_cheng-ITeye/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-apache-configuration-steven_cheng-iteye-">用apache的configuration实现实时配置 - steven_cheng - ITeye技术网站</h1>
<p><a href="http://www.iteye.com/" target="_blank">首页</a> <a href="http://www.iteye.com/news" target="_blank">新闻</a> <a href="http://www.iteye.com/forums" target="_blank">论坛</a> <a href="http://www.iteye.com/ask" target="_blank">问答</a> <a href="http://www.iteye.com/blogs" target="_blank">博客</a> <a href="http://www.iteye.com/job" target="_blank">招聘</a> <a href="http://steven-cheng.iteye.com/blog/70634#" target="_blank">更多 ▼</a></p>
<p><a href="http://www.iteye.com/wiki" target="_blank">专栏</a>  <a href="http://www.iteye.com/groups" target="_blank">群组</a> <a href="http://www.iteye.com/search" target="_blank">搜索</a></p>
<p><a href="http://steven-cheng.iteye.com/login" title="登录" target="_blank">您还未登录 !</a> <a href="http://www.iteye.com/all" target="_blank">我的应用</a> <a href="http://steven-cheng.iteye.com/login" target="_blank">登录</a> <a href="http://steven-cheng.iteye.com/signup" target="_blank">注册</a></p>
<h1 id="-steven_cheng-http-steven-cheng-iteye-com-"><a href="http://steven-cheng.iteye.com/" target="_blank">steven_cheng</a></h1>
<p>永久域名 <a href="http://steven-cheng.iteye.com/" target="_blank"><a href="http://steven-cheng.iteye.com">http://steven-cheng.iteye.com</a></a></p>
<p><a href="http://steven-cheng.iteye.com/blog/87667" title="异常处理" target="_blank">异常处理</a></p>
<p>2006-03-24</p>
<h3 id="-apache-configuration-"><a href="">用apache的configuration实现实时配置</a></h3>
<p>关键字: java 开源
apache下commons有一个configeration包，对于做配置很方便，尤其是实时热配置。可以自动监测到配置文件的更改而reload配置文件。在项目中使用所以进行了一下封装。
java 代码</p>
<ol>
<li>public class DefaultRealTimeXMLConfiger {   </li>
<li></li>
<li>private static Log logger = LogFactory.getLog(DefaultRealTimeXMLConfiger.class);   </li>
<li></li>
<li>private String fileName;   </li>
<li></li>
<li>private long reloadPeriod;   </li>
<li></li>
<li>private XMLConfiguration config;   </li>
<li></li>
<li>public void init()   </li>
<li>{   </li>
<li>String filePath = GlobalConfigerImpl.getConfDir()+&quot;/&quot;+fileName;   </li>
<li>logger.debug(&quot;will config with XML file[&quot;+filePath+&quot;]&quot;);   </li>
<li></li>
<li>File file = new File(filePath);   </li>
<li>if (!file.exists() || !file.isFile()) {   </li>
<li>logger.error(&quot; can&#39;t find file[&quot; + filePath + &quot;]&quot;);   </li>
<li>throw new IllegalArgumentException(&quot;config error! can&#39;t find file[&quot; + filePath + &quot;]&quot;);   </li>
<li>}   </li>
<li>this.init(file);   </li>
<li>}   </li>
<li></li>
<li>public void init(File file) {   </li>
<li>try {   </li>
<li>config = new XMLConfiguration(file);   </li>
<li>FileChangedReloadingStrategy fs = new FileChangedReloadingStrategy();   </li>
<li>fs.setConfiguration(config);   </li>
<li></li>
<li>if(this.reloadPeriod&gt;0)   </li>
<li>{   </li>
<li>fs.setRefreshDelay(this.reloadPeriod);   </li>
<li>}   </li>
<li>config.setReloadingStrategy(fs);   </li>
<li></li>
<li>} catch (ConfigurationException e) {   </li>
<li>logger.error(&quot;error! configer error[&quot;+file.getPath()+&quot;]&quot;);   </li>
<li>logger.error(e);   </li>
<li>e.printStackTrace();   </li>
<li>}   </li>
<li>}   </li>
<li></li>
<li>public Object getProperty(String name) {   </li>
<li>Object s = this.config.getProperty(name);   </li>
<li>return s;   </li>
<li>}   </li>
<li></li>
<li>public String getString(String name) {   </li>
<li>Object s = this.config.getProperty(name);   </li>
<li>String result = null;   </li>
<li>if (s != null)   </li>
<li>result = (String) s;   </li>
<li></li>
<li>return result;   </li>
<li>}   </li>
<li></li>
<li>public String[] getStringArray(String name) {   </li>
<li>String[] target = this.config.getStringArray(name);   </li>
<li></li>
<li>return target;   </li>
<li>}   </li>
<li></li>
<li></li>
<li>//<em>/</em>  </li>
<li>/* @return Returns the fileName.  </li>
<li>/*/  </li>
<li>public String getFileName() {   </li>
<li>return fileName;   </li>
<li>}   </li>
<li></li>
<li>//<em>/</em>  </li>
<li>/* @param fileName The fileName to set.  </li>
<li>/*/  </li>
<li>public void setFileName(String fileName) {   </li>
<li>this.fileName = fileName;   </li>
<li>}   </li>
<li></li>
<li>//<em>/</em>  </li>
<li>/* @return Returns the reloadPeriod.  </li>
<li>/*/  </li>
<li>public long getReloadPeriod() {   </li>
<li>return reloadPeriod;   </li>
<li>}   </li>
<li></li>
<li>//<em>/</em>  </li>
<li>/* @param reloadPeriod The reloadPeriod to set.  </li>
<li>/*/  </li>
<li>public void setReloadPeriod(long reloadPeriod) {   </li>
<li>this.reloadPeriod = reloadPeriod;   </li>
<li>}   </li>
<li>}<br><a href="http://steven-cheng.iteye.com/blog/87667" title="异常处理" target="_blank">异常处理</a></li>
</ol>
<ul>
<li>06:34</li>
<li>浏览 (988)</li>
<li><a href="http://steven-cheng.iteye.com/blog/70634#comments" target="_blank">评论</a> (0)</li>
<li>分类: <a href="http://steven-cheng.iteye.com/category/12345" target="_blank">java</a></li>
<li><a href="http://www.iteye.com/wiki/topic/70634" target="_blank">相关推荐</a><h3 id="-">评论</h3>
</li>
</ul>
<p><a href=""></a></p>
<h3 id="-">发表评论</h3>
<h3 id="-">表情图标</h3>
<p><img src="" alt=""><img src="" alt=""><img src="" alt=""><img src="" alt=""><img src="" alt=""><img src="" alt=""><img src="" alt=""><img src="" alt=""><img src="" alt=""><img src="" alt=""><img src="" alt=""><img src="" alt=""><img src="" alt=""><img src="" alt=""><img src="" alt=""><img src="" alt=""><img src="" alt=""><img src="" alt=""><img src="" alt=""><img src="" alt=""></p>
<p>字体颜色: 标准深红红色橙色棕色黄色绿色橄榄青色蓝色深蓝靛蓝紫色灰色白色黑色 字体大小: 标准1 (xx-small)2 (x-small)3 (small)4 (medium)5 (large)6 (x-large)7 (xx-large) 对齐: 标准居左居中居右</p>
<p>提示：选择您需要装饰的文字, 按上列按钮即可添加上相应的标签</p>
<p>您还没有登录，请<a href="http://steven-cheng.iteye.com/login" target="_blank">登录</a>后发表评论(快捷键 Alt+S / Ctrl+Enter)</p>
<p><a href="http://steven-cheng.iteye.com/" target="_blank"><img src="&quot;steven_cheng的博客: steven_cheng&quot;" alt="steven_cheng的博客"></a></p>
<p>steven_cheng</p>
<ul>
<li>浏览: 6938 次</li>
<li>来自: 北京</li>
<li><img src="" alt=""></li>
<li><a href="http://steven-cheng.iteye.com/blog/profile" target="_blank">详细资料</a> <a href="http://steven-cheng.iteye.com/blog/guest_book" target="_blank">留言簿</a></li>
</ul>
<h3 id="-">搜索本博客</h3>
<h3 id="-http-steven-cheng-iteye-com-blog-user_visits-">最近访客 <a href="http://steven-cheng.iteye.com/blog/user_visits" target="_blank">&gt;&gt;更多访客</a></h3>
<p><a href="http://loudyn.iteye.com/" target="_blank"><img src="&quot;Loudyn的博客: &quot;" alt="Loudyn的博客"></a></p>
<p><a href="http://loudyn.iteye.com/" target="_blank">Loudyn</a></p>
<p><a href="http://hepeng19861212.iteye.com/" target="_blank"><img src="&quot;hepeng19861212的博客: 火柴天堂&quot;" alt="hepeng19861212的博客"></a></p>
<p><a href="http://hepeng19861212.iteye.com/" target="_blank">hepeng19861212</a>
<a href="http://osacar.iteye.com/" target="_blank"><img src="&quot;osacar的博客: &quot;" alt="osacar的博客"></a></p>
<p><a href="http://osacar.iteye.com/" target="_blank">osacar</a></p>
<p><a href="http://kevin-gzhz.iteye.com/" target="_blank"><img src="&quot;kevin_gzhz的博客: kevin_gzhz&quot;" alt="kevin_gzhz的博客"></a></p>
<p><a href="http://kevin-gzhz.iteye.com/" target="_blank">kevin_gzhz</a></p>
<h3 id="-">博客分类</h3>
<ul>
<li><a href="http://steven-cheng.iteye.com/" target="_blank">全部博客 (8)</a></li>
<li><a href="http://steven-cheng.iteye.com/category/4287" target="_blank">默认类别 (0)</a></li>
<li><a href="http://steven-cheng.iteye.com/category/12345" target="_blank">java (6)</a></li>
<li><a href="http://steven-cheng.iteye.com/category/24850" target="_blank">单元测试和TDD (0)</a></li>
<li><a href="http://steven-cheng.iteye.com/category/48191" target="_blank">freemarker (1)</a></li>
<li><a href="http://steven-cheng.iteye.com/category/73657" target="_blank">linux (1)</a></li>
<li><p><a href="http://steven-cheng.iteye.com/category/75601" target="_blank">restlet (1)</a></p>
<h3 id="-http-steven-cheng-iteye-com-blog-guest_book-">我的留言簿 <a href="http://steven-cheng.iteye.com/blog/guest_book" target="_blank">&gt;&gt;更多留言</a></h3>
</li>
<li><p>steven_cheng 写道restlet那片原文是你的吗，如果是给个原文连接。 ...
-- by <a href="http://steven-cheng.iteye.com/blog/guest_book#6151" target="_blank">whaosoft</a></p>
</li>
</ul>
<h3 id="-">其他分类</h3>
<ul>
<li><a href="http://steven-cheng.iteye.com/blog/favorite" target="_blank">我的收藏</a> (15)</li>
<li><a href="http://steven-cheng.iteye.com/blog/code_favorite" target="_blank">我的代码</a> (0)</li>
<li><a href="http://steven-cheng.iteye.com/blog/topic" target="_blank">我的论坛主题帖</a> (1)</li>
<li><a href="http://steven-cheng.iteye.com/blog/post" target="_blank">我的所有论坛帖</a> (8)</li>
<li><a href="http://steven-cheng.iteye.com/blog/article" target="_blank">我的精华良好帖</a> (0)</li>
<li><p><a href="http://steven-cheng.iteye.com/blog/solution" target="_blank">我解决的问题</a> (1)</p>
<h3 id="-">最近加入群组</h3>
</li>
<li><p><a href="http://restlet.group.iteye.com/" target="_blank">Restlet</a></p>
</li>
<li><a href="http://freemarker.group.iteye.com/" target="_blank">FreeMarker</a></li>
</ul>
<h3 id="-">存档</h3>
<ul>
<li><a href="http://steven-cheng.iteye.com/blog/monthblog/2010-02" target="_blank">2010-02</a> (1)</li>
<li><a href="http://steven-cheng.iteye.com/blog/monthblog/2009-09" target="_blank">2009-09</a> (2)</li>
<li><a href="http://steven-cheng.iteye.com/blog/monthblog/2009-07" target="_blank">2009-07</a> (1)</li>
<li><p><a href="http://steven-cheng.iteye.com/blog/monthblog_more" target="_blank">更多存档...</a></p>
<h3 id="-">评论排行榜</h3>
</li>
<li><p><a href="http://steven-cheng.iteye.com/rss" target="_blank"><img src="" alt="Rss"></a></p>
</li>
<li><a href="http://fusion.google.com/add?feedurl=http://steven-cheng.iteye.com/rss" target="_blank"><img src="" alt="Rss_google"></a></li>
</ul>
<p>声明：ITeye文章版权属于作者，受法律保护。没有作者书面许可不得转载。若作者同意转载，必须以超链接形式标明文章原始出处和作者。
© 2003-2011 ITeye.com. All rights reserved. [ 京ICP证110151号 ]
<img src="" alt=""></p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/Java_多线程/">Java_多线程</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/Java_多线程/" class="label label-success">Java_多线程</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:41"datetime="2014-03-07 09:54:41"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-Java_多线程--用apache的configuration实现实时配置-steven_cheng-ITeye/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-Java_多线程--用apache的configuration实现实时配置-steven_cheng-ITeye" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_多线程-并发--J2EE事务并发控制策略总结/">J2EE事务并发控制策略总结</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:41.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_多线程-并发--J2EE事务并发控制策略总结/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="j2ee-">J2EE事务并发控制策略总结</h1>
<p>J2EE事务并发控制策略总结</p>
<p>本文结合Hibernate以及JPA标准，对J2EE当前持久层设计所遇到的几个问题进行总结：</p>
<p>事务并发访问控制策略</p>
<p>当前J2EE项目中，面临的一个共同问题就是如果控制事务的并发访问，虽然有些持久层框架已经为我们做了很多工作，但是理解原理，对于我们开发来说还是很有用处的。</p>
<p>事务并发访问主要可以分为两类，分别是同一个系统事务和跨事务访问的并发访问控制，其中同一个系统事务可以采取乐观锁以及悲观锁策略，而跨多个系统事务时则需要乐观离线锁和悲观离线锁。在讨论这四种并发访问控制策略之前，先需要明确一下数据库事务隔离级别的问题，ANSI标准规定了四个数据库事务隔离级别，它们分别是：</p>
<p>读取未提交（Read Uncommitted)</p>
<p>这是最低的事务隔离级别，读事务不会阻塞读事务和写事务，写事务也不会阻塞读事务，但是会阻塞写事务。这样造成的一个结果就是当一个写事务没有提交的时候，读事务照样可以读取，那么造成了脏读的现象。</p>
<p>读取已提交(Read Committed)</p>
<p>采用此种隔离界别的时候，写事务就会阻塞读事务和写事务，但是读事务不会阻塞读事务和写事务，这样因为写事务会阻塞读取事务，那么从而读取事务就不能读到脏数据，但是因为读事务不会阻塞其它的事务，这样还是会造成不可重复读的问题。</p>
<p>可重复读（Repeatable Read)</p>
<p>采用此种隔离级别，读事务会阻塞写事务，但是读事务不会阻塞读事务，但是写事务会阻塞写事务和读事务。因为读事务阻塞了写事务，这样以来就不会造成不可重复读的问题，但是这样还是不能避免幻影读问题。</p>
<p>序列化（serializable)</p>
<p>此种隔离级别是最严格的隔离级别，如果设置成这个级别，那么就不会出现以上所有的问题（脏读，不可重复读，幻影读）。但是这样以来会极大的影响到我们系统的性能，因此我们应该避免设置成为这种隔离级别，相反的，我们应该采用较低的隔离界别，然后再采用并发控制策略来进行事务的并发访问控制）。</p>
<p>其实我们也可以把事务隔离级别设置为serializable，这样就不需要采用并发控制策略了，数据库就会为我们做好一切并发控制，但是这样以来会严重影响我们系统的伸缩性和性能，所以在实践中，我们一般采用读取已提交或者更低的事务隔离级别，配合各种并发访问控制策略来达到并发事务控制的目的。下面总结一下常用的控制策略：</p>
<p>1 乐观锁</p>
<p>乐观锁是在同一个数据库事务中我们常采取的策略，因为它能使得我们的系统保持高的性能的情况下，提高很好的并发访问控制。乐观锁，顾名思义就是保持一种乐观的态度，我们认为系统中的事务并发更新不会很频繁，即使冲突了也没事，大不了重新再来一次。它的基本思想就是每次提交一个事务更新时，我们想看看要修改的东西从上次读取以后有没有被其它事务修改过，如果修改过，那么更新就会失败,。</p>
<p>最后我们需要明确一个问题，因为乐观锁其实并不会锁定任何记录，所以如果我们数据库的事务隔离级别设置为读取已提交或者更低的隔离界别，那么是不能避免不可重复读问题的（因为此时读事务不会阻塞其它事务），所以采用乐观锁的时候，系统应该要容许不可重复读问题的出现。</p>
<p>了解了乐观锁的概念以后，那么当前我们系统中又是如何来使用这种策略的呢？一般可以采用以下三种方法：</p>
<p>版本(Version)字段：在我们的实体中增加一个版本控制字段，每次事务更新后就将版本字段的值加1.</p>
<p>时间戳（timestamps)：采取这种策略后，当每次要提交更新的时候就会将系统当前时间和实体加载时的时间进行比较，如果不一致，那么就报告乐观锁失败，从而回滚事务或者重新尝试提交。采用时间戳有一些不足，比如在集群环境下，每个节点的时间同步也许会成问题，并且如果并发事务间隔时间小于当前平台最小的时钟单位，那么就会发生覆盖前一个事务结果的问题。因此一般采用版本字段比较好。</p>
<p>基于所有属性进行检测：采用这种策略的时候，需要比较每个字段在读取以后有没有被修改过，所以这种策略实现起来比较麻烦，要求对每个属性都进行比较，如果采用hiernate的话，因为Hibernate在一级缓存中可以进行脏检测，那么可以判断那些字段被修改过，从而动态的生成sql语句进行更新。</p>
<p>下面再总结一下如何在JDBC和Hibernate中使用乐观锁：</p>
<p>JDBC中使用乐观锁：如果我们采用JDBC来实现持久层的话，那么就可以采用以上将的三种支持乐观锁的策略，在实体中增加一个version字段或者一个Date字段，也可以采用基于所有属性的策略，下面就采用version字段来做一演示：</p>
<p>假如系统中有一个Account的实体类，我们在Account中多加一个version字段，那么我们JDBC Sql语句将如下写：</p>
<p>Select a.version....from Account as a where (where condition..)
Update Account set version = version+1.....(another field) where version =?...(another contidition)</p>
<p>这样以来我们就可以通过更新结果的行数来进行判断，如果更新结果的行数为0，那么说明实体从加载以来已经被其它事务更改了，所以就抛出自定义的乐观锁定异常（或者也可以采用Spring封装的异常体系）。具体实例如下：</p>
<p>.......
int rowsUpdated = statement.executeUpdate(sql);
If(rowsUpdated= =0){
throws new OptimisticLockingFailureException();
}
........</p>
<p>在使用JDBC API的情况下，我们需要在每个update语句中，都要进行版本字段的更新以及判断，因此如果稍不小心就会出现版本字段没有更新的问题，相反当前的 ORM框架却为我们做好了一切，我们仅仅需要做的就是在每个实体中都增加version或者是Date字段。</p>
<p>Hibernate中使用乐观锁：如果我们采用Hibernate做为持久层的框架，那么实现乐观锁将变得非常容易，因为框架会帮我们生成相应的sql语句，不仅减少了开发人员的负担，而且不容易出错。下面同样采用version字段的方式来总结一下：</p>
<p>同样假如系统中有一个Account的实体类，我们在Account中多加一个version字段，</p>
<p>public class Account{
Long id ;
.......
@Version //也可以采用XML文件进行配置
Int version
.......
}</p>
<p>这样以来每次我们提交事务时，hibernate内部会生成相应的SQL语句将版本字段加1，并且进行相应的版本检测，如果检测到并发乐观锁定异常，那么就抛出StaleObjectStateException.</p>
<p>2 悲观锁</p>
<p>所谓悲观锁，顾名思义就是采用一种悲观的态度来对待事务并发问题，我们认为系统中的并发更新会非常频繁，并且事务失败了以后重来的开销很大，这样以来，我们就需要采用真正意义上的锁来进行实现。悲观锁的基本思想就是每次一个事务读取某一条记录后，就会把这条记录锁住，这样其它的事务要想更新，必须等以前的事务提交或者回滚解除锁。</p>
<p>最后我们还是需要明确一个问题，假如我们数据库事务的隔离级别设置为读取已提交或者更低，那么通过悲观锁，我们控制了不可重复读的问题，但是不能避免幻影读的问题（因为要想避免我们就需要设置数据库隔离级别为Serializable,而一般情况下我们都会采取读取已提交或者更低隔离级别，并配合乐观或者悲观锁来实现并发控制，所以幻影读问题是不能避免的，如果想避免幻影读问题，那么你只能依靠数据库的serializable隔离级别（幸运的是幻影读问题一般情况下不严重）。</p>
<p>下面就分别以JDBC和Hibernate来总结一下：</p>
<p>JDBC中使用悲观锁：在JDBC中使用悲观锁，需要使用select for update语句，假如我们系统中有一个Account的类，我们可以采用如下的方式来进行：</p>
<p>Select /* from Account where ...(where condition).. for update.</p>
<p>当使用了for update语句后，每次在读取或者加载一条记录的时候，都会锁住被加载的记录，那么当其他事务如果要更新或者是加载此条记录就会因为不能获得锁而阻塞，这样就避免了不可重复读以及脏读的问题，但是其他事务还是可以插入和删除记录，这样也许同一个事务中的两次读取会得到不同的结果集，但是这不是悲观锁锁造成的问题，这是我们数据库隔离级别所造成的问题。</p>
<p>最后还需要注意的一点就是每个冲突的事务中，我们必须使用select for update 语句来进行数据库的访问，如果一些事务没有使用select for update语句，那么就会很容易造成错误，这也是采用JDBC进行悲观控制的缺点。</p>
<p>Hibernate中使用悲观锁：相比于JDBC使用悲观锁来说，在Hibernate中使用悲观锁将会容易很多，因为Hibernate有API让我们来调用，从而避免直接写SQL语句。下面就Hibernate使用悲观锁做一总结：</p>
<p>首先先要明确一下Hibernate中支持悲观锁的两种模式LockMode.UPGRADE以LockMode.UPGRADE_NO_WAIT.(PS:在JPA中，对应的锁模式是LockModeType.Read，这与Hibernate是不一样的呵呵)</p>
<p>假如我们系统中有一个Account的类，那么具体的操作可以像这样：</p>
<p>.......
session.lock(account, LockMode.UPGRADE);
......</p>
<p>或者也可以采用如下方式来加载对象：</p>
<p>session.get(Account.class,identity,LockMode.UPGRADE).</p>
<p>这样以来当加载对象时，hibernate内部会生成相应的select for update语句来加载对象，从而锁定对应的记录，避免其它事务并发更新。</p>
<p>以上两种策略都是针对同一个事务而言的，如果我们要实现跨多个事务的并发控制就要采用其它两种并发控制策略了，下面做一总结：</p>
<p>C++与java是两种完全不同风格的东西，C++是由程序员创造的，由程序员完善的，然后才出的标准的，也就是说C++的标准完全落后与C++的发展。java恰好相反，它是先有标准（可能还没有实现），然后后有的实现，而且它是由公司主导开发的，虽然现在开源了，但是标准并不是谁都能定的。这就造就了C++是百花齐放，博大精深，很少有人敢说自己C++很厉害。java却是另外的一种感觉，一切都规定好了，你只需要按照规定去做，符合标准才可以的。所以C++是那种既可以做的堂堂正正，博大精深（比如标准库），又可以实现的匪夷所思，天马行空（写 Boost库的人太牛了）。java不行，java要求如此只能如此，不能越雷池一步。</p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/Java_多线程/">Java_多线程</a></li><li><a href="/categories/Java&J2EE/Java_多线程/并发/">并发</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/Java_多线程/" class="label label-success">Java_多线程</a><a href="/tags/并发/" class="label label-info">并发</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:41"datetime="2014-03-07 09:54:41"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-Java_多线程-并发--J2EE事务并发控制策略总结/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-Java_多线程-并发--J2EE事务并发控制策略总结" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>





<ul id="pagination" class="pagination pagination-lg">
  <li><a class="extend prev" href="/page/52/">&laquo;</a></li><li><a class="page-number" href="/">1</a></li><li><a class="page-number" href="/page/2/">2</a></li><li><span class="space">&hellip;</span></li><li><a class="page-number" href="/page/50/">50</a></li><li><a class="page-number" href="/page/51/">51</a></li><li><a class="page-number" href="/page/52/">52</a></li><li class="active"><li><span class="page-number current">53</span></li><li><a class="page-number" href="/page/54/">54</a></li><li><a class="page-number" href="/page/55/">55</a></li><li><a class="page-number" href="/page/56/">56</a></li><li><span class="space">&hellip;</span></li></li><li><a class="page-number" href="/page/164/">164</a></li><li><a class="page-number" href="/page/165/">165</a></li><li><a class="extend next" href="/page/54/">&raquo;</a></li>
  <div class="clearfix"></div>
</ul></div><!--wapper-->
       </div><!-- ID main-col END -->
       <aside id="sidebar" class="alignright col-sx-6 col-sm-4 col-md-3 col-lg-3">
<div id="widget_search" class="widget panel panel-primary">
    <form action="//google.com/search" method="get" accept-charset="utf-8">
  <div class="input-group">
    <input class="form-control" id="searchbox" type="search" name="q" results="0" placeholder="search">
    <span class="input-group-btn">
      <button class="btn btn-default" type="submit">Go!</button>
    </span>
    <input type="hidden" name="q" value="site:itsolife.com">
  </div>
</form>
</div>

<div id="widget_category" class="widget panel panel-primary">
  <div class="panel-heading">category</div>  <div data-src='category' class='ajax_widgets'>正在加载...</div>
</div>

<div id="widget_recent_posts" class="widget panel panel-primary">
  <div class="panel-heading">recent posts</div>  <div data-src='recent_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_tagcloud" class="widget panel panel-primary">
  <div class="panel-heading">tagcloud</div>  <div data-src='tagcloud' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_latest_update_posts" class="widget panel panel-primary">
  <div class="panel-heading">最近更新</div>  <div data-src='latest_update_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_recent_comments" class="widget panel panel-primary">
  <div class="panel-heading">recent comments</div>  

<div class="list-group-item ds-recent-comments" data-num-items="6" data-show-avatars="1" data-show-time="1" data-show-title="1" data-show-admin="1" data-excerpt-length="50"></div>



</div>

</aside>
       <div class="clearfix"></div>
     </div><!-- row END -->
  </div>
  <footer id="footer" class="container">
  <div class="panel panel-info">
  <section id='footer_widget'></section>  <div class="panel-footer">
  <div id="site-info">
    <span class='author'>
  
  &copy; 2014 RobinChia
  
    &nbsp;&nbsp;</span>
  
  <span id='analytics-51la'></span><span id='analytics-google'>
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-48559895-1']);
  _gaq.push(['_trackPageview']);
  _js2load.push({src:('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'});
</script></span><span id='analytics-cnzz'>
<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_5774006'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s17.cnzz.com/stat.php%3Fid%3D5774006%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>
</span><span id='analytics-baidu'>
<script>
var _hmt = _hmt || [];
_js2load.push({src:"//hm.baidu.com/hm.js?1442f50724afc42380b51f097c43082c"});
</script>
</span>  </div>
  <div id="copyright">Blog powered by <a href='http://zespia.tw/hexo/'><strong>hexo</strong></a> Theme <strong><a href='https://github.com/chenall/hexo-theme-chenall'>chenall</a></strong>(Some change in it)<span class="pull-right"> 更新时间: <em>2014-03-15 15:12:18</em></span></div>
</div>
<div class="clearfix"></div>


  </div>
  </footer>
  
        <script src="http://cdn.bootcss.com/jquery/1.10.2/jquery.min.js"></script>        
        <script src="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/js/bootstrap.min.js"></script>        
                
        <script src="http://cdn.bootcss.com/prettify/r298/prettify.min.js"></script>    <script type="text/javascript">
   var lang=["bsh", "c", "cc", "cpp", "cs", "csh", "cyc", "cv", "htm", "html",
    "java", "js", "m", "mxml", "perl", "pl", "pm", "py", "rb", "sh",
    "xhtml", "xml", "xsl"];
   var pretty_base='';
   $('script').each(function(){
	var c = $(this).attr('src');
	if (!c)
	    return;
	if (c.match(/(\/)?prettify(\.min)?\.js/i))
	{
	    var index = c.lastIndexOf('/');
	    if (index != -1)
		pretty_base = c.substr(0,index + 1);
	    return false;
	}
   })
   $('pre code').each(function(){
	var c = $(this).attr('class')
	if (!c)
	    return;
	c = c.match(/\s?(lang\-\w+)/i);
	if (c && lang.indexOf(c[1]) == -1)
	{
	    lang.push(c[1]);
	    $.getScript(pretty_base + c[1] + '.min.js');
	}
   })

    $(window).load(function(){
       $("pre").addClass("prettyprint");
       prettyPrint();
    })
</script>    
            <script type="text/javascript">
var duoshuoQuery = {short_name:"robinchia"};
_js2load.push({src:'http://static.duoshuo.com/embed.js',charset:'UTF-8'});
</script>
    
            <!--wumii_relatedItems-->
    
        <script src="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js"></script>    <script type="text/javascript">
(function($){
  $('.entry').each(function(i){
    $(this).find('img').each(function(){
      var alt = this.alt;

      if (alt){
        $(this).before('<span class="caption">' + alt + '</span>');
      }

      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox" rel="fancybox' + i + '" />');
    });
  });

  $('.fancybox').fancybox();
})(jQuery);
</script>    
        <script src="http://cdn.bootcss.com/mathjax/2.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>    <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>
    
<script type="text/javascript">
$('.ajax_widgets').each(function(){var src=$(this).attr('data-src');if(src)$(this).load('/widgets/'+src+'.html');});
$.each(_js2load,function(index,obj){loadjs(obj.src,obj.charset)});
</script>

<div id="scroll2top">
<img src="/scroll2top/arrow.png"/>
</div>
<script src="/scroll2top/scroll2top.min.js"></script>
<div id="winterland">
  <canvas></canvas>
</div>
<script src="/js/winterland.min.js"></script>

  </body>
</html>
