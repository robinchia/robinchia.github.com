
<!DOCTYPE HTML>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>The 41 Page | It so life</title>
<meta name="author" content="RobinChia">

<meta name="description" content="It so life">


<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<meta property="og:site_name" content="It so life"/>

<!--[if IE]><style>.testIE.IE{display:inline;}</style><![endif]-->
<!--[if lte IE 7]><link rel="stylesheet" href="/css/ie7.css" type="text/css"><![endif]-->
<!--[if (lt IE 9)&(gt IE 7)]><style>.testIE.IE8{display:inline;}</style><![endif]-->
<!--[if gt IE 8]><style>.testIE.IE9{display:inline;}</style><![endif]-->

<link href="/favicon.png" rel="icon">
<link rel="alternate" href="/atom.xml" title="It so life Feed" type="application/atom+xml">

<link rel="stylesheet" href="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/css/bootstrap.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/font-awesome/4.0.3/css/font-awesome.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/prettify/r298/prettify.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" type="text/css">
<link rel="stylesheet" href="/css/style.css" type="text/css">
<!--[if lt IE 9]>
   <style>article,aside,dialog,footer,header,section,footer,nav,figure,menu{display:block}</style>
   <script src="http://cdn.staticfile.org/html5shiv/r29/html5.min.js"></script>
   <script src="http://cdn.staticfile.org/respond.js/1.4.2/respond.min.js"></script>
<link href="http://cdn.staticfile.org/respond.js/1.4.2/respond-proxy.html" id="respond-proxy" rel="respond-proxy" />
<link href="/js/respond.proxy.gif" id="respond-redirect" rel="respond-redirect" />
<script src="/js/respond.proxy.js"></script>
   <script src="http://cdn.bootcss.com/selectivizr/1.0.2/selectivizr-min.js"></script>
<![endif]-->
<script type="text/javascript">
function loadjs(c,d){var a=document.createElement("script");a.async=!0;a.type="text/javascript";a.src=c;a.charset=d||"gbk";(document.getElementsByTagName("HEAD")[0]||document.getElementsByTagName("BODY")[0]).appendChild(a)};
var _protocol = (("https:" == document.location.protocol) ? " https://" : " http://");
var _js2load = [];
</script>

</head>
<body>
      <header id="header" class="container"><nav id="main-nav" class="navbar navbar-default navbar-fixed-top " role="navigation">
  <div class="container">
    <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
      <span class="sr-only">Toggle navigation</span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="/">It so life</a>
    </div>
    <div  class="collapse navbar-collapse">
      <ul  class="nav navbar-nav">
  
        <li><a href="/" title="Home">Home</a></li>      
        <li><a href="/about/" title="About">About</a></li>      
        <li><a href="/archives/" title="Archives">Archives</a></li>      
      <li class='dropdown'>
        <a class='dropdown-toggle' data-toggle='dropdown' href='#'>website<b class='caret'></b></a>
        <ul class='dropdown-menu pure-menu-selected'>
    
          <li><a href="//groups.google.com/forum/#!forum/pongba" title="TopLanguage">TopLanguage</a></li>    
          <li><a href="//itpub.net/" title="ITPub">ITPub</a></li>    
          <li><a href="//blog.jobbole.com/" title="Bole">Bole</a></li>    
          <li><a href="//nosql-database.org/" title="nosql">nosql</a></li>    
          <li><a href="//gitimmersion.googol.im/" title="Git">Git</a></li>    
        </ul>
      </li>
    
      </ul>
      <ul class="nav navbar-nav navbar-right">
      
        <li><a href="/atom.xml">RSS</a></li>
      
      
        <li><a href="https://twitter.com/robinchia">twitter</a></li>
      
      
      
      
        <li><a href="https://github.com/robinchia">github</a></li>
      
      </ul>
    </div>
  </div>
</nav>
<div class="clearfix"></div>
</header>
  <div id='content' class="container">
     <div class="page-header-wrapper">
      <!--[if lt IE 9]><div class="alert alert-warning alert-dismissable"><button type="button" class="close" data-dismiss="alert" aria-hidden="true">&times;</button><strong>提示:</strong>您的浏览器版本太低了,建议升级到 <strong><a href="http://windows.microsoft.com/zh-cn/internet-explorer/download-ie" title="IE9">IE9</a></strong> 以上,本站使用<a href="https://www.google.com/intl/zh-CN/chrome/">Chrome浏览器</a>可以获得最好的显示效果.</div><![endif]-->
      <div class="page-header"><h1 align="center"><big>It so life</big> </h1>
        <h5 align="center"><big>love as life</big></h5>
      </div>
     </div>
     <div class="row">
       <div id="main-col" class="alignleft col-sx-12 col-sm-8 col-md-9 col-lg-9">
      <section id='header_widget'></section>
          <div id="wrapper"><article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_总结类--Java调用windows下某些程序/">Java调用windows下某些程序</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:43.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_总结类--Java调用windows下某些程序/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="java-windows-">Java调用windows下某些程序</h1>
<p><a href="http://www.javaeye.com/" target="_blank">首页</a> <a href="http://www.javaeye.com/news" target="_blank">新闻</a> <a href="http://www.javaeye.com/forums" target="_blank">论坛</a> <a href="http://www.javaeye.com/ask" target="_blank">问答</a> <a href="http://www.javaeye.com/blogs" target="_blank">博客</a> <a href="http://www.javaeye.com/job" target="_blank">招聘</a> <a href="http://nee.javaeye.com/blog/146233#" target="_blank">更多 ▼</a></p>
<p><a href="http://www.javaeye.com/wiki" target="_blank">专栏</a> <a href="http://www.javaeye.com/articles" target="_blank">文摘</a> <a href="http://www.javaeye.com/groups" target="_blank">圈子</a> <a href="http://www.javaeye.com/google_search" target="_blank">搜索</a></p>
<p><a href="http://nee.javaeye.com/login" title="登录" target="_blank">您还未登录 !</a> <a href="http://www.javaeye.com/all" target="_blank">我的应用</a> <a href="http://nee.javaeye.com/login" target="_blank">登录</a> <a href="http://nee.javaeye.com/signup" target="_blank">注册</a></p>
<h1 id="-lyon-carol-http-nee-javaeye-com-"><a href="http://nee.javaeye.com/" target="_blank">Lyon &amp; Carol</a></h1>
<p>永久域名 <a href="http://nee.javaeye.com/" target="_blank"><a href="http://nee.javaeye.com/">http://nee.javaeye.com/</a></a></p>
<p><a href="http://nee.javaeye.com/blog/147213" title="JavaScript FSO属性大全" target="_blank">JavaScript FSO属性大全</a> | <a href="http://nee.javaeye.com/blog/82247" title="在Eclipse状态栏上增加JVM内存用量指示器" target="_blank">在Eclipse状态栏上增加JVM内存用量指示器</a></p>
<p>2007-12-05</p>
<h3 id="-java-windows-http-nee-javaeye-com-blog-146233-"><a href="http://nee.javaeye.com/blog/146233" target="_blank">Java调用windows下某些程序</a></h3>
<p>Java是种跨平台的语言，我们经常碰到需要通过Java调用windows下某些程序。有些第三方厂商如（ANT），也提供了调用windows下可执行程序的方法，但我们往往需要调用一些批处理命令。而Java却不提供。这里，我采用一种变相的调用方法，使得Java能调用批处理命令。
前期准备
Quick Batch File (De)Compiler
将任何BAT、CMD批处理脚本编译为EXE文件。
1、运行exe 文件
Java JDK里已经提供了调用的方法，不在累赘，代码如下。
try { 　　String command = &quot;notepad&quot;; 　　Process child = 　　Runtime.getRuntime().exec(command); 　　} catch (IOException e) 　　{ 　　}
2、运行 bat（批处理） 文件
Java对批处理文件还不支持。刚开始一直在研究Java如何调用批处理文件，始终找不到解决方法。后来只好绕过批处理，考虑如何将批处理转换为exe可执行文件。然后再通过Java调用可执行文件。
在Google上搜索一下，找到Quick Batch File (De)Compiler，可以将任何BAT、CMD批处理脚本编译为EXE文件。使用了一下，果然可以。
Quick Batch File (De)Compiler使用非常简单：
Quickbfc 文件名.bat 文件名.exe（将批处理命令编译为可执行文件）
quickbfd 文件名.exe 文件名.bat（将可执行文件反编译为批处理命令）
然后，我们再按第一种方法通过Java 调用，即可。
本文来自：<a href="http://www.linuxpk.com/46886.html" target="_blank">http://www.linuxpk.com/46886.html</a></p>
<p><a href="http://nee.javaeye.com/blog/147213" title="JavaScript FSO属性大全" target="_blank">JavaScript FSO属性大全</a> | <a href="http://nee.javaeye.com/blog/82247" title="在Eclipse状态栏上增加JVM内存用量指示器" target="_blank">在Eclipse状态栏上增加JVM内存用量指示器</a></p>
<ul>
<li>16:46</li>
<li>浏览 (579)</li>
<li><a href="http://nee.javaeye.com/blog/146233#comments" target="_blank">评论</a> (0)</li>
<li>分类: <a href="http://nee.javaeye.com/category/9074" target="_blank">Java技术</a></li>
<li><a href="http://www.javaeye.com/wiki/topic/146233" target="_blank">相关推荐</a></li>
</ul>
<h3 id="-">评论</h3>
<p><a href=""></a></p>
<h3 id="-">发表评论</h3>
<p>您还没有登录，请<a href="http://nee.javaeye.com/login" target="_blank">登录</a>后发表评论(快捷键 Alt+S / Ctrl+Enter)</p>
<p><a href="http://nee.javaeye.com/" target="_blank"><img src="&quot;kyonee的博客: Lyon &amp; Carol&quot;" alt="kyonee的博客"></a></p>
<p>kyonee</p>
<ul>
<li>浏览: 15981 次</li>
<li>来自: ...</li>
<li><img src="" alt=""></li>
<li><a href="http://nee.javaeye.com/blog/profile" target="_blank">详细资料</a> <a href="http://nee.javaeye.com/blog/guest_book" target="_blank">留言簿</a></li>
</ul>
<h3 id="-">搜索本博客</h3>
<h3 id="-http-nee-javaeye-com-blog-user_visits-">最近访客 <a href="http://nee.javaeye.com/blog/user_visits" target="_blank">&gt;&gt;更多访客</a></h3>
<p><a href="http://txws-zx.javaeye.com/" target="_blank"><img src="&quot;txws.zx的博客: &quot;" alt="txws.zx的博客"></a></p>
<p><a href="http://txws-zx.javaeye.com/" target="_blank">txws.zx</a></p>
<p><a href="http://a3x60.javaeye.com/" target="_blank"><img src="&quot;a3x60的博客: &quot;" alt="a3x60的博客"></a></p>
<p><a href="http://a3x60.javaeye.com/" target="_blank">a3x60</a>
<a href="http://zhang-yingjie-qq-com.javaeye.com/" target="_blank"><img src="&quot;zhang_yingjie的博客: 凤舞九天&quot;" alt="zhang_yingjie的博客"></a></p>
<p><a href="http://zhang-yingjie-qq-com.javaeye.com/" target="_blank">zhang_yingjie</a></p>
<p><a href="http://shgavin.javaeye.com/" target="_blank"><img src="&quot;shgavin的博客: &quot;" alt="shgavin的博客"></a></p>
<p><a href="http://shgavin.javaeye.com/" target="_blank">shgavin</a></p>
<h3 id="-">博客分类</h3>
<ul>
<li><a href="http://nee.javaeye.com/" target="_blank">全部博客 (21)</a></li>
<li><a href="http://nee.javaeye.com/category/9074" target="_blank">Java技术 (10)</a></li>
<li><a href="http://nee.javaeye.com/category/9075" target="_blank">DBMS (3)</a></li>
<li><a href="http://nee.javaeye.com/category/9076" target="_blank">Delphi (0)</a></li>
<li><a href="http://nee.javaeye.com/category/9077" target="_blank">Movie &amp; DVD (0)</a></li>
<li><a href="http://nee.javaeye.com/category/9078" target="_blank">摄影 (0)</a></li>
<li><a href="http://nee.javaeye.com/category/9079" target="_blank">下载 (0)</a></li>
<li><a href="http://nee.javaeye.com/category/9080" target="_blank">其他 (8)</a><h3 id="-">我的相册</h3>
</li>
</ul>
<p><a href="http://nee.javaeye.com/album" target="_blank"><img src="" alt=""></a>1
<a href="http://nee.javaeye.com/album" target="_blank">共 5 张</a></p>
<h3 id="-">其他分类</h3>
<ul>
<li><a href="http://nee.javaeye.com/blog/favorite" target="_blank">我的收藏</a> (8)</li>
<li><a href="http://nee.javaeye.com/blog/topic" target="_blank">我的论坛主题贴</a> (0)</li>
<li><a href="http://nee.javaeye.com/blog/post" target="_blank">我的所有论坛贴</a> (1)</li>
<li><a href="http://nee.javaeye.com/blog/article" target="_blank">我的精华良好贴</a> (0)<h3 id="-">最近加入圈子</h3>
</li>
</ul>
<h3 id="-">存档</h3>
<ul>
<li><a href="http://nee.javaeye.com/blog/monthblog/2009-03" target="_blank">2009-03</a> (2)</li>
<li><a href="http://nee.javaeye.com/blog/monthblog/2008-12" target="_blank">2008-12</a> (2)</li>
<li><a href="http://nee.javaeye.com/blog/monthblog/2008-08" target="_blank">2008-08</a> (1)</li>
<li><p><a href="http://nee.javaeye.com/blog/monthblog_more" target="_blank">更多存档...</a></p>
<h3 id="-">最新评论</h3>
</li>
<li><p><a href="http://nee.javaeye.com/blog/350299#comments" title="Chrome启动参数及地址栏功能" target="_blank">Chrome启动参数及地址栏功 ...</a>
怎么里面连--app参数都没有说呢？
-- by <a href="http://iswind.javaeye.com/" target="_blank">徐风子</a></p>
</li>
<li><a href="http://nee.javaeye.com/blog/48574#comments" title="Hibernate读写Blob/Clob类型数据" target="_blank">Hibernate读写Blob/Clob ...</a>
补充:读写BLOB                                 ...
-- by <a href="http://nee.javaeye.com/" target="_blank">kyonee</a></li>
</ul>
<h3 id="-">评论排行榜</h3>
<ul>
<li><a href="http://nee.javaeye.com/rss" target="_blank"><img src="" alt="Rss"></a></li>
<li><a href="http://fusion.google.com/add?feedurl=http://nee.javaeye.com/rss" target="_blank"><img src="" alt="Rss_google"></a></li>
<li><a href="http://www.xianguo.com/subscribe.php?url=http://nee.javaeye.com/rss" target="_blank"><img src="" alt="Rss_xianguo"></a></li>
<li><a href="http://www.google.com/search?hl=zh-CN&amp;q=RSS" target="_blank">[什么是RSS?]</a>
声明：JavaEye文章版权属于作者，受法律保护。没有作者书面许可不得转载。若作者同意转载，必须以超链接形式标明文章原始出处和作者。
© 2003-2010 JavaEye.com. All rights reserved. 上海炯耐计算机软件有限公司 [ 沪ICP备05023328号 ]</li>
</ul>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/Java_总结类/">Java_总结类</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/Java_总结类/" class="label label-success">Java_总结类</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:43"datetime="2014-03-07 09:54:43"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-Java_总结类--Java调用windows下某些程序/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-Java_总结类--Java调用windows下某些程序" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-gitgithub--Git详解之三：Git分支/">Git详解之三：Git分支</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:43.000Z"> <a href="/2014/02/02/2014-02-02-gitgithub--Git详解之三：Git分支/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="git-git-">Git详解之三：Git分支</h1>
<p>原文：<a href="http://git-scm.com/book/zh" target="_blank">《Pro Git》</a></p>
<p><strong>Git 分支</strong></p>
<p>几乎每一种版本控制系统都以某种形式支持分支。使用分支意味着你可以从开发主线上分离开来，然后在不影响主线的同时继续工作。在很多版本控制系统中，这是个昂贵的过程，常常需要创建一个源代码目录的完整副本，对大型项目来说会花费很长时间。（<a href="http://www.jobbole.com/" title="1" target="_blank">伯乐</a>在线注：如果你对Git还不了解，建议从本<a href="http://blog.jobbole.com/25775/" target="_blank">Git</a>系列<a href="http://blog.jobbole.com/25775/" target="_blank">第一篇文章</a>开始阅读）</p>
<p>有人把 Git 的分支模型称为“必杀技特性”，而正是因为它，将 Git 从版本控制系统家族里区分出来。Git 有何特别之处呢？Git 的分支可谓是难以置信的轻量级，它的新建操作几乎可以在瞬间完成，并且在不同分支间切换起来也差不多一样快。和许多其他版本控制系统不同，Git 鼓励在工作流程中频繁使用分支与合并，哪怕一天之内进行许多次都没有关系。理解分支的概念并熟练运用后，你才会意识到为什么 Git 是一个如此强大而独特的工具，并从此真正改变你的开发方式。</p>
<p><strong>3.1  何谓分支</strong></p>
<p>为了理解 Git 分支的实现方式，我们需要回顾一下 Git 是如何储存数据的。或许你还记得第一章的内容，Git 保存的不是文件差异或者变化量，而只是一系列文件快照。</p>
<p>在 Git 中提交时，会保存一个提交（commit）对象，该对象包含一个指向暂存内容快照的指针，包含本次提交的作者等相关附属信息，包含零个或多个指向该提交对 象的父对象指针：首次提交是没有直接祖先的，普通提交有一个祖先，由两个或多个分支合并产生的提交则有多个祖先。</p>
<p>为直观起见，我们假设在工作目录中有三个文件，准备将它们暂存后提交。暂存操作会对每一个文件计算校验和（即第一章中提到的 SHA-1 哈希字串），然后把当前版本的文件快照保存到 Git 仓库中（Git 使用 blob 类型的对象存储这些快照），并将校验和加入暂存区域：</p>
<p>1</p>
<p>2
$ git add README</p>
<p>test</p>
<p>.rb LICENSE</p>
<p>$ git commit -m</p>
<p>&#39;initial commit of my project&#39;</p>
<p>当使用 git commit新建一个提交对象前，Git 会先计算每一个子目录（本例中就是项目根目录）的校验和，然后在 Git 仓库中将这些目录保存为树（tree）对象。之后 Git 创建的提交对象，除了包含相关提交信息以外，还包含着指向这个树对象（项目根目录）的指针，如此它就可以在将来需要的时候，重现此次快照的内容了。</p>
<p>现在，Git 仓库中有五个对象：三个表示文件快照内容的 blob 对象；一个记录着目录树内容及其中各个文件对应 blob 对象索引的 tree 对象；以及一个包含指向 tree 对象（根目录）的索引和其他提交信息元数据的 commit 对象。概念上来说，仓库中的各个对象保存的数据和相互关系看起来如图 3-1 所示：</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-branches1.png" title="Git详解之二：Git分支" target="_blank"><img src="&quot;Git详解之二：Git分支&quot;" alt="Git详解之二：Git分支"></a></p>
<p>图 3-1. 单个提交对象在仓库中的数据结构</p>
<p>作些修改后再次提交，那么这次的提交对象会包含一个指向上次提交对象的指针（译注：即下图中的 parent 对象）。两次提交后，仓库历史会变成图 3-2 的样子：</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-branches12.png" title="Git详解之二：Git分支" target="_blank"><img src="&quot;Git详解之二：Git分支&quot;" alt="Git详解之二：Git分支"></a></p>
<p>图 3-2. 多个提交对象之间的链接关系</p>
<p>现在来谈分支。Git 中的分支，其实本质上仅仅是个指向 commit 对象的可变指针。Git 会使用 master 作为分支的默认名字。在若干次提交后，你其实已经有了一个指向最后一次提交对象的 master 分支，它在每次提交的时候都会自动向前移动。</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-branches13.png" title="Git详解之二：Git分支" target="_blank"><img src="&quot;Git详解之二：Git分支&quot;" alt="Git详解之二：Git分支"></a></p>
<p>图 3-3. 分支其实就是从某个提交对象往回看的历史</p>
<p>那么，Git 又是如何创建一个新的分支的呢？答案很简单，创建一个新的分支指针。比如新建一个 testing 分支，可以使用git branch命令：
1$ git branch testing</p>
<p>这会在当前 commit 对象上新建一个分支指针（见图 3-4）。</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-branches14.png" title="Git详解之二：Git分支" target="_blank"><img src="&quot;Git详解之二：Git分支&quot;" alt="Git详解之二：Git分支"></a></p>
<p>图 3-4. 多个分支指向提交数据的历史</p>
<p>那么，Git 是如何知道你当前在哪个分支上工作的呢？其实答案也很简单，它保存着一个名为 HEAD 的特别指针。请注意它和你熟知的许多其他版本控制系统（比如 Subversion 或 CVS）里的 HEAD 概念大不相同。在 Git 中，它是一个指向你正在工作中的本地分支的指针（译注：将 HEAD 想象为当前分支的别名。）。运行</p>
<p>git branch
 命令，仅仅是建立了一个新的分支，但不会自动切换到这个分支中去，所以在这个例子中，我们依然还在 master 分支里工作（参考图 3-5）。</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-branches15.png" title="Git详解之二：Git分支" target="_blank"><img src="&quot;Git详解之二：Git分支&quot;" alt="Git详解之二：Git分支"></a></p>
<p>图 3-5. HEAD 指向当前所在的分支</p>
<p>要切换到其他分支，可以执行 git checkout命令。我们现在转换到新建的 testing 分支：
1$ git checkout testing</p>
<p>这样 HEAD 就指向了 testing 分支（见图3-6）。</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-branches16.png" title="Git详解之二：Git分支" target="_blank"><img src="&quot;Git详解之二：Git分支&quot;" alt="Git详解之二：Git分支"></a></p>
<p>图 3-6. HEAD 在你转换分支时指向新的分支</p>
<p>这样的实现方式会给我们带来什么好处呢？好吧，现在不妨再提交一次：
$ vim test.rb $ git commit -a -m ‘made a change’</p>
<p>图 3-7 展示了提交后的结果。</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-branches17.png" title="Git详解之二：Git分支" target="_blank"><img src="&quot;Git详解之二：Git分支&quot;" alt="Git详解之二：Git分支"></a></p>
<p>图 3-7. 每次提交后 HEAD 随着分支一起向前移动</p>
<p>非常有趣，现在 testing 分支向前移动了一格，而 master 分支仍然指向原先 </p>
<p>git checkout
 时所在的 commit 对象。现在我们回到 master 分支看看：
1$ git checkout master</p>
<p>图 3-8 显示了结果。</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-branches18.png" title="Git详解之二：Git分支" target="_blank"><img src="&quot;Git详解之二：Git分支&quot;" alt="Git详解之二：Git分支"></a></p>
<p>图 3-8. HEAD 在一次 checkout 之后移动到了另一个分支</p>
<p>这条命令做了两件事。它把 HEAD 指针移回到 master 分支，并把工作目录中的文件换成了 master 分支所指向的快照内容。也就是说，现在开始所做的改动，将始于本项目中一个较老的版本。它的主要作用是将 testing 分支里作出的修改暂时取消，这样你就可以向另一个方向进行开发。</p>
<p>我们作些修改后再次提交：
1</p>
<p>2
$ vim</p>
<p>test</p>
<p>.rb</p>
<p>$ git commit -a -m</p>
<p>&#39;made other changes&#39;</p>
<p>现在我们的项目提交历史产生了分叉（如图 3-9 所示），因为刚才我们创建了一个分支，转换到其中进行了一些工作，然后又回到原来的主分支进行了另外一些工作。这些改变分别孤立在不同的分支里：我们可以 在不同分支里反复切换，并在时机成熟时把它们合并到一起。而所有这些工作，仅仅需要</p>
<p>branch
 和 </p>
<p>checkout
 这两条命令就可以完成。</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-branches19.png" title="Git详解之二：Git分支" target="_blank"><img src="&quot;Git详解之二：Git分支&quot;" alt="Git详解之二：Git分支"></a></p>
<p>图 3-9. 不同流向的分支历史</p>
<p>由于 Git 中的分支实际上仅是一个包含所指对象校验和（40 个字符长度 SHA-1 字串）的文件，所以创建和销毁一个分支就变得非常廉价。说白了，新建一个分支就是向一个文件写入 41 个字节（外加一个换行符）那么简单，当然也就很快了。</p>
<p>这和大多数版本控制系统形成了鲜明对比，它们管理分支大多采取备份所有项目文件到特定目录的方式，所以根据项目文件数量和大小不同，可能花费的时间 也会有相当大的差别，快则几秒，慢则数分钟。而 Git 的实现与项目复杂度无关，它永远可以在几毫秒的时间内完成分支的创建和切换。同时，因为每次提交时都记录了祖先信息（译注：即</p>
<p>parent
 对象），将来要合并分支时，寻找恰当的合并基础（译注：即共同祖先）的工作其实已经自然而然地摆在那里了，所以实现起来非常容易。Git 鼓励开发者频繁使用分支，正是因为有着这些特性作保障。</p>
<p>接下来看看，我们为什么应该频繁使用分支。</p>
<p><strong>3.2  分支的新建与合并</strong></p>
<p>现在让我们来看一个简单的分支与合并的例子，实际工作中大体也会用到这样的工作流程：</p>
<ol>
<li>开发某个网站。 2. 为实现某个新的需求，创建一个分支。 3. 在这个分支上开展工作。</li>
</ol>
<p>假设此时，你突然接到一个电话说有个很严重的问题需要紧急修补，那么可以按照下面的方式处理：</p>
<ol>
<li>返回到原先已经发布到生产服务器上的分支。 2. 为这次紧急修补建立一个新分支，并在其中修复问题。 3. 通过测试后，回到生产服务器所在的分支，将修补分支合并进来，然后再推送到生产服务器上。 4. 切换到之前实现新需求的分支，继续工作。</li>
</ol>
<p><strong>分支的新建与切换</strong></p>
<p>首先，我们假设你正在项目中愉快地工作，并且已经提交了几次更新（见图 3-10）。</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-branches20.png" title="Git详解之二：Git分支" target="_blank"><img src="&quot;Git详解之二：Git分支&quot;" alt="Git详解之二：Git分支"></a></p>
<p>图 3-10. 一个简短的提交历史</p>
<p>现在，你决定要修补问题追踪系统上的 /#53 问题。顺带说明下，Git 并不同任何特定的问题追踪系统打交道。这里为了说明要解决的问题，才把新建的分支取名为 iss53。要新建并切换到该分支，运行git checkout 并加上 -b 参数：</p>
<p>1</p>
<p>2
$ git checkout -b iss53</p>
<p>Switched to a new branch</p>
<p>&quot;iss53&quot;</p>
<p>这相当于执行下面这两条命令：</p>
<p>1</p>
<p>2
$ git branch iss53</p>
<p>$ git checkout iss53</p>
<p>图 3-11 示意该命令的执行结果。</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-branches21.png" title="Git详解之二：Git分支" target="_blank"><img src="&quot;Git详解之二：Git分支&quot;" alt="Git详解之二：Git分支"></a></p>
<p>图 3-11. 创建了一个新分支的指针</p>
<p>接着你开始尝试修复问题，在提交了若干次更新后，iss53分支的指针也会随着向前推进，因为它就是当前分支（换句话说，当前的 HEAD 指针正指向 iss53，见图 3-12）：</p>
<p>1</p>
<p>2
$ vim index.html</p>
<p>$ git commit -a -m</p>
<p>&#39;added a new footer [issue 53]&#39;</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-branches22.png" title="Git详解之二：Git分支" target="_blank"><img src="&quot;Git详解之二：Git分支&quot;" alt="Git详解之二：Git分支"></a></p>
<p>图 3-12. iss53 分支随工作进展向前推进</p>
<p>现在你就接到了那个网站问题的紧急电话，需要马上修补。有了 Git ，我们就不需要同时发布这个补丁和 iss53 里作出的修改，也不需要在创建和发布该补丁到服务器之前花费大力气来复原这些修改。唯一需要的仅仅是切换回master 分支。</p>
<p>不过在此之前，留心你的暂存区或者工作目录里，那些还没有提交的修改，它会和你即将检出的分支产生冲突从而阻止 Git 为你切换分支。切换分支的时候最好保持一个清洁的工作区域。稍后会介绍几个绕过这种问题的办法（分别叫做 stashing 和 commit amending）。目前已经提交了所有的修改，所以接下来可以正常转换到master 分支：</p>
<p>1</p>
<p>2
$ git checkout master</p>
<p>Switched to branch</p>
<p>&quot;master&quot;</p>
<p>此时工作目录中的内容和你在解决问题 /#53 之前一模一样，你可以集中精力进行紧急修补。这一点值得牢记：Git 会把工作目录的内容恢复为检出某分支时它所指向的那个提交对象的快照。它会自动添加、删除和修改文件以确保目录的内容和你当时提交时完全一样。</p>
<p>接下来，你得进行紧急修补。我们创建一个紧急修补分支 hotfix 来开展工作，直到<a href="http://www.amazon.cn/gp/product/B007XPTAIS/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;tag=vastwork-23&amp;linkCode=as2&amp;camp=536&amp;creative=3200&amp;creativeASIN=B007XPTAIS" title="搞定(套装共3册) " target="_blank">搞定</a>（见图 3-13）：</p>
<p>1</p>
<p>2
3</p>
<p>4
5</p>
<p>6
$ git checkout -b</p>
<p>&#39;hotfix&#39;</p>
<p>Switched to a new branch</p>
<p>&quot;hotfix&quot;
$ vim index.html</p>
<p>$ git commit -a -m</p>
<p>&#39;fixed the broken email address&#39;
[hotfix]: created 3a0874c:</p>
<p>&quot;fixed the broken email address&quot;</p>
<p>1 files changed, 0 insertions(+), 1 deletions(-)</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-branches23.png" title="Git详解之二：Git分支" target="_blank"><img src="&quot;Git详解之二：Git分支&quot;" alt="Git详解之二：Git分支"></a></p>
<p>图 3-13. hotfix 分支是从 master 分支所在点分化出来的</p>
<p>有必要作些测试，确保修补是成功的，然后回到 master 分支并把它合并进来，然后发布到生产服务器。用 git merge 命令来进行合并：</p>
<p>1</p>
<p>2
3</p>
<p>4
5</p>
<p>6
$ git checkout master</p>
<p>$ git merge hotfix
Updating f42c576..3a0874c</p>
<p>Fast forward
README | 1 -</p>
<p>1 files changed, 0 insertions(+), 1 deletions(-)</p>
<p>请注意，合并时出现了“Fast forward”的提示。由于当前 master 分支所在的提交对象是要并入的 hotfix 分支的直接上游，Git 只需把master 分支指针直接右移。换句话说，如果顺着一个分支走下去可以到达另一个分支的话，那么 Git 在合并两者时，只会简单地把指针右移，因为这种单线的历史分支不存在任何需要解决的分歧，所以这种合并过程可以称为快进（Fast forward）。</p>
<p>现在最新的修改已经在当前 master 分支所指向的提交对象中了，可以部署到生产服务器上去了（见图 3-14）。</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-branches24.png" title="Git详解之二：Git分支" target="_blank"><img src="&quot;Git详解之二：Git分支&quot;" alt="Git详解之二：Git分支"></a></p>
<p>图 3-14. 合并之后，master 分支和 hotfix 分支指向同一位置。</p>
<p>在那个超级重要的修补发布以后，你想要回到被打扰之前的工作。由于当前 hotfix 分支和 master 都指向相同的提交对象，所以hotfix 已经完成了历史使命，可以删掉了。使用 git branch 的 -d 选项执行删除操作：</p>
<p>1</p>
<p>2
$ git branch -d hotfix</p>
<p>Deleted branch hotfix (3a0874c).</p>
<p>现在回到之前未完成的 /#53 问题修复分支上继续工作（图 3-15）：</p>
<p>1</p>
<p>2
3</p>
<p>4
5</p>
<p>6
$ git checkout iss53</p>
<p>Switched to branch</p>
<p>&quot;iss53&quot;
$ vim index.html</p>
<p>$ git commit -a -m</p>
<p>&#39;finished the new footer [issue 53]&#39;
[iss53]: created ad82d7a:</p>
<p>&quot;finished the new footer [issue 53]&quot;</p>
<p>1 files changed, 1 insertions(+), 0 deletions(-)</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-branches25.png" title="Git详解之二：Git分支" target="_blank"><img src="&quot;Git详解之二：Git分支&quot;" alt="Git详解之二：Git分支"></a></p>
<p>图 3-15. iss53 分支可以不受影响继续推进。</p>
<p>不用担心之前 hotfix 分支的修改内容尚未包含到 iss53 中来。如果确实需要纳入此次修补，可以用git merge master 把 master 分支合并到 iss53；或者等 iss53 完成之后，再将iss53 分支中的更新并入 master。</p>
<p><strong>分支的合并</strong></p>
<p>在问题 /#53 相关的工作完成之后，可以合并回 master 分支。实际操作同前面合并 hotfix 分支差不多，只需回到master分支，运行 git merge 命令指定要合并进来的分支：</p>
<p>1</p>
<p>2
3</p>
<p>4
5$ git checkout master</p>
<p>$ git merge iss53
Merge made by recursive.</p>
<p>README | 1 +
1 files changed, 1 insertions(+), 0 deletions(-)</p>
<p>请注意，这次合并操作的底层实现，并不同于之前 hotfix 的并入方式。因为这次你的开发历史是从更早的地方开始分叉的。由于当前 master 分支所指向的提交对象（C4）并不是 iss53 分支的直接祖先，Git 不得不进行一些额外处理。就此例而言，Git 会用两个分支的末端（C4 和 C5）以及它们的共同祖先（C2）进行一次简单的三方合并计算。图 3-16 用红框标出了 Git 用于合并的三个提交对象：</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-branches26.png" title="Git详解之二：Git分支" target="_blank"><img src="&quot;Git详解之二：Git分支&quot;" alt="Git详解之二：Git分支"></a></p>
<p>图 3-16. Git 为分支合并自动识别出最佳的同源合并点。</p>
<p>这次，Git 没有简单地把分支指针右移，而是对三方合并后的结果重新做一个新的快照，并自动创建一个指向它的提交对象（C6）（见图 3-17）。这个提交对象比较特殊，它有两个祖先（C4 和 C5）。</p>
<p>值得一提的是 Git 可以自己裁决哪个共同祖先才是最佳合并基础；这和 CVS 或 Subversion（1.5 以后的版本）不同，它们需要开发者手工指定合并基础。所以此特性让 Git 的合并操作比其他系统都要简单不少。</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-branches27.png" title="Git详解之二：Git分支" target="_blank"><img src="&quot;Git详解之二：Git分支&quot;" alt="Git详解之二：Git分支"></a></p>
<p>图 3-17. Git 自动创建了一个包含了合并结果的提交对象。</p>
<p>既然之前的工作成果已经合并到 master 了，那么 iss53 也就没用了。你可以就此删除它，并在问题追踪系统里关闭该问题。
1$ git branch -d iss53</p>
<p><strong>遇到冲突时的分支合并</strong></p>
<p>有时候合并操作并不会如此顺利。如果在不同的分支中都修改了同一个文件的同一部分，Git 就无法干净地把两者合到一起（译注：逻辑上说，这种问题只能由人来裁决。）。如果你在解决问题 /#53 的过程中修改了hotfix 中修改的部分，将得到类似下面的结果：</p>
<p>1</p>
<p>2
3</p>
<p>4
$ git merge iss53</p>
<p>Auto-merging index.html
CONFLICT (content): Merge conflict</p>
<p>in</p>
<p>index.html</p>
<p>Automatic merge failed; fix conflicts and</p>
<p>then</p>
<p>commit the result.</p>
<p>Git 作了合并，但没有提交，它会停下来等你解决冲突。要看看哪些文件在合并时发生冲突，可以用 git status 查阅：
1</p>
<p>2
3</p>
<p>4
5</p>
<p>6
7</p>
<p>8
9</p>
<p>10
11[master/*]$ git status</p>
<p>index.html: needs merge
/# On branch master</p>
<p>/# Changed but not updated:
/# (use &quot;git add</p>
<p>...&quot; to update what will be committed)
/# (use &quot;git checkout -- ...&quot;</p>
<p>to discard changes</p>
<p>in</p>
<p>working directory)
/#</p>
<p>/# unmerged: index.html
/#</p>
<p>任何包含未解决冲突的文件都会以未合并（unmerged）的状态列出。Git 会在有冲突的文件里加入标准的冲突解决标记，可以通过它们来手工定位并解决这些冲突。可以看到此文件包含类似下面这样的部分：</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-branches01.png" title="Git branches01" target="_blank"><img src="&quot;Git branches01&quot;" alt=""></a><a href="http://cdn2.jobbole.com/2012/08/Git-branches02.png" title="Git branches02" target="_blank"><img src="&quot;Git branches02&quot;" alt=""></a></p>
<p>可以看到 ======= 隔开的上半部分，是 HEAD（即 master 分支，在运行merge 命令时所切换到的分支）中的内容，下半部分是在 iss53 分支中的内容。解决冲突的办法无非是二者选其一或者由你亲自整合到一起。比如你可以通过把这段内容替换为下面这样来解决：</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-branches03.png" title="Git branches03" target="_blank"><img src="&quot;Git branches03&quot;" alt=""></a></p>
<p>这个解决方案各采纳了两个分支中的一部分内容，而且我还删除了 &lt;&lt;&lt;&lt;&lt;&lt;&lt;，======= 和 &gt;&gt;&gt;&gt;&gt;&gt;&gt; 这些行。在解决了所有文件里的所有冲突后，运行 git add 将把它们标记为已解决状态（译注：实际上就是来一次快照保存到暂存区域。）。因为一旦暂存，就表示冲突已经解决。如果你想用一个有图形界面的工具来解决这些问题，不妨运行git mergetool，它会调用一个可视化的合并工具并引导你解决所有冲突：</p>
<p>1</p>
<p>2
3</p>
<p>4
5</p>
<p>6
7$ git mergetool</p>
<p>merge tool candidates: kdiff3 tkdiff xxdiff meld gvimdiff opendiff emerge vimdiff
Merging the files: index.html</p>
<p>Normal merge conflict</p>
<p>for</p>
<p>&#39;index.html&#39;</p>
<p>:
{</p>
<p>local</p>
<p>}: modified</p>
<p>{remote}: modified
Hit</p>
<p>return</p>
<p>to start merge resolution tool (opendiff):</p>
<p>如果不想用默认的合并工具（Git 为我默认选择了 opendiff，因为我在 Mac 上运行了该命令），你可以在上方”merge tool candidates”里找到可用的合并工具列表，输入你想用的工具名。我们将在第七章讨论怎样改变环境中的默认值。</p>
<p>退出合并工具以后，Git 会询问你合并是否成功。如果回答是，它会为你把相关文件暂存起来，以表明状态为已解决。</p>
<p>再运行一次 git status 来确认所有冲突都已解决：</p>
<p>1</p>
<p>2
3</p>
<p>4
5</p>
<p>6
7</p>
<p>8
$ git status</p>
<p>/# On branch master
/# Changes to be committed:</p>
<p>/# (use &quot;git reset HEAD
...&quot; to unstage)</p>
<p>/#
/# modified: index.html</p>
<p>/#</p>
<p>如果觉得满意了，并且确认所有冲突都已解决，也就是进入了暂存区，就可以用 git commit 来完成这次合并提交。提交的记录差不多是这样：</p>
<p>1</p>
<p>2
3</p>
<p>4
5</p>
<p>6
7</p>
<p>8
Merge branch</p>
<p>&#39;iss53&#39;</p>
<p>Conflicts:
index.html</p>
<p>/#
/# It looks like you may be committing a MERGE.</p>
<p>/# If this is not correct, please remove the file
/# .git/MERGE_HEAD /# and try again.</p>
<p>/#</p>
<p>如果想给将来看这次合并的人一些方便，可以修改该信息，提供更多合并细节。比如你都作了哪些改动，以及这么做的原因。有时候裁决冲突的理由并不直接或明显，有必要略加注解。</p>
<hr>
<p><strong>3.3  分支的管理</strong></p>
<p>到目前为止，你已经学会了如何创建、合并和删除分支。除此之外，我们还需要学习如何管理分支，在日后的常规工作中会经常用到下面介绍的管理命令。</p>
<p>git branch 命令不仅仅能创建和删除分支，如果不加任何参数，它会给出当前所有分支的清单：
1</p>
<p>2
3</p>
<p>4
$ git branch</p>
<p>iss53
/* master</p>
<p>testing</p>
<p>注意看 master 分支前的 /* 字符：它表示当前所在的分支。也就是说，如果现在提交更新，master 分支将随着开发进度前移。若要查看各个分支最后一个提交对象的信息，运行git branch -v：</p>
<p>1</p>
<p>2
3</p>
<p>4
$ git branch -</p>
<p>v</p>
<p>iss53 93b412c fix javascript issue
/* master 7a98805 Merge branch</p>
<p>&#39;iss53&#39;</p>
<p>testing 782fd34 add scott to the author list</p>
<p>in</p>
<p>the readmes</p>
<p>要从该清单中筛选出你已经（或尚未）与当前分支合并的分支，可以用 –merge 和 –no-merged 选项（Git 1.5.6 以上版本）。比如用git branch –merge 查看哪些分支已被并入当前分支（译注：也就是说哪些分支是当前分支的直接上游。）：</p>
<p>1</p>
<p>2
3$ git branch --merged</p>
<p>iss53
/* master</p>
<p>之前我们已经合并了 iss53，所以在这里会看到它。一般来说，列表中没有 /* 的分支通常都可以用 git branch -d 来删掉。原因很简单，既然已经把它们所包含的工作整合到了其他分支，删掉也不会损失什么。</p>
<p>另外可以用 git branch –no-merged 查看尚未合并的工作：</p>
<p>1</p>
<p>2
$ git branch --no-merged</p>
<p>testing</p>
<p>它会显示还未合并进来的分支。由于这些分支中还包含着尚未合并进来的工作成果，所以简单地用 git branch -d 删除该分支会提示错误，因为那样做会丢失数据：
1</p>
<p>2
3$ git branch -d testing</p>
<p>error: The branch</p>
<p>&#39;testing&#39;</p>
<p>is not an ancestor of your current HEAD.
If you are sure you want to delete it, run</p>
<p>&#39;git branch -D testing&#39;</p>
<p>.</p>
<p>不过，如果你确实想要删除该分支上的改动，可以用大写的删除选项 -D 强制执行，就像上面提示信息中给出的那样。</p>
<p><strong>3.4  利用分支进行开发的工作流程</strong></p>
<p>现在我们已经学会了新建分支和合并分支，可以（或应该）用它来做点什么呢？在本节，我们会介绍一些利用分支进行开发的工作流程。而正是由于分支管理的便捷，才衍生出了这类典型的工作模式，你可以根据项目的实际情况选择一种用用看。</p>
<p><strong>长期分支</strong></p>
<p>由于 Git 使用简单的三方合并，所以就算在较长一段时间内，反复多次把某个分支合并到另一分支，也不是什么难事。也就是说，你可以同时拥有多个开放的分支，每个分支用于完成特定的任务，随着开发的推进，你可以随时把某个特性分支的成果并到其他分支中。</p>
<p>许多使用 Git 的开发者都喜欢用这种方式来开展工作，比如仅在 master 分支中保留完全稳定的代码，即已经发布或即将发布的代码。与此同时，他们还有一个名为develop 或 next 的平行分支，专门用于后续的开发，或仅用于稳定性测试 — 当然并不是说一定要绝对稳定，不过一旦进入某种稳定状态，便可以把它合并到master 里。这样，在确保这些已完成的特性分支（短期分支，比如之前的 iss53 分支）能够通过所有测试，并且不会引入更多错误之后，就可以并到主干分支中，等待下一次的发布。</p>
<p>本质上我们刚才谈论的，是随着提交对象不断右移的指针。稳定分支的指针总是在提交历史中落后一大截，而前沿分支总是比较靠前（见图 3-18）。</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-branches28.png" title="Git详解之二：Git分支" target="_blank"><img src="&quot;Git详解之二：Git分支&quot;" alt="Git详解之二：Git分支"></a></p>
<p>图 3-18. 稳定分支总是比较老旧。</p>
<p>或者把它们想象成工作流水线，或许更好理解一些，经过测试的提交对象集合被遴选到更稳定的流水线（见图 3-19）。</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-branches29.png" title="Git详解之二：Git分支" target="_blank"><img src="&quot;Git详解之二：Git分支&quot;" alt="Git详解之二：Git分支"></a></p>
<p>图 3-19. 想象成流水线可能会容易点。</p>
<p>你可以用这招维护不同层次的稳定性。某些大项目还会有个 proposed（建议）或 pu（proposed updates，建议更新）分支，它包含着那些可能还没有成熟到进入next 或 master 的内容。这么做的目的是拥有不同层次的稳定性：当这些分支进入到更稳定的水平时，再把它们合并到更高层分支中去。再次说明下，使用多个长期分支的做法并非必需，不过一般来说，对于特大型项目或特复杂的项目，这么做确实更容易管理。</p>
<p><strong>特性分支</strong></p>
<p>在任何规模的项目中都可以使用特性（Topic）分支。一个特性分支是指一个短期的，用来实现单一特性或与其相关工作的分支。可能你在以前的版本控 制系统里从未做过类似这样的事情，因为通常创建与合并分支消耗太大。然而在 Git 中，一天之内建立、使用、合并再删除多个分支是常见的事。</p>
<p>我们在上节的例子里已经见过这种用法了。我们创建了 iss53 和 hotfix 这两个特性分支，在提交了若干更新后，把它们合并到主干分支，然后删除。该技术允许你迅速且完全的进行语境切换 — 因为你的工作分散在不同的流水线里，每个分支里的改变都和它的目标特性相关，浏览代码之类的事情因而变得更简单了。你可以把作出的改变保持在特性分支中几 分钟，几天甚至几个月，等它们成熟以后再合并，而不用在乎它们建立的顺序或者进度。</p>
<p>现在我们来看一个实际的例子。请看图 3-20，由下往上，起先我们在 master 工作到 C1，然后开始一个新分支 iss91 尝试修复 91 号缺陷，提交到 C6 的时候，又冒出一个解决该问题的新办法，于是从之前 C4 的地方又分出一个分支iss91v2，干到 C8 的时候，又回到主干 master 中提交了 C9 和 C10，再回到 iss91v2 继续工作，提交 C11，接着，又冒出个不太确定的想法，从 master 的最新提交 C10 处开了个新的分支dumbidea 做些试验。</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-branches30.png" title="Git详解之二：Git分支" target="_blank"><img src="&quot;Git详解之二：Git分支&quot;" alt="Git详解之二：Git分支"></a></p>
<p>图 3-20. 拥有多个特性分支的提交历史。</p>
<p>现在，假定两件事情：我们最终决定使用第二个解决方案，即 iss91v2 中的办法；另外，我们把 dumbidea 分支拿给同事们看了以后，发现它竟然是个天才之作。所以接下来，我们准备抛弃原来的iss91 分支（实际上会丢弃 C5 和 C6），直接在主干中并入另外两个分支。最终的提交历史将变成图 3-21 这样：</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-branches31.png" title="Git详解之二：Git分支" target="_blank"><img src="&quot;Git详解之二：Git分支&quot;" alt="Git详解之二：Git分支"></a></p>
<p>图 3-21. 合并了 dumbidea 和 iss91v2 后的分支历史。</p>
<p>请务必牢记这些分支全部都是本地分支，这一点很重要。当你在使用分支及合并的时候，一切都是在你自己的 Git 仓库中进行的 — 完全不涉及与服务器的交互。</p>
<hr>
<p><strong>3.5  远程分支</strong></p>
<p>远程分支（remote branch）是对远程仓库中的分支的索引。它们是一些无法移动的本地分支；只有在 Git 进行网络交互时才会更新。远程分支就像是书签，提醒着你上次连接远程仓库时上面各分支的位置。</p>
<p>我们用 (远程仓库名)/(分支名) 这样的形式表示远程分支。比如我们想看看上次同 origin 仓库通讯时master 的样子，就应该查看 origin/master 分支。如果你和同伴一起修复某个问题，但他们先推送了一个iss53 分支到远程仓库，虽然你可能也有一个本地的 iss53 分支，但指向服务器上最新更新的却应该是 origin/iss53 分支。</p>
<p>可能有点乱，我们不妨举例说明。假设你们团队有个地址为 git.ourcompany.com 的 Git 服务器。如果你从这里克隆，Git 会自动为你将此远程仓库命名为origin，并下载其中所有的数据，建立一个指向它的 master 分支的指针，在本地命名为origin/master，但你无法在本地更改其数据。接着，Git 建立一个属于你自己的本地master 分支，始于 origin 上 master分支相同的位置，你可以就此开始工作（见图 3-22）：</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-branches32.png" title="Git详解之二：Git分支" target="_blank"><img src="&quot;Git详解之二：Git分支&quot;" alt="Git详解之二：Git分支"></a></p>
<p>图 3-22. 一次 Git 克隆会建立你自己的本地分支 master 和远程分支 origin/master，它们都指向 origin/master 分支的最后一次提交。</p>
<p>如果你在本地 master 分支做了些改动，与此同时，其他人向 git.ourcompany.com 推送了他们的更新，那么服务器上的master 分支就会向前推进，而于此同时，你在本地的提交历史正朝向不同方向发展。不过只要你不和服务器通讯，你的 origin/master 指针仍然保持原位不会移动（见图 3-23）。</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-branches33.png" title="Git详解之二：Git分支" target="_blank"><img src="&quot;Git详解之二：Git分支&quot;" alt="Git详解之二：Git分支"></a></p>
<p>图 3-23. 在本地工作的同时有人向远程仓库推送内容会让提交历史开始分流。</p>
<p>可以运行 git fetch origin 来同步远程服务器上的数据到本地。该命令首先找到 origin 是哪个服务器（本例为git.ourcompany.com），从上面获取你尚未拥有的数据，更新你本地的数据库，然后把 origin/master 的指针移到它最新的位置上（见图 3-24）。</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-branches34.png" title="Git详解之二：Git分支" target="_blank"><img src="&quot;Git详解之二：Git分支&quot;" alt="Git详解之二：Git分支"></a></p>
<p>图 3-24. git fetch 命令会更新 remote 索引。</p>
<p>为了演示拥有多个远程分支（在不同的远程服务器上）的项目是如何工作的，我们假设你还有另一个仅供你的敏捷开发小组使用的内部服务器 git.team1.ourcompany.com。可以用第二章中提到的git remote add 命令把它加为当前项目的远程分支之一。我们把它命名为 teamone，以便代替原始的 Git 地址（见图 3-25）。</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-branches35.png" title="Git详解之二：Git分支" target="_blank"><img src="&quot;Git详解之二：Git分支&quot;" alt="Git详解之二：Git分支"></a></p>
<p>图 3-25. 把另一个服务器加为远程仓库</p>
<p>现在你可以用 git fetch teamone 来获取小组服务器上你还没有的数据了。由于当前该服务器上的内容是你 origin 服务器上的子集，Git 不会下载任何数据，而只是简单地创建一个名为teamone/master 的分支，指向 teamone 服务器上 master分支所在的提交对象31b8e（见图 3-26）。</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-branches36.png" title="Git详解之二：Git分支" target="_blank"><img src="&quot;Git详解之二：Git分支&quot;" alt="Git详解之二：Git分支"></a></p>
<p>图 3-26. 你在本地有了一个指向 teamone 服务器上 master 分支的索引。</p>
<p><strong>推送本地分支</strong></p>
<p>要想和其他人分享某个本地分支，你需要把它推送到一个你拥有写权限的远程仓库。你的本地分支不会被自动同步到你引入的远程服务器上，除非你明确执行推送操作。换句话说，对于无意分享的分支，你尽管保留为私人分支好了，而只推送那些协同工作要用到的特性分支。</p>
<p>如果你有个叫 serverfix 的分支需要和他人一起开发，可以运行 git push (远程仓库名) (分支名)：</p>
<p>1</p>
<p>2
3</p>
<p>4
5</p>
<p>6
7$ git push origin serverfix</p>
<p>Counting objects: 20,</p>
<p>done</p>
<p>.
Compressing objects: 100% (14</p>
<p>/14</p>
<p>),</p>
<p>done</p>
<p>.</p>
<p>Writing objects: 100% (15</p>
<p>/15</p>
<p>), 1.74 KiB,</p>
<p>done</p>
<p>.
Total 15 (delta 5), reused 0 (delta 0)</p>
<p>To git@ &lt;span class=</p>
<p>&quot;wp_keywordlink&quot;</p>
<blockquote>
<p>&lt;a href=</p>
</blockquote>
<p>&quot;<a href="http://blog.jobbole.com/6492/" target="_blank">http://blog.jobbole.com/6492/</a>&quot;</p>
<p>title=</p>
<p>&quot;GitHub如何运作：时间并不决定一切&quot;</p>
<p>target=</p>
<p>&quot;_blank&quot;</p>
<blockquote>
<p>GitHub&lt;</p>
</blockquote>
<p>/a</p>
<blockquote>
<p>&lt;</p>
</blockquote>
<p>/span</p>
<blockquote>
<p>.com:schacon</p>
</blockquote>
<p>/simplegit</p>
<p>.git
/* [new branch] serverfix -&gt; serverfix</p>
<p>这其实有点像条捷径。Git 自动把 serverfix 分支名扩展为 refs/heads/serverfix:refs/heads/serverfix，意为“取出我在本地的 serverfix 分支，推送到远程仓库的 serverfix 分支中去”。我们将在第九章进一步介绍refs/heads/ 部分的细节，不过一般使用的时候都可以省略它。也可以运行 git push origin serverfix:serferfix 来实现相同的效果，它的意思是“上传我本地的 serverfix 分支到远程仓库中去，仍旧称它为 serverfix 分支”。通过此语法，你可以把本地分支推送到某个命名不同的远程分支：若想把远程分支叫作awesomebranch，可以用 git push origin serverfix:awesomebranch 来推送数据。</p>
<p>接下来，当你的协作者再次从服务器上获取数据时，他们将得到一个新的远程分支 origin/serverfix：</p>
<p>1</p>
<p>2
3</p>
<p>4
5</p>
<p>6
7$ git fetch origin</p>
<p>remote: Counting objects: 20,</p>
<p>done</p>
<p>.
remote: Compressing objects: 100% (14</p>
<p>/14</p>
<p>),</p>
<p>done</p>
<p>.</p>
<p>remote: Total 15 (delta 5), reused 0 (delta 0)
Unpacking objects: 100% (15</p>
<p>/15</p>
<p>),</p>
<p>done</p>
<p>.</p>
<p>From git@ github.com:schacon</p>
<p>/simplegit
/* [new branch] serverfix -&gt; origin</p>
<p>/serverfix</p>
<p>值得注意的是，在 fetch 操作下载好新的远程分支之后，你仍然无法在本地编辑该远程仓库中的分支。换句话说，在本例中，你不会有一个新的serverfix 分支，有的只是一个你无法移动的 origin/serverfix 指针。</p>
<p>如果要把该内容合并到当前分支，可以运行 git merge origin/serverfix。如果想要一份自己的 serverfix 来开发，可以在远程分支的基础上分化出一个新的分支来：</p>
<p>1</p>
<p>2
3$ git checkout -b serverfix origin</p>
<p>/serverfix</p>
<p>Branch serverfix</p>
<p>set</p>
<p>up to track remote branch refs</p>
<p>/remotes/origin/serverfix</p>
<p>.
Switched to a new branch</p>
<p>&quot;serverfix&quot;</p>
<p>这会切换到新建的 serverfix 本地分支，其内容同远程分支 origin/serverfix 一致，这样你就可以在里面继续开发了。</p>
<p><strong>跟踪远程分支</strong></p>
<p>从远程分支 checkout 出来的本地分支，称为<em>跟踪分支(tracking branch)</em>。跟踪分支是一种和远程分支有直接联系的本地分支。在跟踪分支里输入git push，Git 会自行推断应该向哪个服务器的哪个分支推送数据。反过来，在这些分支里运行 git pull 会获取所有远程索引，并把它们的数据都合并到本地分支中来。</p>
<p>在克隆仓库时，Git 通常会自动创建一个名为 master 的分支来跟踪 origin/master。这正是git push 和 git pull 一开始就能正常工作的原因。当然，你可以随心所欲地设定为其它跟踪分支，比如origin 上除了 master 之外的其它分支。刚才我们已经看到了这样的一个例子：git checkout -b [分支名] [远程名]/[分支名]。如果你有 1.6.2 以上版本的 Git，还可以用–track 选项简化：
1</p>
<p>2
3$ git checkout --track origin</p>
<p>/serverfix</p>
<p>Branch serverfix</p>
<p>set</p>
<p>up to track remote branch refs</p>
<p>/remotes/origin/serverfix</p>
<p>.
Switched to a new branch</p>
<p>&quot;serverfix&quot;</p>
<p>要为本地分支设定不同于远程分支的名字，只需在前个版本的命令里换个名字：</p>
<p>1</p>
<p>2
3$ git checkout -b sf origin</p>
<p>/serverfix</p>
<p>Branch sf</p>
<p>set</p>
<p>up to track remote branch refs</p>
<p>/remotes/origin/serverfix</p>
<p>.
Switched to a new branch</p>
<p>&quot;sf&quot;</p>
<p>现在你的本地分支 sf 会自动向 origin/serverfix 推送和抓取数据了。</p>
<p><strong>删除远程分支</strong></p>
<p>如果不再需要某个远程分支了，比如搞定了某个特性并把它合并进了远程的 master 分支（或任何其他存放稳定代码的地方），可以用这个非常无厘头的语法来删除它：git push [远程名] :[分支名]。如果想在服务器上删除serverfix 分支，运行下面的命令：
1</p>
<p>2
3$ git push origin :serverfix</p>
<p>To git@ github.com:schacon</p>
<p>/simplegit</p>
<p>.git</p>
<ul>
<li>[deleted] serverfix</li>
</ul>
<p>咚！服务器上的分支没了。你最好特别留心这一页，因为你一定会用到那个命令，而且你很可能会忘掉它的语法。有种方便记忆这条命令的方法：记住我们不久前见过的 git push [远程名] [本地分支]:[远程分支] 语法，如果省略 [本地分支]，那就等于是在说“在这里提取空白然后把它变成[远程分支]”。</p>
<p><strong>3.6  分支的衍合</strong></p>
<p>把一个分支整合到另一个分支的办法有两种：merge 和 rebase（译注：rebase 的翻译暂定为“衍合”，大家知道就可以了。）。在本章我们会学习什么是衍合，如何使用衍合，为什么衍合操作如此富有魅力，以及我们应该在什么情况下使用衍合。</p>
<p><strong>基本的衍合操作</strong></p>
<p>回顾之前有关合并的一节（见图 3-27），你会看到开发进程分叉到两个不同分支，又各自提交了更新。</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-branches37.png" title="Git详解之二：Git分支" target="_blank"><img src="&quot;Git详解之二：Git分支&quot;" alt="Git详解之二：Git分支"></a></p>
<p>图 3-27. 最初分叉的提交历史。</p>
<p>之前介绍过，最容易的整合分支的方法是 merge 命令，它会把两个分支最新的快照（C3 和 C4）以及二者最新的共同祖先（C2）进行三方合并，合并的结果是产生一个新的提交对象（C5）。如图 3-28 所示：</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-branches38.png" title="Git详解之二：Git分支" target="_blank"><img src="&quot;Git详解之二：Git分支&quot;" alt="Git详解之二：Git分支"></a></p>
<p>图 3-28. 通过合并一个分支来整合分叉了的历史。</p>
<p>其实，还有另外一个选择：你可以把在 C3 里产生的变化补丁在 C4 的基础上重新打一遍。在 Git 里，这种操作叫做<em>衍合（rebase）</em>。有了 rebase 命令，就可以把在一个分支里提交的改变移到另一个分支里重放一遍。</p>
<p>在上面这个例子中，运行：
1</p>
<p>2
3</p>
<p>4
$ git checkout experiment</p>
<p>$ git rebase master
First, rewinding</p>
<p>head</p>
<p>to replay your work on</p>
<p>top</p>
<p>of it...</p>
<p>Applying: added staged</p>
<p>command</p>
<p>它的原理是回到两个分支最近的共同祖先，根据当前分支（也就是要进行衍合的分支 experiment）后续的历次提交对象（这里只有一个 C3），生成一系列文件补丁，然后以基底分支（也就是主干分支master）最后一个提交对象（C4）为新的出发点，逐个应用之前准备好的补丁文件，最后会生成一个新的合并提交对象（C3’），从而改写 experiment 的提交历史，使它成为 master 分支的直接下游，如图 3-29 所示：</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-branches39.png" title="Git详解之二：Git分支" target="_blank"><img src="&quot;Git详解之二：Git分支&quot;" alt="Git详解之二：Git分支"></a></p>
<p>图 3-29. 把 C3 里产生的改变到 C4 上重演一遍。</p>
<p>现在回到 master 分支，进行一次快进合并（见图 3-30）：</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-branches40.png" title="Git详解之二：Git分支" target="_blank"><img src="&quot;Git详解之二：Git分支&quot;" alt="Git详解之二：Git分支"></a></p>
<p>图 3-30. master 分支的快进。</p>
<p>现在的 C3’ 对应的快照，其实和普通的三方合并，即上个例子中的 C5 对应的快照内容一模一样了。虽然最后整合得到的结果没有任何区别，但衍合能产生一个更为整洁的提交历史。如果视察一个衍合过的分支的历史记录，看起来会更 清楚：仿佛所有修改都是在一根线上先后进行的，尽管实际上它们原本是同时并行发生的。</p>
<p>一般我们使用衍合的目的，是想要得到一个能在远程分支上干净应用的补丁 — 比如某些项目你不是维护者，但想帮点忙的话，最好用衍合：先在自己的一个分支里进行开发，当准备向主项目提交补丁的时候，根据最新的origin/master 进行一次衍合操作然后再提交，这样维护者就不需要做任何整合工作（译注：实际上是把解决分支补丁同最新主干代码之间冲突的责任，化转为由提交补丁的人来解决。），只需根据你提供的仓库地址作一次快进合并，或者直接采纳你提交的补丁。</p>
<p>请注意，合并结果中最后一次提交所指向的快照，无论是通过衍合，还是三方合并，都会得到相同的快照内容，只不过提交历史不同罢了。衍合是按照每行的修改次序重演一遍修改，而合并是把最终结果合在一起。</p>
<p><strong>有趣的衍合</strong></p>
<p>衍合也可以放到其他分支进行，并不一定非得根据分化之前的分支。以图 3-31 的历史为例，我们为了给服务器端代码添加一些功能而创建了特性分支 server，然后提交 C3 和 C4。然后又从 C3 的地方再增加一个client 分支来对客户端代码进行一些相应修改，所以提交了 C8 和 C9。最后，又回到 server 分支提交了 C10。</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-branches41.png" title="Git详解之二：Git分支" target="_blank"><img src="&quot;Git详解之二：Git分支&quot;" alt="Git详解之二：Git分支"></a></p>
<p>图 3-31. 从一个特性分支里再分出一个特性分支的历史。</p>
<p>假设在接下来的一次软件发布中，我们决定先把客户端的修改并到主线中，而暂缓并入服务端软件的修改（因为还需要进一步测试）。这个时候，我们就可以把基于 server 分支而非 master 分支的改变（即 C8 和 C9），跳过 server 直接放到master 分支中重演一遍，但这需要用 git rebase 的 –onto 选项指定新的基底分支master：
1$ git rebase --onto master server client</p>
<p>这好比在说：“取出 client 分支，找出 client 分支和 server 分支的共同祖先之后的变化，然后把它们在master 上重演一遍”。是不是有点复杂？不过它的结果如图 3-32 所示，非常酷（译注：虽然 client 里的 C8, C9 在 C3 之后，但这仅表明时间上的先后，而非在 C3 修改的基础上进一步改动，因为server 和 client 这两个分支对应的代码应该是两套文件，虽然这么说不是很严格，但应理解为在 C3 时间点之后，对另外的文件所做的 C8，C9 修改，放到主干重演。）：</p>
<p><a href="http://cdn2.jobbole.com/2012/08/42.png" title="Git详解之二：Git分支" target="_blank"><img src="&quot;Git详解之二：Git分支&quot;" alt="Git详解之二：Git分支"></a></p>
<p>图 3-32. 将特性分支上的另一个特性分支衍合到其他分支。</p>
<p>现在可以快进 master 分支了（见图 3-33）：
1$ git checkout master $ git merge client</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-branches43.png" title="Git详解之二：Git分支" target="_blank"><img src="&quot;Git详解之二：Git分支&quot;" alt="Git详解之二：Git分支"></a></p>
<p>图 3-33. 快进 master 分支，使之包含 client 分支的变化。</p>
<p>现在我们决定把 server 分支的变化也包含进来。我们可以直接把 server 分支衍合到 master，而不用手工切换到 server分支后再执行衍合操作 — git rebase [主分支] [特性分支] 命令会先取出特性分支server，然后在主分支 master 上重演：
1$ git rebase master server</p>
<p>于是，server 的进度应用到 master 的基础上，如图 3-34 所示：</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-branches44.png" title="Git详解之二：Git分支" target="_blank"><img src="&quot;Git详解之二：Git分支&quot;" alt="Git详解之二：Git分支"></a></p>
<p>图 3-34. 在 master 分支上衍合 server 分支。</p>
<p>然后就可以快进主干分支 master 了：
1$ git checkout master $ git merge server</p>
<p>现在 client 和 server 分支的变化都已经集成到主干分支来了，可以删掉它们了。最终我们的提交历史会变成图 3-35 的样子：</p>
<p>1$ git branch -d client $ git branch -d server</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-branches45.png" title="Git详解之二：Git分支" target="_blank"><img src="&quot;Git详解之二：Git分支&quot;" alt="Git详解之二：Git分支"></a></p>
<p>图 3-35. 最终的提交历史</p>
<p><strong>衍合的风险</strong></p>
<p>呃，奇妙的衍合也并非完美无缺，要用它得遵守一条准则：</p>
<p><strong>一旦分支中的提交对象发布到公共仓库，就千万不要对该分支进行衍合操作。</strong></p>
<p>如果你遵循这条金科玉律，就不会出差错。否则，人民群众会仇恨你，你的朋友和家人也会嘲笑你，唾弃你。</p>
<p>在进行衍合的时候，实际上抛弃了一些现存的提交对象而创造了一些类似但不同的新的提交对象。如果你把原来分支中的提交对象发布出去，并且其他人更新下载后在其基础上开展工作，而稍后你又用git rebase 抛弃这些提交对象，把新的重演后的提交对象发布出去的话，你的合作者就不得不重新合并他们的工作，这样当你再次从他们那里获取内容时，提交历史就会变得一团糟。</p>
<p>下面我们用一个实际例子来说明为什么公开的衍合会带来问题。假设你从一个中央服务器克隆然后在它的基础上搞了一些开发，提交历史类似图 3-36 所示：</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-branches46.png" title="Git详解之二：Git分支" target="_blank"><img src="&quot;Git详解之二：Git分支&quot;" alt="Git详解之二：Git分支"></a></p>
<p>图 3-36. 克隆一个仓库，在其基础上工作一番。</p>
<p>现在，某人在 C1 的基础上做了些改变，并合并他自己的分支得到结果 C6，推送到中央服务器。当你抓取并合并这些数据到你本地的开发分支中后，会得到合并结果 C7，历史提交会变成图 3-37 这样：</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-branches47.png" title="Git详解之二：Git分支" target="_blank"><img src="&quot;Git详解之二：Git分支&quot;" alt="Git详解之二：Git分支"></a></p>
<p>图 3-37. 抓取他人提交，并入自己主干。</p>
<p>接下来，那个推送 C6 上来的人决定用衍合取代之前的合并操作；继而又用 git push –force 覆盖了服务器上的历史，得到 C4’。而之后当你再从服务器上下载最新提交后，会得到：</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-branches48.png" title="Git详解之二：Git分支" target="_blank"><img src="&quot;Git详解之二：Git分支&quot;" alt="Git详解之二：Git分支"></a></p>
<p>图 3-38. 有人推送了衍合后得到的 C4’，丢弃了你作为开发基础的 C4 和 C6。</p>
<p>下载更新后需要合并，但此时衍合产生的提交对象 C4’ 的 SHA-1 校验值和之前 C4 完全不同，所以 Git 会把它们当作新的提交对象处理，而实际上此刻你的提交历史 C7 中早已经包含了 C4 的修改内容，于是合并操作会把 C7 和 C4’ 合并为 C8（见图 3-39）:</p>
<p><a href="http://cdn2.jobbole.com/2012/08/Git-branches49.png" title="Git详解之二：Git分支" target="_blank"><img src="&quot;Git详解之二：Git分支&quot;" alt="Git详解之二：Git分支"></a></p>
<p>图 3-39. 你把相同的内容又合并了一遍，生成一个新的提交 C8。</p>
<p>C8 这一步的合并是迟早会发生的，因为只有这样你才能和其他协作者提交的内容保持同步。而在 C8 之后，你的提交历史里就会同时包含 C4 和 C4’，两者有着不同的 SHA-1 校验值，如果用git log 查看历史，会看到两个提交拥有相同的作者日期与说明，令人费解。而更糟的是，当你把这样的历史推送到服务器后，会再次把这些衍合后的提交引入到中央服务 器，进一步困扰其他人（译注：这个例子中，出问题的责任方是那个发布了 C6 后又用衍合发布 C4’ 的人，其他人会因此反馈双重历史到共享主干，从而混淆大家的视听。）。</p>
<p>如果把衍合当成一种在推送之前清理提交历史的手段，而且仅仅衍合那些尚未公开的提交对象，就没问题。如果衍合那些已经公开的提交对象，并且已经有人基于这些提交对象开展了后续开发工作的话，就会出现叫人沮丧的麻烦。</p>
<p><strong>3.7  小结</strong></p>
<p>读到这里，你应该已经学会了如何创建分支并切换到新分支，在不同分支间转换，合并本地分支，把分支推送到共享服务器上，使用共享分支与他人协作，以及在分享之前进行衍合。</p>
<p><img src="&quot;2 votes, average: 5.00 out of 5&quot;" alt="2 votes, average: 5.00 out of 5"><img src="&quot;2 votes, average: 5.00 out of 5&quot;" alt="2 votes, average: 5.00 out of 5"><img src="&quot;2 votes, average: 5.00 out of 5&quot;" alt="2 votes, average: 5.00 out of 5"><img src="&quot;2 votes, average: 5.00 out of 5&quot;" alt="2 votes, average: 5.00 out of 5"><img src="&quot;2 votes, average: 5.00 out of 5&quot;" alt="2 votes, average: 5.00 out of 5"> (<strong>*2</strong> 个评分，平均: <strong>5.00*</strong>)</p>
<p><img src="&quot;Loading ...&quot;" alt="Loading ..."> Loading ...</p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/git&github/">git&github</a></li></span></span> | <span class="tags">Tagged <a href="/tags/git&github/" class="label label-primary">git&github</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:43"datetime="2014-03-07 09:54:43"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-gitgithub--Git详解之三：Git分支/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-gitgithub--Git详解之三：Git分支" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_总结类--Java生成UUID通用唯一识别码-Programmingonthefly-BlogJ/">Java生成UUID通用唯一识别码 </a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:43.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_总结类--Java生成UUID通用唯一识别码-Programmingonthefly-BlogJ/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="java-uuid-programming-on-the-fly-blogjava">Java生成UUID通用唯一识别码 - Programming on the fly - BlogJava</h1>
<p><a href="http://www.blogjava.net/Werther/" target="_blank">Programming on the fly</a>
Live as if you were to die tomorrow. Learn as if you were to live forever.</p>
<p><a href="http://www.blogjava.net/" target="_blank">BlogJava</a>   <a href="http://www.blogjava.net/Werther/" target="_blank">首页</a>   <a href="http://www.blogjava.net/Werther/admin/EditPosts.aspx?opt=1" target="_blank">新随笔</a> <a href="http://www.blogjava.net/Werther/contact.aspx?id=1" target="_blank">联系</a>   <a href="http://www.blogjava.net/Werther/rss" target="_blank">聚合</a><a href="http://www.blogjava.net/Werther/rss" target="_blank"><img src="" alt=""></a>   <a href="http://www.blogjava.net/Werther/admin/EditPosts.aspx" target="_blank">管理</a></p>
<p>随笔-170  评论-150  文章-11  trackbacks-0
<a href="http://www.blogjava.net/Werther/archive/2009/12/14/305925.html" target="_blank">Java生成UUID通用唯一识别码</a>UUID含义是通用唯一识别码 (Universally Unique Identifier)，这 是一个软件建构的标准，也是被开源软件基金会 (Open Software Foundation, OSF) 的组织在分布式计算环境 (Distributed Computing Environment, DCE) 领域的一部份。UUID 的目的，是让分布式系统中的所有元素，都能有唯一的辨识资讯，而不需要透过中央控制端来做辨识资讯的指定。如此一来，每个人都可以建立不与其它人冲突的 UUID。在这样的情况下，就不需考虑数据库建立时的名称重复问题。目前最广泛应用的 UUID，即是微软的 Microsoft&#39;s Globally Unique Identifiers (GUIDs)，而其他重要的应用，则有 Linux ext2/ext3 档案系统、LUKS 加密分割区、GNOME、KDE、Mac OS X 等等。</p>
<p>以下是具体生成UUID的例子：</p>
<p>view plaincopy to clipboardprint?</p>
<p>package test;</p>
<p>import java.util.UUID;</p>
<p>public class UUIDGenerator {</p>
<p>public UUIDGenerator() {</p>
<p>}</p>
<p>public static String getUUID() {</p>
<p>UUID uuid = UUID.randomUUID();</p>
<p>String str = uuid.toString();</p>
<p>// 去掉&quot;-&quot;符号</p>
<p>String temp = str.substring(0, + str.substring(9, 13) + str.substring(14, 18) + str.substring(19, 23) + str.substring(24);</p>
<p>return str+&quot;,&quot;+temp;</p>
<p>}</p>
<p>//获得指定数量的UUID</p>
<p>public static String[] getUUID(int number) {</p>
<p>if (number &lt; 1) {</p>
<p>return null;</p>
<p>}</p>
<p>String[] ss = new String[number];</p>
<p>for (int i = 0; i &lt; number; i++) {</p>
<p>ss[i] = getUUID();</p>
<p>}</p>
<p>return ss;</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>String[] ss = getUUID(10);</p>
<p>for (int i = 0; i &lt; ss.length; i++) {</p>
<p>System.out.println(&quot;ss[&quot;+i+&quot;]=====&quot;+ss[i]);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>package test;</p>
<p>import java.util.UUID;</p>
<p>public class UUIDGenerator {</p>
<p>public UUIDGenerator() {</p>
<p>}</p>
<p>public static String getUUID() {</p>
<p>UUID uuid = UUID.randomUUID();</p>
<p>String str = uuid.toString();</p>
<p>// 去掉&quot;-&quot;符号</p>
<p>String temp = str.substring(0, + str.substring(9, 13) + str.substring(14, 18) + str.substring(19, 23) + str.substring(24);</p>
<p>return str+&quot;,&quot;+temp;</p>
<p>}
//获得指定数量的UUID</p>
<p>public static String[] getUUID(int number) {</p>
<p>if (number &lt; 1) {</p>
<p>return null;</p>
<p>}</p>
<p>String[] ss = new String[number];</p>
<p>for (int i = 0; i &lt; number; i++) {</p>
<p>ss[i] = getUUID();</p>
<p>}</p>
<p>return ss;</p>
<p>}</p>
<p>public static void main(String[] args) {</p>
<p>String[] ss = getUUID(10);</p>
<p>for (int i = 0; i &lt; ss.length; i++) {</p>
<p>System.out.println(&quot;ss[&quot;+i+&quot;]=====&quot;+ss[i]);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>结果：</p>
<p>view plaincopy to clipboardprint?</p>
<p>ss[0]=====4cdbc040-657a-4847-b266-7e31d9e2c3d9,4cdbc040657a4847b2667e31d9e2c3d9</p>
<p>ss[1]=====72297c88-4260-4c05-9b05-d28bfb11d10b,72297c8842604c059b05d28bfb11d10b</p>
<p>ss[2]=====6d513b6a-69bd-4f79-b94c-d65fc841ea95,6d513b6a69bd4f79b94cd65fc841ea95</p>
<p>ss[3]=====d897a7d3-87a3-4e38-9e0b-71013a6dbe4c,d897a7d387a34e389e0b71013a6dbe4c</p>
<p>ss[4]=====5709f0ba-31e3-42bd-a28d-03485b257c94,5709f0ba31e342bda28d03485b257c94</p>
<p>ss[5]=====530fbb8c-eec9-48d1-ae1b-5f792daf09f3,530fbb8ceec948d1ae1b5f792daf09f3</p>
<p>ss[6]=====4bf07297-65b2-45ca-b905-6fc6f2f39158,4bf0729765b245cab9056fc6f2f39158</p>
<p>ss[7]=====6e5a0e85-b4a0-485f-be54-a758115317e1,6e5a0e85b4a0485fbe54a758115317e1</p>
<p>ss[8]=====245accec-3c12-4642-967f-e476cef558c4,245accec3c124642967fe476cef558c4</p>
<p>ss[9]=====ddd4b5a9-fecd-446c-bd78-63b70bb500a1,ddd4b5a9fecd446cbd7863b70bb500a1</p>
<p>ss[0]=====4cdbc040-657a-4847-b266-7e31d9e2c3d9,4cdbc040657a4847b2667e31d9e2c3d9</p>
<p>ss[1]=====72297c88-4260-4c05-9b05-d28bfb11d10b,72297c8842604c059b05d28bfb11d10b</p>
<p>ss[2]=====6d513b6a-69bd-4f79-b94c-d65fc841ea95,6d513b6a69bd4f79b94cd65fc841ea95</p>
<p>ss[3]=====d897a7d3-87a3-4e38-9e0b-71013a6dbe4c,d897a7d387a34e389e0b71013a6dbe4c</p>
<p>ss[4]=====5709f0ba-31e3-42bd-a28d-03485b257c94,5709f0ba31e342bda28d03485b257c94</p>
<p>ss[5]=====530fbb8c-eec9-48d1-ae1b-5f792daf09f3,530fbb8ceec948d1ae1b5f792daf09f3</p>
<p>ss[6]=====4bf07297-65b2-45ca-b905-6fc6f2f39158,4bf0729765b245cab9056fc6f2f39158</p>
<p>ss[7]=====6e5a0e85-b4a0-485f-be54-a758115317e1,6e5a0e85b4a0485fbe54a758115317e1</p>
<p>ss[8]=====245accec-3c12-4642-967f-e476cef558c4,245accec3c124642967fe476cef558c4</p>
<p>ss[9]=====ddd4b5a9-fecd-446c-bd78-63b70bb500a1,ddd4b5a9fecd446cbd7863b70bb500a1</p>
<p>可以看出，UUID 是指在一台机器上生成的数字，它保证对在同一时空中的所有机器都是唯一的。通常平台会提供生成的API。按照开放软件基金会(OSF)制定的标准计算，用到了以太网卡地址、纳秒级时间、芯片ID码和许多可能的数字</p>
<p>UUID由以下几部分的组合：</p>
<p>（1）当前日期和时间，UUID的第一个部分与时间有关，如果你在生成一个UUID之后，过几秒又生成一个UUID，则第一个部分不同，其余相同。</p>
<p>（2）时钟序列</p>
<p>（3）全局唯一的IEEE机器识别号，如果有网卡，从网卡MAC地址获得，没有网卡以其他方式获得。</p>
<p>UUID的唯一缺陷在于生成的结果串会比较长。关于UUID这个标准使用最普遍的是微软的GUID(Globals Unique Identifiers)。在ColdFusion中可以用CreateUUID()函数很简单的生成UUID，其格式为：xxxxxxxx-xxxx- xxxx-xxxxxxxxxxxxxxxx(8-4-4-16)，其中每个 x 是 0-9 或 a-f 范围内的一个十六进制的数字。而标准的UUID格式为：xxxxxxxx-xxxx-xxxx-xxxxxx-xxxxxxxxxx (8-4-4-4-12)，可以从cflib <a href="http://download.chinaitlab.com/" target="_blank">下载</a>CreateGUID() UDF进行转换。</p>
<p>使用UUID的好处在分布式的软件系统中（比如：DCE/RPC, COM+,CORBA）就能体现出来，它能保证每个节点所生成的标识都不会重复，并且随着WEB服务等整合技术的发展，UUID的优势将更加明显。根据使用的特定机制，UUID不仅需要保证是彼此不相同的，或者最少也是与公元3400年之前其他任何生成的通用惟一标识符有非常大的区别。</p>
<p>通用惟一标识符还可以用来指向大多数的可能的物体。微软和其他一些软件公司都倾向使用全球惟一标识符（GUID），这也是通用惟一标识符的一种类型，可用来指向组建对象模块对象和其他的软件组件。第一个通用惟一标识符是在网罗计算机系统（NCS）中创建，并且随后成为开放软件基金会（OSF）的分布式计算环境（DCE）的组件。
posted on 2009-12-14 17:19 <a href="http://www.blogjava.net/Werther/" target="_blank">Werther</a> 阅读(466) <a href="http://www.blogjava.net/Werther/archive/2009/12/14/305925.html#Post" target="_blank">评论(1)</a>  <a href="http://www.blogjava.net/Werther/admin/EditPosts.aspx?postid=305925" target="_blank">编辑</a>  <a href="http://www.blogjava.net/Werther/AddToFavorite.aspx?id=305925" target="_blank">收藏</a> 所属分类: <a href="http://www.blogjava.net/Werther/category/38034.html" target="_blank">10.Java</a><img src="" alt=""></p>
<p><a href=""></a>
<strong>评论:</strong></p>
<p><a href="http://www.blogjava.net/Werther/archive/2009/12/14/305925.html#305943" title="permalink: re: Java生成UUID通用唯一识别码 " target="_blank">/#</a> <a href=""></a>re: Java生成UUID通用唯一识别码 <a href=""></a>2009-12-14 19:58 | <a href="http://www.blogjava.net/kick191/" target="_blank">天独</a>
在去掉“-”可以用replaceAll这个方法  <a href="http://www.blogjava.net/Werther/archive/2009/12/14/305925.html#post" target="_blank">回复</a>  <a href="http://www.blogjava.net/comment?author=%e5%a4%a9%e7%8b%ac" title="查看该作者发表过的评论" target="_blank">更多评论</a>
<a href=""></a>  <a href=""></a>
<a href="http://news.cnblogs.com/" target="_blank">IT新闻</a>  <a href="http://www.blogjava.net/RequireRegister.aspx" target="_blank">新用户注册</a>  <a href="">刷新评论列表</a>  </p>
<p><a href=""></a> <a href="http://kb.cnblogs.com/zt/chrome/">Chrome OS专题</a>  <a href="http://news.cnblogs.com/" target="_blank">IT新闻</a>  <a href="http://job.cnblogs.com/cate-java_programmer/" target="_blank">Java程序员招聘</a> 标题  请输入标题 姓名  请输入你的姓名 主页 请输入验证码 验证码 /*  <img src="" alt=""> 内容(请不要发表任何与政治相关的内容) 请输入评论内容 Remember Me?   <a href="http://www.blogjava.net/login.aspx?ReturnURL=http://www.blogjava.net/Werther/archive/2009/12/14/305925.html&amp;SourceURL=/Werther/archive/2009/12/14/305925.html" target="_blank">登录</a>       [使用Ctrl+Enter键可以直接提交] <a href="http://kb.cnblogs.com/zt/windows7/" target="_blank">Windows 7专题</a>  IT新闻：
· <a href="http://news.cnblogs.com/n/53055/" target="_blank">微软将推云计算迁移工具</a>
· <a href="http://news.cnblogs.com/n/53054/" target="_blank">广电总局明年加大查处力度 VeryCD有望逃过一劫</a>
· <a href="http://news.cnblogs.com/n/53053/" target="_blank">史玉柱携巨人重返珠海</a>
· <a href="http://news.cnblogs.com/n/53052/" target="_blank">谷歌2009年15件大事 先后2次裁员</a>
· <a href="http://news.cnblogs.com/n/53051/" target="_blank">谷歌和Facebook推出短域名goo.gl和Fb.me</a></p>
<p>博客园首页随笔：
· <a href="http://www.cnblogs.com/gsrdell/archive/2009/12/15/1624437.html" target="_blank">汉诺塔(Hanoi) C/#解法</a>
· <a href="http://www.cnblogs.com/grenet/archive/2009/12/15/1624243.html" target="_blank">计算机中的颜色VI——从色相值到纯色的快速计算</a>
· <a href="http://www.cnblogs.com/jv9/archive/2009/12/15/1622853.html" target="_blank">反编译Silverlight项目</a>
· <a href="http://www.cnblogs.com/cathsfz/archive/2009/12/15/1624229.html" target="_blank">程序之外的事情 (Part 1 - Speech)</a>
· <a href="http://www.cnblogs.com/xiaoyin_net/archive/2009/12/15/1624220.html" target="_blank">Visual Studio 2010 Ultimate敏捷测试驱动开发</a>
招聘信息：
· <a href="http://job.cnblogs.com/offer/3308/" target="_blank">.NET 网站程序开发工程师(龙宽网络信息技术（北京）有限公司)</a>
· <a href="http://job.cnblogs.com/offer/2823/" target="_blank">技术部经理(河南互惠信息咨询有限责任公司)</a>
· <a href="http://job.cnblogs.com/offer/3775/" target="_blank">.NET(C/#)程序员(北京赛优科技有限公司)</a>
· <a href="http://job.cnblogs.com/offer/2429/" target="_blank">.net平台研发工程师(北京易车互联信息技术有限公司)</a>
· <a href="http://job.cnblogs.com/offer/3334/" target="_blank">C++开发工程师(空中网)</a> 在知识库中查看：
<a href="http://kb.cnblogs.com/b/305925/" target="_blank">Java生成UUID通用唯一识别码</a> 网站导航:</p>
<p><a href="http://www.cnblogs.com/" target="_blank">博客园</a>   <a href="http://news.cnblogs.com/" target="_blank">IT新闻</a>   <a href="http://home.cnblogs.com/" target="_blank">个人主页</a>   <a href="http://www.cnweblog.com/" target="_blank">博客生活</a>   <a href="http://www.cnitblog.com/" target="_blank">IT博客网</a>   <a href="http://www.cppblog.com/" target="_blank">C++博客</a>   <a href="http://space.cnblogs.com/" target="_blank">博客园社区</a> <a href="http://www.blogjava.net/Werther/archive/2009/12/14/305925.html?opt=admin" target="_blank">管理</a> 相关文章:</p>
<ul>
<li><a href="http://www.blogjava.net/Werther/archive/2009/12/14/305925.html" target="_blank">Java生成UUID通用唯一识别码</a></li>
<li><a href="http://www.blogjava.net/Werther/archive/2009/11/25/303561.html" target="_blank">instanceof 运算符的用法</a></li>
<li><a href="http://www.blogjava.net/Werther/archive/2009/11/23/303281.html" target="_blank">不同方式遍历Map集合</a></li>
<li><a href="http://www.blogjava.net/Werther/archive/2009/11/19/302891.html" target="_blank">页面显示的处理!</a></li>
<li><a href="http://www.blogjava.net/Werther/archive/2009/11/10/301808.html" target="_blank">logic:present 和 logic:empty标签</a></li>
<li><a href="http://www.blogjava.net/Werther/archive/2009/11/06/301416.html" target="_blank">分治算法</a></li>
<li><a href="http://www.blogjava.net/Werther/archive/2009/10/17/298665.html" target="_blank">Java正则表达式应用总结</a></li>
<li><a href="http://www.blogjava.net/Werther/archive/2009/08/06/290155.html" target="_blank">Post和Get的区别</a></li>
<li><a href="http://www.blogjava.net/Werther/archive/2009/08/05/289995.html" target="_blank">迭代器模式(Iterator pattern)</a></li>
<li><a href="http://www.blogjava.net/Werther/archive/2009/08/04/289872.html" target="_blank">利用Ant和XDoclet自动产生映射文件例子</a>  </li>
</ul>
<h1 id="i-m-reading-">I&#39;m reading...</h1>
<p>Java 60<img src="" alt="">
Head  First SQL<img src="" alt="">
Apache Tomcat5<img src="" alt="">
If you need these books,pls send me emails.
Email:kunpeng.niu@163.com <a href="&quot;Go to the previous month&quot;">&lt;</a> 2009年12月 <a href="&quot;Go to the next month&quot;">&gt;</a> 日 一 二 三 四 五 六 29 30 1 2 3 4 5 6 7 8 9 10 11 12 13 <a href="http://www.blogjava.net/Werther/archive/2009/12/14.html" target="_blank">14</a> 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 1 2 3 4 5 6 7 8 9</p>
<h3 id="-6-">留言簿(6)</h3>
<ul>
<li><a href="http://www.blogjava.net/Werther/Contact.aspx?id=1" target="_blank">给我留言</a></li>
<li><a href="http://www.blogjava.net/Werther/default.aspx?opt=msg" target="_blank">查看公开留言</a></li>
<li><a href="http://www.blogjava.net/Werther/admin/MyMessages.aspx" target="_blank">查看私人留言</a></li>
</ul>
<h1 id="-154-">随笔分类(154)</h1>
<ul>
<li><a href="http://www.blogjava.net/Werther/category/38034.html" target="_blank">10.Java(67)</a><a href="http://www.blogjava.net/Werther/category/38034.html/rss" title="Subscribe to 10.Java(67)" target="_blank"><img src="&quot;Subscribe to 10.Java(67" alt="">&quot;)</a></li>
<li><a href="http://www.blogjava.net/Werther/category/38696.html" target="_blank">11.JavaScript(2)</a><a href="http://www.blogjava.net/Werther/category/38696.html/rss" title="Subscribe to 11.JavaScript(2)" target="_blank"><img src="&quot;Subscribe to 11.JavaScript(2" alt="">&quot;)</a></li>
<li><a href="http://www.blogjava.net/Werther/category/38199.html" target="_blank">12.English(3)</a><a href="http://www.blogjava.net/Werther/category/38199.html/rss" title="Subscribe to 12.English(3)" target="_blank"><img src="&quot;Subscribe to 12.English(3" alt="">&quot;)</a></li>
<li><a href="http://www.blogjava.net/Werther/category/39061.html" target="_blank">13.AJAX(2)</a><a href="http://www.blogjava.net/Werther/category/39061.html/rss" title="Subscribe to 13.AJAX(2)" target="_blank"><img src="&quot;Subscribe to 13.AJAX(2" alt="">&quot;)</a></li>
<li><a href="http://www.blogjava.net/Werther/category/39062.html" target="_blank">14.Oracle(2)</a><a href="http://www.blogjava.net/Werther/category/39062.html/rss" title="Subscribe to 14.Oracle(2)" target="_blank"><img src="&quot;Subscribe to 14.Oracle(2" alt="">&quot;)</a></li>
<li><a href="http://www.blogjava.net/Werther/category/37767.html" target="_blank">15.SQL Server(21)</a><a href="http://www.blogjava.net/Werther/category/37767.html/rss" title="Subscribe to 15.SQL Server(21)" target="_blank"><img src="&quot;Subscribe to 15.SQL Server(21" alt="">&quot;)</a></li>
<li><a href="http://www.blogjava.net/Werther/category/39063.html" target="_blank">16.MySQL(5)</a><a href="http://www.blogjava.net/Werther/category/39063.html/rss" title="Subscribe to 16.MySQL(5)" target="_blank"><img src="&quot;Subscribe to 16.MySQL(5" alt="">&quot;)</a></li>
<li><a href="http://www.blogjava.net/Werther/category/38035.html" target="_blank">17.Windows(4)</a><a href="http://www.blogjava.net/Werther/category/38035.html/rss" title="Subscribe to 17.Windows(4)" target="_blank"><img src="&quot;Subscribe to 17.Windows(4" alt="">&quot;)</a></li>
<li><a href="http://www.blogjava.net/Werther/category/37791.html" target="_blank">18.Other(32)</a><a href="http://www.blogjava.net/Werther/category/37791.html/rss" title="Subscribe to 18.Other(32)" target="_blank"><img src="&quot;Subscribe to 18.Other(32" alt="">&quot;)</a></li>
<li><a href="http://www.blogjava.net/Werther/category/39064.html" target="_blank">19.Eclipse(1)</a><a href="http://www.blogjava.net/Werther/category/39064.html/rss" title="Subscribe to 19.Eclipse(1)" target="_blank"><img src="&quot;Subscribe to 19.Eclipse(1" alt="">&quot;)</a></li>
<li><a href="http://www.blogjava.net/Werther/category/39065.html" target="_blank">20.Struts(5)</a><a href="http://www.blogjava.net/Werther/category/39065.html/rss" title="Subscribe to 20.Struts(5)" target="_blank"><img src="&quot;Subscribe to 20.Struts(5" alt="">&quot;)</a></li>
<li><a href="http://www.blogjava.net/Werther/category/39066.html" target="_blank">21.Hibernate(4)</a><a href="http://www.blogjava.net/Werther/category/39066.html/rss" title="Subscribe to 21.Hibernate(4)" target="_blank"><img src="&quot;Subscribe to 21.Hibernate(4" alt="">&quot;)</a></li>
<li><a href="http://www.blogjava.net/Werther/category/39067.html" target="_blank">22.Spring(4)</a><a href="http://www.blogjava.net/Werther/category/39067.html/rss" title="Subscribe to 22.Spring(4)" target="_blank"><img src="&quot;Subscribe to 22.Spring(4" alt="">&quot;)</a></li>
<li><a href="http://www.blogjava.net/Werther/category/39068.html" target="_blank">23.Tomcat</a><a href="http://www.blogjava.net/Werther/category/39068.html/rss" title="Subscribe to 23.Tomcat" target="_blank"><img src="&quot;Subscribe to 23.Tomcat&quot;" alt=""></a></li>
<li><a href="http://www.blogjava.net/Werther/category/39069.html" target="_blank">24.Weblogic</a><a href="http://www.blogjava.net/Werther/category/39069.html/rss" title="Subscribe to 24.Weblogic" target="_blank"><img src="&quot;Subscribe to 24.Weblogic&quot;" alt=""></a></li>
<li><a href="http://www.blogjava.net/Werther/category/40732.html" target="_blank">25.UML(2)</a><a href="http://www.blogjava.net/Werther/category/40732.html/rss" title="Subscribe to 25.UML(2)" target="_blank"><img src="&quot;Subscribe to 25.UML(2" alt="">&quot;)</a></li>
</ul>
<h1 id="-179-">随笔档案(179)</h1>
<ul>
<li><a href="http://www.blogjava.net/Werther/archive/2009/12.html" target="_blank">2009年12月 (1)</a></li>
<li><a href="http://www.blogjava.net/Werther/archive/2009/11.html" target="_blank">2009年11月 (8)</a></li>
<li><a href="http://www.blogjava.net/Werther/archive/2009/10.html" target="_blank">2009年10月 (4)</a></li>
<li><a href="http://www.blogjava.net/Werther/archive/2009/09.html" target="_blank">2009年9月 (1)</a></li>
<li><a href="http://www.blogjava.net/Werther/archive/2009/08.html" target="_blank">2009年8月 (9)</a></li>
<li><a href="http://www.blogjava.net/Werther/archive/2009/07.html" target="_blank">2009年7月 (14)</a></li>
<li><a href="http://www.blogjava.net/Werther/archive/2009/06.html" target="_blank">2009年6月 (20)</a></li>
<li><a href="http://www.blogjava.net/Werther/archive/2009/05.html" target="_blank">2009年5月 (26)</a></li>
<li><a href="http://www.blogjava.net/Werther/archive/2009/04.html" target="_blank">2009年4月 (41)</a></li>
<li><a href="http://www.blogjava.net/Werther/archive/2009/03.html" target="_blank">2009年3月 (40)</a></li>
<li><a href="http://www.blogjava.net/Werther/archive/2009/02.html" target="_blank">2009年2月 (15)</a></li>
</ul>
<h1 id="-1-">文章档案(1)</h1>
<ul>
<li><a href="http://www.blogjava.net/Werther/archives/2009/11.html" target="_blank">2009年11月 (1)</a></li>
</ul>
<h1 id="-5-">新闻档案(5)</h1>
<ul>
<li><a href="http://www.blogjava.net/Werther/news/2009/09.html" target="_blank">2009年9月 (2)</a></li>
<li><a href="http://www.blogjava.net/Werther/news/2009/06.html" target="_blank">2009年6月 (2)</a></li>
<li><a href="http://www.blogjava.net/Werther/news/2009/04.html" target="_blank">2009年4月 (1)</a></li>
</ul>
<h1 id="-">相册</h1>
<ul>
<li><a href="http://www.blogjava.net/Werther/gallery/39963.html" target="_blank">My Books</a></li>
</ul>
<h1 id="1-java-official-website">1.Java Official Website</h1>
<ul>
<li><a href="http://java.sun.com/" target="_blank">30.Sun Official Website</a></li>
<li><a href="http://cn.sun.com/" target="_blank">31.Sun China</a></li>
<li><a href="http://java.sun.com/javase/6/docs/api/index.html" target="_blank">32.Java SE API 6</a></li>
<li><a href="http://www.eclipse.org/" target="_blank">33.Eclipse Offcial Website</a></li>
<li><a href="http://www.apache.org/" target="_blank">34.Apache</a></li>
</ul>
<h1 id="2-java-study-website">2.Java Study Website</h1>
<ul>
<li><a href="http://www.csdn.com/" target="_blank">40.CSDN</a></li>
<li><a href="http://www.java2s.com/" target="_blank">41.Java2s</a></li>
<li><a href="http://www.chinaitlab.com/" target="_blank">42.ChinaItLab</a></li>
<li><a href="http://www.honoweb.com/java.php" target="_blank">43.Hono Web</a></li>
<li><a href="http://www.matrix.org.cn/main.shtml" target="_blank">44.MATRIX CHINA</a></li>
<li><a href="http://www.java2000.net/" target="_blank">45.JAVA 2000</a></li>
<li><a href="http://www.javadb.com/" target="_blank">46.Java Source Code Examlpe</a></li>
<li><a href="http://www.javaly.cn/" target="_blank">47.Java乐园</a></li>
<li><a href="http://xdoclet.sourceforge.net/olddocs/" target="_blank">48.xdoclet documentation</a></li>
<li><a href="http://www.open-open.com/" target="_blank">49.open-source</a></li>
</ul>
<h1 id="3-java-technic-website">3.Java Technic Website</h1>
<ul>
<li><a href="http://www.j2medev.com/Index.html" target="_blank">50.J2me develop</a></li>
<li><a href="http://www.j2me.com.cn/bbs/" target="_blank">51.J2MEChina</a></li>
<li><a href="http://www.javaeye.com/" target="_blank">52.JavaEye</a></li>
</ul>
<h1 id="4-java-video-website">4.Java Video Website</h1>
<ul>
<li><a href="http://www.verycd.com/topics/93279/" target="_blank">60.尚学堂</a></li>
<li><a href="http://www.verycd.com/topics/249195/" target="_blank">61.浪曦視頻</a></li>
</ul>
<h1 id="5-database-website">5.Database Website</h1>
<ul>
<li><a href="http://www.searchdatabase.com.cn/index.htm" target="_blank">70.TT Database</a></li>
<li><a href="http://www.mysql.com/" target="_blank">71.MySQL</a></li>
<li><a href="http://dev.mysql.com/doc/refman/5.1/zh/index.html" target="_blank">72.MySql Help</a></li>
<li><a href="http://www.mysql-tcr.com/" target="_blank">73.My SQL-TCR</a></li>
</ul>
<h1 id="6-bookshop-website">6.Bookshop Website</h1>
<ul>
<li><a href="http://www.amazon.cn/?source=2009hao123famousdaohang" target="_blank">80.卓越</a></li>
<li><a href="http://www.dangdang.com.cn/" target="_blank">81.當當網</a></li>
<li><a href="http://www.itbook.com.cn/" target="_blank">82.ITBOOK</a></li>
<li><a href="http://www.dearbook.com.cn/" target="_blank">83.第二書店</a></li>
<li><a href="http://www.china-pub.com/" target="_blank">84.中國互動出版網</a></li>
<li><a href="http://www.ithov.com/" target="_blank">85.IT坊</a></li>
</ul>
<h1 id="7-english-website">7.English Website</h1>
<ul>
<li><a href="http://www.kekenet.com/" target="_blank">90.KeKe English</a></li>
<li><a href="http://www.hxen.com/" target="_blank">91.HengXing English</a></li>
<li><a href="http://www.xaqing.cn/Index.html" target="_blank">92.Dream English</a></li>
<li><a href="http://www.wwenglish.com/" target="_blank">93.WangWang English</a></li>
<li><a href="http://www.ebigear.com/" target="_blank">94.Ebigear</a></li>
</ul>
<h1 id="8-friends-link">8.Friends Link</h1>
<ul>
<li><a href="http://www.blogjava.net/fastzch/" target="_blank">100.Robin&#39;s Java World</a></li>
<li><a href="http://www.blogjava.net/Unmi/" target="_blank">101.隔叶黄莺 The Blog of Unmi</a></li>
<li><a href="http://lavasoft.blog.51cto.com/" target="_blank">102.熔岩</a></li>
<li><a href="http://blog.csdn.net/absurd" target="_blank">103.李先靜</a><a href="http://blog.csdn.net/absurd" title="Subscribe to 103.李先靜" target="_blank"><img src="&quot;Subscribe to 103.李先靜&quot;" alt=""></a></li>
<li><a href="http://blog.csdn.net/jobchanceleo" target="_blank">104.Leo</a></li>
<li><a href="http://tonyandjava.s155.eatj.com/" target="_blank">105.闵祖平</a></li>
<li><a href="http://www.cnblogs.com/wayne-ivan/" target="_blank">106.Fish</a></li>
<li><a href="http://www.itstrike.cn/" target="_blank">107..Net世界</a></li>
<li><a href="http://hi.csdn.net/haoel" target="_blank">107.陈皓</a></li>
<li><a href="http://blog.csdn.net/apple_8180" target="_blank">108.VFP 十三豆</a></li>
</ul>
<h1 id="9-other-web">9.Other Web</h1>
<ul>
<li><a href="http://ceping.tianji.com/eval01" target="_blank">120.天际网</a></li>
<li><a href="http://bitscn.com/" target="_blank">121.中國網管聯盟</a></li>
<li><a href="http://www.chachaba.com/" target="_blank">122.查查吧</a></li>
</ul>
<h3 id="-">积分与排名</h3>
<ul>
<li>积分 - 80344</li>
<li>排名 - 172</li>
</ul>
<h3 id="-http-www-blogjava-net-werther-commentsrss-aspx-">最新评论 <a href="http://www.blogjava.net/Werther/CommentsRSS.aspx" target="_blank"><img src="" alt=""></a></h3>
<ul>
<li><a href="http://www.blogjava.net/Werther/archive/2009/12/14/305925.html#305943" target="_blank">1. re: Java生成UUID通用唯一识别码</a></li>
<li>在去掉“-”可以用replaceAll这个方法</li>
<li>--天独</li>
<li><a href="http://www.blogjava.net/Werther/archive/2009/12/03/303281.html#304589" target="_blank">2. re: 不同方式遍历Map集合</a></li>
<li>多學點！</li>
<li>--征服者</li>
<li><a href="http://www.blogjava.net/Werther/archive/2009/12/01/288643.html#304368" target="_blank">3. re: Spring多数据源解决方案 [未登录]</a></li>
<li>如果各个dataSource上的数据库结构不一样的话，这个方法是不能解决问题的</li>
<li>--懒猫</li>
<li><a href="http://www.blogjava.net/Werther/archive/2009/11/19/302891.html#302955" target="_blank">4. re: 页面显示的处理!</a></li>
<li>@月亮的太阳
在开发过程中,对一些数据的处理,尽量在后台处理.每个人有每个人的习惯.</li>
<li>--Werther</li>
<li><a href="http://www.blogjava.net/Werther/archive/2009/11/19/302891.html#302956" target="_blank">5. re: 页面显示的处理!</a></li>
<li>页面只是为了显示数据.</li>
<li>--Werther</li>
</ul>
<h3 id="-">阅读排行榜</h3>
<ul>
<li><a href="http://www.blogjava.net/Werther/archive/2009/06/10/281198.html" target="_blank">1. Java正则表达式的解释说明 (12131)</a></li>
<li><a href="http://www.blogjava.net/Werther/archive/2009/07/21/287656.html" target="_blank">2. 实战体会Java多线程编程精要 (3009)</a></li>
<li><a href="http://www.blogjava.net/Werther/archive/2009/07/27/288643.html" target="_blank">3. Spring多数据源解决方案 (2306)</a></li>
<li><a href="http://www.blogjava.net/Werther/archive/2009/05/05/268905.html" target="_blank">4. 一个最简单的Socket通信例子 (1780)</a></li>
<li><a href="http://www.blogjava.net/Werther/archive/2009/04/06/264145.html" target="_blank">5. 操作java数组的常用工具类(1630)</a></li>
</ul>
<h3 id="-">评论排行榜</h3>
<ul>
<li><a href="http://www.blogjava.net/Werther/archive/2009/06/18/283091.html" target="_blank">1. hibernate的11大优势 (14)</a></li>
<li><a href="http://www.blogjava.net/Werther/archive/2009/05/14/270676.html" target="_blank">2. 区分Action, Service 和 Dao功能 (8)</a></li>
<li><a href="http://www.blogjava.net/Werther/archive/2009/04/21/266819.html" target="_blank">3. 让MyEclipse也具有强大的提示功能 (8)</a></li>
<li><a href="http://www.blogjava.net/Werther/archive/2009/04/20/266584.html" target="_blank">4. Spring事务配置的五种方式 (6)</a></li>
<li><a href="http://www.blogjava.net/Werther/archive/2009/04/28/267821.html" target="_blank">5. JSF与Struts的比较(6)</a>
Powered by: <a href="http://www.cnblogs.com/" target="_blank">博客园</a> 模板提供：<a href="http://blog.hjenglish.com/" target="_blank">沪江博客</a> Copyright ©2009 Werther</li>
</ul>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/Java_总结类/">Java_总结类</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/Java_总结类/" class="label label-success">Java_总结类</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:43"datetime="2014-03-07 09:54:43"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-Java_总结类--Java生成UUID通用唯一识别码-Programmingonthefly-BlogJ/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-Java_总结类--Java生成UUID通用唯一识别码-Programmingonthefly-BlogJ" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_总结类--J2EE总结--Servlet技术/">J2EE总结</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:43.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_总结类--J2EE总结--Servlet技术/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="j2ee-servlet-">J2EE总结--Servlet技术</h1>
<p><a href="http://www.blogjava.net/todd841026/archive/2007/04/08/Servlet.html" target="_blank">J2EE总结--Servlet技术 我的所有随笔属于个人总结，有不足之处请回复指出</a></p>
<p>Servlet技术：</p>
<ol>
<li>什么是servlet？</li>
</ol>
<p>Servlet是一个java类，是一个提供基于协议请求和响应的java类；</p>
<ol>
<li><p>它的生命周期</p>
<ol>
<li><p>启动服务器时就会实例化并加载servlet实例；</p>
</li>
<li><p>进行初始化：自动调用init（ServletConfig servletConfig）方法；</p>
</li>
<li><p>Servlet就绪：调用service（HttpServletRequest request，HttpServletResponse response）方法（其   中     service   就是dopost（）或doget（）方法），这是客户提交时，自动调用的；</p>
</li>
<li><p>Servlet销毁：自动调用调用distory（） ；</p>
</li>
</ol>
<p>注意：在实例化并加载servlet后，步骤二和四只调用一次，而步骤三，是在每次客户端发出请求时都调用；</p>
</li>
<li><p>怎样部署一个servlet？</p>
</li>
</ol>
<p>Servlet类是必须在web.xml中注册才能使用的，例如，我有一个MyServlet类：</p>
<p>必须在web.xml中注册：</p>
<web-app>

<p>//-----------------------Servlet声明----------------------</p>
<pre><code>       &lt;servlet&gt;

             &lt;servlet-name&gt;myServlet&lt;/servlet-name&gt;

             &lt;servlet-class&gt;servletPakage.MyServlet&lt;/servlet-class&gt;

  &lt;/servlet&gt;
</code></pre><p>//------------------------Servlet注册(镜像)---------------</p>
<pre><code>       &lt;servlet-mapping&gt;

             &lt;servlet-name&gt;myServlet&lt;/servlet-name&gt;

             &lt;url-pattern&gt;/myServletURL&lt;/ url-pattern &gt;

  &lt;/servlet-mapping&gt;
</code></pre><p></web-app></p>
<p>这样你在提交时的Url地址就是/myServletURL了；</p>
<ol>
<li>什么是service（HttpServletRequest request，HttpServletResponse response）方法？</li>
</ol>
<p>其中service（HttpServletRequest request，HttpServletResponse response）方法包括两种：</p>
<pre><code>  1.       doget（HttpServletRequest request，HttpServletResponse response）方法：

  这种方法被称为显式提交方法，主要原因是它的得到的参数放在url中，可以被看到，所以称为显示提      交；

  例如：有个表单：

  &lt;form action[=”/myServletURL?name=todd](http://www.blogjava.net/myServletURL?name=todd)” method=”get”&gt;

  &lt;/form&gt;

  这种方法其request获得的参数就是你看到的name=todd；

  例如：String s=request.getParameter(“name”);

        其结果s=”todd”;

  2.       dopost（HttpServletRequest request，HttpServletResponse response）方法：

     这种方法被称为隐式提交方法，它的参数不会在url里得到，而是在请求数据体得到参数；

     例如：有个表单：

        &lt;form action=”/myServletURL” method=”post”&gt;

                 &lt;input type=”text” name=”name” value=”todd”&gt;

     &lt;/form&gt;

  这种方法其request获得的参数就是表单体的name=todd；

        例如：String s=request.getParameter(“name”);

        其结果s=”todd”;
</code></pre><ol>
<li><p>什么是ServletContext?</p>
<p>ServletContext是一个接口，是WebApplication的视图，它的作用域时Application，它能访问Application中的初始化参数和属性，它不局限域一个Servlet，它属于整个Application；</p>
</li>
</ol>
<p>ServletContext的初始化参数：</p>
<p>在web.xml中：</p>
<web-app>

<pre><code>&lt;context-param&gt;
</code></pre><p><param-name>myBlog</param-name></p>
<p><param-value>www.blogjava.net/todd841026</param-value></p>
<p></context-param></p>
<p></web-app></p>
<p> 这样在application中任意一个Servlet中可以得到这个参数，</p>
<p>例如：ServletContext sc = getServletContext ();</p>
<pre><code>      String s = sc.getInitParameter(“myBlog”);
</code></pre><p>那么结果s就是”www.blogjava.net/todd841026”</p>
<ol>
<li>什么是ServletConfig？</li>
</ol>
<p>是单独的Servlet初始化配置；</p>
<p>例如：在web.xml中</p>
<web-app>

<pre><code>        &lt;servlet&gt;

             &lt;servlet-name&gt;myServlet&lt;/servlet-name&gt;

             &lt;servlet-class&gt;servletPakage.MyServlet&lt;/servlet-class&gt;

  &lt;/servlet&gt;

  &lt;init-param&gt;

        &lt;param-name&gt;cache&lt;/param-name&gt;

        &lt;param-value&gt;off&lt;/param-value&gt;
</code></pre><p></init-param></p>
<p></web-app></p>
<p>在这个Servlet中：ServletConfig sc = getServletConfig();</p>
<pre><code>                        String s = sc.getInitParameter(“cache”);
</code></pre><p>那么结果s就是”off”;</p>
<ol>
<li>Servlet怎样处理多线程</li>
</ol>
<p>在默认的情况下，单个Servlet实例是可以处理多个并发请求的，所以要考虑到多线程的共享同一对象的问题，例如：</p>
<p>//做个Servlet中产生了多少个object对象一个变量的例子</p>
<p>Private int count = 0 ;</p>
<p>Public void dopost(HttpServletRequest request,HttpServletResponse response){</p>
<pre><code>       Object object = new Object() ;

       count++ ;

       System.out.println(“count = ” + count) ;
</code></pre><p>}</p>
<p>当有5个用户提交数据时，因为Servlet是处理多线程的，所以可能出现，第四个用户的程序已经执行了count++，而第五个用户刚执行完Object object = new Object() ，就会出现数据不一致性，因为当前有5个object对象，但是count却是4；</p>
<p>解决方案一：</p>
<p>Private boolean flag = false ；</p>
<p>Private int count = 0 ;</p>
<p>Public void dopost(HttpServletRequest request,HttpServletResponse response){</p>
<pre><code>       synchronized(flag){

                Object object = new Object() ;

                count++ ;
</code></pre><p>}                </p>
<pre><code>       System.out.println(“count = ” + count) ;
</code></pre><p>}</p>
<p>用同步程序块解决多线程的问题，这样在同一时刻就只能有一个访问该程序块了；</p>
<p>解决方案二：</p>
<p>Private int count = 0 ;</p>
<p>Public void dopost(HttpServletRequest request,HttpServletResponse response)</p>
<p>Implements SingleThreadModel{</p>
<pre><code>       Object object = new Object() ;

       count++ ;

       System.out.println(“count = ” + count) ;
</code></pre><p>}</p>
<p>实现SingleThreadModel接口，可以解决多线程问题；</p>
<ol>
<li>什么是servlet过滤器？</li>
</ol>
<p>也是一个java类，只是它实现了Filter这个接口；</p>
<ol>
<li>servlet过滤器的生命周期；</li>
</ol>
<p>初始化：自动调用init(FilterConfig config)方法</p>
<p>执行：自动调用doFilter()方法；</p>
<p>销毁：自动调用destory()方法；</p>
<ol>
<li><p>servlet过滤器有什么用途？</p>
<p>个人认为目前自己用到的Servlet过滤器的主要用途：是安全性检查</p>
<p>   当然过滤器在Servlet之前也可以修改请求，要是在Servlet之后，也可以修改响应； </p>
</li>
<li><p>servlet过滤器怎样部署？</p>
</li>
</ol>
<p>在web.xml中：</p>
<web-app>

<pre><code>&lt;filter&gt;

  &lt;filter-name&gt;myFilter&lt;/filter-name&gt;

  &lt;filter-class&gt;filterPage.MyFilter&lt;/filter-class&gt;
</code></pre><p></filter></p>
<filter-mapping>

<pre><code>  &lt;filter-name&gt;myFilter&lt;/filter-name&gt;

  &lt;url-pattern&gt;/Todd//*&lt;/url-pattern&gt;
</code></pre><p></filter-mapping></p>
<p></web-app></p>
<p>这样就是说要访问WEB-INF下的Todd包下的jsp或Servlet的话，就必须要先通过myFilter这个类；</p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/Java_总结类/">Java_总结类</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/Java_总结类/" class="label label-success">Java_总结类</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:43"datetime="2014-03-07 09:54:43"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-Java_总结类--J2EE总结--Servlet技术/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-Java_总结类--J2EE总结--Servlet技术" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_总结类--J2EE开发工程师应该掌握的知识点/">J2EE 开发工程师应该掌握的知识点</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:43.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_总结类--J2EE开发工程师应该掌握的知识点/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="j2ee-">J2EE 开发工程师应该掌握的知识点</h1>
<p>J2EE 开发工程师应该掌握的知识点</p>
<p>1.Servlet
包括session的治理
采用Servlet Context访问resource
jsp技术
web层的模式：Service-to-Worker, Dispatcher View, and Business Delegate patterns
web应用的MVC Pattern
Handling Errors in Web Applications
配置web Application的安全
web application的并发访问
2.事务处理
3.安全策略
4.需求分析
基本的架构设计方法
创建Use Case Diagram
UML图
5.基本的设计模式把握
Composite pattern.
Strategy pattern.
Observer pattern.
Abstract Factory pattern.
6.ejb
打包和部署EJB
CMP BMP Message-Driven Beans
CMP BMP 的事务实现
异常处理
定时服务
采用stateless bean实现webserive
EJB架构的最佳实践
7.J2EE
J2EE的安全架构实现
Fundamental Architectural Concepts和 five primary concerns of architecture
J2EE中Inside the Tier ，Tier-to-Tier Communication的优化
8.Java编程语言
语法
控制语句
数据类型
异常
线程
I/O
Networking</p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/Java_总结类/">Java_总结类</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/Java_总结类/" class="label label-success">Java_总结类</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:43"datetime="2014-03-07 09:54:43"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-Java_总结类--J2EE开发工程师应该掌握的知识点/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-Java_总结类--J2EE开发工程师应该掌握的知识点" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>





<ul id="pagination" class="pagination pagination-lg">
  <li><a class="extend prev" href="/page/40/">&laquo;</a></li><li><a class="page-number" href="/">1</a></li><li><a class="page-number" href="/page/2/">2</a></li><li><span class="space">&hellip;</span></li><li><a class="page-number" href="/page/38/">38</a></li><li><a class="page-number" href="/page/39/">39</a></li><li><a class="page-number" href="/page/40/">40</a></li><li class="active"><li><span class="page-number current">41</span></li><li><a class="page-number" href="/page/42/">42</a></li><li><a class="page-number" href="/page/43/">43</a></li><li><a class="page-number" href="/page/44/">44</a></li><li><span class="space">&hellip;</span></li></li><li><a class="page-number" href="/page/164/">164</a></li><li><a class="page-number" href="/page/165/">165</a></li><li><a class="extend next" href="/page/42/">&raquo;</a></li>
  <div class="clearfix"></div>
</ul></div><!--wapper-->
       </div><!-- ID main-col END -->
       <aside id="sidebar" class="alignright col-sx-6 col-sm-4 col-md-3 col-lg-3">
<div id="widget_search" class="widget panel panel-primary">
    <form action="//google.com/search" method="get" accept-charset="utf-8">
  <div class="input-group">
    <input class="form-control" id="searchbox" type="search" name="q" results="0" placeholder="search">
    <span class="input-group-btn">
      <button class="btn btn-default" type="submit">Go!</button>
    </span>
    <input type="hidden" name="q" value="site:itsolife.com">
  </div>
</form>
</div>

<div id="widget_category" class="widget panel panel-primary">
  <div class="panel-heading">category</div>  <div data-src='category' class='ajax_widgets'>正在加载...</div>
</div>

<div id="widget_recent_posts" class="widget panel panel-primary">
  <div class="panel-heading">recent posts</div>  <div data-src='recent_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_tagcloud" class="widget panel panel-primary">
  <div class="panel-heading">tagcloud</div>  <div data-src='tagcloud' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_latest_update_posts" class="widget panel panel-primary">
  <div class="panel-heading">最近更新</div>  <div data-src='latest_update_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_recent_comments" class="widget panel panel-primary">
  <div class="panel-heading">recent comments</div>  

<div class="list-group-item ds-recent-comments" data-num-items="6" data-show-avatars="1" data-show-time="1" data-show-title="1" data-show-admin="1" data-excerpt-length="50"></div>



</div>

</aside>
       <div class="clearfix"></div>
     </div><!-- row END -->
  </div>
  <footer id="footer" class="container">
  <div class="panel panel-info">
  <section id='footer_widget'></section>  <div class="panel-footer">
  <div id="site-info">
    <span class='author'>
  
  &copy; 2014 RobinChia
  
    &nbsp;&nbsp;</span>
  
  <span id='analytics-51la'></span><span id='analytics-google'>
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-48559895-1']);
  _gaq.push(['_trackPageview']);
  _js2load.push({src:('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'});
</script></span><span id='analytics-cnzz'>
<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_5774006'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s17.cnzz.com/stat.php%3Fid%3D5774006%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>
</span><span id='analytics-baidu'>
<script>
var _hmt = _hmt || [];
_js2load.push({src:"//hm.baidu.com/hm.js?1442f50724afc42380b51f097c43082c"});
</script>
</span>  </div>
  <div id="copyright">Blog powered by <a href='http://zespia.tw/hexo/'><strong>hexo</strong></a> Theme <strong><a href='https://github.com/chenall/hexo-theme-chenall'>chenall</a></strong>(Some change in it)<span class="pull-right"> 更新时间: <em>2014-03-25 18:15:42</em></span></div>
</div>
<div class="clearfix"></div>


  </div>
  </footer>
  
        <script src="http://cdn.bootcss.com/jquery/1.10.2/jquery.min.js"></script>        
        <script src="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/js/bootstrap.min.js"></script>        
                
        <script src="http://cdn.bootcss.com/prettify/r298/prettify.min.js"></script>    <script type="text/javascript">
   var lang=["bsh", "c", "cc", "cpp", "cs", "csh", "cyc", "cv", "htm", "html",
    "java", "js", "m", "mxml", "perl", "pl", "pm", "py", "rb", "sh",
    "xhtml", "xml", "xsl"];
   var pretty_base='';
   $('script').each(function(){
	var c = $(this).attr('src');
	if (!c)
	    return;
	if (c.match(/(\/)?prettify(\.min)?\.js/i))
	{
	    var index = c.lastIndexOf('/');
	    if (index != -1)
		pretty_base = c.substr(0,index + 1);
	    return false;
	}
   })
   $('pre code').each(function(){
	var c = $(this).attr('class')
	if (!c)
	    return;
	c = c.match(/\s?(lang\-\w+)/i);
	if (c && lang.indexOf(c[1]) == -1)
	{
	    lang.push(c[1]);
	    $.getScript(pretty_base + c[1] + '.min.js');
	}
   })

    $(window).load(function(){
       $("pre").addClass("prettyprint");
       prettyPrint();
    })
</script>    
            <script type="text/javascript">
var duoshuoQuery = {short_name:"robinchia"};
_js2load.push({src:'http://static.duoshuo.com/embed.js',charset:'UTF-8'});
</script>
    
            <!--wumii_relatedItems-->
    
        <script src="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js"></script>    <script type="text/javascript">
(function($){
  $('.entry').each(function(i){
    $(this).find('img').each(function(){
      var alt = this.alt;

      if (alt){
        $(this).before('<span class="caption">' + alt + '</span>');
      }

      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox" rel="fancybox' + i + '" />');
    });
  });

  $('.fancybox').fancybox();
})(jQuery);
</script>    
        <script src="http://cdn.bootcss.com/mathjax/2.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>    <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>
    
<script type="text/javascript">
$('.ajax_widgets').each(function(){var src=$(this).attr('data-src');if(src)$(this).load('/widgets/'+src+'.html');});
$.each(_js2load,function(index,obj){loadjs(obj.src,obj.charset)});
</script>

<div id="scroll2top">
<img src="/scroll2top/arrow.png"/>
</div>
<script src="/scroll2top/scroll2top.min.js"></script>
<div id="winterland">
  <canvas></canvas>
</div>
<script src="/js/winterland.min.js"></script>

  </body>
</html>
