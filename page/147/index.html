
<!DOCTYPE HTML>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>The 147 Page | It so life</title>
<meta name="author" content="RobinChia">

<meta name="description" content="It so life">


<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<meta property="og:site_name" content="It so life"/>

<!--[if IE]><style>.testIE.IE{display:inline;}</style><![endif]-->
<!--[if lte IE 7]><link rel="stylesheet" href="/css/ie7.css" type="text/css"><![endif]-->
<!--[if (lt IE 9)&(gt IE 7)]><style>.testIE.IE8{display:inline;}</style><![endif]-->
<!--[if gt IE 8]><style>.testIE.IE9{display:inline;}</style><![endif]-->

<link href="/favicon.png" rel="icon">
<link rel="alternate" href="/atom.xml" title="It so life Feed" type="application/atom+xml">

<link rel="stylesheet" href="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/css/bootstrap.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/font-awesome/4.0.3/css/font-awesome.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/prettify/r298/prettify.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" type="text/css">
<link rel="stylesheet" href="/css/style.css" type="text/css">
<!--[if lt IE 9]>
   <style>article,aside,dialog,footer,header,section,footer,nav,figure,menu{display:block}</style>
   <script src="http://cdn.staticfile.org/html5shiv/r29/html5.min.js"></script>
   <script src="http://cdn.staticfile.org/respond.js/1.4.2/respond.min.js"></script>
<link href="http://cdn.staticfile.org/respond.js/1.4.2/respond-proxy.html" id="respond-proxy" rel="respond-proxy" />
<link href="/js/respond.proxy.gif" id="respond-redirect" rel="respond-redirect" />
<script src="/js/respond.proxy.js"></script>
   <script src="http://cdn.bootcss.com/selectivizr/1.0.2/selectivizr-min.js"></script>
<![endif]-->
<script type="text/javascript">
function loadjs(c,d){var a=document.createElement("script");a.async=!0;a.type="text/javascript";a.src=c;a.charset=d||"gbk";(document.getElementsByTagName("HEAD")[0]||document.getElementsByTagName("BODY")[0]).appendChild(a)};
var _protocol = (("https:" == document.location.protocol) ? " https://" : " http://");
var _js2load = [];
</script>

</head>
<body>
      <header id="header" class="container"><nav id="main-nav" class="navbar navbar-default navbar-fixed-top " role="navigation">
  <div class="container">
    <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
      <span class="sr-only">Toggle navigation</span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="/">It so life</a>
    </div>
    <div  class="collapse navbar-collapse">
      <ul  class="nav navbar-nav">
  
        <li><a href="/" title="Home">Home</a></li>      
        <li><a href="/about/" title="About">About</a></li>      
        <li><a href="/archives/" title="Archives">Archives</a></li>      
      <li class='dropdown'>
        <a class='dropdown-toggle' data-toggle='dropdown' href='#'>website<b class='caret'></b></a>
        <ul class='dropdown-menu pure-menu-selected'>
    
          <li><a href="//groups.google.com/forum/#!forum/pongba" title="TopLanguage">TopLanguage</a></li>    
          <li><a href="//itpub.net/" title="ITPub">ITPub</a></li>    
          <li><a href="//blog.jobbole.com/" title="Bole">Bole</a></li>    
          <li><a href="//nosql-database.org/" title="nosql">nosql</a></li>    
          <li><a href="//gitimmersion.googol.im/" title="Git">Git</a></li>    
        </ul>
      </li>
    
      </ul>
      <ul class="nav navbar-nav navbar-right">
      
        <li><a href="/atom.xml">RSS</a></li>
      
      
        <li><a href="https://twitter.com/robinchia">twitter</a></li>
      
      
      
      
        <li><a href="https://github.com/robinchia">github</a></li>
      
      </ul>
    </div>
  </div>
</nav>
<div class="clearfix"></div>
</header>
  <div id='content' class="container">
     <div class="page-header-wrapper">
      <!--[if lt IE 9]><div class="alert alert-warning alert-dismissable"><button type="button" class="close" data-dismiss="alert" aria-hidden="true">&times;</button><strong>提示:</strong>您的浏览器版本太低了,建议升级到 <strong><a href="http://windows.microsoft.com/zh-cn/internet-explorer/download-ie" title="IE9">IE9</a></strong> 以上,本站使用<a href="https://www.google.com/intl/zh-CN/chrome/">Chrome浏览器</a>可以获得最好的显示效果.</div><![endif]-->
      <div class="page-header"><h1 align="center"><big>It so life</big> </h1>
        <h5 align="center"><big>love as life</big></h5>
      </div>
     </div>
     <div class="row">
       <div id="main-col" class="alignleft col-sx-12 col-sm-8 col-md-9 col-lg-9">
      <section id='header_widget'></section>
          <div id="wrapper"><article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-eclipse--myeclipse9X-101加密和破解机制/">myeclipse9.X</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:29.000Z"> <a href="/2014/02/02/2014-02-02-eclipse--myeclipse9X-101加密和破解机制/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="myeclipse9-x-10-1-">myeclipse9.X-10.1加密和破解机制</h1>
<p>不想了解破解机制急于破解的直接跳到最后 ‘ 具体操作 ’</p>
<p>myeclipse 9.1 终于出来了，有人尝鲜了，但是发现很受伤，很受伤是因为完整性验证部分，呵呵。</p>
<p><img src="" alt="图片"></p>
<p>myeclipse 9.0 完整性校验有参数可以控制.</p>
<p>-Dgenuitec.honorDevMode=true</p>
<p>-Dosgi.dev=true</p>
<p>但是9.1取消了这个选项。上面的命令就不好用了。反编译源代码即可看差异，确实删掉了开发模式的代码。</p>
<p>要想跳过校验，有两种选择。</p>
<p>看堆栈（使用 jconsole，Java内置），可以看到</p>
<p>...</p>
<p>com.genuitec.eclipse.core.SignatureVerifier.verifyJarSignatures(SignatureVerifier.java:172)</p>
<p>com.genuitec.eclipse.core.CommonCore.startup(CommonCore.java:39)</p>
<p>...</p>
<p>1.短路 com.genuitec.eclipse.core.CommonCore中的startup()方法</p>
<p>2.短路 com.genuitec.eclipse.core.SignatureVerifier中的verifyJarSignatures()方法</p>
<p>仔细看反编译的源代码即可发现 短路CommonCore中的startup()方法比较麻烦，因为需要别的类包中的库，找起来比较麻烦。</p>
<p>所以我选择短路SignatureVerifier中的verifyJarSignatures()方法</p>
<p>下面的类即可，什么也不需要，这个方法什么也不做，直接替换就行，用压缩软件打开，替换相应的类即可</p>
<p>注意：最好编译该类的时候使用JDK1.5。高版本也可以，移植的时候可能要考虑JDK的问题。因为1.5运行不了1.6的类文件</p>
<p>相应的包是 Common/plug/com.genuitec.eclipse.core.common_9.0.0.me2011/*.jar，包具体视情况而定.</p>
<p>Java代码 </p>
<ol>
<li>package com.genuitec.eclipse.core;  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* replace com.genuitec.eclipse.core.SignatureVerifier With this class<br> </li>
<li>/<em> in jar com.genuitec.eclipse.core.common_9.0.0.me2011/</em>.jar<br> </li>
<li>/* shorcut method verifyJarSignatures()<br> </li>
<li>/*  </li>
<li>/* @author macbookpro </li>
<li>/*/  </li>
<li>public class SignatureVerifier {  </li>
<li>public void verifyJarSignatures() {  </li>
<li>// do nothing ...  </li>
<li>}  </li>
<li>}  </li>
</ol>
<p>类可以自己编译，也可以用已上传的替换即可。</p>
<p>关于，进一步的用户licence和activecode破解，那个用9.0的破解方法即可，这部分都是一样的。
一个基于Java环境的破解程序。</p>
<p>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/*
有人用了以上的方法，没有破解成功，之后还有校验完整性错误的弹出框，这个是因为myeclipse的检测机制我之前没有弄清楚。</p>
<p>myeclipse检测完整性分为两个步骤</p>
<ol>
<li><p>myeclipse 启动校验</p>
</li>
<li><p>myeclipse 组件校验。</p>
</li>
</ol>
<p>上面写的只是myeclipse的启动的短路，其实还有组件的检测。</p>
<p>组件校验</p>
<p>当myeclipse启动成功，会首先加载eclipse的核心，然后挂载myeclipse组件。</p>
<p>当挂载myeclipse组件的时候，就会有完整性校验了。这个就是组件校验，9.0不知道是否存在这种校验。</p>
<p>找到那个组件校验的类包有两种方法（目前能想到的比较实际的）</p>
<ol>
<li><p>查看堆栈。（jconsole和jstack）</p>
<p>在弹出校验错误的窗口时，看堆栈，找出那个类进行的校验，然后找到该包，短路掉里面的校验逻辑。（找包的部分比较麻烦）</p>
<p>然后再打开myeclipse，再找出哪个类进行的校验………. 直到没有弹出框为止，证明都找到了。</p>
</li>
<li><p>jar文件遍历</p>
<p>编写程序，找出jar文件里的校验类。</p>
<p>程序很好写，就是找出plugin目录和子目录下的jar文件里的类名是否包括SignatureVerifier类即可。</p>
</li>
</ol>
<p>下面的类包和里面的类就是我通过上面两种方法共同找到的类。</p>
<p>Common/plugins/com.genuitec.eclipse.core.common_9.0.0.me201105301859.jar                      [com/genuitec/eclipse/core/SignatureVerifier.class]</p>
<p>Common/plugins/com.genuitec.eclipse.easie.core_9.0.0.me201106010603/easiecore.jar           [com/genuitec/eclipse/easie/core/SignatureVerifier.class]</p>
<p>Common/plugins/com.genuitec.eclipse.j2eedt.core_9.0.0.me201106292137/j2eedtcore.jar         [com/genuitec/eclipse/j2eedt/core/SignatureVerifier.class]</p>
<p>Common/plugins/com.genuitec.myeclipse.product_9.0.0.me201106290046/myeclipse-product.jar      [com/genuitec/myeclipse/product/SignatureVerifier.class]</p>
<p>我们需要把上面的类包中的SignatureVerifier短路掉即可，用上面SignatureVerifier类重新编译即可，注意包名。</p>
<p>替换的类我编写好了一份，要是自己编译麻烦的话，那就直接用附件里面的。</p>
<p>这几个类包短路掉之后，我用windows测试过没有问题。没有校验的弹出框了，基本可以解决校验问题。</p>
<p>替换类的方法我感觉还是比较麻烦，谁让我喜欢尝鲜了，尝鲜的朋友都知道，那就是必须的折腾。</p>
<p>myeclipse 9.1 破解说明</p>
<p>myeclipse 9.X 系列需要两个步骤：</p>
<p>第一步是破解Licence（所有系列都有）</p>
<p>第二步破解激活码activecode，（9.X系列特有）</p>
<p>Licence的算号，网上都有，这个基本没有什么问题，不需要借助其他的库，直接算法就可以。</p>
<p>关键是激活码的计算，这个比较麻烦，网上有关于9.0的破解程序，但是是exe文件的。</p>
<p>本人使用macbook ,要想破解起来必须装虚拟机或者bootcamp，所以对我来说比较麻烦，还有一个问题就是windows破解程序在计算activecode的时候需要systemid，但是替换成macbook的systemid之后再算的时候可能有问题。（可能有些人没这个问题）</p>
<p>所以自己看了myeclipse的验证逻辑，自己写了个破解。完全基于Java,任何系统都可以使用。</p>
<p>下面讲解一下myeclipse 9.X系列的注册验证问题</p>
<ol>
<li>systemid的计算</li>
</ol>
<p>systemid计算需要借助于其他类库</p>
<p>jniwrapper 关于这个可以到官方网站下载相应操作系统的类库。</p>
<p>systemid组成</p>
<p>“1f553430D3107d17834”</p>
<p>TypeField:1</p>
<p>Field:    15(f)</p>
<p>HostInfo:55 </p>
<p>SystemInfo:3430D31</p>
<p>MacAddress:07d1</p>
<p>HDSerial:7834</p>
<p>licenceCode由Licence算号算出。</p>
<p>Licence到期时间，可以由licenceCode反向转换得出，也可以自定义，只要在反向转换的时间之后就可以。</p>
<p>RSA加密解密</p>
<p>大家都知道myeclipse中有个publicKey.bytes文件，这个是公匙。</p>
<p>密匙（privateKey.bytes）在myeclipse公司手中，我们是拿不到的。</p>
<p>所以我们需要自己生成一个公匙和密匙，然后替换掉myeclipse中的公匙，这个就是9.0的破解过程，大家都清楚吧。</p>
<p>通过密匙加密，然后用公匙解出。这个也是RSA加密解密的机制。</p>
<p>激活码 是由上述三个字符串累加而成，然后通过RSA加密而成。</p>
<p>激活码注册验证需要通过三层验证</p>
<p>第一层</p>
<p>你输入的激活码解密出activecode（通过publicKey.bytes解出）</p>
<p>第二层</p>
<p>activecode分离出systemId,licenceCode,licenceDate</p>
<p>第三层</p>
<p>比对systemId,licenceCode,licenceDate三个参数，看是否匹配系统中的参数，即可完成验证。</p>
<p>9.0 的注册机在windows下很好用，但是在其他系统上却有些问题。手动填写systemid计算后的破解码有些问题。</p>
<p>有人使用MacOSX，所以必须借助于虚拟机或者其他的机器上来破解。在网上也找了很多，有一种方法就是使用9.0的注册机，替换掉里面生成systemid字符串（自己操作系统上的systemid，在myeclipse激活窗口能看到），然后运行那个exe文件，就可以破解。这个有些麻烦，但是也能解决问题。</p>
<p>有些人可能就是自己一台机器，借助不了其他的环境，那破解起来就会比较麻烦。</p>
<p> 9.1的破解</p>
<p>我们这里，使用java，可以跨平台使用，启动文件为jar文件，如果装了JDK双击即可，要是在命令行就用java -jar /*.jar（当然要配置好java环境变量，我相信在这里费劲注册激活myeclipse的人java环境变量配置都是入门知识的了吧）</p>
<p><strong>具体操作</strong></p>
<p><img src="" alt="图片"></p>
<p>第一步：Usrcode中输入任意用户名</p>
<p>第二步：点击systemid一次，这时候如果出现一行错误</p>
<p>Cannot find JNIWrapper native library (libjniwrap.so) in java.library.path:~~</p>
<p>不需要理会，再点击一次即可出现systemid。</p>
<p>第三步： 点菜单Tools-&gt;RebuildKey</p>
<p>第四步：点击active按钮.会在显示区域生成</p>
<p>LICENSE_KEY</p>
<p>ACTIVATION_CODE</p>
<p>ACTIVATION_KEY</p>
<p>这时候你并不需要打开myeclipse到激活页面输入。切记。next</p>
<p>第五步：打开菜单Tools-&gt;ReplaceJarFile，弹出文件选择对话框，到myeclipse的安装目录common文件夹下选择plugins文件夹</p>
<pre><code>点击打开，程序会卡住，不要担心，正在替换文件呢！
</code></pre><p>一会之后，会输出信息，文件已被替换</p>
<p>第六步：点菜单Tools-&gt;SaveProperites</p>
<p>OK 。打开你的myeclipse已经不需要再输入激活码什么的了。</p>
<p>仅供研究myeclipse9.X~~10.1加密和破解机制学习使用</p>
<p>我放在MSN网盘上共享，下载地址，  不需注册，刚添加了一下10.1破解的文件和源码
<a href="https://skydrive.live.com/redir.aspx?cid=3a056e7a1777dab0&amp;resid=3A056E7A1777DAB0!105" target="_blank"><a href="https://skydrive.live.com/redir.aspx?cid=3a056e7a1777dab0&amp;resid=3A056E7A1777DAB0!105">https://skydrive.live.com/redir.aspx?cid=3a056e7a1777dab0&amp;resid=3A056E7A1777DAB0!105</a></a></p>
<p>来源： <a href="[http://b1.cnc.qzone.qq.com/cgi-bin/blognew/blog_output_data?uin=894528596&amp;blogid=1317127373&amp;styledm=cnc.qzonestyle.gtimg.cn&amp;imgdm=cnc.qzs.qq.com&amp;bdm=b.cnc.qzone.qq.com&amp;mode=2&amp;numperpage=15&amp;blogseed=0.7196430717594922&amp;property=GoRE×tamp=1372298123&amp;dprefix=cnc.&amp;g_tk=5381&amp;ref=qzone&amp;entertime=1372298137865](http://b1.cnc.qzone.qq.com/cgi-bin/blognew/blog_output_data?uin=894528596&amp;blogid=1317127373&amp;styledm=cnc.qzonestyle.gtimg.cn&amp;imgdm=cnc.qzs.qq.com&amp;bdm=b.cnc.qzone.qq.com&amp;mode=2&amp;numperpage=15&amp;blogseed=0.7196430717594922&amp;property=GoRE&amp;timestamp=1372298123&amp;dprefix=cnc.&amp;g_tk=5381&amp;ref=qzone&amp;entertime=1372298137865)">[http://b1.cnc.qzone.qq.com/cgi-bin/blognew/blog_output_data?uin=894528596&amp;blogid=1317127373&amp;styledm=cnc.qzonestyle.gtimg.cn&amp;imgdm=cnc.qzs.qq.com&amp;bdm=b.cnc.qzone.qq.com&amp;mode=2&amp;numperpage=15&amp;blogseed=0.7196430717594922&amp;property=GoRE×tamp=1372298123&amp;dprefix=cnc.&amp;g_tk=5381&amp;ref=qzone&amp;entertime=1372298137865](http://b1.cnc.qzone.qq.com/cgi-bin/blognew/blog_output_data?uin=894528596&amp;blogid=1317127373&amp;styledm=cnc.qzonestyle.gtimg.cn&amp;imgdm=cnc.qzs.qq.com&amp;bdm=b.cnc.qzone.qq.com&amp;mode=2&amp;numperpage=15&amp;blogseed=0.7196430717594922&amp;property=GoRE&amp;timestamp=1372298123&amp;dprefix=cnc.&amp;g_tk=5381&amp;ref=qzone&amp;entertime=1372298137865)</a></p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/eclipse/">eclipse</a></li></span></span> | <span class="tags">Tagged <a href="/tags/eclipse/" class="label label-primary">eclipse</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:29"datetime="2014-03-07 09:54:29"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-eclipse--myeclipse9X-101加密和破解机制/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-eclipse--myeclipse9X-101加密和破解机制" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-eclipse-插件--EclipseProfilerPlugin/">Eclipse Profiler Plugin</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:29.000Z"> <a href="/2014/02/02/2014-02-02-eclipse-插件--EclipseProfilerPlugin/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="eclipse-profiler-plugin">Eclipse Profiler Plugin</h1>
<h1 id="eclipse-profiler-plugin">Eclipse Profiler Plugin</h1>
<p>This is a plugin for the Eclipse platform which allows java code profiling. <a href="http://sourceforge.net/projects/eclipsecolorer" target="_blank">Project</a></p>
<h2 id="license">License</h2>
<p>CPL.</p>
<h2 id="general-note">General note</h2>
<p>1.) if you run the remote profiler, the filter settings in the eclipse environment are not taken into account. Instead you must provide the filter settings in the start command of your application server. You do this by adding an environment variable <strong>PROFILER_PACKAGE_FILTER to the startup command of your aplication, see below. 2.) Setting up the profiler package filters (in general) You must define the environment variable </strong>PROFILER<em>PACKAGE<em>FILTER as shown below in the examples for tomcat, jboss, weblogic and resin. General important Note: The environment variable contains following parts: the application starting class (<strong>A</strong>) inclusion filters (<strong>P</strong>) exclusion filters (__M</em></em>) You must provide exactly one starting class, but you can have multiple inclusion and exclusion filters. The parts MUST be separated by the OS specific path.separator, i.e. &quot;:&quot; for unix or &quot;;&quot; for WINDOWS platforms) example package filter setting for WINDOWS: -D<strong>PROFILER_PACKAGE_FILTER=</strong>A<strong>org.apache.catalina.startup.Bootstrap;</strong>M<strong>sun.;</strong>P<strong>my.company.classes. example package filter setting for UNIX/LINUX: -D</strong>PROFILER_PACKAGE_FILTER=<strong>A</strong>org.apache.catalina.startup.Bootstrap:<strong>M</strong>sun.:<strong>P</strong>my.company.classes. In the examples below we provide the WINDOWS style. Please take care to use the LINUX/UNIX style if that aplies to you.</p>
<h2 id="win32-installation">Win32 installation</h2>
<p>Copy ProfilerDLL.dll from root plugin folder into bin folder of your JRE installation. You can skip this step, plugin will ask you and copy DLL into your JRE\BIN when you will start profiling local application inside of Eclipse first time. It will also check, that you have in JRE\BIN same DLL as in plugin directory.</p>
<h2 id="linux-installation">Linux installation</h2>
<p>Profiler has native part compiled with gcc 3.2, but if you have old gcc or libraries you can build native part yourself. Extract files from native\profiler_linux.tgz and look at script &quot;m&quot;. This is example of compilation script. Change it as needed for you OS.
See also profile_cpu/profile_heap for examples of start line for cpu and heap profiling and r_cpu/r_heap as example how to use them.</p>
<h2 id="usage">Usage</h2>
<p>Profiler plugin creates additional kind of launch configuration in Run menu. Profiler tab allows the user to define packages which shouldn&#39;t be instrumented, thus, all time usage will be referred to calling methods.
You can specify refresh rate, i.e. how often plugin will read statistics from prolifing JVM.
You can also set method, how to get time of enter in method and leave. There are two methods: fast, but usefull only if you have one active thread, which tries to use all CPU; or slow, which use JVMPI function GetCurrentThreadCpuTime() and allows detect how much of CPU was used by thread. However with this method profiled program runs about 3 times slower than with fast method.
<img src="" alt="">
<strong>Fig. 1. Launch configuration.</strong></p>
<p>Profiler supports inclusive (grren) and exlusive (red) filters. You can noy only specify what packages should be excluded from instrumentation, but also what packages should be included. Usefull, if you want to profile only your own classes. You can move filters up and down using buttons or drag and drop.
<img src="" alt="">
<strong>Fig. 1.1. Drag filters.</strong></p>
<p>Plugin allows remote profiling with &quot;Remote Profiler&quot; launch configuration. Notice, that remote profiling is supported only in &quot;run&quot; mode, i.e. when you create launch configuration using &quot;Run|Run...&quot; menu item.
You need to start remote application with special switches like: java -XrunProfilerDLL -Xbootclasspath/a:jakarta-regexp.jar;profiler<em>trace.jar;commons-lang.jar -D<strong>PROFILER_PACKAGE_FILTER=</strong>M<strong>sun.;</strong>M<strong>com.sun. -D</strong>PROFILER<em>USE<em>PACKAGE<em>FILTER=1 Here <strong>M</strong> prefix used for exclusive filter, __P</em></em> can be used for inclusive filter. And you should use __A</em></em> for class with method &quot;main&quot;.
<img src="" alt="">
<strong>Fig. 2. Remote launch configuration.</strong></p>
<h2 id="tomcat-cpu-profiling">Tomcat CPU profiling</h2>
<p>Profiler was tested with jakarta-tomcat-4.1.12. Add after lines in catalina.bat:
set <em>EXECJAVA=%<em>RUNJAVA%
set MAINCLASS=org.apache.catalina.startup.Bootstrap
set ACTION=start
set SECURITY_POLICY_FILE=
set DEBUG_OPTS=
set JPDA=
following line:
set JAVA_OPTS=-XrunProfilerDLL:1 -Xbootclasspath/a:jakarta-regexp.jar;profiler_trace.jar;commons-lang.jar -D<strong>PROFILER_PACKAGE_FILTER=</strong>A</em></em>%MAINCLASS%;<strong>M</strong>sun.;<strong>M</strong>com.sun.;<strong>M</strong>java.;<strong>M</strong>javax.;<strong>M</strong>org.apache. -D__PROFILER_TIMING_METHOD=1
Then copy jar&#39;s: commons-lang.jar jakarta-regexp.jar profiler_trace.jar to bin directory of tomcat. Now you can start tomcat using startup.bat and it will gather statistics for you. Next step is configuring Eclipse. You should create remote launch configuration and set host address as needed. This is all. Launch it, plugin will connect to your Tomcat and show you some statistics.</p>
<h2 id="tomcat-heap-profiling">Tomcat heap profiling</h2>
<p>Profiling heap is almost same as CPU profiling, but you should use following line:
set JAVA<em>OPTS=-XrunProfilerDLL:3,10,0 -D<strong>PROFILER_PROFILE_HEAP=1 -Xbootclasspath/a:jakarta-regexp.jar;profiler_trace.jar;commons-lang.jar -D</strong>PROFILER<em>PACKAGE<em>FILTER=<em>_A</em></em>%MAINCLASS%;__M</em></em> -D__PROFILER_TIMING_METHOD=1</p>
<h2 id="jboss-profiling">JBoss profiling</h2>
<p>Profiler was tested with jboss-3.0.6_tomcat-4.1.18. Add following line in your bin/run.bat (directly after echo off):
set JAVA_OPTS=-XrunProfilerDLL:1 -Xbootclasspath/a:jakarta-regexp.jar;profiler_trace.jar;commons-lang.jar -D<strong>PROFILER_PACKAGE_FILTER=</strong>A<strong>org.jboss.Main;</strong>M<strong>sun.;</strong>M<strong>com.sun.;</strong>M<strong>java.;</strong>M<strong>javax. -D</strong>PROFILER_TIMING_METHOD=1
Then copy jar&#39;s: commons-lang.jar jakarta-regexp.jar profiler_trace.jar to bin directory of JBoss. Now you can start JBoss using run.bat and it will gather statistics for you. Next step is configuring Eclipse. You should create remote launch configuration and set host address as needed. This is all. Launch it, plugin will connect to your JBoss and show you some statistics.</p>
<h2 id="weblogic-profiling">WebLogic profiling</h2>
<p>Profiler was tested with WebLogic 8.1, installed in &quot;c:/bea&quot;. WebLogic has its own JRE&#39;s, so you will need to copy ProfilerDLL.dll manually to C:\bea\jdk141_02\jre\bin. For profiling examples, change file C:\bea\weblogic81\samples\domains\examples\startExamplesServer.cmd, line where JAVA_OPTIONS is defined:
set JAVA_OPTIONS=-XrunProfilerDLL:1 -Xbootclasspath/a:jakarta-regexp.jar;profiler_trace.jar;commons-lang.jar -D<strong>PROFILER_PACKAGE_FILTER=</strong>A<strong>weblogic.Server;</strong>M<strong>sun.;</strong>M<strong>com.sun.;</strong>M<strong>java.;</strong>M<strong>javax.;</strong>M<strong>weblogic. -D</strong>PROFILER_TIMING_METHOD=1
Then copy jar&#39;s: commons-lang.jar jakarta-regexp.jar profiler_trace.jar to &quot;C:\bea\weblogic81\samples\domains\examples&quot;. Now you can start WebLogic examplex using startExamplesServer.cmd, or shortcut in Windows menu, and it will gather statistics for you. Next step is configuring Eclipse. You should create remote launch configuration and set host address as needed. This is all. Launch it, plugin will connect to your WebLogic and show you some statistics.</p>
<h2 id="resin-profiling">Resin profiling</h2>
<p>Profiler was tested with Resin-ee 2.1.10. Create batch file with following content in &quot;bin&quot;:
httpd.exe -J-XrunProfilerDLL:1 -Xbootclasspath/a:c:/prof/jakarta-regexp.jar;c:/prof/profiler_trace.jar;c:/prof/commons-lang.jar -D<strong>PROFILER_PACKAGE_FILTER=</strong>A<strong>com.caucho.server.http.HttpServer;</strong>M<strong>sun.;</strong>M<strong>com.sun.;</strong>M<strong>java.;</strong>M<strong>javax. -D</strong>PROFILER_TIMING_METHOD=1
Then create directory &quot;prof&quot; in disc &quot;C&quot; and copy jar&#39;s: commons-lang.jar jakarta-regexp.jar profiler_trace.jar. Now you can start your batch file and it will gather statistics for you. Next step is configuring Eclipse. You should create remote launch configuration and set host address as needed. This is all. Launch it, plugin will connect to your Resin and show you some statistics.</p>
<h2 id="options">Options</h2>
<p>Profiler supports several options via -DXXX.
Options Description <strong>PROFILER_PACKAGE_FILTER Contains list of packages to include or exclude.
Here </strong>P<strong> - inclusive pattern, </strong>M<strong> - exclusive pattern.
And </strong>A<strong> - application start class.
Examples:
Include only ru./<em> and de./</em> packages: </strong>P<strong>ru.;</strong>P<strong>de.
Exclude system packages: </strong>A<strong>org.jboss.Main;</strong>M<strong>sun.;</strong>M<strong>com.sun.;</strong>M<strong>java.;</strong>M<strong>javax.
If at least one inclusive pattern used, only classes accepted by inclusive patterns will be instrumented. </strong>PROFILER_TIMING_METHOD Specifies timing method - how to measure elapsed time.
0 - fast, System.currentTimeMillis(), good for application without sleeps and waits.
1 - precise, thread aware, slow, good for multithreaded applications.
2 - sampling profiling, very fast, good for long runned processes. <strong>PROFILER_PROFILE_HEAP 1, if HEAP profiling should be used. </strong>PROFILER_AUTO_START 0 - don&#39;t start automatically.
1 (default) - start automatically. <strong>PROFILER_START_ON_METHOD Start method name. When applications tries to enter in this method profiling starts (see </strong>PROFILER_AUTO_START, it should be 0).
Example: -D<strong>PROFILER_START_ON_METHOD=ru.nlmk.train.Main.mainLoop </strong>PROFILER_PAUSE_ON_METHOD 1, if you need pause profiling when <strong>PROFILER_START_ON_METHOD leaved. </strong>PROFILER_INSTRUMENT_SYSTEM_CLASSES 1, if you need instrument additional system classes, like java.lang.String, etc. Expensive! __PROFILER_WAIT_FRONTEND_CONNECT 1, if you need to wait, until frontend (plugin) will connect. (0 by default).</p>
<h2 id="cpu-profiling">CPU profiling</h2>
<p>Profiler supports CPU profiling and basic function for heap profiling. The profiler collects invocation count and direct time statistics for every method. Direct time is the amount of time used by selected method for execute. Also a total time value displayed in calling tree for selected thread. The total time means a time used by selected method and by all the methods it had called.</p>
<p>Only instrumentation profiling method is supported because of its precise. The overhead expenses reflects at speed decreasing app. 5 times to normal.</p>
<h2 id="how-it-works">How it works</h2>
<p>The profiler subscribes for JVPMI event JVMPI_EVENT_CLASS_LOAD_HOOK which called during every class loading. The profiler modifies loading byte-code by adding profiler&#39;s method call &quot;enter&quot; in the beginning of the every method of loading class and at the end of it - &quot;leave&quot;. &quot;Enter&quot; profiler&#39;s method notes the time of entering to profiling method. &quot;Leave&quot; makes method leaving timestamp and calculates a difference between enter and leave timestamps. This difference means total time for this method call. Direct time calculates as total time of this method minus total time of the all methods called by it. The profiles makes some time corrections for the time spent by profiler.</p>
<p>The profiler implemented as an Eclipse perspective with following views: Threads, Packages, Classes, Methods, Thread methods, Thread call tree, Heap.</p>
<p><strong>Threads.</strong>
Shows a list with all threads (alive or dead) in the current process. Here you can pause/resume refreshing of statistics in views, pause/resume all threads in profilied program, clear all statistics or run GC in profiled JVM.
<img src="" alt="">
<strong>Fig. 3. Threads View.</strong></p>
<p><strong>Call graph.</strong>
Profiler uses Draw2D for displaying call graph of thread. All methods shown in several columns, column depends on level, on which this method was called. Inside one column methods sorted by direct time used. Each node in graph has color from red to dark gray, depending on direct time. Methods with maximum time use have red color, and methods, which almost don&#39;t use time, have grey color. Each method has hint with detailed information. You can double click on method to open it in editor.
Lines between method present call from source method to target. Lines from one level to directly next have black color, to next - blue, inside one level - red, and from backward calls - green. Width of line depeneds on how much of time use in this call.
<img src="" alt="">
<strong>Fig. 3.1. Call graph.</strong>
You can also see hit for call. <img src="" alt="">
<strong>Fig. 3.2. Call hint.</strong>
As you can see, full graph looks fairly complex, but you can select part of it. Press mouse on some method and select then button &quot;Show callers&quot;, &quot;Show calles&quot; or &quot;Show caller and callees&quot;. You can see something like this: <img src="" alt="">
<strong>Fig. 3.3. Callers.</strong>
<img src="" alt="">
<strong>Fig. 3.4. Callees.</strong>
<img src="" alt="">
<strong>Fig. 3.5. Callers and callees.</strong>
You can double click on call line for opening editor with source method with highlighting places, where it calls target method. <img src="" alt="">
<strong>Fig. 3.6. Show calls.</strong></p>
<p><strong>Packages.</strong>
Shows a list with all methods with class hierarchy from package. This allows to determine packages which used the most of CPU time. In this view (and in Classes and Methods views also) the user can see in gray color the methods with unmodified parameters since last update. The user can hide such kind of methods by applying appropriate filters.
Here:
Name - name of package/class/method
Inv. - invocation count
% - percent of all invocations
Time - direct time used
% - percent of total time
Time/Inv. - average time used for one invocation
Total time - total time used directly by method and by all methods it calls
Inst. time - time used for instrumentation of class
<img src="" alt="">
<strong>Fig. 4. Packages View.</strong></p>
<p>You can add package or class to filter by pressing right mose button on element in table and selecting menu item. Filter can be added to launch configuration filter (will be used in next profiling, if you will active it) or to view filters (will be activated right now).
<img src="" alt="">
<strong>Fig. 4.1. Add filter.</strong></p>
<p><strong>Classes.</strong>
Shows a list of all class methods with method hierarchy from class. This allows to determine classes with the most CPU time usage.
<img src="" alt="">
<strong>Fig. 5. Classes View.</strong></p>
<p><strong>Filters.</strong>
Allows to define which kind of methods can be shown.
<img src="" alt="">
<strong>Fig. 6. Filters.</strong>
You can save configured name patterns (inclusive or exalusive) with some name and description, then you will able to select them in check list box. <img src="" alt="">
<strong>Fig. 6.1. New filter.</strong>
Later you can change this user defined filter. <img src="" alt="">
<strong>Fig. 6.2. Edit filter.</strong></p>
<p><strong>Methods.</strong>
Shows the statistics for all methods of the current process.
<img src="" alt="">
<strong>Fig. 7. All Methods View.</strong></p>
<p><strong>Thread methods.</strong>
Shows methods statictics for thread selected in Threads View.
<img src="" alt="">
<strong>Fig. 8. Thread Methods View.</strong></p>
<p><strong>Thread tree.</strong>
Shows a methods invocation tree for thread selected in Threads View. Here red square used for highlighted methods (from thread methods context menu) and green dot used for all other methods.
<img src="" alt="">
<strong>Fig. 9. Thread Tree View.</strong></p>
<p><strong>Inverted thread tree.</strong>
Shows a methods invocation tree for thread selected in Threads View starting from leaves. This allows you fastly detect, that some leaf method uses much of total time and see, what methods it is called.
<img src="" alt="">
<strong>Fig. 9.1. Inverted thread Tree View.</strong></p>
<p><strong>Heap.</strong>
Shows heap usage graph: total (green), used (blue) and free (yellow) heap.
<img src="" alt="Heap View.">
<strong>Fig. 10. Heap View.</strong></p>
<p>Here is an overall view of the profiler perspective. You can see a method HashMap.put opened in source code editor with highlighted lines of code which has the maximum hit count (size of annotation depends on hit count). You can open source code editor by choosing menu item &quot;Open method in editor&quot; in context menu.
<img src="" alt="">
<strong>Fig. 11. Perspective.</strong></p>
<p><a href="http://sourceforge.net/" target="_blank"><img src="" alt="SourceForge Logo"></a></p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/eclipse/">eclipse</a></li></span><span class="breadcrumb"><li><a href="/categories/eclipse/">eclipse</a></li><li><a href="/categories/eclipse/插件/">插件</a></li></span></span> | <span class="tags">Tagged <a href="/tags/eclipse/" class="label label-primary">eclipse</a><a href="/tags/插件/" class="label label-success">插件</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:29"datetime="2014-03-07 09:54:29"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-eclipse-插件--EclipseProfilerPlugin/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-eclipse-插件--EclipseProfilerPlugin" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-框架汇总-Spring--Spring-设计模式-aop-ioc/">Spring</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:29.000Z"> <a href="/2014/02/02/2014-02-02-框架汇总-Spring--Spring-设计模式-aop-ioc/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="spring-aop-ioc">Spring-设计模式-aop-ioc</h1>
<p><a href="http://www.goldendoc.org/" target="_blank">黄金档</a></p>
<p>路漫漫其修远兮，吾将上下而求索……</p>
<ul>
<li><a href="http://www.goldendoc.org/" title="首页" target="_blank">首页</a></li>
<li><a href="http://www.goldendoc.org/hire/" target="_blank">招聘</a></li>
<li><a href="http://www.goldendoc.org/about/" target="_blank">关于</a></li>
</ul>
<h1 id="spring">Spring</h1>
<h2 id="-spring-http-www-goldendoc-org-2010-12-spring_design_pattern-spring-"><a href="http://www.goldendoc.org/2010/12/spring_design_pattern/" title="永久链接：Spring中的设计模式" target="_blank">Spring中的设计模式</a></h2>
<p><a href="http://www.goldendoc.org/2010/12/spring_design_pattern/#comments" target="_blank">2</a></p>
<p>2年前</p>
<p>由<a href="http://www.goldendoc.org/author/jackey/" title="jackey发表的文章 " target="_blank">jackey</a>发布 在<a href="http://www.goldendoc.org/category/spring/" title="Spring (4主题)" target="_blank">Spring</a>
应该说设计模式是我们在写代码时候的一种被承认的较好的模式。好的设计模式就像是给代码造了一个很好的骨架，在这个骨架里，你可以知道心在哪里，肺在哪里，因为大多数人都认识这样的骨架，就有了很好的传播性。这是从易读和易传播来感知设计模式的好处。当然设计模式本身更重要的是设计原则的一种实现，比如开闭原则，依赖倒置原则，这些是在代码的修改和扩展上说事。说到底就是人类和代码发生关系的四种场合：阅读，修改，增加，删除。让每一种场合都比较舒服的话，就需要用设计模式。</p>
<p>下面来简单列举Spring中的设计模式：
<strong>1. 简单工厂</strong>
又叫做静态工厂方法（StaticFactory Method）模式，但不属于23种GOF设计模式之一。
简单工厂模式的实质是由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类。
Spring中的BeanFactory就是简单工厂模式的体现，根据传入一个唯一的标识来获得Bean对象，但是否是在传入参数后创建还是传入参数前创建这个要根据具体情况来定。
<strong>2. 工厂方法（Factory Method）</strong>
定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method使一个类的实例化延迟到其子类。
Spring中的FactoryBean就是典型的工厂方法模式。如下图：
<a href="http://pic.yupoo.com/goldendoc/AFbYXQy8/cgvMF.jpg" target="_blank"><img src="" alt=""></a></p>
<p><strong>3. 单例（Singleton）</strong>
保证一个类仅有一个实例，并提供一个访问它的全局访问点。
Spring中的单例模式完成了后半句话，即提供了全局的访问点BeanFactory。但没有从构造器级别去控制单例，这是因为Spring管理的是是任意的Java对象。
<strong>4. 适配器（Adapter）</strong>
将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。
Spring中在对于AOP的处理中有Adapter模式的例子，见如下图：
<a href="http://pic.yupoo.com/goldendoc/AFbYXG9r/yaKsE.jpg" target="_blank"><img src="" alt=""></a>
由于Advisor链需要的是MethodInterceptor对象，所以每一个Advisor中的Advice都要适配成对应的MethodInterceptor对象。
<strong>5.包装器（Decorator）</strong>
动态地给一个对象添加一些额外的职责。就增加功能来说，Decorator模式相比生成子类更为灵活。 <em>**</em></p>
<p><a href="http://pic.yupoo.com/goldendoc/AFbYXVzM/iEPst.jpg" target="_blank"><img src="" alt=""></a>
Spring中用到的包装器模式在类名上有两种表现：一种是类名中含有Wrapper，另一种是类名中含有Decorator。基本上都是动态地给一个对象添加一些额外的职责。
<strong>6. 代理（Proxy）</strong>
为其他对象提供一种代理以控制对这个对象的访问。
从结构上来看和Decorator模式类似，但Proxy是控制，更像是一种对功能的限制，而Decorator是增加职责。
<img src="" alt="">
Spring的Proxy模式在aop中有体现，比如JdkDynamicAopProxy和Cglib2AopProxy。
<strong>7.观察者（Observer）</strong>
定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。
<a href="http://pic.yupoo.com/goldendoc/AFbYY79B/QRttX.jpg" target="_blank"><img src="" alt=""></a>
Spring中Observer模式常用的地方是listener的实现。如ApplicationListener。
<strong>8. 策略（Strategy）</strong>
定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。
Spring中在实例化对象的时候用到Strategy模式，见如下图：
<a href="http://pic.yupoo.com/goldendoc/AFbYYjl6/c2IJb.jpg" target="_blank"><img src="" alt=""></a>
在SimpleInstantiationStrategy中有如下代码说明了策略模式的使用情况：
<a href="http://pic.yupoo.com/goldendoc/AFbYYecL/xJ2n1.jpg" target="_blank"><img src="" alt=""></a>
<strong>9.模板方法（Template Method）</strong>
定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。Template Method使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。
<img src="" alt="">
Template Method模式一般是需要继承的。这里想要探讨另一种对Template Method的理解。Spring中的JdbcTemplate，在用这个类时并不想去继承这个类，因为这个类的方法太多，但是我们还是想用到JdbcTemplate已有的稳定的、公用的数据库连接，那么我们怎么办呢？我们可以把变化的东西抽出来作为一个参数传入JdbcTemplate的方法中。但是变化的东西是一段代码，而且这段代码会用到JdbcTemplate中的变量。怎么办？那我们就用回调对象吧。在这个回调对象中定义一个操纵JdbcTemplate中变量的方法，我们去实现这个方法，就把变化的东西集中到这里了。然后我们再传入这个回调对象到JdbcTemplate，从而完成了调用。这可能是Template Method不需要继承的另一种实现方式吧。</p>
<p>以下是一个具体的例子：
JdbcTemplate中的execute方法：</p>
<p><a href="http://pic.yupoo.com/goldendoc/AFbYXJ1i/Gqxeo.jpg" target="_blank"><img src="" alt=""></a>
JdbcTemplate执行execute方法：
<a href="http://pic.yupoo.com/goldendoc/AFbYYoCZ/coCXA.jpg" target="_blank"><img src="" alt=""></a></p>
<p><a href="http://www.goldendoc.org/tag/%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f/" title="设计模式 (1主题)" target="_blank">设计模式</a></p>
<h2 id="-spring-aop-http-www-goldendoc-org-2010-12-spring_aop-spring-aop-"><a href="http://www.goldendoc.org/2010/12/spring_aop/" title="永久链接：Spring AOP介绍及源码分析" target="_blank">Spring AOP介绍及源码分析</a></h2>
<p><a href="http://www.goldendoc.org/2010/12/spring_aop/#comments" target="_blank">3</a></p>
<p>2年前</p>
<p>由<a href="http://www.goldendoc.org/author/lwei/" title="lwei发表的文章 " target="_blank">lwei</a>发布 在<a href="http://www.goldendoc.org/category/spring/" title="Spring (4主题)" target="_blank">Spring</a>
软件开发经历了从汇编语言到高级语言和从过程化编程到面向对象编程；前者是为了提高开发效率，而后者则使用了归纳法，把具有共性的东西进行归类并使之模块化，达到便于维护和扩展的目的；如果说面向对象编程可以对业务需求进行很好的分解使之模块化；那么面向切面编程AOP（Aspect-Oriented Programming）则可以对系统需求进行很好的模软件开发经历了从汇编语言到高级语言和从过程化编程到面向对象编程；前者是为了提高开发效率，而后者则使用了归纳法，把具有共性的东西进行归类并使之模块化，达到便于维护和扩展的目的；如果说面向对象编程可以对业务需求进行很好的分解使之模块化；那么面向切面编程AOP（Aspect-Oriented Programming）则可以对系统需求进行很好的模块组织，简化系统需求和实现之间的对比关系，是对OOP思想的一种补充；块组织，简化系统需求和实现之间的对比关系，是对OOP思想的一种补充；</p>
<p><strong>一、AOP介绍
</strong></p>
<p>举个例子来说明一下吧！现在系统中有很多的业务方法，如上传产品信息、修改产品信息、发布公司库等；现在需要对这些方法的执行做性能监控，看每个业务方法的执行时间；在不改变原业务代码的基础上，也许我们会这么做：</p>
<p><strong>Offer接口：
</strong></p>
<p><img src="" alt=""></p>
<p><strong>Offer实现：
</strong></p>
<p><img src="" alt=""></p>
<p><strong>Offer代理：
</strong></p>
<p><img src="" alt=""></p>
<p>我们要通过下面的方式来使用：</p>
<p><img src="" alt=""></p>
<p>上面的例子的输出为：</p>
<p><img src="" alt=""></p>
<p>上面的例子中，OfferProxy实现了IOffer，而所有的业务实现均委托给其成员offer；可以想像，这应该就是最简单的AOP的实现了；但这种方式会存在一个问题：如果有非常多的这种业务对象需要性能监控，我们就需要写同样多的XyzProxy来满足需求，这也是非常巨大的工作量。</p>
<p>上面说到了代理，我们先看看代理模式吧！</p>
<p><strong>二、代理模式及实现
</strong></p>
<p>下面是代理模式的类图：</p>
<p><img src="" alt=""></p>
<p>代理模式类图</p>
<p>代理模式中，存在一个称为ProxyObject的代理对象和RealObject的真实对象，它们都实现了相同的接口；在调用的地方持有ProxyObject的实例，当调用request()方法时，ProxyObject可以在执行RealObject.request()前后做一些特定的业务，甚至不调用RealObject.request()方法。</p>
<p>目前实现代理模式的方式有两种：基于JDK的动态代理和基于CGLIB字节码的代理。</p>
<p><strong>2.1 JDK动态代理
</strong></p>
<p>JDK动态代理，顾名思义，是基于JDK的反射(reflect)机制；在JDK中，提供了InvocationHandler这个接口，下面是JDK里面的注释：</p>
<p>InvocationHandler is the interface implemented by the invocation handler of a proxy instance.</p>
<p>Each proxy instance has an associated invocation handler. When a method is invoked on a proxy instance, the method invocation is encoded and dispatched to the invoke method of its invocation handler.</p>
<p>简单翻译，意思是说：该接口由被代理对象的handler所实现；当调用代理对象的方法时，该方法调用将被编码，然后交给代理对象的invoke方法去执行；</p>
<p>是不是有一种豁然开朗的感觉呢？没错，答案就在你心中。</p>
<p>这样，上面的代码就可以改成下面的实现方式：</p>
<p><img src="" alt=""><em>**</em></p>
<p><strong>调用端：
</strong></p>
<p><img src="" alt=""></p>
<p>通过这种方式，你不需要为针对每一个业务写一个代理对象，就可以很轻松地完成你的需求；但也许你已经注意到了，JDK的动态代理，在创建代理对象(上面红色代码部分)时，被代理的对象需要实现接口(即面向接口编程)；</p>
<p>这就是JDK的动态代理，简单吧！下面看看CGLIB代理方式。</p>
<p><strong>2.2 CGLIB代理
</strong></p>
<p>如果目标对象没有实现任何接口，那怎么办呢？不用担心，你可以用CGLIB来实现代理：</p>
<p><img src="" alt=""></p>
<p><strong>调用端：
</strong></p>
<p><img src="" alt=""></p>
<p>使用CGLIB创建的代理对象，其实就是继承了要代理的目标类，然后对目标类中所有非final方法进行覆盖，但在覆盖方法时会添加一些拦截代码(上面CglibProxyFactory类中的intercept方法)。</p>
<p>下面看看Spring中是如何实现AOP的。</p>
<p><strong>三、Spring AOP的实现
</strong></p>
<p><strong>3.1 Spring AOP的几个概念
</strong></p>
<p>Spring AOP中的几个基本概念，每次学习AOP都被这几个概念折腾的很不爽，我们在这里再把这几个概念描述一遍，力争把这几个概念搞清，在每次review这块内容的时候可以很快上手。</p>
<ol>
<li>切面(Aspect)：切面就是一个关注点的模块化，如事务管理、日志管理、权限管理等；</li>
<li>连接点(Joinpoint)：程序执行时的某个特定的点，在Spring中就是一个方法的执行；</li>
<li>通知(Advice)：通知就是在切面的某个连接点上执行的操作，也就是事务管理、日志管理等；</li>
<li>切入点(Pointcut)：切入点就是描述某一类选定的连接点，也就是指定某一类要织入通知的方法；</li>
<li>目标对象(Target)：就是被AOP动态代理的目标对象；</li>
</ol>
<p>用一张图来形象地表达AOP的概念及其关系如下：</p>
<p><img src="" alt=""></p>
<p><strong>3.2 Spring AOP中切入点、通知、切面的实现
</strong></p>
<p>理解了上面的几个概念后，我们分别来看看Spring AOP是如何实现这些概念的；</p>
<ol>
<li>切入点(Pointcut)：它定义了哪些连接点需要被织入横切逻辑；在Java中，连接点对应哪些类(接口)的方法。因此，我们都能猜到，所谓的切入点，就是定义了匹配哪些娄的哪些方法的一些规则，可以是静态的基于类(方法)名的值匹配，也可以是基于正则表达式的模式匹配。来看看Spring AOP Pointcut相关的类图：</li>
</ol>
<p><img src="" alt=""></p>
<p>在Pointcut接口的定义中，也许你已经想到了，ClassFilter是类过滤器，它定义了哪些类名需要拦截；典型的两个实现类为<strong>TypePatternClassFilter</strong>和<strong>TrueClassFilter</strong>(所有类均匹配)；而MethodMatcher为方法匹配器，定义哪些方法需要拦截。</p>
<p>在上面的类图中：</p>
<ul>
<li>StaticMethodMatch与DynamicMethodMatch的区别是后者在运行时会依据方法的参数值进行匹配。</li>
<li>NameMatchMethodPointCut根据指定的mappedNames来匹配方法。</li>
<li>AbstractRegexpMethodPointCut根据正则表达式来匹配方法。</li>
</ul>
<ol>
<li>通知(Advice)：通知定义了具体的横切逻辑。在Spring中，存在两种类型的Advice，即per-class和per-instance的Advice。</li>
</ol>
<p>所谓per-class，即该类型的Advice只提供方法拦截，不会为目标对象保存任何状态或者添加新的特性，它也是我们最常见的Advice。下面是per-class的类图：</p>
<p><img src="" alt=""></p>
<ul>
<li>BeforeAdvice：在连接点前执行的横切逻辑。</li>
<li>AfterReturningAdvice：在连接点执行后，再执行横切逻辑。</li>
<li>AfterAdvice：一般由程序自己实现，当抛出异常后，执行横切逻辑。</li>
<li>AroundAdvice：Spring AOP中并没有提供这个接口，而是采用了AOP Alliance的MethodInteceptor接口；通过看AfterReturningAdvice的源码我们知道，它是不能更改连接点所在方法的返回值的(更改引用)；但使用的MethodInteceptor，所有的事情，都不在话下。</li>
</ul>
<p>在上面的类图中，还有两种类没有介绍，那就是/<em>/</em>/<em>AdviceAdapter和/</em>/<em>/</em>AdviceInteceptor，我们以AfterReturningAdviceInterceptor为例来说明：</p>
<p><img src="" alt=""></p>
<p>该类实现了MethodInterceptor和AfterAdvice接口，同时构造函数中还有一个AfterReturningAdvice实例的参数；这个类存在的作用是为了什么呢？对，没错，Spring AOP把所有的Advice都适配成了MethodInterceptor，统一的好处是方便后面横切逻辑的执行(参看下一节)，适配的工作即由/<em>/</em>/*AdviceAdapter完成；</p>
<p>哈哈，Spring AOP的代码也不过如此嘛：所谓的AfterReturningAdvice，通过适配成MethodInterceptor后，其实就是在invoke方法中，先执行目标对象的方法，再执行的AfterReturningAdvice所定义的横切逻辑。你现在明白它为什么不能修改返回值的引用了吧？</p>
<p>对于per-instance的Advice，目前只有一种实现，就是Introduction，使用的场景比较少，有兴趣的同学可以自己研究一下，呵呵！</p>
<ol>
<li>切面(Aspect)：在Spring中，Advisor就是切面；但与通常的Aspect不同的是，Advisor通常只有一个Pointcut和一个Advice，而Aspect则可以包含多个Pointcut和多个Advice，因此Advisor是一种特殊的Aspect。但，这已经够用了！</li>
</ol>
<p>接下来看下per-class Advisor的类图：</p>
<p><img src="" alt=""></p>
<p>其实没有什么好看的，前面已经说过，Advisor包含一个Pointcut和一个Advisor；在AbstractGenericPointcutAdvisor中，持有一个Advice的引用；下面的几个实现，均是针对前面提到的几种不同的Pointcut的实现。</p>
<p><strong>3.3 Spring AOP实现的基本线索
</strong></p>
<p>我们选择ProxyFactoryBean作为入口点和分析的开始。ProxyFactoryBean是在Spring IoC环境中，创建AOP应用的最底层方法，从中，可以看到一条实现AOP的基本线索。</p>
<p>所有的逻辑从以下的方法开始,我们主要针对单例的代理对象的生成：</p>
<p><img src="" alt=""></p>
<p>下面我们深入到SpringAOP核心代码的内部，看看代理对象的生成机制，拦截器横切逻辑以及织入的实现。</p>
<p><strong>3.4  代理对象的生成
</strong></p>
<p>对于getSingletonInstance()方法返回了什么，这就是代理对象如何产生的逻辑了，然我们须根溯源，看看传说中的proxy到底是如何一步一步的产生的。</p>
<p><img src="" alt=""></p>
<p>ProxyFactoryBean是AdvisedSupport的子类，Spring使用AopProxy接口把AOP代理的实现与框架的其他部分分离开来。在AdvisedSupport中通过这样的方式来得到AopProxy,当然这里需要得到AopProxyFactory的帮助 ，从JDK或者cglib中得到想要的代理对象：</p>
<p><img src="" alt=""></p>
<p>这个DefaultAopProxyFactory是Spring用来生成AopProxy的地方，它包含JDK和Cglib两种实现方式。让我接着往里面看：</p>
<p><img src="" alt=""></p>
<p>可以看到其中的代理对象可以由JDK或者Cglib来生成，JdkDynamicAopProxy类和Cglib2AopProxy都实现的是AopProxy的接口，我们进入JdkDynamicAopProxy实现中看看Proxy是怎样生成的：</p>
<p><img src="" alt=""></p>
<p>用Proxy包装target之后，通过ProxyFactoryBean得到对其方法的调用就被Proxy拦截了， ProxyFactoryBean的getObject()方法得到的实际上是一个Proxy了，target对象已经被封装了。对 ProxyFactoryBean这个工厂bean而言，其生产出来的对象是封装了目标对象的代理对象。</p>
<p><strong>3.5 拦截器的作用
</strong></p>
<p>前面分析了SpringAOP实现中得到Proxy对象的过程，接下来我们去探寻Spring AOP中拦截器链是怎样被调用的，也就是Proxy模式是怎样起作用的。
还记得在JdkDynamicAopProxy中生成Proxy对象的时候，有一句这样的代码吗？</p>
<p><strong>return</strong> Proxy.<em>newProxyInstance</em>(classLoader, proxiedInterfaces, <strong>this</strong>);<em>**</em></p>
<p>这里我们的JdkDynamicAopProxy实现了InvocationHandler这个接口，this参数对应的是InvocationHandler对象,也就是说当 Proxy对象的函数被调用的时候，InvocationHandler的invoke方法会被作为回调函数调用：</p>
<p><img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>上面所说的目标对象方法的调用，是通过AopUtils的方法调用，使用反射机制来对目标对象的方法进行的：</p>
<p><img src="" alt=""></p>
<p>接下来，我们来看具体的ReflectiveMethodInvocation中proceed()方法的实现，也就是拦截器链的实现机制：</p>
<p><img src="" alt=""></p>
<p>从上面的分析我们看到了Spring AOP拦截机制的基本实现，比如Spring怎样得到Proxy，怎样利用JAVA Proxy以及反射机制对用户定义的拦截器链进行处理。</p>
<p><strong>3.6 织入的实现
</strong></p>
<p>在上面调用拦截器的时候，经过一系列的注册，适配的过程以后，拦截器在拦截的时候，会调用到预置好的一个通知适配器，设置通知拦截器，这是一系列Spring设计好为通知服务的类的一个，是最终完成通知拦截和实现的地方，例如对 MethodBeforeAdviceInterceptor的实现是这样的：</p>
<p><img src="" alt=""></p>
<p>可以看到通知适配器将advice适配成Interceptor以后，会调用advice的before方法去执行横切逻辑。这样就成功的完成了before通知的织入。</p>
<p><a href="http://www.goldendoc.org/tag/aop/" title="AOP (1主题)" target="_blank">AOP</a></p>
<h2 id="-spring-ioc-applicationcontext-http-www-goldendoc-org-2010-11-spring_ioc_applicationcontext-2-spring-ioc-applicationcontext-"><a href="http://www.goldendoc.org/2010/11/spring_ioc_applicationcontext-2/" title="永久链接：Spring IoC之ApplicationContext" target="_blank">Spring IoC之ApplicationContext</a></h2>
<p><a href="http://www.goldendoc.org/2010/11/spring_ioc_applicationcontext-2/#comments" target="_blank">0</a></p>
<p>2年前</p>
<p>由<a href="http://www.goldendoc.org/author/iwlh/" title="iwlh发表的文章 " target="_blank">iwlh</a>发布 在<a href="http://www.goldendoc.org/category/spring/" title="Spring (4主题)" target="_blank">Spring</a>
本章主要讲ApplicationContext接口对BeanFactory接口的扩展内容。BeanFactory接口主要围绕着bean和bean相关配置方式，没有关注应用环境的相关配置。ApplicationContext接口从BeanFactory接口派生而来，它与BeanFactory的对比如下图所示：</p>
<p>BeanFactory </p>
<p>ApplicationContext  Bean配置/实例化</p>
<p>Yes </p>
<p>Yes  自动装配BeanPostProcessor</p>
<p>No </p>
<p>Yes  自动装配BeanFactoryPostProcessor</p>
<p>No </p>
<p>Yes  国际化信息（MessageSources）支持</p>
<p>No </p>
<p>Yes  容器内部事件（ApplicationEvent）支持</p>
<p>No </p>
<p>Yes  多配置模块加载</p>
<p>No </p>
<p>Yes </p>
<p><strong>1、统一资源加载
</strong></p>
<p>Spring中提供了org.springframework.core.io.Resource接口作为所有资源的抽象。Spring中默认提供了一些Resource接口的实现类，如图所示：</p>
<p><img src="" alt=""></p>
<p>实现类命名上就可以看出对应的资源，比如ClassPathResource类是从java应用程序的ClassPath中加载相关资源等等。</p>
<p>Spring中使用ResourceLoader来查找和定位Resource资源。ResorceLoader接口类图如下所示：</p>
<p><img src="" alt=""></p>
<p>从上图可以看出，ApplicationContext接口继承自ResourceLoader接口。AbstractApplicationContext抽象类也继承自DefaultResourceLoader类，而且还拥有一个PathMatchingResourcePatternResolver属性字段，需要加载多个Resource时候，委派给PathMatchingResourcePatternResolver类加载即可。</p>
<p>回过来，让我们再看下DefaultResourceLoader中getResource方法的实现代码。</p>
<p><img src="" alt=""></p>
<p>可以看到getResource方法尝试了classPath、url方式加载资源。需要注意的是，该类不能加载相对路径或绝对路径下的资源（例如文件），如果需要加载绝对路径的资源，可以使用FileSystemResourceLoader对象。</p>
<p><strong>2、国际化信息支持
</strong></p>
<p>Java SE中已经有了国际化支持，也就是java.util.Locale和java.util.ResourceBundle。Spring在JavaSE的国际化支持上，进一步抽象了国际化信息的访问接口，提供了org.springframework.context.MessageSource接口，该接口提供一下方法：</p>
<p><img src="" alt=""></p>
<p>ApplicationContext也实现了MessageSource接口。当ApplicationContext初始化时，它会自动在容器中查找名称为”messageSource”的bean。如果找到，对上述方法的调用将被委托给该bean。否则ApplicationContext会在其父类中查找是否含有同名的bean。如果有，就把它作为MessageSource。如果它最终没有找到任何的消息源，一个空的StaticMessageSource将会被实例化，使它能够接受上述方法的调用。messageSource bean的配置实例如下：</p>
<p><img src="" alt=""></p>
<p>Spring提供了三种MessageSource的实现。即StaticMessageSource（提供简单实现，可通过编程方式添加信息条目，多用于测试，不应该用于正式的生产环境）、ResourceBundleMessageSource（基于标准的java.util.ResourceBundle而实现的MessageSource，对父类AbstractMessageSource进行扩展，提供对多个ResourceBundle的缓存以提高查询速度。是最常用的，可用于生产环境下的MessageSource）、ReloadableResourceBundleMessageSource（同样是基于标准的java.util.ResourceBundle而实现的MessageSource，通过cacheSeconds属性可以定期刷新并检查properties资源文件是否发生变化，并且通过ResourceLoader加载properties资源文件。）</p>
<p>另外，MessageSourceAware接口还能用于获取任何已定义的MessageSource引用。任何实现了MessageSourceAware接口的bean将在Spring容器初始化时候与MessageSource一同被注入。</p>
<p>MessageSource与ApplicationContext的类结构图如下所示：</p>
<p><img src="" alt=""></p>
<p><strong>3、Spring容器内部事件发布
</strong></p>
<p>ApplicationContext容器提供了容器内部事件发布功能，是继承自JavaSE标准自定义事件类而实现的。</p>
<p>JavaSE标准自定义事件结构不在此详细描述，一张图很直观的描述清楚：</p>
<p><img src="" alt=""></p>
<p>EventObject，为JavaSE提供的事件类型基类，任何自定义的事件都继承自该类，例如上图中右侧灰色的各个事件。Spring中提供了该接口的子类ApplicationEvent。</p>
<p>EventListener，为JavaSE提供的事件监听者接口，任何自定义的事件监听者都实现了该接口，如上图左侧的各个事件监听者。Spring中提供了该接口的子类ApplicationListener接口。</p>
<p>JavaSE中未提供事件发布者这一角色类， 由各个应用程序自行实现事件发布者这一角色。Spring中提供了ApplicationEventPublisher接口作为事件发布者，并且ApplicationContext实现了这个接口，担当起了事件发布者这一角色。但ApplicationContext在具体实现上有所差异，Spring提供了ApplicationEventMulticaster接口，负责管理ApplicationListener和发布ApplicationEvent。ApplicationContext会把相应的事件相关工作委派给ApplicationEventMulticaster接口实现类来做。类图如下所示：</p>
<p><img src="" alt=""></p>
<p>附上一张事件发布的时序图：</p>
<p><a href="http://pic.yupoo.com/goldendoc/AH0MxsWp/jBIbm.png" target="_blank"><img src="" alt=""></a></p>
<p><strong>4、多配置模块加载
</strong></p>
<p>现在的应用程序，一般都会把配置信息按照某些规则进行分割，将不同类型或关注点的配置项放置在不同的文件中。相对BeanFactory来说，ApplicationContext已经支持了加载多个配置文件。</p>
<p>ApplicationContext加载多个配置文件的方法有：</p>
<p>1) 数组方式</p>
<p>String[] locations = new String[]{ “conf/bean1.xml”,”conf/bean2.xml”, “conf/bean3.xml”};</p>
<p>ApplicationContext container = new FileSystemXmlApplicationContext(locations);</p>
<p>2) 通配符</p>
<p>ApplicationContext container = new FileSystemXmlApplicationContext(“conf//<em>/</em>//*.xml”);</p>
<p>3) ClassPathXmlApplicationContext特性</p>
<p>ApplicationContext ctx = new ClassPathXmlApplicationContext(new String[] {“services.xml”, “daos.xml”}, MessengerService.class);</p>
<p>该方法可以通过MessengerService类在ClassPath中的位置定位配置文件，而不用指定每个配置文件的完整路径名。</p>
<p><a href="http://www.goldendoc.org/tag/applicationcontext/" title="ApplicationContext (1主题)" target="_blank">ApplicationContext</a></p>
<h2 id="-spring-ioc-beanfactory-http-www-goldendoc-org-2010-11-spring-ioc-e4-b9-8bbeanfactory-spring-ioc-beanfactory-"><a href="http://www.goldendoc.org/2010/11/spring-ioc%e4%b9%8bbeanfactory/" title="永久链接：Spring IoC之BeanFactory" target="_blank">Spring IoC之BeanFactory</a></h2>
<p><a href="http://www.goldendoc.org/2010/11/spring-ioc%e4%b9%8bbeanfactory/#comments" target="_blank">0</a></p>
<p>2年前</p>
<p>由<a href="http://www.goldendoc.org/author/khotyn/" title="khotyn发表的文章 " target="_blank">khotyn</a>发布 在<a href="http://www.goldendoc.org/category/spring/" title="Spring (4主题)" target="_blank">Spring</a>
本文的内容为对Spring IoC容器实现的分析。</p>
<p>本文一共分为5个部分：</p>
<ul>
<li>第一部分简要讲述了IoC的概念</li>
<li>第二部分对Spring IoC容器中的主要类及其职责做一些了解</li>
<li>第三部分分析了Spring IoC容器的初始化过程</li>
<li>第四部分分析了从Spring IoC容器中获取Bean的过程</li>
<li>第五部分简要讲述了Spring IoC容器对Bean生命周期的管理。</li>
</ul>
<p>本文假设读者对以下的概念有所了解：IoC（控制反转），DI（依赖注入），Bean，并且读者有使用Spring IoC容器的经验。</p>
<p>约定：本文中所指的IoC容器没有特别说明均为Spring IoC容器</p>
<h3 id="-ioc-"><a href="">一、什么是</a><a href="">IoC</a><a href=""></a></h3>
<p><a href=""></a></p>
<p><a href="">IoC是Inversion of Control的缩写，中文的意思是控制反转，在IoC中，组件不需要去寻找它所依赖的对象，而是由IoC容器来负责将组件所依赖的对象通过Java Bean的Setter方法或者是构造函数等方式注入给组件。IoC的另一个名字是DI，即依赖注入，关于IoC和DI之间的关系以及关于IoC的更多内容，大家可以参考Wiki上的</a><a href="http://www.google.com/url?q=http%3A%2F%2Fzh.wikipedia.org%2Fzh%2F%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC&amp;sa=D&amp;sntz=1&amp;usg=AFQjCNGHDFZSBvJ9wlCDET_IgqV-4DVCzw">控制反转条目。
</a></p>
<p><a href="http://www.google.com/url?q=http%3A%2F%2Fzh.wikipedia.org%2Fzh%2F%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC&amp;sa=D&amp;sntz=1&amp;usg=AFQjCNGHDFZSBvJ9wlCDET_IgqV-4DVCzw">
</a></p>
<h3 id="-http-www-google-com-url-q-http-3a-2f-2fzh-wikipedia-org-2fzh-2f-e6-8e-a7-e5-88-b6-e5-8f-8d-e8-bd-ac-sa-d-sntz-1-usg-afqjcnghdfzsbvj9wlcdet_igqv-4dvczw-ioc-"><a href="http://www.google.com/url?q=http%3A%2F%2Fzh.wikipedia.org%2Fzh%2F%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC&amp;sa=D&amp;sntz=1&amp;usg=AFQjCNGHDFZSBvJ9wlCDET_IgqV-4DVCzw"></a>[二、IoC容器中的类主要类及其职责</h3>
<p>]()</p>
<p><a href="">
我们先来看下IoC容器的一个大概的类图：
</a></p>
<p><a href=""></a><a href="http://www.google.com/url?q=http%3A%2F%2Fpic.yupoo.com%2Fkhotyn%2F816909ab9c75%2Fji8tx5ue.jpg&amp;sa=D&amp;sntz=1&amp;usg=AFQjCNEixIuYlet6oZmgnSPQy-ZxrCs4yA"><img src="" alt=""></a></p>
<p><a href="http://www.google.com/url?q=http%3A%2F%2Fpic.yupoo.com%2Fkhotyn%2F816909ab9c75%2Fji8tx5ue.jpg&amp;sa=D&amp;sntz=1&amp;usg=AFQjCNEixIuYlet6oZmgnSPQy-ZxrCs4yA" target="_blank">点击查看大图</a></p>
<p>这张图中比较简单的展示了IoC容器中的各个类及其指责，我们需要重点把握几个接口的职责：</p>
<ul>
<li>BeanFactory：这个接口是整个IoC容器最底层的接口，定义了一组访问Bean容器的基本方法。一些其他的接口，比如ListableBeanFactory和ConfigurableBeanFactory，都是继承了BeanFactory，并添加了其他的方法来完成某些特别的功能（比如ConfigurableBeanFactory，顾名思义，这个接口的职责是让BeanFactory变得可配置，那么它就定义了一组可以配置BeanFactory的方法）。</li>
<li>AbstractBeanFactory：从名字可以看出，这个类是BeanFactory接口的一个抽象实现类，这个类本身实现的是ConfigurableBeanFactory，对ConfigurableBeanFactory以及BeanFactory中的方法提供了实现，并且提供了一些诸如单例缓存，别名等等功能。</li>
<li>SingletonBeanRegistry：定义了一组操作单例Bean的方法</li>
</ul>
<h3 id="-ioc-"><a href="">三、</a>[IoC容器的初始化</h3>
<p>]()<a href=""></a></p>
<p>[
使用过Spring的人都知道，我们都是在一份Bean配置文件中定义Bean，然后就可以通过BeanFactory的getBean()方法来获取Bean，那么我们就可以大致猜想到IoC容器的初始化工作大概就是将我们编写的Bean配置文件转换成IoC容器内部定义的用于放置Bean定义信息的数据结构，而这个数据结构就是BeanDefinition这个类。下面我们就来了解下这个转换过程是如何进行的。</p>
<p>我们通过实例化ClassPathXmlApplicationContext这个类来一步步来看其初始化的过程，简单地实例化ClassPathXmlApplicationContext的代码如下：</p>
<p><img src="" alt=""></p>
<p>这里我们传入一个beans.xml作为配置文件的路径去实例化一个ClassPathXmlApplicationContext。</p>
<p>首先我们还是来看下整个初始化过程的序列图：
]()</p>
<p><a href=""></a><a href="http://www.google.com/url?q=http%3A%2F%2Fpic.yupoo.com%2Fkhotyn%2F005389ab9c75%2Fogfhmraj.jpg&amp;sa=D&amp;sntz=1&amp;usg=AFQjCNHa07fld9fiZq1BzNzeljU3nfHFXQ"><img src="" alt=""></a></p>
<p><a href="http://www.google.com/url?q=http%3A%2F%2Fpic.yupoo.com%2Fkhotyn%2F005389ab9c75%2Fogfhmraj.jpg&amp;sa=D&amp;sntz=1&amp;usg=AFQjCNHa07fld9fiZq1BzNzeljU3nfHFXQ" target="_blank">点击查看大图</a></p>
<p>这个图中涉及到的类或许有点吓人，且慢，下面我会慢慢带你了解整个过程。从序列图里面我们看到初始化过程首先调用了refresh()方法，后面调用到了AbstractXmlApplicationContext的loadBeanDefinitions方法，来看下这个方法的实现：</p>
<p><img src="" alt=""></p>
<p>这个方法将beanFactory（实现了BeanDefinitionRegistry接口，后续将通过这个接口将Bean定义信息注册到BeanFactory中去）传入new了一个XmlBeanDefinitionReader对象，然后将刚刚new出来的beanDefinitionReader传入调用loadBeanDefinitions方法，最终调用了XmlBeanDefinitionReader的loadBeanDefinitions(EncodedResource encodedResource)方法：</p>
<p><img src="" alt=""></p>
<p>这个方法获取了Bean配置文件的输入流，并且调用了doLoadBeanDefinitions方法，在这个方法里面，程序将输入流转换成Document对象，然后调用了下面这个方法：</p>
<p><img src="" alt=""></p>
<p>需要注意这个createReaderContext(resource)方法，创建这个方法的时候XmlBeanDefinitionReader将自己传入，以便在后面可以获取到它的Registry对象。最终DefaultBeanDefinitionDocumentReader将解析BeanDefinition的工作又交给了BeanDefinitionParserDelegate对象：</p>
<p><img src="" alt=""></p>
<p>从上面的方法中，我们可以看到BeanDefinitionParserDelegate对象解析出BeanDefinition后，就由BeanDefinitionRegistry来将BeanDefinition注册到BeanFactory中去了。</p>
<p>至此，整个BeanFactory就初始化完毕了，可能一大堆方法调来调去地早就把大家给调晕了，我们就来总结下初始化过程中设计到的几个主要的类以及它们的职责吧：</p>
<ul>
<li>XmlBeanDefinitionReader：读取定义Bean的XML文件并且将XML文件转成Document对象，交给BeanDefinitionDocuementReader再做解析。它持有一个BeanDefinitionRegistry对象，用于将BeanDefinition注册到BeanFactory中去。</li>
<li>XmlBeanDefinitionDocumentReader：取出Docuement对象内的各个元素并将这些元素交给BeanDefinitionParserDelegate来解析。</li>
<li>BeanDefinitionParserDelegate：用于解析Bean定义信息的代理类，负责一个Bean定义信息（可以看作是一个<bean></bean>标签对）解析成一个BeanDefinition对象。</li>
<li>BeanDefinitionRegister：负责将BeanDefinition注册到BeanFactory中去。</li>
</ul>
<h3 id="-ioc-bean-"><a href="">四、从</a><a href="">IoC容器中获取Bean</a><a href=""></a></h3>
<p><a href="">
用过Spring的人大概都知道，在Spring中，我们是通过调用BeanFactory的getBean()方法来取得我们所需要的Bean的，而getBean()方法的主要逻辑在AbstactBeanFactory的doGetBean()方法中。在Spring中，有单例Bean和原型Bean的区分，在从容器中获取Bean的时候，单例Bean和原型Bean有些不同，当第一次获取单例Bean的时候，整个过程和获取原型Bean几乎是一样的，都需要创建一个Bean，但是当第二次，第三次，……，获取同样的单例Bean的时候，容器就直接从单例缓存中获取Bean了，而不会再去像获取原型Bean一样一而再再而三地创建Bean了。这样我们这一节也主要从两个方面来讲，一个是获取原型Bean，第一次获取单例Bean的逻辑和这个类似，有特别的地方也会在这里顺带提到，二则是将从单例缓存中获取单例Bean的过程，首先我们来看获取原型Bean：
</a></p>
<h3 id="-4-1-bean"><a href=""></a>[4.1、获取原型Bean</h3>
<p>]()</p>
<p>[
正如前面所说，我们来看下AbstractBeanFactory的doGetBean()方法来了解获取原型Bean的整个过程。</p>
<p>在获取Bean的时候，无论这个Bean是单例的还是原型的，Spring都会尝试从单例缓存中获取Bean，但是当拿原型Bean的时候，这里显然是拿不到的，接下来程序就会根据BeanDefinition信息来判断要创建的Bean是不是原型Bean，如果是，则进入下面这段逻辑：</p>
<p><img src="" alt=""></p>
<p>程序在上图的（1）中的位置调用了beforePrototypeCreation方法，告诉容器当前的这个Bean正在创建中，来防止发生重复创建的情况。接下来，程序在（2）处调用了createBean方法来创建这个prototypeBean，最后，在（3）处，程序调用afterProtytypeCreation来告诉容器，这个Bean现在已经不再创建过程中了。</p>
<p>那么，让我们来关注下createBean这个方法里面干了些什么事情：</p>
<p><img src="" alt=""></p>
<p>在做了一堆准备工作后，程序就到了上面的这一段中，从代码中我们可以看出这个方法主要的功能为以下两点：</p>
<ul>
<li>调用resolveBeforeInstantiation方法，让BeanPostProcessor可以有机会给你返回一个代理类而不是原来的类，当后面我们看到Spring AOP代理类的生成的时候，就会看到这个方法的用处了。</li>
<li>调用doCreateBean()方法创建Bean</li>
</ul>
<p>我们再来看下doCreateBean方法：</p>
<p><img src="" alt=""></p>
<p>同样，这个方法里面也有两个主要的功能：</p>
<ul>
<li>一是调用createBeanInstance方法，创建一个Bean实例，在这个方法的内部，会调用BeanUtils的instantiateClass来实例化Bean，并把它包装成一个BeanWrapper</li>
<li>二是调用populateBean方法来将Bean依赖的属性设置进去。
]()</li>
</ul>
<h3 id="-4-2-bean"><a href=""></a>[4.2、创建单例Bean</h3>
<p>]()</p>
<p>[
整个获取原型Bean的过程大概就是这样样子，因为创建单例Bean和这个过程基本上是一样的，但是也有一些稍微不一样的地方，这里也稍微提到一下：</p>
<p><img src="" alt=""></p>
<p>创建单例Bean是通过调用getSingleton来实现的，这个方法传入一个beanName和一个ObjectFactory，这个ObjectFactory的getObject方法里面调用到了我们前面提到的createBean方法，所以我们看下getSingleton这个方法的实现：</p>
<p><img src="" alt=""></p>
<p>这个方法先尝试从singletonObjects中获取单例Bean，如果获取不到，则自己创建，同样，和创建原型Bean一样，在创建开始之前会调用beforeSingletonCreation方法来将beanName放到singletonsCurrentlyInCreation来告诉容器这个Bean已经在创建中了，在创建完成之后，会将BeanName从singletonsCurrentlyInCreation中删除掉。创建的过程是调用了传入的ObjectFactory的getObject方法，和创建原型Bean类似。在创建完成之后，还有一步addSingleton的操作，来讲单例放到单例缓存中去，看一下这个的实现：</p>
<p><img src="" alt=""></p>
<p>方法的逻辑非常简单：把创建出来的单例Bean放到singletonObjects中去，然后从singletonFactories和earlySingletonObjects中删除掉，最后在registeredSingletons里面再加入这个Bean，对于这里面用到的几个容器，我觉得有必要在这里描述一下其作用，要不然读者肯定是晕呼晕呼的：</p>
<ul>
<li>singletonObjects：用于保存BeanName和Bean实例之间的关系</li>
<li>singletonFactories：用于保存BeanName和创建Bean的工厂之间的关系</li>
<li>earlySingletonObjects：也是保存BeanName和Bean实例之间的关系，与singletonObjects的不同之处在于，当一个单例Bean被放到这里面去后，那么当Bean还在创建过程中，就可以通过getBean来拿到了，其目的是用来检测循环引用。</li>
<li>registeredSingletons：用来保存当前所有已注册的Bean
]()</li>
</ul>
<h3 id="-4-3-bean"><a href=""></a>[4.3、从单例缓存中获取单例Bean</h3>
<p>]()</p>
<p>[
单例在Spring的同一个容器内只会被创建一次，后续再获取Bean，就直接从单例缓存中获取了，我们来看下这一段过程，看下doGetBean里面调用的getSingleton方法：</p>
<p><img src="" alt=""></p>
<p>这个方法的逻辑也相对简单，先尝试从singletonObjects里面获取，如果获取不到再从earlySingletonObjects里面获取，如果再获取不到，再尝试从singletonFactories里面获取beanName对应的ObjectFactory，然后调用这个ObjectFactory的getObject来创建Bean，并放到earlySingletonObjects里面去，并且从singletonFacotories里面remove掉这个ObjectFactory。</p>
<h3 id="-ioc-bean-">六、IoC容器对Bean生命周期的管理</h3>
<p>Spring有一套Bean生命周期去管理Bean，值得注意的是，Spring只对非单例的Bean进行生命周期管理。关于Spring中Bean的生命周期，我们来看下一张老图：</p>
<p><img src="" alt=""></p>
<p>在上面这张图里面，我们看到有很多的生命周期方法，那么这些生命周期方法是在哪里调用的呢？在前面获取原型Bean的一节中，我们已经知道，Spring会先调用createBeanInstance方法来创建Bean实例，然后通过populateBean方法来设置Bean的属性，在调用这个方法之后，其实Spring还调用了一个initializeBean的方法，上图中我们看到的生命周期方法基本上都在这个方法里面调用：</p>
<p><img src="" alt=""></p>
<p>在这个方法里面：</p>
<ul>
<li>Spring首先调用了invokeAwareMethods来调用各个Aware方法，包括BeanNameAware，BeanClassLoaderAware和BeanFactoryAware</li>
<li>然后调用了所有BeanPostProcessor的postProcessBeforeInitialization方法</li>
<li>接着调用invokeInitMethods方法，里面包括调用afterPropertiesSet和自定义的init方法</li>
<li>最后调用了所有BeanPostProcessor的postProcessAfterInitialization方法</li>
</ul>
<p>在调用这些方法以后，我们的Bean才算是可以使用啦。至于生命周期的最后两个方法，是在容器销毁的时候来调用的。
]()<a href=""></a></p>
<p><a href=""></a></p>
<p><a href=""></a><a href="http://www.goldendoc.org/tag/beanfactory/" title="BeanFactory (1主题)">BeanFactory</a></p>
<p>*</p>
<ul>
<li><h3 id="-">分类</h3>
</li>
<li><p><a href="http://www.goldendoc.org/category/java-nio/" title="查看 Java NIO下的所有文章" target="_blank">Java NIO <strong>(9)</strong> Java NIO相关内容</a></p>
</li>
<li><a href="http://www.goldendoc.org/category/jms/" title="查看 JMS下的所有文章" target="_blank">JMS <strong>(3)</strong> Java Messaging Service</a></li>
<li><a href="http://www.goldendoc.org/category/juc/" title="查看 JUC下的所有文章" target="_blank">JUC <strong>(4)</strong></a></li>
<li><a href="http://www.goldendoc.org/category/jvm/" title="查看 JVM下的所有文章" target="_blank">JVM <strong>(8)</strong> Java Virtual Machine</a></li>
<li><a href="http://www.goldendoc.org/category/spring/" title="查看 Spring下的所有文章" target="_blank">Spring <strong>(4)</strong></a></li>
<li><a href="http://www.goldendoc.org/category/tomcat/" title="查看 Tomcat下的所有文章" target="_blank">Tomcat <strong>(7)</strong></a></li>
<li><a href="http://www.goldendoc.org/category/translation/" title="查看 翻译下的所有文章" target="_blank">翻译 <strong>(1)</strong></a></li>
<li><h3 id="-">最新评论</h3>
</li>
<li><p><a href="http://www.goldendoc.org/2012/01/optimization-barrier3/#comment-306" title="在 优化屏障（Optimization barrier）第三讲" target="_blank"><img src="" alt="熊猫家族">  熊猫家族 很详细，了解了很多 5个月前</a></p>
</li>
<li><a href="http://www.goldendoc.org/2011/06/juc_concurrenthashmap/#comment-304" title="在 Java并发编程之ConcurrentHashMap" target="_blank"><img src="" alt="聊聊并发（四）深入分析ConcurrentHashMap并发编程网 | 并发编程网">  聊聊并发（四）深入分析ConcurrentHashMap并发编程网 | 并发编程网 [...] Java并发编程之ConcurrentHashMap [...] 6个月前</a></li>
<li><a href="http://www.goldendoc.org/2011/06/juc_concurrenthashmap/#comment-301" title="在 Java并发编程之ConcurrentHashMap" target="_blank"><img src="" alt="Jun">  Jun for (HashEntry p = first; p != e; p = p.next) newFirst = new HashEntry(p.key, p.hash, […] 6个月前</a></li>
<li><a href="http://www.goldendoc.org/2011/06/juc_concurrenthashmap/#comment-294" title="在 Java并发编程之ConcurrentHashMap" target="_blank"><img src="" alt="khotyn">  khotyn 这里是我搞错了，已经纠正过来了，谢谢赵姐夫指正。 7个月前</a></li>
<li><a href="http://www.goldendoc.org/2011/06/juc_concurrenthashmap/#comment-293" title="在 Java并发编程之ConcurrentHashMap" target="_blank"><img src="" alt="老赵">  老赵 这里Segment的数量是不大于concurrentLevel的最大的2的指数 应该是“不小于concurrentLevel”的最小的2的指数吧。 7个月前</a>
<a href="&quot;显示下5个条目&quot;">显示更多</a></li>
<li><h3 id="-">最新文章</h3>
</li>
<li><p><a href="http://www.goldendoc.org/2013/01/parentdelegation/" title="从问题出发看双亲委派" target="_blank">从问题出发看双亲委派 (0)  同事A问了这样一个问题： <em>BootstrapClassLoader为什么能够加载用户自定义的类？</em> 当时我想到的是这样的场景： javaagent设置Boot-Class-Path，或者添加启动参数-Xbootclasspath、-Xbootclasspath/a […] 5个月前</a></p>
</li>
<li><a href="http://www.goldendoc.org/2012/07/somethings_i_ve_learnt_about_programming/" title="我学到的一些关于编程的事儿（翻译）" target="_blank">我学到的一些关于编程的事儿（翻译） (3) 原文地址：Some things I&#39;ve learnt about programming ---- By John Graham-Cumming 我已经从事编程 30 年了，用过的机器包括从现在看来很差的（基于 Z80 和 6502）到最新的，用过的语言包括 […] 11个月前</a></li>
<li><a href="http://www.goldendoc.org/2012/02/classloader-jvm/" title="ClassLoader与JVM" target="_blank">ClassLoader与JVM (0) <strong>一、ClassLoader与HotSpot</strong> 对JVM有所了解的人应该知道，类文件的格式是不能违背JVM规范的，而JVM自然会有解析类文件的工具ClassFileParser。 ClassFileParser由ClassFileStream/*构造，其实 […] 1年前</a></li>
<li><a href="http://www.goldendoc.org/2012/01/optimization-barrier3/" title="优化屏障（Optimization barrier）第三讲" target="_blank">优化屏障（Optimization barrier）第三讲 (1) 上一篇 优化屏障（Optimization barrier）第二讲 1. […] 1年前</a></li>
<li><a href="http://www.goldendoc.org/2012/01/optimization-barrier2/" title="优化屏障（Optimization barrier）第二讲" target="_blank">优化屏障（Optimization barrier）第二讲 (1) 上一篇 优化屏障（Optimization barrier）第一讲 1. gcc编译的大致过程 可以看到，gcc优化主要分两大部分:Tree优化和RTL(Register Transfer Language)优化； 前文所说的指令调度（Instruction […] 1年前</a>
<a href="&quot;显示下5个条目&quot;">显示更多</a></li>
<li><h3 id="-">友情链接</h3>
</li>
<li><p><a href="http://ifeve.com/" target="_blank">并发编程促进并发编程的研究和传播</a>
自豪地使用<a href="http://wordpress.org/" target="_blank">WordPress</a>，Mystique主题来自<a href="http://digitalnature.eu/" target="_blank">digitalnature</a> | <a href="http://www.goldendoc.org/feed/" target="_blank">RSS订阅</a>  <a href="">回到顶部</a></p>
</li>
</ul>
<p><a href=""> </a></p>
<p><a href=""> </a></p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/框架汇总/">框架汇总</a></li></span><span class="breadcrumb"><li><a href="/categories/框架汇总/">框架汇总</a></li><li><a href="/categories/框架汇总/Spring/">Spring</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Spring/" class="label label-primary">Spring</a><a href="/tags/框架汇总/" class="label label-success">框架汇总</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:29"datetime="2014-03-07 09:54:29"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-框架汇总-Spring--Spring-设计模式-aop-ioc/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-框架汇总-Spring--Spring-设计模式-aop-ioc" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-框架汇总-ORM-hibernate--Hibernate的体系结构与分析、工作原理/">Hibernate的体系结构与分析、工作原理</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:29.000Z"> <a href="/2014/02/02/2014-02-02-框架汇总-ORM-hibernate--Hibernate的体系结构与分析、工作原理/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="hibernate-">Hibernate的体系结构与分析、工作原理</h1>
<p>本文摘自 李刚 著 《Java EE企业应用实战》</p>
<pre><code>    现在我们知道了一个概念**Hibernate Session**，只有处于**Session**管理下的**POJO**才具有持久化操作能力。当应用程序对于处于**Session**管理下的**POJO**实例执行操作时，**Hibernate**将这种面向对象的操作转换成了持久化操作能力。
</code></pre><p>HIbernate简要的体系结构如下图所示：</p>
<p><img src="" alt=""></p>
<pre><code>    通过上图能够发现HIbernate需要一个**hibernate.properties**文件，该文件用于配置**Hibernate**和数据库连接的信息。还需要一个XML文件，该映射文件确定了持久化类和数据表、数据列之间的想对应关系。
</code></pre><p>除了使用hibernate.properties文件，还可以采用另一种形式的配置文件： <strong>/*.cfg.xml</strong>文件。在实际应用中，采用XML配置文件的方式更加广泛，两种配置文件的实质是一样的。</p>
<pre><code>    Hibernate的持久化解决方案将用户从赤裸裸的JDBC访问中释放出来，用户无需关注底层的JDBC操作，而是以面向对象的方式进行持久层操作。底层数据连接的获得、数据访问的实现、事务控制都无需用户关心。这是一种“全面解决”的体系结构方案，将应用层从底层的JDBC/JTA API中抽象出来。通过配置文件来管理底层的JDBC连接，让Hibernate解决持久化访问的实现。这种“全面解决”方案的体系结构图如图所示：
</code></pre><p><img src="" alt=""></p>
<pre><code>    针对以上的Hibernate全面解决方案架构图：

  （1）**SessionFactory**：**这是Hibernate的关键对象，**它是单个数据库映射关系经过编译后的内存镜像，它也是**线程安全的**。**它是生成Session的工厂**，本身要应用到ConnectionProvider，该对象可以在进程和集群的级别上，为那些事务之间可以重用的数据提供可选的二级缓存。

  （2）**Session**：它是应用程序和持久存储层之间交互操作的一个单线程对象。它也是Hibernate持久化操作的关键对象，所有的持久化对象必须在Session的管理下才能够进行持久化操作。**此对象的生存周期很短，其隐藏了JDBC连接，也是Transaction 的工厂。Session对象有一个一级缓存，现实执行Flush之前，所有的持久化操作的数据都在缓存中Session对象处。**

  （3）**持久化对象**：系统创建的POJO实例一旦与特定Session关联，并对应数据表的指定记录，那该对象就处于持久化状态，这一系列的对象都被称为持久化对象。程序中对持久化对象的修改，都将自动转换为持久层的修改。**持久化对象完全可以是普通的Java Beans/POJO，唯一的特殊性是它们正与Session关联着。**

  （4）**瞬态对象和脱管对象**：系统进行new关键字进行创建的Java 实例，没有Session 相关联，此时处于瞬态。瞬态实例可能是在被应用程序实例化后，尚未进行持久化的对象。如果一个曾今持久化过的实例，但因为Session的关闭而转换为脱管状态。

  （5）**事务(Transaction)**：代表一次原子操作，它具有数据库事务的概念。但它通过抽象，将应用程序从底层的具体的JDBC、JTA和CORBA事务中隔离开。在某些情况下，一个Session 之内可能包含多个Transaction对象。虽然事务操作是可选的，但是所有的持久化操作都应该在事务管理下进行，即使是只读操作。

  （6）**连接提供者(ConnectionProvider)：****它是生成JDBC的连接的工厂，同时具备连接池的作用。他通过抽象将底层的DataSource和DriverManager隔离开。这个对象无需应用程序直接访问，仅在应用程序需要扩展时使用。**

  （7）事务工厂(TransactionFactory)：他是生成Transaction对象实例的工厂。该对象也无需应用程序的直接访问。
</code></pre><p>来源： <a href="[http://blog.csdn.net/titilover/article/details/6920457](http://blog.csdn.net/titilover/article/details/6920457)">[http://blog.csdn.net/titilover/article/details/6920457](http://blog.csdn.net/titilover/article/details/6920457)</a> </p>
<pre><code>前面说了一些宏观上学习框架相关的思想方面的东西，下面继续来介绍我经常使用的框架和框架的分析，这篇博客主要介绍的是hibernate框架。

  首先说hibernate框架是数据持久层的框架，这个框架是非常强大的，它让编程人员纯粹的用面向对象的方式来做开发，让编程人员所面对的都是对象。仅仅从这一点它的设计思路就是非常让编程人员喜爱的。

  回想我们普通的开发流程，和客户沟通定需求，抽象出来原型，从原型中建立数据模型到库表结构的建立，之后在映射成对象模型，之后在用oo的设计思想完成后续的程序开发。但是当我们使用了hibernate框架以后，原先的设计思路就显得不再那么具有优势了。我们直接建立对象模型，之后利用hibernate框架映射成数据模型，我们不再去考虑数据库关系模型的东西，仅仅考虑的东西仅仅就是类和对象，这样的开发才是面向对象的开发，也才是最接近人类思考问题的方式。所以hibernate框架的设计思路是非常好的。

    hibernate框架设计思路的优越性其实体现在了它本身的框架的原理上。hibernate封装了JDBC，减轻了开发人员在持久层的大量重复性工作，它利用了java反射机制来实现程序的透明性；它就是通过这两点才达到从对象出发而非关系数据库出发的效果。



  介绍这么多理论性的东西之后我们能够感觉到hibernate框架的强大，来看看它的结构图：
</code></pre><p><img src="" alt=""></p>
<pre><code>   在hibernate框架中有几个比较重要的接口和类：
</code></pre><ol>
<li><p>Query接口：Query负责执行各种数据库查询。它可以使用HQL语句或SQL语句两种表达方式。</p>
</li>
<li><p>Configuration类：Configuration类负责配置并启动Hibernate，创建SessionFactory对象</p>
</li>
<li><p>SessionFactory接口：SessionFactory接口负责初始化Hibernate。它充当数据存储源的代理，并负责创建Session对象</p>
</li>
<li><p>Session接口：Session接口负责执行被持久化对象的CRUD操作</p>
</li>
<li><p>Transaction接口：Transaction接口负责事务相关的操作</p>
</li>
</ol>
<pre><code>     hibernate框架就是在利用这几个接口来封装了JDBC，而且我们用这些接口来操作数据库变得非常简单，减少了我们在持久层的代码量。

   从这个结构图和我的一些分析就能发现hibernate框架是非常强大，而且它给我们开发人员的开发带来了非常大的便利，尤其是他的设计思路还有它的“全自动”的映射对象模型和关系模型。

   但是hibernate框架也有它的一些缺点：
</code></pre><ol>
<li><p>既然是封装了JDBC，所以很明显它没有JDBC的效率高，尤其是在大量的处理表更新操作的时候。</p>
</li>
<li><p>它有局限性，一个持久化类不能映射多个表</p>
</li>
<li>它应对大数量的时候显得非常笨拙，这一点没有JDBC和接下来要介绍的IBatis框架</li>
</ol>
<pre><code>   其实一项技术或者一个框架都有它的优缺点，选择最合适的才是王道。
</code></pre><p>来源： <a href="[http://blog.csdn.net/lfsf802/article/details/7941958](http://blog.csdn.net/lfsf802/article/details/7941958)">[http://blog.csdn.net/lfsf802/article/details/7941958](http://blog.csdn.net/lfsf802/article/details/7941958)</a> </p>
<p>Hibernate工作原理：</p>
<p>1.Hibernate 的初始化.</p>
<p>读取Hibernate 的配置信息-〉创建Session Factory</p>
<p>1)创建Configeration类的实例：</p>
<p>它的构造方法：将配置信息(Hibernate config.xml)读入到内存。 
一个Configeration 实例代表Hibernate 所有Java类到Sql数据库映射的集合。</p>
<p>2)创建SessionFactory实例：</p>
<p>把Configeration 对象中的所有配置信息拷贝到SessionFactory的缓存中。 
SessionFactory的实例代表一个数据库存储员源，创建后不再与Configeration 对象关联。</p>
<p>3)调用SessionFactory创建Session的方法：</p>
<pre><code>    1】用户自行提供JDBC连接。

    Connection con=dataSource.getConnection();
    Session s=sessionFactory.openSession(con);

    2】让SessionFactory提供连接

    Session s=sessionFactory.openSession();
</code></pre><p>4)通过Session 接口提供的各种方法来操纵数据库访问。</p>
<p>Hibernate 的缓存体系</p>
<p>一级缓存：</p>
<p>Session 有一个内置的缓存，其中存放了被当前工作单元加载的对象。 
每个Session 都有自己独立的缓存，且只能被当前工作单元访问。</p>
<p>二级缓存：</p>
<p>SessionFactory的外置的可插拔的缓存插件。其中的数据可被多个Session共享访问。</p>
<p>SessionFactory的内置缓存：存放了映射元数据，预定义的Sql语句。</p>
<p>Hibernate 中Java对象的状态</p>
<p>1.临时状态 (transient)</p>
<p>特征：</p>
<p>1】不处于Session 缓存中
2】数据库中没有对象记录</p>
<p>Java如何进入临时状态</p>
<p>1】通过new语句刚创建一个对象时 
2】当调用Session 的delete()方法，从Session 缓存中删除一个对象时。</p>
<p>2.持久化状态(persisted)</p>
<p>特征：</p>
<p>1】处于Session 缓存中 
2】持久化对象数据库中设有对象记录 
3】Session 在特定时刻会保持二者同步</p>
<p>Java如何进入持久化状态</p>
<p>1】Session 的save()把临时－》持久化状态 
2】Session 的load(),get()方法返回的对象 
3】Session 的find()返回的list集合中存放的对象 
4】Session 的update(),saveOrupdate()使游离－》持久化</p>
<p>3.游离状态(detached)</p>
<p>特征：</p>
<p>1】不再位于Session 缓存中 
2】游离对象由持久化状态转变而来，数据库中可能还有对应记录。</p>
<p>Java如何进入持久化状态－》游离状态</p>
<p>1】Session 的close()方法 
2】Session 的evict()方法，从缓存中删除一个对象。提高性能。少用。</p>
<p>总结一下Hibernate的好处：</p>
<p>1.JDBC访问数据库的代码做了封装，大大简化了数据访问层繁琐的重复性代码。</p>
<ol>
<li><p>Hibernate是一个基于JDBC的主流持久化框架，是一个优秀的ORM实现。他很大程度的简化DAO层的编码工作</p>
</li>
<li><p>hibernate使用Java反射机制，而不是字节码增强程序来实现透明性。</p>
</li>
<li><p>hibernate的性能非常好，因为它是个轻量级框架。映射的灵活性很出色。它支持各种关系数据库，从一对一到多对多的各种复杂关系。
来源： <a href="[http://www.linuxidc.com/Linux/2012-12/76684.htm](http://www.linuxidc.com/Linux/2012-12/76684.htm)">[http://www.linuxidc.com/Linux/2012-12/76684.htm](http://www.linuxidc.com/Linux/2012-12/76684.htm)</a> </p>
</li>
</ol>
<p><img src="" alt=""></p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/框架汇总/">框架汇总</a></li></span><span class="breadcrumb"><li><a href="/categories/框架汇总/">框架汇总</a></li><li><a href="/categories/框架汇总/ORM/">ORM</a></li><li><a href="/categories/框架汇总/ORM/hibernate/">hibernate</a></li></span></span> | <span class="tags">Tagged <a href="/tags/ORM/" class="label label-primary">ORM</a><a href="/tags/hibernate/" class="label label-success">hibernate</a><a href="/tags/框架汇总/" class="label label-info">框架汇总</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:29"datetime="2014-03-07 09:54:29"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-框架汇总-ORM-hibernate--Hibernate的体系结构与分析、工作原理/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-框架汇总-ORM-hibernate--Hibernate的体系结构与分析、工作原理" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-框架汇总-ORM-hibernate--Hibernate知识总结/">Hibernate知识总结</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:29.000Z"> <a href="/2014/02/02/2014-02-02-框架汇总-ORM-hibernate--Hibernate知识总结/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="hibernate-">Hibernate知识总结</h1>
<p><a href=""></a></p>
<h1 id="-li-boy-http-libooy-diandian-com-"><a href="http://libooy.diandian.com/" target="_blank">Li-boy 奋斗的蜗牛</a></h1>
<ul>
<li><a href="http://libooy.diandian.com/submit" target="_blank">投稿</a></li>
<li><a href="http://libooy.diandian.com/inbox" target="_blank">私信</a></li>
<li><a href="http://libooy.diandian.com/archive" target="_blank">存档</a></li>
<li><a href="http://libooy.diandian.com/random" target="_blank">随机文章</a></li>
<li><a href="">关于</a>
<img src="" alt="Li-boy 奋斗的蜗牛"></li>
</ul>
<h3 id="-">关于我</h3>
<p>一天进步一点点！！！</p>
<p>26 Mar</p>
<h1 id="hibernate-">Hibernate知识总结</h1>
<p><img src="" alt=""></p>
<hr>
<p><strong>1.Hibernate持久化对象的生命周期 (状态)  </strong></p>
<p>(1) 瞬态（自由态） (2) 持久态 (3) 托管（游离态）</p>
<p><strong>1.1自由态</strong></p>
<p>   持久化对象的自由态，指的是对象在内存中存在，但是在数据库中并</p>
<p>没有数据与其关联。比如Student student = new Student()，这里</p>
<p>的student对象就是一个自由态的持久化对象。</p>
<p><strong>1.2持久态</strong></p>
<p>   持久态指的是持久化对象处于由Hibernate管理的状态，这种状态下</p>
<p>持久化对象的变化将会被同步到数据库中。</p>
<p>session.beginTransaction();</p>
<p>User user = new User();</p>
<p>user.setUserName(&quot;James&quot;);</p>
<p>user.setUserPwd(&quot;123&quot;);</p>
<p>session.save(user);</p>
<p>session.getTransaction().commit();</p>
<p><strong>1.3游离态</strong></p>
<p>处于持久态的对象，在其对应的Session实例关闭后，此时对象迚入</p>
<p>游离态。也就是说Session实例是持久态对象的宿主环境，一旦宿主</p>
<p>环境失效，那么持久态对象迚入游离状态。</p>
<p>session.beginTransaction();</p>
<p>User user = new User();</p>
<p>user.setUserName(&quot;James&quot;);</p>
<p>user.setUserPwd(&quot;123&quot;);</p>
<p>Integer id = (Integer) session.save(user);</p>
<p>user.setUserPwd(&quot;456&quot;);</p>
<p>session.getTransaction().commit();</p>
<p>user.setUserPwd(&quot;789&quot;);</p>
<p><strong>游离态和自由态的区别</strong></p>
<p>区别就在于游离态对象可以再次与Session迚行关联而成为持久态对</p>
<p>象。</p>
<p>session.beginTransaction();</p>
<p>User user = new User();</p>
<p>user.setUserName(&quot;James&quot;);</p>
<p>user.setUserPwd(&quot;123&quot;);</p>
<p>Integer id = (Integer) session.save(user);</p>
<p>user.setUserPwd(&quot;456&quot;);</p>
<p>session.getTransaction().commit();</p>
<p>Session session2 = HibernateUtil.getSessionFactory().getCurrentS</p>
<p>session2.beginTransaction();</p>
<p>user.setUserPwd(&quot;789&quot;);</p>
<p>session2.update(user);</p>
<p>session2.getTransaction().commit();</p>
<p>自由态对象在数据库中没有数据与其对应，但是游离态对象在数据库</p>
<p>中有数据与其对应，只不过当前对象不在Session环境中而已。从对</p>
<p>象的是否有主键值可以做简单的判断。</p>
<p>session.beginTransaction();</p>
<p>User user = new User();</p>
<p>user.setUserName(&quot;James&quot;);</p>
<p>user.setUserPwd(&quot;123&quot;);</p>
<p>System.out.println(user.getId());</p>
<p>Integer id = (Integer) session.save(user);</p>
<p>session.getTransaction().commit();</p>
<p>System.out.println(user.getId());</p>
<p>如果我自己创建一个对象，并且给主键属性赋值，该值还在数据库中</p>
<p>存在，当前对象的状态不也是游离态了？</p>
<p>/* 在Hibernate中根据主键判断对象是自由态还是游离态只是判断的</p>
<p>一个参考点，在Hibernate中还有更复杂的机制来判断一个对象的</p>
<p>状态，比如对象的version等等。</p>
<p>回到自由态</p>
<p>session.beginTransaction();</p>
<p>User user = (User) session.load(User.class, 120);</p>
<p>session.delete(user);</p>
<p>session.getTransaction().commit();</p>
<p>三种状态的转换 :</p>
<p><img src="" alt=""></p>
<p><strong>load和get方法</strong></p>
<p>相同点：</p>
<p>   get和load方法都是利用对象的主键值获取相应的对象，并可以使对</p>
<p>象处于持久状态。</p>
<p>不同点：</p>
<p>   load方法获取对象时不会立即执行查询操作，而是在第一次使用对象</p>
<p>是再去执行查询操作。如果查询的对象在数据库中不存在，load方法</p>
<p>返回值不会为null，在第一次使用时抛出</p>
<p>org.hibernate.ObjectNotFoundException异常。</p>
<p>   使用get方法获取对象时会立即执行查询操作，并且对象在数据库中</p>
<p>不存在时返回null值。</p>
<p><strong>save和persist方法</strong></p>
<p>相同点：</p>
<p>save和persist方法都是将持久化对象保存到数据库中</p>
<p>区别：</p>
<p>sava方法成功执行后，返回持久化对象的ID</p>
<p>persist方法成功执行后，不会返回持久化对象的ID，persist方法是</p>
<p>JPA中推荐使用的方法  </p>
<p><strong>save和update方法</strong></p>
<p>save方法是将自由态的对象迚行保存。</p>
<p>update方法是将游离态的对象迚行保存。</p>
<p>update和saveOrUpdate方法</p>
<p>   如果一个对象是游离态戒持久态，对其执行update方法后会将对象</p>
<p>的修改同步到数据库中，如果该对象是自由态，则执行update方法</p>
<p>是没有作用的。</p>
<p>   在执行saveOrUpdate方法时该方法会自动判断对象的状态，如果为</p>
<p>自由态则执行save操作，如果为游离态戒持久态则执行update操作。</p>
<p><strong>update和merge方法</strong></p>
<p>   如果持久化对象在数据库中存在，使用merge操作时迚行同步操作。</p>
<p>如果对象在数据库不存在，merge对象则迚行保存操作。</p>
<p>   如果对象是游离状态，经过update操作后，对象转换为持久态。但</p>
<p>是经过merge操作后，对象状态依然是游离态。</p>
<p><strong>saveOrUpdate和merge方法</strong></p>
<p>saveOrUpdate方法和merge方法的区别在于如果session中存在两</p>
<p>个主键值相同的对象，迚行saveOrUpdate操作时会有异常抛出。这</p>
<p>时必须使用merge迚行操作。</p>
<p>session.beginTransaction();</p>
<p>User user = new User();</p>
<p>user.setId(3);</p>
<p>user.setUserName(&quot;aaaaaaaa&quot;);</p>
<p>user.setUserPwd(&quot;123123&quot;);</p>
<p>User user2 = (User) session.get(User.class, 3);</p>
<p>session.saveOrUpdate(user);//ERROR</p>
<p>session.getTransaction().commit();</p>
<p>clear方法和flush方法</p>
<p>clear方法是将Session中对象全部清除，当前在Session中的对象由</p>
<p>持久态转换为游离态。flush方法则是将持久态对象的更改同步到数据</p>
<p>库中。</p>
<p>session.beginTransaction();</p>
<p>User user = (User) session.get(User.class, 3);</p>
<p>user.setPassword(&quot;111&quot;);</p>
<p>session.flush();  </p>
<p>session.getTransaction().commit();</p>
<p><strong>2.Hibernate查询</strong></p>
<p><strong>2.1 HQL</strong></p>
<p>   HQL（Hibernate Query Language）提供了丰富灵活的查询方式，</p>
<p>使用HQL进行查询也是Hibernate官方推荐使用的查询方式。</p>
<p>   HQL在语法结构上和SQL语句十分的相同，所以可以很快的上手进行</p>
<p>使用。使用HQL需要用到Hibernate中的Query对象，该对象丏门执</p>
<p>行HQL方式的操作。</p>
<p><strong>1.查询所有</strong></p>
<p>session.beginTransaction();</p>
<p>String hql = &quot;from User&quot;;</p>
<p>Query query = session.createQuery(hql);</p>
<p>List<User> userList = query.list();</p>
<p>for(User user:userList){</p>
<p> System.out.println(user.getUserName());</p>
<p>}</p>
<p>session.getTransaction().commit();</p>
<p><strong>2.where</strong></p>
<p>session.beginTransaction();</p>
<p>String hql = &quot;from User where userName = &#39;James&#39;&quot;;</p>
<p>Query query = session.createQuery(hql);</p>
<p>List<User> userList = query.list();</p>
<p>for(User user:userList){</p>
<p> System.out.println(user.getUserName());</p>
<p>}</p>
<p>session.getTransaction().commit();</p>
<p>在HQL中where语句中使用的是持久化对象的属性名，比如上面示例</p>
<p>中的userName。当然在HQL中也可以使用别名：</p>
<p>String hql = &quot;from User as u where u.userName = &#39;James&#39;&quot;;</p>
<p><strong>3.过滤条件</strong></p>
<p>在where语句中还可以使用各种过滤条件，如：=、&lt;&gt;、&lt;、&gt;、&gt;=</p>
<p>、&lt;=、between、not between、in、not in、is、like、and、or</p>
<p>等。</p>
<p>– from Student where age &gt; 20;</p>
<p>– from Student where age between 20 and 30;</p>
<p>– from Student where name is null;</p>
<p>– from Student where name like ‘小%’;</p>
<p>– from Student where name like ‘小%’ and age &lt; 30</p>
<p><strong>4.获取一个不完整对象</strong></p>
<p><strong>一列：</strong></p>
<p>session.beginTransaction();</p>
<p>String hql = &quot;select userName from User&quot;</p>
<p>Query query = session.createQuery(hql);</p>
<p>List nameList = query.list();</p>
<p>for(Object obj:nameList){</p>
<p> System.out.println(obj);</p>
<p>}</p>
<p>session.getTransaction().commit();</p>
<p><strong>5.两列或多列：</strong></p>
<p>session.beginTransaction();</p>
<p>String hql = &quot;select userName,userPwd from User&quot;;</p>
<p>Query query = session.createQuery(hql);</p>
<p>List nameList = query.list();</p>
<p>for(Object obj:nameList){</p>
<p>Object[] array = (Object[]) obj;</p>
<p>System.out.println(&quot;name:&quot; + array[0]);</p>
<p>System.out.println(&quot;pwd:&quot; + array[1]);</p>
<p>}</p>
<p>session.getTransaction().commit();</p>
<p><strong>6.统计和分组查询</strong></p>
<p>session.beginTransaction();</p>
<p>String hql = &quot;select count(/*),max(id) from User&quot;;</p>
<p>Query query = session.createQuery(hql);</p>
<p>List nameList = query.list();</p>
<p>for(Object obj:nameList){</p>
<p>Object[] array = (Object[]) obj;</p>
<p>System.out.println(&quot;count:&quot; + array[0]);</p>
<p>System.out.println(&quot;max:&quot; + array[1]);</p>
<p>}</p>
<p>session.getTransaction().commit();</p>
<p><strong>7.更多写法…</strong></p>
<p>消除重复： select distinct name from Student;</p>
<p>最大： select max(age) from Student;</p>
<p>行数： select count(age),age from Student group by age;</p>
<p>排序： from Student order by age;</p>
<p><strong>HQL占位符</strong></p>
<p>session.beginTransaction();</p>
<p>String hql = &quot;from User where userName = ?&quot;;</p>
<p>Query query = session.createQuery(hql);</p>
<p>query.setString(0, &quot;James&quot;);</p>
<p>List<User> userList = query.list();</p>
<p>for(User user:userList){</p>
<p> System.out.println(user.getUserName());</p>
<p>}</p>
<p>session.getTransaction().commit();</p>
<p><strong>HQL引用占位符</strong></p>
<p>session.beginTransaction();</p>
<p>String hql = &quot;from User where userName = :name&quot;;</p>
<p>Query query = session.createQuery(hql);</p>
<p>query.setParameter(&quot;name&quot;, &quot;James&quot;);</p>
<p>List<User> userList = query.list();</p>
<p>for(User user:userList){</p>
<p> System.out.println(user.getUserName());</p>
<p>}</p>
<p>session.getTransaction().commit();</p>
<p><strong>HQL分页</strong></p>
<p>session.beginTransaction();</p>
<p>String hql = &quot;from User&quot;;</p>
<p>Query query = session.createQuery(hql);</p>
<p><strong>query.setFirstResult(0);</strong></p>
<p><strong>query.setMaxResults(2);</strong></p>
<p>List<User> userList = query.list();</p>
<p>for(User user:userList){</p>
<p> System.out.println(user.getUserName());</p>
<p>}</p>
<p>session.getTransaction().commit();</p>
<p><strong>3.Criteria查询</strong></p>
<p>   Criteria对象提供了一种面向对象的方式查询数据库。Criteria对象需</p>
<p>要使用Session对象来获得。</p>
<p>一个Criteria对象表示对一个持久化类的查询。</p>
<p><strong>1.查询所有</strong></p>
<p>session.beginTransaction();</p>
<p>Criteria c = session.createCriteria(User.class);</p>
<p>List<User> userList = c.list();</p>
<p>for(User user:userList){</p>
<p> System.out.println(user.getUserName());</p>
<p>}</p>
<p>session.getTransaction().commit();</p>
<p><strong>2.Where</strong></p>
<p>session.beginTransaction();</p>
<p>Criteria c = session.createCriteria(User.class);</p>
<p>c.add(Restrictions.eq(&quot;userName&quot;, &quot;James&quot;));</p>
<p>List<User> userList = c.list();</p>
<p>for(User user:userList){</p>
<p> System.out.println(user.getUserName());</p>
<p>}</p>
<p>session.getTransaction().commit();</p>
<p><strong>3.Restrictions对象</strong></p>
<p><img src="" alt=""></p>
<p><strong>where...and .... 语句</strong></p>
<p>session.beginTransaction();</p>
<p><strong>Criteria c = session.createCriteria(User.class)</strong></p>
<p><strong>c.add(Restrictions.like(&quot;userName&quot;, &quot;J&quot;));</strong></p>
<p><strong>c.add(Restrictions.eq(&quot;id&quot;, 120));</strong></p>
<p>List<User> userList = c.list();</p>
<p>for(User user:userList){</p>
<p> System.out.println(user.getUserName());</p>
<p>}</p>
<p>session.getTransaction().commit();</p>
<p><strong>where...or .... 语句</strong></p>
<p>session.beginTransaction();</p>
<p>Criteria c = session.createCriteria(User.class);</p>
<p><strong>c.add(Restrictions.or(Restrictions.eq(&quot;userName&quot;, &quot;James&quot;),</strong></p>
<p><strong> Restrictions.eq(&quot;userName&quot;, &quot;Alex&quot;)));</strong></p>
<p>List<User> userList = c.list();</p>
<p>for(User user:userList){</p>
<p>System.out.println(user.getUserName());</p>
<p>}</p>
<p>session.getTransaction().commit();</p>
<p><strong>获取唯一的记录</strong></p>
<p>session.beginTransaction();</p>
<p>Criteria c = session.createCriteria(User.class);</p>
<p>c.add(Restrictions.eq(&quot;id&quot;, 120));</p>
<p>User user = (User) c.uniqueResult();</p>
<p>System.out.println(user.getUserName());</p>
<p>session.getTransaction().commit();</p>
<p><strong>分页</strong></p>
<p>session.beginTransaction();</p>
<p>Criteria c = session.createCriteria(User.class);</p>
<p>c.setFirstResult(0);</p>
<p>c.setMaxResults(5);</p>
<p>List<User> userList = c.list();</p>
<p>for(User user:userList){</p>
<p> System.out.println(user.getUserName());</p>
<p>}</p>
<p>session.getTransaction().commit();</p>
<p><strong>分组与统计</strong></p>
<p>session.beginTransaction();</p>
<p>Criteria c = session.createCriteria(User.class);</p>
<p>c.setProjection(Projections.sum(&quot;id&quot;));</p>
<p>Object obj = c.uniqueResult();</p>
<p>System.out.println(obj);</p>
<p>session.getTransaction().commit();</p>
<p>Projections对象</p>
<p><img src="" alt=""></p>
<p><strong>多个统计与分组</strong></p>
<p>session.beginTransaction();</p>
<p>Criteria c = session.createCriteria(User.class);</p>
<p><strong>ProjectionList projectionList = Projections.projectionList();</strong></p>
<p><strong>projectionList.add(Projections.sum(&quot;id&quot;));</strong></p>
<p><strong>projectionList.add(Projections.min(&quot;id&quot;));</strong></p>
<p><strong>c.setProjection(projectionList);</strong></p>
<p>Object[] obj = (Object[]) c.uniqueResult();</p>
<p>System.out.println(&quot;sum:&quot; + obj[0]);</p>
<p>System.out.println(&quot;min:&quot; + obj[1]);</p>
<p>session.getTransaction().commit();</p>
<p><strong>排序</strong></p>
<p>session.beginTransaction();</p>
<p>Criteria c = session.createCriteria(User.class);</p>
<p><strong>c.addOrder(Order.desc(&quot;id&quot;));</strong></p>
<p>List<User> list = c.list();</p>
<p>for(User user : list){</p>
<p> System.out.println(user.getUserName());</p>
<p>}</p>
<p>session.getTransaction().commit();</p>
<p><strong>4.使用原生SQL查询</strong></p>
<p><strong>1.查询出后必须封装才可以用：</strong></p>
<p>session.beginTransaction();</p>
<p>String sql = &quot;select id,username,userpwd from t_user&quot;;</p>
<p>List list = session.createSQLQuery(sql).list();</p>
<p>for(Object item : list){</p>
<p>Object[] rows = (Object[]) item;</p>
<p>System.out.println(&quot;id:&quot; + rows[0] + &quot;username:&quot;  </p>
<ul>
<li>rows[1] + &quot;userpwd:&quot; + rows[2]);</li>
</ul>
<p>}</p>
<p>session.getTransaction().commit();</p>
<p><strong>2.查询出一个集合可以直接用对象操作：</strong></p>
<p>session.beginTransaction();</p>
<p>String sql = &quot;select id,username,userpwd from t_user&quot;;</p>
<p>SQLQuery query = session.createSQLQuery(sql).addEntity(User.class);</p>
<p>List<User> list = query.list();</p>
<p>for(User user : list){</p>
<p> System.out.println(user.getUserName());</p>
<p>}</p>
<p>session.getTransaction().commit();</p>
<p><strong>3.查询出一个对象可以直接用对象操作</strong>：</p>
<p>session.beginTransaction();</p>
<p>String sql = &quot;select id,username,userpwd from t_user where id = 2&quot;;</p>
<p>SQLQuery query = session.createSQLQuery(sql).addEntity(User.class);</p>
<p>User user = (User) query.uniqueResult();</p>
<p>System.out.println(user.getUserName());</p>
<p>session.getTransaction().commit();</p>
<p><a href="http://libooy.diandian.com/?tag=hibernate" title="hibernate" target="_blank">hibernate</a>
<a href="">喜欢</a> <a href="">热度 (4)</a></p>
<p><a href="">分享</a></p>
<p><a href=""></a>
<a href="http://libooy.diandian.com/" target="_blank">返回首页</a></p>
<p><a href=""></a>
<a href="http://libooy.diandian.com/post/2012-03-28/14606048" target="_blank">上一篇</a></p>
<p><a href="http://libooy.diandian.com/post/2012-03-26/18813130" target="_blank">下一篇</a></p>
<h3 id="-"><a href="&quot;关于&quot;">关于</a></h3>
<p>一天进步一点点！！！</p>
<h3 id="-">导航</h3>
<ul>
<li><a href="http://libooy.diandian.com/rss" target="_blank">RSS订阅</a></li>
<li><a href="http://libooy.diandian.com/random" target="_blank">随机文章</a></li>
<li><a href="http://libooy.diandian.com/archive" target="_blank">存档</a></li>
<li><a href="http://libooy.diandian.com/inbox" title="私信" target="_blank">私信</a></li>
<li><p><a href="http://libooy.diandian.com/submit" title="投稿" target="_blank">投稿</a></p>
<h3 id="-">页面</h3>
</li>
<li><p><a href="http://libooy.diandian.com/" target="_blank">首页</a></p>
</li>
<li><p>© <a href="http://libooy.diandian.com/" title="Li-boy 奋斗的蜗牛" target="_blank">Li-boy 奋斗的蜗牛</a></p>
</li>
<li>Powered by <a href="http://www.diandian.com/" title="点点网" target="_blank">点点</a></li>
<li>Themed by <a href="http://www.yiyifly.com/" title="舟遥遥以轻飏,风飘飘而吹衣" target="_blank">吹衣轻飏</a></li>
</ul>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/框架汇总/">框架汇总</a></li></span><span class="breadcrumb"><li><a href="/categories/框架汇总/">框架汇总</a></li><li><a href="/categories/框架汇总/ORM/">ORM</a></li><li><a href="/categories/框架汇总/ORM/hibernate/">hibernate</a></li></span></span> | <span class="tags">Tagged <a href="/tags/ORM/" class="label label-primary">ORM</a><a href="/tags/hibernate/" class="label label-success">hibernate</a><a href="/tags/框架汇总/" class="label label-info">框架汇总</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:29"datetime="2014-03-07 09:54:29"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-框架汇总-ORM-hibernate--Hibernate知识总结/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-框架汇总-ORM-hibernate--Hibernate知识总结" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>





<ul id="pagination" class="pagination pagination-lg">
  <li><a class="extend prev" href="/page/146/">&laquo;</a></li><li><a class="page-number" href="/">1</a></li><li><a class="page-number" href="/page/2/">2</a></li><li><span class="space">&hellip;</span></li><li><a class="page-number" href="/page/144/">144</a></li><li><a class="page-number" href="/page/145/">145</a></li><li><a class="page-number" href="/page/146/">146</a></li><li class="active"><li><span class="page-number current">147</span></li><li><a class="page-number" href="/page/148/">148</a></li><li><a class="page-number" href="/page/149/">149</a></li><li><a class="page-number" href="/page/150/">150</a></li><li><span class="space">&hellip;</span></li></li><li><a class="page-number" href="/page/164/">164</a></li><li><a class="page-number" href="/page/165/">165</a></li><li><a class="extend next" href="/page/148/">&raquo;</a></li>
  <div class="clearfix"></div>
</ul></div><!--wapper-->
       </div><!-- ID main-col END -->
       <aside id="sidebar" class="alignright col-sx-6 col-sm-4 col-md-3 col-lg-3">
<div id="widget_search" class="widget panel panel-primary">
    <form action="//google.com/search" method="get" accept-charset="utf-8">
  <div class="input-group">
    <input class="form-control" id="searchbox" type="search" name="q" results="0" placeholder="search">
    <span class="input-group-btn">
      <button class="btn btn-default" type="submit">Go!</button>
    </span>
    <input type="hidden" name="q" value="site:itsolife.com">
  </div>
</form>
</div>

<div id="widget_category" class="widget panel panel-primary">
  <div class="panel-heading">category</div>  <div data-src='category' class='ajax_widgets'>正在加载...</div>
</div>

<div id="widget_recent_posts" class="widget panel panel-primary">
  <div class="panel-heading">recent posts</div>  <div data-src='recent_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_tagcloud" class="widget panel panel-primary">
  <div class="panel-heading">tagcloud</div>  <div data-src='tagcloud' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_latest_update_posts" class="widget panel panel-primary">
  <div class="panel-heading">最近更新</div>  <div data-src='latest_update_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_recent_comments" class="widget panel panel-primary">
  <div class="panel-heading">recent comments</div>  

<div class="list-group-item ds-recent-comments" data-num-items="6" data-show-avatars="1" data-show-time="1" data-show-title="1" data-show-admin="1" data-excerpt-length="50"></div>



</div>

</aside>
       <div class="clearfix"></div>
     </div><!-- row END -->
  </div>
  <footer id="footer" class="container">
  <div class="panel panel-info">
  <section id='footer_widget'></section>  <div class="panel-footer">
  <div id="site-info">
    <span class='author'>
  
  &copy; 2014 RobinChia
  
    &nbsp;&nbsp;</span>
  
  <span id='analytics-51la'></span><span id='analytics-google'>
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-48559895-1']);
  _gaq.push(['_trackPageview']);
  _js2load.push({src:('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'});
</script></span><span id='analytics-cnzz'>
<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_5774006'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s17.cnzz.com/stat.php%3Fid%3D5774006%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>
</span><span id='analytics-baidu'>
<script>
var _hmt = _hmt || [];
_js2load.push({src:"//hm.baidu.com/hm.js?1442f50724afc42380b51f097c43082c"});
</script>
</span>  </div>
  <div id="copyright">Blog powered by <a href='http://zespia.tw/hexo/'><strong>hexo</strong></a> Theme <strong><a href='https://github.com/chenall/hexo-theme-chenall'>chenall</a></strong>(Some change in it)<span class="pull-right"> 更新时间: <em>2014-03-15 16:55:37</em></span></div>
</div>
<div class="clearfix"></div>


  </div>
  </footer>
  
        <script src="http://cdn.bootcss.com/jquery/1.10.2/jquery.min.js"></script>        
        <script src="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/js/bootstrap.min.js"></script>        
                
        <script src="http://cdn.bootcss.com/prettify/r298/prettify.min.js"></script>    <script type="text/javascript">
   var lang=["bsh", "c", "cc", "cpp", "cs", "csh", "cyc", "cv", "htm", "html",
    "java", "js", "m", "mxml", "perl", "pl", "pm", "py", "rb", "sh",
    "xhtml", "xml", "xsl"];
   var pretty_base='';
   $('script').each(function(){
	var c = $(this).attr('src');
	if (!c)
	    return;
	if (c.match(/(\/)?prettify(\.min)?\.js/i))
	{
	    var index = c.lastIndexOf('/');
	    if (index != -1)
		pretty_base = c.substr(0,index + 1);
	    return false;
	}
   })
   $('pre code').each(function(){
	var c = $(this).attr('class')
	if (!c)
	    return;
	c = c.match(/\s?(lang\-\w+)/i);
	if (c && lang.indexOf(c[1]) == -1)
	{
	    lang.push(c[1]);
	    $.getScript(pretty_base + c[1] + '.min.js');
	}
   })

    $(window).load(function(){
       $("pre").addClass("prettyprint");
       prettyPrint();
    })
</script>    
            <script type="text/javascript">
var duoshuoQuery = {short_name:"robinchia"};
_js2load.push({src:'http://static.duoshuo.com/embed.js',charset:'UTF-8'});
</script>
    
            <!--wumii_relatedItems-->
    
        <script src="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js"></script>    <script type="text/javascript">
(function($){
  $('.entry').each(function(i){
    $(this).find('img').each(function(){
      var alt = this.alt;

      if (alt){
        $(this).before('<span class="caption">' + alt + '</span>');
      }

      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox" rel="fancybox' + i + '" />');
    });
  });

  $('.fancybox').fancybox();
})(jQuery);
</script>    
        <script src="http://cdn.bootcss.com/mathjax/2.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>    <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>
    
<script type="text/javascript">
$('.ajax_widgets').each(function(){var src=$(this).attr('data-src');if(src)$(this).load('/widgets/'+src+'.html');});
$.each(_js2load,function(index,obj){loadjs(obj.src,obj.charset)});
</script>

<div id="scroll2top">
<img src="/scroll2top/arrow.png"/>
</div>
<script src="/scroll2top/scroll2top.min.js"></script>
<div id="winterland">
  <canvas></canvas>
</div>
<script src="/js/winterland.min.js"></script>

  </body>
</html>
