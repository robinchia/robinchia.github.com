
<!DOCTYPE HTML>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>The 147 Page | It so life</title>
<meta name="author" content="RobinChia">

<meta name="description" content="It so life">


<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<meta property="og:site_name" content="It so life"/>

<!--[if IE]><style>.testIE.IE{display:inline;}</style><![endif]-->
<!--[if lte IE 7]><link rel="stylesheet" href="/css/ie7.css" type="text/css"><![endif]-->
<!--[if (lt IE 9)&(gt IE 7)]><style>.testIE.IE8{display:inline;}</style><![endif]-->
<!--[if gt IE 8]><style>.testIE.IE9{display:inline;}</style><![endif]-->

<link href="/favicon.png" rel="icon">
<link rel="alternate" href="/atom.xml" title="It so life Feed" type="application/atom+xml">

<link rel="stylesheet" href="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/css/bootstrap.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/font-awesome/4.0.3/css/font-awesome.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/prettify/r298/prettify.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" type="text/css">
<link rel="stylesheet" href="/css/style.css" type="text/css">
<!--[if lt IE 9]>
   <style>article,aside,dialog,footer,header,section,footer,nav,figure,menu{display:block}</style>
   <script src="http://cdn.staticfile.org/html5shiv/r29/html5.min.js"></script>
   <script src="http://cdn.staticfile.org/respond.js/1.4.2/respond.min.js"></script>
<link href="http://cdn.staticfile.org/respond.js/1.4.2/respond-proxy.html" id="respond-proxy" rel="respond-proxy" />
<link href="/js/respond.proxy.gif" id="respond-redirect" rel="respond-redirect" />
<script src="/js/respond.proxy.js"></script>
   <script src="http://cdn.bootcss.com/selectivizr/1.0.2/selectivizr-min.js"></script>
<![endif]-->
<script type="text/javascript">
function loadjs(c,d){var a=document.createElement("script");a.async=!0;a.type="text/javascript";a.src=c;a.charset=d||"gbk";(document.getElementsByTagName("HEAD")[0]||document.getElementsByTagName("BODY")[0]).appendChild(a)};
var _protocol = (("https:" == document.location.protocol) ? " https://" : " http://");
var _js2load = [];
</script>

</head>
<body>
      <header id="header" class="container"><nav id="main-nav" class="navbar navbar-default navbar-fixed-top " role="navigation">
  <div class="container">
    <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
      <span class="sr-only">Toggle navigation</span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="/">It so life</a>
    </div>
    <div  class="collapse navbar-collapse">
      <ul  class="nav navbar-nav">
  
        <li><a href="/" title="Home">Home</a></li>      
        <li><a href="/about/" title="About">About</a></li>      
        <li><a href="/archives/" title="Archives">Archives</a></li>      
      <li class='dropdown'>
        <a class='dropdown-toggle' data-toggle='dropdown' href='#'>website<b class='caret'></b></a>
        <ul class='dropdown-menu pure-menu-selected'>
    
          <li><a href="//groups.google.com/forum/#!forum/pongba" title="TopLanguage">TopLanguage</a></li>    
          <li><a href="//itpub.net/" title="ITPub">ITPub</a></li>    
          <li><a href="//blog.jobbole.com/" title="Bole">Bole</a></li>    
          <li><a href="//nosql-database.org/" title="nosql">nosql</a></li>    
          <li><a href="//gitimmersion.googol.im/" title="Git">Git</a></li>    
        </ul>
      </li>
    
      </ul>
      <ul class="nav navbar-nav navbar-right">
      
        <li><a href="/atom.xml">RSS</a></li>
      
      
        <li><a href="https://twitter.com/robinchia">twitter</a></li>
      
      
      
      
        <li><a href="https://github.com/robinchia">github</a></li>
      
      </ul>
    </div>
  </div>
</nav>
<div class="clearfix"></div>
</header>
  <div id='content' class="container">
     <div class="page-header-wrapper">
      <!--[if lt IE 9]><div class="alert alert-warning alert-dismissable"><button type="button" class="close" data-dismiss="alert" aria-hidden="true">&times;</button><strong>提示:</strong>您的浏览器版本太低了,建议升级到 <strong><a href="http://windows.microsoft.com/zh-cn/internet-explorer/download-ie" title="IE9">IE9</a></strong> 以上,本站使用<a href="https://www.google.com/intl/zh-CN/chrome/">Chrome浏览器</a>可以获得最好的显示效果.</div><![endif]-->
      <div class="page-header"><h1 align="center"><big>It so life</big> </h1>
        <h5 align="center"><big>love as life</big></h5>
      </div>
     </div>
     <div class="row">
       <div id="main-col" class="alignleft col-sx-12 col-sm-8 col-md-9 col-lg-9">
      <section id='header_widget'></section>
          <div id="wrapper"><article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-框架汇总-activemq--activemq的网络层介绍/">activemq的网络层介绍</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:29.000Z"> <a href="/2014/02/02/2014-02-02-框架汇总-activemq--activemq的网络层介绍/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="activemq-">activemq的网络层介绍</h1>
<p>#</p>
<h3 id="-">概要</h3>
<p>activemq是一个apache的顶级项目，其实现了<a href="http://www.goldendoc.org/2011/08/jms_spec_message/" title="JMS规范介绍(1) JMS消息" target="_blank">JMS规范</a>，作为一个开源的JMS实现，activemq已经在很多地方得到了应用。同时，开源小组在研究JMS实现的时候，也选择了activemq作为研究对象，希望能够读其源码，让<a href="http://www.goldendoc.org/" title="开源学习小组：黄金档" target="_blank">开源小组</a>更好的明白JMS规范和实现。</p>
<p>在学习activemq的时候，我们发现还不能一下子就进去学习JMS规范的实现，而是需要了解其底层代码，包括其对网络连接的处理等等。所以，这篇文章就学习了<a href="http://www.goldendoc.org/2011/09/activemq-network-process/" title="activemq的网络层实现" target="_blank">activemq的网络层实现</a>。</p>
<h3 id="activemq-">activemq网络层概念</h3>
<p>activemq 是支持多协议的，因此，把单一协议的server抽象成更高一层，就很有意义，请看下面这张图：
<a href="http://www.goldendoc.org/wp-content/uploads/2011/09/activemq%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A51.png" target="_blank"><img src="" alt=""></a></p>
<p>在activemq中，差不多每种概念都有生命周期（见Service接口）。
这张图十分简单，实际中当然比这个要复杂。下面针对每个概念进行叙述。</p>
<h3 id="transport">Transport</h3>
<p>Transport 应该算是很底层的概念，他封装了 Socket，职责是发送和接受连接方的信息。
同时，在Transport中，增加了同步和异步的概念。
Transport拥有一个TransportListener。</p>
<h3 id="transportlistener">TransportListener</h3>
<p>顾名思义，TransportListener 就是监听 Transport 事件的发生以及做出一定的反映。
在activemq中，正是利用了 TransportListener 对 Command 进行处理 —— Command 是 activemq 网络传递的形式，每个请求都会被反序列化成一个 Command。</p>
<h3 id="transportserver">TransportServer</h3>
<p>就是一个server实例，他会处理外部进来的Socket，进而封装成 Transport 。此 Server 拥有一个 TransportAcceptListener 。</p>
<h3 id="transportacceptlistener">TransportAcceptListener</h3>
<p>负责 Accept Transport，将 Transport 封装成 Connection，从而开启 Connection 的生命周期。
这里需要注意的是：TransportServer 将 Socket 封装成 Transport，而 TransportAcceptListener 将 Transport 封装成 Connection。</p>
<h3 id="connection">Connection</h3>
<p>可以理解成业务层面上的连接。 Connection 会给相应的 Transport 设置 TransportListener ，从而获取底层 Socket 的活动情况，进行业务的处理。</p>
<h3 id="connector">Connector</h3>
<p>Connector就是较高层次的抽象，它代表对外的连接器，每个连接器都可以支持不同的协议。
Connector 通过给 TransportServer 设置 TransportAcceptListener ，从而能够控制 Transport 并产生相应的 Connection。</p>
<h3 id="-">总结</h3>
<p>总体来说，两个Listener是连接 Conncetor与TransportServer 和 Connection和Transport 的关键概念。
至于为什么要分成 Connector ， TransportServer 这两层，我想原因应该就是开头提到的： activemq需要支持多协议，因此 Connector 抽象起来，可以当作是针对不同协议的统一行为；而 TransportServer 就是针对各协议的具体实现。 对于 Connection,Transport 来说， Connector 是与 Connection 统一层次， Transport 是与 TransportServer 统一层次。
如果读者有时间，还可以查看<a href="http://www.goldendoc.org/" title="开源小组" target="_blank">开源小组</a>当时分析的<a href="http://www.goldendoc.org/wp-content/uploads/2011/09/activemq%E7%BD%91%E7%BB%9C%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.png" target="_blank">activemq网络连接序列图</a>（是基于TcpTransportServer的，图像有点大，需要耐心看）</p>
<p><img src="" alt="">
来源： <a href="[http://www.goldendoc.org/2011/09/activemq-network-process/](http://www.goldendoc.org/2011/09/activemq-network-process/)">[http://www.goldendoc.org/2011/09/activemq-network-process/](http://www.goldendoc.org/2011/09/activemq-network-process/)</a></p>
<p>本文会把主要篇幅集中在这几个组件的创建时期，运行时期来讲解，最后会总结一下这几个组建使用的线程情况。一下的分析是基于 bio 的（nio 也是在这个结构当中，只是行为是基于 nio 特点的）。在<a href="http://www.goldendoc.org/2011/09/activemq-network-process/" title="activemq的网络层介绍（一）" target="_blank">activemq的网络层介绍（一）</a>也讲过，activemq中很多组件都实现了 Service 接口，而 Service 接口的作用就是赋予实现者有生命周期的意义。</p>
<h3 id="transportconnector">TransportConnector</h3>
<p>TransportConnector 是 Connector 的实现，是基于 Transport 的 Connector（目前activemq的Connector实现，也就是基于Transport的）。其内部依赖了 TransportServer ，这个也容易理解，因为这个 Connector 是基于 Transport 的。因此 TransportServer 也是其所重点依赖的组件。 值得注意的是 TransportServer 的 AcceptListener 也是在 TransportConnector 中指定的，具体见下文。</p>
<h3 id="transportconnector-">TransportConnector 的创建</h3>
<p>TransportConnector 的创建比较简单，直接接受传入进来的 TransportServer （关于 TransportServer 的创建，详见下文）。</p>
<h3 id="transportconnector-">TransportConnector 的运行</h3>
<p>TransportConnector 是一个 Service，有自己的生命周期。因此，在 activemq 开始的时候，其生命周期，会被启动（具体表现为被调用 start 方法）。</p>
<p>在 TransportConnector 的 start 方法中，可以很明显的看到两个主要的逻辑：为 TransportServer 设置一个匿名的 AcceptListener ，调用 TransportServer 启动。</p>
<p>对于 TransportConnector 为 TransportServer 设置的 AcceptListener，其逻辑主要是当 TransportServer 接收到传输进来的 Transport（由 TransportServer 将 Socket 封装成 Transport）之后，将 Transport 封装成 Connection ，并且启动 Connection 的生命周期。这里也不难理解：在<a href="http://www.goldendoc.org/2011/09/activemq-network-process/" title="activemq的网络层介绍（一）" target="_blank">activemq网络层介绍（一）</a>中也讲过， Connector 是与 Connection 一个层次的，TransportServer 与 Transport 是一个层次的。因此，将 AcceptListener 的匿名实现放在 TransportConnector 中，也就很好理解了。</p>
<h3 id="connection">Connection</h3>
<p>在 TransportServer 的 AcceptListener 收到传输进来的 Transport 之后，就创建了 Connection（实际类型是 TransportConnection），然后为 Connection 开启生命周期。
但一个Socket是从什么时候传进来，进而被封装成 Transport 的，会在下文有描述。现在让我们跟着 TransportConnection ，看看他是如何被创建的，以及在它的生命周期中，会做什么事情。</p>
<h3 id="transportconnection-">TransportConnection 的创建</h3>
<p>TransportConnection 是在 AcceptListener 收到 TransportServer 传进来的 Transport 之后创建的。可以想象，TransportConnection 是封装了 Transport 的。同时， Transport 的 TransportListener ，也是在 TransportConnection 的构造方法中进行了创建。此 TransportListener 的逻辑就是服务一个 Command (Command是 activemq 实例之间交互的基本对象，任何请求和响应都被activemq 序列化成一个 Command)，在得到响应的时候，进行分发（响应其实也是一个Command）。</p>
<h3 id="transportconnection-">TransportConnection 的运行</h3>
<p>在开始说 TransportConnection 的生命周期之前，可以先说一下 activemq 的 Task 接口，此接口有一个 iterate 遍历方法，activemq 一般对这个接口的用法都是使用一个线程去跑 iterater 方法，直到 iterater 返回 false 。一般的，iterater 方法里面都是在重复的做一段逻辑，只不过是这个逻辑实施的对象不一样而已。TransportConnection 正是实现了此接口。</p>
<p>在 TransportConnection 的 start 方法中，主要做了两件事情：创建一个 taskRunner ，以做好跑 Task 的准备（就是在另起线程跑自己的 Iiterater 方法）；调用 Transport 的 Start 方法，开启 Transport 的生命周期。</p>
<p>在 TransportConnection 自己的 Iiterater 方法中，就是到一个队列中取出 Command，并且使用 Transport 的 oneWay，将 Command 发送出去。</p>
<h3 id="transportserver">TransportServer</h3>
<p>按理说要接下来讲 Transport，但如果不先把 TransportServer 弄清出的话， Transport 还是有些难以理解的。因为是 TransportServer 将 接受到的 Socket 封装成 Transport。这里说的是 TransportServer 的实现， TcpTransportServer。</p>
<h3 id="tcptransportserver-">TcpTransportServer 的创建</h3>
<p>TransportServer 是由 TransportFactory 创建的。TransportFactory，不同的 TransportFactory 创建出不同的 TransportServer，而 TcpTransportServer 则是由 TcpTransportFactory 创建的。关于 TransportFactory 如何创建相应的 TransportServer，activemq使用了一套基于分析参数和配置文件来实现，说起来很高深，其实很朴实的，有兴趣也可以了解一下，这里不做深入。</p>
<h3 id="tcptransportserver-">TcpTransportServer 的运行</h3>
<p>这里主要使用 TcpTransportServer，TcpTransportServer 生命周期，是通过 TransportConnector 来开启的，这点在上面已经有所讲述。</p>
<p>这里要说一下 TransportServerThreadSupport，此类的作用是支持 TransportServer 能够开启另外一个线程，只要实现了 TransportServer Runnable，在 start 的时候，就能够开启另外一个线程，这也是 TransportServerThreadSupport 命令的含义。同样的机制也出现在 TransportThreadSupport 中。</p>
<p>现在来看一下 TcpTransportServer 的 start ：
TcpTransportServer 会开启两个线程，包括：</p>
<ol>
<li>实现了Runnable的线程，此线程的工作是不停的 accept 外部的 socket，然后将 socket 扔到一个队列中。简单来说，此线程是一个 acceptor。</li>
<li>另外一个线程的工作是，从队列中取出 socket ，并且将 WireFormat（ WireFormat 是在 activemq 中负责序列化和发序列化的组件） 和socket 封装成一个 Transport ，然后将创建好的 Transport 通知到 AcceptListener 中。</li>
</ol>
<h3 id="transport">Transport</h3>
<p>这里也主要讲 TcpTransport。</p>
<h3 id="tcptransport-">TcpTransport 的创建</h3>
<p>上面已经讲到，TcpTransport 是在 TcpTransportServer 中创建，并扔给了 AcceptListener 。并且，TcpTransport 也支持 TransportThreadSupport 的形式，可以另起一个线程。</p>
<h3 id="tcptransport-">TcpTransport 的运行</h3>
<p>TcpTransport 开始执行之后，专注于做两个事情：</p>
<ol>
<li>初始化 socket，并且把 socket 的流给设置起来。</li>
<li>另起一个线程，利用 wireFormat 将 socket 传过来的字节序列转化成一个 command ，然后将 Command 扔给 transportListener 。transportListener 所做的事情就是进行业务处理，然后将得到的 response （也是一个 command）通过 tcpTransport 的 oneway 传给对方。</li>
</ol>
<p>这样，这个网络通讯的过程就完成了。下面我们来总结一下 TcpTransportServer 的线程模型。</p>
<h3 id="tcptransportserver-">TcpTransportServer 的线程模型</h3>
<p>如图所示：
<a href="http://www.goldendoc.org/wp-content/uploads/2011/09/activemq%E6%A8%A1%E5%9E%8B.jpg" target="_blank"><img src="" alt="activemq网络线程模型"></a></p>
<p>activemq网络线程模型</p>
<h3 id="-">总结</h3>
<p>从上图中可以看出，accpetor 和 sockethandler 线程是在整个 transportServer 中的，而 ThreadPool 中的线程不会进行消息的发送，相反，当需要发送消息的时候，总是会创建新的线程去发送。这也是为了 ThreadPool 能将自己的线程利用率提高。因为这是 bio 的网络，如果消息的发送是利用线程池中的线程来发送的，那么很有可能线程池中的线程会在发送的时候阻塞，因为对方的网络不可预知。因此，新建一个新的线程，利用新建的线程发送消息，则是很明智的选择。
来源： <a href="[http://www.goldendoc.org/2011/09/activemq-network-process-2/](http://www.goldendoc.org/2011/09/activemq-network-process-2/)">[http://www.goldendoc.org/2011/09/activemq-network-process-2/](http://www.goldendoc.org/2011/09/activemq-network-process-2/)</a> </p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/框架汇总/">框架汇总</a></li></span><span class="breadcrumb"><li><a href="/categories/框架汇总/">框架汇总</a></li><li><a href="/categories/框架汇总/activemq/">activemq</a></li></span></span> | <span class="tags">Tagged <a href="/tags/activemq/" class="label label-primary">activemq</a><a href="/tags/框架汇总/" class="label label-success">框架汇总</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:29"datetime="2014-03-07 09:54:29"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-框架汇总-activemq--activemq的网络层介绍/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-框架汇总-activemq--activemq的网络层介绍" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-架构师--PODC-keynote/">PODC</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:29.000Z"> <a href="/2014/02/02/2014-02-02-架构师--PODC-keynote/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="podc-keynote">PODC-keynote</h1>
<p><img src="" alt=""> <img src="" alt=""> <img src="" alt=""> <img src="" alt=""> <img src="" alt=""> <img src="" alt=""> <img src="" alt=""> <img src="" alt=""> <img src="" alt=""> <img src="" alt=""> <img src="" alt=""> <img src="" alt=""> <img src="" alt=""> Inktomi at a Glance
Company Overview Applications
Search Technology Network Products Online Shopping Wireless Systems
Towards Robust Distributed Systems
Dr. Eric A. Brewer
Professor, UC Berkeley Co-Founder &amp; Chief Scientist, Inktomi CoPODC Keynote, July 19, 2000
“INKT” on NASDAQ Founded 1996 out of UC Berkeley ~700 Employees
PODC Keynote, July 19, 2000
Our Perspective
Inktomi builds two distributed systems:
– Global Search Engines – Distributed Web Caches
“Distributed Systems” don’t work...
There exist working DS:
– Simple protocols: DNS, WWW – Inktomi search, Content Delivery Networks – Napster, Verisign, AOL
Based on scalable cluster &amp; parallel computing technology But very little use of classic DS research...
PODC Keynote, July 19, 2000
But these are not classic DS:
– – – – Not distributed objects No RPC No modularity Complex ones are single owner (except phones)
PODC Keynote, July 19, 2000
1
<img src="" alt=""> <img src="" alt=""> <img src="" alt=""> <img src="" alt=""> <img src="" alt=""> Three Basic Issues
Where is the state? Consistency vs. Availability Understanding Boundaries
PODC Keynote, July 19, 2000
Where’s the state?
(not all locations are equal)
PODC Keynote, July 19, 2000
Santa Clara Cluster
Delivering High Availability
We kept up the service through: Crashes &amp; disk failures (weekly) Database upgrades (daily) Software upgrades (weekly to monthly) OS upgrades (twice) Power outage (several) Network outages (now have 11 connections) Physical move of all equipment (twice)
PODC Keynote, July 19, 2000 PODC Keynote, July 19, 2000
• Very uniform • No monitors • No people • No cables • Working power • Working A/C • Working BW
2
<img src="" alt=""> <img src="" alt=""> <img src="" alt=""> <img src="" alt=""> <img src="" alt=""> <img src="" alt=""> <img src="" alt=""> <img src="" alt=""> <img src="" alt=""> <img src="" alt=""> <img src="" alt=""> <img src="" alt=""> <img src="" alt=""> <img src="" alt=""> <img src="" alt=""> <img src="" alt=""> <img src="" alt=""> <img src="" alt=""> <img src="" alt=""> <img src="" alt=""> <img src="" alt=""> <img src="" alt=""> <img src="" alt=""> <img src="" alt=""> <img src="" alt=""> <img src="" alt=""> <img src="" alt=""> <img src="" alt=""> <img src="" alt=""> <img src="" alt=""> <img src="" alt=""> <img src="" alt=""> <img src="" alt=""> <img src="" alt=""> <img src="" alt=""> <img src="" alt=""> <img src="" alt=""> <img src="" alt=""> <img src="" alt=""> <img src="" alt=""> <img src="" alt=""> <img src="" alt=""> <img src="" alt=""> <img src="" alt=""> <img src="" alt=""> <img src="" alt=""> <img src="" alt=""> <img src="" alt=""> Berkeley Ninja Architecture Persistent State is HARD
Base: Scalable, highlyavailable platform for persistent-state services
Classic DS focus on the computation, not the data
– this is WRONG, computation is the easy part
Workstations &amp; PCs
Data centers exist for a reason
– can’t have consistency or availability without them AP
Internet
Other locations are for caching only:
– proxies, basestations, set-top boxes, desktops basestations, set– phones, PDAs, … PDAs,
Active Proxy: Bootstraps thin devices into infrastructure, runs mobile code
AP
Distributed systems can’t ignore location distinctions
Cellphones, Pagers, etc.
PODC Keynote, July 19, 2000
PDAs (e.g. IBM Workpad)
ACID vs. BASE
DBMS research is about ACID (mostly)
Consistency vs. Availability
(ACID vs. BASE)
But we forfeit “C” and “I” for availability, graceful degradation, and performance
This tradeoff is fundamental.
BASE: – Basically Available – Soft-state oft– Eventual consistency
PODC Keynote, July 19, 2000
PODC Keynote, July 19, 2000
3
<img src="" alt=""> <img src="" alt=""> <img src="" alt=""> <img src="" alt=""> ACID vs. BASE
ACID
Strong consistency Isolation Focus on “commit” Nested transactions Availability? Conservative (pessimistic) Difficult evolution (e.g. schema)
–
The CAP Theorem
BASE
Weak consistency
stale data OK
Availability first Best effort Approximate answers OK Aggressive (optimistic) Simpler! Faster Easier evolution Tolerance to network
Consistency
Availability
Partitions
But I think it’s a spectrum
PODC Keynote, July 19, 2000
Theorem: You can have at most two of these properties for any shared-data system
PODC Keynote, July 19, 2000
Forfeit Partitions
Examples Single-site databases SingleCluster databases
Forfeit Availability
Examples Distributed databases Distributed locking
Consistency
Availability
LDAP xFS file system Traits 2-phase commit cache validation protocols
PODC Keynote, July 19, 2000
Consistency
Availability
Majority protocols
Traits Tolerance to network
Tolerance to network
Partitions
Partitions
Pessimistic locking Make minority partitions unavailable
PODC Keynote, July 19, 2000
4
<img src="" alt=""> <img src="" alt=""> <img src="" alt=""> <img src="" alt=""> Forfeit Consistency
Examples Coda Web cachinge
These Tradeoffs are Real
The whole space is useful Real internet systems are a careful mixture of ACID and BASE subsystems
– We use ACID for user profiles and logging (for revenue) Traits
Consistency
Availability
DNS
But there is almost no work in this area Symptom of a deeper problem: systems and database communities are separate but overlapping (with distinct vocabulary)
PODC Keynote, July 19, 2000
Tolerance to network
expirations/leases conflict resolution optimistic
PODC Keynote, July 19, 2000
Partitions
CAP Take Homes
Can have consistency &amp; availability within a cluster (foundation of Ninja), but it is still hard in practice OS/Networking good at BASE/Availability, but terrible at consistency Databases better at C than Availability Wide-area databases can’t have both WideDisconnected clients can’t have both All systems are probabilistic…
PODC Keynote, July 19, 2000 PODC Keynote, July 19, 2000
Understanding Boundaries
(the RPC hangover)
5
<img src="" alt=""> <img src="" alt=""> <img src="" alt=""> <img src="" alt=""> The Boundary
The interface between two modules
– client/server, peers, libaries, etc… libaries,
Different Address Spaces
What if the two sides are NOT in the same address space?
– IPC or LRPC
Basic boundary = the procedure call
C S
Can’t do pass-by-reference (pointers) pass-by– Most IPC screws this up: pass by value-result value– There are TWO copies of args not one
– thread traverses the boundary – two sides are in the same address space
PODC Keynote, July 19, 2000
What if they share some memory?
– Can pass pointers, but… – Need synchronization between client/server – Not all pointers can be passed
PODC Keynote, July 19, 2000
Trust the other side?
What if we don’t trust the other side? Have to check args, no pointer passing args, Kernels get this right:
– copy/check args – use opaque references (e.g. File Descriptors)
Partial Failure
Can the two sides fail independently?
– RPC, IPC, LRPC
Can’t be transparent (like RPC) !! New exceptions (other side gone) Reclaim local resources
– e.g. kernels leak sockets over time =&gt; reboot
Most systems do not:
– TCP – Napster – web browsers
PODC Keynote, July 19, 2000
Can use leases?
– Different new exceptions: lease expired
RPC tries to hide these issues (but fails)
PODC Keynote, July 19, 2000
6
<img src="" alt=""> <img src="" alt=""> <img src="" alt=""> <img src="" alt=""> Multiplexing clients?
Boundary evolution?
Does the server have to:
– – – – – deal with high concurrency? Say “no” sometimes (graceful degradation) Treat clients equally (fairness) Bill for resources (and have audit trail) Isolate clients performance, data, ….
Can the two sides be updated independently? (NO) The DLL problem... Boundaries need versions Negotiation protocol for upgrade? Promises of backward compatibility? Affects naming too (version number)
These all affect the boundary definition
PODC Keynote, July 19, 2000
PODC Keynote, July 19, 2000
Example: protocols vs. APIs
Example: XML
Protocols have been more successful the APIs Some reasons:
– – – – protocols are pass by value protocols designed for partial failure not trying to look like local procedure calls explicit state machine, rather than call/return (this exposes exceptions well)
XML doesn’t solve any of these issues It is RPC with an extensible type system It makes evolution better?
– two sides need to agree on schema – can ignore stuff you don’t understand
Protocols still not good at trust, billing, evolution
PODC Keynote, July 19, 2000
Can mislead us to ignore the real issues
PODC Keynote, July 19, 2000
7
<img src="" alt=""> <img src="" alt=""> <img src="" alt=""> <img src="" alt=""> Boundary Summary
Conclusions
We have been very sloppy about boundaries Leads to fragile systems Root cause is false transparency: trying to look like local procedure calls Relatively little work in evolution, federation, client-based resource allocation, failure recovery client-
Classic Distributed Systems are fragile Some of the causes:
– – – – focus on computation, not data ignoring location distinctions poor definitions of consistency/availability goals poor understanding of boundaries (RPC in particular)
These are all fixable, but need to be far more common
PODC Keynote, July 19, 2000
PODC Keynote, July 19, 2000
The DQ Principle
Harvest &amp; Yield
Yield: Fraction of Answered Queries Yield:
Data/query /<em> Queries/sec = constant = DQ
– for a given node – for a given app/OS release
– Related to uptime but measured by queries, not by time – Drop 1 out of 10 connections =&gt; 90% yield – At full utilization: yield ~ capacity ~ Q
Harvest: Fraction of the Complete Result Harvest:
– Reflects that some of the data may be missing due to faults – Replication: maintain D under faults
A fault can reduce the capacity (Q), completeness (D) or both Faults reduce this constant linearly (at best)
DQ corollary: harvest /</em> yield ~ constant
– ACID =&gt; choose 100% harvest (reduce Q but 100% D) – Internet =&gt; choose 100% yield (available but reduced D)
PODC Keynote, July 19, 2000
PODC Keynote, July 19, 2000
8
<img src="" alt=""> <img src="" alt=""> <img src="" alt=""> <img src="" alt=""> Harvest Options
1) Ignore lost nodes
– RPC gives up – forfeit small part of the database – reduce D, keep Q
Replica Groups
With n members: Each fault reduces Q by 1/n 1/n D stable until nth fault Added load is 1/(n-1) per fault 1/(n
RAID RAID – n=2 =&gt; double load or 50% capacity – n=4 =&gt; 133% load or 75% capacity – “load redirection problem”
2) Pair up nodes
– RPC tries alternate – survives one fault per pair – reduce Q, keep D
3) n-member replica groups Decide when you care...
PODC Keynote, July 19, 2000
Disaster tolerance: better have &gt;3 mirrors
PODC Keynote, July 19, 2000
Graceful Degradation
Goal: smooth decrease in harvest/yield proportional to faults
– we know DQ drops linearly
Thinking Probabilistically
Maximize symmetry
– SPMD + simple replication schemes
Make faults independent
– – – – requires thought avoid cascading errors/faults understand redirected load KISS
Saturation will occur
– high peak/average ratios... – must reduce harvest or yield (or both) – must do admission control!!!
One answer: reduce D dynamically
– disaster =&gt; redirect load, then reduce D to compensate for extra load
PODC Keynote, July 19, 2000
Use randomness
– makes worst-case and average case the same worst– ex: Inktomi spreads data &amp; queries randomly – Node loss implies a random 1% harvest reduction
PODC Keynote, July 19, 2000
9
<img src="" alt=""> <img src="" alt=""> <img src="" alt=""> <img src="" alt=""> Server Pollution
Can’t fix all memory leaks Third-party software leaks memory and sockets Third– so does the OS sometimes
Evolution
Three Approaches: Flash Upgrade
– Fast reboot into new version – Focus on MTTR (&lt; 10 sec) – Reduces yield (and uptime)
Some failures tie up local resources Solution: planned periodic “bounce”
– Not worth the stress to do any better – Bounce time is less than 10 seconds – Nice to remove load first…
PODC Keynote, July 19, 2000
Rolling Upgrade
– Upgrade nodes one at time in a “wave” – Temporary 1/n harvest reduction, 100% yield – Requires co-existing versions co-
“Big Flip”
PODC Keynote, July 19, 2000
The Big Flip
Steps:
1) take down 1/2 the nodes 2) upgrade that half 3) flip the “active half” (site upgraded) 4) upgrade second half 5) return to 100%
Key New Problems
Unknown but large growth
– Incremental &amp; Absolute scalability – 1000’s of components
Must be truly highly available
– Hot swap everything (no recovery time allowed) – No “night” – Graceful degradation under faults &amp; saturation
50% Harvest, 100% Yield
– or inverse?
Constant evolution (internet time)
– Software will be buggy – Hardware will fail – These can’t be emergencies...
PODC Keynote, July 19, 2000
No mixed versions
– can replace schema, protocols, ...
Twice used to change physical location
PODC Keynote, July 19, 2000
10
<img src="" alt=""> <img src="" alt=""> <img src="" alt=""> <img src="" alt=""> Conclusions
Parallel Programming is very relevant, except…
– – – – historically avoids availability no notion of online evolution limited notions of graceful degradation (checkpointing) best for CPU-bound tasks CPU-
Conclusions
Winning solution is message-passing clusters message– fine-grain communication =&gt; finefine-grain exception handling fine– don’t want every load/store to deal with partial failure
Key open problems:
– – – – – – libraries &amp; data structures for HA shared state support for replication and partial failure better understanding of probabilistic systems cleaner support for exceptions (graceful degradation) support for split-phase I/O and many concurrent threads splitsupport for 10,000 threads/node (to avoid FSMs)
PODC Keynote, July 19, 2000
Must think probabilistically about everything
– – – – no such thing as a 100% working system no such thing as 100% fault tolerance partial results are often OK (and better than none) Capacity /* Completeness == Constant
PODC Keynote, July 19, 2000
New Hard Problems...
Really need to manage disks well
– problems are I/O bound, not CPU bound
Backup slides
Lots of simultaneous connections
– 50Kb/s =&gt; at least 2000 connections/node
HAS to be highly available
– no maintenance window, even for upgrades
Continuous evolution
– constant site changes, always small bugs... – large but unpredictable traffic growth
Graceful degradation under saturation
PODC Keynote, July 19, 2000 PODC Keynote, July 19, 2000
11
<img src="" alt=""> Parallel Disk I/O
Want 50+ outstanding reads/disk
– Provides disk-head scheduler with many choices disk– Trades response time for throughput
Pushes towards a split-phase approach to disks splitGeneral trend: each query is a finite-state machine finite– split-phase disk/network operations are state transitions split– multiplex many FSMs over small number of threads – FSM handles state rather than thread stack
PODC Keynote, July 19, 2000
12</p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/架构师/">架构师</a></li></span></span> | <span class="tags">Tagged <a href="/tags/架构师/" class="label label-primary">架构师</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:29"datetime="2014-03-07 09:54:29"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-架构师--PODC-keynote/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-架构师--PODC-keynote" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-框架汇总-ORM-ibatis--对ibatis分页功能的改进/">对ibatis分页功能的改进</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:29.000Z"> <a href="/2014/02/02/2014-02-02-框架汇总-ORM-ibatis--对ibatis分页功能的改进/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-ibatis-">对ibatis分页功能的改进</h1>
<p><strong>对ibatis**</strong>分页功能的改进**</p>
<p>2008-05-26 14:45
今天无意间看到了一篇关于这方面的文章，觉得是网上改进ibatis分页方面比较好的文章，这里转摘一下，希望能让更多的人用的到，也希望别人能把更好的解决方案贡献出来！</p>
<p>使ibatis支持hibernate式的物理分页</p>
<p>一直以来ibatis的分页都是通过滚动ResultSet实现的，应该算是逻辑分页吧。逻辑分页虽然能很干净地独立于特定数据库，但效率在多数情 况下不及特定数据库支持的物理分页，而hibernate的分页则是直接组装sql，充分利用了特定数据库的分页机制，效率相对较高。本文讲述的就是如何 在不重新编译ibatis源码的前提下，为ibatis引入hibernate式的物理分页机制。</p>
<p>基本思路就是找到ibatis执行sql的地方，截获sql并重新组装sql。通过分析ibatis源码知道，最终负责执行sql的类是 com.ibatis.sqlmap.engine.execution.SqlExecutor，此类没有实现任何接口，这多少有点遗憾，因为接口是相 对稳定契约，非大的版本更新，接口一般是不会变的，而类就相对易变一些，所以这里的代码只能保证对当前版本（2.1.7）的ibatis有效。下面是 SqlExecutor执行查询的方法：</p>
<p>  //<em>/</em>
    /<em> Long form of the method to execute a query
    /</em>
    /<em> @param request - the request scope
    /</em> @param conn - the database connection
    /<em> @param sql - the SQL statement to execute
    /</em> @param parameters - the parameters for the statement
    /<em> @param skipResults - the number of results to skip
    /</em> @param maxResults - the maximum number of results to return
    /<em> @param callback - the row handler for the query
    /</em>
    /<em> @throws SQLException - if the query fails
   /</em>/
  public void executeQuery(RequestScope request, Connection conn, String sql, Object[] parameters,
                           int skipResults, int maxResults, RowHandlerCallback callback)
      throws SQLException {
     ErrorContext errorContext = request.getErrorContext();
     errorContext.setActivity(&quot;executing query&quot;);
     errorContext.setObjectId(sql);
     PreparedStatement ps = null;
     ResultSet rs = null;
    try {
       errorContext.setMoreInfo(&quot;Check the SQL Statement (preparation failed).&quot;);
       Integer rsType = request.getStatement().getResultSetType();
      if (rsType != null) {
         ps = conn.prepareStatement(sql, rsType.intValue(), ResultSet.CONCUR_READ_ONLY);
       } else {
         ps = conn.prepareStatement(sql);
       }
       Integer fetchSize = request.getStatement().getFetchSize();
      if (fetchSize != null) {
         ps.setFetchSize(fetchSize.intValue());
       }
       errorContext.setMoreInfo(&quot;Check the parameters (set parameters failed).&quot;);
       request.getParameterMap().setParameters(request, ps, parameters);
       errorContext.setMoreInfo(&quot;Check the statement (query failed).&quot;);
       ps.execute();
       rs = getFirstResultSet(ps);
      if (rs != null) {
         errorContext.setMoreInfo(&quot;Check the results (failed to retrieve results).&quot;);
         handleResults(request, rs, skipResults, maxResults, callback);
       }
      // clear out remaining results
      while (ps.getMoreResults());
     } finally {
      try {
         closeResultSet(rs);
       } finally {
         closeStatement(ps);
       }
     }
   }</p>
<p>其中handleResults(request, rs, skipResults, maxResults, callback)一句用于处理分页，其实此时查询已经执行完毕，可以不必关心handleResults方法，但为清楚起见，下面来看看 handleResults的实现：</p>
<p>private void handleResults(RequestScope request, ResultSet rs, int skipResults, int maxResults, RowHandlerCallback callback) throws SQLException {
    try {
       request.setResultSet(rs);
       ResultMap resultMap = request.getResultMap();
      if (resultMap != null) {
        // Skip Results
        if (rs.getType() != ResultSet.TYPE_FORWARD_ONLY) {
          if (skipResults &gt; 0) {
             rs.absolute(skipResults);
           }
         } else {
          for (int i = 0; i &lt; skipResults; i++) {
            if (!rs.next()) {
              break;
             }
           }
         }
        // Get Results
        int resultsFetched = 0;
        while ((maxResults == SqlExecutor.NO_MAXIMUM_RESULTS || resultsFetched &lt; maxResults) &amp;&amp; rs.next()) {
           Object[] columnValues = resultMap.resolveSubMap(request, rs).getResults(request, rs);
           callback.handleResultObject(request, columnValues, rs);
           resultsFetched++;
         }
       }
     } finally {
       request.setResultSet(null);
     }
   }</p>
<p>此处优先使用的是ResultSet的absolute方法定位记录，是否支持absolute取决于具体数据库驱动，但一般当前版本的数据库都支 持该方法，如果不支持则逐条跳过前面的记录。由此可以看出如果数据库支持absolute，则ibatis内置的分页策略与特定数据库的物理分页效率差距 就在于物理分页查询与不分页查询在数据库中的执行效率的差距了。因为查询执行后读取数据前数据库并未把结果全部返回到内存，所以本身在存储占用上应该差距 不大，如果都使用索引，估计执行速度也差不太多。</p>
<p>继续我们的话题。其实只要在executeQuery执行前组装sql，然后将其传给executeQuery，并告诉handleResults 我们不需要逻辑分页即可。拦截executeQuery可以采用aop动态实现，也可直接继承SqlExecutor覆盖executeQuery来静态 地实现，相比之下后者要简单许多，而且由于SqlExecutor没有实现任何接口，比较易变，动态拦截反到增加了维护的工作量，所以我们下面来覆盖 executeQuery：</p>
<p>package com.aladdin.dao.ibatis.ext;
import java.sql.Connection;
import java.sql.SQLException;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import com.aladdin.dao.dialect.Dialect;
import com.ibatis.sqlmap.engine.execution.SqlExecutor;
import com.ibatis.sqlmap.engine.mapping.statement.RowHandlerCallback;
import com.ibatis.sqlmap.engine.scope.RequestScope;
public class LimitSqlExecutor extends SqlExecutor {
    private static final Log logger = LogFactory.getLog(LimitSqlExecutor.class);</p>
<pre><code>private Dialect dialect;
private boolean enableLimit = true;
public Dialect getDialect() {
    return dialect;
 }
public void setDialect(Dialect dialect) {
    this.dialect = dialect;
 }
public boolean isEnableLimit() {
    return enableLimit;
 }
public void setEnableLimit(boolean enableLimit) {
    this.enableLimit = enableLimit;
 }
 @Override
public void executeQuery(RequestScope request, Connection conn, String sql,
         Object[] parameters, int skipResults, int maxResults,
         RowHandlerCallback callback) throws SQLException {
    if ((skipResults != NO_SKIPPED_RESULTS || maxResults != NO_MAXIMUM_RESULTS)
            &amp;&amp; supportsLimit()) {
         sql = dialect.getLimitString(sql, skipResults, maxResults);
        if(logger.isDebugEnabled()){
             logger.debug(sql);
         }
         skipResults = NO_SKIPPED_RESULTS;
         maxResults = NO_MAXIMUM_RESULTS;            
     }
    super.executeQuery(request, conn, sql, parameters, skipResults,
             maxResults, callback);
 }
public boolean supportsLimit() {
    if (enableLimit &amp;&amp; dialect != null) {
        return dialect.supportsLimit();
     }
    return false;
 }
</code></pre><p>}</p>
<p>其中：</p>
<p>skipResults = NO_SKIPPED_RESULTS;
maxResults = NO_MAXIMUM_RESULTS;</p>
<p>告诉handleResults不分页（我们组装的sql已经使查询结果是分页后的结果了），此处引入了类似hibenate中的数据库方言接口Dialect，其代码如下：</p>
<p>package com.aladdin.dao.dialect;
public interface Dialect {</p>
<pre><code>public boolean supportsLimit();
public String getLimitString(String sql, boolean hasOffset);
public String getLimitString(String sql, int offset, int limit);
</code></pre><p>}</p>
<p>下面为Dialect接口的MySQL实现：</p>
<p>package com.aladdin.dao.dialect;
public class MySQLDialect implements Dialect {
    protected static final String SQL_END_DELIMITER = &quot;;&quot;;
    public String getLimitString(String sql, boolean hasOffset) {
        return new StringBuffer(sql.length() + 20).append(trim(sql)).append(
                 hasOffset ? &quot; limit ?,?&quot; : &quot; limit ?&quot;)
                 .append(SQL_END_DELIMITER).toString();
     }
    public String getLimitString(String sql, int offset, int limit) {
         sql = trim(sql);
         StringBuffer sb = new StringBuffer(sql.length() + 20);
         sb.append(sql);
        if (offset &gt; 0) {
             sb.append(&quot; limit &quot;).append(offset).append(&#39;,&#39;).append(limit)
                     .append(SQL_END_DELIMITER);
         } else {
             sb.append(&quot; limit &quot;).append(limit).append(SQL_END_DELIMITER);
         }
        return sb.toString();
     }
    public boolean supportsLimit() {
        return true;
     }
    private String trim(String sql) {
         sql = sql.trim();
        if (sql.endsWith(SQL_END_DELIMITER)) {
             sql = sql.substring(0, sql.length() - 1</p>
<pre><code>                - SQL_END_DELIMITER.length());
     }
    return sql;
 }
</code></pre><p>}</p>
<p>接下来的工作就是把LimitSqlExecutor注入ibatis中。我们是通过spring来使用ibatis的，所以在我们的dao基类中执行注入，代码如下：</p>
<p>package com.aladdin.dao.ibatis;
import java.io.Serializable;
import java.util.List;
import org.springframework.orm.ObjectRetrievalFailureException;
import org.springframework.orm.ibatis.support.SqlMapClientDaoSupport;
import com.aladdin.dao.ibatis.ext.LimitSqlExecutor;
import com.aladdin.domain.BaseObject;
import com.aladdin.util.ReflectUtil;
import com.ibatis.sqlmap.client.SqlMapClient;
import com.ibatis.sqlmap.engine.execution.SqlExecutor;
import com.ibatis.sqlmap.engine.impl.ExtendedSqlMapClient;
public abstract class BaseDaoiBatis extends SqlMapClientDaoSupport {
    private SqlExecutor sqlExecutor;
    public SqlExecutor getSqlExecutor() {
        return sqlExecutor;
     }
    public void setSqlExecutor(SqlExecutor sqlExecutor) {
        this.sqlExecutor = sqlExecutor;
     }
    public void setEnableLimit(boolean enableLimit) {
        if (sqlExecutor instanceof LimitSqlExecutor) {
             ((LimitSqlExecutor) sqlExecutor).setEnableLimit(enableLimit);
         }
     }
    public void initialize() throws Exception {
        if (sqlExecutor != null) {
             SqlMapClient sqlMapClient = getSqlMapClientTemplate()
                     .getSqlMapClient();
            if (sqlMapClient instanceof ExtendedSqlMapClient) {
                 ReflectUtil.setFieldValue(((ExtendedSqlMapClient) sqlMapClient)
                         .getDelegate(), &quot;sqlExecutor&quot;, SqlExecutor.class,
                         sqlExecutor);
             }
         }
     }
     ...
}</p>
<hr>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/框架汇总/">框架汇总</a></li></span><span class="breadcrumb"><li><a href="/categories/框架汇总/">框架汇总</a></li><li><a href="/categories/框架汇总/ORM/">ORM</a></li><li><a href="/categories/框架汇总/ORM/ibatis/">ibatis</a></li></span></span> | <span class="tags">Tagged <a href="/tags/ORM/" class="label label-primary">ORM</a><a href="/tags/ibatis/" class="label label-success">ibatis</a><a href="/tags/框架汇总/" class="label label-info">框架汇总</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:29"datetime="2014-03-07 09:54:29"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-框架汇总-ORM-ibatis--对ibatis分页功能的改进/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-框架汇总-ORM-ibatis--对ibatis分页功能的改进" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-框架汇总-ORM-hibernate--加速你的Hibernate引擎（上）/">加速你的Hibernate引擎（上）</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:29.000Z"> <a href="/2014/02/02/2014-02-02-框架汇总-ORM-hibernate--加速你的Hibernate引擎（上）/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-hibernate-">加速你的Hibernate引擎（上）</h1>
<p>您还未登录！|<a href="https://passport.csdn.net/account/login" target="_blank">登录</a>|<a href="https://passport.csdn.net/account/register" target="_blank">注册</a>|<a href="https://passport.csdn.net/help/faq" target="_blank">帮助</a></p>
<ul>
<li><a href="http://www.csdn.net/" target="_blank">首页</a></li>
<li><a href="http://news.csdn.net/" target="_blank">业界</a></li>
<li><a href="http://mobile.csdn.net/" target="_blank">移动</a></li>
<li><a href="http://cloud.csdn.net/" target="_blank">云计算</a></li>
<li><a href="http://sd.csdn.net/" target="_blank">研发</a></li>
<li><a href="http://bbs.csdn.net/" target="_blank">论坛</a></li>
<li><a href="http://blog.csdn.net/" target="_blank">博客</a></li>
<li><a href="http://download.csdn.net/" target="_blank">下载</a></li>
<li><h2 id="-"><a href="">更多</a></h2>
</li>
</ul>
<h1 id="-http-blog-csdn-net-dl88250-"><a href="http://blog.csdn.net/DL88250" target="_blank">简约设计の艺术</a></h1>
<h2 id="-">一个自由程序员的琐碎</h2>
<ul>
<li><a href="http://blog.csdn.net/DL88250?viewmode=contents" target="_blank"><img src="" alt="">目录视图</a></li>
<li><a href="http://blog.csdn.net/DL88250?viewmode=list" target="_blank"><img src="" alt="">摘要视图</a></li>
<li><a href="http://blog.csdn.net/DL88250/rss/list" target="_blank"><img src="" alt="">订阅</a>
<a href="https://code.csdn.net/blog/12" target="_blank">公告：博客新增直接引用代码功能</a>        <a href="http://www.csdn.net/article/2013-07-24/2816320" target="_blank">专访谭海燕：移动互联网开发的那些事</a>      <a href="http://blog.csdn.net/csdnproduct/article/details/9226265" target="_blank">CSDN博客频道自定义摘要、图片水印、热门标签等功能上线啦</a>      <a href="http://blog.csdn.net/blogdevteam/article/details/9136613" target="_blank">CSDN博客第二期云计算最佳博主评选</a>      <a href=""></a></li>
</ul>
<h3 id="-hibernate-"><a href="">加速你的Hibernate引擎（上）</a></h3>
<p>分类： <a href="http://blog.csdn.net/DL88250/article/category/742694" target="_blank">ORM</a> <a href="http://blog.csdn.net/DL88250/article/category/336870" target="_blank">Hibernate Framework</a> <a href="http://blog.csdn.net/DL88250/article/category/362100" target="_blank">Java Persistence API</a> <a href="http://blog.csdn.net/DL88250/article/category/742693" target="_blank">JavaEE</a>  2010-11-03 09:55 5540人阅读 <a href="">评论</a>(8) <a href="&quot;收藏&quot;">收藏</a> <a href="&quot;举报&quot;">举报</a>
目录<a href="&quot;系统根据文章中H1到H6标签自动生成文章目录&quot;">(?)</a><a href="&quot;展开&quot;">[+]</a></p>
<ol>
<li><a href="">引言</a></li>
<li><a href="">Hibernate性能调优</a></li>
<li><p><a href="">监控和剖析</a></p>
</li>
<li><p><a href="">监控SQL生成</a></p>
</li>
<li><a href="">查看Hibernate统计</a></li>
<li><p><a href="">剖析</a></p>
</li>
<li><p><a href="">调优技术</a></p>
</li>
<li><p><a href="">业务规则与设计调优</a></p>
</li>
<li><p><a href="">继承映射调优</a></p>
</li>
<li><p><a href="">每个类层次一张表</a></p>
</li>
<li><a href="">每个子类一张表</a></li>
<li><a href="">每个具体类一张表</a></li>
<li><p><a href="">使用隐式多态实现每个具体类一张表</a></p>
</li>
<li><p><a href="">领域对象调优</a></p>
</li>
<li><p><a href="">POJO调优</a></p>
</li>
<li><p><a href="">POJO之间关联的调优</a></p>
</li>
<li><p><a href="">连接池调优</a></p>
</li>
<li><a href="">事务和并发的调优</a></li>
</ol>
<p><img src="" alt="Hibernate Logo"><img src="" alt="InfoQ Logo"></p>
<p><a href="http://www.hibernate.org/" target="_blank">Hibernate</a>是 最流行的对象关系映射（ORM）引擎之一，它提供了数据持久化和查询服务。在你的项目中引入Hibernate并让它跑起来是很容易的。但是，要让它跑得 好却是需要很多时间和经验的。通过我们的使用Hibernate 3.3.1和Oracle 9i的能源项目中的一些例子，本文涵盖了很多Hibernate调优技术。其中还提供了一些掌握Hibernate调优技术所必需的数据库知识。</p>
<p>我们假设读者对Hibernate有一个基本的了解。如果一个调优方法在Hibernate 参考文档（下文简称HRD）或其他调优文章中有详细描述，我们仅提供一个对该文档的引用并从不同角度对其做简单说明。我们关注于那些行之有效，但又缺乏文档的调优方法。</p>
<p>作者 <strong><a href="http://www.infoq.com/cn/author/Yongjun-Jiao-and-Stewart-Clark" target="_blank">Yongjun Jiao and Stewart Clark</a></strong> 译者<strong><a href="http://www.infoq.com/cn/author/%E4%B8%81%E9%9B%AA%E4%B8%B0" target="_blank">丁雪丰</a></strong> 发布于 2010年10月26日 上午12时0分</p>
<h2 id="-1-"><a href=""></a>1.引言</h2>
<p><a href="http://www.hibernate.org/" target="_blank">Hibernate</a>是最流行的对象关系映射（ORM）引擎之一，它提供了数据持久化和查询服务。在你的项目中引入Hibernate并让它跑起来是很容易的。但是，要让它跑得好却是需要很多时间和经验的。通过我们的使用Hibernate 3.3.1和Oracle 9i的能源项目中的一些例子，本文涵盖了很多Hibernate调优技术。其中还提供了一些掌握Hibernate调优技术所必需的数据库知识。</p>
<p>我们假设读者对Hibernate有一个基本的了解。如果一个调优方法在Hibernate 参考文档（下文简称HRD）或其他调优文章中有详细描述，我们仅提供一个对该文档的引用并从不同角度对其做简单说明。我们关注于那些行之有效，但又缺乏文档的调优方法。</p>
<h2 id="-2-hibernate-"><a href=""></a>2.Hibernate性能调优</h2>
<p>调优是一个迭代的、持续进行的过程，涉及软件开发生命周期（SDLC）的所有阶段。在一个典型的使用Hibernate进行持久化的Java EE应用程序中，调优会涉及以下几个方面：</p>
<ul>
<li>业务规则调优</li>
<li>设计调优</li>
<li>Hibernate调优</li>
<li>Java GC调优</li>
<li>应用程序容器调优</li>
<li>底层系统调优，包括数据库和OS。</li>
</ul>
<p>没有一套精心设计的方案就去进行以上调优是非常耗时的，而且很可能收效甚微。好的调优方法的重要部分是为调优内容划分优先级。可以用Pareto定律（又称“80/20法则”）来解释这一点，即通常80%的应用程序性能改善源自头20%的性能问题[5]。</p>
<p>相比基于磁盘和网络的访问，基于内存和CPU的访问能提供更低的延迟和更高的吞吐量。这种基于IO的Hibernate调优与底层系统IO部分的调优应该优先于基于CPU和内存的底层系统GC、CPU和内存部分的调优。
<strong>范例1</strong></p>
<p>我们调优了一个选择电流的HQL查询，把它从30秒降到了1秒以内。如果我们在垃圾回收方面下功夫，可能收效甚微——也许只有几毫秒或者最多几秒，相比HQL的改进，GC方面的改善可以忽略不计。</p>
<p>好的调优方法的另一个重要部分是决定何时优化[4]。</p>
<p>积极优化的提倡者主张开始时就进行调优，例如在业务规则和设计阶段，在整个SDLC都持续进行优化，因为他们认为后期改变业务规则和重新设计代价太大。</p>
<p>另一派人提倡在SDLC末期进行调优，因为他们抱怨前期调优经常会让设计和编码变得复杂。他们经常引用Donald Knuth的名言“<em>过早优化是万恶之源</em>”[6]。</p>
<p>为了平衡调优和编码需要一些权衡。根据笔者的经验，适当的前期调优能带来更明智的设计和细致的编码。很多项目就失败在应用程序调优上，因为上面提到的“过早优化”阶段在被引用时脱离了上下文，而且相应的调优不是被推迟得太晚就是投入资源过少。</p>
<p>但是，要做很多前期调优也不太可能，因为没有经过剖析，你并不能确定应用程序的瓶颈究竟在何处，应用程序一般都是这样演化的。</p>
<p>对我们的多线程企业级应用程序的剖析也表现出大多数应用程序平均只有20-50%的CPU使用率。剩余的CPU开销只是在等待数据库和网络相关的IO。</p>
<p>基于上述分析，我们得出这样一个结论，结合业务规则和设计的Hibernate调优在Pareto定律中20%的那个部分，相应的它们的优先级更高。</p>
<p>一种比较实际的做法是：</p>
<ol>
<li>识别出主要瓶颈，可以预见其中多数是Hibernate、业务规则和设计方面的（其数量视你的调优目标而定；但三到五个是不错的开端）。</li>
<li>修改应用程序以便消除这些瓶颈。</li>
<li>测试应用程序，然后重复步骤1，直到达到你的调优目标为止。</li>
</ol>
<p>你能在Jack Shirazi的《Java Performance Tuning》 [7]一书中找到更多关于性能调优阶段的常见建议。</p>
<p>下面的章节中，我们会按照调优的大致顺序（列在前面的通常影响最大）去解释一些特定的调优技术。</p>
<h2 id="-3-"><a href=""></a>3. 监控和剖析</h2>
<p>没有对Hibernate应用程序的有效监控和剖析，你无法得知性能瓶颈以及何处需要调优。</p>
<h3 id="-3-1-1-sql-"><a href=""></a>3.1.1 监控SQL生成</h3>
<p>尽管使用Hibernate的主要目的是将你从直接使用SQL的痛苦中解救出来，为了对应用程序进行调优，你必须知道Hibernate生成了哪些 SQL。JoeSplosky在他的《The Law of Leaky Abstractions》一文中详细描述了这个问题。</p>
<p>你可以在log4j中将<strong>org.hibernate.SQL</strong>包的日志级别设为DEBUG，这样便能看到生成的所有SQL。你还可以将其他包的日志级别设为DEBUG，甚至TRACE来定位一些性能问题。</p>
<h3 id="-3-1-2-hibernate-"><a href=""></a>3.1.2 查看Hibernate统计</h3>
<p>如果开启<strong>hibernate.generate.statistics</strong>，Hibernate会导出实体、集合、会话、二级缓存、查询和会话工厂的统计信息，这对通过<strong>SessionFactory.getStatistics()</strong>进行的调优很有帮助。为了简单起见，Hibernate还可以使用MBean“<strong>org.hibernate.jmx.StatisticsService</strong>”通过JMX来导出统计信息。你可以在这个网站找到配置范例 。</p>
<h3 id="-3-1-3-"><a href=""></a>3.1.3 剖析</h3>
<p>一个好的剖析工具不仅有利于Hibernate调优，还能为应用程序的其他部分带来好处。然而，大多数商业工具（例如JProbe [10]）都很昂贵。幸运的是Sun/Oracle的JDK1.6自带了一个名为“Java VisualVM” [11]的调试接口。虽然比起那些商业竞争对手，它还相当基础，但它提供了很多调试和调优信息。</p>
<h2 id="-4-"><a href=""></a>4. 调优技术</h2>
<h3 id="-4-1-"><a href=""></a>4.1 业务规则与设计调优</h3>
<p>尽管业务规则和设计调优并不属于Hibernate调优的范畴，但此处的决定对后面Hibernate的调优有很大影响。因此我们特意指出一些与Hibernate调优有关的点。</p>
<p>在业务需求收集与调优过程中，你需要知道：</p>
<ul>
<li>数据获取特性包括引用数据（reference data）、只读数据、读分组（read group）、读取大小、搜索条件以及数据分组和聚合。</li>
<li>数据修改特性包括数据变更、变更组、变更大小、无效修改补偿、数据库（所有变更都在一个数据库中或在多个数据库中）、变更频率和并发性，以及变更响应和吞吐量要求。</li>
<li>数据关系，例如关联（association）、泛化（generalization）、实现（realization）和依赖（dependency）。</li>
</ul>
<p>基于业务需求，你会得到一个最优设计，其中决定了应用程序类型（是OLTP还是数据仓库，亦或者与其中某一种比较接近）和分层结构（将持久层和服务 层分离还是合并），创建领域对象（通常是POJO），决定数据聚合的地方（在数据库中进行聚合能利用强大的数据库功能，节省网络带宽；但是除了像 COUNT、SUM、AVG、MIN和MAX这样的标准聚合，其他的聚合通常不具有移植性。在应用服务器上进行聚合允许你应用更复杂的业务逻辑；但你需要 先在应用程序中载入详细的数据）。
<strong>范例2</strong></p>
<p>分析员需要查看一个取自大数据表的电流ISO（Independent System Operator）聚合列表。最开始他们想要显示大多数字段，尽管数据库能在1分钟内做出响应，应用程序也要花30分钟将1百万行数据加载到前端UI。经 过重新分析，分析员保留了14个字段。因为去掉了很多可选的高聚合度字段，从剩下的字段中进行聚合分组返回的数据要少很多，而且大多数情况下的数据加载时 间也缩小到了可接受的范围内。</p>
<p><strong>范例3</strong></p>
<p>过24个“非标准”（shaped，表示每小时都可以有自己的电量和价格；如果所有24小时的电量和价格相同，我们称之为“标准”）小时会修改小时电流交易，其中包括2个属性：每小时电量和价格。起初我们使用Hibernate的<em>select-before-update</em>特性，就是更新24行数据需要24次选择。因为我们只需要2个属性，而且如果不修改电量或价格的话也没有业务规则禁止无效修改，我们就关闭了<em>select-before-update</em>特性，避免了24次选择。</p>
<h3 id="-4-2-"><a href=""></a>4.2继承映射调优</h3>
<p>尽管继承映射是领域对象的一部分，出于它的重要性我们将它单独出来。HRD [1]中的<a href="http://docs.jboss.org/hibernate/stable/core/reference/en/html/inheritance.html" target="_blank">第9章“继承映射”</a>已经说得很清楚了，所以我们将关注SQL生成和针对每个策略的调优建议。</p>
<p>以下是HRD中范例的类图：</p>
<p><img src="" alt=""><a href=""></a></p>
<h3 id="-4-2-1-"><a href=""></a>4.2.1 每个类层次一张表</h3>
<p>只需要一张表，一条多态查询生成的SQL大概是这样的：
select id, payment_type, amount, currency, rtn, credit_card_type <strong>from</strong> payment</p>
<p>针对具体子类（例如CashPayment）的查询生成的SQL是这样的：</p>
<p>select id, amount, currency <strong>from</strong> payment <strong>where</strong> payment_type=’CASH’</p>
<p>这样做的优点包括只有一张表、查询简单以及容易与其他表进行关联。第二个查询中不需要包含其他子类中的属性。所有这些特性让该策略的性能调优要比其他策略容易得多。这种方法通常比较适合数据仓库系统，因为所有数据都在一张表里，不需要做表连接。</p>
<p>主要的缺点整个类层次中的所有属性都挤在一张大表里，如果有很多子类特有的属性，数据库中就会有太多字段的取值为null，这为当前基于行的数据库 （使用基于列的DBMS的数据仓库处理这个会更好些）的SQL调优增加了难度。除非进行分区，否则唯一的数据表会成为热点，OLTP系统通常在这方面都不 太好。</p>
<h3 id="-4-2-2-"><a href=""></a>4.2.2每个子类一张表</h3>
<p>需要4张表，多态查询生成的SQL如下：
select id, payment_type, amount, currency, rtn, credit_card type,
        case when c.payment_id <strong>is</strong> <strong>not</strong> <strong>null</strong> <strong>then</strong> 1
     when ck.payment_id <strong>is</strong> <strong>not</strong> <strong>null</strong> <strong>then</strong> 2
     when cc.payment_id <strong>is</strong> <strong>not</strong> <strong>null</strong> <strong>then</strong> 3
     when p.id <strong>is</strong> <strong>not</strong> <strong>null</strong> <strong>then</strong> 0 <strong>end</strong> <strong>as</strong> clazz
<strong>from</strong> payment p <strong>left</strong> <strong>join</strong> cash_payment c <strong>on</strong> p.id=c.payment_id <strong>left join</strong>
   cheque_payment ck <strong>on</strong> p.id=ck.payment_id <strong>left</strong> <strong>join</strong>
   credit_payment cc <strong>on</strong> p.id=cc.payment_id;</p>
<p>针对具体子类（例如CashPayment）的查询生成的SQL是这样的：</p>
<p>select id, payment_type, amount, currency
<strong>from</strong> payment p <strong>left</strong> <strong>join</strong> cash_payment c <strong>on</strong> p.id=c.payment_id;</p>
<p>优点包括数据表比较紧凑（没有不需要的可空字段），数据跨三个子类的表进行分区，容易使用超类的表与其他表进行关联。紧凑的数据表可以针对基于行的 数据库做存储块优化，让SQL执行得更好。数据分区增加了数据修改的并发性（除了超类，没有热点），OLTP系统通常会更好些。</p>
<p>同样的，第二个查询不需要包含其他子类的属性。</p>
<p>缺点是在所有策略中它使用的表和表连接最多，SQL语句稍显复杂（看看Hibernate动态鉴别器的长CASE子句）。相比单张表，数据库要花更多时间调优数据表连接，数据仓库在使用该策略时通常不太理想。</p>
<p>因为不能跨超类和子类的字段来建立复合索引，如果需要按这些列进行查询，性能会受影响。任何子类数据的修改都涉及两张表：超类的表和子类的表。</p>
<h3 id="-4-2-3-"><a href=""></a>4.2.3每个具体类一张表</h3>
<p>涉及三张或更多的表，多态查询生成的SQL是这样的：
select p.id, p.amount, p.currency, p.rtn, p. credit_card_type, p.clazz
<strong>from</strong> (<strong>select</strong> id, amount, currency, <strong>null</strong> <strong>as</strong> rtn,<strong>null</strong> <strong>as</strong> credit_card type,
1 <strong>as</strong> clazz <strong>from</strong> cash_payment <strong>union</strong> <strong>all</strong>
<strong>select</strong> id, amount, <strong>null</strong> <strong>as</strong> currency, rtn,<strong>null</strong> <strong>as</strong> credit_card type,
2 <strong>as</strong> clazz <strong>from</strong> cheque_payment <strong>union</strong> <strong>all</strong>
<strong>select</strong> id, amount, <strong>null</strong> <strong>as</strong> currency, <strong>null</strong> <strong>as</strong> rtn,credit_card type,
3 <strong>as</strong> clazz <strong>from</strong> credit_payment) p;</p>
<p>针对具体子类（例如CashPayment）的查询生成的SQL是这样的：</p>
<p>select id, payment_type, amount, currency <strong>from</strong> cash_payment;</p>
<p>优点和上面的“每个子类一张表”策略相似。因为超类通常是抽象的，所以具体的三张表是必须的[开头处说的3张或更多的表是必须的]，任何子类的数据修改只涉及一张表，运行起来更快。</p>
<p>缺点是SQL（from子句和union all子查询）太复杂。但是大多数数据库对此类SQL的调优都很好。</p>
<p>如果一个类想和Payment超类关联，数据库无法使用引用完整性（referential integrity）来实现它；必须使用触发器来实现它。这对数据库性能有些影响。</p>
<h3 id="-4-2-4-"><a href=""></a>4.2.4使用隐式多态实现每个具体类一张表</h3>
<p>只需要三张表。对于Payment的多态查询生成三条独立的SQL语句，每个对应一个子类。Hibernate引擎通过Java反射找出Payment的所有三个子类。</p>
<p>具体子类的查询只生成该子类的SQL。这些SQL语句都很简单，这里就不再阐述了。</p>
<p>它的优点和上节类似：紧凑数据表、跨三个具体子类的数据分区以及对子类任意数据的修改都只涉及一张表。</p>
<p>缺点是用三条独立的SQL语句代替了一条联合SQL，这会带来更多网络IO。Java反射也需要时间。假设如果你有一大堆领域对象，你从最上层的Object类进行隐式选择查询，那该需要多长时间啊！</p>
<p>根据你的映射策略制定合理的选择查询并非易事；这需要你仔细调优业务需求，基于特定的数据场景制定合理的设计决策。</p>
<p>以下是一些建议：</p>
<ul>
<li>设计细粒度的类层次和粗粒度的数据表。细粒度的数据表意味着更多数据表连接，相应的查询也会更复杂。</li>
<li>如非必要，不要使用多态查询。正如上文所示，对具体类的查询只选择需要的数据，没有不必要的表连接和联合。</li>
<li>“每个类层次一张表”对有高并发、简单查询并且没有共享列的OLTP系统来说是个不错的选择。如果你想用数据库的引用完整性来做关联，那它也是个合适的选择。</li>
<li>“每个具体类一张表”对有高并发、复杂查询并且没有共享列的OLTP系统来说是个不错的选择。当然你不得不牺牲超类与其他类之间的关联。</li>
<li>采用混合策略，例如“每个类层次一张表”中嵌入“每个子类一张表”，这样可以利用不同策略的优势。随着你项目的进化，如果你要反复重新映射，那你可能也会采用该策略。</li>
<li>“使用隐式多态实现每个具体类一张表”这种做法并不推荐，因为其配置过于繁缛、使用“any”元素的复杂关联语法和隐式查询的潜在危险性。
<strong>范例4</strong></li>
</ul>
<p>下面是一个交易描述应用程序的部分领域类图：</p>
<p><img src="" alt=""></p>
<p>开始时，项目只有GasDeal和少数用户，它使用“每个类层次一张表”。</p>
<p>OilDeal和ElectricityDeal是后期产生更多业务需求后加入的。没有改变映射策略。但是ElectricityDeal有太多自己的属性，因此有很多电相关的可空字段加入了Deal表。因为用户量也在增长，数据修改变得越来越慢。</p>
<p>重新设计时我们使用了两张单独的表，分别针对气/油和电相关的属性。新的映射混合了“每个类层次一张表”和“每个子类一张表”。我们还重新设计了查询，以便允许针对具体交易子类进行选择，消除不必要的列和表连接。</p>
<h3 id="-4-3-"><a href=""></a>4.3 领域对象调优</h3>
<p>基于<strong>4.1**</strong>节**中对业务规则和设计的调优，你得到了一个用POJO来表示的领域对象的类图。我们建议：</p>
<h3 id="-4-3-1-pojo-"><a href=""></a>4.3.1 POJO调优</h3>
<ul>
<li>从读写数据中将类似引用这样的只读数据和以读为主的数据分离出来。
只读数据的二级缓存是最有效的，其次是以读为主的数据的非严格读写。将只读POJO标识为不可更改的（immutable）也是一个调优点。如果一个服务层方法只处理只读数据，可以将它的事务标为只读，这是优化Hibernate和底层JDBC驱动的一个方法。</li>
<li>细粒度的POJO和粗粒度的数据表。
基于数据的修改并发量和频率等内容来分解大的POJO。尽管你可以定义一个粒度非常细的对象模型，但粒度过细的表会导致大量表连接，这对数据仓库来说是不能接受的。</li>
<li>优先使用非final的类。
Hibernate只会针对非final的类使用CGLIB代理来实现延时关联获取。如果被关联的类是final的，Hibernate会一次加载所有内容，这对性能会有影响。</li>
<li>使用业务键为分离（detached）实例实现equals()和hashCode()方法。
在多层系统中，经常可以在分离对象上使用乐观锁来提升系统并发性，达到更高的性能。</li>
<li>定义一个版本或时间戳属性。
乐观锁需要这个字段来实现长对话（应用程序事务）[译注：session译为会话，conversion译为对话，以示区别]。</li>
<li>优先使用组合POJO。
你的前端UI经常需要来自多个不同POJO的数据。你应该向UI传递一个组合POJO而不是独立的POJO以获得更好的网络性能。
有两种方式在服务层构建组合POJO。一种是在开始时加3.2载所有需要的独立POJO，随后抽取需要的属性放入组合POJO；另一种是使用HQL投影，直接从数据库中选择需要的属性。
如果其他地方也要查找这些独立POJO，可以把它们放进二级缓存以便共享，这时第一种方式更好；其他情况下第二种方式更好。</li>
</ul>
<h3 id="-4-3-2-pojo-"><a href=""></a>4.3.2 POJO之间关联的调优</h3>
<ul>
<li>如果可以用one-to-one、one-to-many或many-to-one的关联，就不要使用many-to-many。</li>
<li>many-to-many关联需要额外的映射表。
尽管你的Java代码只需要处理两端的POJO，但查询时，数据库需要额外地关联映射表，修改时需要额外的删除和插入。</li>
<li>单向关联优先于双向关联。
由于many-to-many的特性，在双向关联的一端加载对象会触发另一端的加载，这会进一步触发原始端加载更多的数据，等等。
one-to-many和many-to-one的双向关联也是类似的，<a href="">当你从多端（子实体）定位到一端（父实体）</a>。
这样的来回加载很耗时，而且可能也不是你所期望的。</li>
<li>不要为了关联而定义关联；只在你需要一起加载它们时才这么做，这应该由你的业务规则和设计来决定（见<strong>范例**</strong>5**）。
另外，你要么不定义任何关联，要么在子POJO中定义一个值类型的属性来表示父POJO的ID（另一个方向也是类似的）。</li>
<li>集合调优
如果集合排序逻辑能由底层数据库实现，就使用“order-by”属性来代替“sort”，因为通常数据库在这方面做得比你好。
集合可以是值类型的（元素或组合元素），也可以是实体引用类型的（one-to-many或many-to-many关联）。对引用类型集合的调优主要是调优获取策略。对于值类型集合的调优，HRD [1]中的20.5节“理解集合性能”已经做了很好的阐述。</li>
<li>获取策略调优。请见<strong>4.7**</strong>节的范例<strong>**5</strong>。
<strong>范例5</strong></li>
</ul>
<p>我们有一个名为ElectricityDeals的核心POJO用于描述电的交易。从业务角度来看，它有很多many-to-one关联，例如和 Portfolio、Strategy和Trader等的关联。因为引用数据十分稳定，它们被缓存在前端，能基于其ID属性快速定位到它们。</p>
<p>为了有好的加载性能，ElectricityDeal只映射元数据，即那些引用POJO的值类型ID属性，因为在需要时，可以在前端通过portfolioKey从缓存中快速查找Portfolio：
name=<em>&quot;portfolioKey&quot;</em> column=<em>&quot;PORTFOLIO_ID&quot;</em>type=<em>&quot;</em>integer<em>&quot;</em>/&gt;</p>
<p>这种隐式关联避免了数据库表连接和额外的字段选择，降低了数据传输的大小。</p>
<h3 id="-4-4-"><a href=""></a>4.4 连接池调优</h3>
<p>由于创建物理数据库连接非常耗时，你应该始终使用连接池，而且应该始终使用生产级连接池而非Hibernate内置的基本连接池算法。</p>
<p>通常会为Hibernate提供一个有连接池功能的数据源。Apache DBCP的BasicDataSource[13]是一个流行的开源生产级数据源。大多数数据库厂商也实现了自己的兼容JDBC 3.0的连接池。举例来说，你也可以使用Oracle ReaApplication Cluster [15]提供的JDBC连接池[14]以获得连接的负载均衡和失败转移。</p>
<p>不用多说，你在网上能找到很多关于连接池调优的技术，因此我们只讨论那些大多数连接池所共有的通用调优参数：</p>
<ul>
<li>最小池大小：连接池中可保持的最小连接数。</li>
<li>最大池大小：连接池中可以分配的最大连接数。
如果应用程序有高并发，而最大池大小又太小，连接池就会经常等待。相反，如果最小池大小太大，又会分配不需要的连接。</li>
<li>最大空闲时间：连接池中的连接被物理关闭前能保持空闲的最大时间。</li>
<li>最大等待时间：连接池等待连接返回的最大时间。该参数可以预防失控事务（runaway transaction）。</li>
<li>验证查询：在将连接返回给调用方前用于验证连接的SQL查询。这是因为一些数据库被配置为会杀掉长时间空闲的连接，网络或数据库相关的异常也可能会杀死连接。为了减少此类开销，连接池在空闲时会运行该验证。</li>
</ul>
<h3 id="-4-5-"><a href=""></a>4.5事务和并发的调优</h3>
<p>短数据库事务对任何高性能、高可扩展性的应用程序来说都是必不可少的。你使用表示对话请求的会话来处理单个工作单元，以此来处理事务。</p>
<p>考虑到工作单元的范围和事务边界的划分，有3中模式：</p>
<ul>
<li><strong>每次操作一个会话。</strong>每次数据库调用需要一个新会话和事务。因为真实的业务事务通常包含多个此类操作和大量小事务，这一般会引起更多数据库活动（主要是数据库每次提交需要将变更刷新到磁盘上），影响应用程序性能。这是一种反模式，不该使用它。</li>
<li><strong>使用分离对象，每次请求一个会话。</strong>每次客户端请求有一个新会话和一个事务，使用Hibernate的“当前会话”特性将两者关联起来。
在一个多层系统中，用户通常会发起长对话（或应用程序事务）。大多数时间我们使用Hibernate的自动版本和分离对象来实现乐观并发控制和高性能。</li>
<li><strong>带扩展（或长）会话的每次对话一会话。</strong>在一个也许会跨多个事务的长对话中保持会话开启。尽管这能把你从重新关联中解脱出来，但会话可能会内存溢出，在高并发系统中可能会有旧数据。</li>
</ul>
<p>你还应该注意以下几点。 </p>
<ul>
<li>如果不需要JTA就用本地事务，因为JTA需要更多资源，比本地事务更慢。就算你有多个数据源，除非有跨多个数据库的事务，否则也不需要 JTA。在最后的一个场景下，可以考虑在每个数据源中使用本地事务，使用一种类似“Last Resource Commit Optimization”[16]的技术（见下面的<strong>范例**</strong>6**）。</li>
<li>如果不涉及数据变更，将事务标记为只读的，就像<strong>4.3.1**</strong>节**提到的那样。</li>
<li>总是设置默认事务超时。保证在没有响应返回给用户时，没有行为不当的事务会完全占有资源。这对本地事务也同样有效。</li>
<li>如果Hibernate不是独占数据库用户，乐观锁会失效，除非创建数据库触发器为其他应用程序对相同数据的变更增加版本字段值。
<strong>范例6</strong></li>
</ul>
<p>我们的应用程序有多个在大多数情况下只和数据库“A”打交道的服务层方法；它们偶尔也会从数据库“B”中获取只读数据。因为数据库“B”只提供只读数据，我们对这些方法在这两个数据库上仍然使用本地事务。</p>
<p>服务层上有一个方法设计在两个数据库上执行数据变更。以下是伪代码：
//Make sure a local transaction on database A exists
@Transactional (readOnly=<strong>false</strong>, propagation=Propagation.<em>REQUIRED</em>)
<strong>public</strong> <strong>void</strong> saveIsoBids() {
//it participates in the above annotated local transaction
insertBidsInDatabaseA();
//it runs in its own local transaction on database B
insertBidRequestsInDatabaseB(); //must be the last operation</p>
<p>因为<strong>insertBidRequestsInDatabaseB()</strong>是saveIsoBids ()中的最后一个方法，所以只有下面的场景会造成数据不一致：</p>
<p>在saveIsoBids()执行返回时，数据库“A”的本地事务提交失败。</p>
<p>但是，就算saveIsoBids()使用JTA，在两阶段提交（2PC）的第二个提交阶段失败的时候，你还是会碰到数据不一致。因此如果你能处理好上述的数据不一致性，而且不想为了一个或少数几个方法引入JTA的复杂性，你应该使用本地事务。</p>
<p>（未完待续）</p>
<p><strong>关于作者</strong></p>
<p><strong>Yongjun Jiao</strong>是SunGard Consulting Services的技术主管。过去10年中他一直是专业软件开发者，他的专长包括Java SE、Java EE、Oracle和应用程序调优。他最近的关注点是高性能计算，包括内存数据网格、并行计算和网格计算。</p>
<p><strong>Stewart Clark</strong>是SunGard Consulting Services的负责人。过去15年中他一直是专业软件开发者和项目经理，他的专长包括Java核心编程、Oracle和能源交易。</p>
<p>[译注：由于原文较长，中译版分两次发布]</p>
<p><strong>查看英文原文：</strong><a href="http://www.infoq.com/articles/hibernate_tuning" target="_blank">Revving Up Your Hibernate Engine</a></p>
<p>转自：<a href="http://www.infoq.com/cn/articles/hibernate_tuning" target="_blank">http://www.infoq.com/cn/articles/hibernate_tuning</a>
本文是使用 <a href="http://b3log-solo.googlecode.com/" target="_blank">B3log Solo</a> 从 <a href="http://b3log-88250.appspot.com/" target="_blank">简约设计の艺术</a> 进行同步发布的</p>
<p>原文地址：<a href="http://b3log-88250.appspot.com/articles/2010/11/03/1288788936673.html" target="_blank"><a href="http://b3log-88250.appspot.com/articles/2010/11/03/1288788936673.html">http://b3log-88250.appspot.com/articles/2010/11/03/1288788936673.html</a></a>
分享到： <a href="&quot;分享到新浪微博&quot;"></a><a href="&quot;分享到腾讯微博&quot;"></a></p>
<ul>
<li>下一篇：<a href="http://blog.csdn.net/dl88250/article/details/1426527" target="_blank">今天正式搬家过来CSDN了~~~~</a>
查看评论<a href=""></a></li>
</ul>
<p>8楼 <a href="http://blog.csdn.net/pettery2" target="_blank">pettery2</a> 2010-12-01 22:41发表 <a href="&quot;回复&quot;">[回复]</a>  <a href="&quot;引用&quot;">[引用]</a> <a href="&quot;举报&quot;">[举报]</a><a href="http://blog.csdn.net/pettery2" target="_blank"><img src="" alt=""></a>[e01]7楼 <a href="http://blog.csdn.net/Duke147" target="_blank">Duke147</a> 2010-11-09 19:05发表 <a href="&quot;回复&quot;">[回复]</a>  <a href="&quot;引用&quot;">[引用]</a> <a href="&quot;举报&quot;">[举报]</a><a href="http://blog.csdn.net/Duke147" target="_blank"><img src="" alt=""></a>[e01]6楼 <a href="http://blog.csdn.net/tangweiwei0000" target="_blank">tangweiwei0000</a> 2010-11-08 09:53发表 <a href="&quot;回复&quot;">[回复]</a>  <a href="&quot;引用&quot;">[引用]</a> <a href="&quot;举报&quot;">[举报]</a><a href="http://blog.csdn.net/tangweiwei0000" target="_blank"><img src="" alt=""></a>[e01]5楼 <a href="http://blog.csdn.net/TAOCLEE" target="_blank">TAOCLEE</a> 2010-11-07 14:29发表 <a href="&quot;回复&quot;">[回复]</a>  <a href="&quot;引用&quot;">[引用]</a> <a href="&quot;举报&quot;">[举报]</a><a href="http://blog.csdn.net/TAOCLEE" target="_blank"><img src="" alt=""></a>路漫漫其修远喜4楼 <a href="http://blog.csdn.net/codeshuo" target="_blank">codeshuo</a> 2010-11-06 22:17发表 <a href="&quot;回复&quot;">[回复]</a>  <a href="&quot;引用&quot;">[引用]</a> <a href="&quot;举报&quot;">[举报]</a><a href="http://blog.csdn.net/codeshuo" target="_blank"><img src="" alt=""></a>[e01]
但我看不太懂啊。。。还得加把劲。3楼 <a href="http://blog.csdn.net/lupengji" target="_blank">lupengji</a> 2010-11-06 18:28发表 <a href="&quot;回复&quot;">[回复]</a>  <a href="&quot;引用&quot;">[引用]</a> <a href="&quot;举报&quot;">[举报]</a><a href="http://blog.csdn.net/lupengji" target="_blank"><img src="" alt=""></a>[e01]2楼 <a href="http://blog.csdn.net/liuwu513" target="_blank">liuwu513</a> 2010-11-05 16:01发表 <a href="&quot;回复&quot;">[回复]</a>  <a href="&quot;引用&quot;">[引用]</a> <a href="&quot;举报&quot;">[举报]</a><a href="http://blog.csdn.net/liuwu513" target="_blank"><img src="" alt=""></a>[e01]
这一部分太重要了1楼 <a href="http://blog.csdn.net/skytalemcc" target="_blank">skytalemcc</a> 2010-11-05 09:47发表 <a href="&quot;回复&quot;">[回复]</a>  <a href="&quot;引用&quot;">[引用]</a> <a href="&quot;举报&quot;">[举报]</a><a href="http://blog.csdn.net/skytalemcc" target="_blank"><img src="" alt=""></a>[e01]
您还没有登录,请<a href="">[登录]</a>或<a href="http://passport.csdn.net/account/register?from=http%3A%2F%2Fblog.csdn.net%2Fdl88250%2Farticle%2Fdetails%2F5985750" target="_blank">[注册]</a></p>
<p>/* 以上用户言论只代表其个人观点，不代表CSDN网站的观点或立场<a href=""></a><a href=""></a>
<a href="&quot;回到顶部&quot;"><img src="" alt="TOP"></a></p>
<p>个人资料</p>
<p><a href="http://my.csdn.net/DL88250" target="_blank"><img src="&quot;访问我的空间&quot;" alt=""></a>
<a href="http://my.csdn.net/DL88250" target="_blank">88250</a></p>
<p><a href="&quot;[加关注]&quot;"></a> <a href="&quot;[发私信]&quot;"></a></p>
<ul>
<li>访问：4219337次</li>
<li>积分：41528分</li>
<li><p>排名：第20名</p>
</li>
<li><p>原创：1195篇</p>
</li>
<li>转载：326篇</li>
<li>译文：42篇</li>
<li>评论：2834条</li>
</ul>
<p>文章搜索</p>
<p><a href=""></a></p>
<p>文章分类</p>
<ul>
<li><a href="http://blog.csdn.net/dl88250/article/category/359483" target="_blank">Adoration</a>(7)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/361991" target="_blank">Agile Develeopment</a>(25)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/817011" target="_blank">Alipay</a>(2)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/785718" target="_blank">Android</a>(2)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/735896" target="_blank">Apache</a>(2)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/362353" target="_blank">Architecture Design</a>(18)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/727396" target="_blank">B3log</a>(31)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/772464" target="_blank">Beyond</a>(2)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/466930" target="_blank">BeyondTrack</a>(8)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/792935" target="_blank">Book</a>(1)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/531019" target="_blank">BPEL</a>(7)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/737397" target="_blank">Buzz</a>(2)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/273193" target="_blank">C/# &amp; .Net</a>(36)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/259942" target="_blank">C/C++</a>(60)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/768467" target="_blank">Cache</a>(4)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/445355" target="_blank">CAS &amp; SAML &amp; SSO</a>(7)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/785583" target="_blank">Chinasb</a>(1)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/830731" target="_blank">Chrome</a>(1)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/279627" target="_blank">Code Name:l0y0l</a>(4)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/323229" target="_blank">Compile Principles</a>(8)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/259943" target="_blank">Data-Structrue/Algorithms</a>(41)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/307128" target="_blank">Database</a>(31)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/318447" target="_blank">Design Patterns</a>(22)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/688714" target="_blank">DHTML</a>(27)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/304165" target="_blank">Eclipse</a>(36)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/472355" target="_blank">EJB 3.x</a>(24)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/371604" target="_blank">English</a>(4)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/772184" target="_blank">EverBox</a>(1)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/259944" target="_blank">Fiddlededee</a>(87)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/798286" target="_blank">FireFox</a>(2)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/823430" target="_blank">FreeMarker</a>(1)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/731730" target="_blank">GAE</a>(32)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/509270" target="_blank">Game</a>(4)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/794103" target="_blank">GFW</a>(1)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/744371" target="_blank">Git</a>(5)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/790487" target="_blank">GlassFish</a>(5)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/755357" target="_blank">Go</a>(4)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/750293" target="_blank">Google</a>(19)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/801964" target="_blank">Guice</a>(1)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/336870" target="_blank">Hibernate Framework</a>(30)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/763988" target="_blank">HTML5</a>(2)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/735897" target="_blank">HttpClient</a>(1)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/801962" target="_blank">IoC/DI</a>(2)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/321666" target="_blank">J2EE/JavaEE</a>(123)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/273192" target="_blank">J2SE/JavaSE</a>(174)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/732513" target="_blank">Java</a>(63)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/362100" target="_blank">Java Persistence API</a>(25)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/359121" target="_blank">Java Server Faces</a>(40)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/742693" target="_blank">JavaEE</a>(14)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/461374" target="_blank">JavaEE Security</a>(3)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/363012" target="_blank">JavaFX</a>(25)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/570523" target="_blank">JavaScript</a>(7)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/450848" target="_blank">JBoss Seam</a>(26)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/531020" target="_blank">jBPM</a>(8)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/786045" target="_blank">JDK 7</a>(3)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/735349" target="_blank">Joke</a>(3)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/814017" target="_blank">JPA</a>(2)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/782163" target="_blank">jQuery</a>(1)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/758468" target="_blank">jsdoc</a>(1)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/757521" target="_blank">jsoup</a>(3)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/510376" target="_blank">JSR-299</a>(21)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/801963" target="_blank">JSR-330</a>(2)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/273771" target="_blank">Life in Programming</a>(153)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/298242" target="_blank">LivaPlayer</a>(14)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/365496" target="_blank">Mathematics</a>(9)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/735535" target="_blank">Maven</a>(8)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/461289" target="_blank">Maven 2</a>(18)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/768466" target="_blank">Memcached</a>(1)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/295040" target="_blank">MultiMediia</a>(17)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/483612" target="_blank">Music</a>(16)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/278915" target="_blank">My Linux</a>(165)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/345108" target="_blank">NetBeans</a>(225)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/300046" target="_blank">Network Engineering</a>(63)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/836154" target="_blank">node.js</a>(1)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/296292" target="_blank">Open Source</a>(261)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/821590" target="_blank">Optimization</a>(1)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/786046" target="_blank">Oracle</a>(6)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/742694" target="_blank">ORM</a>(4)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/364737" target="_blank">OSGi</a>(18)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/743945" target="_blank">PHP</a>(9)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/445013" target="_blank">Portal &amp; Portlet</a>(8)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/833677" target="_blank">Python</a>(1)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/755291" target="_blank">Quartz</a>(1)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/302630" target="_blank">Regular Expression</a>(16)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/361363" target="_blank">Ruby &amp; Rails</a>(19)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/435004" target="_blank">SCA</a>(1)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/310293" target="_blank">Shell Programming</a>(15)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/287867" target="_blank">Software Engineering</a>(42)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/481570" target="_blank">Software Quality Assurance</a>(2)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/318452" target="_blank">Software Testing</a>(15)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/336869" target="_blank">Spring Framework</a>(25)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/363915" target="_blank">StoneAgeDict</a>(28)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/454387" target="_blank">Struts Framework</a>(3)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/469638" target="_blank">Subversion</a>(10)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/319645" target="_blank">SWT/JFace/RCP</a>(25)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/747162" target="_blank">SyntaxHighlighter</a>(1)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/299913" target="_blank">System Analyst exam</a>(13)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/767001" target="_blank">Tencent</a>(1)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/799655" target="_blank">TestNG</a>(2)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/357256" target="_blank">TeX/LaTeX</a>(9)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/260439" target="_blank">Text Categorization</a>(9)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/742035" target="_blank">Ubuntu</a>(3)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/318451" target="_blank">UML Modeling</a>(12)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/832030" target="_blank">VI/VIM</a>(1)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/794848" target="_blank">Web</a>(4)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/798287" target="_blank">Web Browser</a>(2)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/475410" target="_blank">Web Service</a>(5)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/324813" target="_blank">Web UI Design</a>(23)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/803421" target="_blank">Wicket</a>(5)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/267361" target="_blank">Windows</a>(54)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/753760" target="_blank">Wine</a>(1)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/475341" target="_blank">Workflow &amp; BPM</a>(17)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/368591" target="_blank">にほんごのべんきょう</a>(4)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/848178" target="_blank">li</a>(0)</li>
<li><a href="http://blog.csdn.net/dl88250/article/category/911428" target="_blank">B3log Announcement</a>(3)</li>
<li><p><a href="http://blog.csdn.net/dl88250/article/category/1290033" target="_blank">B3log Solo</a>(1)
文章存档</p>
</li>
<li><p><a href="http://blog.csdn.net/dl88250/article/month/2013/05" target="_blank">2013年05月</a>(1)</p>
</li>
<li><a href="http://blog.csdn.net/dl88250/article/month/2012/11" target="_blank">2012年11月</a>(1)</li>
<li><a href="http://blog.csdn.net/dl88250/article/month/2012/08" target="_blank">2012年08月</a>(1)</li>
<li><a href="http://blog.csdn.net/dl88250/article/month/2012/02" target="_blank">2012年02月</a>(1)</li>
<li><a href="http://blog.csdn.net/dl88250/article/month/2011/10" target="_blank">2011年10月</a>(1)</li>
<li><a href="http://blog.csdn.net/dl88250/article/month/2011/08" target="_blank">2011年08月</a>(1)</li>
<li><a href="http://blog.csdn.net/dl88250/article/month/2011/07" target="_blank">2011年07月</a>(1)</li>
<li><a href="http://blog.csdn.net/dl88250/article/month/2011/06" target="_blank">2011年06月</a>(7)</li>
<li><a href="http://blog.csdn.net/dl88250/article/month/2011/05" target="_blank">2011年05月</a>(6)</li>
<li><a href="http://blog.csdn.net/dl88250/article/month/2011/04" target="_blank">2011年04月</a>(9)</li>
<li><a href="http://blog.csdn.net/dl88250/article/month/2011/03" target="_blank">2011年03月</a>(17)</li>
<li><a href="http://blog.csdn.net/dl88250/article/month/2011/02" target="_blank">2011年02月</a>(27)</li>
<li><a href="http://blog.csdn.net/dl88250/article/month/2011/01" target="_blank">2011年01月</a>(13)</li>
<li><a href="http://blog.csdn.net/dl88250/article/month/2010/12" target="_blank">2010年12月</a>(16)</li>
<li><a href="http://blog.csdn.net/dl88250/article/month/2010/11" target="_blank">2010年11月</a>(29)</li>
<li><a href="http://blog.csdn.net/dl88250/article/month/2010/10" target="_blank">2010年10月</a>(16)</li>
<li><a href="http://blog.csdn.net/dl88250/article/month/2010/09" target="_blank">2010年09月</a>(17)</li>
<li><a href="http://blog.csdn.net/dl88250/article/month/2010/08" target="_blank">2010年08月</a>(10)</li>
<li><a href="http://blog.csdn.net/dl88250/article/month/2010/07" target="_blank">2010年07月</a>(10)</li>
<li><a href="http://blog.csdn.net/dl88250/article/month/2010/06" target="_blank">2010年06月</a>(13)</li>
<li><a href="http://blog.csdn.net/dl88250/article/month/2010/05" target="_blank">2010年05月</a>(12)</li>
<li><a href="http://blog.csdn.net/dl88250/article/month/2010/04" target="_blank">2010年04月</a>(25)</li>
<li><a href="http://blog.csdn.net/dl88250/article/month/2010/03" target="_blank">2010年03月</a>(13)</li>
<li><a href="http://blog.csdn.net/dl88250/article/month/2010/02" target="_blank">2010年02月</a>(10)</li>
<li><a href="http://blog.csdn.net/dl88250/article/month/2010/01" target="_blank">2010年01月</a>(13)</li>
<li><a href="http://blog.csdn.net/dl88250/article/month/2009/12" target="_blank">2009年12月</a>(17)</li>
<li><a href="http://blog.csdn.net/dl88250/article/month/2009/11" target="_blank">2009年11月</a>(9)</li>
<li><a href="http://blog.csdn.net/dl88250/article/month/2009/10" target="_blank">2009年10月</a>(13)</li>
<li><a href="http://blog.csdn.net/dl88250/article/month/2009/09" target="_blank">2009年09月</a>(9)</li>
<li><a href="http://blog.csdn.net/dl88250/article/month/2009/08" target="_blank">2009年08月</a>(13)</li>
<li><a href="http://blog.csdn.net/dl88250/article/month/2009/07" target="_blank">2009年07月</a>(13)</li>
<li><a href="http://blog.csdn.net/dl88250/article/month/2009/06" target="_blank">2009年06月</a>(27)</li>
<li><a href="http://blog.csdn.net/dl88250/article/month/2009/05" target="_blank">2009年05月</a>(13)</li>
<li><a href="http://blog.csdn.net/dl88250/article/month/2009/04" target="_blank">2009年04月</a>(18)</li>
<li><a href="http://blog.csdn.net/dl88250/article/month/2009/03" target="_blank">2009年03月</a>(17)</li>
<li><a href="http://blog.csdn.net/dl88250/article/month/2009/02" target="_blank">2009年02月</a>(15)</li>
<li><a href="http://blog.csdn.net/dl88250/article/month/2009/01" target="_blank">2009年01月</a>(23)</li>
<li><a href="http://blog.csdn.net/dl88250/article/month/2008/12" target="_blank">2008年12月</a>(19)</li>
<li><a href="http://blog.csdn.net/dl88250/article/month/2008/11" target="_blank">2008年11月</a>(34)</li>
<li><a href="http://blog.csdn.net/dl88250/article/month/2008/10" target="_blank">2008年10月</a>(27)</li>
<li><a href="http://blog.csdn.net/dl88250/article/month/2008/09" target="_blank">2008年09月</a>(27)</li>
<li><a href="http://blog.csdn.net/dl88250/article/month/2008/08" target="_blank">2008年08月</a>(19)</li>
<li><a href="http://blog.csdn.net/dl88250/article/month/2008/07" target="_blank">2008年07月</a>(18)</li>
<li><a href="http://blog.csdn.net/dl88250/article/month/2008/06" target="_blank">2008年06月</a>(10)</li>
<li><a href="http://blog.csdn.net/dl88250/article/month/2008/05" target="_blank">2008年05月</a>(31)</li>
<li><a href="http://blog.csdn.net/dl88250/article/month/2008/04" target="_blank">2008年04月</a>(23)</li>
<li><a href="http://blog.csdn.net/dl88250/article/month/2008/03" target="_blank">2008年03月</a>(55)</li>
<li><a href="http://blog.csdn.net/dl88250/article/month/2008/02" target="_blank">2008年02月</a>(78)</li>
<li><a href="http://blog.csdn.net/dl88250/article/month/2008/01" target="_blank">2008年01月</a>(76)</li>
<li><a href="http://blog.csdn.net/dl88250/article/month/2007/12" target="_blank">2007年12月</a>(13)</li>
<li><a href="http://blog.csdn.net/dl88250/article/month/2007/11" target="_blank">2007年11月</a>(28)</li>
<li><a href="http://blog.csdn.net/dl88250/article/month/2007/10" target="_blank">2007年10月</a>(33)</li>
<li><a href="http://blog.csdn.net/dl88250/article/month/2007/09" target="_blank">2007年09月</a>(21)</li>
<li><a href="http://blog.csdn.net/dl88250/article/month/2007/08" target="_blank">2007年08月</a>(68)</li>
<li><a href="http://blog.csdn.net/dl88250/article/month/2007/07" target="_blank">2007年07月</a>(113)</li>
<li><a href="http://blog.csdn.net/dl88250/article/month/2007/06" target="_blank">2007年06月</a>(65)</li>
<li><a href="http://blog.csdn.net/dl88250/article/month/2007/05" target="_blank">2007年05月</a>(83)</li>
<li><a href="http://blog.csdn.net/dl88250/article/month/2007/04" target="_blank">2007年04月</a>(43)</li>
<li><a href="http://blog.csdn.net/dl88250/article/month/2007/03" target="_blank">2007年03月</a>(22)</li>
<li><a href="http://blog.csdn.net/dl88250/article/month/2007/02" target="_blank">2007年02月</a>(74)</li>
<li><a href="http://blog.csdn.net/dl88250/article/month/2007/01" target="_blank">2007年01月</a>(78)</li>
<li><a href="http://blog.csdn.net/dl88250/article/month/2006/12" target="_blank">2006年12月</a>(48)</li>
</ul>
<p>展开</p>
<p>阅读排行</p>
<ul>
<li><a href="http://blog.csdn.net/dl88250/article/details/3852624" title="当代 IT 大牛排行榜" target="_blank">当代 IT 大牛排行榜</a>(438472)</li>
<li><a href="http://blog.csdn.net/dl88250/article/details/3280698" title="NetBeans 时事通讯（刊号 # 34 - Nov 11, 2008）" target="_blank">NetBeans 时事通讯（刊号 /# 34 - Nov 11, 2008）</a>(294762)</li>
<li><a href="http://blog.csdn.net/dl88250/article/details/3604772" title="Seam 2.1.1.GA 发布！" target="_blank">Seam 2.1.1.GA 发布！</a>(240265)</li>
<li><a href="http://blog.csdn.net/dl88250/article/details/3765750" title="JBoss Seam 框架下的单元测试" target="_blank">JBoss Seam 框架下的单元测试</a>(220053)</li>
<li><a href="http://blog.csdn.net/dl88250/article/details/1636841" title="20个漂亮xp桌面主题" target="_blank">20个漂亮xp桌面主题</a>(72125)</li>
<li><a href="http://blog.csdn.net/dl88250/article/details/5191092" title="了解 NoSQL 的必读资料" target="_blank">了解 NoSQL 的必读资料</a>(65897)</li>
<li><a href="http://blog.csdn.net/dl88250/article/details/1826713" title="初学UML之-------用例图" target="_blank">初学UML之-------用例图</a>(64870)</li>
<li><a href="http://blog.csdn.net/dl88250/article/details/4027668" title="数学符号大全" target="_blank">数学符号大全</a>(38964)</li>
<li><a href="http://blog.csdn.net/dl88250/article/details/3753193" title="Web Beans (JSR-299): Q&amp;A with Specification Lead Gavin King " target="_blank">Web Beans (JSR-299): Q&amp;A with Specification Lead Gavin King</a>(30472)</li>
<li><p><a href="http://blog.csdn.net/dl88250/article/details/3862541" title="《星际争霸》成为大学课程之一" target="_blank">《星际争霸》成为大学课程之一</a>(26977)
评论排行</p>
</li>
<li><p><a href="http://blog.csdn.net/dl88250/article/details/5931333" title="十二个理由让你不得不期待 Ubuntu10.10" target="_blank">十二个理由让你不得不期待 Ubuntu10.10</a>(106)</p>
</li>
<li><a href="http://blog.csdn.net/dl88250/article/details/5310751" title="2009 年个人回忆与总结" target="_blank">2009 年个人回忆与总结</a>(91)</li>
<li><a href="http://blog.csdn.net/dl88250/article/details/1587054" title="Linux下的千千静听——LivaPlayer" target="_blank">Linux下的千千静听——LivaPlayer</a>(69)</li>
<li><a href="http://blog.csdn.net/dl88250/article/details/1636841" title="20个漂亮xp桌面主题" target="_blank">20个漂亮xp桌面主题</a>(49)</li>
<li><a href="http://blog.csdn.net/dl88250/article/details/1826713" title="初学UML之-------用例图" target="_blank">初学UML之-------用例图</a>(48)</li>
<li><a href="http://blog.csdn.net/dl88250/article/details/4303524" title="书评：简洁代码──敏捷软件工艺指南 " target="_blank">书评：简洁代码──敏捷软件工艺指南</a>(44)</li>
<li><a href="http://blog.csdn.net/dl88250/article/details/5100894" title="程序员的幽默" target="_blank">程序员的幽默</a>(43)</li>
<li><a href="http://blog.csdn.net/dl88250/article/details/6386620" title="准备入职支付宝" target="_blank">准备入职支付宝</a>(39)</li>
<li><a href="http://blog.csdn.net/dl88250/article/details/5118301" title="HTML 5 WebSocket 示例" target="_blank">HTML 5 WebSocket 示例</a>(38)</li>
<li><a href="http://blog.csdn.net/dl88250/article/details/5518605" title="NetBeans IDE 6.9 Beta 发布" target="_blank">NetBeans IDE 6.9 Beta 发布</a>(38)</li>
</ul>
<p>推荐文章
最新评论</p>
<ul>
<li><a href="http://blog.csdn.net/DL88250/article/details/6174582#comments" target="_blank">GAE Java 应用性能优化</a></li>
</ul>
<p><a href="http://blog.csdn.net/wilder2000" target="_blank">wilder2000</a>: mark</p>
<ul>
<li><a href="http://blog.csdn.net/DL88250/article/details/2075637#comments" target="_blank">基于 JSF＋Spring + JPA 构建敏捷的Web应用[88250原创]</a></li>
</ul>
<p><a href="http://blog.csdn.net/az690236414" target="_blank">喝冰开水</a>: 把源码发给我还吗？690236414@qq.com谢谢了，最好是我能加你好友，好相互交流</p>
<ul>
<li><a href="http://blog.csdn.net/DL88250/article/details/4027668#comments" target="_blank">数学符号大全</a></li>
</ul>
<p><a href="http://blog.csdn.net/zinss26914" target="_blank">低调小一</a>: 多谢了，转载了，楼主辛苦</p>
<ul>
<li><a href="http://blog.csdn.net/DL88250/article/details/1843813#comments" target="_blank">java.util.logging日志功能使用快速入门</a></li>
</ul>
<p><a href="http://blog.csdn.net/ccssddnnbbookkee" target="_blank">ccssddnnbbookkee</a>: 很详细，谢谢</p>
<ul>
<li><a href="http://blog.csdn.net/DL88250/article/details/2799522#comments" target="_blank">使用 CAS 在 Tomcat 中实现单点登录</a></li>
</ul>
<p><a href="http://blog.csdn.net/hooqee" target="_blank">hooqee</a>: 不错！</p>
<ul>
<li><a href="http://blog.csdn.net/DL88250/article/details/6227988#comments" target="_blank">哪本书是对程序员最有影响、每个程序员都该阅读的书？</a></li>
</ul>
<p><a href="http://blog.csdn.net/yxm0603" target="_blank">起飞---为梦想而飞</a>: 我一本都没看过，需要好好看看</p>
<ul>
<li><a href="http://blog.csdn.net/DL88250/article/details/2794943#comments" target="_blank">Single SignOn - Integrating Liferay With CAS Server</a></li>
</ul>
<p><a href="http://blog.csdn.net/logoc" target="_blank">logoc</a>: 咱能，一天到晚不转来转去吗。还他妈的专家</p>
<ul>
<li><a href="http://blog.csdn.net/DL88250/article/details/6612090#comments" target="_blank">暂时告别 CSDN 博客，移居 GAE（<a href="http://88250.b3log.org）">http://88250.b3log.org）</a></a></li>
</ul>
<p><a href="http://blog.csdn.net/vbubble" target="_blank">bubble</a>: 顶b3blog 对搜索引擎优化方面做的如何</p>
<ul>
<li><a href="http://blog.csdn.net/DL88250/article/details/6208677#comments" target="_blank">加入中国 HTML5 研究小组</a></li>
</ul>
<p><a href="http://blog.csdn.net/vicns" target="_blank">簡約_Billy</a>: 想您致敬，</p>
<ul>
<li><a href="http://blog.csdn.net/DL88250/article/details/8227475#comments" target="_blank">Java 开源博客——B3log Solo 0.5.5 正式版发布了！</a></li>
</ul>
<p><a href="http://blog.csdn.net/vicns" target="_blank">簡約_Billy</a>:</p>
<p>Code snips</p>
<ul>
<li><a href="http://www.java2s.com/" target="_blank">Java Code examples</a></li>
<li><a href="http://www.blabla.cn/index.html" target="_blank">HTML代码示例</a></li>
<li><p><a href="http://www.java2s.com/Code/Cpp/CatalogCpp.htm" target="_blank">C 代码示例</a>
E-books</p>
</li>
<li><p><a href="http://www.chinaitlab.com/" target="_blank">中国 IT 实验室</a></p>
</li>
<li><a href="http://shop.apabi.com/index/index.aspx" target="_blank">中文电子书网</a></li>
<li><a href="http://book.httpcn.com/" target="_blank">网络中国 - E 书</a></li>
<li><a href="http://download.csdn.net/" target="_blank">CSDN 下载频道</a></li>
<li><a href="http://www.51leifeng.net/index.php" target="_blank">偶要雷锋 - 分享社区</a></li>
</ul>
<p>Linux/Ubuntu</p>
<ul>
<li><a href="http://www.gnome-look.org/" target="_blank">Gnome-Look</a></li>
<li><a href="http://forum.ubuntu.org.cn/" target="_blank">Ubuntu 中文官方论坛</a></li>
<li><a href="http://search.deviantart.com/" target="_blank">deviantART Search</a></li>
<li><a href="http://www.getdeb.net/" target="_blank">GetDeb</a></li>
<li><a href="http://www.kde-look.org/" target="_blank">KDE-Look</a></li>
<li><a href="http://linuxtoy.org/" target="_blank">LinuxToy</a></li>
<li><a href="http://www.compiz-themes.org/" target="_blank">Compiz Themes</a></li>
<li><a href="http://www.chinaunix.net/" target="_blank">ChinaUnix</a></li>
<li><p><a href="http://www.compiz-fusion.org/" target="_blank">Compiz-Fusion</a>
My friends</p>
</li>
<li><p><a href="http://yhuag.blogbus.com/" target="_blank">光光的Blog~</a></p>
</li>
<li><a href="http://hi.baidu.com/zy_tough" target="_blank">ZY Tough</a></li>
<li><a href="http://dorainm.cublog.cn/" target="_blank">师傅 dorainm</a></li>
<li><a href="http://blog.csdn.net/elevenxl" target="_blank">Eleven 的专栏</a></li>
<li><a href="http://blog.csdn.net/meteorlWJ" target="_blank">Meteor 的专栏</a></li>
<li><a href="http://blog.csdn.net/Vanessa219" target="_blank">Vanessa 的小窝</a></li>
<li><a href="http://blog.csdn.net/herian/" target="_blank">秋歌的专栏</a></li>
<li><a href="http://user.qzone.qq.com/769626482/" target="_blank">金秋风采</a></li>
<li><a href="http://www.eleven-china.com/" target="_blank">eleven-china</a></li>
<li><a href="http://blog.csdn.net/debug_today" target="_blank">野地的枯草</a></li>
<li><a href="http://hi.baidu.com/%C0%C7%C6%C6%C0%CB" target="_blank">狼猫窝</a></li>
<li><a href="http://www.co-soft.info/" target="_blank">云南科软</a></li>
<li><a href="http://88250.b3log.org/" target="_blank">88250 @ Solo</a> (<a href="http://88250.b3log.org/blog-articles-feed.do" target="_blank">RSS</a>)</li>
</ul>
<p>My projects</p>
<ul>
<li><a href="https://beyondtrack.dev.java.net/" target="_blank">BeyondTrack @ Java.net</a></li>
<li><a href="http://sourceforge.net/projects/livaplayer/" target="_blank">LivaPlayer</a></li>
<li><a href="http://kenai.com/projects/drop/" target="_blank">Drop</a></li>
<li><a href="http://b3log-solo.googlecode.com/" target="_blank">B3log Solo</a></li>
<li><p><a href="http://latke.googlecode.com/" target="_blank">B3log Latke</a>
Super stars :-)</p>
</li>
<li><p><a href="http://www-cs-staff.stanford.edu/~knuth/index.html" target="_blank">Don Knuth&#39;s Home Page</a></p>
</li>
<li><a href="http://www.martinfowler.com/" target="_blank">Martin Fowler</a></li>
<li><a href="http://www.turing.org.uk/turing/" target="_blank">Alan Turing</a></li>
<li><a href="http://blog.objectmentor.com/articles/category/uncle-bobs-blatherings" target="_blank">Uncle Bob (Robert C. Martin)</a></li>
<li><a href="http://www.research.att.com/~bs/" target="_blank">Bjarne Stroustrup&#39;s Homepage</a></li>
<li><a href="http://www.stallman.org/" target="_blank">Richard Stallman&#39;s Home Page</a></li>
</ul>
<p>Technologies</p>
<ul>
<li><a href="http://www-128.ibm.com/developerworks/cn/opensource/" target="_blank">IBM 软件技术</a></li>
<li><a href="http://www.csdn.net/" target="_blank">CSDN</a></li>
<li><a href="http://www.uml.org/" target="_blank">UML 官方</a></li>
<li><a href="http://www.eclipse.org/" target="_blank">Eclipse.org</a></li>
<li><a href="http://www.apache.org/" target="_blank">Apache Software</a></li>
<li><a href="http://dinosaur.compilertools.net/" target="_blank">LEX &amp; YACC Page</a></li>
<li><a href="http://www.open-open.com/" target="_blank">Java 开源大全</a></li>
<li><a href="http://labs.jboss.com/" target="_blank">JBoss.org</a></li>
<li><a href="http://www.php.net/" target="_blank">PHP 官方</a></li>
<li><a href="http://www.springframework.org/" target="_blank">Springframework.org</a></li>
<li><a href="http://www.netbeans.org/index_zh_CN.html" target="_blank">NetBeans 中文社区</a></li>
<li><a href="http://www.sourceforge.net/" target="_blank">SourceForge.net</a></li>
<li><a href="http://www.javaworld.com.tw/" target="_blank">JavaWorld@TW</a></li>
<li><a href="http://www.hibernate.org/" target="_blank">hibernate.org</a></li>
<li><a href="http://www.extremeprogramming.org/" target="_blank">Extreme Programming</a></li>
<li><a href="http://www.rubyonrails.org/" target="_blank">Ruby on Rails</a></li>
<li><a href="http://www.ruby-lang.org.cn/forums/" target="_blank">Ruby 中文社区论坛</a></li>
<li><a href="http://openjfx.java.sun.com/current-build/doc/" target="_blank">JavaFX Script Reference</a></li>
<li><a href="http://www.javafx.com/" target="_blank">JavaFX Home</a></li>
<li><a href="http://www.opensource.org/" target="_blank">Open Source Initiative</a></li>
<li><a href="https://facelets.dev.java.net/nonav/docs/dev/docbook.html" target="_blank">Facelets DevDoc</a></li>
<li><a href="http://www.testng.org/" target="_blank">Testng.org</a></li>
<li><a href="http://java-source.net/" target="_blank">java-source</a></li>
<li><a href="http://www.javaeye.com/" target="_blank">JavaEye</a></li>
<li><a href="http://wiki.netbeans.org/NetBeansDreamTeam" target="_blank">NetBeans Dream Team</a></li>
<li><a href="http://www.infoq.com/" target="_blank">InfoQ</a></li>
<li><a href="https://open-esb.dev.java.net/" target="_blank">OpenEBS</a></li>
<li><a href="http://www.seamframework.org/" target="_blank">JBoss Seam</a></li>
<li><a href="http://www.jdon.com/" target="_blank">J 道</a></li>
<li><a href="http://www.w3.org/TR/html4/" target="_blank">HTML 4.01 Spec</a></li>
<li><a href="http://xiexiejiao.cn/" target="_blank">歇歇脚</a></li>
<li><a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html" target="_blank">HTTP 1.1 Status Code</a></li>
<li><a href="http://www.oschina.net/" target="_blank">开源中国社区</a></li>
<li><a href="http://www.mhtml5.com/" target="_blank">HTML5 研究小组</a></li>
</ul>
<p><a href="http://www.csdn.net/company/about.html" target="_blank">公司简介</a>|<a href="http://www.csdn.net/company/recruit.html" target="_blank">招贤纳士</a>|<a href="http://www.csdn.net/company/marketing.html" target="_blank">广告服务</a>|<a href="http://www.csdn.net/company/account.html" target="_blank">银行汇款帐号</a>|<a href="http://www.csdn.net/company/contact.html" target="_blank">联系方式</a>|<a href="http://www.csdn.net/company/statement.html" target="_blank">版权声明</a>|<a href="http://www.csdn.net/company/layer.html" target="_blank">法律顾问</a>|<a href="mailto:webmaster@csdn.net">问题报告</a><a href="http://wpa.qq.com/msgrd?v=3&amp;uin=2355263776&amp;site=qq&amp;menu=yes" target="_blank">QQ客服</a> <a href="http://e.weibo.com/csdnsupport/profile" target="_blank">微博客服</a> <a href="http://bbs.csdn.net/forums/Service" target="_blank">论坛反馈</a> <a href="mailto:webmaster@csdn.net">联系邮箱：webmaster@csdn.net</a> 服务热线：400-600-2320京 ICP 证 070598 号北京创新乐知信息技术有限公司 版权所有世纪乐知(北京)网络技术有限公司 提供技术支持江苏乐知网络技术有限公司 提供商务支持Copyright © 1999-2012, CSDN.NET, All Rights Reserved <a href="http://www.hd315.gov.cn/beian/view.asp?bianhao=010202001032100010" target="_blank"><img src="" alt="GongshangLogo"></a>
<img src="http://counter.csdn.net/pv.aspx?id=24" alt=""></p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/框架汇总/">框架汇总</a></li></span><span class="breadcrumb"><li><a href="/categories/框架汇总/">框架汇总</a></li><li><a href="/categories/框架汇总/ORM/">ORM</a></li><li><a href="/categories/框架汇总/ORM/hibernate/">hibernate</a></li></span></span> | <span class="tags">Tagged <a href="/tags/ORM/" class="label label-primary">ORM</a><a href="/tags/hibernate/" class="label label-success">hibernate</a><a href="/tags/框架汇总/" class="label label-info">框架汇总</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:29"datetime="2014-03-07 09:54:29"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-框架汇总-ORM-hibernate--加速你的Hibernate引擎（上）/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-框架汇总-ORM-hibernate--加速你的Hibernate引擎（上）" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-框架汇总-ORM-ibatis--使用ibatis操作数据库的封装/">使用ibatis操作数据库的封装</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:29.000Z"> <a href="/2014/02/02/2014-02-02-框架汇总-ORM-ibatis--使用ibatis操作数据库的封装/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-ibatis-">使用ibatis操作数据库的封装</h1>
<p><strong><a href="http://blog.csdn.net/boaifeng/article/details/5966940" title="[置顶]使用ibatis操作数据库的封装" target="_blank">使用ibatis操作数据库的封装</a><em>**</em></strong></p>
<p>近期刚进入公司，也是本人的第一份正式工作，公司使用的ORM框架是ibatis，下面代码是对batis dao的一个封装，主要继承自spring的SqlMapClientDaoSupport，负责为单个Entity 提供CRUD操作的IBatis DAO基类，使用该基类，可以减少不少代码量。</p>
<p><a href="http://blog.csdn.net/boaifeng/article/details/5966940" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/boaifeng/article/details/5966940" title="copy to clipboard" target="_blank">copy to clipboard</a><a href="http://blog.csdn.net/boaifeng/article/details/5966940" title="print" target="_blank">print</a><a href="http://blog.csdn.net/boaifeng/article/details/5966940" title="?" target="_blank">?</a></p>
<ol>
<li><p>package com.nfschina.utils.dao.ibatis  </p>
</li>
<li></li>
<li><p>import java.io.Serializable;  </p>
</li>
<li><p>import java.sql.Connection;  </p>
</li>
<li><p>import java.sql.ResultSet;  </p>
</li>
<li><p>import java.sql.SQLException;  </p>
</li>
<li><p>import java.util.HashMap;  </p>
</li>
<li><p>import java.util.List;  </p>
</li>
<li><p>import java.util.Map;  </p>
</li>
<li></li>
<li><p>import org.apache.commons.beanutils.PropertyUtils;  </p>
</li>
<li><p>import org.apache.commons.lang.StringUtils;  </p>
</li>
<li><p>import org.springframework.util.Assert;  </p>
</li>
<li></li>
<li><p>import com.ibatis.sqlmap.engine.impl.SqlMapClientImpl;  </p>
</li>
<li><p>import com.ibatis.sqlmap.engine.mapping.sql.stat.StaticSql;  </p>
</li>
<li><p>import com.ibatis.sqlmap.engine.mapping.statement.MappedStatement;  </p>
</li>
<li></li>
<li><p>importcom.nfschina.utils.BaseException;  </p>
</li>
<li><p>import com.nfschina.utils.DataPage;  </p>
</li>
<li></li>
<li><p>import org.springframework.orm.ibatis.support.SqlMapClientDaoSupport  </p>
</li>
<li></li>
<li><p>//<em>/</em> </p>
</li>
<li><p>/* IBatis Dao的泛型基类. </p>
</li>
<li><p>/* 继承于Spring的SqlMapClientDaoSupport,提供分页函数和若干便捷查询方法，并对返回值作了泛型类型转换. </p>
</li>
<li><p>/*/  </p>
</li>
<li><p>@SuppressWarnings(&quot;unchecked&quot;)  </p>
</li>
<li><p>public class IBatisGenericDao extends SqlMapClientDaoSupport {  </p>
</li>
<li></li>
<li><p>public static final String POSTFIX_INSERT = &quot;.insert&quot;;  </p>
</li>
<li></li>
<li><p>public static final String POSTFIX_UPDATE = &quot;.update&quot;;  </p>
</li>
<li></li>
<li><p>public static final String POSTFIX_DELETE = &quot;.delete&quot;;  </p>
</li>
<li></li>
<li><p>public static final String POSTFIX_DELETE_PRIAMARYKEY = &quot;.deleteByPrimaryKey&quot;;  </p>
</li>
<li></li>
<li><p>public static final String POSTFIX_SELECT = &quot;.select&quot;;  </p>
</li>
<li></li>
<li><p>public static final String POSTFIX_SELECTMAP = &quot;.selectByMap&quot;;  </p>
</li>
<li></li>
<li><p>public static final String POSTFIX_SELECTSQL = &quot;.selectBySql&quot;;  </p>
</li>
<li></li>
<li><p>public static final String POSTFIX_COUNT = &quot;.count&quot;;  </p>
</li>
<li></li>
<li><p>//<em>/</em> </p>
</li>
<li><p>/* 根据ID获取对象 </p>
</li>
<li><p>/*  </p>
</li>
<li><p>/* @throws BaseException </p>
</li>
<li><p>/* @throws SQLException  </p>
</li>
<li><p>/*/  </p>
</li>
<li><p>public <T> T get(Class<T> entityClass, Serializable id) throws BaseException, SQLException {  </p>
</li>
<li></li>
<li><p>T o = (T) getSqlMapClient().queryForObject(entityClass.getName() + POSTFIX_SELECT, id);  </p>
</li>
<li><p>if (o == null)  </p>
</li>
<li><p>throw new BaseException(BaseException.DATA_NOTFOUND, &quot;未找到实体: &quot; + id);  </p>
</li>
<li><p>return o;  </p>
</li>
<li><p>}  </p>
</li>
<li></li>
<li><p>//<em>/</em> </p>
</li>
<li><p>/* 获取全部对象 </p>
</li>
<li><p>/* @throws SQLException  </p>
</li>
<li><p>/*/  </p>
</li>
<li><p>public <T> List<T> getAll(Class<T> entityClass) throws SQLException {  </p>
</li>
<li><p>return getSqlMapClient().queryForList(entityClass.getName() + POSTFIX_SELECT, null);  </p>
</li>
<li><p>}  </p>
</li>
<li></li>
<li><p>//<em>/</em> </p>
</li>
<li><p>/* 新增对象 </p>
</li>
<li><p>/* @throws SQLException  </p>
</li>
<li><p>/*/  </p>
</li>
<li><p>public void insert(Object o) throws SQLException {  </p>
</li>
<li><p>getSqlMapClient().insert(o.getClass().getName() + POSTFIX_INSERT, o);  </p>
</li>
<li><p>}  </p>
</li>
<li></li>
<li><p>//<em>/</em> </p>
</li>
<li><p>/* 保存对象 </p>
</li>
<li><p>/* @throws SQLException  </p>
</li>
<li><p>/*/  </p>
</li>
<li><p>public int update(Object o) throws SQLException {  </p>
</li>
<li><p>return getSqlMapClient().update(o.getClass().getName() + POSTFIX_UPDATE, o);  </p>
</li>
<li><p>}  </p>
</li>
<li></li>
<li><p>//<em>/</em> </p>
</li>
<li><p>/* 删除对象 </p>
</li>
<li><p>/* @throws SQLException  </p>
</li>
<li><p>/*/  </p>
</li>
<li><p>public int remove(Object o) throws SQLException {  </p>
</li>
<li><p>return getSqlMapClient().delete(o.getClass().getName() + POSTFIX_DELETE, o);  </p>
</li>
<li><p>}  </p>
</li>
<li></li>
<li><p>//<em>/</em> </p>
</li>
<li><p>/* 根据ID删除对象 </p>
</li>
<li><p>/* @throws SQLException  </p>
</li>
<li><p>/*/  </p>
</li>
<li><p>public <T> int removeById(Class<T> entityClass, Serializable id) throws SQLException {  </p>
</li>
<li><p>return getSqlMapClient().delete(entityClass.getName() + POSTFIX_DELETE_PRIAMARYKEY, id);  </p>
</li>
<li><p>}  </p>
</li>
<li></li>
<li><p>//<em>/</em> </p>
</li>
<li><p>/* map查询. </p>
</li>
<li><p>/*  </p>
</li>
<li><p>/* @param map </p>
</li>
<li><p>/*            包含各种属性的查询 </p>
</li>
<li><p>/* @throws SQLException  </p>
</li>
<li><p>/*/  </p>
</li>
<li><p>public <T> List<T> find(Class<T> entityClass, Map<String, Object> map) throws SQLException {  </p>
</li>
<li><p>if (map == null)  </p>
</li>
<li><p>return this.getSqlMapClient().queryForList(entityClass.getName() + POSTFIX_SELECT, null);  </p>
</li>
<li><p>else {  </p>
</li>
<li><p>map.put(&quot;findBy&quot;, &quot;True&quot;);  </p>
</li>
<li><p>return this.getSqlMapClient()  </p>
</li>
<li><p>.queryForList(entityClass.getName() + POSTFIX_SELECTMAP, map);  </p>
</li>
<li><p>}  </p>
</li>
<li><p>}  </p>
</li>
<li></li>
<li><p>//<em>/</em> </p>
</li>
<li><p>/* sql 查询. </p>
</li>
<li><p>/*  </p>
</li>
<li><p>/* @param sql </p>
</li>
<li><p>/*            直接sql的语句(需要防止注入式攻击) </p>
</li>
<li><p>/* @throws SQLException  </p>
</li>
<li><p>/*/  </p>
</li>
<li><p>public <T> List<T> find(Class<T> entityClass, String sql) throws SQLException {  </p>
</li>
<li><p>Assert.hasText(sql);  </p>
</li>
<li><p>if (StringUtils.isEmpty(sql))  </p>
</li>
<li><p>return this.getSqlMapClient().queryForList(entityClass.getName() + POSTFIX_SELECT, null);  </p>
</li>
<li><p>else  </p>
</li>
<li><p>return this.getSqlMapClient()  </p>
</li>
<li><p>.queryForList(entityClass.getName() + POSTFIX_SELECTSQL, sql);  </p>
</li>
<li><p>}  </p>
</li>
<li></li>
<li><p>//<em>/</em> </p>
</li>
<li><p>/* 根据属性名和属性值查询对象. </p>
</li>
<li><p>/*  </p>
</li>
<li><p>/* @return 符合条件的对象列表 </p>
</li>
<li><p>/* @throws SQLException  </p>
</li>
<li><p>/*/  </p>
</li>
<li><p>public <T> List<T> findBy(Class<T> entityClass, String name, Object value) throws SQLException {  </p>
</li>
<li><p>Assert.hasText(name);  </p>
</li>
<li><p>Map<String, Object> map = new HashMap<String, Object>();  </p>
</li>
<li><p>map.put(name, value);  </p>
</li>
<li><p>return find(entityClass, map);  </p>
</li>
<li><p>}  </p>
</li>
<li></li>
<li><p>//<em>/</em> </p>
</li>
<li><p>/* 根据属性名和属性值查询对象. </p>
</li>
<li><p>/*  </p>
</li>
<li><p>/* @return 符合条件的唯一对象 </p>
</li>
<li><p>/*/  </p>
</li>
<li><p>public <T> T findUniqueBy(Class<T> entityClass, String name, Object value) {  </p>
</li>
<li><p>Assert.hasText(name);  </p>
</li>
<li><p>Map<String, Object> map = new HashMap<String, Object>();  </p>
</li>
<li><p>try {  </p>
</li>
<li><p>PropertyUtils.getProperty(entityClass.newInstance(), name);  </p>
</li>
<li><p>map.put(name, value);  </p>
</li>
<li><p>map.put(&quot;findUniqueBy&quot;, &quot;True&quot;);  </p>
</li>
<li><p>return (T) getSqlMapClient().queryForObject(entityClass.getName() + POSTFIX_SELECTMAP,  </p>
</li>
<li><p>map);  </p>
</li>
<li><p>} catch (Exception e) {  </p>
</li>
<li><p>logger.error(&quot;Error when propertie on entity,&quot; + e.getMessage(), e.getCause());  </p>
</li>
<li><p>return null;  </p>
</li>
<li><p>}  </p>
</li>
<li></li>
<li><p>}  </p>
</li>
<li></li>
<li><p>//<em>/</em> </p>
</li>
<li><p>/* 根据属性名和属性值以Like AnyWhere方式查询对象. </p>
</li>
<li><p>/* @throws SQLException  </p>
</li>
<li><p>/*/  </p>
</li>
<li><p>public <T> List<T> findByLike(Class<T> entityClass, String name, String value) throws SQLException {  </p>
</li>
<li><p>Assert.hasText(name);  </p>
</li>
<li><p>Map<String, Object> map = new HashMap<String, Object>();  </p>
</li>
<li><p>map.put(name, value);  </p>
</li>
<li><p>map.put(&quot;findLikeBy&quot;, &quot;True&quot;);  </p>
</li>
<li><p>return getSqlMapClient().queryForList(entityClass.getName() + POSTFIX_SELECTMAP, map);  </p>
</li>
<li></li>
<li><p>}  </p>
</li>
<li></li>
<li><p>//<em>/</em> </p>
</li>
<li><p>/* 判断对象某些属性的值在数据库中不存在重复 </p>
</li>
<li><p>/*  </p>
</li>
<li><p>/* @param tableName </p>
</li>
<li><p>/*            数据表名字 </p>
</li>
<li><p>/* @param names </p>
</li>
<li><p>/*            在POJO里不能重复的属性列表,以逗号分割 如&quot;name,loginid,password&quot; <br> </p>
</li>
<li><p>/*            FIXME how about in different schema? </p>
</li>
<li><p>/*/  </p>
</li>
<li><p>public boolean isNotUnique(Object entity, String tableName, String names) {  </p>
</li>
<li><p>try {  </p>
</li>
<li><p>String primarykey;  </p>
</li>
<li><p>Connection con = getSqlMapClient().getCurrentConnection();  </p>
</li>
<li><p>ResultSet dbMetaData = con.getMetaData().getPrimaryKeys(con.getCatalog(), null, tableName);  </p>
</li>
<li><p>dbMetaData.next();  </p>
</li>
<li><p>if (dbMetaData.getRow() &gt; 0) {  </p>
</li>
<li><p>primarykey = dbMetaData.getString(4);  </p>
</li>
<li><p>if (names.indexOf(primarykey) &gt; -1)  </p>
</li>
<li><p>return false;  </p>
</li>
<li><p>} else {  </p>
</li>
<li><p>return true;  </p>
</li>
<li><p>}  </p>
</li>
<li></li>
<li><p>} catch (SQLException e) {  </p>
</li>
<li><p>logger.error(e.getMessage(), e);  </p>
</li>
<li><p>return false;  </p>
</li>
<li><p>}  </p>
</li>
<li><p>return false;  </p>
</li>
<li><p>}  </p>
</li>
<li></li>
<li><p>//<em>/</em> </p>
</li>
<li><p>/* 分页查询函数，使用PaginatedList. </p>
</li>
<li><p>/*  </p>
</li>
<li><p>/* @param pageNo </p>
</li>
<li><p>/*            页号,从0开始. </p>
</li>
<li><p>/* @throws SQLException </p>
</li>
<li><p>/*/  </p>
</li>
<li><p>@SuppressWarnings(&quot;rawtypes&quot;)  </p>
</li>
<li><p>public DataPage pagedQuery(String sqlName, HashMap<String, Object> hashMap, Integer pageNo, Integer pageSize)  </p>
</li>
<li><p>throws SQLException {  </p>
</li>
<li></li>
<li><p>if (pageNo == null || pageSize == null) {  </p>
</li>
<li><p>List list = getSqlMapClient().queryForList(sqlName, hashMap);  </p>
</li>
<li><p>if (list == null || list.size() == 0) {  </p>
</li>
<li><p>return new DataPage();  </p>
</li>
<li><p>} else {  </p>
</li>
<li><p>return new DataPage(0, list.size(), list.size(), list);  </p>
</li>
<li><p>}  </p>
</li>
<li><p>} else {  </p>
</li>
<li><p>Assert.hasText(sqlName);  </p>
</li>
<li><p>Assert.isTrue(pageNo &gt;= 1, &quot;pageNo should start from 1&quot;);  </p>
</li>
<li><p>// Count查询   </p>
</li>
<li><p>Integer totalCount = (Integer) getSqlMapClient().queryForObject(sqlName + &quot;.Count&quot;, hashMap);  </p>
</li>
<li></li>
<li><p>if (totalCount &lt; 1) {  </p>
</li>
<li><p>return new DataPage();  </p>
</li>
<li><p>}  </p>
</li>
<li></li>
<li><p>// 实际查询返回分页对象   </p>
</li>
<li><p>int startIndex = DataPage.getStartOfPage(pageNo, pageSize);  </p>
</li>
<li><p>hashMap.put(&quot;startIndex&quot;, startIndex);  </p>
</li>
<li><p>hashMap.put(&quot;pageSize&quot;, pageSize);  </p>
</li>
<li><p>List list = getSqlMapClient().queryForList(sqlName, hashMap);  </p>
</li>
<li></li>
<li><p>return new DataPage(startIndex, totalCount, pageSize, list);  </p>
</li>
<li><p>}  </p>
</li>
<li><p>}  </p>
</li>
<li></li>
<li><p>public String getMappedSQL(String sqlName) {  </p>
</li>
<li><p>String sql = null;  </p>
</li>
<li></li>
<li><p>SqlMapClientImpl sqlmap = (SqlMapClientImpl) getSqlMapClient();  </p>
</li>
<li></li>
<li><p>MappedStatement stmt = sqlmap.getMappedStatement(sqlName);  </p>
</li>
<li><p>StaticSql staticSql = (StaticSql) stmt.getSql();  </p>
</li>
<li><p>sql = staticSql.getSql(null, null);  </p>
</li>
<li><p>return sql;  </p>
</li>
<li><p>}  </p>
</li>
<li><p>}  </p>
</li>
</ol>
<p>package com.nfschina.utils.dao.ibatis import java.io.Serializable; import java.sql.Connection; import java.sql.ResultSet; import java.sql.SQLException; import java.util.HashMap; import java.util.List; import java.util.Map; import org.apache.commons.beanutils.PropertyUtils; import org.apache.commons.lang.StringUtils; import org.springframework.util.Assert; import com.ibatis.sqlmap.engine.impl.SqlMapClientImpl; import com.ibatis.sqlmap.engine.mapping.sql.stat.StaticSql; import com.ibatis.sqlmap.engine.mapping.statement.MappedStatement; importcom.nfschina.utils.BaseException; import com.nfschina.utils.DataPage; import org.springframework.orm.ibatis.support.SqlMapClientDaoSupport //<em>/</em> /<em> IBatis Dao的泛型基类. /</em> 继承于Spring的SqlMapClientDaoSupport,提供分页函数和若干便捷查询方法，并对返回值作了泛型类型转换. /<em>/ @SuppressWarnings(&quot;unchecked&quot;) public class IBatisGenericDao extends SqlMapClientDaoSupport { public static final String POSTFIX_INSERT = &quot;.insert&quot;; public static final String POSTFIX_UPDATE = &quot;.update&quot;; public static final String POSTFIX_DELETE = &quot;.delete&quot;; public static final String POSTFIX_DELETE_PRIAMARYKEY = &quot;.deleteByPrimaryKey&quot;; public static final String POSTFIX_SELECT = &quot;.select&quot;; public static final String POSTFIX_SELECTMAP = &quot;.selectByMap&quot;; public static final String POSTFIX_SELECTSQL = &quot;.selectBySql&quot;; public static final String POSTFIX_COUNT = &quot;.count&quot;; //</em>/<em> /</em> 根据ID获取对象 /<em> /</em> @throws BaseException /<em> @throws SQLException /</em>/ public <T> T get(Class<T> entityClass, Serializable id) throws BaseException, SQLException { T o = (T) getSqlMapClient().queryForObject(entityClass.getName() + POSTFIX_SELECT, id); if (o == null) throw new BaseException(BaseException.DATA_NOTFOUND, &quot;未找到实体: &quot; + id); return o; } //<em>/</em> /<em> 获取全部对象 /</em> @throws SQLException /<em>/ public <T> List<T> getAll(Class<T> entityClass) throws SQLException { return getSqlMapClient().queryForList(entityClass.getName() + POSTFIX_SELECT, null); } //</em>/<em> /</em> 新增对象 /<em> @throws SQLException /</em>/ public void insert(Object o) throws SQLException { getSqlMapClient().insert(o.getClass().getName() + POSTFIX_INSERT, o); } //<em>/</em> /<em> 保存对象 /</em> @throws SQLException /<em>/ public int update(Object o) throws SQLException { return getSqlMapClient().update(o.getClass().getName() + POSTFIX_UPDATE, o); } //</em>/<em> /</em> 删除对象 /<em> @throws SQLException /</em>/ public int remove(Object o) throws SQLException { return getSqlMapClient().delete(o.getClass().getName() + POSTFIX_DELETE, o); } //<em>/</em> /<em> 根据ID删除对象 /</em> @throws SQLException /<em>/ public <T> int removeById(Class<T> entityClass, Serializable id) throws SQLException { return getSqlMapClient().delete(entityClass.getName() + POSTFIX_DELETE_PRIAMARYKEY, id); } //</em>/<em> /</em> map查询. /<em> /</em> @param map /<em> 包含各种属性的查询 /</em> @throws SQLException /<em>/ public <T> List<T> find(Class<T> entityClass, Map<String, Object> map) throws SQLException { if (map == null) return this.getSqlMapClient().queryForList(entityClass.getName() + POSTFIX_SELECT, null); else { map.put(&quot;findBy&quot;, &quot;True&quot;); return this.getSqlMapClient() .queryForList(entityClass.getName() + POSTFIX_SELECTMAP, map); } } //</em>/<em> /</em> sql 查询. /<em> /</em> @param sql /<em> 直接sql的语句(需要防止注入式攻击) /</em> @throws SQLException /<em>/ public <T> List<T> find(Class<T> entityClass, String sql) throws SQLException { Assert.hasText(sql); if (StringUtils.isEmpty(sql)) return this.getSqlMapClient().queryForList(entityClass.getName() + POSTFIX_SELECT, null); else return this.getSqlMapClient() .queryForList(entityClass.getName() + POSTFIX_SELECTSQL, sql); } //</em>/<em> /</em> 根据属性名和属性值查询对象. /<em> /</em> @return 符合条件的对象列表 /<em> @throws SQLException /</em>/ public <T> List<T> findBy(Class<T> entityClass, String name, Object value) throws SQLException { Assert.hasText(name); Map<String, Object> map = new HashMap<String, Object>(); map.put(name, value); return find(entityClass, map); } //<em>/</em> /<em> 根据属性名和属性值查询对象. /</em> /<em> @return 符合条件的唯一对象 /</em>/ public <T> T findUniqueBy(Class<T> entityClass, String name, Object value) { Assert.hasText(name); Map<String, Object> map = new HashMap<String, Object>(); try { PropertyUtils.getProperty(entityClass.newInstance(), name); map.put(name, value); map.put(&quot;findUniqueBy&quot;, &quot;True&quot;); return (T) getSqlMapClient().queryForObject(entityClass.getName() + POSTFIX_SELECTMAP, map); } catch (Exception e) { logger.error(&quot;Error when propertie on entity,&quot; + e.getMessage(), e.getCause()); return null; } } //<em>/</em> /<em> 根据属性名和属性值以Like AnyWhere方式查询对象. /</em> @throws SQLException /<em>/ public <T> List<T> findByLike(Class<T> entityClass, String name, String value) throws SQLException { Assert.hasText(name); Map<String, Object> map = new HashMap<String, Object>(); map.put(name, value); map.put(&quot;findLikeBy&quot;, &quot;True&quot;); return getSqlMapClient().queryForList(entityClass.getName() + POSTFIX_SELECTMAP, map); } //</em>/<em> /</em> 判断对象某些属性的值在数据库中不存在重复 /<em> /</em> @param tableName /<em> 数据表名字 /</em> @param names /<em> 在POJO里不能重复的属性列表,以逗号分割 如&quot;name,loginid,password&quot; <br> /</em> FIXME how about in different schema? /<em>/ public boolean isNotUnique(Object entity, String tableName, String names) { try { String primarykey; Connection con = getSqlMapClient().getCurrentConnection(); ResultSet dbMetaData = con.getMetaData().getPrimaryKeys(con.getCatalog(), null, tableName); dbMetaData.next(); if (dbMetaData.getRow() &gt; 0) { primarykey = dbMetaData.getString(4); if (names.indexOf(primarykey) &gt; -1) return false; } else { return true; } } catch (SQLException e) { logger.error(e.getMessage(), e); return false; } return false; } //</em>/<em> /</em> 分页查询函数，使用PaginatedList. /<em> /</em> @param pageNo /<em> 页号,从0开始. /</em> @throws SQLException /*/ @SuppressWarnings(&quot;rawtypes&quot;) public DataPage pagedQuery(String sqlName, HashMap<String, Object> hashMap, Integer pageNo, Integer pageSize) throws SQLException { if (pageNo == null || pageSize == null) { List list = getSqlMapClient().queryForList(sqlName, hashMap); if (list == null || list.size() == 0) { return new DataPage(); } else { return new DataPage(0, list.size(), list.size(), list); } } else { Assert.hasText(sqlName); Assert.isTrue(pageNo &gt;= 1, &quot;pageNo should start from 1&quot;); // Count查询 Integer totalCount = (Integer) getSqlMapClient().queryForObject(sqlName + &quot;.Count&quot;, hashMap); if (totalCount &lt; 1) { return new DataPage(); } // 实际查询返回分页对象 int startIndex = DataPage.getStartOfPage(pageNo, pageSize); hashMap.put(&quot;startIndex&quot;, startIndex); hashMap.put(&quot;pageSize&quot;, pageSize); List list = getSqlMapClient().queryForList(sqlName, hashMap); return new DataPage(startIndex, totalCount, pageSize, list); } } public String getMappedSQL(String sqlName) { String sql = null; SqlMapClientImpl sqlmap = (SqlMapClientImpl) getSqlMapClient(); MappedStatement stmt = sqlmap.getMappedStatement(sqlName); StaticSql staticSql = (StaticSql) stmt.getSql(); sql = staticSql.getSql(null, null); return sql; } }</p>
<p><a href="http://blog.csdn.net/boaifeng/article/details/5966940" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/boaifeng/article/details/5966940" title="copy to clipboard" target="_blank">copy to clipboard</a><a href="http://blog.csdn.net/boaifeng/article/details/5966940" title="print" target="_blank">print</a><a href="http://blog.csdn.net/boaifeng/article/details/5966940" title="?" target="_blank">?</a></p>
<ol>
<li><p>package com.nfschina.utils.dao.ibatis;  </p>
</li>
<li></li>
<li><p>import java.io.Serializable;  </p>
</li>
<li><p>import java.lang.reflect.InvocationTargetException;  </p>
</li>
<li><p>import java.sql.SQLException;  </p>
</li>
<li><p>import java.util.List;  </p>
</li>
<li><p>import java.util.Map;  </p>
</li>
<li></li>
<li><p>import org.apache.commons.beanutils.PropertyUtils;  </p>
</li>
<li><p>import org.apache.commons.lang.StringUtils;  </p>
</li>
<li><p>import org.springframework.orm.ObjectRetrievalFailureException;  </p>
</li>
<li></li>
<li><p>import com.nfschina.utils.BaseException;  </p>
</li>
<li><p>import com.nfschina.utils.GenericsUtils;  </p>
</li>
<li></li>
<li><p>import   </p>
</li>
<li><p>//<em>/</em> </p>
</li>
<li><p>/* 负责为单个Entity 提供CRUD操作的IBatis DAO基类. </p>
</li>
<li><p>/* <p/> </p>
</li>
<li><p>/* 子类只要在类定义时指定所管理Entity的Class, 即拥有对单个Entity对象的CRUD操作. </p>
</li>
<li><p>/*  </p>
</li>
<li><p>/* <pre> </p>
</li>
<li><p>/* public class UserManagerIbatis extends IBatisEntityDao<User> { </p>
</li>
<li><p>/* } </p>
</li>
<li><p>/* </pre> </p>
</li>
<li><p>/*/  </p>
</li>
<li><p>public class IBatisEntityDao<T> extends IBatisGenericDao {  </p>
</li>
<li></li>
<li><p>//<em>/</em> </p>
</li>
<li><p>/* DAO所管理的Entity类型. </p>
</li>
<li><p>/*/  </p>
</li>
<li><p>protected Class<T> entityClass;  </p>
</li>
<li></li>
<li><p>protected String primaryKeyName;  </p>
</li>
<li></li>
<li><p>//<em>/</em> </p>
</li>
<li><p>/* 在构造函数中将泛型T.class赋给entityClass. </p>
</li>
<li><p>/*/  </p>
</li>
<li><p>@SuppressWarnings(&quot;unchecked&quot;)  </p>
</li>
<li><p>public IBatisEntityDao() {  </p>
</li>
<li><p>entityClass = (Class<T>) GenericsUtils.getSuperClassGenricType(getClass());  </p>
</li>
<li><p>}  </p>
</li>
<li></li>
<li><p>//<em>/</em> </p>
</li>
<li><p>/* 根据属性名和属性值查询对象. </p>
</li>
<li><p>/*  </p>
</li>
<li><p>/* @return 符合条件的对象列表 </p>
</li>
<li><p>/* @throws SQLException  </p>
</li>
<li><p>/*/  </p>
</li>
<li><p>public List<T> findBy(String name, Object value) throws SQLException {  </p>
</li>
<li><p>return findBy(getEntityClass(), name, value);  </p>
</li>
<li><p>}  </p>
</li>
<li></li>
<li><p>//<em>/</em> </p>
</li>
<li><p>/* 根据属性的名值对查询对象 </p>
</li>
<li><p>/* @param map </p>
</li>
<li><p>/* @return </p>
</li>
<li><p>/* @throws SQLException  </p>
</li>
<li><p>/*/  </p>
</li>
<li><p>public List<T> find(Map<String, Object> map) throws SQLException{  </p>
</li>
<li><p>return find(getEntityClass(), map);  </p>
</li>
<li><p>}  </p>
</li>
<li></li>
<li><p>//<em>/</em> </p>
</li>
<li><p>/* 根据属性的名值对查询唯一对象 </p>
</li>
<li><p>/* @param map </p>
</li>
<li><p>/* @return </p>
</li>
<li><p>/* @throws SQLException </p>
</li>
<li><p>/*/  </p>
</li>
<li><p>public T findUniqueByMap(Map<String, Object> map) throws SQLException{  </p>
</li>
<li><p>List<T> list = find(getEntityClass(), map);  </p>
</li>
<li><p>if(list == null || list.size() &lt;= 0){  </p>
</li>
<li><p>return null;  </p>
</li>
<li><p>}   </p>
</li>
<li><p>return list.get(0);  </p>
</li>
<li><p>}  </p>
</li>
<li></li>
<li><p>//<em>/</em> </p>
</li>
<li><p>/* 根据属性名和属性值以Like AnyWhere方式查询对象. </p>
</li>
<li><p>/* @throws SQLException  </p>
</li>
<li><p>/*/  </p>
</li>
<li><p>public List<T> findByLike(String name, String value) throws SQLException {  </p>
</li>
<li><p>return findByLike(getEntityClass(), name, value);  </p>
</li>
<li><p>}  </p>
</li>
<li></li>
<li><p>//<em>/</em> </p>
</li>
<li><p>/* 根据属性名和属性值查询单个对象. </p>
</li>
<li><p>/*  </p>
</li>
<li><p>/* @return 符合条件的唯一对象 </p>
</li>
<li><p>/*/  </p>
</li>
<li><p>public T findUniqueBy(String name, Object value) {  </p>
</li>
<li><p>return findUniqueBy(getEntityClass(), name, value);  </p>
</li>
<li><p>}  </p>
</li>
<li></li>
<li><p>//<em>/</em> </p>
</li>
<li><p>/* 根据ID获取对象. </p>
</li>
<li><p>/*  </p>
</li>
<li><p>/* @throws BaseException </p>
</li>
<li><p>/* @throws SQLException  </p>
</li>
<li><p>/*/  </p>
</li>
<li><p>public T get(Serializable id) throws BaseException, SQLException {  </p>
</li>
<li><p>return get(getEntityClass(), id);  </p>
</li>
<li><p>}  </p>
</li>
<li></li>
<li><p>//<em>/</em> </p>
</li>
<li><p>/* 获取全部对象. </p>
</li>
<li><p>/* @throws SQLException  </p>
</li>
<li><p>/*/  </p>
</li>
<li><p>public List<T> getAll() throws SQLException {  </p>
</li>
<li><p>return getAll(getEntityClass());  </p>
</li>
<li><p>}  </p>
</li>
<li></li>
<li><p>//<em>/</em> </p>
</li>
<li><p>/* 取得entityClass. </p>
</li>
<li><p>/* <p/> </p>
</li>
<li><p>/* JDK1.4不支持泛型的子类可以抛开Class<T> entityClass,重载此函数达到相同效果。 </p>
</li>
<li><p>/*/  </p>
</li>
<li><p>protected Class<T> getEntityClass() {  </p>
</li>
<li><p>return entityClass;  </p>
</li>
<li><p>}  </p>
</li>
<li></li>
<li><p>public String getPrimaryKeyName() {  </p>
</li>
<li><p>if (StringUtils.isEmpty(primaryKeyName))  </p>
</li>
<li><p>primaryKeyName = &quot;id&quot;;  </p>
</li>
<li><p>return primaryKeyName;  </p>
</li>
<li><p>}  </p>
</li>
<li></li>
<li><p>protected Object getPrimaryKeyValue(Object o) throws NoSuchMethodException, IllegalAccessException,  </p>
</li>
<li><p>InvocationTargetException, InstantiationException {  </p>
</li>
<li><p>return PropertyUtils.getProperty(entityClass.newInstance(), getPrimaryKeyName());  </p>
</li>
<li><p>}  </p>
</li>
<li></li>
<li><p>//<em>/</em> </p>
</li>
<li><p>/* 根据ID移除对象. </p>
</li>
<li><p>/* @throws SQLException  </p>
</li>
<li><p>/*/  </p>
</li>
<li><p>public int removeById(Serializable id) throws SQLException {  </p>
</li>
<li><p>return removeById(getEntityClass(), id);  </p>
</li>
<li><p>}  </p>
</li>
<li></li>
<li><p>//<em>/</em> </p>
</li>
<li><p>/* 保存对象. 为了实现IEntityDao 我在内部使用了insert和upate 2个方法. </p>
</li>
<li><p>/* @throws SQLException  </p>
</li>
<li><p>/*/  </p>
</li>
<li><p>public void saveOrUpdate(Object o) throws SQLException {  </p>
</li>
<li><p>Object primaryKey;  </p>
</li>
<li><p>try {  </p>
</li>
<li><p>primaryKey = getPrimaryKeyValue(o);  </p>
</li>
<li><p>} catch (Exception e) {  </p>
</li>
<li><p>throw new ObjectRetrievalFailureException(entityClass, e);  </p>
</li>
<li><p>}  </p>
</li>
<li></li>
<li><p>if (primaryKey == null)  </p>
</li>
<li><p>insert(o);  </p>
</li>
<li><p>else  </p>
</li>
<li><p>update(o);  </p>
</li>
<li><p>}  </p>
</li>
<li></li>
<li><p>public void setPrimaryKeyName(String primaryKeyName) {  </p>
</li>
<li><p>this.primaryKeyName = primaryKeyName;  </p>
</li>
<li><p>}  </p>
</li>
<li></li>
<li><p>public String getIdName(Class&lt;?&gt; clazz) {  </p>
</li>
<li><p>return &quot;id&quot;;  </p>
</li>
<li><p>}  </p>
</li>
<li><p>}  </p>
</li>
</ol>
<p>package com.nfschina.utils.dao.ibatis; import java.io.Serializable; import java.lang.reflect.InvocationTargetException; import java.sql.SQLException; import java.util.List; import java.util.Map; import org.apache.commons.beanutils.PropertyUtils; import org.apache.commons.lang.StringUtils; import org.springframework.orm.ObjectRetrievalFailureException; import com.nfschina.utils.BaseException; import com.nfschina.utils.GenericsUtils; import //<em>/</em> /<em> 负责为单个Entity 提供CRUD操作的IBatis DAO基类. /</em> <p/> /<em> 子类只要在类定义时指定所管理Entity的Class, 即拥有对单个Entity对象的CRUD操作. /</em> /<em> <pre> /</em> public class UserManagerIbatis extends IBatisEntityDao<User> { /<em> } /</em> </pre> /<em>/ public class IBatisEntityDao<T> extends IBatisGenericDao { //</em>/<em> /</em> DAO所管理的Entity类型. /<em>/ protected Class<T> entityClass; protected String primaryKeyName; //</em>/<em> /</em> 在构造函数中将泛型T.class赋给entityClass. /<em>/ @SuppressWarnings(&quot;unchecked&quot;) public IBatisEntityDao() { entityClass = (Class<T>) GenericsUtils.getSuperClassGenricType(getClass()); } //</em>/<em> /</em> 根据属性名和属性值查询对象. /<em> /</em> @return 符合条件的对象列表 /<em> @throws SQLException /</em>/ public List<T> findBy(String name, Object value) throws SQLException { return findBy(getEntityClass(), name, value); } //<em>/</em> /<em> 根据属性的名值对查询对象 /</em> @param map /<em> @return /</em> @throws SQLException /<em>/ public List<T> find(Map<String, Object> map) throws SQLException{ return find(getEntityClass(), map); } //</em>/<em> /</em> 根据属性的名值对查询唯一对象 /<em> @param map /</em> @return /<em> @throws SQLException /</em>/ public T findUniqueByMap(Map<String, Object> map) throws SQLException{ List<T> list = find(getEntityClass(), map); if(list == null || list.size() &lt;= 0){ return null; } return list.get(0); } //<em>/</em> /<em> 根据属性名和属性值以Like AnyWhere方式查询对象. /</em> @throws SQLException /<em>/ public List<T> findByLike(String name, String value) throws SQLException { return findByLike(getEntityClass(), name, value); } //</em>/<em> /</em> 根据属性名和属性值查询单个对象. /<em> /</em> @return 符合条件的唯一对象 /<em>/ public T findUniqueBy(String name, Object value) { return findUniqueBy(getEntityClass(), name, value); } //</em>/<em> /</em> 根据ID获取对象. /<em> /</em> @throws BaseException /<em> @throws SQLException /</em>/ public T get(Serializable id) throws BaseException, SQLException { return get(getEntityClass(), id); } //<em>/</em> /<em> 获取全部对象. /</em> @throws SQLException /<em>/ public List<T> getAll() throws SQLException { return getAll(getEntityClass()); } //</em>/<em> /</em> 取得entityClass. /<em> <p/> /</em> JDK1.4不支持泛型的子类可以抛开Class<T> entityClass,重载此函数达到相同效果。 /<em>/ protected Class<T> getEntityClass() { return entityClass; } public String getPrimaryKeyName() { if (StringUtils.isEmpty(primaryKeyName)) primaryKeyName = &quot;id&quot;; return primaryKeyName; } protected Object getPrimaryKeyValue(Object o) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException { return PropertyUtils.getProperty(entityClass.newInstance(), getPrimaryKeyName()); } //</em>/<em> /</em> 根据ID移除对象. /<em> @throws SQLException /</em>/ public int removeById(Serializable id) throws SQLException { return removeById(getEntityClass(), id); } //<em>/</em> /<em> 保存对象. 为了实现IEntityDao 我在内部使用了insert和upate 2个方法. /</em> @throws SQLException /*/ public void saveOrUpdate(Object o) throws SQLException { Object primaryKey; try { primaryKey = getPrimaryKeyValue(o); } catch (Exception e) { throw new ObjectRetrievalFailureException(entityClass, e); } if (primaryKey == null) insert(o); else update(o); } public void setPrimaryKeyName(String primaryKeyName) { this.primaryKeyName = primaryKeyName; } public String getIdName(Class&lt;?&gt; clazz) { return &quot;id&quot;; } }</p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/框架汇总/">框架汇总</a></li></span><span class="breadcrumb"><li><a href="/categories/框架汇总/">框架汇总</a></li><li><a href="/categories/框架汇总/ORM/">ORM</a></li><li><a href="/categories/框架汇总/ORM/ibatis/">ibatis</a></li></span></span> | <span class="tags">Tagged <a href="/tags/ORM/" class="label label-primary">ORM</a><a href="/tags/ibatis/" class="label label-success">ibatis</a><a href="/tags/框架汇总/" class="label label-info">框架汇总</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:29"datetime="2014-03-07 09:54:29"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-框架汇总-ORM-ibatis--使用ibatis操作数据库的封装/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-框架汇总-ORM-ibatis--使用ibatis操作数据库的封装" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>





<ul id="pagination" class="pagination pagination-lg">
  <li><a class="extend prev" href="/page/146/">&laquo;</a></li><li><a class="page-number" href="/">1</a></li><li><a class="page-number" href="/page/2/">2</a></li><li><span class="space">&hellip;</span></li><li><a class="page-number" href="/page/144/">144</a></li><li><a class="page-number" href="/page/145/">145</a></li><li><a class="page-number" href="/page/146/">146</a></li><li class="active"><li><span class="page-number current">147</span></li><li><a class="page-number" href="/page/148/">148</a></li><li><a class="page-number" href="/page/149/">149</a></li><li><a class="page-number" href="/page/150/">150</a></li><li><span class="space">&hellip;</span></li></li><li><a class="page-number" href="/page/164/">164</a></li><li><a class="page-number" href="/page/165/">165</a></li><li><a class="extend next" href="/page/148/">&raquo;</a></li>
  <div class="clearfix"></div>
</ul></div><!--wapper-->
       </div><!-- ID main-col END -->
       <aside id="sidebar" class="alignright col-sx-6 col-sm-4 col-md-3 col-lg-3">
<div id="widget_search" class="widget panel panel-primary">
    <form action="//google.com/search" method="get" accept-charset="utf-8">
  <div class="input-group">
    <input class="form-control" id="searchbox" type="search" name="q" results="0" placeholder="search">
    <span class="input-group-btn">
      <button class="btn btn-default" type="submit">Go!</button>
    </span>
    <input type="hidden" name="q" value="site:itsolife.com">
  </div>
</form>
</div>

<div id="widget_category" class="widget panel panel-primary">
  <div class="panel-heading">category</div>  <div data-src='category' class='ajax_widgets'>正在加载...</div>
</div>

<div id="widget_recent_posts" class="widget panel panel-primary">
  <div class="panel-heading">recent posts</div>  <div data-src='recent_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_tagcloud" class="widget panel panel-primary">
  <div class="panel-heading">tagcloud</div>  <div data-src='tagcloud' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_latest_update_posts" class="widget panel panel-primary">
  <div class="panel-heading">最近更新</div>  <div data-src='latest_update_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_recent_comments" class="widget panel panel-primary">
  <div class="panel-heading">recent comments</div>  

<div class="list-group-item ds-recent-comments" data-num-items="6" data-show-avatars="1" data-show-time="1" data-show-title="1" data-show-admin="1" data-excerpt-length="50"></div>



</div>

</aside>
       <div class="clearfix"></div>
     </div><!-- row END -->
  </div>
  <footer id="footer" class="container">
  <div class="panel panel-info">
  <section id='footer_widget'></section>  <div class="panel-footer">
  <div id="site-info">
    <span class='author'>
  
  &copy; 2014 RobinChia
  
    &nbsp;&nbsp;</span>
  
  <span id='analytics-51la'></span><span id='analytics-google'>
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-48559895-1']);
  _gaq.push(['_trackPageview']);
  _js2load.push({src:('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'});
</script></span><span id='analytics-cnzz'>
<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_5774006'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s17.cnzz.com/stat.php%3Fid%3D5774006%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>
</span><span id='analytics-baidu'>
<script>
var _hmt = _hmt || [];
_js2load.push({src:"//hm.baidu.com/hm.js?1442f50724afc42380b51f097c43082c"});
</script>
</span>  </div>
  <div id="copyright">Blog powered by <a href='http://zespia.tw/hexo/'><strong>hexo</strong></a> Theme <strong><a href='https://github.com/chenall/hexo-theme-chenall'>chenall</a></strong>(Some change in it)<span class="pull-right"> 更新时间: <em>2014-03-15 16:01:37</em></span></div>
</div>
<div class="clearfix"></div>


  </div>
  </footer>
  
        <script src="http://cdn.bootcss.com/jquery/1.10.2/jquery.min.js"></script>        
        <script src="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/js/bootstrap.min.js"></script>        
                
        <script src="http://cdn.bootcss.com/prettify/r298/prettify.min.js"></script>    <script type="text/javascript">
   var lang=["bsh", "c", "cc", "cpp", "cs", "csh", "cyc", "cv", "htm", "html",
    "java", "js", "m", "mxml", "perl", "pl", "pm", "py", "rb", "sh",
    "xhtml", "xml", "xsl"];
   var pretty_base='';
   $('script').each(function(){
	var c = $(this).attr('src');
	if (!c)
	    return;
	if (c.match(/(\/)?prettify(\.min)?\.js/i))
	{
	    var index = c.lastIndexOf('/');
	    if (index != -1)
		pretty_base = c.substr(0,index + 1);
	    return false;
	}
   })
   $('pre code').each(function(){
	var c = $(this).attr('class')
	if (!c)
	    return;
	c = c.match(/\s?(lang\-\w+)/i);
	if (c && lang.indexOf(c[1]) == -1)
	{
	    lang.push(c[1]);
	    $.getScript(pretty_base + c[1] + '.min.js');
	}
   })

    $(window).load(function(){
       $("pre").addClass("prettyprint");
       prettyPrint();
    })
</script>    
            <script type="text/javascript">
var duoshuoQuery = {short_name:"robinchia"};
_js2load.push({src:'http://static.duoshuo.com/embed.js',charset:'UTF-8'});
</script>
    
            <!--wumii_relatedItems-->
    
        <script src="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js"></script>    <script type="text/javascript">
(function($){
  $('.entry').each(function(i){
    $(this).find('img').each(function(){
      var alt = this.alt;

      if (alt){
        $(this).before('<span class="caption">' + alt + '</span>');
      }

      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox" rel="fancybox' + i + '" />');
    });
  });

  $('.fancybox').fancybox();
})(jQuery);
</script>    
        <script src="http://cdn.bootcss.com/mathjax/2.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>    <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>
    
<script type="text/javascript">
$('.ajax_widgets').each(function(){var src=$(this).attr('data-src');if(src)$(this).load('/widgets/'+src+'.html');});
$.each(_js2load,function(index,obj){loadjs(obj.src,obj.charset)});
</script>

<div id="scroll2top">
<img src="/scroll2top/arrow.png"/>
</div>
<script src="/scroll2top/scroll2top.min.js"></script>
<div id="winterland">
  <canvas></canvas>
</div>
<script src="/js/winterland.min.js"></script>

  </body>
</html>
