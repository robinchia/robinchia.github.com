
<!DOCTYPE HTML>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>The 147 Page | It so life</title>
<meta name="author" content="RobinChia">

<meta name="description" content="It so life">


<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<meta property="og:site_name" content="It so life"/>

<!--[if IE]><style>.testIE.IE{display:inline;}</style><![endif]-->
<!--[if lte IE 7]><link rel="stylesheet" href="/css/ie7.css" type="text/css"><![endif]-->
<!--[if (lt IE 9)&(gt IE 7)]><style>.testIE.IE8{display:inline;}</style><![endif]-->
<!--[if gt IE 8]><style>.testIE.IE9{display:inline;}</style><![endif]-->

<link href="/favicon.png" rel="icon">
<link rel="alternate" href="/atom.xml" title="It so life Feed" type="application/atom+xml">

<link rel="stylesheet" href="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/css/bootstrap.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/font-awesome/4.0.3/css/font-awesome.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/prettify/r298/prettify.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" type="text/css">
<link rel="stylesheet" href="/css/style.css" type="text/css">
<!--[if lt IE 9]>
   <style>article,aside,dialog,footer,header,section,footer,nav,figure,menu{display:block}</style>
   <script src="http://cdn.staticfile.org/html5shiv/r29/html5.min.js"></script>
   <script src="http://cdn.staticfile.org/respond.js/1.4.2/respond.min.js"></script>
<link href="http://cdn.staticfile.org/respond.js/1.4.2/respond-proxy.html" id="respond-proxy" rel="respond-proxy" />
<link href="/js/respond.proxy.gif" id="respond-redirect" rel="respond-redirect" />
<script src="/js/respond.proxy.js"></script>
   <script src="http://cdn.bootcss.com/selectivizr/1.0.2/selectivizr-min.js"></script>
<![endif]-->
<script type="text/javascript">
function loadjs(c,d){var a=document.createElement("script");a.async=!0;a.type="text/javascript";a.src=c;a.charset=d||"gbk";(document.getElementsByTagName("HEAD")[0]||document.getElementsByTagName("BODY")[0]).appendChild(a)};
var _protocol = (("https:" == document.location.protocol) ? " https://" : " http://");
var _js2load = [];
</script>

</head>
<body>
      <header id="header" class="container"><nav id="main-nav" class="navbar navbar-default navbar-fixed-top " role="navigation">
  <div class="container">
    <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
      <span class="sr-only">Toggle navigation</span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="/">It so life</a>
    </div>
    <div  class="collapse navbar-collapse">
      <ul  class="nav navbar-nav">
  
        <li><a href="/" title="Home">Home</a></li>      
        <li><a href="/about/" title="About">About</a></li>      
        <li><a href="/archives/" title="Archives">Archives</a></li>      
      <li class='dropdown'>
        <a class='dropdown-toggle' data-toggle='dropdown' href='#'>website<b class='caret'></b></a>
        <ul class='dropdown-menu pure-menu-selected'>
    
          <li><a href="//groups.google.com/forum/#!forum/pongba" title="TopLanguage">TopLanguage</a></li>    
          <li><a href="//itpub.net/" title="ITPub">ITPub</a></li>    
          <li><a href="//blog.jobbole.com/" title="Bole">Bole</a></li>    
          <li><a href="//nosql-database.org/" title="nosql">nosql</a></li>    
          <li><a href="//gitimmersion.googol.im/" title="Git">Git</a></li>    
        </ul>
      </li>
    
      </ul>
      <ul class="nav navbar-nav navbar-right">
      
        <li><a href="/atom.xml">RSS</a></li>
      
      
        <li><a href="https://twitter.com/robinchia">twitter</a></li>
      
      
      
      
        <li><a href="https://github.com/robinchia">github</a></li>
      
      </ul>
    </div>
  </div>
</nav>
<div class="clearfix"></div>
</header>
  <div id='content' class="container">
     <div class="page-header-wrapper">
      <!--[if lt IE 9]><div class="alert alert-warning alert-dismissable"><button type="button" class="close" data-dismiss="alert" aria-hidden="true">&times;</button><strong>提示:</strong>您的浏览器版本太低了,建议升级到 <strong><a href="http://windows.microsoft.com/zh-cn/internet-explorer/download-ie" title="IE9">IE9</a></strong> 以上,本站使用<a href="https://www.google.com/intl/zh-CN/chrome/">Chrome浏览器</a>可以获得最好的显示效果.</div><![endif]-->
      <div class="page-header"><h1 align="center"><big>It so life</big> </h1>
        <h5 align="center"><big>love as life</big></h5>
      </div>
     </div>
     <div class="row">
       <div id="main-col" class="alignleft col-sx-12 col-sm-8 col-md-9 col-lg-9">
      <section id='header_widget'></section>
          <div id="wrapper"><article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-框架汇总-ORM-hibernate--Hibernate性能调优（转载--作者：RobbinFan）/">Hibernate性能调优（转载</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T09:54:29.000Z"> <a href="/2014/02/02/2014-02-02-框架汇总-ORM-hibernate--Hibernate性能调优（转载--作者：RobbinFan）/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="hibernate-robbin-fan-">Hibernate性能调优（转载--作者：Robbin Fan）</h1>
<hr>
<p><strong>一。**</strong>inverse = ?**</p>
<pre><code>      inverse=false(default)

                  用于单向one-to-many关联

                  parent.getChildren().add(child) // insert child

                  parent.getChildren().delete(child) // delete child

       inverse=true

                  用于双向one-to-many关联

                  child.setParent(parent); session.save(child) // insert child

                   session.delete(child)

        在分层结构的体系中

         parentDao, childDao对于CRUD的封装导致往往直接通过session接口持久化对象，而很少通过关联对象可达性
</code></pre><p><strong>二。**</strong>one-to-many<strong>**关系</strong></p>
<pre><code>            单向关系还是双向关系？

                 parent.getChildren().add(child)对集合的触及操作会导致lazy的集合初始化，在没有对集合配置二级缓存的情况下，应避免此类操作

               select /* from child where parent_id = xxx;

      性能口诀：

              1. 一般情况下避免使用单向关联，尽量使用双向关联

              2. 使用双向关联，inverse=“true”

              3. 在分层结构中通过DAO接口用session直接持久化对象，避免通过关联关系进行可达性持久化
</code></pre><p><strong>三。**</strong>many-to-one<strong>**关系</strong></p>
<pre><code>     单向many-to-one表达了外键存储方

     灵活运用many-to-one可以避免一些不必要的性能问题

     many-to-one表达的含义是：0..n : 1，many可以是0，可以是1，也可以是n，也就是说many-to-one可以表达一对多，一对一，多对一关系

      因此可以配置双向many-to-one关系，例如：

            1.   一桌四人打麻将，麻将席位和打麻将的人是什么关系？是双向many-to-one的关系
</code></pre><p><strong>四。**</strong>one-to-one**</p>
<pre><code>        通过主键进行关联

        相当于把大表拆分为多个小表

        例如把大字段单独拆分出来，以提高数据库操作的性能

        Hibernate的one-to-one似乎无法lazy，必须通过bytecode enhancement
</code></pre><p><strong>五。集合**</strong>List/Bag/Set**</p>
<pre><code>        one-to-many

           1.    List需要维护index column，不能被用于双向关联，必须inverse=“false”，被谨慎的使用在某些稀有的场合

           2.      Bag/Set语义上没有区别

           3.       我个人比较喜欢使用Bag

       many-to-many

           1.      Bag和Set语义有区别

           2。   建议使用Set
</code></pre><p><strong>六。集合的过滤</strong></p>
<pre><code>         1. children = session.createFilter(parent.getChildren(), “where this.age &gt; 5 and   this.age &lt; 10”).list()

     针对一对多关联当中的集合元素非常庞大的情况，特别适合于庞大集合的分页：

               session.createFilter(parent.getChildren(),“”).setFirstResult(0).setMaxResults(10).list();
</code></pre><p>在hibernate 中用 super.getSession().createFilter( , )</p>
<p><strong>七。继承关系当中的隐式多态</strong></p>
<pre><code>       HQL: from Object

         1.     把所有数据库表全部查询出来

          2.     polymorphism=“implicit”(default)将当前对象，和对象所有继承子类全部一次性取出

          3.      polymorphism=“explicit”，只取出当前查询对象
</code></pre><p><strong>八。**</strong>Hibernate<strong>**二级缓存</strong></p>
<pre><code>          著名的n+1问题：from Child，然后在页面上面显示每个子类的父类信息，就会导致n条对parent表的查询：

               select /* from parent where id = ?

               .......................

               select /* from parent where id = ?

          解决方案

                    1.      eager fetch

                     2.      二级缓存
</code></pre><p><strong>九。**</strong>inverse<strong>**和二级缓存的关系</strong></p>
<pre><code>        当使用集合缓存的情况下：

             1.     inverse=“false”，通过parent.getChildren()来操作，Hibernate维护集合缓存

              2.    inverse=“true”，直接对child进行操作，未能维护集合缓存！导致缓存脏数据

              3.    双向关联，inverse=“true”的情况下应避免使用集合缓存
</code></pre><p><strong>十。**</strong>Hibernate<strong><strong>二级缓存是提升</strong></strong>web<strong>**应用性能的法宝</strong></p>
<pre><code>          OLTP类型的web应用，由于应用服务器端可以进行群集水平扩展，最终的系统瓶颈总是逃不开数据库访问；

       哪个框架能够最大限度减少数据库访问，降低数据库访问压力， 哪个框架提供的性能就更高；针对数据库的缓存策略：

                1.        对象缓存：细颗粒度，针对表的记录级别，透明化访问，在不改变程序代码的情况下可以极大提升web应用的性能。对象缓存是ORM的制胜法宝。

                2.       对象缓存的优劣取决于框架实现的水平，Hibernate是目前已知对象缓存最强大的开源ORM

                3.        查询缓存：粗颗粒度，针对查询结果集，应用于数据实时化要求不高的场合
</code></pre><p><strong>十一。应用场合决定了系统架构</strong></p>
<p>一、是否需要ORM</p>
<p>Hibernate or iBATIS？</p>
<p>二、采用ORM决定了数据库设计</p>
<pre><code>        Hibernate：

                倾向于细颗粒度的设计，面向对象，将大表拆分为多个关联关系的小表，消除冗余column，通过二级缓存提升性能（DBA比较忌讳关联关系的出现，但是ORM的缓存将突破关联关系的性能瓶颈）；Hibernate的性能瓶颈不在于关联关系，而在于大表的操作

        iBATIS：

                倾向于粗颗粒度设计，面向关系，尽量把表合并，通过表column冗余，消除关联关系。无有效缓存手段。iBATIS的性能瓶颈不在于大表操作，而在于关联关系。
</code></pre><p>总结：</p>
<pre><code> 性能口诀

           1、使用双向一对多关联，不使用单向一对多

           2、灵活使用单向多对一关联

           3、不用一对一，用多对一取代

           4、配置对象缓存，不使用集合缓存

           5、一对多集合使用Bag，多对多集合使用Set

           6、继承类使用显式多态

           7、表字段要少，表关联不要怕多，有二级缓存撑腰
</code></pre><p>最近开始留意项目中的Hibernate的性能问题，希望可以抽出时间学习一下hiberante的性能优化。主要是对数据库连接池技术、hibernate二级缓存、hibernate的配置优化等问题进行学习！</p>
<p>1.关联关系：</p>
<p>普通的关联关系：是不包括一个连接表，也就是中间表如：</p>
<p>create table Person(personId bigint not null primary key,addressId bigint not null)</p>
<p>create table Address(addressId bigint not null primary key)</p>
<p>也就是不会还有一个关系表如：</p>
<p>create table Person(personId bigint not null primary key)</p>
<p>create table Address(addressId bigint not null primary key)</p>
<p>create table PersonAddress(personId bigint not null,ddressId bigint not null primary key)</p>
<p>单向many-to-one关联是最常见的，而单向one-to-many是不常见的</p>
<ol>
<li>inner join(内连接)</li>
</ol>
<p>left (outer) join（左外连接）</p>
<p>right (outer) join (右外连接)</p>
<p>full join (全连接，并不常用)</p>
<p>3.小技巧：</p>
<p>统计结果数目：</p>
<p>(Integer)session.iterator(&quot;select count(/*) from ..&quot;).next()).intValue();</p>
<p>根据一个集合大小来排序：</p>
<p>select user.id,user.name</p>
<p>from User as user.name</p>
<pre><code>left join user.messages msg
</code></pre><p>group by user.id,user.name</p>
<p>having count(msg)&gt;=1</p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/框架汇总/">框架汇总</a></li></span><span class="breadcrumb"><li><a href="/categories/框架汇总/">框架汇总</a></li><li><a href="/categories/框架汇总/ORM/">ORM</a></li><li><a href="/categories/框架汇总/ORM/hibernate/">hibernate</a></li></span></span> | <span class="tags">Tagged <a href="/tags/ORM/" class="label label-primary">ORM</a><a href="/tags/hibernate/" class="label label-success">hibernate</a><a href="/tags/框架汇总/" class="label label-info">框架汇总</a></span> | <span class="time">recent updated:<time title="2014-03-07 01:54:29"datetime="2014-03-07 01:54:29"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-框架汇总-ORM-hibernate--Hibernate性能调优（转载--作者：RobbinFan）/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-框架汇总-ORM-hibernate--Hibernate性能调优（转载--作者：RobbinFan）" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-框架汇总-activemq--activemq的网络层介绍/">activemq的网络层介绍</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T09:54:29.000Z"> <a href="/2014/02/02/2014-02-02-框架汇总-activemq--activemq的网络层介绍/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="activemq-">activemq的网络层介绍</h1>
<p>#</p>
<h3 id="-">概要</h3>
<p>activemq是一个apache的顶级项目，其实现了<a href="http://www.goldendoc.org/2011/08/jms_spec_message/" title="JMS规范介绍(1) JMS消息" target="_blank">JMS规范</a>，作为一个开源的JMS实现，activemq已经在很多地方得到了应用。同时，开源小组在研究JMS实现的时候，也选择了activemq作为研究对象，希望能够读其源码，让<a href="http://www.goldendoc.org/" title="开源学习小组：黄金档" target="_blank">开源小组</a>更好的明白JMS规范和实现。</p>
<p>在学习activemq的时候，我们发现还不能一下子就进去学习JMS规范的实现，而是需要了解其底层代码，包括其对网络连接的处理等等。所以，这篇文章就学习了<a href="http://www.goldendoc.org/2011/09/activemq-network-process/" title="activemq的网络层实现" target="_blank">activemq的网络层实现</a>。</p>
<h3 id="activemq-">activemq网络层概念</h3>
<p>activemq 是支持多协议的，因此，把单一协议的server抽象成更高一层，就很有意义，请看下面这张图：
<a href="http://www.goldendoc.org/wp-content/uploads/2011/09/activemq%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A51.png" target="_blank"><img src="" alt=""></a></p>
<p>在activemq中，差不多每种概念都有生命周期（见Service接口）。
这张图十分简单，实际中当然比这个要复杂。下面针对每个概念进行叙述。</p>
<h3 id="transport">Transport</h3>
<p>Transport 应该算是很底层的概念，他封装了 Socket，职责是发送和接受连接方的信息。
同时，在Transport中，增加了同步和异步的概念。
Transport拥有一个TransportListener。</p>
<h3 id="transportlistener">TransportListener</h3>
<p>顾名思义，TransportListener 就是监听 Transport 事件的发生以及做出一定的反映。
在activemq中，正是利用了 TransportListener 对 Command 进行处理 —— Command 是 activemq 网络传递的形式，每个请求都会被反序列化成一个 Command。</p>
<h3 id="transportserver">TransportServer</h3>
<p>就是一个server实例，他会处理外部进来的Socket，进而封装成 Transport 。此 Server 拥有一个 TransportAcceptListener 。</p>
<h3 id="transportacceptlistener">TransportAcceptListener</h3>
<p>负责 Accept Transport，将 Transport 封装成 Connection，从而开启 Connection 的生命周期。
这里需要注意的是：TransportServer 将 Socket 封装成 Transport，而 TransportAcceptListener 将 Transport 封装成 Connection。</p>
<h3 id="connection">Connection</h3>
<p>可以理解成业务层面上的连接。 Connection 会给相应的 Transport 设置 TransportListener ，从而获取底层 Socket 的活动情况，进行业务的处理。</p>
<h3 id="connector">Connector</h3>
<p>Connector就是较高层次的抽象，它代表对外的连接器，每个连接器都可以支持不同的协议。
Connector 通过给 TransportServer 设置 TransportAcceptListener ，从而能够控制 Transport 并产生相应的 Connection。</p>
<h3 id="-">总结</h3>
<p>总体来说，两个Listener是连接 Conncetor与TransportServer 和 Connection和Transport 的关键概念。
至于为什么要分成 Connector ， TransportServer 这两层，我想原因应该就是开头提到的： activemq需要支持多协议，因此 Connector 抽象起来，可以当作是针对不同协议的统一行为；而 TransportServer 就是针对各协议的具体实现。 对于 Connection,Transport 来说， Connector 是与 Connection 统一层次， Transport 是与 TransportServer 统一层次。
如果读者有时间，还可以查看<a href="http://www.goldendoc.org/" title="开源小组" target="_blank">开源小组</a>当时分析的<a href="http://www.goldendoc.org/wp-content/uploads/2011/09/activemq%E7%BD%91%E7%BB%9C%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.png" target="_blank">activemq网络连接序列图</a>（是基于TcpTransportServer的，图像有点大，需要耐心看）</p>
<p><img src="" alt="">
来源： <a href="[http://www.goldendoc.org/2011/09/activemq-network-process/](http://www.goldendoc.org/2011/09/activemq-network-process/)">[http://www.goldendoc.org/2011/09/activemq-network-process/](http://www.goldendoc.org/2011/09/activemq-network-process/)</a></p>
<p>本文会把主要篇幅集中在这几个组件的创建时期，运行时期来讲解，最后会总结一下这几个组建使用的线程情况。一下的分析是基于 bio 的（nio 也是在这个结构当中，只是行为是基于 nio 特点的）。在<a href="http://www.goldendoc.org/2011/09/activemq-network-process/" title="activemq的网络层介绍（一）" target="_blank">activemq的网络层介绍（一）</a>也讲过，activemq中很多组件都实现了 Service 接口，而 Service 接口的作用就是赋予实现者有生命周期的意义。</p>
<h3 id="transportconnector">TransportConnector</h3>
<p>TransportConnector 是 Connector 的实现，是基于 Transport 的 Connector（目前activemq的Connector实现，也就是基于Transport的）。其内部依赖了 TransportServer ，这个也容易理解，因为这个 Connector 是基于 Transport 的。因此 TransportServer 也是其所重点依赖的组件。 值得注意的是 TransportServer 的 AcceptListener 也是在 TransportConnector 中指定的，具体见下文。</p>
<h3 id="transportconnector-">TransportConnector 的创建</h3>
<p>TransportConnector 的创建比较简单，直接接受传入进来的 TransportServer （关于 TransportServer 的创建，详见下文）。</p>
<h3 id="transportconnector-">TransportConnector 的运行</h3>
<p>TransportConnector 是一个 Service，有自己的生命周期。因此，在 activemq 开始的时候，其生命周期，会被启动（具体表现为被调用 start 方法）。</p>
<p>在 TransportConnector 的 start 方法中，可以很明显的看到两个主要的逻辑：为 TransportServer 设置一个匿名的 AcceptListener ，调用 TransportServer 启动。</p>
<p>对于 TransportConnector 为 TransportServer 设置的 AcceptListener，其逻辑主要是当 TransportServer 接收到传输进来的 Transport（由 TransportServer 将 Socket 封装成 Transport）之后，将 Transport 封装成 Connection ，并且启动 Connection 的生命周期。这里也不难理解：在<a href="http://www.goldendoc.org/2011/09/activemq-network-process/" title="activemq的网络层介绍（一）" target="_blank">activemq网络层介绍（一）</a>中也讲过， Connector 是与 Connection 一个层次的，TransportServer 与 Transport 是一个层次的。因此，将 AcceptListener 的匿名实现放在 TransportConnector 中，也就很好理解了。</p>
<h3 id="connection">Connection</h3>
<p>在 TransportServer 的 AcceptListener 收到传输进来的 Transport 之后，就创建了 Connection（实际类型是 TransportConnection），然后为 Connection 开启生命周期。
但一个Socket是从什么时候传进来，进而被封装成 Transport 的，会在下文有描述。现在让我们跟着 TransportConnection ，看看他是如何被创建的，以及在它的生命周期中，会做什么事情。</p>
<h3 id="transportconnection-">TransportConnection 的创建</h3>
<p>TransportConnection 是在 AcceptListener 收到 TransportServer 传进来的 Transport 之后创建的。可以想象，TransportConnection 是封装了 Transport 的。同时， Transport 的 TransportListener ，也是在 TransportConnection 的构造方法中进行了创建。此 TransportListener 的逻辑就是服务一个 Command (Command是 activemq 实例之间交互的基本对象，任何请求和响应都被activemq 序列化成一个 Command)，在得到响应的时候，进行分发（响应其实也是一个Command）。</p>
<h3 id="transportconnection-">TransportConnection 的运行</h3>
<p>在开始说 TransportConnection 的生命周期之前，可以先说一下 activemq 的 Task 接口，此接口有一个 iterate 遍历方法，activemq 一般对这个接口的用法都是使用一个线程去跑 iterater 方法，直到 iterater 返回 false 。一般的，iterater 方法里面都是在重复的做一段逻辑，只不过是这个逻辑实施的对象不一样而已。TransportConnection 正是实现了此接口。</p>
<p>在 TransportConnection 的 start 方法中，主要做了两件事情：创建一个 taskRunner ，以做好跑 Task 的准备（就是在另起线程跑自己的 Iiterater 方法）；调用 Transport 的 Start 方法，开启 Transport 的生命周期。</p>
<p>在 TransportConnection 自己的 Iiterater 方法中，就是到一个队列中取出 Command，并且使用 Transport 的 oneWay，将 Command 发送出去。</p>
<h3 id="transportserver">TransportServer</h3>
<p>按理说要接下来讲 Transport，但如果不先把 TransportServer 弄清出的话， Transport 还是有些难以理解的。因为是 TransportServer 将 接受到的 Socket 封装成 Transport。这里说的是 TransportServer 的实现， TcpTransportServer。</p>
<h3 id="tcptransportserver-">TcpTransportServer 的创建</h3>
<p>TransportServer 是由 TransportFactory 创建的。TransportFactory，不同的 TransportFactory 创建出不同的 TransportServer，而 TcpTransportServer 则是由 TcpTransportFactory 创建的。关于 TransportFactory 如何创建相应的 TransportServer，activemq使用了一套基于分析参数和配置文件来实现，说起来很高深，其实很朴实的，有兴趣也可以了解一下，这里不做深入。</p>
<h3 id="tcptransportserver-">TcpTransportServer 的运行</h3>
<p>这里主要使用 TcpTransportServer，TcpTransportServer 生命周期，是通过 TransportConnector 来开启的，这点在上面已经有所讲述。</p>
<p>这里要说一下 TransportServerThreadSupport，此类的作用是支持 TransportServer 能够开启另外一个线程，只要实现了 TransportServer Runnable，在 start 的时候，就能够开启另外一个线程，这也是 TransportServerThreadSupport 命令的含义。同样的机制也出现在 TransportThreadSupport 中。</p>
<p>现在来看一下 TcpTransportServer 的 start ：
TcpTransportServer 会开启两个线程，包括：</p>
<ol>
<li>实现了Runnable的线程，此线程的工作是不停的 accept 外部的 socket，然后将 socket 扔到一个队列中。简单来说，此线程是一个 acceptor。</li>
<li>另外一个线程的工作是，从队列中取出 socket ，并且将 WireFormat（ WireFormat 是在 activemq 中负责序列化和发序列化的组件） 和socket 封装成一个 Transport ，然后将创建好的 Transport 通知到 AcceptListener 中。</li>
</ol>
<h3 id="transport">Transport</h3>
<p>这里也主要讲 TcpTransport。</p>
<h3 id="tcptransport-">TcpTransport 的创建</h3>
<p>上面已经讲到，TcpTransport 是在 TcpTransportServer 中创建，并扔给了 AcceptListener 。并且，TcpTransport 也支持 TransportThreadSupport 的形式，可以另起一个线程。</p>
<h3 id="tcptransport-">TcpTransport 的运行</h3>
<p>TcpTransport 开始执行之后，专注于做两个事情：</p>
<ol>
<li>初始化 socket，并且把 socket 的流给设置起来。</li>
<li>另起一个线程，利用 wireFormat 将 socket 传过来的字节序列转化成一个 command ，然后将 Command 扔给 transportListener 。transportListener 所做的事情就是进行业务处理，然后将得到的 response （也是一个 command）通过 tcpTransport 的 oneway 传给对方。</li>
</ol>
<p>这样，这个网络通讯的过程就完成了。下面我们来总结一下 TcpTransportServer 的线程模型。</p>
<h3 id="tcptransportserver-">TcpTransportServer 的线程模型</h3>
<p>如图所示：
<a href="http://www.goldendoc.org/wp-content/uploads/2011/09/activemq%E6%A8%A1%E5%9E%8B.jpg" target="_blank"><img src="" alt="activemq网络线程模型"></a></p>
<p>activemq网络线程模型</p>
<h3 id="-">总结</h3>
<p>从上图中可以看出，accpetor 和 sockethandler 线程是在整个 transportServer 中的，而 ThreadPool 中的线程不会进行消息的发送，相反，当需要发送消息的时候，总是会创建新的线程去发送。这也是为了 ThreadPool 能将自己的线程利用率提高。因为这是 bio 的网络，如果消息的发送是利用线程池中的线程来发送的，那么很有可能线程池中的线程会在发送的时候阻塞，因为对方的网络不可预知。因此，新建一个新的线程，利用新建的线程发送消息，则是很明智的选择。
来源： <a href="[http://www.goldendoc.org/2011/09/activemq-network-process-2/](http://www.goldendoc.org/2011/09/activemq-network-process-2/)">[http://www.goldendoc.org/2011/09/activemq-network-process-2/](http://www.goldendoc.org/2011/09/activemq-network-process-2/)</a> </p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/框架汇总/">框架汇总</a></li></span><span class="breadcrumb"><li><a href="/categories/框架汇总/">框架汇总</a></li><li><a href="/categories/框架汇总/activemq/">activemq</a></li></span></span> | <span class="tags">Tagged <a href="/tags/activemq/" class="label label-primary">activemq</a><a href="/tags/框架汇总/" class="label label-success">框架汇总</a></span> | <span class="time">recent updated:<time title="2014-03-07 01:54:29"datetime="2014-03-07 01:54:29"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-框架汇总-activemq--activemq的网络层介绍/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-框架汇总-activemq--activemq的网络层介绍" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-框架汇总-反射--Java反射机制剖析/">Java反射机制剖析</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T09:54:29.000Z"> <a href="/2014/02/02/2014-02-02-框架汇总-反射--Java反射机制剖析/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="java-">Java反射机制剖析</h1>
<p><a href="http://blog.csdn.net/lfsf802/article/details/7239652" target="_blank">（一）-定义和API</a></p>
<ol>
<li>什么是Java反射机制
Java的反射机制是在程序运行时，能够完全知道任何一个类，及其它的属性和方法，并且能够任意调用一个对象的属性和方法。这种运行时的动态获取就是Java的反射机制。其实这也是Java是动态语言的一个象征。</li>
</ol>
<p>用一句话来概括反射就是加载一个运行时才知道的类以及它的完整内部结构。</p>
<ol>
<li>为什么要有Java反射机制
我们为什么要用Java的反射机制呢？</li>
</ol>
<p>我认为有两种：</p>
<p>第一种：反射的目的就是为了扩展未知的应用。比如你写了一个程序，这个程序定义了一些接口，只要实现了这些接口的dll都可以作为插件来插入到这个程序中。那么怎么实现呢？就可以通过反射来实现。就是把dll加载进内存，然后通过反射的方式来调用dll中的方法。</p>
<p>第二种：在编码阶段不知道那个类名,要在运行期从配置文件读取类名, 这时候就没有办法硬编码new ClassName(),而必须用到反射才能创建这个对象。</p>
<p>一个生活中常看到的例子有助于理解我们为什么要用Java的反射机制：你进了一家饭店，你不知道他们都有那些菜，要多少钱。那么你第一件事情是干啥“服务员拿个菜单过来”，然后指着菜单说“我要这个，我要那个”。</p>
<ol>
<li>一起来看ReflectionAPI</li>
</ol>
<p>在生活中，我们使用一个未知的东西的时候总会用帮助来解决我们的使用问题，电视机有帮助，电脑有帮助，几乎所有的事物都携带着它的一本帮助，Java的反射机制也不例外。</p>
<p>在JDK中有Reflection API的帮助，它主要说明了什么是Java反射机制，这种反射机制提供了什么样的属性和方法，进一步我们能够知道能够通过它完成什么样的工作。</p>
<p>下面咱就一起看看这部分的API。这些接口和类都位于lang包里。</p>
<p>如图：</p>
<p><img src="" alt=""></p>
<p>接口：</p>
<p><img src="" alt=""></p>
<p>类：</p>
<p><img src="" alt=""></p>
<p>简单介绍一些类和接口的用法。</p>
<p>1)     Member成员是一种接口，反映有关单个成员（字段或方法）或构造方法的标识信息</p>
<p>2)     InvocationHandler是代理实例的调用处理程序 实现的接口（这个接口的具体用法等到java反射机制剖析4着重介绍）</p>
<p>3)     Method提供一个类的方法的信息以及访问类的方法的接口。</p>
<p>示例：</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/lfsf802/article/details/7239652#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/lfsf802/article/details/7239652#" title="copy" target="_blank">copy</a><a href="http://blog.csdn.net/lfsf802/article/details/7239652#" title="print" target="_blank">print</a><a href="http://blog.csdn.net/lfsf802/article/details/7239652#" title="?" target="_blank">?</a></p>
<ol>
<li>import java.lang.reflect.Method;  </li>
<li></li>
<li>public class TestMethod {  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* @param args </li>
<li>/* @throws Exception  </li>
<li>/*/  </li>
<li>public static void main(String[] args) throws Exception {  </li>
<li>// TODO Auto-generated method stub  </li>
<li>Class classType=Class.forName(args[0]);  </li>
<li>Method methods[]=classType.getDeclaredMethods();  </li>
<li>for(int i=0;i&lt;methods.length;i++){  </li>
<li>System.out.println(methods[i].toString());  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>}  </li>
</ol>
<p>4)     Filed提供一个类的域的信息以及访问类的域的接口。</p>
<p>示例：</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/lfsf802/article/details/7239652#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/lfsf802/article/details/7239652#" title="copy" target="_blank">copy</a><a href="http://blog.csdn.net/lfsf802/article/details/7239652#" title="print" target="_blank">print</a><a href="http://blog.csdn.net/lfsf802/article/details/7239652#" title="?" target="_blank">?</a></p>
<ol>
<li>import java.lang.reflect.Field;  </li>
<li></li>
<li></li>
<li>public class TestField {  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* @param args </li>
<li>/* @throws Exception  </li>
<li>/*/  </li>
<li>public static void main(String[] args) throws Exception {  </li>
<li>// TODO Auto-generated method stub  </li>
<li>Class classType=Class.forName(args[0]);  </li>
<li>Field[] fields = classType.getFields();  </li>
<li>for(int i=0;i&lt;fields.length;i++){  </li>
<li>System.out.println(fields[i].toString());  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>}  </li>
</ol>
<p>5)     Array 类提供了动态创建和访问 Java 数组的方法。</p>
<p>示例：</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/lfsf802/article/details/7239652#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/lfsf802/article/details/7239652#" title="copy" target="_blank">copy</a><a href="http://blog.csdn.net/lfsf802/article/details/7239652#" title="print" target="_blank">print</a><a href="http://blog.csdn.net/lfsf802/article/details/7239652#" title="?" target="_blank">?</a></p>
<ol>
<li>import java.lang.reflect.Array;  </li>
<li></li>
<li></li>
<li>public class TestArray {  </li>
<li></li>
<li>public TestArray(){  </li>
<li></li>
<li>}  </li>
<li>//<em>/</em> </li>
<li>/* @param args </li>
<li>/* @throws Exception  </li>
<li>/*/  </li>
<li>public static void main(String[] args) throws Exception {  </li>
<li></li>
<li>Class&lt;?&gt; classType = Class.forName(&quot;java.lang.String&quot;);  </li>
<li></li>
<li>Object array = Array.newInstance(classType, 10);  </li>
<li></li>
<li>Array.set(array, 5, &quot;hello&quot;);  </li>
<li></li>
<li>String s = (String)Array.get(array, 5);  </li>
<li>System.out.println(s);  </li>
<li></li>
<li>}  </li>
<li></li>
<li>}  </li>
</ol>
<p>6)     Proxy提供动态地生成代理类和类实例的静态方法（这个方法在java放射机制剖析4着重介绍）。</p>
<p>其余的类和接口的使用方法详见API
来源： <a href="[http://blog.csdn.net/lfsf802/article/details/7239652](http://blog.csdn.net/lfsf802/article/details/7239652)">[http://blog.csdn.net/lfsf802/article/details/7239652](http://blog.csdn.net/lfsf802/article/details/7239652)</a></p>
<p> <a href="http://blog.csdn.net/lfsf802/article/details/7239711" target="_blank">（二）-功能以及举例</a></p>
<p>从<a href="http://blog.csdn.net/lfsf802/article/details/7239652" target="_blank">《java反射机制剖析（一）》</a>的API我们看到了许多接口和类，我们能够通过这些接口做些什么呢？</p>
<p>从上篇API中我们能看到它能够完成下面的这些功能：</p>
<p>1)     获得类
A.     运用getClass()  (每个class都有此函数)</p>
<pre><code>                                i.    String str = &quot;abc&quot;;

                              ii.    Class c1 = str.getClass();
</code></pre><p>B.     运用Class.forName() (static method 最常被使用)</p>
<pre><code>                                i.    Class c1 = Class.forName (&quot;java.lang.String&quot;);

                              ii.    Class c2 = Class.forName (&quot;java.awt.Button&quot;);
</code></pre><p>C.     运用  .class 语法</p>
<pre><code>                                i.    Class c1 = String.class;

                              ii.    Class c2 = java.awt.Button.class;

                            iii.    Class c4 = int.class;

                              iv.    Class c5 = int[].class;
</code></pre><p>D.     运用 TYPE语法 ( primitive wrapper classes 基本数据类型包装类的 TYPE语法)</p>
<pre><code>                                i.    Class c1 = Boolean.TYPE;
</code></pre><p>2)     获得属性（这个功能的实例见Java反射机制剖析（2））
以下四个方法可以获得属性，主要参见的是Java.lang.class</p>
<p> Public  Field  getField</p>
<p>(String name) 返回一个 Field 对象，它反映此 Class 对象所表示的类或接口的指定公共成员字段 public Field[] getFields() 返回一个包含某些 Field 对象的数组，这些对象反映此 Class 对象所表示的类或接口的所有可访问公共字段 Public  Field</p>
<p>getDeclaredField(String name) 返回一个 Field 对象，该对象反映此 Class 对象所表示的类或接口的指定已声明字段 public  Field[]</p>
<p>getDeclaredFields() 返回 Field 对象的一个数组，这些对象反映此 Class 对象所表示的类或接口所声明的所有字段</p>
<p>3)     获得方法（）
以下四个方法可以获得方法，要参见的是Java.lang.class</p>
<p>public  Method</p>
<p>getMethod(String name,</p>
<p>... )</p>
<p>返回一个 Method 对象，它反映此 Class 对象所表示的类或接口的指定公共成员方法 public Method[] getMethods()</p>
<p>返回一个包含某些 Method 对象的数组，这些对象反映此 Class 对象所表示的类或接口（包括那些由该类或接口声明的以及从超类和超接口继承的那些的类或接口）的公共 member 方法 public Method</p>
<p>getDeclaredMethod(String name,…)</p>
<p>返回一个 Method 对象，该对象反映此 Class 对象所表示的类或接口的指定已声明方法 public Method[]</p>
<p>getDeclaredMethods()</p>
<p>返回 Method 对象的一个数组，这些对象反映此 Class 对象表示的类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法</p>
<p>4)     获取类的构造器
以下四个方法可以获得方法，要参见的是Java.lang.class</p>
<p>public  Constructor</p>
<p>getConstructor(Class&lt;?&gt;... )</p>
<p>返回一个 Constructor 对象，它反映此 Class 对象所表示的类的指定公共构造方法 public  Constructor&lt;?&gt;[]</p>
<p>getConstructors()</p>
<p>返回一个包含某些 Constructor 对象的数组，这些对象反映此 Class 对象所表示的类的所有公共构造方法 Public  Constructor<T></p>
<p>getDeclaredConstructor(Class&lt;?&gt;...)</p>
<p>返回一个 Constructor 对象，该对象反映此 Class 对象所表示的类或接口的指定构造方法 public  Constructor&lt;?&gt;[]</p>
<p>getDeclaredConstructors()</p>
<p>返回 Constructor 对象的一个数组，这些对象反映此 Class 对象表示的类声明的所有构造方法。它们是公共、保护、默认（包）访问和私有构造方法 
示例代码：</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/lfsf802/article/details/7239711#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/lfsf802/article/details/7239711#" title="copy" target="_blank">copy</a><a href="http://blog.csdn.net/lfsf802/article/details/7239711#" title="print" target="_blank">print</a><a href="http://blog.csdn.net/lfsf802/article/details/7239711#" title="?" target="_blank">?</a></p>
<ol>
<li>import java.lang.reflect.Constructor;  </li>
<li></li>
<li></li>
<li>public class TestConstructor {  </li>
<li>//<em>/</em> </li>
<li>/* @param args </li>
<li>/* @throws ClassNotFoundException  </li>
<li>/* @throws SecurityException  </li>
<li>/* @throws NoSuchMethodException  </li>
<li>/*/  </li>
<li>public static void main(String[] args) throws Exception {  </li>
<li>// TODO Auto-generated method stub  </li>
<li>Class classType=Class.forName(args[0]);  </li>
<li>Constructor Constructor= classType.getConstructor();  </li>
<li></li>
<li>System.out.println(Constructor.toString());  </li>
<li></li>
<li>}  </li>
<li></li>
<li></li>
<li>}  </li>
</ol>
<p>5)     新建类的实例</p>
<p>调用类的Class对象的newInstance方法</p>
<p>示例：</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/lfsf802/article/details/7239711#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/lfsf802/article/details/7239711#" title="copy" target="_blank">copy</a><a href="http://blog.csdn.net/lfsf802/article/details/7239711#" title="print" target="_blank">print</a><a href="http://blog.csdn.net/lfsf802/article/details/7239711#" title="?" target="_blank">?</a></p>
<ol>
<li>import java.lang.reflect.Constructor;  </li>
<li></li>
<li></li>
<li>public class TestConstructor {  </li>
<li>//<em>/</em> </li>
<li>/* @param args </li>
<li>/* @throws ClassNotFoundException  </li>
<li>/* @throws SecurityException  </li>
<li>/* @throws NoSuchMethodException  </li>
<li>/*/  </li>
<li>public static void main(String[] args) throws Exception {  </li>
<li>// TODO Auto-generated method stub  </li>
<li>Class classType=Class.forName(args[0]);  </li>
<li>//Constructor Constructor= classType.getConstructor();  </li>
<li>Object inst=classType.newInstance();  </li>
<li>System.out.println(inst);     </li>
<li>}  </li>
<li>}   调用默认Constructor对象的newInstance方法</li>
</ol>
<p>示例：</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/lfsf802/article/details/7239711#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/lfsf802/article/details/7239711#" title="copy" target="_blank">copy</a><a href="http://blog.csdn.net/lfsf802/article/details/7239711#" title="print" target="_blank">print</a><a href="http://blog.csdn.net/lfsf802/article/details/7239711#" title="?" target="_blank">?</a></p>
<ol>
<li>import java.lang.reflect.Constructor;  </li>
<li></li>
<li></li>
<li>public class TestConstructor {  </li>
<li>//<em>/</em> </li>
<li>/* @param args </li>
<li>/* @throws ClassNotFoundException  </li>
<li>/* @throws SecurityException  </li>
<li>/* @throws NoSuchMethodException  </li>
<li>/*/  </li>
<li>public static void main(String[] args) throws Exception {  </li>
<li>// TODO Auto-generated method stub  </li>
<li>Class classType=Class.forName(args[0]);  </li>
<li>Constructor Constructor= classType.getConstructor();  </li>
<li>Object inst=Constructor.newInstance();  </li>
<li>System.out.println(inst);     </li>
<li>}  </li>
<li>}   调用带参数Constructor对象的newInstance方法</li>
</ol>
<p>示例：</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/lfsf802/article/details/7239711#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/lfsf802/article/details/7239711#" title="copy" target="_blank">copy</a><a href="http://blog.csdn.net/lfsf802/article/details/7239711#" title="print" target="_blank">print</a><a href="http://blog.csdn.net/lfsf802/article/details/7239711#" title="?" target="_blank">?</a></p>
<ol>
<li>Class classType=User.class  </li>
<li>Constructor constructor2 =  </li>
<li>classType.getDeclaredConstructor(int.class, String.class);  </li>
<li></li>
<li>Object inst = constructor2.newInstance(1, &quot;123&quot;);  </li>
<li></li>
<li>System.out.println(inst);  </li>
</ol>
<p>来源： <a href="[http://blog.csdn.net/lfsf802/article/details/7239711](http://blog.csdn.net/lfsf802/article/details/7239711)">[http://blog.csdn.net/lfsf802/article/details/7239711](http://blog.csdn.net/lfsf802/article/details/7239711)</a></p>
<p><a href="http://blog.csdn.net/lfsf802/article/details/7239766" target="_blank">（三）-简单谈谈动态代理</a>
通过<a href="http://blog.csdn.net/lfsf802/article/details/7239652" target="_blank">Java反射机制剖析（一）</a>和<a href="http://blog.csdn.net/lfsf802/article/details/7239711" target="_blank">Java反射机制剖析（二）</a>的学习，已经对反射有了一定的了解，这一篇通过动态代理的例子来进一步学习反射机制。</p>
<ol>
<li>代理模式</li>
</ol>
<p>代理模式就是为其他对象提供一种代理来控制对这个对象的访问。其实代理模式是在访问的对象时引入一定程度的间接性，这种间接性可以附加多种用途。</p>
<p>它的特征是代理类与委托类有同样的接口，代理类主要负责为委托类预处理消息、过滤消息、把消息转发给委托类，以及事后处理消息等。代理类与委托类之间通常会存在关联关系，一个代理类的对象与一个委托类的对象关联，代理类的对象本身并不真正实现服务，而是通过调用委托类的对象的相关方法，来提供特定的服务。</p>
<ol>
<li>分类</li>
</ol>
<p>代理类按照创建时期可以分为两种，静态代理类和动态代理类。</p>
<p>静态代理类：由程序员创建或由特定工具自动生成源代码，再对其编译。在程序运行前，代理类的.class文件就已经存在了。</p>
<p>动态代理类：在程序运行时，运用反射机制动态创建而成。</p>
<ol>
<li>静态代理和动态代理举例</li>
</ol>
<p>静态代理：</p>
<p>业务接口类：</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/lfsf802/article/details/7239766#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/lfsf802/article/details/7239766#" title="copy" target="_blank">copy</a><a href="http://blog.csdn.net/lfsf802/article/details/7239766#" title="print" target="_blank">print</a><a href="http://blog.csdn.net/lfsf802/article/details/7239766#" title="?" target="_blank">?</a></p>
<ol>
<li>package com.bjpowernode.pattern;  </li>
<li></li>
<li>public interface UserManager {  </li>
<li></li>
<li>public void addUser(String userId, String userName);  </li>
<li></li>
<li>public void delUser(String userId);  </li>
<li></li>
<li>public void modifyUser(String userId, String userName);  </li>
<li></li>
<li>public String findUser(String userId);  </li>
<li>}<br>业务接口实现类：</li>
</ol>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/lfsf802/article/details/7239766#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/lfsf802/article/details/7239766#" title="copy" target="_blank">copy</a><a href="http://blog.csdn.net/lfsf802/article/details/7239766#" title="print" target="_blank">print</a><a href="http://blog.csdn.net/lfsf802/article/details/7239766#" title="?" target="_blank">?</a></p>
<ol>
<li>package com.bjpowernode.pattern;  </li>
<li></li>
<li>public class UserManagerImpl implements UserManager {  </li>
<li></li>
<li>public void addUser(String userId, String userName) {  </li>
<li>//System.out.println(&quot;start--&gt;&gt;addUser() userId--&gt;&gt;&quot; + userId);  </li>
<li>try {  </li>
<li>System.out.println(&quot;UserManagerImpl.addUser() userId--&gt;&gt;&quot; + userId);  </li>
<li></li>
<li>//System.out.println(&quot;success--&gt;&gt;addUser()&quot;);  </li>
<li>}catch(Exception e) {  </li>
<li>e.printStackTrace();  </li>
<li>//System.out.println(&quot;error--&gt;&gt;addUser()&quot;);  </li>
<li>throw new RuntimeException();  </li>
<li>}     </li>
<li>}  </li>
<li></li>
<li>public void delUser(String userId) {  </li>
<li>System.out.println(&quot;UserManagerImpl.delUser() userId--&gt;&gt;&quot; + userId);  </li>
<li>}  </li>
<li></li>
<li>public String findUser(String userId) {  </li>
<li>System.out.println(&quot;UserManagerImpl.findUser() userId--&gt;&gt;&quot; + userId);  </li>
<li>return &quot;张三&quot;;  </li>
<li>}  </li>
<li></li>
<li>public void modifyUser(String userId, String userName) {  </li>
<li>System.out.println(&quot;UserManagerImpl.modifyUser() userId--&gt;&gt;&quot; + userId);  </li>
<li>}  </li>
<li></li>
<li>}<br>业务代理类：</li>
</ol>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/lfsf802/article/details/7239766#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/lfsf802/article/details/7239766#" title="copy" target="_blank">copy</a><a href="http://blog.csdn.net/lfsf802/article/details/7239766#" title="print" target="_blank">print</a><a href="http://blog.csdn.net/lfsf802/article/details/7239766#" title="?" target="_blank">?</a></p>
<ol>
<li>package com.bjpowernode.pattern;  </li>
<li></li>
<li>public class UserManagerImplProxy implements UserManager {  </li>
<li></li>
<li>private UserManager userManager;  </li>
<li></li>
<li>public UserManagerImplProxy(UserManager userManager) {  </li>
<li>this.userManager = userManager;  </li>
<li>}  </li>
<li></li>
<li>public void addUser(String userId, String userName) {  </li>
<li>try {  </li>
<li>System.out.println(&quot;start--&gt;&gt;addUser() userId--&gt;&gt;&quot; + userId);  </li>
<li>userManager.addUser(userId, userName);  </li>
<li>System.out.println(&quot;success--&gt;&gt;addUser()&quot;);  </li>
<li>}catch(Exception e) {  </li>
<li>e.printStackTrace();  </li>
<li>System.out.println(&quot;error--&gt;&gt;addUser()&quot;);  </li>
<li>}     </li>
<li>}  </li>
<li></li>
<li>public void delUser(String userId) {  </li>
<li></li>
<li>}  </li>
<li></li>
<li>public String findUser(String userId) {  </li>
<li>return null;  </li>
<li>}  </li>
<li></li>
<li>public void modifyUser(String userId, String userName) {  </li>
<li></li>
<li>}  </li>
<li></li>
<li>}<br>客户端类：</li>
</ol>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/lfsf802/article/details/7239766#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/lfsf802/article/details/7239766#" title="copy" target="_blank">copy</a><a href="http://blog.csdn.net/lfsf802/article/details/7239766#" title="print" target="_blank">print</a><a href="http://blog.csdn.net/lfsf802/article/details/7239766#" title="?" target="_blank">?</a></p>
<ol>
<li>package com.bjpowernode.pattern;  </li>
<li></li>
<li>public class Client {  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* @param args </li>
<li>/*/  </li>
<li>public static void main(String[] args) {  </li>
<li>//UserManager userManager = new UserManagerImpl();  </li>
<li>UserManager userManager = new UserManagerImplProxy(new UserManagerImpl());  </li>
<li>userManager.addUser(&quot;0001&quot;, &quot;张三&quot;);  </li>
<li>}  </li>
<li></li>
<li>}<br>运行结果：</li>
</ol>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/lfsf802/article/details/7239766#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/lfsf802/article/details/7239766#" title="copy" target="_blank">copy</a><a href="http://blog.csdn.net/lfsf802/article/details/7239766#" title="print" target="_blank">print</a><a href="http://blog.csdn.net/lfsf802/article/details/7239766#" title="?" target="_blank">?</a></p>
<ol>
<li>start--&gt;&gt;addUser() userId--&gt;&gt;0001  </li>
<li>UserManagerImpl.addUser() userId--&gt;&gt;0001  </li>
<li>success--&gt;&gt;addUser()  </li>
</ol>
<p>动态代理：</p>
<p>业务接口类:</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/lfsf802/article/details/7239766#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/lfsf802/article/details/7239766#" title="copy" target="_blank">copy</a><a href="http://blog.csdn.net/lfsf802/article/details/7239766#" title="print" target="_blank">print</a><a href="http://blog.csdn.net/lfsf802/article/details/7239766#" title="?" target="_blank">?</a></p>
<ol>
<li>package com.bjpowernode.pattern;  </li>
<li></li>
<li>public interface UserManager {  </li>
<li></li>
<li></li>
<li>public String test(String userId);  </li>
<li>}<br>业务接口实现类：</li>
</ol>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/lfsf802/article/details/7239766#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/lfsf802/article/details/7239766#" title="copy" target="_blank">copy</a><a href="http://blog.csdn.net/lfsf802/article/details/7239766#" title="print" target="_blank">print</a><a href="http://blog.csdn.net/lfsf802/article/details/7239766#" title="?" target="_blank">?</a></p>
<ol>
<li>package com.bjpowernode.pattern;  </li>
<li></li>
<li>public class UserManagerImpl implements UserManager {  </li>
<li></li>
<li>public String test(String userId) {  </li>
<li>System.out.println(&quot;UserManagerImpl.findUser() userId--&gt;&gt;&quot; + userId);  </li>
<li>return &quot;张三&quot;;  </li>
<li>}  </li>
<li></li>
<li>}<br>BusinessHandler类：</li>
</ol>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/lfsf802/article/details/7239766#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/lfsf802/article/details/7239766#" title="copy" target="_blank">copy</a><a href="http://blog.csdn.net/lfsf802/article/details/7239766#" title="print" target="_blank">print</a><a href="http://blog.csdn.net/lfsf802/article/details/7239766#" title="?" target="_blank">?</a></p>
<ol>
<li>package com.bjpowernode.pattern;  </li>
<li></li>
<li>import java.lang.reflect.InvocationHandler;  </li>
<li>import java.lang.reflect.Method;  </li>
<li>import java.lang.reflect.Proxy;  </li>
<li></li>
<li>public class BusinessHandler implements InvocationHandler {  </li>
<li></li>
<li>private Object targetObject;  </li>
<li></li>
<li>public Object newProxyInstance(Object targetObject) {  </li>
<li></li>
<li>this.targetObject = targetObject;  </li>
<li>return Proxy.newProxyInstance(targetObject.getClass().getClassLoader(),  </li>
<li>targetObject.getClass().getInterfaces(), this);  </li>
<li>}  </li>
<li></li>
<li>public Object invoke(Object proxy, Method method, Object[] args)  </li>
<li>throws Throwable {  </li>
<li>System.out.println(&quot;start--&gt;&gt;&quot; + method.getName());  </li>
<li>for (int i=0; i&lt;args.length; i++) {  </li>
<li>System.out.println(args[i]);  </li>
<li>}  </li>
<li>Object ret = null;  </li>
<li>try {  </li>
<li>//调用目标方法  </li>
<li>ret = method.invoke(targetObject, args);  </li>
<li>System.out.println(&quot;success--&gt;&gt;&quot; + method.getName());   </li>
<li>}catch(Exception e) {  </li>
<li>e.printStackTrace();  </li>
<li>System.out.println(&quot;error--&gt;&gt;&quot; + method.getName());  </li>
<li>throw e;  </li>
<li>}  </li>
<li>return ret;  </li>
<li>}  </li>
<li></li>
<li>}<br>客户端类：</li>
</ol>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/lfsf802/article/details/7239766#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/lfsf802/article/details/7239766#" title="copy" target="_blank">copy</a><a href="http://blog.csdn.net/lfsf802/article/details/7239766#" title="print" target="_blank">print</a><a href="http://blog.csdn.net/lfsf802/article/details/7239766#" title="?" target="_blank">?</a></p>
<ol>
<li>package com.bjpowernode.pattern;  </li>
<li></li>
<li>import java.lang.reflect.Field;  </li>
<li></li>
<li></li>
<li>public class Client {  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* @param args </li>
<li>/*/  </li>
<li>public static void main(String[] args) {  </li>
<li></li>
<li>BusinessHandler businessHandler = new BusinessHandler();  </li>
<li>UserManager userManager = (UserManager)businessHandler.newProxyInstance(new UserManagerImpl());  </li>
<li></li>
<li></li>
<li></li>
<li>//userManager.addUser(&quot;0001&quot;, &quot;张三&quot;);  </li>
<li>//userManager.delUser(&quot;0001&quot;);  </li>
<li>// System.out.println(userManager.getClass().getName());  </li>
<li></li>
<li>String name = userManager.test(&quot;0001&quot;);  </li>
<li>//String name = ((UserManagerImpl) logHandler.newProxyInstance(new UserManagerImpl())).test(&quot;0001&quot;);  </li>
<li>System.out.println(&quot;Client.main() --- &quot; + name);  </li>
<li>}  </li>
<li></li>
<li>}<br>运行结果：</li>
</ol>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/lfsf802/article/details/7239766#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/lfsf802/article/details/7239766#" title="copy" target="_blank">copy</a><a href="http://blog.csdn.net/lfsf802/article/details/7239766#" title="print" target="_blank">print</a><a href="http://blog.csdn.net/lfsf802/article/details/7239766#" title="?" target="_blank">?</a></p>
<ol>
<li>start--&gt;&gt;test  </li>
<li>0001  </li>
<li>UserManagerImpl.findUser() userId--&gt;&gt;0001  </li>
<li>success--&gt;&gt;test  </li>
<li>Client.main() --- 张三  </li>
</ol>
<p>来源： <a href="[http://blog.csdn.net/lfsf802/article/details/7239766](http://blog.csdn.net/lfsf802/article/details/7239766)">[http://blog.csdn.net/lfsf802/article/details/7239766](http://blog.csdn.net/lfsf802/article/details/7239766)</a></p>
<p> <a href="http://blog.csdn.net/lfsf802/article/details/7239799" target="_blank">（四）-深度剖析动态代理原理及总结</a>
动态代理类原理（<a href="http://blog.csdn.net/lfsf802/article/details/7239766" target="_blank">示例代码参见java反射机制剖析（三）</a>）
a)  理解上面的动态代理示例流程</p>
<p><img src="" alt=""></p>
<p>b)  代理接口实现类源代码剖析</p>
<p>咱们一起来剖析一下代理实现类（$Proxy0）的源代码和整个动态代理的流程。</p>
<p>$Proxy0生成的代码如下：</p>
<p><strong>[html]</strong> <a href="http://blog.csdn.net/lfsf802/article/details/7239799#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/lfsf802/article/details/7239799#" title="copy" target="_blank">copy</a><a href="http://blog.csdn.net/lfsf802/article/details/7239799#" title="print" target="_blank">print</a><a href="http://blog.csdn.net/lfsf802/article/details/7239799#" title="?" target="_blank">?</a></p>
<ol>
<li>import java.lang.reflect.InvocationHandler;  </li>
<li>import java.lang.reflect.Method;  </li>
<li>import java.lang.reflect.Proxy;  </li>
<li>import java.lang.reflect.UndeclaredThrowableException;  </li>
<li></li>
<li>public final class $Proxy0 extends Proxy implements Manager {  </li>
<li></li>
<li>private static Method m1;  </li>
<li>private static Method m0;  </li>
<li>private static Method m3;  </li>
<li>private static Method m2;  </li>
<li></li>
<li>static {  </li>
<li>try {  </li>
<li>m1 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;equals&quot;,  </li>
<li>new Class[] { Class.forName(&quot;java.lang.Object&quot;) });  </li>
<li>m0 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;hashCode&quot;,  </li>
<li>new Class[0]);  </li>
<li>m3 = Class.forName(&quot;com.ml.test.Manager&quot;).getMethod(&quot;test&quot;,  </li>
<li>new Class[0]);  </li>
<li>m2 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;toString&quot;,  </li>
<li>new Class[0]);  </li>
<li>} catch (NoSuchMethodException nosuchmethodexception) {  </li>
<li>throw new NoSuchMethodError(nosuchmethodexception.getMessage());  </li>
<li>} catch (ClassNotFoundException classnotfoundexception) {  </li>
<li>throw new NoClassDefFoundError(classnotfoundexception.getMessage());  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>public $Proxy0(InvocationHandler invocationhandler) {  </li>
<li>super(invocationhandler);  </li>
<li>}  </li>
<li></li>
<li>@Override  </li>
<li>public final boolean equals(Object obj) {  </li>
<li>try {  </li>
<li>return ((Boolean) super.h.invoke(this, m1, new Object[] { obj }))  </li>
<li>.booleanValue();  </li>
<li>} catch (Throwable throwable) {  </li>
<li>throw new UndeclaredThrowableException(throwable);  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>@Override  </li>
<li>public final int hashCode() {  </li>
<li>try {  </li>
<li>return ((Integer) super.h.invoke(this, m0, null)).intValue();  </li>
<li>} catch (Throwable throwable) {  </li>
<li>throw new UndeclaredThrowableException(throwable);  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>public final void test() {  </li>
<li>try {  </li>
<li>super.h.invoke(this, m3, null);  </li>
<li>return;  </li>
<li>} catch (Error e) {  </li>
<li>} catch (Throwable throwable) {  </li>
<li>throw new UndeclaredThrowableException(throwable);  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>@Override  </li>
<li>public final String toString() {  </li>
<li>try {  </li>
<li>return (String) super.h.invoke(this, m2, null);  </li>
<li>} catch (Throwable throwable) {  </li>
<li>throw new UndeclaredThrowableException(throwable);  </li>
<li>}  </li>
<li>}  </li>
<li>}  </li>
</ol>
<p>引入眼帘的是这个代理接口实现类实现了业务类的接口（也就是例子中的UserManager接口），又继承了基类Proxy类；</p>
<p>接着就是构造函数，在构造方法中把BusinessHandler传过去,接着$Proxy0调用父类Proxy的构造器,为h赋值（这里要看Proxy的构造方法）；</p>
<p>随后看到的就是这个类重写了Proxy类的Equals、hashCode、toString方法，又实现了业务类接口的方法（即UserManager的test方法），具体重写和实现都是用到的super.h.invoke（即Proxy.h.invoke）这个方法。</p>
<p>简单分析完这个代理接口实现类，咱们下面来整体看一下这个动态代理是怎么实现的：</p>
<p>首先客户端初始化了BusinessHandler类，调用这个类的newProxyInstance(new UserManagerImpl())方法来初始化了上面的代理接口实现类；</p>
<p>接下来代理接口实现类通过构造函数把BusinessHandler传过去（也就是代码中的this），并通过Proxy的构造函数给h赋值；</p>
<p>随后再客户端就能实例化出代理接口实现类$Proxy0，我们把它强制转换为业务实现接口（UserManager）类型的（为什么要强制转换，这里非常有意思，如果不强制转换就会报错，这里很好解释，因为当前的环境根本不会知道这个代理接口实现类$Proxy0既继承Proxy又实现业务实现接口UserManager，但是强制转换成UserManager它是可以做到的，因为当前环境中就有UserManager。这就是反射的厉害之处，可以在运行时动态调用任何一个类并可以使用这个类的具体细节。）；</p>
<p>之后当我们调用test方法的时候其实是调用了$Proxy0中的test方法，这个方法的实现是通过Proxy.h的invoke方法实现的（即调用了BusinessHandler.invoke方法）；</p>
<p>之后在调用了Method的invoke方法（这时的参数是this，和args）。</p>
<p>这样就调用了UserManagerImpl的对应方法，之后返回给客户端。</p>
<p>到此就完成了整个的调用关系。</p>
<p>反射，反射，程序员的快乐
通过上篇文章对动态代理进行了深度剖析，现在想起来还感觉非常有意思，这里面其实最根本的机制就是反射机制，运行时动态实例化任何一个类，并且调用它的具体细节。现在反看动态代理的示例，其实发现这里最关键的还是在就在Proxy.newProxyInstance(..)方法执行时生成了$Proxy0的内存字节码这一点上，当我们有了内存字节码，我们的反射就会大显威力，这样才有了我们之后的一系列的调用关系。</p>
<p>通过反射机制的分析和动态代理示例的剖析，发现编程是一件多么有意思的事情，以至于我们沉浸其中不能自拔。</p>
<p>最后总结一下：反射，反射，程序员的快乐！
来源： <a href="[http://blog.csdn.net/lfsf802/article/details/7239799](http://blog.csdn.net/lfsf802/article/details/7239799)">[http://blog.csdn.net/lfsf802/article/details/7239799](http://blog.csdn.net/lfsf802/article/details/7239799)</a></p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/框架汇总/">框架汇总</a></li></span><span class="breadcrumb"><li><a href="/categories/框架汇总/">框架汇总</a></li><li><a href="/categories/框架汇总/反射/">反射</a></li></span></span> | <span class="tags">Tagged <a href="/tags/反射/" class="label label-primary">反射</a><a href="/tags/框架汇总/" class="label label-success">框架汇总</a></span> | <span class="time">recent updated:<time title="2014-03-07 01:54:29"datetime="2014-03-07 01:54:29"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-框架汇总-反射--Java反射机制剖析/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-框架汇总-反射--Java反射机制剖析" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-框架汇总-Spring--Spring-设计模式-aop-ioc/">Spring</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T09:54:29.000Z"> <a href="/2014/02/02/2014-02-02-框架汇总-Spring--Spring-设计模式-aop-ioc/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="spring-aop-ioc">Spring-设计模式-aop-ioc</h1>
<p><a href="http://www.goldendoc.org/" target="_blank">黄金档</a></p>
<p>路漫漫其修远兮，吾将上下而求索……</p>
<ul>
<li><a href="http://www.goldendoc.org/" title="首页" target="_blank">首页</a></li>
<li><a href="http://www.goldendoc.org/hire/" target="_blank">招聘</a></li>
<li><a href="http://www.goldendoc.org/about/" target="_blank">关于</a></li>
</ul>
<h1 id="spring">Spring</h1>
<h2 id="-spring-http-www-goldendoc-org-2010-12-spring_design_pattern-spring-"><a href="http://www.goldendoc.org/2010/12/spring_design_pattern/" title="永久链接：Spring中的设计模式" target="_blank">Spring中的设计模式</a></h2>
<p><a href="http://www.goldendoc.org/2010/12/spring_design_pattern/#comments" target="_blank">2</a></p>
<p>2年前</p>
<p>由<a href="http://www.goldendoc.org/author/jackey/" title="jackey发表的文章 " target="_blank">jackey</a>发布 在<a href="http://www.goldendoc.org/category/spring/" title="Spring (4主题)" target="_blank">Spring</a>
应该说设计模式是我们在写代码时候的一种被承认的较好的模式。好的设计模式就像是给代码造了一个很好的骨架，在这个骨架里，你可以知道心在哪里，肺在哪里，因为大多数人都认识这样的骨架，就有了很好的传播性。这是从易读和易传播来感知设计模式的好处。当然设计模式本身更重要的是设计原则的一种实现，比如开闭原则，依赖倒置原则，这些是在代码的修改和扩展上说事。说到底就是人类和代码发生关系的四种场合：阅读，修改，增加，删除。让每一种场合都比较舒服的话，就需要用设计模式。</p>
<p>下面来简单列举Spring中的设计模式：
<strong>1. 简单工厂</strong>
又叫做静态工厂方法（StaticFactory Method）模式，但不属于23种GOF设计模式之一。
简单工厂模式的实质是由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类。
Spring中的BeanFactory就是简单工厂模式的体现，根据传入一个唯一的标识来获得Bean对象，但是否是在传入参数后创建还是传入参数前创建这个要根据具体情况来定。
<strong>2. 工厂方法（Factory Method）</strong>
定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method使一个类的实例化延迟到其子类。
Spring中的FactoryBean就是典型的工厂方法模式。如下图：
<a href="http://pic.yupoo.com/goldendoc/AFbYXQy8/cgvMF.jpg" target="_blank"><img src="" alt=""></a></p>
<p><strong>3. 单例（Singleton）</strong>
保证一个类仅有一个实例，并提供一个访问它的全局访问点。
Spring中的单例模式完成了后半句话，即提供了全局的访问点BeanFactory。但没有从构造器级别去控制单例，这是因为Spring管理的是是任意的Java对象。
<strong>4. 适配器（Adapter）</strong>
将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。
Spring中在对于AOP的处理中有Adapter模式的例子，见如下图：
<a href="http://pic.yupoo.com/goldendoc/AFbYXG9r/yaKsE.jpg" target="_blank"><img src="" alt=""></a>
由于Advisor链需要的是MethodInterceptor对象，所以每一个Advisor中的Advice都要适配成对应的MethodInterceptor对象。
<strong>5.包装器（Decorator）</strong>
动态地给一个对象添加一些额外的职责。就增加功能来说，Decorator模式相比生成子类更为灵活。 <em>**</em></p>
<p><a href="http://pic.yupoo.com/goldendoc/AFbYXVzM/iEPst.jpg" target="_blank"><img src="" alt=""></a>
Spring中用到的包装器模式在类名上有两种表现：一种是类名中含有Wrapper，另一种是类名中含有Decorator。基本上都是动态地给一个对象添加一些额外的职责。
<strong>6. 代理（Proxy）</strong>
为其他对象提供一种代理以控制对这个对象的访问。
从结构上来看和Decorator模式类似，但Proxy是控制，更像是一种对功能的限制，而Decorator是增加职责。
<img src="" alt="">
Spring的Proxy模式在aop中有体现，比如JdkDynamicAopProxy和Cglib2AopProxy。
<strong>7.观察者（Observer）</strong>
定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。
<a href="http://pic.yupoo.com/goldendoc/AFbYY79B/QRttX.jpg" target="_blank"><img src="" alt=""></a>
Spring中Observer模式常用的地方是listener的实现。如ApplicationListener。
<strong>8. 策略（Strategy）</strong>
定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。
Spring中在实例化对象的时候用到Strategy模式，见如下图：
<a href="http://pic.yupoo.com/goldendoc/AFbYYjl6/c2IJb.jpg" target="_blank"><img src="" alt=""></a>
在SimpleInstantiationStrategy中有如下代码说明了策略模式的使用情况：
<a href="http://pic.yupoo.com/goldendoc/AFbYYecL/xJ2n1.jpg" target="_blank"><img src="" alt=""></a>
<strong>9.模板方法（Template Method）</strong>
定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。Template Method使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。
<img src="" alt="">
Template Method模式一般是需要继承的。这里想要探讨另一种对Template Method的理解。Spring中的JdbcTemplate，在用这个类时并不想去继承这个类，因为这个类的方法太多，但是我们还是想用到JdbcTemplate已有的稳定的、公用的数据库连接，那么我们怎么办呢？我们可以把变化的东西抽出来作为一个参数传入JdbcTemplate的方法中。但是变化的东西是一段代码，而且这段代码会用到JdbcTemplate中的变量。怎么办？那我们就用回调对象吧。在这个回调对象中定义一个操纵JdbcTemplate中变量的方法，我们去实现这个方法，就把变化的东西集中到这里了。然后我们再传入这个回调对象到JdbcTemplate，从而完成了调用。这可能是Template Method不需要继承的另一种实现方式吧。</p>
<p>以下是一个具体的例子：
JdbcTemplate中的execute方法：</p>
<p><a href="http://pic.yupoo.com/goldendoc/AFbYXJ1i/Gqxeo.jpg" target="_blank"><img src="" alt=""></a>
JdbcTemplate执行execute方法：
<a href="http://pic.yupoo.com/goldendoc/AFbYYoCZ/coCXA.jpg" target="_blank"><img src="" alt=""></a></p>
<p><a href="http://www.goldendoc.org/tag/%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f/" title="设计模式 (1主题)" target="_blank">设计模式</a></p>
<h2 id="-spring-aop-http-www-goldendoc-org-2010-12-spring_aop-spring-aop-"><a href="http://www.goldendoc.org/2010/12/spring_aop/" title="永久链接：Spring AOP介绍及源码分析" target="_blank">Spring AOP介绍及源码分析</a></h2>
<p><a href="http://www.goldendoc.org/2010/12/spring_aop/#comments" target="_blank">3</a></p>
<p>2年前</p>
<p>由<a href="http://www.goldendoc.org/author/lwei/" title="lwei发表的文章 " target="_blank">lwei</a>发布 在<a href="http://www.goldendoc.org/category/spring/" title="Spring (4主题)" target="_blank">Spring</a>
软件开发经历了从汇编语言到高级语言和从过程化编程到面向对象编程；前者是为了提高开发效率，而后者则使用了归纳法，把具有共性的东西进行归类并使之模块化，达到便于维护和扩展的目的；如果说面向对象编程可以对业务需求进行很好的分解使之模块化；那么面向切面编程AOP（Aspect-Oriented Programming）则可以对系统需求进行很好的模软件开发经历了从汇编语言到高级语言和从过程化编程到面向对象编程；前者是为了提高开发效率，而后者则使用了归纳法，把具有共性的东西进行归类并使之模块化，达到便于维护和扩展的目的；如果说面向对象编程可以对业务需求进行很好的分解使之模块化；那么面向切面编程AOP（Aspect-Oriented Programming）则可以对系统需求进行很好的模块组织，简化系统需求和实现之间的对比关系，是对OOP思想的一种补充；块组织，简化系统需求和实现之间的对比关系，是对OOP思想的一种补充；</p>
<p><strong>一、AOP介绍
</strong></p>
<p>举个例子来说明一下吧！现在系统中有很多的业务方法，如上传产品信息、修改产品信息、发布公司库等；现在需要对这些方法的执行做性能监控，看每个业务方法的执行时间；在不改变原业务代码的基础上，也许我们会这么做：</p>
<p><strong>Offer接口：
</strong></p>
<p><img src="" alt=""></p>
<p><strong>Offer实现：
</strong></p>
<p><img src="" alt=""></p>
<p><strong>Offer代理：
</strong></p>
<p><img src="" alt=""></p>
<p>我们要通过下面的方式来使用：</p>
<p><img src="" alt=""></p>
<p>上面的例子的输出为：</p>
<p><img src="" alt=""></p>
<p>上面的例子中，OfferProxy实现了IOffer，而所有的业务实现均委托给其成员offer；可以想像，这应该就是最简单的AOP的实现了；但这种方式会存在一个问题：如果有非常多的这种业务对象需要性能监控，我们就需要写同样多的XyzProxy来满足需求，这也是非常巨大的工作量。</p>
<p>上面说到了代理，我们先看看代理模式吧！</p>
<p><strong>二、代理模式及实现
</strong></p>
<p>下面是代理模式的类图：</p>
<p><img src="" alt=""></p>
<p>代理模式类图</p>
<p>代理模式中，存在一个称为ProxyObject的代理对象和RealObject的真实对象，它们都实现了相同的接口；在调用的地方持有ProxyObject的实例，当调用request()方法时，ProxyObject可以在执行RealObject.request()前后做一些特定的业务，甚至不调用RealObject.request()方法。</p>
<p>目前实现代理模式的方式有两种：基于JDK的动态代理和基于CGLIB字节码的代理。</p>
<p><strong>2.1 JDK动态代理
</strong></p>
<p>JDK动态代理，顾名思义，是基于JDK的反射(reflect)机制；在JDK中，提供了InvocationHandler这个接口，下面是JDK里面的注释：</p>
<p>InvocationHandler is the interface implemented by the invocation handler of a proxy instance.</p>
<p>Each proxy instance has an associated invocation handler. When a method is invoked on a proxy instance, the method invocation is encoded and dispatched to the invoke method of its invocation handler.</p>
<p>简单翻译，意思是说：该接口由被代理对象的handler所实现；当调用代理对象的方法时，该方法调用将被编码，然后交给代理对象的invoke方法去执行；</p>
<p>是不是有一种豁然开朗的感觉呢？没错，答案就在你心中。</p>
<p>这样，上面的代码就可以改成下面的实现方式：</p>
<p><img src="" alt=""><em>**</em></p>
<p><strong>调用端：
</strong></p>
<p><img src="" alt=""></p>
<p>通过这种方式，你不需要为针对每一个业务写一个代理对象，就可以很轻松地完成你的需求；但也许你已经注意到了，JDK的动态代理，在创建代理对象(上面红色代码部分)时，被代理的对象需要实现接口(即面向接口编程)；</p>
<p>这就是JDK的动态代理，简单吧！下面看看CGLIB代理方式。</p>
<p><strong>2.2 CGLIB代理
</strong></p>
<p>如果目标对象没有实现任何接口，那怎么办呢？不用担心，你可以用CGLIB来实现代理：</p>
<p><img src="" alt=""></p>
<p><strong>调用端：
</strong></p>
<p><img src="" alt=""></p>
<p>使用CGLIB创建的代理对象，其实就是继承了要代理的目标类，然后对目标类中所有非final方法进行覆盖，但在覆盖方法时会添加一些拦截代码(上面CglibProxyFactory类中的intercept方法)。</p>
<p>下面看看Spring中是如何实现AOP的。</p>
<p><strong>三、Spring AOP的实现
</strong></p>
<p><strong>3.1 Spring AOP的几个概念
</strong></p>
<p>Spring AOP中的几个基本概念，每次学习AOP都被这几个概念折腾的很不爽，我们在这里再把这几个概念描述一遍，力争把这几个概念搞清，在每次review这块内容的时候可以很快上手。</p>
<ol>
<li>切面(Aspect)：切面就是一个关注点的模块化，如事务管理、日志管理、权限管理等；</li>
<li>连接点(Joinpoint)：程序执行时的某个特定的点，在Spring中就是一个方法的执行；</li>
<li>通知(Advice)：通知就是在切面的某个连接点上执行的操作，也就是事务管理、日志管理等；</li>
<li>切入点(Pointcut)：切入点就是描述某一类选定的连接点，也就是指定某一类要织入通知的方法；</li>
<li>目标对象(Target)：就是被AOP动态代理的目标对象；</li>
</ol>
<p>用一张图来形象地表达AOP的概念及其关系如下：</p>
<p><img src="" alt=""></p>
<p><strong>3.2 Spring AOP中切入点、通知、切面的实现
</strong></p>
<p>理解了上面的几个概念后，我们分别来看看Spring AOP是如何实现这些概念的；</p>
<ol>
<li>切入点(Pointcut)：它定义了哪些连接点需要被织入横切逻辑；在Java中，连接点对应哪些类(接口)的方法。因此，我们都能猜到，所谓的切入点，就是定义了匹配哪些娄的哪些方法的一些规则，可以是静态的基于类(方法)名的值匹配，也可以是基于正则表达式的模式匹配。来看看Spring AOP Pointcut相关的类图：</li>
</ol>
<p><img src="" alt=""></p>
<p>在Pointcut接口的定义中，也许你已经想到了，ClassFilter是类过滤器，它定义了哪些类名需要拦截；典型的两个实现类为<strong>TypePatternClassFilter</strong>和<strong>TrueClassFilter</strong>(所有类均匹配)；而MethodMatcher为方法匹配器，定义哪些方法需要拦截。</p>
<p>在上面的类图中：</p>
<ul>
<li>StaticMethodMatch与DynamicMethodMatch的区别是后者在运行时会依据方法的参数值进行匹配。</li>
<li>NameMatchMethodPointCut根据指定的mappedNames来匹配方法。</li>
<li>AbstractRegexpMethodPointCut根据正则表达式来匹配方法。</li>
</ul>
<ol>
<li>通知(Advice)：通知定义了具体的横切逻辑。在Spring中，存在两种类型的Advice，即per-class和per-instance的Advice。</li>
</ol>
<p>所谓per-class，即该类型的Advice只提供方法拦截，不会为目标对象保存任何状态或者添加新的特性，它也是我们最常见的Advice。下面是per-class的类图：</p>
<p><img src="" alt=""></p>
<ul>
<li>BeforeAdvice：在连接点前执行的横切逻辑。</li>
<li>AfterReturningAdvice：在连接点执行后，再执行横切逻辑。</li>
<li>AfterAdvice：一般由程序自己实现，当抛出异常后，执行横切逻辑。</li>
<li>AroundAdvice：Spring AOP中并没有提供这个接口，而是采用了AOP Alliance的MethodInteceptor接口；通过看AfterReturningAdvice的源码我们知道，它是不能更改连接点所在方法的返回值的(更改引用)；但使用的MethodInteceptor，所有的事情，都不在话下。</li>
</ul>
<p>在上面的类图中，还有两种类没有介绍，那就是/<em>/</em>/<em>AdviceAdapter和/</em>/<em>/</em>AdviceInteceptor，我们以AfterReturningAdviceInterceptor为例来说明：</p>
<p><img src="" alt=""></p>
<p>该类实现了MethodInterceptor和AfterAdvice接口，同时构造函数中还有一个AfterReturningAdvice实例的参数；这个类存在的作用是为了什么呢？对，没错，Spring AOP把所有的Advice都适配成了MethodInterceptor，统一的好处是方便后面横切逻辑的执行(参看下一节)，适配的工作即由/<em>/</em>/*AdviceAdapter完成；</p>
<p>哈哈，Spring AOP的代码也不过如此嘛：所谓的AfterReturningAdvice，通过适配成MethodInterceptor后，其实就是在invoke方法中，先执行目标对象的方法，再执行的AfterReturningAdvice所定义的横切逻辑。你现在明白它为什么不能修改返回值的引用了吧？</p>
<p>对于per-instance的Advice，目前只有一种实现，就是Introduction，使用的场景比较少，有兴趣的同学可以自己研究一下，呵呵！</p>
<ol>
<li>切面(Aspect)：在Spring中，Advisor就是切面；但与通常的Aspect不同的是，Advisor通常只有一个Pointcut和一个Advice，而Aspect则可以包含多个Pointcut和多个Advice，因此Advisor是一种特殊的Aspect。但，这已经够用了！</li>
</ol>
<p>接下来看下per-class Advisor的类图：</p>
<p><img src="" alt=""></p>
<p>其实没有什么好看的，前面已经说过，Advisor包含一个Pointcut和一个Advisor；在AbstractGenericPointcutAdvisor中，持有一个Advice的引用；下面的几个实现，均是针对前面提到的几种不同的Pointcut的实现。</p>
<p><strong>3.3 Spring AOP实现的基本线索
</strong></p>
<p>我们选择ProxyFactoryBean作为入口点和分析的开始。ProxyFactoryBean是在Spring IoC环境中，创建AOP应用的最底层方法，从中，可以看到一条实现AOP的基本线索。</p>
<p>所有的逻辑从以下的方法开始,我们主要针对单例的代理对象的生成：</p>
<p><img src="" alt=""></p>
<p>下面我们深入到SpringAOP核心代码的内部，看看代理对象的生成机制，拦截器横切逻辑以及织入的实现。</p>
<p><strong>3.4  代理对象的生成
</strong></p>
<p>对于getSingletonInstance()方法返回了什么，这就是代理对象如何产生的逻辑了，然我们须根溯源，看看传说中的proxy到底是如何一步一步的产生的。</p>
<p><img src="" alt=""></p>
<p>ProxyFactoryBean是AdvisedSupport的子类，Spring使用AopProxy接口把AOP代理的实现与框架的其他部分分离开来。在AdvisedSupport中通过这样的方式来得到AopProxy,当然这里需要得到AopProxyFactory的帮助 ，从JDK或者cglib中得到想要的代理对象：</p>
<p><img src="" alt=""></p>
<p>这个DefaultAopProxyFactory是Spring用来生成AopProxy的地方，它包含JDK和Cglib两种实现方式。让我接着往里面看：</p>
<p><img src="" alt=""></p>
<p>可以看到其中的代理对象可以由JDK或者Cglib来生成，JdkDynamicAopProxy类和Cglib2AopProxy都实现的是AopProxy的接口，我们进入JdkDynamicAopProxy实现中看看Proxy是怎样生成的：</p>
<p><img src="" alt=""></p>
<p>用Proxy包装target之后，通过ProxyFactoryBean得到对其方法的调用就被Proxy拦截了， ProxyFactoryBean的getObject()方法得到的实际上是一个Proxy了，target对象已经被封装了。对 ProxyFactoryBean这个工厂bean而言，其生产出来的对象是封装了目标对象的代理对象。</p>
<p><strong>3.5 拦截器的作用
</strong></p>
<p>前面分析了SpringAOP实现中得到Proxy对象的过程，接下来我们去探寻Spring AOP中拦截器链是怎样被调用的，也就是Proxy模式是怎样起作用的。
还记得在JdkDynamicAopProxy中生成Proxy对象的时候，有一句这样的代码吗？</p>
<p><strong>return</strong> Proxy.<em>newProxyInstance</em>(classLoader, proxiedInterfaces, <strong>this</strong>);<em>**</em></p>
<p>这里我们的JdkDynamicAopProxy实现了InvocationHandler这个接口，this参数对应的是InvocationHandler对象,也就是说当 Proxy对象的函数被调用的时候，InvocationHandler的invoke方法会被作为回调函数调用：</p>
<p><img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>上面所说的目标对象方法的调用，是通过AopUtils的方法调用，使用反射机制来对目标对象的方法进行的：</p>
<p><img src="" alt=""></p>
<p>接下来，我们来看具体的ReflectiveMethodInvocation中proceed()方法的实现，也就是拦截器链的实现机制：</p>
<p><img src="" alt=""></p>
<p>从上面的分析我们看到了Spring AOP拦截机制的基本实现，比如Spring怎样得到Proxy，怎样利用JAVA Proxy以及反射机制对用户定义的拦截器链进行处理。</p>
<p><strong>3.6 织入的实现
</strong></p>
<p>在上面调用拦截器的时候，经过一系列的注册，适配的过程以后，拦截器在拦截的时候，会调用到预置好的一个通知适配器，设置通知拦截器，这是一系列Spring设计好为通知服务的类的一个，是最终完成通知拦截和实现的地方，例如对 MethodBeforeAdviceInterceptor的实现是这样的：</p>
<p><img src="" alt=""></p>
<p>可以看到通知适配器将advice适配成Interceptor以后，会调用advice的before方法去执行横切逻辑。这样就成功的完成了before通知的织入。</p>
<p><a href="http://www.goldendoc.org/tag/aop/" title="AOP (1主题)" target="_blank">AOP</a></p>
<h2 id="-spring-ioc-applicationcontext-http-www-goldendoc-org-2010-11-spring_ioc_applicationcontext-2-spring-ioc-applicationcontext-"><a href="http://www.goldendoc.org/2010/11/spring_ioc_applicationcontext-2/" title="永久链接：Spring IoC之ApplicationContext" target="_blank">Spring IoC之ApplicationContext</a></h2>
<p><a href="http://www.goldendoc.org/2010/11/spring_ioc_applicationcontext-2/#comments" target="_blank">0</a></p>
<p>2年前</p>
<p>由<a href="http://www.goldendoc.org/author/iwlh/" title="iwlh发表的文章 " target="_blank">iwlh</a>发布 在<a href="http://www.goldendoc.org/category/spring/" title="Spring (4主题)" target="_blank">Spring</a>
本章主要讲ApplicationContext接口对BeanFactory接口的扩展内容。BeanFactory接口主要围绕着bean和bean相关配置方式，没有关注应用环境的相关配置。ApplicationContext接口从BeanFactory接口派生而来，它与BeanFactory的对比如下图所示：</p>
<p>BeanFactory </p>
<p>ApplicationContext  Bean配置/实例化</p>
<p>Yes </p>
<p>Yes  自动装配BeanPostProcessor</p>
<p>No </p>
<p>Yes  自动装配BeanFactoryPostProcessor</p>
<p>No </p>
<p>Yes  国际化信息（MessageSources）支持</p>
<p>No </p>
<p>Yes  容器内部事件（ApplicationEvent）支持</p>
<p>No </p>
<p>Yes  多配置模块加载</p>
<p>No </p>
<p>Yes </p>
<p><strong>1、统一资源加载
</strong></p>
<p>Spring中提供了org.springframework.core.io.Resource接口作为所有资源的抽象。Spring中默认提供了一些Resource接口的实现类，如图所示：</p>
<p><img src="" alt=""></p>
<p>实现类命名上就可以看出对应的资源，比如ClassPathResource类是从java应用程序的ClassPath中加载相关资源等等。</p>
<p>Spring中使用ResourceLoader来查找和定位Resource资源。ResorceLoader接口类图如下所示：</p>
<p><img src="" alt=""></p>
<p>从上图可以看出，ApplicationContext接口继承自ResourceLoader接口。AbstractApplicationContext抽象类也继承自DefaultResourceLoader类，而且还拥有一个PathMatchingResourcePatternResolver属性字段，需要加载多个Resource时候，委派给PathMatchingResourcePatternResolver类加载即可。</p>
<p>回过来，让我们再看下DefaultResourceLoader中getResource方法的实现代码。</p>
<p><img src="" alt=""></p>
<p>可以看到getResource方法尝试了classPath、url方式加载资源。需要注意的是，该类不能加载相对路径或绝对路径下的资源（例如文件），如果需要加载绝对路径的资源，可以使用FileSystemResourceLoader对象。</p>
<p><strong>2、国际化信息支持
</strong></p>
<p>Java SE中已经有了国际化支持，也就是java.util.Locale和java.util.ResourceBundle。Spring在JavaSE的国际化支持上，进一步抽象了国际化信息的访问接口，提供了org.springframework.context.MessageSource接口，该接口提供一下方法：</p>
<p><img src="" alt=""></p>
<p>ApplicationContext也实现了MessageSource接口。当ApplicationContext初始化时，它会自动在容器中查找名称为”messageSource”的bean。如果找到，对上述方法的调用将被委托给该bean。否则ApplicationContext会在其父类中查找是否含有同名的bean。如果有，就把它作为MessageSource。如果它最终没有找到任何的消息源，一个空的StaticMessageSource将会被实例化，使它能够接受上述方法的调用。messageSource bean的配置实例如下：</p>
<p><img src="" alt=""></p>
<p>Spring提供了三种MessageSource的实现。即StaticMessageSource（提供简单实现，可通过编程方式添加信息条目，多用于测试，不应该用于正式的生产环境）、ResourceBundleMessageSource（基于标准的java.util.ResourceBundle而实现的MessageSource，对父类AbstractMessageSource进行扩展，提供对多个ResourceBundle的缓存以提高查询速度。是最常用的，可用于生产环境下的MessageSource）、ReloadableResourceBundleMessageSource（同样是基于标准的java.util.ResourceBundle而实现的MessageSource，通过cacheSeconds属性可以定期刷新并检查properties资源文件是否发生变化，并且通过ResourceLoader加载properties资源文件。）</p>
<p>另外，MessageSourceAware接口还能用于获取任何已定义的MessageSource引用。任何实现了MessageSourceAware接口的bean将在Spring容器初始化时候与MessageSource一同被注入。</p>
<p>MessageSource与ApplicationContext的类结构图如下所示：</p>
<p><img src="" alt=""></p>
<p><strong>3、Spring容器内部事件发布
</strong></p>
<p>ApplicationContext容器提供了容器内部事件发布功能，是继承自JavaSE标准自定义事件类而实现的。</p>
<p>JavaSE标准自定义事件结构不在此详细描述，一张图很直观的描述清楚：</p>
<p><img src="" alt=""></p>
<p>EventObject，为JavaSE提供的事件类型基类，任何自定义的事件都继承自该类，例如上图中右侧灰色的各个事件。Spring中提供了该接口的子类ApplicationEvent。</p>
<p>EventListener，为JavaSE提供的事件监听者接口，任何自定义的事件监听者都实现了该接口，如上图左侧的各个事件监听者。Spring中提供了该接口的子类ApplicationListener接口。</p>
<p>JavaSE中未提供事件发布者这一角色类， 由各个应用程序自行实现事件发布者这一角色。Spring中提供了ApplicationEventPublisher接口作为事件发布者，并且ApplicationContext实现了这个接口，担当起了事件发布者这一角色。但ApplicationContext在具体实现上有所差异，Spring提供了ApplicationEventMulticaster接口，负责管理ApplicationListener和发布ApplicationEvent。ApplicationContext会把相应的事件相关工作委派给ApplicationEventMulticaster接口实现类来做。类图如下所示：</p>
<p><img src="" alt=""></p>
<p>附上一张事件发布的时序图：</p>
<p><a href="http://pic.yupoo.com/goldendoc/AH0MxsWp/jBIbm.png" target="_blank"><img src="" alt=""></a></p>
<p><strong>4、多配置模块加载
</strong></p>
<p>现在的应用程序，一般都会把配置信息按照某些规则进行分割，将不同类型或关注点的配置项放置在不同的文件中。相对BeanFactory来说，ApplicationContext已经支持了加载多个配置文件。</p>
<p>ApplicationContext加载多个配置文件的方法有：</p>
<p>1) 数组方式</p>
<p>String[] locations = new String[]{ “conf/bean1.xml”,”conf/bean2.xml”, “conf/bean3.xml”};</p>
<p>ApplicationContext container = new FileSystemXmlApplicationContext(locations);</p>
<p>2) 通配符</p>
<p>ApplicationContext container = new FileSystemXmlApplicationContext(“conf//<em>/</em>//*.xml”);</p>
<p>3) ClassPathXmlApplicationContext特性</p>
<p>ApplicationContext ctx = new ClassPathXmlApplicationContext(new String[] {“services.xml”, “daos.xml”}, MessengerService.class);</p>
<p>该方法可以通过MessengerService类在ClassPath中的位置定位配置文件，而不用指定每个配置文件的完整路径名。</p>
<p><a href="http://www.goldendoc.org/tag/applicationcontext/" title="ApplicationContext (1主题)" target="_blank">ApplicationContext</a></p>
<h2 id="-spring-ioc-beanfactory-http-www-goldendoc-org-2010-11-spring-ioc-e4-b9-8bbeanfactory-spring-ioc-beanfactory-"><a href="http://www.goldendoc.org/2010/11/spring-ioc%e4%b9%8bbeanfactory/" title="永久链接：Spring IoC之BeanFactory" target="_blank">Spring IoC之BeanFactory</a></h2>
<p><a href="http://www.goldendoc.org/2010/11/spring-ioc%e4%b9%8bbeanfactory/#comments" target="_blank">0</a></p>
<p>2年前</p>
<p>由<a href="http://www.goldendoc.org/author/khotyn/" title="khotyn发表的文章 " target="_blank">khotyn</a>发布 在<a href="http://www.goldendoc.org/category/spring/" title="Spring (4主题)" target="_blank">Spring</a>
本文的内容为对Spring IoC容器实现的分析。</p>
<p>本文一共分为5个部分：</p>
<ul>
<li>第一部分简要讲述了IoC的概念</li>
<li>第二部分对Spring IoC容器中的主要类及其职责做一些了解</li>
<li>第三部分分析了Spring IoC容器的初始化过程</li>
<li>第四部分分析了从Spring IoC容器中获取Bean的过程</li>
<li>第五部分简要讲述了Spring IoC容器对Bean生命周期的管理。</li>
</ul>
<p>本文假设读者对以下的概念有所了解：IoC（控制反转），DI（依赖注入），Bean，并且读者有使用Spring IoC容器的经验。</p>
<p>约定：本文中所指的IoC容器没有特别说明均为Spring IoC容器</p>
<h3 id="-ioc-"><a href="">一、什么是</a><a href="">IoC</a><a href=""></a></h3>
<p><a href=""></a></p>
<p><a href="">IoC是Inversion of Control的缩写，中文的意思是控制反转，在IoC中，组件不需要去寻找它所依赖的对象，而是由IoC容器来负责将组件所依赖的对象通过Java Bean的Setter方法或者是构造函数等方式注入给组件。IoC的另一个名字是DI，即依赖注入，关于IoC和DI之间的关系以及关于IoC的更多内容，大家可以参考Wiki上的</a><a href="http://www.google.com/url?q=http%3A%2F%2Fzh.wikipedia.org%2Fzh%2F%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC&amp;sa=D&amp;sntz=1&amp;usg=AFQjCNGHDFZSBvJ9wlCDET_IgqV-4DVCzw">控制反转条目。
</a></p>
<p><a href="http://www.google.com/url?q=http%3A%2F%2Fzh.wikipedia.org%2Fzh%2F%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC&amp;sa=D&amp;sntz=1&amp;usg=AFQjCNGHDFZSBvJ9wlCDET_IgqV-4DVCzw">
</a></p>
<h3 id="-http-www-google-com-url-q-http-3a-2f-2fzh-wikipedia-org-2fzh-2f-e6-8e-a7-e5-88-b6-e5-8f-8d-e8-bd-ac-sa-d-sntz-1-usg-afqjcnghdfzsbvj9wlcdet_igqv-4dvczw-ioc-"><a href="http://www.google.com/url?q=http%3A%2F%2Fzh.wikipedia.org%2Fzh%2F%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC&amp;sa=D&amp;sntz=1&amp;usg=AFQjCNGHDFZSBvJ9wlCDET_IgqV-4DVCzw"></a>[二、IoC容器中的类主要类及其职责</h3>
<p>]()</p>
<p><a href="">
我们先来看下IoC容器的一个大概的类图：
</a></p>
<p><a href=""></a><a href="http://www.google.com/url?q=http%3A%2F%2Fpic.yupoo.com%2Fkhotyn%2F816909ab9c75%2Fji8tx5ue.jpg&amp;sa=D&amp;sntz=1&amp;usg=AFQjCNEixIuYlet6oZmgnSPQy-ZxrCs4yA"><img src="" alt=""></a></p>
<p><a href="http://www.google.com/url?q=http%3A%2F%2Fpic.yupoo.com%2Fkhotyn%2F816909ab9c75%2Fji8tx5ue.jpg&amp;sa=D&amp;sntz=1&amp;usg=AFQjCNEixIuYlet6oZmgnSPQy-ZxrCs4yA" target="_blank">点击查看大图</a></p>
<p>这张图中比较简单的展示了IoC容器中的各个类及其指责，我们需要重点把握几个接口的职责：</p>
<ul>
<li>BeanFactory：这个接口是整个IoC容器最底层的接口，定义了一组访问Bean容器的基本方法。一些其他的接口，比如ListableBeanFactory和ConfigurableBeanFactory，都是继承了BeanFactory，并添加了其他的方法来完成某些特别的功能（比如ConfigurableBeanFactory，顾名思义，这个接口的职责是让BeanFactory变得可配置，那么它就定义了一组可以配置BeanFactory的方法）。</li>
<li>AbstractBeanFactory：从名字可以看出，这个类是BeanFactory接口的一个抽象实现类，这个类本身实现的是ConfigurableBeanFactory，对ConfigurableBeanFactory以及BeanFactory中的方法提供了实现，并且提供了一些诸如单例缓存，别名等等功能。</li>
<li>SingletonBeanRegistry：定义了一组操作单例Bean的方法</li>
</ul>
<h3 id="-ioc-"><a href="">三、</a>[IoC容器的初始化</h3>
<p>]()<a href=""></a></p>
<p>[
使用过Spring的人都知道，我们都是在一份Bean配置文件中定义Bean，然后就可以通过BeanFactory的getBean()方法来获取Bean，那么我们就可以大致猜想到IoC容器的初始化工作大概就是将我们编写的Bean配置文件转换成IoC容器内部定义的用于放置Bean定义信息的数据结构，而这个数据结构就是BeanDefinition这个类。下面我们就来了解下这个转换过程是如何进行的。</p>
<p>我们通过实例化ClassPathXmlApplicationContext这个类来一步步来看其初始化的过程，简单地实例化ClassPathXmlApplicationContext的代码如下：</p>
<p><img src="" alt=""></p>
<p>这里我们传入一个beans.xml作为配置文件的路径去实例化一个ClassPathXmlApplicationContext。</p>
<p>首先我们还是来看下整个初始化过程的序列图：
]()</p>
<p><a href=""></a><a href="http://www.google.com/url?q=http%3A%2F%2Fpic.yupoo.com%2Fkhotyn%2F005389ab9c75%2Fogfhmraj.jpg&amp;sa=D&amp;sntz=1&amp;usg=AFQjCNHa07fld9fiZq1BzNzeljU3nfHFXQ"><img src="" alt=""></a></p>
<p><a href="http://www.google.com/url?q=http%3A%2F%2Fpic.yupoo.com%2Fkhotyn%2F005389ab9c75%2Fogfhmraj.jpg&amp;sa=D&amp;sntz=1&amp;usg=AFQjCNHa07fld9fiZq1BzNzeljU3nfHFXQ" target="_blank">点击查看大图</a></p>
<p>这个图中涉及到的类或许有点吓人，且慢，下面我会慢慢带你了解整个过程。从序列图里面我们看到初始化过程首先调用了refresh()方法，后面调用到了AbstractXmlApplicationContext的loadBeanDefinitions方法，来看下这个方法的实现：</p>
<p><img src="" alt=""></p>
<p>这个方法将beanFactory（实现了BeanDefinitionRegistry接口，后续将通过这个接口将Bean定义信息注册到BeanFactory中去）传入new了一个XmlBeanDefinitionReader对象，然后将刚刚new出来的beanDefinitionReader传入调用loadBeanDefinitions方法，最终调用了XmlBeanDefinitionReader的loadBeanDefinitions(EncodedResource encodedResource)方法：</p>
<p><img src="" alt=""></p>
<p>这个方法获取了Bean配置文件的输入流，并且调用了doLoadBeanDefinitions方法，在这个方法里面，程序将输入流转换成Document对象，然后调用了下面这个方法：</p>
<p><img src="" alt=""></p>
<p>需要注意这个createReaderContext(resource)方法，创建这个方法的时候XmlBeanDefinitionReader将自己传入，以便在后面可以获取到它的Registry对象。最终DefaultBeanDefinitionDocumentReader将解析BeanDefinition的工作又交给了BeanDefinitionParserDelegate对象：</p>
<p><img src="" alt=""></p>
<p>从上面的方法中，我们可以看到BeanDefinitionParserDelegate对象解析出BeanDefinition后，就由BeanDefinitionRegistry来将BeanDefinition注册到BeanFactory中去了。</p>
<p>至此，整个BeanFactory就初始化完毕了，可能一大堆方法调来调去地早就把大家给调晕了，我们就来总结下初始化过程中设计到的几个主要的类以及它们的职责吧：</p>
<ul>
<li>XmlBeanDefinitionReader：读取定义Bean的XML文件并且将XML文件转成Document对象，交给BeanDefinitionDocuementReader再做解析。它持有一个BeanDefinitionRegistry对象，用于将BeanDefinition注册到BeanFactory中去。</li>
<li>XmlBeanDefinitionDocumentReader：取出Docuement对象内的各个元素并将这些元素交给BeanDefinitionParserDelegate来解析。</li>
<li>BeanDefinitionParserDelegate：用于解析Bean定义信息的代理类，负责一个Bean定义信息（可以看作是一个<bean></bean>标签对）解析成一个BeanDefinition对象。</li>
<li>BeanDefinitionRegister：负责将BeanDefinition注册到BeanFactory中去。</li>
</ul>
<h3 id="-ioc-bean-"><a href="">四、从</a><a href="">IoC容器中获取Bean</a><a href=""></a></h3>
<p><a href="">
用过Spring的人大概都知道，在Spring中，我们是通过调用BeanFactory的getBean()方法来取得我们所需要的Bean的，而getBean()方法的主要逻辑在AbstactBeanFactory的doGetBean()方法中。在Spring中，有单例Bean和原型Bean的区分，在从容器中获取Bean的时候，单例Bean和原型Bean有些不同，当第一次获取单例Bean的时候，整个过程和获取原型Bean几乎是一样的，都需要创建一个Bean，但是当第二次，第三次，……，获取同样的单例Bean的时候，容器就直接从单例缓存中获取Bean了，而不会再去像获取原型Bean一样一而再再而三地创建Bean了。这样我们这一节也主要从两个方面来讲，一个是获取原型Bean，第一次获取单例Bean的逻辑和这个类似，有特别的地方也会在这里顺带提到，二则是将从单例缓存中获取单例Bean的过程，首先我们来看获取原型Bean：
</a></p>
<h3 id="-4-1-bean"><a href=""></a>[4.1、获取原型Bean</h3>
<p>]()</p>
<p>[
正如前面所说，我们来看下AbstractBeanFactory的doGetBean()方法来了解获取原型Bean的整个过程。</p>
<p>在获取Bean的时候，无论这个Bean是单例的还是原型的，Spring都会尝试从单例缓存中获取Bean，但是当拿原型Bean的时候，这里显然是拿不到的，接下来程序就会根据BeanDefinition信息来判断要创建的Bean是不是原型Bean，如果是，则进入下面这段逻辑：</p>
<p><img src="" alt=""></p>
<p>程序在上图的（1）中的位置调用了beforePrototypeCreation方法，告诉容器当前的这个Bean正在创建中，来防止发生重复创建的情况。接下来，程序在（2）处调用了createBean方法来创建这个prototypeBean，最后，在（3）处，程序调用afterProtytypeCreation来告诉容器，这个Bean现在已经不再创建过程中了。</p>
<p>那么，让我们来关注下createBean这个方法里面干了些什么事情：</p>
<p><img src="" alt=""></p>
<p>在做了一堆准备工作后，程序就到了上面的这一段中，从代码中我们可以看出这个方法主要的功能为以下两点：</p>
<ul>
<li>调用resolveBeforeInstantiation方法，让BeanPostProcessor可以有机会给你返回一个代理类而不是原来的类，当后面我们看到Spring AOP代理类的生成的时候，就会看到这个方法的用处了。</li>
<li>调用doCreateBean()方法创建Bean</li>
</ul>
<p>我们再来看下doCreateBean方法：</p>
<p><img src="" alt=""></p>
<p>同样，这个方法里面也有两个主要的功能：</p>
<ul>
<li>一是调用createBeanInstance方法，创建一个Bean实例，在这个方法的内部，会调用BeanUtils的instantiateClass来实例化Bean，并把它包装成一个BeanWrapper</li>
<li>二是调用populateBean方法来将Bean依赖的属性设置进去。
]()</li>
</ul>
<h3 id="-4-2-bean"><a href=""></a>[4.2、创建单例Bean</h3>
<p>]()</p>
<p>[
整个获取原型Bean的过程大概就是这样样子，因为创建单例Bean和这个过程基本上是一样的，但是也有一些稍微不一样的地方，这里也稍微提到一下：</p>
<p><img src="" alt=""></p>
<p>创建单例Bean是通过调用getSingleton来实现的，这个方法传入一个beanName和一个ObjectFactory，这个ObjectFactory的getObject方法里面调用到了我们前面提到的createBean方法，所以我们看下getSingleton这个方法的实现：</p>
<p><img src="" alt=""></p>
<p>这个方法先尝试从singletonObjects中获取单例Bean，如果获取不到，则自己创建，同样，和创建原型Bean一样，在创建开始之前会调用beforeSingletonCreation方法来将beanName放到singletonsCurrentlyInCreation来告诉容器这个Bean已经在创建中了，在创建完成之后，会将BeanName从singletonsCurrentlyInCreation中删除掉。创建的过程是调用了传入的ObjectFactory的getObject方法，和创建原型Bean类似。在创建完成之后，还有一步addSingleton的操作，来讲单例放到单例缓存中去，看一下这个的实现：</p>
<p><img src="" alt=""></p>
<p>方法的逻辑非常简单：把创建出来的单例Bean放到singletonObjects中去，然后从singletonFactories和earlySingletonObjects中删除掉，最后在registeredSingletons里面再加入这个Bean，对于这里面用到的几个容器，我觉得有必要在这里描述一下其作用，要不然读者肯定是晕呼晕呼的：</p>
<ul>
<li>singletonObjects：用于保存BeanName和Bean实例之间的关系</li>
<li>singletonFactories：用于保存BeanName和创建Bean的工厂之间的关系</li>
<li>earlySingletonObjects：也是保存BeanName和Bean实例之间的关系，与singletonObjects的不同之处在于，当一个单例Bean被放到这里面去后，那么当Bean还在创建过程中，就可以通过getBean来拿到了，其目的是用来检测循环引用。</li>
<li>registeredSingletons：用来保存当前所有已注册的Bean
]()</li>
</ul>
<h3 id="-4-3-bean"><a href=""></a>[4.3、从单例缓存中获取单例Bean</h3>
<p>]()</p>
<p>[
单例在Spring的同一个容器内只会被创建一次，后续再获取Bean，就直接从单例缓存中获取了，我们来看下这一段过程，看下doGetBean里面调用的getSingleton方法：</p>
<p><img src="" alt=""></p>
<p>这个方法的逻辑也相对简单，先尝试从singletonObjects里面获取，如果获取不到再从earlySingletonObjects里面获取，如果再获取不到，再尝试从singletonFactories里面获取beanName对应的ObjectFactory，然后调用这个ObjectFactory的getObject来创建Bean，并放到earlySingletonObjects里面去，并且从singletonFacotories里面remove掉这个ObjectFactory。</p>
<h3 id="-ioc-bean-">六、IoC容器对Bean生命周期的管理</h3>
<p>Spring有一套Bean生命周期去管理Bean，值得注意的是，Spring只对非单例的Bean进行生命周期管理。关于Spring中Bean的生命周期，我们来看下一张老图：</p>
<p><img src="" alt=""></p>
<p>在上面这张图里面，我们看到有很多的生命周期方法，那么这些生命周期方法是在哪里调用的呢？在前面获取原型Bean的一节中，我们已经知道，Spring会先调用createBeanInstance方法来创建Bean实例，然后通过populateBean方法来设置Bean的属性，在调用这个方法之后，其实Spring还调用了一个initializeBean的方法，上图中我们看到的生命周期方法基本上都在这个方法里面调用：</p>
<p><img src="" alt=""></p>
<p>在这个方法里面：</p>
<ul>
<li>Spring首先调用了invokeAwareMethods来调用各个Aware方法，包括BeanNameAware，BeanClassLoaderAware和BeanFactoryAware</li>
<li>然后调用了所有BeanPostProcessor的postProcessBeforeInitialization方法</li>
<li>接着调用invokeInitMethods方法，里面包括调用afterPropertiesSet和自定义的init方法</li>
<li>最后调用了所有BeanPostProcessor的postProcessAfterInitialization方法</li>
</ul>
<p>在调用这些方法以后，我们的Bean才算是可以使用啦。至于生命周期的最后两个方法，是在容器销毁的时候来调用的。
]()<a href=""></a></p>
<p><a href=""></a></p>
<p><a href=""></a><a href="http://www.goldendoc.org/tag/beanfactory/" title="BeanFactory (1主题)">BeanFactory</a></p>
<p>*</p>
<ul>
<li><h3 id="-">分类</h3>
</li>
<li><p><a href="http://www.goldendoc.org/category/java-nio/" title="查看 Java NIO下的所有文章" target="_blank">Java NIO <strong>(9)</strong> Java NIO相关内容</a></p>
</li>
<li><a href="http://www.goldendoc.org/category/jms/" title="查看 JMS下的所有文章" target="_blank">JMS <strong>(3)</strong> Java Messaging Service</a></li>
<li><a href="http://www.goldendoc.org/category/juc/" title="查看 JUC下的所有文章" target="_blank">JUC <strong>(4)</strong></a></li>
<li><a href="http://www.goldendoc.org/category/jvm/" title="查看 JVM下的所有文章" target="_blank">JVM <strong>(8)</strong> Java Virtual Machine</a></li>
<li><a href="http://www.goldendoc.org/category/spring/" title="查看 Spring下的所有文章" target="_blank">Spring <strong>(4)</strong></a></li>
<li><a href="http://www.goldendoc.org/category/tomcat/" title="查看 Tomcat下的所有文章" target="_blank">Tomcat <strong>(7)</strong></a></li>
<li><a href="http://www.goldendoc.org/category/translation/" title="查看 翻译下的所有文章" target="_blank">翻译 <strong>(1)</strong></a></li>
<li><h3 id="-">最新评论</h3>
</li>
<li><p><a href="http://www.goldendoc.org/2012/01/optimization-barrier3/#comment-306" title="在 优化屏障（Optimization barrier）第三讲" target="_blank"><img src="" alt="熊猫家族">  熊猫家族 很详细，了解了很多 5个月前</a></p>
</li>
<li><a href="http://www.goldendoc.org/2011/06/juc_concurrenthashmap/#comment-304" title="在 Java并发编程之ConcurrentHashMap" target="_blank"><img src="" alt="聊聊并发（四）深入分析ConcurrentHashMap并发编程网 | 并发编程网">  聊聊并发（四）深入分析ConcurrentHashMap并发编程网 | 并发编程网 [...] Java并发编程之ConcurrentHashMap [...] 6个月前</a></li>
<li><a href="http://www.goldendoc.org/2011/06/juc_concurrenthashmap/#comment-301" title="在 Java并发编程之ConcurrentHashMap" target="_blank"><img src="" alt="Jun">  Jun for (HashEntry p = first; p != e; p = p.next) newFirst = new HashEntry(p.key, p.hash, […] 6个月前</a></li>
<li><a href="http://www.goldendoc.org/2011/06/juc_concurrenthashmap/#comment-294" title="在 Java并发编程之ConcurrentHashMap" target="_blank"><img src="" alt="khotyn">  khotyn 这里是我搞错了，已经纠正过来了，谢谢赵姐夫指正。 7个月前</a></li>
<li><a href="http://www.goldendoc.org/2011/06/juc_concurrenthashmap/#comment-293" title="在 Java并发编程之ConcurrentHashMap" target="_blank"><img src="" alt="老赵">  老赵 这里Segment的数量是不大于concurrentLevel的最大的2的指数 应该是“不小于concurrentLevel”的最小的2的指数吧。 7个月前</a>
<a href="&quot;显示下5个条目&quot;">显示更多</a></li>
<li><h3 id="-">最新文章</h3>
</li>
<li><p><a href="http://www.goldendoc.org/2013/01/parentdelegation/" title="从问题出发看双亲委派" target="_blank">从问题出发看双亲委派 (0)  同事A问了这样一个问题： <em>BootstrapClassLoader为什么能够加载用户自定义的类？</em> 当时我想到的是这样的场景： javaagent设置Boot-Class-Path，或者添加启动参数-Xbootclasspath、-Xbootclasspath/a […] 5个月前</a></p>
</li>
<li><a href="http://www.goldendoc.org/2012/07/somethings_i_ve_learnt_about_programming/" title="我学到的一些关于编程的事儿（翻译）" target="_blank">我学到的一些关于编程的事儿（翻译） (3) 原文地址：Some things I&#39;ve learnt about programming ---- By John Graham-Cumming 我已经从事编程 30 年了，用过的机器包括从现在看来很差的（基于 Z80 和 6502）到最新的，用过的语言包括 […] 11个月前</a></li>
<li><a href="http://www.goldendoc.org/2012/02/classloader-jvm/" title="ClassLoader与JVM" target="_blank">ClassLoader与JVM (0) <strong>一、ClassLoader与HotSpot</strong> 对JVM有所了解的人应该知道，类文件的格式是不能违背JVM规范的，而JVM自然会有解析类文件的工具ClassFileParser。 ClassFileParser由ClassFileStream/*构造，其实 […] 1年前</a></li>
<li><a href="http://www.goldendoc.org/2012/01/optimization-barrier3/" title="优化屏障（Optimization barrier）第三讲" target="_blank">优化屏障（Optimization barrier）第三讲 (1) 上一篇 优化屏障（Optimization barrier）第二讲 1. […] 1年前</a></li>
<li><a href="http://www.goldendoc.org/2012/01/optimization-barrier2/" title="优化屏障（Optimization barrier）第二讲" target="_blank">优化屏障（Optimization barrier）第二讲 (1) 上一篇 优化屏障（Optimization barrier）第一讲 1. gcc编译的大致过程 可以看到，gcc优化主要分两大部分:Tree优化和RTL(Register Transfer Language)优化； 前文所说的指令调度（Instruction […] 1年前</a>
<a href="&quot;显示下5个条目&quot;">显示更多</a></li>
<li><h3 id="-">友情链接</h3>
</li>
<li><p><a href="http://ifeve.com/" target="_blank">并发编程促进并发编程的研究和传播</a>
自豪地使用<a href="http://wordpress.org/" target="_blank">WordPress</a>，Mystique主题来自<a href="http://digitalnature.eu/" target="_blank">digitalnature</a> | <a href="http://www.goldendoc.org/feed/" target="_blank">RSS订阅</a>  <a href="">回到顶部</a></p>
</li>
</ul>
<p><a href=""> </a></p>
<p><a href=""> </a></p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/框架汇总/">框架汇总</a></li></span><span class="breadcrumb"><li><a href="/categories/框架汇总/">框架汇总</a></li><li><a href="/categories/框架汇总/Spring/">Spring</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Spring/" class="label label-primary">Spring</a><a href="/tags/框架汇总/" class="label label-success">框架汇总</a></span> | <span class="time">recent updated:<time title="2014-03-07 01:54:29"datetime="2014-03-07 01:54:29"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-框架汇总-Spring--Spring-设计模式-aop-ioc/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-框架汇总-Spring--Spring-设计模式-aop-ioc" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-eclipse-插件--EclipseProfilerPlugin/">Eclipse Profiler Plugin</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T09:54:29.000Z"> <a href="/2014/02/02/2014-02-02-eclipse-插件--EclipseProfilerPlugin/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="eclipse-profiler-plugin">Eclipse Profiler Plugin</h1>
<h1 id="eclipse-profiler-plugin">Eclipse Profiler Plugin</h1>
<p>This is a plugin for the Eclipse platform which allows java code profiling. <a href="http://sourceforge.net/projects/eclipsecolorer" target="_blank">Project</a></p>
<h2 id="license">License</h2>
<p>CPL.</p>
<h2 id="general-note">General note</h2>
<p>1.) if you run the remote profiler, the filter settings in the eclipse environment are not taken into account. Instead you must provide the filter settings in the start command of your application server. You do this by adding an environment variable <strong>PROFILER_PACKAGE_FILTER to the startup command of your aplication, see below. 2.) Setting up the profiler package filters (in general) You must define the environment variable </strong>PROFILER<em>PACKAGE<em>FILTER as shown below in the examples for tomcat, jboss, weblogic and resin. General important Note: The environment variable contains following parts: the application starting class (<strong>A</strong>) inclusion filters (<strong>P</strong>) exclusion filters (__M</em></em>) You must provide exactly one starting class, but you can have multiple inclusion and exclusion filters. The parts MUST be separated by the OS specific path.separator, i.e. &quot;:&quot; for unix or &quot;;&quot; for WINDOWS platforms) example package filter setting for WINDOWS: -D<strong>PROFILER_PACKAGE_FILTER=</strong>A<strong>org.apache.catalina.startup.Bootstrap;</strong>M<strong>sun.;</strong>P<strong>my.company.classes. example package filter setting for UNIX/LINUX: -D</strong>PROFILER_PACKAGE_FILTER=<strong>A</strong>org.apache.catalina.startup.Bootstrap:<strong>M</strong>sun.:<strong>P</strong>my.company.classes. In the examples below we provide the WINDOWS style. Please take care to use the LINUX/UNIX style if that aplies to you.</p>
<h2 id="win32-installation">Win32 installation</h2>
<p>Copy ProfilerDLL.dll from root plugin folder into bin folder of your JRE installation. You can skip this step, plugin will ask you and copy DLL into your JRE\BIN when you will start profiling local application inside of Eclipse first time. It will also check, that you have in JRE\BIN same DLL as in plugin directory.</p>
<h2 id="linux-installation">Linux installation</h2>
<p>Profiler has native part compiled with gcc 3.2, but if you have old gcc or libraries you can build native part yourself. Extract files from native\profiler_linux.tgz and look at script &quot;m&quot;. This is example of compilation script. Change it as needed for you OS.
See also profile_cpu/profile_heap for examples of start line for cpu and heap profiling and r_cpu/r_heap as example how to use them.</p>
<h2 id="usage">Usage</h2>
<p>Profiler plugin creates additional kind of launch configuration in Run menu. Profiler tab allows the user to define packages which shouldn&#39;t be instrumented, thus, all time usage will be referred to calling methods.
You can specify refresh rate, i.e. how often plugin will read statistics from prolifing JVM.
You can also set method, how to get time of enter in method and leave. There are two methods: fast, but usefull only if you have one active thread, which tries to use all CPU; or slow, which use JVMPI function GetCurrentThreadCpuTime() and allows detect how much of CPU was used by thread. However with this method profiled program runs about 3 times slower than with fast method.
<img src="" alt="">
<strong>Fig. 1. Launch configuration.</strong></p>
<p>Profiler supports inclusive (grren) and exlusive (red) filters. You can noy only specify what packages should be excluded from instrumentation, but also what packages should be included. Usefull, if you want to profile only your own classes. You can move filters up and down using buttons or drag and drop.
<img src="" alt="">
<strong>Fig. 1.1. Drag filters.</strong></p>
<p>Plugin allows remote profiling with &quot;Remote Profiler&quot; launch configuration. Notice, that remote profiling is supported only in &quot;run&quot; mode, i.e. when you create launch configuration using &quot;Run|Run...&quot; menu item.
You need to start remote application with special switches like: java -XrunProfilerDLL -Xbootclasspath/a:jakarta-regexp.jar;profiler<em>trace.jar;commons-lang.jar -D<strong>PROFILER_PACKAGE_FILTER=</strong>M<strong>sun.;</strong>M<strong>com.sun. -D</strong>PROFILER<em>USE<em>PACKAGE<em>FILTER=1 Here <strong>M</strong> prefix used for exclusive filter, __P</em></em> can be used for inclusive filter. And you should use __A</em></em> for class with method &quot;main&quot;.
<img src="" alt="">
<strong>Fig. 2. Remote launch configuration.</strong></p>
<h2 id="tomcat-cpu-profiling">Tomcat CPU profiling</h2>
<p>Profiler was tested with jakarta-tomcat-4.1.12. Add after lines in catalina.bat:
set <em>EXECJAVA=%<em>RUNJAVA%
set MAINCLASS=org.apache.catalina.startup.Bootstrap
set ACTION=start
set SECURITY_POLICY_FILE=
set DEBUG_OPTS=
set JPDA=
following line:
set JAVA_OPTS=-XrunProfilerDLL:1 -Xbootclasspath/a:jakarta-regexp.jar;profiler_trace.jar;commons-lang.jar -D<strong>PROFILER_PACKAGE_FILTER=</strong>A</em></em>%MAINCLASS%;<strong>M</strong>sun.;<strong>M</strong>com.sun.;<strong>M</strong>java.;<strong>M</strong>javax.;<strong>M</strong>org.apache. -D__PROFILER_TIMING_METHOD=1
Then copy jar&#39;s: commons-lang.jar jakarta-regexp.jar profiler_trace.jar to bin directory of tomcat. Now you can start tomcat using startup.bat and it will gather statistics for you. Next step is configuring Eclipse. You should create remote launch configuration and set host address as needed. This is all. Launch it, plugin will connect to your Tomcat and show you some statistics.</p>
<h2 id="tomcat-heap-profiling">Tomcat heap profiling</h2>
<p>Profiling heap is almost same as CPU profiling, but you should use following line:
set JAVA<em>OPTS=-XrunProfilerDLL:3,10,0 -D<strong>PROFILER_PROFILE_HEAP=1 -Xbootclasspath/a:jakarta-regexp.jar;profiler_trace.jar;commons-lang.jar -D</strong>PROFILER<em>PACKAGE<em>FILTER=<em>_A</em></em>%MAINCLASS%;__M</em></em> -D__PROFILER_TIMING_METHOD=1</p>
<h2 id="jboss-profiling">JBoss profiling</h2>
<p>Profiler was tested with jboss-3.0.6_tomcat-4.1.18. Add following line in your bin/run.bat (directly after echo off):
set JAVA_OPTS=-XrunProfilerDLL:1 -Xbootclasspath/a:jakarta-regexp.jar;profiler_trace.jar;commons-lang.jar -D<strong>PROFILER_PACKAGE_FILTER=</strong>A<strong>org.jboss.Main;</strong>M<strong>sun.;</strong>M<strong>com.sun.;</strong>M<strong>java.;</strong>M<strong>javax. -D</strong>PROFILER_TIMING_METHOD=1
Then copy jar&#39;s: commons-lang.jar jakarta-regexp.jar profiler_trace.jar to bin directory of JBoss. Now you can start JBoss using run.bat and it will gather statistics for you. Next step is configuring Eclipse. You should create remote launch configuration and set host address as needed. This is all. Launch it, plugin will connect to your JBoss and show you some statistics.</p>
<h2 id="weblogic-profiling">WebLogic profiling</h2>
<p>Profiler was tested with WebLogic 8.1, installed in &quot;c:/bea&quot;. WebLogic has its own JRE&#39;s, so you will need to copy ProfilerDLL.dll manually to C:\bea\jdk141_02\jre\bin. For profiling examples, change file C:\bea\weblogic81\samples\domains\examples\startExamplesServer.cmd, line where JAVA_OPTIONS is defined:
set JAVA_OPTIONS=-XrunProfilerDLL:1 -Xbootclasspath/a:jakarta-regexp.jar;profiler_trace.jar;commons-lang.jar -D<strong>PROFILER_PACKAGE_FILTER=</strong>A<strong>weblogic.Server;</strong>M<strong>sun.;</strong>M<strong>com.sun.;</strong>M<strong>java.;</strong>M<strong>javax.;</strong>M<strong>weblogic. -D</strong>PROFILER_TIMING_METHOD=1
Then copy jar&#39;s: commons-lang.jar jakarta-regexp.jar profiler_trace.jar to &quot;C:\bea\weblogic81\samples\domains\examples&quot;. Now you can start WebLogic examplex using startExamplesServer.cmd, or shortcut in Windows menu, and it will gather statistics for you. Next step is configuring Eclipse. You should create remote launch configuration and set host address as needed. This is all. Launch it, plugin will connect to your WebLogic and show you some statistics.</p>
<h2 id="resin-profiling">Resin profiling</h2>
<p>Profiler was tested with Resin-ee 2.1.10. Create batch file with following content in &quot;bin&quot;:
httpd.exe -J-XrunProfilerDLL:1 -Xbootclasspath/a:c:/prof/jakarta-regexp.jar;c:/prof/profiler_trace.jar;c:/prof/commons-lang.jar -D<strong>PROFILER_PACKAGE_FILTER=</strong>A<strong>com.caucho.server.http.HttpServer;</strong>M<strong>sun.;</strong>M<strong>com.sun.;</strong>M<strong>java.;</strong>M<strong>javax. -D</strong>PROFILER_TIMING_METHOD=1
Then create directory &quot;prof&quot; in disc &quot;C&quot; and copy jar&#39;s: commons-lang.jar jakarta-regexp.jar profiler_trace.jar. Now you can start your batch file and it will gather statistics for you. Next step is configuring Eclipse. You should create remote launch configuration and set host address as needed. This is all. Launch it, plugin will connect to your Resin and show you some statistics.</p>
<h2 id="options">Options</h2>
<p>Profiler supports several options via -DXXX.
Options Description <strong>PROFILER_PACKAGE_FILTER Contains list of packages to include or exclude.
Here </strong>P<strong> - inclusive pattern, </strong>M<strong> - exclusive pattern.
And </strong>A<strong> - application start class.
Examples:
Include only ru./<em> and de./</em> packages: </strong>P<strong>ru.;</strong>P<strong>de.
Exclude system packages: </strong>A<strong>org.jboss.Main;</strong>M<strong>sun.;</strong>M<strong>com.sun.;</strong>M<strong>java.;</strong>M<strong>javax.
If at least one inclusive pattern used, only classes accepted by inclusive patterns will be instrumented. </strong>PROFILER_TIMING_METHOD Specifies timing method - how to measure elapsed time.
0 - fast, System.currentTimeMillis(), good for application without sleeps and waits.
1 - precise, thread aware, slow, good for multithreaded applications.
2 - sampling profiling, very fast, good for long runned processes. <strong>PROFILER_PROFILE_HEAP 1, if HEAP profiling should be used. </strong>PROFILER_AUTO_START 0 - don&#39;t start automatically.
1 (default) - start automatically. <strong>PROFILER_START_ON_METHOD Start method name. When applications tries to enter in this method profiling starts (see </strong>PROFILER_AUTO_START, it should be 0).
Example: -D<strong>PROFILER_START_ON_METHOD=ru.nlmk.train.Main.mainLoop </strong>PROFILER_PAUSE_ON_METHOD 1, if you need pause profiling when <strong>PROFILER_START_ON_METHOD leaved. </strong>PROFILER_INSTRUMENT_SYSTEM_CLASSES 1, if you need instrument additional system classes, like java.lang.String, etc. Expensive! __PROFILER_WAIT_FRONTEND_CONNECT 1, if you need to wait, until frontend (plugin) will connect. (0 by default).</p>
<h2 id="cpu-profiling">CPU profiling</h2>
<p>Profiler supports CPU profiling and basic function for heap profiling. The profiler collects invocation count and direct time statistics for every method. Direct time is the amount of time used by selected method for execute. Also a total time value displayed in calling tree for selected thread. The total time means a time used by selected method and by all the methods it had called.</p>
<p>Only instrumentation profiling method is supported because of its precise. The overhead expenses reflects at speed decreasing app. 5 times to normal.</p>
<h2 id="how-it-works">How it works</h2>
<p>The profiler subscribes for JVPMI event JVMPI_EVENT_CLASS_LOAD_HOOK which called during every class loading. The profiler modifies loading byte-code by adding profiler&#39;s method call &quot;enter&quot; in the beginning of the every method of loading class and at the end of it - &quot;leave&quot;. &quot;Enter&quot; profiler&#39;s method notes the time of entering to profiling method. &quot;Leave&quot; makes method leaving timestamp and calculates a difference between enter and leave timestamps. This difference means total time for this method call. Direct time calculates as total time of this method minus total time of the all methods called by it. The profiles makes some time corrections for the time spent by profiler.</p>
<p>The profiler implemented as an Eclipse perspective with following views: Threads, Packages, Classes, Methods, Thread methods, Thread call tree, Heap.</p>
<p><strong>Threads.</strong>
Shows a list with all threads (alive or dead) in the current process. Here you can pause/resume refreshing of statistics in views, pause/resume all threads in profilied program, clear all statistics or run GC in profiled JVM.
<img src="" alt="">
<strong>Fig. 3. Threads View.</strong></p>
<p><strong>Call graph.</strong>
Profiler uses Draw2D for displaying call graph of thread. All methods shown in several columns, column depends on level, on which this method was called. Inside one column methods sorted by direct time used. Each node in graph has color from red to dark gray, depending on direct time. Methods with maximum time use have red color, and methods, which almost don&#39;t use time, have grey color. Each method has hint with detailed information. You can double click on method to open it in editor.
Lines between method present call from source method to target. Lines from one level to directly next have black color, to next - blue, inside one level - red, and from backward calls - green. Width of line depeneds on how much of time use in this call.
<img src="" alt="">
<strong>Fig. 3.1. Call graph.</strong>
You can also see hit for call. <img src="" alt="">
<strong>Fig. 3.2. Call hint.</strong>
As you can see, full graph looks fairly complex, but you can select part of it. Press mouse on some method and select then button &quot;Show callers&quot;, &quot;Show calles&quot; or &quot;Show caller and callees&quot;. You can see something like this: <img src="" alt="">
<strong>Fig. 3.3. Callers.</strong>
<img src="" alt="">
<strong>Fig. 3.4. Callees.</strong>
<img src="" alt="">
<strong>Fig. 3.5. Callers and callees.</strong>
You can double click on call line for opening editor with source method with highlighting places, where it calls target method. <img src="" alt="">
<strong>Fig. 3.6. Show calls.</strong></p>
<p><strong>Packages.</strong>
Shows a list with all methods with class hierarchy from package. This allows to determine packages which used the most of CPU time. In this view (and in Classes and Methods views also) the user can see in gray color the methods with unmodified parameters since last update. The user can hide such kind of methods by applying appropriate filters.
Here:
Name - name of package/class/method
Inv. - invocation count
% - percent of all invocations
Time - direct time used
% - percent of total time
Time/Inv. - average time used for one invocation
Total time - total time used directly by method and by all methods it calls
Inst. time - time used for instrumentation of class
<img src="" alt="">
<strong>Fig. 4. Packages View.</strong></p>
<p>You can add package or class to filter by pressing right mose button on element in table and selecting menu item. Filter can be added to launch configuration filter (will be used in next profiling, if you will active it) or to view filters (will be activated right now).
<img src="" alt="">
<strong>Fig. 4.1. Add filter.</strong></p>
<p><strong>Classes.</strong>
Shows a list of all class methods with method hierarchy from class. This allows to determine classes with the most CPU time usage.
<img src="" alt="">
<strong>Fig. 5. Classes View.</strong></p>
<p><strong>Filters.</strong>
Allows to define which kind of methods can be shown.
<img src="" alt="">
<strong>Fig. 6. Filters.</strong>
You can save configured name patterns (inclusive or exalusive) with some name and description, then you will able to select them in check list box. <img src="" alt="">
<strong>Fig. 6.1. New filter.</strong>
Later you can change this user defined filter. <img src="" alt="">
<strong>Fig. 6.2. Edit filter.</strong></p>
<p><strong>Methods.</strong>
Shows the statistics for all methods of the current process.
<img src="" alt="">
<strong>Fig. 7. All Methods View.</strong></p>
<p><strong>Thread methods.</strong>
Shows methods statictics for thread selected in Threads View.
<img src="" alt="">
<strong>Fig. 8. Thread Methods View.</strong></p>
<p><strong>Thread tree.</strong>
Shows a methods invocation tree for thread selected in Threads View. Here red square used for highlighted methods (from thread methods context menu) and green dot used for all other methods.
<img src="" alt="">
<strong>Fig. 9. Thread Tree View.</strong></p>
<p><strong>Inverted thread tree.</strong>
Shows a methods invocation tree for thread selected in Threads View starting from leaves. This allows you fastly detect, that some leaf method uses much of total time and see, what methods it is called.
<img src="" alt="">
<strong>Fig. 9.1. Inverted thread Tree View.</strong></p>
<p><strong>Heap.</strong>
Shows heap usage graph: total (green), used (blue) and free (yellow) heap.
<img src="" alt="Heap View.">
<strong>Fig. 10. Heap View.</strong></p>
<p>Here is an overall view of the profiler perspective. You can see a method HashMap.put opened in source code editor with highlighted lines of code which has the maximum hit count (size of annotation depends on hit count). You can open source code editor by choosing menu item &quot;Open method in editor&quot; in context menu.
<img src="" alt="">
<strong>Fig. 11. Perspective.</strong></p>
<p><a href="http://sourceforge.net/" target="_blank"><img src="" alt="SourceForge Logo"></a></p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/eclipse/">eclipse</a></li></span><span class="breadcrumb"><li><a href="/categories/eclipse/">eclipse</a></li><li><a href="/categories/eclipse/插件/">插件</a></li></span></span> | <span class="tags">Tagged <a href="/tags/eclipse/" class="label label-primary">eclipse</a><a href="/tags/插件/" class="label label-success">插件</a></span> | <span class="time">recent updated:<time title="2014-03-07 01:54:29"datetime="2014-03-07 01:54:29"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-eclipse-插件--EclipseProfilerPlugin/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-eclipse-插件--EclipseProfilerPlugin" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>





<ul id="pagination" class="pagination pagination-lg">
  <li><a class="extend prev" href="/page/146/">&laquo;</a></li><li><a class="page-number" href="/">1</a></li><li><a class="page-number" href="/page/2/">2</a></li><li><span class="space">&hellip;</span></li><li><a class="page-number" href="/page/144/">144</a></li><li><a class="page-number" href="/page/145/">145</a></li><li><a class="page-number" href="/page/146/">146</a></li><li class="active"><li><span class="page-number current">147</span></li><li><a class="page-number" href="/page/148/">148</a></li><li><a class="page-number" href="/page/149/">149</a></li><li><a class="page-number" href="/page/150/">150</a></li><li><span class="space">&hellip;</span></li></li><li><a class="page-number" href="/page/161/">161</a></li><li><a class="page-number" href="/page/162/">162</a></li><li><a class="extend next" href="/page/148/">&raquo;</a></li>
  <div class="clearfix"></div>
</ul></div><!--wapper-->
       </div><!-- ID main-col END -->
       <aside id="sidebar" class="alignright col-sx-6 col-sm-4 col-md-3 col-lg-3">
<div id="widget_search" class="widget panel panel-primary">
    <form action="//google.com/search" method="get" accept-charset="utf-8">
  <div class="input-group">
    <input class="form-control" id="searchbox" type="search" name="q" results="0" placeholder="search">
    <span class="input-group-btn">
      <button class="btn btn-default" type="submit">Go!</button>
    </span>
    <input type="hidden" name="q" value="site:itsolife.com">
  </div>
</form>
</div>

<div id="widget_category" class="widget panel panel-primary">
  <div class="panel-heading">category</div>  <div data-src='category' class='ajax_widgets'>正在加载...</div>
</div>

<div id="widget_recent_posts" class="widget panel panel-primary">
  <div class="panel-heading">recent posts</div>  <div data-src='recent_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_tagcloud" class="widget panel panel-primary">
  <div class="panel-heading">tagcloud</div>  <div data-src='tagcloud' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_latest_update_posts" class="widget panel panel-primary">
  <div class="panel-heading">最近更新</div>  <div data-src='latest_update_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_recent_comments" class="widget panel panel-primary">
  <div class="panel-heading">recent comments</div>  

<div class="list-group-item ds-recent-comments" data-num-items="6" data-show-avatars="1" data-show-time="1" data-show-title="1" data-show-admin="1" data-excerpt-length="50"></div>



</div>

</aside>
       <div class="clearfix"></div>
     </div><!-- row END -->
  </div>
  <footer id="footer" class="container">
  <div class="panel panel-info">
  <section id='footer_widget'></section>  <div class="panel-footer">
  <div id="site-info">
    <span class='author'>
  
  &copy; 2014 RobinChia
  
    &nbsp;&nbsp;</span>
  
  <span id='analytics-51la'></span><span id='analytics-google'>
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-48559895-1']);
  _gaq.push(['_trackPageview']);
  _js2load.push({src:('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'});
</script></span><span id='analytics-cnzz'>
<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_5774006'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s17.cnzz.com/stat.php%3Fid%3D5774006%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>
</span><span id='analytics-baidu'>
<script>
var _hmt = _hmt || [];
_js2load.push({src:"//hm.baidu.com/hm.js?eaa92c12166944fd3a160103e6c4a8cf"});
</script>


</span>  </div>
  <div id="copyright">Site powered by <a href='http://zespia.tw/hexo/'><strong>hexo</strong></a>  update time: <em>2014-04-14 12:45:08</em></span></div>
</div>
<div class="clearfix"></div>


  </div>
  </footer>
  
        <script src="http://cdn.bootcss.com/jquery/1.10.2/jquery.min.js"></script>        
        <script src="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/js/bootstrap.min.js"></script>        
                
        <script src="http://cdn.bootcss.com/prettify/r298/prettify.min.js"></script>    <script type="text/javascript">
   var lang=["bsh", "c", "cc", "cpp", "cs", "csh", "cyc", "cv", "htm", "html",
    "java", "js", "m", "mxml", "perl", "pl", "pm", "py", "rb", "sh",
    "xhtml", "xml", "xsl"];
   var pretty_base='';
   $('script').each(function(){
	var c = $(this).attr('src');
	if (!c)
	    return;
	if (c.match(/(\/)?prettify(\.min)?\.js/i))
	{
	    var index = c.lastIndexOf('/');
	    if (index != -1)
		pretty_base = c.substr(0,index + 1);
	    return false;
	}
   })
   $('pre code').each(function(){
	var c = $(this).attr('class')
	if (!c)
	    return;
	c = c.match(/\s?(lang\-\w+)/i);
	if (c && lang.indexOf(c[1]) == -1)
	{
	    lang.push(c[1]);
	    $.getScript(pretty_base + c[1] + '.min.js');
	}
   })

    $(window).load(function(){
       $("pre").addClass("prettyprint");
       prettyPrint();
    })
</script>    
            <script type="text/javascript">
var duoshuoQuery = {short_name:"robinchia"};
_js2load.push({src:'http://static.duoshuo.com/embed.js',charset:'UTF-8'});
</script>
    
            <!--wumii_relatedItems-->
    
        <script src="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js"></script>    <script type="text/javascript">
(function($){
  $('.entry').each(function(i){
    $(this).find('img').each(function(){
      var alt = this.alt;

      if (alt){
        $(this).before('<span class="caption">' + alt + '</span>');
      }

      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox" rel="fancybox' + i + '" />');
    });
  });

  $('.fancybox').fancybox();
})(jQuery);
</script>    
        <script src="http://cdn.bootcss.com/mathjax/2.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>    <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>
    
<script type="text/javascript">
$('.ajax_widgets').each(function(){var src=$(this).attr('data-src');if(src)$(this).load('/widgets/'+src+'.html');});
$.each(_js2load,function(index,obj){loadjs(obj.src,obj.charset)});
</script>

<div id="scroll2top">
<img src="/scroll2top/arrow.png"/>
</div>
<script src="/scroll2top/scroll2top.min.js"></script>
<div id="winterland">
  <canvas></canvas>
</div>
<script src="/js/winterland.min.js"></script>

  </body>
</html>
