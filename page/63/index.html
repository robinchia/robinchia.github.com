
<!DOCTYPE HTML>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>The 63 Page | It so life</title>
<meta name="author" content="RobinChia">

<meta name="description" content="It so life">


<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<meta property="og:site_name" content="It so life"/>

<!--[if IE]><style>.testIE.IE{display:inline;}</style><![endif]-->
<!--[if lte IE 7]><link rel="stylesheet" href="/css/ie7.css" type="text/css"><![endif]-->
<!--[if (lt IE 9)&(gt IE 7)]><style>.testIE.IE8{display:inline;}</style><![endif]-->
<!--[if gt IE 8]><style>.testIE.IE9{display:inline;}</style><![endif]-->

<link href="/favicon.png" rel="icon">
<link rel="alternate" href="/atom.xml" title="It so life Feed" type="application/atom+xml">

<link rel="stylesheet" href="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/css/bootstrap.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/font-awesome/4.0.3/css/font-awesome.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/prettify/r298/prettify.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" type="text/css">
<link rel="stylesheet" href="/css/style.css" type="text/css">
<!--[if lt IE 9]>
   <style>article,aside,dialog,footer,header,section,footer,nav,figure,menu{display:block}</style>
   <script src="http://cdn.staticfile.org/html5shiv/r29/html5.min.js"></script>
   <script src="http://cdn.staticfile.org/respond.js/1.4.2/respond.min.js"></script>
<link href="http://cdn.staticfile.org/respond.js/1.4.2/respond-proxy.html" id="respond-proxy" rel="respond-proxy" />
<link href="/js/respond.proxy.gif" id="respond-redirect" rel="respond-redirect" />
<script src="/js/respond.proxy.js"></script>
   <script src="http://cdn.bootcss.com/selectivizr/1.0.2/selectivizr-min.js"></script>
<![endif]-->
<script type="text/javascript">
function loadjs(c,d){var a=document.createElement("script");a.async=!0;a.type="text/javascript";a.src=c;a.charset=d||"gbk";(document.getElementsByTagName("HEAD")[0]||document.getElementsByTagName("BODY")[0]).appendChild(a)};
var _protocol = (("https:" == document.location.protocol) ? " https://" : " http://");
var _js2load = [];
</script>

</head>
<body>
      <header id="header" class="container"><nav id="main-nav" class="navbar navbar-default navbar-fixed-top " role="navigation">
  <div class="container">
    <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
      <span class="sr-only">Toggle navigation</span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="/">It so life</a>
    </div>
    <div  class="collapse navbar-collapse">
      <ul  class="nav navbar-nav">
  
        <li><a href="/" title="Home">Home</a></li>      
        <li><a href="/about/" title="About">About</a></li>      
        <li><a href="/archives/" title="Archives">Archives</a></li>      
      <li class='dropdown'>
        <a class='dropdown-toggle' data-toggle='dropdown' href='#'>website<b class='caret'></b></a>
        <ul class='dropdown-menu pure-menu-selected'>
    
          <li><a href="//groups.google.com/forum/#!forum/pongba" title="TopLanguage">TopLanguage</a></li>    
          <li><a href="//itpub.net/" title="ITPub">ITPub</a></li>    
          <li><a href="//blog.jobbole.com/" title="Bole">Bole</a></li>    
          <li><a href="//nosql-database.org/" title="nosql">nosql</a></li>    
          <li><a href="//gitimmersion.googol.im/" title="Git">Git</a></li>    
        </ul>
      </li>
    
      </ul>
      <ul class="nav navbar-nav navbar-right">
      
        <li><a href="/atom.xml">RSS</a></li>
      
      
        <li><a href="https://twitter.com/robinchia">twitter</a></li>
      
      
      
      
        <li><a href="https://github.com/robinchia">github</a></li>
      
      </ul>
    </div>
  </div>
</nav>
<div class="clearfix"></div>
</header>
  <div id='content' class="container">
     <div class="page-header-wrapper">
      <!--[if lt IE 9]><div class="alert alert-warning alert-dismissable"><button type="button" class="close" data-dismiss="alert" aria-hidden="true">&times;</button><strong>提示:</strong>您的浏览器版本太低了,建议升级到 <strong><a href="http://windows.microsoft.com/zh-cn/internet-explorer/download-ie" title="IE9">IE9</a></strong> 以上,本站使用<a href="https://www.google.com/intl/zh-CN/chrome/">Chrome浏览器</a>可以获得最好的显示效果.</div><![endif]-->
      <div class="page-header"><h1 align="center"><big>It so life</big> </h1>
        <h5 align="center"><big>love as life</big></h5>
      </div>
     </div>
     <div class="row">
       <div id="main-col" class="alignleft col-sx-12 col-sm-8 col-md-9 col-lg-9">
      <section id='header_widget'></section>
          <div id="wrapper"><article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-proguard--开源混淆工具ProGuard配置详解及配置实例/">开源混淆工具ProGuard配置详解及配置实例</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:41.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-proguard--开源混淆工具ProGuard配置详解及配置实例/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-proguard-">开源混淆工具ProGuard配置详解及配置实例</h1>
<p>开源混淆工具ProGuard配置详解及配置实例</p>
<p>ProGuard是一个免费的java类文件压缩,优化,混淆器.它探测并删除没有使用的类,字段,方法和属性.它删除没有用的说明并使用字节码得到最大优化.它使用无意义的名字来重命名类,字段和方法.</p>
<p>ProGuard的作用: </p>
<p>1.创建紧凑的代码文档是为了更快的网络传输,快速装载和更小的内存占用. 
2.创建的程序和程序库很难使用反向工程. 
3.所以它能删除来自源文件中的没有调用的代码 
4.充分利用java6的快速加载的优点来提前检测和返回java6中存在的类文件. </p>
<p><strong>参数： </strong></p>
<p>-include {filename}    从给定的文件中读取配置参数 
-basedirectory {directoryname}    指定基础目录为以后相对的档案名称 
-injars {class_path}    指定要处理的应用程序jar,war,ear和目录 
-outjars {class_path}    指定处理完后要输出的jar,war,ear和目录的名称 
-libraryjars {classpath}    指定要处理的应用程序jar,war,ear和目录所需要的程序库文件 
-dontskipnonpubliclibraryclasses    指定不去忽略非公共的库类。 
-dontskipnonpubliclibraryclassmembers    指定不去忽略包可见的库类的成员。 
<strong>保留选项 </strong>
-keep {Modifier} {class_specification}    保护指定的类文件和类的成员 
-keepclassmembers {modifier} {class_specification}    保护指定类的成员，如果此类受到保护他们会保护的更好 
-keepclasseswithmembers {class_specification}    保护指定的类和类的成员，但条件是所有指定的类和类成员是要存在。 
-keepnames {class_specification}    保护指定的类和类的成员的名称（如果他们不会压缩步骤中删除） 
-keepclassmembernames {class_specification}    保护指定的类的成员的名称（如果他们不会压缩步骤中删除） 
-keepclasseswithmembernames {class_specification}    保护指定的类和类的成员的名称，如果所有指定的类成员出席（在压缩步骤之后） 
-printseeds {filename}    列出类和类的成员-keep选项的清单，标准输出到给定的文件 </p>
<p><strong>压缩 </strong>
-dontshrink    不压缩输入的类文件 
-printusage {filename} 
-whyareyoukeeping {class_specification}     </p>
<p><strong>优化 </strong>
-dontoptimize    不优化输入的类文件 
-assumenosideeffects {class_specification}    优化时假设指定的方法，没有任何副作用 
-allowaccessmodification    优化时允许访问并修改有修饰符的类和类的成员 </p>
<p><strong>混淆 </strong>
-dontobfuscate    不混淆输入的类文件 
-printmapping {filename} 
-applymapping {filename}    重用映射增加混淆 
-obfuscationdictionary {filename}    使用给定文件中的关键字作为要混淆方法的名称 
-overloadaggressively    混淆时应用侵入式重载 
-useuniqueclassmembernames    确定统一的混淆类的成员名称来增加混淆 
-flattenpackagehierarchy {package_name}    重新包装所有重命名的包并放在给定的单一包中 
-repackageclass {package_name}    重新包装所有重命名的类文件中放在给定的单一包中 
-dontusemixedcaseclassnames    混淆时不会产生形形色色的类名 
-keepattributes {attribute_name,...}    保护给定的可选属性，例如LineNumberTable, LocalVariableTable, SourceFile, Deprecated, Synthetic, Signature, and InnerClasses. 
-renamesourcefileattribute {string}    设置源文件中给定的字符串常量
<strong>Ant Example:</strong>
<!-- This Ant build file illustrates how to process applications,
     by including ProGuard-style configuration options.
     Usage: ant -f applications2.xml --></p>
<p><project name="Applications" default="obfuscate" basedir="../.."></p>
<p><target name="obfuscate">
  <taskdef resource="proguard/ant/task.properties"
           classpath="lib/proguard.jar" />
  <proguard>
    <!-- Specify the input jars, output jars, and library jars. -->
    -injars  in.jar
    -outjars out.jar
    -libraryjars ${java.home}/lib/rt.jar
    <!-- -libraryjars junit.jar    -->
    <!-- -libraryjars servlet.jar  -->
    <!-- -libraryjars jai_core.jar -->
    <!-- ...                       -->
    <!-- Save the obfuscation mapping to a file, and preserve line numbers. -->
    -printmapping out.map
    -renamesourcefileattribute SourceFile
    -keepattributes SourceFile,LineNumberTable
    <!-- Preserve all annotations. -->
    -keepattributes /<em>Annotation/</em>
    <!-- Preserve all public applications. -->
    -keepclasseswithmembers public class /<em> {
        public static void main(java.lang.String[]);
    }
    <!-- Preserve all native method names and the names of their classes. -->
    -keepclasseswithmembernames class /</em> {
        native &lt;methods&gt;;
    }
    <!-- Preserve the methods that are required in all enumeration classes. -->
    -keepclassmembers class /<em> extends java.lang.Enum {
        public static /</em>/<em>[] values();
        public static /</em>/<em> valueOf(java.lang.String);
    }
    <!-- Explicitly preserve all serialization members. The Serializable
         interface is only a marker interface, so it wouldn't save them.
         You can comment this out if your library doesn't use serialization.
         If your code contains serializable classes that have to be backward
         compatible, please refer to the manual. -->
    -keepclassmembers class /</em> implements java.io.Serializable {
        static final long serialVersionUID;
        static final java.io.ObjectStreamField[] serialPersistentFields;
        private void writeObject(java.io.ObjectOutputStream);
        private void readObject(java.io.ObjectInputStream);
        java.lang.Object writeReplace();
        java.lang.Object readResolve();
    }
    <!-- Your application may contain more items that need to be preserved;
         typically classes that are dynamically created using Class.forName -->
  </proguard>
</target>
</project>
来源： <a href="[http://www.kaiyuanba.cn/html/1/131/138/7820.htm](http://www.kaiyuanba.cn/html/1/131/138/7820.htm)">[http://www.kaiyuanba.cn/html/1/131/138/7820.htm](http://www.kaiyuanba.cn/html/1/131/138/7820.htm)</a> </p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/proguard/">proguard</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/proguard/" class="label label-success">proguard</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:41"datetime="2014-03-07 09:54:41"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-proguard--开源混淆工具ProGuard配置详解及配置实例/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-proguard--开源混淆工具ProGuard配置详解及配置实例" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-java深入分析--线性表分析及Java实现/">线性表分析及Java实现</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:41.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-java深入分析--线性表分析及Java实现/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-java-">线性表分析及Java实现</h1>
<p><strong><a href="http://java-mzd.iteye.com/blog/826059" target="_blank">线性表分析及Java实现</a></strong></p>
<p><strong>文章分类**</strong>:<a href="http://www.iteye.com/blogs/category/tech" target="_blank">综合技术</a>**</p>
<pre><code>  数据结构中的线性表，对应着Collection中的List接口。

  在本节中，我们将做以下三件事

        第一。我们先来看看线性表的特征

        第二，自己用JAVA实现List

        第三，对比的线性表、链式表性能，以及自己的List性能与JDKList性能对比



** ****线性表特征：**** **

        第一，一个特定的线性表，应该是用来存放特定的某一个类型的元素的（元素的“同一性”）

        第二， 除第一个元素外，其他每一个元素有且仅有一个直接前驱；除最后一个元素外，其他每一个元素有且仅有一个             直接后继（元素的“序偶性”）

        第二， 元素在线性表中的“下标”唯一地确定该元素在表中的相对位置（元素的“索引性”）

   又，一.线性表只是数据的一种逻辑结构，其具体存储结构可以为顺序存储结构和链式储存结构来完成，对应可以得到顺序表和链表，

        二.对线性表的入表和出表顺序做一定的限定，可以得到特殊的线性表，栈(FILO)和队列（FIFO）
</code></pre><p><strong>   **</strong>自己实现线性表之顺序表**</p>
<pre><code>         思路：

            1. 顺序表因为采用顺序存储形式，所以内部使用数组来存储数据

            2.因为存储的具体对象类型不一定，所以采用泛型操作

            3.数组操作优点：1.通过指针快速定位到下表，查询快速

                           缺点：1.数组声明时即需要确定数组大小。当操作中超过容量时，则需要重新声明数组，并且复制当前所有数据

                                    2.当需要在中间进行插入或者删除时，则需要移动大量元素（size-index个）
</code></pre><p>  具体实现代码如下</p>
<p><strong>Java**</strong>代码<strong><strong> </strong></strong> <strong>[</strong><img src="&quot;&quot;收藏这段代码&quot; &quot;" alt="收藏代码]()**"><em>**</em></p>
<ol>
<li><p>//<em>/</em> </p>
</li>
<li><p>/* 自己用数组实现的线性表 </p>
</li>
<li><p>/*/  </p>
</li>
<li><p><strong>public</strong> <strong>class</strong> ArrayList<E> {  </p>
</li>
<li><p>Object[] data = <strong>null</strong>;// 用来保存此队列中内容的数组  </p>
</li>
<li><p><strong>int</strong> current;// 保存当前为第几个元素的指标  </p>
</li>
<li><p><strong>int</strong> capacity;// 表示数组大小的指标  </p>
</li>
<li></li>
<li><p>//<em>/</em> </p>
</li>
<li><p>/* 如果初始化时，未声明大小，则默认为10 </p>
</li>
<li><p>/*/  </p>
</li>
<li><p><strong>public</strong> ArrayList() {  </p>
</li>
<li><p><strong>this</strong>(10);  </p>
</li>
<li><p>}  </p>
</li>
<li></li>
<li><p>//<em>/</em> </p>
</li>
<li><p>/* 初始化线性表，并且声明保存内容的数组大小 </p>
</li>
<li><p>/* @param initalSize </p>
</li>
<li><p>/*/  </p>
</li>
<li><p><strong>public</strong> ArrayList(<strong>int</strong> initalSize) {  </p>
</li>
<li><p><strong>if</strong> (initalSize &lt; 0) {  </p>
</li>
<li><p><strong>throw</strong> <strong>new</strong> RuntimeException(&quot;数组大小错误:&quot; + initalSize);  </p>
</li>
<li><p>} <strong>else</strong> {  </p>
</li>
<li><p><strong>this</strong>.data = <strong>new</strong> Object[initalSize];  </p>
</li>
<li><p><strong>this</strong>.current = 0;  </p>
</li>
<li><p>capacity = initalSize;  </p>
</li>
<li><p>}  </p>
</li>
<li><p>}  </p>
</li>
<li></li>
<li><p>//<em>/</em> </p>
</li>
<li><p>/* 添加元素的方法 添加前，先确认是否已经满了 </p>
</li>
<li><p>/* @param e </p>
</li>
<li><p>/* @return </p>
</li>
<li><p>/*/  </p>
</li>
<li><p><strong>public</strong> <strong>boolean</strong> add(E e) {  </p>
</li>
<li><p>ensureCapacity(current);// 确认容量  </p>
</li>
<li><p><strong>this</strong>.data[current] = e;  </p>
</li>
<li><p>current++;  </p>
</li>
<li><p><strong>return</strong> <strong>true</strong>;  </p>
</li>
<li><p>}  </p>
</li>
<li></li>
<li><p>//<em>/</em> </p>
</li>
<li><p>/* 确认系统当前容量是否满足需要,如果满足，则不执行操作 如果不满足，增加容量 </p>
</li>
<li><p>/* @param cur 当前个数 </p>
</li>
<li><p>/*/  </p>
</li>
<li><p><strong>private</strong> <strong>void</strong> ensureCapacity(<strong>int</strong> cur) {  </p>
</li>
<li><p><strong>if</strong> (cur == capacity) {  </p>
</li>
<li><p>// 如果达到容量极限，增加10的容量，复制当前数组  </p>
</li>
<li><p><strong>this</strong>.capacity = <strong>this</strong>.capacity + 10;  </p>
</li>
<li><p>Object[] newdata = <strong>new</strong> Object[capacity];  </p>
</li>
<li><p><strong>for</strong> (<strong>int</strong> i = 0; i &lt; cur; i++) {  </p>
</li>
<li><p>newdata[i] = <strong>this</strong>.data[i];  </p>
</li>
<li><p>}  </p>
</li>
<li><p><strong>this</strong>.data = newdata;  </p>
</li>
<li><p>}  </p>
</li>
<li><p>}  </p>
</li>
<li></li>
<li><p>//<em>/</em> </p>
</li>
<li><p>/* 得到指定下标的数据 </p>
</li>
<li><p>/* @param index </p>
</li>
<li><p>/* @return </p>
</li>
<li><p>/*/  </p>
</li>
<li><p><strong>public</strong> E get(<strong>int</strong> index) {  </p>
</li>
<li><p>validateIndex(index);  </p>
</li>
<li><p><strong>return</strong> (E) <strong>this</strong>.data[index];  </p>
</li>
<li><p>}  </p>
</li>
<li></li>
<li><p>//<em>/</em> </p>
</li>
<li><p>/* 返回当前队列大小 </p>
</li>
<li><p>/* @return </p>
</li>
<li><p>/*/  </p>
</li>
<li><p><strong>public</strong> <strong>int</strong> size() {  </p>
</li>
<li><p><strong>return</strong> <strong>this</strong>.current;  </p>
</li>
<li><p>}  </p>
</li>
<li></li>
<li><p>//<em>/</em> </p>
</li>
<li><p>/* 更改指定下标元素的数据为e </p>
</li>
<li><p>/* @param index  </p>
</li>
<li><p>/* @param e </p>
</li>
<li><p>/* @return </p>
</li>
<li><p>/*/  </p>
</li>
<li><p><strong>public</strong> <strong>boolean</strong> set(<strong>int</strong> index, E e) {  </p>
</li>
<li><p>validateIndex(index);  </p>
</li>
<li><p><strong>this</strong>.data[index] = e;  </p>
</li>
<li><p><strong>return</strong> <strong>true</strong>;  </p>
</li>
<li><p>}  </p>
</li>
<li></li>
<li><p>//<em>/</em> </p>
</li>
<li><p>/*  验证当前下标是否合法，如果不合法，抛出运行时异常 </p>
</li>
<li><p>/* @param index 下标 </p>
</li>
<li><p>/*/  </p>
</li>
<li><p><strong>private</strong> <strong>void</strong> validateIndex(<strong>int</strong> index) {  </p>
</li>
<li><p><strong>if</strong> (index &lt; 0 || index &gt; current) {  </p>
</li>
<li><p><strong>throw</strong> <strong>new</strong> RuntimeException(&quot;数组index错误：&quot; + index);  </p>
</li>
<li><p>}  </p>
</li>
<li><p>}  </p>
</li>
<li></li>
<li><p>//<em>/</em> </p>
</li>
<li><p>/* 在指定下标位置处插入数据e </p>
</li>
<li><p>/* @param index 下标 </p>
</li>
<li><p>/* @param e 需要插入的数据 </p>
</li>
<li><p>/* @return  </p>
</li>
<li><p>/*/  </p>
</li>
<li><p><strong>public</strong> <strong>boolean</strong> insert(<strong>int</strong> index, E e) {  </p>
</li>
<li><p>validateIndex(index);  </p>
</li>
<li><p>Object[] tem = <strong>new</strong> Object[capacity];// 用一个临时数组作为备份  </p>
</li>
<li><p>//开始备份数组  </p>
</li>
<li><p><strong>for</strong> (<strong>int</strong> i = 0; i &lt; current; i++) {  </p>
</li>
<li><p><strong>if</strong> (i &lt; index) {  </p>
</li>
<li><p>tem[i] = <strong>this</strong>.data[i];  </p>
</li>
<li><p>}<strong>else</strong> <strong>if</strong>(i==index){  </p>
</li>
<li><p>tem[i]=e;  </p>
</li>
<li><p>}<strong>else</strong> <strong>if</strong>(i&gt;index){  </p>
</li>
<li><p>tem[i]=<strong>this</strong>.data[i-1];  </p>
</li>
<li><p>}  </p>
</li>
<li><p>}  </p>
</li>
<li><p><strong>this</strong>.data=tem;  </p>
</li>
<li><p><strong>return</strong> <strong>true</strong>;  </p>
</li>
<li><p>}  </p>
</li>
<li><p><br><br>//<em>/</em><br>  /<em> 删除指定下标出的数据<br>    /</em> @param index<br>  /<em> @return<br>   /</em>/<br> <strong>public</strong> <strong>boolean</strong> delete(<strong>int</strong> index){<br>       validateIndex(index);<br>       Object[] tem = <strong>new</strong> Object[capacity];// 用一个临时数组作为备份<br>      //开始备份数组<br>        for (int i = 0; i &lt; current; i++) {<br>          if (i &lt; index) {<br>             tem[i] = this.data[i];<br>          }else if(i==index){<br>             tem[i]=this.data[i+1];<br>          }else if(i&gt;index){<br>               tem[i]=this.data[i+1];<br>          }<br>       }<br>       this.data=tem;<br>      return true;<br>    }<br><br>}  </p>
</li>
</ol>
<p>  <strong> **</strong>自己实现线性表之链表**</p>
<pre><code>     思路：1.链表采用链式存储结构，在内部只需要将一个一个结点链接起来。（每个结点中有关于此结点下一个结点的引用）

     链表操作优点：1.，因为每个结点记录下个结点的引用，则在进行插入和删除操作时，只需要改变对应下标下结点的引用即可

                 缺点：1.要得到某个下标的数据，不能通过下标直接得到，需要遍历整个链表。
</code></pre><p>  实现代码如下</p>
<p><strong>Java**</strong>代码<strong><strong> </strong></strong> <strong>[</strong><img src="&quot;&quot;收藏这段代码&quot; &quot;" alt="收藏代码]()**"><em>**</em></p>
<ol>
<li><p>//<em>/</em> </p>
</li>
<li><p>/* 自己用链式存储实现的线性表 </p>
</li>
<li><p>/*/  </p>
</li>
<li><p><strong>public</strong> <strong>class</strong> LinkedList<E> {  </p>
</li>
<li></li>
<li><p><strong>private</strong> Node<E> header = <strong>null</strong>;// 头结点  </p>
</li>
<li><p><strong>int</strong> size = 0;// 表示数组大小的指标  </p>
</li>
<li></li>
<li><p><strong>public</strong> LinkedList() {  </p>
</li>
<li><p><strong>this</strong>.header = <strong>new</strong> Node<E>();  </p>
</li>
<li><p>}  </p>
</li>
<li></li>
<li><p><strong>public</strong> <strong>boolean</strong> add(E e) {  </p>
</li>
<li><p><strong>if</strong> (size == 0) {  </p>
</li>
<li><p>header.e = e;  </p>
</li>
<li><p>} <strong>else</strong> {  </p>
</li>
<li><p>// 根据需要添加的内容，封装为结点  </p>
</li>
<li><p>Node<E> newNode = <strong>new</strong> Node<E>(e);  </p>
</li>
<li><p>// 得到当前最后一个结点  </p>
</li>
<li><p>Node<E> last = getNode(size-1);  </p>
</li>
<li><p>// 在最后一个结点后加上新结点  </p>
</li>
<li><p>last.addNext(newNode);  </p>
</li>
<li><p>}  </p>
</li>
<li><p>size++;// 当前大小自增加1  </p>
</li>
<li><p><strong>return</strong> <strong>true</strong>;  </p>
</li>
<li><p>}  </p>
</li>
<li></li>
<li><p><strong>public</strong> <strong>boolean</strong> insert(<strong>int</strong> index, E e) {  </p>
</li>
<li><p>Node<E> newNode = <strong>new</strong> Node<E>(e);  </p>
</li>
<li><p>// 得到第N个结点  </p>
</li>
<li><p>Node<E> cNode = getNode(index);  </p>
</li>
<li><p>newNode.next = cNode.next;  </p>
</li>
<li><p>cNode.next = newNode;  </p>
</li>
<li><p>size++;  </p>
</li>
<li><p><strong>return</strong> <strong>true</strong>;  </p>
</li>
<li></li>
<li><p>}  </p>
</li>
<li></li>
<li><p>//<em>/</em> </p>
</li>
<li><p>/* 遍历当前链表，取得当前索引对应的元素 </p>
</li>
<li><p>/*  </p>
</li>
<li><p>/* @return </p>
</li>
<li><p>/*/  </p>
</li>
<li><p><strong>private</strong> Node<E> getNode(<strong>int</strong> index) {  </p>
</li>
<li><p>// 先判断索引正确性  </p>
</li>
<li><p><strong>if</strong> (index &gt; size || index &lt; 0) {  </p>
</li>
<li><p><strong>throw</strong> <strong>new</strong> RuntimeException(&quot;索引值有错：&quot; + index);  </p>
</li>
<li><p>}  </p>
</li>
<li><p>Node<E> tem = <strong>new</strong> Node<E>();  </p>
</li>
<li><p>tem = header;  </p>
</li>
<li><p><strong>int</strong> count = 0;  </p>
</li>
<li><p><strong>while</strong> (count != index) {  </p>
</li>
<li><p>tem = tem.next;  </p>
</li>
<li><p>count++;  </p>
</li>
<li><p>}  </p>
</li>
<li><p><strong>return</strong> tem;  </p>
</li>
<li><p>}  </p>
</li>
<li></li>
<li><p>//<em>/</em> </p>
</li>
<li><p>/* 根据索引，取得该索引下的数据 </p>
</li>
<li><p>/*  </p>
</li>
<li><p>/* @param index </p>
</li>
<li><p>/* @return </p>
</li>
<li><p>/*/  </p>
</li>
<li><p><strong>public</strong> E get(<strong>int</strong> index) {  </p>
</li>
<li><p>// 先判断索引正确性  </p>
</li>
<li><p><strong>if</strong> (index &gt;= size || index &lt; 0) {  </p>
</li>
<li><p><strong>throw</strong> <strong>new</strong> RuntimeException(&quot;索引值有错：&quot; + index);  </p>
</li>
<li><p>}  </p>
</li>
<li><p>Node<E> tem = <strong>new</strong> Node<E>();  </p>
</li>
<li><p>tem = header;  </p>
</li>
<li><p><strong>int</strong> count = 0;  </p>
</li>
<li><p><strong>while</strong> (count != index) {  </p>
</li>
<li><p>tem = tem.next;  </p>
</li>
<li><p>count++;  </p>
</li>
<li><p>}  </p>
</li>
<li><p>E e = tem.e;  </p>
</li>
<li><p><strong>return</strong> e;  </p>
</li>
<li><p>}  </p>
</li>
<li></li>
<li><p><strong>public</strong> <strong>int</strong> size() {  </p>
</li>
<li><p><strong>return</strong> size;  </p>
</li>
<li><p>}  </p>
</li>
<li></li>
<li><p>//<em>/</em> </p>
</li>
<li><p>/* 设置第N个结点的值 </p>
</li>
<li><p>/*  </p>
</li>
<li><p>/* @param x </p>
</li>
<li><p>/* @param e </p>
</li>
<li><p>/* @return </p>
</li>
<li><p>/*/  </p>
</li>
<li><p><strong>public</strong> <strong>boolean</strong> set(<strong>int</strong> index, E e) {  </p>
</li>
<li><p>// 先判断索引正确性  </p>
</li>
<li><p><strong>if</strong> (index &gt; size || index &lt; 0) {  </p>
</li>
<li><p><strong>throw</strong> <strong>new</strong> RuntimeException(&quot;索引值有错：&quot; + index);  </p>
</li>
<li><p>}  </p>
</li>
<li><p>Node<E> newNode = <strong>new</strong> Node<E>(e);  </p>
</li>
<li><p>// 得到第x个结点  </p>
</li>
<li><p>Node<E> cNode = getNode(index);  </p>
</li>
<li><p>cNode.e = e;  </p>
</li>
<li><p><strong>return</strong> <strong>true</strong>;  </p>
</li>
<li><p>}  </p>
</li>
<li></li>
<li><p>//<em>/</em> </p>
</li>
<li><p>/* 用来存放数据的结点型内部类 </p>
</li>
<li><p>/*/  </p>
</li>
<li><p><strong>class</strong> Node<e> {  </p>
</li>
<li><p><strong>private</strong> E e;// 结点中存放的数据  </p>
</li>
<li></li>
<li><p>Node() {  </p>
</li>
<li><p>}  </p>
</li>
<li></li>
<li><p>Node(E e) {  </p>
</li>
<li><p><strong>this</strong>.e = e;  </p>
</li>
<li><p>}  </p>
</li>
<li></li>
<li><p>Node<E> next;// 用来指向该结点的下一个结点  </p>
</li>
<li></li>
<li><p>// 在此结点后加一个结点  </p>
</li>
<li><p><strong>void</strong> addNext(Node<E> node) {  </p>
</li>
<li><p>next = node;  </p>
</li>
<li><p>}  </p>
</li>
<li><p>}  </p>
</li>
<li></li>
<li><p>}  </p>
</li>
</ol>
<p><strong>自己实现线性表之栈</strong></p>
<pre><code>     栈是限定仅允许在表的同一端（通常为“表尾”）进行插入或删除操作的线性表。

     允许插入和删除的一端称为栈顶(top)，另一端称为栈底(base)
     特点：后进先出 (LIFO)或，先进后出（FILO）



     因为栈是限定线的线性表，所以，我们可以调用前面两种线性表，只需要对出栈和入栈操作进行设定即可

具体实现代码
</code></pre><p><strong>Java**</strong>代码<strong><strong> </strong></strong> <strong>[</strong><img src="&quot;&quot;收藏这段代码&quot; &quot;" alt="收藏代码]()**"><em>**</em></p>
<ol>
<li><p>//<em>/</em> </p>
</li>
<li><p>/* 自己用数组实现的栈 </p>
</li>
<li><p>/*/  </p>
</li>
<li><p><strong>public</strong> <strong>class</strong> ArrayStack<E> {  </p>
</li>
<li><p><strong>private</strong> ArrayList<E> list=<strong>new</strong> ArrayList<E>();//用来保存数据线性表<br>    private  int size;//表示当前栈元素个数  </p>
</li>
<li><p>//<em>/</em> </p>
</li>
<li><p>/* 入栈操作 </p>
</li>
<li><p>/* @param e </p>
</li>
<li><p>/*/  </p>
</li>
<li><p><strong>public</strong> <strong>void</strong> push(E e){  </p>
</li>
<li><p>list.add(e);  </p>
</li>
<li><p>size++;  </p>
</li>
<li><p>}  </p>
</li>
<li></li>
<li><p>//<em>/</em> </p>
</li>
<li><p>/* 出栈操作 </p>
</li>
<li><p>/* @return </p>
</li>
<li><p>/*/  </p>
</li>
<li><p><strong>public</strong> E pop(){  </p>
</li>
<li><p>E e= list.get(size-1);  </p>
</li>
<li><p>size--;  </p>
</li>
<li><p><strong>return</strong> e;  </p>
</li>
<li><p>}  </p>
</li>
<li></li>
<li><p>}  </p>
</li>
</ol>
<p> 至于用链表实现栈，则只需要把保存数据的顺序表改成链表即可，此处就不给出代码了</p>
<p><strong>自己实现线性表之队列</strong></p>
<pre><code>    与栈类似

    队列是只允许在表的一端进行插入，而在另一端删除元素的线性表。

    在队列中，允许插入的一端叫队尾（rear），允许删除的一端称为队头(front)。
    特点：先进先出 (FIFO)、后进后出 (LILO)



   同理，我们也可以调用前面两种线性表，只需要对队列的入队和出队方式进行处理即可
</code></pre><p><strong>Java**</strong>代码<strong><strong> </strong></strong> <strong>[</strong><img src="&quot;&quot;收藏这段代码&quot; &quot;" alt="收藏代码]()**"><em>**</em></p>
<ol>
<li><p><strong>package</strong> cn.javamzd.collection.List;  </p>
</li>
<li></li>
<li><p>//<em>/</em> </p>
</li>
<li><p>/* 用数组实现的队列 </p>
</li>
<li><p>/*/  </p>
</li>
<li><p><strong>public</strong> <strong>class</strong> ArrayQueue<E> {  </p>
</li>
<li><p><strong>private</strong> ArrayList<E> list = <strong>new</strong> ArrayList<E>();// 用来保存数据的队列  </p>
</li>
<li><p><strong>private</strong> <strong>int</strong> size;// 表示当前栈元素个数  </p>
</li>
<li></li>
<li><p>//<em>/</em> </p>
</li>
<li><p>/* 入队 </p>
</li>
<li><p>/* @param e </p>
</li>
<li><p>/*/  </p>
</li>
<li><p><strong>public</strong> <strong>void</strong> EnQueue(E e) {  </p>
</li>
<li><p>list.add(e);  </p>
</li>
<li><p>size++;  </p>
</li>
<li><p>}  </p>
</li>
<li></li>
<li><p>//<em>/</em> </p>
</li>
<li><p>/* 出队 </p>
</li>
<li><p>/* @return </p>
</li>
<li><p>/*/  </p>
</li>
<li><p><strong>public</strong> E DeQueue() {  </p>
</li>
<li><p><strong>if</strong> (size &gt; 0) {  </p>
</li>
<li><p>E e = list.get(0);  </p>
</li>
<li><p>list.delete(0);  </p>
</li>
<li><p><strong>return</strong> e;  </p>
</li>
<li><p>}<strong>else</strong>{  </p>
</li>
<li><p><strong>throw</strong> <strong>new</strong> RuntimeException(&quot;已经到达队列顶部&quot;);  </p>
</li>
<li><p>}  </p>
</li>
<li><p>}  </p>
</li>
<li><p>}  </p>
</li>
</ol>
<p><strong>对比线性表和链式表</strong>
         前面已经说过顺序表和链式表各自的特点，这里在重申一遍</p>
<pre><code>     数组操作优点：1.通过指针快速定位到下标，查询快速

                 缺点：1.数组声明时即需要确定数组大小。当操作中超过容量时，则需要重新声明数组，并且复制当前所有数据

                          2.当需要在中间进行插入或者删除时，则需要移动大量元素（size-index个）    





     链表操作优点：1.，因为每个结点记录下个结点的引用，则在进行插入和删除操作时，只需要改变对应下标下结点的引用即可

                 缺点：1.要得到某个下标的数据，不能通过下标直接得到，需要遍历整个链表。



     现在，我们通过进行增删改查操作来感受一次其效率的差异

     **思路**：通过两个表，各进行大数据量操作（2W）条数据的操作，记录操作前系统时间，操作后系统时间，得出操作时间
</code></pre><p>  实现代码如下</p>
<p><strong>Java**</strong>代码<strong><strong> </strong></strong> <strong>[</strong><img src="&quot;&quot;收藏这段代码&quot; &quot;" alt="收藏代码]()**"><em>**</em></p>
<ol>
<li><p><strong>package</strong> cn.javamzd.collection.List;  </p>
</li>
<li></li>
<li><p><strong>public</strong> <strong>class</strong> Test {  </p>
</li>
<li></li>
<li><p>//<em>/</em> </p>
</li>
<li><p>/* @param args </p>
</li>
<li><p>/*/  </p>
</li>
<li><p><strong>public</strong> <strong>static</strong> <strong>void</strong> main(String[] args) {  </p>
</li>
<li><p>//测试自己实现的ArrayList类和Linkedlist类添加20000个数据所需要的时间  </p>
</li>
<li><p>ArrayList<String> al = <strong>new</strong> ArrayList<String>();  </p>
</li>
<li><p>LinkedList<String> ll = <strong>new</strong> LinkedList<String>();  </p>
</li>
<li><p>Long aBeginTime=System.currentTimeMillis();//记录BeginTime  </p>
</li>
<li><p><strong>for</strong>(<strong>int</strong> i=0;i&lt;30000;i++){  </p>
</li>
<li><p>al.add(&quot;now&quot;+i);  </p>
</li>
<li><p>}  </p>
</li>
<li><p>Long aEndTime=System.currentTimeMillis();//记录EndTime  </p>
</li>
<li><p>System.out.println(&quot;arrylist  add time---&gt;&quot;+(aEndTime-aBeginTime));  </p>
</li>
<li><p>Long lBeginTime=System.currentTimeMillis();//记录BeginTime  </p>
</li>
<li><p><strong>for</strong>(<strong>int</strong> i=0;i&lt;30000;i++){  </p>
</li>
<li><p>ll.add(&quot;now&quot;+i);  </p>
</li>
<li><p>}  </p>
</li>
<li><p>Long lEndTime=System.currentTimeMillis();//记录EndTime  </p>
</li>
<li><p>System.out.println(&quot;linkedList add time----&gt;&quot;+(lEndTime-lBeginTime));  </p>
</li>
<li></li>
<li><p>//测试JDK提供的ArrayList类和LinkedList类添加20000个数据所需要的世界  </p>
</li>
<li><p>java.util.ArrayList<String> sal=<strong>new</strong> java.util.ArrayList<String>();  </p>
</li>
<li><p>java.util.LinkedList<String> sll=<strong>new</strong> java.util.LinkedList<String>();  </p>
</li>
<li><p>Long saBeginTime=System.currentTimeMillis();//记录BeginTime  </p>
</li>
<li><p><strong>for</strong>(<strong>int</strong> i=0;i&lt;30000;i++){  </p>
</li>
<li><p>sal.add(&quot;now&quot;+i);  </p>
</li>
<li><p>}  </p>
</li>
<li><p>Long saEndTime=System.currentTimeMillis();//记录EndTime  </p>
</li>
<li><p>System.out.println(&quot;JDK arrylist  add time---&gt;&quot;+(saEndTime-saBeginTime));  </p>
</li>
<li><p>Long slBeginTime=System.currentTimeMillis();//记录BeginTime  </p>
</li>
<li><p><strong>for</strong>(<strong>int</strong> i=0;i&lt;30000;i++){  </p>
</li>
<li><p>sll.add(&quot;now&quot;+i);  </p>
</li>
<li><p>}  </p>
</li>
<li><p>Long slEndTime=System.currentTimeMillis();//记录EndTime  </p>
</li>
<li><p>System.out.println(&quot;JDK linkedList add time----&gt;&quot;+(slEndTime-slBeginTime));  </p>
</li>
<li><p>}  </p>
</li>
<li></li>
<li><p>}  </p>
<p>得到测试结果如下： </p>
</li>
</ol>
<p>arrylist add time---&gt;446
linkedList add time----&gt;9767
JDK arrylist add time---&gt;13
JDK linkedList add time----&gt;12</p>
<pre><code>    由以上数据，我们可知：
</code></pre><p><strong>           1.JDK**</strong>中的<strong><strong>ArrayList</strong></strong>何<strong><strong>LinkedList</strong></strong>在添加数据时的性能，其实几乎是没有差异的**</p>
<pre><code>       2.我们自己写的List的性能和JDK提供的List的性能还是存在巨大差异的

       3.我们使用链表添加操作，花费的时间是巨大的，比ArrayList都大几十倍



  第三条显然是跟我们最初的设计不相符的，按照我们最初的设想，链表的添加应该比顺序表更省时

  查看我们写的源码，可以发现：

  我们每次添加一个数据时，都需要遍历整个表，得到表尾，再在表尾添加，这是很不科学的



 ** ****现改进如下**：设立一个Node&lt;E&gt;类的成员变量end来指示表尾，这样每次添加时，就不需要再重新遍历得到表尾

  改进后add()方法如下
</code></pre><p><strong>Java**</strong>代码<strong><strong> </strong></strong> <strong>[</strong><img src="&quot;&quot;收藏这段代码&quot; &quot;" alt="收藏代码]()**"><em>**</em></p>
<ol>
<li><p><strong>public</strong> <strong>boolean</strong> add(E e) {  </p>
</li>
<li><p><strong>if</strong> (size == 0) {  </p>
</li>
<li><p>header.e = e;  </p>
</li>
<li><p>} <strong>else</strong> {  </p>
</li>
<li><p>// 根据需要添加的内容，封装为结点  </p>
</li>
<li><p>Node<E> newNode = <strong>new</strong> Node<E>(e);  </p>
</li>
<li><p>//在表尾添加元素  </p>
</li>
<li><p>last.addNext(newNode);  </p>
</li>
<li><p>//将表尾指向当前最后一个元素  </p>
</li>
<li><p>last = newNode;  </p>
</li>
<li><p>}  </p>
</li>
<li><p>size++;// 当前大小自增加1  </p>
</li>
<li><p><strong>return</strong> <strong>true</strong>;  </p>
</li>
<li><p>}  </p>
</li>
</ol>
<pre><code>   ArrayList添加的效率和JDK中对比起来也太低

   分析原因为：

   每次扩大容量时，扩大量太小，需要进行的复制操作太多

   现在改进如下：

   每次扩大，则扩大容量为当前的三倍，此改进仅需要更改ensureCapacity()方法中的一行代码，此处就不列出了。
</code></pre><p>改进后，再次运行添加元素测试代码，结果如下：</p>
<p>arrylist add time---&gt;16
linkedList add time----&gt;8
JDK arrylist add time---&gt;7
JDK linkedList add time----&gt;7</p>
<p> 虽然还有改进的空间，但是显然，我们的效果已经大幅度改进了，而且也比较接近JDK了</p>
<p>接下来测试插入操作的效率</p>
<p>  我们只需要将测试代码中的添加方法(add())改成插入方法(insert(int index,E e)),为了使插入次数尽可能多，我们把index都设置为0</p>
<p>测试结果如下：</p>
<p>arrylist inset time---&gt;17
linkedList inset time----&gt;13
JDK arrylist inset time---&gt;503
JDK linkedList inset time----&gt;11</p>
<p><strong>多次测试，发现我们写的**</strong>ArrayList<strong><strong>在插入方法的效率都已经超过</strong></strong>JDK<strong><strong>了，而且也接近</strong></strong>LinkedLst<strong>**了。撒花！！！</strong></p>
<p>接下来测试删除、得到下标等等操作就不一一列出来了（只需要改变每次调用的方法即可）</p>
<p>恩，本来想今晚把所有的集合框架实现都写一下的</p>
<p>但是不知不觉这都又2点了</p>
<p>明早还得去蓝杰上课</p>
<p>果断先睡吧</p>
<p>敬请大家期待我明日大作------------静态/动态查找表的实现，动态查找表查找/加入算法的JAVA实现，Hash表的实现</p>
<p>good night</p>
<p>url: <a href="http://java-mzd.iteye.com/blog/826059" target="_blank">http://java-mzd.iteye.com/blog/826059</a></p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/java深入分析/">java深入分析</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/java深入分析/" class="label label-success">java深入分析</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:41"datetime="2014-03-07 09:54:41"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-java深入分析--线性表分析及Java实现/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-java深入分析--线性表分析及Java实现" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-内存分析--Java内存泄露监控工具-JVM监控工具介绍jstack-jconsole-jinfo-/">Java 内存泄露监控工具</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:41.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-内存分析--Java内存泄露监控工具-JVM监控工具介绍jstack-jconsole-jinfo-/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="java-jvm-jstack-jconsole-jinfo-jmap-jdb-jstat">Java 内存泄露监控工具-- JVM监控工具介绍jstack, jconsole, jinfo, jmap, jdb, jstat</h1>
<hr>
<p><strong>jstack </strong>-- 如果java程序崩溃生成core文件，jstack工具可以用来获得core文件的java stack和native stack的信息，从而可以轻松地知道java程序是如何崩溃和在程序何处发生问题。另外，jstack工具还可以附属到正在运行的java程序中，看到 当时运行的java程序的java stack和native stack的信息, 如果现在运行的java程序呈现hung的状态，jstack是非常有用的。目前只有在Solaris和Linux的JDK版本里面才有。</p>
<p><strong>jconsole </strong>– jconsole是基于<a href="http://java.chinaitlab.com/" target="_blank">Java </a>Management Extensions (JMX)的实时图形化监测工具，这个工具利用了内建到JVM里面的JMX指令来提供实时的性能和资源的监控，包括了<a href="http://java.chinaitlab.com/" target="_blank">Java </a>程序的内存使用，Heap size, 线程的状态，类的分配状态和空间使用等等。</p>
<p><strong>jinfo </strong>– jinfo可以从core文件里面知道崩溃的Java应用程序的配置信息，目前只有在Solaris和Linux的JDK版本里面才有。</p>
<p><strong>jmap </strong>– jmap 可以从core文件或进程中获得内存的具体匹配情况，包括Heap size, Perm size等等，目前只有在Solaris和Linux的JDK版本里面才有。</p>
<p><strong>jdb </strong>– jdb 用来对core文件和正在运行的Java进程进行实时地调试，里面包含了丰富的命令帮助您进行调试，它的功能和Sun studio里面所带的dbx非常相似，但 jdb是专门用来针对Java应用程序的。</p>
<p><strong>jstat </strong>– jstat利用了JVM内建的指令对Java应用程序的资源和性能进行实时的命令行的监控，包括了对Heap size和垃圾回收状况的监控等等。</p>
<p><strong>jps </strong>– jps是用来查看JVM里面所有进程的具体状态, 包括进程ID，进程启动的路径等等。 </p>
<p><a href="http://java.sun.com/j2se/1.5.0/docs/tooldocs/share/jstatd.html" target="_blank"><strong>jstatd</strong> </a>
启动jvm监控服务。它是一个基于rmi的应用，向远程机器提供本机jvm应用程序的信息。默认端口1099。
实例：jstatd -J-Djava.security.policy=my.policy
my.policy文件需要自己建立，内如如下：
grant codebase &quot;file:$JAVA_HOME/lib/tools.jar&quot; {
permission java.security.AllPermission;
};
这是安全策略文件，因为jdk对jvm做了jaas的安全检测，所以我们必须设置一些策略，使得jstatd被允许作网络操作</p>
<p>上面的操作没有通过，出现：</p>
<p>Could not create remote object
access denied (java.util.PropertyPermission java.rmi.server.ignoreSubClasses write)
java.security.AccessControlException: access denied (java.util.PropertyPermission java.rmi.server.ignoreSubClasses write)
at java.security.AccessControlContext.checkPermission(AccessControlContext.java:323)
at java.security.AccessController.checkPermission(AccessController.java:546)
at java.lang.SecurityManager.checkPermission(SecurityManager.java:532)
at java.lang.System.setProperty(System.java:727)
at sun.tools.jstatd.Jstatd.main(Jstatd.java:122)</p>
<p>create in your usr/java/bin the jstatd.all.policy file, with the content must be</p>
<ol>
<li>grant codebase &quot;file:${java.home}/../lib/tools.jar&quot; {  </li>
<li>permission java.security.AllPermission;  </li>
<li>}; </li>
</ol>
<p><strong><a href="http://java.sun.com/j2se/1.5.0/docs/tooldocs/share/jps.html" target="_blank">jps </a></strong>
列出所有的jvm实例
实例：
jps
列出本机所有的jvm实例
jps 192.168.0.77
列出远程服务器192.168.0.77机器所有的jvm实例，采用rmi协议，默认连接端口为1099
（前提是远程服务器提供jstatd服务）
输出内容如下：
jones@jones:~/data/ebook/java/j2se/jdk_gc$ jps
6286 Jps
6174  Jstat
<strong>jconsole </strong>
一个图形化界面，可以观察到java进程的gc，class，内存等信息。虽然比较直观，但是个人还是比较倾向于使用jstat命令（在最后一部分会对jstat作详细的介绍）。
<strong><a href="http://java.sun.com/j2se/1.5.0/docs/tooldocs/share/jinfo.html" target="_blank">jinfo </a></strong>（linux下特有）
观察运行中的java程序的运行环境参数：参数包括Java System属性和JVM命令行参数
实例：jinfo 2083
其中2083就是java进程id号，可以用jps得到这个id号。
输出内容太多了，不在这里一一列举，大家可以自己尝试这个命令。
<strong><a href="http://java.sun.com/j2se/1.5.0/docs/tooldocs/share/jstack.html" target="_blank">jstack </a></strong>（linux下特有）
可以观察到jvm中当前所有线程的运行情况和线程当前状态
jstack 2083
输出内容如下：
<img src="" alt=""> 
<strong><a href="http://java.sun.com/j2se/1.5.0/docs/tooldocs/share/jmap.html" target="_blank">jmap </a></strong>（linux下特有，也是很常用的一个命令）
观察运行中的jvm物理内存的占用情况。
参数如下：<strong>-heap</strong> ：打印jvm heap的情况
<strong>-histo：</strong> 打印jvm heap的直方图。其输出信息包括类名，对象数量，对象占用大小。
<strong>-histo：live ：</strong> 同上，但是只答应存活对象的情况
<strong>-permstat：</strong> 打印permanent generation heap情况
命令使用：
jmap -heap 2083
可以观察到New Generation（Eden Space，From Space，To Space）,tenured generation,Perm Generation的内存使用情况
输出内容：
<img src="" alt=""> 
jmap -histo 2083 ｜ jmap -histo:live 2083
可以观察heap中所有对象的情况（heap中所有生存的对象的情况）。包括对象数量和所占空间大小。
输出内容：
<img src="" alt=""> 
写个脚本，可以很快把占用heap最大的对象找出来，对付内存泄漏特别有效。
<strong><a href="http://java.sun.com/j2se/1.5.0/docs/tooldocs/share/jstat.html" target="_blank">jstat </a>
</strong>最后要重点介绍下这个命令。
这是jdk命令中比较重要，也是相当实用的一个命令，可以观察到classloader，compiler，gc相关信息
具体参数如下：
-class：统计class loader行为信息
-compile：统计编译行为信息
-gc：统计jdk gc时heap信息
-gccapacity：统计不同的generations（不知道怎么翻译好，包括新生区，老年区，permanent区）相应的heap容量情况
-gccause：统计gc的情况，（同-gcutil）和引起gc的事件
-gcnew：统计gc时，新生代的情况
-gcnewcapacity：统计gc时，新生代heap容量
-gcold：统计gc时，老年区的情况
-gcoldcapacity：统计gc时，老年区heap容量
-gcpermcapacity：统计gc时，permanent区heap容量
-gcutil：统计gc时，heap情况
-printcompilation：不知道干什么的，一直没用过。
一般比较常用的几个参数是：
jstat -class 2083 1000 10 （每隔1秒监控一次，一共做10次）
输出内容含义如下：</p>
<p>Loaded Number of classes loaded. Bytes Number of Kbytes loaded. Unloaded Number of classes unloaded. Bytes Number of Kbytes unloaded. Time Time spent performing class load and unload operations.
jstat -gc 2083 2000 20（每隔2秒监控一次，共做10）
输出内容含义如下：
S0C Current survivor space 0 capacity (KB). EC Current eden space capacity (KB). EU Eden space utilization (KB). OC Current old space capacity (KB). OU Old space utilization (KB). PC Current permanent space capacity (KB). PU Permanent space utilization (KB). YGC Number of young generation GC Events. YGCT Young generation garbage collection time. FGC Number of full GC events. FGCT Full garbage collection time. GCT Total garbage collection time.
输出内容：
<img src="" alt="">
如果能熟练运用这些命令，尤其是在linux下，那么完全可以代替jprofile等监控工具了，谁让它收费呢。呵呵。
用命令的好处就是速度快，并且辅助于其他命令，比如grep gawk sed等，可以组装多种符合自己需求的工具。</p>
<h1 id="-u-jps-"><a href=""></a>u               jps 的用法</h1>
<p>用来查看 JVM 里面所有进程的具体状态 , 包括进程 ID ，进程启动的路径等等。 与 unix 上的 ps 类似，用来显示本地的java 进程，可以查看本地运行着几个 java 程序，并显示他们的进程号。</p>
<p><strong>[root@localhost ~]/# jps</strong></p>
<p>25517 Jps</p>
<p>25444 Bootstrap</p>
<h1 id="-u-jstack-"><a href=""></a>u               jstack 的用法</h1>
<p>如果 java 程序崩溃生成 core 文件， jstack 工具可以用来获得 core 文件的 java stack 和 native stack 的信息，从而可以轻松地知道 java 程序是如何崩溃和在程序何处发生问题。另外， jstack 工具还可以附属到正在运行的 java 程序中，看到当时运行的 java 程序的 java stack 和 native stack 的信息 , 如果现在运行的 java 程序呈现 hung 的状态， jstack 是非常有用的。目前只有在 Solaris 和 Linux 的 JDK 版本里面才有。</p>
<p><strong>[root@localhost bin]/# jstack **</strong>25444**</p>
<p>Attaching to process ID 25917, please wait...</p>
<p>Debugger attached successfully.</p>
<p>Client compiler detected.</p>
<p>JVM version is 1.5.0_08-b03</p>
<p>Thread 25964: (state = BLOCKED)</p>
<p>Error occurred during stack walking:</p>
<p>sun.jvm.hotspot.debugger.DebuggerException: sun.jvm.hotspot.debugger.DebuggerException: get_thread_regs failed for a lwp</p>
<pre><code>    at sun.jvm.hotspot.debugger.linux.LinuxDebuggerLocal$LinuxDebuggerLocalWorkerThread.execute(LinuxDebuggerLocal.java:134)

    at sun.jvm.hotspot.debugger.linux.LinuxDebuggerLocal.getThreadIntegerRegisterSet(LinuxDebuggerLocal.java:437)

    at sun.jvm.hotspot.debugger.linux.LinuxThread.getContext(LinuxThread.java:48)

    at
</code></pre><h1 id="-u-jstat-"><a href=""></a>u               jstat 的用法</h1>
<p>用以判断JVM 是否存在内存问题呢？如何判断JVM 垃圾回收是否正常？一般的top 指令基本上满足不了这样的需求，因为它主要监控的是总体的系统资源，很难定位到java 应用程序。</p>
<p>Jstat 是JDK 自带的一个轻量级小工具。全称“Java Virtual Machine statistics monitoring tool” ，它位于java 的bin 目录下，主要利用JVM 内建的指令对Java 应用程序的资源和性能进行实时的命令行的监控，包括了对Heap size 和垃圾回收状况的监控。可见，Jstat 是轻量级的、专门针对JVM 的工具，非常适用。由于JVM 内存设置较大，图中百分比变化不太明显</p>
<p>一个极强的监视 VM 内存工具。可以用来监视 VM 内存内的各种堆和非堆的大小及其内存使用量。</p>
<p>jstat 工具特别强大，有众多的可选项，详细查看堆内各个部分的使用量，以及加载类的数量。使用时，需加上查看进程的进程 id ，和所选参数。</p>
<p>语法结构：</p>
<p>Usage: jstat -help|-options</p>
<pre><code>   jstat -&lt;option&gt; [-t] [-h&lt;lines&gt;] &lt;vmid&gt; [&lt;interval&gt; [&lt;count&gt;]]
</code></pre><p>参数解释：</p>
<p>Options — 选项，我们一般使用 -gcutil 查看gc 情况</p>
<p>vmid    — VM 的进程号，即当前运行的java 进程号</p>
<p>interval– 间隔时间，单位为秒或者毫秒</p>
<p>count   — 打印次数，如果缺省则打印无数次</p>
<p>S0  — Heap 上的 Survivor space 0 区已使用空间的百分比 
S1  — Heap 上的 Survivor space 1 区已使用空间的百分比 
E   — Heap 上的 Eden space 区已使用空间的百分比 
O   — Heap 上的 Old space 区已使用空间的百分比 
P   — Perm space 区已使用空间的百分比 
YGC — 从应用程序启动到采样时发生 Young GC 的次数 
YGCT– 从应用程序启动到采样时 Young GC 所用的时间( 单位秒 )
FGC — 从应用程序启动到采样时发生 Full GC 的次数 
FGCT– 从应用程序启动到采样时 Full GC 所用的时间( 单位秒 )
GCT — 从应用程序启动到采样时用于垃圾回收的总时间( 单位秒)</p>
<p>实例使用1 ：</p>
<p><strong>[root@localhost bin]/# jstat -gcutil 25444</strong></p>
<p>  S0      S1     E      O      P     YGC     YGCT    FGC    FGCT     GCT</p>
<p>  11.63   0.00    56.46  66.92  98.49 162    0.248    6       0.331    0.579</p>
<p>实例使用 2 ：</p>
<p><strong>[root@localhost bin]/# jstat -gcutil 25444 1000 5</strong></p>
<p>  S0     S1     E      O      P     YGC     YGCT    FGC    FGCT     GCT</p>
<p>  73.54   0.00  99.04  67.52  98.49    166    0.252     6    0.331    0.583</p>
<p>  73.54   0.00  99.04  67.52  98.49    166    0.252     6    0.331    0.583</p>
<p>  73.54   0.00  99.04  67.52  98.49    166    0.252     6    0.331    0.583</p>
<p>  73.54   0.00  99.04  67.52  98.49    166    0.252     6    0.331    0.583</p>
<p>  73.54   0.00  99.04  67.52  98.49    166    0.252     6    0.331    0.583</p>
<p>我们可以看到，5 次young gc 之后，垃圾内存被从Eden space 区(E) 放入了Old space 区(O) ，并引起了百分比的变化，导致Survivor space 使用的百分比从73.54%(S0) 降到0%(S1) 。有效释放了内存空间。绿框中，我们可以看到，一次full gc 之后，Old space 区(O) 的内存被回收，从99.05% 降到67.52% 。</p>
<p>图中同时打印了young gc 和full gc 的总次数、总耗时。而，每次young gc 消耗的时间，可以用相间隔的两行YGCT 相减得到。每次full gc 消耗的时间，可以用相隔的两行FGCT 相减得到。例如红框中表示的第一行、第二行之间发生了1次young gc ，消耗的时间为0.252-0.252 ＝0.0 秒。</p>
<p>常驻内存区(P) 的使用率，始终停留在98.49% 左右，说明常驻内存没有突变，比较正常。</p>
<p>如果young gc 和full gc 能够正常发生，而且都能有效回收内存，常驻内存区变化不明显，则说明java 内存释放情况正常，垃圾回收及时，java 内存泄露的几率就会大大降低。但也不能说明一定没有内存泄露。</p>
<p>GCT 是YGCT 和FGCT 的时间总和。</p>
<p>以上，介绍了Jstat 按百分比查看gc 情况的功能。其实，它还有功能，例如加载类信息统计功能、内存池信息统计功能等，那些是以绝对值的形式打印出来的，比较少用，在此就不做介绍。</p>
<p><strong>[root@localhost bin]/# ps -ef | grep java</strong></p>
<p>root     25917     1  2 23:23 pts /2    00:00:05 /usr/local/jdk1.5/bin/java -Djava.endorsed.dirs=/usr/local/jakarta-tomcat-5.0.30/common/endorsed -classpath /usr/local/jdk1.5/lib/tools.jar:/usr/local/jakarta-tomcat-5.0.30/bin/bootstrap.jar:/usr/local/jakarta-tomcat-5.0.30/bin/commons-logging-api.jar -Dcatalina.base=/usr/local/jakarta-tomcat-5.0.30 -Dcatalina.home=/usr/local/jakarta-tomcat-5.0.30 -Djava.io.tmpdir=/usr/local/jakarta-tomcat-5.0.30/temp org.apache.catalina.startup.Bootstrap start</p>
<p>jstat -class pid: 显示加载 class 的数量，及所占空间等信息。</p>
<p>实例使用3 ：</p>
<p><strong>[root@localhost bin]/# jstat -class 25917</strong></p>
<p>Loaded  Bytes  Unloaded  Bytes     Time</p>
<p>2629     2916.8       29   24.6     0.90</p>
<p>jstat -compiler pid: 显示 VM 实时编译的数量等信息。</p>
<p>实例使用 4 ：</p>
<p><strong>[root@localhost bin]/# jstat -compiler 25917</strong></p>
<p>Compiled Failed Invalid   Time   FailedType FailedMethod</p>
<pre><code> 768      0       0   0.70             0
</code></pre><p>jstat –gccapacity : 可以显示， VM 内存中三代（ young,old,perm ）对象的使用和占用大小，如： PGCMN 显示的是最小 perm 的内存使用量， PGCMX 显示的是 perm 的内存最大使用量， PGC 是当前新生成的 perm 内存占用量， PC 是但前 perm 内存占用量。其他的可以根据这个类推， OC 是 old 内纯的占用量。</p>
<p><strong>[root@localhost bin]/# jstat -gccapacity 25917</strong></p>
<p>NGCMN       640.0</p>
<p>NGCMX       4992.0</p>
<p>NGC         832.0</p>
<p>S0C         64.0</p>
<p>S1C         64.0</p>
<p>EC          704.0</p>
<p>OGCMN       1408.0</p>
<p>OGCMX       60544.0</p>
<p>OGC         9504.0</p>
<p>OC          9504.0                  OC 是 old 内纯的占用量</p>
<p>PGCMN       8192.0                  PGCMN 显示的是最小 perm 的内存使用量</p>
<p>PGCMX       65536.0                 PGCMX 显示的是 perm 的内存最大使用量</p>
<p>PGC         12800.0                 PGC 是当前新生成的 perm 内存占用量</p>
<p>PC          12800.0                 PC 是但前 perm 内存占用量</p>
<p>YGC         164</p>
<p>FGC         6</p>
<p>jstat -gcnew pid: new 对象的信息</p>
<p><strong>[root@localhost bin]/# jstat -gcnew 25917</strong></p>
<p>  S0C    S1C    S0U    S1U   TT MTT  DSS      EC       EU     YGC     YGCT</p>
<p>  64.0   64.0   47.4   0.0    2  15   32.0    704.0    145.7    168    0.254</p>
<p>jstat -gcnewcapacity pid: new 对象的信息及其占用量</p>
<p><strong>[root@localhost bin]/# jstat -gcnewcapacity 25917</strong></p>
<p>  NGCMN   NGCMX    NGC    S0CMX  S0C    S1CMX   S1C   ECMX    EC      YGC   FGC</p>
<p>640.0   4992.0   832.0 64.0     448.0 448.0   64.0   4096.0   704.0  168     6</p>
<p>jstat -gcold pid: old 对象的信息。</p>
<p><strong>[root@localhost bin]/# jstat -gcold 25917</strong></p>
<p>   PC       PU        OC          OU       YGC    FGC    FGCT     GCT</p>
<p>  12800.0  12617.6     9504.0      6561.3   169     6    0.335    0.591</p>
<p>jstat -gcoldcapacity pid:old 对象的信息及其占用量。</p>
<p><strong>[root@localhost bin]/# jstat -gcoldcapacity 25917</strong></p>
<p>OGCMN      OGCMX        OGC         OC       YGC   FGC    FGCT     GCT</p>
<p>1408.0     60544.0      9504.0      9504.0   169     6    0.335    0.591</p>
<p>jstat -gcpermcapacity pid: perm 对象的信息及其占用量。</p>
<p>[root@localhost bin]/# jstat -gcpermcapacity 25917</p>
<p>PGCMN      PGCMX       PGC         PC      YGC   FGC    FGCT     GCT</p>
<p>8192.0    65536.0    12800.0    12800.0   169     6    0.335    0.591</p>
<p>jstat -printcompilation pid: 当前 VM 执行的信息。</p>
<p><strong>[root@localhost bin]/# jstat -printcompilation -h3  25917 1000 5</strong></p>
<p>每 1000 毫秒打印一次，一共打印 5 次，还可以加上 -h3 每三行显示一下标题。</p>
<p>Compiled  Size  Type Method</p>
<pre><code> 788     73    1 java/io/File &lt;init&gt;

 788     73    1 java/io/File &lt;init&gt;

 788     73    1 java/io/File &lt;init&gt;
</code></pre><p>Compiled  Size  Type Method</p>
<pre><code> 788     73    1 java/io/File &lt;init&gt;

 788     73    1 java/io/File &lt;init&gt;
</code></pre><h1 id="-u-jmap-"><a href=""></a>u               jmap 的用法</h1>
<p>打印出某个 java 进程（使用 pid ）内存内的，所有 ‘ 对象 ’ 的情况（如：产生那些对象，及其数量）。</p>
<p>可以输出所有内存中对象的工具，甚至可以将 VM 中的 heap ，以二进制输出成文本。使用方法 jmap -histo pid 。如果连用 SHELL jmap -histo pid&gt;a.log 可以将其保存到文本中去，在一段时间后，使用文本对比工具，可以对比出 GC 回收了哪些对象。 jmap -dump:format=b,file=String 3024 可以将 3024 进程的内存 heap 输出出来到 String 文件里。</p>
<p><strong>[root@localhost bin]/# jmap -histo  25917</strong></p>
<p>Attaching to process ID 26221, please wait...</p>
<p>Debugger attached successfully.</p>
<p>Client compiler detected.</p>
<p>JVM version is 1.5.0_08-b03</p>
<p>Iterating over heap. This may take a while...</p>
<p>Unknown oop at 0xaa6e42d0</p>
<p>Oop&#39;s klass is null</p>
<p>Object Histogram:</p>
<p>Size    Count   Class description</p>
<hr>
<p>3722768 30467    /* ConstMethodKlass</p>
<p>1976480 25334   char[]</p>
<p>1907880 46994   /* SymbolKlass</p>
<p>1762088 2947    byte[]</p>
<p>1709536 30467   /* MethodKlass</p>
<p>1487816 2600    /* ConstantPoolKlass</p>
<p>1009576 2600    /* InstanceKlassKlass</p>
<p>904880  2199    /* ConstantPoolCacheKlass</p>
<p>741432  30893   java.lang.String</p>
<p>653576  4785    int[]</p>
<p>351760  4397    java.lang.reflect.Method</p>
<p>277824  2894    java.lang.Class</p>
<p>248704  3401    short[]</p>
<p>200888  4411    java.lang.Object[]</p>
<p>193656  4045    java.lang.Object[]</p>
<p>179744  5617    java.util.TreeMap$Entry</p>
<p>175688  1800    java.util.HashMap$Entry[]</p>
<p>165288  6887    java.util.HashMap$Entry</p>
<p>104736  3273    java.lang.ref.SoftReference</p>
<p>104136  4339    java.lang.ref.WeakReference</p>
<p>96096   3521    java.lang.String[]</p>
<p>86160   3590    java.util.Hashtable$Entry</p>
<p>85584   3566    java.util.ArrayList</p>
<p>83472   1206    java.util.Hashtable$Entry[]</p>
<p>82944   1728    java.beans.MethodDescriptor</p>
<p>80560   265     /* ObjArrayKlassKlass</p>
<p>69120   1728    java.util.HashMap</p>
<p>52464   3055    java.lang.Class[]</p>
<p>43040   1076    java.util.Hashtable</p>
<p>42496   664     org.apache.commons.modeler.AttributeInfo</p>
<p>37880   947     java.util.TreeMap</p>
<p>33896   557     javax.management.modelmbean.ModelMBeanAttributeInfo[]</p>
<p>33152   518     java.beans.PropertyDescriptor</p>
<p>616     11      org.springframework.aop.framework.ProxyFactory</p>
<p>608     19      java.util.PropertyPermission</p>
<p>608     38      org.springframework.beans.MutablePropertyValues</p>
<p>608     38      org.springframework.beans.factory.support.MethodOverrides</p>
<p>608     2       /* ArrayKlassKlass</p>
<p>608     38      org.springframework.beans.factory.config.ConstructorArgumentValues</p>
<p>608     4       org.apache.xerces.impl.XMLDTDScannerImpl</p>
<p>576     24      java.util.Stack</p>
<p>576     36      java.util.regex.Pattern$Category</p>
<p>576     24      org.apache.naming.NamingEntry</p>
<p>560     7       java.net.URL[]</p>
<p>552     23      sun.management.MappedMXBeanType$BasicMXBeanType</p>
<p>552     1       java.util.Locale[]</p>
<p>552     22      java.io.ObjectStreamField[]</p>
<p>544     17      java.util.Collections$SynchronizedMap</p>
<p>176     11      java.util.regex.Pattern$Ctype</p>
<p>8        1       sun.reflect.GeneratedMethodAccessor49</p>
<p>8       1       sun.reflect.GeneratedMethodAccessor6</p>
<p>8       1       sun.reflect.GeneratedConstructorAccessor10</p>
<p>Heap traversal took 12.003 seconds.</p>
<h1 id="-u-jinfo-"><a href=""></a>u               jinfo 的用法</h1>
<p>可以输出并修改运行时的 java 进程的 opts 。用处比较简单，就是能输出并修改运行时的 java 进程的运行参数。用法是jinfo -opt  pid 如：查看 2788 的 MaxPerm 大小可以用   jinfo -flag MaxPermSize 2788 。</p>
<h1 id="-u-jconsole-"><a href=""></a>u               jconsole 的用法</h1>
<p>jconsole: 一个 java GUI 监视工具，可以以图表化的形式显示各种数据。并可通过远程连接监视远程的服务器 VM 。</p>
<p>用 java 写的 GUI 程序，用来监控 VM ，并可监控远程的 VM ，非常易用，而且功能非常强。命令行里打 jconsole ，选则进程就可以了</p>
<p>不过我没有运行起来，老是报下面的错。会的朋友，帮忙看看。</p>
<p><strong>  [root@localhost bin]/# jconsole</strong></p>
<p>Exception in thread &quot;AWT-EventQueue-0&quot; java.awt.HeadlessException:</p>
<p>No X11 DISPLAY variable was set, but this program performed an operation which requires it.        at java.awt.GraphicsEnvironment.checkHeadless(GraphicsEnvironment.java:159)</p>
<pre><code>    at java.awt.Window.&lt;init&gt;(Window.java:317)

    at java.awt.Frame.&lt;init&gt;(Frame.java:419)

    at javax.swing.JFrame.&lt;init&gt;(JFrame.java:194)

    at sun.tools.jconsole.JConsole.&lt;init&gt;(JConsole.java:65)

    at sun.tools.jconsole.JConsole$4.run(JConsole.java:666)

    at java.awt.event.InvocationEvent.dispatch(InvocationEvent.java:209)

    at java.awt.EventQueue.dispatchEvent(EventQueue.java:461)

    at java.awt.EventDispatchThread.pumpOneEventForHierarchy(EventDispatchThread.java:242)

    at java.awt.EventDispatchThread.pumpEventsForHierarchy(EventDispatchThread.java:163)

    at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:157)

    at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:149)

    at java.awt.EventDispatchThread.run(EventDispatchThread.java:110)
</code></pre><h1 id="-u-jdb-"><a href=""></a>u               jdb 的用法</h1>
<p>用来对 core 文件和正在运行的 Java 进程进行实时地调试，里面包含了丰富的命令帮助您进行调试，它的功能和 Sun studio 里面所带的 dbx 非常相似，但 jdb 是专门用来针对 Java 应用程序的。</p>
<h1 id="-u-jmap-"><a href=""></a>u               jmap 的用法</h1>
<p>打印出某个 java 进程（使用 pid ）内存内的，所有 ‘ 对象 ’ 的情况（如：产生那些对象，及其数量）。</p>
<p>可以输出所有内存中对象的工具，甚至可以将 VM 中的 heap ，以二进制输出成文本。使用方法 jmap -histo pid 。如果连用 SHELL jmap -histo pid&gt;a.log 可以将其保存到文本中去，在一段时间后，使用文本对比工具，可以对比出 GC 回收了哪些对象。 jmap -dump:format=b,file=String 3024 可以将 3024 进程的内存 heap 输出出来到 String 文件里。</p>
<p><strong>[root@localhost bin]/# jmap -histo  25917</strong></p>
<p>Attaching to process ID 26221, please wait...</p>
<p>Debugger attached successfully.</p>
<p>Client compiler detected.</p>
<p>JVM version is 1.5.0_08-b03</p>
<p>Iterating over heap. This may take a while...</p>
<p>Unknown oop at 0xaa6e42d0</p>
<p>Oop&#39;s klass is null</p>
<p>Object Histogram:</p>
<p>Size    Count   Class description</p>
<hr>
<p>3722768 30467    /* ConstMethodKlass</p>
<p>1976480 25334   char[]</p>
<p>1907880 46994   /* SymbolKlass</p>
<p>1762088 2947    byte[]</p>
<p>1709536 30467   /* MethodKlass</p>
<p>1487816 2600    /* ConstantPoolKlass</p>
<p>1009576 2600    /* InstanceKlassKlass</p>
<p>904880  2199    /* ConstantPoolCacheKlass</p>
<p>741432  30893   java.lang.String</p>
<p>653576  4785    int[]</p>
<p>351760  4397    java.lang.reflect.Method</p>
<p>277824  2894    java.lang.Class</p>
<p>248704  3401    short[]</p>
<p>200888  4411    java.lang.Object[]</p>
<p>193656  4045    java.lang.Object[]</p>
<p>179744  5617    java.util.TreeMap$Entry</p>
<p>175688  1800    java.util.HashMap$Entry[]</p>
<p>165288  6887    java.util.HashMap$Entry</p>
<p>104736  3273    java.lang.ref.SoftReference</p>
<p>104136  4339    java.lang.ref.WeakReference</p>
<p>96096   3521    java.lang.String[]</p>
<p>86160   3590    java.util.Hashtable$Entry</p>
<p>85584   3566    java.util.ArrayList</p>
<p>83472   1206    java.util.Hashtable$Entry[]</p>
<p>82944   1728    java.beans.MethodDescriptor</p>
<p>80560   265     /* ObjArrayKlassKlass</p>
<p>69120   1728    java.util.HashMap</p>
<p>52464   3055    java.lang.Class[]</p>
<p>43040   1076    java.util.Hashtable</p>
<p>42496   664     org.apache.commons.modeler.AttributeInfo</p>
<p>37880   947     java.util.TreeMap</p>
<p>33896   557     javax.management.modelmbean.ModelMBeanAttributeInfo[]</p>
<p>33152   518     java.beans.PropertyDescriptor</p>
<p>616     11      org.springframework.aop.framework.ProxyFactory</p>
<p>608     19      java.util.PropertyPermission</p>
<p>608     38      org.springframework.beans.MutablePropertyValues</p>
<p>608     38      org.springframework.beans.factory.support.MethodOverrides</p>
<p>608     2       /* ArrayKlassKlass</p>
<p>608     38      org.springframework.beans.factory.config.ConstructorArgumentValues</p>
<p>608     4       org.apache.xerces.impl.XMLDTDScannerImpl</p>
<p>576     24      java.util.Stack</p>
<p>576     36      java.util.regex.Pattern$Category</p>
<p>576     24      org.apache.naming.NamingEntry</p>
<p>560     7       java.net.URL[]</p>
<p>552     23      sun.management.MappedMXBeanType$BasicMXBeanType</p>
<p>552     1       java.util.Locale[]</p>
<p>552     22      java.io.ObjectStreamField[]</p>
<p>544     17      java.util.Collections$SynchronizedMap</p>
<p>176     11      java.util.regex.Pattern$Ctype</p>
<p>8        1       sun.reflect.GeneratedMethodAccessor49</p>
<p>8       1       sun.reflect.GeneratedMethodAccessor6</p>
<p>8       1       sun.reflect.GeneratedConstructorAccessor10</p>
<p>Heap traversal took 12.003 seconds.</p>
<h1 id="-u-jinfo-"><a href=""></a>u               jinfo 的用法</h1>
<p>可以输出并修改运行时的 java 进程的 opts 。用处比较简单，就是能输出并修改运行时的 java 进程的运行参数。用法是jinfo -opt  pid 如：查看 2788 的 MaxPerm 大小可以用   jinfo -flag MaxPermSize 2788 。</p>
<h1 id="-u-jconsole-"><a href=""></a>u               jconsole 的用法</h1>
<p>jconsole: 一个 java GUI 监视工具，可以以图表化的形式显示各种数据。并可通过远程连接监视远程的服务器 VM 。</p>
<p>用 java 写的 GUI 程序，用来监控 VM ，并可监控远程的 VM ，非常易用，而且功能非常强。命令行里打 jconsole ，选则进程就可以了</p>
<p>不过我没有运行起来，老是报下面的错。会的朋友，帮忙看看。</p>
<p><strong>  [root@localhost bin]/# jconsole</strong></p>
<p>Exception in thread &quot;AWT-EventQueue-0&quot; java.awt.HeadlessException:</p>
<p>No X11 DISPLAY variable was set, but this program performed an operation which requires it.        at java.awt.GraphicsEnvironment.checkHeadless(GraphicsEnvironment.java:159)</p>
<pre><code>    at java.awt.Window.&lt;init&gt;(Window.java:317)

    at java.awt.Frame.&lt;init&gt;(Frame.java:419)

    at javax.swing.JFrame.&lt;init&gt;(JFrame.java:194)

    at sun.tools.jconsole.JConsole.&lt;init&gt;(JConsole.java:65)

    at sun.tools.jconsole.JConsole$4.run(JConsole.java:666)

    at java.awt.event.InvocationEvent.dispatch(InvocationEvent.java:209)

    at java.awt.EventQueue.dispatchEvent(EventQueue.java:461)

    at java.awt.EventDispatchThread.pumpOneEventForHierarchy(EventDispatchThread.java:242)

    at java.awt.EventDispatchThread.pumpEventsForHierarchy(EventDispatchThread.java:163)

    at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:157)

    at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:149)

    at java.awt.EventDispatchThread.run(EventDispatchThread.java:110)
</code></pre><h1 id="-u-jdb-"><a href=""></a>u               jdb 的用法</h1>
<p>用来对 core 文件和正在运行的 Java 进程进行实时地调试，里面包含了丰富的命令帮助您进行调试，它的功能和 Sun studio 里面所带的 dbx 非常相似，但 jdb 是专门用来针对 Java 应用程序的。</p>
<p>来源： <a href="[http://blog.csdn.net/jacky0922/article/details/6201878](http://blog.csdn.net/jacky0922/article/details/6201878)">[http://blog.csdn.net/jacky0922/article/details/6201878](http://blog.csdn.net/jacky0922/article/details/6201878)</a></p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/内存分析/">内存分析</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/内存分析/" class="label label-success">内存分析</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:41"datetime="2014-03-07 09:54:41"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-内存分析--Java内存泄露监控工具-JVM监控工具介绍jstack-jconsole-jinfo-/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-内存分析--Java内存泄露监控工具-JVM监控工具介绍jstack-jconsole-jinfo-" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_多线程-并发--深入浅出JavaConcurrency28-线程池/">深入浅出 Java Concurrency (28)</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:41.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_多线程-并发--深入浅出JavaConcurrency28-线程池/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-java-concurrency-28-">深入浅出 Java Concurrency (28): 线程池</h1>
<p><a href="http://www.blogjava.net/xylz/archive/2010/12/19/341098.html" target="_blank"> 简介</a></p>
<p>从这一节开始正式进入线程池的部分。其实整个体系已经拖了很长的时间，因此后面的章节会加快速度，甚至只是一个半成品或者简单化，以后有时间的慢慢补充、完善。</p>
<p>其实线程池是并发包里面很重要的一部分，在实际情况中也是使用很多的一个重要组件。</p>
<p>下图描述的是线程池API的一部分。广义上的完整线程池可能还包括Thread/Runnable、Timer/TimerTask等部分。这里只介绍主要的和高级的API以及架构和原理。</p>
<p><a href="http://www.blogjava.net/images/blogjava_net/xylz/Windows-Live-Writer/-part-1-_8E6F/ThreadPool2_2.png" target="_blank"><img src="&quot;ThreadPool2&quot;" alt="ThreadPool2"></a></p>
<p>大多数并发应用程序是围绕执行任务（Task）进行管理的。所谓任务就是抽象、离散的工作单元（unit of work）。把一个应用程序的工作（work）分离到任务中，可以简化程序的管理；这种分离还在不同事物间划分了自然的分界线，可以方便程序在出现错误时进行恢复；同时这种分离还可以为并行工作提供一个自然的结构，有利于提高程序的并发性。<a href="http://www.blogjava.net/xylz/archive/2010/12/19/341098.html#jcp" target="_blank">[1]</a></p>
<p>并发执行任务的一个很重要前提是拆分任务。把一个大的过程或者任务拆分成很多小的工作单元，每一个工作单元可能相关、也可能无关，这些单元在一定程度上可以充分利用CPU的特性并发的执行，从而提高并发性（性能、响应时间、吞吐量等）。</p>
<p>所谓的任务拆分就是确定每一个执行任务（工作单元）的边界。理想情况下独立的工作单元有最大的吞吐量，这些工作单元不依赖于其它工作单元的状态、结果或者其他资源等。因此将任务尽可能的拆分成一个个独立的工作单元有利于提高程序的并发性。</p>
<p>对于有依赖关系以及资源竞争的工作单元就涉及到任务的调度和负载均衡。工作单元的状态、结果或者其他资源等有关联的工作单元就需要有一个总体的调度者来协调资源和执行顺序。同样在有限的资源情况下，大量的任务也需要一个协调各个工作单元的调度者。这就涉及到任务执行的策略问题。</p>
<p>任务的执行策略包括4W3H部分：</p>
<ul>
<li>任务在什么（What）线程中执行</li>
<li>任务以什么（What）顺序执行（FIFO/LIFO/优先级等）</li>
<li>同时有多少个（How Many）任务并发执行</li>
<li>允许有多少个（How Many）个任务进入执行队列</li>
<li>系统过载时选择放弃哪一个（Which）任务，如何（How）通知应用程序这个动作</li>
<li>任务执行的开始、结束应该做什么（What）处理</li>
</ul>
<p>在后面的章节中会详细分写这些策略是如何实现的。我们先来简单回答些如何满足上面的条件。</p>
<ol>
<li>首先明确一定是在Java里面可以供使用者调用的启动线程类是Thread。因此Runnable或者Timer/TimerTask等都是要依赖Thread来启动的，因此在ThreadPool里面同样也是靠Thread来启动多线程的。</li>
<li>默认情况下Runnable接口执行完毕后是不能拿到执行结果的，因此在ThreadPool里就定义了一个Callable接口来处理执行结果。</li>
<li>为了异步阻塞的获取结果，Future可以帮助调用线程获取执行结果。</li>
<li>Executor解决了向线程池提交任务的入口问题，同时ScheduledExecutorService解决了如何进行重复调用任务的问题。</li>
<li>CompletionService解决了如何按照执行完毕的顺序获取结果的问题，这在某些情况下可以提高任务执行的并发，调用线程不必在长时间任务上等待过多时间。</li>
<li>显然线程的数量是有限的，而且也不宜过多，因此合适的任务队列是必不可少的，BlockingQueue的容量正好可以解决此问题。</li>
<li>固定任务容量就意味着在容量满了以后需要一定的策略来处理过多的任务（新任务），RejectedExecutionHandler正好解决此问题。</li>
<li>一定时间内阻塞就意味着有超时，因此TimeoutException就是为了描述这种现象。TimeUnit是为了描述超时时间方便的一个时间单元枚举类。</li>
<li>有上述问题就意味了配置一个合适的线程池是很复杂的，因此Executors默认的一些线程池配置可以减少这个操作。</li>
</ol>
<p>线程池的基本策略大致就这些，从下一节开始就从线程池的基本原理和执行方法开始描述。</p>
<p><a href="">[1] Java Concurrency in Practice</a>
来源： <a href="[http://www.blogjava.net/xylz/archive/2010/12/19/341098.html](http://www.blogjava.net/xylz/archive/2010/12/19/341098.html)">[http://www.blogjava.net/xylz/archive/2010/12/19/341098.html](http://www.blogjava.net/xylz/archive/2010/12/19/341098.html)</a> <a href="http://www.blogjava.net/xylz/archive/2010/12/21/341281.html" target="_blank">Executor 以及Executors</a>
Java里面线程池的顶级接口是Executor，但是严格意义上讲Executor并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是ExecutorService。</p>
<p>下面这张图完整描述了线程池的类体系结构。</p>
<p><a href="http://www.blogjava.net/images/blogjava_net/xylz/Windows-Live-Writer/-Java-Concurrency-28--part-1-_1302E/Executor-class_2.png" target="_blank"><img src="&quot;Executor-class&quot;" alt="Executor-class"></a></p>
<p>首先Executor的execute方法只是执行一个Runnable的任务，当然了从某种角度上将最后的实现类也是在线程中启动此任务的。根据线程池的执行策略最后这个任务可能在新的线程中执行，或者线程池中的某个线程，甚至是调用者线程中执行（相当于直接运行Runnable的run方法）。这点在后面会详细说明。</p>
<p>ExecutorService在Executor的基础上增加了一些方法，其中有两个核心的方法：</p>
<ul>
<li>Future&lt;?&gt; submit(Runnable task)</li>
<li><T> Future<T> submit(Callable<T> task)</li>
</ul>
<p>这两个方法都是向线程池中提交任务，它们的区别在于Runnable在执行完毕后没有结果，Callable执行完毕后有一个结果。这在多个线程中传递状态和结果是非常有用的。另外他们的相同点在于都返回一个Future对象。Future对象可以阻塞线程直到运行完毕（获取结果，如果有的话），也可以取消任务执行，当然也能够检测任务是否被取消或者是否执行完毕。</p>
<p>在没有Future之前我们检测一个线程是否执行完毕通常使用Thread.join()或者用一个死循环加状态位来描述线程执行完毕。现在有了更好的方法能够阻塞线程，检测任务执行完毕甚至取消执行中或者未开始执行的任务。</p>
<p>ScheduledExecutorService描述的功能和Timer/TimerTask类似，解决那些需要任务重复执行的问题。这包括延迟时间一次性执行、延迟时间周期性执行以及固定延迟时间周期性执行等。当然了继承ExecutorService的ScheduledExecutorService拥有ExecutorService的全部特性。</p>
<p>ThreadPoolExecutor是ExecutorService的默认实现，其中的配置、策略也是比较复杂的，在后面的章节中会有详细的分析。</p>
<p>ScheduledThreadPoolExecutor是继承ThreadPoolExecutor的ScheduledExecutorService接口实现，周期性任务调度的类实现，在后面的章节中会有详细的分析。</p>
<p>这里需要稍微提一下的是CompletionService接口，它是用于描述顺序获取执行结果的一个线程池包装器。它依赖一个具体的线程池调度，但是能够根据任务的执行先后顺序得到执行结果，这在某些情况下可能提高并发效率。</p>
<p>要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，很有可能配置的线程池不是较优的，因此在Executors类里面提供了一些静态工厂，生成一些常用的线程池。</p>
<ul>
<li><strong>newSingleThreadExecutor</strong>：创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。</li>
<li><strong>newFixedThreadPool</strong>：创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。</li>
<li><strong>newCachedThreadPool</strong>：创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。</li>
<li><strong>newScheduledThreadPool</strong>：创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。</li>
<li><strong>newSingleThreadScheduledExecutor</strong>：创建一个单线程的线程池。此线程池支持定时以及周期性执行任务的需求。</li>
</ul>
<p>在详细讲解ThreadPoolExecutor的时候会具体讨论上述参数配置后的意义和原理。</p>
<p>线程池是一个复杂的任务调度工具，因此它涉及到任务、线程池等的生命周期问题，在下一节中来探讨下这个问题。
来源： <a href="[http://www.blogjava.net/xylz/archive/2010/12/21/341281.html](http://www.blogjava.net/xylz/archive/2010/12/21/341281.html)">[http://www.blogjava.net/xylz/archive/2010/12/21/341281.html](http://www.blogjava.net/xylz/archive/2010/12/21/341281.html)</a> <a href="http://www.blogjava.net/xylz/archive/2011/01/04/342316.html" target="_blank">Executor 生命周期</a></p>
<p>我们知道线程是有多种执行状态的，同样管理线程的线程池也有多种状态。JVM会在所有线程（非后台daemon线程）全部终止后才退出，为了节省资源和有效释放资源关闭一个线程池就显得很重要。有时候无法正确的关闭线程池，将会阻止JVM的结束。</p>
<p>线程池Executor是异步的执行任务，因此任何时刻不能够直接获取提交的任务的状态。这些任务有可能已经完成，也有可能正在执行或者还在排队等待执行。因此关闭线程池可能出现一下几种情况：</p>
<ul>
<li>平缓关闭：已经启动的任务全部执行完毕，同时不再接受新的任务</li>
<li>立即关闭：取消所有正在执行和未执行的任务</li>
</ul>
<p>另外关闭线程池后对于任务的状态应该有相应的反馈信息。</p>
<p>图1 描述了线程池的4种状态。</p>
<ul>
<li>线程池在构造前（new操作）是初始状态，一旦构造完成线程池就进入了执行状态RUNNING。严格意义上讲线程池构造完成后并没有线程被立即启动，只有进行“预启动”或者接收到任务的时候才会启动线程。这个会后面线程池的原理会详细分析。但是线程池是出于运行状态，随时准备接受任务来执行。</li>
<li>线程池运行中可以通过shutdown()和shutdownNow()来改变运行状态。shutdown()是一个平缓的关闭过程，线程池停止接受新的任务，同时等待已经提交的任务执行完毕，包括那些进入队列还没有开始的任务，这时候线程池处于SHUTDOWN状态；shutdownNow()是一个立即关闭过程，线程池停止接受新的任务，同时线程池取消所有执行的任务和已经进入队列但是还没有执行的任务，这时候线程池处于STOP状态。</li>
<li>一旦shutdown()或者shutdownNow()执行完毕，线程池就进入TERMINATED状态，此时线程池就结束了。</li>
<li>isTerminating()描述的是SHUTDOWN和STOP两种状态。</li>
<li>isShutdown()描述的是非RUNNING状态，也就是SHUTDOWN/STOP/TERMINATED三种状态。</li>
</ul>
<p><a href="http://www.blogjava.net/images/blogjava_net/xylz/Windows-Live-Writer/-part-3-Executor-_12486/Executor-Lifecycle_4.png" target="_blank"><img src="&quot;Executor-Lifecycle&quot;" alt="Executor-Lifecycle"></a></p>
<p>图1</p>
<p>线程池的API如下：</p>
<p><a href="http://www.blogjava.net/images/blogjava_net/xylz/Windows-Live-Writer/-part-3-Executor-_12486/ExecutorService-LifeCycle_2.png" target="_blank"><img src="&quot;ExecutorService-LifeCycle&quot;" alt="ExecutorService-LifeCycle"></a></p>
<p>图2</p>
<p>其中shutdownNow()会返回那些已经进入了队列但是还没有执行的任务列表。awaitTermination描述的是等待线程池关闭的时间，如果等待时间线程池还没有关闭将会抛出一个超时异常。</p>
<p>对于关闭线程池期间发生的任务提交情况就会触发一个拒绝执行的操作。这是java.util.concurrent.RejectedExecutionHandler描述的任务操作。下一个小结中将描述这些任务被拒绝后的操作。</p>
<p>总结下这个小节：</p>
<ol>
<li>线程池有运行、关闭、停止、结束四种状态，结束后就会释放所有资源</li>
<li>平缓关闭线程池使用shutdown()</li>
<li>立即关闭线程池使用shutdownNow()，同时得到未执行的任务列表</li>
<li>检测线程池是否正处于关闭中，使用isShutdown()</li>
<li>检测线程池是否已经关闭使用isTerminated()</li>
<li>定时或者永久等待线程池关闭结束使用awaitTermination()操作</li>
</ol>
<p>来源： <a href="[http://www.blogjava.net/xylz/archive/2011/01/04/342316.html](http://www.blogjava.net/xylz/archive/2011/01/04/342316.html)">[http://www.blogjava.net/xylz/archive/2011/01/04/342316.html](http://www.blogjava.net/xylz/archive/2011/01/04/342316.html)</a></p>
<p><strong>线程池数据结构与线程构造方法</strong></p>
<p>由于已经看到了ThreadPoolExecutor的源码，因此很容易就看到了ThreadPoolExecutor线程池的数据结构。图1描述了这种数据结构。</p>
<p><a href="http://www.blogjava.net/images/blogjava_net/xylz/Windows-Live-Writer/-Java-Concurrency-32--part-5-_72AF/ThreadPoolExecutor_2.png" target="_blank"><img src="&quot;ThreadPoolExecutor&quot;" alt="ThreadPoolExecutor"></a></p>
<p>图1 ThreadPoolExecutor 数据结构</p>
<p>其实，即使没有上述图形描述ThreadPoolExecutor的数据结构，我们根据线程池的要求也很能够猜测出其数据结构出来。</p>
<ul>
<li>线程池需要支持多个线程并发执行，因此有一个线程集合Collection<Thread>来执行线程任务；</li>
<li>涉及任务的异步执行，因此需要有一个集合来缓存任务队列Collection<Runnable>；</li>
<li>很显然在多个线程之间协调多个任务，那么就需要一个线程安全的任务集合，同时还需要支持阻塞、超时操作，那么BlockingQueue是必不可少的；</li>
<li>既然是线程池，出发点就是提高系统性能同时降低资源消耗，那么线程池的大小就有限制，因此需要有一个核心线程池大小（线程个数）和一个最大线程池大小（线程个数），有一个计数用来描述当前线程池大小；</li>
<li>如果是有限的线程池大小，那么长时间不使用的线程资源就应该销毁掉，这样就需要一个线程空闲时间的计数来描述线程何时被销毁；</li>
<li>前面描述过线程池也是有生命周期的，因此需要有一个状态来描述线程池当前的运行状态；</li>
<li>线程池的任务队列如果有边界，那么就需要有一个任务拒绝策略来处理过多的任务，同时在线程池的销毁阶段也需要有一个任务拒绝策略来处理新加入的任务；</li>
<li>上面种的线程池大小、线程空闲实际那、线程池运行状态等等状态改变都不是线程安全的，因此需要有一个全局的锁（mainLock）来协调这些竞争资源；</li>
<li>除了以上数据结构以外，ThreadPoolExecutor还有一些状态用来描述线程池的运行计数，例如线程池运行的任务数、曾经达到的最大线程数，主要用于调试和性能分析。</li>
</ul>
<p>对于ThreadPoolExecutor而言，一个线程就是一个Worker对象，它与一个线程绑定，当Worker执行完毕就是线程执行完毕，这个在后面详细讨论线程池中线程的运行方式。</p>
<p>既然是线程池，那么就首先研究下线程的构造方法。
public interface ThreadFactory {
    Thread newThread(Runnable r);
}</p>
<p>ThreadPoolExecutor使用一个线程工厂来构造线程。线程池都是提交一个任务Runnable，然后在某一个线程Thread中执行，ThreadFactory 负责如何创建一个新线程。</p>
<p>在J.U.C中有一个通用的线程工厂java.util.concurrent.Executors.DefaultThreadFactory，它的构造方式如下：
static class DefaultThreadFactory implements ThreadFactory {
    static final AtomicInteger poolNumber = new AtomicInteger(1);
    final ThreadGroup group;
    final AtomicInteger threadNumber = new AtomicInteger(1);
    final String namePrefix;
    DefaultThreadFactory() {
        SecurityManager s = System.getSecurityManager();
        group = (s != null)? s.getThreadGroup() :
                             Thread.currentThread().getThreadGroup();
        namePrefix = &quot;pool-&quot; +
                      poolNumber.getAndIncrement() +
                     &quot;-thread-&quot;;
    }
    public Thread newThread(Runnable r) {
        Thread t = new Thread(group, r,
                              namePrefix + threadNumber.getAndIncrement(),
                              0);
        if (t.isDaemon())
            t.setDaemon(false);
        if (t.getPriority() != Thread.NORM_PRIORITY)
            t.setPriority(Thread.NORM_PRIORITY);
        return t;
    }
}</p>
<p>在这个线程工厂中，同一个线程池的所有线程属于同一个线程组，也就是创建线程池的那个线程组，同时线程池的名称都是“pool-<poolNum>-thread-<threadNum>”，其中poolNum是线程池的数量序号，threadNum是此线程池中的线程数量序号。这样如果使用jstack的话很容易就看到了系统中线程池的数量和线程池中线程的数量。另外对于线程池中的所有线程默认都转换为非后台线程，这样主线程退出时不会直接退出JVM，而是等待线程池结束。还有一点就是默认将线程池中的所有线程都调为同一个级别，这样在操作系统角度来看所有系统都是公平的，不会导致竞争堆积。</p>
<p><strong>线程池中线程生命周期</strong></p>
<p>一个线程Worker被构造出来以后就开始处于运行状态。以下是一个线程执行的简版逻辑。
private final class Worker implements Runnable {
    private final ReentrantLock runLock = new ReentrantLock();
    private Runnable firstTask;
    Thread thread;
    Worker(Runnable firstTask) {
        this.firstTask = firstTask;
    }
    private void runTask(Runnable task) {
        final ReentrantLock runLock = this.runLock;
        runLock.lock();
        try {
           task.run();
        } finally {
            runLock.unlock();
        }
    }
    public void run() {
        try {
            Runnable task = firstTask;
            firstTask = null;
            while (task != null || (task = getTask()) != null) {
                runTask(task);
                task = null;
            }
        } finally {
            workerDone(this);
        }
    }
}</p>
<p><a href="http://www.blogjava.net/images/blogjava_net/xylz/Windows-Live-Writer/-Java-Concurrency-32--part-5-_72AF/ThreadPoolExecutor-Worker_2.png" target="_blank"><img src="&quot;ThreadPoolExecutor-Worker&quot;" alt="ThreadPoolExecutor-Worker"></a></p>
<p>当提交一个任务时，如果需要创建一个线程（何时需要在下一节中探讨）时，就调用线程工厂创建一个线程，同时将线程绑定到Worker工作队列中。需要说明的是，Worker队列构造的时候带着一个任务Runnable，因此Worker创建时总是绑定着一个待执行任务。换句话说，创建线程的前提是有必要创建线程（任务数已经超出了线程或者强制创建新的线程，至于为何强制创建新的线程后面章节会具体分析），不会无缘无故创建一堆空闲线程等着任务。这是节省资源的一种方式。</p>
<p>一旦线程池启动线程后（调用线程run()）方法，那么线程工作队列Worker就从第1个任务开始执行（这时候发现构造Worker时传递一个任务的好处了），一旦第1个任务执行完毕，就从线程池的任务队列中取出下一个任务进行执行。循环如此，直到线程池被关闭或者任务抛出了一个RuntimeException。</p>
<p>由此可见，线程池的基本原理其实也很简单，无非预先启动一些线程，线程进入死循环状态，每次从任务队列中获取一个任务进行执行，直到线程池被关闭。如果某个线程因为执行某个任务发生异常而终止，那么重新创建一个新的线程而已。如此反复。</p>
<p>其实，线程池原理看起来简单，但是复杂的是各种策略，例如何时该启动一个线程，何时该终止、挂起、唤醒一个线程，任务队列的阻塞与超时，线程池的生命周期以及任务拒绝策略等等。下一节将研究这些策略问题。</p>
<p>来源： <a href="[http://www.blogjava.net/xylz/archive/2011/01/18/343183.html](http://www.blogjava.net/xylz/archive/2011/01/18/343183.html)">[http://www.blogjava.net/xylz/archive/2011/01/18/343183.html](http://www.blogjava.net/xylz/archive/2011/01/18/343183.html)</a> </p>
<p><strong>线程池任务执行流程</strong></p>
<p>我们从一个API开始接触Executor是如何处理任务队列的。</p>
<p>java.util.concurrent.Executor.execute(Runnable)
Executes the given task sometime in the future. The task may execute in a new thread or in an existing pooled thread. If the task cannot be submitted for execution, either because this executor has been shutdown or because its capacity has been reached, the task is handled by the current RejectedExecutionHandler.</p>
<p>线程池中所有任务执行都依赖于此接口。这段话有以下几个意思：</p>
<ol>
<li>任务可能在将来某个时刻被执行，有可能不是立即执行。为什么这里有两个“可能”？继续往下面看。</li>
<li>任务可能在一个新的线程中执行或者线程池中存在的一个线程中执行。</li>
<li>任务无法被提交执行有以下两个原因：线程池已经关闭或者线程池已经达到了容量限制。</li>
<li>所有失败的任务都将被“当前”的任务拒绝策略RejectedExecutionHandler 处理。</li>
</ol>
<p>回答上面两个“可能“。任务可能被执行，那不可能的情况就是上面说的情况3；可能不是立即执行，是因为任务可能还在队列中排队，因此还在等待分配线程执行。了解完了字面上的问题，我们再来看具体的实现。
public void execute(Runnable command) {
    if (command == null)
        throw new NullPointerException();
    if (poolSize &gt;= corePoolSize || !addIfUnderCorePoolSize(command)) {
        if (runState == RUNNING &amp;&amp; workQueue.offer(command)) {
            if (runState != RUNNING || poolSize == 0)
                ensureQueuedTaskHandled(command);
        }
        else if (!addIfUnderMaximumPoolSize(command))
            reject(command); // is shutdown or saturated
    }
}</p>
<p>这一段代码看起来挺简单的，其实这就是线程池最重要的一部分，如果能够完全理解这一块，线程池还是挺容易的。整个执行流程是这样的：</p>
<ol>
<li>如果任务command为空，则抛出空指针异常，返回。否则进行2。</li>
<li>如果当前线程池大小 大于或等于 核心线程池大小，进行4。否则进行3。</li>
<li>创建一个新工作队列（线程，参考上一节），成功直接返回，失败进行4。</li>
<li>如果线程池正在运行并且任务加入线程池队列成功，进行5，否则进行7。</li>
<li>如果线程池已经关闭或者线程池大小为0，进行6，否则直接返回。</li>
<li>如果线程池已经关闭则执行拒绝策略返回，否则启动一个新线程来进行执行任务，返回。</li>
<li>如果线程池大小 不大于 最大线程池数量，则启动新线程来进行执行，否则进行拒绝策略，结束。</li>
</ol>
<p>文字描述步骤不够简单？下面图形详细表述了此过程。</p>
<p><a href="http://www.blogjava.net/images/blogjava_net/xylz/Windows-Live-Writer/-Java-Concurrency-34--part-7--2_BFAE/Executor.execute_8.png" target="_blank"><img src="&quot;Executor.execute&quot;" alt="Executor.execute"></a></p>
<p>老实说这个图比上面步骤更难以理解，那么从何入手呢。</p>
<p>流程的入口很简单，我们就是要执行一个任务（Runnable command)，那么它的结束点在哪或者有哪几个？</p>
<p>根据左边这个图我们知道可能有以下几种出口：</p>
<p>（1）图中的P1、P7，我们根据这条路径可以看到，仅仅是将任务加入任务队列（offer(command)）了；</p>
<p>（2）图中的P3，这条路径不将任务加入任务队列，但是启动了一个新工作线程（Worker）进行扫尾操作，用户处理为空的任务队列；</p>
<p>（3）图中的P4，这条路径没有将任务加入任务队列，但是启动了一个新工作线程（Worker），并且工作现场的第一个任务就是当前任务；</p>
<p>（4）图中的P5、P6，这条路径没有将任务加入任务队列，也没有启动工作线程，仅仅是抛给了任务拒绝策略。P2是任务加入了任务队列却因为线程池已经关闭于是又从任务队列中删除，并且抛给了拒绝策略。</p>
<p>如果上面的解释还不清楚，可以去研究下面两段代码：
java.util.concurrent.ThreadPoolExecutor.addIfUnderCorePoolSize(Runnable)
java.util.concurrent.ThreadPoolExecutor.addIfUnderMaximumPoolSize(Runnable)
java.util.concurrent.ThreadPoolExecutor.ensureQueuedTaskHandled(Runnable)</p>
<p>那么什么时候一个任务被立即执行呢？</p>
<p>在线程池运行状态下，如果线程池大小 小于 核心线程池大小或者线程池已满（任务队列已满）并且线程池大小 小于 最大线程池大小（此时线程池大小 大于 核心线程池大小的），用程序描述为：
runState == RUNNING &amp;&amp; ( poolSize &lt; corePoolSize || poolSize &lt; maxnumPoolSize &amp;&amp; workQueue.isFull())</p>
<p>上面的条件就是一个任务能够被立即执行的条件。</p>
<p>有了execute的基础，我们看看ExecutorService中的几个submit方法的实现。
    public Future&lt;?&gt; submit(Runnable task) {
        if (task == null) throw new NullPointerException();
        RunnableFuture<Object> ftask = newTaskFor(task, null);
        execute(ftask);
        return ftask;
    }
    public <T> Future<T> submit(Runnable task, T result) {
        if (task == null) throw new NullPointerException();
        RunnableFuture<T> ftask = newTaskFor(task, result);
        execute(ftask);
        return ftask;
    }
    public <T> Future<T> submit(Callable<T> task) {
        if (task == null) throw new NullPointerException();
        RunnableFuture<T> ftask = newTaskFor(task);
        execute(ftask);
        return ftask;
    }</p>
<p>很简单，不是么？对于一个线程池来说复杂的地方也就在execute方法的执行流程。在下一节中我们来讨论下如何获取任务的执行结果，也就是Future类的使用和原理。</p>
<p>来源： <a href="[http://www.blogjava.net/xylz/archive/2011/02/11/344091.html](http://www.blogjava.net/xylz/archive/2011/02/11/344091.html)">[http://www.blogjava.net/xylz/archive/2011/02/11/344091.html](http://www.blogjava.net/xylz/archive/2011/02/11/344091.html)</a> </p>
<p><strong>线程池任务执行结果</strong></p>
<p>这一节来探讨下线程池中任务执行的结果以及如何阻塞线程、取消任务等等。
1 package info.imxylz.study.concurrency.future;
2 
3 public class SleepForResultDemo implements Runnable {
4 
5     static boolean result = false;
6 
7     static void sleepWhile(long ms) {
8         try {
9             Thread.sleep(ms);
10         } catch (Exception e) {}
11     }
12 
13     @Override
14     public void run() {
15         //do work
16         System.out.println(&quot;Hello, sleep a while.&quot;);
17         sleepWhile(2000L);
18         result = true;
19     }
20 
21     public static void main(String[] args) {
22         SleepForResultDemo demo = new SleepForResultDemo();
23         Thread t = new Thread(demo);
24         t.start();
25         sleepWhile(3000L);
26         System.out.println(result);
27     }
28 
29 }
30 </p>
<p>在没有线程池的时代里面，使用Thread.sleep(long)去获取线程执行完毕的场景很多。显然这种方式很笨拙，他需要你事先知道任务可能的执行时间，并且还会阻塞主线程，不管任务有没有执行完毕。</p>
<p>1 package info.imxylz.study.concurrency.future;
2 
3 public class SleepLoopForResultDemo implements Runnable {
4 
5     boolean result = false;
6 
7     volatile boolean finished = false;
8 
9     static void sleepWhile(long ms) {
10         try {
11             Thread.sleep(ms);
12         } catch (Exception e) {}
13     }
14 
15     @Override
16     public void run() {
17         //do work
18         try {
19             System.out.println(&quot;Hello, sleep a while.&quot;);
20             sleepWhile(2000L);
21             result = true;
22         } finally {
23             finished = true;
24         }
25     }
26 
27     public static void main(String[] args) {
28         SleepLoopForResultDemo demo = new SleepLoopForResultDemo();
29         Thread t = new Thread(demo);
30         t.start();
31         while (!demo.finished) {
32             sleepWhile(10L);
33         }
34         System.out.println(demo.result);
35     }
36 
37 }
38 </p>
<p>使用volatile与while死循环的好处就是等待的时间可以稍微小一点，但是依然有CPU负载高并且阻塞主线程的问题。最简单的降低CPU负载的方式就是使用Thread.join().</p>
<pre><code>    SleepLoopForResultDemo demo = new SleepLoopForResultDemo();
    Thread t = new Thread(demo);
    t.start();
    t.join();
    System.out.println(demo.result);
</code></pre><p>显然这也是一种不错的方式，另外还有自己写锁使用wait/notify的方式。其实join()从本质上讲就是利用while和wait来实现的。</p>
<p>上面的方式中都存在一个问题，那就是会阻塞主线程并且任务不能被取消。为了解决这个问题，线程池中提供了一个Future接口。</p>
<p><a href="http://www.blogjava.net/images/blogjava_net/xylz/Windows-Live-Writer/-Java-Concurrency-35--part-8--2_BFEA/ThreadPoolExecutor-Future_2.png" target="_blank"><img src="&quot;ThreadPoolExecutor-Future&quot;" alt="ThreadPoolExecutor-Future"></a></p>
<p>在Future接口中提供了5个方法。</p>
<ul>
<li>V get() throws InterruptedException, ExecutionException： 等待计算完成，然后获取其结果。</li>
<li>V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException。最多等待为使计算完成所给定的时间之后，获取其结果（如果结果可用）。</li>
<li>boolean cancel(boolean mayInterruptIfRunning)：试图取消对此任务的执行。</li>
<li>boolean isCancelled()：如果在任务正常完成前将其取消，则返回 true。</li>
<li>boolean isDone()：如果任务已完成，则返回 true。 可能由于正常终止、异常或取消而完成，在所有这些情况中，此方法都将返回 true。</li>
</ul>
<p>API看起来容易，来研究下异常吧。get()请求获取一个结果会阻塞当前进程，并且可能抛出以下三种异常：</p>
<ul>
<li>InterruptedException：执行任务的线程被中断则会抛出此异常，此时不能知道任务是否执行完毕，因此其结果是无用的，必须处理此异常。</li>
<li>ExecutionException：任务执行过程中(Runnable/#run()）方法可能抛出RuntimeException，如果提交的是一个java.util.concurrent.Callable<V>接口任务，那么java.util.concurrent.Callable.call()方法有可能抛出任意异常。</li>
<li>CancellationException：实际上get()方法还可能抛出一个CancellationException的RuntimeException，也就是任务被取消了但是依然去获取结果。</li>
</ul>
<p>对于get(long timeout, TimeUnit unit)而言，除了get()方法的异常外，由于有超时机制，因此还可能得到一个TimeoutException。</p>
<p>boolean cancel(boolean mayInterruptIfRunning)方法比较复杂，各种情况比较多：</p>
<ol>
<li>如果任务已经执行完毕，那么返回false。</li>
<li>如果任务已经取消，那么返回false。</li>
<li>循环直到设置任务为取消状态，对于未启动的任务将永远不再执行，对于正在运行的任务，将根据mayInterruptIfRunning是否中断其运行，如果不中断那么任务将继续运行直到结束。</li>
<li>此方法返回后任务要么处于运行结束状态，要么处于取消状态。isDone()将永远返回true，如果cancel()方法返回true，isCancelled()始终返回true。</li>
</ol>
<p>来看看Future接口的实现类java.util.concurrent.FutureTask<V>具体是如何操作的。</p>
<p>在FutureTask中使用了一个<a href="http://www.blogjava.net/xylz/archive/2010/07/06/325390.html" target="_blank">AQS</a>数据结构来完成各种状态以及加锁、阻塞的实现。</p>
<p>在此AQS类java.util.concurrent.FutureTask.Sync中一个任务用4中状态：</p>
<p><a href="http://www.blogjava.net/images/blogjava_net/xylz/Windows-Live-Writer/-Java-Concurrency-35--part-8--2_BFEA/ThreadPoolExecutor-FutureTask-state_2.png" target="_blank"><img src="&quot;ThreadPoolExecutor-FutureTask-state&quot;" alt="ThreadPoolExecutor-FutureTask-state"></a></p>
<p>初始情况下任务状态state=0，任务执行(innerRun)后状态变为运行状态RUNNING(state=1)，执行完毕后变成运行结束状态RAN(state=2)。任务在初始状态或者执行状态被取消后就变为状态CANCELLED(state=4)。<a href="http://www.blogjava.net/xylz/archive/2010/07/06/325390.html" target="_blank">AQS</a>最擅长无锁情况下处理几种简单的状态变更的。
        void innerRun() {
            if (!compareAndSetState(0, RUNNING))
                return;
            try {
                runner = Thread.currentThread();
                if (getState() == RUNNING) // recheck after setting thread
                    innerSet(callable.call());
                else
                    releaseShared(0); // cancel
            } catch (Throwable ex) {
                innerSetException(ex);
            }
        }</p>
<p>执行一个任务有四步：设置运行状态、设置当前线程（AQS需要）、执行任务(Runnable/#run或者Callable/#call）、设置执行结果。这里也可以看到，一个任务只能执行一次，因为执行完毕后它的状态不在为初始值0，要么为CANCELLED，要么为RAN。</p>
<p>取消一个任务(cancel)又是怎样进行的呢？对比下前面取消任务的描述是不是很简单，这里无非利用AQS的状态来改变任务的执行状态，最终达到放弃未启动或者正在执行的任务的目的。
boolean innerCancel(boolean mayInterruptIfRunning) {
    for (;;) {
        int s = getState();
        if (ranOrCancelled(s))
            return false;
        if (compareAndSetState(s, CANCELLED))
            break;
    }
    if (mayInterruptIfRunning) {
        Thread r = runner;
        if (r != null)
            r.interrupt();
    }
    releaseShared(0);
    done();
    return true;
}</p>
<p>到目前为止我们依然没有说明到底是如何阻塞获取一个结果的。下面四段代码描述了这个过程。</p>
<p>1     V innerGet() throws InterruptedException, ExecutionException {
2         acquireSharedInterruptibly(0);
3         if (getState() == CANCELLED)
4             throw new CancellationException();
5         if (exception != null)
6             throw new ExecutionException(exception);
7         return result;
8     }
9     //AQS/#acquireSharedInterruptibly
10     public final void acquireSharedInterruptibly(int arg) throws InterruptedException {
11         if (Thread.interrupted())
12             throw new InterruptedException();
13         if (tryAcquireShared(arg) &lt; 0)
14             doAcquireSharedInterruptibly(arg); //park current Thread for result
15     }
16     protected int tryAcquireShared(int ignore) {
17         return innerIsDone()? 1 : -1;
18     }
19 
20     boolean innerIsDone() {
21         return ranOrCancelled(getState()) &amp;&amp; runner == null;
22     }</p>
<p>当调用Future/#get()的时候尝试去获取一个共享变量。这就涉及到AQS的使用方式了。这里获取一个共享变量的状态是任务是否结束(innerIsDone())，也就是任务是否执行完毕或者被取消。如果不满足条件，那么在AQS中就会doAcquireSharedInterruptibly(arg)挂起当前线程，直到满足条件。AQS前面讲过，挂起线程使用的是LockSupport的park方式，因此性能消耗是很低的。</p>
<p>至于将Runnable接口转换成Callable接口，java.util.concurrent.Executors.callable(Runnable, T)也提供了一个简单实现。
    static final class RunnableAdapter<T> implements Callable<T> {
        final Runnable task;
        final T result;
        RunnableAdapter(Runnable  task, T result) {
            this.task = task;
            this.result = result;
        }
        public T call() {
            task.run();
            return result;
        }
    }</p>
<p><strong>延迟、周期性任务调度的实现</strong></p>
<p>java.util.concurrent.ScheduledThreadPoolExecutor是默认的延迟、周期性任务调度的实现。</p>
<p>有了整个线程池的实现，再回头来看延迟、周期性任务调度的实现应该就很简单了，因为所谓的延迟、周期性任务调度，无非添加一系列有序的任务队列，然后按照执行顺序的先后来处理整个任务队列。如果是周期性任务，那么在执行完毕的时候加入下一个时间点的任务即可。</p>
<p>由此可见，ScheduledThreadPoolExecutor和ThreadPoolExecutor的唯一区别在于任务是有序（按照执行时间顺序）的，并且需要到达时间点（临界点）才能执行，并不是任务队列中有任务就需要执行的。也就是说唯一不同的就是任务队列BlockingQueue<Runnable> workQueue不一样。ScheduledThreadPoolExecutor的任务队列是java.util.concurrent.ScheduledThreadPoolExecutor.DelayedWorkQueue，它是基于java.util.concurrent.DelayQueue<RunnableScheduledFuture>队列的实现。</p>
<p>DelayQueue是基于有序队列<a href="http://www.blogjava.net/xylz/archive/2010/07/30/327582.html" target="_blank">PriorityQueue</a>实现的。<a href="http://www.blogjava.net/xylz/archive/2010/07/30/327582.html" target="_blank">PriorityQueue</a> 也叫优先级队列，按照自然顺序对元素进行排序，类似于TreeMap/Collections.sort一样。</p>
<p>同样是有序队列，DelayQueue和<a href="http://www.blogjava.net/xylz/archive/2010/07/30/327582.html" target="_blank">PriorityQueue</a>区别在什么地方？</p>
<p>由于DelayQueue在获取元素时需要检测元素是否“可用”，也就是任务是否达到“临界点”（指定时间点），因此加入元素和移除元素会有一些额外的操作。</p>
<p>典型的，移除元素需要检测元素是否达到“临界点”，增加元素的时候如果有一个元素比“头元素”更早达到临界点，那么就需要通知任务队列。因此这需要一个条件变量final Condition available 。</p>
<p>移除元素（出队列）的过程是这样的：</p>
<ul>
<li>总是检测队列的头元素（顺序最小元素，也是最先达到临界点的元素）</li>
<li>检测头元素与当前时间的差，如果大于0，表示还未到底临界点，因此等待响应时间（使用条件变量available)</li>
<li>如果小于或者等于0，说明已经到底临界点或者已经过了临界点，那么就移除头元素，并且唤醒其它等待任务队列的线程。
  public E take() throws InterruptedException {<pre><code>  final ReentrantLock lock = this.lock;
  lock.lockInterruptibly();
  try {
      for (;;) {
          E first = q.peek();
          if (first == null) {
              available.await();
          } else {
              long delay =  first.getDelay(TimeUnit.NANOSECONDS);
              if (delay &gt; 0) {
                  long tl = available.awaitNanos(delay);
              } else {
                  E x = q.poll();
                  assert x != null;
                  if (q.size() != 0)
                      available.signalAll(); // wake up other takers
                  return x;
              }
          }
      }
  } finally {
      lock.unlock();
  }
</code></pre>  }</li>
</ul>
<p>同样加入元素也会有相应的条件变量操作。当前仅当队列为空或者要加入的元素比队列中的头元素还小的时候才需要唤醒“等待线程”去检测元素。因为头元素都没有唤醒那么比头元素更延迟的元素就更加不会唤醒。</p>
<pre><code>public boolean offer(E e) {
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {
        E first = q.peek();
        q.offer(e);
        if (first == null || e.compareTo(first) &lt; 0)
            available.signalAll();
        return true;
    } finally {
        lock.unlock();
    }
}
</code></pre><p>有了任务队列后再来看Future在ScheduledThreadPoolExecutor中是如何操作的。</p>
<p>java.util.concurrent.ScheduledThreadPoolExecutor.ScheduledFutureTask<V>是继承java.util.concurrent.FutureTask<V>的，区别在于执行任务是否是周期性的。
        private void runPeriodic() {
            boolean ok = ScheduledFutureTask.super.runAndReset();
            boolean down = isShutdown();
            // Reschedule if not cancelled and not shutdown or policy allows
            if (ok &amp;&amp; (!down ||
                       (getContinueExistingPeriodicTasksAfterShutdownPolicy() &amp;&amp;
                        !isStopped()))) {
                long p = period;
                if (p &gt; 0)
                    time += p;
                else
                    time = now() - p;
                ScheduledThreadPoolExecutor.super.getQueue().add(this);
            }
            // This might have been the final executed delayed
            // task.  Wake up threads to check.
            else if (down)
                interruptIdleWorkers();
        }
        //<em>/</em>
         /<em> Overrides FutureTask version so as to reset/requeue if periodic.
         /</em>/
        public void run() {
            if (isPeriodic())
                runPeriodic();
            else
                ScheduledFutureTask.super.run();
        }
    }</p>
<p>如果不是周期性任务调度，那么就和java.util.concurrent.FutureTask.Sync的调度方式是一样的。如果是周期性任务（isPeriodic()）那么就稍微有所不同的。</p>
<p><a href="http://www.blogjava.net/images/blogjava_net/xylz/Windows-Live-Writer/-Java-Concurrency-35--part-8--2_BFEA/ScheduledThreadPoolExecutor-ScheduledFutureTask_4.png" target="_blank"><img src="&quot;ScheduledThreadPoolExecutor-ScheduledFutureTask&quot;" alt="ScheduledThreadPoolExecutor-ScheduledFutureTask"></a></p>
<p>先从功能/结构上分析下。第一种情况假设提交的任务每次执行花费10s，间隔（delay/period)为20s，对于scheduleAtFixedRate而言，每次执行开始时间20s，对于scheduleWithFixedDelay来说每次执行开始时间30s。第二种情况假设提交的任务每次执行时间花费20s，间隔（delay/period)为10s，对于scheduleAtFixedRate而言，每次执行开始时间10s，对于scheduleWithFixedDelay来说每次执行开始时间30s。（具体分析可以参考<a href="http://www.blogjava.net/xylz/archive/2011/01/10/342738.html" target="_blank">这里</a>）</p>
<p>也就是说scheduleWithFixedDelay的执行开始时间为(delay+cost)，而对于scheduleAtFixedRate来说执行开始时间为max(period,cost)。</p>
<p>回头再来看上面源码runPeriodic()就很容易了。但特别要提醒的，如果任务的任何一个执行遇到异常，则后续执行都会被取消，这从runPeriodic()就能看出。要强调的第二点就是<strong>同一个周期性任务不会被同时执行</strong>。就比如说尽管上面第二种情况的scheduleAtFixedRate任务每隔10s执行到达一个时间点，但是由于每次执行时间花费为20s，因此每次执行间隔为20s，只不过执行的任务次数会多一点。但从本质上讲就是每隔20s执行一次，如果任务队列不取消的话。</p>
<p>为什么不会同时执行？</p>
<p>这是因为ScheduledFutureTask执行的时候会将任务从队列中移除来，执行完毕以后才会添加下一个同序列的任务，因此任务队列中其实最多只有同序列的任务的一份副本，所以永远不会同时执行（尽管要执行的时间在过去）。</p>
<p>ScheduledThreadPoolExecutor使用一个无界（容量无限，整数的最大值）的容器（DelayedWorkQueue队列），根据<a href="http://www.blogjava.net/xylz/archive/2011/02/11/344091.html" target="_blank">ThreadPoolExecutor</a>的原理，只要当容器满的时候才会启动一个大于corePoolSize的线程数。因此实际上ScheduledThreadPoolExecutor是一个固定线程大小的线程池，固定大小为corePoolSize，构造函数里面的Integer.MAX_VALUE其实是不生效的（尽管<a href="http://www.blogjava.net/xylz/archive/2010/07/30/327582.html" target="_blank">PriorityQueue</a>使用数组实现有<a href="http://www.blogjava.net/xylz/archive/2010/07/30/327582.html" target="_blank">PriorityQueue</a>大小限制，如果你的任务数超过了2147483647就会导致OutOfMemoryError，这个参考<a href="http://www.blogjava.net/xylz/archive/2010/07/30/327582.html" target="_blank">PriorityQueue</a>的grow方法）。</p>
<p>再回头看scheduleAtFixedRate等方法就容易多了。无非就是往任务队列中添加一个未来某一时刻的ScheduledFutureTask任务，如果是scheduleAtFixedRate那么period/delay就是正数，如果是scheduleWithFixedDelay那么period/delay就是一个负数，如果是0那么就是一次性任务。直接调用父类<a href="http://www.blogjava.net/xylz/archive/2011/02/11/344091.html" target="_blank">ThreadPoolExecutor</a>的execute/submit等方法就相当于period/delay是0，并且initialDelay也是0。
    public ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command,
                                                  long initialDelay,
                                                  long period,
                                                  TimeUnit unit) {
        if (command == null || unit == null)
            throw new NullPointerException();
        if (period &lt;= 0)
            throw new IllegalArgumentException();
        if (initialDelay &lt; 0) initialDelay = 0;
        long triggerTime = now() + unit.toNanos(initialDelay);
        RunnableScheduledFuture&lt;?&gt; t = decorateTask(command,
            new ScheduledFutureTask<Object>(command,
                                            null,
                                            triggerTime,
                                            unit.toNanos(period)));
        delayedExecute(t);
        return t;
    }</p>
<p>另外需要补充说明的一点，前面说过java.util.concurrent.FutureTask.Sync任务只能执行一次，那么在runPeriodic()里面怎么又将执行过的任务加入队列中呢？这是因为java.util.concurrent.FutureTask.Sync提供了一个innerRunAndReset()方法，此方法不仅执行任务还将任务的状态还原成0（初始状态）了，所以此任务就可以重复执行。这就是为什么runPeriodic()里面调用runAndRest()的缘故。</p>
<pre><code>    boolean innerRunAndReset() {
        if (!compareAndSetState(0, RUNNING))
            return false;
        try {
            runner = Thread.currentThread();
            if (getState() == RUNNING)
                callable.call(); // don&#39;t set result
            runner = null;
            return compareAndSetState(RUNNING, 0);
        } catch (Throwable ex) {
            innerSetException(ex);
            return false;
        }
    }
</code></pre><p><strong>后话</strong></p>
<p>整个并发实践原理和实现（源码）上的东西都讲完了，后面几个小节是一些总结和扫尾的工作，包括超时机制、异常处理等一些细节问题。也就是说大部分只需要搬出一些理论和最佳实践知识出来就好了，不会有大量费脑筋的算法分析和原理、思想探讨之类的。后面的章节也会加快一些进度。</p>
<p>老实说从刚开始的好奇到中间的兴奋，再到现在的彻悟，收获还是很多，个人觉得这是最认真、最努力也是自我最满意的一次技术研究和探讨，同时在这个过程中将很多技术细节都串联起来了，慢慢就有了那种技术相通的感觉。原来有了理论以后再去实践、再去分析问题、解决问题和那种纯解决问题得到的经验完全不一样。整个专辑下来不仅仅是并发包这一点点知识，设计到硬件、软件、操作系统、网络、安全、性能、算法、理论等等，总的来说这也算是一次比较成功的研究切入点，这比<a href="http://www.blogjava.net/xylz/archive/2009/12/22/306955.html" target="_blank">Guice</a>那次探讨要深入和持久的多。
来源： <a href="[http://www.blogjava.net/xylz/archive/2011/02/13/344207.html](http://www.blogjava.net/xylz/archive/2011/02/13/344207.html)">[http://www.blogjava.net/xylz/archive/2011/02/13/344207.html](http://www.blogjava.net/xylz/archive/2011/02/13/344207.html)</a> </p>
<p><a href="http://www.blogjava.net/xylz/archive/2011/07/12/354206.html" target="_blank">并发操作异常体系</a> </p>
<p>并发包引入的工具类很多方法都会抛出一定的异常，这些异常描述了任务在线程池中执行时发生的例外情况，而通常这些例外需要应用程序进行捕捉和处理。</p>
<p>例如在Future接口中有如下一个API：</p>
<p>java.util.concurrent.Future.get(long, TimeUnit) throws InterruptedException, ExecutionException, TimeoutException;</p>
<p>在<a href="http://www.blogjava.net/xylz/archive/2011/02/13/344207.html" target="_blank">前面的章节</a>中描述了Future类的具体实现原理。这里不再讨论，但是比较好奇的抛出的三个异常。</p>
<p>这里有一篇文章（<a href="http://www.ibm.com/developerworks/cn/java/j-jtp05236.html" target="_blank">Java 理论与实践: 处理 InterruptedException</a>）描述了InterruptedException的来源和处理方式。简单的说就是线程在执行的过程中被自己或者别人中断了。这时候为了响应中断就需要处理当前的异常。</p>
<p>对于java.lang.Thread而言，InterruptedException也是一个很诡异的问题。</p>
<p>中断一个线程Thread.<strong>interrupt()</strong>时会触发下面一种情况：
如果线程在调用 Object 类的 wait()、wait(long) 或 wait(long, int) 方法，或者该类的 join()、join(long)、join(long, int)、sleep(long) 或 sleep(long, int) 方法过程中受阻，则其中断状态将被清除，它还将收到一个 InterruptedException。</p>
<p>检测一个线程的中断状态描述是这样的Thread.<strong>interrupted()：</strong></p>
<p>测试当前线程是否已经中断。线程的<em>中断状态</em> 由该方法清除。换句话说，如果连续两次调用该方法，则第二次调用将返回 false（在第一次调用已清除了其中断状态之后，且第二次调用检验完中断状态前，当前线程再次中断的情况除外）。 </p>
<p>也就是说如果检测到一个线程已经被中断了，那么线程的使用方（挂起、等待或者正在执行）都将应该得到一个中断异常，同时将会清除异常中断状态。</p>
<p>V innerGet(long nanosTimeout) throws InterruptedException, ExecutionException, TimeoutException {
    if (!tryAcquireSharedNanos(0, nanosTimeout))
        throw new TimeoutException();
    if (getState() == CANCELLED)
        throw new CancellationException();
    if (exception != null)
        throw new ExecutionException(exception);
    return result;
}</p>
<p>上面获取任务结果的方法实现中，将在获取锁的过程中得到一个中断异常。代码java.util.concurrent.locks.AbstractQueuedSynchronizer.tryAcquireSharedNanos(int, long)描述了这种情况：
    public final boolean tryAcquireSharedNanos(int arg, long nanosTimeout) throws InterruptedException {
    if (Thread.interrupted())
        throw new InterruptedException();
    return tryAcquireShared(arg) &gt;= 0 ||
        doAcquireSharedNanos(arg, nanosTimeout);
    }</p>
<p>这里在获取锁的时候检测线程中断情况，如果被中断则清除中断位，同时抛出一个中断异常。为什么如此做？因为我们的线程在线程池中是被重复执行的，所以一旦线程被中断后并不会退出线程，而是设置中断位，等候任务队列自己处理线程，从而达到线程被重复利用的目的。有兴趣的可以参考代码java.util.concurrent.ThreadPoolExecutor.Worker.runTask(Runnable)。这里在关闭线程池时就会导致中断所有线程。</p>
<p>除了InterruptedException 异常我们还发现了一个全新的异常java.util.concurrent.TimeoutException，此异常是用来描述任务执行时间超过了期望等待时间，也许是一直没有获取到锁，也许是还没有执行完成。</p>
<p>在innerGet代码片段中我们看到，如果线程在指定的时间无法获取到锁，那么就会得到一个超时异常。这个很好理解，比如如果执行一个非常耗时的网络任务，我们不希望任务一直等待从而占用大量的资源，可能在一定时间后就会希望取消此操作。此时超时异常很好的描述了这种需求。</p>
<p>与此同时，如果取消了一个任务，那么再次从任务中获取执行结果，那么将会得到一个任务被取消的异常java.util.concurrent.CancellationException。</p>
<p>除了上述异常外，还将得到一个java.util.concurrent.ExecutionException异常，</p>
<p>这是因为我们的提交的任务java.util.concurrent.Callable在call()方法中允许抛出任何异常，另外常规的线程执行也可能抛出一个RuntimeException，所以这里简单包装了下所有异常，当作执行过程中发生的异常ExecutionException抛出。</p>
<p>以上就是整个异常体系，所有并发操作的异常都可以归结于上述几类。</p>
<p>很多情况下处理时间长度都是用<strong>java.util.concurrent.TimeUnit</strong>，这是一个枚举类型，用来描述时间长度。其中内置了一些长度的单位。其中包括纳秒、微秒、毫秒、秒、分、时、天。例如超时操作5秒，可以使用</p>
<p>Future.get(5,TimeUnit.SECONDS) 或者 Future.get(5000L,TimeUnit.MILLISECONDS)</p>
<p>当然一种单位的时间转换成另一种单位的时间也是非常方便的。另外还有线程的sleep/join以及对象的wait操作的便捷操作。
来源： <a href="[http://www.blogjava.net/xylz/archive/2011/07/12/354206.html](http://www.blogjava.net/xylz/archive/2011/07/12/354206.html)">[http://www.blogjava.net/xylz/archive/2011/07/12/354206.html](http://www.blogjava.net/xylz/archive/2011/07/12/354206.html)</a> </p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/Java_多线程/">Java_多线程</a></li><li><a href="/categories/Java&J2EE/Java_多线程/并发/">并发</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/Java_多线程/" class="label label-success">Java_多线程</a><a href="/tags/并发/" class="label label-info">并发</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:41"datetime="2014-03-07 09:54:41"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-Java_多线程-并发--深入浅出JavaConcurrency28-线程池/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-Java_多线程-并发--深入浅出JavaConcurrency28-线程池" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-java-com-jacob--jacob合并几个word文件到一个word文件/">jacob合并几个word文件到一个word文件</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:41.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-java-com-jacob--jacob合并几个word文件到一个word文件/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="jacob-word-word-">jacob合并几个word文件到一个word文件</h1>
<pre><code> 因项目需要将几个word文件合并到一个word文件，后面附项目运用的jar包jacob-1.9
</code></pre><p>jacob运用中，需要将附件内的jacob.dll放到windows/system32下</p>
<pre><code> 直接上代码：
</code></pre><p>Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>public static void main(String[] args) {  </li>
<li>List list  = new ArrayList();  </li>
<li>String file1= &quot;D:\file1.doc&quot;;  </li>
<li>String file2= &quot;D:\file2.doc&quot;;  </li>
<li>String file3= &quot;D:\file3.doc&quot;;  </li>
<li>list.add(file1);  </li>
<li>list.add(file2);  </li>
<li>list.add(file3);  </li>
<li>uniteDoc(list,&quot;d:\file.doc&quot;);  </li>
<li>}  </li>
<li>public static void uniteDoc(List fileList, String savepaths) {  </li>
<li>if (fileList.size() == 0 || fileList == null) {  </li>
<li>return;  </li>
<li>}  </li>
<li>//打开word  </li>
<li>ActiveXComponent app = new ActiveXComponent(&quot;Word.Application&quot;);//启动word  </li>
<li>try {  </li>
<li>// 设置word不可见  </li>
<li>app.setProperty(&quot;Visible&quot;, new Variant(false));  </li>
<li>//获得documents对象  </li>
<li>Object docs = app.getProperty(&quot;Documents&quot;).toDispatch();  </li>
<li>//打开第一个文件  </li>
<li>Object doc = Dispatch  </li>
<li>.invoke(  </li>
<li>(Dispatch) docs,  </li>
<li>&quot;Open&quot;,  </li>
<li>Dispatch.Method,  </li>
<li>new Object[] { (String) fileList.get(0),  </li>
<li>new Variant(false), new Variant(true) },  </li>
<li>new int[3]).toDispatch();  </li>
<li>//追加文件  </li>
<li>for (int i = 1; i &lt; fileList.size(); i++) {  </li>
<li>Dispatch.invoke(app.getProperty(&quot;Selection&quot;).toDispatch(),  </li>
<li>&quot;insertFile&quot;, Dispatch.Method, new Object[] {  </li>
<li>(String) fileList.get(i), &quot;&quot;,  </li>
<li>new Variant(false), new Variant(false),  </li>
<li>new Variant(false) }, new int[3]);  </li>
<li>}  </li>
<li>//保存新的word文件  </li>
<li>Dispatch.invoke((Dispatch) doc, &quot;SaveAs&quot;, Dispatch.Method,  </li>
<li>new Object[] { savepaths, new Variant(1) }, new int[3]);  </li>
<li>Variant f = new Variant(false);  </li>
<li>Dispatch.call((Dispatch) doc, &quot;Close&quot;, f);  </li>
<li>} catch (Exception e) {  </li>
<li>throw new RuntimeException(&quot;合并word文件出错.原因:&quot; + e);  </li>
<li>} finally {  </li>
<li>app.invoke(&quot;Quit&quot;, new Variant[] {});  </li>
<li>}  </li>
<li>}  </li>
</ol>
<p>public static void main(String[] args) {</p>
<pre><code>        List list  = new ArrayList();
        String file1= &quot;D:\\file1.doc&quot;;

        String file2= &quot;D:\\file2.doc&quot;;
        String file3= &quot;D:\\file3.doc&quot;;

        list.add(file1);
        list.add(file2);

        list.add(file3);
        uniteDoc(list,&quot;d:\\file.doc&quot;);

}
public static void uniteDoc(List fileList, String savepaths) {

    if (fileList.size() == 0 || fileList == null) {
        return;

    }
    //打开word

    ActiveXComponent app = new ActiveXComponent(&quot;Word.Application&quot;);//启动word
    try {

        // 设置word不可见
        app.setProperty(&quot;Visible&quot;, new Variant(false));

        //获得documents对象
        Object docs = app.getProperty(&quot;Documents&quot;).toDispatch();

        //打开第一个文件
        Object doc = Dispatch

            .invoke(
                    (Dispatch) docs,

                    &quot;Open&quot;,
                    Dispatch.Method,

                    new Object[] { (String) fileList.get(0),
                            new Variant(false), new Variant(true) },

                    new int[3]).toDispatch();
        //追加文件

        for (int i = 1; i &lt; fileList.size(); i++) {
            Dispatch.invoke(app.getProperty(&quot;Selection&quot;).toDispatch(),

                &quot;insertFile&quot;, Dispatch.Method, new Object[] {
                        (String) fileList.get(i), &quot;&quot;,

                        new Variant(false), new Variant(false),
                        new Variant(false) }, new int[3]);

        }
        //保存新的word文件

        Dispatch.invoke((Dispatch) doc, &quot;SaveAs&quot;, Dispatch.Method,
            new Object[] { savepaths, new Variant(1) }, new int[3]);

        Variant f = new Variant(false);
        Dispatch.call((Dispatch) doc, &quot;Close&quot;, f);

    } catch (Exception e) {
        throw new RuntimeException(&quot;合并word文件出错.原因:&quot; + e);

    } finally {
        app.invoke(&quot;Quit&quot;, new Variant[] {});

    }
}
</code></pre>
      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/java-com/">java-com</a></li><li><a href="/categories/Java&J2EE/java-com/jacob/">jacob</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/jacob/" class="label label-success">jacob</a><a href="/tags/java-com/" class="label label-info">java-com</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:41"datetime="2014-03-07 09:54:41"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-java-com-jacob--jacob合并几个word文件到一个word文件/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-java-com-jacob--jacob合并几个word文件到一个word文件" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>





<ul id="pagination" class="pagination pagination-lg">
  <li><a class="extend prev" href="/page/62/">&laquo;</a></li><li><a class="page-number" href="/">1</a></li><li><a class="page-number" href="/page/2/">2</a></li><li><span class="space">&hellip;</span></li><li><a class="page-number" href="/page/60/">60</a></li><li><a class="page-number" href="/page/61/">61</a></li><li><a class="page-number" href="/page/62/">62</a></li><li class="active"><li><span class="page-number current">63</span></li><li><a class="page-number" href="/page/64/">64</a></li><li><a class="page-number" href="/page/65/">65</a></li><li><a class="page-number" href="/page/66/">66</a></li><li><span class="space">&hellip;</span></li></li><li><a class="page-number" href="/page/161/">161</a></li><li><a class="page-number" href="/page/162/">162</a></li><li><a class="extend next" href="/page/64/">&raquo;</a></li>
  <div class="clearfix"></div>
</ul></div><!--wapper-->
       </div><!-- ID main-col END -->
       <aside id="sidebar" class="alignright col-sx-6 col-sm-4 col-md-3 col-lg-3">
<div id="widget_search" class="widget panel panel-primary">
    <form action="//google.com/search" method="get" accept-charset="utf-8">
  <div class="input-group">
    <input class="form-control" id="searchbox" type="search" name="q" results="0" placeholder="search">
    <span class="input-group-btn">
      <button class="btn btn-default" type="submit">Go!</button>
    </span>
    <input type="hidden" name="q" value="site:itsolife.com">
  </div>
</form>
</div>

<div id="widget_category" class="widget panel panel-primary">
  <div class="panel-heading">category</div>  <div data-src='category' class='ajax_widgets'>正在加载...</div>
</div>

<div id="widget_recent_posts" class="widget panel panel-primary">
  <div class="panel-heading">recent posts</div>  <div data-src='recent_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_tagcloud" class="widget panel panel-primary">
  <div class="panel-heading">tagcloud</div>  <div data-src='tagcloud' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_latest_update_posts" class="widget panel panel-primary">
  <div class="panel-heading">最近更新</div>  <div data-src='latest_update_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_recent_comments" class="widget panel panel-primary">
  <div class="panel-heading">recent comments</div>  

<div class="list-group-item ds-recent-comments" data-num-items="6" data-show-avatars="1" data-show-time="1" data-show-title="1" data-show-admin="1" data-excerpt-length="50"></div>



</div>

</aside>
       <div class="clearfix"></div>
     </div><!-- row END -->
  </div>
  <footer id="footer" class="container">
  <div class="panel panel-info">
  <section id='footer_widget'></section>  <div class="panel-footer">
  <div id="site-info">
    <span class='author'>
  
  &copy; 2014 RobinChia
  
    &nbsp;&nbsp;</span>
  
  <span id='analytics-51la'></span><span id='analytics-google'>
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-48559895-1']);
  _gaq.push(['_trackPageview']);
  _js2load.push({src:('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'});
</script></span><span id='analytics-cnzz'>
<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_5774006'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s17.cnzz.com/stat.php%3Fid%3D5774006%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>
</span><span id='analytics-baidu'>
<script>
var _hmt = _hmt || [];
_js2load.push({src:"//hm.baidu.com/hm.js?1442f50724afc42380b51f097c43082c"});
</script>
</span>  </div>
  <div id="copyright">Site powered by <a href='http://zespia.tw/hexo/'><strong>hexo</strong></a>  update time: <em>2014-04-07 19:05:46</em></span></div>
</div>
<div class="clearfix"></div>


  </div>
  </footer>
  
        <script src="http://cdn.bootcss.com/jquery/1.10.2/jquery.min.js"></script>        
        <script src="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/js/bootstrap.min.js"></script>        
                
        <script src="http://cdn.bootcss.com/prettify/r298/prettify.min.js"></script>    <script type="text/javascript">
   var lang=["bsh", "c", "cc", "cpp", "cs", "csh", "cyc", "cv", "htm", "html",
    "java", "js", "m", "mxml", "perl", "pl", "pm", "py", "rb", "sh",
    "xhtml", "xml", "xsl"];
   var pretty_base='';
   $('script').each(function(){
	var c = $(this).attr('src');
	if (!c)
	    return;
	if (c.match(/(\/)?prettify(\.min)?\.js/i))
	{
	    var index = c.lastIndexOf('/');
	    if (index != -1)
		pretty_base = c.substr(0,index + 1);
	    return false;
	}
   })
   $('pre code').each(function(){
	var c = $(this).attr('class')
	if (!c)
	    return;
	c = c.match(/\s?(lang\-\w+)/i);
	if (c && lang.indexOf(c[1]) == -1)
	{
	    lang.push(c[1]);
	    $.getScript(pretty_base + c[1] + '.min.js');
	}
   })

    $(window).load(function(){
       $("pre").addClass("prettyprint");
       prettyPrint();
    })
</script>    
            <script type="text/javascript">
var duoshuoQuery = {short_name:"robinchia"};
_js2load.push({src:'http://static.duoshuo.com/embed.js',charset:'UTF-8'});
</script>
    
            <!--wumii_relatedItems-->
    
        <script src="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js"></script>    <script type="text/javascript">
(function($){
  $('.entry').each(function(i){
    $(this).find('img').each(function(){
      var alt = this.alt;

      if (alt){
        $(this).before('<span class="caption">' + alt + '</span>');
      }

      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox" rel="fancybox' + i + '" />');
    });
  });

  $('.fancybox').fancybox();
})(jQuery);
</script>    
        <script src="http://cdn.bootcss.com/mathjax/2.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>    <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>
    
<script type="text/javascript">
$('.ajax_widgets').each(function(){var src=$(this).attr('data-src');if(src)$(this).load('/widgets/'+src+'.html');});
$.each(_js2load,function(index,obj){loadjs(obj.src,obj.charset)});
</script>

<div id="scroll2top">
<img src="/scroll2top/arrow.png"/>
</div>
<script src="/scroll2top/scroll2top.min.js"></script>
<div id="winterland">
  <canvas></canvas>
</div>
<script src="/js/winterland.min.js"></script>

  </body>
</html>
