
<!DOCTYPE HTML>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>The 63 Page | It so life</title>
<meta name="author" content="RobinChia">

<meta name="description" content="It so life">


<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<meta property="og:site_name" content="It so life"/>

<!--[if IE]><style>.testIE.IE{display:inline;}</style><![endif]-->
<!--[if lte IE 7]><link rel="stylesheet" href="/css/ie7.css" type="text/css"><![endif]-->
<!--[if (lt IE 9)&(gt IE 7)]><style>.testIE.IE8{display:inline;}</style><![endif]-->
<!--[if gt IE 8]><style>.testIE.IE9{display:inline;}</style><![endif]-->

<link href="/favicon.png" rel="icon">
<link rel="alternate" href="/atom.xml" title="It so life Feed" type="application/atom+xml">

<link rel="stylesheet" href="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/css/bootstrap.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/font-awesome/4.0.3/css/font-awesome.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/prettify/r298/prettify.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" type="text/css">
<link rel="stylesheet" href="/css/style.css" type="text/css">
<!--[if lt IE 9]>
   <style>article,aside,dialog,footer,header,section,footer,nav,figure,menu{display:block}</style>
   <script src="http://cdn.staticfile.org/html5shiv/r29/html5.min.js"></script>
   <script src="http://cdn.staticfile.org/respond.js/1.4.2/respond.min.js"></script>
<link href="http://cdn.staticfile.org/respond.js/1.4.2/respond-proxy.html" id="respond-proxy" rel="respond-proxy" />
<link href="/js/respond.proxy.gif" id="respond-redirect" rel="respond-redirect" />
<script src="/js/respond.proxy.js"></script>
   <script src="http://cdn.bootcss.com/selectivizr/1.0.2/selectivizr-min.js"></script>
<![endif]-->
<script type="text/javascript">
function loadjs(c,d){var a=document.createElement("script");a.async=!0;a.type="text/javascript";a.src=c;a.charset=d||"gbk";(document.getElementsByTagName("HEAD")[0]||document.getElementsByTagName("BODY")[0]).appendChild(a)};
var _protocol = (("https:" == document.location.protocol) ? " https://" : " http://");
var _js2load = [];
</script>

</head>
<body>
      <header id="header" class="container"><nav id="main-nav" class="navbar navbar-default navbar-fixed-top " role="navigation">
  <div class="container">
    <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
      <span class="sr-only">Toggle navigation</span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="/">It so life</a>
    </div>
    <div  class="collapse navbar-collapse">
      <ul  class="nav navbar-nav">
  
        <li><a href="/" title="Home">Home</a></li>      
        <li><a href="/about/" title="About">About</a></li>      
        <li><a href="/archives/" title="Archives">Archives</a></li>      
      <li class='dropdown'>
        <a class='dropdown-toggle' data-toggle='dropdown' href='#'>website<b class='caret'></b></a>
        <ul class='dropdown-menu pure-menu-selected'>
    
          <li><a href="//groups.google.com/forum/#!forum/pongba" title="TopLanguage">TopLanguage</a></li>    
          <li><a href="//itpub.net/" title="ITPub">ITPub</a></li>    
          <li><a href="//blog.jobbole.com/" title="Bole">Bole</a></li>    
          <li><a href="//nosql-database.org/" title="nosql">nosql</a></li>    
          <li><a href="//gitimmersion.googol.im/" title="Git">Git</a></li>    
        </ul>
      </li>
    
      </ul>
      <ul class="nav navbar-nav navbar-right">
      
        <li><a href="/atom.xml">RSS</a></li>
      
      
        <li><a href="https://twitter.com/robinchia">twitter</a></li>
      
      
      
      
        <li><a href="https://github.com/robinchia">github</a></li>
      
      </ul>
    </div>
  </div>
</nav>
<div class="clearfix"></div>
</header>
  <div id='content' class="container">
     <div class="page-header-wrapper">
      <!--[if lt IE 9]><div class="alert alert-warning alert-dismissable"><button type="button" class="close" data-dismiss="alert" aria-hidden="true">&times;</button><strong>提示:</strong>您的浏览器版本太低了,建议升级到 <strong><a href="http://windows.microsoft.com/zh-cn/internet-explorer/download-ie" title="IE9">IE9</a></strong> 以上,本站使用<a href="https://www.google.com/intl/zh-CN/chrome/">Chrome浏览器</a>可以获得最好的显示效果.</div><![endif]-->
      <div class="page-header"><h1 align="center"><big>It so life</big> </h1>
        <h5 align="center"><big>love as life</big></h5>
      </div>
     </div>
     <div class="row">
       <div id="main-col" class="alignleft col-sx-12 col-sm-8 col-md-9 col-lg-9">
      <section id='header_widget'></section>
          <div id="wrapper"><article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-java深入分析--线性表分析及Java实现/">线性表分析及Java实现</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:41.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-java深入分析--线性表分析及Java实现/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-java-">线性表分析及Java实现</h1>
<p><strong><a href="http://java-mzd.iteye.com/blog/826059" target="_blank">线性表分析及Java实现</a></strong></p>
<p><strong>文章分类**</strong>:<a href="http://www.iteye.com/blogs/category/tech" target="_blank">综合技术</a>**</p>
<pre><code>  数据结构中的线性表，对应着Collection中的List接口。

  在本节中，我们将做以下三件事

        第一。我们先来看看线性表的特征

        第二，自己用JAVA实现List

        第三，对比的线性表、链式表性能，以及自己的List性能与JDKList性能对比



** ****线性表特征：**** **

        第一，一个特定的线性表，应该是用来存放特定的某一个类型的元素的（元素的“同一性”）

        第二， 除第一个元素外，其他每一个元素有且仅有一个直接前驱；除最后一个元素外，其他每一个元素有且仅有一个             直接后继（元素的“序偶性”）

        第二， 元素在线性表中的“下标”唯一地确定该元素在表中的相对位置（元素的“索引性”）

   又，一.线性表只是数据的一种逻辑结构，其具体存储结构可以为顺序存储结构和链式储存结构来完成，对应可以得到顺序表和链表，

        二.对线性表的入表和出表顺序做一定的限定，可以得到特殊的线性表，栈(FILO)和队列（FIFO）
</code></pre><p><strong>   **</strong>自己实现线性表之顺序表**</p>
<pre><code>         思路：

            1. 顺序表因为采用顺序存储形式，所以内部使用数组来存储数据

            2.因为存储的具体对象类型不一定，所以采用泛型操作

            3.数组操作优点：1.通过指针快速定位到下表，查询快速

                           缺点：1.数组声明时即需要确定数组大小。当操作中超过容量时，则需要重新声明数组，并且复制当前所有数据

                                    2.当需要在中间进行插入或者删除时，则需要移动大量元素（size-index个）
</code></pre><p>  具体实现代码如下</p>
<p><strong>Java**</strong>代码<strong><strong> </strong></strong> <strong>[</strong><img src="&quot;&quot;收藏这段代码&quot; &quot;" alt="收藏代码]()**"><em>**</em></p>
<ol>
<li><p>//<em>/</em> </p>
</li>
<li><p>/* 自己用数组实现的线性表 </p>
</li>
<li><p>/*/  </p>
</li>
<li><p><strong>public</strong> <strong>class</strong> ArrayList<E> {  </p>
</li>
<li><p>Object[] data = <strong>null</strong>;// 用来保存此队列中内容的数组  </p>
</li>
<li><p><strong>int</strong> current;// 保存当前为第几个元素的指标  </p>
</li>
<li><p><strong>int</strong> capacity;// 表示数组大小的指标  </p>
</li>
<li></li>
<li><p>//<em>/</em> </p>
</li>
<li><p>/* 如果初始化时，未声明大小，则默认为10 </p>
</li>
<li><p>/*/  </p>
</li>
<li><p><strong>public</strong> ArrayList() {  </p>
</li>
<li><p><strong>this</strong>(10);  </p>
</li>
<li><p>}  </p>
</li>
<li></li>
<li><p>//<em>/</em> </p>
</li>
<li><p>/* 初始化线性表，并且声明保存内容的数组大小 </p>
</li>
<li><p>/* @param initalSize </p>
</li>
<li><p>/*/  </p>
</li>
<li><p><strong>public</strong> ArrayList(<strong>int</strong> initalSize) {  </p>
</li>
<li><p><strong>if</strong> (initalSize &lt; 0) {  </p>
</li>
<li><p><strong>throw</strong> <strong>new</strong> RuntimeException(&quot;数组大小错误:&quot; + initalSize);  </p>
</li>
<li><p>} <strong>else</strong> {  </p>
</li>
<li><p><strong>this</strong>.data = <strong>new</strong> Object[initalSize];  </p>
</li>
<li><p><strong>this</strong>.current = 0;  </p>
</li>
<li><p>capacity = initalSize;  </p>
</li>
<li><p>}  </p>
</li>
<li><p>}  </p>
</li>
<li></li>
<li><p>//<em>/</em> </p>
</li>
<li><p>/* 添加元素的方法 添加前，先确认是否已经满了 </p>
</li>
<li><p>/* @param e </p>
</li>
<li><p>/* @return </p>
</li>
<li><p>/*/  </p>
</li>
<li><p><strong>public</strong> <strong>boolean</strong> add(E e) {  </p>
</li>
<li><p>ensureCapacity(current);// 确认容量  </p>
</li>
<li><p><strong>this</strong>.data[current] = e;  </p>
</li>
<li><p>current++;  </p>
</li>
<li><p><strong>return</strong> <strong>true</strong>;  </p>
</li>
<li><p>}  </p>
</li>
<li></li>
<li><p>//<em>/</em> </p>
</li>
<li><p>/* 确认系统当前容量是否满足需要,如果满足，则不执行操作 如果不满足，增加容量 </p>
</li>
<li><p>/* @param cur 当前个数 </p>
</li>
<li><p>/*/  </p>
</li>
<li><p><strong>private</strong> <strong>void</strong> ensureCapacity(<strong>int</strong> cur) {  </p>
</li>
<li><p><strong>if</strong> (cur == capacity) {  </p>
</li>
<li><p>// 如果达到容量极限，增加10的容量，复制当前数组  </p>
</li>
<li><p><strong>this</strong>.capacity = <strong>this</strong>.capacity + 10;  </p>
</li>
<li><p>Object[] newdata = <strong>new</strong> Object[capacity];  </p>
</li>
<li><p><strong>for</strong> (<strong>int</strong> i = 0; i &lt; cur; i++) {  </p>
</li>
<li><p>newdata[i] = <strong>this</strong>.data[i];  </p>
</li>
<li><p>}  </p>
</li>
<li><p><strong>this</strong>.data = newdata;  </p>
</li>
<li><p>}  </p>
</li>
<li><p>}  </p>
</li>
<li></li>
<li><p>//<em>/</em> </p>
</li>
<li><p>/* 得到指定下标的数据 </p>
</li>
<li><p>/* @param index </p>
</li>
<li><p>/* @return </p>
</li>
<li><p>/*/  </p>
</li>
<li><p><strong>public</strong> E get(<strong>int</strong> index) {  </p>
</li>
<li><p>validateIndex(index);  </p>
</li>
<li><p><strong>return</strong> (E) <strong>this</strong>.data[index];  </p>
</li>
<li><p>}  </p>
</li>
<li></li>
<li><p>//<em>/</em> </p>
</li>
<li><p>/* 返回当前队列大小 </p>
</li>
<li><p>/* @return </p>
</li>
<li><p>/*/  </p>
</li>
<li><p><strong>public</strong> <strong>int</strong> size() {  </p>
</li>
<li><p><strong>return</strong> <strong>this</strong>.current;  </p>
</li>
<li><p>}  </p>
</li>
<li></li>
<li><p>//<em>/</em> </p>
</li>
<li><p>/* 更改指定下标元素的数据为e </p>
</li>
<li><p>/* @param index  </p>
</li>
<li><p>/* @param e </p>
</li>
<li><p>/* @return </p>
</li>
<li><p>/*/  </p>
</li>
<li><p><strong>public</strong> <strong>boolean</strong> set(<strong>int</strong> index, E e) {  </p>
</li>
<li><p>validateIndex(index);  </p>
</li>
<li><p><strong>this</strong>.data[index] = e;  </p>
</li>
<li><p><strong>return</strong> <strong>true</strong>;  </p>
</li>
<li><p>}  </p>
</li>
<li></li>
<li><p>//<em>/</em> </p>
</li>
<li><p>/*  验证当前下标是否合法，如果不合法，抛出运行时异常 </p>
</li>
<li><p>/* @param index 下标 </p>
</li>
<li><p>/*/  </p>
</li>
<li><p><strong>private</strong> <strong>void</strong> validateIndex(<strong>int</strong> index) {  </p>
</li>
<li><p><strong>if</strong> (index &lt; 0 || index &gt; current) {  </p>
</li>
<li><p><strong>throw</strong> <strong>new</strong> RuntimeException(&quot;数组index错误：&quot; + index);  </p>
</li>
<li><p>}  </p>
</li>
<li><p>}  </p>
</li>
<li></li>
<li><p>//<em>/</em> </p>
</li>
<li><p>/* 在指定下标位置处插入数据e </p>
</li>
<li><p>/* @param index 下标 </p>
</li>
<li><p>/* @param e 需要插入的数据 </p>
</li>
<li><p>/* @return  </p>
</li>
<li><p>/*/  </p>
</li>
<li><p><strong>public</strong> <strong>boolean</strong> insert(<strong>int</strong> index, E e) {  </p>
</li>
<li><p>validateIndex(index);  </p>
</li>
<li><p>Object[] tem = <strong>new</strong> Object[capacity];// 用一个临时数组作为备份  </p>
</li>
<li><p>//开始备份数组  </p>
</li>
<li><p><strong>for</strong> (<strong>int</strong> i = 0; i &lt; current; i++) {  </p>
</li>
<li><p><strong>if</strong> (i &lt; index) {  </p>
</li>
<li><p>tem[i] = <strong>this</strong>.data[i];  </p>
</li>
<li><p>}<strong>else</strong> <strong>if</strong>(i==index){  </p>
</li>
<li><p>tem[i]=e;  </p>
</li>
<li><p>}<strong>else</strong> <strong>if</strong>(i&gt;index){  </p>
</li>
<li><p>tem[i]=<strong>this</strong>.data[i-1];  </p>
</li>
<li><p>}  </p>
</li>
<li><p>}  </p>
</li>
<li><p><strong>this</strong>.data=tem;  </p>
</li>
<li><p><strong>return</strong> <strong>true</strong>;  </p>
</li>
<li><p>}  </p>
</li>
<li><p><br><br>//<em>/</em><br>  /<em> 删除指定下标出的数据<br>    /</em> @param index<br>  /<em> @return<br>   /</em>/<br> <strong>public</strong> <strong>boolean</strong> delete(<strong>int</strong> index){<br>       validateIndex(index);<br>       Object[] tem = <strong>new</strong> Object[capacity];// 用一个临时数组作为备份<br>      //开始备份数组<br>        for (int i = 0; i &lt; current; i++) {<br>          if (i &lt; index) {<br>             tem[i] = this.data[i];<br>          }else if(i==index){<br>             tem[i]=this.data[i+1];<br>          }else if(i&gt;index){<br>               tem[i]=this.data[i+1];<br>          }<br>       }<br>       this.data=tem;<br>      return true;<br>    }<br><br>}  </p>
</li>
</ol>
<p>  <strong> **</strong>自己实现线性表之链表**</p>
<pre><code>     思路：1.链表采用链式存储结构，在内部只需要将一个一个结点链接起来。（每个结点中有关于此结点下一个结点的引用）

     链表操作优点：1.，因为每个结点记录下个结点的引用，则在进行插入和删除操作时，只需要改变对应下标下结点的引用即可

                 缺点：1.要得到某个下标的数据，不能通过下标直接得到，需要遍历整个链表。
</code></pre><p>  实现代码如下</p>
<p><strong>Java**</strong>代码<strong><strong> </strong></strong> <strong>[</strong><img src="&quot;&quot;收藏这段代码&quot; &quot;" alt="收藏代码]()**"><em>**</em></p>
<ol>
<li><p>//<em>/</em> </p>
</li>
<li><p>/* 自己用链式存储实现的线性表 </p>
</li>
<li><p>/*/  </p>
</li>
<li><p><strong>public</strong> <strong>class</strong> LinkedList<E> {  </p>
</li>
<li></li>
<li><p><strong>private</strong> Node<E> header = <strong>null</strong>;// 头结点  </p>
</li>
<li><p><strong>int</strong> size = 0;// 表示数组大小的指标  </p>
</li>
<li></li>
<li><p><strong>public</strong> LinkedList() {  </p>
</li>
<li><p><strong>this</strong>.header = <strong>new</strong> Node<E>();  </p>
</li>
<li><p>}  </p>
</li>
<li></li>
<li><p><strong>public</strong> <strong>boolean</strong> add(E e) {  </p>
</li>
<li><p><strong>if</strong> (size == 0) {  </p>
</li>
<li><p>header.e = e;  </p>
</li>
<li><p>} <strong>else</strong> {  </p>
</li>
<li><p>// 根据需要添加的内容，封装为结点  </p>
</li>
<li><p>Node<E> newNode = <strong>new</strong> Node<E>(e);  </p>
</li>
<li><p>// 得到当前最后一个结点  </p>
</li>
<li><p>Node<E> last = getNode(size-1);  </p>
</li>
<li><p>// 在最后一个结点后加上新结点  </p>
</li>
<li><p>last.addNext(newNode);  </p>
</li>
<li><p>}  </p>
</li>
<li><p>size++;// 当前大小自增加1  </p>
</li>
<li><p><strong>return</strong> <strong>true</strong>;  </p>
</li>
<li><p>}  </p>
</li>
<li></li>
<li><p><strong>public</strong> <strong>boolean</strong> insert(<strong>int</strong> index, E e) {  </p>
</li>
<li><p>Node<E> newNode = <strong>new</strong> Node<E>(e);  </p>
</li>
<li><p>// 得到第N个结点  </p>
</li>
<li><p>Node<E> cNode = getNode(index);  </p>
</li>
<li><p>newNode.next = cNode.next;  </p>
</li>
<li><p>cNode.next = newNode;  </p>
</li>
<li><p>size++;  </p>
</li>
<li><p><strong>return</strong> <strong>true</strong>;  </p>
</li>
<li></li>
<li><p>}  </p>
</li>
<li></li>
<li><p>//<em>/</em> </p>
</li>
<li><p>/* 遍历当前链表，取得当前索引对应的元素 </p>
</li>
<li><p>/*  </p>
</li>
<li><p>/* @return </p>
</li>
<li><p>/*/  </p>
</li>
<li><p><strong>private</strong> Node<E> getNode(<strong>int</strong> index) {  </p>
</li>
<li><p>// 先判断索引正确性  </p>
</li>
<li><p><strong>if</strong> (index &gt; size || index &lt; 0) {  </p>
</li>
<li><p><strong>throw</strong> <strong>new</strong> RuntimeException(&quot;索引值有错：&quot; + index);  </p>
</li>
<li><p>}  </p>
</li>
<li><p>Node<E> tem = <strong>new</strong> Node<E>();  </p>
</li>
<li><p>tem = header;  </p>
</li>
<li><p><strong>int</strong> count = 0;  </p>
</li>
<li><p><strong>while</strong> (count != index) {  </p>
</li>
<li><p>tem = tem.next;  </p>
</li>
<li><p>count++;  </p>
</li>
<li><p>}  </p>
</li>
<li><p><strong>return</strong> tem;  </p>
</li>
<li><p>}  </p>
</li>
<li></li>
<li><p>//<em>/</em> </p>
</li>
<li><p>/* 根据索引，取得该索引下的数据 </p>
</li>
<li><p>/*  </p>
</li>
<li><p>/* @param index </p>
</li>
<li><p>/* @return </p>
</li>
<li><p>/*/  </p>
</li>
<li><p><strong>public</strong> E get(<strong>int</strong> index) {  </p>
</li>
<li><p>// 先判断索引正确性  </p>
</li>
<li><p><strong>if</strong> (index &gt;= size || index &lt; 0) {  </p>
</li>
<li><p><strong>throw</strong> <strong>new</strong> RuntimeException(&quot;索引值有错：&quot; + index);  </p>
</li>
<li><p>}  </p>
</li>
<li><p>Node<E> tem = <strong>new</strong> Node<E>();  </p>
</li>
<li><p>tem = header;  </p>
</li>
<li><p><strong>int</strong> count = 0;  </p>
</li>
<li><p><strong>while</strong> (count != index) {  </p>
</li>
<li><p>tem = tem.next;  </p>
</li>
<li><p>count++;  </p>
</li>
<li><p>}  </p>
</li>
<li><p>E e = tem.e;  </p>
</li>
<li><p><strong>return</strong> e;  </p>
</li>
<li><p>}  </p>
</li>
<li></li>
<li><p><strong>public</strong> <strong>int</strong> size() {  </p>
</li>
<li><p><strong>return</strong> size;  </p>
</li>
<li><p>}  </p>
</li>
<li></li>
<li><p>//<em>/</em> </p>
</li>
<li><p>/* 设置第N个结点的值 </p>
</li>
<li><p>/*  </p>
</li>
<li><p>/* @param x </p>
</li>
<li><p>/* @param e </p>
</li>
<li><p>/* @return </p>
</li>
<li><p>/*/  </p>
</li>
<li><p><strong>public</strong> <strong>boolean</strong> set(<strong>int</strong> index, E e) {  </p>
</li>
<li><p>// 先判断索引正确性  </p>
</li>
<li><p><strong>if</strong> (index &gt; size || index &lt; 0) {  </p>
</li>
<li><p><strong>throw</strong> <strong>new</strong> RuntimeException(&quot;索引值有错：&quot; + index);  </p>
</li>
<li><p>}  </p>
</li>
<li><p>Node<E> newNode = <strong>new</strong> Node<E>(e);  </p>
</li>
<li><p>// 得到第x个结点  </p>
</li>
<li><p>Node<E> cNode = getNode(index);  </p>
</li>
<li><p>cNode.e = e;  </p>
</li>
<li><p><strong>return</strong> <strong>true</strong>;  </p>
</li>
<li><p>}  </p>
</li>
<li></li>
<li><p>//<em>/</em> </p>
</li>
<li><p>/* 用来存放数据的结点型内部类 </p>
</li>
<li><p>/*/  </p>
</li>
<li><p><strong>class</strong> Node<e> {  </p>
</li>
<li><p><strong>private</strong> E e;// 结点中存放的数据  </p>
</li>
<li></li>
<li><p>Node() {  </p>
</li>
<li><p>}  </p>
</li>
<li></li>
<li><p>Node(E e) {  </p>
</li>
<li><p><strong>this</strong>.e = e;  </p>
</li>
<li><p>}  </p>
</li>
<li></li>
<li><p>Node<E> next;// 用来指向该结点的下一个结点  </p>
</li>
<li></li>
<li><p>// 在此结点后加一个结点  </p>
</li>
<li><p><strong>void</strong> addNext(Node<E> node) {  </p>
</li>
<li><p>next = node;  </p>
</li>
<li><p>}  </p>
</li>
<li><p>}  </p>
</li>
<li></li>
<li><p>}  </p>
</li>
</ol>
<p><strong>自己实现线性表之栈</strong></p>
<pre><code>     栈是限定仅允许在表的同一端（通常为“表尾”）进行插入或删除操作的线性表。

     允许插入和删除的一端称为栈顶(top)，另一端称为栈底(base)
     特点：后进先出 (LIFO)或，先进后出（FILO）



     因为栈是限定线的线性表，所以，我们可以调用前面两种线性表，只需要对出栈和入栈操作进行设定即可

具体实现代码
</code></pre><p><strong>Java**</strong>代码<strong><strong> </strong></strong> <strong>[</strong><img src="&quot;&quot;收藏这段代码&quot; &quot;" alt="收藏代码]()**"><em>**</em></p>
<ol>
<li><p>//<em>/</em> </p>
</li>
<li><p>/* 自己用数组实现的栈 </p>
</li>
<li><p>/*/  </p>
</li>
<li><p><strong>public</strong> <strong>class</strong> ArrayStack<E> {  </p>
</li>
<li><p><strong>private</strong> ArrayList<E> list=<strong>new</strong> ArrayList<E>();//用来保存数据线性表<br>    private  int size;//表示当前栈元素个数  </p>
</li>
<li><p>//<em>/</em> </p>
</li>
<li><p>/* 入栈操作 </p>
</li>
<li><p>/* @param e </p>
</li>
<li><p>/*/  </p>
</li>
<li><p><strong>public</strong> <strong>void</strong> push(E e){  </p>
</li>
<li><p>list.add(e);  </p>
</li>
<li><p>size++;  </p>
</li>
<li><p>}  </p>
</li>
<li></li>
<li><p>//<em>/</em> </p>
</li>
<li><p>/* 出栈操作 </p>
</li>
<li><p>/* @return </p>
</li>
<li><p>/*/  </p>
</li>
<li><p><strong>public</strong> E pop(){  </p>
</li>
<li><p>E e= list.get(size-1);  </p>
</li>
<li><p>size--;  </p>
</li>
<li><p><strong>return</strong> e;  </p>
</li>
<li><p>}  </p>
</li>
<li></li>
<li><p>}  </p>
</li>
</ol>
<p> 至于用链表实现栈，则只需要把保存数据的顺序表改成链表即可，此处就不给出代码了</p>
<p><strong>自己实现线性表之队列</strong></p>
<pre><code>    与栈类似

    队列是只允许在表的一端进行插入，而在另一端删除元素的线性表。

    在队列中，允许插入的一端叫队尾（rear），允许删除的一端称为队头(front)。
    特点：先进先出 (FIFO)、后进后出 (LILO)



   同理，我们也可以调用前面两种线性表，只需要对队列的入队和出队方式进行处理即可
</code></pre><p><strong>Java**</strong>代码<strong><strong> </strong></strong> <strong>[</strong><img src="&quot;&quot;收藏这段代码&quot; &quot;" alt="收藏代码]()**"><em>**</em></p>
<ol>
<li><p><strong>package</strong> cn.javamzd.collection.List;  </p>
</li>
<li></li>
<li><p>//<em>/</em> </p>
</li>
<li><p>/* 用数组实现的队列 </p>
</li>
<li><p>/*/  </p>
</li>
<li><p><strong>public</strong> <strong>class</strong> ArrayQueue<E> {  </p>
</li>
<li><p><strong>private</strong> ArrayList<E> list = <strong>new</strong> ArrayList<E>();// 用来保存数据的队列  </p>
</li>
<li><p><strong>private</strong> <strong>int</strong> size;// 表示当前栈元素个数  </p>
</li>
<li></li>
<li><p>//<em>/</em> </p>
</li>
<li><p>/* 入队 </p>
</li>
<li><p>/* @param e </p>
</li>
<li><p>/*/  </p>
</li>
<li><p><strong>public</strong> <strong>void</strong> EnQueue(E e) {  </p>
</li>
<li><p>list.add(e);  </p>
</li>
<li><p>size++;  </p>
</li>
<li><p>}  </p>
</li>
<li></li>
<li><p>//<em>/</em> </p>
</li>
<li><p>/* 出队 </p>
</li>
<li><p>/* @return </p>
</li>
<li><p>/*/  </p>
</li>
<li><p><strong>public</strong> E DeQueue() {  </p>
</li>
<li><p><strong>if</strong> (size &gt; 0) {  </p>
</li>
<li><p>E e = list.get(0);  </p>
</li>
<li><p>list.delete(0);  </p>
</li>
<li><p><strong>return</strong> e;  </p>
</li>
<li><p>}<strong>else</strong>{  </p>
</li>
<li><p><strong>throw</strong> <strong>new</strong> RuntimeException(&quot;已经到达队列顶部&quot;);  </p>
</li>
<li><p>}  </p>
</li>
<li><p>}  </p>
</li>
<li><p>}  </p>
</li>
</ol>
<p><strong>对比线性表和链式表</strong>
         前面已经说过顺序表和链式表各自的特点，这里在重申一遍</p>
<pre><code>     数组操作优点：1.通过指针快速定位到下标，查询快速

                 缺点：1.数组声明时即需要确定数组大小。当操作中超过容量时，则需要重新声明数组，并且复制当前所有数据

                          2.当需要在中间进行插入或者删除时，则需要移动大量元素（size-index个）    





     链表操作优点：1.，因为每个结点记录下个结点的引用，则在进行插入和删除操作时，只需要改变对应下标下结点的引用即可

                 缺点：1.要得到某个下标的数据，不能通过下标直接得到，需要遍历整个链表。



     现在，我们通过进行增删改查操作来感受一次其效率的差异

     **思路**：通过两个表，各进行大数据量操作（2W）条数据的操作，记录操作前系统时间，操作后系统时间，得出操作时间
</code></pre><p>  实现代码如下</p>
<p><strong>Java**</strong>代码<strong><strong> </strong></strong> <strong>[</strong><img src="&quot;&quot;收藏这段代码&quot; &quot;" alt="收藏代码]()**"><em>**</em></p>
<ol>
<li><p><strong>package</strong> cn.javamzd.collection.List;  </p>
</li>
<li></li>
<li><p><strong>public</strong> <strong>class</strong> Test {  </p>
</li>
<li></li>
<li><p>//<em>/</em> </p>
</li>
<li><p>/* @param args </p>
</li>
<li><p>/*/  </p>
</li>
<li><p><strong>public</strong> <strong>static</strong> <strong>void</strong> main(String[] args) {  </p>
</li>
<li><p>//测试自己实现的ArrayList类和Linkedlist类添加20000个数据所需要的时间  </p>
</li>
<li><p>ArrayList<String> al = <strong>new</strong> ArrayList<String>();  </p>
</li>
<li><p>LinkedList<String> ll = <strong>new</strong> LinkedList<String>();  </p>
</li>
<li><p>Long aBeginTime=System.currentTimeMillis();//记录BeginTime  </p>
</li>
<li><p><strong>for</strong>(<strong>int</strong> i=0;i&lt;30000;i++){  </p>
</li>
<li><p>al.add(&quot;now&quot;+i);  </p>
</li>
<li><p>}  </p>
</li>
<li><p>Long aEndTime=System.currentTimeMillis();//记录EndTime  </p>
</li>
<li><p>System.out.println(&quot;arrylist  add time---&gt;&quot;+(aEndTime-aBeginTime));  </p>
</li>
<li><p>Long lBeginTime=System.currentTimeMillis();//记录BeginTime  </p>
</li>
<li><p><strong>for</strong>(<strong>int</strong> i=0;i&lt;30000;i++){  </p>
</li>
<li><p>ll.add(&quot;now&quot;+i);  </p>
</li>
<li><p>}  </p>
</li>
<li><p>Long lEndTime=System.currentTimeMillis();//记录EndTime  </p>
</li>
<li><p>System.out.println(&quot;linkedList add time----&gt;&quot;+(lEndTime-lBeginTime));  </p>
</li>
<li></li>
<li><p>//测试JDK提供的ArrayList类和LinkedList类添加20000个数据所需要的世界  </p>
</li>
<li><p>java.util.ArrayList<String> sal=<strong>new</strong> java.util.ArrayList<String>();  </p>
</li>
<li><p>java.util.LinkedList<String> sll=<strong>new</strong> java.util.LinkedList<String>();  </p>
</li>
<li><p>Long saBeginTime=System.currentTimeMillis();//记录BeginTime  </p>
</li>
<li><p><strong>for</strong>(<strong>int</strong> i=0;i&lt;30000;i++){  </p>
</li>
<li><p>sal.add(&quot;now&quot;+i);  </p>
</li>
<li><p>}  </p>
</li>
<li><p>Long saEndTime=System.currentTimeMillis();//记录EndTime  </p>
</li>
<li><p>System.out.println(&quot;JDK arrylist  add time---&gt;&quot;+(saEndTime-saBeginTime));  </p>
</li>
<li><p>Long slBeginTime=System.currentTimeMillis();//记录BeginTime  </p>
</li>
<li><p><strong>for</strong>(<strong>int</strong> i=0;i&lt;30000;i++){  </p>
</li>
<li><p>sll.add(&quot;now&quot;+i);  </p>
</li>
<li><p>}  </p>
</li>
<li><p>Long slEndTime=System.currentTimeMillis();//记录EndTime  </p>
</li>
<li><p>System.out.println(&quot;JDK linkedList add time----&gt;&quot;+(slEndTime-slBeginTime));  </p>
</li>
<li><p>}  </p>
</li>
<li></li>
<li><p>}  </p>
<p>得到测试结果如下： </p>
</li>
</ol>
<p>arrylist add time---&gt;446
linkedList add time----&gt;9767
JDK arrylist add time---&gt;13
JDK linkedList add time----&gt;12</p>
<pre><code>    由以上数据，我们可知：
</code></pre><p><strong>           1.JDK**</strong>中的<strong><strong>ArrayList</strong></strong>何<strong><strong>LinkedList</strong></strong>在添加数据时的性能，其实几乎是没有差异的**</p>
<pre><code>       2.我们自己写的List的性能和JDK提供的List的性能还是存在巨大差异的

       3.我们使用链表添加操作，花费的时间是巨大的，比ArrayList都大几十倍



  第三条显然是跟我们最初的设计不相符的，按照我们最初的设想，链表的添加应该比顺序表更省时

  查看我们写的源码，可以发现：

  我们每次添加一个数据时，都需要遍历整个表，得到表尾，再在表尾添加，这是很不科学的



 ** ****现改进如下**：设立一个Node&lt;E&gt;类的成员变量end来指示表尾，这样每次添加时，就不需要再重新遍历得到表尾

  改进后add()方法如下
</code></pre><p><strong>Java**</strong>代码<strong><strong> </strong></strong> <strong>[</strong><img src="&quot;&quot;收藏这段代码&quot; &quot;" alt="收藏代码]()**"><em>**</em></p>
<ol>
<li><p><strong>public</strong> <strong>boolean</strong> add(E e) {  </p>
</li>
<li><p><strong>if</strong> (size == 0) {  </p>
</li>
<li><p>header.e = e;  </p>
</li>
<li><p>} <strong>else</strong> {  </p>
</li>
<li><p>// 根据需要添加的内容，封装为结点  </p>
</li>
<li><p>Node<E> newNode = <strong>new</strong> Node<E>(e);  </p>
</li>
<li><p>//在表尾添加元素  </p>
</li>
<li><p>last.addNext(newNode);  </p>
</li>
<li><p>//将表尾指向当前最后一个元素  </p>
</li>
<li><p>last = newNode;  </p>
</li>
<li><p>}  </p>
</li>
<li><p>size++;// 当前大小自增加1  </p>
</li>
<li><p><strong>return</strong> <strong>true</strong>;  </p>
</li>
<li><p>}  </p>
</li>
</ol>
<pre><code>   ArrayList添加的效率和JDK中对比起来也太低

   分析原因为：

   每次扩大容量时，扩大量太小，需要进行的复制操作太多

   现在改进如下：

   每次扩大，则扩大容量为当前的三倍，此改进仅需要更改ensureCapacity()方法中的一行代码，此处就不列出了。
</code></pre><p>改进后，再次运行添加元素测试代码，结果如下：</p>
<p>arrylist add time---&gt;16
linkedList add time----&gt;8
JDK arrylist add time---&gt;7
JDK linkedList add time----&gt;7</p>
<p> 虽然还有改进的空间，但是显然，我们的效果已经大幅度改进了，而且也比较接近JDK了</p>
<p>接下来测试插入操作的效率</p>
<p>  我们只需要将测试代码中的添加方法(add())改成插入方法(insert(int index,E e)),为了使插入次数尽可能多，我们把index都设置为0</p>
<p>测试结果如下：</p>
<p>arrylist inset time---&gt;17
linkedList inset time----&gt;13
JDK arrylist inset time---&gt;503
JDK linkedList inset time----&gt;11</p>
<p><strong>多次测试，发现我们写的**</strong>ArrayList<strong><strong>在插入方法的效率都已经超过</strong></strong>JDK<strong><strong>了，而且也接近</strong></strong>LinkedLst<strong>**了。撒花！！！</strong></p>
<p>接下来测试删除、得到下标等等操作就不一一列出来了（只需要改变每次调用的方法即可）</p>
<p>恩，本来想今晚把所有的集合框架实现都写一下的</p>
<p>但是不知不觉这都又2点了</p>
<p>明早还得去蓝杰上课</p>
<p>果断先睡吧</p>
<p>敬请大家期待我明日大作------------静态/动态查找表的实现，动态查找表查找/加入算法的JAVA实现，Hash表的实现</p>
<p>good night</p>
<p>url: <a href="http://java-mzd.iteye.com/blog/826059" target="_blank">http://java-mzd.iteye.com/blog/826059</a></p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/java深入分析/">java深入分析</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/java深入分析/" class="label label-success">java深入分析</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:41"datetime="2014-03-07 09:54:41"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-java深入分析--线性表分析及Java实现/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-java深入分析--线性表分析及Java实现" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-proguard--开源混淆工具ProGuard配置详解及配置实例/">开源混淆工具ProGuard配置详解及配置实例</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:41.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-proguard--开源混淆工具ProGuard配置详解及配置实例/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-proguard-">开源混淆工具ProGuard配置详解及配置实例</h1>
<p>开源混淆工具ProGuard配置详解及配置实例</p>
<p>ProGuard是一个免费的java类文件压缩,优化,混淆器.它探测并删除没有使用的类,字段,方法和属性.它删除没有用的说明并使用字节码得到最大优化.它使用无意义的名字来重命名类,字段和方法.</p>
<p>ProGuard的作用: </p>
<p>1.创建紧凑的代码文档是为了更快的网络传输,快速装载和更小的内存占用. 
2.创建的程序和程序库很难使用反向工程. 
3.所以它能删除来自源文件中的没有调用的代码 
4.充分利用java6的快速加载的优点来提前检测和返回java6中存在的类文件. </p>
<p><strong>参数： </strong></p>
<p>-include {filename}    从给定的文件中读取配置参数 
-basedirectory {directoryname}    指定基础目录为以后相对的档案名称 
-injars {class_path}    指定要处理的应用程序jar,war,ear和目录 
-outjars {class_path}    指定处理完后要输出的jar,war,ear和目录的名称 
-libraryjars {classpath}    指定要处理的应用程序jar,war,ear和目录所需要的程序库文件 
-dontskipnonpubliclibraryclasses    指定不去忽略非公共的库类。 
-dontskipnonpubliclibraryclassmembers    指定不去忽略包可见的库类的成员。 
<strong>保留选项 </strong>
-keep {Modifier} {class_specification}    保护指定的类文件和类的成员 
-keepclassmembers {modifier} {class_specification}    保护指定类的成员，如果此类受到保护他们会保护的更好 
-keepclasseswithmembers {class_specification}    保护指定的类和类的成员，但条件是所有指定的类和类成员是要存在。 
-keepnames {class_specification}    保护指定的类和类的成员的名称（如果他们不会压缩步骤中删除） 
-keepclassmembernames {class_specification}    保护指定的类的成员的名称（如果他们不会压缩步骤中删除） 
-keepclasseswithmembernames {class_specification}    保护指定的类和类的成员的名称，如果所有指定的类成员出席（在压缩步骤之后） 
-printseeds {filename}    列出类和类的成员-keep选项的清单，标准输出到给定的文件 </p>
<p><strong>压缩 </strong>
-dontshrink    不压缩输入的类文件 
-printusage {filename} 
-whyareyoukeeping {class_specification}     </p>
<p><strong>优化 </strong>
-dontoptimize    不优化输入的类文件 
-assumenosideeffects {class_specification}    优化时假设指定的方法，没有任何副作用 
-allowaccessmodification    优化时允许访问并修改有修饰符的类和类的成员 </p>
<p><strong>混淆 </strong>
-dontobfuscate    不混淆输入的类文件 
-printmapping {filename} 
-applymapping {filename}    重用映射增加混淆 
-obfuscationdictionary {filename}    使用给定文件中的关键字作为要混淆方法的名称 
-overloadaggressively    混淆时应用侵入式重载 
-useuniqueclassmembernames    确定统一的混淆类的成员名称来增加混淆 
-flattenpackagehierarchy {package_name}    重新包装所有重命名的包并放在给定的单一包中 
-repackageclass {package_name}    重新包装所有重命名的类文件中放在给定的单一包中 
-dontusemixedcaseclassnames    混淆时不会产生形形色色的类名 
-keepattributes {attribute_name,...}    保护给定的可选属性，例如LineNumberTable, LocalVariableTable, SourceFile, Deprecated, Synthetic, Signature, and InnerClasses. 
-renamesourcefileattribute {string}    设置源文件中给定的字符串常量
<strong>Ant Example:</strong>
<!-- This Ant build file illustrates how to process applications,
     by including ProGuard-style configuration options.
     Usage: ant -f applications2.xml --></p>
<p><project name="Applications" default="obfuscate" basedir="../.."></p>
<p><target name="obfuscate">
  <taskdef resource="proguard/ant/task.properties"
           classpath="lib/proguard.jar" />
  <proguard>
    <!-- Specify the input jars, output jars, and library jars. -->
    -injars  in.jar
    -outjars out.jar
    -libraryjars ${java.home}/lib/rt.jar
    <!-- -libraryjars junit.jar    -->
    <!-- -libraryjars servlet.jar  -->
    <!-- -libraryjars jai_core.jar -->
    <!-- ...                       -->
    <!-- Save the obfuscation mapping to a file, and preserve line numbers. -->
    -printmapping out.map
    -renamesourcefileattribute SourceFile
    -keepattributes SourceFile,LineNumberTable
    <!-- Preserve all annotations. -->
    -keepattributes /<em>Annotation/</em>
    <!-- Preserve all public applications. -->
    -keepclasseswithmembers public class /<em> {
        public static void main(java.lang.String[]);
    }
    <!-- Preserve all native method names and the names of their classes. -->
    -keepclasseswithmembernames class /</em> {
        native &lt;methods&gt;;
    }
    <!-- Preserve the methods that are required in all enumeration classes. -->
    -keepclassmembers class /<em> extends java.lang.Enum {
        public static /</em>/<em>[] values();
        public static /</em>/<em> valueOf(java.lang.String);
    }
    <!-- Explicitly preserve all serialization members. The Serializable
         interface is only a marker interface, so it wouldn't save them.
         You can comment this out if your library doesn't use serialization.
         If your code contains serializable classes that have to be backward
         compatible, please refer to the manual. -->
    -keepclassmembers class /</em> implements java.io.Serializable {
        static final long serialVersionUID;
        static final java.io.ObjectStreamField[] serialPersistentFields;
        private void writeObject(java.io.ObjectOutputStream);
        private void readObject(java.io.ObjectInputStream);
        java.lang.Object writeReplace();
        java.lang.Object readResolve();
    }
    <!-- Your application may contain more items that need to be preserved;
         typically classes that are dynamically created using Class.forName -->
  </proguard>
</target>
</project>
来源： <a href="[http://www.kaiyuanba.cn/html/1/131/138/7820.htm](http://www.kaiyuanba.cn/html/1/131/138/7820.htm)">[http://www.kaiyuanba.cn/html/1/131/138/7820.htm](http://www.kaiyuanba.cn/html/1/131/138/7820.htm)</a> </p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/proguard/">proguard</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/proguard/" class="label label-success">proguard</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:41"datetime="2014-03-07 09:54:41"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-proguard--开源混淆工具ProGuard配置详解及配置实例/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-proguard--开源混淆工具ProGuard配置详解及配置实例" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_多线程--用apache的configuration实现实时配置-steven_cheng-ITeye/">用apache的configuration实现实时配置 </a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:41.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_多线程--用apache的configuration实现实时配置-steven_cheng-ITeye/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-apache-configuration-steven_cheng-iteye-">用apache的configuration实现实时配置 - steven_cheng - ITeye技术网站</h1>
<p><a href="http://www.iteye.com/" target="_blank">首页</a> <a href="http://www.iteye.com/news" target="_blank">新闻</a> <a href="http://www.iteye.com/forums" target="_blank">论坛</a> <a href="http://www.iteye.com/ask" target="_blank">问答</a> <a href="http://www.iteye.com/blogs" target="_blank">博客</a> <a href="http://www.iteye.com/job" target="_blank">招聘</a> <a href="http://steven-cheng.iteye.com/blog/70634#" target="_blank">更多 ▼</a></p>
<p><a href="http://www.iteye.com/wiki" target="_blank">专栏</a>  <a href="http://www.iteye.com/groups" target="_blank">群组</a> <a href="http://www.iteye.com/search" target="_blank">搜索</a></p>
<p><a href="http://steven-cheng.iteye.com/login" title="登录" target="_blank">您还未登录 !</a> <a href="http://www.iteye.com/all" target="_blank">我的应用</a> <a href="http://steven-cheng.iteye.com/login" target="_blank">登录</a> <a href="http://steven-cheng.iteye.com/signup" target="_blank">注册</a></p>
<h1 id="-steven_cheng-http-steven-cheng-iteye-com-"><a href="http://steven-cheng.iteye.com/" target="_blank">steven_cheng</a></h1>
<p>永久域名 <a href="http://steven-cheng.iteye.com/" target="_blank"><a href="http://steven-cheng.iteye.com">http://steven-cheng.iteye.com</a></a></p>
<p><a href="http://steven-cheng.iteye.com/blog/87667" title="异常处理" target="_blank">异常处理</a></p>
<p>2006-03-24</p>
<h3 id="-apache-configuration-"><a href="">用apache的configuration实现实时配置</a></h3>
<p>关键字: java 开源
apache下commons有一个configeration包，对于做配置很方便，尤其是实时热配置。可以自动监测到配置文件的更改而reload配置文件。在项目中使用所以进行了一下封装。
java 代码</p>
<ol>
<li>public class DefaultRealTimeXMLConfiger {   </li>
<li></li>
<li>private static Log logger = LogFactory.getLog(DefaultRealTimeXMLConfiger.class);   </li>
<li></li>
<li>private String fileName;   </li>
<li></li>
<li>private long reloadPeriod;   </li>
<li></li>
<li>private XMLConfiguration config;   </li>
<li></li>
<li>public void init()   </li>
<li>{   </li>
<li>String filePath = GlobalConfigerImpl.getConfDir()+&quot;/&quot;+fileName;   </li>
<li>logger.debug(&quot;will config with XML file[&quot;+filePath+&quot;]&quot;);   </li>
<li></li>
<li>File file = new File(filePath);   </li>
<li>if (!file.exists() || !file.isFile()) {   </li>
<li>logger.error(&quot; can&#39;t find file[&quot; + filePath + &quot;]&quot;);   </li>
<li>throw new IllegalArgumentException(&quot;config error! can&#39;t find file[&quot; + filePath + &quot;]&quot;);   </li>
<li>}   </li>
<li>this.init(file);   </li>
<li>}   </li>
<li></li>
<li>public void init(File file) {   </li>
<li>try {   </li>
<li>config = new XMLConfiguration(file);   </li>
<li>FileChangedReloadingStrategy fs = new FileChangedReloadingStrategy();   </li>
<li>fs.setConfiguration(config);   </li>
<li></li>
<li>if(this.reloadPeriod&gt;0)   </li>
<li>{   </li>
<li>fs.setRefreshDelay(this.reloadPeriod);   </li>
<li>}   </li>
<li>config.setReloadingStrategy(fs);   </li>
<li></li>
<li>} catch (ConfigurationException e) {   </li>
<li>logger.error(&quot;error! configer error[&quot;+file.getPath()+&quot;]&quot;);   </li>
<li>logger.error(e);   </li>
<li>e.printStackTrace();   </li>
<li>}   </li>
<li>}   </li>
<li></li>
<li>public Object getProperty(String name) {   </li>
<li>Object s = this.config.getProperty(name);   </li>
<li>return s;   </li>
<li>}   </li>
<li></li>
<li>public String getString(String name) {   </li>
<li>Object s = this.config.getProperty(name);   </li>
<li>String result = null;   </li>
<li>if (s != null)   </li>
<li>result = (String) s;   </li>
<li></li>
<li>return result;   </li>
<li>}   </li>
<li></li>
<li>public String[] getStringArray(String name) {   </li>
<li>String[] target = this.config.getStringArray(name);   </li>
<li></li>
<li>return target;   </li>
<li>}   </li>
<li></li>
<li></li>
<li>//<em>/</em>  </li>
<li>/* @return Returns the fileName.  </li>
<li>/*/  </li>
<li>public String getFileName() {   </li>
<li>return fileName;   </li>
<li>}   </li>
<li></li>
<li>//<em>/</em>  </li>
<li>/* @param fileName The fileName to set.  </li>
<li>/*/  </li>
<li>public void setFileName(String fileName) {   </li>
<li>this.fileName = fileName;   </li>
<li>}   </li>
<li></li>
<li>//<em>/</em>  </li>
<li>/* @return Returns the reloadPeriod.  </li>
<li>/*/  </li>
<li>public long getReloadPeriod() {   </li>
<li>return reloadPeriod;   </li>
<li>}   </li>
<li></li>
<li>//<em>/</em>  </li>
<li>/* @param reloadPeriod The reloadPeriod to set.  </li>
<li>/*/  </li>
<li>public void setReloadPeriod(long reloadPeriod) {   </li>
<li>this.reloadPeriod = reloadPeriod;   </li>
<li>}   </li>
<li>}<br><a href="http://steven-cheng.iteye.com/blog/87667" title="异常处理" target="_blank">异常处理</a></li>
</ol>
<ul>
<li>06:34</li>
<li>浏览 (988)</li>
<li><a href="http://steven-cheng.iteye.com/blog/70634#comments" target="_blank">评论</a> (0)</li>
<li>分类: <a href="http://steven-cheng.iteye.com/category/12345" target="_blank">java</a></li>
<li><a href="http://www.iteye.com/wiki/topic/70634" target="_blank">相关推荐</a><h3 id="-">评论</h3>
</li>
</ul>
<p><a href=""></a></p>
<h3 id="-">发表评论</h3>
<h3 id="-">表情图标</h3>
<p><img src="" alt=""><img src="" alt=""><img src="" alt=""><img src="" alt=""><img src="" alt=""><img src="" alt=""><img src="" alt=""><img src="" alt=""><img src="" alt=""><img src="" alt=""><img src="" alt=""><img src="" alt=""><img src="" alt=""><img src="" alt=""><img src="" alt=""><img src="" alt=""><img src="" alt=""><img src="" alt=""><img src="" alt=""><img src="" alt=""></p>
<p>字体颜色: 标准深红红色橙色棕色黄色绿色橄榄青色蓝色深蓝靛蓝紫色灰色白色黑色 字体大小: 标准1 (xx-small)2 (x-small)3 (small)4 (medium)5 (large)6 (x-large)7 (xx-large) 对齐: 标准居左居中居右</p>
<p>提示：选择您需要装饰的文字, 按上列按钮即可添加上相应的标签</p>
<p>您还没有登录，请<a href="http://steven-cheng.iteye.com/login" target="_blank">登录</a>后发表评论(快捷键 Alt+S / Ctrl+Enter)</p>
<p><a href="http://steven-cheng.iteye.com/" target="_blank"><img src="&quot;steven_cheng的博客: steven_cheng&quot;" alt="steven_cheng的博客"></a></p>
<p>steven_cheng</p>
<ul>
<li>浏览: 6938 次</li>
<li>来自: 北京</li>
<li><img src="" alt=""></li>
<li><a href="http://steven-cheng.iteye.com/blog/profile" target="_blank">详细资料</a> <a href="http://steven-cheng.iteye.com/blog/guest_book" target="_blank">留言簿</a></li>
</ul>
<h3 id="-">搜索本博客</h3>
<h3 id="-http-steven-cheng-iteye-com-blog-user_visits-">最近访客 <a href="http://steven-cheng.iteye.com/blog/user_visits" target="_blank">&gt;&gt;更多访客</a></h3>
<p><a href="http://loudyn.iteye.com/" target="_blank"><img src="&quot;Loudyn的博客: &quot;" alt="Loudyn的博客"></a></p>
<p><a href="http://loudyn.iteye.com/" target="_blank">Loudyn</a></p>
<p><a href="http://hepeng19861212.iteye.com/" target="_blank"><img src="&quot;hepeng19861212的博客: 火柴天堂&quot;" alt="hepeng19861212的博客"></a></p>
<p><a href="http://hepeng19861212.iteye.com/" target="_blank">hepeng19861212</a>
<a href="http://osacar.iteye.com/" target="_blank"><img src="&quot;osacar的博客: &quot;" alt="osacar的博客"></a></p>
<p><a href="http://osacar.iteye.com/" target="_blank">osacar</a></p>
<p><a href="http://kevin-gzhz.iteye.com/" target="_blank"><img src="&quot;kevin_gzhz的博客: kevin_gzhz&quot;" alt="kevin_gzhz的博客"></a></p>
<p><a href="http://kevin-gzhz.iteye.com/" target="_blank">kevin_gzhz</a></p>
<h3 id="-">博客分类</h3>
<ul>
<li><a href="http://steven-cheng.iteye.com/" target="_blank">全部博客 (8)</a></li>
<li><a href="http://steven-cheng.iteye.com/category/4287" target="_blank">默认类别 (0)</a></li>
<li><a href="http://steven-cheng.iteye.com/category/12345" target="_blank">java (6)</a></li>
<li><a href="http://steven-cheng.iteye.com/category/24850" target="_blank">单元测试和TDD (0)</a></li>
<li><a href="http://steven-cheng.iteye.com/category/48191" target="_blank">freemarker (1)</a></li>
<li><a href="http://steven-cheng.iteye.com/category/73657" target="_blank">linux (1)</a></li>
<li><p><a href="http://steven-cheng.iteye.com/category/75601" target="_blank">restlet (1)</a></p>
<h3 id="-http-steven-cheng-iteye-com-blog-guest_book-">我的留言簿 <a href="http://steven-cheng.iteye.com/blog/guest_book" target="_blank">&gt;&gt;更多留言</a></h3>
</li>
<li><p>steven_cheng 写道restlet那片原文是你的吗，如果是给个原文连接。 ...
-- by <a href="http://steven-cheng.iteye.com/blog/guest_book#6151" target="_blank">whaosoft</a></p>
</li>
</ul>
<h3 id="-">其他分类</h3>
<ul>
<li><a href="http://steven-cheng.iteye.com/blog/favorite" target="_blank">我的收藏</a> (15)</li>
<li><a href="http://steven-cheng.iteye.com/blog/code_favorite" target="_blank">我的代码</a> (0)</li>
<li><a href="http://steven-cheng.iteye.com/blog/topic" target="_blank">我的论坛主题帖</a> (1)</li>
<li><a href="http://steven-cheng.iteye.com/blog/post" target="_blank">我的所有论坛帖</a> (8)</li>
<li><a href="http://steven-cheng.iteye.com/blog/article" target="_blank">我的精华良好帖</a> (0)</li>
<li><p><a href="http://steven-cheng.iteye.com/blog/solution" target="_blank">我解决的问题</a> (1)</p>
<h3 id="-">最近加入群组</h3>
</li>
<li><p><a href="http://restlet.group.iteye.com/" target="_blank">Restlet</a></p>
</li>
<li><a href="http://freemarker.group.iteye.com/" target="_blank">FreeMarker</a></li>
</ul>
<h3 id="-">存档</h3>
<ul>
<li><a href="http://steven-cheng.iteye.com/blog/monthblog/2010-02" target="_blank">2010-02</a> (1)</li>
<li><a href="http://steven-cheng.iteye.com/blog/monthblog/2009-09" target="_blank">2009-09</a> (2)</li>
<li><a href="http://steven-cheng.iteye.com/blog/monthblog/2009-07" target="_blank">2009-07</a> (1)</li>
<li><p><a href="http://steven-cheng.iteye.com/blog/monthblog_more" target="_blank">更多存档...</a></p>
<h3 id="-">评论排行榜</h3>
</li>
<li><p><a href="http://steven-cheng.iteye.com/rss" target="_blank"><img src="" alt="Rss"></a></p>
</li>
<li><a href="http://fusion.google.com/add?feedurl=http://steven-cheng.iteye.com/rss" target="_blank"><img src="" alt="Rss_google"></a></li>
</ul>
<p>声明：ITeye文章版权属于作者，受法律保护。没有作者书面许可不得转载。若作者同意转载，必须以超链接形式标明文章原始出处和作者。
© 2003-2011 ITeye.com. All rights reserved. [ 京ICP证110151号 ]
<img src="" alt=""></p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/Java_多线程/">Java_多线程</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/Java_多线程/" class="label label-success">Java_多线程</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:41"datetime="2014-03-07 09:54:41"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-Java_多线程--用apache的configuration实现实时配置-steven_cheng-ITeye/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-Java_多线程--用apache的configuration实现实时配置-steven_cheng-ITeye" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-内存分析--Java内存泄露监控工具-JVM监控工具介绍jstack-jconsole-jinfo-/">Java 内存泄露监控工具</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:41.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-内存分析--Java内存泄露监控工具-JVM监控工具介绍jstack-jconsole-jinfo-/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="java-jvm-jstack-jconsole-jinfo-jmap-jdb-jstat">Java 内存泄露监控工具-- JVM监控工具介绍jstack, jconsole, jinfo, jmap, jdb, jstat</h1>
<hr>
<p><strong>jstack </strong>-- 如果java程序崩溃生成core文件，jstack工具可以用来获得core文件的java stack和native stack的信息，从而可以轻松地知道java程序是如何崩溃和在程序何处发生问题。另外，jstack工具还可以附属到正在运行的java程序中，看到 当时运行的java程序的java stack和native stack的信息, 如果现在运行的java程序呈现hung的状态，jstack是非常有用的。目前只有在Solaris和Linux的JDK版本里面才有。</p>
<p><strong>jconsole </strong>– jconsole是基于<a href="http://java.chinaitlab.com/" target="_blank">Java </a>Management Extensions (JMX)的实时图形化监测工具，这个工具利用了内建到JVM里面的JMX指令来提供实时的性能和资源的监控，包括了<a href="http://java.chinaitlab.com/" target="_blank">Java </a>程序的内存使用，Heap size, 线程的状态，类的分配状态和空间使用等等。</p>
<p><strong>jinfo </strong>– jinfo可以从core文件里面知道崩溃的Java应用程序的配置信息，目前只有在Solaris和Linux的JDK版本里面才有。</p>
<p><strong>jmap </strong>– jmap 可以从core文件或进程中获得内存的具体匹配情况，包括Heap size, Perm size等等，目前只有在Solaris和Linux的JDK版本里面才有。</p>
<p><strong>jdb </strong>– jdb 用来对core文件和正在运行的Java进程进行实时地调试，里面包含了丰富的命令帮助您进行调试，它的功能和Sun studio里面所带的dbx非常相似，但 jdb是专门用来针对Java应用程序的。</p>
<p><strong>jstat </strong>– jstat利用了JVM内建的指令对Java应用程序的资源和性能进行实时的命令行的监控，包括了对Heap size和垃圾回收状况的监控等等。</p>
<p><strong>jps </strong>– jps是用来查看JVM里面所有进程的具体状态, 包括进程ID，进程启动的路径等等。 </p>
<p><a href="http://java.sun.com/j2se/1.5.0/docs/tooldocs/share/jstatd.html" target="_blank"><strong>jstatd</strong> </a>
启动jvm监控服务。它是一个基于rmi的应用，向远程机器提供本机jvm应用程序的信息。默认端口1099。
实例：jstatd -J-Djava.security.policy=my.policy
my.policy文件需要自己建立，内如如下：
grant codebase &quot;file:$JAVA_HOME/lib/tools.jar&quot; {
permission java.security.AllPermission;
};
这是安全策略文件，因为jdk对jvm做了jaas的安全检测，所以我们必须设置一些策略，使得jstatd被允许作网络操作</p>
<p>上面的操作没有通过，出现：</p>
<p>Could not create remote object
access denied (java.util.PropertyPermission java.rmi.server.ignoreSubClasses write)
java.security.AccessControlException: access denied (java.util.PropertyPermission java.rmi.server.ignoreSubClasses write)
at java.security.AccessControlContext.checkPermission(AccessControlContext.java:323)
at java.security.AccessController.checkPermission(AccessController.java:546)
at java.lang.SecurityManager.checkPermission(SecurityManager.java:532)
at java.lang.System.setProperty(System.java:727)
at sun.tools.jstatd.Jstatd.main(Jstatd.java:122)</p>
<p>create in your usr/java/bin the jstatd.all.policy file, with the content must be</p>
<ol>
<li>grant codebase &quot;file:${java.home}/../lib/tools.jar&quot; {  </li>
<li>permission java.security.AllPermission;  </li>
<li>}; </li>
</ol>
<p><strong><a href="http://java.sun.com/j2se/1.5.0/docs/tooldocs/share/jps.html" target="_blank">jps </a></strong>
列出所有的jvm实例
实例：
jps
列出本机所有的jvm实例
jps 192.168.0.77
列出远程服务器192.168.0.77机器所有的jvm实例，采用rmi协议，默认连接端口为1099
（前提是远程服务器提供jstatd服务）
输出内容如下：
jones@jones:~/data/ebook/java/j2se/jdk_gc$ jps
6286 Jps
6174  Jstat
<strong>jconsole </strong>
一个图形化界面，可以观察到java进程的gc，class，内存等信息。虽然比较直观，但是个人还是比较倾向于使用jstat命令（在最后一部分会对jstat作详细的介绍）。
<strong><a href="http://java.sun.com/j2se/1.5.0/docs/tooldocs/share/jinfo.html" target="_blank">jinfo </a></strong>（linux下特有）
观察运行中的java程序的运行环境参数：参数包括Java System属性和JVM命令行参数
实例：jinfo 2083
其中2083就是java进程id号，可以用jps得到这个id号。
输出内容太多了，不在这里一一列举，大家可以自己尝试这个命令。
<strong><a href="http://java.sun.com/j2se/1.5.0/docs/tooldocs/share/jstack.html" target="_blank">jstack </a></strong>（linux下特有）
可以观察到jvm中当前所有线程的运行情况和线程当前状态
jstack 2083
输出内容如下：
<img src="" alt=""> 
<strong><a href="http://java.sun.com/j2se/1.5.0/docs/tooldocs/share/jmap.html" target="_blank">jmap </a></strong>（linux下特有，也是很常用的一个命令）
观察运行中的jvm物理内存的占用情况。
参数如下：<strong>-heap</strong> ：打印jvm heap的情况
<strong>-histo：</strong> 打印jvm heap的直方图。其输出信息包括类名，对象数量，对象占用大小。
<strong>-histo：live ：</strong> 同上，但是只答应存活对象的情况
<strong>-permstat：</strong> 打印permanent generation heap情况
命令使用：
jmap -heap 2083
可以观察到New Generation（Eden Space，From Space，To Space）,tenured generation,Perm Generation的内存使用情况
输出内容：
<img src="" alt=""> 
jmap -histo 2083 ｜ jmap -histo:live 2083
可以观察heap中所有对象的情况（heap中所有生存的对象的情况）。包括对象数量和所占空间大小。
输出内容：
<img src="" alt=""> 
写个脚本，可以很快把占用heap最大的对象找出来，对付内存泄漏特别有效。
<strong><a href="http://java.sun.com/j2se/1.5.0/docs/tooldocs/share/jstat.html" target="_blank">jstat </a>
</strong>最后要重点介绍下这个命令。
这是jdk命令中比较重要，也是相当实用的一个命令，可以观察到classloader，compiler，gc相关信息
具体参数如下：
-class：统计class loader行为信息
-compile：统计编译行为信息
-gc：统计jdk gc时heap信息
-gccapacity：统计不同的generations（不知道怎么翻译好，包括新生区，老年区，permanent区）相应的heap容量情况
-gccause：统计gc的情况，（同-gcutil）和引起gc的事件
-gcnew：统计gc时，新生代的情况
-gcnewcapacity：统计gc时，新生代heap容量
-gcold：统计gc时，老年区的情况
-gcoldcapacity：统计gc时，老年区heap容量
-gcpermcapacity：统计gc时，permanent区heap容量
-gcutil：统计gc时，heap情况
-printcompilation：不知道干什么的，一直没用过。
一般比较常用的几个参数是：
jstat -class 2083 1000 10 （每隔1秒监控一次，一共做10次）
输出内容含义如下：</p>
<p>Loaded Number of classes loaded. Bytes Number of Kbytes loaded. Unloaded Number of classes unloaded. Bytes Number of Kbytes unloaded. Time Time spent performing class load and unload operations.
jstat -gc 2083 2000 20（每隔2秒监控一次，共做10）
输出内容含义如下：
S0C Current survivor space 0 capacity (KB). EC Current eden space capacity (KB). EU Eden space utilization (KB). OC Current old space capacity (KB). OU Old space utilization (KB). PC Current permanent space capacity (KB). PU Permanent space utilization (KB). YGC Number of young generation GC Events. YGCT Young generation garbage collection time. FGC Number of full GC events. FGCT Full garbage collection time. GCT Total garbage collection time.
输出内容：
<img src="" alt="">
如果能熟练运用这些命令，尤其是在linux下，那么完全可以代替jprofile等监控工具了，谁让它收费呢。呵呵。
用命令的好处就是速度快，并且辅助于其他命令，比如grep gawk sed等，可以组装多种符合自己需求的工具。</p>
<h1 id="-u-jps-"><a href=""></a>u               jps 的用法</h1>
<p>用来查看 JVM 里面所有进程的具体状态 , 包括进程 ID ，进程启动的路径等等。 与 unix 上的 ps 类似，用来显示本地的java 进程，可以查看本地运行着几个 java 程序，并显示他们的进程号。</p>
<p><strong>[root@localhost ~]/# jps</strong></p>
<p>25517 Jps</p>
<p>25444 Bootstrap</p>
<h1 id="-u-jstack-"><a href=""></a>u               jstack 的用法</h1>
<p>如果 java 程序崩溃生成 core 文件， jstack 工具可以用来获得 core 文件的 java stack 和 native stack 的信息，从而可以轻松地知道 java 程序是如何崩溃和在程序何处发生问题。另外， jstack 工具还可以附属到正在运行的 java 程序中，看到当时运行的 java 程序的 java stack 和 native stack 的信息 , 如果现在运行的 java 程序呈现 hung 的状态， jstack 是非常有用的。目前只有在 Solaris 和 Linux 的 JDK 版本里面才有。</p>
<p><strong>[root@localhost bin]/# jstack **</strong>25444**</p>
<p>Attaching to process ID 25917, please wait...</p>
<p>Debugger attached successfully.</p>
<p>Client compiler detected.</p>
<p>JVM version is 1.5.0_08-b03</p>
<p>Thread 25964: (state = BLOCKED)</p>
<p>Error occurred during stack walking:</p>
<p>sun.jvm.hotspot.debugger.DebuggerException: sun.jvm.hotspot.debugger.DebuggerException: get_thread_regs failed for a lwp</p>
<pre><code>    at sun.jvm.hotspot.debugger.linux.LinuxDebuggerLocal$LinuxDebuggerLocalWorkerThread.execute(LinuxDebuggerLocal.java:134)

    at sun.jvm.hotspot.debugger.linux.LinuxDebuggerLocal.getThreadIntegerRegisterSet(LinuxDebuggerLocal.java:437)

    at sun.jvm.hotspot.debugger.linux.LinuxThread.getContext(LinuxThread.java:48)

    at
</code></pre><h1 id="-u-jstat-"><a href=""></a>u               jstat 的用法</h1>
<p>用以判断JVM 是否存在内存问题呢？如何判断JVM 垃圾回收是否正常？一般的top 指令基本上满足不了这样的需求，因为它主要监控的是总体的系统资源，很难定位到java 应用程序。</p>
<p>Jstat 是JDK 自带的一个轻量级小工具。全称“Java Virtual Machine statistics monitoring tool” ，它位于java 的bin 目录下，主要利用JVM 内建的指令对Java 应用程序的资源和性能进行实时的命令行的监控，包括了对Heap size 和垃圾回收状况的监控。可见，Jstat 是轻量级的、专门针对JVM 的工具，非常适用。由于JVM 内存设置较大，图中百分比变化不太明显</p>
<p>一个极强的监视 VM 内存工具。可以用来监视 VM 内存内的各种堆和非堆的大小及其内存使用量。</p>
<p>jstat 工具特别强大，有众多的可选项，详细查看堆内各个部分的使用量，以及加载类的数量。使用时，需加上查看进程的进程 id ，和所选参数。</p>
<p>语法结构：</p>
<p>Usage: jstat -help|-options</p>
<pre><code>   jstat -&lt;option&gt; [-t] [-h&lt;lines&gt;] &lt;vmid&gt; [&lt;interval&gt; [&lt;count&gt;]]
</code></pre><p>参数解释：</p>
<p>Options — 选项，我们一般使用 -gcutil 查看gc 情况</p>
<p>vmid    — VM 的进程号，即当前运行的java 进程号</p>
<p>interval– 间隔时间，单位为秒或者毫秒</p>
<p>count   — 打印次数，如果缺省则打印无数次</p>
<p>S0  — Heap 上的 Survivor space 0 区已使用空间的百分比 
S1  — Heap 上的 Survivor space 1 区已使用空间的百分比 
E   — Heap 上的 Eden space 区已使用空间的百分比 
O   — Heap 上的 Old space 区已使用空间的百分比 
P   — Perm space 区已使用空间的百分比 
YGC — 从应用程序启动到采样时发生 Young GC 的次数 
YGCT– 从应用程序启动到采样时 Young GC 所用的时间( 单位秒 )
FGC — 从应用程序启动到采样时发生 Full GC 的次数 
FGCT– 从应用程序启动到采样时 Full GC 所用的时间( 单位秒 )
GCT — 从应用程序启动到采样时用于垃圾回收的总时间( 单位秒)</p>
<p>实例使用1 ：</p>
<p><strong>[root@localhost bin]/# jstat -gcutil 25444</strong></p>
<p>  S0      S1     E      O      P     YGC     YGCT    FGC    FGCT     GCT</p>
<p>  11.63   0.00    56.46  66.92  98.49 162    0.248    6       0.331    0.579</p>
<p>实例使用 2 ：</p>
<p><strong>[root@localhost bin]/# jstat -gcutil 25444 1000 5</strong></p>
<p>  S0     S1     E      O      P     YGC     YGCT    FGC    FGCT     GCT</p>
<p>  73.54   0.00  99.04  67.52  98.49    166    0.252     6    0.331    0.583</p>
<p>  73.54   0.00  99.04  67.52  98.49    166    0.252     6    0.331    0.583</p>
<p>  73.54   0.00  99.04  67.52  98.49    166    0.252     6    0.331    0.583</p>
<p>  73.54   0.00  99.04  67.52  98.49    166    0.252     6    0.331    0.583</p>
<p>  73.54   0.00  99.04  67.52  98.49    166    0.252     6    0.331    0.583</p>
<p>我们可以看到，5 次young gc 之后，垃圾内存被从Eden space 区(E) 放入了Old space 区(O) ，并引起了百分比的变化，导致Survivor space 使用的百分比从73.54%(S0) 降到0%(S1) 。有效释放了内存空间。绿框中，我们可以看到，一次full gc 之后，Old space 区(O) 的内存被回收，从99.05% 降到67.52% 。</p>
<p>图中同时打印了young gc 和full gc 的总次数、总耗时。而，每次young gc 消耗的时间，可以用相间隔的两行YGCT 相减得到。每次full gc 消耗的时间，可以用相隔的两行FGCT 相减得到。例如红框中表示的第一行、第二行之间发生了1次young gc ，消耗的时间为0.252-0.252 ＝0.0 秒。</p>
<p>常驻内存区(P) 的使用率，始终停留在98.49% 左右，说明常驻内存没有突变，比较正常。</p>
<p>如果young gc 和full gc 能够正常发生，而且都能有效回收内存，常驻内存区变化不明显，则说明java 内存释放情况正常，垃圾回收及时，java 内存泄露的几率就会大大降低。但也不能说明一定没有内存泄露。</p>
<p>GCT 是YGCT 和FGCT 的时间总和。</p>
<p>以上，介绍了Jstat 按百分比查看gc 情况的功能。其实，它还有功能，例如加载类信息统计功能、内存池信息统计功能等，那些是以绝对值的形式打印出来的，比较少用，在此就不做介绍。</p>
<p><strong>[root@localhost bin]/# ps -ef | grep java</strong></p>
<p>root     25917     1  2 23:23 pts /2    00:00:05 /usr/local/jdk1.5/bin/java -Djava.endorsed.dirs=/usr/local/jakarta-tomcat-5.0.30/common/endorsed -classpath /usr/local/jdk1.5/lib/tools.jar:/usr/local/jakarta-tomcat-5.0.30/bin/bootstrap.jar:/usr/local/jakarta-tomcat-5.0.30/bin/commons-logging-api.jar -Dcatalina.base=/usr/local/jakarta-tomcat-5.0.30 -Dcatalina.home=/usr/local/jakarta-tomcat-5.0.30 -Djava.io.tmpdir=/usr/local/jakarta-tomcat-5.0.30/temp org.apache.catalina.startup.Bootstrap start</p>
<p>jstat -class pid: 显示加载 class 的数量，及所占空间等信息。</p>
<p>实例使用3 ：</p>
<p><strong>[root@localhost bin]/# jstat -class 25917</strong></p>
<p>Loaded  Bytes  Unloaded  Bytes     Time</p>
<p>2629     2916.8       29   24.6     0.90</p>
<p>jstat -compiler pid: 显示 VM 实时编译的数量等信息。</p>
<p>实例使用 4 ：</p>
<p><strong>[root@localhost bin]/# jstat -compiler 25917</strong></p>
<p>Compiled Failed Invalid   Time   FailedType FailedMethod</p>
<pre><code> 768      0       0   0.70             0
</code></pre><p>jstat –gccapacity : 可以显示， VM 内存中三代（ young,old,perm ）对象的使用和占用大小，如： PGCMN 显示的是最小 perm 的内存使用量， PGCMX 显示的是 perm 的内存最大使用量， PGC 是当前新生成的 perm 内存占用量， PC 是但前 perm 内存占用量。其他的可以根据这个类推， OC 是 old 内纯的占用量。</p>
<p><strong>[root@localhost bin]/# jstat -gccapacity 25917</strong></p>
<p>NGCMN       640.0</p>
<p>NGCMX       4992.0</p>
<p>NGC         832.0</p>
<p>S0C         64.0</p>
<p>S1C         64.0</p>
<p>EC          704.0</p>
<p>OGCMN       1408.0</p>
<p>OGCMX       60544.0</p>
<p>OGC         9504.0</p>
<p>OC          9504.0                  OC 是 old 内纯的占用量</p>
<p>PGCMN       8192.0                  PGCMN 显示的是最小 perm 的内存使用量</p>
<p>PGCMX       65536.0                 PGCMX 显示的是 perm 的内存最大使用量</p>
<p>PGC         12800.0                 PGC 是当前新生成的 perm 内存占用量</p>
<p>PC          12800.0                 PC 是但前 perm 内存占用量</p>
<p>YGC         164</p>
<p>FGC         6</p>
<p>jstat -gcnew pid: new 对象的信息</p>
<p><strong>[root@localhost bin]/# jstat -gcnew 25917</strong></p>
<p>  S0C    S1C    S0U    S1U   TT MTT  DSS      EC       EU     YGC     YGCT</p>
<p>  64.0   64.0   47.4   0.0    2  15   32.0    704.0    145.7    168    0.254</p>
<p>jstat -gcnewcapacity pid: new 对象的信息及其占用量</p>
<p><strong>[root@localhost bin]/# jstat -gcnewcapacity 25917</strong></p>
<p>  NGCMN   NGCMX    NGC    S0CMX  S0C    S1CMX   S1C   ECMX    EC      YGC   FGC</p>
<p>640.0   4992.0   832.0 64.0     448.0 448.0   64.0   4096.0   704.0  168     6</p>
<p>jstat -gcold pid: old 对象的信息。</p>
<p><strong>[root@localhost bin]/# jstat -gcold 25917</strong></p>
<p>   PC       PU        OC          OU       YGC    FGC    FGCT     GCT</p>
<p>  12800.0  12617.6     9504.0      6561.3   169     6    0.335    0.591</p>
<p>jstat -gcoldcapacity pid:old 对象的信息及其占用量。</p>
<p><strong>[root@localhost bin]/# jstat -gcoldcapacity 25917</strong></p>
<p>OGCMN      OGCMX        OGC         OC       YGC   FGC    FGCT     GCT</p>
<p>1408.0     60544.0      9504.0      9504.0   169     6    0.335    0.591</p>
<p>jstat -gcpermcapacity pid: perm 对象的信息及其占用量。</p>
<p>[root@localhost bin]/# jstat -gcpermcapacity 25917</p>
<p>PGCMN      PGCMX       PGC         PC      YGC   FGC    FGCT     GCT</p>
<p>8192.0    65536.0    12800.0    12800.0   169     6    0.335    0.591</p>
<p>jstat -printcompilation pid: 当前 VM 执行的信息。</p>
<p><strong>[root@localhost bin]/# jstat -printcompilation -h3  25917 1000 5</strong></p>
<p>每 1000 毫秒打印一次，一共打印 5 次，还可以加上 -h3 每三行显示一下标题。</p>
<p>Compiled  Size  Type Method</p>
<pre><code> 788     73    1 java/io/File &lt;init&gt;

 788     73    1 java/io/File &lt;init&gt;

 788     73    1 java/io/File &lt;init&gt;
</code></pre><p>Compiled  Size  Type Method</p>
<pre><code> 788     73    1 java/io/File &lt;init&gt;

 788     73    1 java/io/File &lt;init&gt;
</code></pre><h1 id="-u-jmap-"><a href=""></a>u               jmap 的用法</h1>
<p>打印出某个 java 进程（使用 pid ）内存内的，所有 ‘ 对象 ’ 的情况（如：产生那些对象，及其数量）。</p>
<p>可以输出所有内存中对象的工具，甚至可以将 VM 中的 heap ，以二进制输出成文本。使用方法 jmap -histo pid 。如果连用 SHELL jmap -histo pid&gt;a.log 可以将其保存到文本中去，在一段时间后，使用文本对比工具，可以对比出 GC 回收了哪些对象。 jmap -dump:format=b,file=String 3024 可以将 3024 进程的内存 heap 输出出来到 String 文件里。</p>
<p><strong>[root@localhost bin]/# jmap -histo  25917</strong></p>
<p>Attaching to process ID 26221, please wait...</p>
<p>Debugger attached successfully.</p>
<p>Client compiler detected.</p>
<p>JVM version is 1.5.0_08-b03</p>
<p>Iterating over heap. This may take a while...</p>
<p>Unknown oop at 0xaa6e42d0</p>
<p>Oop&#39;s klass is null</p>
<p>Object Histogram:</p>
<p>Size    Count   Class description</p>
<hr>
<p>3722768 30467    /* ConstMethodKlass</p>
<p>1976480 25334   char[]</p>
<p>1907880 46994   /* SymbolKlass</p>
<p>1762088 2947    byte[]</p>
<p>1709536 30467   /* MethodKlass</p>
<p>1487816 2600    /* ConstantPoolKlass</p>
<p>1009576 2600    /* InstanceKlassKlass</p>
<p>904880  2199    /* ConstantPoolCacheKlass</p>
<p>741432  30893   java.lang.String</p>
<p>653576  4785    int[]</p>
<p>351760  4397    java.lang.reflect.Method</p>
<p>277824  2894    java.lang.Class</p>
<p>248704  3401    short[]</p>
<p>200888  4411    java.lang.Object[]</p>
<p>193656  4045    java.lang.Object[]</p>
<p>179744  5617    java.util.TreeMap$Entry</p>
<p>175688  1800    java.util.HashMap$Entry[]</p>
<p>165288  6887    java.util.HashMap$Entry</p>
<p>104736  3273    java.lang.ref.SoftReference</p>
<p>104136  4339    java.lang.ref.WeakReference</p>
<p>96096   3521    java.lang.String[]</p>
<p>86160   3590    java.util.Hashtable$Entry</p>
<p>85584   3566    java.util.ArrayList</p>
<p>83472   1206    java.util.Hashtable$Entry[]</p>
<p>82944   1728    java.beans.MethodDescriptor</p>
<p>80560   265     /* ObjArrayKlassKlass</p>
<p>69120   1728    java.util.HashMap</p>
<p>52464   3055    java.lang.Class[]</p>
<p>43040   1076    java.util.Hashtable</p>
<p>42496   664     org.apache.commons.modeler.AttributeInfo</p>
<p>37880   947     java.util.TreeMap</p>
<p>33896   557     javax.management.modelmbean.ModelMBeanAttributeInfo[]</p>
<p>33152   518     java.beans.PropertyDescriptor</p>
<p>616     11      org.springframework.aop.framework.ProxyFactory</p>
<p>608     19      java.util.PropertyPermission</p>
<p>608     38      org.springframework.beans.MutablePropertyValues</p>
<p>608     38      org.springframework.beans.factory.support.MethodOverrides</p>
<p>608     2       /* ArrayKlassKlass</p>
<p>608     38      org.springframework.beans.factory.config.ConstructorArgumentValues</p>
<p>608     4       org.apache.xerces.impl.XMLDTDScannerImpl</p>
<p>576     24      java.util.Stack</p>
<p>576     36      java.util.regex.Pattern$Category</p>
<p>576     24      org.apache.naming.NamingEntry</p>
<p>560     7       java.net.URL[]</p>
<p>552     23      sun.management.MappedMXBeanType$BasicMXBeanType</p>
<p>552     1       java.util.Locale[]</p>
<p>552     22      java.io.ObjectStreamField[]</p>
<p>544     17      java.util.Collections$SynchronizedMap</p>
<p>176     11      java.util.regex.Pattern$Ctype</p>
<p>8        1       sun.reflect.GeneratedMethodAccessor49</p>
<p>8       1       sun.reflect.GeneratedMethodAccessor6</p>
<p>8       1       sun.reflect.GeneratedConstructorAccessor10</p>
<p>Heap traversal took 12.003 seconds.</p>
<h1 id="-u-jinfo-"><a href=""></a>u               jinfo 的用法</h1>
<p>可以输出并修改运行时的 java 进程的 opts 。用处比较简单，就是能输出并修改运行时的 java 进程的运行参数。用法是jinfo -opt  pid 如：查看 2788 的 MaxPerm 大小可以用   jinfo -flag MaxPermSize 2788 。</p>
<h1 id="-u-jconsole-"><a href=""></a>u               jconsole 的用法</h1>
<p>jconsole: 一个 java GUI 监视工具，可以以图表化的形式显示各种数据。并可通过远程连接监视远程的服务器 VM 。</p>
<p>用 java 写的 GUI 程序，用来监控 VM ，并可监控远程的 VM ，非常易用，而且功能非常强。命令行里打 jconsole ，选则进程就可以了</p>
<p>不过我没有运行起来，老是报下面的错。会的朋友，帮忙看看。</p>
<p><strong>  [root@localhost bin]/# jconsole</strong></p>
<p>Exception in thread &quot;AWT-EventQueue-0&quot; java.awt.HeadlessException:</p>
<p>No X11 DISPLAY variable was set, but this program performed an operation which requires it.        at java.awt.GraphicsEnvironment.checkHeadless(GraphicsEnvironment.java:159)</p>
<pre><code>    at java.awt.Window.&lt;init&gt;(Window.java:317)

    at java.awt.Frame.&lt;init&gt;(Frame.java:419)

    at javax.swing.JFrame.&lt;init&gt;(JFrame.java:194)

    at sun.tools.jconsole.JConsole.&lt;init&gt;(JConsole.java:65)

    at sun.tools.jconsole.JConsole$4.run(JConsole.java:666)

    at java.awt.event.InvocationEvent.dispatch(InvocationEvent.java:209)

    at java.awt.EventQueue.dispatchEvent(EventQueue.java:461)

    at java.awt.EventDispatchThread.pumpOneEventForHierarchy(EventDispatchThread.java:242)

    at java.awt.EventDispatchThread.pumpEventsForHierarchy(EventDispatchThread.java:163)

    at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:157)

    at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:149)

    at java.awt.EventDispatchThread.run(EventDispatchThread.java:110)
</code></pre><h1 id="-u-jdb-"><a href=""></a>u               jdb 的用法</h1>
<p>用来对 core 文件和正在运行的 Java 进程进行实时地调试，里面包含了丰富的命令帮助您进行调试，它的功能和 Sun studio 里面所带的 dbx 非常相似，但 jdb 是专门用来针对 Java 应用程序的。</p>
<h1 id="-u-jmap-"><a href=""></a>u               jmap 的用法</h1>
<p>打印出某个 java 进程（使用 pid ）内存内的，所有 ‘ 对象 ’ 的情况（如：产生那些对象，及其数量）。</p>
<p>可以输出所有内存中对象的工具，甚至可以将 VM 中的 heap ，以二进制输出成文本。使用方法 jmap -histo pid 。如果连用 SHELL jmap -histo pid&gt;a.log 可以将其保存到文本中去，在一段时间后，使用文本对比工具，可以对比出 GC 回收了哪些对象。 jmap -dump:format=b,file=String 3024 可以将 3024 进程的内存 heap 输出出来到 String 文件里。</p>
<p><strong>[root@localhost bin]/# jmap -histo  25917</strong></p>
<p>Attaching to process ID 26221, please wait...</p>
<p>Debugger attached successfully.</p>
<p>Client compiler detected.</p>
<p>JVM version is 1.5.0_08-b03</p>
<p>Iterating over heap. This may take a while...</p>
<p>Unknown oop at 0xaa6e42d0</p>
<p>Oop&#39;s klass is null</p>
<p>Object Histogram:</p>
<p>Size    Count   Class description</p>
<hr>
<p>3722768 30467    /* ConstMethodKlass</p>
<p>1976480 25334   char[]</p>
<p>1907880 46994   /* SymbolKlass</p>
<p>1762088 2947    byte[]</p>
<p>1709536 30467   /* MethodKlass</p>
<p>1487816 2600    /* ConstantPoolKlass</p>
<p>1009576 2600    /* InstanceKlassKlass</p>
<p>904880  2199    /* ConstantPoolCacheKlass</p>
<p>741432  30893   java.lang.String</p>
<p>653576  4785    int[]</p>
<p>351760  4397    java.lang.reflect.Method</p>
<p>277824  2894    java.lang.Class</p>
<p>248704  3401    short[]</p>
<p>200888  4411    java.lang.Object[]</p>
<p>193656  4045    java.lang.Object[]</p>
<p>179744  5617    java.util.TreeMap$Entry</p>
<p>175688  1800    java.util.HashMap$Entry[]</p>
<p>165288  6887    java.util.HashMap$Entry</p>
<p>104736  3273    java.lang.ref.SoftReference</p>
<p>104136  4339    java.lang.ref.WeakReference</p>
<p>96096   3521    java.lang.String[]</p>
<p>86160   3590    java.util.Hashtable$Entry</p>
<p>85584   3566    java.util.ArrayList</p>
<p>83472   1206    java.util.Hashtable$Entry[]</p>
<p>82944   1728    java.beans.MethodDescriptor</p>
<p>80560   265     /* ObjArrayKlassKlass</p>
<p>69120   1728    java.util.HashMap</p>
<p>52464   3055    java.lang.Class[]</p>
<p>43040   1076    java.util.Hashtable</p>
<p>42496   664     org.apache.commons.modeler.AttributeInfo</p>
<p>37880   947     java.util.TreeMap</p>
<p>33896   557     javax.management.modelmbean.ModelMBeanAttributeInfo[]</p>
<p>33152   518     java.beans.PropertyDescriptor</p>
<p>616     11      org.springframework.aop.framework.ProxyFactory</p>
<p>608     19      java.util.PropertyPermission</p>
<p>608     38      org.springframework.beans.MutablePropertyValues</p>
<p>608     38      org.springframework.beans.factory.support.MethodOverrides</p>
<p>608     2       /* ArrayKlassKlass</p>
<p>608     38      org.springframework.beans.factory.config.ConstructorArgumentValues</p>
<p>608     4       org.apache.xerces.impl.XMLDTDScannerImpl</p>
<p>576     24      java.util.Stack</p>
<p>576     36      java.util.regex.Pattern$Category</p>
<p>576     24      org.apache.naming.NamingEntry</p>
<p>560     7       java.net.URL[]</p>
<p>552     23      sun.management.MappedMXBeanType$BasicMXBeanType</p>
<p>552     1       java.util.Locale[]</p>
<p>552     22      java.io.ObjectStreamField[]</p>
<p>544     17      java.util.Collections$SynchronizedMap</p>
<p>176     11      java.util.regex.Pattern$Ctype</p>
<p>8        1       sun.reflect.GeneratedMethodAccessor49</p>
<p>8       1       sun.reflect.GeneratedMethodAccessor6</p>
<p>8       1       sun.reflect.GeneratedConstructorAccessor10</p>
<p>Heap traversal took 12.003 seconds.</p>
<h1 id="-u-jinfo-"><a href=""></a>u               jinfo 的用法</h1>
<p>可以输出并修改运行时的 java 进程的 opts 。用处比较简单，就是能输出并修改运行时的 java 进程的运行参数。用法是jinfo -opt  pid 如：查看 2788 的 MaxPerm 大小可以用   jinfo -flag MaxPermSize 2788 。</p>
<h1 id="-u-jconsole-"><a href=""></a>u               jconsole 的用法</h1>
<p>jconsole: 一个 java GUI 监视工具，可以以图表化的形式显示各种数据。并可通过远程连接监视远程的服务器 VM 。</p>
<p>用 java 写的 GUI 程序，用来监控 VM ，并可监控远程的 VM ，非常易用，而且功能非常强。命令行里打 jconsole ，选则进程就可以了</p>
<p>不过我没有运行起来，老是报下面的错。会的朋友，帮忙看看。</p>
<p><strong>  [root@localhost bin]/# jconsole</strong></p>
<p>Exception in thread &quot;AWT-EventQueue-0&quot; java.awt.HeadlessException:</p>
<p>No X11 DISPLAY variable was set, but this program performed an operation which requires it.        at java.awt.GraphicsEnvironment.checkHeadless(GraphicsEnvironment.java:159)</p>
<pre><code>    at java.awt.Window.&lt;init&gt;(Window.java:317)

    at java.awt.Frame.&lt;init&gt;(Frame.java:419)

    at javax.swing.JFrame.&lt;init&gt;(JFrame.java:194)

    at sun.tools.jconsole.JConsole.&lt;init&gt;(JConsole.java:65)

    at sun.tools.jconsole.JConsole$4.run(JConsole.java:666)

    at java.awt.event.InvocationEvent.dispatch(InvocationEvent.java:209)

    at java.awt.EventQueue.dispatchEvent(EventQueue.java:461)

    at java.awt.EventDispatchThread.pumpOneEventForHierarchy(EventDispatchThread.java:242)

    at java.awt.EventDispatchThread.pumpEventsForHierarchy(EventDispatchThread.java:163)

    at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:157)

    at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:149)

    at java.awt.EventDispatchThread.run(EventDispatchThread.java:110)
</code></pre><h1 id="-u-jdb-"><a href=""></a>u               jdb 的用法</h1>
<p>用来对 core 文件和正在运行的 Java 进程进行实时地调试，里面包含了丰富的命令帮助您进行调试，它的功能和 Sun studio 里面所带的 dbx 非常相似，但 jdb 是专门用来针对 Java 应用程序的。</p>
<p>来源： <a href="[http://blog.csdn.net/jacky0922/article/details/6201878](http://blog.csdn.net/jacky0922/article/details/6201878)">[http://blog.csdn.net/jacky0922/article/details/6201878](http://blog.csdn.net/jacky0922/article/details/6201878)</a></p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/内存分析/">内存分析</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/内存分析/" class="label label-success">内存分析</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:41"datetime="2014-03-07 09:54:41"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-内存分析--Java内存泄露监控工具-JVM监控工具介绍jstack-jconsole-jinfo-/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-内存分析--Java内存泄露监控工具-JVM监控工具介绍jstack-jconsole-jinfo-" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_多线程-并发--深入浅出JavaConcurrency1-JUC的整体认识/">深入浅出 Java Concurrency (1) </a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:41.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_多线程-并发--深入浅出JavaConcurrency1-JUC的整体认识/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-java-concurrency-1-j-u-c-">深入浅出 Java Concurrency (1) : J.U.C的整体认识</h1>
<p>最近一直用的比较多的就是java.util.concurrent(J.U.C)，实际上这块一直也没有完全深入研究，这次准备花点时间研究下Java里面整个并发体系。初步的设想包括比较大的方便（包括硬件、软件、思想以及误区等等），因此可能会持续较长的时间。这块内容也是Java在多线程方面引以为豪的一部分，深入这一部分不仅对整个Java体系有更深的了解，也对工作、学习的态度有多帮助。</p>
<p>从深入浅出入手，大体内容包括一下几个方面：</p>
<p>（1）J.U.C的API：包括完整的类库结构和样例分析。</p>
<p>（2）J.U.C的硬件原理以及软件思想：这部分也就将自己个人对硬件与程序语言的一些认识与大家分享，主要以总结前人的经验和所谓的理论来进行一些描述。</p>
<p>（3）J.U.C的误区和常见陷阱：包括对J.U.C的一些设计思想和使用上的原则进行说明，同时对可能犯的错误进行一些总结。</p>
<p>下面的图是J.U.C完整的API。<a href="http://www.blogjava.net/images/blogjava_net/xylz/WindowsLiveWriter/JavaConcurrent_FB25/J.U.C_2.png" target="_blank">完整的图片地址在这里</a>。</p>
<p><a href="http://www.blogjava.net/images/blogjava_net/xylz/Windows-Live-Writer/-Java-Concurrency-1--J.U.C_9314/J.U.C_2.png" target="_blank"><img src="&quot;J.U.C&quot;" alt="J.U.C"></a></p>
<p>完整的MindManger图形可以从下面的地址得到（注意，我是用MindManger 8写的，低版本没有测试是否能正常显示）。</p>
<p> <a href="http://www.blogjava.net/Files/xylz/J.U.C.zip" title="J.U.C完整的MindManger图形" target="_blank">J.U.C完整的MindManger图形</a></p>
<p>在接下来的系列文章中，我们将根据这张API的图形进行完整的分析和研究。
来源： <a href="[http://www.blogjava.net/xylz/archive/2010/06/30/324915.html](http://www.blogjava.net/xylz/archive/2010/06/30/324915.html)">[http://www.blogjava.net/xylz/archive/2010/06/30/324915.html](http://www.blogjava.net/xylz/archive/2010/06/30/324915.html)</a> </p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/Java_多线程/">Java_多线程</a></li><li><a href="/categories/Java&J2EE/Java_多线程/并发/">并发</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/Java_多线程/" class="label label-success">Java_多线程</a><a href="/tags/并发/" class="label label-info">并发</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:41"datetime="2014-03-07 09:54:41"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-Java_多线程-并发--深入浅出JavaConcurrency1-JUC的整体认识/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-Java_多线程-并发--深入浅出JavaConcurrency1-JUC的整体认识" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>





<ul id="pagination" class="pagination pagination-lg">
  <li><a class="extend prev" href="/page/62/">&laquo;</a></li><li><a class="page-number" href="/">1</a></li><li><a class="page-number" href="/page/2/">2</a></li><li><span class="space">&hellip;</span></li><li><a class="page-number" href="/page/60/">60</a></li><li><a class="page-number" href="/page/61/">61</a></li><li><a class="page-number" href="/page/62/">62</a></li><li class="active"><li><span class="page-number current">63</span></li><li><a class="page-number" href="/page/64/">64</a></li><li><a class="page-number" href="/page/65/">65</a></li><li><a class="page-number" href="/page/66/">66</a></li><li><span class="space">&hellip;</span></li></li><li><a class="page-number" href="/page/164/">164</a></li><li><a class="page-number" href="/page/165/">165</a></li><li><a class="extend next" href="/page/64/">&raquo;</a></li>
  <div class="clearfix"></div>
</ul></div><!--wapper-->
       </div><!-- ID main-col END -->
       <aside id="sidebar" class="alignright col-sx-6 col-sm-4 col-md-3 col-lg-3">
<div id="widget_search" class="widget panel panel-primary">
    <form action="//google.com/search" method="get" accept-charset="utf-8">
  <div class="input-group">
    <input class="form-control" id="searchbox" type="search" name="q" results="0" placeholder="search">
    <span class="input-group-btn">
      <button class="btn btn-default" type="submit">Go!</button>
    </span>
    <input type="hidden" name="q" value="site:itsolife.com">
  </div>
</form>
</div>

<div id="widget_category" class="widget panel panel-primary">
  <div class="panel-heading">category</div>  <div data-src='category' class='ajax_widgets'>正在加载...</div>
</div>

<div id="widget_recent_posts" class="widget panel panel-primary">
  <div class="panel-heading">recent posts</div>  <div data-src='recent_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_tagcloud" class="widget panel panel-primary">
  <div class="panel-heading">tagcloud</div>  <div data-src='tagcloud' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_latest_update_posts" class="widget panel panel-primary">
  <div class="panel-heading">最近更新</div>  <div data-src='latest_update_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_recent_comments" class="widget panel panel-primary">
  <div class="panel-heading">recent comments</div>  

<div class="list-group-item ds-recent-comments" data-num-items="6" data-show-avatars="1" data-show-time="1" data-show-title="1" data-show-admin="1" data-excerpt-length="50"></div>



</div>

</aside>
       <div class="clearfix"></div>
     </div><!-- row END -->
  </div>
  <footer id="footer" class="container">
  <div class="panel panel-info">
  <section id='footer_widget'></section>  <div class="panel-footer">
  <div id="site-info">
    <span class='author'>
  
  &copy; 2014 RobinChia
  
    &nbsp;&nbsp;</span>
  
  <span id='analytics-51la'></span><span id='analytics-google'>
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-48559895-1']);
  _gaq.push(['_trackPageview']);
  _js2load.push({src:('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'});
</script></span><span id='analytics-cnzz'>
<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_5774006'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s17.cnzz.com/stat.php%3Fid%3D5774006%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>
</span><span id='analytics-baidu'>
<script>
var _hmt = _hmt || [];
_js2load.push({src:"//hm.baidu.com/hm.js?1442f50724afc42380b51f097c43082c"});
</script>
</span>  </div>
  <div id="copyright">Blog powered by <a href='http://zespia.tw/hexo/'><strong>hexo</strong></a> Theme <strong><a href='https://github.com/chenall/hexo-theme-chenall'>chenall</a></strong>(Some change in it)<span class="pull-right"> 更新时间: <em>2014-03-15 13:06:28</em></span></div>
</div>
<div class="clearfix"></div>


  </div>
  </footer>
  
        <script src="http://cdn.bootcss.com/jquery/1.10.2/jquery.min.js"></script>        
        <script src="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/js/bootstrap.min.js"></script>        
                
        <script src="http://cdn.bootcss.com/prettify/r298/prettify.min.js"></script>    <script type="text/javascript">
   var lang=["bsh", "c", "cc", "cpp", "cs", "csh", "cyc", "cv", "htm", "html",
    "java", "js", "m", "mxml", "perl", "pl", "pm", "py", "rb", "sh",
    "xhtml", "xml", "xsl"];
   var pretty_base='';
   $('script').each(function(){
	var c = $(this).attr('src');
	if (!c)
	    return;
	if (c.match(/(\/)?prettify(\.min)?\.js/i))
	{
	    var index = c.lastIndexOf('/');
	    if (index != -1)
		pretty_base = c.substr(0,index + 1);
	    return false;
	}
   })
   $('pre code').each(function(){
	var c = $(this).attr('class')
	if (!c)
	    return;
	c = c.match(/\s?(lang\-\w+)/i);
	if (c && lang.indexOf(c[1]) == -1)
	{
	    lang.push(c[1]);
	    $.getScript(pretty_base + c[1] + '.min.js');
	}
   })

    $(window).load(function(){
       $("pre").addClass("prettyprint");
       prettyPrint();
    })
</script>    
            <script type="text/javascript">
var duoshuoQuery = {short_name:"robinchia"};
_js2load.push({src:'http://static.duoshuo.com/embed.js',charset:'UTF-8'});
</script>
    
            <!--wumii_relatedItems-->
    
        <script src="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js"></script>    <script type="text/javascript">
(function($){
  $('.entry').each(function(i){
    $(this).find('img').each(function(){
      var alt = this.alt;

      if (alt){
        $(this).before('<span class="caption">' + alt + '</span>');
      }

      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox" rel="fancybox' + i + '" />');
    });
  });

  $('.fancybox').fancybox();
})(jQuery);
</script>    
        <script src="http://cdn.bootcss.com/mathjax/2.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>    <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>
    
<script type="text/javascript">
$('.ajax_widgets').each(function(){var src=$(this).attr('data-src');if(src)$(this).load('/widgets/'+src+'.html');});
$.each(_js2load,function(index,obj){loadjs(obj.src,obj.charset)});
</script>

<div id="scroll2top">
<img src="/scroll2top/arrow.png"/>
</div>
<script src="/scroll2top/scroll2top.min.js"></script>
<div id="winterland">
  <canvas></canvas>
</div>
<script src="/js/winterland.min.js"></script>

  </body>
</html>
