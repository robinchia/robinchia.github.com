
<!DOCTYPE HTML>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>The 52 Page | It so life</title>
<meta name="author" content="RobinChia">

<meta name="description" content="It so life">


<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<meta property="og:site_name" content="It so life"/>

<!--[if IE]><style>.testIE.IE{display:inline;}</style><![endif]-->
<!--[if lte IE 7]><link rel="stylesheet" href="/css/ie7.css" type="text/css"><![endif]-->
<!--[if (lt IE 9)&(gt IE 7)]><style>.testIE.IE8{display:inline;}</style><![endif]-->
<!--[if gt IE 8]><style>.testIE.IE9{display:inline;}</style><![endif]-->

<link href="/favicon.png" rel="icon">
<link rel="alternate" href="/atom.xml" title="It so life Feed" type="application/atom+xml">

<link rel="stylesheet" href="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/css/bootstrap.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/font-awesome/4.0.3/css/font-awesome.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/prettify/r298/prettify.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" type="text/css">
<link rel="stylesheet" href="/css/style.css" type="text/css">
<!--[if lt IE 9]>
   <style>article,aside,dialog,footer,header,section,footer,nav,figure,menu{display:block}</style>
   <script src="http://cdn.staticfile.org/html5shiv/r29/html5.min.js"></script>
   <script src="http://cdn.staticfile.org/respond.js/1.4.2/respond.min.js"></script>
<link href="http://cdn.staticfile.org/respond.js/1.4.2/respond-proxy.html" id="respond-proxy" rel="respond-proxy" />
<link href="/js/respond.proxy.gif" id="respond-redirect" rel="respond-redirect" />
<script src="/js/respond.proxy.js"></script>
   <script src="http://cdn.bootcss.com/selectivizr/1.0.2/selectivizr-min.js"></script>
<![endif]-->
<script type="text/javascript">
function loadjs(c,d){var a=document.createElement("script");a.async=!0;a.type="text/javascript";a.src=c;a.charset=d||"gbk";(document.getElementsByTagName("HEAD")[0]||document.getElementsByTagName("BODY")[0]).appendChild(a)};
var _protocol = (("https:" == document.location.protocol) ? " https://" : " http://");
var _js2load = [];
</script>

</head>
<body>
      <header id="header" class="container"><nav id="main-nav" class="navbar navbar-default navbar-fixed-top " role="navigation">
  <div class="container">
    <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
      <span class="sr-only">Toggle navigation</span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="/">It so life</a>
    </div>
    <div  class="collapse navbar-collapse">
      <ul  class="nav navbar-nav">
  
        <li><a href="/" title="Home">Home</a></li>      
        <li><a href="/about/" title="About">About</a></li>      
        <li><a href="/archives/" title="Archives">Archives</a></li>      
      <li class='dropdown'>
        <a class='dropdown-toggle' data-toggle='dropdown' href='#'>website<b class='caret'></b></a>
        <ul class='dropdown-menu pure-menu-selected'>
    
          <li><a href="//groups.google.com/forum/#!forum/pongba" title="TopLanguage">TopLanguage</a></li>    
          <li><a href="//itpub.net/" title="ITPub">ITPub</a></li>    
          <li><a href="//blog.jobbole.com/" title="Bole">Bole</a></li>    
          <li><a href="//nosql-database.org/" title="nosql">nosql</a></li>    
          <li><a href="//gitimmersion.googol.im/" title="Git">Git</a></li>    
        </ul>
      </li>
    
      </ul>
      <ul class="nav navbar-nav navbar-right">
      
        <li><a href="/atom.xml">RSS</a></li>
      
      
        <li><a href="https://twitter.com/robinchia">twitter</a></li>
      
      
      
      
        <li><a href="https://github.com/robinchia">github</a></li>
      
      </ul>
    </div>
  </div>
</nav>
<div class="clearfix"></div>
</header>
  <div id='content' class="container">
     <div class="page-header-wrapper">
      <!--[if lt IE 9]><div class="alert alert-warning alert-dismissable"><button type="button" class="close" data-dismiss="alert" aria-hidden="true">&times;</button><strong>提示:</strong>您的浏览器版本太低了,建议升级到 <strong><a href="http://windows.microsoft.com/zh-cn/internet-explorer/download-ie" title="IE9">IE9</a></strong> 以上,本站使用<a href="https://www.google.com/intl/zh-CN/chrome/">Chrome浏览器</a>可以获得最好的显示效果.</div><![endif]-->
      <div class="page-header"><h1 align="center"><big>It so life</big> </h1>
        <h5 align="center"><big>love as life</big></h5>
      </div>
     </div>
     <div class="row">
       <div id="main-col" class="alignleft col-sx-12 col-sm-8 col-md-9 col-lg-9">
      <section id='header_widget'></section>
          <div id="wrapper"><article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--java线程安全总结-高级语言虚拟机/">java线程安全总结 </a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:42.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--java线程安全总结-高级语言虚拟机/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="java-">java线程安全总结 - 高级语言虚拟机</h1>
<p><a href="http://hllvm.group.iteye.com/login" title="登录" target="_blank">您还未登录 !</a> <a href="http://hllvm.group.iteye.com/login" target="_blank">登录</a> <a href="http://hllvm.group.iteye.com/signup" target="_blank">注册</a></p>
<p><a href="http://www.iteye.com/" target="_blank"><img src="&quot;ITeye-最棒的软件开发交流社区&quot;" alt="ITeye3.0"></a></p>
<p><a href=""></a></p>
<p><a href="http://www.iteye.com/groups" target="_blank">群组首页</a> → <a href="http://hllvm.group.iteye.com/groups/category/language" target="_blank">编程语言</a> → <a href="http://hllvm.group.iteye.com/" target="_blank">高级语言虚拟机</a> → <a href="http://hllvm.group.iteye.com/group/wiki" target="_blank">知识库</a> → <a href="http://hllvm.group.iteye.com/group/wiki?category_id=304" target="_blank">线程安全</a> → <a href="">java线程安全总结</a>
原创作者: <a href="http://www.javaeye.com/topic/806968" target="_blank">jameswxx</a>   阅读:9396次   评论:28条   更新时间:2011-05-26    </p>
<pre><code>  最近想将java基础的一些东西都整理整理，写下来，这是对知识的总结，也是一种乐趣。已经拟好了提纲，大概分为这几个主题： java线程安全，java垃圾收集，java并发包详细介绍，java profile和jvm性能调优 。慢慢写吧。本人jameswxx原创文章，转载请注明出处，我费了很多心血，多谢了。关于java线程安全，网上有很多资料，我只想从自己的角度总结对这方面的考虑，有时候写东西是很痛苦的，知道一些东西，但想用文字说清楚，却不是那么容易。我认为要认识java线程安全，必须了解两个主要的点：java的内存模型，java的线程同步机制。特别是内存模型，java的线程同步机制很大程度上都是基于内存模型而设定的。后面我还会写java并发包的文章，详细总结如何利用java并发包编写高效安全的多线程并发程序。暂时写得比较仓促，后面会慢慢补充完善。
</code></pre><p><strong>浅谈java内存模型</strong>
       不同的平台，内存模型是不一样的，但是jvm的内存模型规范是统一的。其实java的多线程并发问题最终都会反映在java的内存模型上，所谓线程安全无非是要控制多个线程对某个资源的有序访问或修改。总结java的内存模型，要解决两个主要的问题：可见性和有序性。我们都知道计算机有高速缓存的存在，处理器并不是每次处理数据都是取内存的。JVM定义了自己的内存模型，屏蔽了底层平台内存管理细节，对于java开发人员，要清楚在jvm内存模型的基础上，如果解决多线程的可见性和有序性。
       那么，何谓可见性？ 多个线程之间是不能互相传递数据通信的，它们之间的沟通只能通过共享变量来进行。Java内存模型（JMM）规定了jvm有主内存，主内存是多个线程共享的。当new一个对象的时候，也是被分配在主内存中，每个线程都有自己的工作内存，工作内存存储了主存的某些对象的副本，当然线程的工作内存大小是有限制的。当线程操作某个对象时，执行顺序如下：
 (1) 从主存复制变量到当前工作内存 (read and load)
 (2) 执行代码，改变共享变量值 (use and assign)
 (3) 用工作内存数据刷新主存相关内容 (store and write)</p>
<p>JVM规范定义了线程对主存的操作指令：read，load，use，assign，store，write。当一个共享变量在多个线程的工作内存中都有副本时，如果一个线程修改了这个共享变量，那么其他线程应该能够看到这个被修改后的值，这就是多线程的可见性问题。
        那么，什么是有序性呢 ？线程在引用变量时不能直接从主内存中引用,如果线程工作内存中没有该变量,则会从主内存中拷贝一个副本到工作内存中,这个过程为read-load,完成后线程会引用该副本。当同一线程再度引用该字段时,有可能重新从主存中获取变量副本(read-load-use),也有可能直接引用原来的副本(use),也就是说 read,load,use顺序可以由JVM实现系统决定。
        线程不能直接为主存中中字段赋值，它会将值指定给工作内存中的变量副本(assign),完成后这个变量副本会同步到主存储区(store-write)，至于何时同步过去，根据JVM实现系统决定.有该字段,则会从主内存中将该字段赋值到工作内存中,这个过程为read-load,完成后线程会引用该变量副本，当同一线程多次重复对字段赋值时,比如：
Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>for(int i=0;i&lt;10;i++)  </li>
<li>a++;<br>for(int i=0;i&lt;10;i++) a++;</li>
</ol>
<p>线程有可能只对工作内存中的副本进行赋值,只到最后一次赋值后才同步到主存储区，所以assign,store,weite顺序可以由JVM实现系统决定。假设有一个共享变量x，线程a执行x=x+1。从上面的描述中可以知道x=x+1并不是一个原子操作，它的执行过程如下：
1 从主存中读取变量x副本到工作内存
2 给x加1
3 将x加1后的值写回主 存
如果另外一个线程b执行x=x-1，执行过程如下：
1 从主存中读取变量x副本到工作内存
2 给x减1
3 将x减1后的值写回主存
那么显然，最终的x的值是不可靠的。假设x现在为10，线程a加1，线程b减1，从表面上看，似乎最终x还是为10，但是多线程情况下会有这种情况发生：
1：线程a从主存读取x副本到工作内存，工作内存中x值为10
2：线程b从主存读取x副本到工作内存，工作内存中x值为10
3：线程a将工作内存中x加1，工作内存中x值为11
4：线程a将x提交主存中，主存中x为11
5：线程b将工作内存中x值减1，工作内存中x值为9
6：线程b将x提交到中主存中，主存中x为9
同样，x有可能为11，如果x是一个银行账户，线程a存款，线程b扣款，显然这样是有严重问题的，要解决这个问题，必须保证线程a和线程b是有序执行的，并且每个线程执行的加1或减1是一个原子操作。看看下面代码：
Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>public class Account {  </li>
<li></li>
<li>private int balance;  </li>
<li></li>
<li>public Account(int balance) {  </li>
<li>this.balance = balance;  </li>
<li>}  </li>
<li></li>
<li>public int getBalance() {  </li>
<li>return balance;  </li>
<li>}  </li>
<li></li>
<li>public void add(int num) {  </li>
<li>balance = balance + num;  </li>
<li>}  </li>
<li></li>
<li>public void withdraw(int num) {  </li>
<li>balance = balance - num;  </li>
<li>}  </li>
<li></li>
<li>public static void main(String[] args) throws InterruptedException {  </li>
<li>Account account = new Account(1000);  </li>
<li>Thread a = new Thread(new AddThread(account, 20), &quot;add&quot;);  </li>
<li>Thread b = new Thread(new WithdrawThread(account, 20), &quot;withdraw&quot;);  </li>
<li>a.start();  </li>
<li>b.start();  </li>
<li>a.join();  </li>
<li>b.join();  </li>
<li>System.out.println(account.getBalance());  </li>
<li>}  </li>
<li></li>
<li>static class AddThread implements Runnable {  </li>
<li>Account account;  </li>
<li>int     amount;  </li>
<li></li>
<li>public AddThread(Account account, int amount) {  </li>
<li>this.account = account;  </li>
<li>this.amount = amount;  </li>
<li>}  </li>
<li></li>
<li>public void run() {  </li>
<li>for (int i = 0; i &lt; 200000; i++) {  </li>
<li>account.add(amount);  </li>
<li>}  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>static class WithdrawThread implements Runnable {  </li>
<li>Account account;  </li>
<li>int     amount;  </li>
<li></li>
<li>public WithdrawThread(Account account, int amount) {  </li>
<li>this.account = account;  </li>
<li>this.amount = amount;  </li>
<li>}  </li>
<li></li>
<li>public void run() {  </li>
<li>for (int i = 0; i &lt; 100000; i++) {  </li>
<li>account.withdraw(amount);  </li>
<li>}  </li>
<li>}  </li>
<li>}  </li>
<li>}<br>public class Account { private int balance; public Account(int balance) { this.balance = balance; } public int getBalance() { return balance; } public void add(int num) { balance = balance + num; } public void withdraw(int num) { balance = balance - num; } public static void main(String[] args) throws InterruptedException { Account account = new Account(1000); Thread a = new Thread(new AddThread(account, 20), &quot;add&quot;); Thread b = new Thread(new WithdrawThread(account, 20), &quot;withdraw&quot;); a.start(); b.start(); a.join(); b.join(); System.out.println(account.getBalance()); } static class AddThread implements Runnable { Account account; int amount; public AddThread(Account account, int amount) { this.account = account; this.amount = amount; } public void run() { for (int i = 0; i &lt; 200000; i++) { account.add(amount); } } } static class WithdrawThread implements Runnable { Account account; int amount; public WithdrawThread(Account account, int amount) { this.account = account; this.amount = amount; } public void run() { for (int i = 0; i &lt; 100000; i++) { account.withdraw(amount); } } } }</li>
</ol>
<p>第一次执行结果为10200，第二次执行结果为1060，每次执行的结果都是不确定的，因为线程的执行顺序是不可预见的。这是java同步产生的根源，synchronized关键字保证了多个线程对于同步块是互斥的，synchronized作为一种同步手段，解决java多线程的执行有序性和内存可见性，而volatile关键字之解决多线程的内存可见性问题。后面将会详细介绍。</p>
<p><strong>synchronized关键字</strong>
        上面说了，java用synchronized关键字做为多线程并发环境的执行有序性的保证手段之一。当一段代码会修改共享变量，这一段代码成为互斥区或临界区，为了保证共享变量的正确性，synchronized标示了临界区。典型的用法如下：
Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>synchronized(锁){  </li>
<li>临界区代码  </li>
<li>}<br>synchronized(锁){ 临界区代码 }</li>
</ol>
<p>为了保证银行账户的安全，可以操作账户的方法如下：
Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>public synchronized void add(int num) {  </li>
<li>balance = balance + num;  </li>
<li>}  </li>
<li>public synchronized void withdraw(int num) {  </li>
<li>balance = balance - num;  </li>
<li>}<br>public synchronized void add(int num) { balance = balance + num; } public synchronized void withdraw(int num) { balance = balance - num; }</li>
</ol>
<p>刚才不是说了synchronized的用法是这样的吗：
Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>synchronized(锁){  </li>
<li>临界区代码  </li>
<li>}<br>synchronized(锁){ 临界区代码 }</li>
</ol>
<p>那么对于public synchronized void add(int num)这种情况，意味着什么呢？其实这种情况，锁就是这个方法所在的对象。同理，如果方法是public  static synchronized void add(int num)，那么锁就是这个方法所在的class。
        理论上，每个对象都可以做为锁，但一个对象做为锁时，应该被多个线程共享，这样才显得有意义，在并发环境下，一个没有共享的对象作为锁是没有意义的。假如有这样的代码：
Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>public class ThreadTest{  </li>
<li>public void test(){  </li>
<li>Object lock=new Object();  </li>
<li>synchronized (lock){  </li>
<li>//do something  </li>
<li>}  </li>
<li>}  </li>
<li>}<br>public class ThreadTest{ public void test(){ Object lock=new Object(); synchronized (lock){ //do something } } }</li>
</ol>
<p>lock变量作为一个锁存在根本没有意义，因为它根本不是共享对象，每个线程进来都会执行Object lock=new Object();每个线程都有自己的lock，根本不存在锁竞争。
        每个锁对象都有两个队列，一个是就绪队列，一个是阻塞队列，就绪队列存储了将要获得锁的线程，阻塞队列存储了被阻塞的线程，当一个被线程被唤醒(notify)后，才会进入到就绪队列，等待cpu的调度。当一开始线程a第一次执行account.add方法时，jvm会检查锁对象account的就绪队列是否已经有线程在等待，如果有则表明account的锁已经被占用了，由于是第一次运行，account的就绪队列为空，所以线程a获得了锁，执行account.add方法。如果恰好在这个时候，线程b要执行account.withdraw方法，因为线程a已经获得了锁还没有释放，所以线程b要进入account的就绪队列，等到得到锁后才可以执行。
一个线程执行临界区代码过程如下：
1 获得同步锁
2 清空工作内存
3 从主存拷贝变量副本到工作内存
4 对这些变量计算
5 将变量从工作内存写回到主存
6 释放锁
可见，synchronized既保证了多线程的并发有序性，又保证了多线程的内存可见性。
<strong>生产者/消费者模式</strong>
        生产者/消费者模式其实是一种很经典的线程同步模型，很多时候，并不是光保证多个线程对某共享资源操作的互斥性就够了，往往多个线程之间都是有协作的。
        假设有这样一种情况，有一个桌子，桌子上面有一个盘子，盘子里只能放一颗鸡蛋，A专门往盘子里放鸡蛋，如果盘子里有鸡蛋，则一直等到盘子里没鸡蛋，B专门从盘子里拿鸡蛋，如果盘子里没鸡蛋，则等待直到盘子里有鸡蛋。其实盘子就是一个互斥区，每次往盘子放鸡蛋应该都是互斥的，A的等待其实就是主动放弃锁，B等待时还要提醒A放鸡蛋。
如何让线程主动释放锁
很简单，调用锁的wait()方法就好。wait方法是从Object来的，所以任意对象都有这个方法。看这个代码片段：
Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>Object lock=new Object();//声明了一个对象作为锁  </li>
<li>synchronized (lock) {  </li>
<li>balance = balance - num;  </li>
<li>//这里放弃了同步锁，好不容易得到，又放弃了  </li>
<li>lock.wait();  </li>
<li>}<br>Object lock=new Object();//声明了一个对象作为锁 synchronized (lock) { balance = balance - num; //这里放弃了同步锁，好不容易得到，又放弃了 lock.wait(); }</li>
</ol>
<p>如果一个线程获得了锁lock，进入了同步块，执行lock.wait()，那么这个线程会进入到lock的阻塞队列。如果调用lock.notify()则会通知阻塞队列的某个线程进入就绪队列。
声明一个盘子，只能放一个鸡蛋
Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>package com.jameswxx.synctest;  </li>
<li>public class Plate{  </li>
<li>List<Object> eggs=new ArrayList<Object>();  </li>
<li>public synchronized  Object getEgg(){  </li>
<li>if(eggs.size()==0){  </li>
<li>try{  </li>
<li>wait();  </li>
<li>}catch(InterruptedException e){  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>Object egg=eggs.get(0);  </li>
<li>eggs.clear();//清空盘子  </li>
<li>notify();//唤醒阻塞队列的某线程到就绪队列  </li>
<li>return egg;  </li>
<li>}  </li>
<li></li>
<li>public synchronized  void putEgg(Object egg){  </li>
<li>If(eggs.size()&gt;0){  </li>
<li>try{  </li>
<li>wait();  </li>
<li>}catch(InterruptedException e){  </li>
<li>}  </li>
<li>}  </li>
<li>eggs.add(egg);//往盘子里放鸡蛋  </li>
<li>notify();//唤醒阻塞队列的某线程到就绪队列  </li>
<li>}  </li>
<li>}<br>package com.jameswxx.synctest; public class Plate{ List<Object> eggs=new ArrayList<Object>(); public synchronized Object getEgg(){ if(eggs.size()==0){ try{ wait(); }catch(InterruptedException e){ } } Object egg=eggs.get(0); eggs.clear();//清空盘子 notify();//唤醒阻塞队列的某线程到就绪队列 return egg; } public synchronized void putEgg(Object egg){ If(eggs.size()&gt;0){ try{ wait(); }catch(InterruptedException e){ } } eggs.add(egg);//往盘子里放鸡蛋 notify();//唤醒阻塞队列的某线程到就绪队列 } }</li>
</ol>
<p>声明一个Plate对象为plate，被线程A和线程B共享，A专门放鸡蛋，B专门拿鸡蛋。假设
1 开始，A调用plate.putEgg方法，此时eggs.size()为0，因此顺利将鸡蛋放到盘子，还执行了notify()方法，唤醒锁的阻塞队列的线程，此时阻塞队列还没有线程。
2 又有一个A线程对象调用plate.putEgg方法，此时eggs.size()不为0，调用wait()方法，自己进入了锁对象的阻塞队列。
3 此时，来了一个B线程对象，调用plate.getEgg方法，eggs.size()不为0，顺利的拿到了一个鸡蛋，还执行了notify()方法，唤醒锁的阻塞队列的线程，此时阻塞队列有一个A线程对象，唤醒后，它进入到就绪队列，就绪队列也就它一个，因此马上得到锁，开始往盘子里放鸡蛋，此时盘子是空的，因此放鸡蛋成功。
4 假设接着来了线程A，就重复2；假设来料线程B，就重复3。
整个过程都保证了放鸡蛋，拿鸡蛋，放鸡蛋，拿鸡蛋。</p>
<p><strong>volatile关键字</strong>
       volatile是java提供的一种同步手段，只不过它是轻量级的同步，为什么这么说，因为volatile只能保证多线程的内存可见性，不能保证多线程的执行有序性。而最彻底的同步要保证有序性和可见性，例如synchronized。任何被volatile修饰的变量，都不拷贝副本到工作内存，任何修改都及时写在主存。因此对于Valatile修饰的变量的修改，所有线程马上就能看到，但是volatile不能保证对变量的修改是有序的。什么意思呢？假如有这样的代码：
Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>public class VolatileTest{  </li>
<li>public volatile int a;  </li>
<li>public void add(int count){  </li>
<li>a=a+count;  </li>
<li>}  </li>
<li>}<br>public class VolatileTest{ public volatile int a; public void add(int count){ a=a+count; } }</li>
</ol>
<pre><code>    当一个VolatileTest对象被多个线程共享，a的值不一定是正确的，因为a=a+count包含了好几步操作，而此时多个线程的执行是无序的，因为没有任何机制来保证多个线程的执行有序性和原子性。volatile存在的意义是，任何线程对a的修改，都会马上被其他线程读取到，因为直接操作主存，没有线程对工作内存和主存的同步。所以，volatile的使用场景是有限的，在有限的一些情形下可以使用 volatile 变量替代锁。要使 volatile 变量提供理想的线程安全,必须同时满足下面两个条件:
</code></pre><p>1)对变量的写操作不依赖于当前值。
2)该变量没有包含在具有其他变量的不变式中
volatile只保证了可见性，所以Volatile适合直接赋值的场景，如
Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>public class VolatileTest{  </li>
<li>public volatile int a;  </li>
<li>public void setA(int a){  </li>
<li>this.a=a;  </li>
<li>}  </li>
<li>}<br>public class VolatileTest{ public volatile int a; public void setA(int a){ this.a=a; } }</li>
</ol>
<p>在没有volatile声明时，多线程环境下，a的最终值不一定是正确的，因为this.a=a;涉及到给a赋值和将a同步回主存的步骤，这个顺序可能被打乱。如果用volatile声明了，读取主存副本到工作内存和同步a到主存的步骤，相当于是一个原子操作。所以简单来说，volatile适合这种场景：一个变量被多个线程共享，线程直接给这个变量赋值。这是一种很简单的同步场景，这时候使用volatile的开销将会非常小。</p>
<p>评论 共 28 条 请<a href="http://hllvm.group.iteye.com/login" target="_blank">登录</a>后发表评论 <a href=""></a></p>
<h3 id="28-geyingchen-http-geyingchen-iteye-com-geyingchen-2012-11-16-13-48">28 楼 <a href="http://geyingchen.iteye.com/" title="geyingchen" target="_blank">geyingchen</a> 2012-11-16 13:48</h3>
<p>这样行么，如果多次调用getegg ,然后putegg,唤醒  getegg ，getegg在唤醒getegg，这样就会报错额，你notify 唤醒的又不一定是另外一个方法的线程，</p>
<h3 id="27-hqf2009-http-hqf2009-iteye-com-hqf2009-2012-09-19-15-07">27 楼 <a href="http://hqf2009.iteye.com/" title="hqf2009" target="_blank">hqf2009</a> 2012-09-19 15:07</h3>
<p>受教颇多……对线程同步了解更进一步了。</p>
<h3 id="26-lijun880312-http-lijun880312-iteye-com-lijun880312-2012-09-03-14-59">26 楼 <a href="http://lijun880312.iteye.com/" title="lijun880312" target="_blank">lijun880312</a> 2012-09-03 14:59</h3>
<p>楼主诸葛之思，神来之笔啊！<img src="" alt=""></p>
<h3 id="25-zhuangyuann-http-zhuangyuann-iteye-com-zhuangyuann-2012-07-26-19-23">25 楼 <a href="http://zhuangyuann.iteye.com/" title="zhuangyuann" target="_blank">zhuangyuann</a> 2012-07-26 19:23</h3>
<p>收益良多，谢谢分享</p>
<h3 id="24-bbym010-http-bbym010-iteye-com-bbym010-2012-07-08-11-27">24 楼 <a href="http://bbym010.iteye.com/" title="bbym010" target="_blank">bbym010</a> 2012-07-08 11:27</h3>
<p>还厉害，博主，线程相关其他文章在哪</p>
<h3 id="23-yangcheng1230-http-yangcheng1230-iteye-com-yangcheng1230-2012-06-26-14-41">23 楼 <a href="http://yangcheng1230.iteye.com/" title="yangcheng1230" target="_blank">yangcheng1230</a> 2012-06-26 14:41</h3>
<p>楼主大才，谢谢分享。</p>
<h3 id="22-http-13966692733-163-com-iteye-com-2012-06-21-14-41">22 楼 <a href="http://13966692733-163-com.iteye.com/" title="爱上边城" target="_blank">爱上边城</a> 2012-06-21 14:41</h3>
<p><img src="" alt=""> 线程说的真好。感谢您的慷慨奉献</p>
<h3 id="21-tiandizhiguai-http-tiandizhiguai-iteye-com-tiandizhiguai-2012-06-21-10-28">21 楼 <a href="http://tiandizhiguai.iteye.com/" title="tiandizhiguai" target="_blank">tiandizhiguai</a> 2012-06-21 10:28</h3>
<p>写的妙<img src="" alt=""></p>
<h3 id="20-xieyaxiong-http-xieyaxiong-iteye-com-xieyaxiong-2012-06-18-17-52">20 楼 <a href="http://xieyaxiong.iteye.com/" title="xieyaxiong" target="_blank">xieyaxiong</a> 2012-06-18 17:52</h3>
<p><img src="" alt=""> <img src="" alt=""> <img src="" alt=""> <img src="" alt=""> <img src="" alt=""> <img src="" alt=""> <img src="" alt=""> <img src="" alt=""> <img src="" alt=""> <img src="" alt=""> <img src="" alt=""> <img src="" alt=""> <img src="" alt=""> <img src="" alt=""> <img src="" alt=""> <img src="" alt=""> <img src="" alt=""> <img src="" alt=""> <img src="" alt=""> <img src="" alt=""></p>
<h3 id="19-358397023-http-358397023-iteye-com-358397023-2012-03-30-21-28">19 楼 <a href="http://358397023.iteye.com/" title="358397023" target="_blank">358397023</a> 2012-03-30 21:28</h3>
<p>LZ写得好啊！学习了</p>
<h3 id="18-stanly_xia-http-stanly-xia-iteye-com-stanly_xia-2012-03-22-15-59">18 楼 <a href="http://stanly-xia.iteye.com/" title="Stanly_xia" target="_blank">Stanly_xia</a> 2012-03-22 15:59</h3>
<p>写的不错，受益匪浅。谢谢……<img src="" alt=""></p>
<h3 id="17-fs216-http-fs216-iteye-com-fs216-2012-02-10-10-53">17 楼 <a href="http://fs216.iteye.com/" title="fs216" target="_blank">fs216</a> 2012-02-10 10:53</h3>
<p><img src="" alt=""></p>
<h3 id="16-wyn4595735-http-wyn4595735-iteye-com-wyn4595735-2012-02-06-17-03">16 楼 <a href="http://wyn4595735.iteye.com/" title="wyn4595735" target="_blank">wyn4595735</a> 2012-02-06 17:03</h3>
<p>写的真不错啊，赞</p>
<h3 id="15-hemijing-http-hemijing-iteye-com-hemijing-2011-10-22-15-33">15 楼 <a href="http://hemijing.iteye.com/" title="hemijing" target="_blank">hemijing</a> 2011-10-22 15:33</h3>
<p>灰常之好呀</p>
<h3 id="14-yacht-http-noam-iteye-com-yacht-2011-10-12-15-54">14 楼 <a href="http://noam.iteye.com/" title="yacht" target="_blank">yacht</a> 2011-10-12 15:54</h3>
<p>这个文写的太好了！<img src="" alt=""></p>
<h3 id="13-qpshenggui-http-qpshenggui-iteye-com-qpshenggui-2011-08-29-13-39">13 楼 <a href="http://qpshenggui.iteye.com/" title="qpshenggui" target="_blank">qpshenggui</a> 2011-08-29 13:39</h3>
<p><img src="" alt=""></p>
<h3 id="12-wubo-wb-http-tiangu-iteye-com-wubo-wb-2011-08-22-13-48">12 楼 <a href="http://tiangu.iteye.com/" title="wubo.wb" target="_blank">wubo.wb</a> 2011-08-22 13:48</h3>
<p>很通俗易懂，让我知道还有这样一个拷贝过程，谢谢<img src="" alt=""> <img src="" alt=""></p>
<h3 id="11-txin0814-http-txin0814-iteye-com-txin0814-2011-06-23-12-41">11 楼 <a href="http://txin0814.iteye.com/" title="txin0814" target="_blank">txin0814</a> 2011-06-23 12:41</h3>
<p><img src="" alt=""></p>
<h3 id="10-blueheart2008-http-blueheart2008-iteye-com-blueheart2008-2011-06-04-22-53">10 楼 <a href="http://blueheart2008.iteye.com/" title="blueheart2008" target="_blank">blueheart2008</a> 2011-06-04 22:53</h3>
<p><img src="" alt="">
太牛了。</p>
<h3 id="9-yangke5105-http-yangke5105-iteye-com-yangke5105-2011-06-01-11-24">9 楼 <a href="http://yangke5105.iteye.com/" title="yangke5105" target="_blank">yangke5105</a> 2011-06-01 11:24</h3>
<p>已收藏，3ks……</p>
<h3 id="8-sd6733531-http-sd6733531-iteye-com-sd6733531-2011-05-19-10-57">8 楼 <a href="http://sd6733531.iteye.com/" title="sd6733531" target="_blank">sd6733531</a> 2011-05-19 10:57</h3>
<p>的确是好文。但是本人目前还是不能完全理解和消化,楼主有没有好书推荐下</p>
<h3 id="7-http-lovegrass91-yahoo-com-iteye-com-2011-04-18-11-49">7 楼 <a href="http://lovegrass91-yahoo-com.iteye.com/" title="艾青草" target="_blank">艾青草</a> 2011-04-18 11:49</h3>
<p>拜你为师吧！</p>
<h3 id="6-jyb2218-http-jyb2218-iteye-com-jyb2218-2011-04-08-14-23">6 楼 <a href="http://jyb2218.iteye.com/" title="jyb2218" target="_blank">jyb2218</a> 2011-04-08 14:23</h3>
<p>写的好啊。。。。</p>
<h3 id="5-xbcxs-http-xbcxs-iteye-com-xbcxs-2011-04-02-11-29">5 楼 <a href="http://xbcxs.iteye.com/" title="xbcxs" target="_blank">xbcxs</a> 2011-04-02 11:29</h3>
<p>好文章~~~</p>
<h3 id="4-zhao0p-http-zhao0p-iteye-com-zhao0p-2011-03-15-16-23">4 楼 <a href="http://zhao0p.iteye.com/" title="zhao0p" target="_blank">zhao0p</a> 2011-03-15 16:23</h3>
<p>通俗易懂~</p>
<h3 id="3-xiaoying_honey-http-xiaoying-honey-iteye-com-xiaoying_honey-2011-03-15-10-59">3 楼 <a href="http://xiaoying-honey.iteye.com/" title="xiaoying_honey" target="_blank">xiaoying_honey</a> 2011-03-15 10:59</h3>
<p><img src="" alt=""> 谢谢，受益匪浅。</p>
<h3 id="2-lj-http-ljstring19851014-126-com-iteye-com-lj-2011-01-19-16-56">2 楼 <a href="http://ljstring19851014-126-com.iteye.com/" title="lj杰" target="_blank">lj杰</a> 2011-01-19 16:56</h3>
<p>很厉害，很受益额，谢谢了</p>
<h3 id="1-star65225692-http-star65225692-iteye-com-star65225692-2010-11-22-12-00">1 楼 <a href="http://star65225692.iteye.com/" title="star65225692" target="_blank">star65225692</a> 2010-11-22 12:00</h3>
<p>好文<del>~</del><del>~</del><a href="http://www.itstrike.cn/Code/095c4615-263b-45b5-a778-67ebf1aec426" target="_blank">Java读出excel文件的类</a></p>
<h3 id="-">发表评论</h3>
<p><a href="http://hllvm.group.iteye.com/login" target="_blank"><img src="" alt=""> 您还没有登录,请您登录后再发表评论</a></p>
<p><a href="http://hllvm.group.iteye.com/group/wiki/new" target="_blank"><img src="" alt="New-page"></a></p>
<h3 id="-">文章信息</h3>
<p><a href="http://hllvm.group.iteye.com/group/wiki/" target="_blank">知识库: 高级语言虚拟机</a></p>
<ul>
<li>由<a href="http://kiral.iteye.com/" title="fantasy" target="_blank">fantasy</a>在2010-11-12创建</li>
<li><p>由<a href="http://kiral.iteye.com/" title="fantasy" target="_blank">fantasy</a>在2011-05-26更新</p>
<h3 id="-">相关新闻</h3>
</li>
<li><p><a href="http://hllvm.group.iteye.com/news/4307-scalaris-as-web-2-0-services-trade-data" target="_blank">Scalaris，为Web 2.0交易服务存储数据</a></p>
</li>
<li><a href="http://hllvm.group.iteye.com/news/1731" target="_blank">基于Spindle的增强HTTP Spider</a></li>
<li><a href="http://hllvm.group.iteye.com/news/2823" target="_blank">推荐风轻扬：Java 6中的性能优化</a></li>
</ul>
<h3 id="-">相关讨论</h3>
<ul>
<li><a href="http://hllvm.group.iteye.com/topic/806990" target="_blank">java线程安全总结</a></li>
<li><a href="http://hllvm.group.iteye.com/topic/164905" target="_blank">线程同步</a></li>
<li><a href="http://hllvm.group.iteye.com/topic/109150" target="_blank">多核线程笔记-volatile原理与技巧</a></li>
<li><a href="http://hllvm.group.iteye.com/topic/1068877" target="_blank">自己实现的java lock</a></li>
<li><p><a href="http://hllvm.group.iteye.com/topic/770080" target="_blank">最简单高效的tryLock</a></p>
<h3 id="-">相关博客</h3>
</li>
<li><p><a href="http://jiangtie.iteye.com/blog/1112625" target="_blank">java线程安全总结</a></p>
</li>
<li><a href="http://handawei.iteye.com/blog/808485" target="_blank">jvm内存模型</a></li>
<li><a href="http://republicw.iteye.com/blog/1218723" target="_blank">java线程同步</a></li>
<li><a href="http://qpshenggui.iteye.com/blog/1160343" target="_blank">java线程同步</a></li>
<li><a href="http://soboer.iteye.com/blog/1312934" target="_blank">java线程安全总结</a></li>
<li><a href="http://www.iteye.com/" target="_blank">首页</a></li>
<li><a href="http://www.iteye.com/news" target="_blank">资讯</a></li>
<li><a href="http://www.iteye.com/magazines" target="_blank">精华</a></li>
<li><a href="http://www.iteye.com/forums" target="_blank">论坛</a></li>
<li><a href="http://www.iteye.com/ask" target="_blank">问答</a></li>
<li><a href="http://www.iteye.com/blogs" target="_blank">博客</a></li>
<li><a href="http://www.iteye.com/blogs/subjects" target="_blank">专栏</a></li>
<li><a href="http://www.iteye.com/groups" target="_blank">群组</a></li>
<li><a href="http://job.iteye.com/iteye" target="_blank">招聘</a></li>
<li><a href="http://www.iteye.com/search" target="_blank">搜索</a></li>
<li><a href="http://hllvm.group.iteye.com/index/service" target="_blank">广告服务</a></li>
<li><a href="http://webmaster.iteye.com/" target="_blank">ITeye黑板报</a></li>
<li><a href="http://hllvm.group.iteye.com/index/contactus" target="_blank">联系我们</a></li>
<li><a href="http://hllvm.group.iteye.com/index/friend_links" target="_blank">友情链接</a></li>
</ul>
<p>© 2003-2012 ITeye.com. [ <a href="http://www.miibeian.gov.cn/" target="_blank">京ICP证110151号</a> 京公网安备110105010620 ]
百联优力(北京)投资有限公司 版权所有 <img src="http://stat.iteye.com/?url=http%3A%2F%2Fhllvm.group.iteye.com%2Fgroup%2Fwiki%2F2877-synchronized-volatile&amp;referrer=&amp;user_id=" alt=""></p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/JVM/">JVM</a></li></span></span> | <span class="tags">Tagged <a href="/tags/JVM/" class="label label-primary">JVM</a><a href="/tags/Java&J2EE/" class="label label-success">Java&J2EE</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:42"datetime="2014-03-07 09:54:42"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-JVM--java线程安全总结-高级语言虚拟机/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-JVM--java线程安全总结-高级语言虚拟机" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--eden区没有发生minorgc，对象直接分配在了oldgen/">eden区没有发生minor gc，对象直接分配在了old gen</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:42.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--eden区没有发生minorgc，对象直接分配在了oldgen/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="eden-minor-gc-old-gen">eden区没有发生minor gc，对象直接分配在了old gen</h1>
<p><a href="http://hllvm.group.iteye.com/login" title="登录" target="_blank">您还未登录 !</a> <a href="http://hllvm.group.iteye.com/login" target="_blank">登录</a> <a href="http://hllvm.group.iteye.com/signup" target="_blank">注册</a></p>
<p><a href="http://www.iteye.com/" target="_blank"><img src="&quot;ITeye-最棒的软件开发交流社区&quot;" alt="ITeye3.0"></a></p>
<p><a href="http://www.iteye.com/groups" target="_blank">群组首页</a> → <a href="http://hllvm.group.iteye.com/groups/category/language" target="_blank">编程语言</a> → <a href="http://hllvm.group.iteye.com/" target="_blank">高级语言虚拟机</a> → <a href="http://hllvm.group.iteye.com/group/forum" target="_blank">论坛</a></p>
<p><img src="" alt=""> <a href="http://hllvm.group.iteye.com/group/topic/38293/post/new" target="_blank">发表回复</a></p>
<h3 id="-http-hllvm-group-iteye-com-group-forum-tag_id-690-eden-minor-gc-old-gen-"><a href="http://hllvm.group.iteye.com/group/forum?tag_id=690" target="_blank">[讨论]</a> <a href="">eden区没有发生minor gc，对象直接分配在了old gen</a></h3>
<p><a href="http://zsl8544-163-com.iteye.com/" target="_blank"><img src="&quot;等待雨季的到来的博客: &quot;" alt="等待雨季的到来的博客"></a> <a href="http://zsl8544-163-com.iteye.com/" title="等待雨季的到来" target="_blank">等待雨季的到来</a> 2013-07-21</p>
<p>我的测试代码如下
Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>//<em>/</em> </li>
<li>/* -Xmx100M -XX:+PrintGCDetails -XX:MaxNewSize=40M -XX:+PrintTenuringDistribution </li>
<li>/*/  </li>
<li>public static void testAllocation(){  </li>
<li>byte[] byte1 = new byte[_1MB/*5];  </li>
<li>byte[] byte2 = new byte[_1MB/*10];  </li>
<li>byte1 = null;  </li>
<li>byte2 = null;                         </li>
<li>byte[] byte3 = new byte[_1MB/*5];  </li>
<li>byte[] byte4 = new byte[_1MB/*10];  </li>
<li>byte3 = null;  </li>
<li>byte4 = null;  </li>
<li>byte[] byte5 = new byte[_1MB/*15];   </li>
<li><p>}<br>//<em>/</em> /<em> -Xmx100M -XX:+PrintGCDetails -XX:MaxNewSize=40M -XX:+PrintTenuringDistribution /</em>/ public static void testAllocation(){ byte[] byte1 = new byte[_1MB/<em>5]; byte[] byte2 = new byte[_1MB/</em>10]; byte1 = null; byte2 = null; byte[] byte3 = new byte[_1MB/<em>5]; byte[] byte4 = new byte[_1MB/</em>10]; byte3 = null; byte4 = null; byte[] byte5 = new byte[_1MB/*15]; }
因为没有用NewSize限定新生代的初始大小，所以eden区的初始大小为20M，而我用MaxNewSize限定了新生代的初始大小为40M。
GC Log
Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>[GC  </p>
</li>
<li>Desired survivor size 3538944 bytes, new threshold 7 (max 15)  </li>
<li>[PSYoungGen: 16194K-&gt;368K(24320K)] 16194K-&gt;368K(79872K), 0.0020460 secs] [Times: user=0.01 sys=0.00, real=0.00 secs]   </li>
<li>Heap  </li>
<li>PSYoungGen      total 24320K, used 17199K [0x0000000115490000, 0x0000000117c90000, 0x0000000117c90000)  </li>
<li>eden space 20864K, 80% used [0x0000000115490000,0x00000001164ffe38,0x00000001168f0000)  </li>
<li>from space 3456K, 10% used [0x00000001168f0000,0x000000011694c010,0x0000000116c50000)  </li>
<li>to   space 3456K, 0% used [0x0000000117930000,0x0000000117930000,0x0000000117c90000)  </li>
<li>ParOldGen       total 55552K, used 15360K [0x0000000111890000, 0x0000000114ed0000, 0x0000000115490000)  </li>
<li>object space 55552K, 27% used [0x0000000111890000,0x0000000112790010,0x0000000114ed0000)  </li>
<li>PSPermGen       total 21248K, used 2695K [0x000000010c690000, 0x000000010db50000, 0x0000000111890000)  </li>
<li>object space 21248K, 12% used [0x000000010c690000,0x000000010c931ef0,0x000000010db50000)<br>[GC Desired survivor size 3538944 bytes, new threshold 7 (max 15) [PSYoungGen: 16194K-&gt;368K(24320K)] 16194K-&gt;368K(79872K), 0.0020460 secs] [Times: user=0.01 sys=0.00, real=0.00 secs] Heap PSYoungGen total 24320K, used 17199K <a href="http://rednaxelafx.iteye.com/">0x0000000115490000, 0x0000000117c90000, 0x0000000117c90000) eden space 20864K, 80% used [0x0000000115490000,0x00000001164ffe38,0x00000001168f0000) from space 3456K, 10% used [0x00000001168f0000,0x000000011694c010,0x0000000116c50000) to space 3456K, 0% used [0x0000000117930000,0x0000000117930000,0x0000000117c90000) ParOldGen total 55552K, used 15360K [0x0000000111890000, 0x0000000114ed0000, 0x0000000115490000) object space 55552K, 27% used [0x0000000111890000,0x0000000112790010,0x0000000114ed0000) PSPermGen total 21248K, used 2695K [0x000000010c690000, 0x000000010db50000, 0x0000000111890000) object space 21248K, 12% used [0x000000010c690000,0x000000010c931ef0,0x000000010db50000)
现象：
当分配byte3时触发了一次minor gc，byte1和byte2都被回收了，可是我分配byte5的时候，却直接分配在了老生代，byte3和byte4依旧在eden区，而byte5直接被分配在了老生代。
问题：
1、byte5为什么没有触发minor gc而是直接分配在老生代，byte3和byte4为什么没有被回收？
2、eden区什么时候才会自动扩容到40M，当创建超过20M的对象时，都是直接分配在了老生，而创建大小超过老生代的对象时老生代会自动扩容。
其他：
我在用eclipse调试的时候发现，同样的测试代码在执行的时候输出的GC log居然会有很大的变化，有的时候eden区被初始化为8M有的时候初始化为20M。我工作在OS X下，JDK版本如下。
java version &quot;1.7.0_25&quot;
Java(TM) SE Runtime Environment (build 1.7.0_25-b15)
Java HotSpot(TM) 64-Bit Server VM (build 23.25-b01, mixed mode)
<img src="" alt="Spinner"> [<img src="&quot;RednaxelaFX的博客: Script Ahead, Code Behind&quot;" alt="RednaxelaFX的博客"></a> <a href="http://rednaxelafx.iteye.com/" title="RednaxelaFX" target="_blank">RednaxelaFX</a> 2013-07-25</li>
</ol>
<p>楼主是看了毕玄的实验之后自己动手测试么？
把楼主的代码弄成可执行的，我用的测试代码是：
Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>public class PSAllocTest {  </li>
<li>private static final int _1KB = 1024;  </li>
<li>private static final int _1MB = _1KB /* 1024;  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* -Xmx100M -XX:+PrintGCDetails -XX:MaxNewSize=40M -XX:+PrintTenuringDistribution </li>
<li>/*/  </li>
<li>public static void testAllocation() {  </li>
<li>byte[] byte1 = new byte[_1MB/*5];  </li>
<li>byte[] byte2 = new byte[_1MB/*10];  </li>
<li>byte1 = null;  </li>
<li>byte2 = null;                         </li>
<li>byte[] byte3 = new byte[_1MB/*5];  </li>
<li>byte[] byte4 = new byte[_1MB/*10];  </li>
<li>byte3 = null;  </li>
<li>byte4 = null;  </li>
<li>byte[] byte5 = new byte[_1MB/*15];   </li>
<li>}  </li>
<li></li>
<li>public static void main(String[] args) {  </li>
<li>testAllocation();  </li>
<li>}  </li>
<li><p>}<br>public class PSAllocTest { private static final int _1KB = 1024; private static final int _1MB = _1KB /<em> 1024; //</em>/<em> /</em> -Xmx100M -XX:+PrintGCDetails -XX:MaxNewSize=40M -XX:+PrintTenuringDistribution /<em>/ public static void testAllocation() { byte[] byte1 = new byte[_1MB/</em>5]; byte[] byte2 = new byte[_1MB/<em>10]; byte1 = null; byte2 = null; byte[] byte3 = new byte[_1MB/</em>5]; byte[] byte4 = new byte[_1MB/<em>10]; byte3 = null; byte4 = null; byte[] byte5 = new byte[_1MB/</em>15]; } public static void main(String[] args) { testAllocation(); } }
我这边在JDK7u9 64-bit Server VM上跑看到的GC日志会有两次GC：
Gc log代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>D:\test\pstest&gt;java -Xmx100M -XX:+PrintGCDetails -XX:MaxNewSize=40M PSAllocTest  </p>
</li>
<li>[GC [PSYoungGen: 16002K-&gt;584K(18688K)] 16002K-&gt;584K(61376K), 0.0016857 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]  </li>
<li>[GC [PSYoungGen: 16648K-&gt;576K(34752K)] 32008K-&gt;15936K(77440K), 0.0014163 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]  </li>
<li>Heap  </li>
<li>PSYoungGen      total 34752K, used 1218K [0x00000000fd800000, 0x00000000ffc80000, 0x0000000100000000)  </li>
<li>eden space 32128K, 2% used [0x00000000fd800000,0x00000000fd8a0ab0,0x00000000ff760000)  </li>
<li>from space 2624K, 21% used [0x00000000ff9f0000,0x00000000ffa80030,0x00000000ffc80000)  </li>
<li>to   space 2624K, 0% used [0x00000000ff760000,0x00000000ff760000,0x00000000ff9f0000)  </li>
<li>ParOldGen       total 42688K, used 15360K [0x00000000f9c00000, 0x00000000fc5b0000, 0x00000000fd800000)  </li>
<li>object space 42688K, 35% used [0x00000000f9c00000,0x00000000fab00010,0x00000000fc5b0000)  </li>
<li>PSPermGen       total 21248K, used 2505K [0x00000000f4a00000, 0x00000000f5ec0000, 0x00000000f9c00000)  </li>
<li><p>object space 21248K, 11% used [0x00000000f4a00000,0x00000000f4c72638,0x00000000f5ec0000)<br>D:\test\pstest&gt;java -Xmx100M -XX:+PrintGCDetails -XX:MaxNewSize=40M PSAllocTest [GC [PSYoungGen: 16002K-&gt;584K(18688K)] 16002K-&gt;584K(61376K), 0.0016857 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [GC [PSYoungGen: 16648K-&gt;576K(34752K)] 32008K-&gt;15936K(77440K), 0.0014163 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] Heap PSYoungGen total 34752K, used 1218K <a href="&quot;复制代码&quot;">0x00000000fd800000, 0x00000000ffc80000, 0x0000000100000000) eden space 32128K, 2% used [0x00000000fd800000,0x00000000fd8a0ab0,0x00000000ff760000) from space 2624K, 21% used [0x00000000ff9f0000,0x00000000ffa80030,0x00000000ffc80000) to space 2624K, 0% used [0x00000000ff760000,0x00000000ff760000,0x00000000ff9f0000) ParOldGen total 42688K, used 15360K [0x00000000f9c00000, 0x00000000fc5b0000, 0x00000000fd800000) object space 42688K, 35% used [0x00000000f9c00000,0x00000000fab00010,0x00000000fc5b0000) PSPermGen total 21248K, used 2505K [0x00000000f4a00000, 0x00000000f5ec0000, 0x00000000f9c00000) object space 21248K, 11% used [0x00000000f4a00000,0x00000000f4c72638,0x00000000f5ec0000)
第二次GC其实已经在第5个数组成功分配之后了，就楼主关心的部分看我这边看到的跟楼主实验看到的行为一致，只要关心日志里的第一次GC就好了。
如果加上额外参数的话，可以看到更多GC信息：
Java代码 [<img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>D:\test\pstest&gt;java -Xmx100M -XX:+PrintGCDetails -XX:+PrintHeapAtGC -XX:+PrintTLAB -XX:MaxNewSize=40M -XX:+PrintTenuringDistribution PSAllocTest  </p>
</li>
<li>{Heap before GC invocations=1 (full 0):  </li>
<li>PSYoungGen      total 18688K, used 16002K [0x00000000fd800000, 0x00000000fecd0000, 0x0000000100000000)  </li>
<li>eden space 16064K, 99% used [0x00000000fd800000,0x00000000fe7a0b60,0x00000000fe7b0000)  </li>
<li>from space 2624K, 0% used [0x00000000fea40000,0x00000000fea40000,0x00000000fecd0000)  </li>
<li>to   space 2624K, 0% used [0x00000000fe7b0000,0x00000000fe7b0000,0x00000000fea40000)  </li>
<li>ParOldGen       total 42688K, used 0K [0x00000000f9c00000, 0x00000000fc5b0000, 0x00000000fd800000)  </li>
<li>object space 42688K, 0% used [0x00000000f9c00000,0x00000000f9c00000,0x00000000fc5b0000)  </li>
<li>PSPermGen       total 21248K, used 2495K [0x00000000f4a00000, 0x00000000f5ec0000, 0x00000000f9c00000)  </li>
<li>object space 21248K, 11% used [0x00000000f4a00000,0x00000000f4c6fc80,0x00000000f5ec0000)  </li>
<li>TLAB: gc thread: 0x000000000028c000 [id: 10344] desired_size: 321KB slow allocs: 3  refill waste: 5232B alloc: 0.99998    16003KB refills: 2 waste  6.2% gc: 40912B slow: 40B fast: 0B  </li>
<li>TLAB totals: thrds: 1  refills: 2 max: 2 slow allocs: 3 max 3 waste:  6.2% gc: 40912B max: 40912B slow: 40B max: 40B fast: 0B max: 0B  </li>
<li>[GC  </li>
<li>Desired survivor size 2686976 bytes, new threshold 7 (max 15)  </li>
<li>[PSYoungGen: 16002K-&gt;640K(18688K)] 16002K-&gt;640K(61376K), 0.0015035 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]   </li>
<li>Heap after GC invocations=1 (full 0):  </li>
<li>PSYoungGen      total 18688K, used 640K [0x00000000fd800000, 0x00000000ffc80000, 0x0000000100000000)  </li>
<li>eden space 16064K, 0% used [0x00000000fd800000,0x00000000fd800000,0x00000000fe7b0000)  </li>
<li>from space 2624K, 24% used [0x00000000fe7b0000,0x00000000fe850030,0x00000000fea40000)  </li>
<li>to   space 2624K, 0% used [0x00000000ff9f0000,0x00000000ff9f0000,0x00000000ffc80000)  </li>
<li>ParOldGen       total 42688K, used 0K [0x00000000f9c00000, 0x00000000fc5b0000, 0x00000000fd800000)  </li>
<li>object space 42688K, 0% used [0x00000000f9c00000,0x00000000f9c00000,0x00000000fc5b0000)  </li>
<li>PSPermGen       total 21248K, used 2495K [0x00000000f4a00000, 0x00000000f5ec0000, 0x00000000f9c00000)  </li>
<li>object space 21248K, 11% used [0x00000000f4a00000,0x00000000f4c6fc80,0x00000000f5ec0000)  </li>
<li>}  </li>
<li>{Heap before GC invocations=2 (full 0):  </li>
<li>PSYoungGen      total 18688K, used 16704K [0x00000000fd800000, 0x00000000ffc80000, 0x0000000100000000)  </li>
<li>eden space 16064K, 100% used [0x00000000fd800000,0x00000000fe7b0000,0x00000000fe7b0000)  </li>
<li>from space 2624K, 24% used [0x00000000fe7b0000,0x00000000fe850030,0x00000000fea40000)  </li>
<li>to   space 2624K, 0% used [0x00000000ff9f0000,0x00000000ff9f0000,0x00000000ffc80000)  </li>
<li>ParOldGen       total 42688K, used 15360K [0x00000000f9c00000, 0x00000000fc5b0000, 0x00000000fd800000)  </li>
<li>object space 42688K, 35% used [0x00000000f9c00000,0x00000000fab00010,0x00000000fc5b0000)  </li>
<li>PSPermGen       total 21248K, used 2498K [0x00000000f4a00000, 0x00000000f5ec0000, 0x00000000f9c00000)  </li>
<li>object space 21248K, 11% used [0x00000000f4a00000,0x00000000f4c708a0,0x00000000f5ec0000)  </li>
<li>TLAB: gc thread: 0x00000000022a5800 [id: 10100] desired_size: 321KB slow allocs: 0  refill waste: 5136B alloc: 0.99998    16064KB refills: 1 waste 100.0% gc: 328952B slow: 0B fast: 0B  </li>
<li>TLAB: gc thread: 0x000000000229e800 [id: 3928] desired_size: 321KB slow allocs: 0  refill waste: 5136B alloc: 0.99998    16064KB refills: 1 waste 100.0% gc: 328984B slow: 0B fast: 0B  </li>
<li>TLAB totals: thrds: 2  refills: 2 max: 1 slow allocs: 0 max 0 waste: 100.0% gc: 657936B max: 328984B slow: 0B max: 0B fast: 0B max: 0B  </li>
<li>[GC  </li>
<li>Desired survivor size 2686976 bytes, new threshold 7 (max 15)  </li>
<li>[PSYoungGen: 16704K-&gt;520K(34752K)] 32064K-&gt;15880K(77440K), 0.0012669 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]   </li>
<li>Heap after GC invocations=2 (full 0):  </li>
<li>PSYoungGen      total 34752K, used 520K [0x00000000fd800000, 0x00000000ffc80000, 0x0000000100000000)  </li>
<li>eden space 32128K, 0% used [0x00000000fd800000,0x00000000fd800000,0x00000000ff760000)  </li>
<li>from space 2624K, 19% used [0x00000000ff9f0000,0x00000000ffa72020,0x00000000ffc80000)  </li>
<li>to   space 2624K, 0% used [0x00000000ff760000,0x00000000ff760000,0x00000000ff9f0000)  </li>
<li>ParOldGen       total 42688K, used 15360K [0x00000000f9c00000, 0x00000000fc5b0000, 0x00000000fd800000)  </li>
<li>object space 42688K, 35% used [0x00000000f9c00000,0x00000000fab00010,0x00000000fc5b0000)  </li>
<li>PSPermGen       total 21248K, used 2498K [0x00000000f4a00000, 0x00000000f5ec0000, 0x00000000f9c00000)  </li>
<li>object space 21248K, 11% used [0x00000000f4a00000,0x00000000f4c708a0,0x00000000f5ec0000)  </li>
<li>}  </li>
<li>Heap  </li>
<li>PSYoungGen      total 34752K, used 1162K [0x00000000fd800000, 0x00000000ffc80000, 0x0000000100000000)  </li>
<li>eden space 32128K, 2% used [0x00000000fd800000,0x00000000fd8a0ab0,0x00000000ff760000)  </li>
<li>from space 2624K, 19% used [0x00000000ff9f0000,0x00000000ffa72020,0x00000000ffc80000)  </li>
<li>to   space 2624K, 0% used [0x00000000ff760000,0x00000000ff760000,0x00000000ff9f0000)  </li>
<li>ParOldGen       total 42688K, used 15360K [0x00000000f9c00000, 0x00000000fc5b0000, 0x00000000fd800000)  </li>
<li>object space 42688K, 35% used [0x00000000f9c00000,0x00000000fab00010,0x00000000fc5b0000)  </li>
<li>PSPermGen       total 21248K, used 2505K [0x00000000f4a00000, 0x00000000f5ec0000, 0x00000000f9c00000)  </li>
<li><p>object space 21248K, 11% used [0x00000000f4a00000,0x00000000f4c72638,0x00000000f5ec0000)<br>D:\test\pstest&gt;java -Xmx100M -XX:+PrintGCDetails -XX:+PrintHeapAtGC -XX:+PrintTLAB -XX:MaxNewSize=40M -XX:+PrintTenuringDistribution PSAllocTest {Heap before GC invocations=1 (full 0): PSYoungGen total 18688K, used 16002K [0x00000000fd800000, 0x00000000fecd0000, 0x0000000100000000) eden space 16064K, 99% used [0x00000000fd800000,0x00000000fe7a0b60,0x00000000fe7b0000) from space 2624K, 0% used [0x00000000fea40000,0x00000000fea40000,0x00000000fecd0000) to space 2624K, 0% used [0x00000000fe7b0000,0x00000000fe7b0000,0x00000000fea40000) ParOldGen total 42688K, used 0K [0x00000000f9c00000, 0x00000000fc5b0000, 0x00000000fd800000) object space 42688K, 0% used [0x00000000f9c00000,0x00000000f9c00000,0x00000000fc5b0000) PSPermGen total 21248K, used 2495K [0x00000000f4a00000, 0x00000000f5ec0000, 0x00000000f9c00000) object space 21248K, 11% used [0x00000000f4a00000,0x00000000f4c6fc80,0x00000000f5ec0000) TLAB: gc thread: 0x000000000028c000 [id: 10344] desired_size: 321KB slow allocs: 3 refill waste: 5232B alloc: 0.99998 16003KB refills: 2 waste 6.2% gc: 40912B slow: 40B fast: 0B TLAB totals: thrds: 1 refills: 2 max: 2 slow allocs: 3 max 3 waste: 6.2% gc: 40912B max: 40912B slow: 40B max: 40B fast: 0B max: 0B [GC Desired survivor size 2686976 bytes, new threshold 7 (max 15) [PSYoungGen: 16002K-&gt;640K(18688K)] 16002K-&gt;640K(61376K), 0.0015035 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] Heap after GC invocations=1 (full 0): PSYoungGen total 18688K, used 640K [0x00000000fd800000, 0x00000000ffc80000, 0x0000000100000000) eden space 16064K, 0% used [0x00000000fd800000,0x00000000fd800000,0x00000000fe7b0000) from space 2624K, 24% used [0x00000000fe7b0000,0x00000000fe850030,0x00000000fea40000) to space 2624K, 0% used [0x00000000ff9f0000,0x00000000ff9f0000,0x00000000ffc80000) ParOldGen total 42688K, used 0K [0x00000000f9c00000, 0x00000000fc5b0000, 0x00000000fd800000) object space 42688K, 0% used [0x00000000f9c00000,0x00000000f9c00000,0x00000000fc5b0000) PSPermGen total 21248K, used 2495K [0x00000000f4a00000, 0x00000000f5ec0000, 0x00000000f9c00000) object space 21248K, 11% used [0x00000000f4a00000,0x00000000f4c6fc80,0x00000000f5ec0000) } {Heap before GC invocations=2 (full 0): PSYoungGen total 18688K, used 16704K [0x00000000fd800000, 0x00000000ffc80000, 0x0000000100000000) eden space 16064K, 100% used [0x00000000fd800000,0x00000000fe7b0000,0x00000000fe7b0000) from space 2624K, 24% used [0x00000000fe7b0000,0x00000000fe850030,0x00000000fea40000) to space 2624K, 0% used [0x00000000ff9f0000,0x00000000ff9f0000,0x00000000ffc80000) ParOldGen total 42688K, used 15360K [0x00000000f9c00000, 0x00000000fc5b0000, 0x00000000fd800000) object space 42688K, 35% used [0x00000000f9c00000,0x00000000fab00010,0x00000000fc5b0000) PSPermGen total 21248K, used 2498K [0x00000000f4a00000, 0x00000000f5ec0000, 0x00000000f9c00000) object space 21248K, 11% used [0x00000000f4a00000,0x00000000f4c708a0,0x00000000f5ec0000) TLAB: gc thread: 0x00000000022a5800 [id: 10100] desired_size: 321KB slow allocs: 0 refill waste: 5136B alloc: 0.99998 16064KB refills: 1 waste 100.0% gc: 328952B slow: 0B fast: 0B TLAB: gc thread: 0x000000000229e800 [id: 3928] desired_size: 321KB slow allocs: 0 refill waste: 5136B alloc: 0.99998 16064KB refills: 1 waste 100.0% gc: 328984B slow: 0B fast: 0B TLAB totals: thrds: 2 refills: 2 max: 1 slow allocs: 0 max 0 waste: 100.0% gc: 657936B max: 328984B slow: 0B max: 0B fast: 0B max: 0B [GC Desired survivor size 2686976 bytes, new threshold 7 (max 15) [PSYoungGen: 16704K-&gt;520K(34752K)] 32064K-&gt;15880K(77440K), 0.0012669 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] Heap after GC invocations=2 (full 0): PSYoungGen total 34752K, used 520K <a href="&quot;复制代码&quot;">0x00000000fd800000, 0x00000000ffc80000, 0x0000000100000000) eden space 32128K, 0% used [0x00000000fd800000,0x00000000fd800000,0x00000000ff760000) from space 2624K, 19% used [0x00000000ff9f0000,0x00000000ffa72020,0x00000000ffc80000) to space 2624K, 0% used [0x00000000ff760000,0x00000000ff760000,0x00000000ff9f0000) ParOldGen total 42688K, used 15360K [0x00000000f9c00000, 0x00000000fc5b0000, 0x00000000fd800000) object space 42688K, 35% used [0x00000000f9c00000,0x00000000fab00010,0x00000000fc5b0000) PSPermGen total 21248K, used 2498K [0x00000000f4a00000, 0x00000000f5ec0000, 0x00000000f9c00000) object space 21248K, 11% used [0x00000000f4a00000,0x00000000f4c708a0,0x00000000f5ec0000) } Heap PSYoungGen total 34752K, used 1162K [0x00000000fd800000, 0x00000000ffc80000, 0x0000000100000000) eden space 32128K, 2% used [0x00000000fd800000,0x00000000fd8a0ab0,0x00000000ff760000) from space 2624K, 19% used [0x00000000ff9f0000,0x00000000ffa72020,0x00000000ffc80000) to space 2624K, 0% used [0x00000000ff760000,0x00000000ff760000,0x00000000ff9f0000) ParOldGen total 42688K, used 15360K [0x00000000f9c00000, 0x00000000fc5b0000, 0x00000000fd800000) object space 42688K, 35% used [0x00000000f9c00000,0x00000000fab00010,0x00000000fc5b0000) PSPermGen total 21248K, used 2505K [0x00000000f4a00000, 0x00000000f5ec0000, 0x00000000f9c00000) object space 21248K, 11% used [0x00000000f4a00000,0x00000000f4c72638,0x00000000f5ec0000)
加上-XX:+PrintHeapAtGC可以看到每次GC前后堆布局的情况；加上-XX:+PrintTLAB可以看到TLAB的使用状况。
从日志可以看到，这个线程的TLAB才只有321KB，不足以分配楼主例子里的任何一个数组。也就是说例子里的数组全部都不是在TLAB里分配的，而是直接分配在GC堆的共享部分。
我们可以模拟一下楼主的例子的执行过程。整个例子都肯定是在解释器里跑的，所以我们就从解释器来切入。
分配第一个5MB的数组时，解释器要执行newarray字节码指令，来到这里：
hotspot/src/share/vm/interpreter/interpreterRuntime.cpp
C++代码 [<img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>IRT_ENTRY(void, InterpreterRuntime::newarray(JavaThread/* thread, BasicType type, jint size))  </p>
</li>
<li>oop obj = oopFactory::new_typeArray(type, size, CHECK);  </li>
<li>thread-&gt;set_vm_result(obj);  </li>
<li><p>IRT_END<br>IRT_ENTRY(void, InterpreterRuntime::newarray(JavaThread/* thread, BasicType type, jint size)) oop obj = oopFactory::new_typeArray(type, size, CHECK); thread-&gt;set_vm_result(obj); IRT_END
里面调用到：
hotspot/src/share/vm/memory/oopFactory.cpp
C++代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>typeArrayOop oopFactory::new_typeArray(BasicType type, int length, TRAPS) {  </p>
</li>
<li>klassOop type_asKlassOop = Universe::typeArrayKlassObj(type);  </li>
<li>typeArrayKlass/* type_asArrayKlass = typeArrayKlass::cast(type_asKlassOop);  </li>
<li>typeArrayOop result = type_asArrayKlass-&gt;allocate(length, THREAD);  </li>
<li>return result;  </li>
<li><p>}<br>typeArrayOop oopFactory::new_typeArray(BasicType type, int length, TRAPS) { klassOop type_asKlassOop = Universe::typeArrayKlassObj(type); typeArrayKlass/* type_asArrayKlass = typeArrayKlass::cast(type_asKlassOop); typeArrayOop result = type_asArrayKlass-&gt;allocate(length, THREAD); return result; }
进一步调用到：
hotspot/src/share/vm/oops/typeArrayKlass.cpp
C++代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>typeArrayOop typeArrayKlass::allocate(int length, TRAPS) {  </p>
</li>
<li>assert(log2_element_size() &gt;= 0, &quot;bad scale&quot;);  </li>
<li>if (length &gt;= 0) {  </li>
<li>if (length &lt;= max_length()) {  </li>
<li>size_t size = typeArrayOopDesc::object_size(layout_helper(), length);  </li>
<li>KlassHandle h_k(THREAD, as_klassOop());  </li>
<li>typeArrayOop t;  </li>
<li>CollectedHeap/* ch = Universe::heap();  </li>
<li>if (size &lt; ch-&gt;large_typearray_limit()) {  </li>
<li>t = (typeArrayOop)CollectedHeap::array_allocate(h_k, (int)size, length, CHECK_NULL);  </li>
<li>} else {  </li>
<li>t = (typeArrayOop)CollectedHeap::large_typearray_allocate(h_k, (int)size, length, CHECK_NULL);  </li>
<li>}  </li>
<li>assert(t-&gt;is_parsable(), &quot;Don&#39;t publish unless parsable&quot;);  </li>
<li>return t;  </li>
<li>} else {  </li>
<li>report_java_out_of_memory(&quot;Requested array size exceeds VM limit&quot;);  </li>
<li>THROW_OOP_0(Universe::out_of_memory_error_array_size());  </li>
<li>}  </li>
<li>} else {  </li>
<li>THROW_0(vmSymbols::java_lang_NegativeArraySizeException());  </li>
<li>}  </li>
<li><p>}<br>typeArrayOop typeArrayKlass::allocate(int length, TRAPS) { assert(log2_element_size() &gt;= 0, &quot;bad scale&quot;); if (length &gt;= 0) { if (length &lt;= max_length()) { size_t size = typeArrayOopDesc::object_size(layout_helper(), length); KlassHandle h_k(THREAD, as_klassOop()); typeArrayOop t; CollectedHeap/* ch = Universe::heap(); if (size &lt; ch-&gt;large_typearray_limit()) { t = (typeArrayOop)CollectedHeap::array_allocate(h_k, (int)size, length, CHECK_NULL); } else { t = (typeArrayOop)CollectedHeap::large_typearray_allocate(h_k, (int)size, length, CHECK_NULL); } assert(t-&gt;is_parsable(), &quot;Don&#39;t publish unless parsable&quot;); return t; } else { report_java_out_of_memory(&quot;Requested array size exceeds VM limit&quot;); THROW_OOP_0(Universe::out_of_memory_error_array_size()); } } else { THROW_0(vmSymbols::java_lang_NegativeArraySizeException()); } }
这个地方我们看到代码根据要分配的数组是否大于large_typearray_limit()做了分支。那么这个界限是多大呢？
hotspot/src/share/vm/gc_implementation/parallelScavenge/parallelScavengeHeap.hpp
C++代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>size_t large_typearray_limit() { return FastAllocateSizeLimit; }<br>size_t large_typearray_limit() { return FastAllocateSizeLimit; }
hotspot/src/share/vm/runtime/globals.hpp
C++代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>develop(intx, FastAllocateSizeLimit, 128/*K,                               \  </p>
</li>
<li>//<em> Note:  This value is zero mod 1&lt;&lt;13 for a cheap sparc set. /</em>/  \  </li>
<li><p>&quot;Inline allocations larger than this in doublewords must go slow&quot;)\<br>develop(intx, FastAllocateSizeLimit, 128/<em>K, \ //</em> Note: This value is zero mod 1&lt;&lt;13 for a cheap sparc set. /*/ \ &quot;Inline allocations larger than this in doublewords must go slow&quot;)\
这里我们知道了如果对象大小大于128K个doubleword（8字节单元），也就是1MB，就不会进入快速分配路径，而会走慢速分配路径。楼主例子里的数组全部都大于1MB，所以都肯定会走满足分配路径。
不过其实具体到现在HotSpot VM的实现，FastAllocateSizeLimit参数的影响甚微。
它最明显的作用就是让HotSpot Server Compiler（C2）在编译Java方法时看到要分配大于该参数指定的大小的对象时不生成快速分配路径的代码，而直接调用回到VM的慢速分配路径。
而对ParallelScanvege GC来说，这个参数其实设到多少都不影响该GC的行为：本来它就只间接影响到下面讲到的is_noref参数的值，但ParallelScavenge无视了is_noref参数。
回到分配的模拟。接下来调用到：
hotspot/src/share/vm/gc_interface/collectedHeap.inline.hpp
C++代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>oop CollectedHeap::large_typearray_allocate(KlassHandle klass,  </p>
</li>
<li>int size,  </li>
<li>int length,  </li>
<li>TRAPS) {  </li>
<li>debug_only(check_for_valid_allocation_state());  </li>
<li>assert(!Universe::heap()-&gt;is_gc_active(), &quot;Allocation during gc not allowed&quot;);  </li>
<li>assert(size &gt;= 0, &quot;int won&#39;t convert to size_t&quot;);  </li>
<li>HeapWord/* obj = common_mem_allocate_init(size, true, CHECK_NULL);  </li>
<li>post_allocation_setup_array(klass, obj, size, length);  </li>
<li>NOT_PRODUCT(Universe::heap()-&gt;check_for_bad_heap_word_value(obj, size));  </li>
<li>return (oop)obj;  </li>
<li><p>}<br>oop CollectedHeap::large_typearray_allocate(KlassHandle klass, int size, int length, TRAPS) { debug_only(check_for_valid_allocation_state()); assert(!Universe::heap()-&gt;is_gc_active(), &quot;Allocation during gc not allowed&quot;); assert(size &gt;= 0, &quot;int won&#39;t convert to size_t&quot;); HeapWord/* obj = common_mem_allocate_init(size, true, CHECK_NULL); post_allocation_setup_array(klass, obj, size, length); NOT_PRODUCT(Universe::heap()-&gt;check_for_bad_heap_word_value(obj, size)); return (oop)obj; }
这里留意它传给common_mem_allocate_init()的is_noref参数为true，就是说不要refill TLAB。
同一文件里，
C++代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>HeapWord/* CollectedHeap::common_mem_allocate_noinit(size_t size, bool is_noref, TRAPS) {  </p>
</li>
<li></li>
<li>// Clear unhandled oops for memory allocation.  Memory allocation might  </li>
<li>// not take out a lock if from tlab, so clear here.  </li>
<li>CHECK_UNHANDLED_OOPS_ONLY(THREAD-&gt;clear_unhandled_oops();)  </li>
<li></li>
<li>if (HAS_PENDING_EXCEPTION) {  </li>
<li>NOT_PRODUCT(guarantee(false, &quot;Should not allocate with exception pending&quot;));  </li>
<li>return NULL;  // caller does a CHECK_0 too  </li>
<li>}  </li>
<li></li>
<li>// We may want to update this, is_noref objects might not be allocated in TLABs.  </li>
<li>HeapWord/* result = NULL;  </li>
<li>if (UseTLAB) {  </li>
<li>result = CollectedHeap::allocate_from_tlab(THREAD, size);  </li>
<li>if (result != NULL) {  </li>
<li>assert(!HAS_PENDING_EXCEPTION,  </li>
<li>&quot;Unexpected exception, will result in uninitialized storage&quot;);  </li>
<li>return result;  </li>
<li>}  </li>
<li>}  </li>
<li>bool gc_overhead_limit_was_exceeded = false;  </li>
<li>result = Universe::heap()-&gt;mem_allocate(size,  </li>
<li>is_noref,  </li>
<li>false,  </li>
<li>&amp;gc_overhead_limit_was_exceeded);  </li>
<li>if (result != NULL) {  </li>
<li>NOT_PRODUCT(Universe::heap()-&gt;  </li>
<li>check_for_non_bad_heap_word_value(result, size));  </li>
<li>assert(!HAS_PENDING_EXCEPTION,  </li>
<li>&quot;Unexpected exception, will result in uninitialized storage&quot;);  </li>
<li>THREAD-&gt;incr_allocated_bytes(size /* HeapWordSize);  </li>
<li>return result;  </li>
<li>}  </li>
<li></li>
<li></li>
<li>if (!gc_overhead_limit_was_exceeded) {  </li>
<li>// -XX:+HeapDumpOnOutOfMemoryError and -XX:OnOutOfMemoryError support  </li>
<li>report_java_out_of_memory(&quot;Java heap space&quot;);  </li>
<li></li>
<li>if (JvmtiExport::should_post_resource_exhausted()) {  </li>
<li>JvmtiExport::post_resource_exhausted(  </li>
<li>JVMTI_RESOURCE_EXHAUSTED_OOM_ERROR | JVMTI_RESOURCE_EXHAUSTED_JAVA_HEAP,  </li>
<li>&quot;Java heap space&quot;);  </li>
<li>}  </li>
<li></li>
<li>THROW_OOP_0(Universe::out_of_memory_error_java_heap());  </li>
<li>} else {  </li>
<li>// -XX:+HeapDumpOnOutOfMemoryError and -XX:OnOutOfMemoryError support  </li>
<li>report_java_out_of_memory(&quot;GC overhead limit exceeded&quot;);  </li>
<li></li>
<li>if (JvmtiExport::should_post_resource_exhausted()) {  </li>
<li>JvmtiExport::post_resource_exhausted(  </li>
<li>JVMTI_RESOURCE_EXHAUSTED_OOM_ERROR | JVMTI_RESOURCE_EXHAUSTED_JAVA_HEAP,  </li>
<li>&quot;GC overhead limit exceeded&quot;);  </li>
<li>}  </li>
<li></li>
<li>THROW_OOP_0(Universe::out_of_memory_error_gc_overhead_limit());  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>HeapWord/* CollectedHeap::common_mem_allocate_init(size_t size, bool is_noref, TRAPS) {  </li>
<li>HeapWord/* obj = common_mem_allocate_noinit(size, is_noref, CHECK_NULL);  </li>
<li>init_obj(obj, size);  </li>
<li>return obj;  </li>
<li><p>}<br>HeapWord/<em> CollectedHeap::common_mem_allocate_noinit(size_t size, bool is_noref, TRAPS) { // Clear unhandled oops for memory allocation. Memory allocation might // not take out a lock if from tlab, so clear here. CHECK_UNHANDLED_OOPS_ONLY(THREAD-&gt;clear_unhandled_oops();) if (HAS_PENDING_EXCEPTION) { NOT_PRODUCT(guarantee(false, &quot;Should not allocate with exception pending&quot;)); return NULL; // caller does a CHECK_0 too } // We may want to update this, is_noref objects might not be allocated in TLABs. HeapWord/</em> result = NULL; if (UseTLAB) { result = CollectedHeap::allocate_from_tlab(THREAD, size); if (result != NULL) { assert(!HAS_PENDING_EXCEPTION, &quot;Unexpected exception, will result in uninitialized storage&quot;); return result; } } bool gc_overhead_limit_was_exceeded = false; result = Universe::heap()-&gt;mem_allocate(size, is_noref, false, &amp;gc_overhead_limit_was_exceeded); if (result != NULL) { NOT_PRODUCT(Universe::heap()-&gt; check_for_non_bad_heap_word_value(result, size)); assert(!HAS_PENDING_EXCEPTION, &quot;Unexpected exception, will result in uninitialized storage&quot;); THREAD-&gt;incr_allocated_bytes(size /<em> HeapWordSize); return result; } if (!gc_overhead_limit_was_exceeded) { // -XX:+HeapDumpOnOutOfMemoryError and -XX:OnOutOfMemoryError support report_java_out_of_memory(&quot;Java heap space&quot;); if (JvmtiExport::should_post_resource_exhausted()) { JvmtiExport::post_resource_exhausted( JVMTI_RESOURCE_EXHAUSTED_OOM_ERROR | JVMTI_RESOURCE_EXHAUSTED_JAVA_HEAP, &quot;Java heap space&quot;); } THROW_OOP_0(Universe::out_of_memory_error_java_heap()); } else { // -XX:+HeapDumpOnOutOfMemoryError and -XX:OnOutOfMemoryError support report_java_out_of_memory(&quot;GC overhead limit exceeded&quot;); if (JvmtiExport::should_post_resource_exhausted()) { JvmtiExport::post_resource_exhausted( JVMTI_RESOURCE_EXHAUSTED_OOM_ERROR | JVMTI_RESOURCE_EXHAUSTED_JAVA_HEAP, &quot;GC overhead limit exceeded&quot;); } THROW_OOP_0(Universe::out_of_memory_error_gc_overhead_limit()); } } HeapWord/</em> CollectedHeap::common_mem_allocate_init(size_t size, bool is_noref, TRAPS) { HeapWord/* obj = common_mem_allocate_noinit(size, is_noref, CHECK_NULL); init_obj(obj, size); return obj; }
然后会先调用到：
hotspot/src/share/vm/gc_interface/collectedHeap.inline.hpp
C++代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>HeapWord/<em> CollectedHeap::allocate_from_tlab(Thread/</em> thread, size_t size) {  </p>
</li>
<li>assert(UseTLAB, &quot;should use UseTLAB&quot;);  </li>
<li></li>
<li>HeapWord/* obj = thread-&gt;tlab().allocate(size);  </li>
<li>if (obj != NULL) {  </li>
<li>return obj;  </li>
<li>}  </li>
<li>// Otherwise...  </li>
<li>return allocate_from_tlab_slow(thread, size);  </li>
<li><p>}<br>HeapWord/<em> CollectedHeap::allocate_from_tlab(Thread/</em> thread, size_t size) { assert(UseTLAB, &quot;should use UseTLAB&quot;); HeapWord/* obj = thread-&gt;tlab().allocate(size); if (obj != NULL) { return obj; } // Otherwise... return allocate_from_tlab_slow(thread, size); }
前面已经说了，TLAB的大小不足以分配楼主例子里的数组，所以thread-&gt;tlab().allocate()肯定会返回NULL表示无法分配，于是调用到：
hotspot/src/share/vm/gc_interface/collectedHeap.cpp
C++代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>HeapWord/<em> CollectedHeap::allocate_from_tlab_slow(Thread/</em> thread, size_t size) {  </p>
</li>
<li></li>
<li>// Retain tlab and allocate object in shared space if  </li>
<li>// the amount free in the tlab is too large to discard.  </li>
<li>if (thread-&gt;tlab().free() &gt; thread-&gt;tlab().refill_waste_limit()) {  </li>
<li>thread-&gt;tlab().record_slow_allocation(size);  </li>
<li>return NULL;  </li>
<li>}  </li>
<li>// ...  </li>
<li><p>}<br>HeapWord/<em> CollectedHeap::allocate_from_tlab_slow(Thread/</em> thread, size_t size) { // Retain tlab and allocate object in shared space if // the amount free in the tlab is too large to discard. if (thread-&gt;tlab().free() &gt; thread-&gt;tlab().refill_waste_limit()) { thread-&gt;tlab().record_slow_allocation(size); return NULL; } // ... }
例子里TLAB几乎是空的，所以这个if判断肯定会通过，TLAB就会记录下一次slow allocation。从GC日志中第一次minor GC的TLAB统计信息可以看到3次slow allocation，其实就是头两个数组（5MB和10MB那两个）成功分配后，第三个数组（又一个5MB的）尝试在TLAB分配失败后打出的日志。
那么回到CollectedHeap::common_mem_allocate_noinit()，它会调用Universe::heap()-&gt;mem_allocate(...)进一步尝试分配，传入的is_noref为true，is_tlab为false：
hotspot/src/share/vm/gc_implementation/parallelScavengeHeap.cpp
C++代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>// There are two levels of allocation policy here.  </p>
</li>
<li>//  </li>
<li>// When an allocation request fails, the requesting thread must invoke a VM  </li>
<li>// operation, transfer control to the VM thread, and await the results of a  </li>
<li>// garbage collection. That is quite expensive, and we should avoid doing it  </li>
<li>// multiple times if possible.  </li>
<li>//  </li>
<li>// To accomplish this, we have a basic allocation policy, and also a  </li>
<li>// failed allocation policy.  </li>
<li>//  </li>
<li>// The basic allocation policy controls how you allocate memory without  </li>
<li>// attempting garbage collection. It is okay to grab locks and  </li>
<li>// expand the heap, if that can be done without coming to a safepoint.  </li>
<li>// It is likely that the basic allocation policy will not be very  </li>
<li>// aggressive.  </li>
<li>//  </li>
<li>// The failed allocation policy is invoked from the VM thread after  </li>
<li>// the basic allocation policy is unable to satisfy a mem_allocate  </li>
<li>// request. This policy needs to cover the entire range of collection,  </li>
<li>// heap expansion, and out-of-memory conditions. It should make every  </li>
<li>// attempt to allocate the requested memory.  </li>
<li></li>
<li>// Basic allocation policy. Should never be called at a safepoint, or  </li>
<li>// from the VM thread.  </li>
<li>//  </li>
<li>// This method must handle cases where many mem_allocate requests fail  </li>
<li>// simultaneously. When that happens, only one VM operation will succeed,  </li>
<li>// and the rest will not be executed. For that reason, this method loops  </li>
<li>// during failed allocation attempts. If the java heap becomes exhausted,  </li>
<li>// we rely on the size_policy object to force a bail out.  </li>
<li>HeapWord/* ParallelScavengeHeap::mem_allocate(  </li>
<li>size_t size,  </li>
<li>bool is_noref,  </li>
<li>bool is_tlab,  </li>
<li>bool/* gc_overhead_limit_was_exceeded) {  </li>
<li>assert(!SafepointSynchronize::is_at_safepoint(), &quot;should not be at safepoint&quot;);  </li>
<li>assert(Thread::current() != (Thread/*)VMThread::vm_thread(), &quot;should not be in vm thread&quot;);  </li>
<li>assert(!Heap_lock-&gt;owned_by_self(), &quot;this thread should not own the Heap_lock&quot;);  </li>
<li></li>
<li>// In general gc_overhead_limit_was_exceeded should be false so  </li>
<li>// set it so here and reset it to true only if the gc time  </li>
<li>// limit is being exceeded as checked below.  </li>
<li>/*gc_overhead_limit_was_exceeded = false;  </li>
<li></li>
<li>HeapWord/* result = young_gen()-&gt;allocate(size, is_tlab);  </li>
<li></li>
<li>uint loop_count = 0;  </li>
<li>uint gc_count = 0;  </li>
<li></li>
<li>while (result == NULL) {  </li>
<li>// We don&#39;t want to have multiple collections for a single filled generation.  </li>
<li>// To prevent this, each thread tracks the total_collections() value, and if  </li>
<li>// the count has changed, does not do a new collection.  </li>
<li>//  </li>
<li>// The collection count must be read only while holding the heap lock. VM  </li>
<li>// operations also hold the heap lock during collections. There is a lock  </li>
<li>// contention case where thread A blocks waiting on the Heap_lock, while  </li>
<li>// thread B is holding it doing a collection. When thread A gets the lock,  </li>
<li>// the collection count has already changed. To prevent duplicate collections,  </li>
<li>// The policy MUST attempt allocations during the same period it reads the  </li>
<li>// total_collections() value!  </li>
<li>{  </li>
<li>MutexLocker ml(Heap_lock);  </li>
<li>gc_count = Universe::heap()-&gt;total_collections();  </li>
<li></li>
<li>result = young_gen()-&gt;allocate(size, is_tlab);  </li>
<li></li>
<li>// (1) If the requested object is too large to easily fit in the  </li>
<li>//     young_gen, or  </li>
<li>// (2) If GC is locked out via GCLocker, young gen is full and  </li>
<li>//     the need for a GC already signalled to GCLocker (done  </li>
<li>//     at a safepoint),  </li>
<li>// ... then, rather than force a safepoint and (a potentially futile)  </li>
<li>// collection (attempt) for each allocation, try allocation directly  </li>
<li>// in old_gen. For case (2) above, we may in the future allow  </li>
<li>// TLAB allocation directly in the old gen.  </li>
<li>if (result != NULL) {  </li>
<li>return result;  </li>
<li>}  </li>
<li>if (!is_tlab &amp;&amp;  </li>
<li>size &gt;= (young_gen()-&gt;eden_space()-&gt;capacity_in_words(Thread::current()) / 2)) {  </li>
<li>result = old_gen()-&gt;allocate(size, is_tlab);  </li>
<li>if (result != NULL) {  </li>
<li>return result;  </li>
<li>}  </li>
<li>}  </li>
<li>if (GC_locker::is_active_and_needs_gc()) {  </li>
<li>// GC is locked out. If this is a TLAB allocation,  </li>
<li>// return NULL; the requestor will retry allocation  </li>
<li>// of an idividual object at a time.  </li>
<li>if (is_tlab) {  </li>
<li>return NULL;  </li>
<li>}  </li>
<li></li>
<li>// If this thread is not in a jni critical section, we stall  </li>
<li>// the requestor until the critical section has cleared and  </li>
<li>// GC allowed. When the critical section clears, a GC is  </li>
<li>// initiated by the last thread exiting the critical section; so  </li>
<li>// we retry the allocation sequence from the beginning of the loop,  </li>
<li>// rather than causing more, now probably unnecessary, GC attempts.  </li>
<li>JavaThread/* jthr = JavaThread::current();  </li>
<li>if (!jthr-&gt;in_critical()) {  </li>
<li>MutexUnlocker mul(Heap_lock);  </li>
<li>GC_locker::stall_until_clear();  </li>
<li>continue;  </li>
<li>} else {  </li>
<li>if (CheckJNICalls) {  </li>
<li>fatal(&quot;Possible deadlock due to allocating while&quot;  </li>
<li>&quot; in jni critical section&quot;);  </li>
<li>}  </li>
<li>return NULL;  </li>
<li>}  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>if (result == NULL) {  </li>
<li></li>
<li>// Generate a VM operation  </li>
<li>VM_ParallelGCFailedAllocation op(size, is_tlab, gc_count);  </li>
<li>VMThread::execute(&amp;op);  </li>
<li></li>
<li>// Did the VM operation execute? If so, return the result directly.  </li>
<li>// This prevents us from looping until time out on requests that can  </li>
<li>// not be satisfied.  </li>
<li>if (op.prologue_succeeded()) {  </li>
<li>assert(Universe::heap()-&gt;is_in_or_null(op.result()),  </li>
<li>&quot;result not in heap&quot;);  </li>
<li></li>
<li>// If GC was locked out during VM operation then retry allocation  </li>
<li>// and/or stall as necessary.  </li>
<li>if (op.gc_locked()) {  </li>
<li>assert(op.result() == NULL, &quot;must be NULL if gc_locked() is true&quot;);  </li>
<li>continue;  // retry and/or stall as necessary  </li>
<li>}  </li>
<li></li>
<li>// Exit the loop if the gc time limit has been exceeded.  </li>
<li>// The allocation must have failed above (&quot;result&quot; guarding  </li>
<li>// this path is NULL) and the most recent collection has exceeded the  </li>
<li>// gc overhead limit (although enough may have been collected to  </li>
<li>// satisfy the allocation).  Exit the loop so that an out-of-memory  </li>
<li>// will be thrown (return a NULL ignoring the contents of  </li>
<li>// op.result()),  </li>
<li>// but clear gc_overhead_limit_exceeded so that the next collection  </li>
<li>// starts with a clean slate (i.e., forgets about previous overhead  </li>
<li>// excesses).  Fill op.result() with a filler object so that the  </li>
<li>// heap remains parsable.  </li>
<li>const bool limit_exceeded = size_policy()-&gt;gc_overhead_limit_exceeded();  </li>
<li>const bool softrefs_clear = collector_policy()-&gt;all_soft_refs_clear();  </li>
<li>assert(!limit_exceeded || softrefs_clear, &quot;Should have been cleared&quot;);  </li>
<li>if (limit_exceeded &amp;&amp; softrefs_clear) {  </li>
<li>/*gc_overhead_limit_was_exceeded = true;  </li>
<li>size_policy()-&gt;set_gc_overhead_limit_exceeded(false);  </li>
<li>if (PrintGCDetails &amp;&amp; Verbose) {  </li>
<li>gclog_or_tty-&gt;print_cr(&quot;ParallelScavengeHeap::mem_allocate: &quot;  </li>
<li>&quot;return NULL because gc_overhead_limit_exceeded is set&quot;);  </li>
<li>}  </li>
<li>if (op.result() != NULL) {  </li>
<li>CollectedHeap::fill_with_object(op.result(), size);  </li>
<li>}  </li>
<li>return NULL;  </li>
<li>}  </li>
<li></li>
<li>return op.result();  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>// The policy object will prevent us from looping forever. If the  </li>
<li>// time spent in gc crosses a threshold, we will bail out.  </li>
<li>loop_count++;  </li>
<li>if ((result == NULL) &amp;&amp; (QueuedAllocationWarningCount &gt; 0) &amp;&amp;  </li>
<li>(loop_count % QueuedAllocationWarningCount == 0)) {  </li>
<li>warning(&quot;ParallelScavengeHeap::mem_allocate retries %d times \n\t&quot;  </li>
<li>&quot; size=%d %s&quot;, loop_count, size, is_tlab ? &quot;(TLAB)&quot; : &quot;&quot;);  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>return result;  </li>
<li><p>}<br>// There are two levels of allocation policy here. // // When an allocation request fails, the requesting thread must invoke a VM // operation, transfer control to the VM thread, and await the results of a // garbage collection. That is quite expensive, and we should avoid doing it // multiple times if possible. // // To accomplish this, we have a basic allocation policy, and also a // failed allocation policy. // // The basic allocation policy controls how you allocate memory without // attempting garbage collection. It is okay to grab locks and // expand the heap, if that can be done without coming to a safepoint. // It is likely that the basic allocation policy will not be very // aggressive. // // The failed allocation policy is invoked from the VM thread after // the basic allocation policy is unable to satisfy a mem_allocate // request. This policy needs to cover the entire range of collection, // heap expansion, and out-of-memory conditions. It should make every // attempt to allocate the requested memory. // Basic allocation policy. Should never be called at a safepoint, or // from the VM thread. // // This method must handle cases where many mem_allocate requests fail // simultaneously. When that happens, only one VM operation will succeed, // and the rest will not be executed. For that reason, this method loops // during failed allocation attempts. If the java heap becomes exhausted, // we rely on the size_policy object to force a bail out. HeapWord/<em> ParallelScavengeHeap::mem_allocate( size_t size, bool is_noref, bool is_tlab, bool/</em> gc_overhead_limit_was_exceeded) { assert(!SafepointSynchronize::is_at_safepoint(), &quot;should not be at safepoint&quot;); assert(Thread::current() != (Thread/<em>)VMThread::vm_thread(), &quot;should not be in vm thread&quot;); assert(!Heap_lock-&gt;owned_by_self(), &quot;this thread should not own the Heap_lock&quot;); // In general gc_overhead_limit_was_exceeded should be false so // set it so here and reset it to true only if the gc time // limit is being exceeded as checked below. /</em>gc_overhead_limit_was_exceeded = false; HeapWord/<em> result = young_gen()-&gt;allocate(size, is_tlab); uint loop_count = 0; uint gc_count = 0; while (result == NULL) { // We don&#39;t want to have multiple collections for a single filled generation. // To prevent this, each thread tracks the total_collections() value, and if // the count has changed, does not do a new collection. // // The collection count must be read only while holding the heap lock. VM // operations also hold the heap lock during collections. There is a lock // contention case where thread A blocks waiting on the Heap_lock, while // thread B is holding it doing a collection. When thread A gets the lock, // the collection count has already changed. To prevent duplicate collections, // The policy MUST attempt allocations during the same period it reads the // total_collections() value! { MutexLocker ml(Heap_lock); gc_count = Universe::heap()-&gt;total_collections(); result = young_gen()-&gt;allocate(size, is_tlab); // (1) If the requested object is too large to easily fit in the // young_gen, or // (2) If GC is locked out via GCLocker, young gen is full and // the need for a GC already signalled to GCLocker (done // at a safepoint), // ... then, rather than force a safepoint and (a potentially futile) // collection (attempt) for each allocation, try allocation directly // in old_gen. For case (2) above, we may in the future allow // TLAB allocation directly in the old gen. if (result != NULL) { return result; } if (!is_tlab &amp;&amp; size &gt;= (young_gen()-&gt;eden_space()-&gt;capacity_in_words(Thread::current()) / 2)) { result = old_gen()-&gt;allocate(size, is_tlab); if (result != NULL) { return result; } } if (GC_locker::is_active_and_needs_gc()) { // GC is locked out. If this is a TLAB allocation, // return NULL; the requestor will retry allocation // of an idividual object at a time. if (is_tlab) { return NULL; } // If this thread is not in a jni critical section, we stall // the requestor until the critical section has cleared and // GC allowed. When the critical section clears, a GC is // initiated by the last thread exiting the critical section; so // we retry the allocation sequence from the beginning of the loop, // rather than causing more, now probably unnecessary, GC attempts. JavaThread/</em> jthr = JavaThread::current(); if (!jthr-&gt;in_critical()) { MutexUnlocker mul(Heap_lock); GC_locker::stall_until_clear(); continue; } else { if (CheckJNICalls) { fatal(&quot;Possible deadlock due to allocating while&quot; &quot; in jni critical section&quot;); } return NULL; } } } if (result == NULL) { // Generate a VM operation VM_ParallelGCFailedAllocation op(size, is_tlab, gc_count); VMThread::execute(&amp;op); // Did the VM operation execute? If so, return the result directly. // This prevents us from looping until time out on requests that can // not be satisfied. if (op.prologue_succeeded()) { assert(Universe::heap()-&gt;is_in_or_null(op.result()), &quot;result not in heap&quot;); // If GC was locked out during VM operation then retry allocation // and/or stall as necessary. if (op.gc_locked()) { assert(op.result() == NULL, &quot;must be NULL if gc_locked() is true&quot;); continue; // retry and/or stall as necessary } // Exit the loop if the gc time limit has been exceeded. // The allocation must have failed above (&quot;result&quot; guarding // this path is NULL) and the most recent collection has exceeded the // gc overhead limit (although enough may have been collected to // satisfy the allocation). Exit the loop so that an out-of-memory // will be thrown (return a NULL ignoring the contents of // op.result()), // but clear gc_overhead_limit_exceeded so that the next collection // starts with a clean slate (i.e., forgets about previous overhead // excesses). Fill op.result() with a filler object so that the // heap remains parsable. const bool limit_exceeded = size_policy()-&gt;gc_overhead_limit_exceeded(); const bool softrefs_clear = collector_policy()-&gt;all_soft_refs_clear(); assert(!limit_exceeded || softrefs_clear, &quot;Should have been cleared&quot;); if (limit_exceeded &amp;&amp; softrefs_clear) { /*gc_overhead_limit_was_exceeded = true; size_policy()-&gt;set_gc_overhead_limit_exceeded(false); if (PrintGCDetails &amp;&amp; Verbose) { gclog_or_tty-&gt;print_cr(&quot;ParallelScavengeHeap::mem_allocate: &quot; &quot;return NULL because gc_overhead_limit_exceeded is set&quot;); } if (op.result() != NULL) { CollectedHeap::fill_with_object(op.result(), size); } return NULL; } return op.result(); } } // The policy object will prevent us from looping forever. If the // time spent in gc crosses a threshold, we will bail out. loop_count++; if ((result == NULL) &amp;&amp; (QueuedAllocationWarningCount &gt; 0) &amp;&amp; (loop_count % QueuedAllocationWarningCount == 0)) { warning(&quot;ParallelScavengeHeap::mem_allocate retries %d times \n\t&quot; &quot; size=%d %s&quot;, loop_count, size, is_tlab ? &quot;(TLAB)&quot; : &quot;&quot;); } } return result; }
这里会先尝试在young gen里分配
C++代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>// Allocation  </p>
</li>
<li>HeapWord/* allocate(size_t word_size, bool is_tlab) {  </li>
<li>HeapWord/* result = eden_space()-&gt;cas_allocate(word_size);  </li>
<li>return result;  </li>
<li><p>}<br>// Allocation HeapWord/<em> allocate(size_t word_size, bool is_tlab) { HeapWord/</em> result = eden_space()-&gt;cas_allocate(word_size); return result; }
实际上就是尝试在eden里做一次CAS分配。楼主例子里的头两个数组都会在这里分配成功，把eden占用到99%。然后到第三个数组触发GC前试图分配的时候，eden已经没有足够空间了，分配就会失败从而返回NULL。
然后就开始进入“试图分配 -&gt; 不行的话GC -&gt; 再试图分配 -&gt; 不行的话再GC -&gt; 再试图分配”的循环。
做了第一次minor GC后，头两个数组都被GC掉了，eden为空，于是再试图在young gen里分配第三个数组（5MB那个）就成功了。第四个数组（10MB那个）分配的状况与第二个数组类似，都不需要另外触发GC就可以成功。
等到要分配第5个数组（15MB那个）时，堆的状况跟要分配第三个数组时类似，eden都是99%满，所以楼主可能会以为这个数组也会在GC后分配到eden里。实际状况却是它在young gen尝试分配失败后，真的进入GC前还会试图分配，来到ParallelScavengeHeap::mem_allocate()的这个分支：
C++代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>if (!is_tlab &amp;&amp;  </p>
</li>
<li>size &gt;= (young_gen()-&gt;eden_space()-&gt;capacity_in_words(Thread::current()) / 2)) {  </li>
<li>result = old_gen()-&gt;allocate(size, is_tlab);  </li>
<li>if (result != NULL) {  </li>
<li>return result;  </li>
<li>}  </li>
<li>}<br>if (!is_tlab &amp;&amp; size &gt;= (young_gen()-&gt;eden_space()-&gt;capacity_in_words(Thread::current()) / 2)) { result = old_gen()-&gt;allocate(size, is_tlab); if (result != NULL) { return result; } }
此时eden的capacity有15MB多，一半就是不到8MB，第5个数组有15MB多一点，肯定超过了这个判断条件的限制，于是就直接在old gen尝试分配，成功，就不需要做GC，因而之前的第3和第4个数组就都还在。
等待雨季的到来 写道</li>
</ol>
<p>1、byte5为什么没有触发minor gc而是直接分配在老生代，byte3和byte4为什么没有被回收？
总结一下过程：
第1个数组：
大小5MB，慢速路径上在young gen分配直接成功；
第2个数组：
大小10MB，慢速路径上在young gen分配直接成功；
第3个数组：
大小5MB，慢速路径上在young gen分配失败，
（进入循环）再尝试在young gen分配，还是失败，
没达到去old gen分配的大小限制，
于是真的触发一次minor GC，eden清空，
再尝试在young gen分配，成功；
第4个数组：
大小10MB，慢速路径上在young gen分配直接成功；
第5个数组：
大小15MB，慢速路径上在young gen分配失败，
（进入循环）再尝试在young gen分配，还是失败，</p>
<h1 id="-old-gen-old-gen-gc-">达到了去old gen直接分配的大小限制，在old gen上分配成功。没有触发GC。</h1>
<p>等待雨季的到来 写道</p>
<p>2、eden区什么时候才会自动扩容到40M，当创建超过20M的对象时，都是直接分配在了老生，而创建大小超过老生代的对象时老生代会自动扩容。
上面的过程已经很清楚了。如果创建20MB的对象，它在eden分配会失败（此时只有15MB多一点的容量），然后又满足了直接在old gen分配的条件（试图分配的大小大于eden的capacity的一半），就跑到old gen分配了。</p>
<h1 id="-java-tlab-eden-gc-">如果是比较正常的Java程序，创建的多数对象都是小对象，都通过TLAB来分配，那就可以观察到eden经过几次GC后渐渐扩容到最大大小。</h1>
<p>等待雨季的到来 写道</p>
<p>其他：
我在用eclipse调试的时候发现，同样的测试代码在执行的时候输出的GC log居然会有很大的变化，有的时候eden区被初始化为8M有的时候初始化为20M。
这个问题我就不太清楚了。通过Eclipse来调试Java程序，在目标Java程序里会产生一些额外的垃圾，我不太肯定这跟您看到的抖动有没有关系。
<img src="" alt="Spinner"> <a href="http://zsl8544-163-com.iteye.com/" target="_blank"><img src="&quot;等待雨季的到来的博客: &quot;" alt="等待雨季的到来的博客"></a> <a href="http://zsl8544-163-com.iteye.com/" title="等待雨季的到来" target="_blank">等待雨季的到来</a> 前天</p>
<p>实在是太感谢R大神百忙之中能给出这么细致入微的解释了！受益匪浅！以前我的认识只是eden区会在GC之后分配内存，并不知道如果分配内存大于eden区capacity一半就会直接在old gen分配的规则。
只是由于我对TLAB的具体细节只知甚少，对您下面的eden扩容的解释还是不是太清楚。
引用</p>
<p>如果是比较正常的Java程序，创建的多数对象都是小对象，都通过TLAB来分配，那就可以观察到eden经过几次GC后渐渐扩容到最大大小。
为什么说创建小对象，通过TLAB来分配，eden就会渐渐扩容到最大了呢？
还有一个比较傻的问题，内存区域扩容之后还会再缩小吗？有内存扩容这个设计的原因是不是capacity小得内存区域收集的会更快呢？
<img src="" alt="Spinner"> <a href="http://zsl8544-163-com.iteye.com/" target="_blank"><img src="&quot;等待雨季的到来的博客: &quot;" alt="等待雨季的到来的博客"></a> <a href="http://zsl8544-163-com.iteye.com/" title="等待雨季的到来" target="_blank">等待雨季的到来</a> 前天</p>
<p>对了，我没有看毕玄的实验，能给个链接吗？
我看的是您推荐的周志明老师写的深入Java虚拟机。
<img src="" alt="Spinner"> <a href="http://icyfenix.iteye.com/" target="_blank"><img src="&quot;IcyFenix的博客: FenixSoft 3.0&quot;" alt="IcyFenix的博客"></a> <a href="http://icyfenix.iteye.com/" title="IcyFenix" target="_blank">IcyFenix</a> 昨天</p>
<p>等待雨季的到来 写道</p>
<p>实在是太感谢R大神百忙之中能给出这么细致入微的解释了！受益匪浅！以前我的认识只是eden区会在GC之后分配内存，并不知道如果分配内存大于eden区capacity一半就会直接在old gen分配的规则。
只是由于我对TLAB的具体细节只知甚少，对您下面的eden扩容的解释还是不是太清楚。
引用</p>
<p>如果是比较正常的Java程序，创建的多数对象都是小对象，都通过TLAB来分配，那就可以观察到eden经过几次GC后渐渐扩容到最大大小。
为什么说创建小对象，通过TLAB来分配，eden就会渐渐扩容到最大了呢？
还有一个比较傻的问题，内存区域扩容之后还会再缩小吗？有内存扩容这个设计的原因是不是capacity小得内存区域收集的会更快呢？
赞R大的详细解答。我被召唤来回答楼上的2个问题“eden是如何扩容的？”，“eden扩容之后还会缩小吗？”
也按照上面一步一步分析代码来解释，但过程有点多，我就只帖方法名，具体代码不粘上来了，代码可以到openjdk的repo上直接看。
1.遇到分配内存指令（InterpreterRuntime中的new或者newarray这些字节码模版）
2.开始分配内存（前面R大写的分配数组oopFactory::new_typeArray或者分配对象instanceKlass::allocate_instance）
3.向CollectedHeap请求内存（入口是CollectedHeap::array_allocate或者CollectedHeap::obj_allocate，两者最终走到CollectedHeap::common_mem_allocate_noinit方法中）
4.如果能够通过TLAB顺利分配（allocate_from_tlab方法）就在TLAB上划
5.否则，通过mem_allocate方法在eden上划。这个是纯虚方法，因此要看CollectedHeap的子类ParallelScavengeHeap（LZ使用PS收集器）
6.在men_allocate方法中，先通过cas_allocate在MutableSpace上划，不成功的话，堕入GC-尝试分配-GC-尝试分配……的循环中，这个R大在前面讲的很详细，其他就不多说了，着重讲GC。
7.进入GC的过程不是直接方法调用，是通过发送VM_ParallelGCFailedAllocation信号给VM线程触发的，最终转到ParallelScavengeHeap::failed_mem_allocate()方法中。
8.该通过PSScavenge::invoke()开始GC过程，实际GC的活是在PSScavenge::invoke_no_policy()做的。
9.invoke_no_policy()方法可以看到，实际上每次GC都会重置eden大小，即调用了ParallelScavengeHeap::resize_young_gen()方法，eden是否会真正改变，取决于这个方法传入的参数，如果和eden的原本大小不一样，那就相当于增加或者缩小了eden了。
10.这里关系有点烦，补一段说清楚一些。resize_young_gen()方法的参数值就是PSAdaptiveSizePolicy::calculated_eden_size_in_bytes()返回值，换句话说，GC是否要改变eden大小，完全是由PSAdaptiveSizePolicy控制的（这个方法在它的父类AdaptiveSizePolicy中，但calculated_eden_size_in_bytes只是简单返回一个数值，数值是在子类中计算的，PSScavenge::invoke_no_policy()中调用了PSAdaptiveSizePolicy::compute_generation_free_space()去改变这个数值）。
11.到这里，eden如何改变就取决于PSAdaptiveSizePolicy::compute_generation_free_space()的计算结果了。PS收集器的特点是可以设置一些目标策略，譬如追求吞吐量，追求最小停顿时间等，这个方法会根据用户选定的目标，调用adjust_for_minor_pause_time()、adjust_eden_for_footprint()、adjust_for_pause_time()等方法去计算eden的值，具体就不一个一个细说了。即使不详细看方法内容，光从eden_increment_with_supplement_aligned_up、eden_decrement_aligned_down这些明显含有“increment”、“decrement”的方法名字，也可以回答“内存区域扩容之后还会再缩小吗？”这个问题了。
PS：如果对这个确实感兴趣，可以加个PrintAdaptiveSizePolicy，在每次重新计算内存区域大小时输出一些信息看看。
PSS：我把自己的理解写完了，但也木有搞清楚PS收集器eden的大小计算，和TLAB分配的联系在哪里，请R大继续讲解。
<img src="" alt="Spinner"></p>
<p><img src="" alt=""> <a href="http://hllvm.group.iteye.com/group/topic/38293/post/new" target="_blank">发表回复</a></p>
<p><a href="http://hllvm.group.iteye.com/" target="_blank">&gt;&gt;返回群组首页</a></p>
<p><a href="http://hllvm.group.iteye.com/" target="_blank"><img src="&quot;高级语言虚拟机: 关注各种高级语言虚拟机（high-level language virtual machine，HLL VM）的设计与实现，泛化至各种高级语言的运行时的设计与实现。讨论范围包括JVM、CLI、Parrot等当前流行的VM平台，也包括Python、Ruby、JavaScript、Lua、Perl、Forth、Smalltalk等众多语言的引擎，还有历史上有影响的各种高级语言虚拟机，如SECD等。&quot;" alt="高级语言虚拟机群组"></a></p>
<h3 id="-">相关讨论</h3>
<ul>
<li><a href="http://www.iteye.com/topic/802638" target="_blank">JVM内存管理：深入垃圾收集器与内存分配策略</a></li>
<li><a href="http://www.iteye.com/topic/976522" target="_blank">java内存管理以及GC</a></li>
<li><a href="http://www.iteye.com/topic/894148" target="_blank">HotSpot VM 内存堆的两个Servivor区</a></li>
<li><a href="http://www.iteye.com/topic/814815" target="_blank">jvm crash,疑似GC的bug</a></li>
<li><a href="http://www.iteye.com/topic/730461" target="_blank">借助HotSpot SA来一窥PermGen上的对象</a></li>
<li><a href="http://www.iteye.com/" target="_blank">首页</a></li>
<li><a href="http://www.iteye.com/news" target="_blank">资讯</a></li>
<li><a href="http://www.iteye.com/magazines" target="_blank">精华</a></li>
<li><a href="http://www.iteye.com/forums" target="_blank">论坛</a></li>
<li><a href="http://www.iteye.com/ask" target="_blank">问答</a></li>
<li><a href="http://www.iteye.com/blogs" target="_blank">博客</a></li>
<li><a href="http://www.iteye.com/blogs/subjects" target="_blank">专栏</a></li>
<li><a href="http://www.iteye.com/groups" target="_blank">群组</a></li>
<li><a href="http://job.iteye.com/iteye" target="_blank">招聘</a></li>
<li><a href="http://www.iteye.com/search" target="_blank">搜索</a></li>
<li><a href="http://hllvm.group.iteye.com/index/service" target="_blank">广告服务</a></li>
<li><a href="http://webmaster.iteye.com/" target="_blank">ITeye黑板报</a></li>
<li><a href="http://hllvm.group.iteye.com/index/contactus" target="_blank">联系我们</a></li>
<li><a href="http://hllvm.group.iteye.com/index/friend_links" target="_blank">友情链接</a></li>
</ul>
<p>© 2003-2012 ITeye.com. [ <a href="http://www.miibeian.gov.cn/" target="_blank">京ICP证110151号</a> 京公网安备110105010620 ]
百联优力(北京)投资有限公司 版权所有 <img src="http://stat.iteye.com/?url=http%3A%2F%2Fhllvm.group.iteye.com%2Fgroup%2Ftopic%2F38293&amp;referrer=http%3A%2F%2Fhllvm.group.iteye.com%2F&amp;user_id=" alt=""></p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/JVM/">JVM</a></li></span></span> | <span class="tags">Tagged <a href="/tags/JVM/" class="label label-primary">JVM</a><a href="/tags/Java&J2EE/" class="label label-success">Java&J2EE</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:42"datetime="2014-03-07 09:54:42"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-JVM--eden区没有发生minorgc，对象直接分配在了oldgen/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-JVM--eden区没有发生minorgc，对象直接分配在了oldgen" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--JVM调优总结（十二）-参考资料/">JVM调优总结（十二）</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:42.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--JVM调优总结（十二）-参考资料/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="jvm-">JVM调优总结（十二）-参考资料</h1>
<pre><code>能整理出上面一些东西，也是因为站在巨人的肩上。下面是一些参考资料，供大家学习，大家有更好的，可以继续完善：）
</code></pre><p>· <a href="http://www.ibm.com/developerworks/cn/java/j-jtp10283/" target="_blank">Java 理论与实践: 垃圾收集简史</a></p>
<p>· <a href="http://pengjiaheng.iteye.com/admin/blogs/#resources" target="_blank">Java SE 6 HotSpot[tm] Virtual Machine Garbage Collection Tuning</a></p>
<p>· <a href="http://pengjiaheng.iteye.com/admin/blogs/#16.2.6" target="_blank">Improving Java Application Performance and Scalability by Reducing Garbage Collection Times and Sizing Memory Using JDK 1.4.1</a></p>
<p>· <a href="https://java.sun.com/j2se/reference/whitepapers/memorymanagement_whitepaper.pdf" target="_blank">Hotspot memory management whitepaper</a></p>
<p>· <a href="http://java.sun.com/performance/reference/whitepapers/tuning.html" target="_blank">Java Tuning White Paper</a></p>
<p>· <a href="http://java.sun.com/docs/hotspot/gc1.4.2/example.html" target="_blank">Diagnosing a Garbage Collection problem</a></p>
<p>· <a href="http://java.sun.com/javase/technologies/hotspot/vmoptions.jsp" target="_blank">Java HotSpot VM Options</a></p>
<p>· <a href="http://blogs.sun.com/watt/resource/jvm-options-list.html" target="_blank">A Collection of JVM Options</a></p>
<p>· <a href="http://research.sun.com/jtech/pubs/04-g1-paper-ismm.pdf" target="_blank">Garbage-First Garbage Collection</a></p>
<p>· <a href="http://java.sun.com/docs/hotspot/gc1.4.2/faq.html" target="_blank">Frequently Asked Questions about Garbage Collection in the HotspotTM JavaTM Virtual Machine</a></p>
<p>· <a href="http://pengjiaheng.spaces.live.com/blog/cns!2DAA368B386E6AEA!685.entry" target="_blank">JProfiler试用手记</a></p>
<p>· <a href="http://kenwu.me/java6-jvm-options-chinese-edition-published" target="_blank">Java6 JVM参数选项大全</a></p>
<p>· <a href="http://www.douban.com/subject/1138768/" target="_blank">《深入Java虚拟机》</a>。虽然过去了很多年，但这本书依旧是经典。</p>
<pre><code>这里是本系列的最后一篇了，很高兴大家能够喜欢这系列的文章。期间也提了很多问题，其中有些是我之前没有想到的或者考虑欠妥的，感谢提出这些问题的朋友，我也学到的不少东西。
</code></pre>
      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/JVM/">JVM</a></li></span></span> | <span class="tags">Tagged <a href="/tags/JVM/" class="label label-primary">JVM</a><a href="/tags/Java&J2EE/" class="label label-success">Java&J2EE</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:42"datetime="2014-03-07 09:54:42"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-JVM--JVM调优总结（十二）-参考资料/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-JVM--JVM调优总结（十二）-参考资料" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--JVM调优的-标准参数-的各种陷阱/">JVM调优的</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:42.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--JVM调优的-标准参数-的各种陷阱/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="jvm-">JVM调优的&quot;标准参数&quot;的各种陷阱</h1>
<p><a href="http://hllvm.group.iteye.com/login" title="登录" target="_blank">您还未登录 !</a> <a href="http://hllvm.group.iteye.com/login" target="_blank">登录</a> <a href="http://hllvm.group.iteye.com/signup" target="_blank">注册</a></p>
<p><a href="http://www.iteye.com/" target="_blank"><img src="&quot;ITeye-最棒的软件开发交流社区&quot;" alt="ITeye3.0"></a></p>
<p><a href="http://www.iteye.com/groups" target="_blank">群组首页</a> → <a href="http://hllvm.group.iteye.com/groups/category/language" target="_blank">编程语言</a> → <a href="http://hllvm.group.iteye.com/" target="_blank">高级语言虚拟机</a> → <a href="http://hllvm.group.iteye.com/group/forum" target="_blank">论坛</a></p>
<p><img src="" alt=""> <a href="http://hllvm.group.iteye.com/group/topic/27945/post/new" target="_blank">发表回复</a></p>
<p>« 上一页 1 <a href="http://hllvm.group.iteye.com/group/topic/27945?page=2" target="_blank">2</a> <a href="http://hllvm.group.iteye.com/group/topic/27945?page=3" target="_blank">3</a> <a href="http://hllvm.group.iteye.com/group/topic/27945?page=2" target="_blank">下一页 »</a></p>
<h3 id="-http-hllvm-group-iteye-com-group-forum-tag_id-690-jvm-"><a href="http://hllvm.group.iteye.com/group/forum?tag_id=690" target="_blank">[讨论]</a> <a href="">JVM调优的&quot;标准参数&quot;的各种陷阱</a></h3>
<p><a href="http://rednaxelafx.iteye.com/" target="_blank"><img src="&quot;RednaxelaFX的博客: Script Ahead, Code Behind&quot;" alt="RednaxelaFX的博客"></a> <a href="http://rednaxelafx.iteye.com/" title="RednaxelaFX" target="_blank">RednaxelaFX</a> 2011-10-23</p>
<p>开个帖大家来讨论下自己遇到过的情况吧？我在顶楼举几个例子。
开这帖的目的是想让大家了解到，所谓“标准参数”是件很微妙的事情。确实有许多前辈经过多年开发积累下了许多有用的调优经验，但向他们问“标准参数”并照单全收是件危险的事情。
前辈们提供的“标准参数”或许适用于他们的应用场景，他们或许也知道这些参数里隐含的陷阱；但听众却不一定知道各种参数背后的缘由。
原则上说，在生产环境使用非标准参数（这里指的是在各JDK/JRE实现特有的、相互之间不通用的参数）应该尽量避免。这些参数与具体实现密切相关，不是光了解很抽象的“JVM原理”就足以理解的；即便在同一系列的JDK/JRE实现中，非标准参数也不保证在各版本间有一样的作用；而且许多人只看名字就猜想参数的左右，做“调优”却适得其反。
非标准参数的默认值在不同版本间或许会悄然发生变化。这些变化的背后多半有合理的理由。设了一大堆非标准参数、不明就里的同学在升级JDK/JRE的时候也容易掉坑里。
下面用<strong>Oracle/Sun JDK 6</strong>来举几个例子。这帖顶楼里的讨论如果没明确指出JDK版本的都是指Oracle/Sun JDK 6（OpenJDK 6也可以算在内）。</p>
<h1 id="-sun-jdk-1-4-2-sun-jdk-5-oracle-jdk-7-">经验不一定适用于Sun JDK 1.4.2、Sun JDK 5、Oracle JDK 7。</h1>
<p>0、各参数的默认值
在讨论HotSpot VM的各参数的陷阱前，大家应该先了解HotSpot VM到底有哪些参数可以设置，这些参数的默认值都是什么。
有几种办法可以帮助大家获取参数的信息。首先为了大致了解都有些什么参数可以设置，可以参考HotSpot VM里的各个globals.hpp文件：（以下链接取自HotSpot 20.0，与JDK 6 update 25对应）
<a href="http://hg.openjdk.java.net/hsx/hsx20/master/file/f0f676c5a2c6/src/share/vm/runtime/globals.hpp" target="_blank">globals.hpp</a>
<a href="http://hg.openjdk.java.net/hsx/hsx20/master/file/f0f676c5a2c6/src/share/vm/runtime/globals_extension.hpp" target="_blank">globals_extension.hpp</a>
<a href="http://hg.openjdk.java.net/hsx/hsx20/master/file/f0f676c5a2c6/src/share/vm/c1/c1_globals.hpp" target="_blank">c1_globals.hpp</a>
<a href="http://hg.openjdk.java.net/hsx/hsx20/master/file/f0f676c5a2c6/src/os/linux/vm/c1_globals_linux.hpp" target="_blank">c1_globals_linux.hpp</a>
<a href="http://hg.openjdk.java.net/hsx/hsx20/master/file/f0f676c5a2c6/src/os/solaris/vm/c1_globals_solaris.hpp" target="_blank">c1_globals_solaris.hpp</a>
<a href="http://hg.openjdk.java.net/hsx/hsx20/master/file/f0f676c5a2c6/src/cpu/sparc/vm/c1_globals_sparc.hpp" target="_blank">c1_globals_sparc.hpp</a>
<a href="http://hg.openjdk.java.net/hsx/hsx20/master/file/f0f676c5a2c6/src/os/windows/vm/c1_globals_windows.hpp" target="_blank">c1_globals_windows.hpp</a>
<a href="http://hg.openjdk.java.net/hsx/hsx20/master/file/f0f676c5a2c6/src/cpu/x86/vm/c1_globals_x86.hpp" target="_blank">c1_globals_x86.hpp</a>
<a href="http://hg.openjdk.java.net/hsx/hsx20/master/file/f0f676c5a2c6/src/share/vm/opto/c2_globals.hpp" target="_blank">c2_globals.hpp</a>
<a href="http://hg.openjdk.java.net/hsx/hsx20/master/file/f0f676c5a2c6/src/os/linux/vm/c2_globals_linux.hpp" target="_blank">c2_globals_linux.hpp</a>
<a href="http://hg.openjdk.java.net/hsx/hsx20/master/file/f0f676c5a2c6/src/os/solaris/vm/c2_globals_solaris.hpp" target="_blank">c2_globals_solaris.hpp</a>
<a href="http://hg.openjdk.java.net/hsx/hsx20/master/file/f0f676c5a2c6/src/cpu/sparc/vm/c2_globals_sparc.hpp" target="_blank">c2_globals_sparc.hpp</a>
<a href="http://hg.openjdk.java.net/hsx/hsx20/master/file/f0f676c5a2c6/src/os/windows/vm/c2_globals_windows.hpp" target="_blank">c2_globals_windows.hpp</a>
<a href="http://hg.openjdk.java.net/hsx/hsx20/master/file/f0f676c5a2c6/src/cpu/x86/vm/c2_globals_x86.hpp" target="_blank">c2_globals_x86.hpp</a>
<a href="http://hg.openjdk.java.net/hsx/hsx20/master/file/f0f676c5a2c6/src/share/vm/gc_implementation/g1/g1_globals.hpp" target="_blank">g1_globals.hpp</a>
<a href="http://hg.openjdk.java.net/hsx/hsx20/master/file/f0f676c5a2c6/src/os/linux/vm/globals_linux.hpp" target="_blank">globals_linux.hpp</a>
<a href="http://hg.openjdk.java.net/hsx/hsx20/master/file/f0f676c5a2c6/src/os_cpu/linux_sparc/vm/globals_linux_sparc.hpp" target="_blank">globals_linux_sparc.hpp</a>
<a href="http://hg.openjdk.java.net/hsx/hsx20/master/file/f0f676c5a2c6/src/os_cpu/linux_x86/vm/globals_linux_x86.hpp" target="_blank">globals_linux_x86.hpp</a>
<a href="http://hg.openjdk.java.net/hsx/hsx20/master/file/f0f676c5a2c6/src/os_cpu/linux_zero/vm/globals_linux_zero.hpp" target="_blank">globals_linux_zero.hpp</a>
<a href="http://hg.openjdk.java.net/hsx/hsx20/master/file/f0f676c5a2c6/src/os/solaris/vm/globals_solaris.hpp" target="_blank">globals_solaris.hpp</a>
<a href="http://hg.openjdk.java.net/hsx/hsx20/master/file/f0f676c5a2c6/src/os_cpu/solaris_sparc/vm/globals_solaris_sparc.hpp" target="_blank">globals_solaris_sparc.hpp</a>
<a href="http://hg.openjdk.java.net/hsx/hsx20/master/file/f0f676c5a2c6/src/os_cpu/solaris_x86/vm/globals_solaris_x86.hpp" target="_blank">globals_solaris_x86.hpp</a>
<a href="http://hg.openjdk.java.net/hsx/hsx20/master/file/f0f676c5a2c6/src/cpu/sparc/vm/globals_sparc.hpp" target="_blank">globals_sparc.hpp</a>
<a href="http://hg.openjdk.java.net/hsx/hsx20/master/file/f0f676c5a2c6/src/os/windows/vm/globals_windows.hpp" target="_blank">globals_windows.hpp</a>
<a href="http://hg.openjdk.java.net/hsx/hsx20/master/file/f0f676c5a2c6/src/os_cpu/windows_x86/vm/globals_windows_x86.hpp" target="_blank">globals_windows_x86.hpp</a>
<a href="http://hg.openjdk.java.net/hsx/hsx20/master/file/f0f676c5a2c6/src/cpu/x86/vm/globals_x86.hpp" target="_blank">globals_x86.hpp</a>
<a href="http://hg.openjdk.java.net/hsx/hsx20/master/file/f0f676c5a2c6/src/cpu/zero/vm/globals_zero.hpp" target="_blank">globals_zero.hpp</a>
<a href="http://hg.openjdk.java.net/hsx/hsx20/master/file/f0f676c5a2c6/src/share/vm/shark/shark_globals.hpp" target="_blank">shark_globals.hpp</a>
<a href="http://hg.openjdk.java.net/hsx/hsx20/master/file/f0f676c5a2c6/src/cpu/zero/vm/shark_globals_zero.hpp" target="_blank">shark_globals_zero.hpp</a>
<a href="http://hg.openjdk.java.net/hsx/hsx20/master/file/f0f676c5a2c6/src/share/vm/runtime/arguments.cpp" target="_blank">arguments.cpp</a>
然后是 <strong>-XX:+PrintCommandLineFlags</strong> 。这个参数的作用是显示出VM初始化完毕后所有跟最初的默认值不同的参数及它们的值。
这个参数至少在Sun JDK 5上已经开始支持，Oracle/Sun JDK 6以及Oracle JDK 7上也可以使用。Sun JDK 1.4.2还不支持这个参数。
例子：
Command prompt代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>$ java -XX:+PrintCommandLineFlags  </li>
<li>VM option &#39;+PrintCommandLineFlags&#39;  </li>
<li><p>-XX:InitialHeapSize=57344000 -XX:MaxHeapSize=917504000 -XX:ParallelGCThreads=4 -XX:+PrintCommandLineFlags -XX:+UseCompressedOops -XX:+UseParallelGC<br>$ java -XX:+PrintCommandLineFlags VM option &#39;+PrintCommandLineFlags&#39; -XX:InitialHeapSize=57344000 -XX:MaxHeapSize=917504000 -XX:ParallelGCThreads=4 -XX:+PrintCommandLineFlags -XX:+UseCompressedOops -XX:+UseParallelGC
<a href="http://book.douban.com/annotation/15146892/" target="_blank">《Java Performance》一书</a>主要是用这个参数来介绍HotSpot VM各参数的效果的。
接着是 <strong>-XX:+PrintFlagsFinal</strong> 。前一个参数只显示跟默认值不同的，而这个参数则可以显示所有可设置的参数及它们的值。不过这个参数本身只从JDK 6 update 21开始才可以用，之前的Oracle/Sun JDK则用不了。
可以设置的参数默认是不包括diagnostic或experimental系的。要在-XX:+PrintFlagsFinal的输出里看到这两种参数的信息，分别需要显式指定<strong>-XX:+UnlockDiagnosticVMOptions</strong> / <strong>-XX:+UnlockExperimentalVMOptions</strong> 。
再下来，<strong>-XX:+PrintFlagsInitial</strong> 。这个参数显示在处理参数之前所有可设置的参数及它们的值，然后直接退出程序。“参数处理”包括许多步骤，例如说检查参数之间是否有冲突，通过ergonomics调整某些参数的值，之类的。
结合-XX:+PrintFlagsInitial与-XX:+PrintFlagsFinal，对比两者的差异，就可以知道ergonomics对哪些参数做了怎样的调整。
这两个参数的例子：
Command prompt代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>$ java -version  </p>
</li>
<li>java version &quot;1.6.0_29&quot;  </li>
<li>Java(TM) SE Runtime Environment (build 1.6.0_29-b11)  </li>
<li>Java HotSpot(TM) 64-Bit Server VM (build 20.4-b02, mixed mode)  </li>
<li>$ java -XX:+PrintFlagsInitial | grep UseCompressedOops  </li>
<li>bool UseCompressedOops                         = false           {lp64_product}        </li>
<li>$ java -XX:+PrintFlagsFinal | grep UseCompressedOops  </li>
<li><p>bool UseCompressedOops                        := true            {lp64_product}<br>$ java -version java version &quot;1.6.0_29&quot; Java(TM) SE Runtime Environment (build 1.6.0_29-b11) Java HotSpot(TM) 64-Bit Server VM (build 20.4-b02, mixed mode) $ java -XX:+PrintFlagsInitial | grep UseCompressedOops bool UseCompressedOops = false {lp64_product} $ java -XX:+PrintFlagsFinal | grep UseCompressedOops bool UseCompressedOops := true {lp64_product}
<a href="http://rednaxelafx.iteye.com/blog/1010079" target="_blank">Oracle/Sun JDK 6从update 23开始会由ergonomics在合适的条件下默认启用压缩指针功能</a>。这个例子演示的是UseCompressedOops的初始默认值是false，由PrintFlagsInitial的输出可以看到；然后经过ergonomics自动调整后，最终采用的默认值是true，由PrintFlagsFinal的输出可以看到。
输出里“=”表示使用的是初始默认值，而“:=”表示使用的不是初始默认值，可能是命令行传进来的参数、配置文件里的参数或者是ergonomics自动选择了别的值。
除了在VM启动时传些特殊的参数让它打印出自己的各参数外，<strong>jinfo -flag</strong> 可以用来查看某个参数的值，也可以用来设定manageable系参数的值。请参考这帖的例子：<a href="http://rednaxelafx.iteye.com/blog/1049240" target="_blank">通过jinfo工具在full GC前后做heap dump</a></p>
<h1 id="-hotspot-vm-http-rednaxelafx-iteye-com-blog-906807-">之前发过<a href="http://rednaxelafx.iteye.com/blog/906807" target="_blank">某些环境中HotSpot VM的各参数的默认值</a>，可以参考一下。</h1>
<p>1、-XX:+DisableExplicitGC 与 NIO的direct memory
很多人都见过JVM调优建议里使用这个参数，对吧？但是为什么要用它，什么时候应该用而什么时候用了会掉坑里呢？
首先要了解的是这个参数的作用。在Oracle/Sun JDK这个具体实现上，System.gc()的默认效果是引发一次stop-the-world的full GC，对整个GC堆做收集。有几个参数可以改变默认行为，之前<a href="http://rednaxelafx.iteye.com/blog/1042471" target="_blank">发过一帖简单描述</a>过，这里就不重复了。关键点是，用了-XX:+DisableExplicitGC参数后，System.gc()的调用就会变成一个空调用，完全不会触发任何GC（但是“函数调用”本身的开销还是存在的哦～）。
为啥要用这个参数呢？最主要的原因是为了防止某些手贱的同学在代码里到处写System.gc()的调用而干扰了程序的正常运行吧。有些应用程序本来可能正常跑一天也不会出一次full GC，但就是因为有人在代码里调用了System.gc()而不得不间歇性被暂停。也有些时候这些调用是在某些库或框架里写的，改不了它们的代码但又不想被这些调用干扰也会用这参数。
OK。看起来这参数应该总是开着嘛。有啥坑呢？
其中一种情况是下述三个条件同时满足时会发生的：
1、应用本身在GC堆内的对象行为良好，正常情况下很久都不发生full GC；
2、应用大量使用了NIO的direct memory，经常、反复的申请DirectByteBuffer
3、使用了-XX:+DisableExplicitGC
能观察到的现象是：
Log代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>java.lang.OutOfMemoryError: Direct buffer memory  </p>
</li>
<li>at java.nio.Bits.reserveMemory(Bits.java:633)  </li>
<li>at java.nio.DirectByteBuffer.<init>(DirectByteBuffer.java:98)  </li>
<li>at java.nio.ByteBuffer.allocateDirect(ByteBuffer.java:288)  </li>
<li><p>...<br>java.lang.OutOfMemoryError: Direct buffer memory at java.nio.Bits.reserveMemory(Bits.java:633) at java.nio.DirectByteBuffer.<init>(DirectByteBuffer.java:98) at java.nio.ByteBuffer.allocateDirect(ByteBuffer.java:288) ...
做个简单的例子来演示这现象：
Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>import java.nio./*;  </p>
</li>
<li></li>
<li>public class DisableExplicitGCDemo {  </li>
<li>public static void main(String[] args) {  </li>
<li>for (int i = 0; i &lt; 100000; i++) {  </li>
<li>ByteBuffer.allocateDirect(128);  </li>
<li>}  </li>
<li>System.out.println(&quot;Done&quot;);  </li>
<li>}  </li>
<li><p>}<br>import java.nio./*; public class DisableExplicitGCDemo { public static void main(String[] args) { for (int i = 0; i &lt; 100000; i++) { ByteBuffer.allocateDirect(128); } System.out.println(&quot;Done&quot;); } }
然后编译、运行之：
Command prompt代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>$ java -version  </p>
</li>
<li>java version &quot;1.6.0_25&quot;  </li>
<li>Java(TM) SE Runtime Environment (build 1.6.0_25-b06)  </li>
<li>Java HotSpot(TM) 64-Bit Server VM (build 20.0-b11, mixed mode)  </li>
<li>$ javac DisableExplicitGCDemo.java   </li>
<li>$ java -XX:MaxDirectMemorySize=10m -XX:+PrintGC -XX:+DisableExplicitGC DisableExplicitGCDemo  </li>
<li>Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Direct buffer memory  </li>
<li>at java.nio.Bits.reserveMemory(Bits.java:633)  </li>
<li>at java.nio.DirectByteBuffer.<init>(DirectByteBuffer.java:98)  </li>
<li>at java.nio.ByteBuffer.allocateDirect(ByteBuffer.java:288)  </li>
<li>at DisableExplicitGCDemo.main(DisableExplicitGCDemo.java:6)  </li>
<li>$ java -XX:MaxDirectMemorySize=10m -XX:+PrintGC DisableExplicitGCDemo  </li>
<li>[GC 10996K-&gt;10480K(120704K), 0.0433980 secs]  </li>
<li>[Full GC 10480K-&gt;10415K(120704K), 0.0359420 secs]  </li>
<li><p>Done<br>$ java -version java version &quot;1.6.0_25&quot; Java(TM) SE Runtime Environment (build 1.6.0_25-b06) Java HotSpot(TM) 64-Bit Server VM (build 20.0-b11, mixed mode) $ javac DisableExplicitGCDemo.java $ java -XX:MaxDirectMemorySize=10m -XX:+PrintGC -XX:+DisableExplicitGC DisableExplicitGCDemo Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Direct buffer memory at java.nio.Bits.reserveMemory(Bits.java:633) at java.nio.DirectByteBuffer.<init>(DirectByteBuffer.java:98) at java.nio.ByteBuffer.allocateDirect(ByteBuffer.java:288) at DisableExplicitGCDemo.main(DisableExplicitGCDemo.java:6) $ java -XX:MaxDirectMemorySize=10m -XX:+PrintGC DisableExplicitGCDemo [GC 10996K-&gt;10480K(120704K), 0.0433980 secs] [Full GC 10480K-&gt;10415K(120704K), 0.0359420 secs] Done
可以看到，同样的程序，不带-XX:+DisableExplicitGC时能正常完成运行，而带上这个参数后却出现了OOM。
例子里用-XX:MaxDirectMemorySize=10m限制了DirectByteBuffer能分配的空间的限额，以便问题更容易展现出来。不用这个参数就得多跑一会儿了。
在这个例子里，main()里的循环不断申请DirectByteBuffer但并没有引用、使用它们，所以这些DirectByteBuffer应该刚创建出来就已经满足被GC的条件，等下次GC运行的时候就应该可以被回收。
实际上却没这么简单。DirectByteBuffer是种典型的“冰山”对象，也就是说它的Java对象虽然很小很无辜，但它背后却会关联着一定量的native memory资源，而这些资源并不在GC的控制之下，需要自己注意控制好。对JVM如何使用native memory不熟悉的同学可以参考去年JavaOne上IBM的一个演讲，“Where Does All the Native Memory Go”。
Oracle/Sun JDK的实现里，DirectByteBuffer有几处值得注意的地方。
1、DirectByteBuffer没有finalizer，它的native memory的清理工作是通过sun.misc.Cleaner自动完成的。
2、sun.misc.Cleaner是一种基于PhantomReference的清理工具，比普通的finalizer轻量些。对PhantomReference不熟悉的同学请参考Bob Lee最近几年在JavaOne上做的演讲，<a href="http://www.parleys.com/d/2657" target="_blank">&quot;The Ghost in the Virtual Machine: A Reference to References&quot;</a>。<a href="https://oracleus.wingateweb.com/scheduler/eventcatalog/eventCatalogJavaOne.do" target="_blank">今年的JavaOne</a>上他也讲了同一个主题，内容比前几年的稍微更新了些。PPT可以从链接里的页面下载到。
Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>//<em>/</em> </p>
</li>
<li>/* General-purpose phantom-reference-based cleaners. </li>
<li>/* </li>
<li>/* <p> Cleaners are a lightweight and more robust alternative to finalization. </li>
<li>/* They are lightweight because they are not created by the VM and thus do not </li>
<li>/* require a JNI upcall to be created, and because their cleanup code is </li>
<li>/* invoked directly by the reference-handler thread rather than by the </li>
<li>/* finalizer thread.  They are more robust because they use phantom references, </li>
<li>/* the weakest type of reference object, thereby avoiding the nasty ordering </li>
<li>/* problems inherent to finalization. </li>
<li>/* </li>
<li>/* <p> A cleaner tracks a referent object and encapsulates a thunk of arbitrary </li>
<li>/* cleanup code.  Some time after the GC detects that a cleaner&#39;s referent has </li>
<li>/* become phantom-reachable, the reference-handler thread will run the cleaner. </li>
<li>/* Cleaners may also be invoked directly; they are thread safe and ensure that </li>
<li>/* they run their thunks at most once. </li>
<li>/* </li>
<li>/* <p> Cleaners are not a replacement for finalization.  They should be used </li>
<li>/* only when the cleanup code is extremely simple and straightforward. </li>
<li>/* Nontrivial cleaners are inadvisable since they risk blocking the </li>
<li>/* reference-handler thread and delaying further cleanup and finalization. </li>
<li>/* </li>
<li>/* </li>
<li>/* @author Mark Reinhold </li>
<li>/* @version %I%, %E% </li>
<li><p>/<em>/<br>//</em>/<em> /</em> General-purpose phantom-reference-based cleaners. /<em> /</em> <p> Cleaners are a lightweight and more robust alternative to finalization. /<em> They are lightweight because they are not created by the VM and thus do not /</em> require a JNI upcall to be created, and because their cleanup code is /<em> invoked directly by the reference-handler thread rather than by the /</em> finalizer thread. They are more robust because they use phantom references, /<em> the weakest type of reference object, thereby avoiding the nasty ordering /</em> problems inherent to finalization. /<em> /</em> <p> A cleaner tracks a referent object and encapsulates a thunk of arbitrary /<em> cleanup code. Some time after the GC detects that a cleaner&#39;s referent has /</em> become phantom-reachable, the reference-handler thread will run the cleaner. /<em> Cleaners may also be invoked directly; they are thread safe and ensure that /</em> they run their thunks at most once. /<em> /</em> <p> Cleaners are not a replacement for finalization. They should be used /<em> only when the cleanup code is extremely simple and straightforward. /</em> Nontrivial cleaners are inadvisable since they risk blocking the /<em> reference-handler thread and delaying further cleanup and finalization. /</em> /<em> /</em> @author Mark Reinhold /<em> @version %I%, %E% /</em>/
重点是这两句：&quot;A cleaner tracks a referent object and encapsulates a thunk of arbitrary cleanup code.  Some time after the GC detects that a cleaner&#39;s referent has become phantom-reachable, the reference-handler thread will run the cleaner.&quot;
Oracle/Sun JDK 6中的HotSpot VM只会在old gen GC（full GC/major GC或者concurrent GC都算）的时候才会对old gen中的对象做reference processing，而在young GC/minor GC时只会对young gen里的对象做reference processing。
（死在young gen中的DirectByteBuffer对象会在young GC时被处理的例子，请参考这里：<a href="https://gist.github.com/1614952" target="_blank"><a href="https://gist.github.com/1614952">https://gist.github.com/1614952</a></a>）
也就是说，做full GC的话会对old gen做reference processing，进而能触发Cleaner对已死的DirectByteBuffer对象做清理工作。而如果很长一段时间里没做过GC或者只做了young GC的话则不会在old gen触发Cleaner的工作，那么就可能让本来已经死了的、但已经晋升到old gen的DirectByteBuffer关联的native memory得不到及时释放。
3、为DirectByteBuffer分配空间过程中会显式调用System.gc()，以期通过full GC来强迫已经无用的DirectByteBuffer对象释放掉它们关联的native memory：
Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>// These methods should be called whenever direct memory is allocated or  </p>
</li>
<li>// freed.  They allow the user to control the amount of direct memory  </li>
<li>// which a process may access.  All sizes are specified in bytes.  </li>
<li>static void reserveMemory(long size) {  </li>
<li></li>
<li>synchronized (Bits.class) {  </li>
<li>if (!memoryLimitSet &amp;&amp; VM.isBooted()) {  </li>
<li>maxMemory = VM.maxDirectMemory();  </li>
<li>memoryLimitSet = true;  </li>
<li>}  </li>
<li>if (size &lt;= maxMemory - reservedMemory) {  </li>
<li>reservedMemory += size;  </li>
<li>return;  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>System.gc();  </li>
<li>try {  </li>
<li>Thread.sleep(100);  </li>
<li>} catch (InterruptedException x) {  </li>
<li>// Restore interrupt status  </li>
<li>Thread.currentThread().interrupt();  </li>
<li>}  </li>
<li>synchronized (Bits.class) {  </li>
<li>if (reservedMemory + size &gt; maxMemory)  </li>
<li>throw new OutOfMemoryError(&quot;Direct buffer memory&quot;);  </li>
<li>reservedMemory += size;  </li>
<li>}  </li>
<li></li>
<li>}<br>// These methods should be called whenever direct memory is allocated or // freed. They allow the user to control the amount of direct memory // which a process may access. All sizes are specified in bytes. static void reserveMemory(long size) { synchronized (Bits.class) { if (!memoryLimitSet &amp;&amp; VM.isBooted()) { maxMemory = VM.maxDirectMemory(); memoryLimitSet = true; } if (size &lt;= maxMemory - reservedMemory) { reservedMemory += size; return; } } System.gc(); try { Thread.sleep(100); } catch (InterruptedException x) { // Restore interrupt status Thread.currentThread().interrupt(); } synchronized (Bits.class) { if (reservedMemory + size &gt; maxMemory) throw new OutOfMemoryError(&quot;Direct buffer memory&quot;); reservedMemory += size; } }
这几个实现特征使得Oracle/Sun JDK 6依赖于System.gc()触发GC来保证DirectByteMemory的清理工作能及时完成。如果打开了-XX:+DisableExplicitGC，清理工作就可能得不到及时完成，于是就有机会见到direct memory的OOM，也就是上面的例子演示的情况。我们这边在实际生产环境中确实遇到过这样的问题。<h1 id="-oracle-sun-jdk-6-direct-memory-xx-disableexplicitgc-direct-memory-oom-oom-system-gc-full-gc-xx-explicitgcinvokesconcurrent-">教训是：如果你在使用Oracle/Sun JDK 6，应用里有任何地方用了direct memory，那么使用-XX:+DisableExplicitGC要小心。如果用了该参数而且遇到direct memory的OOM，可以尝试去掉该参数看是否能避开这种OOM。如果担心System.gc()调用造成full GC频繁，可以尝试下面提到 -XX:+ExplicitGCInvokesConcurrent 参数</h1>
2、-XX:+DisableExplicitGC 与 Remote Method Invocation (RMI) 与 -Dsun.rmi.dgc.{server|client}.gcInterval=
看了上一个例子有没有觉得-XX:+DisableExplicitGC参数用起来很危险？那干脆完全不要用这个参数吧。又有什么坑呢？
前段时间有个应用的开发来抱怨，说某次升级JDK之前那应用的GC状况都很好，很长时间都不会发生full GC，但升级后发现每一小时左右就会发生一次。经过对比发现，升级的同时也吧启动参数改了，把原本有的-XX:+DisableExplicitGC给去掉了。
观察到的日志有明显特征。一位同事表示：
引用</li>
</ol>
<p>线上机器出现一个场景；每隔1小时出现一次Full GC,用btrace看了一下调用地：
who call system.gc :
sun.misc.GC$Daemon.run(GC.java:92)
预发机没什么流量，也会每一小时一次Full GC
频率正好是一小时一次
Gc log代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>2011-09-23T10:49:38.071+0800: 327692.227: [Full GC (System) 327692.227: [CMS: 75793K-&gt;75759K(2097152K), 0.6923690 secs] 430298K-&gt;75759K(3984640K), [CMS Perm : 104136K-&gt;104124K(173932K)], 0.6925570 secs]<br>2011-09-23T10:49:38.071+0800: 327692.227: [Full GC (System) 327692.227: [CMS: 75793K-&gt;75759K(2097152K), 0.6923690 secs] 430298K-&gt;75759K(3984640K), [CMS Perm : 104136K-&gt;104124K(173932K)], 0.6925570 secs]
实际上这里在做的是分布式GC。Sun JDK的分布式GC是用纯Java实现的，为RMI服务。
RMI DGC相关参数的介绍文档：<a href="http://docs.oracle.com/javase/6/docs/technotes/guides/rmi/sunrmiproperties.html" target="_blank"><a href="http://docs.oracle.com/javase/6/docs/technotes/guides/rmi/sunrmiproperties.html">http://docs.oracle.com/javase/6/docs/technotes/guides/rmi/sunrmiproperties.html</a></a>
（后面回头再补…先睡觉去了）
资料：
<a href="http://java.sun.com/developer/onlineTraining/rmi/exercises/DistributedGarbageCollector/index.html" target="_blank">jGuru: Distributed Garbage Collection</a>
<a href="http://mail.openjdk.java.net/pipermail/hotspot-dev/2011-December/004909.html" target="_blank"><a href="http://mail.openjdk.java.net/pipermail/hotspot-dev/2011-December/004909.html">http://mail.openjdk.java.net/pipermail/hotspot-dev/2011-December/004909.html</a></a>
Tony Printezis 写道</li>
</ol>
<p>RMI has a distributed GC that relies on reference processing to allow
each node to recognize that some objects are unreachable so it can
notify a remote node (or nodes) that some remote references to them do
not exist any more. The remote node might then be able to reclaim
objects that are only remotely reachable. (Or this is how I understood
it at least.)
RMI used to call System.gc() once a minute (!!!) but after some
encouragement from yours truly they changed the default to once an hour
(this is configurable using a property). Note that a STW Full GC is not
really required as long as references are processed. So, in CMS (and
G1), a concurrent cycle is fine which is why we recommend to use
-XX:+ExplicitGCInvokesConcurrent in this case.
I had been warned by the RMI folks against totally disabling those
System.gc()&#39;s (e.g., using -XX:+DisableExplicitGC) given that if Full
GCs / concurrent cycles do not otherwise happen at a reasonable
frequency then remote nodes might experience memory leaks since they
will consider that some otherwise unreachable remote references are
still live. I have no idea how severe such memory leaks would be. I
guess they&#39;d be very application-dependent.
An additional thought that just occurred to me: instead of calling
System.gc() every hour what RMI should really be doing is calling
System.gc() every hour provided no old gen GC has taken place during the
last hour. This would be relatively easy to implement by accessing the
old GC counter through the GC MXBeans.
Tony
再加俩链接：<a href="http://mail.openjdk.java.net/pipermail/hotspot-dev/2012-January/004929.html" target="_blank"><a href="http://mail.openjdk.java.net/pipermail/hotspot-dev/2012-January/004929.html">http://mail.openjdk.java.net/pipermail/hotspot-dev/2012-January/004929.html</a></a>
<a href="http://mail.openjdk.java.net/pipermail/hotspot-dev/2012-January/004946.html" target="_blank"><a href="http://mail.openjdk.java.net/pipermail/hotspot-dev/2012-January/004946.html">http://mail.openjdk.java.net/pipermail/hotspot-dev/2012-January/004946.html</a></a></p>
<h1 id="-java-performance-303-411-xx-disableexplicitgc-rmi-">《Java Performance》的303和411页正好也提到了-XX:+DisableExplicitGC与RMI之间的干扰的事情，有兴趣可以读一下，虽然只有一小段。</h1>
<p>3、-XX:+ExplicitGCInvokesConcurrent 或 -XX:+ExplicitGCInvokesConcurrentAndUnloadsClasses
C++代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>product(bool, ExplicitGCInvokesConcurrent, false,                  \  </li>
<li>&quot;A System.gc() request invokes a concurrent collection;&quot;         \  </li>
<li>&quot; (effective only when UseConcMarkSweepGC)&quot;)                     \  </li>
<li>\  </li>
<li>product(bool, ExplicitGCInvokesConcurrentAndUnloadsClasses, false, \  </li>
<li>&quot;A System.gc() request invokes a concurrent collection and &quot;     \  </li>
<li>&quot;also unloads classes during such a concurrent gc cycle &quot;        \  </li>
<li><p>&quot;(effective only when UseConcMarkSweepGC)&quot;)                      \<br>product(bool, ExplicitGCInvokesConcurrent, false, \ &quot;A System.gc() request invokes a concurrent collection;&quot; \ &quot; (effective only when UseConcMarkSweepGC)&quot;) \ \ product(bool, ExplicitGCInvokesConcurrentAndUnloadsClasses, false, \ &quot;A System.gc() request invokes a concurrent collection and &quot; \ &quot;also unloads classes during such a concurrent gc cycle &quot; \ &quot;(effective only when UseConcMarkSweepGC)&quot;) \
跟上面的第一个例子的-XX:+DisableExplicitGC一样，这两个参数也是用来改变System.gc()的默认行为用的；不同的是这两个参数只能配合CMS使用（-XX:+UseConcMarkSweepGC），而且System.gc()还是会触发GC的，只不过不是触发一个完全stop-the-world的full GC，而是一次并发GC周期。
CMS GC周期中也会做reference processing。所以如果用这两个参数的其中一个，而不是用-XX:+DisableExplicitGC的话，就避开了由full GC带来的长GC pause，同时NIO direct memory的OOM也不会那么容易发生。
做了个跟第一个例子类似的例子，在这里：<a href="https://gist.github.com/1344251" target="_blank"><a href="https://gist.github.com/1344251">https://gist.github.com/1344251</a></a>
《Java Performance》的303页有讲到这俩参数。
相关bug：<a href="http://bugs.sun.com/view_bug.do?bug_id=6919638" target="_blank">6919638 CMS: ExplicitGCInvokesConcurrent misinteracts with gc locker</a></p>
<h1 id="-jdk6u23-">&lt;&lt; JDK6u23修复了这个问题</h1>
<p>4、-XX:+GCLockerInvokesConcurrent
C++代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>product(bool, GCLockerInvokesConcurrent, false,        \  </p>
</li>
<li>&quot;The exit of a JNI CS necessitating a scavenge also&quot; \  </li>
<li><p>&quot; kicks off a bkgrd concurrent collection&quot;)          \<br>product(bool, GCLockerInvokesConcurrent, false, \ &quot;The exit of a JNI CS necessitating a scavenge also&quot; \ &quot; kicks off a bkgrd concurrent collection&quot;) \</p>
<h1 id="-">（内容回头补…）</h1>
<p>5、MaxDirectMemorySize 与 NIO direct memory 的默认上限
<strong>-XX:MaxDirectMemorySize</strong> 是用来配置NIO direct memory上限用的VM参数。
C++代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>product(intx, MaxDirectMemorySize, -1,                         \  </p>
</li>
<li><p>&quot;Maximum total size of NIO direct-buffer allocations&quot;) \<br>product(intx, MaxDirectMemorySize, -1, \ &quot;Maximum total size of NIO direct-buffer allocations&quot;) \
但如果不配置它的话，direct memory默认最多能申请多少内存呢？这个参数默认值是-1，显然不是一个“有效值”。所以真正的默认值肯定是从别的地方来的。
在Sun JDK 6和OpenJDK 6里，有这样一段代码，sun.misc.VM：
Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>// A user-settable upper limit on the maximum amount of allocatable direct  </p>
</li>
<li>// buffer memory.  This value may be changed during VM initialization if  </li>
<li>// &quot;java&quot; is launched with &quot;-XX:MaxDirectMemorySize=<size>&quot;.  </li>
<li>//  </li>
<li>// The initial value of this field is arbitrary; during JRE initialization  </li>
<li>// it will be reset to the value specified on the command line, if any,  </li>
<li>// otherwise to Runtime.getRuntime().maxMemory().  </li>
<li>//  </li>
<li>private static long directMemory = 64 /<em> 1024 /</em> 1024;  </li>
<li></li>
<li>// If this method is invoked during VM initialization, it initializes the  </li>
<li>// maximum amount of allocatable direct buffer memory (in bytes) from the  </li>
<li>// system property sun.nio.MaxDirectMemorySize.  The system property will  </li>
<li>// be removed when it is accessed.  </li>
<li>//  </li>
<li>// If this method is invoked after the VM is booted, it returns the  </li>
<li>// maximum amount of allocatable direct buffer memory.  </li>
<li>//  </li>
<li>public static long maxDirectMemory() {  </li>
<li>if (booted)  </li>
<li>return directMemory;  </li>
<li></li>
<li>Properties p = System.getProperties();  </li>
<li>String s = (String)p.remove(&quot;sun.nio.MaxDirectMemorySize&quot;);  </li>
<li>System.setProperties(p);  </li>
<li></li>
<li>if (s != null) {  </li>
<li>if (s.equals(&quot;-1&quot;)) {  </li>
<li>// -XX:MaxDirectMemorySize not given, take default  </li>
<li>directMemory = Runtime.getRuntime().maxMemory();  </li>
<li>} else {  </li>
<li>long l = Long.parseLong(s);  </li>
<li>if (l &gt; -1)  </li>
<li>directMemory = l;  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>return directMemory;  </li>
<li><p>}<br>// A user-settable upper limit on the maximum amount of allocatable direct // buffer memory. This value may be changed during VM initialization if // &quot;java&quot; is launched with &quot;-XX:MaxDirectMemorySize=<size>&quot;. // // The initial value of this field is arbitrary; during JRE initialization // it will be reset to the value specified on the command line, if any, // otherwise to Runtime.getRuntime().maxMemory(). // private static long directMemory = 64 /<em> 1024 /</em> 1024; // If this method is invoked during VM initialization, it initializes the // maximum amount of allocatable direct buffer memory (in bytes) from the // system property sun.nio.MaxDirectMemorySize. The system property will // be removed when it is accessed. // // If this method is invoked after the VM is booted, it returns the // maximum amount of allocatable direct buffer memory. // public static long maxDirectMemory() { if (booted) return directMemory; Properties p = System.getProperties(); String s = (String)p.remove(&quot;sun.nio.MaxDirectMemorySize&quot;); System.setProperties(p); if (s != null) { if (s.equals(&quot;-1&quot;)) { // -XX:MaxDirectMemorySize not given, take default directMemory = Runtime.getRuntime().maxMemory(); } else { long l = Long.parseLong(s); if (l &gt; -1) directMemory = l; } } return directMemory; }
（代码里原本的注释有个写错的地方，上面有修正）
当MaxDirectMemorySize参数没被显式设置时它的值就是-1，在Java类库初始化时maxDirectMemory()被java.lang.System的静态构造器调用，走的路径就是这条：
Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>if (s.equals(&quot;-1&quot;)) {  </p>
</li>
<li>// -XX:MaxDirectMemorySize not given, take default  </li>
<li>directMemory = Runtime.getRuntime().maxMemory();  </li>
<li><p>}<br>if (s.equals(&quot;-1&quot;)) { // -XX:MaxDirectMemorySize not given, take default directMemory = Runtime.getRuntime().maxMemory(); }
而Runtime.maxMemory()在HotSpot VM里的实现是：
C++代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>JVM_ENTRY_NO_ENV(jlong, JVM_MaxMemory(void))  </p>
</li>
<li>JVMWrapper(&quot;JVM_MaxMemory&quot;);  </li>
<li>size_t n = Universe::heap()-&gt;max_capacity();  </li>
<li>return convert_size_t_to_jlong(n);  </li>
<li><p>JVM_END<br>JVM_ENTRY_NO_ENV(jlong, JVM_MaxMemory(void)) JVMWrapper(&quot;JVM_MaxMemory&quot;); size_t n = Universe::heap()-&gt;max_capacity(); return convert_size_t_to_jlong(n); JVM_END
这个max_capacity()实际返回的是 -Xmx减去一个survivor space的预留大小（G1除外）。
结论：MaxDirectMemorySize没显式配置的时候，NIO direct memory可申请的空间的上限就是<strong>-Xmx减去一个survivor space的预留大小</strong>。
大家感兴趣的话可以试试在不同的-Xmx的条件下不设置MaxDirectMemorySize，并且调用一下sun.misc.VM.maxDirectMemory()看得到的值的相关性。</p>
<h1 id="-jdk7-http-hg-openjdk-java-net-jdk7-jdk7-jdk-rev-b444f86c4abe-http-hg-openjdk-java-net-jdk7-jdk7-jdk-rev-b444f86c4abe-">该行为在JDK7里没变，虽然具体实现的代码有些变化。请参考<a href="http://hg.openjdk.java.net/jdk7/jdk7/jdk/rev/b444f86c4abe" target="_blank"><a href="http://hg.openjdk.java.net/jdk7/jdk7/jdk/rev/b444f86c4abe">http://hg.openjdk.java.net/jdk7/jdk7/jdk/rev/b444f86c4abe</a></a></h1>
<p>6、-verbose:gc 与 -XX:+PrintGCDetails
经常能看到在推荐的标准参数里这两个参数一起出现。实际上它们有啥关系？
在Oracle/Sun JDK 6里，&quot;java&quot;这个启动程序遇到&quot;-verbosegc&quot;会将其转换为&quot;-verbose:gc&quot;，将启动参数传给HotSpot VM后，HotSpot VM遇到&quot;-verbose:gc&quot;则会当作&quot;-XX:+PrintGC&quot;来处理。
也就是说 -verbosegc、-verbose:gc、-XX:+PrintGC 三者的作用是完全一样的。
而当HotSpot VM遇到 -XX:+PrintGCDetails 参数时，会顺带把 -XX:+PrintGC 给设置上。
也就是说 -XX:+PrintGCDetails 包含 -XX:+PrintGC，进而也就包含 -verbose:gc。</p>
<h1 id="-verbose-gc-">既然 -verbose:gc 都被包含了，何必在命令行参数里显式设置它呢？<img src="" alt=""></h1>
<p>7、-XX:+UseFastEmptyMethods 与 -XX:+UseFastAccessorMethods
虽然不常见，但偶尔也会见到推荐的标准参数上有这俩的身影。
empty method顾名思义就是空方法，也就是方法体只包含一条return指令、返回值类型为void的Java方法。
accessor method在这里则有很具体的定义：
C++代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>bool methodOopDesc::is_accessor() const {  </p>
</li>
<li>if (code_size() != 5) return false;  </li>
<li>if (size_of_parameters() != 1) return false;  </li>
<li>if (java_code_at(0) != Bytecodes::_aload_0 ) return false;  </li>
<li>if (java_code_at(1) != Bytecodes::_getfield) return false;  </li>
<li>if (java_code_at(4) != Bytecodes::_areturn &amp;&amp;  </li>
<li>java_code_at(4) != Bytecodes::_ireturn ) return false;  </li>
<li>return true;  </li>
<li><p>}<br>bool methodOopDesc::is_accessor() const { if (code_size() != 5) return false; if (size_of_parameters() != 1) return false; if (java_code_at(0) != Bytecodes::_aload_0 ) return false; if (java_code_at(1) != Bytecodes::_getfield) return false; if (java_code_at(4) != Bytecodes::_areturn &amp;&amp; java_code_at(4) != Bytecodes::_ireturn ) return false; return true; }
如果从Java源码的角度来理解，accessor method就是形如这样的：
Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>public class Foo {  </p>
</li>
<li>private int value;  </li>
<li></li>
<li>public int getValue() {  </li>
<li>return this.value;  </li>
<li>}  </li>
<li><p>}<br>public class Foo { private int value; public int getValue() { return this.value; } }
关键点是：
1、必须是成员方法；静态方法不行
2、返回值类型必须是引用类型或者int，其它都不算
3、方法体的代码必须满足aload_0; getfield /#index; areturn或ireturn这样的模式。
留意：方法名是什么都没关系，是不是get、is、has开头都不重要。
那么这俩有啥问题？
取自JDK 6 update 27：
C++代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>product(bool, UseFastEmptyMethods, true,                   \  </p>
</li>
<li>&quot;Use fast method entry code for empty methods&quot;)    \  </li>
<li>\  </li>
<li>product(bool, UseFastAccessorMethods, true,                \  </li>
<li><p>&quot;Use fast method entry code for accessor methods&quot;) \<br>product(bool, UseFastEmptyMethods, true, \ &quot;Use fast method entry code for empty methods&quot;) \ \ product(bool, UseFastAccessorMethods, true, \ &quot;Use fast method entry code for accessor methods&quot;) \
看到这俩参数的默认值都是true了么？也就是说，在Oracle/Sun JDK 6上设置这参数其实也是没意义的，跟默认一样，一直到最新的JDK 6 update 29都是如此。
不过在Oracle/Sun JDK 7里，情况有变化。
<a href="http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6385687" target="_blank">Bug ID: 6385687 UseFastEmptyMethods/UseFastAccessorMethods considered harmful</a>
在<a href="http://hg.openjdk.java.net/jdk7/hotspot-comp/hotspot/rev/c2323e2ea62b" target="_blank">上述bug对应的代码变更</a>后，这俩参数的默认值改为了false。
本来想多写点这块的…算，还是长话短说。
Oracle JDK 7里的HotSpot VM已经开始有比较好的<a href="http://rednaxelafx.iteye.com/blog/1022095" target="_blank">多层编译（tiered compilation）支持</a>，可以预见在不久的将来该模式将成为HotSpot VM默认的执行模式。当前该模式尚未默认开启；可以通过 <strong>-XX:+TieredCompilation</strong> 来开启。
有趣的是，在使用多层编译模式时，如果UseFastAccessorMethods/UseFastEmptyMethods是开着的，有些多态方法调用点的性能反而会显著下降。所以，为了适应多层编译模式，JDK 7里这两个参数的默认值就被改为false了。</p>
<h1 id="-review-for-6385687-usefastemptymethods-usefastaccessormethods-considered-harmful-http-mail-openjdk-java-net-pipermail-hotspot-compiler-dev-2011-march-005057-html-">在邮件列表上有过相关讨论：<a href="http://mail.openjdk.java.net/pipermail/hotspot-compiler-dev/2011-March/005057.html" target="_blank">review for 6385687: UseFastEmptyMethods/UseFastAccessorMethods considered harmful</a></h1>
<p>8、-XX:+UseCMSCompactAtFullCollection
这个参数在Oracle/Sun JDK 6里一直都默认是true，完全没必要显式设置，设了也不会有啥不同的效果。
C++代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>product(bool, UseCMSCompactAtFullCollection, true,    \  </p>
</li>
<li><p>&quot;Use mark sweep compact at full collections&quot;) \<br>product(bool, UseCMSCompactAtFullCollection, true, \ &quot;Use mark sweep compact at full collections&quot;) \
我不认为显式设置一个跟默认值相同的参数有什么维护上的好处。要维护的参数多了反而更容易成为维护的噩梦吧。后面的人会不知道到底当初为什么要设置这个参数。
相关的有个 <strong>CMSFullGCsBeforeCompaction</strong> 参数，请参考另一帖里的讨论：<a href="http://hllvm.group.iteye.com/group/topic/28854#209294" target="_blank"><a href="http://hllvm.group.iteye.com/group/topic/28854/#209294">http://hllvm.group.iteye.com/group/topic/28854/#209294</a></a>
同样，在Oracle/Sun JDK 6和OpenJDK 6里，<strong>CMSParallelRemarkEnabled</strong> 也一直默认是true，没必要显式设置-XX:+CMSParallelRemarkEnabled。
有很多bool类型的参数默认都是true，显式设置它们之前最好先用这帖开头介绍的办法看看默认值是否已经是想要的值了。
C++代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>product(bool, CMSScavengeBeforeRemark, false,          \  </p>
</li>
<li><p>&quot;Attempt scavenge before the CMS remark step&quot;) \<br>product(bool, CMSScavengeBeforeRemark, false, \ &quot;Attempt scavenge before the CMS remark step&quot;) \</p>
<h1 id="-false-young-gc-cms-remark-remark-young-gc-remark-">这个默认倒是false。如果一个应用统计到的young GC时间都比较短而CMS remark的时间比较长，那么可以试试打开这个参数，在做remark之前先做一次young GC。是否能有效缩短remark的时间视应用情况而异，所以开这个参数的话请一定做好测试。</h1>
<p>9、-XX:CMSMaxAbortablePrecleanTime=5000
同上…默认就是5000
C++代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>product(intx, CMSMaxAbortablePrecleanTime, 5000,    \  </p>
</li>
<li>&quot;(Temporary, subject to experimentation)&quot;   \  </li>
<li><p>&quot;Maximum time in abortable preclean in ms&quot;) \<br>product(intx, CMSMaxAbortablePrecleanTime, 5000, \ &quot;(Temporary, subject to experimentation)&quot; \ &quot;Maximum time in abortable preclean in ms&quot;) \</p>
<h1 id="-">还是不要设跟默认值一样的参数了吧。</h1>
<p>10、-Xss 与 -XX:ThreadStackSize
参考我之前发过的两帖：
<a href="http://mail.openjdk.java.net/pipermail/hotspot-dev/2011-June/004272.html" target="_blank">What the difference between -Xss and -XX:ThreadStackSize is?</a>
<a href="http://mail.openjdk.java.net/pipermail/hotspot-dev/2011-July/004288.html" target="_blank">Inconsistency between -Xss and -XX:ThreadStackSize in the java launcher</a></p>
<h1 id="-">（详情回头补～）</h1>
<p>11、-Xmn 与 -XX:NewSize、-XX:MaxNewSize</p>
<h1 id="-xx-newsize-xx-maxnewsize-could-not-reserve-enough-space-for-object-heap-http-hllvm-group-iteye-com-group-topic-28467-206341-jdk-6-jdk-6-update-14-">如果同时设置了-XX:NewSize与-XX:MaxNewSize遇到“Could not reserve enough space for object heap”错误的话，请看看是不是<a href="http://hllvm.group.iteye.com/group/topic/28467#206341" target="_blank">这帖所说的问题</a>。早期JDK 6似乎都受这问题影响，一直到JDK 6 update 14才修复。</h1>
<h1 id="12-xmn-xx-newratio">12、-Xmn 与 -XX:NewRatio</h1>
<h1 id="13-xx-newratio-xx-newsize-xx-oldsize">13、-XX:NewRatio 与 -XX:NewSize、-XX:OldSize</h1>
<p>14、jmap -heap看到的参数值与实际起作用的参数的关系？
发了几个例子在这里：<a href="https://gist.github.com/1363195" target="_blank"><a href="https://gist.github.com/1363195">https://gist.github.com/1363195</a></a>
其中有个看起来很恐怖的值：
Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>MaxNewSize       = 17592186044415 MB<br>MaxNewSize = 17592186044415 MB
这是啥来的？
C++代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>product(uintx, MaxNewSize, max_uintx,                                  \  </p>
</li>
<li>&quot;Maximum new generation size (in bytes), max_uintx means set &quot; \  </li>
<li><p>&quot;ergonomically&quot;)<br>product(uintx, MaxNewSize, max_uintx, \ &quot;Maximum new generation size (in bytes), max_uintx means set &quot; \ &quot;ergonomically&quot;)
在HotSpot VM里，intx是跟平台字长一样宽的带符号整型，uintx是其无符号版。
max_uintx是(uintx) -1，也就是说在32位平台上是无符号的0xFFFFFFFF，64位平台上则是0xFFFFFFFFFFFFFFFF。
jmap -heap显示的部分参数是以MB为单位来显示的，而MaxNewSize的单位是byte。我跑例子的平台是64位的，于是算一下 0xFFFFFFFFFFFFFFFF / 1024 / 1024 = 17592186044415 MB 。
参数的说明告诉我们，当MaxNewSize的值等于max_uintx时，意思就是交由ergonomics来自动选择young gen的最大大小。<strong>并不是说young gen的最大大小真的有0xFFFFFFFFFFFFFFFF这么大</strong>。
要注意的是，HotSpot VM有大量可调节的参数，并不是所有参数在某次运行的时候都有效。
例如说设置了-Xmn的话，NewRatio就没作用了。
又例如说，
C++代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>product(uintx, OldSize, ScaleForWordSize(4/*M),        \  </p>
</li>
<li><p>&quot;Initial tenured generation size (in bytes)&quot;) \<br>product(uintx, OldSize, ScaleForWordSize(4/*M), \ &quot;Initial tenured generation size (in bytes)&quot;) \
-XX:OldSize参数的默认值在32位平台上是4M，在64位平台上是5M多。但如果这个参数没有被显式设置过，那它实际上是没作用的；old gen的大小会通过Java heap的整体大小与young gen的大小配置计算出来，但OldSize参数却没有被更新（因为根本没用它）。于是这个参数的值与实际运行的状况就可能会不相符。
一种例外的情况是，如果-Xmx非常小，比NewSize+OldSize的默认值还小，那这个OldSize的默认值就会起作用，把MaxHeapSize给撑大。
C++代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>void TwoGenerationCollectorPolicy::initialize_flags() {  </p>
</li>
<li>GenCollectorPolicy::initialize_flags();  </li>
<li></li>
<li>OldSize = align_size_down(OldSize, min_alignment());  </li>
<li>if (NewSize + OldSize &gt; MaxHeapSize) {  </li>
<li>MaxHeapSize = NewSize + OldSize;  </li>
<li>}  </li>
<li>MaxHeapSize = align_size_up(MaxHeapSize, max_alignment());  </li>
<li>//...  </li>
<li><p>}<br>void TwoGenerationCollectorPolicy::initialize_flags() { GenCollectorPolicy::initialize_flags(); OldSize = align_size_down(OldSize, min_alignment()); if (NewSize + OldSize &gt; MaxHeapSize) { MaxHeapSize = NewSize + OldSize; } MaxHeapSize = align_size_up(MaxHeapSize, max_alignment()); //... }</p>
<h1 id="-https-gist-github-com-1375782-https-gist-github-com-1375782-">可以看这边的一个例子：<a href="https://gist.github.com/1375782" target="_blank"><a href="https://gist.github.com/1375782">https://gist.github.com/1375782</a></a></h1>
<p>15、-XX:+AlwaysTenure、-XX:+NeverTenure、-XX:MaxTenuringThreshold=0 或 &quot;-XX:MaxTenuringThreshold=markOopDesc::max_age + 1&quot;
ParNew的时候，设定-XX:+AlwaysTenure隐含-XX:MaxTenuringThreshold=0；不过-XX:+NeverTenure却没啥特别的作用。</p>
<h1 id="-xx-alwaystenure-xx-nevertenure-">-XX:+AlwaysTenure 与 -XX:+NeverTenure 是互斥的，最后一个出现的那个会同时决定这两个参数的值。</h1>
<p>16、-XX:MaxTenuringThreshold 的默认值？
C++代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>product(intx, MaxTenuringThreshold,    15, \  </p>
</li>
<li><p>&quot;Maximum value for tenuring threshold&quot;)  \<br>product(intx, MaxTenuringThreshold, 15, \ &quot;Maximum value for tenuring threshold&quot;) \
Oracle/Sun JDK 6中，选择CMS之外的GC时，MaxTenuringThreshold（以下简称MTT）的默认值是15；而选择了CMS的时候，MTT的默认值是4而不是15。设定是在 Arguments::set_cms_and_parnew_gc_flags() 里做的。
在Sun JDK 6之前（1.4.2、5），选择CMS的时候MTT的默认值则是0，也就是等于设定了-XX:+AlwaysTenure——所有eden里的活对象在经历第一次minor GC的时候就会直接晋升到old gen，而survivor space直接就没用了。
Command prompt代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>$ java -version  </p>
</li>
<li>java version &quot;1.6.0_25&quot;  </li>
<li>Java(TM) SE Runtime Environment (build 1.6.0_25-b06)  </li>
<li>Java HotSpot(TM) 64-Bit Server VM (build 20.0-b11, mixed mode)  </li>
<li>$ java -XX:+PrintFlagsFinal | egrep &#39;MaxTenuringThreshold|UseParallelGC|UseConcMarkSweepGC&#39;  </li>
<li>intx MaxTenuringThreshold                      = 15              {product}             </li>
<li>bool UseConcMarkSweepGC                        = false           {product}             </li>
<li>bool UseParallelGC                            := true            {product}             </li>
<li>$ java -XX:+PrintFlagsFinal -XX:+UseConcMarkSweepGC | egrep &#39;MaxTenuringThreshold|UseParallelGC|UseConcMarkSweepGC&#39;  </li>
<li>intx MaxTenuringThreshold                     := 4               {product}             </li>
<li>bool UseConcMarkSweepGC                       := true            {product}             </li>
<li><p>bool UseParallelGC                             = false           {product}             </p>
<h1 id="-java-version-java-version-1-6-0_25-java-tm-se-runtime-environment-build-1-6-0_25-b06-java-hotspot-tm-64-bit-server-vm-build-20-0-b11-mixed-mode-java-xx-printflagsfinal-egrep-maxtenuringthreshold-useparallelgc-useconcmarksweepgc-intx-maxtenuringthreshold-15-product-bool-useconcmarksweepgc-false-product-bool-useparallelgc-true-product-java-xx-printflagsfinal-xx-useconcmarksweepgc-egrep-maxtenuringthreshold-useparallelgc-useconcmarksweepgc-intx-maxtenuringthreshold-4-product-bool-useconcmarksweepgc-true-product-bool-useparallelgc-false-product-">$ java -version java version &quot;1.6.0_25&quot; Java(TM) SE Runtime Environment (build 1.6.0_25-b06) Java HotSpot(TM) 64-Bit Server VM (build 20.0-b11, mixed mode) $ java -XX:+PrintFlagsFinal | egrep &#39;MaxTenuringThreshold|UseParallelGC|UseConcMarkSweepGC&#39; intx MaxTenuringThreshold = 15 {product} bool UseConcMarkSweepGC = false {product} bool UseParallelGC := true {product} $ java -XX:+PrintFlagsFinal -XX:+UseConcMarkSweepGC | egrep &#39;MaxTenuringThreshold|UseParallelGC|UseConcMarkSweepGC&#39; intx MaxTenuringThreshold := 4 {product} bool UseConcMarkSweepGC := true {product} bool UseParallelGC = false {product}</h1>
<p>17、-XX:+CMSClassUnloadingEnabled</p>
<h1 id="cms-remark-string-intern-">CMS remark暂停时间会增加，所以如果类加载并不频繁、String的intern也没有大量使用的话，这个参数还是不开的好。</h1>
<h1 id="18-xx-aggressiveheap">18、-XX:+AggressiveHeap</h1>
<p>19、-XX:+UseCompressedOops 有益？有害？
先把微博上回复别人问题的解答放这边。
本来如果功能没bug的话，Oracle/Sun JDK 6的64位HotSpot上，GC堆在26G以下（-Xmx + -XX:MaxPermSize）的时候用多数都是有益的。
开启压缩指针后，从代码路径（code path）和CPI（cycles per instruction）两个角度看，情况是不一样的：
·开启压缩指针会使代码路径变长，因为所有在GC堆里的、指向GC堆内对象的指针都会被压缩，这些指针的访问就需要更多的代码才可以实现。不要以为只是读写字段才受影响，其实实例方法调用、子类型检查等操作也受影响——“klass”也是一个指针，也被压缩了。
·但从CPI的角度看，由于压缩指针使需要拷贝的数据量变小了，cache miss的几率随之降低，结果CPI可能会比压缩前降低。综合来看，开了压缩指针通常能大幅降低GC堆内存的消耗，同时维持或略提高Java程序的速度。
但，JDK6u23之前那个参数的bug实在太多，最好别用；而6u23之后它就由ergonomics自动开启了，不用自己设。如果在6u23或更高版本碰到压缩指针造成的问题的话，显式设置 <strong>-XX:-UseCompressedOops</strong> 。
我能做的建议是如果在64位Oracle/Sun JDK 6/7上，那个参数不要显式设置。
关于HotSpot VM的ergonomics自动开启压缩指针功能，请参考<a href="http://rednaxelafx.iteye.com/blog/1010079" target="_blank">之前的一帖</a>。</p>
<h1 id="-vm-berkeley-db-java-edition-http-www-oracle-com-technetwork-database-berkeleydb-overview-index-093405-html-bdb-je-xx-usecompressedoops-bdb-je-java-permgen-32gb-xx-usecompressedoops-warning-on-compressed-oops-https-forums-oracle-com-forums-thread-jspa-messageid-10017916-">有些库比较“聪明”，会自行读取VM参数来调整自己的一些参数，例如<a href="http://www.oracle.com/technetwork/database/berkeleydb/overview/index-093405.html" target="_blank">Berkeley DB Java Edition</a>。但这些库实现得不好的时候反而会带来一些麻烦：BDB JE要求<strong>显式指定-XX:+UseCompressedOops</strong>才能有效的调整它的缓存大小。所以在用BDB JE并且Java堆+PermGen大小小于32GB的时候，请显式指定-XX:+UseCompressedOops吧。参考<a href="https://forums.oracle.com/forums/thread.jspa?messageID=10017916" target="_blank">Warning on Compressed Oops</a></h1>
<p>20、-XX:LargePageSizeInBytes=128m ？
或者是 -XX:LargePageSizeInBytes=256m ？
其实这个参数的值是多少不是问题，问题是这个参数到底有没有起作用。
或许有人读过很老的调优建议资料，例如这个：
<a href="http://java.sun.com/performance/reference/whitepapers/tuning.html#section4.2.3" target="_blank">(2005) Java Tuning White Paper - 4.2.3 Tuning Example 3: Try 256 MB pages</a>
或者是别的一些内容很老的资料。它们提到了-XX:LargePageSizeInBytes=参数。这些老资料也没说错，在Sun JDK 5里 -XX:LargePageSizeInBytes= 参数只在Solaris上有效，使用的时候没有别的参数保护。
但是，实际上这个参数在Oracle/Sun JDK 6里不配合-XX:+UseLargePages的话是不会起任何作用的。
JDK 6里的JVM的Linux版上初始化large page的地方：
C++代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>bool os::large_page_init() {  </p>
</li>
<li>if (!UseLargePages) return false;  </li>
<li></li>
<li>if (LargePageSizeInBytes) {  </li>
<li>_large_page_size = LargePageSizeInBytes;  </li>
<li>} else {  </li>
<li>// ...  </li>
<li>}  </li>
<li></li>
<li>// ...  </li>
<li></li>
<li>// Large page support is available on 2.6 or newer kernel, some vendors  </li>
<li>// (e.g. Redhat) have backported it to their 2.4 based distributions.  </li>
<li>// We optimistically assume the support is available. If later it turns out  </li>
<li>// not true, VM will automatically switch to use regular page size.  </li>
<li>return true;  </li>
<li><p>}<br>bool os::large_page_init() { if (!UseLargePages) return false; if (LargePageSizeInBytes) { _large_page_size = LargePageSizeInBytes; } else { // ... } // ... // Large page support is available on 2.6 or newer kernel, some vendors // (e.g. Redhat) have backported it to their 2.4 based distributions. // We optimistically assume the support is available. If later it turns out // not true, VM will automatically switch to use regular page size. return true; }
看到了么，没有将UseLargePages设置为true的话，LargePageSizeInBytes根本没机会被用上。
对应的，Solaris版：
C++代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>bool os::large_page_init() {  </p>
</li>
<li>if (!UseLargePages) {  </li>
<li>UseISM = false;  </li>
<li>UseMPSS = false;  </li>
<li>return false;  </li>
<li>}  </li>
<li></li>
<li>// ...  </li>
<li><p>}<br>bool os::large_page_init() { if (!UseLargePages) { UseISM = false; UseMPSS = false; return false; } // ... }
以及Windows版：
C++代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>bool os::large_page_init() {  </p>
</li>
<li>if (!UseLargePages) return false;  </li>
<li></li>
<li>// ...  </li>
<li>}<br>bool os::large_page_init() { if (!UseLargePages) return false; // ... }<h1 id="-oracle-sun-jdk-6-oracle-jdk-7-xx-largepagesizeinbytes-xx-uselargepages-large-pages-regular-pages-">在Oracle/Sun JDK 6以及Oracle JDK 7上要使用 -XX:LargePageSizeInBytes= 的话，请务必也设置上 -XX:+UseLargePages 。使用这两个参数之前最好先确认操作系统是否真的只是large pages；操作系统不支持的话，设置这两个参数也没作用，只会退回到使用regular pages而已。</h1>
21、-XX:+AlwaysPreTouch
会把commit的空间跑循环赋值为0以达到“pretouch”的目的。开这个参数会增加VM初始化时的开销，但后面涉及虚拟内存的开销可能降低。<h1 id="-http-hllvm-group-iteye-com-group-topic-28839-209144-http-hllvm-group-iteye-com-group-topic-28839-209144-">在另一个讨论帖里有讲该参数：<a href="http://hllvm.group.iteye.com/group/topic/28839#209144" target="_blank"><a href="http://hllvm.group.iteye.com/group/topic/28839/#209144">http://hllvm.group.iteye.com/group/topic/28839/#209144</a></a></h1>
<h1 id="22-xx-usetlab-runtime-freememory-">22、-XX:+UseTLAB 与 Runtime.freeMemory()</h1>
23、-XX:+ParallelRefProcEnabled
这个功能可以加速reference processing，但在JDK6u25和6u26上不要使用，有bug：<h1 id="-bug-id-7028845-cms-6984287-broke-parallel-reference-processing-in-cms-http-bugs-sun-com-bugdatabase-view_bug-do-bug_id-7028845-"><a href="http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=7028845" target="_blank">Bug ID 7028845: CMS: 6984287 broke parallel reference processing in CMS</a></h1>
24、-XX:+UseConcMarkSweepGC 与 -XX:+UseAdaptiveSizePolicy
这两个选项在现有的Oracle/Sun JDK 6和Oracle JDK 7上都不要搭配在一起使用——CMS用的adaptive size policy还没实现完，用的话可能会crash。
目前HotSpot VM上只有ParallelScavenge系的GC才可以配合-XX:+UseAdaptiveSizePolicy使用；也就是只有-XX:+UseParallelGC或者-XX:+UseParallelOldGC。<a href="http://mail.openjdk.java.net/pipermail/hotspot-gc-use/2011-November/000954.html" target="_blank">Jon Masamitsu在邮件列表上提到过</a>。<h1 id="-useadaptivesizepolicy-parallelscavenge-survivor-space-jon-masamitsu-http-mail-openjdk-java-net-pipermail-hotspot-gc-use-2012-october-001390-html-">题外话：开着UseAdaptiveSizePolicy的ParallelScavenge会动态调整各空间的大小，有可能会造成两个survivor space的大小被调整得不一样大。Jon Masamitsu在<a href="http://mail.openjdk.java.net/pipermail/hotspot-gc-use/2012-October/001390.html" target="_blank">这封邮件</a>里解释了原因。</h1>
25、-XX:+UseAdaptiveGCBoundary<h1 id="jdk-6-bug-">JDK 6里不要用这个选项，有bug。</h1>
26、-XX:HeapDumpPath 与 -XX:+HeapDumpBeforeFullGC、-XX:+HeapDumpAfterFullGC、-XX:+HeapDumpOnOutOfMemoryError
-XX:+HeapDumpBeforeFullGC、-XX:+HeapDumpAfterFullGC、-XX:+HeapDumpOnOutOfMemoryError 这几个参数可以在不同条件下做出HPROF格式的heap dump。但很多人都会疑惑：做出来的heap dump存到哪里去了？
如果不想费神去摸索到底各种环境被配置成什么样、“working directory”到底在哪里的话，就在VM启动参数里加上 <strong>-XX:HeapDumpPath=一个绝对路径</strong> 吧。这样，自动做出的heap dump就会被存到指定的目录里去。<h1 id="-working-directory-">当然相对路径也支持，不过用了相对路径就又得弄清楚当前的“working directory”在哪里了。</h1>
26、UseDepthFirstScavengeOrder
以前有过这样一个参数可以设置young gen遍历对象图的顺序，深度还是广度优先不过高于JDK 6 update 22就没用了，ParallelScavenge变为只用深度优先而不用广度优先。
具体的changeset在这里：<a href="http://hg.openjdk.java.net/hsx/hotspot-main/hotspot/rev/9d7a8ab3736b" target="_blank"><a href="http://hg.openjdk.java.net/hsx/hotspot-main/hotspot/rev/9d7a8ab3736b">http://hg.openjdk.java.net/hsx/hotspot-main/hotspot/rev/9d7a8ab3736b</a></a>
HotSpot VM里的arguments.cpp文件里有obsolete_jvm_flags数组，那边声明的参数都要留意是已经没用的。
（下文待续～）
<img src="" alt="Spinner"> <a href="http://learnworld.iteye.com/" target="_blank"><img src="&quot;learnworld的博客: 一路远行&quot;" alt="learnworld的博客"></a> <a href="http://learnworld.iteye.com/" title="learnworld" target="_blank">learnworld</a> 2011-10-23</li>
</ol>
<p>好贴，坐等下文。
<img src="" alt="Spinner"> <a href="http://jolestar.iteye.com/" target="_blank"><img src="&quot;jolestar的博客: 午夜咖啡&quot;" alt="jolestar的博客"></a> <a href="http://jolestar.iteye.com/" title="jolestar" target="_blank">jolestar</a> 2011-10-23</p>
<p>lz不厚道，说了个半句话就闪了。太吊胃口了。
<img src="" alt="Spinner"> <a href="http://boy00fly.iteye.com/" target="_blank"><img src="&quot;boy00fly的博客: 石头边的老牛&quot;" alt="boy00fly的博客"></a> <a href="http://boy00fly.iteye.com/" title="boy00fly" target="_blank">boy00fly</a> 2011-10-24</p>
<p>jolestar 写道</p>
<p>lz不厚道，说了个半句话就闪了。太吊胃口了。
哈哈，确实吊胃口。。下文呢？
<img src="" alt="Spinner"> <a href="http://icanfly.iteye.com/" target="_blank"><img src="&quot;icanfly的博客: 老罗宣言&quot;" alt="icanfly的博客"></a> <a href="http://icanfly.iteye.com/" title="icanfly" target="_blank">icanfly</a> 2011-10-24</p>
<p>好文。<img src="" alt="">
<img src="" alt="Spinner"> <a href="http://liuyes.iteye.com/" target="_blank"><img src="&quot;liuyes的博客: &quot;" alt="liuyes的博客"></a> <a href="http://liuyes.iteye.com/" title="liuyes" target="_blank">liuyes</a> 2011-10-24</p>
<p>楼主人呢？这发文的也有坑<img src="" alt="">
<img src="" alt="Spinner"> <a href="http://khotyn.iteye.com/" target="_blank"><img src="&quot;khotyn的博客: 码工作坊&quot;" alt="khotyn的博客"></a> <a href="http://khotyn.iteye.com/" title="khotyn" target="_blank">khotyn</a> 2011-10-24</p>
<p>坐等R大把坑填上～～
<img src="" alt="Spinner"> <a href="http://furturestrategist.iteye.com/" target="_blank"><img src="&quot;程序新手的博客: HappyProgramme&quot;" alt="程序新手的博客"></a> <a href="http://furturestrategist.iteye.com/" title="程序新手" target="_blank">程序新手</a> 2011-10-24</p>
<p>内容受益、风格简洁，期待下文
  另外大胆猜测从日志中获取的信息是部分FULL GC由System.gc()引发的
  Full GC (System)
<img src="" alt="Spinner"> <a href="http://furturestrategist.iteye.com/" target="_blank"><img src="&quot;程序新手的博客: HappyProgramme&quot;" alt="程序新手的博客"></a> <a href="http://furturestrategist.iteye.com/" title="程序新手" target="_blank">程序新手</a> 2011-10-25</p>
<p>又受益了 <img src="" alt=""> ..想了解大大收集这些知识点的方法~
<img src="" alt="Spinner"> <a href="http://hittyt.iteye.com/" target="_blank"><img src="&quot;hittyt的博客: 笨小孩&quot;" alt="hittyt的博客"></a> <a href="http://hittyt.iteye.com/" title="hittyt" target="_blank">hittyt</a> 2011-11-08</p>
<p>本人的java环境如下：
Command line代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>java -version  </li>
<li>java version &quot;1.6.0_18&quot;  </li>
<li>Java(TM) SE Runtime Environment (build 1.6.0_18-b07)  </li>
<li><p>Java HotSpot(TM) 64-Bit Server VM (build 16.0-b13, mixed mode)<br>java -version java version &quot;1.6.0_18&quot; Java(TM) SE Runtime Environment (build 1.6.0_18-b07) Java HotSpot(TM) 64-Bit Server VM (build 16.0-b13, mixed mode)
但使用PrintFlagsFinal时得到的输出却是下面的结果：
Command line代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>java -XX:+PrintFlagsFinal  </p>
</li>
<li>Unrecognized VM option &#39;+PrintFlagsFinal&#39;  </li>
<li>Could not create the Java virtual machine.<br>java -XX:+PrintFlagsFinal Unrecognized VM option &#39;+PrintFlagsFinal&#39; Could not create the Java virtual machine.
求LZ解答问题在哪里呢？
<img src="" alt="Spinner"></li>
</ol>
<p><img src="" alt=""> <a href="http://hllvm.group.iteye.com/group/topic/27945/post/new" target="_blank">发表回复</a></p>
<p>« 上一页 1 <a href="http://hllvm.group.iteye.com/group/topic/27945?page=2" target="_blank">2</a> <a href="http://hllvm.group.iteye.com/group/topic/27945?page=3" target="_blank">3</a> <a href="http://hllvm.group.iteye.com/group/topic/27945?page=2" target="_blank">下一页 »</a></p>
<p><a href="http://hllvm.group.iteye.com/" target="_blank">&gt;&gt;返回群组首页</a></p>
<p><a href="http://hllvm.group.iteye.com/" target="_blank"><img src="&quot;高级语言虚拟机: 关注各种高级语言虚拟机（high-level language virtual machine，HLL VM）的设计与实现，泛化至各种高级语言的运行时的设计与实现。讨论范围包括JVM、CLI、Parrot等当前流行的VM平台，也包括Python、Ruby、JavaScript、Lua、Perl、Forth、Smalltalk等众多语言的引擎，还有历史上有影响的各种高级语言虚拟机，如SECD等。&quot;" alt="高级语言虚拟机群组"></a></p>
<h3 id="-">相关讨论</h3>
<ul>
<li><a href="http://www.iteye.com/topic/212967" target="_blank">一次Java垃圾收集调优实战</a></li>
<li><a href="http://www.iteye.com/topic/894148" target="_blank">HotSpot VM 内存堆的两个Servivor区</a></li>
<li><a href="http://www.iteye.com/topic/802638" target="_blank">JVM内存管理：深入垃圾收集器与内存分配策略</a></li>
<li><a href="http://www.iteye.com/topic/473874" target="_blank">CMS gc实践总结</a></li>
<li><a href="http://www.iteye.com/topic/756538" target="_blank">优化JVM参数提高eclipse运行速度</a></li>
<li><a href="http://www.iteye.com/" target="_blank">首页</a></li>
<li><a href="http://www.iteye.com/news" target="_blank">资讯</a></li>
<li><a href="http://www.iteye.com/magazines" target="_blank">精华</a></li>
<li><a href="http://www.iteye.com/forums" target="_blank">论坛</a></li>
<li><a href="http://www.iteye.com/ask" target="_blank">问答</a></li>
<li><a href="http://www.iteye.com/blogs" target="_blank">博客</a></li>
<li><a href="http://www.iteye.com/blogs/subjects" target="_blank">专栏</a></li>
<li><a href="http://www.iteye.com/groups" target="_blank">群组</a></li>
<li><a href="http://job.iteye.com/iteye" target="_blank">招聘</a></li>
<li><a href="http://www.iteye.com/search" target="_blank">搜索</a></li>
<li><a href="http://hllvm.group.iteye.com/index/service" target="_blank">广告服务</a></li>
<li><a href="http://webmaster.iteye.com/" target="_blank">ITeye黑板报</a></li>
<li><a href="http://hllvm.group.iteye.com/index/contactus" target="_blank">联系我们</a></li>
<li><a href="http://hllvm.group.iteye.com/index/friend_links" target="_blank">友情链接</a></li>
</ul>
<p>© 2003-2012 ITeye.com. [ <a href="http://www.miibeian.gov.cn/" target="_blank">京ICP证110151号</a> 京公网安备110105010620 ]
百联优力(北京)投资有限公司 版权所有 <img src="http://stat.iteye.com/?url=http%3A%2F%2Fhllvm.group.iteye.com%2Fgroup%2Ftopic%2F27945&amp;referrer=http%3A%2F%2Fhllvm.group.iteye.com%2F&amp;user_id=" alt=""></p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/JVM/">JVM</a></li></span></span> | <span class="tags">Tagged <a href="/tags/JVM/" class="label label-primary">JVM</a><a href="/tags/Java&J2EE/" class="label label-success">Java&J2EE</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:42"datetime="2014-03-07 09:54:42"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-JVM--JVM调优的-标准参数-的各种陷阱/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-JVM--JVM调优的-标准参数-的各种陷阱" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--一个面试官对面试问题的分析JVM/">一个面试官对面试问题的分析(JVM)</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:42.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--一个面试官对面试问题的分析JVM/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-jvm-">一个面试官对面试问题的分析(JVM)</h1>
<p><a href="">&lt;</a> <a href="">&gt;</a>  猎头职位: <a href="http://www.iteye.com/jobs/1848" target="_blank">北京:  ITeye网站诚聘社区编辑</a></p>
<p>相关文章: <a href="&quot;关闭&quot;"> </a></p>
<ul>
<li><a href="http://www.iteye.com/topic/715256" title="大家都来说说自己最讨厌的面试题目吧。" target="_blank">大家都来说说自己最讨厌的面试题目吧。</a></li>
<li><a href="http://www.iteye.com/topic/1117953" title="今天下午接到阿里的电话面试" target="_blank">今天下午接到阿里的电话面试</a></li>
<li><a href="http://www.iteye.com/topic/1018932" title="虚拟机中的锁优化简介（适应性自旋/锁粗化/锁削除/轻量级锁/偏向锁）" target="_blank">虚拟机中的锁优化简介（适应性自旋/锁粗化/锁削除/轻量级锁/偏向锁）</a>
推荐群组: <a href="http://hllvm.group.iteye.com/" target="_blank">高级语言虚拟机</a>
<a href="http://www.iteye.com/wiki/topic/715304" target="_blank">更多相关推荐</a>
<a href="http://www.iteye.com/forums/tag/%E6%B1%82%E8%81%8C%E7%BB%8F%E9%AA%8C" target="_blank">求职经验</a> <em>这个帖子的背景是今晚看到je上这张贴：<a href="http://www.iteye.com/topic/715256，心血来潮写下的文字，如果能抛砖引玉，能有其他面试官分析一下自己面试时问的问题，那或许是件很有意义的事情。" target="_blank">http://www.iteye.com/topic/715256，心血来潮写下的文字，如果能抛砖引玉，能有其他面试官分析一下自己面试时问的问题，那或许是件很有意义的事情。</a></em>
  在公司当技术面试官几年间，从应届生到工作十几年的应聘者都遇到过。先表达一下我自己对面试的观点：
  1.笔试、面试去评价一个人肯定是不够准确的，了解一个人最准确的方式就是“路遥知马力，日久见人心”。通过一、二个小时内的做题、交流，只是没有其他办法下进行的无奈之举，所以通过了面试不代表有多成功，没通过也不代表有多失败。
  2.好的面试官本身交谈的时候就不应当把自己一个居高临下的角色上，应当把自己和应聘者当做两个做技术的人平等的交流，把自己当作权威往往就会受到观点的角度、语言表达、工作领域的惯性的制约。
  3.好的考察题目则是大家能经常接触，不同层次的人能有不同层次的答案，能从问题引申出后面继续讨论的话题。
  举个例子抛砖引玉，下面这个问题是我以前常问的，从应届生到工作十几年的人都问过：
引用</li>
</ul>
<p>“地球人都知道，Java有个东西叫垃圾收集器，它让创建的对象不需要像c/cpp那样delete、free掉，你能不能谈谈，GC是在什么时候，对什么东西，做了什么事情？”
我自己分析一下这个问题，首先是“什么时候”，不同层次的回答从低到高排列：
    1.系统空闲的时候。
    分析：这种回答大约占30%，遇到的话一般我就会准备转向别的话题，譬如算法、譬如SSH看看能否发掘一些他擅长的其他方面。
    2.系统自身决定，不可预测的时间/调用System.gc()的时候。
    分析：这种回答大约占55%，大部分应届生都能回答到这个答案，起码不能算错误是吧，后续应当细分一下到底是语言表述导致答案太笼统，还是本身就只有这样一个模糊的认识。
    3.能说出新生代、老年代结构，能提出minor gc/full gc
    分析：到了这个层次，基本上能说对GC运作有概念上的了解，譬如看过《深入JVM虚拟机》之类的。这部分不足10%。
    4.能说明minor gc/full gc的触发条件、OOM的触发条件，降低GC的调优的策略。
    分析：列举一些我期望的回答：eden满了minor gc，升到老年代的对象大于老年代剩余空间full gc，或者小于时被HandlePromotionFailure参数强制full gc；gc与非gc时间耗时超过了GCTimeRatio的限制引发OOM，调优诸如通过NewRatio控制新生代老年代比例，通过MaxTenuringThreshold控制进入老年前生存次数等……能回答道这个阶段就会给我带来比较高的期望了，当然面试的时候正常人都不会记得每个参数的拼写，我自己写这段话的时候也是翻过手册的。回答道这部分的小于2%。
PS：加起来不到100%，是因为有确实少数直接说不知道，或者直接拒绝回答的= =/#
    分析第二个问题：“对什么东西”：
    1.不使用的对象。
    分析：相当于没有回答，问题就是在问什么对象才是“不使用的对象”。大约占30%。
    2.超出作用域的对象/引用计数为空的对象。
    分析：这2个回答站了60%，相当高的比例，估计学校教java的时候老师就是这样教的。第一个回答没有解决我的疑问，gc到底怎么判断哪些对象在不在作用域的？至于引用计数来判断对象是否可收集的，我可以会补充一个下面这个例子让面试者分析一下obj1、obj2是否会被GC掉？
    class C{
         public Object x;
    }
    C obj1、obj2 = new C();
    obj1.x = obj2;
    obj2.x = obj1;
    obj1、obj2 = null;
    3.从gc root开始搜索，搜索不到的对象。
    分析：根对象查找、标记已经算是不错了，小于5%的人可以回答道这步，估计是引用计数的方式太“深入民心”了。基本可以得到这个问题全部分数。
    PS：有面试者在这个问补充强引用、弱引用、软引用、幻影引用区别等，不是我想问的答案，但可以加分。
    4.从root搜索不到，而且经过第一次标记、清理后，仍然没有复活的对象。
    分析：我期待的答案。但是的确很少面试者会回答到这一点，所以在我心中回答道第3点我就给全部分数。
    最后由一个问题：“做什么事情”，这个问发挥的空间就太大了，不同年代、不同收集器的动作非常多。
    1.删除不使用的对象，腾出内存空间。
    分析：同问题2第一点。40%。
    2.补充一些诸如停止其他线程执行、运行finalize等的说明。
    分析：起码把问题具体化了一些，如果像答案1那样我很难在回答中找到话题继续展开，大约占40%的人。
    补充一点题外话，面试时我最怕遇到的回答就是“这个问题我说不上来，但是遇到的时候我上网搜一下能做出来”。做程序开发确实不是去锻炼茴香豆的“茴”有几种写法，不死记硬背我同意，我不会纠语法、单词，但是多少你说个思路呀，要直接回答一个上网搜，我完全没办法从中获取可以评价应聘者的信息，也很难从回答中继续发掘话题展开讨论。建议大家尽量回答引向自己熟悉的，可讨论的领域，展现给面试官最擅长的一面。
    3.能说出诸如新生代做的是复制清理、from survivor、to survivor是干啥用的、老年代做的是标记清理、标记清理后碎片要不要整理、复制清理和标记清理有有什么优劣势等。
    分析：也是看过《深入JVM虚拟机》的基本都能回答道这个程度，其实到这个程度我已经比较期待了。同样小于10%。
    4.除了3外，还能讲清楚串行、并行（整理/不整理碎片）、CMS等搜集器可作用的年代、特点、优劣势，并且能说明控制/调整收集器选择的方式。
    分析：同上面2个问题的第四点。
    最后介绍一下自己的背景，在一间不大不小的上市软件公司担任平台架构师，有3年左右的面试官经验，工作主要方向是大规模企业级应用，参与过若干个亿元级的项目的底层架构工作。</p>
<p>ps一下：上面这个问题，倒是遇到过应届生给我相当超出预期的答案，工作经验好量化，天分与兴趣不好考察，但往往日后的骨干就要从这种有天分的苗子开始培养起。
这种题目拿来考应届生，如果来来回回回答的都是深入JVM之类的书本上的，那么也就是靠背出来的，应试能力强而已
对于应届生，我更关心1。理解能力，2.服从性，3。伪代码能力，其他的么，不能算加分，包括学历
考5年以内也不合适，一般5年内的同学的工作层次达不到需要研究JVM和底层一些机制的地步，绝大部分的工作能力和长处并不在此，拿这种东西否定一个人，不过是刁难人罢了
研究JVM和底层的目的是什么，绝不是背几个段子秀一下，其实就一般的工作范围而言，主要是为了调优，考架构师这个层次，这个题目还差不多，但是到这个层次，只是一些书本上的标准回答，又不能满足我了，需要设计一些具体场景，才能看出一个人的能力</p>
<p>在java的实际开发中针对垃圾回收到底要注意什么，垃圾回收都是自动化，到底还需要我们做哪些工作来针对垃圾回收呢，，不明白，望赐教。
主贴内容不错，学习了。
但抱怨的兄弟好像是说你招一程序员，根本用不着问JVM的东西。
我也有一个疑问：是不是招一程序员就得考虑这人是不是将来能成为更高级的人才？有没有评价好的程序员的标准？</p>
<p>fairplay 写道</p>
<p>这种题目拿来考应届生，如果来来回回回答的都是深入JVM之类的书本上的，那么也就是靠背出来的，应试能力强而已
对于应届生，我更关心1。理解能力，2.服从性，3。伪代码能力，其他的么，不能算加分，包括学历
考5年以内也不合适，一般5年内的同学的工作层次达不到需要研究JVM和底层一些机制的地步，绝大部分的工作能力和长处并不在此，拿这种东西否定一个人，不过是刁难人罢了
研究JVM和底层的目的是什么，绝不是背几个段子秀一下，其实就一般的工作范围而言，主要是为了调优，考架构师这个层次，这个题目还差不多，但是到这个层次，只是一些书本上的标准回答，又不能满足我了，需要设计一些具体场景，才能看出一个人的能力
98%以上的应届生的回答不会和JVM有关系，大多停留在第2点答案的水平，这些答案都符合我对应届生的期望呀。
但是如果应届生能回答道第3、4点，哪怕是真的看过教程，或者《深入jvm》之类的书跟我复述出来，无论最后是否愿意入职，我都会很乐意和他保持长期联系。
我面试还经常问一个开放性的问题：“请跟我介绍一下你最近看的一本技术书籍”，很多应届生、应聘者在这个问题上都没有给我留下印象，现在的应届生能看一本书，还把书看成几页纸再用自己的话说出来，说实话已经是一件不太容易的事情。
对于工作经验实在是没有办法之中去量化能力的一个指标，就在今年上半年，我面过10年经验要价3.5K（是K不是W，是自己开价）的，真的被吓到了。另外我自己的工作年限也还不到5年，没有资格要求别人更多。
王者之剑 写道</p>
<p>主贴内容不错，学习了。
但抱怨的兄弟好像是说你招一程序员，根本用不着问JVM的东西。
我也有一个疑问：是不是招一程序员就得考虑这人是不是将来能成为更高级的人才？有没有评价好的程序员的标准
我问这个问题没有要求一定要回答道JVM的东西，否则面应届生我就完全不问了，虽然现在也问的比较少了@_@
考察一个人不是考试改卷，没有说一题非对既错，非会既不会。不了解JVM的东西也可以做很多工作，但是我要知道你是否了解，兴趣在哪里。有的应聘者适合招进来就拉去做事，有的应聘者适合用心培养。面试官问的问题都不是去刁难、打击，而是希望能看清楚潜力和兴趣。</p>
<p>smallboby 写道</p>
<p>在java的实际开发中针对垃圾回收到底要注意什么，垃圾回收都是自动化，到底还需要我们做哪些工作来针对垃圾回收呢，，不明白，望赐教。
自动化的东西容易靠不住呀，遇到泄漏，OOM，或者频繁GC对性能产生和大影响时，我们都要通过dump data、gc trace这些与内存、gc打交道。
学习了，虽然看过虚拟机的内容~~但回答的时候，可能也不会深入到新生代、老年代的层次。
最近看过的《分布式Java应用：基础与实践》里面对JVM也有详细的介绍。
对应届生，一般有问JAVA是如何管理内存之类的问题。</p>
<p>也不知道你们公司是干嘛的</p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/JVM/">JVM</a></li></span></span> | <span class="tags">Tagged <a href="/tags/JVM/" class="label label-primary">JVM</a><a href="/tags/Java&J2EE/" class="label label-success">Java&J2EE</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:42"datetime="2014-03-07 09:54:42"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-JVM--一个面试官对面试问题的分析JVM/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-JVM--一个面试官对面试问题的分析JVM" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>





<ul id="pagination" class="pagination pagination-lg">
  <li><a class="extend prev" href="/page/51/">&laquo;</a></li><li><a class="page-number" href="/">1</a></li><li><a class="page-number" href="/page/2/">2</a></li><li><span class="space">&hellip;</span></li><li><a class="page-number" href="/page/49/">49</a></li><li><a class="page-number" href="/page/50/">50</a></li><li><a class="page-number" href="/page/51/">51</a></li><li class="active"><li><span class="page-number current">52</span></li><li><a class="page-number" href="/page/53/">53</a></li><li><a class="page-number" href="/page/54/">54</a></li><li><a class="page-number" href="/page/55/">55</a></li><li><span class="space">&hellip;</span></li></li><li><a class="page-number" href="/page/161/">161</a></li><li><a class="page-number" href="/page/162/">162</a></li><li><a class="extend next" href="/page/53/">&raquo;</a></li>
  <div class="clearfix"></div>
</ul></div><!--wapper-->
       </div><!-- ID main-col END -->
       <aside id="sidebar" class="alignright col-sx-6 col-sm-4 col-md-3 col-lg-3">
<div id="widget_search" class="widget panel panel-primary">
    <form action="//google.com/search" method="get" accept-charset="utf-8">
  <div class="input-group">
    <input class="form-control" id="searchbox" type="search" name="q" results="0" placeholder="search">
    <span class="input-group-btn">
      <button class="btn btn-default" type="submit">Go!</button>
    </span>
    <input type="hidden" name="q" value="site:itsolife.com">
  </div>
</form>
</div>

<div id="widget_category" class="widget panel panel-primary">
  <div class="panel-heading">category</div>  <div data-src='category' class='ajax_widgets'>正在加载...</div>
</div>

<div id="widget_recent_posts" class="widget panel panel-primary">
  <div class="panel-heading">recent posts</div>  <div data-src='recent_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_tagcloud" class="widget panel panel-primary">
  <div class="panel-heading">tagcloud</div>  <div data-src='tagcloud' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_latest_update_posts" class="widget panel panel-primary">
  <div class="panel-heading">最近更新</div>  <div data-src='latest_update_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_recent_comments" class="widget panel panel-primary">
  <div class="panel-heading">recent comments</div>  

<div class="list-group-item ds-recent-comments" data-num-items="6" data-show-avatars="1" data-show-time="1" data-show-title="1" data-show-admin="1" data-excerpt-length="50"></div>



</div>

</aside>
       <div class="clearfix"></div>
     </div><!-- row END -->
  </div>
  <footer id="footer" class="container">
  <div class="panel panel-info">
  <section id='footer_widget'></section>  <div class="panel-footer">
  <div id="site-info">
    <span class='author'>
  
  &copy; 2014 RobinChia
  
    &nbsp;&nbsp;</span>
  
  <span id='analytics-51la'></span><span id='analytics-google'>
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-48559895-1']);
  _gaq.push(['_trackPageview']);
  _js2load.push({src:('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'});
</script></span><span id='analytics-cnzz'>
<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_5774006'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s17.cnzz.com/stat.php%3Fid%3D5774006%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>
</span><span id='analytics-baidu'>
<script>
var _hmt = _hmt || [];
_js2load.push({src:"//hm.baidu.com/hm.js?1442f50724afc42380b51f097c43082c"});
</script>
</span>  </div>
  <div id="copyright">Site powered by <a href='http://zespia.tw/hexo/'><strong>hexo</strong></a>  update time: <em>2014-04-07 19:25:39</em></span></div>
</div>
<div class="clearfix"></div>


  </div>
  </footer>
  
        <script src="http://cdn.bootcss.com/jquery/1.10.2/jquery.min.js"></script>        
        <script src="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/js/bootstrap.min.js"></script>        
                
        <script src="http://cdn.bootcss.com/prettify/r298/prettify.min.js"></script>    <script type="text/javascript">
   var lang=["bsh", "c", "cc", "cpp", "cs", "csh", "cyc", "cv", "htm", "html",
    "java", "js", "m", "mxml", "perl", "pl", "pm", "py", "rb", "sh",
    "xhtml", "xml", "xsl"];
   var pretty_base='';
   $('script').each(function(){
	var c = $(this).attr('src');
	if (!c)
	    return;
	if (c.match(/(\/)?prettify(\.min)?\.js/i))
	{
	    var index = c.lastIndexOf('/');
	    if (index != -1)
		pretty_base = c.substr(0,index + 1);
	    return false;
	}
   })
   $('pre code').each(function(){
	var c = $(this).attr('class')
	if (!c)
	    return;
	c = c.match(/\s?(lang\-\w+)/i);
	if (c && lang.indexOf(c[1]) == -1)
	{
	    lang.push(c[1]);
	    $.getScript(pretty_base + c[1] + '.min.js');
	}
   })

    $(window).load(function(){
       $("pre").addClass("prettyprint");
       prettyPrint();
    })
</script>    
            <script type="text/javascript">
var duoshuoQuery = {short_name:"robinchia"};
_js2load.push({src:'http://static.duoshuo.com/embed.js',charset:'UTF-8'});
</script>
    
            <!--wumii_relatedItems-->
    
        <script src="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js"></script>    <script type="text/javascript">
(function($){
  $('.entry').each(function(i){
    $(this).find('img').each(function(){
      var alt = this.alt;

      if (alt){
        $(this).before('<span class="caption">' + alt + '</span>');
      }

      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox" rel="fancybox' + i + '" />');
    });
  });

  $('.fancybox').fancybox();
})(jQuery);
</script>    
        <script src="http://cdn.bootcss.com/mathjax/2.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>    <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>
    
<script type="text/javascript">
$('.ajax_widgets').each(function(){var src=$(this).attr('data-src');if(src)$(this).load('/widgets/'+src+'.html');});
$.each(_js2load,function(index,obj){loadjs(obj.src,obj.charset)});
</script>

<div id="scroll2top">
<img src="/scroll2top/arrow.png"/>
</div>
<script src="/scroll2top/scroll2top.min.js"></script>
<div id="winterland">
  <canvas></canvas>
</div>
<script src="/js/winterland.min.js"></script>

  </body>
</html>
