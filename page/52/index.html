
<!DOCTYPE HTML>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>The 52 Page | It so life</title>
<meta name="author" content="RobinChia">

<meta name="description" content="It so life">


<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<meta property="og:site_name" content="It so life"/>

<!--[if IE]><style>.testIE.IE{display:inline;}</style><![endif]-->
<!--[if lte IE 7]><link rel="stylesheet" href="/css/ie7.css" type="text/css"><![endif]-->
<!--[if (lt IE 9)&(gt IE 7)]><style>.testIE.IE8{display:inline;}</style><![endif]-->
<!--[if gt IE 8]><style>.testIE.IE9{display:inline;}</style><![endif]-->

<link href="/favicon.png" rel="icon">
<link rel="alternate" href="/atom.xml" title="It so life Feed" type="application/atom+xml">

<link rel="stylesheet" href="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/css/bootstrap.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/font-awesome/4.0.3/css/font-awesome.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/prettify/r298/prettify.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" type="text/css">
<link rel="stylesheet" href="/css/style.css" type="text/css">
<!--[if lt IE 9]>
   <style>article,aside,dialog,footer,header,section,footer,nav,figure,menu{display:block}</style>
   <script src="http://cdn.staticfile.org/html5shiv/r29/html5.min.js"></script>
   <script src="http://cdn.staticfile.org/respond.js/1.4.2/respond.min.js"></script>
<link href="http://cdn.staticfile.org/respond.js/1.4.2/respond-proxy.html" id="respond-proxy" rel="respond-proxy" />
<link href="/js/respond.proxy.gif" id="respond-redirect" rel="respond-redirect" />
<script src="/js/respond.proxy.js"></script>
   <script src="http://cdn.bootcss.com/selectivizr/1.0.2/selectivizr-min.js"></script>
<![endif]-->
<script type="text/javascript">
function loadjs(c,d){var a=document.createElement("script");a.async=!0;a.type="text/javascript";a.src=c;a.charset=d||"gbk";(document.getElementsByTagName("HEAD")[0]||document.getElementsByTagName("BODY")[0]).appendChild(a)};
var _protocol = (("https:" == document.location.protocol) ? " https://" : " http://");
var _js2load = [];
</script>

</head>
<body>
      <header id="header" class="container"><nav id="main-nav" class="navbar navbar-default navbar-fixed-top " role="navigation">
  <div class="container">
    <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
      <span class="sr-only">Toggle navigation</span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="/">It so life</a>
    </div>
    <div  class="collapse navbar-collapse">
      <ul  class="nav navbar-nav">
  
        <li><a href="/" title="Home">Home</a></li>      
        <li><a href="/about/" title="About">About</a></li>      
        <li><a href="/archives/" title="Archives">Archives</a></li>      
      <li class='dropdown'>
        <a class='dropdown-toggle' data-toggle='dropdown' href='#'>website<b class='caret'></b></a>
        <ul class='dropdown-menu pure-menu-selected'>
    
          <li><a href="//groups.google.com/forum/#!forum/pongba" title="TopLanguage">TopLanguage</a></li>    
          <li><a href="//itpub.net/" title="ITPub">ITPub</a></li>    
          <li><a href="//blog.jobbole.com/" title="Bole">Bole</a></li>    
          <li><a href="//nosql-database.org/" title="nosql">nosql</a></li>    
          <li><a href="//gitimmersion.googol.im/" title="Git">Git</a></li>    
        </ul>
      </li>
    
      </ul>
      <ul class="nav navbar-nav navbar-right">
      
        <li><a href="/atom.xml">RSS</a></li>
      
      
        <li><a href="https://twitter.com/robinchia">twitter</a></li>
      
      
      
      
        <li><a href="https://github.com/robinchia">github</a></li>
      
      </ul>
    </div>
  </div>
</nav>
<div class="clearfix"></div>
</header>
  <div id='content' class="container">
     <div class="page-header-wrapper">
      <!--[if lt IE 9]><div class="alert alert-warning alert-dismissable"><button type="button" class="close" data-dismiss="alert" aria-hidden="true">&times;</button><strong>提示:</strong>您的浏览器版本太低了,建议升级到 <strong><a href="http://windows.microsoft.com/zh-cn/internet-explorer/download-ie" title="IE9">IE9</a></strong> 以上,本站使用<a href="https://www.google.com/intl/zh-CN/chrome/">Chrome浏览器</a>可以获得最好的显示效果.</div><![endif]-->
      <div class="page-header"><h1 align="center"><big>It so life</big> </h1>
        <h5 align="center"><big>love as life</big></h5>
      </div>
     </div>
     <div class="row">
       <div id="main-col" class="alignleft col-sx-12 col-sm-8 col-md-9 col-lg-9">
      <section id='header_widget'></section>
          <div id="wrapper"><article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--两个OOMCases排查过程的分享/">两个OOM Cases排查过程的分享</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:42.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--两个OOMCases排查过程的分享/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-oom-cases-">两个OOM Cases排查过程的分享</h1>
<h1 id="-bluedavy-blog-https-blog-bluedavy-com-"><a href="https://blog.bluedavy.com/" target="_blank">BlueDavy之技术blog</a></h1>
<p>{互联网，OSGi，Java, High Scalability, High Performance,HA}</p>
<ul>
<li><a href="https://blog.bluedavy.com/" target="_blank">Home</a></li>
<li><a href="https://blog.bluedavy.com/?page_id=2" target="_blank">About</a></li>
<li><a href="https://blog.bluedavy.com/?page_id=81" target="_blank">Photos</a></li>
</ul>
<h2 id="-oom-cases-https-blog-bluedavy-com-p-205-oom-cases-"><a href="https://blog.bluedavy.com/?p=205" title="两个OOM Cases排查过程的分享" target="_blank">两个OOM Cases排查过程的分享</a></h2>
<p>Jan 13</p>
<p><a href="http://bluedavy.com/" title="Visit bluedavy’s website" target="_blank">bluedavy</a><a href="https://blog.bluedavy.com/?cat=13" title="View all posts in jvm" target="_blank">jvm</a> <a href="&quot;Comment on 两个OOM Cases排查过程的分享&quot;">5 Comments</a>
分享一下两个OOM Cases的查找过程，一个应用是Native OOM；另外一个应用其实没有OOM，只是每隔一段时间就会出现频繁FGC的现象，OOM的查找已经具备了不错的工具，但有些时候还是会出现很难查的现象，希望这两个排查过程的分享能给需要的同学带来一些帮助。</p>
<p><strong>Native OOM的排查Case</strong>
之前的几个PPT里我都说到了，目前查找Native OOM最好的方法就是用google perftools了，于是挂上google perftools，等待应用再次native oom，很幸运，两天后，应用就再次native oom了，于是分析crash之前那段时间谁在不断的分配堆外的内存，pprof看到的结果主要是java.util.Inflater造成的，由于之前已经碰到过类似的case，知道如果使用了Inflater，但不显式的调用Inflater.end的话，确实会造成这个现象。
于是剩下的问题就是找出代码里什么地方调用了Inflater，这种时候btrace这个神器就可以发挥作用了，一个简单的btrace脚本：
<a href="">?</a>1</p>
<p>2
3</p>
<p>4
5</p>
<p>6
7</p>
<p>8
9</p>
<p>10
11</p>
<p>12
13import</p>
<p>static</p>
<p>com.sun.btrace.BTraceUtils./*;</p>
<p>import</p>
<p>com.sun.btrace.annotations./*;</p>
<p>@BTrace</p>
<p>public</p>
<p>class</p>
<p>Trace{</p>
<p>@OnMethod</p>
<p>(</p>
<p>clazz=</p>
<p>&quot;java.util.zip.Inflater&quot;</p>
<p>,</p>
<p>method=</p>
<p>&quot;/./*/&quot;</p>
<p>)</p>
<p>public</p>
<p>static</p>
<p>void</p>
<p>traceExecute(</p>
<p>@ProbeMethodName</p>
<p>String methodName){</p>
<p>println(concat(</p>
<p>&quot;who call Inflater.&quot;</p>
<p>,methodName));</p>
<p>jstack();</p>
<p>}
}</p>
<p>执行后很快就找到了代码什么地方调用了Inflater，于是加上了显式的调用Inflater.end，搞定收工。</p>
<p><strong>偶尔频繁FGC的排查Case</strong>
这个Case就没上面的那个那么顺利了，查了有接近一个月才查出最终的原因。
当这个应用出现频繁FGC时，dump了内存，用MAT分析后，看到内存被消耗完的原因是由于几个线程内的ThreadLocalMap中有大量的数据，ThreadLocal中消耗最多内存的主要是一个HashMap，这里面有大量的数据。
于是当时想到的第一个方法就是查查应用里面什么地方往ThreadLocal里放了HashMap，杯具的是，当查找代码后发现应用本身的代码并没有往ThreadLocal里放HashMap，那就只能是应用依赖的其他jar包做了这样的事了，但不可能去抓出这个应用依赖的所有的jar的源码来扫描，于是继续借助BTrace，写了个脚本来跟踪这类型的线程中谁调用了ThreadLocal.set，并且放的是HashMap，btrace脚本如下：
<a href="">?</a>1</p>
<p>2
3</p>
<p>4
5</p>
<p>6
7</p>
<p>8
9</p>
<p>10
11</p>
<p>12
13</p>
<p>14
15</p>
<p>16
import</p>
<p>static</p>
<p>com.sun.btrace.BTraceUtils./*;</p>
<p>import</p>
<p>com.sun.btrace.annotations./*;</p>
<p>@BTrace</p>
<p>public</p>
<p>class</p>
<p>Trace{</p>
<p>@OnMethod</p>
<p>(</p>
<p>clazz=</p>
<p>&quot;java.lang.ThreadLocal&quot;</p>
<p>,</p>
<p>method=</p>
<p>&quot;set&quot;</p>
<p>)</p>
<p>public</p>
<p>static</p>
<p>void</p>
<p>traceExecute(Object value){</p>
<p>if</p>
<p>(startsWith(name(currentThread()),</p>
<p>&quot;xxx&quot;</p>
<p>) &amp;&amp; startsWith(</p>
<p>&quot;java.util.HashMap&quot;</p>
<p>,name(classOf(value))) ){</p>
<p>println(</p>
<p>&quot;-------------------------&quot;</p>
<p>);</p>
<p>jstack();</p>
<p>println();</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>OK，开始运行上面的脚本，发现竟然一直都没打印出什么内容，只能一直等了，杯具的是一直到了一周后再次出现频繁FGC时，这个脚本都没输出任何的东西，于是只好转换思路。</p>
<p>既然是HashMap里put了大量的某种类型的数据，那干脆用btrace来看看是谁在往HashMap里put这些数据，于是又写了一个btrace脚本，执行后，很快就看到了是代码中什么地方在put这些数据，但是从抓到的调用者来看，不仅仅是目前有大量数据的这类型的线程会调，其他类型的线程也会调用，如果这个地方有问题的话，应该就全部有问题了，于是跳过这里。</p>
<p>回到MAT看到的现象，会不会是因为代码什么地方用ThreadLocal的方式不对，又或是什么地方往ThreadLocal里放了东西，又忘了清除呢，因此要做的就是找出这个应用中所有属性为ThreadLocal的地方，来人肉分析了，于是写了一个jsp，扫描所有的classloader中的所有class，找出属性类型为ThreadLocal的，扫描后找到了一些，还真发现有一个和现在HashMap中放的数据一样的private ThreadLocal，这种用法在线程复用的情况下，如果是每次new ThreadLocal的话，会导致ThreadLocal放的东西一直不释放，兴奋的以为已经发现原因了，可惜和业务方一确认，这个类借助Spring保证了singleton的，因此不会有问题。
好吧，到这一步，只能猜想是由于某种参数请求的时候造成业务上会获得大量的数据了，于是想着要找业务方来分析代码了，这个非常麻烦，于是到此就几乎停滞不前了。</p>
<p>今天静下心来，重新仔细的看了下MAT分析的结果，决定仍然用btrace跟踪下之前往HashMap中put数据的那个业务代码，突然发现，在web类型的处理线程中它借助的是filter去clear数据的，而杯具的是出问题的这种类型线程的处理机制是没有filter机制的，因此猜测问题估计出在这里了，继续btrace，看看这种类型的线程中是不是只有人调put，没人调clear，btrace脚本运行，很快就验证了这个猜测，于是相应的解决掉了这个case，搞定收工。</p>
<p>在这第二个case中，可见在频繁FGC或者OOM时，很有可能MAT只能告诉你初步的原因，但要对应到代码上到底是什么地方造成的，还得花很大精力分析了，这个时候BTrace通常能帮上很大的忙。</p>
<p><a href="https://blog.bluedavy.com/?p=200" target="_blank">Sun JDK 1.6内存管理</a> <a href="https://blog.bluedavy.com/?p=210" target="_blank">服务框架演变过程</a></p>
<h3 id="5-comments-add-yours-">5 Comments <em>(<a href="">+add yours?</a>)</em></h3>
<ol>
<li><img src="https://secure.gravatar.com/avatar/8a0a3550a77608414631e27fbda32c48?s=48&amp;d=&lt;path_to_url&gt;&amp;r=G" alt=""> Jimmy
<strong>Jan 18, 2011</strong> @ 15:40:15
google perftools这个怎么用呢？能不能讲讲？</li>
<li><img src="https://secure.gravatar.com/avatar/5267242305332fe1affd9c4788191e1d?s=48&amp;d=&lt;path_to_url&gt;&amp;r=G" alt=""> <a href="http://bluedavy.com/" target="_blank">bluedavy</a>
<strong>Jan 18, 2011</strong> @ 21:04:09
perftools装上后，只用设置上export LD_PRELOAD=[libtcmalloc所在的目录]/libtcmalloc.so，然后env HEAPPROFILE=dump的内存信息的文件名 java …，启动后就会每隔一段时间自动生成一些dump文件，最后通过perftools里面的pprof对dump文件进行分析就可以看到结果了。</li>
<li><img src="https://secure.gravatar.com/avatar/ee65a80dc2effc685329d0630603a118?s=48&amp;d=&lt;path_to_url&gt;&amp;r=G" alt=""> <a href="http://www.sandzhang.com/" target="_blank">sand</a>
<strong>May 21, 2011</strong> @ 23:05:26
要是能有人多分享一下这种实际案例就好了<h3 id="leave-a-reply">Leave a Reply</h3>
</li>
</ol>
<p><a href="">Cancel</a></p>
<p>Name (required)</p>
<p>Mail (required)</p>
<p>Website</p>
<p><img src="&quot;CAPTCHA Image&quot;" alt="CAPTCHA Image"></p>
<p><a href="&quot;Refresh Image&quot;"><img src="" alt="Refresh Image"></a></p>
<p>CAPTCHA Code /*</p>
<p><style type='text/css'>/#submit {display:none;}</style><br /> <input name="submit" type="submit" id="submit-alt" tabindex="6" value="Submit Comment" /></p>
<p>July 2013 M T W T F S S <a href="https://blog.bluedavy.com/?m=201303" title="View posts for March 2013" target="_blank">« Mar</a>     1234567 891011121314 15161718192021 22232425262728 293031  </p>
<h3 id="categories">Categories</h3>
<ul>
<li><a href="https://blog.bluedavy.com/?cat=63" title="View all posts filed under Java" target="_blank">Java</a> (10)</li>
<li><a href="https://blog.bluedavy.com/?cat=13" title="View all posts filed under jvm" target="_blank">jvm</a> (19)</li>
<li><a href="https://blog.bluedavy.com/?cat=56" title="View all posts filed under NoSQL" target="_blank">NoSQL</a> (7)</li>
<li><a href="https://blog.bluedavy.com/?cat=4" title="View all posts filed under SOA" target="_blank">SOA</a> (1)</li>
<li><a href="https://blog.bluedavy.com/?cat=11" title="关于《分布式Java应用：基础与实践》书部分章节的公开、书内容的纠错以及补充完善。" target="_blank">书:分布式Java应用</a> (5)</li>
<li><a href="https://blog.bluedavy.com/?cat=6" title="View all posts filed under 互联网" target="_blank">互联网</a> (5)</li>
<li><a href="https://blog.bluedavy.com/?cat=46" title="View all posts filed under 产品总结" target="_blank">产品总结</a> (1)</li>
<li><a href="https://blog.bluedavy.com/?cat=18" title="View all posts filed under 优化案例" target="_blank">优化案例</a> (1)</li>
<li><a href="https://blog.bluedavy.com/?cat=12" title="View all posts filed under 圆桌交流" target="_blank">圆桌交流</a> (2)</li>
<li><a href="https://blog.bluedavy.com/?cat=8" title="View all posts filed under 容量规划" target="_blank">容量规划</a> (2)</li>
<li><a href="https://blog.bluedavy.com/?cat=97" title="View all posts filed under 迁户口" target="_blank">迁户口</a> (1)</li>
<li><a href="https://blog.bluedavy.com/?cat=52" title="View all posts filed under 高可用" target="_blank">高可用</a> (1)</li>
<li><a href="https://blog.bluedavy.com/?cat=3" title="View all posts filed under 高并发" target="_blank">高并发</a> (3)</li>
<li><p><a href="https://blog.bluedavy.com/?cat=1" title="关于性能优化方面的一些东西。" target="_blank">高性能</a> (2)</p>
<h3 id="recent-comments">Recent Comments</h3>
</li>
<li><p><a href="http://code1.riaos.com/?p=5030138" target="_blank">JVM调优 | code1（code1.riaos.com）</a> on <a href="https://blog.bluedavy.com/?p=70&amp;cpage=1#comment-16520" target="_blank">说说MaxTenuringThreshold这个参数</a></p>
</li>
<li><a href="http://architecture1.riaos.com/?p=3063358" target="_blank">JVM调优 | architecture（riaos.com）</a> on <a href="https://blog.bluedavy.com/?p=70&amp;cpage=1#comment-16519" target="_blank">说说MaxTenuringThreshold这个参数</a></li>
<li><a href="http://bluedavy.com/" target="_blank">bluedavy</a> on <a href="https://blog.bluedavy.com/?p=409&amp;cpage=1#comment-16462" target="_blank">一个Java应用频繁抛异常导致cpu us诡异现象的案例</a></li>
<li>xiaobo on <a href="https://blog.bluedavy.com/?p=409&amp;cpage=1#comment-16460" target="_blank">一个Java应用频繁抛异常导致cpu us诡异现象的案例</a></li>
<li><a href="http://bluedavy.com/" target="_blank">bluedavy</a> on <a href="https://blog.bluedavy.com/?p=409&amp;cpage=1#comment-16459" target="_blank">一个Java应用频繁抛异常导致cpu us诡异现象的案例</a></li>
</ul>
<h3 id="tags">Tags</h3>
<p><a href="https://blog.bluedavy.com/?tag=btrace" title="2 topics" target="_blank">btrace</a> <a href="https://blog.bluedavy.com/?tag=c1" title="1 topic" target="_blank">c1</a> <a href="https://blog.bluedavy.com/?tag=c2" title="1 topic" target="_blank">c2</a> <a href="https://blog.bluedavy.com/?tag=deflater" title="1 topic" target="_blank">Deflater</a> <a href="https://blog.bluedavy.com/?tag=facebook" title="2 topics" target="_blank">facebook</a> <a href="https://blog.bluedavy.com/?tag=gc" title="4 topics" target="_blank">gc</a> <a href="https://blog.bluedavy.com/?tag=gc-tuning" title="2 topics" target="_blank">gc tuning</a> <a href="https://blog.bluedavy.com/?tag=grizzly" title="2 topics" target="_blank">Grizzly</a> <a href="https://blog.bluedavy.com/?tag=hbase" title="6 topics" target="_blank">HBase</a> <a href="https://blog.bluedavy.com/?tag=hotspot" title="1 topic" target="_blank">hotspot</a> <a href="https://blog.bluedavy.com/?tag=inflater" title="1 topic" target="_blank">Inflater</a> <a href="https://blog.bluedavy.com/?tag=interpreter" title="1 topic" target="_blank">interpreter</a> <a href="https://blog.bluedavy.com/?tag=javac" title="1 topic" target="_blank">javac</a> <a href="https://blog.bluedavy.com/?tag=java-code-generation" title="1 topic" target="_blank">java code generation</a> <a href="https://blog.bluedavy.com/?tag=javaone" title="4 topics" target="_blank">JavaOne</a> <a href="https://blog.bluedavy.com/?tag=javaone-general-technical-session" title="1 topic" target="_blank">javaone general technical session</a> <a href="https://blog.bluedavy.com/?tag=java%e4%bb%a3%e7%a0%81%e6%89%a7%e8%a1%8c" title="1 topic" target="_blank">java代码执行</a> <a href="https://blog.bluedavy.com/?tag=java-%e5%b9%b6%e5%8f%91" title="1 topic" target="_blank">Java 并发</a> <a href="https://blog.bluedavy.com/?tag=jit" title="1 topic" target="_blank">jit</a> <a href="https://blog.bluedavy.com/?tag=jvm" title="12 topics" target="_blank">jvm</a> <a href="https://blog.bluedavy.com/?tag=memory-management" title="1 topic" target="_blank">memory management</a> <a href="https://blog.bluedavy.com/?tag=native-memory-leak" title="1 topic" target="_blank">Native Memory Leak</a> <a href="https://blog.bluedavy.com/?tag=nosql" title="2 topics" target="_blank">NoSQL</a> <a href="https://blog.bluedavy.com/?tag=oom" title="1 topic" target="_blank">oom</a> <a href="https://blog.bluedavy.com/?tag=oracle-keynote" title="1 topic" target="_blank">oracle keynote</a> <a href="https://blog.bluedavy.com/?tag=pessimism-policy" title="1 topic" target="_blank">pessimism policy</a> <a href="https://blog.bluedavy.com/?tag=references" title="1 topic" target="_blank">references</a> <a href="https://blog.bluedavy.com/?tag=rpc" title="2 topics" target="_blank">RPC</a> <a href="https://blog.bluedavy.com/?tag=serial-gc" title="1 topic" target="_blank">serial gc</a> <a href="https://blog.bluedavy.com/?tag=soa" title="2 topics" target="_blank">SOA</a> <a href="https://blog.bluedavy.com/?tag=sun-jdk" title="1 topic" target="_blank">sun jdk</a> <a href="https://blog.bluedavy.com/?tag=sun-jdk-oom" title="1 topic" target="_blank">sun jdk oom</a> <a href="https://blog.bluedavy.com/?tag=web%e5%ae%b9%e9%87%8f%e8%a7%84%e5%88%92%e7%9a%84%e8%89%ba%e6%9c%af" title="1 topic" target="_blank">Web容量规划的艺术</a> <a href="https://blog.bluedavy.com/?tag=yuanzhuo" title="1 topic" target="_blank">yuanzhuo</a> <a href="https://blog.bluedavy.com/?tag=%e4%b9%a6" title="1 topic" target="_blank">书:分布式Java应用</a> <a href="https://blog.bluedavy.com/?tag=%e4%b9%a6%e8%af%84" title="1 topic" target="_blank">书评</a> <a href="https://blog.bluedavy.com/?tag=%e4%ba%92%e8%81%94%e7%bd%91%e6%8a%80%e6%9c%af" title="1 topic" target="_blank">互联网技术</a> <a href="https://blog.bluedavy.com/?tag=%e4%ba%a4%e6%b5%81" title="1 topic" target="_blank">交流</a> <a href="https://blog.bluedavy.com/?tag=%e5%86%85%e5%ad%98%e7%ae%a1%e7%90%86" title="1 topic" target="_blank">内存管理</a> <a href="https://blog.bluedavy.com/?tag=%e5%88%86%e5%b8%83%e5%bc%8fjava%e5%ba%94%e7%94%a8" title="2 topics" target="_blank">分布式Java应用</a> <a href="https://blog.bluedavy.com/?tag=%e5%9c%86%e6%a1%8c%e4%ba%a4%e6%b5%81" title="1 topic" target="_blank">圆桌交流</a> <a href="https://blog.bluedavy.com/?tag=%e5%ae%b9%e9%87%8f%e8%a7%84%e5%88%92" title="2 topics" target="_blank">容量规划</a> <a href="https://blog.bluedavy.com/?tag=%e6%82%b2%e8%a7%82%e7%ad%96%e7%95%a5" title="3 topics" target="_blank">悲观策略</a> <a href="https://blog.bluedavy.com/?tag=%e6%9c%8d%e5%8a%a1%e6%a1%86%e6%9e%b6" title="1 topic" target="_blank">服务框架</a> <a href="https://blog.bluedavy.com/?tag=%e7%a1%85%e8%b0%b7%e5%85%ac%e5%8f%b8" title="1 topic" target="_blank">硅谷公司</a></p>
<h3 id="-">订阅</h3>
<h3 id="-">推荐书籍</h3>
<h3 id="my-book">My Book</h3>
<p><a href="http://book.douban.com/subject/4848587/" title="分布式Java应用：基础与实践" target="_blank"><img src="" alt=""></a> <a href="http://book.douban.com/subject/3843896/" title="OSGi原理与最佳实践" target="_blank"><img src="" alt=""></a>
© <a href="https://blog.bluedavy.com/" target="_blank">BlueDavy之技术blog</a> 2013</p>
<p><a href="http://icondock.com/" target="_blank">Icons</a> &amp; <a href="http://www.ndesign-studio.com/wp-themes" target="_blank">Wordpress Theme</a> by <a href="http://www.ndesign-studio.com/" target="_blank">N.Design</a></p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/JVM/">JVM</a></li></span></span> | <span class="tags">Tagged <a href="/tags/JVM/" class="label label-primary">JVM</a><a href="/tags/Java&J2EE/" class="label label-success">Java&J2EE</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:42"datetime="2014-03-07 09:54:42"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-JVM--两个OOMCases排查过程的分享/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-JVM--两个OOMCases排查过程的分享" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--借HSDB来探索HotSpotVM的运行时数据/">借HSDB来探索HotSpot VM的运行时数据</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:42.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--借HSDB来探索HotSpotVM的运行时数据/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-hsdb-hotspot-vm-">借HSDB来探索HotSpot VM的运行时数据</h1>
<p>（未经许可请勿转载。希望转载请与我联系。）
（如果打开此页面时浏览器有点卡住的话请耐心等待片刻。大概是ItEye的代码高亮太耗时了…）
几天前在<a href="http://hllvm.group.iteye.com/" target="_blank">HLLVM群组</a>有人<a href="http://hllvm.group.iteye.com/group/topic/37542" target="_blank">问了个小问题</a>，说
Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>public class Test {  </li>
<li>static Test2 t1 = new Test2();  </li>
<li>Test2 t2 = new Test2();  </li>
<li>public void fn() {  </li>
<li>Test2 t3 = new Test2();       </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>class Test2 {  </li>
<li></li>
<li>}  </li>
</ol>
<p>public class Test {</p>
<pre><code>static Test2 t1 = new Test2();
       Test2 t2 = new Test2();

public void fn() {
    Test2 t3 = new Test2();    

}
</code></pre><p>}</p>
<p>class Test2 {</p>
<p>}
这个程序的t1、t2、t3三个变量本身（而不是这三个变量所指向的对象）到底在哪里。
TL;DR版回答是：</p>
<ul>
<li>t1在存Java静态变量的地方，概念上在JVM的方法区（method area）里</li>
<li>t2在Java堆里，作为Test的一个实例的字段存在</li>
<li>t3在Java线程的调用栈里，作为Test.fn()的一个局部变量存在
不过就这么简单的回答大家都会，满足不了对JVM的实现感兴趣的同学们的好奇心。说到底，这“方法区”到底是啥？Java堆在哪里？Java线程的调用栈又是啥样的？
那就让我们跑点例子，借助调试器来看看在一个实际运行中的JVM里是啥状况。<h1 id="-https-gist-github-com-rednaxelafx-5392451-https-gist-github-com-rednaxelafx-5392451-">（下文中代码也传了一份到<a href="https://gist.github.com/rednaxelafx/5392451" target="_blank"><a href="https://gist.github.com/rednaxelafx/5392451">https://gist.github.com/rednaxelafx/5392451</a></a>）</h1>
写个启动类来跑上面问题中的代码：
Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></li>
</ul>
<ol>
<li>public class Main {  </li>
<li>public static void main(String[] args) {  </li>
<li>Test test = new Test();  </li>
<li>test.fn();  </li>
<li>}  </li>
<li>}  </li>
</ol>
<p>public class Main {</p>
<pre><code>public static void main(String[] args) {
    Test test = new Test();

    test.fn();
}
</code></pre><p>}
（编译这个Main.java和上面的Test.java时最好加上-g参数生成LocalVariableTable等调试信息，以便后面某些情况下可以用到）
接下来如无特别说明本文将使用Windows 7 64-bit, Oracle JDK 1.7.0_09 Server VM, Serial GC的环境中运行所有例子。
之前在GreenTeaJUG在杭州的活动<a href="http://rednaxelafx.iteye.com/blog/1814180" target="_blank">演示Serviceability Agent</a>的时候也讲到过这是个非常便于探索HotSpot VM内部实现的API，而HSDB则是在SA基础上包装起来的一个调试器。这次我们就用HSDB来做实验。
SA的一个限制是它只实现了调试snapshot的功能：要么要让被调试的目标进程完全暂停，要么就调试core dump。所以我们在用HSDB做实验前，得先让我们的Java程序运行到我们关注的点上才行。
理想情况下我们会希望让这Java程序停在Test.java的第6行，也就是Test.fn()中t3局部变量已经进入作用域，而该方法又尚未返回的地方。怎样才能停在这里呢？
其实用个Java层的调试器即可。大家平时可能习惯了在Eclipse、IntelliJ IDEA、NetBeans等Java IDE里使用Java层调试器，但为了减少对外部工具的依赖，本文将使用Oracle JDK自带的jdb工具来完成此任务。
<a href="http://docs.oracle.com/javase/7/docs/technotes/tools/windows/jdb.html" target="_blank">jdb</a>跟上面列举的IDE里包含的调试器底下依赖着同一套调试API，也就是<a href="http://docs.oracle.com/javase/7/docs/technotes/guides/jpda/index.html" target="_blank">Java Platform Debugger Architecture (JPDA)</a>。功能也类似，只是界面是命令行的，表明上看起来不太一样而已。
为了方便后续步骤，启动jdb的时候可以设定让目标Java程序使用serial GC和10MB的Java heap。
启动jdb之后可以用stop in命令在指定的Java方法入口处设置断点，
然后用run命令指定主类名称来启动Java程序，
等跑到断点看看位置是否已经到满足需求，还没到的话可以用step、next之类的命令来向前进。
对jdb命令不熟悉的同学可以在启动jdb之后使用help命令来查看命令列表和说明。
具体步骤如下：
Command prompt代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>D:\test&gt;jdb -XX:+UseSerialGC -Xmx10m  </li>
<li>Initializing jdb ...  </li>
<li><blockquote>
<p>stop in Test.fn  </p>
</blockquote>
</li>
<li>Deferring breakpoint Test.fn.  </li>
<li>It will be set after the class is loaded.  </li>
<li><blockquote>
<p>run Main  </p>
</blockquote>
</li>
<li>run  Main  </li>
<li>Set uncaught java.lang.Throwable  </li>
<li>Set deferred uncaught java.lang.Throwable  </li>
<li><blockquote>
</blockquote>
</li>
<li>VM Started: Set deferred breakpoint Test.fn  </li>
<li></li>
<li>Breakpoint hit: &quot;thread=main&quot;, Test.fn(), line=5 bci=0  </li>
<li>5            Test2 t3 = new Test2();  </li>
<li></li>
<li>main[1] next  </li>
<li></li>
<li>Step completed: &gt; &quot;thread=main&quot;, Test.fn(), line=6 bci=8  </li>
<li>6        }  </li>
<li></li>
<li>main[1]   </li>
</ol>
<p>D:\test&gt;jdb -XX:+UseSerialGC -Xmx10m</p>
<p>Initializing jdb ...</p>
<blockquote>
<p>stop in Test.fn</p>
</blockquote>
<p>Deferring breakpoint Test.fn.
It will be set after the class is loaded.</p>
<blockquote>
<p>run Main
run  Main</p>
</blockquote>
<p>Set uncaught java.lang.Throwable
Set deferred uncaught java.lang.Throwable</p>
<p>&gt;
VM Started: Set deferred breakpoint Test.fn</p>
<p>Breakpoint hit: &quot;thread=main&quot;, Test.fn(), line=5 bci=0</p>
<p>5            Test2 t3 = new Test2();</p>
<p>main[1] next</p>
<p>Step completed: &gt; &quot;thread=main&quot;, Test.fn(), line=6 bci=8
6        }</p>
<p>main[1]
按照上述步骤执行完最后一个next命令之后，我们就来到了最初想要的Test.java的第6行，也就是Test.fn()返回前的位置。
接下来把这个jdb窗口放一边，另开一个命令行窗口用<a href="http://docs.oracle.com/javase/7/docs/technotes/tools/share/jps.html" target="_blank">jps</a>命令看看我们要调试的Java进程的pid是多少：
Command prompt代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>D:\test&gt;jps  </li>
<li>4328 Main  </li>
<li>9064 Jps  </li>
<li>7716 TTY  </li>
</ol>
<p>D:\test&gt;jps</p>
<p>4328 Main
9064 Jps</p>
<p>7716 TTY
可以看到是4328。把这个pid记下来待会儿用。
然后启动HSDB：
Command prompt代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>D:\test&gt;java -cp .;%JAVA_HOME%/lib/sa-jdi.jar sun.jvm.hotspot.HSDB  </li>
</ol>
<p>D:\test&gt;java -cp .;%JAVA_HOME%/lib/sa-jdi.jar sun.jvm.hotspot.HSDB
（要留意Linux和Solaris在Oracle/Sun JDK6就可以使用HSDB了，但Windows上要到Oracle JDK7才可以用HSDB）
启动HSDB之后，把它连接到目标进程上。从菜单里选择File -&gt; Attach to HotSpot process：
<img src="&quot;点击查看原始大小图片&quot;" alt="">
在弹出的对话框里输入刚才记下的pid然后按OK：
<img src="&quot;点击查看原始大小图片&quot;" alt="">
这会儿就连接到目标进程了：
<img src="&quot;点击查看原始大小图片&quot;" alt="">
刚开始打开的窗口是Java Threads，里面有个线程列表。双击代表线程的行会打开一个Oop Inspector窗口显示HotSpot VM里记录线程的一些基本信息的C++对象的内容。
不过这里我们更可能会关心的是线程栈的内存数据。先选择main线程，然后点击Java Threads窗口里的工具栏按钮从左数第2个可以打开Stack Memory窗口来显示main线程的栈：
<img src="&quot;点击查看原始大小图片&quot;" alt="">
Stack Memory窗口的内容有三栏：
左起第1栏是内存地址，请让我提醒一下本文里提到“内存地址”的地方都是指虚拟内存意义上的地址，<strong>不是</strong>“物理内存地址”，请不要弄混了这俩概念；
第2栏是该地址上存的数据，以字宽为单位，本文例子中我是在Windows 7 64-bit上跑64位的JDK7的HotSpot VM，字宽是64位（8字节）；
第3栏是对数据的注释，竖线表示范围，横线或斜线连接范围与注释文字。
现在看不懂这个窗口里的数据没关系，先放一边，后面再回过头来看。
现在让我们打开HSDB里的控制台，以便用命令来了解更多信息。
在菜单里选择Windows -&gt; Console：
<img src="" alt="">
然后会得到一个空白的Command Line窗口。在里面敲一下回车就会出现hsdb&gt;提示符。
（用过CLHSDB的同学可能会发现这就是把CLHSDB嵌入在了HSDB的图形界面里）
不知道有什么命令可用的同学可以先用help命令看看命令列表。
可以用universe命令来查看GC堆的地址范围和使用情况：
Hsdb代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>hsdb&gt; universe  </li>
<li>Heap Parameters:  </li>
<li>Gen 0:   eden [0x00000000fa400000,0x00000000fa4aad68,0x00000000fa6b0000) space capacity = 2818048, 24.831088753633722 used  </li>
<li>from [0x00000000fa6b0000,0x00000000fa6b0000,0x00000000fa700000) space capacity = 327680, 0.0 used  </li>
<li>to   [0x00000000fa700000,0x00000000fa700000,0x00000000fa750000) space capacity = 327680, 0.0 usedInvocations: 0  </li>
<li></li>
<li>Gen 1:   old  [0x00000000fa750000,0x00000000fa750000,0x00000000fae00000) space capacity = 7012352, 0.0 usedInvocations: 0  </li>
<li></li>
<li>perm [0x00000000fae00000,0x00000000fb078898,0x00000000fc2c0000) space capacity = 21757952, 11.90770160721009 usedInvocations: 0  </li>
</ol>
<p>hsdb&gt; universe</p>
<p>Heap Parameters:
Gen 0:   eden [0x00000000fa400000,0x00000000fa4aad68,0x00000000fa6b0000) space capacity = 2818048, 24.831088753633722 used</p>
<p>  from [0x00000000fa6b0000,0x00000000fa6b0000,0x00000000fa700000) space capacity = 327680, 0.0 used
  to   [0x00000000fa700000,0x00000000fa700000,0x00000000fa750000) space capacity = 327680, 0.0 usedInvocations: 0</p>
<p>Gen 1:   old  [0x00000000fa750000,0x00000000fa750000,0x00000000fae00000) space capacity = 7012352, 0.0 usedInvocations: 0</p>
<p>  perm <a href="&quot;复制代码&quot;">0x00000000fae00000,0x00000000fb078898,0x00000000fc2c0000) space capacity = 21757952, 11.90770160721009 usedInvocations: 0
这里用的是HotSpot VM的serial GC。GC堆由young gen = DefNewGeneration（包括eden和两个survivor space）、old gen = TenuredGeneration和perm gen = PermGen构成。
其中young gen和old gen构成了这种配置下HotSpot VM里的Java堆（Java heap），而perm gen不属于Java heap的一部分，它存储的主要是元数据或者叫反射信息，主要用于实现JVM规范里的“方法区”概念。
在我们的Java代码里，执行到Test.fn()末尾为止应该创建了3个Test2的实例。它们必然在GC堆里，但都在哪里呢？用scanoops命令来看：
Hsdb代码 [<img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>hsdb&gt; scanoops 0x00000000fa400000 0x00000000fc2c0000 Test2  </li>
<li>0x00000000fa49a710 Test2  </li>
<li>0x00000000fa49a730 Test2  </li>
<li>0x00000000fa49a740 Test2  </li>
</ol>
<p>hsdb&gt; scanoops 0x00000000fa400000 0x00000000fc2c0000 Test2</p>
<p>0x00000000fa49a710 Test2
0x00000000fa49a730 Test2</p>
<p>0x00000000fa49a740 Test2
scanoops接受两个必选参数和一个可选参数：必选参数是要扫描的地址范围，一个是起始地址一个是结束地址；可选参数用于指定要扫描什么类型的对象实例。实际扫描的时候会扫出指定的类型及其派生类的实例。
这里可以看到确实扫出了3个Test2的实例。内容有两列：左边是对象的起始地址，右边是对象的实际类型。
从它们所在的地址，对照前面universe命令看到的GC堆的地址范围，可以知道它们都在eden里。
通过whatis命令可以进一步知道它们都在eden之中分配给main线程的thread-local allocation buffer (TLAB)中：
Hsdb代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>hsdb&gt; whatis 0x00000000fa49a710  </li>
<li>Address 0x00000000fa49a710: In thread-local allocation buffer for thread &quot;main&quot; (1)  [0x00000000fa48f490,0x00000000fa49a750,0x00000000fa49d118)  </li>
<li></li>
<li>hsdb&gt; whatis 0x00000000fa49a730  </li>
<li>Address 0x00000000fa49a730: In thread-local allocation buffer for thread &quot;main&quot; (1)  [0x00000000fa48f490,0x00000000fa49a750,0x00000000fa49d118)  </li>
<li></li>
<li>hsdb&gt; whatis 0x00000000fa49a740  </li>
<li>Address 0x00000000fa49a740: In thread-local allocation buffer for thread &quot;main&quot; (1)  [0x00000000fa48f490,0x00000000fa49a750,0x00000000fa49d118)  </li>
<li></li>
<li>hsdb&gt;   </li>
</ol>
<p>hsdb&gt; whatis 0x00000000fa49a710</p>
<p>Address 0x00000000fa49a710: In thread-local allocation buffer for thread &quot;main&quot; (1)  [0x00000000fa48f490,0x00000000fa49a750,0x00000000fa49d118)</p>
<p>hsdb&gt; whatis 0x00000000fa49a730
Address 0x00000000fa49a730: In thread-local allocation buffer for thread &quot;main&quot; (1)  [0x00000000fa48f490,0x00000000fa49a750,0x00000000fa49d118)</p>
<p>hsdb&gt; whatis 0x00000000fa49a740</p>
<p>Address 0x00000000fa49a740: In thread-local allocation buffer for thread &quot;main&quot; (1)  [0x00000000fa48f490,0x00000000fa49a750,0x00000000fa49d118)</p>
<p>hsdb&gt;
还可以用inspect命令来查看对象的内容：
Hsdb代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>hsdb&gt; inspect 0x00000000fa49a710  </li>
<li>instance of Oop for Test2 @ 0x00000000fa49a710 @ 0x00000000fa49a710 (size = 16)  </li>
<li>_mark: 1  </li>
</ol>
<p>hsdb&gt; inspect 0x00000000fa49a710</p>
<p>instance of Oop for Test2 @ 0x00000000fa49a710 @ 0x00000000fa49a710 (size = 16)
_mark: 1
可见一个Test2的实例要16字节。因为Test2类没有任何Java层的实例字段，这里就没有任何Java实例字段可显示。不过本来这里还应该显示一行：
Hsdb代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>_metadata._compressed_klass: InstanceKlass for Test2 @ 0x00000000fb078608  </li>
</ol>
<p>_metadata._compressed_klass: InstanceKlass for Test2 @ 0x00000000fb078608
不幸因为这个版本的HotSpot VM里带的SA有bug所以没显示出来。此bug在新版里已修。
还想看到更裸的数据的同学可以用mem命令来看实际内存里的数据长啥样：
Hsdb代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>hsdb&gt; mem 0x00000000fa49a710 2  </li>
<li>0x00000000fa49a710: 0x0000000000000001   </li>
<li>0x00000000fa49a718: 0x00000000fb078608   </li>
</ol>
<p>hsdb&gt; mem 0x00000000fa49a710 2</p>
<p>0x00000000fa49a710: 0x0000000000000001
0x00000000fa49a718: 0x00000000fb078608
mem命令接受的两个参数都必选，一个是起始地址，另一个是以字宽为单位的“长度”。我们知道一个Test2实例有16字节，所以给定长度为2来看。
上面的数字都是啥来的呢？
Memory代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>0x00000000fa49a710:  _mark:                        0x0000000000000001   </li>
<li>0x00000000fa49a718:  _metadata._compressed_klass:  0xfb078608  </li>
<li>0x00000000fa49a71c:  (padding):                    0x00000000  </li>
</ol>
<p>0x00000000fa49a710:  _mark:                        0x0000000000000001</p>
<p>0x00000000fa49a718:  _metadata._compressed_klass:  0xfb078608
0x00000000fa49a71c:  (padding):                    0x00000000
一个Test2的实例包含2个给VM用的隐含字段作为对象头，和0个Java字段。
对象头的第一个字段是mark word，记录该对象的GC状态、同步状态、identity hash code之类的多种信息。
对象头的第二个字段是个类型信息指针，klass pointer。这里因为默认开启了压缩指针，所以本来应该是64位的指针存在了32位字段里。
最后还有4个字节是为了满足对齐需求而做的填充（padding）。
以前在另一帖里也介绍过这部分内容，可以参考：<a href="http://rednaxelafx.iteye.com/blog/730461" target="_blank">借助HotSpot SA来一窥PermGen上的对象</a>
顺带发张Inspector的截图来展示HotSpot VM里描述Test2类的VM对象长啥样吧。
在菜单里选Tools -&gt; Inspector，在地址里输入前面看到的klass地址：
<img src="&quot;点击查看原始大小图片&quot;" alt="">
InstanceKlass存着Java类型的名字、继承关系、实现接口关系，字段信息，方法信息，运行时常量池的指针，还有内嵌的虚方法表（vtable）、接口方法表（itable）和记录对象里什么位置上有GC会关心的指针（oop map）等等。
留意到这个InstanceKlass是给VM内部用的，并不直接暴露给Java层；InstanceKlass不是java.lang.Class的实例。
在HotSpot VM里，java.lang.Class的实例被称为“Java mirror”，意思是它是VM内部用的klass对象的“镜像”，把klass对象包装了一层来暴露给Java层使用。
在InstanceKlass里有个_java_mirror字段引用着它对应的Java mirror，而mirror里也有个隐藏字段指向其对应的InstanceKlass。
所以当我们写obj.getClass()，在HotSpot VM里实际上经过了两层间接引用才能找到最终的Class对象：
Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>obj-&gt;_klass-&gt;_java_mirror  </li>
</ol>
<p>obj-&gt;_klass-&gt;_java_mirror
在Oracle JDK7之前，Oracle/Sun JDK的HotSpot VM把Java类的静态变量存在InstanceKlass结构的末尾；从Oracle JDK7开始，为了配合PermGen移除的工作，Java类的静态变量被挪到Java mirror（Class对象）的末尾了。</p>
<h1 id="-jdk7-java-mirror-permgen-jdk7-java-mirror-java-eden-permgen-jdk8-permgen-klass-gc-java-mirror-jdk7-">还有就是，在JDK7之前Java mirror存放在PermGen里，而从JDK7开始Java mirror默认也跟普通Java对象一样先从eden开始分配而不放在PermGen里。到JDK8则进一步彻底移除了PermGen，把诸如klass之类的元数据都挪到GC堆之外管理，而Java mirror的处理则跟JDK7一样。</h1>
<p>前面对HSDB的操作和HotSpot VM里的一些内部数据结构有了一定的了解，现在让我们回到主题：找指针！
HotSpot VM内部使用直接指针来实现Java引用。在64位环境中有可能启用“压缩指针”的功能把64位指针压缩到只用32位来存。压缩指针与非压缩指针直接有非常简单的1对1对应关系，前者可以看作后者的特例。
于是我们要找t1、t2、t3这三个变量，等同于找出存有指向上述3个Test2实例的地址的存储位置。
不嫌麻烦的话手工扫描内存去找也能找到，不过幸好HSDB内建了revptrs命令，可以找出“反向指针”——如果a变量引用着b对象，那么对b对象来说a就是一个“反向指针”。
先拿第一个Test2的实例试试看：
Hsdb代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>hsdb&gt; revptrs 0x00000000fa49a710  </li>
<li>Computing reverse pointers...  </li>
<li>Done.  </li>
<li>null  </li>
<li>Oop for java/lang/Class @ 0x00000000fa499b00  </li>
</ol>
<p>hsdb&gt; revptrs 0x00000000fa49a710</p>
<p>Computing reverse pointers...
Done.</p>
<p>null
Oop for java/lang/Class @ 0x00000000fa499b00
还真的找到了一个包含指向Test2实例的指针，在一个java.lang.Class的实例里。
用whatis命令来看看这个Class对象在哪里：
Hsdb代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>hsdb&gt; whatis 0x00000000fa499b00  </li>
<li>Address 0x00000000fa499b00: In thread-local allocation buffer for thread &quot;main&quot; (1)  [0x00000000fa48f490,0x00000000fa49a750,0x00000000fa49d118)  </li>
<li></li>
</ol>
<p>hsdb&gt; whatis 0x00000000fa499b00</p>
<p>Address 0x00000000fa499b00: In thread-local allocation buffer for thread &quot;main&quot; (1)  [0x00000000fa48f490,0x00000000fa49a750,0x00000000fa49d118)</p>
<p>可以看到这个Class对象也在eden里，具体来说在main线程的TLAB里。
这个Class对象是如何引用到Test2的实例的呢？再用inspect命令：
Hsdb代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>hsdb&gt; inspect 0x00000000fa499b00  </li>
<li>instance of Oop for java/lang/Class @ 0x00000000fa499b00 @ 0x00000000fa499b00 (size = 120)  </li>
<li>&lt;<Reverse pointers>&gt;:   </li>
<li>t1: Oop for Test2 @ 0x00000000fa49a710 Oop for Test2 @ 0x00000000fa49a710  </li>
</ol>
<p>hsdb&gt; inspect 0x00000000fa499b00</p>
<p>instance of Oop for java/lang/Class @ 0x00000000fa499b00 @ 0x00000000fa499b00 (size = 120)
&lt;<Reverse pointers>&gt;:</p>
<p>t1: Oop for Test2 @ 0x00000000fa49a710 Oop for Test2 @ 0x00000000fa49a710
可以看到，这个Class对象里存着Test类的静态变量t1，指向着第一个Test2实例。
<strong>成功找到t1了！这个有点特别，本来JVM规范里也没明确规定静态变量要存在哪里，通常认为它应该在概念中的“方法区”里；但现在在JDK7的HotSpot VM里它实质上也被放在Java heap里了。可以把这种特例看作是HotSpot VM把方法区的一部分数据也放在Java heap里了。
前面也已经提过，在JDK7之前的Oracle/Sun JDK里的HotSpot VM把静态变量存在InstanceKlass末尾，存在PermGen里。那个时候的PermGen更接近于完整的方法区一些。</strong>
关于PermGen移除计划的一些零星笔记可以参考<a href="http://rednaxelafx.iteye.com/blog/905273" target="_blank">我以前一老帖</a>。
再接再厉，用revptrs看看第二个Test2实例有谁引用：
Hsdb代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>hsdb&gt; revptrs 0x00000000fa49a730  </li>
<li>Oop for Test @ 0x00000000fa49a720  </li>
</ol>
<p>hsdb&gt; revptrs 0x00000000fa49a730</p>
<p>Oop for Test @ 0x00000000fa49a720
找到了一个Test实例。同样用whatis来看看它在哪儿：
Hsdb代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>hsdb&gt; whatis 0x00000000fa49a720  </li>
<li>Address 0x00000000fa49a720: In thread-local allocation buffer for thread &quot;main&quot; (1)  [0x00000000fa48f490,0x00000000fa49a750,0x00000000fa49d118)  </li>
<li></li>
</ol>
<p>hsdb&gt; whatis 0x00000000fa49a720</p>
<p>Address 0x00000000fa49a720: In thread-local allocation buffer for thread &quot;main&quot; (1)  [0x00000000fa48f490,0x00000000fa49a750,0x00000000fa49d118)</p>
<p>果然也在main线程的TLAB里。
然后看这个Test实例的内容：
Hsdb代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>hsdb&gt; inspect 0x00000000fa49a720  </li>
<li>instance of Oop for Test @ 0x00000000fa49a720 @ 0x00000000fa49a720 (size = 16)  </li>
<li>&lt;<Reverse pointers>&gt;:   </li>
<li>_mark: 1  </li>
<li>t2: Oop for Test2 @ 0x00000000fa49a730 Oop for Test2 @ 0x00000000fa49a730  </li>
</ol>
<p>hsdb&gt; inspect 0x00000000fa49a720</p>
<p>instance of Oop for Test @ 0x00000000fa49a720 @ 0x00000000fa49a720 (size = 16)
&lt;<Reverse pointers>&gt;:</p>
<p>_mark: 1
t2: Oop for Test2 @ 0x00000000fa49a730 Oop for Test2 @ 0x00000000fa49a730
可以看到这个Test实例里有个成员字段t2，指向了第二个Test2实例。
<strong>于是t2也找到了！在Java堆里，作为Test的实例的成员字段存在。</strong>
那么赶紧试试用revptrs命令看第三个Test2实例：
Hsdb代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>hsdb&gt; revptrs 0x00000000fa49a740  </li>
<li>null  </li>
</ol>
<p>hsdb&gt; revptrs 0x00000000fa49a740</p>
<p>null
啥？没找到？！SA这也太弱小了吧。明明就在那里…
回头我会做个补丁让新版HotSpot VM的SA能处理这种情况。
这个时候的HSDB界面全貌：
<img src="&quot;点击查看原始大小图片&quot;" alt="">
0x00000000fa49a740看起来有没有点眼熟？
回到前面打开的Stack Memory窗口看，仔细看会发现那个窗口里正好就有0x00000000fa49a740这数字，位于0x000000000287f858地址上。
实际情况是，下面这张图里红色框住的部分就是main线程上Test.fn()的调用对应的栈帧：
<img src="&quot;点击查看原始大小图片&quot;" alt="">
如果图里看得不清楚的话，我再用文字重新写一遍（两道横线之间的是Test.fn()的栈帧内容，前后的则是别的东西）：
Memory代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>0x000000000287f7f0: 0x0000000002886298   </li>
<li>0x000000000287f7f8: 0x0000000002893ca5   </li>
<li>0x000000000287f800: 0x0000000002893ca5   </li>
<li><hr>
</li>
<li>Stack frame for Test.fn() @bci=8, line=6, pc=0x0000000002893ca5, methodOop=0x00000000fb077f78 (Interpreted frame)  </li>
<li>0x000000000287f808: 0x000000000287f808 expression stack bottom          &lt;- rsp  </li>
<li>0x000000000287f810: 0x00000000fb077f58 bytecode pointer    = 0x00000000fb077f50 (base) + 8 (bytecode index) in PermGen  </li>
<li>0x000000000287f818: 0x000000000287f860 pointer to locals  </li>
<li>0x000000000287f820: 0x00000000fb078360 constant pool cache = ConstantPoolCache for Test in PermGen  </li>
<li>0x000000000287f828: 0x0000000000000000 method data oop     = null  </li>
<li>0x000000000287f830: 0x00000000fb077f78 method oop          = Method for Test.fn()V in PermGen  </li>
<li>0x000000000287f838: 0x0000000000000000 last Java stack pointer (not set)  </li>
<li>0x000000000287f840: 0x000000000287f860 old stack pointer (saved rsp)  </li>
<li>0x000000000287f848: 0x000000000287f8a8 old frame pointer (saved rbp)    &lt;- rbp  </li>
<li>0x000000000287f850: 0x0000000002886298 return address      = in interpreter codelet &quot;return entry points&quot; [0x00000000028858b8, 0x00000000028876c0)  7688 bytes  </li>
<li>0x000000000287f858: 0x00000000fa49a740 local[1] &quot;t3&quot;       = Oop for Test2 in NewGen  </li>
<li>0x000000000287f860: 0x00000000fa49a720 local[0] &quot;this&quot;     = Oop for Test in NewGen  </li>
<li><hr>
</li>
<li>0x000000000287f868: 0x000000000287f868   </li>
<li>0x000000000287f870: 0x00000000fb077039   </li>
<li>0x000000000287f878: 0x000000000287f8c0   </li>
<li>0x000000000287f880: 0x00000000fb077350   </li>
<li>0x000000000287f888: 0x0000000000000000   </li>
<li>0x000000000287f890: 0x00000000fb077060   </li>
<li>0x000000000287f898: 0x000000000287f860   </li>
<li>0x000000000287f8a0: 0x000000000287f8c0   </li>
<li>0x000000000287f8a8: 0x000000000287f9a0   </li>
<li>0x000000000287f8b0: 0x000000000288062a   </li>
<li>0x000000000287f8b8: 0x00000000fa49a720   </li>
<li>0x000000000287f8c0: 0x00000000fa498ea8   </li>
<li>0x000000000287f8c8: 0x0000000000000000   </li>
<li>0x000000000287f8d0: 0x0000000000000000   </li>
<li>0x000000000287f8d8: 0x0000000000000000   </li>
</ol>
<p>0x000000000287f7f0: 0x0000000002886298</p>
<p>0x000000000287f7f8: 0x0000000002893ca5
0x000000000287f800: 0x0000000002893ca5</p>
<hr>
<p>Stack frame for Test.fn() @bci=8, line=6, pc=0x0000000002893ca5, methodOop=0x00000000fb077f78 (Interpreted frame)</p>
<p>0x000000000287f808: 0x000000000287f808 expression stack bottom          &lt;- rsp
0x000000000287f810: 0x00000000fb077f58 bytecode pointer    = 0x00000000fb077f50 (base) + 8 (bytecode index) in PermGen</p>
<p>0x000000000287f818: 0x000000000287f860 pointer to locals
0x000000000287f820: 0x00000000fb078360 constant pool cache = ConstantPoolCache for Test in PermGen</p>
<p>0x000000000287f828: 0x0000000000000000 method data oop     = null
0x000000000287f830: 0x00000000fb077f78 method oop          = Method for Test.fn()V in PermGen</p>
<p>0x000000000287f838: 0x0000000000000000 last Java stack pointer (not set)
0x000000000287f840: 0x000000000287f860 old stack pointer (saved rsp)</p>
<p>0x000000000287f848: 0x000000000287f8a8 old frame pointer (saved rbp)    &lt;- rbp
0x000000000287f850: 0x0000000002886298 return address      = in interpreter codelet &quot;return entry points&quot; [0x00000000028858b8, 0x00000000028876c0)  7688 bytes</p>
<p>0x000000000287f858: 0x00000000fa49a740 local[1] &quot;t3&quot;       = Oop for Test2 in NewGen
0x000000000287f860: 0x00000000fa49a720 local[0] &quot;this&quot;     = Oop for Test in NewGen</p>
<hr>
<p>0x000000000287f868: 0x000000000287f868</p>
<p>0x000000000287f870: 0x00000000fb077039
0x000000000287f878: 0x000000000287f8c0</p>
<p>0x000000000287f880: 0x00000000fb077350
0x000000000287f888: 0x0000000000000000</p>
<p>0x000000000287f890: 0x00000000fb077060
0x000000000287f898: 0x000000000287f860</p>
<p>0x000000000287f8a0: 0x000000000287f8c0
0x000000000287f8a8: 0x000000000287f9a0</p>
<p>0x000000000287f8b0: 0x000000000288062a
0x000000000287f8b8: 0x00000000fa49a720</p>
<p>0x000000000287f8c0: 0x00000000fa498ea8
0x000000000287f8c8: 0x0000000000000000</p>
<p>0x000000000287f8d0: 0x0000000000000000
0x000000000287f8d8: 0x0000000000000000
回顾<a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-2.html#jvms-2.6" target="_blank">JVM规范里所描述的Java栈帧结构</a>，包括：
[ 操作数栈  (operand stack)   ]</p>
<p>[ 栈帧信息  (dynamic linking) ]
[ 局部变量区 (local variables) ]
上张<a href="http://www.valleytalk.org/2011/07/28/java-%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%EF%BC%8C%E5%8A%A0%E8%BD%BD-%E5%92%8C-%E6%89%A7%E8%A1%8C/" target="_blank">我以前做的投影稿</a>里的图：
<img src="" alt="">
再跟HotSpot VM的解释器所使用的栈帧布局对比看看，是不是正好能对应上？局部变量区（locals）有了，VM所需的栈帧信息也有了；执行到这个位置operand stack正好是空的所以看不到它。
（HotSpot VM里把operand stack叫做expression stack。这是因为operand stack通常只在表达式求值过程中才有内容）
<strong>从Test.fn()的栈帧中我们可以看到t3变量就在locals[1]的位置上。t3变量也找到了！大功告成！</strong>
栈帧信息里具体都是些啥，以后有机会再展开讲吧。
都看到这里了，干脆把main方法的栈帧也如法炮制分析一下。先上图：
<img src="&quot;点击查看原始大小图片&quot;" alt="">
然后再用文字写一次：
Memory代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a></p>
<ol>
<li>0x000000000287f7f0: 0x0000000002886298   </li>
<li>0x000000000287f7f8: 0x0000000002893ca5   </li>
<li>0x000000000287f800: 0x0000000002893ca5   </li>
<li>0x000000000287f808: 0x000000000287f808   </li>
<li>0x000000000287f810: 0x00000000fb077f58   </li>
<li>0x000000000287f818: 0x000000000287f860   </li>
<li>0x000000000287f820: 0x00000000fb078360   </li>
<li>0x000000000287f828: 0x0000000000000000   </li>
<li>0x000000000287f830: 0x00000000fb077f78   </li>
<li>0x000000000287f838: 0x0000000000000000   </li>
<li>0x000000000287f840: 0x000000000287f860   </li>
<li>0x000000000287f848: 0x000000000287f8a8   </li>
<li>0x000000000287f850: 0x0000000002886298   </li>
<li>0x000000000287f858: 0x00000000fa49a740   </li>
<li><hr>
</li>
<li>Stack frame for Main.main(java.lang.String[]) @bci=9, line=4, pc=0x0000000002886298, methodOop=0x00000000fb077060 (Interpreted frame)  </li>
<li>0x000000000287f860: 0x00000000fa49a720 expression stack[0] = Oop for Test in NewGen  </li>
<li>0x000000000287f868: 0x000000000287f868 expression stack bottom  </li>
<li>0x000000000287f870: 0x00000000fb077039 bytecode pointer    = 0x00000000fb077030 (base) + 9 (bytecode index) in PermGen  </li>
<li>0x000000000287f878: 0x000000000287f8c0 pointer to locals  </li>
<li>0x000000000287f880: 0x00000000fb077350 constant pool cache = ConstantPoolCache for Main in PermGen  </li>
<li>0x000000000287f888: 0x0000000000000000 method data oop     = null  </li>
<li>0x000000000287f890: 0x00000000fb077060 method oop          = Method for Main.main([Ljava/lang/String;)V in PermGen  </li>
<li>0x000000000287f898: 0x000000000287f860 last Java stack pointer  </li>
<li>0x000000000287f8a0: 0x000000000287f8c0 old stack pointer  </li>
<li>0x000000000287f8a8: 0x000000000287f9a0 old frame pointer  </li>
<li>0x000000000287f8b0: 0x000000000288062a return address      = in StubRoutines  </li>
<li>0x000000000287f8b8: 0x00000000fa49a720 local[1] &quot;test&quot;     = Oop for Test in NewGen  </li>
<li>0x000000000287f8c0: 0x00000000fa498ea8 local[0] &quot;args&quot;     = Oop for java.lang.String[] in NewGen  </li>
<li><hr>
</li>
<li>0x000000000287f8c8: 0x0000000000000000   </li>
<li>0x000000000287f8d0: 0x0000000000000000   </li>
<li>0x000000000287f8d8: 0x0000000000000000   </li>
</ol>
<p>0x000000000287f7f0: 0x0000000002886298</p>
<p>0x000000000287f7f8: 0x0000000002893ca5
0x000000000287f800: 0x0000000002893ca5</p>
<p>0x000000000287f808: 0x000000000287f808
0x000000000287f810: 0x00000000fb077f58</p>
<p>0x000000000287f818: 0x000000000287f860
0x000000000287f820: 0x00000000fb078360</p>
<p>0x000000000287f828: 0x0000000000000000
0x000000000287f830: 0x00000000fb077f78</p>
<p>0x000000000287f838: 0x0000000000000000
0x000000000287f840: 0x000000000287f860</p>
<p>0x000000000287f848: 0x000000000287f8a8
0x000000000287f850: 0x0000000002886298</p>
<h2 id="0x000000000287f858-0x00000000fa49a740">0x000000000287f858: 0x00000000fa49a740</h2>
<p>Stack frame for Main.main(java.lang.String[]) @bci=9, line=4, pc=0x0000000002886298, methodOop=0x00000000fb077060 (Interpreted frame)
0x000000000287f860: 0x00000000fa49a720 expression stack[0] = Oop for Test in NewGen</p>
<p>0x000000000287f868: 0x000000000287f868 expression stack bottom
0x000000000287f870: 0x00000000fb077039 bytecode pointer    = 0x00000000fb077030 (base) + 9 (bytecode index) in PermGen</p>
<p>0x000000000287f878: 0x000000000287f8c0 pointer to locals
0x000000000287f880: 0x00000000fb077350 constant pool cache = ConstantPoolCache for Main in PermGen</p>
<p>0x000000000287f888: 0x0000000000000000 method data oop     = null
0x000000000287f890: 0x00000000fb077060 method oop          = Method for Main.main([Ljava/lang/String;)V in PermGen</p>
<p>0x000000000287f898: 0x000000000287f860 last Java stack pointer
0x000000000287f8a0: 0x000000000287f8c0 old stack pointer</p>
<p>0x000000000287f8a8: 0x000000000287f9a0 old frame pointer
0x000000000287f8b0: 0x000000000288062a return address      = in StubRoutines</p>
<p>0x000000000287f8b8: 0x00000000fa49a720 local[1] &quot;test&quot;     = Oop for Test in NewGen
0x000000000287f8c0: 0x00000000fa498ea8 local[0] &quot;args&quot;     = Oop for java.lang.String[] in NewGen</p>
<hr>
<p>0x000000000287f8c8: 0x0000000000000000</p>
<p>0x000000000287f8d0: 0x0000000000000000
0x000000000287f8d8: 0x0000000000000000
main的栈帧的operand stack就不是空的了，有一个元素，用来传递参数给其调用的Test.fn()方法（作为“this”）。
仔细的同学可能发现了，0x000000000287f860这个地址前面不是说是调用Test.fn()产生的栈帧么？怎么这里又变成调用main()方法的栈帧的一部分了呢？
其实栈帧直接可以有重叠：（再上一张以前做的投影稿里的图）
<img src="&quot;点击查看原始大小图片&quot;" alt="">
这样可以减少传递参数所需的数据拷贝，也节省了空间。
回到HSDB，我们换个方式来把t3变量找出来。这里就需要编译Test.java时给的-g参数所生成的LocalVariableTable的信息了：
Hsdb代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a></p>
<ol>
<li>hsdb&gt; jseval &quot;ts = jvm.threads&quot;  </li>
<li>[Thread (address=0x00000000fa48fb38, name=Service Thread), Thread (address=0x00000000fa48fa18, name=C2 CompilerThread1), Thread (address=0x00000000fa48f8f8, name=C2 CompilerThread0), Thread (address=0x00000000fa49d178, name=JDWP Command Reader), Thread (address=0x00000000fa48f820, name=JDWP Event Helper Thread), Thread (address=0x00000000fa48f6d8, name=JDWP Transport Listener: dt_shmem), Thread (address=0x00000000fa48dc88, name=Attach Listener), Thread (address=0x00000000fa48db68, name=Signal Dispatcher), Thread (address=0x00000000fa405828, name=Finalizer), Thread (address=0x00000000fa4053a0, name=Reference Handler), Thread (address=0x00000000fa404860, name=main)]   </li>
<li>hsdb&gt; jseval &quot;t = ts[ts.length - 1]&quot;  </li>
<li>Thread (address=0x00000000fa404860, name=main)   </li>
<li>hsdb&gt; jseval &quot;fs = t.frames&quot;  </li>
<li>[Frame (method=Test.fn(), bci=8, line=6), Frame (method=Main.main(java.lang.String[]), bci=9, line=4)]   </li>
<li>hsdb&gt; jseval &quot;f0 = fs[0]&quot;  </li>
<li>Frame (method=Test.fn(), bci=8, line=6)   </li>
<li>hsdb&gt; jseval &quot;f1 = fs[1]&quot;  </li>
<li>Frame (method=Main.main(java.lang.String[]), bci=9, line=4)   </li>
<li>hsdb&gt; jseval &quot;f0.locals&quot;  </li>
<li>{t3=Object 0x00000000fa49a740}   </li>
<li>hsdb&gt;   </li>
</ol>
<p>hsdb&gt; jseval &quot;ts = jvm.threads&quot;</p>
<p>[Thread (address=0x00000000fa48fb38, name=Service Thread), Thread (address=0x00000000fa48fa18, name=C2 CompilerThread1), Thread (address=0x00000000fa48f8f8, name=C2 CompilerThread0), Thread (address=0x00000000fa49d178, name=JDWP Command Reader), Thread (address=0x00000000fa48f820, name=JDWP Event Helper Thread), Thread (address=0x00000000fa48f6d8, name=JDWP Transport Listener: dt_shmem), Thread (address=0x00000000fa48dc88, name=Attach Listener), Thread (address=0x00000000fa48db68, name=Signal Dispatcher), Thread (address=0x00000000fa405828, name=Finalizer), Thread (address=0x00000000fa4053a0, name=Reference Handler), Thread (address=0x00000000fa404860, name=main)]
hsdb&gt; jseval &quot;t = ts[ts.length - 1]&quot;</p>
<p>Thread (address=0x00000000fa404860, name=main)
hsdb&gt; jseval &quot;fs = t.frames&quot;</p>
<p>[Frame (method=Test.fn(), bci=8, line=6), Frame (method=Main.main(java.lang.String[]), bci=9, line=4)]
hsdb&gt; jseval &quot;f0 = fs[0]&quot;</p>
<p>Frame (method=Test.fn(), bci=8, line=6)
hsdb&gt; jseval &quot;f1 = fs[1]&quot;</p>
<p>Frame (method=Main.main(java.lang.String[]), bci=9, line=4)
hsdb&gt; jseval &quot;f0.locals&quot;</p>
<p>{t3=Object 0x00000000fa49a740}</p>
<h1 id="hsdb-">hsdb&gt;</h1>
<p>上面讲栈帧布局的时候出现了“bytecode pointer”字眼。既然之前被不少好奇的同学问过“JVM里字节码存在哪里”，这里就一并回答掉好了。
强调一点：“字节码”只是元数据的一部分。它只负责描述运行逻辑，而其它信息像是类型名、成员的个数、类型、名字等等都<strong>不是字节码</strong>。在Class文件里是如此，到运行时在JVM里仍然是如此。
HotSpot VM里有一套对象专门用来存放元数据，它们包括：</p>
<ul>
<li>Klass系对象。元数据的最主要入口。用于描述类型的总体信息</li>
<li>ConstantPool/ConstantPoolCache对象。每个InstanceKlass关联着一个ConstantPool，作为该类型的运行时常量池。这个常量池的结构跟Class文件里的常量池基本上是对应的。可以参考<a href="http://hllvm.group.iteye.com/group/topic/26412#post-187861" target="_blank">我以前的一个回帖</a>。ConstantPoolCache主要用于存储某些字节码指令所需的解析（resolve）好的常量项，例如给[get|put]static、[get|put]field、invoke[static|special|virtual|interface|dynamic]等指令对应的常量池项用。</li>
<li>Method对象，用来描述Java方法的总体信息，像是方法入口地址、调用/循环计数器等等</li>
<li>ConstMethod对象，记录着Java方法的不变的描述信息，包括方法名、方法的访问修饰符、<strong>字节码</strong>、行号表、局部变量表等等。注意了，字节码就嵌在这ConstMethod对象里面。</li>
<li>Symbol对象，对应Class文件常量池里的JVM_CONSTANT_Utf8类型的常量。有一个VM全局的SymbolTable管理着所有Symbol。Symbol由所有Java类所共享。</li>
<li>MethodData对象，记录着Java方法执行时的profile信息，例如某方法里的某个字节码之类是否从来没遇到过null，某个条件跳转是否总是走同一个分支，等等。这些信息在解释器（多层编译模式下也在低层的编译生成的代码里）收集，然后供给HotSpot Server Compiler用于做激进优化。
在PermGen移除前，上述元数据对象都在PermGen里，直接被GC管理着。
JDK8彻底移除PermGen后，这些对象被挪到GC堆外的一块叫做Metaspace的空间里做特殊管理，仍然间接的受GC管理。
介绍了背景，让我们回到HSDB里。前面不是说“bytecode pointer (bcp)”嘛，从背景介绍可以知道字节码存在ConstMethod对象里，那就让我们用Test.fn()栈帧里存的bcp来验证一下是否真的如此。
还是用whatis命令：
Hsdb代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a></li>
</ul>
<ol>
<li>hsdb&gt; whatis 0x00000000fb077f58  </li>
<li>Address 0x00000000fb077f58: In perm generation   perm [0x00000000fae00000,0x00000000fb078898,0x00000000fc2c0000) space capacity = 21757952, 11.90770160721009 used   </li>
</ol>
<p>hsdb&gt; whatis 0x00000000fb077f58</p>
<p>Address 0x00000000fb077f58: In perm generation   perm <a href="&quot;复制代码&quot;">0x00000000fae00000,0x00000000fb078898,0x00000000fc2c0000) space capacity = 21757952, 11.90770160721009 used
这地址确实在PermGen里了。那么inspect一下看看？
Hsdb代码 [<img src="" alt="复制代码"></a></p>
<ol>
<li>hsdb&gt; inspect 0x00000000fb077f58  </li>
<li>Error: sun.jvm.hotspot.debugger.UnalignedAddressException: 100011  </li>
</ol>
<p>hsdb&gt; inspect 0x00000000fb077f58</p>
<p>Error: sun.jvm.hotspot.debugger.UnalignedAddressException: 100011
呃，这样不行。inspect命令只能接受对象的起始地址，但字节码是嵌在ConstMethod对象中间的。
那换条路子。栈帧里还有method oop，指向该栈帧对应的Method对象。先从它入手：
Hsdb代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a></p>
<ol>
<li>hsdb&gt; inspect 0x00000000fb077f78  </li>
<li>instance of Method fn()V@0x00000000fb077f78 @ 0x00000000fb077f78 @ 0x00000000fb077f78 (size = 136)  </li>
<li>_mark: 1  </li>
<li>_constMethod: ConstMethod fn()V@0x00000000fb077f08 @ 0x00000000fb077f08 Oop @ 0x00000000fb077f08  </li>
<li>_constants: ConstantPool for Test @ 0x00000000fb077c68 Oop @ 0x00000000fb077c68  </li>
<li>_method_size: 17  </li>
<li>_max_stack: 2  </li>
<li>_max_locals: 2  </li>
<li>_size_of_parameters: 1  </li>
<li>_access_flags: 1  </li>
</ol>
<p>hsdb&gt; inspect 0x00000000fb077f78</p>
<p>instance of Method fn()V@0x00000000fb077f78 @ 0x00000000fb077f78 @ 0x00000000fb077f78 (size = 136)
_mark: 1</p>
<p>_constMethod: ConstMethod fn()V@0x00000000fb077f08 @ 0x00000000fb077f08 Oop @ 0x00000000fb077f08
_constants: ConstantPool for Test @ 0x00000000fb077c68 Oop @ 0x00000000fb077c68</p>
<p>_method_size: 17
_max_stack: 2</p>
<p>_max_locals: 2
_size_of_parameters: 1</p>
<p>_access_flags: 1
这样就找到了Test.fn()的Method对象，看到里面的_constMethod字段所指向的ConstMethod对象：
Hsdb代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a></p>
<ol>
<li>hsdb&gt; inspect 0x00000000fb077f08  </li>
<li>instance of ConstMethod fn()V@0x00000000fb077f08 @ 0x00000000fb077f08 @ 0x00000000fb077f08 (size = 112)  </li>
<li>_mark: 1  </li>
<li>_method: Method fn()V@0x00000000fb077f78 @ 0x00000000fb077f78 Oop @ 0x00000000fb077f78  </li>
<li>_exception_table: [I @ 0x00000000fae01d50 Oop for [I @ 0x00000000fae01d50  </li>
<li>_constMethod_size: 14  </li>
<li>_flags: 5  </li>
<li>_code_size: 9  </li>
<li>_name_index: 18  </li>
<li>_signature_index: 12  </li>
<li>_generic_signature_index: 0  </li>
<li>_code_size: 9  </li>
</ol>
<p>hsdb&gt; inspect 0x00000000fb077f08</p>
<p>instance of ConstMethod fn()V@0x00000000fb077f08 @ 0x00000000fb077f08 @ 0x00000000fb077f08 (size = 112)
_mark: 1</p>
<p>_method: Method fn()V@0x00000000fb077f78 @ 0x00000000fb077f78 Oop @ 0x00000000fb077f78
_exception_table: [I @ 0x00000000fae01d50 Oop for [I @ 0x00000000fae01d50</p>
<p>_constMethod_size: 14
_flags: 5</p>
<p>_code_size: 9
_name_index: 18</p>
<p>_signature_index: 12
_generic_signature_index: 0</p>
<p>_code_size: 9
这个ConstMethod对象从0x00000000fb077f08开始，长度112字节，也就是这个对象的范围是<a href="&quot;复制代码&quot;">0x00000000fb077f08, 0x00000000fb077f78)。bcp指向0x00000000fb077f58，确实在这个ConstMethod范围内。
通过经验可以知道实际上这里字节码的起始地址是0x00000000fb077f50。通过ConstMethod的_code_size字段可以知道该方法的字节码有9字节。找出来用mem命令看看内存里的数据：
Hsdb代码 [<img src="" alt="复制代码"></a></p>
<ol>
<li>hsdb&gt; mem 0x00000000fb077f50 2  </li>
<li>0x00000000fb077f50: 0x4c0001b7590200ca   </li>
<li>0x00000000fb077f58: 0x00000000004105b1   </li>
</ol>
<p>hsdb&gt; mem 0x00000000fb077f50 2</p>
<p>0x00000000fb077f50: 0x4c0001b7590200ca
0x00000000fb077f58: 0x00000000004105b1
这串数字是什么东西呢？展开来写清楚一点就是：
Memory代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a></p>
<ol>
<li>0x00000000fb077f50:  bb 00 02  new <cp index /#2> [Class Test2]  </li>
<li>0x00000000fb077f53:  59        dup  </li>
<li>0x00000000fb077f54:  b7 01 00  invokespecial <cp cache index /#1> [Method Test2.<init>()V]  </li>
<li>0x00000000fb077f57:  4c        astore_1  </li>
<li>0x00000000fb077f58:  b1        return  </li>
</ol>
<p>0x00000000fb077f50:  bb 00 02  new <cp index /#2> [Class Test2]</p>
<p>0x00000000fb077f53:  59        dup
0x00000000fb077f54:  b7 01 00  invokespecial <cp cache index /#1> [Method Test2.<init>()V]</p>
<p>0x00000000fb077f57:  4c        astore_1
0x00000000fb077f58:  b1        return
眼尖的同学要吐槽了：在0x00000000fb077f50的字节不是0xca么，怎么变成0xbb了？
其实0xca是JVM规范里有描述的一个可选字节码指令，<a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html#jvms-6.2" target="_blank">breakpoint</a>
Memory代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a></p>
<ol>
<li>0x00000000fb077f50:  ca 00 02  breakpoint // 00 02 not used  </li>
</ol>
<p>0x00000000fb077f50:  ca 00 02  breakpoint // 00 02 not used
还记得本文的实验一开始用了jdb在Test.fn()的入口设置了断点吗？这就是结果——入口处的字节码指令被改写为breakpoint了。当然，原本的字节码指令也还在别的地方存着，等断点解除之后这个位置就会被恢复成原本的0xbb指令。
把ConstMethod里存的字节码跟Class文件里存的比较一下看看。用<a href="http://docs.oracle.com/javase/7/docs/technotes/tools/windows/javap.html" target="_blank">javap</a>工具来看Class文件的内容：
Javap代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a></p>
<ol>
<li>public void fn();  </li>
<li>Code:  </li>
<li>stack=2, locals=2, args_size=1  </li>
<li>0:  bb 00 02  new           /#2                  // class Test2  </li>
<li>3:  59        dup  </li>
<li>4:  b7 00 03  invokespecial /#3                  // Method Test2.&quot;<init>&quot;:()V  </li>
<li>7:  4c        astore_1  </li>
<li><p>8:  b1        return  </p>
<p>public void fn();</p>
<p>Code:
stack=2, locals=2, args_size=1</p>
<p>0:  bb 00 02  new           /#2                  // class Test2
3:  59        dup</p>
<p>4:  b7 00 03  invokespecial /#3                  // Method Test2.&quot;<init>&quot;:()V
7:  4c        astore_1</p>
<p>8:  b1        return
几乎一模一样。唯一的不同也是个有趣的小细节：invokespecial的参数的常量池号码不一样了。HotSpot VM执行new指令的时候用的还是Class文件里的常量池号和字节序。而在执行invokespecial时，光是ConstantPool里的的常量项不够地方放解析（resolve）出来的信息，所以把这些信息放在ConstantPoolCache里，然后也把invokespecial指令里的参数改写过来，顺带变成了平台相关的字节序。
同样也看看Main.main()方法。内存内容：
Memory代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a></p>
</li>
<li><p>hsdb&gt; mem 0x00000000fb077030 2  </p>
</li>
<li>0x00000000fb077030: 0x4c0001b7590200bb   </li>
<li>0x00000000fb077038: 0x214103b10002b62b   </li>
</ol>
<p>hsdb&gt; mem 0x00000000fb077030 2</p>
<p>0x00000000fb077030: 0x4c0001b7590200bb
0x00000000fb077038: 0x214103b10002b62b
展开来注解：
Memory代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a></p>
<ol>
<li>0x00000000fb077030:  bb 00 02  new <cp index /#2> [Class Test]  </li>
<li>0x00000000fb077033:  59        dup  </li>
<li>0x00000000fb077034:  b7 01 00  invokespecial <cp cache index /#1> [Method Test.<init>()V]  </li>
<li>0x00000000fb077037:  4c        astore_1  </li>
<li>0x00000000fb077038:  2b        aload_1  </li>
<li>0x00000000fb077039:  b6 02 00  invokevirtual <cp cache index /#2> [Method Test.fn()V]  </li>
<li>0x00000000fb07703c:  b1        return  </li>
</ol>
<p>0x00000000fb077030:  bb 00 02  new <cp index /#2> [Class Test]</p>
<p>0x00000000fb077033:  59        dup
0x00000000fb077034:  b7 01 00  invokespecial <cp cache index /#1> [Method Test.<init>()V]</p>
<p>0x00000000fb077037:  4c        astore_1
0x00000000fb077038:  2b        aload_1</p>
<p>0x00000000fb077039:  b6 02 00  invokevirtual <cp cache index /#2> [Method Test.fn()V]
0x00000000fb07703c:  b1        return
对应的javap输出：
Javap代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a></p>
<ol>
<li>public static void main(java.lang.String[]);  </li>
<li>Code:  </li>
<li>stack=2, locals=2, args_size=1  </li>
<li>0:  bb 00 02  new           /#2                  // class Test  </li>
<li>3:  59        dup  </li>
<li>4:  b7 00 03  invokespecial /#3                  // Method Test.&quot;<init>&quot;:()V  </li>
<li>7:  4c        astore_1  </li>
<li>8:  2b        aload_1  </li>
<li>9:  b6 00 04  invokevirtual /#4                  // Method Test.fn:()V  </li>
<li><p>12:  b1        return  </p>
<p>public static void main(java.lang.String[]);</p>
<p>Code:
stack=2, locals=2, args_size=1</p>
<p>0:  bb 00 02  new           /#2                  // class Test
3:  59        dup</p>
<p>4:  b7 00 03  invokespecial /#3                  // Method Test.&quot;<init>&quot;:()V
7:  4c        astore_1</p>
<p>8:  2b        aload_1
9:  b6 00 04  invokevirtual /#4                  // Method Test.fn:()V</p>
<p>12:  b1        return
好，今天就写到这里吧～</p>
</li>
</ol>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/JVM/">JVM</a></li></span></span> | <span class="tags">Tagged <a href="/tags/JVM/" class="label label-primary">JVM</a><a href="/tags/Java&J2EE/" class="label label-success">Java&J2EE</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:42"datetime="2014-03-07 09:54:42"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-JVM--借HSDB来探索HotSpotVM的运行时数据/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-JVM--借HSDB来探索HotSpotVM的运行时数据" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--动态跟踪Java代码的执行状况工具--BTrace/">动态跟踪Java代码的执行状况工具</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:42.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--动态跟踪Java代码的执行状况工具--BTrace/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-java-btrace">动态跟踪Java代码的执行状况工具--BTrace</h1>
<h1 id="-bluedavy-blog-http-www-blogjava-net-bluedavy-"><a href="http://www.blogjava.net/BlueDavy/" target="_blank">BlueDavy之技术Blog</a></h1>
<p>理论不懂就实践，实践不会就学理论！</p>
<h2 id="-java-btrace-http-www-blogjava-net-bluedavy-archive-2009-10-10-297661-html-"><a href="http://www.blogjava.net/BlueDavy/archive/2009/10/10/297661.html" target="_blank">动态跟踪Java代码的执行状况工具--BTrace</a></h2>
<p>非常强烈的推荐下BTrace这个工具，用了后不得不说太强大了，BTrace简单来说，就是能在不改动当前程序的情况下，运行时的去监控Java程序的执行状况，例如可以做到内存状况的监控、方法调用的监控等等，官方网站上有非常多详细的例子，我不说太多，只在下面举一个简单的例子来说明它的作用，BTrace的User Guide请见：<a href="http://kenai.com/projects/btrace/pages/UserGuide" target="_blank"><a href="http://kenai.com/projects/btrace/pages/UserGuide">http://kenai.com/projects/btrace/pages/UserGuide</a></a>。
对于运行中的Java程序，尤其是出了问题的程序，会需要跟踪其执行状况，例如传入的参数是什么、执行了多少时间，返回的对象是什么，抛出了什么异常，传统的做法只能是把程序改一遍，加上一堆log，一个例子来展示下用BTrace的情况下，怎么来跟踪一个方法的执行时间：
@BTrace public class MethodResponseTime {</p>
<pre><code>@TLS private static long startTime;

@OnMethod(clazz=&quot;类名&quot;,method=&quot;方法名&quot;)
public static void onCall(){
    println(&quot;enter this method&quot;);
    startTime=timeMillis();
}

@OnMethod(clazz=&quot;类名&quot;,method=&quot;方法名&quot;,location=@Location(Kind.RETURN))
public static void onReturn(){
    println(&quot;method end!&quot;);
    println(strcat(&quot;Time taken ms&quot;,str(timeMillis()-startTime)));
}
</code></pre><p>}
用btrace执行上面的代码，就可以动态的监控任意的目前运行的Java程序中某类的某方法的执行时间，执行上面代码的方式如下（jdk 6+）：
btrace [pid] MethodResponseTime.class
还有例如获取调用参数、调用者的对象实例以及返回值等请参看User Guide。
btrace为了保持JVM运行的安全性，因此做了很多的限制，例如不能抛出异常、修改传入的参数的值、修改返回值等，基本是一个只读的动态分析代码运行状况的工具，但仍然是非常的有用，其实现机制是attach api + asm +  instrumentation。</p>
<p>posted on 2009-10-10 12:41 <a href="http://www.blogjava.net/BlueDavy/" target="_blank">BlueDavy</a> 阅读(11121) <a href="">评论(8)</a>  <a href="http://www.blogjava.net/BlueDavy/admin/EditPosts.aspx?postid=297661" target="_blank">编辑</a>  <a href="http://www.blogjava.net/BlueDavy/AddToFavorite.aspx?id=297661" target="_blank">收藏</a> 所属分类: <a href="http://www.blogjava.net/BlueDavy/category/1366.html" target="_blank">Java</a></p>
<p> <img src="" alt=""></p>
<p><a href=""></a> <a href=""></a></p>
<p>[</p>
<h3 id="-">评论</h3>
<p>]()</p>
<h3 id="-permalink-re-java-btrace-re-java-btrace-2009-10-10-14-02-argan-http-argan-javaeye-com-"><a href=""></a><a href="&quot;permalink: re: 动态跟踪Java代码的执行状况工具--BTrace&quot;">/#</a> <a href=""></a>re: 动态跟踪Java代码的执行状况工具--BTrace  2009-10-10 14:02  <a href="http://argan.javaeye.com/">argan</a></h3>
<p>不错，这个有点强悍的，使用一下先  <a href="">回复</a>  <a href="http://www.blogjava.net/comment?author=argan" title="查看该作者发表过的评论" target="_blank">更多评论</a> <a href=""></a>  <a href=""></a></p>
<h3 id="-permalink-re-java-btrace-re-java-btrace-2009-10-11-01-02-http-www-blogjava-net-unmi-"><a href="&quot;permalink: re: 动态跟踪Java代码的执行状况工具--BTrace&quot;">/#</a> <a href=""></a>re: 动态跟踪Java代码的执行状况工具--BTrace  2009-10-11 01:02  <a href="http://www.blogjava.net/Unmi/">隔叶黄莺</a></h3>
<p>收藏了，以后可能用得着。  <a href="">回复</a>  <a href="http://www.blogjava.net/comment?author=%e9%9a%94%e5%8f%b6%e9%bb%84%e8%8e%ba" title="查看该作者发表过的评论" target="_blank">更多评论</a> <a href=""></a>  <a href=""></a></p>
<h3 id="-permalink-re-java-btrace-re-java-btrace-2009-10-11-23-28-http-www-blogjava-net-youxia-"><a href="&quot;permalink: re: 动态跟踪Java代码的执行状况工具--BTrace[未登录]&quot;">/#</a> <a href=""></a>re: 动态跟踪Java代码的执行状况工具--BTrace[未登录]  2009-10-11 23:28  <a href="http://www.blogjava.net/youxia">海边沫沫</a></h3>
<p>要钱吗?  <a href="">回复</a>  <a href="http://www.blogjava.net/comment?author=%e6%b5%b7%e8%be%b9%e6%b2%ab%e6%b2%ab" title="查看该作者发表过的评论" target="_blank">更多评论</a> <a href=""></a>  <a href=""></a></p>
<h3 id="-permalink-re-java-btrace-re-java-btrace-2009-10-12-03-54-duguo-http-duguo-com-"><a href="&quot;permalink: re: 动态跟踪Java代码的执行状况工具--BTrace&quot;">/#</a> <a href=""></a>re: 动态跟踪Java代码的执行状况工具--BTrace  2009-10-12 03:54  <a href="http://duguo.com/">duguo</a></h3>
<p>试了一下trace Apache Felix 2.0.0, 已加载了的类不好使，抛出NullPointerException。  <a href="">回复</a>  <a href="http://www.blogjava.net/comment?author=duguo" title="查看该作者发表过的评论" target="_blank">更多评论</a> <a href=""></a>  <a href=""></a></p>
<h3 id="-permalink-re-java-btrace-re-java-btrace-2009-10-12-17-12-weager-http-www-blogjava-net-dongritengfei-"><a href="&quot;permalink: re: 动态跟踪Java代码的执行状况工具--BTrace&quot;">/#</a> <a href=""></a>re: 动态跟踪Java代码的执行状况工具--BTrace  2009-10-12 17:12  <a href="http://www.blogjava.net/dongritengfei/">weager</a></h3>
<p>貌似没有什么界面，还得用命令行啊~~~  <a href="">回复</a>  <a href="http://www.blogjava.net/comment?author=weager" title="查看该作者发表过的评论" target="_blank">更多评论</a> <a href=""></a>  <a href=""></a></p>
<h3 id="-permalink-re-java-btrace-re-java-btrace-2009-10-13-00-13-gengmao-"><a href="&quot;permalink: re: 动态跟踪Java代码的执行状况工具--BTrace&quot;">/#</a> <a href=""></a>re: 动态跟踪Java代码的执行状况工具--BTrace  2009-10-13 00:13  <a href="">gengmao</a></h3>
<p>visualvm有btrace的插件  <a href="">回复</a>  <a href="http://www.blogjava.net/comment?author=gengmao" title="查看该作者发表过的评论" target="_blank">更多评论</a> <a href=""></a>  <a href=""></a></p>
<h3 id="-permalink-re-java-btrace-re-java-btrace-2009-10-13-00-57-sswv-http-blog-linjian-org-"><a href="&quot;permalink: re: 动态跟踪Java代码的执行状况工具--BTrace&quot;">/#</a> <a href=""></a>re: 动态跟踪Java代码的执行状况工具--BTrace  2009-10-13 00:57  <a href="http://blog.linjian.org/">sswv</a></h3>
<p>林昊朋友，你好，
首先祝贺你的blog被ZDNet评为了“最受欢迎中国技术博客”之一。
不过你的照片……不知你弄错了还是ZDNet弄错了，是我的头像呵。
详情参考： <a href="http://blog.linjian.org/articles/my-photo-misused-again/" target="_blank"><a href="http://blog.linjian.org/articles/my-photo-misused-again/">http://blog.linjian.org/articles/my-photo-misused-again/</a></a>
有机会看看你写的书。我前不久也与博文视点合作过，是《我是一只IT小小鸟》的合作者之一。  <a href="">回复</a>  <a href="http://www.blogjava.net/comment?author=sswv" title="查看该作者发表过的评论" target="_blank">更多评论</a> <a href=""></a>  <a href=""></a></p>
<h3 id="-permalink-re-java-btrace-re-java-btrace-2009-10-13-08-13-bluedavy-http-www-blogjava-net-bluedavy-"><a href="&quot;permalink: re: 动态跟踪Java代码的执行状况工具--BTrace[未登录]&quot;">/#</a> <a href=""></a>re: 动态跟踪Java代码的执行状况工具--BTrace[未登录]<a href=""></a>  2009-10-13 08:13  <a href="http://www.blogjava.net/bluedavy" target="_blank">BlueDavy</a></h3>
<p>@sswv
...我并不知道ZDNET评选这件事情，我联系下他们吧，不好意思了，<IT小小鸟>可是现在相当火的书，非常恭喜。
  <a href="">回复</a>  <a href="http://www.blogjava.net/comment?author=BlueDavy" title="查看该作者发表过的评论" target="_blank">更多评论</a> <a href=""></a>  <a href=""></a>
<a href="http://www.blogjava.net/RequireRegister.aspx" target="_blank">新用户注册</a>  <a href="">刷新评论列表</a>  </p>
<p><a href=""></a> <a href="http://www.aliyun.com/cps/channel?channel_id=1306&amp;user=0&amp;lv=1">推荐购买云服务器（15%返利+最高千元奖金）</a>   <a href="http://www.cnblogs.com/" target="_blank">博客园</a>  <a href="http://q.cnblogs.com/" target="_blank">博问</a>  <a href="http://news.cnblogs.com/" target="_blank">IT新闻</a>  <a href="http://job.cnblogs.com/cate-java_programmer/" target="_blank">Java程序员招聘</a> 标题  请输入标题 姓名  请输入你的姓名 主页 请输入验证码 验证码 /*  <img src="http://www.blogjava.net/Modules/CaptchaImage/JpegImage.aspx?cacheid=20130727130706" alt=""> 内容(请不要发表任何与政治相关的内容) 请输入评论内容 Remember Me?   <a href="http://www.blogjava.net/login.aspx?ReturnURL=http://www.blogjava.net/BlueDavy/archive/2009/10/10/297661.html&amp;SourceURL=/BlueDavy/archive/2009/10/10/297661.html" target="_blank">登录</a>       [使用Ctrl+Enter键可以直接提交]      网站导航:</p>
<p><a href="http://www.cnblogs.com/" title="程序员的网上家园" target="_blank">博客园</a>   <a href="http://news.cnblogs.com/" target="_blank">IT新闻</a>   <a href="http://kb.cnblogs.com/" target="_blank">知识库</a>   <a href="http://www.cppblog.com/" target="_blank">C++博客</a>   <a href="http://job.cnblogs.com/" target="_blank">程序员招聘</a>   <a href="http://www.blogjava.net/BlueDavy/archive/2009/10/10/297661.html?opt=admin" target="_blank">管理</a> 相关文章:</p>
<ul>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2010/05/25/321796.html" target="_blank">关于《分布式Java应用：基础与实践》一书</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2010/04/30/319794.html" target="_blank">杭州程序员圆桌交流第二期视频</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2010/03/22/316148.html" target="_blank">第一次杭州程序员交流会总结</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2010/03/19/315989.html" target="_blank">杭州程序员圆桌交流第一期–并发编程PPT</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/12/03/304597.html" target="_blank">GCLogViewer(tool to visualize gc log) V0.2 Release</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/11/25/303662.html" target="_blank">Simple Scala actor Vs java Thread Vs Kilim Test</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/11/06/301448.html" target="_blank">《构建高性能的大型分布式Java应用》目录&amp;试读样章</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/10/10/297661.html" target="_blank">动态跟踪Java代码的执行状况工具--BTrace</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/10/09/297562.html" target="_blank">GC策略的调优</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/08/06/290003.html" target="_blank">Hessian 3.2.0的两个bug</a><br>Powered by: <a href="http://www.blogjava.net/" target="_blank">BlogJava</a> Copyright © BlueDavy<h3 id="-">公告</h3>
</li>
</ul>
<p><a href="http://www.douban.com/subject/3843896/" target="_blank"><img src="" alt=""></a> 
<a href="http://china.osgiusers.org/" target="_blank"><img src="" alt=""></a>
<a href="http://feed.feedsky.com/bluedavy" title="BlogJava-BlueDavy之技术Blog" target="_blank"><img src="" alt=""></a> <a href="http://feed.feedsky.com/bluedavy" target="_blank"><img src="" alt="feedsky"></a>
<a href="http://www.zhuaxia.com/add_channel.php?url=http://feed.feedsky.com/bluedavy" target="_blank"><img src="" alt="抓虾"></a>
<a href="http://fusion.google.com/add?feedurl=http://feed.feedsky.com/bluedavy" target="_blank"><img src="" alt="google reader"></a>
<a href="http://www.xianguo.com/subscribe.php?url=http://feed.feedsky.com/bluedavy" target="_blank"><img src="" alt="鲜果"></a></p>
<h3 id="-">导航</h3>
<ul>
<li><a href="http://www.blogjava.net/" target="_blank">BlogJava</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/" target="_blank">首页</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/admin/EditPosts.aspx?opt=1" target="_blank">新随笔</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/contact.aspx?id=1" target="_blank">联系</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/rss" target="_blank">聚合</a><a href="http://www.blogjava.net/BlueDavy/rss" target="_blank"><img src="" alt=""></a></li>
<li><a href="http://www.blogjava.net/BlueDavy/admin/EditPosts.aspx" target="_blank">管理</a>
<a href="&quot;转到上一个月&quot;">&lt;</a>2009年10月<a href="&quot;转到下一个月&quot;">&gt;</a>日一二三四五六2728293012345678<a href="http://www.blogjava.net/BlueDavy/archive/2009/10/09.html" target="_blank">9</a><a href="http://www.blogjava.net/BlueDavy/archive/2009/10/10.html" target="_blank">10</a>1112131415161718192021222324252627282930311234567</li>
</ul>
<h3 id="-">统计</h3>
<ul>
<li>随笔 - 294</li>
<li>文章 - 2</li>
<li>评论 - 2068</li>
<li>引用 - 1</li>
</ul>
<h3 id="-">随笔分类</h3>
<ul>
<li><a href="http://www.blogjava.net/BlueDavy/category/10609.html" target="_blank">@RIAWork(10)</a> <a href="http://www.blogjava.net/BlueDavy/category/10609.html/rss" title="Subscribe to @RIAWork(10)" target="_blank">(rss)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/category/32839.html" target="_blank">Internet(20)</a> <a href="http://www.blogjava.net/BlueDavy/category/32839.html/rss" title="Subscribe to Internet(20)" target="_blank">(rss)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/category/1366.html" target="_blank">Java(82)</a> <a href="http://www.blogjava.net/BlueDavy/category/1366.html/rss" title="Subscribe to Java(82)" target="_blank">(rss)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/category/8127.html" target="_blank">Javascript(7)</a> <a href="http://www.blogjava.net/BlueDavy/category/8127.html/rss" title="Subscribe to Javascript(7)" target="_blank">(rss)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/category/18356.html" target="_blank">OSGi、SOA、SCA(81)</a> <a href="http://www.blogjava.net/BlueDavy/category/18356.html/rss" title="Subscribe to OSGi、SOA、SCA(81)" target="_blank">(rss)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/category/1514.html" target="_blank">Plugin Architecture(10)</a> <a href="http://www.blogjava.net/BlueDavy/category/1514.html/rss" title="Subscribe to Plugin Architecture(10)" target="_blank">(rss)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/category/1513.html" target="_blank">Workflow(4)</a> <a href="http://www.blogjava.net/BlueDavy/category/1513.html/rss" title="Subscribe to Workflow(4)" target="_blank">(rss)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/category/11559.html" target="_blank">业界随想(28)</a> <a href="http://www.blogjava.net/BlueDavy/category/11559.html/rss" title="Subscribe to 业界随想(28)" target="_blank">(rss)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/category/22527.html" target="_blank">数据集成(8)</a> <a href="http://www.blogjava.net/BlueDavy/category/22527.html/rss" title="Subscribe to 数据集成(8)" target="_blank">(rss)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/category/1911.html" target="_blank">系统设计(38)</a> <a href="http://www.blogjava.net/BlueDavy/category/1911.html/rss" title="Subscribe to 系统设计(38)" target="_blank">(rss)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/category/1367.html" target="_blank">软件工程(22)</a> <a href="http://www.blogjava.net/BlueDavy/category/1367.html/rss" title="Subscribe to 软件工程(22)" target="_blank">(rss)</a></li>
</ul>
<h3 id="-">随笔档案</h3>
<ul>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2010/05.html" target="_blank">2010年5月 (3)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2010/04.html" target="_blank">2010年4月 (4)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2010/03.html" target="_blank">2010年3月 (3)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2010/02.html" target="_blank">2010年2月 (1)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2010/01.html" target="_blank">2010年1月 (2)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/12.html" target="_blank">2009年12月 (1)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/11.html" target="_blank">2009年11月 (3)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/10.html" target="_blank">2009年10月 (2)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/09.html" target="_blank">2009年9月 (2)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/08.html" target="_blank">2009年8月 (2)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/07.html" target="_blank">2009年7月 (3)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/06.html" target="_blank">2009年6月 (1)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/05.html" target="_blank">2009年5月 (4)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/04.html" target="_blank">2009年4月 (5)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/03.html" target="_blank">2009年3月 (5)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/01.html" target="_blank">2009年1月 (1)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2008/11.html" target="_blank">2008年11月 (3)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2008/10.html" target="_blank">2008年10月 (1)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2008/09.html" target="_blank">2008年9月 (2)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2008/08.html" target="_blank">2008年8月 (1)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2008/07.html" target="_blank">2008年7月 (4)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2008/06.html" target="_blank">2008年6月 (4)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2008/05.html" target="_blank">2008年5月 (3)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2008/04.html" target="_blank">2008年4月 (1)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2008/03.html" target="_blank">2008年3月 (3)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2008/02.html" target="_blank">2008年2月 (1)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2008/01.html" target="_blank">2008年1月 (10)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2007/12.html" target="_blank">2007年12月 (2)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2007/11.html" target="_blank">2007年11月 (2)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2007/10.html" target="_blank">2007年10月 (6)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2007/09.html" target="_blank">2007年9月 (2)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2007/08.html" target="_blank">2007年8月 (4)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2007/07.html" target="_blank">2007年7月 (5)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2007/06.html" target="_blank">2007年6月 (2)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2007/05.html" target="_blank">2007年5月 (4)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2007/04.html" target="_blank">2007年4月 (2)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2007/03.html" target="_blank">2007年3月 (2)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2007/02.html" target="_blank">2007年2月 (2)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2007/01.html" target="_blank">2007年1月 (1)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/12.html" target="_blank">2006年12月 (6)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/11.html" target="_blank">2006年11月 (5)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/10.html" target="_blank">2006年10月 (8)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/09.html" target="_blank">2006年9月 (13)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/08.html" target="_blank">2006年8月 (15)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/07.html" target="_blank">2006年7月 (3)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/06.html" target="_blank">2006年6月 (7)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/05.html" target="_blank">2006年5月 (9)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/04.html" target="_blank">2006年4月 (12)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/03.html" target="_blank">2006年3月 (13)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/02.html" target="_blank">2006年2月 (9)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/01.html" target="_blank">2006年1月 (14)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2005/12.html" target="_blank">2005年12月 (11)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2005/11.html" target="_blank">2005年11月 (14)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2005/10.html" target="_blank">2005年10月 (9)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2005/09.html" target="_blank">2005年9月 (10)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2005/08.html" target="_blank">2005年8月 (5)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2005/07.html" target="_blank">2005年7月 (9)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2005/06.html" target="_blank">2005年6月 (9)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2005/05.html" target="_blank">2005年5月 (2)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2005/02.html" target="_blank">2005年2月 (1)</a></li>
</ul>
<h3 id="-">文章档案</h3>
<ul>
<li><a href="http://www.blogjava.net/BlueDavy/archives/2005/05.html" target="_blank">2005年5月 (2)</a></li>
</ul>
<h3 id="blogger-s">Blogger&#39;s</h3>
<ul>
<li><a href="http://www.dbanotes.net/" target="_blank">DBANotes</a></li>
<li>大名鼎鼎了，勿需多说</li>
<li><a href="http://www.esbzone.net/" target="_blank">ESBZone</a> <a href="http://www.esbzone.net/feed" title="Subscribe to ESBZone" target="_blank">(rss)</a></li>
<li>SOA实战者，强烈推荐</li>
<li><a href="http://kenwublog.com/" target="_blank">kenwu&#39;s blog[推荐]</a> <a href="http://feed.kenwublog.com/" title="Subscribe to kenwu&#39;s blog[推荐]" target="_blank">(rss)</a></li>
<li>Java底层和JVM的很多文章，强烈推荐。</li>
<li><a href="http://dreamhead.blogbus.com/" target="_blank">梦想风暴</a></li>
<li><a href="http://www.blogjava.net/cenwenchu/" target="_blank">西湖边的穷秀才</a></li>
</ul>
<h3 id="-">搜索</h3>
<p>*</p>
<ul>
<li></li>
</ul>
<h3 id="-http-www-blogjava-net-bluedavy-commentsrss-aspx-">最新评论 <a href="http://www.blogjava.net/BlueDavy/CommentsRSS.aspx" target="_blank"><img src="" alt=""></a></h3>
<ul>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2013/07/19/321796.html#401750" target="_blank">1. re: 关于《分布式Java应用：基础与实践》一书</a></li>
<li>博主 大神啊 这个博客很久没有更新了</li>
<li>--1836567962@qq.com</li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2013/07/11/267970.html#401444" target="_blank">2. re: 网站架构相关PPT、文章整理（更新于2009-7-15）</a></li>
<li>这个文章很有用，收藏</li>
<li>--度哥网</li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2013/05/28/267968.html#399877" target="_blank">3. re: OSGi Opendoc &amp; Book</a></li>
<li>评论内容较长,点击标题查看</li>
<li>--stono</li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2013/05/28/267968.html#399865" target="_blank">4. re: OSGi Opendoc &amp; Book</a></li>
<li>我再看《OSGi》原理与最佳实践，可是源码没有办法下载呀；
有没有什么办法呢？</li>
<li>--stono</li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2013/05/27/321796.html#399801" target="_blank">5. re: 关于《分布式Java应用：基础与实践》一书</a></li>
<li>在这篇blog中放置了我收集的一些网站架构相关的PPT和文章</li>
<li>--色都</li>
</ul>
<h3 id="-">阅读排行榜</h3>
<ul>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2008/09/03/226749.html" target="_blank">1. 大型网站架构演变和知识体系(57638)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/04/28/267970.html" target="_blank">2. 网站架构相关PPT、文章整理（更新于2009-7-15）(38732)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/03/27/37582.html" target="_blank">3. Hibernate实践(31780)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2005/06/13/6037.html" target="_blank">4. 系统设计说明书(架构、概要、详细)目录结构(24258)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/08/25/65741.html" target="_blank">5. 发布《OSGi实战》正式版(17725)</a></li>
</ul>
<h3 id="-">评论排行榜</h3>
<ul>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2008/09/03/226749.html" target="_blank">1. 大型网站架构演变和知识体系(96)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2005/09/07/12340.html" target="_blank">2. 漫谈CMS(88)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2009/04/28/267970.html" target="_blank">3. 网站架构相关PPT、文章整理（更新于2009-7-15）(66)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2007/09/29/149631.html" target="_blank">4. 《OSGi进阶》预览版发布(59)</a></li>
<li><a href="http://www.blogjava.net/BlueDavy/archive/2006/08/25/65741.html" target="_blank">5. 发布《OSGi实战》正式版(54)</a></li>
</ul>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/JVM/">JVM</a></li></span></span> | <span class="tags">Tagged <a href="/tags/JVM/" class="label label-primary">JVM</a><a href="/tags/Java&J2EE/" class="label label-success">Java&J2EE</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:42"datetime="2014-03-07 09:54:42"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-JVM--动态跟踪Java代码的执行状况工具--BTrace/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-JVM--动态跟踪Java代码的执行状况工具--BTrace" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--学习JVM的References/">学习JVM的References</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:42.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--学习JVM的References/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-jvm-references">学习JVM的References</h1>
<h1 id="-bluedavy-blog-https-blog-bluedavy-com-"><a href="https://blog.bluedavy.com/" target="_blank">BlueDavy之技术blog</a></h1>
<p>{互联网，OSGi，Java, High Scalability, High Performance,HA}</p>
<ul>
<li><a href="https://blog.bluedavy.com/" target="_blank">Home</a></li>
<li><a href="https://blog.bluedavy.com/?page_id=2" target="_blank">About</a></li>
<li><a href="https://blog.bluedavy.com/?page_id=81" target="_blank">Photos</a></li>
</ul>
<h2 id="-jvm-references-https-blog-bluedavy-com-p-187-jvm-references-"><a href="https://blog.bluedavy.com/?p=187" title="学习JVM的References" target="_blank">学习JVM的References</a></h2>
<p>Nov 16</p>
<p><a href="http://bluedavy.com/" title="Visit bluedavy’s website" target="_blank">bluedavy</a><a href="https://blog.bluedavy.com/?cat=13" title="View all posts in jvm" target="_blank">jvm</a> <a href="https://blog.bluedavy.com/?tag=jvm" target="_blank">jvm</a>, <a href="https://blog.bluedavy.com/?tag=references" target="_blank">references</a> <a href="&quot;Comment on 学习JVM的References&quot;">15 Comments</a>
本blog中列举了我学习JVM的references，会不断的更新，为了避免版权问题，就不在blog上提供references的下载了，感兴趣的同学可自行下载或购买，:)
大多数的论文可从此下载：<a href="http://citeseer.ist.psu.edu/index.jsp" target="_blank"><a href="http://citeseer.ist.psu.edu/index.jsp">http://citeseer.ist.psu.edu/index.jsp</a></a>
同时推荐@rednaxelafx 整理的jvm的参考资料：<a href="http://goo.gl/oXmRQ" target="_blank"><a href="http://goo.gl/oXmRQ">http://goo.gl/oXmRQ</a></a></p>
<p>References
  |— Towards a Renaissance VM
  |— Oracle JRockit The Definitive Guide
  |— JVM Magic
  |— JAVA虚拟机中文第二版
  |— Java Lang Spec 3.0
  |— Inside Out A Modern Virtual Machine Revealed
  |— Hotspot Overview
  |— Azul’s JVM experiences
  |— A Crash Course in Modern Hardware
  |— [ adaptive ]
        |— Understanding Adaptive Runtimes
        |— Adaptive Optimization of Java Real-time
        |— Adaptive Optimization in the Jalapeno JVM
  |— [ compiler ]
        |— The Java HotSpotTM Server Compiler
        |— Tailoring Graph-coloring Register Allocation For Runtime Compilation
        |— Linear Scan Register Allocation
        |— Design of the Java HotSpotTM Client Compiler for Java 6
  |— [ concurrent ]
        |— The.Art.of.Multiprocessor.Programming.Mar.2008
        |— The Concurrency Revolution The Hardware Story
        |— Multithreaded Programming Guide
        |— JVM Continuations
        |— java.util.concurrent Synchronizer Framework
        |— Java Concurrency Gotchas
        |— Groovy and Concurrency
        |— concurrent programming without locks
        |— Concurrency Grab Bag
        |— Alternative Concurrency Paradigms For the JVM
        |— Accelerating Java Workloads via GPUs
        |— A Scalable Lockfree Stack Algorithm
        |— A Concurrent Dynamic Analysis Framework
  |— [ io ]
        |— Asynchronous IO Tricks and Tips
  |— [ memory management ]
        |— Tuning Java Memory Manager
        |— The Ghost in the Virtual Machine A Reference to References
        |— The Garbage Collection Mythbusters
        |— SuperSizingJava
        |— Step by Step GC Tuning in the HotSpot Java Virtual Machine
        |— parallel gc ppt
        |— Oracle JDBC Memory Management
        |— NUMA-Aware-Java-Heaps-for-Server-Applications
        |— memorymanagement_whitepaper
        |— markcompact_gc ppt
        |— Leak Pruning
        |— GC Vs Explicit MM
        |— GC Tuning in the hotspot
        |— Garbage Collection and Memory Architecture
        |— Garbage Collection Algorithms For Automatic Dynamic Memory Management – Richard Jones
        |— [ Hotspot GC论文 ]
              |— Parallel Garbage Collection for Shared Memory Multiprocessors
              |— Garbage First Garbage Collector
              |— A Generational Mostly-concurrent Garbage Collector
        |— [ 其他JVM GC ]
              |— The pauseless gc
              |— Immix A Mark-Region Garbage Collector
              |— How to write a distributed gc
              |— GC Nirvana High Throughput And Low Latency Together
  |— [ monitoring and profiling ]
        |— Where Does All the Native Memory Go
        |— What’s Happening with My Application JVM Monitoring Tool
        |— Practical Lessons in Memory Analysis
        |— MonitoringGuide
        |— Microarchitectural Characterization of Production JVMs and JavaWorkloads
        |— Going Beyond Memory Leaks Debugging Java from Dumps, Using Memory Analyzer
        |— Diagnosing and Fixing Memory Leaks in Web Applications Tips from the Front Line
  |— [ osrelated ]
        |— poll-epoll_2
        |— poll-epoll_1
        |— memory systems
        |— Linux内核源代码情景分析
        |— linux_cpu_scheduler
        |— Linux 内核中断内幕
        |— Linux System and Performance Monitoring
        |— cpumemory
  |— [ performance ]
        |— Towards Performance Measurements for the Java Virtual Machine’s invokedynamic
        |— Thinking clearly about performance
        |— The Impact of Performance Asymmetry in Emerging Multicore Architectures
        |— the art of benchmarking
        |— Techniques for Obtaining High Performance in Java Programs
        |— Pipelining for Performance
        |— Performance myths and legends
        |— Performance Java Versus C
        |— How to Tune and Write Low-Latency Applications on the Java Virtual Machine
        |— How to Get the Most Performance from Sun JVM on Intel? Multi-Core Servers
        |— Comparing the Performance of Web Server Arch
        |— A Common API for Measuring Performance</p>
<p><a href="https://blog.bluedavy.com/?p=185" target="_blank">BTrace使用简介</a> <a href="https://blog.bluedavy.com/?p=198" target="_blank">JRockit读书笔记I — Java代码的高效执行</a></p>
<h3 id="15-comments-add-yours-">15 Comments <em>(<a href="">+add yours?</a>)</em></h3>
<ol>
<li><img src="https://secure.gravatar.com/avatar/e7a7df93e0364af10fd5bd942fd81f56?s=48&amp;d=&lt;path_to_url&gt;&amp;r=G" alt=""> <a href="http://blog.csdn.net/yang_net" target="_blank">yangwm</a>
<strong>Nov 16, 2010</strong> @ 20:34:17
顶！</li>
<li><img src="" alt=""> <a href="http://www.helishi.net/" target="_blank">ikbear</a>
<strong>Nov 16, 2010</strong> @ 21:29:26
顶！收藏了！</li>
<li><img src="https://secure.gravatar.com/avatar/37e14c958f24c5d75fb4dd926c175629?s=48&amp;d=&lt;path_to_url&gt;&amp;r=G" alt=""> <a href="http://www.ximengbao365.info/" target="_blank">ximengbao</a>
<strong>Nov 27, 2010</strong> @ 17:01:53
没人留言么 那我留一句</li>
<li><img src="https://secure.gravatar.com/avatar/d2b47d707d59207554e65aa3d3f83d18?s=48&amp;d=&lt;path_to_url&gt;&amp;r=G" alt=""> alipay_fred
<strong>Dec 03, 2010</strong> @ 20:17:48
Bohem GC 还是值得一开</li>
</ol>
<p>另外richard Jones 明年有本新书 关于GC的 期待中。。。</p>
<p>另外 今年ISMM 2011 的一些会议论文也很 insightfull</p>
<ol>
<li><img src="https://secure.gravatar.com/avatar/5267242305332fe1affd9c4788191e1d?s=48&amp;d=&lt;path_to_url&gt;&amp;r=G" alt=""> <a href="http://bluedavy.com/" target="_blank">bluedavy</a>
<strong>Dec 04, 2010</strong> @ 21:51:35
恩，感谢建议，:)</li>
<li><img src="https://secure.gravatar.com/avatar/3a190f857aef4c178e77fd9c499ba648?s=48&amp;d=&lt;path_to_url&gt;&amp;r=G" alt=""> <a href="http://www.ruyan.info/" target="_blank">如烟</a>
<strong>Dec 20, 2010</strong> @ 22:40:44
搜索过来的，这个还是挺有帮助的，谢了</li>
<li><img src="" alt=""> jilen
<strong>Jan 01, 2011</strong> @ 22:23:49
给力啊，毕玄同学</li>
<li><img src="https://secure.gravatar.com/avatar/5e07c82e4b00ec8fa41e753e43b90d97?s=48&amp;d=&lt;path_to_url&gt;&amp;r=G" alt=""> clark
<strong>Feb 11, 2011</strong> @ 14:39:54
楼主同学你好厉害啊，对于我们一般人，这些书都看完，人会不会翘掉？？</li>
<li><img src="https://secure.gravatar.com/avatar/5267242305332fe1affd9c4788191e1d?s=48&amp;d=&lt;path_to_url&gt;&amp;r=G" alt=""> <a href="http://bluedavy.com/" target="_blank">bluedavy</a>
<strong>Feb 15, 2011</strong> @ 21:34:00
哈哈，只要有兴趣，看完应该还是正常滴…</li>
<li><img src="https://secure.gravatar.com/avatar/d7159b92ad12edacca5f2a922957ec17?s=48&amp;d=&lt;path_to_url&gt;&amp;r=G" alt=""> lorb
<strong>Mar 22, 2011</strong> @ 11:28:05
赞，发现好多博客的参考链接都指到这儿
在国内这么浮躁的技术氛围中的一方净土，偶像ORZ
JVM相关的中文书籍太少，能否写一本</li>
<li><img src="https://secure.gravatar.com/avatar/aca8bd25b6ab38864dc63502766e357f?s=48&amp;d=&lt;path_to_url&gt;&amp;r=G" alt=""> milo
<strong>Jun 09, 2011</strong> @ 23:18:15
大侠，请教一个很弱智的问题，最近jboss老出现：java.lang.OutOfMemoryError: nativeGetNewTLA 错误，我想请问 nativeGetNewTLA 有什么含义，因为当我看到java.lang.OutOfMemoryError: allocLargeObjectOrArray 时，根据allocLargeObjectOrArray可大概知道是在堆上为大对象或数组对象分配空间时内存不够了，所以我想nativeGetNewTLA 应该能告诉我点什么。google 上看了很多，不理想，想请教你，另外有没有什么文档对这个OutOfMemoryError错误的各种message做个大概的说明。</li>
<li><img src="https://secure.gravatar.com/avatar/5267242305332fe1affd9c4788191e1d?s=48&amp;d=&lt;path_to_url&gt;&amp;r=G" alt=""> <a href="http://bluedavy.com/" target="_blank">bluedavy</a>
<strong>Jun 10, 2011</strong> @ 11:57:18
…这是java crash后出现的错误信息吧？
也许可以看看这个里面关于OOM的说明：<a href="http://blog.bluedavy.com/?p=200" target="_blank">http://blog.bluedavy.com/?p=200</a></li>
<li><img src="https://secure.gravatar.com/avatar/54e62b72074a55e9e404bfabb9217386?s=48&amp;d=&lt;path_to_url&gt;&amp;r=G" alt=""> cheto
<strong>Aug 18, 2011</strong> @ 13:05:15
JRocket The Definite Guide 这一类原版书要怎么才能买到？是不是要代购啊</li>
<li><img src="https://secure.gravatar.com/avatar/5267242305332fe1affd9c4788191e1d?s=48&amp;d=&lt;path_to_url&gt;&amp;r=G" alt=""> <a href="http://bluedavy.com/" target="_blank">bluedavy</a>
<strong>Aug 18, 2011</strong> @ 20:30:29
@cheto，恩，是滴，在国内没有引入影像版前，就只有代购了，或者买电子版吧。<h3 id="leave-a-reply">Leave a Reply</h3>
</li>
</ol>
<p><a href="">Cancel</a></p>
<p>Name (required)</p>
<p>Mail (required)</p>
<p>Website</p>
<p><img src="&quot;CAPTCHA Image&quot;" alt="CAPTCHA Image"></p>
<p><a href="&quot;Refresh Image&quot;"><img src="" alt="Refresh Image"></a></p>
<p>CAPTCHA Code /*</p>
<p><style type='text/css'>/#submit {display:none;}</style><br /> <input name="submit" type="submit" id="submit-alt" tabindex="6" value="Submit Comment" /></p>
<p>July 2013 M T W T F S S <a href="https://blog.bluedavy.com/?m=201303" title="View posts for March 2013" target="_blank">« Mar</a>     1234567 891011121314 15161718192021 22232425262728 293031  </p>
<h3 id="categories">Categories</h3>
<ul>
<li><a href="https://blog.bluedavy.com/?cat=63" title="View all posts filed under Java" target="_blank">Java</a> (10)</li>
<li><a href="https://blog.bluedavy.com/?cat=13" title="View all posts filed under jvm" target="_blank">jvm</a> (19)</li>
<li><a href="https://blog.bluedavy.com/?cat=56" title="View all posts filed under NoSQL" target="_blank">NoSQL</a> (7)</li>
<li><a href="https://blog.bluedavy.com/?cat=4" title="View all posts filed under SOA" target="_blank">SOA</a> (1)</li>
<li><a href="https://blog.bluedavy.com/?cat=11" title="关于《分布式Java应用：基础与实践》书部分章节的公开、书内容的纠错以及补充完善。" target="_blank">书:分布式Java应用</a> (5)</li>
<li><a href="https://blog.bluedavy.com/?cat=6" title="View all posts filed under 互联网" target="_blank">互联网</a> (5)</li>
<li><a href="https://blog.bluedavy.com/?cat=46" title="View all posts filed under 产品总结" target="_blank">产品总结</a> (1)</li>
<li><a href="https://blog.bluedavy.com/?cat=18" title="View all posts filed under 优化案例" target="_blank">优化案例</a> (1)</li>
<li><a href="https://blog.bluedavy.com/?cat=12" title="View all posts filed under 圆桌交流" target="_blank">圆桌交流</a> (2)</li>
<li><a href="https://blog.bluedavy.com/?cat=8" title="View all posts filed under 容量规划" target="_blank">容量规划</a> (2)</li>
<li><a href="https://blog.bluedavy.com/?cat=97" title="View all posts filed under 迁户口" target="_blank">迁户口</a> (1)</li>
<li><a href="https://blog.bluedavy.com/?cat=52" title="View all posts filed under 高可用" target="_blank">高可用</a> (1)</li>
<li><a href="https://blog.bluedavy.com/?cat=3" title="View all posts filed under 高并发" target="_blank">高并发</a> (3)</li>
<li><p><a href="https://blog.bluedavy.com/?cat=1" title="关于性能优化方面的一些东西。" target="_blank">高性能</a> (2)</p>
<h3 id="recent-comments">Recent Comments</h3>
</li>
<li><p><a href="http://code1.riaos.com/?p=5030138" target="_blank">JVM调优 | code1（code1.riaos.com）</a> on <a href="https://blog.bluedavy.com/?p=70&amp;cpage=1#comment-16520" target="_blank">说说MaxTenuringThreshold这个参数</a></p>
</li>
<li><a href="http://architecture1.riaos.com/?p=3063358" target="_blank">JVM调优 | architecture（riaos.com）</a> on <a href="https://blog.bluedavy.com/?p=70&amp;cpage=1#comment-16519" target="_blank">说说MaxTenuringThreshold这个参数</a></li>
<li><a href="http://bluedavy.com/" target="_blank">bluedavy</a> on <a href="https://blog.bluedavy.com/?p=409&amp;cpage=1#comment-16462" target="_blank">一个Java应用频繁抛异常导致cpu us诡异现象的案例</a></li>
<li>xiaobo on <a href="https://blog.bluedavy.com/?p=409&amp;cpage=1#comment-16460" target="_blank">一个Java应用频繁抛异常导致cpu us诡异现象的案例</a></li>
<li><a href="http://bluedavy.com/" target="_blank">bluedavy</a> on <a href="https://blog.bluedavy.com/?p=409&amp;cpage=1#comment-16459" target="_blank">一个Java应用频繁抛异常导致cpu us诡异现象的案例</a></li>
</ul>
<h3 id="tags">Tags</h3>
<p><a href="https://blog.bluedavy.com/?tag=btrace" title="2 topics" target="_blank">btrace</a> <a href="https://blog.bluedavy.com/?tag=c1" title="1 topic" target="_blank">c1</a> <a href="https://blog.bluedavy.com/?tag=c2" title="1 topic" target="_blank">c2</a> <a href="https://blog.bluedavy.com/?tag=deflater" title="1 topic" target="_blank">Deflater</a> <a href="https://blog.bluedavy.com/?tag=facebook" title="2 topics" target="_blank">facebook</a> <a href="https://blog.bluedavy.com/?tag=gc" title="4 topics" target="_blank">gc</a> <a href="https://blog.bluedavy.com/?tag=gc-tuning" title="2 topics" target="_blank">gc tuning</a> <a href="https://blog.bluedavy.com/?tag=grizzly" title="2 topics" target="_blank">Grizzly</a> <a href="https://blog.bluedavy.com/?tag=hbase" title="6 topics" target="_blank">HBase</a> <a href="https://blog.bluedavy.com/?tag=hotspot" title="1 topic" target="_blank">hotspot</a> <a href="https://blog.bluedavy.com/?tag=inflater" title="1 topic" target="_blank">Inflater</a> <a href="https://blog.bluedavy.com/?tag=interpreter" title="1 topic" target="_blank">interpreter</a> <a href="https://blog.bluedavy.com/?tag=javac" title="1 topic" target="_blank">javac</a> <a href="https://blog.bluedavy.com/?tag=java-code-generation" title="1 topic" target="_blank">java code generation</a> <a href="https://blog.bluedavy.com/?tag=javaone" title="4 topics" target="_blank">JavaOne</a> <a href="https://blog.bluedavy.com/?tag=javaone-general-technical-session" title="1 topic" target="_blank">javaone general technical session</a> <a href="https://blog.bluedavy.com/?tag=java%e4%bb%a3%e7%a0%81%e6%89%a7%e8%a1%8c" title="1 topic" target="_blank">java代码执行</a> <a href="https://blog.bluedavy.com/?tag=java-%e5%b9%b6%e5%8f%91" title="1 topic" target="_blank">Java 并发</a> <a href="https://blog.bluedavy.com/?tag=jit" title="1 topic" target="_blank">jit</a> <a href="https://blog.bluedavy.com/?tag=jvm" title="12 topics" target="_blank">jvm</a> <a href="https://blog.bluedavy.com/?tag=memory-management" title="1 topic" target="_blank">memory management</a> <a href="https://blog.bluedavy.com/?tag=native-memory-leak" title="1 topic" target="_blank">Native Memory Leak</a> <a href="https://blog.bluedavy.com/?tag=nosql" title="2 topics" target="_blank">NoSQL</a> <a href="https://blog.bluedavy.com/?tag=oom" title="1 topic" target="_blank">oom</a> <a href="https://blog.bluedavy.com/?tag=oracle-keynote" title="1 topic" target="_blank">oracle keynote</a> <a href="https://blog.bluedavy.com/?tag=pessimism-policy" title="1 topic" target="_blank">pessimism policy</a> <a href="https://blog.bluedavy.com/?tag=references" title="1 topic" target="_blank">references</a> <a href="https://blog.bluedavy.com/?tag=rpc" title="2 topics" target="_blank">RPC</a> <a href="https://blog.bluedavy.com/?tag=serial-gc" title="1 topic" target="_blank">serial gc</a> <a href="https://blog.bluedavy.com/?tag=soa" title="2 topics" target="_blank">SOA</a> <a href="https://blog.bluedavy.com/?tag=sun-jdk" title="1 topic" target="_blank">sun jdk</a> <a href="https://blog.bluedavy.com/?tag=sun-jdk-oom" title="1 topic" target="_blank">sun jdk oom</a> <a href="https://blog.bluedavy.com/?tag=web%e5%ae%b9%e9%87%8f%e8%a7%84%e5%88%92%e7%9a%84%e8%89%ba%e6%9c%af" title="1 topic" target="_blank">Web容量规划的艺术</a> <a href="https://blog.bluedavy.com/?tag=yuanzhuo" title="1 topic" target="_blank">yuanzhuo</a> <a href="https://blog.bluedavy.com/?tag=%e4%b9%a6" title="1 topic" target="_blank">书:分布式Java应用</a> <a href="https://blog.bluedavy.com/?tag=%e4%b9%a6%e8%af%84" title="1 topic" target="_blank">书评</a> <a href="https://blog.bluedavy.com/?tag=%e4%ba%92%e8%81%94%e7%bd%91%e6%8a%80%e6%9c%af" title="1 topic" target="_blank">互联网技术</a> <a href="https://blog.bluedavy.com/?tag=%e4%ba%a4%e6%b5%81" title="1 topic" target="_blank">交流</a> <a href="https://blog.bluedavy.com/?tag=%e5%86%85%e5%ad%98%e7%ae%a1%e7%90%86" title="1 topic" target="_blank">内存管理</a> <a href="https://blog.bluedavy.com/?tag=%e5%88%86%e5%b8%83%e5%bc%8fjava%e5%ba%94%e7%94%a8" title="2 topics" target="_blank">分布式Java应用</a> <a href="https://blog.bluedavy.com/?tag=%e5%9c%86%e6%a1%8c%e4%ba%a4%e6%b5%81" title="1 topic" target="_blank">圆桌交流</a> <a href="https://blog.bluedavy.com/?tag=%e5%ae%b9%e9%87%8f%e8%a7%84%e5%88%92" title="2 topics" target="_blank">容量规划</a> <a href="https://blog.bluedavy.com/?tag=%e6%82%b2%e8%a7%82%e7%ad%96%e7%95%a5" title="3 topics" target="_blank">悲观策略</a> <a href="https://blog.bluedavy.com/?tag=%e6%9c%8d%e5%8a%a1%e6%a1%86%e6%9e%b6" title="1 topic" target="_blank">服务框架</a> <a href="https://blog.bluedavy.com/?tag=%e7%a1%85%e8%b0%b7%e5%85%ac%e5%8f%b8" title="1 topic" target="_blank">硅谷公司</a></p>
<h3 id="-">订阅</h3>
<h3 id="-">推荐书籍</h3>
<h3 id="my-book">My Book</h3>
<p><a href="http://book.douban.com/subject/4848587/" title="分布式Java应用：基础与实践" target="_blank"><img src="" alt=""></a> <a href="http://book.douban.com/subject/3843896/" title="OSGi原理与最佳实践" target="_blank"><img src="" alt=""></a>
© <a href="https://blog.bluedavy.com/" target="_blank">BlueDavy之技术blog</a> 2013</p>
<p><a href="http://icondock.com/" target="_blank">Icons</a> &amp; <a href="http://www.ndesign-studio.com/wp-themes" target="_blank">Wordpress Theme</a> by <a href="http://www.ndesign-studio.com/" target="_blank">N.Design</a></p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/JVM/">JVM</a></li></span></span> | <span class="tags">Tagged <a href="/tags/JVM/" class="label label-primary">JVM</a><a href="/tags/Java&J2EE/" class="label label-success">Java&J2EE</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:42"datetime="2014-03-07 09:54:42"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-JVM--学习JVM的References/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-JVM--学习JVM的References" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--深入理解JVM/">深入理解JVM</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:42.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--深入理解JVM/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-jvm">深入理解JVM</h1>
<p><strong>1 Java技术与Java虚拟机</strong></p>
<p>说起Java，人们首先想到的是Java编程语言，然而事实上，Java是一种技术，它由四方面组成: Java编程语言、Java类文件格式、Java虚拟机和Java应用程序接口(Java API)。它们的关系如下图所示：</p>
<p><img src="" alt=""></p>
<p>图1 Java四个方面的关系</p>
<p>运行期环境代表着Java平台，开发人员编写Java代码(.java文件)，然后将之编译成字节码(.class文件)。最后字节码被装入内存，一旦字节码进入虚拟机，它就会被解释器解释执行，或者是被即时代码发生器有选择的转换成机器码执行。从上图也可以看出Java平台由Java虚拟机和 Java应用程序接口搭建，Java语言则是进入这个平台的通道，用Java语言编写并编译的程序可以运行在这个平台上。这个平台的结构如下图所示：</p>
<p><img src="" alt=""></p>
<p>在Java平台的结构中, 可以看出，Java虚拟机(JVM) 处在核心的位置，是程序与底层操作系统和硬件无关的关键。它的下方是移植接口，移植接口由两部分组成：适配器和Java操作系统, 其中依赖于平台的部分称为适配器；JVM 通过移植接口在具体的平台和操作系统上实现；在JVM 的上方是Java的基本类库和扩展类库以及它们的API， 利用Java API编写的应用程序(application) 和小程序(Java applet) 可以在任何Java平台上运行而无需考虑底层平台, 就是因为有Java虚拟机(JVM)实现了程序与操作系统的分离，从而实现了Java 的平台无关性。</p>
<p>那么到底什么是Java虚拟机(JVM)呢？通常我们谈论JVM时，我们的意思可能是：</p>
<ol>
<li><p>对JVM规范的的比较抽象的说明；</p>
</li>
<li><p>对JVM的具体实现；</p>
</li>
<li><p>在程序运行期间所生成的一个JVM实例。</p>
</li>
</ol>
<p>对JVM规范的的抽象说明是一些概念的集合，它们已经在书《The Java Virtual Machine Specification》（《Java虚拟机规范》）中被详细地描述了；对JVM的具体实现要么是软件，要么是软件和硬件的组合，它已经被许多生产厂商所实现，并存在于多种平台之上；运行Java程序的任务由JVM的运行期实例单个承担。在本文中我们所讨论的Java虚拟机(JVM)主要针对第三种情况而言。它可以被看成一个想象中的机器，在实际的计算机上通过软件模拟来实现，有自己想象中的硬件，如处理器、堆栈、寄存器等，还有自己相应的指令系统。</p>
<p>JVM在它的生存周期中有一个明确的任务，那就是运行Java程序，因此当Java程序启动的时候，就产生JVM的一个实例；当程序运行结束的时候，该实例也跟着消失了。下面我们从JVM的体系结构和它的运行过程这两个方面来对它进行比较深入的研究。</p>
<p><strong>2 Java虚拟机的体系结构</strong></p>
<p>刚才已经提到，JVM可以由不同的厂商来实现。由于厂商的不同必然导致JVM在实现上的一些不同，然而JVM还是可以实现跨平台的特性，这就要归功于设计JVM时的体系结构了。</p>
<p>我们知道，一个JVM实例的行为不光是它自己的事，还涉及到它的子系统、存储区域、数据类型和指令这些部分，它们描述了JVM的一个抽象的内部体系结构，其目的不光规定实现JVM时它内部的体系结构，更重要的是提供了一种方式，用于严格定义实现时的外部行为。每个JVM都有两种机制，一个是装载具有合适名称的类(类或是接口)，叫做类装载子系统；另外的一个负责执行包含在已装载的类或接口中的指令，叫做运行引擎。每个JVM又包括方法区、堆、 Java栈、程序计数器和本地方法栈这五个部分，这几个部分和类装载机制与运行引擎机制一起组成的体系结构图为：</p>
<p><img src="" alt=""></p>
<p>图3 JVM的体系结构</p>
<p>JVM的每个实例都有一个它自己的方法域和一个堆，运行于JVM内的所有的线程都共享这些区域；当虚拟机装载类文件的时候，它解析其中的二进制数据所包含的类信息，并把它们放到方法域中；当程序运行的时候，JVM把程序初始化的所有对象置于堆上；而每个线程创建的时候，都会拥有自己的程序计数器和 Java栈，其中程序计数器中的值指向下一条即将被执行的指令，线程的Java栈则存储为该线程调用Java方法的状态；本地方法调用的状态被存储在本地方法栈，该方法栈依赖于具体的实现。</p>
<p>下面分别对这几个部分进行说明。</p>
<p>执行引擎处于JVM的核心位置，在Java虚拟机规范中，它的行为是由指令集所决定的。尽管对于每条指令，规范很详细地说明了当JVM执行字节码遇到指令时，它的实现应该做什么，但对于怎么做却言之甚少。Java虚拟机支持大约248个字节码。每个字节码执行一种基本的CPU运算,例如,把一个整数加到寄存器,子程序转移等。Java指令集相当于Java程序的汇编语言。</p>
<p>Java指令集中的指令包含一个单字节的操作符,用于指定要执行的操作,还有0个或多个操作数,提供操作所需的参数或数据。许多指令没有操作数,仅由一个单字节的操作符构成。</p>
<p>虚拟机的内层循环的执行过程如下:</p>
<p>do{</p>
<p>取一个操作符字节;</p>
<p>根据操作符的值执行一个动作;</p>
<p>}while(程序未结束)</p>
<p>由于指令系统的简单性,使得虚拟机执行的过程十分简单,从而有利于提高执行的效率。指令中操作数的数量和大小是由操作符决定的。如果操作数比一个字节大,那么它存储的顺序是高位字节优先。例如,一个16位的参数存放时占用两个字节,其值为:</p>
<p>第一个字节/*256+第二个字节字节码。</p>
<p>指令流一般只是字节对齐的。指令tableswitch和lookup是例外,在这两条指令内部要求强制的4字节边界对齐。</p>
<p>对于本地方法接口，实现JVM并不要求一定要有它的支持，甚至可以完全没有。Sun公司实现Java本地接口(JNI)是出于可移植性的考虑，当然我们也可以设计出其它的本地接口来代替Sun公司的JNI。但是这些设计与实现是比较复杂的事情，需要确保垃圾回收器不会将那些正在被本地方法调用的对象释放掉。</p>
<p>Java的堆是一个运行时数据区,类的实例(对象)从中分配空间，它的管理是由垃圾回收来负责的:不给程序员显式释放对象的能力。Java不规定具体使用的垃圾回收算法,可以根据系统的需求使用各种各样的算法。</p>
<p>Java方法区与传统语言中的编译后代码或是Unix进程中的正文段类似。它保存方法代码(编译后的java代码)和符号表。在当前的Java实现中,方法代码不包括在垃圾回收堆中,但计划在将来的版本中实现。每个类文件包含了一个Java类或一个Java界面的编译后的代码。可以说类文件是 Java语言的执行代码文件。为了保证类文件的平台无关性,Java虚拟机规范中对类文件的格式也作了详细的说明。其具体细节请参考Sun公司的Java 虚拟机规范。</p>
<p>Java虚拟机的寄存器用于保存机器的运行状态,与微处理器中的某些专用寄存器类似。Java虚拟机的寄存器有四种:</p>
<ol>
<li><p>pc: Java程序计数器；</p>
</li>
<li><p>optop: 指向操作数栈顶端的指针；</p>
</li>
<li><p>frame: 指向当前执行方法的执行环境的指针；</p>
</li>
<li><p>vars: 指向当前执行方法的局部变量区第一个变量的指针。</p>
</li>
</ol>
<p>在上述体系结构图中，我们所说的是第一种，即程序计数器，每个线程一旦被创建就拥有了自己的程序计数器。当线程执行Java方法的时候，它包含该线程正在被执行的指令的地址。但是若线程执行的是一个本地的方法，那么程序计数器的值就不会被定义。</p>
<p>Java虚拟机的栈有三个区域:局部变量区、运行环境区、操作数区。</p>
<p><strong>局部变量区</strong></p>
<p>每个Java方法使用一个固定大小的局部变量集。它们按照与vars寄存器的字偏移量来寻址。局部变量都是32位的。长整数和双精度浮点数占据了两个局部变量的空间,却按照第一个局部变量的索引来寻址。(例如,一个具有索引n的局部变量,如果是一个双精度浮点数,那么它实际占据了索引n和n+1所代表的存储空间)虚拟机规范并不要求在局部变量中的64位的值是64位对齐的。虚拟机提供了把局部变量中的值装载到操作数栈的指令,也提供了把操作数栈中的值写入局部变量的指令。</p>
<p><strong>运行环境区</strong></p>
<p>在运行环境中包含的信息用于动态链接,正常的方法返回以及异常捕捉。</p>
<p><strong>动态链接</strong></p>
<p>运行环境包括对指向当前类和当前方法的解释器符号表的指针,用于支持方法代码的动态链接。方法的class文件代码在引用要调用的方法和要访问的变量时使用符号。动态链接把符号形式的方法调用翻译成实际方法调用,装载必要的类以解释还没有定义的符号,并把变量访问翻译成与这些变量运行时的存储结构相应的偏移地址。动态链接方法和变量使得方法中使用的其它类的变化不会影响到本程序的代码。</p>
<p><strong>正常的方法返回</strong></p>
<p>如果当前方法正常地结束了,在执行了一条具有正确类型的返回指令时,调用的方法会得到一个返回值。执行环境在正常返回的情况下用于恢复调用者的寄存器,并把调用者的程序计数器增加一个恰当的数值,以跳过已执行过的方法调用指令,然后在调用者的执行环境中继续执行下去。</p>
<p><strong>异常捕捉</strong></p>
<p>异常情况在Java中被称作Error(错误)或Exception(异常),是Throwable类的子类,在程序中的原因是:①动态链接错,如无法找到所需的class文件。②运行时错,如对一个空指针的引用。程序使用了throw语句。</p>
<p>当异常发生时,Java虚拟机采取如下措施:</p>
<p>· 检查与当前方法相联系的catch子句表。每个catch子句包含其有效指令范围,能够处理的异常类型,以及处理异常的代码块地址。</p>
<p>· 与异常相匹配的catch子句应该符合下面的条件:造成异常的指令在其指令范围之内,发生的异常类型是其能处理的异常类型的子类型。如果找到了匹配的catch子句,那么系统转移到指定的异常处理块处执行;如果没有找到异常处理块,重复寻找匹配的catch子句的过程,直到当前方法的所有嵌套的 catch子句都被检查过。</p>
<p>· 由于虚拟机从第一个匹配的catch子句处继续执行,所以catch子句表中的顺序是很重要的。因为Java代码是结构化的,因此总可以把某个方法的所有的异常处理器都按序排列到一个表中,对任意可能的程序计数器的值,都可以用线性的顺序找到合适的异常处理块,以处理在该程序计数器值下发生的异常情况。</p>
<p>· 如果找不到匹配的catch子句,那么当前方法得到一个&quot;未截获异常&quot;的结果并返回到当前方法的调用者,好像异常刚刚在其调用者中发生一样。如果在调用者中仍然没有找到相应的异常处理块,那么这种错误将被传播下去。如果错误被传播到最顶层,那么系统将调用一个缺省的异常处理块。</p>
<p><strong>操作数栈区</strong></p>
<p>机器指令只从操作数栈中取操作数,对它们进行操作,并把结果返回到栈中。选择栈结构的原因是:在只有少量寄存器或非通用寄存器的机器(如 Intel486)上,也能够高效地模拟虚拟机的行为。操作数栈是32位的。它用于给方法传递参数,并从方法接收结果,也用于支持操作的参数,并保存操作的结果。例如,iadd指令将两个整数相加。相加的两个整数应该是操作数栈顶的两个字。这两个字是由先前的指令压进堆栈的。这两个整数将从堆栈弹出、相加,并把结果压回到操作数栈中。</p>
<p>每个原始数据类型都有专门的指令对它们进行必须的操作。每个操作数在栈中需要一个存储位置,除了long和double型,它们需要两个位置。操作数只能被适用于其类型的操作符所操作。例如,压入两个int类型的数,如果把它们当作是一个long类型的数则是非法的。在Sun的虚拟机实现中,这个限制由字节码验证器强制实行。但是,有少数操作(操作符dupe和swap),用于对运行时数据区进行操作时是不考虑类型的。</p>
<p>本地方法栈，当一个线程调用本地方法时，它就不再受到虚拟机关于结构和安全限制方面的约束，它既可以访问虚拟机的运行期数据区，也可以使用本地处理器以及任何类型的栈。例如，本地栈是一个C语言的栈，那么当C程序调用C函数时，函数的参数以某种顺序被压入栈，结果则返回给调用函数。在实现Java虚拟机时，本地方法接口使用的是C语言的模型栈，那么它的本地方法栈的调度与使用则完全与C语言的栈相同。</p>
<p><strong>3 Java虚拟机的运行过程</strong></p>
<p>上面对虚拟机的各个部分进行了比较详细的说明，下面通过一个具体的例子来分析它的运行过程。</p>
<p>虚拟机通过调用某个指定类的方法main启动，传递给main一个字符串数组参数，使指定的类被装载，同时链接该类所使用的其它的类型，并且初始化它们。例如对于程序：</p>
<p>class HelloApp</p>
<p>{</p>
<p>public static void main(String[] args)</p>
<p>{</p>
<p>System.out.println(&quot;Hello World!&quot;);</p>
<p>for (int i = 0; i &lt; args.length; i++ )</p>
<p>{</p>
<p>System.out.println(args[i]);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>编译后在命令行模式下键入： java HelloApp run virtual machine</p>
<p>将通过调用HelloApp的方法main来启动java虚拟机，传递给main一个包含三个字符串&quot;run&quot;、&quot;virtual&quot;、&quot;machine&quot;的数组。现在我们略述虚拟机在执行HelloApp时可能采取的步骤。</p>
<p>开始试图执行类HelloApp的main方法，发现该类并没有被装载，也就是说虚拟机当前不包含该类的二进制代表，于是虚拟机使用 ClassLoader试图寻找这样的二进制代表。如果这个进程失败，则抛出一个异常。类被装载后同时在main方法被调用之前，必须对类 HelloApp与其它类型进行链接然后初始化。链接包含三个阶段：检验，准备和解析。检验检查被装载的主类的符号和语义，准备则创建类或接口的静态域以及把这些域初始化为标准的默认值，解析负责检查主类对其它类或接口的符号引用，在这一步它是可选的。类的初始化是对类中声明的静态初始化函数和静态域的初始化构造方法的执行。一个类在初始化之前它的父类必须被初始化。整个过程如下：
<img src="" alt=""></p>
<p>图4：虚拟机的运行过程</p>
<p><strong>4 结束语</strong></p>
<p>本文通过对JVM的体系结构的深入研究以及一个Java程序执行时虚拟机的运行过程的详细分析，意在剖析清楚Java虚拟机的机理。</p>
<h1 id="-jvm-http-www-javaeye-com-wiki-jvm-2905-jvm-"><a href=""></a><a href="http://www.javaeye.com/wiki/jvm/2905-JVM">慢慢琢磨JVM</a></h1>
<h2 id="-1-jvm-"><a href=""></a>1 JVM简介</h2>
<p>JVM是我们Javaer的最基本功底了，刚开始学Java的时候，一般都是从“Hello World”开始的，然后会写个复杂点class，然后再找一些开源框架，比如Spring，Hibernate等等，再然后就开发企业级的应用，比如网站、企业内部应用、实时交易系统等等，直到某一天突然发现做的系统咋就这么慢呢，而且时不时还来个内存溢出什么的，今天是交易系统报了StackOverflowError，明天是网站系统报了个OutOfMemoryError，这种错误又很难重现，只有分析Javacore和dump文件，运气好点还能分析出个结果，运行遭的点，就直接去庙里烧香吧！每天接客户的电话都是战战兢兢的，生怕再出什么幺蛾子了。我想Java做的久一点的都有这样的经历，那这些问题的最终根结是在哪呢？—— JVM。</p>
<p>JVM全称是Java VirtualMachine，Java虚拟机，也就是在计算机上再虚拟一个计算机，这和我们使用 VMWare不一样，那个虚拟的东西你是可以看到的，这个JVM你是看不到的，它存在内存中。我们知道计算机的基本构成是：运算器、控制器、存储器、输入和输出设备，那这个JVM也是有这成套的元素，运算器是当然是交给硬件CPU还处理了，只是为了适应“一次编译，随处运行”的情况，需要做一个翻译动作，于是就用了JVM自己的命令集，这与汇编的命令集有点类似，每一种汇编命令集针对一个系列的CPU，比如8086系列的汇编也是可以用在8088上的，但是就不能跑在8051上，而JVM的命令集则是可以到处运行的，因为JVM做了翻译，根据不同的CPU，翻译成不同的机器语言。</p>
<p>JVM中我们最需要深入理解的就是它的存储部分，存储？硬盘？NO，NO，JVM是一个内存中的虚拟机，那它的存储就是内存了，我们写的所有类、常量、变量、方法都在内存中，这决定着我们程序运行的是否健壮、是否高效，接下来的部分就是重点介绍之。</p>
<h2 id="-2-jvm-"><a href=""></a>2 JVM的组成部分</h2>
<p>我们先把JVM这个虚拟机画出来，如下图所示：</p>
<p><img src="" alt=""></p>
<p>从这个图中可以看到，JVM是运行在操作系统之上的，它与硬件没有直接的交互。我们再来看下JVM有哪些组成部分，如下图所示：
<img src="" alt=""></p>
<p>该图参考了网上广为流传的JVM构成图，大家看这个图，整个JVM分为四部分：</p>
<p><strong>Class Loader类加载器</strong></p>
<p>类加载器的作用是加载类文件到内存，比如编写一个HelloWord.java程序，然后通过javac编译成class文件，那怎么才能加载到内存中被执行呢？Class Loader承担的就是这个责任，那不可能随便建立一个.class文件就能被加载的，Class Loader加载的class文件是有格式要求，在《JVM Specification》中式这样定义Class文件的结构：</p>
<p>ClassFile{</p>
<p>u4magic;</p>
<p>u2minor_version;</p>
<p>u2major_version;</p>
<p>u2constant_pool_count;</p>
<p>cp_infoconstant_pool[constant_pool_count-1];</p>
<p>u2access_flags;</p>
<p>u2this_class;</p>
<p>u2super_class;</p>
<p>u2interfaces_count;</p>
<p>u2interfaces[interfaces_count];</p>
<p>u2fields_count;</p>
<p>field_infofields[fields_count];</p>
<p>u2methods_count;</p>
<p>method_infomethods[methods_count];</p>
<p>u2attributes_count;</p>
<p>attribute_infoattributes[attributes_count];</p>
<p>}</p>
<p>需要详细了解的话，可以仔细阅读《JVM Specification》的第四章“The class File Format”，这里不再详细说明。</p>
<p>友情提示：Class Loader只管加载，只要符合文件结构就加载，至于说能不能运行，则不是它负责的，那是由Execution Engine负责的。</p>
<p><strong>Execution Engine执行引擎</strong></p>
<p>执行引擎也叫做解释器(Interpreter)，负责解释命令，提交操作系统执行。</p>
<p><strong>Native Interface本地接口</strong></p>
<p>本地接口的作用是融合不同的编程语言为Java所用，它的初衷是融合C/C++程序，Java诞生的时候是C/C++横行的时候，要想立足，必须有一个聪明的、睿智的调用C/C++程序，于是就在内存中专门开辟了一块区域处理标记为native的代码，它的具体做法是Native Method Stack中登记native方法，在Execution Engine执行时加载native libraies。目前该方法使用的是越来越少了，除非是与硬件有关的应用，比如通过Java程序驱动打印机，或者Java系统管理生产设备，在企业级应用中已经比较少见，因为现在的异构领域间的通信很发达，比如可以使用Socket通信，也可以使用Web Service等等，不多做介绍。</p>
<p><strong>Runtime data area运行数据区</strong></p>
<p>运行数据区是整个JVM的重点。我们所有写的程序都被加载到这里，之后才开始运行，Java生态系统如此的繁荣，得益于该区域的优良自治，下一章节详细介绍之。</p>
<p>整个JVM框架由加载器加载文件，然后执行器在内存中处理数据，需要与异构系统交互是可以通过本地接口进行，瞧，一个完整的系统诞生了！</p>
<h2 id="-2-jvm-"><a href=""></a>2 JVM的内存管理</h2>
<p>所有的数据和程序都是在运行数据区存放，它包括以下几部分：</p>
<p>q Stack 栈</p>
<p>栈也叫栈内存，是Java程序的运行区，是在线程创建时创建，它的生命期是跟随线程的生命期，线程结束栈内存也就释放，对于栈来说不存在垃圾回收问题，只要线程一结束，该栈就Over。问题出来了：栈中存的是那些数据呢？又什么是格式呢？</p>
<p>栈中的数据都是以栈帧（Stack Frame）的格式存在，栈帧是一个内存区块，是一个数据集，是一个有关方法(Method)和运行期数据的数据集，当一个方法A被调用时就产生了一个栈帧F1，并被压入到栈中，A方法又调用了B方法，于是产生栈帧F2也被压入栈，执行完毕后，先弹出F2栈帧，再弹出F1栈帧，遵循“先进后出”原则。</p>
<p>那栈帧中到底存在着什么数据呢？栈帧中主要保存3类数据：本地变量（LocalVariables），包括输入参数和输出参数以及方法内的变量；栈操作（Operand Stack），记录出栈、入栈的操作；栈帧数据（FrameData），包括类文件、方法等等。光说比较枯燥，我们画个图来理解一下Java栈，如下图所示：
<img src="" alt=""></p>
<p>图示在一个栈中有两个栈帧，栈帧2是最先被调用的方法，先入栈，然后方法2又调用了方法1，栈帧1处于栈顶的位置，栈帧2处于栈底，执行完毕后，依次弹出栈帧1和栈帧2，线程结束，栈释放。</p>
<p><strong>Heap堆内存</strong></p>
<p>一个JVM实例只存在一个堆类存，堆内存的大小是可以调节的。类加载器读取了类文件后，需要把类、方法、常变量放到堆内存中，以方便执行器执行，堆内存分为三部分：</p>
<p><strong>Permanent Space永久存储区</strong></p>
<p>永久存储区是一个常驻内存区域，用于存放JDK自身所携带的Class,Interface的元数据，也就是说它存储的是运行环境必须的类信息，被装载进此区域的数据是不会被垃圾回收器回收掉的，关闭JVM才会释放此区域所占用的内存。</p>
<p><strong>Young Generation Space 新生区</strong></p>
<p>新生区是类的诞生、成长、消亡的区域，一个类在这里产生，应用，最后被垃圾回收器收集，结束生命。新生区又分为两部分：伊甸区（Eden space）和幸存者区（Survivor pace），所有的类都是在伊甸区被new出来的。幸存区有两个：0区（Survivor 0 space）和1区（Survivor 1 space）。当伊甸园的空间用完时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园区进行垃圾回收，将伊甸园区中的不再被其他对象所引用的对象进行销毁。然后将伊甸园中的剩余对象移动到幸存0区。若幸存0区也满了，再对该区进行垃圾回收，然后移动到1区。那如果1区也满了呢？再移动到养老区。</p>
<p><strong>Tenure generation space养老区</strong></p>
<p>养老区用于保存从新生区筛选出来的JAVA对象，一般池对象都在这个区域活跃。三个区的示意图如下：
<img src="" alt=""></p>
<p><strong>Method Area 方法区</strong></p>
<p>方法区是被所有线程共享，该区域保存所有字段和方法字节码，以及一些特殊方法如构造函数，接口代码也在此定义。</p>
<p><strong>PC Register 程序计数器</strong></p>
<p>每个线程都有一个程序计数器，就是一个指针，指向方法区中的方法字节码，由执行引擎读取下一条指令。</p>
<p><strong>Native Method Stack 本地方法栈</strong></p>
<h2 id="-3-jvm-"><a href=""></a>3 JVM相关问题</h2>
<p><strong>问：堆和栈有什么区别</strong></p>
<p>答：堆是存放对象的，但是对象内的临时变量是存在栈内存中，如例子中的methodVar是在运行期存放到栈中的。</p>
<p>栈是跟随线程的，有线程就有栈，堆是跟随JVM的，有JVM就有堆内存。</p>
<p><strong>问：堆内存中到底存在着什么东西？</strong></p>
<p>答：对象，包括对象变量以及对象方法。</p>
<p><strong>问：类变量和实例变量有什么区别？</strong></p>
<p>答：静态变量是类变量，非静态变量是实例变量，直白的说，有static修饰的变量是静态变量，没有static修饰的变量是实例变量。静态变量存在方法区中，实例变量存在堆内存中。</p>
<p><strong>问：我听说类变量是在JVM启动时就初始化好的，和你这说的不同呀！</strong></p>
<p>答：那你是道听途说，信我的，没错。</p>
<p><strong>问：Java的方法（函数）到底是传值还是传址？</strong></p>
<p>答：都不是，是以传值的方式传递地址，具体的说原生数据类型传递的值，引用类型传递的地址。对于原始数据类型，JVM的处理方法是从Method Area或Heap中拷贝到Stack，然后运行frame中的方法，运行完毕后再把变量指拷贝回去。</p>
<p><strong>问：为什么会产生OutOfMemory产生？</strong></p>
<p>答：一句话：Heap内存中没有足够的可用内存了。这句话要好好理解，不是说Heap没有内存了，是说新申请内存的对象大于Heap空闲内存，比如现在Heap还空闲1M，但是新申请的内存需要1.1M，于是就会报OutOfMemory了，可能以后的对象申请的内存都只要0.9M，于是就只出现一次OutOfMemory，GC也正常了，看起来像偶发事件，就是这么回事。但如果此时GC没有回收就会产生挂起情况，系统不响应了。</p>
<p><strong>问：我产生的对象不多呀，为什么还会产生OutOfMemory？</strong></p>
<p>答：你继承层次忒多了，Heap中产生的对象是先产生父类，然后才产生子类，明白不？</p>
<p><strong>问：OutOfMemory错误分几种？</strong></p>
<p>答：分两种，分别是“OutOfMemoryError:java heap size”和”OutOfMemoryError: PermGen space”，两种都是内存溢出，heap size是说申请不到新的内存了，这个很常见，检查应用或调整堆内存大小。</p>
<p>“PermGen space”是因为永久存储区满了，这个也很常见，一般在热发布的环境中出现，是因为每次发布应用系统都不重启，久而久之永久存储区中的死对象太多导致新对象无法申请内存，一般重新启动一下即可。</p>
<p><strong>问：为什么会产生StackOverflowError？</strong></p>
<p>答：因为一个线程把Stack内存全部耗尽了，一般是递归函数造成的。</p>
<p><strong>问：一个机器上可以看多个JVM吗？JVM之间可以互访吗？</strong></p>
<p>答：可以多个JVM，只要机器承受得了。JVM之间是不可以互访，你不能在A-JVM中访问B-JVM的Heap内存，这是不可能的。在以前老版本的JVM中，会出现A-JVM Crack后影响到B-JVM，现在版本非常少见。</p>
<p><strong>问：为什么Java要采用垃圾回收机制，而不采用C/C++的显式内存管理？</strong></p>
<p>答：为了简单，内存管理不是每个程序员都能折腾好的。</p>
<p><strong>问：为什么你没有详细介绍垃圾回收机制？</strong></p>
<p>答：垃圾回收机制每个JVM都不同，JVM Specification只是定义了要自动释放内存，也就是说它只定义了垃圾回收的抽象方法，具体怎么实现各个厂商都不同，算法各异，这东西实在没必要深入。</p>
<p><strong>问：JVM中到底哪些区域是共享的？哪些是私有的？</strong></p>
<p>答：Heap和Method Area是共享的，其他都是私有的，</p>
<p><strong>问：什么是JIT，你怎么没说？</strong></p>
<p>答：JIT是指Just In Time，有的文档把JIT作为JVM的一个部件来介绍，有的是作为执行引擎的一部分来介绍，这都能理解。Java刚诞生的时候是一个解释性语言，别嘘，即使编译成了字节码（byte code）也是针对JVM的，它需要再次翻译成原生代码(native code)才能被机器执行，于是效率的担忧就提出来了。Sun为了解决该问题提出了一套新的机制，好，你想编译成原生代码，没问题，我在JVM上提供一个工具，把字节码编译成原生码，下次你来访问的时候直接访问原生码就成了，于是JIT就诞生了，就这么回事。</p>
<p><strong>问：JVM还有哪些部分是你没有提到的？</strong></p>
<p>答：JVM是一个异常复杂的东西，写一本砖头书都不为过，还有几个要说明的：</p>
<p>常量池（constant pool）：按照顺序存放程序中的常量，并且进行索引编号的区域。比如int i =100，这个100就放在常量池中。</p>
<p>安全管理器（Security Manager）：提供Java运行期的安全控制，防止恶意攻击，比如指定读取文件，写入文件权限，网络访问，创建进程等等，Class Loader在Security Manager认证通过后才能加载class文件的。</p>
<p>方法索引表（Methods table），记录的是每个method的地址信息，Stack和Heap中的地址指针其实是指向Methodstable地址。</p>
<p><strong>问：为什么不建议在程序中显式的生命System.gc()？</strong></p>
<p>答：因为显式声明是做堆内存全扫描，也就是Full GC，是需要停止所有的活动的（Stop The World Collection），你的应用能承受这个吗？</p>
<p><strong>问：JVM有哪些调整参数？</strong></p>
<p>答：非常多，自己去找，堆内存、栈内存的大小都可以定义，甚至是堆内存的三个部分、新生代的各个比例都能调整。</p>
<p>转载自：<a href="http://wenku.baidu.com/view/70e45e8ba0116c175f0e4840.html" target="_blank"><a href="http://wenku.baidu.com/view/70e45e8ba0116c175f0e4840.html">http://wenku.baidu.com/view/70e45e8ba0116c175f0e4840.html</a></a></p>
<p>来源： &lt;<a href="http://blog.csdn.net/chinajane163/article/details/7784521" target="_blank">深入理解JVM - ChinaJane163的专栏 - 博客频道 - CSDN.NET</a>&gt; </p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/JVM/">JVM</a></li></span></span> | <span class="tags">Tagged <a href="/tags/JVM/" class="label label-primary">JVM</a><a href="/tags/Java&J2EE/" class="label label-success">Java&J2EE</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:42"datetime="2014-03-07 09:54:42"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-JVM--深入理解JVM/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-JVM--深入理解JVM" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>





<ul id="pagination" class="pagination pagination-lg">
  <li><a class="extend prev" href="/page/51/">&laquo;</a></li><li><a class="page-number" href="/">1</a></li><li><a class="page-number" href="/page/2/">2</a></li><li><span class="space">&hellip;</span></li><li><a class="page-number" href="/page/49/">49</a></li><li><a class="page-number" href="/page/50/">50</a></li><li><a class="page-number" href="/page/51/">51</a></li><li class="active"><li><span class="page-number current">52</span></li><li><a class="page-number" href="/page/53/">53</a></li><li><a class="page-number" href="/page/54/">54</a></li><li><a class="page-number" href="/page/55/">55</a></li><li><span class="space">&hellip;</span></li></li><li><a class="page-number" href="/page/164/">164</a></li><li><a class="page-number" href="/page/165/">165</a></li><li><a class="extend next" href="/page/53/">&raquo;</a></li>
  <div class="clearfix"></div>
</ul></div><!--wapper-->
       </div><!-- ID main-col END -->
       <aside id="sidebar" class="alignright col-sx-6 col-sm-4 col-md-3 col-lg-3">
<div id="widget_search" class="widget panel panel-primary">
    <form action="//google.com/search" method="get" accept-charset="utf-8">
  <div class="input-group">
    <input class="form-control" id="searchbox" type="search" name="q" results="0" placeholder="search">
    <span class="input-group-btn">
      <button class="btn btn-default" type="submit">Go!</button>
    </span>
    <input type="hidden" name="q" value="site:itsolife.com">
  </div>
</form>
</div>

<div id="widget_category" class="widget panel panel-primary">
  <div class="panel-heading">category</div>  <div data-src='category' class='ajax_widgets'>正在加载...</div>
</div>

<div id="widget_recent_posts" class="widget panel panel-primary">
  <div class="panel-heading">recent posts</div>  <div data-src='recent_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_tagcloud" class="widget panel panel-primary">
  <div class="panel-heading">tagcloud</div>  <div data-src='tagcloud' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_latest_update_posts" class="widget panel panel-primary">
  <div class="panel-heading">最近更新</div>  <div data-src='latest_update_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_recent_comments" class="widget panel panel-primary">
  <div class="panel-heading">recent comments</div>  

<div class="list-group-item ds-recent-comments" data-num-items="6" data-show-avatars="1" data-show-time="1" data-show-title="1" data-show-admin="1" data-excerpt-length="50"></div>



</div>

</aside>
       <div class="clearfix"></div>
     </div><!-- row END -->
  </div>
  <footer id="footer" class="container">
  <div class="panel panel-info">
  <section id='footer_widget'></section>  <div class="panel-footer">
  <div id="site-info">
    <span class='author'>
  
  &copy; 2014 RobinChia
  
    &nbsp;&nbsp;</span>
  
  <span id='analytics-51la'></span><span id='analytics-google'>
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-48559895-1']);
  _gaq.push(['_trackPageview']);
  _js2load.push({src:('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'});
</script></span><span id='analytics-cnzz'>
<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_5774006'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s17.cnzz.com/stat.php%3Fid%3D5774006%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>
</span><span id='analytics-baidu'>
<script>
var _hmt = _hmt || [];
_js2load.push({src:"//hm.baidu.com/hm.js?1442f50724afc42380b51f097c43082c"});
</script>
</span>  </div>
  <div id="copyright">Blog powered by <a href='http://zespia.tw/hexo/'><strong>hexo</strong></a> Theme <strong><a href='https://github.com/chenall/hexo-theme-chenall'>chenall</a></strong>(Some change in it)<span class="pull-right"> 更新时间: <em>2014-03-26 21:21:33</em></span></div>
</div>
<div class="clearfix"></div>


  </div>
  </footer>
  
        <script src="http://cdn.bootcss.com/jquery/1.10.2/jquery.min.js"></script>        
        <script src="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/js/bootstrap.min.js"></script>        
                
        <script src="http://cdn.bootcss.com/prettify/r298/prettify.min.js"></script>    <script type="text/javascript">
   var lang=["bsh", "c", "cc", "cpp", "cs", "csh", "cyc", "cv", "htm", "html",
    "java", "js", "m", "mxml", "perl", "pl", "pm", "py", "rb", "sh",
    "xhtml", "xml", "xsl"];
   var pretty_base='';
   $('script').each(function(){
	var c = $(this).attr('src');
	if (!c)
	    return;
	if (c.match(/(\/)?prettify(\.min)?\.js/i))
	{
	    var index = c.lastIndexOf('/');
	    if (index != -1)
		pretty_base = c.substr(0,index + 1);
	    return false;
	}
   })
   $('pre code').each(function(){
	var c = $(this).attr('class')
	if (!c)
	    return;
	c = c.match(/\s?(lang\-\w+)/i);
	if (c && lang.indexOf(c[1]) == -1)
	{
	    lang.push(c[1]);
	    $.getScript(pretty_base + c[1] + '.min.js');
	}
   })

    $(window).load(function(){
       $("pre").addClass("prettyprint");
       prettyPrint();
    })
</script>    
            <script type="text/javascript">
var duoshuoQuery = {short_name:"robinchia"};
_js2load.push({src:'http://static.duoshuo.com/embed.js',charset:'UTF-8'});
</script>
    
            <!--wumii_relatedItems-->
    
        <script src="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js"></script>    <script type="text/javascript">
(function($){
  $('.entry').each(function(i){
    $(this).find('img').each(function(){
      var alt = this.alt;

      if (alt){
        $(this).before('<span class="caption">' + alt + '</span>');
      }

      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox" rel="fancybox' + i + '" />');
    });
  });

  $('.fancybox').fancybox();
})(jQuery);
</script>    
        <script src="http://cdn.bootcss.com/mathjax/2.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>    <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>
    
<script type="text/javascript">
$('.ajax_widgets').each(function(){var src=$(this).attr('data-src');if(src)$(this).load('/widgets/'+src+'.html');});
$.each(_js2load,function(index,obj){loadjs(obj.src,obj.charset)});
</script>

<div id="scroll2top">
<img src="/scroll2top/arrow.png"/>
</div>
<script src="/scroll2top/scroll2top.min.js"></script>
<div id="winterland">
  <canvas></canvas>
</div>
<script src="/js/winterland.min.js"></script>

  </body>
</html>
