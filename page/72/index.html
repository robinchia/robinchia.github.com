
<!DOCTYPE HTML>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>The 72 Page | It so life</title>
<meta name="author" content="RobinChia">

<meta name="description" content="It so life">


<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<meta property="og:site_name" content="It so life"/>

<!--[if IE]><style>.testIE.IE{display:inline;}</style><![endif]-->
<!--[if lte IE 7]><link rel="stylesheet" href="/css/ie7.css" type="text/css"><![endif]-->
<!--[if (lt IE 9)&(gt IE 7)]><style>.testIE.IE8{display:inline;}</style><![endif]-->
<!--[if gt IE 8]><style>.testIE.IE9{display:inline;}</style><![endif]-->

<link href="/favicon.png" rel="icon">
<link rel="alternate" href="/atom.xml" title="It so life Feed" type="application/atom+xml">

<link rel="stylesheet" href="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/css/bootstrap.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/font-awesome/4.0.3/css/font-awesome.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/prettify/r298/prettify.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" type="text/css">
<link rel="stylesheet" href="/css/style.css" type="text/css">
<!--[if lt IE 9]>
   <style>article,aside,dialog,footer,header,section,footer,nav,figure,menu{display:block}</style>
   <script src="http://cdn.staticfile.org/html5shiv/r29/html5.min.js"></script>
   <script src="http://cdn.staticfile.org/respond.js/1.4.2/respond.min.js"></script>
<link href="http://cdn.staticfile.org/respond.js/1.4.2/respond-proxy.html" id="respond-proxy" rel="respond-proxy" />
<link href="/js/respond.proxy.gif" id="respond-redirect" rel="respond-redirect" />
<script src="/js/respond.proxy.js"></script>
   <script src="http://cdn.bootcss.com/selectivizr/1.0.2/selectivizr-min.js"></script>
<![endif]-->
<script type="text/javascript">
function loadjs(c,d){var a=document.createElement("script");a.async=!0;a.type="text/javascript";a.src=c;a.charset=d||"gbk";(document.getElementsByTagName("HEAD")[0]||document.getElementsByTagName("BODY")[0]).appendChild(a)};
var _protocol = (("https:" == document.location.protocol) ? " https://" : " http://");
var _js2load = [];
</script>

</head>
<body>
      <header id="header" class="container"><nav id="main-nav" class="navbar navbar-default navbar-fixed-top " role="navigation">
  <div class="container">
    <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
      <span class="sr-only">Toggle navigation</span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="/">It so life</a>
    </div>
    <div  class="collapse navbar-collapse">
      <ul  class="nav navbar-nav">
  
        <li><a href="/" title="Home">Home</a></li>      
        <li><a href="/about/" title="About">About</a></li>      
        <li><a href="/archives/" title="Archives">Archives</a></li>      
      <li class='dropdown'>
        <a class='dropdown-toggle' data-toggle='dropdown' href='#'>website<b class='caret'></b></a>
        <ul class='dropdown-menu pure-menu-selected'>
    
          <li><a href="//groups.google.com/forum/#!forum/pongba" title="TopLanguage">TopLanguage</a></li>    
          <li><a href="//itpub.net/" title="ITPub">ITPub</a></li>    
          <li><a href="//blog.jobbole.com/" title="Bole">Bole</a></li>    
          <li><a href="//nosql-database.org/" title="nosql">nosql</a></li>    
          <li><a href="//gitimmersion.googol.im/" title="Git">Git</a></li>    
        </ul>
      </li>
    
      </ul>
      <ul class="nav navbar-nav navbar-right">
      
        <li><a href="/atom.xml">RSS</a></li>
      
      
        <li><a href="https://twitter.com/robinchia">twitter</a></li>
      
      
      
      
        <li><a href="https://github.com/robinchia">github</a></li>
      
      </ul>
    </div>
  </div>
</nav>
<div class="clearfix"></div>
</header>
  <div id='content' class="container">
     <div class="page-header-wrapper">
      <!--[if lt IE 9]><div class="alert alert-warning alert-dismissable"><button type="button" class="close" data-dismiss="alert" aria-hidden="true">&times;</button><strong>提示:</strong>您的浏览器版本太低了,建议升级到 <strong><a href="http://windows.microsoft.com/zh-cn/internet-explorer/download-ie" title="IE9">IE9</a></strong> 以上,本站使用<a href="https://www.google.com/intl/zh-CN/chrome/">Chrome浏览器</a>可以获得最好的显示效果.</div><![endif]-->
      <div class="page-header"><h1 align="center"><big>It so life</big> </h1>
        <h5 align="center"><big>love as life</big></h5>
      </div>
     </div>
     <div class="row">
       <div id="main-col" class="alignleft col-sx-12 col-sm-8 col-md-9 col-lg-9">
      <section id='header_widget'></section>
          <div id="wrapper"><article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-算法数组优化-数组集合--跟我一起阅读Java源代码之HashMap/">跟我一起阅读Java源代码之HashMap</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:40.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-算法数组优化-数组集合--跟我一起阅读Java源代码之HashMap/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-java-hashmap">跟我一起阅读Java源代码之HashMap</h1>
<p>最近闲的很，想和大家一起学习并讨论下Java的一些源代码以及其实现的数据结构，</p>
<p>不是什么高水平的东西，有兴趣的随便看看</p>
<ol>
<li><p>为什么要用Map，以HashMap为例</p>
<p> 很多时候我们有这样的需求，我们需要将数据成键值对的方式存储起来，根据key来获取value(value可以是简单值，也可以是自定义对象)</p>
<p> 当然用对象数组也能实现这个目的，查找时可以遍历数组，比较关键字来获取对应的value</p>
<p> 从性能上来讲，遍历大数组会消耗性能</p>
<p> 从API易用性来讲，需要自己实现查找的逻辑</p>
<p> 所以用HashMap是必要的    </p>
</li>
</ol>
<ol>
<li>HashMap的数据结构是怎么样的</li>
</ol>
<pre><code>我一直对HashMap的内部结构很好奇，看了源码之后发现他是用散列实现的，即基于hashcode

大体思想是这样的

1. 首先建立一个数组用来存取数据，假设我们定义一个Object[] table用来存取map的value
</code></pre><p>这个很容易理解，key存在哪里呢？暂时我不想存储key</p>
<pre><code>2. 获得key的hashcode经过一定算法转成一个整数

    index，这个index的取值范围必须是0=&lt;index&lt;table.length，然后我将其作为数组元素的下标

    比如执行这样的操作：table[index] = value;

    这样存储的问题解决了

3. 如何通过key去获取这个value呢

    这个太简单了，首先获取key的hashcode，然后通过刚才一样的算法得出元素下标index

    然后value = table[index]
</code></pre><p>简单的HashTable实现如下</p>
<p>Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"></a></p>
<ol>
<li>public class SimpleHashMap {  </li>
<li></li>
<li>private Object[] table;  </li>
<li></li>
<li>public SimpleHashMap() {  </li>
<li>table = new Object[10];  </li>
<li>}  </li>
<li></li>
<li>public Object get(Object key) {  </li>
<li>int index = indexFor(hash(key.hashCode()), 10);  </li>
<li>return table[index];  </li>
<li>}  </li>
<li></li>
<li>public void put(Object key, Object value) {  </li>
<li>int index = indexFor(hash(key.hashCode()), 10);  </li>
<li>table[index] = value;  </li>
<li>}  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* 通过hash code 和table的length得到对应的数组下标 </li>
<li>/*  </li>
<li>/* @param h </li>
<li>/* @param length </li>
<li>/* @return </li>
<li>/*/  </li>
<li>static int indexFor(int h, int length) {  </li>
<li>return h &amp; (length - 1);  </li>
<li>}  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* 通过一定算法计算出新的hash值 </li>
<li>/*  </li>
<li>/* @param h </li>
<li>/* @return </li>
<li>/*/  </li>
<li>static int hash(int h) {  </li>
<li>h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);  </li>
<li>return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);  </li>
<li>}  </li>
<li></li>
<li></li>
<li>public static void main(String[] args){  </li>
<li>SimpleHashMap hashMap = new SimpleHashMap();  </li>
<li>hashMap.put(&quot;key&quot;, &quot;value&quot;);  </li>
<li>System.out.println(hashMap.get(&quot;key&quot;));  </li>
<li>}  </li>
<li>}  </li>
</ol>
<p>这个简单的例子大概描述了散列实现hashmap的过程</p>
<p>但是还很不成熟，我发现至少存在以下两个问题</p>
<ol>
<li><p>hashmap的size是固定的</p>
</li>
<li><p>如果不同的key通过hashcode得出的index相同呢，这样的情况是存在的，如何解决？
来源： <a href="[http://tangyanbo.iteye.com/blog/1755636](http://tangyanbo.iteye.com/blog/1755636)">[http://tangyanbo.iteye.com/blog/1755636](http://tangyanbo.iteye.com/blog/1755636)</a> 由于table的大小是有限的，而key的集合范围是无限大的，所以寄希望于hashcode散落，肯定会出现多个key散落在同一个数组下标下面，</p>
</li>
</ol>
<p>因此我们要引入另外一个概念，将key和value同时存入table[index]中，即将key和value构成一个对象放在table[index]，而且可能存放多个，他们的key对应的index相同，但是key本身不同</p>
<p>现在我们就该讨论以什么样的方式存储这些散落在同一个数组下标的元素</p>
<p>可以考虑数组？</p>
<p>也可以考虑链表存储</p>
<p>源码里面是用链表存储的，其实我也没明白这两种方式在这里有什么区别</p>
<p>，感觉无论在检索和存储上都是差不多的效率，</p>
<p>检索都是需要遍历的方式，而存储也可以是顺序的</p>
<p>那这个问题留给大家吧。</p>
<p>我们来实现链式存储的方式，首先定义一个链表数据结构Entry：</p>
<p>Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"></a></p>
<ol>
<li>public class Entry<K, V> {  </li>
<li>//存储key  </li>
<li>final K key;  </li>
<li>//存储value  </li>
<li>V value;  </li>
<li>//存储指向下一个节点的指针  </li>
<li>Entry<K, V> next;  </li>
<li>//存储key映射的hash  </li>
<li>final int hash;  </li>
<li>}  </li>
</ol>
<p>新的EntryHashMap实现方式</p>
<p>Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"></a></p>
<ol>
<li>public class EntryHashMap<K, V> {  </li>
<li></li>
<li>transient Entry[] table;  </li>
<li></li>
<li>transient int size;  </li>
<li></li>
<li>public V put(K key, V value) {  </li>
<li>//计算出新的hash  </li>
<li>int hash = hash(key.hashCode());  </li>
<li>//计算出数组小标i  </li>
<li>int i = indexFor(hash, table.length);  </li>
<li>//遍历table[i]，如果table[i]没有与新加入的key相等的，则新加入  </li>
<li>//一个value到table[i]中的entry，否则将新的value覆盖旧的value并返回旧的value  </li>
<li>for (Entry<K, V> e = table[i]; e != null; e = e.next) {  </li>
<li>Object k;  </li>
<li>if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) {  </li>
<li>V oldValue = e.value;  </li>
<li>e.value = value;  </li>
<li>return oldValue;  </li>
<li>}  </li>
<li>}  </li>
<li>addEntry(hash, key, value, i);  </li>
<li>return null;  </li>
<li>}  </li>
<li></li>
<li>public void addEntry(int hash, K key, V value, int bucketIndex) {  </li>
<li>Entry<K, V> e = table[bucketIndex];  </li>
<li>//将新的元素插入链表前端  </li>
<li>table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e);  </li>
<li>size++;  </li>
<li>}  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* 通过hash code 和table的length得到对应的数组下标 </li>
<li>/*  </li>
<li>/* @param h </li>
<li>/* @param length </li>
<li>/* @return </li>
<li>/*/  </li>
<li>static int indexFor(int h, int length) {  </li>
<li>return h &amp; (length - 1);  </li>
<li>}  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* 通过一定算法计算出新的hash值 </li>
<li>/*  </li>
<li>/* @param h </li>
<li>/* @return </li>
<li>/*/  </li>
<li>static int hash(int h) {  </li>
<li>h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);  </li>
<li>return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);  </li>
<li>}  </li>
<li>}  </li>
</ol>
<p>来源： <a href="[http://tangyanbo.iteye.com/blog/1756074](http://tangyanbo.iteye.com/blog/1756074)">[http://tangyanbo.iteye.com/blog/1756074](http://tangyanbo.iteye.com/blog/1756074)</a> 为什么要用链表而不是数组</p>
<p>链表的作用有如下两点好处</p>
<ol>
<li><p>remove操作时效率高，只维护指针的变化即可，无需进行移位操作</p>
</li>
<li><p>重新散列时，原来散落在同一个槽中的元素可能会被散落在不同的地方，对于数组需要进行移位操作，而链表只需维护指针</p>
</li>
</ol>
<p>今天研究下数组长度不够时的处理办法</p>
<p>table为散列数组</p>
<ol>
<li><p>首先定义一个不可修改的静态变量存储table的初始大小 DEFAULT_INITIAL_CAPACITY</p>
</li>
<li><p>定义一个全局变量存储table的实际元素长度，size</p>
</li>
<li><p>定义一个全局变量存储临界点，即元素的size&gt;=threshold这个临界点时，扩大table的容量</p>
</li>
<li><p>因为index是根据hash和table的长度计算得到的，所以还需要重新对所有元素进行散列</p>
</li>
</ol>
<p>实现如下：</p>
<p>Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"></a></p>
<ol>
<li>package sourcecoderead.collection.map;  </li>
<li></li>
<li></li>
<li>public class EntryHashMap<K, V> {  </li>
<li></li>
<li>//<em>/</em> 初始容量 /*/  </li>
<li>static final int DEFAULT_INITIAL_CAPACITY = 16;  </li>
<li></li>
<li>static final float DEFAULT_LOAD_FACTOR = 0.75f;  </li>
<li></li>
<li>//<em>/</em> 下次扩容的临界值 /*/  </li>
<li>int threshold;  </li>
<li></li>
<li>transient int size;  </li>
<li></li>
<li>final float loadFactor;  </li>
<li></li>
<li>transient Entry[] table;  </li>
<li></li>
<li>public EntryHashMap() {  </li>
<li>this.loadFactor = DEFAULT_LOAD_FACTOR;  </li>
<li>threshold = (int) (DEFAULT_INITIAL_CAPACITY /* DEFAULT_LOAD_FACTOR);  </li>
<li>table = new Entry[DEFAULT_INITIAL_CAPACITY];  </li>
<li>}  </li>
<li></li>
<li>public V put(K key, V value) {  </li>
<li>// 计算出新的hash  </li>
<li>int hash = hash(key.hashCode());  </li>
<li>// 计算出数组小标i  </li>
<li>int i = indexFor(hash, table.length);  </li>
<li>// 遍历table[i]，如果table[i]没有与新加入的key相等的，则新加入  </li>
<li>// 一个value到table[i]中的entry，否则将新的value覆盖旧的value并返回旧的value  </li>
<li>for (Entry<K, V> e = table[i]; e != null; e = e.next) {  </li>
<li>Object k;  </li>
<li>if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) {  </li>
<li>V oldValue = e.value;  </li>
<li>e.value = value;  </li>
<li>return oldValue;  </li>
<li>}  </li>
<li>}  </li>
<li>addEntry(hash, key, value, i);  </li>
<li>return null;  </li>
<li>}  </li>
<li></li>
<li>public V get(K key) {  </li>
<li>// 计算出新的hash  </li>
<li>int hash = hash(key.hashCode());  </li>
<li>// 计算出数组小标i  </li>
<li>int i = indexFor(hash, table.length);  </li>
<li>for (Entry<K, V> e = table[i]; e != null; e = e.next) {  </li>
<li>Object k;  </li>
<li>if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) {  </li>
<li>return e.value;  </li>
<li>}  </li>
<li>}  </li>
<li>return null;  </li>
<li>}  </li>
<li></li>
<li>private void addEntry(int hash, K key, V value, int bucketIndex) {  </li>
<li>Entry<K, V> e = table[bucketIndex];  </li>
<li>// 将新的元素插入链表前端  </li>
<li>table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e);  </li>
<li>if (size++ &gt;= threshold)  </li>
<li>resize(2 /* table.length);  </li>
<li>}  </li>
<li></li>
<li>void resize(int newCapacity) {  </li>
<li>Entry[] oldTable = table;  </li>
<li>int oldCapacity = oldTable.length;  </li>
<li>Entry[] newTable = new Entry[newCapacity];  </li>
<li>transfer(newTable);  </li>
<li>table = newTable;  </li>
<li>threshold = (int) (newCapacity /* loadFactor);  </li>
<li>}  </li>
<li></li>
<li>void transfer(Entry[] newTable) {  </li>
<li>Entry[] src = table;  </li>
<li>int newCapacity = newTable.length;  </li>
<li>for (int j = 0; j &lt; src.length; j++) {  </li>
<li>Entry<K, V> e = src[j];  </li>
<li>if (e != null) {  </li>
<li>src[j] = null;  </li>
<li>do {  </li>
<li>Entry<K, V> next = e.next;  </li>
<li>int i = indexFor(e.hash, newCapacity);  </li>
<li>e.next = newTable[i];  </li>
<li>newTable[i] = e;  </li>
<li>e = next;  </li>
<li>} while (e != null);  </li>
<li>}  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* 通过hash code 和table的length得到对应的数组下标 </li>
<li>/*  </li>
<li>/* @param h </li>
<li>/* @param length </li>
<li>/* @return </li>
<li>/*/  </li>
<li>static int indexFor(int h, int length) {  </li>
<li>return h &amp; (length - 1);  </li>
<li>}  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* 通过一定算法计算出新的hash值 </li>
<li>/*  </li>
<li>/* @param h </li>
<li>/* @return </li>
<li>/*/  </li>
<li>static int hash(int h) {  </li>
<li>h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);  </li>
<li>return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);  </li>
<li>}  </li>
<li></li>
<li>public static void main(String[] args) {  </li>
<li>EntryHashMap<String, String> hashMap = new EntryHashMap<String, String>();  </li>
<li>hashMap.put(&quot;key&quot;, &quot;value&quot;);  </li>
<li>System.out.println(hashMap.get(&quot;key&quot;));  </li>
<li>}  </li>
<li>}  </li>
</ol>
<p>来源： <a href="[http://tangyanbo.iteye.com/blog/1756536](http://tangyanbo.iteye.com/blog/1756536)">[http://tangyanbo.iteye.com/blog/1756536](http://tangyanbo.iteye.com/blog/1756536)</a> </p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/算法&数组&优化/">算法&数组&优化</a></li><li><a href="/categories/Java&J2EE/算法&数组&优化/数组&集合/">数组&集合</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/数组&集合/" class="label label-success">数组&集合</a><a href="/tags/算法&数组&优化/" class="label label-info">算法&数组&优化</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:40"datetime="2014-03-07 09:54:40"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-算法数组优化-数组集合--跟我一起阅读Java源代码之HashMap/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-算法数组优化-数组集合--跟我一起阅读Java源代码之HashMap" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-算法数组优化-数组集合--通过分析JDK源代码研究Hash存储机制/">通过分析 JDK 源代码研究 Hash 存储机制</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:40.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-算法数组优化-数组集合--通过分析JDK源代码研究Hash存储机制/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-jdk-hash-">通过分析 JDK 源代码研究 Hash 存储机制</h1>
<p><a href="http://www.ibm.com/cn/" target="_blank"><img src="" alt="IBM®"></a> <img src="" alt=""> <a href="http://www.ibm.com/developerworks/cn/java/j-lo-hash/?open&amp;cm_mmc=6505-_-n-_-vrm_newsletter-_-10104_142587&amp;cmibm_em=dm:0:10631101#main" target="_blank"><img src="" alt="跳转到主要内容"></a>     <strong>中国</strong> [<a href="http://www.ibm.com/developerworks/cn/country/" target="_blank">选择</a>]      <a href="http://www.ibm.com/legal/cn/" target="_blank">使用条款</a>   <img src="" alt=""> <img src="" alt="">   <img src="" alt="Select a scope:"> dW 全部内容 -----------------   AIX and UNIX   Information management   Lotus   Rational   WebSphere -----------------   Architecture   Grid computing   Java 技术   Linux   Multicore acceleration   Open source   Security   SOA &amp; Web services   Web development   XML ----------------- IBM 全部内容 <img src="" alt="Search for:">      <a href=""></a>        <a href="http://www.ibm.com/cn/">首页</a>      <a href="http://www.ibm.com/products/cn/" target="_blank">产品</a>      <a href="http://www.ibm.com/servicessolutions/cn/" target="_blank">服务与解决方案</a>      <a href="http://www.ibm.com/support/cn/" target="_blank">支持与下载</a>      <a href="http://www.ibm.com/account/cn/" target="_blank">个性化服务</a>      <a href="http://www.ibm.com/developerworks/cn/" target="_blank"> </a> <a href="http://www.ibm.com/developerworks/cn/">developerWorks
中国</a> <a href="http://www.ibm.com/developerworks/cn/java/j-lo-hash/?open&amp;cm_mmc=6505-_-n-_-vrm_newsletter-_-10104_142587&amp;cmibm_em=dm:0:10631101#" target="_blank">本文内容包括：</a> <img src="" alt=""> <a href="http://www.ibm.com/developerworks/cn/java/j-lo-hash/?open&amp;cm_mmc=6505-_-n-_-vrm_newsletter-_-10104_142587&amp;cmibm_em=dm:0:10631101#major1" target="_blank">通过 HashMap、HashSet 的源代码分析其 Hash 存储机制</a> <img src="" alt=""> <a href="http://www.ibm.com/developerworks/cn/java/j-lo-hash/?open&amp;cm_mmc=6505-_-n-_-vrm_newsletter-_-10104_142587&amp;cmibm_em=dm:0:10631101#major2" target="_blank">HashMap 的存储实现</a> <img src="" alt=""> <a href="http://www.ibm.com/developerworks/cn/java/j-lo-hash/?open&amp;cm_mmc=6505-_-n-_-vrm_newsletter-_-10104_142587&amp;cmibm_em=dm:0:10631101#major3" target="_blank">Hash 算法的性能选项</a> <img src="" alt=""> <a href="http://www.ibm.com/developerworks/cn/java/j-lo-hash/?open&amp;cm_mmc=6505-_-n-_-vrm_newsletter-_-10104_142587&amp;cmibm_em=dm:0:10631101#major4" target="_blank">HashMap 的读取实现</a> <img src="" alt=""> <a href="http://www.ibm.com/developerworks/cn/java/j-lo-hash/?open&amp;cm_mmc=6505-_-n-_-vrm_newsletter-_-10104_142587&amp;cmibm_em=dm:0:10631101#major5" target="_blank">HashSet 的实现</a> <img src="" alt=""> <a href="http://www.ibm.com/developerworks/cn/java/j-lo-hash/?open&amp;cm_mmc=6505-_-n-_-vrm_newsletter-_-10104_142587&amp;cmibm_em=dm:0:10631101#resources" target="_blank">参考资料</a> <img src="" alt=""> <a href="http://www.ibm.com/developerworks/cn/java/j-lo-hash/?open&amp;cm_mmc=6505-_-n-_-vrm_newsletter-_-10104_142587&amp;cmibm_em=dm:0:10631101#author" target="_blank">关于作者</a> <img src="" alt=""> <a href="http://www.ibm.com/developerworks/cn/java/j-lo-hash/?open&amp;cm_mmc=6505-_-n-_-vrm_newsletter-_-10104_142587&amp;cmibm_em=dm:0:10631101#rate" target="_blank">对本文的评价</a> <img src="" alt=""> <img src="" alt="">
<strong>相关链接：</strong> <img src="" alt=""> <a href="http://www.ibm.com/developerworks/cn/views/java/libraryview.jsp" target="_blank">Java technology 技术文档库</a> <img src="" alt=""> <img src="" alt=""> <a href=""><img src="" alt="跳转到主要内容"></a> <img src="" alt=""> <img src="" alt="">
<a href="http://www.ibm.com/developerworks/cn/" target="_blank">developerWorks 中国</a>  &gt;  <a href="http://www.ibm.com/developerworks/cn/java/" target="_blank">Java technology</a>  &gt;<img src="" alt=""></p>
<h1 id="-jdk-hash-">通过分析 JDK 源代码研究 Hash 存储机制</h1>
<p><img src="" alt=""> <img src="" alt="developerWorks"> <img src="" alt=""> <img src="" alt=""> 文档选项 <img src="" alt=""> <img src="" alt=""> 
未显示需要 JavaScript 的文档选项</p>
<p>级别： 中级</p>
<p><a href="http://www.ibm.com/developerworks/cn/java/j-lo-hash/?open&amp;cm_mmc=6505-_-n-_-vrm_newsletter-_-10104_142587&amp;cmibm_em=dm:0:10631101#author" target="_blank">李 刚</a>, 自由撰稿人</p>
<p>2009 年 11 月 26 日
HashMap 和 HashSet 是 Java Collection Framework 的两个重要成员，其中 HashMap 是 Map 接口的常用实现类，HashSet 是 Set 接口的常用实现类。虽然 HashMap 和 HashSet 实现的接口规范不同，但它们底层的 Hash 存储机制完全一样，甚至 HashSet 本身就采用 HashMap 来实现的。</p>
<p><a href="">通过 HashMap、HashSet 的源代码分析其 Hash 存储机制</a></p>
<p><img src="" alt=""> <a href=""><strong>集合和引用</strong></a></p>
<p>就像引用类型的数组一样，当我们把 Java 对象放入数组之时，并不是真正的把 Java 对象放入数组中，只是把对象的引用放入数组中，每个数组元素都是一个引用变量。</p>
<p>实际上，HashSet 和 HashMap 之间有很多相似之处，对于 HashSet 而言，系统采用 Hash 算法决定集合元素的存储位置，这样可以保证能快速存、取集合元素；对于 HashMap 而言，系统 key-value 当成一个整体进行处理，系统总是根据 Hash 算法来计算 key-value 的存储位置，这样可以保证能快速存、取 Map 的 key-value 对。</p>
<p>在介绍集合存储之前需要指出一点：虽然集合号称存储的是 Java 对象，但实际上并不会真正将 Java 对象放入 Set 集合中，只是在 Set 集合中保留这些对象的引用而言。也就是说：Java 集合实际上是多个引用变量所组成的集合，这些引用变量指向实际的 Java 对象。
<img src="" alt="">
<img src="" alt=""> <img src="" alt="">
<img src="" alt="">
 <a href="http://www.ibm.com/developerworks/cn/java/j-lo-hash/?open&amp;cm_mmc=6505-_-n-_-vrm_newsletter-_-10104_142587&amp;cmibm_em=dm:0:10631101#main" target="_blank"><strong>回页首</strong></a></p>
<p><a href="">HashMap 的存储实现</a></p>
<p>当程序试图将多个 key-value 放入 HashMap 中时，以如下代码片段为例：
HashMap<String , Double> map = new HashMap<String , Double>(); map.put(&quot;语文&quot; , 80.0); map.put(&quot;数学&quot; , 89.0); map.put(&quot;英语&quot; , 78.2);</p>
<p>HashMap 采用一种所谓的“Hash 算法”来决定每个元素的存储位置。</p>
<p>当程序执行 map.put(&quot;语文&quot; , 80.0); 时，系统将调用&quot;语文&quot;的 hashCode() 方法得到其 hashCode 值——每个 Java 对象都有 hashCode() 方法，都可通过该方法获得它的 hashCode 值。得到这个对象的 hashCode 值之后，系统会根据该 hashCode 值来决定该元素的存储位置。</p>
<p>我们可以看 HashMap 类的 put(K key , V value) 方法的源代码：
public V put(K key, V value) { // 如果 key 为 null，调用 putForNullKey 方法进行处理 if (key == null) return putForNullKey(value); // 根据 key 的 keyCode 计算 Hash 值 int hash = hash(key.hashCode()); // 搜索指定 hash 值在对应 table 中的索引  int i = indexFor(hash, table.length); // 如果 i 索引处的 Entry 不为 null，通过循环不断遍历 e 元素的下一个元素 for (Entry<K,V> e = table[i]; e != null; e = e.next) { Object k; // 找到指定 key 与需要放入的 key 相等（hash 值相同 // 通过 equals 比较放回 true） if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) { V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; } } // 如果 i 索引处的 Entry 为 null，表明此处还没有 Entry modCount++; // 将 key、value 添加到 i 索引处 addEntry(hash, key, value, i); return null; }
<img src="" alt=""> <a href=""><strong>JDK 源码</strong></a></p>
<p>在 JDK 安装目录下可以找到一个 src.zip 压缩文件，该文件里包含了 Java 基础类库的所有源文件。只要读者有学习兴趣，随时可以打开这份压缩文件来阅读 Java 类库的源代码，这对提高读者的编程能力是非常有帮助的。需要指出的是：src.zip 中包含的源代码并没有包含像上文中的中文注释，这些注释是笔者自己添加进去的。</p>
<p>上面程序中用到了一个重要的内部接口：Map.Entry，每个 Map.Entry 其实就是一个 key-value 对。从上面程序中可以看出：当系统决定存储 HashMap 中的 key-value 对时，完全没有考虑 Entry 中的 value，仅仅只是根据 key 来计算并决定每个 Entry 的存储位置。这也说明了前面的结论：我们完全可以把 Map 集合中的 value 当成 key 的附属，当系统决定了 key 的存储位置之后，value 随之保存在那里即可。</p>
<p>上面方法提供了一个根据 hashCode() 返回值来计算 Hash 码的方法：hash()，这个方法是一个纯粹的数学计算，其方法如下：
static int hash(int h) { h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12); return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4); }</p>
<p>对于任意给定的对象，只要它的 hashCode() 返回值相同，那么程序调用 hash(int h) 方法所计算得到的 Hash 码值总是相同的。接下来程序会调用 indexFor(int h, int length) 方法来计算该对象应该保存在 table 数组的哪个索引处。indexFor(int h, int length) 方法的代码如下：
static int indexFor(int h, int length) { return h &amp; (length-1); }</p>
<p>这个方法非常巧妙，它总是通过 h</p>
<p>&amp;
(table.length -1) 来得到该对象的保存位置——而 HashMap 底层数组的长度总是 2 的 n 次方，这一点可参看后面关于 HashMap 构造器的介绍。</p>
<p>当 length 总是 2 的倍数时，h</p>
<p>&amp; (length-1)</p>
<p>将是一个非常巧妙的设计：假设 h=5,length=16, 那么 h &amp; length - 1 将得到 5；如果 h=6,length=16, 那么 h &amp; length - 1 将得到 6 ……如果 h=15,length=16, 那么 h &amp; length - 1 将得到 15；但是当 h=16 时 , length=16 时，那么 h &amp; length - 1 将得到 0 了；当 h=17 时 , length=16 时，那么 h &amp; length - 1 将得到 1 了……这样保证计算得到的索引值总是位于 table 数组的索引之内。</p>
<p>根据上面 put 方法的源代码可以看出，当程序试图将一个 key-value 对放入 HashMap 中时，程序首先根据该 key 的 hashCode() 返回值决定该 Entry 的存储位置：如果两个 Entry 的 key 的 hashCode() 返回值相同，那它们的存储位置相同。如果这两个 Entry 的 key 通过 equals 比较返回 true，新添加 Entry 的 value 将覆盖集合中原有 Entry 的 value，但 key 不会覆盖。如果这两个 Entry 的 key 通过 equals 比较返回 false，新添加的 Entry 将与集合中原有 Entry 形成 Entry 链，而且新添加的 Entry 位于 Entry 链的头部——具体说明继续看 addEntry() 方法的说明。</p>
<p>当向 HashMap 中添加 key-value 对，由其 key 的 hashCode() 返回值决定该 key-value 对（就是 Entry 对象）的存储位置。当两个 Entry 对象的 key 的 hashCode() 返回值相同时，将由 key 通过 eqauls() 比较值决定是采用覆盖行为（返回 true），还是产生 Entry 链（返回 false）。</p>
<p>上面程序中还调用了 addEntry(hash, key, value, i); 代码，其中 addEntry 是 HashMap 提供的一个包访问权限的方法，该方法仅用于添加一个 key-value 对。下面是该方法的代码：
void addEntry(int hash, K key, V value, int bucketIndex) { // 获取指定 bucketIndex 索引处的 Entry Entry<K,V> e = table[bucketIndex]; // ① // 将新创建的 Entry 放入 bucketIndex 索引处，并让新的 Entry 指向原来的 Entry table[bucketIndex] = new Entry<K,V>(hash, key, value, e); // 如果 Map 中的 key-value 对的数量超过了极限 if (size++ &gt;= threshold) // 把 table 对象的长度扩充到 2 倍。 resize(2 /* table.length); // ② }</p>
<p>上面方法的代码很简单，但其中包含了一个非常优雅的设计：系统总是将新添加的 Entry 对象放入 table 数组的 bucketIndex 索引处——如果 bucketIndex 索引处已经有了一个 Entry 对象，那新添加的 Entry 对象指向原有的 Entry 对象（产生一个 Entry 链），如果 bucketIndex 索引处没有 Entry 对象，也就是上面程序①号代码的 e 变量是 null，也就是新放入的 Entry 对象指向 null，也就是没有产生 Entry 链。
<img src="" alt="">
<img src="" alt=""> <img src="" alt="">
<img src="" alt="">
 <a href="http://www.ibm.com/developerworks/cn/java/j-lo-hash/?open&amp;cm_mmc=6505-_-n-_-vrm_newsletter-_-10104_142587&amp;cmibm_em=dm:0:10631101#main" target="_blank"><strong>回页首</strong></a></p>
<p><a href="">Hash 算法的性能选项</a></p>
<p>根据上面代码可以看出，在同一个 bucket 存储 Entry 链的情况下，新放入的 Entry 总是位于 bucket 中，而最早放入该 bucket 中的 Entry 则位于这个 Entry 链的最末端。</p>
<p>上面程序中还有这样两个变量：</p>
<ul>
<li>size：该变量保存了该 HashMap 中所包含的 key-value 对的数量。</li>
<li>threshold：该变量包含了 HashMap 能容纳的 key-value 对的极限，它的值等于 HashMap 的容量乘以负载因子（load factor）。</li>
</ul>
<p>从上面程序中②号代码可以看出，当 size++ &gt;= threshold 时，HashMap 会自动调用 resize 方法扩充 HashMap 的容量。每扩充一次，HashMap 的容量就增大一倍。</p>
<p>上面程序中使用的 table 其实就是一个普通数组，每个数组都有一个固定的长度，这个数组的长度就是 HashMap 的容量。HashMap 包含如下几个构造器：</p>
<ul>
<li>HashMap()：构建一个初始容量为 16，负载因子为 0.75 的 HashMap。</li>
<li>HashMap(int initialCapacity)：构建一个初始容量为 initialCapacity，负载因子为 0.75 的 HashMap。</li>
<li>HashMap(int initialCapacity, float loadFactor)：以指定初始容量、指定的负载因子创建一个 HashMap。</li>
</ul>
<p>当创建一个 HashMap 时，系统会自动创建一个 table 数组来保存 HashMap 中的 Entry，下面是 HashMap 中一个构造器的代码：
// 以指定初始化容量、负载因子创建 HashMap public HashMap(int initialCapacity, float loadFactor) { // 初始容量不能为负数 if (initialCapacity &lt; 0) throw new IllegalArgumentException( &quot;Illegal initial capacity: &quot; + initialCapacity); // 如果初始容量大于最大容量，让出示容量 if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; // 负载因子必须大于 0 的数值 if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException( loadFactor); // 计算出大于 initialCapacity 的最小的 2 的 n 次方值。 int capacity = 1; while (capacity &lt; initialCapacity) capacity &lt;&lt;= 1; this.loadFactor = loadFactor; // 设置容量极限等于容量 /<em> 负载因子 threshold = (int)(capacity /</em> loadFactor); // 初始化 table 数组 table = new Entry[capacity]; // ① init(); }</p>
<p>上面代码中粗体字代码包含了一个简洁的代码实现：找出大于 initialCapacity 的、最小的 2 的 n 次方值，并将其作为 HashMap 的实际容量（由 capacity 变量保存）。例如给定 initialCapacity 为 10，那么该 HashMap 的实际容量就是 16。
<img src="" alt=""> <a href=""><strong>initialCapacity 与 HashTable 的容量</strong></a></p>
<p>创建 HashMap 时指定的 initialCapacity 并不等于 HashMap 的实际容量，通常来说，HashMap 的实际容量总比 initialCapacity 大一些，除非我们指定的 initialCapacity 参数值恰好是 2 的 n 次方。当然，掌握了 HashMap 容量分配的知识之后，应该在创建 HashMap 时将 initialCapacity 参数值指定为 2 的 n 次方，这样可以减少系统的计算开销。</p>
<p>程序①号代码处可以看到：table 的实质就是一个数组，一个长度为 capacity 的数组。</p>
<p>对于 HashMap 及其子类而言，它们采用 Hash 算法来决定集合中元素的存储位置。当系统开始初始化 HashMap 时，系统会创建一个长度为 capacity 的 Entry 数组，这个数组里可以存储元素的位置被称为“桶（bucket）”，每个 bucket 都有其指定索引，系统可以根据其索引快速访问该 bucket 里存储的元素。</p>
<p>无论何时，HashMap 的每个“桶”只存储一个元素（也就是一个 Entry），由于 Entry 对象可以包含一个引用变量（就是 Entry 构造器的的最后一个参数）用于指向下一个 Entry，因此可能出现的情况是：HashMap 的 bucket 中只有一个 Entry，但这个 Entry 指向另一个 Entry ——这就形成了一个 Entry 链。如图 1 所示：
<a href=""><strong>图 1. HashMap 的存储示意</strong></a>
<img src="" alt="图 1. HashMap 的存储示意">
<img src="" alt="">
<img src="" alt=""> <img src="" alt="">
<img src="" alt="">
 <a href="http://www.ibm.com/developerworks/cn/java/j-lo-hash/?open&amp;cm_mmc=6505-_-n-_-vrm_newsletter-_-10104_142587&amp;cmibm_em=dm:0:10631101#main" target="_blank"><strong>回页首</strong></a></p>
<p><a href="">HashMap 的读取实现</a></p>
<p>当 HashMap 的每个 bucket 里存储的 Entry 只是单个 Entry ——也就是没有通过指针产生 Entry 链时，此时的 HashMap 具有最好的性能：当程序通过 key 取出对应 value 时，系统只要先计算出该 key 的 hashCode() 返回值，在根据该 hashCode 返回值找出该 key 在 table 数组中的索引，然后取出该索引处的 Entry，最后返回该 key 对应的 value 即可。看 HashMap 类的 get(K key) 方法代码：
public V get(Object key) { // 如果 key 是 null，调用 getForNullKey 取出对应的 value if (key == null) return getForNullKey(); // 根据该 key 的 hashCode 值计算它的 hash 码 int hash = hash(key.hashCode()); // 直接取出 table 数组中指定索引处的值， for (Entry<K,V> e = table[indexFor(hash, table.length)]; e != null; // 搜索该 Entry 链的下一个 Entr e = e.next) // ① { Object k; // 如果该 Entry 的 key 与被搜索 key 相同 if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) return e.value; } return null; }</p>
<p>从上面代码中可以看出，如果 HashMap 的每个 bucket 里只有一个 Entry 时，HashMap 可以根据索引、快速地取出该 bucket 里的 Entry；在发生“Hash 冲突”的情况下，单个 bucket 里存储的不是一个 Entry，而是一个 Entry 链，系统只能必须按顺序遍历每个 Entry，直到找到想搜索的 Entry 为止——如果恰好要搜索的 Entry 位于该 Entry 链的最末端（该 Entry 是最早放入该 bucket 中），那系统必须循环到最后才能找到该元素。</p>
<p>归纳起来简单地说，HashMap 在底层将 key-value 当成一个整体进行处理，这个整体就是一个 Entry 对象。HashMap 底层采用一个 Entry[] 数组来保存所有的 key-value 对，当需要存储一个 Entry 对象时，会根据 Hash 算法来决定其存储位置；当需要取出一个 Entry 时，也会根据 Hash 算法找到其存储位置，直接取出该 Entry。由此可见：HashMap 之所以能快速存、取它所包含的 Entry，完全类似于现实生活中母亲从小教我们的：不同的东西要放在不同的位置，需要时才能快速找到它。</p>
<p>当创建 HashMap 时，有一个默认的负载因子（load factor），其默认值为 0.75，这是时间和空间成本上一种折衷：增大负载因子可以减少 Hash 表（就是那个 Entry 数组）所占用的内存空间，但会增加查询数据的时间开销，而查询是最频繁的的操作（HashMap 的 get() 与 put() 方法都要用到查询）；减小负载因子会提高数据查询的性能，但会增加 Hash 表所占用的内存空间。</p>
<p>掌握了上面知识之后，我们可以在创建 HashMap 时根据实际需要适当地调整 load factor 的值；如果程序比较关心空间开销、内存比较紧张，可以适当地增加负载因子；如果程序比较关心时间开销，内存比较宽裕则可以适当的减少负载因子。通常情况下，程序员无需改变负载因子的值。</p>
<p>如果开始就知道 HashMap 会保存多个 key-value 对，可以在创建时就使用较大的初始化容量，如果 HashMap 中 Entry 的数量一直不会超过极限容量（capacity /<em> load factor），HashMap 就无需调用 resize() 方法重新分配 table 数组，从而保证较好的性能。当然，开始就将初始容量设置太高可能会浪费空间（系统需要创建一个长度为 capacity 的 Entry 数组），因此创建 HashMap 时初始化容量设置也需要小心对待。
<img src="" alt="">
<img src="" alt=""> <img src="" alt="">
<img src="" alt="">
 [<em>*回页首</em></em>](<a href="http://www.ibm.com/developerworks/cn/java/j-lo-hash/?open&amp;cm_mmc=6505-_-n-_-vrm_newsletter-_-10104_142587&amp;cmibm_em=dm:0:10631101#main" target="_blank">http://www.ibm.com/developerworks/cn/java/j-lo-hash/?open&amp;cm_mmc=6505-_-n-_-vrm_newsletter-_-10104_142587&amp;cmibm_em=dm:0:10631101#main</a>)</p>
<p><a href="">HashSet 的实现</a></p>
<p>对于 HashSet 而言，它是基于 HashMap 实现的，HashSet 底层采用 HashMap 来保存所有元素，因此 HashSet 的实现比较简单，查看 HashSet 的源代码，可以看到如下代码：
public class HashSet<E> extends AbstractSet<E> implements Set<E>, Cloneable, java.io.Serializable { // 使用 HashMap 的 key 保存 HashSet 中所有元素 private transient HashMap<E,Object> map; // 定义一个虚拟的 Object 对象作为 HashMap 的 value private static final Object PRESENT = new Object(); ... // 初始化 HashSet，底层会初始化一个 HashMap public HashSet() { map = new HashMap<E,Object>(); } // 以指定的 initialCapacity、loadFactor 创建 HashSet // 其实就是以相应的参数创建 HashMap public HashSet(int initialCapacity, float loadFactor) { map = new HashMap<E,Object>(initialCapacity, loadFactor); } public HashSet(int initialCapacity) { map = new HashMap<E,Object>(initialCapacity); } HashSet(int initialCapacity, float loadFactor, boolean dummy) { map = new LinkedHashMap<E,Object>(initialCapacity , loadFactor); } // 调用 map 的 keySet 来返回所有的 key public Iterator<E> iterator() { return map.keySet().iterator(); } // 调用 HashMap 的 size() 方法返回 Entry 的数量，就得到该 Set 里元素的个数 public int size() { return map.size(); } // 调用 HashMap 的 isEmpty() 判断该 HashSet 是否为空， // 当 HashMap 为空时，对应的 HashSet 也为空 public boolean isEmpty() { return map.isEmpty(); } // 调用 HashMap 的 containsKey 判断是否包含指定 key //HashSet 的所有元素就是通过 HashMap 的 key 来保存的 public boolean contains(Object o) { return map.containsKey(o); } // 将指定元素放入 HashSet 中，也就是将该元素作为 key 放入 HashMap public boolean add(E e) { return map.put(e, PRESENT) == null; } // 调用 HashMap 的 remove 方法删除指定 Entry，也就删除了 HashSet 中对应的元素 public boolean remove(Object o) { return map.remove(o)==PRESENT; } // 调用 Map 的 clear 方法清空所有 Entry，也就清空了 HashSet 中所有元素 public void clear() { map.clear(); } ... }</p>
<p>由上面源程序可以看出，HashSet 的实现其实非常简单，它只是封装了一个 HashMap 对象来存储所有的集合元素，所有放入 HashSet 中的集合元素实际上由 HashMap 的 key 来保存，而 HashMap 的 value 则存储了一个 PRESENT，它是一个静态的 Object 对象。</p>
<p>HashSet 的绝大部分方法都是通过调用 HashMap 的方法来实现的，因此 HashSet 和 HashMap 两个集合在实现本质上是相同的。
<img src="" alt=""> <a href=""><strong>HashMap 的 put 与 HashSet 的 add</strong></a></p>
<p>由于 HashSet 的 add() 方法添加集合元素时实际上转变为调用 HashMap 的 put() 方法来添加 key-value 对，当新放入 HashMap 的 Entry 中 key 与集合中原有 Entry 的 key 相同（hashCode() 返回值相等，通过 equals 比较也返回 true），新添加的 Entry 的 value 将覆盖原来 Entry 的 value，但 key 不会有任何改变，因此如果向 HashSet 中添加一个已经存在的元素，新添加的集合元素（底层由 HashMap 的 key 保存）不会覆盖已有的集合元素。</p>
<p>掌握上面理论知识之后，接下来看一个示例程序，测试一下自己是否真正掌握了 HashMap 和 HashSet 集合的功能。
class Name { private String first; private String last; public Name(String first, String last) { this.first = first; this.last = last; } public boolean equals(Object o) { if (this == o) { return true; } if (o.getClass() == Name.class) { Name n = (Name)o; return n.first.equals(first) &amp;&amp; n.last.equals(last); } return false; } } public class HashSetTest { public static void main(String[] args) { Set<Name> s = new HashSet<Name>(); s.add(new Name(&quot;abc&quot;, &quot;123&quot;)); System.out.println( s.contains(new Name(&quot;abc&quot;, &quot;123&quot;))); } }</p>
<p>上面程序中向 HashSet 里添加了一个 new Name(&quot;abc&quot;, &quot;123&quot;) 对象之后，立即通过程序判断该 HashSet 是否包含一个 new Name(&quot;abc&quot;, &quot;123&quot;) 对象。粗看上去，很容易以为该程序会输出 true。</p>
<p>实际运行上面程序将看到程序输出 false，这是因为 HashSet 判断两个对象相等的标准除了要求通过 equals() 方法比较返回 true 之外，还要求两个对象的 hashCode() 返回值相等。而上面程序没有重写 Name 类的 hashCode() 方法，两个 Name 对象的 hashCode() 返回值并不相同，因此 HashSet 会把它们当成 2 个对象处理，因此程序返回 false。</p>
<p>由此可见，当我们试图把某个类的对象当成 HashMap 的 key，或试图将这个类的对象放入 HashSet 中保存时，重写该类的 equals(Object obj) 方法和 hashCode() 方法很重要，而且这两个方法的返回值必须保持一致：当该类的两个的 hashCode() 返回值相同时，它们通过 equals() 方法比较也应该返回 true。通常来说，所有参与计算 hashCode() 返回值的关键属性，都应该用于作为 equals() 比较的标准。
<img src="" alt=""> <a href=""><strong>hashCode() 和 equals()</strong></a></p>
<p>关于如何正确地重写某个类的 hashCode() 方法和 equals() 方法，请参考疯狂 Java 体系的《疯狂 Java 讲义》一书中相关内容。</p>
<p>如下程序就正确重写了 Name 类的 hashCode() 和 equals() 方法，程序如下：
class Name { private String first; private String last; public Name(String first, String last) { this.first = first; this.last = last; } // 根据 first 判断两个 Name 是否相等 public boolean equals(Object o) { if (this == o) { return true; } if (o.getClass() == Name.class) { Name n = (Name)o; return n.first.equals(first); } return false; } // 根据 first 计算 Name 对象的 hashCode() 返回值 public int hashCode() { return first.hashCode(); } public String toString() { return &quot;Name[first=&quot; + first + &quot;, last=&quot; + last + &quot;]&quot;; } } public class HashSetTest2 { public static void main(String[] args) { HashSet<Name> set = new HashSet<Name>(); set.add(new Name(&quot;abc&quot; , &quot;123&quot;)); set.add(new Name(&quot;abc&quot; , &quot;456&quot;)); System.out.println(set); } }</p>
<p>上面程序中提供了一个 Name 类，该 Name 类重写了 equals() 和 toString() 两个方法，这两个方法都是根据 Name 类的 first 实例变量来判断的，当两个 Name 对象的 first 实例变量相等时，这两个 Name 对象的 hashCode() 返回值也相同，通过 equals() 比较也会返回 true。</p>
<p>程序主方法先将第一个 Name 对象添加到 HashSet 中，该 Name 对象的 first 实例变量值为&quot;abc&quot;，接着程序再次试图将一个 first 为&quot;abc&quot;的 Name 对象添加到 HashSet 中，很明显，此时没法将新的 Name 对象添加到该 HashSet 中，因为此处试图添加的 Name 对象的 first 也是&quot; abc&quot;，HashSet 会判断此处新增的 Name 对象与原有的 Name 对象相同，因此无法添加进入，程序在①号代码处输出 set 集合时将看到该集合里只包含一个 Name 对象，就是第一个、last 为&quot;123&quot;的 Name 对象。</p>
<p><a href="">参考资料</a></p>
<ul>
<li>“<a href="http://www.ibm.com/developerworks/cn/java/j-jtp05273/" target="_blank">Java 理论与实践: 哈希</a>”（developerWorks，2003 年 8 月）：介绍在创建 Java 类以有效和准确定义 hashCode() 和 equals() 时应遵循的规则和指南。</li>
<li>“<a href="http://www.ibm.com/developerworks/cn/java/j-jtp08223/" target="_blank">Java 理论与实践: 构建一个更好的 HashMap</a>”（developerWorks，2003 年 8 月）：BrianGoetz 仔细分析了 ConcurrentHashMap 的代码，并探讨 Doug Lea 是如何在不损失线程安全的情况下取得这么骄人成绩的。</li>
<li>“<a href="http://www.ibm.com/developerworks/cn/java/j-lo-hash/" target="_blank">Merlin 的魔力：维护插入顺序使用新链接的 HashSet 和 HashMap 实现</a>”（developerWorks，2001 年 10 月）：学习如何按插入顺序迭代散列集合中的各个元素，以及如何使用 J2SE，版本 1.4 中的新 Collections Framework 按存取顺序维护元素。</li>
<li>在 <a href="http://www.ibm.com/developerworks/cn/java/" target="_blank">developerWorks Java 技术专区</a> 上可以找到数百篇其他的 Java 参考资料。</li>
</ul>
<p><a href="">关于作者</a>
<img src="" alt=""> <img src="" alt="李刚照片">
 <img src="" alt=""> 
李刚，从事 Java EE 应用开发近 10 年。曾任 LITEON 公司的 J2EE 技术主管，负责该公司的企业信息化平台的架构设计。曾任广州电信、广东龙泉科技等公司的技术培训教师。疯狂 Java 联盟（<a href="http://www.crazyit.org）站长。疯狂" target="_blank">http://www.crazyit.org）站长。疯狂</a> Java 实训营创始人，疯狂 Java 体系图书作者，曾任东方标准广州中心软件教学总监，曾兼任广东技术师范学院计算机科学系的兼职副教授。国内知名IT技术作家，已出版《疯狂 Java 讲义》、《轻量级 Java EE 企业应用实战》、《疯狂 Ajax 讲义》、《Struts 2.1 权威指南》、《Ruby On Rails 敏捷开发最佳实践》等著作。</p>
<p><a href="">对本文的评价</a>
<img src="" alt=""> 太差！ (1) 需提高 (2) 一般；尚可 (3) 好文章 (4) 真棒！(5)
<strong>建议？</strong>
  <img src="" alt=""></p>
<p> <img src="" alt="">IBM 公司保留在 developerWorks 网站上发表的内容的著作权。未经IBM公司或原始作者的书面明确许可，请勿转载。如果您希望转载，请通过 <a href="https://www.ibm.com/developerworks/secure/reprintreq.jsp?domain=dwchina" target="_blank">提交转载请求表单</a> 联系我们的编辑团队。     <a href="http://www.ibm.com/cn/ibm/index.shtml" target="_blank">关于 IBM</a>      <a href="http://www.ibm.com/cn/ibm/privacy/index.shtml" target="_blank">隐私条约</a>      <a href="http://www.ibm.com/contact/cn/" target="_blank">联系 IBM</a>      <a href="http://www.ibm.com/legal/cn/zh/" target="_blank">使用条款</a>  <img src="" alt=""></p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/算法&数组&优化/">算法&数组&优化</a></li><li><a href="/categories/Java&J2EE/算法&数组&优化/数组&集合/">数组&集合</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/数组&集合/" class="label label-success">数组&集合</a><a href="/tags/算法&数组&优化/" class="label label-info">算法&数组&优化</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:40"datetime="2014-03-07 09:54:40"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-算法数组优化-数组集合--通过分析JDK源代码研究Hash存储机制/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-算法数组优化-数组集合--通过分析JDK源代码研究Hash存储机制" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-算法数组优化-加解密--Java加密技术（一）——BASE64与单向加密算法MD5SHAMAC/">Java加密技术（一）——BASE64与单向加密算法MD5&SHA&MAC</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:40.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-算法数组优化-加解密--Java加密技术（一）——BASE64与单向加密算法MD5SHAMAC/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="java-base64-md5-sha-mac">Java加密技术（一）——BASE64与单向加密算法MD5&amp;SHA&amp;MAC</h1>
<pre><code>加密解密，曾经是我一个毕业设计的重要组件。在工作了多年以后回想当时那个加密、解密算法，实在是太单纯了。![]()
言归正传，这里我们主要描述Java已经实现的一些加密解密算法，最后介绍数字证书。
如基本的单向加密算法：
</code></pre><ul>
<li>BASE64 严格地说，属于编码格式，而非加密算法</li>
<li>MD5(Message Digest algorithm 5，信息摘要算法)</li>
<li>SHA(Secure Hash Algorithm，安全散列算法)</li>
<li><p>HMAC(Hash Message Authentication Code，散列消息鉴别码)
  复杂的对称加密（DES、PBE）、非对称加密算法：</p>
</li>
<li><p>DES(Data Encryption Standard，数据加密算法)</p>
</li>
<li>PBE(Password-based encryption，基于密码验证)</li>
<li>RSA(算法的名字以发明者的名字命名：Ron Rivest, AdiShamir 和Leonard Adleman)</li>
<li>DH(Diffie-Hellman算法，密钥一致协议)</li>
<li>DSA(Digital Signature Algorithm，数字签名)</li>
<li>ECC(Elliptic Curves Cryptography，椭圆曲线密码编码学)
  本篇内容简要介绍<strong>BASE64</strong>、<strong>MD5</strong>、<strong>SHA</strong>、<strong>HMAC</strong>几种方法。
  <strong>MD5</strong>、<strong>SHA</strong>、<strong>HMAC</strong>这三种加密算法，可谓是非可逆加密，就是不可解密的加密方法。我们通常只把他们作为加密的基础。单纯的以上三种的加密并不可靠。
<strong>BASE64</strong>
按照RFC2045的定义，Base64被定义为：Base64内容传送编码被设计用来把任意序列的8位字节描述为一种不易被人直接识别的形式。（The Base64 Content-Transfer-Encoding is designed to represent arbitrary sequences of octets in a form that need not be humanly readable.）
常见于邮件、http加密，截取http信息，你就会发现登录操作的用户名、密码字段通过BASE64加密的。
<img src="" alt="">
通过java代码实现如下：
Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></li>
</ul>
<ol>
<li>//<em>/</em> </li>
<li>/* BASE64解密 </li>
<li>/*  </li>
<li>/* @param key </li>
<li>/* @return </li>
<li>/* @throws Exception </li>
<li>/*/  </li>
<li>public static byte[] decryptBASE64(String key) throws Exception {  </li>
<li>return (new BASE64Decoder()).decodeBuffer(key);  </li>
<li>}  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* BASE64加密 </li>
<li>/*  </li>
<li>/* @param key </li>
<li>/* @return </li>
<li>/* @throws Exception </li>
<li>/*/  </li>
<li>public static String encryptBASE64(byte[] key) throws Exception {  </li>
<li>return (new BASE64Encoder()).encodeBuffer(key);  </li>
<li><p>}  </p>
<p> //<em>/</em></p>
<p>  /<em> BASE64解密
  /</em></p>
<p>  /<em> @param key
  /</em> @return</p>
<p>  /<em> @throws Exception
  /</em>/</p>
<p> public static byte[] decryptBASE64(String key) throws Exception {</p>
<pre><code> return (new BASE64Decoder()).decodeBuffer(key);
</code></pre><p> }</p>
</li>
</ol>
<pre><code>//*/*
 /* BASE64加密

 /*
 /* @param key

 /* @return
 /* @throws Exception

 /*/
public static String encryptBASE64(byte[] key) throws Exception {

    return (new BASE64Encoder()).encodeBuffer(key);
}
</code></pre><p>主要就是BASE64Encoder、BASE64Decoder两个类，我们只需要知道使用对应的方法即可。另，BASE加密后产生的字节位数是8的倍数，如果不够位数以<strong>=</strong>符号填充。
<strong>MD5</strong>
MD5 -- message-digest algorithm 5 （信息-摘要算法）缩写，广泛用于加密和解密技术，常用于文件校验。校验？不管文件多大，经过MD5后都能生成唯一的MD5值。好比现在的ISO校验，都是MD5校验。怎么用？当然是把ISO经过MD5后产生MD5的值。一般下载linux-ISO的朋友都见过下载链接旁边放着MD5的串。就是用来验证文件是否一致的。
<img src="" alt="">
通过java代码实现如下：
Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>//<em>/</em> </li>
<li>/* MD5加密 </li>
<li>/*  </li>
<li>/* @param data </li>
<li>/* @return </li>
<li>/* @throws Exception </li>
<li>/*/  </li>
<li>public static byte[] encryptMD5(byte[] data) throws Exception {  </li>
<li></li>
<li>MessageDigest md5 = MessageDigest.getInstance(KEY_MD5);  </li>
<li>md5.update(data);  </li>
<li></li>
<li>return md5.digest();  </li>
<li></li>
<li><p>}  </p>
<p> //<em>/</em></p>
<p>  /<em> MD5加密
  /</em></p>
<p>  /<em> @param data
  /</em> @return</p>
<p>  /<em> @throws Exception
  /</em>/</p>
<p> public static byte[] encryptMD5(byte[] data) throws Exception {</p>
</li>
</ol>
<pre><code>    MessageDigest md5 = MessageDigest.getInstance(KEY_MD5);
    md5.update(data);


    return md5.digest();


}
</code></pre><p>通常我们不直接使用上述MD5加密。通常将MD5产生的字节数组交给BASE64再加密一把，得到相应的字符串。
<strong>SHA</strong>
SHA(Secure Hash Algorithm，安全散列算法），数字签名等密码学应用中重要的工具，被广泛地应用于电子商务等信息安全领域。虽然，SHA与MD5通过碰撞法都被破解了，<img src="" alt=""> 但是SHA仍然是公认的安全加密算法，较之MD5更为安全。<img src="" alt="">
<img src="" alt="">
通过java代码实现如下：
Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>//<em>/</em> </li>
<li>/* SHA加密 </li>
<li>/*  </li>
<li>/* @param data </li>
<li>/* @return </li>
<li>/* @throws Exception </li>
<li>/*/  </li>
<li>public static byte[] encryptSHA(byte[] data) throws Exception {  </li>
<li></li>
<li>MessageDigest sha = MessageDigest.getInstance(KEY_SHA);  </li>
<li>sha.update(data);  </li>
<li></li>
<li>return sha.digest();  </li>
<li></li>
<li>}  </li>
<li><p>}  </p>
<p> //<em>/</em></p>
<p>  /<em> SHA加密
  /</em></p>
<p>  /<em> @param data
  /</em> @return</p>
<p>  /<em> @throws Exception
  /</em>/</p>
<p> public static byte[] encryptSHA(byte[] data) throws Exception {</p>
</li>
</ol>
<pre><code>    MessageDigest sha = MessageDigest.getInstance(KEY_SHA);
    sha.update(data);


    return sha.digest();


}
</code></pre><p>}
<strong>HMAC</strong>
HMAC(Hash Message Authentication Code，散列消息鉴别码，基于密钥的Hash算法的认证协议。消息鉴别码实现鉴别的原理是，用公开函数和密钥产生一个固定长度的值作为认证标识，用这个标识鉴别消息的完整性。使用一个密钥生成一个固定大小的小数据块，即MAC，并将其加入到消息中，然后传输。接收方利用与发送方共享的密钥进行鉴别认证等。
<img src="" alt="">
通过java代码实现如下：
Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>//<em>/</em> </li>
<li>/* 初始化HMAC密钥 </li>
<li>/*  </li>
<li>/* @return </li>
<li>/* @throws Exception </li>
<li>/*/  </li>
<li>public static String initMacKey() throws Exception {  </li>
<li>KeyGenerator keyGenerator = KeyGenerator.getInstance(KEY_MAC);  </li>
<li></li>
<li>SecretKey secretKey = keyGenerator.generateKey();  </li>
<li>return encryptBASE64(secretKey.getEncoded());  </li>
<li>}  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* HMAC加密 </li>
<li>/*  </li>
<li>/* @param data </li>
<li>/* @param key </li>
<li>/* @return </li>
<li>/* @throws Exception </li>
<li>/*/  </li>
<li>public static byte[] encryptHMAC(byte[] data, String key) throws Exception {  </li>
<li></li>
<li>SecretKey secretKey = new SecretKeySpec(decryptBASE64(key), KEY_MAC);  </li>
<li>Mac mac = Mac.getInstance(secretKey.getAlgorithm());  </li>
<li>mac.init(secretKey);  </li>
<li></li>
<li>return mac.doFinal(data);  </li>
<li></li>
<li><p>}  </p>
<p> //<em>/</em></p>
<p>  /<em> 初始化HMAC密钥
  /</em></p>
<p>  /<em> @return
  /</em> @throws Exception</p>
<p>  /*/
 public static String initMacKey() throws Exception {</p>
<pre><code> KeyGenerator keyGenerator = KeyGenerator.getInstance(KEY_MAC);
</code></pre></li>
</ol>
<pre><code>    SecretKey secretKey = keyGenerator.generateKey();
    return encryptBASE64(secretKey.getEncoded());

}


//*/*
 /* HMAC加密

 /*
 /* @param data

 /* @param key
 /* @return

 /* @throws Exception
 /*/

public static byte[] encryptHMAC(byte[] data, String key) throws Exception {


    SecretKey secretKey = new SecretKeySpec(decryptBASE64(key), KEY_MAC);
    Mac mac = Mac.getInstance(secretKey.getAlgorithm());

    mac.init(secretKey);


    return mac.doFinal(data);


}
</code></pre><p>给出一个完整类，如下：
Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>import java.security.MessageDigest;  </li>
<li></li>
<li>import javax.crypto.KeyGenerator;  </li>
<li>import javax.crypto.Mac;  </li>
<li>import javax.crypto.SecretKey;  </li>
<li></li>
<li>import sun.misc.BASE64Decoder;  </li>
<li>import sun.misc.BASE64Encoder;  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* 基础加密组件 </li>
<li>/*  </li>
<li>/* @author 梁栋 </li>
<li>/* @version 1.0 </li>
<li>/* @since 1.0 </li>
<li>/*/  </li>
<li>public abstract class Coder {  </li>
<li>public static final String KEY_SHA = &quot;SHA&quot;;  </li>
<li>public static final String KEY_MD5 = &quot;MD5&quot;;  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* MAC算法可选以下多种算法 </li>
<li>/*  </li>
<li>/* <pre> </li>
<li>/* HmacMD5  </li>
<li>/* HmacSHA1  </li>
<li>/* HmacSHA256  </li>
<li>/* HmacSHA384  </li>
<li>/* HmacSHA512 </li>
<li>/* </pre> </li>
<li>/*/  </li>
<li>public static final String KEY_MAC = &quot;HmacMD5&quot;;  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* BASE64解密 </li>
<li>/*  </li>
<li>/* @param key </li>
<li>/* @return </li>
<li>/* @throws Exception </li>
<li>/*/  </li>
<li>public static byte[] decryptBASE64(String key) throws Exception {  </li>
<li>return (new BASE64Decoder()).decodeBuffer(key);  </li>
<li>}  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* BASE64加密 </li>
<li>/*  </li>
<li>/* @param key </li>
<li>/* @return </li>
<li>/* @throws Exception </li>
<li>/*/  </li>
<li>public static String encryptBASE64(byte[] key) throws Exception {  </li>
<li>return (new BASE64Encoder()).encodeBuffer(key);  </li>
<li>}  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* MD5加密 </li>
<li>/*  </li>
<li>/* @param data </li>
<li>/* @return </li>
<li>/* @throws Exception </li>
<li>/*/  </li>
<li>public static byte[] encryptMD5(byte[] data) throws Exception {  </li>
<li></li>
<li>MessageDigest md5 = MessageDigest.getInstance(KEY_MD5);  </li>
<li>md5.update(data);  </li>
<li></li>
<li>return md5.digest();  </li>
<li></li>
<li>}  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* SHA加密 </li>
<li>/*  </li>
<li>/* @param data </li>
<li>/* @return </li>
<li>/* @throws Exception </li>
<li>/*/  </li>
<li>public static byte[] encryptSHA(byte[] data) throws Exception {  </li>
<li></li>
<li>MessageDigest sha = MessageDigest.getInstance(KEY_SHA);  </li>
<li>sha.update(data);  </li>
<li></li>
<li>return sha.digest();  </li>
<li></li>
<li>}  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* 初始化HMAC密钥 </li>
<li>/*  </li>
<li>/* @return </li>
<li>/* @throws Exception </li>
<li>/*/  </li>
<li>public static String initMacKey() throws Exception {  </li>
<li>KeyGenerator keyGenerator = KeyGenerator.getInstance(KEY_MAC);  </li>
<li></li>
<li>SecretKey secretKey = keyGenerator.generateKey();  </li>
<li>return encryptBASE64(secretKey.getEncoded());  </li>
<li>}  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* HMAC加密 </li>
<li>/*  </li>
<li>/* @param data </li>
<li>/* @param key </li>
<li>/* @return </li>
<li>/* @throws Exception </li>
<li>/*/  </li>
<li>public static byte[] encryptHMAC(byte[] data, String key) throws Exception {  </li>
<li></li>
<li>SecretKey secretKey = new SecretKeySpec(decryptBASE64(key), KEY_MAC);  </li>
<li>Mac mac = Mac.getInstance(secretKey.getAlgorithm());  </li>
<li>mac.init(secretKey);  </li>
<li></li>
<li>return mac.doFinal(data);  </li>
<li></li>
<li>}  </li>
<li>}  </li>
</ol>
<p>import java.security.MessageDigest;</p>
<p>import javax.crypto.KeyGenerator;</p>
<p>import javax.crypto.Mac;
import javax.crypto.SecretKey;</p>
<p>import sun.misc.BASE64Decoder;</p>
<p>import sun.misc.BASE64Encoder;</p>
<p>//<em>/</em>
/* 基础加密组件</p>
<p>/<em>
/</em> @author 梁栋</p>
<p>/<em> @version 1.0
/</em> @since 1.0</p>
<p>/*/
public abstract class Coder {</p>
<pre><code>public static final String KEY_SHA = &quot;SHA&quot;;
public static final String KEY_MD5 = &quot;MD5&quot;;


//*/*

 /* MAC算法可选以下多种算法
 /*

 /* &lt;pre&gt;
 /* HmacMD5

 /* HmacSHA1
 /* HmacSHA256

 /* HmacSHA384
 /* HmacSHA512

 /* &lt;/pre&gt;
 /*/

public static final String KEY_MAC = &quot;HmacMD5&quot;;


//*/*
 /* BASE64解密

 /*
 /* @param key

 /* @return
 /* @throws Exception

 /*/
public static byte[] decryptBASE64(String key) throws Exception {

    return (new BASE64Decoder()).decodeBuffer(key);
}


//*/*

 /* BASE64加密
 /*

 /* @param key
 /* @return

 /* @throws Exception
 /*/

public static String encryptBASE64(byte[] key) throws Exception {
    return (new BASE64Encoder()).encodeBuffer(key);

}


//*/*
 /* MD5加密

 /*
 /* @param data

 /* @return
 /* @throws Exception

 /*/
public static byte[] encryptMD5(byte[] data) throws Exception {


    MessageDigest md5 = MessageDigest.getInstance(KEY_MD5);

    md5.update(data);


    return md5.digest();


}


//*/*
 /* SHA加密

 /*
 /* @param data

 /* @return
 /* @throws Exception

 /*/
public static byte[] encryptSHA(byte[] data) throws Exception {


    MessageDigest sha = MessageDigest.getInstance(KEY_SHA);

    sha.update(data);


    return sha.digest();


}


//*/*
 /* 初始化HMAC密钥

 /*
 /* @return

 /* @throws Exception
 /*/

public static String initMacKey() throws Exception {
    KeyGenerator keyGenerator = KeyGenerator.getInstance(KEY_MAC);


    SecretKey secretKey = keyGenerator.generateKey();

    return encryptBASE64(secretKey.getEncoded());
}


//*/*

 /* HMAC加密
 /*

 /* @param data
 /* @param key

 /* @return
 /* @throws Exception

 /*/
public static byte[] encryptHMAC(byte[] data, String key) throws Exception {


    SecretKey secretKey = new SecretKeySpec(decryptBASE64(key), KEY_MAC);

    Mac mac = Mac.getInstance(secretKey.getAlgorithm());
    mac.init(secretKey);


    return mac.doFinal(data);


}
</code></pre><p>}
再给出一个测试类：
Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>import static org.junit.Assert./*;  </li>
<li></li>
<li>import org.junit.Test;  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/*  </li>
<li>/* @author 梁栋 </li>
<li>/* @version 1.0 </li>
<li>/* @since 1.0 </li>
<li>/*/  </li>
<li>public class CoderTest {  </li>
<li></li>
<li>@Test  </li>
<li>public void test() throws Exception {  </li>
<li>String inputStr = &quot;简单加密&quot;;  </li>
<li>System.err.println(&quot;原文:\n&quot; + inputStr);  </li>
<li></li>
<li>byte[] inputData = inputStr.getBytes();  </li>
<li>String code = Coder.encryptBASE64(inputData);  </li>
<li></li>
<li>System.err.println(&quot;BASE64加密后:\n&quot; + code);  </li>
<li></li>
<li>byte[] output = Coder.decryptBASE64(code);  </li>
<li></li>
<li>String outputStr = new String(output);  </li>
<li></li>
<li>System.err.println(&quot;BASE64解密后:\n&quot; + outputStr);  </li>
<li></li>
<li>// 验证BASE64加密解密一致性  </li>
<li>assertEquals(inputStr, outputStr);  </li>
<li></li>
<li>// 验证MD5对于同一内容加密是否一致  </li>
<li>assertArrayEquals(Coder.encryptMD5(inputData), Coder  </li>
<li>.encryptMD5(inputData));  </li>
<li></li>
<li>// 验证SHA对于同一内容加密是否一致  </li>
<li>assertArrayEquals(Coder.encryptSHA(inputData), Coder  </li>
<li>.encryptSHA(inputData));  </li>
<li></li>
<li>String key = Coder.initMacKey();  </li>
<li>System.err.println(&quot;Mac密钥:\n&quot; + key);  </li>
<li></li>
<li>// 验证HMAC对于同一内容，同一密钥加密是否一致  </li>
<li>assertArrayEquals(Coder.encryptHMAC(inputData, key), Coder.encryptHMAC(  </li>
<li>inputData, key));  </li>
<li></li>
<li>BigInteger md5 = new BigInteger(Coder.encryptMD5(inputData));  </li>
<li>System.err.println(&quot;MD5:\n&quot; + md5.toString(16));  </li>
<li></li>
<li>BigInteger sha = new BigInteger(Coder.encryptSHA(inputData));  </li>
<li>System.err.println(&quot;SHA:\n&quot; + sha.toString(32));  </li>
<li></li>
<li>BigInteger mac = new BigInteger(Coder.encryptHMAC(inputData, inputStr));  </li>
<li>System.err.println(&quot;HMAC:\n&quot; + mac.toString(16));  </li>
<li>}  </li>
<li>}  </li>
</ol>
<p>import static org.junit.Assert./*;</p>
<p>import org.junit.Test;</p>
<p>//<em>/</em></p>
<p>/<em>
/</em> @author 梁栋</p>
<p>/<em> @version 1.0
/</em> @since 1.0</p>
<p>/*/
public class CoderTest {</p>
<pre><code>@Test

public void test() throws Exception {
    String inputStr = &quot;简单加密&quot;;

    System.err.println(&quot;原文:\n&quot; + inputStr);


    byte[] inputData = inputStr.getBytes();
    String code = Coder.encryptBASE64(inputData);


    System.err.println(&quot;BASE64加密后:\n&quot; + code);


    byte[] output = Coder.decryptBASE64(code);


    String outputStr = new String(output);


    System.err.println(&quot;BASE64解密后:\n&quot; + outputStr);


    // 验证BASE64加密解密一致性

    assertEquals(inputStr, outputStr);


    // 验证MD5对于同一内容加密是否一致
    assertArrayEquals(Coder.encryptMD5(inputData), Coder

            .encryptMD5(inputData));


    // 验证SHA对于同一内容加密是否一致
    assertArrayEquals(Coder.encryptSHA(inputData), Coder

            .encryptSHA(inputData));


    String key = Coder.initMacKey();
    System.err.println(&quot;Mac密钥:\n&quot; + key);


    // 验证HMAC对于同一内容，同一密钥加密是否一致

    assertArrayEquals(Coder.encryptHMAC(inputData, key), Coder.encryptHMAC(
            inputData, key));


    BigInteger md5 = new BigInteger(Coder.encryptMD5(inputData));

    System.err.println(&quot;MD5:\n&quot; + md5.toString(16));


    BigInteger sha = new BigInteger(Coder.encryptSHA(inputData));
    System.err.println(&quot;SHA:\n&quot; + sha.toString(32));


    BigInteger mac = new BigInteger(Coder.encryptHMAC(inputData, inputStr));

    System.err.println(&quot;HMAC:\n&quot; + mac.toString(16));
}
</code></pre><p>}
控制台输出：
Console代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>原文:  </li>
<li>简单加密  </li>
<li>BASE64加密后:  </li>
<li>566A5Y2V5Yqg5a+G  </li>
<li></li>
<li>BASE64解密后:  </li>
<li>简单加密  </li>
<li>Mac密钥:  </li>
<li>uGxdHC+6ylRDaik++leFtGwiMbuYUJ6mqHWyhSgF4trVkVBBSQvY/a22xU8XT1RUemdCWW155Bke  </li>
<li>pBIpkd7QHg==  </li>
<li></li>
<li>MD5:  </li>
<li>-550b4d90349ad4629462113e7934de56  </li>
<li>SHA:  </li>
<li>91k9vo7p400cjkgfhjh0ia9qthsjagfn  </li>
<li>HMAC:  </li>
<li>2287d192387e95694bdbba2fa941009a  </li>
</ol>
<p>原文:</p>
<p>简单加密
BASE64加密后:</p>
<p>566A5Y2V5Yqg5a+G</p>
<p>BASE64解密后:
简单加密</p>
<p>Mac密钥:
uGxdHC+6ylRDaik++leFtGwiMbuYUJ6mqHWyhSgF4trVkVBBSQvY/a22xU8XT1RUemdCWW155Bke</p>
<p>pBIpkd7QHg==</p>
<p>MD5:
-550b4d90349ad4629462113e7934de56</p>
<p>SHA:
91k9vo7p400cjkgfhjh0ia9qthsjagfn</p>
<p>HMAC:
2287d192387e95694bdbba2fa941009a</p>
<p>注意
编译时，可能会看到如下提示：
引用</p>
<p>警告：sun.misc.BASE64Decoder 是 Sun 的专用 API，可能会在未来版本中删除
import sun.misc.BASE64Decoder;
               ^
警告：sun.misc.BASE64Encoder 是 Sun 的专用 API，可能会在未来版本中删除
import sun.misc.BASE64Encoder;
               ^
BASE64Encoder和BASE64Decoder是非官方JDK实现类。虽然可以在JDK里能找到并使用，但是在API里查不到。JRE 中 sun 和 com.sun 开头包的类都是未被文档化的，他们属于 java, javax 类库的基础，其中的实现大多数与底层平台有关，一般来说是不推荐使用的。
    BASE64的加密解密是双向的，可以求反解。
    MD5、SHA以及HMAC是单向加密，任何数据加密后只会产生唯一的一个加密串，通常用来校验数据在传输过程中是否被修改。其中HMAC算法有一个密钥，增强了数据传输过程中的安全性，强化了算法外的不可控因素。<img src="" alt="">
    单向加密的用途主要是为了校验数据在传输过程中是否被修改。
<strong>相关链接：
<a href="http://snowolf.iteye.com/blog/379860" target="_blank">Java加密技术（一）——BASE64与单向加密算法MD5&amp;SHA&amp;MAC</a>
<a href="http://snowolf.iteye.com/blog/380034" target="_blank">Java加密技术（二）——对称加密DES&amp;AES</a>
<a href="http://snowolf.iteye.com/blog/380761" target="_blank">Java加密技术（三）——PBE算法</a>
<a href="http://snowolf.iteye.com/blog/381767" target="_blank">Java加密技术（四）——非对称加密算法RSA</a>
<a href="http://snowolf.iteye.com/blog/382422" target="_blank">Java加密技术（五）——非对称加密算法的由来DH</a>
<a href="http://snowolf.iteye.com/blog/382749" target="_blank">Java加密技术（六）——数字签名算法DSA</a>
<a href="http://snowolf.iteye.com/blog/383412" target="_blank">Java加密技术（七）——非对称加密算法最高ECC</a>
<a href="http://snowolf.iteye.com/blog/391931" target="_blank">Java加密技术（八）——数字证书</a>
<a href="http://snowolf.iteye.com/blog/397693" target="_blank">Java加密技术（九）——初探SSL</a>
<a href="http://snowolf.iteye.com/blog/398198" target="_blank">Java加密技术（十）——单向认证</a>
<a href="http://snowolf.iteye.com/blog/510985" target="_blank">Java加密技术（十一）——双向认证</a>
<a href="http://snowolf.iteye.com/blog/735294" target="_blank">Java加密技术（十二）——/<em>.PFX(/</em>.p12)&amp;个人信息交换文件</a>
</strong></p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/算法&数组&优化/">算法&数组&优化</a></li><li><a href="/categories/Java&J2EE/算法&数组&优化/加解密/">加解密</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/加解密/" class="label label-success">加解密</a><a href="/tags/算法&数组&优化/" class="label label-info">算法&数组&优化</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:40"datetime="2014-03-07 09:54:40"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-算法数组优化-加解密--Java加密技术（一）——BASE64与单向加密算法MD5SHAMAC/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-算法数组优化-加解密--Java加密技术（一）——BASE64与单向加密算法MD5SHAMAC" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-算法数组优化-加解密--Java加密技术（八）——数字证书/">Java加密技术（八）——数字证书</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:40.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-算法数组优化-加解密--Java加密技术（八）——数字证书/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="java-">Java加密技术（八）——数字证书</h1>
<pre><code>本篇的主要内容为Java证书体系的实现。![]()
</code></pre><p><strong>请大家在阅读本篇内容时先阅读 <a href="http://snowolf.iteye.com/blog/381767" target="_blank">Java加密技术（四）</a>，预先了解RSA加密算法。</strong><img src="" alt="">
在构建Java代码实现前，我们需要完成证书的制作。
1.生成keyStroe文件
在命令行下执行以下命令：
Shell代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>keytool -genkey -validity 36000 -alias www.zlex.org -keyalg RSA -keystore d:\zlex.keystore  </li>
</ol>
<p>keytool -genkey -validity 36000 -alias www.zlex.org -keyalg RSA -keystore d:\zlex.keystore
其中
<strong>-genkey</strong>表示生成密钥
<strong>-validity</strong>指定证书有效期，这里是<strong>36000</strong>天
<strong>-alias</strong>指定别名，这里是<strong>www.zlex.org</strong>
<strong>-keyalg</strong>指定算法，这里是<strong>RSA</strong>
<strong>-keystore</strong>指定存储位置，这里是<strong>d:\zlex.keystore</strong>
在这里我使用的密码为 <strong>123456</strong>
控制台输出：
Console代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>输入keystore密码：  </li>
<li>再次输入新密码:  </li>
<li>您的名字与姓氏是什么？  </li>
<li>[Unknown]：  www.zlex.org  </li>
<li>您的组织单位名称是什么？  </li>
<li>[Unknown]：  zlex  </li>
<li>您的组织名称是什么？  </li>
<li>[Unknown]：  zlex  </li>
<li>您所在的城市或区域名称是什么？  </li>
<li>[Unknown]：  BJ  </li>
<li>您所在的州或省份名称是什么？  </li>
<li>[Unknown]：  BJ  </li>
<li>该单位的两字母国家代码是什么  </li>
<li>[Unknown]：  CN  </li>
<li>CN=www.zlex.org, OU=zlex, O=zlex, L=BJ, ST=BJ, C=CN 正确吗？  </li>
<li>[否]：  Y  </li>
<li></li>
<li>输入<tomcat>的主密码  </li>
<li>（如果和 keystore 密码相同，按回车）：  </li>
<li>再次输入新密码:  </li>
</ol>
<p>输入keystore密码：</p>
<p>再次输入新密码:
您的名字与姓氏是什么？</p>
<p>  [Unknown]：  www.zlex.org
您的组织单位名称是什么？</p>
<p>  [Unknown]：  zlex
您的组织名称是什么？</p>
<p>  [Unknown]：  zlex
您所在的城市或区域名称是什么？</p>
<p>  [Unknown]：  BJ
您所在的州或省份名称是什么？</p>
<p>  [Unknown]：  BJ
该单位的两字母国家代码是什么</p>
<p>  [Unknown]：  CN
CN=www.zlex.org, OU=zlex, O=zlex, L=BJ, ST=BJ, C=CN 正确吗？</p>
<p>  [否]：  Y</p>
<p>输入<tomcat>的主密码
        （如果和 keystore 密码相同，按回车）：</p>
<p>再次输入新密码:</p>
<p>这时，在D盘下会生成一个zlex.keystore的文件。
2.生成自签名证书
光有keyStore文件是不够的，还需要证书文件，证书才是直接提供给外界使用的公钥凭证。
导出证书：
Shell代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>keytool -export -keystore d:\zlex.keystore -alias www.zlex.org -file d:\zlex.cer -rfc  </li>
</ol>
<p>keytool -export -keystore d:\zlex.keystore -alias www.zlex.org -file d:\zlex.cer -rfc
其中
<strong>-export</strong>指定为导出操作
<strong>-keystore</strong>指定<strong>keystore文件</strong>
<strong>-alias</strong>指定导出<strong>keystore文件中的别名</strong>
<strong>-file</strong>指向<strong>导出路径</strong>
<strong>-rfc</strong>以文本格式输出，也就是以<strong>BASE64编码</strong>输出
这里的密码是 <strong>123456</strong>
控制台输出：
Console代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>输入keystore密码：  </li>
<li>保存在文件中的认证 <d:\zlex.cer>  </li>
</ol>
<p>输入keystore密码：</p>
<p>保存在文件中的认证 <d:\zlex.cer>
当然，使用方是需要导入证书的！
可以通过自签名证书完成CAS单点登录系统的构建！<img src="" alt="">
Ok，准备工作完成，开始Java实现！
通过java代码实现如下：<strong>Coder类见 <a href="http://snowolf.iteye.com/blog/379860" target="_blank">Java加密技术（一）</a></strong>
Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>import java.io.FileInputStream;  </li>
<li>import java.security.KeyStore;  </li>
<li>import java.security.PrivateKey;  </li>
<li>import java.security.PublicKey;  </li>
<li>import java.security.Signature;  </li>
<li>import java.security.cert.Certificate;  </li>
<li>import java.security.cert.CertificateFactory;  </li>
<li>import java.security.cert.X509Certificate;  </li>
<li>import java.util.Date;  </li>
<li></li>
<li>import javax.crypto.Cipher;  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* 证书组件 </li>
<li>/*  </li>
<li>/* @author 梁栋 </li>
<li>/* @version 1.0 </li>
<li>/* @since 1.0 </li>
<li>/*/  </li>
<li>public abstract class CertificateCoder extends Coder {  </li>
<li></li>
<li></li>
<li>//<em>/</em> </li>
<li>/* Java密钥库(Java Key Store，JKS)KEY_STORE </li>
<li>/*/  </li>
<li>public static final String KEY_STORE = &quot;JKS&quot;;  </li>
<li></li>
<li>public static final String X509 = &quot;X.509&quot;;  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* 由KeyStore获得私钥 </li>
<li>/*  </li>
<li>/* @param keyStorePath </li>
<li>/* @param alias </li>
<li>/* @param password </li>
<li>/* @return </li>
<li>/* @throws Exception </li>
<li>/*/  </li>
<li>private static PrivateKey getPrivateKey(String keyStorePath, String alias,  </li>
<li>String password) throws Exception {  </li>
<li>KeyStore ks = getKeyStore(keyStorePath, password);  </li>
<li>PrivateKey key = (PrivateKey) ks.getKey(alias, password.toCharArray());  </li>
<li>return key;  </li>
<li>}  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* 由Certificate获得公钥 </li>
<li>/*  </li>
<li>/* @param certificatePath </li>
<li>/* @return </li>
<li>/* @throws Exception </li>
<li>/*/  </li>
<li>private static PublicKey getPublicKey(String certificatePath)  </li>
<li>throws Exception {  </li>
<li>Certificate certificate = getCertificate(certificatePath);  </li>
<li>PublicKey key = certificate.getPublicKey();  </li>
<li>return key;  </li>
<li>}  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* 获得Certificate </li>
<li>/*  </li>
<li>/* @param certificatePath </li>
<li>/* @return </li>
<li>/* @throws Exception </li>
<li>/*/  </li>
<li>private static Certificate getCertificate(String certificatePath)  </li>
<li>throws Exception {  </li>
<li>CertificateFactory certificateFactory = CertificateFactory  </li>
<li>.getInstance(X509);  </li>
<li>FileInputStream in = new FileInputStream(certificatePath);  </li>
<li></li>
<li>Certificate certificate = certificateFactory.generateCertificate(in);  </li>
<li>in.close();  </li>
<li></li>
<li>return certificate;  </li>
<li>}  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* 获得Certificate </li>
<li>/*  </li>
<li>/* @param keyStorePath </li>
<li>/* @param alias </li>
<li>/* @param password </li>
<li>/* @return </li>
<li>/* @throws Exception </li>
<li>/*/  </li>
<li>private static Certificate getCertificate(String keyStorePath,  </li>
<li>String alias, String password) throws Exception {  </li>
<li>KeyStore ks = getKeyStore(keyStorePath, password);  </li>
<li>Certificate certificate = ks.getCertificate(alias);  </li>
<li></li>
<li>return certificate;  </li>
<li>}  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* 获得KeyStore </li>
<li>/*  </li>
<li>/* @param keyStorePath </li>
<li>/* @param password </li>
<li>/* @return </li>
<li>/* @throws Exception </li>
<li>/*/  </li>
<li>private static KeyStore getKeyStore(String keyStorePath, String password)  </li>
<li>throws Exception {  </li>
<li>FileInputStream is = new FileInputStream(keyStorePath);  </li>
<li>KeyStore ks = KeyStore.getInstance(KEY_STORE);  </li>
<li>ks.load(is, password.toCharArray());  </li>
<li>is.close();  </li>
<li>return ks;  </li>
<li>}  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* 私钥加密 </li>
<li>/*  </li>
<li>/* @param data </li>
<li>/* @param keyStorePath </li>
<li>/* @param alias </li>
<li>/* @param password </li>
<li>/* @return </li>
<li>/* @throws Exception </li>
<li>/*/  </li>
<li>public static byte[] encryptByPrivateKey(byte[] data, String keyStorePath,  </li>
<li>String alias, String password) throws Exception {  </li>
<li>// 取得私钥  </li>
<li>PrivateKey privateKey = getPrivateKey(keyStorePath, alias, password);  </li>
<li></li>
<li>// 对数据加密  </li>
<li>Cipher cipher = Cipher.getInstance(privateKey.getAlgorithm());  </li>
<li>cipher.init(Cipher.ENCRYPT_MODE, privateKey);  </li>
<li></li>
<li>return cipher.doFinal(data);  </li>
<li></li>
<li>}  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* 私钥解密 </li>
<li>/*  </li>
<li>/* @param data </li>
<li>/* @param keyStorePath </li>
<li>/* @param alias </li>
<li>/* @param password </li>
<li>/* @return </li>
<li>/* @throws Exception </li>
<li>/*/  </li>
<li>public static byte[] decryptByPrivateKey(byte[] data, String keyStorePath,  </li>
<li>String alias, String password) throws Exception {  </li>
<li>// 取得私钥  </li>
<li>PrivateKey privateKey = getPrivateKey(keyStorePath, alias, password);  </li>
<li></li>
<li>// 对数据加密  </li>
<li>Cipher cipher = Cipher.getInstance(privateKey.getAlgorithm());  </li>
<li>cipher.init(Cipher.DECRYPT_MODE, privateKey);  </li>
<li></li>
<li>return cipher.doFinal(data);  </li>
<li></li>
<li>}  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* 公钥加密 </li>
<li>/*  </li>
<li>/* @param data </li>
<li>/* @param certificatePath </li>
<li>/* @return </li>
<li>/* @throws Exception </li>
<li>/*/  </li>
<li>public static byte[] encryptByPublicKey(byte[] data, String certificatePath)  </li>
<li>throws Exception {  </li>
<li></li>
<li>// 取得公钥  </li>
<li>PublicKey publicKey = getPublicKey(certificatePath);  </li>
<li>// 对数据加密  </li>
<li>Cipher cipher = Cipher.getInstance(publicKey.getAlgorithm());  </li>
<li>cipher.init(Cipher.ENCRYPT_MODE, publicKey);  </li>
<li></li>
<li>return cipher.doFinal(data);  </li>
<li></li>
<li>}  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* 公钥解密 </li>
<li>/*  </li>
<li>/* @param data </li>
<li>/* @param certificatePath </li>
<li>/* @return </li>
<li>/* @throws Exception </li>
<li>/*/  </li>
<li>public static byte[] decryptByPublicKey(byte[] data, String certificatePath)  </li>
<li>throws Exception {  </li>
<li>// 取得公钥  </li>
<li>PublicKey publicKey = getPublicKey(certificatePath);  </li>
<li></li>
<li>// 对数据加密  </li>
<li>Cipher cipher = Cipher.getInstance(publicKey.getAlgorithm());  </li>
<li>cipher.init(Cipher.DECRYPT_MODE, publicKey);  </li>
<li></li>
<li>return cipher.doFinal(data);  </li>
<li></li>
<li>}  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* 验证Certificate </li>
<li>/*  </li>
<li>/* @param certificatePath </li>
<li>/* @return </li>
<li>/*/  </li>
<li>public static boolean verifyCertificate(String certificatePath) {  </li>
<li>return verifyCertificate(new Date(), certificatePath);  </li>
<li>}  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* 验证Certificate是否过期或无效 </li>
<li>/*  </li>
<li>/* @param date </li>
<li>/* @param certificatePath </li>
<li>/* @return </li>
<li>/*/  </li>
<li>public static boolean verifyCertificate(Date date, String certificatePath) {  </li>
<li>boolean status = true;  </li>
<li>try {  </li>
<li>// 取得证书  </li>
<li>Certificate certificate = getCertificate(certificatePath);  </li>
<li>// 验证证书是否过期或无效  </li>
<li>status = verifyCertificate(date, certificate);  </li>
<li>} catch (Exception e) {  </li>
<li>status = false;  </li>
<li>}  </li>
<li>return status;  </li>
<li>}  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* 验证证书是否过期或无效 </li>
<li>/*  </li>
<li>/* @param date </li>
<li>/* @param certificate </li>
<li>/* @return </li>
<li>/*/  </li>
<li>private static boolean verifyCertificate(Date date, Certificate certificate) {  </li>
<li>boolean status = true;  </li>
<li>try {  </li>
<li>X509Certificate x509Certificate = (X509Certificate) certificate;  </li>
<li>x509Certificate.checkValidity(date);  </li>
<li>} catch (Exception e) {  </li>
<li>status = false;  </li>
<li>}  </li>
<li>return status;  </li>
<li>}  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* 签名 </li>
<li>/*  </li>
<li>/* @param keyStorePath </li>
<li>/* @param alias </li>
<li>/* @param password </li>
<li>/*  </li>
<li>/* @return </li>
<li>/* @throws Exception </li>
<li>/*/  </li>
<li>public static String sign(byte[] sign, String keyStorePath, String alias,  </li>
<li>String password) throws Exception {  </li>
<li>// 获得证书  </li>
<li>X509Certificate x509Certificate = (X509Certificate) getCertificate(  </li>
<li>keyStorePath, alias, password);  </li>
<li>// 获取私钥  </li>
<li>KeyStore ks = getKeyStore(keyStorePath, password);  </li>
<li>// 取得私钥  </li>
<li>PrivateKey privateKey = (PrivateKey) ks.getKey(alias, password  </li>
<li>.toCharArray());  </li>
<li></li>
<li>// 构建签名  </li>
<li>Signature signature = Signature.getInstance(x509Certificate  </li>
<li>.getSigAlgName());  </li>
<li>signature.initSign(privateKey);  </li>
<li>signature.update(sign);  </li>
<li>return encryptBASE64(signature.sign());  </li>
<li>}  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* 验证签名 </li>
<li>/*  </li>
<li>/* @param data </li>
<li>/* @param sign </li>
<li>/* @param certificatePath </li>
<li>/* @return </li>
<li>/* @throws Exception </li>
<li>/*/  </li>
<li>public static boolean verify(byte[] data, String sign,  </li>
<li>String certificatePath) throws Exception {  </li>
<li>// 获得证书  </li>
<li>X509Certificate x509Certificate = (X509Certificate) getCertificate(certificatePath);  </li>
<li>// 获得公钥  </li>
<li>PublicKey publicKey = x509Certificate.getPublicKey();  </li>
<li>// 构建签名  </li>
<li>Signature signature = Signature.getInstance(x509Certificate  </li>
<li>.getSigAlgName());  </li>
<li>signature.initVerify(publicKey);  </li>
<li>signature.update(data);  </li>
<li></li>
<li>return signature.verify(decryptBASE64(sign));  </li>
<li></li>
<li>}  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* 验证Certificate </li>
<li>/*  </li>
<li>/* @param keyStorePath </li>
<li>/* @param alias </li>
<li>/* @param password </li>
<li>/* @return </li>
<li>/*/  </li>
<li>public static boolean verifyCertificate(Date date, String keyStorePath,  </li>
<li>String alias, String password) {  </li>
<li>boolean status = true;  </li>
<li>try {  </li>
<li>Certificate certificate = getCertificate(keyStorePath, alias,  </li>
<li>password);  </li>
<li>status = verifyCertificate(date, certificate);  </li>
<li>} catch (Exception e) {  </li>
<li>status = false;  </li>
<li>}  </li>
<li>return status;  </li>
<li>}  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* 验证Certificate </li>
<li>/*  </li>
<li>/* @param keyStorePath </li>
<li>/* @param alias </li>
<li>/* @param password </li>
<li>/* @return </li>
<li>/*/  </li>
<li>public static boolean verifyCertificate(String keyStorePath, String alias,  </li>
<li>String password) {  </li>
<li>return verifyCertificate(new Date(), keyStorePath, alias, password);  </li>
<li>}  </li>
<li>}  </li>
</ol>
<p>import java.io.FileInputStream;</p>
<p>import java.security.KeyStore;
import java.security.PrivateKey;</p>
<p>import java.security.PublicKey;
import java.security.Signature;</p>
<p>import java.security.cert.Certificate;
import java.security.cert.CertificateFactory;</p>
<p>import java.security.cert.X509Certificate;
import java.util.Date;</p>
<p>import javax.crypto.Cipher;</p>
<p>//<em>/</em></p>
<p>/<em> 证书组件
/</em></p>
<p>/<em> @author 梁栋
/</em> @version 1.0</p>
<p>/<em> @since 1.0
/</em>/</p>
<p>public abstract class CertificateCoder extends Coder {</p>
<pre><code>//*/*

 /* Java密钥库(Java Key Store，JKS)KEY_STORE
 /*/

public static final String KEY_STORE = &quot;JKS&quot;;


public static final String X509 = &quot;X.509&quot;;


//*/*
 /* 由KeyStore获得私钥

 /*
 /* @param keyStorePath

 /* @param alias
 /* @param password

 /* @return
 /* @throws Exception

 /*/
private static PrivateKey getPrivateKey(String keyStorePath, String alias,

        String password) throws Exception {
    KeyStore ks = getKeyStore(keyStorePath, password);

    PrivateKey key = (PrivateKey) ks.getKey(alias, password.toCharArray());
    return key;

}


//*/*
 /* 由Certificate获得公钥

 /*
 /* @param certificatePath

 /* @return
 /* @throws Exception

 /*/
private static PublicKey getPublicKey(String certificatePath)

        throws Exception {
    Certificate certificate = getCertificate(certificatePath);

    PublicKey key = certificate.getPublicKey();
    return key;

}


//*/*
 /* 获得Certificate

 /*
 /* @param certificatePath

 /* @return
 /* @throws Exception

 /*/
private static Certificate getCertificate(String certificatePath)

        throws Exception {
    CertificateFactory certificateFactory = CertificateFactory

            .getInstance(X509);
    FileInputStream in = new FileInputStream(certificatePath);


    Certificate certificate = certificateFactory.generateCertificate(in);

    in.close();


    return certificate;
}


//*/*

 /* 获得Certificate
 /*

 /* @param keyStorePath
 /* @param alias

 /* @param password
 /* @return

 /* @throws Exception
 /*/

private static Certificate getCertificate(String keyStorePath,
        String alias, String password) throws Exception {

    KeyStore ks = getKeyStore(keyStorePath, password);
    Certificate certificate = ks.getCertificate(alias);


    return certificate;

}


//*/*
 /* 获得KeyStore

 /*
 /* @param keyStorePath

 /* @param password
 /* @return

 /* @throws Exception
 /*/

private static KeyStore getKeyStore(String keyStorePath, String password)
        throws Exception {

    FileInputStream is = new FileInputStream(keyStorePath);
    KeyStore ks = KeyStore.getInstance(KEY_STORE);

    ks.load(is, password.toCharArray());
    is.close();

    return ks;
}


//*/*

 /* 私钥加密
 /*

 /* @param data
 /* @param keyStorePath

 /* @param alias
 /* @param password

 /* @return
 /* @throws Exception

 /*/
public static byte[] encryptByPrivateKey(byte[] data, String keyStorePath,

        String alias, String password) throws Exception {
    // 取得私钥

    PrivateKey privateKey = getPrivateKey(keyStorePath, alias, password);


    // 对数据加密
    Cipher cipher = Cipher.getInstance(privateKey.getAlgorithm());

    cipher.init(Cipher.ENCRYPT_MODE, privateKey);


    return cipher.doFinal(data);


}


//*/*
 /* 私钥解密

 /*
 /* @param data

 /* @param keyStorePath
 /* @param alias

 /* @param password
 /* @return

 /* @throws Exception
 /*/

public static byte[] decryptByPrivateKey(byte[] data, String keyStorePath,
        String alias, String password) throws Exception {

    // 取得私钥
    PrivateKey privateKey = getPrivateKey(keyStorePath, alias, password);


    // 对数据加密

    Cipher cipher = Cipher.getInstance(privateKey.getAlgorithm());
    cipher.init(Cipher.DECRYPT_MODE, privateKey);


    return cipher.doFinal(data);


}


//*/*

 /* 公钥加密
 /*

 /* @param data
 /* @param certificatePath

 /* @return
 /* @throws Exception

 /*/
public static byte[] encryptByPublicKey(byte[] data, String certificatePath)

        throws Exception {


    // 取得公钥
    PublicKey publicKey = getPublicKey(certificatePath);

    // 对数据加密
    Cipher cipher = Cipher.getInstance(publicKey.getAlgorithm());

    cipher.init(Cipher.ENCRYPT_MODE, publicKey);


    return cipher.doFinal(data);


}


//*/*
 /* 公钥解密

 /*
 /* @param data

 /* @param certificatePath
 /* @return

 /* @throws Exception
 /*/

public static byte[] decryptByPublicKey(byte[] data, String certificatePath)
        throws Exception {

    // 取得公钥
    PublicKey publicKey = getPublicKey(certificatePath);


    // 对数据加密

    Cipher cipher = Cipher.getInstance(publicKey.getAlgorithm());
    cipher.init(Cipher.DECRYPT_MODE, publicKey);


    return cipher.doFinal(data);


}


//*/*

 /* 验证Certificate
 /*

 /* @param certificatePath
 /* @return

 /*/
public static boolean verifyCertificate(String certificatePath) {

    return verifyCertificate(new Date(), certificatePath);
}


//*/*

 /* 验证Certificate是否过期或无效
 /*

 /* @param date
 /* @param certificatePath

 /* @return
 /*/

public static boolean verifyCertificate(Date date, String certificatePath) {
    boolean status = true;

    try {
        // 取得证书

        Certificate certificate = getCertificate(certificatePath);
        // 验证证书是否过期或无效

        status = verifyCertificate(date, certificate);
    } catch (Exception e) {

        status = false;
    }

    return status;
}


//*/*

 /* 验证证书是否过期或无效
 /*

 /* @param date
 /* @param certificate

 /* @return
 /*/

private static boolean verifyCertificate(Date date, Certificate certificate) {
    boolean status = true;

    try {
        X509Certificate x509Certificate = (X509Certificate) certificate;

        x509Certificate.checkValidity(date);
    } catch (Exception e) {

        status = false;
    }

    return status;
}


//*/*

 /* 签名
 /*

 /* @param keyStorePath
 /* @param alias

 /* @param password
 /*

 /* @return
 /* @throws Exception

 /*/
public static String sign(byte[] sign, String keyStorePath, String alias,

        String password) throws Exception {
    // 获得证书

    X509Certificate x509Certificate = (X509Certificate) getCertificate(
            keyStorePath, alias, password);

    // 获取私钥
    KeyStore ks = getKeyStore(keyStorePath, password);

    // 取得私钥
    PrivateKey privateKey = (PrivateKey) ks.getKey(alias, password

            .toCharArray());


    // 构建签名
    Signature signature = Signature.getInstance(x509Certificate

            .getSigAlgName());
    signature.initSign(privateKey);

    signature.update(sign);
    return encryptBASE64(signature.sign());

}


//*/*
 /* 验证签名

 /*
 /* @param data

 /* @param sign
 /* @param certificatePath

 /* @return
 /* @throws Exception

 /*/
public static boolean verify(byte[] data, String sign,

        String certificatePath) throws Exception {
    // 获得证书

    X509Certificate x509Certificate = (X509Certificate) getCertificate(certificatePath);
    // 获得公钥

    PublicKey publicKey = x509Certificate.getPublicKey();
    // 构建签名

    Signature signature = Signature.getInstance(x509Certificate
            .getSigAlgName());

    signature.initVerify(publicKey);
    signature.update(data);


    return signature.verify(decryptBASE64(sign));


}


//*/*

 /* 验证Certificate
 /*

 /* @param keyStorePath
 /* @param alias

 /* @param password
 /* @return

 /*/
public static boolean verifyCertificate(Date date, String keyStorePath,

        String alias, String password) {
    boolean status = true;

    try {
        Certificate certificate = getCertificate(keyStorePath, alias,

                password);
        status = verifyCertificate(date, certificate);

    } catch (Exception e) {
        status = false;

    }
    return status;

}


//*/*
 /* 验证Certificate

 /*
 /* @param keyStorePath

 /* @param alias
 /* @param password

 /* @return
 /*/

public static boolean verifyCertificate(String keyStorePath, String alias,
        String password) {

    return verifyCertificate(new Date(), keyStorePath, alias, password);
}
</code></pre><p>}
再给出一个测试类：
Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>import static org.junit.Assert./*;  </li>
<li></li>
<li>import org.junit.Test;  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/*  </li>
<li>/* @author 梁栋 </li>
<li>/* @version 1.0 </li>
<li>/* @since 1.0 </li>
<li>/*/  </li>
<li>public class CertificateCoderTest {  </li>
<li>private String password = &quot;123456&quot;;  </li>
<li>private String alias = &quot;www.zlex.org&quot;;  </li>
<li>private String certificatePath = &quot;d:/zlex.cer&quot;;  </li>
<li>private String keyStorePath = &quot;d:/zlex.keystore&quot;;  </li>
<li></li>
<li>@Test  </li>
<li>public void test() throws Exception {  </li>
<li>System.err.println(&quot;公钥加密——私钥解密&quot;);  </li>
<li>String inputStr = &quot;Ceritifcate&quot;;  </li>
<li>byte[] data = inputStr.getBytes();  </li>
<li></li>
<li>byte[] encrypt = CertificateCoder.encryptByPublicKey(data,  </li>
<li>certificatePath);  </li>
<li></li>
<li>byte[] decrypt = CertificateCoder.decryptByPrivateKey(encrypt,  </li>
<li>keyStorePath, alias, password);  </li>
<li>String outputStr = new String(decrypt);  </li>
<li></li>
<li>System.err.println(&quot;加密前: &quot; + inputStr + &quot;\n\r&quot; + &quot;解密后: &quot; + outputStr);  </li>
<li></li>
<li>// 验证数据一致  </li>
<li>assertArrayEquals(data, decrypt);  </li>
<li></li>
<li>// 验证证书有效  </li>
<li>assertTrue(CertificateCoder.verifyCertificate(certificatePath));  </li>
<li></li>
<li>}  </li>
<li></li>
<li>@Test  </li>
<li>public void testSign() throws Exception {  </li>
<li>System.err.println(&quot;私钥加密——公钥解密&quot;);  </li>
<li></li>
<li>String inputStr = &quot;sign&quot;;  </li>
<li>byte[] data = inputStr.getBytes();  </li>
<li></li>
<li>byte[] encodedData = CertificateCoder.encryptByPrivateKey(data,  </li>
<li>keyStorePath, alias, password);  </li>
<li></li>
<li>byte[] decodedData = CertificateCoder.decryptByPublicKey(encodedData,  </li>
<li>certificatePath);  </li>
<li></li>
<li>String outputStr = new String(decodedData);  </li>
<li>System.err.println(&quot;加密前: &quot; + inputStr + &quot;\n\r&quot; + &quot;解密后: &quot; + outputStr);  </li>
<li>assertEquals(inputStr, outputStr);  </li>
<li></li>
<li>System.err.println(&quot;私钥签名——公钥验证签名&quot;);  </li>
<li>// 产生签名  </li>
<li>String sign = CertificateCoder.sign(encodedData, keyStorePath, alias,  </li>
<li>password);  </li>
<li>System.err.println(&quot;签名:\r&quot; + sign);  </li>
<li></li>
<li>// 验证签名  </li>
<li>boolean status = CertificateCoder.verify(encodedData, sign,  </li>
<li>certificatePath);  </li>
<li>System.err.println(&quot;状态:\r&quot; + status);  </li>
<li>assertTrue(status);  </li>
<li></li>
<li>}  </li>
<li>}  </li>
</ol>
<p>import static org.junit.Assert./*;</p>
<p>import org.junit.Test;</p>
<p>//<em>/</em></p>
<p>/<em>
/</em> @author 梁栋</p>
<p>/<em> @version 1.0
/</em> @since 1.0</p>
<p>/*/
public class CertificateCoderTest {</p>
<pre><code>private String password = &quot;123456&quot;;
private String alias = &quot;www.zlex.org&quot;;

private String certificatePath = &quot;d:/zlex.cer&quot;;
private String keyStorePath = &quot;d:/zlex.keystore&quot;;


@Test

public void test() throws Exception {
    System.err.println(&quot;公钥加密——私钥解密&quot;);

    String inputStr = &quot;Ceritifcate&quot;;
    byte[] data = inputStr.getBytes();


    byte[] encrypt = CertificateCoder.encryptByPublicKey(data,

            certificatePath);


    byte[] decrypt = CertificateCoder.decryptByPrivateKey(encrypt,
            keyStorePath, alias, password);

    String outputStr = new String(decrypt);


    System.err.println(&quot;加密前: &quot; + inputStr + &quot;\n\r&quot; + &quot;解密后: &quot; + outputStr);


    // 验证数据一致
    assertArrayEquals(data, decrypt);


    // 验证证书有效

    assertTrue(CertificateCoder.verifyCertificate(certificatePath));


}


@Test
public void testSign() throws Exception {

    System.err.println(&quot;私钥加密——公钥解密&quot;);


    String inputStr = &quot;sign&quot;;
    byte[] data = inputStr.getBytes();


    byte[] encodedData = CertificateCoder.encryptByPrivateKey(data,

            keyStorePath, alias, password);


    byte[] decodedData = CertificateCoder.decryptByPublicKey(encodedData,
            certificatePath);


    String outputStr = new String(decodedData);

    System.err.println(&quot;加密前: &quot; + inputStr + &quot;\n\r&quot; + &quot;解密后: &quot; + outputStr);
    assertEquals(inputStr, outputStr);


    System.err.println(&quot;私钥签名——公钥验证签名&quot;);

    // 产生签名
    String sign = CertificateCoder.sign(encodedData, keyStorePath, alias,

            password);
    System.err.println(&quot;签名:\r&quot; + sign);


    // 验证签名

    boolean status = CertificateCoder.verify(encodedData, sign,
            certificatePath);

    System.err.println(&quot;状态:\r&quot; + status);
    assertTrue(status);


}
</code></pre><p>}
控制台输出：
Console代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>公钥加密——私钥解密  </li>
<li>加密前: Ceritificate  </li>
<li></li>
<li>解密后: Ceritificate  </li>
<li></li>
<li>私钥加密——公钥解密  </li>
<li>加密前: sign  </li>
<li></li>
<li>解密后: sign  </li>
<li>私钥签名——公钥验证签名  </li>
<li>签名:  </li>
<li>pqBn5m6PJlfOjH0A6U2o2mUmBsfgyEY1NWCbiyA/I5Gc3gaVNVIdj/zkGNZRqTjhf3+J9a9z9EI7  </li>
<li>6F2eWYd7punHx5oh6hfNgcKbVb52EfItl4QEN+djbXiPynn07+Lbg1NOjULnpEd6ZhLP1YwrEAuM  </li>
<li>OfvX0e7/wplxLbySaKQ=  </li>
<li></li>
<li>状态:  </li>
<li>true  </li>
</ol>
<p>公钥加密——私钥解密</p>
<p>加密前: Ceritificate</p>
<p>解密后: Ceritificate</p>
<p>私钥加密——公钥解密
加密前: sign</p>
<p>解密后: sign</p>
<p>私钥签名——公钥验证签名
签名:</p>
<p>pqBn5m6PJlfOjH0A6U2o2mUmBsfgyEY1NWCbiyA/I5Gc3gaVNVIdj/zkGNZRqTjhf3+J9a9z9EI7
6F2eWYd7punHx5oh6hfNgcKbVb52EfItl4QEN+djbXiPynn07+Lbg1NOjULnpEd6ZhLP1YwrEAuM</p>
<p>OfvX0e7/wplxLbySaKQ=</p>
<p>状态:
true
由此完成了证书验证体系！<img src="" alt="">
同样，我们可以对代码做签名——代码签名！<img src="" alt="">
通过工具JarSigner可以完成代码签名。
这里我们对tools.jar做代码签名，命令如下：
Shell代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>jarsigner -storetype jks -keystore zlex.keystore -verbose tools.jar www.zlex.org  </li>
</ol>
<p>jarsigner -storetype jks -keystore zlex.keystore -verbose tools.jar www.zlex.org
控制台输出：
Console代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>输入密钥库的口令短语：  </li>
<li>正在更新： META-INF/WWW_ZLEX.SF  </li>
<li>正在更新： META-INF/WWW_ZLEX.RSA  </li>
<li>正在签名： org/zlex/security/Security.class  </li>
<li>正在签名： org/zlex/tool/Main$1.class  </li>
<li>正在签名： org/zlex/tool/Main$2.class  </li>
<li>正在签名： org/zlex/tool/Main.class  </li>
<li></li>
<li>警告：  </li>
<li>签名者证书将在六个月内过期。  </li>
</ol>
<p>输入密钥库的口令短语：</p>
<p>正在更新： META-INF/WWW_ZLEX.SF
正在更新： META-INF/WWW_ZLEX.RSA</p>
<p>  正在签名： org/zlex/security/Security.class
  正在签名： org/zlex/tool/Main$1.class</p>
<p>  正在签名： org/zlex/tool/Main$2.class
  正在签名： org/zlex/tool/Main.class</p>
<p>警告：</p>
<p>签名者证书将在六个月内过期。
此时，我们可以对签名后的jar做验证！<img src="" alt="">
验证tools.jar，命令如下：
Shell代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>jarsigner -verify -verbose -certs tools.jar  </li>
</ol>
<p>jarsigner -verify -verbose -certs tools.jar
控制台输出：
Console代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>402 Sat Jun 20 16:25:14 CST 2009 META-INF/MANIFEST.MF  </li>
<li>532 Sat Jun 20 16:25:14 CST 2009 META-INF/WWW_ZLEX.SF  </li>
<li>889 Sat Jun 20 16:25:14 CST 2009 META-INF/WWW_ZLEX.RSA  </li>
<li>sm       590 Wed Dec 10 13:03:42 CST 2008 org/zlex/security/Security.class  </li>
<li></li>
<li>X.509, CN=www.zlex.org, OU=zlex, O=zlex, L=BJ, ST=BJ, C=CN  </li>
<li>[证书将在 09-9-18 下午3:27 到期]  </li>
<li></li>
<li>sm       705 Tue Dec 16 18:00:56 CST 2008 org/zlex/tool/Main$1.class  </li>
<li></li>
<li>X.509, CN=www.zlex.org, OU=zlex, O=zlex, L=BJ, ST=BJ, C=CN  </li>
<li>[证书将在 09-9-18 下午3:27 到期]  </li>
<li></li>
<li>sm       779 Tue Dec 16 18:00:56 CST 2008 org/zlex/tool/Main$2.class  </li>
<li></li>
<li>X.509, CN=www.zlex.org, OU=zlex, O=zlex, L=BJ, ST=BJ, C=CN  </li>
<li>[证书将在 09-9-18 下午3:27 到期]  </li>
<li></li>
<li>sm     12672 Tue Dec 16 18:00:56 CST 2008 org/zlex/tool/Main.class  </li>
<li></li>
<li>X.509, CN=www.zlex.org, OU=zlex, O=zlex, L=BJ, ST=BJ, C=CN  </li>
<li>[证书将在 09-9-18 下午3:27 到期]  </li>
<li></li>
<li></li>
<li>s = 已验证签名  </li>
<li>m = 在清单中列出条目  </li>
<li>k = 在密钥库中至少找到了一个证书  </li>
<li>i = 在身份作用域内至少找到了一个证书  </li>
<li></li>
<li>jar 已验证。  </li>
<li></li>
<li>警告：  </li>
<li><p>此 jar 包含签名者证书将在六个月内过期的条目。  </p>
<pre><code>  402 Sat Jun 20 16:25:14 CST 2009 META-INF/MANIFEST.MF

  532 Sat Jun 20 16:25:14 CST 2009 META-INF/WWW_ZLEX.SF
  889 Sat Jun 20 16:25:14 CST 2009 META-INF/WWW_ZLEX.RSA
</code></pre></li>
</ol>
<p>sm       590 Wed Dec 10 13:03:42 CST 2008 org/zlex/security/Security.class</p>
<pre><code>  X.509, CN=www.zlex.org, OU=zlex, O=zlex, L=BJ, ST=BJ, C=CN
  [证书将在 09-9-18 下午3:27 到期]
</code></pre><p>sm       705 Tue Dec 16 18:00:56 CST 2008 org/zlex/tool/Main$1.class</p>
<pre><code>  X.509, CN=www.zlex.org, OU=zlex, O=zlex, L=BJ, ST=BJ, C=CN

  [证书将在 09-9-18 下午3:27 到期]
</code></pre><p>sm       779 Tue Dec 16 18:00:56 CST 2008 org/zlex/tool/Main$2.class</p>
<pre><code>  X.509, CN=www.zlex.org, OU=zlex, O=zlex, L=BJ, ST=BJ, C=CN
  [证书将在 09-9-18 下午3:27 到期]
</code></pre><p>sm     12672 Tue Dec 16 18:00:56 CST 2008 org/zlex/tool/Main.class</p>
<pre><code>  X.509, CN=www.zlex.org, OU=zlex, O=zlex, L=BJ, ST=BJ, C=CN

  [证书将在 09-9-18 下午3:27 到期]
</code></pre><p>  s = 已验证签名</p>
<p>  m = 在清单中列出条目
  k = 在密钥库中至少找到了一个证书</p>
<p>  i = 在身份作用域内至少找到了一个证书</p>
<p>jar 已验证。</p>
<p>警告：
此 jar 包含签名者证书将在六个月内过期的条目。
代码签名认证的用途主要是对发布的软件做验证，支持 Sun Java .jar (Java Applet) 文件(J2SE)和 J2ME MIDlet Suite 文件。
<img src="" alt="">
<strong>相关链接：
<a href="http://snowolf.iteye.com/blog/379860" target="_blank">Java加密技术（一）——BASE64与单向加密算法MD5&amp;SHA&amp;MAC</a>
<a href="http://snowolf.iteye.com/blog/380034" target="_blank">Java加密技术（二）——对称加密DES&amp;AES</a>
<a href="http://snowolf.iteye.com/blog/380761" target="_blank">Java加密技术（三）——PBE算法</a>
<a href="http://snowolf.iteye.com/blog/381767" target="_blank">Java加密技术（四）——非对称加密算法RSA</a>
<a href="http://snowolf.iteye.com/blog/382422" target="_blank">Java加密技术（五）——非对称加密算法的由来</a>
<a href="http://snowolf.iteye.com/blog/382749" target="_blank">Java加密技术（六）——数字签名算法DSA</a>
<a href="http://snowolf.iteye.com/blog/383412" target="_blank">Java加密技术（七）——非对称加密算法最高ECC</a>
<a href="http://snowolf.iteye.com/blog/391931" target="_blank">Java加密技术（八）——数字证书</a>
<a href="http://snowolf.iteye.com/blog/397693" target="_blank">Java加密技术（九）——初探SSL</a>
<a href="http://snowolf.iteye.com/blog/398198" target="_blank">Java加密技术（十）——单向认证</a>
<a href="http://snowolf.iteye.com/blog/510985" target="_blank">Java加密技术（十一）——双向认证</a>
<a href="http://snowolf.iteye.com/blog/735294" target="_blank">Java加密技术（十二）——/<em>.PFX(/</em>.p12)&amp;个人信息交换文件</a>
</strong></p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/算法&数组&优化/">算法&数组&优化</a></li><li><a href="/categories/Java&J2EE/算法&数组&优化/加解密/">加解密</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/加解密/" class="label label-success">加解密</a><a href="/tags/算法&数组&优化/" class="label label-info">算法&数组&优化</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:40"datetime="2014-03-07 09:54:40"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-算法数组优化-加解密--Java加密技术（八）——数字证书/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-算法数组优化-加解密--Java加密技术（八）——数字证书" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-算法数组优化-加解密--Java加密技术（二）——对称加密算法DESAES/">Java加密技术（二）——对称加密算法DES&AES</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:40.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-算法数组优化-加解密--Java加密技术（二）——对称加密算法DESAES/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="java-des-aes">Java加密技术（二）——对称加密算法DES&amp;AES</h1>
<pre><code>接下来我们介绍对称加密算法，最常用的莫过于DES数据加密算法。
</code></pre><p><strong>DES</strong>
DES-Data Encryption Standard,即数据加密算法。是IBM公司于1975年研究成功并公开发表的。DES算法的入口参数有三个:Key、Data、Mode。其中Key为8个字节共64位,是DES算法的工作密钥;Data也为8个字节64位,是要被加密或被解密的数据;Mode为DES的工作方式,有两种:加密或解密。
DES算法把64位的明文输入块变为64位的密文输出块,它所使用的密钥也是64位。
<img src="" alt="">
通过java代码实现如下：<strong>Coder类见 <a href="http://snowolf.iteye.com/blog/379860" target="_blank">Java加密技术（一）</a></strong>
Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>import java.security.Key;  </li>
<li>import java.security.SecureRandom;  </li>
<li></li>
<li>import javax.crypto.Cipher;  </li>
<li>import javax.crypto.KeyGenerator;  </li>
<li>import javax.crypto.SecretKey;  </li>
<li>import javax.crypto.SecretKeyFactory;  </li>
<li>import javax.crypto.spec.DESKeySpec;  </li>
<li></li>
<li></li>
<li>//<em>/</em> </li>
<li>/* DES安全编码组件 </li>
<li>/*  </li>
<li>/* <pre> </li>
<li>/* 支持 DES、DESede(TripleDES,就是3DES)、AES、Blowfish、RC2、RC4(ARCFOUR) </li>
<li>/* DES                  key size must be equal to 56 </li>
<li>/* DESede(TripleDES)    key size must be equal to 112 or 168 </li>
<li>/* AES                  key size must be equal to 128, 192 or 256,but 192 and 256 bits may not be available </li>
<li>/* Blowfish             key size must be multiple of 8, and can only range from 32 to 448 (inclusive) </li>
<li>/* RC2                  key size must be between 40 and 1024 bits </li>
<li>/* RC4(ARCFOUR)         key size must be between 40 and 1024 bits </li>
<li>/* 具体内容 需要关注 JDK Document <a href="http://.../docs/technotes/guides/security/SunProviders.html" target="_blank">http://.../docs/technotes/guides/security/SunProviders.html</a> </li>
<li>/* </pre> </li>
<li>/*  </li>
<li>/* @author 梁栋 </li>
<li>/* @version 1.0 </li>
<li>/* @since 1.0 </li>
<li>/*/  </li>
<li>public abstract class DESCoder extends Coder {  </li>
<li>//<em>/</em> </li>
<li>/* ALGORITHM 算法 <br> </li>
<li>/* 可替换为以下任意一种算法，同时key值的size相应改变。 </li>
<li>/*  </li>
<li>/* <pre> </li>
<li>/* DES                  key size must be equal to 56 </li>
<li>/* DESede(TripleDES)    key size must be equal to 112 or 168 </li>
<li>/* AES                  key size must be equal to 128, 192 or 256,but 192 and 256 bits may not be available </li>
<li>/* Blowfish             key size must be multiple of 8, and can only range from 32 to 448 (inclusive) </li>
<li>/* RC2                  key size must be between 40 and 1024 bits </li>
<li>/* RC4(ARCFOUR)         key size must be between 40 and 1024 bits </li>
<li>/* </pre> </li>
<li>/*  </li>
<li>/* 在Key toKey(byte[] key)方法中使用下述代码 </li>
<li>/* <code>SecretKey secretKey = new SecretKeySpec(key, ALGORITHM);</code> 替换 </li>
<li></li>
<li>/* <code> </li>
<li>/* DESKeySpec dks = new DESKeySpec(key); </li>
<li>/* SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(ALGORITHM); </li>
<li>/* SecretKey secretKey = keyFactory.generateSecret(dks); </li>
<li>/* </code> </li>
<li>/*/  </li>
<li>public static final String ALGORITHM = &quot;DES&quot;;  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* 转换密钥<br> </li>
<li>/*  </li>
<li>/* @param key </li>
<li>/* @return </li>
<li>/* @throws Exception </li>
<li>/*/  </li>
<li>private static Key toKey(byte[] key) throws Exception {  </li>
<li>DESKeySpec dks = new DESKeySpec(key);  </li>
<li>SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(ALGORITHM);  </li>
<li>SecretKey secretKey = keyFactory.generateSecret(dks);  </li>
<li></li>
<li>// 当使用其他对称加密算法时，如AES、Blowfish等算法时，用下述代码替换上述三行代码  </li>
<li>// SecretKey secretKey = new SecretKeySpec(key, ALGORITHM);  </li>
<li></li>
<li>return secretKey;  </li>
<li>}  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* 解密 </li>
<li>/*  </li>
<li>/* @param data </li>
<li>/* @param key </li>
<li>/* @return </li>
<li>/* @throws Exception </li>
<li>/*/  </li>
<li>public static byte[] decrypt(byte[] data, String key) throws Exception {  </li>
<li>Key k = toKey(decryptBASE64(key));  </li>
<li></li>
<li>Cipher cipher = Cipher.getInstance(ALGORITHM);  </li>
<li>cipher.init(Cipher.DECRYPT_MODE, k);  </li>
<li></li>
<li>return cipher.doFinal(data);  </li>
<li>}  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* 加密 </li>
<li>/*  </li>
<li>/* @param data </li>
<li>/* @param key </li>
<li>/* @return </li>
<li>/* @throws Exception </li>
<li>/*/  </li>
<li>public static byte[] encrypt(byte[] data, String key) throws Exception {  </li>
<li>Key k = toKey(decryptBASE64(key));  </li>
<li>Cipher cipher = Cipher.getInstance(ALGORITHM);  </li>
<li>cipher.init(Cipher.ENCRYPT_MODE, k);  </li>
<li></li>
<li>return cipher.doFinal(data);  </li>
<li>}  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* 生成密钥 </li>
<li>/*  </li>
<li>/* @return </li>
<li>/* @throws Exception </li>
<li>/*/  </li>
<li>public static String initKey() throws Exception {  </li>
<li>return initKey(null);  </li>
<li>}  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* 生成密钥 </li>
<li>/*  </li>
<li>/* @param seed </li>
<li>/* @return </li>
<li>/* @throws Exception </li>
<li>/*/  </li>
<li>public static String initKey(String seed) throws Exception {  </li>
<li>SecureRandom secureRandom = null;  </li>
<li></li>
<li>if (seed != null) {  </li>
<li>secureRandom = new SecureRandom(decryptBASE64(seed));  </li>
<li>} else {  </li>
<li>secureRandom = new SecureRandom();  </li>
<li>}  </li>
<li></li>
<li>KeyGenerator kg = KeyGenerator.getInstance(ALGORITHM);  </li>
<li>kg.init(secureRandom);  </li>
<li></li>
<li>SecretKey secretKey = kg.generateKey();  </li>
<li></li>
<li>return encryptBASE64(secretKey.getEncoded());  </li>
<li>}  </li>
<li>}  </li>
</ol>
<p>import java.security.Key;</p>
<p>import java.security.SecureRandom;</p>
<p>import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;</p>
<p>import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;</p>
<p>import javax.crypto.spec.DESKeySpec;</p>
<p>//<em>/</em></p>
<p>/<em> DES安全编码组件
/</em></p>
<p>/<em> <pre>
/</em> 支持 DES、DESede(TripleDES,就是3DES)、AES、Blowfish、RC2、RC4(ARCFOUR)</p>
<p> /<em> DES                  key size must be equal to 56
 /</em> DESede(TripleDES)     key size must be equal to 112 or 168</p>
<p> /<em> AES                  key size must be equal to 128, 192 or 256,but 192 and 256 bits may not be available
 /</em> Blowfish             key size must be multiple of 8, and can only range from 32 to 448 (inclusive)</p>
<p> /<em> RC2                  key size must be between 40 and 1024 bits
 /</em> RC4(ARCFOUR)         key size must be between 40 and 1024 bits</p>
<p>/<em> 具体内容 需要关注 JDK Document <a href="http://.../docs/technotes/guides/security/SunProviders.html" target="_blank">http://.../docs/technotes/guides/security/SunProviders.html</a>
/</em> </pre></p>
<p>/<em>
/</em> @author 梁栋</p>
<p>/<em> @version 1.0
/</em> @since 1.0</p>
<p>/*/
public abstract class DESCoder extends Coder {</p>
<pre><code>//*/*
 /* ALGORITHM 算法 &lt;br&gt;

 /* 可替换为以下任意一种算法，同时key值的size相应改变。
 /*

 /* &lt;pre&gt;
 /* DES                  key size must be equal to 56

 /* DESede(TripleDES)     key size must be equal to 112 or 168
 /* AES                  key size must be equal to 128, 192 or 256,but 192 and 256 bits may not be available

 /* Blowfish             key size must be multiple of 8, and can only range from 32 to 448 (inclusive)
 /* RC2                  key size must be between 40 and 1024 bits

 /* RC4(ARCFOUR)         key size must be between 40 and 1024 bits
 /* &lt;/pre&gt;

 /*
 /* 在Key toKey(byte[] key)方法中使用下述代码

 /* &lt;code&gt;SecretKey secretKey = new SecretKeySpec(key, ALGORITHM);&lt;/code&gt; 替换


 /* &lt;code&gt;
 /* DESKeySpec dks = new DESKeySpec(key);

 /* SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(ALGORITHM);
 /* SecretKey secretKey = keyFactory.generateSecret(dks);

 /* &lt;/code&gt;
 /*/

public static final String ALGORITHM = &quot;DES&quot;;


//*/*
 /* 转换密钥&lt;br&gt;

 /*
 /* @param key

 /* @return
 /* @throws Exception

 /*/
private static Key toKey(byte[] key) throws Exception {

    DESKeySpec dks = new DESKeySpec(key);
    SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(ALGORITHM);

    SecretKey secretKey = keyFactory.generateSecret(dks);


    // 当使用其他对称加密算法时，如AES、Blowfish等算法时，用下述代码替换上述三行代码
    // SecretKey secretKey = new SecretKeySpec(key, ALGORITHM);


    return secretKey;

}


//*/*
 /* 解密

 /*
 /* @param data

 /* @param key
 /* @return

 /* @throws Exception
 /*/

public static byte[] decrypt(byte[] data, String key) throws Exception {
    Key k = toKey(decryptBASE64(key));


    Cipher cipher = Cipher.getInstance(ALGORITHM);

    cipher.init(Cipher.DECRYPT_MODE, k);


    return cipher.doFinal(data);
}


//*/*

 /* 加密
 /*

 /* @param data
 /* @param key

 /* @return
 /* @throws Exception

 /*/
public static byte[] encrypt(byte[] data, String key) throws Exception {

    Key k = toKey(decryptBASE64(key));
    Cipher cipher = Cipher.getInstance(ALGORITHM);

    cipher.init(Cipher.ENCRYPT_MODE, k);


    return cipher.doFinal(data);
}


//*/*

 /* 生成密钥
 /*

 /* @return
 /* @throws Exception

 /*/
public static String initKey() throws Exception {

    return initKey(null);
}


//*/*

 /* 生成密钥
 /*

 /* @param seed
 /* @return

 /* @throws Exception
 /*/

public static String initKey(String seed) throws Exception {
    SecureRandom secureRandom = null;


    if (seed != null) {

        secureRandom = new SecureRandom(decryptBASE64(seed));
    } else {

        secureRandom = new SecureRandom();
    }


    KeyGenerator kg = KeyGenerator.getInstance(ALGORITHM);

    kg.init(secureRandom);


    SecretKey secretKey = kg.generateKey();


    return encryptBASE64(secretKey.getEncoded());
}
</code></pre><p>}
延续上一个类的实现，我们通过MD5以及SHA对字符串加密生成密钥，这是比较常见的密钥生成方式。
再给出一个测试类：
Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>import static org.junit.Assert./*;  </li>
<li></li>
<li></li>
<li>import org.junit.Test;  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/*  </li>
<li>/* @author 梁栋 </li>
<li>/* @version 1.0 </li>
<li>/* @since 1.0 </li>
<li>/*/  </li>
<li>public class DESCoderTest {  </li>
<li></li>
<li>@Test  </li>
<li>public void test() throws Exception {  </li>
<li>String inputStr = &quot;DES&quot;;  </li>
<li>String key = DESCoder.initKey();  </li>
<li>System.err.println(&quot;原文:\t&quot; + inputStr);  </li>
<li></li>
<li>System.err.println(&quot;密钥:\t&quot; + key);  </li>
<li></li>
<li>byte[] inputData = inputStr.getBytes();  </li>
<li>inputData = DESCoder.encrypt(inputData, key);  </li>
<li></li>
<li>System.err.println(&quot;加密后:\t&quot; + DESCoder.encryptBASE64(inputData));  </li>
<li></li>
<li>byte[] outputData = DESCoder.decrypt(inputData, key);  </li>
<li>String outputStr = new String(outputData);  </li>
<li></li>
<li>System.err.println(&quot;解密后:\t&quot; + outputStr);  </li>
<li></li>
<li>assertEquals(inputStr, outputStr);  </li>
<li>}  </li>
<li>}  </li>
</ol>
<p>import static org.junit.Assert./*;</p>
<p>import org.junit.Test;</p>
<p>//<em>/</em>
/*</p>
<p>/<em> @author 梁栋
/</em> @version 1.0</p>
<p>/<em> @since 1.0
/</em>/</p>
<p>public class DESCoderTest {</p>
<pre><code>@Test
public void test() throws Exception {

    String inputStr = &quot;DES&quot;;
    String key = DESCoder.initKey();

    System.err.println(&quot;原文:\t&quot; + inputStr);


    System.err.println(&quot;密钥:\t&quot; + key);


    byte[] inputData = inputStr.getBytes();
    inputData = DESCoder.encrypt(inputData, key);


    System.err.println(&quot;加密后:\t&quot; + DESCoder.encryptBASE64(inputData));


    byte[] outputData = DESCoder.decrypt(inputData, key);

    String outputStr = new String(outputData);


    System.err.println(&quot;解密后:\t&quot; + outputStr);


    assertEquals(inputStr, outputStr);
}
</code></pre><p>}
得到的输出内容如下：
Console代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>原文: DES  </li>
<li>密钥: f3wEtRrV6q0=  </li>
<li></li>
<li>加密后:    C6qe9oNIzRY=  </li>
<li></li>
<li>解密后:    DES  </li>
</ol>
<p>原文:    DES</p>
<p>密钥:    f3wEtRrV6q0=</p>
<p>加密后:    C6qe9oNIzRY=</p>
<p>解密后:    DES
    由控制台得到的输出，我们能够比对加密、解密后结果一致。这是一种简单的加密解密方式，只有一个密钥。
    其实DES有很多同胞兄弟，如DESede(TripleDES)、AES、Blowfish、RC2、RC4(ARCFOUR)。这里就不过多阐述了，大同小异，只要换掉ALGORITHM换成对应的值，同时做一个代码替换<strong>SecretKey secretKey = new SecretKeySpec(key, ALGORITHM);</strong>就可以了，此外就是密钥长度不同了。
Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>//<em>/</em> </li>
<li>/* DES          key size must be equal to 56 </li>
<li>/* DESede(TripleDES) key size must be equal to 112 or 168 </li>
<li>/* AES          key size must be equal to 128, 192 or 256,but 192 and 256 bits may not be available </li>
<li>/* Blowfish     key size must be multiple of 8, and can only range from 32 to 448 (inclusive) </li>
<li>/* RC2          key size must be between 40 and 1024 bits </li>
<li>/* RC4(ARCFOUR) key size must be between 40 and 1024 bits </li>
<li>/<em>/</em>/  </li>
</ol>
<p>//<em>/</em></p>
<p> /<em> DES          key size must be equal to 56
/</em> DESede(TripleDES) key size must be equal to 112 or 168</p>
<p> /<em> AES          key size must be equal to 128, 192 or 256,but 192 and 256 bits may not be available
 /</em> Blowfish     key size must be multiple of 8, and can only range from 32 to 448 (inclusive)</p>
<p> /<em> RC2          key size must be between 40 and 1024 bits
/</em> RC4(ARCFOUR) key size must be between 40 and 1024 bits</p>
<p>/<em>/</em>/
<strong>相关链接：
<a href="http://snowolf.iteye.com/blog/379860" target="_blank">Java加密技术（一）——BASE64与单向加密算法MD5&amp;SHA&amp;MAC</a>
<a href="http://snowolf.iteye.com/blog/380034" target="_blank">Java加密技术（二）——对称加密算法DES&amp;AES</a>
<a href="http://snowolf.iteye.com/blog/380761" target="_blank">Java加密技术（三）——PBE算法</a>
<a href="http://snowolf.iteye.com/blog/381767" target="_blank">Java加密技术（四）——非对称加密算法RSA</a>
<a href="http://snowolf.iteye.com/blog/382422" target="_blank">Java加密技术（五）——非对称加密算法的由来</a>
<a href="http://snowolf.iteye.com/blog/382749" target="_blank">Java加密技术（六）——数字签名算法DSA</a>
<a href="http://snowolf.iteye.com/blog/383412" target="_blank">Java加密技术（七）——非对称加密算法最高ECC</a>
<a href="http://snowolf.iteye.com/blog/391931" target="_blank">Java加密技术（八）——数字证书</a>
<a href="http://snowolf.iteye.com/blog/397693" target="_blank">Java加密技术（九）——初探SSL</a>
<a href="http://snowolf.iteye.com/blog/398198" target="_blank">Java加密技术（十）——单向认证</a>
<a href="http://snowolf.iteye.com/blog/510985" target="_blank">Java加密技术（十一）——双向认证</a>
<a href="http://snowolf.iteye.com/blog/735294" target="_blank">Java加密技术（十二）——/<em>.PFX(/</em>.p12)&amp;个人信息交换文件</a>
</strong></p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/算法&数组&优化/">算法&数组&优化</a></li><li><a href="/categories/Java&J2EE/算法&数组&优化/加解密/">加解密</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/加解密/" class="label label-success">加解密</a><a href="/tags/算法&数组&优化/" class="label label-info">算法&数组&优化</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:40"datetime="2014-03-07 09:54:40"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-算法数组优化-加解密--Java加密技术（二）——对称加密算法DESAES/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-算法数组优化-加解密--Java加密技术（二）——对称加密算法DESAES" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>





<ul id="pagination" class="pagination pagination-lg">
  <li><a class="extend prev" href="/page/71/">&laquo;</a></li><li><a class="page-number" href="/">1</a></li><li><a class="page-number" href="/page/2/">2</a></li><li><span class="space">&hellip;</span></li><li><a class="page-number" href="/page/69/">69</a></li><li><a class="page-number" href="/page/70/">70</a></li><li><a class="page-number" href="/page/71/">71</a></li><li class="active"><li><span class="page-number current">72</span></li><li><a class="page-number" href="/page/73/">73</a></li><li><a class="page-number" href="/page/74/">74</a></li><li><a class="page-number" href="/page/75/">75</a></li><li><span class="space">&hellip;</span></li></li><li><a class="page-number" href="/page/164/">164</a></li><li><a class="page-number" href="/page/165/">165</a></li><li><a class="extend next" href="/page/73/">&raquo;</a></li>
  <div class="clearfix"></div>
</ul></div><!--wapper-->
       </div><!-- ID main-col END -->
       <aside id="sidebar" class="alignright col-sx-6 col-sm-4 col-md-3 col-lg-3">
<div id="widget_search" class="widget panel panel-primary">
    <form action="//google.com/search" method="get" accept-charset="utf-8">
  <div class="input-group">
    <input class="form-control" id="searchbox" type="search" name="q" results="0" placeholder="search">
    <span class="input-group-btn">
      <button class="btn btn-default" type="submit">Go!</button>
    </span>
    <input type="hidden" name="q" value="site:itsolife.com">
  </div>
</form>
</div>

<div id="widget_category" class="widget panel panel-primary">
  <div class="panel-heading">category</div>  <div data-src='category' class='ajax_widgets'>正在加载...</div>
</div>

<div id="widget_recent_posts" class="widget panel panel-primary">
  <div class="panel-heading">recent posts</div>  <div data-src='recent_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_tagcloud" class="widget panel panel-primary">
  <div class="panel-heading">tagcloud</div>  <div data-src='tagcloud' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_latest_update_posts" class="widget panel panel-primary">
  <div class="panel-heading">最近更新</div>  <div data-src='latest_update_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_recent_comments" class="widget panel panel-primary">
  <div class="panel-heading">recent comments</div>  

<div class="list-group-item ds-recent-comments" data-num-items="6" data-show-avatars="1" data-show-time="1" data-show-title="1" data-show-admin="1" data-excerpt-length="50"></div>



</div>

</aside>
       <div class="clearfix"></div>
     </div><!-- row END -->
  </div>
  <footer id="footer" class="container">
  <div class="panel panel-info">
  <section id='footer_widget'></section>  <div class="panel-footer">
  <div id="site-info">
    <span class='author'>
  
  &copy; 2014 RobinChia
  
    &nbsp;&nbsp;</span>
  
  <span id='analytics-51la'></span><span id='analytics-google'>
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-48559895-1']);
  _gaq.push(['_trackPageview']);
  _js2load.push({src:('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'});
</script></span><span id='analytics-cnzz'>
<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_5774006'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s17.cnzz.com/stat.php%3Fid%3D5774006%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>
</span><span id='analytics-baidu'>
<script>
var _hmt = _hmt || [];
_js2load.push({src:"//hm.baidu.com/hm.js?1442f50724afc42380b51f097c43082c"});
</script>
</span>  </div>
  <div id="copyright">Blog powered by <a href='http://zespia.tw/hexo/'><strong>hexo</strong></a> Theme <strong><a href='https://github.com/chenall/hexo-theme-chenall'>chenall</a></strong>(Some change in it)<span class="pull-right"> 更新时间: <em>2014-03-25 18:15:42</em></span></div>
</div>
<div class="clearfix"></div>


  </div>
  </footer>
  
        <script src="http://cdn.bootcss.com/jquery/1.10.2/jquery.min.js"></script>        
        <script src="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/js/bootstrap.min.js"></script>        
                
        <script src="http://cdn.bootcss.com/prettify/r298/prettify.min.js"></script>    <script type="text/javascript">
   var lang=["bsh", "c", "cc", "cpp", "cs", "csh", "cyc", "cv", "htm", "html",
    "java", "js", "m", "mxml", "perl", "pl", "pm", "py", "rb", "sh",
    "xhtml", "xml", "xsl"];
   var pretty_base='';
   $('script').each(function(){
	var c = $(this).attr('src');
	if (!c)
	    return;
	if (c.match(/(\/)?prettify(\.min)?\.js/i))
	{
	    var index = c.lastIndexOf('/');
	    if (index != -1)
		pretty_base = c.substr(0,index + 1);
	    return false;
	}
   })
   $('pre code').each(function(){
	var c = $(this).attr('class')
	if (!c)
	    return;
	c = c.match(/\s?(lang\-\w+)/i);
	if (c && lang.indexOf(c[1]) == -1)
	{
	    lang.push(c[1]);
	    $.getScript(pretty_base + c[1] + '.min.js');
	}
   })

    $(window).load(function(){
       $("pre").addClass("prettyprint");
       prettyPrint();
    })
</script>    
            <script type="text/javascript">
var duoshuoQuery = {short_name:"robinchia"};
_js2load.push({src:'http://static.duoshuo.com/embed.js',charset:'UTF-8'});
</script>
    
            <!--wumii_relatedItems-->
    
        <script src="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js"></script>    <script type="text/javascript">
(function($){
  $('.entry').each(function(i){
    $(this).find('img').each(function(){
      var alt = this.alt;

      if (alt){
        $(this).before('<span class="caption">' + alt + '</span>');
      }

      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox" rel="fancybox' + i + '" />');
    });
  });

  $('.fancybox').fancybox();
})(jQuery);
</script>    
        <script src="http://cdn.bootcss.com/mathjax/2.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>    <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>
    
<script type="text/javascript">
$('.ajax_widgets').each(function(){var src=$(this).attr('data-src');if(src)$(this).load('/widgets/'+src+'.html');});
$.each(_js2load,function(index,obj){loadjs(obj.src,obj.charset)});
</script>

<div id="scroll2top">
<img src="/scroll2top/arrow.png"/>
</div>
<script src="/scroll2top/scroll2top.min.js"></script>
<div id="winterland">
  <canvas></canvas>
</div>
<script src="/js/winterland.min.js"></script>

  </body>
</html>
