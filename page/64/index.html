
<!DOCTYPE HTML>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>The 64 Page | It so life</title>
<meta name="author" content="RobinChia">

<meta name="description" content="It so life">


<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<meta property="og:site_name" content="It so life"/>

<!--[if IE]><style>.testIE.IE{display:inline;}</style><![endif]-->
<!--[if lte IE 7]><link rel="stylesheet" href="/css/ie7.css" type="text/css"><![endif]-->
<!--[if (lt IE 9)&(gt IE 7)]><style>.testIE.IE8{display:inline;}</style><![endif]-->
<!--[if gt IE 8]><style>.testIE.IE9{display:inline;}</style><![endif]-->

<link href="/favicon.png" rel="icon">
<link rel="alternate" href="/atom.xml" title="It so life Feed" type="application/atom+xml">

<link rel="stylesheet" href="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/css/bootstrap.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/font-awesome/4.0.3/css/font-awesome.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/prettify/r298/prettify.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" type="text/css">
<link rel="stylesheet" href="/css/style.css" type="text/css">
<!--[if lt IE 9]>
   <style>article,aside,dialog,footer,header,section,footer,nav,figure,menu{display:block}</style>
   <script src="http://cdn.staticfile.org/html5shiv/r29/html5.min.js"></script>
   <script src="http://cdn.staticfile.org/respond.js/1.4.2/respond.min.js"></script>
<link href="http://cdn.staticfile.org/respond.js/1.4.2/respond-proxy.html" id="respond-proxy" rel="respond-proxy" />
<link href="/js/respond.proxy.gif" id="respond-redirect" rel="respond-redirect" />
<script src="/js/respond.proxy.js"></script>
   <script src="http://cdn.bootcss.com/selectivizr/1.0.2/selectivizr-min.js"></script>
<![endif]-->
<script type="text/javascript">
function loadjs(c,d){var a=document.createElement("script");a.async=!0;a.type="text/javascript";a.src=c;a.charset=d||"gbk";(document.getElementsByTagName("HEAD")[0]||document.getElementsByTagName("BODY")[0]).appendChild(a)};
var _protocol = (("https:" == document.location.protocol) ? " https://" : " http://");
var _js2load = [];
</script>

</head>
<body>
      <header id="header" class="container"><nav id="main-nav" class="navbar navbar-default navbar-fixed-top " role="navigation">
  <div class="container">
    <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
      <span class="sr-only">Toggle navigation</span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="/">It so life</a>
    </div>
    <div  class="collapse navbar-collapse">
      <ul  class="nav navbar-nav">
  
        <li><a href="/" title="Home">Home</a></li>      
        <li><a href="/about/" title="About">About</a></li>      
        <li><a href="/archives/" title="Archives">Archives</a></li>      
      <li class='dropdown'>
        <a class='dropdown-toggle' data-toggle='dropdown' href='#'>website<b class='caret'></b></a>
        <ul class='dropdown-menu pure-menu-selected'>
    
          <li><a href="//groups.google.com/forum/#!forum/pongba" title="TopLanguage">TopLanguage</a></li>    
          <li><a href="//itpub.net/" title="ITPub">ITPub</a></li>    
          <li><a href="//blog.jobbole.com/" title="Bole">Bole</a></li>    
          <li><a href="//nosql-database.org/" title="nosql">nosql</a></li>    
          <li><a href="//gitimmersion.googol.im/" title="Git">Git</a></li>    
        </ul>
      </li>
    
      </ul>
      <ul class="nav navbar-nav navbar-right">
      
        <li><a href="/atom.xml">RSS</a></li>
      
      
        <li><a href="https://twitter.com/robinchia">twitter</a></li>
      
      
      
      
        <li><a href="https://github.com/robinchia">github</a></li>
      
      </ul>
    </div>
  </div>
</nav>
<div class="clearfix"></div>
</header>
  <div id='content' class="container">
     <div class="page-header-wrapper">
      <!--[if lt IE 9]><div class="alert alert-warning alert-dismissable"><button type="button" class="close" data-dismiss="alert" aria-hidden="true">&times;</button><strong>提示:</strong>您的浏览器版本太低了,建议升级到 <strong><a href="http://windows.microsoft.com/zh-cn/internet-explorer/download-ie" title="IE9">IE9</a></strong> 以上,本站使用<a href="https://www.google.com/intl/zh-CN/chrome/">Chrome浏览器</a>可以获得最好的显示效果.</div><![endif]-->
      <div class="page-header"><h1 align="center"><big>It so life</big> </h1>
        <h5 align="center"><big>love as life</big></h5>
      </div>
     </div>
     <div class="row">
       <div id="main-col" class="alignleft col-sx-12 col-sm-8 col-md-9 col-lg-9">
      <section id='header_widget'></section>
          <div id="wrapper"><article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_多线程-并发--聊聊并发（三）——JAVA线程池的分析和使用/">聊聊并发（三）——JAVA线程池的分析和使用</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:41.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_多线程-并发--聊聊并发（三）——JAVA线程池的分析和使用/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-java-">聊聊并发（三）——JAVA线程池的分析和使用</h1>
<h3 id="-">分享到</h3>
<ul>
<li><a href="">一键分享</a></li>
<li><a href="">QQ空间</a></li>
<li><a href="">新浪微博</a></li>
<li><a href="">百度搜藏</a></li>
<li><a href="">人人网</a></li>
<li><a href="">腾讯微博</a></li>
<li><a href="">百度相册</a></li>
<li><a href="">开心网</a></li>
<li><a href="">腾讯朋友</a></li>
<li><a href="">百度贴吧</a></li>
<li><a href="">豆瓣网</a></li>
<li><a href="">搜狐微博</a></li>
<li><a href="">百度新首页</a></li>
<li><a href="">QQ好友</a></li>
<li><a href="">和讯微博</a></li>
<li><a href="">更多...</a></li>
</ul>
<p><a href="">百度分享</a></p>
<ul>
<li><a href="http://www.infoq.com/cn/aboutus" title="关于我们" target="_blank">关于我们</a></li>
<li><p><a href="http://www.infoq.com/cn/contribute" title="让大家在InfoQ上听见你的声音" target="_blank">让大家在InfoQ上听见你的声音</a></p>
</li>
<li><p><a href="http://e.weibo.com/infoqchina" target="_blank"><img src="" alt=""></a></p>
</li>
<li><a href="http://www.infoq.com/cn/news/2013/02/infoq-wechat" target="_blank"><img src="" alt=""></a></li>
<li><a href="http://www.infoq.com/cn/rss/rss.action?token=J6EBu2hcpyEuMs9msdo8GyNCZTcWG7pm" target="_blank"><img src="" alt=""></a></li>
</ul>
<h1 id="-java-">聊聊并发（三）——JAVA线程池的分析和使用</h1>
<p>作者 <a href="http://www.infoq.com/cn/author/%E6%96%B9%E8%85%BE%E9%A3%9E" target="_blank">方腾飞</a> 发布于 十一月 15, 2012 <em>|</em> <a href="">14 评论</a></p>
<h2 id="1-">1. 引言</h2>
<p>合理利用线程池能够带来三个好处。第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。第二：提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。第三：提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。但是要做到合理的利用线程池，必须对其原理了如指掌。</p>
<h2 id="2-">2. 线程池的使用</h2>
<p><strong>线程池的创建</strong></p>
<p>我们可以通过ThreadPoolExecutor来创建一个线程池。
new ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, milliseconds,runnableTaskQueue, handler);</p>
<p>创建一个线程池需要输入几个参数：</p>
<ul>
<li>corePoolSize（线程池的基本大小）：当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于线程池基本大小时就不再创建。如果调用了线程池的prestartAllCoreThreads方法，线程池会提前创建并启动所有基本线程。</li>
<li><p>runnableTaskQueue（任务队列）：用于保存等待执行的任务的阻塞队列。 可以选择以下几个阻塞队列。</p>
</li>
<li><p>ArrayBlockingQueue：是一个基于数组结构的有界阻塞队列，此队列按 FIFO（先进先出）原则对元素进行排序。</p>
</li>
<li>LinkedBlockingQueue：一个基于链表结构的阻塞队列，此队列按FIFO （先进先出） 排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列。</li>
<li>SynchronousQueue：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQueue，静态工厂方法Executors.newCachedThreadPool使用了这个队列。</li>
<li>PriorityBlockingQueue：一个具有优先级的无限阻塞队列。</li>
<li>maximumPoolSize（线程池最大大小）：线程池允许创建的最大线程数。如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。值得注意的是如果使用了无界的任务队列这个参数就没什么效果。</li>
<li>ThreadFactory：用于设置创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置更有意义的名字。</li>
<li><p>RejectedExecutionHandler（饱和策略）：当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。这个策略默认情况下是AbortPolicy，表示无法处理新任务时抛出异常。以下是JDK1.5提供的四种策略。</p>
</li>
<li><p>AbortPolicy：直接抛出异常。</p>
</li>
<li>CallerRunsPolicy：只用调用者所在线程来运行任务。</li>
<li>DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务。</li>
<li>DiscardPolicy：不处理，丢弃掉。</li>
<li>当然也可以根据应用场景需要来实现RejectedExecutionHandler接口自定义策略。如记录日志或持久化不能处理的任务。</li>
<li>keepAliveTime（线程活动保持时间）：线程池的工作线程空闲后，保持存活的时间。所以如果任务很多，并且每个任务执行的时间比较短，可以调大这个时间，提高线程的利用率。</li>
<li>TimeUnit（线程活动保持时间的单位）：可选的单位有天（DAYS），小时（HOURS），分钟（MINUTES），毫秒(MILLISECONDS)，微秒(MICROSECONDS, 千分之一毫秒)和毫微秒(NANOSECONDS, 千分之一微秒)。</li>
</ul>
<p><strong>向线程池提交任务</strong></p>
<p>我们可以使用execute提交的任务，但是execute方法没有返回值，所以无法判断任务是否被线程池执行成功。通过以下代码可知execute方法输入的任务是一个Runnable类的实例。
threadsPool.execute(new Runnable() { @Override public void run() { // TODO Auto-generated method stub } });</p>
<p>我们也可以使用submit 方法来提交任务，它会返回一个future,那么我们可以通过这个future来判断任务是否执行成功，通过future的get方法来获取返回值，get方法会阻塞住直到任务完成，而使用get(long timeout, TimeUnit unit)方法则会阻塞一段时间后立即返回，这时有可能任务没有执行完。</p>
<p>Future<Object> future = executor.submit(harReturnValuetask); try { Object s = future.get(); } catch (InterruptedException e) { // 处理中断异常 } catch (ExecutionException e) { // 处理无法执行任务异常 } finally { // 关闭线程池 executor.shutdown(); }</p>
<p><strong>线程池的关闭</strong></p>
<p>我们可以通过调用线程池的shutdown或shutdownNow方法来关闭线程池，它们的原理是遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法终止。但是它们存在一定的区别，shutdownNow首先将线程池的状态设置成STOP，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表，而shutdown只是将线程池的状态设置成SHUTDOWN状态，然后中断所有没有正在执行任务的线程。</p>
<p>只要调用了这两个关闭方法的其中一个，isShutdown方法就会返回true。当所有的任务都已关闭后,才表示线程池关闭成功，这时调用isTerminaed方法会返回true。至于我们应该调用哪一种方法来关闭线程池，应该由提交到线程池的任务特性决定，通常调用shutdown来关闭线程池，如果任务不一定要执行完，则可以调用shutdownNow。</p>
<h2 id="3-">3. 线程池的分析</h2>
<p>流程分析：线程池的主要工作流程如下图：</p>
<p><img src="" alt=""></p>
<p>从上图我们可以看出，当提交一个新任务到线程池时，线程池的处理流程如下：</p>
<ol>
<li>首先线程池判断<strong>基本线程池</strong>是否已满？没满，创建一个工作线程来执行任务。满了，则进入下个流程。</li>
<li>其次线程池判断<strong>工作队列</strong>是否已满？没满，则将新提交的任务存储在工作队列里。满了，则进入下个流程。</li>
<li>最后线程池判断<strong>整个线程池</strong>是否已满？没满，则创建一个新的工作线程来执行任务，满了，则交给饱和策略来处理这个任务。</li>
</ol>
<p><strong>源码分析</strong>。上面的流程分析让我们很直观的了解了线程池的工作原理，让我们再通过源代码来看看是如何实现的。线程池执行任务的方法如下：
public void execute(Runnable command) { if (command == null) throw new NullPointerException(); //如果线程数小于基本线程数，则创建线程并执行当前任务 if (poolSize &gt;= corePoolSize || !addIfUnderCorePoolSize(command)) { //如线程数大于等于基本线程数或线程创建失败，则将当前任务放到工作队列中。 if (runState == RUNNING &amp;&amp; workQueue.offer(command)) { if (runState != RUNNING || poolSize == 0) ensureQueuedTaskHandled(command); } //如果线程池不处于运行中或任务无法放入队列，并且当前线程数量小于最大允许的线程数量， 则创建一个线程执行任务。 else if (!addIfUnderMaximumPoolSize(command)) //抛出RejectedExecutionException异常 reject(command); // is shutdown or saturated } }</p>
<p><strong>工作线程</strong>。线程池创建线程时，会将线程封装成工作线程Worker，Worker在执行完任务后，还会无限循环获取工作队列里的任务来执行。我们可以从Worker的run方法里看到这点：</p>
<p>public void run() { try { Runnable task = firstTask; firstTask = null; while (task != null || (task = getTask()) != null) { runTask(task); task = null; } } finally { workerDone(this); } }</p>
<h2 id="4-">4. 合理的配置线程池</h2>
<p>要想合理的配置线程池，就必须首先分析任务特性，可以从以下几个角度来进行分析：</p>
<ol>
<li>任务的性质：CPU密集型任务，IO密集型任务和混合型任务。</li>
<li>任务的优先级：高，中和低。</li>
<li>任务的执行时间：长，中和短。</li>
<li>任务的依赖性：是否依赖其他系统资源，如数据库连接。</li>
</ol>
<p>任务性质不同的任务可以用不同规模的线程池分开处理。CPU密集型任务配置尽可能小的线程，如配置Ncpu+1个线程的线程池。IO密集型任务则由于线程并不是一直在执行任务，则配置尽可能多的线程，如2/*Ncpu。混合型的任务，如果可以拆分，则将其拆分成一个CPU密集型任务和一个IO密集型任务，只要这两个任务执行的时间相差不是太大，那么分解后执行的吞吐率要高于串行执行的吞吐率，如果这两个任务执行时间相差太大，则没必要进行分解。我们可以通过Runtime.getRuntime().availableProcessors()方法获得当前设备的CPU个数。</p>
<p>优先级不同的任务可以使用优先级队列PriorityBlockingQueue来处理。它可以让优先级高的任务先得到执行，需要注意的是如果一直有优先级高的任务提交到队列里，那么优先级低的任务可能永远不能执行。</p>
<p>执行时间不同的任务可以交给不同规模的线程池来处理，或者也可以使用优先级队列，让执行时间短的任务先执行。</p>
<p>依赖数据库连接池的任务，因为线程提交SQL后需要等待数据库返回结果，如果等待的时间越长CPU空闲时间就越长，那么线程数应该设置越大，这样才能更好的利用CPU。</p>
<p>建议使用有界队列，有界队列能增加系统的稳定性和预警能力，可以根据需要设大一点，比如几千。有一次我们组使用的后台任务线程池的队列和线程池全满了，不断的抛出抛弃任务的异常，通过排查发现是数据库出现了问题，导致执行SQL变得非常缓慢，因为后台任务线程池里的任务全是需要向数据库查询和插入数据的，所以导致线程池里的工作线程全部阻塞住，任务积压在线程池里。如果当时我们设置成无界队列，线程池的队列就会越来越多，有可能会撑满内存，导致整个系统不可用，而不只是后台任务出现问题。当然我们的系统所有的任务是用的单独的服务器部署的，而我们使用不同规模的线程池跑不同类型的任务，但是出现这样问题时也会影响到其他任务。</p>
<h2 id="5-">5. 线程池的监控</h2>
<p>通过线程池提供的参数进行监控。线程池里有一些属性在监控线程池的时候可以使用</p>
<ul>
<li>taskCount：线程池需要执行的任务数量。</li>
<li>completedTaskCount：线程池在运行过程中已完成的任务数量。小于或等于taskCount。</li>
<li>largestPoolSize：线程池曾经创建过的最大线程数量。通过这个数据可以知道线程池是否满过。如等于线程池的最大大小，则表示线程池曾经满了。</li>
<li>getPoolSize:线程池的线程数量。如果线程池不销毁的话，池里的线程不会自动销毁，所以这个大小只增不+ getActiveCount：获取活动的线程数。</li>
</ul>
<p>通过扩展线程池进行监控。通过继承线程池并重写线程池的beforeExecute，afterExecute和terminated方法，我们可以在任务执行前，执行后和线程池关闭前干一些事情。如监控任务的平均执行时间，最大执行时间和最小执行时间等。这几个方法在线程池里是空方法。如：
protected void beforeExecute(Thread t, Runnable r) { }</p>
<h2 id="6-">6. 参考资料</h2>
<ul>
<li>Java并发编程实战。</li>
<li>JDK1.6源码</li>
</ul>
<h2 id="-">作者介绍</h2>
<p><strong>方腾飞</strong>，花名清英，淘宝资深开发工程师，关注并发编程，目前在广告技术部从事无线广告联盟的开发和设计工作。个人博客：<a href="http://ifeve.com/" target="_blank"><a href="http://ifeve.com">http://ifeve.com</a></a> 微博：<a href="http://weibo.com/kirals" target="_blank"><a href="http://weibo.com/kirals">http://weibo.com/kirals</a></a> 欢迎通过我的微博进行技术交流。</p>
<p>感谢<a href="http://www.infoq.com/cn/bycategory.action?authorName=张龙" target="_blank">张龙</a>对本文的审校。</p>
<p>给InfoQ中文站投稿或者参与内容翻译工作，请邮件至<a href="mailto:editors@cn.infoq.com">editors@cn.infoq.com</a>。也欢迎大家通过新浪微博（<a href="http://www.weibo.com/infoqchina" target="_blank">@InfoQ</a>）或者腾讯微博（<a href="http://t.qq.com/infoqchina" target="_blank">@InfoQ</a>）关注我们，并与我们的编辑和其他读者朋友交流。</p>
<ul>
<li><a href="">Sections</a></li>
<li><a href="http://www.infoq.com/cn/development" target="_blank"><strong>语言 &amp; 开发</strong></a></li>
<li><a href="">Topics</a></li>
<li><a href="http://www.infoq.com/cn/threading" target="_blank">线程技术</a></li>
<li><a href="http://www.infoq.com/cn/Multi-threading" target="_blank">多线程</a></li>
<li><a href="http://www.infoq.com/cn/concurrency" target="_blank">并发</a></li>
<li><a href="http://www.infoq.com/cn/java" target="_blank">Java</a></li>
<li><a href="http://www.infoq.com/cn/threadPool" target="_blank">线程池</a></li>
<li><a href="http://www.infoq.com/cn/thread" target="_blank">线程</a></li>
</ul>
<p>相关内容</p>
<h3 id="-java-http-www-infoq-com-cn-articles-java-memory-model-7-utm_source-infoq-utm_medium-related_content_link-utm_campaign-relatedcontent_articles_clk-"><a href="http://www.infoq.com/cn/articles/java-memory-model-7?utm_source=infoq&amp;utm_medium=related_content_link&amp;utm_campaign=relatedContent_articles_clk" target="_blank">深入理解Java内存模型（七）——总结</a></h3>
<h3 id="-java-final-http-www-infoq-com-cn-articles-java-memory-model-6-utm_source-infoq-utm_medium-related_content_link-utm_campaign-relatedcontent_articles_clk-"><a href="http://www.infoq.com/cn/articles/java-memory-model-6?utm_source=infoq&amp;utm_medium=related_content_link&amp;utm_campaign=relatedContent_articles_clk" target="_blank">深入理解Java内存模型（六）——final</a></h3>
<h3 id="-java-http-www-infoq-com-cn-articles-java-memory-model-5-utm_source-infoq-utm_medium-related_content_link-utm_campaign-relatedcontent_articles_clk-"><a href="http://www.infoq.com/cn/articles/java-memory-model-5?utm_source=infoq&amp;utm_medium=related_content_link&amp;utm_campaign=relatedContent_articles_clk" target="_blank">深入理解Java内存模型（五）——锁</a></h3>
<h3 id="-concurrentlinkedqueue-http-www-infoq-com-cn-articles-concurrentlinkedqueue-utm_source-infoq-utm_medium-related_content_link-utm_campaign-relatedcontent_articles_clk-"><a href="http://www.infoq.com/cn/articles/ConcurrentLinkedQueue?utm_source=infoq&amp;utm_medium=related_content_link&amp;utm_campaign=relatedContent_articles_clk" target="_blank">聊聊并发（六）——ConcurrentLinkedQueue的实现原理分析</a></h3>
<h3 id="-http-www-infoq-com-cn-articles-atomic-operation-utm_source-infoq-utm_medium-related_content_link-utm_campaign-relatedcontent_articles_clk-"><a href="http://www.infoq.com/cn/articles/atomic-operation?utm_source=infoq&amp;utm_medium=related_content_link&amp;utm_campaign=relatedContent_articles_clk" target="_blank">聊聊并发（五）——原子操作的实现原理</a></h3>
<h3 id="-java-http-www-infoq-com-cn-articles-java-memory-model-7-utm_source-infoq-utm_medium-related_content_link-utm_campaign-relatedcontent_articles_clk-"><a href="http://www.infoq.com/cn/articles/java-memory-model-7?utm_source=infoq&amp;utm_medium=related_content_link&amp;utm_campaign=relatedContent_articles_clk" target="_blank">深入理解Java内存模型（七）——总结</a></h3>
<h3 id="-java-final-http-www-infoq-com-cn-articles-java-memory-model-6-utm_source-infoq-utm_medium-related_content_link-utm_campaign-relatedcontent_articles_clk-"><a href="http://www.infoq.com/cn/articles/java-memory-model-6?utm_source=infoq&amp;utm_medium=related_content_link&amp;utm_campaign=relatedContent_articles_clk" target="_blank">深入理解Java内存模型（六）——final</a></h3>
<h3 id="-java-http-www-infoq-com-cn-articles-java-memory-model-5-utm_source-infoq-utm_medium-related_content_link-utm_campaign-relatedcontent_articles_clk-"><a href="http://www.infoq.com/cn/articles/java-memory-model-5?utm_source=infoq&amp;utm_medium=related_content_link&amp;utm_campaign=relatedContent_articles_clk" target="_blank">深入理解Java内存模型（五）——锁</a></h3>
<h3 id="-java-http-www-infoq-com-cn-minibooks-java_memory_model-utm_source-infoq-utm_medium-related_content_link-utm_campaign-relatedcontent_articles_clk-"><a href="http://www.infoq.com/cn/minibooks/java_memory_model?utm_source=infoq&amp;utm_medium=related_content_link&amp;utm_campaign=relatedContent_articles_clk" target="_blank">深入理解Java内存模型</a></h3>
<h3 id="-java-volatile-http-www-infoq-com-cn-articles-java-memory-model-4-utm_source-infoq-utm_medium-related_content_link-utm_campaign-relatedcontent_articles_clk-"><a href="http://www.infoq.com/cn/articles/java-memory-model-4?utm_source=infoq&amp;utm_medium=related_content_link&amp;utm_campaign=relatedContent_articles_clk" target="_blank">深入理解Java内存模型（四）——volatile</a></h3>
<h2 id="-">您好，陌生人！</h2>
<p>您需要 <a href="http://www.infoq.com/reginit.action" target="_blank">注册一个InfoQ账号</a> 或者 <a href="">登录</a> 才能进行评论。在您完成注册后还需要进行一些设置。</p>
<h2 id="-infoq-">获得来自InfoQ的更多体验。<a href=""></a></h2>
<p>允许的HTML标签: a,b,br,blockquote,i,li,pre,u,ul,p</p>
<p>当有人回复此评论时请E-mail通知我</p>
<p>社区评论 <a href="">Watch Thread</a></p>
<p><a href=""><strong>拜读，有一些困惑望解答</strong> by 史 雨鑫 Posted 16/11/2012 03:19</a>
<a href=""><strong>Re: 拜读，有一些困惑望解答</strong> by 方 腾飞 Posted 16/11/2012 05:06</a></p>
<p><a href=""><strong>Re: 拜读，有一些困惑望解答</strong> by 萧 欢 Posted 18/11/2012 12:57</a>
<a href=""><strong>Re: 拜读，有一些困惑望解答</strong> by 方 腾飞 Posted 18/11/2012 02:43</a></p>
<p><a href=""><strong>能谈谈thread pool和多核CPU的关系吗？ 怎样能保证thread pool的配置，让其能够最大化的压栈多核cpu</strong> by biao jiang Posted 20/11/2012 11:02</a>
<a href=""><strong>Re: 能谈谈thread pool和多核CPU的关系吗？ 怎样能保证thread pool的配置，让其能够最大化的压栈多核cpu</strong> by 萧 欢 Posted 20/11/2012 02:26</a></p>
<p><a href=""><strong>Re: 能谈谈thread pool和多核CPU的关系吗？ 怎样能保证thread pool的配置，让其能够最大化的压栈多核cpu</strong> by 老 bull Posted 22/11/2012 11:48</a>
<a href=""><strong>Re: 能谈谈thread pool和多核CPU的关系吗？ 怎样能保证thread pool的配置，让其能够最大化的压栈多核cpu</strong> by 方 腾飞 Posted 26/11/2012 00:00</a></p>
<p><a href=""><strong>使用的一些问题?</strong> by Qiao stephen Posted 25/02/2013 02:23</a>
<a href=""><strong>Re: 使用的一些问题?</strong> by vince vince Posted 16/04/2013 02:45</a></p>
<p><a href=""><strong>不知道是不是错误</strong> by 高 鹏翔 Posted 29/03/2013 01:53</a>
<a href=""><strong>Re: 不知道是不是错误</strong> by 方 腾飞 Posted 18/05/2013 01:25</a></p>
<p><a href=""><strong>昨晚再次阅读了该文，有几个问题需要解答</strong> by 王 明军 Posted 27/05/2013 09:11</a>
<a href=""><strong>Re: 昨晚再次阅读了该文，有几个问题需要解答</strong> by 方 腾飞 Posted 13/06/2013 03:38</a>
<a href=""></a></p>
<p><strong>拜读，有一些困惑望解答</strong> 16/11/2012 03:19 by 史 雨鑫</p>
<p>腾飞，线程池分析小节中，“队列是否满了”-&gt;”线程池是否满了“过程中，假设使用ArrayBlockingQueue队列，文中提到如果队列满了，并且线程池没满，则会新建线程处理此任务，那问题是此任务有可能会在队列任务被执行前执行，这样就不满足”先进先出“原则了吧？望解答。</p>
<ul>
<li><a href="">回复</a></li>
<li><a href="">回到顶部</a></li>
</ul>
<p><a href=""></a></p>
<p><strong>Re: 拜读，有一些困惑望解答</strong> 16/11/2012 05:06 by 方 腾飞</p>
<p>此任务是提交给线程池执行的新任务，不在队列里。队列里的任务存储的都是以前提交的任务，它们需要等待线程空闲时来执行。</p>
<ul>
<li><a href="">回复</a></li>
<li><a href="">回到顶部</a>
<a href=""></a></li>
</ul>
<p><strong>Re: 拜读，有一些困惑望解答</strong> 18/11/2012 12:57 by 萧 欢</p>
<p>你的理解是对的。如果在创建线程池的时候，指定的corePoolSize<maximumPoolsize是会出现你说的这种情况，这在线程池机制中称为“应急处理”。如果你的线程池模型用于任务有严格的先后顺序的情况下，指定corePoolSize=maximumPoolsize就不会有你说的问题了。通常用newFixedThreadPool这个工厂方法创建的线程池是corePoolSize=maximumPoolsize，遵循先进先出></p>
<ul>
<li><a href="">回复</a></li>
<li><a href="">回到顶部</a></li>
</ul>
<p><a href=""></a></p>
<p><strong>Re: 拜读，有一些困惑望解答</strong> 18/11/2012 02:43 by 方 腾飞</p>
<p>是的。之前没理解你的问题。</p>
<ul>
<li><a href="">回复</a></li>
<li><a href="">回到顶部</a>
<a href=""></a></li>
</ul>
<p><strong>能谈谈thread pool和多核CPU的关系吗？ 怎样能保证thread pool的配置，让其能够最大化的压栈多核cpu</strong> 20/11/2012 11:02 by biao jiang</p>
<p>能谈谈thread pool和多核CPU的关系吗？ 怎样能保证thread pool的配置，让其能够最大化的压栈多核cpu</p>
<ul>
<li><a href="">回复</a></li>
<li><a href="">回到顶部</a></li>
</ul>
<p><a href=""></a></p>
<p><strong>Re: 能谈谈thread pool和多核CPU的关系吗？ 怎样能保证thread pool的配置，让其能够最大化的压栈多核cpu</strong> 20/11/2012 02:26 by 萧 欢</p>
<p>这个应该挺难的。只能说，理论上一个CPU分配一个线程是最优的情况，然而这只是理论上。线程池和CPU核数的关系也与线程池的任务模型息息相关，是CPU密集型还是I/O密集型。最简单的方式就是动态递增的增加线程池数目然后跑一段时间程序，观察系统吞吐率，寻找最适合你的那个高层点</p>
<ul>
<li><a href="">回复</a></li>
<li><a href="">回到顶部</a>
<a href=""></a></li>
</ul>
<p><strong>Re: 能谈谈thread pool和多核CPU的关系吗？ 怎样能保证thread pool的配置，让其能够最大化的压栈多核cpu</strong> 22/11/2012 11:48 by 老 bull</p>
<p>Java 1.2之后线程都是采用内核级线程（进程）实现的，一个JAVA用户线程最终会对应到一个内核线程上面托管，而内核线程在CPU上的调度是依赖操作系统的，这个问题可以从操作系统层面上解决或者寻求答案。</p>
<ul>
<li><a href="">回复</a></li>
<li><a href="">回到顶部</a></li>
</ul>
<p><a href=""></a></p>
<p><strong>Re: 能谈谈thread pool和多核CPU的关系吗？ 怎样能保证thread pool的配置，让其能够最大化的压栈多核cpu</strong> 26/11/2012 00:00 by 方 腾飞</p>
<p>文中有提到如果是CPU密集型任务，使用Ncpu+1个线程可以很好的压榨CPU。详细的可以参见“合理的配置线程池”章节。</p>
<ul>
<li><a href="">回复</a></li>
<li><a href="">回到顶部</a>
<a href=""></a></li>
</ul>
<p><strong>使用的一些问题?</strong> 25/02/2013 02:23 by Qiao stephen</p>
<p>如果我在一个应用中,存在多个小服务,每个服务都开启一个线程,请问那么是在整个应用中开启一个线程池还是每个小服务开启
一个线程池呢?如果是每个小服务开启一个,各个线程池之间又是怎么管理呢?
是不是使用一个线程池来管理上面的多个线程池呢?</p>
<ul>
<li><a href="">回复</a></li>
<li><a href="">回到顶部</a></li>
</ul>
<p><a href=""></a></p>
<p><strong>不知道是不是错误</strong> 29/03/2013 01:53 by 高 鹏翔</p>
<p>◦DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务。
这个策略,我看的时候有点疑惑,进入代码里面看了下,应该是丢弃待执行的任务队列的对首,但是这个队列是FIFO的,所以我觉得应该是丢弃最远的一个任务,不知道是否理解的有误解,忘指正</p>
<ul>
<li><a href="">回复</a></li>
<li><a href="">回到顶部</a>
<a href=""></a></li>
</ul>
<p><strong>Re: 使用的一些问题?</strong> 16/04/2013 02:45 by vince vince</p>
<p>应该是在应用中建一个线程池，把每个服务要执行的方法体封装成Runnable对象提交到线程池里执行吧，线程池顾名思义，就是一个线程库，事先为你建好，要用的时候丢给它，它给你返回结果，至于优势嘛开头说得很清楚了~这么做可以简化客户端代码复杂度，让他只关心自己的线程体逻辑，而线程本身的生命周期等都不需要自己操心~</p>
<ul>
<li><a href="">回复</a></li>
<li><a href="">回到顶部</a></li>
</ul>
<p><a href=""></a></p>
<p><strong>Re: 不知道是不是错误</strong> 18/05/2013 01:25 by 方 腾飞</p>
<p>的确是丢弃最远的任务，源码如下
public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
if (!e.isShutdown()) {
e.getQueue().poll();
e.execute(r);
}
}</p>
<ul>
<li><a href="">回复</a></li>
<li><a href="">回到顶部</a>
<a href=""></a></li>
</ul>
<p><strong>昨晚再次阅读了该文，有几个问题需要解答</strong> 27/05/2013 09:11 by 王 明军</p>
<p>1、文中提到了线程池的关闭，那么线程池在什么情况下执行关闭呢？
2、什么是CPU密集型任务？
谢谢！有个问题通过阅读评论已经解决，是丢弃任务那个问题。</p>
<ul>
<li><a href="">回复</a></li>
<li><a href="">回到顶部</a></li>
</ul>
<p><a href=""></a></p>
<p><strong>Re: 昨晚再次阅读了该文，有几个问题需要解答</strong> 13/06/2013 03:38 by 方 腾飞</p>
<p>1：不需要使用的时候就关闭。比如服务器暂停使用。
2：CPU密集型任务，如压缩和解压缩，这种需要CPU不停的计算的任务。</p>
<ul>
<li><a href="">回复</a></li>
<li><a href="">回到顶部</a></li>
</ul>
<p><a href="">关闭</a></p>
<h3 id="-by"><em>**</em>by</h3>
<p>发布于</p>
<ul>
<li><a href="">查看</a></li>
<li><a href="">回复</a></li>
<li><a href="">回到顶部</a>
<a href="">关闭</a> 主题  您的回复 <a href="">引用原消息</a></li>
</ul>
<p>允许的HTML标签: a,b,br,blockquote,i,li,pre,u,ul,p
当有人回复此评论时请E-mail通知我</p>
<p><a href="">关闭</a> 主题  您的回复</p>
<p>允许的HTML标签: a,b,br,blockquote,i,li,pre,u,ul,p
当有人回复此评论时请E-mail通知我
<a href="">关闭</a></p>
<ul>
<li>热点内容</li>
<li><a href="">本周</a></li>
<li><a href="">本月</a></li>
<li><a href="">近6个月</a><h3 id="-32-http-www-infoq-com-cn-news-2012-08-32-most-important-algorithms-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2012/08/32-most-important-algorithms?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">计算机科学中最重要的32个算法</a></h3>
</li>
</ul>
<h3 id="-thoughtworks-2013-5-http-www-infoq-com-cn-articles-thoughtworks-technology-radar-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/thoughtWorks-technology-radar?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">ThoughtWorks技术雷达（2013年5月）</a></h3>
<h3 id="-1-5-http-www-infoq-com-cn-articles-iqiyi-cloud-push-practices-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/iqiyi-cloud-push-practices?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">让1.5亿移动端用户第一时间获取消息</a></h3>
<h3 id="-thoughtworks-ceo-http-www-infoq-com-cn-news-2013-06-tw-guoxiao-on-talents-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2013/06/tw-guoxiao-on-talents?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">ThoughtWorks全球CEO郭晓谈软件人才的招聘与培养</a></h3>
<h3 id="-http-www-infoq-com-cn-news-2013-06-10-sins-for-scalability-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2013/06/10-sins-for-scalability?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">影响可扩展性的十宗罪</a></h3>
<h3 id="-6-http-www-infoq-com-cn-minibooks-architect-jun-10-2013-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/architect-jun-10-2013?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">架构师（6月刊）</a></h3>
<h3 id="-http-www-infoq-com-cn-articles-function-switch-realize-better-continuous-implementations-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/function-switch-realize-better-continuous-implementations?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">使用功能开关更好地实现持续部署</a></h3>
<h3 id="-eclipse-github-http-www-infoq-com-cn-news-2013-06-eclipse-github-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2013/06/eclipse-github?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">Eclipse迁移到GitHub</a></h3>
<h3 id="-newegg-com-http-www-infoq-com-cn-presentations-newegg-big-data-practice-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/presentations/newegg-big-data-practice?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">Newegg.com大数据实践</a></h3>
<h3 id="-http-www-infoq-com-cn-minibooks-software-sys-architect-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/software-sys-architect?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">软件系统架构：使用视点和视角与利益相关者合作</a></h3>
<h3 id="-32-http-www-infoq-com-cn-news-2012-08-32-most-important-algorithms-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2012/08/32-most-important-algorithms?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">计算机科学中最重要的32个算法</a></h3>
<h3 id="-6-http-www-infoq-com-cn-minibooks-architect-jun-10-2013-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/architect-jun-10-2013?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">架构师（6月刊）</a></h3>
<h3 id="-rest-http-www-infoq-com-cn-news-2013-06-rest-drawbacks-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2013/06/rest-drawbacks?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">REST的缺点是什么？</a></h3>
<h3 id="-google-web-ui-polymer-http-www-infoq-com-cn-news-2013-06-webcomponents-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2013/06/webcomponents?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">Google 发布新一代Web UI库Polymer</a></h3>
<h3 id="-http-www-infoq-com-cn-news-2013-06-dianping-xinnet-hacked-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2013/06/dianping-xinnet-hacked?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">大众点评网域名劫持事件概述</a></h3>
<h3 id="-node-js-grunt-js-http-www-infoq-com-cn-articles-gruntjs-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/GruntJs?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">基于Node.js的自动化构建工具Grunt.js</a></h3>
<h3 id="-node-js-node-js-http-www-infoq-com-cn-articles-what-is-nodejs-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/what-is-nodejs?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">深入浅出Node.js（一）：什么是Node.js</a></h3>
<h3 id="-http-www-infoq-com-cn-minibooks-i-m-wrights-hard-code-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/i-m-wrights-hard-code?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">代码之殇·第二版</a></h3>
<h3 id="-http-www-infoq-com-cn-minibooks-software-sys-architect-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/software-sys-architect?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">软件系统架构：使用视点和视角与利益相关者合作</a></h3>
<h3 id="-18-java-http-www-infoq-com-cn-news-2013-06-zhuhong-on-java-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2013/06/zhuhong-on-java?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">大家谈18岁的Java——朱鸿：开过跑车后再去开大巴车总是有点不爽的</a></h3>
<h3 id="-32-http-www-infoq-com-cn-news-2012-08-32-most-important-algorithms-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2012/08/32-most-important-algorithms?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">计算机科学中最重要的32个算法</a></h3>
<h3 id="-java-http-www-infoq-com-cn-articles-java-memory-model-1-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/java-memory-model-1?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">深入理解Java内存模型（一）——基础</a></h3>
<h3 id="-node-js-node-js-http-www-infoq-com-cn-articles-what-is-nodejs-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/what-is-nodejs?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">深入浅出Node.js（一）：什么是Node.js</a></h3>
<h3 id="-node-js-node-js-npm-http-www-infoq-com-cn-articles-nodejs-npm-install-config-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/nodejs-npm-install-config?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">深入浅出Node.js（二）：Node.js&amp;NPM的安装与配置</a></h3>
<h3 id="-3-http-www-infoq-com-cn-minibooks-architect-mar-10-2013-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/architect-mar-10-2013?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">架构师（3月刊）</a></h3>
<h3 id="-1-http-www-infoq-com-cn-minibooks-architect-jan-10-2013-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/architect-jan-10-2013?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">架构师（1月刊）</a></h3>
<h3 id="-4-http-www-infoq-com-cn-minibooks-architect-apr-10-2013-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/architect-apr-10-2013?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">架构师（4月刊）</a></h3>
<h3 id="-java-http-www-infoq-com-cn-articles-java-threadpool-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/java-threadPool?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">聊聊并发（三）——JAVA线程池的分析和使用</a></h3>
<h3 id="-2-http-www-infoq-com-cn-minibooks-architect-feb-10-2013-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/architect-feb-10-2013?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">架构师（2月刊）</a></h3>
<h3 id="-12306-github-http-www-infoq-com-cn-news-2013-01-12306-plugin-ddos-github-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2013/01/12306-plugin-ddos-github?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">12306订票助手插件拖垮GitHub事件原因始末</a></h3>
<h3 id="-32-http-www-infoq-com-cn-news-2012-08-32-most-important-algorithms-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2012/08/32-most-important-algorithms?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">计算机科学中最重要的32个算法</a></h3>
<h3 id="-thoughtworks-2013-5-http-www-infoq-com-cn-articles-thoughtworks-technology-radar-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/thoughtWorks-technology-radar?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">ThoughtWorks技术雷达（2013年5月）</a></h3>
<h3 id="-1-5-http-www-infoq-com-cn-articles-iqiyi-cloud-push-practices-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/iqiyi-cloud-push-practices?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">让1.5亿移动端用户第一时间获取消息</a></h3>
<h3 id="-thoughtworks-ceo-http-www-infoq-com-cn-news-2013-06-tw-guoxiao-on-talents-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2013/06/tw-guoxiao-on-talents?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">ThoughtWorks全球CEO郭晓谈软件人才的招聘与培养</a></h3>
<h3 id="-http-www-infoq-com-cn-news-2013-06-10-sins-for-scalability-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2013/06/10-sins-for-scalability?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">影响可扩展性的十宗罪</a></h3>
<h3 id="-6-http-www-infoq-com-cn-minibooks-architect-jun-10-2013-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/architect-jun-10-2013?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">架构师（6月刊）</a></h3>
<h3 id="-http-www-infoq-com-cn-articles-function-switch-realize-better-continuous-implementations-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/function-switch-realize-better-continuous-implementations?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">使用功能开关更好地实现持续部署</a></h3>
<h3 id="-eclipse-github-http-www-infoq-com-cn-news-2013-06-eclipse-github-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2013/06/eclipse-github?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">Eclipse迁移到GitHub</a></h3>
<h3 id="-newegg-com-http-www-infoq-com-cn-presentations-newegg-big-data-practice-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/presentations/newegg-big-data-practice?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">Newegg.com大数据实践</a></h3>
<h3 id="-http-www-infoq-com-cn-minibooks-software-sys-architect-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/software-sys-architect?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">软件系统架构：使用视点和视角与利益相关者合作</a></h3>
<h3 id="-32-http-www-infoq-com-cn-news-2012-08-32-most-important-algorithms-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2012/08/32-most-important-algorithms?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">计算机科学中最重要的32个算法</a></h3>
<h3 id="-6-http-www-infoq-com-cn-minibooks-architect-jun-10-2013-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/architect-jun-10-2013?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">架构师（6月刊）</a></h3>
<h3 id="-rest-http-www-infoq-com-cn-news-2013-06-rest-drawbacks-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2013/06/rest-drawbacks?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">REST的缺点是什么？</a></h3>
<h3 id="-google-web-ui-polymer-http-www-infoq-com-cn-news-2013-06-webcomponents-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2013/06/webcomponents?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">Google 发布新一代Web UI库Polymer</a></h3>
<h3 id="-http-www-infoq-com-cn-news-2013-06-dianping-xinnet-hacked-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2013/06/dianping-xinnet-hacked?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">大众点评网域名劫持事件概述</a></h3>
<h3 id="-node-js-grunt-js-http-www-infoq-com-cn-articles-gruntjs-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/GruntJs?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">基于Node.js的自动化构建工具Grunt.js</a></h3>
<h3 id="-node-js-node-js-http-www-infoq-com-cn-articles-what-is-nodejs-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/what-is-nodejs?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">深入浅出Node.js（一）：什么是Node.js</a></h3>
<h3 id="-http-www-infoq-com-cn-minibooks-i-m-wrights-hard-code-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/i-m-wrights-hard-code?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">代码之殇·第二版</a></h3>
<h3 id="-http-www-infoq-com-cn-minibooks-software-sys-architect-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/software-sys-architect?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">软件系统架构：使用视点和视角与利益相关者合作</a></h3>
<h3 id="-18-java-http-www-infoq-com-cn-news-2013-06-zhuhong-on-java-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2013/06/zhuhong-on-java?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">大家谈18岁的Java——朱鸿：开过跑车后再去开大巴车总是有点不爽的</a></h3>
<h3 id="-32-http-www-infoq-com-cn-news-2012-08-32-most-important-algorithms-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2012/08/32-most-important-algorithms?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">计算机科学中最重要的32个算法</a></h3>
<h3 id="-java-http-www-infoq-com-cn-articles-java-memory-model-1-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/java-memory-model-1?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">深入理解Java内存模型（一）——基础</a></h3>
<h3 id="-node-js-node-js-http-www-infoq-com-cn-articles-what-is-nodejs-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/what-is-nodejs?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">深入浅出Node.js（一）：什么是Node.js</a></h3>
<h3 id="-node-js-node-js-npm-http-www-infoq-com-cn-articles-nodejs-npm-install-config-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/nodejs-npm-install-config?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">深入浅出Node.js（二）：Node.js&amp;NPM的安装与配置</a></h3>
<h3 id="-3-http-www-infoq-com-cn-minibooks-architect-mar-10-2013-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/architect-mar-10-2013?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">架构师（3月刊）</a></h3>
<h3 id="-1-http-www-infoq-com-cn-minibooks-architect-jan-10-2013-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/architect-jan-10-2013?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">架构师（1月刊）</a></h3>
<h3 id="-4-http-www-infoq-com-cn-minibooks-architect-apr-10-2013-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/architect-apr-10-2013?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">架构师（4月刊）</a></h3>
<h3 id="-java-http-www-infoq-com-cn-articles-java-threadpool-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/java-threadPool?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">聊聊并发（三）——JAVA线程池的分析和使用</a></h3>
<h3 id="-2-http-www-infoq-com-cn-minibooks-architect-feb-10-2013-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/architect-feb-10-2013?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">架构师（2月刊）</a></h3>
<h3 id="-12306-github-http-www-infoq-com-cn-news-2013-01-12306-plugin-ddos-github-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2013/01/12306-plugin-ddos-github?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">12306订票助手插件拖垮GitHub事件原因始末</a></h3>
<h2 id="-">深度内容</h2>
<ul>
<li><a href="">全部</a></li>
<li><a href="">文章</a></li>
<li><a href="">演讲</a></li>
<li><a href="">访谈</a></li>
<li><a href="">迷你书</a></li>
</ul>
<h2 id="-juergen-fesslmeier-javascript-http-www-infoq-com-cn-interviews-end-to-end-javascript-juergen-fesslmeier-javascript-"><a href="http://www.infoq.com/cn/interviews/end-to-end-javascript" title="Juergen Fesslmeier谈端到端的JavaScript开发" target="_blank">Juergen Fesslmeier谈端到端的JavaScript开发</a></h2>
<p><a href="http://www.infoq.com/cn/author/Juergen-Fesslmeier" title="Juergen Fesslmeier" target="_blank">Juergen Fesslmeier</a> 七月 02, 2013</p>
<p><a href="http://www.infoq.com/cn/interviews/end-to-end-javascript" title="Juergen Fesslmeier谈端到端的JavaScript开发" target="_blank"><img src="" alt=""></a></p>
<h2 id="-http-www-infoq-com-cn-articles-design-pattern-automation-"><a href="http://www.infoq.com/cn/articles/Design-Pattern-Automation" title="设计模式自动化" target="_blank">设计模式自动化</a></h2>
<p><a href="http://www.infoq.com/cn/author/Gael-Fraiteur-and-Yan-Cui" title="Gael Fraiteur and Yan Cui" target="_blank">Gael Fraiteur and Yan Cui</a> 七月 01, 2013</p>
<p><a href="http://www.infoq.com/cn/articles/Design-Pattern-Automation" title="设计模式自动化" target="_blank"><img src="" alt=""></a></p>
<h2 id="-http-www-infoq-com-cn-articles-designing-a-world-at-your-fingertips-mobile-user-interfaces-"><a href="http://www.infoq.com/cn/articles/designing-a-world-at-your-fingertips-mobile-user-interfaces" title="设计指尖上的世界：移动用户界面一瞥" target="_blank">设计指尖上的世界：移动用户界面一瞥</a></h2>
<p><a href="http://www.infoq.com/cn/author/Forrest-Shull" title="Forrest Shull" target="_blank">Forrest Shull</a> 六月 28, 2013</p>
<p><a href="http://www.infoq.com/cn/articles/designing-a-world-at-your-fingertips-mobile-user-interfaces" title="设计指尖上的世界：移动用户界面一瞥" target="_blank"><img src="" alt=""></a></p>
<h2 id="-alm-http-www-infoq-com-cn-articles-integrated-alm-alm-"><a href="http://www.infoq.com/cn/articles/Integrated-ALM" title="成功的根本—集成的ALM工具" target="_blank">成功的根本—集成的ALM工具</a></h2>
<p><a href="http://www.infoq.com/cn/author/Dave-West" title="Dave West" target="_blank">Dave West</a> 六月 28, 2013</p>
<p><a href="http://www.infoq.com/cn/articles/Integrated-ALM" title="成功的根本—集成的ALM工具" target="_blank"><img src="" alt=""></a></p>
<h2 id="-http-www-infoq-com-cn-articles-atdd-by-example-book-"><a href="http://www.infoq.com/cn/articles/atdd-by-example-book" title="书评：验收测试驱动开发实践指南" target="_blank">书评：验收测试驱动开发实践指南</a></h2>
<p><a href="http://www.infoq.com/cn/author/Manuel-Pais" title="Manuel Pais" target="_blank">Manuel Pais</a> 六月 26, 2013</p>
<p><a href="http://www.infoq.com/cn/articles/atdd-by-example-book" title="书评：验收测试驱动开发实践指南" target="_blank"><img src="" alt=""></a></p>
<h2 id="-web-http-www-infoq-com-cn-presentations-across-device-web-web-"><a href="http://www.infoq.com/cn/presentations/across-device-web" title="跨终端的web" target="_blank">跨终端的web</a></h2>
<p><a href="http://www.infoq.com/cn/author/%E8%88%92%E6%96%87%E4%BA%AE" title="舒文亮" target="_blank">舒文亮</a> 六月 26, 2013</p>
<p><a href="http://www.infoq.com/cn/presentations/across-device-web" title="跨终端的web" target="_blank"><img src="" alt=""></a></p>
<ul>
<li><a href="">更早的 &gt;</a></li>
</ul>
<p>语言 &amp; 开发</p>
<p><a href="http://www.infoq.com/cn/interviews/end-to-end-javascript" title="Juergen Fesslmeier谈端到端的JavaScript开发" target="_blank">Juergen Fesslmeier谈端到端的JavaScript开发</a></p>
<p><a href="http://www.infoq.com/cn/news/2013/07/mobilecloud-tfs" title="MobileCloud for TFS支持测试Windows Phone,Android,iOS及BlackBerry应用" target="_blank">MobileCloud for TFS支持测试Windows Phone,Android,iOS及BlackBerry应用</a></p>
<p><a href="http://www.infoq.com/cn/news/2013/07/baidu-salon39-summary" title="百度技术沙龙第39期回顾：前端快速开发实践（含资料下载）" target="_blank">百度技术沙龙第39期回顾：前端快速开发实践（含资料下载）</a></p>
<p>架构 &amp; 设计</p>
<p><a href="http://www.infoq.com/cn/news/2013/07/Native-Performance" title="内存与本机代码的性能" target="_blank">内存与本机代码的性能</a></p>
<p><a href="http://www.infoq.com/cn/articles/Design-Pattern-Automation" title="设计模式自动化" target="_blank">设计模式自动化</a></p>
<p><a href="http://www.infoq.com/cn/news/2013/07/WinRT-Devices" title="连接设备编程" target="_blank">连接设备编程</a>
过程 &amp; 实践</p>
<p><a href="http://www.infoq.com/cn/articles/Integrated-ALM" title="成功的根本—集成的ALM工具" target="_blank">成功的根本—集成的ALM工具</a></p>
<p><a href="http://www.infoq.com/cn/news/2013/06/tw-guoxiao-on-talents" title="ThoughtWorks全球CEO郭晓谈软件人才的招聘与培养" target="_blank">ThoughtWorks全球CEO郭晓谈软件人才的招聘与培养</a></p>
<p><a href="http://www.infoq.com/cn/articles/atdd-by-example-book" title="书评：验收测试驱动开发实践指南" target="_blank">书评：验收测试驱动开发实践指南</a></p>
<p>运维 &amp; 基础架构</p>
<p><a href="http://www.infoq.com/cn/news/2013/06/devops-in-traditional-enterprise" title="在传统企业中引入DevOps" target="_blank">在传统企业中引入DevOps</a></p>
<p><a href="http://www.infoq.com/cn/news/2013/06/dod-ams-day1-s-is-for-security" title="安全性——“DevOpS”中的S" target="_blank">安全性——“DevOpS”中的S</a></p>
<p><a href="http://www.infoq.com/cn/articles/atdd-by-example-book" title="书评：验收测试驱动开发实践指南" target="_blank">书评：验收测试驱动开发实践指南</a>
企业架构</p>
<p><a href="http://www.infoq.com/cn/articles/designing-a-world-at-your-fingertips-mobile-user-interfaces" title="设计指尖上的世界：移动用户界面一瞥" target="_blank">设计指尖上的世界：移动用户界面一瞥</a></p>
<p><a href="http://www.infoq.com/cn/news/2013/06/stratos-2" title="Stratos 2.0已发布，支持所有运行时环境和30个IaaS" target="_blank">Stratos 2.0已发布，支持所有运行时环境和30个IaaS</a></p>
<p><a href="http://www.infoq.com/cn/articles/iqiyi-cloud-push-practices" title="让1.5亿移动端用户第一时间获取消息" target="_blank">让1.5亿移动端用户第一时间获取消息</a></p>
<p>语言 &amp; 开发</p>
<p><a href="http://www.infoq.com/cn/interviews/end-to-end-javascript" title="Juergen Fesslmeier谈端到端的JavaScript开发" target="_blank">Juergen Fesslmeier谈端到端的JavaScript开发</a></p>
<p><a href="http://www.infoq.com/cn/news/2013/07/mobilecloud-tfs" title="MobileCloud for TFS支持测试Windows Phone,Android,iOS及BlackBerry应用" target="_blank">MobileCloud for TFS支持测试Windows Phone,Android,iOS及BlackBerry应用</a></p>
<p><a href="http://www.infoq.com/cn/news/2013/07/baidu-salon39-summary" title="百度技术沙龙第39期回顾：前端快速开发实践（含资料下载）" target="_blank">百度技术沙龙第39期回顾：前端快速开发实践（含资料下载）</a>
架构 &amp; 设计</p>
<p><a href="http://www.infoq.com/cn/news/2013/07/Native-Performance" title="内存与本机代码的性能" target="_blank">内存与本机代码的性能</a></p>
<p><a href="http://www.infoq.com/cn/articles/Design-Pattern-Automation" title="设计模式自动化" target="_blank">设计模式自动化</a></p>
<p><a href="http://www.infoq.com/cn/news/2013/07/WinRT-Devices" title="连接设备编程" target="_blank">连接设备编程</a></p>
<p>过程 &amp; 实践</p>
<p><a href="http://www.infoq.com/cn/articles/Integrated-ALM" title="成功的根本—集成的ALM工具" target="_blank">成功的根本—集成的ALM工具</a></p>
<p><a href="http://www.infoq.com/cn/news/2013/06/tw-guoxiao-on-talents" title="ThoughtWorks全球CEO郭晓谈软件人才的招聘与培养" target="_blank">ThoughtWorks全球CEO郭晓谈软件人才的招聘与培养</a></p>
<p><a href="http://www.infoq.com/cn/articles/atdd-by-example-book" title="书评：验收测试驱动开发实践指南" target="_blank">书评：验收测试驱动开发实践指南</a>
运维 &amp; 基础架构</p>
<p><a href="http://www.infoq.com/cn/news/2013/06/devops-in-traditional-enterprise" title="在传统企业中引入DevOps" target="_blank">在传统企业中引入DevOps</a></p>
<p><a href="http://www.infoq.com/cn/news/2013/06/dod-ams-day1-s-is-for-security" title="安全性——“DevOpS”中的S" target="_blank">安全性——“DevOpS”中的S</a></p>
<p><a href="http://www.infoq.com/cn/articles/atdd-by-example-book" title="书评：验收测试驱动开发实践指南" target="_blank">书评：验收测试驱动开发实践指南</a></p>
<p>企业架构</p>
<p><a href="http://www.infoq.com/cn/articles/designing-a-world-at-your-fingertips-mobile-user-interfaces" title="设计指尖上的世界：移动用户界面一瞥" target="_blank">设计指尖上的世界：移动用户界面一瞥</a></p>
<p><a href="http://www.infoq.com/cn/news/2013/06/stratos-2" title="Stratos 2.0已发布，支持所有运行时环境和30个IaaS" target="_blank">Stratos 2.0已发布，支持所有运行时环境和30个IaaS</a></p>
<p><a href="http://www.infoq.com/cn/articles/iqiyi-cloud-push-practices" title="让1.5亿移动端用户第一时间获取消息" target="_blank">让1.5亿移动端用户第一时间获取消息</a>
<a href="">Close</a> E-mail  密码</p>
<p><a href="http://www.infoq.com/cn/social/googleLogin.action?fl=login" title="使用Google账号登录" target="_blank">使用Google账号登录</a> <a href="http://www.infoq.com/cn/social/liveLogin.action?fl=login" title="使用Microsoft账号登录" target="_blank">使用Microsoft账号登录</a>
<a href="">忘记密码？</a>
 InfoQ账号使用的E-mail 发送邮件</p>
<p><a href="">重新登录</a>
重新发送激活信息 重新发送</p>
<p><a href="">重新登录</a>
<a href="http://www.infoq.com/cn/reginit.action" target="_blank">没有用户名？</a></p>
<p><a href="http://www.infoq.com/cn/reginit.action" target="_blank">点击注册</a></p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/Java_多线程/">Java_多线程</a></li><li><a href="/categories/Java&J2EE/Java_多线程/并发/">并发</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/Java_多线程/" class="label label-success">Java_多线程</a><a href="/tags/并发/" class="label label-info">并发</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:41"datetime="2014-03-07 09:54:41"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-Java_多线程-并发--聊聊并发（三）——JAVA线程池的分析和使用/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-Java_多线程-并发--聊聊并发（三）——JAVA线程池的分析和使用" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_多线程-并发--聊聊并发（四）——深入分析ConcurrentHashMap/">聊聊并发（四）——深入分析ConcurrentHashMap</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:41.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_多线程-并发--聊聊并发（四）——深入分析ConcurrentHashMap/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-concurrenthashmap">聊聊并发（四）——深入分析ConcurrentHashMap</h1>
<h2 id="-">术语定义</h2>
<p>术语 英文 解释 哈希算法 hash algorithm 是一种将任意内容的输入转换成相同长度输出的加密方式，其输出被称为哈希值。 哈希表 hash table 根据设定的哈希函数H(key)和处理冲突方法将一组关键字映象到一个有限的地址区间上，并以关键字在地址区间中的象作为记录在表中的存储位置，这种表称为哈希表或散列，所得存储位置称为哈希地址或散列地址。</p>
<h2 id="-hashmap">线程不安全的HashMap</h2>
<p>因为多线程环境下，使用HashMap进行put操作会引起死循环，导致CPU利用率接近100%，所以在并发情况下不能使用HashMap，如以下代码
final HashMap<String, String> map = new HashMap<String, String>(2);</p>
<p>Thread t = new Thread(new Runnable() {
@Override</p>
<p>public void run() {
for (int i = 0; i &lt; 10000; i++) {</p>
<p>new Thread(new Runnable() {
@Override</p>
<p>public void run() {
map.put(UUID.randomUUID().toString(), &quot;&quot;);</p>
<p>}
}, &quot;ftf&quot; + i).start();</p>
<p>}
}</p>
<p>}, &quot;ftf&quot;);
t.start();</p>
<p>t.join();</p>
<h2 id="-hashtable-">效率低下的HashTable容器</h2>
<p>HashTable容器使用synchronized来保证线程安全，但在线程竞争激烈的情况下HashTable的效率非常低下。因为当一个线程访问HashTable的同步方法时，其他线程访问HashTable的同步方法时，可能会进入阻塞或轮询状态。如线程1使用put进行添加元素，线程2不但不能使用put方法添加元素，并且也不能使用get方法来获取元素，所以竞争越激烈效率越低。</p>
<h2 id="-">锁分段技术</h2>
<p>HashTable容器在竞争激烈的并发环境下表现出效率低下的原因是所有访问HashTable的线程都必须竞争同一把锁，那假如容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效的提高并发访问效率，这就是ConcurrentHashMap所使用的锁分段技术，首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。</p>
<h2 id="concurrenthashmap-">ConcurrentHashMap的结构</h2>
<p>我们通过ConcurrentHashMap的类图来分析ConcurrentHashMap的结构。</p>
<p><img src="" alt=""></p>
<p>ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。Segment是一种可重入锁ReentrantLock，在ConcurrentHashMap里扮演锁的角色，HashEntry则用于存储键值对数据。一个ConcurrentHashMap里包含一个Segment数组，Segment的结构和HashMap类似，是一种数组和链表结构， 一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素， 每个Segment守护者一个HashEntry数组里的元素,当对HashEntry数组的数据进行修改时，必须首先获得它对应的Segment锁。</p>
<p><img src="" alt=""></p>
<h2 id="concurrenthashmap-">ConcurrentHashMap的初始化</h2>
<p>ConcurrentHashMap初始化方法是通过initialCapacity，loadFactor, concurrencyLevel几个参数来初始化segments数组，段偏移量segmentShift，段掩码segmentMask和每个segment里的HashEntry数组 。</p>
<p>初始化segments数组。让我们来看一下初始化segmentShift，segmentMask和segments数组的源代码。
if (concurrencyLevel &gt; MAX_SEGMENTS)</p>
<p>concurrencyLevel = MAX_SEGMENTS;
// Find power-of-two sizes best matching arguments</p>
<p>int sshift = 0;
int ssize = 1;</p>
<p>while (ssize &lt; concurrencyLevel) {
++sshift;</p>
<p>ssize &lt;&lt;= 1;
}</p>
<p>segmentShift = 32 - sshift;
segmentMask = ssize - 1;</p>
<p>this.segments = Segment.newArray(ssize);</p>
<p>由上面的代码可知segments数组的长度ssize通过concurrencyLevel计算得出。为了能通过按位与的哈希算法来定位segments数组的索引，必须保证segments数组的长度是2的N次方（power-of-two size），所以必须计算出一个是大于或等于concurrencyLevel的最小的2的N次方值来作为segments数组的长度。假如concurrencyLevel等于14，15或16，ssize都会等于16，即容器里锁的个数也是16。注意concurrencyLevel的最大大小是65535，意味着segments数组的长度最大为65536，对应的二进制是16位。</p>
<p>初始化segmentShift和segmentMask。这两个全局变量在定位segment时的哈希算法里需要使用，sshift等于ssize从1向左移位的次数，在默认情况下concurrencyLevel等于16，1需要向左移位移动4次，所以sshift等于4。segmentShift用于定位参与hash运算的位数，segmentShift等于32减sshift，所以等于28，这里之所以用32是因为ConcurrentHashMap里的hash()方法输出的最大数是32位的，后面的测试中我们可以看到这点。segmentMask是哈希运算的掩码，等于ssize减1，即15，掩码的二进制各个位的值都是1。因为ssize的最大长度是65536，所以segmentShift最大值是16，segmentMask最大值是65535，对应的二进制是16位，每个位都是1。</p>
<p>初始化每个Segment。输入参数initialCapacity是ConcurrentHashMap的初始化容量，loadfactor是每个segment的负载因子，在构造方法里需要通过这两个参数来初始化数组中的每个segment。
if (initialCapacity &gt; MAXIMUM_CAPACITY)</p>
<p>initialCapacity = MAXIMUM_CAPACITY;
int c = initialCapacity / ssize;</p>
<p>if (c /* ssize &lt; initialCapacity)
++c;</p>
<p>int cap = 1;
while (cap &lt; c)</p>
<p>cap &lt;&lt;= 1;
for (int i = 0; i &lt; this.segments.length; ++i)</p>
<p>this.segments[i] = new Segment<K,V>(cap, loadFactor);</p>
<p>上面代码中的变量cap就是segment里HashEntry数组的长度，它等于initialCapacity除以ssize的倍数c，如果c大于1，就会取大于等于c的2的N次方值，所以cap不是1，就是2的N次方。segment的容量threshold＝(int)cap/*loadFactor，默认情况下initialCapacity等于16，loadfactor等于0.75，通过运算cap等于1，threshold等于零。</p>
<h2 id="-segment">定位Segment</h2>
<p>既然ConcurrentHashMap使用分段锁Segment来保护不同段的数据，那么在插入和获取元素的时候，必须先通过哈希算法定位到Segment。可以看到ConcurrentHashMap会首先使用Wang/Jenkins hash的变种算法对元素的hashCode进行一次再哈希。
private static int hash(int h) {</p>
<p>h += (h &lt;&lt; 15) ^ 0xffffcd7d;
h ^= (h &gt;&gt;&gt; 10);</p>
<p>h += (h &lt;&lt; 3);
h ^= (h &gt;&gt;&gt; 6);</p>
<p>h += (h &lt;&lt; 2) + (h &lt;&lt; 14);
return h ^ (h &gt;&gt;&gt; 16);</p>
<p>}</p>
<p>之所以进行再哈希，其目的是为了减少哈希冲突，使元素能够均匀的分布在不同的Segment上，从而提高容器的存取效率。假如哈希的质量差到极点，那么所有的元素都在一个Segment中，不仅存取元素缓慢，分段锁也会失去意义。我做了一个测试，不通过再哈希而直接执行哈希计算。</p>
<p>System.out.println(Integer.parseInt(&quot;0001111&quot;, 2) &amp; 15);</p>
<p>System.out.println(Integer.parseInt(&quot;0011111&quot;, 2) &amp; 15);
System.out.println(Integer.parseInt(&quot;0111111&quot;, 2) &amp; 15);</p>
<p>System.out.println(Integer.parseInt(&quot;1111111&quot;, 2) &amp; 15);</p>
<p>计算后输出的哈希值全是15，通过这个例子可以发现如果不进行再哈希，哈希冲突会非常严重，因为只要低位一样，无论高位是什么数，其哈希值总是一样。我们再把上面的二进制数据进行再哈希后结果如下，为了方便阅读，不足32位的高位补了0，每隔四位用竖线分割下。</p>
<p>0100｜0111｜0110｜0111｜1101｜1010｜0100｜1110</p>
<p>1111｜0111｜0100｜0011｜0000｜0001｜1011｜1000
0111｜0111｜0110｜1001｜0100｜0110｜0011｜1110</p>
<p>1000｜0011｜0000｜0000｜1100｜1000｜0001｜1010</p>
<p>可以发现每一位的数据都散列开了，通过这种再哈希能让数字的每一位都能参加到哈希运算当中，从而减少哈希冲突。ConcurrentHashMap通过以下哈希算法定位segment。</p>
<p>final Segment<K,V> segmentFor(int hash) {</p>
<p>return segments[(hash &gt;&gt;&gt; segmentShift) &amp; segmentMask];
}</p>
<p>默认情况下segmentShift为28，segmentMask为15，再哈希后的数最大是32位二进制数据，向右无符号移动28位，意思是让高4位参与到hash运算中， (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask的运算结果分别是4，15，7和8，可以看到hash值没有发生冲突。</p>
<h2 id="concurrenthashmap-get-">ConcurrentHashMap的get操作</h2>
<p>Segment的get操作实现非常简单和高效。先经过一次再哈希，然后使用这个哈希值通过哈希运算定位到segment，再通过哈希算法定位到元素，代码如下：
public V get(Object key) {</p>
<p>int hash = hash(key.hashCode());
return segmentFor(hash).get(key, hash);</p>
<p>}</p>
<p>get操作的高效之处在于整个get过程不需要加锁，除非读到的值是空的才会加锁重读，我们知道HashTable容器的get方法是需要加锁的，那么ConcurrentHashMap的get操作是如何做到不加锁的呢？原因是它的get方法里将要使用的共享变量都定义成volatile，如用于统计当前Segement大小的count字段和用于存储值的HashEntry的value。定义成volatile的变量，能够在线程之间保持可见性，能够被多线程同时读，并且保证不会读到过期的值，但是只能被单线程写（有一种情况可以被多线程写，就是写入的值不依赖于原值），在get操作里只需要读不需要写共享变量count和value，所以可以不用加锁。之所以不会读到过期的值，是根据java内存模型的happen before原则，对volatile字段的写入操作先于读操作，即使两个线程同时修改和获取volatile变量，get操作也能拿到最新的值，这是用volatile替换锁的经典应用场景。</p>
<p>transient volatile int count;</p>
<p>volatile V value;</p>
<p>在定位元素的代码里我们可以发现定位HashEntry和定位Segment的哈希算法虽然一样，都与数组的长度减去一相与，但是相与的值不一样，定位Segment使用的是元素的hashcode通过再哈希后得到的值的高位，而定位HashEntry直接使用的是再哈希后的值。其目的是避免两次哈希后的值一样，导致元素虽然在Segment里散列开了，但是却没有在HashEntry里散列开。</p>
<p>hash &gt;&gt;&gt; segmentShift) &amp; segmentMask//定位Segment所使用的hash算法</p>
<p>int index = hash &amp; (tab.length - 1);// 定位HashEntry所使用的hash算法</p>
<h2 id="concurrenthashmap-put-">ConcurrentHashMap的Put操作</h2>
<p>由于put方法里需要对共享变量进行写入操作，所以为了线程安全，在操作共享变量时必须得加锁。Put方法首先定位到Segment，然后在Segment里进行插入操作。插入操作需要经历两个步骤，第一步判断是否需要对Segment里的HashEntry数组进行扩容，第二步定位添加元素的位置然后放在HashEntry数组里。</p>
<p>是否需要扩容。在插入元素前会先判断Segment里的HashEntry数组是否超过容量（threshold），如果超过阀值，数组进行扩容。值得一提的是，Segment的扩容判断比HashMap更恰当，因为HashMap是在插入元素后判断元素是否已经到达容量的，如果到达了就进行扩容，但是很有可能扩容之后没有新元素插入，这时HashMap就进行了一次无效的扩容。</p>
<p>如何扩容。扩容的时候首先会创建一个两倍于原容量的数组，然后将原数组里的元素进行再hash后插入到新的数组里。为了高效ConcurrentHashMap不会对整个容器进行扩容，而只对某个segment进行扩容。</p>
<h2 id="concurrenthashmap-size-">ConcurrentHashMap的size操作</h2>
<p>如果我们要统计整个ConcurrentHashMap里元素的大小，就必须统计所有Segment里元素的大小后求和。Segment里的全局变量count是一个volatile变量，那么在多线程场景下，我们是不是直接把所有Segment的count相加就可以得到整个ConcurrentHashMap大小了呢？不是的，虽然相加时可以获取每个Segment的count的最新值，但是拿到之后可能累加前使用的count发生了变化，那么统计结果就不准了。所以最安全的做法，是在统计size的时候把所有Segment的put，remove和clean方法全部锁住，但是这种做法显然非常低效。 因为在累加count操作过程中，之前累加过的count发生变化的几率非常小，所以ConcurrentHashMap的做法是先尝试2次通过不锁住Segment的方式来统计各个Segment大小，如果统计的过程中，容器的count发生了变化，则再采用加锁的方式来统计所有Segment的大小。</p>
<p>那么ConcurrentHashMap是如何判断在统计的时候容器是否发生了变化呢？使用modCount变量，在put , remove和clean方法里操作元素前都会将变量modCount进行加1，那么在统计size前后比较modCount是否发生变化，从而得知容器的大小是否发生变化。</p>
<h2 id="-">参考资料</h2>
<ol>
<li>JDK1.6源代码。</li>
<li>《Java并发编程实践》。</li>
<li><a href="http://www.goldendoc.org/2011/06/juc_concurrenthashmap/" target="_blank">Java并发编程之ConcurrentHashMap</a> 。</li>
</ol>
<h2 id="-">作者介绍</h2>
<p><strong>方腾飞</strong>，花名清英，淘宝资深开发工程师，关注并发编程，目前在广告技术部从事无线广告联盟的开发和设计工作。个人博客：<a href="http://ifeve.com/" target="_blank"><a href="http://ifeve.com">http://ifeve.com</a></a> 微博：<a href="http://weibo.com/kirals" target="_blank"><a href="http://weibo.com/kirals">http://weibo.com/kirals</a></a> 欢迎通过我的微博进行技术交流。</p>
<p>感谢<a href="http://www.infoq.com/cn/bycategory.action?authorName=%E5%BC%A0%E9%BE%99" target="_blank">张龙</a>对本文的审校。
来源： <a href="[http://www.infoq.com/cn/articles/ConcurrentHashMap](http://www.infoq.com/cn/articles/ConcurrentHashMap)">[http://www.infoq.com/cn/articles/ConcurrentHashMap](http://www.infoq.com/cn/articles/ConcurrentHashMap)</a></p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/Java_多线程/">Java_多线程</a></li><li><a href="/categories/Java&J2EE/Java_多线程/并发/">并发</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/Java_多线程/" class="label label-success">Java_多线程</a><a href="/tags/并发/" class="label label-info">并发</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:41"datetime="2014-03-07 09:54:41"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-Java_多线程-并发--聊聊并发（四）——深入分析ConcurrentHashMap/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-Java_多线程-并发--聊聊并发（四）——深入分析ConcurrentHashMap" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_多线程-并发--聊聊并发（六）——ConcurrentLinkedQueue的实现原理分析/">聊聊并发（六）——ConcurrentLinkedQueue的实现原理分析</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:41.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_多线程-并发--聊聊并发（六）——ConcurrentLinkedQueue的实现原理分析/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-concurrentlinkedqueue-">聊聊并发（六）——ConcurrentLinkedQueue的实现原理分析</h1>
<h3 id="-">分享到</h3>
<ul>
<li><a href="">一键分享</a></li>
<li><a href="">QQ空间</a></li>
<li><a href="">新浪微博</a></li>
<li><a href="">百度搜藏</a></li>
<li><a href="">人人网</a></li>
<li><a href="">腾讯微博</a></li>
<li><a href="">百度相册</a></li>
<li><a href="">开心网</a></li>
<li><a href="">腾讯朋友</a></li>
<li><a href="">百度贴吧</a></li>
<li><a href="">豆瓣网</a></li>
<li><a href="">搜狐微博</a></li>
<li><a href="">百度新首页</a></li>
<li><a href="">QQ好友</a></li>
<li><a href="">和讯微博</a></li>
<li><a href="">更多...</a></li>
</ul>
<p><a href="">百度分享</a></p>
<ul>
<li><a href="http://www.infoq.com/cn/aboutus" title="关于我们" target="_blank">关于我们</a></li>
<li><p><a href="http://www.infoq.com/cn/contribute" title="让大家在InfoQ上听见你的声音" target="_blank">让大家在InfoQ上听见你的声音</a></p>
</li>
<li><p>欢迎关注我们的：</p>
</li>
<li><a href="http://e.weibo.com/infoqchina" target="_blank"><img src="" alt=""></a></li>
<li><a href="http://www.infoq.com/cn/news/2013/02/infoq-wechat" target="_blank"><img src="" alt=""></a></li>
<li><a href="http://www.infoq.com/cn/rss/rss.action?token=J6EBu2hcpyEuMs9msdo8GyNCZTcWG7pm" target="_blank"><img src="" alt=""></a></li>
</ul>
<h1 id="-concurrentlinkedqueue-">聊聊并发（六）——ConcurrentLinkedQueue的实现原理分析</h1>
<p>作者 <a href="http://www.infoq.com/cn/author/%E6%96%B9%E8%85%BE%E9%A3%9E" target="_blank">方腾飞</a> 发布于 一月 09, 2013 <em>|</em> <a href="">5 评论</a></p>
<h2 id="1-">1. 引言</h2>
<p>在并发编程中我们有时候需要使用线程安全的队列。如果我们要实现一个线程安全的队列有两种实现方式：一种是使用阻塞算法，另一种是使用非阻塞算法。使用阻塞算法的队列可以用一个锁（入队和出队用同一把锁）或两个锁（入队和出队用不同的锁）等方式来实现，而非阻塞的实现方式则可以使用循环CAS的方式来实现，本文让我们一起来研究下Doug Lea是如何使用非阻塞的方式来实现线程安全队列ConcurrentLinkedQueue的，相信从大师身上我们能学到不少并发编程的技巧。</p>
<h2 id="2-concurrentlinkedqueue-">2. ConcurrentLinkedQueue的介绍</h2>
<p>ConcurrentLinkedQueue是一个基于链接节点的无界线程安全队列，它采用先进先出的规则对节点进行排序，当我们添加一个元素的时候，它会添加到队列的尾部，当我们获取一个元素时，它会返回队列头部的元素。它采用了“wait－free”算法来实现，该算法在Michael &amp; Scott算法上进行了一些修改, Michael &amp; Scott算法的详细信息可以参见<a href="http://www.cs.rochester.edu/u/michael/PODC96.html" target="_blank">参考资料一</a>。</p>
<h2 id="3-concurrentlinkedqueue-">3. ConcurrentLinkedQueue的结构</h2>
<p>我们通过ConcurrentLinkedQueue的类图来分析一下它的结构。</p>
<p><img src="" alt=""></p>
<p>（图1）</p>
<p>ConcurrentLinkedQueue由head节点和tair节点组成，每个节点（Node）由节点元素（item）和指向下一个节点的引用(next)组成，节点与节点之间就是通过这个next关联起来，从而组成一张链表结构的队列。默认情况下head节点存储的元素为空，tair节点等于head节点。
private transient volatile Node tail = head;</p>
<h2 id="4-">4. 入队列</h2>
<p><strong>入队列就是将入队节点添加到队列的尾部</strong>。为了方便理解入队时队列的变化，以及head节点和tair节点的变化，每添加一个节点我就做了一个队列的快照图。</p>
<p><img src="" alt=""></p>
<p>（图二）</p>
<ul>
<li>第一步添加元素1。队列更新head节点的next节点为元素1节点。又因为tail节点默认情况下等于head节点，所以它们的next节点都指向元素1节点。</li>
<li>第二步添加元素2。队列首先设置元素1节点的next节点为元素2节点，然后更新tail节点指向元素2节点。</li>
<li>第三步添加元素3，设置tail节点的next节点为元素3节点。</li>
<li>第四步添加元素4，设置元素3的next节点为元素4节点，然后将tail节点指向元素4节点。</li>
</ul>
<p>通过debug入队过程并观察head节点和tail节点的变化，发现入队主要做两件事情，第一是将入队节点设置成当前队列尾节点的下一个节点。第二是更新tail节点，如果tail节点的next节点不为空，则将入队节点设置成tail节点，如果tail节点的next节点为空，则将入队节点设置成tail的next节点，所以tail节点不总是尾节点，理解这一点对于我们研究源码会非常有帮助。</p>
<p>上面的分析让我们从单线程入队的角度来理解入队过程，但是多个线程同时进行入队情况就变得更加复杂，因为可能会出现其他线程插队的情况。如果有一个线程正在入队，那么它必须先获取尾节点，然后设置尾节点的下一个节点为入队节点，但这时可能有另外一个线程插队了，那么队列的尾节点就会发生变化，这时当前线程要暂停入队操作，然后重新获取尾节点。让我们再通过源码来详细分析下它是如何使用CAS算法来入队的。
public boolean offer(E e) { if (e == null) throw new NullPointerException(); //入队前，创建一个入队节点 Node<E> n = new Node<E>(e); retry: //死循环，入队不成功反复入队。 for (;;) { //创建一个指向tail节点的引用 Node<E> t = tail; //p用来表示队列的尾节点，默认情况下等于tail节点。 Node<E> p = t; for (int hops = 0; ; hops++) { //获得p节点的下一个节点。 Node<E> next = succ(p); //next节点不为空，说明p不是尾节点，需要更新p后在将它指向next节点 if (next != null) { //循环了两次及其以上，并且当前节点还是不等于尾节点 if (hops &gt; HOPS &amp;&amp; t != tail) continue retry; p = next; } //如果p是尾节点，则设置p节点的next节点为入队节点。 else if (p.casNext(null, n)) { //如果tail节点有大于等于1个next节点，则将入队节点设置成tair节点，更新失败了也 没关系，因为失败了表示有其他线程成功更新了tair节点。 if (hops &gt;= HOPS) casTail(t, n); // 更新tail节点，允许失败 return true; } // p有next节点,表示p的next节点是尾节点，则重新设置p节点 else { p = succ(p); } } } }</p>
<p><strong>从源代码角度来看整个入队过程主要做二件事情</strong>。第一是定位出尾节点，第二是使用CAS算法能将入队节点设置成尾节点的next节点，如不成功则重试。</p>
<p><strong>第一步定位尾节点</strong>。tail节点并不总是尾节点，所以每次入队都必须先通过tail节点来找到尾节点，尾节点可能就是tail节点，也可能是tail节点的next节点。代码中循环体中的第一个if就是判断tail是否有next节点，有则表示next节点可能是尾节点。获取tail节点的next节点需要注意的是p节点等于p的next节点的情况，只有一种可能就是p节点和p的next节点都等于空，表示这个队列刚初始化，正准备添加第一次节点，所以需要返回head节点。获取p节点的next节点代码如下
final Node<E> succ(Node<E> p) { Node<E> next = p.getNext(); return (p == next) ? head : next; }</p>
<p><strong>第二步设置入队节点为尾节点</strong>。p.casNext(null, n)方法用于将入队节点设置为当前队列尾节点的next节点，p如果是null表示p是当前队列的尾节点，如果不为null表示有其他线程更新了尾节点，则需要重新获取当前队列的尾节点。</p>
<p><strong>hops的设计意图</strong>。上面分析过对于先进先出的队列入队所要做的事情就是将入队节点设置成尾节点，doug lea写的代码和逻辑还是稍微有点复杂。那么我用以下方式来实现行不行？
public boolean offer(E e) { if (e == null) throw new NullPointerException(); Node<E> n = new Node<E>(e); for (;;) { Node<E> t = tail; if (t.casNext(null, n) &amp;&amp; casTail(t, n)) { return true; } } }</p>
<p>让tail节点永远作为队列的尾节点，这样实现代码量非常少，而且逻辑非常清楚和易懂。但是这么做有个缺点就是每次都需要使用循环CAS更新tail节点。如果能减少CAS更新tail节点的次数，就能提高入队的效率，所以doug lea使用hops变量来控制并减少tail节点的更新频率，并不是每次节点入队后都将 tail节点更新成尾节点，而是当 tail节点和尾节点的距离大于等于常量HOPS的值（默认等于1）时才更新tail节点，tail和尾节点的距离越长使用CAS更新tail节点的次数就会越少，但是距离越长带来的负面效果就是每次入队时定位尾节点的时间就越长，因为循环体需要多循环一次来定位出尾节点，但是这样仍然能提高入队的效率，因为从本质上来看它通过增加对volatile变量的读操作来减少了对volatile变量的写操作，而对volatile变量的写操作开销要远远大于读操作，所以入队效率会有所提升。</p>
<p>private static final int HOPS = 1;</p>
<p>还有一点需要注意的是入队方法永远返回true，所以不要通过返回值判断入队是否成功。</p>
<h2 id="5-">5. 出队列</h2>
<p>出队列的就是从队列里返回一个节点元素，并清空该节点对元素的引用。让我们通过每个节点出队的快照来观察下head节点的变化。</p>
<p><img src="" alt=""></p>
<p>从上图可知，并不是每次出队时都更新head节点，当head节点里有元素时，直接弹出head节点里的元素，而不会更新head节点。只有当head节点里没有元素时，出队操作才会更新head节点。这种做法也是通过hops变量来减少使用CAS更新head节点的消耗，从而提高出队效率。让我们再通过源码来深入分析下出队过程。
public E poll() { Node<E> h = head; // p表示头节点，需要出队的节点 Node<E> p = h; for (int hops = 0;; hops++) { // 获取p节点的元素 E item = p.getItem(); // 如果p节点的元素不为空，使用CAS设置p节点引用的元素为null,如果成功则返回p节点的元素。 if (item != null &amp;&amp; p.casItem(item, null)) { if (hops &gt;= HOPS) { //将p节点下一个节点设置成head节点 Node<E> q = p.getNext(); updateHead(h, (q != null) ? q : p); } return item; } // 如果头节点的元素为空或头节点发生了变化，这说明头节点已经被另外一个线程修改了。那么获取p节点的下一个节点 Node&lt;&gt; next = succ(p); // 如果p的下一个节点也为空，说明这个队列已经空了 if (next == null) { // 更新头节点。 updateHead(h, p); break; } // 如果下一个元素不为空，则将头节点的下一个节点设置成头节点 p = next; } return null; }</p>
<p>首先获取头节点的元素，然后判断头节点元素是否为空，如果为空，表示另外一个线程已经进行了一次出队操作将该节点的元素取走，如果不为空，则使用CAS的方式将头节点的引用设置成null，如果CAS成功，则直接返回头节点的元素，如果不成功，表示另外一个线程已经进行了一次出队操作更新了head节点，导致元素发生了变化，需要重新获取头节点。</p>
<h2 id="6-">6. 参考资料</h2>
<ul>
<li><a href="http://www.cs.rochester.edu/u/scott/papers/1996_PODC_queues.pdf" target="_blank">简单，快速和实用的阻塞和非阻塞并发队列算法</a>。</li>
<li><a href="http://www.ibm.com/developerworks/cn/java/j-lo-concurrent/index.html" target="_blank">非阻塞算法在容器里的实现</a>。</li>
<li>JDK1.6中ConcurrentLinkedQueue源码和注释。</li>
</ul>
<h1 id="-">#</h1>
<h2 id="-">作者介绍</h2>
<p><strong>方腾飞</strong>，花名清英，淘宝资深开发工程师，关注并发编程，目前在广告技术部从事无线广告联盟的开发和设计工作。个人博客：<a href="http://ifeve.com/" target="_blank"><a href="http://ifeve.com">http://ifeve.com</a></a> 微博：<a href="http://weibo.com/kirals" target="_blank"><a href="http://weibo.com/kirals">http://weibo.com/kirals</a></a>欢迎通过我的微博进行技术交流。</p>
<p>感谢<a href="http://www.infoq.com/cn/bycategory.action?authorName=张龙" target="_blank">张龙</a>对本文的审校。</p>
<p>给InfoQ中文站投稿或者参与内容翻译工作，请邮件至<a href="mailto:editors@cn.infoq.com">editors@cn.infoq.com</a>。也欢迎大家通过新浪微博（<a href="http://www.weibo.com/infoqchina" target="_blank">@InfoQ</a>）或者腾讯微博（<a href="http://t.qq.com/infoqchina" target="_blank">@InfoQ</a>）关注我们，并与我们的编辑和其他读者朋友交流。</p>
<ul>
<li><a href="">Sections</a></li>
<li><a href="http://www.infoq.com/cn/development" target="_blank"><strong>语言 &amp; 开发</strong></a></li>
<li><a href="">Topics</a></li>
<li><a href="http://www.infoq.com/cn/Multi-threading" target="_blank">多线程</a></li>
<li><a href="http://www.infoq.com/cn/concurrency" target="_blank">并发</a></li>
<li><a href="http://www.infoq.com/cn/java" target="_blank">Java</a></li>
</ul>
<p>相关内容</p>
<h3 id="-http-www-infoq-com-cn-articles-atomic-operation-utm_source-infoq-utm_medium-related_content_link-utm_campaign-relatedcontent_articles_clk-"><a href="http://www.infoq.com/cn/articles/atomic-operation?utm_source=infoq&amp;utm_medium=related_content_link&amp;utm_campaign=relatedContent_articles_clk" target="_blank">聊聊并发（五）——原子操作的实现原理</a></h3>
<h3 id="-concurrenthashmap-http-www-infoq-com-cn-articles-concurrenthashmap-utm_source-infoq-utm_medium-related_content_link-utm_campaign-relatedcontent_articles_clk-"><a href="http://www.infoq.com/cn/articles/ConcurrentHashMap?utm_source=infoq&amp;utm_medium=related_content_link&amp;utm_campaign=relatedContent_articles_clk" target="_blank">聊聊并发（四）——深入分析ConcurrentHashMap</a></h3>
<h3 id="-java-http-www-infoq-com-cn-articles-java-threadpool-utm_source-infoq-utm_medium-related_content_link-utm_campaign-relatedcontent_articles_clk-"><a href="http://www.infoq.com/cn/articles/java-threadPool?utm_source=infoq&amp;utm_medium=related_content_link&amp;utm_campaign=relatedContent_articles_clk" target="_blank">聊聊并发（三）——JAVA线程池的分析和使用</a></h3>
<h3 id="-volatile-http-www-infoq-com-cn-articles-ftf-java-volatile-utm_source-infoq-utm_medium-related_content_link-utm_campaign-relatedcontent_articles_clk-"><a href="http://www.infoq.com/cn/articles/ftf-java-volatile?utm_source=infoq&amp;utm_medium=related_content_link&amp;utm_campaign=relatedContent_articles_clk" target="_blank">聊聊并发（一）——深入分析Volatile的实现原理</a></h3>
<h3 id="-java-http-www-infoq-com-cn-articles-java-memory-model-7-utm_source-infoq-utm_medium-related_content_link-utm_campaign-relatedcontent_articles_clk-"><a href="http://www.infoq.com/cn/articles/java-memory-model-7?utm_source=infoq&amp;utm_medium=related_content_link&amp;utm_campaign=relatedContent_articles_clk" target="_blank">深入理解Java内存模型（七）——总结</a></h3>
<h3 id="-java-http-www-infoq-com-cn-articles-java-memory-model-7-utm_source-infoq-utm_medium-related_content_link-utm_campaign-relatedcontent_articles_clk-"><a href="http://www.infoq.com/cn/articles/java-memory-model-7?utm_source=infoq&amp;utm_medium=related_content_link&amp;utm_campaign=relatedContent_articles_clk" target="_blank">深入理解Java内存模型（七）——总结</a></h3>
<h3 id="-java-final-http-www-infoq-com-cn-articles-java-memory-model-6-utm_source-infoq-utm_medium-related_content_link-utm_campaign-relatedcontent_articles_clk-"><a href="http://www.infoq.com/cn/articles/java-memory-model-6?utm_source=infoq&amp;utm_medium=related_content_link&amp;utm_campaign=relatedContent_articles_clk" target="_blank">深入理解Java内存模型（六）——final</a></h3>
<h3 id="-java-http-www-infoq-com-cn-articles-java-memory-model-5-utm_source-infoq-utm_medium-related_content_link-utm_campaign-relatedcontent_articles_clk-"><a href="http://www.infoq.com/cn/articles/java-memory-model-5?utm_source=infoq&amp;utm_medium=related_content_link&amp;utm_campaign=relatedContent_articles_clk" target="_blank">深入理解Java内存模型（五）——锁</a></h3>
<h3 id="-http-www-infoq-com-cn-articles-atomic-operation-utm_source-infoq-utm_medium-related_content_link-utm_campaign-relatedcontent_articles_clk-"><a href="http://www.infoq.com/cn/articles/atomic-operation?utm_source=infoq&amp;utm_medium=related_content_link&amp;utm_campaign=relatedContent_articles_clk" target="_blank">聊聊并发（五）——原子操作的实现原理</a></h3>
<h3 id="-concurrenthashmap-http-www-infoq-com-cn-articles-concurrenthashmap-utm_source-infoq-utm_medium-related_content_link-utm_campaign-relatedcontent_articles_clk-"><a href="http://www.infoq.com/cn/articles/ConcurrentHashMap?utm_source=infoq&amp;utm_medium=related_content_link&amp;utm_campaign=relatedContent_articles_clk" target="_blank">聊聊并发（四）——深入分析ConcurrentHashMap</a></h3>
<h2 id="-">您好，陌生人！</h2>
<p>您需要 <a href="http://www.infoq.com/reginit.action" target="_blank">注册一个InfoQ账号</a> 或者 <a href="">登录</a> 才能进行评论。在您完成注册后还需要进行一些设置。</p>
<h2 id="-infoq-">获得来自InfoQ的更多体验。<a href=""></a></h2>
<p>允许的HTML标签: a,b,br,blockquote,i,li,pre,u,ul,p</p>
<p>当有人回复此评论时请E-mail通知我</p>
<p>社区评论 <a href="">Watch Thread</a></p>
<p><a href=""><strong>CAS 描述有错</strong> by lin lirs Posted 10/01/2013 05:35</a>
<a href=""><strong>Re: CAS 描述有错</strong> by 方 腾飞 Posted 11/01/2013 03:10</a></p>
<p><a href=""><strong>请教大师，有个地方不是很明白</strong> by huang shuihua Posted 18/01/2013 02:58</a>
<a href=""><strong>Re: 请教大师，有个地方不是很明白</strong> by 方 腾飞 Posted 18/01/2013 03:40</a></p>
<p><a href=""><strong>看着不过瘾，买了本书</strong> by 杨 亮 Posted 04/03/2013 01:42</a>
<a href=""></a></p>
<p><strong>CAS 描述有错</strong> 10/01/2013 05:35 by lin lirs</p>
<p>“它采用了“wait－free”算法（即CAS算法）来实现”， CAS不是指算法，而是一个原子操作，wait-free不等同CAS。
<a href="http://en.wikipedia.org/wiki/Compare-and-swap" target="_blank">en.wikipedia.org/wiki/Compare-and-swap</a></p>
<ul>
<li><a href="">回复</a></li>
<li><a href="">回到顶部</a></li>
</ul>
<p><a href=""></a></p>
<p><strong>Re: CAS 描述有错</strong> 11/01/2013 03:10 by 方 腾飞</p>
<p>的确！CAS是一个原子操作指令，可以用来实现“wait－free”算法。这里用“既CAS算法”的确不太合适，我加上的初衷是希望读者能很好的理解“wait－free”算法，但这样会产生一些歧义，所以还是删掉比较合适，感谢您的纠正。</p>
<ul>
<li><a href="">回复</a></li>
<li><a href="">回到顶部</a>
<a href=""></a></li>
</ul>
<p><strong>请教大师，有个地方不是很明白</strong> 18/01/2013 02:58 by huang shuihua</p>
<p>(如果tail节点的next节点不为空，则将入队节点设置成tail节点，如果tail节点的next节点为空，则将入队节点设置成tail的next节点，所以tail节点不总是尾节点),这个还是不是很明白，能否有更加清晰一点的原理图show一下，谢谢!</p>
<ul>
<li><a href="">回复</a></li>
<li><a href="">回到顶部</a></li>
</ul>
<p><a href=""></a></p>
<p><strong>Re: 请教大师，有个地方不是很明白</strong> 18/01/2013 03:40 by 方 腾飞</p>
<p>tail节点并总是尾节点。入队的时候，入队节点要放在队列的尾部，那首先要定位尾节点是哪个节点？所以这里通过tail节点来定位尾节点。尾节点要么是tail节点，要么是tail的next节点。所以入队会有两种情况
情况1：tail节点的next节点不为空，那么插入后队列变成
旧的tail节点-&gt;旧tail节点的next节点-&gt;入队节点（新tail节点）
情况2：tail节点的next节点为空，那么插入后队列变成
tail节点-&gt;入队节点</p>
<ul>
<li><a href="">回复</a></li>
<li><a href="">回到顶部</a>
<a href=""></a></li>
</ul>
<p><strong>看着不过瘾，买了本书</strong> 04/03/2013 01:42 by 杨 亮</p>
<p>聊聊并发这个系列都看了，结合内存模型系列，但还是看着不过瘾，买了本书看。</p>
<ul>
<li><a href="">回复</a></li>
<li><a href="">回到顶部</a></li>
</ul>
<p><a href="">关闭</a></p>
<h3 id="-by"><em>**</em>by</h3>
<p>发布于</p>
<ul>
<li><a href="">查看</a></li>
<li><a href="">回复</a></li>
<li><a href="">回到顶部</a>
<a href="">关闭</a> 主题  您的回复 <a href="">引用原消息</a></li>
</ul>
<p>允许的HTML标签: a,b,br,blockquote,i,li,pre,u,ul,p
当有人回复此评论时请E-mail通知我</p>
<p><a href="">关闭</a> 主题  您的回复</p>
<p>允许的HTML标签: a,b,br,blockquote,i,li,pre,u,ul,p
当有人回复此评论时请E-mail通知我
<a href="">关闭</a></p>
<ul>
<li>热点内容</li>
<li><a href="">本周</a></li>
<li><a href="">本月</a></li>
<li><a href="">近6个月</a><h3 id="-32-http-www-infoq-com-cn-news-2012-08-32-most-important-algorithms-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2012/08/32-most-important-algorithms?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">计算机科学中最重要的32个算法</a></h3>
</li>
</ul>
<h3 id="-thoughtworks-2013-5-http-www-infoq-com-cn-articles-thoughtworks-technology-radar-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/thoughtWorks-technology-radar?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">ThoughtWorks技术雷达（2013年5月）</a></h3>
<h3 id="-1-5-http-www-infoq-com-cn-articles-iqiyi-cloud-push-practices-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/iqiyi-cloud-push-practices?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">让1.5亿移动端用户第一时间获取消息</a></h3>
<h3 id="-thoughtworks-ceo-http-www-infoq-com-cn-news-2013-06-tw-guoxiao-on-talents-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2013/06/tw-guoxiao-on-talents?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">ThoughtWorks全球CEO郭晓谈软件人才的招聘与培养</a></h3>
<h3 id="-http-www-infoq-com-cn-news-2013-06-10-sins-for-scalability-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2013/06/10-sins-for-scalability?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">影响可扩展性的十宗罪</a></h3>
<h3 id="-6-http-www-infoq-com-cn-minibooks-architect-jun-10-2013-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/architect-jun-10-2013?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">架构师（6月刊）</a></h3>
<h3 id="-http-www-infoq-com-cn-articles-function-switch-realize-better-continuous-implementations-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/function-switch-realize-better-continuous-implementations?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">使用功能开关更好地实现持续部署</a></h3>
<h3 id="-eclipse-github-http-www-infoq-com-cn-news-2013-06-eclipse-github-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2013/06/eclipse-github?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">Eclipse迁移到GitHub</a></h3>
<h3 id="-newegg-com-http-www-infoq-com-cn-presentations-newegg-big-data-practice-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/presentations/newegg-big-data-practice?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">Newegg.com大数据实践</a></h3>
<h3 id="-http-www-infoq-com-cn-minibooks-software-sys-architect-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/software-sys-architect?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">软件系统架构：使用视点和视角与利益相关者合作</a></h3>
<h3 id="-32-http-www-infoq-com-cn-news-2012-08-32-most-important-algorithms-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2012/08/32-most-important-algorithms?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">计算机科学中最重要的32个算法</a></h3>
<h3 id="-6-http-www-infoq-com-cn-minibooks-architect-jun-10-2013-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/architect-jun-10-2013?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">架构师（6月刊）</a></h3>
<h3 id="-rest-http-www-infoq-com-cn-news-2013-06-rest-drawbacks-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2013/06/rest-drawbacks?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">REST的缺点是什么？</a></h3>
<h3 id="-google-web-ui-polymer-http-www-infoq-com-cn-news-2013-06-webcomponents-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2013/06/webcomponents?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">Google 发布新一代Web UI库Polymer</a></h3>
<h3 id="-http-www-infoq-com-cn-news-2013-06-dianping-xinnet-hacked-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2013/06/dianping-xinnet-hacked?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">大众点评网域名劫持事件概述</a></h3>
<h3 id="-node-js-grunt-js-http-www-infoq-com-cn-articles-gruntjs-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/GruntJs?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">基于Node.js的自动化构建工具Grunt.js</a></h3>
<h3 id="-node-js-node-js-http-www-infoq-com-cn-articles-what-is-nodejs-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/what-is-nodejs?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">深入浅出Node.js（一）：什么是Node.js</a></h3>
<h3 id="-http-www-infoq-com-cn-minibooks-i-m-wrights-hard-code-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/i-m-wrights-hard-code?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">代码之殇·第二版</a></h3>
<h3 id="-http-www-infoq-com-cn-minibooks-software-sys-architect-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/software-sys-architect?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">软件系统架构：使用视点和视角与利益相关者合作</a></h3>
<h3 id="-18-java-http-www-infoq-com-cn-news-2013-06-zhuhong-on-java-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2013/06/zhuhong-on-java?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">大家谈18岁的Java——朱鸿：开过跑车后再去开大巴车总是有点不爽的</a></h3>
<h3 id="-32-http-www-infoq-com-cn-news-2012-08-32-most-important-algorithms-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2012/08/32-most-important-algorithms?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">计算机科学中最重要的32个算法</a></h3>
<h3 id="-java-http-www-infoq-com-cn-articles-java-memory-model-1-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/java-memory-model-1?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">深入理解Java内存模型（一）——基础</a></h3>
<h3 id="-node-js-node-js-http-www-infoq-com-cn-articles-what-is-nodejs-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/what-is-nodejs?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">深入浅出Node.js（一）：什么是Node.js</a></h3>
<h3 id="-node-js-node-js-npm-http-www-infoq-com-cn-articles-nodejs-npm-install-config-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/nodejs-npm-install-config?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">深入浅出Node.js（二）：Node.js&amp;NPM的安装与配置</a></h3>
<h3 id="-3-http-www-infoq-com-cn-minibooks-architect-mar-10-2013-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/architect-mar-10-2013?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">架构师（3月刊）</a></h3>
<h3 id="-1-http-www-infoq-com-cn-minibooks-architect-jan-10-2013-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/architect-jan-10-2013?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">架构师（1月刊）</a></h3>
<h3 id="-4-http-www-infoq-com-cn-minibooks-architect-apr-10-2013-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/architect-apr-10-2013?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">架构师（4月刊）</a></h3>
<h3 id="-java-http-www-infoq-com-cn-articles-java-threadpool-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/java-threadPool?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">聊聊并发（三）——JAVA线程池的分析和使用</a></h3>
<h3 id="-2-http-www-infoq-com-cn-minibooks-architect-feb-10-2013-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/architect-feb-10-2013?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">架构师（2月刊）</a></h3>
<h3 id="-12306-github-http-www-infoq-com-cn-news-2013-01-12306-plugin-ddos-github-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2013/01/12306-plugin-ddos-github?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">12306订票助手插件拖垮GitHub事件原因始末</a></h3>
<h3 id="-32-http-www-infoq-com-cn-news-2012-08-32-most-important-algorithms-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2012/08/32-most-important-algorithms?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">计算机科学中最重要的32个算法</a></h3>
<h3 id="-thoughtworks-2013-5-http-www-infoq-com-cn-articles-thoughtworks-technology-radar-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/thoughtWorks-technology-radar?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">ThoughtWorks技术雷达（2013年5月）</a></h3>
<h3 id="-1-5-http-www-infoq-com-cn-articles-iqiyi-cloud-push-practices-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/iqiyi-cloud-push-practices?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">让1.5亿移动端用户第一时间获取消息</a></h3>
<h3 id="-thoughtworks-ceo-http-www-infoq-com-cn-news-2013-06-tw-guoxiao-on-talents-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2013/06/tw-guoxiao-on-talents?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">ThoughtWorks全球CEO郭晓谈软件人才的招聘与培养</a></h3>
<h3 id="-http-www-infoq-com-cn-news-2013-06-10-sins-for-scalability-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2013/06/10-sins-for-scalability?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">影响可扩展性的十宗罪</a></h3>
<h3 id="-6-http-www-infoq-com-cn-minibooks-architect-jun-10-2013-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/architect-jun-10-2013?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">架构师（6月刊）</a></h3>
<h3 id="-http-www-infoq-com-cn-articles-function-switch-realize-better-continuous-implementations-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/function-switch-realize-better-continuous-implementations?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">使用功能开关更好地实现持续部署</a></h3>
<h3 id="-eclipse-github-http-www-infoq-com-cn-news-2013-06-eclipse-github-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2013/06/eclipse-github?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">Eclipse迁移到GitHub</a></h3>
<h3 id="-newegg-com-http-www-infoq-com-cn-presentations-newegg-big-data-practice-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/presentations/newegg-big-data-practice?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">Newegg.com大数据实践</a></h3>
<h3 id="-http-www-infoq-com-cn-minibooks-software-sys-architect-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/software-sys-architect?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">软件系统架构：使用视点和视角与利益相关者合作</a></h3>
<h3 id="-32-http-www-infoq-com-cn-news-2012-08-32-most-important-algorithms-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2012/08/32-most-important-algorithms?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">计算机科学中最重要的32个算法</a></h3>
<h3 id="-6-http-www-infoq-com-cn-minibooks-architect-jun-10-2013-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/architect-jun-10-2013?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">架构师（6月刊）</a></h3>
<h3 id="-rest-http-www-infoq-com-cn-news-2013-06-rest-drawbacks-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2013/06/rest-drawbacks?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">REST的缺点是什么？</a></h3>
<h3 id="-google-web-ui-polymer-http-www-infoq-com-cn-news-2013-06-webcomponents-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2013/06/webcomponents?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">Google 发布新一代Web UI库Polymer</a></h3>
<h3 id="-http-www-infoq-com-cn-news-2013-06-dianping-xinnet-hacked-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2013/06/dianping-xinnet-hacked?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">大众点评网域名劫持事件概述</a></h3>
<h3 id="-node-js-grunt-js-http-www-infoq-com-cn-articles-gruntjs-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/GruntJs?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">基于Node.js的自动化构建工具Grunt.js</a></h3>
<h3 id="-node-js-node-js-http-www-infoq-com-cn-articles-what-is-nodejs-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/what-is-nodejs?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">深入浅出Node.js（一）：什么是Node.js</a></h3>
<h3 id="-http-www-infoq-com-cn-minibooks-i-m-wrights-hard-code-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/i-m-wrights-hard-code?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">代码之殇·第二版</a></h3>
<h3 id="-http-www-infoq-com-cn-minibooks-software-sys-architect-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/software-sys-architect?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">软件系统架构：使用视点和视角与利益相关者合作</a></h3>
<h3 id="-18-java-http-www-infoq-com-cn-news-2013-06-zhuhong-on-java-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2013/06/zhuhong-on-java?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">大家谈18岁的Java——朱鸿：开过跑车后再去开大巴车总是有点不爽的</a></h3>
<h3 id="-32-http-www-infoq-com-cn-news-2012-08-32-most-important-algorithms-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2012/08/32-most-important-algorithms?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">计算机科学中最重要的32个算法</a></h3>
<h3 id="-java-http-www-infoq-com-cn-articles-java-memory-model-1-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/java-memory-model-1?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">深入理解Java内存模型（一）——基础</a></h3>
<h3 id="-node-js-node-js-http-www-infoq-com-cn-articles-what-is-nodejs-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/what-is-nodejs?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">深入浅出Node.js（一）：什么是Node.js</a></h3>
<h3 id="-node-js-node-js-npm-http-www-infoq-com-cn-articles-nodejs-npm-install-config-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/nodejs-npm-install-config?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">深入浅出Node.js（二）：Node.js&amp;NPM的安装与配置</a></h3>
<h3 id="-3-http-www-infoq-com-cn-minibooks-architect-mar-10-2013-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/architect-mar-10-2013?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">架构师（3月刊）</a></h3>
<h3 id="-1-http-www-infoq-com-cn-minibooks-architect-jan-10-2013-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/architect-jan-10-2013?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">架构师（1月刊）</a></h3>
<h3 id="-4-http-www-infoq-com-cn-minibooks-architect-apr-10-2013-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/architect-apr-10-2013?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">架构师（4月刊）</a></h3>
<h3 id="-java-http-www-infoq-com-cn-articles-java-threadpool-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/java-threadPool?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">聊聊并发（三）——JAVA线程池的分析和使用</a></h3>
<h3 id="-2-http-www-infoq-com-cn-minibooks-architect-feb-10-2013-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/architect-feb-10-2013?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">架构师（2月刊）</a></h3>
<h3 id="-12306-github-http-www-infoq-com-cn-news-2013-01-12306-plugin-ddos-github-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2013/01/12306-plugin-ddos-github?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">12306订票助手插件拖垮GitHub事件原因始末</a></h3>
<h2 id="-">深度内容</h2>
<ul>
<li><a href="">全部</a></li>
<li><a href="">文章</a></li>
<li><a href="">演讲</a></li>
<li><a href="">访谈</a></li>
<li><a href="">迷你书</a></li>
</ul>
<h2 id="-juergen-fesslmeier-javascript-http-www-infoq-com-cn-interviews-end-to-end-javascript-juergen-fesslmeier-javascript-"><a href="http://www.infoq.com/cn/interviews/end-to-end-javascript" title="Juergen Fesslmeier谈端到端的JavaScript开发" target="_blank">Juergen Fesslmeier谈端到端的JavaScript开发</a></h2>
<p><a href="http://www.infoq.com/cn/author/Juergen-Fesslmeier" title="Juergen Fesslmeier" target="_blank">Juergen Fesslmeier</a> 七月 02, 2013</p>
<p><a href="http://www.infoq.com/cn/interviews/end-to-end-javascript" title="Juergen Fesslmeier谈端到端的JavaScript开发" target="_blank"><img src="" alt=""></a></p>
<h2 id="-http-www-infoq-com-cn-articles-design-pattern-automation-"><a href="http://www.infoq.com/cn/articles/Design-Pattern-Automation" title="设计模式自动化" target="_blank">设计模式自动化</a></h2>
<p><a href="http://www.infoq.com/cn/author/Gael-Fraiteur-and-Yan-Cui" title="Gael Fraiteur and Yan Cui" target="_blank">Gael Fraiteur and Yan Cui</a> 七月 01, 2013</p>
<p><a href="http://www.infoq.com/cn/articles/Design-Pattern-Automation" title="设计模式自动化" target="_blank"><img src="" alt=""></a></p>
<h2 id="-http-www-infoq-com-cn-articles-designing-a-world-at-your-fingertips-mobile-user-interfaces-"><a href="http://www.infoq.com/cn/articles/designing-a-world-at-your-fingertips-mobile-user-interfaces" title="设计指尖上的世界：移动用户界面一瞥" target="_blank">设计指尖上的世界：移动用户界面一瞥</a></h2>
<p><a href="http://www.infoq.com/cn/author/Forrest-Shull" title="Forrest Shull" target="_blank">Forrest Shull</a> 六月 28, 2013</p>
<p><a href="http://www.infoq.com/cn/articles/designing-a-world-at-your-fingertips-mobile-user-interfaces" title="设计指尖上的世界：移动用户界面一瞥" target="_blank"><img src="" alt=""></a></p>
<h2 id="-alm-http-www-infoq-com-cn-articles-integrated-alm-alm-"><a href="http://www.infoq.com/cn/articles/Integrated-ALM" title="成功的根本—集成的ALM工具" target="_blank">成功的根本—集成的ALM工具</a></h2>
<p><a href="http://www.infoq.com/cn/author/Dave-West" title="Dave West" target="_blank">Dave West</a> 六月 28, 2013</p>
<p><a href="http://www.infoq.com/cn/articles/Integrated-ALM" title="成功的根本—集成的ALM工具" target="_blank"><img src="" alt=""></a></p>
<h2 id="-http-www-infoq-com-cn-articles-atdd-by-example-book-"><a href="http://www.infoq.com/cn/articles/atdd-by-example-book" title="书评：验收测试驱动开发实践指南" target="_blank">书评：验收测试驱动开发实践指南</a></h2>
<p><a href="http://www.infoq.com/cn/author/Manuel-Pais" title="Manuel Pais" target="_blank">Manuel Pais</a> 六月 26, 2013</p>
<p><a href="http://www.infoq.com/cn/articles/atdd-by-example-book" title="书评：验收测试驱动开发实践指南" target="_blank"><img src="" alt=""></a></p>
<h2 id="-web-http-www-infoq-com-cn-presentations-across-device-web-web-"><a href="http://www.infoq.com/cn/presentations/across-device-web" title="跨终端的web" target="_blank">跨终端的web</a></h2>
<p><a href="http://www.infoq.com/cn/author/%E8%88%92%E6%96%87%E4%BA%AE" title="舒文亮" target="_blank">舒文亮</a> 六月 26, 2013</p>
<p><a href="http://www.infoq.com/cn/presentations/across-device-web" title="跨终端的web" target="_blank"><img src="" alt=""></a></p>
<ul>
<li><a href="">更早的 &gt;</a></li>
</ul>
<p><a href="">Close</a> E-mail  密码</p>
<p><a href="http://www.infoq.com/cn/social/googleLogin.action?fl=login" title="使用Google账号登录" target="_blank">使用Google账号登录</a> <a href="http://www.infoq.com/cn/social/liveLogin.action?fl=login" title="使用Microsoft账号登录" target="_blank">使用Microsoft账号登录</a>
<a href="">忘记密码？</a>
 InfoQ账号使用的E-mail 发送邮件</p>
<p><a href="">重新登录</a>
重新发送激活信息 重新发送</p>
<p><a href="">重新登录</a>
<a href="http://www.infoq.com/cn/reginit.action" target="_blank">没有用户名？</a></p>
<p><a href="http://www.infoq.com/cn/reginit.action" target="_blank">点击注册</a>
<img src="&quot;定义(粉红" alt="">&quot;)<img src="&quot;假设(蓝色" alt="">&quot;)<img src="&quot;分析(黄色" alt="">&quot;)<img src="&quot;结论(橘红" alt="">&quot;)<img src="&quot;优势(绿色" alt="">&quot;)<img src="&quot;缺陷(紫色" alt="">&quot;)<img src="&quot;注意(红色" alt="">&quot;)<img src="&quot;清除背景色&quot;" alt=""><img src="&quot;书签&quot;" alt=""><img src="&quot;设为目录项&quot;" alt=""><img src="&quot;在Google中搜索&quot;" alt=""><img src="&quot;查找解释&quot;" alt=""><img src="&quot;标注&quot;" alt=""><img src="&quot;链接到所选文件夹/标签/样式/文件&quot;" alt=""><img src="&quot;Wiz助手&quot;" alt=""><img src="&quot;稍后阅读(tag" alt="">&quot;)</p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/Java_多线程/">Java_多线程</a></li><li><a href="/categories/Java&J2EE/Java_多线程/并发/">并发</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/Java_多线程/" class="label label-success">Java_多线程</a><a href="/tags/并发/" class="label label-info">并发</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:41"datetime="2014-03-07 09:54:41"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-Java_多线程-并发--聊聊并发（六）——ConcurrentLinkedQueue的实现原理分析/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-Java_多线程-并发--聊聊并发（六）——ConcurrentLinkedQueue的实现原理分析" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_多线程-内存--深入理解Java内存模型（七）——总结/">深入理解Java内存模型（七）——总结</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:41.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_多线程-内存--深入理解Java内存模型（七）——总结/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-java-">深入理解Java内存模型（七）——总结</h1>
<h3 id="-">分享到</h3>
<ul>
<li><a href="">一键分享</a></li>
<li><a href="">QQ空间</a></li>
<li><a href="">新浪微博</a></li>
<li><a href="">百度搜藏</a></li>
<li><a href="">人人网</a></li>
<li><a href="">腾讯微博</a></li>
<li><a href="">百度相册</a></li>
<li><a href="">开心网</a></li>
<li><a href="">腾讯朋友</a></li>
<li><a href="">百度贴吧</a></li>
<li><a href="">豆瓣网</a></li>
<li><a href="">搜狐微博</a></li>
<li><a href="">百度新首页</a></li>
<li><a href="">QQ好友</a></li>
<li><a href="">和讯微博</a></li>
<li><a href="">更多...</a></li>
</ul>
<p><a href="">百度分享</a></p>
<ul>
<li><a href="http://www.infoq.com/cn/aboutus" title="关于我们" target="_blank">关于我们</a></li>
<li><p><a href="http://www.infoq.com/cn/contribute" title="让大家在InfoQ上听见你的声音" target="_blank">让大家在InfoQ上听见你的声音</a></p>
</li>
<li><p>欢迎关注我们的：</p>
</li>
<li><a href="http://e.weibo.com/infoqchina" target="_blank"><img src="" alt=""></a></li>
<li><a href="http://www.infoq.com/cn/news/2013/02/infoq-wechat" target="_blank"><img src="" alt=""></a></li>
<li><a href="http://www.infoq.com/cn/rss/rss.action?token=AjlwmaWcwi5ejkcT6GcRk1pCqJ4K7ocs" target="_blank"><img src="" alt=""></a></li>
</ul>
<p>促进软件开发领域知识与创新的传播</p>
<p><a href="&quot;Login&quot;">登录</a>
<a href="http://www.infoq.com/cn/" target="_blank"><img src="" alt=""></a></p>
<ul>
<li><a href="http://www.infoq.com/" target="_blank">En</a> |</li>
<li><a href="&quot;InfoQ China&quot;">中文</a> |</li>
<li><a href="http://www.infoq.com/jp/" target="_blank">日本</a> |</li>
<li><a href="http://www.infoq.com/fr/" target="_blank">Fr</a> |</li>
<li><a href="http://www.infoq.com/br/" target="_blank">Br</a></li>
</ul>
<p>164,153 六月 独立访问用户</p>
<ul>
<li><p><a href="http://www.infoq.com/cn/development/" title="Development" target="_blank">语言 &amp; 开发</a></p>
</li>
<li><p><a href="http://www.infoq.com/cn/java/?utm_source=infoq&amp;utm_medium=header_graybar&amp;utm_campaign=topic_clk" title="Java" target="_blank">Java</a></p>
</li>
<li><a href="http://www.infoq.com/cn/dotnet/?utm_source=infoq&amp;utm_medium=header_graybar&amp;utm_campaign=topic_clk" title=".Net" target="_blank">.Net</a></li>
<li><a href="http://www.infoq.com/cn/cloud-computing/?utm_source=infoq&amp;utm_medium=header_graybar&amp;utm_campaign=topic_clk" title="云计算" target="_blank">云计算</a></li>
<li><a href="http://www.infoq.com/cn/mobile/?utm_source=infoq&amp;utm_medium=header_graybar&amp;utm_campaign=topic_clk" title="移动" target="_blank">移动</a></li>
<li><a href="http://www.infoq.com/cn/HTML5Topic/?utm_source=infoq&amp;utm_medium=header_graybar&amp;utm_campaign=topic_clk" title="HTML 5" target="_blank">HTML 5</a></li>
<li><a href="http://www.infoq.com/cn/javascript/?utm_source=infoq&amp;utm_medium=header_graybar&amp;utm_campaign=topic_clk" title="JavaScript" target="_blank">JavaScript</a></li>
<li><a href="http://www.infoq.com/cn/ruby/?utm_source=infoq&amp;utm_medium=header_graybar&amp;utm_campaign=topic_clk" title="Ruby" target="_blank">Ruby</a></li>
<li><a href="http://www.infoq.com/cn/dsl/?utm_source=infoq&amp;utm_medium=header_graybar&amp;utm_campaign=topic_clk" title="DSLs" target="_blank">DSLs</a></li>
<li><a href="http://www.infoq.com/cn/python/?utm_source=infoq&amp;utm_medium=header_graybar&amp;utm_campaign=topic_clk" title="Python" target="_blank">Python</a></li>
<li><a href="http://www.infoq.com/cn/Topic_PHP/?utm_source=infoq&amp;utm_medium=header_graybar&amp;utm_campaign=topic_clk" title="PHP" target="_blank">PHP</a></li>
<li><a href="http://www.infoq.com/cn/PaaS/?utm_source=infoq&amp;utm_medium=header_graybar&amp;utm_campaign=topic_clk" title="PaaS" target="_blank">PaaS</a></li>
</ul>
<h2 id="-">特别专题语言 &amp; 开发</h2>
<h3 id="-juergen-fesslmeier-javascript-http-www-infoq-com-cn-interviews-end-to-end-javascript-"><a href="http://www.infoq.com/cn/interviews/end-to-end-javascript" target="_blank">Juergen Fesslmeier谈端到端的JavaScript开发</a></h3>
<p><img src="" alt=""> Juergen谈论了使用JavaScript进行端对端开发的好处和开发团队可能遇见的挑战。他还谈到了Wakanda Studio以及如何仅用JavaScript通过它来开发复杂的应用程序。
<a href="http://www.infoq.com/cn/development/" target="_blank">浏览所有<strong>语言 &amp; 开发</strong></a></p>
<ul>
<li><p><a href="http://www.infoq.com/cn/architecture-design/" title="Architecture &amp; Design" target="_blank">架构 &amp; 设计</a></p>
</li>
<li><p><a href="http://www.infoq.com/cn/Modeling/?utm_source=infoq&amp;utm_medium=header_graybar&amp;utm_campaign=topic_clk" title="建模" target="_blank">建模</a></p>
</li>
<li><a href="http://www.infoq.com/cn/performance-scalability/?utm_source=infoq&amp;utm_medium=header_graybar&amp;utm_campaign=topic_clk" title="性能和可伸缩性" target="_blank">性能和可伸缩性</a></li>
<li><a href="http://www.infoq.com/cn/domain-driven-design/?utm_source=infoq&amp;utm_medium=header_graybar&amp;utm_campaign=topic_clk" title="领域驱动设计" target="_blank">领域驱动设计</a></li>
<li><a href="http://www.infoq.com/cn/AOP/?utm_source=infoq&amp;utm_medium=header_graybar&amp;utm_campaign=topic_clk" title="AOP" target="_blank">AOP</a></li>
<li><a href="http://www.infoq.com/cn/DesignPattern/?utm_source=infoq&amp;utm_medium=header_graybar&amp;utm_campaign=topic_clk" title="设计模式" target="_blank">设计模式</a></li>
<li><a href="http://www.infoq.com/cn/Security/?utm_source=infoq&amp;utm_medium=header_graybar&amp;utm_campaign=topic_clk" title="安全" target="_blank">安全</a></li>
<li><a href="http://www.infoq.com/cn/cloud-computing/?utm_source=infoq&amp;utm_medium=header_graybar&amp;utm_campaign=topic_clk" title="云计算" target="_blank">云计算</a></li>
<li><a href="http://www.infoq.com/cn/soa_platforms/?utm_source=infoq&amp;utm_medium=header_graybar&amp;utm_campaign=topic_clk" title="SOA" target="_blank">SOA</a></li>
</ul>
<h2 id="-">特别专题架构 &amp; 设计</h2>
<h3 id="-http-www-infoq-com-cn-articles-design-pattern-automation-"><a href="http://www.infoq.com/cn/articles/Design-Pattern-Automation" target="_blank">设计模式自动化</a></h3>
<p><img src="" alt=""> 尽管维护每行代码的成本如此高昂，但我们仍然每天都在编写着大量的样板代码。如果我们有更智能的编译器，那其中很大一部分是可以避免的。实际上，多数模板代码只是重复地实现那些我们已理解透彻的设计模式，只要我们教会编译器一些技巧，有一些设计模式完全是可以自动实现的。
<a href="http://www.infoq.com/cn/architecture-design/" target="_blank">浏览所有<strong>架构 &amp; 设计</strong></a></p>
<ul>
<li><p><a href="http://www.infoq.com/cn/process-practices/" title="Process &amp; Practices" target="_blank">过程 &amp; 实践</a></p>
</li>
<li><p><a href="http://www.infoq.com/cn/agile/?utm_source=infoq&amp;utm_medium=header_graybar&amp;utm_campaign=topic_clk" title="Agile" target="_blank">Agile</a></p>
</li>
<li><a href="http://www.infoq.com/cn/Leadership/?utm_source=infoq&amp;utm_medium=header_graybar&amp;utm_campaign=topic_clk" title="领导能力" target="_blank">领导能力</a></li>
<li><a href="http://www.infoq.com/cn/team-collaboration/?utm_source=infoq&amp;utm_medium=header_graybar&amp;utm_campaign=topic_clk" title="团队协作" target="_blank">团队协作</a></li>
<li><a href="http://www.infoq.com/cn/agile_techniques/?utm_source=infoq&amp;utm_medium=header_graybar&amp;utm_campaign=topic_clk" title="敏捷技术" target="_blank">敏捷技术</a></li>
<li><a href="http://www.infoq.com/cn/methodologies/?utm_source=infoq&amp;utm_medium=header_graybar&amp;utm_campaign=topic_clk" title="方法论" target="_blank">方法论</a></li>
<li><a href="http://www.infoq.com/cn/continuous_integration/?utm_source=infoq&amp;utm_medium=header_graybar&amp;utm_campaign=topic_clk" title="持续集成" target="_blank">持续集成</a></li>
<li><a href="http://www.infoq.com/cn/lean/?utm_source=infoq&amp;utm_medium=header_graybar&amp;utm_campaign=topic_clk" title="精益" target="_blank">精益</a></li>
<li><a href="http://www.infoq.com/cn/cust_requirements/?utm_source=infoq&amp;utm_medium=header_graybar&amp;utm_campaign=topic_clk" title="客户及需求" target="_blank">客户及需求</a></li>
</ul>
<h2 id="-">特别专题过程 &amp; 实践</h2>
<h3 id="-alm-http-www-infoq-com-cn-articles-integrated-alm-"><a href="http://www.infoq.com/cn/articles/Integrated-ALM" target="_blank">成功的根本—集成的ALM工具</a></h3>
<p><img src="" alt=""> 典型的软件交付项目会无数次地去获取需求，并在多个地方描述测试，但它们却与某一特定的构建里的具体内容并不相符合，因此项目往往需要大量分析来获知谁在做什么以及为什么做。Dave West深入研究造成该问题的原因，并致力研究一个整体的、集成的ALM方法。
<a href="http://www.infoq.com/cn/process-practices/" target="_blank">浏览所有<strong>过程 &amp; 实践</strong></a></p>
<ul>
<li><p><a href="http://www.infoq.com/cn/operations-infrastructure/" title="Operations &amp; Infrastructure" target="_blank">运维 &amp; 基础架构</a></p>
</li>
<li><p><a href="http://www.infoq.com/cn/performance-scalability/?utm_source=infoq&amp;utm_medium=header_graybar&amp;utm_campaign=topic_clk" title="性能和可伸缩性" target="_blank">性能和可伸缩性</a></p>
</li>
<li><a href="http://www.infoq.com/cn/bigdata/?utm_source=infoq&amp;utm_medium=header_graybar&amp;utm_campaign=topic_clk" title="大数据" target="_blank">大数据</a></li>
<li><a href="http://www.infoq.com/cn/devops/?utm_source=infoq&amp;utm_medium=header_graybar&amp;utm_campaign=topic_clk" title="DevOps" target="_blank">DevOps</a></li>
<li><a href="http://www.infoq.com/cn/cloud-computing/?utm_source=infoq&amp;utm_medium=header_graybar&amp;utm_campaign=topic_clk" title="云计算" target="_blank">云计算</a></li>
<li><a href="http://www.infoq.com/cn/virtualization/?utm_source=infoq&amp;utm_medium=header_graybar&amp;utm_campaign=topic_clk" title="虚拟化" target="_blank">虚拟化</a></li>
<li><a href="http://www.infoq.com/cn/NoSQL/?utm_source=infoq&amp;utm_medium=header_graybar&amp;utm_campaign=topic_clk" title="NoSQL" target="_blank">NoSQL</a></li>
<li><a href="http://www.infoq.com/cn/ApplicationServers/?utm_source=infoq&amp;utm_medium=header_graybar&amp;utm_campaign=topic_clk" title="应用服务器" target="_blank">应用服务器</a></li>
<li><a href="http://www.infoq.com/cn/operations/?utm_source=infoq&amp;utm_medium=header_graybar&amp;utm_campaign=topic_clk" title="运维" target="_blank">运维</a></li>
</ul>
<h2 id="-">特别专题运维 &amp; 基础架构</h2>
<h3 id="-http-www-infoq-com-cn-articles-atdd-by-example-book-"><a href="http://www.infoq.com/cn/articles/atdd-by-example-book" target="_blank">书评：验收测试驱动开发实践指南</a></h3>
<p><img src="" alt=""> 《验收测试驱动开发实践指南》一书的目的是作为一个介绍性使用指南指导那些从零开始的团队成功执行和应用验收测试驱动开发（ATDD）。尽管该书在指出及总结了成功敏捷测试人员应该掌握的多个测试相关实践上做了有效的工作，但该书最终并没有为它的各层读者提供他们所需要的信息。By Manuel Pais
<a href="http://www.infoq.com/cn/operations-infrastructure/" target="_blank">浏览所有<strong>运维 &amp; 基础架构</strong></a></p>
<ul>
<li><p><a href="http://www.infoq.com/cn/enterprise-architect/" title="Enterprise Architecture" target="_blank">企业架构</a></p>
</li>
<li><p><a href="http://www.infoq.com/cn/enterprise-architecture/?utm_source=infoq&amp;utm_medium=header_graybar&amp;utm_campaign=topic_clk" title="企业架构" target="_blank">企业架构</a></p>
</li>
<li><a href="http://www.infoq.com/cn/bpm/?utm_source=infoq&amp;utm_medium=header_graybar&amp;utm_campaign=topic_clk" title="业务流程建模" target="_blank">业务流程建模</a></li>
<li><a href="http://www.infoq.com/cn/business_it_alignment/?utm_source=infoq&amp;utm_medium=header_graybar&amp;utm_campaign=topic_clk" title="业务/IT整合" target="_blank">业务/IT整合</a></li>
<li><a href="http://www.infoq.com/cn/EAI/?utm_source=infoq&amp;utm_medium=header_graybar&amp;utm_campaign=topic_clk" title="Integration (EAI)" target="_blank">Integration (EAI)</a></li>
<li><a href="http://www.infoq.com/cn/Governance/?utm_source=infoq&amp;utm_medium=header_graybar&amp;utm_campaign=topic_clk" title="治理" target="_blank">治理</a></li>
<li><a href="http://www.infoq.com/cn/web20/?utm_source=infoq&amp;utm_medium=header_graybar&amp;utm_campaign=topic_clk" title="Web 2.0" target="_blank">Web 2.0</a></li>
<li><a href="http://www.infoq.com/cn/soa/?utm_source=infoq&amp;utm_medium=header_graybar&amp;utm_campaign=topic_clk" title="SOA" target="_blank">SOA</a></li>
</ul>
<h2 id="-">特别专题企业架构</h2>
<h3 id="-http-www-infoq-com-cn-articles-designing-a-world-at-your-fingertips-mobile-user-interfaces-"><a href="http://www.infoq.com/cn/articles/designing-a-world-at-your-fingertips-mobile-user-interfaces" target="_blank">设计指尖上的世界：移动用户界面一瞥</a></h3>
<p><img src="" alt=""> 对任何成功的移动应用来说，用户界面（UI）是至关重要的组成部分。在这篇文章中，Forrest Skull展示了他与人机交互（HCI）研究者们进行的访谈与讨论，他们探讨了移动设备UI方面的原则，以及其它一些正在研究的领域，包括多设备、隐私、安全和语音。这篇文章还描述了开发移动设备用户界面过程中会面临的挑战。
<a href="http://www.infoq.com/cn/enterprise-architect/" target="_blank">浏览所有<strong>企业架构</strong></a>
<a href="http://www.qconshanghai.com/" title="New York 2013"><strong>QCon上海2013</strong>
11月1-3日
上海光大会展中心</a></p>
<ul>
<li><a href="http://www.infoq.com/cn/mobile/?utm_source=infoq&amp;utm_medium=header_graybar&amp;utm_campaign=topic_clk" title="移动" target="_blank">移动</a></li>
<li><a href="http://www.infoq.com/cn/html-5/?utm_source=infoq&amp;utm_medium=header_graybar&amp;utm_campaign=topic_clk" title="HTML 5" target="_blank">HTML 5</a></li>
<li><a href="http://www.infoq.com/cn/nodejs/?utm_source=infoq&amp;utm_medium=header_graybar&amp;utm_campaign=topic_clk" title="Node.js" target="_blank">Node.js</a></li>
<li><a href="http://www.infoq.com/cn/cloud-computing/?utm_source=infoq&amp;utm_medium=header_graybar&amp;utm_campaign=topic_clk" title="云计算" target="_blank">云计算</a></li>
<li><a href="http://www.infoq.com/cn/bigdata/?utm_source=infoq&amp;utm_medium=header_graybar&amp;utm_campaign=topic_clk" title="大数据" target="_blank">大数据</a></li>
<li><a href="http://www.infoq.com/cn/operations/?utm_source=infoq&amp;utm_medium=header_graybar&amp;utm_campaign=topic_clk" title="运维" target="_blank">运维</a></li>
<li><a href="http://www.infoq.com/cn/architect/?utm_source=infoq&amp;utm_medium=header_graybar&amp;utm_campaign=topic_clk" title="架构师" target="_blank">架构师</a></li>
<li><a href="http://www.infoq.com/cn/baidu_cloud/?utm_source=infoq&amp;utm_medium=header_graybar&amp;utm_campaign=topic_clk" title="百度云" target="_blank">百度云</a>
<a href="http://www.infoq.com/cn/topics" target="_blank">全部话题</a></li>
</ul>
<p><a href="http://www.infoq.com/news/2013/04/infoq-redesign" target="_blank">New UI</a>
您目前处于： <a href="http://www.infoq.com/cn" title="InfoQ首页" target="_blank">InfoQ首页</a> <a href="http://www.infoq.com/cn/articles" title="文章" target="_blank">文章</a> 深入理解Java内存模型（七）——总结</p>
<h1 id="-java-">深入理解Java内存模型（七）——总结</h1>
<p>作者 <a href="http://www.infoq.com/cn/author/%E7%A8%8B%E6%99%93%E6%98%8E" target="_blank">程晓明</a> 发布于 三月 15, 2013 <em>|</em> <a href="">4 评论</a></p>
<ul>
<li><a href="&quot;分享到新浪微博&quot;">新浪微博</a> <a href="&quot;分享到腾讯微博&quot;">腾讯微博</a> <a href="&quot;分享到豆瓣网&quot;">豆瓣网</a> <a href="&quot;分享到Twitter&quot;">Twitter</a> <a href="&quot;分享到Facebook&quot;">Facebook</a> <a href="&quot;分享到linkedin&quot;">linkedin</a> <a href="&quot;分享到邮件分享&quot;">邮件分享</a> 更多 <a href="&quot;累计分享23次&quot;">23</a></li>
<li><a href="">稍后阅读</a></li>
<li><a href="http://www.infoq.com/cn/showbookmarks.action" target="_blank">我的阅读清单</a><h2 id="-">处理器内存模型</h2>
</li>
</ul>
<p>顺序一致性内存模型是一个理论参考模型，JMM和处理器内存模型在设计时通常会把顺序一致性内存模型作为参照。JMM和处理器内存模型在设计时会对顺序一致性模型做一些放松，因为如果完全按照顺序一致性模型来实现处理器和JMM，那么很多的处理器和编译器优化都要被禁止，这对执行性能将会有很大的影响。</p>
<p>根据对不同类型读/写操作组合的执行顺序的放松，可以把常见处理器的内存模型划分为下面几种类型：</p>
<ol>
<li>放松程序中写-读操作的顺序，由此产生了total store ordering内存模型（简称为TSO）。</li>
<li>在前面1的基础上，继续放松程序中写-写操作的顺序，由此产生了partial store order 内存模型（简称为PSO）。</li>
<li>在前面1和2的基础上，继续放松程序中读-写和读-读操作的顺序，由此产生了relaxed memory order内存模型（简称为RMO）和PowerPC内存模型。</li>
</ol>
<p>注意，这里处理器对读/写操作的放松，是以两个操作之间不存在数据依赖性为前提的（因为处理器要遵守as-if-serial语义，处理器不会对存在数据依赖性的两个内存操作做重排序）。</p>
<p>下面的表格展示了常见处理器内存模型的细节特征：
内存模型名称</p>
<p>对应的处理器
相关厂商内容</p>
<h3 id="-javaone-spring-java-ee-6-http-www-infoq-com-infoq-url-action-i-3379-t-f-"><a href="http://www.infoq.com/infoq/url.action?i=3379&amp;t=f" target="_blank">JavaOne上海：迁移Spring应用到Java EE 6</a></h3>
<h3 id="-javaone-http-www-infoq-com-infoq-url-action-i-3380-t-f-"><a href="http://www.infoq.com/infoq/url.action?i=3380&amp;t=f" target="_blank">JavaOne上海：淘宝的鹰眼分布式日志系统</a></h3>
<h3 id="-qcon-2013-http-www-infoq-com-cn-vendorcontent-show-action-vcr-2272-utm_source-infoq-utm_medium-vcr-utm_campaign-vcr_articles_click-"><a href="http://www.infoq.com/cn/vendorcontent/show.action?vcr=2272&amp;utm_source=infoq&amp;utm_medium=VCR&amp;utm_campaign=vcr_articles_click" target="_blank">豆瓣工程副总裁段念确认参与QCon上海2013，担任团队文化专题出品人</a></h3>
<h3 id="-html5-builder-web-http-www-infoq-com-cn-vendorcontent-show-action-vcr-2308-utm_source-infoq-utm_medium-vcr-utm_campaign-vcr_articles_click-"><a href="http://www.infoq.com/cn/vendorcontent/show.action?vcr=2308&amp;utm_source=infoq&amp;utm_medium=VCR&amp;utm_campaign=vcr_articles_click" target="_blank">白皮书下载：用HTML5 Builder构建单一代码库的Web/移动应用</a></h3>
<h3 id="-qcon-20-80-http-www-infoq-com-cn-vendorcontent-show-action-vcr-2311-utm_source-infoq-utm_medium-vcr-utm_campaign-vcr_articles_click-"><a href="http://www.infoq.com/cn/vendorcontent/show.action?vcr=2311&amp;utm_source=infoq&amp;utm_medium=VCR&amp;utm_campaign=vcr_articles_click" target="_blank">首届QCon上海20个专题确认，80余场分享，全面征集演讲主题</a></h3>
<p>相关赞助商
<a href="http://www.infoq.com/infoq/url.action?i=3367&amp;t=f" target="_blank"><img src="" alt=""></a></p>
<p>JavaOne大会独家社区合作，<a href="http://www.infoq.com/infoq/url.action?i=3511&amp;t=f" target="_blank">InfoQ用户享75折购票</a>。 
Store-Load 重排序</p>
<p>Store-Store重排序</p>
<p>Load-Load 和Load-Store重排序</p>
<p>可以更早读取到其它处理器的写</p>
<p>可以更早读取到当前处理器的写 TSO</p>
<p>sparc-TSO</p>
<p>X64</p>
<p>Y</p>
<p>Y PSO</p>
<p>sparc-PSO</p>
<p>Y</p>
<p>Y</p>
<p>Y RMO</p>
<p>ia64</p>
<p>Y</p>
<p>Y</p>
<p>Y</p>
<p>Y PowerPC</p>
<p>PowerPC</p>
<p>Y</p>
<p>Y</p>
<p>Y</p>
<p>Y</p>
<p>Y</p>
<p>在这个表格中，我们可以看到所有处理器内存模型都允许写-读重排序，原因在第一章以说明过：它们都使用了写缓存区，写缓存区可能导致写-读操作重排序。同时，我们可以看到这些处理器内存模型都允许更早读到当前处理器的写，原因同样是因为写缓存区：由于写缓存区仅对当前处理器可见，这个特性导致当前处理器可以比其他处理器先看到临时保存在自己的写缓存区中的写。</p>
<p>上面表格中的各种处理器内存模型，从上到下，模型由强变弱。越是追求性能的处理器，内存模型设计的会越弱。因为这些处理器希望内存模型对它们的束缚越少越好，这样它们就可以做尽可能多的优化来提高性能。</p>
<p>由于常见的处理器内存模型比JMM要弱，java编译器在生成字节码时，会在执行指令序列的适当位置插入内存屏障来限制处理器的重排序。同时，由于各种处理器内存模型的强弱并不相同，为了在不同的处理器平台向程序员展示一个一致的内存模型，JMM在不同的处理器中需要插入的内存屏障的数量和种类也不相同。下图展示了JMM在不同处理器内存模型中需要插入的内存屏障的示意图：</p>
<p><img src="" alt=""></p>
<p>如上图所示，JMM屏蔽了不同处理器内存模型的差异，它在不同的处理器平台之上为java程序员呈现了一个一致的内存模型。</p>
<h2 id="jmm-">JMM，处理器内存模型与顺序一致性内存模型之间的关系</h2>
<p>JMM是一个语言级的内存模型，处理器内存模型是硬件级的内存模型，顺序一致性内存模型是一个理论参考模型。下面是语言内存模型，处理器内存模型和顺序一致性内存模型的强弱对比示意图：</p>
<p><img src="" alt=""></p>
<p>从上图我们可以看出：常见的4种处理器内存模型比常用的3中语言内存模型要弱，处理器内存模型和语言内存模型都比顺序一致性内存模型要弱。同处理器内存模型一样，越是追求执行性能的语言，内存模型设计的会越弱。</p>
<h2 id="jmm-">JMM的设计</h2>
<p>从JMM设计者的角度来说，在设计JMM时，需要考虑两个关键因素：</p>
<ul>
<li>程序员对内存模型的使用。程序员希望内存模型易于理解，易于编程。程序员希望基于一个强内存模型来编写代码。</li>
<li>编译器和处理器对内存模型的实现。编译器和处理器希望内存模型对它们的束缚越少越好，这样它们就可以做尽可能多的优化来提高性能。编译器和处理器希望实现一个弱内存模型。</li>
</ul>
<p>由于这两个因素互相矛盾，所以JSR-133专家组在设计JMM时的核心目标就是找到一个好的平衡点：一方面要为程序员提供足够强的内存可见性保证；另一方面，对编译器和处理器的限制要尽可能的放松。下面让我们看看JSR-133是如何实现这一目标的。</p>
<p>为了具体说明，请看前面提到过的计算圆面积的示例代码：
double pi = 3.14; //A double r = 1.0; //B double area = pi /<em> r /</em> r; //C</p>
<p>上面计算圆的面积的示例代码存在三个happens- before关系：</p>
<ol>
<li>A happens- before B；</li>
<li>B happens- before C；</li>
<li>A happens- before C；</li>
</ol>
<p>由于A happens- before B，happens- before的定义会要求：A操作执行的结果要对B可见，且A操作的执行顺序排在B操作之前。 但是从程序语义的角度来说，对A和B做重排序即不会改变程序的执行结果，也还能提高程序的执行性能（允许这种重排序减少了对编译器和处理器优化的束缚）。也就是说，上面这3个happens- before关系中，虽然2和3是必需要的，但1是不必要的。因此，JMM把happens- before要求禁止的重排序分为了下面两类：</p>
<ul>
<li>会改变程序执行结果的重排序。</li>
<li>不会改变程序执行结果的重排序。</li>
</ul>
<p>JMM对这两种不同性质的重排序，采取了不同的策略：</p>
<ul>
<li>对于会改变程序执行结果的重排序，JMM要求编译器和处理器必须禁止这种重排序。</li>
<li>对于不会改变程序执行结果的重排序，JMM对编译器和处理器不作要求（JMM允许这种重排序）。</li>
</ul>
<p>下面是JMM的设计示意图：</p>
<p><img src="" alt=""></p>
<p>从上图可以看出两点：</p>
<ul>
<li>JMM向程序员提供的happens- before规则能满足程序员的需求。JMM的happens- before规则不但简单易懂，而且也向程序员提供了足够强的内存可见性保证（有些内存可见性保证其实并不一定真实存在，比如上面的A happens- before B）。</li>
<li>JMM对编译器和处理器的束缚已经尽可能的少。从上面的分析我们可以看出，JMM其实是在遵循一个基本原则：只要不改变程序的执行结果（指的是单线程程序和正确同步的多线程程序），编译器和处理器怎么优化都行。比如，如果编译器经过细致的分析后，认定一个锁只会被单个线程访问，那么这个锁可以被消除。再比如，如果编译器经过细致的分析后，认定一个volatile变量仅仅只会被单个线程访问，那么编译器可以把这个volatile变量当作一个普通变量来对待。这些优化既不会改变程序的执行结果，又能提高程序的执行效率。</li>
</ul>
<h2 id="jmm-">JMM的内存可见性保证</h2>
<p>Java程序的内存可见性保证按程序类型可以分为下列三类：</p>
<ol>
<li>单线程程序。单线程程序不会出现内存可见性问题。编译器，runtime和处理器会共同确保单线程程序的执行结果与该程序在顺序一致性模型中的执行结果相同。</li>
<li>正确同步的多线程程序。正确同步的多线程程序的执行将具有顺序一致性（程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同）。这是JMM关注的重点，JMM通过限制编译器和处理器的重排序来为程序员提供内存可见性保证。</li>
<li>未同步/未正确同步的多线程程序。JMM为它们提供了最小安全性保障：线程执行时读取到的值，要么是之前某个线程写入的值，要么是默认值（0，null，false）。</li>
</ol>
<p>下图展示了这三类程序在JMM中与在顺序一致性内存模型中的执行结果的异同：</p>
<p><img src="" alt=""></p>
<p>只要多线程程序是正确同步的，JMM保证该程序在任意的处理器平台上的执行结果，与该程序在顺序一致性内存模型中的执行结果一致。</p>
<h2 id="jsr-133-">JSR-133对旧内存模型的修补</h2>
<p>JSR-133对JDK5之前的旧内存模型的修补主要有两个：</p>
<ul>
<li>增强volatile的内存语义。旧内存模型允许volatile变量与普通变量重排序。JSR-133严格限制volatile变量与普通变量的重排序，使volatile的写-读和锁的释放-获取具有相同的内存语义。</li>
<li>增强final的内存语义。在旧内存模型中，多次读取同一个final变量的值可能会不相同。为此，JSR-133为final增加了两个重排序规则。现在，final具有了初始化安全性。</li>
</ul>
<h2 id="-">参考文献</h2>
<ol>
<li><a href="http://www.amazon.com/Computer-Architecture-Fourth-Quantitative-Approach/dp/0123704901/ref=sr_1_10/102-0116773-7214567?ie=UTF8&amp;s=books&amp;qid=1188797467&amp;sr=1-10" target="_blank">Computer Architecture: A Quantitative Approach, 4th Edition</a></li>
<li><a href="http://www.hpl.hp.com/techreports/Compaq-DEC/WRL-95-7.pdf" target="_blank">Shared memory consistency models: A tutorial</a></li>
<li><a href="http://www.intel.com/content/dam/www/public/us/en/documents/manuals/itanium-architecture-software-developer-rev-2-3-vol-2-manual.pdf" target="_blank">Intel® Itanium® Architecture Software Developer’s Manual Volume 2: System Architecture</a></li>
<li><a href="http://www.amazon.com/Concurrent-Programming-Windows-Joe-Duffy/dp/032143482X/ref=sr_1_1?ie=UTF8&amp;s=books&amp;qid=1262571776&amp;sr=1-1" target="_blank">Concurrent Programming on Windows</a></li>
<li><a href="http://www.cs.umd.edu/users/pugh/java/memoryModel/jsr-133-faq.html" target="_blank">JSR 133 (Java Memory Model) FAQ</a></li>
<li><a href="http://gee.cs.oswego.edu/dl/jmm/cookbook.html" target="_blank">The JSR-133 Cookbook for Compiler Writers</a></li>
<li><a href="http://www.ibm.com/developerworks/java/library/j-jtp03304/index.html" target="_blank">Java theory and practice: Fixing the Java Memory Model, Part 2</a></li>
</ol>
<h2 id="-">关于作者</h2>
<p><strong>程晓明</strong>，Java软件工程师，国家认证的系统分析师、信息项目管理师。专注于并发编程，就职于富士通南大。个人邮箱：<a href="mailto:asst2003@163.com">asst2003@163.com</a>。</p>
<ul>
<li><a href="">Sections</a></li>
<li><a href="http://www.infoq.com/cn/architecture-design" target="_blank"><strong>架构 &amp; 设计</strong></a></li>
<li><a href="http://www.infoq.com/cn/development" target="_blank"><strong>语言 &amp; 开发</strong></a></li>
<li><a href="">Topics</a></li>
<li><a href="http://www.infoq.com/cn/Multi-threading" target="_blank">多线程</a></li>
<li><a href="http://www.infoq.com/cn/memory-model" target="_blank">内存模型</a></li>
<li><a href="http://www.infoq.com/cn/concurrency" target="_blank">并发</a></li>
<li><a href="http://www.infoq.com/cn/java" target="_blank">Java</a></li>
<li><a href="http://www.infoq.com/cn/special-column" target="_blank">专栏</a></li>
</ul>
<p>相关内容</p>
<h3 id="-java-final-http-www-infoq-com-cn-articles-java-memory-model-6-utm_source-infoq-utm_medium-related_content_link-utm_campaign-relatedcontent_articles_clk-"><a href="http://www.infoq.com/cn/articles/java-memory-model-6?utm_source=infoq&amp;utm_medium=related_content_link&amp;utm_campaign=relatedContent_articles_clk" target="_blank">深入理解Java内存模型（六）——final</a></h3>
<h3 id="-java-http-www-infoq-com-cn-articles-java-memory-model-5-utm_source-infoq-utm_medium-related_content_link-utm_campaign-relatedcontent_articles_clk-"><a href="http://www.infoq.com/cn/articles/java-memory-model-5?utm_source=infoq&amp;utm_medium=related_content_link&amp;utm_campaign=relatedContent_articles_clk" target="_blank">深入理解Java内存模型（五）——锁</a></h3>
<h3 id="-java-volatile-http-www-infoq-com-cn-articles-java-memory-model-4-utm_source-infoq-utm_medium-related_content_link-utm_campaign-relatedcontent_articles_clk-"><a href="http://www.infoq.com/cn/articles/java-memory-model-4?utm_source=infoq&amp;utm_medium=related_content_link&amp;utm_campaign=relatedContent_articles_clk" target="_blank">深入理解Java内存模型（四）——volatile</a></h3>
<h3 id="-java-http-www-infoq-com-cn-articles-java-memory-model-3-utm_source-infoq-utm_medium-related_content_link-utm_campaign-relatedcontent_articles_clk-"><a href="http://www.infoq.com/cn/articles/java-memory-model-3?utm_source=infoq&amp;utm_medium=related_content_link&amp;utm_campaign=relatedContent_articles_clk" target="_blank">深入理解Java内存模型（三）——顺序一致性</a></h3>
<h3 id="-java-http-www-infoq-com-cn-articles-java-memory-model-2-utm_source-infoq-utm_medium-related_content_link-utm_campaign-relatedcontent_articles_clk-"><a href="http://www.infoq.com/cn/articles/java-memory-model-2?utm_source=infoq&amp;utm_medium=related_content_link&amp;utm_campaign=relatedContent_articles_clk" target="_blank">深入理解Java内存模型（二）——重排序</a></h3>
<h2 id="-">您好，陌生人！</h2>
<p>您需要 <a href="http://www.infoq.com/reginit.action" target="_blank">注册一个InfoQ账号</a> 或者 <a href="">登录</a> 才能进行评论。在您完成注册后还需要进行一些设置。</p>
<h2 id="-infoq-">获得来自InfoQ的更多体验。 <a href=""></a></h2>
<h3 id="-">告诉我们您的想法</h3>
<p>允许的HTML标签: a,b,br,blockquote,i,li,pre,u,ul,p
当有人回复此评论时请E-mail通知我</p>
<p>社区评论  <a href="">Watch Thread</a></p>
<p><a href=""><strong>看完后有两点疑问，请教一下：</strong>  by Z CS Posted 21/03/2013 07:37</a>
<a href=""><strong>Re: 看完后有两点疑问，请教一下：</strong>  by 程 晓明 Posted 23/03/2013 12:50</a></p>
<p><a href=""><strong>编译器什么时候插入内存屏障？</strong>  by 黄 春 Posted 10/04/2013 12:49</a>
<a href=""><strong>Re: 编译器什么时候插入内存屏障？</strong>  by 程 晓明 Posted 14/04/2013 11:01</a>
<a href=""></a></p>
<p><strong>看完后有两点疑问，请教一下：</strong>  21/03/2013 07:37 by Z CS</p>
<ol>
<li>文中所写的 “未同步/未正确同步的多线程程序。JMM为它们提供了最小安全性保障：线程执行时读取到的值，要么是之前某个线程写入的值，要么是默认值（0，null，false）。”，JSR-133 真的做到这样了么? 那 么 long和double的 读写 的非原子性是怎么回事啊？是不是矛盾啊？</li>
<li>关于本文中最后“JSR-133为final增加了两个重排序规则。现在，final具有了初始化安全性。”，这句话，是不是也还要加上那个 前提“保证final引用不从构造函数内逸出”，final才能具有“初始化安全性”啊？</li>
</ol>
<ul>
<li><a href="">回复</a></li>
<li><a href="">回到顶部</a></li>
</ul>
<p><a href=""></a></p>
<p><strong>Re: 看完后有两点疑问，请教一下：</strong>  23/03/2013 12:50 by 程 晓明</p>
<p>谢谢您的关注。
/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>
问题1
最小安全性与64位数据的非原子性读/写并不矛盾。
它们是两个不同的概念，它们“发生”的时间点也不同。
最小安全性保证对象默认初始化之后（设置成员域为0，null或false），才会被任意线程使用。
最小安全性“发生”在对象被任意线程使用之前。
64位数据的非原子性读/写“发生”在对象被多个线程使用的过程中（读/写共享变量）。
当发生《本文三》末尾的那种问题时（处理器B看到仅仅被处理器A“写了一半“的无效值），
这里虽然处理器B读取到一个被写了一半的无效值，但这个值任然是处理器A写入的，只不过处理器A还没有写完而已。
最小安全性保证线程读取到的值，要么是之前某个线程写入的值，要么是默认值（0，null，false）。
但最小安全性并不保证线程读取到的共享变量的值，一定是某个线程写完后的值。
最小安全性保证线程读取到的值不会无中生有的冒出来，但并不保证线程读取到的值一定是正确的。
/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/*
问题2
是的，你的理解是对的。
这句话也要加上那个前提：“保证final引用不从构造函数内逸出”，final才能具有“初始化安全性”。</p>
<ul>
<li><a href="">回复</a></li>
<li><a href="">回到顶部</a>
<a href=""></a></li>
</ul>
<p><strong>编译器什么时候插入内存屏障？</strong>  10/04/2013 12:49 by 黄 春</p>
<p>厚积薄发之做。 明白了很多不解的地方。 这里有个问题想问下。 文中说“java编译器在生成字节码时，会在执行指令序列的适当位置插入内存屏障来限制处理器的重排序”。 这里有个问题请教。
插入内存屏障， 是在编译成字节码的时候完成， 还是在JIT执行的时候重新调整指令生成的？ 或者JIT只生产本地代码， 跟插入内存屏障之类的没关系？</p>
<ul>
<li><a href="">回复</a></li>
<li><a href="">回到顶部</a></li>
</ul>
<p><a href=""></a></p>
<p><strong>Re: 编译器什么时候插入内存屏障？</strong>  14/04/2013 11:01 by 程 晓明</p>
<p>Doug Lea在《The JSR-133 Cookbook for Compiler Writers》中，并没有明确指定插入内存屏障的时机。
个人估计，应该是取决于具体的JVM实现。</p>
<ul>
<li><a href="">回复</a></li>
<li><a href="">回到顶部</a></li>
</ul>
<p><a href="">关闭</a></p>
<h3 id="-by"><em>**</em> by</h3>
<p>发布于</p>
<ul>
<li><a href="">查看</a></li>
<li><a href="">回复</a></li>
<li><a href="">回到顶部</a>
<a href="">关闭</a>  主题   您的回复 <a href="">引用原消息</a></li>
</ul>
<p>允许的HTML标签: a,b,br,blockquote,i,li,pre,u,ul,p
当有人回复此评论时请E-mail通知我</p>
<p><a href="">关闭</a>  主题  您的回复</p>
<p>允许的HTML标签: a,b,br,blockquote,i,li,pre,u,ul,p
当有人回复此评论时请E-mail通知我
<a href="">关闭</a></p>
<ul>
<li>热点内容</li>
<li><a href="">本周</a></li>
<li><a href="">本月</a></li>
<li><a href="">近6个月</a><h3 id="-32-http-www-infoq-com-cn-news-2012-08-32-most-important-algorithms-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2012/08/32-most-important-algorithms?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">计算机科学中最重要的32个算法</a></h3>
</li>
</ul>
<h3 id="-thoughtworks-2013-5-http-www-infoq-com-cn-articles-thoughtworks-technology-radar-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/thoughtWorks-technology-radar?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">ThoughtWorks技术雷达（2013年5月）</a></h3>
<h3 id="-1-5-http-www-infoq-com-cn-articles-iqiyi-cloud-push-practices-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/iqiyi-cloud-push-practices?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">让1.5亿移动端用户第一时间获取消息</a></h3>
<h3 id="-thoughtworks-ceo-http-www-infoq-com-cn-news-2013-06-tw-guoxiao-on-talents-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2013/06/tw-guoxiao-on-talents?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">ThoughtWorks全球CEO郭晓谈软件人才的招聘与培养</a></h3>
<h3 id="-http-www-infoq-com-cn-news-2013-06-10-sins-for-scalability-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2013/06/10-sins-for-scalability?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">影响可扩展性的十宗罪</a></h3>
<h3 id="-6-http-www-infoq-com-cn-minibooks-architect-jun-10-2013-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/architect-jun-10-2013?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">架构师（6月刊）</a></h3>
<h3 id="-http-www-infoq-com-cn-articles-function-switch-realize-better-continuous-implementations-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/function-switch-realize-better-continuous-implementations?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">使用功能开关更好地实现持续部署</a></h3>
<h3 id="-eclipse-github-http-www-infoq-com-cn-news-2013-06-eclipse-github-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2013/06/eclipse-github?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">Eclipse迁移到GitHub</a></h3>
<h3 id="-newegg-com-http-www-infoq-com-cn-presentations-newegg-big-data-practice-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/presentations/newegg-big-data-practice?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">Newegg.com大数据实践</a></h3>
<h3 id="-http-www-infoq-com-cn-minibooks-software-sys-architect-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/software-sys-architect?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">软件系统架构：使用视点和视角与利益相关者合作</a></h3>
<h3 id="-32-http-www-infoq-com-cn-news-2012-08-32-most-important-algorithms-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2012/08/32-most-important-algorithms?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">计算机科学中最重要的32个算法</a></h3>
<h3 id="-6-http-www-infoq-com-cn-minibooks-architect-jun-10-2013-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/architect-jun-10-2013?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">架构师（6月刊）</a></h3>
<h3 id="-rest-http-www-infoq-com-cn-news-2013-06-rest-drawbacks-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2013/06/rest-drawbacks?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">REST的缺点是什么？</a></h3>
<h3 id="-google-web-ui-polymer-http-www-infoq-com-cn-news-2013-06-webcomponents-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2013/06/webcomponents?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">Google 发布新一代Web UI库Polymer</a></h3>
<h3 id="-http-www-infoq-com-cn-news-2013-06-dianping-xinnet-hacked-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2013/06/dianping-xinnet-hacked?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">大众点评网域名劫持事件概述</a></h3>
<h3 id="-node-js-grunt-js-http-www-infoq-com-cn-articles-gruntjs-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/GruntJs?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">基于Node.js的自动化构建工具Grunt.js</a></h3>
<h3 id="-node-js-node-js-http-www-infoq-com-cn-articles-what-is-nodejs-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/what-is-nodejs?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">深入浅出Node.js（一）：什么是Node.js</a></h3>
<h3 id="-http-www-infoq-com-cn-minibooks-i-m-wrights-hard-code-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/i-m-wrights-hard-code?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">代码之殇·第二版</a></h3>
<h3 id="-http-www-infoq-com-cn-minibooks-software-sys-architect-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/software-sys-architect?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">软件系统架构：使用视点和视角与利益相关者合作</a></h3>
<h3 id="-18-java-http-www-infoq-com-cn-news-2013-06-zhuhong-on-java-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2013/06/zhuhong-on-java?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">大家谈18岁的Java——朱鸿：开过跑车后再去开大巴车总是有点不爽的</a></h3>
<h3 id="-32-http-www-infoq-com-cn-news-2012-08-32-most-important-algorithms-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2012/08/32-most-important-algorithms?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">计算机科学中最重要的32个算法</a></h3>
<h3 id="-java-http-www-infoq-com-cn-articles-java-memory-model-1-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/java-memory-model-1?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">深入理解Java内存模型（一）——基础</a></h3>
<h3 id="-node-js-node-js-http-www-infoq-com-cn-articles-what-is-nodejs-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/what-is-nodejs?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">深入浅出Node.js（一）：什么是Node.js</a></h3>
<h3 id="-node-js-node-js-npm-http-www-infoq-com-cn-articles-nodejs-npm-install-config-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/nodejs-npm-install-config?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">深入浅出Node.js（二）：Node.js&amp;NPM的安装与配置</a></h3>
<h3 id="-3-http-www-infoq-com-cn-minibooks-architect-mar-10-2013-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/architect-mar-10-2013?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">架构师（3月刊）</a></h3>
<h3 id="-1-http-www-infoq-com-cn-minibooks-architect-jan-10-2013-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/architect-jan-10-2013?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">架构师（1月刊）</a></h3>
<h3 id="-4-http-www-infoq-com-cn-minibooks-architect-apr-10-2013-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/architect-apr-10-2013?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">架构师（4月刊）</a></h3>
<h3 id="-java-http-www-infoq-com-cn-articles-java-threadpool-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/java-threadPool?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">聊聊并发（三）——JAVA线程池的分析和使用</a></h3>
<h3 id="-2-http-www-infoq-com-cn-minibooks-architect-feb-10-2013-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/architect-feb-10-2013?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">架构师（2月刊）</a></h3>
<h3 id="-12306-github-http-www-infoq-com-cn-news-2013-01-12306-plugin-ddos-github-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2013/01/12306-plugin-ddos-github?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">12306订票助手插件拖垮GitHub事件原因始末</a></h3>
<h2 id="-">深度内容</h2>
<ul>
<li><a href="">全部</a></li>
<li><a href="">文章</a></li>
<li><a href="">演讲</a></li>
<li><a href="">访谈</a></li>
<li><a href="">迷你书</a><h2 id="-juergen-fesslmeier-javascript-http-www-infoq-com-cn-interviews-end-to-end-javascript-juergen-fesslmeier-javascript-"><a href="http://www.infoq.com/cn/interviews/end-to-end-javascript" title="Juergen Fesslmeier谈端到端的JavaScript开发" target="_blank">Juergen Fesslmeier谈端到端的JavaScript开发</a></h2>
</li>
</ul>
<p><a href="http://www.infoq.com/cn/author/Juergen-Fesslmeier" title="Juergen Fesslmeier" target="_blank">Juergen Fesslmeier</a> 七月 02, 2013</p>
<p><a href="http://www.infoq.com/cn/interviews/end-to-end-javascript" title="Juergen Fesslmeier谈端到端的JavaScript开发" target="_blank"><img src="" alt=""></a></p>
<h2 id="-http-www-infoq-com-cn-articles-design-pattern-automation-"><a href="http://www.infoq.com/cn/articles/Design-Pattern-Automation" title="设计模式自动化" target="_blank">设计模式自动化</a></h2>
<p><a href="http://www.infoq.com/cn/author/Gael-Fraiteur-and-Yan-Cui" title="Gael Fraiteur and Yan Cui" target="_blank">Gael Fraiteur and Yan Cui</a> 七月 01, 2013</p>
<p><a href="http://www.infoq.com/cn/articles/Design-Pattern-Automation" title="设计模式自动化" target="_blank"><img src="" alt=""></a></p>
<h2 id="-http-www-infoq-com-cn-articles-designing-a-world-at-your-fingertips-mobile-user-interfaces-"><a href="http://www.infoq.com/cn/articles/designing-a-world-at-your-fingertips-mobile-user-interfaces" title="设计指尖上的世界：移动用户界面一瞥" target="_blank">设计指尖上的世界：移动用户界面一瞥</a></h2>
<p><a href="http://www.infoq.com/cn/author/Forrest-Shull" title="Forrest Shull" target="_blank">Forrest Shull</a> 六月 28, 2013</p>
<p><a href="http://www.infoq.com/cn/articles/designing-a-world-at-your-fingertips-mobile-user-interfaces" title="设计指尖上的世界：移动用户界面一瞥" target="_blank"><img src="" alt=""></a></p>
<h2 id="-alm-http-www-infoq-com-cn-articles-integrated-alm-alm-"><a href="http://www.infoq.com/cn/articles/Integrated-ALM" title="成功的根本—集成的ALM工具" target="_blank">成功的根本—集成的ALM工具</a></h2>
<p><a href="http://www.infoq.com/cn/author/Dave-West" title="Dave West" target="_blank">Dave West</a> 六月 28, 2013</p>
<p><a href="http://www.infoq.com/cn/articles/Integrated-ALM" title="成功的根本—集成的ALM工具" target="_blank"><img src="" alt=""></a></p>
<h2 id="-http-www-infoq-com-cn-articles-atdd-by-example-book-"><a href="http://www.infoq.com/cn/articles/atdd-by-example-book" title="书评：验收测试驱动开发实践指南" target="_blank">书评：验收测试驱动开发实践指南</a></h2>
<p><a href="http://www.infoq.com/cn/author/Manuel-Pais" title="Manuel Pais" target="_blank">Manuel Pais</a> 六月 26, 2013</p>
<p><a href="http://www.infoq.com/cn/articles/atdd-by-example-book" title="书评：验收测试驱动开发实践指南" target="_blank"><img src="" alt=""></a></p>
<h2 id="-web-http-www-infoq-com-cn-presentations-across-device-web-web-"><a href="http://www.infoq.com/cn/presentations/across-device-web" title="跨终端的web" target="_blank">跨终端的web</a></h2>
<p><a href="http://www.infoq.com/cn/author/%E8%88%92%E6%96%87%E4%BA%AE" title="舒文亮" target="_blank">舒文亮</a> 六月 26, 2013</p>
<p><a href="http://www.infoq.com/cn/presentations/across-device-web" title="跨终端的web" target="_blank"><img src="" alt=""></a></p>
<ul>
<li><a href="">更早的 &gt;</a></li>
</ul>
<p>赞助商链接</p>
<h3 id="infoq-">InfoQ每周精要</h3>
<p>通过个性化定制的新闻邮件、RSS Feeds和InfoQ业界邮件通知，保持您对感兴趣的社区内容的时刻关注。
<a href="http://www.infoq.com/cn/newsletter_sample.html" target="_blank"><img src="" alt=""></a></p>
<p>语言 &amp; 开发</p>
<p><a href="http://www.infoq.com/cn/interviews/end-to-end-javascript" title="Juergen Fesslmeier谈端到端的JavaScript开发" target="_blank">Juergen Fesslmeier谈端到端的JavaScript开发</a></p>
<p><a href="http://www.infoq.com/cn/news/2013/07/mobilecloud-tfs" title="MobileCloud for TFS支持测试Windows Phone,Android,iOS及BlackBerry应用" target="_blank">MobileCloud for TFS支持测试Windows Phone,Android,iOS及BlackBerry应用</a></p>
<p><a href="http://www.infoq.com/cn/news/2013/07/baidu-salon39-summary" title="百度技术沙龙第39期回顾：前端快速开发实践（含资料下载）" target="_blank">百度技术沙龙第39期回顾：前端快速开发实践（含资料下载）</a></p>
<p>架构 &amp; 设计</p>
<p><a href="http://www.infoq.com/cn/news/2013/07/Native-Performance" title="内存与本机代码的性能" target="_blank">内存与本机代码的性能</a></p>
<p><a href="http://www.infoq.com/cn/articles/Design-Pattern-Automation" title="设计模式自动化" target="_blank">设计模式自动化</a></p>
<p><a href="http://www.infoq.com/cn/news/2013/07/WinRT-Devices" title="连接设备编程" target="_blank">连接设备编程</a>
过程 &amp; 实践</p>
<p><a href="http://www.infoq.com/cn/articles/Integrated-ALM" title="成功的根本—集成的ALM工具" target="_blank">成功的根本—集成的ALM工具</a></p>
<p><a href="http://www.infoq.com/cn/news/2013/06/tw-guoxiao-on-talents" title="ThoughtWorks全球CEO郭晓谈软件人才的招聘与培养" target="_blank">ThoughtWorks全球CEO郭晓谈软件人才的招聘与培养</a></p>
<p><a href="http://www.infoq.com/cn/articles/atdd-by-example-book" title="书评：验收测试驱动开发实践指南" target="_blank">书评：验收测试驱动开发实践指南</a></p>
<p>运维 &amp; 基础架构</p>
<p><a href="http://www.infoq.com/cn/news/2013/06/devops-in-traditional-enterprise" title="在传统企业中引入DevOps" target="_blank">在传统企业中引入DevOps</a></p>
<p><a href="http://www.infoq.com/cn/news/2013/06/dod-ams-day1-s-is-for-security" title="安全性——“DevOpS”中的S" target="_blank">安全性——“DevOpS”中的S</a></p>
<p><a href="http://www.infoq.com/cn/articles/atdd-by-example-book" title="书评：验收测试驱动开发实践指南" target="_blank">书评：验收测试驱动开发实践指南</a>
企业架构</p>
<p><a href="http://www.infoq.com/cn/articles/designing-a-world-at-your-fingertips-mobile-user-interfaces" title="设计指尖上的世界：移动用户界面一瞥" target="_blank">设计指尖上的世界：移动用户界面一瞥</a></p>
<p><a href="http://www.infoq.com/cn/news/2013/06/stratos-2" title="Stratos 2.0已发布，支持所有运行时环境和30个IaaS" target="_blank">Stratos 2.0已发布，支持所有运行时环境和30个IaaS</a></p>
<p><a href="http://www.infoq.com/cn/articles/iqiyi-cloud-push-practices" title="让1.5亿移动端用户第一时间获取消息" target="_blank">让1.5亿移动端用户第一时间获取消息</a></p>
<ul>
<li><a href="http://www.infoq.com/cn/" title="首页" target="_blank">首页</a></li>
<li><a href="http://www.infoq.com/cn/topics" title="全部话题" target="_blank">全部话题</a></li>
<li><a href="http://www.qconferences.com/" title="QCon全球软件开发大会" target="_blank">QCon全球软件开发大会</a></li>
<li><a href="http://www.infoq.com/cn/aboutus" title="关于我们" target="_blank">关于我们</a></li>
<li><a href="http://www.infoq.com/cn/contribute" title="让大家在InfoQ上听见你的声音" target="_blank">让大家在InfoQ上听见你的声音</a></li>
<li><a href="http://www.infoq.com/cn/reginit.action" title="创建账号" target="_blank">创建账号</a></li>
<li><p><a href="&quot;登录&quot;">登录</a></p>
</li>
<li><p><strong>会议</strong></p>
</li>
<li><a href="http://www.qconshanghai.com/" title="技术大会：QCon上海2013，11月1-3日 " target="_blank">QCon全球软件开发大会（上海站）2013，11月1-3日</a><h3 id="infoq-">InfoQ每周精要</h3>
</li>
</ul>
<p>通过个性化定制的新闻邮件、RSS Feeds和InfoQ业界邮件通知，保持您对感兴趣的社区内容的时刻关注。</p>
<p><a href="http://www.infoq.com/cn/newsletter_sample.html" target="_blank"><img src="" alt=""></a></p>
<ul>
<li><a href="http://www.infoq.com/cn/rss/rss.action?token=AjlwmaWcwi5ejkcT6GcRk1pCqJ4K7ocs" target="_blank">属于您的个性化RSS</a></li>
<li><a href="http://weibo.com/infoqchina" target="_blank">新浪微博</a></li>
<li><a href="http://www.facebook.com/InfoQ" target="_blank">社区新闻和热点</a></li>
</ul>
<p>特别专题</p>
<ul>
<li><a href="http://www.infoq.com/cn/chinaitevents" target="_blank"><strong>技术社区活动日历</strong></a></li>
<li><a href="http://www.infoq.com/cn/zones/baidu-salon/" target="_blank"><strong>百度技术沙龙</strong></a></li>
<li><a href="http://www.infoq.com/cn/scrum/" target="_blank"><strong>Scrum开发</strong></a></li>
<li><a href="http://www.infoq.com/cn/architect/" target="_blank"><strong>月刊：《架构师》</strong></a></li>
<li><a href="http://www.infoq.com/cn/qclub/" target="_blank"><strong>线下活动：QClub</strong></a>
定制您感兴趣的技术领域</li>
</ul>
<p>语言 &amp; 开发 架构 &amp; 设计 过程 &amp; 实践 运维 &amp; 基础架构 企业架构
提供反馈</p>
<p><a href="mailto:feedback@cn.infoq.com">feedback@cn.infoq.com</a>
 错误报告</p>
<p><a href="mailto:bugs@cn.infoq.com">bugs@cn.infoq.com</a>
 商务合作</p>
<p><a href="mailto:sales@cn.infoq.com">sales@cn.infoq.com</a>
 内容合作</p>
<p><a href="mailto:editors@cn.infoq.com">editors@cn.infoq.com</a>
 InfoQ.com及所有内容，版权所有 © 2006-2013 C4Media Inc. InfoQ.com 服务器由 <a href="http://www.contegix.com/" target="_blank">Contegix</a>提供, 我们最信赖的ISP合作伙伴。
<a href="http://www.infoq.com/cn/privacypolicy" target="_blank">隐私政策</a></p>
<p><a href="">Close</a>  E-mail  密码</p>
<p><a href="http://www.infoq.com/cn/social/googleLogin.action?fl=login" title="使用Google账号登录" target="_blank">使用Google账号登录</a>  <a href="http://www.infoq.com/cn/social/liveLogin.action?fl=login" title="使用Microsoft账号登录" target="_blank">使用Microsoft账号登录</a>
<a href="">忘记密码？</a>
   InfoQ账号使用的E-mail  发送邮件</p>
<p><a href="">重新登录</a>
重新发送激活信息  重新发送</p>
<p><a href="">重新登录</a>
<a href="http://www.infoq.com/cn/reginit.action" target="_blank">没有用户名？</a></p>
<p><a href="http://www.infoq.com/cn/reginit.action" target="_blank">点击注册</a></p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/Java_多线程/">Java_多线程</a></li><li><a href="/categories/Java&J2EE/Java_多线程/内存/">内存</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/Java_多线程/" class="label label-success">Java_多线程</a><a href="/tags/内存/" class="label label-info">内存</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:41"datetime="2014-03-07 09:54:41"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-Java_多线程-内存--深入理解Java内存模型（七）——总结/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-Java_多线程-内存--深入理解Java内存模型（七）——总结" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_多线程-内存--缓存算法/">缓存算法</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:41.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_多线程-内存--缓存算法/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-">缓存算法</h1>
<p><strong>缓存算法</strong></p>
<p>没有人能说清哪种缓存算法由于其他的缓存算法。（以下的几种缓存算法，有的我也理解不好，如果感兴趣，你可以Google一下 ）</p>
<p><strong>Least Frequently Used（LFU）</strong>：</p>
<p>大家好，我是 LFU，我会计算为每个缓存对象计算他们被使用的频率。我会把最不常用的缓存对象踢走。</p>
<p><strong>Least Recently User（LRU）</strong>：</p>
<p>我是LRU缓存算法，我把最近最少使用的缓存对象给踢走。</p>
<p>我总是需要去了解在什么时候，用了哪个缓存对象。如果有人想要了解我为什么总能把最近最少使用的对象踢掉，是非常困难的。</p>
<p>浏览器就是使用了我（LRU）作为缓存算法。新的对象会被放在缓存的顶部，当缓存达到了容量极限，我会把底部的对象踢走，而技巧就是：我会把最新被访问的缓存对象，放到缓存池的顶部。</p>
<p>所以，经常被读取的缓存对象就会一直呆在缓存池中。有两种方法可以实现我，array 或者是 linked list。</p>
<p>我的速度很快，我也可以被数据访问模式适配。我有一个大家庭，他们都可以完善我，甚至做的比我更好（我确实有时会嫉妒，但是没关系）。我家庭的一些成员包括LRU2 和 2Q，他们就是为了完善 LRU 而存在的。</p>
<p><strong>Least Recently Used 2（LRU2）</strong>：</p>
<p>我是 Least Recently Used 2，有人叫我最近最少使用twice，我更喜欢这个叫法。我会把被两次访问过的对象放入缓存池，当缓存池满了之后，我会把有两次最少使用的缓存对象踢走。 因为需要跟踪对象2次，访问负载就会随着缓存池的增加而增加。如果把我用在大容量的缓存池中，就会有问题。另外，我还需要跟踪那么不在缓存的对象，因为他 们还没有被第二次读取。我比LRU好，而且是 adoptive to access 模式 。</p>
<p><strong>Two Queues（2Q）</strong>：</p>
<p>我是 Two Queues；我把被访问的数据放到LRU的缓存中，如果这个对象再一次被访问，我就把他转移到第二个、更大的LRU缓存。</p>
<p>我踢走缓存对象是为了保持第一个缓存池是第二个缓存池的1/3。当缓存的访问负载是固定的时候，把 LRU 换成 LRU2，就比增加缓存的容量更好。这种机制使得我比 LRU2 更好，我也是 LRU 家族中的一员，而且是 adoptive to access 模式 。</p>
<p><strong>Adaptive Replacement Cache（ARC）</strong>：</p>
<p>我是 ARC，有人说我是介于 LRU 和 LFU 之间，为了提高效果，我是由2个 LRU 组成，第一个，也就是 L1，包含的条目是最近只被使用过一次的，而第二个 LRU，也就是 L2，包含的是最近被使用过两次的条目。因此， L1 放的是新的对象，而 L2 放的是常用的对象。所以，别人才会认为我是介于 LRU 和 LFU 之间的，不过没关系，我不介意。</p>
<p>我被认为是性能最好的缓存算法之一，能够自调，并且是低负载的。我也保存着历史对象，这样，我就可以记住那些被移除的对象，同时，也让我可以看到被移除的对象是否可以留下，取而代之的是踢走别的对象。我的记忆力很差，但是我很快，适用性也强。</p>
<p><strong>Most Recently Used（MRU）</strong>：</p>
<p>我是 MRU，和 LRU 是对应的。我会移除最近最多被使用的对象，你一定会问我为什么。好吧，让我告诉你，当一次访问过来的时候，有些事情是无法预测的，并且在缓存系统中找出最少最近使用的对象是一项时间复杂度非常高的运算，这就是为什么我是最好的选择。</p>
<p>我是数据库内存缓存中是多么的常见！每当一次缓存记录的使用，我会把它放到栈的顶端。当栈满了的时候，你猜怎么着？我会把栈顶的对象给换成新进来的对象！</p>
<p><strong>First in First out（FIFO）</strong>：</p>
<p>我是先进先出，我是一个低负载的算法，并且对缓存对象的管理要求不高。我通过一个队列去跟踪所有的缓存对象，最近最常用的缓存对象放在后面，而更早的缓存对象放在前面，当缓存容量满时，排在前面的缓存对象会被踢走，然后把新的缓存对象加进去。我很快，但是我并不适用。</p>
<p><strong>Second Chance</strong>：</p>
<p>大家好，我是 second chance，我是通过FIFO修改而来的，被大家叫做 second chance 缓存算法，我比 FIFO 好的地方是我改善了 FIFO 的成本。我是 FIFO 一样也是在观察队列的前端，但是很FIFO的立刻踢出不同，我会检查即将要被踢出的对象有没有之前被使用过的标志（1一个bit表示），没有没有被使用 过，我就把他踢出；否则，我会把这个标志位清除，然后把这个缓存对象当做新增缓存对象加入队列。你可以想象就这就像一个环队列。当我再一次在队头碰到这个 对象时，由于他已经没有这个标志位了，所以我立刻就把他踢开了。我在速度上比FIFO快。</p>
<p><strong>CLock</strong></p>
<p>我是Clock，一个更好的FIFO，也比 second chance更好。因为我不会像second chance那样把有标志的缓存对象放到队列的尾部，但是也可以达到second chance的效果。</p>
<p>我持有一个装有缓存对象的环形列表，头指针指向列表中最老的缓存对象。当缓存miss发生并且没有新的缓存空间时，我会问问指针指向的缓存对象的标 志位去决定我应该怎么做。如果标志是0，我会直接用新的缓存对象替代这个缓存对象；如果标志位是1，我会把头指针递增，然后重复这个过程，知道新的缓存对 象能够被放入。我比second chance更快。</p>
<p><strong>Simple time-based</strong>：</p>
<p>我是 simple time-based 缓存算法，我通过绝对的时间周期去失效那些缓存对象。对于新增的对象，我会保存特定的时间。我很快，但是我并不适用。</p>
<p><strong>Extended time-based expiration</strong>：</p>
<p>我是 extended time-based expiration 缓存算法，我是通过相对时间去失效缓存对象的；对于新增的缓存对象，我会保存特定的时间，比如是每5分钟，每天的12点。</p>
<p><strong>Sliding time-based expiration</strong>：</p>
<p>我是 sliding time-based expiration，与前面不同的是，被我管理的缓存对象的生命起点是在这个缓存的最后被访问时间算起的。我很快，但是我也不太适用。</p>
<p>好了！听了那么多缓存算法的自我介绍，其他的缓存算法还考虑到了下面几点：</p>
<p>成本。如果缓存对象有不同的成本，应该把那些难以获得的对象保存下来。
容量。如果缓存对象有不同的大小，应该把那些大的缓存对象清除，这样就可以让更多的小缓存对象进来了。
时间。一些缓存还保存着缓存的过期时间。电脑会失效他们，因为他们已经过期了。
根据缓存对象的大小而不管其他的缓存算法可能是有必要的。</p>
<p><strong>Random Cache</strong>：</p>
<p>我是随机缓存，我随意的替换缓存实体，没人敢抱怨。你可以说那个被替换的实体很倒霉。通过这些行为，我随意的去处缓存实体。我比FIFO机制好，在某些情况下，我甚至比 LRU 好，但是，通常LRU都会比我好。</p>
<p>看看缓存元素（缓存实体）
public class CacheElement {</p>
<p>private Object objectValue;</p>
<p>private Object objectKey;</p>
<p>private int index;</p>
<p>private int hitCount;</p>
<p>// getters and setters</p>
<p>}</p>
<p>这个缓存实体拥有缓存的key和value，这个实体的数据结构会被以下所有缓存算法用到。</p>
<p>缓存算法的公用代码
public final synchronized void addElement(Object key,Object value) {</p>
<p>int index;
Object obj;</p>
<p>// get the entry from the table
obj = table.get(key);</p>
<p>// If we have the entry already in our table
then get it and replace only its value.
if (obj != null) {
CacheElement element;</p>
<p>element = (CacheElement) obj;
element.setObjectValue(value);
element.setObjectKey(key);</p>
<p>return;
}
}</p>
<p>上面的代码会被所有的缓存算法实现用到。这段代码是用来检查缓存元素是否在缓存中了，如果是，我们就替换它，但是如果我们找不到这个key对应的缓存，我们会怎么做呢？那我们就来深入的看看会发生什么吧！</p>
<p>现场访问</p>
<p>今天的专题很特殊，因为我们有特殊的客人，事实上他们是我们想要听的与会者，但是首先，先介绍一下我们的客人：Random Cache，FIFO Cache。让我们从 Random Cache开始。</p>
<p>看看随机缓存的实现
public final synchronized void addElement(Object key,Object value) {</p>
<p>int index;
Object obj;</p>
<p>obj = table.get(key);</p>
<p>if (obj != null) {
CacheElement element;</p>
<p>// Just replace the value.
element = (CacheElement) obj;
element.setObjectValue(value);
element.setObjectKey(key);</p>
<p>return;
}</p>
<p>// If we haven’t
filled the cache yet, put it at the end.
if (!isFull()) {
index = numEntries;
++numEntries;
} else {
// Otherwise, replace a random entry.
index = (int) (cache.length /* random.nextFloat());
table.remove(cache[index].getObjectKey());
}</p>
<p>cache[index].setObjectValue(value);
cache[index].setObjectKey(key);
table.put(key, cache[index]);
}</p>
<p>看看FIFO缓存算法的实现</p>
<p>public final synchronized void addElement(Object
key,Object value) {
int index;
Object obj;</p>
<p>obj = table.get(key);</p>
<p>if (obj != null) {
CacheElement element;</p>
<p>// Just replace the value.
element = (CacheElement) obj;
element.setObjectValue(value);
element.setObjectKey(key);</p>
<p>return;
}</p>
<p>// If we haven’t filled the cache yet, put it at the end.
if (!isFull()) {
index = numEntries;
++numEntries;
} else {
// Otherwise, replace the current pointer, entry with the new one
index = current;
// in order to make Circular FIFO
if (++current &gt;= cache.length)
current = 0;</p>
<p>table.remove(cache[index].getObjectKey());
}</p>
<p>cache[index].setObjectValue(value);
cache[index].setObjectKey(key);
table.put(key, cache[index]);
}</p>
<p>看看LFU缓存算法的实现</p>
<p>public synchronized Object getElement(Object key) {</p>
<p>Object obj;</p>
<p>obj = table.get(key);</p>
<p>if (obj != null) {
CacheElement element = (CacheElement) obj;
element.setHitCount(element.getHitCount() + 1);
return element.getObjectValue();
}
return null;</p>
<p>}</p>
<p>public final synchronized void addElement(Object key, Object value) {</p>
<p>Object obj;</p>
<p>obj = table.get(key);</p>
<p>if (obj != null) {
CacheElement element;</p>
<p>// Just replace the value.
element = (CacheElement) obj;
element.setObjectValue(value);
element.setObjectKey(key);</p>
<p>return;
}</p>
<p>if (!isFull()) {</p>
<p>index = numEntries;
++numEntries;
} else {
CacheElement element = removeLfuElement();
index = element.getIndex();
table.remove(element.getObjectKey());
}</p>
<p>cache[index].setObjectValue(value);
cache[index].setObjectKey(key);
cache[index].setIndex(index);
table.put(key, cache[index]);
}</p>
<p>public CacheElement removeLfuElement() {</p>
<p>CacheElement[] elements = getElementsFromTable();
CacheElement leastElement = leastHit(elements);
return leastElement;
}</p>
<p>public static CacheElement leastHit(CacheElement[] elements) {</p>
<p>CacheElement lowestElement = null;
for (int i = 0; i &lt; elements.length; i++) {
CacheElement element = elements[i];
if (lowestElement == null) {
lowestElement = element;</p>
<p>} else {
if (element.getHitCount() &lt; lowestElement.getHitCount()) { lowestElement = element; }</p>
<p>}</p>
<p>}</p>
<p>return lowestElement;</p>
<p>}</p>
<p>最重点的代码，就应该是 leastHit 这个方法，这段代码就是把 hitCount 最低的元素找出来，然后删除，给新进的缓存元素留位置。 看看LRU缓存算法实现</p>
<p>private void moveToFront(int index) {</p>
<p>int nextIndex, prevIndex;</p>
<p>if(head != index) {</p>
<p>nextIndex = next[index];</p>
<p>prevIndex = prev[index]; // Only the head has a prev entry that is an invalid index so // we don’t check. next[prevIndex] = nextIndex; // Make sure index is valid. If it isn’t, we’re at the tail // and don’t set prev[next]. if(nextIndex &gt;= 0)
prev[nextIndex] = prevIndex;
else
tail = prevIndex;</p>
<p>prev[index] = -1;
next[index] = head;
prev[head] = index;
head = index;
}
}</p>
<p>public final synchronized void addElement(Object key, Object value) {
int index;
Object obj;</p>
<p>obj = table.get(key);</p>
<p>if(obj != null) {
CacheElement entry;</p>
<p>// Just replace the value, but move it to the front.
entry = (CacheElement)obj;
entry.setObjectValue(value);
entry.setObjectKey(key);</p>
<p>moveToFront(entry.getIndex());</p>
<p>return;
}</p>
<p>// If we haven’t filled the cache yet, place in next available spot
// and move to front.
if(!isFull()) {
if(_numEntries &gt; 0) {
prev[_numEntries] = tail;
next[_numEntries] = -1;
moveToFront(numEntries);
}
++numEntries;
} else {
// We replace the tail of the list.
table.remove(cache[tail].getObjectKey());
moveToFront(tail);
}</p>
<p>cache[head].setObjectValue(value);
cache[head].setObjectKey(key);
table.put(key, cache[head]);
}</p>
<p>这段代码的逻辑如 LRU算法 的描述一样，把再次用到的缓存提取到最前面，而每次删除的都是最后面的元素。</p>
<p>结论</p>
<p>我们已经看到 LFU缓存算法 和 LRU缓存算法的实现方式，至于如何实现，采用数组还是 LinkedHashMap，都由你决定，不够我一般是小的缓存容量用数组，大的用LinkedHashMap。
来源： <a href="[http://www.yiihsia.com/2011/01/%e7%bc%93%e5%ad%98%e7%ae%97%e6%b3%95/](http://www.yiihsia.com/2011/01/%e7%bc%93%e5%ad%98%e7%ae%97%e6%b3%95/)">[http://www.yiihsia.com/2011/01/%e7%bc%93%e5%ad%98%e7%ae%97%e6%b3%95/](http://www.yiihsia.com/2011/01/%e7%bc%93%e5%ad%98%e7%ae%97%e6%b3%95/)</a> 
Intro to Caching,Caching algorithms and caching frameworks part 2</p>
<p>Introduction:
In this part we are going to show how to implement some of the famous replacement algorithms as we mentioned in <a href="http://www.jtraining.com/blogs/intro-to-caching-caching-algorithms-and-caching-frameworks.html" target="_blank">part 1</a>, the code in this article is just for demonstration purpose which means you will have to do some extra effort if you want to make use of it in your application (if you are going to build your own implementation and wont use any caching frameworks)</p>
<p>The Leftover policy:</p>
<p>After programmer 1 read the article he proceeded to review the comments on this article, one of these comments were talking about leftover policy, which is named “Random Cache”</p>
<p>Random Cache:</p>
<p>I am random cache, I replace any cache entry I want, I just do that and no one can complain about that, you can say the unlucky entry, by doing this I remove any overhead of tracking references or so, am better than FIFO policy, in some cases I perform even better than LRU but in general LRU is better than me.</p>
<p>It is comment time:</p>
<p>While programmer 1 was reading the rest of the comments, he found very interesting comment about implementation of some of the famous replacement policies, actually it was a link to the commenter site which has the actual implementation so programmer 1 clicked the link and here what he got:</p>
<p>Meet the Cache Element:
public class CacheElement {
private Object objectValue;
private Object objectKey;
private int index;
private int
hitCount;
.
. // getters and setters
.
}</p>
<p>This is the cache entry which will use to hold the key and the value; this will be used in all the cache algorithms implementation</p>
<p>Common Code for All Caches:
public final synchronized void addElement(Object key,Object value) {
int index;
Object obj;
// get the entry from the table
obj = table.get(key);
// If we have the entry already in our table
then get it and replace only its value.
if (obj != null) {
CacheElement
element;
element = (CacheElement) obj;
element.setObjectValue(value);
element.setObjectKey(key);
return;
}
}</p>
<p>The above code will be common for all our implementation; it is about checking if the cacheElemnet already exists in our cache, if so then we just need to place its value and we don’t need to make anything else but what if we didn’t find it ? Then we will have to dig deeper and see what will happen below.</p>
<p>The Talk Show:</p>
<p>Today’s episode is a special episode , we have special guests , they are in fact compotators we are going to hear what everyone has to say but first lets introduce our guests:</p>
<p>Random Cache, FIFO Cache</p>
<p>Let’s start with the Random Cache.</p>
<p>Meet Random Cache implementation:
public final synchronized void addElement(Object key,Object value) {
int index;
Object obj;
obj = table.get(key);
if (obj
!= null) {
CacheElement element;
// Just replace the value.
element = (CacheElement) obj;
element.setObjectValue(value);
element.setObjectKey(key);
return;
}
// If we haven&#39;t
filled the cache yet, put it at the end.
if (!isFull()) {
index =
numEntries;
++numEntries;
} else {
// Otherwise, replace a random
entry.
index = (int) (cache.length /* random.nextFloat());
table.remove(cache[index].getObjectKey());
}
cache[index].setObjectValue(value);
cache[index].setObjectKey(key);
table.put(key, cache[index]);
}</p>
<p>Analyzing Random Cache Code (Talk show):</p>
<p>In today’s show the Random Cache is going to explain the code line by line and here we go.
I will go straight to the main point; if I am not full then I will place the new entry that the client requested at the end of the cache (in case there is a cache miss).</p>
<p>I do this by getting the number of entries that resides in the cache and assign it to index (which will be the index of the current entry the client is adding) after that I increment the number of entries.
if (!isFull()) {
index = numEntries;
++numEntries;
}</p>
<p>If I don’t have enough room for the current entry, I will have to kick out a random entry (totally random, bribing isn’t allowed).</p>
<p>In order to get the random entry, I will use the random util. shipped with java to generate a random index and ask the cache to remove the entry that its index equal to the generated index.
else {
// Otherwise, replace a random entry.
index = (int) (cache.length /* random.nextFloat());
table.remove(cache[index].getObjectKey());
}</p>
<p>At the end I just place the entry -either the cache was full or no- in the cache.</p>
<p>cache[index].setObjectValue(value);
cache[index].setObjectKey(key);
table.put(key, cache[index]);</p>
<p>Magnifying the Code:</p>
<p>It is said that when you look at stuff from a near view it is better to understand it, so that’s why we have a magnifying glass and we are going to magnify the code to get more near to it (and maybe understand it more).</p>
<p>Cache entries in the same voice: hi ho, hi ho, into cache we go.</p>
<p>New cache entry: excuse me; I have a question! (Asking a singing old cache entry near to him)</p>
<p>Old cache entry: go ahead.</p>
<p>New cache entry: I am new here and I don’t understand my role exactly, how will the algorithm handle us?</p>
<p>Old cache entry: cache! (Instead of man!), you remind me of myself when I was new (1st time I was added to the cache), I used to ask questions like that, let me show you what will happen.
<img src="" alt=""></p>
<p>Meet FIFO Cache Implementation:</p>
<p>public final synchronized void addElement(Object
key,Object value) {
int index;
Object obj;
obj = table.get(key);
if (obj != null) {
CacheElement element;
// Just replace the
value.
element = (CacheElement) obj;
element.setObjectValue(value);
element.setObjectKey(key);
return;
}
// If we haven&#39;t
filled the cache yet, put it at the end.
if (!isFull()) {
index =
numEntries;
++numEntries;
} else {
// Otherwise, replace the current
pointer, entry with the new one
index = current;
// in order to make
Circular FIFO
if (++current &gt;= cache.length)
current = 0;
table.remove(cache[index].getObjectKey());
}
cache[index].setObjectValue(value);
cache[index].setObjectKey(key);
table.put(key, cache[index]);
}</p>
<p>Analyzing FIFO Cache Code (Talk show):</p>
<p>After Random Cache, audience went crazy for random cache, which made FIFO a little bit jealous so FIFO started talking and said:</p>
<p>When there is no more rooms for the new cache entry , I will have to kick out the entry at the front (the one came first) as I work in a circular queue like manner, by default the current position is at the beginning of the queue(points to the beginning of the queue).</p>
<p>I assign current value to index (index of the current entry) and then check to see if the incremented current greater than or equals to the cache length(coz I want to reset current –pointer- position to the beginning of the queue) ,if so then I will set current to zero again ,after that I just kick the entry at the index position (Which is the first entry in the queue now) and place the new entry.
else {
// Otherwise, replace the current pointer,
which takes care of
// FIFO in a circular fashion.
index = current;
if (++current &gt;= cache.length)
current = 0;
table.remove(cache[index].getObjectKey());
}
cache[index].setObjectValue(value);
cache[index].setObjectKey(key);
table.put(key, cache[index]);</p>
<p>Magnifying the Code:</p>
<p>Back to our magnifying glass we can observe the following actions happening to our entries</p>
<p><img src="" alt="">Conclusion:</p>
<p>As we have seen in this article how to implement the FIFO replacement policy and also Random replacement policy, in the upcoming articles we will try to take our magnifying glass and magnify LFU, LRU replacement policy, till then stay tuned ;)</p>
<p>来源： <a href="[http://www.jtraining.com/component/content/article/35-jtraining-blog/137.html](http://www.jtraining.com/component/content/article/35-jtraining-blog/137.html)">[http://www.jtraining.com/component/content/article/35-jtraining-blog/137.html](http://www.jtraining.com/component/content/article/35-jtraining-blog/137.html)</a> </p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/Java_多线程/">Java_多线程</a></li><li><a href="/categories/Java&J2EE/Java_多线程/内存/">内存</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/Java_多线程/" class="label label-success">Java_多线程</a><a href="/tags/内存/" class="label label-info">内存</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:41"datetime="2014-03-07 09:54:41"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-Java_多线程-内存--缓存算法/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-Java_多线程-内存--缓存算法" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>





<ul id="pagination" class="pagination pagination-lg">
  <li><a class="extend prev" href="/page/63/">&laquo;</a></li><li><a class="page-number" href="/">1</a></li><li><a class="page-number" href="/page/2/">2</a></li><li><span class="space">&hellip;</span></li><li><a class="page-number" href="/page/61/">61</a></li><li><a class="page-number" href="/page/62/">62</a></li><li><a class="page-number" href="/page/63/">63</a></li><li class="active"><li><span class="page-number current">64</span></li><li><a class="page-number" href="/page/65/">65</a></li><li><a class="page-number" href="/page/66/">66</a></li><li><a class="page-number" href="/page/67/">67</a></li><li><span class="space">&hellip;</span></li></li><li><a class="page-number" href="/page/164/">164</a></li><li><a class="page-number" href="/page/165/">165</a></li><li><a class="extend next" href="/page/65/">&raquo;</a></li>
  <div class="clearfix"></div>
</ul></div><!--wapper-->
       </div><!-- ID main-col END -->
       <aside id="sidebar" class="alignright col-sx-6 col-sm-4 col-md-3 col-lg-3">
<div id="widget_search" class="widget panel panel-primary">
    <form action="//google.com/search" method="get" accept-charset="utf-8">
  <div class="input-group">
    <input class="form-control" id="searchbox" type="search" name="q" results="0" placeholder="search">
    <span class="input-group-btn">
      <button class="btn btn-default" type="submit">Go!</button>
    </span>
    <input type="hidden" name="q" value="site:itsolife.com">
  </div>
</form>
</div>

<div id="widget_category" class="widget panel panel-primary">
  <div class="panel-heading">category</div>  <div data-src='category' class='ajax_widgets'>正在加载...</div>
</div>

<div id="widget_recent_posts" class="widget panel panel-primary">
  <div class="panel-heading">recent posts</div>  <div data-src='recent_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_tagcloud" class="widget panel panel-primary">
  <div class="panel-heading">tagcloud</div>  <div data-src='tagcloud' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_latest_update_posts" class="widget panel panel-primary">
  <div class="panel-heading">最近更新</div>  <div data-src='latest_update_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_recent_comments" class="widget panel panel-primary">
  <div class="panel-heading">recent comments</div>  

<div class="list-group-item ds-recent-comments" data-num-items="6" data-show-avatars="1" data-show-time="1" data-show-title="1" data-show-admin="1" data-excerpt-length="50"></div>



</div>

</aside>
       <div class="clearfix"></div>
     </div><!-- row END -->
  </div>
  <footer id="footer" class="container">
  <div class="panel panel-info">
  <section id='footer_widget'></section>  <div class="panel-footer">
  <div id="site-info">
    <span class='author'>
  
  &copy; 2014 RobinChia
  
    &nbsp;&nbsp;</span>
  
  <span id='analytics-51la'></span><span id='analytics-google'>
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-48559895-1']);
  _gaq.push(['_trackPageview']);
  _js2load.push({src:('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'});
</script></span><span id='analytics-cnzz'>
<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_5774006'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s17.cnzz.com/stat.php%3Fid%3D5774006%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>
</span><span id='analytics-baidu'>
<script>
var _hmt = _hmt || [];
_js2load.push({src:"//hm.baidu.com/hm.js?1442f50724afc42380b51f097c43082c"});
</script>
</span>  </div>
  <div id="copyright">Blog powered by <a href='http://zespia.tw/hexo/'><strong>hexo</strong></a> Theme <strong><a href='https://github.com/chenall/hexo-theme-chenall'>chenall</a></strong>(Some change in it)<span class="pull-right"> 更新时间: <em>2014-03-15 16:01:36</em></span></div>
</div>
<div class="clearfix"></div>


  </div>
  </footer>
  
        <script src="http://cdn.bootcss.com/jquery/1.10.2/jquery.min.js"></script>        
        <script src="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/js/bootstrap.min.js"></script>        
                
        <script src="http://cdn.bootcss.com/prettify/r298/prettify.min.js"></script>    <script type="text/javascript">
   var lang=["bsh", "c", "cc", "cpp", "cs", "csh", "cyc", "cv", "htm", "html",
    "java", "js", "m", "mxml", "perl", "pl", "pm", "py", "rb", "sh",
    "xhtml", "xml", "xsl"];
   var pretty_base='';
   $('script').each(function(){
	var c = $(this).attr('src');
	if (!c)
	    return;
	if (c.match(/(\/)?prettify(\.min)?\.js/i))
	{
	    var index = c.lastIndexOf('/');
	    if (index != -1)
		pretty_base = c.substr(0,index + 1);
	    return false;
	}
   })
   $('pre code').each(function(){
	var c = $(this).attr('class')
	if (!c)
	    return;
	c = c.match(/\s?(lang\-\w+)/i);
	if (c && lang.indexOf(c[1]) == -1)
	{
	    lang.push(c[1]);
	    $.getScript(pretty_base + c[1] + '.min.js');
	}
   })

    $(window).load(function(){
       $("pre").addClass("prettyprint");
       prettyPrint();
    })
</script>    
            <script type="text/javascript">
var duoshuoQuery = {short_name:"robinchia"};
_js2load.push({src:'http://static.duoshuo.com/embed.js',charset:'UTF-8'});
</script>
    
            <!--wumii_relatedItems-->
    
        <script src="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js"></script>    <script type="text/javascript">
(function($){
  $('.entry').each(function(i){
    $(this).find('img').each(function(){
      var alt = this.alt;

      if (alt){
        $(this).before('<span class="caption">' + alt + '</span>');
      }

      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox" rel="fancybox' + i + '" />');
    });
  });

  $('.fancybox').fancybox();
})(jQuery);
</script>    
        <script src="http://cdn.bootcss.com/mathjax/2.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>    <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>
    
<script type="text/javascript">
$('.ajax_widgets').each(function(){var src=$(this).attr('data-src');if(src)$(this).load('/widgets/'+src+'.html');});
$.each(_js2load,function(index,obj){loadjs(obj.src,obj.charset)});
</script>

<div id="scroll2top">
<img src="/scroll2top/arrow.png"/>
</div>
<script src="/scroll2top/scroll2top.min.js"></script>
<div id="winterland">
  <canvas></canvas>
</div>
<script src="/js/winterland.min.js"></script>

  </body>
</html>
