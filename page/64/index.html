
<!DOCTYPE HTML>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>The 64 Page | It so life</title>
<meta name="author" content="RobinChia">

<meta name="description" content="It so life">


<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<meta property="og:site_name" content="It so life"/>

<!--[if IE]><style>.testIE.IE{display:inline;}</style><![endif]-->
<!--[if lte IE 7]><link rel="stylesheet" href="/css/ie7.css" type="text/css"><![endif]-->
<!--[if (lt IE 9)&(gt IE 7)]><style>.testIE.IE8{display:inline;}</style><![endif]-->
<!--[if gt IE 8]><style>.testIE.IE9{display:inline;}</style><![endif]-->

<link href="/favicon.png" rel="icon">
<link rel="alternate" href="/atom.xml" title="It so life Feed" type="application/atom+xml">

<link rel="stylesheet" href="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/css/bootstrap.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/font-awesome/4.0.3/css/font-awesome.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/prettify/r298/prettify.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" type="text/css">
<link rel="stylesheet" href="/css/style.css" type="text/css">
<!--[if lt IE 9]>
   <style>article,aside,dialog,footer,header,section,footer,nav,figure,menu{display:block}</style>
   <script src="http://cdn.staticfile.org/html5shiv/r29/html5.min.js"></script>
   <script src="http://cdn.staticfile.org/respond.js/1.4.2/respond.min.js"></script>
<link href="http://cdn.staticfile.org/respond.js/1.4.2/respond-proxy.html" id="respond-proxy" rel="respond-proxy" />
<link href="/js/respond.proxy.gif" id="respond-redirect" rel="respond-redirect" />
<script src="/js/respond.proxy.js"></script>
   <script src="http://cdn.bootcss.com/selectivizr/1.0.2/selectivizr-min.js"></script>
<![endif]-->
<script type="text/javascript">
function loadjs(c,d){var a=document.createElement("script");a.async=!0;a.type="text/javascript";a.src=c;a.charset=d||"gbk";(document.getElementsByTagName("HEAD")[0]||document.getElementsByTagName("BODY")[0]).appendChild(a)};
var _protocol = (("https:" == document.location.protocol) ? " https://" : " http://");
var _js2load = [];
</script>

</head>
<body>
      <header id="header" class="container"><nav id="main-nav" class="navbar navbar-default navbar-fixed-top " role="navigation">
  <div class="container">
    <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
      <span class="sr-only">Toggle navigation</span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="/">It so life</a>
    </div>
    <div  class="collapse navbar-collapse">
      <ul  class="nav navbar-nav">
  
        <li><a href="/" title="Home">Home</a></li>      
        <li><a href="/about/" title="About">About</a></li>      
        <li><a href="/archives/" title="Archives">Archives</a></li>      
      <li class='dropdown'>
        <a class='dropdown-toggle' data-toggle='dropdown' href='#'>website<b class='caret'></b></a>
        <ul class='dropdown-menu pure-menu-selected'>
    
          <li><a href="//groups.google.com/forum/#!forum/pongba" title="TopLanguage">TopLanguage</a></li>    
          <li><a href="//itpub.net/" title="ITPub">ITPub</a></li>    
          <li><a href="//blog.jobbole.com/" title="Bole">Bole</a></li>    
          <li><a href="//nosql-database.org/" title="nosql">nosql</a></li>    
          <li><a href="//gitimmersion.googol.im/" title="Git">Git</a></li>    
        </ul>
      </li>
    
      </ul>
      <ul class="nav navbar-nav navbar-right">
      
        <li><a href="/atom.xml">RSS</a></li>
      
      
        <li><a href="https://twitter.com/robinchia">twitter</a></li>
      
      
      
      
        <li><a href="https://github.com/robinchia">github</a></li>
      
      </ul>
    </div>
  </div>
</nav>
<div class="clearfix"></div>
</header>
  <div id='content' class="container">
     <div class="page-header-wrapper">
      <!--[if lt IE 9]><div class="alert alert-warning alert-dismissable"><button type="button" class="close" data-dismiss="alert" aria-hidden="true">&times;</button><strong>提示:</strong>您的浏览器版本太低了,建议升级到 <strong><a href="http://windows.microsoft.com/zh-cn/internet-explorer/download-ie" title="IE9">IE9</a></strong> 以上,本站使用<a href="https://www.google.com/intl/zh-CN/chrome/">Chrome浏览器</a>可以获得最好的显示效果.</div><![endif]-->
      <div class="page-header"><h1 align="center"><big>It so life</big> </h1>
        <h5 align="center"><big>love as life</big></h5>
      </div>
     </div>
     <div class="row">
       <div id="main-col" class="alignleft col-sx-12 col-sm-8 col-md-9 col-lg-9">
      <section id='header_widget'></section>
          <div id="wrapper"><article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_多线程-并发--深入浅出JavaConcurrency2-原子操作/">深入浅出 Java Concurrency (2)</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:41.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_多线程-并发--深入浅出JavaConcurrency2-原子操作/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-java-concurrency-2-">深入浅出 Java Concurrency (2): 原子操作</h1>
<p>从相对简单的Atomic入手（java.util.concurrent是基于Queue的并发包，而Queue，很多情况下使用到了Atomic操作，因此首先从这里开始）。很多情况下我们只是需要一个简单的、高效的、线程安全的递增递减方案。注意，这里有三个条件：简单，意味着程序员尽可能少的操作底层或者实现起来要比较容易；高效意味着耗用资源要少，程序处理速度要快；线程安全也非常重要，这个在多线程下能保证数据的正确性。这三个条件看起来比较简单，但是实现起来却难以令人满意。</p>
<p>通常情况下，在Java里面，++i或者--i不是线程安全的，这里面有三个独立的操作：或者变量当前值，为该值+1/-1，然后写回新的值。在没有额外资源可以利用的情况下，只能使用加锁才能保证读-改-写这三个操作时“原子性”的。</p>
<p>Doug Lea在未将<a href="http://backport-jsr166.sourceforge.net/" target="_blank">backport-util-concurrent</a>合并到<a href="http://jcp.org/en/jsr/detail?id=166" target="_blank">JSR 166</a>里面来之前，是采用纯Java实现的，于是不可避免的采用了synchronized关键字。</p>
<p>public final synchronized void set(int newValue);</p>
<p>public final synchronized int getAndSet(int newValue);</p>
<p>public final synchronized int incrementAndGet();</p>
<p>同时在变量上使用了volatile （后面会具体来讲volatile到底是个什么东东）来保证get()的时候不用加锁。尽管synchronized的代价还是很高的，但是在没有JNI的手段下纯Java语言还是不能实现此操作的。</p>
<p>JSR 166提上日程后，backport-util-concurrent就合并到JDK 5.0里面了，在这里面重复使用了现代CPU的特性来降低锁的消耗。后本章的最后小结中会谈到这些原理和特性。在此之前先看看API的使用。</p>
<p>一切从java.util.concurrent.atomic.AtomicInteger开始。</p>
<p>int addAndGet(int delta)
          以原子方式将给定值与当前值相加。 实际上就是等于线程安全版本的i =i+delta操作。</p>
<p>boolean compareAndSet(int expect, int update)
          如果当前值 == 预期值，则以原子方式将该值设置为给定的更新值。 如果成功就返回true，否则返回false，并且不修改原值。</p>
<p>int decrementAndGet()
          以原子方式将当前值减 1。 相当于线程安全版本的--i操作。</p>
<p>int get()
          获取当前值。</p>
<p>int getAndAdd(int delta)
          以原子方式将给定值与当前值相加。 相当于线程安全版本的t=i;i+=delta;return t;操作。</p>
<p>int getAndDecrement()
          以原子方式将当前值减 1。 相当于线程安全版本的i--操作。</p>
<p>int getAndIncrement()
          以原子方式将当前值加 1。 相当于线程安全版本的i++操作。</p>
<p>int getAndSet(int newValue)
          以原子方式设置为给定值，并返回旧值。 相当于线程安全版本的t=i;i=newValue;return t;操作。</p>
<p>int incrementAndGet()
          以原子方式将当前值加 1。 相当于线程安全版本的++i操作。 </p>
<p>void lazySet(int newValue)
          最后设置为给定值。 延时设置变量值，这个等价于set()方法，但是由于字段是volatile类型的，因此次字段的修改会比普通字段（非volatile字段）有稍微的性能延时（尽管可以忽略），所以如果不是想立即读取设置的新值，允许在“后台”修改值，那么此方法就很有用。如果还是难以理解，这里就类似于启动一个后台线程如执行修改新值的任务，原线程就不等待修改结果立即返回（这种解释其实是不正确的，但是可以这么理解）。</p>
<p>void set(int newValue)
          设置为给定值。 直接修改原始值，也就是i=newValue操作。</p>
<p>boolean weakCompareAndSet(int expect, int update)
          如果当前值 == 预期值，则以原子方式将该设置为给定的更新值。JSR规范中说：以原子方式读取和有条件地写入变量但<em>不</em> 创建任何 happen-before 排序，因此不提供与除 weakCompareAndSet 目标外任何变量以前或后续读取或写入操作有关的任何保证。大意就是说调用weakCompareAndSet时并不能保证不存在happen-before的发生（也就是可能存在指令重排序导致此操作失败）。但是从Java源码来看，其实此方法并没有实现JSR规范的要求，最后效果和compareAndSet是等效的，都调用了unsafe.compareAndSwapInt()完成操作。
下面的代码是一个测试样例，为了省事就写在一个方法里面来了。
<img src="" alt="">package xylz.study.concurrency.atomic;
<img src="" alt="">
<img src="" alt="">import java.util.concurrent.atomic.AtomicInteger;
<img src="" alt="">
<img src="" alt="">import org.junit.Test;
<img src="" alt="">
<img src="" alt="">import static org.junit.Assert./*;
<img src="" alt="">
<img src="" alt="">public class AtomicIntegerTest {
<img src="" alt="">
<img src="" alt="">    @Test
<img src="" alt="">    public void testAll() throws InterruptedException{
<img src="" alt="">        final AtomicInteger value = new AtomicInteger(10);
<img src="" alt="">        assertEquals(value.compareAndSet(1, 2), false);
<img src="" alt="">        assertEquals(value.get(), 10);
<img src="" alt="">        assertTrue(value.compareAndSet(10, 3));
<img src="" alt="">        assertEquals(value.get(), 3);
<img src="" alt="">        value.set(0);
<img src="" alt="">        //
<img src="" alt="">        assertEquals(value.incrementAndGet(), 1);
<img src="" alt="">        assertEquals(value.getAndAdd(2),1);
<img src="" alt="">        assertEquals(value.getAndSet(5),3);
<img src="" alt="">        assertEquals(value.get(),5);
<img src="" alt="">        //
<img src="" alt="">        final int threadSize = 10;
<img src="" alt="">        Thread[] ts = new Thread[threadSize];
<img src="" alt="">        for (int i = 0; i &lt; threadSize; i++) {
<img src="" alt="">            ts[i] = new Thread() {
<img src="" alt="">                public void run() {
<img src="" alt="">                    value.incrementAndGet();
<img src="" alt="">                }
<img src="" alt="">            };
<img src="" alt="">        }
<img src="" alt="">        //
<img src="" alt="">        for(Thread t:ts) {
<img src="" alt="">            t.start();
<img src="" alt="">        }
<img src="" alt="">        for(Thread t:ts) {
<img src="" alt="">            t.join();
<img src="" alt="">        }
<img src="" alt="">        //
<img src="" alt="">        assertEquals(value.get(), 5+threadSize);
<img src="" alt="">    }
<img src="" alt="">
<img src="" alt="">}
<img src="" alt="">
 由于这里例子比较简单，这里就不做过多介绍了。
AtomicInteger和AtomicLong、AtomicBoolean、AtomicReference差不多，这里就不介绍了。在下一篇中就介绍下数组、字段等其他方面的原子操作。
 参考资料：
(1)<a href="http://stackoverflow.com/questions/2443239/java-atomicinteger-what-are-the-differences-between-compareandset-and-weakcompar" target="_blank"><a href="http://stackoverflow.com/questions/2443239/java-atomicinteger-what-are-the-differences-between-compareandset-and-weakcompar">http://stackoverflow.com/questions/2443239/java-atomicinteger-what-are-the-differences-between-compareandset-and-weakcompar</a></a>
(2)<a href="http://stackoverflow.com/questions/1468007/atomicinteger-lazyset-and-set" target="_blank"><a href="http://stackoverflow.com/questions/1468007/atomicinteger-lazyset-and-set">http://stackoverflow.com/questions/1468007/atomicinteger-lazyset-and-set</a></a></p>
<p>来源： <a href="[http://www.blogjava.net/xylz/archive/2010/07/01/324988.html](http://www.blogjava.net/xylz/archive/2010/07/01/324988.html)">[http://www.blogjava.net/xylz/archive/2010/07/01/324988.html](http://www.blogjava.net/xylz/archive/2010/07/01/324988.html)</a></p>
<p>在这一部分开始讨论数组原子操作和一些其他的原子操作。</p>
<p><strong>AtomicIntegerArray/AtomicLongArray/AtomicReferenceArray</strong>的API类似，选择有代表性的AtomicIntegerArray来描述这些问题。</p>
<p><strong>int get(int i)</strong></p>
<p>获取位置 </p>
<p>i
 的当前值。很显然，由于这个是数组操作，就有索引越界的问题（IndexOutOfBoundsException异常）。</p>
<p>对于下面的API起始和AtomicInteger是类似的，这种通过方法、参数的名称就能够得到函数意义的写法是非常值得称赞的。在<a href="http://www.china-pub.com/12901" target="_blank">《重构：改善既有代码的设计》</a>和<a href="http://www.china-pub.com/196266" target="_blank">《代码整洁之道》</a>中都非常推崇这种做法。</p>
<p><strong>void set(int i, int newValue)</strong>
<strong>void lazySet(int i, int newValue)
int getAndSet(int i, int newValue)
boolean compareAndSet(int i, int expect, int update)
boolean weakCompareAndSet(int i, int expect, int update)
int getAndIncrement(int i)
int getAndDecrement(int i)
int getAndAdd(int i, int delta)
int incrementAndGet(int i)
int decrementAndGet(int i)
int addAndGet(int i, int delta)</strong></p>
<p>整体来说，数组的原子操作在理解上还是相对比较容易的，这些API就是有多使用才能体会到它们的好处，而不仅仅是停留在理论阶段。</p>
<p>现在关注字段的原子更新。</p>
<p><strong>AtomicIntegerFieldUpdater<T>/AtomicLongFieldUpdater<T>/AtomicReferenceFieldUpdater<T,V></strong>是基于反射的原子更新字段的值。</p>
<p>相应的API也是非常简单的，但是也是有一些约束的。</p>
<p>（1）字段必须是volatile类型的！在后面的章节中会详细说明为什么必须是volatile，volatile到底是个什么东西。</p>
<p>（2）字段的描述类型（修饰符public/protected/default/private）是与调用者与操作对象字段的关系一致。也就是说调用者能够直接操作对象字段，那么就可以反射进行原子操作。但是对于父类的字段，子类是不能直接操作的，尽管子类可以访问父类的字段。</p>
<p>（3）只能是实例变量，不能是类变量，也就是说不能加static关键字。</p>
<p>（4）只能是可修改变量，不能使final变量，因为final的语义就是不可修改。实际上final的语义和volatile是有冲突的，这两个关键字不能同时存在。</p>
<p>（5）对于<strong>AtomicIntegerFieldUpdater</strong>和<strong>AtomicLongFieldUpdater</strong>只能修改int/long类型的字段，不能修改其包装类型（Integer/Long）。如果要修改包装类型就需要使用<strong>AtomicReferenceFieldUpdater</strong>。</p>
<p>在下面的例子中描述了操作的方法。</p>
<p><img src="" alt="">package xylz.study.concurrency.atomic; 
<img src="" alt="">
<img src="" alt="">import java.util.concurrent.atomic.AtomicIntegerFieldUpdater; 
<img src="" alt="">
<img src="" alt="">public class AtomicIntegerFieldUpdaterDemo { 
<img src="" alt="">
<img src="" alt="">   class DemoData{
<img src="" alt="">       public volatile int value1 = 1;
<img src="" alt="">       volatile int value2 = 2;
<img src="" alt="">       protected volatile int value3 = 3;
<img src="" alt="">       private volatile int value4 = 4;
<img src="" alt="">   }
<img src="" alt="">    AtomicIntegerFieldUpdater<DemoData> getUpdater(String fieldName) {
<img src="" alt="">        return AtomicIntegerFieldUpdater.newUpdater(DemoData.class, fieldName);
<img src="" alt="">    }
<img src="" alt="">    void doit() {
<img src="" alt="">        DemoData data = new DemoData();
<img src="" alt="">        System.out.println(&quot;1 ==&gt; &quot;+getUpdater(&quot;value1&quot;).getAndSet(data, 10));
<img src="" alt="">        System.out.println(&quot;3 ==&gt; &quot;+getUpdater(&quot;value2&quot;).incrementAndGet(data));
<img src="" alt="">        System.out.println(&quot;2 ==&gt; &quot;+getUpdater(&quot;value3&quot;).decrementAndGet(data));
<img src="" alt="">        System.out.println(&quot;true ==&gt; &quot;+getUpdater(&quot;value4&quot;).compareAndSet(data, 4, 5));
<img src="" alt="">    }
<img src="" alt="">    public static void main(String[] args) {
<img src="" alt="">        AtomicIntegerFieldUpdaterDemo demo = new AtomicIntegerFieldUpdaterDemo();
<img src="" alt="">        demo.doit();
<img src="" alt="">    }
<img src="" alt="">} 
<img src="" alt="">
<img src="" alt=""></p>
<p>在上面的例子中DemoData的字段value3/value4对于AtomicIntegerFieldUpdaterDemo类是不可见的，因此通过反射是不能直接修改其值的。</p>
<p><strong>AtomicMarkableReference</strong>类描述的一个<Object,Boolean>的对，可以原子的修改Object或者Boolean的值，这种数据结构在一些缓存或者状态描述中比较有用。这种结构在单个或者同时修改Object/Boolean的时候能够有效的提高吞吐量。</p>
<p><strong>AtomicStampedReference</strong>类维护带有整数“标志”的对象引用，可以用原子方式对其进行更新。对比<strong>AtomicMarkableReference</strong>类的<Object,Boolean>，<strong>AtomicStampedReference</strong>维护的是一种类似<Object,int>的数据结构，其实就是对对象（引用）的一个并发计数。但是与<strong>AtomicInteger</strong>不同的是，此数据结构可以携带一个对象引用（Object），并且能够对此对象和计数同时进行原子操作。</p>
<p>在后面的章节中会提到“ABA问题”，而<strong>AtomicMarkableReference/**</strong>AtomicStampedReference<strong>在解决“ABA问题”上很有用</strong>。**</p>
<hr>
<p>原子操作的使用大概就是这么多，大体来说还算是比较清晰的，在下一个章节中，将对象原子操作进行总结，重点介绍下原子操作的原理和设计思想。
来源： <a href="[http://www.blogjava.net/xylz/archive/2010/07/02/325079.html](http://www.blogjava.net/xylz/archive/2010/07/02/325079.html)">[http://www.blogjava.net/xylz/archive/2010/07/02/325079.html](http://www.blogjava.net/xylz/archive/2010/07/02/325079.html)</a> </p>
<p>在这个小结里面重点讨论原子操作的原理和设计思想。</p>
<p>由于在下一个章节中会谈到锁机制，因此此小节中会适当引入锁的概念。</p>
<p>在<a href="http://www.amazon.com/exec/obidos/ASIN/0321349601/ref=nosim/none0b69" title="http://www.amazon.com/exec/obidos/ASIN/0321349601/ref=nosim/none0b69" target="_blank">Java Concurrency in Practice</a>中是这样定义线程安全的：
<strong>当多个线程访问一个类时，如果不用考虑这些线程在运行时环境下的调度和交替运行，并且不需要额外的同步及在调用方代码不必做其他的协调，这个类的行为仍然是正确的，那么这个类就是线程安全的。</strong></p>
<p>显然只有资源竞争时才会导致线程不安全，因此<strong><em>无状态对象永远是线程安全的</em></strong>。</p>
<p>原子操作的描述是： 多个线程执行一个操作时，其中<strong><em>任何一个线程要么完全执行完此操作，要么没有执行此操作的任何步骤</em></strong>，那么这个操作就是原子的。</p>
<p>枯燥的定义介绍完了，下面说更枯燥的理论知识。</p>
<p><strong>指令重排序</strong></p>
<p>Java语言规范规定了JVM线程内部维持顺序化语义，也就是说只要程序的最终结果等同于它在严格的顺序化环境下的结果，那么指令的执行顺序就可能与代码的顺序不一致。这个过程通过叫做指令的重排序。指令重排序存在的意义在于：JVM能够根据处理器的特性（CPU的多级缓存系统、多核处理器等）适当的重新排序机器指令，使机器指令更符合CPU的执行特点，最大限度的发挥机器的性能。</p>
<p>程序执行最简单的模型是按照指令出现的顺序执行，这样就与执行指令的CPU无关，最大限度的保证了指令的可移植性。这个模型的专业术语叫做顺序化一致性模型。但是现代计算机体系和处理器架构都不保证这一点（因为人为的指定并不能总是保证符合CPU处理的特性）。</p>
<p>我们来看最经典的一个案例。
<img src="" alt="">package xylz.study.concurrency.atomic; 
<img src="" alt="">
<img src="" alt="">public class ReorderingDemo { 
<img src="" alt="">
<img src="" alt="">    static int x = 0, y = 0, a = 0, b = 0; 
<img src="" alt="">
<img src="" alt="">    public static void main(String[] args) throws Exception { 
<img src="" alt="">
<img src="" alt="">        for (int i = 0; i &lt; 100; i++) {
<img src="" alt="">            x=y=a=b=0;
<img src="" alt="">            Thread one = new Thread() {
<img src="" alt="">                public void run() {
<img src="" alt="">                    a = 1;
<img src="" alt="">                    x = b;
<img src="" alt="">                }
<img src="" alt="">            };
<img src="" alt="">            Thread two = new Thread() {
<img src="" alt="">                public void run() {
<img src="" alt="">                    b = 1;
<img src="" alt="">                    y = a;
<img src="" alt="">                }
<img src="" alt="">            };
<img src="" alt="">            one.start();
<img src="" alt="">            two.start();
<img src="" alt="">            one.join();
<img src="" alt="">            two.join();
<img src="" alt="">            System.out.println(x + &quot; &quot; + y);
<img src="" alt="">        }
<img src="" alt="">    } 
<img src="" alt="">
<img src="" alt="">}
<img src="" alt="">
<img src="" alt="">
在这个例子中one/two两个线程修改区x,y,a,b四个变量，在执行100次的情况下，可能得到(0 1)或者（1 0）或者（1 1）。事实上按照JVM的规范以及CPU的特性有很可能得到（0 0）。当然上面的代码大家不一定能得到（0 0），因为run()里面的操作过于简单，可能比启动一个线程花费的时间还少，因此上面的例子难以出现（0,0）。但是在现代CPU和JVM上确实是存在的。由于run()里面的动作对于结果是无关的，因此里面的指令可能发生指令重排序，即使是按照程序的顺序执行，数据变化刷新到主存也是需要时间的。假定是按照a=1;x=b;b=1;y=a;执行的，x=0是比较正常的，虽然a=1在y=a之前执行的，但是由于线程one执行a=1完成后还没有来得及将数据1写回主存（这时候数据是在线程one的堆栈里面的），线程two从主存中拿到的数据a可能仍然是0（显然是一个过期数据，但是是有可能的），这样就发生了数据错误。</p>
<p>在两个线程交替执行的情况下数据的结果就不确定了，在机器压力大，多核CPU并发执行的情况下，数据的结果就更加不确定了。</p>
<p><strong>Happens-before法则</strong></p>
<p>Java存储模型有一个happens-before原则，就是如果动作B要看到动作A的执行结果（无论A/B是否在同一个线程里面执行），那么A/B就需要满足happens-before关系。</p>
<p>在介绍happens-before法则之前介绍一个概念：JMM动作（Java Memeory Model Action），Java存储模型动作。一个动作（Action）包括：变量的读写、监视器加锁和释放锁、线程的start()和join()。后面还会提到锁的的。</p>
<p>happens-before完整规则：
（1）同一个线程中的每个Action都happens-before于出现在其后的任何一个Action。</p>
<p>（2）对一个监视器的解锁happens-before于每一个后续对同一个监视器的加锁。</p>
<p>（3）对volatile字段的写入操作happens-before于每一个后续的同一个字段的读操作。</p>
<p>（4）Thread.start()的调用会happens-before于启动线程里面的动作。</p>
<p>（5）Thread中的所有动作都happens-before于其他线程检查到此线程结束或者Thread.join（）中返回或者Thread.isAlive()==false。</p>
<p>（6）一个线程A调用另一个另一个线程B的interrupt（）都happens-before于线程A发现B被A中断（B抛出异常或者A检测到B的isInterrupted（）或者interrupted()）。</p>
<p>（7）一个对象构造函数的结束happens-before与该对象的finalizer的开始</p>
<p>（8）如果A动作happens-before于B动作，而B动作happens-before与C动作，那么A动作happens-before于C动作。</p>
<p><strong>volatile语义</strong></p>
<p>到目前为止，我们多次提到volatile，但是却仍然没有理解volatile的语义。</p>
<p>volatile相当于synchronized的弱实现，也就是说volatile实现了类似synchronized的语义，却又没有锁机制。它确保对volatile字段的更新以可预见的方式告知其他的线程。</p>
<p>volatile包含以下语义：</p>
<p>（1）Java 存储模型不会对valatile指令的操作进行重排序：这个保证对volatile变量的操作时按照指令的出现顺序执行的。</p>
<p>（2）volatile变量不会被缓存在寄存器中（只有拥有线程可见）或者其他对CPU不可见的地方，每次总是从主存中读取volatile变量的结果。也就是说对于volatile变量的修改，其它线程总是可见的，并且不是使用自己线程栈内部的变量。也就是在happens-before法则中，对一个valatile变量的写操作后，其后的任何读操作理解可见此写操作的结果。</p>
<p>尽管volatile变量的特性不错，但是volatile并不能保证线程安全的，也就是说volatile字段的操作不是原子性的，volatile变量只能保证可见性（一个线程修改后其它线程能够理解看到此变化后的结果），要想保证原子性，目前为止只能加锁！</p>
<p>volatile通常在下面的场景：</p>
<p><img src="" alt="">volatile boolean done = false;
<img src="" alt="">
<img src="" alt="">…
<img src="" alt="">
<img src="" alt="">    while( ! done ){
<img src="" alt="">        dosomething();
<img src="" alt="">    }</p>
<p>应用volatile变量的三个原则：
（1）写入变量不依赖此变量的值，或者只有一个线程修改此变量</p>
<p>（2）变量的状态不需要与其它变量共同参与不变约束</p>
<p>（3）访问变量不需要加锁</p>
<p><strong>这一节理论知识比较多，但是这是很面很多章节的基础，在后面的章节中会多次提到这些特性。</strong></p>
<p>本小节中还是没有谈到原子操作的原理和思想，在下一节中将根据上面的一些知识来介绍原子操作。</p>
<p>参考资料：</p>
<p>（1）<a href="http://www.amazon.com/exec/obidos/ASIN/0321349601/ref=nosim/none0b69" title="http://www.amazon.com/exec/obidos/ASIN/0321349601/ref=nosim/none0b69" target="_blank">Java Concurrency in Practice</a></p>
<p>（2）<a href="http://www.ibm.com/developerworks/cn/java/j-jtp06197.html" target="_blank">正确使用 Volatile 变量</a>
来源： <a href="[http://www.blogjava.net/xylz/archive/2010/07/03/325168.html](http://www.blogjava.net/xylz/archive/2010/07/03/325168.html)">[http://www.blogjava.net/xylz/archive/2010/07/03/325168.html](http://www.blogjava.net/xylz/archive/2010/07/03/325168.html)</a> </p>
<p>在JDK 5之前Java语言是靠synchronized关键字保证同步的，这会导致有锁（后面的章节还会谈到锁）。</p>
<p>锁机制存在以下问题：</p>
<p>（1）在多线程竞争下，加锁、释放锁会导致比较多的上下文切换和调度延时，引起性能问题。</p>
<p>（2）一个线程持有锁会导致其它所有需要此锁的线程挂起。</p>
<p>（3）如果一个优先级高的线程等待一个优先级低的线程释放锁会导致优先级倒置，引起性能风险。</p>
<p>volatile是不错的机制，但是volatile不能保证原子性。因此对于同步最终还是要回到锁机制上来。</p>
<p>独占锁是一种悲观锁，synchronized就是一种独占锁，会导致其它所有需要锁的线程挂起，等待持有锁的线程释放锁。而另一个更加有效的锁就是乐观锁。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。</p>
<p><strong>CAS 操作</strong></p>
<p>上面的乐观锁用到的机制就是CAS，Compare and Swap。</p>
<p>CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。</p>
<p><strong>非阻塞算法 （nonblocking algorithms）</strong>
一个线程的失败或者挂起不应该影响其他线程的失败或挂起的算法。</p>
<p>现代的CPU提供了特殊的指令，可以自动更新共享数据，而且能够检测到其他线程的干扰，而 compareAndSet() 就用这些代替了锁定。</p>
<p>拿出AtomicInteger来研究在没有锁的情况下是如何做到数据正确性的。
private volatile int value;</p>
<p>首先毫无以为，在没有锁的机制下可能需要借助volatile原语，保证线程间的数据是可见的（共享的）。</p>
<p>这样才获取变量的值的时候才能直接读取。
public final int get() {
        return value;
    }</p>
<p>然后来看看++i是怎么做到的。</p>
<p>public final int incrementAndGet() {
    for (;;) {
        int current = get();
        int next = current + 1;
        if (compareAndSet(current, next))
            return next;
    }
}</p>
<p>在这里采用了CAS操作，每次从内存中读取数据然后将此数据和+1后的结果进行CAS操作，如果成功就返回结果，否则重试直到成功为止。</p>
<p>而compareAndSet利用JNI来完成CPU指令的操作。
public final boolean compareAndSet(int expect, int update) {<br>    return unsafe.compareAndSwapInt(this, valueOffset, expect, update);
    }</p>
<p>整体的过程就是这样子的，利用CPU的CAS指令，同时借助JNI来完成Java的非阻塞算法。其它原子操作都是利用类似的特性完成的。</p>
<p>而整个J.U.C都是建立在CAS之上的，因此对于synchronized阻塞算法，J.U.C在性能上有了很大的提升。参考资料的文章中介绍了如果利用CAS构建非阻塞计数器、队列等数据结构。</p>
<p>CAS看起来很爽，但是会导致“ABA问题”。</p>
<p>CAS算法实现一个重要前提需要取出内存中某时刻的数据，而在下时刻比较并替换，那么在这个时间差类会导致数据的变化。</p>
<p>比如说一个线程one从内存位置V中取出A，这时候另一个线程two也从内存中取出A，并且two进行了一些操作变成了B，然后two又将V位置的数据变成A，这时候线程one进行CAS操作发现内存中仍然是A，然后one操作成功。尽管线程one的CAS操作成功，但是不代表这个过程就是没有问题的。如果链表的头在变化了两次后恢复了原值，但是不代表链表就没有变化。因此前面提到的原子操作AtomicStampedReference/AtomicMarkableReference就很有用了。这允许一对变化的元素进行原子操作。</p>
<p>参考资料：</p>
<p>（1）<a href="http://www.ibm.com/developerworks/cn/java/j-jtp04186/" target="_blank">非阻塞算法简介</a></p>
<p>（2）<a href="https://www.ibm.com/developerworks/cn/java/j-jtp11234/" target="_blank">流行的原子</a>
来源： <a href="[http://www.blogjava.net/xylz/archive/2010/07/04/325206.html](http://www.blogjava.net/xylz/archive/2010/07/04/325206.html)">[http://www.blogjava.net/xylz/archive/2010/07/04/325206.html](http://www.blogjava.net/xylz/archive/2010/07/04/325206.html)</a> </p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/Java_多线程/">Java_多线程</a></li><li><a href="/categories/Java&J2EE/Java_多线程/并发/">并发</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/Java_多线程/" class="label label-success">Java_多线程</a><a href="/tags/并发/" class="label label-info">并发</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:41"datetime="2014-03-07 09:54:41"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-Java_多线程-并发--深入浅出JavaConcurrency2-原子操作/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-Java_多线程-并发--深入浅出JavaConcurrency2-原子操作" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_多线程-并发--Java并发编程之ConcurrentHashMap/">Java并发编程之ConcurrentHashMap</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:41.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_多线程-并发--Java并发编程之ConcurrentHashMap/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="java-concurrenthashmap">Java并发编程之ConcurrentHashMap</h1>
<h3 id="concurrenthashmap">ConcurrentHashMap</h3>
<p>ConcurrentHashMap是一个线程安全的Hash Table，它的主要功能是提供了一组和HashTable功能相同但是线程安全的方法。ConcurrentHashMap可以做到读取数据不加锁，并且其内部的结构可以让其在进行写操作的时候能够将锁的粒度保持地尽量地小，不用对整个ConcurrentHashMap加锁。</p>
<h3 id="concurrenthashmap-">ConcurrentHashMap的内部结构</h3>
<p>ConcurrentHashMap为了提高本身的并发能力，在内部采用了一个叫做Segment的结构，一个Segment其实就是一个类Hash Table的结构，Segment内部维护了一个链表数组，我们用下面这一幅图来看下ConcurrentHashMap的内部结构：
<a href="http://www.yupoo.com/photos/goldendoc/81556254/" title="图表1" target="_blank"><img src="" alt="图表1"></a>
从上面的结构我们可以了解到，ConcurrentHashMap定位一个元素的过程需要进行两次Hash操作，第一次Hash定位到Segment，第二次Hash定位到元素所在的链表的头部，因此，这一种结构的带来的副作用是Hash的过程要比普通的HashMap要长，但是带来的好处是写操作的时候可以只对元素所在的Segment进行加锁即可，不会影响到其他的Segment，这样，在最理想的情况下，ConcurrentHashMap可以最高同时支持Segment数量大小的写操作（刚好这些写操作都非常平均地分布在所有的Segment上），所以，通过这一种结构，ConcurrentHashMap的并发能力可以大大的提高。</p>
<h3 id="segment">Segment</h3>
<p>我们再来具体了解一下Segment的数据结构：
1</p>
<p>2
3</p>
<p>4
5</p>
<p>6
7 static</p>
<p>final</p>
<p>class</p>
<p>Segment<K,V></p>
<p>extends</p>
<p>ReentrantLock</p>
<p>implements</p>
<p>Serializable {</p>
<p>transient</p>
<p>volatile</p>
<p>int</p>
<p>count;</p>
<p>transient</p>
<p>int</p>
<p>modCount;</p>
<p>transient</p>
<p>int</p>
<p>threshold;</p>
<p>transient</p>
<p>volatile</p>
<p>HashEntry<K,V>[] table;</p>
<p>final</p>
<p>float</p>
<p>loadFactor;
}</p>
<p>详细解释一下Segment里面的成员变量的意义：</p>
<ul>
<li>count：Segment中元素的数量</li>
<li>modCount：对table的大小造成影响的操作的数量（比如put或者remove操作）</li>
<li>threshold：阈值，Segment里面元素的数量超过这个值依旧就会对Segment进行扩容</li>
<li>table：链表数组，数组中的每一个元素代表了一个链表的头部</li>
<li>loadFactor：负载因子，用于确定threshold</li>
</ul>
<h3 id="hashentry">HashEntry</h3>
<p>Segment中的元素是以HashEntry的形式存放在链表数组中的，看一下HashEntry的结构：
1</p>
<p>2
3</p>
<p>4
5</p>
<p>6
 static</p>
<p>final</p>
<p>class</p>
<p>HashEntry<K,V> {</p>
<p>final</p>
<p>K key;</p>
<p>final</p>
<p>int</p>
<p>hash;</p>
<p>volatile</p>
<p>V value;</p>
<p>final</p>
<p>HashEntry<K,V> next;</p>
<p>}</p>
<p>可以看到HashEntry的一个特点，除了value以外，其他的几个变量都是final的，这样做是为了防止链表结构被破坏，出现ConcurrentModification的情况。</p>
<h3 id="concurrenthashmap-">ConcurrentHashMap的初始化</h3>
<p>下面我们来结合源代码来具体分析一下ConcurrentHashMap的实现，先看下初始化方法：
1</p>
<p>2
3</p>
<p>4
5</p>
<p>6
7</p>
<p>8
9</p>
<p>10
11</p>
<p>12
13</p>
<p>14
15</p>
<p>16
17</p>
<p>18
19</p>
<p>20
21</p>
<p>22
23</p>
<p>24
25</p>
<p>26
27</p>
<p>28
29</p>
<p>30
31 public</p>
<p>ConcurrentHashMap(</p>
<p>int</p>
<p>initialCapacity,</p>
<p>float</p>
<p>loadFactor,</p>
<p>int</p>
<p>concurrencyLevel) {</p>
<p>if</p>
<p>(!(loadFactor &gt;</p>
<p>0</p>
<p>) || initialCapacity &lt;</p>
<p>0</p>
<p>|| concurrencyLevel &lt;=</p>
<p>0</p>
<p>)</p>
<p>throw</p>
<p>new</p>
<p>IllegalArgumentException();</p>
<p>if</p>
<p>(concurrencyLevel &gt; MAX_SEGMENTS)</p>
<p>concurrencyLevel = MAX_SEGMENTS;</p>
<p>int</p>
<p>sshift =</p>
<p>0</p>
<p>;</p>
<p>int</p>
<p>ssize =</p>
<p>1</p>
<p>;</p>
<p>while</p>
<p>(ssize &lt; concurrencyLevel) {</p>
<p>++sshift;</p>
<p>ssize &lt;&lt;=</p>
<p>1</p>
<p>;</p>
<p>}</p>
<p>segmentShift =</p>
<p>32</p>
<ul>
<li>sshift;</li>
</ul>
<p>segmentMask = ssize -</p>
<p>1</p>
<p>;</p>
<p>this</p>
<p>.segments = Segment.newArray(ssize);</p>
<p>if</p>
<p>(initialCapacity &gt; MAXIMUM_CAPACITY)</p>
<p>initialCapacity = MAXIMUM_CAPACITY;</p>
<p>int</p>
<p>c = initialCapacity / ssize;</p>
<p>if</p>
<p>(c /* ssize &lt; initialCapacity)</p>
<p>++c;</p>
<p>int</p>
<p>cap =</p>
<p>1</p>
<p>;</p>
<p>while</p>
<p>(cap &lt; c)</p>
<p>cap &lt;&lt;=</p>
<p>1</p>
<p>;</p>
<p>for</p>
<p>(</p>
<p>int</p>
<p>i =</p>
<p>0</p>
<p>; i &lt;</p>
<p>this</p>
<p>.segments.length; ++i)</p>
<p>this</p>
<p>.segments[i] =</p>
<p>new</p>
<p>Segment<K,V>(cap, loadFactor);
}</p>
<p>CurrentHashMap的初始化一共有三个参数，一个initialCapacity，表示初始的容量，一个loadFactor，表示负载参数，最后一个是concurrentLevel，代表ConcurrentHashMap内部的Segment的数量，ConcurrentLevel一经指定，不可改变，后续如果ConcurrentHashMap的元素数量增加导致ConrruentHashMap需要扩容，ConcurrentHashMap不会增加Segment的数量，而只会增加Segment中链表数组的容量大小，这样的好处是扩容过程不需要对整个ConcurrentHashMap做rehash，而只需要对Segment里面的元素做一次rehash就可以了。</p>
<p>整个ConcurrentHashMap的初始化方法还是非常简单的，先是根据concurrentLevel来new出Segment，这里Segment的数量是不小于concurrentLevel的最大的2的指数，就是说Segment的数量永远是2的指数个，这样的好处是方便采用移位操作来进行hash，加快hash的过程。接下来就是根据intialCapacity确定Segment的容量的大小，每一个Segment的容量大小也是2的指数，同样使为了加快hash的过程。</p>
<p>这边需要特别注意一下两个变量，分别是segmentShift和segmentMask，这两个变量在后面将会起到很大的作用，假设构造函数确定了Segment的数量是2的n次方，那么segmentShift就等于32减去n，而segmentMask就等于2的n次方减一。</p>
<h3 id="concurrenthashmap-get-">ConcurrentHashMap的get操作</h3>
<p>前面提到过ConcurrentHashMap的get操作是不用加锁的，我们这里看一下其实现：
1</p>
<p>2
3</p>
<p>4
 public</p>
<p>V get(Object key) {</p>
<p>int</p>
<p>hash = hash(key.hashCode());</p>
<p>return</p>
<p>segmentFor(hash).get(key, hash);</p>
<p>}</p>
<p>看第三行，segmentFor这个函数用于确定操作应该在哪一个segment中进行，几乎对ConcurrentHashMap的所有操作都需要用到这个函数，我们看下这个函数的实现：</p>
<p>1</p>
<p>2
3 final</p>
<p>Segment<K,V> segmentFor(</p>
<p>int</p>
<p>hash) {</p>
<p>return</p>
<p>segments[(hash &gt;&gt;&gt; segmentShift) &amp; segmentMask];
}</p>
<p>这个函数用了位操作来确定Segment，根据传入的hash值向右无符号右移segmentShift位，然后和segmentMask进行与操作，结合我们之前说的segmentShift和segmentMask的值，就可以得出以下结论：假设Segment的数量是2的n次方，根据元素的hash值的高n位就可以确定元素到底在哪一个Segment中。</p>
<p>在确定了需要在哪一个segment中进行操作以后，接下来的事情就是调用对应的Segment的get方法：
1</p>
<p>2
3</p>
<p>4
5</p>
<p>6
7</p>
<p>8
9</p>
<p>10
11</p>
<p>12
13</p>
<p>14
15 V get(Object key,</p>
<p>int</p>
<p>hash) {</p>
<p>if</p>
<p>(count !=</p>
<p>0</p>
<p>) {</p>
<p>HashEntry<K,V> e = getFirst(hash);</p>
<p>while</p>
<p>(e !=</p>
<p>null</p>
<p>) {</p>
<p>if</p>
<p>(e.hash == hash &amp;&amp; key.equals(e.key)) {</p>
<p>V v = e.value;</p>
<p>if</p>
<p>(v !=</p>
<p>null</p>
<p>)</p>
<p>return</p>
<p>v;</p>
<p>return</p>
<p>readValueUnderLock(e);</p>
<p>}</p>
<p>e = e.next;</p>
<p>}</p>
<p>}</p>
<p>return</p>
<p>null</p>
<p>;
}</p>
<p>先看第二行代码，这里对count进行了一次判断，其中count表示Segment中元素的数量，我们可以来看一下count的定义：</p>
<p>1 transient</p>
<p>volatile</p>
<p>int</p>
<p>count;</p>
<p>可以看到count是volatile的，实际上这里里面利用了volatile的语义：</p>
<p>对volatile字段的写入操作happens-before于每一个后续的同一个字段的读操作。</p>
<p>因为实际上put、remove等操作也会更新count的值，所以当竞争发生的时候，volatile的语义可以保证写操作在读操作之前，也就保证了写操作对后续的读操作都是可见的，这样后面get的后续操作就可以拿到完整的元素内容。</p>
<p>然后，在第三行，调用了getFirst()来取得链表的头部：
1</p>
<p>2
3</p>
<p>4
 HashEntry<K,V> getFirst(</p>
<p>int</p>
<p>hash) {</p>
<p>HashEntry<K,V>[] tab = table;</p>
<p>return</p>
<p>tab[hash &amp; (tab.length -</p>
<p>1</p>
<p>)];</p>
<p>}</p>
<p>同样，这里也是用位操作来确定链表的头部，hash值和HashTable的长度减一做与操作，最后的结果就是hash值的低n位，其中n是HashTable的长度以2为底的结果。</p>
<p>在确定了链表的头部以后，就可以对整个链表进行遍历，看第4行，取出key对应的value的值，如果拿出的value的值是null，则可能这个key，value对正在put的过程中，如果出现这种情况，那么就加锁来保证取出的value是完整的，如果不是null，则直接返回value。</p>
<h3 id="concurrenthashmap-put-">ConcurrentHashMap的put操作</h3>
<p>看完了get操作，再看下put操作，put操作的前面也是确定Segment的过程，这里不再赘述，直接看关键的segment的put方法：
1</p>
<p>2
3</p>
<p>4
5</p>
<p>6
7</p>
<p>8
9</p>
<p>10
11</p>
<p>12
13</p>
<p>14
15</p>
<p>16
17</p>
<p>18
19</p>
<p>20
21</p>
<p>22
23</p>
<p>24
25</p>
<p>26
27</p>
<p>28
29</p>
<p>30
 V put(K key,</p>
<p>int</p>
<p>hash, V value,</p>
<p>boolean</p>
<p>onlyIfAbsent) {</p>
<p>lock();</p>
<p>try</p>
<p>{</p>
<p>int</p>
<p>c = count;</p>
<p>if</p>
<p>(c++ &gt; threshold)</p>
<p>rehash();</p>
<p>HashEntry<K,V>[] tab = table;</p>
<p>int</p>
<p>index = hash &amp; (tab.length -</p>
<p>1</p>
<p>);</p>
<p>HashEntry<K,V> first = tab[index];</p>
<p>HashEntry<K,V> e = first;</p>
<p>while</p>
<p>(e !=</p>
<p>null</p>
<p>&amp;&amp; (e.hash != hash || !key.equals(e.key)))</p>
<p>e = e.next;</p>
<p>V oldValue;</p>
<p>if</p>
<p>(e !=</p>
<p>null</p>
<p>) {</p>
<p>oldValue = e.value;</p>
<p>if</p>
<p>(!onlyIfAbsent)</p>
<p>e.value = value;</p>
<p>}</p>
<p>else</p>
<p>{</p>
<p>oldValue =</p>
<p>null</p>
<p>;</p>
<p>++modCount;</p>
<p>tab[index] =</p>
<p>new</p>
<p>HashEntry<K,V>(key, hash, first, value);</p>
<p>count = c;</p>
<p>}</p>
<p>return</p>
<p>oldValue;</p>
<p>}</p>
<p>finally</p>
<p>{</p>
<p>unlock();</p>
<p>}</p>
<p>}</p>
<p>首先对Segment的put操作是加锁完成的，然后在第五行，如果Segment中元素的数量超过了阈值（由构造函数中的loadFactor算出）这需要进行对Segment扩容，并且要进行rehash，关于rehash的过程大家可以自己去了解，这里不详细讲了。</p>
<p>第8和第9行的操作就是getFirst的过程，确定链表头部的位置。</p>
<p>第11行这里的这个while循环是在链表中寻找和要put的元素相同key的元素，如果找到，就直接更新更新key的value，如果没有找到，则进入21行这里，生成一个新的HashEntry并且把它加到整个Segment的头部，然后再更新count的值。</p>
<h3 id="concurrenthashmap-remove-">ConcurrentHashMap的remove操作</h3>
<p>Remove操作的前面一部分和前面的get和put操作一样，都是定位Segment的过程，然后再调用Segment的remove方法：
1</p>
<p>2
3</p>
<p>4
5</p>
<p>6
7</p>
<p>8
9</p>
<p>10
11</p>
<p>12
13</p>
<p>14
15</p>
<p>16
17</p>
<p>18
19</p>
<p>20
21</p>
<p>22
23</p>
<p>24
25</p>
<p>26
27</p>
<p>28
29</p>
<p>30
31</p>
<p>32
33 V remove(Object key,</p>
<p>int</p>
<p>hash, Object value) {</p>
<p>lock();</p>
<p>try</p>
<p>{</p>
<p>int</p>
<p>c = count -</p>
<p>1</p>
<p>;</p>
<p>HashEntry<K,V>[] tab = table;</p>
<p>int</p>
<p>index = hash &amp; (tab.length -</p>
<p>1</p>
<p>);</p>
<p>HashEntry<K,V> first = tab[index];</p>
<p>HashEntry<K,V> e = first;</p>
<p>while</p>
<p>(e !=</p>
<p>null</p>
<p>&amp;&amp; (e.hash != hash || !key.equals(e.key)))</p>
<p>e = e.next;</p>
<p>V oldValue =</p>
<p>null</p>
<p>;</p>
<p>if</p>
<p>(e !=</p>
<p>null</p>
<p>) {</p>
<p>V v = e.value;</p>
<p>if</p>
<p>(value ==</p>
<p>null</p>
<p>|| value.equals(v)) {</p>
<p>oldValue = v;</p>
<p>++modCount;</p>
<p>HashEntry<K,V> newFirst = e.next;</p>
<p>for</p>
<p>(HashEntry<K,V> p = first; p != e; p = p.next)</p>
<p>newFirst =</p>
<p>new</p>
<p>HashEntry<K,V>(p.key, p.hash,</p>
<p>newFirst, p.value);</p>
<p>tab[index] = newFirst;</p>
<p>count = c;</p>
<p>}</p>
<p>}</p>
<p>return</p>
<p>oldValue;</p>
<p>}</p>
<p>finally</p>
<p>{</p>
<p>unlock();</p>
<p>}
}</p>
<p>首先remove操作也是确定需要删除的元素的位置，不过这里删除元素的方法不是简单地把待删除元素的前面的一个元素的next指向后面一个就完事了，我们之前已经说过HashEntry中的next是final的，一经赋值以后就不可修改，在定位到待删除元素的位置以后，程序就将待删除元素前面的那一些元素全部复制一遍，然后再一个一个重新接到链表上去，看一下下面这一幅图来了解这个过程：
<a href="http://www.yupoo.com/photos/goldendoc/81555357/" title="1" target="_blank"><img src="" alt="1"></a>
假设链表中原来的元素如上图所示，现在要删除元素3，那么删除元素3以后的链表就如下图所示：
<a href="http://www.yupoo.com/photos/goldendoc/81555358/" title="2" target="_blank"><img src="" alt="2"></a></p>
<h3 id="concurrenthashmap-size-">ConcurrentHashMap的size操作</h3>
<p>在前面的章节中，我们涉及到的操作都是在单个Segment中进行的，但是ConcurrentHashMap有一些操作是在多个Segment中进行，比如size操作，ConcurrentHashMap的size操作也采用了一种比较巧的方式，来尽量避免对所有的Segment都加锁。</p>
<p>前面我们提到了一个Segment中的有一个modCount变量，代表的是对Segment中元素的数量造成影响的操作的次数，这个值只增不减，size操作就是遍历了两次Segment，每次记录Segment的modCount值，然后将两次的modCount进行比较，如果相同，则表示期间没有发生过写入操作，就将原先遍历的结果返回，如果不相同，则把这个过程再重复做一次，如果再不相同，则就需要将所有的Segment都锁住，然后一个一个遍历了，具体的实现大家可以看ConcurrentHashMap的源码，这里就不贴了。
来源： <a href="[http://www.goldendoc.org/2011/06/juc_concurrenthashmap/](http://www.goldendoc.org/2011/06/juc_concurrenthashmap/)">[http://www.goldendoc.org/2011/06/juc_concurrenthashmap/](http://www.goldendoc.org/2011/06/juc_concurrenthashmap/)</a> </p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/Java_多线程/">Java_多线程</a></li><li><a href="/categories/Java&J2EE/Java_多线程/并发/">并发</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/Java_多线程/" class="label label-success">Java_多线程</a><a href="/tags/并发/" class="label label-info">并发</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:41"datetime="2014-03-07 09:54:41"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-Java_多线程-并发--Java并发编程之ConcurrentHashMap/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-Java_多线程-并发--Java并发编程之ConcurrentHashMap" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_多线程--多线程讲解/">多线程讲解</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:41.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_多线程--多线程讲解/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-">多线程讲解</h1>
<p>多线程是java应用程序的一个特点，掌握java的多线程也是作为一java程序员必备的知识。多线程指的是在单个程序中可以同时运行多个同的线程执行不同的任务.线程是程序内的顺序控制流，只能使用分配给序的资源和环境。还记得刚开始学习的时候总是和进程分不清，总是对这两个名词所迷惑。</p>
<p>下面就首先对这两个名词区分来作为本篇博客的开始：</p>
<p><strong>    一、线程与进程的区别</strong></p>
<p>多个进程的内部数据和状态都是完全独立的,而多线程是共享一块内存空间和一组系统资源,有可能互相影响. •线程本身的数据通常只有寄存器数据，以及一个程序执行时使用的堆栈，所以线程的切换比进程切换的负担要小。</p>
<p> 多线程编程的目的，就是&quot;最大限度地利用CPU资源&quot;，当某一线程的处理不需要占用CPU而只和I/O等资源打交道时，让需要占用CPU资源的其它线程有机会获得CPU资源。从根本上说，这就是多线程编程的最终目的。</p>
<p>二、了解一下java在多线程中的基础知识</p>
<p>1.Java中如果我们自己没有产生线程，那么系统就会给我们产生一个线程（主线程，main方法就在主线程上运行），我们的程序都是由线程来执行的。</p>
<ol>
<li>进程：执行中的程序（程序是静态的概念，进程是动态的概念）。 </li>
</ol>
<ol>
<li><p>线程的实现有两种方式，<strong>第一种方式是继承Thread类，然后重写run方法；第二种是实现Runnable接口，然后实现其run方法。 </strong></p>
</li>
<li><p>将我们希望线程执行的代码放到run方法中，然后通过start方法来启动线程，<strong>start方法首先为线程的执行准备好系统资源，然后再去调用run方法。</strong>当某个类继承了Thread类之后，该类就叫做一个线程类。 </p>
</li>
<li><p>一个进程至少要包含一个线程。 </p>
</li>
<li><p>对于单核CPU来说，某一时刻只能有一个线程在执行（微观串行），从宏观角度来看，多个线程在同时执行（宏观并行）。 </p>
</li>
<li><p>对于双核或双核以上的CPU来说，可以真正做到微观并行。</p>
</li>
</ol>
<p>三、Thread源码研究： </p>
<p>1) Thread类也实现了Runnable接口，因此实现了Runnable接口中的run方法； </p>
<p>2) 当生成一个线程对象时，如果没有为其设定名字，那么线程对象的名字将使用如下形式：Thread-number,该number将是自动增加的，并被所有的Thread对象所共享（因为它是static的成员变量）。 </p>
<p>3) 当使用第一种方式来生成线程对象时，我们需要重写run方法，因为Thread类的run方法此时什么事情也不做。</p>
<p>4）当使用第二种方式生成线程对象时，我们需要实现Runnable接口的run方法，然后使用new Thread（new MyThread（））（假如MyThread已经实现了Runnable接口）来生成线程对象，这时的线程对象的run方法或调就会MyThread类的run方法，这样我们自己编写的run方法就执行了。</p>
<p>说明： </p>
<p>Public void run(){</p>
<p>If(target!=null){</p>
<p>Target.run();</p>
<p>}}</p>
<p>当使用继承Thread生成线程对象时，target为空，什么也不执行，当使用第二种方式生成时，执行target.run（），target为runnable的实例对象，即为执行重写后的方法</p>
<p>总结：两种生成线程对象的区别：</p>
<p>1.两种方法均需执行线程的start方法为线程分配必须的系统资源、调度线程运行并执行线程的run方法。 </p>
<p>2.在具体应用中，采用哪种方法来构造线程体要视情况而定。通常，当一个线程已继承了另一个类时，就应该用第二种方法来构造，即实现Runnable接口。 </p>
<p><strong>四：线程的生命周期：</strong></p>
<p><img src="" alt=""></p>
<p>由上图可以看出，一个线程由出生到死亡分为五个阶段：</p>
<p><strong>1）.创建状态 </strong></p>
<p>•当用new操作符创建一个新的线程对象时，该线程处于创建状态。 </p>
<p>•处于创建状态的线程只是一个空的线程对象，系统不为它分配资源 </p>
<p><strong>2）. 可运行状态 </strong></p>
<p>•执行线程的start()方法将为线程分配必须的系统资源，安排其运行，并调用线程体—run()方法，这样就使得该线程处于可运行( Runnable )状态。 </p>
<p>•这一状态并不是运行中状态（Running )，因为线程也许实际上并未真正运行。 </p>
<p><strong>3）.不可运行状态 </strong></p>
<p>.当发生下列事件时，处于运行状态的线程会转入到不可运行状态。 </p>
<p>调用了sleep（）方法； </p>
<p>•线程调用wait方法等待特定条件的满足 </p>
<p>•线程输入/输出阻塞 </p>
<p><strong>4）返回可运行状态： </strong></p>
<p>•处于睡眠状态的线程在指定的时间过去后 </p>
<p>•如果线程在等待某一条件，另一个对象必须通过notify()或notifyAll()方法通知等待线程条件的改变 </p>
<p>•如果线程是因为输入/输出阻塞，等待输入/输出完成 </p>
<p><strong>5）. 消亡状态 </strong></p>
<p>当线程的run方法执行结束后，该线程自然消亡。 </p>
<p>注意：</p>
<p>1.停止线程的方式：不能使用Thread类的stop方法来终止线程的执行。一般要设定一个变量，在run方法中是一个循环，循环每次检查该变量，如果满足条件则继续执行，否则跳出循环，线程结束。 </p>
<p>2.不能依靠线程的优先级来决定线程的执行顺序。 </p>
<p><strong>五：多线程并发</strong></p>
<p>多线程并发是线程同步中比较常见的现象，java多线程为了避免多线程并发解决多线程共享数据同步问题提供了<strong>synchronized关键字</strong></p>
<p>synchronized关键字：当synchronized关键字修饰一个方法的时候，该方法叫做同步方法。 </p>
<p>1.Java中的每个对象都有一个锁（lock）或者叫做监视器（monitor），当访问某个对象的synchronized方法时，表示将该对象上锁，此时其他任何线程都无法再去访问该synchronized方法了，直到之前的那个线程执行方法完毕后（或者是抛出了异常），那么将该对象的锁释放掉，其他线程才有可能再去访问该synchronized方法。 </p>
<ol>
<li>如果一个对象有多个synchronized方法，某一时刻某个线程已经进入到了某个synchronized方法，那么在该方法没有执行完毕前，其他线程是无法访问该对象的任何synchronized方法的。 </li>
</ol>
<p>3.如果某个synchronized方法是static的，那么当线程访问该方法时，它锁的并不是synchronized方法所在的对象，而是synchronized方法所在的对象所对应的Class对象，因为Java中无论一个类有多少个对象，这些对象会对应唯一一个Class对象，因此当线程分别访问同一个类的两个对象的两个static，synchronized方法时，他们的执行顺序也是顺序的，也就是说一个线程先去执行方法，执行完毕后另一个线程才开始执行。 </p>
<ol>
<li>synchronized块，写法： </li>
</ol>
<p>synchronized(object) </p>
<p>{ </p>
<p>} </p>
<p>表示线程在执行的时候会对object对象上锁。 </p>
<p>5.synchronized方法是一种粗粒度的并发控制，某一时刻，只能有一个线程执行该synchronized方法;synchronized块则是一种细粒度的并发控制，只会将块中的代码同步，位于方法内、synchronized块之外的代码是可以被多个线程同时访问到的。 </p>
<p>同步的线程状态图：</p>
<p><img src="" alt=""></p>
<p><strong>六：wait与notify</strong></p>
<p>1.wait与notify方法都是定义在Object类中，而且是final的，因此会被所有的Java类所继承并且无法重写。这两个方法要求在调用时线程应该已经获得了对象的锁，因此对这两个方法的调用需要放在synchronized方法或块当中。当线程执行了wait方法时，它会释放掉对象的锁。 </p>
<ol>
<li>另一个会导致线程暂停的方法就是Thread类的sleep方法，它会导致线程睡眠指定的毫秒数，但线程在睡眠的过程中是不会释放掉对象的锁的。 </li>
</ol>
<p>3.notify():唤醒在此对象监视器上等待的单个线程。如果所有线程都在此对象上等待，则会选择唤醒其中一个线程。选择是任意性的，并在对实现做出决定时发生。线程通过调用其中一个 wait 方法，在对象的监视器上等待。 </p>
<p>直到当前线程放弃此对象上的锁定，才能继续执行被唤醒的线程。被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞争；例如，唤醒的线程在作为锁定此对象的下一个线程方面没有可靠的特权或劣势。</p>
<p>此方法只应由作为此对象监视器的所有者的线程来调用。通过以下三种方法之一，线程可以成为此对象监视器的所有者：</p>
<p>o 通过执行此对象的同步实例方法。</p>
<p>o 通过执行在此对象上进行同步的 synchronized 语句的正文。</p>
<p>o 对于 Class 类型的对象，可以通过执行该类的同步静态方法。</p>
<p>一次只能有一个线程拥有对象的监视器。</p>
<p><img src="" alt=""></p>
<p> <strong>关于成员变量与局部变量</strong>：如果一个变量是成员变量，那么多个线程对同一个对象的成员变量进行操作时，他们对该成员变量是彼此影响的（也就是说一个线程对成员变量的改变会影响到另一个线程）。  如果一个变量是局部变量，那么每个线程都会有一个该局部变量的拷贝，一个线程对该局部变量的改变不会影响到其他的线程。</p>
<p><strong>七：死锁的问题： </strong></p>
<p>定义：线程1锁住了对象A的监视器，等待对象B的监视器，线程2锁住了对象B的监视器，等待对象A的监视器，就造成了死锁。</p>
<pre><code> 导致死锁的根源在于不适当地运用“synchronized”关键词来管理线程对特定对象的访问。“synchronized”关键词的作用是，确保在某个时刻只有一个线程被允许执行特定的代码块，因此，被允许执行的线程首先必须拥有对变量或对象的排他性访问权。当线程访问对象时，线程会给对象加锁
</code></pre><p>Java中每个对象都有一把锁与之对应。但Java不提供单独的lock和unlock操作。下面笔者分析死锁的两个过程“上锁”和“锁死” 。</p>
<p>(1) 上锁
     许多线程在执行中必须考虑与其他线程之间共享数据或协调执行状态，就需要同步机制。因此大多数应用程序要求线程互相通信来同步它们的动作，在 Java 程序中最简单实现同步的方法就是上锁。在 Java 编程中，所有的对象都有锁。线程可以使用 synchronized 关键字来获得锁。在任一时刻对于给定的类的实例，方法或同步的代码块只能被一个线程执行。这是因为代码在执行之前要求获得对象的锁。</p>
<pre><code>为了防止同时访问共享资源，线程在使用资源的前后可以给该资源上锁和开锁。给共享变量上锁就使得 Java 线程能够快速方便地通信和同步。某个线程若给一个对象上了锁，就可以知道没有其他线程能够访问该对象。即使在抢占式模型中，其他线程也不能够访问此对象，直到上锁的线程被唤醒、完成工作并开锁。那些试图访问一个上锁对象的线程通常会进入睡眠状态，直到上锁的线程开锁。一旦锁被打开，这些睡眠进程就会被唤醒并移到准备就绪队列中。
</code></pre><p>(2)锁死
     如果程序中有几个竞争资源的并发线程,那么保证均衡是很重要的。系统均衡是指每个线程在执行过程中都能充分访问有限的资源，系统中没有饿死和死锁的线程。当多个并发的线程分别试图同时占有两个锁时，会出现加锁冲突的情形。如果一个线程占有了另一个线程必需的锁，互相等待时被阻塞就有可能出现死锁。</p>
<pre><code>在编写多线程代码时，笔者认为死锁是最难处理的问题之一。因为死锁可能在最意想不到的地方发生，所以查找和修正它既费时又费力。例如，常见的例子如下面这段程序。[print](http://write.blog.csdn.net/postedit#)[?](http://write.blog.csdn.net/postedit#)
</code></pre><p>1 public int sumArrays(int[] a1, int[] a2){  </p>
<p>2   int value = 0;  </p>
<p>3   int size = a1.length;  </p>
<p>4   if (size == a2.length) {  </p>
<p>5      synchronized(a1) { //1        </p>
<p>6        synchronized(a2) { //2          </p>
<p>7          for (int i=0; i&lt;size; i++)  </p>
<p>8             value += a1[i] + a2[i];  </p>
<p>9        }    </p>
<p>10      }    </p>
<p>11   } return value;  </p>
<p>12 }   </p>
<p>这段代码在求和操作中访问两个数组对象之前锁定了这两个数组对象。它形式简短，编写也适合所要执行的任务；但不幸的是，它有一个潜在的问题。这个问题就是它埋下了死锁的种子。</p>
<p><strong>ThreadLocal类（这个类本人没用过，暂时不太懂）</strong></p>
<p>首先，ThreadLocal 不是用来解决共享对象的多线程访问问题的，一般情况下，通过ThreadLocal.set() 到线程中的对象是该线程自己使用的对象，其他线程是不需要访问的，也访问不到的。各个线程中访问的是不同的对象。
另外，说ThreadLocal使得各线程能够保持各自独立的一个对象，并不是通过ThreadLocal.set()来实现的，而是通过每个线程中的new 对象 的操作来创建的对象，每个线程创建一个，不是什么对象的拷贝或副本。通过ThreadLocal.set()将这个新创建的对象的引用保存到各线程的自己的一个map中，每个线程都有这样一个map，执行ThreadLocal.get()时，各线程从自己的map中取出放进去的对象，因此取出来的是各自自己线程中的对象，ThreadLocal实例是作为map的key来使用的。
如果ThreadLocal.set()进去的东西本来就是多个线程共享的同一个对象，那么多个线程的ThreadLocal.get()取得的还是这个共享对象本身，还是有并发访问问题。</p>
<p><strong> 本文来自：曹胜欢博客专栏。转载请注明出处：<a href="http://blog.csdn.net/csh624366188" target="_blank"><a href="http://blog.csdn.net/csh624366188">http://blog.csdn.net/csh624366188</a></a></strong></p>
<p>来源： <a href="[http://blog.csdn.net/csh624366188/article/details/7318245](http://blog.csdn.net/csh624366188/article/details/7318245)">[http://blog.csdn.net/csh624366188/article/details/7318245](http://blog.csdn.net/csh624366188/article/details/7318245)</a> </p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/Java_多线程/">Java_多线程</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/Java_多线程/" class="label label-success">Java_多线程</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:41"datetime="2014-03-07 09:54:41"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-Java_多线程--多线程讲解/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-Java_多线程--多线程讲解" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_多线程-并发--java多线程学习-javautilconcurrent详解/">java多线程学习</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:41.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_多线程-并发--java多线程学习-javautilconcurrent详解/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="java-java-util-concurrent-">java多线程学习-java.util.concurrent详解</h1>
<h3 id="-latch-barrier-http-janeky-iteye-com-blog-769965-"><a href="http://janeky.iteye.com/blog/769965" target="_blank">Latch/Barrier</a></h3>
<p>   Java1.5提供了一个非常高效实用的多线程包：java.util.concurrent, 提供了大量高级工具，可以帮助开发者编写高效、易维护、结构清晰的Java多线程程序。从这篇blog起，我将跟大家一起共同学习这些新的Java多线程构件 </p>
<ol>
<li><p>CountDownLatch 
 我们先来学习一下JDK1.5 API中关于这个类的详细介绍： 
“一个同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待。 用给定的计数 初始化 CountDownLatch。由于调用了 countDown() 方法，所以在当前计数到达零之前，await 方法会一直受阻塞。之后，会释放所有等待的线程，await 的所有后续调用都将立即返回。这种现象只出现一次——计数无法被重置。如果需要重置计数，请考虑使用 CyclicBarrier。” 
 这就是说，CountDownLatch可以用来管理一组相关的线程执行，只需在主线程中调用CountDownLatch 的await方法（一直阻塞），让各个线程调用countDown方法。当所有的线程都只需完countDown了，await也顺利返回，不再阻塞了。在这样情况下尤其适用：将一个任务分成若干线程执行，等到所有线程执行完，再进行汇总处理。 
 下面我举一个非常简单的例子。假设我们要打印1-100，最后再输出“Ok“。1-100的打印顺序不要求统一，只需保证“Ok“是在最后出现即可。 
 解决方案：我们定义一个CountDownLatch，然后开10个线程分别打印（n-1）/<em>10+1至（n-1）/</em>10+10。主线程中调用await方法等待所有线程的执行完毕，每个线程执行完毕后都调用countDown方法。最后再await返回后打印“Ok”。 
具体代码如下（本代码参考了JDK示例代码）： 
Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"></a></p>
</li>
<li><p>import java.util.concurrent.CountDownLatch;  </p>
</li>
<li>//<em>/</em> </li>
<li>/* 示例：CountDownLatch的使用举例 </li>
<li>/* Mail: ken@iamcoding.com </li>
<li>/* @author janeky </li>
<li>/*/  </li>
<li>public class TestCountDownLatch {  </li>
<li>private static final int N = 10;  </li>
<li></li>
<li>public static void main(String[] args) throws InterruptedException {  </li>
<li>CountDownLatch doneSignal = new CountDownLatch(N);  </li>
<li>CountDownLatch startSignal = new CountDownLatch(1);//开始执行信号  </li>
<li></li>
<li>for (int i = 1; i &lt;= N; i++) {  </li>
<li>new Thread(new Worker(i, doneSignal, startSignal)).start();//线程启动了  </li>
<li>}  </li>
<li>System.out.println(&quot;begin------------&quot;);  </li>
<li>startSignal.countDown();//开始执行啦  </li>
<li>doneSignal.await();//等待所有的线程执行完毕  </li>
<li>System.out.println(&quot;Ok&quot;);  </li>
<li></li>
<li>}  </li>
<li></li>
<li>static class Worker implements Runnable {  </li>
<li>private final CountDownLatch doneSignal;  </li>
<li>private final CountDownLatch startSignal;  </li>
<li>private int beginIndex;  </li>
<li></li>
<li>Worker(int beginIndex, CountDownLatch doneSignal,  </li>
<li>CountDownLatch startSignal) {  </li>
<li>this.startSignal = startSignal;  </li>
<li>this.beginIndex = beginIndex;  </li>
<li>this.doneSignal = doneSignal;  </li>
<li>}  </li>
<li></li>
<li>public void run() {  </li>
<li>try {  </li>
<li>startSignal.await(); //等待开始执行信号的发布  </li>
<li>beginIndex = (beginIndex - 1) /* 10 + 1;  </li>
<li>for (int i = beginIndex; i &lt;= beginIndex + 10; i++) {  </li>
<li>System.out.println(i);  </li>
<li>}  </li>
<li>} catch (InterruptedException e) {  </li>
<li>e.printStackTrace();  </li>
<li>} finally {  </li>
<li>doneSignal.countDown();  </li>
<li>}  </li>
<li>}  </li>
<li>}  </li>
<li>}<br> 总结：CounDownLatch对于管理一组相关线程非常有用。上述示例代码中就形象地描述了两种使用情况。第一种是计算器为1，代表了两种状态，开关。第二种是计数器为N，代表等待N个操作完成。今后我们在编写多线程程序时，可以使用这个构件来管理一组独立线程的执行。 </li>
<li><p>CyclicBarrier 
 我们先来学习一下JDK1.5 API中关于这个类的详细介绍： 
 “一个同步辅助类，它允许一组线程互相等待，直到到达某个公共屏障点 (common barrier point)。在涉及一组固定大小的线程的程序中，这些线程必须不时地互相等待，此时 CyclicBarrier 很有用。因为该 barrier 在释放等待线程后可以重用，所以称它为循环 的 barrier。 
 CyclicBarrier 支持一个可选的 Runnable 命令，在一组线程中的最后一个线程到达之后（但在释放所有线程之前），该命令只在每个屏障点运行一次。若在继续所有参与线程之前更新共享状态，此屏障操作 很有用。 
 我们在学习CountDownLatch的时候就提到了CyclicBarrier。两者究竟有什么联系呢？引用[JCIP]中的描述“The key difference is that with a barrier, all the threads must come together at a barrier point at the same time in order to proceed. Latches are for waiting for events; barriers are for waiting for other threads。CyclicBarrier等待所有的线程一起完成后再执行某个动作。这个功能CountDownLatch也同样可以实现。但是CountDownLatch更多时候是在等待某个事件的发生。在CyclicBarrier中，所有的线程调用await方法，等待其他线程都执行完。 
 举一个很简单的例子，今天晚上我们哥们4个去Happy。就互相通知了一下：晚上八点准时到xx酒吧门前集合，不见不散！。有个哥们住的近，早早就到了。有的事务繁忙，刚好踩点到了。无论怎样，先来的都不能独自行动，只能等待所有人 
代码如下（参考了网上给的一些教程） 
Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"></a></p>
</li>
<li><p>import java.util.Random;  </p>
</li>
<li>import java.util.concurrent.BrokenBarrierException;  </li>
<li>import java.util.concurrent.CyclicBarrier;  </li>
<li>import java.util.concurrent.ExecutorService;  </li>
<li>import java.util.concurrent.Executors;  </li>
<li></li>
<li>public class TestCyclicBarrier {  </li>
<li></li>
<li>public static void main(String[] args) {  </li>
<li></li>
<li>ExecutorService exec = Executors.newCachedThreadPool();       </li>
<li>final Random random=new Random();  </li>
<li></li>
<li>final CyclicBarrier barrier=new CyclicBarrier(4,new Runnable(){  </li>
<li>@Override  </li>
<li>public void run() {  </li>
<li>System.out.println(&quot;大家都到齐了，开始happy去&quot;);  </li>
<li>}});  </li>
<li></li>
<li>for(int i=0;i&lt;4;i++){  </li>
<li>exec.execute(new Runnable(){  </li>
<li>@Override  </li>
<li>public void run() {  </li>
<li>try {  </li>
<li>Thread.sleep(random.nextInt(1000));  </li>
<li>} catch (InterruptedException e) {  </li>
<li>e.printStackTrace();  </li>
<li>}  </li>
<li>System.out.println(Thread.currentThread().getName()+&quot;到了，其他哥们呢&quot;);  </li>
<li>try {  </li>
<li>barrier.await();//等待其他哥们  </li>
<li>} catch (InterruptedException e) {  </li>
<li>e.printStackTrace();  </li>
<li>} catch (BrokenBarrierException e) {  </li>
<li>e.printStackTrace();  </li>
<li>}  </li>
<li>}});  </li>
<li>}  </li>
<li>exec.shutdown();  </li>
<li>}  </li>
<li></li>
<li><p>}<br> 关于await方法要特别注意一下，它有可能在阻塞的过程中由于某些原因被中断 
 总结：CyclicBarrier就是一个栅栏，等待所有线程到达后再执行相关的操作。barrier 在释放等待线程后可以重用。 </p>
</li>
<li><p>Semaphore 
 我们先来学习一下JDK1.5 API中关于这个类的详细介绍： 
“一个计数信号量。从概念上讲，信号量维护了一个许可集。如有必要，在许可可用前会阻塞每一个 acquire()，然后再获取该许可。每个 release() 添加一个许可，从而可能释放一个正在阻塞的获取者。但是，不使用实际的许可对象，Semaphore 只对可用许可的号码进行计数，并采取相应的行动。” 
 我们一般用它来控制某个对象的线程访问对象 
 例如，对于某个容器，我们规定，最多只能容纳n个线程同时操作 
使用信号量来模拟实现 
具体代码如下（参考 [JCIP]） 
Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"></a></p>
</li>
<li><p>import java.util.Collections;  </p>
</li>
<li>import java.util.HashSet;  </li>
<li>import java.util.Set;  </li>
<li>import java.util.concurrent.ExecutorService;  </li>
<li>import java.util.concurrent.Executors;  </li>
<li>import java.util.concurrent.Semaphore;  </li>
<li></li>
<li>public class TestSemaphore {  </li>
<li></li>
<li>public static void main(String[] args) {  </li>
<li>ExecutorService exec = Executors.newCachedThreadPool();  </li>
<li>TestSemaphore t = new TestSemaphore();  </li>
<li>final BoundedHashSet<String> set = t.getSet();  </li>
<li></li>
<li>for (int i = 0; i &lt; 3; i++) {//三个线程同时操作add  </li>
<li>exec.execute(new Runnable() {  </li>
<li>public void run() {  </li>
<li>try {  </li>
<li>set.add(Thread.currentThread().getName());  </li>
<li>} catch (InterruptedException e) {  </li>
<li>e.printStackTrace();  </li>
<li>}  </li>
<li>}  </li>
<li>});  </li>
<li>}  </li>
<li></li>
<li>for (int j = 0; j &lt; 3; j++) {//三个线程同时操作remove  </li>
<li>exec.execute(new Runnable() {  </li>
<li>public void run() {  </li>
<li>set.remove(Thread.currentThread().getName());  </li>
<li>}  </li>
<li>});  </li>
<li>}  </li>
<li>exec.shutdown();  </li>
<li>}  </li>
<li></li>
<li>public BoundedHashSet<String> getSet() {  </li>
<li>return new BoundedHashSet<String>(2);//定义一个边界约束为2的线程  </li>
<li>}  </li>
<li></li>
<li>class BoundedHashSet<T> {  </li>
<li>private final Set<T> set;  </li>
<li>private final Semaphore semaphore;  </li>
<li></li>
<li>public BoundedHashSet(int bound) {  </li>
<li>this.set = Collections.synchronizedSet(new HashSet<T>());  </li>
<li>this.semaphore = new Semaphore(bound, true);  </li>
<li>}  </li>
<li></li>
<li>public void add(T o) throws InterruptedException {  </li>
<li>semaphore.acquire();//信号量控制可访问的线程数目  </li>
<li>set.add(o);  </li>
<li>System.out.printf(&quot;add:%s%n&quot;,o);  </li>
<li>}  </li>
<li></li>
<li>public void remove(T o) {  </li>
<li>if (set.remove(o))  </li>
<li>semaphore.release();//释放掉信号量  </li>
<li>System.out.printf(&quot;remove:%s%n&quot;,o);  </li>
<li>}  </li>
<li>}  </li>
<li><p>}<br> 总结：Semaphore通常用于对象池的控制 
4．FutureTask 
 我们先来学习一下JDK1.5 API中关于这个类的详细介绍： 
 “取消的异步计算。利用开始和取消计算的方法、查询计算是否完成的方法和获取计算结果的方法，此类提供了对 Future 的基本实现。仅在计算完成时才能获取结果；如果计算尚未完成，则阻塞 get 方法。一旦计算完成，就不能再重新开始或取消计算。 
可使用 FutureTask 包装 Callable 或 Runnable 对象。因为 FutureTask 实现了 Runnable，所以可将 FutureTask 提交给 Executor 执行。 
除了作为一个独立的类外，此类还提供了 protected 功能，这在创建自定义任务类时可能很有用。 “ 
 应用举例：我们的算法中有一个很耗时的操作，在编程的是，我们希望将它独立成一个模块，调用的时候当做它是立刻返回的，并且可以随时取消的 
具体代码如下（参考 [JCIP]） 
Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"></a></p>
</li>
<li><p>import java.util.concurrent.Callable;  </p>
</li>
<li>import java.util.concurrent.ExecutionException;  </li>
<li>import java.util.concurrent.ExecutorService;  </li>
<li>import java.util.concurrent.Executors;  </li>
<li>import java.util.concurrent.FutureTask;  </li>
<li></li>
<li>public class TestFutureTask {  </li>
<li></li>
<li>public static void main(String[] args) {  </li>
<li>ExecutorService exec=Executors.newCachedThreadPool();  </li>
<li></li>
<li>FutureTask<String> task=new FutureTask<String>(new Callable<String>(){//FutrueTask的构造参数是一个Callable接口  </li>
<li>@Override  </li>
<li>public String call() throws Exception {  </li>
<li>return Thread.currentThread().getName();//这里可以是一个异步操作  </li>
<li>}});  </li>
<li></li>
<li>try {  </li>
<li>exec.execute(task);//FutureTask实际上也是一个线程  </li>
<li>String result=task.get();//取得异步计算的结果，如果没有返回，就会一直阻塞等待  </li>
<li>System.out.printf(&quot;get:%s%n&quot;,result);  </li>
<li>} catch (InterruptedException e) {  </li>
<li>e.printStackTrace();  </li>
<li>} catch (ExecutionException e) {  </li>
<li>e.printStackTrace();  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>}<br> 总结：FutureTask其实就是新建了一个线程单独执行，使得线程有一个返回值，方便程序的编写 </li>
<li><p>Exchanger 
 我们先来学习一下JDK1.5 API中关于这个类的详细介绍： 
 “可以在pair中对元素进行配对和交换的线程的同步点。每个线程将条目上的某个方法呈现给 exchange 方法，与伙伴线程进行匹配，并且在返回时接收其伙伴的对象。Exchanger 可能被视为 SynchronousQueue 的双向形式。Exchanger 可能在应用程序（比如遗传算法和管道设计）中很有用。 “ 
 应用举例：有两个缓存区，两个线程分别向两个缓存区fill和take，当且仅当一个满了，两个缓存区交换 
 代码如下（参考了网上给的示例   <a href="http://hi.baidu.com/webidea/blog/item/2995e731e53ad5a55fdf0e7d.html）" target="_blank">http://hi.baidu.com/webidea/blog/item/2995e731e53ad5a55fdf0e7d.html）</a> 
Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"></a></p>
</li>
<li><p>import java.util.ArrayList;  </p>
</li>
<li>import java.util.concurrent.Exchanger;  </li>
<li></li>
<li>public class TestExchanger {  </li>
<li></li>
<li>public static void main(String[] args) {  </li>
<li>final Exchanger<ArrayList<Integer>&gt; exchanger = new Exchanger<ArrayList<Integer>&gt;();  </li>
<li>final ArrayList<Integer> buff1 = new ArrayList<Integer>(10);  </li>
<li>final ArrayList<Integer> buff2 = new ArrayList<Integer>(10);  </li>
<li></li>
<li>new Thread(new Runnable() {  </li>
<li>@Override  </li>
<li>public void run() {  </li>
<li>ArrayList<Integer> buff = buff1;  </li>
<li>try {  </li>
<li>while (true) {  </li>
<li>if (buff.size() &gt;= 10) {  </li>
<li>buff = exchanger.exchange(buff);//开始跟另外一个线程交互数据  </li>
<li>System.out.println(&quot;exchange buff1&quot;);  </li>
<li>buff.clear();  </li>
<li>}  </li>
<li>buff.add((int)(Math.random()/*100));  </li>
<li>Thread.sleep((long)(Math.random()/*1000));  </li>
<li>}  </li>
<li>} catch (InterruptedException e) {  </li>
<li>e.printStackTrace();  </li>
<li>}  </li>
<li>}  </li>
<li>}).start();  </li>
<li></li>
<li>new Thread(new Runnable(){  </li>
<li>@Override  </li>
<li>public void run() {  </li>
<li>ArrayList<Integer> buff=buff2;  </li>
<li>while(true){  </li>
<li>try {  </li>
<li>for(Integer i:buff){  </li>
<li>System.out.println(i);  </li>
<li>}  </li>
<li>Thread.sleep(1000);  </li>
<li>buff=exchanger.exchange(buff);//开始跟另外一个线程交换数据  </li>
<li>System.out.println(&quot;exchange buff2&quot;);  </li>
<li>} catch (InterruptedException e) {  </li>
<li>e.printStackTrace();  </li>
<li>}  </li>
<li>}  </li>
<li>}}).start();  </li>
<li>}  </li>
<li><p>}<br> 总结：Exchanger在特定的使用场景比较有用（两个伙伴线程之间的数据交互） </p>
</li>
<li><p>ScheduledThreadPoolExecutor 
 我们先来学习一下JDK1.5 API中关于这个类的详细介绍： 
 &quot;可另行安排在给定的延迟后运行命令，或者定期执行命令。需要多个辅助线程时，或者要求 ThreadPoolExecutor 具有额外的灵活性或功能时，此类要优于 Timer。 
 一旦启用已延迟的任务就执行它，但是有关何时启用，启用后何时执行则没有任何实时保证。按照提交的先进先出 (FIFO) 顺序来启用那些被安排在同一执行时间的任务。 
 虽然此类继承自 ThreadPoolExecutor，但是几个继承的调整方法对此类并无作用。特别是，因为它作为一个使用 corePoolSize 线程和一个无界队列的固定大小的池，所以调整 maximumPoolSize 没有什么效果。&quot; 
 在JDK1.5之前，我们关于定时/周期操作都是通过Timer来实现的。但是Timer有以下几种危险[JCIP] 
a. Timer是基于绝对时间的。容易受系统时钟的影响。 
b. Timer只新建了一个线程来执行所有的TimeTask。所有TimeTask可能会相关影响 
c. Timer不会捕获TimerTask的异常，只是简单地停止。这样势必会影响其他TimeTask的执行。 
 如果你是使用JDK1.5以上版本，建议用ScheduledThreadPoolExecutor代替Timer。它基本上解决了上述问题。它采用相对时间，用线程池来执行TimerTask，会出来TimerTask异常。 
 下面通过一个简单的实例来阐述ScheduledThreadPoolExecutor的使用。 </p>
<p> 我们定期让定时器抛异常 
 我们定期从控制台打印系统时间 
代码如下（参考了网上的一些代码，在此表示感谢） 
Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"></a></p>
</li>
<li><p>import java.util.concurrent.ScheduledThreadPoolExecutor;  </p>
</li>
<li>import java.util.concurrent.TimeUnit;  </li>
<li></li>
<li></li>
<li>public class TestScheduledThreadPoolExecutor {  </li>
<li></li>
<li>public static void main(String[] args) {  </li>
<li>ScheduledThreadPoolExecutor exec=new ScheduledThreadPoolExecutor(1);  </li>
<li></li>
<li>exec.scheduleAtFixedRate(new Runnable(){//每隔一段时间就触发异常  </li>
<li>@Override  </li>
<li>public void run() {  </li>
<li>throw new RuntimeException();  </li>
<li>}}, 1000, 5000, TimeUnit.MILLISECONDS);  </li>
<li></li>
<li>exec.scheduleAtFixedRate(new Runnable(){//每隔一段时间打印系统时间，证明两者是互不影响的  </li>
<li>@Override  </li>
<li>public void run() {  </li>
<li>System.out.println(System.nanoTime());  </li>
<li>}}, 1000, 2000, TimeUnit.MILLISECONDS);  </li>
<li>}  </li>
<li></li>
<li>}<br>总结：是时候把你的定时器换成 ScheduledThreadPoolExecutor了 </li>
</ol>
<p>7.BlockingQueue 
    “支持两个附加操作的 Queue，这两个操作是：获取元素时等待队列变为非空，以及存储元素时等待空间变得可用。“ 
    这里我们主要讨论BlockingQueue的最典型实现：LinkedBlockingQueue 和ArrayBlockingQueue。两者的不同是底层的数据结构不够，一个是链表，另外一个是数组。 </p>
<pre><code>后面将要单独解释其他类型的BlockingQueue和SynchronousQueue 
BlockingQueue的经典用途是 生产者-消费者模式 
代码如下： 
</code></pre><p>Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"></a></p>
<ol>
<li>import java.util.Random;  </li>
<li>import java.util.concurrent.BlockingQueue;  </li>
<li>import java.util.concurrent.LinkedBlockingQueue;  </li>
<li></li>
<li>public class TestBlockingQueue {  </li>
<li></li>
<li>public static void main(String[] args) {  </li>
<li>final BlockingQueue<Integer> queue=new LinkedBlockingQueue<Integer>(3);  </li>
<li>final Random random=new Random();  </li>
<li></li>
<li>class Producer implements Runnable{  </li>
<li>@Override  </li>
<li>public void run() {  </li>
<li>while(true){  </li>
<li>try {  </li>
<li>int i=random.nextInt(100);  </li>
<li>queue.put(i);//当队列达到容量时候，会自动阻塞的  </li>
<li>if(queue.size()==3)  </li>
<li>{  </li>
<li>System.out.println(&quot;full&quot;);  </li>
<li>}  </li>
<li>} catch (InterruptedException e) {  </li>
<li>e.printStackTrace();  </li>
<li>}  </li>
<li>}  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>class Consumer implements Runnable{  </li>
<li>@Override  </li>
<li>public void run() {  </li>
<li>while(true){  </li>
<li>try {  </li>
<li>queue.take();//当队列为空时，也会自动阻塞  </li>
<li>Thread.sleep(1000);  </li>
<li>} catch (InterruptedException e) {  </li>
<li>e.printStackTrace();  </li>
<li>}  </li>
<li>}  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>new Thread(new Producer()).start();  </li>
<li>new Thread(new Consumer()).start();  </li>
<li>}  </li>
<li></li>
<li>}<br> 总结：BlockingQueue使用时候特别注意take 和 put </li>
<li><p>DelayQueue 
我们先来学习一下JDK1.5 API中关于这个类的详细介绍： 
 “它是包含Delayed 元素的一个无界阻塞队列，只有在延迟期满时才能从中提取元素。该队列的头部 是延迟期满后保存时间最长的 Delayed 元素。如果延迟都还没有期满，则队列没有头部，并且 poll 将返回 null。当一个元素的 getDelay(TimeUnit.NANOSECONDS) 方法返回一个小于等于 0 的值时，将发生到期。即使无法使用 take 或 poll 移除未到期的元素，也不会将这些元素作为正常元素对待。例如，size 方法同时返回到期和未到期元素的计数。此队列不允许使用 null 元素。” 
 在现实生活中，很多DelayQueue的例子。就拿上海的SB会来说明，很多国家地区的开馆时间不同。你很早就来到园区，然后急急忙忙地跑到一些心仪的馆区，发现有些还没开，你吃了闭门羹。 
 仔细研究DelayQueue，你会发现它其实就是一个PriorityQueue的封装（按照delay时间排序），里面的元素都实现了Delayed接口，相关操作需要判断延时时间是否到了。 
 在实际应用中，有人拿它来管理跟实际相关的缓存、session等 
下面我就通过 “上海SB会的例子来阐述DelayQueue的用法” 
代码如下： 
Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"></a></p>
</li>
<li><p>import java.util.Random;  </p>
</li>
<li>import java.util.concurrent.DelayQueue;  </li>
<li>import java.util.concurrent.Delayed;  </li>
<li>import java.util.concurrent.TimeUnit;  </li>
<li></li>
<li>public class TestDelayQueue {  </li>
<li></li>
<li>private class Stadium implements Delayed  </li>
<li>{  </li>
<li>long trigger;  </li>
<li></li>
<li>public Stadium(long i){  </li>
<li>trigger=System.currentTimeMillis()+i;  </li>
<li>}  </li>
<li></li>
<li>@Override  </li>
<li>public long getDelay(TimeUnit arg0) {  </li>
<li>long n=trigger-System.currentTimeMillis();  </li>
<li>return n;  </li>
<li>}  </li>
<li></li>
<li>@Override  </li>
<li>public int compareTo(Delayed arg0) {  </li>
<li>return (int)(this.getDelay(TimeUnit.MILLISECONDS)-arg0.getDelay(TimeUnit.MILLISECONDS));  </li>
<li>}  </li>
<li></li>
<li>public long getTriggerTime(){  </li>
<li>return trigger;  </li>
<li>}  </li>
<li></li>
<li>}  </li>
<li>public static void main(String[] args)throws Exception {  </li>
<li>Random random=new Random();  </li>
<li>DelayQueue<Stadium> queue=new DelayQueue<Stadium>();  </li>
<li>TestDelayQueue t=new TestDelayQueue();  </li>
<li></li>
<li>for(int i=0;i&lt;5;i++){  </li>
<li>queue.add(t.new Stadium(random.nextInt(30000)));  </li>
<li>}  </li>
<li>Thread.sleep(2000);  </li>
<li></li>
<li>while(true){  </li>
<li>Stadium s=queue.take();//延时时间未到就一直等待  </li>
<li>if(s!=null){  </li>
<li>System.out.println(System.currentTimeMillis()-s.getTriggerTime());//基本上是等于0  </li>
<li>}  </li>
<li>if(queue.size()==0)  </li>
<li>break;  </li>
<li>}  </li>
<li>}  </li>
<li>}<br> 总结：适用于需要延时操作的队列管理 </li>
<li><p>SynchronousQueue 
 我们先来学习一下JDK1.5 API中关于这个类的详细介绍： 
 “一种阻塞队列，其中每个插入操作必须等待另一个线程的对应移除操作 ，反之亦然。同步队列没有任何内部容量，甚至连一个队列的容量都没有。不能在同步队列上进行 peek，因为仅在试图要移除元素时，该元素才存在；除非另一个线程试图移除某个元素，否则也不能（使用任何方法）插入元素；也不能迭代队列，因为其中没有元素可用于迭代。队列的头 是尝试添加到队列中的首个已排队插入线程的元素；如果没有这样的已排队线程，则没有可用于移除的元素并且 poll() 将会返回 null。对于其他 Collection 方法（例如 contains），SynchronousQueue 作为一个空 collection。此队列不允许 null 元素。 
 同步队列类似于 CSP 和 Ada 中使用的 rendezvous 信道。它非常适合于传递性设计，在这种设计中，在一个线程中运行的对象要将某些信息、事件或任务传递给在另一个线程中运行的对象，它就必须与该对象同步。 “ 
 看起来很有意思吧。队列竟然是没有内部容量的。这个队列其实是BlockingQueue的一种实现。每个插入操作必须等待另一个线程的对应移除操作，反之亦然。它给我们提供了在线程之间交换单一元素的极轻量级方法 
应用举例：我们要在多个线程中传递一个变量。 
代码如下（其实就是生产者消费者模式） 
Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"></a></p>
</li>
<li><p>import java.util.Arrays;  </p>
</li>
<li>import java.util.List;  </li>
<li>import java.util.concurrent.BlockingQueue;  </li>
<li>import java.util.concurrent.SynchronousQueue;  </li>
<li></li>
<li>public class TestSynchronousQueue {  </li>
<li></li>
<li>class Producer implements Runnable {  </li>
<li>private BlockingQueue<String> queue;  </li>
<li>List<String> objects = Arrays.asList(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;);  </li>
<li></li>
<li>public Producer(BlockingQueue<String> q) {  </li>
<li>this.queue = q;  </li>
<li>}  </li>
<li></li>
<li>@Override  </li>
<li>public void run() {  </li>
<li>try {  </li>
<li>for (String s : objects) {  </li>
<li>queue.put(s);// 产生数据放入队列中  </li>
<li>System.out.printf(&quot;put:%s%n&quot;,s);  </li>
<li>}  </li>
<li>queue.put(&quot;Done&quot;);// 已完成的标志  </li>
<li>} catch (InterruptedException e) {  </li>
<li>e.printStackTrace();  </li>
<li>}  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>class Consumer implements Runnable {  </li>
<li>private BlockingQueue<String> queue;  </li>
<li></li>
<li>public Consumer(BlockingQueue<String> q) {  </li>
<li>this.queue = q;  </li>
<li>}  </li>
<li></li>
<li>@Override  </li>
<li>public void run() {  </li>
<li>String obj = null;  </li>
<li>try {  </li>
<li>while (!((obj = queue.take()).equals(&quot;Done&quot;))) {  </li>
<li>System.out.println(obj);//从队列中读取对象  </li>
<li>Thread.sleep(3000);     //故意sleep，证明Producer是put不进去的  </li>
<li>}  </li>
<li>} catch (InterruptedException e) {  </li>
<li>e.printStackTrace();  </li>
<li>}  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>public static void main(String[] args) {  </li>
<li>BlockingQueue<String> q=new SynchronousQueue<String>();  </li>
<li>TestSynchronousQueue t=new TestSynchronousQueue();  </li>
<li>new Thread(t.new Producer(q)).start();  </li>
<li>new Thread(t.new Consumer(q)).start();  </li>
<li>}  </li>
<li></li>
<li>}<br>总结：SynchronousQueue主要用于单个元素在多线程之间的传递 </li>
</ol>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/Java_多线程/">Java_多线程</a></li><li><a href="/categories/Java&J2EE/Java_多线程/并发/">并发</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/Java_多线程/" class="label label-success">Java_多线程</a><a href="/tags/并发/" class="label label-info">并发</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:41"datetime="2014-03-07 09:54:41"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-Java_多线程-并发--java多线程学习-javautilconcurrent详解/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-Java_多线程-并发--java多线程学习-javautilconcurrent详解" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_多线程-内存--深入理解Java内存模型（七）——总结/">深入理解Java内存模型（七）——总结</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:41.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_多线程-内存--深入理解Java内存模型（七）——总结/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-java-">深入理解Java内存模型（七）——总结</h1>
<h3 id="-">分享到</h3>
<ul>
<li><a href="">一键分享</a></li>
<li><a href="">QQ空间</a></li>
<li><a href="">新浪微博</a></li>
<li><a href="">百度搜藏</a></li>
<li><a href="">人人网</a></li>
<li><a href="">腾讯微博</a></li>
<li><a href="">百度相册</a></li>
<li><a href="">开心网</a></li>
<li><a href="">腾讯朋友</a></li>
<li><a href="">百度贴吧</a></li>
<li><a href="">豆瓣网</a></li>
<li><a href="">搜狐微博</a></li>
<li><a href="">百度新首页</a></li>
<li><a href="">QQ好友</a></li>
<li><a href="">和讯微博</a></li>
<li><a href="">更多...</a></li>
</ul>
<p><a href="">百度分享</a></p>
<ul>
<li><a href="http://www.infoq.com/cn/aboutus" title="关于我们" target="_blank">关于我们</a></li>
<li><p><a href="http://www.infoq.com/cn/contribute" title="让大家在InfoQ上听见你的声音" target="_blank">让大家在InfoQ上听见你的声音</a></p>
</li>
<li><p>欢迎关注我们的：</p>
</li>
<li><a href="http://e.weibo.com/infoqchina" target="_blank"><img src="" alt=""></a></li>
<li><a href="http://www.infoq.com/cn/news/2013/02/infoq-wechat" target="_blank"><img src="" alt=""></a></li>
<li><a href="http://www.infoq.com/cn/rss/rss.action?token=AjlwmaWcwi5ejkcT6GcRk1pCqJ4K7ocs" target="_blank"><img src="" alt=""></a></li>
</ul>
<p>促进软件开发领域知识与创新的传播</p>
<p><a href="&quot;Login&quot;">登录</a>
<a href="http://www.infoq.com/cn/" target="_blank"><img src="" alt=""></a></p>
<ul>
<li><a href="http://www.infoq.com/" target="_blank">En</a> |</li>
<li><a href="&quot;InfoQ China&quot;">中文</a> |</li>
<li><a href="http://www.infoq.com/jp/" target="_blank">日本</a> |</li>
<li><a href="http://www.infoq.com/fr/" target="_blank">Fr</a> |</li>
<li><a href="http://www.infoq.com/br/" target="_blank">Br</a></li>
</ul>
<p>164,153 六月 独立访问用户</p>
<ul>
<li><p><a href="http://www.infoq.com/cn/development/" title="Development" target="_blank">语言 &amp; 开发</a></p>
</li>
<li><p><a href="http://www.infoq.com/cn/java/?utm_source=infoq&amp;utm_medium=header_graybar&amp;utm_campaign=topic_clk" title="Java" target="_blank">Java</a></p>
</li>
<li><a href="http://www.infoq.com/cn/dotnet/?utm_source=infoq&amp;utm_medium=header_graybar&amp;utm_campaign=topic_clk" title=".Net" target="_blank">.Net</a></li>
<li><a href="http://www.infoq.com/cn/cloud-computing/?utm_source=infoq&amp;utm_medium=header_graybar&amp;utm_campaign=topic_clk" title="云计算" target="_blank">云计算</a></li>
<li><a href="http://www.infoq.com/cn/mobile/?utm_source=infoq&amp;utm_medium=header_graybar&amp;utm_campaign=topic_clk" title="移动" target="_blank">移动</a></li>
<li><a href="http://www.infoq.com/cn/HTML5Topic/?utm_source=infoq&amp;utm_medium=header_graybar&amp;utm_campaign=topic_clk" title="HTML 5" target="_blank">HTML 5</a></li>
<li><a href="http://www.infoq.com/cn/javascript/?utm_source=infoq&amp;utm_medium=header_graybar&amp;utm_campaign=topic_clk" title="JavaScript" target="_blank">JavaScript</a></li>
<li><a href="http://www.infoq.com/cn/ruby/?utm_source=infoq&amp;utm_medium=header_graybar&amp;utm_campaign=topic_clk" title="Ruby" target="_blank">Ruby</a></li>
<li><a href="http://www.infoq.com/cn/dsl/?utm_source=infoq&amp;utm_medium=header_graybar&amp;utm_campaign=topic_clk" title="DSLs" target="_blank">DSLs</a></li>
<li><a href="http://www.infoq.com/cn/python/?utm_source=infoq&amp;utm_medium=header_graybar&amp;utm_campaign=topic_clk" title="Python" target="_blank">Python</a></li>
<li><a href="http://www.infoq.com/cn/Topic_PHP/?utm_source=infoq&amp;utm_medium=header_graybar&amp;utm_campaign=topic_clk" title="PHP" target="_blank">PHP</a></li>
<li><a href="http://www.infoq.com/cn/PaaS/?utm_source=infoq&amp;utm_medium=header_graybar&amp;utm_campaign=topic_clk" title="PaaS" target="_blank">PaaS</a></li>
</ul>
<h2 id="-">特别专题语言 &amp; 开发</h2>
<h3 id="-juergen-fesslmeier-javascript-http-www-infoq-com-cn-interviews-end-to-end-javascript-"><a href="http://www.infoq.com/cn/interviews/end-to-end-javascript" target="_blank">Juergen Fesslmeier谈端到端的JavaScript开发</a></h3>
<p><img src="" alt=""> Juergen谈论了使用JavaScript进行端对端开发的好处和开发团队可能遇见的挑战。他还谈到了Wakanda Studio以及如何仅用JavaScript通过它来开发复杂的应用程序。
<a href="http://www.infoq.com/cn/development/" target="_blank">浏览所有<strong>语言 &amp; 开发</strong></a></p>
<ul>
<li><p><a href="http://www.infoq.com/cn/architecture-design/" title="Architecture &amp; Design" target="_blank">架构 &amp; 设计</a></p>
</li>
<li><p><a href="http://www.infoq.com/cn/Modeling/?utm_source=infoq&amp;utm_medium=header_graybar&amp;utm_campaign=topic_clk" title="建模" target="_blank">建模</a></p>
</li>
<li><a href="http://www.infoq.com/cn/performance-scalability/?utm_source=infoq&amp;utm_medium=header_graybar&amp;utm_campaign=topic_clk" title="性能和可伸缩性" target="_blank">性能和可伸缩性</a></li>
<li><a href="http://www.infoq.com/cn/domain-driven-design/?utm_source=infoq&amp;utm_medium=header_graybar&amp;utm_campaign=topic_clk" title="领域驱动设计" target="_blank">领域驱动设计</a></li>
<li><a href="http://www.infoq.com/cn/AOP/?utm_source=infoq&amp;utm_medium=header_graybar&amp;utm_campaign=topic_clk" title="AOP" target="_blank">AOP</a></li>
<li><a href="http://www.infoq.com/cn/DesignPattern/?utm_source=infoq&amp;utm_medium=header_graybar&amp;utm_campaign=topic_clk" title="设计模式" target="_blank">设计模式</a></li>
<li><a href="http://www.infoq.com/cn/Security/?utm_source=infoq&amp;utm_medium=header_graybar&amp;utm_campaign=topic_clk" title="安全" target="_blank">安全</a></li>
<li><a href="http://www.infoq.com/cn/cloud-computing/?utm_source=infoq&amp;utm_medium=header_graybar&amp;utm_campaign=topic_clk" title="云计算" target="_blank">云计算</a></li>
<li><a href="http://www.infoq.com/cn/soa_platforms/?utm_source=infoq&amp;utm_medium=header_graybar&amp;utm_campaign=topic_clk" title="SOA" target="_blank">SOA</a></li>
</ul>
<h2 id="-">特别专题架构 &amp; 设计</h2>
<h3 id="-http-www-infoq-com-cn-articles-design-pattern-automation-"><a href="http://www.infoq.com/cn/articles/Design-Pattern-Automation" target="_blank">设计模式自动化</a></h3>
<p><img src="" alt=""> 尽管维护每行代码的成本如此高昂，但我们仍然每天都在编写着大量的样板代码。如果我们有更智能的编译器，那其中很大一部分是可以避免的。实际上，多数模板代码只是重复地实现那些我们已理解透彻的设计模式，只要我们教会编译器一些技巧，有一些设计模式完全是可以自动实现的。
<a href="http://www.infoq.com/cn/architecture-design/" target="_blank">浏览所有<strong>架构 &amp; 设计</strong></a></p>
<ul>
<li><p><a href="http://www.infoq.com/cn/process-practices/" title="Process &amp; Practices" target="_blank">过程 &amp; 实践</a></p>
</li>
<li><p><a href="http://www.infoq.com/cn/agile/?utm_source=infoq&amp;utm_medium=header_graybar&amp;utm_campaign=topic_clk" title="Agile" target="_blank">Agile</a></p>
</li>
<li><a href="http://www.infoq.com/cn/Leadership/?utm_source=infoq&amp;utm_medium=header_graybar&amp;utm_campaign=topic_clk" title="领导能力" target="_blank">领导能力</a></li>
<li><a href="http://www.infoq.com/cn/team-collaboration/?utm_source=infoq&amp;utm_medium=header_graybar&amp;utm_campaign=topic_clk" title="团队协作" target="_blank">团队协作</a></li>
<li><a href="http://www.infoq.com/cn/agile_techniques/?utm_source=infoq&amp;utm_medium=header_graybar&amp;utm_campaign=topic_clk" title="敏捷技术" target="_blank">敏捷技术</a></li>
<li><a href="http://www.infoq.com/cn/methodologies/?utm_source=infoq&amp;utm_medium=header_graybar&amp;utm_campaign=topic_clk" title="方法论" target="_blank">方法论</a></li>
<li><a href="http://www.infoq.com/cn/continuous_integration/?utm_source=infoq&amp;utm_medium=header_graybar&amp;utm_campaign=topic_clk" title="持续集成" target="_blank">持续集成</a></li>
<li><a href="http://www.infoq.com/cn/lean/?utm_source=infoq&amp;utm_medium=header_graybar&amp;utm_campaign=topic_clk" title="精益" target="_blank">精益</a></li>
<li><a href="http://www.infoq.com/cn/cust_requirements/?utm_source=infoq&amp;utm_medium=header_graybar&amp;utm_campaign=topic_clk" title="客户及需求" target="_blank">客户及需求</a></li>
</ul>
<h2 id="-">特别专题过程 &amp; 实践</h2>
<h3 id="-alm-http-www-infoq-com-cn-articles-integrated-alm-"><a href="http://www.infoq.com/cn/articles/Integrated-ALM" target="_blank">成功的根本—集成的ALM工具</a></h3>
<p><img src="" alt=""> 典型的软件交付项目会无数次地去获取需求，并在多个地方描述测试，但它们却与某一特定的构建里的具体内容并不相符合，因此项目往往需要大量分析来获知谁在做什么以及为什么做。Dave West深入研究造成该问题的原因，并致力研究一个整体的、集成的ALM方法。
<a href="http://www.infoq.com/cn/process-practices/" target="_blank">浏览所有<strong>过程 &amp; 实践</strong></a></p>
<ul>
<li><p><a href="http://www.infoq.com/cn/operations-infrastructure/" title="Operations &amp; Infrastructure" target="_blank">运维 &amp; 基础架构</a></p>
</li>
<li><p><a href="http://www.infoq.com/cn/performance-scalability/?utm_source=infoq&amp;utm_medium=header_graybar&amp;utm_campaign=topic_clk" title="性能和可伸缩性" target="_blank">性能和可伸缩性</a></p>
</li>
<li><a href="http://www.infoq.com/cn/bigdata/?utm_source=infoq&amp;utm_medium=header_graybar&amp;utm_campaign=topic_clk" title="大数据" target="_blank">大数据</a></li>
<li><a href="http://www.infoq.com/cn/devops/?utm_source=infoq&amp;utm_medium=header_graybar&amp;utm_campaign=topic_clk" title="DevOps" target="_blank">DevOps</a></li>
<li><a href="http://www.infoq.com/cn/cloud-computing/?utm_source=infoq&amp;utm_medium=header_graybar&amp;utm_campaign=topic_clk" title="云计算" target="_blank">云计算</a></li>
<li><a href="http://www.infoq.com/cn/virtualization/?utm_source=infoq&amp;utm_medium=header_graybar&amp;utm_campaign=topic_clk" title="虚拟化" target="_blank">虚拟化</a></li>
<li><a href="http://www.infoq.com/cn/NoSQL/?utm_source=infoq&amp;utm_medium=header_graybar&amp;utm_campaign=topic_clk" title="NoSQL" target="_blank">NoSQL</a></li>
<li><a href="http://www.infoq.com/cn/ApplicationServers/?utm_source=infoq&amp;utm_medium=header_graybar&amp;utm_campaign=topic_clk" title="应用服务器" target="_blank">应用服务器</a></li>
<li><a href="http://www.infoq.com/cn/operations/?utm_source=infoq&amp;utm_medium=header_graybar&amp;utm_campaign=topic_clk" title="运维" target="_blank">运维</a></li>
</ul>
<h2 id="-">特别专题运维 &amp; 基础架构</h2>
<h3 id="-http-www-infoq-com-cn-articles-atdd-by-example-book-"><a href="http://www.infoq.com/cn/articles/atdd-by-example-book" target="_blank">书评：验收测试驱动开发实践指南</a></h3>
<p><img src="" alt=""> 《验收测试驱动开发实践指南》一书的目的是作为一个介绍性使用指南指导那些从零开始的团队成功执行和应用验收测试驱动开发（ATDD）。尽管该书在指出及总结了成功敏捷测试人员应该掌握的多个测试相关实践上做了有效的工作，但该书最终并没有为它的各层读者提供他们所需要的信息。By Manuel Pais
<a href="http://www.infoq.com/cn/operations-infrastructure/" target="_blank">浏览所有<strong>运维 &amp; 基础架构</strong></a></p>
<ul>
<li><p><a href="http://www.infoq.com/cn/enterprise-architect/" title="Enterprise Architecture" target="_blank">企业架构</a></p>
</li>
<li><p><a href="http://www.infoq.com/cn/enterprise-architecture/?utm_source=infoq&amp;utm_medium=header_graybar&amp;utm_campaign=topic_clk" title="企业架构" target="_blank">企业架构</a></p>
</li>
<li><a href="http://www.infoq.com/cn/bpm/?utm_source=infoq&amp;utm_medium=header_graybar&amp;utm_campaign=topic_clk" title="业务流程建模" target="_blank">业务流程建模</a></li>
<li><a href="http://www.infoq.com/cn/business_it_alignment/?utm_source=infoq&amp;utm_medium=header_graybar&amp;utm_campaign=topic_clk" title="业务/IT整合" target="_blank">业务/IT整合</a></li>
<li><a href="http://www.infoq.com/cn/EAI/?utm_source=infoq&amp;utm_medium=header_graybar&amp;utm_campaign=topic_clk" title="Integration (EAI)" target="_blank">Integration (EAI)</a></li>
<li><a href="http://www.infoq.com/cn/Governance/?utm_source=infoq&amp;utm_medium=header_graybar&amp;utm_campaign=topic_clk" title="治理" target="_blank">治理</a></li>
<li><a href="http://www.infoq.com/cn/web20/?utm_source=infoq&amp;utm_medium=header_graybar&amp;utm_campaign=topic_clk" title="Web 2.0" target="_blank">Web 2.0</a></li>
<li><a href="http://www.infoq.com/cn/soa/?utm_source=infoq&amp;utm_medium=header_graybar&amp;utm_campaign=topic_clk" title="SOA" target="_blank">SOA</a></li>
</ul>
<h2 id="-">特别专题企业架构</h2>
<h3 id="-http-www-infoq-com-cn-articles-designing-a-world-at-your-fingertips-mobile-user-interfaces-"><a href="http://www.infoq.com/cn/articles/designing-a-world-at-your-fingertips-mobile-user-interfaces" target="_blank">设计指尖上的世界：移动用户界面一瞥</a></h3>
<p><img src="" alt=""> 对任何成功的移动应用来说，用户界面（UI）是至关重要的组成部分。在这篇文章中，Forrest Skull展示了他与人机交互（HCI）研究者们进行的访谈与讨论，他们探讨了移动设备UI方面的原则，以及其它一些正在研究的领域，包括多设备、隐私、安全和语音。这篇文章还描述了开发移动设备用户界面过程中会面临的挑战。
<a href="http://www.infoq.com/cn/enterprise-architect/" target="_blank">浏览所有<strong>企业架构</strong></a>
<a href="http://www.qconshanghai.com/" title="New York 2013"><strong>QCon上海2013</strong>
11月1-3日
上海光大会展中心</a></p>
<ul>
<li><a href="http://www.infoq.com/cn/mobile/?utm_source=infoq&amp;utm_medium=header_graybar&amp;utm_campaign=topic_clk" title="移动" target="_blank">移动</a></li>
<li><a href="http://www.infoq.com/cn/html-5/?utm_source=infoq&amp;utm_medium=header_graybar&amp;utm_campaign=topic_clk" title="HTML 5" target="_blank">HTML 5</a></li>
<li><a href="http://www.infoq.com/cn/nodejs/?utm_source=infoq&amp;utm_medium=header_graybar&amp;utm_campaign=topic_clk" title="Node.js" target="_blank">Node.js</a></li>
<li><a href="http://www.infoq.com/cn/cloud-computing/?utm_source=infoq&amp;utm_medium=header_graybar&amp;utm_campaign=topic_clk" title="云计算" target="_blank">云计算</a></li>
<li><a href="http://www.infoq.com/cn/bigdata/?utm_source=infoq&amp;utm_medium=header_graybar&amp;utm_campaign=topic_clk" title="大数据" target="_blank">大数据</a></li>
<li><a href="http://www.infoq.com/cn/operations/?utm_source=infoq&amp;utm_medium=header_graybar&amp;utm_campaign=topic_clk" title="运维" target="_blank">运维</a></li>
<li><a href="http://www.infoq.com/cn/architect/?utm_source=infoq&amp;utm_medium=header_graybar&amp;utm_campaign=topic_clk" title="架构师" target="_blank">架构师</a></li>
<li><a href="http://www.infoq.com/cn/baidu_cloud/?utm_source=infoq&amp;utm_medium=header_graybar&amp;utm_campaign=topic_clk" title="百度云" target="_blank">百度云</a>
<a href="http://www.infoq.com/cn/topics" target="_blank">全部话题</a></li>
</ul>
<p><a href="http://www.infoq.com/news/2013/04/infoq-redesign" target="_blank">New UI</a>
您目前处于： <a href="http://www.infoq.com/cn" title="InfoQ首页" target="_blank">InfoQ首页</a> <a href="http://www.infoq.com/cn/articles" title="文章" target="_blank">文章</a> 深入理解Java内存模型（七）——总结</p>
<h1 id="-java-">深入理解Java内存模型（七）——总结</h1>
<p>作者 <a href="http://www.infoq.com/cn/author/%E7%A8%8B%E6%99%93%E6%98%8E" target="_blank">程晓明</a> 发布于 三月 15, 2013 <em>|</em> <a href="">4 评论</a></p>
<ul>
<li><a href="&quot;分享到新浪微博&quot;">新浪微博</a> <a href="&quot;分享到腾讯微博&quot;">腾讯微博</a> <a href="&quot;分享到豆瓣网&quot;">豆瓣网</a> <a href="&quot;分享到Twitter&quot;">Twitter</a> <a href="&quot;分享到Facebook&quot;">Facebook</a> <a href="&quot;分享到linkedin&quot;">linkedin</a> <a href="&quot;分享到邮件分享&quot;">邮件分享</a> 更多 <a href="&quot;累计分享23次&quot;">23</a></li>
<li><a href="">稍后阅读</a></li>
<li><a href="http://www.infoq.com/cn/showbookmarks.action" target="_blank">我的阅读清单</a><h2 id="-">处理器内存模型</h2>
</li>
</ul>
<p>顺序一致性内存模型是一个理论参考模型，JMM和处理器内存模型在设计时通常会把顺序一致性内存模型作为参照。JMM和处理器内存模型在设计时会对顺序一致性模型做一些放松，因为如果完全按照顺序一致性模型来实现处理器和JMM，那么很多的处理器和编译器优化都要被禁止，这对执行性能将会有很大的影响。</p>
<p>根据对不同类型读/写操作组合的执行顺序的放松，可以把常见处理器的内存模型划分为下面几种类型：</p>
<ol>
<li>放松程序中写-读操作的顺序，由此产生了total store ordering内存模型（简称为TSO）。</li>
<li>在前面1的基础上，继续放松程序中写-写操作的顺序，由此产生了partial store order 内存模型（简称为PSO）。</li>
<li>在前面1和2的基础上，继续放松程序中读-写和读-读操作的顺序，由此产生了relaxed memory order内存模型（简称为RMO）和PowerPC内存模型。</li>
</ol>
<p>注意，这里处理器对读/写操作的放松，是以两个操作之间不存在数据依赖性为前提的（因为处理器要遵守as-if-serial语义，处理器不会对存在数据依赖性的两个内存操作做重排序）。</p>
<p>下面的表格展示了常见处理器内存模型的细节特征：
内存模型名称</p>
<p>对应的处理器
相关厂商内容</p>
<h3 id="-javaone-spring-java-ee-6-http-www-infoq-com-infoq-url-action-i-3379-t-f-"><a href="http://www.infoq.com/infoq/url.action?i=3379&amp;t=f" target="_blank">JavaOne上海：迁移Spring应用到Java EE 6</a></h3>
<h3 id="-javaone-http-www-infoq-com-infoq-url-action-i-3380-t-f-"><a href="http://www.infoq.com/infoq/url.action?i=3380&amp;t=f" target="_blank">JavaOne上海：淘宝的鹰眼分布式日志系统</a></h3>
<h3 id="-qcon-2013-http-www-infoq-com-cn-vendorcontent-show-action-vcr-2272-utm_source-infoq-utm_medium-vcr-utm_campaign-vcr_articles_click-"><a href="http://www.infoq.com/cn/vendorcontent/show.action?vcr=2272&amp;utm_source=infoq&amp;utm_medium=VCR&amp;utm_campaign=vcr_articles_click" target="_blank">豆瓣工程副总裁段念确认参与QCon上海2013，担任团队文化专题出品人</a></h3>
<h3 id="-html5-builder-web-http-www-infoq-com-cn-vendorcontent-show-action-vcr-2308-utm_source-infoq-utm_medium-vcr-utm_campaign-vcr_articles_click-"><a href="http://www.infoq.com/cn/vendorcontent/show.action?vcr=2308&amp;utm_source=infoq&amp;utm_medium=VCR&amp;utm_campaign=vcr_articles_click" target="_blank">白皮书下载：用HTML5 Builder构建单一代码库的Web/移动应用</a></h3>
<h3 id="-qcon-20-80-http-www-infoq-com-cn-vendorcontent-show-action-vcr-2311-utm_source-infoq-utm_medium-vcr-utm_campaign-vcr_articles_click-"><a href="http://www.infoq.com/cn/vendorcontent/show.action?vcr=2311&amp;utm_source=infoq&amp;utm_medium=VCR&amp;utm_campaign=vcr_articles_click" target="_blank">首届QCon上海20个专题确认，80余场分享，全面征集演讲主题</a></h3>
<p>相关赞助商
<a href="http://www.infoq.com/infoq/url.action?i=3367&amp;t=f" target="_blank"><img src="" alt=""></a></p>
<p>JavaOne大会独家社区合作，<a href="http://www.infoq.com/infoq/url.action?i=3511&amp;t=f" target="_blank">InfoQ用户享75折购票</a>。 
Store-Load 重排序</p>
<p>Store-Store重排序</p>
<p>Load-Load 和Load-Store重排序</p>
<p>可以更早读取到其它处理器的写</p>
<p>可以更早读取到当前处理器的写 TSO</p>
<p>sparc-TSO</p>
<p>X64</p>
<p>Y</p>
<p>Y PSO</p>
<p>sparc-PSO</p>
<p>Y</p>
<p>Y</p>
<p>Y RMO</p>
<p>ia64</p>
<p>Y</p>
<p>Y</p>
<p>Y</p>
<p>Y PowerPC</p>
<p>PowerPC</p>
<p>Y</p>
<p>Y</p>
<p>Y</p>
<p>Y</p>
<p>Y</p>
<p>在这个表格中，我们可以看到所有处理器内存模型都允许写-读重排序，原因在第一章以说明过：它们都使用了写缓存区，写缓存区可能导致写-读操作重排序。同时，我们可以看到这些处理器内存模型都允许更早读到当前处理器的写，原因同样是因为写缓存区：由于写缓存区仅对当前处理器可见，这个特性导致当前处理器可以比其他处理器先看到临时保存在自己的写缓存区中的写。</p>
<p>上面表格中的各种处理器内存模型，从上到下，模型由强变弱。越是追求性能的处理器，内存模型设计的会越弱。因为这些处理器希望内存模型对它们的束缚越少越好，这样它们就可以做尽可能多的优化来提高性能。</p>
<p>由于常见的处理器内存模型比JMM要弱，java编译器在生成字节码时，会在执行指令序列的适当位置插入内存屏障来限制处理器的重排序。同时，由于各种处理器内存模型的强弱并不相同，为了在不同的处理器平台向程序员展示一个一致的内存模型，JMM在不同的处理器中需要插入的内存屏障的数量和种类也不相同。下图展示了JMM在不同处理器内存模型中需要插入的内存屏障的示意图：</p>
<p><img src="" alt=""></p>
<p>如上图所示，JMM屏蔽了不同处理器内存模型的差异，它在不同的处理器平台之上为java程序员呈现了一个一致的内存模型。</p>
<h2 id="jmm-">JMM，处理器内存模型与顺序一致性内存模型之间的关系</h2>
<p>JMM是一个语言级的内存模型，处理器内存模型是硬件级的内存模型，顺序一致性内存模型是一个理论参考模型。下面是语言内存模型，处理器内存模型和顺序一致性内存模型的强弱对比示意图：</p>
<p><img src="" alt=""></p>
<p>从上图我们可以看出：常见的4种处理器内存模型比常用的3中语言内存模型要弱，处理器内存模型和语言内存模型都比顺序一致性内存模型要弱。同处理器内存模型一样，越是追求执行性能的语言，内存模型设计的会越弱。</p>
<h2 id="jmm-">JMM的设计</h2>
<p>从JMM设计者的角度来说，在设计JMM时，需要考虑两个关键因素：</p>
<ul>
<li>程序员对内存模型的使用。程序员希望内存模型易于理解，易于编程。程序员希望基于一个强内存模型来编写代码。</li>
<li>编译器和处理器对内存模型的实现。编译器和处理器希望内存模型对它们的束缚越少越好，这样它们就可以做尽可能多的优化来提高性能。编译器和处理器希望实现一个弱内存模型。</li>
</ul>
<p>由于这两个因素互相矛盾，所以JSR-133专家组在设计JMM时的核心目标就是找到一个好的平衡点：一方面要为程序员提供足够强的内存可见性保证；另一方面，对编译器和处理器的限制要尽可能的放松。下面让我们看看JSR-133是如何实现这一目标的。</p>
<p>为了具体说明，请看前面提到过的计算圆面积的示例代码：
double pi = 3.14; //A double r = 1.0; //B double area = pi /<em> r /</em> r; //C</p>
<p>上面计算圆的面积的示例代码存在三个happens- before关系：</p>
<ol>
<li>A happens- before B；</li>
<li>B happens- before C；</li>
<li>A happens- before C；</li>
</ol>
<p>由于A happens- before B，happens- before的定义会要求：A操作执行的结果要对B可见，且A操作的执行顺序排在B操作之前。 但是从程序语义的角度来说，对A和B做重排序即不会改变程序的执行结果，也还能提高程序的执行性能（允许这种重排序减少了对编译器和处理器优化的束缚）。也就是说，上面这3个happens- before关系中，虽然2和3是必需要的，但1是不必要的。因此，JMM把happens- before要求禁止的重排序分为了下面两类：</p>
<ul>
<li>会改变程序执行结果的重排序。</li>
<li>不会改变程序执行结果的重排序。</li>
</ul>
<p>JMM对这两种不同性质的重排序，采取了不同的策略：</p>
<ul>
<li>对于会改变程序执行结果的重排序，JMM要求编译器和处理器必须禁止这种重排序。</li>
<li>对于不会改变程序执行结果的重排序，JMM对编译器和处理器不作要求（JMM允许这种重排序）。</li>
</ul>
<p>下面是JMM的设计示意图：</p>
<p><img src="" alt=""></p>
<p>从上图可以看出两点：</p>
<ul>
<li>JMM向程序员提供的happens- before规则能满足程序员的需求。JMM的happens- before规则不但简单易懂，而且也向程序员提供了足够强的内存可见性保证（有些内存可见性保证其实并不一定真实存在，比如上面的A happens- before B）。</li>
<li>JMM对编译器和处理器的束缚已经尽可能的少。从上面的分析我们可以看出，JMM其实是在遵循一个基本原则：只要不改变程序的执行结果（指的是单线程程序和正确同步的多线程程序），编译器和处理器怎么优化都行。比如，如果编译器经过细致的分析后，认定一个锁只会被单个线程访问，那么这个锁可以被消除。再比如，如果编译器经过细致的分析后，认定一个volatile变量仅仅只会被单个线程访问，那么编译器可以把这个volatile变量当作一个普通变量来对待。这些优化既不会改变程序的执行结果，又能提高程序的执行效率。</li>
</ul>
<h2 id="jmm-">JMM的内存可见性保证</h2>
<p>Java程序的内存可见性保证按程序类型可以分为下列三类：</p>
<ol>
<li>单线程程序。单线程程序不会出现内存可见性问题。编译器，runtime和处理器会共同确保单线程程序的执行结果与该程序在顺序一致性模型中的执行结果相同。</li>
<li>正确同步的多线程程序。正确同步的多线程程序的执行将具有顺序一致性（程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同）。这是JMM关注的重点，JMM通过限制编译器和处理器的重排序来为程序员提供内存可见性保证。</li>
<li>未同步/未正确同步的多线程程序。JMM为它们提供了最小安全性保障：线程执行时读取到的值，要么是之前某个线程写入的值，要么是默认值（0，null，false）。</li>
</ol>
<p>下图展示了这三类程序在JMM中与在顺序一致性内存模型中的执行结果的异同：</p>
<p><img src="" alt=""></p>
<p>只要多线程程序是正确同步的，JMM保证该程序在任意的处理器平台上的执行结果，与该程序在顺序一致性内存模型中的执行结果一致。</p>
<h2 id="jsr-133-">JSR-133对旧内存模型的修补</h2>
<p>JSR-133对JDK5之前的旧内存模型的修补主要有两个：</p>
<ul>
<li>增强volatile的内存语义。旧内存模型允许volatile变量与普通变量重排序。JSR-133严格限制volatile变量与普通变量的重排序，使volatile的写-读和锁的释放-获取具有相同的内存语义。</li>
<li>增强final的内存语义。在旧内存模型中，多次读取同一个final变量的值可能会不相同。为此，JSR-133为final增加了两个重排序规则。现在，final具有了初始化安全性。</li>
</ul>
<h2 id="-">参考文献</h2>
<ol>
<li><a href="http://www.amazon.com/Computer-Architecture-Fourth-Quantitative-Approach/dp/0123704901/ref=sr_1_10/102-0116773-7214567?ie=UTF8&amp;s=books&amp;qid=1188797467&amp;sr=1-10" target="_blank">Computer Architecture: A Quantitative Approach, 4th Edition</a></li>
<li><a href="http://www.hpl.hp.com/techreports/Compaq-DEC/WRL-95-7.pdf" target="_blank">Shared memory consistency models: A tutorial</a></li>
<li><a href="http://www.intel.com/content/dam/www/public/us/en/documents/manuals/itanium-architecture-software-developer-rev-2-3-vol-2-manual.pdf" target="_blank">Intel® Itanium® Architecture Software Developer’s Manual Volume 2: System Architecture</a></li>
<li><a href="http://www.amazon.com/Concurrent-Programming-Windows-Joe-Duffy/dp/032143482X/ref=sr_1_1?ie=UTF8&amp;s=books&amp;qid=1262571776&amp;sr=1-1" target="_blank">Concurrent Programming on Windows</a></li>
<li><a href="http://www.cs.umd.edu/users/pugh/java/memoryModel/jsr-133-faq.html" target="_blank">JSR 133 (Java Memory Model) FAQ</a></li>
<li><a href="http://gee.cs.oswego.edu/dl/jmm/cookbook.html" target="_blank">The JSR-133 Cookbook for Compiler Writers</a></li>
<li><a href="http://www.ibm.com/developerworks/java/library/j-jtp03304/index.html" target="_blank">Java theory and practice: Fixing the Java Memory Model, Part 2</a></li>
</ol>
<h2 id="-">关于作者</h2>
<p><strong>程晓明</strong>，Java软件工程师，国家认证的系统分析师、信息项目管理师。专注于并发编程，就职于富士通南大。个人邮箱：<a href="mailto:asst2003@163.com">asst2003@163.com</a>。</p>
<ul>
<li><a href="">Sections</a></li>
<li><a href="http://www.infoq.com/cn/architecture-design" target="_blank"><strong>架构 &amp; 设计</strong></a></li>
<li><a href="http://www.infoq.com/cn/development" target="_blank"><strong>语言 &amp; 开发</strong></a></li>
<li><a href="">Topics</a></li>
<li><a href="http://www.infoq.com/cn/Multi-threading" target="_blank">多线程</a></li>
<li><a href="http://www.infoq.com/cn/memory-model" target="_blank">内存模型</a></li>
<li><a href="http://www.infoq.com/cn/concurrency" target="_blank">并发</a></li>
<li><a href="http://www.infoq.com/cn/java" target="_blank">Java</a></li>
<li><a href="http://www.infoq.com/cn/special-column" target="_blank">专栏</a></li>
</ul>
<p>相关内容</p>
<h3 id="-java-final-http-www-infoq-com-cn-articles-java-memory-model-6-utm_source-infoq-utm_medium-related_content_link-utm_campaign-relatedcontent_articles_clk-"><a href="http://www.infoq.com/cn/articles/java-memory-model-6?utm_source=infoq&amp;utm_medium=related_content_link&amp;utm_campaign=relatedContent_articles_clk" target="_blank">深入理解Java内存模型（六）——final</a></h3>
<h3 id="-java-http-www-infoq-com-cn-articles-java-memory-model-5-utm_source-infoq-utm_medium-related_content_link-utm_campaign-relatedcontent_articles_clk-"><a href="http://www.infoq.com/cn/articles/java-memory-model-5?utm_source=infoq&amp;utm_medium=related_content_link&amp;utm_campaign=relatedContent_articles_clk" target="_blank">深入理解Java内存模型（五）——锁</a></h3>
<h3 id="-java-volatile-http-www-infoq-com-cn-articles-java-memory-model-4-utm_source-infoq-utm_medium-related_content_link-utm_campaign-relatedcontent_articles_clk-"><a href="http://www.infoq.com/cn/articles/java-memory-model-4?utm_source=infoq&amp;utm_medium=related_content_link&amp;utm_campaign=relatedContent_articles_clk" target="_blank">深入理解Java内存模型（四）——volatile</a></h3>
<h3 id="-java-http-www-infoq-com-cn-articles-java-memory-model-3-utm_source-infoq-utm_medium-related_content_link-utm_campaign-relatedcontent_articles_clk-"><a href="http://www.infoq.com/cn/articles/java-memory-model-3?utm_source=infoq&amp;utm_medium=related_content_link&amp;utm_campaign=relatedContent_articles_clk" target="_blank">深入理解Java内存模型（三）——顺序一致性</a></h3>
<h3 id="-java-http-www-infoq-com-cn-articles-java-memory-model-2-utm_source-infoq-utm_medium-related_content_link-utm_campaign-relatedcontent_articles_clk-"><a href="http://www.infoq.com/cn/articles/java-memory-model-2?utm_source=infoq&amp;utm_medium=related_content_link&amp;utm_campaign=relatedContent_articles_clk" target="_blank">深入理解Java内存模型（二）——重排序</a></h3>
<h2 id="-">您好，陌生人！</h2>
<p>您需要 <a href="http://www.infoq.com/reginit.action" target="_blank">注册一个InfoQ账号</a> 或者 <a href="">登录</a> 才能进行评论。在您完成注册后还需要进行一些设置。</p>
<h2 id="-infoq-">获得来自InfoQ的更多体验。 <a href=""></a></h2>
<h3 id="-">告诉我们您的想法</h3>
<p>允许的HTML标签: a,b,br,blockquote,i,li,pre,u,ul,p
当有人回复此评论时请E-mail通知我</p>
<p>社区评论  <a href="">Watch Thread</a></p>
<p><a href=""><strong>看完后有两点疑问，请教一下：</strong>  by Z CS Posted 21/03/2013 07:37</a>
<a href=""><strong>Re: 看完后有两点疑问，请教一下：</strong>  by 程 晓明 Posted 23/03/2013 12:50</a></p>
<p><a href=""><strong>编译器什么时候插入内存屏障？</strong>  by 黄 春 Posted 10/04/2013 12:49</a>
<a href=""><strong>Re: 编译器什么时候插入内存屏障？</strong>  by 程 晓明 Posted 14/04/2013 11:01</a>
<a href=""></a></p>
<p><strong>看完后有两点疑问，请教一下：</strong>  21/03/2013 07:37 by Z CS</p>
<ol>
<li>文中所写的 “未同步/未正确同步的多线程程序。JMM为它们提供了最小安全性保障：线程执行时读取到的值，要么是之前某个线程写入的值，要么是默认值（0，null，false）。”，JSR-133 真的做到这样了么? 那 么 long和double的 读写 的非原子性是怎么回事啊？是不是矛盾啊？</li>
<li>关于本文中最后“JSR-133为final增加了两个重排序规则。现在，final具有了初始化安全性。”，这句话，是不是也还要加上那个 前提“保证final引用不从构造函数内逸出”，final才能具有“初始化安全性”啊？</li>
</ol>
<ul>
<li><a href="">回复</a></li>
<li><a href="">回到顶部</a></li>
</ul>
<p><a href=""></a></p>
<p><strong>Re: 看完后有两点疑问，请教一下：</strong>  23/03/2013 12:50 by 程 晓明</p>
<p>谢谢您的关注。
/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>
问题1
最小安全性与64位数据的非原子性读/写并不矛盾。
它们是两个不同的概念，它们“发生”的时间点也不同。
最小安全性保证对象默认初始化之后（设置成员域为0，null或false），才会被任意线程使用。
最小安全性“发生”在对象被任意线程使用之前。
64位数据的非原子性读/写“发生”在对象被多个线程使用的过程中（读/写共享变量）。
当发生《本文三》末尾的那种问题时（处理器B看到仅仅被处理器A“写了一半“的无效值），
这里虽然处理器B读取到一个被写了一半的无效值，但这个值任然是处理器A写入的，只不过处理器A还没有写完而已。
最小安全性保证线程读取到的值，要么是之前某个线程写入的值，要么是默认值（0，null，false）。
但最小安全性并不保证线程读取到的共享变量的值，一定是某个线程写完后的值。
最小安全性保证线程读取到的值不会无中生有的冒出来，但并不保证线程读取到的值一定是正确的。
/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/*
问题2
是的，你的理解是对的。
这句话也要加上那个前提：“保证final引用不从构造函数内逸出”，final才能具有“初始化安全性”。</p>
<ul>
<li><a href="">回复</a></li>
<li><a href="">回到顶部</a>
<a href=""></a></li>
</ul>
<p><strong>编译器什么时候插入内存屏障？</strong>  10/04/2013 12:49 by 黄 春</p>
<p>厚积薄发之做。 明白了很多不解的地方。 这里有个问题想问下。 文中说“java编译器在生成字节码时，会在执行指令序列的适当位置插入内存屏障来限制处理器的重排序”。 这里有个问题请教。
插入内存屏障， 是在编译成字节码的时候完成， 还是在JIT执行的时候重新调整指令生成的？ 或者JIT只生产本地代码， 跟插入内存屏障之类的没关系？</p>
<ul>
<li><a href="">回复</a></li>
<li><a href="">回到顶部</a></li>
</ul>
<p><a href=""></a></p>
<p><strong>Re: 编译器什么时候插入内存屏障？</strong>  14/04/2013 11:01 by 程 晓明</p>
<p>Doug Lea在《The JSR-133 Cookbook for Compiler Writers》中，并没有明确指定插入内存屏障的时机。
个人估计，应该是取决于具体的JVM实现。</p>
<ul>
<li><a href="">回复</a></li>
<li><a href="">回到顶部</a></li>
</ul>
<p><a href="">关闭</a></p>
<h3 id="-by"><em>**</em> by</h3>
<p>发布于</p>
<ul>
<li><a href="">查看</a></li>
<li><a href="">回复</a></li>
<li><a href="">回到顶部</a>
<a href="">关闭</a>  主题   您的回复 <a href="">引用原消息</a></li>
</ul>
<p>允许的HTML标签: a,b,br,blockquote,i,li,pre,u,ul,p
当有人回复此评论时请E-mail通知我</p>
<p><a href="">关闭</a>  主题  您的回复</p>
<p>允许的HTML标签: a,b,br,blockquote,i,li,pre,u,ul,p
当有人回复此评论时请E-mail通知我
<a href="">关闭</a></p>
<ul>
<li>热点内容</li>
<li><a href="">本周</a></li>
<li><a href="">本月</a></li>
<li><a href="">近6个月</a><h3 id="-32-http-www-infoq-com-cn-news-2012-08-32-most-important-algorithms-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2012/08/32-most-important-algorithms?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">计算机科学中最重要的32个算法</a></h3>
</li>
</ul>
<h3 id="-thoughtworks-2013-5-http-www-infoq-com-cn-articles-thoughtworks-technology-radar-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/thoughtWorks-technology-radar?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">ThoughtWorks技术雷达（2013年5月）</a></h3>
<h3 id="-1-5-http-www-infoq-com-cn-articles-iqiyi-cloud-push-practices-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/iqiyi-cloud-push-practices?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">让1.5亿移动端用户第一时间获取消息</a></h3>
<h3 id="-thoughtworks-ceo-http-www-infoq-com-cn-news-2013-06-tw-guoxiao-on-talents-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2013/06/tw-guoxiao-on-talents?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">ThoughtWorks全球CEO郭晓谈软件人才的招聘与培养</a></h3>
<h3 id="-http-www-infoq-com-cn-news-2013-06-10-sins-for-scalability-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2013/06/10-sins-for-scalability?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">影响可扩展性的十宗罪</a></h3>
<h3 id="-6-http-www-infoq-com-cn-minibooks-architect-jun-10-2013-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/architect-jun-10-2013?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">架构师（6月刊）</a></h3>
<h3 id="-http-www-infoq-com-cn-articles-function-switch-realize-better-continuous-implementations-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/function-switch-realize-better-continuous-implementations?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">使用功能开关更好地实现持续部署</a></h3>
<h3 id="-eclipse-github-http-www-infoq-com-cn-news-2013-06-eclipse-github-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2013/06/eclipse-github?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">Eclipse迁移到GitHub</a></h3>
<h3 id="-newegg-com-http-www-infoq-com-cn-presentations-newegg-big-data-practice-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/presentations/newegg-big-data-practice?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">Newegg.com大数据实践</a></h3>
<h3 id="-http-www-infoq-com-cn-minibooks-software-sys-architect-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/software-sys-architect?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">软件系统架构：使用视点和视角与利益相关者合作</a></h3>
<h3 id="-32-http-www-infoq-com-cn-news-2012-08-32-most-important-algorithms-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2012/08/32-most-important-algorithms?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">计算机科学中最重要的32个算法</a></h3>
<h3 id="-6-http-www-infoq-com-cn-minibooks-architect-jun-10-2013-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/architect-jun-10-2013?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">架构师（6月刊）</a></h3>
<h3 id="-rest-http-www-infoq-com-cn-news-2013-06-rest-drawbacks-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2013/06/rest-drawbacks?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">REST的缺点是什么？</a></h3>
<h3 id="-google-web-ui-polymer-http-www-infoq-com-cn-news-2013-06-webcomponents-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2013/06/webcomponents?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">Google 发布新一代Web UI库Polymer</a></h3>
<h3 id="-http-www-infoq-com-cn-news-2013-06-dianping-xinnet-hacked-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2013/06/dianping-xinnet-hacked?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">大众点评网域名劫持事件概述</a></h3>
<h3 id="-node-js-grunt-js-http-www-infoq-com-cn-articles-gruntjs-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/GruntJs?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">基于Node.js的自动化构建工具Grunt.js</a></h3>
<h3 id="-node-js-node-js-http-www-infoq-com-cn-articles-what-is-nodejs-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/what-is-nodejs?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">深入浅出Node.js（一）：什么是Node.js</a></h3>
<h3 id="-http-www-infoq-com-cn-minibooks-i-m-wrights-hard-code-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/i-m-wrights-hard-code?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">代码之殇·第二版</a></h3>
<h3 id="-http-www-infoq-com-cn-minibooks-software-sys-architect-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/software-sys-architect?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">软件系统架构：使用视点和视角与利益相关者合作</a></h3>
<h3 id="-18-java-http-www-infoq-com-cn-news-2013-06-zhuhong-on-java-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2013/06/zhuhong-on-java?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">大家谈18岁的Java——朱鸿：开过跑车后再去开大巴车总是有点不爽的</a></h3>
<h3 id="-32-http-www-infoq-com-cn-news-2012-08-32-most-important-algorithms-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2012/08/32-most-important-algorithms?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">计算机科学中最重要的32个算法</a></h3>
<h3 id="-java-http-www-infoq-com-cn-articles-java-memory-model-1-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/java-memory-model-1?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">深入理解Java内存模型（一）——基础</a></h3>
<h3 id="-node-js-node-js-http-www-infoq-com-cn-articles-what-is-nodejs-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/what-is-nodejs?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">深入浅出Node.js（一）：什么是Node.js</a></h3>
<h3 id="-node-js-node-js-npm-http-www-infoq-com-cn-articles-nodejs-npm-install-config-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/nodejs-npm-install-config?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">深入浅出Node.js（二）：Node.js&amp;NPM的安装与配置</a></h3>
<h3 id="-3-http-www-infoq-com-cn-minibooks-architect-mar-10-2013-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/architect-mar-10-2013?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">架构师（3月刊）</a></h3>
<h3 id="-1-http-www-infoq-com-cn-minibooks-architect-jan-10-2013-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/architect-jan-10-2013?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">架构师（1月刊）</a></h3>
<h3 id="-4-http-www-infoq-com-cn-minibooks-architect-apr-10-2013-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/architect-apr-10-2013?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">架构师（4月刊）</a></h3>
<h3 id="-java-http-www-infoq-com-cn-articles-java-threadpool-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/java-threadPool?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">聊聊并发（三）——JAVA线程池的分析和使用</a></h3>
<h3 id="-2-http-www-infoq-com-cn-minibooks-architect-feb-10-2013-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/architect-feb-10-2013?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">架构师（2月刊）</a></h3>
<h3 id="-12306-github-http-www-infoq-com-cn-news-2013-01-12306-plugin-ddos-github-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2013/01/12306-plugin-ddos-github?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">12306订票助手插件拖垮GitHub事件原因始末</a></h3>
<h2 id="-">深度内容</h2>
<ul>
<li><a href="">全部</a></li>
<li><a href="">文章</a></li>
<li><a href="">演讲</a></li>
<li><a href="">访谈</a></li>
<li><a href="">迷你书</a><h2 id="-juergen-fesslmeier-javascript-http-www-infoq-com-cn-interviews-end-to-end-javascript-juergen-fesslmeier-javascript-"><a href="http://www.infoq.com/cn/interviews/end-to-end-javascript" title="Juergen Fesslmeier谈端到端的JavaScript开发" target="_blank">Juergen Fesslmeier谈端到端的JavaScript开发</a></h2>
</li>
</ul>
<p><a href="http://www.infoq.com/cn/author/Juergen-Fesslmeier" title="Juergen Fesslmeier" target="_blank">Juergen Fesslmeier</a> 七月 02, 2013</p>
<p><a href="http://www.infoq.com/cn/interviews/end-to-end-javascript" title="Juergen Fesslmeier谈端到端的JavaScript开发" target="_blank"><img src="" alt=""></a></p>
<h2 id="-http-www-infoq-com-cn-articles-design-pattern-automation-"><a href="http://www.infoq.com/cn/articles/Design-Pattern-Automation" title="设计模式自动化" target="_blank">设计模式自动化</a></h2>
<p><a href="http://www.infoq.com/cn/author/Gael-Fraiteur-and-Yan-Cui" title="Gael Fraiteur and Yan Cui" target="_blank">Gael Fraiteur and Yan Cui</a> 七月 01, 2013</p>
<p><a href="http://www.infoq.com/cn/articles/Design-Pattern-Automation" title="设计模式自动化" target="_blank"><img src="" alt=""></a></p>
<h2 id="-http-www-infoq-com-cn-articles-designing-a-world-at-your-fingertips-mobile-user-interfaces-"><a href="http://www.infoq.com/cn/articles/designing-a-world-at-your-fingertips-mobile-user-interfaces" title="设计指尖上的世界：移动用户界面一瞥" target="_blank">设计指尖上的世界：移动用户界面一瞥</a></h2>
<p><a href="http://www.infoq.com/cn/author/Forrest-Shull" title="Forrest Shull" target="_blank">Forrest Shull</a> 六月 28, 2013</p>
<p><a href="http://www.infoq.com/cn/articles/designing-a-world-at-your-fingertips-mobile-user-interfaces" title="设计指尖上的世界：移动用户界面一瞥" target="_blank"><img src="" alt=""></a></p>
<h2 id="-alm-http-www-infoq-com-cn-articles-integrated-alm-alm-"><a href="http://www.infoq.com/cn/articles/Integrated-ALM" title="成功的根本—集成的ALM工具" target="_blank">成功的根本—集成的ALM工具</a></h2>
<p><a href="http://www.infoq.com/cn/author/Dave-West" title="Dave West" target="_blank">Dave West</a> 六月 28, 2013</p>
<p><a href="http://www.infoq.com/cn/articles/Integrated-ALM" title="成功的根本—集成的ALM工具" target="_blank"><img src="" alt=""></a></p>
<h2 id="-http-www-infoq-com-cn-articles-atdd-by-example-book-"><a href="http://www.infoq.com/cn/articles/atdd-by-example-book" title="书评：验收测试驱动开发实践指南" target="_blank">书评：验收测试驱动开发实践指南</a></h2>
<p><a href="http://www.infoq.com/cn/author/Manuel-Pais" title="Manuel Pais" target="_blank">Manuel Pais</a> 六月 26, 2013</p>
<p><a href="http://www.infoq.com/cn/articles/atdd-by-example-book" title="书评：验收测试驱动开发实践指南" target="_blank"><img src="" alt=""></a></p>
<h2 id="-web-http-www-infoq-com-cn-presentations-across-device-web-web-"><a href="http://www.infoq.com/cn/presentations/across-device-web" title="跨终端的web" target="_blank">跨终端的web</a></h2>
<p><a href="http://www.infoq.com/cn/author/%E8%88%92%E6%96%87%E4%BA%AE" title="舒文亮" target="_blank">舒文亮</a> 六月 26, 2013</p>
<p><a href="http://www.infoq.com/cn/presentations/across-device-web" title="跨终端的web" target="_blank"><img src="" alt=""></a></p>
<ul>
<li><a href="">更早的 &gt;</a></li>
</ul>
<p>赞助商链接</p>
<h3 id="infoq-">InfoQ每周精要</h3>
<p>通过个性化定制的新闻邮件、RSS Feeds和InfoQ业界邮件通知，保持您对感兴趣的社区内容的时刻关注。
<a href="http://www.infoq.com/cn/newsletter_sample.html" target="_blank"><img src="" alt=""></a></p>
<p>语言 &amp; 开发</p>
<p><a href="http://www.infoq.com/cn/interviews/end-to-end-javascript" title="Juergen Fesslmeier谈端到端的JavaScript开发" target="_blank">Juergen Fesslmeier谈端到端的JavaScript开发</a></p>
<p><a href="http://www.infoq.com/cn/news/2013/07/mobilecloud-tfs" title="MobileCloud for TFS支持测试Windows Phone,Android,iOS及BlackBerry应用" target="_blank">MobileCloud for TFS支持测试Windows Phone,Android,iOS及BlackBerry应用</a></p>
<p><a href="http://www.infoq.com/cn/news/2013/07/baidu-salon39-summary" title="百度技术沙龙第39期回顾：前端快速开发实践（含资料下载）" target="_blank">百度技术沙龙第39期回顾：前端快速开发实践（含资料下载）</a></p>
<p>架构 &amp; 设计</p>
<p><a href="http://www.infoq.com/cn/news/2013/07/Native-Performance" title="内存与本机代码的性能" target="_blank">内存与本机代码的性能</a></p>
<p><a href="http://www.infoq.com/cn/articles/Design-Pattern-Automation" title="设计模式自动化" target="_blank">设计模式自动化</a></p>
<p><a href="http://www.infoq.com/cn/news/2013/07/WinRT-Devices" title="连接设备编程" target="_blank">连接设备编程</a>
过程 &amp; 实践</p>
<p><a href="http://www.infoq.com/cn/articles/Integrated-ALM" title="成功的根本—集成的ALM工具" target="_blank">成功的根本—集成的ALM工具</a></p>
<p><a href="http://www.infoq.com/cn/news/2013/06/tw-guoxiao-on-talents" title="ThoughtWorks全球CEO郭晓谈软件人才的招聘与培养" target="_blank">ThoughtWorks全球CEO郭晓谈软件人才的招聘与培养</a></p>
<p><a href="http://www.infoq.com/cn/articles/atdd-by-example-book" title="书评：验收测试驱动开发实践指南" target="_blank">书评：验收测试驱动开发实践指南</a></p>
<p>运维 &amp; 基础架构</p>
<p><a href="http://www.infoq.com/cn/news/2013/06/devops-in-traditional-enterprise" title="在传统企业中引入DevOps" target="_blank">在传统企业中引入DevOps</a></p>
<p><a href="http://www.infoq.com/cn/news/2013/06/dod-ams-day1-s-is-for-security" title="安全性——“DevOpS”中的S" target="_blank">安全性——“DevOpS”中的S</a></p>
<p><a href="http://www.infoq.com/cn/articles/atdd-by-example-book" title="书评：验收测试驱动开发实践指南" target="_blank">书评：验收测试驱动开发实践指南</a>
企业架构</p>
<p><a href="http://www.infoq.com/cn/articles/designing-a-world-at-your-fingertips-mobile-user-interfaces" title="设计指尖上的世界：移动用户界面一瞥" target="_blank">设计指尖上的世界：移动用户界面一瞥</a></p>
<p><a href="http://www.infoq.com/cn/news/2013/06/stratos-2" title="Stratos 2.0已发布，支持所有运行时环境和30个IaaS" target="_blank">Stratos 2.0已发布，支持所有运行时环境和30个IaaS</a></p>
<p><a href="http://www.infoq.com/cn/articles/iqiyi-cloud-push-practices" title="让1.5亿移动端用户第一时间获取消息" target="_blank">让1.5亿移动端用户第一时间获取消息</a></p>
<ul>
<li><a href="http://www.infoq.com/cn/" title="首页" target="_blank">首页</a></li>
<li><a href="http://www.infoq.com/cn/topics" title="全部话题" target="_blank">全部话题</a></li>
<li><a href="http://www.qconferences.com/" title="QCon全球软件开发大会" target="_blank">QCon全球软件开发大会</a></li>
<li><a href="http://www.infoq.com/cn/aboutus" title="关于我们" target="_blank">关于我们</a></li>
<li><a href="http://www.infoq.com/cn/contribute" title="让大家在InfoQ上听见你的声音" target="_blank">让大家在InfoQ上听见你的声音</a></li>
<li><a href="http://www.infoq.com/cn/reginit.action" title="创建账号" target="_blank">创建账号</a></li>
<li><p><a href="&quot;登录&quot;">登录</a></p>
</li>
<li><p><strong>会议</strong></p>
</li>
<li><a href="http://www.qconshanghai.com/" title="技术大会：QCon上海2013，11月1-3日 " target="_blank">QCon全球软件开发大会（上海站）2013，11月1-3日</a><h3 id="infoq-">InfoQ每周精要</h3>
</li>
</ul>
<p>通过个性化定制的新闻邮件、RSS Feeds和InfoQ业界邮件通知，保持您对感兴趣的社区内容的时刻关注。</p>
<p><a href="http://www.infoq.com/cn/newsletter_sample.html" target="_blank"><img src="" alt=""></a></p>
<ul>
<li><a href="http://www.infoq.com/cn/rss/rss.action?token=AjlwmaWcwi5ejkcT6GcRk1pCqJ4K7ocs" target="_blank">属于您的个性化RSS</a></li>
<li><a href="http://weibo.com/infoqchina" target="_blank">新浪微博</a></li>
<li><a href="http://www.facebook.com/InfoQ" target="_blank">社区新闻和热点</a></li>
</ul>
<p>特别专题</p>
<ul>
<li><a href="http://www.infoq.com/cn/chinaitevents" target="_blank"><strong>技术社区活动日历</strong></a></li>
<li><a href="http://www.infoq.com/cn/zones/baidu-salon/" target="_blank"><strong>百度技术沙龙</strong></a></li>
<li><a href="http://www.infoq.com/cn/scrum/" target="_blank"><strong>Scrum开发</strong></a></li>
<li><a href="http://www.infoq.com/cn/architect/" target="_blank"><strong>月刊：《架构师》</strong></a></li>
<li><a href="http://www.infoq.com/cn/qclub/" target="_blank"><strong>线下活动：QClub</strong></a>
定制您感兴趣的技术领域</li>
</ul>
<p>语言 &amp; 开发 架构 &amp; 设计 过程 &amp; 实践 运维 &amp; 基础架构 企业架构
提供反馈</p>
<p><a href="mailto:feedback@cn.infoq.com">feedback@cn.infoq.com</a>
 错误报告</p>
<p><a href="mailto:bugs@cn.infoq.com">bugs@cn.infoq.com</a>
 商务合作</p>
<p><a href="mailto:sales@cn.infoq.com">sales@cn.infoq.com</a>
 内容合作</p>
<p><a href="mailto:editors@cn.infoq.com">editors@cn.infoq.com</a>
 InfoQ.com及所有内容，版权所有 © 2006-2013 C4Media Inc. InfoQ.com 服务器由 <a href="http://www.contegix.com/" target="_blank">Contegix</a>提供, 我们最信赖的ISP合作伙伴。
<a href="http://www.infoq.com/cn/privacypolicy" target="_blank">隐私政策</a></p>
<p><a href="">Close</a>  E-mail  密码</p>
<p><a href="http://www.infoq.com/cn/social/googleLogin.action?fl=login" title="使用Google账号登录" target="_blank">使用Google账号登录</a>  <a href="http://www.infoq.com/cn/social/liveLogin.action?fl=login" title="使用Microsoft账号登录" target="_blank">使用Microsoft账号登录</a>
<a href="">忘记密码？</a>
   InfoQ账号使用的E-mail  发送邮件</p>
<p><a href="">重新登录</a>
重新发送激活信息  重新发送</p>
<p><a href="">重新登录</a>
<a href="http://www.infoq.com/cn/reginit.action" target="_blank">没有用户名？</a></p>
<p><a href="http://www.infoq.com/cn/reginit.action" target="_blank">点击注册</a></p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/Java_多线程/">Java_多线程</a></li><li><a href="/categories/Java&J2EE/Java_多线程/内存/">内存</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/Java_多线程/" class="label label-success">Java_多线程</a><a href="/tags/内存/" class="label label-info">内存</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:41"datetime="2014-03-07 09:54:41"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-Java_多线程-内存--深入理解Java内存模型（七）——总结/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-Java_多线程-内存--深入理解Java内存模型（七）——总结" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>





<ul id="pagination" class="pagination pagination-lg">
  <li><a class="extend prev" href="/page/63/">&laquo;</a></li><li><a class="page-number" href="/">1</a></li><li><a class="page-number" href="/page/2/">2</a></li><li><span class="space">&hellip;</span></li><li><a class="page-number" href="/page/61/">61</a></li><li><a class="page-number" href="/page/62/">62</a></li><li><a class="page-number" href="/page/63/">63</a></li><li class="active"><li><span class="page-number current">64</span></li><li><a class="page-number" href="/page/65/">65</a></li><li><a class="page-number" href="/page/66/">66</a></li><li><a class="page-number" href="/page/67/">67</a></li><li><span class="space">&hellip;</span></li></li><li><a class="page-number" href="/page/164/">164</a></li><li><a class="page-number" href="/page/165/">165</a></li><li><a class="extend next" href="/page/65/">&raquo;</a></li>
  <div class="clearfix"></div>
</ul></div><!--wapper-->
       </div><!-- ID main-col END -->
       <aside id="sidebar" class="alignright col-sx-6 col-sm-4 col-md-3 col-lg-3">
<div id="widget_search" class="widget panel panel-primary">
    <form action="//google.com/search" method="get" accept-charset="utf-8">
  <div class="input-group">
    <input class="form-control" id="searchbox" type="search" name="q" results="0" placeholder="search">
    <span class="input-group-btn">
      <button class="btn btn-default" type="submit">Go!</button>
    </span>
    <input type="hidden" name="q" value="site:itsolife.com">
  </div>
</form>
</div>

<div id="widget_category" class="widget panel panel-primary">
  <div class="panel-heading">category</div>  <div data-src='category' class='ajax_widgets'>正在加载...</div>
</div>

<div id="widget_recent_posts" class="widget panel panel-primary">
  <div class="panel-heading">recent posts</div>  <div data-src='recent_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_tagcloud" class="widget panel panel-primary">
  <div class="panel-heading">tagcloud</div>  <div data-src='tagcloud' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_latest_update_posts" class="widget panel panel-primary">
  <div class="panel-heading">最近更新</div>  <div data-src='latest_update_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_recent_comments" class="widget panel panel-primary">
  <div class="panel-heading">recent comments</div>  

<div class="list-group-item ds-recent-comments" data-num-items="6" data-show-avatars="1" data-show-time="1" data-show-title="1" data-show-admin="1" data-excerpt-length="50"></div>



</div>

</aside>
       <div class="clearfix"></div>
     </div><!-- row END -->
  </div>
  <footer id="footer" class="container">
  <div class="panel panel-info">
  <section id='footer_widget'></section>  <div class="panel-footer">
  <div id="site-info">
    <span class='author'>
  
  &copy; 2014 RobinChia
  
    &nbsp;&nbsp;</span>
  
  <span id='analytics-51la'></span><span id='analytics-google'>
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-48559895-1']);
  _gaq.push(['_trackPageview']);
  _js2load.push({src:('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'});
</script></span><span id='analytics-cnzz'>
<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_5774006'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s17.cnzz.com/stat.php%3Fid%3D5774006%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>
</span><span id='analytics-baidu'>
<script>
var _hmt = _hmt || [];
_js2load.push({src:"//hm.baidu.com/hm.js?1442f50724afc42380b51f097c43082c"});
</script>
</span>  </div>
  <div id="copyright">Blog powered by <a href='http://zespia.tw/hexo/'><strong>hexo</strong></a> Theme <strong><a href='https://github.com/chenall/hexo-theme-chenall'>chenall</a></strong>(Some change in it)<span class="pull-right"> 更新时间: <em>2014-03-15 13:06:28</em></span></div>
</div>
<div class="clearfix"></div>


  </div>
  </footer>
  
        <script src="http://cdn.bootcss.com/jquery/1.10.2/jquery.min.js"></script>        
        <script src="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/js/bootstrap.min.js"></script>        
                
        <script src="http://cdn.bootcss.com/prettify/r298/prettify.min.js"></script>    <script type="text/javascript">
   var lang=["bsh", "c", "cc", "cpp", "cs", "csh", "cyc", "cv", "htm", "html",
    "java", "js", "m", "mxml", "perl", "pl", "pm", "py", "rb", "sh",
    "xhtml", "xml", "xsl"];
   var pretty_base='';
   $('script').each(function(){
	var c = $(this).attr('src');
	if (!c)
	    return;
	if (c.match(/(\/)?prettify(\.min)?\.js/i))
	{
	    var index = c.lastIndexOf('/');
	    if (index != -1)
		pretty_base = c.substr(0,index + 1);
	    return false;
	}
   })
   $('pre code').each(function(){
	var c = $(this).attr('class')
	if (!c)
	    return;
	c = c.match(/\s?(lang\-\w+)/i);
	if (c && lang.indexOf(c[1]) == -1)
	{
	    lang.push(c[1]);
	    $.getScript(pretty_base + c[1] + '.min.js');
	}
   })

    $(window).load(function(){
       $("pre").addClass("prettyprint");
       prettyPrint();
    })
</script>    
            <script type="text/javascript">
var duoshuoQuery = {short_name:"robinchia"};
_js2load.push({src:'http://static.duoshuo.com/embed.js',charset:'UTF-8'});
</script>
    
            <!--wumii_relatedItems-->
    
        <script src="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js"></script>    <script type="text/javascript">
(function($){
  $('.entry').each(function(i){
    $(this).find('img').each(function(){
      var alt = this.alt;

      if (alt){
        $(this).before('<span class="caption">' + alt + '</span>');
      }

      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox" rel="fancybox' + i + '" />');
    });
  });

  $('.fancybox').fancybox();
})(jQuery);
</script>    
        <script src="http://cdn.bootcss.com/mathjax/2.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>    <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>
    
<script type="text/javascript">
$('.ajax_widgets').each(function(){var src=$(this).attr('data-src');if(src)$(this).load('/widgets/'+src+'.html');});
$.each(_js2load,function(index,obj){loadjs(obj.src,obj.charset)});
</script>

<div id="scroll2top">
<img src="/scroll2top/arrow.png"/>
</div>
<script src="/scroll2top/scroll2top.min.js"></script>
<div id="winterland">
  <canvas></canvas>
</div>
<script src="/js/winterland.min.js"></script>

  </body>
</html>
