
<!DOCTYPE HTML>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>The 80 Page | It so life</title>
<meta name="author" content="RobinChia">

<meta name="description" content="It so life">


<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<meta property="og:site_name" content="It so life"/>

<!--[if IE]><style>.testIE.IE{display:inline;}</style><![endif]-->
<!--[if lte IE 7]><link rel="stylesheet" href="/css/ie7.css" type="text/css"><![endif]-->
<!--[if (lt IE 9)&(gt IE 7)]><style>.testIE.IE8{display:inline;}</style><![endif]-->
<!--[if gt IE 8]><style>.testIE.IE9{display:inline;}</style><![endif]-->

<link href="/favicon.png" rel="icon">
<link rel="alternate" href="/atom.xml" title="It so life Feed" type="application/atom+xml">

<link rel="stylesheet" href="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/css/bootstrap.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/font-awesome/4.0.3/css/font-awesome.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/prettify/r298/prettify.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" type="text/css">
<link rel="stylesheet" href="/css/style.css" type="text/css">
<!--[if lt IE 9]>
   <style>article,aside,dialog,footer,header,section,footer,nav,figure,menu{display:block}</style>
   <script src="http://cdn.staticfile.org/html5shiv/r29/html5.min.js"></script>
   <script src="http://cdn.staticfile.org/respond.js/1.4.2/respond.min.js"></script>
<link href="http://cdn.staticfile.org/respond.js/1.4.2/respond-proxy.html" id="respond-proxy" rel="respond-proxy" />
<link href="/js/respond.proxy.gif" id="respond-redirect" rel="respond-redirect" />
<script src="/js/respond.proxy.js"></script>
   <script src="http://cdn.bootcss.com/selectivizr/1.0.2/selectivizr-min.js"></script>
<![endif]-->
<script type="text/javascript">
function loadjs(c,d){var a=document.createElement("script");a.async=!0;a.type="text/javascript";a.src=c;a.charset=d||"gbk";(document.getElementsByTagName("HEAD")[0]||document.getElementsByTagName("BODY")[0]).appendChild(a)};
var _protocol = (("https:" == document.location.protocol) ? " https://" : " http://");
var _js2load = [];
</script>

</head>
<body>
      <header id="header" class="container"><nav id="main-nav" class="navbar navbar-default navbar-fixed-top " role="navigation">
  <div class="container">
    <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
      <span class="sr-only">Toggle navigation</span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="/">It so life</a>
    </div>
    <div  class="collapse navbar-collapse">
      <ul  class="nav navbar-nav">
  
        <li><a href="/" title="Home">Home</a></li>      
        <li><a href="/about/" title="About">About</a></li>      
        <li><a href="/archives/" title="Archives">Archives</a></li>      
      <li class='dropdown'>
        <a class='dropdown-toggle' data-toggle='dropdown' href='#'>website<b class='caret'></b></a>
        <ul class='dropdown-menu pure-menu-selected'>
    
          <li><a href="//groups.google.com/forum/#!forum/pongba" title="TopLanguage">TopLanguage</a></li>    
          <li><a href="//itpub.net/" title="ITPub">ITPub</a></li>    
          <li><a href="//blog.jobbole.com/" title="Bole">Bole</a></li>    
          <li><a href="//nosql-database.org/" title="nosql">nosql</a></li>    
          <li><a href="//gitimmersion.googol.im/" title="Git">Git</a></li>    
        </ul>
      </li>
    
      </ul>
      <ul class="nav navbar-nav navbar-right">
      
        <li><a href="/atom.xml">RSS</a></li>
      
      
        <li><a href="https://twitter.com/robinchia">twitter</a></li>
      
      
      
      
        <li><a href="https://github.com/robinchia">github</a></li>
      
      </ul>
    </div>
  </div>
</nav>
<div class="clearfix"></div>
</header>
  <div id='content' class="container">
     <div class="page-header-wrapper">
      <!--[if lt IE 9]><div class="alert alert-warning alert-dismissable"><button type="button" class="close" data-dismiss="alert" aria-hidden="true">&times;</button><strong>提示:</strong>您的浏览器版本太低了,建议升级到 <strong><a href="http://windows.microsoft.com/zh-cn/internet-explorer/download-ie" title="IE9">IE9</a></strong> 以上,本站使用<a href="https://www.google.com/intl/zh-CN/chrome/">Chrome浏览器</a>可以获得最好的显示效果.</div><![endif]-->
      <div class="page-header"><h1 align="center"><big>It so life</big> </h1>
        <h5 align="center"><big>love as life</big></h5>
      </div>
     </div>
     <div class="row">
       <div id="main-col" class="alignleft col-sx-12 col-sm-8 col-md-9 col-lg-9">
      <section id='header_widget'></section>
          <div id="wrapper"><article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-缓存-ehcache--Ehcache详细解读-四火的BLOG-ITeye技术网站/">Ehcache详细解读 </a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:39.000Z"> <a href="/2014/02/02/2014-02-02-缓存-ehcache--Ehcache详细解读-四火的BLOG-ITeye技术网站/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="ehcache-blog-iteye-">Ehcache详细解读 - 四火的BLOG - ITeye技术网站</h1>
<p><a href="http://www.iteye.com/" target="_blank">首页</a> <a href="http://www.iteye.com/news" target="_blank">资讯</a> <a href="http://www.iteye.com/magazines" target="_blank">精华</a> <a href="http://www.iteye.com/forums" target="_blank">论坛</a> <a href="http://www.iteye.com/ask" target="_blank">问答</a> <a href="http://www.iteye.com/blogs" target="_blank">博客</a> <a href="http://www.iteye.com/blogs/subjects" target="_blank">专栏</a> <a href="http://www.iteye.com/groups" target="_blank">群组</a> <a href="http://raychase.iteye.com/blog/1545906#" target="_blank">更多 ▼</a></p>
<p><a href="http://www.iteye.com/job" target="_blank">招聘</a> <a href="http://www.iteye.com/search" target="_blank">搜索</a></p>
<p><a href="http://raychase.iteye.com/login" title="登录" target="_blank">您还未登录 !</a> <a href="http://raychase.iteye.com/login" target="_blank">登录</a> <a href="http://raychase.iteye.com/signup" target="_blank">注册</a></p>
<h1 id="-blog-http-raychase-iteye-com-"><a href="http://raychase.iteye.com/" target="_blank">四火的BLOG</a></h1>
<ul>
<li><a href="http://raychase.iteye.com/" target="_blank"><strong>博客</strong></a></li>
<li><a href="http://raychase.iteye.com/weibo" target="_blank">微博</a></li>
<li><a href="http://raychase.iteye.com/album" target="_blank">相册</a></li>
<li><a href="http://raychase.iteye.com/link" target="_blank">收藏</a></li>
<li><a href="http://raychase.iteye.com/blog/guest_book" target="_blank">留言</a></li>
<li><a href="http://raychase.iteye.com/blog/profile" target="_blank">关于我</a></li>
</ul>
<h3 id="-ehcache-"><a href="">Ehcache详细解读</a> **</h3>
<p><strong>博客分类：</strong></p>
<ul>
<li><a href="http://raychase.iteye.com/category/178243" target="_blank">Framework</a></li>
<li><a href="http://raychase.iteye.com/category/185968" target="_blank">Performance</a>
<a href="http://www.iteye.com/blogs/tag/%E7%BC%93%E5%AD%98" target="_blank">缓存</a><a href="http://www.iteye.com/blogs/tag/Ehcache" target="_blank">Ehcache</a></li>
</ul>
<p><a href="http://ehcache.org/" target="_blank">Ehcache</a> 是现在最流行的纯Java开源缓存框架，配置简单、结构清晰、功能强大，最初知道它，是从Hibernate的缓存开始的。网上中文的EhCache材料以简单介绍和配置方法居多，如果你有这方面的问题，请自行google；对于API，官网上介绍已经非常清楚，请参见官网；但是很少见到特性说明和对实现原理的分析，因此在这篇文章里面，我会详细介绍和分析EhCache的特性，加上一些自己的理解和思考，希望对缓存感兴趣的朋友有所收获。</p>
<p><strong>一、特性一览</strong>，来自官网，简单翻译一下：</p>
<p>1、快速轻量
过去几年，诸多测试表明Ehcache是最快的Java缓存之一。
Ehcache的线程机制是为大型高并发系统设计的。
大量性能测试用例保证Ehcache在不同版本间性能表现得一致性。
很多用户都不知道他们正在用Ehcache，因为不需要什么特别的配置。
API易于使用，这就很容易部署上线和运行。
很小的jar包，Ehcache 2.2.3才668kb。
最小的依赖：唯一的依赖就是SLF4J了。
2、伸缩性
缓存在内存和磁盘存储可以伸缩到数G，Ehcache为大数据存储做过优化。
大内存的情况下，所有进程可以支持数百G的吞吐。
为高并发和大型多CPU服务器做优化。
线程安全和性能总是一对矛盾，Ehcache的线程机制设计采用了Doug Lea的想法来获得较高的性能。
单台虚拟机上支持多缓存管理器。
通过Terracotta服务器矩阵，可以伸缩到数百个节点。
3、灵活性
Ehcache 1.2具备对象API接口和可序列化API接口。
不能序列化的对象可以使用除磁盘存储外Ehcache的所有功能。
除了元素的返回方法以外，API都是统一的。只有这两个方法不一致：getObjectValue和getKeyValue。这就使得缓存对象、序列化对象来获取新的特性这个过程很简单。
支持基于Cache和基于Element的过期策略，每个Cache的存活时间都是可以设置和控制的。
提供了LRU、LFU和FIFO缓存淘汰算法，Ehcache 1.2引入了最少使用和先进先出缓存淘汰算法，构成了完整的缓存淘汰算法。
提供内存和磁盘存储，Ehcache和大多数缓存解决方案一样，提供高性能的内存和磁盘存储。
动态、运行时缓存配置，存活时间、空闲时间、内存和磁盘存放缓存的最大数目都是可以在运行时修改的。
4、标准支持
Ehcache提供了对JSR107 JCACHE API最完整的实现。因为JCACHE在发布以前，Ehcache的实现（如net.sf.jsr107cache）已经发布了。
实现JCACHE API有利于到未来其他缓存解决方案的可移植性。
Ehcache的维护者Greg Luck，正是JSR107的专家委员会委员。
5、可扩展性
监听器可以插件化。Ehcache 1.2提供了CacheManagerEventListener和CacheEventListener接口，实现可以插件化，并且可以在ehcache.xml里配置。
节点发现，冗余器和监听器都可以插件化。
分布式缓存，从Ehcache 1.2开始引入，包含了一些权衡的选项。Ehcache的团队相信没有什么是万能的配置。
实现者可以使用内建的机制或者完全自己实现，因为有完整的插件开发指南。
缓存的可扩展性可以插件化。创建你自己的缓存扩展，它可以持有一个缓存的引用，并且绑定在缓存的生命周期内。
缓存加载器可以插件化。创建你自己的缓存加载器，可以使用一些异步方法来加载数据到缓存里面。
缓存异常处理器可以插件化。创建一个异常处理器，在异常发生的时候，可以执行某些特定操作。
6、应用持久化
在VM重启后，持久化到磁盘的存储可以复原数据。
Ehcache是第一个引入缓存数据持久化存储的开源Java缓存框架。缓存的数据可以在机器重启后从磁盘上重新获得。
根据需要将缓存刷到磁盘。将缓存条目刷到磁盘的操作可以通过cache.flush()方法来执行，这大大方便了Ehcache的使用。
7、监听器
缓存管理器监听器。允许注册实现了CacheManagerEventListener接口的监听器：
notifyCacheAdded()
notifyCacheRemoved()
缓存事件监听器。允许注册实现了CacheEventListener接口的监听器，它提供了许多对缓存事件发生后的处理机制：
notifyElementRemoved/Put/Updated/Expired
8、开启JMX
Ehcache的JMX功能是默认开启的，你可以监控和管理如下的MBean：
CacheManager、Cache、CacheConfiguration、CacheStatistics
9、分布式缓存
从Ehcache 1.2开始，支持高性能的分布式缓存，兼具灵活性和扩展性。
分布式缓存的选项包括：
通过Terracotta的缓存集群：设定和使用Terracotta模式的Ehcache缓存。缓存发现是自动完成的，并且有很多选项可以用来调试缓存行为和性能。
使用RMI、JGroups或者JMS来冗余缓存数据：节点可以通过多播或发现者手动配置。状态更新可以通过RMI连接来异步或者同步完成。
Custom：一个综合的插件机制，支持发现和复制的能力。
可用的缓存复制选项。支持的通过RMI、JGroups或JMS进行的异步或同步的缓存复制。
可靠的分发：使用TCP的内建分发机制。
节点发现：节点可以手动配置或者使用多播自动发现，并且可以自动添加和移除节点。对于多播阻塞的情况下，手动配置可以很好地控制。
分布式缓存可以任意时间加入或者离开集群。缓存可以配置在初始化的时候执行引导程序员。
BootstrapCacheLoaderFactory抽象工厂，实现了BootstrapCacheLoader接口（RMI实现）。
缓存服务端。Ehcache提供了一个Cache Server，一个war包，为绝大多数web容器或者是独立的服务器提供支持。
缓存服务端有两组API：面向资源的RESTful，还有就是SOAP。客户端没有实现语言的限制。
RESTful缓存服务器：Ehcached的实现严格遵循RESTful面向资源的架构风格。
SOAP缓存服务端：Ehcache RESTFul Web Services API暴露了单例的CacheManager，他能在ehcache.xml或者IoC容器里面配置。
标准服务端包含了内嵌的Glassfish web容器。它被打成了war包，可以任意部署到支持Servlet 2.5的web容器内。Glassfish V2/3、Tomcat 6和Jetty 6都已经经过了测试。
10、搜索
标准分布式搜索使用了流式查询接口的方式，请参阅文档。
11、Java EE和应用缓存
为普通缓存场景和模式提供高质量的实现。
阻塞缓存：它的机制避免了复制进程并发操作的问题。
SelfPopulatingCache在缓存一些开销昂贵操作时显得特别有用，它是一种针对读优化的缓存。它不需要调用者知道缓存元素怎样被返回，也支持在不阻塞读的情况下刷新缓存条目。
CachingFilter：一个抽象、可扩展的cache filter。
SimplePageCachingFilter：用于缓存基于request URI和Query String的页面。它可以根据HTTP request header的值来选择采用或者不采用gzip压缩方式将页面发到浏览器端。你可以用它来缓存整个Servlet页面，无论你采用的是JSP、velocity，或者其他的页面渲染技术。
SimplePageFragmentCachingFilter：缓存页面片段，基于request URI和Query String。在JSP中使用jsp:include标签包含。
已经使用Orion和Tomcat测试过，兼容Servlet 2.3、Servlet 2.4规范。
Cacheable命令：这是一种老的命令行模式，支持异步行为、容错。
兼容Hibernate，兼容Google App Engine。
基于JTA的事务支持，支持事务资源管理，二阶段提交和回滚，以及本地事务。
12、开源协议
Apache 2.0 license</p>
<p><strong>二、Ehcache的加载模块列表</strong>，他们都是独立的库，每个都为Ehcache添加新的功能，可以<a href="http://ehcache.org/downloads/catalog" target="_blank">在此下载</a> ：</p>
<ul>
<li>ehcache-core：API，标准缓存引擎，RMI复制和Hibernate支持</li>
<li>ehcache：分布式Ehcache，包括Ehcache的核心和Terracotta的库</li>
<li>ehcache-monitor：企业级监控和管理</li>
<li>ehcache-web：为Java Servlet Container提供缓存、gzip压缩支持的filters</li>
<li>ehcache-jcache：JSR107 JCACHE的实现</li>
<li>ehcache-jgroupsreplication：使用JGroup的复制</li>
<li>ehcache-jmsreplication：使用JMS的复制</li>
<li>ehcache-openjpa：OpenJPA插件</li>
<li>ehcache-server：war内部署或者单独部署的RESTful cache server</li>
<li>ehcache-unlockedreadsview：允许Terracotta cache的无锁读</li>
<li>ehcache-debugger：记录RMI分布式调用事件</li>
<li>Ehcache for Ruby：Jruby and Rails支持</li>
</ul>
<p>Ehcache的结构设计概览：</p>
<p><img src="&quot;点击查看原始大小图片&quot;" alt=""></p>
<p><strong>三、核心定义</strong>：</p>
<p>cache manager：缓存管理器，以前是只允许单例的，不过现在也可以多实例了</p>
<p>cache：缓存管理器内可以放置若干cache，存放数据的实质，所有cache都实现了Ehcache接口</p>
<p>element：单条缓存数据的组成单位</p>
<p>system of record（SOR）：可以取到真实数据的组件，可以是真正的业务逻辑、外部接口调用、存放真实数据的数据库等等，缓存就是从SOR中读取或者写入到SOR中去的。</p>
<p>代码示例：
Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>CacheManager manager = CacheManager.newInstance(&quot;src/config/ehcache.xml&quot;);  </li>
<li>manager.addCache(&quot;testCache&quot;);  </li>
<li>Cache test = singletonManager.getCache(&quot;testCache&quot;);  </li>
<li>test.put(new Element(&quot;key1&quot;, &quot;value1&quot;));  </li>
<li>manager.shutdown();<br>CacheManager manager = CacheManager.newInstance(&quot;src/config/ehcache.xml&quot;); manager.addCache(&quot;testCache&quot;); Cache test = singletonManager.getCache(&quot;testCache&quot;); test.put(new Element(&quot;key1&quot;, &quot;value1&quot;)); manager.shutdown();</li>
</ol>
<p>当然，也支持这种类似DSL的配置方式，配置都是可以在运行时动态修改的：</p>
<p>Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>Cache testCache = new Cache(  </li>
<li>new CacheConfiguration(&quot;testCache&quot;, maxElements)  </li>
<li>.memoryStoreEvictionPolicy(MemoryStoreEvictionPolicy.LFU)  </li>
<li>.overflowToDisk(true)  </li>
<li>.eternal(false)  </li>
<li>.timeToLiveSeconds(60)  </li>
<li>.timeToIdleSeconds(30)  </li>
<li>.diskPersistent(false)  </li>
<li>.diskExpiryThreadIntervalSeconds(0));<br>Cache testCache = new Cache( new CacheConfiguration(&quot;testCache&quot;, maxElements) .memoryStoreEvictionPolicy(MemoryStoreEvictionPolicy.LFU) .overflowToDisk(true) .eternal(false) .timeToLiveSeconds(60) .timeToIdleSeconds(30) .diskPersistent(false) .diskExpiryThreadIntervalSeconds(0));</li>
</ol>
<p>事务的例子：</p>
<p>Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>Ehcache cache = cacheManager.getEhcache(&quot;xaCache&quot;);  </li>
<li>transactionManager.begin();  </li>
<li>try {  </li>
<li>Element e = cache.get(key);  </li>
<li>Object result = complexService.doStuff(element.getValue());  </li>
<li>cache.put(new Element(key, result));  </li>
<li>complexService.doMoreStuff(result);  </li>
<li>transactionManager.commit();  </li>
<li>} catch (Exception e) {  </li>
<li>transactionManager.rollback();  </li>
<li>}<br>Ehcache cache = cacheManager.getEhcache(&quot;xaCache&quot;); transactionManager.begin(); try { Element e = cache.get(key); Object result = complexService.doStuff(element.getValue()); cache.put(new Element(key, result)); complexService.doMoreStuff(result); transactionManager.commit(); } catch (Exception e) { transactionManager.rollback(); }</li>
</ol>
<p><strong>四、一致性模型</strong>：</p>
<p>说到一致性，数据库的一致性是怎样的？不妨先来回顾一下数据库的几个隔离级别：</p>
<p>未提交读（Read Uncommitted）：在读数据时不会检查或使用任何锁。因此，在这种隔离级别中可能读取到没有提交的数据。会出现脏读、不可重复读、幻象读。
已提交读（Read Committed）：只读取提交的数据并等待其他事务释放排他锁。读数据的共享锁在读操作完成后立即释放。已提交读是数据库的默认隔离级别。会出现不可重复读、幻象读。
可重复读（Repeatable Read）：像已提交读级别那样读数据，但会保持共享锁直到事务结束。会出现幻象读。
可序列化（Serializable）：工作方式类似于可重复读。但它不仅会锁定受影响的数据，还会锁定这个范围，这就阻止了新数据插入查询所涉及的范围。</p>
<p>基于以上，再来对比思考下面的一致性模型：</p>
<p>1、强一致性模型：系统中的某个数据被成功更新(事务成功返回)后，后续任何对该数据的读取操作都得到更新后的值。这是传统关系数据库提供的一致性模型，也是关系数据库深受人们喜爱的原因之一。强一致性模型下的性能消耗通常是最大的。</p>
<p>2、弱一致性模型：系统中的某个数据被更新后，后续对该数据的读取操作得到的不一定是更新后的值，这种情况下通常有个“不一致性时间窗口”存在：即数据更新完成后在经过这个时间窗口，后续读取操作就能够得到更新后的值。</p>
<p>3、最终一致性模型：属于弱一致性的一种，即某个数据被更新后，如果该数据后续没有被再次更新，那么最终所有的读取操作都会返回更新后的值。</p>
<p>最终一致性模型包含如下几个必要属性，都比较好理解：</p>
<ul>
<li>读写一致：某线程A，更新某条数据以后，后续的访问全部都能取得更新后的数据。</li>
<li>会话内一致：它本质上和上面那一条是一致的，某用户更改了数据，只要会话还存在，后续他取得的所有数据都必须是更改后的数据。</li>
<li>单调读一致：如果一个进程可以看到当前的值，那么后续的访问不能返回之前的值。</li>
<li>单调写一致：对同一进程内的写行为必须是保序的，否则，写完毕的结果就是不可预期的了。</li>
</ul>
<p>4、Bulk Load：这种模型是基于批量加载数据到缓存里面的场景而优化的，没有引入锁和常规的淘汰算法这些降低性能的东西，它和最终一致性模型很像，但是有批量、高速写和弱一致性保证的机制。</p>
<p>这样几个API也会影响到一致性的结果：</p>
<p>1、显式锁（<a href="http://terracotta.org/documentation/enterprise-ehcache/api-guide#31478" target="_blank">Explicit Locking</a> ）：如果我们本身就配置为强一致性，那么自然所有的缓存操作都具备事务性质。而如果我们配置成最终一致性时，再在外部使用显式锁API，也可以达到事务的效果。当然这样的锁可以控制得更细粒度，但是依然可能存在竞争和线程阻塞。</p>
<p>2、无锁可读取视图（UnlockedReadsView）：一个允许脏读的decorator，它只能用在强一致性的配置下，它通过申请一个特殊的写锁来比完全的强一致性配置提升性能。</p>
<p>举例如下，xml配置为强一致性模型：
Xml代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>&lt;cache name=&quot;myCache&quot;  </li>
<li>maxElementsInMemory=&quot;500&quot;  </li>
<li>eternal=&quot;false&quot;  </li>
<li>overflowToDisk=&quot;false&quot;  </li>
<li><terracotta clustered="true" consistency="strong" />  </li>
<li></cache>  <cache name="myCache" maxElementsInMemory="500" eternal="false" overflowToDisk="false" <terracotta clustered="true" consistency="strong" /> </cache>

</li>
</ol>
<p>但是使用UnlockedReadsView：</p>
<p>Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>Cache cache = cacheManager.getEhcache(&quot;myCache&quot;);  </li>
<li>UnlockedReadsView unlockedReadsView = new UnlockedReadsView(cache, &quot;myUnlockedCache&quot;);<br>Cache cache = cacheManager.getEhcache(&quot;myCache&quot;); UnlockedReadsView unlockedReadsView = new UnlockedReadsView(cache, &quot;myUnlockedCache&quot;);</li>
</ol>
<p>3、原子方法（Atomic methods）：方法执行是原子化的，即CAS操作（Compare and Swap）。CAS最终也实现了强一致性的效果，但不同的是，它是采用乐观锁而不是悲观锁来实现的。在乐观锁机制下，更新的操作可能不成功，因为在这过程中可能会有其他线程对同一条数据进行变更，那么在失败后需要重新执行更新操作。现代的CPU都支持CAS原语了。
Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>cache.putIfAbsent(Element element);  </li>
<li>cache.replace(Element oldOne, Element newOne);  </li>
<li>cache.remove(Element);<br>cache.putIfAbsent(Element element); cache.replace(Element oldOne, Element newOne); cache.remove(Element);</li>
</ol>
<p><strong>五、缓存拓扑类型</strong>：</p>
<p>1、独立缓存（Standalone Ehcache）：这样的缓存应用节点都是独立的，互相不通信。</p>
<p>2、分布式缓存（Distributed Ehcache）：数据存储在Terracotta的服务器阵列（Terracotta Server Array，TSA）中，但是最近使用的数据，可以存储在各个应用节点中。</p>
<p>逻辑视角：</p>
<p><img src="" alt="">
L1缓存就在各个应用节点上，而L2缓存则放在Cache Server阵列中。</p>
<p>组网视角：
<img src="" alt=""></p>
<p>模型存储视角：</p>
<p><img src="" alt="">
L1级缓存是没有持久化存储的。另外，从缓存数据量上看，server端远大于应用节点。</p>
<p>3、复制式缓存（Replicated Ehcache）：缓存数据时同时存放在多个应用节点的，数据复制和失效的事件以同步或者异步的形式在各个集群节点间传播。上述事件到来时，会阻塞写线程的操作。在这种模式下，只有弱一致性模型。</p>
<p>它有如下几种事件传播机制：RMI、JGroups、JMS和Cache Server。</p>
<p>RMI模式下，所有节点全部对等：</p>
<p><img src="" alt=""></p>
<p>JGroup模式：可以配置单播或者多播，协议栈和配置都非常灵活。</p>
<p>Xml代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>&lt;cacheManagerPeerProviderFactory  </li>
<li>class=&quot;net.sf.ehcache.distribution.jgroups.JGroupsCacheManagerPeerProviderFactory&quot;  </li>
<li>properties=&quot;connect=UDP(mcast_addr=231.12.21.132;mcast_port=45566;):PING:  </li>
<li>MERGE2:FD_SOCK:VERIFY_SUSPECT:pbcast.NAKACK:UNICAST:pbcast.STABLE:FRAG:pbcast.GMS&quot;  </li>
<li>propertySeparator=&quot;::&quot;  </li>
<li>/&gt;  <cacheManagerPeerProviderFactory class="net.sf.ehcache.distribution.jgroups.JGroupsCacheManagerPeerProviderFactory" properties="connect=UDP(mcast_addr=231.12.21.132;mcast_port=45566;):PING: MERGE2:FD_SOCK:VERIFY_SUSPECT:pbcast.NAKACK:UNICAST:pbcast.STABLE:FRAG:pbcast.GMS" propertySeparator="::" />





</li>
</ol>
<p>JMS模式：这种模式的核心就是一个消息队列，每个应用节点都订阅预先定义好的主题，同时，节点有元素更新时，也会发布更新元素到主题中去。JMS规范实现者上，Open MQ和Active MQ这两个，Ehcache的兼容性都已经测试过。</p>
<p><img src="" alt=""></p>
<p>Cache Server模式：这种模式下存在主从节点，通信可以通过RESTful的API或者SOAP。</p>
<p><img src="" alt=""></p>
<p>无论上面哪个模式，更新事件又可以分为updateViaCopy或updateViaInvalidate，后者只是发送一个过期消息，效率要高得多。</p>
<p>复制式缓存容易出现数据不一致的问题，如果这成为一个问题，可以考虑使用数据同步分发的机制。</p>
<p>即便不采用分布式缓存和复制式缓存，依然会出现一些不好的行为，比如：</p>
<p>缓存漂移（Cache Drift）：每个应用节点只管理自己的缓存，在更新某个节点的时候，不会影响到其他的节点，这样数据之间可能就不同步了。这在web会话数据缓存中情况尤甚。</p>
<p>数据库瓶颈（Database Bottlenecks ）：对于单实例的应用来说，缓存可以保护数据库的读风暴；但是，在集群的环境下，每一个应用节点都要定期保持数据最新，节点越多，要维持这样的情况对数据库的开销也越大。</p>
<p><strong>六、存储方式</strong>：</p>
<p>1、堆内存储：速度快，但是容量有限。</p>
<p>2、堆外（OffHeapStore）存储：被称为BigMemory，只在企业版本的Ehcache中提供，原理是利用nio的DirectByteBuffers实现，比存储到磁盘上快，而且完全不受GC的影响，可以保证响应时间的稳定性；但是direct buffer的在分配上的开销要比heap buffer大，而且要求必须以字节数组方式存储，因此对象必须在存储过程中进行序列化，读取则进行反序列化操作，它的速度大约比堆内存储慢一个数量级。</p>
<p>（注：direct buffer不受GC影响，但是direct buffer归属的的JAVA对象是在堆上且能够被GC回收的，一旦它被回收，JVM将释放direct buffer的堆外空间。）</p>
<p>3、磁盘存储。</p>
<p><strong>七、缓存使用模式</strong>：</p>
<p>cache-aside：直接操作。先询问cache某条缓存数据是否存在，存在的话直接从cache中返回数据，绕过SOR；如果不存在，从SOR中取得数据，然后再放入cache中。</p>
<p>Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>public V readSomeData(K key)   </li>
<li>{  </li>
<li>Element element;  </li>
<li>if ((element = cache.get(key)) != null) {  </li>
<li>return element.getValue();  </li>
<li>}  </li>
<li>if (value = readDataFromDataStore(key)) != null) {  </li>
<li>cache.put(new Element(key, value));  </li>
<li>}   </li>
<li>return value;  </li>
<li>}<br>public V readSomeData(K key) { Element element; if ((element = cache.get(key)) != null) { return element.getValue(); } if (value = readDataFromDataStore(key)) != null) { cache.put(new Element(key, value)); } return value; }</li>
</ol>
<p>cache-as-sor：结合了read-through、write-through或write-behind操作，通过给SOR增加了一层代理，对外部应用访问来说，它不用区别数据是从缓存中还是从SOR中取得的。</p>
<p>read-through。</p>
<p>write-through。</p>
<p>write-behind（write-back）：既将写的过程变为异步的，又进一步延迟写入数据的过程。</p>
<p>Copy Cache的两个模式：CopyOnRead和CopyOnWrite。</p>
<p>CopyOnRead指的是在读缓存数据的请求到达时，如果发现数据已经过期，需要重新从源处获取，发起的copy element的操作（pull）；</p>
<p>CopyOnWrite则是发生在真实数据写入缓存时，发起的更新其他节点的copy element的操作（push）。</p>
<p>前者适合在不允许多个线程访问同一个element的时候使用，后者则允许你自由控制缓存更新通知的时机。</p>
<p>更多push和pull的变化和不同，也可<a href="http://raychase.iteye.com/blog/1337015" target="_blank">参见这里</a>。</p>
<p><strong>八、多种配置方式</strong>：</p>
<p>包括配置文件、声明式配置、编程式配置，甚至通过指定构造器的参数来完成配置，配置设计的原则包括：</p>
<p>所有配置要放到一起</p>
<p>缓存的配置可以很容易在开发阶段、运行时修改</p>
<p>错误的配置能够在程序启动时发现，在运行时修改出错则需要抛出运行时异常</p>
<p>提供默认配置，几乎所有的配置都是可选的，都有默认值</p>
<p><strong>九、自动资源控制</strong>（Automatic Resource Control，ARC）：</p>
<p>它是提供了一种智能途径来控制缓存，调优性能。特性包括：</p>
<p>内存内缓存对象大小的控制，避免OOM出现</p>
<p>池化（cache manager级别）的缓存大小获取，避免单独计算缓存大小的消耗</p>
<p>灵活的独立基于层的大小计算能力，下图中可以看到，不同层的大小都是可以单独控制的</p>
<p>可以统计字节大小、缓存条目数和百分比</p>
<p>优化高命中数据的获取，以提升性能，参见下面对缓存数据在不同层之间的流转的介绍</p>
<p><img src="" alt=""></p>
<p>缓存数据的流转包括了这样几种行为：</p>
<p>Flush：缓存条目向低层次移动。</p>
<p>Fault：从低层拷贝一个对象到高层。在获取缓存的过程中，某一层发现自己的该缓存条目已经失效，就触发了Fault行为。</p>
<p>Eviction：把缓存条目除去。</p>
<p>Expiration：失效状态。</p>
<p>Pinning：强制缓存条目保持在某一层。</p>
<p>下面的图反映了数据在各个层之间的流转，也反映了数据的生命周期：</p>
<p><img src="" alt=""></p>
<p><strong>十、监控功能</strong>：</p>
<p>监控的拓扑：</p>
<p><img src="" alt="">
每个应用节点部署一个监控探针，通过TCP协议与监控服务器联系，最终将数据提供给富文本客户端或者监控操作服务器。</p>
<p><strong>十一、广域网复制</strong>：</p>
<p>缓存数据复制方面，Ehcache允许两个地理位置各异的节点在广域网下维持数据一致性，同时它提供了这样几种方案（注：下面的示例都只绘制了两个节点的情形，实际可以推广到N个节点）：</p>
<p>第一种方案：Terracotta Active/Mirror Replication。</p>
<p><img src="" alt="">
这种方案下，服务端包含一个活跃节点，一个备份节点；各个应用节点全部靠该活跃节点提供读写服务。这种方式最简单，管理容易；但是，需要寄希望于理想的网络状况，服务器之间和客户端到服务器之间都存在走WAN的情况，这样的方案其实最不稳定。</p>
<p>第二种方案：Transactional Cache Manager Replication。</p>
<p><img src="" alt="">
这种方案下，数据读取不需要经过WAN，写入数据时写入两份，分别由两个cache manager处理，一份在本地Server，一份到其他Server去。这种方案下读的吞吐量较高而且延迟较低；但是需要引入一个XA事务管理器，两个cache manager写两份数据导致写开销较大，而且过WAN的写延迟依然可能导致系统响应的瓶颈。</p>
<p>第三种方案：Messaging based (AMQ) replication。</p>
<p><img src="&quot;点击查看原始大小图片&quot;" alt="">
这种方案下，引入了批量处理和队列，用以减缓WAN的瓶颈出现，同时，把处理读请求和复制逻辑从Server Array物理上就剥离开，避免了WAN情况恶化对节点读取业务的影响。这种方案要较高的吞吐量和较低的延迟，读/复制的分离保证了可以提供完备的消息分发保证、冲突处理等特性；但是它较为复杂，而且还需要一个消息总线。</p>
<p>有一些Ehcache特性应用较少或者比较边缘化，没有提到，例如对于JMX的支持；还有一些则是有类似的特性和介绍了，例如对于WEB的支持，请参见我<a href="http://raychase.iteye.com/blog/1533153" target="_blank">这篇关于OSCache的解读</a>，其中的“web支持”一节有详细的原理分析。</p>
<p>最后，关于Ehcache的性能比对，下面这张图来自Ehcache的创始人<a href="http://gregluck.com/blog/archives/2007/05/comparing-memcached-and-ehcache-performance/" target="_blank">Greg Luck的blog</a>：</p>
<p><img src="" alt=""> </p>
<p>put/get上Ehcache要500-1000倍快过Memcached。原因何在？他自己分析道：“In-process caching and asynchronous replication are a clear performance winner”。有关它详细的内容还是请参阅他的blog吧。</p>
<p><strong>文章系本人原创，转载请注明出处和作者</strong></p>
<ul>
<li><a href=""><img src="&quot;点击查看原始大小图片&quot;" alt=""></a></li>
<li><p>大小: 45.2 KB</p>
</li>
<li><p><a href=""><img src="&quot;点击查看原始大小图片&quot;" alt=""></a></p>
</li>
<li><p>大小: 64 KB</p>
</li>
<li><p><a href=""><img src="&quot;点击查看原始大小图片&quot;" alt=""></a></p>
</li>
<li><p>大小: 42.4 KB</p>
</li>
<li><p><a href=""><img src="&quot;点击查看原始大小图片&quot;" alt=""></a></p>
</li>
<li><p>大小: 46.1 KB</p>
</li>
<li><p><a href=""><img src="&quot;点击查看原始大小图片&quot;" alt=""></a></p>
</li>
<li><p>大小: 22.4 KB</p>
</li>
<li><p><a href=""><img src="&quot;点击查看原始大小图片&quot;" alt=""></a></p>
</li>
<li><p>大小: 65.2 KB</p>
</li>
<li><p><a href=""><img src="&quot;点击查看原始大小图片&quot;" alt=""></a></p>
</li>
<li><p>大小: 85.1 KB</p>
</li>
<li><p><a href=""><img src="&quot;点击查看原始大小图片&quot;" alt=""></a></p>
</li>
<li><p>大小: 28.4 KB</p>
</li>
<li><p><a href=""><img src="&quot;点击查看原始大小图片&quot;" alt=""></a></p>
</li>
<li><p>大小: 34.7 KB</p>
</li>
<li><p><a href=""><img src="&quot;点击查看原始大小图片&quot;" alt=""></a></p>
</li>
<li><p>大小: 52.6 KB</p>
</li>
<li><p><a href=""><img src="&quot;点击查看原始大小图片&quot;" alt=""></a></p>
</li>
<li><p>大小: 90.1 KB</p>
</li>
<li><p><a href=""><img src="&quot;点击查看原始大小图片&quot;" alt=""></a></p>
</li>
<li><p>大小: 94.3 KB</p>
</li>
<li><p><a href=""><img src="&quot;点击查看原始大小图片&quot;" alt=""></a></p>
</li>
<li><p>大小: 132.2 KB</p>
</li>
<li><p><a href=""><img src="&quot;点击查看原始大小图片&quot;" alt=""></a></p>
</li>
<li><p>大小: 20.4 KB</p>
</li>
<li><p><a href="http://raychase.iteye.com/blog/1545906#" target="_blank">查看图片附件</a></p>
</li>
</ul>
<p><strong>5</strong>
顶</p>
<p><strong>2</strong>
踩</p>
<p>分享到： <a href="&quot;分享到新浪微博&quot;"><img src="" alt=""></a> <a href="&quot;分享到腾讯微博&quot;"><img src="" alt=""></a>
<a href="http://raychase.iteye.com/blog/1549570" title="设计一套缓存框架需要关注的要素" target="_blank">设计一套缓存框架需要关注的要素</a> | <a href="http://raychase.iteye.com/blog/1541627" title="“你不适合做程序员”" target="_blank">“你不适合做程序员”</a></p>
<ul>
<li>2012-05-31 17:44</li>
<li>浏览 1752</li>
<li><a href="http://raychase.iteye.com/blog/1545906#comments" target="_blank">评论(1)</a></li>
<li>分类:<a href="http://www.iteye.com/blogs/category/internet" target="_blank">互联网</a></li>
<li><a href="http://www.iteye.com/wiki/blog/1545906" target="_blank">相关推荐</a><h3 id="-">评论</h3>
</li>
</ul>
<p><a href=""></a></p>
<p>1 楼 <a href="http://mowengaobo.iteye.com/" title="mowengaobo" target="_blank">mowengaobo</a> 2012-07-10  </p>
<p>写得真不错，不过对 Greg Luck最后那张图表示怀疑。</p>
<h3 id="-">发表评论</h3>
<p><a href="http://raychase.iteye.com/login" target="_blank"><img src="" alt=""></a><a href="http://raychase.iteye.com/login" target="_blank">您还没有登录,请您登录后再发表评论</a></p>
<p><a href="http://raychase.iteye.com/" target="_blank"><img src="&quot;RayChase的博客: 四火的BLOG&quot;" alt="RayChase的博客"></a></p>
<p>RayChase</p>
<ul>
<li>浏览: 113254 次</li>
<li>性别: <img src="&quot;男&quot;" alt="Icon_minigender_1"></li>
<li>来自: 北京</li>
<li><img src="" alt=""><h3 id="-http-raychase-iteye-com-blog-user_visits-">最近访客 <a href="http://raychase.iteye.com/blog/user_visits" target="_blank">更多访客&gt;&gt;</a></h3>
</li>
</ul>
<p><a href="http://fudewei1.iteye.com/" target="_blank"><img src="&quot;fudewei1的博客: &quot;" alt="fudewei1的博客"></a></p>
<p><a href="http://fudewei1.iteye.com/" title="fudewei1" target="_blank">fudewei1</a></p>
<p><a href="http://hi00o.iteye.com/" target="_blank"><img src="&quot;hi00o的博客: &quot;" alt="hi00o的博客"></a></p>
<p><a href="http://hi00o.iteye.com/" title="hi00o" target="_blank">hi00o</a>
<a href="http://macrochen.iteye.com/" target="_blank"><img src="&quot;macrochen的博客: 疯狂的菠菜&quot;" alt="macrochen的博客"></a></p>
<p><a href="http://macrochen.iteye.com/" title="macrochen" target="_blank">macrochen</a></p>
<p><a href="http://dylinshi126.iteye.com/" target="_blank"><img src="&quot;dylinshi126的博客: &quot;" alt="dylinshi126的博客"></a></p>
<p><a href="http://dylinshi126.iteye.com/" title="dylinshi126" target="_blank">dylinshi126</a></p>
<h3 id="-">博客专栏</h3>
<p><a href="http://www.iteye.com/blogs/subjects/Core-J2EE-Pattern" target="_blank"><img src="" alt="1489d3fc-d068-34f7-9f25-23a663e958b1"></a> <a href="http://www.iteye.com/blogs/subjects/Core-J2EE-Pattern" title="J2EE 核心模式" target="_blank">J2EE 核心模式</a>
浏览量：16253 <a href="http://www.iteye.com/blogs/subjects/JS-Refactory" target="_blank"><img src="" alt="C976ce7b-2227-36df-bb1a-47f0139cc7ac"></a> <a href="http://www.iteye.com/blogs/subjects/JS-Refactory" title="JavaScript重构" target="_blank">JavaScript重构</a>
浏览量：12707</p>
<h3 id="-">文章分类</h3>
<ul>
<li><a href="http://raychase.iteye.com/" target="_blank">全部博客 (150)</a></li>
<li><a href="http://raychase.iteye.com/category/178240" target="_blank">Web UI (9)</a></li>
<li><a href="http://raychase.iteye.com/category/178244" target="_blank">Dynamic Language (7)</a></li>
<li><a href="http://raychase.iteye.com/category/178243" target="_blank">Framework (5)</a></li>
<li><a href="http://raychase.iteye.com/category/178249" target="_blank">Note &amp; Try (10)</a></li>
<li><a href="http://raychase.iteye.com/category/178250" target="_blank">JavaScript (27)</a></li>
<li><a href="http://raychase.iteye.com/category/178257" target="_blank">Ant/Gant/Maven (2)</a></li>
<li><a href="http://raychase.iteye.com/category/178262" target="_blank">Database (4)</a></li>
<li><a href="http://raychase.iteye.com/category/178263" target="_blank">Software Engineering (8)</a></li>
<li><a href="http://raychase.iteye.com/category/200349" target="_blank">Career (19)</a></li>
<li><a href="http://raychase.iteye.com/category/217121" target="_blank">Team Management (3)</a></li>
<li><a href="http://raychase.iteye.com/category/185968" target="_blank">Performance (9)</a></li>
<li><a href="http://raychase.iteye.com/category/199601" target="_blank">Algorithm (6)</a></li>
<li><a href="http://raychase.iteye.com/category/202095" target="_blank">News &amp; Commets (15)</a></li>
<li><a href="http://raychase.iteye.com/category/178259" target="_blank">System Design (14)</a></li>
<li><a href="http://raychase.iteye.com/category/217118" target="_blank">OO Design (8)</a></li>
<li><a href="http://raychase.iteye.com/category/217120" target="_blank">API Design (3)</a></li>
<li><a href="http://raychase.iteye.com/category/217119" target="_blank">Programming Paradigms (4)</a></li>
<li><a href="http://raychase.iteye.com/category/217122" target="_blank">Asynchronous Programming (4)</a></li>
<li><a href="http://raychase.iteye.com/category/217124" target="_blank">Architecture (4)</a></li>
</ul>
<h3 id="-">社区版块</h3>
<ul>
<li><a href="http://raychase.iteye.com/blog/news" target="_blank">我的资讯</a> (0)</li>
<li><a href="http://raychase.iteye.com/blog/post" target="_blank">我的论坛</a> (9)</li>
<li><p><a href="http://raychase.iteye.com/blog/answered_problems" target="_blank">我的问答</a> (1)</p>
<h3 id="-">存档分类</h3>
</li>
<li><p><a href="http://raychase.iteye.com/blog/monthblog/2012-10" target="_blank">2012-10</a> (4)</p>
</li>
<li><a href="http://raychase.iteye.com/blog/monthblog/2012-09" target="_blank">2012-09</a> (7)</li>
<li><a href="http://raychase.iteye.com/blog/monthblog/2012-08" target="_blank">2012-08</a> (3)</li>
<li><a href="http://raychase.iteye.com/blog/monthblog_more" target="_blank">更多存档...</a></li>
</ul>
<h3 id="-">评论排行榜</h3>
<ul>
<li><a href="http://raychase.iteye.com/blog/1450079" title="谈谈对程序员的培养" target="_blank">谈谈对程序员的培养</a></li>
<li><a href="http://raychase.iteye.com/blog/1340843" title="写在职业生涯的路口" target="_blank">写在职业生涯的路口</a></li>
<li><a href="http://raychase.iteye.com/blog/1325097" title="一些平安夜里的IT人" target="_blank">一些平安夜里的IT人</a></li>
<li><a href="http://raychase.iteye.com/blog/1486868" title="那些糟糕的面试和那些屎问题" target="_blank">那些糟糕的面试和那些屎问题</a></li>
<li><p><a href="http://raychase.iteye.com/blog/1689006" title="你真的精通Java吗？" target="_blank">你真的精通Java吗？</a></p>
<h3 id="-">最新评论</h3>
</li>
<li><p><a href="http://datadatawarehouse.iteye.com/" title="datawarehouse" target="_blank">datawarehouse</a>： wf_chn 写道没看到怎么个抢法 同意，不知道在说什么。
<a href="http://raychase.iteye.com/blog/1691863#bc2284161" target="_blank">如何在局域网内抢带宽</a></p>
</li>
<li><a href="http://ajavaloser.iteye.com/" title="wf_chn" target="_blank">wf_chn</a>： 没看到怎么个抢法
<a href="http://raychase.iteye.com/blog/1691863#bc2284147" target="_blank">如何在局域网内抢带宽</a></li>
<li><a href="http://muyishuihan.iteye.com/" title="muyishuihan" target="_blank">muyishuihan</a>： 尼玛，碉堡
<a href="http://raychase.iteye.com/blog/1689168#bc2284132" target="_blank">一些中文编程语言</a></li>
<li><a href="http://javaroom.iteye.com/" title="javaroom" target="_blank">javaroom</a>： 没别的意思，讨论嘛，各抒己见，对LZ的观点，我还是赞同的，奈何 ...
<a href="http://raychase.iteye.com/blog/1689006#bc2283982" target="_blank">你真的精通Java吗？</a></li>
<li><a href="http://anyasir.iteye.com/" title="anyasir" target="_blank">anyasir</a>： 不知道怎么说我就是从不写精通的大学主修java编程工作也三年多 ...
<a href="http://raychase.iteye.com/blog/1689006#bc2283974" target="_blank">你真的精通Java吗？</a>
声明：ITeye文章版权属于作者，受法律保护。没有作者书面许可不得转载。若作者同意转载，必须以超链接形式标明文章原始出处和作者。
© 2003-2012 ITeye.com. All rights reserved. [ 京ICP证110151号 京公网安备110105010620 ]
<img src="" alt=""></li>
</ul>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/缓存/">缓存</a></li></span><span class="breadcrumb"><li><a href="/categories/缓存/">缓存</a></li><li><a href="/categories/缓存/ehcache/">ehcache</a></li></span></span> | <span class="tags">Tagged <a href="/tags/ehcache/" class="label label-primary">ehcache</a><a href="/tags/缓存/" class="label label-success">缓存</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:39"datetime="2014-03-07 09:54:39"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-缓存-ehcache--Ehcache详细解读-四火的BLOG-ITeye技术网站/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-缓存-ehcache--Ehcache详细解读-四火的BLOG-ITeye技术网站" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-缓存-ehcache--使用EhCache关于临时目录的一个注意事项-讨论区-开源中国社区/">使用 EhCache 关于临时目录的一个注意事项 </a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:39.000Z"> <a href="/2014/02/02/2014-02-02-缓存-ehcache--使用EhCache关于临时目录的一个注意事项-讨论区-开源中国社区/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-ehcache-">使用 EhCache 关于临时目录的一个注意事项 - 讨论区 - 开源中国社区</h1>
<ul>
<li><a href="http://www.oschina.net/" target="_blank">首页</a></li>
<li><a href="http://www.oschina.net/project" target="_blank">开源软件</a></li>
<li><a href="http://www.oschina.net/question" target="_blank">讨论区</a></li>
<li><a href="http://www.oschina.net/code/list" target="_blank">代码分享</a></li>
<li><a href="http://www.oschina.net/news" target="_blank">资讯</a></li>
<li><a href="http://www.oschina.net/blog" target="_blank">博客</a></li>
<li><a href="http://www.oschina.net/android" target="_blank">Android</a></li>
<li><a href="http://www.oschina.net/job" target="_blank">招聘</a></li>
</ul>
<p>当前访客身份：游客 [ <a href="http://www.oschina.net/home/login" target="_blank">登录</a> | <a href="http://www.oschina.net/home/reg" target="_blank">加入开源中国</a> ]</p>
<p>当前位置：<a href="http://www.oschina.net/question" target="_blank">讨论区</a> » <a href="http://www.oschina.net/question?catalog=2" target="_blank">技术分享</a> » <a href="http://www.oschina.net/p/ehcache" target="_blank">EhCache</a></p>
<p>软件 代码 讨论区 新闻 博客
<a href="http://my.oschina.net/javayou" target="_blank"><img src="&quot;红薯&quot;" alt="红薯"></a></p>
<h1 id="-ehcache-"><a href="">使用 EhCache 关于临时目录的一个注意事项</a></h1>
<p><a href="http://my.oschina.net/javayou" target="_blank">红薯</a> 发表于 8-20 09:24 3年前, <a href="http://www.oschina.net/question/12_2368#answers" target="_blank">0</a>回/524阅
<strong><a href="http://www.oschina.net/question" target="_blank">讨论区</a> » <a href="http://www.oschina.net/question?catalog=2" target="_blank">技术分享</a></strong></p>
<p>【杭州】开源中国-源创会第十三期开始报名 <a href="http://www.oschina.net/question/28_72721" target="_blank">我要报名»</a>
一般 ehcache 的配置中默认的 diskStore 的路径设置的是 java.io.tmpdir ，等于是当前系统的临时目录。</p>
<p>但是在 Tomcat  和 Resin 这两个应用服务器上，临时目录是有区别的，在 Tomcat 上运行的应用通过 java.io.tmpdir 系统变量获取到的路径是 <a href="http://www.oschina.net/p/tomcat" target="_blank">Tomcat</a> 目录下的 temp 子目录，而 <a href="http://www.oschina.net/p/resin" target="_blank">Resin</a> 返回的是系统的临时目录，linux下可能就是 /tmp</p>
<p>在 Linux 下如果我们使用的是 root 账号来启动 Tomcat 和 Resin 的话，那这个问题就不存在。但是我们非常不建议用 root 来启动 Tomcat 和 Resin，这时候我们会单独的创建一个非特权账号，假设该账号名为 www 来运行应用服务器。</p>
<p>我们需要将 Tomcat 和 Resin 所在的目录授权给 www 账号，这样应用服务器的日志文件才能正常的写入，但是由于 Resin 的临时目录是对应系统的 /tmp 目录，因此如果应用中使用了 ehcache 并设置了存储路径为 java.io.tmpdir ，你就会发现启动的时候报错，提示没有在 /tmp 目录下创建文件的权限，这是因为 www 账号没有写 tmp 目录的权限。</p>
<p>解决的办法就是修改 ehcache 的 diskStore 配置的值为  user.home ，将存储文件路径指定到用户的主目录下即可。</p>
<p>而 Tomcat 就没有这个问题，因为它的临时目录在 {tomcat}/temp ，而整个 {tomcat} 都已经授权给 www 账号了。</p>
<p><strong>标签：</strong> <a href="http://www.oschina.net/question/tag/ehcache" title="Java缓存框架 EhCache" target="_blank">EhCache</a> <a href="http://www.oschina.net/question/tag/cache" target="_blank">缓存</a>
<a href="">补充话题说明»</a></p>
<p><strong>分享到</strong> <a href="&quot;分享到新浪微博&quot;"></a><a href="&quot;分享到腾讯微博&quot;"></a>**</p>
<p><a href="&quot;收藏此话题&quot;">收藏</a>
**</p>
<p>3
**</p>
<p><a href="">举报</a>
**</p>
<p><a href="&quot;踩：这问题不知道在说什么，或者没什么用&quot;">踩</a> 0 | <a href="&quot;顶：这问题很有用或者很清晰明了&quot;">顶</a> 0
**</p>
<h2 id="-http-www-oschina-net-question-12_2368-answers-http-www-oschina-net-question-12_2368-sort-time-answers-http-www-oschina-net-question-12_2368-top-0-http-www-oschina-net-question-12_2368-answerform-"><a href="http://www.oschina.net/question/12_2368#answers" target="_blank">按默认排序</a> | <a href="http://www.oschina.net/question/12_2368?sort=time#answers" target="_blank">显示最新评论</a> | <a href="http://www.oschina.net/question/12_2368#top" target="_blank">回页面顶部</a>  <a href=""></a>共有<em>0</em>个评论 <a href="http://www.oschina.net/question/12_2368#answerform">发表评论»</a></h2>
<p><a href="http://www.oschina.net/question/$link.user($g_user" target="_blank"><img src="&quot;非会员用户&quot;" alt="非会员用户"></a>)   <a href="&quot;粗体(Ctrl+B"></a>&quot;)<a href="&quot;斜体(Ctrl+I"></a>&quot;)<a href="&quot;下划线(Ctrl+U"></a>&quot;)<a href="&quot;删除线&quot;"></a><a href="&quot;删除格式&quot;"></a><a href="&quot;编号&quot;"></a><a href="&quot;项目符号&quot;"></a><a href="&quot;文字颜色&quot;"></a><a href="&quot;文字背景&quot;"></a><a href="&quot;字体&quot;"></a><a href="&quot;文字大小&quot;"></a><a href="&quot;超级链接&quot;"></a><a href="&quot;取消超级链接&quot;"></a><a href="&quot;插入表情&quot;"></a><a href="&quot;插入程序代码或脚本&quot;"></a><a href="&quot;图片&quot;"></a><a href="&quot;插入Flash&quot;"></a><a href="&quot;引用某段文字&quot;"></a><a href="&quot;全选&quot;"></a><a href="&quot;HTML代码&quot;"></a><a href="&quot;关于&quot;"></a>
<a href="http://www.oschina.net/question/12_2368#answers" target="_blank">回评论顶部</a> | <a href="http://www.oschina.net/question/12_2368#top" target="_blank">回页面顶部</a>
有什么技术问题吗？ <a href="http://www.oschina.net/question/ask" target="_blank">我要提问</a></p>
<p><strong><a href="http://my.oschina.net/javayou/?ft=bbs&amp;scope=2&amp;showme=1" target="_blank">全部(4786)...</a><em>红薯</em>的其他问题</strong></p>
<ul>
<li><a href="http://www.oschina.net/question/12_73010" title="解读 Oracle 12c 的 12 个新特性" target="_blank">解读 Oracle 12c 的 12 个新特性</a>(19回/2930阅,昨天(15:20))</li>
<li><a href="http://www.oschina.net/question/12_72989" title="配置 Gitosis" target="_blank">配置 Gitosis</a>(0回/17阅,昨天(13:10))</li>
<li><a href="http://www.oschina.net/question/12_72988" title="Git 服务器 Gitosis 架设指南" target="_blank">Git 服务器 Gitosis 架设指南</a>(1回/127阅,昨天(13:06))</li>
<li><a href="http://www.oschina.net/question/12_72813" title="MySQL 5.6.7-RC 的 tpcc-mysql 基准测试结果" target="_blank">MySQL 5.6.7-RC 的 tpcc-mysql 基准测试结果</a>(6回/1397阅,2天前)</li>
<li><p><a href="http://www.oschina.net/question/12_72796" title="使用 Web API 作为动态 TypeScript 编译器运行环境" target="_blank">使用 Web API 作为动态 TypeScript 编译器运行环境</a>(15回/3539阅,2天前)
<strong>类似的话题</strong></p>
</li>
<li><p><a href="http://www.oschina.net/question/12_12938" title="发布 oschina 缓存管理的源码，基于 ehcache" target="_blank">发布 oschina 缓存管理的源码，基于 ehcache</a>(4回/899阅,1年前)</p>
</li>
<li><a href="http://www.oschina.net/question/12_3699" title="快来看看 EhCache 卖掉后有多恶心" target="_blank">快来看看 EhCache 卖掉后有多恶心</a>(8回/1928阅,2年前)</li>
<li><a href="http://www.oschina.net/question/107963_13557" title="关于Ehcache集群缓存在应用重启后的加载问题" target="_blank">关于Ehcache集群缓存在应用重启后的加载问题</a>(0回/453阅,1年前)</li>
<li><a href="http://www.oschina.net/question/62530_4270" title="2010年3月9日ehcache 2.0发布" target="_blank">2010年3月9日ehcache 2.0发布</a>(3回/165阅,2年前)</li>
<li><a href="http://www.oschina.net/question/12_2940" title="EhCache的网友评论" target="_blank">EhCache的网友评论</a>(1回/186阅,2年前)</li>
<li><a href="http://www.oschina.net/question/12_7773" title="深入探讨在集群环境中使用 EhCache 缓存系统" target="_blank">深入探讨在集群环境中使用 EhCache 缓存系统</a>(4回/1372阅,2年前)</li>
<li><a href="http://www.oschina.net/question/12_3984" title="下载 EhCache 集群演示程序" target="_blank">下载 EhCache 集群演示程序</a>(29回/8486阅,2年前)</li>
<li><a href="http://www.oschina.net/question/1_5194" title="EhCache在acegi中的应用" target="_blank">EhCache在acegi中的应用</a>(1回/480阅,3年前)</li>
<li><a href="http://www.oschina.net/question/102297_17302" title="ehcache集群时同步不了" target="_blank">ehcache集群时同步不了</a>(3回/501阅,1年前)</li>
<li><a href="http://www.oschina.net/question/54100_31552" title="在 JPA、Hibernate 和 Spring 中配置 Ehcache 缓存" target="_blank">在 JPA、Hibernate 和 Spring 中配置 Ehcache 缓存</a>(2回/967阅,11个月前)</li>
<li><a href="http://www.oschina.net/question/12_4358" title="Ehcache 2.0 支持新的 Hibernate 3.3/3.5 缓存 SPI" target="_blank">Ehcache 2.0 支持新的 Hibernate 3.3/3.5 缓存 SPI</a>(1回/701阅,2年前)</li>
<li><a href="http://www.oschina.net/question/1_5192" title="EHCache 初步使用指南 " target="_blank">EHCache 初步使用指南</a>(0回/520阅,3年前)</li>
<li><a href="http://www.oschina.net/question/98610_14858" title="EhCache CacheManager 初次获取key值对象为空" target="_blank">EhCache CacheManager 初次获取key值对象为空</a>(4回/394阅,1年前)</li>
<li><a href="http://www.oschina.net/question/8676_3506" title="简述 EhCache 的几个模块" target="_blank">简述 EhCache 的几个模块</a>(1回/1623阅,2年前)</li>
<li><a href="http://www.oschina.net/question/12_8718" title="找到了 OSChina 出问题的原因了～～" target="_blank">找到了 OSChina 出问题的原因了～～</a>(2回/539阅,2年前)</li>
<li><a href="http://www.oschina.net/question/163220_62999" title="关于ehcahce配置" target="_blank">关于ehcahce配置</a>(0回/138阅,2个月前)</li>
</ul>
<p>© 开源中国社区(OsChina.NET) | <a href="http://www.oschina.net/home/about" target="_blank">关于我们</a> | <a href="mailto:oschina.net@gmail.com">广告联系</a> | <a href="http://weibo.com/oschina2010" target="_blank">@新浪微博</a> | <a href="http://m.oschina.net/" target="_blank">开源中国手机版</a> | 粤ICP备12009483号-3</p>
<p><a href=""></a><a href=""></a><a href=""></a>
<img src="" alt=""></p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/缓存/">缓存</a></li></span><span class="breadcrumb"><li><a href="/categories/缓存/">缓存</a></li><li><a href="/categories/缓存/ehcache/">ehcache</a></li></span></span> | <span class="tags">Tagged <a href="/tags/ehcache/" class="label label-primary">ehcache</a><a href="/tags/缓存/" class="label label-success">缓存</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:39"datetime="2014-03-07 09:54:39"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-缓存-ehcache--使用EhCache关于临时目录的一个注意事项-讨论区-开源中国社区/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-缓存-ehcache--使用EhCache关于临时目录的一个注意事项-讨论区-开源中国社区" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-缓存-ehcache--EhCache配置文件-奈何桥收费站。。。-ITeye技术网站/">EhCache配置文件 </a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:39.000Z"> <a href="/2014/02/02/2014-02-02-缓存-ehcache--EhCache配置文件-奈何桥收费站。。。-ITeye技术网站/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="ehcache-iteye-">EhCache配置文件 - 奈何桥收费站。。。 - ITeye技术网站</h1>
<p><a href="http://www.iteye.com/" target="_blank">首页</a> <a href="http://www.iteye.com/news" target="_blank">资讯</a> <a href="http://www.iteye.com/magazines" target="_blank">精华</a> <a href="http://www.iteye.com/forums" target="_blank">论坛</a> <a href="http://www.iteye.com/ask" target="_blank">问答</a> <a href="http://www.iteye.com/blogs" target="_blank">博客</a> <a href="http://www.iteye.com/blogs/subjects" target="_blank">专栏</a> <a href="http://www.iteye.com/groups" target="_blank">群组</a> <a href="http://zuzong.iteye.com/blog/1048714#" target="_blank">更多 ▼</a></p>
<p><a href="http://www.iteye.com/job" target="_blank">招聘</a> <a href="http://www.iteye.com/search" target="_blank">搜索</a></p>
<p><a href="http://zuzong.iteye.com/login" title="登录" target="_blank">您还未登录 !</a> <a href="http://zuzong.iteye.com/login" target="_blank">登录</a> <a href="http://zuzong.iteye.com/signup" target="_blank">注册</a></p>
<h1 id="-http-zuzong-iteye-com-"><a href="http://zuzong.iteye.com/" target="_blank">奈何桥收费站。。。</a></h1>
<ul>
<li><a href="http://zuzong.iteye.com/" target="_blank"><strong>博客</strong></a></li>
<li><a href="http://zuzong.iteye.com/weibo" target="_blank">微博</a></li>
<li><a href="http://zuzong.iteye.com/album" target="_blank">相册</a></li>
<li><a href="http://zuzong.iteye.com/link" target="_blank">收藏</a></li>
<li><a href="http://zuzong.iteye.com/blog/guest_book" target="_blank">留言</a></li>
<li><a href="http://zuzong.iteye.com/blog/profile" target="_blank">关于我</a></li>
</ul>
<h3 id="-ehcache-"><a href="">EhCache配置文件</a> **</h3>
<p><strong>博客分类：</strong></p>
<ul>
<li><a href="http://zuzong.iteye.com/category/157174" target="_blank">缓存</a>
<a href="http://www.iteye.com/blogs/tag/Cache" target="_blank">Cache</a><a href="http://www.iteye.com/blogs/tag/%E5%BA%94%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8" target="_blank">应用服务器</a><a href="http://www.iteye.com/blogs/tag/Linux" target="_blank">Linux</a><a href="http://www.iteye.com/blogs/tag/%E5%B5%8C%E5%85%A5%E5%BC%8F" target="_blank">嵌入式</a><a href="http://www.iteye.com/blogs/tag/performance" target="_blank">performance</a> </li>
</ul>
<p>Xml代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;       </li>
<li>&lt;!--  </li>
<li></li>
<li>CacheManager配置  </li>
<li>==========================  </li>
<li></li>
<li></li>
<li>一个ehcache.xml 相当于一个单个的CacheManager  </li>
<li></li>
<li>学习下面的说明或者ehcache构架（ehcache.xsd）怎样配置  </li>
<li>系统资源标识在这个文件中能被具体制定，当配置被加载时，他们将会被替换。例如 multicastGroupPort=${multicastGroupPort}被环境变量的系统属性替换，或是使用如-DmulticastGroupPort=4446命令行开关指定一个系统属性。  </li>
<li></li>
<li><ehcache>的属性如下：  </li>
<li></li>
<li>/* name – CacheManager的可选名称。这个名称起初主要是用于文档记录或辨别Terracotta集群状态。对于Terracotta集群的缓存，一组CacheManager名称和cache名称唯一的鉴定了一个特定的存储于Terracotta集群存储器的缓存。  </li>
<li></li>
<li>/* updateCheck – 一个可选的boolean标识符，指定这个CacheManager是否通过Internet检查Ehcache的新版本。如果没有特别指明，updateCheck=&quot;true&quot;.  </li>
<li></li>
<li>/* monitoring – 一个可选的设置，决定CacheManager是否应该自动的用系统MBean服务器注册SampledCacheMBean。当下，这个监测。只有当使用Terracotta集群和使用Terracotta Developer Console时才有用。使用&quot;autodetect&quot;值，Terracotta集群的出现将被检测和监视，并通过Developer控制台激活。其他允许的值有：&quot;on&quot; 和 &quot;off&quot;。默认为&quot;autodetect&quot;。当使用JMX监测时，这个设置不会产生任何作用。  </li>
<li></li>
<li>/* dynamicConfig – 一个可选设置，能够使与这个CacheManager相关联的动态配置失活。这个设置的默认值是true-例如，动态配置是激活的。动态配置的缓存通过缓存的配置对象让他们的TTI, TTL 和maximum disk 和in-memory capacity在运行时改变。  </li>
<li>--&gt;    </li>
<li>&lt;ehcache xmlns:xsi=&quot;<a href="http://www.w3.org/2001/XMLSchema-instance" target="_blank">http://www.w3.org/2001/XMLSchema-instance</a>&quot;  </li>
<li>xsi:noNamespaceSchemaLocation=&quot;ehcache.xsd&quot;  </li>
<li>updateCheck=&quot;true&quot; monitoring=&quot;autodetect&quot;  </li>
<li>dynamicConfig=&quot;true&quot; &gt;  </li>
<li></li>
<li>&lt;!--  </li>
<li>DiskStore configuration  </li>
<li>=======================  </li>
<li>磁盘存储器是可选的。关闭磁盘存储路径创建，解释下面的磁盘存储器元素。  </li>
<li>对于任何缓存，如果你已经激活了overflowToDisk或diskPersistent，就要配置磁盘存储器。  </li>
<li>如果他未配置，并且创建了一个需要磁盘存储的缓存，将会发出一个警告并且java.io.tmpdir将会自动使用。  </li>
<li>磁盘存储器仅有一个属性- &quot;path&quot;。这个路径就是.data and .index文件被创建的目录路径。  </li>
<li>如果这个路径是下述Java系统属性之一，他将会被运行中的VM中的值替换。为了向后兼容，这些应该被特别规定，而不会被${token}替换语法封闭。  </li>
<li></li>
<li>下列属性翻译：  </li>
<li>/* user.home -用户的根目录  </li>
<li>/* user.dir – 用户的当前工作目录  </li>
<li>/* java.io.tmpdir – 默认临时文件路径  </li>
<li>/* ehcache.disk.store.dir – 一个系统属性，你通常用命令行指定；  </li>
<li>例如： java -Dehcache.disk.store.dir=/u01/myapp/diskdir ...  </li>
<li></li>
<li></li>
<li></li>
<li>子目录通过如下属性指定，例如：java.io.tmpdir/one  </li>
<li>--&gt;  </li>
<li><diskStore path="java.io.tmpdir"/>  </li>
<li></li>
<li></li>
<li>&lt;!--  </li>
<li>TransactionManagerLookup configuration  </li>
<li>======================================  </li>
<li>TransactionManagerLookup 配置  </li>
<li>这个类被ehcache用XA激活的ehcache来查找用于应用程序中的JTA TransactionManager。如果没有指定类，那么DefaultTransactionManagerLookup将以如下顺序找到TransactionManager。  </li>
<li></li>
<li>/*GenericJNDI（例如：jboss，属性jndiName控制TransactionManager对象的名称来查找）  </li>
<li>/*Websphere  </li>
<li>/*Bitronix  </li>
<li>/*Atomikos  </li>
<li>你可以提供自己的查找类实现net.sf.ehcache.transaction.manager.TransactionManagerLookup接口。  </li>
<li><transactionManagerLookup class="net.sf.ehcache.transaction.manager.DefaultTransactionManagerLookup" properties="" propertySeparator=":"/>  </li>
<li></li>
<li>&lt;!--  </li>
<li>CacheManagerEventListener  </li>
<li>=========================  </li>
<li>指定一个CacheManagerEventListenerFactory，当缓存被增加或从CacheManager移除时被告知。  </li>
<li></li>
<li>CacheManagerEventListenerFactory的属性有：  </li>
<li>/* class – 一个完全限定的工厂类名。  </li>
<li>/* properties – 逗号隔开的属性只对工厂有意义。  </li>
<li>overflowToDisk:设置元素是否能溢出磁盘，当存储器容量达到最大存储限制。  </li>
<li></li>
<li>如下属性和元素是可选的。  </li>
<li></li>
<li>timeToIdleSeconds:  </li>
<li>Sets the time to idle for an element before it expires.  </li>
<li>设置一个元素在过期前的空闲时间  </li>
<li>i.e. The maximum amount of time between accesses before an element expires  </li>
<li>Is only used if the element is not eternal.  </li>
<li>换言之，最大时间数在进入之后和元素过期之前这段时间之间，只有元素在非持久化时才有用。  </li>
<li>Optional attribute. A value of 0 means that an Element can idle for infinity.  </li>
<li>可选属性，0表示一个元素可以无限的空闲  </li>
<li>The default value is 0.  </li>
<li>默认值是0。  </li>
<li></li>
<li>timeToLiveSeconds:  </li>
<li>Sets the time to live for an element before it expires.  </li>
<li>i.e. The maximum time between creation time and when an element expires.  </li>
<li>Is only used if the element is not eternal.  </li>
<li>Optional attribute. A value of 0 means that and Element can live for infinity.  </li>
<li>The default value is 0.  </li>
<li>在元素过期之前，设置一个存留时间。换言之，最大时间在创建时间和元素过期之间。仅用于元素非持久化。可选属性。值为0表示元素可无限存留，默认值是0  </li>
<li></li>
<li>diskPersistent:  </li>
<li>Whether the disk store persists between restarts of the Virtual Machine.  </li>
<li>The default value is false.  </li>
<li>磁盘存储是否在虚拟机重启后持续存在。默认只是false。  </li>
<li></li>
<li>diskExpiryThreadIntervalSeconds:  </li>
<li>The number of seconds between runs of the disk expiry thread. The default value  </li>
<li>is 120 seconds.  </li>
<li>秒数在运行和磁盘终止线程之间，默认值是120秒。  </li>
<li></li>
<li>diskSpoolBufferSizeMB:  </li>
<li>This is the size to allocate the DiskStore for a spool buffer. Writes are made  </li>
<li>to this area and then asynchronously written to disk. The default size is 30MB.  </li>
<li>Each spool buffer is used only by its cache. If you get OutOfMemory errors consider  </li>
<li>lowering this value. To improve DiskStore performance consider increasing it. Trace level  </li>
<li>logging in the DiskStore will show if put back ups are occurring.  </li>
<li>这是为后台打印缓冲分配在DiskStore的大小。在这一区域进行写入，并同步写入磁盘。默认值是30M。每个后台缓冲区仅由他的缓存使用，如出现OutOfMemory错误，考虑降低该值。为了提高DiskStore性能，考虑增加它。跟踪级别的DiskStore工作 将显示是否推迟出现。  </li>
<li></li>
<li>clearOnFlush:  </li>
<li>whether the MemoryStore should be cleared when flush() is called on the cache.  </li>
<li>By default, this is true i.e. the MemoryStore is cleared.  </li>
<li>当flush()在缓存中被调用时，MemoryStore是否被清除。默认是true，即MemoryStore被清除。  </li>
<li></li>
<li>memoryStoreEvictionPolicy:  </li>
<li>Policy would be enforced upon reaching the maxElementsInMemory limit. Default  </li>
<li>policy is Least Recently Used (specified as LRU). Other policies available -  </li>
<li>First In First Out (specified as FIFO) and Less Frequently Used  </li>
<li>(specified as LFU)  </li>
<li></li>
<li>Cache elements can also contain sub elements which take the same format of a factory class  </li>
<li>and properties. Defined sub-elements are:  </li>
<li>当达到maxElementsInMemory限制时，策略将强制执行。策略是最近最少使用的算法（简称为LRU）。其他的策略通用。缓存元素也可以有子元素，子元素拥有相同格式的工厂类和属性。定义的sub-elements有：  </li>
<li></li>
<li>/* cacheEventListenerFactory - Enables registration of listeners for cache events, such as  </li>
<li>put, remove, update, and expire.  </li>
<li>/* cacheEventListenerFactory – 启用缓存事件监听器的注册，如put, remove, update, and expire.  </li>
<li></li>
<li>/* bootstrapCacheLoaderFactory - Specifies a BootstrapCacheLoader, which is called by a  </li>
<li>cache on initialisation to prepopulate itself.  </li>
<li>/* bootstrapCacheLoaderFactory – 指定一个BootstrapCacheLoader，它被一个缓存在初始化时调用，用来预填充自己。  </li>
<li></li>
<li>/* cacheExtensionFactory - Specifies a CacheExtension, a generic mechansim to tie a class  </li>
<li>which holds a reference to a cache to the cache lifecycle.  </li>
<li>/* cacheExtensionFactory – 指定一个CacheExtension，一个通用的mechansim来联系一个保存引用到缓存的类到缓存生命周期。  </li>
<li></li>
<li>/* cacheExceptionHandlerFactory - Specifies a CacheExceptionHandler, which is called when  </li>
<li>cache exceptions occur.  </li>
<li>/* cacheExceptionHandlerFactory – 指定一个CacheExceptionHandler，每当缓存异常出现时调用。  </li>
<li></li>
<li>/* cacheLoaderFactory - Specifies a CacheLoader, which can be used both asynchronously and  </li>
<li>synchronously to load objects into a cache. More than one cacheLoaderFactory element  </li>
<li>can be added, in which case the loaders form a chain which are executed in order. If a  </li>
<li>loader returns null, the next in chain is called.  </li>
<li>/* cacheLoaderFactory – 指定一个CacheLoader，能够同步和异步装载对象到一个缓存。可以添加多个cacheLoaderFactory元素，在这种情况装载机形成一个链，被有序的执行。如果一个装载机返回null，下一个链就被调用。  </li>
<li></li>
<li>Cache Event Listeners  </li>
<li>缓存事件监听器  </li>
<li></li>
<li>All cacheEventListenerFactory elements can take an optional property listenFor that describes  </li>
<li>which events will be delivered in a clustered environment.  The listenFor attribute has the  </li>
<li>following allowed values:  </li>
<li>所有的cacheEventListenerFactory元素能选取一个可选属性listenFor描述的事件将在一个集群环境中交付。这个listenFor属性有如下允许的值：  </li>
<li></li>
<li>/* all - the default is to deliver all local and remote events  </li>
<li>/* local - deliver only events originating in the current node  </li>
<li>/* remote - deliver only events originating in other nodes  </li>
<li>/* all – 默认交付所有的本地和远程事件  </li>
<li>/* local – 交付的只是源于当前节点的事件  </li>
<li>/* remote - 交付的只是源于其他节点  </li>
<li></li>
<li>Example of setting up a logging listener for local cache events:  </li>
<li>设置一个本地缓存事件监听器的例子：  </li>
<li></li>
<li>&lt;cacheEventListenerFactory class=&quot;my.company.log.CacheLogger&quot;  </li>
<li>listenFor=&quot;local&quot; /&gt;  </li>
<li></li>
<li></li>
<li>Cache Exception Handling  </li>
<li>缓存异常处理  </li>
<li>++++++++++++++++++++++++  </li>
<li></li>
<li>By default, most cache operations will propagate a runtime CacheException on failure. An  </li>
<li>interceptor, using a dynamic proxy, may be configured so that a CacheExceptionHandler can  </li>
<li>be configured to intercept Exceptions. Errors are not intercepted.  </li>
<li>通常，大多数cache运行失败将产生运行时CacheException。通过使用代理，一个拦截器应该被配置，以便于能够配置CacheExceptionHandler拦截异常。错误并不被拦截。  </li>
<li></li>
<li>It is configured as per the following example:  </li>
<li>按照下面的例子配置：  </li>
<li></li>
<li>&lt;cacheExceptionHandlerFactory class=&quot;com.example.ExampleExceptionHandlerFactory&quot;  </li>
<li>properties=&quot;logLevel=FINE&quot;/&gt;  </li>
<li></li>
<li>Caches with ExceptionHandling configured are not of type Cache, but are of type Ehcache only,  </li>
<li>and are not available using CacheManager.getCache(), but using CacheManager.getEhcache().  </li>
<li>有ExceptionHandling配置的缓存并不是典型的Cache，但却是典型的Ehcache，并且不能使用CacheManager.getCache()，但能够使用CacheManager.getEhcache()。  </li>
<li></li>
<li></li>
<li>Cache Loader  </li>
<li>缓存装载  </li>
<li>++++++++++++  </li>
<li></li>
<li>A default CacheLoader may be set which loads objects into the cache through asynchronous and  </li>
<li>synchronous methods on Cache. This is different to the bootstrap cache loader, which is used  </li>
<li>only in distributed caching.  </li>
<li>一个默认的CacheLoader应该被设置成这样，能够通过Cache中的同步和异步方法装载对象到缓存中。这和仅在分布是缓存中被用到的缓存装载引导程序是不同的。  </li>
<li></li>
<li>It is configured as per the following example:  </li>
<li>按照如下示例配置：  </li>
<li></li>
<li>&lt;cacheLoaderFactory class=&quot;com.example.ExampleCacheLoaderFactory&quot;  </li>
<li>properties=&quot;type=int,startCounter=10&quot;/&gt;  </li>
<li></li>
<li>XA Cache  </li>
<li>++++++++  </li>
<li></li>
<li>To enable an ehcache as a participant in the JTA Transaction, just have the following attribute  </li>
<li>使ehcache作为JTA事务的参与者，只需要如下属性。  </li>
<li></li>
<li>transactionalMode=&quot;xa&quot;, otherwise the default is transactionalMode=&quot;off&quot;  </li>
<li>transactionalMode=&quot;xa&quot;, 否则，默认是 transactionalMode=&quot;off&quot;  </li>
<li></li>
<li></li>
<li>Cache Writer  </li>
<li>++++++++++++  </li>
<li></li>
<li>A CacheWriter maybe be set to write to an underlying resource. Only one CacheWriter can be  </li>
<li>been to a cache.  </li>
<li>一个CacheWriter可以设置写到底层资源中。只有一个CacheWriter能够成为一个cache。  </li>
<li></li>
<li>It is configured as per the following example for write-through:  </li>
<li>按照如下示例配置write-through：  </li>
<li></li>
<li><cacheWriter writeMode="write-through" notifyListenersOnException="true">  </li>
<li>&lt;cacheWriterFactory class=&quot;net.sf.ehcache.writer.TestCacheWriterFactory&quot;  </li>
<li>properties=&quot;type=int,startCounter=10&quot;/&gt;  </li>
<li></cacheWriter>  </li>
<li></li>
<li>And it is configured as per the following example for write-behind:  </li>
<li>按照如下示例配置write-behind:  </li>
<li></li>
<li>&lt;cacheWriter writeMode=&quot;write-behind&quot; minWriteDelay=&quot;1&quot; maxWriteDelay=&quot;5&quot;  </li>
<li>rateLimitPerSecond=&quot;5&quot; writeCoalescing=&quot;true&quot; writeBatching=&quot;true&quot; writeBatchSize=&quot;1&quot;  </li>
<li>retryAttempts=&quot;2&quot; retryAttemptDelaySeconds=&quot;1&quot;&gt;  </li>
<li>&lt;cacheWriterFactory class=&quot;net.sf.ehcache.writer.TestCacheWriterFactory&quot;  </li>
<li>properties=&quot;type=int,startCounter=10&quot;/&gt;  </li>
<li></cacheWriter>  </li>
<li></li>
<li>The cacheWriter element has the following attributes:  </li>
<li>cacheWriter元素有如下属性：  </li>
<li>/* writeMode: the write mode, write-through or write-behind  </li>
<li></li>
<li>These attributes only apply to write-through mode:  </li>
<li>这些属性仅适用于write-through模式：  </li>
<li>/* notifyListenersOnException: Sets whether to notify listeners when an exception occurs on a writer operation.  </li>
<li>/* notifyListenersOnException:设置当一个写操作出现异常时是否告知监听器。  </li>
<li></li>
<li>These attributes only apply to write-behind mode:  </li>
<li>这些属性仅适用于write-behind模式：  </li>
<li></li>
<li>/* minWriteDelay: Set the minimum number of seconds to wait before writing behind. If set to a value greater than 0,  </li>
<li>it permits operations to build up in the queue. This is different from the maximum write delay in that by waiting  </li>
<li>a minimum amount of time, work is always being built up. If the minimum write delay is set to zero and the  </li>
<li>CacheWriter performs its work very quickly, the overhead of processing the write behind queue items becomes very  </li>
<li>noticeable in a cluster since all the operations might be done for individual items instead of for a collection  </li>
<li>of them.  </li>
<li>/* minWriteDelay:设置write-behind之前的等待最小秒数。如果设置值比0大，则允许操作建立在队列中。和最大写入延迟不同，通过等待的最短时间，工作将同时被建立。如果最小写入延迟设置成0，并且CacheWriter快速执行程序，在一个集群中处理队列项目后的写入开销将会非常显著，因为所有的运行被单个项目完成，代替他们的一个集合。  </li>
<li></li>
<li>/* maxWriteDelay: Set the maximum number of seconds to wait before writing behind. If set to a value greater than 0,  </li>
<li>it permits operations to build up in the queue to enable effective coalescing and batching optimisations.  </li>
<li>/* maxWriteDelay:设置在后面写入之前等待的最大秒数。如设置值为0，它允许在队列里建立运行程序，以便有效地合并和批量优化。  </li>
<li></li>
<li>/* writeBatching: Sets whether to batch write operations. If set to true, writeAll and deleteAll will be called on  </li>
<li>the CacheWriter rather than write and delete being called for each key. Resources such as databases can perform  </li>
<li>more efficiently if updates are batched, thus reducing load.  </li>
<li>/* writeBatching:设置是否批量写入操作。如果设为true，writeAll 和deleteAll将调用CacheWriter，而不是为每个键调用write和delete。如果更新是批量的，诸如数据库资源可以更高效的执行，因此减少了负荷。  </li>
<li>/* writeBatchSize: Sets the number of operations to include in each batch when writeBatching is enabled. If there are  </li>
<li>less entries in the write-behind queue than the batch size, the queue length size is used.  </li>
<li>/* writeBatchSize:当writeBatching处于激活时，设置每批包含的操作的数目。如果write-behind队列的实体数少于每批的数目，就使用队列的长度。  </li>
<li>/* rateLimitPerSecond: Sets the maximum number of write operations to allow per second when writeBatching is enabled.  </li>
<li>/* rateLimitPerSecond:当writeBatching激活时，设置写操作每秒允许的最大数目。  </li>
<li>/* writeCoalescing: Sets whether to use write coalescing. If set to true and multiple operations on the same key are  </li>
<li>present in the write-behind queue, only the latest write is done, as the others are redundant.  </li>
<li>/* writeCoalescing: 设置是否使用写入联合。如果设为true并且同样的键有多个操作出现在write-behind队列，只有最新的写入完成，因为其他的成了多余的。  </li>
<li>/* retryAttempts: Sets the number of times the operation is retried in the CacheWriter, this happens after the  </li>
<li>original operation.  </li>
<li>/* retryAttempts:设置CacheWriter中重复操作的总次数，这发生在初次操作之后。  </li>
<li>/* retryAttemptDelaySeconds: Sets the number of seconds to wait before retrying an failed operation.  </li>
<li>/* retryAttemptDelaySeconds:设置在失败操作重试之前等待的秒数。  </li>
<li></li>
<li>Cache Extension  </li>
<li>+++++++++++++++  </li>
<li></li>
<li>CacheExtensions are a general purpose mechanism to allow generic extensions to a Cache.  </li>
<li>CacheExtensions are tied into the Cache lifecycle.  </li>
<li>CacheExtensions是一个总的作用机制允许Cache有普通异常。CacheExtensions与Cache生命周期紧密相连。  </li>
<li>CacheExtensions are created using the CacheExtensionFactory which has a  </li>
<li><code>createCacheCacheExtension()</code> method which takes as a parameter a  </li>
<li>Cache and properties. It can thus call back into any public method on Cache, including, of  </li>
<li>course, the load methods.  </li>
<li>创建CacheExtensions 来使用CacheExtensionFactory，他有一个<code>createCacheCacheExtension()</code>方法可以当做一个参数一个Cache和属性。因此CacheExtensions能够回调所有Cache中的公有方法，当然，包括装载方法。  </li>
<li></li>
<li>Extensions are added as per the following example:  </li>
<li>按照如下示例增加Extensions：  </li>
<li></li>
<li>&lt;cacheExtensionFactory class=&quot;com.example.FileWatchingCacheRefresherExtensionFactory&quot;  </li>
<li>properties=&quot;refreshIntervalMillis=18000, loaderTimeout=3000,  </li>
<li>flushPeriod=whatever, someOtherProperty=someValue ...&quot;/&gt;  </li>
<li></li>
<li>Terracotta Clustering  </li>
<li>+++++++++++++++++++++  </li>
<li></li>
<li>Cache elements can also contain information about whether the cache can be clustered with Terracotta.  </li>
<li>The <terracotta> sub-element has the following attributes:  </li>
<li>Cache元素也包含了有关是否缓存能和Terracotta聚集的信息。<terracotta>子元素有如下属性：  </li>
<li></li>
<li>/* clustered=true|false - indicates whether this cache should be clustered with Terracotta. By  </li>
<li>default, if the <terracotta> element is included, clustered=true.  </li>
<li>/* clustered=true|false – 显示这个cache是否应该和Terracotta聚集。如果包括<terracotta>元素，默认的是clustered=true。  </li>
<li>/* valueMode=serialization|identity - indicates whether this cache should be clustered with  </li>
<li>serialized copies of the values or using Terracotta identity mode.  By default, values will  </li>
<li>be cached in serialization mode which is similar to other replicated Ehcache modes.  The identity  </li>
<li>mode is only available in certain Terracotta deployment scenarios and will maintain actual object  </li>
<li>identity of the keys and values across the cluster.  In this case, all users of a value retrieved from  </li>
<li>the cache are using the same clustered value and must provide appropriate locking for any changes  </li>
<li>made to the value (or objects referred to by the value).  </li>
<li>/* valueMode=serialization|identity – 指出是否这个cache和值的序列化拷贝聚合或者使用Terracotta鉴定模式。通常，值将会在序列化模式中缓存，这和其他的再生Ehcache模式相似。身份模式只有在某些Terracotta部署方案中有效，并且通过集群保持实际对象身份的键和值。在这种情况下，所有从缓存取值的用户都使用相同的集群值，并且必须对值（或者值所引用的对象）的任何改变提供了合适的锁定。  </li>
<li>/* synchronousWrites=true|false - When set to true, clustered caches use  </li>
<li>Terracotta SYNCHRONOUS WRITE locks. Asynchronous writes (synchronousWrites=&quot;false&quot;) maximize performance by  </li>
<li>allowing clients to proceed without waiting for a &quot;transaction received&quot; acknowledgement from the server.  </li>
<li>Synchronous writes (synchronousWrites=&quot;true&quot;) maximize data safety by requiring that a client receive server  </li>
<li>acknowledgement of a transaction before that client can proceed. If coherence mode is disabled using  </li>
<li>configuration (coherent=&quot;false&quot;) or through the coherence API, only asynchronous writes can occur  </li>
<li>(synchronousWrites=&quot;true&quot; is ignored). By default this value is false (i.e. clustered caches use normal  </li>
<li>Terracotta WRITE locks).  </li>
<li>/* synchronousWrites=true|false – 当设为true时，缓存集群使用Terracotta SYNCHRONOUS WRITE锁。异步写入(synchronousWrites=&quot;false&quot;)最大的性能允许客户端继续而无需等待&quot;transaction received&quot;服务器的回应。同步写入(synchronousWrites=&quot;true&quot;)最大数据安全性，要求客户端再继续之前接收服务器端的事务响应。如果coherence模式不能使用配置(coherent=&quot;false&quot;)或者通过coherence API，仅异步写入能够存在(synchronousWrites=&quot;true&quot;被忽略)。通常，这个值为false（例. 聚集缓存使用正常的Terracotta WRITE锁）。  </li>
<li>/* coherent=true|false - indicates whether this cache should have coherent reads and writes with guaranteed  </li>
<li>consistency across the cluster.  By default, its value is true.  If this attribute is set to false  </li>
<li>(or &quot;incoherent&quot; mode), values from the cache are read without locking, possibly yielding stale data.  </li>
<li>Writes to a cache in incoherent mode are batched and applied without acquiring cluster-wide locks,  </li>
<li>possibly creating inconsistent values across cluster. Incoherent mode is a performance optimization  </li>
<li>with weaker concurrency guarantees and should generally be used for bulk-loading caches, for loading  </li>
<li>a read-only cache, or where the application that can tolerate reading stale data. This setting overrides  </li>
<li>coherentReads, which is deprecated.  </li>
<li>/* coherent=true|false – 指出是否这个缓存应使读和写前后一致并通过集群确保其一致性。通常默认值是true。如这个属性被设为false（或&quot;incoherent&quot;模式），缓存里没有锁定直接读取的值，可能产生坏的数据。随着并发保证的减弱，Incoherent模式是最优化性能，应该用于bulk-loading缓存，用于装载一个只读缓存，或用于程序中能够容忍读取损坏数据的地方。这个设置重载了coherentReads，这是不赞成的。  </li>
<li>/* copyOnRead=true|false - indicates whether cache values are deserialized on every read or if the  </li>
<li>materialized cache value can be re-used between get() calls. This setting is useful if a cache  </li>
<li>is being shared by callers with disparate classloaders or to prevent local drift if keys/values  </li>
<li>are mutated locally w/o putting back to the cache. NOTE: This setting is only relevant for caches  </li>
<li>with valueMode=serialization  </li>
<li>/* copyOnRead=true|false – 指出是否每个读出的缓存值是反序列化的，或者，是否具体的缓存值能够在get()调用之间被重用。这个设置很有用，如果一个缓存被不同的类装载器的调用者共享，或是阻止本地偏移如果键/值被组织本地w/o放回缓存。注意：这个设置仅对valueMode=serialization的缓存有意义。  </li>
<li></li>
<li></li>
<li>Simplest example to indicate clustering:  </li>
<li>最简单的集群实例：  </li>
<li><terracotta/>  </li>
<li></li>
<li>To indicate the cache should not be clustered (or remove the <terracotta> element altogether):  </li>
<li>指明缓存不被聚集（或一起移除<terracotta>元素）   </li>
<li><terracotta clustered="false"/>  </li>
<li></li>
<li>To indicate the cache should be clustered using identity mode:  </li>
<li>表示使用模式聚集缓存：  </li>
<li><terracotta clustered="true" valueMode="identity"/>        </li>
<li></li>
<li>To indicate the cache should be clustered using incoherent mode for bulk load:  </li>
<li>对大量的装载使用incoherent模式聚集缓存。  </li>
<li><terracotta clustered="true" coherent="false"/>  </li>
<li></li>
<li>To indicate the cache should be clustered using synchronous-write locking level:  </li>
<li>使用synchronous-write锁定水平应该聚集缓存。  </li>
<li><terracotta clustered="true" synchronousWrites="true"/>  </li>
<li>--&gt;  </li>
<li></li>
<li>&lt;!--  </li>
<li>Mandatory Default Cache configuration. These settings will be applied to caches  </li>
<li>created programmtically using CacheManager.add(String cacheName).  </li>
<li>强制预设缓存配置。这个设置将应用于缓存创建CacheManager.add(String cacheName)。  </li>
<li></li>
<li>The defaultCache has an implicit name &quot;default&quot; which is a reserved cache name.  </li>
<li>defaultCache有一个内涵的名称“default”，是一个预设的缓存名称。  </li>
<li>--&gt;  </li>
<li>&lt;defaultCache  </li>
<li>maxElementsInMemory=&quot;0&quot;  </li>
<li>eternal=&quot;false&quot;  </li>
<li>timeToIdleSeconds=&quot;1200&quot;  </li>
<li>timeToLiveSeconds=&quot;1200&quot;&gt;  </li>
<li><terracotta/>  </li>
<li></defaultCache>  </li>
<li></li>
<li>&lt;!--  </li>
<li>Sample caches. Following are some example caches. Remove these before use.  </li>
<li>缓存样本。以下是一些缓存实例，在使用前删掉这些。  </li>
<li>--&gt;  </li>
<li></li>
<li>&lt;!--  </li>
<li>Sample cache named sampleCache1  </li>
<li>This cache contains a maximum in memory of 10000 elements, and will expire  </li>
<li>an element if it is idle for more than 5 minutes and lives for more than  </li>
<li>10 minutes.  </li>
<li>缓存实例名为sampleCache1，这个缓存的最大存储量为10000个元素，如果一个元素空闲时间超过5分钟就会失效并且生命周期超过10分钟。  </li>
<li></li>
<li>If there are more than 10000 elements it will overflow to the  </li>
<li>disk cache, which in this configuration will go to wherever java.io.tmp is  </li>
<li>defined on your system. On a standard Linux system this will be /tmp&quot;  </li>
<li>如果超过了10000个元素，磁盘缓存将会溢出，在这个缓存中，这个配置将找到你系统中任何定义java.io.tmp的地方。在标准的Linux系统中，这将会是/tmp&quot;。  </li>
<li></li>
<li></li>
<li>--&gt;  </li>
<li>&lt;cache name=&quot;sampleCache1&quot;  </li>
<li>maxElementsInMemory=&quot;10000&quot;  </li>
<li>maxElementsOnDisk=&quot;1000&quot;  </li>
<li>eternal=&quot;false&quot;  </li>
<li>overflowToDisk=&quot;true&quot;  </li>
<li>diskSpoolBufferSizeMB=&quot;20&quot;  </li>
<li>timeToIdleSeconds=&quot;300&quot;  </li>
<li>timeToLiveSeconds=&quot;600&quot;  </li>
<li>memoryStoreEvictionPolicy=&quot;LFU&quot;  </li>
<li>/&gt;  </li>
<li></li>
<li></li>
<li>&lt;!--  </li>
<li>Sample cache named sampleCache2  </li>
<li>实例缓存sampleCache2  </li>
<li>This cache has a maximum of 1000 elements in memory. There is no overflow to disk, so 1000  </li>
<li>is also the maximum cache size. Note that when a cache is eternal, timeToLive and  </li>
<li>timeToIdle are not used and do not need to be specified.  </li>
<li>这个缓存的最大存储容量是1000个元素。没有磁盘溢出，因此，1000也是缓存的最大长度。要注意的是，当缓存持久化后, timeToLive和timeToIdle将不被使用，并且不需要特别指定。  </li>
<li>--&gt;  </li>
<li>&lt;cache name=&quot;sampleCache2&quot;  </li>
<li>maxElementsInMemory=&quot;1000&quot;  </li>
<li>eternal=&quot;true&quot;  </li>
<li>overflowToDisk=&quot;false&quot;  </li>
<li>memoryStoreEvictionPolicy=&quot;FIFO&quot;  </li>
<li>/&gt;  </li>
<li></li>
<li></li>
<li>&lt;!--  </li>
<li>Sample cache named sampleCache3. This cache overflows to disk. The disk store is  </li>
<li>persistent between cache and VM restarts. The disk expiry thread interval is set to 10  </li>
<li>minutes, overriding the default of 2 minutes.  </li>
<li>示例sampleCache3。这个缓存溢出到磁盘。磁盘存储在缓存和VM重启的时候是持续的。磁盘期满间隔设置为10分钟，覆盖原来的2分钟。  </li>
<li>--&gt;  </li>
<li>&lt;cache name=&quot;sampleCache3&quot;  </li>
<li>maxElementsInMemory=&quot;500&quot;  </li>
<li>eternal=&quot;false&quot;  </li>
<li>overflowToDisk=&quot;true&quot;  </li>
<li>timeToIdleSeconds=&quot;300&quot;  </li>
<li>timeToLiveSeconds=&quot;600&quot;  </li>
<li>diskPersistent=&quot;true&quot;  </li>
<li>diskExpiryThreadIntervalSeconds=&quot;1&quot;  </li>
<li>memoryStoreEvictionPolicy=&quot;LFU&quot;  </li>
<li>/&gt;  </li>
<li></li>
<li>&lt;!--  </li>
<li>Sample Terracotta clustered cache named sampleTerracottaCache.  </li>
<li>This cache uses Terracotta to cluster the contents of the cache.  </li>
<li>Terracotta集群缓存示例sampleTerracottaCache。这个缓存使用Terracotta聚集缓存内容。  </li>
<li>--&gt;  </li>
<li>&lt;cache name=&quot;sampleTerracottaCache&quot;  </li>
<li>maxElementsInMemory=&quot;1000&quot;  </li>
<li>eternal=&quot;false&quot;  </li>
<li>timeToIdleSeconds=&quot;3600&quot;  </li>
<li>timeToLiveSeconds=&quot;1800&quot;  </li>
<li>overflowToDisk=&quot;false&quot;&gt;  </li>
<li></li>
<li><terracotta/>  </li>
<li></cache>  </li>
<li></li>
<li>&lt;!--  </li>
<li>Sample xa enabled cache name xaCache  </li>
<li>Xa激活缓存示例xaCache  </li>
<li>--&gt;  </li>
<li></li>
<li>&lt;cache name=&quot;xaCache&quot;  </li>
<li>maxElementsInMemory=&quot;500&quot;  </li>
<li>eternal=&quot;false&quot;  </li>
<li>timeToIdleSeconds=&quot;300&quot;  </li>
<li>timeToLiveSeconds=&quot;600&quot;  </li>
<li>overflowToDisk=&quot;false&quot;  </li>
<li>diskPersistent=&quot;false&quot;  </li>
<li>diskExpiryThreadIntervalSeconds=&quot;1&quot;  </li>
<li>transactionalMode=&quot;xa&quot;&gt;  </li>
<li><terracotta clustered="true"/>  </li>
<li></cache>  </li>
<li></li>
<li></li>
<li></ehcache>  </li>
<li></li>
<li></li>
<li></li>
<li>设置完全限定类名被注册为CacheManager事件监听器。  </li>
<li></li>
<li>事件包括：  </li>
<li>/* adding a Cache增加一个缓存  </li>
<li>/* removing a Cache移除一个缓存  </li>
<li>设置元素是否持久化，如果持久化，将忽视超时并且元素永不过期。  </li>
<li>回调监听器的方法有同步和异步两种。安全的处理潜在的麻烦和线程安全问题将是实施者的责任，这依取决于他们的监听器在干什么。  </li>
<li></li>
<li>如果没有类指定，就不会创建监听器。这里没有默认值。  </li>
<li><cacheManagerEventListenerFactory class="" properties=""/>  </li>
<li></li>
<li>&lt;!--  </li>
<li>TerracottaConfig  </li>
<li>========================  </li>
<li>maxElementsOnDisk:  </li>
<li></li>
<li>设置磁盘存储器维持的对象的最大数目。默认是0，意味着没有限制。  </li>
<li>eternal:  </li>
<li>激活Terracotta集群选项)  </li>
<li></li>
<li>注意：你需要安装运行一个或多个Terracotta服务器来使用Terracotta集群。  </li>
<li>参看<a href="http://www.terracotta.org/web/display/orgsite/Download" target="_blank">http://www.terracotta.org/web/display/orgsite/Download</a>  </li>
<li></li>
<li></li>
<li>使用多个Terracotta服务器实例URLs（容错能力）的例子  </li>
<li><terracottaConfig url="host1:9510,host2:9510,host3:9510"/>  </li>
<li>maxElementsInMemory:  </li>
<li></li>
<li>设置创建到存储器中的对象的最大数目。  </li>
<li>在ehcache配置文件中嵌入一个Terracotta配置文件简单的放置一个普通的Terracotta XML配置到<terracottaConfig>元素中。  </li>
<li></li>
<li>Example:  </li>
<li><terracottaConfig>  </li>
<li><tc-config>  </li>
<li><servers>  </li>
<li><server host="server1" name="s1"/>  </li>
<li><server host="server2" name="s2"/>  </li>
<li></servers>  </li>
<li><clients>  </li>
<li><logs>app/logs-%i</logs>  </li>
<li></clients>           </li>
<li></tc-config>  </li>
<li></terracottaConfig>  </li>
<li>更多的Terracotta信息，参看Terracotta文档。  </li>
<li>--&gt;  </li>
<li><terracottaConfig url="localhost:9510"/>  </li>
<li></li>
<li>&lt;!--  </li>
<li>Cache configuration  </li>
<li>===================  </li>
<li></li>
<li>The following attributes are required.  </li>
<li>如下属性都需要：  </li>
<li>name:  </li>
<li></li>
<li>设置缓存的名称。用于鉴定缓存，他必须是唯一的。  </li>
<li></li>
<li>指定一个TerracottaConfig用于为CacheManager配置Terracotta运行时。  </li>
<li></li>
<li>配置文件可以通过两种主要方式指定：通过引用配置文件或者使用Terracotta嵌入式配置文件。  </li>
<li></li>
<li>使用URL属性指定一个配置资源（或者多个）的引用。URL属性必须包含一个逗号隔开的列表：  </li>
<li>/* path（Terracotta配置文件的路径）(通常命名为 tc-config.xml)  </li>
<li>/* URL Terracotta配置文件的URL  </li>
<li>/* <server host>:<port> Terracotta服务器运行实例  </li>
<li>最简单的例子指出这台机器上的一个Terracotta服务器：  </li>
<li><terracottaConfig url="localhost:9510"/>  </li>
<li>使用Terracotta配置文件路径的例子：  </li>
<li><terracottaConfig url="/app/config/tc-config.xml"/>  </li>
<li>使用Terracotta配置文件URL的例子：  </li>
<li><terracottaConfig url="http://internal/ehcache/app/tc-config.xml"/><br>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; <!-- CacheManager配置 ========================== 一个ehcache.xml 相当于一个单个的CacheManager 学习下面的说明或者ehcache构架（ehcache.xsd）怎样配置 系统资源标识在这个文件中能被具体制定，当配置被加载时，他们将会被替换。例如 multicastGroupPort=${multicastGroupPort}被环境变量的系统属性替换，或是使用如-DmulticastGroupPort=4446命令行开关指定一个系统属性。 <ehcache>的属性如下： /* name – CacheManager的可选名称。这个名称起初主要是用于文档记录或辨别Terracotta集群状态。对于Terracotta集群的缓存，一组CacheManager名称和cache名称唯一的鉴定了一个特定的存储于Terracotta集群存储器的缓存。 /* updateCheck – 一个可选的boolean标识符，指定这个CacheManager是否通过Internet检查Ehcache的新版本。如果没有特别指明，updateCheck="true". /* monitoring – 一个可选的设置，决定CacheManager是否应该自动的用系统MBean服务器注册SampledCacheMBean。当下，这个监测。只有当使用Terracotta集群和使用Terracotta Developer Console时才有用。使用"autodetect"值，Terracotta集群的出现将被检测和监视，并通过Developer控制台激活。其他允许的值有："on" 和 "off"。默认为"autodetect"。当使用JMX监测时，这个设置不会产生任何作用。 /* dynamicConfig – 一个可选设置，能够使与这个CacheManager相关联的动态配置失活。这个设置的默认值是true-例如，动态配置是激活的。动态配置的缓存通过缓存的配置对象让他们的TTI, TTL 和maximum disk 和in-memory capacity在运行时改变。 --> <ehcache xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="ehcache.xsd" updateCheck="true" monitoring="autodetect" dynamicConfig="true" > <!-- DiskStore configuration ======================= 磁盘存储器是可选的。关闭磁盘存储路径创建，解释下面的磁盘存储器元素。 对于任何缓存，如果你已经激活了overflowToDisk或diskPersistent，就要配置磁盘存储器。 如果他未配置，并且创建了一个需要磁盘存储的缓存，将会发出一个警告并且java.io.tmpdir将会自动使用。 磁盘存储器仅有一个属性- "path"。这个路径就是.data and .index文件被创建的目录路径。 如果这个路径是下述Java系统属性之一，他将会被运行中的VM中的值替换。为了向后兼容，这些应该被特别规定，而不会被${token}替换语法封闭。 下列属性翻译： /* user.home -用户的根目录 /* user.dir – 用户的当前工作目录 /* java.io.tmpdir – 默认临时文件路径 /* ehcache.disk.store.dir – 一个系统属性，你通常用命令行指定； 例如： java -Dehcache.disk.store.dir=/u01/myapp/diskdir ... 子目录通过如下属性指定，例如：java.io.tmpdir/one --> <diskStore path="java.io.tmpdir"/> <!-- TransactionManagerLookup configuration ====================================== TransactionManagerLookup 配置 这个类被ehcache用XA激活的ehcache来查找用于应用程序中的JTA TransactionManager。如果没有指定类，那么DefaultTransactionManagerLookup将以如下顺序找到TransactionManager。 /*GenericJNDI（例如：jboss，属性jndiName控制TransactionManager对象的名称来查找） /*Websphere /*Bitronix /*Atomikos 你可以提供自己的查找类实现net.sf.ehcache.transaction.manager.TransactionManagerLookup接口。 <transactionManagerLookup class="net.sf.ehcache.transaction.manager.DefaultTransactionManagerLookup" properties="" propertySeparator=":"/> <!-- CacheManagerEventListener ========================= 指定一个CacheManagerEventListenerFactory，当缓存被增加或从CacheManager移除时被告知。 CacheManagerEventListenerFactory的属性有： /* class – 一个完全限定的工厂类名。 /* properties – 逗号隔开的属性只对工厂有意义。 overflowToDisk:设置元素是否能溢出磁盘，当存储器容量达到最大存储限制。 如下属性和元素是可选的。 timeToIdleSeconds: Sets the time to idle for an element before it expires. 设置一个元素在过期前的空闲时间 i.e. The maximum amount of time between accesses before an element expires Is only used if the element is not eternal. 换言之，最大时间数在进入之后和元素过期之前这段时间之间，只有元素在非持久化时才有用。 Optional attribute. A value of 0 means that an Element can idle for infinity. 可选属性，0表示一个元素可以无限的空闲 The default value is 0. 默认值是0。 timeToLiveSeconds: Sets the time to live for an element before it expires. i.e. The maximum time between creation time and when an element expires. Is only used if the element is not eternal. Optional attribute. A value of 0 means that and Element can live for infinity. The default value is 0. 在元素过期之前，设置一个存留时间。换言之，最大时间在创建时间和元素过期之间。仅用于元素非持久化。可选属性。值为0表示元素可无限存留，默认值是0 diskPersistent: Whether the disk store persists between restarts of the Virtual Machine. The default value is false. 磁盘存储是否在虚拟机重启后持续存在。默认只是false。 diskExpiryThreadIntervalSeconds: The number of seconds between runs of the disk expiry thread. The default value is 120 seconds. 秒数在运行和磁盘终止线程之间，默认值是120秒。 diskSpoolBufferSizeMB: This is the size to allocate the DiskStore for a spool buffer. Writes are made to this area and then asynchronously written to disk. The default size is 30MB. Each spool buffer is used only by its cache. If you get OutOfMemory errors consider lowering this value. To improve DiskStore performance consider increasing it. Trace level logging in the DiskStore will show if put back ups are occurring. 这是为后台打印缓冲分配在DiskStore的大小。在这一区域进行写入，并同步写入磁盘。默认值是30M。每个后台缓冲区仅由他的缓存使用，如出现OutOfMemory错误，考虑降低该值。为了提高DiskStore性能，考虑增加它。跟踪级别的DiskStore工作 将显示是否推迟出现。 clearOnFlush: whether the MemoryStore should be cleared when flush() is called on the cache. By default, this is true i.e. the MemoryStore is cleared. 当flush()在缓存中被调用时，MemoryStore是否被清除。默认是true，即MemoryStore被清除。 memoryStoreEvictionPolicy: Policy would be enforced upon reaching the maxElementsInMemory limit. Default policy is Least Recently Used (specified as LRU). Other policies available - First In First Out (specified as FIFO) and Less Frequently Used (specified as LFU) Cache elements can also contain sub elements which take the same format of a factory class and properties. Defined sub-elements are: 当达到maxElementsInMemory限制时，策略将强制执行。策略是最近最少使用的算法（简称为LRU）。其他的策略通用。缓存元素也可以有子元素，子元素拥有相同格式的工厂类和属性。定义的sub-elements有： /* cacheEventListenerFactory - Enables registration of listeners for cache events, such as put, remove, update, and expire. /* cacheEventListenerFactory – 启用缓存事件监听器的注册，如put, remove, update, and expire. /* bootstrapCacheLoaderFactory - Specifies a BootstrapCacheLoader, which is called by a cache on initialisation to prepopulate itself. /* bootstrapCacheLoaderFactory – 指定一个BootstrapCacheLoader，它被一个缓存在初始化时调用，用来预填充自己。 /* cacheExtensionFactory - Specifies a CacheExtension, a generic mechansim to tie a class which holds a reference to a cache to the cache lifecycle. /* cacheExtensionFactory – 指定一个CacheExtension，一个通用的mechansim来联系一个保存引用到缓存的类到缓存生命周期。 /* cacheExceptionHandlerFactory - Specifies a CacheExceptionHandler, which is called when cache exceptions occur. /* cacheExceptionHandlerFactory – 指定一个CacheExceptionHandler，每当缓存异常出现时调用。 /* cacheLoaderFactory - Specifies a CacheLoader, which can be used both asynchronously and synchronously to load objects into a cache. More than one cacheLoaderFactory element can be added, in which case the loaders form a chain which are executed in order. If a loader returns null, the next in chain is called. /* cacheLoaderFactory – 指定一个CacheLoader，能够同步和异步装载对象到一个缓存。可以添加多个cacheLoaderFactory元素，在这种情况装载机形成一个链，被有序的执行。如果一个装载机返回null，下一个链就被调用。 Cache Event Listeners 缓存事件监听器 All cacheEventListenerFactory elements can take an optional property listenFor that describes which events will be delivered in a clustered environment. The listenFor attribute has the following allowed values: 所有的cacheEventListenerFactory元素能选取一个可选属性listenFor描述的事件将在一个集群环境中交付。这个listenFor属性有如下允许的值： /* all - the default is to deliver all local and remote events /* local - deliver only events originating in the current node /* remote - deliver only events originating in other nodes /* all – 默认交付所有的本地和远程事件 /* local – 交付的只是源于当前节点的事件 /* remote - 交付的只是源于其他节点 Example of setting up a logging listener for local cache events: 设置一个本地缓存事件监听器的例子： <cacheEventListenerFactory class="my.company.log.CacheLogger" listenFor="local" /> Cache Exception Handling 缓存异常处理 ++++++++++++++++++++++++ By default, most cache operations will propagate a runtime CacheException on failure. An interceptor, using a dynamic proxy, may be configured so that a CacheExceptionHandler can be configured to intercept Exceptions. Errors are not intercepted. 通常，大多数cache运行失败将产生运行时CacheException。通过使用代理，一个拦截器应该被配置，以便于能够配置CacheExceptionHandler拦截异常。错误并不被拦截。 It is configured as per the following example: 按照下面的例子配置： <cacheExceptionHandlerFactory class="com.example.ExampleExceptionHandlerFactory" properties="logLevel=FINE"/> Caches with ExceptionHandling configured are not of type Cache, but are of type Ehcache only, and are not available using CacheManager.getCache(), but using CacheManager.getEhcache(). 有ExceptionHandling配置的缓存并不是典型的Cache，但却是典型的Ehcache，并且不能使用CacheManager.getCache()，但能够使用CacheManager.getEhcache()。 Cache Loader 缓存装载 ++++++++++++ A default CacheLoader may be set which loads objects into the cache through asynchronous and synchronous methods on Cache. This is different to the bootstrap cache loader, which is used only in distributed caching. 一个默认的CacheLoader应该被设置成这样，能够通过Cache中的同步和异步方法装载对象到缓存中。这和仅在分布是缓存中被用到的缓存装载引导程序是不同的。 It is configured as per the following example: 按照如下示例配置： <cacheLoaderFactory class="com.example.ExampleCacheLoaderFactory" properties="type=int,startCounter=10"/> XA Cache ++++++++ To enable an ehcache as a participant in the JTA Transaction, just have the following attribute 使ehcache作为JTA事务的参与者，只需要如下属性。 transactionalMode="xa", otherwise the default is transactionalMode="off" transactionalMode="xa", 否则，默认是 transactionalMode="off" Cache Writer ++++++++++++ A CacheWriter maybe be set to write to an underlying resource. Only one CacheWriter can be been to a cache. 一个CacheWriter可以设置写到底层资源中。只有一个CacheWriter能够成为一个cache。 It is configured as per the following example for write-through: 按照如下示例配置write-through： <cacheWriter writeMode="write-through" notifyListenersOnException="true"> <cacheWriterFactory class="net.sf.ehcache.writer.TestCacheWriterFactory" properties="type=int,startCounter=10"/> </cacheWriter> And it is configured as per the following example for write-behind: 按照如下示例配置write-behind: <cacheWriter writeMode="write-behind" minWriteDelay="1" maxWriteDelay="5" rateLimitPerSecond="5" writeCoalescing="true" writeBatching="true" writeBatchSize="1" retryAttempts="2" retryAttemptDelaySeconds="1"> <cacheWriterFactory class="net.sf.ehcache.writer.TestCacheWriterFactory" properties="type=int,startCounter=10"/> </cacheWriter> The cacheWriter element has the following attributes: cacheWriter元素有如下属性： /* writeMode: the write mode, write-through or write-behind These attributes only apply to write-through mode: 这些属性仅适用于write-through模式： /* notifyListenersOnException: Sets whether to notify listeners when an exception occurs on a writer operation. /* notifyListenersOnException:设置当一个写操作出现异常时是否告知监听器。 These attributes only apply to write-behind mode: 这些属性仅适用于write-behind模式： /* minWriteDelay: Set the minimum number of seconds to wait before writing behind. If set to a value greater than 0, it permits operations to build up in the queue. This is different from the maximum write delay in that by waiting a minimum amount of time, work is always being built up. If the minimum write delay is set to zero and the CacheWriter performs its work very quickly, the overhead of processing the write behind queue items becomes very noticeable in a cluster since all the operations might be done for individual items instead of for a collection of them. /* minWriteDelay:设置write-behind之前的等待最小秒数。如果设置值比0大，则允许操作建立在队列中。和最大写入延迟不同，通过等待的最短时间，工作将同时被建立。如果最小写入延迟设置成0，并且CacheWriter快速执行程序，在一个集群中处理队列项目后的写入开销将会非常显著，因为所有的运行被单个项目完成，代替他们的一个集合。 /* maxWriteDelay: Set the maximum number of seconds to wait before writing behind. If set to a value greater than 0, it permits operations to build up in the queue to enable effective coalescing and batching optimisations. /* maxWriteDelay:设置在后面写入之前等待的最大秒数。如设置值为0，它允许在队列里建立运行程序，以便有效地合并和批量优化。 /* writeBatching: Sets whether to batch write operations. If set to true, writeAll and deleteAll will be called on the CacheWriter rather than write and delete being called for each key. Resources such as databases can perform more efficiently if updates are batched, thus reducing load. /* writeBatching:设置是否批量写入操作。如果设为true，writeAll 和deleteAll将调用CacheWriter，而不是为每个键调用write和delete。如果更新是批量的，诸如数据库资源可以更高效的执行，因此减少了负荷。 /* writeBatchSize: Sets the number of operations to include in each batch when writeBatching is enabled. If there are less entries in the write-behind queue than the batch size, the queue length size is used. /* writeBatchSize:当writeBatching处于激活时，设置每批包含的操作的数目。如果write-behind队列的实体数少于每批的数目，就使用队列的长度。 /* rateLimitPerSecond: Sets the maximum number of write operations to allow per second when writeBatching is enabled. /* rateLimitPerSecond:当writeBatching激活时，设置写操作每秒允许的最大数目。 /* writeCoalescing: Sets whether to use write coalescing. If set to true and multiple operations on the same key are present in the write-behind queue, only the latest write is done, as the others are redundant. /* writeCoalescing: 设置是否使用写入联合。如果设为true并且同样的键有多个操作出现在write-behind队列，只有最新的写入完成，因为其他的成了多余的。 /* retryAttempts: Sets the number of times the operation is retried in the CacheWriter, this happens after the original operation. /* retryAttempts:设置CacheWriter中重复操作的总次数，这发生在初次操作之后。 /* retryAttemptDelaySeconds: Sets the number of seconds to wait before retrying an failed operation. /* retryAttemptDelaySeconds:设置在失败操作重试之前等待的秒数。 Cache Extension +++++++++++++++ CacheExtensions are a general purpose mechanism to allow generic extensions to a Cache. CacheExtensions are tied into the Cache lifecycle. CacheExtensions是一个总的作用机制允许Cache有普通异常。CacheExtensions与Cache生命周期紧密相连。 CacheExtensions are created using the CacheExtensionFactory which has a <code>createCacheCacheExtension()</code> method which takes as a parameter a Cache and properties. It can thus call back into any public method on Cache, including, of course, the load methods. 创建CacheExtensions 来使用CacheExtensionFactory，他有一个<code>createCacheCacheExtension()</code>方法可以当做一个参数一个Cache和属性。因此CacheExtensions能够回调所有Cache中的公有方法，当然，包括装载方法。 Extensions are added as per the following example: 按照如下示例增加Extensions： <cacheExtensionFactory class="com.example.FileWatchingCacheRefresherExtensionFactory" properties="refreshIntervalMillis=18000, loaderTimeout=3000, flushPeriod=whatever, someOtherProperty=someValue ..."/> Terracotta Clustering +++++++++++++++++++++ Cache elements can also contain information about whether the cache can be clustered with Terracotta. The <terracotta> sub-element has the following attributes: Cache元素也包含了有关是否缓存能和Terracotta聚集的信息。<terracotta>子元素有如下属性： /* clustered=true|false - indicates whether this cache should be clustered with Terracotta. By default, if the <terracotta> element is included, clustered=true. /* clustered=true|false – 显示这个cache是否应该和Terracotta聚集。如果包括<terracotta>元素，默认的是clustered=true。 /* valueMode=serialization|identity - indicates whether this cache should be clustered with serialized copies of the values or using Terracotta identity mode. By default, values will be cached in serialization mode which is similar to other replicated Ehcache modes. The identity mode is only available in certain Terracotta deployment scenarios and will maintain actual object identity of the keys and values across the cluster. In this case, all users of a value retrieved from the cache are using the same clustered value and must provide appropriate locking for any changes made to the value (or objects referred to by the value). /* valueMode=serialization|identity – 指出是否这个cache和值的序列化拷贝聚合或者使用Terracotta鉴定模式。通常，值将会在序列化模式中缓存，这和其他的再生Ehcache模式相似。身份模式只有在某些Terracotta部署方案中有效，并且通过集群保持实际对象身份的键和值。在这种情况下，所有从缓存取值的用户都使用相同的集群值，并且必须对值（或者值所引用的对象）的任何改变提供了合适的锁定。 /* synchronousWrites=true|false - When set to true, clustered caches use Terracotta SYNCHRONOUS WRITE locks. Asynchronous writes (synchronousWrites="false") maximize performance by allowing clients to proceed without waiting for a "transaction received" acknowledgement from the server. Synchronous writes (synchronousWrites="true") maximize data safety by requiring that a client receive server acknowledgement of a transaction before that client can proceed. If coherence mode is disabled using configuration (coherent="false") or through the coherence API, only asynchronous writes can occur (synchronousWrites="true" is ignored). By default this value is false (i.e. clustered caches use normal Terracotta WRITE locks). /* synchronousWrites=true|false – 当设为true时，缓存集群使用Terracotta SYNCHRONOUS WRITE锁。异步写入(synchronousWrites="false")最大的性能允许客户端继续而无需等待"transaction received"服务器的回应。同步写入(synchronousWrites="true")最大数据安全性，要求客户端再继续之前接收服务器端的事务响应。如果coherence模式不能使用配置(coherent="false")或者通过coherence API，仅异步写入能够存在(synchronousWrites="true"被忽略)。通常，这个值为false（例. 聚集缓存使用正常的Terracotta WRITE锁）。 /* coherent=true|false - indicates whether this cache should have coherent reads and writes with guaranteed consistency across the cluster. By default, its value is true. If this attribute is set to false (or "incoherent" mode), values from the cache are read without locking, possibly yielding stale data. Writes to a cache in incoherent mode are batched and applied without acquiring cluster-wide locks, possibly creating inconsistent values across cluster. Incoherent mode is a performance optimization with weaker concurrency guarantees and should generally be used for bulk-loading caches, for loading a read-only cache, or where the application that can tolerate reading stale data. This setting overrides coherentReads, which is deprecated. /* coherent=true|false – 指出是否这个缓存应使读和写前后一致并通过集群确保其一致性。通常默认值是true。如这个属性被设为false（或"incoherent"模式），缓存里没有锁定直接读取的值，可能产生坏的数据。随着并发保证的减弱，Incoherent模式是最优化性能，应该用于bulk-loading缓存，用于装载一个只读缓存，或用于程序中能够容忍读取损坏数据的地方。这个设置重载了coherentReads，这是不赞成的。 /* copyOnRead=true|false - indicates whether cache values are deserialized on every read or if the materialized cache value can be re-used between get() calls. This setting is useful if a cache is being shared by callers with disparate classloaders or to prevent local drift if keys/values are mutated locally w/o putting back to the cache. NOTE: This setting is only relevant for caches with valueMode=serialization /* copyOnRead=true|false – 指出是否每个读出的缓存值是反序列化的，或者，是否具体的缓存值能够在get()调用之间被重用。这个设置很有用，如果一个缓存被不同的类装载器的调用者共享，或是阻止本地偏移如果键/值被组织本地w/o放回缓存。注意：这个设置仅对valueMode=serialization的缓存有意义。 Simplest example to indicate clustering: 最简单的集群实例： <terracotta/> To indicate the cache should not be clustered (or remove the <terracotta> element altogether): 指明缓存不被聚集（或一起移除<terracotta>元素） <terracotta clustered="false"/> To indicate the cache should be clustered using identity mode: 表示使用模式聚集缓存： <terracotta clustered="true" valueMode="identity"/> To indicate the cache should be clustered using incoherent mode for bulk load: 对大量的装载使用incoherent模式聚集缓存。 <terracotta clustered="true" coherent="false"/> To indicate the cache should be clustered using synchronous-write locking level: 使用synchronous-write锁定水平应该聚集缓存。 <terracotta clustered="true" synchronousWrites="true"/> --> <!-- Mandatory Default Cache configuration. These settings will be applied to caches created programmtically using CacheManager.add(String cacheName). 强制预设缓存配置。这个设置将应用于缓存创建CacheManager.add(String cacheName)。 The defaultCache has an implicit name "default" which is a reserved cache name. defaultCache有一个内涵的名称“default”，是一个预设的缓存名称。 --> <defaultCache maxElementsInMemory="0" eternal="false" timeToIdleSeconds="1200" timeToLiveSeconds="1200"> <terracotta/> </defaultCache> <!-- Sample caches. Following are some example caches. Remove these before use. 缓存样本。以下是一些缓存实例，在使用前删掉这些。 --> <!-- Sample cache named sampleCache1 This cache contains a maximum in memory of 10000 elements, and will expire an element if it is idle for more than 5 minutes and lives for more than 10 minutes. 缓存实例名为sampleCache1，这个缓存的最大存储量为10000个元素，如果一个元素空闲时间超过5分钟就会失效并且生命周期超过10分钟。 If there are more than 10000 elements it will overflow to the disk cache, which in this configuration will go to wherever java.io.tmp is defined on your system. On a standard Linux system this will be /tmp" 如果超过了10000个元素，磁盘缓存将会溢出，在这个缓存中，这个配置将找到你系统中任何定义java.io.tmp的地方。在标准的Linux系统中，这将会是/tmp"。 --> <cache name="sampleCache1" maxElementsInMemory="10000" maxElementsOnDisk="1000" eternal="false" overflowToDisk="true" diskSpoolBufferSizeMB="20" timeToIdleSeconds="300" timeToLiveSeconds="600" memoryStoreEvictionPolicy="LFU" /> <!-- Sample cache named sampleCache2 实例缓存sampleCache2 This cache has a maximum of 1000 elements in memory. There is no overflow to disk, so 1000 is also the maximum cache size. Note that when a cache is eternal, timeToLive and timeToIdle are not used and do not need to be specified. 这个缓存的最大存储容量是1000个元素。没有磁盘溢出，因此，1000也是缓存的最大长度。要注意的是，当缓存持久化后, timeToLive和timeToIdle将不被使用，并且不需要特别指定。 --> <cache name="sampleCache2" maxElementsInMemory="1000" eternal="true" overflowToDisk="false" memoryStoreEvictionPolicy="FIFO" /> <!-- Sample cache named sampleCache3. This cache overflows to disk. The disk store is persistent between cache and VM restarts. The disk expiry thread interval is set to 10 minutes, overriding the default of 2 minutes. 示例sampleCache3。这个缓存溢出到磁盘。磁盘存储在缓存和VM重启的时候是持续的。磁盘期满间隔设置为10分钟，覆盖原来的2分钟。 --> <cache name="sampleCache3" maxElementsInMemory="500" eternal="false" overflowToDisk="true" timeToIdleSeconds="300" timeToLiveSeconds="600" diskPersistent="true" diskExpiryThreadIntervalSeconds="1" memoryStoreEvictionPolicy="LFU" /> <!-- Sample Terracotta clustered cache named sampleTerracottaCache. This cache uses Terracotta to cluster the contents of the cache. Terracotta集群缓存示例sampleTerracottaCache。这个缓存使用Terracotta聚集缓存内容。 --> <cache name="sampleTerracottaCache" maxElementsInMemory="1000" eternal="false" timeToIdleSeconds="3600" timeToLiveSeconds="1800" overflowToDisk="false"> <terracotta/> </cache> <!-- Sample xa enabled cache name xaCache Xa激活缓存示例xaCache --> <cache name="xaCache" maxElementsInMemory="500" eternal="false" timeToIdleSeconds="300" timeToLiveSeconds="600" overflowToDisk="false" diskPersistent="false" diskExpiryThreadIntervalSeconds="1" transactionalMode="xa"> <terracotta clustered="true"/> </cache> </ehcache> 设置完全限定类名被注册为CacheManager事件监听器。 事件包括： /<em> adding a Cache增加一个缓存 /</em> removing a Cache移除一个缓存 设置元素是否持久化，如果持久化，将忽视超时并且元素永不过期。 回调监听器的方法有同步和异步两种。安全的处理潜在的麻烦和线程安全问题将是实施者的责任，这依取决于他们的监听器在干什么。 如果没有类指定，就不会创建监听器。这里没有默认值。 <cacheManagerEventListenerFactory class="" properties=""/> <!-- TerracottaConfig ======================== maxElementsOnDisk: 设置磁盘存储器维持的对象的最大数目。默认是0，意味着没有限制。 eternal: 激活Terracotta集群选项) 注意：你需要安装运行一个或多个Terracotta服务器来使用Terracotta集群。 参看http://www.terracotta.org/web/display/orgsite/Download 使用多个Terracotta服务器实例URLs（容错能力）的例子 <terracottaConfig url="host1:9510,host2:9510,host3:9510"/> maxElementsInMemory: 设置创建到存储器中的对象的最大数目。 在ehcache配置文件中嵌入一个Terracotta配置文件简单的放置一个普通的Terracotta XML配置到<terracottaConfig>元素中。 Example: <terracottaConfig> <tc-config> <servers> <server host="server1" name="s1"/> <server host="server2" name="s2"/> </servers> <clients> <logs>app/logs-%i</logs> </clients> </tc-config> </terracottaConfig> 更多的Terracotta信息，参看Terracotta文档。 --> <terracottaConfig url="localhost:9510"/> &lt;!-- Cache configuration =================== The following attributes are required. 如下属性都需要： name: 设置缓存的名称。用于鉴定缓存，他必须是唯一的。 指定一个TerracottaConfig用于为CacheManager配置Terracotta运行时。 配置文件可以通过两种主要方式指定：通过引用配置文件或者使用Terracotta嵌入式配置文件。 使用URL属性指定一个配置资源（或者多个）的引用。URL属性必须包含一个逗号隔开的列表： /<em> path（Terracotta配置文件的路径）(通常命名为 tc-config.xml) /</em> URL Terracotta配置文件的URL /* <server host>:<port> Terracotta服务器运行实例 最简单的例子指出这台机器上的一个Terracotta服务器： <terracottaConfig url="localhost:9510"/> 使用Terracotta配置文件路径的例子： <terracottaConfig url="/app/config/tc-config.xml"/> 使用Terracotta配置文件URL的例子： <terracottaConfig url="http://internal/ehcache/app/tc-config.xml"/>
分享到： <a href="&quot;分享到新浪微博&quot;"><img src="" alt=""></a> <a href="&quot;分享到腾讯微博&quot;"><img src="" alt=""></a></li>
</ol>
<p><a href="http://zuzong.iteye.com/blog/1048731" title="Spring 3.0.5 MVC 基于注解ehcache.xml 配置方式" target="_blank">Spring 3.0.5 MVC 基于注解ehcache.xml 配 ...</a> | <a href="http://zuzong.iteye.com/blog/941759" title="过滤掉非指定保留的html元素，保留元素间的内容和指定的html" target="_blank">过滤掉非指定保留的html元素，保留元素间的 ...</a></p>
<ul>
<li>2011-05-18 17:20</li>
<li>浏览 507</li>
<li><a href="http://zuzong.iteye.com/blog/1048714#comments" target="_blank">评论(0)</a></li>
<li>分类:<a href="http://www.iteye.com/blogs/category/architecture" target="_blank">企业架构</a></li>
<li><a href="http://www.iteye.com/wiki/blog/1048714" target="_blank">相关推荐</a></li>
</ul>
<h3 id="-">评论</h3>
<p><a href=""></a></p>
<h3 id="-">发表评论</h3>
<p><a href="http://zuzong.iteye.com/login" target="_blank"><img src="" alt=""></a><a href="http://zuzong.iteye.com/login" target="_blank">您还没有登录,请您登录后再发表评论</a></p>
<p><a href="http://zuzong.iteye.com/" target="_blank"><img src="&quot;zuzong的博客: 奈何桥收费站。。。&quot;" alt="zuzong的博客"></a></p>
<p>zuzong</p>
<ul>
<li>浏览: 24410 次</li>
<li>性别: <img src="&quot;男&quot;" alt="Icon_minigender_1"></li>
<li>来自: 济南</li>
<li><img src="" alt=""><h3 id="-http-zuzong-iteye-com-blog-user_visits-">最近访客 <a href="http://zuzong.iteye.com/blog/user_visits" target="_blank">更多访客&gt;&gt;</a></h3>
</li>
</ul>
<p><a href="http://136203489-qq-com.iteye.com/" target="_blank"><img src="&quot;小菜菜的博客: &quot;" alt="小菜菜的博客"></a></p>
<p><a href="http://136203489-qq-com.iteye.com/" title="小菜菜" target="_blank">小菜菜</a></p>
<p><a href="http://donald3003a.iteye.com/" target="_blank"><img src="&quot;donald3003a的博客: &quot;" alt="donald3003a的博客"></a></p>
<p><a href="http://donald3003a.iteye.com/" title="donald3003a" target="_blank">donald3003a</a>
<a href="http://umex.iteye.com/" target="_blank"><img src="&quot;china_ymex的博客: &quot;" alt="china_ymex的博客"></a></p>
<p><a href="http://umex.iteye.com/" title="china_ymex" target="_blank">china_ymex</a></p>
<p><a href="http://dylinshi126.iteye.com/" target="_blank"><img src="&quot;dylinshi126的博客: &quot;" alt="dylinshi126的博客"></a></p>
<p><a href="http://dylinshi126.iteye.com/" title="dylinshi126" target="_blank">dylinshi126</a></p>
<h3 id="-">文章分类</h3>
<ul>
<li><a href="http://zuzong.iteye.com/" target="_blank">全部博客 (52)</a></li>
<li><a href="http://zuzong.iteye.com/category/51241" target="_blank">java (22)</a></li>
<li><a href="http://zuzong.iteye.com/category/51242" target="_blank">UI (4)</a></li>
<li><a href="http://zuzong.iteye.com/category/52900" target="_blank">临时 (1)</a></li>
<li><a href="http://zuzong.iteye.com/category/157174" target="_blank">缓存 (2)</a></li>
<li><a href="http://zuzong.iteye.com/category/157184" target="_blank">Python (1)</a></li>
<li><a href="http://zuzong.iteye.com/category/157246" target="_blank">安全 (1)</a></li>
<li><a href="http://zuzong.iteye.com/category/157330" target="_blank">Perl (1)</a></li>
<li><a href="http://zuzong.iteye.com/category/157455" target="_blank">软件设计 (4)</a></li>
<li><a href="http://zuzong.iteye.com/category/159555" target="_blank">MySQL (2)</a></li>
<li><a href="http://zuzong.iteye.com/category/181752" target="_blank">Groovy on Grails (1)</a></li>
<li><a href="http://zuzong.iteye.com/category/182760" target="_blank">Linux (11)</a></li>
<li><p><a href="http://zuzong.iteye.com/category/183872" target="_blank">Eclipse (1)</a></p>
<h3 id="-">社区版块</h3>
</li>
<li><p><a href="http://zuzong.iteye.com/blog/news" target="_blank">我的资讯</a> (0)</p>
</li>
<li><a href="http://zuzong.iteye.com/blog/post" target="_blank">我的论坛</a> (30)</li>
<li><a href="http://zuzong.iteye.com/blog/answered_problems" target="_blank">我的问答</a> (1)</li>
</ul>
<h3 id="-">存档分类</h3>
<ul>
<li><a href="http://zuzong.iteye.com/blog/monthblog/2011-10" target="_blank">2011-10</a> (17)</li>
<li><a href="http://zuzong.iteye.com/blog/monthblog/2011-09" target="_blank">2011-09</a> (1)</li>
<li><a href="http://zuzong.iteye.com/blog/monthblog/2011-06" target="_blank">2011-06</a> (5)</li>
<li><p><a href="http://zuzong.iteye.com/blog/monthblog_more" target="_blank">更多存档...</a></p>
<h3 id="-">最新评论</h3>
</li>
<li><p><a href="http://yangbaodi516.iteye.com/" title="yangbaodi516" target="_blank">yangbaodi516</a>： XMLInputFactory2 xmlif = (XMLIn ...
<a href="http://zuzong.iteye.com/blog/1073358#bc2240488" target="_blank">基于Woodstox的StAX 2 解析XML</a></p>
</li>
<li><a href="http://ak53pro.iteye.com/" title="AK53pro" target="_blank">AK53pro</a>： SSL证书怎么伪造啊...有数字签名的啊...
<a href="http://zuzong.iteye.com/blog/1050164#bc2237084" target="_blank">SSL中间人攻击及防范</a></li>
<li><a href="http://lysino.iteye.com/" title="lysino" target="_blank">lysino</a>： 若把此问题交给oracle的sequence来解决岂不是很简单 ...
<a href="http://zuzong.iteye.com/blog/1174278#bc2218914" target="_blank">一个循环流水号实现，求评</a></li>
<li><a href="http://zuzong.iteye.com/" title="zuzong" target="_blank">zuzong</a>： 写的时候，考虑过用indexof查一次，删一次，后来写着写着就 ...
<a href="http://zuzong.iteye.com/blog/941759#bc1948620" target="_blank">过滤掉非指定保留的html元素，保留元素间的内容和指定的html</a></li>
<li><a href="http://zuzong.iteye.com/" title="zuzong" target="_blank">zuzong</a>： 我一开始用的stringbuffer，发现删除了那些不需要的h ...
<a href="http://zuzong.iteye.com/blog/941759#bc1948610" target="_blank">过滤掉非指定保留的html元素，保留元素间的内容和指定的html</a>
声明：ITeye文章版权属于作者，受法律保护。没有作者书面许可不得转载。若作者同意转载，必须以超链接形式标明文章原始出处和作者。
© 2003-2012 ITeye.com. All rights reserved. [ 京ICP证110151号 京公网安备110105010620 ]
<img src="" alt=""></li>
</ul>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/缓存/">缓存</a></li></span><span class="breadcrumb"><li><a href="/categories/缓存/">缓存</a></li><li><a href="/categories/缓存/ehcache/">ehcache</a></li></span></span> | <span class="tags">Tagged <a href="/tags/ehcache/" class="label label-primary">ehcache</a><a href="/tags/缓存/" class="label label-success">缓存</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:39"datetime="2014-03-07 09:54:39"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-缓存-ehcache--EhCache配置文件-奈何桥收费站。。。-ITeye技术网站/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-缓存-ehcache--EhCache配置文件-奈何桥收费站。。。-ITeye技术网站" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-缓存-ehcache--Ehcache配置文件加载方式-crazyinsomnia的空间-开源中国社区/">Ehcache配置文件加载方式 </a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:39.000Z"> <a href="/2014/02/02/2014-02-02-缓存-ehcache--Ehcache配置文件加载方式-crazyinsomnia的空间-开源中国社区/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="ehcache-crazyinsomnia-">Ehcache配置文件加载方式 - crazyinsomnia的空间 - 开源中国社区</h1>
<p><a href="http://www.oschina.net/" title="开源中国社区首页" target="_blank">开源中国社区</a></p>
<p>10月20日杭州OSC源创会 <a href="http://www.oschina.net/question/28_72721" target="_blank">正在报名</a> 中</p>
<ul>
<li><a href="http://www.oschina.net/project" target="_blank">软件</a></li>
<li><a href="http://www.oschina.net/question" target="_blank">讨论</a></li>
<li><a href="http://www.oschina.net/code/list" target="_blank">代码</a></li>
<li><a href="http://www.oschina.net/news" target="_blank">资讯</a></li>
<li><a href="http://www.oschina.net/blog" target="_blank">博客</a></li>
<li><a href="http://www.oschina.net/android" target="_blank">Android</a></li>
<li><a href="http://www.oschina.net/job" target="_blank">招聘</a></li>
</ul>
<p>当前访客身份： 游客 [ <a href="http://www.oschina.net/home/login?goto_page=http%3A%2F%2Fmy.oschina.net%2Fcrazyinsomnia" target="_blank">登录</a> | <a href="http://www.oschina.net/home/reg" target="_blank">加入开源中国</a> ]  <a href="http://www.oschina.net/home/login?goto_page=http%3A%2F%2Fmy.oschina.net%2Fcrazyinsomnia" title="进入我的留言箱" target="_blank">你有<em>0</em>新留言</a></p>
<p>软件 代码 讨论区 新闻 博客</p>
<p>软件</p>
<ul>
<li><a href="http://my.oschina.net/crazyinsomnia/blog/3552#1" target="_blank">软件</a></li>
<li><a href="http://my.oschina.net/crazyinsomnia/blog/3552#2" target="_blank">代码</a></li>
<li><a href="http://my.oschina.net/crazyinsomnia/blog/3552#3" target="_blank">讨论区</a></li>
<li><a href="http://my.oschina.net/crazyinsomnia/blog/3552#4" target="_blank">新闻</a></li>
<li><a href="http://my.oschina.net/crazyinsomnia/blog/3552#5" target="_blank">博客</a>
<a href="http://my.oschina.net/crazyinsomnia" target="_blank"><img src="&quot;crazyinsomnia&quot;" alt="crazyinsomnia"></a>  <a href="http://my.oschina.net/crazyinsomnia" title="男" target="_blank">crazyinsomnia</a>  <img src="&quot;男&quot;" alt=""> <a href="&quot;成为TA的粉丝&quot;">关注此人</a></li>
</ul>
<p><a href="http://my.oschina.net/crazyinsomnia/fellow" target="_blank">关注(10)</a> <a href="http://my.oschina.net/crazyinsomnia/fans" target="_blank">粉丝(16)</a> <a href="http://www.oschina.net/question/3307_20931" title="查看OSCHINA积分规则" target="_blank">积分(47)</a></p>
<p>青春是人生的实验课，错也错的很值得！！
<a href="">.发送留言</a> <a href="http://www.oschina.net/question/ask?user=30362" target="_blank">.请教问题</a></p>
<p><strong>博客分类</strong></p>
<ul>
<li><a href="http://my.oschina.net/crazyinsomnia/blog?catalog=62638" target="_blank">Spring</a>(1)</li>
<li><a href="http://my.oschina.net/crazyinsomnia/blog?catalog=29443" target="_blank">Freemarker</a>(1)</li>
<li><a href="http://my.oschina.net/crazyinsomnia/blog?catalog=22602" target="_blank">java</a>(12)</li>
<li><a href="http://my.oschina.net/crazyinsomnia/blog?catalog=22687" target="_blank">Jquery</a>(2)</li>
<li><a href="http://my.oschina.net/crazyinsomnia/blog?catalog=28068" target="_blank">Linux</a>(3)</li>
<li><a href="http://my.oschina.net/crazyinsomnia/blog?catalog=24660" target="_blank">Velocity</a>(1)</li>
<li><a href="http://my.oschina.net/crazyinsomnia/blog?catalog=27928" target="_blank">Hibernate</a>(1)</li>
<li><a href="http://my.oschina.net/crazyinsomnia/blog?catalog=27635" target="_blank">Struts2</a>(6)</li>
<li><a href="http://my.oschina.net/crazyinsomnia/blog?catalog=28479" target="_blank">Htmlparser</a>(1)</li>
<li><a href="http://my.oschina.net/crazyinsomnia/blog?catalog=25478" target="_blank">数据库</a>(2)</li>
<li><a href="http://my.oschina.net/crazyinsomnia/blog?catalog=24533" target="_blank">CSS+Html+Javascript</a>(5)</li>
<li><a href="http://my.oschina.net/crazyinsomnia/blog?catalog=13879" target="_blank">工作日志</a>(0)</li>
<li><a href="http://my.oschina.net/crazyinsomnia/blog?catalog=13880" target="_blank">日常记录</a>(3)</li>
<li><a href="http://my.oschina.net/crazyinsomnia/blog?catalog=13881" target="_blank">转贴的文章</a>(0)
<strong>阅读排行</strong></li>
</ul>
<ol>
<li><a href="http://my.oschina.net/crazyinsomnia/blog/3370" target="_blank">1. WebApplicationContext : org.springframework.web.context.ContextLoaderListener作用</a></li>
<li><a href="http://my.oschina.net/crazyinsomnia/blog/2231" target="_blank">2. hibernate学习笔记：hibernate中的Cache管理</a></li>
<li><a href="http://my.oschina.net/crazyinsomnia/blog/3490" target="_blank">3. Document.location.href和document.location.replace的区别</a></li>
<li><a href="http://my.oschina.net/crazyinsomnia/blog/12518" target="_blank">4. web.xml 中的listener、 filter、servlet 加载顺序及其详解</a></li>
<li><a href="http://my.oschina.net/crazyinsomnia/blog/2233" target="_blank">5. jquery的extend和fn.extend</a></li>
<li><a href="http://my.oschina.net/crazyinsomnia/blog/3400" target="_blank">6. Struts2中的ActionContext</a></li>
<li><a href="http://my.oschina.net/crazyinsomnia/blog/3848" target="_blank">7. Struts2执行流程【图】</a></li>
<li><a href="">8. Ehcache配置文件加载方式</a></li>
</ol>
<p><strong>最新评论</strong></p>
<ul>
<li><a href="http://my.oschina.net/u/242075" target="_blank">@lfsfxy9</a>：相同的内容，有必要重复一遍吗？！ <a href="http://my.oschina.net/action/tweet/go?obj=269119659&amp;type=18&amp;user=242075" target="_blank">查看»</a></li>
<li><a href="http://my.oschina.net/chengjiansunboy" target="_blank">@被风遗忘</a>：引用来自“senge”的评论 CacheManager manager... <a href="http://my.oschina.net/action/tweet/go?obj=268835524&amp;type=18&amp;user=221603" target="_blank">查看»</a></li>
<li><a href="http://my.oschina.net/senge" target="_blank">@senge</a>：CacheManager manager = new CacheManager(url);... <a href="http://my.oschina.net/action/tweet/go?obj=264235413&amp;type=18&amp;user=106591" target="_blank">查看»</a></li>
<li><a href="http://my.oschina.net/laddygaga" target="_blank">@哥不是传说</a>： <a href="http://my.oschina.net/action/tweet/go?obj=259653898&amp;type=18&amp;user=111291" target="_blank">查看»</a></li>
<li><a href="http://my.oschina.net/javayou" target="_blank">@红薯</a>：不需要 from dual 啦， select now();... <a href="http://my.oschina.net/action/tweet/go?obj=254022309&amp;type=18&amp;user=12" target="_blank">查看»</a></li>
<li><a href="http://my.oschina.net/crazyinsomnia" target="_blank">@crazyinsomnia</a>：嘻嘻，是啊！：） <a href="http://my.oschina.net/action/tweet/go?obj=254017055&amp;type=18&amp;user=30362" target="_blank">查看»</a></li>
<li><p><a href="http://my.oschina.net/javayou" target="_blank">@红薯</a>：通过URL加载，这个说法不太对哦 getClass().get... <a href="http://my.oschina.net/action/tweet/go?obj=254015753&amp;type=18&amp;user=12" target="_blank">查看»</a>
<strong>访客统计</strong></p>
</li>
<li><p>今日访问：21</p>
</li>
<li>昨日访问：22</li>
<li>本周访问：86</li>
<li>本月访问：175</li>
<li>所有访问：21437</li>
</ul>
<p><a href="http://my.oschina.net/crazyinsomnia" target="_blank">空间</a> » <a href="http://my.oschina.net/crazyinsomnia/blog" target="_blank">博客</a> » <a href="http://my.oschina.net/crazyinsomnia/blog?catalog=22602" target="_blank">java</a> » 博客正文</p>
<h1 id="-ehcache-"><img src="" alt=""> Ehcache配置文件加载方式</h1>
<p><em>0</em>人收藏此文章,  <a href="">我要收藏</a>   发表于2年前(2010-04-01 00:00) , 已有<strong>924</strong>次阅读 共<strong><a href="http://my.oschina.net/crazyinsomnia/blog/3552#comments" target="_blank">4</a></strong>个评论</p>
<p>会在classpath路径下找ehcache.xml配置文件</p>
<p>CacheManager manager = new CacheManager();   </p>
<p>也可以根据相对文件路径来加载配置文件</p>
<p>CacheManager manager = new CacheManager(“src/ehcache.xml”); .</p>
<p>通过相对与类路径的位置加载   </p>
<p>URL url = getClass().getResource(“/ehcache.xml”); </p>
<p>CacheManager manager = new CacheManager(url);</p>
<p>通过流加载</p>
<p>InputSream fis = new FileInputStream(new File(“src/config/ehcache.xml”).getAbsolutePath());
声明：OSCHINA 博客文章版权属于作者，受法律保护。未经作者同意不得转载。</p>
<ul>
<li><a href="http://my.oschina.net/crazyinsomnia/blog/3547" title="上一篇：Linux总结----VI文件编辑器" target="_blank">« Linux总结----VI文件编辑器</a></li>
<li><a href="http://my.oschina.net/crazyinsomnia/blog/3562" title="下一篇：MySQL获得系统时间" target="_blank">MySQL获得系统时间 »</a></li>
</ul>
<p>开源中国-程序员在线工具：<a href="http://www.osctools.net/apidocs" target="_blank">API文档大全(120+)</a> <a href="http://www.osctools.net/jsbin" target="_blank">JS在线编辑演示</a> <a href="http://www.osctools.net/qr" target="_blank">二维码</a> <a href="http://www.osctools.net/" target="_blank">更多&gt;&gt;</a>
<a href="&quot;分享到新浪微博&quot;"></a> <a href="&quot;分享到腾讯微博&quot;"></a> <a href="&quot;分享到开心网&quot;"></a> <a href="&quot;分享到人人网&quot;"></a> <a href="&quot;分享到豆瓣&quot;"></a> <a href="http://www.jiathis.com/share?uid=1567353"></a> <a href="">0</a>     <a href="">顶</a>已有 <em>0</em>人顶</p>
<h2 id="-4-"><a href=""></a>共有 4 条网友评论</h2>
<ul>
<li><a href="http://my.oschina.net/javayou" target="_blank"><img src="&quot;红薯&quot;" alt="红薯"></a> 1楼：<a href="http://my.oschina.net/javayou" target="_blank">红薯</a> 发表于 2010-04-01 07:39 <a href="">回复此评论</a></li>
</ul>
<p>通过URL加载，这个说法不太对哦 getClass().getResource(....) 主要是从类路径中加载</p>
<ul>
<li><a href="http://my.oschina.net/crazyinsomnia" target="_blank"><img src="&quot;crazyinsomnia&quot;" alt="crazyinsomnia"></a> 2楼：<a href="http://my.oschina.net/crazyinsomnia" target="_blank">crazyinsomnia</a> 发表于 2010-04-01 09:27 <a href="">回复此评论</a></li>
</ul>
<p>嘻嘻，是啊！：）</p>
<ul>
<li><a href="http://my.oschina.net/senge" target="_blank"><img src="&quot;senge&quot;" alt="senge"></a> 3楼：<a href="http://my.oschina.net/senge" target="_blank">senge</a> 发表于 2011-11-13 17:37 <a href="">回复此评论</a></li>
</ul>
<p>CacheManager manager = new CacheManager(url);
url 是WEB－INF　下面的配置文件　怎么加载不进来啊！</p>
<ul>
<li><a href="http://my.oschina.net/chengjiansunboy" target="_blank"><img src="&quot;被风遗忘&quot;" alt="被风遗忘"></a> 4楼：<a href="http://my.oschina.net/chengjiansunboy" target="_blank">被风遗忘</a> 发表于 2012-08-05 22:39 <a href="">回复此评论</a></li>
</ul>
<h3 id="-senge-">引用来自“senge”的评论</h3>
<p>CacheManager manager = new CacheManager(url);
url 是WEB－INF　下面的配置文件　怎么加载不进来啊！
应该是读取的位置不对的吧.</p>
<p>文明上网，理性发言
<a href=""></a></p>
<p><img src="" alt=""> 文明上网，理性发言  <a href="http://my.oschina.net/crazyinsomnia/blog/3552#" target="_blank">回到页首</a> | <a href="http://my.oschina.net/crazyinsomnia/blog/3552#comments" target="_blank">回到评论列表</a></p>
<p><strong><a href="">关闭</a>相关文章阅读</strong></p>
<ul>
<li>2012/07/29 <a href="http://my.oschina.net/u/615185/blog/69693" title="Nagios的配置文件" target="_blank">Nagios的配置文件</a></li>
<li>2012/06/04 <a href="http://my.oschina.net/chaoren8/blog/60918" title="读取properties格式的配置文件" target="_blank">读取properties格式的配置文件...</a></li>
<li>2012/01/29 <a href="http://my.oschina.net/superoscar/blog/39502" title="更新了VIM的配置-_vimc（2012年1月版）" target="_blank">更新了VIM的配置-_vimc（2012年1月版...</a></li>
<li>2012/08/14 <a href="http://my.oschina.net/u/617085/blog/72692" title="hadoop配置文件" target="_blank">hadoop配置文件</a></li>
<li>2012/06/04 <a href="http://my.oschina.net/bsnfei/blog/60900" title="编写调用配置文件" target="_blank">编写调用配置文件</a></li>
</ul>
<p>© 开源中国社区(OsChina.NET) | <a href="http://www.oschina.net/home/about" target="_blank">关于我们</a> | <a href="mailto:oschina.net@gmail.com">广告联系</a> | <a href="http://weibo.com/oschina2010" target="_blank">@新浪微博</a> | <a href="http://m.oschina.net/" target="_blank">开源中国手机版</a> | 粤ICP备12009483号-3</p>
<p><a href=""></a><a href=""></a><a href=""></a>
<img src="" alt=""></p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/缓存/">缓存</a></li></span><span class="breadcrumb"><li><a href="/categories/缓存/">缓存</a></li><li><a href="/categories/缓存/ehcache/">ehcache</a></li></span></span> | <span class="tags">Tagged <a href="/tags/ehcache/" class="label label-primary">ehcache</a><a href="/tags/缓存/" class="label label-success">缓存</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:39"datetime="2014-03-07 09:54:39"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-缓存-ehcache--Ehcache配置文件加载方式-crazyinsomnia的空间-开源中国社区/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-缓存-ehcache--Ehcache配置文件加载方式-crazyinsomnia的空间-开源中国社区" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-缓存-ehcache--EhCache小结--ITeye技术网站/">EhCache小结 </a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:39.000Z"> <a href="/2014/02/02/2014-02-02-缓存-ehcache--EhCache小结--ITeye技术网站/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="ehcache-iteye-">EhCache小结 - - ITeye技术网站</h1>
<p><a href="http://www.iteye.com/" target="_blank">首页</a> <a href="http://www.iteye.com/news" target="_blank">资讯</a> <a href="http://www.iteye.com/magazines" target="_blank">精华</a> <a href="http://www.iteye.com/forums" target="_blank">论坛</a> <a href="http://www.iteye.com/ask" target="_blank">问答</a> <a href="http://www.iteye.com/blogs" target="_blank">博客</a> <a href="http://www.iteye.com/blogs/subjects" target="_blank">专栏</a> <a href="http://www.iteye.com/groups" target="_blank">群组</a> <a href="http://nanguocoffee.iteye.com/blog/356324#" target="_blank">更多 ▼</a></p>
<p><a href="http://www.iteye.com/job" target="_blank">招聘</a> <a href="http://www.iteye.com/search" target="_blank">搜索</a></p>
<p><a href="http://nanguocoffee.iteye.com/login" title="登录" target="_blank">您还未登录 !</a> <a href="http://nanguocoffee.iteye.com/login" target="_blank">登录</a> <a href="http://nanguocoffee.iteye.com/signup" target="_blank">注册</a></p>
<h1 id="-nanguocoffee-http-nanguocoffee-iteye-com-"><a href="http://nanguocoffee.iteye.com/" target="_blank">nanguocoffee</a></h1>
<ul>
<li><a href="http://nanguocoffee.iteye.com/" target="_blank"><strong>博客</strong></a></li>
<li><a href="http://nanguocoffee.iteye.com/weibo" target="_blank">微博</a></li>
<li><a href="http://nanguocoffee.iteye.com/album" target="_blank">相册</a></li>
<li><a href="http://nanguocoffee.iteye.com/link" target="_blank">收藏</a></li>
<li><a href="http://nanguocoffee.iteye.com/blog/guest_book" target="_blank">留言</a></li>
<li><a href="http://nanguocoffee.iteye.com/blog/profile" target="_blank">关于我</a></li>
</ul>
<h3 id="-ehcache-"><a href="">EhCache小结</a> **</h3>
<p><strong>博客分类：</strong></p>
<ul>
<li><a href="http://nanguocoffee.iteye.com/category/60003" target="_blank">缓存</a>
<a href="http://www.iteye.com/blogs/tag/Cache" target="_blank">Cache</a><a href="http://www.iteye.com/blogs/tag/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84" target="_blank">数据结构</a><a href="http://www.iteye.com/blogs/tag/%E7%AE%97%E6%B3%95" target="_blank">算法</a><a href="http://www.iteye.com/blogs/tag/%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86" target="_blank">配置管理</a><a href="http://www.iteye.com/blogs/tag/Hibernate" target="_blank">Hibernate</a> </li>
</ul>
<p>一：接口和类的作用：
Elemenet：
key
value
lastAccessTime
hitCount
等描述cache中元素的信息。
Store: 实际上存放Element的对象，Cache针对对象的操作一般都委托Store对象。</p>
<ul>
<li>MemoryStore： 继承该类来实现自定义MemoryStore。该类存放数据时，先使用Map存放数据，然后再判断是否超出容量。
put()
doPut() // 用来清理元素
-LruMemoryStore.java  使用 LinkedHashMap的子类，doput（）为空，因为该map的实现中的removeEldestEntry方法清理了超出容量的元素。
-LfuMemoryStore.java  使用HashMap
-FifoMemoryStore.java 使用LinkedHashMap  这里用队列应该更快吧？？源码中还需要遍历map。
-DiskStore：
其实diskStore也是用一个hashmap来存放数据，只有显式的调用flush（）方法的时候才判断是否要将元素写入文件中。
CacheManager 来管理 Cache ；
Cache用来操作Element，Cache是抽象出来的逻辑概念，其 内部使用Store来处理Element
Element就是数据描述缓存对象的基本信息。
Store是保管缓存对象的仓库，这个仓库分Memory和Disk两种。
EHCache中的EventListener是针对分布式的，普通的应用可以不用考虑。
二：一些功能细节：
1：超出设定的元素容量的解决方法
MemoryStore：
When an element is added to a cache and it goes beyond its maximum memory size,
an existing element is either deleted, if overflowToDisk is false, or evaluated for spooling to disk,
if overflowToDisk is true. In the latter case, a check for expiry is carried out. If it is expired it is deleted; if not it is spooled.
判断元素是否过期，MemoryStore有3种策略可选，LRU，LFU，FIFO，默认为LRU。
DiskStore：
使用LFU，DiskStore使用一个守护线程，DiskStore.SpoolAndExpiryThread内部类来定时检查diskStore中的元素，
定时刷新到文件中，如果遇到过期的元素则移除。
2：元素存活时间到期
MemoryStore：
在get（）和超出容量的时候才判断是否过期
DiskStore：
只有在flush的时候才判断是否过期，如果过期则移除。
也就是说，这两种方式，不论在文件或者内存中，都会依然存在过期的元素，
这些元算可能永远存在，但不影响我们的操作，因为我们get（）或者超出容量的时候都会判断是否过期并清除。
三：初始化
CacheManager cacheManager = new CacheManager();
调用protected void init(Configuration configuration, String configurationFileName, URL configurationURL,   InputStream configurationInputStream) 方法进行初始化。
1：解析配置信息：
1.1 查找ehcache.xml文件，如果找不到则使用默认的ehcache-failsafe.xml，返回一个URL对象。
1.2 调用ConfigurationFactory.parseConfiguration(input) 方法来进行解析。返回Configuration对象。
Configuration的数据结构：
  private DiskStoreConfiguration diskStoreConfiguration;
  private CacheConfiguration defaultCacheConfiguration;
  private List<FactoryConfiguration> cacheManagerPeerProviderFactoryConfiguration = new ArrayList<FactoryConfiguration>();
  private List<FactoryConfiguration> cacheManagerPeerListenerFactoryConfiguration = new ArrayList<FactoryConfiguration>();
  private FactoryConfiguration cacheManagerEventListenerFactoryConfiguration;
  private final Map cacheConfigurations = new HashMap();
  private String configurationSource;
该数据结构是针对xml定义来的，其中最复杂也最常用的算是CacheConfiguration，其内部结构也很简单。
cacheConfigurations存放多个CacheConfiguration。
2：根据Configuration进行CacheManager，Cache，Store等数据结构的初始化。
总结：
EHCache是一款比较简单的开源缓存产品，但也存在一些不足之处：
比如：
1：CacheManager和Cache这个具体类耦合，当然也提供了针对EHCache接口的方法，如果使用自定义的Cache的话容易混淆方法。
2：针对不同的Cache类，我们希望指定不同的MemoryStore实现、DiskStore实现，EHCache只提供了通过程序来达到这一功能，
没有提供通过配置文件来提供(类似于Hibernate配置文件中CacheProvider，JDBC  dialect 等)。
3：有些算法实现得不算好，比如FifoMemoryStore.java中的清理元素算法选择的数据结构不够快速。
分享到： <a href="&quot;分享到新浪微博&quot;"><img src="" alt=""></a> <a href="&quot;分享到腾讯微博&quot;"><img src="" alt=""></a></li>
</ul>
<p><a href="http://nanguocoffee.iteye.com/blog/467199" title="JForum源码学习研究1-起步" target="_blank">JForum源码学习研究1-起步</a> | <a href="http://nanguocoffee.iteye.com/blog/356322" title="EhCache入门" target="_blank">EhCache入门</a></p>
<ul>
<li>2009-03-27 18:34</li>
<li>浏览 1010</li>
<li><a href="http://nanguocoffee.iteye.com/blog/356324#comments" target="_blank">评论(0)</a></li>
<li><a href="http://www.iteye.com/wiki/blog/356324" target="_blank">相关推荐</a></li>
</ul>
<h3 id="-">评论</h3>
<p><a href=""></a></p>
<h3 id="-">发表评论</h3>
<p><a href="http://nanguocoffee.iteye.com/login" target="_blank"><img src="" alt=""></a><a href="http://nanguocoffee.iteye.com/login" target="_blank">您还没有登录,请您登录后再发表评论</a></p>
<p><a href="http://nanguocoffee.iteye.com/" target="_blank"><img src="&quot;NanguoCoffee的博客: &quot;" alt="NanguoCoffee的博客"></a></p>
<p>NanguoCoffee</p>
<ul>
<li>浏览: 10206 次</li>
<li>性别: <img src="&quot;男&quot;" alt="Icon_minigender_1"></li>
<li>来自: 北京</li>
<li><img src="" alt=""><h3 id="-http-nanguocoffee-iteye-com-blog-user_visits-">最近访客 <a href="http://nanguocoffee.iteye.com/blog/user_visits" target="_blank">更多访客&gt;&gt;</a></h3>
</li>
</ul>
<p><a href="http://bingki.iteye.com/" target="_blank"><img src="&quot;bingki的博客: 我的IT生活...&quot;" alt="bingki的博客"></a></p>
<p><a href="http://bingki.iteye.com/" title="bingki" target="_blank">bingki</a></p>
<p><a href="http://turandot.iteye.com/" target="_blank"><img src="&quot;Turandot的博客: &quot;" alt="Turandot的博客"></a></p>
<p><a href="http://turandot.iteye.com/" title="Turandot" target="_blank">Turandot</a>
<a href="http://dylinshi126.iteye.com/" target="_blank"><img src="&quot;dylinshi126的博客: &quot;" alt="dylinshi126的博客"></a></p>
<p><a href="http://dylinshi126.iteye.com/" title="dylinshi126" target="_blank">dylinshi126</a></p>
<p><a href="http://luwies.iteye.com/" target="_blank"><img src="&quot;luwies的博客: &quot;" alt="luwies的博客"></a></p>
<p><a href="http://luwies.iteye.com/" title="luwies" target="_blank">luwies</a></p>
<h3 id="-">文章分类</h3>
<ul>
<li><a href="http://nanguocoffee.iteye.com/" target="_blank">全部博客 (23)</a></li>
<li><a href="http://nanguocoffee.iteye.com/category/60003" target="_blank">缓存 (2)</a></li>
<li><a href="http://nanguocoffee.iteye.com/category/79080" target="_blank">JForum (3)</a></li>
<li><a href="http://nanguocoffee.iteye.com/category/121602" target="_blank">Java IO (3)</a></li>
<li><a href="http://nanguocoffee.iteye.com/category/121603" target="_blank">其他 (7)</a></li>
<li><a href="http://nanguocoffee.iteye.com/category/121996" target="_blank">Java 多线程 (1)</a></li>
<li><a href="http://nanguocoffee.iteye.com/category/132461" target="_blank">性能优化 (1)</a></li>
<li><a href="http://nanguocoffee.iteye.com/category/132820" target="_blank">Oracle (1)</a></li>
<li><p><a href="http://nanguocoffee.iteye.com/category/137742" target="_blank">编码相关 (6)</a></p>
<h3 id="-">社区版块</h3>
</li>
<li><p><a href="http://nanguocoffee.iteye.com/blog/news" target="_blank">我的资讯</a> (0)</p>
</li>
<li><a href="http://nanguocoffee.iteye.com/blog/post" target="_blank">我的论坛</a> (118)</li>
<li><a href="http://nanguocoffee.iteye.com/blog/answered_problems" target="_blank">我的问答</a> (18)</li>
</ul>
<h3 id="-">存档分类</h3>
<ul>
<li><a href="http://nanguocoffee.iteye.com/blog/monthblog/2011-02" target="_blank">2011-02</a> (1)</li>
<li><a href="http://nanguocoffee.iteye.com/blog/monthblog/2011-01" target="_blank">2011-01</a> (1)</li>
<li><a href="http://nanguocoffee.iteye.com/blog/monthblog/2010-12" target="_blank">2010-12</a> (6)</li>
<li><p><a href="http://nanguocoffee.iteye.com/blog/monthblog_more" target="_blank">更多存档...</a></p>
<h3 id="-">最新评论</h3>
</li>
<li><p><a href="http://nanguocoffee.iteye.com/" title="NanguoCoffee" target="_blank">NanguoCoffee</a>： javantsky 写道楼主为什么要自己实现分离锁呢？ jav ...
<a href="http://nanguocoffee.iteye.com/blog/907824#bc1905975" target="_blank">知道为啥HashMap里面的数组size必须是2的次幂？</a></p>
</li>
<li><a href="http://javantsky.iteye.com/" title="javantsky" target="_blank">javantsky</a>： 楼主为什么要自己实现分离锁呢？java.util.concur ...
<a href="http://nanguocoffee.iteye.com/blog/907824#bc1905933" target="_blank">知道为啥HashMap里面的数组size必须是2的次幂？</a></li>
<li><a href="http://obullxl.iteye.com/" title="obullxl" target="_blank">obullxl</a>： LZ分析有道理，最后的&amp;操作，（LOCK_NUM - ...
<a href="http://nanguocoffee.iteye.com/blog/907824#bc1905828" target="_blank">知道为啥HashMap里面的数组size必须是2的次幂？</a></li>
<li><a href="http://nanguocoffee.iteye.com/" title="NanguoCoffee" target="_blank">NanguoCoffee</a>： sniffer123 写道LZ你自己的写法有问题啊。。跟HAS ...
<a href="http://nanguocoffee.iteye.com/blog/907824#bc1905087" target="_blank">知道为啥HashMap里面的数组size必须是2的次幂？</a></li>
<li><a href="http://sniffer123.iteye.com/" title="sniffer123" target="_blank">sniffer123</a>： LZ你自己的写法有问题啊。。跟HASH是不是 2的幂一点关系也 ...
<a href="http://nanguocoffee.iteye.com/blog/907824#bc1905063" target="_blank">知道为啥HashMap里面的数组size必须是2的次幂？</a>
声明：ITeye文章版权属于作者，受法律保护。没有作者书面许可不得转载。若作者同意转载，必须以超链接形式标明文章原始出处和作者。
© 2003-2012 ITeye.com. All rights reserved. [ 京ICP证110151号 京公网安备110105010620 ]
<img src="" alt=""></li>
</ul>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/缓存/">缓存</a></li></span><span class="breadcrumb"><li><a href="/categories/缓存/">缓存</a></li><li><a href="/categories/缓存/ehcache/">ehcache</a></li></span></span> | <span class="tags">Tagged <a href="/tags/ehcache/" class="label label-primary">ehcache</a><a href="/tags/缓存/" class="label label-success">缓存</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:39"datetime="2014-03-07 09:54:39"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-缓存-ehcache--EhCache小结--ITeye技术网站/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-缓存-ehcache--EhCache小结--ITeye技术网站" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>





<ul id="pagination" class="pagination pagination-lg">
  <li><a class="extend prev" href="/page/79/">&laquo;</a></li><li><a class="page-number" href="/">1</a></li><li><a class="page-number" href="/page/2/">2</a></li><li><span class="space">&hellip;</span></li><li><a class="page-number" href="/page/77/">77</a></li><li><a class="page-number" href="/page/78/">78</a></li><li><a class="page-number" href="/page/79/">79</a></li><li class="active"><li><span class="page-number current">80</span></li><li><a class="page-number" href="/page/81/">81</a></li><li><a class="page-number" href="/page/82/">82</a></li><li><a class="page-number" href="/page/83/">83</a></li><li><span class="space">&hellip;</span></li></li><li><a class="page-number" href="/page/164/">164</a></li><li><a class="page-number" href="/page/165/">165</a></li><li><a class="extend next" href="/page/81/">&raquo;</a></li>
  <div class="clearfix"></div>
</ul></div><!--wapper-->
       </div><!-- ID main-col END -->
       <aside id="sidebar" class="alignright col-sx-6 col-sm-4 col-md-3 col-lg-3">
<div id="widget_search" class="widget panel panel-primary">
    <form action="//google.com/search" method="get" accept-charset="utf-8">
  <div class="input-group">
    <input class="form-control" id="searchbox" type="search" name="q" results="0" placeholder="search">
    <span class="input-group-btn">
      <button class="btn btn-default" type="submit">Go!</button>
    </span>
    <input type="hidden" name="q" value="site:itsolife.com">
  </div>
</form>
</div>

<div id="widget_category" class="widget panel panel-primary">
  <div class="panel-heading">category</div>  <div data-src='category' class='ajax_widgets'>正在加载...</div>
</div>

<div id="widget_recent_posts" class="widget panel panel-primary">
  <div class="panel-heading">recent posts</div>  <div data-src='recent_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_tagcloud" class="widget panel panel-primary">
  <div class="panel-heading">tagcloud</div>  <div data-src='tagcloud' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_latest_update_posts" class="widget panel panel-primary">
  <div class="panel-heading">最近更新</div>  <div data-src='latest_update_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_recent_comments" class="widget panel panel-primary">
  <div class="panel-heading">recent comments</div>  

<div class="list-group-item ds-recent-comments" data-num-items="6" data-show-avatars="1" data-show-time="1" data-show-title="1" data-show-admin="1" data-excerpt-length="50"></div>



</div>

</aside>
       <div class="clearfix"></div>
     </div><!-- row END -->
  </div>
  <footer id="footer" class="container">
  <div class="panel panel-info">
  <section id='footer_widget'></section>  <div class="panel-footer">
  <div id="site-info">
    <span class='author'>
  
  &copy; 2014 RobinChia
  
    &nbsp;&nbsp;</span>
  
  <span id='analytics-51la'></span><span id='analytics-google'>
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-48559895-1']);
  _gaq.push(['_trackPageview']);
  _js2load.push({src:('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'});
</script></span><span id='analytics-cnzz'>
<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_5774006'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s17.cnzz.com/stat.php%3Fid%3D5774006%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>
</span><span id='analytics-baidu'>
<script>
var _hmt = _hmt || [];
_js2load.push({src:"//hm.baidu.com/hm.js?1442f50724afc42380b51f097c43082c"});
</script>
</span>  </div>
  <div id="copyright">Blog powered by <a href='http://zespia.tw/hexo/'><strong>hexo</strong></a> Theme <strong><a href='https://github.com/chenall/hexo-theme-chenall'>chenall</a></strong>(Some change in it)<span class="pull-right"> 更新时间: <em>2014-03-15 20:45:44</em></span></div>
</div>
<div class="clearfix"></div>


  </div>
  </footer>
  
        <script src="http://cdn.bootcss.com/jquery/1.10.2/jquery.min.js"></script>        
        <script src="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/js/bootstrap.min.js"></script>        
                
        <script src="http://cdn.bootcss.com/prettify/r298/prettify.min.js"></script>    <script type="text/javascript">
   var lang=["bsh", "c", "cc", "cpp", "cs", "csh", "cyc", "cv", "htm", "html",
    "java", "js", "m", "mxml", "perl", "pl", "pm", "py", "rb", "sh",
    "xhtml", "xml", "xsl"];
   var pretty_base='';
   $('script').each(function(){
	var c = $(this).attr('src');
	if (!c)
	    return;
	if (c.match(/(\/)?prettify(\.min)?\.js/i))
	{
	    var index = c.lastIndexOf('/');
	    if (index != -1)
		pretty_base = c.substr(0,index + 1);
	    return false;
	}
   })
   $('pre code').each(function(){
	var c = $(this).attr('class')
	if (!c)
	    return;
	c = c.match(/\s?(lang\-\w+)/i);
	if (c && lang.indexOf(c[1]) == -1)
	{
	    lang.push(c[1]);
	    $.getScript(pretty_base + c[1] + '.min.js');
	}
   })

    $(window).load(function(){
       $("pre").addClass("prettyprint");
       prettyPrint();
    })
</script>    
            <script type="text/javascript">
var duoshuoQuery = {short_name:"robinchia"};
_js2load.push({src:'http://static.duoshuo.com/embed.js',charset:'UTF-8'});
</script>
    
            <!--wumii_relatedItems-->
    
        <script src="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js"></script>    <script type="text/javascript">
(function($){
  $('.entry').each(function(i){
    $(this).find('img').each(function(){
      var alt = this.alt;

      if (alt){
        $(this).before('<span class="caption">' + alt + '</span>');
      }

      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox" rel="fancybox' + i + '" />');
    });
  });

  $('.fancybox').fancybox();
})(jQuery);
</script>    
        <script src="http://cdn.bootcss.com/mathjax/2.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>    <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>
    
<script type="text/javascript">
$('.ajax_widgets').each(function(){var src=$(this).attr('data-src');if(src)$(this).load('/widgets/'+src+'.html');});
$.each(_js2load,function(index,obj){loadjs(obj.src,obj.charset)});
</script>

<div id="scroll2top">
<img src="/scroll2top/arrow.png"/>
</div>
<script src="/scroll2top/scroll2top.min.js"></script>
<div id="winterland">
  <canvas></canvas>
</div>
<script src="/js/winterland.min.js"></script>

  </body>
</html>
