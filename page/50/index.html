
<!DOCTYPE HTML>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>The 50 Page | It so life</title>
<meta name="author" content="RobinChia">

<meta name="description" content="It so life">


<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<meta property="og:site_name" content="It so life"/>

<!--[if IE]><style>.testIE.IE{display:inline;}</style><![endif]-->
<!--[if lte IE 7]><link rel="stylesheet" href="/css/ie7.css" type="text/css"><![endif]-->
<!--[if (lt IE 9)&(gt IE 7)]><style>.testIE.IE8{display:inline;}</style><![endif]-->
<!--[if gt IE 8]><style>.testIE.IE9{display:inline;}</style><![endif]-->

<link href="/favicon.png" rel="icon">
<link rel="alternate" href="/atom.xml" title="It so life Feed" type="application/atom+xml">

<link rel="stylesheet" href="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/css/bootstrap.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/font-awesome/4.0.3/css/font-awesome.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/prettify/r298/prettify.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" type="text/css">
<link rel="stylesheet" href="/css/style.css" type="text/css">
<!--[if lt IE 9]>
   <style>article,aside,dialog,footer,header,section,footer,nav,figure,menu{display:block}</style>
   <script src="http://cdn.staticfile.org/html5shiv/r29/html5.min.js"></script>
   <script src="http://cdn.staticfile.org/respond.js/1.4.2/respond.min.js"></script>
<link href="http://cdn.staticfile.org/respond.js/1.4.2/respond-proxy.html" id="respond-proxy" rel="respond-proxy" />
<link href="/js/respond.proxy.gif" id="respond-redirect" rel="respond-redirect" />
<script src="/js/respond.proxy.js"></script>
   <script src="http://cdn.bootcss.com/selectivizr/1.0.2/selectivizr-min.js"></script>
<![endif]-->
<script type="text/javascript">
function loadjs(c,d){var a=document.createElement("script");a.async=!0;a.type="text/javascript";a.src=c;a.charset=d||"gbk";(document.getElementsByTagName("HEAD")[0]||document.getElementsByTagName("BODY")[0]).appendChild(a)};
var _protocol = (("https:" == document.location.protocol) ? " https://" : " http://");
var _js2load = [];
</script>

</head>
<body>
      <header id="header" class="container"><nav id="main-nav" class="navbar navbar-default navbar-fixed-top " role="navigation">
  <div class="container">
    <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
      <span class="sr-only">Toggle navigation</span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="/">It so life</a>
    </div>
    <div  class="collapse navbar-collapse">
      <ul  class="nav navbar-nav">
  
        <li><a href="/" title="Home">Home</a></li>      
        <li><a href="/about/" title="About">About</a></li>      
        <li><a href="/archives/" title="Archives">Archives</a></li>      
      <li class='dropdown'>
        <a class='dropdown-toggle' data-toggle='dropdown' href='#'>website<b class='caret'></b></a>
        <ul class='dropdown-menu pure-menu-selected'>
    
          <li><a href="//groups.google.com/forum/#!forum/pongba" title="TopLanguage">TopLanguage</a></li>    
          <li><a href="//itpub.net/" title="ITPub">ITPub</a></li>    
          <li><a href="//blog.jobbole.com/" title="Bole">Bole</a></li>    
          <li><a href="//nosql-database.org/" title="nosql">nosql</a></li>    
          <li><a href="//gitimmersion.googol.im/" title="Git">Git</a></li>    
        </ul>
      </li>
    
      </ul>
      <ul class="nav navbar-nav navbar-right">
      
        <li><a href="/atom.xml">RSS</a></li>
      
      
        <li><a href="https://twitter.com/robinchia">twitter</a></li>
      
      
      
      
        <li><a href="https://github.com/robinchia">github</a></li>
      
      </ul>
    </div>
  </div>
</nav>
<div class="clearfix"></div>
</header>
  <div id='content' class="container">
     <div class="page-header-wrapper">
      <!--[if lt IE 9]><div class="alert alert-warning alert-dismissable"><button type="button" class="close" data-dismiss="alert" aria-hidden="true">&times;</button><strong>提示:</strong>您的浏览器版本太低了,建议升级到 <strong><a href="http://windows.microsoft.com/zh-cn/internet-explorer/download-ie" title="IE9">IE9</a></strong> 以上,本站使用<a href="https://www.google.com/intl/zh-CN/chrome/">Chrome浏览器</a>可以获得最好的显示效果.</div><![endif]-->
      <div class="page-header"><h1 align="center"><big>It so life</big> </h1>
        <h5 align="center"><big>love as life</big></h5>
      </div>
     </div>
     <div class="row">
       <div id="main-col" class="alignleft col-sx-12 col-sm-8 col-md-9 col-lg-9">
      <section id='header_widget'></section>
          <div id="wrapper"><article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--JVM调优总结（十）-调优方法/">JVM调优总结（十）</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:42.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--JVM调优总结（十）-调优方法/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="jvm-">JVM调优总结（十）-调优方法</h1>
<h2 id="jvm-">JVM调优工具</h2>
<p><strong>Jconsole，jProfile，VisualVM</strong></p>
<hr>
<p><strong>Jconsole :</strong> jdk自带，功能简单，但是可以在系统有一定负荷的情况下使用。对垃圾回收算法有很详细的跟踪。详细说明参考<a href="http://pengjiaheng.spaces.live.com/blog/cns!2DAA368B386E6AEA!687.entry" target="_blank">这里</a></p>
<p><strong>JProfiler</strong>：商业软件，需要付费。功能强大。详细说明参考<a href="http://pengjiaheng.spaces.live.com/blog/cns!2DAA368B386E6AEA!685.entry" target="_blank">这里</a></p>
<p><strong>VisualVM</strong>：JDK自带，功能强大，与JProfiler类似。推荐。</p>
<h2 id="-">如何调优</h2>
<p>观察内存释放情况、集合类检查、对象树</p>
<p>上面这些调优工具都提供了强大的功能，但是总的来说一般分为以下几类功能</p>
<p><strong>堆信息查看</strong></p>
<p><a href=""></a></p>
<p><img src="" alt=""> 
可查看堆空间大小分配（年轻代、年老代、持久代分配）</p>
<p>提供即时的垃圾回收功能</p>
<p>垃圾监控（长时间监控回收情况）</p>
<p><a href=""></a></p>
<p><img src="" alt=""> 
查看堆内类、对象信息查看：数量、类型等</p>
<p><a href=""></a></p>
<p><img src="" alt=""> 
对象引用情况查看</p>
<p>有了堆信息查看方面的功能，我们一般可以顺利解决以下问题：</p>
<p>  --年老代年轻代大小划分是否合理</p>
<p>  --内存泄漏</p>
<p>  --垃圾回收算法设置是否合理</p>
<h2 id="-">线程监控</h2>
<p><a href=""></a></p>
<p><img src="" alt=""> 
线程信息监控：系统线程数量。</p>
<p>线程状态监控：各个线程都处在什么样的状态下</p>
<p><a href=""></a></p>
<p><img src="" alt=""> 
Dump线程详细信息：查看线程内部运行情况</p>
<p>死锁检查</p>
<p><strong>热点分析</strong></p>
<p><a href=""></a></p>
<p><img src="" alt=""> </p>
<p><strong>    CPU热点</strong>：检查系统哪些方法占用的大量CPU时间</p>
<p><strong>    内存热点</strong>：检查哪些对象在系统中数量最大（一定时间内存活对象和销毁对象一起统计）</p>
<pre><code>这两个东西对于系统优化很有帮助。我们可以根据找到的热点，有针对性的进行系统的瓶颈查找和进行系统优化，而不是漫无目的的进行所有代码的优化。
</code></pre><p><strong>快照</strong></p>
<pre><code>快照是系统运行到某一时刻的一个定格。在我们进行调优的时候，不可能用眼睛去跟踪所有系统变化，依赖快照功能，我们就可以进行系统两个不同运行时刻，对象（或类、线程等）的不同，以便快速找到问题

举例说，我要检查系统进行垃圾回收以后，是否还有该收回的对象被遗漏下来的了。那么，我可以在进行垃圾回收前后，分别进行一次堆情况的快照，然后对比两次快照的对象情况。
</code></pre><h2 id="-">内存泄漏检查</h2>
<pre><code>内存泄漏是比较常见的问题，而且解决方法也比较通用，这里可以重点说一下，而线程、热点方面的问题则是具体问题具体分析了。

内存泄漏一般可以理解为系统资源（各方面的资源，堆、栈、线程等）在错误使用的情况下，导致使用完毕的资源无法回收（或没有回收），从而导致新的资源分配请求无法完成，引起系统错误。

内存泄漏对系统危害比较大，因为他可以直接导致系统的崩溃。

需要区别一下，内存泄漏和系统超负荷两者是有区别的，虽然可能导致的最终结果是一样的。内存泄漏是用完的资源没有回收引起错误，而系统超负荷则是系统确实没有那么多资源可以分配了（其他的资源都在使用）。
</code></pre><p><strong>年老代堆空间被占满</strong></p>
<p><strong>异常：</strong> java.lang.OutOfMemoryError: Java heap space</p>
<p><strong>说明：</strong></p>
<p><a href=""></a></p>
<p><img src="" alt=""></p>
<pre><code>这是最典型的内存泄漏方式，简单说就是所有堆空间都被无法回收的垃圾对象占满，虚拟机无法再在分配新空间。

如上图所示，这是非常典型的内存泄漏的垃圾回收情况图。所有峰值部分都是一次垃圾回收点，所有谷底部分表示是一次垃圾回收后剩余的内存。连接所有谷底的点，可以发现一条由底到高的线，这说明，随时间的推移，系统的堆空间被不断占满，最终会占满整个堆空间。因此可以初步认为系统内部可能有内存泄漏。（上面的图仅供示例，在实际情况下收集数据的时间需要更长，比如几个小时或者几天）
</code></pre><p><strong>解决：</strong></p>
<pre><code>这种方式解决起来也比较容易，一般就是根据垃圾回收前后情况对比，同时根据对象引用情况（常见的集合对象引用）分析，基本都可以找到泄漏点。
</code></pre><p><strong>持久代被占满</strong></p>
<p><strong>异常：</strong>java.lang.OutOfMemoryError: PermGen space</p>
<p><strong>说明：</strong></p>
<pre><code>Perm空间被占满。无法为新的class分配存储空间而引发的异常。这个异常以前是没有的，但是在Java反射大量使用的今天这个异常比较常见了。主要原因就是大量动态反射生成的类不断被加载，最终导致Perm区被占满。

更可怕的是，不同的classLoader即便使用了相同的类，但是都会对其进行加载，相当于同一个东西，如果有N个classLoader那么他将会被加载N次。因此，某些情况下，这个问题基本视为无解。当然，存在大量classLoader和大量反射类的情况其实也不多。
</code></pre><p><strong>解决：</strong></p>
<pre><code>1. -XX:MaxPermSize=16m

2. 换用JDK。比如JRocket。
</code></pre><p><strong>堆栈溢出</strong></p>
<p><strong>异常：</strong>java.lang.StackOverflowError</p>
<p><strong>说明：</strong>这个就不多说了，一般就是递归没返回，或者循环调用造成</p>
<p><strong>线程堆栈满</strong></p>
<p><strong>异常</strong>：Fatal: Stack size too small</p>
<p><strong>说明</strong>：java中一个线程的空间大小是有限制的。JDK5.0以后这个值是1M。与这个线程相关的数据将会保存在其中。但是当线程空间满了以后，将会出现上面异常。</p>
<p><strong>解决</strong>：增加线程栈大小。-Xss2m。但这个配置无法解决根本问题，还要看代码部分是否有造成泄漏的部分。</p>
<p><strong>系统内存被占满</strong></p>
<p><strong>异常</strong>：java.lang.OutOfMemoryError: unable to create new native thread</p>
<p><strong>说明</strong>：</p>
<pre><code>这个异常是由于操作系统没有足够的资源来产生这个线程造成的。系统创建线程时，除了要在Java堆中分配内存外，操作系统本身也需要分配资源来创建线程。因此，当线程数量大到一定程度以后，堆中或许还有空间，但是操作系统分配不出资源来了，就出现这个异常了。
</code></pre><p>分配给Java虚拟机的内存愈多，系统剩余的资源就越少，因此，当系统内存固定时，分配给Java虚拟机的内存越多，那么，系统总共能够产生的线程也就越少，两者成反比的关系。同时，可以通过修改-Xss来减少分配给单个线程的空间，也可以增加系统总共内生产的线程数。</p>
<p><strong>解决：</strong></p>
<pre><code>1. 重新设计系统减少线程数量。

2. 线程数量不能减少的情况下，通过-Xss减小单个线程大小。以便能生产更多的线程。
</code></pre>
      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/JVM/">JVM</a></li></span></span> | <span class="tags">Tagged <a href="/tags/JVM/" class="label label-primary">JVM</a><a href="/tags/Java&J2EE/" class="label label-success">Java&J2EE</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:42"datetime="2014-03-07 09:54:42"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-JVM--JVM调优总结（十）-调优方法/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-JVM--JVM调优总结（十）-调优方法" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--通过Java-JMX得到fullGC次数？-高级语言虚拟机/">通过Java</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:42.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--通过Java-JMX得到fullGC次数？-高级语言虚拟机/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-java-jmx-full-gc-">通过Java/JMX得到full GC次数？ - 高级语言虚拟机</h1>
<p><a href="http://hllvm.group.iteye.com/login" title="登录" target="_blank">您还未登录 !</a> <a href="http://hllvm.group.iteye.com/login" target="_blank">登录</a> <a href="http://hllvm.group.iteye.com/signup" target="_blank">注册</a></p>
<p><a href="http://www.iteye.com/" target="_blank"><img src="&quot;ITeye-最棒的软件开发交流社区&quot;" alt="ITeye3.0"></a></p>
<p><a href=""></a></p>
<p><a href="http://www.iteye.com/groups" target="_blank">群组首页</a> → <a href="http://hllvm.group.iteye.com/groups/category/language" target="_blank">编程语言</a> → <a href="http://hllvm.group.iteye.com/" target="_blank">高级语言虚拟机</a> → <a href="http://hllvm.group.iteye.com/group/wiki" target="_blank">知识库</a> → <a href="http://hllvm.group.iteye.com/group/wiki?category_id=315" target="_blank">JVM实战</a> → <a href="">通过Java/JMX得到full GC次数？</a>
原创作者: <a href="http://www.javaeye.com/topic/790015" target="_blank">RednaxelaFX</a>   阅读:2261次   评论:1条   更新时间:2011-05-26    </p>
<p>今天有个同事问如何能通过<a href="http://java.sun.com/javase/technologies/core/mntr-mgmt/javamanagement/" target="_blank">JMX</a>获取到某个Java进程的full GC次数：
引用</p>
<p>hi,问个问题，怎们在java中获取到full gc的次数呢？
我现在用jmx的那个得到了gc次数，不过不能细化出来full gc的次数
Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>for (final GarbageCollectorMXBean garbageCollector  </li>
<li>: ManagementFactory.getGarbageCollectorMXBeans()) {  </li>
<li>gcCounts += garbageCollector.getCollectionCount();  </li>
<li><p>}<br>for (final GarbageCollectorMXBean garbageCollector : ManagementFactory.getGarbageCollectorMXBeans()) { gcCounts += garbageCollector.getCollectionCount(); }
你比如我现在是这样拿次数的
我回答说因为full GC概念只有在分代式GC的上下文中才存在，而JVM并不强制要求GC使用分代式实现，所以JMX提供的标准<a href="http://download-llnw.oracle.com/javase/6/docs/technotes/guides/management/mxbeans.html" target="_blank">MXBean</a> API里不提供“full GC次数”这样的方法也正常。
既然“full GC”本来就是非常平台相关的概念，那就hack一点，用平台相关的代码来解决问题好了。这些GC的MXBean都是有名字的，而主流的JVM的GC名字相对稳定，非要通过JMX得到full GC次数的话，用名字来判断一下就好了。
举个例子来看看。通过JDK 6自带的<a href="http://download-llnw.oracle.com/javase/6/docs/technotes/guides/management/jconsole.html" target="_blank">JConsole</a>工具来查看相关的MXBean的话，可以看到，
GC的MXBean在这个位置：
<img src="&quot;点击查看原始大小图片&quot;" alt="">
这个例子是用server模式启动JConsole的，使用的是ParallelScavenge GC，它的年老代对应的收集器在这里：
<img src="&quot;点击查看原始大小图片&quot;" alt="">
该收集器的总收集次数在此，这也就是full GC的次数：
<img src="&quot;点击查看原始大小图片&quot;" alt="">
于是只要知道我们用的JVM提供的GC MXBean的名字与分代的关系，就可以知道full GC的次数了。
Java代码写起来冗长，这帖就不用Java来写例子了，反正API是一样的，意思能表达清楚就OK。
用一个<a href="http://groovy.codehaus.org/" target="_blank">Groovy</a>脚本简单演示一下适用于Oracle (Sun) HotSpot与Oracle (BEA) JRockit的GC统计程序：
Groovy代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>import java.lang.management.ManagementFactory  </p>
</li>
<li></li>
<li>printGCStats = {  </li>
<li>def youngGenCollectorNames = [  </li>
<li>// Oracle (Sun) HotSpot  </li>
<li>// -XX:+UseSerialGC  </li>
<li>&#39;Copy&#39;,  </li>
<li>// -XX:+UseParNewGC  </li>
<li>&#39;ParNew&#39;,  </li>
<li>// -XX:+UseParallelGC  </li>
<li>&#39;PS Scavenge&#39;,  </li>
<li></li>
<li>// Oracle (BEA) JRockit  </li>
<li>// -XgcPrio:pausetime  </li>
<li>&#39;Garbage collection optimized for short pausetimes Young Collector&#39;,  </li>
<li>// -XgcPrio:throughput  </li>
<li>&#39;Garbage collection optimized for throughput Young Collector&#39;,  </li>
<li>// -XgcPrio:deterministic  </li>
<li>&#39;Garbage collection optimized for deterministic pausetimes Young Collector&#39;  </li>
<li>]  </li>
<li></li>
<li>def oldGenCollectorNames = [  </li>
<li>// Oracle (Sun) HotSpot  </li>
<li>// -XX:+UseSerialGC  </li>
<li>&#39;MarkSweepCompact&#39;,  </li>
<li>// -XX:+UseParallelGC and (-XX:+UseParallelOldGC or -XX:+UseParallelOldGCCompacting)  </li>
<li>&#39;PS MarkSweep&#39;,  </li>
<li>// -XX:+UseConcMarkSweepGC  </li>
<li>&#39;ConcurrentMarkSweep&#39;,  </li>
<li></li>
<li>// Oracle (BEA) JRockit  </li>
<li>// -XgcPrio:pausetime  </li>
<li>&#39;Garbage collection optimized for short pausetimes Old Collector&#39;,  </li>
<li>// -XgcPrio:throughput  </li>
<li>&#39;Garbage collection optimized for throughput Old Collector&#39;,  </li>
<li>// -XgcPrio:deterministic  </li>
<li>&#39;Garbage collection optimized for deterministic pausetimes Old Collector&#39;  </li>
<li>]  </li>
<li></li>
<li>R: {  </li>
<li>ManagementFactory.garbageCollectorMXBeans.each {  </li>
<li>def name  = it.name  </li>
<li>def count = it.collectionCount  </li>
<li>def gcType;  </li>
<li>switch (name) {  </li>
<li>case youngGenCollectorNames:  </li>
<li>gcType = &#39;Minor Collection&#39;  </li>
<li>break  </li>
<li>case oldGenCollectorNames:  </li>
<li>gcType = &#39;Major Collection&#39;  </li>
<li>break  </li>
<li>default:  </li>
<li>gcType = &#39;Unknown Collection Type&#39;  </li>
<li>break  </li>
<li>}  </li>
<li>println &quot;$count &lt;- $gcType: $name&quot;  </li>
<li>}  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li><p>printGCStats()<br>import java.lang.management.ManagementFactory printGCStats = { def youngGenCollectorNames = [ // Oracle (Sun) HotSpot // -XX:+UseSerialGC &#39;Copy&#39;, // -XX:+UseParNewGC &#39;ParNew&#39;, // -XX:+UseParallelGC &#39;PS Scavenge&#39;, // Oracle (BEA) JRockit // -XgcPrio:pausetime &#39;Garbage collection optimized for short pausetimes Young Collector&#39;, // -XgcPrio:throughput &#39;Garbage collection optimized for throughput Young Collector&#39;, // -XgcPrio:deterministic &#39;Garbage collection optimized for deterministic pausetimes Young Collector&#39; ] def oldGenCollectorNames = [ // Oracle (Sun) HotSpot // -XX:+UseSerialGC &#39;MarkSweepCompact&#39;, // -XX:+UseParallelGC and (-XX:+UseParallelOldGC or -XX:+UseParallelOldGCCompacting) &#39;PS MarkSweep&#39;, // -XX:+UseConcMarkSweepGC &#39;ConcurrentMarkSweep&#39;, // Oracle (BEA) JRockit // -XgcPrio:pausetime &#39;Garbage collection optimized for short pausetimes Old Collector&#39;, // -XgcPrio:throughput &#39;Garbage collection optimized for throughput Old Collector&#39;, // -XgcPrio:deterministic &#39;Garbage collection optimized for deterministic pausetimes Old Collector&#39; ] R: { ManagementFactory.garbageCollectorMXBeans.each { def name = it.name def count = it.collectionCount def gcType; switch (name) { case youngGenCollectorNames: gcType = &#39;Minor Collection&#39; break case oldGenCollectorNames: gcType = &#39;Major Collection&#39; break default: gcType = &#39;Unknown Collection Type&#39; break } println &quot;$count &lt;- $gcType: $name&quot; } } } printGCStats()
执行可以看到类似这样的输出：
Command prompt代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>5 &lt;- Minor Collection: Copy  </p>
</li>
<li><p>0 &lt;- Major Collection: MarkSweepCompact<br>5 &lt;- Minor Collection: Copy 0 &lt;- Major Collection: MarkSweepCompact
↑这是用client模式的HotSpot执行得到的；
Command prompt代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>0 &lt;- Minor Collection: Garbage collection optimized for throughput Young Collector  </p>
</li>
<li><p>0 &lt;- Major Collection: Garbage collection optimized for throughput Old Collector<br>0 &lt;- Minor Collection: Garbage collection optimized for throughput Young Collector 0 &lt;- Major Collection: Garbage collection optimized for throughput Old Collector
↑这是用JRockit R28在32位Windows上的默认模式得到的。
通过上述方法，要包装起来方便以后使用的话也很简单，例如下面Groovy程序：
Groovy代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>import java.lang.management.ManagementFactory  </p>
</li>
<li></li>
<li>class GCStats {  </li>
<li>static final List<String> YoungGenCollectorNames = [  </li>
<li>// Oracle (Sun) HotSpot  </li>
<li>// -XX:+UseSerialGC  </li>
<li>&#39;Copy&#39;,  </li>
<li>// -XX:+UseParNewGC  </li>
<li>&#39;ParNew&#39;,  </li>
<li>// -XX:+UseParallelGC  </li>
<li>&#39;PS Scavenge&#39;,  </li>
<li></li>
<li>// Oracle (BEA) JRockit  </li>
<li>// -XgcPrio:pausetime  </li>
<li>&#39;Garbage collection optimized for short pausetimes Young Collector&#39;,  </li>
<li>// -XgcPrio:throughput  </li>
<li>&#39;Garbage collection optimized for throughput Young Collector&#39;,  </li>
<li>// -XgcPrio:deterministic  </li>
<li>&#39;Garbage collection optimized for deterministic pausetimes Young Collector&#39;  </li>
<li>]  </li>
<li></li>
<li>static final List<String> OldGenCollectorNames = [  </li>
<li>// Oracle (Sun) HotSpot  </li>
<li>// -XX:+UseSerialGC  </li>
<li>&#39;MarkSweepCompact&#39;,  </li>
<li>// -XX:+UseParallelGC and (-XX:+UseParallelOldGC or -XX:+UseParallelOldGCCompacting)  </li>
<li>&#39;PS MarkSweep&#39;,  </li>
<li>// -XX:+UseConcMarkSweepGC  </li>
<li>&#39;ConcurrentMarkSweep&#39;,  </li>
<li></li>
<li>// Oracle (BEA) JRockit  </li>
<li>// -XgcPrio:pausetime  </li>
<li>&#39;Garbage collection optimized for short pausetimes Old Collector&#39;,  </li>
<li>// -XgcPrio:throughput  </li>
<li>&#39;Garbage collection optimized for throughput Old Collector&#39;,  </li>
<li>// -XgcPrio:deterministic  </li>
<li>&#39;Garbage collection optimized for deterministic pausetimes Old Collector&#39;  </li>
<li>]  </li>
<li></li>
<li>static int getYoungGCCount() {  </li>
<li>ManagementFactory.garbageCollectorMXBeans.inject(0) { youngGCCount, gc -&gt;  </li>
<li>if (YoungGenCollectorNames.contains(gc.name))  </li>
<li>youngGCCount + gc.collectionCount  </li>
<li>else  </li>
<li>youngGCCount  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>static int getFullGCCount() {  </li>
<li>ManagementFactory.garbageCollectorMXBeans.inject(0) { fullGCCount, gc -&gt;  </li>
<li>if (OldGenCollectorNames.contains(gc.name))  </li>
<li>fullGCCount + gc.collectionCount  </li>
<li>else  </li>
<li>fullGCCount  </li>
<li>}  </li>
<li>}  </li>
<li><p>}<br>import java.lang.management.ManagementFactory class GCStats { static final List<String> YoungGenCollectorNames = [ // Oracle (Sun) HotSpot // -XX:+UseSerialGC &#39;Copy&#39;, // -XX:+UseParNewGC &#39;ParNew&#39;, // -XX:+UseParallelGC &#39;PS Scavenge&#39;, // Oracle (BEA) JRockit // -XgcPrio:pausetime &#39;Garbage collection optimized for short pausetimes Young Collector&#39;, // -XgcPrio:throughput &#39;Garbage collection optimized for throughput Young Collector&#39;, // -XgcPrio:deterministic &#39;Garbage collection optimized for deterministic pausetimes Young Collector&#39; ] static final List<String> OldGenCollectorNames = [ // Oracle (Sun) HotSpot // -XX:+UseSerialGC &#39;MarkSweepCompact&#39;, // -XX:+UseParallelGC and (-XX:+UseParallelOldGC or -XX:+UseParallelOldGCCompacting) &#39;PS MarkSweep&#39;, // -XX:+UseConcMarkSweepGC &#39;ConcurrentMarkSweep&#39;, // Oracle (BEA) JRockit // -XgcPrio:pausetime &#39;Garbage collection optimized for short pausetimes Old Collector&#39;, // -XgcPrio:throughput &#39;Garbage collection optimized for throughput Old Collector&#39;, // -XgcPrio:deterministic &#39;Garbage collection optimized for deterministic pausetimes Old Collector&#39; ] static int getYoungGCCount() { ManagementFactory.garbageCollectorMXBeans.inject(0) { youngGCCount, gc -&gt; if (YoungGenCollectorNames.contains(gc.name)) youngGCCount + gc.collectionCount else youngGCCount } } static int getFullGCCount() { ManagementFactory.garbageCollectorMXBeans.inject(0) { fullGCCount, gc -&gt; if (OldGenCollectorNames.contains(gc.name)) fullGCCount + gc.collectionCount else fullGCCount } } }
用的时候：
Groovysh代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>D:>\sdk\groovy-1.7.2\bin\groovysh  </p>
</li>
<li>Groovy Shell (1.7.2, JVM: 1.6.0_20)  </li>
<li>Type &#39;help&#39; or &#39;\h&#39; for help.  </li>
<li><hr>
</li>
<li>groovy:000&gt; GCStats.fullGCCount  </li>
<li>===&gt; 0  </li>
<li>groovy:000&gt; System.gc()  </li>
<li>===&gt; null  </li>
<li>groovy:000&gt; GCStats.fullGCCount  </li>
<li>===&gt; 1  </li>
<li>groovy:000&gt; System.gc()  </li>
<li>===&gt; null  </li>
<li>groovy:000&gt; System.gc()  </li>
<li>===&gt; null  </li>
<li>groovy:000&gt; GCStats.fullGCCount  </li>
<li>===&gt; 3  </li>
<li>groovy:000&gt; GCStats.youngGCCount  </li>
<li>===&gt; 9  </li>
<li>groovy:000&gt; GCStats.youngGCCount  </li>
<li>===&gt; 9  </li>
<li>groovy:000&gt; GCStats.youngGCCount  </li>
<li>===&gt; 9  </li>
<li>groovy:000&gt; System.gc()  </li>
<li>===&gt; null  </li>
<li>groovy:000&gt; GCStats.youngGCCount  </li>
<li>===&gt; 9  </li>
<li>groovy:000&gt; GCStats.fullGCCount  </li>
<li>===&gt; 4  </li>
<li>groovy:000&gt; quit<br>D:>\sdk\groovy-1.7.2\bin\groovysh Groovy Shell (1.7.2, JVM: 1.6.0_20) Type &#39;help&#39; or &#39;\h&#39; for help. -------------------------------------------------- groovy:000&gt; GCStats.fullGCCount ===&gt; 0 groovy:000&gt; System.gc() ===&gt; null groovy:000&gt; GCStats.fullGCCount ===&gt; 1 groovy:000&gt; System.gc() ===&gt; null groovy:000&gt; System.gc() ===&gt; null groovy:000&gt; GCStats.fullGCCount ===&gt; 3 groovy:000&gt; GCStats.youngGCCount ===&gt; 9 groovy:000&gt; GCStats.youngGCCount ===&gt; 9 groovy:000&gt; GCStats.youngGCCount ===&gt; 9 groovy:000&gt; System.gc() ===&gt; null groovy:000&gt; GCStats.youngGCCount ===&gt; 9 groovy:000&gt; GCStats.fullGCCount ===&gt; 4 groovy:000&gt; quit
这是在Sun JDK 6 update 20上跑的。顺带一提，如果这是跑在JRockit上的话，那full GC的次数就不会增加——因为JRockit里System.gc()默认是触发young GC的；请不要因为Sun HotSpot的默认行为而认为System.gc()总是会触发full GC的。
关于JMX的MXBean的使用，也可以参考下面两篇文档：
<a href="http://docs.codehaus.org/display/GROOVY/Groovy+and+JMX" target="_blank">Groovy and JMX</a>
<a href="http://www.engineyard.com/blog/2010/monitoring-the-jvm-heap-with-jruby/" target="_blank">Monitoring the JVM Heap with JRuby</a>
<a href="http://hllvm.group.iteye.com/group/wiki/3042-JVM-eclipse" title="如何更快的启动eclipse" target="_blank">如何更快的启动eclipse</a></li>
</ol>
<p>评论 共 1 条 请<a href="http://hllvm.group.iteye.com/login" target="_blank">登录</a>后发表评论 <a href=""></a></p>
<h3 id="1-xgj1988-http-xgj1988-iteye-com-xgj1988-2011-04-27-15-07">1 楼 <a href="http://xgj1988.iteye.com/" title="xgj1988" target="_blank">xgj1988</a> 2011-04-27 15:07</h3>
<p>SUN jdk   使用FULL GC 是如下的几种之一？
Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>static final List<String> OldGenCollectorNames = [     </li>
<li>// Oracle (Sun) HotSpot     </li>
<li>// -XX:+UseSerialGC     </li>
<li>&#39;MarkSweepCompact&#39;,     </li>
<li>// -XX:+UseParallelGC and (-XX:+UseParallelOldGC or -XX:+UseParallelOldGCCompacting)     </li>
<li>&#39;PS MarkSweep&#39;,     </li>
<li>// -XX:+UseConcMarkSweepGC     </li>
<li>&#39;ConcurrentMarkSweep&#39;,     </li>
<li></li>
<li><p>]<br>static final List<String> OldGenCollectorNames = [ // Oracle (Sun) HotSpot // -XX:+UseSerialGC &#39;MarkSweepCompact&#39;, // -XX:+UseParallelGC and (-XX:+UseParallelOldGC or -XX:+UseParallelOldGCCompacting) &#39;PS MarkSweep&#39;, // -XX:+UseConcMarkSweepGC &#39;ConcurrentMarkSweep&#39;, ]
这几个是young gc?
Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>&#39;Copy&#39;,     </p>
</li>
<li>// -XX:+UseParNewGC     </li>
<li>&#39;ParNew&#39;,     </li>
<li>// -XX:+UseParallelGC     </li>
<li>&#39;PS Scavenge&#39;,     </li>
<li>&#39;Copy&#39;, // -XX:+UseParNewGC &#39;ParNew&#39;, // -XX:+UseParallelGC &#39;PS Scavenge&#39;,
根据名字判断来获取full gc<img src="" alt=""><h3 id="-">发表评论</h3>
</li>
</ol>
<p><a href="http://hllvm.group.iteye.com/login" target="_blank"><img src="" alt=""> 您还没有登录,请您登录后再发表评论</a></p>
<p><a href="http://hllvm.group.iteye.com/group/wiki/new" target="_blank"><img src="" alt="New-page"></a></p>
<h3 id="-">文章信息</h3>
<p><a href="http://hllvm.group.iteye.com/group/wiki/" target="_blank">知识库: 高级语言虚拟机</a></p>
<ul>
<li>由<a href="http://kiral.iteye.com/" title="fantasy" target="_blank">fantasy</a>在2010-12-16创建</li>
<li><p>由<a href="http://kiral.iteye.com/" title="fantasy" target="_blank">fantasy</a>在2011-05-26更新</p>
<h3 id="-">相关新闻</h3>
</li>
<li><p><a href="http://hllvm.group.iteye.com/news/6318-java-se-6-update-14-early-access-version" target="_blank">Java SE 6 Update 14 Early Access 早期使用版本现已发布</a></p>
</li>
<li><a href="http://hllvm.group.iteye.com/news/4146-jdk-7-in-the-new-garbage-collection-mechanism" target="_blank">JDK 7 中新的垃圾收集机制</a></li>
<li><a href="http://hllvm.group.iteye.com/news/10069" target="_blank">Java 7的新功能和Java 1.5,1.6,1.7的性能测试比较</a></li>
</ul>
<h3 id="-">相关讨论</h3>
<ul>
<li><a href="http://hllvm.group.iteye.com/topic/894148" target="_blank">HotSpot VM 内存堆的两个Servivor区</a></li>
<li><a href="http://hllvm.group.iteye.com/topic/976522" target="_blank">java内存管理以及GC</a></li>
<li><a href="http://hllvm.group.iteye.com/topic/802638" target="_blank">JVM内存管理：深入垃圾收集器与内存分配策略</a></li>
<li><a href="http://hllvm.group.iteye.com/topic/212967" target="_blank">一次Java垃圾收集调优实战</a></li>
<li><p><a href="http://hllvm.group.iteye.com/topic/262541" target="_blank">JVM的GC-生命不能承受之重</a></p>
<h3 id="-">相关博客</h3>
</li>
<li><p><a href="http://rednaxelafx.iteye.com/blog/790015" target="_blank">通过Java/JMX得到full GC次数？</a></p>
</li>
<li><a href="http://millerhu.iteye.com/blog/890724" target="_blank">通过Java/JMX得到full GC次数？</a></li>
<li><a href="http://rednaxelafx.iteye.com/blog/790864" target="_blank">用Java获取full GC的次数？（2）</a></li>
<li><a href="http://tianshibaijia.iteye.com/blog/1343308" target="_blank">常用垃圾收集器在Mbean上的名称</a></li>
<li><a href="http://rednaxelafx.iteye.com/blog/1042471" target="_blank">答复: HotSpot VM 内存堆的两个Survivor区</a></li>
<li><a href="http://www.iteye.com/" target="_blank">首页</a></li>
<li><a href="http://www.iteye.com/news" target="_blank">资讯</a></li>
<li><a href="http://www.iteye.com/magazines" target="_blank">精华</a></li>
<li><a href="http://www.iteye.com/forums" target="_blank">论坛</a></li>
<li><a href="http://www.iteye.com/ask" target="_blank">问答</a></li>
<li><a href="http://www.iteye.com/blogs" target="_blank">博客</a></li>
<li><a href="http://www.iteye.com/blogs/subjects" target="_blank">专栏</a></li>
<li><a href="http://www.iteye.com/groups" target="_blank">群组</a></li>
<li><a href="http://job.iteye.com/iteye" target="_blank">招聘</a></li>
<li><a href="http://www.iteye.com/search" target="_blank">搜索</a></li>
<li><a href="http://hllvm.group.iteye.com/index/service" target="_blank">广告服务</a></li>
<li><a href="http://webmaster.iteye.com/" target="_blank">ITeye黑板报</a></li>
<li><a href="http://hllvm.group.iteye.com/index/contactus" target="_blank">联系我们</a></li>
<li><a href="http://hllvm.group.iteye.com/index/friend_links" target="_blank">友情链接</a></li>
</ul>
<p>© 2003-2012 ITeye.com. [ <a href="http://www.miibeian.gov.cn/" target="_blank">京ICP证110151号</a> 京公网安备110105010620 ]
百联优力(北京)投资有限公司 版权所有 <img src="http://stat.iteye.com/?url=http%3A%2F%2Fhllvm.group.iteye.com%2Fgroup%2Fwiki%2F2950-gc&amp;referrer=&amp;user_id=" alt=""></p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/JVM/">JVM</a></li></span></span> | <span class="tags">Tagged <a href="/tags/JVM/" class="label label-primary">JVM</a><a href="/tags/Java&J2EE/" class="label label-success">Java&J2EE</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:42"datetime="2014-03-07 09:54:42"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-JVM--通过Java-JMX得到fullGC次数？-高级语言虚拟机/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-JVM--通过Java-JMX得到fullGC次数？-高级语言虚拟机" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--请别再拿“StringsnewString-xyz-创建了多少个String实例”来/">请别再拿“String s = new String(</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:42.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--请别再拿“StringsnewString-xyz-创建了多少个String实例”来/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-string-s-new-string-xyz-string-">请别再拿“String s = new String(&quot;xyz&quot;);创建了多少个String实例”来面试了吧</h1>
<p>这帖是用来回复<a href="http://hllvm.group.iteye.com/" target="_blank">高级语言虚拟机</a>圈子里的一个问题，<a href="http://hllvm.group.iteye.com/group/topic/21761" target="_blank">一道Java笔试题</a>的。
本来因为见得太多已经吐槽无力，但这次实在忍不住了就又爆发了一把。写得太长干脆单独开了一帖。
顺带广告：对JVM感兴趣的同学们同志们请多多支持<a href="http://hllvm.group.iteye.com/" target="_blank">高级语言虚拟机</a>圈子 <img src="" alt=""></p>
<h1 id="-">以下是回复内容。文中的“楼主”是针对原问题帖而言。</h1>
<p>楼主是看各种宝典了么……以后我面试人的时候就要专找宝典答案是错的来问，方便筛人orz
楼主要注意了：这题或类似的题虽然经常见，但使用这个描述方式实际上没有任何意义：
引用</p>
<p>问题：</p>
<p>Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>String s = new String(&quot;xyz&quot;);<br>String s = new String(&quot;xyz&quot;);创建了几个String Object？
这个问题自身就没有合理的答案，楼主所引用的“标准答案”自然也就不准确了：
引用</li>
</ol>
<p>答案：两个(一个是“xyz”,一个是指向“xyz”的引用对象s)
（好吧这个答案的吐槽点很多……大家慢慢来）
这问题的毛病是什么呢？它并没有定义“创建了”的意义。
什么叫“创建了”？什么时候创建了什么？
而且这段Java代码片段实际运行的时候真的会“创建两个String实例”么？
如果这道是面试题，那么可以当面让面试官澄清“创建了”的定义，然后再对应的回答。这种时候面试官多半会让被面试者自己解释，那就好办了，好好晒给面试官看。</p>
<h1 id="-">如果是笔试题就没有提问要求澄清的机会了。不过会出这种题目的地方水平多半也不怎么样。说不定出题的人就是从各种宝典上把题抄来的，那就按照宝典把那不大对劲的答案写上去就能混过去了<img src="" alt=""></h1>
<p>先换成另一个问题来问：
引用</p>
<p>问题：</p>
<p>Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>String s = new String(&quot;xyz&quot;);<br>String s = new String(&quot;xyz&quot;);在运行时涉及几个String实例？
一种合理的解答是：
引用</li>
</ol>
<p>答案：两个，一个是字符串字面量&quot;xyz&quot;所对应的、驻留（intern）在一个全局共享的字符串常量池中的实例，另一个是通过new String(String)创建并初始化的、内容与&quot;xyz&quot;相同的实例
这是根据Java语言规范相关规定可以给出的合理答案。考虑到Java语言规范中明确指出了：
The Java Language Specification, Third Edition 写道</p>
<p>The Java programming language is normally compiled to the bytecoded instruction set and binary format defined in <em>The Java Virtual Machine Specification, Second Edition</em> (Addison-Wesley, 1999).
也就是规定了Java语言一般是编译为Java虚拟机规范所定义的Class文件，但并没有规定“一定”（must），留有不使用JVM来实现Java语言的余地。
考虑上Java虚拟机规范，确实在这段代码里涉及的常量种类为<a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html#29297" target="_blank">CONSTANT_String_info</a>的字符串常量也只有&quot;xyz&quot;一个。CONSTANT_String_info是用来表示Java语言中String类型的常量表达式的值（包括字符串字面量）用的常量种类，只在这个层面上考虑的话，这个解答也没问题。
所以这种解答可以认为是合理的。
值得注意的是问题中“在运行时”既包括类加载阶段，也包括这个代码片段自身执行的时候。下文会再讨论这个细节与楼主原本给出的问题的关系。
碰到这种问题首先应该想到去查阅相关的规范，这里具体是<a href="http://java.sun.com/docs/books/jls/" target="_blank">Java语言规范</a>与<a href="http://java.sun.com/docs/books/jvms/" target="_blank">Java虚拟机规范</a>，以及一些相关API的JavaDoc。很多人喜欢把“按道理说”当作口头禅，规范就是用来定义各种“道理”的——“为什么XXX是YYY的意思？”“因为规范里是这样定义的！”——无敌了。
在Java虚拟机规范中相关的定义有下面一些：
The Java Virtual Machine Specification, Second Edition 写道</p>
<p><strong>2.3 Literals</strong>
A literal is the source code representation of a value of a primitive type <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Concepts.doc.html#19511" target="_blank">(§2.4.1)</a>, the String type <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Concepts.doc.html#25486" target="_blank">(§2.4.8)</a>, or the null type <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Concepts.doc.html#22930" target="_blank">(§2.4)</a>. String literals and, more generally, strings that are the values of constant expressions are &quot;interned&quot; so as to share unique instances, using the method String.intern.
The null type has one value, the null reference, denoted by the literal null. The boolean type has two values, denoted by the literals true and false.
<strong>2.4.8 The Class String</strong>
Instances of class String represent sequences of Unicode characters <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Concepts.doc.html#25310" target="_blank">(§2.1)</a>. A String object has a constant, unchanging value. String literals <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Concepts.doc.html#20359" target="_blank">(§2.3)</a> are references to instances of class String.
<strong>2.17.6 Creation of New Class Instances</strong>
A new class instance is explicitly created when one of the following situations occurs:</p>
<ul>
<li>Evaluation of a class instance creation expression creates a new instance of the class whose name appears in the expression.</li>
<li><p>Invocation of the newInstance method of class Class creates a new instance of the class represented by the Class object for which the method was invoked.
A new class instance may be implicitly created in the following situations:</p>
</li>
<li><p>Loading of a class or interface that contains a String literal may create a new String object <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Concepts.doc.html#25486" target="_blank">(§2.4.8)</a> to represent that literal. This may not occur if the a String object has already been created to represent a previous occurrence of that literal, or if the String.intern method has been invoked on a String object representing the same string as the literal.</p>
</li>
<li>Execution of a string concatenation operator that is not part of a constant expression sometimes creates a new String object to represent the result. String concatenation operators may also create temporary wrapper objects for a value of a primitive type <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Concepts.doc.html#19511" target="_blank">(§2.4.1)</a>.
Each of these situations identifies a particular constructor to be called with specified arguments (possibly none) as part of the class instance creation process.
<strong>5.1 The Runtime Constant Pool</strong>
...
● A string literal <a href="http://java.sun.com/docs/books/jvms/second_edition/html/Concepts.doc.html#20359" target="_blank">(§2.3)</a> is derived from a CONSTANT_String_info structure <a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html#29297" target="_blank">(§4.4.3)</a> in the binary representation of a class or interface. The CONSTANT_String_info structure gives the sequence of Unicode characters constituting the string literal.
● The Java programming language requires that identical string literals (that is, literals that contain the same sequence of characters) must refer to the same instance of class String. In addition, if the method String.intern is called on any string, the result is a reference to the same class instance that would be returned if that string appeared as a literal. Thus,
Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></li>
</ul>
<ol>
<li>(&quot;a&quot; + &quot;b&quot; + &quot;c&quot;).intern() == &quot;abc&quot;  </li>
</ol>
<p>(&quot;a&quot; + &quot;b&quot; + &quot;c&quot;).intern() == &quot;abc&quot;
must have the value true.
● To derive a string literal, the Java virtual machine examines the sequence of characters given by the CONSTANT_String_info structure.
  ○ If the method String.intern has previously been called on an instance of class String containing a sequence of Unicode characters identical to that given by the CONSTANT_String_info structure, then the result of string literal derivation is a reference to that same instance of class String.
  ○ Otherwise, a new instance of class String is created containing the sequence of Unicode characters given by the CONSTANT_String_info structure; that class instance is the result of string literal derivation. Finally, the intern method of the new String instance is invoked.
...
The remaining structures in the constant_pool table of the binary representation of a class or interface, the CONSTANT_NameAndType_info <a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html#1327" target="_blank">(§4.4.6)</a> and CONSTANT_Utf8_info <a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html#7963" target="_blank">(§4.4.7)</a> structures are only used indirectly when deriving symbolic references to classes, interfaces, methods, and fields, and when deriving string literals.
把Sun的JDK看作参考实现（reference implementation, RI），其中<a href="http://download.oracle.com/javase/6/docs/api/java/lang/String.html#intern(" target="_blank">String.intern()的JavaDoc</a>)为：
JavaDoc 写道</p>
<p>public String intern()
    Returns a canonical representation for the string object.
    A pool of strings, initially empty, is maintained privately by the class String.
    When the intern method is invoked, if the pool already contains a string equal to this String object as determined by the equals(Object) method, then the string from the pool is returned. Otherwise, this String object is added to the pool and a reference to this String object is returned.
    It follows that for any two strings s and t, s.intern() == t.intern() is true if and only if s.equals(t) is true.
    All literal strings and string-valued constant expressions are interned. String literals are defined in §3.10.5 of the Java Language Specification
    <strong>Returns:</strong></p>
<pre><code>    a string that has the same contents as this string, but is guaranteed to be from a pool of unique strings.
</code></pre><p>===============================================================
再换一个问题来问：
引用</p>
<p>问题：</p>
<p>Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>String s = new String(&quot;xyz&quot;);<br>String s = new String(&quot;xyz&quot;); 涉及用户声明的几个String类型的变量？
答案也很简单：
引用</li>
</ol>
<p>答案：一个，就是String s。
把问题换成下面这个版本，答案也一样：
引用</p>
<p>问题：</p>
<p>Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li><p>String s = null;<br>String s = null; 涉及用户声明的几个String类型的变量？
Java里变量就是变量，引用类型的变量只是对某个对象实例或者null的引用，不是实例本身。声明变量的个数跟创建实例的个数没有必然关系，像是说：
Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>String s1 = &quot;a&quot;;  </p>
</li>
<li>String s2 = s1.concat(&quot;&quot;);  </li>
<li>String s3 = null;  </li>
<li>new String(s1);  </li>
</ol>
<p>String s1 = &quot;a&quot;;</p>
<p>String s2 = s1.concat(&quot;&quot;);
String s3 = null;</p>
<p>new String(s1);
这段代码会涉及3个String类型的变量，
1、s1，指向下面String实例的1
2、s2，指向与s1相同
3、s3，值为null，不指向任何实例
以及3个String实例，
1、&quot;a&quot;字面量对应的驻留的字符串常量的String实例
2、&quot;&quot;字面量对应的驻留的字符串常量的String实例
（<a href="http://download.oracle.com/javase/6/docs/api/java/lang/String.html#concat(java.lang.String" target="_blank">String.concat()</a>)是个有趣的方法，当发现传入的参数是空字符串时会返回this，所以这里不会额外创建新的String实例）</p>
<h1 id="3-new-string-string-string-">3、通过new String(String)创建的新String实例；没有任何变量指向它。</h1>
<p>回到楼主开头引用的问题与“标准答案”
引用</p>
<p>问题：</p>
<p>Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li><p>String s = new String(&quot;xyz&quot;);<br>String s = new String(&quot;xyz&quot;);创建了几个String Object？
答案：两个(一个是“xyz”,一个是指向“xyz”的引用对象s)
用归谬法论证。假定问题问的是“在执行这段代码片段时创建了几个String实例”。如果“标准答案”是正确的，那么下面的代码片段在执行时就应该创建4个String实例了：
Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>String s1 = new String(&quot;xyz&quot;);  </p>
</li>
<li>String s2 = new String(&quot;xyz&quot;);  </li>
</ol>
<p>String s1 = new String(&quot;xyz&quot;);</p>
<p>String s2 = new String(&quot;xyz&quot;);
马上就会有人跳出来说上下两个&quot;xyz&quot;字面量都是引用了同一个String对象，所以不应该是创建了4个对象。
那么应该是多少个？
运行时的类加载过程与实际执行某个代码片段，两者必须分开讨论才有那么点意义。
为了执行问题中的代码片段，其所在的类必然要先被加载，而且同一个类最多只会被加载一次（要注意对JVM来说“同一个类”并不是类的全限定名相同就足够了，而是&lt;类全限定名, 定义类加载器&gt;一对都相同才行）。
根据上文引用的规范的内容，符合规范的JVM实现应该在类加载的过程中创建并驻留一个String实例作为常量来对应&quot;xyz&quot;字面量；具体是在类加载的resolve阶段进行的。这个常量是全局共享的，只在先前尚未有内容相同的字符串驻留过的前提下才需要创建新的String实例。
等到真正执行原问题中的代码片段时，JVM需要执行的字节码类似这样：
Java bytecode代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>0: new  /#2; //class java/lang/String  </li>
<li>3: dup  </li>
<li>4: ldc  /#3; //String xyz  </li>
<li>6: invokespecial    /#4; //Method java/lang/String.&quot;<init>&quot;:(Ljava/lang/String;)V  </li>
<li>9: astore_1  </li>
</ol>
<p>0: new    /#2; //class java/lang/String</p>
<p>3: dup
4: ldc    /#3; //String xyz</p>
<p>6: invokespecial    /#4; //Method java/lang/String.&quot;<init>&quot;:(Ljava/lang/String;)V
9: astore_1
这之中出现过多少次new java/lang/String就是创建了多少个String对象。也就是说原问题中的代码在每执行一次只会新创建一个String实例。
这里，ldc指令只是把先前在类加载过程中已经创建好的一个String对象（&quot;xyz&quot;）的一个引用压到操作数栈顶而已，并不新创建String对象。
所以刚才用于归谬的代码片段：
Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>String s1 = new String(&quot;xyz&quot;);  </li>
<li>String s2 = new String(&quot;xyz&quot;);  </li>
</ol>
<p>String s1 = new String(&quot;xyz&quot;);</p>
<p>String s2 = new String(&quot;xyz&quot;);</p>
<h2 id="-2-string-">每执行一次只会新创建2个String实例。</h2>
<p>为了避免一些同学犯糊涂，再强调一次：
在Java语言里，“new”表达式是负责创建实例的，其中会调用构造器去对实例做初始化；构造器自身的返回值类型是void，并不是“构造器返回了新创建的对象的引用”，而是new表达式的值是新创建的对象的引用。
对应的，在JVM里，“new”字节码指令只负责把实例创建出来（包括分配空间、设定类型、所有字段设置默认值等工作），并且把指向新创建对象的引用压到操作数栈顶。此时该引用还不能直接使用，处于未初始化状态（uninitialized）；如果某方法a含有代码试图通过未初始化状态的引用来调用任何实例方法，那么方法a会通不过JVM的字节码校验，从而被JVM拒绝执行。
能对未初始化状态的引用做的唯一一种事情就是通过它调用实例构造器，在Class文件层面表现为特殊初始化方法“<init>”。实际调用的指令是invokespecial，而在实际调用前要把需要的参数按顺序压到操作数栈上。在上面的字节码例子中，压参数的指令包括dup和ldc两条，分别把隐藏参数（新创建的实例的引用，对于实例构造器来说就是“this”）与显式声明的第一个实际参数（&quot;xyz&quot;常量的引用）压到操作数栈上。
在构造器返回之后，新创建的实例的引用就可以正常使用了。</p>
<h1 id="-http-rednaxelafx-iteye-com-blog-652719-">关于构造器的讨论，可以参考我之前的一帖，<a href="http://rednaxelafx.iteye.com/blog/652719" target="_blank">实例构造器是不是静态方法？</a></h1>
<p>以上讨论都只是针对规范所定义的Java语言与Java虚拟机而言。概念上是如此，但实际的JVM实现可以做得更优化，原问题中的代码片段有可能在实际执行的时候一个String实例也不会完整创建（没有分配空间）。
例如说，在x86、Windows Vista SP2、Sun JDK 6 update 14的fastdebug版上跑下面的测试代码：
Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>public class C2EscapeAnalysisDemo {  </li>
<li>private static void warmUp() {  </li>
<li>IFoo[] array = new IFoo[] {  </li>
<li>new FooA(), new FooB(), new FooC(), new FooD()  </li>
<li>};  </li>
<li>for (int i = 0; i &lt; 1000000; i++) {  </li>
<li>array[i % array.length].foo(); // megamorphic callsite to prevent inlining  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>public static void main(String[] args) {  </li>
<li>while (true) {  </li>
<li>warmUp();  </li>
<li>}  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>interface IFoo {  </li>
<li>void foo();  </li>
<li>}  </li>
<li></li>
<li>class FooA implements IFoo {  </li>
<li>public void foo() {  </li>
<li>String s1 = new String(&quot;xyz&quot;);  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>class FooB implements IFoo {  </li>
<li>public void foo() {  </li>
<li>String s1 = new String(&quot;xyz&quot;);  </li>
<li>String s2 = new String(&quot;xyz&quot;);  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>class FooC implements IFoo {  </li>
<li>public void foo() {  </li>
<li>String s1 = new String(&quot;xyz&quot;);  </li>
<li>String s2 = new String(&quot;xyz&quot;);  </li>
<li>String s3 = new String(&quot;xyz&quot;);  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>class FooD implements IFoo {  </li>
<li>public void foo() {  </li>
<li>String s1 = new String(&quot;xyz&quot;);  </li>
<li>String s2 = new String(&quot;xyz&quot;);  </li>
<li>String s3 = new String(&quot;xyz&quot;);  </li>
<li>String s4 = new String(&quot;xyz&quot;);  </li>
<li>}  </li>
<li>}  </li>
</ol>
<p>public class C2EscapeAnalysisDemo {</p>
<p>  private static void warmUp() {
    IFoo[] array = new IFoo[] {</p>
<pre><code>  new FooA(), new FooB(), new FooC(), new FooD()
};

for (int i = 0; i &lt; 1000000; i++) {
  array[i % array.length].foo(); // megamorphic callsite to prevent inlining

}
</code></pre><p>  }</p>
<p>  public static void main(String[] args) {</p>
<pre><code>while (true) {
  warmUp();

}
</code></pre><p>  }</p>
<p>}</p>
<p>interface IFoo {
  void foo();</p>
<p>}</p>
<p>class FooA implements IFoo {
  public void foo() {</p>
<pre><code>String s1 = new String(&quot;xyz&quot;);
</code></pre><p>  }</p>
<p>}</p>
<p>class FooB implements IFoo {
  public void foo() {</p>
<pre><code>String s1 = new String(&quot;xyz&quot;);
String s2 = new String(&quot;xyz&quot;);
</code></pre><p>  }
}</p>
<p>class FooC implements IFoo {</p>
<p>  public void foo() {
    String s1 = new String(&quot;xyz&quot;);</p>
<pre><code>String s2 = new String(&quot;xyz&quot;);
String s3 = new String(&quot;xyz&quot;);
</code></pre><p>  }
}</p>
<p>class FooD implements IFoo {</p>
<p>  public void foo() {
    String s1 = new String(&quot;xyz&quot;);</p>
<pre><code>String s2 = new String(&quot;xyz&quot;);
String s3 = new String(&quot;xyz&quot;);

String s4 = new String(&quot;xyz&quot;);
</code></pre><p>  }</p>
<p>}
照常用javac用默认参数编译，然后先用server模式的默认配置来跑，顺带打出GC和JIT编译日志来看
Command prompt代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>java -server -verbose:gc -XX:+PrintCompilation C2EscapeAnalysisDemo  </li>
</ol>
<p>java -server -verbose:gc -XX:+PrintCompilation C2EscapeAnalysisDemo
看到的日志的开头一段如下：
Hotspot log代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>1       java.lang.String::charAt (33 bytes)  </li>
<li>2       java.lang.Object::<init> (1 bytes)  </li>
<li>3       java.lang.String::<init> (61 bytes)  </li>
<li>1%      C2EscapeAnalysisDemo::warmUp @ 47 (71 bytes)  </li>
<li>4       FooA::foo (11 bytes)  </li>
<li>5       FooB::foo (21 bytes)  </li>
<li>6       FooC::foo (31 bytes)  </li>
<li>7       FooD::foo (42 bytes)  </li>
<li>[GC 3072K-&gt;168K(32768K), 0.0058325 secs]  </li>
<li>[GC 3240K-&gt;160K(32768K), 0.0104623 secs]  </li>
<li>[GC 3232K-&gt;160K(32768K), 0.0027323 secs]  </li>
<li>[GC 3232K-&gt;160K(35840K), 0.0026220 secs]  </li>
<li>[GC 6304K-&gt;160K(35840K), 0.0173733 secs]  </li>
<li>[GC 6304K-&gt;144K(41664K), 0.0059720 secs]  </li>
<li>[GC 12432K-&gt;144K(41664K), 0.0353320 secs]  </li>
<li>[GC 12432K-&gt;144K(54016K), 0.0139333 secs]  </li>
<li>8       C2EscapeAnalysisDemo::warmUp (71 bytes)  </li>
<li>[GC 24720K-&gt;160K(54016K), 0.0697970 secs]  </li>
<li>[GC 24736K-&gt;160K(68800K), 0.0261921 secs]  </li>
<li>[GC 39520K-&gt;160K(68800K), 0.0958433 secs]  </li>
<li>[GC 39520K-&gt;160K(87168K), 0.0433377 secs]  </li>
<li>[GC 57888K-&gt;160K(87168K), 0.0542482 secs]  </li>
<li>[GC 57888K-&gt;148K(87168K), 0.0533140 secs]  </li>
<li>[GC 57876K-&gt;164K(84288K), 0.0533537 secs]  </li>
<li>[GC 55204K-&gt;164K(81728K), 0.0596820 secs]  </li>
<li>[GC 52644K-&gt;164K(79488K), 0.0515090 secs]  </li>
<li>[GC 50212K-&gt;164K(76992K), 0.0491227 secs]  </li>
<li>[GC 47908K-&gt;164K(74944K), 0.0450666 secs]  </li>
<li>[GC 45668K-&gt;164K(72640K), 0.0467671 secs]  </li>
<li>[GC 43556K-&gt;152K(70784K), 0.0420757 secs]  </li>
<li>[GC 41560K-&gt;168K(68736K), 0.0391296 secs]  </li>
<li>[GC 39656K-&gt;168K(67072K), 0.0397539 secs]  </li>
<li><p>[GC 37864K-&gt;188K(65216K), 0.0360861 secs]  </p>
<p>1       java.lang.String::charAt (33 bytes)</p>
<p>2       java.lang.Object::<init> (1 bytes)
3       java.lang.String::<init> (61 bytes)</p>
<p>1%      C2EscapeAnalysisDemo::warmUp @ 47 (71 bytes)
4       FooA::foo (11 bytes)</p>
<p>5       FooB::foo (21 bytes)
6       FooC::foo (31 bytes)</p>
<p>7       FooD::foo (42 bytes)
[GC 3072K-&gt;168K(32768K), 0.0058325 secs]</p>
</li>
</ol>
<p>[GC 3240K-&gt;160K(32768K), 0.0104623 secs]
[GC 3232K-&gt;160K(32768K), 0.0027323 secs]</p>
<p>[GC 3232K-&gt;160K(35840K), 0.0026220 secs]
[GC 6304K-&gt;160K(35840K), 0.0173733 secs]</p>
<p>[GC 6304K-&gt;144K(41664K), 0.0059720 secs]
[GC 12432K-&gt;144K(41664K), 0.0353320 secs]</p>
<p>[GC 12432K-&gt;144K(54016K), 0.0139333 secs]
  8       C2EscapeAnalysisDemo::warmUp (71 bytes)</p>
<p>[GC 24720K-&gt;160K(54016K), 0.0697970 secs]
[GC 24736K-&gt;160K(68800K), 0.0261921 secs]</p>
<p>[GC 39520K-&gt;160K(68800K), 0.0958433 secs]
[GC 39520K-&gt;160K(87168K), 0.0433377 secs]</p>
<p>[GC 57888K-&gt;160K(87168K), 0.0542482 secs]
[GC 57888K-&gt;148K(87168K), 0.0533140 secs]</p>
<p>[GC 57876K-&gt;164K(84288K), 0.0533537 secs]
[GC 55204K-&gt;164K(81728K), 0.0596820 secs]</p>
<p>[GC 52644K-&gt;164K(79488K), 0.0515090 secs]
[GC 50212K-&gt;164K(76992K), 0.0491227 secs]</p>
<p>[GC 47908K-&gt;164K(74944K), 0.0450666 secs]
[GC 45668K-&gt;164K(72640K), 0.0467671 secs]</p>
<p>[GC 43556K-&gt;152K(70784K), 0.0420757 secs]
[GC 41560K-&gt;168K(68736K), 0.0391296 secs]</p>
<p>[GC 39656K-&gt;168K(67072K), 0.0397539 secs]
[GC 37864K-&gt;188K(65216K), 0.0360861 secs]
上面的日志中，后面的方法名的行是JIT编译的日志，而以<a href="&quot;复制代码&quot;">GC开头的是minor GC的日志。
程序一直跑，GC的日志还会不断的打出来。这是理所当然的对吧？HotSpot的堆就那么大，而测试代码在不断新创建String对象，肯定得不断触发GC的。
用不同的VM启动参数来跑的话，
Command prompt代码 [<img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>java -server -verbose:gc -XX:+PrintCompilation -XX:+DoEscapeAnalysis -XX:+EliminateAllocations C2EscapeAnalysisDemo  </li>
</ol>
<p>java -server -verbose:gc -XX:+PrintCompilation -XX:+DoEscapeAnalysis -XX:+EliminateAllocations C2EscapeAnalysisDemo
还是同样的Java测试程序，同样的Sun JDK 6 update 14，但打开了逃逸分析和空间分配消除功能，再运行，看到的全部日志如下：
Hotspot log代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>1       java.lang.String::charAt (33 bytes)  </li>
<li>2       java.lang.Object::<init> (1 bytes)  </li>
<li>3       java.lang.String::<init> (61 bytes)  </li>
<li>1%      C2EscapeAnalysisDemo::warmUp @ 47 (71 bytes)  </li>
<li>5       FooB::foo (21 bytes)  </li>
<li>4       FooA::foo (11 bytes)  </li>
<li>6       FooC::foo (31 bytes)  </li>
<li>7       FooD::foo (42 bytes)  </li>
<li>[GC 3072K-&gt;176K(32768K), 0.0056527 secs]  </li>
<li><p>8       C2EscapeAnalysisDemo::warmUp (71 bytes)  </p>
<p>1       java.lang.String::charAt (33 bytes)</p>
<p>2       java.lang.Object::<init> (1 bytes)
3       java.lang.String::<init> (61 bytes)</p>
<p>1%      C2EscapeAnalysisDemo::warmUp @ 47 (71 bytes)
5       FooB::foo (21 bytes)</p>
<p>4       FooA::foo (11 bytes)
6       FooC::foo (31 bytes)</p>
<p>7       FooD::foo (42 bytes)
[GC 3072K-&gt;176K(32768K), 0.0056527 secs]</p>
<p>8       C2EscapeAnalysisDemo::warmUp (71 bytes)
继续跑下去也没有再打出GC日志了。难道新创建String对象都不吃内存了么？
实际情况是：经过HotSpot的server模式编译器的优化后，FooA、FooB、FooC、FooD四个版本的foo()实现都不新创建String实例了。这样自然不吃内存，也就不再触发GC了。
经过的分析和优化笼统说有方法内联（method inlining）、逃逸分析（escape analysis）、标量替换（scalar replacement）、无用代码削除（dead-code elimination）之类。
FooA.foo()最短，就以它举例来大致演示一下优化的过程。
它其实就是创建并初始化了一个String对象而已。调用的构造器的源码是：
Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>public String(String original) {  </p>
</li>
<li>int size = original.count;  </li>
<li>char[] originalValue = original.value;  </li>
<li>char[] v;  </li>
<li>if (originalValue.length &gt; size) {  </li>
<li>// The array representing the String is bigger than the new  </li>
<li>// String itself.  Perhaps this constructor is being called  </li>
<li>// in order to trim the baggage, so make a copy of the array.  </li>
<li>int off = original.offset;  </li>
<li>v = Arrays.copyOfRange(originalValue, off, off+size);  </li>
<li>} else {  </li>
<li>// The array representing the String is the same  </li>
<li>// size as the String, so no point in making a copy.  </li>
<li>v = originalValue;  </li>
<li>}  </li>
<li>this.offset = 0;  </li>
<li>this.count = size;  </li>
<li>this.value = v;  </li>
<li>}  </li>
</ol>
<p>public String(String original) {</p>
<pre><code>int size = original.count;
char[] originalValue = original.value;

char[] v;
if (originalValue.length &gt; size) {

   // The array representing the String is bigger than the new
   // String itself.  Perhaps this constructor is being called

   // in order to trim the baggage, so make a copy of the array.
  int off = original.offset;

  v = Arrays.copyOfRange(originalValue, off, off+size);
} else {

   // The array representing the String is the same
   // size as the String, so no point in making a copy.

  v = originalValue;
}

this.offset = 0;
this.count = size;

this.value = v;
</code></pre><p>}
因为参数是&quot;xyz&quot;，可以确定在我们的测试代码里不会走到构造器的if分支里，下面为了演示方便就省略掉那部分代码（实际代码还是存在的，只是没执行而已）
Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>public String(String original) {  </li>
<li>int size = original.count;  </li>
<li>char[] originalValue = original.value;  </li>
<li>char[] v;  </li>
<li>if (originalValue.length &gt; size) {  </li>
<li>// 省略  </li>
<li>} else {  </li>
<li>v = originalValue;  </li>
<li>}  </li>
<li>this.offset = 0;  </li>
<li>this.count = size;  </li>
<li>this.value = v;  </li>
<li>}  </li>
</ol>
<p>public String(String original) {</p>
<pre><code>int size = original.count;
char[] originalValue = original.value;

char[] v;
if (originalValue.length &gt; size) {

   // 省略
} else {

  v = originalValue;
}

this.offset = 0;
this.count = size;

this.value = v;
</code></pre><p>}
那么把构造器内联到FooA.foo()里，
Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>public FooA implements IFoo {  </li>
<li>public void foo() {  </li>
<li>String s = AllocateString(); // 这里虚构一个只分配空间，不调用构造器的函数  </li>
<li>String original = &quot;xyz&quot;;  </li>
<li></li>
<li>// 下面就是内联进来的构造器内容  </li>
<li>int size = original.count;  </li>
<li>char[] originalValue = original.value;  </li>
<li>char[] v;  </li>
<li>if (originalValue.length &gt; size) {  </li>
<li>// 省略  </li>
<li>} else {  </li>
<li>v = originalValue;  </li>
<li>}  </li>
<li></li>
<li>s.offset = 0;  </li>
<li>s.count = size;  </li>
<li>s.value = v;  </li>
<li>}  </li>
<li>}  </li>
</ol>
<p>public FooA implements IFoo {</p>
<p>  public void foo() {
    String s = AllocateString(); // 这里虚构一个只分配空间，不调用构造器的函数</p>
<pre><code>String original = &quot;xyz&quot;;


// 下面就是内联进来的构造器内容
int size = original.count;

char[] originalValue = original.value;
char[] v;

if (originalValue.length &gt; size) {
   // 省略

} else {
  v = originalValue;

}


s.offset = 0;
s.count = size;

s.value = v;
</code></pre><p>  }</p>
<p>}
然后经过逃逸分析与标量替换，
Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>public FooA implements IFoo {  </li>
<li>public void foo() {  </li>
<li>String original = &quot;xyz&quot;;  </li>
<li></li>
<li>// 下面就是内联进来的构造器内容  </li>
<li>int size = original.count;  </li>
<li>char[] originalValue = original.value;  </li>
<li>char[] v;  </li>
<li>if (originalValue.length &gt; size) {  </li>
<li>// 省略  </li>
<li>} else {  </li>
<li>v = originalValue;  </li>
<li>}  </li>
<li></li>
<li>// 原本s的实例变量被标量替换为foo()的局部变量  </li>
<li>int sOffset = 0;  </li>
<li>int sCount = size;  </li>
<li>char[] sValue = v;  </li>
<li>}  </li>
<li>}  </li>
</ol>
<p>public FooA implements IFoo {</p>
<p>  public void foo() {
    String original = &quot;xyz&quot;;</p>
<pre><code>// 下面就是内联进来的构造器内容

int size = original.count;
char[] originalValue = original.value;

char[] v;
if (originalValue.length &gt; size) {

   // 省略
} else {

  v = originalValue;
}


// 原本s的实例变量被标量替换为foo()的局部变量

int sOffset = 0;
int sCount = size;

char[] sValue = v;
</code></pre><p>  }</p>
<p>}
注意，到这里就已经把新创建String在堆上分配空间的代码全部削除了，原本新建的String实例的字段变成了FooA.foo()的局部变量。
最后再经过无用代码削除，把sOffset、sCount和sValue这三个没被读过的局部变量给削除掉，
Java代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>public FooA implements IFoo {  </li>
<li>public void foo() {  </li>
<li>String original = &quot;xyz&quot;;  </li>
<li></li>
<li>// 下面就是内联进来的构造器内容  </li>
<li>int size = original.count;  </li>
<li>char[] originalValue = original.value;  </li>
<li>char[] v;  </li>
<li>if (originalValue.length &gt; size) {  </li>
<li>// 省略  </li>
<li>} else {  </li>
<li>v = originalValue;  </li>
<li>}  </li>
<li></li>
<li>// 几个局部变量也干掉了  </li>
<li>}  </li>
<li>}  </li>
</ol>
<p>public FooA implements IFoo {</p>
<p>  public void foo() {
    String original = &quot;xyz&quot;;</p>
<pre><code>// 下面就是内联进来的构造器内容

int size = original.count;
char[] originalValue = original.value;

char[] v;
if (originalValue.length &gt; size) {

   // 省略
} else {

  v = originalValue;
}


// 几个局部变量也干掉了
</code></pre><p>  }
}
这就跟FooA.foo()被优化编译后实际执行的代码基本一致了。
实际执行的x86代码如下：
X86 asm代码 <a href="&quot;复制代码&quot;"><img src="" alt="复制代码"></a> <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>0x0247aeec: mov    %eax,-0x4000(%esp) ; 检查栈是否溢出（stack bang），若溢出则这条指令会引发异常  </li>
<li>0x0247aef3: push   %ebp               ; 保存老的栈帧指针  </li>
<li>0x0247aef4: sub    $0x18,%esp         ; 为新栈帧分配空间  </li>
<li>0x0247aefa: mov    $0x1027e9a8,%edi   ; String original //<em> EDI /</em>/ = &quot;xyz&quot;  </li>
<li>0x0247aeff: mov    0x8(%edi),%ecx     ; char[] originalValue //<em> ECX /</em>/ = original.value;  </li>
<li>0x0247af02: mov    0x8(%ecx),%ebx     ; EBX = originalValue.length  </li>
<li>0x0247af05: mov    0x10(%edi),%ebp    ; int size //<em> EBP /</em>/ = original.count;  </li>
<li>0x0247af08: cmp    %ebp,%ebx          ; 比较originalValue.length与size  </li>
<li>0x0247af0a: jg     0x0247af17         ; 如果originalValue.length &gt; size则跳转到0x0247af17  </li>
<li>;   实际不会发生跳转（就是不会执行if分支），所以后面代码省略  </li>
<li>0x0247af0c: add    $0x18,%esp         ; 撤销栈帧分配的空间  </li>
<li>0x0247af0f: pop    %ebp               ; 恢复老的栈帧指针  </li>
<li>0x0247af10: test   %eax,0x310000      ; 方法返回前检查是否需要进入safepoint （{poll_return}）  </li>
<li>0x0247af16: ret                       ; 方法返回  </li>
<li>0x0247af17: ; 以下是if分支和异常处理器的代码，因为实际不会执行，省略  </li>
</ol>
<p>0x0247aeec: mov    %eax,-0x4000(%esp) ; 检查栈是否溢出（stack bang），若溢出则这条指令会引发异常</p>
<p>0x0247aef3: push   %ebp               ; 保存老的栈帧指针
0x0247aef4: sub    $0x18,%esp         ; 为新栈帧分配空间</p>
<p>0x0247aefa: mov    $0x1027e9a8,%edi   ; String original //<em> EDI /</em>/ = &quot;xyz&quot;
0x0247aeff: mov    0x8(%edi),%ecx     ; char[] originalValue //<em> ECX /</em>/ = original.value;</p>
<p>0x0247af02: mov    0x8(%ecx),%ebx     ; EBX = originalValue.length
0x0247af05: mov    0x10(%edi),%ebp    ; int size //<em> EBP /</em>/ = original.count;</p>
<p>0x0247af08: cmp    %ebp,%ebx          ; 比较originalValue.length与size
0x0247af0a: jg     0x0247af17         ; 如果originalValue.length &gt; size则跳转到0x0247af17</p>
<pre><code>                                  ;   实际不会发生跳转（就是不会执行if分支），所以后面代码省略
</code></pre><p>0x0247af0c: add    $0x18,%esp         ; 撤销栈帧分配的空间</p>
<p>0x0247af0f: pop    %ebp               ; 恢复老的栈帧指针
0x0247af10: test   %eax,0x310000      ; 方法返回前检查是否需要进入safepoint （{poll_return}）</p>
<p>0x0247af16: ret                       ; 方法返回
0x0247af17: ; 以下是if分支和异常处理器的代码，因为实际不会执行，省略
看，确实没有新创建String对象了。
另外三个版本的foo()实现也是类似，HotSpot成功的把无用的new String(&quot;xyz&quot;)全部干掉了。
关于逃逸分析的例子，可以参考我以前一篇帖，<a href="http://rednaxelafx.iteye.com/blog/659108" target="_blank">HotSpot 17.0-b12的逃逸分析/标量替换的一个演示</a></p>
<h1 id="-fooa-foo-string-">再回头看看楼主的原问题，问题中的代码片段执行的时候（对应到FooA.foo()被调用的时候）一个String对象也没有新建。于是那“标准答案”在现实中的指导意义又有多少呢？</h1>
<p>另外，楼主还提到了PermGen：
QM42977 写道</p>
<p>&quot;xyz&quot;在perm gen应该还会生成一个对象，因为常量(&quot;xyz&quot;)都会保存在perm gen中
这里也是需要强调一点：永生代（“Perm Gen”）只是Sun JDK的一个实现细节而已，Java语言规范和Java虚拟机规范都没有规定必须有“Permanent Generation”这么一块空间，甚至没规定要用什么GC算法——不用分代式GC算法哪儿来的“永生代”？
HotSpot的PermGen是用来实现Java虚拟机规范中的“<strong>方法区</strong>”（method area）的。如果使用“方法区”这个术语，在讨论概念中的JVM时就安全得多——大家都必须实现出这个表象。
当然如何实现又是另一回事了。Oracle JRockit没有PermGen，IBM J9也没有，事实上有这么一块空间特别管理的反而是少数吧orz
事实上新版HotSpot VM也在计划去除PermGen，转而使用native memory来实现方法区存储元数据。在JDK8的HotSpot VM中已经实现了这点。</p>
<h1 id="-http-rednaxelafx-iteye-com-blog-905273-http-rednaxelafx-iteye-com-blog-905273-">可以参考这帖：<a href="http://rednaxelafx.iteye.com/blog/905273" target="_blank"><a href="http://rednaxelafx.iteye.com/blog/905273">http://rednaxelafx.iteye.com/blog/905273</a></a></h1>
<p>费那么多口舌，最后点题：请别再拿“String s = new String(&quot;xyz&quot;);创建了多少个String实例”来面试了吧，既没意义又不涨面子。
困，睡觉去……<img src="" alt=""></p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/JVM/">JVM</a></li></span></span> | <span class="tags">Tagged <a href="/tags/JVM/" class="label label-primary">JVM</a><a href="/tags/Java&J2EE/" class="label label-success">Java&J2EE</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:42"datetime="2014-03-07 09:54:42"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-JVM--请别再拿“StringsnewString-xyz-创建了多少个String实例”来/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-JVM--请别再拿“StringsnewString-xyz-创建了多少个String实例”来" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--豆列：从表到里学习JVM实现/">豆列：从表到里学习JVM实现</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:42.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--豆列：从表到里学习JVM实现/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-jvm-">豆列：从表到里学习JVM实现</h1>
<p>刚写了个学习JVM用的豆列跟大家分享。
豆列地址：<a href="http://book.douban.com/doulist/2545443/" target="_blank"><a href="http://book.douban.com/doulist/2545443/">http://book.douban.com/doulist/2545443/</a></a>
下面把豆列的介绍贴过来。具体书单请到上面的豆列地址那边去看。
在社会化分工、软件行业细分专业化的趋势下，会真的参与到底层系统实现的人肯定是越来越少（比例上说）。真的会参与到JVM实现的人肯定是少数。
但如果您对JVM是如何实现的有兴趣、充满好奇，却苦于没有足够系统的知识去深入，那么这个豆列就是为您打好基础而准备的。
如果只想用用Java用用JVM，对深入到实现细节无甚兴趣的话，这个豆列就请不必参考了，免得浪费钱浪费时间精力，呵呵 :-)
本豆列的脉络是：</p>
<ol>
<li>JVM与Java语言规范
要了解JVM是如何实现的，首先必须要知道JVM到底是什么、不是什么，表面上应该提供怎样的功能。为此，JVM规范必读，而且应该时常放在手边参考。
而JVM的主要服务对象是Java编程语言。虽然JVM也可以支持众多其它语言，但JVM里的“J”仍然最重要，Java的语言特性影响了JVM的原始设计，所以Java语言规范也应该阅读。特别是，JVM关于线程和同步相关的规定都是交由Java语言规范的相关章节定义的。</li>
<li>虚拟机概论
这里选取《Virtual Machines: Versatile Platforms for Systems and Processes》，帮助您了解“虚拟机”一词到底指代什么，有什么不同类型，大概有哪些实现方法，等等。读完这本书有助获得一个清晰的大局观。</li>
<li>为Java程序员从用户的角度介绍JVM的使用经验的几本书
虽然这几本并没有深入到JVM实现的非常细节的角落，但对已经习惯用Java语言编程的程序员来说，有这么几本书带领自己从熟悉的领域进入不熟悉的领域总是件好事。
这几本书中，最深入JVM内部的是《Oracle JRockit: The Definitive Guide》；有丰富调优建议的是《Java Performance》；结合实现大概介绍JVM的抽象概念的是周志明的《深入理解Java虚拟机》。</li>
<li>虚拟机的入门级实现
先通过《Language Implementation Patterns》了解编程语言的一些入门级实现方式，把高级语言编译器与虚拟机两个概念联系起来。
然后通过《プログラミング言語を作る》了解非常简易的、用树遍历式以及字节码式解释器实现虚拟机大概是个怎么回事。虽然这本书没有实现JVM，但它介绍的Diksam与早期JVM的实现颇有相似之处，可参考。
接下来《深入嵌入式Java虚拟机》介绍了一种实际的JVM——KVM的实现细节。KVM是CLDC的参考实现（RI）里的JVM，结构简单，资源消耗小，适合入门阅读。
这部分最后是《The School of Niklaus Wirth》，里面有一章介绍了HotSpot Client Compiler (C1)的原始设计思路。这是个非常简单、但相对来说性能还不错的JIT编译器，可用于对JIT编译器的基本了解。这本书本身就很赞，不为学习虚拟机也可以一读。
需要注意的是从“简易的JVM实现”到“高性能、复杂的JVM实现”跨度非常大；前者的许多部分的实现方式与后者相当不同。先从简易的实现开始入手主要是为了对JVM里大概都有些什么组件有所了解。但如果目标是了解高性能JVM的实现，那就必须在GC、编译原理方面打下更好的基础，重新洗一次脑。</li>
<li>C++基础书
下面要开始逐渐深入JVM的内部实现，如果没有良好的C或（与？）C++基础会比较吃力。虽然也有几乎完全用Java语言实现的高性能JVM，例如Maxine VM与Jikes RVM，但它们都是研究性质的；商用JVM实现仍然是C与C++的天下。
这里我先推荐C++之父自己写的那本书来入门。虽然BS巨巨后来还出过本新书，而近来也渐渐开始有介绍C++11的入门书，但实际上现在多数JVM实现用的还是C99或非常古老的C++（连C++03都不一定用到了），所以用这本老书应该就够了。
然后通过《深度探索C++对象模型》来学习C++对象模型的常见实现方式。这对后面理解Java对象模型的实现很有帮助。</li>
<li>GC与编译原理的入门书
GC书总共就那么几本，倒也没啥可挑的。《The Garbage Collection Handbook》是绝对必读。
编译原理的书就稍微尴尬些。现有的编译原理书大都针对静态编译器、针对像C或C++那样的偏静态、偏native的语言。我还没读到过什么编译原理书是专门介绍JIT编译器或者说动态编译器的。静态与动态编译器会有些取舍上、实现策略上的差异，不过还好其核心的原理都是一样的，所以还是可以推荐几本书。龙书用来最初入门，鲸书用来补充一些优化相关的知识，EAC第二版用来学习编译器一种比较良好的逻辑组织方式，最后学一下针对现代机器的优化。</li>
<li>介绍计算机体系结构的书
实际JVM实现里，如果有JIT编译器或者动态编译器那它们的编译目标多半是底层机器的机器码。这就涉及到计算机体系结构了。
如果您只对Java语言和抽象的JVM有一定了解，那可以用《计算机组成及汇编语言原理》来入门。这本书比较奇葩，用JVM的字节码指令集来当作真实机器介绍体系结构的概念。我并不太喜欢这本书，但感觉它对有Java背景的初学者来说应该有点用。要注意的是千万别只读这本书来入门，请结合下面要介绍的一本书来重新洗一次脑。
如果对C或C++已经有所了解，那《深入理解计算机系统》（CSAPP）是计算机体系结构入门的最适合的书了。</li>
<li>进一步阅读
到此为止各种抽象概念应该都了解得差不多了。那么要在真实的机器上实现高性能JVM，就必须要对真实机器的指令集细节有所了解。x86/x86-64、SPARC、ARM、MIPS，要在哪个平台上做高性能实现就要学习哪个平台的指令集及指令级别优化技巧。这里就不具体推荐书了。
操作系统层面的知识同样重要。像是说JVM要实现线程、内存分配啥的，都可能要跟系统调用或CRT对系统调用的包装打交道。这部分也需要另外找书来读。我回头再考虑下要不要加几本道这个豆列里来。
另外，从80年代开始高级语言虚拟机的实现技术有了突飞猛进的发展，但却没有专门的书对这个领域做综述和导读。多数有用的资料其实还是在论文里。光靠读书是远远不够用的，论文这块也请关注。<h1 id="-http-rednaxelafx-iteye-com-blog-362738-http-rednaxelafx-iteye-com-blog-362738-">顺便广告一下：我的博客里关于虚拟机的文章也推荐给大家参考：<a href="http://rednaxelafx.iteye.com/blog/362738" target="_blank"><a href="http://rednaxelafx.iteye.com/blog/362738">http://rednaxelafx.iteye.com/blog/362738</a></a></h1>
这个豆列没有漏掉 <a href="http://book.douban.com/subject/1788390/" target="_blank">《Inside the Java Virtual Machine, Second Edition》</a> ，中文版<a href="http://book.douban.com/subject/1138768/" target="_blank">《深入Java虚拟机(原书第2版)》</a>，只是我现在已经不再推荐它。这本书刚出版的时候确实引起了一番学习Java虚拟机的热潮，但其部分内容从现在的角度看已经过时，特别是涉及JVM实现的部分。像火车算法什么的现在已经没有JVM实现使用。不过话说回来，了解了解这些过时的信息也没什么不好，前提是能自己分辨清楚哪些信息是适用于现在的JVM的，而哪些已经成为了历史。</li>
</ol>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/JVM/">JVM</a></li></span></span> | <span class="tags">Tagged <a href="/tags/JVM/" class="label label-primary">JVM</a><a href="/tags/Java&J2EE/" class="label label-success">Java&J2EE</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:42"datetime="2014-03-07 09:54:42"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-JVM--豆列：从表到里学习JVM实现/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-JVM--豆列：从表到里学习JVM实现" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--记录帖：碰到的一些Java问题（更新于2013-03-06）/">记录帖：碰到的一些Java问题（更新于2013</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:42.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-JVM--记录帖：碰到的一些Java问题（更新于2013-03-06）/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-java-2013-03-06-">记录帖：碰到的一些Java问题（更新于2013-03-06）</h1>
<h1 id="-bluedavy-blog-https-blog-bluedavy-com-"><a href="https://blog.bluedavy.com/" target="_blank">BlueDavy之技术blog</a></h1>
<p>{互联网，OSGi，Java, High Scalability, High Performance,HA}</p>
<ul>
<li><a href="https://blog.bluedavy.com/" target="_blank">Home</a></li>
<li><a href="https://blog.bluedavy.com/?page_id=2" target="_blank">About</a></li>
<li><a href="https://blog.bluedavy.com/?page_id=81" target="_blank">Photos</a></li>
</ul>
<h2 id="-java-2013-03-06-https-blog-bluedavy-com-p-300-java-2013-03-06-"><a href="https://blog.bluedavy.com/?p=300" title="记录帖：碰到的一些Java问题（更新于2013-03-06）" target="_blank">记录帖：碰到的一些Java问题（更新于2013-03-06）</a></h2>
<p>Aug 09</p>
<p><a href="http://bluedavy.com/" title="Visit bluedavy’s website" target="_blank">bluedavy</a><a href="https://blog.bluedavy.com/?cat=63" title="View all posts in Java" target="_blank">Java</a>, <a href="https://blog.bluedavy.com/?cat=13" title="View all posts in jvm" target="_blank">jvm</a> <a href="https://blog.bluedavy.com/?tag=btrace" target="_blank">btrace</a>, <a href="https://blog.bluedavy.com/?tag=java-cases" target="_blank">Java Cases</a>, <a href="https://blog.bluedavy.com/?tag=java-troubleshooting" target="_blank">Java Troubleshooting</a>, <a href="https://blog.bluedavy.com/?tag=java%e9%97%ae%e9%a2%98" target="_blank">Java问题</a> <a href="&quot;Comment on 记录帖：碰到的一些Java问题（更新于2013-03-06）&quot;">11 Comments</a>
这个贴用于记录自己碰到过的一些Java问题，会根据经验不断增加，以便总结，:)</p>
<p>case: 一次非常诡异的CMS GC频繁问题的排查
详细见此贴：<a href="https://bluedavy.com/?p=424" target="_blank"><a href="https://bluedavy.com/?p=424">https://bluedavy.com/?p=424</a></a></p>
<p>case: 某应用在压测一台物理机上的多台虚拟机时不能保持线性增长的案例
现象描述：
一台16 core（HT）的物理机上，创建了8个虚拟机，每个虚拟机独占两个core，每个虚拟机里部署的都是同样的应用，按道理来说，在应用没有瓶颈的情况下，每增加一台虚拟机，tps应该可以保持线性增长，不过在压测的时候发现，在增加到第四台的时候（每次4台挑选的都是不同的机器），有些时候能线性增长，有些时候不能。
解决过程：
1、经过手工调整其中某台虚拟机的cpu，发现在12/13 cpu加入时，整个tps就会下降，于是猜想莫非和这两个核还有关系；
2、猜测是和中断处理有关系，发现core 12处理的中断确实比较其他的多一些，于是把irqbalance关了，调整了中断的绑定，还是一样的现象；
3、看了下四台虚拟机绑定的cpu的分布状况，发现12/13刚好和其中一台虚拟机绑定的4/5是同样的两个core，4/12其实是同一个core HT的，5/13是另一个core HT的，而这个应用是很耗cpu的，单压某个虚拟机cpu us就可以到90%左右，所以如果压测的4台如果有CPU刚好是同一个Core HT的，性能自然是上不去的。
总结：
和各种文章中讲的一样，CPU HT只有在理论的某些场景能达到2个真实core的性能，但多数情况都达不到，貌似很多场景的经验值是2 core(HT) = 1.3 Core。</p>
<p>case: 一个Java应用频繁抛异常导致cpu us诡异现象的案例
详细见此贴：<a href="http://blog.bluedavy.com/?p=409" target="_blank"><a href="http://blog.bluedavy.com/?p=409">http://blog.bluedavy.com/?p=409</a></a></p>
<p>case: 某应用在运行个一两天后就会把物理内存耗光
解决过程：
1、先按经验查了下有没有错误使用Inflater和Deflater，没有，于是继续；
2、继续上perftools，看看到底什么原因造成的，结果在6u21版本上看到的很诡异，是JVM_handle_linux_signal占了最多，觉得不靠谱，于是先升级成了6u26；
3、再分析，看到os::malloc占用了最多，但其他的就完全没头绪了；
4、在@JosephWang_CN的帮助下，图形分析下了perftools的stack trace，才发现还是unsafe_allocate的地方，但这次现象和上个case不同，不同点在于这次是由于cms gc的bug造成的，bug id为7112034，这个bug会造成即使direct bytebuffer已经无引用了，但在cms gc时其并不会被清除掉，而要等到full gc才会清除，官方版本在6u32中修复此bug（这个很容易验证，如果没开启ExplicitGCInvokesConcurrent，用jmap -histo:live强制触发下）；
5、在fix了这个bug的前提下，还需要限制-XX:MaxDirectMemorySize的大小才行，否则可能会出现还没到触发cms gc时，物理内存就用完了的现象。
总结：
根据多次排查Java Heap外内存泄露的问题，目前的经验为：
1、先查查看有没有错误使用Inflater和Deflater，如有则基本就搞定了；
2、多执行几次jmap -histo:live，看看内存会不会下降，如果会的话，多数和GC的bug有关；
3、perftools，对调用次数的那列进行排序(pprof –text … | sort -n -r -k4)，如果看到是Unsafe_Allocate比较多，且为server端应用，则通常说明是哪个地方分配了Direct ByteBuffer，但来不及释放引用，然后嘛，就是用btrace跟踪下看看谁干的，分析原因。</p>
<p>case: 某应用在压测一段时间后就会把物理内存耗光
解决过程：
1、从gc log以及jstat信息来看，java heap内的内存消耗并不多，但堆外消耗非常严重，导致了物理内存被耗光；
2、于是装上google perftools，看看堆外到底是什么原因造成的消耗；
3、分析了下google perftools的内存malloc消耗，主要是调用Unsafe.allocate造成的；
4、通常调用Unsafe.allocateMemory来分配内存的，只有Direct ByteBuffer和AWT，这应用是没用AWT的，Direct ByteBuffer倒是用到了；
5、网上google了一会，找到一个貌似和这个应用的场景很像的内存泄露的现象，具体信息请见：<a href="http://t.co/S9jvDt8O" title="SocketChannel.write Direct ByteBuffer memory leak" target="_blank"><a href="http://t.co/S9jvDt8O">http://t.co/S9jvDt8O</a></a>，号称是SocketChannel.write的时候，如果是Direct ByteBuffer会导致memory leak，而且Trustin Lee(Mina/Netty的作者)也这么说的：”it’s a known bug”;
6、于是建议应用的同学将ByteBuffer的地方改成不用direct方式；
7、改完后，重新压测，物理内存消耗是没那么严重了，但java heap用满了后回收不了了；
8、于是dump内存，用mat分析后发现是由于这个应用本身处理上的一些缺失造成的，简单说下，这个应用是一个基于mina的应用，而应用没有对session上的发送请求做限流，而mina来不及发送，导致积压了很多WriteRequest，从而内存被耗光了；
9、对这个问题的解决方法是：限流，当未发送的字节数到达某个比率后，就暂时先不发送了，或者报错等等，用netty能对这个现象有一定的缓解，但限流动作还是要做，否则可能会出现接收方处理慢，从而导致发送方内存用完的现象。</p>
<p>case: 某应用在压测时很容易出现promotion failed的现象
解决过程：
1、从promotion failed时的gc日志来看，状况为新生代中有1.5g的对象存活，旧生代此时的空余空间为4g，足以放下新生代存活的这些对象，于是只能猜测可能是cms gc的情况下旧生代的碎片问题导致的，其实心里是不太相信的，因为这空间空闲了如此的多呀；
2、首先增加-XX:+PrintPromotionFailure看看Promotion Failed的时候是不是有很大的对象要晋升到旧生代，结果打出来的日志显示在晋升的时候失败的竟然只是申请262146个block的空间而已，这是在开启了压缩指针的情况，因此每个block为4个字节；
3、还是不能确定，于是增加-XX:+CMSDumpAtPromotionFailure，看看OLD Gen的碎片状况；
4、打出来的信息显示old gen拥有最多free block的chunk也只有99977个而已，有53w+个chunk，里面大部分都只有999个free block，可见碎片相当严重；
5、到这步只是确定了碎片很严重，暂时能想到的只有每天半夜的时候主动执行下jmap -histo:live，尽可能减少碎片吧，如果后续有什么改进的动作，再来记录。</p>
<p>case: 某应用在发布的过程中突然crash了几台
解决过程：
1、应用crash后hs_err/*.log以及core.[pid]文件都没生成；
2、先打开core dump;
3、crash后gdb core dump看：
<a href="">?</a>1</p>
<p>2
3</p>
<p>4
(gdb) bt</p>
<p>/#0  0x00002ba466f82971 in ?? () from /opt/jdk-1.6.0_26/jre/lib/amd64/server/libjvm.so
/#1  0x00002aab78a7e20d in Java_java_net_SocketOutputStream_socketWrite0 ()</p>
<p>from /opt/jdk-1.6.0_26/jre/lib/amd64/libnet.so</p>
<p>4、看到上面的core dump完全木有头绪，后来@rednaxelafx 介入处理，才知道原来jstack是可以跟core dump文件提取出当时java程序的状况的；
5、jstack出来一看，发现程序里有个地方无限递归…so…
总结：
@rednaxelafx接着又进一步分析了为什么没有生成hs_err/<em>.log，是因为从jdk 5.0以后的版本，hs_err/</em>.log就是在crash的那个线程来生成，而这个案例中crash时的那个线程无限递归，而且正在native栈上，栈空间被消耗光了，所以hs_err/*.log文件就没生成出来。</p>
<p>Case: 某应用偶尔会出现极为频繁的Promotion failed，导致cms gc切换为串行full gc，从而响应变得超级慢
解决过程：
1、从promotion failed的日志来看，应该是在那段时间内内存被消耗光了造成的，因此在promotion failed的时候dump了内存；
2、可惜dump出来的那个内存文件打不开，几次都是如此；
3、还好我们自己定制的jdk版本这个时候发挥了作用，这个版本中有个功能是如果代码中有地方分配了超级大的数组，会打印出堆栈；
4、在某次出问题的时候，我们看到了这样的堆栈信息：
<a href="">?</a>1</p>
<p>2
3</p>
<p>4
5</p>
<p>6
7</p>
<p>8
9</p>
<p>10
11</p>
<p>12
13==WARNNING==  allocating large array: thread_id[0x00002aaac2d85800], thread_name[ajp-0.0.0.0-8009-48], array_size[782611408 bytes], array_length[195652847 el</p>
<p>ememts]</p>
<p>at java.util.Arrays.copyOf(Arrays.java:2734)</p>
<p>at java.util.ArrayList.ensureCapacity(ArrayList.java:167)</p>
<p>at java.util.ArrayList.add(ArrayList.java:351)</p>
<p>at net.sf.json.JSONArray._fromJSONTokener(JSONArray.java:1154)</p>
<p>at net.sf.json.JSONArray.fromObject(JSONArray.java:147)</p>
<p>at net.sf.json.util.JSONTokener.nextValue(JSONTokener.java:358)</p>
<p>at net.sf.json.JSONObject._fromJSONTokener(JSONObject.java:1128)</p>
<p>at net.sf.json.JSONObject._fromString(JSONObject.java:1317)</p>
<p>at net.sf.json.JSONObject.fromObject(JSONObject.java:185)</p>
<p>at net.sf.json.JSONObject.fromObject(JSONObject.java:154)</p>
<p>at 我们自己的代码...</p>
<p>5、有这个堆栈后就可以知道是由于自己的代码这个地方触发了json创建了一个巨大的array；
6、于是怀疑是我们传给了json一个很大的String，就先在应用层做了个保护，超过一定大小的String就直接抛错；
7、加上了这个保护后还是出问题了；
8、因此怀疑是json内部有bug，导致传了某种格式的String后就会出现死循环什么的；
9、“神”看代码后，构造了一个这样的String s = “{tag:[0,1,”;然后调用JSONObject.fromObject(s)，就会OOM；
10、于是修改了json的代码，修复此bug…</p>
<p>Case: 某应用cms gc时concurrent-mark阶段应用竟然没有响应…
解决过程：
1、在cms gc进行的过程中用pstack采集目前java进程正在做什么；
2、从日志分析来看貌似是在concurrent-mark时，很多的java线程在分配内存的时候被锁住了…
3、将相关信息发给官方的gc dev maillist，只是得到了升级到6u28试试的建议…
目前问题尚未解决，先在此mark下，和这个url提到的问题基本一致：<a href="http://t.co/EU92I8nN" target="_blank"><a href="http://t.co/EU92I8nN">http://t.co/EU92I8nN</a></a></p>
<p>Case: 某应用cms gc非常频繁，并且很容易出现concurrent mode failure造成Full GC
解决过程：
1、从gc日志来看，cms gc每次在旧生代使用才到18%左右的时候就触发了，而设置的触发比率是80%，并且不允许JVM自行触发；
2、每几次cms gc还会偶尔出现concurrent mode failure的现象，看了下，这时旧生代的空间是非常充足的；
3、根据cms gc的触发机制，猜测是permGen的问题造成的，于是通过jstat -gcutil看了下permGen的占用比例，果然过一会就超过下92%（不过这里有个问题，就是permGen其实是还没达到MaxPermSize的，看来在cms gc的情况下，maxPermSize要采用不同策略）；
4、于是适当的调大permGen，不过仍然没有解决，原因是permGen增长实在太快了；
5、应用方发现有地方会不断的创建classLoader，加载class，因此导致了permGen的增长，修改后问题解决。
总结：
CMS GC的日志其实打的有些问题，应该把cms gc触发时的原因输出下；
另外就是在大部分情况下，只要不是cms gc触发的比例设置的太有问题，如果cms gc频繁或full gc频繁都是应用本身的问题造成的。</p>
<p>Case: 某应用出现启动后集群中部分node成功，部分node失败
解决过程：
1、失败的node抛出的是NoClassDefFoundError，这些node在环境上和应用包上是完全一致的，因此猜想是classloader装载class时出现了什么问题；
2、在启动参数上增加了-XX:+TraceClassLoading，想看看成功的node和失败的node是不是从第一个地方加载的相应的类，悲催的是成功的node加上了这参数后启动超慢，于是只好放弃；
3、由于不能用TraceClassLoading，只好从ClassLoader方面来跟踪这个类的加载，于是从应用层上做了相应的分析，找出了相应的classloader，然后用btrace相应的进行了跟踪，才终于发现成功的node和失败的node装载此类时不是从同一地方装载的，而其中有一个地方的这个类引用了一个不存在的类，于是就出现了NoClassDefFoundError。
总结：
在经过分析后，猜想是在这两个不同的node上classloader在list一个目录下的文件时，出现了顺序不同的现象，于是后来写了一个简单的程序在两个node上list那个目录的文件，发现返回的顺序果然不同，这个具体的原因为File.listFiles最后会调用到readdir函数，而这个函数返回的文件列表是按inode number排序的，因此在每台linux机器上确实有可能不同，当一个目录下有两个jar中有相同名字但不同内容的class时（话说这也是java应用中比较麻烦的问题，这个专门写篇blog来说下，java 8的模块化真的非常重要），就悲催了，一个保护做法是在实现classloader时，最好是先对listFiles排下序，避免集群中node出现表现不一致的问题。</p>
<p>Case: 某应用GC频繁但不一直不抛OOM的问题
解决过程：
这个应用是期待在内存不够的情况下快速抛出OOM的，但在执行中却发现执行了4个多小时的Full GC，就是没有抛OOM，导致应用出现了问题，从GC代码来看，目前要比较快的触发OOM，只能是调整GCTimeLimit和GCHeapFreeLimit，不过都不好调，后来暂时是靠调整了GCHeapFreeLimit来帮助快速抛出OOM。</p>
<p>Case: 某应用堆外内存泄露的bug
具体解决过程可参考这篇blog：<a href="http://blog.bluedavy.com/?p=205" title="两个OOM Cases" target="_blank"><a href="http://blog.bluedavy.com/?p=205">http://blog.bluedavy.com/?p=205</a></a>和<a href="http://goo.gl/mYsV5" title="里面有关于google perftools安装的说明" target="_blank">这篇blog</a>。
总结：
堆外内存泄露基本就是靠google perf-tools来查找了，目前来看堆外内存泄露基本都是使用Deflater，却没有显式调用end造成的。</p>
<p>Case: 某应用压测时压力上不去的问题
解决过程：
1、查看压测的目标服务器的cpu、网卡流量，发现都没到瓶颈；
2、继续查看压测的目标Server的线程状况，发现Server的线程数也没到瓶颈，有个诡异的现象是随着客户端施加的压力上升，服务器端线程数也没上升，而且网卡流量也没上升；
3、于是猜测是客户端本身的问题，客户端的CPU、网卡流量也没到瓶颈，但发现客户端的线程数随着施加的请求数增加，也没上升，因此猜想是客户端这个地方的线程数已经达到了最大值；
4、由于代码是第三方的，于是用btrace写了个脚本，跟踪查找了该线程池的最大线程数，发现果然是这个最大线程数比较小，因此做了相应的修改，放大最大线程数，继续压测就OK了。
ps: 这个Case还出现了一个状况，就是客户端的网卡流量随着施加的压力上升，却没发生变化，因此猜测是网络上有流量限制…
总结：
从查这次的问题来看，在压测时压力上不去时，需要查看从请求发起到响应返回的整个过程，资源的消耗状况，是否某个地方资源消耗到极限了，如果硬件资源未到极限，通常会是线程blocked或线程被消耗完了。</p>
<p>Case: 某应用GC频繁的问题
这个专门写了一篇blog来描述，具体请见：<a href="http://blog.bluedavy.com/?p=290" title="一个GC频繁的Case" target="_blank"><a href="http://blog.bluedavy.com/?p=290">http://blog.bluedavy.com/?p=290</a></a></p>
<p>Case: 某应用一直没响应。
解决过程：
1、jstack多次后分析，很多的线程都在Blocked状态，等待一把锁，而持有这把锁的线程一直停在了Log4j的ConsoleLog的write上；
2、于是问题就集中到为什么ConsoleLog write的时候竟然会停住，最早猜测的原因是console是不是也输出到了一个文件，而这个文件出问题了，但经过检查发现一切正常；
3、通过ps auxf查看脚本看看console有没有输出到文件，发现这个脚本嵌套了好几层，但都输出到了外部的文件，而外部这个文件是没什么问题的；
4、仔细查看发现这个Java进程是在代码里通过调用脚本启动的，猜想是不是没有正确处理标准输出流和错误流造成的，于是翻看代码，发现代码只处理了输出流，但没处理错误流，并且在处理输出流时只处理了10000行，超过10000的时候就没再去读了，对于这种未将console重定向到外部文件的场景，linux会将其写到一个缓冲区，缓冲区写满后就会导致应用程序阻塞住，这个在Java的API上也有说明：
The parent process uses these streams(Process.getOutputStream(), Process.getInputStream(), Process.getErrorStream()) to feed input to and get output from the subprocess. Because some native platforms only provide limited buffer size for standard input and output streams, failure to promptly write the input stream or read the output stream of the subprocess may cause the subprocess to block, and even deadlock.
5、到这步后就可以确认问题的原因了。
解决方法：
1、把输出到Console的Logger方式去掉了，这样自然就没问题了；
2、程序上修改，不是读到1w行就不读了，而是一直读到没有输出流和错误流了才结束，通常来说比较正确的做法请见这篇贴：<a href="http://goo.gl/sllmv" target="_blank">http://goo.gl/sllmv</a>
总结：
在Java中启动外部程序时一定要注意正确处理输出流和错误流。</p>
<p><a href="https://blog.bluedavy.com/?p=290" target="_blank">一个GC频繁的Case</a> <a href="https://blog.bluedavy.com/?p=309" target="_blank">HBase随机写以及随机读性能测试</a></p>
<h3 id="11-comments-add-yours-">11 Comments <em>(<a href="">+add yours?</a>)</em></h3>
<ol>
<li><img src="https://secure.gravatar.com/avatar/dbaac4591255b0c52e86868bcabc6bd9?s=48&amp;d=&lt;path_to_url&gt;&amp;r=G" alt=""> nova
<strong>Aug 29, 2011</strong> @ 13:20:16
你好，看了你的blog，觉得你在jvm方面研究很深。</li>
</ol>
<p>想问你一个jvm方面的问题，我目前在用一个hudson的服务器，跑在tomcat上，不知道为什么，总是jvm崩溃，然后生成一个 pidXXXX.log的文件，里面的内容不知所云。</p>
<p>请问如何分析这种jvm crash产生的 pidXXX.log文件啊？</p>
<ol>
<li><img src="https://secure.gravatar.com/avatar/5267242305332fe1affd9c4788191e1d?s=48&amp;d=&lt;path_to_url&gt;&amp;r=G" alt=""> <a href="http://bluedavy.com/" target="_blank">bluedavy</a>
<strong>Aug 29, 2011</strong> @ 16:32:39
只能看看这个日志里的内容是什么了，然后相应的解决。</li>
<li><img src="https://secure.gravatar.com/avatar/17dce1595a6c2594969d8fb9ee332df8?s=48&amp;d=&lt;path_to_url&gt;&amp;r=G" alt=""> blueswind
<strong>Sep 16, 2011</strong> @ 11:36:40
毕玄大牛好！
请教一下，在一个应用中，我发现会偶尔出现Full GC，但是这个应用是不允许Full GC出现的，观察gc.log感觉很奇怪：
553887.031: [GC 553887.031: [ParNew: 6448271K-&gt;69532K(7188480K), 0.0676760 secs] 10144883K-&gt;3766882K(12513280K), 0.0679280 secs] [Times: user=0.46 sys=0.01, real=0.07 secs]
553891.774: [GC 553891.774: [ParNew: 6459292K-&gt;75749K(7188480K), 0.1285440 secs] 10156642K-&gt;3774046K(12513280K), 0.1288140 secs] [Times: user=0.92 sys=0.00, real=0.13 secs]
553896.757: [GC 553896.757: [ParNew (promotion failed): 6465509K-&gt;6485588K(7188480K), 2.1091440 secs]553898.866: [CMS: 3699438K-&gt;1483627K(5324800K), 17.0428180 secs] 10163806K-&gt;1483627K(12513280K), [CMS Perm : 95598K-&gt;52896K(131072K)], 19.1523340 secs] [Times: user=19.27 sys=0.02, real=19.16 secs]
553943.432: [GC 553943.432: [ParNew: 6389760K-&gt;113975K(7188480K), 0.0698770 secs] 7873387K-&gt;1597603K(12513280K), 0.0700800 secs] [Times: user=0.47 sys=0.00, real=0.07 secs]
553948.178: [GC 553948.178: [ParNew: 6503735K-&gt;90637K(7188480K), 0.0667370 secs] 7987363K-&gt;1574265K(12513280K), 0.0669710 secs] [Times: user=0.42 sys=0.01, real=0.07 secs]</li>
</ol>
<p>导致promotion failed的那个时刻似乎并没有进行MinorGC，而OldGen又没有到达我设置的80%，我的jvm参数如下：
-Xmx13000m -Xms13000m -Xmn7800m -Xss256k -XX:PermSize=64m -XX:MaxPermSize=128m -XX:ParallelGCThreads=20 -XX:+UseConcMarkSweepGC -XX:+UseParNewGC -XX:SurvivorRatio=8 -XX:TargetSurvivorRatio=100 -XX:MaxTenuringThreshold=15 -XX:CMSInitiatingOccupancyFraction=80 -XX:SoftRefLRUPolicyMSPerMB=0 -XX:+UseCMSCompactAtFullCollection -XX:CMSMaxAbortablePrecleanTime=30000 -XX:CMSScheduleRemarkEdenPenetration=1 -server -XX:+PrintGCDetails -Xloggc:./log/gc.log</p>
<p>由于这个Full GC出现的很少，所以很难重现，如果遇到这种问题，应该如何追查呢？请教毕玄大牛哈~~</p>
<ol>
<li><img src="https://secure.gravatar.com/avatar/5267242305332fe1affd9c4788191e1d?s=48&amp;d=&lt;path_to_url&gt;&amp;r=G" alt=""> <a href="http://bluedavy.com/" target="_blank">bluedavy</a>
<strong>Sep 16, 2011</strong> @ 17:33:47
@blueswind
promotion failed就是minor gc进行的时候出现的，so…
至于这个时候为什么产生了full gc，原因就是因为promotion failed了…
promotion failed的原因主要是旧生代装不下要晋升到old中的对象，建议调整下参数…把新生代放小点吧，或者把cms的触发比率降低点吧。</li>
<li><img src="https://secure.gravatar.com/avatar/17dce1595a6c2594969d8fb9ee332df8?s=48&amp;d=&lt;path_to_url&gt;&amp;r=G" alt=""> blueswind
<strong>Sep 29, 2011</strong> @ 19:06:16
毕玄你好~
上次的那个promotion failed的问题仔细分析了一下，怀疑可能是由于CMSGC时的内存碎片导致的，以下是我的分析和解决过程，请拍砖！
发生promotion failed时，OldGen还有1.6G的空间，同时使用gcLogViewer查看平均新生代晋升大小（AVG PTOS），只有几十K。所以怀疑是由于OldGen在距离上次CMSGC后，经过一段时间又产生了大量内存碎片，当某个时间点在OldGen中的连续空间没有一块足够58K的话，就会导致的promotion failed。
这种情况下的解决方法难道只有调小CMS触发比率或缩小新生代吗？因为这样的话必然会导致系统吞吐量的下降，难道没有很好的解决内存碎片的方法吗？</li>
<li><img src="https://secure.gravatar.com/avatar/0af46e7838cb5c6bed0d132b865d6ead?s=48&amp;d=&lt;path_to_url&gt;&amp;r=G" alt=""> Edward Lee
<strong>Oct 27, 2011</strong> @ 10:00:01
毕玄，首先非常感谢你与我们分享工作中的经验，真得非常感谢！</li>
</ol>
<p>对于你的 Case 1 情况，你在文中说道“一个保护做法是在实现classloader时，最好是先对listFiles排下序”。我感觉用处不大。</p>
<p>比如，App 中至少有 3 个 jar 包出现 3 个同样的 class 类型，而正确的那个类处于中间位置（不管你升序，还是降序），还是一样会抛出NoClassDefFoundError异常。</p>
<p>我觉得合理的做法：在自定义classloader装载类时，若发生异常，则继续尝试加载下一个符合的class类型，直到装载成功为止。</p>
<p>不知你是如何看待这个问题的？</p>
<ol>
<li><img src="https://secure.gravatar.com/avatar/5267242305332fe1affd9c4788191e1d?s=48&amp;d=&lt;path_to_url&gt;&amp;r=G" alt=""> <a href="http://bluedavy.com/" target="_blank">bluedavy</a>
<strong>Oct 27, 2011</strong> @ 10:56:34
@Edward Lee
排序的意思是为了避免集群中各node出现不一致的表现，至少保持一致，冲突的问题这个最好不要智能解决，因为很难说应用到底想加载哪个…</li>
<li><img src="https://secure.gravatar.com/avatar/0af46e7838cb5c6bed0d132b865d6ead?s=48&amp;d=&lt;path_to_url&gt;&amp;r=G" alt=""> Edward Lee
<strong>Oct 27, 2011</strong> @ 15:17:06
@bluedavy
“冲突的问题这个最好不要智能解决，因为很难说应用到底想加载哪个…”
呵呵，对，多谢提醒啊！</li>
<li><img src="https://secure.gravatar.com/avatar/1ddf3edd708b8f29b60ccfa68d855fd3?s=48&amp;d=&lt;path_to_url&gt;&amp;r=G" alt=""> 震子
<strong>Dec 13, 2011</strong> @ 16:18:02
对于permGen的问题造成的的full gc貌似gc日志里面可以指示出来的，从《java_performance》这本书里面看到
在304页
Concurrent Permanent Generation Garbage Collection
Full garbage collections may also occur as a result of a full permanent generation
space. Monitoring the garbage collection data looking for full garbage collections and
then observing the occupancy of the permanent generation space identifies whether
they occur as a result of permanent generation space filling up. Here is an example
full garbage collection initiated by permanent generation space filling up:
2010-12-16T17:14:32.533-0600: [Full GC
[CMS: 95401K-&gt;287072K(1048576K), 0.5317934 secs]
482111K-&gt;287072K(5190464K),
[CMS Perm : 65534K-&gt;58281K(65536K)], 0.5319635</li>
<li><img src="https://secure.gravatar.com/avatar/1ddf3edd708b8f29b60ccfa68d855fd3?s=48&amp;d=&lt;path_to_url&gt;&amp;r=G" alt=""> 震子
<strong>Dec 13, 2011</strong> @ 16:23:48
Case: 某应用压测时压力上不去的问题
对于这个case，我也分享一下，呵呵，如果用的loadrunner的话，一定要注意loadrunner的内存使用，如果内存使用一直涨，那么肯定loadrunner的压力上不去，典型的是：我这边在使用loadrunner的Parameter List的时候就出现了这种情况，loadrunner使用的内存一直在涨。</li>
<li><img src="https://secure.gravatar.com/avatar/5267242305332fe1affd9c4788191e1d?s=48&amp;d=&lt;path_to_url&gt;&amp;r=G" alt=""> <a href="http://bluedavy.com/" target="_blank">bluedavy</a>
<strong>Dec 16, 2011</strong> @ 20:43:52
@震子
还是jstat比较容易判断。<h3 id="leave-a-reply">Leave a Reply</h3>
</li>
</ol>
<p><a href="">Cancel</a></p>
<p>Name (required)</p>
<p>Mail (required)</p>
<p>Website</p>
<p><img src="https://blog.bluedavy.com/wp-content/plugins/si-captcha-for-wordpress/captcha/securimage_show.php?si_form_id=com&amp;prefix=K89yTXStz1vAkC0u" alt="CAPTCHA Image" title="CAPTCHA Image"></p>
<p><a href="&quot;Refresh Image&quot;"><img src="" alt="Refresh Image"></a></p>
<p>CAPTCHA Code /*</p>
<p><style type='text/css'>/#submit {display:none;}</style><br /> <input name="submit" type="submit" id="submit-alt" tabindex="6" value="Submit Comment" /></p>
<p>July 2013 M T W T F S S <a href="https://blog.bluedavy.com/?m=201303" title="View posts for March 2013" target="_blank">« Mar</a>     1234567 891011121314 15161718192021 22232425262728 293031  </p>
<h3 id="categories">Categories</h3>
<ul>
<li><a href="https://blog.bluedavy.com/?cat=63" title="View all posts filed under Java" target="_blank">Java</a> (10)</li>
<li><a href="https://blog.bluedavy.com/?cat=13" title="View all posts filed under jvm" target="_blank">jvm</a> (19)</li>
<li><a href="https://blog.bluedavy.com/?cat=56" title="View all posts filed under NoSQL" target="_blank">NoSQL</a> (7)</li>
<li><a href="https://blog.bluedavy.com/?cat=4" title="View all posts filed under SOA" target="_blank">SOA</a> (1)</li>
<li><a href="https://blog.bluedavy.com/?cat=11" title="关于《分布式Java应用：基础与实践》书部分章节的公开、书内容的纠错以及补充完善。" target="_blank">书:分布式Java应用</a> (5)</li>
<li><a href="https://blog.bluedavy.com/?cat=6" title="View all posts filed under 互联网" target="_blank">互联网</a> (5)</li>
<li><a href="https://blog.bluedavy.com/?cat=46" title="View all posts filed under 产品总结" target="_blank">产品总结</a> (1)</li>
<li><a href="https://blog.bluedavy.com/?cat=18" title="View all posts filed under 优化案例" target="_blank">优化案例</a> (1)</li>
<li><a href="https://blog.bluedavy.com/?cat=12" title="View all posts filed under 圆桌交流" target="_blank">圆桌交流</a> (2)</li>
<li><a href="https://blog.bluedavy.com/?cat=8" title="View all posts filed under 容量规划" target="_blank">容量规划</a> (2)</li>
<li><a href="https://blog.bluedavy.com/?cat=97" title="View all posts filed under 迁户口" target="_blank">迁户口</a> (1)</li>
<li><a href="https://blog.bluedavy.com/?cat=52" title="View all posts filed under 高可用" target="_blank">高可用</a> (1)</li>
<li><a href="https://blog.bluedavy.com/?cat=3" title="View all posts filed under 高并发" target="_blank">高并发</a> (3)</li>
<li><p><a href="https://blog.bluedavy.com/?cat=1" title="关于性能优化方面的一些东西。" target="_blank">高性能</a> (2)</p>
<h3 id="recent-comments">Recent Comments</h3>
</li>
<li><p><a href="http://code1.riaos.com/?p=5030138" target="_blank">JVM调优 | code1（code1.riaos.com）</a> on <a href="https://blog.bluedavy.com/?p=70&amp;cpage=1#comment-16520" target="_blank">说说MaxTenuringThreshold这个参数</a></p>
</li>
<li><a href="http://architecture1.riaos.com/?p=3063358" target="_blank">JVM调优 | architecture（riaos.com）</a> on <a href="https://blog.bluedavy.com/?p=70&amp;cpage=1#comment-16519" target="_blank">说说MaxTenuringThreshold这个参数</a></li>
<li><a href="http://bluedavy.com/" target="_blank">bluedavy</a> on <a href="https://blog.bluedavy.com/?p=409&amp;cpage=1#comment-16462" target="_blank">一个Java应用频繁抛异常导致cpu us诡异现象的案例</a></li>
<li>xiaobo on <a href="https://blog.bluedavy.com/?p=409&amp;cpage=1#comment-16460" target="_blank">一个Java应用频繁抛异常导致cpu us诡异现象的案例</a></li>
<li><a href="http://bluedavy.com/" target="_blank">bluedavy</a> on <a href="https://blog.bluedavy.com/?p=409&amp;cpage=1#comment-16459" target="_blank">一个Java应用频繁抛异常导致cpu us诡异现象的案例</a></li>
</ul>
<h3 id="tags">Tags</h3>
<p><a href="https://blog.bluedavy.com/?tag=btrace" title="2 topics" target="_blank">btrace</a> <a href="https://blog.bluedavy.com/?tag=c1" title="1 topic" target="_blank">c1</a> <a href="https://blog.bluedavy.com/?tag=c2" title="1 topic" target="_blank">c2</a> <a href="https://blog.bluedavy.com/?tag=deflater" title="1 topic" target="_blank">Deflater</a> <a href="https://blog.bluedavy.com/?tag=facebook" title="2 topics" target="_blank">facebook</a> <a href="https://blog.bluedavy.com/?tag=gc" title="4 topics" target="_blank">gc</a> <a href="https://blog.bluedavy.com/?tag=gc-tuning" title="2 topics" target="_blank">gc tuning</a> <a href="https://blog.bluedavy.com/?tag=grizzly" title="2 topics" target="_blank">Grizzly</a> <a href="https://blog.bluedavy.com/?tag=hbase" title="6 topics" target="_blank">HBase</a> <a href="https://blog.bluedavy.com/?tag=hotspot" title="1 topic" target="_blank">hotspot</a> <a href="https://blog.bluedavy.com/?tag=inflater" title="1 topic" target="_blank">Inflater</a> <a href="https://blog.bluedavy.com/?tag=interpreter" title="1 topic" target="_blank">interpreter</a> <a href="https://blog.bluedavy.com/?tag=javac" title="1 topic" target="_blank">javac</a> <a href="https://blog.bluedavy.com/?tag=java-code-generation" title="1 topic" target="_blank">java code generation</a> <a href="https://blog.bluedavy.com/?tag=javaone" title="4 topics" target="_blank">JavaOne</a> <a href="https://blog.bluedavy.com/?tag=javaone-general-technical-session" title="1 topic" target="_blank">javaone general technical session</a> <a href="https://blog.bluedavy.com/?tag=java%e4%bb%a3%e7%a0%81%e6%89%a7%e8%a1%8c" title="1 topic" target="_blank">java代码执行</a> <a href="https://blog.bluedavy.com/?tag=java-%e5%b9%b6%e5%8f%91" title="1 topic" target="_blank">Java 并发</a> <a href="https://blog.bluedavy.com/?tag=jit" title="1 topic" target="_blank">jit</a> <a href="https://blog.bluedavy.com/?tag=jvm" title="12 topics" target="_blank">jvm</a> <a href="https://blog.bluedavy.com/?tag=memory-management" title="1 topic" target="_blank">memory management</a> <a href="https://blog.bluedavy.com/?tag=native-memory-leak" title="1 topic" target="_blank">Native Memory Leak</a> <a href="https://blog.bluedavy.com/?tag=nosql" title="2 topics" target="_blank">NoSQL</a> <a href="https://blog.bluedavy.com/?tag=oom" title="1 topic" target="_blank">oom</a> <a href="https://blog.bluedavy.com/?tag=oracle-keynote" title="1 topic" target="_blank">oracle keynote</a> <a href="https://blog.bluedavy.com/?tag=pessimism-policy" title="1 topic" target="_blank">pessimism policy</a> <a href="https://blog.bluedavy.com/?tag=references" title="1 topic" target="_blank">references</a> <a href="https://blog.bluedavy.com/?tag=rpc" title="2 topics" target="_blank">RPC</a> <a href="https://blog.bluedavy.com/?tag=serial-gc" title="1 topic" target="_blank">serial gc</a> <a href="https://blog.bluedavy.com/?tag=soa" title="2 topics" target="_blank">SOA</a> <a href="https://blog.bluedavy.com/?tag=sun-jdk" title="1 topic" target="_blank">sun jdk</a> <a href="https://blog.bluedavy.com/?tag=sun-jdk-oom" title="1 topic" target="_blank">sun jdk oom</a> <a href="https://blog.bluedavy.com/?tag=web%e5%ae%b9%e9%87%8f%e8%a7%84%e5%88%92%e7%9a%84%e8%89%ba%e6%9c%af" title="1 topic" target="_blank">Web容量规划的艺术</a> <a href="https://blog.bluedavy.com/?tag=yuanzhuo" title="1 topic" target="_blank">yuanzhuo</a> <a href="https://blog.bluedavy.com/?tag=%e4%b9%a6" title="1 topic" target="_blank">书:分布式Java应用</a> <a href="https://blog.bluedavy.com/?tag=%e4%b9%a6%e8%af%84" title="1 topic" target="_blank">书评</a> <a href="https://blog.bluedavy.com/?tag=%e4%ba%92%e8%81%94%e7%bd%91%e6%8a%80%e6%9c%af" title="1 topic" target="_blank">互联网技术</a> <a href="https://blog.bluedavy.com/?tag=%e4%ba%a4%e6%b5%81" title="1 topic" target="_blank">交流</a> <a href="https://blog.bluedavy.com/?tag=%e5%86%85%e5%ad%98%e7%ae%a1%e7%90%86" title="1 topic" target="_blank">内存管理</a> <a href="https://blog.bluedavy.com/?tag=%e5%88%86%e5%b8%83%e5%bc%8fjava%e5%ba%94%e7%94%a8" title="2 topics" target="_blank">分布式Java应用</a> <a href="https://blog.bluedavy.com/?tag=%e5%9c%86%e6%a1%8c%e4%ba%a4%e6%b5%81" title="1 topic" target="_blank">圆桌交流</a> <a href="https://blog.bluedavy.com/?tag=%e5%ae%b9%e9%87%8f%e8%a7%84%e5%88%92" title="2 topics" target="_blank">容量规划</a> <a href="https://blog.bluedavy.com/?tag=%e6%82%b2%e8%a7%82%e7%ad%96%e7%95%a5" title="3 topics" target="_blank">悲观策略</a> <a href="https://blog.bluedavy.com/?tag=%e6%9c%8d%e5%8a%a1%e6%a1%86%e6%9e%b6" title="1 topic" target="_blank">服务框架</a> <a href="https://blog.bluedavy.com/?tag=%e7%a1%85%e8%b0%b7%e5%85%ac%e5%8f%b8" title="1 topic" target="_blank">硅谷公司</a></p>
<h3 id="-">订阅</h3>
<h3 id="-">推荐书籍</h3>
<h3 id="my-book">My Book</h3>
<p><a href="http://book.douban.com/subject/4848587/" title="分布式Java应用：基础与实践" target="_blank"><img src="" alt=""></a> <a href="http://book.douban.com/subject/3843896/" title="OSGi原理与最佳实践" target="_blank"><img src="" alt=""></a>
© <a href="https://blog.bluedavy.com/" target="_blank">BlueDavy之技术blog</a> 2013</p>
<p><a href="http://icondock.com/" target="_blank">Icons</a> &amp; <a href="http://www.ndesign-studio.com/wp-themes" target="_blank">Wordpress Theme</a> by <a href="http://www.ndesign-studio.com/" target="_blank">N.Design</a></p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/JVM/">JVM</a></li></span></span> | <span class="tags">Tagged <a href="/tags/JVM/" class="label label-primary">JVM</a><a href="/tags/Java&J2EE/" class="label label-success">Java&J2EE</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:42"datetime="2014-03-07 09:54:42"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-JVM--记录帖：碰到的一些Java问题（更新于2013-03-06）/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-JVM--记录帖：碰到的一些Java问题（更新于2013-03-06）" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>





<ul id="pagination" class="pagination pagination-lg">
  <li><a class="extend prev" href="/page/49/">&laquo;</a></li><li><a class="page-number" href="/">1</a></li><li><a class="page-number" href="/page/2/">2</a></li><li><span class="space">&hellip;</span></li><li><a class="page-number" href="/page/47/">47</a></li><li><a class="page-number" href="/page/48/">48</a></li><li><a class="page-number" href="/page/49/">49</a></li><li class="active"><li><span class="page-number current">50</span></li><li><a class="page-number" href="/page/51/">51</a></li><li><a class="page-number" href="/page/52/">52</a></li><li><a class="page-number" href="/page/53/">53</a></li><li><span class="space">&hellip;</span></li></li><li><a class="page-number" href="/page/162/">162</a></li><li><a class="page-number" href="/page/163/">163</a></li><li><a class="extend next" href="/page/51/">&raquo;</a></li>
  <div class="clearfix"></div>
</ul></div><!--wapper-->
       </div><!-- ID main-col END -->
       <aside id="sidebar" class="alignright col-sx-6 col-sm-4 col-md-3 col-lg-3">
<div id="widget_search" class="widget panel panel-primary">
    <form action="//google.com/search" method="get" accept-charset="utf-8">
  <div class="input-group">
    <input class="form-control" id="searchbox" type="search" name="q" results="0" placeholder="search">
    <span class="input-group-btn">
      <button class="btn btn-default" type="submit">Go!</button>
    </span>
    <input type="hidden" name="q" value="site:itsolife.com">
  </div>
</form>
</div>

<div id="widget_category" class="widget panel panel-primary">
  <div class="panel-heading">category</div>  <div data-src='category' class='ajax_widgets'>正在加载...</div>
</div>

<div id="widget_recent_posts" class="widget panel panel-primary">
  <div class="panel-heading">recent posts</div>  <div data-src='recent_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_tagcloud" class="widget panel panel-primary">
  <div class="panel-heading">tagcloud</div>  <div data-src='tagcloud' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_latest_update_posts" class="widget panel panel-primary">
  <div class="panel-heading">最近更新</div>  <div data-src='latest_update_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_recent_comments" class="widget panel panel-primary">
  <div class="panel-heading">recent comments</div>  

<div class="list-group-item ds-recent-comments" data-num-items="6" data-show-avatars="1" data-show-time="1" data-show-title="1" data-show-admin="1" data-excerpt-length="50"></div>



</div>

</aside>
       <div class="clearfix"></div>
     </div><!-- row END -->
  </div>
  <footer id="footer" class="container">
  <div class="panel panel-info">
  <section id='footer_widget'></section>  <div class="panel-footer">
  <div id="site-info">
    <span class='author'>
  
  &copy; 2014 RobinChia
  
    &nbsp;&nbsp;</span>
  
  <span id='analytics-51la'></span><span id='analytics-google'>
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-48559895-1']);
  _gaq.push(['_trackPageview']);
  _js2load.push({src:('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'});
</script></span><span id='analytics-cnzz'>
<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_5774006'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s17.cnzz.com/stat.php%3Fid%3D5774006%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>
</span><span id='analytics-baidu'>
<script>
var _hmt = _hmt || [];
_js2load.push({src:"//hm.baidu.com/hm.js?1442f50724afc42380b51f097c43082c"});
</script>
</span>  </div>
  <div id="copyright">Site powered by <a href='http://zespia.tw/hexo/'><strong>hexo</strong></a>  update time: <em>2014-03-30 14:30:15</em></span></div>
</div>
<div class="clearfix"></div>


  </div>
  </footer>
  
        <script src="http://cdn.bootcss.com/jquery/1.10.2/jquery.min.js"></script>        
        <script src="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/js/bootstrap.min.js"></script>        
                
        <script src="http://cdn.bootcss.com/prettify/r298/prettify.min.js"></script>    <script type="text/javascript">
   var lang=["bsh", "c", "cc", "cpp", "cs", "csh", "cyc", "cv", "htm", "html",
    "java", "js", "m", "mxml", "perl", "pl", "pm", "py", "rb", "sh",
    "xhtml", "xml", "xsl"];
   var pretty_base='';
   $('script').each(function(){
	var c = $(this).attr('src');
	if (!c)
	    return;
	if (c.match(/(\/)?prettify(\.min)?\.js/i))
	{
	    var index = c.lastIndexOf('/');
	    if (index != -1)
		pretty_base = c.substr(0,index + 1);
	    return false;
	}
   })
   $('pre code').each(function(){
	var c = $(this).attr('class')
	if (!c)
	    return;
	c = c.match(/\s?(lang\-\w+)/i);
	if (c && lang.indexOf(c[1]) == -1)
	{
	    lang.push(c[1]);
	    $.getScript(pretty_base + c[1] + '.min.js');
	}
   })

    $(window).load(function(){
       $("pre").addClass("prettyprint");
       prettyPrint();
    })
</script>    
            <script type="text/javascript">
var duoshuoQuery = {short_name:"robinchia"};
_js2load.push({src:'http://static.duoshuo.com/embed.js',charset:'UTF-8'});
</script>
    
            <!--wumii_relatedItems-->
    
        <script src="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js"></script>    <script type="text/javascript">
(function($){
  $('.entry').each(function(i){
    $(this).find('img').each(function(){
      var alt = this.alt;

      if (alt){
        $(this).before('<span class="caption">' + alt + '</span>');
      }

      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox" rel="fancybox' + i + '" />');
    });
  });

  $('.fancybox').fancybox();
})(jQuery);
</script>    
        <script src="http://cdn.bootcss.com/mathjax/2.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>    <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>
    
<script type="text/javascript">
$('.ajax_widgets').each(function(){var src=$(this).attr('data-src');if(src)$(this).load('/widgets/'+src+'.html');});
$.each(_js2load,function(index,obj){loadjs(obj.src,obj.charset)});
</script>

<div id="scroll2top">
<img src="/scroll2top/arrow.png"/>
</div>
<script src="/scroll2top/scroll2top.min.js"></script>
<div id="winterland">
  <canvas></canvas>
</div>
<script src="/js/winterland.min.js"></script>

  </body>
</html>
