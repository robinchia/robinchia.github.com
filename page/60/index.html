
<!DOCTYPE HTML>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>The 60 Page | It so life</title>
<meta name="author" content="RobinChia">

<meta name="description" content="It so life">


<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<meta property="og:site_name" content="It so life"/>

<!--[if IE]><style>.testIE.IE{display:inline;}</style><![endif]-->
<!--[if lte IE 7]><link rel="stylesheet" href="/css/ie7.css" type="text/css"><![endif]-->
<!--[if (lt IE 9)&(gt IE 7)]><style>.testIE.IE8{display:inline;}</style><![endif]-->
<!--[if gt IE 8]><style>.testIE.IE9{display:inline;}</style><![endif]-->

<link href="/favicon.png" rel="icon">
<link rel="alternate" href="/atom.xml" title="It so life Feed" type="application/atom+xml">

<link rel="stylesheet" href="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/css/bootstrap.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/font-awesome/4.0.3/css/font-awesome.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/prettify/r298/prettify.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" type="text/css">
<link rel="stylesheet" href="/css/style.css" type="text/css">
<!--[if lt IE 9]>
   <style>article,aside,dialog,footer,header,section,footer,nav,figure,menu{display:block}</style>
   <script src="http://cdn.staticfile.org/html5shiv/r29/html5.min.js"></script>
   <script src="http://cdn.staticfile.org/respond.js/1.4.2/respond.min.js"></script>
<link href="http://cdn.staticfile.org/respond.js/1.4.2/respond-proxy.html" id="respond-proxy" rel="respond-proxy" />
<link href="/js/respond.proxy.gif" id="respond-redirect" rel="respond-redirect" />
<script src="/js/respond.proxy.js"></script>
   <script src="http://cdn.bootcss.com/selectivizr/1.0.2/selectivizr-min.js"></script>
<![endif]-->
<script type="text/javascript">
function loadjs(c,d){var a=document.createElement("script");a.async=!0;a.type="text/javascript";a.src=c;a.charset=d||"gbk";(document.getElementsByTagName("HEAD")[0]||document.getElementsByTagName("BODY")[0]).appendChild(a)};
var _protocol = (("https:" == document.location.protocol) ? " https://" : " http://");
var _js2load = [];
</script>

</head>
<body>
      <header id="header" class="container"><nav id="main-nav" class="navbar navbar-default navbar-fixed-top " role="navigation">
  <div class="container">
    <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
      <span class="sr-only">Toggle navigation</span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="/">It so life</a>
    </div>
    <div  class="collapse navbar-collapse">
      <ul  class="nav navbar-nav">
  
        <li><a href="/" title="Home">Home</a></li>      
        <li><a href="/about/" title="About">About</a></li>      
        <li><a href="/archives/" title="Archives">Archives</a></li>      
      <li class='dropdown'>
        <a class='dropdown-toggle' data-toggle='dropdown' href='#'>website<b class='caret'></b></a>
        <ul class='dropdown-menu pure-menu-selected'>
    
          <li><a href="//groups.google.com/forum/#!forum/pongba" title="TopLanguage">TopLanguage</a></li>    
          <li><a href="//itpub.net/" title="ITPub">ITPub</a></li>    
          <li><a href="//blog.jobbole.com/" title="Bole">Bole</a></li>    
          <li><a href="//nosql-database.org/" title="nosql">nosql</a></li>    
          <li><a href="//gitimmersion.googol.im/" title="Git">Git</a></li>    
        </ul>
      </li>
    
      </ul>
      <ul class="nav navbar-nav navbar-right">
      
        <li><a href="/atom.xml">RSS</a></li>
      
      
        <li><a href="https://twitter.com/robinchia">twitter</a></li>
      
      
      
      
        <li><a href="https://github.com/robinchia">github</a></li>
      
      </ul>
    </div>
  </div>
</nav>
<div class="clearfix"></div>
</header>
  <div id='content' class="container">
     <div class="page-header-wrapper">
      <!--[if lt IE 9]><div class="alert alert-warning alert-dismissable"><button type="button" class="close" data-dismiss="alert" aria-hidden="true">&times;</button><strong>提示:</strong>您的浏览器版本太低了,建议升级到 <strong><a href="http://windows.microsoft.com/zh-cn/internet-explorer/download-ie" title="IE9">IE9</a></strong> 以上,本站使用<a href="https://www.google.com/intl/zh-CN/chrome/">Chrome浏览器</a>可以获得最好的显示效果.</div><![endif]-->
      <div class="page-header"><h1 align="center"><big>It so life</big> </h1>
        <h5 align="center"><big>love as life</big></h5>
      </div>
     </div>
     <div class="row">
       <div id="main-col" class="alignleft col-sx-12 col-sm-8 col-md-9 col-lg-9">
      <section id='header_widget'></section>
          <div id="wrapper"><article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-SQL_Java--Java中，获得ResultSet的总行数与总列数/">Java中，获得ResultSet的总行数与总列数</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:41.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-SQL_Java--Java中，获得ResultSet的总行数与总列数/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="java-resultset-">Java中，获得ResultSet的总行数与总列数</h1>
<h2 id="java-resultset-">Java中，获得ResultSet的总行数与总列数</h2>
<p>在Java中，获得ResultSet的总行数的方法有以下几种。</p>
<p><strong>第一种：利用ResultSet的getRow方法来获得ResultSet的总行数</strong></p>
<p>Statement stmt = con.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_UPDATABLE);
ResultSet rset = stmt.executeQuery(&quot;select /* from yourTableName&quot;);
rset.last();
int rowCount = rset.getRow(); //获得ResultSet的总行数</p>
<p><strong>第二种：利用循环ResultSet的元素来获得ResultSet的总行数</strong></p>
<p>ResultSet rset = stmt.executeQuery(&quot;select /* from yourTableName&quot;);
int rowCount = 0;
while(rset.next()) {
rowCount++;
}</p>
<p>rowCount就是ResultSet的总行数。</p>
<p><strong>第三种：利用sql语句中的count函数获得ResultSet的总行数</strong></p>
<p>ResultSet rset = stmt.executeQuery(&quot;select count(/*) totalCount from yourTableName&quot;);
int rowCount = 0;
if(rset.next()) {
rowCount=rset .getInt(&quot;totalCount &quot;);
}</p>
<p>rowCount就是ResultSet的总行数。</p>
<ul>
<li>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/*</li>
<li>Java中获得ResultSet的总列数是非常简单事情，因为Java中ResultSet提供了ResultSetMetaData工具类,ResultSetMetaData 是ResultSet的元数据的集合说明。</li>
</ul>
<p>java获得ResultSet总列数的代码如下：</p>
<p>Statement stmt = con.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_UPDATABLE);
ResultSet rset = stmt.executeQuery(&quot;select /* from yourtable&quot;);
ResultSetMetaData rsmd = rset.getMetaData() ;
int columnCount = rsmd.getColumnCount();</p>
<p>columnCount 就是ResultSet的总列数。</p>
<hr>
<p>例子：
Statement stmt = conn.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,  ResultSet.CONCUR_READ_ONLY);   ResultSet rs = stmt.executeQuery(sql);   rs.last();   int length = rs.getRow();</p>
<p>如上，length的值，就是行数了。如果在获取了行数后，还需要继续使用当前数据集rs，则需要rs.beforeFirst();一次，将游标回到初始位置。
ResultSet.TYPE_SCROLL_INSENSITIVE 结果集的游标可以上下移动，当数据库变化时，当前结果集不变。
ResultSet.CONCUR_READ_ONLY 不能用结果集更新数据库中的表。</p>
<p>此外，给出Statement创建时的其他说明：
通用格式为：Statement stmt=con.createStatement(int type，int concurrency);我们在访问数据库的时候，在读取返回结果的时候，可能要前后移动指针，比如我们先计算有多少条信息，这是我们就需要把指针移到最后来计算，然后再把指针移到最前面，逐条读取，有时我们只需要逐条读取就可以了。还有就是有只我们只需要读取数据，为了不破坏数据，我们可采用只读模式，有时我们需要望数据库里添加记录，这是我们就要采用可更新数据库的模式。
下面是所有参数的说明：
参数 int type
ResultSet.TYPE_FORWORD_ONLY 结果集的游标只能向下滚动。
ResultSet.TYPE_SCROLL_INSENSITIVE 结果集的游标可以上下移动，当数据库变化时，当前结果集不变。
ResultSet.TYPE_SCROLL_SENSITIVE 返回可滚动的结果集，当数据库变化时，当前结果集同步改变。</p>
<p>参数 int concurrency</p>
<p>ResultSet.CONCUR_READ_ONLY 不能用结果集更新数据库中的表。
ResultSet.CONCUR_UPDATETABLE 能用结果集更新数据库中的表。</p>
<p>此外，当我们使用ResultSet re=stmt.executeQuery(SQL语句）查询后，我们可以使用下列方法获得信息：</p>
<p>public boolean previous() 将游标向上移动，该方法返回boolean型数据，当移到结果集第一行之前时，返回false。
public void beforeFirst 将游标移动到结果集的初始位置，即在第一行之前。
public void afterLast() 将游标移到结果集最后一行之后。
public void first() 将游标移到结果集的第一行。
public void last() 将游标移到结果集的最后一行。
public boolean isAfterLast() 判断游标是否在最后一行之后。
public boolean isBeforeFirst() 判断游标是否在第一行之前。
public boolean ifFirst() 判断游标是否指向结果集的第一行。
public boolean isLast() 判断游标是否指向结果集的最后一行。
public int getRow() 得到当前游标所指向行的行号，行号从1开始，如果结果集没有行，返回0。
public boolean absolute(int row) 将游标移到参数row指定的行号。如果row取负值，就是倒数的行数，absolute(-1)表示移到最后一行，absolute(-2)表示移到倒数第2行。当移动到第一行前面或最后一行的后面时，该方法返回false。</p>
<p>ResultSetMetaData rsmd = this.rs.getMetaData();
this.columnCount = rsmd.getColumnCount();</p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/SQL_Java/">SQL_Java</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/SQL_Java/" class="label label-success">SQL_Java</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:41"datetime="2014-03-07 09:54:41"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-SQL_Java--Java中，获得ResultSet的总行数与总列数/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-SQL_Java--Java中，获得ResultSet的总行数与总列数" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-SQL_Java--IntroductiontoStructuredQueryLanguageZQL/">Introduction to Structured Query Language(ZQL)</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:41.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-SQL_Java--IntroductiontoStructuredQueryLanguageZQL/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="introduction-to-structured-query-language-zql-">Introduction to Structured Query Language(ZQL)</h1>
<h1 id="introduction-to-structured-query-language">Introduction to Structured Query Language</h1>
<p><strong>Version 3.31</strong></p>
<p>This page is a tutorial of the Structured Query Language(also known as <strong>SQL</strong>) and is a pioneering effort on the World Wide Web, as this is the first comprehensive SQL tutorial available on the Internet. SQL allows users to access data in relational database management systems, such as Oracle, Sybase, Informix, Microsoft SQL Server, Access, and others, by allowing users to describe the data the user wishes to see. SQL also allows users to define the data in a database, and manipulate that data. This page will describe how to use SQL, and give examples. The SQL used in this document is &quot;ANSI&quot;, or standard SQL, and no SQL features of specific database management systems will be discussed until the &quot;Nonstandard SQL&quot; section. It is recommended that you print this page, so that you can easily refer back to previous examples.
<strong>Table of Contents</strong></p>
<p><a href="http://zql.sourceforge.net/sqltut.html#Basics%20of%20the%20SELECT%20Statement">Basics of the SELECT Statement
</a><a href="http://zql.sourceforge.net/sqltut.html#Conditional%20Selection">Conditional Selection
</a><a href="http://zql.sourceforge.net/sqltut.html#Relational%20Operators">Relational Operators
</a><a href="http://zql.sourceforge.net/sqltut.html#Compound%20Conditions">Compound Conditions
</a><a href="http://zql.sourceforge.net/sqltut.html#IN%20&amp;%20BETWEEN">IN &amp; BETWEEN
</a><a href="http://zql.sourceforge.net/sqltut.html#Using%20LIKE" target="_blank">Using LIKE</a></p>
<p><a href="http://zql.sourceforge.net/sqltut.html#Joins">Joins
</a><a href="http://zql.sourceforge.net/sqltut.html#Keys">Keys
</a><a href="http://zql.sourceforge.net/sqltut.html#Performing%20a%20Join">Performing a Join
</a><a href="http://zql.sourceforge.net/sqltut.html#Eliminating%20Duplicates">Eliminating Duplicates
</a><a href="http://zql.sourceforge.net/sqltut.html#Aliases%20&amp;%20In/Subqueries" target="_blank">Aliases &amp; In/Subqueries</a></p>
<p><a href="http://zql.sourceforge.net/sqltut.html#Aggregate%20Functions" target="_blank">Aggregate Functions</a>
<a href="http://zql.sourceforge.net/sqltut.html#Views" target="_blank">Views</a>
<a href="http://zql.sourceforge.net/sqltut.html#Creating%20New%20Tables" target="_blank">Creating New Tables</a>
<a href="http://zql.sourceforge.net/sqltut.html#Altering%20Tables" target="_blank">Altering Tables</a>
<a href="http://zql.sourceforge.net/sqltut.html#Adding%20Data" target="_blank">Adding Data</a>
<a href="http://zql.sourceforge.net/sqltut.html#Deleting%20Data" target="_blank">Deleting Data</a>
<a href="http://zql.sourceforge.net/sqltut.html#Updating%20Data" target="_blank">Updating Data</a></p>
<p><a href="http://zql.sourceforge.net/sqltut.html#Indexes" target="_blank">Indexes</a>
<a href="http://zql.sourceforge.net/sqltut.html#GROUP%20BY%20&amp;%20HAVING" target="_blank">GROUP BY &amp; HAVING</a>
<a href="http://zql.sourceforge.net/sqltut.html#More%20Subqueries">More Subqueries
</a><a href="http://zql.sourceforge.net/sqltut.html#EXISTS%20&amp;%20ALL" target="_blank">EXISTS &amp; ALL</a>
<a href="http://zql.sourceforge.net/sqltut.html#UNION%20&amp;%20Outer%20Joins" target="_blank">UNION &amp; Outer Joins</a>
<a href="http://zql.sourceforge.net/sqltut.html#Embedded%20SQL" target="_blank">Embedded SQL</a>
<a href="http://zql.sourceforge.net/sqltut.html#Common%20SQL%20Questions" target="_blank">Common SQL Questions</a>
<a href="http://zql.sourceforge.net/sqltut.html#Nonstandard%20SQL" target="_blank">Nonstandard SQL</a>
<a href="http://zql.sourceforge.net/sqltut.html#Syntax%20Summary" target="_blank">Syntax Summary</a>
<a href="http://zql.sourceforge.net/sqltut.html#Important%20Links" target="_blank">Important Links</a></p>
<p><a href=""></a><strong>Basics of the SELECT Statement</strong></p>
<p>In a relational database, data is stored in tables. An example table would relate Social Security Number, Name, and Address:
<strong>EmployeeAddressTable</strong> <strong>SSN</strong> <strong>FirstName</strong> <strong>LastName</strong> <strong>Address</strong> <strong>City</strong> <strong>State</strong> 512687458 Joe Smith 83 First Street Howard Ohio 758420012 Mary Scott 842 Vine Ave. Losantiville Ohio 102254896 Sam Jones 33 Elm St. Paris New York 876512563 Sarah Ackerman 440 U.S. 110 Upton Michigan</p>
<p>Now, let&#39;s say you want to see the address of each employee. Use the SELECT statement, like so:</p>
<p>SELECT FirstName, LastName, Address, City, State
FROM EmployeeAddressTable;</p>
<p>The following is the results of your query of the database:
<strong>First Name</strong> <strong>Last Name</strong> <strong>Address</strong> <strong>City</strong> <strong>State</strong> Joe Smith 83 First Street Howard Ohio Mary Scott 842 Vine Ave. Losantiville Ohio Sam Jones 33 Elm St. Paris New York Sarah Ackerman 440 U.S. 110 Upton Michigan</p>
<p>To explain what you just did, you asked for the all of data in the EmployeeAddressTable, and specifically, you asked for the columns called FirstName, LastName, Address, City, and State. Note that column names and table names do not have spaces...they must be typed as one word; and that the statement ends with a semicolon (;). The general form for a SELECT statement, retrieving all of the rows in the table is:</p>
<p>SELECT ColumnName, ColumnName, ...
FROM TableName;</p>
<p>To get all columns of a table without typing all column names, use:</p>
<p>SELECT /* FROM TableName;</p>
<p>Each database management system (DBMS) and database software has different methods for logging in to the database and entering SQL commands; see the local computer &quot;guru&quot; to help you get onto the system, so that you can use SQL.
<a href=""></a><strong>Conditional Selection</strong></p>
<p>To further discuss the SELECT statement, let&#39;s look at a new example table (for hypothetical purposes only):
<strong>EmployeeStatisticsTable</strong> <strong>EmployeeIDNo</strong> <strong>Salary</strong> <strong>Benefits</strong> <strong>Position</strong> 010 75000 15000 Manager 105 65000 15000 Manager 152 60000 15000 Manager 215 60000 12500 Manager 244 50000 12000 Staff 300 45000 10000 Staff 335 40000 10000 Staff 400 32000 7500 Entry-Level 441 28000 7500 Entry-Level</p>
<h3 id="-relational-operators"><a href=""></a>Relational Operators</h3>
<p>There are six Relational Operators in SQL, and after introducing them, we&#39;ll see how they&#39;re used:
= Equal &lt;&gt; or != (see manual) Not Equal &lt; Less Than &gt; Greater Than &lt;= Less Than or Equal To &gt;= Greater Than or Equal To</p>
<p>The WHEREclause is used to specify that only certain rows of the table are displayed, based on the criteria described in that WHERE clause. It is most easily understood by looking at a couple of examples.</p>
<p>If you wanted to see the EMPLOYEEIDNO&#39;s of those making at or over $50,000, use the following:</p>
<p>SELECT EMPLOYEEIDNO
FROM EMPLOYEESTATISTICSTABLE
WHERE SALARY &gt;= 50000;</p>
<p>Notice that the &gt;= (greater than or equal to) sign is used, as we wanted to see those who made greater than $50,000, or equal to $50,000, listed together. This displays:</p>
<h2 id="employeeidno">EMPLOYEEIDNO</h2>
<p>010
105
152
215
244</p>
<p>The WHERE description, SALARY &gt;= 50000, is known as a condition. The same can be done for text columns:</p>
<p>SELECT EMPLOYEEIDNO
FROM EMPLOYEESTATISTICSTABLE
WHERE POSITION = &#39;Manager&#39;;</p>
<p>This displays the ID Numbers of all Managers. Generally, with text columns, stick to equal to or not equal to, and make sure that any text that appears in the statement is surrounded by single quotes (&#39;).</p>
<p><a href=""></a>More Complex Conditions: Compound Conditions</p>
<p>The AND operator joins two or more conditions, and displays a row only if that row&#39;s data satisfies <strong>ALL</strong> conditions listed (i.e. all conditions hold true). For example, to display all staff making over $40,000, use:</p>
<p>SELECT EMPLOYEEIDNO
FROM EMPLOYEESTATISTICSTABLE
WHERE SALARY &gt; 40000 AND POSITION = &#39;Staff&#39;;</p>
<p>The OR operator joins two or more conditions, but returns a row if <strong>ANY</strong> of the conditions listed hold true. To see all those who make less than $40,000 or have less than $10,000 in benefits, listed together, use the following query:</p>
<p>SELECT EMPLOYEEIDNO
FROM EMPLOYEESTATISTICSTABLE
WHERE SALARY &lt; 40000 OR BENEFITS &lt; 10000;</p>
<p>AND &amp; OR can be combined, for example:</p>
<p>SELECT EMPLOYEEIDNO
FROM EMPLOYEESTATISTICSTABLE
WHERE POSITION = &#39;Manager&#39; AND SALARY &gt; 60000 OR BENEFITS &gt; 12000;</p>
<p>First, SQL finds the rows where the salary is greater than $60,000 and the position column is equal to Manager, then taking this new list of rows, SQL then sees if any of these rows satisfies the previous AND condition or the condition that the Benefits column is greater then $12,000. Subsequently, SQL only displays this second new list of rows, keeping in mind that anyone with Benefits over $12,000 will be included as the OR operator includes a row if either resulting condition is True. Also note that the AND operation is done first.</p>
<p>To generalize this process, SQL performs the AND operation(s) to determine the rows where the AND operation(s) hold true (remember: all of the conditions are true), then these results are used to compare with the OR conditions, and only display those remaining rows where the conditions joined by the OR operator hold true.</p>
<p>To perform OR&#39;s before AND&#39;s, like if you wanted to see a list of employees making a large salary (&gt;$50,000) or have a large benefit package (&gt;$10,000), and that happen to be a manager, use parentheses:</p>
<p>SELECT EMPLOYEEIDNO
FROM EMPLOYEESTATISTICSTABLE
WHERE POSITION = &#39;Manager&#39; AND (SALARY &gt; 50000 OR BENEFIT &gt; 10000);</p>
<p><a href=""></a><strong>IN &amp; BETWEEN</strong></p>
<p>An easier method of using compound conditions uses IN or BETWEEN. For example, if you wanted to list all managers and staff:</p>
<p>SELECT EMPLOYEEIDNO
FROM EMPLOYEESTATISTICSTABLE
WHERE POSITION IN (&#39;Manager&#39;, &#39;Staff&#39;);</p>
<p>or to list those making greater than or equal to $30,000, but less than or equal to $50,000, use:</p>
<p>SELECT EMPLOYEEIDNO
FROM EMPLOYEESTATISTICSTABLE
WHERE SALARY BETWEEN 30000 AND 50000;</p>
<p>To list everyone not in this range, try:</p>
<p>SELECT EMPLOYEEIDNO
FROM EMPLOYEESTATISTICSTABLE
WHERE SALARY NOT BETWEEN 30000 AND 50000;</p>
<p>Similarly, NOT IN lists all rows excluded from the IN list.</p>
<p><a href=""></a><strong>UsingLIKE</strong></p>
<p>Look at the EmployeeStatisticsTable, and say you wanted to see all people whose last names started with &quot;L&quot;; try:</p>
<p>SELECT EMPLOYEEIDNO
FROM EMPLOYEEADDRESSTABLE
WHERE LASTNAME LIKE &#39;L%&#39;;</p>
<p>The percent sign (%) is used to represent any possible character (number, letter, or punctuation) or set of characters that might appear after the &quot;L&quot;. To find those people with LastName&#39;s ending in &quot;L&quot;, use &#39;%L&#39;, or if you wanted the &quot;L&quot; in the middle of the word, try &#39;%L%&#39;. The &#39;%&#39; can be used for any characters, in that relative position to the given characters. NOT LIKE displays rows not fitting the given description. Other possiblities of using LIKE, or any of these discussed conditionals, are available, though it depends on what DBMS you are using; as usual, consult a manual or your system manager or administrator for the available features on your system, or just to make sure that what you are trying to do is available and allowed. This disclaimer holds for the features of SQL that will be discussed below. This section is just to give you an idea of the possibilities of queries that can be written in SQL.
<a href=""></a><strong>Joins</strong></p>
<p>In this section, we will only discuss inner joins, and equijoins, as in general, they are the most useful. For more information, try the SQL links at the bottom of the page.</p>
<p>Good database design suggests that each table lists data only about a single entity, and detailed information can be obtained in a relational database, by using additional tables, and by using a join.</p>
<p>First, take a look at these example tables:
<strong>AntiqueOwners</strong>
 <strong>OwnerID</strong> <strong>OwnerLastName</strong> <strong>OwnerFirstName</strong> 01 Jones Bill 02 Smith Bob 15 Lawson Patricia 21 Akins Jane 50 Fowler Sam</p>
<p><strong>Orders</strong>
 <strong>OwnerID</strong> <strong>ItemDesired</strong> 02 Table 02 Desk 21 Chair 15 Mirror</p>
<p><strong>Antiques</strong>
 <strong>SellerID</strong> <strong>BuyerID</strong> <strong>Item</strong> 01 50 Bed 02 15 Table 15 02 Chair 21 50 Mirror 50 01 Desk 01 21 Cabinet 02 21 Coffee Table 15 50 Chair 01 15 Jewelry Box 02 21 Pottery 21 02 Bookcase 50 01 Plant Stand</p>
<p><a href=""></a><strong>Keys</strong></p>
<p>First, let&#39;s discuss the concept of keys. A primary key is a column or set of columns that uniquely identifies the rest of the data in any given row. For example, in the AntiqueOwners table, the OwnerID column uniquely identifies that row. This means two things: no two rows can have the same OwnerID, and, even if two owners have the same first and last names, the OwnerID column ensures that the two owners will not be confused with each other, because the unique OwnerID column will be used throughout the database to track the owners, rather than the names.</p>
<p>Aforeign key is a column in a table where that column is a primary key of another table, which means that any data in a foreign key column must have corresponding data in the other table where that column is the primary key. In DBMS-speak, this correspondence is known as referential integrity. For example, in the Antiques table, both the BuyerID and SellerID are foreign keys to the primary key of the AntiqueOwners table (OwnerID; for purposes of argument, one has to be an Antique Owner before one can buy or sell any items), as, in both tables, the ID rows are used to identify the owners or buyers and sellers, and that the OwnerID is the primary key of the AntiqueOwners table. In other words, all of this &quot;ID&quot; data is used to refer to the owners, buyers, or sellers of antiques, themselves, without having to use the actual names.</p>
<p><a href=""></a><strong>Performing a Join</strong></p>
<p>The purpose of these keys is so that data can be related across tables, without having to repeat data in every table--this is the power of relational databases. For example, you can find the names of those who bought a chair without having to list the full name of the buyer in the Antiques table...you can get the name by relating those who bought a chair with the names in the AntiqueOwners table through the use of the OwnerID, which relates the data in the two tables. To find the names of those who bought a chair, use the following query:</p>
<p>SELECT OWNERLASTNAME, OWNERFIRSTNAME
FROM ANTIQUEOWNERS, ANTIQUES
WHERE BUYERID = OWNERID AND ITEM = &#39;Chair&#39;;</p>
<p>Note the following about this query...notice that both tables involved in the relation are listed in the FROM clause of the statement. In the WHERE clause, first notice that the ITEM = &#39;Chair&#39; part restricts the listing to those who have bought (and in this example, thereby owns) a chair. Secondly, notice how the ID columns are related from one table to the next by use of the BUYERID = OWNERID clause. Only where ID&#39;s match across tables and the item purchased is a chair (because of the AND), will the names from the AntiqueOwners table be listed. Because the joining condition used an equal sign, this join is called an equijoin. The result of this query is two names: Smith, Bob &amp; Fowler, Sam.</p>
<p>Dot notation refers to prefixing the table names to column names, to avoid ambiguity, as such:</p>
<p>SELECT ANTIQUEOWNERS.OWNERLASTNAME, ANTIQUEOWNERS.OWNERFIRSTNAME
FROM ANTIQUEOWNERS, ANTIQUES
WHERE ANTIQUES.BUYERID = ANTIQUEOWNERS.OWNERID AND ANTIQUES.ITEM = &#39;Chair&#39;;</p>
<p>As the column names are different in each table, however, this wasn&#39;t necessary.</p>
<p><a href=""></a><strong>DISTINCT and Eliminating Duplicates</strong></p>
<p>Let&#39;s say that you want to list the ID and names of <strong>only</strong> those people who have sold an antique. Obviously, you want a list where each seller is only listed once--you don&#39;t want to know how many antiques a person sold, just the fact that this person sold one (for counts, see the Aggregate Function section below). This means that you will need to tell SQL to eliminate duplicate sales rows, and just list each person only once. To do this, use the DISTINCT keyword.</p>
<p>First, we will need an equijoin to the AntiqueOwners table to get the detail data of the person&#39;s LastName and FirstName. However, keep in mind that since the SellerID column in the Antiques table is a foreign key to the AntiqueOwners table, a seller will only be listed if there is a row in the AntiqueOwners table listing the ID and names. We also want to eliminate multiple occurences of the SellerID in our listing, so we use DISTINCT<strong>on the column where the repeats may occur.</strong></p>
<p>To throw in one more twist, we will also want the list alphabetized by LastName, then by FirstName (on a LastName tie), then by OwnerID (on a LastName and FirstName tie). Thus, we will use the ORDER BY clause:</p>
<p>SELECT DISTINCT SELLERID, OWNERLASTNAME, OWNERFIRSTNAME
FROM ANTIQUES, ANTIQUEOWNERS
WHERE SELLERID = OWNERID
ORDER BY OWNERLASTNAME, OWNERFIRSTNAME, OWNERID;</p>
<p>In this example, since everyone has sold an item, we will get a listing of all of the owners, in alphabetical order by last name. For future reference (and in case anyone asks), this type of join is considered to be in the category of inner joins.</p>
<p><a href=""></a><strong>Aliases &amp; In/Subqueries</strong></p>
<p>In this section, we will talk about Aliases, In and the use of subqueries, and how these can be used in a 3-table example. First, look at this query which prints the last name of those owners who have placed an order and what the order is, only listing those orders which can be filled (that is, there is a buyer who owns that ordered item):</p>
<p>SELECT OWN.OWNERLASTNAME Last Name, ORD.ITEMDESIRED Item Ordered
FROM ORDERS ORD, ANTIQUEOWNERS OWN
WHERE ORD.OWNERID = OWN.OWNERID
AND ORD.ITEMDESIRED IN</p>
<p>(SELECT ITEM
FROM ANTIQUES);</p>
<p>This gives:</p>
<p>Last Name Item Ordered</p>
<hr>
<p>Smith     Table
Smith     Desk
Akins     Chair
Lawson    Mirror</p>
<p>There are several things to note about this query:</p>
<ol>
<li>First, the &quot;Last Name&quot; and &quot;Item Ordered&quot; in the Select lines gives the headers on the report.</li>
<li>The OWN &amp; ORD are aliases; these are new names for the two tables listed in the FROM clause that are used as prefixes for all dot notations of column names in the query (see above). This eliminates ambiguity, especially in the equijoin WHERE clause where both tables have the column named OwnerID, and the dot notation tells SQL that we are talking about two different OwnerID&#39;s from the two different tables.</li>
<li>Note that the Orders table is listed first in the FROM clause; this makes sure listing is done off of that table, and the AntiqueOwners table is only used for the detail information (Last Name).</li>
<li>Most importantly, the AND in the WHERE clause forces the In Subquery to be invoked (&quot;= ANY&quot; or &quot;= SOME&quot; are two equivalent uses of IN). What this does is, the subquery is performed, returning all of the Items owned from the Antiques table, as there is no WHERE clause. Then, for a row from the Orders table to be listed, the ItemDesired must be in that returned list of Items owned from the Antiques table, thus listing an item only if the order can be filled from another owner. You can think of it this way: the subquery returns a set of Items from which each ItemDesired in the Orders table is compared; the In condition is true only if the ItemDesired is in that returned set from the Antiques table.</li>
<li>Also notice, that in this case, that there happened to be an antique available for each one desired...obviously, that won&#39;t always be the case. In addition, notice that when the IN, &quot;= ANY&quot;, or &quot;= SOME&quot; is used, that these keywords refer to any possible row matches, not column matches...that is, you cannot put multiple columns in the subquery Select clause, in an attempt to match the column in the outer Where clause to one of multiple possible column values in the subquery; only one column can be listed in the subquery, and the possible match comes from multiple row values in that one column, not vice-versa.</li>
</ol>
<p>Whew! That&#39;s enough on the topic of complex SELECT queries for now. Now on to other SQL statements.
<strong>Miscellaneous SQL Statements</strong></p>
<p><a href=""></a><strong>Aggregate Functions</strong></p>
<p>I will discuss five important aggregate functions: SUM, AVG, MAX, MIN, and COUNT. They are called aggregate functions because they summarize the results of a query, rather than listing all of the rows.</p>
<ul>
<li>SUM () gives the total of all the rows, satisfying any conditions, of the given column, where the given column is numeric.</li>
<li>AVG () gives the average of the given column.</li>
<li>MAX () gives the largest figure in the given column.</li>
<li>MIN () gives the smallest figure in the given column.</li>
<li>COUNT(/*) gives the number of rows satisfying the conditions.</li>
</ul>
<p>Looking at the tables at the top of the document, let&#39;s look at three examples:</p>
<p>SELECT SUM(SALARY), AVG(SALARY)
FROM EMPLOYEESTATISTICSTABLE;</p>
<p>This query shows the total of all salaries in the table, and the average salary of all of the entries in the table.</p>
<p>SELECT MIN(BENEFITS)
FROM EMPLOYEESTATISTICSTABLE
WHERE POSITION = &#39;Manager&#39;;</p>
<p>This query gives the smallest figure of the Benefits column, of the employees who are Managers, which is 12500.</p>
<p>SELECT COUNT(/*)
FROM EMPLOYEESTATISTICSTABLE
WHERE POSITION = &#39;Staff&#39;;</p>
<p>This query tells you how many employees have Staff status (3).</p>
<p><a href=""></a><strong>Views</strong></p>
<p>In SQL, you might (check your DBA) have access to create views for yourself. What a view does is to allow you to assign the results of a query to a new, personal table, that you can use in other queries, where this new table is given the view name in your FROM clause. When you access a view, the query that is defined in your view creation statement is performed (generally), and the results of that query look just like another table in the query that you wrote invoking the view. For example, to create a view:</p>
<p>CREATE VIEW ANTVIEW AS SELECT ITEMDESIRED FROM ORDERS;</p>
<p>Now, write a query using this view as a table, where the table is just a listing of all Items Desired from the Orders table:</p>
<p>SELECT SELLERID
FROM ANTIQUES, ANTVIEW
WHERE ITEMDESIRED = ITEM;</p>
<p>This query shows all SellerID&#39;s from the Antiques table where the Item in that table happens to appear in the Antview view, which is just all of the Items Desired in the Orders table. The listing is generated by going through the Antique Items one-by-one until there&#39;s a match with the Antview view. Views can be used to restrict database access, as well as, in this case, simplify a complex query.</p>
<p><a href=""></a><strong>Creating New Tables</strong></p>
<p>All tables within a database must be created at some point in time...let&#39;s see how we would create the Orders table:</p>
<p>CREATE TABLE ORDERS
(OWNERID INTEGER NOT NULL,
ITEMDESIRED CHAR(40) NOT NULL);</p>
<p>This statement gives the table name and tells the DBMS about each column in the table. <strong>Please note</strong> that this statement uses generic data types, and that the data types might be different, depending on what DBMS you are using. As usual, check local listings. Some common generic data types are:</p>
<ul>
<li>Char(x) - A column of characters, where x is a number designating the maximum number of characters allowed (maximum length) in the column.</li>
<li>Integer - A column of whole numbers, positive or negative.</li>
<li>Decimal(x, y) - A column of decimal numbers, where x is the maximum length in digits of the decimal numbers in this column, and y is the maximum number of digits allowed after the decimal point. The maximum (4,2) number would be 99.99.</li>
<li>Date - A date column in a DBMS-specific format.</li>
<li>Logical - A column that can hold only two values: TRUE or FALSE.</li>
</ul>
<p>One other note, the NOT NULL means that the column must have a value in each row. If NULL was used, that column may be left empty in a given row.</p>
<p><a href=""></a><strong>Altering Tables</strong></p>
<p>Let&#39;s add a column to the Antiques table to allow the entry of the price of a given Item:</p>
<p>ALTER TABLE ANTIQUES ADD (PRICE DECIMAL(8,2) NULL);</p>
<p>The data for this new column can be updated or inserted as shown later.</p>
<p><a href=""></a><strong>Adding Data</strong></p>
<p>To insert rows into a table, do the following:</p>
<p>INSERT INTO ANTIQUES VALUES (21, 01, &#39;Ottoman&#39;, 200.00);</p>
<p>This inserts the data into the table, as a new row, column-by-column, in the pre-defined order. Instead, let&#39;s change the order and leave Price blank:</p>
<p>INSERT INTO ANTIQUES (BUYERID, SELLERID, ITEM)
VALUES (01, 21, &#39;Ottoman&#39;);</p>
<p><a href=""></a><strong>Deleting Data</strong></p>
<p>Let&#39;s delete this new row back out of the database:</p>
<p>DELETE FROM ANTIQUES
WHERE ITEM = &#39;Ottoman&#39;;</p>
<p>But if there is another row that contains &#39;Ottoman&#39;, that row will be deleted also. Let&#39;s delete all rows (one, in this case) that contain the specific data we added before:</p>
<p>DELETE FROM ANTIQUES
WHERE ITEM = &#39;Ottoman&#39; AND BUYERID = 01 AND SELLERID = 21;</p>
<p><a href=""></a><strong>Updating Data</strong></p>
<p>Let&#39;s update a Price into a row that doesn&#39;t have a price listed yet:</p>
<p>UPDATE ANTIQUES SET PRICE = 500.00 WHERE ITEM = &#39;Chair&#39;;</p>
<p>This sets all Chair&#39;s Prices to 500.00. As shown above, more WHERE conditionals, using AND, must be used to limit the updating to more specific rows. Also, additional columns may be set by separating equal statements with commas.</p>
<p><strong>Miscellaneous Topics</strong></p>
<p><a href=""></a><strong>Indexes</strong></p>
<p>Indexes allow a DBMS to access data quicker (please note: this feature is nonstandard/not available on all systems). The system creates this internal data structure (the index) which causes selection of rows, when the selection is based on indexed columns, to occur faster. This index tells the DBMS where a certain row is in the table given an indexed-column value, much like a book index tells you what page a given word appears. Let&#39;s create an index for the OwnerID in the AntiqueOwners column:</p>
<p>CREATE INDEX OID_IDX ON ANTIQUEOWNERS (OWNERID);</p>
<p>Now on the names:</p>
<p>CREATE INDEX NAME_IDX ON ANTIQUEOWNERS (OWNERLASTNAME, OWNERFIRSTNAME);</p>
<p>To get rid of an index, drop it:</p>
<p>DROP INDEX OID_IDX;</p>
<p>By the way, you can also &quot;drop&quot; a table, as well (careful!--that means that your table is deleted). In the second example, the index is kept on the two columns, aggregated together--strange behavior might occur in this situation...check the manual before performing such an operation.</p>
<p>Some DBMS&#39;s do not enforce primary keys; in other words, the uniqueness of a column is not enforced automatically. What that means is, if, for example, I tried to insert another row into the AntiqueOwners table with an OwnerID of 02, some systems will allow me to do that, even though, we do not, as that column is supposed to be unique to that table (every row value is supposed to be different). One way to get around that is to create a unique index on the column that we want to be a primary key, to force the system to enforce prohibition of duplicates:</p>
<p>CREATE UNIQUE INDEX OID_IDX ON ANTIQUEOWNERS (OWNERID);</p>
<p><a href=""></a><strong>GROUP BY &amp; HAVING</strong></p>
<p>One special use of GROUP BY is to associate an aggregate function (especially COUNT; counting the number of rows in each group) with groups of rows. First, assume that the Antiques table has the Price column, and each row has a value for that column. We want to see the price of the most expensive item bought by each owner. We have to tell SQL to group each owner&#39;s purchases, and tell us the maximum purchase price:</p>
<p>SELECT BUYERID, MAX(PRICE)
FROM ANTIQUES
GROUP BY BUYERID;</p>
<p>Now, say we only want to see the maximum purchase price if the purchase is over $1000, so we use the HAVING clause:</p>
<p>SELECT BUYERID, MAX(PRICE)
FROM ANTIQUES
GROUP BY BUYERID
HAVING PRICE &gt; 1000;</p>
<p><a href=""></a><strong>More Subqueries</strong></p>
<p>Another common usage of subqueries involves the use of operators to allow a Where condition to include the Select output of a subquery. First, list the buyers who purchased an expensive item (the Price of the item is $100 greater than the average price of all items purchased):</p>
<p>SELECT OWNERID
FROM ANTIQUES
WHERE PRICE &gt;</p>
<p>(SELECT AVG(PRICE) + 100
FROM ANTIQUES);</p>
<p>The subquery calculates the average Price, plus $100, and using that figure, an OwnerID is printed for every item costing over that figure. One could use DISTINCT OWNERID, to eliminate duplicates.</p>
<p>List the Last Names of those in the AntiqueOwners table, ONLY if they have bought an item:</p>
<p>SELECT OWNERLASTNAME
FROM ANTIQUEOWNERS
WHERE OWNERID =</p>
<p>(SELECT DISTINCT BUYERID
FROM ANTIQUES);</p>
<p>The subquery returns a list of buyers, and the Last Name is printed for an Antique Owner if and only if the Owner&#39;s ID appears in the subquery list (sometimes called a candidate list).</p>
<p>For an Update example, we know that the gentleman who bought the bookcase has the wrong First Name in the database...it should be John:</p>
<p>UPDATE ANTIQUEOWNERS
SET OWNERFIRSTNAME = &#39;John&#39;
WHERE OWNERID =</p>
<p>(SELECT BUYERID
FROM ANTIQUES
WHERE ITEM = &#39;Bookcase&#39;);</p>
<p>First, the subquery finds the BuyerID for the person(s) who bought the Bookcase, then the outer query updates his First Name.</p>
<p><strong>Remember this rule about subqueries:</strong> when you have a subquery as part of a WHERE condition, the Select clause in the subquery must have columns that match in number and type to those in the Where clause of the outer query. In other words, if you have &quot;WHERE ColumnName = (SELECT...);&quot;, the Select must have only one column in it, to match the ColumnName in the outer Where clause, and they must match in type (both being integers, both being character strings, etc.).</p>
<p><a href=""></a><strong>EXISTS &amp; ALL</strong></p>
<p>EXISTS uses a subquery as a condition, where the condition is True if the subquery returns any rows, and False if the subquery does not return any rows; this is a nonintuitive feature with few unique uses. However, if a prospective customer wanted to see the list of Owners only if the shop dealt in Chairs, try:</p>
<p>SELECT OWNERFIRSTNAME, OWNERLASTNAME
FROM ANTIQUEOWNERS
WHERE EXISTS</p>
<p>(SELECT /*
FROM ANTIQUES
WHERE ITEM = &#39;Chair&#39;);</p>
<p>If there are any Chairs in the Antiques column, the subquery would return a row or rows, making the EXISTS clause true, causing SQL to list the Antique Owners. If there had been no Chairs, no rows would have been returned by the outside query.</p>
<p>ALL is another unusual feature, as ALL queries can usually be done with different, and possibly simpler methods; let&#39;s take a look at an example query:</p>
<p>SELECT BUYERID, ITEM
FROM ANTIQUES
WHERE PRICE &gt;= ALL</p>
<p>(SELECT PRICE
FROM ANTIQUES);</p>
<p>This will return the largest priced item (or more than one item if there is a tie), and its buyer. The subquery returns a list of all Prices in the Antiques table, and the outer query goes through each row of the Antiques table, and if its Price is greater than or equal to every (or ALL) Prices in the list, it is listed, giving the highest priced Item. The reason &quot;&gt;=&quot; must be used is that the highest priced item will be equal to the highest price on the list, because this Item is in the Price list.</p>
<p><a href=""></a><strong>UNION &amp; Outer Joins</strong></p>
<p>There are occasions where you might want to see the results of multiple queries together, combining their output; use UNION. To merge the output of the following two queries, displaying the ID&#39;s of all Buyers, plus all those who have an Order placed:</p>
<p>SELECT BUYERID
FROM ANTIQUEOWNERS
UNION
SELECT OWNERID
FROM ORDERS;</p>
<p>Notice that SQL requires that the Select list (of columns) must match, column-by-column, in data type. In this case BuyerID and OwnerID are of the same data type (integer). Also notice that SQL does automatic duplicate elimination when using UNION (as if they were two &quot;sets&quot;); in single queries, you have to use DISTINCT.</p>
<p>The outer join is used when a join query is &quot;united&quot; with the rows not included in the join, and are especially useful if constant text &quot;flags&quot; are included. First, look at the query:</p>
<p>SELECT OWNERID, &#39;is in both Orders &amp; Antiques&#39;
FROM ORDERS, ANTIQUES
WHERE OWNERID = BUYERID
UNION
SELECT BUYERID, &#39;is in Antiques only&#39;
FROM ANTIQUES
WHERE BUYERID NOT IN</p>
<p>(SELECT OWNERID
FROM ORDERS);</p>
<p>The first query does a join to list any owners who are in both tables, and putting a tag line after the ID repeating the quote. The UNION merges this list with the next list. The second list is generated by first listing those ID&#39;s not in the Orders table, thus generating a list of ID&#39;s excluded from the join query. Then, each row in the Antiques table is scanned, and if the BuyerID is not in this exclusion list, it is listed with its quoted tag. There might be an easier way to make this list, but it&#39;s difficult to generate the informational quoted strings of text.</p>
<p>This concept is useful in situations where a primary key is related to a foreign key, but the foreign key value for some primary keys is NULL. For example, in one table, the primary key is a salesperson, and in another table is customers, with their salesperson listed in the same row. However, if a salesperson has no customers, that person&#39;s name won&#39;t appear in the customer table. The outer join is used if the listing of <strong>all</strong> salespersons is to be printed, listed with their customers, whether the salesperson has a customer or not--that is, no customer is printed (a logical NULL value) if the salesperson has no customers, but is in the salespersons table. Otherwise, the salesperson will be listed with each customer.</p>
<p>ENOUGH QUERIES!!! you say?...now on to something completely different...</p>
<p><a href=""></a><strong>Embedded SQL--an ugly example (do not write a program like this...for purposes of argument ONLY)</strong></p>
<p>//<em> -To get right to it, here is an example program that uses Embedded
    SQL. Embedded SQL allows programmers to connect to a database and
    include SQL code right in the program, so that their programs can
    use, manipulate, and process data from a database.
   -This example C Program (using Embedded SQL) will print a report.
   -This program will have to be precompiled for the SQL statements,
    before regular compilation.
   -The EXEC SQL parts are the same (standard), but the surrounding C
    code will need to be changed, including the host variable
    declarations, if you are using a different language.
   -Embedded SQL changes from system to system, so, once again, check
    local documentation, especially variable declarations and logging
    in procedures, in which network, DBMS, and operating system
    considerations are crucial. /</em>/</p>
<p>//<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/
//<em> THIS PROGRAM IS NOT COMPILABLE OR EXECUTABLE /</em>/
//<em> IT IS FOR EXAMPLE PURPOSES ONLY              /</em>/
//<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/</p>
<p>/#include <stdio.h></p>
<p>//<em> This section declares the host variables; these will be the
   variables your program uses, but also the variable SQL will put
   values in or take values out. /</em>/
EXEC SQL BEGIN DECLARE SECTION;
  int BuyerID;
  char FirstName[100], LastName[100], Item[100];
EXEC SQL END DECLARE SECTION;</p>
<p>//<em> This includes the SQLCA variable, so that some error checking can be done. /</em>/
EXEC SQL INCLUDE SQLCA;</p>
<p>main() {</p>
<p>//<em> This is a possible way to log into the database /</em>/
EXEC SQL CONNECT UserID/Password;</p>
<p>//<em> This code either says that you are connected or checks if an error
   code was generated, meaning log in was incorrect or not possible. /</em>/   if(sqlca.sqlcode) {
    printf(Printer, &quot;Error connecting to database server.\n&quot;);
    exit();
  }
  printf(&quot;Connected to database server.\n&quot;);</p>
<p>//<em> This declares a &quot;Cursor&quot;. This is used when a query returns more
   than one row, and an operation is to be performed on each row
   resulting from the query. With each row established by this query,
   I&#39;m going to use it in the report. Later, &quot;Fetch&quot; will be used to
   pick off each row, one at a time, but for the query to actually
   be executed, the &quot;Open&quot; statement is used. The &quot;Declare&quot; just
   establishes the query. /</em>/
EXEC SQL DECLARE ItemCursor CURSOR FOR
  SELECT ITEM, BUYERID
  FROM ANTIQUES
  ORDER BY ITEM;
EXEC SQL OPEN ItemCursor;</p>
<p>//<em> +-- You may wish to put a similar error checking block here --+ /</em>/</p>
<p>//<em> Fetch puts the values of the &quot;next&quot; row of the query in the host
   variables, respectively. However, a &quot;priming fetch&quot; (programming
   technique) must first be done. When the cursor is out of data, a
   sqlcode will be generated allowing us to leave the loop. Notice
   that, for simplicity&#39;s sake, the loop will leave on any sqlcode,
   even if it is an error code. Otherwise, specific code checking must
   be performed. /</em>/
EXEC SQL FETCH ItemCursor INTO :Item, :BuyerID;
  while(!sqlca.sqlcode) {</p>
<p>//<em> With each row, we will also do a couple of things. First, bump the
   price up by $5 (dealer&#39;s fee) and get the buyer&#39;s name to put in
   the report. To do this, I&#39;ll use an Update and a Select, before
   printing the line on the screen. The update assumes however, that
   a given buyer has only bought one of any given item, or else the
   price will be increased too many times. Otherwise, a &quot;RowID&quot; logic
   would have to be used (see documentation). Also notice the colon    before host variable names when used inside of SQL statements. /</em>/</p>
<p>EXEC SQL UPDATE ANTIQUES
  SET PRICE = PRICE + 5
  WHERE ITEM = :Item AND BUYERID = :BuyerID;</p>
<p>EXEC SQL SELECT OWNERFIRSTNAME, OWNERLASTNAME
  INTO :FirstName, :LastName
  FROM ANTIQUEOWNERS
  WHERE BUYERID = :BuyerID;</p>
<pre><code>printf(&quot;%25s %25s %25s&quot;, FirstName, LastName, Item);
</code></pre><p>//<em> Ugly report--for example purposes only! Get the next row. /</em>/
EXEC SQL FETCH ItemCursor INTO :Item, :BuyerID;
  }</p>
<p>//<em> Close the cursor, commit the changes (see below), and exit the
   program. /</em>/
EXEC SQL CLOSE DataCursor;
EXEC SQL COMMIT RELEASE;
  exit();
}</p>
<p><a href=""></a><strong>Common SQL Questions--Advanced Topics (see FAQ link for several more)</strong></p>
<ol>
<li>Why can&#39;t I just ask for the first three rows in a table? --Because in relational databases, rows are inserted in no particular order, that is, the system inserts them in an arbitrary order; so, you can only request rows using valid SQL features, like ORDER BY, etc.</li>
<li>What is this DDL and DML I hear about? --DDL (Data Definition Language) refers to (in SQL) the Create Table statement...DML (Data Manipulation Language) refers to the Select, Update, Insert, and Delete statements.</li>
<li>Aren&#39;t database tables just files? --Well, DBMS&#39;s store data in files declared by system managers before new tables are created (on large systems), but the system stores the data in a special format, and may spread data from one table over several files. In the database world, a set of files created for a database is called a tablespace. In general, on small systems, everything about a database (definitions and all table data) is kept in one file.</li>
<li>(Related question) Aren&#39;t database tables just like spreadsheets? --No, for two reasons. First, spreadsheets can have data in a cell, but a cell is more than just a row-column-intersection. Depending on your spreadsheet software, a cell might also contain formulas and formatting, which database tables cannot have (currently). Secondly, spreadsheet cells are often dependent on the data in other cells. In databases, &quot;cells&quot; are independent, except that columns are logically related (hopefully; together a row of columns describe an entity), and, other than primary key and foreign key constraints, each row in a table in independent from one another.</li>
<li>How do I import a text file of data into a database? --Well, you can&#39;t do it directly...you must use a utility, such as Oracle&#39;s SQL/*Loader, or write a program to load the data into the database. A program to do this would simply go through each record of a text file, break it up into columns, and do an Insert into the database.</li>
<li>What is a schema? --A schema is a logical set of tables, such as the Antiques database above...usually, it is thought of as simply &quot;the database&quot;, but a database can hold more than one schema. For example, a star schema is a set of tables where one large, central table holds all of the important information, and is linked, via foreign keys, to dimension tables which hold detail information, and can be used in a join to create detailed reports.</li>
<li>What are some general tips you would give to make my SQL queries and databases better and faster (optimized)?</li>
</ol>
<ul>
<li>You should try, if you can, to avoid expressions in Selects, such as SELECT ColumnA + ColumnB, etc. The query optimizer of the database, the portion of the DBMS that determines the best way to get the required data out of the database itself, handles expressions in such a way that would normally require more time to retrieve the data than if columns were normally selected, and the expression itself handled programmatically.</li>
<li>Minimize the number of columns included in a Group By clause.</li>
<li>If you are using a join, try to have the columns joined on (from both tables) indexed.</li>
<li>When in doubt, index.</li>
<li><p>Unless doing multiple counts or a complex query, use COUNT(/*) (the number of rows generated by the query) rather than COUNT(Column_Name).</p>
</li>
<li><p>What is normalization? --Normalization is a technique of database design that suggests that certain criteria be used when constructing a table layout (deciding what columns each table will have, and creating the key structure), where the idea is to eliminate redundancy of non-key data across tables. Normalization is usually referred to in terms of forms, and I will introduce only the first three, even though it is somewhat common to use other, more advanced forms (fourth, fifth, Boyce-Codd; see documentation).
First Normal Form refers to moving data into separate tables where the data in each table is of a similar type, and by giving each table a primary key.
Putting data in Second Normal Form involves taking out data off to other tables that is only dependent of a part of the key. For example, if I had left the names of the Antique Owners in the items table, that would not be in second normal form because that data would be redundant; the name would be repeated for each item owned, so the names were placed in their own table. The names themselves don&#39;t have anything to do with the items, only the identities of the buyers and sellers.
Third Normal Form involves getting rid of anything in the tables that doesn&#39;t depend solely on the primary key. Only include information that is dependent on the key, and move off data to other tables that are independent of the primary key, and create a primary keys for the new tables.
There is some redundancy to each form, and if data is in 3NF(shorthand for 3rd normal form), it is already in 1NFand 2NF. In terms of data design then, arrange data so that any non-primary key columns are dependent only on the whole primary key. If you take a look at the sample database, you will see that the way then to navigate through the database is through joins using common key columns.
Two other important points in database design are using good, consistent, logical, full-word names for the tables and columns, and the use of full words in the database itself. On the last point, my database is lacking, as I use numeric codes for identification. It is usually best, if possible, to come up with keys that are, by themselves, self-explanatory; for example, a better key would be the first four letters of the last name and first initial of the owner, like JONEB for Bill Jones (or for tiebreaking purposes, add numbers to the end to differentiate two or more people with similar names, so you could try JONEB1, JONEB2, etc.).</p>
</li>
<li>What is the difference between a single-row query and a multiple-row query and why is it important to know the difference? --First, to cover the obvious, a single-row query is a query that returns one row as its result, and a multiple-row query is a query that returns more than one row as its result. Whether a query returns one row or more than one row is entirely dependent on the design (or schema) of the tables of the database. As query-writer, you must be aware of the schema, be sure to include enough conditions, and structure your SQL statement properly, so that you will get the desired result (either one row or multiple rows). For example, if you wanted to be sure that a query of the AntiqueOwners table returned only one row, consider an equal condition of the primary key-column, OwnerID.
Three reasons immediately come to mind as to why this is important. First, getting multiple rows when you were expecting only one, or vice-versa, may mean that the query is erroneous, that the database is incomplete, or simply, you learned something new about your data. Second, if you are using an update or delete statement, you had better be sure that the statement that you write performs the operation on the desired row (or rows)...or else, you might be deleting or updating more rows than you intend. Third, any queries written in Embedded SQL must be carefully thought out as to the number of rows returned. If you write a single-row query, only one SQL statement may need to be performed to complete the programming logic required. If your query, on the other hand, returns multiple rows, you will have to use the Fetch statement, and quite probably, some sort of looping structure in your program will be required to iterate processing on each returned row of the query.</li>
<li>What are relationships? --Another design question...the term &quot;relationships&quot; (often termed &quot;relation&quot;) usually refers to the relationships among primary and foreign keys between tables. This concept is important because when the tables of a relational database are designed, these relationships must be defined because they determine which columns are or are not primary or foreign keys. You may have heard of an <strong>Entity-Relationship Diagram</strong>, which is a graphical view of tables in a database schema, with lines connecting related columns across tables. See the sample diagram at the end of this section or some of the sites below in regard to this topic, as there are many different ways of drawing E-R diagrams. But first, let&#39;s look at each kind of relationship...
A One-to-one relationship means that you have a primary key column that is related to a foreign key column, and that for every primary key value, there is <strong>one</strong> foreign key value. For example, in the first example, the EmployeeAddressTable, we add an EmployeeIDNo column. Then, the EmployeeAddressTable is related to the EmployeeStatisticsTable (second example table) by means of that EmployeeIDNo. Specifically, each employee in the EmployeeAddressTable <strong>has</strong> statistics (one row of data) in the EmployeeStatisticsTable. Even though this is a contrived example, this is a &quot;1-1&quot; relationship. Also notice the &quot;has&quot; in bold...when expressing a relationship, it is important to describe the relationship with a verb.
The other two kinds of relationships may or may not use logical primary key and foreign key constraints...it is strictly a call of the designer. The first of these is the one-to-many relationship (&quot;1-M&quot;). This means that for every column value in one table, there is <strong>one or more</strong> related values in another table. Key constraints may be added to the design, or possibly just the use of some sort of identifier column may be used to establish the relationship. An example would be that for every OwnerID in the AntiqueOwners table, there are one or more (zero is permissible too) Items <strong>bought</strong> in the Antiques table (verb: buy).
Finally, the many-to-many relationship (&quot;M-M&quot;) does not involve keys generally, and usually involves idenifying columns. The unusual occurence of a &quot;M-M&quot; means that one column in one table is related to another column in another table, and for every value of one of these two columns, there are one or more related values in the corresponding column in the other table (and vice-versa), or more a common possibility, two tables have a 1-M relationship to each other (two relationships, one 1-M going each way). A [bad] example of the more common situation would be if you had a job assignment database, where one table held one row for each employee and a job assignment, and another table held one row for each job with one of the assigned employees. Here, you would have multiple rows for each employee in the first table, one for each job assignment, and multiple rows for each job in the second table, one for each employee assigned to the project. These tables have a M-M: each employee in the first table <strong>has</strong> many job assignments from the second table, and each job <strong>has</strong> many employees assigned to it from the first table. This is the tip of the iceberg on this topic...see the links below for more information and see the diagram below for a simplified example of an E-R diagram.
<img src="http://zql.sourceforge.net/erdiagram.gif" alt="Sample Simplified Entity-Relationship Diagram"></li>
<li>What are some important nonstandard SQL features (extremely common question)? --Well, see the next section...</li>
</ul>
<p><a href=""></a><strong>Nonstandard SQL...&quot;check local listings&quot;</strong></p>
<ul>
<li>INTERSECT and MINUS are like the UNION statement, except that INTERSECT produces rows that appear in both queries, and MINUS produces rows that result from the first query, but not the second.</li>
<li>Report Generation Features: the COMPUTE clause is placed at the end of a query to place the result of an aggregate function at the end of a listing, like COMPUTE SUM (PRICE); Another option is to use break logic: define a break to divide the query results into groups based on a column, like BREAK ON BUYERID. Then, to produce a result after the listing of a group, use COMPUTE SUM OF PRICE ON BUYERID. If, for example, you used all three of these clauses (BREAK first, COMPUTE on break second, COMPUTE overall sum third), you would get a report that grouped items by their BuyerID, listing the sum of Prices after each group of a BuyerID&#39;s items, then, after all groups are listed, the sum of all Prices is listed, all with SQL-generated headers and lines.</li>
<li>In addition to the above listed aggregate functions, some DBMS&#39;s allow more functions to be used in Select lists, except that these functions (some character functions allow multiple-row results) are to be used with an individual value (not groups), on single-row queries.The functions are to be used only on appropriate data types, also. Here are some <strong>Mathematical Functions</strong>:
<strong>ABS(X)</strong> Absolute value-converts negative numbers to positive, or leaves positive numbers alone <strong>CEIL(X)</strong> X is a decimal value that will be rounded up. <strong>FLOOR(X)</strong> X is a decimal value that will be rounded down. <strong>GREATEST(X,Y)</strong> Returns the largest of the two values. <strong>LEAST(X,Y)</strong> Returns the smallest of the two values. <strong>MOD(X,Y)</strong> Returns the remainder of X / Y. <strong>POWER(X,Y)</strong> Returns X to the power of Y. <strong>ROUND(X,Y)</strong> Rounds X to Y decimal places. If Y is omitted, X is rounded to the nearest integer. <strong>SIGN(X)</strong> Returns a minus if X &lt; 0, else a plus. <strong>SQRT(X)</strong> Returns the square root of X. <strong>Character Functions</strong>
<strong>LEFT(<string>,X)</strong> Returns the leftmost X characters of the string. <strong>RIGHT(<string>,X)</strong> Returns the rightmost X characters of the string. <strong>UPPER(<string>)</strong> Converts the string to all uppercase letters. <strong>LOWER(<string>)</strong> Converts the string to all lowercase letters. <strong>INITCAP(<string>)</strong> Converts the string to initial caps. <strong>LENGTH(<string>)</strong> Returns the number of characters in the string. <strong><string>||<string></strong> Combines the two strings of text into one, concatenated string, where the first string is immediately followed by the second. <strong>LPAD(<string>,X,&#39;/*&#39;)</strong> Pads the string on the left with the /<em> (or whatever character is inside the quotes), to make the string X characters long. **RPAD(<string>,X,&#39;/</em>&#39;)<strong> Pads the string on the right with the /* (or whatever character is inside the quotes), to make the string X characters long. </strong>SUBSTR(<string>,X,Y)<strong> Extracts Y letters from the string beginning at position X. </strong>NVL(<column>,<value>)** The Null value function will substitute <value> for any NULLs for in the <column>. If the current value of <column> is not NULL, NVL has no effect.</li>
</ul>
<p><a href=""></a><strong>Syntax Summary--For Advanced Users Only</strong></p>
<p>Here are the general forms of the statements discussed in this tutorial, plus some extra important ones (explanations given). <strong>REMEMBER</strong> that all of these statements may or may not be available on your system, so check documentation regarding availability:</p>
<p><strong>ALTER TABLE</strong><TABLE NAME> ADD|DROP|MODIFY (COLUMN SPECIFICATION[S]...see Create Table); --allows you to add or delete a column or columns from a table, or change the specification (data type, etc.) on an existing column; this statement is also used to change the physical specifications of a table (how a table is stored, etc.), but these definitions are DBMS-specific, so read the documentation. Also, these physical specifications are used with the Create Table statement, when a table is first created. In addition, only one option can be performed per Alter Table statement--either add, drop, <strong>OR</strong>modify in a single statement.</p>
<p><strong>COMMIT</strong>; --makes changes made to some database systems permanent (since the last COMMIT; known as a transaction)</p>
<p><strong>CREATE [UNIQUE] INDEX</strong> <INDEX NAME>
ON <TABLE NAME> (<COLUMN LIST>); --UNIQUE is optional; within brackets.</p>
<p><strong>CREATE TABLE</strong> <TABLE NAME>
(<COLUMN NAME> <DATA TYPE> [(<SIZE>)] <COLUMN CONSTRAINT>,
...other columns); (also valid with ALTER TABLE)
--where SIZE is only used on certain data types (see above), and constraints include the following possibilities (automatically enforced by the DBMS; failure causes an error to be generated):</p>
<ol>
<li>NULL or NOT NULL (see above)</li>
<li>UNIQUE enforces that no two rows will have the same value for this column</li>
<li>PRIMARY KEY tells the database that this column is the primary key column (only used if the key is a one column key, otherwise a PRIMARY KEY (column, column, ...) statement appears after the last column definition.</li>
<li>CHECK allows a condition to be checked for when data in that column is updated or inserted; for example, CHECK (PRICE &gt; 0) causes the system to check that the Price column is greater than zero before accepting the value...sometimes implemented as the CONSTRAINT statement.</li>
<li>DEFAULT inserts the default value into the database if a row is inserted without that column&#39;s data being inserted; for example, BENEFITS INTEGER DEFAULT = 10000</li>
<li>FOREIGN KEY works the same as Primary Key, but is followed by: REFERENCES <TABLE NAME> (<COLUMN NAME>), which refers to the referential primary key.</li>
</ol>
<p><strong>CREATE VIEW</strong> <TABLE NAME> AS <QUERY>;</p>
<p><strong>DELETE</strong> FROM <TABLE NAME> WHERE <CONDITION>;</p>
<p><strong>INSERT</strong> INTO <TABLE NAME> [(<COLUMN LIST>)]
VALUES (<VALUE LIST>);</p>
<p><strong>ROLLBACK</strong>; --Takes back any changes to the database that you have made, back to the last time you gave a Commit command...beware! Some software uses automatic committing on systems that use the transaction features, so the Rollback command may not work.</p>
<p><strong>SELECT</strong> [DISTINCT|ALL] <LIST OF COLUMNS, FUNCTIONS, CONSTANTS, ETC.>
FROM <LIST OF TABLES OR VIEWS>
[WHERE <CONDITION(S)>]
[GROUP BY <GROUPING COLUMN(S)>]
[HAVING <CONDITION>]
[ORDER BY <ORDERING COLUMN(S)> [ASC|DESC]]; --where ASC|DESC allows the ordering to be done in ASCending or DESCending order</p>
<p><strong>UPDATE</strong> <TABLE NAME>
SET <COLUMN NAME> = <VALUE>
[WHERE <CONDITION>]; --if the Where clause is left out, all rows will be updated according to the Set statement</p>
<p><a href=""></a><strong>Important Links</strong></p>
<p>Computing &amp; SQL/DB Links: <a href="http://home.netscape.com/" target="_blank">Netscape</a> -- <a href="http://www.oracle.com/" target="_blank">Oracle</a> -- <a href="http://www.sybase.com/" target="_blank">Sybase</a> -- <a href="http://www.informix.com/" target="_blank">Informix</a> --<a href="http://www.microsoft.com/">Microsoft
</a><a href="http://www.contrib.andrew.cmu.edu/~shadow/sql.html" target="_blank">SQL Reference Page</a> -- <a href="http://www.inquiry.com/techtips/thesqlpro/" target="_blank">Ask the SQL Pro</a> -- <a href="http://www.inquiry.com/techtips/thesqlpro/usefulsites.html">SQL Pro&#39;s Relational DB Useful Sites
</a><a href="http://infoweb.magi.com/~steve/develop.html" target="_blank">Programmer&#39;s Source</a> -- <a href="http://info.itu.ch/special/wwwfiles/comp_db.html" target="_blank">DBMS Sites</a> -- <a href="http://www.inquiry.com/" target="_blank">inquiry.com</a> -- <a href="http://www.compapp.dcu.ie/databases/f017.html" target="_blank">DB Ingredients</a>
<a href="http://www.stars.com/Tutorial/CGI/" target="_blank">Web Authoring</a> -- <a href="http://wfn-shop.princeton.edu/cgi-bin/foldoc" target="_blank">Computing Dictionary</a> -- <a href="http://www-ccs.cs.umass.edu/db.html" target="_blank">DBMS Lab/Links</a> -- <a href="http://epoch.cs.berkeley.edu:8000/sequoia/dba/montage/FAQ/SQL_TOC.html" target="_blank">SQL FAQ</a> -- <a href="http://chaos.mur.csu.edu.au/itc125/cgi/sqldb.html" target="_blank">SQL Databases</a>
<a href="http://www.it.rit.edu/~wjs/IT/199602/icsa720/icsa720postings.html" target="_blank">RIT Database Design Page</a> -- <a href="http://www.pcslink.com/~ej/dbweb.html" target="_blank">Database Jump Site</a> -- <a href="http://www.eng.uc.edu/~jtilley/tutorial.html" target="_blank">Programming Tutorials on the Web</a>
<a href="http://www.ndev.com/ndc2/support/resources.htp" target="_blank">Development Resources</a> -- <a href="http://ashok.pair.com/sql.htm" target="_blank">Query List</a> -- <a href="http://jazz.external.hp.com/training/sqltables/main.html" target="_blank">IMAGE SQL</a></p>
<p>Miscellaneous: <a href="http://www.cnn.com/" target="_blank">CNN</a> -- <a href="http://www.usatoday.com/" target="_blank">USA Today</a> -- <a href="http://www.pathfinder.com/" target="_blank">Pathfinder</a> -- <a href="http://www.zdnet.com/" target="_blank">ZDNet</a> -- <a href="http://metroscope.com/" target="_blank">Metroscope</a> -- <a href="http://www.cnet.com/" target="_blank">CNet</a>
<a href="http://www.eit.com/web/netservices.html" target="_blank">Internet Resource List</a> -- <a href="http://netcast.noaa.gov/cgi-bin/page?pg=netcast" target="_blank">Netcast Weather</a> -- <a href="http://www.techweb.com/" target="_blank">TechWeb</a> -- <a href="http://www.looksmart.com/" target="_blank">LookSmart</a></p>
<p>Search Engines: <a href="http://www.yahoo.com/" target="_blank">Yahoo</a> -- <a href="http://www.altavista.digital.com/" target="_blank">Alta Vista</a> -- <a href="http://www.excite.com/" target="_blank">Excite</a> -- <a href="http://webcrawler.com/" target="_blank">WebCrawler</a> -- <a href="http://www.lycos.com/" target="_blank">Lycos</a> -- <a href="http://www.infoseek.com/" target="_blank">Infoseek</a> -- <a href="http://www.search.com/" target="_blank">search.com</a></p>
<p>These sites are not endorsed by the author.
<strong>Disclaimer</strong></p>
<p>I hope you have learned something from this introductory look at a very important language that is becoming more prevalent in the world of client-server computing. I wrote this web page in order to contribute something of value to the web and the web community. In fact, I have been informed that this document is being used at several colleges for use in database classes and for use by researchers. Also, look for this page in Waite Publishing&#39;s newest book about Borland C++ Builder, which will be out this summer, and in an upcoming Sams Publishing release. In addition, I would like to thank all of the people from across five continents who have contacted me regarding this web page.</p>
<p>I also hope to continue to add more material to this tutorial, such as topics about database design and nonstandard SQL extensions, even though I wish to stay away from material about individual Database Management Systems. Good luck in your SQL and other computing adventures.</p>
<p>Jim Hoffman
Comments or suggestions? Mail me at <a href="mailto:jhoffman@one.net">jhoffman@one.net.</a></p>
<p>Or you may wish to look at <a href="http://w3.one.net/~jhoffman/index.html" target="_blank">Jim Hoffman&#39;s Web Pages</a> for more information about myself.</p>
<p>Copyright 1996-1997, James Hoffman. This document can be used for free by any Internet user, but cannot be included in another document, published in any other form, or mass produced in any way.</p>
<p>This page is best viewed with <a href="http://home.netscape.com/" target="_blank">Netscape Navigator</a>; it doesn&#39;t look quite right with <a href="http://www.microsoft.com/ie" target="_blank">Microsoft Internet Explorer.</a></p>
<p>Last updated: 8-25-1997; added some material.</p>
<p><a href="http://w3.one.net/~jhoffman/sqltut.htm" target="_blank">http://w3.one.net/~jhoffman/sqltut.htm</a>
来源： <a href="[http://zql.sourceforge.net/sqltut.html](http://zql.sourceforge.net/sqltut.html)">[http://zql.sourceforge.net/sqltut.html](http://zql.sourceforge.net/sqltut.html)</a>  </p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/SQL_Java/">SQL_Java</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/SQL_Java/" class="label label-success">SQL_Java</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:41"datetime="2014-03-07 09:54:41"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-SQL_Java--IntroductiontoStructuredQueryLanguageZQL/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-SQL_Java--IntroductiontoStructuredQueryLanguageZQL" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-java深入分析--Hash表分析以及Java实现/">Hash表分析以及Java实现</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:41.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-java深入分析--Hash表分析以及Java实现/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="hash-java-">Hash表分析以及Java实现</h1>
<p><strong><a href="http://java-mzd.iteye.com/blog/827523" target="_blank">Hash表分析以及Java实现</a></strong></p>
<p><strong>文章分类**</strong>:<a href="http://www.iteye.com/blogs/category/tech" target="_blank">综合技术</a>**</p>
<pre><code>   这篇博客主要探讨**Hash****表**中的一些原理/概念，及根据这些原理/概念，自己设计一个用来存放/查找数据的Hash表，并且与JDK中的HashMap类进行比较。
</code></pre><p>我们分一下七个步骤来进行。 </p>
<p><strong>一。**</strong>   Hash<strong>**表概念</strong></p>
<p><strong>二**</strong>.      Hash<strong>**构造函数的方法，及适用范围</strong></p>
<p><strong>三**</strong>.       Hash<strong>**处理冲突方法，各自特征</strong></p>
<p><strong>四**</strong>.       Hash<strong>**查找过程</strong></p>
<p><strong>五**</strong>.       <strong><strong>实现一个使用</strong></strong>Hash<strong><strong>存数据的场景</strong></strong>-------Hash<strong>**查找算法，插入算法</strong></p>
<p><strong>六**</strong>.       JDK<strong><strong>中</strong></strong>HashMap<strong>**的实现</strong></p>
<p><strong>七**</strong>.       Hash<strong><strong>表与</strong></strong>HashMap<strong>**的对比，性能分析</strong></p>
<p> <strong>一。**</strong>   Hash<strong><strong>表概念</strong></strong> **</p>
<pre><code>           在查找表中我们已经说过，在Hash表中，**记录在表中的位置和其关键字之间存在着一种确定的关系**。这样       我们就能预先知道所查关键字在表中的位置，从而直接通过下标找到记录。使ASL趋近与0.



          1) **  **哈希(Hash)函数是一个映象，即： 将关键字的集合映射到某个地址集合上，它的设置很灵活，只要这个地       址集合的大小不超出允许范围即可；

         2)  由于哈希函数是一个压缩映象，因此，在一般情况下，很容易产生“冲突”现象，即： key1¹ key2，而  f            (key1) = f(key2)。

          3).  只能尽量减少冲突而不能完全避免冲突，这是因为通常关键字集合比较大，其元素包括所有可能的关键字，       而地址集合的元素仅为哈希表中的地址值



   在构造这种特殊的“查找表” 时，除了需要选择一个**“****好****”(****尽可能少产生冲突****)**的哈希函数之外；还需要找到一      种**“****处理冲突****”** 的方法。
</code></pre><p><strong>二**</strong>.     Hash<strong>**构造函数的方法，及适用范围</strong></p>
<p>§    <strong>直接定址法</strong></p>
<p>§    <strong>数字分析法</strong></p>
<p>§    <strong>平方取中法</strong></p>
<p>§    <strong>折叠法</strong></p>
<p>§    <strong>除留余数法</strong></p>
<p>§    <strong>随机数法</strong>      </p>
<pre><code>  （1）直接定址法：

            哈希函数为关键字的线性函数，H(key) = key 或者 H(key) = a ´ key + b

          **此法仅适合于**：地址集合的大小 = = 关键字集合的大小，其中a和b为常数。

 （2）数字分析法：

         假设关键字集合中的每个关键字都是由 s 位数字组成 (u1, u2, …, us)，分析关键字集中的全体，                  并从中提取分布均匀的若干位或它们的组合作为地址。

         **此法适于:**能预先估计出全体关键字的每一位上各种数字出现的频度。

 （3）平方取中法：

           以关键字的平方值的中间几位作为存储地址。求“关键字的平方值” 的目的是“扩大差别” ，同                    时平方值的中间各位又能受到整个关键字中各位的影响。

         **此法适于:**关键字中的每一位都有某些数字重复出现频度很高的现象。

 （4）折叠法：

        将关键字分割成若干部分，然后取它们的叠加和为哈希地址。两种叠加处理的方法：移位叠加:将分                割后的几部分低位对齐相加；间界叠加:从一端沿分割界来回折叠，然后对齐相加。

        **此法适于：**关键字的数字位数特别多。

 （5）除留余数法：

         设定哈希函数为:H(key) = key MOD p   ( p≤m )，其中， m为表长，p 为不大于 m 的素数，或                 是不含 20 以下的质因子

 （6）随机数法：

       设定哈希函数为:H(key) = Random(key)其中，Random 为伪随机函数

       **此法适于：**对长度不等的关键字构造哈希函数。



     实际造表时，采用何种构造哈希函数的方法取决于建表的关键字集合的情况(包括关键字的范围和形态)，以及哈希表    长度（哈希地址范围），**总的原则是使产生冲突的可能性降到尽可能地小。**
</code></pre><p><strong>三**</strong>.       Hash<strong>**处理冲突方法，各自特征</strong></p>
<p> <strong>“**</strong>处理冲突” 的实际含义是：为产生冲突的关键字寻找下一个哈希地址。**</p>
<p>§    <strong>  **</strong>开放定址法**</p>
<p>§    <strong>  **</strong>再哈希法**</p>
<p>§    <strong>  **</strong>链地址法**</p>
<pre><code>  （1）开放定址法：

           为产生冲突的关键字地址 H(key) 求得一个地址序列： H0, H1, H2, …, Hs  1≤s≤m-1，Hi = ( H(key)                 +di  ) MOD m，其中： i=1, 2, …, s，H(key)为哈希函数;m为哈希表长;



  （2）链地址法：
</code></pre><p><img src="" alt="http://dl.iteye.com/upload/attachment/355453/2a1ac1de-80ef-33d5-a120-9a8f07dbf3e9.jpg"></p>
<pre><code>         将所有哈希地址相同的记录都链接在同一链表中。



  （3）再哈希法：

           方法：构造若干个哈希函数，当发生冲突时，根据另一个哈希函数计算下一个哈希地址，直到冲突不再发                  生。即：Hi=Rhi(key)     i=1,2,……k，其中：Rhi——不同的哈希函数，特点：计算时间增加
</code></pre><p> <strong>四**</strong>.       Hash<strong>**查找过程</strong></p>
<p><img src="" alt="http://dl.iteye.com/upload/attachment/355455/a946abd8-ba7b-3e4e-b5a5-b94059e086ac.png"></p>
<p><strong>  </strong>      对于给定值 K,计算哈希地址 i = H(K)，若 r[i] = NULL  则查找不成功，若 r[i].key = K  则查找成功， 否则 “求     下一地址 Hi” ，直至r[Hi] = NULL  (查找不成功)  或r[Hi].key = K  (查找成功) 为止。</p>
<p> <strong>五**</strong>.       <strong><strong>实现一个使用</strong></strong>Hash<strong><strong>存数据的场景</strong></strong>-------Hash<strong>**查找算法，插入算法</strong></p>
<pre><code>     假设我们要设计的是一个用来保存中南大学所有在校学生个人信息的数据表。因为在校学生数量也不是特别巨大(8W?)，每个学生的学号是唯一的,因此，我们可以简单的应用直接定址法，声明一个10W大小的数组，每个学生的学号作为主键。然后每次要添加或者查找学生，只需要根据需要去操作即可。

  但是，显然这样做是**很脑残**的。这样做系统的可拓展性和复用性就非常差了，比如有一天人数超过10W了？如果是用来保存别的数据呢？或者我只需要保存20条记录呢？声明大小为10W的数组显然是太浪费了的。



 如果我们是用来保存大数据量（比如银行的用户数，4大的用户数都应该有3-5亿了吧？），这时候我们计算出来的HashCode就很可能会有冲突了， 我们的系统应该有“处理冲突”的能力，此处我们**通过挂链法****“****处理冲突****”**。



 如果我们的数据量非常巨大，并且还持续在增加，如果我们仅仅只是通过挂链法来处理冲突，可能我们的链上挂了上万个数据后，这个时候再通过静态搜索来查找链表，显然性能也是非常低的。所以我们的系统应该还能实现自动扩容，**当容量达到某比例后，即自动扩容，使装载因子保存在一个固定的水平上**。
</code></pre><p>综上所述，我们对这个Hash容器的基本要求应该有如下几点：</p>
<pre><code>         **满足****Hash****表的查找要求（废话）**
</code></pre><p><strong>             **</strong>能支持从小数据量到大数据量的自动转变（自动扩容）**</p>
<p><strong>             **</strong>使用挂链法解决冲突**</p>
<p>好了，既然都分析到这一步了，咱就闲话少叙，直接开始上代码吧。</p>
<p><strong>Java**</strong>代码<strong><strong> </strong></strong> <strong>[</strong><img src="&quot;&quot;收藏这段代码&quot; &quot;" alt="收藏代码]()**"><em>**</em></p>
<ol>
<li><p><strong>package</strong> cn.javamzd.collection.search;  </p>
</li>
<li></li>
<li><p><strong>public</strong> <strong>class</strong> MyMap<K, V> {  </p>
</li>
<li><p><strong>private</strong> <strong>int</strong> size;// 当前容量  </p>
</li>
<li><p><strong>private</strong> <strong>static</strong> <strong>int</strong> INIT_CAPACITY = 16;// 默认容量  </p>
</li>
<li><p><strong>private</strong> Entry<K, V>[] container;// 实际存储数据的数组对象  </p>
</li>
<li><p><strong>private</strong> <strong>static</strong> <strong>float</strong> LOAD_FACTOR = 0.75f;// 装载因子  </p>
</li>
<li><p><strong>private</strong> <strong>int</strong> max;// 能存的最大的数=capacity/*factor  </p>
</li>
<li></li>
<li><p>// 自己设置容量和装载因子的构造器  </p>
</li>
<li><p><strong>public</strong> MyMap(<strong>int</strong> init_Capaticy, <strong>float</strong> load_factor) {  </p>
</li>
<li><p><strong>if</strong> (init_Capaticy &lt; 0)  </p>
</li>
<li><p><strong>throw</strong> <strong>new</strong> IllegalArgumentException(&quot;Illegal initial capacity: &quot;  </p>
</li>
<li><ul>
<li>init_Capaticy);  </li>
</ul>
</li>
<li><p><strong>if</strong> (load_factor &lt;= 0 || Float.isNaN(load_factor))  </p>
</li>
<li><p><strong>throw</strong> <strong>new</strong> IllegalArgumentException(&quot;Illegal load factor: &quot;  </p>
</li>
<li><ul>
<li>load_factor);  </li>
</ul>
</li>
<li><p><strong>this</strong>.LOAD_FACTOR = load_factor;  </p>
</li>
<li><p>max = (<strong>int</strong>) (init_Capaticy /* load_factor);  </p>
</li>
<li><p>container = <strong>new</strong> Entry[init_Capaticy];  </p>
</li>
<li><p>}  </p>
</li>
<li></li>
<li><p>// 使用默认参数的构造器  </p>
</li>
<li><p><strong>public</strong> MyMap() {  </p>
</li>
<li><p><strong>this</strong>(INIT_CAPACITY, LOAD_FACTOR);  </p>
</li>
<li><p>}  </p>
</li>
<li></li>
<li><p>//<em>/</em> </p>
</li>
<li><p>/* 存 </p>
</li>
<li><p>/*  </p>
</li>
<li><p>/* @param k </p>
</li>
<li><p>/* @param v </p>
</li>
<li><p>/* @return </p>
</li>
<li><p>/*/  </p>
</li>
<li><p><strong>public</strong> <strong>boolean</strong> put(K k, V v) {  </p>
</li>
<li><p>// 1.计算K的hash值  </p>
</li>
<li><p>// 因为自己很难写出对不同的类型都适用的Hash算法，故调用JDK给出的hashCode()方法来计算hash值  </p>
</li>
<li><p><strong>int</strong> hash = k.hashCode();  </p>
</li>
<li><p>//将所有信息封装为一个Entry  </p>
</li>
<li><p>Entry<K,V> temp=<strong>new</strong> Entry(k,v,hash);  </p>
</li>
<li><p><strong>if</strong>(setEntry(temp, container)){  </p>
</li>
<li><p>// 大小加一  </p>
</li>
<li><p>size++;  </p>
</li>
<li><p><strong>return</strong> <strong>true</strong>;  </p>
</li>
<li><p>}  </p>
</li>
<li><p><strong>return</strong> <strong>false</strong>;  </p>
</li>
<li><p>}  </p>
</li>
<li></li>
<li></li>
<li><p>//<em>/</em> </p>
</li>
<li><p>/* 扩容的方法 </p>
</li>
<li><p>/*  </p>
</li>
<li><p>/* @param newSize </p>
</li>
<li><p>/*            新的容器大小 </p>
</li>
<li><p>/*/  </p>
</li>
<li><p><strong>private</strong> <strong>void</strong> reSize(<strong>int</strong> newSize) {  </p>
</li>
<li><p>// 1.声明新数组  </p>
</li>
<li><p>Entry<K, V>[] newTable = <strong>new</strong> Entry[newSize];  </p>
</li>
<li><p>max = (<strong>int</strong>) (newSize /* LOAD_FACTOR);  </p>
</li>
<li><p>// 2.复制已有元素,即遍历所有元素，每个元素再存一遍  </p>
</li>
<li><p><strong>for</strong> (<strong>int</strong> j = 0; j &lt; container.length; j++) {  </p>
</li>
<li><p>Entry<K, V> entry = container[j];  </p>
</li>
<li><p>//因为每个数组元素其实为链表，所以…………  </p>
</li>
<li><p><strong>while</strong> (<strong>null</strong> != entry) {  </p>
</li>
<li><p>setEntry(entry, newTable);  </p>
</li>
<li><p>entry = entry.next;  </p>
</li>
<li><p>}  </p>
</li>
<li><p>}  </p>
</li>
<li><p>// 3.改变指向  </p>
</li>
<li><p>container = newTable;  </p>
</li>
<li></li>
<li><p>}  </p>
</li>
<li></li>
<li><p>//<em>/</em> </p>
</li>
<li><p>/*将指定的结点temp添加到指定的hash表table当中 </p>
</li>
<li><p>/* 添加时判断该结点是否已经存在 </p>
</li>
<li><p>/* 如果已经存在，返回false </p>
</li>
<li><p>/* 添加成功返回true </p>
</li>
<li><p>/* @param temp </p>
</li>
<li><p>/* @param table </p>
</li>
<li><p>/* @return </p>
</li>
<li><p>/*/  </p>
</li>
<li><p><strong>private</strong> <strong>boolean</strong> setEntry(Entry<K,V> temp,Entry[] table){  </p>
</li>
<li><p>// 根据hash值找到下标  </p>
</li>
<li><p><strong>int</strong> index = indexFor(temp.hash, table.length);  </p>
</li>
<li><p>//根据下标找到对应元素  </p>
</li>
<li><p>Entry<K, V> entry = table[index];  </p>
</li>
<li><p>// 3.若存在  </p>
</li>
<li><p><strong>if</strong> (<strong>null</strong> != entry) {  </p>
</li>
<li><p>// 3.1遍历整个链表，判断是否相等  </p>
</li>
<li><p><strong>while</strong> (<strong>null</strong> != entry) {  </p>
</li>
<li><p>//判断相等的条件时应该注意，除了比较地址相同外，引用传递的相等用equals()方法比较  </p>
</li>
<li><p>//相等则不存，返回false  </p>
</li>
<li><p><strong>if</strong> ((temp.key == entry.key||temp.key.equals(entry.key)) &amp;&amp; temp.hash == entry.hash&amp;&amp;(temp.value==entry.value||temp.value.equals(entry.value))) {  </p>
</li>
<li><p><strong>return</strong> <strong>false</strong>;  </p>
</li>
<li><p>}  </p>
</li>
<li><p>//不相等则比较下一个元素  </p>
</li>
<li><p><strong>else</strong> <strong>if</strong> (temp.key != entry.key &amp;&amp; temp.value != entry.value) {  </p>
</li>
<li><p>//到达队尾，中断循环  </p>
</li>
<li><p><strong>if</strong>(<strong>null</strong>==entry.next){  </p>
</li>
<li><p><strong>break</strong>;  </p>
</li>
<li><p>}  </p>
</li>
<li><p>// 没有到达队尾，继续遍历下一个元素  </p>
</li>
<li><p>entry = entry.next;  </p>
</li>
<li><p>}  </p>
</li>
<li><p>}  </p>
</li>
<li><p>// 3.2当遍历到了队尾，如果都没有相同的元素，则将该元素挂在队尾  </p>
</li>
<li><p>addEntry2Last(entry,temp);  </p>
</li>
<li></li>
<li><p>}  </p>
</li>
<li><p>// 4.若不存在,直接设置初始化元素  </p>
</li>
<li><p>setFirstEntry(temp,index,table);  </p>
</li>
<li><p><strong>return</strong> <strong>true</strong>;  </p>
</li>
<li><p>}  </p>
</li>
<li></li>
<li><p><strong>private</strong> <strong>void</strong> addEntry2Last(Entry<K, V> entry, Entry<K, V> temp) {  </p>
</li>
<li><p><strong>if</strong> (size &gt; max) {  </p>
</li>
<li><p>reSize(container.length /* 4);  </p>
</li>
<li><p>}  </p>
</li>
<li><p>entry.next=temp;  </p>
</li>
<li></li>
<li><p>}  </p>
</li>
<li></li>
<li><p>//<em>/</em> </p>
</li>
<li><p>/* 将指定结点temp，添加到指定的hash表table的指定下标index中 </p>
</li>
<li><p>/* @param temp </p>
</li>
<li><p>/* @param index </p>
</li>
<li><p>/* @param table </p>
</li>
<li><p>/*/  </p>
</li>
<li><p><strong>private</strong> <strong>void</strong> setFirstEntry(Entry<K, V> temp, <strong>int</strong> index, Entry[] table) {  </p>
</li>
<li><p>// 1.判断当前容量是否超标，如果超标，调用扩容方法  </p>
</li>
<li><p><strong>if</strong> (size &gt; max) {  </p>
</li>
<li><p>reSize(table.length /* 4);  </p>
</li>
<li><p>}  </p>
</li>
<li><p>// 2.不超标，或者扩容以后，设置元素  </p>
</li>
<li><p>table[index] = temp;  </p>
</li>
<li><p>//！！！！！！！！！！！！！！！  </p>
</li>
<li><p>//因为每次设置后都是新的链表，需要将其后接的结点都去掉  </p>
</li>
<li><p>//NND，少这一行代码卡了哥哥7个小时（代码重构）  </p>
</li>
<li><p>temp.next=<strong>null</strong>;  </p>
</li>
<li><p>}  </p>
</li>
<li></li>
<li><p>//<em>/</em> </p>
</li>
<li><p>/* 取 </p>
</li>
<li><p>/*  </p>
</li>
<li><p>/* @param k </p>
</li>
<li><p>/* @return </p>
</li>
<li><p>/*/  </p>
</li>
<li><p><strong>public</strong> V get(K k) {  </p>
</li>
<li><p>Entry<K, V> entry = <strong>null</strong>;  </p>
</li>
<li><p>// 1.计算K的hash值  </p>
</li>
<li><p><strong>int</strong> hash = k.hashCode();  </p>
</li>
<li><p>// 2.根据hash值找到下标  </p>
</li>
<li><p><strong>int</strong> index = indexFor(hash, container.length);  </p>
</li>
<li><p>// 3。根据index找到链表  </p>
</li>
<li><p>entry = container[index];  </p>
</li>
<li><p>// 3。若链表为空，返回null  </p>
</li>
<li><p><strong>if</strong> (<strong>null</strong> == entry) {  </p>
</li>
<li><p><strong>return</strong> <strong>null</strong>;  </p>
</li>
<li><p>}  </p>
</li>
<li><p>// 4。若不为空，遍历链表，比较k是否相等,如果k相等，则返回该value  </p>
</li>
<li><p><strong>while</strong> (<strong>null</strong> != entry) {  </p>
</li>
<li><p><strong>if</strong> (k == entry.key||entry.key.equals(k)) {  </p>
</li>
<li><p><strong>return</strong> entry.value;  </p>
</li>
<li><p>}  </p>
</li>
<li><p>entry = entry.next;  </p>
</li>
<li><p>}  </p>
</li>
<li><p>// 如果遍历完了不相等，则返回空  </p>
</li>
<li><p><strong>return</strong> <strong>null</strong>;  </p>
</li>
<li></li>
<li><p>}  </p>
</li>
<li></li>
<li><p>//<em>/</em> </p>
</li>
<li><p>/* 根据hash码，容器数组的长度,计算该哈希码在容器数组中的下标值 </p>
</li>
<li><p>/*  </p>
</li>
<li><p>/* @param hashcode </p>
</li>
<li><p>/* @param containerLength </p>
</li>
<li><p>/* @return </p>
</li>
<li><p>/*/  </p>
</li>
<li><p><strong>public</strong> <strong>int</strong> indexFor(<strong>int</strong> hashcode, <strong>int</strong> containerLength) {  </p>
</li>
<li><p><strong>return</strong> hashcode &amp; (containerLength - 1);  </p>
</li>
<li></li>
<li><p>}  </p>
</li>
<li></li>
<li><p>//<em>/</em> </p>
</li>
<li><p>/* 用来实际保存数据的内部类,因为采用挂链法解决冲突，此内部类设计为链表形式 </p>
</li>
<li><p>/*  </p>
</li>
<li><p>/* @param <K>key </p>
</li>
<li><p>/* @param <V> </p>
</li>
<li><p>/*            value </p>
</li>
<li><p>/*/  </p>
</li>
<li><p><strong>class</strong> Entry<K, V> {  </p>
</li>
<li><p>Entry<K, V> next;// 下一个结点  </p>
</li>
<li><p>K key;// key  </p>
</li>
<li><p>V value;// value  </p>
</li>
<li><p><strong>int</strong> hash;// 这个key对应的hash码，作为一个成员变量，当下次需要用的时候可以不用重新计算  </p>
</li>
<li></li>
<li><p>// 构造方法  </p>
</li>
<li><p>Entry(K k, V v, <strong>int</strong> hash) {  </p>
</li>
<li><p><strong>this</strong>.key = k;  </p>
</li>
<li><p><strong>this</strong>.value = v;  </p>
</li>
<li><p><strong>this</strong>.hash = hash;  </p>
</li>
<li></li>
<li><p>}  </p>
</li>
<li></li>
<li><p>//相应的getter()方法  </p>
</li>
<li></li>
<li><p>}  </p>
</li>
<li><p>}  </p>
</li>
</ol>
<p> 代码中有相当清楚的注释了</p>
<p>在文章的最后这里，我要强烈的宣泄下感情</p>
<p>MLGBD，本来以为分析的挺到位了，写出这个东西也就最多需要个把小时吧</p>
<p>结果因为通宵作业，脑袋运转不灵</p>
<p>硬是花了哥三个小时才写出了</p>
<p>好不容易些出来了</p>
<p>我日</p>
<p>看着代码比较混乱</p>
<p>然后就对代码重构了下</p>
<p>把逻辑抽象清楚，进行重构就花了个多小时</p>
<p>好不容易构造好了</p>
<p>就开始了TMD的一直报错了----------大数据量测试时到大概5000就死循环了</p>
<p>各种调试，各种分析都觉得没错误</p>
<p> 最后花了哥7个小时终于找出来了</p>
<p>我擦</p>
<p>第一次初始化加的时候，因为每个元素的next都是空的</p>
<p>而扩充容量resize()时，因为冲突处理是链式结构的</p>
<p>当将他们重新hash添加的时候，重复的这些鸟元素的next是有元素的</p>
<p>一定要设置为null</p>
<p><strong>七**</strong>.<strong>**性能分析：</strong></p>
<pre><code>  1.因为冲突的存在，其查找长度不可能达到O(1)

  2哈希表的平均查找长度是装载因子a 的函数，而不是 n 的函数。

  3.用哈希表构造查找表时，可以选择一个适当的装填因子 a ，使得平均查找长度限定在某个范围内。
</code></pre><p>   最后给出我们这个HashMap的性能</p>
<p>  测试代码</p>
<p><strong>Java**</strong>代码<strong><strong> </strong></strong> <strong>[</strong><img src="&quot;&quot;收藏这段代码&quot; &quot;" alt="收藏代码]()**"><em>**</em></p>
<ol>
<li><p><strong>public</strong> <strong>class</strong> Test {  </p>
</li>
<li></li>
<li><p><strong>public</strong> <strong>static</strong> <strong>void</strong> main(String[] args) {  </p>
</li>
<li><p>MyMap<String, String> mm = <strong>new</strong> MyMap<String, String>();   </p>
</li>
<li><p>Long aBeginTime=System.currentTimeMillis();//记录BeginTime  </p>
</li>
<li><p><strong>for</strong>(<strong>int</strong> i=0;i&lt;1000000;i++){  </p>
</li>
<li><p>mm.put(&quot;&quot;+i, &quot;&quot;+i/*100);  </p>
</li>
<li><p>}  </p>
</li>
<li><p>Long aEndTime=System.currentTimeMillis();//记录EndTime  </p>
</li>
<li><p>System.out.println(&quot;insert time--&gt;&quot;+(aEndTime-aBeginTime));  </p>
</li>
<li></li>
<li><p>Long lBeginTime=System.currentTimeMillis();//记录BeginTime  </p>
</li>
<li><p>mm.get(&quot;&quot;+100000);  </p>
</li>
<li><p>Long lEndTime=System.currentTimeMillis();//记录EndTime  </p>
</li>
<li><p>System.out.println(&quot;seach time---&gt;&quot;+(lEndTime-lBeginTime));  </p>
</li>
<li><p>}  </p>
</li>
<li><p>}  </p>
<p>100W个数据时，全部存储时间为1S多一点，而<strong>搜寻时间为**</strong>0 **</p>
</li>
</ol>
<p>insert time--&gt;1536
seach time---&gt;0</p>
<p>好了，牢骚发完了</p>
<p>本来今天想写个<strong>有关大访问量处理的一些基本概念</strong>的文章</p>
<p>全泡汤了,明天写吧</p>
<p>url: <a href="http://java-mzd.iteye.com/blog/827523" target="_blank">http://java-mzd.iteye.com/blog/827523</a></p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/java深入分析/">java深入分析</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/java深入分析/" class="label label-success">java深入分析</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:41"datetime="2014-03-07 09:54:41"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-java深入分析--Hash表分析以及Java实现/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-java深入分析--Hash表分析以及Java实现" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-SQL_Java--SQL解析Jsqlparser/">SQL解析(Jsqlparser)</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:41.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-SQL_Java--SQL解析Jsqlparser/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="sql-jsqlparser-">SQL解析(Jsqlparser)</h1>
<p>前段时间主要研究了一下SQL语句的解析，主要的几个开源产品试用了一下。本文大概总结一下个人体会。
首先是ZQL，ZQL有个比较突出的优点是使用起来比较简单，基本上属于拿上手就可以用的。但支持的功能有限，selectItem可以是简单的表达式，但不支持查询作为一个selectItem，对于其他的子查询同样也不支持。
最终我选择使用了Jsqlparser，主要原因有两点：
1）功能强大，基本上能够覆盖所有的SQL语法（没有研究是不是包含了数据库特殊的关键字，如LIMIT ），包含UNION,GROUP BY,HAVING,ORDER BY,JOIN,SUB JOIN,SUB SELECT,FUNCTION等。支持SQL深层嵌套。
2）本身设计不错，使用起来感觉很灵活。Jsqlparser对于SQL的遍历采用了VISITOR模式可以很方便的遍历SQL语句。
下面主要介绍一下Jsqlparser在我的项目中的应用情况。
背景：通过SQL语句的解析，从而增强SQL语句增加特定的查询过滤条件（如：状态过滤、权限过滤等）
1）解析SQL
2）根据SQL中涉及的表增强SQL
3）重新生成ORACLE数据库的SQL
Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>CCJSqlParserManager parserManager = new CCJSqlParserManager();  </li>
<li>try {  </li>
<li>Select select = (Select) parserManager.parse(new StringReader(sql)); //解析SQL语句  </li>
<li>SelectBody body = select.getSelectBody();   </li>
<li>VisitContext vc = new VisitContext(filterContext, params);  </li>
<li>vc.setTableFilterFactory(tableFilterFactory);//表的字段过滤  </li>
<li>body.accept(new SelectVisitorImpl(vc)); //访问SQL并根据SQL中涉及的表来增强SQL  </li>
<li>ExpressionDeParser expressionDeParser = new ExpressionDeParser();  </li>
<li>StringBuffer stringBuffer = new StringBuffer();  </li>
<li>SelectDeParser deParser = new OracleSelectDeParser(expressionDeParser, stringBuffer); //针对ORACLE的SQL生成  </li>
<li>expressionDeParser.setSelectVisitor(deParser);  </li>
<li>expressionDeParser.setBuffer(stringBuffer);  </li>
<li></li>
<li>body.accept(deParser);  </li>
<li>return new FilterResult(deParser.getBuffer().toString(), vc.getResultSqlParams());  </li>
<li>} catch (JSQLParserException e) {  </li>
<li>throw new FilterException(e);  </li>
<li><p>}  </p>
<pre><code> CCJSqlParserManager parserManager = new CCJSqlParserManager();

 try {
     Select select = (Select) parserManager.parse(new StringReader(sql)); //解析SQL语句

     SelectBody body = select.getSelectBody();
     VisitContext vc = new VisitContext(filterContext, params);

     vc.setTableFilterFactory(tableFilterFactory);//表的字段过滤
     body.accept(new SelectVisitorImpl(vc)); //访问SQL并根据SQL中涉及的表来增强SQL

     ExpressionDeParser expressionDeParser = new ExpressionDeParser();
     StringBuffer stringBuffer = new StringBuffer();

     SelectDeParser deParser = new OracleSelectDeParser(expressionDeParser, stringBuffer); //针对ORACLE的SQL生成
     expressionDeParser.setSelectVisitor(deParser);

     expressionDeParser.setBuffer(stringBuffer);
</code></pre></li>
</ol>
<pre><code>        body.accept(deParser);
        return new FilterResult(deParser.getBuffer().toString(), vc.getResultSqlParams());

    } catch (JSQLParserException e) {
        throw new FilterException(e);

    }
</code></pre><p>接下去是各个VISITOR，用来访问解析后的SQL
Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>public class SelectVisitorImpl extends AbstractVisitor implements SelectVisitor {  </li>
<li></li>
<li>public SelectVisitorImpl(VisitContext ctx) {  </li>
<li>super(ctx);  </li>
<li>}  </li>
<li></li>
<li>@SuppressWarnings(&quot;unchecked&quot;)  </li>
<li>public void visit(PlainSelect ps) {  </li>
<li>//SELECT ITEM访问  </li>
<li>List<SelectItem> selectItems = ps.getSelectItems();  </li>
<li>for (SelectItem item : selectItems) {  </li>
<li>item.accept(new SelectItemVisitorImpl(this.getContext()));  </li>
<li>}  </li>
<li></li>
<li>//FROM访问  </li>
<li>FromItem from = ps.getFromItem();  </li>
<li>FromItemVisitorImpl fv = new FromItemVisitorImpl(context);  </li>
<li>from.accept(fv);  </li>
<li></li>
<li>//查询条件访问  </li>
<li>if (ps.getWhere() != null) {  </li>
<li>ps.getWhere().accept(new ExpressionVisitorImpl(this.getContext()));  </li>
<li>}  </li>
<li></li>
<li>//过滤增强的条件  </li>
<li>if (fv.getEnhancedCondition() != null) {  </li>
<li>if (ps.getWhere() != null) {  </li>
<li>Expression expr = new Parenthesis(ps.getWhere());  </li>
<li>AndExpression and = new AndExpression(fv.getEnhancedCondition(), expr);  </li>
<li>ps.setWhere(and);  </li>
<li>} else {  </li>
<li>ps.setWhere(fv.getEnhancedCondition());  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>//JOIN表的访问  </li>
<li>List<Join> joins = ps.getJoins();  </li>
<li>if (CollectionUtil.isNotEmpty(joins)) {  </li>
<li>for (Join join : joins) {  </li>
<li>FromItemVisitorImpl tempfv = new FromItemVisitorImpl(context);  </li>
<li>join.getRightItem().accept(tempfv);  </li>
<li>if (join.getOnExpression() != null) {  </li>
<li>join.getOnExpression().accept(new ExpressionVisitorImpl(this.getContext()));  </li>
<li>if (tempfv.getEnhancedCondition() != null) {  </li>
<li>Expression expr = new Parenthesis(join.getOnExpression());  </li>
<li>AndExpression and = new AndExpression(tempfv.getEnhancedCondition(), expr);  </li>
<li>join.setOnExpression(and);  </li>
<li>}  </li>
<li>}  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>//ORDER BY 访问  </li>
<li>List<OrderByElement> elements = ps.getOrderByElements();  </li>
<li>if (CollectionUtil.isNotEmpty(elements)) {  </li>
<li>for (OrderByElement e : elements) {  </li>
<li>e.getExpression().accept(new ExpressionVisitorImpl(this.getContext()));  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>//GROUP BY的HAVING访问  </li>
<li>if (ps.getHaving() != null) {  </li>
<li>ps.getHaving().accept(new ExpressionVisitorImpl(this.getContext()));  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>@SuppressWarnings(&quot;unchecked&quot;)  </li>
<li>public void visit(Union un) {  </li>
<li>List<PlainSelect> selects = un.getPlainSelects();  </li>
<li>for (PlainSelect select : selects) {  </li>
<li>select.accept(new SelectVisitorImpl(this.getContext()));  </li>
<li>}  </li>
<li>List<OrderByElement> elements = un.getOrderByElements();  </li>
<li>if (CollectionUtil.isNotEmpty(elements)) {  </li>
<li>for (OrderByElement e : elements) {  </li>
<li>e.getExpression().accept(new ExpressionVisitorImpl(this.getContext()));  </li>
<li>}  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>}  </li>
</ol>
<p>public class SelectVisitorImpl extends AbstractVisitor implements SelectVisitor {</p>
<pre><code>public SelectVisitorImpl(VisitContext ctx) {

    super(ctx);
}


@SuppressWarnings(&quot;unchecked&quot;)

public void visit(PlainSelect ps) {
    //SELECT ITEM访问

    List&lt;SelectItem&gt; selectItems = ps.getSelectItems();
    for (SelectItem item : selectItems) {

        item.accept(new SelectItemVisitorImpl(this.getContext()));
    }


    //FROM访问

    FromItem from = ps.getFromItem();
    FromItemVisitorImpl fv = new FromItemVisitorImpl(context);

    from.accept(fv);


    //查询条件访问
    if (ps.getWhere() != null) {

        ps.getWhere().accept(new ExpressionVisitorImpl(this.getContext()));
    }


    //过滤增强的条件

    if (fv.getEnhancedCondition() != null) {
        if (ps.getWhere() != null) {

            Expression expr = new Parenthesis(ps.getWhere());
            AndExpression and = new AndExpression(fv.getEnhancedCondition(), expr);

            ps.setWhere(and);
        } else {

            ps.setWhere(fv.getEnhancedCondition());
        }

    }


    //JOIN表的访问
    List&lt;Join&gt; joins = ps.getJoins();

    if (CollectionUtil.isNotEmpty(joins)) {
        for (Join join : joins) {

            FromItemVisitorImpl tempfv = new FromItemVisitorImpl(context);
            join.getRightItem().accept(tempfv);

            if (join.getOnExpression() != null) {
                join.getOnExpression().accept(new ExpressionVisitorImpl(this.getContext()));

                if (tempfv.getEnhancedCondition() != null) {
                    Expression expr = new Parenthesis(join.getOnExpression());

                    AndExpression and = new AndExpression(tempfv.getEnhancedCondition(), expr);
                    join.setOnExpression(and);

                }
            }

        }
    }


    //ORDER BY 访问

    List&lt;OrderByElement&gt; elements = ps.getOrderByElements();
    if (CollectionUtil.isNotEmpty(elements)) {

        for (OrderByElement e : elements) {
            e.getExpression().accept(new ExpressionVisitorImpl(this.getContext()));

        }
    }


    //GROUP BY的HAVING访问

    if (ps.getHaving() != null) {
        ps.getHaving().accept(new ExpressionVisitorImpl(this.getContext()));

    }
}


@SuppressWarnings(&quot;unchecked&quot;)

public void visit(Union un) {
    List&lt;PlainSelect&gt; selects = un.getPlainSelects();

    for (PlainSelect select : selects) {
        select.accept(new SelectVisitorImpl(this.getContext()));

    }
    List&lt;OrderByElement&gt; elements = un.getOrderByElements();

    if (CollectionUtil.isNotEmpty(elements)) {
        for (OrderByElement e : elements) {

            e.getExpression().accept(new ExpressionVisitorImpl(this.getContext()));
        }

    }
}
</code></pre><p>}
Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>public class SelectItemVisitorImpl extends AbstractVisitor implements SelectItemVisitor {  </li>
<li></li>
<li>public SelectItemVisitorImpl(VisitContext ctx) {  </li>
<li>super(ctx);  </li>
<li>}  </li>
<li></li>
<li>public void visit(AllColumns ac) {  </li>
<li>}  </li>
<li></li>
<li>public void visit(AllTableColumns atc) {  </li>
<li>}  </li>
<li></li>
<li>public void visit(SelectExpressionItem sei) {  </li>
<li>sei.getExpression().accept(new ExpressionVisitorImpl(this.getContext()));  </li>
<li>}  </li>
<li></li>
<li>}  </li>
</ol>
<p>public class SelectItemVisitorImpl extends AbstractVisitor implements SelectItemVisitor {</p>
<pre><code>public SelectItemVisitorImpl(VisitContext ctx) {

    super(ctx);
}


public void visit(AllColumns ac) {

}


public void visit(AllTableColumns atc) {
}


public void visit(SelectExpressionItem sei) {

    sei.getExpression().accept(new ExpressionVisitorImpl(this.getContext()));
}
</code></pre><p>}
Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>public class ItemsListVisitorImpl extends AbstractVisitor implements ItemsListVisitor {  </li>
<li></li>
<li>public ItemsListVisitorImpl(VisitContext ctx) {  </li>
<li>super(ctx);  </li>
<li>}  </li>
<li></li>
<li>public void visit(SubSelect ss) {  </li>
<li>ss.getSelectBody().accept(new SelectVisitorImpl(context));  </li>
<li>}  </li>
<li></li>
<li>@SuppressWarnings(&quot;unchecked&quot;)  </li>
<li>public void visit(ExpressionList el) {  </li>
<li>List<Expression> list = el.getExpressions();  </li>
<li>if (CollectionUtil.isNotEmpty(list)) {  </li>
<li>for (Expression expr : list) {  </li>
<li>expr.accept(new ExpressionVisitorImpl(context));  </li>
<li>}  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>}  </li>
</ol>
<p>public class ItemsListVisitorImpl extends AbstractVisitor implements ItemsListVisitor {</p>
<pre><code>public ItemsListVisitorImpl(VisitContext ctx) {

    super(ctx);
}


public void visit(SubSelect ss) {

    ss.getSelectBody().accept(new SelectVisitorImpl(context));
}


@SuppressWarnings(&quot;unchecked&quot;)

public void visit(ExpressionList el) {
    List&lt;Expression&gt; list = el.getExpressions();

    if (CollectionUtil.isNotEmpty(list)) {
        for (Expression expr : list) {

            expr.accept(new ExpressionVisitorImpl(context));
        }

    }
}
</code></pre><p>}
如果FROM的内容是table的话，则根据table的增强配置对SQL增强
Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>public class FromItemVisitorImpl extends AbstractVisitor implements FromItemVisitor {  </li>
<li>private String varPattern = &quot;@\{\s/<em>?(\w+)\s/</em>?\}&quot;;  </li>
<li>private Expression enhancedCondition;  </li>
<li></li>
<li>public FromItemVisitorImpl(VisitContext ctx) {  </li>
<li>super(ctx);  </li>
<li>}  </li>
<li></li>
<li>public void visit(Table table) {  </li>
<li>Set<FieldFilter> filters = context.getTableFilterFactory().getTableFilter(table.getName());  </li>
<li>if (filters == null) {  </li>
<li>filters = Collections.emptySet();  </li>
<li>}  </li>
<li>for (FieldFilter ff : filters) {  </li>
<li>Column c = new Column(new Table(null, table.getAlias()), ff.getFieldName());  </li>
<li>JdbcParameter param = new JdbcParameter();  </li>
<li>Object fieldValue = getRawValue(ff.getFieldValue(), this.context.getFilterContext());  </li>
<li>Expression[] exps;  </li>
<li>if (&quot;between&quot;.equalsIgnoreCase(ff.getOperator()) || &quot;not between&quot;.equalsIgnoreCase(ff.getOperator())) {  </li>
<li>Object[] objs = (Object[]) fieldValue;  </li>
<li>this.getContext().getResultSqlParams().add(objs[0]);  </li>
<li>this.getContext().getResultSqlParams().add(objs[1]);  </li>
<li>exps = new Expression[] { c, param, param };  </li>
<li>} else if (&quot;is null&quot;.equalsIgnoreCase(ff.getOperator()) || &quot;is not null&quot;.equalsIgnoreCase(ff.getOperator())) {  </li>
<li>exps = new Expression[] { c };  </li>
<li>} else {  </li>
<li>this.getContext().getResultSqlParams().add(fieldValue);  </li>
<li>exps = new Expression[] { c, param };  </li>
<li>}  </li>
<li>Expression operator = this.getOperator(ff.getOperator(), exps);  </li>
<li>if (this.enhancedCondition != null) {  </li>
<li>enhancedCondition = new AndExpression(enhancedCondition, operator);  </li>
<li>} else {  </li>
<li>enhancedCondition = operator;  </li>
<li>}  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>public void visit(SubSelect ss) {  </li>
<li>ss.getSelectBody().accept(new SelectVisitorImpl(this.getContext()));  </li>
<li>}  </li>
<li></li>
<li>public void visit(SubJoin sj) {  </li>
<li>Join join = sj.getJoin();  </li>
<li>join.getRightItem().accept(new FromItemVisitorImpl(this.getContext()));  </li>
<li>join.getOnExpression().accept(new ExpressionVisitorImpl(this.getContext()));  </li>
<li>}  </li>
<li></li>
<li>private Expression getOperator(String op, Expression[] exp) {  </li>
<li>if (&quot;=&quot;.equals(op)) {  </li>
<li>EqualsTo eq = new EqualsTo();  </li>
<li>eq.setLeftExpression(exp[0]);  </li>
<li>eq.setRightExpression(exp[1]);  </li>
<li>return eq;  </li>
<li>} else if (&quot;&gt;&quot;.equals(op)) {  </li>
<li>GreaterThan gt = new GreaterThan();  </li>
<li>gt.setLeftExpression(exp[0]);  </li>
<li>gt.setRightExpression(exp[1]);  </li>
<li>return gt;  </li>
<li>} else if (&quot;&gt;=&quot;.equals(op)) {  </li>
<li>GreaterThanEquals geq = new GreaterThanEquals();  </li>
<li>geq.setLeftExpression(exp[0]);  </li>
<li>geq.setRightExpression(exp[1]);  </li>
<li>return geq;  </li>
<li>} else if (&quot;&lt;&quot;.equals(op)) {  </li>
<li>MinorThan mt = new MinorThan();  </li>
<li>mt.setLeftExpression(exp[0]);  </li>
<li>mt.setRightExpression(exp[1]);  </li>
<li>return mt;  </li>
<li>} else if (&quot;&lt;=&quot;.equals(op)) {  </li>
<li>MinorThanEquals leq = new MinorThanEquals();  </li>
<li>leq.setLeftExpression(exp[0]);  </li>
<li>leq.setRightExpression(exp[1]);  </li>
<li>return leq;  </li>
<li>} else if (&quot;&lt;&gt;&quot;.equals(op)) {  </li>
<li>NotEqualsTo neq = new NotEqualsTo();  </li>
<li>neq.setLeftExpression(exp[0]);  </li>
<li>neq.setRightExpression(exp[1]);  </li>
<li>return neq;  </li>
<li>} else if (&quot;is null&quot;.equalsIgnoreCase(op)) {  </li>
<li>IsNullExpression isNull = new IsNullExpression();  </li>
<li>isNull.setNot(false);  </li>
<li>isNull.setLeftExpression(exp[0]);  </li>
<li>return isNull;  </li>
<li>} else if (&quot;is not null&quot;.equalsIgnoreCase(op)) {  </li>
<li>IsNullExpression isNull = new IsNullExpression();  </li>
<li>isNull.setNot(true);  </li>
<li>isNull.setLeftExpression(exp[0]);  </li>
<li>return isNull;  </li>
<li>} else if (&quot;like&quot;.equalsIgnoreCase(op)) {  </li>
<li>LikeExpression like = new LikeExpression();  </li>
<li>like.setNot(false);  </li>
<li>like.setLeftExpression(exp[0]);  </li>
<li>like.setRightExpression(exp[1]);  </li>
<li>return like;  </li>
<li>} else if (&quot;not like&quot;.equalsIgnoreCase(op)) {  </li>
<li>LikeExpression nlike = new LikeExpression();  </li>
<li>nlike.setNot(true);  </li>
<li>nlike.setLeftExpression(exp[0]);  </li>
<li>nlike.setRightExpression(exp[1]);  </li>
<li>return nlike;  </li>
<li>} else if (&quot;between&quot;.equalsIgnoreCase(op)) {  </li>
<li>Between bt = new Between();  </li>
<li>bt.setNot(false);  </li>
<li>bt.setLeftExpression(exp[0]);  </li>
<li>bt.setBetweenExpressionStart(exp[1]);  </li>
<li>bt.setBetweenExpressionEnd(exp[2]);  </li>
<li>return bt;  </li>
<li>} else if (&quot;not between&quot;.equalsIgnoreCase(op)) {  </li>
<li>Between bt = new Between();  </li>
<li>bt.setNot(true);  </li>
<li>bt.setLeftExpression(exp[0]);  </li>
<li>bt.setBetweenExpressionStart(exp[1]);  </li>
<li>bt.setBetweenExpressionEnd(exp[2]);  </li>
<li>return bt;  </li>
<li>}  </li>
<li>throw new FilterException(&quot;Unknown operator:&quot; + op);  </li>
<li>}  </li>
<li></li>
<li>protected Object getRawValue(Object value, Map<String, Object> context) {  </li>
<li>if (context == null) {  </li>
<li>return value;  </li>
<li>}  </li>
<li>if (value instanceof String) {  </li>
<li>String v = (String) value;  </li>
<li>Pattern pattern = Pattern.compile(varPattern);  </li>
<li>Matcher matcher = pattern.matcher(v);  </li>
<li>if (matcher.find()) {  </li>
<li>return context.get(matcher.group(1));  </li>
<li>}  </li>
<li>}  </li>
<li>return value;  </li>
<li>}  </li>
<li></li>
<li>public Expression getEnhancedCondition() {  </li>
<li>return enhancedCondition;  </li>
<li>}  </li>
<li></li>
<li>}  </li>
</ol>
<p>public class FromItemVisitorImpl extends AbstractVisitor implements FromItemVisitor {</p>
<pre><code>private String varPattern = &quot;@\\{\\s/*?(\\w+)\\s/*?\\}&quot;;
private Expression enhancedCondition;


public FromItemVisitorImpl(VisitContext ctx) {

    super(ctx);
}


public void visit(Table table) {

    Set&lt;FieldFilter&gt; filters = context.getTableFilterFactory().getTableFilter(table.getName());
    if (filters == null) {

        filters = Collections.emptySet();
    }

    for (FieldFilter ff : filters) {
        Column c = new Column(new Table(null, table.getAlias()), ff.getFieldName());

        JdbcParameter param = new JdbcParameter();
        Object fieldValue = getRawValue(ff.getFieldValue(), this.context.getFilterContext());

        Expression[] exps;
        if (&quot;between&quot;.equalsIgnoreCase(ff.getOperator()) || &quot;not between&quot;.equalsIgnoreCase(ff.getOperator())) {

            Object[] objs = (Object[]) fieldValue;
            this.getContext().getResultSqlParams().add(objs[0]);

            this.getContext().getResultSqlParams().add(objs[1]);
            exps = new Expression[] { c, param, param };

        } else if (&quot;is null&quot;.equalsIgnoreCase(ff.getOperator()) || &quot;is not null&quot;.equalsIgnoreCase(ff.getOperator())) {
            exps = new Expression[] { c };

        } else {
            this.getContext().getResultSqlParams().add(fieldValue);

            exps = new Expression[] { c, param };
        }

        Expression operator = this.getOperator(ff.getOperator(), exps);
        if (this.enhancedCondition != null) {

            enhancedCondition = new AndExpression(enhancedCondition, operator);
        } else {

            enhancedCondition = operator;
        }

    }
}


public void visit(SubSelect ss) {

    ss.getSelectBody().accept(new SelectVisitorImpl(this.getContext()));
}


public void visit(SubJoin sj) {

    Join join = sj.getJoin();
    join.getRightItem().accept(new FromItemVisitorImpl(this.getContext()));

    join.getOnExpression().accept(new ExpressionVisitorImpl(this.getContext()));
}


private Expression getOperator(String op, Expression[] exp) {

    if (&quot;=&quot;.equals(op)) {
        EqualsTo eq = new EqualsTo();

        eq.setLeftExpression(exp[0]);
        eq.setRightExpression(exp[1]);

        return eq;
    } else if (&quot;&gt;&quot;.equals(op)) {

        GreaterThan gt = new GreaterThan();
        gt.setLeftExpression(exp[0]);

        gt.setRightExpression(exp[1]);
        return gt;

    } else if (&quot;&gt;=&quot;.equals(op)) {
        GreaterThanEquals geq = new GreaterThanEquals();

        geq.setLeftExpression(exp[0]);
        geq.setRightExpression(exp[1]);

        return geq;
    } else if (&quot;&lt;&quot;.equals(op)) {

        MinorThan mt = new MinorThan();
        mt.setLeftExpression(exp[0]);

        mt.setRightExpression(exp[1]);
        return mt;

    } else if (&quot;&lt;=&quot;.equals(op)) {
        MinorThanEquals leq = new MinorThanEquals();

        leq.setLeftExpression(exp[0]);
        leq.setRightExpression(exp[1]);

        return leq;
    } else if (&quot;&lt;&gt;&quot;.equals(op)) {

        NotEqualsTo neq = new NotEqualsTo();
        neq.setLeftExpression(exp[0]);

        neq.setRightExpression(exp[1]);
        return neq;

    } else if (&quot;is null&quot;.equalsIgnoreCase(op)) {
        IsNullExpression isNull = new IsNullExpression();

        isNull.setNot(false);
        isNull.setLeftExpression(exp[0]);

        return isNull;
    } else if (&quot;is not null&quot;.equalsIgnoreCase(op)) {

        IsNullExpression isNull = new IsNullExpression();
        isNull.setNot(true);

        isNull.setLeftExpression(exp[0]);
        return isNull;

    } else if (&quot;like&quot;.equalsIgnoreCase(op)) {
        LikeExpression like = new LikeExpression();

        like.setNot(false);
        like.setLeftExpression(exp[0]);

        like.setRightExpression(exp[1]);
        return like;

    } else if (&quot;not like&quot;.equalsIgnoreCase(op)) {
        LikeExpression nlike = new LikeExpression();

        nlike.setNot(true);
        nlike.setLeftExpression(exp[0]);

        nlike.setRightExpression(exp[1]);
        return nlike;

    } else if (&quot;between&quot;.equalsIgnoreCase(op)) {
        Between bt = new Between();

        bt.setNot(false);
        bt.setLeftExpression(exp[0]);

        bt.setBetweenExpressionStart(exp[1]);
        bt.setBetweenExpressionEnd(exp[2]);

        return bt;
    } else if (&quot;not between&quot;.equalsIgnoreCase(op)) {

        Between bt = new Between();
        bt.setNot(true);

        bt.setLeftExpression(exp[0]);
        bt.setBetweenExpressionStart(exp[1]);

        bt.setBetweenExpressionEnd(exp[2]);
        return bt;

    }
    throw new FilterException(&quot;Unknown operator:&quot; + op);

}


protected Object getRawValue(Object value, Map&lt;String, Object&gt; context) {
    if (context == null) {

        return value;
    }

    if (value instanceof String) {
        String v = (String) value;

        Pattern pattern = Pattern.compile(varPattern);
        Matcher matcher = pattern.matcher(v);

        if (matcher.find()) {
            return context.get(matcher.group(1));

        }
    }

    return value;
}


public Expression getEnhancedCondition() {

    return enhancedCondition;
}
</code></pre><p>}
1）对JDBC parameter做了处理，如果参数为NULL则自动忽略该parameter，忽略后需要处理and or between 等情况
   如：where name=? and age=? ，假如name对应的参数为null，则条件改为where 1=1 and age=?，如果是or的话则改为 where 1=0 or age=?
Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>public class ExpressionVisitorImpl extends AbstractVisitor implements ExpressionVisitor {  </li>
<li></li>
<li>public ExpressionVisitorImpl(VisitContext ctx) {  </li>
<li>super(ctx);  </li>
<li>}  </li>
<li></li>
<li>public void visit(NullValue nv) {  </li>
<li>}  </li>
<li></li>
<li>public void visit(Function f) {  </li>
<li>}  </li>
<li></li>
<li>public void visit(InverseExpression ie) {  </li>
<li>}  </li>
<li></li>
<li>public void visit(JdbcParameter jp) {  </li>
<li>this.getContext().getResultSqlParams().add(context.removeFirstParam());  </li>
<li>}  </li>
<li></li>
<li>public void visit(DoubleValue dv) {  </li>
<li>}  </li>
<li></li>
<li>public void visit(LongValue lv) {  </li>
<li>}  </li>
<li></li>
<li>public void visit(DateValue dv) {  </li>
<li>}  </li>
<li></li>
<li>public void visit(TimeValue tv) {  </li>
<li>}  </li>
<li></li>
<li>public void visit(TimestampValue tv) {  </li>
<li>}  </li>
<li></li>
<li>public void visit(Parenthesis parenthesis) {  </li>
<li>ExpressionVisitorImpl ev = new ExpressionVisitorImpl(context);  </li>
<li>parenthesis.getExpression().accept(ev);  </li>
<li>if (ev.isNotValid()) {  </li>
<li>parenthesis.setExpression(this.createTrueEquals());  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>public void visit(StringValue s) {  </li>
<li>}  </li>
<li></li>
<li>public void visit(Addition a) {  </li>
<li>}  </li>
<li></li>
<li>public void visit(Division d) {  </li>
<li>}  </li>
<li></li>
<li>public void visit(Multiplication m) {  </li>
<li>}  </li>
<li></li>
<li>public void visit(Subtraction s) {  </li>
<li>}  </li>
<li></li>
<li>public void visit(AndExpression and) {  </li>
<li>ExpressionVisitorImpl left = new ExpressionVisitorImpl(this.getContext());  </li>
<li>and.getLeftExpression().accept(left);  </li>
<li>if (left.isNotValid()) {  </li>
<li>and.setLeftExpression(this.createTrueEquals());  </li>
<li>}  </li>
<li>ExpressionVisitorImpl right = new ExpressionVisitorImpl(this.getContext());  </li>
<li>and.getRightExpression().accept(right);  </li>
<li>if (right.isNotValid()) {  </li>
<li>and.setRightExpression(this.createTrueEquals());  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>public void visit(OrExpression or) {  </li>
<li>ExpressionVisitorImpl left = new ExpressionVisitorImpl(this.getContext());  </li>
<li>or.getLeftExpression().accept(left);  </li>
<li>if (left.isNotValid()) {  </li>
<li>or.setLeftExpression(this.createFalseEquals());  </li>
<li>}  </li>
<li>ExpressionVisitorImpl right = new ExpressionVisitorImpl(this.getContext());  </li>
<li>or.getRightExpression().accept(right);  </li>
<li>if (right.isNotValid()) {  </li>
<li>or.setRightExpression(this.createFalseEquals());  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>public void visit(Between btw) {  </li>
<li>Expression start = btw.getBetweenExpressionStart();  </li>
<li>Expression end = btw.getBetweenExpressionEnd();  </li>
<li>if (start instanceof JdbcParameter &amp;&amp; end instanceof JdbcParameter) {  </li>
<li>Object o1 = this.context.getFirstParam();  </li>
<li>Object o2 = this.context.getParam(1);  </li>
<li>if (o1 == null || o2 == null) {  </li>
<li>this.context.removeFirstParam();  </li>
<li>this.context.removeFirstParam();  </li>
<li>this.setValid(false);  </li>
<li>return;  </li>
<li>}  </li>
<li>} else if (start instanceof JdbcParameter || end instanceof JdbcParameter) {  </li>
<li>Object o1 = this.context.getFirstParam();  </li>
<li>if (o1 == null) {  </li>
<li>this.context.removeFirstParam();  </li>
<li>this.setValid(false);  </li>
<li>return;  </li>
<li>}  </li>
<li>}  </li>
<li>btw.getLeftExpression().accept(new ExpressionVisitorImpl(context));  </li>
<li>btw.getBetweenExpressionStart().accept(new ExpressionVisitorImpl(context));  </li>
<li>btw.getBetweenExpressionEnd().accept(new ExpressionVisitorImpl(context));  </li>
<li>}  </li>
<li></li>
<li>public void visit(EqualsTo eq) {  </li>
<li>if (eq.getRightExpression() instanceof JdbcParameter) {  </li>
<li>Object o = this.context.getFirstParam();  </li>
<li>if (o == null) {  </li>
<li>this.setValid(false);  </li>
<li>this.getContext().removeFirstParam();  </li>
<li>return;  </li>
<li>}  </li>
<li>}  </li>
<li>eq.getLeftExpression().accept(new ExpressionVisitorImpl(this.getContext()));  </li>
<li>eq.getRightExpression().accept(new ExpressionVisitorImpl(this.getContext()));  </li>
<li>}  </li>
<li></li>
<li>public void visit(GreaterThan gt) {  </li>
<li>if (gt.getRightExpression() instanceof JdbcParameter) {  </li>
<li>Object o = this.context.getFirstParam();  </li>
<li>if (o == null) {  </li>
<li>this.setValid(false);  </li>
<li>this.getContext().removeFirstParam();  </li>
<li>}  </li>
<li>}  </li>
<li>gt.getLeftExpression().accept(new ExpressionVisitorImpl(this.getContext()));  </li>
<li>gt.getRightExpression().accept(new ExpressionVisitorImpl(this.getContext()));  </li>
<li>}  </li>
<li></li>
<li>public void visit(GreaterThanEquals gte) {  </li>
<li>if (gte.getRightExpression() instanceof JdbcParameter) {  </li>
<li>Object o = this.context.getFirstParam();  </li>
<li>if (o == null) {  </li>
<li>this.setValid(false);  </li>
<li>this.getContext().removeFirstParam();  </li>
<li>}  </li>
<li>}  </li>
<li>gte.getLeftExpression().accept(new ExpressionVisitorImpl(this.getContext()));  </li>
<li>gte.getRightExpression().accept(new ExpressionVisitorImpl(this.getContext()));  </li>
<li>}  </li>
<li></li>
<li>public void visit(InExpression in) {  </li>
<li>ItemsList list = in.getItemsList();  </li>
<li>list.accept(new ItemsListVisitorImpl(context));  </li>
<li>}  </li>
<li></li>
<li>public void visit(IsNullExpression ine) {  </li>
<li>}  </li>
<li></li>
<li>public void visit(LikeExpression le) {  </li>
<li>if (le.getRightExpression() instanceof JdbcParameter) {  </li>
<li>Object o = this.context.getFirstParam();  </li>
<li>if (o == null) {  </li>
<li>this.setValid(false);  </li>
<li>this.getContext().removeFirstParam();  </li>
<li>}  </li>
<li>}  </li>
<li>le.getLeftExpression().accept(new ExpressionVisitorImpl(this.getContext()));  </li>
<li>le.getRightExpression().accept(new ExpressionVisitorImpl(this.getContext()));  </li>
<li>}  </li>
<li></li>
<li>public void visit(MinorThan mt) {  </li>
<li>if (mt.getRightExpression() instanceof JdbcParameter) {  </li>
<li>Object o = this.context.getFirstParam();  </li>
<li>if (o == null) {  </li>
<li>this.setValid(false);  </li>
<li>this.getContext().removeFirstParam();  </li>
<li>}  </li>
<li>}  </li>
<li>mt.getLeftExpression().accept(new ExpressionVisitorImpl(this.getContext()));  </li>
<li>mt.getRightExpression().accept(new ExpressionVisitorImpl(this.getContext()));  </li>
<li>}  </li>
<li></li>
<li>public void visit(MinorThanEquals mte) {  </li>
<li>if (mte.getRightExpression() instanceof JdbcParameter) {  </li>
<li>Object o = this.context.getFirstParam();  </li>
<li>if (o == null) {  </li>
<li>this.setValid(false);  </li>
<li>this.getContext().removeFirstParam();  </li>
<li>}  </li>
<li>}  </li>
<li>mte.getLeftExpression().accept(new ExpressionVisitorImpl(this.getContext()));  </li>
<li>mte.getRightExpression().accept(new ExpressionVisitorImpl(this.getContext()));  </li>
<li>}  </li>
<li></li>
<li>public void visit(NotEqualsTo neq) {  </li>
<li>if (neq.getRightExpression() instanceof JdbcParameter) {  </li>
<li>Object o = this.context.getFirstParam();  </li>
<li>if (o == null) {  </li>
<li>this.setValid(false);  </li>
<li>this.getContext().removeFirstParam();  </li>
<li>return;  </li>
<li>}  </li>
<li>}  </li>
<li>neq.getLeftExpression().accept(new ExpressionVisitorImpl(this.getContext()));  </li>
<li>neq.getRightExpression().accept(new ExpressionVisitorImpl(this.getContext()));  </li>
<li>}  </li>
<li></li>
<li>public void visit(Column c) {  </li>
<li>}  </li>
<li></li>
<li>public void visit(SubSelect ss) {  </li>
<li>ss.getSelectBody().accept(new SelectVisitorImpl(context));  </li>
<li>}  </li>
<li></li>
<li>public void visit(CaseExpression ce) {  </li>
<li>}  </li>
<li></li>
<li>public void visit(WhenClause wc) {  </li>
<li>}  </li>
<li></li>
<li>public void visit(ExistsExpression ee) {  </li>
<li>}  </li>
<li></li>
<li>public void visit(AllComparisonExpression ace) {  </li>
<li>}  </li>
<li></li>
<li>public void visit(AnyComparisonExpression ace) {  </li>
<li>}  </li>
<li></li>
<li>public void visit(Concat c) {  </li>
<li>}  </li>
<li></li>
<li>public void visit(Matches m) {  </li>
<li>}  </li>
<li></li>
<li>public void visit(BitwiseAnd ba) {  </li>
<li>}  </li>
<li></li>
<li>public void visit(BitwiseOr bo) {  </li>
<li>}  </li>
<li></li>
<li>public void visit(BitwiseXor bx) {  </li>
<li>}  </li>
<li></li>
<li>private EqualsTo createTrueEquals() {  </li>
<li>EqualsTo eq = new EqualsTo();  </li>
<li>eq.setLeftExpression(new LongValue(&quot;1&quot;));  </li>
<li>eq.setRightExpression(new LongValue(&quot;1&quot;));  </li>
<li>return eq;  </li>
<li>}  </li>
<li></li>
<li>private EqualsTo createFalseEquals() {  </li>
<li>EqualsTo eq = new EqualsTo();  </li>
<li>eq.setLeftExpression(new LongValue(&quot;1&quot;));  </li>
<li>eq.setRightExpression(new LongValue(&quot;0&quot;));  </li>
<li>return eq;  </li>
<li>}  </li>
<li></li>
<li>}  </li>
</ol>
<p>public class ExpressionVisitorImpl extends AbstractVisitor implements ExpressionVisitor {</p>
<pre><code>public ExpressionVisitorImpl(VisitContext ctx) {

    super(ctx);
}


public void visit(NullValue nv) {

}


public void visit(Function f) {
}


public void visit(InverseExpression ie) {

}


public void visit(JdbcParameter jp) {
    this.getContext().getResultSqlParams().add(context.removeFirstParam());

}


public void visit(DoubleValue dv) {
}


public void visit(LongValue lv) {

}


public void visit(DateValue dv) {
}


public void visit(TimeValue tv) {

}


public void visit(TimestampValue tv) {
}


public void visit(Parenthesis parenthesis) {

    ExpressionVisitorImpl ev = new ExpressionVisitorImpl(context);
    parenthesis.getExpression().accept(ev);

    if (ev.isNotValid()) {
        parenthesis.setExpression(this.createTrueEquals());

    }
}


public void visit(StringValue s) {

}


public void visit(Addition a) {
}


public void visit(Division d) {

}


public void visit(Multiplication m) {
}


public void visit(Subtraction s) {

}


public void visit(AndExpression and) {
    ExpressionVisitorImpl left = new ExpressionVisitorImpl(this.getContext());

    and.getLeftExpression().accept(left);
    if (left.isNotValid()) {

        and.setLeftExpression(this.createTrueEquals());
    }

    ExpressionVisitorImpl right = new ExpressionVisitorImpl(this.getContext());
    and.getRightExpression().accept(right);

    if (right.isNotValid()) {
        and.setRightExpression(this.createTrueEquals());

    }
}


public void visit(OrExpression or) {

    ExpressionVisitorImpl left = new ExpressionVisitorImpl(this.getContext());
    or.getLeftExpression().accept(left);

    if (left.isNotValid()) {
        or.setLeftExpression(this.createFalseEquals());

    }
    ExpressionVisitorImpl right = new ExpressionVisitorImpl(this.getContext());

    or.getRightExpression().accept(right);
    if (right.isNotValid()) {

        or.setRightExpression(this.createFalseEquals());
    }

}


public void visit(Between btw) {
    Expression start = btw.getBetweenExpressionStart();

    Expression end = btw.getBetweenExpressionEnd();
    if (start instanceof JdbcParameter &amp;&amp; end instanceof JdbcParameter) {

        Object o1 = this.context.getFirstParam();
        Object o2 = this.context.getParam(1);

        if (o1 == null || o2 == null) {
            this.context.removeFirstParam();

            this.context.removeFirstParam();
            this.setValid(false);

            return;
        }

    } else if (start instanceof JdbcParameter || end instanceof JdbcParameter) {
        Object o1 = this.context.getFirstParam();

        if (o1 == null) {
            this.context.removeFirstParam();

            this.setValid(false);
            return;

        }
    }

    btw.getLeftExpression().accept(new ExpressionVisitorImpl(context));
    btw.getBetweenExpressionStart().accept(new ExpressionVisitorImpl(context));

    btw.getBetweenExpressionEnd().accept(new ExpressionVisitorImpl(context));
}


public void visit(EqualsTo eq) {

    if (eq.getRightExpression() instanceof JdbcParameter) {
        Object o = this.context.getFirstParam();

        if (o == null) {
            this.setValid(false);

            this.getContext().removeFirstParam();
            return;

        }
    }

    eq.getLeftExpression().accept(new ExpressionVisitorImpl(this.getContext()));
    eq.getRightExpression().accept(new ExpressionVisitorImpl(this.getContext()));

}


public void visit(GreaterThan gt) {
    if (gt.getRightExpression() instanceof JdbcParameter) {

        Object o = this.context.getFirstParam();
        if (o == null) {

            this.setValid(false);
            this.getContext().removeFirstParam();

        }
    }

    gt.getLeftExpression().accept(new ExpressionVisitorImpl(this.getContext()));
    gt.getRightExpression().accept(new ExpressionVisitorImpl(this.getContext()));

}


public void visit(GreaterThanEquals gte) {
    if (gte.getRightExpression() instanceof JdbcParameter) {

        Object o = this.context.getFirstParam();
        if (o == null) {

            this.setValid(false);
            this.getContext().removeFirstParam();

        }
    }

    gte.getLeftExpression().accept(new ExpressionVisitorImpl(this.getContext()));
    gte.getRightExpression().accept(new ExpressionVisitorImpl(this.getContext()));

}


public void visit(InExpression in) {
    ItemsList list = in.getItemsList();

    list.accept(new ItemsListVisitorImpl(context));
}


public void visit(IsNullExpression ine) {

}


public void visit(LikeExpression le) {
    if (le.getRightExpression() instanceof JdbcParameter) {

        Object o = this.context.getFirstParam();
        if (o == null) {

            this.setValid(false);
            this.getContext().removeFirstParam();

        }
    }

    le.getLeftExpression().accept(new ExpressionVisitorImpl(this.getContext()));
    le.getRightExpression().accept(new ExpressionVisitorImpl(this.getContext()));

}


public void visit(MinorThan mt) {
    if (mt.getRightExpression() instanceof JdbcParameter) {

        Object o = this.context.getFirstParam();
        if (o == null) {

            this.setValid(false);
            this.getContext().removeFirstParam();

        }
    }

    mt.getLeftExpression().accept(new ExpressionVisitorImpl(this.getContext()));
    mt.getRightExpression().accept(new ExpressionVisitorImpl(this.getContext()));

}


public void visit(MinorThanEquals mte) {
    if (mte.getRightExpression() instanceof JdbcParameter) {

        Object o = this.context.getFirstParam();
        if (o == null) {

            this.setValid(false);
            this.getContext().removeFirstParam();

        }
    }

    mte.getLeftExpression().accept(new ExpressionVisitorImpl(this.getContext()));
    mte.getRightExpression().accept(new ExpressionVisitorImpl(this.getContext()));

}


public void visit(NotEqualsTo neq) {
    if (neq.getRightExpression() instanceof JdbcParameter) {

        Object o = this.context.getFirstParam();
        if (o == null) {

            this.setValid(false);
            this.getContext().removeFirstParam();

            return;
        }

    }
    neq.getLeftExpression().accept(new ExpressionVisitorImpl(this.getContext()));

    neq.getRightExpression().accept(new ExpressionVisitorImpl(this.getContext()));
}


public void visit(Column c) {

}


public void visit(SubSelect ss) {
    ss.getSelectBody().accept(new SelectVisitorImpl(context));

}


public void visit(CaseExpression ce) {
}


public void visit(WhenClause wc) {

}


public void visit(ExistsExpression ee) {
}


public void visit(AllComparisonExpression ace) {

}


public void visit(AnyComparisonExpression ace) {
}


public void visit(Concat c) {

}


public void visit(Matches m) {
}


public void visit(BitwiseAnd ba) {

}


public void visit(BitwiseOr bo) {
}


public void visit(BitwiseXor bx) {

}


private EqualsTo createTrueEquals() {
    EqualsTo eq = new EqualsTo();

    eq.setLeftExpression(new LongValue(&quot;1&quot;));
    eq.setRightExpression(new LongValue(&quot;1&quot;));

    return eq;
}


private EqualsTo createFalseEquals() {

    EqualsTo eq = new EqualsTo();
    eq.setLeftExpression(new LongValue(&quot;1&quot;));

    eq.setRightExpression(new LongValue(&quot;0&quot;));
    return eq;

}
</code></pre><p>}
增强后SQL语句的重新生成，根据ORACLE的语法重写了几个生成的方法
Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>public class OracleSelectDeParser extends SelectDeParser {  </li>
<li></li>
<li>public OracleSelectDeParser(ExpressionDeParser expressionDeParser, StringBuffer sb) {  </li>
<li>super(expressionDeParser, sb);  </li>
<li>}  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* 重写父类方法，去掉父类方法中table前的as </li>
<li>/*/  </li>
<li>public void visit(Table tableName) {  </li>
<li>buffer.append(tableName.getWholeTableName());  </li>
<li>String alias = tableName.getAlias();  </li>
<li>if (alias != null &amp;&amp; StringUtil.isNotEmpty(alias)) {  </li>
<li>buffer.append(&quot; &quot;);  </li>
<li>buffer.append(alias);  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* 重写父类方法，在JOIN之前增加空格 </li>
<li>/*/  </li>
<li>@SuppressWarnings(&quot;unchecked&quot;)  </li>
<li>public void deparseJoin(Join join) {  </li>
<li>if (join.isSimple()) {  </li>
<li>buffer.append(&quot;, &quot;);  </li>
<li>} else {  </li>
<li>buffer.append(&quot; &quot;);  </li>
<li>if (join.isRight()) {  </li>
<li>buffer.append(&quot;RIGHT &quot;);  </li>
<li>} else if (join.isNatural()) {  </li>
<li>buffer.append(&quot;NATURAL &quot;);  </li>
<li>} else if (join.isFull()) {  </li>
<li>buffer.append(&quot;FULL &quot;);  </li>
<li>} else if (join.isLeft()) {  </li>
<li>buffer.append(&quot;LEFT &quot;);  </li>
<li>}  </li>
<li>if (join.isOuter()) {  </li>
<li>buffer.append(&quot;OUTER &quot;);  </li>
<li>} else if (join.isInner()) {  </li>
<li>buffer.append(&quot;INNER &quot;);  </li>
<li>}  </li>
<li>buffer.append(&quot;JOIN &quot;);  </li>
<li>}  </li>
<li></li>
<li>FromItem fromItem = join.getRightItem();  </li>
<li>fromItem.accept(this);  </li>
<li>if (join.getOnExpression() != null) {  </li>
<li>buffer.append(&quot; ON &quot;);  </li>
<li>join.getOnExpression().accept(expressionVisitor);  </li>
<li>}  </li>
<li>if (join.getUsingColumns() != null) {  </li>
<li>buffer.append(&quot; USING ( &quot;);  </li>
<li>for (Iterator<Column> iterator = join.getUsingColumns().iterator(); iterator.hasNext();) {  </li>
<li>Column column = iterator.next();  </li>
<li>buffer.append(column.getWholeColumnName());  </li>
<li>if (iterator.hasNext()) {  </li>
<li>buffer.append(&quot; ,&quot;);  </li>
<li>}  </li>
<li>}  </li>
<li>buffer.append(&quot;)&quot;);  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>}  </li>
</ol>
<p>public class OracleSelectDeParser extends SelectDeParser {</p>
<pre><code>public OracleSelectDeParser(ExpressionDeParser expressionDeParser, StringBuffer sb) {

    super(expressionDeParser, sb);
}


//*/*

 /* 重写父类方法，去掉父类方法中table前的as
 /*/

public void visit(Table tableName) {
    buffer.append(tableName.getWholeTableName());

    String alias = tableName.getAlias();
    if (alias != null &amp;&amp; StringUtil.isNotEmpty(alias)) {

        buffer.append(&quot; &quot;);
        buffer.append(alias);

    }
}


//*/*

 /* 重写父类方法，在JOIN之前增加空格
 /*/

@SuppressWarnings(&quot;unchecked&quot;)
public void deparseJoin(Join join) {

    if (join.isSimple()) {
        buffer.append(&quot;, &quot;);

    } else {
        buffer.append(&quot; &quot;);

        if (join.isRight()) {
            buffer.append(&quot;RIGHT &quot;);

        } else if (join.isNatural()) {
            buffer.append(&quot;NATURAL &quot;);

        } else if (join.isFull()) {
            buffer.append(&quot;FULL &quot;);

        } else if (join.isLeft()) {
            buffer.append(&quot;LEFT &quot;);

        }
        if (join.isOuter()) {

            buffer.append(&quot;OUTER &quot;);
        } else if (join.isInner()) {

            buffer.append(&quot;INNER &quot;);
        }

        buffer.append(&quot;JOIN &quot;);
    }


    FromItem fromItem = join.getRightItem();

    fromItem.accept(this);
    if (join.getOnExpression() != null) {

        buffer.append(&quot; ON &quot;);
        join.getOnExpression().accept(expressionVisitor);

    }
    if (join.getUsingColumns() != null) {

        buffer.append(&quot; USING ( &quot;);
        for (Iterator&lt;Column&gt; iterator = join.getUsingColumns().iterator(); iterator.hasNext();) {

            Column column = iterator.next();
            buffer.append(column.getWholeColumnName());

            if (iterator.hasNext()) {
                buffer.append(&quot; ,&quot;);

            }
        }

        buffer.append(&quot;)&quot;);
    }

}
</code></pre><p>}</p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/SQL_Java/">SQL_Java</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/SQL_Java/" class="label label-success">SQL_Java</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:41"datetime="2014-03-07 09:54:41"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-SQL_Java--SQL解析Jsqlparser/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-SQL_Java--SQL解析Jsqlparser" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-java深入分析--IOC原理分析/">IOC原理分析</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:41.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-java深入分析--IOC原理分析/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="ioc-">IOC原理分析</h1>
<p><strong><a href="http://java-mzd.iteye.com/blog/818344" target="_blank">IOC原理分析</a></strong></p>
<p><strong>文章分类**</strong>:<a href="http://www.iteye.com/blogs/category/java" target="_blank">Java编程</a>**</p>
<p>IOC(inversion of control)控制反转</p>
<p>在我们的程序中，要实现某个功能，我们都会用到两个或两个以上的类来协同完成，那么在一个类中，我们就会要有它的合作类的引用，也就是说这个类依赖于别的类，这个合作类的获取，将会有一下几种不同的情况</p>
<p>依赖获取的三种方式： </p>
<p><strong>Java**</strong>代码<strong><strong> </strong></strong> <strong>[</strong><img src="&quot;&quot;收藏这段代码&quot; &quot;" alt="收藏代码]()**"><em>**</em></p>
<ol>
<li><p>情况1.自己生成   </p>
</li>
<li></li>
<li><p>Class person{  </p>
</li>
<li></li>
<li><p>Eat(){  </p>
</li>
<li></li>
<li><p>Apple a=<strong>new</strong> Apple();  </p>
</li>
<li></li>
<li><p>}  </p>
</li>
<li></li>
<li><p>}  </p>
</li>
</ol>
<p>第一种方式：在person的eat()方法里就把吃的水果写死，从开始就创建对象，</p>
<pre><code>  缺点 ：1.Person类必须依赖于Apple类，如果Apple类没完成，则编译都不能通过
</code></pre><p>2.不能再更改，当person想再吃别的水果的时候，无法进行修改</p>
<p>3.很难共享给其他人，只能单独使用</p>
<p>4.person类要对Apple的整个生命周期负责，两个类始终耦合在一起</p>
<p><strong>Java**</strong>代码<strong><strong> </strong></strong> <strong>[</strong><img src="&quot;&quot;收藏这段代码&quot; &quot;" alt="收藏代码]()**"><em>**</em></p>
<ol>
<li><p>情况2 通过中介得到  </p>
</li>
<li></li>
<li><p>Class person{  </p>
</li>
<li></li>
<li><p>Eat(String name){  </p>
</li>
<li></li>
<li><p>Apple a=(Apple)Fruitfactory.getInstance(“name”);  </p>
</li>
<li></li>
<li><p>}}  </p>
</li>
</ol>
<p>第二种方式：1.通过使用工程类，间接得到需要的对象</p>
<p>通过使用工程类，程序效果确实得到了改进，但是问题依然存在</p>
<p>缺点：1.每个子类的生成的代码都写死在工厂类里面了，如果要换个子类，则必须更改工厂类中的方法</p>
<pre><code>            2.面向接口编程，一般都会使用工厂类，一般每个接口都会对于一个工程类，当项目非常大的时候，则会有非常多的工厂类
</code></pre><p><strong>Java**</strong>代码<strong><strong> </strong></strong> <strong>[</strong><img src="&quot;&quot;收藏这段代码&quot; &quot;" alt="收藏代码]()**"><em>**</em></p>
<ol>
<li><p>情况3.直接被注入  </p>
</li>
<li><p>Class person{  </p>
</li>
<li></li>
<li><p>Eat(Fruit fruit){  </p>
</li>
<li></li>
<li><p>//apple为Fruit实现类  </p>
</li>
<li></li>
<li><p>}  </p>
</li>
<li></li>
<li><p>}  </p>
</li>
</ol>
<p>第三种方式：只需要在外部传入一个现成的对象给方法调用，不同的实现传入不同的对象即可（感觉这么说就是简单的面向接口的编程的好处，具体优势，请看后面）</p>
<p>在系统中，我们可以用一个外部的容器Container 来统一调配整个系统的运行，将对象的创建和获取提取到外部容器，由外部容器为每个组件提供需要的组建.</p>
<p>例如：</p>
<p>在容器中创建Fruit类对象apple，</p>
<p>将Person类依赖的Fruit对象传递给Person类</p>
<p>将了这么多，那么，到底是控制的什么被反转了呢?</p>
<p>获得依赖对象的方式被反转了.</p>
<p>也就是说</p>
<p>将一个对象如何获取它所依赖的对象这个任务的控制权反转到外部容器中。对象的依赖都是在对象创建时，由负责协调整个系统中各个实体间关系的外部容器提供了。</p>
<p>了解了IOC的基本理念后</p>
<p>剩下的问题就是：怎么样把类中依赖的对象的引用传递给类？（我们把这种将依赖对象的引用传递给类的方式叫做注入）</p>
<p>接下来，我们需要研究，有几种方法，可以把对象注入到类的内部</p>
<p>注入的三种方式： </p>
<p>1．  通过接口注入</p>
<pre><code>  这种方式要求我们自己定义的组建类必须实现容器给定的一个接口，然后容器通过这个接口，为我们的组建类注入所依赖的类

  缺点：容器对组建的侵入性会很强，实现的组建只能给此容器用了，移植性不强
</code></pre><p>2．  Setter注入</p>
<pre><code>  在容器中，通过调用对象的setter()方法，将该对象的依赖传递到类当中
</code></pre><p>3．构造器注入</p>
<pre><code> 通过使用构造器，在类初始化的时候，传入对象的依赖
</code></pre><p>知道了在容器中可以有三种方式把一个类的对象的依赖传入到这个对象的当中去，但是，这个类的对象我们到底该怎么得到呢？它的依赖又该怎么得到呢？</p>
<p>难道也是在容器中，简单的通过new得到不同的对象，然后进行相互调用吗?</p>
<p>如果是这样的话，那么我们仅仅只是完成了一些基于依赖倒转的代码重构工作而已，并没有真正的体现系统的动态性</p>
<p>那么我们该怎么样才能最大程度的体现系统的动态性? 怎么样才能最大程度的将两个类之间的依赖降低，实现解耦合呢？</p>
<p>我们可以给系统一个XML的配置文件，</p>
<p>在该XML配置文件中，设置每个对象的相应的属性信息（即该类的具体依赖）</p>
<p>然后在系统中，解析XML文件得到一个实体类obj类，obj类保留没一个对象的配置信息</p>
<p>然后根据反射原理，利用解析得到的obj类中信息，动态的生成配置对应的对象，并且调用对象的setter()方法，完成对该对象的注入，</p>
<p>因为XML只是一个符合一定格式要求的文本文件，</p>
<p>所以我们可以随时更改XML文件，而不修改源代码</p>
<p>来得到我们需要的任何类型的任何一个对象，并完全对该对象的注入</p>
<p>使该对象的依赖得以进行，并能使系统最大程度的动态化，具有可拓展性</p>
<p>IoC核心理念：</p>
<p>1.在类当中不创建对象，在代码中不直接与对象和服务连接</p>
<p>2.在配置文件中描述创建对象的方式，以及各个组件之间的联系</p>
<p>3.外部容器通过解析配置文件，通过反射来将这些联系在一起</p>
<p>The Hollywood principle：Don’t call us,we’ll call you.</p>
<p>即，所有组件都是被动的、不主动联系（调用）外部代码，</p>
<p>要等着外部代码的调用--------所有的组件的初始化和相互调用都由容器负责实现。</p>
<p>简单的说，就是整个程序之间的关系，都由容器来控制:将程序的控制权反转给容器,就是所谓的外转</p>
<p>而在我们传统代码中，由程序代码直接控制</p>
<p>最后，使用一个比较形象的例子来最后阐述一次IOC的作用：</p>
<p>  所谓IoC，对于spring框架来说，就是由spring来负责控制对象的生命周期和对象间的关系。这是什么意思呢，举个简单的例子，我们是如何找女朋友的？常见的情况是，我们到处去看哪里有长得漂亮身材又好的mm，然后打听她们的兴趣爱好、qq号、电话号、ip号、iq号………，想办法认识她们，投其所好送其所要，然后嘿嘿……这个过程是复杂深奥的，我们必须自己设计和面对每个环节。传统的程序开发也是如此，在一个对象中，如果要使用另外的对象，就必须得到它（自己new一个，或者从JNDI中查询一个），使用完之后还要将对象销毁（比如Connection等），对象始终会和其他的接口或类藕合起来。</p>
<p>那么IoC是如何做的呢？有点像通过婚介找女朋友，在我和女朋友之间引入了一个第三者：婚姻介绍所。婚介管理了很多男男女女的资料，我可以向婚介提出一个列表，告诉它我想找个什么样的女朋友，比如长得像李嘉欣，身材像林熙雷，唱歌像周杰伦，速度像卡洛斯，技术像齐达内之类的，然后婚介就会按照我们的要求，提供一个mm，我们只需要去和她谈恋爱、结婚就行了。简单明了，如果婚介给我们的人选不符合要求，我们就会抛出异常。整个过程不再由我自己控制，而是有婚介这样一个类似容器的机构来控制。</p>
<p>Spring所倡导的开发方式就是如此，所有的类都会在spring容器中登记，告诉spring你是个什么东西，你需要什么东西，然后spring会在系统运行到适当的时候，把你要的东西主动给你，同时也把你交给其他需要你的东西。所有的类的创建、销毁都由spring来控制，也就是说控制对象生存周期的不再是引用它的对象，而是spring。对于某个具体的对象而言，以前是它控制其他对象，现在是所有对象都被spring控制，所以这叫控制反转。</p>
<p>IoC的一个重点,是在系统运行中动态的向某个对象提供它所需要的其他对象。这一点是通过DI（Dependency Injection，依赖注入）来实现的。比如对象A需要操作数据库，以前我们总是要在A中自己编写代码来获得一个Connection对象，有了 spring我们就只需要告诉spring，A中需要一个Connection，至于这个Connection怎么构造，何时构造，A不需要知道。在系统运行时，spring会在适当的时候制造一个Connection，然后像打针一样，注射到A当中，这样就完成了对各个对象之间关系的控制。A需要依赖 Connection才能正常运行，而这个Connection是由spring注入到A中的，依赖注入的名字就这么来的。那么DI是如何实现的呢？ Java 1.3之后一个重要特征是反射（reflection），它允许程序在运行的时候动态的生成对象、执行对象的方法、改变对象的属性，spring就是通过反射来实现注入的。</p>
<p>附注：因为参考的文章和Blog太多，无法一一表示感谢.谨在此特别感谢CSDN博客的it_man大神</p>
<p>和<a href="http://www.zhuoda.org/xiaoming/66303.html的作者" target="_blank">http://www.zhuoda.org/xiaoming/66303.html的作者</a></p>
<p>以及百度百科作者、维基百科作者</p>
<p>以及javaeye上的多为写了ioc的兄弟</p>
<p>恩，IOC原理折腾了一天总算搞明白了。接下来自己动手写个玩具Spring吧。</p>
<p>url: <a href="http://java-mzd.iteye.com/blog/818344" target="_blank">http://java-mzd.iteye.com/blog/818344</a></p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/java深入分析/">java深入分析</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/java深入分析/" class="label label-success">java深入分析</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:41"datetime="2014-03-07 09:54:41"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-java深入分析--IOC原理分析/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-java深入分析--IOC原理分析" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>





<ul id="pagination" class="pagination pagination-lg">
  <li><a class="extend prev" href="/page/59/">&laquo;</a></li><li><a class="page-number" href="/">1</a></li><li><a class="page-number" href="/page/2/">2</a></li><li><span class="space">&hellip;</span></li><li><a class="page-number" href="/page/57/">57</a></li><li><a class="page-number" href="/page/58/">58</a></li><li><a class="page-number" href="/page/59/">59</a></li><li class="active"><li><span class="page-number current">60</span></li><li><a class="page-number" href="/page/61/">61</a></li><li><a class="page-number" href="/page/62/">62</a></li><li><a class="page-number" href="/page/63/">63</a></li><li><span class="space">&hellip;</span></li></li><li><a class="page-number" href="/page/164/">164</a></li><li><a class="page-number" href="/page/165/">165</a></li><li><a class="extend next" href="/page/61/">&raquo;</a></li>
  <div class="clearfix"></div>
</ul></div><!--wapper-->
       </div><!-- ID main-col END -->
       <aside id="sidebar" class="alignright col-sx-6 col-sm-4 col-md-3 col-lg-3">
<div id="widget_search" class="widget panel panel-primary">
    <form action="//google.com/search" method="get" accept-charset="utf-8">
  <div class="input-group">
    <input class="form-control" id="searchbox" type="search" name="q" results="0" placeholder="search">
    <span class="input-group-btn">
      <button class="btn btn-default" type="submit">Go!</button>
    </span>
    <input type="hidden" name="q" value="site:itsolife.com">
  </div>
</form>
</div>

<div id="widget_category" class="widget panel panel-primary">
  <div class="panel-heading">category</div>  <div data-src='category' class='ajax_widgets'>正在加载...</div>
</div>

<div id="widget_recent_posts" class="widget panel panel-primary">
  <div class="panel-heading">recent posts</div>  <div data-src='recent_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_tagcloud" class="widget panel panel-primary">
  <div class="panel-heading">tagcloud</div>  <div data-src='tagcloud' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_latest_update_posts" class="widget panel panel-primary">
  <div class="panel-heading">最近更新</div>  <div data-src='latest_update_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_recent_comments" class="widget panel panel-primary">
  <div class="panel-heading">recent comments</div>  

<div class="list-group-item ds-recent-comments" data-num-items="6" data-show-avatars="1" data-show-time="1" data-show-title="1" data-show-admin="1" data-excerpt-length="50"></div>



</div>

</aside>
       <div class="clearfix"></div>
     </div><!-- row END -->
  </div>
  <footer id="footer" class="container">
  <div class="panel panel-info">
  <section id='footer_widget'></section>  <div class="panel-footer">
  <div id="site-info">
    <span class='author'>
  
  &copy; 2014 RobinChia
  
    &nbsp;&nbsp;</span>
  
  <span id='analytics-51la'></span><span id='analytics-google'>
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-48559895-1']);
  _gaq.push(['_trackPageview']);
  _js2load.push({src:('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'});
</script></span><span id='analytics-cnzz'>
<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_5774006'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s17.cnzz.com/stat.php%3Fid%3D5774006%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>
</span><span id='analytics-baidu'>
<script>
var _hmt = _hmt || [];
_js2load.push({src:"//hm.baidu.com/hm.js?1442f50724afc42380b51f097c43082c"});
</script>
</span>  </div>
  <div id="copyright">Blog powered by <a href='http://zespia.tw/hexo/'><strong>hexo</strong></a> Theme <strong><a href='https://github.com/chenall/hexo-theme-chenall'>chenall</a></strong>(Some change in it)<span class="pull-right"> 更新时间: <em>2014-03-15 17:28:49</em></span></div>
</div>
<div class="clearfix"></div>


  </div>
  </footer>
  
        <script src="http://cdn.bootcss.com/jquery/1.10.2/jquery.min.js"></script>        
        <script src="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/js/bootstrap.min.js"></script>        
                
        <script src="http://cdn.bootcss.com/prettify/r298/prettify.min.js"></script>    <script type="text/javascript">
   var lang=["bsh", "c", "cc", "cpp", "cs", "csh", "cyc", "cv", "htm", "html",
    "java", "js", "m", "mxml", "perl", "pl", "pm", "py", "rb", "sh",
    "xhtml", "xml", "xsl"];
   var pretty_base='';
   $('script').each(function(){
	var c = $(this).attr('src');
	if (!c)
	    return;
	if (c.match(/(\/)?prettify(\.min)?\.js/i))
	{
	    var index = c.lastIndexOf('/');
	    if (index != -1)
		pretty_base = c.substr(0,index + 1);
	    return false;
	}
   })
   $('pre code').each(function(){
	var c = $(this).attr('class')
	if (!c)
	    return;
	c = c.match(/\s?(lang\-\w+)/i);
	if (c && lang.indexOf(c[1]) == -1)
	{
	    lang.push(c[1]);
	    $.getScript(pretty_base + c[1] + '.min.js');
	}
   })

    $(window).load(function(){
       $("pre").addClass("prettyprint");
       prettyPrint();
    })
</script>    
            <script type="text/javascript">
var duoshuoQuery = {short_name:"robinchia"};
_js2load.push({src:'http://static.duoshuo.com/embed.js',charset:'UTF-8'});
</script>
    
            <!--wumii_relatedItems-->
    
        <script src="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js"></script>    <script type="text/javascript">
(function($){
  $('.entry').each(function(i){
    $(this).find('img').each(function(){
      var alt = this.alt;

      if (alt){
        $(this).before('<span class="caption">' + alt + '</span>');
      }

      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox" rel="fancybox' + i + '" />');
    });
  });

  $('.fancybox').fancybox();
})(jQuery);
</script>    
        <script src="http://cdn.bootcss.com/mathjax/2.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>    <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>
    
<script type="text/javascript">
$('.ajax_widgets').each(function(){var src=$(this).attr('data-src');if(src)$(this).load('/widgets/'+src+'.html');});
$.each(_js2load,function(index,obj){loadjs(obj.src,obj.charset)});
</script>

<div id="scroll2top">
<img src="/scroll2top/arrow.png"/>
</div>
<script src="/scroll2top/scroll2top.min.js"></script>
<div id="winterland">
  <canvas></canvas>
</div>
<script src="/js/winterland.min.js"></script>

  </body>
</html>
