
<!DOCTYPE HTML>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>The 60 Page | It so life</title>
<meta name="author" content="RobinChia">

<meta name="description" content="It so life">


<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<meta property="og:site_name" content="It so life"/>

<!--[if IE]><style>.testIE.IE{display:inline;}</style><![endif]-->
<!--[if lte IE 7]><link rel="stylesheet" href="/css/ie7.css" type="text/css"><![endif]-->
<!--[if (lt IE 9)&(gt IE 7)]><style>.testIE.IE8{display:inline;}</style><![endif]-->
<!--[if gt IE 8]><style>.testIE.IE9{display:inline;}</style><![endif]-->

<link href="/favicon.png" rel="icon">
<link rel="alternate" href="/atom.xml" title="It so life Feed" type="application/atom+xml">

<link rel="stylesheet" href="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/css/bootstrap.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/font-awesome/4.0.3/css/font-awesome.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/prettify/r298/prettify.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" type="text/css">
<link rel="stylesheet" href="/css/style.css" type="text/css">
<!--[if lt IE 9]>
   <style>article,aside,dialog,footer,header,section,footer,nav,figure,menu{display:block}</style>
   <script src="http://cdn.staticfile.org/html5shiv/r29/html5.min.js"></script>
   <script src="http://cdn.staticfile.org/respond.js/1.4.2/respond.min.js"></script>
<link href="http://cdn.staticfile.org/respond.js/1.4.2/respond-proxy.html" id="respond-proxy" rel="respond-proxy" />
<link href="/js/respond.proxy.gif" id="respond-redirect" rel="respond-redirect" />
<script src="/js/respond.proxy.js"></script>
   <script src="http://cdn.bootcss.com/selectivizr/1.0.2/selectivizr-min.js"></script>
<![endif]-->
<script type="text/javascript">
function loadjs(c,d){var a=document.createElement("script");a.async=!0;a.type="text/javascript";a.src=c;a.charset=d||"gbk";(document.getElementsByTagName("HEAD")[0]||document.getElementsByTagName("BODY")[0]).appendChild(a)};
var _protocol = (("https:" == document.location.protocol) ? " https://" : " http://");
var _js2load = [];
</script>

</head>
<body>
      <header id="header" class="container"><nav id="main-nav" class="navbar navbar-default navbar-fixed-top " role="navigation">
  <div class="container">
    <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
      <span class="sr-only">Toggle navigation</span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="/">It so life</a>
    </div>
    <div  class="collapse navbar-collapse">
      <ul  class="nav navbar-nav">
  
        <li><a href="/" title="Home">Home</a></li>      
        <li><a href="/about/" title="About">About</a></li>      
        <li><a href="/archives/" title="Archives">Archives</a></li>      
      <li class='dropdown'>
        <a class='dropdown-toggle' data-toggle='dropdown' href='#'>website<b class='caret'></b></a>
        <ul class='dropdown-menu pure-menu-selected'>
    
          <li><a href="//groups.google.com/forum/#!forum/pongba" title="TopLanguage">TopLanguage</a></li>    
          <li><a href="//itpub.net/" title="ITPub">ITPub</a></li>    
          <li><a href="//blog.jobbole.com/" title="Bole">Bole</a></li>    
          <li><a href="//nosql-database.org/" title="nosql">nosql</a></li>    
          <li><a href="//gitimmersion.googol.im/" title="Git">Git</a></li>    
        </ul>
      </li>
    
      </ul>
      <ul class="nav navbar-nav navbar-right">
      
        <li><a href="/atom.xml">RSS</a></li>
      
      
        <li><a href="https://twitter.com/robinchia">twitter</a></li>
      
      
      
      
        <li><a href="https://github.com/robinchia">github</a></li>
      
      </ul>
    </div>
  </div>
</nav>
<div class="clearfix"></div>
</header>
  <div id='content' class="container">
     <div class="page-header-wrapper">
      <!--[if lt IE 9]><div class="alert alert-warning alert-dismissable"><button type="button" class="close" data-dismiss="alert" aria-hidden="true">&times;</button><strong>提示:</strong>您的浏览器版本太低了,建议升级到 <strong><a href="http://windows.microsoft.com/zh-cn/internet-explorer/download-ie" title="IE9">IE9</a></strong> 以上,本站使用<a href="https://www.google.com/intl/zh-CN/chrome/">Chrome浏览器</a>可以获得最好的显示效果.</div><![endif]-->
      <div class="page-header"><h1 align="center"><big>It so life</big> </h1>
        <h5 align="center"><big>love as life</big></h5>
      </div>
     </div>
     <div class="row">
       <div id="main-col" class="alignleft col-sx-12 col-sm-8 col-md-9 col-lg-9">
      <section id='header_widget'></section>
          <div id="wrapper"><article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-NIO--Javaaio异步网络IO初探/">Java aio(异步网络IO)初探</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:41.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-NIO--Javaaio异步网络IO初探/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="java-aio-io-">Java aio(异步网络IO)初探</h1>
<p><a href="">&lt;</a> <a href="">&gt;</a>  猎头职位: <a href="http://www.iteye.com/jobs/2509" target="_blank">上海:  Junior Product Manager</a></p>
<p>相关文章: <a href="&quot;关闭&quot;"> </a></p>
<ul>
<li><a href="http://www.iteye.com/topic/1113611" title="JDK7 AIO 初体验" target="_blank">JDK7 AIO 初体验</a></li>
<li><a href="http://www.iteye.com/topic/446298" title="JavaSE7新特性 异步非阻塞I/O 网络通信 AIO" target="_blank">JavaSE7新特性 异步非阻塞I/O 网络通信 AIO</a></li>
<li><p><a href="http://www.iteye.com/topic/834447" title="JAVA NIO 简介" target="_blank">JAVA NIO 简介</a>
推荐群组: <a href="http://dlang.group.iteye.com/" target="_blank">D语言</a>
<a href="http://www.iteye.com/wiki/topic/472333" target="_blank">更多相关推荐</a>
<a href="http://www.iteye.com/forums/tag/%E4%BC%81%E4%B8%9A%E5%BA%94%E7%94%A8" target="_blank">企业应用</a></p>
<p>  按照《Unix网络编程》的划分，IO模型可以分为：阻塞IO、非阻塞IO、IO复用、信号驱动IO和异步IO，按照POSIX标准来划分只分为两类：同步IO和异步IO。如何区分呢？首先一个IO操作其实分成了两个步骤：发起IO请求和实际的IO操作，同步IO和异步IO的区别就在于第二个步骤是否阻塞，如果实际的IO读写阻塞请求进程，那么就是同步IO，因此阻塞IO、非阻塞IO、IO服用、信号驱动IO都是同步IO，如果不阻塞，而是操作系统帮你做完IO操作再将结果返回给你，那么就是异步IO。阻塞IO和非阻塞IO的区别在于第一步，发起IO请求是否会被阻塞，如果阻塞直到完成那么就是传统的阻塞IO，如果不阻塞，那么就是非阻塞IO。
 Java nio 2.0的主要改进就是引入了异步IO（包括文件和网络），这里主要介绍下异步网络IO API的使用以及框架的设计，以TCP服务端为例。首先看下为了支持AIO引入的新的类和接口：
<strong>java.nio.channels.AsynchronousChannel</strong></p>
<pre><code> 标记一个channel支持异步IO操作。
</code></pre><p><strong> java.nio.channels.AsynchronousServerSocketChannel</strong></p>
<pre><code> ServerSocket的aio版本，创建TCP服务端，绑定地址，监听端口等。
</code></pre><p><strong> java.nio.channels.AsynchronousSocketChannel</strong></p>
<pre><code> 面向流的异步socket channel，表示一个连接。
</code></pre><p><strong> java.nio.channels.AsynchronousChannelGroup</strong></p>
<pre><code> 异步channel的分组管理，目的是为了资源共享。一个AsynchronousChannelGroup绑定一个线程池，这个线程池执行两个任务：处理IO事件和派发CompletionHandler。AsynchronousServerSocketChannel创建的时候可以传入一个 AsynchronousChannelGroup，那么通过AsynchronousServerSocketChannel创建的 AsynchronousSocketChannel将同属于一个组，共享资源。
</code></pre><p><strong> java.nio.channels.CompletionHandler</strong></p>
<pre><code> 异步IO操作结果的回调接口，用于定义在IO操作完成后所作的回调工作。AIO的API允许两种方式来处理异步操作的结果：返回的Future模式或者注册CompletionHandler，我更推荐用CompletionHandler的方式，这些handler的调用是由 AsynchronousChannelGroup的线程池派发的。显然，线程池的大小是性能的关键因素。AsynchronousChannelGroup允许绑定不同的线程池，通过三个静态方法来创建：
</code></pre></li>
</ul>
<p>Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>public static AsynchronousChannelGroup withFixedThreadPool(int nThreads,  </li>
<li>ThreadFactory threadFactory)  </li>
<li>throws IOException  </li>
<li></li>
<li>public static AsynchronousChannelGroup withCachedThreadPool(ExecutorService executor,  </li>
<li>int initialSize)  </li>
<li></li>
<li>public static AsynchronousChannelGroup withThreadPool(ExecutorService executor)  </li>
<li>throws IOException  </li>
</ol>
<p>public static AsynchronousChannelGroup withFixedThreadPool(int nThreads,</p>
<pre><code>                                                           ThreadFactory threadFactory)
    throws IOException
</code></pre><p>public static AsynchronousChannelGroup withCachedThreadPool(ExecutorService executor,</p>
<pre><code>                                                            int initialSize)
</code></pre><p>public static AsynchronousChannelGroup withThreadPool(ExecutorService executor)
        throws IOException</p>
<pre><code> 需要根据具体应用相应调整，从框架角度出发，需要暴露这样的配置选项给用户。
 在介绍完了aio引入的TCP的主要接口和类之后，我们来设想下一个aio框架应该怎么设计。参考非阻塞nio框架的设计，一般都是采用**Reactor**模式，Reacot负责事件的注册、select、事件的派发；相应地，异步IO有个**Proactor**模式，Proactor负责 CompletionHandler的派发，查看一个典型的IO写操作的流程来看两者的区别：
 Reactor:  send(msg) -&gt; 消息队列是否为空，如果为空  -&gt; 向Reactor注册OP_WRITE，然后返回 -&gt; Reactor select -&gt; 触发Writable，通知用户线程去处理 -&gt;先注销Writable(很多人遇到的cpu 100%的问题就在于没有注销）,处理Writeable，如果没有完全写入，继续注册OP_WRITE。注意到，写入的工作还是用户线程在处理。
 Proactor: send(msg) -&gt; 消息队列是否为空，如果为空,发起read异步调用，并注册CompletionHandler，然后返回。 -&gt; 操作系统负责将你的消息写入，并返回结果（写入的字节数）给Proactor -&gt; Proactor派发CompletionHandler。可见，写入的工作是操作系统在处理，无需用户线程参与。事实上在aio的API 中,**AsynchronousChannelGroup就扮演了Proactor的角色**。
CompletionHandler有三个方法，分别对应于处理成功、失败、被取消（通过返回的Future)情况下的回调处理：
</code></pre><p>Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>public interface CompletionHandler<V,A> {  </li>
<li></li>
<li>void completed(V result, A attachment);  </li>
<li></li>
<li>void failed(Throwable exc, A attachment);  </li>
<li></li>
<li></li>
<li>void cancelled(A attachment);  </li>
<li>}  </li>
</ol>
<p>public interface CompletionHandler<V,A> {</p>
<pre><code> void completed(V result, A attachment);


void failed(Throwable exc, A attachment);




void cancelled(A attachment);
</code></pre><p>}</p>
<pre><code>其中的泛型参数V表示IO调用的结果，而A是发起调用时传入的attchment。
在初步介绍完aio引入的类和接口后，我们看看一个典型的tcp服务端是怎么启动的，怎么接受连接并处理读和写，这里引用的代码都是yanf4j 的aio分支中的代码，可以从svn checkout，svn地址: [http://yanf4j.googlecode.com/svn/branches/yanf4j-aio](http://yanf4j.googlecode.com/svn/branches/yanf4j-aio)
第一步，创建一个AsynchronousServerSocketChannel，创建之前先创建一个 AsynchronousChannelGroup，上文提到AsynchronousServerSocketChannel可以绑定一个 AsynchronousChannelGroup，那么通过这个AsynchronousServerSocketChannel建立的连接都将同属于一个AsynchronousChannelGroup并共享资源：
</code></pre><p>Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>this.asynchronousChannelGroup = AsynchronousChannelGroup  </li>
<li>.withCachedThreadPool(Executors.newCachedThreadPool(),  </li>
<li>this.threadPoolSize);  </li>
</ol>
<p>this.asynchronousChannelGroup = AsynchronousChannelGroup</p>
<pre><code>                .withCachedThreadPool(Executors.newCachedThreadPool(),
                        this.threadPoolSize);

 然后初始化一个AsynchronousServerSocketChannel，通过open方法：
</code></pre><p>Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>this.serverSocketChannel = AsynchronousServerSocketChannel  </li>
<li>.open(this.asynchronousChannelGroup);  </li>
</ol>
<p>this.serverSocketChannel = AsynchronousServerSocketChannel</p>
<pre><code>            .open(this.asynchronousChannelGroup);


通过nio 2.0引入的SocketOption类设置一些TCP选项：
</code></pre><p>Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>this.serverSocketChannel  </li>
<li>.setOption(  </li>
<li>StandardSocketOption.SO_REUSEADDR,true);  </li>
<li>this.serverSocketChannel  </li>
<li>.setOption(  </li>
<li>StandardSocketOption.SO_RCVBUF,16/*1024);  </li>
</ol>
<p>this.serverSocketChannel</p>
<pre><code>                .setOption(
                        StandardSocketOption.SO_REUSEADDR,true);
</code></pre><p>this.serverSocketChannel
                    .setOption(</p>
<pre><code>                        StandardSocketOption.SO_RCVBUF,16/*1024);


绑定本地地址：
</code></pre><p>Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>this.serverSocketChannel  </li>
<li>.bind(new InetSocketAddress(&quot;localhost&quot;,8080), 100);  </li>
</ol>
<p>this.serverSocketChannel</p>
<pre><code>                .bind(new InetSocketAddress(&quot;localhost&quot;,8080), 100);



其中的100用于指定等待连接的队列大小(backlog)。完了吗？还没有，最重要的**监听**工作还没开始，监听端口是为了等待连接上来以便accept产生一个AsynchronousSocketChannel来表示一个新建立的连接，因此需要发起一个accept调用，调用是异步的，操作系统将在连接建立后，将最后的结果——**AsynchronousSocketChannel**返回给你：
</code></pre><p>Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>public void pendingAccept() {  </li>
<li>if (this.started &amp;&amp; this.serverSocketChannel.isOpen()) {  </li>
<li>this.acceptFuture = this.serverSocketChannel.accept(null,  </li>
<li>new AcceptCompletionHandler());  </li>
<li></li>
<li>} else {  </li>
<li>throw new IllegalStateException(&quot;Controller has been closed&quot;);  </li>
<li>}  </li>
<li>}  </li>
</ol>
<p>public void pendingAccept() {</p>
<pre><code>    if (this.started &amp;&amp; this.serverSocketChannel.isOpen()) {
        this.acceptFuture = this.serverSocketChannel.accept(null,

                new AcceptCompletionHandler());


    } else {
        throw new IllegalStateException(&quot;Controller has been closed&quot;);

    }
}
</code></pre><p>   注意，重复的accept调用将会抛出PendingAcceptException，后文提到的read和write也是如此。accept方法的第一个参数是你想传给CompletionHandler的attchment，第二个参数就是注册的用于回调的CompletionHandler，最后返回结果Future<AsynchronousSocketChannel>。你可以对future做处理，这里采用更推荐的方式就是注册一个CompletionHandler。那么accept的CompletionHandler中做些什么工作呢？显然一个赤裸裸的 AsynchronousSocketChannel是不够的，我们需要将它封装成session，一个session表示一个连接（mina里就叫 IoSession了），里面带了一个缓冲的消息队列以及一些其他资源等。在连接建立后，除非你的服务器只准备接受一个连接，不然你需要在后面<strong>继续调用pendingAccept来发起另一个accept请求</strong>：</p>
<p>Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>private final class AcceptCompletionHandler implements  </li>
<li>CompletionHandler<AsynchronousSocketChannel, Object> {  </li>
<li></li>
<li>@Override  </li>
<li>public void cancelled(Object attachment) {  </li>
<li>logger.warn(&quot;Accept operation was canceled&quot;);  </li>
<li>}  </li>
<li></li>
<li>@Override  </li>
<li>public void completed(AsynchronousSocketChannel socketChannel,  </li>
<li>Object attachment) {  </li>
<li>try {  </li>
<li>logger.debug(&quot;Accept connection from &quot;  </li>
<li><ul>
<li>socketChannel.getRemoteAddress());  </li>
</ul>
</li>
<li>configureChannel(socketChannel);  </li>
<li>AioSessionConfig sessionConfig = buildSessionConfig(socketChannel);  </li>
<li>Session session = new AioTCPSession(sessionConfig,  </li>
<li>AioTCPController.this.configuration  </li>
<li>.getSessionReadBufferSize(),  </li>
<li>AioTCPController.this.sessionTimeout);  </li>
<li>session.start();  </li>
<li>registerSession(session);  </li>
<li>} catch (Exception e) {  </li>
<li>e.printStackTrace();  </li>
<li>logger.error(&quot;Accept error&quot;, e);  </li>
<li>notifyException(e);  </li>
<li>} finally {  </li>
<li><strong>pendingAccept</strong>();  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>@Override  </li>
<li>public void failed(Throwable exc, Object attachment) {  </li>
<li>logger.error(&quot;Accept error&quot;, exc);  </li>
<li>try {  </li>
<li>notifyException(exc);  </li>
<li>} finally {  </li>
<li><strong>pendingAccept</strong>();  </li>
<li>}  </li>
<li>}  </li>
<li>}  </li>
</ol>
<p>private final class AcceptCompletionHandler implements</p>
<pre><code>        CompletionHandler&lt;AsynchronousSocketChannel, Object&gt; {


    @Override
    public void cancelled(Object attachment) {

        logger.warn(&quot;Accept operation was canceled&quot;);
    }


    @Override

    public void completed(AsynchronousSocketChannel socketChannel,
            Object attachment) {

        try {
            logger.debug(&quot;Accept connection from &quot;

                    + socketChannel.getRemoteAddress());
            configureChannel(socketChannel);

            AioSessionConfig sessionConfig = buildSessionConfig(socketChannel);
            Session session = new AioTCPSession(sessionConfig,

                    AioTCPController.this.configuration
                            .getSessionReadBufferSize(),

                    AioTCPController.this.sessionTimeout);
            session.start();

            registerSession(session);
        } catch (Exception e) {

            e.printStackTrace();
            logger.error(&quot;Accept error&quot;, e);

            notifyException(e);
        } finally {
</code></pre><p><strong>pendingAccept</strong></p>
<p>();
            }</p>
<pre><code>    }


    @Override
    public void failed(Throwable exc, Object attachment) {

        logger.error(&quot;Accept error&quot;, exc);
        try {

            notifyException(exc);
        } finally {
</code></pre><p><strong>pendingAccept</strong></p>
<p>();
            }</p>
<pre><code>    }
}



注意到了吧，我们在failed和completed方法中在最后都调用了pendingAccept来继续发起accept调用，等待新的连接上来。有的同学可能要说了，这样搞是不是递归调用，会不会堆栈溢出？实际上不会，因为发起accept调用的线程与CompletionHandler回调的线程并非同一个，不是一个上下文中，两者之间没有耦合关系。要注意到，CompletionHandler的回调共用的是 AsynchronousChannelGroup绑定的线程池，因此**千万别在CompletionHandler回调方法中调用阻塞或者长时间的操作**，例如sleep，回调方法最好能支持超时，防止线程池耗尽。
连接建立后，怎么读和写呢？回忆下在nonblocking nio框架中，连接建立后的第一件事是干什么？注册OP_READ事件等待socket可读。异步IO也同样如此，连接建立后马上发起一个异步read调用，等待socket可读，这个是Session.start方法中所做的事情：
</code></pre><p>Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>public class AioTCPSession {  </li>
<li>protected void start0() {  </li>
<li>pendingRead();  </li>
<li>}  </li>
<li></li>
<li>protected final void pendingRead() {  </li>
<li>if (!isClosed() &amp;&amp; this.asynchronousSocketChannel.isOpen()) {  </li>
<li>if (!this.readBuffer.hasRemaining()) {  </li>
<li>this.readBuffer = ByteBufferUtils  </li>
<li>.increaseBufferCapatity(this.readBuffer);  </li>
<li>}  </li>
<li>this.readFuture = this.asynchronousSocketChannel.read(  </li>
<li>this.readBuffer, this, this.readCompletionHandler);  </li>
<li>} else {  </li>
<li>throw new IllegalStateException(  </li>
<li>&quot;Session Or Channel has been closed&quot;);  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>}  </li>
</ol>
<p>public class AioTCPSession {</p>
<pre><code>protected void start0() {
    pendingRead();

}


protected final void pendingRead() {
    if (!isClosed() &amp;&amp; this.asynchronousSocketChannel.isOpen()) {

        if (!this.readBuffer.hasRemaining()) {
            this.readBuffer = ByteBufferUtils

                    .increaseBufferCapatity(this.readBuffer);
        }

        this.readFuture = this.asynchronousSocketChannel.read(
                this.readBuffer, this, this.readCompletionHandler);

    } else {
        throw new IllegalStateException(

                &quot;Session Or Channel has been closed&quot;);
    }

}
</code></pre><p>}</p>
<pre><code> AsynchronousSocketChannel的read调用与AsynchronousServerSocketChannel的accept调用类似，同样是非阻塞的，返回结果也是一个Future，但是写的结果是整数，表示写入了多少字节，因此read调用返回的是 **Future&lt;Integer&gt;**，方法的第一个参数是读的缓冲区，操作系统将IO读到数据拷贝到这个缓冲区，第二个参数是传递给 CompletionHandler的attchment，第三个参数就是注册的用于回调的CompletionHandler。这里保存了read的结果Future，这是为了在关闭连接的时候能够主动取消调用，accept也是如此。现在可以看看read的CompletionHandler的实现：
</code></pre><p>Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>public final class ReadCompletionHandler implements  </li>
<li>CompletionHandler<Integer, AbstractAioSession> {  </li>
<li></li>
<li>private static final Logger log = LoggerFactory  </li>
<li>.getLogger(ReadCompletionHandler.class);  </li>
<li>protected final AioTCPController controller;  </li>
<li></li>
<li>public ReadCompletionHandler(AioTCPController controller) {  </li>
<li>this.controller = controller;  </li>
<li>}  </li>
<li></li>
<li>@Override  </li>
<li>public void cancelled(AbstractAioSession session) {  </li>
<li>log.warn(&quot;Session(&quot; + session.getRemoteSocketAddress()  </li>
<li><ul>
<li>&quot;) read operation was canceled&quot;);  </li>
</ul>
</li>
<li>}  </li>
<li></li>
<li>@Override  </li>
<li>public void completed(Integer result, AbstractAioSession session) {  </li>
<li>if (log.isDebugEnabled())  </li>
<li>log.debug(&quot;Session(&quot; + session.getRemoteSocketAddress()  </li>
<li><ul>
<li>&quot;) read +&quot; + result + &quot; bytes&quot;);  </li>
</ul>
</li>
<li>if (result &lt; 0) {  </li>
<li>session.close();  </li>
<li>return;  </li>
<li>}  </li>
<li>try {  </li>
<li>if (result &gt; 0) {  </li>
<li>session.updateTimeStamp();  </li>
<li>session.getReadBuffer().flip();  </li>
<li>session.decode();  </li>
<li>session.getReadBuffer().compact();  </li>
<li>}  </li>
<li>} finally {  </li>
<li>try {  </li>
<li>session.pendingRead();  </li>
<li>} catch (IOException e) {  </li>
<li>session.onException(e);  </li>
<li>session.close();  </li>
<li>}  </li>
<li>}  </li>
<li>controller.checkSessionTimeout();  </li>
<li>}  </li>
<li></li>
<li>@Override  </li>
<li>public void failed(Throwable exc, AbstractAioSession session) {  </li>
<li>log.error(&quot;Session read error&quot;, exc);  </li>
<li>session.onException(exc);  </li>
<li>session.close();  </li>
<li>}  </li>
<li></li>
<li>}  </li>
</ol>
<p>public final class ReadCompletionHandler implements</p>
<pre><code>    CompletionHandler&lt;Integer, AbstractAioSession&gt; {


private static final Logger log = LoggerFactory
        .getLogger(ReadCompletionHandler.class);

protected final AioTCPController controller;


public ReadCompletionHandler(AioTCPController controller) {
    this.controller = controller;

}


@Override
public void cancelled(AbstractAioSession session) {

    log.warn(&quot;Session(&quot; + session.getRemoteSocketAddress()
            + &quot;) read operation was canceled&quot;);

}


@Override
public void completed(Integer result, AbstractAioSession session) {

    if (log.isDebugEnabled())
        log.debug(&quot;Session(&quot; + session.getRemoteSocketAddress()

                + &quot;) read +&quot; + result + &quot; bytes&quot;);
    if (result &lt; 0) {

        session.close();
        return;

    }
    try {

        if (result &gt; 0) {
            session.updateTimeStamp();

            session.getReadBuffer().flip();
            session.decode();

            session.getReadBuffer().compact();
        }

    } finally {
        try {

            session.pendingRead();
        } catch (IOException e) {

            session.onException(e);
            session.close();

        }
    }

    controller.checkSessionTimeout();
}


@Override

public void failed(Throwable exc, AbstractAioSession session) {
    log.error(&quot;Session read error&quot;, exc);

    session.onException(exc);
    session.close();

}
</code></pre><p>}</p>
<p>   如果IO读失败，会返回失败产生的异常，这种情况下我们就主动关闭连接，通过session.close()方法，这个方法干了两件事情：关闭channel和取消read调用：</p>
<p>Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>if (null != this.readFuture) {  </li>
<li>this.readFuture.cancel(true);  </li>
<li>}  </li>
<li>this.asynchronousSocketChannel.close();  </li>
</ol>
<p>if (null != this.readFuture) {</p>
<pre><code>        this.readFuture.cancel(true);
    }
</code></pre><p>this.asynchronousSocketChannel.close();</p>
<p>   在读成功的情况下，我们还需要判断结果result是否小于0，<strong>如果小于0就表示对端关闭了</strong>，这种情况下我们也主动关闭连接并返回。如果读到一定字节，也就是result大于0的情况下，我们就尝试从读缓冲区中decode出消息，并派发给业务处理器的回调方法，最终<strong>通过pendingRead继续发起read调用等待socket的下一次可读</strong>。可见，我们并不需要自己去调用channel来进行IO读，而是操作系统帮你直接读到了缓冲区，然后给你一个结果表示读入了多少字节，你处理这个结果即可。而nonblocking IO框架中，是reactor通知用户线程socket可读了，然后用户线程自己去调用read进行实际读操作。这里还有个需要注意的地方，就是decode出来的消息的派发给业务处理器工作最好交给一个线程池来处理，避免阻塞group绑定的线程池。</p>
<p>   IO写的操作与此类似，不过通常写的话我们会在session中关联一个缓冲队列来处理，没有完全写入或者等待写入的消息都存放在队列中，队列为空的情况下发起write调用：</p>
<p>Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>protected void write0(WriteMessage message) {  </li>
<li>boolean needWrite = false;  </li>
<li>synchronized (this.writeQueue) {  </li>
<li>needWrite = this.writeQueue.isEmpty();  </li>
<li>this.writeQueue.offer(message);  </li>
<li>}  </li>
<li>if (needWrite) {  </li>
<li>pendingWrite(message);  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>protected final void pendingWrite(WriteMessage message) {  </li>
<li>message = preprocessWriteMessage(message);  </li>
<li>if (!isClosed() &amp;&amp; this.asynchronousSocketChannel.isOpen()) {  </li>
<li>this.asynchronousSocketChannel.write(message.getWriteBuffer(),  </li>
<li>this, this.writeCompletionHandler);  </li>
<li>} else {  </li>
<li>throw new IllegalStateException(  </li>
<li>&quot;Session Or Channel has been closed&quot;);  </li>
<li>}  </li>
<li><p>}  </p>
<p>protected void write0(WriteMessage message) {</p>
<p>   boolean needWrite = false;
   synchronized (this.writeQueue) {</p>
<pre><code>   needWrite = this.writeQueue.isEmpty();
   this.writeQueue.offer(message);
</code></pre><p>   }
   if (needWrite) {</p>
<pre><code>   pendingWrite(message);
</code></pre><p>   }</p>
<p>}</p>
</li>
</ol>
<pre><code>protected final void pendingWrite(WriteMessage message) {
    message = preprocessWriteMessage(message);

    if (!isClosed() &amp;&amp; this.asynchronousSocketChannel.isOpen()) {
        this.asynchronousSocketChannel.write(message.getWriteBuffer(),

                this, this.writeCompletionHandler);
    } else {

        throw new IllegalStateException(
                &quot;Session Or Channel has been closed&quot;);

    }
}




write调用返回的结果与read一样是一个Future&lt;Integer&gt;，而write的CompletionHandler处理的核心逻辑大概是这样：
</code></pre><p>Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>@Override  </li>
<li>public void completed(Integer result, AbstractAioSession session) {  </li>
<li>if (log.isDebugEnabled())  </li>
<li>log.debug(&quot;Session(&quot; + session.getRemoteSocketAddress()  </li>
<li><ul>
<li>&quot;) writen &quot; + result + &quot; bytes&quot;);  </li>
</ul>
</li>
<li></li>
<li>WriteMessage writeMessage;  </li>
<li>Queue<WriteMessage> writeQueue = session.getWriteQueue();  </li>
<li>synchronized (writeQueue) {  </li>
<li>writeMessage = writeQueue.peek();  </li>
<li>if (writeMessage.getWriteBuffer() == null  </li>
<li>|| !writeMessage.getWriteBuffer().hasRemaining()) {  </li>
<li>writeQueue.remove();  </li>
<li>if (writeMessage.getWriteFuture() != null) {  </li>
<li>writeMessage.getWriteFuture().setResult(Boolean.TRUE);  </li>
<li>}  </li>
<li>try {  </li>
<li>session.getHandler().onMessageSent(session,  </li>
<li>writeMessage.getMessage());  </li>
<li>} catch (Exception e) {  </li>
<li>session.onException(e);  </li>
<li>}  </li>
<li>writeMessage = writeQueue.peek();  </li>
<li>}  </li>
<li>}  </li>
<li>if (writeMessage != null) {  </li>
<li>try {  </li>
<li>session.pendingWrite(writeMessage);  </li>
<li>} catch (IOException e) {  </li>
<li>session.onException(e);  </li>
<li>session.close();  </li>
<li>}  </li>
<li>}  </li>
<li>}  </li>
</ol>
<p>@Override</p>
<pre><code>public void completed(Integer result, AbstractAioSession session) {
    if (log.isDebugEnabled())

        log.debug(&quot;Session(&quot; + session.getRemoteSocketAddress()
                + &quot;) writen &quot; + result + &quot; bytes&quot;);


    WriteMessage writeMessage;

    Queue&lt;WriteMessage&gt; writeQueue = session.getWriteQueue();
    synchronized (writeQueue) {

        writeMessage = writeQueue.peek();
        if (writeMessage.getWriteBuffer() == null

                || !writeMessage.getWriteBuffer().hasRemaining()) {
            writeQueue.remove();

            if (writeMessage.getWriteFuture() != null) {
                writeMessage.getWriteFuture().setResult(Boolean.TRUE);

            }
            try {

                session.getHandler().onMessageSent(session,
                        writeMessage.getMessage());

            } catch (Exception e) {
                session.onException(e);

            }
            writeMessage = writeQueue.peek();

        }
    }

    if (writeMessage != null) {
        try {

            session.pendingWrite(writeMessage);
        } catch (IOException e) {

            session.onException(e);
            session.close();

        }
    }

}
</code></pre><p>   compete方法中的result就是实际写入的字节数，然后我们判断消息的缓冲区是否还有剩余，如果没有就将消息从队列中移除，如果队列中还有消息，那么继续发起write调用。
   重复一下，这里引用的代码都是yanf4j aio分支中的源码，感兴趣的朋友可以直接check out出来看看: <a href="http://yanf4j.googlecode.com/svn/branches/yanf4j-aio" target="_blank"><a href="http://yanf4j.googlecode.com/svn/branches/yanf4j-aio">http://yanf4j.googlecode.com/svn/branches/yanf4j-aio</a></a>。
   在引入了aio之后，java对于网络层的支持已经非常完善，该有的都有了，java也已经成为服务器开发的首选语言之一。java的弱项在于对内存的管理上，由于这一切都交给了GC，因此在高性能的网络服务器上还是Cpp的天下。java这种单一堆模型比之erlang的进程内堆模型还是有差距，很难做到高效的垃圾回收和细粒度的内存管理。
   这里仅仅是介绍了aio开发的核心流程，对于一个网络框架来说，还需要考虑超时的处理、缓冲buffer的处理、业务层和网络层的切分、可扩展性、性能的可调性以及一定的通用性要求。</p>
<p>刚看了一点，第一行有个错别字，不是IO服用，是复用，嘿嘿
老大终于开始介绍java NIO了。。
还有一点，看过一些源代码，对事件驱动还是理解不深，也请老大介绍下把。
rain2005 写道</p>
<p>刚看了一点，第一行有个错别字，不是IO服用，是复用，嘿嘿
老大终于开始介绍java NIO了。。
还有一点，看过一些源代码，对事件驱动还是理解不深，也请老大介绍下把。
多谢指正，关于事件机制，我会画个UML图可能比较清晰</p>
<p>上面提到几个类 怎么在jdk6中没发现那
是不是要下载第三方框架
正好想研究一下
收藏啦
xly_971223 写道</p>
<p>上面提到几个类 怎么在jdk6中没发现那
是不是要下载第三方框架
正好想研究一下
收藏啦
aio是在jdk7引入的，请下载JDK7 preview1版本，或者open jdk</p>
<p>dennis_zane 写道</p>
<p>xly_971223 写道</p>
<p>上面提到几个类 怎么在jdk6中没发现那
是不是要下载第三方框架
正好想研究一下
收藏啦
aio是在jdk7引入的，请下载JDK7 preview1版本，或者open jdk
是不是这个意思。
jdk7以前的nio是非阻塞IO,操作系统底层比方说linux,是用IO复用select实现的
jdk7用的是真正的异步IO,操作系统底层是用epoll实现的
是这样的吗？
rain2005 写道</p>
<p>dennis_zane 写道</p>
<p>xly_971223 写道</p>
<p>上面提到几个类 怎么在jdk6中没发现那
是不是要下载第三方框架
正好想研究一下
收藏啦
aio是在jdk7引入的，请下载JDK7 preview1版本，或者open jdk
是不是这个意思。
jdk7以前的nio是非阻塞IO,操作系统底层比方说linux,是用IO复用select实现的
jdk7用的是真正的异步IO,操作系统底层是用epoll实现的
是这样的吗？
epoll也不是异步IO啊。异步IO在linux上目前仅限于文件系统，并且还没有得到广泛应用，很多平台都没有这玩意。
java aio在windows上是利用iocp实现的，这是真正的异步IO。而在linux上，是通过epoll模拟的。</p>
<p>楼主，你好，我写的server是p2p的应用，恩，想请教一下，因为我对数据库这一块的操作并不是特别的多，基本是客户自己也有很多是服务器，不知道是否可以在事件响应的当前线程来对数据库操作呢？前提是把线程池子的数目设的大些？或者用那个JDK提供的可自己增加线程的池子？
因为如果在弄个池子来处理数据库的话，担心线程太多了，
你如果时间充分心情好的话，真希望你能讲解一下和别人公用一台服务器（主机）是怎么用的呢。。。
总之要谢谢你对这段代码的讲解，kang sang mi da
wujingsong 写道</p>
<p>楼主，你好，我写的server是p2p的应用，恩，想请教一下，因为我对数据库这一块的操作并不是特别的多，基本是客户自己也有很多是服务器，不知道是否可以在事件响应的当前线程来对数据库操作呢？前提是把线程池子的数目设的大些？或者用那个JDK提供的可自己增加线程的池子？
因为如果在弄个池子来处理数据库的话，担心线程太多了，
你如果时间充分心情好的话，真希望你能讲解一下和别人公用一台服务器（主机）是怎么用的呢。。。
总之要谢谢你对这段代码的讲解，kang sang mi da
按我的经验来说，类似数据库操作这样的IO操作，最好还是起个线程池来处理，防止阻塞框架内部的处理线程。如果这样的操作不是特别多，那么直接在响应线程处理也未尝不可，还是建议你自己搞两个版本性能对比一下。
wujingsong 写道</p>
<p>和别人公用一台是怎么用的呢？
我还真不明白什么意思，现在我们的应用基本都跑在虚拟机上了，几个应用跑在一个物理机上。虚拟化我不懂，就不乱弹了。</p>
<p>kang sa mi da,谢谢楼主的回复,确实是个很好的建议.
闲聊啊,今天无意看到Google 上一个音乐的图片链接,点进去后,看到了一个不大容易理解的词,说什么
            &quot;在南中国常年保持高收听率的极有个性的节目&quot;,
费解.....广东那边是这么叫的吗?不大可能吧..</p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/NIO/">NIO</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/NIO/" class="label label-success">NIO</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:41"datetime="2014-03-07 09:54:41"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-NIO--Javaaio异步网络IO初探/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-NIO--Javaaio异步网络IO初探" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-SQL_Java--Java中，获得ResultSet的总行数与总列数/">Java中，获得ResultSet的总行数与总列数</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:41.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-SQL_Java--Java中，获得ResultSet的总行数与总列数/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="java-resultset-">Java中，获得ResultSet的总行数与总列数</h1>
<h2 id="java-resultset-">Java中，获得ResultSet的总行数与总列数</h2>
<p>在Java中，获得ResultSet的总行数的方法有以下几种。</p>
<p><strong>第一种：利用ResultSet的getRow方法来获得ResultSet的总行数</strong></p>
<p>Statement stmt = con.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_UPDATABLE);
ResultSet rset = stmt.executeQuery(&quot;select /* from yourTableName&quot;);
rset.last();
int rowCount = rset.getRow(); //获得ResultSet的总行数</p>
<p><strong>第二种：利用循环ResultSet的元素来获得ResultSet的总行数</strong></p>
<p>ResultSet rset = stmt.executeQuery(&quot;select /* from yourTableName&quot;);
int rowCount = 0;
while(rset.next()) {
rowCount++;
}</p>
<p>rowCount就是ResultSet的总行数。</p>
<p><strong>第三种：利用sql语句中的count函数获得ResultSet的总行数</strong></p>
<p>ResultSet rset = stmt.executeQuery(&quot;select count(/*) totalCount from yourTableName&quot;);
int rowCount = 0;
if(rset.next()) {
rowCount=rset .getInt(&quot;totalCount &quot;);
}</p>
<p>rowCount就是ResultSet的总行数。</p>
<ul>
<li>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/*</li>
<li>Java中获得ResultSet的总列数是非常简单事情，因为Java中ResultSet提供了ResultSetMetaData工具类,ResultSetMetaData 是ResultSet的元数据的集合说明。</li>
</ul>
<p>java获得ResultSet总列数的代码如下：</p>
<p>Statement stmt = con.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_UPDATABLE);
ResultSet rset = stmt.executeQuery(&quot;select /* from yourtable&quot;);
ResultSetMetaData rsmd = rset.getMetaData() ;
int columnCount = rsmd.getColumnCount();</p>
<p>columnCount 就是ResultSet的总列数。</p>
<hr>
<p>例子：
Statement stmt = conn.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,  ResultSet.CONCUR_READ_ONLY);   ResultSet rs = stmt.executeQuery(sql);   rs.last();   int length = rs.getRow();</p>
<p>如上，length的值，就是行数了。如果在获取了行数后，还需要继续使用当前数据集rs，则需要rs.beforeFirst();一次，将游标回到初始位置。
ResultSet.TYPE_SCROLL_INSENSITIVE 结果集的游标可以上下移动，当数据库变化时，当前结果集不变。
ResultSet.CONCUR_READ_ONLY 不能用结果集更新数据库中的表。</p>
<p>此外，给出Statement创建时的其他说明：
通用格式为：Statement stmt=con.createStatement(int type，int concurrency);我们在访问数据库的时候，在读取返回结果的时候，可能要前后移动指针，比如我们先计算有多少条信息，这是我们就需要把指针移到最后来计算，然后再把指针移到最前面，逐条读取，有时我们只需要逐条读取就可以了。还有就是有只我们只需要读取数据，为了不破坏数据，我们可采用只读模式，有时我们需要望数据库里添加记录，这是我们就要采用可更新数据库的模式。
下面是所有参数的说明：
参数 int type
ResultSet.TYPE_FORWORD_ONLY 结果集的游标只能向下滚动。
ResultSet.TYPE_SCROLL_INSENSITIVE 结果集的游标可以上下移动，当数据库变化时，当前结果集不变。
ResultSet.TYPE_SCROLL_SENSITIVE 返回可滚动的结果集，当数据库变化时，当前结果集同步改变。</p>
<p>参数 int concurrency</p>
<p>ResultSet.CONCUR_READ_ONLY 不能用结果集更新数据库中的表。
ResultSet.CONCUR_UPDATETABLE 能用结果集更新数据库中的表。</p>
<p>此外，当我们使用ResultSet re=stmt.executeQuery(SQL语句）查询后，我们可以使用下列方法获得信息：</p>
<p>public boolean previous() 将游标向上移动，该方法返回boolean型数据，当移到结果集第一行之前时，返回false。
public void beforeFirst 将游标移动到结果集的初始位置，即在第一行之前。
public void afterLast() 将游标移到结果集最后一行之后。
public void first() 将游标移到结果集的第一行。
public void last() 将游标移到结果集的最后一行。
public boolean isAfterLast() 判断游标是否在最后一行之后。
public boolean isBeforeFirst() 判断游标是否在第一行之前。
public boolean ifFirst() 判断游标是否指向结果集的第一行。
public boolean isLast() 判断游标是否指向结果集的最后一行。
public int getRow() 得到当前游标所指向行的行号，行号从1开始，如果结果集没有行，返回0。
public boolean absolute(int row) 将游标移到参数row指定的行号。如果row取负值，就是倒数的行数，absolute(-1)表示移到最后一行，absolute(-2)表示移到倒数第2行。当移动到第一行前面或最后一行的后面时，该方法返回false。</p>
<p>ResultSetMetaData rsmd = this.rs.getMetaData();
this.columnCount = rsmd.getColumnCount();</p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/SQL_Java/">SQL_Java</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/SQL_Java/" class="label label-success">SQL_Java</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:41"datetime="2014-03-07 09:54:41"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-SQL_Java--Java中，获得ResultSet的总行数与总列数/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-SQL_Java--Java中，获得ResultSet的总行数与总列数" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_多线程-并发--深入浅出JavaConcurrency37-并发总结/">深入浅出 Java Concurrency (37)</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:41.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_多线程-并发--深入浅出JavaConcurrency37-并发总结/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-java-concurrency-37-">深入浅出 Java Concurrency (37): 并发总结</h1>
<p><a href="http://www.blogjava.net/xylz/archive/2011/12/29/365149.html" target="_blank">深入浅出 Java Concurrency (37): 并发总结 part 1 死锁与活跃度</a></p>
<h1 id="-">死锁与活跃度</h1>
<p>前面谈了很多并发的特性和工具，但是大部分都是和锁有关的。我们使用锁来保证线程安全，但是这也会引起一些问题。</p>
<ul>
<li>锁顺序死锁(lock-ordering deadlock)：多个线程试图通过不同的顺序获得多个相同的资源，则发生的循环锁依赖现象。</li>
<li>动态的锁顺序死锁（Dynamic Lock Order Deadlocks）：多个线程通过传递不同的锁造成的锁顺序死锁问题。</li>
<li>资源死锁（Resource Deadlocks）：线程间相互等待对方持有的锁，并且谁都不会释放自己持有的锁发生的死锁。也就是说当现场持有和等待的目标成为资源，就有可能发生此死锁。这和锁顺序死锁不一样的地方是，竞争的资源之间并没有严格先后顺序，仅仅是相互依赖而已。</li>
</ul>
<h2 id="-">锁顺序死锁</h2>
<p>最经典的锁顺序死锁就是LeftRightDeadLock.
<img src="" alt=""></p>
<p>public class LeftRightDeadLock {
    final Object left = new Object();
    final Object right = new Object();
    public void doLeftRight() {
        synchronized (left) {
            synchronized (right) {
                execute1();
            }
        }
    }
    public void doRightLeft() {
        synchronized (right) {
            synchronized (left) {
                execute2();
            }
        }
    }
    private void execute2() {
    }
    private void execute1() {
    }
}</p>
<p>这个例子很简单，当两个线程分别获取到left和right锁时，互相等待对方释放其对应的锁，很显然双方都陷入了绝境。</p>
<h2 id="-">动态的锁顺序死锁</h2>
<p>与锁顺序死锁不同的是动态的锁顺序死锁只是将静态的锁变成了动态锁。 一个比较生动的例子是这样的。</p>
<p>public void transferMoney(Account fromAccount,//
        Account toAccount,//
        int amount
        ) {
    synchronized (fromAccount) {
        synchronized (toAccount) {
            fromAccount.decr(amount);
            toAccount.add(amount);
        }
    }
}
当我们银行转账的时候，我们期望锁住双方的账户，这样保证是原子操作。 看起来很合理，可是如果双方同时在进行转账操作，那么就有可能发生死锁的可能性。</p>
<p>很显然，动态的锁顺序死锁的解决方案应该看起来和锁顺序死锁解决方案差不多。 但是一个比较特殊的解决方式是纠正这种顺序。 例如可以调整成这样：
Object lock = new Object();
public void transferMoney(Account fromAccount,//
        Account toAccount,//
        int amount
        ) {
    int order = fromAccount.name().compareTo(toAccount.name());
    Object lockFirst = order&gt;0?toAccount:fromAccount;
    Object lockSecond = order&gt;0?fromAccount:toAccount;
    if(order==0){
        synchronized(lock){
            synchronized(lockFirst){
                synchronized(lockSecond){
                    //do work
                }
            }
        }
    }else{
        synchronized(lockFirst){
            synchronized(lockSecond){
                //do work
            }
        }
    }
}</p>
<p>这个挺有意思的。比较两个账户的顺序，保证此两个账户之间的传递顺序总是按照某一种锁的顺序进行的， 即使多个线程同时发生，也会遵循一次操作完释放完锁才进行下一次操作的顺序，从而可以避免死锁的发生。</p>
<h2 id="-">资源死锁</h2>
<p>资源死锁比较容易理解，就是需要的资源远远大于已有的资源，这样就有可能线程间的资源竞争从而发生死锁。 一个简单的场景是，应用同时从两个连接池中获取资源，两个线程都在等待对方释放连接池的资源以便能够同时获取 到所需要的资源，从而发生死锁。</p>
<p>资源死锁除了这种资源之间的直接依赖死锁外，还有一种叫线程饥饿死锁（thread-starvation deadlock）。 严格意义上讲，这种死锁更像是活跃度问题。例如提交到线程池中的任务由于总是不能够抢到线程从而一直不被执行， 造成任务的“假死”状况。</p>
<p>除了上述几种问题外，还有协作对象间的死锁以及开发调用的问题。这个描述起来会比较困难，也不容易看出死锁来。</p>
<h1 id="-">避免和解决死锁</h1>
<p>通常发生死锁后程序难以自恢复。但也不是不能避免的。 有一些技巧和原则是可以降低死锁可能性的。</p>
<p>最简单的原则是尽可能的减少锁的范围。锁的范围越小，那么竞争的可能性也越小。 尽快释放锁也有助于避开锁顺序。如果一个线程每次最多只能够获取一个锁，那么就不会产生锁顺序死锁。尽管应用中比较困难，但是减少锁的边界有助于分析程序的设计和简化流程。 减少锁之间的依赖以及遵守获取锁的顺序是避免锁顺序死锁的有效途径。</p>
<p>另外尽可能的使用定时的锁有助于程序从死锁中自恢复。 例如对于上述顺序锁死锁中，使用定时锁很容易解决此问题。</p>
<p>public void doLeftRight() throws Exception {
    boolean over = false;
    while (!over) {
        if (left.tryLock(1, TimeUnit.SECONDS)) {
            try {
                if (right.tryLock(1, TimeUnit.SECONDS)) {
                    try {
                        execute1();
                    } finally {
                        right.unlock();
                        over = true;
                    }
                }
            } finally {
                left.unlock();
            }
        }
    }
}
public void doRightLeft() throws Exception {
    boolean over = false;
    while (!over) {
        if (right.tryLock(1, TimeUnit.SECONDS)) {
            try {
                if (left.tryLock(1, TimeUnit.SECONDS)) {
                    try {
                        execute2();
                    } finally {
                        left.unlock();
                        over = true;
                    }
                }
            } finally {
                right.unlock();
            }
        }
    }
}
看起来代码会比较复杂，但是这是避免死锁的有效方式。</p>
<h1 id="-">活跃度</h1>
<p>对于多线程来说，死锁是非常严重的系统问题，必须修正。除了死锁，遇到很多的就是活跃度问题了。 活跃度问题主要包括：饥饿，丢失信号，和活锁等。</p>
<h2 id="-">饥饿</h2>
<p>饥饿是指线程需要访问的资源被永久拒绝，以至于不能在继续进行。 比如说：某个权重比较低的线程可能一直不能够抢到CPU周期，从而一直不能够被执行。</p>
<p>也有一些场景是比较容易理解的。对于一个固定大小的连接池中，如果连接一直被用完，那么过多的任务可能由于一直无法抢占到连接从而不能够被执行。这也是饥饿的一种表现。</p>
<p>对于饥饿而言，就需要平衡资源的竞争，例如线程的优先级，任务的权重，执行的周期等等。总之，当空闲的资源较多的情况下，发生饥饿的可能性就越小。</p>
<h2 id="-">弱响应性</h2>
<p>弱响应是指，线程最终能够得到有效的执行，只是等待的响应时间较长。 最常见的莫过于GUI的“假死”了。很多时候GUI的响应只是为了等待后台数据的处理，如果线程协调不好，很有可能就会发生“失去响应”的现象。</p>
<p>另外，和饥饿很类似的情况。如果一个线程长时间独占一个锁，那么其它需要此锁的线程很有可能就会被迫等待。</p>
<h2 id="-">活锁</h2>
<p>活锁（Livelock）是指线程虽然没有被阻塞，但是由于某种条件不满足，一直尝试重试，却终是失败。</p>
<p>考虑一个场景，我们从队列中拿出一个任务来执行，如果任务执行失败，那么将任务重新加入队列，继续执行。假如任务总是执行失败，或者某种依赖的条件总是不满足，那么线程一直在繁忙却没有任何结果。</p>
<p>错误的循环引用和判断也有可能导致活锁。当某些条件总是不能满足的时候，可能陷入死循环的境地。</p>
<p>线程间的协同也有可能导致活锁。例如如果两个线程发生了某些条件的碰撞后重新执行，那么如果再次尝试后依然发生了碰撞，长此下去就有可能发生活锁。</p>
<p>解决活锁的一种方案是对重试机制引入一些随机性。例如如果检测到冲突，那么就暂停随机的一定时间进行重试。这回大大减少碰撞的可能性。</p>
<p>另外为了避免可能的死锁，适当加入一定的重试次数也是有效的解决办法。尽管这在业务上会引起一些复杂的逻辑处理。
来源： <a href="[http://www.blogjava.net/xylz/archive/2011/12/29/365149.html](http://www.blogjava.net/xylz/archive/2011/12/29/365149.html)">[http://www.blogjava.net/xylz/archive/2011/12/29/365149.html](http://www.blogjava.net/xylz/archive/2011/12/29/365149.html)</a> </p>
<h1 id="-">常见的并发场景</h1>
<h2 id="-">线程池</h2>
<p>并发最常见用于线程池，显然使用线程池可以有效的提高吞吐量。</p>
<p>最常见、比较复杂一个场景是Web容器的线程池。Web容器使用线程池同步或者异步处理HTTP请求，同时这也可以有效的复用HTTP连接，降低资源申请的开销。通常我们认为HTTP请求时非常昂贵的，并且也是比较耗费资源和性能的，所以线程池在这里就扮演了非常重要的角色。</p>
<p>在<a href="http://www.blogjava.net/xylz/archive/2010/12/19/341098.html" target="_blank">线程池</a>的章节中非常详细的讨论了线程池的原理和使用，同时也提到了，线程池的配置和参数对性能的影响是巨大的。不尽如此，受限于资源（机器的性能、网络的带宽等等）、依赖的服务，客户端的响应速度等，线程池的威力也不会一直增长。达到了线程池的瓶颈后，性能和吞吐量都会大幅度降低。</p>
<p>一直增加机器的性能或者增大线程的个数，并不一定能有效的提高吞吐量。高并发的情况下，机器的负载会大幅提升，这时候机器的稳定性、服务的可靠性都会下降。</p>
<p>尽管如此，线程池依然是提高吞吐量的一个有效措施，配合合适的参数能够有效的充分利用资源，提高资源的利用率。</p>
<h2 id="-">任务队列</h2>
<p>除了线程池是比较发杂的并发场景外，<a href="http://www.blogjava.net/xylz/archive/2010/07/21/326723.html" target="_blank">任务队列</a>也是一个不错的并发工具。JDK内部有大量的队列（Queue),这些工具不仅能够方便使用，提高生产力，也能够进行组合适应于不同的场景。即使线程池内部，也是用了任务队列来处理任务的积压，平衡资源的消耗。</p>
<p>安全的任务队列能够有效的平衡机器的复杂，抵消由于峰值和波动带来的不稳定，有效提高服务的可靠性。同时任务队列的处理也有助于统计和分析服务的状况。</p>
<p>任务队列也可以在多个线程之间传递数据，有助于并行处理任务。例如经典的“生产者-消费者”模型就可以有效的提高多个线程的并行处理能力。在IO延时比较大的服务中尤其有效。 我最喜欢的一个案例是导数据是，一个线程负责往固定大小的任务队列中压入大量的数据，队列满了以后就暂停，另外几个线程负责从任务队列中获取数据并消费。这将串行的“生产-消费”，变成了并行的“生产-消费”。实践证明极大的节省任务处理时间。</p>
<h2 id="-">异步处理</h2>
<p>线程池也是异步处理的一种表现形式，除此之外，使用异步处理的目的也是为了提高服务的处理速度。 例如AOP的一个例子就是使用切面来记录日志，如果说我们要远程收集日志，显然不希望由于收集日志而影响服务本身。这时候就将日志收集的过程进行异步处理。</p>
<p>如今大量的开源组件都喜欢使用异步处理来提高IO的效率，某些不需要同步返回的操作使用异步处理后能够有效的提高吞吐量。</p>
<p>当然，异步也不总是令人满意的，也会有相应的问题。例如引入异步设计后的复杂性，线程中断后的处理机制，失败后的处理策略，产生的消息比消费的还快时怎么办，关闭程序时如何关闭异步处理逻辑等等。这都会增加系统的复杂性。</p>
<p>尽管大量的服务、业务使用异步来处理，但是很显然需要有保障机制能够保证异步处理的逻辑正确性。如果认为异步处理的任务不是特别重要，或者说主业务不能因为附属业务的逻辑出错而崩溃，那么使用异步处理是正确的选择。</p>
<h2 id="-">同步操作</h2>
<p>并发操作的同时还需要维护数据的一致性，或多或少的会涉及到同步操作。正确的使用原子操作，合理的使用独占锁和读写锁也是一个很大的挑战。</p>
<p>线程间的协调与通信，尤其是状态的同步都是比较困难的。我们看到线程池<a href="http://www.blogjava.net/xylz/archive/2011/01/18/343183.html" target="_blank">ThreadPoolExecutor</a>的实现为了解决各个线程的执行状态，引入的很多的同步操作。线程越来越多的情况下，同步的成本会越来越高，同时也有可能引入死锁的情况。</p>
<p>尽管如此，单个JVM内部的多线程同步还是比较容易控制的。JDK内部也提供了大量的工具来方便完成数据的同步。例如<a href="http://www.blogjava.net/xylz/archive/2010/07/05/325274.html" target="_blank">Lock</a>/<a href="http://www.blogjava.net/xylz/archive/2010/07/08/325540.html" target="_blank">Condition</a>/<a href="http://www.blogjava.net/xylz/archive/2010/07/09/325612.html" target="_blank">CountDownLatch</a>/<a href="http://www.blogjava.net/xylz/archive/2010/07/12/325913.html" target="_blank">CyclicBarrier</a>/<a href="http://www.blogjava.net/xylz/archive/2010/07/13/326021.html" target="_blank">Semaphore</a>/<a href="http://www.blogjava.net/xylz/archive/2010/11/22/338733.html" target="_blank">Exchanger</a>等等。</p>
<h2 id="-">分布式锁</h2>
<p>分布式的并发问题更难以处理，根据<a href="http://en.wikipedia.org/wiki/CAP_theorem" target="_blank">CAP</a>的原理，基本上没有一个至善至美的方案。 分布式资源协调使用分布式锁是一个不错的选择。<a href="http://blog.nosqlfan.com/html/1038.html" target="_blank">Google的分布式锁</a>（建立在BigTable之上），<a href="http://zookeeper.apache.org/doc/r3.3.2/zookeeperOver.html" target="_blank">Zookeeper的分布式锁</a>，甚至简单的利用<a href="http://memcached.org/" target="_blank">memcache</a>的add操作或者<a href="http://redis.io/" target="_blank">redis</a>的setnx操作建立伪分布式锁也可以解决类似的问题。
来源： <a href="[http://www.blogjava.net/xylz/archive/2011/12/29/367480.html](http://www.blogjava.net/xylz/archive/2011/12/29/367480.html)">[http://www.blogjava.net/xylz/archive/2011/12/29/367480.html](http://www.blogjava.net/xylz/archive/2011/12/29/367480.html)</a> </p>
<h1 id="-">常见的并发陷阱</h1>
<h2 id="volatile">volatile</h2>
<p>volatile只能强调数据的可见性，并不能保证原子操作和线程安全，因此volatile不是万能的。参考<a href="http://www.blogjava.net/xylz/archive/2010/07/03/325168.html" target="_blank">指令重排序</a></p>
<p>volatile最常见于下面两种场景。</p>
<p>a. 循环检测机制
volatile boolean done = false;
<img src="" alt="">
    while( ! done ){
        dosomething();
    }</p>
<p>b. 单例模型 （<a href="http://www.blogjava.net/xylz/archive/2009/12/18/306622.html%ef%bc%89" target="_blank"><a href="http://www.blogjava.net/xylz/archive/2009/12/18/306622.html）">http://www.blogjava.net/xylz/archive/2009/12/18/306622.html）</a>
</a></p>
<p><a href="http://www.blogjava.net/xylz/archive/2009/12/18/306622.html%ef%bc%89">public class DoubleLockSingleton {
    private static volatile DoubleLockSingleton instance = null;
    private DoubleLockSingleton() {
    }
    public static DoubleLockSingleton getInstance() {
        if (instance == null) {
            synchronized (DoubleLockSingleton.class) {
                if (instance == null) {
                    instance = new DoubleLockSingleton();
                }
            }
        }
        return instance;
    }
}</a></p>
<h2 id="synchronized-lock">synchronized/Lock</h2>
<p>看起来Lock有更好的性能以及更灵活的控制，是否完全可以替换synchronized？</p>
<p>在<a href="http://www.blogjava.net/xylz/archive/2010/07/16/326246.html" target="_blank">锁的一些其它问题</a>中说过，synchronized的性能随着JDK版本的升级会越来越高，而Lock优化的空间受限于CPU的性能，很有限。另外JDK内部的工具（线程转储）对synchronized是有一些支持的（方便发现死锁等），而对Lock是没有任何支持的。</p>
<p>也就说简单的逻辑使用synchronized完全没有问题，随着机器的性能的提高，这点开销是可以忽略的。而且从代码结构上讲是更简单的。简单就是美。</p>
<p>对于复杂的逻辑，如果涉及到读写锁、条件变量、更高的吞吐量以及更灵活、动态的用法，那么就可以考虑使用Lock。当然这里尤其需要注意Lock的正确用法。
Lock lock = <img src="" alt="">
lock.lock();
try{
    //do something
}finally{
    lock.unlock();
}</p>
<p>一定要将Lock的释放放入finally块中，否则一旦发生异常或者逻辑跳转，很有可能会导致锁没有释放，从而发生死锁。而且这种死锁是难以排查的。</p>
<p>如果需要synchronized无法做到的尝试锁机制，或者说担心发生死锁无法自恢复，那么使用tryLock()是一个比较明智的选择的。
Lock lock = <img src="" alt="">
if(lock.tryLock()){
    try{
        //do something
    }finally{
        lock.unlock();
    }
}</p>
<p>甚至可以使用获取锁一段时间内超时的机制Lock.tryLock(long,TimeUnit)。 锁的使用可以参考前面文章的描述和建议。</p>
<h2 id="-">锁的边界</h2>
<p>一个流行的错误是这样的。
ConcurrentMap<String,String> map = new ConcurrentHashMap<String,String>();
if(!map.containsKey(key)){
    map.put(key,value);
}</p>
<p>看起来很合理的，对于一个线程安全的Map实现，要存取一个不重复的结果，先检测是否存在然后加入。 其实我们知道两个原子操作和在一起的指令序列不代表就是线程安全的。 割裂的多个原子操作放在一起在多线程的情况下就有可能发生错误。</p>
<p>实际上ConcurrentMap提供了putIfAbsent(K, V)的“原子操作”机制，这等价于下面的逻辑：
if(map.containsKey(key)){
    return map.get(key);
}else{
    return map.put(k,v);
}</p>
<p>除了putIfAbsent还有replace(K, V)以及replace(K, V, V)两种机制来完成组合的操作。</p>
<p>提到Map，这里有一篇谈<a href="http://www.blogjava.net/xylz/archive/2009/12/18/306602.html" target="_blank">HashMap读写并发</a>的问题。</p>
<h2 id="-">构造函数启动线程</h2>
<p>下面的实例是在构造函数中启动一个线程。
public class Runner{
   int x,y;
   Thread thread;
   public Runner(){
      this.x=1;
      this.y=2;
      this.thread=new MyThread();
      this.thread.start();
   }
}</p>
<p>这里可能存在的陷阱是如果此类被继承，那么启动的线程可能无法正确读取子类的初始化操作。</p>
<p>因此一个简单的原则是，禁止在构造函数中启动线程，可以考虑但是提供一个方法来启动线程。如果非要这么做，最好将类设置为final，禁止继承。</p>
<h2 id="-">丢失通知的问题</h2>
<p><a href="http://www.blogjava.net/xylz/archive/2011/09/05/326988.html" target="_blank">这篇文章</a>里面提到过notify丢失通知的问题。</p>
<p>对于wait/notify/notifyAll以及await/singal/singalAll，如果不确定到底是否能够正确的收到消息，担心丢失通知，简单一点就是总是通知所有。</p>
<p>如果担心只收到一次消息，使用循环一直监听是不错的选择。</p>
<p>非常主用性能的系统，可能就需要区分到底是通知单个还是通知所有的挂起者。</p>
<h2 id="-">线程数</h2>
<p>并不是线程数越多越好，在下一篇文章里面会具体了解下性能和可伸缩性。 简单的说，线程数多少没有一个固定的结论，受限于CPU的内核数，IO的性能以及依赖的服务等等。因此选择一个合适的线程数有助于提高吞吐量。</p>
<p>对于CPU密集型应用，线程数和CPU的内核数一致有助于提高吞吐量，所有CPU都很繁忙，效率就很高。 对于IO密集型应用，线程数受限于IO的性能，某些时候单线程可能比多线程效率更高。但通常情况下适当提高线程数，有利于提高网络IO的效率，因为我们总是认为网络IO的效率比较低。</p>
<p>对于线程池而言，选择合适的线程数以及任务队列是提高线程池效率的手段。
public ThreadPoolExecutor(
    int corePoolSize,
    int maximumPoolSize,
    long keepAliveTime,
    TimeUnit unit,
    BlockingQueue<Runnable> workQueue,
    ThreadFactory threadFactory,
    RejectedExecutionHandler handler)</p>
<p>对于线程池来说，如果任务总是有积压，那么可以适当提高corePoolSize大小；如果机器负载较低，那么可以适当提高maximumPoolSize的大小；任务队列不长的情况下减小keepAliveTime的时间有助于降低负载；另外任务队列的长度以及任务队列的<a href="http://www.blogjava.net/xylz/archive/2011/01/18/343183.html" target="_blank">拒绝策略</a>也会对任务的处理有一些影响。
来源： <a href="[http://www.blogjava.net/xylz/archive/2011/12/30/367592.html](http://www.blogjava.net/xylz/archive/2011/12/30/367592.html)">[http://www.blogjava.net/xylz/archive/2011/12/30/367592.html](http://www.blogjava.net/xylz/archive/2011/12/30/367592.html)</a> </p>
<h1 id="-">性能与伸缩性</h1>
<p>使用线程的一种说法是为了提高性能。多线程可以使程序充分利用闲置的资源，提高资源的利用率，同时能够并行处理任务，提高系统的响应性。 但是很显然，引入线程的同时也引入了系统的复杂性。另外系统的性能并不是总是随着线程数的增加而总是提高。</p>
<h2 id="-">性能与伸缩性</h2>
<p>性能的提升通常意味着可以用更少的资源做更多的事情。这里资源是包括我们常说的CPU周期、内存、网络带宽、磁盘IO、数据库、WEB服务等等。 引入多线程可以充分利用多核的优势，充分利用IO阻塞带来的延迟，也可以降低网络开销带来的影响，从而提高单位时间内的响应效率。</p>
<p>为了提高性能，需要有效的利用我们现有的处理资源，同时也要开拓新的可用资源。例如，对于CPU而言，理想状况下希望CPU能够满负荷工作。当然这里满负荷工作是指做有用的事情，而不是无谓的死循环或者等待。受限于CPU的计算能力，如果CPU达到了极限，那么很显然我们充分利用了计算能力。对于IO而言（内存、磁盘、网络等），如果达到了其对于的带宽，这些资源的利用率也就上去了。理想状况下所有资源的能力都被用完了，那么这个系统的性能达到了最大值。</p>
<p>为了衡量系统的性能，有一些指标用于定性、定量的分析。例如服务时间、等待时间、吞吐量、效率、可伸缩性、生成量等等。服务时间、等待时间等用于衡量系统的效率，即到底有多快。吞吐量、生成量等用于衡量系统的容量，即能够处理多少数据。除此之外，有效服务时间、中断时间等用于能力系统的可靠性和稳定性等。</p>
<p>可伸缩性的意思是指增加计算资源，吞吐量和生产量相应得到的改进。 从算法的角度讲，通常用复杂度来衡量其对应的性能。例如时间复杂度、空间复杂度等。</p>
<h2 id="amdahl-">Amdahl定律</h2>
<p>并行的任务增加资源显然能够提高性能，但是如果是串行的任务，增加资源并不一定能够得到合理的性能提升。 <a href="http://en.wikipedia.org/wiki/Amdahl%27s_law" target="_blank">Amdahl定律</a>描述的在一个系统中，增加处理器资源对系统行的提升比率。 假定在一个系统中，F是必须串行化执行的比重，N是处理器资源，那么随着N的增加最多增加的加速比：
<img src="" alt=""></p>
<p>理论上，当N趋近于无穷大时，加速比最大值无限趋近于1/F。 这意味着如果一个程序的串行化比重为50%，那么并行化后最大加速比为2倍。</p>
<p>加速比除了可以用于加速的比率外，也可以用于衡量CPU资源的利用率。如果每一个CPU的资源利用率为100%，那么CPU的资源每次翻倍时，加速比也应该翻倍。 事实上，在拥有10个处理器的系统中，程序如果有10%是串行化的，那么最多可以加速1/(0.1+(1-0.1)/10)=5.3倍，换句话说CPU的利用率只用5.3/10=53%。而如果处理器增加到100倍，那么加速比为9.2倍，也就是说CPU的利用率只有个9.3%。</p>
<p>显然增加CPU的数量并不能提高CPU的利用率。下图描述的是随着CPU的数量增加，不同串行化比重的系统的加速比。
<img src="" alt=""></p>
<p>很显然，串行比重越大，增加CPU资源的效果越不明显。</p>
<h2 id="-">性能提升</h2>
<p>性能的提升可以从以下几个方面入手。</p>
<h3 id="-">系统平台的资源利用率</h3>
<p>一个程序对系统平台的资源利用率是指某一个设备繁忙且服务于此程序的时间占所有时间的比率。从物理学的角度讲类似于有用功的比率。简单的说就是：资源利用率=有效繁忙时间/总耗费时间。</p>
<p>也就说尽可能的让设备做有用的功，同时榨取其最大值。无用的循环可能会导致CPU 100%的使用率，但不一定是有效的工作。有效性通常难以衡量，通常只能以主观来评估，或者通过被优化的程序的行为来判断是否提高了有效性。</p>
<h3 id="-">延迟</h3>
<p>延迟描述的是完成任务所耗费的时间。延迟有时候也成为响应时间。如果有多个并行的操作，那么延迟取决于耗费时间最大的任务。</p>
<h3 id="-">多处理</h3>
<p>多处理是指在单一系统上同时执行多个进程或者多个程序的能力。多处理能力的好处是可以提高吞吐量。多处理可以有效利用多核CPU的资源。</p>
<h3 id="-">多线程</h3>
<p>多线程描述的是同一个地址空间内同时执行多个线程的过程。这些线程都有不同的执行路径和不同的栈结构。我们说的并发性更多的是指针对线程。</p>
<h3 id="-">并发性</h3>
<p>同时执行多个程序或者任务称之为并发。单程序内的多任务处理或者多程序间的多任务处理都认为是并发。</p>
<h3 id="-">吞吐量</h3>
<p>吞吐量衡量系统在单位之间内可以完成的工作总量。对于硬件系统而言，吞吐量是物理介质的上限。在没有达到物理介质之前，提高系统的吞吐量也可以大幅度改进性能。同时吞吐量也是衡量性能的一个指标。</p>
<h3 id="-">瓶颈</h3>
<p>程序运行过程中性能最差的地方。通常而言，串行的IO、磁盘IO、内存单元分配、网络IO等都可能造成瓶颈。某些使用太频繁的算法也有可能成为瓶颈。</p>
<h3 id="-">可扩展性</h3>
<p>这里的可扩展性主要是指程序或系统通过增加可使用的资源而增加性能的能力。</p>
<h2 id="-">线程开销</h2>
<p>假设引入的多线程都用于计算，那么性能一定会有很大的提升么？ 其实引入多线程以后也会引入更多的开销。</p>
<h3 id="-">切换上下文</h3>
<p>如果可运行的线程数大于CPU的内核数，那么OS会根据一定的调度算法，强行切换正在运行的线程，从而使其它线程能够使用CPU周期。</p>
<p>切换线程会导致上下文切换。线程的调度会导致CPU需要在操作系统和进程间花费更多的时间片段，这样真正执行应用程序的时间就减少了。另外上下文切换也会导致缓存的频繁进出，对于一个刚被切换的线程来说，可能由于高速缓冲中没有数据而变得更慢，从而导致更多的IO开销。</p>
<h3 id="-">内存同步</h3>
<p>不同线程间要进行数据同步，synchronized以及volatile提供的可见性都会导致缓存失效。线程栈之间的数据要和主存进行同步，这些同步有一些小小的开销。如果线程间同时要进行数据同步，那么这些同步的线程可能都会受阻。</p>
<h3 id="-">阻塞</h3>
<p>当发生锁竞争时，失败的线程会导致阻塞。通常阻塞的线程可能在JVM内部进行自旋等待，或者被操作系统挂起。自旋等待可能会导致更多的CPU切片浪费，而操作系统挂起则会导致更多的上下文切换。</p>
<p>了解了性能的提升的几个方面，也了解性能的开销后，应用程序就要根据实际的场景进行取舍和评估。没有一劳永逸的优化方案，不断的进行小范围改进和调整是提高性能的有效手段。当前一些大的架构调整也会导致较大的性能的提升。</p>
<p>简单的原则是在保证逻辑正确的情况小，找到性能瓶颈，小步改进和优化。</p>
<h2 id="-">参考资料</h2>
<ul>
<li>Amdahl&#39;s law: <a href="http://en.wikipedia.org/wiki/Amdahl%27s_law" target="_blank"><a href="http://en.wikipedia.org/wiki/Amdahl%27s_law">http://en.wikipedia.org/wiki/Amdahl%27s_law</a></a></li>
<li>Gustafson&#39;s law: <a href="http://en.wikipedia.org/wiki/Gustafson%27s_law" target="_blank"><a href="http://en.wikipedia.org/wiki/Gustafson%27s_law">http://en.wikipedia.org/wiki/Gustafson%27s_law</a></a></li>
<li>Sun-Ni law: <a href="http://en.wikipedia.org/wiki/Sun-Ni_law" target="_blank"><a href="http://en.wikipedia.org/wiki/Sun-Ni_law">http://en.wikipedia.org/wiki/Sun-Ni_law</a></a></li>
<li>多核系统中三种典型锁竞争的加速比分析 <a href="http://blog.csdn.net/drzhouweiming/article/details/1800319" target="_blank"><a href="http://blog.csdn.net/drzhouweiming/article/details/1800319">http://blog.csdn.net/drzhouweiming/article/details/1800319</a></a></li>
<li>阿姆达尔定律和Gustafson定律的等价性 <a href="http://book.51cto.com/art/201004/197506.htm" target="_blank"><a href="http://book.51cto.com/art/201004/197506.htm">http://book.51cto.com/art/201004/197506.htm</a></a>
来源： <a href="[http://www.blogjava.net/xylz/archive/2011/12/31/367641.html](http://www.blogjava.net/xylz/archive/2011/12/31/367641.html)">[http://www.blogjava.net/xylz/archive/2011/12/31/367641.html](http://www.blogjava.net/xylz/archive/2011/12/31/367641.html)</a> </li>
</ul>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/Java_多线程/">Java_多线程</a></li><li><a href="/categories/Java&J2EE/Java_多线程/并发/">并发</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/Java_多线程/" class="label label-success">Java_多线程</a><a href="/tags/并发/" class="label label-info">并发</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:41"datetime="2014-03-07 09:54:41"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-Java_多线程-并发--深入浅出JavaConcurrency37-并发总结/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-Java_多线程-并发--深入浅出JavaConcurrency37-并发总结" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-NIO--javanio网络编程的一点心得/">java nio网络编程的一点心得</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:41.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-NIO--javanio网络编程的一点心得/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="java-nio-">java nio网络编程的一点心得</h1>
<p>前几日用java nio写了一个<a href="http://code.google.com/p/marlon-tools/source/browse/tools/tcpmon/TCPMonitorSelect.java" target="_blank">tcp端口转发小工具</a>，还颇费周折，其中一个原因在于网上资料很混乱，不少还是错误的。这篇文章中我会以一个EchoServer作为例子。先看<a href="http://book.douban.com/subject/1438754/" target="_blank">《Java网络编程》</a>中的写法，这也是在网上颇为常见的一个写法。
Java代码  <a href="&quot;收藏这段代码&quot;"><img src="http://marlonyao.iteye.com/images/icon_star.png" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>public class EchoServer {  </li>
<li>public static int DEFAULT_PORT = 7777;  </li>
<li></li>
<li>public static void main(String[] args) throws IOException {  </li>
<li>System.out.println(&quot;Listening for connection on port &quot; + DEFAULT_PORT);  </li>
<li></li>
<li>Selector selector = Selector.open();  </li>
<li>initServer(selector);  </li>
<li></li>
<li>while (true) {  </li>
<li>selector.select();  </li>
<li></li>
<li>for (Iterator<SelectionKey> itor = selector.selectedKeys().iterator(); itor.hasNext();) {  </li>
<li>SelectionKey key = (SelectionKey) itor.next();  </li>
<li>itor.remove();  </li>
<li>try {  </li>
<li>if (key.isAcceptable()) {  </li>
<li>ServerSocketChannel server = (ServerSocketChannel) key.channel();  </li>
<li>SocketChannel client = server.accept();  </li>
<li>System.out.println(&quot;Accepted connection from &quot; + client);  </li>
<li>client.configureBlocking(false);  </li>
<li>SelectionKey clientKey = client.register(selector, SelectionKey.OP_WRITE|SelectionKey.OP_READ);  </li>
<li>ByteBuffer buffer = ByteBuffer.allocate(100);  </li>
<li>clientKey.attach(buffer);  </li>
<li>}  </li>
<li>if (key.isReadable()) {  </li>
<li>SocketChannel client = (SocketChannel) key.channel();  </li>
<li>ByteBuffer buffer = (ByteBuffer) key.attachment();  </li>
<li>client.read(buffer);  </li>
<li>}  </li>
<li>if (key.isWritable()) {  </li>
<li>// System.out.println(&quot;is writable...&quot;);  </li>
<li>SocketChannel client = (SocketChannel) key.channel();  </li>
<li>ByteBuffer buffer = (ByteBuffer) key.attachment();  </li>
<li>buffer.flip();  </li>
<li>client.write(buffer);  </li>
<li>buffer.compact();  </li>
<li>}  </li>
<li>} catch (IOException e) {  </li>
<li>key.cancel();  </li>
<li>try { key.channel().close(); } catch (IOException ioe) { }  </li>
<li>}  </li>
<li>}  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>private static void initServer(Selector selector) throws IOException,  </li>
<li>ClosedChannelException {  </li>
<li>ServerSocketChannel serverChannel = ServerSocketChannel.open();  </li>
<li>ServerSocket ss = serverChannel.socket();  </li>
<li>ss.bind(new InetSocketAddress(DEFAULT_PORT));  </li>
<li>serverChannel.configureBlocking(false);  </li>
<li>serverChannel.register(selector, SelectionKey.OP_ACCEPT);  </li>
<li>}  </li>
<li>}  </li>
</ol>
<p>public class EchoServer {</p>
<pre><code>public static int DEFAULT_PORT = 7777;


public static void main(String[] args) throws IOException {
    System.out.println(&quot;Listening for connection on port &quot; + DEFAULT_PORT);


    Selector selector = Selector.open();

    initServer(selector);


    while (true) {
        selector.select();


        for (Iterator&lt;SelectionKey&gt; itor = selector.selectedKeys().iterator(); itor.hasNext();) {

            SelectionKey key = (SelectionKey) itor.next();
            itor.remove();

            try {
                if (key.isAcceptable()) {

                    ServerSocketChannel server = (ServerSocketChannel) key.channel();
                    SocketChannel client = server.accept();

                    System.out.println(&quot;Accepted connection from &quot; + client);
                    client.configureBlocking(false);

                    SelectionKey clientKey = client.register(selector, SelectionKey.OP_WRITE|SelectionKey.OP_READ);
                    ByteBuffer buffer = ByteBuffer.allocate(100);

                    clientKey.attach(buffer);
                }

                if (key.isReadable()) {
                    SocketChannel client = (SocketChannel) key.channel();

                    ByteBuffer buffer = (ByteBuffer) key.attachment();
                    client.read(buffer);

                }
                if (key.isWritable()) {

                    // System.out.println(&quot;is writable...&quot;);
                    SocketChannel client = (SocketChannel) key.channel();

                    ByteBuffer buffer = (ByteBuffer) key.attachment();
                    buffer.flip();

                    client.write(buffer);
                    buffer.compact();

                }
            } catch (IOException e) {

                key.cancel();
                try { key.channel().close(); } catch (IOException ioe) { }

            }
        }

    }
}


private static void initServer(Selector selector) throws IOException,

        ClosedChannelException {
    ServerSocketChannel serverChannel = ServerSocketChannel.open();

    ServerSocket ss = serverChannel.socket();
    ss.bind(new InetSocketAddress(DEFAULT_PORT));

    serverChannel.configureBlocking(false);
    serverChannel.register(selector, SelectionKey.OP_ACCEPT);

}
</code></pre><p>}
上面的代码很典型，运行结果似乎也是正确的。
Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>marlon$ java EchoServer&amp;  </li>
<li>--&gt; Listening for connection on port 7777  </li>
<li>marlon$ telnet localhost 7777  </li>
<li>--&gt; Accepted connection from java.nio.channels.SocketChannel[connected local=/127.0.0.1:7777 remote=/127.0.0.1:65030]  </li>
<li>hello  </li>
<li>--&gt; hello  </li>
<li>world  </li>
<li>--&gt;world  </li>
</ol>
<p>marlon$ java EchoServer&amp;</p>
<p>--&gt; Listening for connection on port 7777
marlon$ telnet localhost 7777</p>
<p>--&gt; Accepted connection from java.nio.channels.SocketChannel[connected local=/127.0.0.1:7777 remote=/127.0.0.1:65030]
hello</p>
<p>--&gt; hello
world</p>
<p>--&gt;world
但是如果你这时top用看一下发现服务器进程CPU占用到95%以上，如果取消掉32行的注释，服务器会不断地输出&quot;is writable...&quot;，这是为什么呢？让我们来分析当第一个客户端连接上时发生什么情况。</p>
<ol>
<li>在连接之前，服务器第11行：selector.select()处阻塞。当阻塞时，内核会将这个进程调度至休眠状态，此时基本不耗CPU。</li>
<li>当客户端发起一个连接时，服务器检测到客户端连接，selector.select()返回。selector.selectedKeys()返回已就绪的SelectionKey的集合，在这种情况下，它只包含一个key，也就是53行注册的acceptable key。服务器开始运行17-25行的代码，server.accept()返回代码客户端连接的socket，第22行在socket上注册OP_READ和OP_WRITE，表示当socket可读或者可写时就会通知selector。</li>
<li>接着服务器又回到第11行，尽管这时客户端还没有任何输入，但这时selector.select()不会阻塞，因为22行在socket注册了写操作，而socket只要send buffer不满就可以写，刚开始send buffer为空，socket总是可以写，于是server.select()立即返回，包含在22行注册的key。由于这个key可写，所以服务器会运行31-38行的代码，但是这时buffer为空，client.write(buffer)没有向socket写任何东西，立即返回0。</li>
<li><p>接着服务器又回到第11行，由于客户端连接socket可以写，这时selector.select()会立即返回，然后运行31-38行的代码，像步骤3一样，由于buffer为空，服务器没有干任何事又返回到第11行，这样不断循环，服务器却实际没有干事情，却耗大量的CPU。
从上面的分析可以看出问题在于我们在没有数据可写时就在socket上注册了OP_WRITE，导致服务器浪费大量CPU资源，解决办法是<strong>只有数据可以写时才注册OP_WRITE操作</strong>。上面的版本还不只浪费CPU那么简单，它还可能导致潜在的死锁。虽然死锁在我的机器上没有发生，对于这个简单的例子似乎也不大可能发生在别的机器上，但是在对于复杂的情况，比如我写的端口转发工具中就发生了，这还依赖于jdk的实现。对于上面的EchoServer，出现死锁的场景是这样的：</p>
</li>
<li><p>假设服务器已经启动，并且已经有一个客户端与它相连，此时正如上面的分析，服务器在不断地循环做无用功。这时用户在客户端输入&quot;hello&quot;。</p>
</li>
<li><p>当服务器运行到第11行：selector.select()时，这时selector.selectedKeys()会返回一个代表客户端连接的key，显然这时客户端socket是既可读又可写，但jdk却并不保证能够检测到两种状态。如果它检测到key既可读又可写，那么服务器会执行26-38行的代码。如果只检测到可读，那么服务器会执行26-30行的代码。如果只检测到可写，那么会执行31－38行的代码。对于前两种情况，不会造成死锁，因为当执行完29行，buffer会读到用户输入的内容，下次再运行到36行就可以将用户输入内容echo回。但是对最后一种情况，服务器完全忽略了客户端发过来的内容，如果每次selector.select()都只能检测到socket可写，那么服务器永远不能将echo回客户端输入的内容。
避免死锁的一个简单方法就是<strong>不要在同一个socket同时注册多个操作</strong>。对于上面的EchoServer来说就是不要同时注册OP_READ和OP_WRITE，要么只注册OP_READ，要么只注册OP_WRITE。下面的EchoServer修正了以上的错误：
Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>public static void main(String[] args) throws IOException {  </p>
</li>
<li>System.out.println(&quot;Listening for connection on port &quot; + DEFAULT_PORT);  </li>
<li></li>
<li>Selector selector = Selector.open();  </li>
<li>initServer(selector);  </li>
<li></li>
<li>while (true) {  </li>
<li>selector.select();  </li>
<li></li>
<li>for (Iterator<SelectionKey> itor = selector.selectedKeys().iterator(); itor.hasNext();) {  </li>
<li>SelectionKey key = (SelectionKey) itor.next();  </li>
<li>itor.remove();  </li>
<li>try {  </li>
<li>if (key.isAcceptable()) {  </li>
<li>ServerSocketChannel server = (ServerSocketChannel) key.channel();  </li>
<li>SocketChannel client = server.accept();  </li>
<li>System.out.println(&quot;Accepted connection from &quot; + client);  </li>
<li>client.configureBlocking(false);  </li>
<li>SelectionKey clientKey = client.register(selector, SelectionKey.OP_READ);  </li>
<li>ByteBuffer buffer = ByteBuffer.allocate(100);  </li>
<li>clientKey.attach(buffer);  </li>
<li>} else if (key.isReadable()) {  </li>
<li>SocketChannel client = (SocketChannel) key.channel();  </li>
<li>ByteBuffer buffer = (ByteBuffer) key.attachment();  </li>
<li>int n = client.read(buffer);  </li>
<li>if (n &gt; 0) {  </li>
<li>buffer.flip();  </li>
<li>key.interestOps(SelectionKey.OP_WRITE);     // switch to OP_WRITE  </li>
<li>}  </li>
<li>} else if (key.isWritable()) {  </li>
<li>System.out.println(&quot;is writable...&quot;);  </li>
<li>SocketChannel client = (SocketChannel) key.channel();  </li>
<li>ByteBuffer buffer = (ByteBuffer) key.attachment();  </li>
<li>client.write(buffer);  </li>
<li>if (buffer.remaining() == 0) {  // write finished, switch to OP_READ  </li>
<li>buffer.clear();  </li>
<li>key.interestOps(SelectionKey.OP_READ);  </li>
<li>}  </li>
<li>}  </li>
<li>} catch (IOException e) {  </li>
<li>key.cancel();  </li>
<li>try { key.channel().close(); } catch (IOException ioe) { }  </li>
<li>}  </li>
<li>}  </li>
<li>}  </li>
<li><p>}  </p>
<p> public static void main(String[] args) throws IOException {</p>
<pre><code> System.out.println(&quot;Listening for connection on port &quot; + DEFAULT_PORT);
</code></pre></li>
</ol>
<pre><code>    Selector selector = Selector.open();
    initServer(selector);


    while (true) {

        selector.select();


        for (Iterator&lt;SelectionKey&gt; itor = selector.selectedKeys().iterator(); itor.hasNext();) {
            SelectionKey key = (SelectionKey) itor.next();

            itor.remove();
            try {

                if (key.isAcceptable()) {
                    ServerSocketChannel server = (ServerSocketChannel) key.channel();

                    SocketChannel client = server.accept();
                    System.out.println(&quot;Accepted connection from &quot; + client);

                    client.configureBlocking(false);
                    SelectionKey clientKey = client.register(selector, SelectionKey.OP_READ);

                    ByteBuffer buffer = ByteBuffer.allocate(100);
                    clientKey.attach(buffer);

                } else if (key.isReadable()) {
                    SocketChannel client = (SocketChannel) key.channel();

                    ByteBuffer buffer = (ByteBuffer) key.attachment();
                    int n = client.read(buffer);

                    if (n &gt; 0) {
                        buffer.flip();

                        key.interestOps(SelectionKey.OP_WRITE);        // switch to OP_WRITE
                    }

                } else if (key.isWritable()) {
                    System.out.println(&quot;is writable...&quot;);

                    SocketChannel client = (SocketChannel) key.channel();
                    ByteBuffer buffer = (ByteBuffer) key.attachment();

                    client.write(buffer);
                    if (buffer.remaining() == 0) {    // write finished, switch to OP_READ

                        buffer.clear();
                        key.interestOps(SelectionKey.OP_READ);

                    }
                }

            } catch (IOException e) {
                key.cancel();

                try { key.channel().close(); } catch (IOException ioe) { }
            }

        }
    }

}
</code></pre><p>主要变化，在第19行接受客户端连接时只注册OP_READ操作，第28行当读到数据时才切换到OP_WRITE操作，第35-38行，当写操作完成时再切换到OP_READ操作。由于一个key同时只能执行一个操作，我将原来三个并行if换成了if...else。
上面的代码不够优雅，它将处理服务器Socket和客户连接Socket的代码搅在一起，对于简单的EchoServer这样做没什么问题，当服务器变得复杂，使用命令模式将它们分开变显得非常必要。首先创建一个接口来抽象对SelectionKey的处理。
Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>interface Handler {  </li>
<li>void execute(Selector selector, SelectionKey key);  </li>
<li><p>}  </p>
<p> interface Handler {</p>
<pre><code> void execute(Selector selector, SelectionKey key);
</code></pre><p> }
再来看main函数：
Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
</li>
<li><p>public static void main(String[] args) throws IOException {  </p>
</li>
<li>System.out.println(&quot;Listening for connection on port &quot; + DEFAULT_PORT);  </li>
<li></li>
<li>Selector selector = Selector.open();  </li>
<li>initServer(selector);  </li>
<li></li>
<li>while (true) {  </li>
<li>selector.select();  </li>
<li></li>
<li>for (Iterator<SelectionKey> itor = selector.selectedKeys().iterator(); itor.hasNext();) {  </li>
<li>SelectionKey key = (SelectionKey) itor.next();  </li>
<li>itor.remove();  </li>
<li>Handler handler = (Handler) key.attachment();  </li>
<li>handler.execute(selector, key);  </li>
<li>}  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>private static void initServer(Selector selector) throws IOException,  </li>
<li>ClosedChannelException {  </li>
<li>ServerSocketChannel serverChannel = ServerSocketChannel.open();  </li>
<li>ServerSocket ss = serverChannel.socket();  </li>
<li>ss.bind(new InetSocketAddress(DEFAULT_PORT));  </li>
<li>serverChannel.configureBlocking(false);  </li>
<li>SelectionKey serverKey = serverChannel.register(selector, SelectionKey.OP_ACCEPT);  </li>
<li>serverKey.attach(new ServerHandler());  </li>
<li><p>}  </p>
<p> public static void main(String[] args) throws IOException {</p>
<pre><code> System.out.println(&quot;Listening for connection on port &quot; + DEFAULT_PORT);
</code></pre></li>
</ol>
<pre><code>    Selector selector = Selector.open();
    initServer(selector);


    while (true) {

        selector.select();


        for (Iterator&lt;SelectionKey&gt; itor = selector.selectedKeys().iterator(); itor.hasNext();) {
            SelectionKey key = (SelectionKey) itor.next();

            itor.remove();
            Handler handler = (Handler) key.attachment();

            handler.execute(selector, key);
        }

    }
}


private static void initServer(Selector selector) throws IOException,

        ClosedChannelException {
    ServerSocketChannel serverChannel = ServerSocketChannel.open();

    ServerSocket ss = serverChannel.socket();
    ss.bind(new InetSocketAddress(DEFAULT_PORT));

    serverChannel.configureBlocking(false);
    SelectionKey serverKey = serverChannel.register(selector, SelectionKey.OP_ACCEPT);

    serverKey.attach(new ServerHandler());
}
</code></pre><p>main函数非常简单，迭代SelectionKey，对每个key的attachment为Handler，调用它的execute的方法，不用管它是服务器Socket还是客户Socket。注意initServer方法将serverKey附加了一个ServerHandler。下面是ServerHandler的代码：
Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>class ServerHandler implements Handler {  </li>
<li>public void execute(Selector selector, SelectionKey key) {  </li>
<li>ServerSocketChannel server = (ServerSocketChannel) key.channel();  </li>
<li>SocketChannel client = null;  </li>
<li>try {  </li>
<li>client = server.accept();  </li>
<li>System.out.println(&quot;Accepted connection from &quot; + client);  </li>
<li>} catch (IOException e) {  </li>
<li>e.printStackTrace();  </li>
<li>return;  </li>
<li>}  </li>
<li></li>
<li>SelectionKey clientKey = null;  </li>
<li>try {  </li>
<li>client.configureBlocking(false);  </li>
<li>clientKey = client.register(selector, SelectionKey.OP_READ);  </li>
<li>clientKey.attach(new ClientHandler());  </li>
<li>} catch (IOException e) {  </li>
<li>if (clientKey != null)  </li>
<li>clientKey.cancel();  </li>
<li>try { client.close(); } catch (IOException ioe) { }  </li>
<li>}  </li>
<li>}  </li>
<li><p>}  </p>
<p> class ServerHandler implements Handler {</p>
<pre><code> public void execute(Selector selector, SelectionKey key) {
     ServerSocketChannel server = (ServerSocketChannel) key.channel();

     SocketChannel client = null;
     try {

         client = server.accept();
         System.out.println(&quot;Accepted connection from &quot; + client);

     } catch (IOException e) {
         e.printStackTrace();

         return;
     }
</code></pre></li>
</ol>
<pre><code>        SelectionKey clientKey = null;

        try {
            client.configureBlocking(false);

            clientKey = client.register(selector, SelectionKey.OP_READ);
            clientKey.attach(new ClientHandler());

        } catch (IOException e) {
            if (clientKey != null)

                clientKey.cancel();
            try { client.close(); } catch (IOException ioe) { }

        }
    }

}
</code></pre><p>ServerHandler接收连接，为每个客户Socket注册OP_READ操作，返回的clientKey附加上ClientHandler。
Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>class ClientHandler implements Handler {  </li>
<li>private ByteBuffer buffer;  </li>
<li></li>
<li>public ClientHandler() {  </li>
<li>buffer = ByteBuffer.allocate(100);  </li>
<li>}  </li>
<li></li>
<li>public void execute(Selector selector, SelectionKey key) {  </li>
<li>try {  </li>
<li>if (key.isReadable()) {  </li>
<li>readKey(selector, key);  </li>
<li>} else if (key.isWritable()) {  </li>
<li>writeKey(selector, key);  </li>
<li>}  </li>
<li>} catch (IOException e) {  </li>
<li>key.cancel();  </li>
<li>try { key.channel().close(); } catch (IOException ioe) { }  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>private void readKey(Selector selector, SelectionKey key) throws IOException {  </li>
<li>SocketChannel client = (SocketChannel) key.channel();  </li>
<li>int n = client.read(buffer);  </li>
<li>if (n &gt; 0) {  </li>
<li>buffer.flip();  </li>
<li>key.interestOps(SelectionKey.OP_WRITE);     // switch to OP_WRITE  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>private void writeKey(Selector selector, SelectionKey key) throws IOException {  </li>
<li>// System.out.println(&quot;is writable...&quot;);  </li>
<li>SocketChannel client = (SocketChannel) key.channel();  </li>
<li>client.write(buffer);  </li>
<li>if (buffer.remaining() == 0) {  // write finished, switch to OP_READ  </li>
<li>buffer.clear();  </li>
<li>key.interestOps(SelectionKey.OP_READ);  </li>
<li>}  </li>
<li>}  </li>
<li><p>}  </p>
<p> class ClientHandler implements Handler {</p>
<pre><code> private ByteBuffer buffer;
</code></pre></li>
</ol>
<pre><code>    public ClientHandler() {
        buffer = ByteBuffer.allocate(100);

    }


    public void execute(Selector selector, SelectionKey key) {
        try {

            if (key.isReadable()) {
                readKey(selector, key);

            } else if (key.isWritable()) {
                writeKey(selector, key);

            }
        } catch (IOException e) {

            key.cancel();
            try { key.channel().close(); } catch (IOException ioe) { }

        }
    }


    private void readKey(Selector selector, SelectionKey key) throws IOException {

        SocketChannel client = (SocketChannel) key.channel();
        int n = client.read(buffer);

        if (n &gt; 0) {
            buffer.flip();

            key.interestOps(SelectionKey.OP_WRITE);        // switch to OP_WRITE
        }

    }


    private void writeKey(Selector selector, SelectionKey key) throws IOException {
        // System.out.println(&quot;is writable...&quot;);

        SocketChannel client = (SocketChannel) key.channel();
        client.write(buffer);

        if (buffer.remaining() == 0) {    // write finished, switch to OP_READ
            buffer.clear();

            key.interestOps(SelectionKey.OP_READ);
        }

    }
}
</code></pre><p>这个代码没有什么新内容，只是将根据key是可读还可写拆分为两个方法，代码结构显得更清晰。对于EchoServer，这么做确实有些过度工程，对于稍微复杂一点的服务器这么做是很值得的。
代码：<a href="http://pastebin.com/de64ZzUy" target="_blank">EchoServer.java</a>, <a href="http://pastebin.com/fFy0Uhbm" target="_blank">EchoServer2.java</a>, <a href="http://pastebin.com/DRMT4LdJ" target="_blank">EchoServer3.java</a>
参考：</p>
<ol>
<li><a href="http://rox-xmlrpc.sourceforge.net/niotut/" target="_blank">The Rox Java NIO Tutorial</a></li>
<li><a href="http://today.java.net/pub/a/today/2007/02/13/architecture-of-highly-scalable-nio-server.html" target="_blank">Architecture of a Highly Scalable NIO-Based Server</a></li>
</ol>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/NIO/">NIO</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/NIO/" class="label label-success">NIO</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:41"datetime="2014-03-07 09:54:41"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-NIO--javanio网络编程的一点心得/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-NIO--javanio网络编程的一点心得" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-java深入分析--Hash表分析以及Java实现/">Hash表分析以及Java实现</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:41.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-java深入分析--Hash表分析以及Java实现/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="hash-java-">Hash表分析以及Java实现</h1>
<p><strong><a href="http://java-mzd.iteye.com/blog/827523" target="_blank">Hash表分析以及Java实现</a></strong></p>
<p><strong>文章分类**</strong>:<a href="http://www.iteye.com/blogs/category/tech" target="_blank">综合技术</a>**</p>
<pre><code>   这篇博客主要探讨**Hash****表**中的一些原理/概念，及根据这些原理/概念，自己设计一个用来存放/查找数据的Hash表，并且与JDK中的HashMap类进行比较。
</code></pre><p>我们分一下七个步骤来进行。 </p>
<p><strong>一。**</strong>   Hash<strong>**表概念</strong></p>
<p><strong>二**</strong>.      Hash<strong>**构造函数的方法，及适用范围</strong></p>
<p><strong>三**</strong>.       Hash<strong>**处理冲突方法，各自特征</strong></p>
<p><strong>四**</strong>.       Hash<strong>**查找过程</strong></p>
<p><strong>五**</strong>.       <strong><strong>实现一个使用</strong></strong>Hash<strong><strong>存数据的场景</strong></strong>-------Hash<strong>**查找算法，插入算法</strong></p>
<p><strong>六**</strong>.       JDK<strong><strong>中</strong></strong>HashMap<strong>**的实现</strong></p>
<p><strong>七**</strong>.       Hash<strong><strong>表与</strong></strong>HashMap<strong>**的对比，性能分析</strong></p>
<p> <strong>一。**</strong>   Hash<strong><strong>表概念</strong></strong> **</p>
<pre><code>           在查找表中我们已经说过，在Hash表中，**记录在表中的位置和其关键字之间存在着一种确定的关系**。这样       我们就能预先知道所查关键字在表中的位置，从而直接通过下标找到记录。使ASL趋近与0.



          1) **  **哈希(Hash)函数是一个映象，即： 将关键字的集合映射到某个地址集合上，它的设置很灵活，只要这个地       址集合的大小不超出允许范围即可；

         2)  由于哈希函数是一个压缩映象，因此，在一般情况下，很容易产生“冲突”现象，即： key1¹ key2，而  f            (key1) = f(key2)。

          3).  只能尽量减少冲突而不能完全避免冲突，这是因为通常关键字集合比较大，其元素包括所有可能的关键字，       而地址集合的元素仅为哈希表中的地址值



   在构造这种特殊的“查找表” 时，除了需要选择一个**“****好****”(****尽可能少产生冲突****)**的哈希函数之外；还需要找到一      种**“****处理冲突****”** 的方法。
</code></pre><p><strong>二**</strong>.     Hash<strong>**构造函数的方法，及适用范围</strong></p>
<p>§    <strong>直接定址法</strong></p>
<p>§    <strong>数字分析法</strong></p>
<p>§    <strong>平方取中法</strong></p>
<p>§    <strong>折叠法</strong></p>
<p>§    <strong>除留余数法</strong></p>
<p>§    <strong>随机数法</strong>      </p>
<pre><code>  （1）直接定址法：

            哈希函数为关键字的线性函数，H(key) = key 或者 H(key) = a ´ key + b

          **此法仅适合于**：地址集合的大小 = = 关键字集合的大小，其中a和b为常数。

 （2）数字分析法：

         假设关键字集合中的每个关键字都是由 s 位数字组成 (u1, u2, …, us)，分析关键字集中的全体，                  并从中提取分布均匀的若干位或它们的组合作为地址。

         **此法适于:**能预先估计出全体关键字的每一位上各种数字出现的频度。

 （3）平方取中法：

           以关键字的平方值的中间几位作为存储地址。求“关键字的平方值” 的目的是“扩大差别” ，同                    时平方值的中间各位又能受到整个关键字中各位的影响。

         **此法适于:**关键字中的每一位都有某些数字重复出现频度很高的现象。

 （4）折叠法：

        将关键字分割成若干部分，然后取它们的叠加和为哈希地址。两种叠加处理的方法：移位叠加:将分                割后的几部分低位对齐相加；间界叠加:从一端沿分割界来回折叠，然后对齐相加。

        **此法适于：**关键字的数字位数特别多。

 （5）除留余数法：

         设定哈希函数为:H(key) = key MOD p   ( p≤m )，其中， m为表长，p 为不大于 m 的素数，或                 是不含 20 以下的质因子

 （6）随机数法：

       设定哈希函数为:H(key) = Random(key)其中，Random 为伪随机函数

       **此法适于：**对长度不等的关键字构造哈希函数。



     实际造表时，采用何种构造哈希函数的方法取决于建表的关键字集合的情况(包括关键字的范围和形态)，以及哈希表    长度（哈希地址范围），**总的原则是使产生冲突的可能性降到尽可能地小。**
</code></pre><p><strong>三**</strong>.       Hash<strong>**处理冲突方法，各自特征</strong></p>
<p> <strong>“**</strong>处理冲突” 的实际含义是：为产生冲突的关键字寻找下一个哈希地址。**</p>
<p>§    <strong>  **</strong>开放定址法**</p>
<p>§    <strong>  **</strong>再哈希法**</p>
<p>§    <strong>  **</strong>链地址法**</p>
<pre><code>  （1）开放定址法：

           为产生冲突的关键字地址 H(key) 求得一个地址序列： H0, H1, H2, …, Hs  1≤s≤m-1，Hi = ( H(key)                 +di  ) MOD m，其中： i=1, 2, …, s，H(key)为哈希函数;m为哈希表长;



  （2）链地址法：
</code></pre><p><img src="" alt="http://dl.iteye.com/upload/attachment/355453/2a1ac1de-80ef-33d5-a120-9a8f07dbf3e9.jpg"></p>
<pre><code>         将所有哈希地址相同的记录都链接在同一链表中。



  （3）再哈希法：

           方法：构造若干个哈希函数，当发生冲突时，根据另一个哈希函数计算下一个哈希地址，直到冲突不再发                  生。即：Hi=Rhi(key)     i=1,2,……k，其中：Rhi——不同的哈希函数，特点：计算时间增加
</code></pre><p> <strong>四**</strong>.       Hash<strong>**查找过程</strong></p>
<p><img src="" alt="http://dl.iteye.com/upload/attachment/355455/a946abd8-ba7b-3e4e-b5a5-b94059e086ac.png"></p>
<p><strong>  </strong>      对于给定值 K,计算哈希地址 i = H(K)，若 r[i] = NULL  则查找不成功，若 r[i].key = K  则查找成功， 否则 “求     下一地址 Hi” ，直至r[Hi] = NULL  (查找不成功)  或r[Hi].key = K  (查找成功) 为止。</p>
<p> <strong>五**</strong>.       <strong><strong>实现一个使用</strong></strong>Hash<strong><strong>存数据的场景</strong></strong>-------Hash<strong>**查找算法，插入算法</strong></p>
<pre><code>     假设我们要设计的是一个用来保存中南大学所有在校学生个人信息的数据表。因为在校学生数量也不是特别巨大(8W?)，每个学生的学号是唯一的,因此，我们可以简单的应用直接定址法，声明一个10W大小的数组，每个学生的学号作为主键。然后每次要添加或者查找学生，只需要根据需要去操作即可。

  但是，显然这样做是**很脑残**的。这样做系统的可拓展性和复用性就非常差了，比如有一天人数超过10W了？如果是用来保存别的数据呢？或者我只需要保存20条记录呢？声明大小为10W的数组显然是太浪费了的。



 如果我们是用来保存大数据量（比如银行的用户数，4大的用户数都应该有3-5亿了吧？），这时候我们计算出来的HashCode就很可能会有冲突了， 我们的系统应该有“处理冲突”的能力，此处我们**通过挂链法****“****处理冲突****”**。



 如果我们的数据量非常巨大，并且还持续在增加，如果我们仅仅只是通过挂链法来处理冲突，可能我们的链上挂了上万个数据后，这个时候再通过静态搜索来查找链表，显然性能也是非常低的。所以我们的系统应该还能实现自动扩容，**当容量达到某比例后，即自动扩容，使装载因子保存在一个固定的水平上**。
</code></pre><p>综上所述，我们对这个Hash容器的基本要求应该有如下几点：</p>
<pre><code>         **满足****Hash****表的查找要求（废话）**
</code></pre><p><strong>             **</strong>能支持从小数据量到大数据量的自动转变（自动扩容）**</p>
<p><strong>             **</strong>使用挂链法解决冲突**</p>
<p>好了，既然都分析到这一步了，咱就闲话少叙，直接开始上代码吧。</p>
<p><strong>Java**</strong>代码<strong><strong> </strong></strong> <strong>[</strong><img src="&quot;&quot;收藏这段代码&quot; &quot;" alt="收藏代码]()**"><em>**</em></p>
<ol>
<li><p><strong>package</strong> cn.javamzd.collection.search;  </p>
</li>
<li></li>
<li><p><strong>public</strong> <strong>class</strong> MyMap<K, V> {  </p>
</li>
<li><p><strong>private</strong> <strong>int</strong> size;// 当前容量  </p>
</li>
<li><p><strong>private</strong> <strong>static</strong> <strong>int</strong> INIT_CAPACITY = 16;// 默认容量  </p>
</li>
<li><p><strong>private</strong> Entry<K, V>[] container;// 实际存储数据的数组对象  </p>
</li>
<li><p><strong>private</strong> <strong>static</strong> <strong>float</strong> LOAD_FACTOR = 0.75f;// 装载因子  </p>
</li>
<li><p><strong>private</strong> <strong>int</strong> max;// 能存的最大的数=capacity/*factor  </p>
</li>
<li></li>
<li><p>// 自己设置容量和装载因子的构造器  </p>
</li>
<li><p><strong>public</strong> MyMap(<strong>int</strong> init_Capaticy, <strong>float</strong> load_factor) {  </p>
</li>
<li><p><strong>if</strong> (init_Capaticy &lt; 0)  </p>
</li>
<li><p><strong>throw</strong> <strong>new</strong> IllegalArgumentException(&quot;Illegal initial capacity: &quot;  </p>
</li>
<li><ul>
<li>init_Capaticy);  </li>
</ul>
</li>
<li><p><strong>if</strong> (load_factor &lt;= 0 || Float.isNaN(load_factor))  </p>
</li>
<li><p><strong>throw</strong> <strong>new</strong> IllegalArgumentException(&quot;Illegal load factor: &quot;  </p>
</li>
<li><ul>
<li>load_factor);  </li>
</ul>
</li>
<li><p><strong>this</strong>.LOAD_FACTOR = load_factor;  </p>
</li>
<li><p>max = (<strong>int</strong>) (init_Capaticy /* load_factor);  </p>
</li>
<li><p>container = <strong>new</strong> Entry[init_Capaticy];  </p>
</li>
<li><p>}  </p>
</li>
<li></li>
<li><p>// 使用默认参数的构造器  </p>
</li>
<li><p><strong>public</strong> MyMap() {  </p>
</li>
<li><p><strong>this</strong>(INIT_CAPACITY, LOAD_FACTOR);  </p>
</li>
<li><p>}  </p>
</li>
<li></li>
<li><p>//<em>/</em> </p>
</li>
<li><p>/* 存 </p>
</li>
<li><p>/*  </p>
</li>
<li><p>/* @param k </p>
</li>
<li><p>/* @param v </p>
</li>
<li><p>/* @return </p>
</li>
<li><p>/*/  </p>
</li>
<li><p><strong>public</strong> <strong>boolean</strong> put(K k, V v) {  </p>
</li>
<li><p>// 1.计算K的hash值  </p>
</li>
<li><p>// 因为自己很难写出对不同的类型都适用的Hash算法，故调用JDK给出的hashCode()方法来计算hash值  </p>
</li>
<li><p><strong>int</strong> hash = k.hashCode();  </p>
</li>
<li><p>//将所有信息封装为一个Entry  </p>
</li>
<li><p>Entry<K,V> temp=<strong>new</strong> Entry(k,v,hash);  </p>
</li>
<li><p><strong>if</strong>(setEntry(temp, container)){  </p>
</li>
<li><p>// 大小加一  </p>
</li>
<li><p>size++;  </p>
</li>
<li><p><strong>return</strong> <strong>true</strong>;  </p>
</li>
<li><p>}  </p>
</li>
<li><p><strong>return</strong> <strong>false</strong>;  </p>
</li>
<li><p>}  </p>
</li>
<li></li>
<li></li>
<li><p>//<em>/</em> </p>
</li>
<li><p>/* 扩容的方法 </p>
</li>
<li><p>/*  </p>
</li>
<li><p>/* @param newSize </p>
</li>
<li><p>/*            新的容器大小 </p>
</li>
<li><p>/*/  </p>
</li>
<li><p><strong>private</strong> <strong>void</strong> reSize(<strong>int</strong> newSize) {  </p>
</li>
<li><p>// 1.声明新数组  </p>
</li>
<li><p>Entry<K, V>[] newTable = <strong>new</strong> Entry[newSize];  </p>
</li>
<li><p>max = (<strong>int</strong>) (newSize /* LOAD_FACTOR);  </p>
</li>
<li><p>// 2.复制已有元素,即遍历所有元素，每个元素再存一遍  </p>
</li>
<li><p><strong>for</strong> (<strong>int</strong> j = 0; j &lt; container.length; j++) {  </p>
</li>
<li><p>Entry<K, V> entry = container[j];  </p>
</li>
<li><p>//因为每个数组元素其实为链表，所以…………  </p>
</li>
<li><p><strong>while</strong> (<strong>null</strong> != entry) {  </p>
</li>
<li><p>setEntry(entry, newTable);  </p>
</li>
<li><p>entry = entry.next;  </p>
</li>
<li><p>}  </p>
</li>
<li><p>}  </p>
</li>
<li><p>// 3.改变指向  </p>
</li>
<li><p>container = newTable;  </p>
</li>
<li></li>
<li><p>}  </p>
</li>
<li></li>
<li><p>//<em>/</em> </p>
</li>
<li><p>/*将指定的结点temp添加到指定的hash表table当中 </p>
</li>
<li><p>/* 添加时判断该结点是否已经存在 </p>
</li>
<li><p>/* 如果已经存在，返回false </p>
</li>
<li><p>/* 添加成功返回true </p>
</li>
<li><p>/* @param temp </p>
</li>
<li><p>/* @param table </p>
</li>
<li><p>/* @return </p>
</li>
<li><p>/*/  </p>
</li>
<li><p><strong>private</strong> <strong>boolean</strong> setEntry(Entry<K,V> temp,Entry[] table){  </p>
</li>
<li><p>// 根据hash值找到下标  </p>
</li>
<li><p><strong>int</strong> index = indexFor(temp.hash, table.length);  </p>
</li>
<li><p>//根据下标找到对应元素  </p>
</li>
<li><p>Entry<K, V> entry = table[index];  </p>
</li>
<li><p>// 3.若存在  </p>
</li>
<li><p><strong>if</strong> (<strong>null</strong> != entry) {  </p>
</li>
<li><p>// 3.1遍历整个链表，判断是否相等  </p>
</li>
<li><p><strong>while</strong> (<strong>null</strong> != entry) {  </p>
</li>
<li><p>//判断相等的条件时应该注意，除了比较地址相同外，引用传递的相等用equals()方法比较  </p>
</li>
<li><p>//相等则不存，返回false  </p>
</li>
<li><p><strong>if</strong> ((temp.key == entry.key||temp.key.equals(entry.key)) &amp;&amp; temp.hash == entry.hash&amp;&amp;(temp.value==entry.value||temp.value.equals(entry.value))) {  </p>
</li>
<li><p><strong>return</strong> <strong>false</strong>;  </p>
</li>
<li><p>}  </p>
</li>
<li><p>//不相等则比较下一个元素  </p>
</li>
<li><p><strong>else</strong> <strong>if</strong> (temp.key != entry.key &amp;&amp; temp.value != entry.value) {  </p>
</li>
<li><p>//到达队尾，中断循环  </p>
</li>
<li><p><strong>if</strong>(<strong>null</strong>==entry.next){  </p>
</li>
<li><p><strong>break</strong>;  </p>
</li>
<li><p>}  </p>
</li>
<li><p>// 没有到达队尾，继续遍历下一个元素  </p>
</li>
<li><p>entry = entry.next;  </p>
</li>
<li><p>}  </p>
</li>
<li><p>}  </p>
</li>
<li><p>// 3.2当遍历到了队尾，如果都没有相同的元素，则将该元素挂在队尾  </p>
</li>
<li><p>addEntry2Last(entry,temp);  </p>
</li>
<li></li>
<li><p>}  </p>
</li>
<li><p>// 4.若不存在,直接设置初始化元素  </p>
</li>
<li><p>setFirstEntry(temp,index,table);  </p>
</li>
<li><p><strong>return</strong> <strong>true</strong>;  </p>
</li>
<li><p>}  </p>
</li>
<li></li>
<li><p><strong>private</strong> <strong>void</strong> addEntry2Last(Entry<K, V> entry, Entry<K, V> temp) {  </p>
</li>
<li><p><strong>if</strong> (size &gt; max) {  </p>
</li>
<li><p>reSize(container.length /* 4);  </p>
</li>
<li><p>}  </p>
</li>
<li><p>entry.next=temp;  </p>
</li>
<li></li>
<li><p>}  </p>
</li>
<li></li>
<li><p>//<em>/</em> </p>
</li>
<li><p>/* 将指定结点temp，添加到指定的hash表table的指定下标index中 </p>
</li>
<li><p>/* @param temp </p>
</li>
<li><p>/* @param index </p>
</li>
<li><p>/* @param table </p>
</li>
<li><p>/*/  </p>
</li>
<li><p><strong>private</strong> <strong>void</strong> setFirstEntry(Entry<K, V> temp, <strong>int</strong> index, Entry[] table) {  </p>
</li>
<li><p>// 1.判断当前容量是否超标，如果超标，调用扩容方法  </p>
</li>
<li><p><strong>if</strong> (size &gt; max) {  </p>
</li>
<li><p>reSize(table.length /* 4);  </p>
</li>
<li><p>}  </p>
</li>
<li><p>// 2.不超标，或者扩容以后，设置元素  </p>
</li>
<li><p>table[index] = temp;  </p>
</li>
<li><p>//！！！！！！！！！！！！！！！  </p>
</li>
<li><p>//因为每次设置后都是新的链表，需要将其后接的结点都去掉  </p>
</li>
<li><p>//NND，少这一行代码卡了哥哥7个小时（代码重构）  </p>
</li>
<li><p>temp.next=<strong>null</strong>;  </p>
</li>
<li><p>}  </p>
</li>
<li></li>
<li><p>//<em>/</em> </p>
</li>
<li><p>/* 取 </p>
</li>
<li><p>/*  </p>
</li>
<li><p>/* @param k </p>
</li>
<li><p>/* @return </p>
</li>
<li><p>/*/  </p>
</li>
<li><p><strong>public</strong> V get(K k) {  </p>
</li>
<li><p>Entry<K, V> entry = <strong>null</strong>;  </p>
</li>
<li><p>// 1.计算K的hash值  </p>
</li>
<li><p><strong>int</strong> hash = k.hashCode();  </p>
</li>
<li><p>// 2.根据hash值找到下标  </p>
</li>
<li><p><strong>int</strong> index = indexFor(hash, container.length);  </p>
</li>
<li><p>// 3。根据index找到链表  </p>
</li>
<li><p>entry = container[index];  </p>
</li>
<li><p>// 3。若链表为空，返回null  </p>
</li>
<li><p><strong>if</strong> (<strong>null</strong> == entry) {  </p>
</li>
<li><p><strong>return</strong> <strong>null</strong>;  </p>
</li>
<li><p>}  </p>
</li>
<li><p>// 4。若不为空，遍历链表，比较k是否相等,如果k相等，则返回该value  </p>
</li>
<li><p><strong>while</strong> (<strong>null</strong> != entry) {  </p>
</li>
<li><p><strong>if</strong> (k == entry.key||entry.key.equals(k)) {  </p>
</li>
<li><p><strong>return</strong> entry.value;  </p>
</li>
<li><p>}  </p>
</li>
<li><p>entry = entry.next;  </p>
</li>
<li><p>}  </p>
</li>
<li><p>// 如果遍历完了不相等，则返回空  </p>
</li>
<li><p><strong>return</strong> <strong>null</strong>;  </p>
</li>
<li></li>
<li><p>}  </p>
</li>
<li></li>
<li><p>//<em>/</em> </p>
</li>
<li><p>/* 根据hash码，容器数组的长度,计算该哈希码在容器数组中的下标值 </p>
</li>
<li><p>/*  </p>
</li>
<li><p>/* @param hashcode </p>
</li>
<li><p>/* @param containerLength </p>
</li>
<li><p>/* @return </p>
</li>
<li><p>/*/  </p>
</li>
<li><p><strong>public</strong> <strong>int</strong> indexFor(<strong>int</strong> hashcode, <strong>int</strong> containerLength) {  </p>
</li>
<li><p><strong>return</strong> hashcode &amp; (containerLength - 1);  </p>
</li>
<li></li>
<li><p>}  </p>
</li>
<li></li>
<li><p>//<em>/</em> </p>
</li>
<li><p>/* 用来实际保存数据的内部类,因为采用挂链法解决冲突，此内部类设计为链表形式 </p>
</li>
<li><p>/*  </p>
</li>
<li><p>/* @param <K>key </p>
</li>
<li><p>/* @param <V> </p>
</li>
<li><p>/*            value </p>
</li>
<li><p>/*/  </p>
</li>
<li><p><strong>class</strong> Entry<K, V> {  </p>
</li>
<li><p>Entry<K, V> next;// 下一个结点  </p>
</li>
<li><p>K key;// key  </p>
</li>
<li><p>V value;// value  </p>
</li>
<li><p><strong>int</strong> hash;// 这个key对应的hash码，作为一个成员变量，当下次需要用的时候可以不用重新计算  </p>
</li>
<li></li>
<li><p>// 构造方法  </p>
</li>
<li><p>Entry(K k, V v, <strong>int</strong> hash) {  </p>
</li>
<li><p><strong>this</strong>.key = k;  </p>
</li>
<li><p><strong>this</strong>.value = v;  </p>
</li>
<li><p><strong>this</strong>.hash = hash;  </p>
</li>
<li></li>
<li><p>}  </p>
</li>
<li></li>
<li><p>//相应的getter()方法  </p>
</li>
<li></li>
<li><p>}  </p>
</li>
<li><p>}  </p>
</li>
</ol>
<p> 代码中有相当清楚的注释了</p>
<p>在文章的最后这里，我要强烈的宣泄下感情</p>
<p>MLGBD，本来以为分析的挺到位了，写出这个东西也就最多需要个把小时吧</p>
<p>结果因为通宵作业，脑袋运转不灵</p>
<p>硬是花了哥三个小时才写出了</p>
<p>好不容易些出来了</p>
<p>我日</p>
<p>看着代码比较混乱</p>
<p>然后就对代码重构了下</p>
<p>把逻辑抽象清楚，进行重构就花了个多小时</p>
<p>好不容易构造好了</p>
<p>就开始了TMD的一直报错了----------大数据量测试时到大概5000就死循环了</p>
<p>各种调试，各种分析都觉得没错误</p>
<p> 最后花了哥7个小时终于找出来了</p>
<p>我擦</p>
<p>第一次初始化加的时候，因为每个元素的next都是空的</p>
<p>而扩充容量resize()时，因为冲突处理是链式结构的</p>
<p>当将他们重新hash添加的时候，重复的这些鸟元素的next是有元素的</p>
<p>一定要设置为null</p>
<p><strong>七**</strong>.<strong>**性能分析：</strong></p>
<pre><code>  1.因为冲突的存在，其查找长度不可能达到O(1)

  2哈希表的平均查找长度是装载因子a 的函数，而不是 n 的函数。

  3.用哈希表构造查找表时，可以选择一个适当的装填因子 a ，使得平均查找长度限定在某个范围内。
</code></pre><p>   最后给出我们这个HashMap的性能</p>
<p>  测试代码</p>
<p><strong>Java**</strong>代码<strong><strong> </strong></strong> <strong>[</strong><img src="&quot;&quot;收藏这段代码&quot; &quot;" alt="收藏代码]()**"><em>**</em></p>
<ol>
<li><p><strong>public</strong> <strong>class</strong> Test {  </p>
</li>
<li></li>
<li><p><strong>public</strong> <strong>static</strong> <strong>void</strong> main(String[] args) {  </p>
</li>
<li><p>MyMap<String, String> mm = <strong>new</strong> MyMap<String, String>();   </p>
</li>
<li><p>Long aBeginTime=System.currentTimeMillis();//记录BeginTime  </p>
</li>
<li><p><strong>for</strong>(<strong>int</strong> i=0;i&lt;1000000;i++){  </p>
</li>
<li><p>mm.put(&quot;&quot;+i, &quot;&quot;+i/*100);  </p>
</li>
<li><p>}  </p>
</li>
<li><p>Long aEndTime=System.currentTimeMillis();//记录EndTime  </p>
</li>
<li><p>System.out.println(&quot;insert time--&gt;&quot;+(aEndTime-aBeginTime));  </p>
</li>
<li></li>
<li><p>Long lBeginTime=System.currentTimeMillis();//记录BeginTime  </p>
</li>
<li><p>mm.get(&quot;&quot;+100000);  </p>
</li>
<li><p>Long lEndTime=System.currentTimeMillis();//记录EndTime  </p>
</li>
<li><p>System.out.println(&quot;seach time---&gt;&quot;+(lEndTime-lBeginTime));  </p>
</li>
<li><p>}  </p>
</li>
<li><p>}  </p>
<p>100W个数据时，全部存储时间为1S多一点，而<strong>搜寻时间为**</strong>0 **</p>
</li>
</ol>
<p>insert time--&gt;1536
seach time---&gt;0</p>
<p>好了，牢骚发完了</p>
<p>本来今天想写个<strong>有关大访问量处理的一些基本概念</strong>的文章</p>
<p>全泡汤了,明天写吧</p>
<p>url: <a href="http://java-mzd.iteye.com/blog/827523" target="_blank">http://java-mzd.iteye.com/blog/827523</a></p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/java深入分析/">java深入分析</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/java深入分析/" class="label label-success">java深入分析</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:41"datetime="2014-03-07 09:54:41"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-java深入分析--Hash表分析以及Java实现/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-java深入分析--Hash表分析以及Java实现" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>





<ul id="pagination" class="pagination pagination-lg">
  <li><a class="extend prev" href="/page/59/">&laquo;</a></li><li><a class="page-number" href="/">1</a></li><li><a class="page-number" href="/page/2/">2</a></li><li><span class="space">&hellip;</span></li><li><a class="page-number" href="/page/57/">57</a></li><li><a class="page-number" href="/page/58/">58</a></li><li><a class="page-number" href="/page/59/">59</a></li><li class="active"><li><span class="page-number current">60</span></li><li><a class="page-number" href="/page/61/">61</a></li><li><a class="page-number" href="/page/62/">62</a></li><li><a class="page-number" href="/page/63/">63</a></li><li><span class="space">&hellip;</span></li></li><li><a class="page-number" href="/page/161/">161</a></li><li><a class="page-number" href="/page/162/">162</a></li><li><a class="extend next" href="/page/61/">&raquo;</a></li>
  <div class="clearfix"></div>
</ul></div><!--wapper-->
       </div><!-- ID main-col END -->
       <aside id="sidebar" class="alignright col-sx-6 col-sm-4 col-md-3 col-lg-3">
<div id="widget_search" class="widget panel panel-primary">
    <form action="//google.com/search" method="get" accept-charset="utf-8">
  <div class="input-group">
    <input class="form-control" id="searchbox" type="search" name="q" results="0" placeholder="search">
    <span class="input-group-btn">
      <button class="btn btn-default" type="submit">Go!</button>
    </span>
    <input type="hidden" name="q" value="site:itsolife.com">
  </div>
</form>
</div>

<div id="widget_category" class="widget panel panel-primary">
  <div class="panel-heading">category</div>  <div data-src='category' class='ajax_widgets'>正在加载...</div>
</div>

<div id="widget_recent_posts" class="widget panel panel-primary">
  <div class="panel-heading">recent posts</div>  <div data-src='recent_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_tagcloud" class="widget panel panel-primary">
  <div class="panel-heading">tagcloud</div>  <div data-src='tagcloud' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_latest_update_posts" class="widget panel panel-primary">
  <div class="panel-heading">最近更新</div>  <div data-src='latest_update_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_recent_comments" class="widget panel panel-primary">
  <div class="panel-heading">recent comments</div>  

<div class="list-group-item ds-recent-comments" data-num-items="6" data-show-avatars="1" data-show-time="1" data-show-title="1" data-show-admin="1" data-excerpt-length="50"></div>



</div>

</aside>
       <div class="clearfix"></div>
     </div><!-- row END -->
  </div>
  <footer id="footer" class="container">
  <div class="panel panel-info">
  <section id='footer_widget'></section>  <div class="panel-footer">
  <div id="site-info">
    <span class='author'>
  
  &copy; 2014 RobinChia
  
    &nbsp;&nbsp;</span>
  
  <span id='analytics-51la'></span><span id='analytics-google'>
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-48559895-1']);
  _gaq.push(['_trackPageview']);
  _js2load.push({src:('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'});
</script></span><span id='analytics-cnzz'>
<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_5774006'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s17.cnzz.com/stat.php%3Fid%3D5774006%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>
</span><span id='analytics-baidu'>
<script>
var _hmt = _hmt || [];
_js2load.push({src:"//hm.baidu.com/hm.js?1442f50724afc42380b51f097c43082c"});
</script>
</span>  </div>
  <div id="copyright">Site powered by <a href='http://zespia.tw/hexo/'><strong>hexo</strong></a>  update time: <em>2014-04-07 19:05:46</em></span></div>
</div>
<div class="clearfix"></div>


  </div>
  </footer>
  
        <script src="http://cdn.bootcss.com/jquery/1.10.2/jquery.min.js"></script>        
        <script src="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/js/bootstrap.min.js"></script>        
                
        <script src="http://cdn.bootcss.com/prettify/r298/prettify.min.js"></script>    <script type="text/javascript">
   var lang=["bsh", "c", "cc", "cpp", "cs", "csh", "cyc", "cv", "htm", "html",
    "java", "js", "m", "mxml", "perl", "pl", "pm", "py", "rb", "sh",
    "xhtml", "xml", "xsl"];
   var pretty_base='';
   $('script').each(function(){
	var c = $(this).attr('src');
	if (!c)
	    return;
	if (c.match(/(\/)?prettify(\.min)?\.js/i))
	{
	    var index = c.lastIndexOf('/');
	    if (index != -1)
		pretty_base = c.substr(0,index + 1);
	    return false;
	}
   })
   $('pre code').each(function(){
	var c = $(this).attr('class')
	if (!c)
	    return;
	c = c.match(/\s?(lang\-\w+)/i);
	if (c && lang.indexOf(c[1]) == -1)
	{
	    lang.push(c[1]);
	    $.getScript(pretty_base + c[1] + '.min.js');
	}
   })

    $(window).load(function(){
       $("pre").addClass("prettyprint");
       prettyPrint();
    })
</script>    
            <script type="text/javascript">
var duoshuoQuery = {short_name:"robinchia"};
_js2load.push({src:'http://static.duoshuo.com/embed.js',charset:'UTF-8'});
</script>
    
            <!--wumii_relatedItems-->
    
        <script src="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js"></script>    <script type="text/javascript">
(function($){
  $('.entry').each(function(i){
    $(this).find('img').each(function(){
      var alt = this.alt;

      if (alt){
        $(this).before('<span class="caption">' + alt + '</span>');
      }

      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox" rel="fancybox' + i + '" />');
    });
  });

  $('.fancybox').fancybox();
})(jQuery);
</script>    
        <script src="http://cdn.bootcss.com/mathjax/2.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>    <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>
    
<script type="text/javascript">
$('.ajax_widgets').each(function(){var src=$(this).attr('data-src');if(src)$(this).load('/widgets/'+src+'.html');});
$.each(_js2load,function(index,obj){loadjs(obj.src,obj.charset)});
</script>

<div id="scroll2top">
<img src="/scroll2top/arrow.png"/>
</div>
<script src="/scroll2top/scroll2top.min.js"></script>
<div id="winterland">
  <canvas></canvas>
</div>
<script src="/js/winterland.min.js"></script>

  </body>
</html>
