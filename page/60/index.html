
<!DOCTYPE HTML>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>The 60 Page | It so life</title>
<meta name="author" content="RobinChia">

<meta name="description" content="It so life">


<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<meta property="og:site_name" content="It so life"/>

<!--[if IE]><style>.testIE.IE{display:inline;}</style><![endif]-->
<!--[if lte IE 7]><link rel="stylesheet" href="/css/ie7.css" type="text/css"><![endif]-->
<!--[if (lt IE 9)&(gt IE 7)]><style>.testIE.IE8{display:inline;}</style><![endif]-->
<!--[if gt IE 8]><style>.testIE.IE9{display:inline;}</style><![endif]-->

<link href="/favicon.png" rel="icon">
<link rel="alternate" href="/atom.xml" title="It so life Feed" type="application/atom+xml">

<link rel="stylesheet" href="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/css/bootstrap.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/font-awesome/4.0.3/css/font-awesome.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/prettify/r298/prettify.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" type="text/css">
<link rel="stylesheet" href="/css/style.css" type="text/css">
<!--[if lt IE 9]>
   <style>article,aside,dialog,footer,header,section,footer,nav,figure,menu{display:block}</style>
   <script src="http://cdn.staticfile.org/html5shiv/r29/html5.min.js"></script>
   <script src="http://cdn.staticfile.org/respond.js/1.4.2/respond.min.js"></script>
<link href="http://cdn.staticfile.org/respond.js/1.4.2/respond-proxy.html" id="respond-proxy" rel="respond-proxy" />
<link href="/js/respond.proxy.gif" id="respond-redirect" rel="respond-redirect" />
<script src="/js/respond.proxy.js"></script>
   <script src="http://cdn.bootcss.com/selectivizr/1.0.2/selectivizr-min.js"></script>
<![endif]-->
<script type="text/javascript">
function loadjs(c,d){var a=document.createElement("script");a.async=!0;a.type="text/javascript";a.src=c;a.charset=d||"gbk";(document.getElementsByTagName("HEAD")[0]||document.getElementsByTagName("BODY")[0]).appendChild(a)};
var _protocol = (("https:" == document.location.protocol) ? " https://" : " http://");
var _js2load = [];
</script>

</head>
<body>
      <header id="header" class="container"><nav id="main-nav" class="navbar navbar-default navbar-fixed-top " role="navigation">
  <div class="container">
    <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
      <span class="sr-only">Toggle navigation</span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="/">It so life</a>
    </div>
    <div  class="collapse navbar-collapse">
      <ul  class="nav navbar-nav">
  
        <li><a href="/" title="Home">Home</a></li>      
        <li><a href="/about/" title="About">About</a></li>      
        <li><a href="/archives/" title="Archives">Archives</a></li>      
      <li class='dropdown'>
        <a class='dropdown-toggle' data-toggle='dropdown' href='#'>website<b class='caret'></b></a>
        <ul class='dropdown-menu pure-menu-selected'>
    
          <li><a href="//groups.google.com/forum/#!forum/pongba" title="TopLanguage">TopLanguage</a></li>    
          <li><a href="//itpub.net/" title="ITPub">ITPub</a></li>    
          <li><a href="//blog.jobbole.com/" title="Bole">Bole</a></li>    
          <li><a href="//nosql-database.org/" title="nosql">nosql</a></li>    
          <li><a href="//gitimmersion.googol.im/" title="Git">Git</a></li>    
        </ul>
      </li>
    
      </ul>
      <ul class="nav navbar-nav navbar-right">
      
        <li><a href="/atom.xml">RSS</a></li>
      
      
        <li><a href="https://twitter.com/robinchia">twitter</a></li>
      
      
      
      
        <li><a href="https://github.com/robinchia">github</a></li>
      
      </ul>
    </div>
  </div>
</nav>
<div class="clearfix"></div>
</header>
  <div id='content' class="container">
     <div class="page-header-wrapper">
      <!--[if lt IE 9]><div class="alert alert-warning alert-dismissable"><button type="button" class="close" data-dismiss="alert" aria-hidden="true">&times;</button><strong>提示:</strong>您的浏览器版本太低了,建议升级到 <strong><a href="http://windows.microsoft.com/zh-cn/internet-explorer/download-ie" title="IE9">IE9</a></strong> 以上,本站使用<a href="https://www.google.com/intl/zh-CN/chrome/">Chrome浏览器</a>可以获得最好的显示效果.</div><![endif]-->
      <div class="page-header"><h1 align="center"><big>It so life</big> </h1>
        <h5 align="center"><big>love as life</big></h5>
      </div>
     </div>
     <div class="row">
       <div id="main-col" class="alignleft col-sx-12 col-sm-8 col-md-9 col-lg-9">
      <section id='header_widget'></section>
          <div id="wrapper"><article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-java深入分析--Java深度历险（一）——Java字节代码的操纵/">Java深度历险（一）——Java字节代码的操纵</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:41.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-java深入分析--Java深度历险（一）——Java字节代码的操纵/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="java-java-">Java深度历险（一）——Java字节代码的操纵</h1>
<p>编者按】Java作为业界应用最为广泛的语言之一，深得众多软件厂商和开发者的推崇，更是被包括Oracle在内的众多JCP成员积极地推动发展。但是对于Java语言的深度理解和运用，毕竟是很少会有人涉及的话题。InfoQ中文站特地邀请IBM高级工程师成富为大家撰写这个《Java深度历险》专栏，旨在就Java的一些深度和高级特性分享他的经验。</p>
<p>在一般的Java应用开发过程中，开发人员使用Java的方式比较简单。打开惯用的IDE，编写Java源代码，再利用IDE提供的功能直接运行Java 程序就可以了。这种开发模式背后的过程是：开发人员编写的是Java源代码文件（.java），IDE会负责调用Java的编译器把Java源代码编译成平台无关的字节代码（byte code），以类文件的形式保存在磁盘上（.class）。Java虚拟机（JVM）会负责把Java字节代码加载并执行。Java通过这种方式来实现其“<a href="http://en.wikipedia.org/wiki/Write_once,_run_anywhere" target="_blank">编写一次，到处运行（Write once, run anywhere）</a>” 的目标。Java类文件中包含的字节代码可以被不同平台上的JVM所使用。Java字节代码不仅可以以文件形式存在于磁盘上，也可以通过网络方式来下载，还可以只存在于内存中。JVM中的类加载器会负责从包含字节代码的字节数组（byte[]）中定义出Java类。在某些情况下，可能会需要动态的生成 Java字节代码，或是对已有的Java字节代码进行修改。这个时候就需要用到本文中将要介绍的相关技术。首先介绍一下如何动态编译Java源文件。</p>
<h2 id="-java-">动态编译Java源文件</h2>
<p>在一般情况下，开发人员都是在程序运行之前就编写完成了全部的Java源代码并且成功编译。对有些应用来说，Java源代码的内容在运行时刻才能确定。这个时候就需要动态编译源代码来生成Java字节代码，再由JVM来加载执行。典型的场景是很多算法竞赛的在线评测系统（如<a href="http://poj.org/" target="_blank">PKU JudgeOnline</a>），允许用户上传Java代码，由系统在后台编译、运行并进行判定。在动态编译Java源文件时，使用的做法是直接在程序中调用Java编译器。</p>
<p><a href="http://www.jcp.org/en/jsr/detail?id=199" target="_blank">JSR 199</a>引入了Java编译器API。如果使用JDK 6的话，可以通过此API来动态编译Java代码。比如下面的代码用来动态编译最简单的Hello World类。该Java类的代码是保存在一个字符串中的。
public class CompilerTest {</p>
<p>   public static void main(String[] args) throws Exception {<br>      String source = &quot;public class Main { public static void main(String[] args) {System.out.println(\&quot;Hello World!\&quot;);} }&quot;;</p>
<pre><code>  JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
  StandardJavaFileManager fileManager = compiler.getStandardFileManager(null, null, null);

  StringSourceJavaObject sourceObject = new CompilerTest.StringSourceJavaObject(&quot;Main&quot;, source);
  Iterable&lt; extends JavaFileObject&gt; fileObjects = Arrays.asList(sourceObject);

  CompilationTask task = compiler.getTask(null, fileManager, null, null, null, fileObjects);
  boolean result = task.call();

  if (result) {
     System.out.println(&quot;编译成功。&quot;);

  }
</code></pre><p>   }</p>
<p>   static class StringSourceJavaObject extends SimpleJavaFileObject {</p>
<pre><code>  private String content = null;

  public StringSourceJavaObject(String name, String content) ??throws URISyntaxException {
     super(URI.create(&quot;string:///&quot; + name.replace(&#39;.&#39;,&#39;/&#39;) + Kind.SOURCE.extension), Kind.SOURCE);

     this.content = content;
  }


  public CharSequence getCharContent(boolean ignoreEncodingErrors) ??throws IOException {

     return content;
  }
</code></pre><p>   }
}</p>
<p>如果不能使用JDK 6提供的Java编译器API的话，可以使用JDK中的工具类<a href="http://download.oracle.com/javase/1.5.0/docs/tooldocs/solaris/javac.html" target="_blank">com.sun.tools.javac.Main</a>，不过该工具类只能编译存放在磁盘上的文件，类似于直接使用javac命令。</p>
<p>另外一个可用的工具是<a href="http://www.eclipse.org/jdt/core/" target="_blank">Eclipse JDT Core</a>提供的编译器。这是Eclipse Java开发环境使用的增量式Java编译器，支持运行和调试有错误的代码。该编译器也可以单独使用。<a href="http://www.playframework.org/" target="_blank">Play框架</a>在内部使用了JDT的编译器来动态编译Java源代码。在开发模式下，Play框架会定期扫描项目中的Java源代码文件，一旦发现有修改，会自动编译 Java源代码。因此在修改代码之后，刷新页面就可以看到变化。使用这些动态编译的方式的时候，需要确保JDK中的tools.jar在应用的 CLASSPATH中。</p>
<p>下面介绍一个例子，是关于如何在Java里面做四则运算，比如求出来(3+4)/*7-10的值。一般的做法是分析输入的运算表达式，自己来模拟计算过程。考虑到括号的存在和运算符的优先级等问题，这样的计算过程会比较复杂，而且容易出错。另外一种做法是可以用<a href="http://jcp.org/en/jsr/detail?id=223" target="_blank">JSR 223</a>引入的脚本语言支持，直接把输入的表达式当做JavaScript或是JavaFX脚本来执行，得到结果。下面的代码使用的做法是动态生成Java源代码并编译，接着加载Java类来执行并获取结果。这种做法完全使用Java来实现。
private static double calculate(String expr) throws CalculationException  {</p>
<p>   String className = &quot;CalculatorMain&quot;;
   String methodName = &quot;calculate&quot;;</p>
<p>   String source = &quot;public class &quot; + className</p>
<pre><code>  + &quot; { public static double &quot; + methodName + &quot;() { return &quot; + expr + &quot;; } }&quot;;

  //省略动态编译Java源代码的相关代码，参见上一节
</code></pre><p>   boolean result = task.call();</p>
<p>   if (result) {
      ClassLoader loader = Calculator.class.getClassLoader();</p>
<pre><code>  try {           
     Class&lt;?&gt; clazz = loader.loadClass(className);

     Method method = clazz.getMethod(methodName, new Class&lt;?&gt;[] {});
     Object value = method.invoke(null, new Object[] {});

     return (Double) value;
  } catch (Exception e) {

     throw new CalculationException(&quot;内部错误。&quot;);       
  }   
</code></pre><p>   } else {
      throw new CalculationException(&quot;错误的表达式。&quot;);   </p>
<p>   }
}</p>
<p>上面的代码给出了使用动态生成的Java字节代码的基本模式，即通过类加载器来加载字节代码，创建Java类的对象的实例，再通过Java反射API来调用对象中的方法。</p>
<h2 id="java-">Java字节代码增强</h2>
<p>Java 字节代码增强指的是在Java字节代码生成之后，对其进行修改，增强其功能。这种做法相当于对应用程序的二进制文件进行修改。在很多Java框架中都可以见到这种实现方式。Java字节代码增强通常与Java源文件中的注解（annotation）一块使用。注解在Java源代码中声明了需要增强的行为及相关的元数据，由框架在运行时刻完成对字节代码的增强。Java字节代码增强应用的场景比较多，一般都集中在减少冗余代码和对开发人员屏蔽底层的实现细节上。用过<a href="http://download.oracle.com/javase/tutorial/javabeans/index.html" target="_blank">JavaBeans</a>的人可能对其中那些必须添加的getter/setter方法感到很繁琐，并且难以维护。而通过字节代码增强，开发人员只需要声明Bean中的属性即可，getter/setter方法可以通过修改字节代码来自动添加。用过<a href="http://www.oracle.com/technetwork/articles/javaee/jpa-137156.html" target="_blank">JPA</a>的人，在调试程序的时候，会发现<a href="http://download.oracle.com/javaee/5/tutorial/doc/bnbqa.html" target="_blank">实体类</a>中被添加了一些额外的 域和方法。这些域和方法是在运行时刻由JPA的实现动态添加的。字节代码增强在<a href="http://en.wikipedia.org/wiki/Aspect-oriented_programming" target="_blank">面向方面编程（AOP）</a>的一些实现中也有使用。</p>
<p>在讨论如何进行字节代码增强之前，首先介绍一下表示一个Java类或接口的字节代码的组织形式。
类文件 {</p>
<p>   0xCAFEBABE，小版本号，大版本号，常量池大小，常量池数组，
   访问控制标记，当前类信息，父类信息，实现的接口个数，实现的接口信息数组，域个数，</p>
<p>   域信息数组，方法个数，方法信息数组，属性个数，属性信息数组
}</p>
<p>如上所示，一个类或接口的字节代码使用的是一种松散的组织结构，其中所包含的内容依次排列。对于可能包含多个条目的内容，如所实现的接口、域、方法和属性等，是以数组来表示的。而在数组之前的是该数组中条目的个数。不同的内容类型，有其不同的内部结构。对于开发人员来说，直接操纵包含字节代码的字节数组的话，开发效率比较低，而且容易出错。已经有不少的开源库可以对字节代码进行修改或是从头开始创建新的Java类的字节代码内容。这些类库包括<a href="http://asm.ow2.org/" target="_blank">ASM</a>、<a href="http://cglib.sourceforge.net/" target="_blank">cglib</a>、<a href="http://serp.sourceforge.net/" target="_blank">serp</a>和<a href="http://jakarta.apache.org/bcel/" target="_blank">BCEL</a>等。使用这些类库可以在一定程度上降低增强字节代码的复杂度。比如考虑下面一个简单的需求，在一个Java类的所有方法执行之前输出相应的日志。熟悉AOP的人都知道，可以用一个前增强（before advice）来解决这个问题。如果使用ASM的话，相关的代码如下：</p>
<p>ClassReader cr = new ClassReader(is);</p>
<p>ClassNode cn = new ClassNode();
cr.accept(cn, 0);</p>
<p>for (Object object : cn.methods) {<br>   MethodNode mn = (MethodNode) object;  </p>
<p>   if (&quot;<init>&quot;.equals(mn.name) || &quot;<clinit>&quot;.equals(mn.name)) {<br>      continue;   </p>
<p>   }<br>   InsnList insns = mn.instructions;   </p>
<p>   InsnList il = new InsnList();<br>   il.add(new FieldInsnNode(GETSTATIC, &quot;java/lang/System&quot;, &quot;out&quot;, &quot;Ljava/io/PrintStream;&quot;));   </p>
<p>   il.add(new LdcInsnNode(&quot;Enter method -&gt; &quot; + mn.name));<br>   il.add(new MethodInsnNode(INVOKEVIRTUAL, &quot;java/io/PrintStream&quot;, &quot;println&quot;, &quot;(Ljava/lang/String;)V&quot;));   </p>
<p>   insns.insert(il);  mn.maxStack += 3;
}</p>
<p>ClassWriter cw = new ClassWriter(0);
cn.accept(cw);</p>
<p>byte[] b = cw.toByteArray();</p>
<p>从<a href="http://asm.ow2.org/asm33/javadoc/user/org/objectweb/asm/ClassWriter.html" target="_blank">ClassWriter</a>就可以获取到包含增强之后的字节代码的字节数组，可以把字节代码写回磁盘或是由类加载器直接使用。上述示例中，增强部分的逻辑比较简单，只是遍历Java类中的所有方法并添加对System.out.println方法的调用。在字节代码中，Java方法体是由一系列的指令组成的。而要做的是生成调用System.out.println方法的指令，并把这些指令插入到指令集合的最前面。ASM对这些指令做了抽象，不过熟悉全部的指令比较困难。ASM提供了一个工具类<a href="http://asm.ow2.org/asm33/javadoc/user/org/objectweb/asm/util/ASMifierClassVisitor.html" target="_blank">ASMifierClassVisitor</a>，可以打印出Java类的字节代码的结构信息。当需要增强某个类的时候，可以先在源代码上做出修改，再通过此工具类来比较修改前后的字节代码的差异，从而确定该如何编写增强的代码。</p>
<p>对类文件进行增强的时机是需要在Java源代码编译之后，在JVM执行之前。比较常见的做法有：</p>
<ul>
<li>由IDE在完成编译操作之后执行。如Google App Engine的Eclipse插件会在编译之后运行<a href="http://www.datanucleus.org/" target="_blank">DataNucleus</a>来对实体类进行增强。</li>
<li>在构建过程中完成，比如通过Ant或Maven来执行相关的操作。</li>
<li>实现自己的Java类加载器。当获取到Java类的字节代码之后，先进行增强处理，再从修改过的字节代码中定义出Java类。</li>
<li>通过JDK 5引入的java.lang.instrument包来完成。</li>
</ul>
<h2 id="java-lang-instrument">java.lang.instrument</h2>
<p>由于存在着大量对Java字节代码进行修改的需求，<a href="http://download.oracle.com/javase/1.5.0/docs/api/java/lang/instrument/package-summary.html" target="_blank">JDK 5</a>引入了java.lang.instrument包并在<a href="http://download.oracle.com/javase/6/docs/api/java/lang/instrument/package-summary.html" target="_blank">JDK 6</a>中得到了进一步的增强。基本的思路是在JVM启动的时候添加一些代理（agent）。每个代理是一个jar包，其清单（manifest）文件中会指定一个代理类。这个类会包含一个premain方法。JVM在启动的时候会首先执行代理类的premain方法，再执行Java程序本身的main方法。在 premain方法中就可以对程序本身的字节代码进行修改。JDK 6中还允许在JVM启动之后动态添加代理。java.lang.instrument包支持两种修改的场景，一种是重定义一个Java类，即完全替换一个 Java类的字节代码；另外一种是转换已有的Java类，相当于前面提到的类字节代码增强。还是以前面提到的输出方法执行日志的场景为例，首先需要实现<a href="http://download.oracle.com/javase/6/docs/api/java/lang/instrument/ClassFileTransformer.html" target="_blank">java.lang.instrument.ClassFileTransformer</a>接口来完成对已有Java类的转换。
static class MethodEntryTransformer implements ClassFileTransformer {</p>
<p>   public byte[] transform(ClassLoader loader, String className,
     Class&lt;?&gt; classBeingRedefined, ?ProtectionDomain protectionDomain, byte[] classfileBuffer)</p>
<pre><code> throws  IllegalClassFormatException {
    try {

       ClassReader cr = new ClassReader(classfileBuffer);
       ClassNode cn = new ClassNode();           

       //省略使用ASM进行字节代码转换的代码           
       ClassWriter cw = new ClassWriter(0);

       cn.accept(cw);
       return cw.toByteArray();      

    } catch (Exception e){           
       return null;

    }
</code></pre><p>   }</p>
<p>}</p>
<p>有了这个转换类之后，就可以在代理的premain方法中使用它。</p>
<p>public static void premain(String args, Instrumentation inst) {   </p>
<p>   inst.addTransformer(new MethodEntryTransformer());
}</p>
<p>把该代理类打成一个jar包，并在jar包的清单文件中通过Premain-Class声明代理类的名称。运行Java程序的时候，添加JVM启动参数-javaagent:myagent.jar。这样的话，JVM会在加载Java类的字节代码之前，完成相关的转换操作。</p>
<h2 id="-">总结</h2>
<p>操纵Java字节代码是一件很有趣的事情。通过它，可以很容易的对二进制分发的Java程序进行修改，非常适合于性能分析、调试跟踪和日志记录等任务。另外一个非常重要的作用是把开发人员从繁琐的Java语法中解放出来。开发人员应该只需要负责编写与业务逻辑相关的重要代码。对于那些只是因为语法要求而添加的，或是模式固定的代码，完全可以将其字节代码动态生成出来。字节代码增强和源代码生成是不同的概念。源代码生成之后，就已经成为了程序的一部分，开发人员需要去维护它：要么手工修改生成出来的源代码，要么重新生成。而字节代码的增强过程，对于开发人员是完全透明的。妥善使用Java字节代码的操纵技术，可以更好的解决某一类开发问题。</p>
<h2 id="-">参考资料</h2>
<ul>
<li><a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html" target="_blank">Java字节代码格式</a></li>
<li><a href="http://www.javabeat.net/articles/73-the-java-60-compiler-api-1.html" target="_blank">Java 6.0 Compiler API</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/java/j-lo-classloader/index.html" target="_blank">深入探讨Java类加载器</a></li>
</ul>
<p>感谢<a href="http://www.infoq.com/cn/bycategory.action?authorName=%E5%BC%A0%E5%87%AF%E5%B3%B0" target="_blank">张凯峰</a>对本文的审校。</p>
<p>来源： <a href="[http://www.infoq.com/cn/articles/cf-java-byte-code](http://www.infoq.com/cn/articles/cf-java-byte-code)">[http://www.infoq.com/cn/articles/cf-java-byte-code](http://www.infoq.com/cn/articles/cf-java-byte-code)</a></p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/java深入分析/">java深入分析</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/java深入分析/" class="label label-success">java深入分析</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:41"datetime="2014-03-07 09:54:41"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-java深入分析--Java深度历险（一）——Java字节代码的操纵/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-java深入分析--Java深度历险（一）——Java字节代码的操纵" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-java深入分析--Java对存储过程的调用方法/">Java对存储过程的调用方法</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:41.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-java深入分析--Java对存储过程的调用方法/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="java-">Java对存储过程的调用方法</h1>
<p>一:Java如何实现对存储过程的调用:
   A:不带输出参数的
   ---------------不带输出参数的----------------------------------
create procedure getsum
@n int =0&lt;--此处为参数--&gt;
as
declare @sum int&lt;--定义变量--&gt;
declare @i int
set @sum=0
set @i=0
while @i&lt;=@n begin
set @sum=@sum+@i
set @i=@i+1
end
print &#39;the sum is &#39;+ltrim(rtrim(str(@sum)))</p>
<p>--------------在SQL中执行:--------------------
   exec getsum 100</p>
<p>------------在JAVA中调用:---------------------
   JAVA可以调用   但是在JAVA程序却不能去显示该存储过程的结果 因为上面的存储
   过程的参数类型int 传递方式是in(按值)方式
   import java.sql./*;
public class ProcedureTest 
{
public static void main(String args[]) throws Exception
{
   //加载驱动
   DriverManager.registerDriver(new sun.jdbc.odbc.JdbcOdbcDriver());
   //获得连接
   Connection conn=DriverManager.getConnection(&quot;jdbc:odbc:mydata&quot;,&quot;sa&quot;,&quot;&quot;);</p>
<pre><code>     //创建存储过程的对象
     CallableStatement c=conn.prepareCall(&quot;{call getsum(?)}&quot;);

     //给存储过程的参数设置值
     c.setInt(1,100);   //将第一个参数的值设置成100

     //执行存储过程
     c.execute();
     conn.close();
</code></pre><p>}
}</p>
<p>   B:带输出参数的
     1:返回int
         -------------------------带输出参数的----------------
alter procedure getsum
@n int =0,
@result int output
as
declare @sum int
declare @i int
set @sum=0
set @i=0
while @i&lt;=@n begin
set @sum=@sum+@i
set @i=@i+1
end
set @result=@sum
   -------------------在查询分析器中执行------------
   declare @myResult int
exec getsum 100,@myResult output
print @myResult</p>
<p>   ------------在JAVA中调用---------------------
import java.sql./*;
public class ProcedureTest 
{
public static void main(String args[]) throws Exception
{
   //加载驱动
   DriverManager.registerDriver(new sun.jdbc.odbc.JdbcOdbcDriver());
   //获得连接
   Connection conn=DriverManager.getConnection(&quot;jdbc:odbc:mydata&quot;,&quot;sa&quot;,&quot;&quot;);</p>
<pre><code>     //创建存储过程的对象
     CallableStatement c=conn.prepareCall(&quot;{call getsum(?,?)}&quot;);

     //给存储过程的第一个参数设置值
     c.setInt(1,100);

     //注册存储过程的第二个参数
     c.registerOutParameter(2,java.sql.Types.INTEGER);

     //执行存储过程
     c.execute();

     //得到存储过程的输出参数值
     System.out.println (c.getInt(2));
     conn.close();
</code></pre><p>}
}
     2:返回varchar
       ----------------存储过程带游标----------------
---在存储过程中带游标   使用游标不停的遍历orderid
create procedure CursorIntoProcedure
@pname varchar(8000) output
as
--定义游标
declare cur cursor for select orderid from orders
--定义一个变量来接收游标的值
declare @v varchar(5)
--打开游标
open cur
set @pname=&#39;&#39;--给@pname初值
--提取游标的值
fetch next from cur into @v
while @@fetch_status=0
   begin</p>
<p>set @pname=@pname+&#39;;&#39;+@v
   fetch next from cur into @v
end
print @pname
--关闭游标
close cur
--销毁游标
deallocate cur</p>
<p>   ------------执行存储过程--------------
exec CursorIntoProcedure &#39;&#39;</p>
<p>   --------------JAVA调用------------------
import java.sql./*;
public class ProcedureTest 
{
public static void main(String args[]) throws Exception
{
   //加载驱动
   DriverManager.registerDriver(new sun.jdbc.odbc.JdbcOdbcDriver());
   //获得连接
   Connection conn=DriverManager.getConnection(&quot;jdbc:odbc:mydata&quot;,&quot;sa&quot;,&quot;&quot;);
   CallableStatement c=conn.prepareCall(&quot;{call CursorIntoProcedure(?)}&quot;);</p>
<p>   c.registerOutParameter(1,java.sql.Types.VARCHAR);</p>
<p>   c.execute();</p>
<p>   System.out.println (c.getString(1));
   conn.close();
}
}
   C:删除数据的存储过程
     ------------------存储过程--------------------------</p>
<p>drop table 学生基本信息表
create table 学生基本信息表
(
StuID int primary key,
StuName varchar(10),
StuAddress varchar(20)
)
insert into   学生基本信息表 values(1,&#39;三毛&#39;,&#39;wuhan&#39;)
insert into   学生基本信息表 values(2,&#39;三毛&#39;,&#39;wuhan&#39;)
create table 学生成绩表
(
StuID int,
Chinese int,
PyhSics int
foreign key(StuID) references   学生基本信息表(StuID)
on delete cascade
on update cascade
) 
insert into   学生成绩表 values(1,99,100)
insert into   学生成绩表 values(2,99,100)</p>
<p>--创建存储过程 
create procedure delePro
@StuID int
as
delete from 学生基本信息表 where StuID=@StuID
--创建完毕
exec delePro 1   --执行存储过程
--创建存储过程
create procedure selePro
as
select /<em> from 学生基本信息表
--创建完毕
exec selePro   --执行存储过程
     ------------------在JAVA中调用----------------
import java.sql./</em>;
public class ProcedureTest 
{
public static void main(String args[]) throws Exception
{
   //加载驱动
   DriverManager.registerDriver(new sun.jdbc.odbc.JdbcOdbcDriver());
   //获得连接
   Connection conn=DriverManager.getConnection(&quot;jdbc:odbc:mydata&quot;,&quot;sa&quot;,&quot;&quot;);</p>
<pre><code>     //创建存储过程的对象
     CallableStatement c=conn.prepareCall(&quot;{call delePro(?)}&quot;);

     c.setInt(1,1);

     c.execute();

     c=conn.prepareCall(&quot;{call selePro}&quot;);
     ResultSet rs=c.executeQuery();

     while(rs.next())
     {
     String Stu=rs.getString(&quot;StuID&quot;);
     String name=rs.getString(&quot;StuName&quot;);
     String add=rs.getString(&quot;StuAddress&quot;);

     System.out.println (&quot;学号:&quot;+&quot;     &quot;+&quot;姓名:&quot;+&quot;     &quot;+&quot;地址&quot;);
     System.out.println (Stu+&quot;     &quot;+name+&quot;   &quot;+add);
     }
     c.close();
</code></pre><p>}
}
   D:修改数据的存储过程
---------------------创建存储过程---------------------
   create procedure ModPro
@StuID int,
@StuName varchar(10)
as
update 学生基本信息表 set StuName=@StuName where StuID=@StuID</p>
<p>   -------------执行存储过程-------------------------
exec ModPro 2,&#39;四毛&#39;
   ---------------JAVA调用存储过程--------------------
import java.sql./*;
public class ProcedureTest 
{
public static void main(String args[]) throws Exception
{
   //加载驱动
   DriverManager.registerDriver(new sun.jdbc.odbc.JdbcOdbcDriver());
   //获得连接
   Connection conn=DriverManager.getConnection(&quot;jdbc:odbc:mydata&quot;,&quot;sa&quot;,&quot;&quot;);</p>
<pre><code>     //创建存储过程的对象
     CallableStatement c=conn.prepareCall(&quot;{call ModPro(?,?)}&quot;);

     c.setInt(1,2);
     c.setString(2,&quot;美女&quot;);

     c.execute();

     c=conn.prepareCall(&quot;{call selePro}&quot;);
     ResultSet rs=c.executeQuery();

     while(rs.next())
     {
     String Stu=rs.getString(&quot;StuID&quot;);
     String name=rs.getString(&quot;StuName&quot;);
     String add=rs.getString(&quot;StuAddress&quot;);

     System.out.println (&quot;学号:&quot;+&quot;     &quot;+&quot;姓名:&quot;+&quot;     &quot;+&quot;地址&quot;);
     System.out.println (Stu+&quot;     &quot;+name+&quot;   &quot;+add);
     }
     c.close();
</code></pre><p>}
}
   E:查询数据的存储过程(模糊查询)
     -----------------存储过程---------------------
create procedure FindCusts
@cust varchar(10)
as
select customerid from orders where customerid 
like &#39;%&#39;+@cust+&#39;%&#39;
     ---------------执行---------------------------
execute FindCusts &#39;alfki&#39;
   -------------在JAVA中调用--------------------------
import java.sql./*;
public class ProcedureTest 
{
public static void main(String args[]) throws Exception
{
   //加载驱动
   DriverManager.registerDriver(new sun.jdbc.odbc.JdbcOdbcDriver());
   //获得连接
   Connection conn=DriverManager.getConnection(&quot;jdbc:odbc:mydata&quot;,&quot;sa&quot;,&quot;&quot;);</p>
<pre><code>     //创建存储过程的对象
     CallableStatement c=conn.prepareCall(&quot;{call FindCusts(?)}&quot;);
     c.setString(1,&quot;Tom&quot;);

     ResultSet rs=c.executeQuery();

     while(rs.next())
     {
     String cust=rs.getString(&quot;customerid&quot;);        
     System.out.println (cust);
     }
     c.close();
</code></pre><p>}
}
   F:增加数据的存储过程</p>
<p>------------存储过程--------------------
create procedure InsertPro
@StuID int,
@StuName varchar(10),
@StuAddress varchar(20)
as
insert into 学生基本信息表 values(@StuID,@StuName,@StuAddress)</p>
<p>-----------调用存储过程---------------
exec InsertPro 5,&#39;555&#39;,&#39;555&#39;
-----------在JAVA中执行-------------
import java.sql./*;
public class ProcedureTest 
{
public static void main(String args[]) throws Exception
{
   //加载驱动
   DriverManager.registerDriver(new sun.jdbc.odbc.JdbcOdbcDriver());
   //获得连接
   Connection conn=DriverManager.getConnection(&quot;jdbc:odbc:mydata&quot;,&quot;sa&quot;,&quot;&quot;);</p>
<pre><code>     //创建存储过程的对象
     CallableStatement c=conn.prepareCall(&quot;{call InsertPro(?,?,?)}&quot;);
     c.setInt(1,6);
     c.setString(2,&quot;Liu&quot;);
     c.setString(3,&quot;wuhan&quot;);

     c.execute();

     c=conn.prepareCall(&quot;{call selePro}&quot;);
     ResultSet rs=c.executeQuery();

     while(rs.next())
     {
     String stuid=rs.getString(&quot;StuID&quot;);        
     String name=rs.getString(&quot;StuName&quot;);        
     String address=rs.getString(&quot;StuAddress&quot;);        
     System.out.println (stuid+&quot;   &quot;+name+&quot;   &quot;+address);
     }
     c.close();
</code></pre><p>}
}</p>
<p>G:在JAVA中创建存储过程   并且在JAVA中直接调用
import java.sql./*;
public class ProcedureTest 
{
public static void main(String args[]) throws Exception
{
   //加载驱动
   DriverManager.registerDriver(new sun.jdbc.odbc.JdbcOdbcDriver());
   //获得连接
   Connection conn=DriverManager.getConnection(&quot;jdbc:odbc:mydata&quot;,&quot;sa&quot;,&quot;&quot;);</p>
<p>   Statement stmt=conn.createStatement();
   //在JAVA中创建存储过程
   stmt.executeUpdate(&quot;create procedure OOP as select /* from 学生成绩表&quot;);</p>
<p>   CallableStatement c=conn.prepareCall(&quot;{call OOP}&quot;);</p>
<p>   ResultSet rs=c.executeQuery();
   while(rs.next())
   {
   String chinese=rs.getString(&quot;Chinese&quot;);</p>
<p>   System.out.println (chinese);
   }
   conn.close();</p>
<p>}
} 
来源： <a href="[http://technicalsearch.iteye.com/blog/1433293](http://technicalsearch.iteye.com/blog/1433293)">[http://technicalsearch.iteye.com/blog/1433293](http://technicalsearch.iteye.com/blog/1433293)</a> </p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/java深入分析/">java深入分析</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/java深入分析/" class="label label-success">java深入分析</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:41"datetime="2014-03-07 09:54:41"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-java深入分析--Java对存储过程的调用方法/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-java深入分析--Java对存储过程的调用方法" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-java深入分析--JDKJREJVM区别/">JDKJREJVM区别</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:41.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-java深入分析--JDKJREJVM区别/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="jdkjrejvm-">JDKJREJVM区别</h1>
<p><strong><a href="http://java-mzd.iteye.com/blog/838514" target="_blank">JDK,JRE,JVM区别与联系</a></strong></p>
<p><strong>文章分类**</strong>:<a href="http://www.iteye.com/blogs/category/java" target="_blank">Java编程</a>**</p>
<pre><code>很多朋友可能跟我一样，已经使用JAVA开发很久了，可是对JDK,JRE,JVM这三者的联系与区别，一直都是模模糊糊的。

今天特写此文，来整理下三者的关系。



JDK : Java Development ToolKit(Java开发工具包)。JDK是整个JAVA的核心，包括了Java运行环境（Java Runtime Envirnment），一堆Java工具（javac/java/jdb等）和Java基础的类库（即Java API 包括rt.jar）。

最主流的JDK是Sun公司发布的JDK，除了Sun之外，还有很多公司和组织都开发了属于自己的JDK，例如国外IBM公司开发了属于自己的JDK，国内淘宝也开发了属于自己的JDK，各个组织开发自己的JDK都是为了在某些方面得到一些提高，以适应自己的需求，比如IBM的JDK据说运行效率就比SUN的JDK高的多。但不管怎么说，我们还是需要先把基础的Sun JDK掌握好。

JDK有以下三种版本：
</code></pre><p>J2SE，standard edition，标准版，是我们通常用的一个版本J2EE，enterpsise edtion，企业版，使用这种JDK开发J2EE应用程序J2ME，micro edtion，主要用于移动设备、嵌入式设备上的java应用程序</p>
<pre><code>我们常常用JDK来代指Java API，Java API是Java的应用程序接口，其实就是前辈们写好的一些java Class，包括一些重要的语言结构以及基本图形，网络和文件I/O等等 ，我们在自己的程序中，调用前辈们写好的这些Class，来作为我们自己开发的一个基础。当然，现在已经有越来越多的性能更好或者功能更强大的第三方类库供我们使用。



JRE:Java  Runtime  Enviromental(java运行时环境)。也就是我们说的JAVA平台，所有的Java程序都要在JRE下才能运行。包括JVM和JAVA核心类库和支持文件。与JDK相比，它不包含开发工具——编译器、调试器和其它工具。



JVM：Java Virtual Mechinal(JAVA虚拟机)。JVM是JRE的一部分，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。JVM有自己完善的硬件架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。JVM 的主要工作是解释自己的指令集（即字节码）并映射到本地的 CPU 的指令集或 OS 的系统调用。Java语言是跨平台运行的，其实就是不同的操作系统，使用不同的JVM映射规则，让其与操作系统无关，完成了跨平台性。JVM 对上层的Java 源文件是不关心的，它关注的只是由源文件生成的类文件（ class file ）。类文件的组成包括JVM 指令集，符号表以及一些补助信息。
</code></pre><p>下图很好的表面了JDK,JRE,JVM三者间的关系：</p>
<p><img src="" alt="http://dl.iteye.com/upload/attachment/364841/7dbc84af-e878-3718-beb5-6471ad99b995.gif"></p>
<pre><code>我们开发的实际情况是：我们利用JDK（调用JAVA API）开发了属于我们自己的JAVA程序后，通过JDK中的编译程序（javac）将我们的文本java文件编译成JAVA字节码，在JRE上运行这些JAVA字节码，JVM解析这些字节码，映射到CPU指令集或OS的系统调用。
</code></pre><p>url: <a href="http://java-mzd.iteye.com/blog/838514" target="_blank">http://java-mzd.iteye.com/blog/838514</a></p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/java深入分析/">java深入分析</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/java深入分析/" class="label label-success">java深入分析</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:41"datetime="2014-03-07 09:54:41"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-java深入分析--JDKJREJVM区别/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-java深入分析--JDKJREJVM区别" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-java深入分析--IOC原理分析/">IOC原理分析</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:41.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-java深入分析--IOC原理分析/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="ioc-">IOC原理分析</h1>
<p><strong><a href="http://java-mzd.iteye.com/blog/818344" target="_blank">IOC原理分析</a></strong></p>
<p><strong>文章分类**</strong>:<a href="http://www.iteye.com/blogs/category/java" target="_blank">Java编程</a>**</p>
<p>IOC(inversion of control)控制反转</p>
<p>在我们的程序中，要实现某个功能，我们都会用到两个或两个以上的类来协同完成，那么在一个类中，我们就会要有它的合作类的引用，也就是说这个类依赖于别的类，这个合作类的获取，将会有一下几种不同的情况</p>
<p>依赖获取的三种方式： </p>
<p><strong>Java**</strong>代码<strong><strong> </strong></strong> <strong>[</strong><img src="&quot;&quot;收藏这段代码&quot; &quot;" alt="收藏代码]()**"><em>**</em></p>
<ol>
<li><p>情况1.自己生成   </p>
</li>
<li></li>
<li><p>Class person{  </p>
</li>
<li></li>
<li><p>Eat(){  </p>
</li>
<li></li>
<li><p>Apple a=<strong>new</strong> Apple();  </p>
</li>
<li></li>
<li><p>}  </p>
</li>
<li></li>
<li><p>}  </p>
</li>
</ol>
<p>第一种方式：在person的eat()方法里就把吃的水果写死，从开始就创建对象，</p>
<pre><code>  缺点 ：1.Person类必须依赖于Apple类，如果Apple类没完成，则编译都不能通过
</code></pre><p>2.不能再更改，当person想再吃别的水果的时候，无法进行修改</p>
<p>3.很难共享给其他人，只能单独使用</p>
<p>4.person类要对Apple的整个生命周期负责，两个类始终耦合在一起</p>
<p><strong>Java**</strong>代码<strong><strong> </strong></strong> <strong>[</strong><img src="&quot;&quot;收藏这段代码&quot; &quot;" alt="收藏代码]()**"><em>**</em></p>
<ol>
<li><p>情况2 通过中介得到  </p>
</li>
<li></li>
<li><p>Class person{  </p>
</li>
<li></li>
<li><p>Eat(String name){  </p>
</li>
<li></li>
<li><p>Apple a=(Apple)Fruitfactory.getInstance(“name”);  </p>
</li>
<li></li>
<li><p>}}  </p>
</li>
</ol>
<p>第二种方式：1.通过使用工程类，间接得到需要的对象</p>
<p>通过使用工程类，程序效果确实得到了改进，但是问题依然存在</p>
<p>缺点：1.每个子类的生成的代码都写死在工厂类里面了，如果要换个子类，则必须更改工厂类中的方法</p>
<pre><code>            2.面向接口编程，一般都会使用工厂类，一般每个接口都会对于一个工程类，当项目非常大的时候，则会有非常多的工厂类
</code></pre><p><strong>Java**</strong>代码<strong><strong> </strong></strong> <strong>[</strong><img src="&quot;&quot;收藏这段代码&quot; &quot;" alt="收藏代码]()**"><em>**</em></p>
<ol>
<li><p>情况3.直接被注入  </p>
</li>
<li><p>Class person{  </p>
</li>
<li></li>
<li><p>Eat(Fruit fruit){  </p>
</li>
<li></li>
<li><p>//apple为Fruit实现类  </p>
</li>
<li></li>
<li><p>}  </p>
</li>
<li></li>
<li><p>}  </p>
</li>
</ol>
<p>第三种方式：只需要在外部传入一个现成的对象给方法调用，不同的实现传入不同的对象即可（感觉这么说就是简单的面向接口的编程的好处，具体优势，请看后面）</p>
<p>在系统中，我们可以用一个外部的容器Container 来统一调配整个系统的运行，将对象的创建和获取提取到外部容器，由外部容器为每个组件提供需要的组建.</p>
<p>例如：</p>
<p>在容器中创建Fruit类对象apple，</p>
<p>将Person类依赖的Fruit对象传递给Person类</p>
<p>将了这么多，那么，到底是控制的什么被反转了呢?</p>
<p>获得依赖对象的方式被反转了.</p>
<p>也就是说</p>
<p>将一个对象如何获取它所依赖的对象这个任务的控制权反转到外部容器中。对象的依赖都是在对象创建时，由负责协调整个系统中各个实体间关系的外部容器提供了。</p>
<p>了解了IOC的基本理念后</p>
<p>剩下的问题就是：怎么样把类中依赖的对象的引用传递给类？（我们把这种将依赖对象的引用传递给类的方式叫做注入）</p>
<p>接下来，我们需要研究，有几种方法，可以把对象注入到类的内部</p>
<p>注入的三种方式： </p>
<p>1．  通过接口注入</p>
<pre><code>  这种方式要求我们自己定义的组建类必须实现容器给定的一个接口，然后容器通过这个接口，为我们的组建类注入所依赖的类

  缺点：容器对组建的侵入性会很强，实现的组建只能给此容器用了，移植性不强
</code></pre><p>2．  Setter注入</p>
<pre><code>  在容器中，通过调用对象的setter()方法，将该对象的依赖传递到类当中
</code></pre><p>3．构造器注入</p>
<pre><code> 通过使用构造器，在类初始化的时候，传入对象的依赖
</code></pre><p>知道了在容器中可以有三种方式把一个类的对象的依赖传入到这个对象的当中去，但是，这个类的对象我们到底该怎么得到呢？它的依赖又该怎么得到呢？</p>
<p>难道也是在容器中，简单的通过new得到不同的对象，然后进行相互调用吗?</p>
<p>如果是这样的话，那么我们仅仅只是完成了一些基于依赖倒转的代码重构工作而已，并没有真正的体现系统的动态性</p>
<p>那么我们该怎么样才能最大程度的体现系统的动态性? 怎么样才能最大程度的将两个类之间的依赖降低，实现解耦合呢？</p>
<p>我们可以给系统一个XML的配置文件，</p>
<p>在该XML配置文件中，设置每个对象的相应的属性信息（即该类的具体依赖）</p>
<p>然后在系统中，解析XML文件得到一个实体类obj类，obj类保留没一个对象的配置信息</p>
<p>然后根据反射原理，利用解析得到的obj类中信息，动态的生成配置对应的对象，并且调用对象的setter()方法，完成对该对象的注入，</p>
<p>因为XML只是一个符合一定格式要求的文本文件，</p>
<p>所以我们可以随时更改XML文件，而不修改源代码</p>
<p>来得到我们需要的任何类型的任何一个对象，并完全对该对象的注入</p>
<p>使该对象的依赖得以进行，并能使系统最大程度的动态化，具有可拓展性</p>
<p>IoC核心理念：</p>
<p>1.在类当中不创建对象，在代码中不直接与对象和服务连接</p>
<p>2.在配置文件中描述创建对象的方式，以及各个组件之间的联系</p>
<p>3.外部容器通过解析配置文件，通过反射来将这些联系在一起</p>
<p>The Hollywood principle：Don’t call us,we’ll call you.</p>
<p>即，所有组件都是被动的、不主动联系（调用）外部代码，</p>
<p>要等着外部代码的调用--------所有的组件的初始化和相互调用都由容器负责实现。</p>
<p>简单的说，就是整个程序之间的关系，都由容器来控制:将程序的控制权反转给容器,就是所谓的外转</p>
<p>而在我们传统代码中，由程序代码直接控制</p>
<p>最后，使用一个比较形象的例子来最后阐述一次IOC的作用：</p>
<p>  所谓IoC，对于spring框架来说，就是由spring来负责控制对象的生命周期和对象间的关系。这是什么意思呢，举个简单的例子，我们是如何找女朋友的？常见的情况是，我们到处去看哪里有长得漂亮身材又好的mm，然后打听她们的兴趣爱好、qq号、电话号、ip号、iq号………，想办法认识她们，投其所好送其所要，然后嘿嘿……这个过程是复杂深奥的，我们必须自己设计和面对每个环节。传统的程序开发也是如此，在一个对象中，如果要使用另外的对象，就必须得到它（自己new一个，或者从JNDI中查询一个），使用完之后还要将对象销毁（比如Connection等），对象始终会和其他的接口或类藕合起来。</p>
<p>那么IoC是如何做的呢？有点像通过婚介找女朋友，在我和女朋友之间引入了一个第三者：婚姻介绍所。婚介管理了很多男男女女的资料，我可以向婚介提出一个列表，告诉它我想找个什么样的女朋友，比如长得像李嘉欣，身材像林熙雷，唱歌像周杰伦，速度像卡洛斯，技术像齐达内之类的，然后婚介就会按照我们的要求，提供一个mm，我们只需要去和她谈恋爱、结婚就行了。简单明了，如果婚介给我们的人选不符合要求，我们就会抛出异常。整个过程不再由我自己控制，而是有婚介这样一个类似容器的机构来控制。</p>
<p>Spring所倡导的开发方式就是如此，所有的类都会在spring容器中登记，告诉spring你是个什么东西，你需要什么东西，然后spring会在系统运行到适当的时候，把你要的东西主动给你，同时也把你交给其他需要你的东西。所有的类的创建、销毁都由spring来控制，也就是说控制对象生存周期的不再是引用它的对象，而是spring。对于某个具体的对象而言，以前是它控制其他对象，现在是所有对象都被spring控制，所以这叫控制反转。</p>
<p>IoC的一个重点,是在系统运行中动态的向某个对象提供它所需要的其他对象。这一点是通过DI（Dependency Injection，依赖注入）来实现的。比如对象A需要操作数据库，以前我们总是要在A中自己编写代码来获得一个Connection对象，有了 spring我们就只需要告诉spring，A中需要一个Connection，至于这个Connection怎么构造，何时构造，A不需要知道。在系统运行时，spring会在适当的时候制造一个Connection，然后像打针一样，注射到A当中，这样就完成了对各个对象之间关系的控制。A需要依赖 Connection才能正常运行，而这个Connection是由spring注入到A中的，依赖注入的名字就这么来的。那么DI是如何实现的呢？ Java 1.3之后一个重要特征是反射（reflection），它允许程序在运行的时候动态的生成对象、执行对象的方法、改变对象的属性，spring就是通过反射来实现注入的。</p>
<p>附注：因为参考的文章和Blog太多，无法一一表示感谢.谨在此特别感谢CSDN博客的it_man大神</p>
<p>和<a href="http://www.zhuoda.org/xiaoming/66303.html的作者" target="_blank">http://www.zhuoda.org/xiaoming/66303.html的作者</a></p>
<p>以及百度百科作者、维基百科作者</p>
<p>以及javaeye上的多为写了ioc的兄弟</p>
<p>恩，IOC原理折腾了一天总算搞明白了。接下来自己动手写个玩具Spring吧。</p>
<p>url: <a href="http://java-mzd.iteye.com/blog/818344" target="_blank">http://java-mzd.iteye.com/blog/818344</a></p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/java深入分析/">java深入分析</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/java深入分析/" class="label label-success">java深入分析</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:41"datetime="2014-03-07 09:54:41"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-java深入分析--IOC原理分析/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-java深入分析--IOC原理分析" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_多线程-并发--聊聊并发（五）——原子操作的实现原理/">聊聊并发（五）——原子操作的实现原理</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:41.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_多线程-并发--聊聊并发（五）——原子操作的实现原理/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-">聊聊并发（五）——原子操作的实现原理</h1>
<h3 id="-">分享到</h3>
<ul>
<li><a href="">一键分享</a></li>
<li><a href="">QQ空间</a></li>
<li><a href="">新浪微博</a></li>
<li><a href="">百度搜藏</a></li>
<li><a href="">人人网</a></li>
<li><a href="">腾讯微博</a></li>
<li><a href="">百度相册</a></li>
<li><a href="">开心网</a></li>
<li><a href="">腾讯朋友</a></li>
<li><a href="">百度贴吧</a></li>
<li><a href="">豆瓣网</a></li>
<li><a href="">搜狐微博</a></li>
<li><a href="">百度新首页</a></li>
<li><a href="">QQ好友</a></li>
<li><a href="">和讯微博</a></li>
<li><a href="">更多...</a></li>
</ul>
<p><a href="">百度分享</a></p>
<h1 id="-">聊聊并发（五）——原子操作的实现原理</h1>
<p>作者 <a href="http://www.infoq.com/cn/author/%E6%96%B9%E8%85%BE%E9%A3%9E" target="_blank">方腾飞</a> 发布于 十一月 29, 2012 <em>|</em> <a href="">14 评论</a></p>
<h2 id="1-">1. 引言</h2>
<p>原子（atom）本意是“不能被进一步分割的最小粒子”，而原子操作（atomic operation）意为&quot;不可被中断的一个或一系列操作&quot; 。在多处理器上实现原子操作就变得有点复杂。本文让我们一起来聊一聊在Intel处理器和Java里是如何实现原子操作的。</p>
<h2 id="2-">2. 术语定义</h2>
<p>术语 英文 解释 缓存行 Cache line 缓存的最小操作单位 比较并交换 Compare and Swap CAS操作需要输入两个数值，一个旧值（期望操作前的值）和一个新值，在操作期间先比较下旧值有没有发生变化，如果没有发生变化，才交换成新值，发生了变化则不交换。 CPU流水线 CPU pipeline CPU流水线的工作方式就象工业生产上的装配流水线，在CPU中由5~6个不同功能的电路单元组成一条指令处理流水线，然后将一条X86指令分成5~6步后再由这些电路单元分别执行，这样就能实现在一个CPU时钟周期完成一条指令，因此提高CPU的运算速度。 内存顺序冲突 Memory order violation 内存顺序冲突一般是由假共享引起，假共享是指多个CPU同时修改同一个缓存行的不同部分而引起其中一个CPU的操作无效，当出现这个内存顺序冲突时，CPU必须清空流水线。</p>
<h2 id="3-">3. 处理器如何实现原子操作</h2>
<p>32位IA-32处理器使用基于对缓存加锁或总线加锁的方式来实现多处理器之间的原子操作。</p>
<h3 id="3-1-">3.1 处理器自动保证基本内存操作的原子性</h3>
<p>首先处理器会自动保证基本的内存操作的原子性。处理器保证从系统内存当中读取或者写入一个字节是原子的，意思是当一个处理器读取一个字节时，其他处理器不能访问这个字节的内存地址。奔腾6和最新的处理器能自动保证单处理器对同一个缓存行里进行16/32/64位的操作是原子的，但是复杂的内存操作处理器不能自动保证其原子性，比如跨总线宽度，跨多个缓存行，跨页表的访问。但是处理器提供总线锁定和缓存锁定两个机制来保证复杂内存操作的原子性。</p>
<h3 id="3-2-">3.2 使用总线锁保证原子性</h3>
<p>第一个机制是通过总线锁保证原子性。如果多个处理器同时对共享变量进行读改写（i++就是经典的读改写操作）操作，那么共享变量就会被多个处理器同时进行操作，这样读改写操作就不是原子的，操作完之后共享变量的值会和期望的不一致，举个例子：如果i=1,我们进行两次i++操作，我们期望的结果是3，但是有可能结果是2。如下图</p>
<p><img src="" alt=""></p>
<p>（例1）</p>
<p>原因是有可能多个处理器同时从各自的缓存中读取变量i，分别进行加一操作，然后分别写入系统内存当中。那么想要保证读改写共享变量的操作是原子的，就必须保证CPU1读改写共享变量的时候，CPU2不能操作缓存了该共享变量内存地址的缓存。</p>
<p>处理器使用总线锁就是来解决这个问题的。所谓总线锁就是使用处理器提供的一个LOCK＃信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住,那么该处理器可以独占使用共享内存。</p>
<h3 id="3-3-">3.3 使用缓存锁保证原子性</h3>
<p>第二个机制是通过缓存锁定保证原子性。在同一时刻我们只需保证对某个内存地址的操作是原子性即可，但总线锁定把CPU和内存之间通信锁住了，这使得锁定期间，其他处理器不能操作其他内存地址的数据，所以总线锁定的开销比较大，最近的处理器在某些场合下使用缓存锁定代替总线锁定来进行优化。</p>
<p>频繁使用的内存会缓存在处理器的L1，L2和L3高速缓存里，那么原子操作就可以直接在处理器内部缓存中进行，并不需要声明总线锁，在奔腾6和最近的处理器中可以使用“缓存锁定”的方式来实现复杂的原子性。所谓“缓存锁定”就是如果缓存在处理器缓存行中内存区域在LOCK操作期间被锁定，当它执行锁操作回写内存时，处理器不在总线上声言LOCK＃信号，而是修改内部的内存地址，并允许它的缓存一致性机制来保证操作的原子性，因为缓存一致性机制会阻止同时修改被两个以上处理器缓存的内存区域数据，当其他处理器回写已被锁定的缓存行的数据时会起缓存行无效，在例1中，当CPU1修改缓存行中的i时使用缓存锁定，那么CPU2就不能同时缓存了i的缓存行。</p>
<p>但是有两种情况下处理器不会使用缓存锁定。第一种情况是：当操作的数据不能被缓存在处理器内部，或操作的数据跨多个缓存行（cache line），则处理器会调用总线锁定。第二种情况是：有些处理器不支持缓存锁定。对于Inter486和奔腾处理器,就算锁定的内存区域在处理器的缓存行中也会调用总线锁定。</p>
<p>以上两个机制我们可以通过Inter处理器提供了很多LOCK前缀的指令来实现。比如位测试和修改指令BTS，BTR，BTC，交换指令XADD，CMPXCHG和其他一些操作数和逻辑指令，比如ADD（加），OR（或）等，被这些指令操作的内存区域就会加锁，导致其他处理器不能同时访问它。</p>
<h2 id="4-java-">4. JAVA如何实现原子操作</h2>
<p>在java中可以通过锁和循环CAS的方式来实现原子操作。</p>
<h3 id="4-1-cas-">4.1 使用循环CAS实现原子操作</h3>
<p>JVM中的CAS操作正是利用了上一节中提到的处理器提供的CMPXCHG指令实现的。自旋CAS实现的基本思路就是循环进行CAS操作直到成功为止，以下代码实现了一个基于CAS线程安全的计数器方法safeCount和一个非线程安全的计数器count。
public class Counter { private AtomicInteger atomicI = new AtomicInteger(0); private int i = 0; public static void main(String[] args) { final Counter cas = new Counter(); List<Thread> ts = new ArrayList<Thread>(600); long start = System.currentTimeMillis(); for (int j = 0; j &lt; 100; j++) { Thread t = new Thread(new Runnable() { @Override public void run() { for (int i = 0; i &lt; 10000; i++) { cas.count(); cas.safeCount(); } } }); ts.add(t); } for (Thread t : ts) { t.start(); } // 等待所有线程执行完成 for (Thread t : ts) { try { t.join(); } catch (InterruptedException e) { e.printStackTrace(); } } System.out.println(cas.i); System.out.println(cas.atomicI.get()); System.out.println(System.currentTimeMillis() - start); } //<em>/</em> /<em> 使用CAS实现线程安全计数器 /</em>/ private void safeCount() { for (;;) { int i = atomicI.get(); boolean suc = atomicI.compareAndSet(i, ++i); if (suc) { break; } } } //<em>/</em> /<em> 非线程安全计数器 /</em>/ private void count() { i++; } }</p>
<p>在java并发包中有一些并发框架也使用了自旋CAS的方式来实现原子操作，比如LinkedTransferQueue类的Xfer方法。CAS虽然很高效的解决原子操作，但是CAS仍然存在三大问题。ABA问题，循环时间长开销大和只能保证一个共享变量的原子操作。</p>
<ol>
<li>ABA问题。因为CAS需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么A－B－A 就会变成1A-2B－3A。
从Java1.5开始JDK的atomic包里提供了一个类AtomicStampedReference来解决ABA问题。这个类的compareAndSet方法作用是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。
public boolean compareAndSet (V expectedReference,//预期引用 V newReference,//更新后的引用 int expectedStamp, //预期标志 int newStamp) //更新后的标志</li>
<li>循环时间长开销大。自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。</li>
<li>只能保证一个共享变量的原子操作。当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁，或者有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如有两个共享变量i＝2,j=a，合并一下ij=2a，然后用CAS来操作ij。从Java1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行CAS操作。</li>
</ol>
<h3 id="4-2-">4.2 使用锁机制实现原子操作</h3>
<p>锁机制保证了只有获得锁的线程能够操作锁定的内存区域。JVM内部实现了很多种锁机制，有偏向锁，轻量级锁和互斥锁，有意思的是除了偏向锁，JVM实现锁的方式都用到的循环CAS，当一个线程想进入同步块的时候使用循环CAS的方式来获取锁，当它退出同步块的时候使用循环CAS释放锁。详细说明可以参见文章Java SE1.6中的Synchronized。</p>
<h2 id="5-">5. 参考资料</h2>
<ol>
<li><a href="http://www.infoq.com/cn/articles/java-se-16-synchronized" target="_blank">Java SE1.6中的Synchronized</a></li>
<li><a href="http://www.intel.com/products/processor/manuals/" target="_blank">Intel 64和IA-32架构软件开发人员手册</a></li>
<li><a href="http://www.infoq.com/cn/articles/ftf-java-volatile" target="_blank">深入分析Volatile的实现原理</a></li>
</ol>
<h2 id="-">作者介绍</h2>
<p><strong>方腾飞</strong>，花名清英，淘宝资深开发工程师，关注并发编程，目前在广告技术部从事无线广告联盟的开发和设计工作。个人博客：<a href="http://ifeve.com/" target="_blank"><a href="http://ifeve.com">http://ifeve.com</a></a> 微博：<a href="http://weibo.com/kirals" target="_blank"><a href="http://weibo.com/kirals">http://weibo.com/kirals</a></a> 欢迎通过我的微博进行技术交流。</p>
<p>感谢<a href="http://www.infoq.com/cn/bycategory.action?authorName=张龙" target="_blank">张龙</a>对本文的审校。</p>
<p>给InfoQ中文站投稿或者参与内容翻译工作，请邮件至<a href="mailto:editors@cn.infoq.com">editors@cn.infoq.com</a>。也欢迎大家通过新浪微博（<a href="http://www.weibo.com/infoqchina" target="_blank">@InfoQ</a>）或者腾讯微博（<a href="http://t.qq.com/infoqchina" target="_blank">@InfoQ</a>）关注我们，并与我们的编辑和其他读者朋友交流。</p>
<ul>
<li><a href="">Sections</a></li>
<li><a href="http://www.infoq.com/cn/architecture-design" target="_blank"><strong>架构 &amp; 设计</strong></a></li>
<li><a href="http://www.infoq.com/cn/development" target="_blank"><strong>语言 &amp; 开发</strong></a></li>
<li><a href="">Topics</a></li>
<li><a href="http://www.infoq.com/cn/cloud-computing" target="_blank">云计算</a></li>
<li><a href="http://www.infoq.com/cn/Multi-threading" target="_blank">多线程</a></li>
<li><a href="http://www.infoq.com/cn/atomic-operation" target="_blank">原子操作</a></li>
<li><a href="http://www.infoq.com/cn/Security" target="_blank">安全</a></li>
<li><a href="http://www.infoq.com/cn/concurrency" target="_blank">并发</a></li>
<li><a href="http://www.infoq.com/cn/soa_platforms" target="_blank">SOA平台</a></li>
<li><a href="http://www.infoq.com/cn/architecture" target="_blank">架构</a></li>
<li><a href="http://www.infoq.com/cn/java" target="_blank">Java</a></li>
<li><a href="http://www.infoq.com/cn/soa" target="_blank">SOA</a></li>
<li><a href="http://www.infoq.com/cn/enterprise-architecture" target="_blank">企业架构</a></li>
<li><a href="http://www.infoq.com/cn/intel" target="_blank">Intel</a></li>
</ul>
<p>相关内容</p>
<h3 id="-concurrentlinkedqueue-http-www-infoq-com-cn-articles-concurrentlinkedqueue-utm_source-infoq-utm_medium-related_content_link-utm_campaign-relatedcontent_articles_clk-"><a href="http://www.infoq.com/cn/articles/ConcurrentLinkedQueue?utm_source=infoq&amp;utm_medium=related_content_link&amp;utm_campaign=relatedContent_articles_clk" target="_blank">聊聊并发（六）——ConcurrentLinkedQueue的实现原理分析</a></h3>
<h3 id="-concurrenthashmap-http-www-infoq-com-cn-articles-concurrenthashmap-utm_source-infoq-utm_medium-related_content_link-utm_campaign-relatedcontent_articles_clk-"><a href="http://www.infoq.com/cn/articles/ConcurrentHashMap?utm_source=infoq&amp;utm_medium=related_content_link&amp;utm_campaign=relatedContent_articles_clk" target="_blank">聊聊并发（四）——深入分析ConcurrentHashMap</a></h3>
<h3 id="-java-http-www-infoq-com-cn-articles-java-threadpool-utm_source-infoq-utm_medium-related_content_link-utm_campaign-relatedcontent_articles_clk-"><a href="http://www.infoq.com/cn/articles/java-threadPool?utm_source=infoq&amp;utm_medium=related_content_link&amp;utm_campaign=relatedContent_articles_clk" target="_blank">聊聊并发（三）——JAVA线程池的分析和使用</a></h3>
<h3 id="-volatile-http-www-infoq-com-cn-articles-ftf-java-volatile-utm_source-infoq-utm_medium-related_content_link-utm_campaign-relatedcontent_articles_clk-"><a href="http://www.infoq.com/cn/articles/ftf-java-volatile?utm_source=infoq&amp;utm_medium=related_content_link&amp;utm_campaign=relatedContent_articles_clk" target="_blank">聊聊并发（一）——深入分析Volatile的实现原理</a></h3>
<h3 id="-intel-javascript-http-www-infoq-com-cn-news-2012-02-javascript-parallel-processing-utm_source-infoq-utm_medium-related_content_link-utm_campaign-relatedcontent_articles_clk-"><a href="http://www.infoq.com/cn/news/2012/02/javascript-parallel-processing?utm_source=infoq&amp;utm_medium=related_content_link&amp;utm_campaign=relatedContent_articles_clk" target="_blank">Intel发布JavaScript扩展以支持并行运算</a></h3>
<h2 id="-">您好，陌生人！</h2>
<p>您需要 <a href="http://www.infoq.com/reginit.action" target="_blank">注册一个InfoQ账号</a> 或者 <a href="">登录</a> 才能进行评论。在您完成注册后还需要进行一些设置。</p>
<h2 id="-infoq-">获得来自InfoQ的更多体验。<a href=""></a></h2>
<p>允许的HTML标签: a,b,br,blockquote,i,li,pre,u,ul,p</p>
<p>当有人回复此评论时请E-mail通知我</p>
<p>社区评论 <a href="">Watch Thread</a></p>
<p><a href=""><strong>您好，有个地方不太明白</strong> by 王 凯 Posted 30/11/2012 05:01</a>
<a href=""><strong>Re: 您好，有个地方不太明白</strong> by 方 腾飞 Posted 30/11/2012 05:14</a></p>
<p><a href=""><strong>Re: 您好，有个地方不太明白</strong> by 王 凯 Posted 30/11/2012 05:21</a>
<a href=""><strong>期待看到happens-before的深入解读</strong> by freish freish Posted 05/12/2012 08:54</a></p>
<p><a href=""><strong>Re: 期待看到happens-before的深入解读</strong> by 方 腾飞 Posted 05/12/2012 11:04</a>
<a href=""><strong>缓存锁定一处不太明白</strong> by 陈 良柱 Posted 18/12/2012 08:20</a></p>
<p><a href=""><strong>Re: 缓存锁定一处不太明白</strong> by 方 腾飞 Posted 27/12/2012 01:00</a>
<a href=""><strong>Re: 缓存锁定一处不太明白</strong> by Zhao Yu Posted 27/12/2012 10:20</a></p>
<p><a href=""><strong>Re: 缓存锁定一处不太明白</strong> by 方 腾飞 Posted 31/12/2012 10:28</a>
<a href=""><strong>Re: 缓存锁定一处不太明白</strong> by 陈 良柱 Posted 31/12/2012 09:29</a></p>
<p><a href=""><strong>缓存锁定</strong> by Zhao Yu Posted 25/12/2012 04:19</a>
<a href=""><strong>Re: 缓存锁定</strong> by 方 腾飞 Posted 27/12/2012 00:59</a></p>
<p><a href=""><strong>关于总线锁的问题</strong> by lee jw Posted 29/12/2012 12:54</a>
<a href=""><strong>Re: 关于总线锁的问题</strong> by 方 腾飞 Posted 31/12/2012 10:30</a>
<a href=""></a></p>
<p><strong>您好，有个地方不太明白</strong> 30/11/2012 05:01 by 王 凯</p>
<p>safeCount()方法有些看不明白，直接让atomicI自增不可以吗，AtomicInteger本身不就是原子方式增加的吗，谢谢。</p>
<ul>
<li><a href="">回复</a></li>
<li><a href="">回到顶部</a></li>
</ul>
<p><a href=""></a></p>
<p><strong>Re: 您好，有个地方不太明白</strong> 30/11/2012 05:14 by 方 腾飞</p>
<p>atomicI.compareAndSet(i, ++i);本身是原子方式的增加，但是有可能会增加失败，所以需要不停atomicI.compareAndSet(i, ++i);</p>
<ul>
<li><a href="">回复</a></li>
<li><a href="">回到顶部</a>
<a href=""></a></li>
</ul>
<p><strong>Re: 您好，有个地方不太明白</strong> 30/11/2012 05:21 by 王 凯</p>
<p>哦，明白了，我看了下AtomicInteger的源码，incrementAndGet方法实现，呵呵</p>
<ul>
<li><a href="">回复</a></li>
<li><a href="">回到顶部</a></li>
</ul>
<p><a href=""></a></p>
<p><strong>期待看到happens-before的深入解读</strong> 05/12/2012 08:54 by freish freish</p>
<p>期待看到happens-before的深入解读</p>
<ul>
<li><a href="">回复</a></li>
<li><a href="">回到顶部</a>
<a href=""></a></li>
</ul>
<p><strong>Re: 期待看到happens-before的深入解读</strong> 05/12/2012 11:04 by 方 腾飞</p>
<p>好的，没问题，在JMM文章里我会深入解读下。</p>
<ul>
<li><a href="">回复</a></li>
<li><a href="">回到顶部</a></li>
</ul>
<p><a href=""></a></p>
<p><strong>缓存锁定一处不太明白</strong> 18/12/2012 08:20 by 陈 良柱</p>
<p>缓存失效是在内存写回之前还是之后？如何使得其他cpu的缓存失效？是说内存到缓存的映射是一共享区域且回写内存包含对其的检查吗？</p>
<ul>
<li><a href="">回复</a></li>
<li><a href="">回到顶部</a>
<a href=""></a></li>
</ul>
<p><strong>缓存锁定</strong> 25/12/2012 04:19 by Zhao Yu</p>
<p>“所谓“缓存锁定”就是如果缓存在处理器缓存行中内存区域在LOCK操作期间被锁定，当它执行锁操作回写内存时，处理器不在总线上声言LOCK＃信号，而是修改内部的内存地址，并允许它的缓存一致性机制来保证操作的原子性”
这句实在不理解，首先什么是Lock操作期间？不是不锁总线了嘛？为什么还Lock？其次，处理器不发Lock信号而是修改内部的内存地址，到底是怎么保障在一个处理器修改缓存并回写期间，其它处理器不会执行同样操作？？？望作者解答一下</p>
<ul>
<li><a href="">回复</a></li>
<li><a href="">回到顶部</a></li>
</ul>
<p><a href=""></a></p>
<p><strong>Re: 缓存锁定</strong> 27/12/2012 00:59 by 方 腾飞</p>
<p>Lock操作期间，是指Lock指令执行期间，不锁总线但是锁缓存。
最后一个问题，这个是由缓存一致性协议保证的，详细参见：<a href="http://www.tektalk.org/2011/07/07/cache一致性与2种基本写策略1/" target="_blank">www.tektalk.org/2011/07/07/cache一致性与2种基本写策略1/</a></p>
<ul>
<li><a href="">回复</a></li>
<li><a href="">回到顶部</a>
<a href=""></a></li>
</ul>
<p><strong>Re: 缓存锁定一处不太明白</strong> 27/12/2012 01:00 by 方 腾飞</p>
<p>参见缓存一致性协议：www.tektalk.org/2011/07/07/cache一致性与2种基本写策略1/</p>
<ul>
<li><a href="">回复</a></li>
<li><a href="">回到顶部</a></li>
</ul>
<p><a href=""></a></p>
<p><strong>Re: 缓存锁定一处不太明白</strong> 27/12/2012 10:20 by Zhao Yu</p>
<p>好的～多谢作者的答复，这块内容关注很久了，多线程并发开发程序，那门语言和平台都是学到最后的最为重要，也是最深的地方，希望您继续发表相关博文～</p>
<ul>
<li><a href="">回复</a></li>
<li><a href="">回到顶部</a>
<a href=""></a></li>
</ul>
<p><strong>关于总线锁的问题</strong> 29/12/2012 12:54 by lee jw</p>
<p>您好，我想请问CPU在什么情况下会发出LOCK/#信号，是在冲突的时候发出，还是在读写内存的时候发出？看您的文章是说CPU1发出LOCK/#信号后，CPU2就不能读写内存，我想请问一下这里面是否有优先级的判断？谢谢</p>
<ul>
<li><a href="">回复</a></li>
<li><a href="">回到顶部</a></li>
</ul>
<p><a href=""></a></p>
<p><strong>Re: 缓存锁定一处不太明白</strong> 31/12/2012 10:28 by 方 腾飞</p>
<p>多谢你的关注，定期会发表新文章的。或者你也可以关注我的小站<a href="http://ifeve.com/" target="_blank">ifeve.com</a> 最近我在做国外并发编程文章的翻译，都是非常值得一看的文章，你也可以参与到我们的翻译当中来，一起促进并发编程的研究和推广 。</p>
<ul>
<li><a href="">回复</a></li>
<li><a href="">回到顶部</a>
<a href=""></a></li>
</ul>
<p><strong>Re: 关于总线锁的问题</strong> 31/12/2012 10:30 by 方 腾飞</p>
<p>指令触发的，比如使用lock前缀的指令。</p>
<ul>
<li><a href="">回复</a></li>
<li><a href="">回到顶部</a></li>
</ul>
<p><a href=""></a></p>
<p><strong>Re: 缓存锁定一处不太明白</strong> 31/12/2012 09:29 by 陈 良柱</p>
<p>你给的文章链接没有回答我的问题，不过write-invalidate和write-update两词很有用处。
找到一篇个人认为写得较为清楚的综述文章，在此分享：<a href="http://www.docin.com/p-92508695.html。" target="_blank">www.docin.com/p-92508695.html。</a></p>
<ul>
<li><a href="">回复</a></li>
<li><a href="">回到顶部</a></li>
</ul>
<p><a href="">关闭</a></p>
<h3 id="-by"><em>**</em>by</h3>
<p>发布于</p>
<ul>
<li><a href="">查看</a></li>
<li><a href="">回复</a></li>
<li><a href="">回到顶部</a>
<a href="">关闭</a> 主题  您的回复 <a href="">引用原消息</a></li>
</ul>
<p>允许的HTML标签: a,b,br,blockquote,i,li,pre,u,ul,p
当有人回复此评论时请E-mail通知我</p>
<p><a href="">关闭</a> 主题  您的回复</p>
<p>允许的HTML标签: a,b,br,blockquote,i,li,pre,u,ul,p
当有人回复此评论时请E-mail通知我
<a href="">关闭</a></p>
<ul>
<li>热点内容</li>
<li><a href="">本周</a></li>
<li><a href="">本月</a></li>
<li><a href="">近6个月</a><h3 id="-32-http-www-infoq-com-cn-news-2012-08-32-most-important-algorithms-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2012/08/32-most-important-algorithms?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">计算机科学中最重要的32个算法</a></h3>
</li>
</ul>
<h3 id="-thoughtworks-2013-5-http-www-infoq-com-cn-articles-thoughtworks-technology-radar-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/thoughtWorks-technology-radar?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">ThoughtWorks技术雷达（2013年5月）</a></h3>
<h3 id="-1-5-http-www-infoq-com-cn-articles-iqiyi-cloud-push-practices-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/iqiyi-cloud-push-practices?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">让1.5亿移动端用户第一时间获取消息</a></h3>
<h3 id="-thoughtworks-ceo-http-www-infoq-com-cn-news-2013-06-tw-guoxiao-on-talents-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2013/06/tw-guoxiao-on-talents?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">ThoughtWorks全球CEO郭晓谈软件人才的招聘与培养</a></h3>
<h3 id="-http-www-infoq-com-cn-news-2013-06-10-sins-for-scalability-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2013/06/10-sins-for-scalability?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">影响可扩展性的十宗罪</a></h3>
<h3 id="-6-http-www-infoq-com-cn-minibooks-architect-jun-10-2013-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/architect-jun-10-2013?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">架构师（6月刊）</a></h3>
<h3 id="-http-www-infoq-com-cn-articles-function-switch-realize-better-continuous-implementations-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/function-switch-realize-better-continuous-implementations?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">使用功能开关更好地实现持续部署</a></h3>
<h3 id="-eclipse-github-http-www-infoq-com-cn-news-2013-06-eclipse-github-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2013/06/eclipse-github?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">Eclipse迁移到GitHub</a></h3>
<h3 id="-newegg-com-http-www-infoq-com-cn-presentations-newegg-big-data-practice-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/presentations/newegg-big-data-practice?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">Newegg.com大数据实践</a></h3>
<h3 id="-http-www-infoq-com-cn-minibooks-software-sys-architect-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/software-sys-architect?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">软件系统架构：使用视点和视角与利益相关者合作</a></h3>
<h3 id="-32-http-www-infoq-com-cn-news-2012-08-32-most-important-algorithms-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2012/08/32-most-important-algorithms?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">计算机科学中最重要的32个算法</a></h3>
<h3 id="-6-http-www-infoq-com-cn-minibooks-architect-jun-10-2013-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/architect-jun-10-2013?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">架构师（6月刊）</a></h3>
<h3 id="-rest-http-www-infoq-com-cn-news-2013-06-rest-drawbacks-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2013/06/rest-drawbacks?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">REST的缺点是什么？</a></h3>
<h3 id="-google-web-ui-polymer-http-www-infoq-com-cn-news-2013-06-webcomponents-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2013/06/webcomponents?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">Google 发布新一代Web UI库Polymer</a></h3>
<h3 id="-http-www-infoq-com-cn-news-2013-06-dianping-xinnet-hacked-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2013/06/dianping-xinnet-hacked?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">大众点评网域名劫持事件概述</a></h3>
<h3 id="-node-js-grunt-js-http-www-infoq-com-cn-articles-gruntjs-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/GruntJs?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">基于Node.js的自动化构建工具Grunt.js</a></h3>
<h3 id="-node-js-node-js-http-www-infoq-com-cn-articles-what-is-nodejs-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/what-is-nodejs?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">深入浅出Node.js（一）：什么是Node.js</a></h3>
<h3 id="-http-www-infoq-com-cn-minibooks-i-m-wrights-hard-code-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/i-m-wrights-hard-code?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">代码之殇·第二版</a></h3>
<h3 id="-http-www-infoq-com-cn-minibooks-software-sys-architect-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/software-sys-architect?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">软件系统架构：使用视点和视角与利益相关者合作</a></h3>
<h3 id="-18-java-http-www-infoq-com-cn-news-2013-06-zhuhong-on-java-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2013/06/zhuhong-on-java?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">大家谈18岁的Java——朱鸿：开过跑车后再去开大巴车总是有点不爽的</a></h3>
<h3 id="-32-http-www-infoq-com-cn-news-2012-08-32-most-important-algorithms-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2012/08/32-most-important-algorithms?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">计算机科学中最重要的32个算法</a></h3>
<h3 id="-java-http-www-infoq-com-cn-articles-java-memory-model-1-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/java-memory-model-1?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">深入理解Java内存模型（一）——基础</a></h3>
<h3 id="-node-js-node-js-http-www-infoq-com-cn-articles-what-is-nodejs-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/what-is-nodejs?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">深入浅出Node.js（一）：什么是Node.js</a></h3>
<h3 id="-node-js-node-js-npm-http-www-infoq-com-cn-articles-nodejs-npm-install-config-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/nodejs-npm-install-config?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">深入浅出Node.js（二）：Node.js&amp;NPM的安装与配置</a></h3>
<h3 id="-3-http-www-infoq-com-cn-minibooks-architect-mar-10-2013-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/architect-mar-10-2013?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">架构师（3月刊）</a></h3>
<h3 id="-1-http-www-infoq-com-cn-minibooks-architect-jan-10-2013-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/architect-jan-10-2013?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">架构师（1月刊）</a></h3>
<h3 id="-4-http-www-infoq-com-cn-minibooks-architect-apr-10-2013-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/architect-apr-10-2013?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">架构师（4月刊）</a></h3>
<h3 id="-java-http-www-infoq-com-cn-articles-java-threadpool-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/articles/java-threadPool?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">聊聊并发（三）——JAVA线程池的分析和使用</a></h3>
<h3 id="-2-http-www-infoq-com-cn-minibooks-architect-feb-10-2013-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/minibooks/architect-feb-10-2013?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">架构师（2月刊）</a></h3>
<h3 id="-12306-github-http-www-infoq-com-cn-news-2013-01-12306-plugin-ddos-github-utm_source-infoq-utm_medium-popular_links_homepage-"><a href="http://www.infoq.com/cn/news/2013/01/12306-plugin-ddos-github?utm_source=infoq&amp;utm_medium=popular_links_homepage" target="_blank">12306订票助手插件拖垮GitHub事件原因始末</a></h3>
<h2 id="-">深度内容</h2>
<ul>
<li><a href="">全部</a></li>
<li><a href="">文章</a></li>
<li><a href="">演讲</a></li>
<li><a href="">访谈</a></li>
<li><a href="">迷你书</a><h2 id="-juergen-fesslmeier-javascript-http-www-infoq-com-cn-interviews-end-to-end-javascript-juergen-fesslmeier-javascript-"><a href="http://www.infoq.com/cn/interviews/end-to-end-javascript" title="Juergen Fesslmeier谈端到端的JavaScript开发" target="_blank">Juergen Fesslmeier谈端到端的JavaScript开发</a></h2>
</li>
</ul>
<p><a href="http://www.infoq.com/cn/author/Juergen-Fesslmeier" title="Juergen Fesslmeier" target="_blank">Juergen Fesslmeier</a> 七月 02, 2013</p>
<p><a href="http://www.infoq.com/cn/interviews/end-to-end-javascript" title="Juergen Fesslmeier谈端到端的JavaScript开发" target="_blank"><img src="" alt=""></a></p>
<h2 id="-http-www-infoq-com-cn-articles-design-pattern-automation-"><a href="http://www.infoq.com/cn/articles/Design-Pattern-Automation" title="设计模式自动化" target="_blank">设计模式自动化</a></h2>
<p><a href="http://www.infoq.com/cn/author/Gael-Fraiteur-and-Yan-Cui" title="Gael Fraiteur and Yan Cui" target="_blank">Gael Fraiteur and Yan Cui</a> 七月 01, 2013</p>
<p><a href="http://www.infoq.com/cn/articles/Design-Pattern-Automation" title="设计模式自动化" target="_blank"><img src="" alt=""></a></p>
<h2 id="-http-www-infoq-com-cn-articles-designing-a-world-at-your-fingertips-mobile-user-interfaces-"><a href="http://www.infoq.com/cn/articles/designing-a-world-at-your-fingertips-mobile-user-interfaces" title="设计指尖上的世界：移动用户界面一瞥" target="_blank">设计指尖上的世界：移动用户界面一瞥</a></h2>
<p><a href="http://www.infoq.com/cn/author/Forrest-Shull" title="Forrest Shull" target="_blank">Forrest Shull</a> 六月 28, 2013</p>
<p><a href="http://www.infoq.com/cn/articles/designing-a-world-at-your-fingertips-mobile-user-interfaces" title="设计指尖上的世界：移动用户界面一瞥" target="_blank"><img src="" alt=""></a></p>
<h2 id="-alm-http-www-infoq-com-cn-articles-integrated-alm-alm-"><a href="http://www.infoq.com/cn/articles/Integrated-ALM" title="成功的根本—集成的ALM工具" target="_blank">成功的根本—集成的ALM工具</a></h2>
<p><a href="http://www.infoq.com/cn/author/Dave-West" title="Dave West" target="_blank">Dave West</a> 六月 28, 2013</p>
<p><a href="http://www.infoq.com/cn/articles/Integrated-ALM" title="成功的根本—集成的ALM工具" target="_blank"><img src="" alt=""></a></p>
<h2 id="-http-www-infoq-com-cn-articles-atdd-by-example-book-"><a href="http://www.infoq.com/cn/articles/atdd-by-example-book" title="书评：验收测试驱动开发实践指南" target="_blank">书评：验收测试驱动开发实践指南</a></h2>
<p><a href="http://www.infoq.com/cn/author/Manuel-Pais" title="Manuel Pais" target="_blank">Manuel Pais</a> 六月 26, 2013</p>
<p><a href="http://www.infoq.com/cn/articles/atdd-by-example-book" title="书评：验收测试驱动开发实践指南" target="_blank"><img src="" alt=""></a></p>
<h2 id="-web-http-www-infoq-com-cn-presentations-across-device-web-web-"><a href="http://www.infoq.com/cn/presentations/across-device-web" title="跨终端的web" target="_blank">跨终端的web</a></h2>
<p><a href="http://www.infoq.com/cn/author/%E8%88%92%E6%96%87%E4%BA%AE" title="舒文亮" target="_blank">舒文亮</a> 六月 26, 2013</p>
<p><a href="http://www.infoq.com/cn/presentations/across-device-web" title="跨终端的web" target="_blank"><img src="" alt=""></a></p>
<ul>
<li><a href="">更早的 &gt;</a></li>
</ul>
<p>语言 &amp; 开发</p>
<p><a href="http://www.infoq.com/cn/interviews/end-to-end-javascript" title="Juergen Fesslmeier谈端到端的JavaScript开发" target="_blank">Juergen Fesslmeier谈端到端的JavaScript开发</a></p>
<p><a href="http://www.infoq.com/cn/news/2013/07/mobilecloud-tfs" title="MobileCloud for TFS支持测试Windows Phone,Android,iOS及BlackBerry应用" target="_blank">MobileCloud for TFS支持测试Windows Phone,Android,iOS及BlackBerry应用</a></p>
<p><a href="http://www.infoq.com/cn/news/2013/07/baidu-salon39-summary" title="百度技术沙龙第39期回顾：前端快速开发实践（含资料下载）" target="_blank">百度技术沙龙第39期回顾：前端快速开发实践（含资料下载）</a></p>
<p>架构 &amp; 设计</p>
<p><a href="http://www.infoq.com/cn/news/2013/07/Native-Performance" title="内存与本机代码的性能" target="_blank">内存与本机代码的性能</a></p>
<p><a href="http://www.infoq.com/cn/articles/Design-Pattern-Automation" title="设计模式自动化" target="_blank">设计模式自动化</a></p>
<p><a href="http://www.infoq.com/cn/news/2013/07/WinRT-Devices" title="连接设备编程" target="_blank">连接设备编程</a>
过程 &amp; 实践</p>
<p><a href="http://www.infoq.com/cn/articles/Integrated-ALM" title="成功的根本—集成的ALM工具" target="_blank">成功的根本—集成的ALM工具</a></p>
<p><a href="http://www.infoq.com/cn/news/2013/06/tw-guoxiao-on-talents" title="ThoughtWorks全球CEO郭晓谈软件人才的招聘与培养" target="_blank">ThoughtWorks全球CEO郭晓谈软件人才的招聘与培养</a></p>
<p><a href="http://www.infoq.com/cn/articles/atdd-by-example-book" title="书评：验收测试驱动开发实践指南" target="_blank">书评：验收测试驱动开发实践指南</a></p>
<p>运维 &amp; 基础架构</p>
<p><a href="http://www.infoq.com/cn/news/2013/06/devops-in-traditional-enterprise" title="在传统企业中引入DevOps" target="_blank">在传统企业中引入DevOps</a></p>
<p><a href="http://www.infoq.com/cn/news/2013/06/dod-ams-day1-s-is-for-security" title="安全性——“DevOpS”中的S" target="_blank">安全性——“DevOpS”中的S</a></p>
<p><a href="http://www.infoq.com/cn/articles/atdd-by-example-book" title="书评：验收测试驱动开发实践指南" target="_blank">书评：验收测试驱动开发实践指南</a>
企业架构</p>
<p><a href="http://www.infoq.com/cn/articles/designing-a-world-at-your-fingertips-mobile-user-interfaces" title="设计指尖上的世界：移动用户界面一瞥" target="_blank">设计指尖上的世界：移动用户界面一瞥</a></p>
<p><a href="http://www.infoq.com/cn/news/2013/06/stratos-2" title="Stratos 2.0已发布，支持所有运行时环境和30个IaaS" target="_blank">Stratos 2.0已发布，支持所有运行时环境和30个IaaS</a></p>
<p><a href="http://www.infoq.com/cn/articles/iqiyi-cloud-push-practices" title="让1.5亿移动端用户第一时间获取消息" target="_blank">让1.5亿移动端用户第一时间获取消息</a>
<a href="">Close</a> E-mail  密码</p>
<p><a href="http://www.infoq.com/cn/social/googleLogin.action?fl=login" title="使用Google账号登录" target="_blank">使用Google账号登录</a> <a href="http://www.infoq.com/cn/social/liveLogin.action?fl=login" title="使用Microsoft账号登录" target="_blank">使用Microsoft账号登录</a>
<a href="">忘记密码？</a>
 InfoQ账号使用的E-mail 发送邮件</p>
<p><a href="">重新登录</a>
重新发送激活信息 重新发送</p>
<p><a href="">重新登录</a>
<a href="http://www.infoq.com/cn/reginit.action" target="_blank">没有用户名？</a></p>
<p><a href="http://www.infoq.com/cn/reginit.action" target="_blank">点击注册</a></p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/Java_多线程/">Java_多线程</a></li><li><a href="/categories/Java&J2EE/Java_多线程/并发/">并发</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/Java_多线程/" class="label label-success">Java_多线程</a><a href="/tags/并发/" class="label label-info">并发</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:41"datetime="2014-03-07 09:54:41"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-Java_多线程-并发--聊聊并发（五）——原子操作的实现原理/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-Java_多线程-并发--聊聊并发（五）——原子操作的实现原理" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>





<ul id="pagination" class="pagination pagination-lg">
  <li><a class="extend prev" href="/page/59/">&laquo;</a></li><li><a class="page-number" href="/">1</a></li><li><a class="page-number" href="/page/2/">2</a></li><li><span class="space">&hellip;</span></li><li><a class="page-number" href="/page/57/">57</a></li><li><a class="page-number" href="/page/58/">58</a></li><li><a class="page-number" href="/page/59/">59</a></li><li class="active"><li><span class="page-number current">60</span></li><li><a class="page-number" href="/page/61/">61</a></li><li><a class="page-number" href="/page/62/">62</a></li><li><a class="page-number" href="/page/63/">63</a></li><li><span class="space">&hellip;</span></li></li><li><a class="page-number" href="/page/164/">164</a></li><li><a class="page-number" href="/page/165/">165</a></li><li><a class="extend next" href="/page/61/">&raquo;</a></li>
  <div class="clearfix"></div>
</ul></div><!--wapper-->
       </div><!-- ID main-col END -->
       <aside id="sidebar" class="alignright col-sx-6 col-sm-4 col-md-3 col-lg-3">
<div id="widget_search" class="widget panel panel-primary">
    <form action="//google.com/search" method="get" accept-charset="utf-8">
  <div class="input-group">
    <input class="form-control" id="searchbox" type="search" name="q" results="0" placeholder="search">
    <span class="input-group-btn">
      <button class="btn btn-default" type="submit">Go!</button>
    </span>
    <input type="hidden" name="q" value="site:itsolife.com">
  </div>
</form>
</div>

<div id="widget_category" class="widget panel panel-primary">
  <div class="panel-heading">category</div>  <div data-src='category' class='ajax_widgets'>正在加载...</div>
</div>

<div id="widget_recent_posts" class="widget panel panel-primary">
  <div class="panel-heading">recent posts</div>  <div data-src='recent_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_tagcloud" class="widget panel panel-primary">
  <div class="panel-heading">tagcloud</div>  <div data-src='tagcloud' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_latest_update_posts" class="widget panel panel-primary">
  <div class="panel-heading">最近更新</div>  <div data-src='latest_update_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_recent_comments" class="widget panel panel-primary">
  <div class="panel-heading">recent comments</div>  

<div class="list-group-item ds-recent-comments" data-num-items="6" data-show-avatars="1" data-show-time="1" data-show-title="1" data-show-admin="1" data-excerpt-length="50"></div>



</div>

</aside>
       <div class="clearfix"></div>
     </div><!-- row END -->
  </div>
  <footer id="footer" class="container">
  <div class="panel panel-info">
  <section id='footer_widget'></section>  <div class="panel-footer">
  <div id="site-info">
    <span class='author'>
  
  &copy; 2014 RobinChia
  
    &nbsp;&nbsp;</span>
  
  <span id='analytics-51la'></span><span id='analytics-google'>
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-48559895-1']);
  _gaq.push(['_trackPageview']);
  _js2load.push({src:('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'});
</script></span><span id='analytics-cnzz'>
<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_5774006'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s17.cnzz.com/stat.php%3Fid%3D5774006%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>
</span><span id='analytics-baidu'>
<script>
var _hmt = _hmt || [];
_js2load.push({src:"//hm.baidu.com/hm.js?1442f50724afc42380b51f097c43082c"});
</script>
</span>  </div>
  <div id="copyright">Blog powered by <a href='http://zespia.tw/hexo/'><strong>hexo</strong></a> Theme <strong><a href='https://github.com/chenall/hexo-theme-chenall'>chenall</a></strong>(Some change in it)<span class="pull-right"> 更新时间: <em>2014-03-23 21:54:38</em></span></div>
</div>
<div class="clearfix"></div>


  </div>
  </footer>
  
        <script src="http://cdn.bootcss.com/jquery/1.10.2/jquery.min.js"></script>        
        <script src="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/js/bootstrap.min.js"></script>        
                
        <script src="http://cdn.bootcss.com/prettify/r298/prettify.min.js"></script>    <script type="text/javascript">
   var lang=["bsh", "c", "cc", "cpp", "cs", "csh", "cyc", "cv", "htm", "html",
    "java", "js", "m", "mxml", "perl", "pl", "pm", "py", "rb", "sh",
    "xhtml", "xml", "xsl"];
   var pretty_base='';
   $('script').each(function(){
	var c = $(this).attr('src');
	if (!c)
	    return;
	if (c.match(/(\/)?prettify(\.min)?\.js/i))
	{
	    var index = c.lastIndexOf('/');
	    if (index != -1)
		pretty_base = c.substr(0,index + 1);
	    return false;
	}
   })
   $('pre code').each(function(){
	var c = $(this).attr('class')
	if (!c)
	    return;
	c = c.match(/\s?(lang\-\w+)/i);
	if (c && lang.indexOf(c[1]) == -1)
	{
	    lang.push(c[1]);
	    $.getScript(pretty_base + c[1] + '.min.js');
	}
   })

    $(window).load(function(){
       $("pre").addClass("prettyprint");
       prettyPrint();
    })
</script>    
            <script type="text/javascript">
var duoshuoQuery = {short_name:"robinchia"};
_js2load.push({src:'http://static.duoshuo.com/embed.js',charset:'UTF-8'});
</script>
    
            <!--wumii_relatedItems-->
    
        <script src="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js"></script>    <script type="text/javascript">
(function($){
  $('.entry').each(function(i){
    $(this).find('img').each(function(){
      var alt = this.alt;

      if (alt){
        $(this).before('<span class="caption">' + alt + '</span>');
      }

      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox" rel="fancybox' + i + '" />');
    });
  });

  $('.fancybox').fancybox();
})(jQuery);
</script>    
        <script src="http://cdn.bootcss.com/mathjax/2.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>    <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>
    
<script type="text/javascript">
$('.ajax_widgets').each(function(){var src=$(this).attr('data-src');if(src)$(this).load('/widgets/'+src+'.html');});
$.each(_js2load,function(index,obj){loadjs(obj.src,obj.charset)});
</script>

<div id="scroll2top">
<img src="/scroll2top/arrow.png"/>
</div>
<script src="/scroll2top/scroll2top.min.js"></script>
<div id="winterland">
  <canvas></canvas>
</div>
<script src="/js/winterland.min.js"></script>

  </body>
</html>
