
<!DOCTYPE HTML>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>The 60 Page | It so life</title>
<meta name="author" content="RobinChia">

<meta name="description" content="It so life">


<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<meta property="og:site_name" content="It so life"/>

<!--[if IE]><style>.testIE.IE{display:inline;}</style><![endif]-->
<!--[if lte IE 7]><link rel="stylesheet" href="/css/ie7.css" type="text/css"><![endif]-->
<!--[if (lt IE 9)&(gt IE 7)]><style>.testIE.IE8{display:inline;}</style><![endif]-->
<!--[if gt IE 8]><style>.testIE.IE9{display:inline;}</style><![endif]-->

<link href="/favicon.png" rel="icon">
<link rel="alternate" href="/atom.xml" title="It so life Feed" type="application/atom+xml">

<link rel="stylesheet" href="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/css/bootstrap.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/font-awesome/4.0.3/css/font-awesome.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/prettify/r298/prettify.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" type="text/css">
<link rel="stylesheet" href="/css/style.css" type="text/css">
<!--[if lt IE 9]>
   <style>article,aside,dialog,footer,header,section,footer,nav,figure,menu{display:block}</style>
   <script src="http://cdn.staticfile.org/html5shiv/r29/html5.min.js"></script>
   <script src="http://cdn.staticfile.org/respond.js/1.4.2/respond.min.js"></script>
<link href="http://cdn.staticfile.org/respond.js/1.4.2/respond-proxy.html" id="respond-proxy" rel="respond-proxy" />
<link href="/js/respond.proxy.gif" id="respond-redirect" rel="respond-redirect" />
<script src="/js/respond.proxy.js"></script>
   <script src="http://cdn.bootcss.com/selectivizr/1.0.2/selectivizr-min.js"></script>
<![endif]-->
<script type="text/javascript">
function loadjs(c,d){var a=document.createElement("script");a.async=!0;a.type="text/javascript";a.src=c;a.charset=d||"gbk";(document.getElementsByTagName("HEAD")[0]||document.getElementsByTagName("BODY")[0]).appendChild(a)};
var _protocol = (("https:" == document.location.protocol) ? " https://" : " http://");
var _js2load = [];
</script>

</head>
<body>
      <header id="header" class="container"><nav id="main-nav" class="navbar navbar-default navbar-fixed-top " role="navigation">
  <div class="container">
    <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
      <span class="sr-only">Toggle navigation</span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="/">It so life</a>
    </div>
    <div  class="collapse navbar-collapse">
      <ul  class="nav navbar-nav">
  
        <li><a href="/" title="Home">Home</a></li>      
        <li><a href="/about/" title="About">About</a></li>      
        <li><a href="/archives/" title="Archives">Archives</a></li>      
      <li class='dropdown'>
        <a class='dropdown-toggle' data-toggle='dropdown' href='#'>website<b class='caret'></b></a>
        <ul class='dropdown-menu pure-menu-selected'>
    
          <li><a href="//groups.google.com/forum/#!forum/pongba" title="TopLanguage">TopLanguage</a></li>    
          <li><a href="//itpub.net/" title="ITPub">ITPub</a></li>    
          <li><a href="//blog.jobbole.com/" title="Bole">Bole</a></li>    
          <li><a href="//nosql-database.org/" title="nosql">nosql</a></li>    
          <li><a href="//gitimmersion.googol.im/" title="Git">Git</a></li>    
        </ul>
      </li>
    
      </ul>
      <ul class="nav navbar-nav navbar-right">
      
        <li><a href="/atom.xml">RSS</a></li>
      
      
        <li><a href="https://twitter.com/robinchia">twitter</a></li>
      
      
      
      
        <li><a href="https://github.com/robinchia">github</a></li>
      
      </ul>
    </div>
  </div>
</nav>
<div class="clearfix"></div>
</header>
  <div id='content' class="container">
     <div class="page-header-wrapper">
      <!--[if lt IE 9]><div class="alert alert-warning alert-dismissable"><button type="button" class="close" data-dismiss="alert" aria-hidden="true">&times;</button><strong>提示:</strong>您的浏览器版本太低了,建议升级到 <strong><a href="http://windows.microsoft.com/zh-cn/internet-explorer/download-ie" title="IE9">IE9</a></strong> 以上,本站使用<a href="https://www.google.com/intl/zh-CN/chrome/">Chrome浏览器</a>可以获得最好的显示效果.</div><![endif]-->
      <div class="page-header"><h1 align="center"><big>It so life</big> </h1>
        <h5 align="center"><big>love as life</big></h5>
      </div>
     </div>
     <div class="row">
       <div id="main-col" class="alignleft col-sx-12 col-sm-8 col-md-9 col-lg-9">
      <section id='header_widget'></section>
          <div id="wrapper"><article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-SQL_Java--Java中，获得ResultSet的总行数与总列数/">Java中，获得ResultSet的总行数与总列数</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:41.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-SQL_Java--Java中，获得ResultSet的总行数与总列数/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="java-resultset-">Java中，获得ResultSet的总行数与总列数</h1>
<h2 id="java-resultset-">Java中，获得ResultSet的总行数与总列数</h2>
<p>在Java中，获得ResultSet的总行数的方法有以下几种。</p>
<p><strong>第一种：利用ResultSet的getRow方法来获得ResultSet的总行数</strong></p>
<p>Statement stmt = con.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_UPDATABLE);
ResultSet rset = stmt.executeQuery(&quot;select /* from yourTableName&quot;);
rset.last();
int rowCount = rset.getRow(); //获得ResultSet的总行数</p>
<p><strong>第二种：利用循环ResultSet的元素来获得ResultSet的总行数</strong></p>
<p>ResultSet rset = stmt.executeQuery(&quot;select /* from yourTableName&quot;);
int rowCount = 0;
while(rset.next()) {
rowCount++;
}</p>
<p>rowCount就是ResultSet的总行数。</p>
<p><strong>第三种：利用sql语句中的count函数获得ResultSet的总行数</strong></p>
<p>ResultSet rset = stmt.executeQuery(&quot;select count(/*) totalCount from yourTableName&quot;);
int rowCount = 0;
if(rset.next()) {
rowCount=rset .getInt(&quot;totalCount &quot;);
}</p>
<p>rowCount就是ResultSet的总行数。</p>
<ul>
<li>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/*</li>
<li>Java中获得ResultSet的总列数是非常简单事情，因为Java中ResultSet提供了ResultSetMetaData工具类,ResultSetMetaData 是ResultSet的元数据的集合说明。</li>
</ul>
<p>java获得ResultSet总列数的代码如下：</p>
<p>Statement stmt = con.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_UPDATABLE);
ResultSet rset = stmt.executeQuery(&quot;select /* from yourtable&quot;);
ResultSetMetaData rsmd = rset.getMetaData() ;
int columnCount = rsmd.getColumnCount();</p>
<p>columnCount 就是ResultSet的总列数。</p>
<hr>
<p>例子：
Statement stmt = conn.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,  ResultSet.CONCUR_READ_ONLY);   ResultSet rs = stmt.executeQuery(sql);   rs.last();   int length = rs.getRow();</p>
<p>如上，length的值，就是行数了。如果在获取了行数后，还需要继续使用当前数据集rs，则需要rs.beforeFirst();一次，将游标回到初始位置。
ResultSet.TYPE_SCROLL_INSENSITIVE 结果集的游标可以上下移动，当数据库变化时，当前结果集不变。
ResultSet.CONCUR_READ_ONLY 不能用结果集更新数据库中的表。</p>
<p>此外，给出Statement创建时的其他说明：
通用格式为：Statement stmt=con.createStatement(int type，int concurrency);我们在访问数据库的时候，在读取返回结果的时候，可能要前后移动指针，比如我们先计算有多少条信息，这是我们就需要把指针移到最后来计算，然后再把指针移到最前面，逐条读取，有时我们只需要逐条读取就可以了。还有就是有只我们只需要读取数据，为了不破坏数据，我们可采用只读模式，有时我们需要望数据库里添加记录，这是我们就要采用可更新数据库的模式。
下面是所有参数的说明：
参数 int type
ResultSet.TYPE_FORWORD_ONLY 结果集的游标只能向下滚动。
ResultSet.TYPE_SCROLL_INSENSITIVE 结果集的游标可以上下移动，当数据库变化时，当前结果集不变。
ResultSet.TYPE_SCROLL_SENSITIVE 返回可滚动的结果集，当数据库变化时，当前结果集同步改变。</p>
<p>参数 int concurrency</p>
<p>ResultSet.CONCUR_READ_ONLY 不能用结果集更新数据库中的表。
ResultSet.CONCUR_UPDATETABLE 能用结果集更新数据库中的表。</p>
<p>此外，当我们使用ResultSet re=stmt.executeQuery(SQL语句）查询后，我们可以使用下列方法获得信息：</p>
<p>public boolean previous() 将游标向上移动，该方法返回boolean型数据，当移到结果集第一行之前时，返回false。
public void beforeFirst 将游标移动到结果集的初始位置，即在第一行之前。
public void afterLast() 将游标移到结果集最后一行之后。
public void first() 将游标移到结果集的第一行。
public void last() 将游标移到结果集的最后一行。
public boolean isAfterLast() 判断游标是否在最后一行之后。
public boolean isBeforeFirst() 判断游标是否在第一行之前。
public boolean ifFirst() 判断游标是否指向结果集的第一行。
public boolean isLast() 判断游标是否指向结果集的最后一行。
public int getRow() 得到当前游标所指向行的行号，行号从1开始，如果结果集没有行，返回0。
public boolean absolute(int row) 将游标移到参数row指定的行号。如果row取负值，就是倒数的行数，absolute(-1)表示移到最后一行，absolute(-2)表示移到倒数第2行。当移动到第一行前面或最后一行的后面时，该方法返回false。</p>
<p>ResultSetMetaData rsmd = this.rs.getMetaData();
this.columnCount = rsmd.getColumnCount();</p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/SQL_Java/">SQL_Java</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/SQL_Java/" class="label label-success">SQL_Java</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:41"datetime="2014-03-07 09:54:41"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-SQL_Java--Java中，获得ResultSet的总行数与总列数/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-SQL_Java--Java中，获得ResultSet的总行数与总列数" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_多线程-并发--深入浅出JavaConcurrency28-线程池/">深入浅出 Java Concurrency (28)</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:41.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_多线程-并发--深入浅出JavaConcurrency28-线程池/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-java-concurrency-28-">深入浅出 Java Concurrency (28): 线程池</h1>
<p><a href="http://www.blogjava.net/xylz/archive/2010/12/19/341098.html" target="_blank"> 简介</a></p>
<p>从这一节开始正式进入线程池的部分。其实整个体系已经拖了很长的时间，因此后面的章节会加快速度，甚至只是一个半成品或者简单化，以后有时间的慢慢补充、完善。</p>
<p>其实线程池是并发包里面很重要的一部分，在实际情况中也是使用很多的一个重要组件。</p>
<p>下图描述的是线程池API的一部分。广义上的完整线程池可能还包括Thread/Runnable、Timer/TimerTask等部分。这里只介绍主要的和高级的API以及架构和原理。</p>
<p><a href="http://www.blogjava.net/images/blogjava_net/xylz/Windows-Live-Writer/-part-1-_8E6F/ThreadPool2_2.png" target="_blank"><img src="&quot;ThreadPool2&quot;" alt="ThreadPool2"></a></p>
<p>大多数并发应用程序是围绕执行任务（Task）进行管理的。所谓任务就是抽象、离散的工作单元（unit of work）。把一个应用程序的工作（work）分离到任务中，可以简化程序的管理；这种分离还在不同事物间划分了自然的分界线，可以方便程序在出现错误时进行恢复；同时这种分离还可以为并行工作提供一个自然的结构，有利于提高程序的并发性。<a href="http://www.blogjava.net/xylz/archive/2010/12/19/341098.html#jcp" target="_blank">[1]</a></p>
<p>并发执行任务的一个很重要前提是拆分任务。把一个大的过程或者任务拆分成很多小的工作单元，每一个工作单元可能相关、也可能无关，这些单元在一定程度上可以充分利用CPU的特性并发的执行，从而提高并发性（性能、响应时间、吞吐量等）。</p>
<p>所谓的任务拆分就是确定每一个执行任务（工作单元）的边界。理想情况下独立的工作单元有最大的吞吐量，这些工作单元不依赖于其它工作单元的状态、结果或者其他资源等。因此将任务尽可能的拆分成一个个独立的工作单元有利于提高程序的并发性。</p>
<p>对于有依赖关系以及资源竞争的工作单元就涉及到任务的调度和负载均衡。工作单元的状态、结果或者其他资源等有关联的工作单元就需要有一个总体的调度者来协调资源和执行顺序。同样在有限的资源情况下，大量的任务也需要一个协调各个工作单元的调度者。这就涉及到任务执行的策略问题。</p>
<p>任务的执行策略包括4W3H部分：</p>
<ul>
<li>任务在什么（What）线程中执行</li>
<li>任务以什么（What）顺序执行（FIFO/LIFO/优先级等）</li>
<li>同时有多少个（How Many）任务并发执行</li>
<li>允许有多少个（How Many）个任务进入执行队列</li>
<li>系统过载时选择放弃哪一个（Which）任务，如何（How）通知应用程序这个动作</li>
<li>任务执行的开始、结束应该做什么（What）处理</li>
</ul>
<p>在后面的章节中会详细分写这些策略是如何实现的。我们先来简单回答些如何满足上面的条件。</p>
<ol>
<li>首先明确一定是在Java里面可以供使用者调用的启动线程类是Thread。因此Runnable或者Timer/TimerTask等都是要依赖Thread来启动的，因此在ThreadPool里面同样也是靠Thread来启动多线程的。</li>
<li>默认情况下Runnable接口执行完毕后是不能拿到执行结果的，因此在ThreadPool里就定义了一个Callable接口来处理执行结果。</li>
<li>为了异步阻塞的获取结果，Future可以帮助调用线程获取执行结果。</li>
<li>Executor解决了向线程池提交任务的入口问题，同时ScheduledExecutorService解决了如何进行重复调用任务的问题。</li>
<li>CompletionService解决了如何按照执行完毕的顺序获取结果的问题，这在某些情况下可以提高任务执行的并发，调用线程不必在长时间任务上等待过多时间。</li>
<li>显然线程的数量是有限的，而且也不宜过多，因此合适的任务队列是必不可少的，BlockingQueue的容量正好可以解决此问题。</li>
<li>固定任务容量就意味着在容量满了以后需要一定的策略来处理过多的任务（新任务），RejectedExecutionHandler正好解决此问题。</li>
<li>一定时间内阻塞就意味着有超时，因此TimeoutException就是为了描述这种现象。TimeUnit是为了描述超时时间方便的一个时间单元枚举类。</li>
<li>有上述问题就意味了配置一个合适的线程池是很复杂的，因此Executors默认的一些线程池配置可以减少这个操作。</li>
</ol>
<p>线程池的基本策略大致就这些，从下一节开始就从线程池的基本原理和执行方法开始描述。</p>
<p><a href="">[1] Java Concurrency in Practice</a>
来源： <a href="[http://www.blogjava.net/xylz/archive/2010/12/19/341098.html](http://www.blogjava.net/xylz/archive/2010/12/19/341098.html)">[http://www.blogjava.net/xylz/archive/2010/12/19/341098.html](http://www.blogjava.net/xylz/archive/2010/12/19/341098.html)</a> <a href="http://www.blogjava.net/xylz/archive/2010/12/21/341281.html" target="_blank">Executor 以及Executors</a>
Java里面线程池的顶级接口是Executor，但是严格意义上讲Executor并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是ExecutorService。</p>
<p>下面这张图完整描述了线程池的类体系结构。</p>
<p><a href="http://www.blogjava.net/images/blogjava_net/xylz/Windows-Live-Writer/-Java-Concurrency-28--part-1-_1302E/Executor-class_2.png" target="_blank"><img src="&quot;Executor-class&quot;" alt="Executor-class"></a></p>
<p>首先Executor的execute方法只是执行一个Runnable的任务，当然了从某种角度上将最后的实现类也是在线程中启动此任务的。根据线程池的执行策略最后这个任务可能在新的线程中执行，或者线程池中的某个线程，甚至是调用者线程中执行（相当于直接运行Runnable的run方法）。这点在后面会详细说明。</p>
<p>ExecutorService在Executor的基础上增加了一些方法，其中有两个核心的方法：</p>
<ul>
<li>Future&lt;?&gt; submit(Runnable task)</li>
<li><T> Future<T> submit(Callable<T> task)</li>
</ul>
<p>这两个方法都是向线程池中提交任务，它们的区别在于Runnable在执行完毕后没有结果，Callable执行完毕后有一个结果。这在多个线程中传递状态和结果是非常有用的。另外他们的相同点在于都返回一个Future对象。Future对象可以阻塞线程直到运行完毕（获取结果，如果有的话），也可以取消任务执行，当然也能够检测任务是否被取消或者是否执行完毕。</p>
<p>在没有Future之前我们检测一个线程是否执行完毕通常使用Thread.join()或者用一个死循环加状态位来描述线程执行完毕。现在有了更好的方法能够阻塞线程，检测任务执行完毕甚至取消执行中或者未开始执行的任务。</p>
<p>ScheduledExecutorService描述的功能和Timer/TimerTask类似，解决那些需要任务重复执行的问题。这包括延迟时间一次性执行、延迟时间周期性执行以及固定延迟时间周期性执行等。当然了继承ExecutorService的ScheduledExecutorService拥有ExecutorService的全部特性。</p>
<p>ThreadPoolExecutor是ExecutorService的默认实现，其中的配置、策略也是比较复杂的，在后面的章节中会有详细的分析。</p>
<p>ScheduledThreadPoolExecutor是继承ThreadPoolExecutor的ScheduledExecutorService接口实现，周期性任务调度的类实现，在后面的章节中会有详细的分析。</p>
<p>这里需要稍微提一下的是CompletionService接口，它是用于描述顺序获取执行结果的一个线程池包装器。它依赖一个具体的线程池调度，但是能够根据任务的执行先后顺序得到执行结果，这在某些情况下可能提高并发效率。</p>
<p>要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，很有可能配置的线程池不是较优的，因此在Executors类里面提供了一些静态工厂，生成一些常用的线程池。</p>
<ul>
<li><strong>newSingleThreadExecutor</strong>：创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。</li>
<li><strong>newFixedThreadPool</strong>：创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。</li>
<li><strong>newCachedThreadPool</strong>：创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。</li>
<li><strong>newScheduledThreadPool</strong>：创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。</li>
<li><strong>newSingleThreadScheduledExecutor</strong>：创建一个单线程的线程池。此线程池支持定时以及周期性执行任务的需求。</li>
</ul>
<p>在详细讲解ThreadPoolExecutor的时候会具体讨论上述参数配置后的意义和原理。</p>
<p>线程池是一个复杂的任务调度工具，因此它涉及到任务、线程池等的生命周期问题，在下一节中来探讨下这个问题。
来源： <a href="[http://www.blogjava.net/xylz/archive/2010/12/21/341281.html](http://www.blogjava.net/xylz/archive/2010/12/21/341281.html)">[http://www.blogjava.net/xylz/archive/2010/12/21/341281.html](http://www.blogjava.net/xylz/archive/2010/12/21/341281.html)</a> <a href="http://www.blogjava.net/xylz/archive/2011/01/04/342316.html" target="_blank">Executor 生命周期</a></p>
<p>我们知道线程是有多种执行状态的，同样管理线程的线程池也有多种状态。JVM会在所有线程（非后台daemon线程）全部终止后才退出，为了节省资源和有效释放资源关闭一个线程池就显得很重要。有时候无法正确的关闭线程池，将会阻止JVM的结束。</p>
<p>线程池Executor是异步的执行任务，因此任何时刻不能够直接获取提交的任务的状态。这些任务有可能已经完成，也有可能正在执行或者还在排队等待执行。因此关闭线程池可能出现一下几种情况：</p>
<ul>
<li>平缓关闭：已经启动的任务全部执行完毕，同时不再接受新的任务</li>
<li>立即关闭：取消所有正在执行和未执行的任务</li>
</ul>
<p>另外关闭线程池后对于任务的状态应该有相应的反馈信息。</p>
<p>图1 描述了线程池的4种状态。</p>
<ul>
<li>线程池在构造前（new操作）是初始状态，一旦构造完成线程池就进入了执行状态RUNNING。严格意义上讲线程池构造完成后并没有线程被立即启动，只有进行“预启动”或者接收到任务的时候才会启动线程。这个会后面线程池的原理会详细分析。但是线程池是出于运行状态，随时准备接受任务来执行。</li>
<li>线程池运行中可以通过shutdown()和shutdownNow()来改变运行状态。shutdown()是一个平缓的关闭过程，线程池停止接受新的任务，同时等待已经提交的任务执行完毕，包括那些进入队列还没有开始的任务，这时候线程池处于SHUTDOWN状态；shutdownNow()是一个立即关闭过程，线程池停止接受新的任务，同时线程池取消所有执行的任务和已经进入队列但是还没有执行的任务，这时候线程池处于STOP状态。</li>
<li>一旦shutdown()或者shutdownNow()执行完毕，线程池就进入TERMINATED状态，此时线程池就结束了。</li>
<li>isTerminating()描述的是SHUTDOWN和STOP两种状态。</li>
<li>isShutdown()描述的是非RUNNING状态，也就是SHUTDOWN/STOP/TERMINATED三种状态。</li>
</ul>
<p><a href="http://www.blogjava.net/images/blogjava_net/xylz/Windows-Live-Writer/-part-3-Executor-_12486/Executor-Lifecycle_4.png" target="_blank"><img src="&quot;Executor-Lifecycle&quot;" alt="Executor-Lifecycle"></a></p>
<p>图1</p>
<p>线程池的API如下：</p>
<p><a href="http://www.blogjava.net/images/blogjava_net/xylz/Windows-Live-Writer/-part-3-Executor-_12486/ExecutorService-LifeCycle_2.png" target="_blank"><img src="&quot;ExecutorService-LifeCycle&quot;" alt="ExecutorService-LifeCycle"></a></p>
<p>图2</p>
<p>其中shutdownNow()会返回那些已经进入了队列但是还没有执行的任务列表。awaitTermination描述的是等待线程池关闭的时间，如果等待时间线程池还没有关闭将会抛出一个超时异常。</p>
<p>对于关闭线程池期间发生的任务提交情况就会触发一个拒绝执行的操作。这是java.util.concurrent.RejectedExecutionHandler描述的任务操作。下一个小结中将描述这些任务被拒绝后的操作。</p>
<p>总结下这个小节：</p>
<ol>
<li>线程池有运行、关闭、停止、结束四种状态，结束后就会释放所有资源</li>
<li>平缓关闭线程池使用shutdown()</li>
<li>立即关闭线程池使用shutdownNow()，同时得到未执行的任务列表</li>
<li>检测线程池是否正处于关闭中，使用isShutdown()</li>
<li>检测线程池是否已经关闭使用isTerminated()</li>
<li>定时或者永久等待线程池关闭结束使用awaitTermination()操作</li>
</ol>
<p>来源： <a href="[http://www.blogjava.net/xylz/archive/2011/01/04/342316.html](http://www.blogjava.net/xylz/archive/2011/01/04/342316.html)">[http://www.blogjava.net/xylz/archive/2011/01/04/342316.html](http://www.blogjava.net/xylz/archive/2011/01/04/342316.html)</a></p>
<p><strong>线程池数据结构与线程构造方法</strong></p>
<p>由于已经看到了ThreadPoolExecutor的源码，因此很容易就看到了ThreadPoolExecutor线程池的数据结构。图1描述了这种数据结构。</p>
<p><a href="http://www.blogjava.net/images/blogjava_net/xylz/Windows-Live-Writer/-Java-Concurrency-32--part-5-_72AF/ThreadPoolExecutor_2.png" target="_blank"><img src="&quot;ThreadPoolExecutor&quot;" alt="ThreadPoolExecutor"></a></p>
<p>图1 ThreadPoolExecutor 数据结构</p>
<p>其实，即使没有上述图形描述ThreadPoolExecutor的数据结构，我们根据线程池的要求也很能够猜测出其数据结构出来。</p>
<ul>
<li>线程池需要支持多个线程并发执行，因此有一个线程集合Collection<Thread>来执行线程任务；</li>
<li>涉及任务的异步执行，因此需要有一个集合来缓存任务队列Collection<Runnable>；</li>
<li>很显然在多个线程之间协调多个任务，那么就需要一个线程安全的任务集合，同时还需要支持阻塞、超时操作，那么BlockingQueue是必不可少的；</li>
<li>既然是线程池，出发点就是提高系统性能同时降低资源消耗，那么线程池的大小就有限制，因此需要有一个核心线程池大小（线程个数）和一个最大线程池大小（线程个数），有一个计数用来描述当前线程池大小；</li>
<li>如果是有限的线程池大小，那么长时间不使用的线程资源就应该销毁掉，这样就需要一个线程空闲时间的计数来描述线程何时被销毁；</li>
<li>前面描述过线程池也是有生命周期的，因此需要有一个状态来描述线程池当前的运行状态；</li>
<li>线程池的任务队列如果有边界，那么就需要有一个任务拒绝策略来处理过多的任务，同时在线程池的销毁阶段也需要有一个任务拒绝策略来处理新加入的任务；</li>
<li>上面种的线程池大小、线程空闲实际那、线程池运行状态等等状态改变都不是线程安全的，因此需要有一个全局的锁（mainLock）来协调这些竞争资源；</li>
<li>除了以上数据结构以外，ThreadPoolExecutor还有一些状态用来描述线程池的运行计数，例如线程池运行的任务数、曾经达到的最大线程数，主要用于调试和性能分析。</li>
</ul>
<p>对于ThreadPoolExecutor而言，一个线程就是一个Worker对象，它与一个线程绑定，当Worker执行完毕就是线程执行完毕，这个在后面详细讨论线程池中线程的运行方式。</p>
<p>既然是线程池，那么就首先研究下线程的构造方法。
public interface ThreadFactory {
    Thread newThread(Runnable r);
}</p>
<p>ThreadPoolExecutor使用一个线程工厂来构造线程。线程池都是提交一个任务Runnable，然后在某一个线程Thread中执行，ThreadFactory 负责如何创建一个新线程。</p>
<p>在J.U.C中有一个通用的线程工厂java.util.concurrent.Executors.DefaultThreadFactory，它的构造方式如下：
static class DefaultThreadFactory implements ThreadFactory {
    static final AtomicInteger poolNumber = new AtomicInteger(1);
    final ThreadGroup group;
    final AtomicInteger threadNumber = new AtomicInteger(1);
    final String namePrefix;
    DefaultThreadFactory() {
        SecurityManager s = System.getSecurityManager();
        group = (s != null)? s.getThreadGroup() :
                             Thread.currentThread().getThreadGroup();
        namePrefix = &quot;pool-&quot; +
                      poolNumber.getAndIncrement() +
                     &quot;-thread-&quot;;
    }
    public Thread newThread(Runnable r) {
        Thread t = new Thread(group, r,
                              namePrefix + threadNumber.getAndIncrement(),
                              0);
        if (t.isDaemon())
            t.setDaemon(false);
        if (t.getPriority() != Thread.NORM_PRIORITY)
            t.setPriority(Thread.NORM_PRIORITY);
        return t;
    }
}</p>
<p>在这个线程工厂中，同一个线程池的所有线程属于同一个线程组，也就是创建线程池的那个线程组，同时线程池的名称都是“pool-<poolNum>-thread-<threadNum>”，其中poolNum是线程池的数量序号，threadNum是此线程池中的线程数量序号。这样如果使用jstack的话很容易就看到了系统中线程池的数量和线程池中线程的数量。另外对于线程池中的所有线程默认都转换为非后台线程，这样主线程退出时不会直接退出JVM，而是等待线程池结束。还有一点就是默认将线程池中的所有线程都调为同一个级别，这样在操作系统角度来看所有系统都是公平的，不会导致竞争堆积。</p>
<p><strong>线程池中线程生命周期</strong></p>
<p>一个线程Worker被构造出来以后就开始处于运行状态。以下是一个线程执行的简版逻辑。
private final class Worker implements Runnable {
    private final ReentrantLock runLock = new ReentrantLock();
    private Runnable firstTask;
    Thread thread;
    Worker(Runnable firstTask) {
        this.firstTask = firstTask;
    }
    private void runTask(Runnable task) {
        final ReentrantLock runLock = this.runLock;
        runLock.lock();
        try {
           task.run();
        } finally {
            runLock.unlock();
        }
    }
    public void run() {
        try {
            Runnable task = firstTask;
            firstTask = null;
            while (task != null || (task = getTask()) != null) {
                runTask(task);
                task = null;
            }
        } finally {
            workerDone(this);
        }
    }
}</p>
<p><a href="http://www.blogjava.net/images/blogjava_net/xylz/Windows-Live-Writer/-Java-Concurrency-32--part-5-_72AF/ThreadPoolExecutor-Worker_2.png" target="_blank"><img src="&quot;ThreadPoolExecutor-Worker&quot;" alt="ThreadPoolExecutor-Worker"></a></p>
<p>当提交一个任务时，如果需要创建一个线程（何时需要在下一节中探讨）时，就调用线程工厂创建一个线程，同时将线程绑定到Worker工作队列中。需要说明的是，Worker队列构造的时候带着一个任务Runnable，因此Worker创建时总是绑定着一个待执行任务。换句话说，创建线程的前提是有必要创建线程（任务数已经超出了线程或者强制创建新的线程，至于为何强制创建新的线程后面章节会具体分析），不会无缘无故创建一堆空闲线程等着任务。这是节省资源的一种方式。</p>
<p>一旦线程池启动线程后（调用线程run()）方法，那么线程工作队列Worker就从第1个任务开始执行（这时候发现构造Worker时传递一个任务的好处了），一旦第1个任务执行完毕，就从线程池的任务队列中取出下一个任务进行执行。循环如此，直到线程池被关闭或者任务抛出了一个RuntimeException。</p>
<p>由此可见，线程池的基本原理其实也很简单，无非预先启动一些线程，线程进入死循环状态，每次从任务队列中获取一个任务进行执行，直到线程池被关闭。如果某个线程因为执行某个任务发生异常而终止，那么重新创建一个新的线程而已。如此反复。</p>
<p>其实，线程池原理看起来简单，但是复杂的是各种策略，例如何时该启动一个线程，何时该终止、挂起、唤醒一个线程，任务队列的阻塞与超时，线程池的生命周期以及任务拒绝策略等等。下一节将研究这些策略问题。</p>
<p>来源： <a href="[http://www.blogjava.net/xylz/archive/2011/01/18/343183.html](http://www.blogjava.net/xylz/archive/2011/01/18/343183.html)">[http://www.blogjava.net/xylz/archive/2011/01/18/343183.html](http://www.blogjava.net/xylz/archive/2011/01/18/343183.html)</a> </p>
<p><strong>线程池任务执行流程</strong></p>
<p>我们从一个API开始接触Executor是如何处理任务队列的。</p>
<p>java.util.concurrent.Executor.execute(Runnable)
Executes the given task sometime in the future. The task may execute in a new thread or in an existing pooled thread. If the task cannot be submitted for execution, either because this executor has been shutdown or because its capacity has been reached, the task is handled by the current RejectedExecutionHandler.</p>
<p>线程池中所有任务执行都依赖于此接口。这段话有以下几个意思：</p>
<ol>
<li>任务可能在将来某个时刻被执行，有可能不是立即执行。为什么这里有两个“可能”？继续往下面看。</li>
<li>任务可能在一个新的线程中执行或者线程池中存在的一个线程中执行。</li>
<li>任务无法被提交执行有以下两个原因：线程池已经关闭或者线程池已经达到了容量限制。</li>
<li>所有失败的任务都将被“当前”的任务拒绝策略RejectedExecutionHandler 处理。</li>
</ol>
<p>回答上面两个“可能“。任务可能被执行，那不可能的情况就是上面说的情况3；可能不是立即执行，是因为任务可能还在队列中排队，因此还在等待分配线程执行。了解完了字面上的问题，我们再来看具体的实现。
public void execute(Runnable command) {
    if (command == null)
        throw new NullPointerException();
    if (poolSize &gt;= corePoolSize || !addIfUnderCorePoolSize(command)) {
        if (runState == RUNNING &amp;&amp; workQueue.offer(command)) {
            if (runState != RUNNING || poolSize == 0)
                ensureQueuedTaskHandled(command);
        }
        else if (!addIfUnderMaximumPoolSize(command))
            reject(command); // is shutdown or saturated
    }
}</p>
<p>这一段代码看起来挺简单的，其实这就是线程池最重要的一部分，如果能够完全理解这一块，线程池还是挺容易的。整个执行流程是这样的：</p>
<ol>
<li>如果任务command为空，则抛出空指针异常，返回。否则进行2。</li>
<li>如果当前线程池大小 大于或等于 核心线程池大小，进行4。否则进行3。</li>
<li>创建一个新工作队列（线程，参考上一节），成功直接返回，失败进行4。</li>
<li>如果线程池正在运行并且任务加入线程池队列成功，进行5，否则进行7。</li>
<li>如果线程池已经关闭或者线程池大小为0，进行6，否则直接返回。</li>
<li>如果线程池已经关闭则执行拒绝策略返回，否则启动一个新线程来进行执行任务，返回。</li>
<li>如果线程池大小 不大于 最大线程池数量，则启动新线程来进行执行，否则进行拒绝策略，结束。</li>
</ol>
<p>文字描述步骤不够简单？下面图形详细表述了此过程。</p>
<p><a href="http://www.blogjava.net/images/blogjava_net/xylz/Windows-Live-Writer/-Java-Concurrency-34--part-7--2_BFAE/Executor.execute_8.png" target="_blank"><img src="&quot;Executor.execute&quot;" alt="Executor.execute"></a></p>
<p>老实说这个图比上面步骤更难以理解，那么从何入手呢。</p>
<p>流程的入口很简单，我们就是要执行一个任务（Runnable command)，那么它的结束点在哪或者有哪几个？</p>
<p>根据左边这个图我们知道可能有以下几种出口：</p>
<p>（1）图中的P1、P7，我们根据这条路径可以看到，仅仅是将任务加入任务队列（offer(command)）了；</p>
<p>（2）图中的P3，这条路径不将任务加入任务队列，但是启动了一个新工作线程（Worker）进行扫尾操作，用户处理为空的任务队列；</p>
<p>（3）图中的P4，这条路径没有将任务加入任务队列，但是启动了一个新工作线程（Worker），并且工作现场的第一个任务就是当前任务；</p>
<p>（4）图中的P5、P6，这条路径没有将任务加入任务队列，也没有启动工作线程，仅仅是抛给了任务拒绝策略。P2是任务加入了任务队列却因为线程池已经关闭于是又从任务队列中删除，并且抛给了拒绝策略。</p>
<p>如果上面的解释还不清楚，可以去研究下面两段代码：
java.util.concurrent.ThreadPoolExecutor.addIfUnderCorePoolSize(Runnable)
java.util.concurrent.ThreadPoolExecutor.addIfUnderMaximumPoolSize(Runnable)
java.util.concurrent.ThreadPoolExecutor.ensureQueuedTaskHandled(Runnable)</p>
<p>那么什么时候一个任务被立即执行呢？</p>
<p>在线程池运行状态下，如果线程池大小 小于 核心线程池大小或者线程池已满（任务队列已满）并且线程池大小 小于 最大线程池大小（此时线程池大小 大于 核心线程池大小的），用程序描述为：
runState == RUNNING &amp;&amp; ( poolSize &lt; corePoolSize || poolSize &lt; maxnumPoolSize &amp;&amp; workQueue.isFull())</p>
<p>上面的条件就是一个任务能够被立即执行的条件。</p>
<p>有了execute的基础，我们看看ExecutorService中的几个submit方法的实现。
    public Future&lt;?&gt; submit(Runnable task) {
        if (task == null) throw new NullPointerException();
        RunnableFuture<Object> ftask = newTaskFor(task, null);
        execute(ftask);
        return ftask;
    }
    public <T> Future<T> submit(Runnable task, T result) {
        if (task == null) throw new NullPointerException();
        RunnableFuture<T> ftask = newTaskFor(task, result);
        execute(ftask);
        return ftask;
    }
    public <T> Future<T> submit(Callable<T> task) {
        if (task == null) throw new NullPointerException();
        RunnableFuture<T> ftask = newTaskFor(task);
        execute(ftask);
        return ftask;
    }</p>
<p>很简单，不是么？对于一个线程池来说复杂的地方也就在execute方法的执行流程。在下一节中我们来讨论下如何获取任务的执行结果，也就是Future类的使用和原理。</p>
<p>来源： <a href="[http://www.blogjava.net/xylz/archive/2011/02/11/344091.html](http://www.blogjava.net/xylz/archive/2011/02/11/344091.html)">[http://www.blogjava.net/xylz/archive/2011/02/11/344091.html](http://www.blogjava.net/xylz/archive/2011/02/11/344091.html)</a> </p>
<p><strong>线程池任务执行结果</strong></p>
<p>这一节来探讨下线程池中任务执行的结果以及如何阻塞线程、取消任务等等。
1 package info.imxylz.study.concurrency.future;
2 
3 public class SleepForResultDemo implements Runnable {
4 
5     static boolean result = false;
6 
7     static void sleepWhile(long ms) {
8         try {
9             Thread.sleep(ms);
10         } catch (Exception e) {}
11     }
12 
13     @Override
14     public void run() {
15         //do work
16         System.out.println(&quot;Hello, sleep a while.&quot;);
17         sleepWhile(2000L);
18         result = true;
19     }
20 
21     public static void main(String[] args) {
22         SleepForResultDemo demo = new SleepForResultDemo();
23         Thread t = new Thread(demo);
24         t.start();
25         sleepWhile(3000L);
26         System.out.println(result);
27     }
28 
29 }
30 </p>
<p>在没有线程池的时代里面，使用Thread.sleep(long)去获取线程执行完毕的场景很多。显然这种方式很笨拙，他需要你事先知道任务可能的执行时间，并且还会阻塞主线程，不管任务有没有执行完毕。</p>
<p>1 package info.imxylz.study.concurrency.future;
2 
3 public class SleepLoopForResultDemo implements Runnable {
4 
5     boolean result = false;
6 
7     volatile boolean finished = false;
8 
9     static void sleepWhile(long ms) {
10         try {
11             Thread.sleep(ms);
12         } catch (Exception e) {}
13     }
14 
15     @Override
16     public void run() {
17         //do work
18         try {
19             System.out.println(&quot;Hello, sleep a while.&quot;);
20             sleepWhile(2000L);
21             result = true;
22         } finally {
23             finished = true;
24         }
25     }
26 
27     public static void main(String[] args) {
28         SleepLoopForResultDemo demo = new SleepLoopForResultDemo();
29         Thread t = new Thread(demo);
30         t.start();
31         while (!demo.finished) {
32             sleepWhile(10L);
33         }
34         System.out.println(demo.result);
35     }
36 
37 }
38 </p>
<p>使用volatile与while死循环的好处就是等待的时间可以稍微小一点，但是依然有CPU负载高并且阻塞主线程的问题。最简单的降低CPU负载的方式就是使用Thread.join().</p>
<pre><code>    SleepLoopForResultDemo demo = new SleepLoopForResultDemo();
    Thread t = new Thread(demo);
    t.start();
    t.join();
    System.out.println(demo.result);
</code></pre><p>显然这也是一种不错的方式，另外还有自己写锁使用wait/notify的方式。其实join()从本质上讲就是利用while和wait来实现的。</p>
<p>上面的方式中都存在一个问题，那就是会阻塞主线程并且任务不能被取消。为了解决这个问题，线程池中提供了一个Future接口。</p>
<p><a href="http://www.blogjava.net/images/blogjava_net/xylz/Windows-Live-Writer/-Java-Concurrency-35--part-8--2_BFEA/ThreadPoolExecutor-Future_2.png" target="_blank"><img src="&quot;ThreadPoolExecutor-Future&quot;" alt="ThreadPoolExecutor-Future"></a></p>
<p>在Future接口中提供了5个方法。</p>
<ul>
<li>V get() throws InterruptedException, ExecutionException： 等待计算完成，然后获取其结果。</li>
<li>V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException。最多等待为使计算完成所给定的时间之后，获取其结果（如果结果可用）。</li>
<li>boolean cancel(boolean mayInterruptIfRunning)：试图取消对此任务的执行。</li>
<li>boolean isCancelled()：如果在任务正常完成前将其取消，则返回 true。</li>
<li>boolean isDone()：如果任务已完成，则返回 true。 可能由于正常终止、异常或取消而完成，在所有这些情况中，此方法都将返回 true。</li>
</ul>
<p>API看起来容易，来研究下异常吧。get()请求获取一个结果会阻塞当前进程，并且可能抛出以下三种异常：</p>
<ul>
<li>InterruptedException：执行任务的线程被中断则会抛出此异常，此时不能知道任务是否执行完毕，因此其结果是无用的，必须处理此异常。</li>
<li>ExecutionException：任务执行过程中(Runnable/#run()）方法可能抛出RuntimeException，如果提交的是一个java.util.concurrent.Callable<V>接口任务，那么java.util.concurrent.Callable.call()方法有可能抛出任意异常。</li>
<li>CancellationException：实际上get()方法还可能抛出一个CancellationException的RuntimeException，也就是任务被取消了但是依然去获取结果。</li>
</ul>
<p>对于get(long timeout, TimeUnit unit)而言，除了get()方法的异常外，由于有超时机制，因此还可能得到一个TimeoutException。</p>
<p>boolean cancel(boolean mayInterruptIfRunning)方法比较复杂，各种情况比较多：</p>
<ol>
<li>如果任务已经执行完毕，那么返回false。</li>
<li>如果任务已经取消，那么返回false。</li>
<li>循环直到设置任务为取消状态，对于未启动的任务将永远不再执行，对于正在运行的任务，将根据mayInterruptIfRunning是否中断其运行，如果不中断那么任务将继续运行直到结束。</li>
<li>此方法返回后任务要么处于运行结束状态，要么处于取消状态。isDone()将永远返回true，如果cancel()方法返回true，isCancelled()始终返回true。</li>
</ol>
<p>来看看Future接口的实现类java.util.concurrent.FutureTask<V>具体是如何操作的。</p>
<p>在FutureTask中使用了一个<a href="http://www.blogjava.net/xylz/archive/2010/07/06/325390.html" target="_blank">AQS</a>数据结构来完成各种状态以及加锁、阻塞的实现。</p>
<p>在此AQS类java.util.concurrent.FutureTask.Sync中一个任务用4中状态：</p>
<p><a href="http://www.blogjava.net/images/blogjava_net/xylz/Windows-Live-Writer/-Java-Concurrency-35--part-8--2_BFEA/ThreadPoolExecutor-FutureTask-state_2.png" target="_blank"><img src="&quot;ThreadPoolExecutor-FutureTask-state&quot;" alt="ThreadPoolExecutor-FutureTask-state"></a></p>
<p>初始情况下任务状态state=0，任务执行(innerRun)后状态变为运行状态RUNNING(state=1)，执行完毕后变成运行结束状态RAN(state=2)。任务在初始状态或者执行状态被取消后就变为状态CANCELLED(state=4)。<a href="http://www.blogjava.net/xylz/archive/2010/07/06/325390.html" target="_blank">AQS</a>最擅长无锁情况下处理几种简单的状态变更的。
        void innerRun() {
            if (!compareAndSetState(0, RUNNING))
                return;
            try {
                runner = Thread.currentThread();
                if (getState() == RUNNING) // recheck after setting thread
                    innerSet(callable.call());
                else
                    releaseShared(0); // cancel
            } catch (Throwable ex) {
                innerSetException(ex);
            }
        }</p>
<p>执行一个任务有四步：设置运行状态、设置当前线程（AQS需要）、执行任务(Runnable/#run或者Callable/#call）、设置执行结果。这里也可以看到，一个任务只能执行一次，因为执行完毕后它的状态不在为初始值0，要么为CANCELLED，要么为RAN。</p>
<p>取消一个任务(cancel)又是怎样进行的呢？对比下前面取消任务的描述是不是很简单，这里无非利用AQS的状态来改变任务的执行状态，最终达到放弃未启动或者正在执行的任务的目的。
boolean innerCancel(boolean mayInterruptIfRunning) {
    for (;;) {
        int s = getState();
        if (ranOrCancelled(s))
            return false;
        if (compareAndSetState(s, CANCELLED))
            break;
    }
    if (mayInterruptIfRunning) {
        Thread r = runner;
        if (r != null)
            r.interrupt();
    }
    releaseShared(0);
    done();
    return true;
}</p>
<p>到目前为止我们依然没有说明到底是如何阻塞获取一个结果的。下面四段代码描述了这个过程。</p>
<p>1     V innerGet() throws InterruptedException, ExecutionException {
2         acquireSharedInterruptibly(0);
3         if (getState() == CANCELLED)
4             throw new CancellationException();
5         if (exception != null)
6             throw new ExecutionException(exception);
7         return result;
8     }
9     //AQS/#acquireSharedInterruptibly
10     public final void acquireSharedInterruptibly(int arg) throws InterruptedException {
11         if (Thread.interrupted())
12             throw new InterruptedException();
13         if (tryAcquireShared(arg) &lt; 0)
14             doAcquireSharedInterruptibly(arg); //park current Thread for result
15     }
16     protected int tryAcquireShared(int ignore) {
17         return innerIsDone()? 1 : -1;
18     }
19 
20     boolean innerIsDone() {
21         return ranOrCancelled(getState()) &amp;&amp; runner == null;
22     }</p>
<p>当调用Future/#get()的时候尝试去获取一个共享变量。这就涉及到AQS的使用方式了。这里获取一个共享变量的状态是任务是否结束(innerIsDone())，也就是任务是否执行完毕或者被取消。如果不满足条件，那么在AQS中就会doAcquireSharedInterruptibly(arg)挂起当前线程，直到满足条件。AQS前面讲过，挂起线程使用的是LockSupport的park方式，因此性能消耗是很低的。</p>
<p>至于将Runnable接口转换成Callable接口，java.util.concurrent.Executors.callable(Runnable, T)也提供了一个简单实现。
    static final class RunnableAdapter<T> implements Callable<T> {
        final Runnable task;
        final T result;
        RunnableAdapter(Runnable  task, T result) {
            this.task = task;
            this.result = result;
        }
        public T call() {
            task.run();
            return result;
        }
    }</p>
<p><strong>延迟、周期性任务调度的实现</strong></p>
<p>java.util.concurrent.ScheduledThreadPoolExecutor是默认的延迟、周期性任务调度的实现。</p>
<p>有了整个线程池的实现，再回头来看延迟、周期性任务调度的实现应该就很简单了，因为所谓的延迟、周期性任务调度，无非添加一系列有序的任务队列，然后按照执行顺序的先后来处理整个任务队列。如果是周期性任务，那么在执行完毕的时候加入下一个时间点的任务即可。</p>
<p>由此可见，ScheduledThreadPoolExecutor和ThreadPoolExecutor的唯一区别在于任务是有序（按照执行时间顺序）的，并且需要到达时间点（临界点）才能执行，并不是任务队列中有任务就需要执行的。也就是说唯一不同的就是任务队列BlockingQueue<Runnable> workQueue不一样。ScheduledThreadPoolExecutor的任务队列是java.util.concurrent.ScheduledThreadPoolExecutor.DelayedWorkQueue，它是基于java.util.concurrent.DelayQueue<RunnableScheduledFuture>队列的实现。</p>
<p>DelayQueue是基于有序队列<a href="http://www.blogjava.net/xylz/archive/2010/07/30/327582.html" target="_blank">PriorityQueue</a>实现的。<a href="http://www.blogjava.net/xylz/archive/2010/07/30/327582.html" target="_blank">PriorityQueue</a> 也叫优先级队列，按照自然顺序对元素进行排序，类似于TreeMap/Collections.sort一样。</p>
<p>同样是有序队列，DelayQueue和<a href="http://www.blogjava.net/xylz/archive/2010/07/30/327582.html" target="_blank">PriorityQueue</a>区别在什么地方？</p>
<p>由于DelayQueue在获取元素时需要检测元素是否“可用”，也就是任务是否达到“临界点”（指定时间点），因此加入元素和移除元素会有一些额外的操作。</p>
<p>典型的，移除元素需要检测元素是否达到“临界点”，增加元素的时候如果有一个元素比“头元素”更早达到临界点，那么就需要通知任务队列。因此这需要一个条件变量final Condition available 。</p>
<p>移除元素（出队列）的过程是这样的：</p>
<ul>
<li>总是检测队列的头元素（顺序最小元素，也是最先达到临界点的元素）</li>
<li>检测头元素与当前时间的差，如果大于0，表示还未到底临界点，因此等待响应时间（使用条件变量available)</li>
<li>如果小于或者等于0，说明已经到底临界点或者已经过了临界点，那么就移除头元素，并且唤醒其它等待任务队列的线程。
  public E take() throws InterruptedException {<pre><code>  final ReentrantLock lock = this.lock;
  lock.lockInterruptibly();
  try {
      for (;;) {
          E first = q.peek();
          if (first == null) {
              available.await();
          } else {
              long delay =  first.getDelay(TimeUnit.NANOSECONDS);
              if (delay &gt; 0) {
                  long tl = available.awaitNanos(delay);
              } else {
                  E x = q.poll();
                  assert x != null;
                  if (q.size() != 0)
                      available.signalAll(); // wake up other takers
                  return x;
              }
          }
      }
  } finally {
      lock.unlock();
  }
</code></pre>  }</li>
</ul>
<p>同样加入元素也会有相应的条件变量操作。当前仅当队列为空或者要加入的元素比队列中的头元素还小的时候才需要唤醒“等待线程”去检测元素。因为头元素都没有唤醒那么比头元素更延迟的元素就更加不会唤醒。</p>
<pre><code>public boolean offer(E e) {
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {
        E first = q.peek();
        q.offer(e);
        if (first == null || e.compareTo(first) &lt; 0)
            available.signalAll();
        return true;
    } finally {
        lock.unlock();
    }
}
</code></pre><p>有了任务队列后再来看Future在ScheduledThreadPoolExecutor中是如何操作的。</p>
<p>java.util.concurrent.ScheduledThreadPoolExecutor.ScheduledFutureTask<V>是继承java.util.concurrent.FutureTask<V>的，区别在于执行任务是否是周期性的。
        private void runPeriodic() {
            boolean ok = ScheduledFutureTask.super.runAndReset();
            boolean down = isShutdown();
            // Reschedule if not cancelled and not shutdown or policy allows
            if (ok &amp;&amp; (!down ||
                       (getContinueExistingPeriodicTasksAfterShutdownPolicy() &amp;&amp;
                        !isStopped()))) {
                long p = period;
                if (p &gt; 0)
                    time += p;
                else
                    time = now() - p;
                ScheduledThreadPoolExecutor.super.getQueue().add(this);
            }
            // This might have been the final executed delayed
            // task.  Wake up threads to check.
            else if (down)
                interruptIdleWorkers();
        }
        //<em>/</em>
         /<em> Overrides FutureTask version so as to reset/requeue if periodic.
         /</em>/
        public void run() {
            if (isPeriodic())
                runPeriodic();
            else
                ScheduledFutureTask.super.run();
        }
    }</p>
<p>如果不是周期性任务调度，那么就和java.util.concurrent.FutureTask.Sync的调度方式是一样的。如果是周期性任务（isPeriodic()）那么就稍微有所不同的。</p>
<p><a href="http://www.blogjava.net/images/blogjava_net/xylz/Windows-Live-Writer/-Java-Concurrency-35--part-8--2_BFEA/ScheduledThreadPoolExecutor-ScheduledFutureTask_4.png" target="_blank"><img src="&quot;ScheduledThreadPoolExecutor-ScheduledFutureTask&quot;" alt="ScheduledThreadPoolExecutor-ScheduledFutureTask"></a></p>
<p>先从功能/结构上分析下。第一种情况假设提交的任务每次执行花费10s，间隔（delay/period)为20s，对于scheduleAtFixedRate而言，每次执行开始时间20s，对于scheduleWithFixedDelay来说每次执行开始时间30s。第二种情况假设提交的任务每次执行时间花费20s，间隔（delay/period)为10s，对于scheduleAtFixedRate而言，每次执行开始时间10s，对于scheduleWithFixedDelay来说每次执行开始时间30s。（具体分析可以参考<a href="http://www.blogjava.net/xylz/archive/2011/01/10/342738.html" target="_blank">这里</a>）</p>
<p>也就是说scheduleWithFixedDelay的执行开始时间为(delay+cost)，而对于scheduleAtFixedRate来说执行开始时间为max(period,cost)。</p>
<p>回头再来看上面源码runPeriodic()就很容易了。但特别要提醒的，如果任务的任何一个执行遇到异常，则后续执行都会被取消，这从runPeriodic()就能看出。要强调的第二点就是<strong>同一个周期性任务不会被同时执行</strong>。就比如说尽管上面第二种情况的scheduleAtFixedRate任务每隔10s执行到达一个时间点，但是由于每次执行时间花费为20s，因此每次执行间隔为20s，只不过执行的任务次数会多一点。但从本质上讲就是每隔20s执行一次，如果任务队列不取消的话。</p>
<p>为什么不会同时执行？</p>
<p>这是因为ScheduledFutureTask执行的时候会将任务从队列中移除来，执行完毕以后才会添加下一个同序列的任务，因此任务队列中其实最多只有同序列的任务的一份副本，所以永远不会同时执行（尽管要执行的时间在过去）。</p>
<p>ScheduledThreadPoolExecutor使用一个无界（容量无限，整数的最大值）的容器（DelayedWorkQueue队列），根据<a href="http://www.blogjava.net/xylz/archive/2011/02/11/344091.html" target="_blank">ThreadPoolExecutor</a>的原理，只要当容器满的时候才会启动一个大于corePoolSize的线程数。因此实际上ScheduledThreadPoolExecutor是一个固定线程大小的线程池，固定大小为corePoolSize，构造函数里面的Integer.MAX_VALUE其实是不生效的（尽管<a href="http://www.blogjava.net/xylz/archive/2010/07/30/327582.html" target="_blank">PriorityQueue</a>使用数组实现有<a href="http://www.blogjava.net/xylz/archive/2010/07/30/327582.html" target="_blank">PriorityQueue</a>大小限制，如果你的任务数超过了2147483647就会导致OutOfMemoryError，这个参考<a href="http://www.blogjava.net/xylz/archive/2010/07/30/327582.html" target="_blank">PriorityQueue</a>的grow方法）。</p>
<p>再回头看scheduleAtFixedRate等方法就容易多了。无非就是往任务队列中添加一个未来某一时刻的ScheduledFutureTask任务，如果是scheduleAtFixedRate那么period/delay就是正数，如果是scheduleWithFixedDelay那么period/delay就是一个负数，如果是0那么就是一次性任务。直接调用父类<a href="http://www.blogjava.net/xylz/archive/2011/02/11/344091.html" target="_blank">ThreadPoolExecutor</a>的execute/submit等方法就相当于period/delay是0，并且initialDelay也是0。
    public ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command,
                                                  long initialDelay,
                                                  long period,
                                                  TimeUnit unit) {
        if (command == null || unit == null)
            throw new NullPointerException();
        if (period &lt;= 0)
            throw new IllegalArgumentException();
        if (initialDelay &lt; 0) initialDelay = 0;
        long triggerTime = now() + unit.toNanos(initialDelay);
        RunnableScheduledFuture&lt;?&gt; t = decorateTask(command,
            new ScheduledFutureTask<Object>(command,
                                            null,
                                            triggerTime,
                                            unit.toNanos(period)));
        delayedExecute(t);
        return t;
    }</p>
<p>另外需要补充说明的一点，前面说过java.util.concurrent.FutureTask.Sync任务只能执行一次，那么在runPeriodic()里面怎么又将执行过的任务加入队列中呢？这是因为java.util.concurrent.FutureTask.Sync提供了一个innerRunAndReset()方法，此方法不仅执行任务还将任务的状态还原成0（初始状态）了，所以此任务就可以重复执行。这就是为什么runPeriodic()里面调用runAndRest()的缘故。</p>
<pre><code>    boolean innerRunAndReset() {
        if (!compareAndSetState(0, RUNNING))
            return false;
        try {
            runner = Thread.currentThread();
            if (getState() == RUNNING)
                callable.call(); // don&#39;t set result
            runner = null;
            return compareAndSetState(RUNNING, 0);
        } catch (Throwable ex) {
            innerSetException(ex);
            return false;
        }
    }
</code></pre><p><strong>后话</strong></p>
<p>整个并发实践原理和实现（源码）上的东西都讲完了，后面几个小节是一些总结和扫尾的工作，包括超时机制、异常处理等一些细节问题。也就是说大部分只需要搬出一些理论和最佳实践知识出来就好了，不会有大量费脑筋的算法分析和原理、思想探讨之类的。后面的章节也会加快一些进度。</p>
<p>老实说从刚开始的好奇到中间的兴奋，再到现在的彻悟，收获还是很多，个人觉得这是最认真、最努力也是自我最满意的一次技术研究和探讨，同时在这个过程中将很多技术细节都串联起来了，慢慢就有了那种技术相通的感觉。原来有了理论以后再去实践、再去分析问题、解决问题和那种纯解决问题得到的经验完全不一样。整个专辑下来不仅仅是并发包这一点点知识，设计到硬件、软件、操作系统、网络、安全、性能、算法、理论等等，总的来说这也算是一次比较成功的研究切入点，这比<a href="http://www.blogjava.net/xylz/archive/2009/12/22/306955.html" target="_blank">Guice</a>那次探讨要深入和持久的多。
来源： <a href="[http://www.blogjava.net/xylz/archive/2011/02/13/344207.html](http://www.blogjava.net/xylz/archive/2011/02/13/344207.html)">[http://www.blogjava.net/xylz/archive/2011/02/13/344207.html](http://www.blogjava.net/xylz/archive/2011/02/13/344207.html)</a> </p>
<p><a href="http://www.blogjava.net/xylz/archive/2011/07/12/354206.html" target="_blank">并发操作异常体系</a> </p>
<p>并发包引入的工具类很多方法都会抛出一定的异常，这些异常描述了任务在线程池中执行时发生的例外情况，而通常这些例外需要应用程序进行捕捉和处理。</p>
<p>例如在Future接口中有如下一个API：</p>
<p>java.util.concurrent.Future.get(long, TimeUnit) throws InterruptedException, ExecutionException, TimeoutException;</p>
<p>在<a href="http://www.blogjava.net/xylz/archive/2011/02/13/344207.html" target="_blank">前面的章节</a>中描述了Future类的具体实现原理。这里不再讨论，但是比较好奇的抛出的三个异常。</p>
<p>这里有一篇文章（<a href="http://www.ibm.com/developerworks/cn/java/j-jtp05236.html" target="_blank">Java 理论与实践: 处理 InterruptedException</a>）描述了InterruptedException的来源和处理方式。简单的说就是线程在执行的过程中被自己或者别人中断了。这时候为了响应中断就需要处理当前的异常。</p>
<p>对于java.lang.Thread而言，InterruptedException也是一个很诡异的问题。</p>
<p>中断一个线程Thread.<strong>interrupt()</strong>时会触发下面一种情况：
如果线程在调用 Object 类的 wait()、wait(long) 或 wait(long, int) 方法，或者该类的 join()、join(long)、join(long, int)、sleep(long) 或 sleep(long, int) 方法过程中受阻，则其中断状态将被清除，它还将收到一个 InterruptedException。</p>
<p>检测一个线程的中断状态描述是这样的Thread.<strong>interrupted()：</strong></p>
<p>测试当前线程是否已经中断。线程的<em>中断状态</em> 由该方法清除。换句话说，如果连续两次调用该方法，则第二次调用将返回 false（在第一次调用已清除了其中断状态之后，且第二次调用检验完中断状态前，当前线程再次中断的情况除外）。 </p>
<p>也就是说如果检测到一个线程已经被中断了，那么线程的使用方（挂起、等待或者正在执行）都将应该得到一个中断异常，同时将会清除异常中断状态。</p>
<p>V innerGet(long nanosTimeout) throws InterruptedException, ExecutionException, TimeoutException {
    if (!tryAcquireSharedNanos(0, nanosTimeout))
        throw new TimeoutException();
    if (getState() == CANCELLED)
        throw new CancellationException();
    if (exception != null)
        throw new ExecutionException(exception);
    return result;
}</p>
<p>上面获取任务结果的方法实现中，将在获取锁的过程中得到一个中断异常。代码java.util.concurrent.locks.AbstractQueuedSynchronizer.tryAcquireSharedNanos(int, long)描述了这种情况：
    public final boolean tryAcquireSharedNanos(int arg, long nanosTimeout) throws InterruptedException {
    if (Thread.interrupted())
        throw new InterruptedException();
    return tryAcquireShared(arg) &gt;= 0 ||
        doAcquireSharedNanos(arg, nanosTimeout);
    }</p>
<p>这里在获取锁的时候检测线程中断情况，如果被中断则清除中断位，同时抛出一个中断异常。为什么如此做？因为我们的线程在线程池中是被重复执行的，所以一旦线程被中断后并不会退出线程，而是设置中断位，等候任务队列自己处理线程，从而达到线程被重复利用的目的。有兴趣的可以参考代码java.util.concurrent.ThreadPoolExecutor.Worker.runTask(Runnable)。这里在关闭线程池时就会导致中断所有线程。</p>
<p>除了InterruptedException 异常我们还发现了一个全新的异常java.util.concurrent.TimeoutException，此异常是用来描述任务执行时间超过了期望等待时间，也许是一直没有获取到锁，也许是还没有执行完成。</p>
<p>在innerGet代码片段中我们看到，如果线程在指定的时间无法获取到锁，那么就会得到一个超时异常。这个很好理解，比如如果执行一个非常耗时的网络任务，我们不希望任务一直等待从而占用大量的资源，可能在一定时间后就会希望取消此操作。此时超时异常很好的描述了这种需求。</p>
<p>与此同时，如果取消了一个任务，那么再次从任务中获取执行结果，那么将会得到一个任务被取消的异常java.util.concurrent.CancellationException。</p>
<p>除了上述异常外，还将得到一个java.util.concurrent.ExecutionException异常，</p>
<p>这是因为我们的提交的任务java.util.concurrent.Callable在call()方法中允许抛出任何异常，另外常规的线程执行也可能抛出一个RuntimeException，所以这里简单包装了下所有异常，当作执行过程中发生的异常ExecutionException抛出。</p>
<p>以上就是整个异常体系，所有并发操作的异常都可以归结于上述几类。</p>
<p>很多情况下处理时间长度都是用<strong>java.util.concurrent.TimeUnit</strong>，这是一个枚举类型，用来描述时间长度。其中内置了一些长度的单位。其中包括纳秒、微秒、毫秒、秒、分、时、天。例如超时操作5秒，可以使用</p>
<p>Future.get(5,TimeUnit.SECONDS) 或者 Future.get(5000L,TimeUnit.MILLISECONDS)</p>
<p>当然一种单位的时间转换成另一种单位的时间也是非常方便的。另外还有线程的sleep/join以及对象的wait操作的便捷操作。
来源： <a href="[http://www.blogjava.net/xylz/archive/2011/07/12/354206.html](http://www.blogjava.net/xylz/archive/2011/07/12/354206.html)">[http://www.blogjava.net/xylz/archive/2011/07/12/354206.html](http://www.blogjava.net/xylz/archive/2011/07/12/354206.html)</a> </p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/Java_多线程/">Java_多线程</a></li><li><a href="/categories/Java&J2EE/Java_多线程/并发/">并发</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/Java_多线程/" class="label label-success">Java_多线程</a><a href="/tags/并发/" class="label label-info">并发</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:41"datetime="2014-03-07 09:54:41"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-Java_多线程-并发--深入浅出JavaConcurrency28-线程池/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-Java_多线程-并发--深入浅出JavaConcurrency28-线程池" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-SQL_Java--SQL解析Jsqlparser/">SQL解析(Jsqlparser)</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:41.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-SQL_Java--SQL解析Jsqlparser/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="sql-jsqlparser-">SQL解析(Jsqlparser)</h1>
<p>前段时间主要研究了一下SQL语句的解析，主要的几个开源产品试用了一下。本文大概总结一下个人体会。
首先是ZQL，ZQL有个比较突出的优点是使用起来比较简单，基本上属于拿上手就可以用的。但支持的功能有限，selectItem可以是简单的表达式，但不支持查询作为一个selectItem，对于其他的子查询同样也不支持。
最终我选择使用了Jsqlparser，主要原因有两点：
1）功能强大，基本上能够覆盖所有的SQL语法（没有研究是不是包含了数据库特殊的关键字，如LIMIT ），包含UNION,GROUP BY,HAVING,ORDER BY,JOIN,SUB JOIN,SUB SELECT,FUNCTION等。支持SQL深层嵌套。
2）本身设计不错，使用起来感觉很灵活。Jsqlparser对于SQL的遍历采用了VISITOR模式可以很方便的遍历SQL语句。
下面主要介绍一下Jsqlparser在我的项目中的应用情况。
背景：通过SQL语句的解析，从而增强SQL语句增加特定的查询过滤条件（如：状态过滤、权限过滤等）
1）解析SQL
2）根据SQL中涉及的表增强SQL
3）重新生成ORACLE数据库的SQL
Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>CCJSqlParserManager parserManager = new CCJSqlParserManager();  </li>
<li>try {  </li>
<li>Select select = (Select) parserManager.parse(new StringReader(sql)); //解析SQL语句  </li>
<li>SelectBody body = select.getSelectBody();   </li>
<li>VisitContext vc = new VisitContext(filterContext, params);  </li>
<li>vc.setTableFilterFactory(tableFilterFactory);//表的字段过滤  </li>
<li>body.accept(new SelectVisitorImpl(vc)); //访问SQL并根据SQL中涉及的表来增强SQL  </li>
<li>ExpressionDeParser expressionDeParser = new ExpressionDeParser();  </li>
<li>StringBuffer stringBuffer = new StringBuffer();  </li>
<li>SelectDeParser deParser = new OracleSelectDeParser(expressionDeParser, stringBuffer); //针对ORACLE的SQL生成  </li>
<li>expressionDeParser.setSelectVisitor(deParser);  </li>
<li>expressionDeParser.setBuffer(stringBuffer);  </li>
<li></li>
<li>body.accept(deParser);  </li>
<li>return new FilterResult(deParser.getBuffer().toString(), vc.getResultSqlParams());  </li>
<li>} catch (JSQLParserException e) {  </li>
<li>throw new FilterException(e);  </li>
<li><p>}  </p>
<pre><code> CCJSqlParserManager parserManager = new CCJSqlParserManager();

 try {
     Select select = (Select) parserManager.parse(new StringReader(sql)); //解析SQL语句

     SelectBody body = select.getSelectBody();
     VisitContext vc = new VisitContext(filterContext, params);

     vc.setTableFilterFactory(tableFilterFactory);//表的字段过滤
     body.accept(new SelectVisitorImpl(vc)); //访问SQL并根据SQL中涉及的表来增强SQL

     ExpressionDeParser expressionDeParser = new ExpressionDeParser();
     StringBuffer stringBuffer = new StringBuffer();

     SelectDeParser deParser = new OracleSelectDeParser(expressionDeParser, stringBuffer); //针对ORACLE的SQL生成
     expressionDeParser.setSelectVisitor(deParser);

     expressionDeParser.setBuffer(stringBuffer);
</code></pre></li>
</ol>
<pre><code>        body.accept(deParser);
        return new FilterResult(deParser.getBuffer().toString(), vc.getResultSqlParams());

    } catch (JSQLParserException e) {
        throw new FilterException(e);

    }
</code></pre><p>接下去是各个VISITOR，用来访问解析后的SQL
Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>public class SelectVisitorImpl extends AbstractVisitor implements SelectVisitor {  </li>
<li></li>
<li>public SelectVisitorImpl(VisitContext ctx) {  </li>
<li>super(ctx);  </li>
<li>}  </li>
<li></li>
<li>@SuppressWarnings(&quot;unchecked&quot;)  </li>
<li>public void visit(PlainSelect ps) {  </li>
<li>//SELECT ITEM访问  </li>
<li>List<SelectItem> selectItems = ps.getSelectItems();  </li>
<li>for (SelectItem item : selectItems) {  </li>
<li>item.accept(new SelectItemVisitorImpl(this.getContext()));  </li>
<li>}  </li>
<li></li>
<li>//FROM访问  </li>
<li>FromItem from = ps.getFromItem();  </li>
<li>FromItemVisitorImpl fv = new FromItemVisitorImpl(context);  </li>
<li>from.accept(fv);  </li>
<li></li>
<li>//查询条件访问  </li>
<li>if (ps.getWhere() != null) {  </li>
<li>ps.getWhere().accept(new ExpressionVisitorImpl(this.getContext()));  </li>
<li>}  </li>
<li></li>
<li>//过滤增强的条件  </li>
<li>if (fv.getEnhancedCondition() != null) {  </li>
<li>if (ps.getWhere() != null) {  </li>
<li>Expression expr = new Parenthesis(ps.getWhere());  </li>
<li>AndExpression and = new AndExpression(fv.getEnhancedCondition(), expr);  </li>
<li>ps.setWhere(and);  </li>
<li>} else {  </li>
<li>ps.setWhere(fv.getEnhancedCondition());  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>//JOIN表的访问  </li>
<li>List<Join> joins = ps.getJoins();  </li>
<li>if (CollectionUtil.isNotEmpty(joins)) {  </li>
<li>for (Join join : joins) {  </li>
<li>FromItemVisitorImpl tempfv = new FromItemVisitorImpl(context);  </li>
<li>join.getRightItem().accept(tempfv);  </li>
<li>if (join.getOnExpression() != null) {  </li>
<li>join.getOnExpression().accept(new ExpressionVisitorImpl(this.getContext()));  </li>
<li>if (tempfv.getEnhancedCondition() != null) {  </li>
<li>Expression expr = new Parenthesis(join.getOnExpression());  </li>
<li>AndExpression and = new AndExpression(tempfv.getEnhancedCondition(), expr);  </li>
<li>join.setOnExpression(and);  </li>
<li>}  </li>
<li>}  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>//ORDER BY 访问  </li>
<li>List<OrderByElement> elements = ps.getOrderByElements();  </li>
<li>if (CollectionUtil.isNotEmpty(elements)) {  </li>
<li>for (OrderByElement e : elements) {  </li>
<li>e.getExpression().accept(new ExpressionVisitorImpl(this.getContext()));  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>//GROUP BY的HAVING访问  </li>
<li>if (ps.getHaving() != null) {  </li>
<li>ps.getHaving().accept(new ExpressionVisitorImpl(this.getContext()));  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>@SuppressWarnings(&quot;unchecked&quot;)  </li>
<li>public void visit(Union un) {  </li>
<li>List<PlainSelect> selects = un.getPlainSelects();  </li>
<li>for (PlainSelect select : selects) {  </li>
<li>select.accept(new SelectVisitorImpl(this.getContext()));  </li>
<li>}  </li>
<li>List<OrderByElement> elements = un.getOrderByElements();  </li>
<li>if (CollectionUtil.isNotEmpty(elements)) {  </li>
<li>for (OrderByElement e : elements) {  </li>
<li>e.getExpression().accept(new ExpressionVisitorImpl(this.getContext()));  </li>
<li>}  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>}  </li>
</ol>
<p>public class SelectVisitorImpl extends AbstractVisitor implements SelectVisitor {</p>
<pre><code>public SelectVisitorImpl(VisitContext ctx) {

    super(ctx);
}


@SuppressWarnings(&quot;unchecked&quot;)

public void visit(PlainSelect ps) {
    //SELECT ITEM访问

    List&lt;SelectItem&gt; selectItems = ps.getSelectItems();
    for (SelectItem item : selectItems) {

        item.accept(new SelectItemVisitorImpl(this.getContext()));
    }


    //FROM访问

    FromItem from = ps.getFromItem();
    FromItemVisitorImpl fv = new FromItemVisitorImpl(context);

    from.accept(fv);


    //查询条件访问
    if (ps.getWhere() != null) {

        ps.getWhere().accept(new ExpressionVisitorImpl(this.getContext()));
    }


    //过滤增强的条件

    if (fv.getEnhancedCondition() != null) {
        if (ps.getWhere() != null) {

            Expression expr = new Parenthesis(ps.getWhere());
            AndExpression and = new AndExpression(fv.getEnhancedCondition(), expr);

            ps.setWhere(and);
        } else {

            ps.setWhere(fv.getEnhancedCondition());
        }

    }


    //JOIN表的访问
    List&lt;Join&gt; joins = ps.getJoins();

    if (CollectionUtil.isNotEmpty(joins)) {
        for (Join join : joins) {

            FromItemVisitorImpl tempfv = new FromItemVisitorImpl(context);
            join.getRightItem().accept(tempfv);

            if (join.getOnExpression() != null) {
                join.getOnExpression().accept(new ExpressionVisitorImpl(this.getContext()));

                if (tempfv.getEnhancedCondition() != null) {
                    Expression expr = new Parenthesis(join.getOnExpression());

                    AndExpression and = new AndExpression(tempfv.getEnhancedCondition(), expr);
                    join.setOnExpression(and);

                }
            }

        }
    }


    //ORDER BY 访问

    List&lt;OrderByElement&gt; elements = ps.getOrderByElements();
    if (CollectionUtil.isNotEmpty(elements)) {

        for (OrderByElement e : elements) {
            e.getExpression().accept(new ExpressionVisitorImpl(this.getContext()));

        }
    }


    //GROUP BY的HAVING访问

    if (ps.getHaving() != null) {
        ps.getHaving().accept(new ExpressionVisitorImpl(this.getContext()));

    }
}


@SuppressWarnings(&quot;unchecked&quot;)

public void visit(Union un) {
    List&lt;PlainSelect&gt; selects = un.getPlainSelects();

    for (PlainSelect select : selects) {
        select.accept(new SelectVisitorImpl(this.getContext()));

    }
    List&lt;OrderByElement&gt; elements = un.getOrderByElements();

    if (CollectionUtil.isNotEmpty(elements)) {
        for (OrderByElement e : elements) {

            e.getExpression().accept(new ExpressionVisitorImpl(this.getContext()));
        }

    }
}
</code></pre><p>}
Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>public class SelectItemVisitorImpl extends AbstractVisitor implements SelectItemVisitor {  </li>
<li></li>
<li>public SelectItemVisitorImpl(VisitContext ctx) {  </li>
<li>super(ctx);  </li>
<li>}  </li>
<li></li>
<li>public void visit(AllColumns ac) {  </li>
<li>}  </li>
<li></li>
<li>public void visit(AllTableColumns atc) {  </li>
<li>}  </li>
<li></li>
<li>public void visit(SelectExpressionItem sei) {  </li>
<li>sei.getExpression().accept(new ExpressionVisitorImpl(this.getContext()));  </li>
<li>}  </li>
<li></li>
<li>}  </li>
</ol>
<p>public class SelectItemVisitorImpl extends AbstractVisitor implements SelectItemVisitor {</p>
<pre><code>public SelectItemVisitorImpl(VisitContext ctx) {

    super(ctx);
}


public void visit(AllColumns ac) {

}


public void visit(AllTableColumns atc) {
}


public void visit(SelectExpressionItem sei) {

    sei.getExpression().accept(new ExpressionVisitorImpl(this.getContext()));
}
</code></pre><p>}
Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>public class ItemsListVisitorImpl extends AbstractVisitor implements ItemsListVisitor {  </li>
<li></li>
<li>public ItemsListVisitorImpl(VisitContext ctx) {  </li>
<li>super(ctx);  </li>
<li>}  </li>
<li></li>
<li>public void visit(SubSelect ss) {  </li>
<li>ss.getSelectBody().accept(new SelectVisitorImpl(context));  </li>
<li>}  </li>
<li></li>
<li>@SuppressWarnings(&quot;unchecked&quot;)  </li>
<li>public void visit(ExpressionList el) {  </li>
<li>List<Expression> list = el.getExpressions();  </li>
<li>if (CollectionUtil.isNotEmpty(list)) {  </li>
<li>for (Expression expr : list) {  </li>
<li>expr.accept(new ExpressionVisitorImpl(context));  </li>
<li>}  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>}  </li>
</ol>
<p>public class ItemsListVisitorImpl extends AbstractVisitor implements ItemsListVisitor {</p>
<pre><code>public ItemsListVisitorImpl(VisitContext ctx) {

    super(ctx);
}


public void visit(SubSelect ss) {

    ss.getSelectBody().accept(new SelectVisitorImpl(context));
}


@SuppressWarnings(&quot;unchecked&quot;)

public void visit(ExpressionList el) {
    List&lt;Expression&gt; list = el.getExpressions();

    if (CollectionUtil.isNotEmpty(list)) {
        for (Expression expr : list) {

            expr.accept(new ExpressionVisitorImpl(context));
        }

    }
}
</code></pre><p>}
如果FROM的内容是table的话，则根据table的增强配置对SQL增强
Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>public class FromItemVisitorImpl extends AbstractVisitor implements FromItemVisitor {  </li>
<li>private String varPattern = &quot;@\{\s/<em>?(\w+)\s/</em>?\}&quot;;  </li>
<li>private Expression enhancedCondition;  </li>
<li></li>
<li>public FromItemVisitorImpl(VisitContext ctx) {  </li>
<li>super(ctx);  </li>
<li>}  </li>
<li></li>
<li>public void visit(Table table) {  </li>
<li>Set<FieldFilter> filters = context.getTableFilterFactory().getTableFilter(table.getName());  </li>
<li>if (filters == null) {  </li>
<li>filters = Collections.emptySet();  </li>
<li>}  </li>
<li>for (FieldFilter ff : filters) {  </li>
<li>Column c = new Column(new Table(null, table.getAlias()), ff.getFieldName());  </li>
<li>JdbcParameter param = new JdbcParameter();  </li>
<li>Object fieldValue = getRawValue(ff.getFieldValue(), this.context.getFilterContext());  </li>
<li>Expression[] exps;  </li>
<li>if (&quot;between&quot;.equalsIgnoreCase(ff.getOperator()) || &quot;not between&quot;.equalsIgnoreCase(ff.getOperator())) {  </li>
<li>Object[] objs = (Object[]) fieldValue;  </li>
<li>this.getContext().getResultSqlParams().add(objs[0]);  </li>
<li>this.getContext().getResultSqlParams().add(objs[1]);  </li>
<li>exps = new Expression[] { c, param, param };  </li>
<li>} else if (&quot;is null&quot;.equalsIgnoreCase(ff.getOperator()) || &quot;is not null&quot;.equalsIgnoreCase(ff.getOperator())) {  </li>
<li>exps = new Expression[] { c };  </li>
<li>} else {  </li>
<li>this.getContext().getResultSqlParams().add(fieldValue);  </li>
<li>exps = new Expression[] { c, param };  </li>
<li>}  </li>
<li>Expression operator = this.getOperator(ff.getOperator(), exps);  </li>
<li>if (this.enhancedCondition != null) {  </li>
<li>enhancedCondition = new AndExpression(enhancedCondition, operator);  </li>
<li>} else {  </li>
<li>enhancedCondition = operator;  </li>
<li>}  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>public void visit(SubSelect ss) {  </li>
<li>ss.getSelectBody().accept(new SelectVisitorImpl(this.getContext()));  </li>
<li>}  </li>
<li></li>
<li>public void visit(SubJoin sj) {  </li>
<li>Join join = sj.getJoin();  </li>
<li>join.getRightItem().accept(new FromItemVisitorImpl(this.getContext()));  </li>
<li>join.getOnExpression().accept(new ExpressionVisitorImpl(this.getContext()));  </li>
<li>}  </li>
<li></li>
<li>private Expression getOperator(String op, Expression[] exp) {  </li>
<li>if (&quot;=&quot;.equals(op)) {  </li>
<li>EqualsTo eq = new EqualsTo();  </li>
<li>eq.setLeftExpression(exp[0]);  </li>
<li>eq.setRightExpression(exp[1]);  </li>
<li>return eq;  </li>
<li>} else if (&quot;&gt;&quot;.equals(op)) {  </li>
<li>GreaterThan gt = new GreaterThan();  </li>
<li>gt.setLeftExpression(exp[0]);  </li>
<li>gt.setRightExpression(exp[1]);  </li>
<li>return gt;  </li>
<li>} else if (&quot;&gt;=&quot;.equals(op)) {  </li>
<li>GreaterThanEquals geq = new GreaterThanEquals();  </li>
<li>geq.setLeftExpression(exp[0]);  </li>
<li>geq.setRightExpression(exp[1]);  </li>
<li>return geq;  </li>
<li>} else if (&quot;&lt;&quot;.equals(op)) {  </li>
<li>MinorThan mt = new MinorThan();  </li>
<li>mt.setLeftExpression(exp[0]);  </li>
<li>mt.setRightExpression(exp[1]);  </li>
<li>return mt;  </li>
<li>} else if (&quot;&lt;=&quot;.equals(op)) {  </li>
<li>MinorThanEquals leq = new MinorThanEquals();  </li>
<li>leq.setLeftExpression(exp[0]);  </li>
<li>leq.setRightExpression(exp[1]);  </li>
<li>return leq;  </li>
<li>} else if (&quot;&lt;&gt;&quot;.equals(op)) {  </li>
<li>NotEqualsTo neq = new NotEqualsTo();  </li>
<li>neq.setLeftExpression(exp[0]);  </li>
<li>neq.setRightExpression(exp[1]);  </li>
<li>return neq;  </li>
<li>} else if (&quot;is null&quot;.equalsIgnoreCase(op)) {  </li>
<li>IsNullExpression isNull = new IsNullExpression();  </li>
<li>isNull.setNot(false);  </li>
<li>isNull.setLeftExpression(exp[0]);  </li>
<li>return isNull;  </li>
<li>} else if (&quot;is not null&quot;.equalsIgnoreCase(op)) {  </li>
<li>IsNullExpression isNull = new IsNullExpression();  </li>
<li>isNull.setNot(true);  </li>
<li>isNull.setLeftExpression(exp[0]);  </li>
<li>return isNull;  </li>
<li>} else if (&quot;like&quot;.equalsIgnoreCase(op)) {  </li>
<li>LikeExpression like = new LikeExpression();  </li>
<li>like.setNot(false);  </li>
<li>like.setLeftExpression(exp[0]);  </li>
<li>like.setRightExpression(exp[1]);  </li>
<li>return like;  </li>
<li>} else if (&quot;not like&quot;.equalsIgnoreCase(op)) {  </li>
<li>LikeExpression nlike = new LikeExpression();  </li>
<li>nlike.setNot(true);  </li>
<li>nlike.setLeftExpression(exp[0]);  </li>
<li>nlike.setRightExpression(exp[1]);  </li>
<li>return nlike;  </li>
<li>} else if (&quot;between&quot;.equalsIgnoreCase(op)) {  </li>
<li>Between bt = new Between();  </li>
<li>bt.setNot(false);  </li>
<li>bt.setLeftExpression(exp[0]);  </li>
<li>bt.setBetweenExpressionStart(exp[1]);  </li>
<li>bt.setBetweenExpressionEnd(exp[2]);  </li>
<li>return bt;  </li>
<li>} else if (&quot;not between&quot;.equalsIgnoreCase(op)) {  </li>
<li>Between bt = new Between();  </li>
<li>bt.setNot(true);  </li>
<li>bt.setLeftExpression(exp[0]);  </li>
<li>bt.setBetweenExpressionStart(exp[1]);  </li>
<li>bt.setBetweenExpressionEnd(exp[2]);  </li>
<li>return bt;  </li>
<li>}  </li>
<li>throw new FilterException(&quot;Unknown operator:&quot; + op);  </li>
<li>}  </li>
<li></li>
<li>protected Object getRawValue(Object value, Map<String, Object> context) {  </li>
<li>if (context == null) {  </li>
<li>return value;  </li>
<li>}  </li>
<li>if (value instanceof String) {  </li>
<li>String v = (String) value;  </li>
<li>Pattern pattern = Pattern.compile(varPattern);  </li>
<li>Matcher matcher = pattern.matcher(v);  </li>
<li>if (matcher.find()) {  </li>
<li>return context.get(matcher.group(1));  </li>
<li>}  </li>
<li>}  </li>
<li>return value;  </li>
<li>}  </li>
<li></li>
<li>public Expression getEnhancedCondition() {  </li>
<li>return enhancedCondition;  </li>
<li>}  </li>
<li></li>
<li>}  </li>
</ol>
<p>public class FromItemVisitorImpl extends AbstractVisitor implements FromItemVisitor {</p>
<pre><code>private String varPattern = &quot;@\\{\\s/*?(\\w+)\\s/*?\\}&quot;;
private Expression enhancedCondition;


public FromItemVisitorImpl(VisitContext ctx) {

    super(ctx);
}


public void visit(Table table) {

    Set&lt;FieldFilter&gt; filters = context.getTableFilterFactory().getTableFilter(table.getName());
    if (filters == null) {

        filters = Collections.emptySet();
    }

    for (FieldFilter ff : filters) {
        Column c = new Column(new Table(null, table.getAlias()), ff.getFieldName());

        JdbcParameter param = new JdbcParameter();
        Object fieldValue = getRawValue(ff.getFieldValue(), this.context.getFilterContext());

        Expression[] exps;
        if (&quot;between&quot;.equalsIgnoreCase(ff.getOperator()) || &quot;not between&quot;.equalsIgnoreCase(ff.getOperator())) {

            Object[] objs = (Object[]) fieldValue;
            this.getContext().getResultSqlParams().add(objs[0]);

            this.getContext().getResultSqlParams().add(objs[1]);
            exps = new Expression[] { c, param, param };

        } else if (&quot;is null&quot;.equalsIgnoreCase(ff.getOperator()) || &quot;is not null&quot;.equalsIgnoreCase(ff.getOperator())) {
            exps = new Expression[] { c };

        } else {
            this.getContext().getResultSqlParams().add(fieldValue);

            exps = new Expression[] { c, param };
        }

        Expression operator = this.getOperator(ff.getOperator(), exps);
        if (this.enhancedCondition != null) {

            enhancedCondition = new AndExpression(enhancedCondition, operator);
        } else {

            enhancedCondition = operator;
        }

    }
}


public void visit(SubSelect ss) {

    ss.getSelectBody().accept(new SelectVisitorImpl(this.getContext()));
}


public void visit(SubJoin sj) {

    Join join = sj.getJoin();
    join.getRightItem().accept(new FromItemVisitorImpl(this.getContext()));

    join.getOnExpression().accept(new ExpressionVisitorImpl(this.getContext()));
}


private Expression getOperator(String op, Expression[] exp) {

    if (&quot;=&quot;.equals(op)) {
        EqualsTo eq = new EqualsTo();

        eq.setLeftExpression(exp[0]);
        eq.setRightExpression(exp[1]);

        return eq;
    } else if (&quot;&gt;&quot;.equals(op)) {

        GreaterThan gt = new GreaterThan();
        gt.setLeftExpression(exp[0]);

        gt.setRightExpression(exp[1]);
        return gt;

    } else if (&quot;&gt;=&quot;.equals(op)) {
        GreaterThanEquals geq = new GreaterThanEquals();

        geq.setLeftExpression(exp[0]);
        geq.setRightExpression(exp[1]);

        return geq;
    } else if (&quot;&lt;&quot;.equals(op)) {

        MinorThan mt = new MinorThan();
        mt.setLeftExpression(exp[0]);

        mt.setRightExpression(exp[1]);
        return mt;

    } else if (&quot;&lt;=&quot;.equals(op)) {
        MinorThanEquals leq = new MinorThanEquals();

        leq.setLeftExpression(exp[0]);
        leq.setRightExpression(exp[1]);

        return leq;
    } else if (&quot;&lt;&gt;&quot;.equals(op)) {

        NotEqualsTo neq = new NotEqualsTo();
        neq.setLeftExpression(exp[0]);

        neq.setRightExpression(exp[1]);
        return neq;

    } else if (&quot;is null&quot;.equalsIgnoreCase(op)) {
        IsNullExpression isNull = new IsNullExpression();

        isNull.setNot(false);
        isNull.setLeftExpression(exp[0]);

        return isNull;
    } else if (&quot;is not null&quot;.equalsIgnoreCase(op)) {

        IsNullExpression isNull = new IsNullExpression();
        isNull.setNot(true);

        isNull.setLeftExpression(exp[0]);
        return isNull;

    } else if (&quot;like&quot;.equalsIgnoreCase(op)) {
        LikeExpression like = new LikeExpression();

        like.setNot(false);
        like.setLeftExpression(exp[0]);

        like.setRightExpression(exp[1]);
        return like;

    } else if (&quot;not like&quot;.equalsIgnoreCase(op)) {
        LikeExpression nlike = new LikeExpression();

        nlike.setNot(true);
        nlike.setLeftExpression(exp[0]);

        nlike.setRightExpression(exp[1]);
        return nlike;

    } else if (&quot;between&quot;.equalsIgnoreCase(op)) {
        Between bt = new Between();

        bt.setNot(false);
        bt.setLeftExpression(exp[0]);

        bt.setBetweenExpressionStart(exp[1]);
        bt.setBetweenExpressionEnd(exp[2]);

        return bt;
    } else if (&quot;not between&quot;.equalsIgnoreCase(op)) {

        Between bt = new Between();
        bt.setNot(true);

        bt.setLeftExpression(exp[0]);
        bt.setBetweenExpressionStart(exp[1]);

        bt.setBetweenExpressionEnd(exp[2]);
        return bt;

    }
    throw new FilterException(&quot;Unknown operator:&quot; + op);

}


protected Object getRawValue(Object value, Map&lt;String, Object&gt; context) {
    if (context == null) {

        return value;
    }

    if (value instanceof String) {
        String v = (String) value;

        Pattern pattern = Pattern.compile(varPattern);
        Matcher matcher = pattern.matcher(v);

        if (matcher.find()) {
            return context.get(matcher.group(1));

        }
    }

    return value;
}


public Expression getEnhancedCondition() {

    return enhancedCondition;
}
</code></pre><p>}
1）对JDBC parameter做了处理，如果参数为NULL则自动忽略该parameter，忽略后需要处理and or between 等情况
   如：where name=? and age=? ，假如name对应的参数为null，则条件改为where 1=1 and age=?，如果是or的话则改为 where 1=0 or age=?
Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>public class ExpressionVisitorImpl extends AbstractVisitor implements ExpressionVisitor {  </li>
<li></li>
<li>public ExpressionVisitorImpl(VisitContext ctx) {  </li>
<li>super(ctx);  </li>
<li>}  </li>
<li></li>
<li>public void visit(NullValue nv) {  </li>
<li>}  </li>
<li></li>
<li>public void visit(Function f) {  </li>
<li>}  </li>
<li></li>
<li>public void visit(InverseExpression ie) {  </li>
<li>}  </li>
<li></li>
<li>public void visit(JdbcParameter jp) {  </li>
<li>this.getContext().getResultSqlParams().add(context.removeFirstParam());  </li>
<li>}  </li>
<li></li>
<li>public void visit(DoubleValue dv) {  </li>
<li>}  </li>
<li></li>
<li>public void visit(LongValue lv) {  </li>
<li>}  </li>
<li></li>
<li>public void visit(DateValue dv) {  </li>
<li>}  </li>
<li></li>
<li>public void visit(TimeValue tv) {  </li>
<li>}  </li>
<li></li>
<li>public void visit(TimestampValue tv) {  </li>
<li>}  </li>
<li></li>
<li>public void visit(Parenthesis parenthesis) {  </li>
<li>ExpressionVisitorImpl ev = new ExpressionVisitorImpl(context);  </li>
<li>parenthesis.getExpression().accept(ev);  </li>
<li>if (ev.isNotValid()) {  </li>
<li>parenthesis.setExpression(this.createTrueEquals());  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>public void visit(StringValue s) {  </li>
<li>}  </li>
<li></li>
<li>public void visit(Addition a) {  </li>
<li>}  </li>
<li></li>
<li>public void visit(Division d) {  </li>
<li>}  </li>
<li></li>
<li>public void visit(Multiplication m) {  </li>
<li>}  </li>
<li></li>
<li>public void visit(Subtraction s) {  </li>
<li>}  </li>
<li></li>
<li>public void visit(AndExpression and) {  </li>
<li>ExpressionVisitorImpl left = new ExpressionVisitorImpl(this.getContext());  </li>
<li>and.getLeftExpression().accept(left);  </li>
<li>if (left.isNotValid()) {  </li>
<li>and.setLeftExpression(this.createTrueEquals());  </li>
<li>}  </li>
<li>ExpressionVisitorImpl right = new ExpressionVisitorImpl(this.getContext());  </li>
<li>and.getRightExpression().accept(right);  </li>
<li>if (right.isNotValid()) {  </li>
<li>and.setRightExpression(this.createTrueEquals());  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>public void visit(OrExpression or) {  </li>
<li>ExpressionVisitorImpl left = new ExpressionVisitorImpl(this.getContext());  </li>
<li>or.getLeftExpression().accept(left);  </li>
<li>if (left.isNotValid()) {  </li>
<li>or.setLeftExpression(this.createFalseEquals());  </li>
<li>}  </li>
<li>ExpressionVisitorImpl right = new ExpressionVisitorImpl(this.getContext());  </li>
<li>or.getRightExpression().accept(right);  </li>
<li>if (right.isNotValid()) {  </li>
<li>or.setRightExpression(this.createFalseEquals());  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>public void visit(Between btw) {  </li>
<li>Expression start = btw.getBetweenExpressionStart();  </li>
<li>Expression end = btw.getBetweenExpressionEnd();  </li>
<li>if (start instanceof JdbcParameter &amp;&amp; end instanceof JdbcParameter) {  </li>
<li>Object o1 = this.context.getFirstParam();  </li>
<li>Object o2 = this.context.getParam(1);  </li>
<li>if (o1 == null || o2 == null) {  </li>
<li>this.context.removeFirstParam();  </li>
<li>this.context.removeFirstParam();  </li>
<li>this.setValid(false);  </li>
<li>return;  </li>
<li>}  </li>
<li>} else if (start instanceof JdbcParameter || end instanceof JdbcParameter) {  </li>
<li>Object o1 = this.context.getFirstParam();  </li>
<li>if (o1 == null) {  </li>
<li>this.context.removeFirstParam();  </li>
<li>this.setValid(false);  </li>
<li>return;  </li>
<li>}  </li>
<li>}  </li>
<li>btw.getLeftExpression().accept(new ExpressionVisitorImpl(context));  </li>
<li>btw.getBetweenExpressionStart().accept(new ExpressionVisitorImpl(context));  </li>
<li>btw.getBetweenExpressionEnd().accept(new ExpressionVisitorImpl(context));  </li>
<li>}  </li>
<li></li>
<li>public void visit(EqualsTo eq) {  </li>
<li>if (eq.getRightExpression() instanceof JdbcParameter) {  </li>
<li>Object o = this.context.getFirstParam();  </li>
<li>if (o == null) {  </li>
<li>this.setValid(false);  </li>
<li>this.getContext().removeFirstParam();  </li>
<li>return;  </li>
<li>}  </li>
<li>}  </li>
<li>eq.getLeftExpression().accept(new ExpressionVisitorImpl(this.getContext()));  </li>
<li>eq.getRightExpression().accept(new ExpressionVisitorImpl(this.getContext()));  </li>
<li>}  </li>
<li></li>
<li>public void visit(GreaterThan gt) {  </li>
<li>if (gt.getRightExpression() instanceof JdbcParameter) {  </li>
<li>Object o = this.context.getFirstParam();  </li>
<li>if (o == null) {  </li>
<li>this.setValid(false);  </li>
<li>this.getContext().removeFirstParam();  </li>
<li>}  </li>
<li>}  </li>
<li>gt.getLeftExpression().accept(new ExpressionVisitorImpl(this.getContext()));  </li>
<li>gt.getRightExpression().accept(new ExpressionVisitorImpl(this.getContext()));  </li>
<li>}  </li>
<li></li>
<li>public void visit(GreaterThanEquals gte) {  </li>
<li>if (gte.getRightExpression() instanceof JdbcParameter) {  </li>
<li>Object o = this.context.getFirstParam();  </li>
<li>if (o == null) {  </li>
<li>this.setValid(false);  </li>
<li>this.getContext().removeFirstParam();  </li>
<li>}  </li>
<li>}  </li>
<li>gte.getLeftExpression().accept(new ExpressionVisitorImpl(this.getContext()));  </li>
<li>gte.getRightExpression().accept(new ExpressionVisitorImpl(this.getContext()));  </li>
<li>}  </li>
<li></li>
<li>public void visit(InExpression in) {  </li>
<li>ItemsList list = in.getItemsList();  </li>
<li>list.accept(new ItemsListVisitorImpl(context));  </li>
<li>}  </li>
<li></li>
<li>public void visit(IsNullExpression ine) {  </li>
<li>}  </li>
<li></li>
<li>public void visit(LikeExpression le) {  </li>
<li>if (le.getRightExpression() instanceof JdbcParameter) {  </li>
<li>Object o = this.context.getFirstParam();  </li>
<li>if (o == null) {  </li>
<li>this.setValid(false);  </li>
<li>this.getContext().removeFirstParam();  </li>
<li>}  </li>
<li>}  </li>
<li>le.getLeftExpression().accept(new ExpressionVisitorImpl(this.getContext()));  </li>
<li>le.getRightExpression().accept(new ExpressionVisitorImpl(this.getContext()));  </li>
<li>}  </li>
<li></li>
<li>public void visit(MinorThan mt) {  </li>
<li>if (mt.getRightExpression() instanceof JdbcParameter) {  </li>
<li>Object o = this.context.getFirstParam();  </li>
<li>if (o == null) {  </li>
<li>this.setValid(false);  </li>
<li>this.getContext().removeFirstParam();  </li>
<li>}  </li>
<li>}  </li>
<li>mt.getLeftExpression().accept(new ExpressionVisitorImpl(this.getContext()));  </li>
<li>mt.getRightExpression().accept(new ExpressionVisitorImpl(this.getContext()));  </li>
<li>}  </li>
<li></li>
<li>public void visit(MinorThanEquals mte) {  </li>
<li>if (mte.getRightExpression() instanceof JdbcParameter) {  </li>
<li>Object o = this.context.getFirstParam();  </li>
<li>if (o == null) {  </li>
<li>this.setValid(false);  </li>
<li>this.getContext().removeFirstParam();  </li>
<li>}  </li>
<li>}  </li>
<li>mte.getLeftExpression().accept(new ExpressionVisitorImpl(this.getContext()));  </li>
<li>mte.getRightExpression().accept(new ExpressionVisitorImpl(this.getContext()));  </li>
<li>}  </li>
<li></li>
<li>public void visit(NotEqualsTo neq) {  </li>
<li>if (neq.getRightExpression() instanceof JdbcParameter) {  </li>
<li>Object o = this.context.getFirstParam();  </li>
<li>if (o == null) {  </li>
<li>this.setValid(false);  </li>
<li>this.getContext().removeFirstParam();  </li>
<li>return;  </li>
<li>}  </li>
<li>}  </li>
<li>neq.getLeftExpression().accept(new ExpressionVisitorImpl(this.getContext()));  </li>
<li>neq.getRightExpression().accept(new ExpressionVisitorImpl(this.getContext()));  </li>
<li>}  </li>
<li></li>
<li>public void visit(Column c) {  </li>
<li>}  </li>
<li></li>
<li>public void visit(SubSelect ss) {  </li>
<li>ss.getSelectBody().accept(new SelectVisitorImpl(context));  </li>
<li>}  </li>
<li></li>
<li>public void visit(CaseExpression ce) {  </li>
<li>}  </li>
<li></li>
<li>public void visit(WhenClause wc) {  </li>
<li>}  </li>
<li></li>
<li>public void visit(ExistsExpression ee) {  </li>
<li>}  </li>
<li></li>
<li>public void visit(AllComparisonExpression ace) {  </li>
<li>}  </li>
<li></li>
<li>public void visit(AnyComparisonExpression ace) {  </li>
<li>}  </li>
<li></li>
<li>public void visit(Concat c) {  </li>
<li>}  </li>
<li></li>
<li>public void visit(Matches m) {  </li>
<li>}  </li>
<li></li>
<li>public void visit(BitwiseAnd ba) {  </li>
<li>}  </li>
<li></li>
<li>public void visit(BitwiseOr bo) {  </li>
<li>}  </li>
<li></li>
<li>public void visit(BitwiseXor bx) {  </li>
<li>}  </li>
<li></li>
<li>private EqualsTo createTrueEquals() {  </li>
<li>EqualsTo eq = new EqualsTo();  </li>
<li>eq.setLeftExpression(new LongValue(&quot;1&quot;));  </li>
<li>eq.setRightExpression(new LongValue(&quot;1&quot;));  </li>
<li>return eq;  </li>
<li>}  </li>
<li></li>
<li>private EqualsTo createFalseEquals() {  </li>
<li>EqualsTo eq = new EqualsTo();  </li>
<li>eq.setLeftExpression(new LongValue(&quot;1&quot;));  </li>
<li>eq.setRightExpression(new LongValue(&quot;0&quot;));  </li>
<li>return eq;  </li>
<li>}  </li>
<li></li>
<li>}  </li>
</ol>
<p>public class ExpressionVisitorImpl extends AbstractVisitor implements ExpressionVisitor {</p>
<pre><code>public ExpressionVisitorImpl(VisitContext ctx) {

    super(ctx);
}


public void visit(NullValue nv) {

}


public void visit(Function f) {
}


public void visit(InverseExpression ie) {

}


public void visit(JdbcParameter jp) {
    this.getContext().getResultSqlParams().add(context.removeFirstParam());

}


public void visit(DoubleValue dv) {
}


public void visit(LongValue lv) {

}


public void visit(DateValue dv) {
}


public void visit(TimeValue tv) {

}


public void visit(TimestampValue tv) {
}


public void visit(Parenthesis parenthesis) {

    ExpressionVisitorImpl ev = new ExpressionVisitorImpl(context);
    parenthesis.getExpression().accept(ev);

    if (ev.isNotValid()) {
        parenthesis.setExpression(this.createTrueEquals());

    }
}


public void visit(StringValue s) {

}


public void visit(Addition a) {
}


public void visit(Division d) {

}


public void visit(Multiplication m) {
}


public void visit(Subtraction s) {

}


public void visit(AndExpression and) {
    ExpressionVisitorImpl left = new ExpressionVisitorImpl(this.getContext());

    and.getLeftExpression().accept(left);
    if (left.isNotValid()) {

        and.setLeftExpression(this.createTrueEquals());
    }

    ExpressionVisitorImpl right = new ExpressionVisitorImpl(this.getContext());
    and.getRightExpression().accept(right);

    if (right.isNotValid()) {
        and.setRightExpression(this.createTrueEquals());

    }
}


public void visit(OrExpression or) {

    ExpressionVisitorImpl left = new ExpressionVisitorImpl(this.getContext());
    or.getLeftExpression().accept(left);

    if (left.isNotValid()) {
        or.setLeftExpression(this.createFalseEquals());

    }
    ExpressionVisitorImpl right = new ExpressionVisitorImpl(this.getContext());

    or.getRightExpression().accept(right);
    if (right.isNotValid()) {

        or.setRightExpression(this.createFalseEquals());
    }

}


public void visit(Between btw) {
    Expression start = btw.getBetweenExpressionStart();

    Expression end = btw.getBetweenExpressionEnd();
    if (start instanceof JdbcParameter &amp;&amp; end instanceof JdbcParameter) {

        Object o1 = this.context.getFirstParam();
        Object o2 = this.context.getParam(1);

        if (o1 == null || o2 == null) {
            this.context.removeFirstParam();

            this.context.removeFirstParam();
            this.setValid(false);

            return;
        }

    } else if (start instanceof JdbcParameter || end instanceof JdbcParameter) {
        Object o1 = this.context.getFirstParam();

        if (o1 == null) {
            this.context.removeFirstParam();

            this.setValid(false);
            return;

        }
    }

    btw.getLeftExpression().accept(new ExpressionVisitorImpl(context));
    btw.getBetweenExpressionStart().accept(new ExpressionVisitorImpl(context));

    btw.getBetweenExpressionEnd().accept(new ExpressionVisitorImpl(context));
}


public void visit(EqualsTo eq) {

    if (eq.getRightExpression() instanceof JdbcParameter) {
        Object o = this.context.getFirstParam();

        if (o == null) {
            this.setValid(false);

            this.getContext().removeFirstParam();
            return;

        }
    }

    eq.getLeftExpression().accept(new ExpressionVisitorImpl(this.getContext()));
    eq.getRightExpression().accept(new ExpressionVisitorImpl(this.getContext()));

}


public void visit(GreaterThan gt) {
    if (gt.getRightExpression() instanceof JdbcParameter) {

        Object o = this.context.getFirstParam();
        if (o == null) {

            this.setValid(false);
            this.getContext().removeFirstParam();

        }
    }

    gt.getLeftExpression().accept(new ExpressionVisitorImpl(this.getContext()));
    gt.getRightExpression().accept(new ExpressionVisitorImpl(this.getContext()));

}


public void visit(GreaterThanEquals gte) {
    if (gte.getRightExpression() instanceof JdbcParameter) {

        Object o = this.context.getFirstParam();
        if (o == null) {

            this.setValid(false);
            this.getContext().removeFirstParam();

        }
    }

    gte.getLeftExpression().accept(new ExpressionVisitorImpl(this.getContext()));
    gte.getRightExpression().accept(new ExpressionVisitorImpl(this.getContext()));

}


public void visit(InExpression in) {
    ItemsList list = in.getItemsList();

    list.accept(new ItemsListVisitorImpl(context));
}


public void visit(IsNullExpression ine) {

}


public void visit(LikeExpression le) {
    if (le.getRightExpression() instanceof JdbcParameter) {

        Object o = this.context.getFirstParam();
        if (o == null) {

            this.setValid(false);
            this.getContext().removeFirstParam();

        }
    }

    le.getLeftExpression().accept(new ExpressionVisitorImpl(this.getContext()));
    le.getRightExpression().accept(new ExpressionVisitorImpl(this.getContext()));

}


public void visit(MinorThan mt) {
    if (mt.getRightExpression() instanceof JdbcParameter) {

        Object o = this.context.getFirstParam();
        if (o == null) {

            this.setValid(false);
            this.getContext().removeFirstParam();

        }
    }

    mt.getLeftExpression().accept(new ExpressionVisitorImpl(this.getContext()));
    mt.getRightExpression().accept(new ExpressionVisitorImpl(this.getContext()));

}


public void visit(MinorThanEquals mte) {
    if (mte.getRightExpression() instanceof JdbcParameter) {

        Object o = this.context.getFirstParam();
        if (o == null) {

            this.setValid(false);
            this.getContext().removeFirstParam();

        }
    }

    mte.getLeftExpression().accept(new ExpressionVisitorImpl(this.getContext()));
    mte.getRightExpression().accept(new ExpressionVisitorImpl(this.getContext()));

}


public void visit(NotEqualsTo neq) {
    if (neq.getRightExpression() instanceof JdbcParameter) {

        Object o = this.context.getFirstParam();
        if (o == null) {

            this.setValid(false);
            this.getContext().removeFirstParam();

            return;
        }

    }
    neq.getLeftExpression().accept(new ExpressionVisitorImpl(this.getContext()));

    neq.getRightExpression().accept(new ExpressionVisitorImpl(this.getContext()));
}


public void visit(Column c) {

}


public void visit(SubSelect ss) {
    ss.getSelectBody().accept(new SelectVisitorImpl(context));

}


public void visit(CaseExpression ce) {
}


public void visit(WhenClause wc) {

}


public void visit(ExistsExpression ee) {
}


public void visit(AllComparisonExpression ace) {

}


public void visit(AnyComparisonExpression ace) {
}


public void visit(Concat c) {

}


public void visit(Matches m) {
}


public void visit(BitwiseAnd ba) {

}


public void visit(BitwiseOr bo) {
}


public void visit(BitwiseXor bx) {

}


private EqualsTo createTrueEquals() {
    EqualsTo eq = new EqualsTo();

    eq.setLeftExpression(new LongValue(&quot;1&quot;));
    eq.setRightExpression(new LongValue(&quot;1&quot;));

    return eq;
}


private EqualsTo createFalseEquals() {

    EqualsTo eq = new EqualsTo();
    eq.setLeftExpression(new LongValue(&quot;1&quot;));

    eq.setRightExpression(new LongValue(&quot;0&quot;));
    return eq;

}
</code></pre><p>}
增强后SQL语句的重新生成，根据ORACLE的语法重写了几个生成的方法
Java代码  <a href="&quot;收藏这段代码&quot;"><img src="" alt="收藏代码"><img src="" alt=""></a></p>
<ol>
<li>public class OracleSelectDeParser extends SelectDeParser {  </li>
<li></li>
<li>public OracleSelectDeParser(ExpressionDeParser expressionDeParser, StringBuffer sb) {  </li>
<li>super(expressionDeParser, sb);  </li>
<li>}  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* 重写父类方法，去掉父类方法中table前的as </li>
<li>/*/  </li>
<li>public void visit(Table tableName) {  </li>
<li>buffer.append(tableName.getWholeTableName());  </li>
<li>String alias = tableName.getAlias();  </li>
<li>if (alias != null &amp;&amp; StringUtil.isNotEmpty(alias)) {  </li>
<li>buffer.append(&quot; &quot;);  </li>
<li>buffer.append(alias);  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>//<em>/</em> </li>
<li>/* 重写父类方法，在JOIN之前增加空格 </li>
<li>/*/  </li>
<li>@SuppressWarnings(&quot;unchecked&quot;)  </li>
<li>public void deparseJoin(Join join) {  </li>
<li>if (join.isSimple()) {  </li>
<li>buffer.append(&quot;, &quot;);  </li>
<li>} else {  </li>
<li>buffer.append(&quot; &quot;);  </li>
<li>if (join.isRight()) {  </li>
<li>buffer.append(&quot;RIGHT &quot;);  </li>
<li>} else if (join.isNatural()) {  </li>
<li>buffer.append(&quot;NATURAL &quot;);  </li>
<li>} else if (join.isFull()) {  </li>
<li>buffer.append(&quot;FULL &quot;);  </li>
<li>} else if (join.isLeft()) {  </li>
<li>buffer.append(&quot;LEFT &quot;);  </li>
<li>}  </li>
<li>if (join.isOuter()) {  </li>
<li>buffer.append(&quot;OUTER &quot;);  </li>
<li>} else if (join.isInner()) {  </li>
<li>buffer.append(&quot;INNER &quot;);  </li>
<li>}  </li>
<li>buffer.append(&quot;JOIN &quot;);  </li>
<li>}  </li>
<li></li>
<li>FromItem fromItem = join.getRightItem();  </li>
<li>fromItem.accept(this);  </li>
<li>if (join.getOnExpression() != null) {  </li>
<li>buffer.append(&quot; ON &quot;);  </li>
<li>join.getOnExpression().accept(expressionVisitor);  </li>
<li>}  </li>
<li>if (join.getUsingColumns() != null) {  </li>
<li>buffer.append(&quot; USING ( &quot;);  </li>
<li>for (Iterator<Column> iterator = join.getUsingColumns().iterator(); iterator.hasNext();) {  </li>
<li>Column column = iterator.next();  </li>
<li>buffer.append(column.getWholeColumnName());  </li>
<li>if (iterator.hasNext()) {  </li>
<li>buffer.append(&quot; ,&quot;);  </li>
<li>}  </li>
<li>}  </li>
<li>buffer.append(&quot;)&quot;);  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>}  </li>
</ol>
<p>public class OracleSelectDeParser extends SelectDeParser {</p>
<pre><code>public OracleSelectDeParser(ExpressionDeParser expressionDeParser, StringBuffer sb) {

    super(expressionDeParser, sb);
}


//*/*

 /* 重写父类方法，去掉父类方法中table前的as
 /*/

public void visit(Table tableName) {
    buffer.append(tableName.getWholeTableName());

    String alias = tableName.getAlias();
    if (alias != null &amp;&amp; StringUtil.isNotEmpty(alias)) {

        buffer.append(&quot; &quot;);
        buffer.append(alias);

    }
}


//*/*

 /* 重写父类方法，在JOIN之前增加空格
 /*/

@SuppressWarnings(&quot;unchecked&quot;)
public void deparseJoin(Join join) {

    if (join.isSimple()) {
        buffer.append(&quot;, &quot;);

    } else {
        buffer.append(&quot; &quot;);

        if (join.isRight()) {
            buffer.append(&quot;RIGHT &quot;);

        } else if (join.isNatural()) {
            buffer.append(&quot;NATURAL &quot;);

        } else if (join.isFull()) {
            buffer.append(&quot;FULL &quot;);

        } else if (join.isLeft()) {
            buffer.append(&quot;LEFT &quot;);

        }
        if (join.isOuter()) {

            buffer.append(&quot;OUTER &quot;);
        } else if (join.isInner()) {

            buffer.append(&quot;INNER &quot;);
        }

        buffer.append(&quot;JOIN &quot;);
    }


    FromItem fromItem = join.getRightItem();

    fromItem.accept(this);
    if (join.getOnExpression() != null) {

        buffer.append(&quot; ON &quot;);
        join.getOnExpression().accept(expressionVisitor);

    }
    if (join.getUsingColumns() != null) {

        buffer.append(&quot; USING ( &quot;);
        for (Iterator&lt;Column&gt; iterator = join.getUsingColumns().iterator(); iterator.hasNext();) {

            Column column = iterator.next();
            buffer.append(column.getWholeColumnName());

            if (iterator.hasNext()) {
                buffer.append(&quot; ,&quot;);

            }
        }

        buffer.append(&quot;)&quot;);
    }

}
</code></pre><p>}</p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/SQL_Java/">SQL_Java</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/SQL_Java/" class="label label-success">SQL_Java</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:41"datetime="2014-03-07 09:54:41"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-SQL_Java--SQL解析Jsqlparser/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-SQL_Java--SQL解析Jsqlparser" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-SQL_Java--IntroductiontoStructuredQueryLanguageZQL/">Introduction to Structured Query Language(ZQL)</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:41.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-SQL_Java--IntroductiontoStructuredQueryLanguageZQL/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="introduction-to-structured-query-language-zql-">Introduction to Structured Query Language(ZQL)</h1>
<h1 id="introduction-to-structured-query-language">Introduction to Structured Query Language</h1>
<p><strong>Version 3.31</strong></p>
<p>This page is a tutorial of the Structured Query Language(also known as <strong>SQL</strong>) and is a pioneering effort on the World Wide Web, as this is the first comprehensive SQL tutorial available on the Internet. SQL allows users to access data in relational database management systems, such as Oracle, Sybase, Informix, Microsoft SQL Server, Access, and others, by allowing users to describe the data the user wishes to see. SQL also allows users to define the data in a database, and manipulate that data. This page will describe how to use SQL, and give examples. The SQL used in this document is &quot;ANSI&quot;, or standard SQL, and no SQL features of specific database management systems will be discussed until the &quot;Nonstandard SQL&quot; section. It is recommended that you print this page, so that you can easily refer back to previous examples.
<strong>Table of Contents</strong></p>
<p><a href="http://zql.sourceforge.net/sqltut.html#Basics%20of%20the%20SELECT%20Statement">Basics of the SELECT Statement
</a><a href="http://zql.sourceforge.net/sqltut.html#Conditional%20Selection">Conditional Selection
</a><a href="http://zql.sourceforge.net/sqltut.html#Relational%20Operators">Relational Operators
</a><a href="http://zql.sourceforge.net/sqltut.html#Compound%20Conditions">Compound Conditions
</a><a href="http://zql.sourceforge.net/sqltut.html#IN%20&amp;%20BETWEEN">IN &amp; BETWEEN
</a><a href="http://zql.sourceforge.net/sqltut.html#Using%20LIKE" target="_blank">Using LIKE</a></p>
<p><a href="http://zql.sourceforge.net/sqltut.html#Joins">Joins
</a><a href="http://zql.sourceforge.net/sqltut.html#Keys">Keys
</a><a href="http://zql.sourceforge.net/sqltut.html#Performing%20a%20Join">Performing a Join
</a><a href="http://zql.sourceforge.net/sqltut.html#Eliminating%20Duplicates">Eliminating Duplicates
</a><a href="http://zql.sourceforge.net/sqltut.html#Aliases%20&amp;%20In/Subqueries" target="_blank">Aliases &amp; In/Subqueries</a></p>
<p><a href="http://zql.sourceforge.net/sqltut.html#Aggregate%20Functions" target="_blank">Aggregate Functions</a>
<a href="http://zql.sourceforge.net/sqltut.html#Views" target="_blank">Views</a>
<a href="http://zql.sourceforge.net/sqltut.html#Creating%20New%20Tables" target="_blank">Creating New Tables</a>
<a href="http://zql.sourceforge.net/sqltut.html#Altering%20Tables" target="_blank">Altering Tables</a>
<a href="http://zql.sourceforge.net/sqltut.html#Adding%20Data" target="_blank">Adding Data</a>
<a href="http://zql.sourceforge.net/sqltut.html#Deleting%20Data" target="_blank">Deleting Data</a>
<a href="http://zql.sourceforge.net/sqltut.html#Updating%20Data" target="_blank">Updating Data</a></p>
<p><a href="http://zql.sourceforge.net/sqltut.html#Indexes" target="_blank">Indexes</a>
<a href="http://zql.sourceforge.net/sqltut.html#GROUP%20BY%20&amp;%20HAVING" target="_blank">GROUP BY &amp; HAVING</a>
<a href="http://zql.sourceforge.net/sqltut.html#More%20Subqueries">More Subqueries
</a><a href="http://zql.sourceforge.net/sqltut.html#EXISTS%20&amp;%20ALL" target="_blank">EXISTS &amp; ALL</a>
<a href="http://zql.sourceforge.net/sqltut.html#UNION%20&amp;%20Outer%20Joins" target="_blank">UNION &amp; Outer Joins</a>
<a href="http://zql.sourceforge.net/sqltut.html#Embedded%20SQL" target="_blank">Embedded SQL</a>
<a href="http://zql.sourceforge.net/sqltut.html#Common%20SQL%20Questions" target="_blank">Common SQL Questions</a>
<a href="http://zql.sourceforge.net/sqltut.html#Nonstandard%20SQL" target="_blank">Nonstandard SQL</a>
<a href="http://zql.sourceforge.net/sqltut.html#Syntax%20Summary" target="_blank">Syntax Summary</a>
<a href="http://zql.sourceforge.net/sqltut.html#Important%20Links" target="_blank">Important Links</a></p>
<p><a href=""></a><strong>Basics of the SELECT Statement</strong></p>
<p>In a relational database, data is stored in tables. An example table would relate Social Security Number, Name, and Address:
<strong>EmployeeAddressTable</strong> <strong>SSN</strong> <strong>FirstName</strong> <strong>LastName</strong> <strong>Address</strong> <strong>City</strong> <strong>State</strong> 512687458 Joe Smith 83 First Street Howard Ohio 758420012 Mary Scott 842 Vine Ave. Losantiville Ohio 102254896 Sam Jones 33 Elm St. Paris New York 876512563 Sarah Ackerman 440 U.S. 110 Upton Michigan</p>
<p>Now, let&#39;s say you want to see the address of each employee. Use the SELECT statement, like so:</p>
<p>SELECT FirstName, LastName, Address, City, State
FROM EmployeeAddressTable;</p>
<p>The following is the results of your query of the database:
<strong>First Name</strong> <strong>Last Name</strong> <strong>Address</strong> <strong>City</strong> <strong>State</strong> Joe Smith 83 First Street Howard Ohio Mary Scott 842 Vine Ave. Losantiville Ohio Sam Jones 33 Elm St. Paris New York Sarah Ackerman 440 U.S. 110 Upton Michigan</p>
<p>To explain what you just did, you asked for the all of data in the EmployeeAddressTable, and specifically, you asked for the columns called FirstName, LastName, Address, City, and State. Note that column names and table names do not have spaces...they must be typed as one word; and that the statement ends with a semicolon (;). The general form for a SELECT statement, retrieving all of the rows in the table is:</p>
<p>SELECT ColumnName, ColumnName, ...
FROM TableName;</p>
<p>To get all columns of a table without typing all column names, use:</p>
<p>SELECT /* FROM TableName;</p>
<p>Each database management system (DBMS) and database software has different methods for logging in to the database and entering SQL commands; see the local computer &quot;guru&quot; to help you get onto the system, so that you can use SQL.
<a href=""></a><strong>Conditional Selection</strong></p>
<p>To further discuss the SELECT statement, let&#39;s look at a new example table (for hypothetical purposes only):
<strong>EmployeeStatisticsTable</strong> <strong>EmployeeIDNo</strong> <strong>Salary</strong> <strong>Benefits</strong> <strong>Position</strong> 010 75000 15000 Manager 105 65000 15000 Manager 152 60000 15000 Manager 215 60000 12500 Manager 244 50000 12000 Staff 300 45000 10000 Staff 335 40000 10000 Staff 400 32000 7500 Entry-Level 441 28000 7500 Entry-Level</p>
<h3 id="-relational-operators"><a href=""></a>Relational Operators</h3>
<p>There are six Relational Operators in SQL, and after introducing them, we&#39;ll see how they&#39;re used:
= Equal &lt;&gt; or != (see manual) Not Equal &lt; Less Than &gt; Greater Than &lt;= Less Than or Equal To &gt;= Greater Than or Equal To</p>
<p>The WHEREclause is used to specify that only certain rows of the table are displayed, based on the criteria described in that WHERE clause. It is most easily understood by looking at a couple of examples.</p>
<p>If you wanted to see the EMPLOYEEIDNO&#39;s of those making at or over $50,000, use the following:</p>
<p>SELECT EMPLOYEEIDNO
FROM EMPLOYEESTATISTICSTABLE
WHERE SALARY &gt;= 50000;</p>
<p>Notice that the &gt;= (greater than or equal to) sign is used, as we wanted to see those who made greater than $50,000, or equal to $50,000, listed together. This displays:</p>
<h2 id="employeeidno">EMPLOYEEIDNO</h2>
<p>010
105
152
215
244</p>
<p>The WHERE description, SALARY &gt;= 50000, is known as a condition. The same can be done for text columns:</p>
<p>SELECT EMPLOYEEIDNO
FROM EMPLOYEESTATISTICSTABLE
WHERE POSITION = &#39;Manager&#39;;</p>
<p>This displays the ID Numbers of all Managers. Generally, with text columns, stick to equal to or not equal to, and make sure that any text that appears in the statement is surrounded by single quotes (&#39;).</p>
<p><a href=""></a>More Complex Conditions: Compound Conditions</p>
<p>The AND operator joins two or more conditions, and displays a row only if that row&#39;s data satisfies <strong>ALL</strong> conditions listed (i.e. all conditions hold true). For example, to display all staff making over $40,000, use:</p>
<p>SELECT EMPLOYEEIDNO
FROM EMPLOYEESTATISTICSTABLE
WHERE SALARY &gt; 40000 AND POSITION = &#39;Staff&#39;;</p>
<p>The OR operator joins two or more conditions, but returns a row if <strong>ANY</strong> of the conditions listed hold true. To see all those who make less than $40,000 or have less than $10,000 in benefits, listed together, use the following query:</p>
<p>SELECT EMPLOYEEIDNO
FROM EMPLOYEESTATISTICSTABLE
WHERE SALARY &lt; 40000 OR BENEFITS &lt; 10000;</p>
<p>AND &amp; OR can be combined, for example:</p>
<p>SELECT EMPLOYEEIDNO
FROM EMPLOYEESTATISTICSTABLE
WHERE POSITION = &#39;Manager&#39; AND SALARY &gt; 60000 OR BENEFITS &gt; 12000;</p>
<p>First, SQL finds the rows where the salary is greater than $60,000 and the position column is equal to Manager, then taking this new list of rows, SQL then sees if any of these rows satisfies the previous AND condition or the condition that the Benefits column is greater then $12,000. Subsequently, SQL only displays this second new list of rows, keeping in mind that anyone with Benefits over $12,000 will be included as the OR operator includes a row if either resulting condition is True. Also note that the AND operation is done first.</p>
<p>To generalize this process, SQL performs the AND operation(s) to determine the rows where the AND operation(s) hold true (remember: all of the conditions are true), then these results are used to compare with the OR conditions, and only display those remaining rows where the conditions joined by the OR operator hold true.</p>
<p>To perform OR&#39;s before AND&#39;s, like if you wanted to see a list of employees making a large salary (&gt;$50,000) or have a large benefit package (&gt;$10,000), and that happen to be a manager, use parentheses:</p>
<p>SELECT EMPLOYEEIDNO
FROM EMPLOYEESTATISTICSTABLE
WHERE POSITION = &#39;Manager&#39; AND (SALARY &gt; 50000 OR BENEFIT &gt; 10000);</p>
<p><a href=""></a><strong>IN &amp; BETWEEN</strong></p>
<p>An easier method of using compound conditions uses IN or BETWEEN. For example, if you wanted to list all managers and staff:</p>
<p>SELECT EMPLOYEEIDNO
FROM EMPLOYEESTATISTICSTABLE
WHERE POSITION IN (&#39;Manager&#39;, &#39;Staff&#39;);</p>
<p>or to list those making greater than or equal to $30,000, but less than or equal to $50,000, use:</p>
<p>SELECT EMPLOYEEIDNO
FROM EMPLOYEESTATISTICSTABLE
WHERE SALARY BETWEEN 30000 AND 50000;</p>
<p>To list everyone not in this range, try:</p>
<p>SELECT EMPLOYEEIDNO
FROM EMPLOYEESTATISTICSTABLE
WHERE SALARY NOT BETWEEN 30000 AND 50000;</p>
<p>Similarly, NOT IN lists all rows excluded from the IN list.</p>
<p><a href=""></a><strong>UsingLIKE</strong></p>
<p>Look at the EmployeeStatisticsTable, and say you wanted to see all people whose last names started with &quot;L&quot;; try:</p>
<p>SELECT EMPLOYEEIDNO
FROM EMPLOYEEADDRESSTABLE
WHERE LASTNAME LIKE &#39;L%&#39;;</p>
<p>The percent sign (%) is used to represent any possible character (number, letter, or punctuation) or set of characters that might appear after the &quot;L&quot;. To find those people with LastName&#39;s ending in &quot;L&quot;, use &#39;%L&#39;, or if you wanted the &quot;L&quot; in the middle of the word, try &#39;%L%&#39;. The &#39;%&#39; can be used for any characters, in that relative position to the given characters. NOT LIKE displays rows not fitting the given description. Other possiblities of using LIKE, or any of these discussed conditionals, are available, though it depends on what DBMS you are using; as usual, consult a manual or your system manager or administrator for the available features on your system, or just to make sure that what you are trying to do is available and allowed. This disclaimer holds for the features of SQL that will be discussed below. This section is just to give you an idea of the possibilities of queries that can be written in SQL.
<a href=""></a><strong>Joins</strong></p>
<p>In this section, we will only discuss inner joins, and equijoins, as in general, they are the most useful. For more information, try the SQL links at the bottom of the page.</p>
<p>Good database design suggests that each table lists data only about a single entity, and detailed information can be obtained in a relational database, by using additional tables, and by using a join.</p>
<p>First, take a look at these example tables:
<strong>AntiqueOwners</strong>
 <strong>OwnerID</strong> <strong>OwnerLastName</strong> <strong>OwnerFirstName</strong> 01 Jones Bill 02 Smith Bob 15 Lawson Patricia 21 Akins Jane 50 Fowler Sam</p>
<p><strong>Orders</strong>
 <strong>OwnerID</strong> <strong>ItemDesired</strong> 02 Table 02 Desk 21 Chair 15 Mirror</p>
<p><strong>Antiques</strong>
 <strong>SellerID</strong> <strong>BuyerID</strong> <strong>Item</strong> 01 50 Bed 02 15 Table 15 02 Chair 21 50 Mirror 50 01 Desk 01 21 Cabinet 02 21 Coffee Table 15 50 Chair 01 15 Jewelry Box 02 21 Pottery 21 02 Bookcase 50 01 Plant Stand</p>
<p><a href=""></a><strong>Keys</strong></p>
<p>First, let&#39;s discuss the concept of keys. A primary key is a column or set of columns that uniquely identifies the rest of the data in any given row. For example, in the AntiqueOwners table, the OwnerID column uniquely identifies that row. This means two things: no two rows can have the same OwnerID, and, even if two owners have the same first and last names, the OwnerID column ensures that the two owners will not be confused with each other, because the unique OwnerID column will be used throughout the database to track the owners, rather than the names.</p>
<p>Aforeign key is a column in a table where that column is a primary key of another table, which means that any data in a foreign key column must have corresponding data in the other table where that column is the primary key. In DBMS-speak, this correspondence is known as referential integrity. For example, in the Antiques table, both the BuyerID and SellerID are foreign keys to the primary key of the AntiqueOwners table (OwnerID; for purposes of argument, one has to be an Antique Owner before one can buy or sell any items), as, in both tables, the ID rows are used to identify the owners or buyers and sellers, and that the OwnerID is the primary key of the AntiqueOwners table. In other words, all of this &quot;ID&quot; data is used to refer to the owners, buyers, or sellers of antiques, themselves, without having to use the actual names.</p>
<p><a href=""></a><strong>Performing a Join</strong></p>
<p>The purpose of these keys is so that data can be related across tables, without having to repeat data in every table--this is the power of relational databases. For example, you can find the names of those who bought a chair without having to list the full name of the buyer in the Antiques table...you can get the name by relating those who bought a chair with the names in the AntiqueOwners table through the use of the OwnerID, which relates the data in the two tables. To find the names of those who bought a chair, use the following query:</p>
<p>SELECT OWNERLASTNAME, OWNERFIRSTNAME
FROM ANTIQUEOWNERS, ANTIQUES
WHERE BUYERID = OWNERID AND ITEM = &#39;Chair&#39;;</p>
<p>Note the following about this query...notice that both tables involved in the relation are listed in the FROM clause of the statement. In the WHERE clause, first notice that the ITEM = &#39;Chair&#39; part restricts the listing to those who have bought (and in this example, thereby owns) a chair. Secondly, notice how the ID columns are related from one table to the next by use of the BUYERID = OWNERID clause. Only where ID&#39;s match across tables and the item purchased is a chair (because of the AND), will the names from the AntiqueOwners table be listed. Because the joining condition used an equal sign, this join is called an equijoin. The result of this query is two names: Smith, Bob &amp; Fowler, Sam.</p>
<p>Dot notation refers to prefixing the table names to column names, to avoid ambiguity, as such:</p>
<p>SELECT ANTIQUEOWNERS.OWNERLASTNAME, ANTIQUEOWNERS.OWNERFIRSTNAME
FROM ANTIQUEOWNERS, ANTIQUES
WHERE ANTIQUES.BUYERID = ANTIQUEOWNERS.OWNERID AND ANTIQUES.ITEM = &#39;Chair&#39;;</p>
<p>As the column names are different in each table, however, this wasn&#39;t necessary.</p>
<p><a href=""></a><strong>DISTINCT and Eliminating Duplicates</strong></p>
<p>Let&#39;s say that you want to list the ID and names of <strong>only</strong> those people who have sold an antique. Obviously, you want a list where each seller is only listed once--you don&#39;t want to know how many antiques a person sold, just the fact that this person sold one (for counts, see the Aggregate Function section below). This means that you will need to tell SQL to eliminate duplicate sales rows, and just list each person only once. To do this, use the DISTINCT keyword.</p>
<p>First, we will need an equijoin to the AntiqueOwners table to get the detail data of the person&#39;s LastName and FirstName. However, keep in mind that since the SellerID column in the Antiques table is a foreign key to the AntiqueOwners table, a seller will only be listed if there is a row in the AntiqueOwners table listing the ID and names. We also want to eliminate multiple occurences of the SellerID in our listing, so we use DISTINCT<strong>on the column where the repeats may occur.</strong></p>
<p>To throw in one more twist, we will also want the list alphabetized by LastName, then by FirstName (on a LastName tie), then by OwnerID (on a LastName and FirstName tie). Thus, we will use the ORDER BY clause:</p>
<p>SELECT DISTINCT SELLERID, OWNERLASTNAME, OWNERFIRSTNAME
FROM ANTIQUES, ANTIQUEOWNERS
WHERE SELLERID = OWNERID
ORDER BY OWNERLASTNAME, OWNERFIRSTNAME, OWNERID;</p>
<p>In this example, since everyone has sold an item, we will get a listing of all of the owners, in alphabetical order by last name. For future reference (and in case anyone asks), this type of join is considered to be in the category of inner joins.</p>
<p><a href=""></a><strong>Aliases &amp; In/Subqueries</strong></p>
<p>In this section, we will talk about Aliases, In and the use of subqueries, and how these can be used in a 3-table example. First, look at this query which prints the last name of those owners who have placed an order and what the order is, only listing those orders which can be filled (that is, there is a buyer who owns that ordered item):</p>
<p>SELECT OWN.OWNERLASTNAME Last Name, ORD.ITEMDESIRED Item Ordered
FROM ORDERS ORD, ANTIQUEOWNERS OWN
WHERE ORD.OWNERID = OWN.OWNERID
AND ORD.ITEMDESIRED IN</p>
<p>(SELECT ITEM
FROM ANTIQUES);</p>
<p>This gives:</p>
<p>Last Name Item Ordered</p>
<hr>
<p>Smith     Table
Smith     Desk
Akins     Chair
Lawson    Mirror</p>
<p>There are several things to note about this query:</p>
<ol>
<li>First, the &quot;Last Name&quot; and &quot;Item Ordered&quot; in the Select lines gives the headers on the report.</li>
<li>The OWN &amp; ORD are aliases; these are new names for the two tables listed in the FROM clause that are used as prefixes for all dot notations of column names in the query (see above). This eliminates ambiguity, especially in the equijoin WHERE clause where both tables have the column named OwnerID, and the dot notation tells SQL that we are talking about two different OwnerID&#39;s from the two different tables.</li>
<li>Note that the Orders table is listed first in the FROM clause; this makes sure listing is done off of that table, and the AntiqueOwners table is only used for the detail information (Last Name).</li>
<li>Most importantly, the AND in the WHERE clause forces the In Subquery to be invoked (&quot;= ANY&quot; or &quot;= SOME&quot; are two equivalent uses of IN). What this does is, the subquery is performed, returning all of the Items owned from the Antiques table, as there is no WHERE clause. Then, for a row from the Orders table to be listed, the ItemDesired must be in that returned list of Items owned from the Antiques table, thus listing an item only if the order can be filled from another owner. You can think of it this way: the subquery returns a set of Items from which each ItemDesired in the Orders table is compared; the In condition is true only if the ItemDesired is in that returned set from the Antiques table.</li>
<li>Also notice, that in this case, that there happened to be an antique available for each one desired...obviously, that won&#39;t always be the case. In addition, notice that when the IN, &quot;= ANY&quot;, or &quot;= SOME&quot; is used, that these keywords refer to any possible row matches, not column matches...that is, you cannot put multiple columns in the subquery Select clause, in an attempt to match the column in the outer Where clause to one of multiple possible column values in the subquery; only one column can be listed in the subquery, and the possible match comes from multiple row values in that one column, not vice-versa.</li>
</ol>
<p>Whew! That&#39;s enough on the topic of complex SELECT queries for now. Now on to other SQL statements.
<strong>Miscellaneous SQL Statements</strong></p>
<p><a href=""></a><strong>Aggregate Functions</strong></p>
<p>I will discuss five important aggregate functions: SUM, AVG, MAX, MIN, and COUNT. They are called aggregate functions because they summarize the results of a query, rather than listing all of the rows.</p>
<ul>
<li>SUM () gives the total of all the rows, satisfying any conditions, of the given column, where the given column is numeric.</li>
<li>AVG () gives the average of the given column.</li>
<li>MAX () gives the largest figure in the given column.</li>
<li>MIN () gives the smallest figure in the given column.</li>
<li>COUNT(/*) gives the number of rows satisfying the conditions.</li>
</ul>
<p>Looking at the tables at the top of the document, let&#39;s look at three examples:</p>
<p>SELECT SUM(SALARY), AVG(SALARY)
FROM EMPLOYEESTATISTICSTABLE;</p>
<p>This query shows the total of all salaries in the table, and the average salary of all of the entries in the table.</p>
<p>SELECT MIN(BENEFITS)
FROM EMPLOYEESTATISTICSTABLE
WHERE POSITION = &#39;Manager&#39;;</p>
<p>This query gives the smallest figure of the Benefits column, of the employees who are Managers, which is 12500.</p>
<p>SELECT COUNT(/*)
FROM EMPLOYEESTATISTICSTABLE
WHERE POSITION = &#39;Staff&#39;;</p>
<p>This query tells you how many employees have Staff status (3).</p>
<p><a href=""></a><strong>Views</strong></p>
<p>In SQL, you might (check your DBA) have access to create views for yourself. What a view does is to allow you to assign the results of a query to a new, personal table, that you can use in other queries, where this new table is given the view name in your FROM clause. When you access a view, the query that is defined in your view creation statement is performed (generally), and the results of that query look just like another table in the query that you wrote invoking the view. For example, to create a view:</p>
<p>CREATE VIEW ANTVIEW AS SELECT ITEMDESIRED FROM ORDERS;</p>
<p>Now, write a query using this view as a table, where the table is just a listing of all Items Desired from the Orders table:</p>
<p>SELECT SELLERID
FROM ANTIQUES, ANTVIEW
WHERE ITEMDESIRED = ITEM;</p>
<p>This query shows all SellerID&#39;s from the Antiques table where the Item in that table happens to appear in the Antview view, which is just all of the Items Desired in the Orders table. The listing is generated by going through the Antique Items one-by-one until there&#39;s a match with the Antview view. Views can be used to restrict database access, as well as, in this case, simplify a complex query.</p>
<p><a href=""></a><strong>Creating New Tables</strong></p>
<p>All tables within a database must be created at some point in time...let&#39;s see how we would create the Orders table:</p>
<p>CREATE TABLE ORDERS
(OWNERID INTEGER NOT NULL,
ITEMDESIRED CHAR(40) NOT NULL);</p>
<p>This statement gives the table name and tells the DBMS about each column in the table. <strong>Please note</strong> that this statement uses generic data types, and that the data types might be different, depending on what DBMS you are using. As usual, check local listings. Some common generic data types are:</p>
<ul>
<li>Char(x) - A column of characters, where x is a number designating the maximum number of characters allowed (maximum length) in the column.</li>
<li>Integer - A column of whole numbers, positive or negative.</li>
<li>Decimal(x, y) - A column of decimal numbers, where x is the maximum length in digits of the decimal numbers in this column, and y is the maximum number of digits allowed after the decimal point. The maximum (4,2) number would be 99.99.</li>
<li>Date - A date column in a DBMS-specific format.</li>
<li>Logical - A column that can hold only two values: TRUE or FALSE.</li>
</ul>
<p>One other note, the NOT NULL means that the column must have a value in each row. If NULL was used, that column may be left empty in a given row.</p>
<p><a href=""></a><strong>Altering Tables</strong></p>
<p>Let&#39;s add a column to the Antiques table to allow the entry of the price of a given Item:</p>
<p>ALTER TABLE ANTIQUES ADD (PRICE DECIMAL(8,2) NULL);</p>
<p>The data for this new column can be updated or inserted as shown later.</p>
<p><a href=""></a><strong>Adding Data</strong></p>
<p>To insert rows into a table, do the following:</p>
<p>INSERT INTO ANTIQUES VALUES (21, 01, &#39;Ottoman&#39;, 200.00);</p>
<p>This inserts the data into the table, as a new row, column-by-column, in the pre-defined order. Instead, let&#39;s change the order and leave Price blank:</p>
<p>INSERT INTO ANTIQUES (BUYERID, SELLERID, ITEM)
VALUES (01, 21, &#39;Ottoman&#39;);</p>
<p><a href=""></a><strong>Deleting Data</strong></p>
<p>Let&#39;s delete this new row back out of the database:</p>
<p>DELETE FROM ANTIQUES
WHERE ITEM = &#39;Ottoman&#39;;</p>
<p>But if there is another row that contains &#39;Ottoman&#39;, that row will be deleted also. Let&#39;s delete all rows (one, in this case) that contain the specific data we added before:</p>
<p>DELETE FROM ANTIQUES
WHERE ITEM = &#39;Ottoman&#39; AND BUYERID = 01 AND SELLERID = 21;</p>
<p><a href=""></a><strong>Updating Data</strong></p>
<p>Let&#39;s update a Price into a row that doesn&#39;t have a price listed yet:</p>
<p>UPDATE ANTIQUES SET PRICE = 500.00 WHERE ITEM = &#39;Chair&#39;;</p>
<p>This sets all Chair&#39;s Prices to 500.00. As shown above, more WHERE conditionals, using AND, must be used to limit the updating to more specific rows. Also, additional columns may be set by separating equal statements with commas.</p>
<p><strong>Miscellaneous Topics</strong></p>
<p><a href=""></a><strong>Indexes</strong></p>
<p>Indexes allow a DBMS to access data quicker (please note: this feature is nonstandard/not available on all systems). The system creates this internal data structure (the index) which causes selection of rows, when the selection is based on indexed columns, to occur faster. This index tells the DBMS where a certain row is in the table given an indexed-column value, much like a book index tells you what page a given word appears. Let&#39;s create an index for the OwnerID in the AntiqueOwners column:</p>
<p>CREATE INDEX OID_IDX ON ANTIQUEOWNERS (OWNERID);</p>
<p>Now on the names:</p>
<p>CREATE INDEX NAME_IDX ON ANTIQUEOWNERS (OWNERLASTNAME, OWNERFIRSTNAME);</p>
<p>To get rid of an index, drop it:</p>
<p>DROP INDEX OID_IDX;</p>
<p>By the way, you can also &quot;drop&quot; a table, as well (careful!--that means that your table is deleted). In the second example, the index is kept on the two columns, aggregated together--strange behavior might occur in this situation...check the manual before performing such an operation.</p>
<p>Some DBMS&#39;s do not enforce primary keys; in other words, the uniqueness of a column is not enforced automatically. What that means is, if, for example, I tried to insert another row into the AntiqueOwners table with an OwnerID of 02, some systems will allow me to do that, even though, we do not, as that column is supposed to be unique to that table (every row value is supposed to be different). One way to get around that is to create a unique index on the column that we want to be a primary key, to force the system to enforce prohibition of duplicates:</p>
<p>CREATE UNIQUE INDEX OID_IDX ON ANTIQUEOWNERS (OWNERID);</p>
<p><a href=""></a><strong>GROUP BY &amp; HAVING</strong></p>
<p>One special use of GROUP BY is to associate an aggregate function (especially COUNT; counting the number of rows in each group) with groups of rows. First, assume that the Antiques table has the Price column, and each row has a value for that column. We want to see the price of the most expensive item bought by each owner. We have to tell SQL to group each owner&#39;s purchases, and tell us the maximum purchase price:</p>
<p>SELECT BUYERID, MAX(PRICE)
FROM ANTIQUES
GROUP BY BUYERID;</p>
<p>Now, say we only want to see the maximum purchase price if the purchase is over $1000, so we use the HAVING clause:</p>
<p>SELECT BUYERID, MAX(PRICE)
FROM ANTIQUES
GROUP BY BUYERID
HAVING PRICE &gt; 1000;</p>
<p><a href=""></a><strong>More Subqueries</strong></p>
<p>Another common usage of subqueries involves the use of operators to allow a Where condition to include the Select output of a subquery. First, list the buyers who purchased an expensive item (the Price of the item is $100 greater than the average price of all items purchased):</p>
<p>SELECT OWNERID
FROM ANTIQUES
WHERE PRICE &gt;</p>
<p>(SELECT AVG(PRICE) + 100
FROM ANTIQUES);</p>
<p>The subquery calculates the average Price, plus $100, and using that figure, an OwnerID is printed for every item costing over that figure. One could use DISTINCT OWNERID, to eliminate duplicates.</p>
<p>List the Last Names of those in the AntiqueOwners table, ONLY if they have bought an item:</p>
<p>SELECT OWNERLASTNAME
FROM ANTIQUEOWNERS
WHERE OWNERID =</p>
<p>(SELECT DISTINCT BUYERID
FROM ANTIQUES);</p>
<p>The subquery returns a list of buyers, and the Last Name is printed for an Antique Owner if and only if the Owner&#39;s ID appears in the subquery list (sometimes called a candidate list).</p>
<p>For an Update example, we know that the gentleman who bought the bookcase has the wrong First Name in the database...it should be John:</p>
<p>UPDATE ANTIQUEOWNERS
SET OWNERFIRSTNAME = &#39;John&#39;
WHERE OWNERID =</p>
<p>(SELECT BUYERID
FROM ANTIQUES
WHERE ITEM = &#39;Bookcase&#39;);</p>
<p>First, the subquery finds the BuyerID for the person(s) who bought the Bookcase, then the outer query updates his First Name.</p>
<p><strong>Remember this rule about subqueries:</strong> when you have a subquery as part of a WHERE condition, the Select clause in the subquery must have columns that match in number and type to those in the Where clause of the outer query. In other words, if you have &quot;WHERE ColumnName = (SELECT...);&quot;, the Select must have only one column in it, to match the ColumnName in the outer Where clause, and they must match in type (both being integers, both being character strings, etc.).</p>
<p><a href=""></a><strong>EXISTS &amp; ALL</strong></p>
<p>EXISTS uses a subquery as a condition, where the condition is True if the subquery returns any rows, and False if the subquery does not return any rows; this is a nonintuitive feature with few unique uses. However, if a prospective customer wanted to see the list of Owners only if the shop dealt in Chairs, try:</p>
<p>SELECT OWNERFIRSTNAME, OWNERLASTNAME
FROM ANTIQUEOWNERS
WHERE EXISTS</p>
<p>(SELECT /*
FROM ANTIQUES
WHERE ITEM = &#39;Chair&#39;);</p>
<p>If there are any Chairs in the Antiques column, the subquery would return a row or rows, making the EXISTS clause true, causing SQL to list the Antique Owners. If there had been no Chairs, no rows would have been returned by the outside query.</p>
<p>ALL is another unusual feature, as ALL queries can usually be done with different, and possibly simpler methods; let&#39;s take a look at an example query:</p>
<p>SELECT BUYERID, ITEM
FROM ANTIQUES
WHERE PRICE &gt;= ALL</p>
<p>(SELECT PRICE
FROM ANTIQUES);</p>
<p>This will return the largest priced item (or more than one item if there is a tie), and its buyer. The subquery returns a list of all Prices in the Antiques table, and the outer query goes through each row of the Antiques table, and if its Price is greater than or equal to every (or ALL) Prices in the list, it is listed, giving the highest priced Item. The reason &quot;&gt;=&quot; must be used is that the highest priced item will be equal to the highest price on the list, because this Item is in the Price list.</p>
<p><a href=""></a><strong>UNION &amp; Outer Joins</strong></p>
<p>There are occasions where you might want to see the results of multiple queries together, combining their output; use UNION. To merge the output of the following two queries, displaying the ID&#39;s of all Buyers, plus all those who have an Order placed:</p>
<p>SELECT BUYERID
FROM ANTIQUEOWNERS
UNION
SELECT OWNERID
FROM ORDERS;</p>
<p>Notice that SQL requires that the Select list (of columns) must match, column-by-column, in data type. In this case BuyerID and OwnerID are of the same data type (integer). Also notice that SQL does automatic duplicate elimination when using UNION (as if they were two &quot;sets&quot;); in single queries, you have to use DISTINCT.</p>
<p>The outer join is used when a join query is &quot;united&quot; with the rows not included in the join, and are especially useful if constant text &quot;flags&quot; are included. First, look at the query:</p>
<p>SELECT OWNERID, &#39;is in both Orders &amp; Antiques&#39;
FROM ORDERS, ANTIQUES
WHERE OWNERID = BUYERID
UNION
SELECT BUYERID, &#39;is in Antiques only&#39;
FROM ANTIQUES
WHERE BUYERID NOT IN</p>
<p>(SELECT OWNERID
FROM ORDERS);</p>
<p>The first query does a join to list any owners who are in both tables, and putting a tag line after the ID repeating the quote. The UNION merges this list with the next list. The second list is generated by first listing those ID&#39;s not in the Orders table, thus generating a list of ID&#39;s excluded from the join query. Then, each row in the Antiques table is scanned, and if the BuyerID is not in this exclusion list, it is listed with its quoted tag. There might be an easier way to make this list, but it&#39;s difficult to generate the informational quoted strings of text.</p>
<p>This concept is useful in situations where a primary key is related to a foreign key, but the foreign key value for some primary keys is NULL. For example, in one table, the primary key is a salesperson, and in another table is customers, with their salesperson listed in the same row. However, if a salesperson has no customers, that person&#39;s name won&#39;t appear in the customer table. The outer join is used if the listing of <strong>all</strong> salespersons is to be printed, listed with their customers, whether the salesperson has a customer or not--that is, no customer is printed (a logical NULL value) if the salesperson has no customers, but is in the salespersons table. Otherwise, the salesperson will be listed with each customer.</p>
<p>ENOUGH QUERIES!!! you say?...now on to something completely different...</p>
<p><a href=""></a><strong>Embedded SQL--an ugly example (do not write a program like this...for purposes of argument ONLY)</strong></p>
<p>//<em> -To get right to it, here is an example program that uses Embedded
    SQL. Embedded SQL allows programmers to connect to a database and
    include SQL code right in the program, so that their programs can
    use, manipulate, and process data from a database.
   -This example C Program (using Embedded SQL) will print a report.
   -This program will have to be precompiled for the SQL statements,
    before regular compilation.
   -The EXEC SQL parts are the same (standard), but the surrounding C
    code will need to be changed, including the host variable
    declarations, if you are using a different language.
   -Embedded SQL changes from system to system, so, once again, check
    local documentation, especially variable declarations and logging
    in procedures, in which network, DBMS, and operating system
    considerations are crucial. /</em>/</p>
<p>//<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/
//<em> THIS PROGRAM IS NOT COMPILABLE OR EXECUTABLE /</em>/
//<em> IT IS FOR EXAMPLE PURPOSES ONLY              /</em>/
//<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/<em>/</em>/</p>
<p>/#include <stdio.h></p>
<p>//<em> This section declares the host variables; these will be the
   variables your program uses, but also the variable SQL will put
   values in or take values out. /</em>/
EXEC SQL BEGIN DECLARE SECTION;
  int BuyerID;
  char FirstName[100], LastName[100], Item[100];
EXEC SQL END DECLARE SECTION;</p>
<p>//<em> This includes the SQLCA variable, so that some error checking can be done. /</em>/
EXEC SQL INCLUDE SQLCA;</p>
<p>main() {</p>
<p>//<em> This is a possible way to log into the database /</em>/
EXEC SQL CONNECT UserID/Password;</p>
<p>//<em> This code either says that you are connected or checks if an error
   code was generated, meaning log in was incorrect or not possible. /</em>/   if(sqlca.sqlcode) {
    printf(Printer, &quot;Error connecting to database server.\n&quot;);
    exit();
  }
  printf(&quot;Connected to database server.\n&quot;);</p>
<p>//<em> This declares a &quot;Cursor&quot;. This is used when a query returns more
   than one row, and an operation is to be performed on each row
   resulting from the query. With each row established by this query,
   I&#39;m going to use it in the report. Later, &quot;Fetch&quot; will be used to
   pick off each row, one at a time, but for the query to actually
   be executed, the &quot;Open&quot; statement is used. The &quot;Declare&quot; just
   establishes the query. /</em>/
EXEC SQL DECLARE ItemCursor CURSOR FOR
  SELECT ITEM, BUYERID
  FROM ANTIQUES
  ORDER BY ITEM;
EXEC SQL OPEN ItemCursor;</p>
<p>//<em> +-- You may wish to put a similar error checking block here --+ /</em>/</p>
<p>//<em> Fetch puts the values of the &quot;next&quot; row of the query in the host
   variables, respectively. However, a &quot;priming fetch&quot; (programming
   technique) must first be done. When the cursor is out of data, a
   sqlcode will be generated allowing us to leave the loop. Notice
   that, for simplicity&#39;s sake, the loop will leave on any sqlcode,
   even if it is an error code. Otherwise, specific code checking must
   be performed. /</em>/
EXEC SQL FETCH ItemCursor INTO :Item, :BuyerID;
  while(!sqlca.sqlcode) {</p>
<p>//<em> With each row, we will also do a couple of things. First, bump the
   price up by $5 (dealer&#39;s fee) and get the buyer&#39;s name to put in
   the report. To do this, I&#39;ll use an Update and a Select, before
   printing the line on the screen. The update assumes however, that
   a given buyer has only bought one of any given item, or else the
   price will be increased too many times. Otherwise, a &quot;RowID&quot; logic
   would have to be used (see documentation). Also notice the colon    before host variable names when used inside of SQL statements. /</em>/</p>
<p>EXEC SQL UPDATE ANTIQUES
  SET PRICE = PRICE + 5
  WHERE ITEM = :Item AND BUYERID = :BuyerID;</p>
<p>EXEC SQL SELECT OWNERFIRSTNAME, OWNERLASTNAME
  INTO :FirstName, :LastName
  FROM ANTIQUEOWNERS
  WHERE BUYERID = :BuyerID;</p>
<pre><code>printf(&quot;%25s %25s %25s&quot;, FirstName, LastName, Item);
</code></pre><p>//<em> Ugly report--for example purposes only! Get the next row. /</em>/
EXEC SQL FETCH ItemCursor INTO :Item, :BuyerID;
  }</p>
<p>//<em> Close the cursor, commit the changes (see below), and exit the
   program. /</em>/
EXEC SQL CLOSE DataCursor;
EXEC SQL COMMIT RELEASE;
  exit();
}</p>
<p><a href=""></a><strong>Common SQL Questions--Advanced Topics (see FAQ link for several more)</strong></p>
<ol>
<li>Why can&#39;t I just ask for the first three rows in a table? --Because in relational databases, rows are inserted in no particular order, that is, the system inserts them in an arbitrary order; so, you can only request rows using valid SQL features, like ORDER BY, etc.</li>
<li>What is this DDL and DML I hear about? --DDL (Data Definition Language) refers to (in SQL) the Create Table statement...DML (Data Manipulation Language) refers to the Select, Update, Insert, and Delete statements.</li>
<li>Aren&#39;t database tables just files? --Well, DBMS&#39;s store data in files declared by system managers before new tables are created (on large systems), but the system stores the data in a special format, and may spread data from one table over several files. In the database world, a set of files created for a database is called a tablespace. In general, on small systems, everything about a database (definitions and all table data) is kept in one file.</li>
<li>(Related question) Aren&#39;t database tables just like spreadsheets? --No, for two reasons. First, spreadsheets can have data in a cell, but a cell is more than just a row-column-intersection. Depending on your spreadsheet software, a cell might also contain formulas and formatting, which database tables cannot have (currently). Secondly, spreadsheet cells are often dependent on the data in other cells. In databases, &quot;cells&quot; are independent, except that columns are logically related (hopefully; together a row of columns describe an entity), and, other than primary key and foreign key constraints, each row in a table in independent from one another.</li>
<li>How do I import a text file of data into a database? --Well, you can&#39;t do it directly...you must use a utility, such as Oracle&#39;s SQL/*Loader, or write a program to load the data into the database. A program to do this would simply go through each record of a text file, break it up into columns, and do an Insert into the database.</li>
<li>What is a schema? --A schema is a logical set of tables, such as the Antiques database above...usually, it is thought of as simply &quot;the database&quot;, but a database can hold more than one schema. For example, a star schema is a set of tables where one large, central table holds all of the important information, and is linked, via foreign keys, to dimension tables which hold detail information, and can be used in a join to create detailed reports.</li>
<li>What are some general tips you would give to make my SQL queries and databases better and faster (optimized)?</li>
</ol>
<ul>
<li>You should try, if you can, to avoid expressions in Selects, such as SELECT ColumnA + ColumnB, etc. The query optimizer of the database, the portion of the DBMS that determines the best way to get the required data out of the database itself, handles expressions in such a way that would normally require more time to retrieve the data than if columns were normally selected, and the expression itself handled programmatically.</li>
<li>Minimize the number of columns included in a Group By clause.</li>
<li>If you are using a join, try to have the columns joined on (from both tables) indexed.</li>
<li>When in doubt, index.</li>
<li><p>Unless doing multiple counts or a complex query, use COUNT(/*) (the number of rows generated by the query) rather than COUNT(Column_Name).</p>
</li>
<li><p>What is normalization? --Normalization is a technique of database design that suggests that certain criteria be used when constructing a table layout (deciding what columns each table will have, and creating the key structure), where the idea is to eliminate redundancy of non-key data across tables. Normalization is usually referred to in terms of forms, and I will introduce only the first three, even though it is somewhat common to use other, more advanced forms (fourth, fifth, Boyce-Codd; see documentation).
First Normal Form refers to moving data into separate tables where the data in each table is of a similar type, and by giving each table a primary key.
Putting data in Second Normal Form involves taking out data off to other tables that is only dependent of a part of the key. For example, if I had left the names of the Antique Owners in the items table, that would not be in second normal form because that data would be redundant; the name would be repeated for each item owned, so the names were placed in their own table. The names themselves don&#39;t have anything to do with the items, only the identities of the buyers and sellers.
Third Normal Form involves getting rid of anything in the tables that doesn&#39;t depend solely on the primary key. Only include information that is dependent on the key, and move off data to other tables that are independent of the primary key, and create a primary keys for the new tables.
There is some redundancy to each form, and if data is in 3NF(shorthand for 3rd normal form), it is already in 1NFand 2NF. In terms of data design then, arrange data so that any non-primary key columns are dependent only on the whole primary key. If you take a look at the sample database, you will see that the way then to navigate through the database is through joins using common key columns.
Two other important points in database design are using good, consistent, logical, full-word names for the tables and columns, and the use of full words in the database itself. On the last point, my database is lacking, as I use numeric codes for identification. It is usually best, if possible, to come up with keys that are, by themselves, self-explanatory; for example, a better key would be the first four letters of the last name and first initial of the owner, like JONEB for Bill Jones (or for tiebreaking purposes, add numbers to the end to differentiate two or more people with similar names, so you could try JONEB1, JONEB2, etc.).</p>
</li>
<li>What is the difference between a single-row query and a multiple-row query and why is it important to know the difference? --First, to cover the obvious, a single-row query is a query that returns one row as its result, and a multiple-row query is a query that returns more than one row as its result. Whether a query returns one row or more than one row is entirely dependent on the design (or schema) of the tables of the database. As query-writer, you must be aware of the schema, be sure to include enough conditions, and structure your SQL statement properly, so that you will get the desired result (either one row or multiple rows). For example, if you wanted to be sure that a query of the AntiqueOwners table returned only one row, consider an equal condition of the primary key-column, OwnerID.
Three reasons immediately come to mind as to why this is important. First, getting multiple rows when you were expecting only one, or vice-versa, may mean that the query is erroneous, that the database is incomplete, or simply, you learned something new about your data. Second, if you are using an update or delete statement, you had better be sure that the statement that you write performs the operation on the desired row (or rows)...or else, you might be deleting or updating more rows than you intend. Third, any queries written in Embedded SQL must be carefully thought out as to the number of rows returned. If you write a single-row query, only one SQL statement may need to be performed to complete the programming logic required. If your query, on the other hand, returns multiple rows, you will have to use the Fetch statement, and quite probably, some sort of looping structure in your program will be required to iterate processing on each returned row of the query.</li>
<li>What are relationships? --Another design question...the term &quot;relationships&quot; (often termed &quot;relation&quot;) usually refers to the relationships among primary and foreign keys between tables. This concept is important because when the tables of a relational database are designed, these relationships must be defined because they determine which columns are or are not primary or foreign keys. You may have heard of an <strong>Entity-Relationship Diagram</strong>, which is a graphical view of tables in a database schema, with lines connecting related columns across tables. See the sample diagram at the end of this section or some of the sites below in regard to this topic, as there are many different ways of drawing E-R diagrams. But first, let&#39;s look at each kind of relationship...
A One-to-one relationship means that you have a primary key column that is related to a foreign key column, and that for every primary key value, there is <strong>one</strong> foreign key value. For example, in the first example, the EmployeeAddressTable, we add an EmployeeIDNo column. Then, the EmployeeAddressTable is related to the EmployeeStatisticsTable (second example table) by means of that EmployeeIDNo. Specifically, each employee in the EmployeeAddressTable <strong>has</strong> statistics (one row of data) in the EmployeeStatisticsTable. Even though this is a contrived example, this is a &quot;1-1&quot; relationship. Also notice the &quot;has&quot; in bold...when expressing a relationship, it is important to describe the relationship with a verb.
The other two kinds of relationships may or may not use logical primary key and foreign key constraints...it is strictly a call of the designer. The first of these is the one-to-many relationship (&quot;1-M&quot;). This means that for every column value in one table, there is <strong>one or more</strong> related values in another table. Key constraints may be added to the design, or possibly just the use of some sort of identifier column may be used to establish the relationship. An example would be that for every OwnerID in the AntiqueOwners table, there are one or more (zero is permissible too) Items <strong>bought</strong> in the Antiques table (verb: buy).
Finally, the many-to-many relationship (&quot;M-M&quot;) does not involve keys generally, and usually involves idenifying columns. The unusual occurence of a &quot;M-M&quot; means that one column in one table is related to another column in another table, and for every value of one of these two columns, there are one or more related values in the corresponding column in the other table (and vice-versa), or more a common possibility, two tables have a 1-M relationship to each other (two relationships, one 1-M going each way). A [bad] example of the more common situation would be if you had a job assignment database, where one table held one row for each employee and a job assignment, and another table held one row for each job with one of the assigned employees. Here, you would have multiple rows for each employee in the first table, one for each job assignment, and multiple rows for each job in the second table, one for each employee assigned to the project. These tables have a M-M: each employee in the first table <strong>has</strong> many job assignments from the second table, and each job <strong>has</strong> many employees assigned to it from the first table. This is the tip of the iceberg on this topic...see the links below for more information and see the diagram below for a simplified example of an E-R diagram.
<img src="http://zql.sourceforge.net/erdiagram.gif" alt="Sample Simplified Entity-Relationship Diagram"></li>
<li>What are some important nonstandard SQL features (extremely common question)? --Well, see the next section...</li>
</ul>
<p><a href=""></a><strong>Nonstandard SQL...&quot;check local listings&quot;</strong></p>
<ul>
<li>INTERSECT and MINUS are like the UNION statement, except that INTERSECT produces rows that appear in both queries, and MINUS produces rows that result from the first query, but not the second.</li>
<li>Report Generation Features: the COMPUTE clause is placed at the end of a query to place the result of an aggregate function at the end of a listing, like COMPUTE SUM (PRICE); Another option is to use break logic: define a break to divide the query results into groups based on a column, like BREAK ON BUYERID. Then, to produce a result after the listing of a group, use COMPUTE SUM OF PRICE ON BUYERID. If, for example, you used all three of these clauses (BREAK first, COMPUTE on break second, COMPUTE overall sum third), you would get a report that grouped items by their BuyerID, listing the sum of Prices after each group of a BuyerID&#39;s items, then, after all groups are listed, the sum of all Prices is listed, all with SQL-generated headers and lines.</li>
<li>In addition to the above listed aggregate functions, some DBMS&#39;s allow more functions to be used in Select lists, except that these functions (some character functions allow multiple-row results) are to be used with an individual value (not groups), on single-row queries.The functions are to be used only on appropriate data types, also. Here are some <strong>Mathematical Functions</strong>:
<strong>ABS(X)</strong> Absolute value-converts negative numbers to positive, or leaves positive numbers alone <strong>CEIL(X)</strong> X is a decimal value that will be rounded up. <strong>FLOOR(X)</strong> X is a decimal value that will be rounded down. <strong>GREATEST(X,Y)</strong> Returns the largest of the two values. <strong>LEAST(X,Y)</strong> Returns the smallest of the two values. <strong>MOD(X,Y)</strong> Returns the remainder of X / Y. <strong>POWER(X,Y)</strong> Returns X to the power of Y. <strong>ROUND(X,Y)</strong> Rounds X to Y decimal places. If Y is omitted, X is rounded to the nearest integer. <strong>SIGN(X)</strong> Returns a minus if X &lt; 0, else a plus. <strong>SQRT(X)</strong> Returns the square root of X. <strong>Character Functions</strong>
<strong>LEFT(<string>,X)</strong> Returns the leftmost X characters of the string. <strong>RIGHT(<string>,X)</strong> Returns the rightmost X characters of the string. <strong>UPPER(<string>)</strong> Converts the string to all uppercase letters. <strong>LOWER(<string>)</strong> Converts the string to all lowercase letters. <strong>INITCAP(<string>)</strong> Converts the string to initial caps. <strong>LENGTH(<string>)</strong> Returns the number of characters in the string. <strong><string>||<string></strong> Combines the two strings of text into one, concatenated string, where the first string is immediately followed by the second. <strong>LPAD(<string>,X,&#39;/*&#39;)</strong> Pads the string on the left with the /<em> (or whatever character is inside the quotes), to make the string X characters long. **RPAD(<string>,X,&#39;/</em>&#39;)<strong> Pads the string on the right with the /* (or whatever character is inside the quotes), to make the string X characters long. </strong>SUBSTR(<string>,X,Y)<strong> Extracts Y letters from the string beginning at position X. </strong>NVL(<column>,<value>)** The Null value function will substitute <value> for any NULLs for in the <column>. If the current value of <column> is not NULL, NVL has no effect.</li>
</ul>
<p><a href=""></a><strong>Syntax Summary--For Advanced Users Only</strong></p>
<p>Here are the general forms of the statements discussed in this tutorial, plus some extra important ones (explanations given). <strong>REMEMBER</strong> that all of these statements may or may not be available on your system, so check documentation regarding availability:</p>
<p><strong>ALTER TABLE</strong><TABLE NAME> ADD|DROP|MODIFY (COLUMN SPECIFICATION[S]...see Create Table); --allows you to add or delete a column or columns from a table, or change the specification (data type, etc.) on an existing column; this statement is also used to change the physical specifications of a table (how a table is stored, etc.), but these definitions are DBMS-specific, so read the documentation. Also, these physical specifications are used with the Create Table statement, when a table is first created. In addition, only one option can be performed per Alter Table statement--either add, drop, <strong>OR</strong>modify in a single statement.</p>
<p><strong>COMMIT</strong>; --makes changes made to some database systems permanent (since the last COMMIT; known as a transaction)</p>
<p><strong>CREATE [UNIQUE] INDEX</strong> <INDEX NAME>
ON <TABLE NAME> (<COLUMN LIST>); --UNIQUE is optional; within brackets.</p>
<p><strong>CREATE TABLE</strong> <TABLE NAME>
(<COLUMN NAME> <DATA TYPE> [(<SIZE>)] <COLUMN CONSTRAINT>,
...other columns); (also valid with ALTER TABLE)
--where SIZE is only used on certain data types (see above), and constraints include the following possibilities (automatically enforced by the DBMS; failure causes an error to be generated):</p>
<ol>
<li>NULL or NOT NULL (see above)</li>
<li>UNIQUE enforces that no two rows will have the same value for this column</li>
<li>PRIMARY KEY tells the database that this column is the primary key column (only used if the key is a one column key, otherwise a PRIMARY KEY (column, column, ...) statement appears after the last column definition.</li>
<li>CHECK allows a condition to be checked for when data in that column is updated or inserted; for example, CHECK (PRICE &gt; 0) causes the system to check that the Price column is greater than zero before accepting the value...sometimes implemented as the CONSTRAINT statement.</li>
<li>DEFAULT inserts the default value into the database if a row is inserted without that column&#39;s data being inserted; for example, BENEFITS INTEGER DEFAULT = 10000</li>
<li>FOREIGN KEY works the same as Primary Key, but is followed by: REFERENCES <TABLE NAME> (<COLUMN NAME>), which refers to the referential primary key.</li>
</ol>
<p><strong>CREATE VIEW</strong> <TABLE NAME> AS <QUERY>;</p>
<p><strong>DELETE</strong> FROM <TABLE NAME> WHERE <CONDITION>;</p>
<p><strong>INSERT</strong> INTO <TABLE NAME> [(<COLUMN LIST>)]
VALUES (<VALUE LIST>);</p>
<p><strong>ROLLBACK</strong>; --Takes back any changes to the database that you have made, back to the last time you gave a Commit command...beware! Some software uses automatic committing on systems that use the transaction features, so the Rollback command may not work.</p>
<p><strong>SELECT</strong> [DISTINCT|ALL] <LIST OF COLUMNS, FUNCTIONS, CONSTANTS, ETC.>
FROM <LIST OF TABLES OR VIEWS>
[WHERE <CONDITION(S)>]
[GROUP BY <GROUPING COLUMN(S)>]
[HAVING <CONDITION>]
[ORDER BY <ORDERING COLUMN(S)> [ASC|DESC]]; --where ASC|DESC allows the ordering to be done in ASCending or DESCending order</p>
<p><strong>UPDATE</strong> <TABLE NAME>
SET <COLUMN NAME> = <VALUE>
[WHERE <CONDITION>]; --if the Where clause is left out, all rows will be updated according to the Set statement</p>
<p><a href=""></a><strong>Important Links</strong></p>
<p>Computing &amp; SQL/DB Links: <a href="http://home.netscape.com/" target="_blank">Netscape</a> -- <a href="http://www.oracle.com/" target="_blank">Oracle</a> -- <a href="http://www.sybase.com/" target="_blank">Sybase</a> -- <a href="http://www.informix.com/" target="_blank">Informix</a> --<a href="http://www.microsoft.com/">Microsoft
</a><a href="http://www.contrib.andrew.cmu.edu/~shadow/sql.html" target="_blank">SQL Reference Page</a> -- <a href="http://www.inquiry.com/techtips/thesqlpro/" target="_blank">Ask the SQL Pro</a> -- <a href="http://www.inquiry.com/techtips/thesqlpro/usefulsites.html">SQL Pro&#39;s Relational DB Useful Sites
</a><a href="http://infoweb.magi.com/~steve/develop.html" target="_blank">Programmer&#39;s Source</a> -- <a href="http://info.itu.ch/special/wwwfiles/comp_db.html" target="_blank">DBMS Sites</a> -- <a href="http://www.inquiry.com/" target="_blank">inquiry.com</a> -- <a href="http://www.compapp.dcu.ie/databases/f017.html" target="_blank">DB Ingredients</a>
<a href="http://www.stars.com/Tutorial/CGI/" target="_blank">Web Authoring</a> -- <a href="http://wfn-shop.princeton.edu/cgi-bin/foldoc" target="_blank">Computing Dictionary</a> -- <a href="http://www-ccs.cs.umass.edu/db.html" target="_blank">DBMS Lab/Links</a> -- <a href="http://epoch.cs.berkeley.edu:8000/sequoia/dba/montage/FAQ/SQL_TOC.html" target="_blank">SQL FAQ</a> -- <a href="http://chaos.mur.csu.edu.au/itc125/cgi/sqldb.html" target="_blank">SQL Databases</a>
<a href="http://www.it.rit.edu/~wjs/IT/199602/icsa720/icsa720postings.html" target="_blank">RIT Database Design Page</a> -- <a href="http://www.pcslink.com/~ej/dbweb.html" target="_blank">Database Jump Site</a> -- <a href="http://www.eng.uc.edu/~jtilley/tutorial.html" target="_blank">Programming Tutorials on the Web</a>
<a href="http://www.ndev.com/ndc2/support/resources.htp" target="_blank">Development Resources</a> -- <a href="http://ashok.pair.com/sql.htm" target="_blank">Query List</a> -- <a href="http://jazz.external.hp.com/training/sqltables/main.html" target="_blank">IMAGE SQL</a></p>
<p>Miscellaneous: <a href="http://www.cnn.com/" target="_blank">CNN</a> -- <a href="http://www.usatoday.com/" target="_blank">USA Today</a> -- <a href="http://www.pathfinder.com/" target="_blank">Pathfinder</a> -- <a href="http://www.zdnet.com/" target="_blank">ZDNet</a> -- <a href="http://metroscope.com/" target="_blank">Metroscope</a> -- <a href="http://www.cnet.com/" target="_blank">CNet</a>
<a href="http://www.eit.com/web/netservices.html" target="_blank">Internet Resource List</a> -- <a href="http://netcast.noaa.gov/cgi-bin/page?pg=netcast" target="_blank">Netcast Weather</a> -- <a href="http://www.techweb.com/" target="_blank">TechWeb</a> -- <a href="http://www.looksmart.com/" target="_blank">LookSmart</a></p>
<p>Search Engines: <a href="http://www.yahoo.com/" target="_blank">Yahoo</a> -- <a href="http://www.altavista.digital.com/" target="_blank">Alta Vista</a> -- <a href="http://www.excite.com/" target="_blank">Excite</a> -- <a href="http://webcrawler.com/" target="_blank">WebCrawler</a> -- <a href="http://www.lycos.com/" target="_blank">Lycos</a> -- <a href="http://www.infoseek.com/" target="_blank">Infoseek</a> -- <a href="http://www.search.com/" target="_blank">search.com</a></p>
<p>These sites are not endorsed by the author.
<strong>Disclaimer</strong></p>
<p>I hope you have learned something from this introductory look at a very important language that is becoming more prevalent in the world of client-server computing. I wrote this web page in order to contribute something of value to the web and the web community. In fact, I have been informed that this document is being used at several colleges for use in database classes and for use by researchers. Also, look for this page in Waite Publishing&#39;s newest book about Borland C++ Builder, which will be out this summer, and in an upcoming Sams Publishing release. In addition, I would like to thank all of the people from across five continents who have contacted me regarding this web page.</p>
<p>I also hope to continue to add more material to this tutorial, such as topics about database design and nonstandard SQL extensions, even though I wish to stay away from material about individual Database Management Systems. Good luck in your SQL and other computing adventures.</p>
<p>Jim Hoffman
Comments or suggestions? Mail me at <a href="mailto:jhoffman@one.net">jhoffman@one.net.</a></p>
<p>Or you may wish to look at <a href="http://w3.one.net/~jhoffman/index.html" target="_blank">Jim Hoffman&#39;s Web Pages</a> for more information about myself.</p>
<p>Copyright 1996-1997, James Hoffman. This document can be used for free by any Internet user, but cannot be included in another document, published in any other form, or mass produced in any way.</p>
<p>This page is best viewed with <a href="http://home.netscape.com/" target="_blank">Netscape Navigator</a>; it doesn&#39;t look quite right with <a href="http://www.microsoft.com/ie" target="_blank">Microsoft Internet Explorer.</a></p>
<p>Last updated: 8-25-1997; added some material.</p>
<p><a href="http://w3.one.net/~jhoffman/sqltut.htm" target="_blank">http://w3.one.net/~jhoffman/sqltut.htm</a>
来源： <a href="[http://zql.sourceforge.net/sqltut.html](http://zql.sourceforge.net/sqltut.html)">[http://zql.sourceforge.net/sqltut.html](http://zql.sourceforge.net/sqltut.html)</a>  </p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/SQL_Java/">SQL_Java</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/SQL_Java/" class="label label-success">SQL_Java</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:41"datetime="2014-03-07 09:54:41"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-SQL_Java--IntroductiontoStructuredQueryLanguageZQL/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-SQL_Java--IntroductiontoStructuredQueryLanguageZQL" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_多线程-并发--深入浅出JavaConcurrency37-并发总结/">深入浅出 Java Concurrency (37)</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:41.000Z"> <a href="/2014/02/02/2014-02-02-JavaJ2EE-Java_多线程-并发--深入浅出JavaConcurrency37-并发总结/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-java-concurrency-37-">深入浅出 Java Concurrency (37): 并发总结</h1>
<p><a href="http://www.blogjava.net/xylz/archive/2011/12/29/365149.html" target="_blank">深入浅出 Java Concurrency (37): 并发总结 part 1 死锁与活跃度</a></p>
<h1 id="-">死锁与活跃度</h1>
<p>前面谈了很多并发的特性和工具，但是大部分都是和锁有关的。我们使用锁来保证线程安全，但是这也会引起一些问题。</p>
<ul>
<li>锁顺序死锁(lock-ordering deadlock)：多个线程试图通过不同的顺序获得多个相同的资源，则发生的循环锁依赖现象。</li>
<li>动态的锁顺序死锁（Dynamic Lock Order Deadlocks）：多个线程通过传递不同的锁造成的锁顺序死锁问题。</li>
<li>资源死锁（Resource Deadlocks）：线程间相互等待对方持有的锁，并且谁都不会释放自己持有的锁发生的死锁。也就是说当现场持有和等待的目标成为资源，就有可能发生此死锁。这和锁顺序死锁不一样的地方是，竞争的资源之间并没有严格先后顺序，仅仅是相互依赖而已。</li>
</ul>
<h2 id="-">锁顺序死锁</h2>
<p>最经典的锁顺序死锁就是LeftRightDeadLock.
<img src="" alt=""></p>
<p>public class LeftRightDeadLock {
    final Object left = new Object();
    final Object right = new Object();
    public void doLeftRight() {
        synchronized (left) {
            synchronized (right) {
                execute1();
            }
        }
    }
    public void doRightLeft() {
        synchronized (right) {
            synchronized (left) {
                execute2();
            }
        }
    }
    private void execute2() {
    }
    private void execute1() {
    }
}</p>
<p>这个例子很简单，当两个线程分别获取到left和right锁时，互相等待对方释放其对应的锁，很显然双方都陷入了绝境。</p>
<h2 id="-">动态的锁顺序死锁</h2>
<p>与锁顺序死锁不同的是动态的锁顺序死锁只是将静态的锁变成了动态锁。 一个比较生动的例子是这样的。</p>
<p>public void transferMoney(Account fromAccount,//
        Account toAccount,//
        int amount
        ) {
    synchronized (fromAccount) {
        synchronized (toAccount) {
            fromAccount.decr(amount);
            toAccount.add(amount);
        }
    }
}
当我们银行转账的时候，我们期望锁住双方的账户，这样保证是原子操作。 看起来很合理，可是如果双方同时在进行转账操作，那么就有可能发生死锁的可能性。</p>
<p>很显然，动态的锁顺序死锁的解决方案应该看起来和锁顺序死锁解决方案差不多。 但是一个比较特殊的解决方式是纠正这种顺序。 例如可以调整成这样：
Object lock = new Object();
public void transferMoney(Account fromAccount,//
        Account toAccount,//
        int amount
        ) {
    int order = fromAccount.name().compareTo(toAccount.name());
    Object lockFirst = order&gt;0?toAccount:fromAccount;
    Object lockSecond = order&gt;0?fromAccount:toAccount;
    if(order==0){
        synchronized(lock){
            synchronized(lockFirst){
                synchronized(lockSecond){
                    //do work
                }
            }
        }
    }else{
        synchronized(lockFirst){
            synchronized(lockSecond){
                //do work
            }
        }
    }
}</p>
<p>这个挺有意思的。比较两个账户的顺序，保证此两个账户之间的传递顺序总是按照某一种锁的顺序进行的， 即使多个线程同时发生，也会遵循一次操作完释放完锁才进行下一次操作的顺序，从而可以避免死锁的发生。</p>
<h2 id="-">资源死锁</h2>
<p>资源死锁比较容易理解，就是需要的资源远远大于已有的资源，这样就有可能线程间的资源竞争从而发生死锁。 一个简单的场景是，应用同时从两个连接池中获取资源，两个线程都在等待对方释放连接池的资源以便能够同时获取 到所需要的资源，从而发生死锁。</p>
<p>资源死锁除了这种资源之间的直接依赖死锁外，还有一种叫线程饥饿死锁（thread-starvation deadlock）。 严格意义上讲，这种死锁更像是活跃度问题。例如提交到线程池中的任务由于总是不能够抢到线程从而一直不被执行， 造成任务的“假死”状况。</p>
<p>除了上述几种问题外，还有协作对象间的死锁以及开发调用的问题。这个描述起来会比较困难，也不容易看出死锁来。</p>
<h1 id="-">避免和解决死锁</h1>
<p>通常发生死锁后程序难以自恢复。但也不是不能避免的。 有一些技巧和原则是可以降低死锁可能性的。</p>
<p>最简单的原则是尽可能的减少锁的范围。锁的范围越小，那么竞争的可能性也越小。 尽快释放锁也有助于避开锁顺序。如果一个线程每次最多只能够获取一个锁，那么就不会产生锁顺序死锁。尽管应用中比较困难，但是减少锁的边界有助于分析程序的设计和简化流程。 减少锁之间的依赖以及遵守获取锁的顺序是避免锁顺序死锁的有效途径。</p>
<p>另外尽可能的使用定时的锁有助于程序从死锁中自恢复。 例如对于上述顺序锁死锁中，使用定时锁很容易解决此问题。</p>
<p>public void doLeftRight() throws Exception {
    boolean over = false;
    while (!over) {
        if (left.tryLock(1, TimeUnit.SECONDS)) {
            try {
                if (right.tryLock(1, TimeUnit.SECONDS)) {
                    try {
                        execute1();
                    } finally {
                        right.unlock();
                        over = true;
                    }
                }
            } finally {
                left.unlock();
            }
        }
    }
}
public void doRightLeft() throws Exception {
    boolean over = false;
    while (!over) {
        if (right.tryLock(1, TimeUnit.SECONDS)) {
            try {
                if (left.tryLock(1, TimeUnit.SECONDS)) {
                    try {
                        execute2();
                    } finally {
                        left.unlock();
                        over = true;
                    }
                }
            } finally {
                right.unlock();
            }
        }
    }
}
看起来代码会比较复杂，但是这是避免死锁的有效方式。</p>
<h1 id="-">活跃度</h1>
<p>对于多线程来说，死锁是非常严重的系统问题，必须修正。除了死锁，遇到很多的就是活跃度问题了。 活跃度问题主要包括：饥饿，丢失信号，和活锁等。</p>
<h2 id="-">饥饿</h2>
<p>饥饿是指线程需要访问的资源被永久拒绝，以至于不能在继续进行。 比如说：某个权重比较低的线程可能一直不能够抢到CPU周期，从而一直不能够被执行。</p>
<p>也有一些场景是比较容易理解的。对于一个固定大小的连接池中，如果连接一直被用完，那么过多的任务可能由于一直无法抢占到连接从而不能够被执行。这也是饥饿的一种表现。</p>
<p>对于饥饿而言，就需要平衡资源的竞争，例如线程的优先级，任务的权重，执行的周期等等。总之，当空闲的资源较多的情况下，发生饥饿的可能性就越小。</p>
<h2 id="-">弱响应性</h2>
<p>弱响应是指，线程最终能够得到有效的执行，只是等待的响应时间较长。 最常见的莫过于GUI的“假死”了。很多时候GUI的响应只是为了等待后台数据的处理，如果线程协调不好，很有可能就会发生“失去响应”的现象。</p>
<p>另外，和饥饿很类似的情况。如果一个线程长时间独占一个锁，那么其它需要此锁的线程很有可能就会被迫等待。</p>
<h2 id="-">活锁</h2>
<p>活锁（Livelock）是指线程虽然没有被阻塞，但是由于某种条件不满足，一直尝试重试，却终是失败。</p>
<p>考虑一个场景，我们从队列中拿出一个任务来执行，如果任务执行失败，那么将任务重新加入队列，继续执行。假如任务总是执行失败，或者某种依赖的条件总是不满足，那么线程一直在繁忙却没有任何结果。</p>
<p>错误的循环引用和判断也有可能导致活锁。当某些条件总是不能满足的时候，可能陷入死循环的境地。</p>
<p>线程间的协同也有可能导致活锁。例如如果两个线程发生了某些条件的碰撞后重新执行，那么如果再次尝试后依然发生了碰撞，长此下去就有可能发生活锁。</p>
<p>解决活锁的一种方案是对重试机制引入一些随机性。例如如果检测到冲突，那么就暂停随机的一定时间进行重试。这回大大减少碰撞的可能性。</p>
<p>另外为了避免可能的死锁，适当加入一定的重试次数也是有效的解决办法。尽管这在业务上会引起一些复杂的逻辑处理。
来源： <a href="[http://www.blogjava.net/xylz/archive/2011/12/29/365149.html](http://www.blogjava.net/xylz/archive/2011/12/29/365149.html)">[http://www.blogjava.net/xylz/archive/2011/12/29/365149.html](http://www.blogjava.net/xylz/archive/2011/12/29/365149.html)</a> </p>
<h1 id="-">常见的并发场景</h1>
<h2 id="-">线程池</h2>
<p>并发最常见用于线程池，显然使用线程池可以有效的提高吞吐量。</p>
<p>最常见、比较复杂一个场景是Web容器的线程池。Web容器使用线程池同步或者异步处理HTTP请求，同时这也可以有效的复用HTTP连接，降低资源申请的开销。通常我们认为HTTP请求时非常昂贵的，并且也是比较耗费资源和性能的，所以线程池在这里就扮演了非常重要的角色。</p>
<p>在<a href="http://www.blogjava.net/xylz/archive/2010/12/19/341098.html" target="_blank">线程池</a>的章节中非常详细的讨论了线程池的原理和使用，同时也提到了，线程池的配置和参数对性能的影响是巨大的。不尽如此，受限于资源（机器的性能、网络的带宽等等）、依赖的服务，客户端的响应速度等，线程池的威力也不会一直增长。达到了线程池的瓶颈后，性能和吞吐量都会大幅度降低。</p>
<p>一直增加机器的性能或者增大线程的个数，并不一定能有效的提高吞吐量。高并发的情况下，机器的负载会大幅提升，这时候机器的稳定性、服务的可靠性都会下降。</p>
<p>尽管如此，线程池依然是提高吞吐量的一个有效措施，配合合适的参数能够有效的充分利用资源，提高资源的利用率。</p>
<h2 id="-">任务队列</h2>
<p>除了线程池是比较发杂的并发场景外，<a href="http://www.blogjava.net/xylz/archive/2010/07/21/326723.html" target="_blank">任务队列</a>也是一个不错的并发工具。JDK内部有大量的队列（Queue),这些工具不仅能够方便使用，提高生产力，也能够进行组合适应于不同的场景。即使线程池内部，也是用了任务队列来处理任务的积压，平衡资源的消耗。</p>
<p>安全的任务队列能够有效的平衡机器的复杂，抵消由于峰值和波动带来的不稳定，有效提高服务的可靠性。同时任务队列的处理也有助于统计和分析服务的状况。</p>
<p>任务队列也可以在多个线程之间传递数据，有助于并行处理任务。例如经典的“生产者-消费者”模型就可以有效的提高多个线程的并行处理能力。在IO延时比较大的服务中尤其有效。 我最喜欢的一个案例是导数据是，一个线程负责往固定大小的任务队列中压入大量的数据，队列满了以后就暂停，另外几个线程负责从任务队列中获取数据并消费。这将串行的“生产-消费”，变成了并行的“生产-消费”。实践证明极大的节省任务处理时间。</p>
<h2 id="-">异步处理</h2>
<p>线程池也是异步处理的一种表现形式，除此之外，使用异步处理的目的也是为了提高服务的处理速度。 例如AOP的一个例子就是使用切面来记录日志，如果说我们要远程收集日志，显然不希望由于收集日志而影响服务本身。这时候就将日志收集的过程进行异步处理。</p>
<p>如今大量的开源组件都喜欢使用异步处理来提高IO的效率，某些不需要同步返回的操作使用异步处理后能够有效的提高吞吐量。</p>
<p>当然，异步也不总是令人满意的，也会有相应的问题。例如引入异步设计后的复杂性，线程中断后的处理机制，失败后的处理策略，产生的消息比消费的还快时怎么办，关闭程序时如何关闭异步处理逻辑等等。这都会增加系统的复杂性。</p>
<p>尽管大量的服务、业务使用异步来处理，但是很显然需要有保障机制能够保证异步处理的逻辑正确性。如果认为异步处理的任务不是特别重要，或者说主业务不能因为附属业务的逻辑出错而崩溃，那么使用异步处理是正确的选择。</p>
<h2 id="-">同步操作</h2>
<p>并发操作的同时还需要维护数据的一致性，或多或少的会涉及到同步操作。正确的使用原子操作，合理的使用独占锁和读写锁也是一个很大的挑战。</p>
<p>线程间的协调与通信，尤其是状态的同步都是比较困难的。我们看到线程池<a href="http://www.blogjava.net/xylz/archive/2011/01/18/343183.html" target="_blank">ThreadPoolExecutor</a>的实现为了解决各个线程的执行状态，引入的很多的同步操作。线程越来越多的情况下，同步的成本会越来越高，同时也有可能引入死锁的情况。</p>
<p>尽管如此，单个JVM内部的多线程同步还是比较容易控制的。JDK内部也提供了大量的工具来方便完成数据的同步。例如<a href="http://www.blogjava.net/xylz/archive/2010/07/05/325274.html" target="_blank">Lock</a>/<a href="http://www.blogjava.net/xylz/archive/2010/07/08/325540.html" target="_blank">Condition</a>/<a href="http://www.blogjava.net/xylz/archive/2010/07/09/325612.html" target="_blank">CountDownLatch</a>/<a href="http://www.blogjava.net/xylz/archive/2010/07/12/325913.html" target="_blank">CyclicBarrier</a>/<a href="http://www.blogjava.net/xylz/archive/2010/07/13/326021.html" target="_blank">Semaphore</a>/<a href="http://www.blogjava.net/xylz/archive/2010/11/22/338733.html" target="_blank">Exchanger</a>等等。</p>
<h2 id="-">分布式锁</h2>
<p>分布式的并发问题更难以处理，根据<a href="http://en.wikipedia.org/wiki/CAP_theorem" target="_blank">CAP</a>的原理，基本上没有一个至善至美的方案。 分布式资源协调使用分布式锁是一个不错的选择。<a href="http://blog.nosqlfan.com/html/1038.html" target="_blank">Google的分布式锁</a>（建立在BigTable之上），<a href="http://zookeeper.apache.org/doc/r3.3.2/zookeeperOver.html" target="_blank">Zookeeper的分布式锁</a>，甚至简单的利用<a href="http://memcached.org/" target="_blank">memcache</a>的add操作或者<a href="http://redis.io/" target="_blank">redis</a>的setnx操作建立伪分布式锁也可以解决类似的问题。
来源： <a href="[http://www.blogjava.net/xylz/archive/2011/12/29/367480.html](http://www.blogjava.net/xylz/archive/2011/12/29/367480.html)">[http://www.blogjava.net/xylz/archive/2011/12/29/367480.html](http://www.blogjava.net/xylz/archive/2011/12/29/367480.html)</a> </p>
<h1 id="-">常见的并发陷阱</h1>
<h2 id="volatile">volatile</h2>
<p>volatile只能强调数据的可见性，并不能保证原子操作和线程安全，因此volatile不是万能的。参考<a href="http://www.blogjava.net/xylz/archive/2010/07/03/325168.html" target="_blank">指令重排序</a></p>
<p>volatile最常见于下面两种场景。</p>
<p>a. 循环检测机制
volatile boolean done = false;
<img src="" alt="">
    while( ! done ){
        dosomething();
    }</p>
<p>b. 单例模型 （<a href="http://www.blogjava.net/xylz/archive/2009/12/18/306622.html%ef%bc%89" target="_blank"><a href="http://www.blogjava.net/xylz/archive/2009/12/18/306622.html）">http://www.blogjava.net/xylz/archive/2009/12/18/306622.html）</a>
</a></p>
<p><a href="http://www.blogjava.net/xylz/archive/2009/12/18/306622.html%ef%bc%89">public class DoubleLockSingleton {
    private static volatile DoubleLockSingleton instance = null;
    private DoubleLockSingleton() {
    }
    public static DoubleLockSingleton getInstance() {
        if (instance == null) {
            synchronized (DoubleLockSingleton.class) {
                if (instance == null) {
                    instance = new DoubleLockSingleton();
                }
            }
        }
        return instance;
    }
}</a></p>
<h2 id="synchronized-lock">synchronized/Lock</h2>
<p>看起来Lock有更好的性能以及更灵活的控制，是否完全可以替换synchronized？</p>
<p>在<a href="http://www.blogjava.net/xylz/archive/2010/07/16/326246.html" target="_blank">锁的一些其它问题</a>中说过，synchronized的性能随着JDK版本的升级会越来越高，而Lock优化的空间受限于CPU的性能，很有限。另外JDK内部的工具（线程转储）对synchronized是有一些支持的（方便发现死锁等），而对Lock是没有任何支持的。</p>
<p>也就说简单的逻辑使用synchronized完全没有问题，随着机器的性能的提高，这点开销是可以忽略的。而且从代码结构上讲是更简单的。简单就是美。</p>
<p>对于复杂的逻辑，如果涉及到读写锁、条件变量、更高的吞吐量以及更灵活、动态的用法，那么就可以考虑使用Lock。当然这里尤其需要注意Lock的正确用法。
Lock lock = <img src="" alt="">
lock.lock();
try{
    //do something
}finally{
    lock.unlock();
}</p>
<p>一定要将Lock的释放放入finally块中，否则一旦发生异常或者逻辑跳转，很有可能会导致锁没有释放，从而发生死锁。而且这种死锁是难以排查的。</p>
<p>如果需要synchronized无法做到的尝试锁机制，或者说担心发生死锁无法自恢复，那么使用tryLock()是一个比较明智的选择的。
Lock lock = <img src="" alt="">
if(lock.tryLock()){
    try{
        //do something
    }finally{
        lock.unlock();
    }
}</p>
<p>甚至可以使用获取锁一段时间内超时的机制Lock.tryLock(long,TimeUnit)。 锁的使用可以参考前面文章的描述和建议。</p>
<h2 id="-">锁的边界</h2>
<p>一个流行的错误是这样的。
ConcurrentMap<String,String> map = new ConcurrentHashMap<String,String>();
if(!map.containsKey(key)){
    map.put(key,value);
}</p>
<p>看起来很合理的，对于一个线程安全的Map实现，要存取一个不重复的结果，先检测是否存在然后加入。 其实我们知道两个原子操作和在一起的指令序列不代表就是线程安全的。 割裂的多个原子操作放在一起在多线程的情况下就有可能发生错误。</p>
<p>实际上ConcurrentMap提供了putIfAbsent(K, V)的“原子操作”机制，这等价于下面的逻辑：
if(map.containsKey(key)){
    return map.get(key);
}else{
    return map.put(k,v);
}</p>
<p>除了putIfAbsent还有replace(K, V)以及replace(K, V, V)两种机制来完成组合的操作。</p>
<p>提到Map，这里有一篇谈<a href="http://www.blogjava.net/xylz/archive/2009/12/18/306602.html" target="_blank">HashMap读写并发</a>的问题。</p>
<h2 id="-">构造函数启动线程</h2>
<p>下面的实例是在构造函数中启动一个线程。
public class Runner{
   int x,y;
   Thread thread;
   public Runner(){
      this.x=1;
      this.y=2;
      this.thread=new MyThread();
      this.thread.start();
   }
}</p>
<p>这里可能存在的陷阱是如果此类被继承，那么启动的线程可能无法正确读取子类的初始化操作。</p>
<p>因此一个简单的原则是，禁止在构造函数中启动线程，可以考虑但是提供一个方法来启动线程。如果非要这么做，最好将类设置为final，禁止继承。</p>
<h2 id="-">丢失通知的问题</h2>
<p><a href="http://www.blogjava.net/xylz/archive/2011/09/05/326988.html" target="_blank">这篇文章</a>里面提到过notify丢失通知的问题。</p>
<p>对于wait/notify/notifyAll以及await/singal/singalAll，如果不确定到底是否能够正确的收到消息，担心丢失通知，简单一点就是总是通知所有。</p>
<p>如果担心只收到一次消息，使用循环一直监听是不错的选择。</p>
<p>非常主用性能的系统，可能就需要区分到底是通知单个还是通知所有的挂起者。</p>
<h2 id="-">线程数</h2>
<p>并不是线程数越多越好，在下一篇文章里面会具体了解下性能和可伸缩性。 简单的说，线程数多少没有一个固定的结论，受限于CPU的内核数，IO的性能以及依赖的服务等等。因此选择一个合适的线程数有助于提高吞吐量。</p>
<p>对于CPU密集型应用，线程数和CPU的内核数一致有助于提高吞吐量，所有CPU都很繁忙，效率就很高。 对于IO密集型应用，线程数受限于IO的性能，某些时候单线程可能比多线程效率更高。但通常情况下适当提高线程数，有利于提高网络IO的效率，因为我们总是认为网络IO的效率比较低。</p>
<p>对于线程池而言，选择合适的线程数以及任务队列是提高线程池效率的手段。
public ThreadPoolExecutor(
    int corePoolSize,
    int maximumPoolSize,
    long keepAliveTime,
    TimeUnit unit,
    BlockingQueue<Runnable> workQueue,
    ThreadFactory threadFactory,
    RejectedExecutionHandler handler)</p>
<p>对于线程池来说，如果任务总是有积压，那么可以适当提高corePoolSize大小；如果机器负载较低，那么可以适当提高maximumPoolSize的大小；任务队列不长的情况下减小keepAliveTime的时间有助于降低负载；另外任务队列的长度以及任务队列的<a href="http://www.blogjava.net/xylz/archive/2011/01/18/343183.html" target="_blank">拒绝策略</a>也会对任务的处理有一些影响。
来源： <a href="[http://www.blogjava.net/xylz/archive/2011/12/30/367592.html](http://www.blogjava.net/xylz/archive/2011/12/30/367592.html)">[http://www.blogjava.net/xylz/archive/2011/12/30/367592.html](http://www.blogjava.net/xylz/archive/2011/12/30/367592.html)</a> </p>
<h1 id="-">性能与伸缩性</h1>
<p>使用线程的一种说法是为了提高性能。多线程可以使程序充分利用闲置的资源，提高资源的利用率，同时能够并行处理任务，提高系统的响应性。 但是很显然，引入线程的同时也引入了系统的复杂性。另外系统的性能并不是总是随着线程数的增加而总是提高。</p>
<h2 id="-">性能与伸缩性</h2>
<p>性能的提升通常意味着可以用更少的资源做更多的事情。这里资源是包括我们常说的CPU周期、内存、网络带宽、磁盘IO、数据库、WEB服务等等。 引入多线程可以充分利用多核的优势，充分利用IO阻塞带来的延迟，也可以降低网络开销带来的影响，从而提高单位时间内的响应效率。</p>
<p>为了提高性能，需要有效的利用我们现有的处理资源，同时也要开拓新的可用资源。例如，对于CPU而言，理想状况下希望CPU能够满负荷工作。当然这里满负荷工作是指做有用的事情，而不是无谓的死循环或者等待。受限于CPU的计算能力，如果CPU达到了极限，那么很显然我们充分利用了计算能力。对于IO而言（内存、磁盘、网络等），如果达到了其对于的带宽，这些资源的利用率也就上去了。理想状况下所有资源的能力都被用完了，那么这个系统的性能达到了最大值。</p>
<p>为了衡量系统的性能，有一些指标用于定性、定量的分析。例如服务时间、等待时间、吞吐量、效率、可伸缩性、生成量等等。服务时间、等待时间等用于衡量系统的效率，即到底有多快。吞吐量、生成量等用于衡量系统的容量，即能够处理多少数据。除此之外，有效服务时间、中断时间等用于能力系统的可靠性和稳定性等。</p>
<p>可伸缩性的意思是指增加计算资源，吞吐量和生产量相应得到的改进。 从算法的角度讲，通常用复杂度来衡量其对应的性能。例如时间复杂度、空间复杂度等。</p>
<h2 id="amdahl-">Amdahl定律</h2>
<p>并行的任务增加资源显然能够提高性能，但是如果是串行的任务，增加资源并不一定能够得到合理的性能提升。 <a href="http://en.wikipedia.org/wiki/Amdahl%27s_law" target="_blank">Amdahl定律</a>描述的在一个系统中，增加处理器资源对系统行的提升比率。 假定在一个系统中，F是必须串行化执行的比重，N是处理器资源，那么随着N的增加最多增加的加速比：
<img src="" alt=""></p>
<p>理论上，当N趋近于无穷大时，加速比最大值无限趋近于1/F。 这意味着如果一个程序的串行化比重为50%，那么并行化后最大加速比为2倍。</p>
<p>加速比除了可以用于加速的比率外，也可以用于衡量CPU资源的利用率。如果每一个CPU的资源利用率为100%，那么CPU的资源每次翻倍时，加速比也应该翻倍。 事实上，在拥有10个处理器的系统中，程序如果有10%是串行化的，那么最多可以加速1/(0.1+(1-0.1)/10)=5.3倍，换句话说CPU的利用率只用5.3/10=53%。而如果处理器增加到100倍，那么加速比为9.2倍，也就是说CPU的利用率只有个9.3%。</p>
<p>显然增加CPU的数量并不能提高CPU的利用率。下图描述的是随着CPU的数量增加，不同串行化比重的系统的加速比。
<img src="" alt=""></p>
<p>很显然，串行比重越大，增加CPU资源的效果越不明显。</p>
<h2 id="-">性能提升</h2>
<p>性能的提升可以从以下几个方面入手。</p>
<h3 id="-">系统平台的资源利用率</h3>
<p>一个程序对系统平台的资源利用率是指某一个设备繁忙且服务于此程序的时间占所有时间的比率。从物理学的角度讲类似于有用功的比率。简单的说就是：资源利用率=有效繁忙时间/总耗费时间。</p>
<p>也就说尽可能的让设备做有用的功，同时榨取其最大值。无用的循环可能会导致CPU 100%的使用率，但不一定是有效的工作。有效性通常难以衡量，通常只能以主观来评估，或者通过被优化的程序的行为来判断是否提高了有效性。</p>
<h3 id="-">延迟</h3>
<p>延迟描述的是完成任务所耗费的时间。延迟有时候也成为响应时间。如果有多个并行的操作，那么延迟取决于耗费时间最大的任务。</p>
<h3 id="-">多处理</h3>
<p>多处理是指在单一系统上同时执行多个进程或者多个程序的能力。多处理能力的好处是可以提高吞吐量。多处理可以有效利用多核CPU的资源。</p>
<h3 id="-">多线程</h3>
<p>多线程描述的是同一个地址空间内同时执行多个线程的过程。这些线程都有不同的执行路径和不同的栈结构。我们说的并发性更多的是指针对线程。</p>
<h3 id="-">并发性</h3>
<p>同时执行多个程序或者任务称之为并发。单程序内的多任务处理或者多程序间的多任务处理都认为是并发。</p>
<h3 id="-">吞吐量</h3>
<p>吞吐量衡量系统在单位之间内可以完成的工作总量。对于硬件系统而言，吞吐量是物理介质的上限。在没有达到物理介质之前，提高系统的吞吐量也可以大幅度改进性能。同时吞吐量也是衡量性能的一个指标。</p>
<h3 id="-">瓶颈</h3>
<p>程序运行过程中性能最差的地方。通常而言，串行的IO、磁盘IO、内存单元分配、网络IO等都可能造成瓶颈。某些使用太频繁的算法也有可能成为瓶颈。</p>
<h3 id="-">可扩展性</h3>
<p>这里的可扩展性主要是指程序或系统通过增加可使用的资源而增加性能的能力。</p>
<h2 id="-">线程开销</h2>
<p>假设引入的多线程都用于计算，那么性能一定会有很大的提升么？ 其实引入多线程以后也会引入更多的开销。</p>
<h3 id="-">切换上下文</h3>
<p>如果可运行的线程数大于CPU的内核数，那么OS会根据一定的调度算法，强行切换正在运行的线程，从而使其它线程能够使用CPU周期。</p>
<p>切换线程会导致上下文切换。线程的调度会导致CPU需要在操作系统和进程间花费更多的时间片段，这样真正执行应用程序的时间就减少了。另外上下文切换也会导致缓存的频繁进出，对于一个刚被切换的线程来说，可能由于高速缓冲中没有数据而变得更慢，从而导致更多的IO开销。</p>
<h3 id="-">内存同步</h3>
<p>不同线程间要进行数据同步，synchronized以及volatile提供的可见性都会导致缓存失效。线程栈之间的数据要和主存进行同步，这些同步有一些小小的开销。如果线程间同时要进行数据同步，那么这些同步的线程可能都会受阻。</p>
<h3 id="-">阻塞</h3>
<p>当发生锁竞争时，失败的线程会导致阻塞。通常阻塞的线程可能在JVM内部进行自旋等待，或者被操作系统挂起。自旋等待可能会导致更多的CPU切片浪费，而操作系统挂起则会导致更多的上下文切换。</p>
<p>了解了性能的提升的几个方面，也了解性能的开销后，应用程序就要根据实际的场景进行取舍和评估。没有一劳永逸的优化方案，不断的进行小范围改进和调整是提高性能的有效手段。当前一些大的架构调整也会导致较大的性能的提升。</p>
<p>简单的原则是在保证逻辑正确的情况小，找到性能瓶颈，小步改进和优化。</p>
<h2 id="-">参考资料</h2>
<ul>
<li>Amdahl&#39;s law: <a href="http://en.wikipedia.org/wiki/Amdahl%27s_law" target="_blank"><a href="http://en.wikipedia.org/wiki/Amdahl%27s_law">http://en.wikipedia.org/wiki/Amdahl%27s_law</a></a></li>
<li>Gustafson&#39;s law: <a href="http://en.wikipedia.org/wiki/Gustafson%27s_law" target="_blank"><a href="http://en.wikipedia.org/wiki/Gustafson%27s_law">http://en.wikipedia.org/wiki/Gustafson%27s_law</a></a></li>
<li>Sun-Ni law: <a href="http://en.wikipedia.org/wiki/Sun-Ni_law" target="_blank"><a href="http://en.wikipedia.org/wiki/Sun-Ni_law">http://en.wikipedia.org/wiki/Sun-Ni_law</a></a></li>
<li>多核系统中三种典型锁竞争的加速比分析 <a href="http://blog.csdn.net/drzhouweiming/article/details/1800319" target="_blank"><a href="http://blog.csdn.net/drzhouweiming/article/details/1800319">http://blog.csdn.net/drzhouweiming/article/details/1800319</a></a></li>
<li>阿姆达尔定律和Gustafson定律的等价性 <a href="http://book.51cto.com/art/201004/197506.htm" target="_blank"><a href="http://book.51cto.com/art/201004/197506.htm">http://book.51cto.com/art/201004/197506.htm</a></a>
来源： <a href="[http://www.blogjava.net/xylz/archive/2011/12/31/367641.html](http://www.blogjava.net/xylz/archive/2011/12/31/367641.html)">[http://www.blogjava.net/xylz/archive/2011/12/31/367641.html](http://www.blogjava.net/xylz/archive/2011/12/31/367641.html)</a> </li>
</ul>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li></span><span class="breadcrumb"><li><a href="/categories/Java&J2EE/">Java&J2EE</a></li><li><a href="/categories/Java&J2EE/Java_多线程/">Java_多线程</a></li><li><a href="/categories/Java&J2EE/Java_多线程/并发/">并发</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Java&J2EE/" class="label label-primary">Java&J2EE</a><a href="/tags/Java_多线程/" class="label label-success">Java_多线程</a><a href="/tags/并发/" class="label label-info">并发</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:41"datetime="2014-03-07 09:54:41"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-JavaJ2EE-Java_多线程-并发--深入浅出JavaConcurrency37-并发总结/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-JavaJ2EE-Java_多线程-并发--深入浅出JavaConcurrency37-并发总结" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>





<ul id="pagination" class="pagination pagination-lg">
  <li><a class="extend prev" href="/page/59/">&laquo;</a></li><li><a class="page-number" href="/">1</a></li><li><a class="page-number" href="/page/2/">2</a></li><li><span class="space">&hellip;</span></li><li><a class="page-number" href="/page/57/">57</a></li><li><a class="page-number" href="/page/58/">58</a></li><li><a class="page-number" href="/page/59/">59</a></li><li class="active"><li><span class="page-number current">60</span></li><li><a class="page-number" href="/page/61/">61</a></li><li><a class="page-number" href="/page/62/">62</a></li><li><a class="page-number" href="/page/63/">63</a></li><li><span class="space">&hellip;</span></li></li><li><a class="page-number" href="/page/164/">164</a></li><li><a class="page-number" href="/page/165/">165</a></li><li><a class="extend next" href="/page/61/">&raquo;</a></li>
  <div class="clearfix"></div>
</ul></div><!--wapper-->
       </div><!-- ID main-col END -->
       <aside id="sidebar" class="alignright col-sx-6 col-sm-4 col-md-3 col-lg-3">
<div id="widget_search" class="widget panel panel-primary">
    <form action="//google.com/search" method="get" accept-charset="utf-8">
  <div class="input-group">
    <input class="form-control" id="searchbox" type="search" name="q" results="0" placeholder="search">
    <span class="input-group-btn">
      <button class="btn btn-default" type="submit">Go!</button>
    </span>
    <input type="hidden" name="q" value="site:itsolife.com">
  </div>
</form>
</div>

<div id="widget_category" class="widget panel panel-primary">
  <div class="panel-heading">category</div>  <div data-src='category' class='ajax_widgets'>正在加载...</div>
</div>

<div id="widget_recent_posts" class="widget panel panel-primary">
  <div class="panel-heading">recent posts</div>  <div data-src='recent_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_tagcloud" class="widget panel panel-primary">
  <div class="panel-heading">tagcloud</div>  <div data-src='tagcloud' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_latest_update_posts" class="widget panel panel-primary">
  <div class="panel-heading">最近更新</div>  <div data-src='latest_update_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_recent_comments" class="widget panel panel-primary">
  <div class="panel-heading">recent comments</div>  

<div class="list-group-item ds-recent-comments" data-num-items="6" data-show-avatars="1" data-show-time="1" data-show-title="1" data-show-admin="1" data-excerpt-length="50"></div>



</div>

</aside>
       <div class="clearfix"></div>
     </div><!-- row END -->
  </div>
  <footer id="footer" class="container">
  <div class="panel panel-info">
  <section id='footer_widget'></section>  <div class="panel-footer">
  <div id="site-info">
    <span class='author'>
  
  &copy; 2014 RobinChia
  
    &nbsp;&nbsp;</span>
  
  <span id='analytics-51la'></span><span id='analytics-google'>
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-48559895-1']);
  _gaq.push(['_trackPageview']);
  _js2load.push({src:('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'});
</script></span><span id='analytics-cnzz'>
<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_5774006'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s17.cnzz.com/stat.php%3Fid%3D5774006%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>
</span><span id='analytics-baidu'>
<script>
var _hmt = _hmt || [];
_js2load.push({src:"//hm.baidu.com/hm.js?1442f50724afc42380b51f097c43082c"});
</script>
</span>  </div>
  <div id="copyright">Blog powered by <a href='http://zespia.tw/hexo/'><strong>hexo</strong></a> Theme <strong><a href='https://github.com/chenall/hexo-theme-chenall'>chenall</a></strong>(Some change in it)<span class="pull-right"> 更新时间: <em>2014-03-15 13:06:28</em></span></div>
</div>
<div class="clearfix"></div>


  </div>
  </footer>
  
        <script src="http://cdn.bootcss.com/jquery/1.10.2/jquery.min.js"></script>        
        <script src="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/js/bootstrap.min.js"></script>        
                
        <script src="http://cdn.bootcss.com/prettify/r298/prettify.min.js"></script>    <script type="text/javascript">
   var lang=["bsh", "c", "cc", "cpp", "cs", "csh", "cyc", "cv", "htm", "html",
    "java", "js", "m", "mxml", "perl", "pl", "pm", "py", "rb", "sh",
    "xhtml", "xml", "xsl"];
   var pretty_base='';
   $('script').each(function(){
	var c = $(this).attr('src');
	if (!c)
	    return;
	if (c.match(/(\/)?prettify(\.min)?\.js/i))
	{
	    var index = c.lastIndexOf('/');
	    if (index != -1)
		pretty_base = c.substr(0,index + 1);
	    return false;
	}
   })
   $('pre code').each(function(){
	var c = $(this).attr('class')
	if (!c)
	    return;
	c = c.match(/\s?(lang\-\w+)/i);
	if (c && lang.indexOf(c[1]) == -1)
	{
	    lang.push(c[1]);
	    $.getScript(pretty_base + c[1] + '.min.js');
	}
   })

    $(window).load(function(){
       $("pre").addClass("prettyprint");
       prettyPrint();
    })
</script>    
            <script type="text/javascript">
var duoshuoQuery = {short_name:"robinchia"};
_js2load.push({src:'http://static.duoshuo.com/embed.js',charset:'UTF-8'});
</script>
    
            <!--wumii_relatedItems-->
    
        <script src="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js"></script>    <script type="text/javascript">
(function($){
  $('.entry').each(function(i){
    $(this).find('img').each(function(){
      var alt = this.alt;

      if (alt){
        $(this).before('<span class="caption">' + alt + '</span>');
      }

      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox" rel="fancybox' + i + '" />');
    });
  });

  $('.fancybox').fancybox();
})(jQuery);
</script>    
        <script src="http://cdn.bootcss.com/mathjax/2.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>    <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>
    
<script type="text/javascript">
$('.ajax_widgets').each(function(){var src=$(this).attr('data-src');if(src)$(this).load('/widgets/'+src+'.html');});
$.each(_js2load,function(index,obj){loadjs(obj.src,obj.charset)});
</script>

<div id="scroll2top">
<img src="/scroll2top/arrow.png"/>
</div>
<script src="/scroll2top/scroll2top.min.js"></script>
<div id="winterland">
  <canvas></canvas>
</div>
<script src="/js/winterland.min.js"></script>

  </body>
</html>
