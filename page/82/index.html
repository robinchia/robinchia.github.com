
<!DOCTYPE HTML>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>The 82 Page | It so life</title>
<meta name="author" content="RobinChia">

<meta name="description" content="It so life">


<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<meta property="og:site_name" content="It so life"/>

<!--[if IE]><style>.testIE.IE{display:inline;}</style><![endif]-->
<!--[if lte IE 7]><link rel="stylesheet" href="/css/ie7.css" type="text/css"><![endif]-->
<!--[if (lt IE 9)&(gt IE 7)]><style>.testIE.IE8{display:inline;}</style><![endif]-->
<!--[if gt IE 8]><style>.testIE.IE9{display:inline;}</style><![endif]-->

<link href="/favicon.png" rel="icon">
<link rel="alternate" href="/atom.xml" title="It so life Feed" type="application/atom+xml">

<link rel="stylesheet" href="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/css/bootstrap.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/font-awesome/4.0.3/css/font-awesome.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/prettify/r298/prettify.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" type="text/css">
<link rel="stylesheet" href="/css/style.css" type="text/css">
<!--[if lt IE 9]>
   <style>article,aside,dialog,footer,header,section,footer,nav,figure,menu{display:block}</style>
   <script src="http://cdn.staticfile.org/html5shiv/r29/html5.min.js"></script>
   <script src="http://cdn.staticfile.org/respond.js/1.4.2/respond.min.js"></script>
<link href="http://cdn.staticfile.org/respond.js/1.4.2/respond-proxy.html" id="respond-proxy" rel="respond-proxy" />
<link href="/js/respond.proxy.gif" id="respond-redirect" rel="respond-redirect" />
<script src="/js/respond.proxy.js"></script>
   <script src="http://cdn.bootcss.com/selectivizr/1.0.2/selectivizr-min.js"></script>
<![endif]-->
<script type="text/javascript">
function loadjs(c,d){var a=document.createElement("script");a.async=!0;a.type="text/javascript";a.src=c;a.charset=d||"gbk";(document.getElementsByTagName("HEAD")[0]||document.getElementsByTagName("BODY")[0]).appendChild(a)};
var _protocol = (("https:" == document.location.protocol) ? " https://" : " http://");
var _js2load = [];
</script>

</head>
<body>
      <header id="header" class="container"><nav id="main-nav" class="navbar navbar-default navbar-fixed-top " role="navigation">
  <div class="container">
    <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
      <span class="sr-only">Toggle navigation</span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="/">It so life</a>
    </div>
    <div  class="collapse navbar-collapse">
      <ul  class="nav navbar-nav">
  
        <li><a href="/" title="Home">Home</a></li>      
        <li><a href="/about/" title="About">About</a></li>      
        <li><a href="/archives/" title="Archives">Archives</a></li>      
      <li class='dropdown'>
        <a class='dropdown-toggle' data-toggle='dropdown' href='#'>website<b class='caret'></b></a>
        <ul class='dropdown-menu pure-menu-selected'>
    
          <li><a href="//groups.google.com/forum/#!forum/pongba" title="TopLanguage">TopLanguage</a></li>    
          <li><a href="//itpub.net/" title="ITPub">ITPub</a></li>    
          <li><a href="//blog.jobbole.com/" title="Bole">Bole</a></li>    
          <li><a href="//nosql-database.org/" title="nosql">nosql</a></li>    
          <li><a href="//gitimmersion.googol.im/" title="Git">Git</a></li>    
        </ul>
      </li>
    
      </ul>
      <ul class="nav navbar-nav navbar-right">
      
        <li><a href="/atom.xml">RSS</a></li>
      
      
        <li><a href="https://twitter.com/robinchia">twitter</a></li>
      
      
      
      
        <li><a href="https://github.com/robinchia">github</a></li>
      
      </ul>
    </div>
  </div>
</nav>
<div class="clearfix"></div>
</header>
  <div id='content' class="container">
     <div class="page-header-wrapper">
      <!--[if lt IE 9]><div class="alert alert-warning alert-dismissable"><button type="button" class="close" data-dismiss="alert" aria-hidden="true">&times;</button><strong>提示:</strong>您的浏览器版本太低了,建议升级到 <strong><a href="http://windows.microsoft.com/zh-cn/internet-explorer/download-ie" title="IE9">IE9</a></strong> 以上,本站使用<a href="https://www.google.com/intl/zh-CN/chrome/">Chrome浏览器</a>可以获得最好的显示效果.</div><![endif]-->
      <div class="page-header"><h1 align="center"><big>It so life</big> </h1>
        <h5 align="center"><big>love as life</big></h5>
      </div>
     </div>
     <div class="row">
       <div id="main-col" class="alignleft col-sx-12 col-sm-8 col-md-9 col-lg-9">
      <section id='header_widget'></section>
          <div id="wrapper"><article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-缓存--Web开发人员需知的Web缓存知识/">Web开发人员需知的Web缓存知识</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:39.000Z"> <a href="/2014/02/02/2014-02-02-缓存--Web开发人员需知的Web缓存知识/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="web-web-">Web开发人员需知的Web缓存知识</h1>
<p>原文出处： <a href="http://www.mnot.net/cache_docs/" target="_blank">mnot</a>   译文出处： <a href="http://www.zhangxinxu.com/wordpress/2013/05/caching-tutorial-for-web-authors-and-webmasters/" target="_blank">张鑫旭</a></p>
<p>最近的译文距今已有4年之久，原文有一定的更新。今天踩着前辈们的肩膀，再次把这篇文章翻译整理下。一来让自己对web缓存的理解更深刻些，二来让大家注意力稍稍转移下，不要整天HTML5, 面试题啊叨啊叨的~~</p>
<h3 id="-web-">什么是Web缓存，为什么要使用它？</h3>
<p><em>Web缓存</em>游走于服务器和客户端之间。这个服务器可能是源服务器（资源所驻留的服务器Add），数量可能是1个或多个；这个客户端也可能是1个或多个。<em>Web缓存</em>就在服务器-客户端之间搞监控，监控请求，并且把请求输出的内容（例如html页面、 图片和文件）（统称为<em>副本</em>）另存一份；然后，如果下一个请求是相同的URL，则直接请求保存的副本，而不是再次麻烦源服务器。</p>
<p>使用缓存的2个主要原因：</p>
<ul>
<li><strong>降低延迟：</strong>缓存离客户端更近，因此，从缓存请求内容比从源服务器所用时间更少，呈现速度更快，网站就显得更灵敏。</li>
<li><strong>降低网络传输：</strong>副本被重复使用，大大降低了用户的带宽使用，其实也是一种变相的省钱（如果流量要付费的话），同时保证了带宽请求在一个低水平上，更容易维护了。</li>
</ul>
<h3 id="web-">Web缓存的类型</h3>
<p><strong>1. <a href="http://blog.jobbole.com/12749/" title="浏览器" target="_blank">浏览器</a>缓存</strong>
在任何<a href="http://blog.jobbole.com/12749/" title="现代浏览器" target="_blank">现代浏览器</a>上(如IE, FireFox, Chrome)折腾清除隐私数据（//zxx: 原文说的是首选项，显然out了，这里有改动）的对话框，你很可能会注意到“缓存”这个设置项。</p>
<p><a href="http://cdn2.jobbole.com/2013/06/cache-for-web-master-01.png" title="web制作、开发人员需知的Web缓存知识" target="_blank"><img src="&quot;web制作、开发人员需知的Web缓存知识&quot;" alt="web制作、开发人员需知的Web缓存知识"></a></p>
<p>浏览器会在你的硬盘上专门开辟一个空间专门为你存储资源副本。浏览器缓存的工作规则很简单：检查以确保副本是最新的，通常只要一次会话（就是当前浏览器调用的这次N）。</p>
<p>浏览器缓存在用户触发“后退”操作或点击一个之前看过的链接的时候很管用。同样，如果你在网站上访问同一张图片，该图片可以从浏览器缓存中调出并几乎立即显现出来。</p>
<p><strong>2. 代理服务器缓存</strong>
Web代理服务器使用同样的缓存原理，只是规模更大。代理以同样的方式服务千万用户，大公司和ISP(Internet Server Provider, Internet服务提供商Add)经常在他们的防火墙或者单独的设备（也被称为<em>中介(intermediaries)</em>）上架设代理缓存。</p>
<p>由于代理服务器缓存并非客户端或者源服务器的一部分，而是处于网络中，请求需要以某种方式路由到它们。一种方法是手动设置，告诉浏览器的你常用的代理服务器(//zxx: 翻墙的时候常用的)，另外就是使用拦截。<em>拦截代理(Interception proxies)</em>把Web请求根据自己的底层网络重定向，因此，客户端无需配置，甚至都不需要知道它们。//zxx: 维基百科上提供的几种检测拦截代理服务器存在的方法add，您若有兴趣，可以<a href="http://en.wikipedia.org/wiki/Proxy_server#Detection" target="_blank">点击这里</a>查看。</p>
<p>代理缓存属于一种<em>共享缓存</em>；往往有大量的用户使用，因此，其在降低延时和网络流量上很有用，毕竟每个副本都被大量重用。//zxx: 这里我有疑问：就算是放在代理服务器上，每次获取还是要通过网络的啊，如何降低了网络流量呢？希望谁可以帮忙解惑下。</p>
<p><strong>3. 网关缓存</strong>
也被称为“反向代理缓存”或“替代缓存”。网关缓存同样是起中介作用的，不过不是（素不相识、不曾谋面的Add）网络管理员部署的，而多半是网站管理员（公司专门的运维工程师、或UED或程序组某人Add）他们自己部署，这样更容易扩展与维护。</p>
<p>可以有多种方法把请求路由到网关缓存，但通常使用某种形式的负载均衡器①，使它们中的一个或多个看起来像是源服务器。<em>内容分发网络</em>②(CDNs)为整个网络（或部分）分配网关缓存，然后把这些缓存卖给需要的网站。<a href="http://www.speedera.com/" target="_blank">Speedera</a>③和<a href="http://www.akamai.com/" target="_blank">Akamai</a>④就是代表性的网络内容发布商。
①负载均衡器：是一种采用各种分配算法把网络请求分散到一个服务器集群中的可用服务器上去，通过管理进入的Web数据流量和增加有效的网络带宽，从而使网络访问者获得尽可能最佳的联网体验的硬件设备。</p>
<p>②内容分发网络：即CDN, 基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。其目的是使用户可就近取得所需内容，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度。</p>
<p>③Speedera：是一家全球性的内容服务提供商，它与北美、欧洲以及亚太地区的1000多家大型运营商都有联系，并为那些不想在自己服务器上寄存内容的公司提供软件下载、媒体及其它服务管理等业务。05年的时候被下面要介绍的Akamai以$130m的价格给收购了。</p>
<p>④Akamai：美国Akamai是国际上最大的CDN服务商，它巨大的网络分发能力在峰值时可达到15Tbps。Akamai公司是为数不多的旨在消除Internet瓶颈和提高下载速度的几家新公司之一，是一个致力于网络交通提速的”内容发布”公司，是波士顿高技术区最卓越的新兴企业之一。Akamai公司向全球企业提供发送互联网内容，汇流媒体和应用程序的服务（目前，该公司为15个国家的企业管理着8000多台服务器）。1998年，丹尼尔。L和麻省理工学院的一些研究人员一起创立了这家公司，他在麻省理工学院的硕士论文构成了Akamai公司最初的”自由流”（Freeflow）技术的核心。</p>
<p>本教程重点在浏览器和代理缓存，尽管有些信息对网关缓存感兴趣的人也适用。</p>
<h3 id="web-">Web缓存无害吗？为什么要鼓励缓存？</h3>
<p>Web缓存是互联网中最容易被误解的技术之一。网站管理员特别希望知道网站的一举一动，比方说多少人访问啦，访问时间啊什么的，而缓存会“隐藏”他们的用户，他们就无从得知到底谁访问了这个站点。</p>
<p>捡了芝麻丢西瓜，自认为放弃缓存可以精确跟踪用户，实际上，互联网中有太多的变数，想精确得到一张用户查看网站的图片？没那么简单的，亲！如果你很重视这个问题，恭喜你，本文正好提供了解决之道，即保证缓存友好，同时又能获得统计。</p>
<p>另外需要注意的是，缓存的内容都是旧的过时的。因此，如何准确更新就成了一个问题。不过不要担心，本文会向你展示如何配置服务器，让缓存就像你的女仆——随便调教。</p>
<p><a href="http://cdn2.jobbole.com/2013/06/cache-for-web-master-02.jpg" title="web制作、开发人员需知的Web缓存知识" target="_blank"><img src="&quot;web制作、开发人员需知的Web缓存知识&quot;" alt="web制作、开发人员需知的Web缓存知识"></a></p>
<p>CDN算是个挺有意思的技术，不同于代理缓存，CDN的网关缓存和被缓存的Web站点的利益是一致的，因此，上面提到的问题对于CDN而言是没有的。不过，即使你使用了CDN，你仍要顾虑下游的代理和浏览器缓存。</p>
<p>以上为缓存可能的“糟粕”，那他好的地方呢？缓存可以让你的Web站点加载更快，让你的服务器和互联网链接间负担更小。这种差异会导致一些类似质的变化，一个网站要几秒钟才能加载出来，而另外一个充分发挥缓存的优势，几乎瞬间显示。用户自然更喜欢那个加载迅速的站点，访问也更多。</p>
<p>再说个现实示例，许多大型互联网公司花费了数百万美元，在世界各地设立服务器集群来复制他们的内容，以使其尽可能快被他们的用户访问。缓存为你做同样的事情，而且他们更接近最终用户。最重要的是，你不要花银子。<img src="" alt=""></p>
<p>实际上呢，无论你喜欢与否，代理和浏览器缓存都会被使用。如果你站点的缓存配置不正确，你只能听天由命了。</p>
<h3 id="web-">Web缓存如何工作</h3>
<p>所以的缓存都有一套自己的规则，可以用来决定何时跟缓存暧昧往来。其中部分规则设定在协议中(HTTP 1.0 以及 1.1)，部分由缓存管理员⑤设置。
⑤缓存管理员：如果指的是浏览器缓存，则有可能就是我们服务器专家同事，在服务器上配置一些缓存规则；如果是代理缓存，则指的就是处理代理服务器这块的管理人员。</p>
<p>一般而言有如下常用规则N：</p>
<ol>
<li>响应头明确说明，偶不想被缓存，则不会被缓存；</li>
<li>如果请求信息是需要认证或者安全加密的(如, HTTPS)，相应内容也不会被缓存；</li>
<li>缓存如果有以下表现，则认为是<em>fresh</em>新鲜的（无需检查源服务器，直接发送给客户端）：</li>
</ol>
<ul>
<li>含有完整的过期时间和寿命控制头信息，并且内容仍在保鲜期内，或者</li>
<li>缓存最近已展现，并且在不久前修改。</li>
</ul>
<p>则内容缓存直取，绕过源服务器。</p>
<ul>
<li>若内容陈旧，则会要求源服务器做验证<em> validate </em>，或者告诉缓存其拷贝副本是否是OK的。</li>
<li>特定情况下——例如，断网了，之前有过的响应缓存直取而不检查源服务器。</li>
</ul>
<p>响应如果没有类似<em>ETag</em>或<em>Last-Modified</em>头这样的校验器，也没有明确的更新信息，通常（并不绝对）认为是不可缓存的。</p>
<p>总而言之，<strong>*新鲜度</strong>freshness<em>和**</em>校验<em>*validation</em>是确定缓存内容是否可用的最重要途径。如果要展示的足够新，直接缓存取；如果检测发现展示内容并未变化，则不会再来一次完整的传输。</p>
<h3 id="-">如何控制缓存和不缓存</h3>
<p>有很多工具可以帮助设计师和网站管理员调整服务器缓存网站的方式，这也许需要你亲自动手对服务器的配置进行一些调整，但绝对值得。了解如何使用这些工具请参考本文后面的章节。</p>
<p><strong>HTML Meta标签 vs. HTTP头信息</strong>
HTML<a href="http://www.amazon.cn/gp/product/B003BY6PLK/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;tag=vastwork-23&amp;linkCode=as2&amp;camp=536&amp;creative=3200&amp;creativeASIN=B003BY6PLK" title="重构:改善既有代码的设计" target="_blank">重构</a>人员可以在文档的</p>
<p><head>
中添加标签进行描述。这些<em>meta</em>标签通常用来标记不可缓存或过期时间。</p>
<p>Meta标签使用简单，但效果一般。因为只被少数几个浏览器宠幸，而代理缓存基本上就不访问HTML文档。尽管我们可以在页面上试图添加</p>
<p>no-cache
 meta标签让页面一直是最新的，但其实没必要。</p>
<p>如果你的网站托管在ISP或者主机托管商那里，并且他们没有赋予您任意设置HTTP头信息的能力(比如Expires和Cache-Control)，你要投诉争取，因为在你的工作中这些是必须的。</p>
<p>另外一方面： <em>HTTP头</em>信息可以让你对浏览器和代理服务器如何处理你的副本进行更多的控制。他们在HTML代码中是看不见的，一般由Web服务器自动生成。但是，根据你使用的服务器，你可以在某种程度上进行控制。在下文中：你将看到一些有趣的HTTP头信息，以及如何在你的站点上应用部署这些特性。</p>
<p>HTTP头信息发送在HTML代码之前，只能被浏览器和一些中间缓存能看到，一个典型的HTTP 1.1协议返回的头信息看上去像这样：
HTTP/1.1 200 OK</p>
<p>Date: Fri, 30 Oct 1998 13:19:41 GMT
Server: Apache/1.3.3 (Unix)</p>
<p>Cache-Control: max-age=3600, must-revalidate
Expires: Fri, 30 Oct 1998 14:19:41 GMT</p>
<p>Last-Modified: Mon, 29 Jun 1998 02:28:12 GMT
ETag: &quot;3e86-410-3596fbbc&quot;</p>
<p>Content-Length: 1040
Content-Type: text/html</p>
<p>头信息空一行后是HTML代码的输出，关于如何设置HTTP头信息请参考对应章节。</p>
<p><strong>Pragma HTTP头信息（以及为什么不起作用）</strong>
很多人认为在HTTP头信息中设置了</p>
<p>Pragma: no-cache
后会让内容无法被缓存。但事实并非如此：HTTP的规范中，响应型头信息没有任何关于Pragma属性的说明，只说明了请求头信息（浏览器发送给服务器的头信息）中的Pragma属性。虽然有少部分缓存会买账，但大部分无视，使用Pragma没作用。若要使用，试试下面的头信息。</p>
<p><strong>使用Expires HTTP头信息控制不过期</strong>
Expires HTTP头是控制缓存的基本手段，Expires的中文意思是“有效期”，显然，就是告诉浏览器缓存的有效期。如果过期，缓存会检查源服务器以确定文件是否改变了。Expires头几乎每个缓存都支持。</p>
<p>大部分的服务器允许你以多种方式设置Expires响应头。通常，他们允许设置一个绝对过期时间，然后对比最后一次访问的时候或者最后一次文档修改的时候决定客户端内容的获取方式。</p>
<p>对于静态图片（如导航或按钮的图片）而言，Expires头信息是相当有用的，因为图片不怎么修改，您可以给图片设置一个相当长的过期时间，这回让你的用户感觉网站变快了。Expires对于控制有改变规律的网页也很有用，例如：你有一个新闻聚合页面，每天早上6点钟准时更新，您可以设置缓存的过期时间也是这个点，于是缓存就可以很聪明地知道什么时候该去重载新的内容，什么时候睡大觉。</p>
<p>Expires头唯一的有效值是HTTP时间，其他值都会被认为是“前男友前女友”之类，不会去缓存的。注意：时间是格林威治时间（GMT），而不是本地时间。如下所示：
Expires: Fri, 30 Oct 1998 14:19:41 GMT</p>
<p>显然，如果你要使用Expires头，确保你的Web服务器时间的准备就非常重要了。使用网络时间协议⑥(Network Time Protocol – NTP)不失为一个号方法。如果你的身边有本地系统管理员，可以向他咨询，或者查看下面的百科Add 。</p>
<p>尽管Expires头很有用，但它有一定的局限性。首先，因为牵扯到时间，Web服务器端的时钟必须和缓存的同步，否则很可能实现不了预期的结果——缓存把前女友当初现女友，把现女友当作过去式——那就悲剧了。</p>
<p>另外一个问题是，你很容易忘记给某内容设置了一个特定时间，如果返回内容的时候没有更新这个过期时间，则每个请求都是上访到服务器，反而增加了负载和响应时间。
⑥网络时间协议(NTP): 以封包交换把两台电脑的时钟同步化的网络协议。NTP使用UDP端口123作为传输层。它是用作抵销可变延迟的影响。NTP是仍在使用中的最古老的网络协议之一（在1985年前开始）。NTP最初由德拉瓦州大学的Dave Mills设计，他与一群志愿者仍在维护NTP。</p>
<p><strong>Cache-Control（缓存控制）HTTP头信息</strong>
HTTP 1.1引入了新的头信息：</p>
<p>Cache-Control
响应头信息，让网站的发布者可以更全面的控制他们的内容，更好地处理Expires的些限制。</p>
<p>Cache-Control
有用的响应头包括：</p>
<ul>
<li><strong>max-age=[秒]</strong>：表示在这个时间范围内缓存是新鲜的无需更新。类似Expires时间，不过这个时间是相对的，而不是绝对的。也就是某次请求成功后多少秒内缓存是新鲜的。</li>
<li><strong>s-maxage=[秒]</strong>：类似</li>
</ul>
<p>max-age
, 除了仅应用于共享缓存（如代理）。</p>
<ul>
<li><strong>public</strong>：标记认证的响应才能够被缓存。一般而言，需要认证HTTP请求内容会自动私有化（不会被缓存Add）。</li>
<li><strong>private</strong>N：允许缓存专门为某一个用户存储响应，比方说在浏览器中；共享缓存一般不会，例如在代理中。</li>
<li><strong>no-cache</strong>：每次在释放缓存副本之前都强制发送请求给源服务器进行验证，这在确保认证有效性上很管用（和</li>
</ul>
<p>public
结合使用）或者保证内容必须是即时的，不得无视缓存的所有优点，如国内的微博、twitter等的刷新显示Add。</p>
<ul>
<li><strong>no-store</strong>：强制缓存在任何情况下都不要保留任何副本。</li>
<li><strong>must-revalidate</strong>：告诉缓存，我给你准备了一些关于新鲜度的信息，在表现的时候要严格遵循之。HTTP允许缓存在某些特定情况下返回过期数据，指定了这个属性，相对于告诉缓存，你丫必须严格遵循我的规则。</li>
<li><strong>proxy-revalidate</strong>：类似</li>
</ul>
<p>must-revalidate
，除了只能应用于代理缓存。</p>
<p>举个板栗：
Cache-Control: max-age=3600, must-revalidate</p>
<p>如果</p>
<p>Cache-Control
和</p>
<p>Expires
同时存在，</p>
<p>Cache-Control
说了算N。如果你打算使用</p>
<p>Cache-Control
头，你应该好好看看”<a href="http://www.ietf.org/rfc/rfc2616.txt" target="_blank">HTTP 1.1 规范</a>“, 详见参考文章以及拓展阅读。</p>
<p><strong>验证器和验证</strong>
在缓存如何工作这段译文中，我们说过，服务器以及缓存通过验证来判断内容是否改变，在不确定内容是否过期的时候，可以避免本地已经存在副本的时候下载整个内容。</p>
<p>验证器是很重要的，如果一个都没有，同时没有可用的新鲜度信息(</p>
<p>Expires
或</p>
<p>Cache-Control
)，缓存一点儿都不会存储内容。</p>
<p>最常见的验证是通过</p>
<p>Last-Modified
头信息通信确定文档最后的修改时间，如果缓存有内容存储，会包含</p>
<p>Last-Modified
信息的，辅助</p>
<p>If-Modified-Since
请求，我们可以询问服务器内容是否改变了。</p>
<p>HTTP 1.1引入了一个新的验证器，称为</p>
<p><em>Etag</em>
⑦. </p>
<p>Etag
是每次展现内容改变时候由服务器生成的唯一标识符，由于服务器控制</p>
<p>ETag
如何生成，当缓存发起</p>
<p>If-None-Match
请求的时候，如果</p>
<p>Etag
匹配，就可以确定展示内容其实是一样的。
⑦Etag: HTTP协议规格说明定义ETag为”被请求变量的实体值”。另一种说法是，ETag是一个可以与Web资源关联的记号（token）。典型的Web资源可以一个Web页，但也可能是JSON或XML文档。服务器单独负责判断记号是什么及其含义，并在HTTP响应头中将其传送到客户端，以下是服务器端返回的格式：ETag:”50b1c1d4f775c61:df3″客户端的查询更新格式是这样的：If-None-Match : W / “50b1c1d4f775c61:df3″如果ETag没改变，则返回状态304然后不返回，这也和Last-Modified一样。测试Etag主要在断点下载时比较有用。</p>
<p>几乎所有的缓存使用</p>
<p>Last-Modified
时间作为验证器，</p>
<p>Etag
验证也开始变得流行。</p>
<p>所有新一代的Web服务器都对静态内容（如：文件）自动生成</p>
<p>ETag
和</p>
<p>Last-Modified
头信息，而你不必做任何设置。但是，服务器对于动态内容（例如：CGI, ASP或数据库生成的网站）并不知道如何生成这些信息，参考一下编写支持缓存的脚本章节；</p>
<h3 id="-">创建支持缓存网站的小技巧</h3>
<p>除了使用新鲜度信息以及验证，还有其他一些技巧可以让你网站的缓存更加友好：</p>
<ul>
<li><strong>保持URL稳定</strong>：这是缓存的金科玉律，如果你为不同页面，不同用户或不同网站提供相同的内容，他们应该使用相同的URL. 这是简单却非常行之有效的方法。例如，你的HTML中的某个引用地址是</li>
</ul>
<p>&quot;/index.html&quot;
, 则要一直使用这个地址。</p>
<ul>
<li>不同地方的图片和其他元素<strong>使用同一库</strong>。</li>
<li><strong>对于不经常改变的图片/页面启用缓存</strong>，通过将</li>
</ul>
<p>Cache-Control: max-age
头信息的值设大一点。</p>
<ul>
<li><strong>对于定期更新的内容</strong>通过指定</li>
</ul>
<p>max-age
或过期时间实现缓存。</p>
<ul>
<li><strong>如果资源改变了（尤其下载文件），改变其名字</strong>。由于一般这种资源会有很长的过期时间，而服务器上一直是正确的版本；因此，链接这个下载资源的页面需要要比较短的过期时间（//zxx: 我司页面5分钟过期）。否则，会出现服务器的资源是新的，但页面被缓存了，其中的链接地址还是旧的，就会出现新旧版本冲突的可能Add。</li>
<li><strong>万不得已不要变动文件</strong>：否则你要设置一个新的</li>
</ul>
<p>Last-Modified
值。另外，当你更新站点的时候，只要上传改动的那些文件，而不要把整个站点都覆盖过去。</p>
<ul>
<li><strong>Cookie能不用就不用</strong>：Cookie难以被缓存，且大多情境下是没有必要的。如果你非得使用Cookie，建议用在动态页面上。</li>
<li><strong>减少SSL⑧的使用</strong>：因为共享缓存不能存储认证页面，只在必要的时候使用，并且在SSL页面上减少图片的使用。</li>
<li><strong>使用<a href="http://redbot.org/" target="_blank">REDbot</a>⑨检查你的网站</strong>：可以帮助你应用本文所介绍的一些概念。
⑧ SSL：全称Secure Socket Layer – 安全套接层，为Netscape所研发，用以保障在Internet上数据传输之安全，利用数据加密(Encryption)技术，可确保数据在网络上之传输过程中不会被截取及窃听。目前一般通用之规格为40 bit之安全标准，美国则已推出128 bit之更高安全标准，但限制出境。只要3.0版本以上之I.E.或Netscape浏览器即可支持SSL。</li>
</ul>
<p>⑨ REDbot：REDbot = RED + robot，是个机器人，检查HTTP资源，看他们如何会表现，指出常见的问题，并提出改进建议。虽然它属于HTTP一致性测试仪，但却可以找到不少HTTP相关问题。</p>
<h3 id="-">编写支持缓存的脚本</h3>
<p>默认情况下，大多数的脚本不会返回验证器（</p>
<p>Last-Modified
或</p>
<p>Etag
响应头）或新鲜度信息（</p>
<p>Expires
或</p>
<p>Cache-Control
）。尽管有些脚本的确是动态的（意味着每次请求都有不同的响应），还是有很多（如搜索引擎或数据库驱动的）网站可以从缓存中受益。</p>
<p>一般来讲，对于同一个请求（无论是几分钟还是几天之后），如果脚本产生的内容是可重复的，则可以缓存。脚本内容的改变仅仅依赖于URL，则可以缓存。如果是依赖于Cookie，认证信息或其他外部条件，很可能不缓存。</p>
<ul>
<li>最利于缓存的脚本就是在内容改变时导出成静态文件，服务器会想对待其他Web一样对待它的，生成以及使用验证器，于是你可以好好地喝杯咖啡了。记住，只有文件更改的时候才写入，这样Last-Modified时间就会被保存下来。</li>
<li>另外的脚本缓存之道就是使用</li>
</ul>
<p>age
相关的头部，相比</p>
<p>Expires
, </p>
<p>Cache-Control: max-age
更容易些，因为是相对时间，每次新请求完成后重新设置，时间到了，再重新请求，再设置新的相对过期时间。</p>
<ul>
<li>如果上面的做法你搞不定，你还可以试试通过脚本生成一个校验器, 然后回应</li>
</ul>
<p>If-Modified-Since
和/或</p>
<p>If-None-Match
请求。通过分析HTTP头信息，在适合的时候回应</p>
<p>304 Not Modified
. 不幸的是，这不是个打打酱油就能<a href="http://www.amazon.cn/gp/product/B007XPTAIS/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;tag=vastwork-23&amp;linkCode=as2&amp;camp=536&amp;creative=3200&amp;creativeASIN=B007XPTAIS" title="搞定(套装共3册) " target="_blank">搞定</a>的任务。</p>
<p><strong>其他一些技巧</strong></p>
<ul>
<li><strong>不要使用POST</strong>：若是获取数据，尽量不使用POST模式，因为POST方式返回内容大部分不会被缓存，相对的，通过GET以路径和查询发送的信息被缓存存储下来供后续使用。</li>
<li><strong>URL地址中不要嵌入特定的用户信息</strong>，除非生成的内容对于用户而言是唯一的。</li>
<li><strong>不要指望同一用户的所有请求来自同一主机</strong>，因为缓存经常协同工作。//zxx: 嘛意思？</li>
<li><strong>生成Content-Length⑩头信息</strong>。实现不难，可让你的脚本以持久连接(<em>persistent connection</em>)形式响应。这允许客户端在一个TCP/IP请求上请求多个内容，而不是为每次请求单独建立连接，这样你的网站相应会快很多。</li>
</ul>
<p>详见实现注意事项。
⑩Content-Length：指明实体正文的长度，以字节方式存储的十进制数字来表示。在数据下行的过程中，Content-Length的方式要预先在服务器中缓存所有数据，然后所有数据再一股脑儿地发给客户端。</p>
<h3 id="-">常见问题解答</h3>
<p><strong>缓存可用的最重要事情是？</strong>
其中一个不错的策略是找出常用的、规模较大的内容（尤其图片），然后优先处理之。</p>
<p><strong>我该如何利用缓存让我的页面尽可能的快？</strong>
最应该缓存的内容设置一个较长的过期时间。验证有助于减少查看内容的时间，不过缓存仍会连接源服务器查看是不是过期了。如果缓存已经知道内容是新鲜的，直接返回。</p>
<p><strong>我知道缓存是个好东西，但是我想随时知道多少人访问了我的网页！</strong>
如果你必须知道每一次页面被访问的情况，可以选择页面上的一个小元素(或页面本身)，然后给这个元素一个适当的头信息使它是不可缓存。比如，你可以在每一个页面上引用一个<em>1像素×1像素</em>的不可缓存（如scr地址后面加个随机数Add）的透明图片。Referer头信息将会包含调用它的页面信息。</p>
<p>请注意，即使这样也不能给出你用户的精确统计，并且对通过互联网访问的用户也不是很友好：产生不必要的流量，并强迫用户等待未被缓存的内容从网络上下载回来。更多的信息可参见拓展阅读中的“<a href="http://www.goldmark.org/netrants/webstats/" target="_blank">解读访问统计</a>”对应内容。</p>
<p><strong>我该如何查看HTTP头？</strong>
许多浏览器可以查看</p>
<p>Expires
和</p>
<p>Last-Modified
头信息，如右键→查看页面信息或类似面板。例如，在Firefox浏览器下Add：</p>
<p><a href="http://cdn2.jobbole.com/2013/06/cache-for-web-master-025.png" title="web制作、开发人员需知的Web缓存知识" target="_blank"><img src="&quot;web制作、开发人员需知的Web缓存知识&quot;" alt="web制作、开发人员需知的Web缓存知识"></a><a href="http://cdn2.jobbole.com/2013/06/cache-for-web-master-03.png" title="web制作、开发人员需知的Web缓存知识" target="_blank"><img src="&quot;web制作、开发人员需知的Web缓存知识&quot;" alt="web制作、开发人员需知的Web缓存知识"></a></p>
<p>表示要看到完整的头，您可以使用Telnet⑪客户端手动连接到Web服务器上。</p>
<p>为此，你可能需要用一个字段指定端口（默认是80），或者连接到</p>
<p>www.example.com:80
或者</p>
<p>www.example.com 80
(注意是空格)，更多设置请参考一下telnet客户端的文档。</p>
<p>一旦连接到该网站，输入请求。比如，你想查看</p>
<p><a href="http://www.example.com/foo.html" target="_blank">http://www.example.com/foo.html</a>
的头信息，首先连接到</p>
<p>www.example.com
, 使用80端口，并输入：
GET /foo.html HTTP/1.1 [return]</p>
<p>Host: www.example.com [return][return]</p>
<p>[return]
等同敲回车键，最后输入两次确认。这样就会输出头信息，然后跟着实际内容。如果只想看到头信息，使用</p>
<p>HEAD
来替换</p>
<p>GET
.</p>
<p>⑪Telnet：Telnet协议是<a href="http://www.amazon.cn/gp/product/B004JZY9BI/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;tag=vastwork-23&amp;linkCode=as2&amp;camp=536&amp;creative=3200&amp;creativeASIN=B004JZY9BI" title="TCP/IP协议族" target="_blank">TCP/IP协议族</a>中的一员，是Internet远程登陆服务的标准协议和主要方式。它为用户提供了在本地计算机上完成远程主机工作的能力。在终端使用者的电脑上使用telnet程序，用它连接到服务器。终端使用者可以在telnet程序中输入命令，这些命令会在服务器上运行，就像直接在服务器的控制台上输入一样。可以在本地就能控制服务器。要开始一个telnet会话，必须输入用户名和密码来登录服务器。Telnet是常用的远程控制Web服务器的方法。</p>
<p><strong>我的页面是密码保护的，代理缓存是怎么处理的？</strong>
默认情况下，HTTP验证保护的页面是私有的，共享缓存是不能保存的。然而，你可以通过</p>
<p>Cache-Control: public
头的设置使其公有。HTTP 1.1标准兼容的缓存服务器可以使之缓存。</p>
<p>如果你希望这些缓存的页面在用户查看之前还要验证一下，可以组合使用</p>
<p>Cache-Control: public
和</p>
<p>no-cache
头，这相对于告诉缓存器它从缓存中送出内容前必须递交客户端的验证给原始服务器。这个头信息如下所示：
Cache-Control: public, no-cache</p>
<p>不管怎么，这是最小化验证最好的方法；例如，你的图片不敏感，你可以把它放在分离的目录中，并配置你的服务对它们不做强制验证。这样，那些图片就会很自然的被缓存了。</p>
<p><strong>如果人们通过缓存访问我的网站，我应该担心安全吗？</strong>
SSL页面不会被代理服务器缓存，所以这个你不需要担心。但是，代理服务器就好非SSL页面请求以及URL抓取这口，你懂的，这是不安全的。无良的管理员可能就会收集网站用户的信息，尤其在URL中。</p>
<p>事实上，任何网络管理员都可以收集你的客户端和服务器端之间的这类信息。CGI ⑫脚本有个漏洞，会把用户名和密码放在自身的URL地址中，这很容易让其他人发现用户的登陆信息。</p>
<p>如果你懂得互联网安全的些基本机制，就不会对代理缓存感到任何惊讶。
⑫CGI：通用网关接口(Common Gateway Interface). 用于初始化软件服务的服务器方接口。这套接口描述了Web服务器与同一计算机上的软件的通信方式。</p>
<p>通用网关接口，它是一段程序，运行在服务器上，提供同客户端HTML页面的接口，通俗的讲CGI就像是一座桥，把网页和WEB服务器中的执行程序连接起来，它把HTML接收的指令传递给服务器，再把服务器执行的结果返还给HTML页；用CGI可以实现处理表格，数据库查询，发送电子邮件等许多操作，最常见的CGI程序就是计数器。CGI使网页变得不是静态的，而是交互式的。</p>
<p><strong>我在寻找一个集成的Web发布解决方案。哪些是可缓存的？</strong>
这个是不确定的。一般来说，越复杂的系统越难缓存。最差的情况就是所有的内容都是动态生成，并且不提供校验器，与缓存压根无缘。你可以和你供应商的技术人员沟通获取更多信息，并参考下面实现注意事项。</p>
<p><strong>我的图片缓存一个月后才到期，我现在就想变动！</strong></p>
<p>Expires
头是绕不过去的，除非缓存（浏览器或者代理）空间不足才会删除副本，缓存副本会一直使用。</p>
<p>最有效的方法是修改链接，这样会从源服务器获取完整的新内容。请记住，调用图片的这个页面也会被缓存的，正因如此，我们需要让图片以及其他类似的静态资源易缓存，而页面呢可以随着自身的改变（例如改变了一个图片的URL地址Add）即时更新。</p>
<p>如果你想摆脱特定缓存，重载内容，可以试试强制刷新（在FireFox中，shift键+reload按钮等同于处理</p>
<p>Pragma: no-cache
请求头）或者让缓存管理员使用某些接口删除内容。</p>
<p><strong>我运行一个Web Hosting服务。我怎样才能让我的用户发布缓存友好的网页？</strong>
如果你使用apahe，可以考虑允许他们使用</p>
<p>.htaccess
文件并提供相应的文档。</p>
<p>否则你需要在每一个虚拟主机上为各种缓存属性建立预定的区域。比如：你可以指定一个叫</p>
<p>/cache-1m
的目录用来放读取后要缓存一个月的内容，然后再建一个</p>
<p>/no-cache
的目录，并在头信息中指定这么目录中的内容不被缓存。</p>
<p>不管上面你做的如何，总之最好优先给用户量大的客户做缓存处理。大部分服务器节约的流量以及负载都是来自高容量的网站。</p>
<p><strong>我明明告诉网页要好好缓存，但它老是去请求，怎么破？</strong>
缓存服务器并不总是要求内容要保持并重用，某些条件下，他们是不保存不重用的，所有的缓存服务器都回基于文件的大小、类型（图片、页面…），或者服务器空间的剩余来确定如何缓存。如果你的文件比较大或很热门，可能就不会被缓存。有些缓存服务器允许管理员决定哪些内容要存储，有些缓存服务器允许内容长存缓存中，所以，它们总是可用的。</p>
<h3 id="-web-">实现需注意的：Web服务器端</h3>
<p>一般说来，应该选择最新版本的Web服务器程序来部署。不仅因为它们包含更多利于缓存的功能，新版本往往在性能和安全性方面都有很多的改善。</p>
<p><strong>Apache HTTP服务器</strong>
<a href="http://www.apache.org/" target="_blank">Apache</a>使用可选模块包含头信息，头信息</p>
<p>Expires
和</p>
<p>Cache-Control
一并包含。这些模块在1.2版本以上都支持。</p>
<p>这些模块需要编译到Apache中，虽然包含，但是默认并未开启。为了确定相应模块已经被启用，找到httpd⑬程序，运行</p>
<p>httpd -l
, 它会列出可用的模块（注意，仅有内部编译的模块列表才会显示，在较新版本的Apache中，使用</p>
<p>httpd -M
可以包含动态加载的模块N），我们需要关注的是expires模块(</p>
<p>expires_module
)和headers模块(</p>
<p>headers_module
)。
⑬httpd：httpd是Apache超文本传输协议(HTTP)服务器的主程序。被设计为一个独立运行的后台进程，它会建立一个处理请求的子进程或线程的池。</p>
<ul>
<li>如果这些模块不可用，你需要联系管理员，重新编译以包含这些模块。这些模块可以通过取消配置文件中的注释掉启用，或者在编译的时候增加</li>
</ul>
<p>-enable -module=expires
和</p>
<p>-enable-module=headers
参数(apache 1.3+). 参开Apache中的INSTALL文件。</p>
<p>一旦你的Apache有了相应的模块，你可以使用</p>
<p>mod_expires
指定过期的时间，要么在</p>
<p>.htaccess
文件，要么在服务器的</p>
<p>access.conf
文件。你可以设置过期时间是从访问时间开始还是文件修改时间开始，并应用到特定类型文件上或设为默认配置。查看官方<a href="http://www.apache.org/docs/mod/mod_expires.html" target="_blank">该模块文档</a>获得更多信息，或者遇到问题的时候向你身边的apache专家讨教。</p>
<p>为应用</p>
<p>Cache-Control
头，你需要使用</p>
<p>mod_headers
模块，其允许你为资源指定任意的头信息。可参考<a href="http://www.apache.org/docs/mod/mod_headers.html" target="_blank">mod_headers官方文档</a>。</p>
<p>下面是</p>
<p>.htaccess
文件展示了如何使用头信息：</p>
<ul>
<li>.htaccess
文件允许Web发布者使用配置文件中的指定。可以影响目录以及子目录内容。和你的服务器管理员沟通下，看看它们是否可用。</li>
</ul>
<p>/#/#/# activate mod_expires</p>
<p>ExpiresActive On
/#/#/# Expire .gif&#39;s 1 month from when they&#39;re accessed</p>
<p>ExpiresByType image/gif A2592000
/#/#/# Expire everything else 1 day from when it&#39;s last modified</p>
<p>/#/#/# (this uses the Alternative syntax)
ExpiresDefault &quot;modification plus 1 day&quot;</p>
<p>/#/#/# Apply a Cache-Control header to index.html</p>
<Files index.html>

<p>Header append Cache-Control &quot;public, must-revalidate&quot;
</Files></p>
<ul>
<li>注意，在有些情况下，</li>
</ul>
<p>mod_expires
会自动计算并插入</p>
<p>Cache-Control:max-age
头信息。</p>
<p>Apache 2′s的配置和1.3类似，更多信息可以参考2.2N的<a href="http://httpd.apache.org/docs/2.2/mod/mod_expires.html" target="_blank">mod_expires</a>和<a href="http://httpd.apache.org/docs/2.2/mod/mod_headers.html" target="_blank">mod_headers</a>文档。</p>
<p><strong>微软IIS</strong>
微软的IIS有一些灵活的方式可以很容易得设置头信息，不过似乎只针对IIS 4.0服务器，并且只能在NT服务器上运行。</p>
<p>为了给网站某区域指定头信息，需要进入</p>
<p>Administration
(管理员)工具面板，然后再设置属性。选择</p>
<p>HTTP Headers
选项卡后，你会看到两个有意思的区域：</p>
<p>Enable Content Expiration
和</p>
<p>Custom HTTP headers
, 第一个含义一目了然，第二个用来应用</p>
<p>Cache-Control
头。//zxx: 此处的操作描述很过时了，看看window7下，操作界面早就大变样了！</p>
<p><a href="http://cdn2.jobbole.com/2013/06/cache-for-web-master-035.png" title="web制作、开发人员需知的Web缓存知识" target="_blank"><img src="&quot;web制作、开发人员需知的Web缓存知识&quot;" alt="web制作、开发人员需知的Web缓存知识"></a><a href="http://cdn2.jobbole.com/2013/06/cache-for-web-master-04.png" title="web制作、开发人员需知的Web缓存知识" target="_blank"><img src="&quot;web制作、开发人员需知的Web缓存知识&quot;" alt="web制作、开发人员需知的Web缓存知识"></a></p>
<p>设置ASP页面(Active Server Pages)的头信息可以参考后面的ASP章节，也可以通过ISAPI模块设置头信息，细节请参考MSDN。</p>
<p><strong>Netscape/iPlanet企业服务器</strong>
3.6版本以后，企业版服务器已经不能以任何方式设置</p>
<p>Expires
头信息了。然而，其从3.0版本开始支持HTTP 1.1的功能。这意味着HTTP 1.1的缓存（代理服务器/浏览器）利用你对</p>
<p>Cache-Control
的设置来获得。</p>
<p>为了使用</p>
<p>Cache-Control
头，在管理员服务器中选择</p>
<p>Content Management | Cache Control Directives
（内容管理|缓存控制指令）。然后，使用资源选择器(Resource Picker)，选择你希望设置头信息的目录。设置完头信息后，点击”确定”。更多信息请参考<a href="http://www.redhat.com/docs/manuals/ent-server/" target="_blank">NES手册</a>。</p>
<h3 id="-">实现需注意的：服务端脚本</h3>
<p>时刻谨记，在Web服务器上设置HTTP要比通过脚本设置轻松些。你可以两者都试试。</p>
<p>因为服务器端的脚本主要是为了动态内容，所以即使实际上内容可以被缓存的，其也不会生成缓存很强的页面。如果你的页面内容经常变动，但不是每个页面都中枪，可以考虑设置</p>
<p>Cache-Control: max-age
头信息，大部分用户是在相对端的时间内再次访问这个页面。例如：用户点击“后退”按钮，如果没有任何验证或新鲜度信息，他们将不得不等待，直到从服务器页面重新下载才能看到它。</p>
<p><strong>CGI</strong>
CGI脚本是生成内容最常用的技术之一。你可以轻轻松松在请求发送给主体之前添加HTTP请求信息。大部分CGI实现都需要添加</p>
<p>Content-Type
头信息，例如这个Perl脚本：//zxx: 还是挺好懂的
&lt;/#!/usr/bin/perl</p>
<p>print &quot;Content-type: text/htmln&quot;;
print &quot;Expires: Thu, 29 Oct 1998 17:04:19 GMTn&quot;;</p>
<p>print &quot;n&quot;;
/#/#/# the content body follows.../pre&gt;</p>
<p>由于都是文本，你可以很容易通过内置函数生成</p>
<p>Expires
和其他日期相关的头信息。如果你使用</p>
<p>Cache-Control: max-age
会更简单：</p>
<p>print &quot;Cache-Control: max-age=600n&quot;;</p>
<p>上面脚本可以让请求完成后缓存10分钟，因此，当用户点击“后退”按钮的时候，就不会重新涂胶请求了。</p>
<p>CGI的规范同时也允许在脚本环境中，客户端发送请求头信息，每个头信息都有一个’HTTP_’的前缀。于是乎，如果一个客户端发送一个</p>
<p>If-Modified-Since
请求，就是这样的：
HTTP_IF_MODIFIED_SINCE</p>
<p>可观摩<a href="http://www.mnot.net/cgi_buffer/" target="_blank">cgi_buffer</a>库，其可以自动实现</p>
<p>Etag
生成和验证，</p>
<p>Content-Length
生成及gzip内容，而所有这些实现，只需要一行include，就可以为Perl和Python写CGI脚本。Python版本还可以包装任意的CGI脚本。</p>
<p><strong>服务器端包含</strong>
SSI（扩展名通常是</p>
<p>.shtml
）最早可以生成动态内容的网站发布方案。通过在页面中使用特定的标签，有一定限制的内HTML脚本就可以使用了。大部分的SSI实现不设置验证器，故无法缓存。不过Apache服务器允许通过设置让SSI文件可缓存，通过适当的文件并结合</p>
<p>XbitHack full
指令设置组执行权限。欲了解更多信息，请参阅<a href="http://www.apache.org/docs/mod/mod_include.html" target="_blank">mod_include文档</a>。</p>
<p><strong>PHP</strong>
PHP为服务器端脚本语言，在服务器内置的时候，可以在HTML页面中内嵌使用，很像SSL，不过有更多的可选项。PHP可以在任何Web服务器(Unix或Windows)或Apache模块上作为CGI使用。</p>
<p>默认情况下，PHP生成的内容没有分配验证器，因此，不能缓存。不过，开发人员可以通过</p>
<p>Header()
函数设置HTTP头信息。例如，创建</p>
<p>Cache-Control
头，过期时间为3天：
&lt;?php</p>
<p>Header(&quot;Cache-Control: must-revalidate&quot;);</p>
<p>$offset = 60 /<em> 60 /</em> 24 /* 3;
$ExpStr = &quot;Expires: &quot; . gmdate(&quot;D, d M Y H:i:s&quot;, time() + $offset) . &quot; GMT&quot;;</p>
<p>Header($ExpStr);
?&gt;</p>
<p>记住</p>
<p>Header()
需要在所有的输出之前。</p>
<p>正如你看到的，你可以手工创建HTTP日期。PHP没有专门的函数（新版本已改进，请参考<a href="http://php.net/date" target="_blank">PHP的日期相关函数文档</a>）。当然，最简单的还是设置</p>
<p>Cache-Control: max-age
头信息，适用于大部分情况。</p>
<p>更多内容，请参阅<a href="http://www.php.net/manual/function.header.php3" target="_blank">header手册</a>。</p>
<p>还是<a href="http://www.mnot.net/cgi_buffer/" target="_blank">cgi_buffer</a>库，只要一行包含，就能以PHP脚本形式自动实现</p>
<p>Etag
生成和验证，</p>
<p>Content-Length
生成及gzip内容。</p>
<p><strong>Cold Fusion</strong>
<a href="http://www.adobe.com/products/coldfusion/" target="_blank">Cold Fusion</a>是Macromedia的商业服务器端脚本引擎，并且支持多种Windows平台，Linux平台和多种Unix平台。//zxx: 看到Macromedia心亮了半截，几百年前就被收购的公司……此文未免太过时了点了~~大家这段可以跳过了，几乎没有任何价值……</p>
<p>Cold Fusion通过CFHEADER标记设置HTTP头信息相对容易。可惜的是，以下的Expires头信息的设置有些容易误导：</p>
<CFHEADER NAME="Expires" VALUE="/#Now()/#">

<p>它并不像你想像的那样工作，因为时间（本例中为请求发起的时间）并不会被转换成一个符合HTTP时间，而且打印出副本的Cold fusion的日期/时间对象，大部分客户端会忽略或者将其转换成1970年1月1日。</p>
<p>但是：Cold Fusion另外提供了一套日期格式化函数-<a href="http://livedocs.macromedia.com/coldfusion/7/htmldocs/00000483.htm" target="_blank">GetHttpTimeSTring</a>. 结合<a href="http://livedocs.macromedia.com/coldfusion/7/htmldocs/00000437.htm" target="_blank">DateAdd</a>函数，就很容易设置过期时间了，这里我们设置一个头信息，声明内容在1个月以后过期：</p>
<cfheader name="Expires"

  value="/#GetHttpTimeString(DateAdd('m', 1, Now()))/#">

<p>你也可以使用</p>
<p>CFHEADER
标签设置</p>
<p>Cache-Control: max-age
以及其他头信息。</p>
<p>记住，Web服务器也会将头信息设置转给Cold Fusion(做为CGI运行的时候)，检查你的服务器设置并确定你是否可以利用服务器设置代替Cold Fusion.</p>
<p><strong>ASP和ASP.NET</strong></p>
<p>在asp中设置HTTP头信息时，确保</p>
<p>Response
方法调用在HTML内容输出之前，或者使用</p>
<p>Response.Buffer
暂存输出。同时，注意某些版本的IIS默认设置会输出</p>
<p>Cache-Control: private
头信息，必须声明成</p>
<p>public
才能被共享缓存服务器缓存。</p>
<p>ASP(Active Server Pages)，IIS内置，也可用于其他Web服务器，同样允许你设置HTTP头。例如设置过期时间，你可以使用</p>
<p>Response
自带属性：
&lt;% Response.Expires=1440 %&gt;</p>
<p>指定内容过期的分钟数。</p>
<p>Cache-Control
头添加如下：</p>
<p>&lt;% Response.CacheControl=&quot;public&quot; %&gt;</p>
<p>在ASP.NET中，</p>
<p>Response.Expires
已经不推荐使用了，正确的方法是通过</p>
<p>Response.Cache
设置缓存相关的头信息，如下：</p>
<p>Response.Cache.SetExpires ( DateTime.Now.AddMinutes ( 60 ) ) ;</p>
<p>Response.Cache.SetCacheability ( HttpCacheability.Public ) ;</p>
<h3 id="-">参考文档和拓展阅读</h3>
<p><a href="http://www.ietf.org/rfc/rfc2616.txt" target="_blank"><strong>HTTP 1.1规范</strong></a>
HTTP 1.1的规范对页面缓存以及权威的接口实现指南有了大量的扩展，参考章节：13, 14.9, 14.21以及14.25 .</p>
<p><strong><a href="http://www.web-caching.com/" target="_blank">Web-Caching.com</a></strong>
对缓存概念有很好的介绍，并且有很多其他在线资源的链接。</p>
<p><a href="http://www.goldmark.org/netrants/webstats/" target="_blank"><strong>解读访问统计</strong></a>
Jeff Goldberg这篇内容丰富叙述会告诉你为什么不应该过度依赖访问统计和计数器。//zxx 上世纪的复古页面…</p>
<p><a href="http://www.zhangxinxu.com/wordpress/2013/05/caching-tutorial-for-web-authors-and-webmasters/" target="_blank"><strong>REDbot</strong></a>
检查HTTP资源，以确定它们如何与Web缓存交互，以及通常如何使用该协议。</p>
<p><a href="http://www.mnot.net/cgi_buffer/" target="_blank"><strong>cgi_buffer库</strong></a>
只要包含一行Perl CGI, Python CGI以及PHP脚本，就能自动实现</p>
<p>Etag
生成以及验证，</p>
<p>Content-Length
生成以及Gzip内容的正确编码。Python版本还可以包装任意的CGI脚本。</p>
<h3 id="-">关于本文档</h3>
<p>本文版权属于Mark Nottingham © 1998-2013 邮箱为</p>
<p>mnot@pobox.com
.</p>
<p>本作品遵循<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/" target="_blank">知识共享署名 – 非商业性使用 – 禁止演绎3.0声明页面许可证</a>N。</p>
<p>所有的商标版权为其持有人所有。</p>
<p>内容在发布时是可以确保其正确性，但是，随着时间推移，就不能保证正确无误了。因此，如有链接404，描述错误或其他需要纠正的问题请尽快告知作者。</p>
<p>本文最新版本可以从<a href="http://www.mnot.net/cache_docs/" target="_blank"><a href="http://www.mnot.net/cache_docs/">http://www.mnot.net/cache_docs/</a></a>获得</p>
<p>可用翻译：<a href="http://www.fatcow.com/edu/cache-docs-be/" target="_blank">白俄罗斯</a>，<a href="http://www.zhangxinxu.com/wordpress/?p=3338" target="_blank">中国</a>，<a href="http://www.jakpsatweb.cz/clanky/caching-tutorial-czech-translation.html" target="_blank">捷克</a>，<a href="http://thomas-huehn.de/web/caching-tutorial" target="_blank">德国</a>和<a href="http://www.mnot.net/cache_docs/index.fr.html" target="_blank">法国</a>。</p>
<p><strong>文档说明：</strong>含有上标N的表示与前辈翻译时候相比新增的；上标Add表示作为译者的我为了便于理解自己添加的；上标数字(①-⑬)是对一些可能不熟悉的名词的百科解释。</p>
<p>虽然原作语言不生动，教科书般一板一眼⑭；有些可能过时了。不过，还是学到了很多东西。还是很值的！欢迎分享，欢迎传播，以后面试之前来这里看看，可能会有帮助哦！
⑭ 如果我介绍缓存，我可能就这么讲：缓存是什么？顾名思意，就是缓慢的存钱。为什么要缓慢的存钱，因为工资卡都上交老婆了，为了攒点零花钱又不能被老婆发现，只能慢慢存了。那缓存有什么用呢？你想啊，自己有点小钱，做事情就方便快捷了，比方说我想买个鱼竿，就不要去向老婆要（给不给先不谈），自己从自己这边取，大大提高了执行的速度。</p>
<p>那什么时候可以存什么时候不能存呢？老婆给零花钱的时候，可能会有过期时间头，例如，周一甩了100块钱，拿去，这是一周的伙食！这个一周就是过期时间头(Expires Header)，在这个时间内，你的钱可以从缓存，也就是自己这里取……</p>
<p><img src="&quot;1 vote, average: 5.00 out of 5&quot;" alt="1 vote, average: 5.00 out of 5"><img src="&quot;1 vote, average: 5.00 out of 5&quot;" alt="1 vote, average: 5.00 out of 5"><img src="&quot;1 vote, average: 5.00 out of 5&quot;" alt="1 vote, average: 5.00 out of 5"><img src="&quot;1 vote, average: 5.00 out of 5&quot;" alt="1 vote, average: 5.00 out of 5"><img src="&quot;1 vote, average: 5.00 out of 5&quot;" alt="1 vote, average: 5.00 out of 5"> (<strong>*1</strong> 个评分，平均: <strong>5.00*</strong>)</p>
<p><img src="&quot;Loading ...&quot;" alt="Loading ..."> Loading ...</p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/缓存/">缓存</a></li></span></span> | <span class="tags">Tagged <a href="/tags/缓存/" class="label label-primary">缓存</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:39"datetime="2014-03-07 09:54:39"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-缓存--Web开发人员需知的Web缓存知识/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-缓存--Web开发人员需知的Web缓存知识" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-安全--黑客经典之恶意SSH登录企图分析/">黑客经典之恶意SSH登录企图分析</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:39.000Z"> <a href="/2014/02/02/2014-02-02-安全--黑客经典之恶意SSH登录企图分析/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-ssh-">黑客经典之恶意SSH登录企图分析</h1>
<p>黑客经典之恶意SSH登录企图分析</p>
<p>原文链接：<a href="http://www.securitycn.net/html/research/service/1395.html" target="_blank">http://www.securitycn.net/html/research/service/1395.html</a></p>
<p>恶意SSH登录企图出现在一些管理者的日志中已经有几年的时间了。本文回顾了使用&quot;蜜罐&quot;（honeypot）对恶意SSH登录企图进行分析的方法，并提出了我们可以从这一活动中学到的东西。接着本文给出了关于如何使自己的系统安全面对这些攻击的建议。</p>
<p>使用honeypots进行研究</p>
<p>新西兰Honeynet（蜜罐网络）联盟是Honeynet联盟的一个成员研究机构，它致力于通过使用蜜罐技术研究黑帽子黑客（black hat hackers，指那些恶意入侵计算机或计算机网络并尽其所能进行破坏的黑客）的行为、策略和工具来提升计算机系统和网络安全。蜜罐的价值在于它们是可以公开接受攻击并被攻入的开放计算机系统，这使得研究者可以分析该系统上的恶意行为。</p>
<p>我们已经在惠灵顿的维多利亚大学建立起这样的系统来研究发生于新西兰大学网络上的恶意行为。该系统是一个高度互联的蜜罐，一个攻击者可以像在网络的任何其他系统上一样与之联系。在攻击者可知的范围内，蜜罐与其他计算机系统应该没有可分辨的差别。然而，所有流入和流出蜜罐的网络流量都通过Honeynet联盟的Roo honeywall严密监控。此外，系统事件也被蜜罐自身通过其日志功能进行记录。</p>
<p>蜜罐上运行的是标准RedHad 9服务器配置版本，带有可以通过公共互联网访问的安全外壳（Secure Shell，简称SSH）服务器。SSH是可以使得一个用户在网上通过加密通道登录到另一台电脑的程序。在过去的配置下遭遇到恶意SSH登录企图后，我们重新编配了我们的蜜罐以使其可以收集更多的数据。我们对SSH服务器打了补丁以同时记录在登录企图中使用的帐户名和密码。该蜜罐在2006年7月11日上线，在22天后的2006年8月1日下线。在这期间，该蜜罐受到了无数次的SSH登录企图攻击。我们进一步观察这些数据以确定攻击者的策略并提出提高 SSH安全水平的建议。
。</p>
<p>在该蜜罐在6月28日到7月4日运行的另一个配置上，我们增加了可以在系统被攻入后记录攻击者键盘操作的Sebek模块。我们设置了若干具有常用密码的用户帐户。几天后，一个攻击者成功进入了这一系统。在本文中给出了对这一攻击及后续攻击的分析，并提供了对恶意SSH登录企图如何被用于攻入系统的进一步分析。</p>
<p>对SSH登录企图的分析</p>
<p>这一部分分析了7月11日到8月1日我们的蜜罐捕获的数据。该分析完全基于蜜罐的系统日志文件，尤其是&quot;messages&quot;日志。&quot;messages&quot;日志记录了对SSH服务器的验证请求。它记录了日期、时间、登录企图发生的IP地址、请求的结果（失败或成功）以及验证使用的帐户名和密码。下面是两个&quot;messages&quot;的日志示例条目：</p>
<p><code> 
Jul 13 09:37:59 basta sshd[22308]: PW-ATTEMPT: fritz<br>Jul 13 09:37:59 basta sshd[22308]: Failed password for  root from 10.0.160.14<br> port 39529 ssh2<br>Jul 13 09:38:02 basta sshd[22310]: Illegal user   fatacunike from 10.0.160.14<br>Jul 13 09:38:02 basta sshd[22310]: PW-ATTEMPT: fatacunike<br>Jul 13 09:38:02 basta sshd[22310]: Failed password for illegal user fatacunike<br> from 10.0.160.14 port 40444 ssh2
</code></p>
<p>首先，我们分析了用于登录企图的用户名。在取样时间内，系统日志总共记录到2741 个不同的帐户名，包括从常见的姓氏、系统帐户名和常用帐户名到短的字符串。在这些帐户名中，15个使用频率最高的帐户名被列于表1。该表格显示有一个系统上通常存在的帐户（root，mysql）、可能存在的帐户（guest、test）以及常见的姓氏（paul）。随后图1给出了所使用过的有效与无效帐户名的分布。</p>
<p>所使用的无效帐户名远多于有效帐户名并不奇怪，但是我们注意到在蜜罐上存在的所有默认帐户名中96.30%都被攻击利用。</p>
<p><img src="http://www.securitycn.net/img/uploadimg/20060915/1052550.jpg" alt=""></p>
<p>表1 2741次攻击中出现最多的15个帐户名</p>
<p><img src="http://www.securitycn.net/img/uploadimg/20060915/1052551.jpg" alt=""></p>
<p>（Number of Account Names Used in Attack：攻击中使用的帐户名数量；</p>
<p>Number of Account Names on System：系统中的帐户名数量</p>
<p>Existing Account：有效帐户</p>
<p>Invalid Account：无效帐户）</p>
<center>图1 有效与无效帐户名数量</center>  

<p>&quot;成功&quot;的恶意SSH登录企图</p>
<p>在上面的部分中，我们分析了对于没有成功的恶意SSH登录企图数据的记录。这些数据可以使我们进一步理解这些攻击者如何操作，但是还有很多问题没有解决，其中之一是这些攻击中是否使用了工具软件。</p>
<p>7月2日，有一名攻击者通过猜测出一个SSH上的有效帐户名/密码成功地侵入了蜜罐。在这一事件中捕获的数据揭示了这些问题的答案。</p>
<p>首先我们观察了该黑客成功入侵蜜罐后进行的操作。确定了有效的帐户名/密码后，该黑客通过SSH登入蜜罐并继而下载了一个SSH扫描工具。在下面一节将更详细地介绍该工具，这里我们先将其总结为一个可以允许其使用者通过猜测密码的尝试识别并入侵其它SSH服务器的工具。这一工具安装后立刻被用来从我们的蜜罐中扫描B类网络。由于Roo honeywall对于向网络外部的连接施加的限制，该SSH扫描工具并未发现任何SSH服务器。</p>
<p>在最初的扫描后，攻击者继续下载并安装一个IRC僵尸（IRC Bot）。IRC僵尸是可以在远程通过IRC聊天通道控制一个被入侵的系统的工具，其中被入侵的系统被设定为可以通过该通道被监听。使用IRC来控制一个被入侵的系统比直接使用SSH要隐蔽得多，因为此时攻击者不再需要直接登入系统。此外，它还使得攻击者可以同时控制多个这样的系统（它们被称为 Zombies，还魂尸)。</p>
<p>IRC通道中的会话表明，Zombies被用于使用类似于被下载到我们的蜜罐上那样的SSH扫描工具扫描B类网络。在几个小时的时间里，有4个B类网络被来自不同IRC僵尸的SSH扫描工具扫描。一次扫描大约需要700秒的时间完成。此外，我们还目睹了一个帐户名/密码列表与160,324个不同的帐户名/密码组合之间的信息交换。这些帐户名与密码的结构与对我们的蜜罐系统进行攻击时使用的那些非常相似，但比它们范围更广。</p>
<p>分析总结</p>
<p>从这些被我们的蜜罐记录的数据中我们可以得到什么？SSH是一种可以通过安全、加密的方式在网络中访问一台电脑的方法，已经被广泛接受。然而，尽管其在安全方面名誉很好，在一台电脑上操作SSH仍然会面临威胁。如我们在本文中所示的那样，密码猜测显然是威胁之一。仅SSH服务器正在运行并可经互联网连接这一事实就吸引了23次来自独立IP的攻击，在22天内我们的蜜罐共受到6,899 次登录企图。这相当于大约平均每天1次攻击、约300次登录尝试。一些攻击者的攻击非常执着，在每次攻击中执行了上百次登录尝试。</p>
<p>扫描工具的数据记录显示有非常强有力的工具被使用。它们十分灵活并且可以使用用户定制的帐户名/密码列表进行攻击。如果一个攻击者想攻击一个特定的域，他们或许可以通过社会工程获取帐户名，然而将这些帐户名于将在攻击中使用的标准密码组合。通过观察一个IRC僵尸通道，我们发现攻击者们将扫描工具与IRC僵尸计数结合来通过Zombies（攻击者通过远程通道控制的被入侵的系统）进行扫描。</p>
<p>与一系列IRC僵尸结合后，一个攻击者只需要525个Zombies就可以在1天内扫描当今公共互联网的整个IP4。如果你有一个可以被公开访问的SSH服务器，你很可能就会成为这些攻击的目标。</p>
<p>安全建议</p>
<p>有很多简单的方法可以防范这些攻击。最显而易见的方式就是关闭在很多系统中被默认安装的daemon服务。如果一个计算机系统被作为桌面电脑，很可能没有必要用通过SSH的远程访问登入该电脑。如果该方式对你不适用，还有很多其他的选择：</p>
<p>·使用大多数Unix和Linux系统中的/etc/hosts.allow和/etc/hosts.deny文件限制对特定主机的daemon访问。</p>
<p>·安装一个防火墙以限制只允许指定的电脑与网络访问SSH服务器。这在来自内部网络一台电脑的管理员必须对该电脑远程操作时尤其适用。</p>
<p>·限制SSH服务器只允许经过验证的特定用户和组登录。</p>
<p>·将SSH服务器监听端口从22调整到其他未被使用的端口。尽管这样做不会阻止攻击者连接到服务器并开始猜测密码，但它会显著降低发现你的SSH daemon的可能性，因为黑客使用的是标准SSH客户端而且假定SSH服务器的攻击工具是运行于标准的22端口上的。</p>
<p>·除了简单的密码外使用其他验证方法。下面有关于这点的更多介绍。如果你无法选择这一方法，确保正在使用的密码或验证短语安全程度高而且是比较复杂的。</p>
<p>SSH提供了另一种可以成功地减少密码猜测攻击的验证方法。这一验证方法是基于密钥的，或者说是所谓的私钥与公钥。公钥被置于服务器端作为访问你的帐户的用户锁。该锁只能被对应的私钥开启。一旦你提供了该私钥，你就可以获得访问权限。由于攻击者无法猜测或生成这一私钥，密码猜测攻击将失败。所有流行的SSH服务器默认状态下都被设置为支持这一验证方法。然而，它们通常在提供的私钥错误时重新回到基于密码的验证过程，这再次为密码猜测攻击提供了方便。为使这一降低风险的策略成功，这些服务器需要被重新设定为只接受基于密钥的验证。</p>
<p>建立使用密钥的SSH十分简单，只需要几分钟的时间。先前Brian Hatch的文章已经谈及了关于个人用户和SSH服务器间安全访问的SSH用户身份。SSH主机密钥保护一文中提供了关于每台服务器所生成的主机密钥的更多信息。如果使用SSH密钥，读者可能希望获得更多SSH于ssh-agent的例子以便更快更容易地通过SSH登录。</p>
<p>在一些例子中，对一个SSH服务器基于密码的验证或访问无法被禁用。在这种情况下，需要采用其他措施。我们已经看到攻击者猜测帐户名并且对现有系统的帐户以及在通常的计算机系统中的帐户了如指掌。如果该攻击者可以猜到系统中存在的一个帐户名——对于我们的蜜罐，在Redhat蜜罐系统中96.30%的默认帐户名被猜到——则该攻击者已经在该电脑的门口踏入了一步。因此，我们建议不要使用很容易被猜到的帐户名，例如那些常见的姓氏。不要使用&quot;Peter&quot;、&quot;Ian&quot;、或&quot;Mark&quot;，而是建立包括有姓和名的组合的帐户名，例如 &quot;seifer_chr&quot;。这可以通过控制帐户名分配的管理员做到。</p>
<p>此外，我们已经看到&quot;root&quot;帐户是在攻击中使用最多的帐户名，因为它通常都存在于计算机系统中。我们建议禁用该帐户的远程访问权限，取而代之的是管理员应该先通过一般用户帐户再使用&quot;su&quot;（超级用户指令）获得该root帐户的权限。</p>
<p>攻击者经常试图猜测在大多数系统上默认存在的长湖，例如ftp和mysql。如果 shell外壳与这些帐户关联，那么只有通过这些帐户才能访问外壳。对于ftp或mysql这样其存在只为运行电脑上某服务的帐户，外壳是不需要的并且应该被禁用，这可以有效地阻止通过SSH使用这些帐户远程登录。</p>
<p>除了使用无法被猜到的帐户名外，使用安全性强的用户密码也是很重要的。我们已经看到在攻击中使用的密码通常与帐户名相同或者是帐户名加上一些数列。我们推测攻击者们选择这些密码因为它们在恶意登录企图中是最&quot;成功&quot;的。这表明至少有些用户将他们的密码设置为这些很容易被猜到的字符串。系统管理员阻止用户选用这样的密码的唯一方法是通过安装各种工具软件（例如passwd+）强制用户使用安全性高的密码。</p>
<p>攻击者们正在使用工具进行密码猜测和登录尝试，例如被记录的扫描工具、QT和 55hb。然而，尽管有这些工具存在，由于SSH服务器端内置的对于失败登录企图的故意延迟以及各种网络延迟，登录尝试的最短平均时间也需要约2秒。尽管这提供了对于暴力攻击的防范，对于安全性差的帐户名和密码只需要少数几次尝试与猜测就可以侵入系统。以上所描述的安全措施应该被安装以保证安全工作的广泛与深入。</p>
<p>未来的工作</p>
<p>我们的分析是基于我们的蜜罐捕获的数据进行的。我们无法确定这些攻击对于网络上可以找到的系统成功的概率有多大。为了确定成功率，我们需要将这些攻击中使用的帐户名/密码组合与在真实系统中存在的帐户名/密码组合进行比较。此外，我们提出了将SSH服务器监听端口改到其他未占用的端口。我们需要建立这样配置的系统以评估其有效性。</p>
<p>关于作者</p>
<p>Christian Seifert是新西兰Honeynet联盟的成员。</p>
<p>致谢</p>
<p>感谢Jamie Riden提供降低密码猜测风险的策略以及对实际SSH密码猜测工具的参考。</p>
<p>本篇文章来源于 中国安全网-安全您的网络 原文链接：<a href="http://www.securitycn.net/html/research/service/1395.html" target="_blank">http://www.securitycn.net/html/research/service/1395.html</a></p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/安全/">安全</a></li></span></span> | <span class="tags">Tagged <a href="/tags/安全/" class="label label-primary">安全</a></span> | <span class="time">recent updated:<time title="2014-03-29 21:31:05"datetime="2014-03-29 21:31:05"> mar. 29 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-安全--黑客经典之恶意SSH登录企图分析/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-安全--黑客经典之恶意SSH登录企图分析" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-CAS--casclient使用指南-老老-ITeye技术网站/">cas client使用指南 </a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:39.000Z"> <a href="/2014/02/02/2014-02-02-CAS--casclient使用指南-老老-ITeye技术网站/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="cas-client-iteye-">cas client使用指南 - 老老 - ITeye技术网站</h1>
<p><a href="http://www.iteye.com/" target="_blank">首页</a> <a href="http://www.iteye.com/news" target="_blank">资讯</a> <a href="http://www.iteye.com/magazines" target="_blank">精华</a> <a href="http://www.iteye.com/forums" target="_blank">论坛</a> <a href="http://www.iteye.com/ask" target="_blank">问答</a> <a href="http://www.iteye.com/blogs" target="_blank">博客</a> <a href="http://www.iteye.com/blogs/subjects" target="_blank">专栏</a> <a href="http://www.iteye.com/groups" target="_blank">群组</a> <a href="http://lvyanglin.iteye.com/blog/618081#" target="_blank">更多 ▼</a></p>
<p><a href="http://www.iteye.com/job" target="_blank">招聘</a> <a href="http://www.iteye.com/search" target="_blank">搜索</a></p>
<p><a href="http://lvyanglin.iteye.com/login" title="登录" target="_blank">您还未登录 !</a> <a href="http://lvyanglin.iteye.com/login" target="_blank">登录</a> <a href="http://lvyanglin.iteye.com/signup" target="_blank">注册</a></p>
<h1 id="-http-lvyanglin-iteye-com-"><a href="http://lvyanglin.iteye.com/" target="_blank">老老</a></h1>
<ul>
<li><a href="http://lvyanglin.iteye.com/" target="_blank"><strong>博客</strong></a></li>
<li><a href="http://lvyanglin.iteye.com/weibo" target="_blank">微博</a></li>
<li><a href="http://lvyanglin.iteye.com/album" target="_blank">相册</a></li>
<li><a href="http://lvyanglin.iteye.com/link" target="_blank">收藏</a></li>
<li><a href="http://lvyanglin.iteye.com/blog/guest_book" target="_blank">留言</a></li>
<li><a href="http://lvyanglin.iteye.com/blog/profile" target="_blank">关于我</a></li>
</ul>
<h3 id="-cas-client-"><a href="">cas client使用指南</a> **</h3>
<p><strong>博客分类：</strong></p>
<ul>
<li><a href="http://lvyanglin.iteye.com/category/67638" target="_blank">java</a>
<a href="http://www.iteye.com/blogs/tag/%E4%BC%81%E4%B8%9A%E5%BA%94%E7%94%A8" target="_blank">企业应用</a><a href="http://www.iteye.com/blogs/tag/SSO" target="_blank">SSO</a><a href="http://www.iteye.com/blogs/tag/SQL%20Server" target="_blank">SQL Server</a><a href="http://www.iteye.com/blogs/tag/%E5%BA%94%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8" target="_blank">应用服务器</a><a href="http://www.iteye.com/blogs/tag/Spring" target="_blank">Spring</a> </li>
</ul>
<p>2008-02-27
JA-SIG（CAS）学习笔记3
关键字: cas sso 统一身份认证 java ja-sig
技术背景知识：
  JA-SIG CAS服务环境搭建，请参考 ：JA-SIG（CAS）学习笔记1 
  JA-SIG CAS业务架构介绍，请参考 ：JA-SIG（CAS）学习笔记2
  HTTPS所涉及的Java安全证书知识，请参考 ：Java  keytool 安全证书学习笔记
CAS技术框架
  CAS  Server
    目前，我们使用的CAS Server 3.1.1的是基于Spring Framework编写的，因此在CAS服务器端的配置管理中，绝大多数是Spring式的Java Bean XML配置。CAS 的服务器提供了一套易于定制的用户认证器接口，用户可以根据自身企业的在线系统的认证方式，来定制自己的认证逻辑。不论是传统的用户名/密码方式，还是基于安全证书的方式；是基于关系数据库的存储，还是采用LDAP服务器，CAS  Server给我们提供了这些常用的验证器模板代码，只要稍作修改，便可灵活使用了。
    对于广大的中国企业用户而言，另一个需要定制的功能莫过于全中文、企业特色的用户身份认证页面了。CAS Server提供了两套系统界面，一套是默认的CAS英文标准页面，另一套则是专门提供给用户来定制修改的。（PS：老外们做事情就是人性化啊~~）那么对CAS Server端的后续学习，我们将围绕着身份认证模块定制和界面定制这两方面展开。
  CAS  Client
    客户端我们使用的是CAS Client 2.1.1。虽然在官方网站上已出现了3.1.0版本的下载，但该版本地代码已经完全重写，使用的package和类名同2.1.1大相径庭了，最关键的是，该版本暂时没有对应的API说明文档。虽然咖啡我对程序版本怀有极大的“喜新厌旧”的心态，但安全起见，还是先2.1.1吧，相信3.1.0的文档耶鲁大学的大牛们已经在整理了，期待中……
CAS Client2.1.1.jar中的代码是相当精炼的，有兴趣的朋友建议阅读一下源码。Jar包中的代码分成三个大部分</p>
<ol>
<li>edu.yale.its.tp.cas.util 包，其中只有一个工具类 SecureURL.java 用来访问HTTPS URL</li>
<li>edu.yale.its.tp.cas.proxy包，用来处理Proxy Authentication代理认证的3个类，其中ProxyTicketReceptor.java是 接收PGT回调的servlet，在下文中我们会提及。</li>
<li>edu.yale.its.tp.cas.client包，其中包含了CAS Filter ，Tag Library等主要的认证客户端工具类，我们在后面会进行重点介绍。
针对CAS Client的学习，我们的重点将放在CAS Filter 和ProxyTicketReceptor 的配置以及在Java SE环境下，直接使用 ServiceTicketValidator进行Ticket认证实现上。
CAS服务器端应用
定制适合你的身份认证程序
通过前面的学习，我们了解了CAS具有一个良好而强大的SSO功能框架。接下来，我们要学习如何将实际企业应用中的身份认证同CAS进行整合。
简单的说，要将现有企业应用中的认证集成到CAS Server中，只要实现一个名为AuthenticationHandler的一个认证处理Java接口就行。以下是该接口的源代码：
Java代码
public interface AuthenticationHandler {<br>//<em>/</em> 
/<em> 该方法决定一个受支持的credentials是否是可用的， 
/</em> 如果可用，该方法返回true，则说明身份认证通过 
/<em>/ 
boolean  authenticate(Credentials credentials)  throws  AuthenticationException;<br>//</em>/<em> 
/</em> 该方法决定一个credentials是否是当前的handle所支持的 
/<em>/ 
boolean  supports(Credentials credentials);<br>} 
public interface AuthenticationHandler {
//</em>/<em>
/</em> 该方法决定一个受支持的credentials是否是可用的，
/<em> 如果可用，该方法返回true，则说明身份认证通过
/</em>/
boolean  authenticate(Credentials credentials)  throws  AuthenticationException;
//<em>/</em>
/<em> 该方法决定一个credentials是否是当前的handle所支持的
/</em>/
boolean  supports(Credentials credentials);
}
这里我们要说明一下Credentials这个CAS的概念。所谓Credentials是由外界提供给CAS来证明自身身份的信息，简单的如一个用户名/密码对就是一个Credentials，或者一个经过某种加密算法生成的密文证书也可以是一个Credentials。在程序的实现上，Credentials被声明为一个可序列化的接口，仅仅起着标识作用，源代码如下：
Java代码
public interface Credentials extends Serializable {<br>// marker interface contains no methods<br>} 
public interface Credentials extends Serializable {
// marker interface contains no methods
}
CAS的API中，已经为我们提供了一个最常用的实现UsernamePasswordCredentials  用户名/密码凭证，代码如下：
Java代码
public class UsernamePasswordCredentials implements Credentials {<br>//<em>/</em> Unique ID for serialization. /<em>/ 
private static final long serialVersionUID = -8343864967200862794L;<br>//</em>/<em> The username. /</em>/ 
private String username;<br>//<em>/</em> The password. /*/ 
private String password;<br>public final String getPassword() {<br>   return this.password;<br>}<br>public final void setPassword(final String password) {<br>   this.password = password;<br>}<br>public final String getUsername() {<br>   return this.username;<br>}<br>public final void setUsername(final String userName) {<br>   this.username = userName;<br>}<br>public String toString() {<br>   return this.username;<br>}<br>public boolean equals(final Object obj) {<br>   if (obj == null || !obj.getClass().equals(this.getClass())) {  <pre><code>   return false;  
</code></pre>   }<br>   final UsernamePasswordCredentials c = (UsernamePasswordCredentials) obj;<br>   return this.username.equals(c.getUsername())  <pre><code>   &amp;&amp; this.password.equals(c.getPassword());  
</code></pre>}<br>public int hashCode() {<br>   return this.username.hashCode() ^ this.password.hashCode();<br>}<br>} 
public class UsernamePasswordCredentials implements Credentials {
//<em>/</em> Unique ID for serialization. /<em>/
private static final long serialVersionUID = -8343864967200862794L;
//</em>/<em> The username. /</em>/
private String username;
//<em>/</em> The password. /*/
private String password;
public final String getPassword() {
   return this.password;
}
public final void setPassword(final String password) {
   this.password = password;
}
public final String getUsername() {
   return this.username;
}
public final void setUsername(final String userName) {
   this.username = userName;
}
public String toString() {
   return this.username;
}
public boolean equals(final Object obj) {
   if (obj == null || !obj.getClass().equals(this.getClass())) {<pre><code>   return false;
</code></pre>   }
   final UsernamePasswordCredentials c = (UsernamePasswordCredentials) obj;
   return this.username.equals(c.getUsername())<pre><code>   &amp;&amp; this.password.equals(c.getPassword());
</code></pre>}
public int hashCode() {
   return this.username.hashCode() ^ this.password.hashCode();
}
}
很简单不是吗？就是存储一个用户名和密码的java bean而已。
 接下来，我们将一个Credentials传给一个AuthenticationHandler进行认证，首先调用boolean  supports(Credentials credentials)方法察看当前传入的Credentials实例，AuthenticationHandler实例现是否支持它？如果支持，再调用boolean  authenticate(Credentials credentials)方法进行认证。由于用户名/密码方式是最常用的认证方法，因此CAS为我们提供了一个现成的基于该方式的抽象认证处理类AbstractUsernamePasswordAuthenticationHandler。通常我们只需要继承该类，并实现其中的    authenticateUsernamePasswordInternal方法即可。下面我们给出一个Demo的实现类，它的校验逻辑很简单——仅校验用户名的字符长度是否与密码的相等（这里密码是一个表示长度的整数），如果相等则认为认证通过，请看代码：
Java代码
public class UsernameLengthAuthnHandler  <pre><code>              extends AbstractUsernamePasswordAuthenticationHandler {  
</code></pre>protected boolean authenticateUsernamePasswordInternal( UsernamePasswordCredentials credentials)  throws AuthenticationException {<br>//<em><br>/</em> 这里我们完全可以用自己的认证逻辑代替，比如将用户名/密码传入一个SQL语句<br>/<em> 向数据库验证是否有对应的用户账号，这不是我们最经常干的事么？<br>/</em> 只需要将下面的程序替换掉就OK了！！So  easy，so  simple！<br>/<br>String username = credentials.getUsername();<br>String password = credentials.getPassword();<br>String correctPassword = Integer.toString(username.length());<br>return correctPassword.equals(password);<br>}<br>} 
public class UsernameLengthAuthnHandler<pre><code>              extends AbstractUsernamePasswordAuthenticationHandler {
</code></pre>protected boolean authenticateUsernamePasswordInternal( UsernamePasswordCredentials credentials)  throws AuthenticationException {
//<em>
/</em> 这里我们完全可以用自己的认证逻辑代替，比如将用户名/密码传入一个SQL语句
/<em> 向数据库验证是否有对应的用户账号，这不是我们最经常干的事么？
/</em> 只需要将下面的程序替换掉就OK了！！So  easy，so  simple！
/
String username = credentials.getUsername();
String password = credentials.getPassword();
String correctPassword = Integer.toString(username.length());
return correctPassword.equals(password);
}
}
介绍到这里，大家应该清楚如何定制自己的AuthenticationHandler类了吧！这里要附带说明的是，在CAS Server的扩展API中已经提供了大量常用认证形式的实现类，它们同CAS Server的war包一同分发：
cas-server-support-generic-3.1.1.jar ——使用Map记录用户认证信息的实现
cas-server-support-jdbc-3.1.1.jar —— 基于Spring JDBC的数据库实现（我们常用的）
cas-server-support-ldap-3.1.1.jar —— 基于LDAP的用户认证实现
更多其他形式的实现各位看官有兴趣的，可以一一阅读源码。
配置你的身份认证程序
完成了定制认证类的代码编写，接下来就是要让CAS Server来调用它了。在CAS的框架中，对程序的配置都是使用Spring Framework的xml文件，这对于熟悉Spring的程序员而言算驾轻就熟了。
配置文件位于应用部署目录的WEB-INF子目录下——deployerConfigContext.xml。在bean id=authenticationManager 的 authenticationHandlers属性中配置我们的AuthenticationHandlers：
引用
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
<beans xmlns="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:p="http://www.springframework.org/schema/p"
  xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.0.xsd">
<bean id="authenticationManager"
class="org.jasig.cas.authentication.AuthenticationManagerImpl">
   。。。
   。。。
<property name="authenticationHandlers">
<list>
<bean class="org.jasig.cas.authentication.handler.support.HttpBasedServiceCredentialsAuthenticationHandler" p:httpClient-ref="httpClient" />
   &lt;!—下面就是系统默认的验证器配置，你可以替换它，或者增加一个新的handler --&gt;
<bean     class="org.jasig.cas.authentication.handler.support.SimpleTestUsernamePasswordAuthenticationHandler" />
</list>
</property>
</bean>
。。。
。。。
</beans>
我们发现authenticationHandlers属性是一个list，在这个list中可以配置多个AuthenticationHandlers。这些AuthenticationHandlers形成了一个验证器链，所有提交给CAS的Credentials信息将通过这个验证器链的链式过滤，只要这链中有一个验证器通过了对Credentials的验证，就认为这个Credentials是合法的。这样的设计使得我们可以很轻松的整合不同验证体系的已有应用到同一个CAS上，比如：A验证器负责校验alpha系统提交的Credentials，它是基于LDAP服务器的；B验证器负责校验beta系统提交的Credentials，它是一个传统的RDB用户表认证；C验证器负责校验gamma系统提交的基于RSA证书加密的Credentials。3种完全不同的用户身份认证通过配置就可以统一在同一个CAS服务内，很好很强大，不是吗！！
定制身份验证登录界面
 CAS Server在显示界面层view使用了“主题Theme”的概念。在{project.home}/webapp/WEB-INF/view/jsp/目录下，系统默认提供了两套得UI —— default和simple 。default方案使用了CSS等相对复杂得界面元素，而simple方案提供了最简化的界面表示方式。在整个的CAS Server服务器端，有四个界面是我们必须要实现的：
casConfirmView.jsp —— 确认信息（警告信息）页面
casGenericSuccess.jsp —— 登陆成功提示页面
casLoginView.jsp —— 登录输入页面
casLogoutView.jsp —— SSO登出提示页面
这些都是标准的jsp页面，如何实现他们，完全由您说了算，除了名字不能改。
CAS为view的展示提供了3个级别的定制方式，让我们从最直观简单的开始吧。
1． 采用文件覆盖方式：直接修改default中的页面或者将新写好的四个jsp文件覆盖到default目录中。这种方式最直观和简单，但咖啡建议各位在使用这种方式前将原有目录中的文件备份一下，以备不时之需。
2． 修改UI配置文件，定位UI目录：在CAS Server端/webapp/WEB-INF/classes/ 目录下，有一个名为default_views.properties的属性配置文件，你可以通过修改配置文件中的各个页面文件位置，指向你新UI文件，来达到修改页面展示的目的。
3． 修改配置文件的配置文件，这话看起来有点别扭，其实一点不难理解。在方法2中的default_views.properties文件是一整套的UI页面配置。如果我想保存多套的UI页面配置就可以写多个的properties文件来保存这些配置。在CAS Server端/webapp/WEB-INF/目录下有cas-servlet.xml和cas.properties两个文件，cas-servlet.xml使用了cas.properties文件中的cas.viewResolver.basename属性来定义view属性文件的名字，因此你可以选者直接修改cas-servlet.xml中的viewResolver 下的basenames属性，或者修改cas.properties中的cas.viewResolver.basename属性，指定新的properties文件名，这样可以轻松的替换全套UI。
CAS客户端配置及API应用
CASFilter的配置
对于大部分web应用而言，使用CAS集成统一认证是相对简单的事，只要为需要认证的URL配置edu.yale.its.tp.cas.client.filter.CASFilter认证过滤器。下面我们就针对过滤器的配置进行说明。首先参看一下Filter的基本配置：
引用
<web-app>
...
<filter>
<filter-name>CAS Filter</filter-name>
<filter-class>edu.yale.its.tp.cas.client.filter.CASFilter</filter-class>
<init-param>
  <param-name>edu.yale.its.tp.cas.client.filter.loginUrl</param-name>
  <param-value><a href="https://secure.its.yale.edu/cas/login" target="_blank">https://secure.its.yale.edu/cas/login</a>&lt;;/param-value&gt;
</init-param>
<init-param>
  <param-name>edu.yale.its.tp.cas.client.filter.validateUrl</param-name>
  <param-value><a href="https://secure.its.yale.edu/cas/serviceValidate" target="_blank">https://secure.its.yale.edu/cas/serviceValidate</a>&lt;;/param-value&gt;
</init-param>
<init-param>
  <param-name>edu.yale.its.tp.cas.client.filter.serverName</param-name>
  <param-value>your server name and port (e.g., www.yale.edu:8080)</param-value>
</init-param>
</filter>
<filter-mapping>
<filter-name>CAS Filter</filter-name>
<url-pattern>/requires-cas-authetication//<em></url-pattern>
</filter-mapping>
...
</web-app>
上述配置中的init-param是filter的3个必备的属性，下面这张表则是filter全部属性的详细说明：
ProxyTicketReceptor的配置
大家还记得在前面我们说过的Proxy Authentication中的call back URL吗？ProxyTicketReceptor是部署在client端的一个servlet，提供server端回传PGT和PGTIOU的。它的xml部署如下：
引用
<web-app>
...
<servlet>
<servlet-name>ProxyTicketReceptor</servlet-name>
<servlet-class>edu.yale.its.tp.cas.proxy.ProxyTicketReceptor</servlet-class>
<init-param>
  <param-name>edu.yale.its.tp.cas.proxyUrl</param-name>
  <param-value><a href="https://secure.its.yale.edu/cas/proxy" target="_blank">https://secure.its.yale.edu/cas/proxy</a>&lt;;/param-value&gt;
</init-param>
</servlet>
<servlet-mapping>
<servlet-name>ProxyTicketReceptor</servlet-name>
<url-pattern>/CasProxyServlet</url-pattern>
</servlet-mapping>
...
</webapp>
这里要说明的是它的参数edu.yale.its.tp.cas.proxyUrl。在服务端通过ProxyTicketReceptor将PGT和PGTIOU传给客户端后，ProxyTicketReceptor在进行Proxy Authentication的过程中需要向服务端请求一个ProxyTicket（PT），这个proxyUrl就是服务端的请求入口了。（关于Proxy Authentication的运作原理，参见JA-SIG（CAS）学习笔记2 ）
CAS Client端的API应用1．用户可以通过以下两种方式的任意一种，从JSP或servlet中获取通过认证的用户名：
引用
String username = (String)session.getAttribute(CASFilter.CAS_FILTER_USER);
或者
String username = (String)session.getAttribute(&quot;edu.yale.its.tp.cas.client.filter.user&quot;);
2．获得更完整的受认证用户信息对象CASReceipt Java Bean，可以使用以下语句的任一:
引用
CASReceipt  receipt = (CASReceipt )session.getAttribute(CASFilter.CAS_FILTER_RECEIPT);
或者
CASReceipt  receipt = (CASReceipt )session.getAttribute(&quot;edu.yale.its.tp.cas.client.filter.receipt&quot;);
3．手工编码使用CAS Java Object进行用户验证，使用ServiceTicketValidator或者 ProxyTicketValidator（代理认证模式下），在servlet中对用户身份进行验证。
3-1．ServiceTicketValidator
Java代码
import edu.yale.its.tp.cas.client./</em>;<br>...<br>String user = null;<br>String errorCode = null;<br>String errorMessage = null;<br>String xmlResponse = null;  </li>
</ol>
<p>//<em> instantiate a new ServiceTicketValidator /</em>/ 
ServiceTicketValidator sv = new ServiceTicketValidator();  </p>
<p>//<em> set its parameters /</em>/ 
sv.setCasValidateUrl(&quot;<a href="https://secure.its.yale.edu/cas/serviceValidate" target="_blank">https://secure.its.yale.edu/cas/serviceValidate</a>&quot;);<br>sv.setService(urlOfThisService);<br>sv.setServiceTicket(request.getParameter(&quot;ticket&quot;));   </p>
<p>String urlOfProxyCallbackServlet = &quot;<a href="https://portal.yale.edu/CasProxyServlet" target="_blank">https://portal.yale.edu/CasProxyServlet</a>&quot;;<br>sv.setProxyCallbackUrl(urlOfProxyCallbackServlet);  </p>
<p>//<em> contact CAS and validate /</em>/ 
sv.validate();  </p>
<p>//<em> if we want to look at the raw response, we can use getResponse() /</em>/ 
xmlResponse = sv.getResponse();  </p>
<p>if(sv.isAuthenticationSuccesful()) {<br>  user = sv.getUser();<br>} else {<br>  errorCode = sv.getErrorCode();<br>  errorMessage = sv.getErrorMessage();<br>}<br>  //<em> The user is now authenticated. /</em>/ 
  //<em> If we did set the proxy callback url, we can get proxy tickets with: /</em>/ 
  String urlOfTargetService = &quot;<a href="http://hkg2.its.yale.edu/someApp/portalFeed" target="_blank">http://hkg2.its.yale.edu/someApp/portalFeed</a>&quot;;<br>  String proxyTicket = ProxyTicketReceptor.getProxyTicket( sv.getPgtIou() , urlOfTargetService); 
import edu.yale.its.tp.cas.client./<em>;
...
String user = null;
String errorCode = null;
String errorMessage = null;
String xmlResponse = null;
//</em> instantiate a new ServiceTicketValidator /<em>/
ServiceTicketValidator sv = new ServiceTicketValidator();
//</em> set its parameters /<em>/
sv.setCasValidateUrl(&quot;<a href="https://secure.its.yale.edu/cas/serviceValidate" target="_blank">https://secure.its.yale.edu/cas/serviceValidate</a>&quot;);
sv.setService(urlOfThisService);
sv.setServiceTicket(request.getParameter(&quot;ticket&quot;));
String urlOfProxyCallbackServlet = &quot;<a href="https://portal.yale.edu/CasProxyServlet" target="_blank">https://portal.yale.edu/CasProxyServlet</a>&quot;;
sv.setProxyCallbackUrl(urlOfProxyCallbackServlet);
//</em> contact CAS and validate /<em>/
sv.validate();
//</em> if we want to look at the raw response, we can use getResponse() /<em>/
xmlResponse = sv.getResponse();
if(sv.isAuthenticationSuccesful()) {
  user = sv.getUser();
} else {
  errorCode = sv.getErrorCode();
  errorMessage = sv.getErrorMessage();
}
  //</em> The user is now authenticated. /<em>/
  //</em> If we did set the proxy callback url, we can get proxy tickets with: /<em>/
  String urlOfTargetService = &quot;<a href="http://hkg2.its.yale.edu/someApp/portalFeed" target="_blank">http://hkg2.its.yale.edu/someApp/portalFeed</a>&quot;;
  String proxyTicket = ProxyTicketReceptor.getProxyTicket( sv.getPgtIou() , urlOfTargetService);
3-2．ProxyTicketValidator
Java代码
import edu.yale.its.tp.cas.client./</em>;<br>...<br>String user = null;<br>String errorCode = null;<br>String errorMessage = null;<br>String xmlResponse = null;<br>List proxyList = null;  </p>
<p>//<em> instantiate a new ProxyTicketValidator /</em>/ 
ProxyTicketValidator pv = new ProxyTicketValidator();   </p>
<p>//<em> set its parameters /</em>/ 
pv.setCasValidateUrl(&quot;<a href="https://secure.its.yale.edu/cas/proxyValidate" target="_blank">https://secure.its.yale.edu/cas/proxyValidate</a>&quot;);<br>pv.setService(urlOfThisService);<br>pv.setServiceTicket(request.getParameter(&quot;ticket&quot;));   </p>
<p>String urlOfProxyCallbackServlet = &quot;<a href="https://portal.yale.edu/CasProxyServlet" target="_blank">https://portal.yale.edu/CasProxyServlet</a>&quot;;<br>pv.setProxyCallbackUrl(urlOfProxyCallbackServlet);   </p>
<p>//<em> contact CAS and validate /</em>/ 
pv.validate();  </p>
<p>//<em> if we want to look at the raw response, we can use getResponse() /</em>/ 
xmlResponse = pv.getResponse();   </p>
<p>//<em> read the response /</em>/ 
if(pv.isAuthenticationSuccesful()) {<br>  user = pv.getUser();<br>  proxyList = pv.getProxyList();<br>} else {<br>  errorCode = pv.getErrorCode();<br>  errorMessage = pv.getErrorMessage();<br>  //<em> handle the error /</em>/ 
}<br>//<em> The user is now authenticated. /</em>/<br>//<em> If we did set the proxy callback url, we can get proxy tickets with this method call: /</em>/<br>String urlOfTargetService = &quot;<a href="http://hkg2.its.yale.edu/someApp/portalFeed" target="_blank">http://hkg2.its.yale.edu/someApp/portalFeed</a>&quot;;<br>String proxyTicket = ProxyTicketReceptor.getProxyTicket( pv.getPgtIou() , urlOfTargetService); 
import edu.yale.its.tp.cas.client./<em>;
...
String user = null;
String errorCode = null;
String errorMessage = null;
String xmlResponse = null;
List proxyList = null;
//</em> instantiate a new ProxyTicketValidator /<em>/
ProxyTicketValidator pv = new ProxyTicketValidator();
//</em> set its parameters /<em>/
pv.setCasValidateUrl(&quot;<a href="https://secure.its.yale.edu/cas/proxyValidate" target="_blank">https://secure.its.yale.edu/cas/proxyValidate</a>&quot;);
pv.setService(urlOfThisService);
pv.setServiceTicket(request.getParameter(&quot;ticket&quot;));
String urlOfProxyCallbackServlet = &quot;<a href="https://portal.yale.edu/CasProxyServlet" target="_blank">https://portal.yale.edu/CasProxyServlet</a>&quot;;
pv.setProxyCallbackUrl(urlOfProxyCallbackServlet);
//</em> contact CAS and validate /<em>/
pv.validate();
//</em> if we want to look at the raw response, we can use getResponse() /<em>/
xmlResponse = pv.getResponse();
//</em> read the response /<em>/
if(pv.isAuthenticationSuccesful()) {
  user = pv.getUser();
  proxyList = pv.getProxyList();
} else {
  errorCode = pv.getErrorCode();
  errorMessage = pv.getErrorMessage();
  //</em> handle the error /<em>/
}
//</em> The user is now authenticated. /<em>/
//</em> If we did set the proxy callback url, we can get proxy tickets with this method call: /*/
String urlOfTargetService = &quot;<a href="http://hkg2.its.yale.edu/someApp/portalFeed" target="_blank">http://hkg2.its.yale.edu/someApp/portalFeed</a>&quot;;
String proxyTicket = ProxyTicketReceptor.getProxyTicket( pv.getPgtIou() , urlOfTargetService);
在这里，我们假设上下文环境中的用户已经通过了CAS登录认证，被重定向到当前的servlet下，我们在servlet中获取ticket凭证，servlet的URL对用户身份进行确认。如果上下文参数中无法获取ticket凭证，我们就认为用户尚未登录，那么，该servlet必须负责将用户重定向到CAS的登录页面去。
初战告捷
      到今天为止，我们已经通过JA-SIG学习笔记的1-3部分，对CAS这个开源SSO的框架有了个大体的了解和初步的掌握，希望这些知识能为各位步入CAS殿堂打开一扇的大门。咖啡希望在今后的工作应用中，能同大家一块共同探讨，进一步深入了解CAS。
学无止境。。。。。。
分享到： <a href="&quot;分享到新浪微博&quot;"><img src="" alt=""></a> <a href="&quot;分享到腾讯微博&quot;"><img src="" alt=""></a></p>
<p><a href="http://lvyanglin.iteye.com/blog/622656" title="cas-server-3.3.2  使用举例" target="_blank">cas-server-3.3.2 使用举例</a> | <a href="http://lvyanglin.iteye.com/blog/615166" title="cas 服务器端的配置" target="_blank">cas 服务器端的配置</a></p>
<ul>
<li>2010-03-17 14:56</li>
<li>浏览 770</li>
<li><a href="http://lvyanglin.iteye.com/blog/618081#comments" target="_blank">评论(0)</a></li>
<li>分类:<a href="http://www.iteye.com/blogs/category/language" target="_blank">编程语言</a></li>
<li><a href="http://www.iteye.com/wiki/blog/618081" target="_blank">相关推荐</a></li>
</ul>
<h3 id="-">评论</h3>
<p><a href=""></a></p>
<h3 id="-">发表评论</h3>
<p><a href="http://lvyanglin.iteye.com/login" target="_blank"><img src="" alt=""></a><a href="http://lvyanglin.iteye.com/login" target="_blank">您还没有登录,请您登录后再发表评论</a></p>
<p><a href="http://lvyanglin.iteye.com/" target="_blank"><img src="&quot;lvyanglin的博客: 老老&quot;" alt="lvyanglin的博客"></a></p>
<p>lvyanglin</p>
<ul>
<li>浏览: 11625 次</li>
<li>性别: <img src="&quot;男&quot;" alt="Icon_minigender_1"></li>
<li>来自: 广州</li>
<li><img src="" alt=""><h3 id="-http-lvyanglin-iteye-com-blog-user_visits-">最近访客 <a href="http://lvyanglin.iteye.com/blog/user_visits" target="_blank">更多访客&gt;&gt;</a></h3>
</li>
</ul>
<p><a href="http://shangyue1110.iteye.com/" target="_blank"><img src="&quot;shangyue1110的博客: &quot;" alt="shangyue1110的博客"></a></p>
<p><a href="http://shangyue1110.iteye.com/" title="shangyue1110" target="_blank">shangyue1110</a></p>
<p><a href="http://dylinshi126.iteye.com/" target="_blank"><img src="&quot;dylinshi126的博客: &quot;" alt="dylinshi126的博客"></a></p>
<p><a href="http://dylinshi126.iteye.com/" title="dylinshi126" target="_blank">dylinshi126</a>
<a href="http://dada7020.iteye.com/" target="_blank"><img src="&quot;dada7020的博客: &quot;" alt="dada7020的博客"></a></p>
<p><a href="http://dada7020.iteye.com/" title="dada7020" target="_blank">dada7020</a></p>
<p><a href="http://k175981998.iteye.com/" target="_blank"><img src="&quot;k175981998的博客: &quot;" alt="k175981998的博客"></a></p>
<p><a href="http://k175981998.iteye.com/" title="k175981998" target="_blank">k175981998</a></p>
<h3 id="-">文章分类</h3>
<ul>
<li><a href="http://lvyanglin.iteye.com/" target="_blank">全部博客 (35)</a></li>
<li><a href="http://lvyanglin.iteye.com/category/67638" target="_blank">java (20)</a></li>
<li><a href="http://lvyanglin.iteye.com/category/67639" target="_blank">数据库 (5)</a></li>
<li><a href="http://lvyanglin.iteye.com/category/67640" target="_blank">其他 (5)</a></li>
<li><a href="http://lvyanglin.iteye.com/category/187499" target="_blank">在centsos上安装chrome (1)</a></li>
<li><a href="http://lvyanglin.iteye.com/category/194903" target="_blank">centos 安装 (1)</a></li>
<li><p><a href="http://lvyanglin.iteye.com/category/220785" target="_blank">学习linux (0)</a></p>
<h3 id="-">社区版块</h3>
</li>
<li><p><a href="http://lvyanglin.iteye.com/blog/news" target="_blank">我的资讯</a> (0)</p>
</li>
<li><a href="http://lvyanglin.iteye.com/blog/post" target="_blank">我的论坛</a> (0)</li>
<li><a href="http://lvyanglin.iteye.com/blog/answered_problems" target="_blank">我的问答</a> (1)</li>
</ul>
<h3 id="-">存档分类</h3>
<ul>
<li><a href="http://lvyanglin.iteye.com/blog/monthblog/2011-12" target="_blank">2011-12</a> (2)</li>
<li><a href="http://lvyanglin.iteye.com/blog/monthblog/2011-11" target="_blank">2011-11</a> (1)</li>
<li><a href="http://lvyanglin.iteye.com/blog/monthblog/2011-05" target="_blank">2011-05</a> (2)</li>
<li><p><a href="http://lvyanglin.iteye.com/blog/monthblog_more" target="_blank">更多存档...</a></p>
<h3 id="-">最新评论</h3>
</li>
<li><p><a href="http://403577706.iteye.com/" title="403577706" target="_blank">403577706</a>： sudo apt-get build-dep /#(packag ...
<a href="http://lvyanglin.iteye.com/blog/800337#bc2250038" target="_blank">sudo apt-get -f install</a>
声明：ITeye文章版权属于作者，受法律保护。没有作者书面许可不得转载。若作者同意转载，必须以超链接形式标明文章原始出处和作者。
© 2003-2011 ITeye.com. All rights reserved. [ 京ICP证110151号 京公网安备110105010620 ]
<img src="" alt=""></p>
</li>
</ul>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/CAS/">CAS</a></li></span></span> | <span class="tags">Tagged <a href="/tags/CAS/" class="label label-primary">CAS</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:39"datetime="2014-03-07 09:54:39"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-CAS--casclient使用指南-老老-ITeye技术网站/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-CAS--casclient使用指南-老老-ITeye技术网站" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-CAS--CAS之自定义登录页实践-Codingforfun-ITeye技术网站/">CAS 之自定义登录页实践 </a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:39.000Z"> <a href="/2014/02/02/2014-02-02-CAS--CAS之自定义登录页实践-Codingforfun-ITeye技术网站/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="cas-coding-for-fun-iteye-">CAS 之自定义登录页实践 - Coding for fun. - ITeye技术网站</h1>
<p><img src="" alt=""> Saving Data...
正在保存数据...
正在儲存資料...</p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/CAS/">CAS</a></li></span></span> | <span class="tags">Tagged <a href="/tags/CAS/" class="label label-primary">CAS</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:39"datetime="2014-03-07 09:54:39"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-CAS--CAS之自定义登录页实践-Codingforfun-ITeye技术网站/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-CAS--CAS之自定义登录页实践-Codingforfun-ITeye技术网站" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-CAS--CAS的SSO实现细节-Jaytse的专栏-博客频道-CSDNNET/">CAS 的SSO实现细节 </a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:39.000Z"> <a href="/2014/02/02/2014-02-02-CAS--CAS的SSO实现细节-Jaytse的专栏-博客频道-CSDNNET/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="cas-sso-jaytse-csdn-net">CAS 的SSO实现细节 - Jaytse的专栏 - 博客频道 - CSDN.NET</h1>
<p>您还未登录！|<a href="http://passport.csdn.net/account/login" target="_blank">登录</a>|<a href="http://passport.csdn.net/account/register" target="_blank">注册</a>|<a href="http://passport.csdn.net/help/faq" target="_blank">帮助</a></p>
<ul>
<li><a href="http://www.csdn.net/" target="_blank">CSDN首页</a></li>
<li><a href="http://news.csdn.net/" target="_blank">资讯</a></li>
<li><a href="http://bbs.csdn.net/" target="_blank">论坛</a></li>
<li><a href="http://blog.csdn.net/" target="_blank">博客</a></li>
<li><a href="http://download.csdn.net/" target="_blank">下载</a></li>
<li><a href="http://so.csdn.net/" target="_blank">搜索</a></li>
<li><h2 id="-"><a href="">更多</a></h2>
</li>
<li><p><a href="http://cto.csdn.net/" target="_blank">CTO俱乐部</a></p>
</li>
<li><a href="http://student.csdn.net/" target="_blank">学生大本营</a></li>
<li><a href="http://edu.csdn.net/" target="_blank">培训充电</a></li>
<li><a href="http://mobile.csdn.net/" target="_blank">移动开发</a></li>
<li><a href="http://sd.csdn.net/" target="_blank">软件研发</a></li>
<li><a href="http://cloud.csdn.net/" target="_blank">云计算</a></li>
<li><a href="http://www.programmer.com.cn/" target="_blank">程序员</a></li>
<li><a href="http://www.iteye.com/" target="_blank">ITeye</a></li>
<li><a href="http://tup.csdn.net/" target="_blank">TUP</a></li>
</ul>
<h1 id="-jaytse-http-blog-csdn-net-jaytse-"><a href="http://blog.csdn.net/jaytse" target="_blank">Jaytse的专栏</a></h1>
<h2 id="-csdn">欢迎来到小米的CSDN</h2>
<ul>
<li><a href="http://blog.csdn.net/jaytse?viewmode=contents" target="_blank"><img src="" alt="">目录视图</a></li>
<li><a href="http://blog.csdn.net/jaytse?viewmode=list" target="_blank"><img src="" alt="">摘要视图</a></li>
<li><a href="http://blog.csdn.net/jaytse/rss/list" target="_blank"><img src="" alt="">订阅</a>
<a href="http://cloud.csdn.net/a/20120620/2806805.html" target="_blank">用开源IaaS构建自己的云——OpenStack征稿启事</a>                   <a href="http://topic.csdn.net/u/20120709/15/2e6511e3-e34f-41d7-9f71-a47bb4f8c9fa.html" target="_blank">CSDN社区7月&quot;畅谈加班 赢程序员杂志&quot;活动火爆上线！！</a>
<a href="http://blog.csdn.net/blogdevteam/article/details/7712568" target="_blank">2012年7月当选微软MVP的CSDN会员名单揭晓！</a>                    <a href="http://topic.csdn.net/u/20120704/14/c98b3641-359f-4bea-b111-21c409db8819.html" target="_blank">CSDN账号全站整合公告</a>                <a href="http://adclk.thinkmedia.cn/clk/pid=2000/media=CSDN.CN/place=1Clt1/size=760x90" target="_blank">不用买彩票，就有408万！</a></li>
</ul>
<h3 id="-cas-sso-"><a href="">CAS 的SSO实现细节</a></h3>
<p>分类： <a href="http://blog.csdn.net/jaytse/article/category/168314" target="_blank">J2EE</a>  2008-07-25 16:07 629人阅读 <a href="http://blog.csdn.net/jaytse/article/details/2710567#comments" target="_blank">评论</a>(0) <a href="&quot;收藏&quot;">收藏</a> <a href="http://blog.csdn.net/jaytse/article/details/2710567#report" title="举报" target="_blank">举报</a></p>
<p>实验步骤</p>
<ol>
<li><p>访问partner1 (CAS Client 1)的index.jsp</p>
</li>
<li><p>访问partner2 (CAS Client 2)的index.jsp</p>
</li>
<li><p>访问partner1的debug.jsp</p>
</li>
<li><p>访问<a href="http://www.test.com:443/cas-server/logout" target="_blank">www.test.com:443/cas-server/logout</a> (CAS Server)</p>
</li>
</ol>
<p>讨论</p>
<p>步骤一</p>
<p><a href="http://p.blog.csdn.net/images/p_blog_csdn_net/jaytse/EntryImages/20080725/p1.JPG" target="_blank">http://p.blog.csdn.net/images/p_blog_csdn_net/jaytse/EntryImages/20080725/p1.JPG</a></p>
<ol>
<li><p>请求partner1的index.jsp</p>
</li>
<li><p>发现请求页面为受限页面，REDIRECT 到CAS-Server端进行认证</p>
</li>
<li><p>返回CAS Server登录页面</p>
</li>
<li><p>输入用户名、密码，Form表单提交</p>
</li>
<li><p>CAS Server端进行认证，REDIRECT到Partner端，此时CAS-Server端为Partner1生成ST，并在浏览器记录CAS Server的Cookie</p>
</li>
<li><p>Partner端获取到ST后，到CAS Server端去验证，返回认证信息</p>
</li>
<li><p>若通过认证（1.0为yes， 2.0为XML格式验证），Partner返回请求的页面，并在浏览器记录Partner的Cookie</p>
</li>
</ol>
<p>步骤二</p>
<p><a href="http://p.blog.csdn.net/images/p_blog_csdn_net/jaytse/EntryImages/20080725/p2.JPG" target="_blank">http://p.blog.csdn.net/images/p_blog_csdn_net/jaytse/EntryImages/20080725/p2.JPG</a></p>
<ol>
<li><p>请求Partner2 的index.jsp</p>
</li>
<li><p>发现请求页面为受限页面，REDIRECT 到CAS-Server端进行认证。浏览器的Redirect带着将已经被记录了的通过认证的CAS Server的Cookie一同到CAS-Server认证</p>
</li>
<li><p>认证通过，REDIRECT到Partner2，此时CAS Server端为Partner2生成ST。</p>
</li>
<li><p>Partner 2获取到ST后，到CAS Server端去验证，返回认证信息</p>
</li>
<li><p>若通过认证，Partner2返回请求的页面，并在浏览器记录Partner2的Cookie</p>
</li>
</ol>
<p>步骤三</p>
<p><a href="http://p.blog.csdn.net/images/p_blog_csdn_net/jaytse/EntryImages/20080725/p3.JPG" target="_blank">http://p.blog.csdn.net/images/p_blog_csdn_net/jaytse/EntryImages/20080725/p3.JPG</a></p>
<ol>
<li><p>请求Partner 1的debug.jsp（带有Partner 1的Cookie信息）</p>
</li>
<li><p>返回debug.jsp</p>
</li>
</ol>
<p>步骤四</p>
<p><a href="http://p.blog.csdn.net/images/p_blog_csdn_net/jaytse/EntryImages/20080725/p4.JPG" target="_blank">http://p.blog.csdn.net/images/p_blog_csdn_net/jaytse/EntryImages/20080725/p4.JPG</a></p>
<ol>
<li><p>请求logout</p>
</li>
<li><p>CAS Server通知Partner 1和Partner 2</p>
</li>
<li><p>返回CAS Server的logout页面</p>
</li>
</ol>
<p>备注</p>
<p>Redirect分成2个步骤：</p>
<ol>
<li><p>response发送给浏览器返回信息，通知浏览器创建新的请求</p>
</li>
<li><p>请求新的页面</p>
</li>
</ol>
<p>Cookie中携带的信息：</p>
<ol>
<li><p>域名</p>
</li>
<li><p>路径
当域名和路径名全部相同的时候，浏览器产生请求才把对应的信息一同携带给服务器</p>
</li>
</ol>
<p>分享到： <a href="&quot;分享到新浪微博&quot;"></a><a href="&quot;分享到腾讯微博&quot;"></a></p>
<ul>
<li>上一篇：<a href="http://blog.csdn.net/jaytse/article/details/2710041" target="_blank">CAS学习笔记</a></li>
<li><p>下一篇：<a href="http://blog.csdn.net/jaytse/article/details/2710594" target="_blank">Solaris10 cron使用</a>
查看评论<a href=""></a></p>
<p>暂无评论
您还没有登录,请<a href="http://passport.csdn.net/account/login?from=http%3A%2F%2Fblog.csdn.net%2Fjaytse%2Farticle%2Fdetails%2F2710567" target="_blank">[登录]</a>或<a href="http://passport.csdn.net/account/register?from=http%3A%2F%2Fblog.csdn.net%2Fjaytse%2Farticle%2Fdetails%2F2710567" target="_blank">[注册]</a></p>
</li>
</ul>
<p>/* 以上用户言论只代表其个人观点，不代表CSDN网站的观点或立场<a href=""></a><a href=""></a></p>
<p>个人资料</p>
<p><a href="http://my.csdn.net/jaytse" target="_blank"><img src="&quot;访问我的空间&quot;" alt=""></a>
<a href="http://my.csdn.net/jaytse" target="_blank">jaytse</a></p>
<p><a href="http://blog.csdn.net/jaytse/article/details/2710567#" title="[加关注]" target="_blank"></a> <a href="http://my.csdn.net/my/letter/send/jaytse" title="[发私信]"></a></p>
<ul>
<li>访问：68320次</li>
<li>积分：1431分</li>
<li><p>排名：第4313名</p>
</li>
<li><p>原创：68篇</p>
</li>
<li>转载：30篇</li>
<li>译文：0篇</li>
<li>评论：46条</li>
</ul>
<p>文章搜索</p>
<p><a href=""></a>
文章分类</p>
<ul>
<li><a href="http://blog.csdn.net/jaytse/article/category/168316" target="_blank">C Programming Language</a>(4)</li>
<li><a href="http://blog.csdn.net/jaytse/article/category/358000" target="_blank">database</a>(4)</li>
<li><a href="http://blog.csdn.net/jaytse/article/category/168313" target="_blank">Design Pattern</a>(0)</li>
<li><a href="http://blog.csdn.net/jaytse/article/category/168317" target="_blank">Framework</a>(0)</li>
<li><a href="http://blog.csdn.net/jaytse/article/category/168314" target="_blank">J2EE</a>(21)</li>
<li><a href="http://blog.csdn.net/jaytse/article/category/168315" target="_blank">J2SE</a>(12)</li>
<li><a href="http://blog.csdn.net/jaytse/article/category/358001" target="_blank">System</a>(4)</li>
<li><a href="http://blog.csdn.net/jaytse/article/category/168318" target="_blank">心情点滴</a>(42)</li>
</ul>
<p>文章存档</p>
<ul>
<li><a href="http://blog.csdn.net/jaytse/article/month/2010/05" target="_blank">2010年05月</a>(1)</li>
<li><a href="http://blog.csdn.net/jaytse/article/month/2010/04" target="_blank">2010年04月</a>(1)</li>
<li><a href="http://blog.csdn.net/jaytse/article/month/2010/01" target="_blank">2010年01月</a>(4)</li>
<li><a href="http://blog.csdn.net/jaytse/article/month/2009/12" target="_blank">2009年12月</a>(1)</li>
<li><a href="http://blog.csdn.net/jaytse/article/month/2009/11" target="_blank">2009年11月</a>(1)</li>
<li><a href="http://blog.csdn.net/jaytse/article/month/2009/10" target="_blank">2009年10月</a>(2)</li>
<li><a href="http://blog.csdn.net/jaytse/article/month/2009/05" target="_blank">2009年05月</a>(4)</li>
<li><a href="http://blog.csdn.net/jaytse/article/month/2008/12" target="_blank">2008年12月</a>(3)</li>
<li><a href="http://blog.csdn.net/jaytse/article/month/2008/11" target="_blank">2008年11月</a>(2)</li>
<li><a href="http://blog.csdn.net/jaytse/article/month/2008/09" target="_blank">2008年09月</a>(4)</li>
<li><a href="http://blog.csdn.net/jaytse/article/month/2008/08" target="_blank">2008年08月</a>(2)</li>
<li><a href="http://blog.csdn.net/jaytse/article/month/2008/07" target="_blank">2008年07月</a>(11)</li>
<li><a href="http://blog.csdn.net/jaytse/article/month/2008/05" target="_blank">2008年05月</a>(1)</li>
<li><a href="http://blog.csdn.net/jaytse/article/month/2008/04" target="_blank">2008年04月</a>(1)</li>
<li><a href="http://blog.csdn.net/jaytse/article/month/2008/01" target="_blank">2008年01月</a>(5)</li>
<li><a href="http://blog.csdn.net/jaytse/article/month/2007/10" target="_blank">2007年10月</a>(1)</li>
<li><a href="http://blog.csdn.net/jaytse/article/month/2007/09" target="_blank">2007年09月</a>(1)</li>
<li><a href="http://blog.csdn.net/jaytse/article/month/2007/08" target="_blank">2007年08月</a>(2)</li>
<li><a href="http://blog.csdn.net/jaytse/article/month/2007/07" target="_blank">2007年07月</a>(2)</li>
<li><a href="http://blog.csdn.net/jaytse/article/month/2007/03" target="_blank">2007年03月</a>(1)</li>
<li><a href="http://blog.csdn.net/jaytse/article/month/2006/11" target="_blank">2006年11月</a>(2)</li>
<li><a href="http://blog.csdn.net/jaytse/article/month/2006/10" target="_blank">2006年10月</a>(4)</li>
<li><a href="http://blog.csdn.net/jaytse/article/month/2006/09" target="_blank">2006年09月</a>(3)</li>
<li><a href="http://blog.csdn.net/jaytse/article/month/2006/08" target="_blank">2006年08月</a>(3)</li>
<li><a href="http://blog.csdn.net/jaytse/article/month/2006/07" target="_blank">2006年07月</a>(2)</li>
<li><a href="http://blog.csdn.net/jaytse/article/month/2006/06" target="_blank">2006年06月</a>(4)</li>
<li><a href="http://blog.csdn.net/jaytse/article/month/2006/05" target="_blank">2006年05月</a>(1)</li>
<li><a href="http://blog.csdn.net/jaytse/article/month/2006/04" target="_blank">2006年04月</a>(2)</li>
<li><a href="http://blog.csdn.net/jaytse/article/month/2006/03" target="_blank">2006年03月</a>(12)</li>
<li><a href="http://blog.csdn.net/jaytse/article/month/2006/02" target="_blank">2006年02月</a>(2)</li>
<li><a href="http://blog.csdn.net/jaytse/article/month/2006/01" target="_blank">2006年01月</a>(6)</li>
<li><a href="http://blog.csdn.net/jaytse/article/month/2005/12" target="_blank">2005年12月</a>(6)</li>
<li><a href="http://blog.csdn.net/jaytse/article/month/2005/08" target="_blank">2005年08月</a>(1)</li>
</ul>
<p>展开
阅读排行</p>
<ul>
<li><a href="http://blog.csdn.net/jaytse/article/details/2710041" title="CAS学习笔记" target="_blank">CAS学习笔记</a>(6331)</li>
<li><a href="http://blog.csdn.net/jaytse/article/details/578083" title="IBM 几次电话面试的总结" target="_blank">IBM 几次电话面试的总结</a>(4022)</li>
<li><a href="http://blog.csdn.net/jaytse/article/details/4210625" title="Openfire Connection Manager 配置" target="_blank">Openfire Connection Manager 配置</a>(3454)</li>
<li><a href="http://blog.csdn.net/jaytse/article/details/3291578" title="MSN协议分析以及Java实现MSN登陆" target="_blank">MSN协议分析以及Java实现MSN登陆</a>(2666)</li>
<li><a href="http://blog.csdn.net/jaytse/article/details/3452981" title="利用HTTP协议获取163的联系人列表(1)" target="_blank">利用HTTP协议获取163的联系人列表(1)</a>(2190)</li>
<li><a href="http://blog.csdn.net/jaytse/article/details/3453123" title="利用HTTP协议获取163的联系人列表(3)" target="_blank">利用HTTP协议获取163的联系人列表(3)</a>(2029)</li>
<li><a href="http://blog.csdn.net/jaytse/article/details/632843" title="WAS中关于命令行部署EAR" target="_blank">WAS中关于命令行部署EAR</a>(1788)</li>
<li><a href="http://blog.csdn.net/jaytse/article/details/565439" title="Axis试用小记（－）" target="_blank">Axis试用小记（－）</a>(1719)</li>
<li><a href="http://blog.csdn.net/jaytse/article/details/1536991" title="我的这半年---离职和求职" target="_blank">我的这半年---离职和求职</a>(1537)</li>
<li><a href="http://blog.csdn.net/jaytse/article/details/659098" title="“老板”的故事" target="_blank">“老板”的故事</a>(1511)</li>
</ul>
<p>评论排行</p>
<ul>
<li><a href="http://blog.csdn.net/jaytse/article/details/4210625" title="Openfire Connection Manager 配置" target="_blank">Openfire Connection Manager 配置</a>(6)</li>
<li><a href="http://blog.csdn.net/jaytse/article/details/3452981" title="利用HTTP协议获取163的联系人列表(1)" target="_blank">利用HTTP协议获取163的联系人列表(1)</a>(6)</li>
<li><a href="http://blog.csdn.net/jaytse/article/details/5627289" title="[转载] 沦丧——交大校友的真实职场经历和体会" target="_blank">[转载] 沦丧——交大校友的真实职场经历和体会</a>(4)</li>
<li><a href="http://blog.csdn.net/jaytse/article/details/2710041" title="CAS学习笔记" target="_blank">CAS学习笔记</a>(4)</li>
<li><a href="http://blog.csdn.net/jaytse/article/details/5274598" title="逝去的2009（四）" target="_blank">逝去的2009（四）</a>(4)</li>
<li><a href="http://blog.csdn.net/jaytse/article/details/995743" title="IBM CSDL的几个月" target="_blank">IBM CSDL的几个月</a>(3)</li>
<li><a href="http://blog.csdn.net/jaytse/article/details/2710925" title="用 openssl 签发CA" target="_blank">用 openssl 签发CA</a>(2)</li>
<li><a href="http://blog.csdn.net/jaytse/article/details/578083" title="IBM 几次电话面试的总结" target="_blank">IBM 几次电话面试的总结</a>(2)</li>
<li><a href="http://blog.csdn.net/jaytse/article/details/5216774" title="逝去的2009（三）" target="_blank">逝去的2009（三）</a>(2)</li>
<li><a href="http://blog.csdn.net/jaytse/article/details/643466" title="A week went again" target="_blank">A week went again</a>(2)
推荐文章</li>
</ul>
<p>最新评论</p>
<ul>
<li><a href="http://blog.csdn.net/jaytse/article/details/4210625#comments" target="_blank">Openfire Connection Manager 配置</a></li>
</ul>
<p>taizans: good..</p>
<ul>
<li><a href="http://blog.csdn.net/jaytse/article/details/4210625#comments" target="_blank">Openfire Connection Manager 配置</a></li>
</ul>
<p>xueixin: 我的bin/cmanager.sh 启动不起来咋回事啊，能够提供一些详细的解决方案吗？ 我的qq67...</p>
<ul>
<li><a href="http://blog.csdn.net/jaytse/article/details/4210625#comments" target="_blank">Openfire Connection Manager 配置</a></li>
</ul>
<p>nongyan90: 你说的这些对我很有用，谢谢了！</p>
<ul>
<li><a href="http://blog.csdn.net/jaytse/article/details/4210625#comments" target="_blank">Openfire Connection Manager 配置</a></li>
</ul>
<p>nongyan90: author ，我们很关心图啊</p>
<ul>
<li><a href="http://blog.csdn.net/jaytse/article/details/4210625#comments" target="_blank">Openfire Connection Manager 配置</a></li>
</ul>
<p>leibf: 所谓胡图在哪里</p>
<ul>
<li><a href="http://blog.csdn.net/jaytse/article/details/2710041#comments" target="_blank">CAS学习笔记</a></li>
</ul>
<p>if_else123: 学习了，正在找单点登录方面的资料，虽然没有这么做，但还是支持楼主。</p>
<ul>
<li><a href="http://blog.csdn.net/jaytse/article/details/2710041#comments" target="_blank">CAS学习笔记</a></li>
</ul>
<p>jaytse: 呵呵，我基本上没有看懂你的问题；但我想可能是spring的事情吧；1.5比1.4多了泛型和其他扩展，...</p>
<ul>
<li><a href="http://blog.csdn.net/jaytse/article/details/4210625#comments" target="_blank">Openfire Connection Manager 配置</a></li>
</ul>
<p>liu282713097:</p>
<ul>
<li><a href="http://blog.csdn.net/jaytse/article/details/3452981#comments" target="_blank">利用HTTP协议获取163的联系人列表(1)</a></li>
</ul>
<p>tianguowei123: 你好，你写的那篇关于《利用HTTP协议获取163的联系人列表》三个系列，但是现在又改了，有空帮忙分析...</p>
<ul>
<li><a href="http://blog.csdn.net/jaytse/article/details/5627289#comments" target="_blank">[转载] 沦丧——交大校友的真实职场经历和体会</a></li>
</ul>
<p>lwchw: 工作的不入操作的，这年头完全颠倒了。
设计模式</p>
<ul>
<li><a href="http://dev.csdn.net/article/68/68538.shtm" target="_blank">设计模式(Patterns in Java)</a></li>
</ul>
<p>我的相册</p>
<ul>
<li><a href="http://picasaweb.google.com/xjtujay" target="_blank">Google相册</a></li>
<li><p><a href="http://xiaoyou.qq.com/index.php?mod=photo&amp;u=c265e4bd629300c5dfe5aad01ee2601cc513190cdf90331d" target="_blank">QQ相册</a>
学生时代</p>
</li>
<li><p><a href="http://www.neiep.edu.cn/" target="_blank">东北电力学院</a></p>
</li>
<li><a href="http://www.xjtu.edu.cn/" target="_blank">西安交通大学</a></li>
<li><a href="http://www.polyu.edu.hk/" target="_blank">香港理工大学</a></li>
</ul>
<p>衣食父母</p>
<ul>
<li><a href="http://www.gzoas.com/" target="_blank">广州傲思（已经倒了）</a></li>
<li><a href="http://www-900.ibm.com/cn/cdl/infomagmt/" target="_blank">IBM CSDL</a></li>
<li><a href="http://www.iscas.ac.cn/" target="_blank">中科院软件所</a></li>
<li><a href="http://www.sysu.edu.cn/" target="_blank">中山大学</a></li>
<li><p><a href="http://www.hku.hk/" target="_blank">香港大学</a>
友情支持</p>
</li>
<li><p><a href="http://blog.csdn.net/yevv" target="_blank">yevv&#39;s blog</a></p>
</li>
<li><a href="http://ourifa.bokee.com/" target="_blank">our ifa&#39;s blog</a><pre><code>![]()
</code></pre></li>
</ul>
<p><a href="http://www.csdn.net/company/about.html" target="_blank">公司简介</a>|<a href="http://www.csdn.net/company/recruit.html" target="_blank">招贤纳士</a>|<a href="http://www.csdn.net/company/marketing.html" target="_blank">广告服务</a>|<a href="http://www.csdn.net/company/account.html" target="_blank">银行汇款帐号</a>|<a href="http://www.csdn.net/company/contact.html" target="_blank">联系方式</a>|<a href="http://www.csdn.net/company/statement.html" target="_blank">版权声明</a>|<a href="http://www.csdn.net/company/layer.html" target="_blank">法律顾问</a>|<a href="mailto:webmaster@csdn.net">问题报告</a>京 ICP 证 070598 号北京创新乐知信息技术有限公司 版权所有<img src="" alt=""> 联系邮箱：webmaster@csdn.netCopyright © 1999-2012, CSDN.NET, All Rights Reserved <a href="http://www.hd315.gov.cn/beian/view.asp?bianhao=010202001032100010" target="_blank"><img src="" alt="GongshangLogo"></a></p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/CAS/">CAS</a></li></span></span> | <span class="tags">Tagged <a href="/tags/CAS/" class="label label-primary">CAS</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:39"datetime="2014-03-07 09:54:39"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-CAS--CAS的SSO实现细节-Jaytse的专栏-博客频道-CSDNNET/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-CAS--CAS的SSO实现细节-Jaytse的专栏-博客频道-CSDNNET" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>





<ul id="pagination" class="pagination pagination-lg">
  <li><a class="extend prev" href="/page/81/">&laquo;</a></li><li><a class="page-number" href="/">1</a></li><li><a class="page-number" href="/page/2/">2</a></li><li><span class="space">&hellip;</span></li><li><a class="page-number" href="/page/79/">79</a></li><li><a class="page-number" href="/page/80/">80</a></li><li><a class="page-number" href="/page/81/">81</a></li><li class="active"><li><span class="page-number current">82</span></li><li><a class="page-number" href="/page/83/">83</a></li><li><a class="page-number" href="/page/84/">84</a></li><li><a class="page-number" href="/page/85/">85</a></li><li><span class="space">&hellip;</span></li></li><li><a class="page-number" href="/page/161/">161</a></li><li><a class="page-number" href="/page/162/">162</a></li><li><a class="extend next" href="/page/83/">&raquo;</a></li>
  <div class="clearfix"></div>
</ul></div><!--wapper-->
       </div><!-- ID main-col END -->
       <aside id="sidebar" class="alignright col-sx-6 col-sm-4 col-md-3 col-lg-3">
<div id="widget_search" class="widget panel panel-primary">
    <form action="//google.com/search" method="get" accept-charset="utf-8">
  <div class="input-group">
    <input class="form-control" id="searchbox" type="search" name="q" results="0" placeholder="search">
    <span class="input-group-btn">
      <button class="btn btn-default" type="submit">Go!</button>
    </span>
    <input type="hidden" name="q" value="site:itsolife.com">
  </div>
</form>
</div>

<div id="widget_category" class="widget panel panel-primary">
  <div class="panel-heading">category</div>  <div data-src='category' class='ajax_widgets'>正在加载...</div>
</div>

<div id="widget_recent_posts" class="widget panel panel-primary">
  <div class="panel-heading">recent posts</div>  <div data-src='recent_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_tagcloud" class="widget panel panel-primary">
  <div class="panel-heading">tagcloud</div>  <div data-src='tagcloud' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_latest_update_posts" class="widget panel panel-primary">
  <div class="panel-heading">最近更新</div>  <div data-src='latest_update_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_recent_comments" class="widget panel panel-primary">
  <div class="panel-heading">recent comments</div>  

<div class="list-group-item ds-recent-comments" data-num-items="6" data-show-avatars="1" data-show-time="1" data-show-title="1" data-show-admin="1" data-excerpt-length="50"></div>



</div>

</aside>
       <div class="clearfix"></div>
     </div><!-- row END -->
  </div>
  <footer id="footer" class="container">
  <div class="panel panel-info">
  <section id='footer_widget'></section>  <div class="panel-footer">
  <div id="site-info">
    <span class='author'>
  
  &copy; 2014 RobinChia
  
    &nbsp;&nbsp;</span>
  
  <span id='analytics-51la'></span><span id='analytics-google'>
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-48559895-1']);
  _gaq.push(['_trackPageview']);
  _js2load.push({src:('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'});
</script></span><span id='analytics-cnzz'>
<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_5774006'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s17.cnzz.com/stat.php%3Fid%3D5774006%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>
</span><span id='analytics-baidu'>
<script>
var _hmt = _hmt || [];
_js2load.push({src:"//hm.baidu.com/hm.js?1442f50724afc42380b51f097c43082c"});
</script>
</span>  </div>
  <div id="copyright">Site powered by <a href='http://zespia.tw/hexo/'><strong>hexo</strong></a>  update time: <em>2014-04-07 19:05:47</em></span></div>
</div>
<div class="clearfix"></div>


  </div>
  </footer>
  
        <script src="http://cdn.bootcss.com/jquery/1.10.2/jquery.min.js"></script>        
        <script src="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/js/bootstrap.min.js"></script>        
                
        <script src="http://cdn.bootcss.com/prettify/r298/prettify.min.js"></script>    <script type="text/javascript">
   var lang=["bsh", "c", "cc", "cpp", "cs", "csh", "cyc", "cv", "htm", "html",
    "java", "js", "m", "mxml", "perl", "pl", "pm", "py", "rb", "sh",
    "xhtml", "xml", "xsl"];
   var pretty_base='';
   $('script').each(function(){
	var c = $(this).attr('src');
	if (!c)
	    return;
	if (c.match(/(\/)?prettify(\.min)?\.js/i))
	{
	    var index = c.lastIndexOf('/');
	    if (index != -1)
		pretty_base = c.substr(0,index + 1);
	    return false;
	}
   })
   $('pre code').each(function(){
	var c = $(this).attr('class')
	if (!c)
	    return;
	c = c.match(/\s?(lang\-\w+)/i);
	if (c && lang.indexOf(c[1]) == -1)
	{
	    lang.push(c[1]);
	    $.getScript(pretty_base + c[1] + '.min.js');
	}
   })

    $(window).load(function(){
       $("pre").addClass("prettyprint");
       prettyPrint();
    })
</script>    
            <script type="text/javascript">
var duoshuoQuery = {short_name:"robinchia"};
_js2load.push({src:'http://static.duoshuo.com/embed.js',charset:'UTF-8'});
</script>
    
            <!--wumii_relatedItems-->
    
        <script src="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js"></script>    <script type="text/javascript">
(function($){
  $('.entry').each(function(i){
    $(this).find('img').each(function(){
      var alt = this.alt;

      if (alt){
        $(this).before('<span class="caption">' + alt + '</span>');
      }

      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox" rel="fancybox' + i + '" />');
    });
  });

  $('.fancybox').fancybox();
})(jQuery);
</script>    
        <script src="http://cdn.bootcss.com/mathjax/2.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>    <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>
    
<script type="text/javascript">
$('.ajax_widgets').each(function(){var src=$(this).attr('data-src');if(src)$(this).load('/widgets/'+src+'.html');});
$.each(_js2load,function(index,obj){loadjs(obj.src,obj.charset)});
</script>

<div id="scroll2top">
<img src="/scroll2top/arrow.png"/>
</div>
<script src="/scroll2top/scroll2top.min.js"></script>
<div id="winterland">
  <canvas></canvas>
</div>
<script src="/js/winterland.min.js"></script>

  </body>
</html>
