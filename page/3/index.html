
<!DOCTYPE HTML>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>The 3 Page | It so life</title>
<meta name="author" content="RobinChia">

<meta name="description" content="It so life">


<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<meta property="og:site_name" content="It so life"/>

<!--[if IE]><style>.testIE.IE{display:inline;}</style><![endif]-->
<!--[if lte IE 7]><link rel="stylesheet" href="/css/ie7.css" type="text/css"><![endif]-->
<!--[if (lt IE 9)&(gt IE 7)]><style>.testIE.IE8{display:inline;}</style><![endif]-->
<!--[if gt IE 8]><style>.testIE.IE9{display:inline;}</style><![endif]-->

<link href="/favicon.png" rel="icon">
<link rel="alternate" href="/atom.xml" title="It so life Feed" type="application/atom+xml">

<link rel="stylesheet" href="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/css/bootstrap.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/font-awesome/4.0.3/css/font-awesome.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/prettify/r298/prettify.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" type="text/css">
<link rel="stylesheet" href="/css/style.css" type="text/css">
<!--[if lt IE 9]>
   <style>article,aside,dialog,footer,header,section,footer,nav,figure,menu{display:block}</style>
   <script src="http://cdn.staticfile.org/html5shiv/r29/html5.min.js"></script>
   <script src="http://cdn.staticfile.org/respond.js/1.4.2/respond.min.js"></script>
<link href="http://cdn.staticfile.org/respond.js/1.4.2/respond-proxy.html" id="respond-proxy" rel="respond-proxy" />
<link href="/js/respond.proxy.gif" id="respond-redirect" rel="respond-redirect" />
<script src="/js/respond.proxy.js"></script>
   <script src="http://cdn.bootcss.com/selectivizr/1.0.2/selectivizr-min.js"></script>
<![endif]-->
<script type="text/javascript">
function loadjs(c,d){var a=document.createElement("script");a.async=!0;a.type="text/javascript";a.src=c;a.charset=d||"gbk";(document.getElementsByTagName("HEAD")[0]||document.getElementsByTagName("BODY")[0]).appendChild(a)};
var _protocol = (("https:" == document.location.protocol) ? " https://" : " http://");
var _js2load = [];
</script>

</head>
<body>
      <header id="header" class="container"><nav id="main-nav" class="navbar navbar-default navbar-fixed-top " role="navigation">
  <div class="container">
    <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
      <span class="sr-only">Toggle navigation</span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="/">It so life</a>
    </div>
    <div  class="collapse navbar-collapse">
      <ul  class="nav navbar-nav">
  
        <li><a href="/" title="Home">Home</a></li>      
        <li><a href="/about/" title="About">About</a></li>      
        <li><a href="/archives/" title="Archives">Archives</a></li>      
      <li class='dropdown'>
        <a class='dropdown-toggle' data-toggle='dropdown' href='#'>website<b class='caret'></b></a>
        <ul class='dropdown-menu pure-menu-selected'>
    
          <li><a href="//groups.google.com/forum/#!forum/pongba" title="TopLanguage">TopLanguage</a></li>    
          <li><a href="//itpub.net/" title="ITPub">ITPub</a></li>    
          <li><a href="//blog.jobbole.com/" title="Bole">Bole</a></li>    
          <li><a href="//nosql-database.org/" title="nosql">nosql</a></li>    
          <li><a href="//gitimmersion.googol.im/" title="Git">Git</a></li>    
        </ul>
      </li>
    
      </ul>
      <ul class="nav navbar-nav navbar-right">
      
        <li><a href="/atom.xml">RSS</a></li>
      
      
        <li><a href="https://twitter.com/robinchia">twitter</a></li>
      
      
      
      
        <li><a href="https://github.com/robinchia">github</a></li>
      
      </ul>
    </div>
  </div>
</nav>
<div class="clearfix"></div>
</header>
  <div id='content' class="container">
     <div class="page-header-wrapper">
      <!--[if lt IE 9]><div class="alert alert-warning alert-dismissable"><button type="button" class="close" data-dismiss="alert" aria-hidden="true">&times;</button><strong>提示:</strong>您的浏览器版本太低了,建议升级到 <strong><a href="http://windows.microsoft.com/zh-cn/internet-explorer/download-ie" title="IE9">IE9</a></strong> 以上,本站使用<a href="https://www.google.com/intl/zh-CN/chrome/">Chrome浏览器</a>可以获得最好的显示效果.</div><![endif]-->
      <div class="page-header"><h1 align="center"><big>It so life</big> </h1>
        <h5 align="center"><big>love as life</big></h5>
      </div>
     </div>
     <div class="row">
       <div id="main-col" class="alignleft col-sx-12 col-sm-8 col-md-9 col-lg-9">
      <section id='header_widget'></section>
          <div id="wrapper"><article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/03/2014-02-03--《Rework》摘录及感想/">《Rework》摘录及感想</a></h1>
      
        <span>Posted on<time datetime="2014-02-03T03:24:29.000Z"> <a href="/2014/02/03/2014-02-03--《Rework》摘录及感想/">feb. 3 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-rework-">《Rework》摘录及感想</h1>
<p>2013年3月11日 <a href="http://coolshell.cn/articles/author/haoel" title="由 陈皓 发布" target="_blank">陈皓</a> <a href="">发表评论</a> <a href="">阅读评论</a> 36,592 人阅读    </p>
<p><img src="" alt="">读了《Rework》这本书好多遍，每次读都有不同的感想。但从来没有把这些感想记录下来，今天把《Rework》书中的一些章节做一些摘录，并把我的一些感想总结出来。供大家参考。这是一本平生以来让我中毒很深的书，也是一本让我思考得很多的书。希望看到这篇文章的人都能好好地读读这本书。这本书并不难读，是一本你可以一口气不中断就可以读完的书。</p>
<h3 id="-">现实世界</h3>
<p>“这在现实世界里面行不通”，当你向人们介绍一个新创意时，人们总是这么回答你。这个“现实世界”听起来如此令人沮丧，……只有人耳熟能详，习以为常的事情才会胜利，即使是这些事情已经漏洞百出陈腐低效。</p>
<p>揭开“现实世界”这个锅盖，你会发现居住在里的人都充斥着悲观主义和失望的情绪。更糟的是，他们想将别人拖进他们的坟墓。如果你是充满希望和野心的人，他们会试着说服你，你的想法是不可能的。他们会说你在浪费时间。</p>
<p><strong>“现实世界”并不存在，那只是人的一个借口。只是某些人为了开脱 自己的无所作为，跟你一点关系也没有。</strong>
<strong>感想</strong>：我经常会向一同事和朋友提及一些我的想法，朋友同事们经常会回答我——这个事某某人，某某团队做过了，没成功。或是对我说，你做这个事的时候，要小心这个要小心那个。我觉得，这个时候是最考验我们的时候了，要有一个清醒的头脑去分析别人的话，别人真不代表自己。这个世界上大多数人都是比较保守的，大多数都对这个现实世界都有或多或少的恐惧感。当然，你可以选择做大众，但是如果你想让你的人生有些不同，有些精彩，我还是建议你不要和大多数人想得一样，<strong>如果你和大多数人的想法一样，你必然会和大多数人一样的平庸</strong>。当然，如果你和大多数人不一样，你要么就是天才，要么就是傻瓜。要证明你自己是不是傻瓜，我们可以看看我们过去有没有过一些小成功或小成绩。如果有，那么就应该大胆地坚持自己的想法。</p>
<h3 id="-">被高估的“从错误中学习”</h3>
<p>你真的从错误和失败里面学到什么了吗？你也许学到了别再重蹈覆辙，但是这有什么意义吗？你仍然不知道接下来该做什么。</p>
<p><strong>相反的应该从成功中汲取养分。成功給予真正靠得住的教材。</strong></p>
<p>失败并不是成功的先决条件。自然规律是，<strong>逗留在过去的失败中是无法进化的，进化是建立在成功的基础上的</strong>。
<strong>感想</strong>：我见过和很多人都在抱怨这不好那不好，但是他们其实并不知道什么是好的，因为——没有见过好的，你将永远不知道什么是好的。就好像你没有见过什么是汽车，你就只会整天在抱怨为什么骑自行车太累。回头想想我们的编程的这个过程也是一样，我们编程技能的提高基本上都是在看到别人的那些漂亮优雅的代码。所以，你一定要去看看那些优秀人干是怎么想的，怎么干的，去那些成功的公司开开眼界。另外，你应该多想想你过去做成功过什么事？那些才是你的长处，才是让你进化的前提。</p>
<h3 id="-">计划就是瞎猜</h3>
<p>除非你是算命先生，长期的商业计划是种幻想。有太多的事实证明那是超出你的掌控的：市场环境、对手、顾客、经济等等。做计划让你觉得一切尽在掌握但实际上你没有。</p>
<p><strong>当你把计划变成猜测时，就等于进入一个危险的境地。做计划就是在用过去推导未来，等于给你戴上了眼罩。</strong>
<strong>感想</strong>：你有职业规划吗？如果你有的话，那么你就一定就错了。职业规划是一件很扯淡的事情。我和一些高手都交流过，其实这些人在当初都并不有什么职业规划的，要说有的话，也就是想把技术搞透搞精。这些人在一开始从来没有想过要当个什么经理或是什么架构师之类的东西，这些人就是对技术有非常大的热情，把身边的那些看得见够得着的事情做到好好地，并且保持不持续强大的好奇心努力地学习自己不懂的东西。一个坚定不移的决定和意志力会比任何的计划和职业规划都重要。<strong>你问问自己，想不想当程序员，能不能一辈子都当一个程序员，能不能写程序写一辈子？</strong>（关于做一辈子程序员这个事，大家可以看看我的<a href="http://weibo.com/1401880315/zmebaF5tQ" target="_blank">新浪微博</a> ——<em>没哪个行业能像计算机行业这么活跃、刺激和有趣了。不仅是新兴工业革命的主力，又渗入到所有的行业中，干一辈子值了。//<a href="http://weibo.com/n/_%E4%BD%A0%E4%BA%B2%E7%88%B1%E7%9A%84%E5%81%8F%E6%89%A7%E7%8B%82" target="_blank">@_你亲爱的偏执狂</a>: 程序员首先是工程师，Professional，就跟律师，医生一样，给大家解决问题；但是另一面呢，又是艺术家，创造新奇好玩的东西。这样的职业做一辈子有什么问题？</em>）</p>
<h3 id="-">拒绝壮大</h3>
<p>规模越大你就得承受更大压力、需要更专业、拥有更强的能力。</p>
<p><strong>有没有注意到，一个小公司希望自己变大时，大公司却想要变得灵活变通</strong>。记住，一旦你变大了就很难在不解雇人、不破坏士气、不改变你的整个商业路线的情况下收缩规模。</p>
<p>扩张不必成为你的目标。我们也不是仅在讨论你已有员工数。 还有花费、租金、IT 基础结构、设备等。这些事情不会碰巧发生。 你来决定是否承受这些。如果你决定去承受，你也将遇到新的头痛问题。花费那么多，你强迫自己构建一个复杂的生意，有一大堆困难而高压的事情要解决。</p>
<p><strong>小公司并不是一个起步，小公司本身就是一个伟大的目标。</strong>
<strong>感想</strong>：很多人都会以为拥有一支成百上千人的团队而成为一个成功的标志。就像很多朋友和猎头都会问我管多少人，当我说，我就管个十人不到的团队时，他们似乎都会觉得我很平庸。他们中的一些人基本上就不会再问我在干些什么了，因为他们可能觉得这么少的人都干什么大事呢？。当然，我说了他们也不一定听得懂。人多可能恰恰说明你可能在干一个劳动密集型的事情，这并没有什么可自豪的。真正自豪的不是在战争中用人海战术让大量的人去当炮灰，而是用一个小分队端掉敌军的军火库或指挥部。所以，<strong>关键不是你有多少人，关键是你做的事是不是有非凡的意义，而且你用了最小当量的资源。这就好像建立一个高性能的网站一样，用成百上千的服务器不算本事，谁用的少才是本事</strong>。</p>
<h3 id="-">工作狂</h3>
<p>工作狂的行为不但没有必要，而且愚蠢至极。过多的工作并不代表你对项目更关注，也不代表你作了更多的贡献，这仅仅意味着你干了更多的活而已。<strong>工作狂制造的麻烦比解决的麻烦多</strong>。</p>
<p>工作狂往往不得要领。他们花大把大把的时间去解决问题，<strong>他们以为能靠蛮力来弥补思维上的惰性，其结果就是折腾出一堆粗糙无用的解决方案</strong>。</p>
<p><strong>如果你只是为了工作而工作，那么你就会丧失判断力。你的价值 观和决策方式都是扭曲</strong>。你没有能力去判断哪些工作值得做，哪些工作该放弃，最后搞得自己筋疲力尽，而一个筋疲力尽的人是无法作出明智的决定的。</p>
<p><strong>工作狂不是英雄。他们不是在节约时间而是在浪费生命。真正的英雄早已想出了办法，搞定一切，然后回家了。</strong>
<strong>感想</strong>：这让我想到了那些为了冲业绩的业绩KPI的制订者们，很多时候，他们的价值观和决策真是的很扭曲的。他们生生地把一种技术密集型的工作变成了劳动密集型。<strong>他们其实就是在拼命地训练客户需要的那匹“更快的马”，而从来没有想过要去造个更快的交通工具。</strong></p>
<p>另外，每当我在优秀员工的评比和员工的绩效考核中的跨团队比较中我们能听到很多很多的人说，XX员工工作任劳任愿，工作得很晚很晚，付出很大。老实说，我真的为这样的价值观感到悲哀。最后，我还想说说关于超时工作，我也经常学习和做自己的事情到深夜，我相信很多人也这样，但我们应该认真思考一下Rework中的这个观点，<strong>我们超时工作是在使用蛮力呢？还是在使用热情和兴趣呢？</strong></p>
<h3 id="-">挠自己的痒处</h3>
<p>想要创造一款伟大的产品或者是某项卓越的服务，最直接、最简单的方法就是去做你自己想用的东西。设计你了解的产品——你就能很快发现它到到底好不好用。</p>
<p><strong>最棒的是，“解决你实际遇到的问题”会让你爱上你做的事情</strong>。 你知道问题所在并且熟知解决它的价值。这是无法替代的。毕竟，你会充满希望的在接下来的日子里继续做。 甚至会占据你余生所有时间。所以，最好还是做自己真正关心的东西。
<strong>感想</strong>：这就是吃自己的狗食，做自己感兴趣的事。软件项目中，我最恨的就是那种闭门造车造出来的自己都不用的东西（不是从已有业务生长出来的东西），以及那些自己不动手就在边上指指点点的各种咨询师或是喜欢动用行政命令的高层管理者。</p>
<p>但是，在这里，我更想说说我所理解的另一层“挠自己痒处”——有天我和一前前同事聊天，她说她在那家公司十多年了，现在老了，虽然心不老还想折腾，但是对自己的能力没自信，求稳了。我听到很多朋友想对自己有个改变，比如有QA的同学想做开发，有生活在内地的朋友想来大城市的大公司里有更爽的经历，<strong>这些人明明想活得更有激情，但最终在现实面前认命妥协。我说既然有痒处，还比较痒，那就应该毫不犹豫革自己的命，轰轰烈烈地活一次</strong>。别等老了后悔当年没有勇气。“挠自己痒处”就是挑战自己，革自己的命，既然想了，就做吧，生命只有一次，值得我们轰轰烈烈地去为之付出。</p>
<h3 id="-">“没时间”不是借口</h3>
<p>人们最常用的借口是：“时间不够。”他们宣称很想开一家公司，学一种乐器，写一本书，等等，但时间不够用。拜托，如果你善加利用，时间总是有的。</p>
<p>把看电视或玩魔兽的时间腾出来完成你的创意；把10点上订改成11点上床，这不是怂恿你通宵达旦或是一天干足16个小时——我们要说的是，第周匀出一些业余时间来，就足够你去做些事情了。</p>
<p>当你拥有某种强烈的渴望时，你就能挤出时间来——不管你身上是否背负着其他责任。<strong>事实上，真相是大多数的渴望并不是那么强烈。于是他们拿时间当借口来自我开脱。别给自己错口。</strong></p>
<p>另外，永远会有正当其时的时候，你总会觉得自己会么太年轻，要么太老，要么太忙，太穷，或是别的什么原因。<strong>如果你总是为遇到一个完美时机而发愁，那么，完美的时机绝对不会到来</strong>。
<strong>感想</strong>：我在“<a href="http://coolshell.cn/articles/7048.html" title="挑战无处不在 " target="_blank">挑战无处不在</a>”中也表达过这样的观点，<strong>关于热情和态度，说白了就是不要给自己找借口</strong>。比如：“工作忙事多没时间学所以可以不懂”，“工作中没用到所以可以不懂”，“工作没有挑战，一直没有遇到合适的项目”等等。而且，如果你只能在万事俱备的情况下才能做事，那么，你还有什么价值呢？人的价值和竞争力就是在条件并不完美的时候还能搞定事情。</p>
<h3 id="-">画沙为界，立场明确</h3>
<p>坚定的信念能为你赢得超级粉丝，他们会为你马首是瞻，会舍身保护你，他们充满激情的口碑传播将胜过这世间一切的广告。</p>
<p>强大的主见，也是要付出代价的，在这个过程中，会有人诋毁你，说像傲慢，冷漠。没办法，这就是人生，有人喜欢你，就有人憎恨你。如果你的说法没有引起任何人的心烦意乱，只能说明你的推广力度可能还不够。（也可能代表你比较无趣）</p>
<p><strong>对我们来说，我们的产品所不能处理的和我们的产品所能处理的一样令人感到骄傲</strong>。</p>
<p>我们的产品不适合每一个人，没有关系，我们愿意为了那些更加深爱我们的客户而放弃另一部分客户。这就是我们的立场。
<strong>感想</strong>：我从来不想做一个大众脸。酷壳上有很多比较有争议的文章，也有很多人说我很极端，偏执，有优越感，清高……，说什么的都有，无所谓。我有一个做新闻编辑的太太，主辑要求文章要客观和没有观点，不温不火，本来好好的一篇有观点的文章被编辑过后只剩下了一堆食之无味的文字。<strong>我喜欢有鲜明的观点，因为鲜明的观点和立场能不但能让文章鲜活起来，而且还能迎来更多的不同意见和更多的思考</strong>（而不只是“顶”“赞”之类无意义的回复）。我并不希望我的观点是正确的，我只希望能和更多的人加入我一同思考，而思考最佳的催化剂就是争论。我从这个行为中收益到了很多很多。</p>
<h3 id="-">找好退路无异于失败</h3>
<p>你还常常听到：“你的退出战略是什么？（万一不成功，你怎么办）”甚至在你刚开始启动时就听到它。这些人不知道怎么开始就要想到怎么结束？急什么呢？如果在全情投入之前就想怎么撤出，这种逻辑不是一般的混乱。</p>
<p>你正打算恋爱一场就计划着分手？你在第一次约会时就签订婚前协议？你会在婚礼早上先约见离婚律师？那也太荒谬了吧。</p>
<p><strong>你需要的是承诺战略而不是退出战略。你要考虑的是你的项目怎样发展和成功，而不是怎样撤退</strong>。如果整个战略是基于撤退的，一开始你就不会有机会成功。
<strong>感想</strong>：几年前，我有一个朋友被创新工场忽悠从美国退学回来创业，我非常质疑他退学创业这个事。他对我说，没事，反正就算失败我也不会失去什么。还有一个朋友一年前从美国回国创业，也对我说，就算没搞好也没什么。我都对他们说，如果你以为用试一试的态度就可以把一个事情搞成功，那么你让这世上那些Full Time全天候从事这个事情的并有一些积累的人情何以堪？如果你创业时都想好了失败，那就说你你对这个事没有必胜的信心，也说明连你自己都不相信这个事，你还干个什么劲啊？<strong>你与其把时间用在思考如果创业没成功你会怎么办上，你还如去思考一下如何做才有更大的胜算</strong>。</p>
<h3 id="-">条件受限是好事</h3>
<p>“我没有足够的时间、钱、人手、经验”。不要现无谓的抱怨了。“少”不是什么坏事。“条件受限”貌似缺陷，实力优势。有限的资源能激发你在现有的条件下完成任务的能力。没有一点浪费空间，一切都需要你发挥最大的创造力。</p>
<p>你见过囚犯用肥皂和汤勺制作武器吗？你们是“创新”的典范。只有在条件受到限制时，我们才会发挥出“小材大用”的能力。
<strong>感想</strong>：我相信这世上很多事情都是被条件受限逼过去的。我回想到我以前经常在干的性能调优，想尽一切办法榨干系统资源这件事上，我就无法不赞同这句话。想想淘宝的TFS，就是一个因为条件受限到了不得不自己干的时候，被逼出来的东西。如果你没有足够多的人，你才会去想要怎么去优化工作和开发效率，于是才会逼着你去开发一些自动化的工具，而这些工具恰恰解放了生产力可以让你更快地干更多的事。<strong>只有条件受限，才会从劳动密集型中激发出知识密集型的东西</strong>。再回到以前我的那篇“<a href="http://coolshell.cn/articles/6994.html" title="我们需要专职的QA吗？" target="_blank">是否需要专职的QA</a>”一文说的到东西，如果你有很多很多帮你做测试的QA，你就不会去测试，你的团队也就不会有自动化测试等工具。这就好像在中国这个劳动力又多又廉价的大国下，基本上不需要你在技术上的创新，你只需要去不断地迁就这些低端用户，迁就这些用户越多，你还能有什么重大创新吗？真正的创新是帮助用户成长，而不是迁就用户。</p>
<h3 id="-">与其做个半成品，不如做好半个产品</h3>
<p>同时做N件事的结果就是：一大把绝妙的点子最后被转化成一个蹩脚的产品。</p>
<p>有舍才有得，砍掉多余的野心，你就会发现慢慢做一件正事要胜过毛毛躁躁地做一堆傻事。</p>
<p>很多东西都是越简短越好。拿起斧子动手砍吧，为了一个“伟 大”的起点，让我们把那些“挺不错”地枝节给砍掉吧。
<strong>感想</strong>：这正如“<a href="http://coolshell.cn/articles/3605.html" title="为什么中国的网页设计那么烂？" target="_blank">为什么中国的网页设计这么烂</a>”中说的：“中国的学生只是去记忆东西而不是真正的理解。他们从来不花时间去思考，而只是贪婪地去获取更多的信息”。与其记忆那么多的东西，还不如好好理解部分的东西。还有一种说法是：“Done is better than Perfect!”，这句话某些时候说得也挺对的，尤其是对于那些完美地长期不能Done的项目。但是Done一个Ugly的东西还不如不做。所以平衡Done和Perfect的方式正好就是这句话——“与其做个半成品，不好做好半个产品”，因为，<strong>一个半成品会让人绝望，而半个好产品会让人有所期望，这就是其中的不同</strong>。</p>
<h3 id="-">关注不变因素</h3>
<p><strong>很多公司和人都关注即将到来的大事件。他们热衷于新鲜热辣的事物，追逐最新的潮流和技术</strong>。</p>
<p>这是一条愚笨之路。一旦走上这条路，你就会关注时髦、放弃本质，把注意力放到不断变化的事物上，而不是持久不变的事物上。</p>
<p>你的事业的核心应该建立在不变的基础之上。<strong>你应该投资于那些人们现在需要，并且十年后仍然需要的事物上</strong>。</p>
<p>要记住，时尚会凋零。只有当你聚焦于长久的功能时，你才会发现自己把握住了永不落伍的东西。
<strong>感想</strong>：一年多前，我在《<a href="http://coolshell.cn/articles/5815.html" target="_blank">来信、创业和移动互联网</a>》中谈到过那个时尚的“移动互联网”，说了四个方向：阅读，分享交流，电商，推荐/提醒。大家可以看到现在地铁上已经不像以前很多人都在看报纸了，而是很多人都在看手机。而手机端的社交（分享和交流），电子商务，以及很多推荐、提醒都越来越火了。这些东西都是都是“常量”——十年前存在，未来十年也会存在，我们看到很多人太过着眼于手机上的应用，而不是那些不变的因素。今天还有两个巨火无比的流行词，一个是云计算，一个是大数据，那些一听到这两个词就会兴奋的人，我不知道他们有没有真正理解这两词？他们真正理解了云计算其实就是那个N多年前就提过的IT服务，关于大数据，我完全不知道为什么会火，你会因为听到中国人口有13亿你就会兴奋吗？老鼠的数量比较这个更多呢，呵呵。其实，数据无所谓大小之分，只有好数据和烂数据之分，还热数据和冷数据之分。十年前有两个更为流行的词：一个是计算网格，一个是数据网格，这两个词5年前就凋零了，今天的云计算和大数据，有多少人意识到了其中有什么相通的，或是其中的不变因素是什么？<strong>大数据和云计算其实都在描述两个东西，一个是超大规模的计算能力，另一个则是服务。还有一个词是“平台化”，这可能被大家忽略了，通过平台进行计算和数据服务，这才是那计算机存在以来基本不变的东西，无论你是移动互联网，还是互联网，不管是云计算，还是大数据，都需要一个平台提供服务</strong>。</p>
<h3 id="-">会议有毒</h3>
<p>世人最可恨的打扰莫过于开会。原因是：</p>
<ul>
<li>会议中充斥着纸上谈兵和抽象的概念，大多是不切实际的。</li>
<li>会议中能传达的信息量少之又少。</li>
<li>人们在会议中容易跑题，堪比暴风雪里的芝加哥出租车还容易迷失方向。</li>
<li>会议要求做充分的准备，但是大多数人没有时间准备这些。</li>
<li>会议制定的议程常常是模糊的，根本就没有人真正清楚目标是什么。</li>
<li>会议中难免会轮到那么一两个低能人士发言，于是大家的时间都浪费在他们的扯淡上了。</li>
<li>会议具有自我繁殖功能。一次会议总能导致另外一次，以及再导出下一次，生生不息……
<strong>感想</strong>：这世上除了“他爹的TDD”开发模式，还有“他妈的TMD”开发，就是Team Meeting Driven，很多公司有太多太多的会要开了，开会基本上成了每天工作最主要的东西，对于一些管理者来说一星期中居然有80%时间都在开会。其实，这么多的会议并不意味着你在管理，只是意味着你对要管的东西完全不知道，需要通过开会来了解。很多会完全是没有议题的，大家坐在一起东拉西扯，非常非常地低效。我通常把这种会叫做“神仙会”，用个流行语来说，就是Cloud Meeting，大家神一要的各说各的，似乎，没有这种形式，不能证明参会者的存在，用会议来证明他们的存在，相当的可笑。对我来说，<strong>如果只是带一个或几个问题来开会，简直是就是扯谈，如果对于问题没有几个备选的解决方案和各方案的评估，完全没有必要开会</strong>。Amazon的会议是不会有PPT的，会议组织者会要要讨论的东西写好并打印出来，在会前给参会者把要讨论的东西打印出来，开会前10分钟左右，会场里没有任何声音，每个人都在读文档，全部人读完后，直接对议题发表自己的个人意见应该怎么干，然后很快形成共识，散会。</li>
</ul>
<h3 id="-">人人都得干活</h3>
<p>在一个小团队里，你需要的是干活的人，而不是监工。每个人都得做事，没有人可以袖手旁观 。</p>
<p>这意味着你在招聘中要避免招到监工型的人物，这些人喜欢对别人谆谆教导。对于小团队来讲监工型的人就是累赘。</p>
<p>监工们还喜欢把人拖去开会。实际上，会议是监工们最好的朋友，因为只有在开会时才显得出他们的重要。
<strong>感想</strong>：<strong>为什么会有办公室政治，那就是因为这个公司里有一部分人不干活，不做事，</strong>于是，他们就有大量地时间开始胡思乱想，他们花大量的时间不是想怎么去做事，而是想自己怎么更容易的打垮别人得到上面的认可，从而得到晋升。在大公司中这样的情况会比Startup的公司多得多。所以，如果你不想滋生办公室政治，那么你需要干两个事，第一个是最好不要变成大公司，第一个是让每个人都在实干。我最近看到其大公司，虽然很多东西不规范，而且很多东西在野蛮生长，有些事情也有点土，但绝大多数人都在实干，所以，只要每个人都在实干，就算干的方式不好，干出来的东西有问题，也比那些滋生办公室政治的公司强上几百倍</p>
<h3 id="-">拒绝照搬 &amp; 将你的产品去商品化</h3>
<p>有时候，照猫画虎也是一种学习过程，就好像艺术系的学生通过临摹美术馆的作品来学习绘画。当你还是一个学生时，这种模仿是一种很有效的学习工具。不幸的是，商业战场上的模仿却不招人待见。而这也意味着你打算通过当盲从者或抄袭者的方式来建立你的事业，这注定是一个失败模式。</p>
<p>模仿的问题在于，简单的复制扼杀了深层的理解——而理解才能激发成长。你不但要知其然，还要知其所以然。而当你复制时，你会忽视这一点。你照搬的只是表面，而不是本质。</p>
<p>一旦你扬名立万，模模仿者会蜂拥而至，这就是生活。但你可以用一种绝佳的方式来保护自己不被 他们吞没：让你自己成为你的产品或服务的一部分。
<strong>感想</strong>：在《<a href="http://coolshell.cn/articles/7617.html" title="抄袭，腾讯 和 产品" target="_blank">抄袭，腾讯 和 产品</a>》中我谈到过这个事情，虽然我对抄袭和山寨很反感，但是我不得不承认这是这个世界的一部分，好的东西总是会被人复制的，这也不一定是一个坏事，这会让你更清楚认识到什么是真正产品的价值，什么是核心竞争力，你但凡有一点急功近利的想法你都要想一想那堆抄袭者，其中还不乏有钱有人的专业抄袭的公司。而面对被抄袭这样的事情，最好的解决方法是着眼着远期而不是短期——<strong>如果你着眼短期，你无疑会面对众多的抄袭和模仿者让你万劫不复，但是，如果你着眼长期，做一个3-5年需要花费大量精力才会成熟的产品，那么，那些急功近利的抄袭者会知难而退的，因为长期并不符合抄袭者的价值观</strong>。</p>
<h3 id="-">做得比对手少</h3>
<p>传统智慧告诉我们，要想打败竞争者就要胜人一筹。如果人家有 4 个功能，你就得 5 个（或者 15 个，25 个）。如果人家花了$20,000，你就得花 $30,000。如果人家有 50 个员工，你就得要 100 个。</p>
<p>这样的冷战式的攀比思维会把人引上绝路。一旦被卷入“军备竞赛”，你就陷入了一场无止境的战争，这场战争会让你耗费大量的金钱、时间和动力。并且使你陷入长期的防御战中。处于防御状态的公司是没有预见力的；他们只能后知后觉，他们无法领跑，只能尾随。</p>
<p>那么你应该怎么做呢？比你的竞对手做得少，以此来打败他们。<strong>让自己去解决简单的问题，把那些纠结的、麻烦的、艰难的、讨厌的难题留给竞对手去解决</strong>。不要总想着去胜人一筹、去超过别人，试试相反的做法。</p>
<p>不要因为你的产品或服务不如别人的花哨就感到自惭形秽。把他们做得醒目高调，并引以为傲。就像对手那些强有力的销售他们多功能的产品一样销售你那简约的产品。
<strong>感想</strong>：一个最典型的例子就是iPad，它干得比Laptop少，比上网本少，就是一个很简单的上网和简单游戏的设备，但是他有非常简单的用户体验，让两三岁的儿童和六七十岁的老人都能很快上手。你相信吗？我花了好多年都没教会我父母用电脑以及手机里除了电话功能外的其它功能，但我只花了10分钟就教会他们使用iPad上网了。这就是“做得比对手少”的强大。<strong>只有简约的东西，才会显得更精致，才会显得更专业</strong>。</p>
<h3 id="-">谁在乎他们在干什么</h3>
<p>不管怎样，终究是不值得过于关注你的竞争者。为什么？因为<strong>关注别人太多会让自己受到困扰</strong>。他们现在在做什么？他们下一步呢？我们该怎样作出回应？</p>
<p>每一个小小的动作都会被分析一下。那是一种可怕的心态。这会产生不可抗拒的压力和焦虑。这样的想法会滋长不好的东西。</p>
<p>这是没有意义的事情。竞争者的风景时时在变。你的竞争对手明天一个样儿，今天一个样儿。完全在你控制之外。去担心你所不能控制的事情有意义吗？</p>
<p>过于关注竞争者会混淆你的视野。当你一直吸收别人思想时， 你的机会则会减少。你变得反动而不是充满想象力。你只不过是将你竞对手的产品换了个包装。</p>
<p>如果你打算做一个“the iPod killer”或“the next Pokemon”，你已经死了。你是在承认你的竞争者所设定的参数。你没有跳出 Apple 的套路。他们制定了这个游戏规则。你不可能打败制定规则的那个人。你必须重新制定一个规则，而不是稍微改建一点点。
<strong>感想</strong>：这个社会浮躁之处就在于我们太多的观注了别人，人比人气死人。我们很多人都注意到了别人的风光，看到别人创业被注资，看到别人找到了好的工作，看到了别人不走正道而发达，看到了别人很轻松还挣得多，甚至看到别人的粉丝比自己多，等等，等等，这些东西让自己的心态变，变得非常地不淡定了。眼红也是魔鬼，因为眼红让人心理扭曲了的例子还少吗？<strong>不要在乎别人干了什么，你应该多看看自己的长处是什么，每个人都有每个人的路，你要做的是按照自己的节奏和自己擅长的方式行事，而不是小猫钓鱼</strong>。</p>
<h3 id="-">养成对客户说“不”的习惯</h3>
<p>说“好的”很容易。我们很容易接受同意一个新功能、同意一个过于乐观的截止日期、笑纳一个平庸的设计。很快，一大堆你曾经说“yes”的事情就发生连锁反应，很多你不想要的东西越堆越高，甚至你都看不出原来想要的东西。</p>
<p>别相信“顾客永远是对的”这类的话。如果你是一个大厨，你的很多客人说你做的菜太咸或者太烫，你可以改。但是如果有一些挑剔的老主顾要求在宽面条里面加些香蕉，你千万不要理会他们，没关系。若是为了少数顾客的要求而毁了产品不值得。</p>
<p><strong>你的目标是确保你的产品与就是和你合拍的产品，你就是你自己产品最踏实的粉丝。你是最信赖它的那个人</strong>。那样的话，你会说：“我想你也会爱它的，因为我爱它。”
<strong>感想</strong>：亨利福特说过：“如果我要问我的客户要什么，他们会告诉我他们要一匹更快的马”，所以，过份的迁就用户并不是一件好的事，相反会是一件很不好的事。互联网和电视节目一样都有一个万恶的KPI，电子节目那万恶的KPI是收视率，而互联网的万恶KPI是流量。于是<strong>很多公司为了流量开始不择手段，就像电视节目用庸俗化来提高收视率一样，我们的一些互联网产品也使用庸俗化的东西来提高流量。我们要做的是一个让人称道的有品质的产品，而不是一个只有访问量的产品</strong>。</p>
<h3 id="-">不要攀客户的高枝</h3>
<p>也许你曾经见过这样的场景：一个顾客向一家公司投了很多钱。这家公司想要尽可能的取悦那个顾客。为了迎合这个客户的要求而改变自己的产品，渐渐地，你的产品就会脱离普遍客户的基础。</p>
<p>而且，突然有一天，这个大客户绝尘而去，公司则会背负一个包袱——这个产品是围绕着一个已经离开了的人设计的。而其他人没法用。</p>
<p>人在变，环境在变，你不可能满足所有人的所有要求。<strong>公司要对某一类型的客户全情投入，而不是对某个善变的客户唯唯诺诺</strong>。
<strong>感想</strong>：你永远要找到自己的定位，你不可能满足所有的人。就像屌丝们喜欢的北京的动物园批发市场和高富帅们喜欢的北京燕莎商场一样，他们分别订位于不同的用户。你的产品从生下来的那一时刻就应该需要做好定位，是面对什么样的人群。而且，你也不可能实现所有人的需求的。有时候，失去一些客户并不是坏事，<strong>我们要做的是管理我们的客户，让客户认同我们，而不是被客户牵着走</strong>。</p>
<h3 id="-">一夜成名只是传说</h3>
<p>你不会瞬间大红大紫，也不会一夜暴富，你所了解的那些道听途说的“一夜成名”的故事，深挖一点，你就能发现这些成功人士在到达引爆点之前，都已经在这个方向 上苦熬了很长时间。</p>
<p>把一夜成名的迷梦换成一步一个脚印的成长行动吧。道路很艰难，但你必须充满耐心。你得用功去做，在遇到伯乐前，你得努力很长时间。
<strong>感想</strong>：这和我在<a href="http://coolshell.cn/articles/8790.html" title="程序算法与人生选择" target="_blank">程序算法与人生选择</a>一文中所说的那个最短路径的算法的类比一样，与其展望要当什么架构师或是要成为牛人的憧憬，不如把身边看得见够得着的东西学扎实，干出色。一夜成名只是一个传说，你知道酷壳是因为我写十多年的博客，你知道我是因为我积累了十多年的编程，看看酷壳以前介绍过的<a href="http://coolshell.cn/articles/5651.html" target="_blank">王平同学</a>吧。<strong>很多事情都不是偶然的，都是有前兆的，还是我<a href="http://coolshell.cn/articles/7048.html" target="_blank">以前说过的那句话</a>，“如果一件事情以前没有发生过，未来也不会发生”，比如：如果你在学校里，在工作里，你的同学和同事并不经常来向你请教询问你的意见，那么你基本上很难成为一个Leader</strong>。</p>
<h3 id="-13-">员工不是13岁</h3>
<p><strong>当你把员工当孩子看时，人们就会像孩子一样行事</strong>。</p>
<p>当公司里事事都要上报审批时，你就创造出了一种无脑文化。你成功地制造出了老板和员工之间的对立关系。这种关系在咆哮着：“我不相信你！”</p>
<p>当你处处限制员工，比如禁上他们在上班时访问外部网站或是开小差，你会得到什么好处？什么也得不到。人们需要开小差，这有助于打破整日的枯燥单调，花点时间上上Youtube或Facebook不会失去什么。</p>
<p>如果你要监控你的员工，你得想想你要花多少时间和金钱来监管员工。你浪费了多少钱去安装监控软件？你浪费了多少人力资源去监视员工？你浪费了多少时间去写没有人会看的规章制度？<strong>看看这些成本，你很快就发现，对员工的不信任才是最大的开销</strong>。
<strong>感想</strong>：我始终在跟我的团队成员说，最有效的管理就是自己管理自己，而不是还要专们的人来管你。不然的话，你一定会很难受的。如果你能管理好你的工作和任务，我们就不需要项目经理。如果你能管理得好你的做事的方法和流程，就不需要那些搞流程的。如果你能管理得好你的程序质量，我们就不需要QA来监管你…… 等等。<strong>其实，你们如果能管理得好自己，并能自我进化。你们甚至不需要一个经理。但是，你们可能会需要一个为你们跑腿打杂的人，其实，那个人就是经理</strong>。</p>
<p>（全文完）</p>
<p><strong>（转载本站文章请注明作者和出处 <a href="http://coolshell.cn/" target="_blank">酷壳 – CoolShell.cn</a> ，请勿用于任何商业用途）</strong></p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/好文摘录/">好文摘录</a></li></span></span> | <span class="time">recent updated:<time title="2014-03-07 11:32:03"datetime="2014-03-07 11:32:03"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/03/2014-02-03--《Rework》摘录及感想/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-03--《Rework》摘录及感想" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/03/2014-02-03--数据的游戏：冰与火/">数据的游戏：冰与火</a></h1>
      
        <span>Posted on<time datetime="2014-02-03T03:24:29.000Z"> <a href="/2014/02/03/2014-02-03--数据的游戏：冰与火/">feb. 3 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-">数据的游戏：冰与火</h1>
<p>2013年7月31日 <a href="http://coolshell.cn/articles/author/haoel" title="由 陈皓 发布" target="_blank">陈皓</a></p>
<p><img src="" alt="">我对数据挖掘和机器学习是新手，从去年7月份在Amazon才开始接触，而且还是因为工作需要被动接触的，以前都没有接触过，做的是需求预测机器学习相关的。后来，到了淘宝后，自己凭兴趣主动地做了几个月的和用户地址相关数据挖掘上的工作，有一些浅薄的心得。下面这篇文章主要是我做为一个新人仅从事数据方面技术不到10个月的一些心得，也许对你有用，也许很傻，不管怎么样，欢迎指教和讨论。</p>
<p>另外，注明一下，这篇文章的标题模仿了一个美剧《<a href="http://movie.douban.com/subject/3016187/" target="_blank">权力的游戏：冰与火之歌</a>》。在数据的世界里，我们看到了很多很牛，很强大也很有趣的案例。但是，<strong>数据就像一个王座一样，像征着一种权力和征服，但登上去的路途一样令人胆颤</strong>。</p>
<h3 id="-">数据挖掘中的三种角色</h3>
<p>在Amazon里从事机器学习的工作时，我注意到了Amazon玩数据的三种角色。</p>
<ul>
<li><p><strong>Data Analyzer：数据分析员</strong>。这类人的人主要是分析数据的，从数据中找到一些规则，并且为了数据模型的找不同场景的Training Data。另外，这些人也是把一些脏数据洗干净的的人。</p>
</li>
<li><p><strong>Research Scientist：研究科学家</strong>。这种角色主要是根据不同的需求来建立数据模型的。他们把自己戏称为不近人间烟火的奇异性物种，就像《生活大爆炸》里的 那个Sheldon一样。这些人基本上玩的是数据上的科学</p>
</li>
<li><p><strong>Software Developer ：软件开发工程师</strong>。主要是把 Scientist 建立的数据模型给实现出来，交给Data Analyzer去玩。这些人通常更懂的各种机器学习的算法。</p>
</li>
</ul>
<p>我相信其它公司的做数据挖掘或是机器学习的也就这三种工作，或者说这三种人，对于我来说，</p>
<ul>
<li><p><strong>最有技术含量的是 Scientist</strong>，因为数据建模和抽取最有意义的向量，以及选取不同的方法都是这类人来决定的。这类人，我觉得在国内是找不到的。</p>
</li>
<li><p><strong>最苦逼，也最累，但也最重要的是Data Analyzer</strong>，他们的活也是这三个角色中最最最重要的（注意：我用了三个最）。因为，无论你的模型你的算法再怎么牛，在一堆烂数据上也只能干出一堆垃圾的活来。正所谓：Garbage In, Garbage Out ！但是这个活是最脏最累的活，也是让人最容易退缩的活。</p>
</li>
<li><p><strong>最没技术含量的是Software Developer</strong>。现在国内很多玩数据的都以为算法最重要，并且，很多技术人员都在研究机器学习的算法。错了，最重要的是上面两个人，一个是苦逼地洗数据的Data Analyzer，另一个是真正懂得数据建模的Scientist！而像什么<a href="http://coolshell.cn/articles/7779.html" title="K-Means 算法" target="_blank">K-Means</a>，<a href="http://coolshell.cn/articles/8052.html" title="K Nearest Neighbor 算法" target="_blank">K Nearest Neighbor</a>，或是别的什么贝叶斯、回归、决策树、随机森林等这些玩法，都很成熟了，而且又不是人工智能，说白了，这些算法在机器学习和数据挖掘中，就像Quick Sort之类的算法在软件设计中基本没什么技术含量。</p>
</li>
</ul>
<h3 id="-">数据的质量</h3>
<p><strong>目前所流行的Buzz Word——大数据是相当误导人的。在我眼中，数据不分大小，只分好坏。</strong></p>
<p>在处理数据的过程中，我第一个感受最大的就是数据质量。下面我分几个案例来说明：</p>
<h3 id="-">案例一：数据的标准</h3>
<p>在Amazon里，所有的商品都有一个唯一的ID，叫ASIN——Amazon Single Identify Number，这个ID是用来标识商品的唯一性的（来自于条形码）。也就是说，无论是你把商品描述成什么样，只要ASIN一样，这就是完完全全一模一样的商品。</p>
<p>这样，就不像淘宝一样，当你搜索一个iPhone，你会出现一堆各种各样的iPhone，有的叫“超值iPhone”，有的叫“苹果iPhone”，有的叫“智能手机iPhone”，有的叫“iPhone 白色/黑色”……，这些同一个商品不同的描述是商家为了吸引用户。但是带来的问题有两点：</p>
<p>1）<strong>用户体验不好</strong>。以商品为中心的业务模型，对于消费者来说，体验明显好于以商家为中心的业务模型。</p>
<p>2）<strong>只要你不能正确读懂（识别）数据，你后面的什么算法，什么模型统统没用</strong>。</p>
<p>所以，只要你玩数据，你就会发现，<strong>如果数据的标准没有建立起来，干什么都没用。数据标准是数据质量的第一道关卡</strong>，没这个玩意，你就什么也别玩了。所谓数据的标准，为数据做唯一标识只是其中最最基础的一步，数据的标准还单单只是这个，<strong>更重要的是把数据的标准抽象成数学向量，没有数学向量，后面也无法挖掘</strong>。</p>
<p>所以，你会看到，<strong>洗数据的大量的工作就是在把杂乱无章的数据归并聚合，这就是在建立数据标准。这里面绝对少不了人肉的工作</strong>。无非就是：</p>
<ul>
<li><p>聪明的人在数据产生之前就定义好标准，并在数据产生之时就在干数据清洗的工作。</p>
</li>
<li><p>一般的人是在数据产生并大量堆积之后，才来干这个事。</p>
</li>
</ul>
<p>另外，说一下Amazon的ASIN，这个事从十多年前就开始了，我在Amazon的内网里看到的资料并没有说为什么搞了个这样一个ID，我倒觉得这并不是因为Amazon因为玩数据发现必需建议个商品ID，也许因为Amazon的业务模型就是设计成以“商品为中心”的。今天，这个ASIN依然有很多很多的问题，ASIN一样不能完全保证商品就是一样的，ASIN不一样也不代表商品不一样，不过90%以上的商品是保证的。Amazon有专门的团队Category Team，里面有很多业务人员天天都在拼命地在对ASIN的数据进行更正。</p>
<h3 id="-">案例二：数据的准确</h3>
<p>用户地址是我从事过数据分析的另一个事情。我还记得当时看到那数以亿计的用户地址的数据的那种兴奋。但是随后我就兴奋不起来了。因为地址是用户自己填写的，这里面有很多的坑，都不是很容易做的。</p>
<p>第一个是假/错地址，因为有的商家作弊或是用户做测试。所以地址是错的，</p>
<ul>
<li><p>比如，直接就输入“该地址不存在”，“13243234asdfasdi”之类的。这类的地址是可以被我的程序识别出来的。</p>
</li>
<li><p>还有很能被我的程序所识别出来的。比如：“宇宙路地球小区”之类的。但这类地址可以被人识别出来。</p>
</li>
<li><p>还有连人都识别不出来的，比如：“北京市东四环中路23号南航大厦5楼540室”，这个地址根本不存在。</p>
</li>
</ul>
<p>第二个是真地址，但是因为用户写的不标准，所以很难处理，比如：</p>
<ul>
<li><p>缩写：“建国门外大街” 和 “建外大街”，“中国工商银行”和“工行”……</p>
</li>
<li><p>错别字：“潮阳门”，“通慧河”……</p>
</li>
<li><p>颠倒：“东四环中路朝阳公园” 和 “朝阳公园 （靠东四环）” ……</p>
</li>
<li><p>别名：有的人写的是开发商的小区名“东恒国际”，有的则是写行政的地名“八里庄东里”……</p>
</li>
</ul>
<p>这样的例子多得不能再多了。可见数据如果不准确，会增加你处理的难度。有个比喻非常好，<strong>玩数据的就像是在挖金矿一样，如果含金量高，那么，挖掘的难度就小，也就容易出效果，如果含金量低，那么挖掘的难度就大，效果就差</strong>。</p>
<p>上面，我给了两个案例，旨在说明——</p>
<p><strong>1）数据没有大小之分，只有含金量大的数据和垃圾量大的数据之分</strong>。</p>
<p><strong>2）数据清洗是一件多么重要的工作，这也是一件人肉工作量很大的工作。</strong></p>
<p><em>**</em>所以，这个工作最好是在数据产生的时候就一点一滴的完成。</p>
<p>有一个观点：<strong>如果数据准确度在60%的时候，你干出来的事，一定会被用户骂！如果数据准确度在80%左右，那么用户会说，还不错！只有数据准确度到了90%的时候，用户才会觉得真牛B。但是从数据准确度从80%到90%要付出的成本要比60% 到 80%的付出大得多得多</strong>。大多数据的数据挖掘团队都会止步于70%这个地方。因为，再往后，这就是一件相当累的活。</p>
<h3 id="-">数据的业务场景</h3>
<p>我不知道有多少数据挖掘团队真正意识到了业务场景和数据挖掘的重要关系？<strong>我们需要知道，根本不可能做出能够满足所有业务的数据挖掘和分析模型</strong>。</p>
<p>推荐音乐视频，和电子商务中的推荐商品的场景完全不一样。电商中，只要你买了一个东西没有退货，那么，有很大的概率我可以相信你是喜欢这个东西的，然后，对于音乐和视频，你完全不能通过用户听了这首歌或是看了这个视频就武断地觉得用户是喜欢这首歌和这个视频的，所以，我们可以看到，推荐算法在不同的业务场景下的实现难度也完全不一样。</p>
<p>说到推荐算法，你是不是和我一样，有时候会对推荐有一种感觉——<strong>推荐就是一种按不同维度的排序的算法</strong>。我个人以为，就提一下推荐这个东西在某些业务场景下是比较Tricky的，比如，推荐有两种（不是按用户关系和按物品关系这两种），</p>
<ul>
<li><p>一种是共性化推荐，结果就是推荐了流行的东西，这也许是好 的，但这也许会是用户已知的东西，比如，到了北京，我想找个饭馆，你总是给我推荐烤鸭，我想去个地方，你总是给我推荐天安门故宫天坛（因为大多数人来北京就是吃烤鸭，就是去天安门的），这些我不都知道了嘛，还要你来推荐？另外，共性化的东西通常是可以被水军刷的。</p>
</li>
<li><p>另一种是一种是个性化推荐，这个需要分析用户的个体喜好，好的就是总是给我我喜欢的，不好的就是也许我的口味会随我的年龄和环境所改变，而且，总是推荐符合用户口味的，不能帮用户发掘新鲜点。比如，我喜欢吃辣的，你总是给我推荐川菜和湘菜，时间长了我也会觉得烦的。</p>
</li>
</ul>
<p><strong>推荐有时并不是民主投票，而是专业用户或资深玩家的建议；推荐有时并不是推荐流行的，而是推荐新鲜而我不知道的</strong>。你可以看到，不同的业务场景，不同的产品形态下的玩法可能完全不一样，</p>
<p>另外，就算是对于同一个电子商务来说，书、手机 和服装的业务形态完全不一样。我之前在Amazon做Demand Forecasting（用户需求预测）——通过历史数据来预测用户未来的需求。</p>
<ul>
<li><p>对于书、手机、家电这些东西，在Amazon里叫Hard Line的产品，你可以认为是“标品”（但也不一定），预测是比较准的，甚至可以预测到相关的产品属性的需求。</p>
</li>
<li><p>但是地于服装这样的叫Soft Line的产品，Amazon干了十多年都没有办法预测得很好，因为这类东西受到的干扰因素太多了，比如：用户的对颜色款式的喜好，穿上去合不合身，爱人朋友喜不喜欢…… 这类的东西太容易变了，买得人多了反而会卖不好，所以根本没法预测好，更别Stock/Vender Manager 提出来的“预测某品牌的某种颜色的衣服或鞋子”。</p>
</li>
</ul>
<p>对于需求的预测，我发现，长期在这个行业中打拼的人的预测是最准的，什么机器学习都是浮云。机器学习只有在你要面对的是成千上万种不同商品和品类的时候才会有意义。</p>
<p><strong>数据挖掘不是人工智能，而且差得还太远。不要觉得数据挖掘什么事都能干，找到一个合适的业务场景和产品形态，比什么都重要</strong>。</p>
<h3 id="-">数据的分析结果</h3>
<p>我看到很多的玩大数据的，基本上干的是数据统计的事，从多个不同的维度来统计数据的表现。最简单最常见的统计就是像网站统计这样的事。比如：PV是多少，UV是多少，来路是哪里，浏览器、操作系统、地理、搜索引擎的分布，等等，等等。</p>
<p>唠叨一句，千万不要以为，你一天有十几个T的日志就是数据了，也不要以为你会用Hadoop/MapReduce分析一下日志，这就是数据挖掘了，说得难听一点，你在做的只不过是一个统计的工作。那几个T的Raw Data，基本上来说没什么意义，只能叫日志，连数据都算不上，只有你统计出来的这些数据才是有点意义的，才能叫数据。</p>
<p>当一个用户在面对着自己网店的数据的时候，比如：每千人有5个人下单，有65%的访客是男的，18-24岁的人群有30%，等等。甚至你给出了，你打败了40%同类型商家的这样的数据。作为一个商户，面对这些数据时，大多数人的表现是完全不知道自己能干什么？是把网站改得更男性一点，还是让年轻人更喜欢一点？完全不知道所措。</p>
<p>只要你去看一看，你会发现，好些好些的数据分析出来的结果，看上去似乎不错，但是其实完全不知道下一步该干什么？</p>
<p>所以，我觉得，<strong>数据分析的结果并不仅仅只是把数据呈现出来，而更应该关注的是通过这些数据后面可以干什么？如果看了数据分析的结果后并不知道可以干什么，那么这个数据分析是失败的。</strong></p>
<h3 id="-">总结</h3>
<p>综上所述，下面是我觉得数据挖掘或机器学习最重要的东西：</p>
<p>1）<strong>数据的质量</strong>。分为数据的标准和数据的准确。数据中的杂音要尽量地排除掉。为了数据的质量，大量人肉的工作少不了。</p>
<p>2）<strong>数据的业务场景</strong>。我们不可能做所有场景下的来，所以，业务场景和产品形态很重要，我个人感觉业务场景越窄越好。</p>
<p>3）<strong>数据的分析结果</strong>，要让人能看得懂，知道接下来要干什么，而不是为了数据而数据。</p>
<p>搞数据挖掘的人很多，但成功的案例却不多（相比起大量的尝试来说），就目前而言，<strong>我似乎觉得目前的数据挖掘的技术是一种过渡技术，还在摸索阶段。另外，好些数据挖掘的团队搞得业务不业务，技术不技术的，为其中的技术人员感到惋惜</strong>……</p>
<p>不好意思，我只给出了问题，没有建议，这也说明数据分析中有很多的机会……</p>
<p>最后，还要提的一个是“<strong>数据中的个人隐私问题</strong>”，这似乎就像那些有悖伦理的黑魔法一样，你要成功就得把自己变得黑暗。是的，<strong>数据就像一个王座一样，像征着一种权力和征服，但登上去的路途一样令人胆颤</strong>。</p>
<p>（全文完）
<strong>（转载本站文章请注明作者和出处 <a href="http://coolshell.cn/" target="_blank">酷壳 – CoolShell.cn</a> ，请勿用于任何商业用途）</strong></p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/好文摘录/">好文摘录</a></li></span></span> | <span class="time">recent updated:<time title="2014-03-07 11:33:41"datetime="2014-03-07 11:33:41"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/03/2014-02-03--数据的游戏：冰与火/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-03--数据的游戏：冰与火" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/03/2014-02-03--{技术}{多线程}实施并行编程的五大障碍/">{技术}{多线程}实施并行编程的五大障碍</a></h1>
      
        <span>Posted on<time datetime="2014-02-03T03:24:29.000Z"> <a href="/2014/02/03/2014-02-03--{技术}{多线程}实施并行编程的五大障碍/">feb. 3 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-">{技术}{多线程}实施并行编程的五大障碍</h1>
<p>要使用 Google·网上论坛讨论区，请在您的浏览器设置中启用 JavaScript，然后刷新该网页。   <plaintext/><xmp>.</p>
<ol>
<li><a href="https://plus.google.com/?gpsrc=ogpy0&amp;tab=gX" target="_blank">+你</a></li>
<li><a href="http://www.google.com/webhp?hl=zh-CN&amp;tab=gw" target="_blank">搜索</a></li>
<li><a href="http://www.google.com/imghp?hl=zh-CN&amp;tab=gi" target="_blank">图片</a></li>
<li><a href="https://maps.google.com/maps?hl=zh-CN&amp;tab=gl" target="_blank">地图</a></li>
<li><a href="https://play.google.com/?hl=zh-CN&amp;tab=g8" target="_blank">Play</a></li>
<li><a href="https://www.youtube.com/?tab=g1" target="_blank">YouTube</a></li>
<li><a href="https://news.google.com/nwshp?hl=zh-CN&amp;tab=gn" target="_blank">新闻</a></li>
<li><a href="https://mail.google.com/mail/?tab=gm" target="_blank">Gmail</a></li>
<li><a href="https://drive.google.com/?tab=go" target="_blank">云端硬盘</a></li>
<li><a href="https://www.google.com/calendar?tab=gc" target="_blank">日历</a></li>
<li><p><a href="http://www.google.com/intl/zh-CN/options/" target="_blank">更多</a></p>
</li>
<li><p><a href="https://translate.google.com/?hl=zh-CN&amp;tab=gT" target="_blank">翻译</a></p>
</li>
<li><a href="http://www.google.com/mobile/?hl=zh-CN&amp;tab=gD" target="_blank">移动</a></li>
<li><a href="http://books.google.com/bkshp?hl=zh-CN&amp;tab=gp" target="_blank">图书</a></li>
<li><a href="https://wallet.google.com/manage/?tab=ga" target="_blank">电子钱包</a></li>
<li><a href="https://www.blogger.com/?tab=gj" target="_blank">Blogger</a></li>
<li><a href="https://www.google.com/finance?tab=ge" target="_blank">财经</a></li>
<li><a href="https://plus.google.com/photos?tab=gq" target="_blank">相册</a></li>
<li><a href="http://video.google.com/?hl=zh-CN&amp;tab=gv" target="_blank">视频</a>
1.</li>
<li><a href="http://www.google.com/intl/zh-CN/options/" target="_blank">更多</a></li>
</ol>
<p><a href="https://groups.google.com/d/overview" title="Google 网上论坛"></a></p>
<p>隐藏字段搜索论坛或帖子</p>
<p><img src="" alt=""></p>
<h2 id="account-options">Account Options</h2>
<p>1.</p>
<ol>
<li><a href="https://www.google.com/a/UniversalLogin?continue=https%3A%2F%2Fgroups.google.com%2Fd%2Ftopic%2Fpongba%2FBPGNU3OJZos&amp;hl=zh-CN&amp;service=groups2&amp;hd=default" target="_blank">登录</a><h2 id="-"><a href="">网上论坛</a></h2>
</li>
</ol>
<p><img src="" alt=""><img src="" alt="">第  个，共  个（ 个未读）</p>
<p><img src="" alt="">
<img src="" alt=""></p>
<p><img src="" alt=""></p>
<p><img src="" alt=""></p>
<p><a href="">首页</a></p>
<p>导入预定义搜索，将它们添加到您保存的搜索结果中。</p>
<p>点击论坛的星标即可收藏它
[0</p>
<h3 id="-">最近看过的论坛</h3>
<p>]()</p>
<p><a href=""></a></p>
<p><a href="">0  TopLanguage</a></p>
<p>[0</p>
<h3 id="-">最近的搜索</h3>
<p>]()</p>
<p><a href=""></a>
[0</p>
<h3 id="-">最近发过帖的论坛</h3>
<p>]()</p>
<p><a href=""></a></p>
<p>请<a href="https://www.google.com/a/UniversalLogin?continue=https%3A%2F%2Fgroups.google.com%2Fd%2Ftopic%2Fpongba%2FBPGNU3OJZos&amp;hl=zh-CN&amp;service=groups2&amp;hd=default" target="_blank">登录</a>或开始浏览，以整理您的论坛并查看最近的项目。</p>
<p>©2013 Google
<a href="http://www.google.com/intl/zh-CN/policies/privacy/" target="_blank">隐私权政策</a>  -  <a href="http://www.google.com/intl/zh-CN/policies/terms/" target="_blank">服务条款</a>  -  <a href="http://www.google.com/" target="_blank">Google 首页</a></p>
<p><a href=""></a> <a href=""></a> <a href="">TopLanguage</a> › 由于长期没有活动，本主题已不再开放新回复。如果您要发帖，请在上方搜索更新的主题或发布新问题。 {技术}{多线程}实施并行编程的五大障碍</p>
<p>此主题和其他讨论重复。   <a href=""></a>
系统将您从重复的主题重定向到这里。   <a href=""></a></p>
<p>24 名作者发布了 95 个帖子</p>
<p><img src="" alt="">
上一页 <a href="">上一页</a>  </p>
<p>第 <strong>1</strong> 页
  下一页 <a href="">下一页</a></p>
<p><img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问“什么是实施并行编程的最大障
碍”时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看
<a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/" target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/</a></a>
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是“专家”们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了“编译指导”、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说“在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶……你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的”，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：“你觉得并行编程容易么？”，十有八九会说“我觉得很难”。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点“教育”有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。
<a href="">显示删减掉的内容</a></p>
</li>
</ol>
<p><img src="" alt=""> 机械唯物主义 : linjunhalida <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>恩恩，有些事情还是没有并行的必要。等光处理器出来就好了。
2010/3/22 Guancheng Chen <a href="&#x6d;&#97;&#x69;&#108;&#x74;&#x6f;&#58;&#91;&#x63;&#104;&#101;&#110;&#x67;&#x75;&#46;&#46;&#46;&#x40;&#103;&#109;&#97;&#105;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#40;&#41;">&#91;&#x63;&#104;&#101;&#110;&#x67;&#x75;&#46;&#46;&#46;&#x40;&#103;&#109;&#97;&#105;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#40;&#41;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问“什么是实施并行编程的最大障
碍”时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。
( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看
<a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/" target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/</a></a>
)</p>
<ol>
<li>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</li>
<li>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是“专家”们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了“编译指导”、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。
可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说“在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶……你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的”，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：“你觉得并行编程容易么？”，十有八九会说“我觉得很难”。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</li>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？
(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx
总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点“教育”有很大关系了。</li>
<li>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</li>
<li>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> 陨落雕 <img src="" alt=""></li>
</ol>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>呃，我想的障碍是: 1. 类C语言的统治地位; 2. 内存带宽不够; 3. 误导性宣传;</p>
<p>On Mar 21, 7:37 pm, Guancheng Chen <a href="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#x6f;&#58;&#91;&#99;&#x68;&#x65;&#110;&#x67;&#x75;&#97;&#x6e;&#x63;&#x68;&#46;&#46;&#x2e;&#64;&#x67;&#109;&#97;&#x69;&#x6c;&#x2e;&#99;&#111;&#x6d;&#x5d;&#x28;&#x29;">&#91;&#99;&#x68;&#x65;&#110;&#x67;&#x75;&#97;&#x6e;&#x63;&#x68;&#46;&#46;&#x2e;&#64;&#x67;&#109;&#97;&#x69;&#x6c;&#x2e;&#99;&#111;&#x6d;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看<a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..</p>
<p>)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。</p>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<blockquote>
<p>尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。
<a href="">显示删减掉的内容</a></p>
</li>
</ol>
</blockquote>
<p><img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>可是按现在的趋势，多核一定会在光处理器之前成为主流啊</p>
<p>On 3月22日, 上午12时42分, 机械唯物主义 : linjunhalida <a href="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#x6f;&#x3a;&#91;&#x6c;&#x69;&#x6e;&#106;&#117;&#x6e;&#x68;&#x61;&#x6c;&#x2e;&#x2e;&#46;&#64;&#103;&#x6d;&#97;&#x69;&#108;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#x28;&#x29;">&#91;&#x6c;&#x69;&#x6e;&#106;&#117;&#x6e;&#x68;&#x61;&#x6c;&#x2e;&#x2e;&#46;&#64;&#103;&#x6d;&#97;&#x69;&#108;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#x28;&#x29;</a>
wrote:</p>
<blockquote>
<p>恩恩，有些事情还是没有并行的必要。等光处理器出来就好了。</p>
<p>2010/3/22 Guancheng Chen <a href="&#x6d;&#x61;&#105;&#108;&#x74;&#x6f;&#58;&#91;&#x63;&#x68;&#x65;&#110;&#103;&#x75;&#x61;&#x6e;&#99;&#104;&#46;&#x2e;&#46;&#64;&#x67;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#40;&#x29;">&#91;&#x63;&#x68;&#x65;&#110;&#103;&#x75;&#x61;&#x6e;&#99;&#104;&#46;&#x2e;&#46;&#64;&#x67;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#40;&#x29;</a></p>
</blockquote>
<p>&gt;
&gt;
&gt;</p>
<blockquote>
<blockquote>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问“什么是实施并行编程的最大障
碍”时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..</p>
</blockquote>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<blockquote>
<blockquote>
<p>)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是“专家”们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了“编译指导”、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说“在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶……你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的”，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：“你觉得并行编程容易么？”，十有八九会说“我觉得很难”。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点“教育”有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。</p>
</li>
</ol>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
</blockquote>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<ol>
<li>C语言可以使用pthread等库实现并行化，C++ JAVA等已经会即将支持多线程 所以语言能实现并行化 只是难易问题</li>
<li>是指Shared memory模型，多核共享一条内存总线所以造成带宽问题么？这确实是个问题，不过我感觉硬件商家会负责为你带来越来越多的带
宽，而程序员的任务只是合理的利用好这些给定的带宽</li>
<li>能具体说说哪些误导宣传么？</li>
</ol>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>On 3月22日, 上午1时46分, 陨落雕 <a href="&#x6d;&#97;&#105;&#x6c;&#x74;&#x6f;&#58;&#x5b;&#x67;&#x65;&#111;&#x2e;&#x2e;&#46;&#46;&#64;&#x67;&#109;&#x61;&#x69;&#x6c;&#46;&#x63;&#111;&#109;&#x5d;&#x28;&#x29;">&#x5b;&#x67;&#x65;&#111;&#x2e;&#x2e;&#46;&#46;&#64;&#x67;&#109;&#x61;&#x69;&#x6c;&#46;&#x63;&#111;&#109;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>呃，我想的障碍是: 1. 类C语言的统治地位; 2. 内存带宽不够; 3. 误导性宣传;</p>
<p>On Mar 21, 7:37 pm, Guancheng Chen <a href="&#x6d;&#97;&#105;&#108;&#116;&#111;&#58;&#x5b;&#99;&#104;&#101;&#x6e;&#x67;&#117;&#97;&#x6e;&#99;&#104;&#46;&#46;&#46;&#64;&#x67;&#x6d;&#x61;&#x69;&#108;&#46;&#x63;&#111;&#109;&#x5d;&#40;&#41;">&#x5b;&#99;&#104;&#101;&#x6e;&#x67;&#117;&#97;&#x6e;&#99;&#104;&#46;&#46;&#46;&#64;&#x67;&#x6d;&#x61;&#x69;&#108;&#46;&#x63;&#111;&#109;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看<a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。
<a href="">显示删减掉的内容</a></p>
</li>
</ol>
</blockquote>
</blockquote>
<p><img src="" alt=""> Jeffrey Zhao <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是“抽象”这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上……我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog: <a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter: <a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p><strong>From:</strong> <a href="&quot;chenguancheng@gmail.com&quot;">Guancheng Chen</a></p>
<p><strong>Sent:</strong> Monday, March 22, 2010 7:37 AM
<strong>To:</strong> <a href="&quot;pongba@googlegroups.com&quot;">TopLanguage</a></p>
<p><strong>Subject:</strong> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问“什么是实施并行编程的最大障
碍”时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。
( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看
<a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/" target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/</a></a>
)</p>
<ol>
<li>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</li>
<li>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是“专家”们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了“编译指导”、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。
可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说“在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶……你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的”，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：“你觉得并行编程容易么？”，十有八九会说“我觉得很难”。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</li>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？
(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx
总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点“教育”有很大关系了。</li>
<li>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</li>
<li>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> tinyfool <img src="" alt=""></li>
</ol>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？
还有支持显卡计算的OpenCL也是无比强大啊。
2010/3/22 Jeffrey Zhao <a href="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#111;&#x3a;&#x5b;&#106;&#x65;&#46;&#46;&#46;&#x40;&#108;&#105;&#x76;&#x65;&#46;&#x63;&#111;&#109;&#93;&#x28;&#41;">&#x5b;&#106;&#x65;&#46;&#46;&#46;&#x40;&#108;&#105;&#x76;&#x65;&#46;&#x63;&#111;&#109;&#93;&#x28;&#41;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是“抽象”这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上……我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog: <a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter: <a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p><strong>From:</strong> <a href="&quot;chenguancheng@gmail.com&quot;">Guancheng Chen</a></p>
<p><strong>Sent:</strong> Monday, March 22, 2010 7:37 AM
<strong>To:</strong> <a href="&quot;pongba@googlegroups.com&quot;">TopLanguage</a></p>
<p><strong>Subject:</strong> [TL] {技术}{多线程}实施并行编程的五大障碍
近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问“什么是实施并行编程的最大障
碍”时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。
( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看
<a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/" target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/</a></a>
)</p>
<ol>
<li>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</li>
<li>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是“专家”们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了“编译指导”、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。
可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说“在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶……你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的”，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：“你觉得并行编程容易么？”，十有八九会说“我觉得很难”。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</li>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？
(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx
总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点“教育”有很大关系了。</li>
<li>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</li>
<li>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</li>
</ol>
<h2 id="to-unsubscribe-from-this-group-send-email-to-pongba-unsubscribegooglegroups-com-http-unsubscribegooglegroups-com-or-reply-to-this-email-with-the-words-remove-me-as-the-subject-">To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</h2>
<p>Tinyfool的开发日记 <a href="http://www.tinydust.net/dev/" target="_blank"><a href="http://www.tinydust.net/dev/">http://www.tinydust.net/dev/</a></a>
代码中国网 <a href="http://www.codechina.org/" target="_blank"><a href="http://www.codechina.org">http://www.codechina.org</a></a>
myTwitter: <a href="http://twitter.com/tinyfool" target="_blank"><a href="http://twitter.com/tinyfool">http://twitter.com/tinyfool</a></a>
<a href="">显示删减掉的内容</a></p>
<p><img src="" alt=""> 陨落雕 <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<ol>
<li>这和第二个问题是连起来的，到最后，你还是操作的mutable object，就是无穷无尽的memory consistency的麻烦；</li>
<li>就是这个问题，可惜从来都没跟上来过，光传输是一个可行性，如果实现了的确会改变现在的处境；</li>
<li>说在shared memory模型上内核数量可以无限上去的误导宣传，可惜这个20年前就失败，现在在TOP500上能看到的
supercomputer都是distributed memory model；</li>
</ol>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>On Mar 21, 8:58 pm, Guancheng Chen <a href="&#109;&#97;&#x69;&#x6c;&#x74;&#x6f;&#x3a;&#91;&#99;&#104;&#x65;&#x6e;&#x67;&#x75;&#x61;&#x6e;&#x63;&#x68;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#x61;&#x69;&#108;&#46;&#99;&#111;&#109;&#93;&#x28;&#x29;">&#91;&#99;&#104;&#x65;&#x6e;&#x67;&#x75;&#x61;&#x6e;&#x63;&#x68;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#x61;&#x69;&#108;&#46;&#99;&#111;&#109;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<ol>
<li>C语言可以使用pthread等库实现并行化，C++ JAVA等已经会即将支持多线程 所以语言能实现并行化 只是难易问题</li>
<li>是指Shared memory模型，多核共享一条内存总线所以造成带宽问题么？这确实是个问题，不过我感觉硬件商家会负责为你带来越来越多的带
宽，而程序员的任务只是合理的利用好这些给定的带宽</li>
<li>能具体说说哪些误导宣传么？</li>
</ol>
<p>On 3月22日, 上午1时46分, 陨落雕 <a href="&#x6d;&#97;&#x69;&#108;&#116;&#111;&#x3a;&#91;&#103;&#x65;&#111;&#46;&#46;&#46;&#46;&#x40;&#x67;&#x6d;&#x61;&#x69;&#108;&#46;&#99;&#x6f;&#109;&#93;&#40;&#x29;">&#91;&#103;&#x65;&#111;&#46;&#46;&#46;&#46;&#x40;&#x67;&#x6d;&#x61;&#x69;&#108;&#46;&#99;&#x6f;&#109;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>呃，我想的障碍是: 1. 类C语言的统治地位; 2. 内存带宽不够; 3. 误导性宣传;</p>
<p>On Mar 21, 7:37 pm, Guancheng Chen <a href="&#109;&#x61;&#x69;&#108;&#x74;&#111;&#x3a;&#x5b;&#x63;&#x68;&#101;&#110;&#103;&#117;&#97;&#110;&#x63;&#104;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#109;&#97;&#105;&#x6c;&#x2e;&#99;&#111;&#x6d;&#x5d;&#x28;&#x29;">&#x5b;&#x63;&#x68;&#101;&#110;&#103;&#117;&#97;&#110;&#x63;&#104;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#109;&#97;&#105;&#x6c;&#x2e;&#99;&#111;&#x6d;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看<a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。
<a href="">显示删减掉的内容</a>
<img src="" alt=""> 陨落雕 <img src="" alt=""></p>
</li>
</ol>
</blockquote>
</blockquote>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>OpenCL解决了一大类的问题（每个kernel只需要一小部分数据，类似rasterization的渲染），而且现在他们有动力解决另一大类的问
题（每个小的kernel需要查询大量数据，类似ray tracer的渲染）。但是现在移植还是好困难啊，特别是显存和内存通信时候的
consolation，头疼死了，显存不够要swap out的时候，也很头疼。</p>
<p>On Mar 21, 9:20 pm, Tinyfool <a href="&#109;&#97;&#x69;&#108;&#x74;&#x6f;&#58;&#x5b;&#116;&#x69;&#110;&#x79;&#x66;&#46;&#x2e;&#x2e;&#x40;&#x67;&#109;&#97;&#x69;&#108;&#46;&#99;&#x6f;&#109;&#x5d;&#40;&#41;">&#x5b;&#116;&#x69;&#110;&#x79;&#x66;&#46;&#x2e;&#x2e;&#x40;&#x67;&#109;&#97;&#x69;&#108;&#46;&#99;&#x6f;&#109;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#x6d;&#97;&#x69;&#108;&#116;&#x6f;&#x3a;&#91;&#106;&#x65;&#x2e;&#46;&#x2e;&#64;&#108;&#x69;&#118;&#x65;&#x2e;&#99;&#111;&#109;&#93;&#40;&#x29;">&#91;&#106;&#x65;&#x2e;&#46;&#x2e;&#64;&#108;&#x69;&#118;&#x65;&#x2e;&#99;&#111;&#109;&#93;&#40;&#x29;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
</blockquote>
</blockquote>
<p>&gt;</p>
<blockquote>
<blockquote>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#x6d;&#x61;&#105;&#x6c;&#x74;&#x6f;&#x3a;&#x5b;&#99;&#104;&#101;&#110;&#x67;&#117;&#x61;&#x6e;&#x63;&#104;&#x2e;&#46;&#x2e;&#64;&#x67;&#x6d;&#97;&#x69;&#108;&#x2e;&#99;&#111;&#109;&#93;&#40;&#x29;">&#x5b;&#99;&#104;&#101;&#110;&#x67;&#117;&#x61;&#x6e;&#x63;&#104;&#x2e;&#46;&#x2e;&#64;&#x67;&#x6d;&#97;&#x69;&#108;&#x2e;&#99;&#111;&#109;&#93;&#40;&#x29;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#109;&#97;&#105;&#108;&#116;&#x6f;&#x3a;&#x5b;&#x70;&#x6f;&#x6e;&#x2e;&#46;&#x2e;&#64;&#103;&#111;&#x6f;&#x67;&#108;&#101;&#103;&#114;&#x6f;&#x75;&#x70;&#115;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#41;">&#x5b;&#x70;&#x6f;&#x6e;&#x2e;&#46;&#x2e;&#64;&#103;&#111;&#x6f;&#x67;&#108;&#101;&#103;&#114;&#x6f;&#x75;&#x70;&#115;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#41;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
</blockquote>
</blockquote>
<p>&gt;</p>
<blockquote>
<blockquote>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..</p>
<p>)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。</p>
</blockquote>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<blockquote>
<blockquote>
<p>尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。</p>
</li>
</ol>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>--
Tinyfool的开发日记<a href="http://www.tinydust.net/dev/" target="_blank"><a href="http://www.tinydust.net/dev/">http://www.tinydust.net/dev/</a></a>
代码中国网<a href="http://www.codechina.org/" target="_blank"><a href="http://www.codechina.org">http://www.codechina.org</a></a>
myTwitter:<a href="http://twitter.com/tinyfool" target="_blank"><a href="http://twitter.com/tinyfool">http://twitter.com/tinyfool</a></a>
<a href="">显示删减掉的内容</a></p>
</blockquote>
<p><img src="" alt=""> Jeffrey Zhao <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>哈哈，广告好，扩展视野，那我继续做广告了……</p>
<p>微软其实很早就在搞Microsoft Accelerator项目，旨在利用DirectX进行计算，.NET项目。 <a href="http://research.microsoft.com/en-us/projects/Accelerator/" title="http://research.microsoft.com/en-us/projects/Accelerator/
CTRL + 单击以下链接"><a href="http://research.microsoft.com/en-us/projects/Accelerator/" target="_blank">http://research.microsoft.com/en-us/projects/Accelerator/</a></a></p>
<p>然后F/#这边由于语言的支持良好，可以设计出丰富的表达式、DSL等Modeling Language，再由框架进行自动并行，解决问题可以很容易（已经2.0了）。</p>
<p>这篇文章是个简单介绍：<a href="http://strangelights.com/blog/archive/2008/09/21/1628.aspx" target="_blank"><a href="http://strangelights.com/blog/archive/2008/09/21/1628.aspx">http://strangelights.com/blog/archive/2008/09/21/1628.aspx</a></a></p>
<p>Microsoft Solver Foundation <a href="http://code.msdn.microsoft.com/solverfoundation" target="_blank"><a href="http://code.msdn.microsoft.com/solverfoundation">http://code.msdn.microsoft.com/solverfoundation</a></a></p>
<p>F/# Optimization Modeling Language Utilizing Microsoft Solver Foundation <a href="http://code.msdn.microsoft.com/solverfoundationfs1" title="http://code.msdn.microsoft.com/solverfoundationfs1
CTRL + 单击以下链接"><a href="http://code.msdn.microsoft.com/solverfoundationfs1" target="_blank">http://code.msdn.microsoft.com/solverfoundationfs1</a></a></p>
<p>现在就等OpenCL如果有标准出来，肯定立马可以跟上个类库，哦耶。</p>
<p>Jeffrey Zhao
Blog: <a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter: <a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a>
<strong>From:</strong> <a href="&quot;tinyfool@gmail.com&quot;">Tinyfool</a></p>
<p><strong>Sent:</strong> Monday, March 22, 2010 9:20 AM
<strong>To:</strong> <a href="&quot;pongba@googlegroups.com&quot;">pon...@googlegroups.com</a></p>
<p><strong>Subject:</strong> Re: [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？
还有支持显卡计算的OpenCL也是无比强大啊。
2010/3/22 Jeffrey Zhao <a href="&#x6d;&#x61;&#105;&#108;&#116;&#111;&#x3a;&#x5b;&#106;&#101;&#46;&#x2e;&#46;&#x40;&#108;&#x69;&#x76;&#x65;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#40;&#41;">&#x5b;&#106;&#101;&#46;&#x2e;&#46;&#x40;&#108;&#x69;&#x76;&#x65;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#40;&#41;</a>
我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是“抽象”这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上……我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog: <a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter: <a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p><strong>From:</strong> <a href="&quot;chenguancheng@gmail.com&quot;">Guancheng Chen</a></p>
<p><strong>Sent:</strong> Monday, March 22, 2010 7:37 AM
<strong>To:</strong> <a href="&quot;pongba@googlegroups.com&quot;">TopLanguage</a></p>
<p><strong>Subject:</strong> [TL] {技术}{多线程}实施并行编程的五大障碍
近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问“什么是实施并行编程的最大障
碍”时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。
( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看
<a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/" target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/</a></a>
)</p>
<ol>
<li>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</li>
<li>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是“专家”们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了“编译指导”、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。
可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说“在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶……你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的”，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：“你觉得并行编程容易么？”，十有八九会说“我觉得很难”。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</li>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？
(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx
总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点“教育”有很大关系了。</li>
<li>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</li>
<li>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</li>
</ol>
<h2 id="to-unsubscribe-from-this-group-send-email-to-pongba-unsubscribegooglegroups-com-http-unsubscribegooglegroups-com-or-reply-to-this-email-with-the-words-remove-me-as-the-subject-">To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</h2>
<p>Tinyfool的开发日记 <a href="http://www.tinydust.net/dev/" target="_blank"><a href="http://www.tinydust.net/dev/">http://www.tinydust.net/dev/</a></a>
代码中国网 <a href="http://www.codechina.org/" target="_blank"><a href="http://www.codechina.org">http://www.codechina.org</a></a>
myTwitter: <a href="http://twitter.com/tinyfool" target="_blank"><a href="http://twitter.com/tinyfool">http://twitter.com/tinyfool</a></a></p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> tinyfool <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>OpenCL早就出来标准了，而且在做各个平台的实现…</p>
<p>视野啊…
2010/3/22 Jeffrey Zhao <a href="&#x6d;&#97;&#x69;&#x6c;&#x74;&#111;&#58;&#x5b;&#106;&#101;&#x2e;&#46;&#46;&#64;&#108;&#x69;&#118;&#x65;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#x28;&#41;">&#x5b;&#106;&#101;&#x2e;&#46;&#46;&#64;&#108;&#x69;&#118;&#x65;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#x28;&#41;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>哈哈，广告好，扩展视野，那我继续做广告了……</p>
<p>微软其实很早就在搞Microsoft Accelerator项目，旨在利用DirectX进行计算，.NET项目。 <a href="http://research.microsoft.com/en-us/projects/Accelerator/" title="http://research.microsoft.com/en-us/projects/Accelerator/
CTRL + 单击以下链接"><a href="http://research.microsoft.com/en-us/projects/Accelerator/" target="_blank">http://research.microsoft.com/en-us/projects/Accelerator/</a></a></p>
<p>然后F/#这边由于语言的支持良好，可以设计出丰富的表达式、DSL等Modeling Language，再由框架进行自动并行，解决问题可以很容易（已经2.0了）。</p>
<p>这篇文章是个简单介绍：<a href="http://strangelights.com/blog/archive/2008/09/21/1628.aspx" target="_blank"><a href="http://strangelights.com/blog/archive/2008/09/21/1628.aspx">http://strangelights.com/blog/archive/2008/09/21/1628.aspx</a></a></p>
<p>Microsoft Solver Foundation <a href="http://code.msdn.microsoft.com/solverfoundation" target="_blank"><a href="http://code.msdn.microsoft.com/solverfoundation">http://code.msdn.microsoft.com/solverfoundation</a></a></p>
<p>F/# Optimization Modeling Language Utilizing Microsoft Solver Foundation <a href="http://code.msdn.microsoft.com/solverfoundationfs1" title="http://code.msdn.microsoft.com/solverfoundationfs1
CTRL + 单击以下链接"><a href="http://code.msdn.microsoft.com/solverfoundationfs1" target="_blank">http://code.msdn.microsoft.com/solverfoundationfs1</a></a></p>
<p>现在就等OpenCL如果有标准出来，肯定立马可以跟上个类库，哦耶。</p>
<p>Jeffrey Zhao
Blog: <a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter: <a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a>
<strong>From:</strong> <a href="&quot;tinyfool@gmail.com&quot;">Tinyfool</a></p>
<p><strong>Sent:</strong> Monday, March 22, 2010 9:20 AM
<strong>To:</strong> <a href="&quot;pongba@googlegroups.com&quot;">pon...@googlegroups.com</a></p>
<p><strong>Subject:</strong> Re: [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？
还有支持显卡计算的OpenCL也是无比强大啊。
2010/3/22 Jeffrey Zhao <a href="&#x6d;&#x61;&#105;&#108;&#116;&#111;&#58;&#x5b;&#x6a;&#x65;&#x2e;&#x2e;&#x2e;&#64;&#x6c;&#x69;&#118;&#101;&#x2e;&#x63;&#x6f;&#109;&#93;&#x28;&#x29;">&#x5b;&#x6a;&#x65;&#x2e;&#x2e;&#x2e;&#64;&#x6c;&#x69;&#118;&#101;&#x2e;&#x63;&#x6f;&#109;&#93;&#x28;&#x29;</a>
我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是“抽象”这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上……我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog: <a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter: <a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p><strong>From:</strong> <a href="&quot;chenguancheng@gmail.com&quot;">Guancheng Chen</a></p>
<p><strong>Sent:</strong> Monday, March 22, 2010 7:37 AM
<strong>To:</strong> <a href="&quot;pongba@googlegroups.com&quot;">TopLanguage</a></p>
<p><strong>Subject:</strong> [TL] {技术}{多线程}实施并行编程的五大障碍
近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问“什么是实施并行编程的最大障
碍”时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。
( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看
<a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/" target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/</a></a>
)</p>
<ol>
<li>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</li>
<li>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是“专家”们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了“编译指导”、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。
可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说“在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶……你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的”，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：“你觉得并行编程容易么？”，十有八九会说“我觉得很难”。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</li>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？
(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx
总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点“教育”有很大关系了。</li>
<li>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</li>
<li>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</li>
</ol>
<h2 id="to-unsubscribe-from-this-group-send-email-to-pongba-unsubscribegooglegroups-com-http-unsubscribegooglegroups-com-or-reply-to-this-email-with-the-words-remove-me-as-the-subject-">To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</h2>
<p>Tinyfool的开发日记 <a href="http://www.tinydust.net/dev/" target="_blank"><a href="http://www.tinydust.net/dev/">http://www.tinydust.net/dev/</a></a>
代码中国网 <a href="http://www.codechina.org/" target="_blank"><a href="http://www.codechina.org">http://www.codechina.org</a></a>
myTwitter: <a href="http://twitter.com/tinyfool" target="_blank"><a href="http://twitter.com/tinyfool">http://twitter.com/tinyfool</a></a></p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>--
Tinyfool的开发日记 <a href="http://www.tinydust.net/dev/" target="_blank"><a href="http://www.tinydust.net/dev/">http://www.tinydust.net/dev/</a></a>
代码中国网 <a href="http://www.codechina.org/" target="_blank"><a href="http://www.codechina.org">http://www.codechina.org</a></a>
myTwitter: <a href="http://twitter.com/tinyfool" target="_blank"><a href="http://twitter.com/tinyfool">http://twitter.com/tinyfool</a></a>
<a href="">显示删减掉的内容</a></p>
<p><img src="" alt=""> woo <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>C的pthread太重量级了，我觉得golang的go要好很多，虽然只是试验阶段</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>On 17:58 Sun 21 Mar     , Guancheng Chen wrote:</p>
<blockquote>
<ol>
<li>C语言可以使用pthread等库实现并行化，C++ JAVA等已经会即将支持多线程 所以语言能实现并行化 只是难易问题</li>
<li>是指Shared memory模型，多核共享一条内存总线所以造成带宽问题么？这确实是个问题，不过我感觉硬件商家会负责为你带来越来越多的带
宽，而程序员的任务只是合理的利用好这些给定的带宽</li>
<li>能具体说说哪些误导宣传么？</li>
</ol>
<p>On 3月22日, 上午1时46分, 陨落雕 <a href="&#109;&#x61;&#x69;&#108;&#x74;&#111;&#x3a;&#91;&#103;&#101;&#x6f;&#46;&#46;&#46;&#x2e;&#x40;&#x67;&#109;&#x61;&#x69;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#93;&#40;&#41;">&#91;&#103;&#101;&#x6f;&#46;&#46;&#46;&#x2e;&#x40;&#x67;&#109;&#x61;&#x69;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>呃，我想的障碍是: 1. 类C语言的统治地位; 2. 内存带宽不够; 3. 误导性宣传;</p>
<p>On Mar 21, 7:37 pm, Guancheng Chen <a href="&#109;&#x61;&#105;&#108;&#116;&#x6f;&#58;&#x5b;&#99;&#104;&#101;&#x6e;&#103;&#x75;&#97;&#x6e;&#99;&#104;&#x2e;&#46;&#46;&#x40;&#x67;&#109;&#x61;&#105;&#x6c;&#46;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#x29;">&#x5b;&#99;&#104;&#101;&#x6e;&#103;&#x75;&#97;&#x6e;&#99;&#104;&#x2e;&#46;&#46;&#x40;&#x67;&#109;&#x61;&#105;&#x6c;&#46;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看<a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。</p>
</li>
</ol>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> 陨落雕 <img src="" alt=""></p>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>言多必失啊，coalescing是写显存时候的问题，单词也拼错了......</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>On Mar 21, 9:33 pm, 陨落雕 <a href="&#x6d;&#97;&#105;&#x6c;&#116;&#111;&#x3a;&#x5b;&#x67;&#101;&#111;&#46;&#x2e;&#x2e;&#x2e;&#64;&#103;&#109;&#97;&#105;&#x6c;&#x2e;&#99;&#111;&#109;&#x5d;&#x28;&#x29;">&#x5b;&#x67;&#101;&#111;&#46;&#x2e;&#x2e;&#x2e;&#64;&#103;&#109;&#97;&#105;&#x6c;&#x2e;&#99;&#111;&#109;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>OpenCL解决了一大类的问题（每个kernel只需要一小部分数据，类似rasterization的渲染），而且现在他们有动力解决另一大类的问
题（每个小的kernel需要查询大量数据，类似ray tracer的渲染）。但是现在移植还是好困难啊，特别是显存和内存通信时候的
consolation，头疼死了，显存不够要swap out的时候，也很头疼。</p>
<p>On Mar 21, 9:20 pm, Tinyfool <a href="&#x6d;&#x61;&#105;&#x6c;&#x74;&#x6f;&#58;&#x5b;&#x74;&#x69;&#x6e;&#121;&#x66;&#x2e;&#x2e;&#x2e;&#64;&#103;&#109;&#x61;&#105;&#108;&#x2e;&#99;&#111;&#109;&#93;&#x28;&#x29;">&#x5b;&#x74;&#x69;&#x6e;&#121;&#x66;&#x2e;&#x2e;&#x2e;&#64;&#103;&#109;&#x61;&#105;&#108;&#x2e;&#99;&#111;&#109;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#x6d;&#97;&#x69;&#x6c;&#116;&#x6f;&#x3a;&#91;&#x6a;&#101;&#x2e;&#x2e;&#46;&#64;&#x6c;&#x69;&#118;&#101;&#x2e;&#x63;&#111;&#109;&#x5d;&#x28;&#x29;">&#91;&#x6a;&#101;&#x2e;&#x2e;&#46;&#64;&#x6c;&#x69;&#118;&#101;&#x2e;&#x63;&#111;&#109;&#x5d;&#x28;&#x29;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#x6d;&#97;&#105;&#x6c;&#116;&#111;&#x3a;&#91;&#99;&#104;&#101;&#x6e;&#x67;&#117;&#97;&#110;&#x63;&#104;&#46;&#x2e;&#46;&#x40;&#x67;&#x6d;&#97;&#105;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#x29;">&#91;&#99;&#104;&#101;&#x6e;&#x67;&#117;&#97;&#110;&#x63;&#104;&#46;&#x2e;&#46;&#x40;&#x67;&#x6d;&#97;&#105;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#x29;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#x6d;&#97;&#x69;&#x6c;&#116;&#111;&#58;&#x5b;&#x70;&#111;&#110;&#46;&#46;&#46;&#64;&#x67;&#111;&#x6f;&#x67;&#x6c;&#101;&#103;&#114;&#x6f;&#x75;&#x70;&#115;&#46;&#99;&#111;&#109;&#x5d;&#40;&#x29;">&#x5b;&#x70;&#111;&#110;&#46;&#46;&#46;&#64;&#x67;&#111;&#x6f;&#x67;&#x6c;&#101;&#103;&#114;&#x6f;&#x75;&#x70;&#115;&#46;&#99;&#111;&#109;&#x5d;&#40;&#x29;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。</p>
</li>
</ol>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>--
Tinyfool的开发日记<a href="http://www.tinydust.net/dev/" target="_blank"><a href="http://www.tinydust.net/dev/">http://www.tinydust.net/dev/</a></a></p>
</blockquote>
<p>...</p>
<p>read more &gt;&gt;
<a href="">显示删减掉的内容</a></p>
</blockquote>
<p><img src="" alt=""> Jeffrey Zhao <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>是嘛，我记得是提交了标准还在审核。</p>
<p>好吧，我去查了一下果然在08年12月1.0 Stable release了。</p>
<p>Jeffrey Zhao
Blog: <a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter: <a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a>
<strong>From:</strong> <a href="&quot;tinyfool@gmail.com&quot;">Tinyfool</a></p>
<p><strong>Sent:</strong> Monday, March 22, 2010 9:46 AM</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p><strong>To:</strong> <a href="&quot;pongba@googlegroups.com&quot;">pon...@googlegroups.com</a></p>
<p><strong>Subject:</strong> Re: [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>OpenCL早就出来标准了，而且在做各个平台的实现…</p>
<p>视野啊…
2010/3/22 Jeffrey Zhao <a href="&#x6d;&#97;&#x69;&#108;&#x74;&#111;&#x3a;&#91;&#x6a;&#101;&#46;&#46;&#46;&#64;&#x6c;&#x69;&#x76;&#101;&#46;&#99;&#111;&#x6d;&#93;&#x28;&#x29;">&#91;&#x6a;&#101;&#46;&#46;&#46;&#64;&#x6c;&#x69;&#x76;&#101;&#46;&#99;&#111;&#x6d;&#93;&#x28;&#x29;</a>
哈哈，广告好，扩展视野，那我继续做广告了……</p>
<p>微软其实很早就在搞Microsoft Accelerator项目，旨在利用DirectX进行计算，.NET项目。 <a href="http://research.microsoft.com/en-us/projects/Accelerator/" title="http://research.microsoft.com/en-us/projects/Accelerator/
CTRL + 单击以下链接"><a href="http://research.microsoft.com/en-us/projects/Accelerator/" target="_blank">http://research.microsoft.com/en-us/projects/Accelerator/</a></a></p>
<p>然后F/#这边由于语言的支持良好，可以设计出丰富的表达式、DSL等Modeling Language，再由框架进行自动并行，解决问题可以很容易（已经2.0了）。</p>
<p>这篇文章是个简单介绍：<a href="http://strangelights.com/blog/archive/2008/09/21/1628.aspx" title="http://strangelights.com/blog/archive/2008/09/21/1628.aspx
CTRL + 单击以下链接"><a href="http://strangelights.com/blog/archive/2008/09/21/1628.aspx" target="_blank">http://strangelights.com/blog/archive/2008/09/21/1628.aspx</a></a></p>
<p>Microsoft Solver Foundation <a href="http://code.msdn.microsoft.com/solverfoundation" title="http://code.msdn.microsoft.com/solverfoundation
CTRL + 单击以下链接"><a href="http://code.msdn.microsoft.com/solverfoundation" target="_blank">http://code.msdn.microsoft.com/solverfoundation</a></a></p>
<p>F/# Optimization Modeling Language Utilizing Microsoft Solver Foundation <a href="http://code.msdn.microsoft.com/solverfoundationfs1" title="http://code.msdn.microsoft.com/solverfoundationfs1
CTRL + 单击以下链接"><a href="http://code.msdn.microsoft.com/solverfoundationfs1" target="_blank">http://code.msdn.microsoft.com/solverfoundationfs1</a></a></p>
<p>现在就等OpenCL如果有标准出来，肯定立马可以跟上个类库，哦耶。</p>
<p>Jeffrey Zhao
Blog: <a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter: <a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a>
<strong>From:</strong> <a href="&quot;tinyfool@gmail.com&quot;">Tinyfool</a></p>
<p><strong>Sent:</strong> Monday, March 22, 2010 9:20 AM
<strong>To:</strong> <a href="&quot;pongba@googlegroups.com&quot;">pon...@googlegroups.com</a></p>
<p><strong>Subject:</strong> Re: [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？
还有支持显卡计算的OpenCL也是无比强大啊。
2010/3/22 Jeffrey Zhao <a href="&#109;&#97;&#x69;&#x6c;&#116;&#x6f;&#58;&#91;&#x6a;&#x65;&#46;&#46;&#46;&#x40;&#108;&#x69;&#x76;&#x65;&#46;&#99;&#111;&#x6d;&#x5d;&#40;&#41;">&#91;&#x6a;&#x65;&#46;&#46;&#46;&#x40;&#108;&#x69;&#x76;&#x65;&#46;&#99;&#111;&#x6d;&#x5d;&#40;&#41;</a>
我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是“抽象”这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上……我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog: <a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter: <a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p><strong>From:</strong> <a href="&quot;chenguancheng@gmail.com&quot;">Guancheng Chen</a></p>
<p><strong>Sent:</strong> Monday, March 22, 2010 7:37 AM
<strong>To:</strong> <a href="&quot;pongba@googlegroups.com&quot;">TopLanguage</a></p>
<p><strong>Subject:</strong> [TL] {技术}{多线程}实施并行编程的五大障碍
近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问“什么是实施并行编程的最大障
碍”时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。
( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看
<a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/" target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/</a></a>
)</p>
<ol>
<li>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</li>
<li>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是“专家”们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了“编译指导”、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。
可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说“在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶……你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的”，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：“你觉得并行编程容易么？”，十有八九会说“我觉得很难”。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</li>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？
(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx
总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点“教育”有很大关系了。</li>
<li>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</li>
<li>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</li>
</ol>
<h2 id="to-unsubscribe-from-this-group-send-email-to-pongba-unsubscribegooglegroups-com-http-unsubscribegooglegroups-com-or-reply-to-this-email-with-the-words-remove-me-as-the-subject-">To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</h2>
<p>Tinyfool的开发日记 <a href="http://www.tinydust.net/dev/" target="_blank"><a href="http://www.tinydust.net/dev/">http://www.tinydust.net/dev/</a></a>
代码中国网 <a href="http://www.codechina.org/" target="_blank"><a href="http://www.codechina.org">http://www.codechina.org</a></a>
myTwitter: <a href="http://twitter.com/tinyfool" target="_blank"><a href="http://twitter.com/tinyfool">http://twitter.com/tinyfool</a></a></p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<h2 id="to-unsubscribe-from-this-group-send-email-to-pongba-unsubscribegooglegroups-com-http-unsubscribegooglegroups-com-or-reply-to-this-email-with-the-words-remove-me-as-the-subject-">To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</h2>
<p>Tinyfool的开发日记 <a href="http://www.tinydust.net/dev/" target="_blank"><a href="http://www.tinydust.net/dev/">http://www.tinydust.net/dev/</a></a>
代码中国网 <a href="http://www.codechina.org/" target="_blank"><a href="http://www.codechina.org">http://www.codechina.org</a></a>
myTwitter: <a href="http://twitter.com/tinyfool" target="_blank"><a href="http://twitter.com/tinyfool">http://twitter.com/tinyfool</a></a></p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> changsheng <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>个人觉得最大障碍在工具上.</p>
<p>并行学术上研究得不少, 主要在算法和模型上. 工程上的工具, 多是自串行程序来设计的, 弄得复杂不堪. 并行需要语言和库两级支持, Pthreads 和 MPI 仅从库上入手, 让程序员处理各种重复且复杂的分发, 并发锁等. OpenMP好一些, 可惜目前只支持线程并行.
用 ErLang 等将并行设计在语言里的来做并行会容易得多, 得易于面向消息传递的隔离模型, 程序稳定易写. 模型和语言的性能是一个问题, 主要的问题还在用的人和实际并行项目不多.</p>
<p>调试工具就更少了. 有少数商业化的工具.
当然, 我是将可维护性归结为语言工具太差.</p>
<pre><code>                                                 Changsheng Jiang
</code></pre><p>2010/3/22 Guancheng Chen <a href="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#x6f;&#58;&#91;&#x63;&#104;&#101;&#x6e;&#103;&#x75;&#x2e;&#x2e;&#46;&#x40;&#x67;&#x6d;&#97;&#105;&#108;&#46;&#99;&#x6f;&#x6d;&#x5d;&#40;&#x29;">&#91;&#x63;&#104;&#101;&#x6e;&#103;&#x75;&#x2e;&#x2e;&#46;&#x40;&#x67;&#x6d;&#97;&#105;&#108;&#46;&#99;&#x6f;&#x6d;&#x5d;&#40;&#x29;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问“什么是实施并行编程的最大障
碍”时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。
( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看
<a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/" target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/</a></a>
)</p>
<ol>
<li>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</li>
<li>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是“专家”们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了“编译指导”、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。
可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说“在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶……你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的”，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：“你觉得并行编程容易么？”，十有八九会说“我觉得很难”。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</li>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？
(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx
总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点“教育”有很大关系了。</li>
<li>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</li>
<li>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。</li>
</ol>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a></p>
<p><img src="" alt=""> Milo Yip <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>我在等NVidia的Fermi和Nexus，想試做全域照明。
但怕買了Fermi後，機器也只是用來做做翻譯……</p>
<p>在 2010年3月22日上午9:51，Jeffrey Zhao <a href="&#x6d;&#x61;&#x69;&#108;&#116;&#111;&#x3a;&#x5b;&#x6a;&#x65;&#x2e;&#x2e;&#46;&#64;&#x6c;&#x69;&#x76;&#x65;&#46;&#x63;&#111;&#x6d;&#93;&#x28;&#x29;">&#x5b;&#x6a;&#x65;&#x2e;&#x2e;&#46;&#64;&#x6c;&#x69;&#x76;&#x65;&#46;&#x63;&#111;&#x6d;&#93;&#x28;&#x29;</a> 寫道：</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<blockquote>
<p>是嘛，我记得是提交了标准还在审核。</p>
<p>好吧，我去查了一下果然在08年12月1.0 Stable release了。</p>
<p>Jeffrey Zhao
Blog: <a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter: <a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a>
From: Tinyfool
Sent: Monday, March 22, 2010 9:46 AM
To: <a href="">pon...@googlegroups.com</a>
Subject: Re: [TL] {技术}{多线程}实施并行编程的五大障碍
OpenCL早就出来标准了，而且在做各个平台的实现…
视野啊…</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#109;&#x61;&#105;&#x6c;&#x74;&#111;&#x3a;&#91;&#106;&#x65;&#x2e;&#x2e;&#x2e;&#x40;&#x6c;&#105;&#118;&#x65;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#41;">&#91;&#106;&#x65;&#x2e;&#x2e;&#x2e;&#x40;&#x6c;&#105;&#118;&#x65;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#41;</a>
&gt;</p>
<blockquote>
<p>哈哈，广告好，扩展视野，那我继续做广告了……</p>
<p>微软其实很早就在搞Microsoft Accelerator项目，旨在利用DirectX进行计算，.NET项目。
<a href="http://research.microsoft.com/en-us/projects/Accelerator/" target="_blank"><a href="http://research.microsoft.com/en-us/projects/Accelerator/">http://research.microsoft.com/en-us/projects/Accelerator/</a></a></p>
<p>然后F/#这边由于语言的支持良好，可以设计出丰富的表达式、DSL等Modeling
Language，再由框架进行自动并行，解决问题可以很容易（已经2.0了）。</p>
<p>这篇文章是个简单介绍：<a href="http://strangelights.com/blog/archive/2008/09/21/1628.aspx" target="_blank"><a href="http://strangelights.com/blog/archive/2008/09/21/1628.aspx">http://strangelights.com/blog/archive/2008/09/21/1628.aspx</a></a></p>
<p>Microsoft Solver Foundation
<a href="http://code.msdn.microsoft.com/solverfoundation" target="_blank"><a href="http://code.msdn.microsoft.com/solverfoundation">http://code.msdn.microsoft.com/solverfoundation</a></a></p>
<p>F/# Optimization Modeling Language Utilizing Microsoft Solver Foundation
<a href="http://code.msdn.microsoft.com/solverfoundationfs1" target="_blank"><a href="http://code.msdn.microsoft.com/solverfoundationfs1">http://code.msdn.microsoft.com/solverfoundationfs1</a></a></p>
<p>现在就等OpenCL如果有标准出来，肯定立马可以跟上个类库，哦耶。</p>
<p>Jeffrey Zhao
Blog: <a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter: <a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a>
From: Tinyfool
Sent: Monday, March 22, 2010 9:20 AM
To: <a href="">pon...@googlegroups.com</a>
Subject: Re: [TL] {技术}{多线程}实施并行编程的五大障碍
唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下
Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？
还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#109;&#x61;&#x69;&#108;&#116;&#111;&#x3a;&#91;&#106;&#101;&#46;&#46;&#x2e;&#x40;&#108;&#105;&#118;&#x65;&#46;&#x63;&#x6f;&#109;&#93;&#x28;&#41;">&#91;&#106;&#101;&#46;&#46;&#x2e;&#x40;&#108;&#105;&#118;&#x65;&#46;&#x63;&#x6f;&#109;&#93;&#x28;&#41;</a>
&gt;</p>
<blockquote>
<p>我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是“抽象”这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上……我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog: <a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter: <a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a>
From: Guancheng Chen
Sent: Monday, March 22, 2010 7:37 AM
To: TopLanguage
Subject: [TL] {技术}{多线程}实施并行编程的五大障碍
近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问“什么是实施并行编程的最大障
碍”时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/" target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/</a></a>
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是“专家”们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了“编译指导”、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说“在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶……你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的”，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：“你觉得并行编程容易么？”，十有八九会说“我觉得很难”。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点“教育”有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。</p>
</li>
</ol>
<p>To unsubscribe from this group, send email to
pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to
pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>--
Tinyfool的开发日记 <a href="http://www.tinydust.net/dev/" target="_blank"><a href="http://www.tinydust.net/dev/">http://www.tinydust.net/dev/</a></a>
代码中国网 <a href="http://www.codechina.org/" target="_blank"><a href="http://www.codechina.org">http://www.codechina.org</a></a>
myTwitter: <a href="http://twitter.com/tinyfool" target="_blank"><a href="http://twitter.com/tinyfool">http://twitter.com/tinyfool</a></a></p>
<p>To unsubscribe from this group, send email to
pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to
pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>--
Tinyfool的开发日记 <a href="http://www.tinydust.net/dev/" target="_blank"><a href="http://www.tinydust.net/dev/">http://www.tinydust.net/dev/</a></a>
代码中国网 <a href="http://www.codechina.org/" target="_blank"><a href="http://www.codechina.org">http://www.codechina.org</a></a>
myTwitter: <a href="http://twitter.com/tinyfool" target="_blank"><a href="http://twitter.com/tinyfool">http://twitter.com/tinyfool</a></a></p>
<p>To unsubscribe from this group, send email to
pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to
pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>--
Milo Yip</p>
<p>Twitter @miloyip
<a href="http://www.cnblogs.com/miloyip/" target="_blank"><a href="http://www.cnblogs.com/miloyip/">http://www.cnblogs.com/miloyip/</a></a>
<a href="http://miloyip.seezone.net/" target="_blank"><a href="http://miloyip.seezone.net/">http://miloyip.seezone.net/</a></a>
<a href="">显示删减掉的内容</a>
<img src="" alt=""> Milo Yip <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>應該是「全局照明」</p>
<p>在 2010年3月22日上午10:20，Milo Yip <a href="&#109;&#x61;&#105;&#x6c;&#x74;&#x6f;&#58;&#91;&#109;&#x69;&#x6c;&#x2e;&#46;&#x2e;&#x40;&#103;&#x6d;&#97;&#105;&#108;&#x2e;&#99;&#x6f;&#109;&#x5d;&#40;&#41;">&#91;&#109;&#x69;&#x6c;&#x2e;&#46;&#x2e;&#x40;&#103;&#x6d;&#97;&#105;&#108;&#x2e;&#99;&#x6f;&#109;&#x5d;&#40;&#41;</a> 寫道：</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<blockquote>
<p>我在等NVidia的Fermi和Nexus，想試做全域照明。
但怕買了Fermi後，機器也只是用來做做翻譯……</p>
<p>在 2010年3月22日上午9:51，Jeffrey Zhao <a href="&#x6d;&#97;&#105;&#108;&#x74;&#111;&#58;&#91;&#x6a;&#101;&#46;&#x2e;&#46;&#64;&#108;&#x69;&#x76;&#x65;&#46;&#x63;&#x6f;&#109;&#93;&#x28;&#41;">&#91;&#x6a;&#101;&#46;&#x2e;&#46;&#64;&#108;&#x69;&#x76;&#x65;&#46;&#x63;&#x6f;&#109;&#93;&#x28;&#41;</a> 寫道：</p>
<blockquote>
<p>是嘛，我记得是提交了标准还在审核。</p>
<p>好吧，我去查了一下果然在08年12月1.0 Stable release了。</p>
<p>Jeffrey Zhao
Blog: <a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter: <a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a>
From: Tinyfool
Sent: Monday, March 22, 2010 9:46 AM
To: <a href="">pon...@googlegroups.com</a>
Subject: Re: [TL] {技术}{多线程}实施并行编程的五大障碍
OpenCL早就出来标准了，而且在做各个平台的实现…
视野啊…</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#109;&#x61;&#105;&#108;&#116;&#x6f;&#x3a;&#x5b;&#106;&#x65;&#46;&#46;&#x2e;&#64;&#x6c;&#105;&#x76;&#101;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#41;">&#x5b;&#106;&#x65;&#46;&#46;&#x2e;&#64;&#x6c;&#105;&#x76;&#101;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#41;</a>
&gt;</p>
<blockquote>
<p>哈哈，广告好，扩展视野，那我继续做广告了……</p>
<p>微软其实很早就在搞Microsoft Accelerator项目，旨在利用DirectX进行计算，.NET项目。
<a href="http://research.microsoft.com/en-us/projects/Accelerator/" target="_blank"><a href="http://research.microsoft.com/en-us/projects/Accelerator/">http://research.microsoft.com/en-us/projects/Accelerator/</a></a></p>
<p>然后F/#这边由于语言的支持良好，可以设计出丰富的表达式、DSL等Modeling
Language，再由框架进行自动并行，解决问题可以很容易（已经2.0了）。</p>
<p>这篇文章是个简单介绍：<a href="http://strangelights.com/blog/archive/2008/09/21/1628.aspx" target="_blank"><a href="http://strangelights.com/blog/archive/2008/09/21/1628.aspx">http://strangelights.com/blog/archive/2008/09/21/1628.aspx</a></a></p>
<p>Microsoft Solver Foundation
<a href="http://code.msdn.microsoft.com/solverfoundation" target="_blank"><a href="http://code.msdn.microsoft.com/solverfoundation">http://code.msdn.microsoft.com/solverfoundation</a></a></p>
<p>F/# Optimization Modeling Language Utilizing Microsoft Solver Foundation
<a href="http://code.msdn.microsoft.com/solverfoundationfs1" target="_blank"><a href="http://code.msdn.microsoft.com/solverfoundationfs1">http://code.msdn.microsoft.com/solverfoundationfs1</a></a></p>
<p>现在就等OpenCL如果有标准出来，肯定立马可以跟上个类库，哦耶。</p>
<p>Jeffrey Zhao
Blog: <a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter: <a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a>
From: Tinyfool
Sent: Monday, March 22, 2010 9:20 AM
To: <a href="">pon...@googlegroups.com</a>
Subject: Re: [TL] {技术}{多线程}实施并行编程的五大障碍
唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下
Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？
还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#109;&#x61;&#105;&#x6c;&#116;&#x6f;&#58;&#x5b;&#106;&#x65;&#46;&#46;&#46;&#x40;&#108;&#105;&#x76;&#101;&#46;&#99;&#x6f;&#x6d;&#93;&#x28;&#41;">&#x5b;&#106;&#x65;&#46;&#46;&#46;&#x40;&#108;&#105;&#x76;&#101;&#46;&#99;&#x6f;&#x6d;&#93;&#x28;&#41;</a>
&gt;</p>
<blockquote>
<p>我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是“抽象”这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上……我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog: <a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter: <a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a>
From: Guancheng Chen
Sent: Monday, March 22, 2010 7:37 AM
To: TopLanguage
Subject: [TL] {技术}{多线程}实施并行编程的五大障碍
近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问“什么是实施并行编程的最大障
碍”时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/" target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/</a></a>
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是“专家”们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了“编译指导”、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说“在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶……你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的”，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：“你觉得并行编程容易么？”，十有八九会说“我觉得很难”。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点“教育”有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。</p>
</li>
</ol>
<p>To unsubscribe from this group, send email to
pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to
pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>--
Tinyfool的开发日记 <a href="http://www.tinydust.net/dev/" target="_blank"><a href="http://www.tinydust.net/dev/">http://www.tinydust.net/dev/</a></a>
代码中国网 <a href="http://www.codechina.org/" target="_blank"><a href="http://www.codechina.org">http://www.codechina.org</a></a>
myTwitter: <a href="http://twitter.com/tinyfool" target="_blank"><a href="http://twitter.com/tinyfool">http://twitter.com/tinyfool</a></a></p>
<p>To unsubscribe from this group, send email to
pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to
pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>--
Tinyfool的开发日记 <a href="http://www.tinydust.net/dev/" target="_blank"><a href="http://www.tinydust.net/dev/">http://www.tinydust.net/dev/</a></a>
代码中国网 <a href="http://www.codechina.org/" target="_blank"><a href="http://www.codechina.org">http://www.codechina.org</a></a>
myTwitter: <a href="http://twitter.com/tinyfool" target="_blank"><a href="http://twitter.com/tinyfool">http://twitter.com/tinyfool</a></a></p>
<p>To unsubscribe from this group, send email to
pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to
pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>--
Milo Yip</p>
<p>Twitter @miloyip
<a href="http://www.cnblogs.com/miloyip/" target="_blank"><a href="http://www.cnblogs.com/miloyip/">http://www.cnblogs.com/miloyip/</a></a>
<a href="http://miloyip.seezone.net/" target="_blank"><a href="http://miloyip.seezone.net/">http://miloyip.seezone.net/</a></a></p>
</blockquote>
<p>--
Milo Yip</p>
<p>Twitter @miloyip
<a href="http://www.cnblogs.com/miloyip/" target="_blank"><a href="http://www.cnblogs.com/miloyip/">http://www.cnblogs.com/miloyip/</a></a>
<a href="http://miloyip.seezone.net/" target="_blank"><a href="http://miloyip.seezone.net/">http://miloyip.seezone.net/</a></a>
<a href="">显示删减掉的内容</a></p>
<p><img src="" alt=""> archerzz <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>工具的确是个问题，没有好的工具，很难快速推广。
2010/3/22 Changsheng Jiang <a href="&#109;&#97;&#x69;&#x6c;&#116;&#x6f;&#x3a;&#x5b;&#106;&#x69;&#x61;&#110;&#x67;&#x2e;&#46;&#x2e;&#64;&#x67;&#x6d;&#97;&#x69;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#x29;">&#x5b;&#106;&#x69;&#x61;&#110;&#x67;&#x2e;&#46;&#x2e;&#64;&#x67;&#x6d;&#97;&#x69;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#x29;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>个人觉得最大障碍在工具上.</p>
<p>并行学术上研究得不少, 主要在算法和模型上. 工程上的工具, 多是自串行程序来设计的, 弄得复杂不堪. 并行需要语言和库两级支持, Pthreads 和 MPI 仅从库上入手, 让程序员处理各种重复且复杂的分发, 并发锁等. OpenMP好一些, 可惜目前只支持线程并行.
用 ErLang 等将并行设计在语言里的来做并行会容易得多, 得易于面向消息传递的隔离模型, 程序稳定易写. 模型和语言的性能是一个问题, 主要的问题还在用的人和实际并行项目不多.</p>
<p>调试工具就更少了. 有少数商业化的工具.
当然, 我是将可维护性归结为语言工具太差.</p>
<pre><code>                                                 Changsheng Jiang
</code></pre><p>2010/3/22 Guancheng Chen <a href="&#x6d;&#x61;&#105;&#108;&#x74;&#x6f;&#58;&#x5b;&#x63;&#x68;&#101;&#x6e;&#x67;&#x75;&#46;&#x2e;&#46;&#64;&#x67;&#x6d;&#x61;&#105;&#x6c;&#46;&#x63;&#x6f;&#109;&#x5d;&#x28;&#41;">&#x5b;&#x63;&#x68;&#101;&#x6e;&#x67;&#x75;&#46;&#x2e;&#46;&#64;&#x67;&#x6d;&#x61;&#105;&#x6c;&#46;&#x63;&#x6f;&#109;&#x5d;&#x28;&#41;</a></p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问“什么是实施并行编程的最大障
碍”时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。
( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看
<a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/" target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/</a></a>
)</p>
<ol>
<li>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</li>
<li>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是“专家”们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了“编译指导”、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。
可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说“在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶……你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的”，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：“你觉得并行编程容易么？”，十有八九会说“我觉得很难”。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</li>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？
(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx
总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点“教育”有很大关系了。</li>
<li>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</li>
<li>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> 陨落雕 <img src="" alt=""></li>
</ol>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>我也想用Fermi来解一个和ray tracer类似的问题，话说NV招了好多搞ray tracer和hpc的大牛。</p>
<p>On Mar 21, 10:20 pm, Milo Yip <a href="&#x6d;&#97;&#105;&#x6c;&#x74;&#x6f;&#x3a;&#91;&#109;&#105;&#108;&#x6f;&#46;&#x2e;&#46;&#64;&#103;&#x6d;&#x61;&#x69;&#x6c;&#46;&#x63;&#111;&#109;&#93;&#40;&#x29;">&#91;&#109;&#105;&#108;&#x6f;&#46;&#x2e;&#46;&#64;&#103;&#x6d;&#x61;&#x69;&#x6c;&#46;&#x63;&#111;&#109;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>我在等NVidia的Fermi和Nexus，想試做全域照明。
但怕買了Fermi後，機器也只是用來做做翻譯......</p>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>在 2010年3月22日上午9:51，Jeffrey Zhao <a href="&#x6d;&#x61;&#105;&#108;&#116;&#111;&#58;&#91;&#x6a;&#101;&#46;&#46;&#46;&#x40;&#108;&#105;&#x76;&#x65;&#46;&#x63;&#111;&#x6d;&#x5d;&#x28;&#41;">&#91;&#x6a;&#101;&#46;&#46;&#46;&#x40;&#108;&#105;&#x76;&#x65;&#46;&#x63;&#111;&#x6d;&#x5d;&#x28;&#41;</a> 寫道：</p>
<blockquote>
<p>是嘛，我记得是提交了标准还在审核。</p>
<p>好吧，我去查了一下果然在08年12月1.0 Stable release了。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a>
From: Tinyfool
Sent: Monday, March 22, 2010 9:46 AM
To: <a href="">pon...@googlegroups.com</a>
Subject: Re: [TL] {技术}{多线程}实施并行编程的五大障碍
OpenCL早就出来标准了，而且在做各个平台的实现...
视野啊...</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#109;&#97;&#x69;&#108;&#116;&#x6f;&#58;&#91;&#x6a;&#101;&#46;&#x2e;&#46;&#x40;&#108;&#x69;&#x76;&#x65;&#46;&#99;&#x6f;&#109;&#93;&#x28;&#x29;">&#91;&#x6a;&#101;&#46;&#x2e;&#46;&#x40;&#108;&#x69;&#x76;&#x65;&#46;&#99;&#x6f;&#109;&#93;&#x28;&#x29;</a></p>
<blockquote>
<p>哈哈，广告好，扩展视野，那我继续做广告了......</p>
</blockquote>
</blockquote>
</blockquote>
<p>&gt;</p>
<blockquote>
<blockquote>
<blockquote>
<p>微软其实很早就在搞Microsoft Accelerator项目，旨在利用DirectX进行计算，.NET项目。
<a href="http://research.microsoft.com/en-us/projects/Accelerator/" target="_blank"><a href="http://research.microsoft.com/en-us/projects/Accelerator/">http://research.microsoft.com/en-us/projects/Accelerator/</a></a></p>
<p>然后F/#这边由于语言的支持良好，可以设计出丰富的表达式、DSL等Modeling
Language，再由框架进行自动并行，解决问题可以很容易（已经2.0了）。</p>
<p>这篇文章是个简单介绍：<a href="http://strangelights.com/blog/archive/2008/09/21/1628.aspx" target="_blank"><a href="http://strangelights.com/blog/archive/2008/09/21/1628.aspx">http://strangelights.com/blog/archive/2008/09/21/1628.aspx</a></a></p>
<p>Microsoft Solver Foundation
<a href="http://code.msdn.microsoft.com/solverfoundation" target="_blank"><a href="http://code.msdn.microsoft.com/solverfoundation">http://code.msdn.microsoft.com/solverfoundation</a></a></p>
<p>F/# Optimization Modeling Language Utilizing Microsoft Solver Foundation
<a href="http://code.msdn.microsoft.com/solverfoundationfs1" target="_blank"><a href="http://code.msdn.microsoft.com/solverfoundationfs1">http://code.msdn.microsoft.com/solverfoundationfs1</a></a></p>
<p>现在就等OpenCL如果有标准出来，肯定立马可以跟上个类库，哦耶。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a>
From: Tinyfool
Sent: Monday, March 22, 2010 9:20 AM
To: <a href="">pon...@googlegroups.com</a>
Subject: Re: [TL] {技术}{多线程}实施并行编程的五大障碍
唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下
Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？
还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#x6d;&#97;&#105;&#108;&#x74;&#x6f;&#x3a;&#91;&#106;&#x65;&#46;&#x2e;&#x2e;&#x40;&#x6c;&#105;&#x76;&#x65;&#46;&#99;&#111;&#x6d;&#93;&#x28;&#41;">&#91;&#106;&#x65;&#46;&#x2e;&#x2e;&#x40;&#x6c;&#105;&#x76;&#x65;&#46;&#99;&#111;&#x6d;&#93;&#x28;&#41;</a></p>
<blockquote>
<p>我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>&gt;</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a>
From: Guancheng Chen
Sent: Monday, March 22, 2010 7:37 AM
To: TopLanguage
Subject: [TL] {技术}{多线程}实施并行编程的五大障碍
近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..</p>
<p>)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。</p>
<p>尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这</li>
</ol>
</blockquote>
</blockquote>
</blockquote>
<p>...</p>
<p>read more &gt;&gt;
<a href="">显示删减掉的内容</a></p>
</blockquote>
<p><img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>微软好像已经推出了跟OpenCL类似的Direct Compute，也能搞GPU CPU混合计算</p>
<p>On 3月22日, 上午2时42分, &quot;Jeffrey Zhao&quot; <a href="&#x6d;&#x61;&#x69;&#x6c;&#116;&#x6f;&#58;&#91;&#x6a;&#x65;&#x2e;&#x2e;&#46;&#x40;&#x6c;&#105;&#x76;&#101;&#x2e;&#x63;&#111;&#109;&#93;&#40;&#x29;">&#91;&#x6a;&#x65;&#x2e;&#x2e;&#46;&#x40;&#x6c;&#105;&#x76;&#101;&#x2e;&#x63;&#111;&#109;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>哈哈，广告好，扩展视野，那我继续做广告了......</p>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>微软其实很早就在搞Microsoft Accelerator项目，旨在利用DirectX进行计算，.NET项目。<a href="http://research.microsoft.com/en-us/projects/Accelerator/" target="_blank"><a href="http://research.microsoft.com/en-us/projects/Accelerator/">http://research.microsoft.com/en-us/projects/Accelerator/</a></a></p>
<p>然后F/#这边由于语言的支持良好，可以设计出丰富的表达式、DSL等Modeling Language，再由框架进行自动并行，解决问题可以很容易（已经2.0了）。</p>
<p>这篇文章是个简单介绍：<a href="http://strangelights.com/blog/archive/2008/09/21/1628.aspx" target="_blank"><a href="http://strangelights.com/blog/archive/2008/09/21/1628.aspx">http://strangelights.com/blog/archive/2008/09/21/1628.aspx</a></a></p>
<p>Microsoft Solver Foundation<a href="http://[code.msdn.microsoft.com/solverfoundation](http://code.msdn.microsoft.com/solverfoundation" target="_blank">http://[code.msdn.microsoft.com/solverfoundation](http://code.msdn.microsoft.com/solverfoundation</a>)</p>
<p>F/# Optimization Modeling Language Utilizing Microsoft Solver Foundation<a href="http://[code.msdn.microsoft.com/solverfoundationfs1](http://code.msdn.microsoft.com/solverfoundationfs1" target="_blank">http://[code.msdn.microsoft.com/solverfoundationfs1](http://code.msdn.microsoft.com/solverfoundationfs1</a>)</p>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>现在就等OpenCL如果有标准出来，肯定立马可以跟上个类库，哦耶。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p>From: Tinyfool
Sent: Monday, March 22, 2010 9:20 AM
To: <a href="">pon...@googlegroups.com</a>
Subject: Re: [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#x6d;&#x61;&#105;&#x6c;&#x74;&#111;&#x3a;&#91;&#106;&#101;&#46;&#46;&#46;&#64;&#108;&#105;&#x76;&#101;&#x2e;&#99;&#111;&#x6d;&#93;&#40;&#x29;">&#91;&#106;&#101;&#46;&#46;&#46;&#64;&#108;&#105;&#x76;&#101;&#x2e;&#99;&#111;&#x6d;&#93;&#40;&#x29;</a></p>
<p>  我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>  其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>  例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>  至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>  例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>  Jeffrey Zhao
  Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
  Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p>  From: Guancheng Chen
  Sent: Monday, March 22, 2010 7:37 AM
  To: TopLanguage
  Subject: [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>  近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
  碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
  (fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
  Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
  的看法。</p>
<p>  ( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看
 <a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..</p>
<p>  )</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。</p>
<p>尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
</li>
<li><p>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</p>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
</li>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可...</p>
</li>
</ol>
<p>阅读更多 &gt;&gt;
<a href="">显示删减掉的内容</a>
<img src="" alt=""> 郑伟 <img src="" alt=""></p>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>我觉得 想要并行开发 必须绕开c/c++
2010/3/22 Guancheng Chen <a href="&#x6d;&#x61;&#105;&#108;&#x74;&#x6f;&#58;&#91;&#99;&#x68;&#x65;&#x6e;&#103;&#117;&#46;&#46;&#x2e;&#x40;&#x67;&#109;&#97;&#105;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#93;&#x28;&#x29;">&#91;&#99;&#x68;&#x65;&#x6e;&#103;&#117;&#46;&#46;&#x2e;&#x40;&#x67;&#109;&#97;&#105;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#93;&#x28;&#x29;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>微软好像已经推出了跟OpenCL类似的Direct Compute，也能搞GPU CPU混合计算
On 3月22日, 上午2时42分, &quot;Jeffrey Zhao&quot; <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#x3a;&#91;&#106;&#101;&#x2e;&#x2e;&#x2e;&#64;&#x6c;&#x69;&#x76;&#x65;&#46;&#x63;&#111;&#x6d;&#93;&#x28;&#41;">&#91;&#106;&#101;&#x2e;&#x2e;&#x2e;&#64;&#x6c;&#x69;&#x76;&#x65;&#46;&#x63;&#111;&#x6d;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>哈哈，广告好，扩展视野，那我继续做广告了......</p>
<p>微软其实很早就在搞Microsoft Accelerator项目，旨在利用DirectX进行计算，.NET项目。<a href="http://research.microsoft.com/en-us/projects/Accelerator/" target="_blank"><a href="http://research.microsoft.com/en-us/projects/Accelerator/">http://research.microsoft.com/en-us/projects/Accelerator/</a></a></p>
<p>然后F/#这边由于语言的支持良好，可以设计出丰富的表达式、DSL等Modeling Language，再由框架进行自动并行，解决问题可以很容易（已经2.0了）。</p>
<p>这篇文章是个简单介绍：<a href="http://strangelights.com/blog/archive/2008/09/21/1628.aspx" target="_blank"><a href="http://strangelights.com/blog/archive/2008/09/21/1628.aspx">http://strangelights.com/blog/archive/2008/09/21/1628.aspx</a></a></p>
<p>Microsoft Solver Foundation<a href="http://[code.msdn.microsoft.com/solverfoundation](http://code.msdn.microsoft.com/solverfoundation" target="_blank">http://[code.msdn.microsoft.com/solverfoundation](http://code.msdn.microsoft.com/solverfoundation</a>)</p>
<p>F/# Optimization Modeling Language Utilizing Microsoft Solver Foundation<a href="http://[code.msdn.microsoft.com/solverfoundationfs1](http://code.msdn.microsoft.com/solverfoundationfs1" target="_blank">http://[code.msdn.microsoft.com/solverfoundationfs1](http://code.msdn.microsoft.com/solverfoundationfs1</a>)</p>
<p>现在就等OpenCL如果有标准出来，肯定立马可以跟上个类库，哦耶。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p>From: Tinyfool
Sent: Monday, March 22, 2010 9:20 AM
To: <a href="">pon...@googlegroups.com</a>
Subject: Re: [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#x6d;&#97;&#105;&#108;&#116;&#111;&#58;&#x5b;&#106;&#x65;&#46;&#46;&#46;&#64;&#x6c;&#105;&#x76;&#x65;&#46;&#99;&#111;&#109;&#x5d;&#x28;&#41;">&#x5b;&#106;&#x65;&#46;&#46;&#46;&#64;&#x6c;&#105;&#x76;&#x65;&#46;&#99;&#111;&#109;&#x5d;&#x28;&#41;</a></p>
<p>  我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>  其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>  例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>  至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>  例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>  Jeffrey Zhao
  Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
  Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p>  From: Guancheng Chen
  Sent: Monday, March 22, 2010 7:37 AM
  To: TopLanguage
  Subject: [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>  近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
  碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
  (fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
  Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
  的看法。</p>
<p>  ( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看
 <a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
  )</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
</li>
<li><p>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</p>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
</li>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维&gt;   护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可...</p>
</li>
</ol>
<p>阅读更多 &gt;&gt;</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a></p>
<p><img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>很有意思的事情是我上次问过一个负责定制OpenCL的哥们，&quot;从商业角度上讲，苹果为什么要自己搞一个新标准？&quot; 他就说那个时候苹果意识到未来这种
通用并行计算平台的重要性，而为了保证最大的商业利益就选择自己重新搞一个新标准而不是跟当时已有CUDA的Nvidia合作，结果现在NV也开始支持
OpenCL，但是他们最新的一本教材里说到&quot;根据我们的经验，学习OpenCL最好的办法是先学CUDA&quot;</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>On 3月22日, 上午6时10分, 陨落雕 <a href="&#109;&#x61;&#105;&#108;&#x74;&#x6f;&#58;&#x5b;&#x67;&#x65;&#111;&#46;&#x2e;&#x2e;&#46;&#64;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#99;&#111;&#x6d;&#x5d;&#40;&#x29;">&#x5b;&#x67;&#x65;&#111;&#46;&#x2e;&#x2e;&#46;&#64;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#99;&#111;&#x6d;&#x5d;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>我也想用Fermi来解一个和ray tracer类似的问题，话说NV招了好多搞ray tracer和hpc的大牛。</p>
<p>On Mar 21, 10:20 pm, Milo Yip <a href="&#109;&#x61;&#x69;&#108;&#116;&#x6f;&#x3a;&#x5b;&#x6d;&#105;&#x6c;&#111;&#x2e;&#46;&#46;&#x40;&#x67;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#109;&#x5d;&#x28;&#41;">&#x5b;&#x6d;&#105;&#x6c;&#111;&#x2e;&#46;&#46;&#x40;&#x67;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#109;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>我在等NVidia的Fermi和Nexus，想試做全域照明。
但怕買了Fermi後，機器也只是用來做做翻譯......</p>
<p>在 2010年3月22日上午9:51，Jeffrey Zhao <a href="&#x6d;&#x61;&#105;&#108;&#x74;&#111;&#58;&#x5b;&#x6a;&#x65;&#46;&#x2e;&#x2e;&#64;&#108;&#105;&#x76;&#x65;&#x2e;&#99;&#111;&#109;&#x5d;&#x28;&#41;">&#x5b;&#x6a;&#x65;&#46;&#x2e;&#x2e;&#64;&#108;&#105;&#x76;&#x65;&#x2e;&#99;&#111;&#109;&#x5d;&#x28;&#41;</a> 寫道：</p>
<blockquote>
<p>是嘛，我记得是提交了标准还在审核。</p>
<p>好吧，我去查了一下果然在08年12月1.0 Stable release了。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a>
From: Tinyfool
Sent: Monday, March 22, 2010 9:46 AM
To: <a href="">pon...@googlegroups.com</a>
Subject: Re: [TL] {技术}{多线程}实施并行编程的五大障碍
OpenCL早就出来标准了，而且在做各个平台的实现...
视野啊...</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#109;&#x61;&#x69;&#108;&#116;&#111;&#x3a;&#x5b;&#106;&#101;&#x2e;&#46;&#x2e;&#x40;&#x6c;&#105;&#118;&#x65;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#x28;&#x29;">&#x5b;&#106;&#101;&#x2e;&#46;&#x2e;&#x40;&#x6c;&#105;&#118;&#x65;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#x28;&#x29;</a></p>
<blockquote>
<p>哈哈，广告好，扩展视野，那我继续做广告了......</p>
<p>微软其实很早就在搞Microsoft Accelerator项目，旨在利用DirectX进行计算，.NET项目。
<a href="http://research.microsoft.com/en-us/projects/Accelerator/" target="_blank"><a href="http://research.microsoft.com/en-us/projects/Accelerator/">http://research.microsoft.com/en-us/projects/Accelerator/</a></a></p>
<p>然后F/#这边由于语言的支持良好，可以设计出丰富的表达式、DSL等Modeling
Language，再由框架进行自动并行，解决问题可以很容易（已经2.0了）。</p>
<p>这篇文章是个简单介绍：<a href="http://strangelights.com/blog/archive/2008/09/21/1628.aspx" target="_blank"><a href="http://strangelights.com/blog/archive/2008/09/21/1628.aspx">http://strangelights.com/blog/archive/2008/09/21/1628.aspx</a></a></p>
<p>Microsoft Solver Foundation
<a href="http://code.msdn.microsoft.com/solverfoundation" target="_blank"><a href="http://code.msdn.microsoft.com/solverfoundation">http://code.msdn.microsoft.com/solverfoundation</a></a></p>
<p>F/# Optimization Modeling Language Utilizing Microsoft Solver Foundation
<a href="http://code.msdn.microsoft.com/solverfoundationfs1" target="_blank"><a href="http://code.msdn.microsoft.com/solverfoundationfs1">http://code.msdn.microsoft.com/solverfoundationfs1</a></a></p>
<p>现在就等OpenCL如果有标准出来，肯定立马可以跟上个类库，哦耶。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a>
From: Tinyfool
Sent: Monday, March 22, 2010 9:20 AM
To: <a href="">pon...@googlegroups.com</a>
Subject: Re: [TL] {技术}{多线程}实施并行编程的五大障碍
唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下
Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？
还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#109;&#x61;&#105;&#108;&#x74;&#x6f;&#x3a;&#91;&#x6a;&#101;&#46;&#x2e;&#x2e;&#64;&#108;&#x69;&#x76;&#x65;&#46;&#99;&#x6f;&#109;&#93;&#x28;&#x29;">&#91;&#x6a;&#101;&#46;&#x2e;&#x2e;&#64;&#108;&#x69;&#x76;&#x65;&#46;&#99;&#x6f;&#109;&#93;&#x28;&#x29;</a></p>
<blockquote>
<p>我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a>
From: Guancheng Chen
Sent: Monday, March 22, 2010 7:37 AM
To: TopLanguage
Subject: [TL] {技术}{多线程}实施并行编程的五大障碍
近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li>对众核的恐惧...</li>
</ol>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>阅读更多 &gt;&gt;
<a href="">显示删减掉的内容</a>
<img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>不知道您觉得现有的工具哪些个最趁手呢？</p>
<p>On 3月22日, 上午3时19分, Changsheng Jiang <a href="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#x6f;&#58;&#91;&#x6a;&#x69;&#x61;&#x6e;&#x67;&#122;&#x75;&#111;&#46;&#46;&#46;&#64;&#x67;&#x6d;&#x61;&#105;&#108;&#x2e;&#99;&#111;&#109;&#x5d;&#40;&#x29;">&#91;&#x6a;&#x69;&#x61;&#x6e;&#x67;&#122;&#x75;&#111;&#46;&#46;&#46;&#64;&#x67;&#x6d;&#x61;&#105;&#108;&#x2e;&#99;&#111;&#109;&#x5d;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>个人觉得最大障碍在工具上.</p>
<p>并行学术上研究得不少, 主要在算法和模型上. 工程上的工具, 多是自串行程序来设计的, 弄得复杂不堪. 并行需要语言和库两级支持, Pthreads 和
MPI 仅从库上入手, 让程序员处理各种重复且复杂的分发, 并发锁等. OpenMP好一些, 可惜目前只支持线程并行.</p>
<p>用 ErLang 等将并行设计在语言里的来做并行会容易得多, 得易于面向消息传递的隔离模型, 程序稳定易写. 模型和语言的性能是一个问题,
主要的问题还在用的人和实际并行项目不多.</p>
<p>调试工具就更少了. 有少数商业化的工具.</p>
<p>当然, 我是将可维护性归结为语言工具太差.</p>
<pre><code>                                                 Changsheng Jiang
</code></pre><p>2010/3/22 Guancheng Chen <a href="&#x6d;&#97;&#105;&#108;&#x74;&#x6f;&#58;&#x5b;&#x63;&#104;&#101;&#x6e;&#x67;&#x75;&#x61;&#110;&#99;&#104;&#x2e;&#46;&#46;&#x40;&#103;&#x6d;&#97;&#x69;&#108;&#46;&#99;&#111;&#x6d;&#x5d;&#40;&#41;">&#x5b;&#x63;&#104;&#101;&#x6e;&#x67;&#x75;&#x61;&#110;&#99;&#104;&#x2e;&#46;&#46;&#x40;&#103;&#x6d;&#97;&#x69;&#108;&#46;&#99;&#111;&#x6d;&#x5d;&#40;&#41;</a></p>
</blockquote>
<p>&gt;
&gt;
&gt;</p>
<blockquote>
<blockquote>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..</p>
<p>)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。</p>
</blockquote>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<blockquote>
<blockquote>
<p>尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。</p>
</li>
</ol>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
<a href="">显示删减掉的内容</a></p>
</blockquote>
</blockquote>
<p><img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>哈哈 是想绕开C++那些本来就复杂的要死的feature么？是不是如果有一门新的易用的编程语言会比诸如给C++添加thread特性的方法要
好？</p>
<p>On 3月22日, 上午6时48分, Kula <a href="&#109;&#x61;&#105;&#x6c;&#116;&#111;&#x3a;&#x5b;&#x6b;&#117;&#x6c;&#97;&#x73;&#46;&#46;&#46;&#64;&#x67;&#109;&#x61;&#x69;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#93;&#40;&#41;">&#x5b;&#x6b;&#117;&#x6c;&#97;&#x73;&#46;&#46;&#46;&#64;&#x67;&#109;&#x61;&#x69;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>我觉得 想要并行开发 必须绕开c/c++</p>
<p>2010/3/22 Guancheng Chen <a href="&#109;&#x61;&#x69;&#108;&#x74;&#x6f;&#x3a;&#91;&#99;&#104;&#101;&#110;&#103;&#117;&#x61;&#x6e;&#99;&#104;&#46;&#46;&#x2e;&#64;&#x67;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#99;&#x6f;&#109;&#x5d;&#x28;&#x29;">&#91;&#99;&#104;&#101;&#110;&#103;&#117;&#x61;&#x6e;&#99;&#104;&#46;&#46;&#x2e;&#64;&#x67;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#99;&#x6f;&#109;&#x5d;&#x28;&#x29;</a></p>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>&gt;
&gt;
&gt;</p>
<blockquote>
<blockquote>
<p>微软好像已经推出了跟OpenCL类似的Direct Compute，也能搞GPU CPU混合计算</p>
<p>On 3月22日, 上午2时42分, &quot;Jeffrey Zhao&quot; <a href="&#x6d;&#97;&#x69;&#108;&#116;&#111;&#x3a;&#91;&#x6a;&#101;&#x2e;&#x2e;&#46;&#x40;&#108;&#x69;&#x76;&#101;&#46;&#x63;&#111;&#109;&#x5d;&#40;&#41;">&#91;&#x6a;&#101;&#x2e;&#x2e;&#46;&#x40;&#108;&#x69;&#x76;&#101;&#46;&#x63;&#111;&#109;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>哈哈，广告好，扩展视野，那我继续做广告了......</p>
<p>微软其实很早就在搞Microsoft Accelerator项目，旨在利用DirectX进行计算，.NET项目。
<a href="http://research.microsoft.com/en-us/projects/Accelerator/" target="_blank"><a href="http://research.microsoft.com/en-us/projects/Accelerator/">http://research.microsoft.com/en-us/projects/Accelerator/</a></a></p>
<p>然后F/#这边由于语言的支持良好，可以设计出丰富的表达式、DSL等Modeling
Language，再由框架进行自动并行，解决问题可以很容易（已经2.0了）。</p>
<p>这篇文章是个简单介绍：<a href="http://strangelights.com/blog/archive/2008/09/21/1628.aspx" target="_blank"><a href="http://strangelights.com/blog/archive/2008/09/21/1628.aspx">http://strangelights.com/blog/archive/2008/09/21/1628.aspx</a></a></p>
<p>Microsoft Solver Foundationhttp://
<a href="http://code.msdn.microsoft.com/solverfoundation" target="_blank">code.msdn.microsoft.com/solverfoundation</a></p>
<p>F/# Optimization Modeling Language Utilizing Microsoft Solver
Foundation<a href="http://[code.msdn.microsoft.com/solverfoundationfs1](http://code.msdn.microsoft.com/solverfoundationfs1" target="_blank">http://[code.msdn.microsoft.com/solverfoundationfs1](http://code.msdn.microsoft.com/solverfoundationfs1</a>)</p>
<p>现在就等OpenCL如果有标准出来，肯定立马可以跟上个类库，哦耶。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p>From: Tinyfool
Sent: Monday, March 22, 2010 9:20 AM
To: <a href="">pon...@googlegroups.com</a>
Subject: Re: [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#109;&#x61;&#x69;&#x6c;&#x74;&#111;&#x3a;&#91;&#x6a;&#x65;&#46;&#x2e;&#46;&#64;&#x6c;&#x69;&#118;&#x65;&#46;&#x63;&#x6f;&#109;&#x5d;&#40;&#x29;">&#91;&#x6a;&#x65;&#46;&#x2e;&#46;&#64;&#x6c;&#x69;&#118;&#x65;&#46;&#x63;&#x6f;&#109;&#x5d;&#40;&#x29;</a></p>
<p>  我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>  其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>  例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>  至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>  例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>  Jeffrey Zhao
  Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
  Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p>  From: Guancheng Chen
  Sent: Monday, March 22, 2010 7:37 AM
  To: TopLanguage
  Subject: [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>  近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
  碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
  (fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
  Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
  的看法。</p>
<p>  ( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看
 <a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-" target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a></a>.
..
  )</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线</p>
</li>
</ol>
</blockquote>
<p>程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。</p>
<blockquote>
<p>  尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
  并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
  好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
  和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
  OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
  训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li><p>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</p>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
</li>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false...</p>
</li>
</ol>
</blockquote>
</blockquote>
<p>阅读更多 &gt;&gt;
<a href="">显示删减掉的内容</a>
<img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>On 3月22日, 上午2时20分, Tinyfool <a href="&#x6d;&#x61;&#105;&#108;&#x74;&#x6f;&#x3a;&#x5b;&#x74;&#x69;&#x6e;&#x79;&#102;&#x2e;&#46;&#x2e;&#64;&#103;&#x6d;&#x61;&#x69;&#108;&#46;&#x63;&#x6f;&#x6d;&#93;&#40;&#x29;">&#x5b;&#x74;&#x69;&#x6e;&#x79;&#102;&#x2e;&#46;&#x2e;&#64;&#103;&#x6d;&#x61;&#x69;&#108;&#46;&#x63;&#x6f;&#x6d;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#x6d;&#x61;&#105;&#x6c;&#x74;&#x6f;&#58;&#x5b;&#106;&#x65;&#46;&#46;&#46;&#64;&#108;&#x69;&#118;&#101;&#46;&#x63;&#111;&#109;&#93;&#40;&#41;">&#x5b;&#106;&#x65;&#46;&#46;&#46;&#64;&#108;&#x69;&#118;&#101;&#46;&#x63;&#111;&#109;&#93;&#40;&#41;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
</blockquote>
</blockquote>
<p>&gt;</p>
<blockquote>
<blockquote>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#x6d;&#97;&#105;&#108;&#116;&#111;&#x3a;&#91;&#x63;&#x68;&#101;&#x6e;&#x67;&#117;&#x61;&#x6e;&#99;&#104;&#x2e;&#x2e;&#46;&#64;&#103;&#x6d;&#x61;&#105;&#108;&#46;&#99;&#x6f;&#109;&#x5d;&#40;&#x29;">&#91;&#x63;&#x68;&#101;&#x6e;&#x67;&#117;&#x61;&#x6e;&#99;&#104;&#x2e;&#x2e;&#46;&#64;&#103;&#x6d;&#x61;&#105;&#108;&#46;&#99;&#x6f;&#109;&#x5d;&#40;&#x29;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#109;&#97;&#x69;&#108;&#116;&#x6f;&#x3a;&#x5b;&#x70;&#111;&#110;&#x2e;&#x2e;&#46;&#64;&#103;&#111;&#111;&#x67;&#x6c;&#101;&#x67;&#x72;&#111;&#x75;&#x70;&#x73;&#46;&#99;&#x6f;&#109;&#93;&#x28;&#41;">&#x5b;&#x70;&#111;&#110;&#x2e;&#x2e;&#46;&#64;&#103;&#111;&#111;&#x67;&#x6c;&#101;&#x67;&#x72;&#111;&#x75;&#x70;&#x73;&#46;&#99;&#x6f;&#109;&#93;&#x28;&#41;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
</blockquote>
</blockquote>
<p>&gt;</p>
<blockquote>
<blockquote>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..</p>
<p>)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。</p>
</blockquote>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<blockquote>
<blockquote>
<p>尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。</p>
</li>
</ol>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>--
Tinyfool的开发日记<a href="http://www.tinydust.net/dev/" target="_blank"><a href="http://www.tinydust.net/dev/">http://www.tinydust.net/dev/</a></a>
代码中国网<a href="http://www.codechina.org/" target="_blank"><a href="http://www.codechina.org">http://www.codechina.org</a></a>
myTwitter:<a href="http://twitter.com/tinyfool" target="_blank"><a href="http://twitter.com/tinyfool">http://twitter.com/tinyfool</a></a>
<a href="">显示删减掉的内容</a></p>
</blockquote>
<p><img src="" alt=""> changsheng <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>说来惭愧, 接触并行时间不长, 没什么实际经验, 只写过几个并行程序.</p>
<p>感觉 MPI + OpenMP 倒算好用. 简单的单机程序, 用OpenMP并行, 添加几个编译指令就可以. 复杂点的, 用MPI, 也能忍, 只是需要重新设计一下程序和算法.
除了简单的打印, 跟踪一个进程, 不知道怎么调试并行程序. 没有专用平台如NUMA等的编程经验.</p>
<pre><code>                                                 Changsheng Jiang
</code></pre><p>2010/3/22 Guancheng Chen <a href="&#109;&#x61;&#x69;&#108;&#116;&#x6f;&#58;&#x5b;&#x63;&#104;&#101;&#x6e;&#103;&#x75;&#x2e;&#x2e;&#46;&#64;&#103;&#x6d;&#97;&#105;&#x6c;&#x2e;&#x63;&#111;&#109;&#x5d;&#40;&#41;">&#x5b;&#x63;&#104;&#101;&#x6e;&#103;&#x75;&#x2e;&#x2e;&#46;&#64;&#103;&#x6d;&#97;&#105;&#x6c;&#x2e;&#x63;&#111;&#109;&#x5d;&#40;&#41;</a>
不知道您觉得现有的工具哪些个最趁手呢？
On 3月22日, 上午3时19分, Changsheng Jiang <a href="&#x6d;&#97;&#105;&#108;&#116;&#111;&#x3a;&#x5b;&#106;&#x69;&#x61;&#110;&#103;&#x7a;&#117;&#111;&#46;&#46;&#x2e;&#x40;&#x67;&#109;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#111;&#109;&#x5d;&#40;&#41;">&#x5b;&#106;&#x69;&#x61;&#110;&#103;&#x7a;&#117;&#111;&#46;&#46;&#x2e;&#x40;&#x67;&#109;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#111;&#109;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>个人觉得最大障碍在工具上.</p>
<p>并行学术上研究得不少, 主要在算法和模型上. 工程上的工具, 多是自串行程序来设计的, 弄得复杂不堪. 并行需要语言和库两级支持, Pthreads 和
MPI 仅从库上入手, 让程序员处理各种重复且复杂的分发, 并发锁等. OpenMP好一些, 可惜目前只支持线程并行.</p>
<p>用 ErLang 等将并行设计在语言里的来做并行会容易得多, 得易于面向消息传递的隔离模型, 程序稳定易写. 模型和语言的性能是一个问题,
主要的问题还在用的人和实际并行项目不多.</p>
<p>调试工具就更少了. 有少数商业化的工具.</p>
<p>当然, 我是将可维护性归结为语言工具太差.</p>
<pre><code>                                                 Changsheng Jiang
</code></pre><p>2010/3/22 Guancheng Chen <a href="&#x6d;&#x61;&#x69;&#108;&#116;&#x6f;&#58;&#x5b;&#99;&#104;&#x65;&#110;&#103;&#x75;&#x61;&#110;&#x63;&#x68;&#46;&#46;&#46;&#64;&#x67;&#x6d;&#97;&#x69;&#x6c;&#46;&#99;&#111;&#109;&#93;&#40;&#x29;">&#x5b;&#99;&#104;&#x65;&#110;&#103;&#x75;&#x61;&#110;&#x63;&#x68;&#46;&#46;&#46;&#64;&#x67;&#x6d;&#97;&#x69;&#x6c;&#46;&#99;&#111;&#109;&#93;&#40;&#x29;</a></p>
<blockquote>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。</p>
</li>
</ol>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> doyle <img src="" alt=""></p>
</blockquote>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>2010/3/22 Guancheng Chen <a href="&#109;&#97;&#105;&#x6c;&#116;&#x6f;&#58;&#x5b;&#99;&#104;&#101;&#x6e;&#103;&#117;&#46;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#40;&#41;">&#x5b;&#99;&#104;&#101;&#x6e;&#103;&#117;&#46;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#40;&#41;</a>
我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>我也是被蛊惑了...所以向老婆提申请来着,结果被否掉了...
 On 3月22日, 上午2时20分, Tinyfool <a href="&#x6d;&#97;&#105;&#108;&#116;&#111;&#x3a;&#x5b;&#116;&#105;&#x6e;&#x79;&#102;&#46;&#46;&#x2e;&#x40;&#103;&#x6d;&#97;&#x69;&#x6c;&#46;&#x63;&#111;&#109;&#x5d;&#x28;&#x29;">&#x5b;&#116;&#105;&#x6e;&#x79;&#102;&#46;&#46;&#x2e;&#x40;&#103;&#x6d;&#97;&#x69;&#x6c;&#46;&#x63;&#111;&#109;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#109;&#97;&#x69;&#x6c;&#116;&#x6f;&#58;&#x5b;&#106;&#x65;&#x2e;&#x2e;&#46;&#64;&#x6c;&#x69;&#118;&#101;&#46;&#x63;&#111;&#x6d;&#93;&#40;&#41;">&#x5b;&#106;&#x65;&#x2e;&#x2e;&#46;&#64;&#x6c;&#x69;&#118;&#101;&#46;&#x63;&#111;&#x6d;&#93;&#40;&#41;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#x6d;&#97;&#x69;&#x6c;&#x74;&#x6f;&#x3a;&#91;&#99;&#x68;&#101;&#110;&#x67;&#x75;&#x61;&#x6e;&#99;&#x68;&#x2e;&#46;&#x2e;&#64;&#103;&#x6d;&#x61;&#x69;&#108;&#46;&#99;&#x6f;&#x6d;&#93;&#x28;&#41;">&#91;&#99;&#x68;&#101;&#110;&#x67;&#x75;&#x61;&#x6e;&#99;&#x68;&#x2e;&#46;&#x2e;&#64;&#103;&#x6d;&#x61;&#x69;&#108;&#46;&#99;&#x6f;&#x6d;&#93;&#x28;&#41;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#x6d;&#x61;&#105;&#108;&#116;&#x6f;&#x3a;&#x5b;&#112;&#111;&#x6e;&#x2e;&#x2e;&#x2e;&#64;&#103;&#x6f;&#x6f;&#x67;&#108;&#x65;&#103;&#x72;&#x6f;&#x75;&#112;&#115;&#46;&#99;&#x6f;&#109;&#x5d;&#40;&#x29;">&#x5b;&#112;&#111;&#x6e;&#x2e;&#x2e;&#x2e;&#64;&#103;&#x6f;&#x6f;&#x67;&#108;&#x65;&#103;&#x72;&#x6f;&#x75;&#112;&#115;&#46;&#99;&#x6f;&#109;&#x5d;&#40;&#x29;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
</blockquote>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>&gt;</p>
<blockquote>
<blockquote>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。</p>
</li>
</ol>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>--</p>
<p>Tinyfool的开发日记<a href="http://www.tinydust.net/dev/" target="_blank"><a href="http://www.tinydust.net/dev/">http://www.tinydust.net/dev/</a></a>
代码中国网<a href="http://www.codechina.org/" target="_blank"><a href="http://www.codechina.org">http://www.codechina.org</a></a>
myTwitter:<a href="http://twitter.com/tinyfool" target="_blank"><a href="http://twitter.com/tinyfool">http://twitter.com/tinyfool</a></a></p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a></p>
<p><img src="" alt=""> tinyfool <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>热烈支持，哈哈
2010/3/22 Guancheng Chen <a href="&#109;&#x61;&#x69;&#108;&#x74;&#111;&#58;&#x5b;&#99;&#104;&#x65;&#x6e;&#x67;&#x75;&#46;&#46;&#x2e;&#x40;&#103;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#99;&#111;&#109;&#x5d;&#40;&#41;">&#x5b;&#99;&#104;&#x65;&#x6e;&#x67;&#x75;&#46;&#46;&#x2e;&#x40;&#103;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#99;&#111;&#109;&#x5d;&#40;&#41;</a>
我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>On 3月22日, 上午2时20分, Tinyfool <a href="&#109;&#x61;&#x69;&#108;&#x74;&#x6f;&#x3a;&#91;&#x74;&#105;&#110;&#121;&#x66;&#x2e;&#x2e;&#46;&#64;&#103;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#93;&#x28;&#x29;">&#91;&#x74;&#105;&#110;&#121;&#x66;&#x2e;&#x2e;&#46;&#64;&#103;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p><a href="">显示删减掉的内容</a>
<img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>我个人也觉得OpenMP是目前比较好用的并行方式。像您这样设计算法的程序员，是不是基本上也是只对串行算法做优化改进，然后性能瓶颈比较大的部分才
考虑实施并行化？</p>
<p>On 3月22日, 上午7时09分, Changsheng Jiang <a href="&#x6d;&#x61;&#x69;&#108;&#116;&#x6f;&#58;&#x5b;&#x6a;&#105;&#97;&#110;&#x67;&#122;&#x75;&#111;&#46;&#46;&#46;&#x40;&#103;&#109;&#97;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#x29;">&#x5b;&#x6a;&#105;&#97;&#110;&#x67;&#122;&#x75;&#111;&#46;&#46;&#46;&#x40;&#103;&#109;&#97;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>说来惭愧, 接触并行时间不长, 没什么实际经验, 只写过几个并行程序.</p>
<p>感觉 MPI + OpenMP 倒算好用. 简单的单机程序, 用OpenMP并行, 添加几个编译指令就可以. 复杂点的, 用MPI, 也能忍,
只是需要重新设计一下程序和算法.</p>
<p>除了简单的打印, 跟踪一个进程, 不知道怎么调试并行程序. 没有专用平台如NUMA等的编程经验.</p>
<pre><code>                                                 Changsheng Jiang
</code></pre><p>2010/3/22 Guancheng Chen <a href="&#x6d;&#97;&#105;&#x6c;&#116;&#111;&#58;&#x5b;&#x63;&#104;&#x65;&#110;&#x67;&#117;&#x61;&#x6e;&#x63;&#104;&#x2e;&#x2e;&#x2e;&#64;&#103;&#109;&#x61;&#x69;&#108;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#41;">&#x5b;&#x63;&#104;&#x65;&#110;&#x67;&#117;&#x61;&#x6e;&#x63;&#104;&#x2e;&#x2e;&#x2e;&#64;&#103;&#109;&#x61;&#x69;&#108;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#41;</a></p>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>&gt;
&gt;
&gt;</p>
<blockquote>
<blockquote>
<p>不知道您觉得现有的工具哪些个最趁手呢？</p>
<p>On 3月22日, 上午3时19分, Changsheng Jiang <a href="&#x6d;&#x61;&#105;&#108;&#116;&#111;&#58;&#x5b;&#106;&#105;&#97;&#110;&#103;&#x7a;&#117;&#111;&#46;&#46;&#x2e;&#64;&#x67;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#x28;&#41;">&#x5b;&#106;&#105;&#97;&#110;&#103;&#x7a;&#117;&#111;&#46;&#46;&#x2e;&#64;&#x67;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>个人觉得最大障碍在工具上.</p>
<p>并行学术上研究得不少, 主要在算法和模型上. 工程上的工具, 多是自串行程序来设计的, 弄得复杂不堪. 并行需要语言和库两级支持,
Pthreads 和
MPI 仅从库上入手, 让程序员处理各种重复且复杂的分发, 并发锁等. OpenMP好一些, 可惜目前只支持线程并行.</p>
<p>用 ErLang 等将并行设计在语言里的来做并行会容易得多, 得易于面向消息传递的隔离模型, 程序稳定易写. 模型和语言的性能是一个问题,
主要的问题还在用的人和实际并行项目不多.</p>
<p>调试工具就更少了. 有少数商业化的工具.</p>
<p>当然, 我是将可维护性归结为语言工具太差.</p>
<pre><code>                                                 Changsheng Jiang
</code></pre><p>2010/3/22 Guancheng Chen <a href="&#109;&#x61;&#105;&#x6c;&#116;&#111;&#58;&#91;&#99;&#104;&#101;&#x6e;&#x67;&#x75;&#x61;&#110;&#x63;&#x68;&#x2e;&#46;&#x2e;&#x40;&#103;&#x6d;&#x61;&#105;&#108;&#46;&#99;&#111;&#109;&#93;&#40;&#x29;">&#91;&#99;&#104;&#101;&#x6e;&#x67;&#x75;&#x61;&#110;&#x63;&#x68;&#x2e;&#46;&#x2e;&#x40;&#103;&#x6d;&#x61;&#105;&#108;&#46;&#99;&#111;&#109;&#93;&#40;&#x29;</a></p>
<blockquote>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-" target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a></a>.
..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线</p>
</blockquote>
</blockquote>
<p>程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。</p>
<blockquote>
<blockquote>
<p>尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。</p>
</li>
</ol>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
<a href="">显示删减掉的内容</a></p>
</blockquote>
</blockquote>
<p><img src="" alt=""> changsheng <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>说设计算法, 其实, 是实现算法, 找到合适的算法实现了.</p>
<p>五个障碍中的第一条在, 人力有限, 只能并行不并行不行的部分.
                                                     Changsheng Jiang
2010/3/22 Guancheng Chen <a href="&#109;&#97;&#x69;&#108;&#x74;&#111;&#x3a;&#x5b;&#99;&#x68;&#101;&#x6e;&#x67;&#117;&#46;&#46;&#x2e;&#x40;&#x67;&#109;&#97;&#x69;&#x6c;&#46;&#99;&#x6f;&#x6d;&#93;&#x28;&#x29;">&#x5b;&#99;&#x68;&#101;&#x6e;&#x67;&#117;&#46;&#46;&#x2e;&#x40;&#x67;&#109;&#97;&#x69;&#x6c;&#46;&#99;&#x6f;&#x6d;&#93;&#x28;&#x29;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>我个人也觉得OpenMP是目前比较好用的并行方式。像您这样设计算法的程序员，是不是基本上也是只对串行算法做优化改进，然后性能瓶颈比较大的部分才
考虑实施并行化？
On 3月22日, 上午7时09分, Changsheng Jiang <a href="&#x6d;&#97;&#x69;&#x6c;&#x74;&#x6f;&#x3a;&#91;&#106;&#x69;&#x61;&#110;&#103;&#122;&#x75;&#111;&#x2e;&#46;&#46;&#64;&#x67;&#109;&#x61;&#105;&#108;&#x2e;&#99;&#111;&#x6d;&#x5d;&#x28;&#x29;">&#91;&#106;&#x69;&#x61;&#110;&#103;&#122;&#x75;&#111;&#x2e;&#46;&#46;&#64;&#x67;&#109;&#x61;&#105;&#108;&#x2e;&#99;&#111;&#x6d;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>说来惭愧, 接触并行时间不长, 没什么实际经验, 只写过几个并行程序.</p>
<p>感觉 MPI + OpenMP 倒算好用. 简单的单机程序, 用OpenMP并行, 添加几个编译指令就可以. 复杂点的, 用MPI, 也能忍,
只是需要重新设计一下程序和算法.</p>
<p>除了简单的打印, 跟踪一个进程, 不知道怎么调试并行程序. 没有专用平台如NUMA等的编程经验.</p>
<pre><code>                                                 Changsheng Jiang
</code></pre><p>2010/3/22 Guancheng Chen <a href="&#x6d;&#x61;&#105;&#108;&#116;&#x6f;&#58;&#x5b;&#x63;&#x68;&#x65;&#110;&#103;&#117;&#97;&#x6e;&#99;&#x68;&#x2e;&#46;&#46;&#x40;&#x67;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#40;&#x29;">&#x5b;&#x63;&#x68;&#x65;&#110;&#103;&#117;&#97;&#x6e;&#99;&#x68;&#x2e;&#46;&#46;&#x40;&#x67;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#40;&#x29;</a></p>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>&gt;
&gt;
&gt;</p>
<blockquote>
<blockquote>
<p>不知道您觉得现有的工具哪些个最趁手呢？</p>
<p>On 3月22日, 上午3时19分, Changsheng Jiang <a href="&#109;&#97;&#x69;&#x6c;&#116;&#111;&#58;&#x5b;&#106;&#105;&#x61;&#x6e;&#x67;&#x7a;&#x75;&#x6f;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#109;&#97;&#105;&#x6c;&#46;&#99;&#x6f;&#x6d;&#93;&#x28;&#41;">&#x5b;&#106;&#105;&#x61;&#x6e;&#x67;&#x7a;&#x75;&#x6f;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#109;&#97;&#105;&#x6c;&#46;&#99;&#x6f;&#x6d;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>个人觉得最大障碍在工具上.</p>
<p>并行学术上研究得不少, 主要在算法和模型上. 工程上的工具, 多是自串行程序来设计的, 弄得复杂不堪. 并行需要语言和库两级支持,
Pthreads 和
MPI 仅从库上入手, 让程序员处理各种重复且复杂的分发, 并发锁等. OpenMP好一些, 可惜目前只支持线程并行.</p>
<p>用 ErLang 等将并行设计在语言里的来做并行会容易得多, 得易于面向消息传递的隔离模型, 程序稳定易写. 模型和语言的性能是一个问题,
主要的问题还在用的人和实际并行项目不多.</p>
<p>调试工具就更少了. 有少数商业化的工具.</p>
<p>当然, 我是将可维护性归结为语言工具太差.</p>
<pre><code>                                                 Changsheng Jiang
</code></pre><p>2010/3/22 Guancheng Chen <a href="&#109;&#97;&#105;&#x6c;&#x74;&#111;&#x3a;&#91;&#x63;&#x68;&#101;&#x6e;&#x67;&#x75;&#x61;&#x6e;&#99;&#x68;&#46;&#x2e;&#46;&#64;&#x67;&#x6d;&#97;&#105;&#108;&#46;&#x63;&#111;&#109;&#x5d;&#40;&#x29;">&#91;&#x63;&#x68;&#101;&#x6e;&#x67;&#x75;&#x61;&#x6e;&#99;&#x68;&#46;&#x2e;&#46;&#64;&#x67;&#x6d;&#97;&#105;&#108;&#46;&#x63;&#111;&#109;&#x5d;&#40;&#x29;</a></p>
<blockquote>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-" target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a></a>.
..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线</p>
</blockquote>
</blockquote>
<p>程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。</p>
<blockquote>
<blockquote>
<p>尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。</p>
</li>
</ol>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
 To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> Alleluia <img src="" alt=""></p>
</blockquote>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>Parallelism 说到底是算法问题.Parallelism与Concurrency不同,Concurrency所面对的问题相对的单一可以
让一群有经验的专家来实现一套通用库或者语言来提供一个基本的编程框架.而在Parallelism上,具体的不同问题,其所需要并行的算法是根本不同
的.原因在于不同的问题,其内部的DataDependency的结构完全不同,不同的Data Dependency的结构,需要构造不同的算法.即
便是相同的Data Dependency,在不同的颗粒度下，在不同的硬件条件下所采用的算法也是完全不同的.因为一旦出现Data
Dependency也就意味着并行计算模块之间需要进行通信.从以计算节点为单位的分布式并行,到多核CPU上的Numa结构,到SIMD上的向量处
理器,其计算单元之间的通信手段,通信效率简直天差地别.比如说,在SMP上最常见的并行算法,work stealing也就是Intel的TBB,
是建立在两个条件下第一个是CPU的Cache机制上,这使得通常在内存的之间的数据搬运消耗非常小,第二个是SMP上计算单元相对的少,因此每个计算
单元被分配到的任务就相对的重。其开销远远大于通信的开销,因此这种机制在SMP上相对的划算.但是如果你要在GPU上做Work Stealing就
完全不可行,因为GPU的运算单元数量极多,被分配到的任务就相对来说的非常轻量,CUDA上的一个thread很多时候运算一次的时间不会超过
10us,而一次跨Block的线程之间的通信开销就往往要达到100us左右,再加上目前GPU上的Cache机制非常落后导致了需要频繁的通信开销
的Work Stealing在GPU上是非常不划算得.
所以我个人认为在硬件架构没有更多的突破之前,OpenCL这种东西是没有任何生命力的.不要说CPU的并行与GPU之间差异巨大,就是不同的GPU之
间AMD与Nvidia两个也是各自为政,一个平台上跑得非常快的东西,在另外一个平台极大的可能是龟速.其最终的结果估计就是跟Java的
write once run everywhere一样是个大笑话.</p>
<p>On 3月22日, 下午2时06分, Guancheng Chen <a href="&#x6d;&#97;&#x69;&#x6c;&#116;&#111;&#58;&#91;&#99;&#x68;&#101;&#x6e;&#x67;&#117;&#97;&#x6e;&#x63;&#104;&#46;&#x2e;&#46;&#64;&#x67;&#x6d;&#97;&#105;&#108;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#40;&#x29;">&#91;&#99;&#x68;&#101;&#x6e;&#x67;&#117;&#97;&#x6e;&#x63;&#104;&#46;&#x2e;&#46;&#64;&#x67;&#x6d;&#97;&#105;&#108;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>On 3月22日, 上午2时20分, Tinyfool <a href="&#109;&#x61;&#x69;&#108;&#x74;&#x6f;&#58;&#x5b;&#116;&#105;&#110;&#x79;&#x66;&#46;&#46;&#46;&#x40;&#x67;&#109;&#x61;&#105;&#108;&#46;&#x63;&#111;&#x6d;&#93;&#40;&#x29;">&#x5b;&#116;&#105;&#110;&#x79;&#x66;&#46;&#46;&#46;&#x40;&#x67;&#109;&#x61;&#105;&#108;&#46;&#x63;&#111;&#x6d;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#109;&#x61;&#105;&#108;&#116;&#111;&#x3a;&#x5b;&#x6a;&#x65;&#x2e;&#x2e;&#x2e;&#x40;&#108;&#x69;&#118;&#101;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#41;">&#x5b;&#x6a;&#x65;&#x2e;&#x2e;&#x2e;&#x40;&#108;&#x69;&#118;&#101;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#41;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#x6d;&#97;&#105;&#x6c;&#116;&#111;&#x3a;&#x5b;&#x63;&#x68;&#x65;&#110;&#103;&#117;&#97;&#110;&#99;&#104;&#x2e;&#46;&#46;&#x40;&#x67;&#109;&#x61;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#40;&#x29;">&#x5b;&#x63;&#x68;&#x65;&#110;&#103;&#117;&#97;&#110;&#99;&#104;&#x2e;&#46;&#46;&#x40;&#x67;&#109;&#x61;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#40;&#x29;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#109;&#97;&#105;&#x6c;&#x74;&#x6f;&#58;&#91;&#x70;&#111;&#110;&#x2e;&#x2e;&#x2e;&#64;&#103;&#x6f;&#111;&#x67;&#x6c;&#101;&#103;&#x72;&#x6f;&#117;&#x70;&#x73;&#46;&#x63;&#111;&#x6d;&#93;&#x28;&#41;">&#91;&#x70;&#111;&#110;&#x2e;&#x2e;&#x2e;&#64;&#103;&#x6f;&#111;&#x67;&#x6c;&#101;&#103;&#x72;&#x6f;&#117;&#x70;&#x73;&#46;&#x63;&#111;&#x6d;&#93;&#x28;&#41;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
</blockquote>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<blockquote>
<blockquote>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。</p>
</li>
</ol>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>--
Tinyfool的开发日记<a href="http://www.tinydust.net/dev/" target="_blank"><a href="http://www.tinydust.net/dev/">http://www.tinydust.net/dev/</a></a>
代码中国网<a href="http://www.codechina.org/" target="_blank"><a href="http://www.codechina.org">http://www.codechina.org</a></a>
myTwitter:<a href="http://twitter.com/tinyfool" target="_blank"><a href="http://twitter.com/tinyfool">http://twitter.com/tinyfool</a></a>
<a href="">显示删减掉的内容</a></p>
</blockquote>
</blockquote>
<p><img src="" alt=""> Alleluia <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>其实并行计算这个东西,对现有的基于文本内容的程序意义不是很大.因为文本内容的数据量增加是线性的.而相对来说,视频音频的数据就完全不同是按平方甚
至是指数增加的.一个文本长度增加一倍,数据量也就增加一倍.而一张图片,长宽增加一倍,数据量要增加四倍.一个既有的算法在没有大的理论突破的前提
下,在特定的硬件平台上能够优化加速5-6倍已经是了不得了.但是对于多媒体数据来说,这个加速真的不算什么.一个算法在720p上快3,4倍,换到
1080p的也就是达到了720p上不加速的效果而已.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>绝大部分的观点Can&#39;t agree more.其实这也是为什么我引用了高老爷子那段话的原因，因为程序的本质就是数据结构和算法，你要没有非常适
合并行的算法那简直就是巧妇难为无米之炊。但是有疑问的一点是关于Parallelism和Concurrency这两个单词的区别，实际上这也是非常
有意思的一件事情，Sun的多线程指南上写的是： Parallelism is a condition that arises when at
least two threads are executing simultaneously, while concurrency is a
condition that exists when at least two threads are making progress.
Therefore concurrency is a more generalized form of parallelism that
can include time-slicing as a form of virtual parallelism.不知道您怎么看？</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>On 3月22日, 上午8时06分, Alleluia <a href="&#109;&#97;&#x69;&#x6c;&#x74;&#x6f;&#x3a;&#x5b;&#x61;&#x6c;&#108;&#117;&#x6c;&#46;&#x2e;&#x2e;&#x40;&#x67;&#109;&#x61;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#93;&#40;&#41;">&#x5b;&#x61;&#x6c;&#108;&#117;&#x6c;&#46;&#x2e;&#x2e;&#x40;&#x67;&#109;&#x61;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>Parallelism 说到底是算法问题.Parallelism与Concurrency不同,Concurrency所面对的问题相对的单一可以
让一群有经验的专家来实现一套通用库或者语言来提供一个基本的编程框架.而在Parallelism上,具体的不同问题,其所需要并行的算法是根本不同
的.原因在于不同的问题,其内部的DataDependency的结构完全不同,不同的Data Dependency的结构,需要构造不同的算法.即
便是相同的Data Dependency,在不同的颗粒度下，在不同的硬件条件下所采用的算法也是完全不同的.因为一旦出现Data
Dependency也就意味着并行计算模块之间需要进行通信.从以计算节点为单位的分布式并行,到多核CPU上的Numa结构,到SIMD上的向量处
理器,其计算单元之间的通信手段,通信效率简直天差地别.比如说,在SMP上最常见的并行算法,work stealing也就是Intel的TBB,
是建立在两个条件下第一个是CPU的Cache机制上,这使得通常在内存的之间的数据搬运消耗非常小,第二个是SMP上计算单元相对的少,因此每个计算
单元被分配到的任务就相对的重。其开销远远大于通信的开销,因此这种机制在SMP上相对的划算.但是如果你要在GPU上做Work Stealing就
完全不可行,因为GPU的运算单元数量极多,被分配到的任务就相对来说的非常轻量,CUDA上的一个thread很多时候运算一次的时间不会超过
10us,而一次跨Block的线程之间的通信开销就往往要达到100us左右,再加上目前GPU上的Cache机制非常落后导致了需要频繁的通信开销
的Work Stealing在GPU上是非常不划算得.
所以我个人认为在硬件架构没有更多的突破之前,OpenCL这种东西是没有任何生命力的.不要说CPU的并行与GPU之间差异巨大,就是不同的GPU之
间AMD与Nvidia两个也是各自为政,一个平台上跑得非常快的东西,在另外一个平台极大的可能是龟速.其最终的结果估计就是跟Java的
write once run everywhere一样是个大笑话.</p>
<p>On 3月22日, 下午2时06分, Guancheng Chen <a href="&#109;&#97;&#x69;&#108;&#116;&#x6f;&#x3a;&#91;&#x63;&#104;&#x65;&#110;&#103;&#x75;&#x61;&#x6e;&#x63;&#x68;&#46;&#46;&#46;&#64;&#103;&#x6d;&#97;&#x69;&#108;&#46;&#99;&#111;&#109;&#x5d;&#40;&#x29;">&#91;&#x63;&#104;&#x65;&#110;&#103;&#x75;&#x61;&#x6e;&#x63;&#x68;&#46;&#46;&#46;&#64;&#103;&#x6d;&#97;&#x69;&#108;&#46;&#99;&#111;&#109;&#x5d;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>On 3月22日, 上午2时20分, Tinyfool <a href="&#x6d;&#97;&#x69;&#x6c;&#116;&#111;&#x3a;&#x5b;&#x74;&#x69;&#x6e;&#121;&#x66;&#46;&#46;&#x2e;&#64;&#103;&#109;&#x61;&#105;&#108;&#46;&#99;&#x6f;&#x6d;&#93;&#x28;&#x29;">&#x5b;&#x74;&#x69;&#x6e;&#121;&#x66;&#46;&#46;&#x2e;&#64;&#103;&#109;&#x61;&#105;&#108;&#46;&#99;&#x6f;&#x6d;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#x6d;&#97;&#105;&#108;&#116;&#111;&#58;&#x5b;&#x6a;&#x65;&#x2e;&#x2e;&#46;&#64;&#x6c;&#105;&#118;&#101;&#46;&#x63;&#111;&#109;&#93;&#x28;&#x29;">&#x5b;&#x6a;&#x65;&#x2e;&#x2e;&#46;&#64;&#x6c;&#105;&#118;&#101;&#46;&#x63;&#111;&#109;&#93;&#x28;&#x29;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#x6d;&#97;&#105;&#108;&#x74;&#x6f;&#x3a;&#91;&#x63;&#104;&#x65;&#x6e;&#103;&#x75;&#x61;&#110;&#99;&#x68;&#46;&#46;&#x2e;&#x40;&#x67;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#109;&#x5d;&#40;&#41;">&#91;&#x63;&#104;&#x65;&#x6e;&#103;&#x75;&#x61;&#110;&#99;&#x68;&#46;&#46;&#x2e;&#x40;&#x67;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#109;&#x5d;&#40;&#41;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#x6d;&#97;&#105;&#x6c;&#116;&#111;&#x3a;&#91;&#112;&#x6f;&#x6e;&#x2e;&#46;&#x2e;&#64;&#103;&#111;&#111;&#103;&#108;&#x65;&#103;&#114;&#x6f;&#x75;&#x70;&#115;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#x28;&#x29;">&#91;&#112;&#x6f;&#x6e;&#x2e;&#46;&#x2e;&#64;&#103;&#111;&#111;&#103;&#108;&#x65;&#103;&#114;&#x6f;&#x75;&#x70;&#115;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#x28;&#x29;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，...</p>
</blockquote>
</blockquote>
</blockquote>
<p>阅读更多 &gt;&gt;
<a href="">显示删减掉的内容</a></p>
</blockquote>
<p><img src="" alt=""> Alleluia <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>Concurrency 说到底纯粹就是一个IO问题.而IO问题本质上是和计算完全无关的事情,不存在能不能行可不可计算的问题.因此它相对来说非常
单纯。他更多的是一种类似时钟同步的问题,如果你把IO事件想像成一种时钟信号.其实时钟本来也就是一堆信号而已.如果你做过Circuit 的东西就
会明白,IO只是在不同的时序下进行数据采样.比如最简单的同步时钟,所有的时序电路公用一个时钟,把不同的电路安排在不同的时序边沿上触发.当然更复
杂异步逻辑的道理也是一样的.放到宏观的Concurrency的问题的实质并没有多大改变,只不过CPU依靠PC指针的移动把这种电路上的时序处理软
件化了.</p>
<p>而Parallelism更多的是需要考虑计算问题同时还要兼顾IO.Parallelism首先要回答的是一个东西是不是可并行的.回答完这个问题
后,如果可并行那么在什么样的硬件设备上并行是最合适的这样一个问题.在Parallelism中需要考虑的的IO也不仅仅是来自于网络更多是,缓存,
内存,磁盘,总线等等.其实我觉得,在Parallelism下你总是处于一个矛盾状态,颗粒度越小的并行获得的计算资源的利用率也就越大加速比就越
大,但是同时通信系统的工作也就越是繁忙整个运算过程浪费在通信消耗上的时间也就越多.
这个当中的tradeoff是非常困难的.很多时候速度不快,完全不是因为你的核心不够多,而是你的通信速度不够高.</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>On 3月22日, 下午3时21分, Guancheng Chen <a href="&#109;&#x61;&#105;&#x6c;&#x74;&#x6f;&#58;&#91;&#x63;&#x68;&#x65;&#x6e;&#103;&#x75;&#x61;&#x6e;&#x63;&#x68;&#46;&#46;&#46;&#64;&#103;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#99;&#111;&#109;&#93;&#40;&#41;">&#91;&#x63;&#x68;&#x65;&#x6e;&#103;&#x75;&#x61;&#x6e;&#x63;&#x68;&#46;&#46;&#46;&#64;&#103;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#99;&#111;&#109;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>绝大部分的观点Can&#39;t agree more.其实这也是为什么我引用了高老爷子那段话的原因，因为程序的本质就是数据结构和算法，你要没有非常适
合并行的算法那简直就是巧妇难为无米之炊。但是有疑问的一点是关于Parallelism和Concurrency这两个单词的区别，实际上这也是非常
有意思的一件事情，Sun的多线程指南上写的是： Parallelism is a condition that arises when at
least two threads are executing simultaneously, while concurrency is a
condition that exists when at least two threads are making progress.
Therefore concurrency is a more generalized form of parallelism that
can include time-slicing as a form of virtual parallelism.不知道您怎么看？</p>
<p>On 3月22日, 上午8时06分, Alleluia <a href="&#x6d;&#97;&#105;&#108;&#x74;&#x6f;&#58;&#91;&#x61;&#108;&#108;&#x75;&#108;&#46;&#46;&#x2e;&#x40;&#x67;&#x6d;&#97;&#x69;&#108;&#x2e;&#x63;&#111;&#x6d;&#93;&#x28;&#41;">&#91;&#x61;&#108;&#108;&#x75;&#108;&#46;&#46;&#x2e;&#x40;&#x67;&#x6d;&#97;&#x69;&#108;&#x2e;&#x63;&#111;&#x6d;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>Parallelism 说到底是算法问题.Parallelism与Concurrency不同,Concurrency所面对的问题相对的单一可以
让一群有经验的专家来实现一套通用库或者语言来提供一个基本的编程框架.而在Parallelism上,具体的不同问题,其所需要并行的算法是根本不同
的.原因在于不同的问题,其内部的DataDependency的结构完全不同,不同的Data Dependency的结构,需要构造不同的算法.即
便是相同的Data Dependency,在不同的颗粒度下，在不同的硬件条件下所采用的算法也是完全不同的.因为一旦出现Data
Dependency也就意味着并行计算模块之间需要进行通信.从以计算节点为单位的分布式并行,到多核CPU上的Numa结构,到SIMD上的向量处
理器,其计算单元之间的通信手段,通信效率简直天差地别.比如说,在SMP上最常见的并行算法,work stealing也就是Intel的TBB,
是建立在两个条件下第一个是CPU的Cache机制上,这使得通常在内存的之间的数据搬运消耗非常小,第二个是SMP上计算单元相对的少,因此每个计算
单元被分配到的任务就相对的重。其开销远远大于通信的开销,因此这种机制在SMP上相对的划算.但是如果你要在GPU上做Work Stealing就
完全不可行,因为GPU的运算单元数量极多,被分配到的任务就相对来说的非常轻量,CUDA上的一个thread很多时候运算一次的时间不会超过
10us,而一次跨Block的线程之间的通信开销就往往要达到100us左右,再加上目前GPU上的Cache机制非常落后导致了需要频繁的通信开销
的Work Stealing在GPU上是非常不划算得.
所以我个人认为在硬件架构没有更多的突破之前,OpenCL这种东西是没有任何生命力的.不要说CPU的并行与GPU之间差异巨大,就是不同的GPU之
间AMD与Nvidia两个也是各自为政,一个平台上跑得非常快的东西,在另外一个平台极大的可能是龟速.其最终的结果估计就是跟Java的
write once run everywhere一样是个大笑话.</p>
<p>On 3月22日, 下午2时06分, Guancheng Chen <a href="&#x6d;&#x61;&#105;&#108;&#116;&#x6f;&#x3a;&#x5b;&#99;&#104;&#x65;&#x6e;&#x67;&#x75;&#97;&#110;&#99;&#104;&#46;&#46;&#x2e;&#64;&#x67;&#109;&#x61;&#x69;&#108;&#46;&#x63;&#x6f;&#109;&#93;&#40;&#x29;">&#x5b;&#99;&#104;&#x65;&#x6e;&#x67;&#x75;&#97;&#110;&#99;&#104;&#46;&#46;&#x2e;&#64;&#x67;&#109;&#x61;&#x69;&#108;&#46;&#x63;&#x6f;&#109;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>On 3月22日, 上午2时20分, Tinyfool <a href="&#109;&#x61;&#x69;&#108;&#116;&#x6f;&#x3a;&#91;&#x74;&#x69;&#110;&#121;&#x66;&#46;&#46;&#46;&#64;&#103;&#x6d;&#97;&#105;&#108;&#x2e;&#99;&#111;&#x6d;&#93;&#x28;&#x29;">&#91;&#x74;&#x69;&#110;&#121;&#x66;&#46;&#46;&#46;&#64;&#103;&#x6d;&#97;&#105;&#108;&#x2e;&#99;&#111;&#x6d;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#111;&#58;&#91;&#x6a;&#x65;&#46;&#46;&#x2e;&#64;&#x6c;&#105;&#x76;&#x65;&#46;&#99;&#x6f;&#109;&#x5d;&#40;&#41;">&#91;&#x6a;&#x65;&#46;&#46;&#x2e;&#64;&#x6c;&#105;&#x76;&#x65;&#46;&#99;&#x6f;&#109;&#x5d;&#40;&#41;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#109;&#x61;&#105;&#108;&#x74;&#111;&#58;&#x5b;&#x63;&#104;&#x65;&#110;&#x67;&#117;&#x61;&#x6e;&#99;&#x68;&#46;&#46;&#46;&#x40;&#x67;&#x6d;&#97;&#x69;&#108;&#x2e;&#99;&#111;&#109;&#x5d;&#40;&#41;">&#x5b;&#x63;&#104;&#x65;&#110;&#x67;&#117;&#x61;&#x6e;&#99;&#x68;&#46;&#46;&#46;&#x40;&#x67;&#x6d;&#97;&#x69;&#108;&#x2e;&#99;&#111;&#109;&#x5d;&#40;&#41;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#109;&#97;&#105;&#108;&#116;&#x6f;&#x3a;&#91;&#x70;&#x6f;&#110;&#x2e;&#46;&#46;&#x40;&#x67;&#111;&#111;&#103;&#108;&#x65;&#x67;&#x72;&#x6f;&#117;&#112;&#x73;&#46;&#99;&#x6f;&#x6d;&#93;&#40;&#x29;">&#91;&#x70;&#x6f;&#110;&#x2e;&#46;&#46;&#x40;&#x67;&#111;&#111;&#103;&#108;&#x65;&#x67;&#x72;&#x6f;&#117;&#112;&#x73;&#46;&#99;&#x6f;&#x6d;&#93;&#40;&#x29;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>...</p>
<p>阅读更多 &gt;&gt;
<a href="">显示删减掉的内容</a>
<img src="" alt=""> Alleluia <img src="" alt=""></p>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>Microsoft Accelerator稍稍看了一下这个东西,是05年的工作.这个东西其实已经不新鲜了.大概跟PyCUDA
array-processing operations such as those which frequently arise in
domains.
但是我要说的是,这个领域相对于真正需要的并行计算实在是太少太少.比如说他强调的 image processing and
scientific computing,当中很多非线性滤波的并行算法就不能用这个架构来做.</p>
<p>On 3月22日, 上午9时42分, &quot;Jeffrey Zhao&quot; <a href="&#109;&#x61;&#x69;&#x6c;&#116;&#111;&#x3a;&#91;&#106;&#x65;&#46;&#46;&#x2e;&#64;&#108;&#x69;&#x76;&#x65;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#x28;&#41;">&#91;&#106;&#x65;&#46;&#46;&#x2e;&#64;&#108;&#x69;&#x76;&#x65;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>哈哈，广告好，扩展视野，那我继续做广告了......</p>
<p>微软其实很早就在搞Microsoft Accelerator项目，旨在利用DirectX进行计算，.NET项目。<a href="http://research.microsoft.com/en-us/projects/Accelerator/" target="_blank"><a href="http://research.microsoft.com/en-us/projects/Accelerator/">http://research.microsoft.com/en-us/projects/Accelerator/</a></a></p>
<p>然后F/#这边由于语言的支持良好，可以设计出丰富的表达式、DSL等Modeling Language，再由框架进行自动并行，解决问题可以很容易（已经2.0了）。</p>
<p>这篇文章是个简单介绍：<a href="http://strangelights.com/blog/archive/2008/09/21/1628.aspx" target="_blank"><a href="http://strangelights.com/blog/archive/2008/09/21/1628.aspx">http://strangelights.com/blog/archive/2008/09/21/1628.aspx</a></a></p>
<p>Microsoft Solver Foundation<a href="http://[code.msdn.microsoft.com/solverfoundation](http://code.msdn.microsoft.com/solverfoundation" target="_blank">http://[code.msdn.microsoft.com/solverfoundation](http://code.msdn.microsoft.com/solverfoundation</a>)</p>
<p>F/# Optimization Modeling Language Utilizing Microsoft Solver Foundation<a href="http://[code.msdn.microsoft.com/solverfoundationfs1](http://code.msdn.microsoft.com/solverfoundationfs1" target="_blank">http://[code.msdn.microsoft.com/solverfoundationfs1](http://code.msdn.microsoft.com/solverfoundationfs1</a>)</p>
<p>现在就等OpenCL如果有标准出来，肯定立马可以跟上个类库，哦耶。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p>From: Tinyfool
Sent: Monday, March 22, 2010 9:20 AM
To: <a href="">pon...@googlegroups.com</a>
Subject: Re: [TL] {技术}{多线程}实施并行编程的五大障碍</p>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#x6d;&#97;&#105;&#x6c;&#x74;&#111;&#58;&#x5b;&#106;&#x65;&#46;&#x2e;&#x2e;&#64;&#x6c;&#x69;&#x76;&#x65;&#x2e;&#99;&#x6f;&#109;&#93;&#40;&#41;">&#x5b;&#106;&#x65;&#46;&#x2e;&#x2e;&#64;&#x6c;&#x69;&#x76;&#x65;&#x2e;&#99;&#x6f;&#109;&#93;&#40;&#41;</a></p>
<p>  我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>  其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>  例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>  至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>  例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>  Jeffrey Zhao
  Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
  Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p>  From: Guancheng Chen
  Sent: Monday, March 22, 2010 7:37 AM
  To: TopLanguage
  Subject: [TL] {技术}{多线程}实施并行编程的五大障碍</p>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>&gt;</p>
<blockquote>
<p>  近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
  碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
  (fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
  Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
  的看法。</p>
<p>  ( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看
 <a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
  )</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
</li>
<li><p>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</p>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，</p>
<p>Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
</li>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
...</p>
</li>
</ol>
<p>阅读更多 &gt;&gt;
<a href="">显示删减掉的内容</a></p>
</blockquote>
<p><img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>您的观点很有新意，我以前没有过用IO来区分Concurrency和Parallelism的想法，我猜测可能跟您的网络/通信背景有关。其实我觉得
从广义上来讲Parallelism和Concurrency是基本重合的两个概念，只不过可能Concurrency稍微偏工程一点，
Parallelism稍微偏研究一点。例如Herb Sutter要出的新书叫Effective Concurrency,而市面上其他讲并行计算
的书不少也使用Parallel相关的词汇。</p>
<p>另外您这句话我有些不赞同：&quot;颗粒度越小的并行获得的计算资源的利用率也就越大加速比就越大&quot;，拿一个计算密集型的嵌套循环举例，对比并行外层循环和并
行内层循环，无疑你在并行化外层循环时的性能加速比更好，而这时候你的并行度是粗粒度的(内循环并行相对来说是细粒度的)。当然，粗/细粒度的选择确实
是个tradeoff，拿锁竞争来说，细粒度的锁意味着更好的Scalability，但是你加锁/解锁的次数相比组粒度所来说增加了，而这种加锁/解
锁的操作是有开销的，所以需要在锁操作本身的开销和程序的Scalability中做一个平衡。</p>
<p>多谢指教！</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>On 3月22日, 上午10时19分, Alleluia <a href="&#x6d;&#97;&#x69;&#108;&#116;&#x6f;&#x3a;&#x5b;&#x61;&#x6c;&#108;&#x75;&#108;&#46;&#46;&#x2e;&#x40;&#x67;&#109;&#97;&#x69;&#x6c;&#46;&#x63;&#x6f;&#109;&#x5d;&#40;&#41;">&#x5b;&#x61;&#x6c;&#108;&#x75;&#108;&#46;&#46;&#x2e;&#x40;&#x67;&#109;&#97;&#x69;&#x6c;&#46;&#x63;&#x6f;&#109;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>Concurrency 说到底纯粹就是一个IO问题.而IO问题本质上是和计算完全无关的事情,不存在能不能行可不可计算的问题.因此它相对来说非常
单纯。他更多的是一种类似时钟同步的问题,如果你把IO事件想像成一种时钟信号.其实时钟本来也就是一堆信号而已.如果你做过Circuit 的东西就
会明白,IO只是在不同的时序下进行数据采样.比如最简单的同步时钟,所有的时序电路公用一个时钟,把不同的电路安排在不同的时序边沿上触发.当然更复
杂异步逻辑的道理也是一样的.放到宏观的Concurrency的问题的实质并没有多大改变,只不过CPU依靠PC指针的移动把这种电路上的时序处理软
件化了.</p>
<p>而Parallelism更多的是需要考虑计算问题同时还要兼顾IO.Parallelism首先要回答的是一个东西是不是可并行的.回答完这个问题
后,如果可并行那么在什么样的硬件设备上并行是最合适的这样一个问题.在Parallelism中需要考虑的的IO也不仅仅是来自于网络更多是,缓存,
内存,磁盘,总线等等.其实我觉得,在Parallelism下你总是处于一个矛盾状态,颗粒度越小的并行获得的计算资源的利用率也就越大加速比就越
大,但是同时通信系统的工作也就越是繁忙整个运算过程浪费在通信消耗上的时间也就越多.
这个当中的tradeoff是非常困难的.很多时候速度不快,完全不是因为你的核心不够多,而是你的通信速度不够高.</p>
<p>On 3月22日, 下午3时21分, Guancheng Chen <a href="&#x6d;&#x61;&#105;&#x6c;&#x74;&#111;&#58;&#x5b;&#x63;&#x68;&#101;&#110;&#103;&#x75;&#97;&#110;&#99;&#x68;&#46;&#x2e;&#46;&#64;&#103;&#x6d;&#97;&#105;&#108;&#46;&#99;&#111;&#109;&#x5d;&#40;&#x29;">&#x5b;&#x63;&#x68;&#101;&#110;&#103;&#x75;&#97;&#110;&#99;&#x68;&#46;&#x2e;&#46;&#64;&#103;&#x6d;&#97;&#105;&#108;&#46;&#99;&#111;&#109;&#x5d;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>绝大部分的观点Can&#39;t agree more.其实这也是为什么我引用了高老爷子那段话的原因，因为程序的本质就是数据结构和算法，你要没有非常适
合并行的算法那简直就是巧妇难为无米之炊。但是有疑问的一点是关于Parallelism和Concurrency这两个单词的区别，实际上这也是非常
有意思的一件事情，Sun的多线程指南上写的是： Parallelism is a condition that arises when at
least two threads are executing simultaneously, while concurrency is a
condition that exists when at least two threads are making progress.
Therefore concurrency is a more generalized form of parallelism that
can include time-slicing as a form of virtual parallelism.不知道您怎么看？</p>
<p>On 3月22日, 上午8时06分, Alleluia <a href="&#109;&#x61;&#x69;&#108;&#116;&#111;&#x3a;&#x5b;&#97;&#x6c;&#x6c;&#117;&#x6c;&#46;&#46;&#46;&#x40;&#x67;&#109;&#x61;&#105;&#108;&#x2e;&#99;&#111;&#x6d;&#93;&#40;&#x29;">&#x5b;&#97;&#x6c;&#x6c;&#117;&#x6c;&#46;&#46;&#46;&#x40;&#x67;&#109;&#x61;&#105;&#108;&#x2e;&#99;&#111;&#x6d;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>Parallelism 说到底是算法问题.Parallelism与Concurrency不同,Concurrency所面对的问题相对的单一可以
让一群有经验的专家来实现一套通用库或者语言来提供一个基本的编程框架.而在Parallelism上,具体的不同问题,其所需要并行的算法是根本不同
的.原因在于不同的问题,其内部的DataDependency的结构完全不同,不同的Data Dependency的结构,需要构造不同的算法.即
便是相同的Data Dependency,在不同的颗粒度下，在不同的硬件条件下所采用的算法也是完全不同的.因为一旦出现Data
Dependency也就意味着并行计算模块之间需要进行通信.从以计算节点为单位的分布式并行,到多核CPU上的Numa结构,到SIMD上的向量处
理器,其计算单元之间的通信手段,通信效率简直天差地别.比如说,在SMP上最常见的并行算法,work stealing也就是Intel的TBB,
是建立在两个条件下第一个是CPU的Cache机制上,这使得通常在内存的之间的数据搬运消耗非常小,第二个是SMP上计算单元相对的少,因此每个计算
单元被分配到的任务就相对的重。其开销远远大于通信的开销,因此这种机制在SMP上相对的划算.但是如果你要在GPU上做Work Stealing就
完全不可行,因为GPU的运算单元数量极多,被分配到的任务就相对来说的非常轻量,CUDA上的一个thread很多时候运算一次的时间不会超过
10us,而一次跨Block的线程之间的通信开销就往往要达到100us左右,再加上目前GPU上的Cache机制非常落后导致了需要频繁的通信开销
的Work Stealing在GPU上是非常不划算得.
所以我个人认为在硬件架构没有更多的突破之前,OpenCL这种东西是没有任何生命力的.不要说CPU的并行与GPU之间差异巨大,就是不同的GPU之
间AMD与Nvidia两个也是各自为政,一个平台上跑得非常快的东西,在另外一个平台极大的可能是龟速.其最终的结果估计就是跟Java的
write once run everywhere一样是个大笑话.</p>
<p>On 3月22日, 下午2时06分, Guancheng Chen <a href="&#109;&#x61;&#x69;&#x6c;&#x74;&#x6f;&#x3a;&#91;&#x63;&#x68;&#x65;&#x6e;&#x67;&#x75;&#97;&#110;&#x63;&#x68;&#x2e;&#x2e;&#46;&#64;&#103;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#40;&#x29;">&#91;&#x63;&#x68;&#x65;&#x6e;&#x67;&#x75;&#97;&#110;&#x63;&#x68;&#x2e;&#x2e;&#46;&#64;&#103;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>On 3月22日, 上午2时20分, Tinyfool <a href="&#109;&#x61;&#x69;&#x6c;&#x74;&#111;&#58;&#x5b;&#116;&#x69;&#x6e;&#x79;&#x66;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#109;&#x61;&#x69;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#x29;">&#x5b;&#116;&#x69;&#x6e;&#x79;&#x66;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#109;&#x61;&#x69;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#109;&#97;&#x69;&#x6c;&#116;&#x6f;&#x3a;&#91;&#x6a;&#x65;&#x2e;&#x2e;&#46;&#x40;&#x6c;&#x69;&#x76;&#x65;&#46;&#x63;&#111;&#x6d;&#x5d;&#x28;&#41;">&#91;&#x6a;&#x65;&#x2e;&#x2e;&#46;&#x40;&#x6c;&#x69;&#x76;&#x65;&#46;&#x63;&#111;&#x6d;&#x5d;&#x28;&#41;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#109;&#x61;&#105;&#108;&#116;&#x6f;&#58;&#91;&#99;&#x68;&#101;&#110;&#x67;&#x75;&#x61;&#110;&#99;&#104;&#x2e;&#46;&#46;&#x40;&#x67;&#109;&#97;&#x69;&#108;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#40;&#x29;">&#91;&#99;&#x68;&#101;&#110;&#x67;&#x75;&#x61;&#110;&#99;&#104;&#x2e;&#46;&#46;&#x40;&#x67;&#109;&#97;&#x69;&#108;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#40;&#x29;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#x6d;&#x61;&#105;&#108;&#116;&#111;&#x3a;&#x5b;&#x70;&#x6f;&#110;&#x2e;&#46;&#46;&#64;&#x67;&#x6f;&#x6f;&#x67;&#x6c;&#101;&#103;&#x72;&#x6f;&#117;&#112;&#115;&#46;&#99;&#x6f;&#109;&#93;&#x28;&#41;">&#x5b;&#x70;&#x6f;&#110;&#x2e;&#46;&#46;&#64;&#x67;&#x6f;&#x6f;&#x67;&#x6c;&#101;&#103;&#x72;&#x6f;&#117;&#112;&#115;&#46;&#99;&#x6f;&#109;&#93;&#x28;&#41;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也...</p>
</li>
</ol>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>阅读更多 &gt;&gt;
<a href="">显示删减掉的内容</a>
<img src="" alt=""> Googol Lee <img src="" alt=""></p>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>彻底来晚了......我是来广告golang的！大并发IO还是csp模型的语言更靠谱！</p>
<p>不过golang在cpu密集的并发上不知道效果会怎么样，就现在的表现来看比erlang好，但还赶不上c/c++</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>On Mar 22, 9:20 am, Tinyfool <a href="&#x6d;&#x61;&#x69;&#108;&#116;&#x6f;&#58;&#x5b;&#116;&#105;&#110;&#x79;&#x66;&#x2e;&#46;&#46;&#x40;&#x67;&#x6d;&#x61;&#x69;&#108;&#46;&#99;&#x6f;&#109;&#x5d;&#x28;&#41;">&#x5b;&#116;&#105;&#110;&#x79;&#x66;&#x2e;&#46;&#46;&#x40;&#x67;&#x6d;&#x61;&#x69;&#108;&#46;&#99;&#x6f;&#109;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#x6d;&#x61;&#105;&#108;&#x74;&#x6f;&#x3a;&#91;&#x6a;&#x65;&#46;&#46;&#46;&#x40;&#108;&#x69;&#118;&#x65;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#x28;&#41;">&#91;&#x6a;&#x65;&#46;&#46;&#46;&#x40;&#108;&#x69;&#118;&#x65;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#x28;&#41;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#109;&#97;&#105;&#x6c;&#116;&#x6f;&#58;&#91;&#x63;&#x68;&#x65;&#110;&#103;&#x75;&#x61;&#110;&#99;&#104;&#x2e;&#46;&#x2e;&#x40;&#103;&#109;&#97;&#105;&#108;&#x2e;&#x63;&#111;&#109;&#93;&#40;&#x29;">&#91;&#x63;&#x68;&#x65;&#110;&#103;&#x75;&#x61;&#110;&#99;&#104;&#x2e;&#46;&#x2e;&#x40;&#103;&#109;&#97;&#105;&#108;&#x2e;&#x63;&#111;&#109;&#93;&#40;&#x29;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#109;&#97;&#x69;&#108;&#x74;&#111;&#58;&#x5b;&#x70;&#111;&#110;&#46;&#46;&#x2e;&#x40;&#x67;&#111;&#x6f;&#x67;&#108;&#101;&#103;&#x72;&#x6f;&#x75;&#112;&#115;&#46;&#99;&#111;&#x6d;&#x5d;&#x28;&#41;">&#x5b;&#x70;&#111;&#110;&#46;&#46;&#x2e;&#x40;&#x67;&#111;&#x6f;&#x67;&#108;&#101;&#103;&#x72;&#x6f;&#x75;&#112;&#115;&#46;&#99;&#111;&#x6d;&#x5d;&#x28;&#41;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄</p>
</li>
</ol>
</blockquote>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<blockquote>
<blockquote>
<p>了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。</p>
</li>
</ol>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>--
Tinyfool的开发日记<a href="http://www.tinydust.net/dev/" target="_blank"><a href="http://www.tinydust.net/dev/">http://www.tinydust.net/dev/</a></a>
代码中国网<a href="http://www.codechina.org/" target="_blank"><a href="http://www.codechina.org">http://www.codechina.org</a></a>
myTwitter:<a href="http://twitter.com/tinyfool" target="_blank"><a href="http://twitter.com/tinyfool">http://twitter.com/tinyfool</a></a>
<a href="">显示删减掉的内容</a></p>
</blockquote>
<p><img src="" alt=""> Jeffrey Zhao <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>锟斤拷锟斤拷锟斤拷F/#锟斤拷锟斤拷锟斤拷锟斤拷锟揭伙拷锟斤拷锟斤拷诺姆锟绞斤拷锟绞碉拷锟紺SP锟侥★拷</p>
<p>锟斤拷锟斤拷锟斤拷锟斤拷锟节达拷锟斤拷院锟节诧拷锟斤拷锟斤拷锟斤拷锟较斤拷锟斤拷F/#锟狡广，锟斤拷锟斤拷锟斤拷</p>
<p>Jeffrey Zhao
Blog: <a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter: @jeffz_cn</p>
<hr>
<p>From: &quot;Googol Lee&quot; <a href="&#109;&#x61;&#105;&#108;&#116;&#111;&#x3a;&#91;&#x67;&#x6f;&#x6f;&#x67;&#46;&#x2e;&#x2e;&#x40;&#103;&#109;&#x61;&#x69;&#108;&#x2e;&#99;&#x6f;&#x6d;&#93;&#x28;&#41;">&#91;&#x67;&#x6f;&#x6f;&#x67;&#46;&#x2e;&#x2e;&#x40;&#103;&#109;&#x61;&#x69;&#108;&#x2e;&#99;&#x6f;&#x6d;&#93;&#x28;&#41;</a>
Sent: Monday, March 22, 2010 8:30 PM
To: &quot;TopLanguage&quot; <a href="&#109;&#x61;&#105;&#108;&#116;&#111;&#58;&#91;&#112;&#111;&#x6e;&#x2e;&#46;&#x2e;&#x40;&#x67;&#x6f;&#x6f;&#x67;&#108;&#x65;&#x67;&#114;&#111;&#x75;&#112;&#x73;&#x2e;&#99;&#x6f;&#109;&#93;&#40;&#41;">&#91;&#112;&#111;&#x6e;&#x2e;&#46;&#x2e;&#x40;&#x67;&#x6f;&#x6f;&#x67;&#108;&#x65;&#x67;&#114;&#111;&#x75;&#112;&#x73;&#x2e;&#99;&#x6f;&#109;&#93;&#40;&#41;</a>
Subject: [TL] Re: {锟斤拷锟斤拷}{锟斤拷锟竭筹拷}实施锟斤拷锟叫憋拷痰锟斤拷锟斤拷锟较帮拷</p>
<blockquote>
<p>锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷......锟斤拷锟斤拷锟斤拷锟斤拷锟絞olang锟侥ｏ拷锟襟并凤拷IO锟斤拷锟斤拷csp模锟酵碉拷锟斤拷锟皆革拷锟阶ｏ拷</p>
<p>锟斤拷锟斤拷golang锟斤拷cpu锟杰硷拷锟侥诧拷锟斤拷锟较诧拷知锟斤拷效锟斤拷锟斤拷锟矫达拷锟斤拷锟斤拷锟节的憋拷锟斤拷锟斤拷锟斤拷锟斤拷erlang锟矫ｏ拷锟斤拷锟斤拷锟较诧拷锟斤拷c/c++</p>
<p>On Mar 22, 9:20 am, Tinyfool <a href="&#x6d;&#97;&#105;&#x6c;&#x74;&#111;&#x3a;&#91;&#116;&#x69;&#110;&#121;&#102;&#46;&#46;&#46;&#64;&#103;&#109;&#x61;&#105;&#108;&#46;&#99;&#111;&#x6d;&#x5d;&#40;&#41;">&#91;&#116;&#x69;&#110;&#121;&#102;&#46;&#46;&#46;&#64;&#103;&#109;&#x61;&#105;&#108;&#46;&#99;&#111;&#x6d;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷模锟斤拷锟饺伙拷越锟斤拷冒锟斤拷锟斤拷锟剿ｏ拷锟斤拷也锟斤拷锟斤拷锟揭伙拷锟�</p>
<p>Mac OS X锟斤拷锟铰的诧拷锟叫伙拷锟狡斤拷锟斤拷GCD锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟街撅拷知锟斤拷锟睫憋拷强锟斤拷锟剿吧ｏ拷</p>
<p>锟斤拷锟斤拷支锟斤拷锟皆匡拷锟斤拷锟斤拷锟絆penCL也锟斤拷锟睫憋拷强锟襟啊★拷</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#109;&#x61;&#105;&#x6c;&#116;&#x6f;&#x3a;&#x5b;&#x6a;&#x65;&#46;&#x2e;&#46;&#64;&#x6c;&#x69;&#x76;&#101;&#46;&#x63;&#111;&#109;&#x5d;&#x28;&#41;">&#x5b;&#x6a;&#x65;&#46;&#x2e;&#46;&#64;&#x6c;&#x69;&#x76;&#101;&#46;&#x63;&#111;&#109;&#x5d;&#x28;&#41;</a></p>
<blockquote>
<p> 锟斤拷锟斤拷锟斤拷锟斤拷妫猴拷锟斤拷瞬锟斤拷锌狻拷锟斤拷锟紽/#锟斤拷锟斤拷锟斤拷锟皆碉拷支锟街ｏ拷锟斤拷锟叫憋拷锟斤拷丫锟斤拷锟斤拷缀芏锟斤拷恕锟斤拷锟斤拷锟叫э拷剩锟街达拷锟叫э拷剩锟斤拷锟轿拷锟斤拷远锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟竭★拷</p>
<p>锟斤拷实锟斤拷锟斤拷&quot;锟斤拷锟斤拷&quot;锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷茫锟街灰拷锟脚ｏ拷税锟斤拷锟斤拷壮锟斤拷锟斤拷锟侥讹拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷装锟斤拷锟斤拷锟斤拷锟斤拷一锟斤拷锟斤拷锟矫的筹拷锟襟，对大部分筹拷锟斤拷员锟斤拷说锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷唷�</p>
<p>锟斤拷锟斤拷Memory Consistency锟斤拷锟斤拷JVM锟斤拷CLR锟斤拷锟斤拷锟节革拷CPU锟杰癸拷锟斤拷统一锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷没锟叫诧拷锟叫匡拷锟街э拷郑锟叫达拷锟斤拷谐锟斤拷锟斤拷丫锟斤拷锟斤拷锟斤拷锟斤拷珊芏锟斤拷恕锟�</p>
<p>锟斤拷锟节斤拷锟斤拷锟斤拷......锟揭撅拷锟斤拷锟斤拷实锟斤拷锟斤拷锟斤拷獾癸拷锟斤拷遣锟斤拷锟斤拷锟斤拷械模锟揭诧拷锟斤拷遣锟斤拷锟斤拷锟斤拷锟斤拷锟街的革拷祝锟斤拷锟斤拷牵锟斤拷锟斤拷冢锟斤拷锟斤拷锟斤拷锟矫伙拷锟斤拷锟斤拷吮锟斤拷锟斤拷锟矫★拷</p>
<p>锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷系锟结构锟斤拷锟斤拷锟斤拷系统锟饺等★拷锟斤拷锟斤拷然锟酵诧拷锟斤拷锟叫关ｏ拷锟斤拷也锟斤拷锟角诧拷锟斤拷锟斤拷锟叫的讹拷锟斤拷锟斤拷</p>
</blockquote>
</blockquote>
<p>&gt;</p>
<blockquote>
<blockquote>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#109;&#x61;&#105;&#108;&#116;&#x6f;&#x3a;&#91;&#99;&#x68;&#x65;&#x6e;&#x67;&#x75;&#x61;&#110;&#99;&#x68;&#x2e;&#46;&#46;&#x40;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#109;&#93;&#40;&#x29;">&#91;&#99;&#x68;&#x65;&#x6e;&#x67;&#x75;&#x61;&#110;&#99;&#x68;&#x2e;&#46;&#46;&#x40;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#109;&#93;&#40;&#x29;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#x6d;&#97;&#x69;&#x6c;&#x74;&#x6f;&#x3a;&#x5b;&#112;&#x6f;&#110;&#46;&#x2e;&#46;&#x40;&#x67;&#111;&#x6f;&#103;&#108;&#101;&#x67;&#x72;&#111;&#x75;&#x70;&#x73;&#x2e;&#x63;&#x6f;&#109;&#93;&#40;&#41;">&#x5b;&#112;&#x6f;&#110;&#46;&#x2e;&#46;&#x40;&#x67;&#111;&#x6f;&#103;&#108;&#101;&#x67;&#x72;&#111;&#x75;&#x70;&#x73;&#x2e;&#x63;&#x6f;&#109;&#93;&#40;&#41;</a>
/<em>Subject:/</em> [TL] {锟斤拷锟斤拷}{锟斤拷锟竭筹拷}实施锟斤拷锟叫憋拷痰锟斤拷锟斤拷锟较帮拷</p>
<p>锟斤拷锟节匡拷锟斤拷一篇锟斤拷锟斤拷Intel锟侥猴拷锟斤拷锟斤拷思锟侥凤拷锟斤拷锟斤拷锟铰ｏ拷锟斤拷锟斤拷锟结到锟斤拷锟斤拷锟斤拷45锟斤拷锟斤拷锟侥革拷锟斤拷司锟斤拷锟斤拷员/锟斤拷锟斤拷锟斤拷锟斤拷/战锟斤拷师锟斤拷锟斤拷&quot;什么锟斤拷实施锟斤拷锟叫憋拷痰锟斤拷锟斤拷锟斤拷
锟斤拷&quot;时锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷乇锟斤拷峒帮拷拇锟斤拷锟斤拷锟洁：锟斤拷锟斤拷锟斤拷锟斤拷(legacy code)锟斤拷锟斤拷锟斤拷(education)锟斤拷锟斤拷锟斤拷(tools)锟斤拷锟斤拷锟节猴拷锟斤拷锟狡的恐撅拷
(fear of many cores)锟皆硷拷锟斤拷维锟斤拷锟斤拷(maintainability)锟斤拷锟斤拷锟斤拷锟斤拷然锟斤拷一篇Intel
Parallel
Studio锟斤拷锟斤拷锟侥ｏ拷锟斤拷锟斤拷锟斤拷锟斤拷锟结及锟斤拷锟斤拷锟斤拷锟斤拷习锟饺达拷浅锟街碉拷锟斤拷锟斤拷郏锟斤拷锟斤拷锟斤拷锟斤拷叶锟斤拷锟斤拷锟斤拷锟较帮拷锟斤拷一些锟斤拷浅锟斤拷锟斤拷锟斤拷希锟斤拷锟斤拷锟斤拷一锟斤拷锟斤拷砖锟斤拷锟斤拷锟斤拷锟斤拷茫锟斤拷锟接拷锟揭革拷锟斤拷锟斤拷锟�
锟侥匡拷锟斤拷锟斤拷</p>
<p>( 注锟斤拷锟斤拷锟斤拷Google Group锟斤拷锟斤拷原锟侥碉拷一些锟斤拷锟斤拷锟接讹拷失效锟剿ｏ拷锟斤拷锟斤拷锟斤拷懈锟矫碉拷锟侥讹拷锟斤拷锟介，锟诫看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>锟斤拷锟斤拷锟斤拷锟斤拷
锟斤拷锟斤拷锟斤拷知锟斤拷锟斤拷锟叫伙拷实施锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷压锟剿撅拷锟斤拷锟叫╋拷锟斤拷锟斤拷锟斤拷锟斤拷锟叫伙拷锟斤拷100K~1000K锟侥达拷锟斤拷锟斤拷锟斤拷锟角筹拷锟斤拷锟斤拷斜锟教憋拷锟斤拷锟斤拷锟角非筹拷锟斤拷锟阶筹拷锟斤拷模锟�
一锟斤拷锟斤拷锟斤拷锟絛ata race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe锟饺碉拷锟斤拷锟斤拷锟斤拷锟斤拷锟揭伙拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟酵凤拷螅锟斤拷说要锟斤拷
效锟缴匡拷锟侥诧拷锟叫伙拷锟斤拷些锟接达拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷恕锟斤拷锟斤拷锟斤拷训锟斤拷呛芏锟斤拷锟斤拷锟斤拷锟斤拷牖癸拷斜锟叫达拷锟斤拷丫锟斤拷锟街帮拷锟斤拷牡锟阶拷筒锟饺拷锟斤拷锟斤拷猓拷锟斤拷锟斤拷锟斤拷锟窖╋拷霞锟剿拷锟斤拷映杀锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷通锟斤拷一
些锟斤拷锟斤拷谋锟斤拷锟斤拷锟�(锟斤拷锟斤拷Intel锟斤拷ICC)锟皆讹拷锟斤拷锟叫伙拷一些锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷省钱锟侥ｏ拷锟斤拷锟斤拷锟斤拷锟街凤拷锟斤拷锟斤拷锟斤拷缺锟捷撅拷锟斤拷锟斤拷锟斤拷Intel ICC锟斤拷锟斤拷锟皆讹拷锟酵憋拷锟斤拷锟斤拷
锟斤拷锟皆讹拷锟斤拷锟叫伙拷锟侥达拷锟斤拷浅锟斤拷伲锟斤拷佣锟斤拷锟斤拷锟斤拷锟斤拷峁╋拷锟斤拷锟斤拷锟斤拷呕锟斤拷浅锟斤拷锟斤拷蓿锟斤拷锟斤拷揖锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷芑锟斤拷speedup锟侥达拷锟斤拷也锟叫很讹拷约锟斤拷锟斤拷锟斤拷(锟斤拷锟斤拷loop锟斤拷循锟斤拷之锟斤拷
没锟斤拷dependence锟斤拷锟斤拷锟揭革拷loop应锟斤拷锟斤拷一锟斤拷锟斤拷锟斤拷锟饺碉拷)锟斤拷锟斤拷锟斤拷目前锟斤拷锟斤拷状锟斤拷锟角达拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟诫并锟斤拷锟斤拷锟斤拷效锟侥憋拷锟斤拷锟叫伙拷锟斤拷锟斤拷锟斤拷业锟侥角讹拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟�
锟斤拷一锟街斤拷锟斤拷锟斤拷锟斤拷锟斤拷诙锟绞憋拷锟斤拷诳锟斤拷倏煽锟斤拷锟酵拷锟绞凳╋拷锟斤拷谢锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟�%~30%锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷么锟斤拷锟斤拷丫锟斤拷锟轿拷锟剿撅拷锟绞★拷锟斤拷锟斤拷杀锟斤拷恕锟�</p>
</li>
<li><p>锟斤拷锟斤拷
锟节讹拷锟斤拷锟斤拷习锟斤拷锟斤拷芫锟斤拷浅锟斤拷锟皆比憋拷锟斤拷锟斤拷斜锟教凤拷锟斤拷慕锟斤拷锟斤拷恕锟斤拷锟绞碉拷锟斤拷斜锟斤拷锟窖撅拷锟叫讹拷锟斤拷十锟斤拷锟斤拷锟绞凤拷耍锟斤拷锟斤拷锟斤拷诙锟斤拷CPU锟斤拷锟斤拷之前锟斤拷些锟斤拷锟叫憋拷潭锟斤拷锟�&quot;专锟斤拷&quot;锟角碉拷锟斤拷
锟竭★拷锟斤拷时锟斤拷牟锟斤拷斜锟教达拷锟斤拷锟斤拷锟节硷拷群锟斤拷锟斤拷锟酵伙拷锟斤拷叻锟斤拷锟斤拷锟斤拷希锟酵拷锟組PI(message
passing model)锟斤拷锟斤拷SMP(锟皆称多处锟斤拷锟斤拷锟斤拷锟斤拷一
锟斤拷锟斤拷锟斤拷锟斤拷锟叫讹拷锟斤拷锟斤拷锟紺PU锟斤拷锟斤拷锟斤拷shared memory model)锟斤拷锟斤拷刹锟斤拷屑锟斤拷恪thread锟斤拷准锟斤拷1995锟疥建锟斤拷锟侥ｏ拷之锟斤拷锟斤拷锟斤拷锟�
Windows锟斤拷锟絎in32 thread锟斤拷锟斤拷锟斤拷锟街筹拷锟斤拷锟斤拷&quot;锟斤拷锟斤拷指锟斤拷&quot;锟斤拷锟斤拷锟斤拷data parallel模锟酵碉拷OpenMP(OpenMP 3.0锟斤拷
锟斤拷锟斤拷task parallel支锟斤拷)锟斤拷task parallel锟侥憋拷锟斤拷Click锟斤拷Intel锟斤拷Intel Thread
Building
Block(task parallel)锟斤拷Java 1.5锟斤拷始锟皆讹拷锟竭筹拷锟结供锟较好碉拷支锟斤拷(锟斤拷锟斤拷锟斤拷Java
Memory Model)锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷
GPU锟侥凤拷展锟斤拷Nvidia锟街匡拷始锟斤拷CUDA(data-parallel)锟斤拷Apple一锟斤拷锟斤拷锟皆ｏ拷锟斤拷锟叫憋拷锟斤拷院锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷业貌锟揭伙拷郑锟斤拷锟斤拷锟斤拷约锟斤拷锟斤拷锟脚�
锟剿革拷锟斤拷锟紺PU锟斤拷GPU锟斤拷媳锟教碉拷OpenCL锟斤拷微锟斤拷一锟斤拷也锟斤拷住锟斤拷也要锟斤拷锟斤拷Visual
Studio2010锟斤拷始锟斤拷C/#锟侥诧拷锟叫库，锟斤拷锟斤拷C++0x也
要锟斤拷锟斤拷锟斤拷叱锟街э拷郑锟斤拷锟斤拷锟斤拷锟斤拷瞎哦锟紼rlang也锟斤拷为锟斤拷锟斤拷支锟街诧拷锟叫憋拷锟斤拷锟斤拷锟饺筹拷锟斤拷锟斤拷之锟斤拷锟斤拷摩锟斤拷锟斤拷锟节达拷锟斤拷锟斤拷锟斤拷锟绞э拷锟斤拷锟斤拷业锟界都锟斤拷始锟斤拷锟斤拷锟斤拷锟叫憋拷谭锟斤拷锟�
展锟斤拷</p>
</li>
</ol>
<p>锟斤拷锟角对筹拷锟斤拷员锟斤拷说锟斤拷锟斤拷什么锟斤拷锟斤拷兀锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟杰的斤拷锟斤拷蠖蓟锟斤拷谴锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷些锟姐法锟斤拷锟斤拷萁峁癸拷锟斤拷叩锟斤拷锟斤拷锟揭黄拷锟教革拷锟剿�&quot;锟斤拷锟揭匡拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟�
锟斤拷硬锟斤拷锟斤拷锟斤拷锟斤拷丫锟斤拷藜瓶锟绞╋拷说锟斤拷碌模锟斤拷锟斤拷墙锟組oore锟斤拷锟斤拷失效锟斤拷锟斤拷锟斤拷锟斤拷锟窖革拷锟斤拷锟斤拷锟斤拷锟斤拷撸锟斤拷锟斤拷锟斤拷歉锟斤拷锟斤拷堑幕锟斤拷锟街伙拷锟斤拷锟侥承┲革拷锟斤拷锟斤拷锟斤拷械酶锟斤拷锟剿讹拷锟窖★拷锟斤拷锟斤拷锟斤拷
锟教碉拷锟诫法锟斤拷证锟斤拷锟斤拷失锟杰的ｏ拷锟斤拷一锟姐都锟斤拷锟斤拷械锟斤拷锟斤拷锟�......锟斤拷锟斤拷说锟斤拷锟叫讹拷锟劫筹拷锟斤拷员锟斤拷锟斤拷锟斤拷未锟斤拷一片锟斤拷锟斤拷锟侥伙拷锟斤拷锟斤拷锟斤拷强锟揭碉拷锟斤拷趣锟斤拷锟揭硷拷锟斤拷没锟斤拷锟斤拷说锟斤拷锟斤拷锟斤拷锟斤拷堑锟斤拷呖唷�
锟斤拷锟斤拷锟斤拷锟斤拷学院锟斤拷些锟斤拷硬锟斤拷锟侥家伙拷一直锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟角达拷锟�&quot;锟斤拷锟缴硷拷硬锟斤拷锟斤拷展锟斤拷锟斤拷锟斤拷锟斤拷转锟斤拷直锟接碉拷锟铰筹拷锟斤拷员锟斤拷锟斤拷训锟斤拷锟斤拷锟窖撅拷锟斤拷锟斤拷锟剿★拷锟斤拷么锟斤拷锟斤拷员锟斤拷锟斤拷锟杰碉拷锟斤拷锟矫碉拷
锟斤拷锟叫憋拷探锟斤拷锟斤拷锟斤拷穑亢锟斤拷锟饺伙拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷一锟斤拷锟斤拷通锟侥筹拷锟斤拷员锟斤拷&quot;锟斤拷锟斤拷貌锟斤拷斜锟斤拷锟斤拷锟斤拷么锟斤拷&quot;锟斤拷十锟叫八九伙拷说&quot;锟揭撅拷锟矫猴拷锟斤拷&quot;锟斤拷前一锟斤拷锟斤拷锟斤拷锟斤拷锟桔凤拷锟斤拷锟斤拷锟斤拷锟斤拷枚锟斤拷叱锟�
锟矫伙拷锟角讹拷锟教好ｏ拷锟斤拷实锟斤拷原锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷露锟斤拷叱锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷疲锟斤拷锟斤拷锟絠solation锟侥讹拷锟斤拷模式锟斤拷锟斤拷programming productivity
锟斤拷performance之锟斤拷锟揭碉拷锟饺较好碉拷锟斤拷锟皆ｏ拷锟斤拷锟皆癸拷锟节猴拷锟叫凤拷锟斤拷锟斤拷锟斤拷锟斤拷锟竭讹拷选锟斤拷锟剿讹拷锟斤拷(锟斤拷锟斤拷锟狡凤拷)锟斤拷锟接达拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟叫撅拷锟斤拷系锟斤拷模锟斤拷锟斤拷锟叫�
OS/Compiler锟侥ｏ拷锟斤拷锟角讹拷锟斤拷锟斤拷锟斤拷锟皆的ｏ拷锟斤拷锟节讹拷锟节伙拷努锟斤拷锟斤拷为锟斤拷锟侥筹拷锟斤拷员锟结供一锟斤拷锟斤拷锟斤拷锟斤拷使锟矫的诧拷锟叫憋拷锟侥ｏ拷停锟絀ntel锟解几锟疥不也锟节革拷锟斤拷锟斤拷
训么锟斤拷锟解都锟角猴拷锟斤拷锟襟，碉拷锟角ｏ拷锟斤拷锟斤拷锟斤拷锟饺拷锟斤拷斜锟斤拷时锟斤拷锟斤拷锟洁当锟斤拷锟斤拷路要锟竭★拷锟斤拷锟斤拷锟絀T锟斤拷锟斤拷锟斤拷锟斤拷锟介单锟斤拷锟斤拷锟斤拷锟斤拷胁锟斤拷斜锟教碉拷锟介籍锟斤拷锟角革拷锟杰好碉拷写锟秸★拷</p>
<ol>
<li>锟斤拷锟斤拷
锟斤拷锟斤拷锟斤拷锟斤拷锟铰ｏ拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷么锟街阶讹拷锟斤拷锟斤拷锟斤拷锟矫的ｏ拷锟斤拷锟揭猴拷锟矫的诧拷锟叫憋拷坦锟斤拷锟斤拷卸锟斤拷锟斤拷兀锟斤拷锟接拷锟揭诧拷锟戒）锟斤拷</li>
</ol>
<p>(1) IDE: Intel Parallel Studio锟斤拷微锟斤拷锟斤拷锟较筹拷锟斤拷锟斤拷VS2010锟斤拷一锟斤拷锟斤拷Sun锟斤拷Sun
Studio(锟斤拷知锟斤拷锟斤拷锟轿达拷锟斤拷锟�
锟轿ｏ拷锟斤拷锟斤拷锟斤拷锟斤拷锟酵猴拷小锟斤拷)锟斤拷Nvidia锟斤拷CUDA平台什么锟侥撅拷锟饺诧拷锟斤拷锟斤拷
(2) Compiler: Intel锟斤拷ICC(锟斤拷锟皆讹拷锟斤拷锟叫伙拷一些锟斤拷锟斤拷)锟斤拷Nema Labs锟斤拷FASThread(锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟侥斤拷锟斤拷锟斤拷锟斤拷锟斤拷芸锟斤拷锟�
锟缴匡拷锟斤拷指锟斤拷锟斤拷锟斤拷员实施锟斤拷锟叫伙拷)
(3) Performance Tuning: Intel Vtune Analyzer(锟桔猴拷锟斤拷锟杰凤拷锟斤拷)锟斤拷Thread
profiler锟斤拷
Acumem锟斤拷Thread Spotter(锟斤拷远锟斤拷Cache锟斤拷锟斤拷锟杰凤拷锟斤拷锟斤拷锟脚伙拷)
(4) Debugging: Petra锟斤拷Jinx</p>
<p>锟斤拷锟斤拷锟斤拷锟揭革拷锟剿撅拷锟斤拷锟斤拷锟角对筹拷锟斤拷员锟斤拷说确实锟斤拷锟矫ｏ拷锟斤拷锟斤拷前锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷要锟斤拷锟矫★拷锟斤拷锟斤拷实锟街革拷诙锟斤拷锟�&quot;锟斤拷锟斤拷&quot;锟叫很达拷锟较碉拷恕锟�</p>
<ol>
<li><p>锟斤拷锟节核的恐撅拷
锟斤拷锟斤拷锟斤拷锟角匡拷锟斤拷4锟斤拷锟窖撅拷锟角筹拷锟秸憋拷锟剿ｏ拷锟饺癸拷锟斤拷锟角可撅拷锟斤拷8锟剿ｏ拷16锟剿ｏ拷32锟斤拷锟剿★拷锟斤拷锟斤拷确锟斤拷锟斤拷拇锟斤拷锟斤拷诤锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷泻芎玫锟斤拷锟斤拷埽锟斤拷芎玫目锟斤拷锟斤拷锟斤拷裕锟斤拷锟�
锟斤拷锟斤拷歉锟斤拷锟斤拷狻ｏ拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷芯锟斤拷锟斤拷嵌锟斤拷叱坛锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟杰凤拷锟斤拷锟斤拷目锟侥撅拷锟斤拷为锟剿帮拷锟斤拷锟斤拷锟皆憋拷锟矫的斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟缴碉拷锟斤拷锟斤拷瓶锟斤拷锟斤拷实锟斤拷锟较ｏ拷为锟剿得碉拷锟杰好碉拷
锟斤拷锟斤拷锟斤拷锟皆ｏ拷锟斤拷锟斤拷员锟斤拷要锟斤拷锟斤拷锟斤拷要使锟矫诧拷锟斤拷锟窖好碉拷锟斤拷萁峁�(锟斤拷锟斤拷concurrent hash
map)锟斤拷使锟斤拷细锟斤拷锟饺碉拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟教ｏ拷锟斤拷锟絛ata
parallel锟斤拷锟姐法锟斤拷锟斤拷锟杰碉拷锟斤拷(锟斤拷锟斤拷锟斤拷偷锟絝alse sharing锟斤拷锟斤拷)锟饺等等等ｏ拷锟斤拷锟斤拷锟斤拷每一锟筋都锟角诧拷小锟斤拷锟斤拷战锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷一篇锟斤拷锟铰讹拷锟斤拷锟�
锟斤拷锟竭程筹拷锟斤拷锟结供锟斤拷一些锟斤拷锟矫的斤拷锟介。</p>
</li>
<li><p>锟斤拷维锟斤拷锟斤拷
锟斤拷锟斤拷锟斤拷锟绞ｏ拷锟斤拷锟斤拷希锟斤拷锟叫达拷锟斤拷锟杰癸拷锟斤拷锟街达拷锟絩untime系统锟斤拷build系统锟皆硷拷锟斤拷锟斤拷锟斤拷锟叫达拷锟斤拷一锟斤拷锟斤拷确锟侥癸拷锟斤拷锟斤拷锟斤拷锟角革拷希锟斤拷锟斤拷些锟斤拷锟叫达拷锟斤拷锟斤拷锟斤拷锟斤拷狻拷锟斤拷锟轿�
锟斤拷锟斤拷锟斤拷锟叫较筹拷锟斤拷锟斤拷锟斤拷锟斤拷锟节★拷锟斤拷锟斤拷锟街阶讹拷锟斤拷锟斤拷锟斤拷锟秸诧拷锟叫憋拷痰某锟斤拷锟皆憋拷锟街拷锟斤拷伲锟斤拷锟斤拷也锟斤拷斜锟斤拷锟斤拷锟斤拷锟斤拷么锟斤拷锟窖ｏ拷锟斤拷锟斤拷锟斤拷锟斤拷锟叫╋拷锟斤拷写锟斤拷锟街伙拷锟斤拷锟揭恍┬⌒★拷母亩锟斤拷锟斤拷锟斤拷锌锟�
锟杰碉拷锟斤拷锟铰碉拷bug锟斤拷锟铰碉拷锟斤拷锟斤拷瓶锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟揭伙拷锟斤拷浅锟酵达拷锟斤拷锟斤拷锟介。</p>
</li>
</ol>
</blockquote>
</blockquote>
<p>&gt;</p>
<blockquote>
<blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE
ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>--
Tinyfool锟侥匡拷锟斤拷锟秸硷拷<a href="http://www.tinydust.net/dev/" target="_blank"><a href="http://www.tinydust.net/dev/">http://www.tinydust.net/dev/</a></a>
锟斤拷锟斤拷锟叫癸拷锟斤拷<a href="http://www.codechina.org/" target="_blank"><a href="http://www.codechina.org">http://www.codechina.org</a></a>
myTwitter:<a href="http://twitter.com/tinyfool" target="_blank"><a href="http://twitter.com/tinyfool">http://twitter.com/tinyfool</a></a></p>
</blockquote>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>To unsubscribe from this group, send email to
pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
<p><a href="">显示删减掉的内容</a>
<img src="" alt=""> Lai Jiangshan <img src="" alt=""></p>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>由于内存/cache模型和编译器/cpu的优化, 并行化是不可能通过库来实现的.
我认为最大的障碍是支持并行化的语言.
2010/3/22 Guancheng Chen <a href="&#109;&#97;&#x69;&#x6c;&#x74;&#111;&#58;&#91;&#99;&#104;&#x65;&#x6e;&#103;&#x75;&#46;&#46;&#46;&#x40;&#103;&#109;&#97;&#x69;&#108;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#x28;&#x29;">&#91;&#99;&#104;&#x65;&#x6e;&#103;&#x75;&#46;&#46;&#46;&#x40;&#103;&#109;&#97;&#x69;&#108;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#x28;&#x29;</a></p>
<ol>
<li>C语言可以使用pthread等库实现并行化，C++ JAVA等已经会即将支持多线程 所以语言能实现并行化 只是难易问题</li>
<li>是指Shared memory模型，多核共享一条内存总线所以造成带宽问题么？这确实是个问题，不过我感觉硬件商家会负责为你带来越来越多的带
宽，而程序员的任务只是合理的利用好这些给定的带宽</li>
<li>能具体说说哪些误导宣传么？
On 3月22日, 上午1时46分, 陨落雕 <a href="&#x6d;&#97;&#105;&#x6c;&#116;&#111;&#58;&#91;&#103;&#101;&#x6f;&#46;&#46;&#46;&#x2e;&#x40;&#103;&#109;&#x61;&#105;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#x29;">&#91;&#103;&#101;&#x6f;&#46;&#46;&#46;&#x2e;&#x40;&#103;&#109;&#x61;&#105;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#x29;</a> wrote:<blockquote>
<p>呃，我想的障碍是: 1. 类C语言的统治地位; 2. 内存带宽不够; 3. 误导性宣传;</p>
</blockquote>
</li>
</ol>
<p>&gt;</p>
<blockquote>
<p>On Mar 21, 7:37 pm, Guancheng Chen <a href="&#x6d;&#97;&#105;&#108;&#x74;&#x6f;&#58;&#91;&#99;&#x68;&#101;&#110;&#103;&#117;&#97;&#110;&#99;&#x68;&#46;&#46;&#x2e;&#64;&#x67;&#x6d;&#97;&#x69;&#x6c;&#46;&#99;&#111;&#109;&#93;&#x28;&#41;">&#91;&#99;&#x68;&#101;&#110;&#103;&#117;&#97;&#110;&#99;&#x68;&#46;&#46;&#x2e;&#64;&#x67;&#x6d;&#97;&#x69;&#x6c;&#46;&#99;&#111;&#109;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看<a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..</p>
</blockquote>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<blockquote>
<blockquote>
<p>)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a></p>
</li>
</ol>
</blockquote>
</blockquote>
<p><img src="" alt=""> Jeffrey Zhao <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>能详细说说为什么“由于内存/cache模型和编译器/cpu的优化, 并行化是不可能通过库来实现的”吗？</p>
<p>Jeffrey Zhao
Blog: <a href="http://www.cnblogs.com/JeffreyZhao/" title="http://www.cnblogs.com/JeffreyZhao/
CTRL + Click to follow link"><a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter: @jeffz_cn
<strong>From:</strong> <a href="&quot;mailto:eag0628@gmail.com
CTRL + Click to follow link&quot;">Lai Jiangshan</a></p>
<p><strong>Sent:</strong> Monday, March 22, 2010 10:17 PM
<strong>To:</strong> <a href="&quot;mailto:pongba@googlegroups.com
CTRL + Click to follow link&quot;">pon...@googlegroups.com</a></p>
<p><strong>Subject:</strong> Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>由于内存/cache模型和编译器/cpu的优化, 并行化是不可能通过库来实现的.
我认为最大的障碍是支持并行化的语言.
2010/3/22 Guancheng Chen <a href="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#x6f;&#x3a;&#x5b;&#99;&#104;&#101;&#110;&#x67;&#117;&#46;&#46;&#46;&#x40;&#x67;&#109;&#x61;&#x69;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#93;&#40;&#x29;">&#x5b;&#99;&#104;&#101;&#110;&#x67;&#117;&#46;&#46;&#46;&#x40;&#x67;&#109;&#x61;&#x69;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#93;&#40;&#x29;</a></p>
<ol>
<li>C语言可以使用pthread等库实现并行化，C++ JAVA等已经会即将支持多线程 所以语言能实现并行化 只是难易问题</li>
<li>是指Shared memory模型，多核共享一条内存总线所以造成带宽问题么？这确实是个问题，不过我感觉硬件商家会负责为你带来越来越多的带
宽，而程序员的任务只是合理的利用好这些给定的带宽</li>
<li>能具体说说哪些误导宣传么？
On 3月22日, 上午1时46分, 陨落雕 <a href="&#109;&#x61;&#105;&#x6c;&#116;&#111;&#x3a;&#x5b;&#x67;&#x65;&#111;&#x2e;&#x2e;&#x2e;&#46;&#x40;&#x67;&#x6d;&#x61;&#x69;&#108;&#46;&#99;&#x6f;&#x6d;&#93;&#x28;&#41;">&#x5b;&#x67;&#x65;&#111;&#x2e;&#x2e;&#x2e;&#46;&#x40;&#x67;&#x6d;&#x61;&#x69;&#108;&#46;&#99;&#x6f;&#x6d;&#93;&#x28;&#41;</a> wrote:<blockquote>
<p>呃，我想的障碍是: 1. 类C语言的统治地位; 2. 内存带宽不够; 3. 误导性宣传;</p>
<p>On Mar 21, 7:37 pm, Guancheng Chen <a href="&#109;&#x61;&#x69;&#x6c;&#116;&#x6f;&#58;&#91;&#99;&#x68;&#x65;&#x6e;&#103;&#117;&#x61;&#x6e;&#99;&#x68;&#46;&#46;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#x69;&#108;&#46;&#x63;&#111;&#109;&#x5d;&#40;&#41;">&#91;&#99;&#x68;&#x65;&#x6e;&#103;&#117;&#x61;&#x6e;&#99;&#x68;&#46;&#46;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#x69;&#108;&#46;&#x63;&#111;&#109;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看<a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
</li>
</ol>
</blockquote>
</blockquote>
</li>
</ol>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>您值得是那篇著名的“Threads Cannot be Implemented as a Library”吧？恩，好用的并行语言确实关键，虽然
C++0x和Java都会加入memory model，但是要程序员来手动负责这些事情确实还是挺约束生产力的。</p>
<p>On 3月22日, 下午3时17分, Lai Jiangshan <a href="&#x6d;&#97;&#x69;&#x6c;&#x74;&#x6f;&#x3a;&#x5b;&#101;&#x61;&#103;&#x30;&#x2e;&#x2e;&#46;&#64;&#103;&#109;&#x61;&#x69;&#x6c;&#46;&#99;&#111;&#x6d;&#93;&#x28;&#x29;">&#x5b;&#101;&#x61;&#103;&#x30;&#x2e;&#x2e;&#46;&#64;&#103;&#109;&#x61;&#x69;&#x6c;&#46;&#99;&#111;&#x6d;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>由于内存/cache模型和编译器/cpu的优化, 并行化是不可能通过库来实现的.</p>
<p>我认为最大的障碍是支持并行化的语言.</p>
<p>2010/3/22 Guancheng Chen <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#91;&#99;&#104;&#101;&#110;&#x67;&#117;&#x61;&#110;&#99;&#104;&#46;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#97;&#x69;&#108;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#40;&#x29;">&#91;&#99;&#104;&#101;&#110;&#x67;&#117;&#x61;&#110;&#99;&#104;&#46;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#97;&#x69;&#108;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#40;&#x29;</a></p>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>&gt;
&gt;
&gt;</p>
<blockquote>
<blockquote>
<ol>
<li>C语言可以使用pthread等库实现并行化，C++ JAVA等已经会即将支持多线程 所以语言能实现并行化 只是难易问题</li>
<li>是指Shared memory模型，多核共享一条内存总线所以造成带宽问题么？这确实是个问题，不过我感觉硬件商家会负责为你带来越来越多的带
宽，而程序员的任务只是合理的利用好这些给定的带宽</li>
<li>能具体说说哪些误导宣传么？</li>
</ol>
<p>On 3月22日, 上午1时46分, 陨落雕 <a href="&#x6d;&#x61;&#105;&#x6c;&#116;&#111;&#x3a;&#x5b;&#x67;&#x65;&#x6f;&#46;&#x2e;&#46;&#x2e;&#x40;&#103;&#x6d;&#97;&#x69;&#108;&#46;&#99;&#x6f;&#x6d;&#93;&#x28;&#41;">&#x5b;&#x67;&#x65;&#x6f;&#46;&#x2e;&#46;&#x2e;&#x40;&#103;&#x6d;&#97;&#x69;&#108;&#46;&#99;&#x6f;&#x6d;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>呃，我想的障碍是: 1. 类C语言的统治地位; 2. 内存带宽不够; 3. 误导性宣传;</p>
<p>On Mar 21, 7:37 pm, Guancheng Chen <a href="&#x6d;&#97;&#x69;&#108;&#x74;&#x6f;&#58;&#91;&#99;&#104;&#101;&#110;&#x67;&#x75;&#97;&#110;&#x63;&#x68;&#46;&#46;&#46;&#x40;&#x67;&#x6d;&#x61;&#x69;&#108;&#x2e;&#99;&#111;&#109;&#93;&#x28;&#x29;">&#91;&#99;&#104;&#101;&#110;&#x67;&#x75;&#97;&#110;&#x63;&#x68;&#46;&#46;&#46;&#x40;&#x67;&#x6d;&#x61;&#x69;&#108;&#x2e;&#99;&#111;&#109;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看
<a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线</p>
</blockquote>
</blockquote>
<p>程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。</p>
<blockquote>
<blockquote>
<p>尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。</p>
</li>
</ol>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
<a href="">显示删减掉的内容</a></p>
</blockquote>
</blockquote>
<p><img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>主要就是那篇《Threads Cannot be Implemented as a Library》的论文，跟我以前发帖说的
Sequential Consistency，memory model有关</p>
<p>On 3月22日, 下午3时38分, &quot;Jeffrey Zhao&quot; <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#x3a;&#x5b;&#x6a;&#101;&#46;&#46;&#x2e;&#64;&#x6c;&#105;&#x76;&#x65;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#41;">&#x5b;&#x6a;&#101;&#46;&#46;&#x2e;&#64;&#x6c;&#105;&#x76;&#x65;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>能详细说说为什么&quot;由于内存/cache模型和编译器/cpu的优化, 并行化是不可能通过库来实现的&quot;吗？</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter: @jeffz_cn</p>
<p>From: Lai Jiangshan
Sent: Monday, March 22, 2010 10:17 PM
To: <a href="">pon...@googlegroups.com</a>
Subject: Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>由于内存/cache模型和编译器/cpu的优化, 并行化是不可能通过库来实现的.</p>
<p>我认为最大的障碍是支持并行化的语言.</p>
<p>2010/3/22 Guancheng Chen <a href="&#109;&#97;&#x69;&#108;&#116;&#x6f;&#58;&#x5b;&#99;&#x68;&#101;&#110;&#x67;&#x75;&#97;&#110;&#99;&#x68;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#97;&#x69;&#108;&#x2e;&#99;&#111;&#109;&#x5d;&#40;&#41;">&#x5b;&#99;&#x68;&#101;&#110;&#x67;&#x75;&#97;&#110;&#99;&#x68;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#97;&#x69;&#108;&#x2e;&#99;&#111;&#109;&#x5d;&#40;&#41;</a></p>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>&gt;</p>
<blockquote>
<ol>
<li>C语言可以使用pthread等库实现并行化，C++ JAVA等已经会即将支持多线程 所以语言能实现并行化 只是难易问题</li>
<li>是指Shared memory模型，多核共享一条内存总线所以造成带宽问题么？这确实是个问题，不过我感觉硬件商家会负责为你带来越来越多的带
宽，而程序员的任务只是合理的利用好这些给定的带宽</li>
<li><p>能具体说说哪些误导宣传么？</p>
<p>On 3月22日, 上午1时46分, 陨落雕 <a href="&#x6d;&#97;&#x69;&#108;&#116;&#111;&#x3a;&#x5b;&#103;&#x65;&#x6f;&#x2e;&#x2e;&#x2e;&#46;&#64;&#x67;&#109;&#97;&#105;&#108;&#46;&#99;&#x6f;&#109;&#x5d;&#x28;&#41;">&#x5b;&#103;&#x65;&#x6f;&#x2e;&#x2e;&#x2e;&#46;&#64;&#x67;&#109;&#97;&#105;&#108;&#46;&#99;&#x6f;&#109;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>呃，我想的障碍是: 1. 类C语言的统治地位; 2. 内存带宽不够; 3. 误导性宣传;</p>
<p>On Mar 21, 7:37 pm, Guancheng Chen <a href="&#x6d;&#x61;&#x69;&#108;&#116;&#x6f;&#58;&#x5b;&#99;&#x68;&#x65;&#x6e;&#x67;&#117;&#97;&#x6e;&#x63;&#x68;&#46;&#x2e;&#46;&#x40;&#103;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#99;&#111;&#x6d;&#x5d;&#x28;&#x29;">&#x5b;&#99;&#x68;&#x65;&#x6e;&#x67;&#117;&#97;&#x6e;&#x63;&#x68;&#46;&#x2e;&#46;&#x40;&#103;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#99;&#111;&#x6d;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看<a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。</p>
</li>
</ol>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
</li>
</ol>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> Alleluia <img src="" alt=""></p>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>no no.其实Concurrency和Parallelism完全是两码事情,IO来区分它们其实完全是从最基本的体系结构上来说就是如此的.你把
IO理解为网络通信,磁盘读写就太狭隘了.
比如看这个图
<a href="http://ian--king.javaeye.com/upload/picture/pic/57449/40915ec8-f578-3398-9931-1afa4364a2b9.jpg" target="_blank"><a href="http://ian--king.javaeye.com/upload/picture/pic/57449/40915ec8-f578-3398-9931-1afa4364a2b9.jpg">http://ian--king.javaeye.com/upload/picture/pic/57449/40915ec8-f578-3398-9931-1afa4364a2b9.jpg</a></a>
,我们要计算一个ax^2+bx+c的一元二次方程,左边的是并行计算,右边的是顺序计算.这两者完全就是两个体系结构,我们现在所使用的计算机是右边
那个图是由Control Flow Drive的.左边是Data Flow Drive的是典型的并行计算机的结构.其中最大的区别就是,右边的架
构采用了PC指针和Assignment.Assignment本身不是一个计算过程,仅仅是一次IO操作,从存储器里拿出数据/程序灌入运算器或者相
反.那么Assignment跟Concurrency有什么关系呢?为了响应Assigment这种基础的IO,那么冯结构必须依靠CPU时钟来驱动
PC指针的移动.因此控制流驱动模式构成了CPU响应外界IO的最基本的模式.无论是内存还是磁盘或者网络,CPU要获取外部设备的IO最基本模式,只
能是通过本地时钟触发控制流，周期性发起状态查询.CPU在某个周期向其他设备发送信号，在收到远端设备的反馈信号后计算得出本地代码序列上的程序段地
址,然后移动PC指针指向该地址进行处理。无论是早期的轮询模式还是现在广泛采用的中断方式，其基本的IO模式并没有改变,只不过查询对象由最初的IO
设备演变为中断寄存器.
因此你可以看到,Concurrency其实只是在讨论如何能够利用外设信号与CPU时钟之间的差异,让CPU在一定的时钟周期内尽可能多的响应不同外
设信号。一个通常的程序仅仅只需要通过Assigment响应内存IO,而Concurrency程序需要相应成千上万个外部设备,这仅仅是量上的区别
并没有到任何质上的区别,Concurrency程序本质上仍然是一个顺序执行的程序而已.采用恰当的技术比如完成端口之类的,可以在单核CPU机器上
仅仅采用单线程模型就能得到极高的并发性.当然多核同时处理可以进一步提高并发量,但是这不是必须的.
换一句话说,目前的CPU架构本身就是一种具备了Concurrency能力的顺序型架构.甚至在当初冯诺伊曼设计这个架构的时候,就极力杜绝并行计算
的指令在这种机器上出现在程序里,因为他认为并行执行的指令会让人发疯.而你再看右边的计算机构,与冯结构完全不同.他的计算是彻底并行的,这就是所谓
的数据流驱动.虽然说冯结构本身不利于并行,但是这个体系发展到现在,已经在不同层面上用冯结构模拟数据流计算.往小里说,CPU上最典型的顺序型程序
在微指令层面上有很大一部分就是数据流驱动并行执行的,因为要做OOO.往大了说,并行在若干个独立内核上的线程组之间的互相通信,也是一种数据流驱
动.并行必定是数据流驱动的.这是两者本质上的不同.如果你去看GPU上的并行就更接近这个模型,所有的计算都是分成若干个stage,数据依次从
stage上流过,stage上的并行计算单元对数据进行高密度的并行计算.这就是所谓的流处理器.当然现在的流处理器还是非常的简单,未来的GPU会
像Dataflow machine的方向发展.当然DataFlow machine也有自己的问题，比如说的指令牌粒度太小了，这导致两个重要缺
点，一个是通信代价非常高，另一个是指令牌点火代价很高。而Standford的ImagineGPU流处理器引擎可以看作介于数据流机和指令流机之间
的架构，所作的一个重要权衡就是增加指令牌的粒度，从而减小点火代价和利用赠大的Token粒度去减小通信代价</p>
<p>至于粒度问题,关键是看你的计算资源有多少.比如说CPU目前最多8核,16核.那么你所谓的按照循环来进行并行自然是可行的,但是你放到CUDA上
去,GTX295有250个内核,你为了让他所有的内核处于工作繁忙的状态,就根本不可能按照循环层次来进行并行,在这个上面并行的粒度是需要划分的极
为纤细的。更诡异的是有些算法,处理的数据量很小,但是计算量可能极为庞大.比如一些运动估计算法,在一个16/*16的像素区域内要完成256×256
次sad运算.这种数据量和计算完全非常不成比例的.怎么对并行粒度的进行有效的划分,非常考算法功夫的.并行计算最好是通过算法杜绝锁,这也是非常困
难的地方.</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>On 3月22日, 下午7时04分, Guancheng Chen <a href="&#x6d;&#x61;&#x69;&#x6c;&#116;&#x6f;&#x3a;&#91;&#99;&#104;&#101;&#x6e;&#x67;&#x75;&#97;&#x6e;&#x63;&#x68;&#46;&#46;&#x2e;&#64;&#x67;&#x6d;&#97;&#105;&#x6c;&#46;&#99;&#x6f;&#x6d;&#93;&#40;&#41;">&#91;&#99;&#104;&#101;&#x6e;&#x67;&#x75;&#97;&#x6e;&#x63;&#x68;&#46;&#46;&#x2e;&#64;&#x67;&#x6d;&#97;&#105;&#x6c;&#46;&#99;&#x6f;&#x6d;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>您的观点很有新意，我以前没有过用IO来区分Concurrency和Parallelism的想法，我猜测可能跟您的网络/通信背景有关。其实我觉得
从广义上来讲Parallelism和Concurrency是基本重合的两个概念，只不过可能Concurrency稍微偏工程一点，
Parallelism稍微偏研究一点。例如Herb Sutter要出的新书叫Effective Concurrency,而市面上其他讲并行计算
的书不少也使用Parallel相关的词汇。</p>
<p>另外您这句话我有些不赞同：&quot;颗粒度越小的并行获得的计算资源的利用率也就越大加速比就越大&quot;，拿一个计算密集型的嵌套循环举例，对比并行外层循环和并
行内层循环，无疑你在并行化外层循环时的性能加速比更好，而这时候你的并行度是粗粒度的(内循环并行相对来说是细粒度的)。当然，粗/细粒度的选择确实
是个tradeoff，拿锁竞争来说，细粒度的锁意味着更好的Scalability，但是你加锁/解锁的次数相比组粒度所来说增加了，而这种加锁/解
锁的操作是有开销的，所以需要在锁操作本身的开销和程序的Scalability中做一个平衡。</p>
<p>多谢指教！</p>
<p>On 3月22日, 上午10时19分, Alleluia <a href="&#x6d;&#97;&#x69;&#108;&#x74;&#111;&#x3a;&#91;&#x61;&#x6c;&#x6c;&#117;&#x6c;&#46;&#x2e;&#46;&#x40;&#x67;&#x6d;&#x61;&#105;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#x29;">&#91;&#x61;&#x6c;&#x6c;&#117;&#x6c;&#46;&#x2e;&#46;&#x40;&#x67;&#x6d;&#x61;&#105;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>Concurrency 说到底纯粹就是一个IO问题.而IO问题本质上是和计算完全无关的事情,不存在能不能行可不可计算的问题.因此它相对来说非常
单纯。他更多的是一种类似时钟同步的问题,如果你把IO事件想像成一种时钟信号.其实时钟本来也就是一堆信号而已.如果你做过Circuit 的东西就
会明白,IO只是在不同的时序下进行数据采样.比如最简单的同步时钟,所有的时序电路公用一个时钟,把不同的电路安排在不同的时序边沿上触发.当然更复
杂异步逻辑的道理也是一样的.放到宏观的Concurrency的问题的实质并没有多大改变,只不过CPU依靠PC指针的移动把这种电路上的时序处理软
件化了.</p>
<p>而Parallelism更多的是需要考虑计算问题同时还要兼顾IO.Parallelism首先要回答的是一个东西是不是可并行的.回答完这个问题
后,如果可并行那么在什么样的硬件设备上并行是最合适的这样一个问题.在Parallelism中需要考虑的的IO也不仅仅是来自于网络更多是,缓存,
内存,磁盘,总线等等.其实我觉得,在Parallelism下你总是处于一个矛盾状态,颗粒度越小的并行获得的计算资源的利用率也就越大加速比就越
大,但是同时通信系统的工作也就越是繁忙整个运算过程浪费在通信消耗上的时间也就越多.
这个当中的tradeoff是非常困难的.很多时候速度不快,完全不是因为你的核心不够多,而是你的通信速度不够高.</p>
<p>On 3月22日, 下午3时21分, Guancheng Chen <a href="&#x6d;&#x61;&#105;&#x6c;&#x74;&#111;&#58;&#x5b;&#99;&#104;&#101;&#110;&#103;&#x75;&#x61;&#x6e;&#x63;&#x68;&#46;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#x69;&#108;&#46;&#99;&#111;&#x6d;&#93;&#40;&#x29;">&#x5b;&#99;&#104;&#101;&#110;&#103;&#x75;&#x61;&#x6e;&#x63;&#x68;&#46;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#x69;&#108;&#46;&#99;&#111;&#x6d;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>绝大部分的观点Can&#39;t agree more.其实这也是为什么我引用了高老爷子那段话的原因，因为程序的本质就是数据结构和算法，你要没有非常适
合并行的算法那简直就是巧妇难为无米之炊。但是有疑问的一点是关于Parallelism和Concurrency这两个单词的区别，实际上这也是非常
有意思的一件事情，Sun的多线程指南上写的是： Parallelism is a condition that arises when at
least two threads are executing simultaneously, while concurrency is a
condition that exists when at least two threads are making progress.
Therefore concurrency is a more generalized form of parallelism that
can include time-slicing as a form of virtual parallelism.不知道您怎么看？</p>
<p>On 3月22日, 上午8时06分, Alleluia <a href="&#109;&#x61;&#x69;&#108;&#x74;&#111;&#x3a;&#x5b;&#x61;&#x6c;&#x6c;&#117;&#108;&#x2e;&#x2e;&#46;&#x40;&#x67;&#x6d;&#x61;&#105;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#40;&#x29;">&#x5b;&#x61;&#x6c;&#x6c;&#117;&#108;&#x2e;&#x2e;&#46;&#x40;&#x67;&#x6d;&#x61;&#105;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>Parallelism 说到底是算法问题.Parallelism与Concurrency不同,Concurrency所面对的问题相对的单一可以
让一群有经验的专家来实现一套通用库或者语言来提供一个基本的编程框架.而在Parallelism上,具体的不同问题,其所需要并行的算法是根本不同
的.原因在于不同的问题,其内部的DataDependency的结构完全不同,不同的Data Dependency的结构,需要构造不同的算法.即
便是相同的Data Dependency,在不同的颗粒度下，在不同的硬件条件下所采用的算法也是完全不同的.因为一旦出现Data
Dependency也就意味着并行计算模块之间需要进行通信.从以计算节点为单位的分布式并行,到多核CPU上的Numa结构,到SIMD上的向量处
理器,其计算单元之间的通信手段,通信效率简直天差地别.比如说,在SMP上最常见的并行算法,work stealing也就是Intel的TBB,
是建立在两个条件下第一个是CPU的Cache机制上,这使得通常在内存的之间的数据搬运消耗非常小,第二个是SMP上计算单元相对的少,因此每个计算
单元被分配到的任务就相对的重。其开销远远大于通信的开销,因此这种机制在SMP上相对的划算.但是如果你要在GPU上做Work Stealing就
完全不可行,因为GPU的运算单元数量极多,被分配到的任务就相对来说的非常轻量,CUDA上的一个thread很多时候运算一次的时间不会超过
10us,而一次跨Block的线程之间的通信开销就往往要达到100us左右,再加上目前GPU上的Cache机制非常落后导致了需要频繁的通信开销
的Work Stealing在GPU上是非常不划算得.
所以我个人认为在硬件架构没有更多的突破之前,OpenCL这种东西是没有任何生命力的.不要说CPU的并行与GPU之间差异巨大,就是不同的GPU之
间AMD与Nvidia两个也是各自为政,一个平台上跑得非常快的东西,在另外一个平台极大的可能是龟速.其最终的结果估计就是跟Java的
write once run everywhere一样是个大笑话.</p>
<p>On 3月22日, 下午2时06分, Guancheng Chen <a href="&#109;&#x61;&#105;&#x6c;&#x74;&#x6f;&#58;&#x5b;&#x63;&#x68;&#101;&#x6e;&#x67;&#x75;&#97;&#x6e;&#x63;&#104;&#46;&#46;&#46;&#64;&#x67;&#109;&#x61;&#105;&#x6c;&#46;&#x63;&#111;&#x6d;&#93;&#40;&#41;">&#x5b;&#x63;&#x68;&#101;&#x6e;&#x67;&#x75;&#97;&#x6e;&#x63;&#104;&#46;&#46;&#46;&#64;&#x67;&#109;&#x61;&#105;&#x6c;&#46;&#x63;&#111;&#x6d;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>On 3月22日, 上午2时20分, Tinyfool <a href="&#109;&#97;&#105;&#x6c;&#x74;&#x6f;&#x3a;&#x5b;&#116;&#x69;&#x6e;&#121;&#x66;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#109;&#97;&#105;&#x6c;&#x2e;&#99;&#111;&#x6d;&#x5d;&#40;&#41;">&#x5b;&#116;&#x69;&#x6e;&#121;&#x66;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#109;&#97;&#105;&#x6c;&#x2e;&#99;&#111;&#x6d;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#x6d;&#97;&#105;&#x6c;&#116;&#x6f;&#x3a;&#91;&#106;&#101;&#x2e;&#x2e;&#46;&#x40;&#108;&#x69;&#x76;&#x65;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#x29;">&#91;&#106;&#101;&#x2e;&#x2e;&#46;&#x40;&#108;&#x69;&#x76;&#x65;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#x29;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a></p>
<p>Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#109;&#x61;&#x69;&#x6c;&#116;&#x6f;&#x3a;&#x5b;&#99;&#x68;&#x65;&#110;&#103;&#117;&#97;&#x6e;&#x63;&#104;&#46;&#46;&#x2e;&#x40;&#103;&#x6d;&#x61;&#105;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#x29;">&#x5b;&#99;&#x68;&#x65;&#110;&#103;&#117;&#97;&#x6e;&#x63;&#104;&#46;&#46;&#x2e;&#x40;&#103;&#x6d;&#x61;&#105;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#x29;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#109;&#x61;&#x69;&#108;&#x74;&#x6f;&#x3a;&#91;&#112;&#x6f;&#x6e;&#x2e;&#x2e;&#x2e;&#64;&#103;&#x6f;&#x6f;&#103;&#108;&#x65;&#x67;&#x72;&#111;&#117;&#x70;&#x73;&#x2e;&#x63;&#111;&#x6d;&#93;&#40;&#41;">&#91;&#112;&#x6f;&#x6e;&#x2e;&#x2e;&#x2e;&#64;&#103;&#x6f;&#x6f;&#103;&#108;&#x65;&#x67;&#x72;&#111;&#117;&#x70;&#x73;&#x2e;&#x63;&#111;&#x6d;&#93;&#40;&#41;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>&gt;</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间</li>
</ol>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>...</p>
<p>阅读更多 &gt;&gt;
<a href="">显示删减掉的内容</a></p>
</blockquote>
<p><img src="" alt=""> Alleluia <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>且抛开,流处理器这种异构的内核,SMP和Numa之间的差异.就说说单个CPU上做SIMD并行化的需要考虑的内存/cache问题.
比如作矩阵乘法运算,如果矩阵都是按照行存储, 则在A/*B中, 乘法对B的访问是按列的. 假设B一行有N个元素, 那么在存储器中, 两个同列不同
行的元素所在的存储单元相差N. 对B的访问并不是局部化的. 因为访问不局部化, 所以每次乘法, 都需要从内存中调一个 cache 单元到
CPU. 这个极大的降低了处理器的执行速度. 因此, 矩阵乘法的优化的核心, 在于局部化B的访问. 反过来, 如果矩阵按照列存储, 则要局部化
对A的访问. 关于怎样局部化访问还能获得正确的乘法,那就要针对具体的情况设计正确的算法.
为何并行化不可能用库来实现呢?其实问题根源在于,并行颗粒度的变化,导致对IO,算法的乃至硬件结构产生天差地别的变化.一个顺序型的问题,可以划分
成不同的颗粒度.比如说一个100M的Byte型数组,要求和,你可以按照1M的颗粒度进行划分,也可以按照1K,甚至256，128，乃至
4byte,8byte进行划分.每种划分,产生的数据搬运的次数,每次数据搬运的大小,乃至缓存命中率都是不同。
再进一步说,颗粒度划分的越细,意味着计算单元就需要增加,否则就没有意义.但是一旦运算单元的增加到一个的极限,就会引起硬件结构的改变,比如说
SMP根本无法支撑超过16Core的架构,超过这个限度你就得换Nehalem那种Numa架构.在Numa结构下你就不得不考虑,本地内存和远端内
存的区别。
目前没有一个很好的方案来统一不同等级并行计算的架构,在8核之下你用Numa就是杀鸡用牛刀了,而超过32核Numa也不堪重负需要像GPU那样去设
计硬件架构这也就是为什么Intel的Larrebe会难产的原因.每个X86内核都要顶着一个硕大的Deocder还有branch
prediction,OOO之类的庞然大物,用PII来做Larrebe都非常的头大的事情.所以,我个人认为,并行化本身就是和硬件结构极为相关的
事情,这一切都不太可能由一个统一的计算库来完成统一的封装.</p>
<p>On 3月22日, 下午10时38分, &quot;Jeffrey Zhao&quot; <a href="&#x6d;&#x61;&#x69;&#x6c;&#116;&#x6f;&#x3a;&#91;&#x6a;&#101;&#x2e;&#x2e;&#46;&#x40;&#x6c;&#105;&#118;&#101;&#x2e;&#99;&#111;&#109;&#93;&#x28;&#41;">&#91;&#x6a;&#101;&#x2e;&#x2e;&#46;&#x40;&#x6c;&#105;&#118;&#101;&#x2e;&#99;&#111;&#109;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>能详细说说为什么&quot;由于内存/cache模型和编译器/cpu的优化, 并行化是不可能通过库来实现的&quot;吗？</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter: @jeffz_cn</p>
<p>From: Lai Jiangshan
Sent: Monday, March 22, 2010 10:17 PM
To: <a href="">pon...@googlegroups.com</a>
Subject: Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>由于内存/cache模型和编译器/cpu的优化, 并行化是不可能通过库来实现的.</p>
<p>我认为最大的障碍是支持并行化的语言.</p>
<p>2010/3/22 Guancheng Chen <a href="&#x6d;&#97;&#105;&#x6c;&#x74;&#111;&#58;&#x5b;&#99;&#104;&#x65;&#110;&#103;&#117;&#97;&#x6e;&#x63;&#104;&#46;&#46;&#x2e;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#x63;&#111;&#109;&#x5d;&#x28;&#x29;">&#x5b;&#99;&#104;&#x65;&#110;&#103;&#117;&#97;&#x6e;&#x63;&#104;&#46;&#46;&#x2e;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#x63;&#111;&#109;&#x5d;&#x28;&#x29;</a></p>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>&gt;</p>
<blockquote>
<ol>
<li>C语言可以使用pthread等库实现并行化，C++ JAVA等已经会即将支持多线程 所以语言能实现并行化 只是难易问题</li>
<li>是指Shared memory模型，多核共享一条内存总线所以造成带宽问题么？这确实是个问题，不过我感觉硬件商家会负责为你带来越来越多的带
宽，而程序员的任务只是合理的利用好这些给定的带宽</li>
<li><p>能具体说说哪些误导宣传么？</p>
<p>On 3月22日, 上午1时46分, 陨落雕 <a href="&#109;&#97;&#105;&#x6c;&#116;&#111;&#58;&#91;&#x67;&#101;&#x6f;&#x2e;&#x2e;&#x2e;&#46;&#x40;&#103;&#109;&#x61;&#105;&#108;&#x2e;&#99;&#111;&#109;&#93;&#x28;&#41;">&#91;&#x67;&#101;&#x6f;&#x2e;&#x2e;&#x2e;&#46;&#x40;&#103;&#109;&#x61;&#105;&#108;&#x2e;&#99;&#111;&#109;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>呃，我想的障碍是: 1. 类C语言的统治地位; 2. 内存带宽不够; 3. 误导性宣传;</p>
<p>On Mar 21, 7:37 pm, Guancheng Chen <a href="&#x6d;&#x61;&#x69;&#108;&#116;&#111;&#58;&#x5b;&#99;&#x68;&#x65;&#110;&#103;&#117;&#97;&#x6e;&#x63;&#x68;&#46;&#x2e;&#46;&#64;&#103;&#x6d;&#97;&#105;&#108;&#x2e;&#99;&#x6f;&#109;&#93;&#40;&#41;">&#x5b;&#99;&#x68;&#x65;&#110;&#103;&#117;&#97;&#x6e;&#x63;&#x68;&#46;&#x2e;&#46;&#64;&#103;&#x6d;&#97;&#105;&#108;&#x2e;&#99;&#x6f;&#109;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看<a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。</p>
</li>
</ol>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
</li>
</ol>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> 郑伟 <img src="" alt=""></p>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>我对这个比较感兴趣，能详细介绍一下golang在多核下的表现吗？</p>
<p>2010/3/22 Googol Lee <a href="&#109;&#97;&#x69;&#x6c;&#116;&#111;&#58;&#x5b;&#103;&#x6f;&#111;&#x67;&#x2e;&#46;&#46;&#64;&#x67;&#109;&#97;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#41;">&#x5b;&#103;&#x6f;&#111;&#x67;&#x2e;&#46;&#46;&#64;&#x67;&#109;&#97;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#41;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>彻底来晚了......我是来广告golang的！大并发IO还是csp模型的语言更靠谱！
不过golang在cpu密集的并发上不知道效果会怎么样，就现在的表现来看比erlang好，但还赶不上c/c++
On Mar 22, 9:20 am, Tinyfool <a href="&#109;&#97;&#x69;&#108;&#x74;&#111;&#x3a;&#x5b;&#116;&#x69;&#x6e;&#121;&#102;&#x2e;&#46;&#46;&#x40;&#103;&#x6d;&#x61;&#x69;&#108;&#x2e;&#99;&#111;&#x6d;&#x5d;&#x28;&#41;">&#x5b;&#116;&#x69;&#x6e;&#121;&#102;&#x2e;&#46;&#46;&#x40;&#103;&#x6d;&#x61;&#x69;&#108;&#x2e;&#99;&#111;&#x6d;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#109;&#x61;&#105;&#x6c;&#116;&#x6f;&#x3a;&#x5b;&#106;&#101;&#x2e;&#x2e;&#x2e;&#64;&#108;&#105;&#118;&#101;&#x2e;&#99;&#111;&#109;&#x5d;&#40;&#x29;">&#x5b;&#106;&#101;&#x2e;&#x2e;&#x2e;&#64;&#108;&#105;&#118;&#101;&#x2e;&#99;&#111;&#109;&#x5d;&#40;&#x29;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#109;&#x61;&#x69;&#108;&#116;&#111;&#58;&#91;&#99;&#104;&#x65;&#110;&#x67;&#x75;&#x61;&#x6e;&#99;&#x68;&#46;&#x2e;&#x2e;&#x40;&#x67;&#109;&#x61;&#105;&#108;&#x2e;&#x63;&#111;&#x6d;&#93;&#x28;&#41;">&#91;&#99;&#104;&#x65;&#110;&#x67;&#x75;&#x61;&#x6e;&#99;&#x68;&#46;&#x2e;&#x2e;&#x40;&#x67;&#109;&#x61;&#105;&#108;&#x2e;&#x63;&#111;&#x6d;&#93;&#x28;&#41;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#x6d;&#x61;&#105;&#108;&#x74;&#x6f;&#58;&#91;&#112;&#111;&#110;&#x2e;&#x2e;&#46;&#x40;&#103;&#111;&#x6f;&#103;&#x6c;&#x65;&#x67;&#x72;&#x6f;&#x75;&#x70;&#x73;&#46;&#99;&#x6f;&#x6d;&#93;&#x28;&#x29;">&#91;&#112;&#111;&#110;&#x2e;&#x2e;&#46;&#x40;&#103;&#111;&#x6f;&#103;&#x6c;&#x65;&#x67;&#x72;&#x6f;&#x75;&#x70;&#x73;&#46;&#99;&#x6f;&#x6d;&#93;&#x28;&#x29;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。</p>
</li>
</ol>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>--</p>
<p>Tinyfool的开发日记<a href="http://www.tinydust.net/dev/" target="_blank"><a href="http://www.tinydust.net/dev/">http://www.tinydust.net/dev/</a></a>
代码中国网<a href="http://www.codechina.org/" target="_blank"><a href="http://www.codechina.org">http://www.codechina.org</a></a></p>
<p>myTwitter:<a href="http://twitter.com/tinyfool" target="_blank"><a href="http://twitter.com/tinyfool">http://twitter.com/tinyfool</a></a>
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a></p>
</blockquote>
<p><img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-23</p>
<p>其他收件人：</p>
<p>您说的可能跟那个问题不是一回事情，窃以为Lai Jiangshan所说的是指CPU和编译器会对并行程序做违反程序semantics的优化（例如
reordering），导致破坏Memory Consistency，例如大牛HJ Boehm的一篇论文《Threads Cannot be
Implemented as a Library》，我之前也写过一篇浅显小文：<a href="http://www.parallellabs.com/2010/03/06/why-should-programmer-care-about-sequential-consistency-rather-than-cache-coherence/" target="_blank"><a href="http://www.parallellabs.com/">http://www.parallellabs.com/</a>
2010/03/06/why-should-programmer-care-about-sequential-consistency-
rather-than-cache-coherence/</a></p>
<p>另外对于您的Concurrency和Parallelism的看法，我大致理解了您所指的&quot;Concurrency&quot;的含义，它跟我所认为的软件层面
的Concurrency不太一样，您的含义更宏观一些，但是感觉我还没有抓住它的精要，不知道能否推荐几篇文献供我参考？</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>On 3月22日, 下午4时35分, Alleluia <a href="&#109;&#x61;&#x69;&#x6c;&#116;&#x6f;&#x3a;&#x5b;&#97;&#x6c;&#x6c;&#x75;&#x6c;&#46;&#x2e;&#x2e;&#64;&#103;&#x6d;&#97;&#105;&#108;&#46;&#99;&#111;&#x6d;&#x5d;&#x28;&#41;">&#x5b;&#97;&#x6c;&#x6c;&#x75;&#x6c;&#46;&#x2e;&#x2e;&#64;&#103;&#x6d;&#97;&#105;&#108;&#46;&#99;&#111;&#x6d;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>且抛开,流处理器这种异构的内核,SMP和Numa之间的差异.就说说单个CPU上做SIMD并行化的需要考虑的内存/cache问题.
比如作矩阵乘法运算,如果矩阵都是按照行存储, 则在A/*B中, 乘法对B的访问是按列的. 假设B一行有N个元素, 那么在存储器中, 两个同列不同
行的元素所在的存储单元相差N. 对B的访问并不是局部化的. 因为访问不局部化, 所以每次乘法, 都需要从内存中调一个 cache 单元到
CPU. 这个极大的降低了处理器的执行速度. 因此, 矩阵乘法的优化的核心, 在于局部化B的访问. 反过来, 如果矩阵按照列存储, 则要局部化
对A的访问. 关于怎样局部化访问还能获得正确的乘法,那就要针对具体的情况设计正确的算法.
为何并行化不可能用库来实现呢?其实问题根源在于,并行颗粒度的变化,导致对IO,算法的乃至硬件结构产生天差地别的变化.一个顺序型的问题,可以划分
成不同的颗粒度.比如说一个100M的Byte型数组,要求和,你可以按照1M的颗粒度进行划分,也可以按照1K,甚至256，128，乃至
4byte,8byte进行划分.每种划分,产生的数据搬运的次数,每次数据搬运的大小,乃至缓存命中率都是不同。
再进一步说,颗粒度划分的越细,意味着计算单元就需要增加,否则就没有意义.但是一旦运算单元的增加到一个的极限,就会引起硬件结构的改变,比如说
SMP根本无法支撑超过16Core的架构,超过这个限度你就得换Nehalem那种Numa架构.在Numa结构下你就不得不考虑,本地内存和远端内
存的区别。
目前没有一个很好的方案来统一不同等级并行计算的架构,在8核之下你用Numa就是杀鸡用牛刀了,而超过32核Numa也不堪重负需要像GPU那样去设
计硬件架构这也就是为什么Intel的Larrebe会难产的原因.每个X86内核都要顶着一个硕大的Deocder还有branch
prediction,OOO之类的庞然大物,用PII来做Larrebe都非常的头大的事情.所以,我个人认为,并行化本身就是和硬件结构极为相关的
事情,这一切都不太可能由一个统一的计算库来完成统一的封装.</p>
<p>On 3月22日, 下午10时38分, &quot;Jeffrey Zhao&quot; <a href="&#109;&#97;&#x69;&#108;&#116;&#x6f;&#58;&#x5b;&#106;&#x65;&#x2e;&#46;&#x2e;&#64;&#108;&#105;&#118;&#101;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#40;&#x29;">&#x5b;&#106;&#x65;&#x2e;&#46;&#x2e;&#64;&#108;&#105;&#118;&#101;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>能详细说说为什么&quot;由于内存/cache模型和编译器/cpu的优化, 并行化是不可能通过库来实现的&quot;吗？</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter: @jeffz_cn</p>
<p>From: Lai Jiangshan
Sent: Monday, March 22, 2010 10:17 PM
To: <a href="">pon...@googlegroups.com</a>
Subject: Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>由于内存/cache模型和编译器/cpu的优化, 并行化是不可能通过库来实现的.</p>
<p>我认为最大的障碍是支持并行化的语言.</p>
<p>2010/3/22 Guancheng Chen <a href="&#109;&#97;&#105;&#x6c;&#x74;&#111;&#58;&#91;&#99;&#x68;&#x65;&#110;&#x67;&#x75;&#97;&#110;&#99;&#x68;&#46;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#97;&#x69;&#108;&#x2e;&#x63;&#111;&#109;&#x5d;&#x28;&#x29;">&#91;&#99;&#x68;&#x65;&#110;&#x67;&#x75;&#97;&#110;&#99;&#x68;&#46;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#97;&#x69;&#108;&#x2e;&#x63;&#111;&#109;&#x5d;&#x28;&#x29;</a></p>
<ol>
<li>C语言可以使用pthread等库实现并行化，C++ JAVA等已经会即将支持多线程 所以语言能实现并行化 只是难易问题</li>
<li>是指Shared memory模型，多核共享一条内存总线所以造成带宽问题么？这确实是个问题，不过我感觉硬件商家会负责为你带来越来越多的带
宽，而程序员的任务只是合理的利用好这些给定的带宽</li>
<li><p>能具体说说哪些误导宣传么？</p>
<p>On 3月22日, 上午1时46分, 陨落雕 <a href="&#x6d;&#x61;&#105;&#108;&#x74;&#111;&#58;&#91;&#103;&#101;&#x6f;&#46;&#x2e;&#46;&#46;&#64;&#x67;&#109;&#97;&#x69;&#108;&#46;&#x63;&#x6f;&#109;&#93;&#40;&#x29;">&#91;&#103;&#101;&#x6f;&#46;&#x2e;&#46;&#46;&#64;&#x67;&#109;&#97;&#x69;&#108;&#46;&#x63;&#x6f;&#109;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>呃，我想的障碍是: 1. 类C语言的统治地位; 2. 内存带宽不够; 3. 误导性宣传;</p>
<p>On Mar 21, 7:37 pm, Guancheng Chen <a href="&#x6d;&#97;&#x69;&#108;&#116;&#x6f;&#x3a;&#x5b;&#x63;&#x68;&#101;&#x6e;&#103;&#x75;&#97;&#x6e;&#x63;&#104;&#x2e;&#46;&#x2e;&#64;&#103;&#x6d;&#97;&#105;&#x6c;&#x2e;&#99;&#x6f;&#109;&#93;&#x28;&#x29;">&#x5b;&#x63;&#x68;&#101;&#x6e;&#103;&#x75;&#97;&#x6e;&#x63;&#104;&#x2e;&#46;&#x2e;&#64;&#103;&#x6d;&#97;&#105;&#x6c;&#x2e;&#99;&#x6f;&#109;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看<a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx...</p>
</blockquote>
</blockquote>
</li>
</ol>
</blockquote>
<p>阅读更多 &gt;&gt;
<a href="">显示删减掉的内容</a>
<img src="" alt=""> windstorm <img src="" alt=""></p>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-23</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>实在是不能同意你更多......很早很早以前我就在这里和人争论过，GPU的并行计算平台不可能一统天下的。CUDA也不是救世主。OpenCL更不是。</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p><a href="http://www.kunli.info/" target="_blank">www.kunli.info</a>
<a href="http://twitter.com/cnbuff" target="_blank"><a href="http://twitter.com/cnbuff">http://twitter.com/cnbuff</a></a></p>
<p>2010/3/22 Alleluia <a href="&#109;&#x61;&#105;&#x6c;&#x74;&#111;&#58;&#x5b;&#x61;&#108;&#108;&#x75;&#x2e;&#46;&#x2e;&#x40;&#103;&#x6d;&#x61;&#x69;&#x6c;&#46;&#x63;&#x6f;&#109;&#x5d;&#40;&#41;">&#x5b;&#x61;&#108;&#108;&#x75;&#x2e;&#46;&#x2e;&#x40;&#103;&#x6d;&#x61;&#x69;&#x6c;&#46;&#x63;&#x6f;&#109;&#x5d;&#40;&#41;</a>:</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<blockquote>
<p>Parallelism 说到底是算法问题.Parallelism与Concurrency不同,Concurrency所面对的问题相对的单一可以
让一群有经验的专家来实现一套通用库或者语言来提供一个基本的编程框架.而在Parallelism上,具体的不同问题,其所需要并行的算法是根本不同
的.原因在于不同的问题,其内部的DataDependency的结构完全不同,不同的Data Dependency的结构,需要构造不同的算法.即
便是相同的Data Dependency,在不同的颗粒度下，在不同的硬件条件下所采用的算法也是完全不同的.因为一旦出现Data
Dependency也就意味着并行计算模块之间需要进行通信.从以计算节点为单位的分布式并行,到多核CPU上的Numa结构,到SIMD上的向量处
理器,其计算单元之间的通信手段,通信效率简直天差地别.比如说,在SMP上最常见的并行算法,work stealing也就是Intel的TBB,
是建立在两个条件下第一个是CPU的Cache机制上,这使得通常在内存的之间的数据搬运消耗非常小,第二个是SMP上计算单元相对的少,因此每个计算
单元被分配到的任务就相对的重。其开销远远大于通信的开销,因此这种机制在SMP上相对的划算.但是如果你要在GPU上做Work Stealing就
完全不可行,因为GPU的运算单元数量极多,被分配到的任务就相对来说的非常轻量,CUDA上的一个thread很多时候运算一次的时间不会超过
10us,而一次跨Block的线程之间的通信开销就往往要达到100us左右,再加上目前GPU上的Cache机制非常落后导致了需要频繁的通信开销
的Work Stealing在GPU上是非常不划算得.
所以我个人认为在硬件架构没有更多的突破之前,OpenCL这种东西是没有任何生命力的.不要说CPU的并行与GPU之间差异巨大,就是不同的GPU之
间AMD与Nvidia两个也是各自为政,一个平台上跑得非常快的东西,在另外一个平台极大的可能是龟速.其最终的结果估计就是跟Java的
write once run everywhere一样是个大笑话.</p>
<p>On 3月22日, 下午2时06分, Guancheng Chen <a href="&#x6d;&#x61;&#x69;&#108;&#x74;&#x6f;&#58;&#91;&#99;&#104;&#101;&#110;&#x67;&#x75;&#97;&#x6e;&#99;&#104;&#x2e;&#46;&#x2e;&#x40;&#103;&#x6d;&#x61;&#105;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#93;&#40;&#41;">&#91;&#99;&#104;&#101;&#110;&#x67;&#x75;&#97;&#x6e;&#99;&#104;&#x2e;&#46;&#x2e;&#x40;&#103;&#x6d;&#x61;&#105;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>On 3月22日, 上午2时20分, Tinyfool <a href="&#x6d;&#x61;&#105;&#x6c;&#x74;&#111;&#x3a;&#x5b;&#x74;&#x69;&#110;&#x79;&#x66;&#46;&#46;&#x2e;&#64;&#x67;&#x6d;&#97;&#x69;&#108;&#46;&#99;&#111;&#109;&#93;&#x28;&#41;">&#x5b;&#x74;&#x69;&#110;&#x79;&#x66;&#46;&#46;&#x2e;&#64;&#x67;&#x6d;&#97;&#x69;&#108;&#46;&#99;&#111;&#109;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#x6d;&#97;&#x69;&#x6c;&#116;&#111;&#x3a;&#x5b;&#106;&#101;&#x2e;&#46;&#46;&#x40;&#x6c;&#105;&#x76;&#x65;&#46;&#99;&#111;&#109;&#93;&#x28;&#x29;">&#x5b;&#106;&#101;&#x2e;&#46;&#46;&#x40;&#x6c;&#105;&#x76;&#x65;&#46;&#99;&#111;&#109;&#93;&#x28;&#x29;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#109;&#x61;&#x69;&#108;&#x74;&#x6f;&#58;&#91;&#99;&#x68;&#101;&#x6e;&#103;&#117;&#x61;&#x6e;&#x63;&#x68;&#x2e;&#46;&#46;&#x40;&#x67;&#x6d;&#97;&#x69;&#108;&#46;&#x63;&#x6f;&#109;&#93;&#40;&#x29;">&#91;&#99;&#x68;&#101;&#x6e;&#103;&#117;&#x61;&#x6e;&#x63;&#x68;&#x2e;&#46;&#46;&#x40;&#x67;&#x6d;&#97;&#x69;&#108;&#46;&#x63;&#x6f;&#109;&#93;&#40;&#x29;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#111;&#58;&#91;&#x70;&#111;&#x6e;&#x2e;&#x2e;&#46;&#64;&#x67;&#x6f;&#x6f;&#x67;&#108;&#101;&#x67;&#x72;&#x6f;&#x75;&#112;&#115;&#46;&#99;&#111;&#109;&#93;&#40;&#41;">&#91;&#x70;&#111;&#x6e;&#x2e;&#x2e;&#46;&#64;&#x67;&#x6f;&#x6f;&#x67;&#108;&#101;&#x67;&#x72;&#x6f;&#x75;&#112;&#115;&#46;&#99;&#111;&#109;&#93;&#40;&#41;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。</p>
</li>
</ol>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>--
Tinyfool的开发日记<a href="http://www.tinydust.net/dev/" target="_blank"><a href="http://www.tinydust.net/dev/">http://www.tinydust.net/dev/</a></a>
代码中国网<a href="http://www.codechina.org/" target="_blank"><a href="http://www.codechina.org">http://www.codechina.org</a></a>
myTwitter:<a href="http://twitter.com/tinyfool" target="_blank"><a href="http://twitter.com/tinyfool">http://twitter.com/tinyfool</a></a></p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p><a href="">显示删减掉的内容</a></p>
</blockquote>
<p><img src="" alt=""> Juv...@gmail.com <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-23</p>
<p>其他收件人：</p>
<p>好像大家说的concurrency和parallelism不是一个东西？
<a href="">显示删减掉的内容</a>
<img src="" alt=""> windstorm <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-23</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>我觉得这两个东西，sun的多线程编程手册说得很清楚了，没必要重新定义。</p>
<p>Parallelism is a condition that arises when at least two threads are
executing simultaneously, while concurrency is a condition that exists
when at least two threads are making progress.</p>
<p>也就是说concurrency有点像更通用化，限制条件更低的parallelism，而某些case下两者完全不同。比如单核多线程程序，你可以叫它是concurrent
program，但不能叫它是parallel
program。Concurrency在现有体系的处理器架构下都可以做到。和Alleluia说的一样，只是一个时钟周期同步的问题。写过硬件编程的人，几乎都算是写过concurrent
program，但很少写过parallel program</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p><a href="http://www.kunli.info/" target="_blank">www.kunli.info</a>
<a href="http://twitter.com/cnbuff" target="_blank"><a href="http://twitter.com/cnbuff">http://twitter.com/cnbuff</a></a></p>
<p>2010/3/22 <a href="">Juv...@gmail.com</a> <a href="&#109;&#x61;&#105;&#108;&#x74;&#111;&#58;&#x5b;&#106;&#x75;&#x76;&#46;&#x2e;&#46;&#x40;&#x67;&#109;&#97;&#105;&#108;&#46;&#x63;&#x6f;&#x6d;&#93;&#x28;&#x29;">&#x5b;&#106;&#x75;&#x76;&#46;&#x2e;&#46;&#x40;&#x67;&#109;&#97;&#105;&#108;&#46;&#x63;&#x6f;&#x6d;&#93;&#x28;&#x29;</a>:</p>
<blockquote>
<p>好像大家说的concurrency和parallelism不是一个东西？</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p><a href="">显示删减掉的内容</a></p>
</blockquote>
<p><img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-23</p>
<p>其他收件人：</p>
<p>我觉得现有的OpenCL确实非常不成熟，但是从纯性能角度上来讲，我看好Heterogeneous架构，尽管它们的编程难度太大，就像前面提到的不
同架构需要做不同优化等。CPU的性能是latency-oriented，GPU是throughput-oriented,Intel的
Larrabee虽然现在来看不成功，但是业界都在朝着那个方向努力。</p>
<p>On 3月22日, 下午6时18分, windstorm <a href="&#x6d;&#97;&#105;&#x6c;&#x74;&#x6f;&#58;&#91;&#x6c;&#105;&#x6b;&#117;&#110;&#x61;&#114;&#x6d;&#x73;&#116;&#114;&#46;&#46;&#46;&#x40;&#x67;&#109;&#97;&#x69;&#108;&#46;&#99;&#x6f;&#109;&#x5d;&#40;&#x29;">&#91;&#x6c;&#105;&#x6b;&#117;&#110;&#x61;&#114;&#x6d;&#x73;&#116;&#114;&#46;&#46;&#46;&#x40;&#x67;&#109;&#97;&#x69;&#108;&#46;&#99;&#x6f;&#109;&#x5d;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>实在是不能同意你更多......很早很早以前我就在这里和人争论过，GPU的并行计算平台不可能一统天下的。CUDA也不是救世主。OpenCL更不是。</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Alleluia <a href="&#x6d;&#x61;&#105;&#108;&#116;&#111;&#x3a;&#91;&#97;&#x6c;&#x6c;&#117;&#108;&#x2e;&#x2e;&#46;&#x40;&#x67;&#109;&#97;&#x69;&#x6c;&#46;&#x63;&#111;&#109;&#93;&#40;&#x29;">&#91;&#97;&#x6c;&#x6c;&#117;&#108;&#x2e;&#x2e;&#46;&#x40;&#x67;&#109;&#97;&#x69;&#x6c;&#46;&#x63;&#111;&#109;&#93;&#40;&#x29;</a>:</p>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>&gt;
&gt;
&gt;</p>
<blockquote>
<blockquote>
<p>Parallelism 说到底是算法问题.Parallelism与Concurrency不同,Concurrency所面对的问题相对的单一可以
让一群有经验的专家来实现一套通用库或者语言来提供一个基本的编程框架.而在Parallelism上,具体的不同问题,其所需要并行的算法是根本不同
的.原因在于不同的问题,其内部的DataDependency的结构完全不同,不同的Data Dependency的结构,需要构造不同的算法.即
便是相同的Data Dependency,在不同的颗粒度下，在不同的硬件条件下所采用的算法也是完全不同的.因为一旦出现Data
Dependency也就意味着并行计算模块之间需要进行通信.从以计算节点为单位的分布式并行,到多核CPU上的Numa结构,到SIMD上的向量处
理器,其计算单元之间的通信手段,通信效率简直天差地别.比如说,在SMP上最常见的并行算法,work stealing也就是Intel的TBB,
是建立在两个条件下第一个是CPU的Cache机制上,这使得通常在内存的之间的数据搬运消耗非常小,第二个是SMP上计算单元相对的少,因此每个计算
单元被分配到的任务就相对的重。其开销远远大于通信的开销,因此这种机制在SMP上相对的划算.但是如果你要在GPU上做Work Stealing就
完全不可行,因为GPU的运算单元数量极多,被分配到的任务就相对来说的非常轻量,CUDA上的一个thread很多时候运算一次的时间不会超过
10us,而一次跨Block的线程之间的通信开销就往往要达到100us左右,再加上目前GPU上的Cache机制非常落后导致了需要频繁的通信开销
的Work Stealing在GPU上是非常不划算得.
所以我个人认为在硬件架构没有更多的突破之前,OpenCL这种东西是没有任何生命力的.不要说CPU的并行与GPU之间差异巨大,就是不同的GPU之
间AMD与Nvidia两个也是各自为政,一个平台上跑得非常快的东西,在另外一个平台极大的可能是龟速.其最终的结果估计就是跟Java的
write once run everywhere一样是个大笑话.</p>
<p>On 3月22日, 下午2时06分, Guancheng Chen <a href="&#x6d;&#x61;&#105;&#x6c;&#x74;&#111;&#x3a;&#91;&#99;&#x68;&#x65;&#x6e;&#x67;&#117;&#97;&#x6e;&#x63;&#x68;&#x2e;&#x2e;&#46;&#x40;&#103;&#109;&#97;&#x69;&#108;&#46;&#x63;&#111;&#x6d;&#x5d;&#x28;&#x29;">&#91;&#99;&#x68;&#x65;&#x6e;&#x67;&#117;&#97;&#x6e;&#x63;&#x68;&#x2e;&#x2e;&#46;&#x40;&#103;&#109;&#97;&#x69;&#108;&#46;&#x63;&#111;&#x6d;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>On 3月22日, 上午2时20分, Tinyfool <a href="&#x6d;&#97;&#105;&#108;&#116;&#111;&#x3a;&#91;&#x74;&#105;&#x6e;&#x79;&#x66;&#46;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#105;&#108;&#46;&#x63;&#111;&#x6d;&#93;&#x28;&#x29;">&#91;&#x74;&#105;&#x6e;&#x79;&#x66;&#46;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#105;&#108;&#46;&#x63;&#111;&#x6d;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#109;&#x61;&#105;&#108;&#x74;&#111;&#x3a;&#x5b;&#106;&#x65;&#46;&#x2e;&#x2e;&#x40;&#x6c;&#105;&#x76;&#101;&#x2e;&#99;&#x6f;&#x6d;&#93;&#40;&#x29;">&#x5b;&#106;&#x65;&#46;&#x2e;&#x2e;&#x40;&#x6c;&#105;&#x76;&#101;&#x2e;&#99;&#x6f;&#x6d;&#93;&#40;&#x29;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#109;&#x61;&#105;&#108;&#x74;&#111;&#x3a;&#x5b;&#x63;&#104;&#x65;&#110;&#x67;&#x75;&#97;&#110;&#99;&#x68;&#46;&#46;&#46;&#x40;&#103;&#x6d;&#x61;&#x69;&#108;&#46;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#41;">&#x5b;&#x63;&#104;&#x65;&#110;&#x67;&#x75;&#97;&#110;&#99;&#x68;&#46;&#46;&#46;&#x40;&#103;&#x6d;&#x61;&#x69;&#108;&#46;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#41;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#x6d;&#97;&#x69;&#x6c;&#116;&#111;&#58;&#91;&#112;&#111;&#110;&#46;&#46;&#x2e;&#x40;&#103;&#x6f;&#111;&#x67;&#108;&#101;&#x67;&#x72;&#111;&#117;&#112;&#115;&#x2e;&#99;&#111;&#x6d;&#93;&#x28;&#x29;">&#91;&#112;&#111;&#110;&#46;&#46;&#x2e;&#x40;&#103;&#x6f;&#111;&#x67;&#108;&#101;&#x67;&#x72;&#111;&#117;&#112;&#115;&#x2e;&#99;&#111;&#x6d;&#93;&#x28;&#x29;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？...</li>
</ol>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>阅读更多 &gt;&gt;
<a href="">显示删减掉的内容</a>
<img src="" alt=""> windstorm <img src="" alt=""></p>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-23</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>Larrabee当初我还是很看好的，它的架构比其他的更像一个统一的方案，可惜后来Intel自己经验不足搞不好。</p>
<p>OPENCL还是主要面向multimedia吧，CUDA/OpenCL在业界代表了流处理的方向，从GPU针对任务的角度讲是好的。其他的就算了。就像Alleluia说的那样，在硬件架构没有更多的突破之前，不说没有生命力，至少想取得任何进一步的突破都太难。</p>
<p>现在这个领域，你吹你的水，我吹我的水。至于谁的泡泡大，我看不清。所以真要选东西学，最好还是针对自己的application选靠谱。这也是并行编程教育难的问题。大家需求完全不一样。</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p><a href="http://www.kunli.info/" target="_blank">www.kunli.info</a>
<a href="http://twitter.com/cnbuff" target="_blank"><a href="http://twitter.com/cnbuff">http://twitter.com/cnbuff</a></a></p>
<p>2010/3/22 Guancheng Chen <a href="&#109;&#x61;&#105;&#x6c;&#116;&#111;&#58;&#91;&#99;&#x68;&#x65;&#110;&#x67;&#117;&#x2e;&#x2e;&#46;&#x40;&#x67;&#x6d;&#x61;&#x69;&#108;&#46;&#99;&#111;&#x6d;&#x5d;&#40;&#41;">&#91;&#99;&#x68;&#x65;&#110;&#x67;&#117;&#x2e;&#x2e;&#46;&#x40;&#x67;&#x6d;&#x61;&#x69;&#108;&#46;&#99;&#111;&#x6d;&#x5d;&#40;&#41;</a>:</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<blockquote>
<p>我觉得现有的OpenCL确实非常不成熟，但是从纯性能角度上来讲，我看好Heterogeneous架构，尽管它们的编程难度太大，就像前面提到的不
同架构需要做不同优化等。CPU的性能是latency-oriented，GPU是throughput-oriented,Intel的
Larrabee虽然现在来看不成功，但是业界都在朝着那个方向努力。</p>
<p>On 3月22日, 下午6时18分, windstorm <a href="&#109;&#x61;&#x69;&#108;&#116;&#111;&#58;&#91;&#108;&#x69;&#107;&#x75;&#110;&#97;&#114;&#x6d;&#115;&#116;&#114;&#46;&#x2e;&#46;&#x40;&#103;&#x6d;&#97;&#x69;&#108;&#46;&#x63;&#111;&#x6d;&#x5d;&#x28;&#x29;">&#91;&#108;&#x69;&#107;&#x75;&#110;&#97;&#114;&#x6d;&#115;&#116;&#114;&#46;&#x2e;&#46;&#x40;&#103;&#x6d;&#97;&#x69;&#108;&#46;&#x63;&#111;&#x6d;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>实在是不能同意你更多......很早很早以前我就在这里和人争论过，GPU的并行计算平台不可能一统天下的。CUDA也不是救世主。OpenCL更不是。</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Alleluia <a href="&#x6d;&#97;&#x69;&#x6c;&#x74;&#111;&#x3a;&#91;&#x61;&#x6c;&#108;&#117;&#108;&#46;&#x2e;&#46;&#x40;&#103;&#x6d;&#97;&#105;&#x6c;&#x2e;&#x63;&#111;&#109;&#x5d;&#40;&#41;">&#91;&#x61;&#x6c;&#108;&#117;&#108;&#46;&#x2e;&#46;&#x40;&#103;&#x6d;&#97;&#105;&#x6c;&#x2e;&#x63;&#111;&#109;&#x5d;&#40;&#41;</a>:</p>
<blockquote>
<p>Parallelism 说到底是算法问题.Parallelism与Concurrency不同,Concurrency所面对的问题相对的单一可以
让一群有经验的专家来实现一套通用库或者语言来提供一个基本的编程框架.而在Parallelism上,具体的不同问题,其所需要并行的算法是根本不同
的.原因在于不同的问题,其内部的DataDependency的结构完全不同,不同的Data Dependency的结构,需要构造不同的算法.即
便是相同的Data Dependency,在不同的颗粒度下，在不同的硬件条件下所采用的算法也是完全不同的.因为一旦出现Data
Dependency也就意味着并行计算模块之间需要进行通信.从以计算节点为单位的分布式并行,到多核CPU上的Numa结构,到SIMD上的向量处
理器,其计算单元之间的通信手段,通信效率简直天差地别.比如说,在SMP上最常见的并行算法,work stealing也就是Intel的TBB,
是建立在两个条件下第一个是CPU的Cache机制上,这使得通常在内存的之间的数据搬运消耗非常小,第二个是SMP上计算单元相对的少,因此每个计算
单元被分配到的任务就相对的重。其开销远远大于通信的开销,因此这种机制在SMP上相对的划算.但是如果你要在GPU上做Work Stealing就
完全不可行,因为GPU的运算单元数量极多,被分配到的任务就相对来说的非常轻量,CUDA上的一个thread很多时候运算一次的时间不会超过
10us,而一次跨Block的线程之间的通信开销就往往要达到100us左右,再加上目前GPU上的Cache机制非常落后导致了需要频繁的通信开销
的Work Stealing在GPU上是非常不划算得.
所以我个人认为在硬件架构没有更多的突破之前,OpenCL这种东西是没有任何生命力的.不要说CPU的并行与GPU之间差异巨大,就是不同的GPU之
间AMD与Nvidia两个也是各自为政,一个平台上跑得非常快的东西,在另外一个平台极大的可能是龟速.其最终的结果估计就是跟Java的
write once run everywhere一样是个大笑话.</p>
<p>On 3月22日, 下午2时06分, Guancheng Chen <a href="&#x6d;&#x61;&#x69;&#x6c;&#116;&#x6f;&#58;&#x5b;&#x63;&#x68;&#101;&#x6e;&#x67;&#x75;&#x61;&#110;&#99;&#x68;&#46;&#x2e;&#46;&#x40;&#x67;&#x6d;&#x61;&#x69;&#108;&#x2e;&#99;&#x6f;&#x6d;&#93;&#40;&#41;">&#x5b;&#x63;&#x68;&#101;&#x6e;&#x67;&#x75;&#x61;&#110;&#99;&#x68;&#46;&#x2e;&#46;&#x40;&#x67;&#x6d;&#x61;&#x69;&#108;&#x2e;&#99;&#x6f;&#x6d;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>On 3月22日, 上午2时20分, Tinyfool <a href="&#x6d;&#97;&#105;&#x6c;&#x74;&#x6f;&#x3a;&#91;&#x74;&#105;&#x6e;&#x79;&#x66;&#x2e;&#46;&#46;&#64;&#103;&#109;&#97;&#105;&#x6c;&#x2e;&#x63;&#111;&#109;&#93;&#x28;&#x29;">&#91;&#x74;&#105;&#x6e;&#x79;&#x66;&#x2e;&#46;&#46;&#64;&#103;&#109;&#97;&#105;&#x6c;&#x2e;&#x63;&#111;&#109;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#x6d;&#x61;&#105;&#x6c;&#x74;&#111;&#58;&#x5b;&#x6a;&#101;&#46;&#x2e;&#x2e;&#x40;&#108;&#105;&#x76;&#101;&#46;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#x29;">&#x5b;&#x6a;&#101;&#46;&#x2e;&#x2e;&#x40;&#108;&#105;&#x76;&#101;&#46;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#x29;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#x6d;&#97;&#x69;&#108;&#x74;&#111;&#x3a;&#91;&#99;&#104;&#101;&#110;&#103;&#117;&#x61;&#x6e;&#x63;&#104;&#x2e;&#x2e;&#46;&#x40;&#103;&#x6d;&#97;&#105;&#x6c;&#x2e;&#99;&#111;&#x6d;&#x5d;&#40;&#x29;">&#91;&#99;&#104;&#101;&#110;&#103;&#117;&#x61;&#x6e;&#x63;&#104;&#x2e;&#x2e;&#46;&#x40;&#103;&#x6d;&#97;&#105;&#x6c;&#x2e;&#99;&#111;&#x6d;&#x5d;&#40;&#x29;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#x6d;&#x61;&#105;&#108;&#116;&#x6f;&#x3a;&#91;&#x70;&#x6f;&#x6e;&#46;&#x2e;&#x2e;&#64;&#103;&#111;&#111;&#103;&#108;&#101;&#x67;&#114;&#x6f;&#x75;&#112;&#115;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#40;&#x29;">&#91;&#x70;&#x6f;&#x6e;&#46;&#x2e;&#x2e;&#64;&#103;&#111;&#111;&#103;&#108;&#101;&#x67;&#114;&#x6f;&#x75;&#112;&#115;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#40;&#x29;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？...</li>
</ol>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>阅读更多 &gt;&gt;</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p><a href="">显示删减掉的内容</a></p>
</blockquote>
<p><img src="" alt=""> Alleluia <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-23</p>
<p>其他收件人：</p>
<p>对于Concurrency和Parallelism之间混乱的根源就是多线程/进程模型.Concurrrency可以用multithread/
process,也可以不用.一个单核单线程的Concurrency程序只要写的好,对于几万个并发连接不是问题.但是Parallelism必须要
用到multithread.对于Concurrency来说,multithread只是一种可选的方案.
当然,在CPU架构上Concurrency和Parallelism的很多设施都是可以复用的,比如高性能的线程池,以及细粒度的锁等等.</p>
<p>On 3月23日, 上午4时32分, windstorm <a href="&#x6d;&#97;&#105;&#x6c;&#x74;&#111;&#58;&#x5b;&#108;&#105;&#x6b;&#117;&#110;&#97;&#114;&#109;&#x73;&#116;&#x72;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#109;&#97;&#x69;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#93;&#x28;&#41;">&#x5b;&#108;&#105;&#x6b;&#117;&#110;&#97;&#114;&#109;&#x73;&#116;&#x72;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#109;&#97;&#x69;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>我觉得这两个东西，sun的多线程编程手册说得很清楚了，没必要重新定义。</p>
<p>Parallelism is a condition that arises when at least two threads are
executing simultaneously, while concurrency is a condition that exists
when at least two threads are making progress.</p>
<p>也就是说concurrency有点像更通用化，限制条件更低的parallelism，而某些case下两者完全不同。比如单核多线程程序，你可以叫它是co ncurrent
program，但不能叫它是parallel
program。Concurrency在现有体系的处理器架构下都可以做到。和Alleluia说的一样，只是一个时钟周期同步的问题。写过硬件编程的人，几 乎都算是写过concurrent
program，但很少写过parallel program</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>2010/3/22 <a href="">Juv...@gmail.com</a> <a href="&#x6d;&#97;&#x69;&#108;&#x74;&#111;&#58;&#x5b;&#106;&#117;&#118;&#46;&#46;&#46;&#64;&#103;&#x6d;&#x61;&#105;&#108;&#46;&#99;&#x6f;&#109;&#93;&#40;&#x29;">&#x5b;&#106;&#117;&#118;&#46;&#46;&#46;&#64;&#103;&#x6d;&#x61;&#105;&#108;&#46;&#99;&#x6f;&#109;&#93;&#40;&#x29;</a>:</p>
<blockquote>
<p>好像大家说的concurrency和parallelism不是一个东西？</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> Alleluia <img src="" alt=""></p>
</blockquote>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-23</p>
<p>其他收件人：</p>
<p>Heterogeneous目前来看也是一个暂时的过渡性的东西. Heterogeneous架构最大的问题还是硬件,CPU和GPU之间的
PCIE2的bus带宽太窄了.在上面来回传递一次几M的内存可能需要化掉500us左右.如果一个算法本来就是在3-4ms级别的,你要用GPU去优
化,内存带宽的消耗就占了1/10,这是非常可怕的事情.或许像AMD那种Fusion架构是一种趋势,但是目前来说没有太大的进展.貌似AMD出了一
款混合的CPU,但是貌似还没有看到有多大的优势.</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>On 3月23日, 上午5时02分, Guancheng Chen <a href="&#109;&#x61;&#105;&#x6c;&#x74;&#111;&#58;&#91;&#99;&#104;&#x65;&#x6e;&#103;&#117;&#97;&#x6e;&#99;&#x68;&#46;&#46;&#x2e;&#64;&#x67;&#109;&#97;&#105;&#108;&#46;&#x63;&#111;&#109;&#93;&#x28;&#41;">&#91;&#99;&#104;&#x65;&#x6e;&#103;&#117;&#97;&#x6e;&#99;&#x68;&#46;&#46;&#x2e;&#64;&#x67;&#109;&#97;&#105;&#108;&#46;&#x63;&#111;&#109;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>我觉得现有的OpenCL确实非常不成熟，但是从纯性能角度上来讲，我看好Heterogeneous架构，尽管它们的编程难度太大，就像前面提到的不
同架构需要做不同优化等。CPU的性能是latency-oriented，GPU是throughput-oriented,Intel的
Larrabee虽然现在来看不成功，但是业界都在朝着那个方向努力。</p>
<p>On 3月22日, 下午6时18分, windstorm <a href="&#109;&#97;&#105;&#x6c;&#x74;&#x6f;&#x3a;&#91;&#x6c;&#105;&#107;&#x75;&#x6e;&#97;&#114;&#x6d;&#x73;&#116;&#114;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#109;&#x61;&#x69;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#93;&#40;&#41;">&#91;&#x6c;&#105;&#107;&#x75;&#x6e;&#97;&#114;&#x6d;&#x73;&#116;&#114;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#109;&#x61;&#x69;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>实在是不能同意你更多......很早很早以前我就在这里和人争论过，GPU的并行计算平台不可能一统天下的。CUDA也不是救世主。OpenCL更不是。</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Alleluia <a href="&#x6d;&#x61;&#x69;&#108;&#116;&#x6f;&#x3a;&#x5b;&#97;&#108;&#x6c;&#117;&#x6c;&#46;&#46;&#x2e;&#64;&#x67;&#109;&#97;&#105;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#93;&#40;&#41;">&#x5b;&#97;&#108;&#x6c;&#117;&#x6c;&#46;&#46;&#x2e;&#64;&#x67;&#109;&#97;&#105;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#93;&#40;&#41;</a>:</p>
<blockquote>
<p>Parallelism 说到底是算法问题.Parallelism与Concurrency不同,Concurrency所面对的问题相对的单一可以
让一群有经验的专家来实现一套通用库或者语言来提供一个基本的编程框架.而在Parallelism上,具体的不同问题,其所需要并行的算法是根本不同
的.原因在于不同的问题,其内部的DataDependency的结构完全不同,不同的Data Dependency的结构,需要构造不同的算法.即
便是相同的Data Dependency,在不同的颗粒度下，在不同的硬件条件下所采用的算法也是完全不同的.因为一旦出现Data
Dependency也就意味着并行计算模块之间需要进行通信.从以计算节点为单位的分布式并行,到多核CPU上的Numa结构,到SIMD上的向量处
理器,其计算单元之间的通信手段,通信效率简直天差地别.比如说,在SMP上最常见的并行算法,work stealing也就是Intel的TBB,
是建立在两个条件下第一个是CPU的Cache机制上,这使得通常在内存的之间的数据搬运消耗非常小,第二个是SMP上计算单元相对的少,因此每个计算
单元被分配到的任务就相对的重。其开销远远大于通信的开销,因此这种机制在SMP上相对的划算.但是如果你要在GPU上做Work Stealing就
完全不可行,因为GPU的运算单元数量极多,被分配到的任务就相对来说的非常轻量,CUDA上的一个thread很多时候运算一次的时间不会超过
10us,而一次跨Block的线程之间的通信开销就往往要达到100us左右,再加上目前GPU上的Cache机制非常落后导致了需要频繁的通信开销
的Work Stealing在GPU上是非常不划算得.
所以我个人认为在硬件架构没有更多的突破之前,OpenCL这种东西是没有任何生命力的.不要说CPU的并行与GPU之间差异巨大,就是不同的GPU之
间AMD与Nvidia两个也是各自为政,一个平台上跑得非常快的东西,在另外一个平台极大的可能是龟速.其最终的结果估计就是跟Java的
write once run everywhere一样是个大笑话.</p>
<p>On 3月22日, 下午2时06分, Guancheng Chen <a href="&#109;&#x61;&#105;&#x6c;&#x74;&#111;&#58;&#91;&#x63;&#x68;&#x65;&#x6e;&#x67;&#117;&#x61;&#x6e;&#x63;&#104;&#46;&#x2e;&#x2e;&#64;&#x67;&#109;&#97;&#x69;&#108;&#46;&#x63;&#x6f;&#109;&#x5d;&#40;&#41;">&#91;&#x63;&#x68;&#x65;&#x6e;&#x67;&#117;&#x61;&#x6e;&#x63;&#104;&#46;&#x2e;&#x2e;&#64;&#x67;&#109;&#97;&#x69;&#108;&#46;&#x63;&#x6f;&#109;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>On 3月22日, 上午2时20分, Tinyfool <a href="&#109;&#x61;&#x69;&#x6c;&#x74;&#111;&#58;&#x5b;&#x74;&#x69;&#110;&#121;&#102;&#x2e;&#46;&#46;&#x40;&#x67;&#109;&#x61;&#x69;&#108;&#x2e;&#99;&#111;&#x6d;&#x5d;&#x28;&#x29;">&#x5b;&#x74;&#x69;&#110;&#121;&#102;&#x2e;&#46;&#46;&#x40;&#x67;&#109;&#x61;&#x69;&#108;&#x2e;&#99;&#111;&#x6d;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#x6d;&#97;&#105;&#x6c;&#116;&#x6f;&#58;&#91;&#x6a;&#101;&#46;&#46;&#x2e;&#64;&#x6c;&#105;&#118;&#x65;&#46;&#x63;&#111;&#109;&#x5d;&#x28;&#x29;">&#91;&#x6a;&#101;&#46;&#46;&#x2e;&#64;&#x6c;&#105;&#118;&#x65;&#46;&#x63;&#111;&#109;&#x5d;&#x28;&#x29;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#x6d;&#x61;&#105;&#x6c;&#x74;&#111;&#58;&#91;&#x63;&#x68;&#101;&#110;&#x67;&#x75;&#x61;&#110;&#x63;&#104;&#x2e;&#x2e;&#46;&#64;&#103;&#x6d;&#97;&#105;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#40;&#41;">&#91;&#x63;&#x68;&#101;&#110;&#x67;&#x75;&#x61;&#110;&#x63;&#104;&#x2e;&#x2e;&#46;&#64;&#103;&#x6d;&#97;&#105;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#40;&#41;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#109;&#97;&#x69;&#x6c;&#116;&#x6f;&#58;&#x5b;&#112;&#111;&#110;&#46;&#x2e;&#46;&#x40;&#x67;&#x6f;&#111;&#x67;&#x6c;&#101;&#x67;&#x72;&#x6f;&#x75;&#x70;&#x73;&#46;&#99;&#111;&#109;&#93;&#x28;&#x29;">&#x5b;&#112;&#111;&#110;&#46;&#x2e;&#46;&#x40;&#x67;&#x6f;&#111;&#x67;&#x6c;&#101;&#x67;&#x72;&#x6f;&#x75;&#x70;&#x73;&#46;&#99;&#111;&#109;&#93;&#x28;&#x29;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>...</p>
<p>阅读更多 &gt;&gt;
<a href="">显示删减掉的内容</a></p>
</blockquote>
<p><img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-23</p>
<p>其他收件人：</p>
<p>恩 您也是搞体系结构的么？
现在我在跟瑞典这边的爱立信合作做毕设 不过对象不是他们的Erlang 而是传统的C/C++程序 下半年可能我也去搞GPGPU了 因为它的
data parallel模型对遗留代码的并行化很有搞头，现在我粗略的想法是把Compute sensitive的任务放一部分到GPU上去做，
当然我也对GPU目前的一些限制有所了解 但是一些探索工作还是非常值得的 到时候还想向前辈多多请教</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>On 3月22日, 下午11时30分, Alleluia <a href="&#109;&#97;&#x69;&#108;&#116;&#x6f;&#58;&#x5b;&#x61;&#x6c;&#x6c;&#117;&#x6c;&#x2e;&#46;&#x2e;&#64;&#103;&#109;&#x61;&#105;&#x6c;&#x2e;&#99;&#x6f;&#109;&#x5d;&#x28;&#x29;">&#x5b;&#x61;&#x6c;&#x6c;&#117;&#x6c;&#x2e;&#46;&#x2e;&#64;&#103;&#109;&#x61;&#105;&#x6c;&#x2e;&#99;&#x6f;&#109;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>Heterogeneous目前来看也是一个暂时的过渡性的东西. Heterogeneous架构最大的问题还是硬件,CPU和GPU之间的
PCIE2的bus带宽太窄了.在上面来回传递一次几M的内存可能需要化掉500us左右.如果一个算法本来就是在3-4ms级别的,你要用GPU去优
化,内存带宽的消耗就占了1/10,这是非常可怕的事情.或许像AMD那种Fusion架构是一种趋势,但是目前来说没有太大的进展.貌似AMD出了一
款混合的CPU,但是貌似还没有看到有多大的优势.
On 3月23日, 上午5时02分, Guancheng Chen <a href="&#109;&#97;&#105;&#108;&#116;&#x6f;&#58;&#91;&#99;&#x68;&#101;&#x6e;&#103;&#117;&#x61;&#x6e;&#99;&#x68;&#x2e;&#x2e;&#46;&#x40;&#103;&#109;&#97;&#105;&#x6c;&#46;&#99;&#111;&#109;&#93;&#x28;&#41;">&#91;&#99;&#x68;&#101;&#x6e;&#103;&#117;&#x61;&#x6e;&#99;&#x68;&#x2e;&#x2e;&#46;&#x40;&#103;&#109;&#97;&#105;&#x6c;&#46;&#99;&#111;&#109;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>我觉得现有的OpenCL确实非常不成熟，但是从纯性能角度上来讲，我看好Heterogeneous架构，尽管它们的编程难度太大，就像前面提到的不
同架构需要做不同优化等。CPU的性能是latency-oriented，GPU是throughput-oriented,Intel的
Larrabee虽然现在来看不成功，但是业界都在朝着那个方向努力。</p>
<p>On 3月22日, 下午6时18分, windstorm <a href="&#x6d;&#97;&#105;&#108;&#116;&#x6f;&#58;&#x5b;&#108;&#105;&#x6b;&#x75;&#x6e;&#x61;&#x72;&#x6d;&#x73;&#116;&#114;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#x61;&#105;&#108;&#46;&#99;&#x6f;&#109;&#x5d;&#x28;&#41;">&#x5b;&#108;&#105;&#x6b;&#x75;&#x6e;&#x61;&#x72;&#x6d;&#x73;&#116;&#114;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#x61;&#105;&#108;&#46;&#99;&#x6f;&#109;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>实在是不能同意你更多......很早很早以前我就在这里和人争论过，GPU的并行计算平台不可能一统天下的。CUDA也不是救世主。OpenCL更不是。</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Alleluia <a href="&#109;&#97;&#x69;&#108;&#x74;&#x6f;&#x3a;&#x5b;&#x61;&#x6c;&#108;&#117;&#x6c;&#x2e;&#46;&#x2e;&#x40;&#103;&#109;&#x61;&#105;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#93;&#x28;&#41;">&#x5b;&#x61;&#x6c;&#108;&#117;&#x6c;&#x2e;&#46;&#x2e;&#x40;&#103;&#109;&#x61;&#105;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#93;&#x28;&#41;</a>:</p>
<blockquote>
<p>Parallelism 说到底是算法问题.Parallelism与Concurrency不同,Concurrency所面对的问题相对的单一可以
让一群有经验的专家来实现一套通用库或者语言来提供一个基本的编程框架.而在Parallelism上,具体的不同问题,其所需要并行的算法是根本不同
的.原因在于不同的问题,其内部的DataDependency的结构完全不同,不同的Data Dependency的结构,需要构造不同的算法.即
便是相同的Data Dependency,在不同的颗粒度下，在不同的硬件条件下所采用的算法也是完全不同的.因为一旦出现Data
Dependency也就意味着并行计算模块之间需要进行通信.从以计算节点为单位的分布式并行,到多核CPU上的Numa结构,到SIMD上的向量处
理器,其计算单元之间的通信手段,通信效率简直天差地别.比如说,在SMP上最常见的并行算法,work stealing也就是Intel的TBB,
是建立在两个条件下第一个是CPU的Cache机制上,这使得通常在内存的之间的数据搬运消耗非常小,第二个是SMP上计算单元相对的少,因此每个计算
单元被分配到的任务就相对的重。其开销远远大于通信的开销,因此这种机制在SMP上相对的划算.但是如果你要在GPU上做Work Stealing就
完全不可行,因为GPU的运算单元数量极多,被分配到的任务就相对来说的非常轻量,CUDA上的一个thread很多时候运算一次的时间不会超过
10us,而一次跨Block的线程之间的通信开销就往往要达到100us左右,再加上目前GPU上的Cache机制非常落后导致了需要频繁的通信开销
的Work Stealing在GPU上是非常不划算得.
所以我个人认为在硬件架构没有更多的突破之前,OpenCL这种东西是没有任何生命力的.不要说CPU的并行与GPU之间差异巨大,就是不同的GPU之
间AMD与Nvidia两个也是各自为政,一个平台上跑得非常快的东西,在另外一个平台极大的可能是龟速.其最终的结果估计就是跟Java的
write once run everywhere一样是个大笑话.</p>
<p>On 3月22日, 下午2时06分, Guancheng Chen <a href="&#x6d;&#97;&#x69;&#108;&#116;&#111;&#58;&#91;&#99;&#104;&#101;&#x6e;&#103;&#117;&#97;&#x6e;&#x63;&#x68;&#x2e;&#46;&#46;&#64;&#103;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#99;&#111;&#109;&#x5d;&#40;&#41;">&#91;&#99;&#104;&#101;&#x6e;&#103;&#117;&#97;&#x6e;&#x63;&#x68;&#x2e;&#46;&#46;&#64;&#103;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#99;&#111;&#109;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>On 3月22日, 上午2时20分, Tinyfool <a href="&#109;&#97;&#105;&#x6c;&#116;&#x6f;&#58;&#91;&#116;&#105;&#110;&#x79;&#102;&#x2e;&#46;&#x2e;&#64;&#x67;&#109;&#x61;&#x69;&#108;&#x2e;&#x63;&#111;&#109;&#x5d;&#x28;&#x29;">&#91;&#116;&#105;&#110;&#x79;&#102;&#x2e;&#46;&#x2e;&#64;&#x67;&#109;&#x61;&#x69;&#108;&#x2e;&#x63;&#111;&#109;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#109;&#x61;&#x69;&#x6c;&#116;&#111;&#x3a;&#91;&#106;&#x65;&#x2e;&#x2e;&#x2e;&#64;&#x6c;&#x69;&#118;&#101;&#46;&#99;&#x6f;&#109;&#93;&#x28;&#41;">&#91;&#106;&#x65;&#x2e;&#x2e;&#x2e;&#64;&#x6c;&#x69;&#118;&#101;&#46;&#99;&#x6f;&#109;&#93;&#x28;&#41;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#x6d;&#x61;&#105;&#x6c;&#116;&#x6f;&#x3a;&#x5b;&#x63;&#x68;&#101;&#110;&#x67;&#x75;&#97;&#x6e;&#x63;&#104;&#46;&#46;&#46;&#64;&#x67;&#109;&#x61;&#x69;&#108;&#46;&#x63;&#111;&#x6d;&#x5d;&#40;&#x29;">&#x5b;&#x63;&#x68;&#101;&#110;&#x67;&#x75;&#97;&#x6e;&#x63;&#104;&#46;&#46;&#46;&#64;&#x67;&#109;&#x61;&#x69;&#108;&#46;&#x63;&#111;&#x6d;&#x5d;&#40;&#x29;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#109;&#97;&#105;&#108;&#x74;&#x6f;&#58;&#91;&#x70;&#111;&#x6e;&#46;&#46;&#x2e;&#64;&#103;&#x6f;&#111;&#x67;&#108;&#x65;&#x67;&#114;&#x6f;&#x75;&#x70;&#x73;&#x2e;&#99;&#x6f;&#x6d;&#93;&#x28;&#x29;">&#91;&#x70;&#111;&#x6e;&#46;&#46;&#x2e;&#64;&#103;&#x6f;&#111;&#x67;&#108;&#x65;&#x67;&#114;&#x6f;&#x75;&#x70;&#x73;&#x2e;&#99;&#x6f;&#x6d;&#93;&#x28;&#x29;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。...</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>阅读更多 &gt;&gt;
<a href="">显示删减掉的内容</a>
<img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-23</p>
<p>其他收件人：</p>
<p>教育以人为本，最终决定使用何种并行技术的还是程序员。目前业界对程序员并没有并行编程的技能要求，全民并行编程的时代什么时候才能到来？这是个问
题。</p>
<p>On 3月22日, 下午10时41分, windstorm <a href="&#109;&#97;&#x69;&#108;&#x74;&#x6f;&#x3a;&#91;&#x6c;&#x69;&#x6b;&#117;&#x6e;&#97;&#x72;&#x6d;&#115;&#x74;&#114;&#46;&#46;&#46;&#x40;&#103;&#x6d;&#97;&#105;&#108;&#x2e;&#99;&#111;&#x6d;&#x5d;&#40;&#x29;">&#91;&#x6c;&#x69;&#x6b;&#117;&#x6e;&#97;&#x72;&#x6d;&#115;&#x74;&#114;&#46;&#46;&#46;&#x40;&#103;&#x6d;&#97;&#105;&#108;&#x2e;&#99;&#111;&#x6d;&#x5d;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>Larrabee当初我还是很看好的，它的架构比其他的更像一个统一的方案，可惜后来Intel自己经验不足搞不好。</p>
<p>OPENCL还是主要面向multimedia吧，CUDA/OpenCL在业界代表了流处理的方向，从GPU针对任务的角度讲是好的。其他的就算了。就像Al leluia说的那样，在硬件架构没有更多的突破之前，不说没有生命力，至少想取得任何进一步的突破都太难。</p>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>现在这个领域，你吹你的水，我吹我的水。至于谁的泡泡大，我看不清。所以真要选东西学，最好还是针对自己的application选靠谱。这也是并行编程教育难 的问题。大家需求完全不一样。</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Guancheng Chen <a href="&#x6d;&#x61;&#x69;&#x6c;&#116;&#111;&#x3a;&#x5b;&#99;&#104;&#101;&#110;&#103;&#x75;&#x61;&#110;&#99;&#104;&#46;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#x61;&#x69;&#108;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#40;&#41;">&#x5b;&#99;&#104;&#101;&#110;&#103;&#x75;&#x61;&#110;&#99;&#104;&#46;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#x61;&#x69;&#108;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#40;&#41;</a>:</p>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>&gt;
&gt;
&gt;</p>
<blockquote>
<blockquote>
<p>我觉得现有的OpenCL确实非常不成熟，但是从纯性能角度上来讲，我看好Heterogeneous架构，尽管它们的编程难度太大，就像前面提到的不
同架构需要做不同优化等。CPU的性能是latency-oriented，GPU是throughput-oriented,Intel的
Larrabee虽然现在来看不成功，但是业界都在朝着那个方向努力。</p>
<p>On 3月22日, 下午6时18分, windstorm <a href="&#x6d;&#x61;&#x69;&#108;&#116;&#x6f;&#58;&#x5b;&#x6c;&#x69;&#x6b;&#117;&#x6e;&#x61;&#x72;&#x6d;&#115;&#x74;&#x72;&#46;&#x2e;&#46;&#64;&#103;&#109;&#x61;&#x69;&#x6c;&#x2e;&#99;&#111;&#x6d;&#93;&#40;&#41;">&#x5b;&#x6c;&#x69;&#x6b;&#117;&#x6e;&#x61;&#x72;&#x6d;&#115;&#x74;&#x72;&#46;&#x2e;&#46;&#64;&#103;&#109;&#x61;&#x69;&#x6c;&#x2e;&#99;&#111;&#x6d;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>实在是不能同意你更多......很早很早以前我就在这里和人争论过，GPU的并行计算平台不可能一统天下的。CUDA也不是救世主。OpenCL更不是。</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Alleluia <a href="&#x6d;&#97;&#105;&#108;&#x74;&#x6f;&#58;&#x5b;&#x61;&#108;&#x6c;&#x75;&#108;&#46;&#46;&#x2e;&#x40;&#103;&#x6d;&#97;&#x69;&#108;&#x2e;&#99;&#111;&#109;&#x5d;&#x28;&#41;">&#x5b;&#x61;&#108;&#x6c;&#x75;&#108;&#46;&#46;&#x2e;&#x40;&#103;&#x6d;&#97;&#x69;&#108;&#x2e;&#99;&#111;&#109;&#x5d;&#x28;&#41;</a>:</p>
<blockquote>
<p>Parallelism 说到底是算法问题.Parallelism与Concurrency不同,Concurrency所面对的问题相对的单一可以
让一群有经验的专家来实现一套通用库或者语言来提供一个基本的编程框架.而在Parallelism上,具体的不同问题,其所需要并行的算法是根本不同
的.原因在于不同的问题,其内部的DataDependency的结构完全不同,不同的Data Dependency的结构,需要构造不同的算法.即
便是相同的Data Dependency,在不同的颗粒度下，在不同的硬件条件下所采用的算法也是完全不同的.因为一旦出现Data
Dependency也就意味着并行计算模块之间需要进行通信.从以计算节点为单位的分布式并行,到多核CPU上的Numa结构,到SIMD上的向量处
理器,其计算单元之间的通信手段,通信效率简直天差地别.比如说,在SMP上最常见的并行算法,work stealing也就是Intel的TBB,
是建立在两个条件下第一个是CPU的Cache机制上,这使得通常在内存的之间的数据搬运消耗非常小,第二个是SMP上计算单元相对的少,因此每个计算
单元被分配到的任务就相对的重。其开销远远大于通信的开销,因此这种机制在SMP上相对的划算.但是如果你要在GPU上做Work Stealing就
完全不可行,因为GPU的运算单元数量极多,被分配到的任务就相对来说的非常轻量,CUDA上的一个thread很多时候运算一次的时间不会超过
10us,而一次跨Block的线程之间的通信开销就往往要达到100us左右,再加上目前GPU上的Cache机制非常落后导致了需要频繁的通信开销
的Work Stealing在GPU上是非常不划算得.
所以我个人认为在硬件架构没有更多的突破之前,OpenCL这种东西是没有任何生命力的.不要说CPU的并行与GPU之间差异巨大,就是不同的GPU之
间AMD与Nvidia两个也是各自为政,一个平台上跑得非常快的东西,在另外一个平台极大的可能是龟速.其最终的结果估计就是跟Java的
write once run everywhere一样是个大笑话.</p>
<p>On 3月22日, 下午2时06分, Guancheng Chen <a href="&#x6d;&#97;&#x69;&#108;&#x74;&#111;&#58;&#x5b;&#x63;&#104;&#x65;&#110;&#103;&#x75;&#97;&#110;&#x63;&#104;&#x2e;&#46;&#46;&#64;&#x67;&#109;&#x61;&#105;&#108;&#46;&#x63;&#x6f;&#109;&#x5d;&#40;&#x29;">&#x5b;&#x63;&#104;&#x65;&#110;&#103;&#x75;&#97;&#110;&#x63;&#104;&#x2e;&#46;&#46;&#64;&#x67;&#109;&#x61;&#105;&#108;&#46;&#x63;&#x6f;&#109;&#x5d;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>On 3月22日, 上午2时20分, Tinyfool <a href="&#109;&#97;&#x69;&#108;&#x74;&#x6f;&#58;&#x5b;&#x74;&#105;&#110;&#x79;&#x66;&#46;&#x2e;&#x2e;&#x40;&#103;&#109;&#97;&#x69;&#x6c;&#46;&#x63;&#x6f;&#109;&#x5d;&#40;&#41;">&#x5b;&#x74;&#105;&#110;&#x79;&#x66;&#46;&#x2e;&#x2e;&#x40;&#103;&#109;&#97;&#x69;&#x6c;&#46;&#x63;&#x6f;&#109;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#109;&#x61;&#x69;&#x6c;&#116;&#111;&#58;&#91;&#106;&#x65;&#46;&#46;&#46;&#x40;&#x6c;&#105;&#118;&#x65;&#x2e;&#x63;&#111;&#109;&#93;&#40;&#41;">&#91;&#106;&#x65;&#46;&#46;&#46;&#x40;&#x6c;&#105;&#118;&#x65;&#x2e;&#x63;&#111;&#109;&#93;&#40;&#41;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#109;&#x61;&#105;&#108;&#x74;&#111;&#x3a;&#91;&#x63;&#104;&#x65;&#x6e;&#x67;&#x75;&#x61;&#110;&#x63;&#x68;&#46;&#46;&#x2e;&#64;&#103;&#109;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#x28;&#41;">&#91;&#x63;&#104;&#x65;&#x6e;&#x67;&#x75;&#x61;&#110;&#x63;&#x68;&#46;&#46;&#x2e;&#64;&#103;&#109;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#x28;&#41;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#x6d;&#97;&#x69;&#108;&#116;&#111;&#58;&#91;&#112;&#x6f;&#x6e;&#x2e;&#x2e;&#46;&#x40;&#103;&#x6f;&#x6f;&#103;&#x6c;&#x65;&#x67;&#x72;&#111;&#x75;&#x70;&#115;&#x2e;&#x63;&#x6f;&#109;&#93;&#x28;&#41;">&#91;&#112;&#x6f;&#x6e;&#x2e;&#x2e;&#46;&#x40;&#103;&#x6f;&#x6f;&#103;&#x6c;&#x65;&#x67;&#x72;&#111;&#x75;&#x70;&#115;&#x2e;&#x63;&#x6f;&#109;&#93;&#x28;&#41;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线...</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>阅读更多 &gt;&gt;
<a href="">显示删减掉的内容</a></p>
</blockquote>
<p><img src="" alt=""> windstorm <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-23</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>全民并行编程的时代，只有在全民能够并行编程的时候才会到来嘛，现在不是这个时候</p>
<p>我个人倾向于等待一个比较好的统一性架构。两条路：</p>
<p>一是某一个全新概念的提出，这个要看学术界的努力，而且在某种意义上讲，学术界搞出一个真正可行的并行架构的可能性比工业界更高。虽说今天多核的发展是工业界引领的，但是点子还是最早学术界提出的。典型的有几个：斯坦福的Hydra（1996），斯坦福的Imagine(2000)，MIT的RAW（2002），以及UT奥斯丁的TRIPS（2003）。在这个问题上，是不得不佩服美国的创造力，要知道直到在2000年左右，所有的人都还在为处理器频率按照摩尔定律翻翻而狂热，美国的顶尖研究员就早已看到了这条路的尽头并指出未来处理器的发展之路。</p>
<p>二是你用现有的架构，但是application引导。如果要找一个面向多application
domain的话，刚才说了，本来看好Larrabee，因为它的架构解决了CUDA一个很大的潜在问题，而且允许现有程序员不经过任何特殊training就上手编程，包括图形图像，科学计算，或者网络处理，各个领域。</p>
<p>不过可能就是因为这个solution的过于理想化导致结构的过于复杂化，才让其目前暂时流产。</p>
<p>总的来说，现在的问题就是软件发展不成熟，硬件发展不完善，你没法靠程序员决定使用什么并行技术，完全靠应用主导，这套技术在这个应用上如鱼得水，在那个应用上完全不罩，作为程序员，有什么办法？</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p><a href="http://www.kunli.info/" target="_blank">www.kunli.info</a>
<a href="http://twitter.com/cnbuff" target="_blank"><a href="http://twitter.com/cnbuff">http://twitter.com/cnbuff</a></a></p>
<p>2010/3/22 Guancheng Chen <a href="&#109;&#x61;&#x69;&#108;&#116;&#x6f;&#x3a;&#91;&#x63;&#x68;&#x65;&#x6e;&#x67;&#117;&#46;&#x2e;&#46;&#x40;&#x67;&#x6d;&#x61;&#105;&#108;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#40;&#41;">&#91;&#x63;&#x68;&#x65;&#x6e;&#x67;&#117;&#46;&#x2e;&#46;&#x40;&#x67;&#x6d;&#x61;&#105;&#108;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#40;&#41;</a>:</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<blockquote>
<p>教育以人为本，最终决定使用何种并行技术的还是程序员。目前业界对程序员并没有并行编程的技能要求，全民并行编程的时代什么时候才能到来？这是个问
题。</p>
<p>On 3月22日, 下午10时41分, windstorm <a href="&#x6d;&#97;&#x69;&#108;&#116;&#x6f;&#x3a;&#x5b;&#108;&#x69;&#x6b;&#x75;&#110;&#x61;&#x72;&#109;&#x73;&#x74;&#114;&#x2e;&#46;&#x2e;&#64;&#x67;&#x6d;&#x61;&#105;&#108;&#46;&#99;&#x6f;&#109;&#93;&#40;&#x29;">&#x5b;&#108;&#x69;&#x6b;&#x75;&#110;&#x61;&#x72;&#109;&#x73;&#x74;&#114;&#x2e;&#46;&#x2e;&#64;&#x67;&#x6d;&#x61;&#105;&#108;&#46;&#99;&#x6f;&#109;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>Larrabee当初我还是很看好的，它的架构比其他的更像一个统一的方案，可惜后来Intel自己经验不足搞不好。</p>
<p>OPENCL还是主要面向multimedia吧，CUDA/OpenCL在业界代表了流处理的方向，从GPU针对任务的角度讲是好的。其他的就算了。就像Al leluia说的那样，在硬件架构没有更多的突破之前，不说没有生命力，至少想取得任何进一步的突破都太难。</p>
<p>现在这个领域，你吹你的水，我吹我的水。至于谁的泡泡大，我看不清。所以真要选东西学，最好还是针对自己的application选靠谱。这也是并行编程教育难 的问题。大家需求完全不一样。</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Guancheng Chen <a href="&#109;&#x61;&#x69;&#x6c;&#116;&#111;&#x3a;&#x5b;&#99;&#x68;&#101;&#110;&#x67;&#117;&#x61;&#110;&#99;&#x68;&#46;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#111;&#109;&#93;&#40;&#x29;">&#x5b;&#99;&#x68;&#101;&#110;&#x67;&#117;&#x61;&#110;&#99;&#x68;&#46;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#111;&#109;&#93;&#40;&#x29;</a>:</p>
<blockquote>
<p>我觉得现有的OpenCL确实非常不成熟，但是从纯性能角度上来讲，我看好Heterogeneous架构，尽管它们的编程难度太大，就像前面提到的不
同架构需要做不同优化等。CPU的性能是latency-oriented，GPU是throughput-oriented,Intel的
Larrabee虽然现在来看不成功，但是业界都在朝着那个方向努力。</p>
<p>On 3月22日, 下午6时18分, windstorm <a href="&#x6d;&#97;&#105;&#x6c;&#x74;&#x6f;&#x3a;&#91;&#x6c;&#105;&#x6b;&#x75;&#110;&#97;&#x72;&#x6d;&#x73;&#x74;&#114;&#46;&#46;&#46;&#64;&#x67;&#x6d;&#x61;&#105;&#x6c;&#46;&#x63;&#111;&#x6d;&#x5d;&#x28;&#41;">&#91;&#x6c;&#105;&#x6b;&#x75;&#110;&#97;&#x72;&#x6d;&#x73;&#x74;&#114;&#46;&#46;&#46;&#64;&#x67;&#x6d;&#x61;&#105;&#x6c;&#46;&#x63;&#111;&#x6d;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>实在是不能同意你更多......很早很早以前我就在这里和人争论过，GPU的并行计算平台不可能一统天下的。CUDA也不是救世主。OpenCL更不是。</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Alleluia <a href="&#x6d;&#x61;&#x69;&#108;&#x74;&#x6f;&#58;&#x5b;&#x61;&#108;&#108;&#117;&#x6c;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#x63;&#111;&#109;&#x5d;&#40;&#41;">&#x5b;&#x61;&#108;&#108;&#117;&#x6c;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#x63;&#111;&#109;&#x5d;&#40;&#41;</a>:</p>
<blockquote>
<p>Parallelism 说到底是算法问题.Parallelism与Concurrency不同,Concurrency所面对的问题相对的单一可以
让一群有经验的专家来实现一套通用库或者语言来提供一个基本的编程框架.而在Parallelism上,具体的不同问题,其所需要并行的算法是根本不同
的.原因在于不同的问题,其内部的DataDependency的结构完全不同,不同的Data Dependency的结构,需要构造不同的算法.即
便是相同的Data Dependency,在不同的颗粒度下，在不同的硬件条件下所采用的算法也是完全不同的.因为一旦出现Data
Dependency也就意味着并行计算模块之间需要进行通信.从以计算节点为单位的分布式并行,到多核CPU上的Numa结构,到SIMD上的向量处
理器,其计算单元之间的通信手段,通信效率简直天差地别.比如说,在SMP上最常见的并行算法,work stealing也就是Intel的TBB,
是建立在两个条件下第一个是CPU的Cache机制上,这使得通常在内存的之间的数据搬运消耗非常小,第二个是SMP上计算单元相对的少,因此每个计算
单元被分配到的任务就相对的重。其开销远远大于通信的开销,因此这种机制在SMP上相对的划算.但是如果你要在GPU上做Work Stealing就
完全不可行,因为GPU的运算单元数量极多,被分配到的任务就相对来说的非常轻量,CUDA上的一个thread很多时候运算一次的时间不会超过
10us,而一次跨Block的线程之间的通信开销就往往要达到100us左右,再加上目前GPU上的Cache机制非常落后导致了需要频繁的通信开销
的Work Stealing在GPU上是非常不划算得.
所以我个人认为在硬件架构没有更多的突破之前,OpenCL这种东西是没有任何生命力的.不要说CPU的并行与GPU之间差异巨大,就是不同的GPU之
间AMD与Nvidia两个也是各自为政,一个平台上跑得非常快的东西,在另外一个平台极大的可能是龟速.其最终的结果估计就是跟Java的
write once run everywhere一样是个大笑话.</p>
<p>On 3月22日, 下午2时06分, Guancheng Chen <a href="&#x6d;&#97;&#x69;&#108;&#x74;&#111;&#58;&#91;&#x63;&#x68;&#x65;&#x6e;&#x67;&#117;&#x61;&#110;&#99;&#104;&#x2e;&#46;&#46;&#x40;&#103;&#109;&#x61;&#105;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#93;&#x28;&#x29;">&#91;&#x63;&#x68;&#x65;&#x6e;&#x67;&#117;&#x61;&#110;&#99;&#104;&#x2e;&#46;&#46;&#x40;&#103;&#109;&#x61;&#105;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>On 3月22日, 上午2时20分, Tinyfool <a href="&#109;&#97;&#105;&#x6c;&#x74;&#111;&#x3a;&#91;&#116;&#105;&#x6e;&#121;&#102;&#x2e;&#x2e;&#46;&#x40;&#x67;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#111;&#x6d;&#93;&#x28;&#x29;">&#91;&#116;&#105;&#x6e;&#121;&#102;&#x2e;&#x2e;&#46;&#x40;&#x67;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#111;&#x6d;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#x6d;&#97;&#105;&#x6c;&#x74;&#x6f;&#x3a;&#x5b;&#x6a;&#x65;&#x2e;&#46;&#46;&#64;&#108;&#x69;&#118;&#101;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#x29;">&#x5b;&#x6a;&#x65;&#x2e;&#46;&#46;&#64;&#108;&#x69;&#118;&#101;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#x29;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#109;&#x61;&#x69;&#108;&#x74;&#x6f;&#x3a;&#91;&#99;&#x68;&#101;&#110;&#x67;&#117;&#x61;&#110;&#99;&#104;&#46;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#97;&#105;&#108;&#46;&#99;&#x6f;&#x6d;&#x5d;&#40;&#x29;">&#91;&#99;&#x68;&#101;&#110;&#x67;&#117;&#x61;&#110;&#99;&#104;&#46;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#97;&#105;&#108;&#46;&#99;&#x6f;&#x6d;&#x5d;&#40;&#x29;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#x6d;&#97;&#x69;&#x6c;&#x74;&#111;&#x3a;&#91;&#x70;&#x6f;&#110;&#x2e;&#46;&#46;&#x40;&#x67;&#111;&#x6f;&#x67;&#x6c;&#101;&#x67;&#x72;&#x6f;&#x75;&#112;&#x73;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#40;&#x29;">&#91;&#x70;&#x6f;&#110;&#x2e;&#46;&#46;&#x40;&#x67;&#111;&#x6f;&#x67;&#x6c;&#101;&#x67;&#x72;&#x6f;&#x75;&#112;&#x73;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#40;&#x29;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线...</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>阅读更多 &gt;&gt;</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p><a href="">显示删减掉的内容</a>
<img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-23</p>
<p>其他收件人：</p>
<p>恩</p>
<p>第二点其实我就是指程序员根据他自己的程序领域选择合适的并行技术。Top Language真是藏龙卧虎啊。你是在Boulder么?我一个大学女同
学在你那读MIS的phd</p>
<p>On 3月23日, 上午12时04分, windstorm <a href="&#x6d;&#x61;&#x69;&#108;&#x74;&#x6f;&#x3a;&#91;&#x6c;&#x69;&#x6b;&#x75;&#110;&#97;&#x72;&#x6d;&#x73;&#x74;&#x72;&#46;&#46;&#46;&#x40;&#103;&#x6d;&#x61;&#105;&#x6c;&#46;&#99;&#x6f;&#109;&#x5d;&#40;&#41;">&#91;&#x6c;&#x69;&#x6b;&#x75;&#110;&#97;&#x72;&#x6d;&#x73;&#x74;&#x72;&#46;&#46;&#46;&#x40;&#103;&#x6d;&#x61;&#105;&#x6c;&#46;&#99;&#x6f;&#109;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>全民并行编程的时代，只有在全民能够并行编程的时候才会到来嘛，现在不是这个时候</p>
<p>我个人倾向于等待一个比较好的统一性架构。两条路：</p>
<p>一是某一个全新概念的提出，这个要看学术界的努力，而且在某种意义上讲，学术界搞出一个真正可行的并行架构的可能性比工业界更高。虽说今天多核的发展是工业界引 领的，但是点子还是最早学术界提出的。典型的有几个：斯坦福的Hydra（1996），斯坦福的Imagine(2000)，MIT的RAW（2002），以及 UT奥斯丁的TRIPS（2003）。在这个问题上，是不得不佩服美国的创造力，要知道直到在2000年左右，所有的人都还在为处理器频率按照摩尔定律翻翻而狂 热，美国的顶尖研究员就早已看到了这条路的尽头并指出未来处理器的发展之路。</p>
<p>二是你用现有的架构，但是application引导。如果要找一个面向多application
domain的话，刚才说了，本来看好Larrabee，因为它的架构解决了CUDA一个很大的潜在问题，而且允许现有程序员不经过任何特殊training就 上手编程，包括图形图像，科学计算，或者网络处理，各个领域。</p>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>不过可能就是因为这个solution的过于理想化导致结构的过于复杂化，才让其目前暂时流产。</p>
<p>总的来说，现在的问题就是软件发展不成熟，硬件发展不完善，你没法靠程序员决定使用什么并行技术，完全靠应用主导，这套技术在这个应用上如鱼得水，在那个应用上 完全不罩，作为程序员，有什么办法？</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Guancheng Chen <a href="&#109;&#97;&#x69;&#108;&#x74;&#x6f;&#58;&#x5b;&#99;&#104;&#x65;&#x6e;&#x67;&#x75;&#x61;&#110;&#x63;&#104;&#46;&#46;&#46;&#64;&#103;&#109;&#x61;&#x69;&#108;&#x2e;&#99;&#111;&#109;&#93;&#x28;&#x29;">&#x5b;&#99;&#104;&#x65;&#x6e;&#x67;&#x75;&#x61;&#110;&#x63;&#104;&#46;&#46;&#46;&#64;&#103;&#109;&#x61;&#x69;&#108;&#x2e;&#99;&#111;&#109;&#93;&#x28;&#x29;</a>:</p>
<blockquote>
<p>教育以人为本，最终决定使用何种并行技术的还是程序员。目前业界对程序员并没有并行编程的技能要求，全民并行编程的时代什么时候才能到来？这是个问
题。</p>
<p>On 3月22日, 下午10时41分, windstorm <a href="&#x6d;&#x61;&#105;&#108;&#116;&#111;&#58;&#x5b;&#108;&#x69;&#x6b;&#x75;&#110;&#97;&#114;&#109;&#115;&#116;&#114;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#109;&#97;&#x69;&#108;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#40;&#41;">&#x5b;&#108;&#x69;&#x6b;&#x75;&#110;&#97;&#114;&#109;&#115;&#116;&#114;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#109;&#97;&#x69;&#108;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>Larrabee当初我还是很看好的，它的架构比其他的更像一个统一的方案，可惜后来Intel自己经验不足搞不好。</p>
<p>OPENCL还是主要面向multimedia吧，CUDA/OpenCL在业界代表了流处理的方向，从GPU针对任务的角度讲是好的。其他的就算了。就像Al leluia说的那样，在硬件架构没有更多的突破之前，不说没有生命力，至少想取得任何进一步的突破都太难。</p>
<p>现在这个领域，你吹你的水，我吹我的水。至于谁的泡泡大，我看不清。所以真要选东西学，最好还是针对自己的application选靠谱。这也是并行编程教育难 的问题。大家需求完全不一样。</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Guancheng Chen <a href="&#x6d;&#x61;&#x69;&#x6c;&#116;&#111;&#x3a;&#x5b;&#99;&#104;&#101;&#x6e;&#103;&#117;&#97;&#x6e;&#x63;&#x68;&#x2e;&#46;&#x2e;&#x40;&#x67;&#109;&#x61;&#105;&#108;&#x2e;&#99;&#111;&#x6d;&#x5d;&#x28;&#41;">&#x5b;&#99;&#104;&#101;&#x6e;&#103;&#117;&#97;&#x6e;&#x63;&#x68;&#x2e;&#46;&#x2e;&#x40;&#x67;&#109;&#x61;&#105;&#108;&#x2e;&#99;&#111;&#x6d;&#x5d;&#x28;&#41;</a>:</p>
<blockquote>
<p>我觉得现有的OpenCL确实非常不成熟，但是从纯性能角度上来讲，我看好Heterogeneous架构，尽管它们的编程难度太大，就像前面提到的不
同架构需要做不同优化等。CPU的性能是latency-oriented，GPU是throughput-oriented,Intel的
Larrabee虽然现在来看不成功，但是业界都在朝着那个方向努力。</p>
<p>On 3月22日, 下午6时18分, windstorm <a href="&#x6d;&#97;&#105;&#x6c;&#116;&#x6f;&#58;&#91;&#x6c;&#x69;&#107;&#x75;&#x6e;&#97;&#x72;&#x6d;&#x73;&#x74;&#114;&#46;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#46;&#99;&#111;&#x6d;&#93;&#40;&#x29;">&#91;&#x6c;&#x69;&#107;&#x75;&#x6e;&#97;&#x72;&#x6d;&#x73;&#x74;&#114;&#46;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#46;&#99;&#111;&#x6d;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>实在是不能同意你更多......很早很早以前我就在这里和人争论过，GPU的并行计算平台不可能一统天下的。CUDA也不是救世主。OpenCL更不是。</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Alleluia <a href="&#x6d;&#97;&#105;&#x6c;&#x74;&#x6f;&#x3a;&#91;&#x61;&#108;&#x6c;&#117;&#108;&#x2e;&#46;&#46;&#64;&#x67;&#x6d;&#97;&#105;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#40;&#41;">&#91;&#x61;&#108;&#x6c;&#117;&#108;&#x2e;&#46;&#46;&#64;&#x67;&#x6d;&#97;&#105;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#40;&#41;</a>:</p>
<blockquote>
<p>Parallelism 说到底是算法问题.Parallelism与Concurrency不同,Concurrency所面对的问题相对的单一可以
让一群有经验的专家来实现一套通用库或者语言来提供一个基本的编程框架.而在Parallelism上,具体的不同问题,其所需要并行的算法是根本不同
的.原因在于不同的问题,其内部的DataDependency的结构完全不同,不同的Data Dependency的结构,需要构造不同的算法.即
便是相同的Data Dependency,在不同的颗粒度下，在不同的硬件条件下所采用的算法也是完全不同的.因为一旦出现Data
Dependency也就意味着并行计算模块之间需要进行通信.从以计算节点为单位的分布式并行,到多核CPU上的Numa结构,到SIMD上的向量处
理器,其计算单元之间的通信手段,通信效率简直天差地别.比如说,在SMP上最常见的并行算法,work stealing也就是Intel的TBB,
是建立在两个条件下第一个是CPU的Cache机制上,这使得通常在内存的之间的数据搬运消耗非常小,第二个是SMP上计算单元相对的少,因此每个计算
单元被分配到的任务就相对的重。其开销远远大于通信的开销,因此这种机制在SMP上相对的划算.但是如果你要在GPU上做Work Stealing就
完全不可行,因为GPU的运算单元数量极多,被分配到的任务就相对来说的非常轻量,CUDA上的一个thread很多时候运算一次的时间不会超过
10us,而一次跨Block的线程之间的通信开销就往往要达到100us左右,再加上目前GPU上的Cache机制非常落后导致了需要频繁的通信开销
的Work Stealing在GPU上是非常不划算得.
所以我个人认为在硬件架构没有更多的突破之前,OpenCL这种东西是没有任何生命力的.不要说CPU的并行与GPU之间差异巨大,就是不同的GPU之
间AMD与Nvidia两个也是各自为政,一个平台上跑得非常快的东西,在另外一个平台极大的可能是龟速.其最终的结果估计就是跟Java的
write once run everywhere一样是个大笑话.</p>
<p>On 3月22日, 下午2时06分, Guancheng Chen <a href="&#x6d;&#97;&#x69;&#x6c;&#x74;&#x6f;&#x3a;&#91;&#99;&#104;&#x65;&#x6e;&#x67;&#x75;&#x61;&#110;&#x63;&#104;&#x2e;&#46;&#46;&#64;&#x67;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#109;&#93;&#40;&#41;">&#91;&#99;&#104;&#x65;&#x6e;&#x67;&#x75;&#x61;&#110;&#x63;&#104;&#x2e;&#46;&#46;&#64;&#x67;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#109;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>On 3月22日, 上午2时20分, Tinyfool <a href="&#x6d;&#97;&#x69;&#108;&#x74;&#111;&#x3a;&#91;&#x74;&#x69;&#110;&#x79;&#x66;&#x2e;&#46;&#46;&#64;&#x67;&#x6d;&#x61;&#105;&#108;&#46;&#x63;&#111;&#109;&#x5d;&#40;&#41;">&#91;&#x74;&#x69;&#110;&#x79;&#x66;&#x2e;&#46;&#46;&#64;&#x67;&#x6d;&#x61;&#105;&#108;&#46;&#x63;&#111;&#109;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#x6d;&#97;&#x69;&#x6c;&#116;&#x6f;&#58;&#x5b;&#106;&#x65;&#46;&#x2e;&#x2e;&#x40;&#x6c;&#105;&#118;&#x65;&#46;&#99;&#x6f;&#109;&#x5d;&#40;&#x29;">&#x5b;&#106;&#x65;&#46;&#x2e;&#x2e;&#x40;&#x6c;&#105;&#118;&#x65;&#46;&#99;&#x6f;&#109;&#x5d;&#40;&#x29;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#x6d;&#97;&#105;&#x6c;&#x74;&#111;&#58;&#x5b;&#x63;&#104;&#x65;&#x6e;&#x67;&#117;&#x61;&#110;&#x63;&#x68;&#46;&#x2e;&#46;&#x40;&#x67;&#109;&#97;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#109;&#93;&#40;&#x29;">&#x5b;&#x63;&#104;&#x65;&#x6e;&#x67;&#117;&#x61;&#110;&#x63;&#x68;&#46;&#x2e;&#46;&#x40;&#x67;&#109;&#97;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#109;&#93;&#40;&#x29;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#109;&#97;&#x69;&#108;&#x74;&#111;&#x3a;&#91;&#x70;&#111;&#110;&#x2e;&#x2e;&#46;&#x40;&#x67;&#111;&#x6f;&#103;&#108;&#x65;&#103;&#x72;&#111;&#117;&#x70;&#x73;&#46;&#x63;&#x6f;&#x6d;&#93;&#x28;&#x29;">&#91;&#x70;&#111;&#110;&#x2e;&#x2e;&#46;&#x40;&#x67;&#111;&#x6f;&#103;&#108;&#x65;&#103;&#x72;&#111;&#117;&#x70;&#x73;&#46;&#x63;&#x6f;&#x6d;&#93;&#x28;&#x29;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器...</li>
</ol>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>阅读更多 &gt;&gt;
<a href="">显示删减掉的内容</a></p>
</blockquote>
<p><img src="" alt=""> Alleluia <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-23</p>
<p>其他收件人：</p>
<p>我不是搞体系结构的.但是我认为目前来说做Parallelism的人首先不是去熟悉什么API或者Libarary,而是要熟悉两样东西体系结构和算
法.没有这两样,几乎写不出什么高效率的并行程序.当然你的需求只是并行化循环这种简单的东西当然可以里例外.呵呵.
我觉得你最好放弃用GPGPU去搞遗留代码的想法.现在市面上的GPU产品无论是A记的还是N记的其编程架构与CPU完全不同,你不要想把一个循环简单
的porting到GPU上就能并行了.那是几乎不可能的,比如最简单的你如何处理branch?如果branch非常多,divergence会把速
度拖得比CPU版本还慢.你如何处理CPU代码里的数组随机访问,在GPU上无论是片上的还是片外的内存是不能随机访问的,最要命的是没有cache,
随机访问的代价极其高昂.你几乎需要把CPU上的代码面目全非地从新写一遍,遗留代码除了用作调试测试做结果比对之外几乎要全部抛弃.</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>On 3月23日, 上午6时42分, Guancheng Chen <a href="&#109;&#x61;&#105;&#x6c;&#x74;&#111;&#x3a;&#x5b;&#x63;&#104;&#101;&#x6e;&#103;&#x75;&#x61;&#110;&#99;&#104;&#46;&#x2e;&#46;&#x40;&#x67;&#109;&#x61;&#105;&#x6c;&#x2e;&#99;&#111;&#109;&#93;&#40;&#41;">&#x5b;&#x63;&#104;&#101;&#x6e;&#103;&#x75;&#x61;&#110;&#99;&#104;&#46;&#x2e;&#46;&#x40;&#x67;&#109;&#x61;&#105;&#x6c;&#x2e;&#99;&#111;&#109;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>恩 您也是搞体系结构的么？
现在我在跟瑞典这边的爱立信合作做毕设 不过对象不是他们的Erlang 而是传统的C/C++程序 下半年可能我也去搞GPGPU了 因为它的
data parallel模型对遗留代码的并行化很有搞头，现在我粗略的想法是把Compute sensitive的任务放一部分到GPU上去做，
当然我也对GPU目前的一些限制有所了解 但是一些探索工作还是非常值得的 到时候还想向前辈多多请教</p>
<p>On 3月22日, 下午11时30分, Alleluia <a href="&#x6d;&#x61;&#x69;&#108;&#x74;&#111;&#58;&#x5b;&#x61;&#108;&#108;&#x75;&#108;&#x2e;&#x2e;&#x2e;&#64;&#103;&#x6d;&#97;&#x69;&#x6c;&#46;&#99;&#111;&#109;&#93;&#40;&#x29;">&#x5b;&#x61;&#108;&#108;&#x75;&#108;&#x2e;&#x2e;&#x2e;&#64;&#103;&#x6d;&#97;&#x69;&#x6c;&#46;&#99;&#111;&#109;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>Heterogeneous目前来看也是一个暂时的过渡性的东西. Heterogeneous架构最大的问题还是硬件,CPU和GPU之间的
PCIE2的bus带宽太窄了.在上面来回传递一次几M的内存可能需要化掉500us左右.如果一个算法本来就是在3-4ms级别的,你要用GPU去优
化,内存带宽的消耗就占了1/10,这是非常可怕的事情.或许像AMD那种Fusion架构是一种趋势,但是目前来说没有太大的进展.貌似AMD出了一
款混合的CPU,但是貌似还没有看到有多大的优势.
On 3月23日, 上午5时02分, Guancheng Chen <a href="&#x6d;&#x61;&#105;&#x6c;&#x74;&#111;&#x3a;&#91;&#99;&#x68;&#101;&#x6e;&#x67;&#x75;&#97;&#x6e;&#99;&#104;&#x2e;&#x2e;&#46;&#64;&#103;&#x6d;&#97;&#105;&#108;&#46;&#x63;&#x6f;&#109;&#93;&#x28;&#x29;">&#91;&#99;&#x68;&#101;&#x6e;&#x67;&#x75;&#97;&#x6e;&#99;&#104;&#x2e;&#x2e;&#46;&#64;&#103;&#x6d;&#97;&#105;&#108;&#46;&#x63;&#x6f;&#109;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>我觉得现有的OpenCL确实非常不成熟，但是从纯性能角度上来讲，我看好Heterogeneous架构，尽管它们的编程难度太大，就像前面提到的不
同架构需要做不同优化等。CPU的性能是latency-oriented，GPU是throughput-oriented,Intel的
Larrabee虽然现在来看不成功，但是业界都在朝着那个方向努力。</p>
<p>On 3月22日, 下午6时18分, windstorm <a href="&#x6d;&#97;&#105;&#x6c;&#x74;&#x6f;&#58;&#91;&#x6c;&#105;&#x6b;&#117;&#x6e;&#97;&#114;&#109;&#x73;&#x74;&#x72;&#46;&#46;&#46;&#64;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#111;&#109;&#x5d;&#40;&#x29;">&#91;&#x6c;&#105;&#x6b;&#117;&#x6e;&#97;&#114;&#109;&#x73;&#x74;&#x72;&#46;&#46;&#46;&#64;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#111;&#109;&#x5d;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>实在是不能同意你更多......很早很早以前我就在这里和人争论过，GPU的并行计算平台不可能一统天下的。CUDA也不是救世主。OpenCL更不是。</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Alleluia <a href="&#x6d;&#97;&#105;&#x6c;&#116;&#x6f;&#58;&#x5b;&#x61;&#x6c;&#x6c;&#x75;&#108;&#x2e;&#46;&#x2e;&#x40;&#x67;&#109;&#97;&#105;&#x6c;&#x2e;&#99;&#x6f;&#109;&#x5d;&#40;&#x29;">&#x5b;&#x61;&#x6c;&#x6c;&#x75;&#108;&#x2e;&#46;&#x2e;&#x40;&#x67;&#109;&#97;&#105;&#x6c;&#x2e;&#99;&#x6f;&#109;&#x5d;&#40;&#x29;</a>:</p>
<blockquote>
<p>Parallelism 说到底是算法问题.Parallelism与Concurrency不同,Concurrency所面对的问题相对的单一可以
让一群有经验的专家来实现一套通用库或者语言来提供一个基本的编程框架.而在Parallelism上,具体的不同问题,其所需要并行的算法是根本不同
的.原因在于不同的问题,其内部的DataDependency的结构完全不同,不同的Data Dependency的结构,需要构造不同的算法.即
便是相同的Data Dependency,在不同的颗粒度下，在不同的硬件条件下所采用的算法也是完全不同的.因为一旦出现Data
Dependency也就意味着并行计算模块之间需要进行通信.从以计算节点为单位的分布式并行,到多核CPU上的Numa结构,到SIMD上的向量处
理器,其计算单元之间的通信手段,通信效率简直天差地别.比如说,在SMP上最常见的并行算法,work stealing也就是Intel的TBB,
是建立在两个条件下第一个是CPU的Cache机制上,这使得通常在内存的之间的数据搬运消耗非常小,第二个是SMP上计算单元相对的少,因此每个计算
单元被分配到的任务就相对的重。其开销远远大于通信的开销,因此这种机制在SMP上相对的划算.但是如果你要在GPU上做Work Stealing就
完全不可行,因为GPU的运算单元数量极多,被分配到的任务就相对来说的非常轻量,CUDA上的一个thread很多时候运算一次的时间不会超过
10us,而一次跨Block的线程之间的通信开销就往往要达到100us左右,再加上目前GPU上的Cache机制非常落后导致了需要频繁的通信开销
的Work Stealing在GPU上是非常不划算得.
所以我个人认为在硬件架构没有更多的突破之前,OpenCL这种东西是没有任何生命力的.不要说CPU的并行与GPU之间差异巨大,就是不同的GPU之
间AMD与Nvidia两个也是各自为政,一个平台上跑得非常快的东西,在另外一个平台极大的可能是龟速.其最终的结果估计就是跟Java的
write once run everywhere一样是个大笑话.</p>
<p>On 3月22日, 下午2时06分, Guancheng Chen <a href="&#x6d;&#x61;&#105;&#108;&#116;&#x6f;&#x3a;&#x5b;&#x63;&#104;&#x65;&#x6e;&#x67;&#117;&#97;&#110;&#99;&#x68;&#x2e;&#46;&#46;&#x40;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#41;">&#x5b;&#x63;&#104;&#x65;&#x6e;&#x67;&#117;&#97;&#110;&#99;&#x68;&#x2e;&#46;&#46;&#x40;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>On 3月22日, 上午2时20分, Tinyfool <a href="&#109;&#97;&#105;&#108;&#x74;&#111;&#x3a;&#x5b;&#116;&#x69;&#110;&#x79;&#x66;&#x2e;&#46;&#46;&#64;&#103;&#109;&#x61;&#x69;&#108;&#x2e;&#99;&#111;&#109;&#93;&#40;&#x29;">&#x5b;&#116;&#x69;&#110;&#x79;&#x66;&#x2e;&#46;&#46;&#64;&#103;&#109;&#x61;&#x69;&#108;&#x2e;&#99;&#111;&#109;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#111;&#x3a;&#x5b;&#x6a;&#101;&#46;&#x2e;&#x2e;&#64;&#x6c;&#x69;&#x76;&#101;&#x2e;&#x63;&#111;&#x6d;&#93;&#40;&#41;">&#x5b;&#x6a;&#101;&#46;&#x2e;&#x2e;&#64;&#x6c;&#x69;&#x76;&#101;&#x2e;&#x63;&#111;&#x6d;&#93;&#40;&#41;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#x6d;&#x61;&#105;&#x6c;&#116;&#111;&#x3a;&#91;&#99;&#104;&#101;&#x6e;&#x67;&#117;&#97;&#x6e;&#x63;&#x68;&#46;&#46;&#x2e;&#64;&#x67;&#x6d;&#97;&#105;&#x6c;&#46;&#x63;&#111;&#x6d;&#x5d;&#40;&#41;">&#91;&#99;&#104;&#101;&#x6e;&#x67;&#117;&#97;&#x6e;&#x63;&#x68;&#46;&#46;&#x2e;&#64;&#x67;&#x6d;&#97;&#105;&#x6c;&#46;&#x63;&#111;&#x6d;&#x5d;&#40;&#41;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#109;&#x61;&#105;&#108;&#116;&#111;&#x3a;&#x5b;&#112;&#x6f;&#110;&#x2e;&#x2e;&#46;&#x40;&#x67;&#x6f;&#111;&#x67;&#x6c;&#x65;&#x67;&#114;&#x6f;&#x75;&#112;&#x73;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#40;&#x29;">&#x5b;&#112;&#x6f;&#110;&#x2e;&#x2e;&#46;&#x40;&#x67;&#x6f;&#111;&#x67;&#x6c;&#x65;&#x67;&#114;&#x6f;&#x75;&#112;&#x73;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#40;&#x29;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发</p>
</li>
</ol>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>...</p>
<p>阅读更多 &gt;&gt;
<a href="">显示删减掉的内容</a>
<img src="" alt=""> Alleluia <img src="" alt=""></p>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-23</p>
<p>其他收件人：</p>
<p>我当初就不看好Larrabee这个东西,想想一个Core上一个Decoder就要消耗1瓦的功率,32个捆起来这个Core的功率要多大啊.我觉得
一捆Arm棒在一起都比PII靠谱.</p>
<p>On 3月23日, 上午5时41分, windstorm <a href="&#x6d;&#97;&#x69;&#x6c;&#116;&#x6f;&#58;&#91;&#108;&#105;&#107;&#x75;&#110;&#97;&#114;&#109;&#x73;&#x74;&#114;&#x2e;&#x2e;&#46;&#64;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#46;&#x63;&#x6f;&#109;&#x5d;&#40;&#41;">&#91;&#108;&#105;&#107;&#x75;&#110;&#97;&#114;&#109;&#x73;&#x74;&#114;&#x2e;&#x2e;&#46;&#64;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#46;&#x63;&#x6f;&#109;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>Larrabee当初我还是很看好的，它的架构比其他的更像一个统一的方案，可惜后来Intel自己经验不足搞不好。</p>
<p>OPENCL还是主要面向multimedia吧，CUDA/OpenCL在业界代表了流处理的方向，从GPU针对任务的角度讲是好的。其他的就算了。就像Al leluia说的那样，在硬件架构没有更多的突破之前，不说没有生命力，至少想取得任何进一步的突破都太难。</p>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>现在这个领域，你吹你的水，我吹我的水。至于谁的泡泡大，我看不清。所以真要选东西学，最好还是针对自己的application选靠谱。这也是并行编程教育难 的问题。大家需求完全不一样。</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Guancheng Chen <a href="&#x6d;&#97;&#x69;&#108;&#x74;&#x6f;&#x3a;&#x5b;&#99;&#104;&#x65;&#x6e;&#x67;&#117;&#97;&#110;&#99;&#x68;&#x2e;&#46;&#x2e;&#64;&#103;&#x6d;&#97;&#105;&#x6c;&#46;&#x63;&#x6f;&#109;&#93;&#40;&#41;">&#x5b;&#99;&#104;&#x65;&#x6e;&#x67;&#117;&#97;&#110;&#99;&#x68;&#x2e;&#46;&#x2e;&#64;&#103;&#x6d;&#97;&#105;&#x6c;&#46;&#x63;&#x6f;&#109;&#93;&#40;&#41;</a>:</p>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>&gt;
&gt;
&gt;</p>
<blockquote>
<blockquote>
<p>我觉得现有的OpenCL确实非常不成熟，但是从纯性能角度上来讲，我看好Heterogeneous架构，尽管它们的编程难度太大，就像前面提到的不
同架构需要做不同优化等。CPU的性能是latency-oriented，GPU是throughput-oriented,Intel的
Larrabee虽然现在来看不成功，但是业界都在朝着那个方向努力。</p>
<p>On 3月22日, 下午6时18分, windstorm <a href="&#109;&#97;&#105;&#x6c;&#x74;&#x6f;&#58;&#x5b;&#x6c;&#x69;&#107;&#x75;&#110;&#97;&#x72;&#x6d;&#x73;&#x74;&#114;&#46;&#46;&#46;&#64;&#103;&#109;&#x61;&#105;&#108;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#x28;&#41;">&#x5b;&#x6c;&#x69;&#107;&#x75;&#110;&#97;&#x72;&#x6d;&#x73;&#x74;&#114;&#46;&#46;&#46;&#64;&#103;&#109;&#x61;&#105;&#108;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>实在是不能同意你更多......很早很早以前我就在这里和人争论过，GPU的并行计算平台不可能一统天下的。CUDA也不是救世主。OpenCL更不是。</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Alleluia <a href="&#x6d;&#x61;&#105;&#x6c;&#x74;&#x6f;&#x3a;&#91;&#x61;&#108;&#x6c;&#x75;&#x6c;&#46;&#x2e;&#x2e;&#x40;&#x67;&#109;&#x61;&#105;&#x6c;&#46;&#99;&#111;&#109;&#93;&#40;&#x29;">&#91;&#x61;&#108;&#x6c;&#x75;&#x6c;&#46;&#x2e;&#x2e;&#x40;&#x67;&#109;&#x61;&#105;&#x6c;&#46;&#99;&#111;&#109;&#93;&#40;&#x29;</a>:</p>
<blockquote>
<p>Parallelism 说到底是算法问题.Parallelism与Concurrency不同,Concurrency所面对的问题相对的单一可以
让一群有经验的专家来实现一套通用库或者语言来提供一个基本的编程框架.而在Parallelism上,具体的不同问题,其所需要并行的算法是根本不同
的.原因在于不同的问题,其内部的DataDependency的结构完全不同,不同的Data Dependency的结构,需要构造不同的算法.即
便是相同的Data Dependency,在不同的颗粒度下，在不同的硬件条件下所采用的算法也是完全不同的.因为一旦出现Data
Dependency也就意味着并行计算模块之间需要进行通信.从以计算节点为单位的分布式并行,到多核CPU上的Numa结构,到SIMD上的向量处
理器,其计算单元之间的通信手段,通信效率简直天差地别.比如说,在SMP上最常见的并行算法,work stealing也就是Intel的TBB,
是建立在两个条件下第一个是CPU的Cache机制上,这使得通常在内存的之间的数据搬运消耗非常小,第二个是SMP上计算单元相对的少,因此每个计算
单元被分配到的任务就相对的重。其开销远远大于通信的开销,因此这种机制在SMP上相对的划算.但是如果你要在GPU上做Work Stealing就
完全不可行,因为GPU的运算单元数量极多,被分配到的任务就相对来说的非常轻量,CUDA上的一个thread很多时候运算一次的时间不会超过
10us,而一次跨Block的线程之间的通信开销就往往要达到100us左右,再加上目前GPU上的Cache机制非常落后导致了需要频繁的通信开销
的Work Stealing在GPU上是非常不划算得.
所以我个人认为在硬件架构没有更多的突破之前,OpenCL这种东西是没有任何生命力的.不要说CPU的并行与GPU之间差异巨大,就是不同的GPU之
间AMD与Nvidia两个也是各自为政,一个平台上跑得非常快的东西,在另外一个平台极大的可能是龟速.其最终的结果估计就是跟Java的
write once run everywhere一样是个大笑话.</p>
<p>On 3月22日, 下午2时06分, Guancheng Chen <a href="&#109;&#97;&#105;&#108;&#x74;&#x6f;&#x3a;&#91;&#x63;&#x68;&#x65;&#x6e;&#103;&#x75;&#97;&#110;&#x63;&#104;&#x2e;&#x2e;&#46;&#x40;&#x67;&#x6d;&#97;&#x69;&#x6c;&#46;&#99;&#111;&#109;&#93;&#x28;&#41;">&#91;&#x63;&#x68;&#x65;&#x6e;&#103;&#x75;&#97;&#110;&#x63;&#104;&#x2e;&#x2e;&#46;&#x40;&#x67;&#x6d;&#97;&#x69;&#x6c;&#46;&#99;&#111;&#109;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>On 3月22日, 上午2时20分, Tinyfool <a href="&#x6d;&#97;&#x69;&#x6c;&#x74;&#111;&#58;&#91;&#x74;&#x69;&#110;&#121;&#x66;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#109;&#x61;&#105;&#108;&#x2e;&#99;&#x6f;&#109;&#93;&#x28;&#x29;">&#91;&#x74;&#x69;&#110;&#121;&#x66;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#109;&#x61;&#105;&#108;&#x2e;&#99;&#x6f;&#109;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#109;&#x61;&#x69;&#108;&#x74;&#x6f;&#x3a;&#91;&#x6a;&#x65;&#x2e;&#x2e;&#46;&#64;&#108;&#105;&#118;&#x65;&#x2e;&#99;&#111;&#109;&#93;&#40;&#41;">&#91;&#x6a;&#x65;&#x2e;&#x2e;&#46;&#64;&#108;&#105;&#118;&#x65;&#x2e;&#99;&#111;&#109;&#93;&#40;&#41;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#x6d;&#97;&#105;&#x6c;&#116;&#111;&#58;&#x5b;&#x63;&#104;&#x65;&#110;&#103;&#x75;&#x61;&#110;&#99;&#104;&#46;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#97;&#105;&#x6c;&#x2e;&#x63;&#111;&#109;&#x5d;&#x28;&#x29;">&#x5b;&#x63;&#104;&#x65;&#110;&#103;&#x75;&#x61;&#110;&#99;&#104;&#46;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#97;&#105;&#x6c;&#x2e;&#x63;&#111;&#109;&#x5d;&#x28;&#x29;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#x6d;&#x61;&#105;&#108;&#x74;&#111;&#58;&#91;&#112;&#111;&#x6e;&#46;&#46;&#x2e;&#64;&#x67;&#x6f;&#x6f;&#103;&#x6c;&#x65;&#103;&#x72;&#111;&#117;&#112;&#115;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#x28;&#x29;">&#91;&#112;&#111;&#x6e;&#46;&#46;&#x2e;&#64;&#x67;&#x6f;&#x6f;&#103;&#x6c;&#x65;&#103;&#x72;&#111;&#117;&#112;&#115;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#x28;&#x29;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>...</p>
<p>阅读更多 &gt;&gt;
<a href="">显示删减掉的内容</a></p>
</blockquote>
<p><img src="" alt=""> windstorm <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-23</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>显然不是简单捆绑那么简单阿。</p>
<p>而且我看好它，并不是它将来会一统天下，而是说它相对革命性的架构部分程度上满足了线程完备，从而扩展了GPU的使用领域，所以我看好以它为代表的这种架构的发展。同类型的还有Sun当年的Rock和Niagara
1/2</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p><a href="http://www.kunli.info/" target="_blank">www.kunli.info</a>
<a href="http://twitter.com/cnbuff" target="_blank"><a href="http://twitter.com/cnbuff">http://twitter.com/cnbuff</a></a></p>
<p>2010/3/22 Alleluia <a href="&#109;&#x61;&#105;&#x6c;&#x74;&#111;&#58;&#91;&#97;&#108;&#108;&#x75;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#97;&#105;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#x29;">&#91;&#97;&#108;&#108;&#x75;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#97;&#105;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#x29;</a>:</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<blockquote>
<p>我当初就不看好Larrabee这个东西,想想一个Core上一个Decoder就要消耗1瓦的功率,32个捆起来这个Core的功率要多大啊.我觉得
一捆Arm棒在一起都比PII靠谱.</p>
<p>On 3月23日, 上午5时41分, windstorm <a href="&#109;&#97;&#105;&#x6c;&#x74;&#111;&#58;&#x5b;&#x6c;&#x69;&#x6b;&#117;&#110;&#x61;&#114;&#x6d;&#115;&#x74;&#114;&#x2e;&#x2e;&#46;&#64;&#103;&#x6d;&#97;&#x69;&#108;&#46;&#99;&#111;&#109;&#93;&#x28;&#41;">&#x5b;&#x6c;&#x69;&#x6b;&#117;&#110;&#x61;&#114;&#x6d;&#115;&#x74;&#114;&#x2e;&#x2e;&#46;&#64;&#103;&#x6d;&#97;&#x69;&#108;&#46;&#99;&#111;&#109;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>Larrabee当初我还是很看好的，它的架构比其他的更像一个统一的方案，可惜后来Intel自己经验不足搞不好。</p>
<p>OPENCL还是主要面向multimedia吧，CUDA/OpenCL在业界代表了流处理的方向，从GPU针对任务的角度讲是好的。其他的就算了。就像Al leluia说的那样，在硬件架构没有更多的突破之前，不说没有生命力，至少想取得任何进一步的突破都太难。</p>
<p>现在这个领域，你吹你的水，我吹我的水。至于谁的泡泡大，我看不清。所以真要选东西学，最好还是针对自己的application选靠谱。这也是并行编程教育难 的问题。大家需求完全不一样。</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Guancheng Chen <a href="&#x6d;&#x61;&#105;&#108;&#116;&#111;&#x3a;&#x5b;&#99;&#104;&#101;&#x6e;&#103;&#x75;&#97;&#110;&#x63;&#x68;&#x2e;&#46;&#46;&#x40;&#103;&#109;&#97;&#105;&#108;&#x2e;&#99;&#111;&#x6d;&#93;&#40;&#41;">&#x5b;&#99;&#104;&#101;&#x6e;&#103;&#x75;&#97;&#110;&#x63;&#x68;&#x2e;&#46;&#46;&#x40;&#103;&#109;&#97;&#105;&#108;&#x2e;&#99;&#111;&#x6d;&#93;&#40;&#41;</a>:</p>
<blockquote>
<p>我觉得现有的OpenCL确实非常不成熟，但是从纯性能角度上来讲，我看好Heterogeneous架构，尽管它们的编程难度太大，就像前面提到的不
同架构需要做不同优化等。CPU的性能是latency-oriented，GPU是throughput-oriented,Intel的
Larrabee虽然现在来看不成功，但是业界都在朝着那个方向努力。</p>
<p>On 3月22日, 下午6时18分, windstorm <a href="&#x6d;&#97;&#105;&#x6c;&#x74;&#111;&#x3a;&#91;&#x6c;&#105;&#x6b;&#117;&#110;&#x61;&#114;&#109;&#115;&#x74;&#114;&#46;&#46;&#46;&#x40;&#x67;&#109;&#97;&#x69;&#108;&#x2e;&#99;&#x6f;&#109;&#x5d;&#x28;&#x29;">&#91;&#x6c;&#105;&#x6b;&#117;&#110;&#x61;&#114;&#109;&#115;&#x74;&#114;&#46;&#46;&#46;&#x40;&#x67;&#109;&#97;&#x69;&#108;&#x2e;&#99;&#x6f;&#109;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>实在是不能同意你更多......很早很早以前我就在这里和人争论过，GPU的并行计算平台不可能一统天下的。CUDA也不是救世主。OpenCL更不是。</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Alleluia <a href="&#109;&#97;&#105;&#x6c;&#116;&#111;&#58;&#91;&#x61;&#108;&#x6c;&#x75;&#108;&#x2e;&#46;&#x2e;&#x40;&#x67;&#109;&#x61;&#x69;&#108;&#46;&#99;&#111;&#x6d;&#93;&#x28;&#x29;">&#91;&#x61;&#108;&#x6c;&#x75;&#108;&#x2e;&#46;&#x2e;&#x40;&#x67;&#109;&#x61;&#x69;&#108;&#46;&#99;&#111;&#x6d;&#93;&#x28;&#x29;</a>:</p>
<blockquote>
<p>Parallelism 说到底是算法问题.Parallelism与Concurrency不同,Concurrency所面对的问题相对的单一可以
让一群有经验的专家来实现一套通用库或者语言来提供一个基本的编程框架.而在Parallelism上,具体的不同问题,其所需要并行的算法是根本不同
的.原因在于不同的问题,其内部的DataDependency的结构完全不同,不同的Data Dependency的结构,需要构造不同的算法.即
便是相同的Data Dependency,在不同的颗粒度下，在不同的硬件条件下所采用的算法也是完全不同的.因为一旦出现Data
Dependency也就意味着并行计算模块之间需要进行通信.从以计算节点为单位的分布式并行,到多核CPU上的Numa结构,到SIMD上的向量处
理器,其计算单元之间的通信手段,通信效率简直天差地别.比如说,在SMP上最常见的并行算法,work stealing也就是Intel的TBB,
是建立在两个条件下第一个是CPU的Cache机制上,这使得通常在内存的之间的数据搬运消耗非常小,第二个是SMP上计算单元相对的少,因此每个计算
单元被分配到的任务就相对的重。其开销远远大于通信的开销,因此这种机制在SMP上相对的划算.但是如果你要在GPU上做Work Stealing就
完全不可行,因为GPU的运算单元数量极多,被分配到的任务就相对来说的非常轻量,CUDA上的一个thread很多时候运算一次的时间不会超过
10us,而一次跨Block的线程之间的通信开销就往往要达到100us左右,再加上目前GPU上的Cache机制非常落后导致了需要频繁的通信开销
的Work Stealing在GPU上是非常不划算得.
所以我个人认为在硬件架构没有更多的突破之前,OpenCL这种东西是没有任何生命力的.不要说CPU的并行与GPU之间差异巨大,就是不同的GPU之
间AMD与Nvidia两个也是各自为政,一个平台上跑得非常快的东西,在另外一个平台极大的可能是龟速.其最终的结果估计就是跟Java的
write once run everywhere一样是个大笑话.</p>
<p>On 3月22日, 下午2时06分, Guancheng Chen <a href="&#x6d;&#97;&#x69;&#x6c;&#116;&#111;&#x3a;&#x5b;&#x63;&#x68;&#101;&#110;&#x67;&#117;&#x61;&#110;&#99;&#x68;&#x2e;&#x2e;&#x2e;&#64;&#103;&#109;&#97;&#105;&#x6c;&#x2e;&#99;&#x6f;&#109;&#93;&#40;&#41;">&#x5b;&#x63;&#x68;&#101;&#110;&#x67;&#117;&#x61;&#110;&#99;&#x68;&#x2e;&#x2e;&#x2e;&#64;&#103;&#109;&#97;&#105;&#x6c;&#x2e;&#99;&#x6f;&#109;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>On 3月22日, 上午2时20分, Tinyfool <a href="&#109;&#97;&#x69;&#108;&#x74;&#111;&#58;&#x5b;&#x74;&#x69;&#x6e;&#x79;&#102;&#46;&#46;&#46;&#64;&#103;&#x6d;&#97;&#105;&#x6c;&#46;&#99;&#111;&#109;&#93;&#40;&#x29;">&#x5b;&#x74;&#x69;&#x6e;&#x79;&#102;&#46;&#46;&#46;&#64;&#103;&#x6d;&#97;&#105;&#x6c;&#46;&#99;&#111;&#109;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#109;&#97;&#105;&#108;&#116;&#x6f;&#58;&#x5b;&#x6a;&#101;&#x2e;&#46;&#x2e;&#64;&#x6c;&#105;&#118;&#101;&#46;&#x63;&#111;&#x6d;&#93;&#x28;&#41;">&#x5b;&#x6a;&#101;&#x2e;&#46;&#x2e;&#64;&#x6c;&#105;&#118;&#101;&#46;&#x63;&#111;&#x6d;&#93;&#x28;&#41;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#109;&#x61;&#105;&#108;&#116;&#x6f;&#x3a;&#91;&#x63;&#x68;&#101;&#x6e;&#x67;&#x75;&#x61;&#110;&#x63;&#104;&#46;&#x2e;&#x2e;&#64;&#x67;&#109;&#97;&#x69;&#108;&#x2e;&#99;&#111;&#x6d;&#93;&#x28;&#41;">&#91;&#x63;&#x68;&#101;&#x6e;&#x67;&#x75;&#x61;&#110;&#x63;&#104;&#46;&#x2e;&#x2e;&#64;&#x67;&#109;&#97;&#x69;&#108;&#x2e;&#99;&#111;&#x6d;&#93;&#x28;&#41;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#x6d;&#x61;&#105;&#x6c;&#x74;&#111;&#58;&#91;&#112;&#x6f;&#110;&#x2e;&#46;&#x2e;&#64;&#x67;&#111;&#x6f;&#103;&#x6c;&#101;&#x67;&#x72;&#x6f;&#117;&#112;&#115;&#46;&#99;&#x6f;&#109;&#93;&#x28;&#x29;">&#91;&#112;&#x6f;&#110;&#x2e;&#46;&#x2e;&#64;&#x67;&#111;&#x6f;&#103;&#x6c;&#101;&#x67;&#x72;&#x6f;&#117;&#112;&#115;&#46;&#99;&#x6f;&#109;&#93;&#x28;&#x29;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>...</p>
<p>阅读更多 &gt;&gt;</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p><a href="">显示删减掉的内容</a>
<img src="" alt=""> windstorm <img src="" alt=""></p>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-23</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>女生？LJJ？</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p><a href="http://www.kunli.info/" target="_blank">www.kunli.info</a>
<a href="http://twitter.com/cnbuff" target="_blank"><a href="http://twitter.com/cnbuff">http://twitter.com/cnbuff</a></a></p>
<p>2010/3/22 Guancheng Chen <a href="&#x6d;&#x61;&#105;&#x6c;&#116;&#111;&#58;&#x5b;&#99;&#x68;&#x65;&#x6e;&#x67;&#x75;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#109;&#97;&#x69;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#93;&#40;&#41;">&#x5b;&#99;&#x68;&#x65;&#x6e;&#x67;&#x75;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#109;&#97;&#x69;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#93;&#40;&#41;</a>:</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<blockquote>
<p>恩</p>
<p>第二点其实我就是指程序员根据他自己的程序领域选择合适的并行技术。Top Language真是藏龙卧虎啊。你是在Boulder么?我一个大学女同
学在你那读MIS的phd</p>
<p>On 3月23日, 上午12时04分, windstorm <a href="&#109;&#x61;&#105;&#108;&#x74;&#x6f;&#58;&#x5b;&#x6c;&#x69;&#107;&#117;&#x6e;&#97;&#114;&#x6d;&#115;&#x74;&#114;&#46;&#46;&#46;&#x40;&#103;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#99;&#111;&#x6d;&#x5d;&#40;&#41;">&#x5b;&#x6c;&#x69;&#107;&#117;&#x6e;&#97;&#114;&#x6d;&#115;&#x74;&#114;&#46;&#46;&#46;&#x40;&#103;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#99;&#111;&#x6d;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>全民并行编程的时代，只有在全民能够并行编程的时候才会到来嘛，现在不是这个时候</p>
<p>我个人倾向于等待一个比较好的统一性架构。两条路：</p>
<p>一是某一个全新概念的提出，这个要看学术界的努力，而且在某种意义上讲，学术界搞出一个真正可行的并行架构的可能性比工业界更高。虽说今天多核的发展是工业界引 领的，但是点子还是最早学术界提出的。典型的有几个：斯坦福的Hydra（1996），斯坦福的Imagine(2000)，MIT的RAW（2002），以及 UT奥斯丁的TRIPS（2003）。在这个问题上，是不得不佩服美国的创造力，要知道直到在2000年左右，所有的人都还在为处理器频率按照摩尔定律翻翻而狂 热，美国的顶尖研究员就早已看到了这条路的尽头并指出未来处理器的发展之路。</p>
<p>二是你用现有的架构，但是application引导。如果要找一个面向多application
domain的话，刚才说了，本来看好Larrabee，因为它的架构解决了CUDA一个很大的潜在问题，而且允许现有程序员不经过任何特殊training就 上手编程，包括图形图像，科学计算，或者网络处理，各个领域。</p>
<p>不过可能就是因为这个solution的过于理想化导致结构的过于复杂化，才让其目前暂时流产。</p>
<p>总的来说，现在的问题就是软件发展不成熟，硬件发展不完善，你没法靠程序员决定使用什么并行技术，完全靠应用主导，这套技术在这个应用上如鱼得水，在那个应用上 完全不罩，作为程序员，有什么办法？</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Guancheng Chen <a href="&#x6d;&#x61;&#105;&#108;&#116;&#x6f;&#58;&#x5b;&#x63;&#104;&#101;&#110;&#103;&#x75;&#x61;&#110;&#99;&#x68;&#46;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#97;&#x69;&#x6c;&#46;&#99;&#111;&#109;&#x5d;&#x28;&#x29;">&#x5b;&#x63;&#104;&#101;&#110;&#103;&#x75;&#x61;&#110;&#99;&#x68;&#46;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#97;&#x69;&#x6c;&#46;&#99;&#111;&#109;&#x5d;&#x28;&#x29;</a>:</p>
<blockquote>
<p>教育以人为本，最终决定使用何种并行技术的还是程序员。目前业界对程序员并没有并行编程的技能要求，全民并行编程的时代什么时候才能到来？这是个问
题。</p>
<p>On 3月22日, 下午10时41分, windstorm <a href="&#109;&#x61;&#105;&#x6c;&#x74;&#x6f;&#58;&#91;&#x6c;&#x69;&#107;&#117;&#x6e;&#97;&#x72;&#x6d;&#115;&#x74;&#x72;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#97;&#105;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#93;&#40;&#41;">&#91;&#x6c;&#x69;&#107;&#117;&#x6e;&#97;&#x72;&#x6d;&#115;&#x74;&#x72;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#97;&#105;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>Larrabee当初我还是很看好的，它的架构比其他的更像一个统一的方案，可惜后来Intel自己经验不足搞不好。</p>
<p>OPENCL还是主要面向multimedia吧，CUDA/OpenCL在业界代表了流处理的方向，从GPU针对任务的角度讲是好的。其他的就算了。就像Al leluia说的那样，在硬件架构没有更多的突破之前，不说没有生命力，至少想取得任何进一步的突破都太难。</p>
<p>现在这个领域，你吹你的水，我吹我的水。至于谁的泡泡大，我看不清。所以真要选东西学，最好还是针对自己的application选靠谱。这也是并行编程教育难 的问题。大家需求完全不一样。</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Guancheng Chen <a href="&#x6d;&#x61;&#105;&#x6c;&#x74;&#x6f;&#58;&#x5b;&#99;&#x68;&#x65;&#x6e;&#103;&#117;&#x61;&#110;&#99;&#x68;&#x2e;&#46;&#x2e;&#64;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#46;&#99;&#111;&#109;&#x5d;&#40;&#x29;">&#x5b;&#99;&#x68;&#x65;&#x6e;&#103;&#117;&#x61;&#110;&#99;&#x68;&#x2e;&#46;&#x2e;&#64;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#46;&#99;&#111;&#109;&#x5d;&#40;&#x29;</a>:</p>
<blockquote>
<p>我觉得现有的OpenCL确实非常不成熟，但是从纯性能角度上来讲，我看好Heterogeneous架构，尽管它们的编程难度太大，就像前面提到的不
同架构需要做不同优化等。CPU的性能是latency-oriented，GPU是throughput-oriented,Intel的
Larrabee虽然现在来看不成功，但是业界都在朝着那个方向努力。</p>
<p>On 3月22日, 下午6时18分, windstorm <a href="&#109;&#97;&#x69;&#x6c;&#x74;&#111;&#x3a;&#91;&#108;&#x69;&#107;&#x75;&#110;&#97;&#114;&#109;&#x73;&#116;&#114;&#46;&#46;&#x2e;&#64;&#103;&#x6d;&#x61;&#105;&#108;&#46;&#99;&#x6f;&#x6d;&#x5d;&#40;&#x29;">&#91;&#108;&#x69;&#107;&#x75;&#110;&#97;&#114;&#109;&#x73;&#116;&#114;&#46;&#46;&#x2e;&#64;&#103;&#x6d;&#x61;&#105;&#108;&#46;&#99;&#x6f;&#x6d;&#x5d;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>实在是不能同意你更多......很早很早以前我就在这里和人争论过，GPU的并行计算平台不可能一统天下的。CUDA也不是救世主。OpenCL更不是。</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Alleluia <a href="&#x6d;&#x61;&#x69;&#x6c;&#116;&#x6f;&#x3a;&#x5b;&#x61;&#108;&#x6c;&#117;&#108;&#46;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#97;&#x69;&#108;&#x2e;&#99;&#111;&#x6d;&#93;&#40;&#41;">&#x5b;&#x61;&#108;&#x6c;&#117;&#108;&#46;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#97;&#x69;&#108;&#x2e;&#99;&#111;&#x6d;&#93;&#40;&#41;</a>:</p>
<blockquote>
<p>Parallelism 说到底是算法问题.Parallelism与Concurrency不同,Concurrency所面对的问题相对的单一可以
让一群有经验的专家来实现一套通用库或者语言来提供一个基本的编程框架.而在Parallelism上,具体的不同问题,其所需要并行的算法是根本不同
的.原因在于不同的问题,其内部的DataDependency的结构完全不同,不同的Data Dependency的结构,需要构造不同的算法.即
便是相同的Data Dependency,在不同的颗粒度下，在不同的硬件条件下所采用的算法也是完全不同的.因为一旦出现Data
Dependency也就意味着并行计算模块之间需要进行通信.从以计算节点为单位的分布式并行,到多核CPU上的Numa结构,到SIMD上的向量处
理器,其计算单元之间的通信手段,通信效率简直天差地别.比如说,在SMP上最常见的并行算法,work stealing也就是Intel的TBB,
是建立在两个条件下第一个是CPU的Cache机制上,这使得通常在内存的之间的数据搬运消耗非常小,第二个是SMP上计算单元相对的少,因此每个计算
单元被分配到的任务就相对的重。其开销远远大于通信的开销,因此这种机制在SMP上相对的划算.但是如果你要在GPU上做Work Stealing就
完全不可行,因为GPU的运算单元数量极多,被分配到的任务就相对来说的非常轻量,CUDA上的一个thread很多时候运算一次的时间不会超过
10us,而一次跨Block的线程之间的通信开销就往往要达到100us左右,再加上目前GPU上的Cache机制非常落后导致了需要频繁的通信开销
的Work Stealing在GPU上是非常不划算得.
所以我个人认为在硬件架构没有更多的突破之前,OpenCL这种东西是没有任何生命力的.不要说CPU的并行与GPU之间差异巨大,就是不同的GPU之
间AMD与Nvidia两个也是各自为政,一个平台上跑得非常快的东西,在另外一个平台极大的可能是龟速.其最终的结果估计就是跟Java的
write once run everywhere一样是个大笑话.</p>
<p>On 3月22日, 下午2时06分, Guancheng Chen <a href="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#x6f;&#58;&#91;&#99;&#104;&#101;&#110;&#103;&#117;&#97;&#x6e;&#99;&#x68;&#x2e;&#x2e;&#46;&#x40;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#40;&#x29;">&#91;&#99;&#104;&#101;&#110;&#103;&#117;&#97;&#x6e;&#99;&#x68;&#x2e;&#x2e;&#46;&#x40;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>On 3月22日, 上午2时20分, Tinyfool <a href="&#x6d;&#97;&#x69;&#108;&#x74;&#x6f;&#58;&#91;&#x74;&#x69;&#x6e;&#x79;&#x66;&#46;&#46;&#x2e;&#x40;&#103;&#109;&#x61;&#105;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#93;&#x28;&#41;">&#91;&#x74;&#x69;&#x6e;&#x79;&#x66;&#46;&#46;&#x2e;&#x40;&#103;&#109;&#x61;&#105;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#x6d;&#x61;&#x69;&#108;&#116;&#x6f;&#x3a;&#x5b;&#x6a;&#x65;&#x2e;&#x2e;&#x2e;&#64;&#108;&#x69;&#x76;&#101;&#x2e;&#99;&#111;&#109;&#93;&#40;&#x29;">&#x5b;&#x6a;&#x65;&#x2e;&#x2e;&#x2e;&#64;&#108;&#x69;&#x76;&#101;&#x2e;&#99;&#111;&#109;&#93;&#40;&#x29;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#109;&#97;&#105;&#108;&#x74;&#x6f;&#58;&#91;&#x63;&#104;&#x65;&#110;&#x67;&#x75;&#97;&#110;&#99;&#x68;&#x2e;&#46;&#46;&#64;&#x67;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#111;&#x6d;&#93;&#x28;&#x29;">&#91;&#x63;&#104;&#x65;&#110;&#x67;&#x75;&#97;&#110;&#99;&#x68;&#x2e;&#46;&#46;&#64;&#x67;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#111;&#x6d;&#93;&#x28;&#x29;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#x6d;&#97;&#105;&#108;&#x74;&#x6f;&#x3a;&#91;&#x70;&#x6f;&#110;&#x2e;&#46;&#x2e;&#64;&#103;&#111;&#111;&#x67;&#x6c;&#x65;&#x67;&#x72;&#x6f;&#x75;&#112;&#115;&#46;&#x63;&#111;&#109;&#x5d;&#40;&#x29;">&#91;&#x70;&#x6f;&#110;&#x2e;&#46;&#x2e;&#64;&#103;&#111;&#111;&#x67;&#x6c;&#x65;&#x67;&#x72;&#x6f;&#x75;&#112;&#115;&#46;&#x63;&#111;&#109;&#x5d;&#40;&#x29;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器...</li>
</ol>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>阅读更多 &gt;&gt;</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p><a href="">显示删减掉的内容</a></p>
</blockquote>
<p><img src="" alt=""> SevenCat <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-23</p>
<p>其他收件人：</p>
<p>大家在什么项目上用到并行编程？
<a href="">显示删减掉的内容</a>
<img src="" alt=""> qiaojie <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-23</p>
<p>其他收件人：</p>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1) = 5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？
<a href="">显示删减掉的内容</a></p>
<p><img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-23</p>
<p>其他收件人：</p>
<p>多谢大牛指教。我之所以提到并行化循环，是因为我以前实习过的公司的解决方案就是以data parallel模型的把循环并行化为主，其实新编写的代
码也可以用他们的技术。我之所以要提到遗留代码，是因为如果针对只对遗留代码的循环进行并行化就已经能取得比较可观的speedup(如果本身该循环是
热点，经过一些指导被程序员正确改成independent的之后即可并行化)，同时又不会引入太多的并行编程的复杂度。我原来测试它的时候一般1-3
个小时就能出结果，speedup在1.2~1.6之间(dual core, quad core 2.X)。</p>
<p>另外想请教您的实际工作中一般适用什么样的并行算法？任务分解(如TBB)？还是数据分解？</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>On 3月23日, 上午3时09分, Alleluia <a href="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#x6f;&#58;&#91;&#97;&#x6c;&#108;&#117;&#108;&#46;&#x2e;&#x2e;&#x40;&#x67;&#109;&#97;&#x69;&#x6c;&#46;&#99;&#x6f;&#109;&#93;&#x28;&#x29;">&#91;&#97;&#x6c;&#108;&#117;&#108;&#46;&#x2e;&#x2e;&#x40;&#x67;&#109;&#97;&#x69;&#x6c;&#46;&#99;&#x6f;&#109;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>我不是搞体系结构的.但是我认为目前来说做Parallelism的人首先不是去熟悉什么API或者Libarary,而是要熟悉两样东西体系结构和算
法.没有这两样,几乎写不出什么高效率的并行程序.当然你的需求只是并行化循环这种简单的东西当然可以里例外.呵呵.
我觉得你最好放弃用GPGPU去搞遗留代码的想法.现在市面上的GPU产品无论是A记的还是N记的其编程架构与CPU完全不同,你不要想把一个循环简单
的porting到GPU上就能并行了.那是几乎不可能的,比如最简单的你如何处理branch?如果branch非常多,divergence会把速
度拖得比CPU版本还慢.你如何处理CPU代码里的数组随机访问,在GPU上无论是片上的还是片外的内存是不能随机访问的,最要命的是没有cache,
随机访问的代价极其高昂.你几乎需要把CPU上的代码面目全非地从新写一遍,遗留代码除了用作调试测试做结果比对之外几乎要全部抛弃.</p>
<p>On 3月23日, 上午6时42分, Guancheng Chen <a href="&#x6d;&#97;&#105;&#x6c;&#x74;&#111;&#58;&#91;&#x63;&#x68;&#x65;&#x6e;&#x67;&#x75;&#x61;&#x6e;&#99;&#x68;&#x2e;&#46;&#x2e;&#x40;&#x67;&#109;&#x61;&#x69;&#x6c;&#46;&#x63;&#111;&#x6d;&#x5d;&#x28;&#41;">&#91;&#x63;&#x68;&#x65;&#x6e;&#x67;&#x75;&#x61;&#x6e;&#99;&#x68;&#x2e;&#46;&#x2e;&#x40;&#x67;&#109;&#x61;&#x69;&#x6c;&#46;&#x63;&#111;&#x6d;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>恩 您也是搞体系结构的么？
现在我在跟瑞典这边的爱立信合作做毕设 不过对象不是他们的Erlang 而是传统的C/C++程序 下半年可能我也去搞GPGPU了 因为它的
data parallel模型对遗留代码的并行化很有搞头，现在我粗略的想法是把Compute sensitive的任务放一部分到GPU上去做，
当然我也对GPU目前的一些限制有所了解 但是一些探索工作还是非常值得的 到时候还想向前辈多多请教</p>
<p>On 3月22日, 下午11时30分, Alleluia <a href="&#109;&#97;&#x69;&#108;&#x74;&#x6f;&#x3a;&#91;&#x61;&#108;&#108;&#x75;&#108;&#x2e;&#x2e;&#46;&#x40;&#x67;&#x6d;&#97;&#105;&#108;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#x28;&#x29;">&#91;&#x61;&#108;&#108;&#x75;&#108;&#x2e;&#x2e;&#46;&#x40;&#x67;&#x6d;&#97;&#105;&#108;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>Heterogeneous目前来看也是一个暂时的过渡性的东西. Heterogeneous架构最大的问题还是硬件,CPU和GPU之间的
PCIE2的bus带宽太窄了.在上面来回传递一次几M的内存可能需要化掉500us左右.如果一个算法本来就是在3-4ms级别的,你要用GPU去优
化,内存带宽的消耗就占了1/10,这是非常可怕的事情.或许像AMD那种Fusion架构是一种趋势,但是目前来说没有太大的进展.貌似AMD出了一
款混合的CPU,但是貌似还没有看到有多大的优势.
On 3月23日, 上午5时02分, Guancheng Chen <a href="&#109;&#x61;&#105;&#108;&#116;&#x6f;&#x3a;&#x5b;&#99;&#104;&#x65;&#110;&#103;&#x75;&#x61;&#110;&#99;&#104;&#x2e;&#46;&#x2e;&#64;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#109;&#93;&#x28;&#x29;">&#x5b;&#99;&#104;&#x65;&#110;&#103;&#x75;&#x61;&#110;&#99;&#104;&#x2e;&#46;&#x2e;&#64;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#109;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>我觉得现有的OpenCL确实非常不成熟，但是从纯性能角度上来讲，我看好Heterogeneous架构，尽管它们的编程难度太大，就像前面提到的不
同架构需要做不同优化等。CPU的性能是latency-oriented，GPU是throughput-oriented,Intel的
Larrabee虽然现在来看不成功，但是业界都在朝着那个方向努力。</p>
<p>On 3月22日, 下午6时18分, windstorm <a href="&#109;&#97;&#105;&#x6c;&#x74;&#x6f;&#x3a;&#x5b;&#108;&#105;&#x6b;&#x75;&#110;&#x61;&#114;&#x6d;&#115;&#x74;&#114;&#x2e;&#x2e;&#46;&#x40;&#103;&#x6d;&#97;&#105;&#108;&#x2e;&#99;&#111;&#x6d;&#x5d;&#40;&#x29;">&#x5b;&#108;&#105;&#x6b;&#x75;&#110;&#x61;&#114;&#x6d;&#115;&#x74;&#114;&#x2e;&#x2e;&#46;&#x40;&#103;&#x6d;&#97;&#105;&#108;&#x2e;&#99;&#111;&#x6d;&#x5d;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>实在是不能同意你更多......很早很早以前我就在这里和人争论过，GPU的并行计算平台不可能一统天下的。CUDA也不是救世主。OpenCL更不是。</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Alleluia <a href="&#109;&#97;&#105;&#108;&#x74;&#x6f;&#x3a;&#x5b;&#x61;&#108;&#108;&#x75;&#x6c;&#46;&#x2e;&#x2e;&#64;&#103;&#x6d;&#97;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#93;&#x28;&#41;">&#x5b;&#x61;&#108;&#108;&#x75;&#x6c;&#46;&#x2e;&#x2e;&#64;&#103;&#x6d;&#97;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#93;&#x28;&#41;</a>:</p>
<blockquote>
<p>Parallelism 说到底是算法问题.Parallelism与Concurrency不同,Concurrency所面对的问题相对的单一可以
让一群有经验的专家来实现一套通用库或者语言来提供一个基本的编程框架.而在Parallelism上,具体的不同问题,其所需要并行的算法是根本不同
的.原因在于不同的问题,其内部的DataDependency的结构完全不同,不同的Data Dependency的结构,需要构造不同的算法.即
便是相同的Data Dependency,在不同的颗粒度下，在不同的硬件条件下所采用的算法也是完全不同的.因为一旦出现Data
Dependency也就意味着并行计算模块之间需要进行通信.从以计算节点为单位的分布式并行,到多核CPU上的Numa结构,到SIMD上的向量处
理器,其计算单元之间的通信手段,通信效率简直天差地别.比如说,在SMP上最常见的并行算法,work stealing也就是Intel的TBB,
是建立在两个条件下第一个是CPU的Cache机制上,这使得通常在内存的之间的数据搬运消耗非常小,第二个是SMP上计算单元相对的少,因此每个计算
单元被分配到的任务就相对的重。其开销远远大于通信的开销,因此这种机制在SMP上相对的划算.但是如果你要在GPU上做Work Stealing就
完全不可行,因为GPU的运算单元数量极多,被分配到的任务就相对来说的非常轻量,CUDA上的一个thread很多时候运算一次的时间不会超过
10us,而一次跨Block的线程之间的通信开销就往往要达到100us左右,再加上目前GPU上的Cache机制非常落后导致了需要频繁的通信开销
的Work Stealing在GPU上是非常不划算得.
所以我个人认为在硬件架构没有更多的突破之前,OpenCL这种东西是没有任何生命力的.不要说CPU的并行与GPU之间差异巨大,就是不同的GPU之
间AMD与Nvidia两个也是各自为政,一个平台上跑得非常快的东西,在另外一个平台极大的可能是龟速.其最终的结果估计就是跟Java的
write once run everywhere一样是个大笑话.</p>
<p>On 3月22日, 下午2时06分, Guancheng Chen <a href="&#x6d;&#x61;&#x69;&#108;&#x74;&#x6f;&#58;&#x5b;&#99;&#x68;&#101;&#110;&#103;&#x75;&#97;&#x6e;&#x63;&#x68;&#x2e;&#46;&#46;&#64;&#x67;&#x6d;&#97;&#x69;&#108;&#x2e;&#x63;&#111;&#x6d;&#93;&#x28;&#x29;">&#x5b;&#99;&#x68;&#101;&#110;&#103;&#x75;&#97;&#x6e;&#x63;&#x68;&#x2e;&#46;&#46;&#64;&#x67;&#x6d;&#97;&#x69;&#108;&#x2e;&#x63;&#111;&#x6d;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>On 3月22日, 上午2时20分, Tinyfool <a href="&#109;&#97;&#x69;&#x6c;&#x74;&#111;&#x3a;&#91;&#116;&#105;&#x6e;&#121;&#102;&#x2e;&#46;&#x2e;&#x40;&#103;&#109;&#97;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#109;&#93;&#x28;&#x29;">&#91;&#116;&#105;&#x6e;&#121;&#102;&#x2e;&#46;&#x2e;&#x40;&#103;&#109;&#97;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#109;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#109;&#x61;&#105;&#108;&#x74;&#x6f;&#58;&#x5b;&#106;&#x65;&#x2e;&#46;&#46;&#x40;&#x6c;&#x69;&#118;&#101;&#46;&#99;&#x6f;&#x6d;&#93;&#40;&#x29;">&#x5b;&#106;&#x65;&#x2e;&#46;&#46;&#x40;&#x6c;&#x69;&#118;&#101;&#46;&#99;&#x6f;&#x6d;&#93;&#40;&#x29;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#x6d;&#97;&#105;&#x6c;&#x74;&#111;&#x3a;&#x5b;&#x63;&#104;&#101;&#x6e;&#x67;&#x75;&#97;&#110;&#x63;&#104;&#46;&#x2e;&#46;&#x40;&#103;&#109;&#x61;&#x69;&#x6c;&#46;&#99;&#111;&#109;&#93;&#x28;&#41;">&#x5b;&#x63;&#104;&#101;&#x6e;&#x67;&#x75;&#97;&#110;&#x63;&#104;&#46;&#x2e;&#46;&#x40;&#103;&#109;&#x61;&#x69;&#x6c;&#46;&#99;&#111;&#109;&#93;&#x28;&#41;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#109;&#97;&#x69;&#x6c;&#x74;&#111;&#x3a;&#x5b;&#x70;&#111;&#110;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#x6f;&#111;&#x67;&#x6c;&#x65;&#x67;&#114;&#x6f;&#x75;&#112;&#x73;&#46;&#99;&#111;&#109;&#93;&#40;&#41;">&#x5b;&#x70;&#111;&#110;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#x6f;&#111;&#x67;&#x6c;&#x65;&#x67;&#114;&#x6f;&#x75;&#112;&#x73;&#46;&#99;&#111;&#109;&#93;&#40;&#41;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育...</p>
</li>
</ol>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>阅读更多 &gt;&gt;
<a href="">显示删减掉的内容</a>
<img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-23</p>
<p>其他收件人：</p>
<p>Yeap.</p>
<p>On 3月23日, 上午3时37分, windstorm <a href="&#x6d;&#97;&#105;&#108;&#x74;&#111;&#58;&#91;&#x6c;&#105;&#x6b;&#x75;&#x6e;&#x61;&#114;&#x6d;&#115;&#x74;&#x72;&#46;&#46;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#105;&#108;&#x2e;&#99;&#x6f;&#109;&#x5d;&#x28;&#41;">&#91;&#x6c;&#105;&#x6b;&#x75;&#x6e;&#x61;&#114;&#x6d;&#115;&#x74;&#x72;&#46;&#46;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#105;&#108;&#x2e;&#99;&#x6f;&#109;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>女生？LJJ？</p>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>&gt;</p>
<blockquote>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Guancheng Chen <a href="&#x6d;&#97;&#105;&#108;&#x74;&#111;&#x3a;&#x5b;&#99;&#104;&#101;&#x6e;&#x67;&#x75;&#97;&#x6e;&#99;&#x68;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#99;&#x6f;&#109;&#x5d;&#40;&#41;">&#x5b;&#99;&#104;&#101;&#x6e;&#x67;&#x75;&#97;&#x6e;&#99;&#x68;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#99;&#x6f;&#109;&#x5d;&#40;&#41;</a>:</p>
<blockquote>
<p>恩</p>
<p>第二点其实我就是指程序员根据他自己的程序领域选择合适的并行技术。Top Language真是藏龙卧虎啊。你是在Boulder么?我一个大学女同
学在你那读MIS的phd</p>
<p>On 3月23日, 上午12时04分, windstorm <a href="&#x6d;&#97;&#x69;&#108;&#x74;&#x6f;&#x3a;&#x5b;&#x6c;&#x69;&#107;&#117;&#110;&#x61;&#114;&#x6d;&#x73;&#116;&#x72;&#46;&#46;&#x2e;&#x40;&#x67;&#x6d;&#97;&#105;&#108;&#46;&#99;&#x6f;&#109;&#93;&#40;&#x29;">&#x5b;&#x6c;&#x69;&#107;&#117;&#110;&#x61;&#114;&#x6d;&#x73;&#116;&#x72;&#46;&#46;&#x2e;&#x40;&#x67;&#x6d;&#97;&#105;&#108;&#46;&#99;&#x6f;&#109;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>全民并行编程的时代，只有在全民能够并行编程的时候才会到来嘛，现在不是这个时候</p>
<p>我个人倾向于等待一个比较好的统一性架构。两条路：</p>
<p>一是某一个全新概念的提出，这个要看学术界的努力，而且在某种意义上讲，学术界搞出一个真正可行的并行架构的可能性比工业界更高。虽说今天多核的发展是工业界引 领的，但是点子还是最早学术界提出的。典型的有几个：斯坦福的Hydra（1996），斯坦福的Imagine(2000)，MIT的RAW（2002），以及 UT奥斯丁的TRIPS（2003）。在这个问题上，是不得不佩服美国的创造力，要知道直到在2000年左右，所有的人都还在为处理器频率按照摩尔定律翻翻而狂 热，美国的顶尖研究员就早已看到了这条路的尽头并指出未来处理器的发展之路。</p>
<p>二是你用现有的架构，但是application引导。如果要找一个面向多application
domain的话，刚才说了，本来看好Larrabee，因为它的架构解决了CUDA一个很大的潜在问题，而且允许现有程序员不经过任何特殊training就 上手编程，包括图形图像，科学计算，或者网络处理，各个领域。</p>
<p>不过可能就是因为这个solution的过于理想化导致结构的过于复杂化，才让其目前暂时流产。</p>
<p>总的来说，现在的问题就是软件发展不成熟，硬件发展不完善，你没法靠程序员决定使用什么并行技术，完全靠应用主导，这套技术在这个应用上如鱼得水，在那个应用上 完全不罩，作为程序员，有什么办法？</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Guancheng Chen <a href="&#x6d;&#97;&#105;&#x6c;&#116;&#111;&#x3a;&#91;&#x63;&#x68;&#x65;&#110;&#103;&#117;&#97;&#x6e;&#99;&#x68;&#46;&#x2e;&#46;&#64;&#103;&#x6d;&#x61;&#x69;&#x6c;&#46;&#x63;&#111;&#x6d;&#x5d;&#x28;&#41;">&#91;&#x63;&#x68;&#x65;&#110;&#103;&#117;&#97;&#x6e;&#99;&#x68;&#46;&#x2e;&#46;&#64;&#103;&#x6d;&#x61;&#x69;&#x6c;&#46;&#x63;&#111;&#x6d;&#x5d;&#x28;&#41;</a>:</p>
<blockquote>
<p>教育以人为本，最终决定使用何种并行技术的还是程序员。目前业界对程序员并没有并行编程的技能要求，全民并行编程的时代什么时候才能到来？这是个问
题。</p>
<p>On 3月22日, 下午10时41分, windstorm <a href="&#x6d;&#97;&#x69;&#x6c;&#116;&#x6f;&#x3a;&#x5b;&#108;&#x69;&#107;&#117;&#x6e;&#97;&#x72;&#109;&#x73;&#x74;&#x72;&#x2e;&#46;&#46;&#64;&#x67;&#x6d;&#x61;&#x69;&#108;&#46;&#99;&#111;&#109;&#93;&#x28;&#x29;">&#x5b;&#108;&#x69;&#107;&#117;&#x6e;&#97;&#x72;&#109;&#x73;&#x74;&#x72;&#x2e;&#46;&#46;&#64;&#x67;&#x6d;&#x61;&#x69;&#108;&#46;&#99;&#111;&#109;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>Larrabee当初我还是很看好的，它的架构比其他的更像一个统一的方案，可惜后来Intel自己经验不足搞不好。</p>
<p>OPENCL还是主要面向multimedia吧，CUDA/OpenCL在业界代表了流处理的方向，从GPU针对任务的角度讲是好的。其他的就算了。就像Al leluia说的那样，在硬件架构没有更多的突破之前，不说没有生命力，至少想取得任何进一步的突破都太难。</p>
<p>现在这个领域，你吹你的水，我吹我的水。至于谁的泡泡大，我看不清。所以真要选东西学，最好还是针对自己的application选靠谱。这也是并行编程教育难 的问题。大家需求完全不一样。</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Guancheng Chen <a href="&#109;&#x61;&#x69;&#x6c;&#x74;&#111;&#x3a;&#x5b;&#99;&#104;&#101;&#x6e;&#103;&#117;&#97;&#x6e;&#x63;&#x68;&#x2e;&#x2e;&#x2e;&#64;&#103;&#109;&#97;&#x69;&#108;&#x2e;&#99;&#111;&#x6d;&#x5d;&#x28;&#x29;">&#x5b;&#99;&#104;&#101;&#x6e;&#103;&#117;&#97;&#x6e;&#x63;&#x68;&#x2e;&#x2e;&#x2e;&#64;&#103;&#109;&#97;&#x69;&#108;&#x2e;&#99;&#111;&#x6d;&#x5d;&#x28;&#x29;</a>:</p>
<blockquote>
<p>我觉得现有的OpenCL确实非常不成熟，但是从纯性能角度上来讲，我看好Heterogeneous架构，尽管它们的编程难度太大，就像前面提到的不
同架构需要做不同优化等。CPU的性能是latency-oriented，GPU是throughput-oriented,Intel的
Larrabee虽然现在来看不成功，但是业界都在朝着那个方向努力。</p>
<p>On 3月22日, 下午6时18分, windstorm <a href="&#x6d;&#97;&#x69;&#x6c;&#116;&#111;&#58;&#91;&#108;&#105;&#x6b;&#x75;&#110;&#x61;&#x72;&#x6d;&#x73;&#116;&#114;&#46;&#x2e;&#46;&#64;&#103;&#x6d;&#97;&#105;&#x6c;&#46;&#99;&#x6f;&#x6d;&#x5d;&#40;&#41;">&#91;&#108;&#105;&#x6b;&#x75;&#110;&#x61;&#x72;&#x6d;&#x73;&#116;&#114;&#46;&#x2e;&#46;&#64;&#103;&#x6d;&#97;&#105;&#x6c;&#46;&#99;&#x6f;&#x6d;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>实在是不能同意你更多......很早很早以前我就在这里和人争论过，GPU的并行计算平台不可能一统天下的。CUDA也不是救世主。OpenCL更不是。</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Alleluia <a href="&#109;&#x61;&#x69;&#x6c;&#x74;&#111;&#x3a;&#x5b;&#97;&#108;&#x6c;&#117;&#x6c;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#109;&#x61;&#x69;&#x6c;&#46;&#x63;&#111;&#109;&#93;&#40;&#41;">&#x5b;&#97;&#108;&#x6c;&#117;&#x6c;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#109;&#x61;&#x69;&#x6c;&#46;&#x63;&#111;&#109;&#93;&#40;&#41;</a>:</p>
<blockquote>
<p>Parallelism 说到底是算法问题.Parallelism与Concurrency不同,Concurrency所面对的问题相对的单一可以
让一群有经验的专家来实现一套通用库或者语言来提供一个基本的编程框架.而在Parallelism上,具体的不同问题,其所需要并行的算法是根本不同
的.原因在于不同的问题,其内部的DataDependency的结构完全不同,不同的Data Dependency的结构,需要构造不同的算法.即
便是相同的Data Dependency,在不同的颗粒度下，在不同的硬件条件下所采用的算法也是完全不同的.因为一旦出现Data
Dependency也就意味着并行计算模块之间需要进行通信.从以计算节点为单位的分布式并行,到多核CPU上的Numa结构,到SIMD上的向量处
理器,其计算单元之间的通信手段,通信效率简直天差地别.比如说,在SMP上最常见的并行算法,work stealing也就是Intel的TBB,
是建立在两个条件下第一个是CPU的Cache机制上,这使得通常在内存的之间的数据搬运消耗非常小,第二个是SMP上计算单元相对的少,因此每个计算
单元被分配到的任务就相对的重。其开销远远大于通信的开销,因此这种机制在SMP上相对的划算.但是如果你要在GPU上做Work Stealing就
完全不可行,因为GPU的运算单元数量极多,被分配到的任务就相对来说的非常轻量,CUDA上的一个thread很多时候运算一次的时间不会超过
10us,而一次跨Block的线程之间的通信开销就往往要达到100us左右,再加上目前GPU上的Cache机制非常落后导致了需要频繁的通信开销
的Work Stealing在GPU上是非常不划算得.
所以我个人认为在硬件架构没有更多的突破之前,OpenCL这种东西是没有任何生命力的.不要说CPU的并行与GPU之间差异巨大,就是不同的GPU之
间AMD与Nvidia两个也是各自为政,一个平台上跑得非常快的东西,在另外一个平台极大的可能是龟速.其最终的结果估计就是跟Java的
write once run everywhere一样是个大笑话.</p>
<p>On 3月22日, 下午2时06分, Guancheng Chen <a href="&#x6d;&#x61;&#x69;&#x6c;&#116;&#x6f;&#x3a;&#x5b;&#x63;&#x68;&#101;&#110;&#x67;&#117;&#x61;&#x6e;&#x63;&#x68;&#x2e;&#46;&#x2e;&#x40;&#x67;&#109;&#97;&#x69;&#108;&#46;&#x63;&#111;&#x6d;&#x5d;&#x28;&#x29;">&#x5b;&#x63;&#x68;&#101;&#110;&#x67;&#117;&#x61;&#x6e;&#x63;&#x68;&#x2e;&#46;&#x2e;&#x40;&#x67;&#109;&#97;&#x69;&#108;&#46;&#x63;&#111;&#x6d;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>On 3月22日, 上午2时20分, Tinyfool <a href="&#109;&#x61;&#105;&#108;&#116;&#x6f;&#58;&#91;&#x74;&#x69;&#110;&#121;&#x66;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#105;&#108;&#x2e;&#99;&#x6f;&#109;&#93;&#40;&#x29;">&#91;&#x74;&#x69;&#110;&#121;&#x66;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#105;&#108;&#x2e;&#99;&#x6f;&#109;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#x6d;&#97;&#105;&#x6c;&#x74;&#x6f;&#58;&#91;&#x6a;&#101;&#x2e;&#x2e;&#46;&#64;&#108;&#x69;&#118;&#x65;&#x2e;&#x63;&#111;&#109;&#x5d;&#x28;&#41;">&#91;&#x6a;&#101;&#x2e;&#x2e;&#46;&#64;&#108;&#x69;&#118;&#x65;&#x2e;&#x63;&#111;&#109;&#x5d;&#x28;&#41;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#x6d;&#x61;&#105;&#x6c;&#x74;&#x6f;&#58;&#x5b;&#99;&#x68;&#x65;&#x6e;&#x67;&#117;&#97;&#x6e;&#x63;&#x68;&#46;&#46;&#46;&#x40;&#x67;&#109;&#x61;&#105;&#108;&#x2e;&#99;&#x6f;&#109;&#x5d;&#40;&#41;">&#x5b;&#99;&#x68;&#x65;&#x6e;&#x67;&#117;&#97;&#x6e;&#x63;&#x68;&#46;&#46;&#46;&#x40;&#x67;&#109;&#x61;&#105;&#108;&#x2e;&#99;&#x6f;&#109;&#x5d;&#40;&#41;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#109;&#97;&#x69;&#108;&#x74;&#x6f;&#x3a;&#91;&#112;&#x6f;&#x6e;&#46;&#x2e;&#x2e;&#x40;&#x67;&#x6f;&#x6f;&#103;&#108;&#101;&#x67;&#x72;&#111;&#117;&#x70;&#115;&#x2e;&#99;&#111;&#x6d;&#x5d;&#40;&#41;">&#91;&#112;&#x6f;&#x6e;&#46;&#x2e;&#x2e;&#x40;&#x67;&#x6f;&#x6f;&#103;&#108;&#101;&#x67;&#x72;&#111;&#117;&#x70;&#115;&#x2e;&#99;&#111;&#x6d;&#x5d;&#40;&#41;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，...</li>
</ol>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>阅读更多 &gt;&gt;
<a href="">显示删减掉的内容</a></p>
</blockquote>
<p><img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-23</p>
<p>其他收件人：</p>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>On 3月23日, 上午9时15分, qiaojie <a href="&#109;&#97;&#x69;&#108;&#116;&#111;&#x3a;&#x5b;&#113;&#x69;&#97;&#111;&#x2e;&#x2e;&#x2e;&#64;&#103;&#109;&#97;&#x69;&#108;&#46;&#x63;&#x6f;&#109;&#93;&#40;&#x29;">&#x5b;&#113;&#x69;&#97;&#111;&#x2e;&#x2e;&#x2e;&#64;&#103;&#109;&#97;&#x69;&#108;&#46;&#x63;&#x6f;&#109;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1) =
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？
<a href="">显示删减掉的内容</a>
<img src="" alt=""> qiaojie <img src="" alt=""></p>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-23</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>目前正在写的是一个软件渲染器，采用了光栅化和光线跟踪混合算法，渲染算法已经完全并行化了，</p>
<p>在4核系统上基本可以达到线性加速比，更多核的系统暂时还没测试。kd-tree的构造暂时还没有并
行化，以后有空了再研究。</p>
<p>2010/3/23 Guancheng Chen <a href="&#109;&#x61;&#x69;&#108;&#x74;&#x6f;&#x3a;&#91;&#x63;&#x68;&#101;&#110;&#x67;&#117;&#x2e;&#46;&#46;&#64;&#x67;&#109;&#97;&#x69;&#108;&#46;&#99;&#111;&#109;&#x5d;&#40;&#41;">&#91;&#x63;&#x68;&#101;&#110;&#x67;&#117;&#x2e;&#46;&#46;&#64;&#x67;&#109;&#97;&#x69;&#108;&#46;&#99;&#111;&#109;&#x5d;&#40;&#41;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？
On 3月23日, 上午9时15分, qiaojie <a href="&#109;&#97;&#x69;&#108;&#116;&#x6f;&#58;&#91;&#x71;&#105;&#x61;&#111;&#46;&#x2e;&#46;&#x40;&#x67;&#109;&#97;&#105;&#x6c;&#46;&#x63;&#111;&#109;&#93;&#x28;&#x29;">&#91;&#x71;&#105;&#x61;&#111;&#46;&#x2e;&#46;&#x40;&#x67;&#109;&#97;&#105;&#x6c;&#46;&#x63;&#111;&#109;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1) =
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a></p>
<p><img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-24</p>
<p>其他收件人：</p>
<p>Nice 大胆预测Linear speedup应该是每个程序员十年后的目标 呵呵</p>
<p>On 3月23日, 上午10时43分, qiaojie <a href="&#109;&#97;&#105;&#x6c;&#x74;&#x6f;&#x3a;&#x5b;&#x71;&#105;&#97;&#x6f;&#46;&#46;&#46;&#64;&#103;&#109;&#97;&#105;&#x6c;&#46;&#x63;&#111;&#109;&#93;&#40;&#x29;">&#x5b;&#x71;&#105;&#97;&#x6f;&#46;&#46;&#46;&#64;&#103;&#109;&#97;&#105;&#x6c;&#46;&#x63;&#111;&#109;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>目前正在写的是一个软件渲染器，采用了光栅化和光线跟踪混合算法，渲染算法已经完全并行化了，
在4核系统上基本可以达到线性加速比，更多核的系统暂时还没测试。kd-tree的构造暂时还没有并
行化，以后有空了再研究。</p>
<p>2010/3/23 Guancheng Chen <a href="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#x6f;&#58;&#91;&#99;&#x68;&#101;&#110;&#103;&#x75;&#x61;&#110;&#x63;&#x68;&#x2e;&#x2e;&#46;&#64;&#x67;&#109;&#x61;&#105;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#41;">&#91;&#99;&#x68;&#101;&#110;&#103;&#x75;&#x61;&#110;&#x63;&#x68;&#x2e;&#x2e;&#46;&#64;&#x67;&#109;&#x61;&#105;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#41;</a></p>
</blockquote>
<p>&gt;
&gt;
&gt;</p>
<blockquote>
<blockquote>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？</p>
<p>On 3月23日, 上午9时15分, qiaojie <a href="&#x6d;&#97;&#105;&#x6c;&#116;&#x6f;&#x3a;&#x5b;&#x71;&#x69;&#97;&#111;&#x2e;&#46;&#x2e;&#64;&#103;&#109;&#x61;&#105;&#108;&#46;&#99;&#111;&#x6d;&#93;&#40;&#41;">&#x5b;&#x71;&#x69;&#97;&#111;&#x2e;&#46;&#x2e;&#64;&#103;&#109;&#x61;&#105;&#108;&#46;&#99;&#111;&#x6d;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1) =
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？</p>
</blockquote>
<p> To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> longshanksmo <img src="" alt=""></p>
</blockquote>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-24</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<h2 id="-cerl-2-0-">凑个热闹，也来个广告：CERL 2.0初具雏形。</h2>
<p>反者道之动，弱者道之用
<a href="">longsh...@gmail.com</a>
<a href="http://blog.csdn.net/longshanks/" target="_blank"><a href="http://blog.csdn.net/longshanks/">http://blog.csdn.net/longshanks/</a></a>
wave开通
<a href="">显示删减掉的内容</a></p>
<p><img src="" alt=""> qiaojie <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-24</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>不是所有的程序都需要并行化的，能用串行化解决的问题没必要并行，所以即使将来many-core系统成为主流，大部分程序员也没必要去搞并行计算。</p>
<p>我觉得未来的主流应该是类似cell这样一颗全功能核心带众多协处理核心的异构系统，这样才能达到最优的 性能/核心面积比。
2010/3/24 Guancheng Chen <a href="&#109;&#x61;&#105;&#108;&#116;&#x6f;&#58;&#x5b;&#99;&#x68;&#101;&#110;&#x67;&#117;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#97;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#x28;&#41;">&#x5b;&#99;&#x68;&#101;&#110;&#x67;&#117;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#97;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#x28;&#41;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>Nice 大胆预测Linear speedup应该是每个程序员十年后的目标 呵呵
On 3月23日, 上午10时43分, qiaojie <a href="&#x6d;&#97;&#105;&#x6c;&#116;&#111;&#58;&#91;&#113;&#105;&#97;&#111;&#x2e;&#46;&#46;&#x40;&#103;&#109;&#97;&#x69;&#108;&#46;&#x63;&#111;&#109;&#93;&#40;&#x29;">&#91;&#113;&#105;&#97;&#111;&#x2e;&#46;&#46;&#x40;&#103;&#109;&#97;&#x69;&#108;&#46;&#x63;&#111;&#109;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>目前正在写的是一个软件渲染器，采用了光栅化和光线跟踪混合算法，渲染算法已经完全并行化了，
在4核系统上基本可以达到线性加速比，更多核的系统暂时还没测试。kd-tree的构造暂时还没有并
行化，以后有空了再研究。</p>
<p>2010/3/23 Guancheng Chen <a href="&#109;&#97;&#105;&#x6c;&#116;&#111;&#58;&#91;&#99;&#104;&#101;&#110;&#x67;&#x75;&#x61;&#110;&#99;&#x68;&#46;&#x2e;&#46;&#x40;&#x67;&#109;&#97;&#x69;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#93;&#40;&#41;">&#91;&#99;&#104;&#101;&#110;&#x67;&#x75;&#x61;&#110;&#99;&#x68;&#46;&#x2e;&#46;&#x40;&#x67;&#109;&#97;&#x69;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#93;&#40;&#41;</a></p>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>&gt;
&gt;
&gt;</p>
<blockquote>
<blockquote>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？</p>
<p>On 3月23日, 上午9时15分, qiaojie <a href="&#x6d;&#97;&#x69;&#x6c;&#116;&#111;&#x3a;&#x5b;&#x71;&#105;&#97;&#111;&#x2e;&#46;&#46;&#64;&#103;&#x6d;&#x61;&#105;&#x6c;&#46;&#99;&#x6f;&#x6d;&#93;&#40;&#x29;">&#x5b;&#x71;&#105;&#97;&#111;&#x2e;&#46;&#46;&#64;&#103;&#x6d;&#x61;&#105;&#x6c;&#46;&#99;&#x6f;&#x6d;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1) =
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？</p>
</blockquote>
<p> To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> 机械唯物主义 : linjunhalida <img src="" alt=""></p>
</blockquote>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-24</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>我猜测未来的主流是数据中心，动态分配运算，存储资源。CPU，内存集群。
加上本地终端，运行一些本地进程，比如GUI，实时视频采集和分析什么的。CPU＋GPU。
根据需求和成本来考虑程序在本地或者数据中心。
其实好像这就是现在的状况？
未来的状况还是要局限于成本和性能，
如果瓶颈在数据传输，那么中心化趋势会很明显。
如果瓶颈在运算，那么程序员要花很多时间在并行处理上。
2010/3/24 qiaojie <a href="&#109;&#97;&#x69;&#108;&#x74;&#x6f;&#58;&#x5b;&#x71;&#x69;&#97;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#97;&#x69;&#108;&#46;&#x63;&#x6f;&#109;&#x5d;&#40;&#x29;">&#x5b;&#x71;&#x69;&#97;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#97;&#x69;&#108;&#46;&#x63;&#x6f;&#109;&#x5d;&#40;&#x29;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>不是所有的程序都需要并行化的，能用串行化解决的问题没必要并行，所以即使将来many-core系统成为主流，大部分程序员也没必要去搞并行计算。</p>
<p>我觉得未来的主流应该是类似cell这样一颗全功能核心带众多协处理核心的异构系统，这样才能达到最优的 性能/核心面积比。
2010/3/24 Guancheng Chen <a href="&#109;&#97;&#105;&#x6c;&#x74;&#x6f;&#58;&#91;&#99;&#104;&#x65;&#110;&#x67;&#x75;&#46;&#x2e;&#x2e;&#x40;&#x67;&#109;&#97;&#105;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#x28;&#x29;">&#91;&#99;&#104;&#x65;&#110;&#x67;&#x75;&#46;&#x2e;&#x2e;&#x40;&#x67;&#109;&#97;&#105;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#x28;&#x29;</a></p>
<p>Nice 大胆预测Linear speedup应该是每个程序员十年后的目标 呵呵
On 3月23日, 上午10时43分, qiaojie <a href="&#109;&#x61;&#x69;&#x6c;&#116;&#111;&#x3a;&#91;&#x71;&#x69;&#97;&#111;&#46;&#x2e;&#x2e;&#64;&#103;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#93;&#40;&#41;">&#91;&#x71;&#x69;&#97;&#111;&#46;&#x2e;&#x2e;&#64;&#103;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>目前正在写的是一个软件渲染器，采用了光栅化和光线跟踪混合算法，渲染算法已经完全并行化了，
在4核系统上基本可以达到线性加速比，更多核的系统暂时还没测试。kd-tree的构造暂时还没有并
行化，以后有空了再研究。</p>
<p>2010/3/23 Guancheng Chen <a href="&#109;&#97;&#x69;&#108;&#x74;&#x6f;&#58;&#91;&#x63;&#104;&#x65;&#x6e;&#103;&#117;&#x61;&#110;&#x63;&#x68;&#x2e;&#46;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#105;&#x6c;&#46;&#x63;&#111;&#x6d;&#93;&#x28;&#x29;">&#91;&#x63;&#104;&#x65;&#x6e;&#103;&#117;&#x61;&#110;&#x63;&#x68;&#x2e;&#46;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#105;&#x6c;&#46;&#x63;&#111;&#x6d;&#93;&#x28;&#x29;</a></p>
<blockquote>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？</p>
<p>On 3月23日, 上午9时15分, qiaojie <a href="&#x6d;&#x61;&#x69;&#108;&#116;&#x6f;&#x3a;&#x5b;&#x71;&#x69;&#x61;&#x6f;&#46;&#x2e;&#46;&#64;&#103;&#x6d;&#97;&#x69;&#x6c;&#46;&#x63;&#111;&#109;&#x5d;&#40;&#x29;">&#x5b;&#x71;&#x69;&#x61;&#x6f;&#46;&#x2e;&#46;&#64;&#103;&#x6d;&#97;&#x69;&#x6c;&#46;&#x63;&#111;&#109;&#x5d;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1) =
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？</p>
</blockquote>
<p> To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a></p>
<p><img src="" alt=""> Hongzh...@gmail.com <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-24</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>异构平台如果编程复杂度降不下来的话很难流行起来。cell已经死了...
2010/3/24 qiaojie <a href="&#109;&#x61;&#x69;&#x6c;&#x74;&#111;&#x3a;&#91;&#113;&#105;&#97;&#x2e;&#46;&#46;&#64;&#103;&#109;&#x61;&#105;&#x6c;&#x2e;&#99;&#111;&#109;&#x5d;&#x28;&#x29;">&#91;&#113;&#105;&#97;&#x2e;&#46;&#46;&#64;&#103;&#109;&#x61;&#105;&#x6c;&#x2e;&#99;&#111;&#109;&#x5d;&#x28;&#x29;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>不是所有的程序都需要并行化的，能用串行化解决的问题没必要并行，所以即使将来many-core系统成为主流，大部分程序员也没必要去搞并行计算。</p>
<p>我觉得未来的主流应该是类似cell这样一颗全功能核心带众多协处理核心的异构系统，这样才能达到最优的 性能/核心面积比。
2010/3/24 Guancheng Chen <a href="&#x6d;&#x61;&#x69;&#108;&#x74;&#111;&#x3a;&#x5b;&#x63;&#104;&#101;&#x6e;&#103;&#117;&#46;&#x2e;&#46;&#x40;&#103;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#99;&#111;&#109;&#93;&#40;&#41;">&#x5b;&#x63;&#104;&#101;&#x6e;&#103;&#117;&#46;&#x2e;&#46;&#x40;&#103;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#99;&#111;&#109;&#93;&#40;&#41;</a></p>
<p>Nice 大胆预测Linear speedup应该是每个程序员十年后的目标 呵呵
On 3月23日, 上午10时43分, qiaojie <a href="&#109;&#x61;&#x69;&#108;&#116;&#x6f;&#x3a;&#91;&#113;&#105;&#97;&#111;&#x2e;&#x2e;&#46;&#x40;&#103;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#93;&#40;&#x29;">&#91;&#113;&#105;&#97;&#111;&#x2e;&#x2e;&#46;&#x40;&#103;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>目前正在写的是一个软件渲染器，采用了光栅化和光线跟踪混合算法，渲染算法已经完全并行化了，
在4核系统上基本可以达到线性加速比，更多核的系统暂时还没测试。kd-tree的构造暂时还没有并
行化，以后有空了再研究。</p>
<p>2010/3/23 Guancheng Chen <a href="&#109;&#97;&#105;&#x6c;&#116;&#x6f;&#58;&#91;&#99;&#104;&#101;&#x6e;&#103;&#117;&#97;&#x6e;&#99;&#x68;&#46;&#46;&#x2e;&#x40;&#x67;&#x6d;&#97;&#x69;&#108;&#46;&#99;&#111;&#x6d;&#x5d;&#x28;&#x29;">&#91;&#99;&#104;&#101;&#x6e;&#103;&#117;&#97;&#x6e;&#99;&#x68;&#46;&#46;&#x2e;&#x40;&#x67;&#x6d;&#97;&#x69;&#108;&#46;&#99;&#111;&#x6d;&#x5d;&#x28;&#x29;</a></p>
<blockquote>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？</p>
<p>On 3月23日, 上午9时15分, qiaojie <a href="&#109;&#97;&#105;&#108;&#116;&#x6f;&#58;&#x5b;&#113;&#105;&#x61;&#111;&#x2e;&#46;&#x2e;&#64;&#x67;&#109;&#97;&#x69;&#x6c;&#x2e;&#x63;&#111;&#109;&#x5d;&#x28;&#41;">&#x5b;&#113;&#105;&#x61;&#111;&#x2e;&#46;&#x2e;&#64;&#x67;&#109;&#97;&#x69;&#x6c;&#x2e;&#x63;&#111;&#109;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1) =
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？</p>
</blockquote>
<p> To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> qiaojie <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-24</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>说的没错，cell已经成了先烈了。不过这不代表异构的方向不对，CUDA，OpenCL也都是异构平台，以后我们会越来越习惯异构平台的。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#109;&#x61;&#105;&#x6c;&#116;&#x6f;&#58;&#91;&#104;&#111;&#110;&#103;&#x7a;&#104;&#x2e;&#46;&#46;&#x40;&#x67;&#x6d;&#97;&#105;&#108;&#46;&#99;&#111;&#109;&#x5d;&#40;&#x29;">&#91;&#104;&#111;&#110;&#103;&#x7a;&#104;&#x2e;&#46;&#46;&#x40;&#x67;&#x6d;&#97;&#105;&#108;&#46;&#99;&#111;&#109;&#x5d;&#40;&#x29;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>异构平台如果编程复杂度降不下来的话很难流行起来。cell已经死了...
2010/3/24 qiaojie <a href="&#109;&#x61;&#x69;&#108;&#x74;&#x6f;&#58;&#91;&#x71;&#x69;&#97;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#109;&#97;&#105;&#108;&#46;&#x63;&#111;&#109;&#x5d;&#x28;&#x29;">&#91;&#x71;&#x69;&#97;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#109;&#97;&#105;&#108;&#46;&#x63;&#111;&#109;&#x5d;&#x28;&#x29;</a>
 不是所有的程序都需要并行化的，能用串行化解决的问题没必要并行，所以即使将来many-core系统成为主流，大部分程序员也没必要去搞并行计算。</p>
<p>我觉得未来的主流应该是类似cell这样一颗全功能核心带众多协处理核心的异构系统，这样才能达到最优的 性能/核心面积比。</p>
<p>2010/3/24 Guancheng Chen <a href="&#x6d;&#x61;&#105;&#108;&#116;&#x6f;&#58;&#x5b;&#x63;&#104;&#101;&#x6e;&#103;&#x75;&#46;&#46;&#46;&#x40;&#103;&#x6d;&#x61;&#105;&#108;&#46;&#99;&#111;&#109;&#x5d;&#x28;&#41;">&#x5b;&#x63;&#104;&#101;&#x6e;&#103;&#x75;&#46;&#46;&#46;&#x40;&#103;&#x6d;&#x61;&#105;&#108;&#46;&#99;&#111;&#109;&#x5d;&#x28;&#41;</a></p>
<p>Nice 大胆预测Linear speedup应该是每个程序员十年后的目标 呵呵
On 3月23日, 上午10时43分, qiaojie <a href="&#109;&#97;&#x69;&#x6c;&#116;&#111;&#58;&#91;&#113;&#105;&#x61;&#111;&#x2e;&#x2e;&#46;&#x40;&#103;&#109;&#x61;&#105;&#108;&#x2e;&#x63;&#x6f;&#109;&#93;&#40;&#x29;">&#91;&#113;&#105;&#x61;&#111;&#x2e;&#x2e;&#46;&#x40;&#103;&#109;&#x61;&#105;&#108;&#x2e;&#x63;&#x6f;&#109;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>目前正在写的是一个软件渲染器，采用了光栅化和光线跟踪混合算法，渲染算法已经完全并行化了，
在4核系统上基本可以达到线性加速比，更多核的系统暂时还没测试。kd-tree的构造暂时还没有并
行化，以后有空了再研究。</p>
<p>2010/3/23 Guancheng Chen <a href="&#109;&#x61;&#105;&#108;&#x74;&#x6f;&#x3a;&#x5b;&#x63;&#104;&#101;&#110;&#x67;&#117;&#x61;&#x6e;&#99;&#x68;&#46;&#x2e;&#46;&#64;&#103;&#x6d;&#97;&#x69;&#x6c;&#46;&#99;&#x6f;&#109;&#93;&#40;&#x29;">&#x5b;&#x63;&#104;&#101;&#110;&#x67;&#117;&#x61;&#x6e;&#99;&#x68;&#46;&#x2e;&#46;&#64;&#103;&#x6d;&#97;&#x69;&#x6c;&#46;&#99;&#x6f;&#109;&#93;&#40;&#x29;</a></p>
<blockquote>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？</p>
<p>On 3月23日, 上午9时15分, qiaojie <a href="&#x6d;&#x61;&#x69;&#108;&#x74;&#111;&#x3a;&#x5b;&#113;&#105;&#97;&#111;&#x2e;&#x2e;&#46;&#x40;&#x67;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#109;&#x5d;&#x28;&#x29;">&#x5b;&#113;&#105;&#97;&#111;&#x2e;&#x2e;&#46;&#x40;&#x67;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#109;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1) =
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？</p>
</blockquote>
<p> To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a></p>
<p><img src="" alt=""> sunjoy <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-24</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>挺有意思的，我之前没有接触过并行计算的相关理论，按照你的公式我花了个图，反映并行度、加速比以及CPU核之间的关系。</p>
<p>2010/3/23 qiaojie <a href="&#109;&#x61;&#x69;&#108;&#x74;&#111;&#x3a;&#x5b;&#113;&#x69;&#x61;&#x2e;&#46;&#x2e;&#x40;&#x67;&#109;&#x61;&#105;&#108;&#46;&#99;&#111;&#x6d;&#93;&#x28;&#41;">&#x5b;&#113;&#x69;&#x61;&#x2e;&#46;&#x2e;&#x40;&#x67;&#109;&#x61;&#105;&#108;&#46;&#99;&#111;&#x6d;&#93;&#x28;&#41;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1) = 5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？
 To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a></p>
<p>附件 (1)</p>
<p><a href="https://groups.google.com/group/pongba/attach/53e12db326792d31/parallelism.png?part=4&amp;authuser=0&amp;view=1" title="parallelism.png"></a></p>
<p>parallelism.png 23 KB   <a href="https://groups.google.com/group/pongba/attach/53e12db326792d31/parallelism.png?part=4&amp;authuser=0&amp;view=1" target="_blank">查看</a>   <a href="https://groups.google.com/group/pongba/attach/53e12db326792d31/parallelism.png?part=4&amp;authuser=0" target="_blank">下载</a>
<img src="" alt=""> Hongzh...@gmail.com <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-24</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>异构平台从网络处理器算起已经快10年了，现在情况仍然不明朗。就我看到的，异构平台要想高效，就必须向程序员暴露非常多的硬件细节，这必然导致编程的复杂性。曲高和寡，要想渗透到应用程序这一块，我觉得很难。</p>
<p>2010/3/24 qiaojie <a href="&#109;&#x61;&#x69;&#x6c;&#116;&#x6f;&#x3a;&#91;&#x71;&#x69;&#x61;&#x2e;&#46;&#x2e;&#64;&#x67;&#x6d;&#x61;&#x69;&#108;&#46;&#99;&#x6f;&#109;&#93;&#x28;&#41;">&#91;&#x71;&#x69;&#x61;&#x2e;&#46;&#x2e;&#64;&#x67;&#x6d;&#x61;&#x69;&#108;&#46;&#99;&#x6f;&#109;&#93;&#x28;&#41;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>说的没错，cell已经成了先烈了。不过这不代表异构的方向不对，CUDA，OpenCL也都是异构平台，以后我们会越来越习惯异构平台的。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#109;&#x61;&#105;&#108;&#x74;&#x6f;&#58;&#x5b;&#104;&#x6f;&#110;&#x67;&#122;&#104;&#46;&#x2e;&#x2e;&#64;&#103;&#x6d;&#x61;&#105;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#93;&#40;&#x29;">&#x5b;&#104;&#x6f;&#110;&#x67;&#122;&#104;&#46;&#x2e;&#x2e;&#64;&#103;&#x6d;&#x61;&#105;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#93;&#40;&#x29;</a></p>
<p>异构平台如果编程复杂度降不下来的话很难流行起来。cell已经死了...
2010/3/24 qiaojie <a href="&#109;&#97;&#x69;&#108;&#116;&#x6f;&#x3a;&#91;&#113;&#105;&#97;&#46;&#46;&#46;&#64;&#x67;&#109;&#97;&#x69;&#108;&#46;&#x63;&#x6f;&#109;&#93;&#x28;&#x29;">&#91;&#113;&#105;&#97;&#46;&#46;&#46;&#64;&#x67;&#109;&#97;&#x69;&#108;&#46;&#x63;&#x6f;&#109;&#93;&#x28;&#x29;</a>
 不是所有的程序都需要并行化的，能用串行化解决的问题没必要并行，所以即使将来many-core系统成为主流，大部分程序员也没必要去搞并行计算。</p>
<p>我觉得未来的主流应该是类似cell这样一颗全功能核心带众多协处理核心的异构系统，这样才能达到最优的 性能/核心面积比。</p>
<p>2010/3/24 Guancheng Chen <a href="&#109;&#x61;&#105;&#x6c;&#116;&#111;&#x3a;&#91;&#99;&#104;&#x65;&#x6e;&#x67;&#117;&#46;&#46;&#46;&#64;&#x67;&#109;&#97;&#105;&#108;&#46;&#x63;&#x6f;&#109;&#93;&#40;&#x29;">&#91;&#99;&#104;&#x65;&#x6e;&#x67;&#117;&#46;&#46;&#46;&#64;&#x67;&#109;&#97;&#105;&#108;&#46;&#x63;&#x6f;&#109;&#93;&#40;&#x29;</a></p>
<p>Nice 大胆预测Linear speedup应该是每个程序员十年后的目标 呵呵
On 3月23日, 上午10时43分, qiaojie <a href="&#x6d;&#x61;&#x69;&#108;&#x74;&#x6f;&#x3a;&#x5b;&#113;&#105;&#97;&#111;&#46;&#x2e;&#46;&#x40;&#x67;&#109;&#97;&#x69;&#108;&#x2e;&#99;&#x6f;&#x6d;&#93;&#40;&#x29;">&#x5b;&#113;&#105;&#97;&#111;&#46;&#x2e;&#46;&#x40;&#x67;&#109;&#97;&#x69;&#108;&#x2e;&#99;&#x6f;&#x6d;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>目前正在写的是一个软件渲染器，采用了光栅化和光线跟踪混合算法，渲染算法已经完全并行化了，
在4核系统上基本可以达到线性加速比，更多核的系统暂时还没测试。kd-tree的构造暂时还没有并
行化，以后有空了再研究。</p>
<p>2010/3/23 Guancheng Chen <a href="&#109;&#x61;&#105;&#x6c;&#x74;&#x6f;&#x3a;&#x5b;&#99;&#104;&#x65;&#110;&#103;&#117;&#97;&#110;&#x63;&#104;&#x2e;&#46;&#46;&#x40;&#103;&#109;&#97;&#x69;&#x6c;&#46;&#x63;&#x6f;&#109;&#93;&#40;&#x29;">&#x5b;&#99;&#104;&#x65;&#110;&#103;&#117;&#97;&#110;&#x63;&#104;&#x2e;&#46;&#46;&#x40;&#103;&#109;&#97;&#x69;&#x6c;&#46;&#x63;&#x6f;&#109;&#93;&#40;&#x29;</a></p>
<blockquote>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？</p>
<p>On 3月23日, 上午9时15分, qiaojie <a href="&#x6d;&#x61;&#x69;&#108;&#x74;&#111;&#58;&#x5b;&#x71;&#x69;&#97;&#111;&#x2e;&#x2e;&#46;&#64;&#103;&#x6d;&#x61;&#x69;&#108;&#x2e;&#99;&#x6f;&#109;&#x5d;&#x28;&#41;">&#x5b;&#x71;&#x69;&#97;&#111;&#x2e;&#x2e;&#46;&#64;&#103;&#x6d;&#x61;&#x69;&#108;&#x2e;&#99;&#x6f;&#109;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1) =
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？</p>
</blockquote>
<p> To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a></p>
<p><img src="" alt=""> qiaojie <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-24</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>并行计算本来就是曲高和寡的东西，就跟3D渲染一样，能开发引擎的毕竟只是小部分人，大多数人在引擎的基础上做应用。关键在于是否有杀手应用，只要有大量的需求，自然会有人去做开发。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#109;&#x61;&#x69;&#108;&#116;&#x6f;&#58;&#91;&#x68;&#x6f;&#x6e;&#x67;&#x7a;&#104;&#46;&#46;&#x2e;&#x40;&#x67;&#109;&#x61;&#105;&#108;&#x2e;&#99;&#111;&#109;&#x5d;&#x28;&#41;">&#91;&#x68;&#x6f;&#x6e;&#x67;&#x7a;&#104;&#46;&#46;&#x2e;&#x40;&#x67;&#109;&#x61;&#105;&#108;&#x2e;&#99;&#111;&#109;&#x5d;&#x28;&#41;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>异构平台从网络处理器算起已经快10年了，现在情况仍然不明朗。就我看到的，异构平台要想高效，就必须向程序员暴露非常多的硬件细节，这必然导致编程的复杂性。曲高和寡，要想渗透到应用程序这一块，我觉得很难。</p>
<p>2010/3/24 qiaojie <a href="&#109;&#x61;&#x69;&#x6c;&#116;&#111;&#58;&#x5b;&#113;&#105;&#97;&#46;&#46;&#46;&#64;&#x67;&#109;&#x61;&#x69;&#108;&#x2e;&#99;&#111;&#109;&#x5d;&#x28;&#x29;">&#x5b;&#113;&#105;&#97;&#46;&#46;&#46;&#64;&#x67;&#109;&#x61;&#x69;&#108;&#x2e;&#99;&#111;&#109;&#x5d;&#x28;&#x29;</a>
说的没错，cell已经成了先烈了。不过这不代表异构的方向不对，CUDA，OpenCL也都是异构平台，以后我们会越来越习惯异构平台的。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#x6d;&#x61;&#105;&#x6c;&#x74;&#111;&#x3a;&#91;&#x68;&#x6f;&#x6e;&#x67;&#122;&#104;&#46;&#x2e;&#x2e;&#64;&#103;&#109;&#97;&#x69;&#x6c;&#46;&#99;&#111;&#109;&#x5d;&#40;&#41;">&#91;&#x68;&#x6f;&#x6e;&#x67;&#122;&#104;&#46;&#x2e;&#x2e;&#64;&#103;&#109;&#97;&#x69;&#x6c;&#46;&#99;&#111;&#109;&#x5d;&#40;&#41;</a></p>
<p>异构平台如果编程复杂度降不下来的话很难流行起来。cell已经死了...
2010/3/24 qiaojie <a href="&#x6d;&#97;&#105;&#108;&#116;&#x6f;&#x3a;&#91;&#113;&#x69;&#97;&#46;&#46;&#46;&#x40;&#x67;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#x63;&#111;&#109;&#x5d;&#x28;&#41;">&#91;&#113;&#x69;&#97;&#46;&#46;&#46;&#x40;&#x67;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#x63;&#111;&#109;&#x5d;&#x28;&#41;</a>
 不是所有的程序都需要并行化的，能用串行化解决的问题没必要并行，所以即使将来many-core系统成为主流，大部分程序员也没必要去搞并行计算。</p>
<p>我觉得未来的主流应该是类似cell这样一颗全功能核心带众多协处理核心的异构系统，这样才能达到最优的 性能/核心面积比。</p>
<p>2010/3/24 Guancheng Chen <a href="&#x6d;&#x61;&#105;&#108;&#116;&#x6f;&#x3a;&#91;&#x63;&#104;&#x65;&#x6e;&#103;&#x75;&#46;&#46;&#x2e;&#64;&#x67;&#x6d;&#x61;&#105;&#108;&#x2e;&#99;&#111;&#x6d;&#x5d;&#40;&#x29;">&#91;&#x63;&#104;&#x65;&#x6e;&#103;&#x75;&#46;&#46;&#x2e;&#64;&#x67;&#x6d;&#x61;&#105;&#108;&#x2e;&#99;&#111;&#x6d;&#x5d;&#40;&#x29;</a></p>
<p>Nice 大胆预测Linear speedup应该是每个程序员十年后的目标 呵呵
On 3月23日, 上午10时43分, qiaojie <a href="&#109;&#x61;&#105;&#x6c;&#x74;&#x6f;&#x3a;&#91;&#x71;&#105;&#x61;&#111;&#x2e;&#x2e;&#46;&#64;&#x67;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#x6d;&#x5d;&#40;&#41;">&#91;&#x71;&#105;&#x61;&#111;&#x2e;&#x2e;&#46;&#64;&#x67;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#x6d;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>目前正在写的是一个软件渲染器，采用了光栅化和光线跟踪混合算法，渲染算法已经完全并行化了，
在4核系统上基本可以达到线性加速比，更多核的系统暂时还没测试。kd-tree的构造暂时还没有并
行化，以后有空了再研究。</p>
<p>2010/3/23 Guancheng Chen <a href="&#x6d;&#97;&#x69;&#x6c;&#116;&#111;&#58;&#91;&#99;&#104;&#x65;&#110;&#103;&#117;&#x61;&#x6e;&#99;&#104;&#46;&#x2e;&#46;&#x40;&#103;&#x6d;&#x61;&#105;&#108;&#x2e;&#x63;&#111;&#109;&#x5d;&#x28;&#41;">&#91;&#99;&#104;&#x65;&#110;&#103;&#117;&#x61;&#x6e;&#99;&#104;&#46;&#x2e;&#46;&#x40;&#103;&#x6d;&#x61;&#105;&#108;&#x2e;&#x63;&#111;&#109;&#x5d;&#x28;&#41;</a></p>
<blockquote>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？</p>
<p>On 3月23日, 上午9时15分, qiaojie <a href="&#x6d;&#x61;&#x69;&#x6c;&#116;&#x6f;&#58;&#91;&#x71;&#105;&#x61;&#111;&#46;&#46;&#x2e;&#x40;&#103;&#109;&#97;&#105;&#x6c;&#46;&#x63;&#111;&#109;&#93;&#x28;&#x29;">&#91;&#x71;&#105;&#x61;&#111;&#46;&#46;&#x2e;&#x40;&#103;&#109;&#97;&#105;&#x6c;&#46;&#x63;&#111;&#109;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1) =
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？</p>
</blockquote>
<p> To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-25</p>
<p>其他收件人：</p>
<p>杀手应用一般来说是指什么样的应用呢？比如用户群特别大的网游？还是那些专有的科学计算用的软件？</p>
<p>On 3月24日, 下午12时36分, qiaojie <a href="&#109;&#97;&#x69;&#x6c;&#x74;&#x6f;&#x3a;&#91;&#113;&#105;&#97;&#x6f;&#x2e;&#46;&#x2e;&#64;&#103;&#109;&#97;&#105;&#x6c;&#x2e;&#99;&#111;&#x6d;&#93;&#x28;&#41;">&#91;&#113;&#105;&#97;&#x6f;&#x2e;&#46;&#x2e;&#64;&#103;&#109;&#97;&#105;&#x6c;&#x2e;&#99;&#111;&#x6d;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>并行计算本来就是曲高和寡的东西，就跟3D渲染一样，能开发引擎的毕竟只是小部分人，大多数人在引擎的基础上做应用。关键在于是否有杀手应用，只要有大量的需求 ，自然会有人去做开发。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#x6d;&#97;&#x69;&#x6c;&#x74;&#111;&#58;&#91;&#x68;&#111;&#110;&#103;&#122;&#104;&#x61;&#110;&#x67;&#46;&#x2e;&#x2e;&#x2e;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#x63;&#111;&#109;&#x5d;&#40;&#x29;">&#91;&#x68;&#111;&#110;&#103;&#122;&#104;&#x61;&#110;&#x67;&#46;&#x2e;&#x2e;&#x2e;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#x63;&#111;&#109;&#x5d;&#40;&#x29;</a></p>
</blockquote>
<p>&gt;
&gt;
&gt;</p>
<blockquote>
<blockquote>
<p>异构平台从网络处理器算起已经快10年了，现在情况仍然不明朗。就我看到的，异构平台要想高效，就必须向程序员暴露非常多的硬件细节，这必然导致编程的复杂性。 曲高和寡，要想渗透到应用程序这一块，我觉得很难。</p>
<p>2010/3/24 qiaojie <a href="&#x6d;&#x61;&#105;&#x6c;&#x74;&#x6f;&#x3a;&#91;&#113;&#105;&#97;&#111;&#46;&#x2e;&#x2e;&#x40;&#103;&#109;&#x61;&#x69;&#108;&#46;&#99;&#111;&#109;&#93;&#40;&#x29;">&#91;&#113;&#105;&#97;&#111;&#46;&#x2e;&#x2e;&#x40;&#103;&#109;&#x61;&#x69;&#108;&#46;&#99;&#111;&#109;&#93;&#40;&#x29;</a></p>
</blockquote>
</blockquote>
<p>&gt;</p>
<blockquote>
<blockquote>
<blockquote>
<p>说的没错，cell已经成了先烈了。不过这不代表异构的方向不对，CUDA，OpenCL也都是异构平台，以后我们会越来越习惯异构平台的。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#x6d;&#x61;&#105;&#108;&#x74;&#111;&#58;&#91;&#x68;&#111;&#110;&#103;&#122;&#x68;&#97;&#110;&#103;&#46;&#x2e;&#46;&#46;&#64;&#x67;&#109;&#x61;&#x69;&#x6c;&#46;&#99;&#x6f;&#x6d;&#x5d;&#40;&#41;">&#91;&#x68;&#111;&#110;&#103;&#122;&#x68;&#97;&#110;&#103;&#46;&#x2e;&#46;&#46;&#64;&#x67;&#109;&#x61;&#x69;&#x6c;&#46;&#99;&#x6f;&#x6d;&#x5d;&#40;&#41;</a></p>
<p>异构平台如果编程复杂度降不下来的话很难流行起来。cell已经死了...</p>
<blockquote>
<p> 2010/3/24 qiaojie <a href="&#x6d;&#x61;&#x69;&#x6c;&#116;&#x6f;&#x3a;&#91;&#113;&#x69;&#x61;&#111;&#46;&#46;&#46;&#x40;&#103;&#x6d;&#x61;&#x69;&#x6c;&#46;&#99;&#x6f;&#x6d;&#93;&#x28;&#41;">&#91;&#113;&#x69;&#x61;&#111;&#46;&#46;&#46;&#x40;&#103;&#x6d;&#x61;&#x69;&#x6c;&#46;&#99;&#x6f;&#x6d;&#93;&#x28;&#41;</a></p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>&gt;</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>不是所有的程序都需要并行化的，能用串行化解决的问题没必要并行，所以即使将来many-core系统成为主流，大部分程序员也没必要去搞并行计算。
  我觉得未来的主流应该是类似cell这样一颗全功能核心带众多协处理核心的异构系统，这样才能达到最优的 性能/核心面积比。</p>
<p>2010/3/24 Guancheng Chen <a href="&#109;&#x61;&#x69;&#108;&#116;&#x6f;&#x3a;&#91;&#x63;&#x68;&#x65;&#x6e;&#x67;&#x75;&#97;&#110;&#99;&#104;&#46;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#97;&#x69;&#108;&#46;&#99;&#111;&#109;&#x5d;&#40;&#41;">&#91;&#x63;&#x68;&#x65;&#x6e;&#x67;&#x75;&#97;&#110;&#99;&#104;&#46;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#97;&#x69;&#108;&#46;&#99;&#111;&#109;&#x5d;&#40;&#41;</a></p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>&gt;</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>Nice 大胆预测Linear speedup应该是每个程序员十年后的目标 呵呵</p>
<blockquote>
<p>On 3月23日, 上午10时43分, qiaojie <a href="&#x6d;&#x61;&#105;&#x6c;&#116;&#x6f;&#x3a;&#91;&#113;&#105;&#x61;&#111;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#109;&#97;&#x69;&#x6c;&#46;&#99;&#x6f;&#x6d;&#93;&#40;&#41;">&#91;&#113;&#105;&#x61;&#111;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#109;&#97;&#x69;&#x6c;&#46;&#99;&#x6f;&#x6d;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>目前正在写的是一个软件渲染器，采用了光栅化和光线跟踪混合算法，渲染算法已经完全并行化了，
在4核系统上基本可以达到线性加速比，更多核的系统暂时还没测试。kd-tree的构造暂时还没有并
行化，以后有空了再研究。</p>
<p>2010/3/23 Guancheng Chen <a href="&#109;&#97;&#x69;&#x6c;&#116;&#111;&#58;&#x5b;&#x63;&#x68;&#101;&#x6e;&#x67;&#117;&#97;&#110;&#x63;&#x68;&#x2e;&#46;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#105;&#108;&#46;&#x63;&#111;&#x6d;&#93;&#40;&#x29;">&#x5b;&#x63;&#x68;&#101;&#x6e;&#x67;&#117;&#97;&#110;&#x63;&#x68;&#x2e;&#46;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#105;&#108;&#46;&#x63;&#111;&#x6d;&#93;&#40;&#x29;</a></p>
<blockquote>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？</p>
<p>On 3月23日, 上午9时15分, qiaojie <a href="&#x6d;&#x61;&#105;&#x6c;&#x74;&#111;&#x3a;&#91;&#113;&#105;&#x61;&#x6f;&#46;&#46;&#x2e;&#64;&#x67;&#x6d;&#97;&#x69;&#108;&#46;&#99;&#111;&#109;&#93;&#x28;&#x29;">&#91;&#113;&#105;&#x61;&#x6f;&#46;&#46;&#x2e;&#64;&#x67;&#x6d;&#97;&#x69;&#108;&#46;&#99;&#111;&#109;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1)
=
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank
Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？</p>
</blockquote>
<p> To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
<a href="">显示删减掉的内容</a></p>
</blockquote>
</blockquote>
<p><img src="" alt=""> qiaojie <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-25</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>3D游戏就是一类杀手应用，由此支撑起了一个庞大的GPU市场，芯片行业的研发成本是很高的，没有一个庞大的市场是做不起来的。目前的消费者对于多核系统显然还没有强烈的需求，因为应用跟不上，i7发布快2年了还没进入主流市场，这种情况延续下去的话摩尔定律将因此失效。不过我相信杀手级应用总会出现的，这可能要硬件性能突破一个临界点，比方说目前GPU的性能再提升一个数量级的话，光线跟踪算法就可以提供流畅的接近CG的画质，倒是此类应用便会流行开来。</p>
<p>2010/3/25 Guancheng Chen <a href="&#x6d;&#x61;&#105;&#x6c;&#x74;&#111;&#58;&#x5b;&#99;&#104;&#x65;&#x6e;&#x67;&#117;&#46;&#46;&#x2e;&#x40;&#x67;&#x6d;&#97;&#105;&#x6c;&#x2e;&#x63;&#111;&#109;&#93;&#40;&#x29;">&#x5b;&#99;&#104;&#x65;&#x6e;&#x67;&#117;&#46;&#46;&#x2e;&#x40;&#x67;&#x6d;&#97;&#105;&#x6c;&#x2e;&#x63;&#111;&#109;&#93;&#40;&#x29;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>杀手应用一般来说是指什么样的应用呢？比如用户群特别大的网游？还是那些专有的科学计算用的软件？
On 3月24日, 下午12时36分, qiaojie <a href="&#109;&#x61;&#105;&#108;&#x74;&#111;&#x3a;&#91;&#x71;&#105;&#97;&#111;&#46;&#46;&#46;&#64;&#103;&#x6d;&#97;&#x69;&#108;&#x2e;&#99;&#x6f;&#109;&#93;&#x28;&#x29;">&#91;&#x71;&#105;&#97;&#111;&#46;&#46;&#46;&#64;&#103;&#x6d;&#97;&#x69;&#108;&#x2e;&#99;&#x6f;&#109;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>并行计算本来就是曲高和寡的东西，就跟3D渲染一样，能开发引擎的毕竟只是小部分人，大多数人在引擎的基础上做应用。关键在于是否有杀手应用，只要有大量的需求 ，自然会有人去做开发。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#109;&#97;&#x69;&#x6c;&#116;&#111;&#58;&#x5b;&#x68;&#x6f;&#110;&#103;&#x7a;&#104;&#97;&#x6e;&#103;&#x2e;&#46;&#x2e;&#46;&#64;&#103;&#x6d;&#97;&#x69;&#x6c;&#46;&#x63;&#111;&#x6d;&#93;&#40;&#41;">&#x5b;&#x68;&#x6f;&#110;&#103;&#x7a;&#104;&#97;&#x6e;&#103;&#x2e;&#46;&#x2e;&#46;&#64;&#103;&#x6d;&#97;&#x69;&#x6c;&#46;&#x63;&#111;&#x6d;&#93;&#40;&#41;</a></p>
<blockquote>
<p>异构平台从网络处理器算起已经快10年了，现在情况仍然不明朗。就我看到的，异构平台要想高效，就必须向程序员暴露非常多的硬件细节，这必然导致编程的复杂性。 曲高和寡，要想渗透到应用程序这一块，我觉得很难。</p>
<p>2010/3/24 qiaojie <a href="&#x6d;&#97;&#x69;&#108;&#116;&#111;&#x3a;&#x5b;&#113;&#x69;&#97;&#111;&#46;&#46;&#46;&#64;&#103;&#109;&#97;&#x69;&#108;&#46;&#x63;&#x6f;&#x6d;&#93;&#40;&#x29;">&#x5b;&#113;&#x69;&#97;&#111;&#46;&#46;&#46;&#64;&#103;&#109;&#97;&#x69;&#108;&#46;&#x63;&#x6f;&#x6d;&#93;&#40;&#x29;</a></p>
<blockquote>
<p>说的没错，cell已经成了先烈了。不过这不代表异构的方向不对，CUDA，OpenCL也都是异构平台，以后我们会越来越习惯异构平台的。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#x6d;&#97;&#105;&#108;&#116;&#111;&#x3a;&#91;&#104;&#111;&#x6e;&#x67;&#122;&#x68;&#97;&#x6e;&#103;&#46;&#46;&#x2e;&#46;&#x40;&#x67;&#109;&#97;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#40;&#x29;">&#91;&#104;&#111;&#x6e;&#x67;&#122;&#x68;&#97;&#x6e;&#103;&#46;&#46;&#x2e;&#46;&#x40;&#x67;&#109;&#97;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#40;&#x29;</a></p>
<p>异构平台如果编程复杂度降不下来的话很难流行起来。cell已经死了...</p>
<blockquote>
<p> 2010/3/24 qiaojie <a href="&#109;&#97;&#105;&#x6c;&#116;&#x6f;&#x3a;&#91;&#x71;&#105;&#97;&#111;&#46;&#x2e;&#x2e;&#64;&#103;&#x6d;&#97;&#x69;&#108;&#46;&#x63;&#111;&#x6d;&#x5d;&#40;&#x29;">&#91;&#x71;&#105;&#97;&#111;&#46;&#x2e;&#x2e;&#64;&#103;&#x6d;&#97;&#x69;&#108;&#46;&#x63;&#111;&#x6d;&#x5d;&#40;&#x29;</a></p>
<blockquote>
<p>不是所有的程序都需要并行化的，能用串行化解决的问题没必要并行，所以即使将来many-core系统成为主流，大部分程序员也没必要去搞并行计算。
  我觉得未来的主流应该是类似cell这样一颗全功能核心带众多协处理核心的异构系统，这样才能达到最优的 性能/核心面积比。</p>
<p>2010/3/24 Guancheng Chen <a href="&#x6d;&#97;&#x69;&#108;&#x74;&#x6f;&#58;&#x5b;&#x63;&#x68;&#101;&#110;&#103;&#x75;&#97;&#110;&#x63;&#x68;&#x2e;&#46;&#46;&#x40;&#103;&#x6d;&#x61;&#105;&#108;&#46;&#x63;&#111;&#x6d;&#93;&#40;&#41;">&#x5b;&#x63;&#x68;&#101;&#110;&#103;&#x75;&#97;&#110;&#x63;&#x68;&#x2e;&#46;&#46;&#x40;&#103;&#x6d;&#x61;&#105;&#108;&#46;&#x63;&#111;&#x6d;&#93;&#40;&#41;</a></p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>&gt;</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>Nice 大胆预测Linear speedup应该是每个程序员十年后的目标 呵呵</p>
<blockquote>
<p>On 3月23日, 上午10时43分, qiaojie <a href="&#x6d;&#97;&#105;&#x6c;&#x74;&#111;&#58;&#x5b;&#x71;&#x69;&#x61;&#111;&#46;&#x2e;&#x2e;&#64;&#103;&#109;&#97;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#41;">&#x5b;&#x71;&#x69;&#x61;&#111;&#46;&#x2e;&#x2e;&#64;&#103;&#109;&#97;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>目前正在写的是一个软件渲染器，采用了光栅化和光线跟踪混合算法，渲染算法已经完全并行化了，
在4核系统上基本可以达到线性加速比，更多核的系统暂时还没测试。kd-tree的构造暂时还没有并
行化，以后有空了再研究。</p>
<p>2010/3/23 Guancheng Chen <a href="&#x6d;&#97;&#x69;&#108;&#x74;&#111;&#x3a;&#x5b;&#99;&#x68;&#x65;&#110;&#x67;&#x75;&#x61;&#110;&#99;&#104;&#46;&#x2e;&#46;&#64;&#103;&#x6d;&#x61;&#x69;&#108;&#46;&#x63;&#x6f;&#109;&#x5d;&#40;&#x29;">&#x5b;&#99;&#x68;&#x65;&#110;&#x67;&#x75;&#x61;&#110;&#99;&#104;&#46;&#x2e;&#46;&#64;&#103;&#x6d;&#x61;&#x69;&#108;&#46;&#x63;&#x6f;&#109;&#x5d;&#40;&#x29;</a></p>
<blockquote>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？</p>
<p>On 3月23日, 上午9时15分, qiaojie <a href="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#111;&#x3a;&#x5b;&#x71;&#105;&#97;&#111;&#x2e;&#46;&#x2e;&#x40;&#103;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#40;&#x29;">&#x5b;&#x71;&#105;&#97;&#111;&#x2e;&#46;&#x2e;&#x40;&#103;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1)
=
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank
Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？</p>
</blockquote>
<p> To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> 机械唯物主义 : linjunhalida <img src="" alt=""></p>
</blockquote>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-25</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>一个谬误：刺激需求
产能=消费，产能才是主动力。技术成长是随着产能成长而起来的。
而产能多的结果就是满足了需求，造成一种需求带来技术进步的假像。
而技术和产能之间的关系又错综复杂。。
2010/3/25 qiaojie <a href="&#109;&#x61;&#x69;&#x6c;&#x74;&#x6f;&#x3a;&#x5b;&#x71;&#105;&#x61;&#46;&#x2e;&#46;&#64;&#x67;&#109;&#97;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#40;&#x29;">&#x5b;&#x71;&#105;&#x61;&#46;&#x2e;&#46;&#64;&#x67;&#109;&#97;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#40;&#x29;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>3D游戏就是一类杀手应用，由此支撑起了一个庞大的GPU市场，芯片行业的研发成本是很高的，没有一个庞大的市场是做不起来的。目前的消费者对于多核系统显然还没有强烈的需求，因为应用跟不上，i7发布快2年了还没进入主流市场，这种情况延续下去的话摩尔定律将因此失效。不过我相信杀手级应用总会出现的，这可能要硬件性能突破一个临界点，比方说目前GPU的性能再提升一个数量级的话，光线跟踪算法就可以提供流畅的接近CG的画质，倒是此类应用便会流行开来。</p>
<p>2010/3/25 Guancheng Chen <a href="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#111;&#58;&#91;&#x63;&#104;&#x65;&#110;&#x67;&#x75;&#x2e;&#x2e;&#46;&#x40;&#x67;&#109;&#x61;&#x69;&#108;&#46;&#99;&#x6f;&#x6d;&#93;&#x28;&#41;">&#91;&#x63;&#104;&#x65;&#110;&#x67;&#x75;&#x2e;&#x2e;&#46;&#x40;&#x67;&#109;&#x61;&#x69;&#108;&#46;&#99;&#x6f;&#x6d;&#93;&#x28;&#41;</a></p>
<p>杀手应用一般来说是指什么样的应用呢？比如用户群特别大的网游？还是那些专有的科学计算用的软件？
On 3月24日, 下午12时36分, qiaojie <a href="&#109;&#x61;&#x69;&#108;&#x74;&#x6f;&#x3a;&#91;&#x71;&#105;&#97;&#x6f;&#x2e;&#46;&#x2e;&#64;&#103;&#109;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#40;&#41;">&#91;&#x71;&#105;&#97;&#x6f;&#x2e;&#46;&#x2e;&#64;&#103;&#109;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>并行计算本来就是曲高和寡的东西，就跟3D渲染一样，能开发引擎的毕竟只是小部分人，大多数人在引擎的基础上做应用。关键在于是否有杀手应用，只要有大量的需求 ，自然会有人去做开发。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#109;&#97;&#105;&#x6c;&#116;&#111;&#58;&#91;&#104;&#x6f;&#x6e;&#x67;&#122;&#x68;&#x61;&#x6e;&#x67;&#46;&#x2e;&#46;&#x2e;&#x40;&#103;&#x6d;&#97;&#x69;&#108;&#x2e;&#99;&#x6f;&#109;&#93;&#x28;&#41;">&#91;&#104;&#x6f;&#x6e;&#x67;&#122;&#x68;&#x61;&#x6e;&#x67;&#46;&#x2e;&#46;&#x2e;&#x40;&#103;&#x6d;&#97;&#x69;&#108;&#x2e;&#99;&#x6f;&#109;&#93;&#x28;&#41;</a></p>
<blockquote>
<p>异构平台从网络处理器算起已经快10年了，现在情况仍然不明朗。就我看到的，异构平台要想高效，就必须向程序员暴露非常多的硬件细节，这必然导致编程的复杂性。 曲高和寡，要想渗透到应用程序这一块，我觉得很难。</p>
<p>2010/3/24 qiaojie <a href="&#x6d;&#97;&#105;&#x6c;&#x74;&#x6f;&#58;&#91;&#113;&#105;&#97;&#111;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#105;&#x6c;&#46;&#99;&#111;&#109;&#93;&#x28;&#x29;">&#91;&#113;&#105;&#97;&#111;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#105;&#x6c;&#46;&#99;&#111;&#109;&#93;&#x28;&#x29;</a></p>
<blockquote>
<p>说的没错，cell已经成了先烈了。不过这不代表异构的方向不对，CUDA，OpenCL也都是异构平台，以后我们会越来越习惯异构平台的。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#109;&#97;&#x69;&#x6c;&#x74;&#111;&#x3a;&#x5b;&#104;&#x6f;&#110;&#x67;&#122;&#104;&#97;&#110;&#103;&#46;&#x2e;&#x2e;&#46;&#64;&#103;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#x29;">&#x5b;&#104;&#x6f;&#110;&#x67;&#122;&#104;&#97;&#110;&#103;&#46;&#x2e;&#x2e;&#46;&#64;&#103;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#x29;</a></p>
<p>异构平台如果编程复杂度降不下来的话很难流行起来。cell已经死了...</p>
<blockquote>
<p> 2010/3/24 qiaojie <a href="&#x6d;&#97;&#x69;&#x6c;&#x74;&#111;&#x3a;&#91;&#113;&#x69;&#x61;&#111;&#x2e;&#46;&#x2e;&#x40;&#103;&#109;&#x61;&#105;&#108;&#46;&#99;&#111;&#109;&#x5d;&#x28;&#x29;">&#91;&#113;&#x69;&#x61;&#111;&#x2e;&#46;&#x2e;&#x40;&#103;&#109;&#x61;&#105;&#108;&#46;&#99;&#111;&#109;&#x5d;&#x28;&#x29;</a></p>
<blockquote>
<p>不是所有的程序都需要并行化的，能用串行化解决的问题没必要并行，所以即使将来many-core系统成为主流，大部分程序员也没必要去搞并行计算。
  我觉得未来的主流应该是类似cell这样一颗全功能核心带众多协处理核心的异构系统，这样才能达到最优的 性能/核心面积比。</p>
<p>2010/3/24 Guancheng Chen <a href="&#109;&#97;&#105;&#x6c;&#x74;&#111;&#x3a;&#x5b;&#x63;&#104;&#101;&#x6e;&#x67;&#x75;&#x61;&#x6e;&#99;&#x68;&#46;&#x2e;&#46;&#64;&#x67;&#x6d;&#x61;&#x69;&#108;&#x2e;&#99;&#111;&#109;&#x5d;&#40;&#x29;">&#x5b;&#x63;&#104;&#101;&#x6e;&#x67;&#x75;&#x61;&#x6e;&#99;&#x68;&#46;&#x2e;&#46;&#64;&#x67;&#x6d;&#x61;&#x69;&#108;&#x2e;&#99;&#111;&#109;&#x5d;&#40;&#x29;</a></p>
<p>Nice 大胆预测Linear speedup应该是每个程序员十年后的目标 呵呵</p>
<blockquote>
<p>On 3月23日, 上午10时43分, qiaojie <a href="&#x6d;&#x61;&#105;&#108;&#116;&#x6f;&#58;&#91;&#113;&#x69;&#x61;&#x6f;&#46;&#x2e;&#46;&#64;&#103;&#109;&#97;&#105;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#93;&#x28;&#x29;">&#91;&#113;&#x69;&#x61;&#x6f;&#46;&#x2e;&#46;&#64;&#103;&#109;&#97;&#105;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>目前正在写的是一个软件渲染器，采用了光栅化和光线跟踪混合算法，渲染算法已经完全并行化了，
在4核系统上基本可以达到线性加速比，更多核的系统暂时还没测试。kd-tree的构造暂时还没有并
行化，以后有空了再研究。</p>
<p>2010/3/23 Guancheng Chen <a href="&#109;&#97;&#x69;&#108;&#116;&#x6f;&#58;&#91;&#x63;&#x68;&#101;&#x6e;&#x67;&#x75;&#x61;&#x6e;&#99;&#104;&#x2e;&#x2e;&#46;&#64;&#103;&#109;&#x61;&#105;&#108;&#x2e;&#x63;&#111;&#x6d;&#93;&#40;&#x29;">&#91;&#x63;&#x68;&#101;&#x6e;&#x67;&#x75;&#x61;&#x6e;&#99;&#104;&#x2e;&#x2e;&#46;&#64;&#103;&#109;&#x61;&#105;&#108;&#x2e;&#x63;&#111;&#x6d;&#93;&#40;&#x29;</a></p>
<blockquote>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？</p>
<p>On 3月23日, 上午9时15分, qiaojie <a href="&#109;&#x61;&#105;&#x6c;&#116;&#x6f;&#x3a;&#91;&#x71;&#x69;&#97;&#x6f;&#x2e;&#46;&#46;&#64;&#103;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#x28;&#41;">&#91;&#x71;&#x69;&#97;&#x6f;&#x2e;&#46;&#46;&#64;&#103;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1)
=
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank
Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？</p>
</blockquote>
<p> To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a></p>
</blockquote>
</blockquote>
<p><img src="" alt=""> qiaojie <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-25</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>如果产能=消费的话就没有产能过剩这一说了。</p>
<p>2010/3/25 机械唯物主义 : linjunhalida <a href="&#x6d;&#x61;&#105;&#x6c;&#x74;&#x6f;&#x3a;&#x5b;&#x6c;&#105;&#110;&#106;&#x75;&#x6e;&#x2e;&#x2e;&#46;&#x40;&#103;&#109;&#x61;&#105;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#93;&#40;&#x29;">&#x5b;&#x6c;&#105;&#110;&#106;&#x75;&#x6e;&#x2e;&#x2e;&#46;&#x40;&#103;&#109;&#x61;&#105;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#93;&#40;&#x29;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>一个谬误：刺激需求
产能=消费，产能才是主动力。技术成长是随着产能成长而起来的。
而产能多的结果就是满足了需求，造成一种需求带来技术进步的假像。
而技术和产能之间的关系又错综复杂。。
2010/3/25 qiaojie <a href="&#109;&#97;&#105;&#x6c;&#x74;&#x6f;&#58;&#x5b;&#113;&#x69;&#x61;&#x2e;&#x2e;&#46;&#x40;&#x67;&#109;&#97;&#105;&#108;&#46;&#x63;&#111;&#109;&#x5d;&#x28;&#x29;">&#x5b;&#113;&#x69;&#x61;&#x2e;&#x2e;&#46;&#x40;&#x67;&#109;&#97;&#105;&#108;&#46;&#x63;&#111;&#109;&#x5d;&#x28;&#x29;</a></p>
<p>3D游戏就是一类杀手应用，由此支撑起了一个庞大的GPU市场，芯片行业的研发成本是很高的，没有一个庞大的市场是做不起来的。目前的消费者对于多核系统显然还没有强烈的需求，因为应用跟不上，i7发布快2年了还没进入主流市场，这种情况延续下去的话摩尔定律将因此失效。不过我相信杀手级应用总会出现的，这可能要硬件性能突破一个临界点，比方说目前GPU的性能再提升一个数量级的话，光线跟踪算法就可以提供流畅的接近CG的画质，倒是此类应用便会流行开来。</p>
<p>2010/3/25 Guancheng Chen <a href="&#x6d;&#97;&#105;&#108;&#x74;&#111;&#x3a;&#x5b;&#99;&#104;&#x65;&#x6e;&#x67;&#x75;&#46;&#46;&#46;&#64;&#x67;&#109;&#x61;&#105;&#108;&#46;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#x29;">&#x5b;&#99;&#104;&#x65;&#x6e;&#x67;&#x75;&#46;&#46;&#46;&#64;&#x67;&#109;&#x61;&#105;&#108;&#46;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#x29;</a></p>
<p>杀手应用一般来说是指什么样的应用呢？比如用户群特别大的网游？还是那些专有的科学计算用的软件？
On 3月24日, 下午12时36分, qiaojie <a href="&#x6d;&#x61;&#105;&#108;&#x74;&#x6f;&#58;&#x5b;&#x71;&#105;&#97;&#x6f;&#46;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#x61;&#x69;&#108;&#46;&#x63;&#111;&#109;&#93;&#x28;&#41;">&#x5b;&#x71;&#105;&#97;&#x6f;&#46;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#x61;&#x69;&#108;&#46;&#x63;&#111;&#109;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>并行计算本来就是曲高和寡的东西，就跟3D渲染一样，能开发引擎的毕竟只是小部分人，大多数人在引擎的基础上做应用。关键在于是否有杀手应用，只要有大量的需求 ，自然会有人去做开发。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#x6d;&#97;&#105;&#x6c;&#x74;&#x6f;&#x3a;&#91;&#104;&#x6f;&#x6e;&#x67;&#x7a;&#104;&#97;&#x6e;&#x67;&#x2e;&#x2e;&#46;&#46;&#64;&#103;&#109;&#97;&#x69;&#108;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#x28;&#x29;">&#91;&#104;&#x6f;&#x6e;&#x67;&#x7a;&#104;&#97;&#x6e;&#x67;&#x2e;&#x2e;&#46;&#46;&#64;&#103;&#109;&#97;&#x69;&#108;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#x28;&#x29;</a></p>
<blockquote>
<p>异构平台从网络处理器算起已经快10年了，现在情况仍然不明朗。就我看到的，异构平台要想高效，就必须向程序员暴露非常多的硬件细节，这必然导致编程的复杂性。 曲高和寡，要想渗透到应用程序这一块，我觉得很难。</p>
<p>2010/3/24 qiaojie <a href="&#x6d;&#97;&#105;&#108;&#116;&#111;&#58;&#91;&#x71;&#x69;&#97;&#111;&#x2e;&#x2e;&#46;&#64;&#x67;&#x6d;&#x61;&#105;&#108;&#x2e;&#99;&#111;&#x6d;&#x5d;&#x28;&#41;">&#91;&#x71;&#x69;&#97;&#111;&#x2e;&#x2e;&#46;&#64;&#x67;&#x6d;&#x61;&#105;&#108;&#x2e;&#99;&#111;&#x6d;&#x5d;&#x28;&#41;</a></p>
<blockquote>
<p>说的没错，cell已经成了先烈了。不过这不代表异构的方向不对，CUDA，OpenCL也都是异构平台，以后我们会越来越习惯异构平台的。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#x6d;&#x61;&#105;&#x6c;&#x74;&#x6f;&#x3a;&#91;&#x68;&#x6f;&#110;&#103;&#122;&#104;&#97;&#x6e;&#x67;&#46;&#x2e;&#46;&#46;&#x40;&#103;&#x6d;&#x61;&#x69;&#108;&#46;&#99;&#111;&#109;&#x5d;&#40;&#41;">&#91;&#x68;&#x6f;&#110;&#103;&#122;&#104;&#97;&#x6e;&#x67;&#46;&#x2e;&#46;&#46;&#x40;&#103;&#x6d;&#x61;&#x69;&#108;&#46;&#99;&#111;&#109;&#x5d;&#40;&#41;</a></p>
<p>异构平台如果编程复杂度降不下来的话很难流行起来。cell已经死了...</p>
<blockquote>
<p> 2010/3/24 qiaojie <a href="&#109;&#97;&#105;&#108;&#116;&#x6f;&#58;&#91;&#113;&#x69;&#97;&#111;&#x2e;&#x2e;&#x2e;&#64;&#103;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#93;&#x28;&#x29;">&#91;&#113;&#x69;&#97;&#111;&#x2e;&#x2e;&#x2e;&#64;&#103;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#93;&#x28;&#x29;</a></p>
<blockquote>
<p>不是所有的程序都需要并行化的，能用串行化解决的问题没必要并行，所以即使将来many-core系统成为主流，大部分程序员也没必要去搞并行计算。
  我觉得未来的主流应该是类似cell这样一颗全功能核心带众多协处理核心的异构系统，这样才能达到最优的 性能/核心面积比。</p>
<p>2010/3/24 Guancheng Chen <a href="&#109;&#97;&#x69;&#108;&#x74;&#x6f;&#x3a;&#91;&#99;&#x68;&#101;&#x6e;&#x67;&#117;&#x61;&#x6e;&#x63;&#104;&#x2e;&#46;&#46;&#64;&#103;&#x6d;&#x61;&#x69;&#108;&#46;&#99;&#x6f;&#x6d;&#93;&#x28;&#41;">&#91;&#99;&#x68;&#101;&#x6e;&#x67;&#117;&#x61;&#x6e;&#x63;&#104;&#x2e;&#46;&#46;&#64;&#103;&#x6d;&#x61;&#x69;&#108;&#46;&#99;&#x6f;&#x6d;&#93;&#x28;&#41;</a></p>
<p>Nice 大胆预测Linear speedup应该是每个程序员十年后的目标 呵呵</p>
<blockquote>
<p>On 3月23日, 上午10时43分, qiaojie <a href="&#x6d;&#97;&#x69;&#x6c;&#x74;&#111;&#58;&#x5b;&#113;&#x69;&#97;&#x6f;&#x2e;&#46;&#46;&#64;&#x67;&#109;&#97;&#105;&#108;&#x2e;&#x63;&#111;&#x6d;&#93;&#x28;&#x29;">&#x5b;&#113;&#x69;&#97;&#x6f;&#x2e;&#46;&#46;&#64;&#x67;&#109;&#97;&#105;&#108;&#x2e;&#x63;&#111;&#x6d;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>目前正在写的是一个软件渲染器，采用了光栅化和光线跟踪混合算法，渲染算法已经完全并行化了，
在4核系统上基本可以达到线性加速比，更多核的系统暂时还没测试。kd-tree的构造暂时还没有并
行化，以后有空了再研究。</p>
<p>2010/3/23 Guancheng Chen <a href="&#109;&#97;&#x69;&#108;&#x74;&#111;&#x3a;&#x5b;&#99;&#x68;&#x65;&#x6e;&#x67;&#x75;&#97;&#x6e;&#x63;&#104;&#46;&#46;&#x2e;&#x40;&#x67;&#x6d;&#97;&#105;&#x6c;&#46;&#x63;&#x6f;&#109;&#93;&#x28;&#x29;">&#x5b;&#99;&#x68;&#x65;&#x6e;&#x67;&#x75;&#97;&#x6e;&#x63;&#104;&#46;&#46;&#x2e;&#x40;&#x67;&#x6d;&#97;&#105;&#x6c;&#46;&#x63;&#x6f;&#109;&#93;&#x28;&#x29;</a></p>
<blockquote>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？</p>
<p>On 3月23日, 上午9时15分, qiaojie <a href="&#109;&#97;&#105;&#108;&#x74;&#x6f;&#x3a;&#x5b;&#113;&#x69;&#97;&#x6f;&#46;&#46;&#x2e;&#64;&#103;&#109;&#x61;&#x69;&#108;&#x2e;&#99;&#111;&#109;&#93;&#x28;&#41;">&#x5b;&#113;&#x69;&#97;&#x6f;&#46;&#46;&#x2e;&#64;&#103;&#109;&#x61;&#x69;&#108;&#x2e;&#99;&#111;&#109;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1)
=
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank
Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？</p>
</blockquote>
<p> To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> 机械唯物主义 : linjunhalida <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-25</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>产能过剩的说法本来就不对。
产出的东西没有价值，这样的活动就不能说是生产。
比如我这个程序员，花了1周写了一个垃圾程序，然后被开除了。
然后1个月闲着，这是我产能过剩吗？
而闲着的原因是政府给我失业金，我就不需要工作闲起来了。。。
2010/3/25 qiaojie <a href="&#109;&#x61;&#x69;&#108;&#x74;&#111;&#58;&#91;&#113;&#105;&#x61;&#46;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#x61;&#105;&#x6c;&#46;&#x63;&#111;&#109;&#x5d;&#40;&#41;">&#91;&#113;&#105;&#x61;&#46;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#x61;&#105;&#x6c;&#46;&#x63;&#111;&#109;&#x5d;&#40;&#41;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>如果产能=消费的话就没有产能过剩这一说了。</p>
<p>2010/3/25 机械唯物主义 : linjunhalida <a href="&#109;&#x61;&#x69;&#108;&#x74;&#x6f;&#x3a;&#91;&#x6c;&#x69;&#x6e;&#106;&#x75;&#110;&#46;&#x2e;&#46;&#64;&#103;&#x6d;&#97;&#x69;&#x6c;&#46;&#x63;&#111;&#109;&#93;&#40;&#41;">&#91;&#x6c;&#x69;&#x6e;&#106;&#x75;&#110;&#46;&#x2e;&#46;&#64;&#103;&#x6d;&#97;&#x69;&#x6c;&#46;&#x63;&#111;&#109;&#93;&#40;&#41;</a></p>
<p>一个谬误：刺激需求
产能=消费，产能才是主动力。技术成长是随着产能成长而起来的。
而产能多的结果就是满足了需求，造成一种需求带来技术进步的假像。
而技术和产能之间的关系又错综复杂。。
2010/3/25 qiaojie <a href="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#x6f;&#x3a;&#91;&#x71;&#x69;&#x61;&#x2e;&#46;&#x2e;&#x40;&#103;&#109;&#97;&#105;&#x6c;&#x2e;&#99;&#111;&#x6d;&#93;&#40;&#41;">&#91;&#x71;&#x69;&#x61;&#x2e;&#46;&#x2e;&#x40;&#103;&#109;&#97;&#105;&#x6c;&#x2e;&#99;&#111;&#x6d;&#93;&#40;&#41;</a></p>
<p>3D游戏就是一类杀手应用，由此支撑起了一个庞大的GPU市场，芯片行业的研发成本是很高的，没有一个庞大的市场是做不起来的。目前的消费者对于多核系统显然还没有强烈的需求，因为应用跟不上，i7发布快2年了还没进入主流市场，这种情况延续下去的话摩尔定律将因此失效。不过我相信杀手级应用总会出现的，这可能要硬件性能突破一个临界点，比方说目前GPU的性能再提升一个数量级的话，光线跟踪算法就可以提供流畅的接近CG的画质，倒是此类应用便会流行开来。</p>
<p>2010/3/25 Guancheng Chen <a href="&#109;&#97;&#105;&#x6c;&#x74;&#111;&#58;&#x5b;&#99;&#104;&#x65;&#110;&#x67;&#117;&#46;&#46;&#46;&#x40;&#103;&#109;&#x61;&#x69;&#x6c;&#x2e;&#99;&#111;&#109;&#x5d;&#40;&#x29;">&#x5b;&#99;&#104;&#x65;&#110;&#x67;&#117;&#46;&#46;&#46;&#x40;&#103;&#109;&#x61;&#x69;&#x6c;&#x2e;&#99;&#111;&#109;&#x5d;&#40;&#x29;</a></p>
<p>杀手应用一般来说是指什么样的应用呢？比如用户群特别大的网游？还是那些专有的科学计算用的软件？
On 3月24日, 下午12时36分, qiaojie <a href="&#109;&#x61;&#105;&#x6c;&#x74;&#x6f;&#x3a;&#91;&#113;&#105;&#x61;&#x6f;&#46;&#x2e;&#46;&#64;&#x67;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#93;&#x28;&#41;">&#91;&#113;&#105;&#x61;&#x6f;&#46;&#x2e;&#46;&#64;&#x67;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>并行计算本来就是曲高和寡的东西，就跟3D渲染一样，能开发引擎的毕竟只是小部分人，大多数人在引擎的基础上做应用。关键在于是否有杀手应用，只要有大量的需求 ，自然会有人去做开发。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#x6d;&#97;&#x69;&#x6c;&#116;&#111;&#58;&#91;&#x68;&#111;&#x6e;&#103;&#122;&#x68;&#97;&#110;&#x67;&#46;&#46;&#46;&#x2e;&#x40;&#103;&#x6d;&#97;&#105;&#x6c;&#x2e;&#99;&#111;&#x6d;&#93;&#40;&#41;">&#91;&#x68;&#111;&#x6e;&#103;&#122;&#x68;&#97;&#110;&#x67;&#46;&#46;&#46;&#x2e;&#x40;&#103;&#x6d;&#97;&#105;&#x6c;&#x2e;&#99;&#111;&#x6d;&#93;&#40;&#41;</a></p>
<blockquote>
<p>异构平台从网络处理器算起已经快10年了，现在情况仍然不明朗。就我看到的，异构平台要想高效，就必须向程序员暴露非常多的硬件细节，这必然导致编程的复杂性。 曲高和寡，要想渗透到应用程序这一块，我觉得很难。</p>
<p>2010/3/24 qiaojie <a href="&#x6d;&#97;&#105;&#x6c;&#x74;&#x6f;&#58;&#x5b;&#113;&#x69;&#97;&#x6f;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#97;&#x69;&#x6c;&#46;&#99;&#111;&#x6d;&#x5d;&#x28;&#41;">&#x5b;&#113;&#x69;&#97;&#x6f;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#97;&#x69;&#x6c;&#46;&#99;&#111;&#x6d;&#x5d;&#x28;&#41;</a></p>
<blockquote>
<p>说的没错，cell已经成了先烈了。不过这不代表异构的方向不对，CUDA，OpenCL也都是异构平台，以后我们会越来越习惯异构平台的。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#109;&#97;&#105;&#x6c;&#x74;&#x6f;&#58;&#91;&#x68;&#x6f;&#110;&#103;&#x7a;&#x68;&#x61;&#110;&#103;&#46;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#109;&#97;&#x69;&#108;&#x2e;&#99;&#111;&#109;&#93;&#x28;&#41;">&#91;&#x68;&#x6f;&#110;&#103;&#x7a;&#x68;&#x61;&#110;&#103;&#46;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#109;&#97;&#x69;&#108;&#x2e;&#99;&#111;&#109;&#93;&#x28;&#41;</a></p>
<p>异构平台如果编程复杂度降不下来的话很难流行起来。cell已经死了...</p>
<blockquote>
<p> 2010/3/24 qiaojie <a href="&#x6d;&#97;&#105;&#108;&#116;&#111;&#x3a;&#91;&#x71;&#105;&#x61;&#111;&#x2e;&#46;&#46;&#64;&#x67;&#x6d;&#x61;&#105;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#x28;&#x29;">&#91;&#x71;&#105;&#x61;&#111;&#x2e;&#46;&#46;&#64;&#x67;&#x6d;&#x61;&#105;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#x28;&#x29;</a></p>
<blockquote>
<p>不是所有的程序都需要并行化的，能用串行化解决的问题没必要并行，所以即使将来many-core系统成为主流，大部分程序员也没必要去搞并行计算。
  我觉得未来的主流应该是类似cell这样一颗全功能核心带众多协处理核心的异构系统，这样才能达到最优的 性能/核心面积比。</p>
<p>2010/3/24 Guancheng Chen <a href="&#109;&#97;&#x69;&#108;&#x74;&#111;&#58;&#x5b;&#99;&#x68;&#x65;&#x6e;&#103;&#117;&#x61;&#110;&#x63;&#x68;&#46;&#46;&#46;&#64;&#x67;&#109;&#x61;&#105;&#108;&#46;&#x63;&#x6f;&#109;&#x5d;&#40;&#41;">&#x5b;&#99;&#x68;&#x65;&#x6e;&#103;&#117;&#x61;&#110;&#x63;&#x68;&#46;&#46;&#46;&#64;&#x67;&#109;&#x61;&#105;&#108;&#46;&#x63;&#x6f;&#109;&#x5d;&#40;&#41;</a></p>
<p>Nice 大胆预测Linear speedup应该是每个程序员十年后的目标 呵呵</p>
<blockquote>
<p>On 3月23日, 上午10时43分, qiaojie <a href="&#x6d;&#x61;&#x69;&#108;&#x74;&#111;&#58;&#91;&#x71;&#105;&#97;&#x6f;&#46;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#97;&#x69;&#x6c;&#46;&#99;&#x6f;&#109;&#x5d;&#x28;&#x29;">&#91;&#x71;&#105;&#97;&#x6f;&#46;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#97;&#x69;&#x6c;&#46;&#99;&#x6f;&#109;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>目前正在写的是一个软件渲染器，采用了光栅化和光线跟踪混合算法，渲染算法已经完全并行化了，
在4核系统上基本可以达到线性加速比，更多核的系统暂时还没测试。kd-tree的构造暂时还没有并
行化，以后有空了再研究。</p>
<p>2010/3/23 Guancheng Chen <a href="&#x6d;&#97;&#x69;&#108;&#x74;&#111;&#58;&#91;&#x63;&#104;&#x65;&#x6e;&#103;&#117;&#97;&#x6e;&#x63;&#104;&#46;&#46;&#x2e;&#64;&#103;&#x6d;&#x61;&#x69;&#108;&#x2e;&#99;&#111;&#x6d;&#93;&#x28;&#41;">&#91;&#x63;&#104;&#x65;&#x6e;&#103;&#117;&#97;&#x6e;&#x63;&#104;&#46;&#46;&#x2e;&#64;&#103;&#x6d;&#x61;&#x69;&#108;&#x2e;&#99;&#111;&#x6d;&#93;&#x28;&#41;</a></p>
<blockquote>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？</p>
<p>On 3月23日, 上午9时15分, qiaojie <a href="&#109;&#97;&#x69;&#x6c;&#116;&#x6f;&#x3a;&#91;&#x71;&#105;&#x61;&#111;&#46;&#x2e;&#46;&#x40;&#103;&#x6d;&#97;&#x69;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#x29;">&#91;&#x71;&#105;&#x61;&#111;&#46;&#x2e;&#46;&#x40;&#103;&#x6d;&#97;&#x69;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1)
=
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank
Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？</p>
</blockquote>
<p> To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a></p>
<p><img src="" alt=""> 机械唯物主义 : linjunhalida <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-25</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>扯远了。我觉得并行和串行应该是信息处理本质上的2种方式，
在不同的场景下，可以采用不同的方式进行。
重要的是能够“又好又快”地实现需求，以及根据场景，把一个需求进行实现方式的伸缩。
不过看起来这样的工作还是要靠程序员来实现？而体系架构设计者要根据对应问题的本质特性来设计架构？
2010/3/25 机械唯物主义 : linjunhalida <a href="&#109;&#97;&#x69;&#108;&#x74;&#x6f;&#58;&#x5b;&#108;&#105;&#110;&#x6a;&#x75;&#x6e;&#46;&#x2e;&#46;&#64;&#103;&#109;&#97;&#x69;&#108;&#x2e;&#99;&#x6f;&#109;&#x5d;&#x28;&#x29;">&#x5b;&#108;&#105;&#110;&#x6a;&#x75;&#x6e;&#46;&#x2e;&#46;&#64;&#103;&#109;&#97;&#x69;&#108;&#x2e;&#99;&#x6f;&#109;&#x5d;&#x28;&#x29;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>产能过剩的说法本来就不对。
产出的东西没有价值，这样的活动就不能说是生产。
比如我这个程序员，花了1周写了一个垃圾程序，然后被开除了。
然后1个月闲着，这是我产能过剩吗？
而闲着的原因是政府给我失业金，我就不需要工作闲起来了。。。</p>
<p>2010/3/25 qiaojie <a href="&#109;&#x61;&#105;&#108;&#x74;&#x6f;&#x3a;&#91;&#113;&#105;&#97;&#46;&#46;&#46;&#64;&#x67;&#109;&#97;&#x69;&#108;&#x2e;&#x63;&#111;&#109;&#93;&#x28;&#41;">&#91;&#113;&#105;&#97;&#46;&#46;&#46;&#64;&#x67;&#109;&#97;&#x69;&#108;&#x2e;&#x63;&#111;&#109;&#93;&#x28;&#41;</a>
如果产能=消费的话就没有产能过剩这一说了。</p>
<p>2010/3/25 机械唯物主义 : linjunhalida <a href="&#x6d;&#x61;&#105;&#x6c;&#116;&#x6f;&#58;&#x5b;&#108;&#x69;&#x6e;&#x6a;&#117;&#110;&#46;&#46;&#46;&#64;&#103;&#x6d;&#97;&#x69;&#108;&#46;&#99;&#x6f;&#109;&#93;&#x28;&#x29;">&#x5b;&#108;&#x69;&#x6e;&#x6a;&#117;&#110;&#46;&#46;&#46;&#64;&#103;&#x6d;&#97;&#x69;&#108;&#46;&#99;&#x6f;&#109;&#93;&#x28;&#x29;</a></p>
<p>一个谬误：刺激需求
产能=消费，产能才是主动力。技术成长是随着产能成长而起来的。
而产能多的结果就是满足了需求，造成一种需求带来技术进步的假像。
而技术和产能之间的关系又错综复杂。。
2010/3/25 qiaojie <a href="&#x6d;&#x61;&#105;&#108;&#116;&#x6f;&#58;&#91;&#x71;&#105;&#97;&#46;&#46;&#46;&#x40;&#103;&#109;&#97;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#40;&#41;">&#91;&#x71;&#105;&#97;&#46;&#46;&#46;&#x40;&#103;&#109;&#97;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#40;&#41;</a></p>
<p>3D游戏就是一类杀手应用，由此支撑起了一个庞大的GPU市场，芯片行业的研发成本是很高的，没有一个庞大的市场是做不起来的。目前的消费者对于多核系统显然还没有强烈的需求，因为应用跟不上，i7发布快2年了还没进入主流市场，这种情况延续下去的话摩尔定律将因此失效。不过我相信杀手级应用总会出现的，这可能要硬件性能突破一个临界点，比方说目前GPU的性能再提升一个数量级的话，光线跟踪算法就可以提供流畅的接近CG的画质，倒是此类应用便会流行开来。</p>
<p>2010/3/25 Guancheng Chen <a href="&#x6d;&#97;&#105;&#108;&#116;&#111;&#x3a;&#91;&#99;&#x68;&#101;&#x6e;&#x67;&#x75;&#x2e;&#46;&#46;&#64;&#103;&#x6d;&#x61;&#105;&#x6c;&#46;&#99;&#111;&#x6d;&#x5d;&#x28;&#x29;">&#91;&#99;&#x68;&#101;&#x6e;&#x67;&#x75;&#x2e;&#46;&#46;&#64;&#103;&#x6d;&#x61;&#105;&#x6c;&#46;&#99;&#111;&#x6d;&#x5d;&#x28;&#x29;</a></p>
<p>杀手应用一般来说是指什么样的应用呢？比如用户群特别大的网游？还是那些专有的科学计算用的软件？
On 3月24日, 下午12时36分, qiaojie <a href="&#x6d;&#97;&#105;&#x6c;&#x74;&#x6f;&#x3a;&#x5b;&#x71;&#x69;&#97;&#111;&#46;&#x2e;&#46;&#x40;&#103;&#109;&#97;&#x69;&#x6c;&#x2e;&#99;&#111;&#x6d;&#x5d;&#x28;&#41;">&#x5b;&#x71;&#x69;&#97;&#111;&#46;&#x2e;&#46;&#x40;&#103;&#109;&#97;&#x69;&#x6c;&#x2e;&#99;&#111;&#x6d;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>并行计算本来就是曲高和寡的东西，就跟3D渲染一样，能开发引擎的毕竟只是小部分人，大多数人在引擎的基础上做应用。关键在于是否有杀手应用，只要有大量的需求 ，自然会有人去做开发。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#109;&#97;&#105;&#108;&#x74;&#x6f;&#58;&#x5b;&#x68;&#x6f;&#x6e;&#103;&#x7a;&#104;&#x61;&#x6e;&#x67;&#46;&#x2e;&#46;&#x2e;&#64;&#103;&#109;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#111;&#109;&#x5d;&#40;&#x29;">&#x5b;&#x68;&#x6f;&#x6e;&#103;&#x7a;&#104;&#x61;&#x6e;&#x67;&#46;&#x2e;&#46;&#x2e;&#64;&#103;&#109;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#111;&#109;&#x5d;&#40;&#x29;</a></p>
<blockquote>
<p>异构平台从网络处理器算起已经快10年了，现在情况仍然不明朗。就我看到的，异构平台要想高效，就必须向程序员暴露非常多的硬件细节，这必然导致编程的复杂性。 曲高和寡，要想渗透到应用程序这一块，我觉得很难。</p>
<p>2010/3/24 qiaojie <a href="&#109;&#x61;&#105;&#108;&#116;&#111;&#x3a;&#91;&#x71;&#x69;&#x61;&#111;&#46;&#46;&#46;&#x40;&#103;&#109;&#97;&#x69;&#108;&#x2e;&#x63;&#111;&#109;&#93;&#x28;&#x29;">&#91;&#x71;&#x69;&#x61;&#111;&#46;&#46;&#46;&#x40;&#103;&#109;&#97;&#x69;&#108;&#x2e;&#x63;&#111;&#109;&#93;&#x28;&#x29;</a></p>
<blockquote>
<p>说的没错，cell已经成了先烈了。不过这不代表异构的方向不对，CUDA，OpenCL也都是异构平台，以后我们会越来越习惯异构平台的。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#x6d;&#x61;&#105;&#108;&#x74;&#x6f;&#58;&#91;&#104;&#x6f;&#110;&#x67;&#122;&#104;&#97;&#110;&#x67;&#46;&#x2e;&#46;&#x2e;&#64;&#x67;&#x6d;&#x61;&#x69;&#108;&#46;&#x63;&#111;&#x6d;&#x5d;&#x28;&#41;">&#91;&#104;&#x6f;&#110;&#x67;&#122;&#104;&#97;&#110;&#x67;&#46;&#x2e;&#46;&#x2e;&#64;&#x67;&#x6d;&#x61;&#x69;&#108;&#46;&#x63;&#111;&#x6d;&#x5d;&#x28;&#41;</a></p>
<p>异构平台如果编程复杂度降不下来的话很难流行起来。cell已经死了...</p>
<blockquote>
<p> 2010/3/24 qiaojie <a href="&#109;&#x61;&#x69;&#x6c;&#116;&#x6f;&#x3a;&#x5b;&#x71;&#x69;&#x61;&#111;&#46;&#x2e;&#x2e;&#64;&#x67;&#109;&#x61;&#105;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#93;&#40;&#x29;">&#x5b;&#x71;&#x69;&#x61;&#111;&#46;&#x2e;&#x2e;&#64;&#x67;&#109;&#x61;&#105;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#93;&#40;&#x29;</a></p>
<blockquote>
<p>不是所有的程序都需要并行化的，能用串行化解决的问题没必要并行，所以即使将来many-core系统成为主流，大部分程序员也没必要去搞并行计算。
  我觉得未来的主流应该是类似cell这样一颗全功能核心带众多协处理核心的异构系统，这样才能达到最优的 性能/核心面积比。</p>
<p>2010/3/24 Guancheng Chen <a href="&#x6d;&#x61;&#x69;&#108;&#x74;&#111;&#58;&#91;&#99;&#x68;&#101;&#110;&#x67;&#x75;&#97;&#x6e;&#99;&#x68;&#46;&#x2e;&#46;&#64;&#103;&#109;&#x61;&#105;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#93;&#40;&#x29;">&#91;&#99;&#x68;&#101;&#110;&#x67;&#x75;&#97;&#x6e;&#99;&#x68;&#46;&#x2e;&#46;&#64;&#103;&#109;&#x61;&#105;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#93;&#40;&#x29;</a></p>
<p>Nice 大胆预测Linear speedup应该是每个程序员十年后的目标 呵呵</p>
<blockquote>
<p>On 3月23日, 上午10时43分, qiaojie <a href="&#109;&#97;&#x69;&#108;&#x74;&#x6f;&#58;&#x5b;&#113;&#105;&#x61;&#x6f;&#46;&#46;&#x2e;&#64;&#x67;&#109;&#97;&#x69;&#108;&#x2e;&#99;&#x6f;&#x6d;&#93;&#40;&#x29;">&#x5b;&#113;&#105;&#x61;&#x6f;&#46;&#46;&#x2e;&#64;&#x67;&#109;&#97;&#x69;&#108;&#x2e;&#99;&#x6f;&#x6d;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>目前正在写的是一个软件渲染器，采用了光栅化和光线跟踪混合算法，渲染算法已经完全并行化了，
在4核系统上基本可以达到线性加速比，更多核的系统暂时还没测试。kd-tree的构造暂时还没有并
行化，以后有空了再研究。</p>
<p>2010/3/23 Guancheng Chen <a href="&#109;&#x61;&#x69;&#108;&#x74;&#x6f;&#58;&#91;&#99;&#104;&#x65;&#x6e;&#103;&#x75;&#x61;&#x6e;&#99;&#104;&#x2e;&#x2e;&#46;&#64;&#103;&#x6d;&#x61;&#105;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#93;&#x28;&#41;">&#91;&#99;&#104;&#x65;&#x6e;&#103;&#x75;&#x61;&#x6e;&#99;&#104;&#x2e;&#x2e;&#46;&#64;&#103;&#x6d;&#x61;&#105;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#93;&#x28;&#41;</a></p>
<blockquote>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？</p>
<p>On 3月23日, 上午9时15分, qiaojie <a href="&#109;&#x61;&#105;&#x6c;&#x74;&#111;&#58;&#x5b;&#x71;&#x69;&#x61;&#111;&#46;&#x2e;&#46;&#x40;&#103;&#x6d;&#97;&#x69;&#108;&#46;&#x63;&#x6f;&#109;&#x5d;&#40;&#x29;">&#x5b;&#x71;&#x69;&#x61;&#111;&#46;&#x2e;&#46;&#x40;&#103;&#x6d;&#97;&#x69;&#108;&#46;&#x63;&#x6f;&#109;&#x5d;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1)
=
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank
Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？</p>
</blockquote>
<p> To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> qiaojie <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-25</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>什么叫产能过剩？假设全世界每年消费10000亿斤粮食，结果今年收成好，生产了15000亿斤，</p>
<p>那多出来的5000亿斤无法被市场消化掉，就是产能过剩。那5000亿斤没价值，是垃圾？生产那
5000亿斤的农民是闲的蛋疼没事干？靠政府失业金养？</p>
<p>2010/3/25 机械唯物主义 : linjunhalida <a href="&#109;&#x61;&#x69;&#108;&#x74;&#111;&#58;&#x5b;&#x6c;&#x69;&#110;&#106;&#x75;&#x6e;&#x2e;&#46;&#46;&#x40;&#103;&#x6d;&#97;&#x69;&#108;&#x2e;&#x63;&#x6f;&#109;&#93;&#x28;&#x29;">&#x5b;&#x6c;&#x69;&#110;&#106;&#x75;&#x6e;&#x2e;&#46;&#46;&#x40;&#103;&#x6d;&#97;&#x69;&#108;&#x2e;&#x63;&#x6f;&#109;&#93;&#x28;&#x29;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>产能过剩的说法本来就不对。
产出的东西没有价值，这样的活动就不能说是生产。
比如我这个程序员，花了1周写了一个垃圾程序，然后被开除了。
然后1个月闲着，这是我产能过剩吗？
而闲着的原因是政府给我失业金，我就不需要工作闲起来了。。。</p>
<p>2010/3/25 qiaojie <a href="&#x6d;&#97;&#x69;&#x6c;&#x74;&#x6f;&#58;&#91;&#113;&#x69;&#x61;&#46;&#x2e;&#46;&#64;&#x67;&#109;&#97;&#105;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#93;&#x28;&#x29;">&#91;&#113;&#x69;&#x61;&#46;&#x2e;&#46;&#64;&#x67;&#109;&#97;&#105;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#93;&#x28;&#x29;</a>
如果产能=消费的话就没有产能过剩这一说了。</p>
<p>2010/3/25 机械唯物主义 : linjunhalida <a href="&#109;&#97;&#x69;&#108;&#116;&#111;&#58;&#x5b;&#x6c;&#x69;&#110;&#x6a;&#x75;&#110;&#46;&#46;&#46;&#x40;&#x67;&#x6d;&#97;&#105;&#108;&#46;&#99;&#x6f;&#109;&#x5d;&#40;&#x29;">&#x5b;&#x6c;&#x69;&#110;&#x6a;&#x75;&#110;&#46;&#46;&#46;&#x40;&#x67;&#x6d;&#97;&#105;&#108;&#46;&#99;&#x6f;&#109;&#x5d;&#40;&#x29;</a></p>
<p>一个谬误：刺激需求
产能=消费，产能才是主动力。技术成长是随着产能成长而起来的。
而产能多的结果就是满足了需求，造成一种需求带来技术进步的假像。
而技术和产能之间的关系又错综复杂。。
2010/3/25 qiaojie <a href="&#109;&#97;&#x69;&#x6c;&#116;&#x6f;&#x3a;&#91;&#113;&#105;&#97;&#46;&#x2e;&#46;&#x40;&#x67;&#109;&#x61;&#x69;&#108;&#x2e;&#x63;&#x6f;&#109;&#93;&#40;&#41;">&#91;&#113;&#105;&#97;&#46;&#x2e;&#46;&#x40;&#x67;&#109;&#x61;&#x69;&#108;&#x2e;&#x63;&#x6f;&#109;&#93;&#40;&#41;</a></p>
<p>3D游戏就是一类杀手应用，由此支撑起了一个庞大的GPU市场，芯片行业的研发成本是很高的，没有一个庞大的市场是做不起来的。目前的消费者对于多核系统显然还没有强烈的需求，因为应用跟不上，i7发布快2年了还没进入主流市场，这种情况延续下去的话摩尔定律将因此失效。不过我相信杀手级应用总会出现的，这可能要硬件性能突破一个临界点，比方说目前GPU的性能再提升一个数量级的话，光线跟踪算法就可以提供流畅的接近CG的画质，倒是此类应用便会流行开来。</p>
<p>2010/3/25 Guancheng Chen <a href="&#109;&#97;&#x69;&#108;&#x74;&#111;&#x3a;&#x5b;&#99;&#x68;&#x65;&#110;&#103;&#117;&#x2e;&#46;&#x2e;&#64;&#103;&#x6d;&#97;&#x69;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#41;">&#x5b;&#99;&#x68;&#x65;&#110;&#103;&#117;&#x2e;&#46;&#x2e;&#64;&#103;&#x6d;&#97;&#x69;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#41;</a></p>
<p>杀手应用一般来说是指什么样的应用呢？比如用户群特别大的网游？还是那些专有的科学计算用的软件？
On 3月24日, 下午12时36分, qiaojie <a href="&#x6d;&#97;&#105;&#108;&#x74;&#x6f;&#x3a;&#x5b;&#x71;&#x69;&#x61;&#111;&#46;&#x2e;&#46;&#64;&#103;&#x6d;&#97;&#x69;&#x6c;&#46;&#99;&#111;&#x6d;&#93;&#x28;&#x29;">&#x5b;&#x71;&#x69;&#x61;&#111;&#46;&#x2e;&#46;&#64;&#103;&#x6d;&#97;&#x69;&#x6c;&#46;&#99;&#111;&#x6d;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>并行计算本来就是曲高和寡的东西，就跟3D渲染一样，能开发引擎的毕竟只是小部分人，大多数人在引擎的基础上做应用。关键在于是否有杀手应用，只要有大量的需求 ，自然会有人去做开发。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#109;&#x61;&#105;&#108;&#x74;&#x6f;&#x3a;&#x5b;&#104;&#111;&#x6e;&#103;&#122;&#x68;&#97;&#110;&#x67;&#x2e;&#x2e;&#x2e;&#46;&#64;&#103;&#109;&#x61;&#x69;&#x6c;&#46;&#x63;&#111;&#109;&#93;&#40;&#41;">&#x5b;&#104;&#111;&#x6e;&#103;&#122;&#x68;&#97;&#110;&#x67;&#x2e;&#x2e;&#x2e;&#46;&#64;&#103;&#109;&#x61;&#x69;&#x6c;&#46;&#x63;&#111;&#109;&#93;&#40;&#41;</a></p>
<blockquote>
<p>异构平台从网络处理器算起已经快10年了，现在情况仍然不明朗。就我看到的，异构平台要想高效，就必须向程序员暴露非常多的硬件细节，这必然导致编程的复杂性。 曲高和寡，要想渗透到应用程序这一块，我觉得很难。</p>
<p>2010/3/24 qiaojie <a href="&#109;&#97;&#105;&#108;&#116;&#x6f;&#58;&#91;&#x71;&#105;&#97;&#x6f;&#46;&#x2e;&#46;&#64;&#103;&#109;&#x61;&#x69;&#108;&#46;&#99;&#111;&#x6d;&#x5d;&#40;&#x29;">&#91;&#x71;&#105;&#97;&#x6f;&#46;&#x2e;&#46;&#64;&#103;&#109;&#x61;&#x69;&#108;&#46;&#99;&#111;&#x6d;&#x5d;&#40;&#x29;</a></p>
<blockquote>
<p>说的没错，cell已经成了先烈了。不过这不代表异构的方向不对，CUDA，OpenCL也都是异构平台，以后我们会越来越习惯异构平台的。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#109;&#x61;&#x69;&#x6c;&#x74;&#x6f;&#58;&#x5b;&#104;&#x6f;&#x6e;&#x67;&#x7a;&#x68;&#97;&#110;&#x67;&#46;&#x2e;&#x2e;&#46;&#64;&#x67;&#109;&#x61;&#x69;&#x6c;&#x2e;&#99;&#111;&#109;&#93;&#x28;&#x29;">&#x5b;&#104;&#x6f;&#x6e;&#x67;&#x7a;&#x68;&#97;&#110;&#x67;&#46;&#x2e;&#x2e;&#46;&#64;&#x67;&#109;&#x61;&#x69;&#x6c;&#x2e;&#99;&#111;&#109;&#93;&#x28;&#x29;</a></p>
<p>异构平台如果编程复杂度降不下来的话很难流行起来。cell已经死了...</p>
<blockquote>
<p> 2010/3/24 qiaojie <a href="&#x6d;&#x61;&#105;&#x6c;&#116;&#x6f;&#x3a;&#91;&#113;&#105;&#x61;&#x6f;&#46;&#x2e;&#x2e;&#x40;&#103;&#109;&#x61;&#x69;&#x6c;&#46;&#99;&#x6f;&#109;&#93;&#x28;&#41;">&#91;&#113;&#105;&#x61;&#x6f;&#46;&#x2e;&#x2e;&#x40;&#103;&#109;&#x61;&#x69;&#x6c;&#46;&#99;&#x6f;&#109;&#93;&#x28;&#41;</a></p>
<blockquote>
<p>不是所有的程序都需要并行化的，能用串行化解决的问题没必要并行，所以即使将来many-core系统成为主流，大部分程序员也没必要去搞并行计算。
  我觉得未来的主流应该是类似cell这样一颗全功能核心带众多协处理核心的异构系统，这样才能达到最优的 性能/核心面积比。</p>
<p>2010/3/24 Guancheng Chen <a href="&#109;&#x61;&#105;&#108;&#116;&#x6f;&#58;&#91;&#99;&#104;&#101;&#x6e;&#103;&#117;&#x61;&#x6e;&#99;&#104;&#46;&#46;&#x2e;&#64;&#103;&#109;&#x61;&#105;&#108;&#46;&#99;&#111;&#109;&#93;&#x28;&#41;">&#91;&#99;&#104;&#101;&#x6e;&#103;&#117;&#x61;&#x6e;&#99;&#104;&#46;&#46;&#x2e;&#64;&#103;&#109;&#x61;&#105;&#108;&#46;&#99;&#111;&#109;&#93;&#x28;&#41;</a></p>
<p>Nice 大胆预测Linear speedup应该是每个程序员十年后的目标 呵呵</p>
<blockquote>
<p>On 3月23日, 上午10时43分, qiaojie <a href="&#x6d;&#97;&#105;&#108;&#x74;&#111;&#x3a;&#91;&#113;&#105;&#97;&#111;&#x2e;&#x2e;&#x2e;&#64;&#103;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#41;">&#91;&#113;&#105;&#97;&#111;&#x2e;&#x2e;&#x2e;&#64;&#103;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>目前正在写的是一个软件渲染器，采用了光栅化和光线跟踪混合算法，渲染算法已经完全并行化了，
在4核系统上基本可以达到线性加速比，更多核的系统暂时还没测试。kd-tree的构造暂时还没有并
行化，以后有空了再研究。</p>
<p>2010/3/23 Guancheng Chen <a href="&#x6d;&#x61;&#105;&#108;&#116;&#x6f;&#58;&#x5b;&#x63;&#104;&#101;&#110;&#x67;&#117;&#x61;&#110;&#99;&#104;&#x2e;&#46;&#x2e;&#64;&#x67;&#x6d;&#97;&#x69;&#x6c;&#46;&#x63;&#111;&#109;&#93;&#40;&#x29;">&#x5b;&#x63;&#104;&#101;&#110;&#x67;&#117;&#x61;&#110;&#99;&#104;&#x2e;&#46;&#x2e;&#64;&#x67;&#x6d;&#97;&#x69;&#x6c;&#46;&#x63;&#111;&#109;&#93;&#40;&#x29;</a></p>
<blockquote>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？</p>
<p>On 3月23日, 上午9时15分, qiaojie <a href="&#x6d;&#97;&#105;&#x6c;&#x74;&#x6f;&#58;&#91;&#113;&#x69;&#97;&#x6f;&#x2e;&#46;&#x2e;&#64;&#x67;&#109;&#97;&#x69;&#108;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#x28;&#x29;">&#91;&#113;&#x69;&#97;&#x6f;&#x2e;&#46;&#x2e;&#64;&#x67;&#109;&#97;&#x69;&#108;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1)
=
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank
Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？</p>
</blockquote>
<p> To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a></p>
<p><img src="" alt=""> tinyfool <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-25</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>哈哈，终于从技术聊到经济了</p>
<p>在 2010-3-25，下午2:11， qiaojie 写道：</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>什么叫产能过剩？假设全世界每年消费10000亿斤粮食，结果今年收成好，生产了15000亿斤，</p>
<p>那多出来的5000亿斤无法被市场消化掉，就是产能过剩。那5000亿斤没价值，是垃圾？生产那
5000亿斤的农民是闲的蛋疼没事干？靠政府失业金养？</p>
<p>2010/3/25 机械唯物主义 : linjunhalida <a href="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#111;&#58;&#91;&#x6c;&#105;&#110;&#x6a;&#117;&#110;&#x2e;&#46;&#46;&#x40;&#x67;&#x6d;&#x61;&#x69;&#108;&#46;&#99;&#x6f;&#109;&#93;&#40;&#41;">&#91;&#x6c;&#105;&#110;&#x6a;&#117;&#110;&#x2e;&#46;&#46;&#x40;&#x67;&#x6d;&#x61;&#x69;&#108;&#46;&#99;&#x6f;&#109;&#93;&#40;&#41;</a>
产能过剩的说法本来就不对。
产出的东西没有价值，这样的活动就不能说是生产。
比如我这个程序员，花了1周写了一个垃圾程序，然后被开除了。
然后1个月闲着，这是我产能过剩吗？
而闲着的原因是政府给我失业金，我就不需要工作闲起来了。。。</p>
<p>2010/3/25 qiaojie <a href="&#109;&#97;&#x69;&#108;&#116;&#x6f;&#x3a;&#91;&#x71;&#x69;&#97;&#x2e;&#46;&#x2e;&#64;&#103;&#109;&#97;&#105;&#108;&#x2e;&#x63;&#111;&#x6d;&#93;&#x28;&#41;">&#91;&#x71;&#x69;&#97;&#x2e;&#46;&#x2e;&#64;&#103;&#109;&#97;&#105;&#108;&#x2e;&#x63;&#111;&#x6d;&#93;&#x28;&#41;</a>
如果产能=消费的话就没有产能过剩这一说了。</p>
<p>2010/3/25 机械唯物主义 : linjunhalida <a href="&#109;&#x61;&#x69;&#x6c;&#116;&#111;&#58;&#x5b;&#x6c;&#105;&#x6e;&#x6a;&#117;&#x6e;&#46;&#46;&#46;&#64;&#103;&#x6d;&#x61;&#x69;&#x6c;&#46;&#99;&#111;&#109;&#93;&#x28;&#41;">&#x5b;&#x6c;&#105;&#x6e;&#x6a;&#117;&#x6e;&#46;&#46;&#46;&#64;&#103;&#x6d;&#x61;&#x69;&#x6c;&#46;&#99;&#111;&#109;&#93;&#x28;&#41;</a></p>
<p>一个谬误：刺激需求
产能=消费，产能才是主动力。技术成长是随着产能成长而起来的。
而产能多的结果就是满足了需求，造成一种需求带来技术进步的假像。
而技术和产能之间的关系又错综复杂。。
2010/3/25 qiaojie <a href="&#x6d;&#97;&#105;&#108;&#x74;&#111;&#58;&#x5b;&#x71;&#x69;&#x61;&#x2e;&#x2e;&#46;&#64;&#103;&#109;&#97;&#105;&#x6c;&#x2e;&#x63;&#111;&#109;&#93;&#40;&#x29;">&#x5b;&#x71;&#x69;&#x61;&#x2e;&#x2e;&#46;&#64;&#103;&#109;&#97;&#105;&#x6c;&#x2e;&#x63;&#111;&#109;&#93;&#40;&#x29;</a></p>
<p>3D游戏就是一类杀手应用，由此支撑起了一个庞大的GPU市场，芯片行业的研发成本是很高的，没有一个庞大的市场是做不起来的。目前的消费者对于多核系统显然还没有强烈的需求，因为应用跟不上，i7发布快2年了还没进入主流市场，这种情况延续下去的话摩尔定律将因此失效。不过我相信杀手级应用总会出现的，这可能要硬件性能突破一个临界点，比方说目前GPU的性能再提升一个数量级的话，光线跟踪算法就可以提供流畅的接近CG的画质，倒是此类应用便会流行开来。</p>
<p>2010/3/25 Guancheng Chen <a href="&#109;&#x61;&#x69;&#108;&#x74;&#111;&#x3a;&#x5b;&#x63;&#x68;&#101;&#x6e;&#x67;&#x75;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#109;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#93;&#40;&#41;">&#x5b;&#x63;&#x68;&#101;&#x6e;&#x67;&#x75;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#109;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#93;&#40;&#41;</a></p>
<p>杀手应用一般来说是指什么样的应用呢？比如用户群特别大的网游？还是那些专有的科学计算用的软件？
On 3月24日, 下午12时36分, qiaojie <a href="&#x6d;&#x61;&#105;&#108;&#116;&#111;&#x3a;&#91;&#113;&#105;&#97;&#111;&#46;&#x2e;&#46;&#64;&#x67;&#109;&#97;&#x69;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#41;">&#91;&#113;&#105;&#97;&#111;&#46;&#x2e;&#46;&#64;&#x67;&#109;&#97;&#x69;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>并行计算本来就是曲高和寡的东西，就跟3D渲染一样，能开发引擎的毕竟只是小部分人，大多数人在引擎的基础上做应用。关键在于是否有杀手应用，只要有大量的需求 ，自然会有人去做开发。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#109;&#x61;&#105;&#x6c;&#x74;&#111;&#58;&#x5b;&#104;&#x6f;&#110;&#103;&#122;&#104;&#x61;&#110;&#x67;&#46;&#46;&#46;&#46;&#x40;&#103;&#109;&#x61;&#105;&#108;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#41;">&#x5b;&#104;&#x6f;&#110;&#103;&#122;&#104;&#x61;&#110;&#x67;&#46;&#46;&#46;&#46;&#x40;&#103;&#109;&#x61;&#105;&#108;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#41;</a></p>
<blockquote>
<p>异构平台从网络处理器算起已经快10年了，现在情况仍然不明朗。就我看到的，异构平台要想高效，就必须向程序员暴露非常多的硬件细节，这必然导致编程的复杂性。 曲高和寡，要想渗透到应用程序这一块，我觉得很难。</p>
<p>2010/3/24 qiaojie <a href="&#109;&#x61;&#x69;&#108;&#116;&#111;&#x3a;&#x5b;&#x71;&#105;&#97;&#x6f;&#46;&#46;&#46;&#x40;&#x67;&#x6d;&#97;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#x28;&#x29;">&#x5b;&#x71;&#105;&#97;&#x6f;&#46;&#46;&#46;&#x40;&#x67;&#x6d;&#97;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#x28;&#x29;</a></p>
<blockquote>
<p>说的没错，cell已经成了先烈了。不过这不代表异构的方向不对，CUDA，OpenCL也都是异构平台，以后我们会越来越习惯异构平台的。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#109;&#97;&#105;&#108;&#116;&#x6f;&#x3a;&#x5b;&#x68;&#111;&#110;&#103;&#122;&#104;&#x61;&#x6e;&#103;&#46;&#x2e;&#46;&#x2e;&#64;&#103;&#x6d;&#97;&#105;&#x6c;&#46;&#x63;&#111;&#109;&#x5d;&#40;&#41;">&#x5b;&#x68;&#111;&#110;&#103;&#122;&#104;&#x61;&#x6e;&#103;&#46;&#x2e;&#46;&#x2e;&#64;&#103;&#x6d;&#97;&#105;&#x6c;&#46;&#x63;&#111;&#109;&#x5d;&#40;&#41;</a></p>
<p>异构平台如果编程复杂度降不下来的话很难流行起来。cell已经死了...</p>
<blockquote>
<p> 2010/3/24 qiaojie <a href="&#x6d;&#x61;&#105;&#108;&#x74;&#x6f;&#x3a;&#91;&#x71;&#x69;&#x61;&#111;&#x2e;&#46;&#x2e;&#64;&#x67;&#109;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#111;&#109;&#93;&#40;&#x29;">&#91;&#x71;&#x69;&#x61;&#111;&#x2e;&#46;&#x2e;&#64;&#x67;&#109;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#111;&#109;&#93;&#40;&#x29;</a></p>
<blockquote>
<p>不是所有的程序都需要并行化的，能用串行化解决的问题没必要并行，所以即使将来many-core系统成为主流，大部分程序员也没必要去搞并行计算。
  我觉得未来的主流应该是类似cell这样一颗全功能核心带众多协处理核心的异构系统，这样才能达到最优的 性能/核心面积比。</p>
<p>2010/3/24 Guancheng Chen <a href="&#109;&#97;&#105;&#x6c;&#x74;&#x6f;&#x3a;&#x5b;&#x63;&#104;&#101;&#110;&#103;&#117;&#97;&#110;&#99;&#x68;&#46;&#46;&#x2e;&#64;&#x67;&#x6d;&#97;&#x69;&#x6c;&#46;&#x63;&#x6f;&#109;&#x5d;&#40;&#41;">&#x5b;&#x63;&#104;&#101;&#110;&#103;&#117;&#97;&#110;&#99;&#x68;&#46;&#46;&#x2e;&#64;&#x67;&#x6d;&#97;&#x69;&#x6c;&#46;&#x63;&#x6f;&#109;&#x5d;&#40;&#41;</a></p>
<p>Nice 大胆预测Linear speedup应该是每个程序员十年后的目标 呵呵</p>
<blockquote>
<p>On 3月23日, 上午10时43分, qiaojie <a href="&#109;&#x61;&#105;&#x6c;&#x74;&#x6f;&#x3a;&#x5b;&#113;&#105;&#x61;&#x6f;&#x2e;&#46;&#46;&#x40;&#103;&#109;&#97;&#105;&#x6c;&#46;&#x63;&#x6f;&#109;&#93;&#x28;&#x29;">&#x5b;&#113;&#105;&#x61;&#x6f;&#x2e;&#46;&#46;&#x40;&#103;&#109;&#97;&#105;&#x6c;&#46;&#x63;&#x6f;&#109;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>目前正在写的是一个软件渲染器，采用了光栅化和光线跟踪混合算法，渲染算法已经完全并行化了，
在4核系统上基本可以达到线性加速比，更多核的系统暂时还没测试。kd-tree的构造暂时还没有并
行化，以后有空了再研究。</p>
<p>2010/3/23 Guancheng Chen <a href="&#109;&#97;&#105;&#108;&#x74;&#111;&#58;&#91;&#x63;&#x68;&#101;&#110;&#103;&#117;&#x61;&#x6e;&#x63;&#104;&#x2e;&#46;&#x2e;&#x40;&#103;&#109;&#97;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#40;&#x29;">&#91;&#x63;&#x68;&#101;&#110;&#103;&#117;&#x61;&#x6e;&#x63;&#104;&#x2e;&#46;&#x2e;&#x40;&#103;&#109;&#97;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#40;&#x29;</a></p>
<blockquote>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？</p>
<p>On 3月23日, 上午9时15分, qiaojie <a href="&#x6d;&#97;&#105;&#x6c;&#x74;&#111;&#x3a;&#x5b;&#113;&#x69;&#x61;&#111;&#x2e;&#46;&#x2e;&#64;&#103;&#109;&#97;&#x69;&#x6c;&#x2e;&#x63;&#111;&#109;&#93;&#40;&#x29;">&#x5b;&#113;&#x69;&#x61;&#111;&#x2e;&#46;&#x2e;&#64;&#103;&#109;&#97;&#x69;&#x6c;&#x2e;&#x63;&#111;&#109;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1)
=
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank
Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？</p>
</blockquote>
<p> To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> 机械唯物主义 : linjunhalida <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-25</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>本来就不该生产那么多的粮食，多余的人力和土地可以用来做别的事情。
问题在于为什么他们估算错误？
2010/3/25 qiaojie <a href="&#109;&#97;&#x69;&#x6c;&#116;&#x6f;&#58;&#91;&#113;&#105;&#97;&#46;&#46;&#x2e;&#x40;&#103;&#109;&#97;&#105;&#108;&#x2e;&#x63;&#111;&#x6d;&#93;&#x28;&#x29;">&#91;&#113;&#105;&#97;&#46;&#46;&#x2e;&#x40;&#103;&#109;&#97;&#105;&#108;&#x2e;&#x63;&#111;&#x6d;&#93;&#x28;&#x29;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>什么叫产能过剩？假设全世界每年消费10000亿斤粮食，结果今年收成好，生产了15000亿斤，</p>
<p>那多出来的5000亿斤无法被市场消化掉，就是产能过剩。那5000亿斤没价值，是垃圾？生产那
5000亿斤的农民是闲的蛋疼没事干？靠政府失业金养？</p>
<p>2010/3/25 机械唯物主义 : linjunhalida <a href="&#x6d;&#97;&#105;&#108;&#x74;&#x6f;&#x3a;&#x5b;&#108;&#x69;&#110;&#x6a;&#117;&#x6e;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#109;&#x61;&#105;&#x6c;&#x2e;&#x63;&#111;&#109;&#x5d;&#x28;&#41;">&#x5b;&#108;&#x69;&#110;&#x6a;&#117;&#x6e;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#109;&#x61;&#105;&#x6c;&#x2e;&#x63;&#111;&#109;&#x5d;&#x28;&#41;</a>
产能过剩的说法本来就不对。
产出的东西没有价值，这样的活动就不能说是生产。
比如我这个程序员，花了1周写了一个垃圾程序，然后被开除了。
然后1个月闲着，这是我产能过剩吗？
而闲着的原因是政府给我失业金，我就不需要工作闲起来了。。。</p>
<p>2010/3/25 qiaojie <a href="&#x6d;&#x61;&#105;&#108;&#116;&#111;&#x3a;&#x5b;&#113;&#105;&#97;&#46;&#46;&#46;&#64;&#x67;&#109;&#97;&#105;&#108;&#46;&#x63;&#111;&#x6d;&#93;&#x28;&#41;">&#x5b;&#113;&#105;&#97;&#46;&#46;&#46;&#64;&#x67;&#109;&#97;&#105;&#108;&#46;&#x63;&#111;&#x6d;&#93;&#x28;&#41;</a>
如果产能=消费的话就没有产能过剩这一说了。</p>
<p>2010/3/25 机械唯物主义 : linjunhalida <a href="&#x6d;&#97;&#105;&#108;&#116;&#x6f;&#x3a;&#x5b;&#x6c;&#105;&#x6e;&#106;&#x75;&#x6e;&#46;&#46;&#x2e;&#64;&#x67;&#x6d;&#x61;&#105;&#108;&#46;&#x63;&#111;&#x6d;&#93;&#x28;&#x29;">&#x5b;&#x6c;&#105;&#x6e;&#106;&#x75;&#x6e;&#46;&#46;&#x2e;&#64;&#x67;&#x6d;&#x61;&#105;&#108;&#46;&#x63;&#111;&#x6d;&#93;&#x28;&#x29;</a></p>
<p>一个谬误：刺激需求
产能=消费，产能才是主动力。技术成长是随着产能成长而起来的。
而产能多的结果就是满足了需求，造成一种需求带来技术进步的假像。
而技术和产能之间的关系又错综复杂。。
2010/3/25 qiaojie <a href="&#x6d;&#97;&#x69;&#108;&#x74;&#x6f;&#58;&#x5b;&#x71;&#x69;&#x61;&#46;&#x2e;&#46;&#64;&#103;&#109;&#97;&#x69;&#x6c;&#46;&#x63;&#111;&#x6d;&#93;&#x28;&#41;">&#x5b;&#x71;&#x69;&#x61;&#46;&#x2e;&#46;&#64;&#103;&#109;&#97;&#x69;&#x6c;&#46;&#x63;&#111;&#x6d;&#93;&#x28;&#41;</a></p>
<p>3D游戏就是一类杀手应用，由此支撑起了一个庞大的GPU市场，芯片行业的研发成本是很高的，没有一个庞大的市场是做不起来的。目前的消费者对于多核系统显然还没有强烈的需求，因为应用跟不上，i7发布快2年了还没进入主流市场，这种情况延续下去的话摩尔定律将因此失效。不过我相信杀手级应用总会出现的，这可能要硬件性能突破一个临界点，比方说目前GPU的性能再提升一个数量级的话，光线跟踪算法就可以提供流畅的接近CG的画质，倒是此类应用便会流行开来。</p>
<p>2010/3/25 Guancheng Chen <a href="&#109;&#97;&#105;&#108;&#x74;&#x6f;&#x3a;&#91;&#99;&#x68;&#x65;&#x6e;&#x67;&#117;&#46;&#46;&#46;&#x40;&#103;&#x6d;&#97;&#105;&#x6c;&#x2e;&#99;&#111;&#109;&#93;&#40;&#x29;">&#91;&#99;&#x68;&#x65;&#x6e;&#x67;&#117;&#46;&#46;&#46;&#x40;&#103;&#x6d;&#97;&#105;&#x6c;&#x2e;&#99;&#111;&#109;&#93;&#40;&#x29;</a></p>
<p>杀手应用一般来说是指什么样的应用呢？比如用户群特别大的网游？还是那些专有的科学计算用的软件？
On 3月24日, 下午12时36分, qiaojie <a href="&#109;&#97;&#105;&#x6c;&#116;&#x6f;&#58;&#x5b;&#x71;&#x69;&#x61;&#111;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#109;&#x61;&#105;&#108;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#41;">&#x5b;&#x71;&#x69;&#x61;&#111;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#109;&#x61;&#105;&#108;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>并行计算本来就是曲高和寡的东西，就跟3D渲染一样，能开发引擎的毕竟只是小部分人，大多数人在引擎的基础上做应用。关键在于是否有杀手应用，只要有大量的需求 ，自然会有人去做开发。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#x6d;&#97;&#105;&#108;&#x74;&#111;&#x3a;&#x5b;&#x68;&#111;&#x6e;&#103;&#x7a;&#104;&#97;&#110;&#103;&#46;&#46;&#46;&#46;&#64;&#103;&#109;&#x61;&#105;&#x6c;&#x2e;&#99;&#x6f;&#109;&#93;&#x28;&#41;">&#x5b;&#x68;&#111;&#x6e;&#103;&#x7a;&#104;&#97;&#110;&#103;&#46;&#46;&#46;&#46;&#64;&#103;&#109;&#x61;&#105;&#x6c;&#x2e;&#99;&#x6f;&#109;&#93;&#x28;&#41;</a></p>
<blockquote>
<p>异构平台从网络处理器算起已经快10年了，现在情况仍然不明朗。就我看到的，异构平台要想高效，就必须向程序员暴露非常多的硬件细节，这必然导致编程的复杂性。 曲高和寡，要想渗透到应用程序这一块，我觉得很难。</p>
<p>2010/3/24 qiaojie <a href="&#109;&#97;&#x69;&#x6c;&#116;&#x6f;&#58;&#x5b;&#113;&#105;&#97;&#111;&#46;&#x2e;&#46;&#x40;&#x67;&#109;&#97;&#x69;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#93;&#x28;&#x29;">&#x5b;&#113;&#105;&#97;&#111;&#46;&#x2e;&#46;&#x40;&#x67;&#109;&#97;&#x69;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#93;&#x28;&#x29;</a></p>
<blockquote>
<p>说的没错，cell已经成了先烈了。不过这不代表异构的方向不对，CUDA，OpenCL也都是异构平台，以后我们会越来越习惯异构平台的。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#x6d;&#97;&#105;&#x6c;&#116;&#x6f;&#58;&#91;&#x68;&#x6f;&#110;&#103;&#x7a;&#x68;&#x61;&#x6e;&#103;&#x2e;&#46;&#46;&#x2e;&#x40;&#x67;&#109;&#97;&#x69;&#108;&#x2e;&#99;&#x6f;&#109;&#x5d;&#x28;&#41;">&#91;&#x68;&#x6f;&#110;&#103;&#x7a;&#x68;&#x61;&#x6e;&#103;&#x2e;&#46;&#46;&#x2e;&#x40;&#x67;&#109;&#97;&#x69;&#108;&#x2e;&#99;&#x6f;&#109;&#x5d;&#x28;&#41;</a></p>
<p>异构平台如果编程复杂度降不下来的话很难流行起来。cell已经死了...</p>
<blockquote>
<p> 2010/3/24 qiaojie <a href="&#109;&#97;&#x69;&#x6c;&#116;&#x6f;&#58;&#x5b;&#x71;&#105;&#x61;&#x6f;&#46;&#46;&#x2e;&#64;&#x67;&#109;&#97;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#40;&#x29;">&#x5b;&#x71;&#105;&#x61;&#x6f;&#46;&#46;&#x2e;&#64;&#x67;&#109;&#97;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#40;&#x29;</a></p>
<blockquote>
<p>不是所有的程序都需要并行化的，能用串行化解决的问题没必要并行，所以即使将来many-core系统成为主流，大部分程序员也没必要去搞并行计算。
  我觉得未来的主流应该是类似cell这样一颗全功能核心带众多协处理核心的异构系统，这样才能达到最优的 性能/核心面积比。</p>
<p>2010/3/24 Guancheng Chen <a href="&#x6d;&#97;&#x69;&#108;&#116;&#111;&#58;&#91;&#99;&#104;&#x65;&#x6e;&#x67;&#117;&#97;&#x6e;&#99;&#104;&#46;&#x2e;&#46;&#x40;&#x67;&#109;&#97;&#x69;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#93;&#x28;&#41;">&#91;&#99;&#104;&#x65;&#x6e;&#x67;&#117;&#97;&#x6e;&#99;&#104;&#46;&#x2e;&#46;&#x40;&#x67;&#109;&#97;&#x69;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#93;&#x28;&#41;</a></p>
<p>Nice 大胆预测Linear speedup应该是每个程序员十年后的目标 呵呵</p>
<blockquote>
<p>On 3月23日, 上午10时43分, qiaojie <a href="&#x6d;&#97;&#105;&#108;&#x74;&#111;&#x3a;&#91;&#113;&#105;&#97;&#111;&#46;&#46;&#46;&#64;&#x67;&#109;&#x61;&#105;&#108;&#46;&#x63;&#111;&#x6d;&#93;&#x28;&#x29;">&#91;&#113;&#105;&#97;&#111;&#46;&#46;&#46;&#64;&#x67;&#109;&#x61;&#105;&#108;&#46;&#x63;&#111;&#x6d;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>目前正在写的是一个软件渲染器，采用了光栅化和光线跟踪混合算法，渲染算法已经完全并行化了，
在4核系统上基本可以达到线性加速比，更多核的系统暂时还没测试。kd-tree的构造暂时还没有并
行化，以后有空了再研究。</p>
<p>2010/3/23 Guancheng Chen <a href="&#x6d;&#x61;&#105;&#108;&#x74;&#x6f;&#58;&#x5b;&#x63;&#x68;&#101;&#x6e;&#103;&#117;&#97;&#x6e;&#99;&#104;&#46;&#46;&#46;&#64;&#x67;&#109;&#97;&#105;&#108;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#40;&#x29;">&#x5b;&#x63;&#x68;&#101;&#x6e;&#103;&#117;&#97;&#x6e;&#99;&#104;&#46;&#46;&#46;&#64;&#x67;&#109;&#97;&#105;&#108;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#40;&#x29;</a></p>
<blockquote>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？</p>
<p>On 3月23日, 上午9时15分, qiaojie <a href="&#x6d;&#x61;&#105;&#x6c;&#116;&#111;&#x3a;&#x5b;&#113;&#105;&#97;&#x6f;&#46;&#46;&#46;&#x40;&#103;&#x6d;&#97;&#105;&#108;&#x2e;&#99;&#111;&#x6d;&#x5d;&#40;&#41;">&#x5b;&#113;&#105;&#97;&#x6f;&#46;&#46;&#46;&#x40;&#103;&#x6d;&#97;&#105;&#108;&#x2e;&#99;&#111;&#x6d;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1)
=
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank
Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？</p>
</blockquote>
<p> To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a></p>
<p><img src="" alt=""> qiaojie <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-25</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>产能过剩和短缺导致的价格波动是市场经济的典型特征，想要消除过剩和短缺那叫计划经济，</p>
<p>学点经济学常识再来讨论这些问题吧。
2010/3/25 机械唯物主义 : linjunhalida <a href="&#109;&#97;&#105;&#x6c;&#116;&#111;&#x3a;&#x5b;&#x6c;&#x69;&#110;&#x6a;&#117;&#x6e;&#x2e;&#x2e;&#46;&#64;&#x67;&#x6d;&#97;&#105;&#108;&#46;&#x63;&#111;&#109;&#93;&#40;&#41;">&#x5b;&#x6c;&#x69;&#110;&#x6a;&#117;&#x6e;&#x2e;&#x2e;&#46;&#64;&#x67;&#x6d;&#97;&#105;&#108;&#46;&#x63;&#111;&#109;&#93;&#40;&#41;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>本来就不该生产那么多的粮食，多余的人力和土地可以用来做别的事情。
问题在于为什么他们估算错误？</p>
<p>2010/3/25 qiaojie <a href="&#x6d;&#97;&#x69;&#x6c;&#x74;&#x6f;&#x3a;&#x5b;&#x71;&#105;&#x61;&#x2e;&#46;&#46;&#64;&#103;&#109;&#x61;&#105;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#93;&#40;&#x29;">&#x5b;&#x71;&#105;&#x61;&#x2e;&#46;&#46;&#64;&#103;&#109;&#x61;&#105;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#93;&#40;&#x29;</a>
什么叫产能过剩？假设全世界每年消费10000亿斤粮食，结果今年收成好，生产了15000亿斤，</p>
<p>那多出来的5000亿斤无法被市场消化掉，就是产能过剩。那5000亿斤没价值，是垃圾？生产那
5000亿斤的农民是闲的蛋疼没事干？靠政府失业金养？</p>
<p>2010/3/25 机械唯物主义 : linjunhalida <a href="&#x6d;&#97;&#x69;&#x6c;&#116;&#111;&#58;&#91;&#108;&#105;&#x6e;&#106;&#117;&#110;&#46;&#46;&#46;&#64;&#103;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#111;&#109;&#93;&#40;&#x29;">&#91;&#108;&#105;&#x6e;&#106;&#117;&#110;&#46;&#46;&#46;&#64;&#103;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#111;&#109;&#93;&#40;&#x29;</a>
产能过剩的说法本来就不对。
产出的东西没有价值，这样的活动就不能说是生产。
比如我这个程序员，花了1周写了一个垃圾程序，然后被开除了。
然后1个月闲着，这是我产能过剩吗？
而闲着的原因是政府给我失业金，我就不需要工作闲起来了。。。</p>
<p>2010/3/25 qiaojie <a href="&#x6d;&#97;&#x69;&#108;&#116;&#x6f;&#x3a;&#x5b;&#113;&#105;&#97;&#x2e;&#46;&#x2e;&#64;&#x67;&#109;&#x61;&#105;&#x6c;&#46;&#x63;&#111;&#x6d;&#93;&#x28;&#41;">&#x5b;&#113;&#105;&#97;&#x2e;&#46;&#x2e;&#64;&#x67;&#109;&#x61;&#105;&#x6c;&#46;&#x63;&#111;&#x6d;&#93;&#x28;&#41;</a>
如果产能=消费的话就没有产能过剩这一说了。</p>
<p>2010/3/25 机械唯物主义 : linjunhalida <a href="&#x6d;&#x61;&#105;&#108;&#116;&#111;&#58;&#91;&#108;&#105;&#x6e;&#106;&#117;&#110;&#46;&#46;&#x2e;&#x40;&#x67;&#x6d;&#97;&#105;&#x6c;&#x2e;&#99;&#x6f;&#109;&#x5d;&#x28;&#x29;">&#91;&#108;&#105;&#x6e;&#106;&#117;&#110;&#46;&#46;&#x2e;&#x40;&#x67;&#x6d;&#97;&#105;&#x6c;&#x2e;&#99;&#x6f;&#109;&#x5d;&#x28;&#x29;</a></p>
<p>一个谬误：刺激需求
产能=消费，产能才是主动力。技术成长是随着产能成长而起来的。
而产能多的结果就是满足了需求，造成一种需求带来技术进步的假像。
而技术和产能之间的关系又错综复杂。。
2010/3/25 qiaojie <a href="&#x6d;&#97;&#105;&#108;&#x74;&#111;&#58;&#91;&#113;&#x69;&#97;&#x2e;&#46;&#46;&#x40;&#x67;&#109;&#97;&#x69;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#40;&#41;">&#91;&#113;&#x69;&#97;&#x2e;&#46;&#46;&#x40;&#x67;&#109;&#97;&#x69;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#40;&#41;</a></p>
<p>3D游戏就是一类杀手应用，由此支撑起了一个庞大的GPU市场，芯片行业的研发成本是很高的，没有一个庞大的市场是做不起来的。目前的消费者对于多核系统显然还没有强烈的需求，因为应用跟不上，i7发布快2年了还没进入主流市场，这种情况延续下去的话摩尔定律将因此失效。不过我相信杀手级应用总会出现的，这可能要硬件性能突破一个临界点，比方说目前GPU的性能再提升一个数量级的话，光线跟踪算法就可以提供流畅的接近CG的画质，倒是此类应用便会流行开来。</p>
<p>2010/3/25 Guancheng Chen <a href="&#x6d;&#x61;&#x69;&#108;&#x74;&#x6f;&#58;&#x5b;&#99;&#104;&#101;&#x6e;&#103;&#x75;&#46;&#46;&#x2e;&#x40;&#103;&#109;&#x61;&#105;&#108;&#x2e;&#99;&#111;&#109;&#93;&#40;&#41;">&#x5b;&#99;&#104;&#101;&#x6e;&#103;&#x75;&#46;&#46;&#x2e;&#x40;&#103;&#109;&#x61;&#105;&#108;&#x2e;&#99;&#111;&#109;&#93;&#40;&#41;</a></p>
<p>杀手应用一般来说是指什么样的应用呢？比如用户群特别大的网游？还是那些专有的科学计算用的软件？
On 3月24日, 下午12时36分, qiaojie <a href="&#109;&#x61;&#105;&#108;&#x74;&#111;&#58;&#x5b;&#113;&#x69;&#97;&#x6f;&#46;&#46;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#105;&#108;&#46;&#99;&#x6f;&#x6d;&#93;&#40;&#41;">&#x5b;&#113;&#x69;&#97;&#x6f;&#46;&#46;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#105;&#108;&#46;&#99;&#x6f;&#x6d;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>并行计算本来就是曲高和寡的东西，就跟3D渲染一样，能开发引擎的毕竟只是小部分人，大多数人在引擎的基础上做应用。关键在于是否有杀手应用，只要有大量的需求 ，自然会有人去做开发。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#x6d;&#97;&#x69;&#108;&#116;&#x6f;&#x3a;&#x5b;&#x68;&#x6f;&#110;&#x67;&#x7a;&#104;&#97;&#110;&#103;&#46;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#109;&#x61;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#40;&#x29;">&#x5b;&#x68;&#x6f;&#110;&#x67;&#x7a;&#104;&#97;&#110;&#103;&#46;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#109;&#x61;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#40;&#x29;</a></p>
<blockquote>
<p>异构平台从网络处理器算起已经快10年了，现在情况仍然不明朗。就我看到的，异构平台要想高效，就必须向程序员暴露非常多的硬件细节，这必然导致编程的复杂性。 曲高和寡，要想渗透到应用程序这一块，我觉得很难。</p>
<p>2010/3/24 qiaojie <a href="&#109;&#97;&#x69;&#x6c;&#116;&#x6f;&#x3a;&#x5b;&#113;&#105;&#97;&#111;&#x2e;&#x2e;&#46;&#x40;&#103;&#x6d;&#x61;&#x69;&#108;&#x2e;&#99;&#111;&#109;&#93;&#x28;&#41;">&#x5b;&#113;&#105;&#97;&#111;&#x2e;&#x2e;&#46;&#x40;&#103;&#x6d;&#x61;&#x69;&#108;&#x2e;&#99;&#111;&#109;&#93;&#x28;&#41;</a></p>
<blockquote>
<p>说的没错，cell已经成了先烈了。不过这不代表异构的方向不对，CUDA，OpenCL也都是异构平台，以后我们会越来越习惯异构平台的。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#x6d;&#97;&#105;&#x6c;&#x74;&#111;&#x3a;&#91;&#x68;&#111;&#x6e;&#103;&#122;&#104;&#x61;&#110;&#103;&#x2e;&#x2e;&#46;&#46;&#x40;&#x67;&#x6d;&#97;&#x69;&#x6c;&#46;&#99;&#x6f;&#109;&#x5d;&#40;&#41;">&#91;&#x68;&#111;&#x6e;&#103;&#122;&#104;&#x61;&#110;&#103;&#x2e;&#x2e;&#46;&#46;&#x40;&#x67;&#x6d;&#97;&#x69;&#x6c;&#46;&#99;&#x6f;&#109;&#x5d;&#40;&#41;</a></p>
<p>异构平台如果编程复杂度降不下来的话很难流行起来。cell已经死了...</p>
<blockquote>
<p> 2010/3/24 qiaojie <a href="&#109;&#x61;&#105;&#108;&#x74;&#111;&#x3a;&#91;&#x71;&#105;&#97;&#x6f;&#46;&#46;&#46;&#x40;&#103;&#109;&#97;&#105;&#108;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#x28;&#x29;">&#91;&#x71;&#105;&#97;&#x6f;&#46;&#46;&#46;&#x40;&#103;&#109;&#97;&#105;&#108;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#x28;&#x29;</a></p>
<blockquote>
<p>不是所有的程序都需要并行化的，能用串行化解决的问题没必要并行，所以即使将来many-core系统成为主流，大部分程序员也没必要去搞并行计算。
  我觉得未来的主流应该是类似cell这样一颗全功能核心带众多协处理核心的异构系统，这样才能达到最优的 性能/核心面积比。</p>
<p>2010/3/24 Guancheng Chen <a href="&#109;&#97;&#105;&#108;&#116;&#x6f;&#58;&#91;&#x63;&#104;&#x65;&#x6e;&#x67;&#x75;&#97;&#110;&#99;&#104;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#109;&#x61;&#x69;&#x6c;&#x2e;&#99;&#111;&#x6d;&#x5d;&#x28;&#x29;">&#91;&#x63;&#104;&#x65;&#x6e;&#x67;&#x75;&#97;&#110;&#99;&#104;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#109;&#x61;&#x69;&#x6c;&#x2e;&#99;&#111;&#x6d;&#x5d;&#x28;&#x29;</a></p>
<p>Nice 大胆预测Linear speedup应该是每个程序员十年后的目标 呵呵</p>
<blockquote>
<p>On 3月23日, 上午10时43分, qiaojie <a href="&#x6d;&#97;&#105;&#x6c;&#x74;&#111;&#58;&#91;&#x71;&#105;&#97;&#111;&#46;&#x2e;&#x2e;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#x63;&#x6f;&#109;&#x5d;&#x28;&#x29;">&#91;&#x71;&#105;&#97;&#111;&#46;&#x2e;&#x2e;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#x63;&#x6f;&#109;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>目前正在写的是一个软件渲染器，采用了光栅化和光线跟踪混合算法，渲染算法已经完全并行化了，
在4核系统上基本可以达到线性加速比，更多核的系统暂时还没测试。kd-tree的构造暂时还没有并
行化，以后有空了再研究。</p>
<p>2010/3/23 Guancheng Chen <a href="&#109;&#97;&#x69;&#x6c;&#x74;&#x6f;&#58;&#91;&#x63;&#104;&#101;&#x6e;&#x67;&#117;&#97;&#x6e;&#99;&#104;&#x2e;&#46;&#46;&#64;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#93;&#x28;&#41;">&#91;&#x63;&#104;&#101;&#x6e;&#x67;&#117;&#97;&#x6e;&#99;&#104;&#x2e;&#46;&#46;&#64;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#93;&#x28;&#41;</a></p>
<blockquote>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？</p>
<p>On 3月23日, 上午9时15分, qiaojie <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#91;&#113;&#105;&#x61;&#x6f;&#46;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#x61;&#105;&#x6c;&#46;&#99;&#111;&#109;&#93;&#x28;&#x29;">&#91;&#113;&#105;&#x61;&#x6f;&#46;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#x61;&#105;&#x6c;&#46;&#99;&#111;&#109;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1)
=
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank
Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？</p>
</blockquote>
<p> To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> 机械唯物主义 : linjunhalida <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-25</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>小规模的，市场会自动调节。
如果出现大规模的问题，就有可能是信息错误——货币的币值变了。
2010/3/25 qiaojie <a href="&#109;&#97;&#105;&#x6c;&#x74;&#x6f;&#58;&#x5b;&#113;&#105;&#x61;&#46;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#97;&#105;&#x6c;&#46;&#x63;&#111;&#x6d;&#x5d;&#x28;&#x29;">&#x5b;&#113;&#105;&#x61;&#46;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#97;&#105;&#x6c;&#46;&#x63;&#111;&#x6d;&#x5d;&#x28;&#x29;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>产能过剩和短缺导致的价格波动是市场经济的典型特征，想要消除过剩和短缺那叫计划经济，</p>
<p>学点经济学常识再来讨论这些问题吧。
2010/3/25 机械唯物主义 : linjunhalida <a href="&#x6d;&#x61;&#105;&#108;&#x74;&#x6f;&#58;&#x5b;&#x6c;&#x69;&#x6e;&#x6a;&#117;&#x6e;&#46;&#46;&#46;&#x40;&#x67;&#109;&#x61;&#x69;&#x6c;&#46;&#99;&#x6f;&#109;&#93;&#40;&#x29;">&#x5b;&#x6c;&#x69;&#x6e;&#x6a;&#117;&#x6e;&#46;&#46;&#46;&#x40;&#x67;&#109;&#x61;&#x69;&#x6c;&#46;&#99;&#x6f;&#109;&#93;&#40;&#x29;</a>
本来就不该生产那么多的粮食，多余的人力和土地可以用来做别的事情。
问题在于为什么他们估算错误？</p>
<p>2010/3/25 qiaojie <a href="&#x6d;&#x61;&#105;&#x6c;&#116;&#111;&#x3a;&#91;&#x71;&#x69;&#x61;&#x2e;&#46;&#46;&#64;&#x67;&#109;&#97;&#x69;&#108;&#x2e;&#99;&#111;&#109;&#x5d;&#x28;&#x29;">&#91;&#x71;&#x69;&#x61;&#x2e;&#46;&#46;&#64;&#x67;&#109;&#97;&#x69;&#108;&#x2e;&#99;&#111;&#109;&#x5d;&#x28;&#x29;</a>
什么叫产能过剩？假设全世界每年消费10000亿斤粮食，结果今年收成好，生产了15000亿斤，</p>
<p>那多出来的5000亿斤无法被市场消化掉，就是产能过剩。那5000亿斤没价值，是垃圾？生产那
5000亿斤的农民是闲的蛋疼没事干？靠政府失业金养？</p>
<p>2010/3/25 机械唯物主义 : linjunhalida <a href="&#x6d;&#x61;&#105;&#108;&#x74;&#111;&#x3a;&#91;&#x6c;&#105;&#110;&#x6a;&#117;&#110;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#109;&#x61;&#x69;&#x6c;&#46;&#x63;&#111;&#x6d;&#x5d;&#40;&#x29;">&#91;&#x6c;&#105;&#110;&#x6a;&#117;&#110;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#109;&#x61;&#x69;&#x6c;&#46;&#x63;&#111;&#x6d;&#x5d;&#40;&#x29;</a>
产能过剩的说法本来就不对。
产出的东西没有价值，这样的活动就不能说是生产。
比如我这个程序员，花了1周写了一个垃圾程序，然后被开除了。
然后1个月闲着，这是我产能过剩吗？
而闲着的原因是政府给我失业金，我就不需要工作闲起来了。。。</p>
<p>2010/3/25 qiaojie <a href="&#109;&#x61;&#x69;&#x6c;&#x74;&#x6f;&#58;&#91;&#x71;&#x69;&#97;&#46;&#x2e;&#x2e;&#x40;&#103;&#109;&#97;&#105;&#x6c;&#46;&#x63;&#111;&#109;&#x5d;&#x28;&#41;">&#91;&#x71;&#x69;&#97;&#46;&#x2e;&#x2e;&#x40;&#103;&#109;&#97;&#105;&#x6c;&#46;&#x63;&#111;&#109;&#x5d;&#x28;&#41;</a>
如果产能=消费的话就没有产能过剩这一说了。</p>
<p>2010/3/25 机械唯物主义 : linjunhalida <a href="&#x6d;&#97;&#105;&#108;&#x74;&#111;&#x3a;&#x5b;&#108;&#105;&#110;&#x6a;&#x75;&#110;&#x2e;&#46;&#x2e;&#64;&#103;&#109;&#x61;&#x69;&#x6c;&#46;&#x63;&#111;&#x6d;&#x5d;&#x28;&#x29;">&#x5b;&#108;&#105;&#110;&#x6a;&#x75;&#110;&#x2e;&#46;&#x2e;&#64;&#103;&#109;&#x61;&#x69;&#x6c;&#46;&#x63;&#111;&#x6d;&#x5d;&#x28;&#x29;</a></p>
<p>一个谬误：刺激需求
产能=消费，产能才是主动力。技术成长是随着产能成长而起来的。
而产能多的结果就是满足了需求，造成一种需求带来技术进步的假像。
而技术和产能之间的关系又错综复杂。。
2010/3/25 qiaojie <a href="&#x6d;&#97;&#105;&#108;&#116;&#111;&#x3a;&#91;&#113;&#105;&#x61;&#46;&#x2e;&#x2e;&#64;&#x67;&#109;&#97;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#40;&#41;">&#91;&#113;&#105;&#x61;&#46;&#x2e;&#x2e;&#64;&#x67;&#109;&#97;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#40;&#41;</a></p>
<p>3D游戏就是一类杀手应用，由此支撑起了一个庞大的GPU市场，芯片行业的研发成本是很高的，没有一个庞大的市场是做不起来的。目前的消费者对于多核系统显然还没有强烈的需求，因为应用跟不上，i7发布快2年了还没进入主流市场，这种情况延续下去的话摩尔定律将因此失效。不过我相信杀手级应用总会出现的，这可能要硬件性能突破一个临界点，比方说目前GPU的性能再提升一个数量级的话，光线跟踪算法就可以提供流畅的接近CG的画质，倒是此类应用便会流行开来。</p>
<p>2010/3/25 Guancheng Chen <a href="&#x6d;&#x61;&#x69;&#x6c;&#116;&#x6f;&#x3a;&#x5b;&#99;&#104;&#x65;&#x6e;&#103;&#117;&#46;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#111;&#109;&#93;&#40;&#41;">&#x5b;&#99;&#104;&#x65;&#x6e;&#103;&#117;&#46;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#111;&#109;&#93;&#40;&#41;</a></p>
<p>杀手应用一般来说是指什么样的应用呢？比如用户群特别大的网游？还是那些专有的科学计算用的软件？
On 3月24日, 下午12时36分, qiaojie <a href="&#x6d;&#x61;&#x69;&#108;&#116;&#111;&#58;&#91;&#113;&#105;&#97;&#111;&#46;&#x2e;&#46;&#64;&#103;&#109;&#97;&#x69;&#x6c;&#46;&#x63;&#111;&#x6d;&#x5d;&#40;&#41;">&#91;&#113;&#105;&#97;&#111;&#46;&#x2e;&#46;&#64;&#103;&#109;&#97;&#x69;&#x6c;&#46;&#x63;&#111;&#x6d;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>并行计算本来就是曲高和寡的东西，就跟3D渲染一样，能开发引擎的毕竟只是小部分人，大多数人在引擎的基础上做应用。关键在于是否有杀手应用，只要有大量的需求 ，自然会有人去做开发。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#109;&#x61;&#x69;&#x6c;&#116;&#111;&#x3a;&#91;&#x68;&#x6f;&#110;&#x67;&#x7a;&#104;&#x61;&#110;&#x67;&#46;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#97;&#x69;&#108;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#40;&#41;">&#91;&#x68;&#x6f;&#110;&#x67;&#x7a;&#104;&#x61;&#110;&#x67;&#46;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#97;&#x69;&#108;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#40;&#41;</a></p>
<blockquote>
<p>异构平台从网络处理器算起已经快10年了，现在情况仍然不明朗。就我看到的，异构平台要想高效，就必须向程序员暴露非常多的硬件细节，这必然导致编程的复杂性。 曲高和寡，要想渗透到应用程序这一块，我觉得很难。</p>
<p>2010/3/24 qiaojie <a href="&#109;&#97;&#105;&#108;&#x74;&#111;&#58;&#91;&#x71;&#x69;&#x61;&#111;&#46;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#97;&#105;&#108;&#x2e;&#x63;&#111;&#x6d;&#93;&#40;&#41;">&#91;&#x71;&#x69;&#x61;&#111;&#46;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#97;&#105;&#108;&#x2e;&#x63;&#111;&#x6d;&#93;&#40;&#41;</a></p>
<blockquote>
<p>说的没错，cell已经成了先烈了。不过这不代表异构的方向不对，CUDA，OpenCL也都是异构平台，以后我们会越来越习惯异构平台的。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#x6f;&#x3a;&#x5b;&#104;&#111;&#x6e;&#x67;&#122;&#x68;&#x61;&#x6e;&#x67;&#46;&#x2e;&#46;&#46;&#64;&#x67;&#x6d;&#x61;&#105;&#108;&#46;&#99;&#x6f;&#109;&#93;&#x28;&#41;">&#x5b;&#104;&#111;&#x6e;&#x67;&#122;&#x68;&#x61;&#x6e;&#x67;&#46;&#x2e;&#46;&#46;&#64;&#x67;&#x6d;&#x61;&#105;&#108;&#46;&#99;&#x6f;&#109;&#93;&#x28;&#41;</a></p>
<p>异构平台如果编程复杂度降不下来的话很难流行起来。cell已经死了...</p>
<blockquote>
<p> 2010/3/24 qiaojie <a href="&#109;&#97;&#x69;&#108;&#116;&#111;&#58;&#91;&#113;&#x69;&#97;&#111;&#46;&#x2e;&#46;&#64;&#x67;&#x6d;&#x61;&#105;&#108;&#x2e;&#x63;&#x6f;&#109;&#93;&#40;&#41;">&#91;&#113;&#x69;&#97;&#111;&#46;&#x2e;&#46;&#64;&#x67;&#x6d;&#x61;&#105;&#108;&#x2e;&#x63;&#x6f;&#109;&#93;&#40;&#41;</a></p>
<blockquote>
<p>不是所有的程序都需要并行化的，能用串行化解决的问题没必要并行，所以即使将来many-core系统成为主流，大部分程序员也没必要去搞并行计算。
  我觉得未来的主流应该是类似cell这样一颗全功能核心带众多协处理核心的异构系统，这样才能达到最优的 性能/核心面积比。</p>
<p>2010/3/24 Guancheng Chen <a href="&#109;&#x61;&#105;&#x6c;&#116;&#111;&#58;&#x5b;&#99;&#x68;&#x65;&#110;&#103;&#117;&#97;&#x6e;&#99;&#x68;&#46;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#x61;&#x69;&#x6c;&#46;&#99;&#111;&#x6d;&#x5d;&#x28;&#x29;">&#x5b;&#99;&#x68;&#x65;&#110;&#103;&#117;&#97;&#x6e;&#99;&#x68;&#46;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#x61;&#x69;&#x6c;&#46;&#99;&#111;&#x6d;&#x5d;&#x28;&#x29;</a></p>
<p>Nice 大胆预测Linear speedup应该是每个程序员十年后的目标 呵呵</p>
<blockquote>
<p>On 3月23日, 上午10时43分, qiaojie <a href="&#x6d;&#97;&#105;&#x6c;&#116;&#111;&#58;&#91;&#113;&#105;&#x61;&#x6f;&#46;&#46;&#46;&#x40;&#x67;&#109;&#97;&#x69;&#108;&#x2e;&#x63;&#111;&#x6d;&#93;&#x28;&#x29;">&#91;&#113;&#105;&#x61;&#x6f;&#46;&#46;&#46;&#x40;&#x67;&#109;&#97;&#x69;&#108;&#x2e;&#x63;&#111;&#x6d;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>目前正在写的是一个软件渲染器，采用了光栅化和光线跟踪混合算法，渲染算法已经完全并行化了，
在4核系统上基本可以达到线性加速比，更多核的系统暂时还没测试。kd-tree的构造暂时还没有并
行化，以后有空了再研究。</p>
<p>2010/3/23 Guancheng Chen <a href="&#x6d;&#x61;&#x69;&#108;&#x74;&#x6f;&#x3a;&#x5b;&#99;&#x68;&#101;&#110;&#x67;&#x75;&#x61;&#110;&#99;&#104;&#46;&#46;&#x2e;&#x40;&#103;&#109;&#97;&#105;&#108;&#x2e;&#99;&#111;&#x6d;&#93;&#40;&#41;">&#x5b;&#99;&#x68;&#101;&#110;&#x67;&#x75;&#x61;&#110;&#99;&#104;&#46;&#46;&#x2e;&#x40;&#103;&#109;&#97;&#105;&#108;&#x2e;&#99;&#111;&#x6d;&#93;&#40;&#41;</a></p>
<blockquote>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？</p>
<p>On 3月23日, 上午9时15分, qiaojie <a href="&#x6d;&#x61;&#x69;&#108;&#x74;&#111;&#x3a;&#x5b;&#x71;&#105;&#97;&#111;&#x2e;&#46;&#46;&#64;&#103;&#109;&#97;&#x69;&#108;&#x2e;&#99;&#111;&#x6d;&#x5d;&#40;&#41;">&#x5b;&#x71;&#105;&#97;&#111;&#x2e;&#46;&#46;&#64;&#103;&#109;&#97;&#x69;&#108;&#x2e;&#99;&#111;&#x6d;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1)
=
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank
Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？</p>
</blockquote>
<p> To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a></p>
<p><img src="" alt=""> qiaojie <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-25</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>恩，很快会被升华成为政治问题
2010/3/25 郝培强 tinyfool <a href="&#109;&#x61;&#105;&#108;&#x74;&#x6f;&#58;&#x5b;&#116;&#x69;&#110;&#121;&#46;&#x2e;&#x2e;&#64;&#103;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#111;&#109;&#x5d;&#x28;&#x29;">&#x5b;&#116;&#x69;&#110;&#121;&#46;&#x2e;&#x2e;&#64;&#103;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#111;&#109;&#x5d;&#x28;&#x29;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>哈哈，终于从技术聊到经济了</p>
<p>在 2010-3-25，下午2:11， qiaojie 写道：</p>
<p>什么叫产能过剩？假设全世界每年消费10000亿斤粮食，结果今年收成好，生产了15000亿斤，</p>
<p>那多出来的5000亿斤无法被市场消化掉，就是产能过剩。那5000亿斤没价值，是垃圾？生产那
5000亿斤的农民是闲的蛋疼没事干？靠政府失业金养？</p>
<p>2010/3/25 机械唯物主义 : linjunhalida <a href="&#109;&#x61;&#x69;&#108;&#x74;&#x6f;&#x3a;&#x5b;&#x6c;&#x69;&#x6e;&#x6a;&#117;&#110;&#46;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#x61;&#x69;&#108;&#46;&#x63;&#111;&#109;&#x5d;&#40;&#x29;">&#x5b;&#x6c;&#x69;&#x6e;&#x6a;&#117;&#110;&#46;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#x61;&#x69;&#108;&#46;&#x63;&#111;&#109;&#x5d;&#40;&#x29;</a>
产能过剩的说法本来就不对。
产出的东西没有价值，这样的活动就不能说是生产。
比如我这个程序员，花了1周写了一个垃圾程序，然后被开除了。
然后1个月闲着，这是我产能过剩吗？
而闲着的原因是政府给我失业金，我就不需要工作闲起来了。。。</p>
<p>2010/3/25 qiaojie <a href="&#x6d;&#x61;&#105;&#x6c;&#116;&#x6f;&#58;&#x5b;&#113;&#105;&#x61;&#46;&#x2e;&#x2e;&#x40;&#x67;&#109;&#x61;&#x69;&#x6c;&#46;&#99;&#x6f;&#x6d;&#x5d;&#40;&#x29;">&#x5b;&#113;&#105;&#x61;&#46;&#x2e;&#x2e;&#x40;&#x67;&#109;&#x61;&#x69;&#x6c;&#46;&#99;&#x6f;&#x6d;&#x5d;&#40;&#x29;</a>
如果产能=消费的话就没有产能过剩这一说了。</p>
<p>2010/3/25 机械唯物主义 : linjunhalida <a href="&#x6d;&#97;&#105;&#x6c;&#x74;&#111;&#58;&#x5b;&#x6c;&#105;&#x6e;&#x6a;&#117;&#x6e;&#x2e;&#46;&#x2e;&#x40;&#x67;&#109;&#97;&#x69;&#x6c;&#46;&#99;&#x6f;&#x6d;&#93;&#x28;&#x29;">&#x5b;&#x6c;&#105;&#x6e;&#x6a;&#117;&#x6e;&#x2e;&#46;&#x2e;&#x40;&#x67;&#109;&#97;&#x69;&#x6c;&#46;&#99;&#x6f;&#x6d;&#93;&#x28;&#x29;</a></p>
<p>一个谬误：刺激需求
产能=消费，产能才是主动力。技术成长是随着产能成长而起来的。
而产能多的结果就是满足了需求，造成一种需求带来技术进步的假像。
而技术和产能之间的关系又错综复杂。。
2010/3/25 qiaojie <a href="&#x6d;&#x61;&#105;&#108;&#116;&#x6f;&#58;&#91;&#x71;&#x69;&#x61;&#46;&#x2e;&#46;&#64;&#103;&#x6d;&#97;&#105;&#x6c;&#x2e;&#x63;&#111;&#109;&#93;&#x28;&#x29;">&#91;&#x71;&#x69;&#x61;&#46;&#x2e;&#46;&#64;&#103;&#x6d;&#97;&#105;&#x6c;&#x2e;&#x63;&#111;&#109;&#93;&#x28;&#x29;</a></p>
<p>3D游戏就是一类杀手应用，由此支撑起了一个庞大的GPU市场，芯片行业的研发成本是很高的，没有一个庞大的市场是做不起来的。目前的消费者对于多核系统显然还没有强烈的需求，因为应用跟不上，i7发布快2年了还没进入主流市场，这种情况延续下去的话摩尔定律将因此失效。不过我相信杀手级应用总会出现的，这可能要硬件性能突破一个临界点，比方说目前GPU的性能再提升一个数量级的话，光线跟踪算法就可以提供流畅的接近CG的画质，倒是此类应用便会流行开来。</p>
<p>2010/3/25 Guancheng Chen <a href="&#109;&#x61;&#105;&#108;&#x74;&#111;&#x3a;&#91;&#99;&#104;&#101;&#110;&#103;&#x75;&#x2e;&#x2e;&#46;&#x40;&#103;&#109;&#97;&#105;&#x6c;&#46;&#99;&#x6f;&#x6d;&#93;&#x28;&#41;">&#91;&#99;&#104;&#101;&#110;&#103;&#x75;&#x2e;&#x2e;&#46;&#x40;&#103;&#109;&#97;&#105;&#x6c;&#46;&#99;&#x6f;&#x6d;&#93;&#x28;&#41;</a></p>
<p>杀手应用一般来说是指什么样的应用呢？比如用户群特别大的网游？还是那些专有的科学计算用的软件？
On 3月24日, 下午12时36分, qiaojie <a href="&#109;&#x61;&#x69;&#x6c;&#x74;&#111;&#58;&#91;&#113;&#105;&#97;&#x6f;&#46;&#x2e;&#x2e;&#64;&#x67;&#109;&#97;&#105;&#108;&#x2e;&#99;&#111;&#x6d;&#93;&#x28;&#41;">&#91;&#113;&#105;&#97;&#x6f;&#46;&#x2e;&#x2e;&#64;&#x67;&#109;&#97;&#105;&#108;&#x2e;&#99;&#111;&#x6d;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>并行计算本来就是曲高和寡的东西，就跟3D渲染一样，能开发引擎的毕竟只是小部分人，大多数人在引擎的基础上做应用。关键在于是否有杀手应用，只要有大量的需求 ，自然会有人去做开发。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#109;&#x61;&#x69;&#108;&#116;&#x6f;&#58;&#x5b;&#x68;&#111;&#110;&#103;&#x7a;&#x68;&#97;&#110;&#103;&#x2e;&#x2e;&#46;&#46;&#x40;&#103;&#109;&#97;&#105;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#93;&#x28;&#x29;">&#x5b;&#x68;&#111;&#110;&#103;&#x7a;&#x68;&#97;&#110;&#103;&#x2e;&#x2e;&#46;&#46;&#x40;&#103;&#109;&#97;&#105;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#93;&#x28;&#x29;</a></p>
<blockquote>
<p>异构平台从网络处理器算起已经快10年了，现在情况仍然不明朗。就我看到的，异构平台要想高效，就必须向程序员暴露非常多的硬件细节，这必然导致编程的复杂性。 曲高和寡，要想渗透到应用程序这一块，我觉得很难。</p>
<p>2010/3/24 qiaojie <a href="&#109;&#97;&#x69;&#108;&#x74;&#x6f;&#58;&#91;&#x71;&#x69;&#97;&#x6f;&#46;&#x2e;&#46;&#64;&#x67;&#109;&#x61;&#105;&#x6c;&#46;&#99;&#111;&#109;&#93;&#x28;&#41;">&#91;&#x71;&#x69;&#97;&#x6f;&#46;&#x2e;&#46;&#64;&#x67;&#109;&#x61;&#105;&#x6c;&#46;&#99;&#111;&#109;&#93;&#x28;&#41;</a></p>
<blockquote>
<p>说的没错，cell已经成了先烈了。不过这不代表异构的方向不对，CUDA，OpenCL也都是异构平台，以后我们会越来越习惯异构平台的。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#111;&#x3a;&#x5b;&#104;&#x6f;&#110;&#x67;&#x7a;&#104;&#x61;&#110;&#x67;&#46;&#x2e;&#46;&#46;&#64;&#103;&#109;&#97;&#x69;&#108;&#46;&#99;&#x6f;&#x6d;&#93;&#x28;&#41;">&#x5b;&#104;&#x6f;&#110;&#x67;&#x7a;&#104;&#x61;&#110;&#x67;&#46;&#x2e;&#46;&#46;&#64;&#103;&#109;&#97;&#x69;&#108;&#46;&#99;&#x6f;&#x6d;&#93;&#x28;&#41;</a></p>
<p>异构平台如果编程复杂度降不下来的话很难流行起来。cell已经死了...</p>
<blockquote>
<p> 2010/3/24 qiaojie <a href="&#x6d;&#97;&#105;&#108;&#116;&#x6f;&#x3a;&#91;&#113;&#x69;&#x61;&#x6f;&#x2e;&#46;&#46;&#x40;&#x67;&#x6d;&#x61;&#105;&#108;&#46;&#x63;&#x6f;&#109;&#93;&#40;&#41;">&#91;&#113;&#x69;&#x61;&#x6f;&#x2e;&#46;&#46;&#x40;&#x67;&#x6d;&#x61;&#105;&#108;&#46;&#x63;&#x6f;&#109;&#93;&#40;&#41;</a></p>
<blockquote>
<p>不是所有的程序都需要并行化的，能用串行化解决的问题没必要并行，所以即使将来many-core系统成为主流，大部分程序员也没必要去搞并行计算。
  我觉得未来的主流应该是类似cell这样一颗全功能核心带众多协处理核心的异构系统，这样才能达到最优的 性能/核心面积比。</p>
<p>2010/3/24 Guancheng Chen <a href="&#x6d;&#x61;&#x69;&#x6c;&#116;&#111;&#58;&#91;&#99;&#104;&#101;&#x6e;&#103;&#117;&#97;&#x6e;&#99;&#x68;&#46;&#x2e;&#46;&#64;&#103;&#x6d;&#97;&#x69;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#93;&#40;&#x29;">&#91;&#99;&#104;&#101;&#x6e;&#103;&#117;&#97;&#x6e;&#99;&#x68;&#46;&#x2e;&#46;&#64;&#103;&#x6d;&#97;&#x69;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#93;&#40;&#x29;</a></p>
<p>Nice 大胆预测Linear speedup应该是每个程序员十年后的目标 呵呵</p>
<blockquote>
<p>On 3月23日, 上午10时43分, qiaojie <a href="&#109;&#97;&#x69;&#x6c;&#x74;&#111;&#58;&#91;&#x71;&#x69;&#97;&#x6f;&#46;&#x2e;&#46;&#x40;&#103;&#109;&#x61;&#105;&#x6c;&#x2e;&#x63;&#111;&#109;&#x5d;&#x28;&#41;">&#91;&#x71;&#x69;&#97;&#x6f;&#46;&#x2e;&#46;&#x40;&#103;&#109;&#x61;&#105;&#x6c;&#x2e;&#x63;&#111;&#109;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>目前正在写的是一个软件渲染器，采用了光栅化和光线跟踪混合算法，渲染算法已经完全并行化了，
在4核系统上基本可以达到线性加速比，更多核的系统暂时还没测试。kd-tree的构造暂时还没有并
行化，以后有空了再研究。</p>
<p>2010/3/23 Guancheng Chen <a href="&#x6d;&#97;&#x69;&#x6c;&#x74;&#x6f;&#58;&#x5b;&#99;&#x68;&#x65;&#x6e;&#x67;&#x75;&#97;&#110;&#x63;&#x68;&#x2e;&#x2e;&#46;&#x40;&#103;&#109;&#97;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#41;">&#x5b;&#99;&#x68;&#x65;&#x6e;&#x67;&#x75;&#97;&#110;&#x63;&#x68;&#x2e;&#x2e;&#46;&#x40;&#103;&#109;&#97;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#41;</a></p>
<blockquote>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？</p>
<p>On 3月23日, 上午9时15分, qiaojie <a href="&#x6d;&#97;&#105;&#x6c;&#x74;&#111;&#x3a;&#x5b;&#x71;&#x69;&#97;&#x6f;&#46;&#46;&#46;&#x40;&#x67;&#109;&#x61;&#x69;&#108;&#x2e;&#99;&#111;&#x6d;&#x5d;&#40;&#41;">&#x5b;&#x71;&#x69;&#97;&#x6f;&#46;&#46;&#46;&#x40;&#x67;&#109;&#x61;&#x69;&#108;&#x2e;&#99;&#111;&#x6d;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1)
=
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank
Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？</p>
</blockquote>
<p> To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> tinyfool <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-25</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>哈哈，二位都平和一点，咱们继续回到技术讨论的主线吧</p>
<p>在 2010-3-25，下午2:40， qiaojie 写道：</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>恩，很快会被升华成为政治问题
2010/3/25 郝培强 tinyfool <a href="&#109;&#x61;&#x69;&#x6c;&#116;&#x6f;&#x3a;&#91;&#116;&#105;&#x6e;&#x79;&#46;&#46;&#x2e;&#64;&#103;&#x6d;&#97;&#x69;&#108;&#x2e;&#x63;&#111;&#109;&#93;&#x28;&#41;">&#91;&#116;&#105;&#x6e;&#x79;&#46;&#46;&#x2e;&#64;&#103;&#x6d;&#97;&#x69;&#108;&#x2e;&#x63;&#111;&#109;&#93;&#x28;&#41;</a>
哈哈，终于从技术聊到经济了</p>
<p>在 2010-3-25，下午2:11， qiaojie 写道：</p>
<p>什么叫产能过剩？假设全世界每年消费10000亿斤粮食，结果今年收成好，生产了15000亿斤，</p>
<p>那多出来的5000亿斤无法被市场消化掉，就是产能过剩。那5000亿斤没价值，是垃圾？生产那
5000亿斤的农民是闲的蛋疼没事干？靠政府失业金养？</p>
<p>2010/3/25 机械唯物主义 : linjunhalida <a href="&#109;&#x61;&#105;&#108;&#x74;&#111;&#58;&#91;&#108;&#x69;&#x6e;&#106;&#117;&#x6e;&#46;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#97;&#x69;&#108;&#46;&#x63;&#111;&#x6d;&#93;&#x28;&#41;">&#91;&#108;&#x69;&#x6e;&#106;&#117;&#x6e;&#46;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#97;&#x69;&#108;&#46;&#x63;&#111;&#x6d;&#93;&#x28;&#41;</a>
产能过剩的说法本来就不对。
产出的东西没有价值，这样的活动就不能说是生产。
比如我这个程序员，花了1周写了一个垃圾程序，然后被开除了。
然后1个月闲着，这是我产能过剩吗？
而闲着的原因是政府给我失业金，我就不需要工作闲起来了。。。</p>
<p>2010/3/25 qiaojie <a href="&#x6d;&#x61;&#x69;&#108;&#x74;&#111;&#58;&#91;&#113;&#x69;&#97;&#46;&#x2e;&#46;&#64;&#103;&#x6d;&#x61;&#105;&#x6c;&#46;&#99;&#111;&#109;&#x5d;&#40;&#x29;">&#91;&#113;&#x69;&#97;&#46;&#x2e;&#46;&#64;&#103;&#x6d;&#x61;&#105;&#x6c;&#46;&#99;&#111;&#109;&#x5d;&#40;&#x29;</a>
如果产能=消费的话就没有产能过剩这一说了。</p>
<p>2010/3/25 机械唯物主义 : linjunhalida <a href="&#x6d;&#x61;&#x69;&#108;&#x74;&#111;&#58;&#91;&#x6c;&#105;&#x6e;&#x6a;&#117;&#x6e;&#46;&#46;&#x2e;&#64;&#103;&#109;&#97;&#x69;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#x29;">&#91;&#x6c;&#105;&#x6e;&#x6a;&#117;&#x6e;&#46;&#46;&#x2e;&#64;&#103;&#109;&#97;&#x69;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#x29;</a></p>
<p>一个谬误：刺激需求
产能=消费，产能才是主动力。技术成长是随着产能成长而起来的。
而产能多的结果就是满足了需求，造成一种需求带来技术进步的假像。
而技术和产能之间的关系又错综复杂。。
2010/3/25 qiaojie <a href="&#x6d;&#97;&#x69;&#108;&#116;&#111;&#x3a;&#x5b;&#113;&#x69;&#97;&#x2e;&#46;&#46;&#64;&#x67;&#x6d;&#97;&#x69;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#41;">&#x5b;&#113;&#x69;&#97;&#x2e;&#46;&#46;&#64;&#x67;&#x6d;&#97;&#x69;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#41;</a></p>
<p>3D游戏就是一类杀手应用，由此支撑起了一个庞大的GPU市场，芯片行业的研发成本是很高的，没有一个庞大的市场是做不起来的。目前的消费者对于多核系统显然还没有强烈的需求，因为应用跟不上，i7发布快2年了还没进入主流市场，这种情况延续下去的话摩尔定律将因此失效。不过我相信杀手级应用总会出现的，这可能要硬件性能突破一个临界点，比方说目前GPU的性能再提升一个数量级的话，光线跟踪算法就可以提供流畅的接近CG的画质，倒是此类应用便会流行开来。</p>
<p>2010/3/25 Guancheng Chen <a href="&#109;&#x61;&#x69;&#108;&#x74;&#111;&#58;&#91;&#99;&#x68;&#101;&#110;&#103;&#117;&#x2e;&#46;&#46;&#x40;&#103;&#109;&#97;&#105;&#108;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#40;&#41;">&#91;&#99;&#x68;&#101;&#110;&#103;&#117;&#x2e;&#46;&#46;&#x40;&#103;&#109;&#97;&#105;&#108;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#40;&#41;</a></p>
<p>杀手应用一般来说是指什么样的应用呢？比如用户群特别大的网游？还是那些专有的科学计算用的软件？
On 3月24日, 下午12时36分, qiaojie <a href="&#x6d;&#97;&#105;&#108;&#116;&#111;&#x3a;&#91;&#113;&#105;&#x61;&#x6f;&#46;&#x2e;&#x2e;&#64;&#103;&#x6d;&#x61;&#x69;&#x6c;&#46;&#x63;&#111;&#x6d;&#x5d;&#x28;&#41;">&#91;&#113;&#105;&#x61;&#x6f;&#46;&#x2e;&#x2e;&#64;&#103;&#x6d;&#x61;&#x69;&#x6c;&#46;&#x63;&#111;&#x6d;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>并行计算本来就是曲高和寡的东西，就跟3D渲染一样，能开发引擎的毕竟只是小部分人，大多数人在引擎的基础上做应用。关键在于是否有杀手应用，只要有大量的需求 ，自然会有人去做开发。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#x6d;&#x61;&#x69;&#x6c;&#116;&#111;&#58;&#91;&#104;&#x6f;&#110;&#103;&#x7a;&#x68;&#x61;&#110;&#103;&#46;&#46;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#40;&#x29;">&#91;&#104;&#x6f;&#110;&#103;&#x7a;&#x68;&#x61;&#110;&#103;&#46;&#46;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#40;&#x29;</a></p>
<blockquote>
<p>异构平台从网络处理器算起已经快10年了，现在情况仍然不明朗。就我看到的，异构平台要想高效，就必须向程序员暴露非常多的硬件细节，这必然导致编程的复杂性。 曲高和寡，要想渗透到应用程序这一块，我觉得很难。</p>
<p>2010/3/24 qiaojie <a href="&#x6d;&#x61;&#x69;&#108;&#x74;&#111;&#58;&#91;&#x71;&#x69;&#x61;&#x6f;&#x2e;&#x2e;&#46;&#64;&#103;&#x6d;&#x61;&#x69;&#108;&#46;&#99;&#x6f;&#x6d;&#93;&#x28;&#41;">&#91;&#x71;&#x69;&#x61;&#x6f;&#x2e;&#x2e;&#46;&#64;&#103;&#x6d;&#x61;&#x69;&#108;&#46;&#99;&#x6f;&#x6d;&#93;&#x28;&#41;</a></p>
<blockquote>
<p>说的没错，cell已经成了先烈了。不过这不代表异构的方向不对，CUDA，OpenCL也都是异构平台，以后我们会越来越习惯异构平台的。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#109;&#x61;&#105;&#108;&#x74;&#x6f;&#x3a;&#91;&#104;&#x6f;&#110;&#103;&#x7a;&#x68;&#97;&#110;&#x67;&#x2e;&#x2e;&#x2e;&#46;&#64;&#x67;&#109;&#97;&#x69;&#x6c;&#x2e;&#99;&#111;&#109;&#x5d;&#40;&#41;">&#91;&#104;&#x6f;&#110;&#103;&#x7a;&#x68;&#97;&#110;&#x67;&#x2e;&#x2e;&#x2e;&#46;&#64;&#x67;&#109;&#97;&#x69;&#x6c;&#x2e;&#99;&#111;&#109;&#x5d;&#40;&#41;</a></p>
<p>异构平台如果编程复杂度降不下来的话很难流行起来。cell已经死了...</p>
<blockquote>
<p> 2010/3/24 qiaojie <a href="&#109;&#97;&#x69;&#108;&#116;&#111;&#x3a;&#91;&#x71;&#x69;&#97;&#111;&#46;&#46;&#46;&#x40;&#x67;&#x6d;&#97;&#x69;&#108;&#46;&#x63;&#x6f;&#109;&#x5d;&#x28;&#x29;">&#91;&#x71;&#x69;&#97;&#111;&#46;&#46;&#46;&#x40;&#x67;&#x6d;&#97;&#x69;&#108;&#46;&#x63;&#x6f;&#109;&#x5d;&#x28;&#x29;</a></p>
<blockquote>
<p>不是所有的程序都需要并行化的，能用串行化解决的问题没必要并行，所以即使将来many-core系统成为主流，大部分程序员也没必要去搞并行计算。
  我觉得未来的主流应该是类似cell这样一颗全功能核心带众多协处理核心的异构系统，这样才能达到最优的 性能/核心面积比。</p>
<p>2010/3/24 Guancheng Chen <a href="&#x6d;&#97;&#105;&#x6c;&#116;&#x6f;&#x3a;&#x5b;&#99;&#x68;&#101;&#x6e;&#103;&#x75;&#x61;&#110;&#x63;&#104;&#x2e;&#x2e;&#46;&#64;&#103;&#109;&#x61;&#105;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#40;&#41;">&#x5b;&#99;&#x68;&#101;&#x6e;&#103;&#x75;&#x61;&#110;&#x63;&#104;&#x2e;&#x2e;&#46;&#64;&#103;&#109;&#x61;&#105;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#40;&#41;</a></p>
<p>Nice 大胆预测Linear speedup应该是每个程序员十年后的目标 呵呵</p>
<blockquote>
<p>On 3月23日, 上午10时43分, qiaojie <a href="&#x6d;&#x61;&#105;&#108;&#x74;&#111;&#x3a;&#x5b;&#x71;&#105;&#x61;&#111;&#x2e;&#46;&#46;&#64;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#99;&#111;&#109;&#93;&#x28;&#x29;">&#x5b;&#x71;&#105;&#x61;&#111;&#x2e;&#46;&#46;&#64;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#99;&#111;&#109;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>目前正在写的是一个软件渲染器，采用了光栅化和光线跟踪混合算法，渲染算法已经完全并行化了，
在4核系统上基本可以达到线性加速比，更多核的系统暂时还没测试。kd-tree的构造暂时还没有并
行化，以后有空了再研究。</p>
<p>2010/3/23 Guancheng Chen <a href="&#x6d;&#97;&#105;&#108;&#116;&#x6f;&#x3a;&#x5b;&#99;&#104;&#x65;&#110;&#x67;&#117;&#x61;&#x6e;&#99;&#104;&#x2e;&#x2e;&#46;&#64;&#x67;&#109;&#97;&#x69;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#40;&#41;">&#x5b;&#99;&#104;&#x65;&#110;&#x67;&#117;&#x61;&#x6e;&#99;&#104;&#x2e;&#x2e;&#46;&#64;&#x67;&#109;&#97;&#x69;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#40;&#41;</a></p>
<blockquote>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？</p>
<p>On 3月23日, 上午9时15分, qiaojie <a href="&#109;&#x61;&#105;&#x6c;&#x74;&#111;&#58;&#x5b;&#113;&#105;&#97;&#x6f;&#x2e;&#46;&#x2e;&#64;&#103;&#109;&#x61;&#x69;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#41;">&#x5b;&#113;&#105;&#97;&#x6f;&#x2e;&#46;&#x2e;&#64;&#103;&#109;&#x61;&#x69;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1)
=
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank
Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？</p>
</blockquote>
<p> To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a></p>
<p><img src="" alt=""> 机械唯物主义 : linjunhalida <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-25</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>恩，离题远了。不再讨论经济。</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>2010/3/25 郝培强 tinyfool <a href="&#x6d;&#97;&#x69;&#x6c;&#x74;&#111;&#58;&#91;&#116;&#x69;&#110;&#x79;&#46;&#x2e;&#46;&#64;&#x67;&#109;&#x61;&#x69;&#108;&#x2e;&#99;&#x6f;&#109;&#93;&#40;&#41;">&#91;&#116;&#x69;&#110;&#x79;&#46;&#x2e;&#46;&#64;&#x67;&#109;&#x61;&#x69;&#108;&#x2e;&#99;&#x6f;&#109;&#93;&#40;&#41;</a>
哈哈，二位都平和一点，咱们继续回到技术讨论的主线吧</p>
<p>在 2010-3-25，下午2:40， qiaojie 写道：</p>
<p>恩，很快会被升华成为政治问题
2010/3/25 郝培强 tinyfool <a href="&#x6d;&#97;&#105;&#x6c;&#116;&#x6f;&#x3a;&#91;&#116;&#x69;&#x6e;&#x79;&#x2e;&#x2e;&#46;&#64;&#103;&#109;&#97;&#x69;&#108;&#46;&#x63;&#111;&#x6d;&#x5d;&#x28;&#41;">&#91;&#116;&#x69;&#x6e;&#x79;&#x2e;&#x2e;&#46;&#64;&#103;&#109;&#97;&#x69;&#108;&#46;&#x63;&#111;&#x6d;&#x5d;&#x28;&#41;</a>
哈哈，终于从技术聊到经济了</p>
<p>在 2010-3-25，下午2:11， qiaojie 写道：</p>
<p>什么叫产能过剩？假设全世界每年消费10000亿斤粮食，结果今年收成好，生产了15000亿斤，</p>
<p>那多出来的5000亿斤无法被市场消化掉，就是产能过剩。那5000亿斤没价值，是垃圾？生产那
5000亿斤的农民是闲的蛋疼没事干？靠政府失业金养？</p>
<p>2010/3/25 机械唯物主义 : linjunhalida <a href="&#109;&#97;&#x69;&#x6c;&#116;&#111;&#58;&#x5b;&#108;&#105;&#x6e;&#106;&#117;&#x6e;&#46;&#x2e;&#46;&#64;&#103;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#111;&#109;&#93;&#40;&#x29;">&#x5b;&#108;&#105;&#x6e;&#106;&#117;&#x6e;&#46;&#x2e;&#46;&#64;&#103;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#111;&#109;&#93;&#40;&#x29;</a>
产能过剩的说法本来就不对。
产出的东西没有价值，这样的活动就不能说是生产。
比如我这个程序员，花了1周写了一个垃圾程序，然后被开除了。
然后1个月闲着，这是我产能过剩吗？
而闲着的原因是政府给我失业金，我就不需要工作闲起来了。。。</p>
<p>2010/3/25 qiaojie <a href="&#x6d;&#x61;&#x69;&#x6c;&#116;&#111;&#x3a;&#91;&#113;&#105;&#x61;&#46;&#x2e;&#x2e;&#x40;&#103;&#109;&#97;&#x69;&#108;&#46;&#99;&#111;&#x6d;&#93;&#40;&#41;">&#91;&#113;&#105;&#x61;&#46;&#x2e;&#x2e;&#x40;&#103;&#109;&#97;&#x69;&#108;&#46;&#99;&#111;&#x6d;&#93;&#40;&#41;</a>
如果产能=消费的话就没有产能过剩这一说了。</p>
<p>2010/3/25 机械唯物主义 : linjunhalida <a href="&#x6d;&#x61;&#105;&#108;&#x74;&#x6f;&#58;&#91;&#108;&#105;&#x6e;&#106;&#x75;&#x6e;&#x2e;&#x2e;&#46;&#64;&#x67;&#109;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#x28;&#x29;">&#91;&#108;&#105;&#x6e;&#106;&#x75;&#x6e;&#x2e;&#x2e;&#46;&#64;&#x67;&#109;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#x28;&#x29;</a></p>
<p>一个谬误：刺激需求
产能=消费，产能才是主动力。技术成长是随着产能成长而起来的。
而产能多的结果就是满足了需求，造成一种需求带来技术进步的假像。
而技术和产能之间的关系又错综复杂。。
2010/3/25 qiaojie <a href="&#109;&#97;&#105;&#x6c;&#116;&#x6f;&#58;&#91;&#x71;&#x69;&#x61;&#46;&#46;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#105;&#x6c;&#46;&#99;&#x6f;&#109;&#93;&#x28;&#x29;">&#91;&#x71;&#x69;&#x61;&#46;&#46;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#105;&#x6c;&#46;&#99;&#x6f;&#109;&#93;&#x28;&#x29;</a></p>
<p>3D游戏就是一类杀手应用，由此支撑起了一个庞大的GPU市场，芯片行业的研发成本是很高的，没有一个庞大的市场是做不起来的。目前的消费者对于多核系统显然还没有强烈的需求，因为应用跟不上，i7发布快2年了还没进入主流市场，这种情况延续下去的话摩尔定律将因此失效。不过我相信杀手级应用总会出现的，这可能要硬件性能突破一个临界点，比方说目前GPU的性能再提升一个数量级的话，光线跟踪算法就可以提供流畅的接近CG的画质，倒是此类应用便会流行开来。</p>
<p>2010/3/25 Guancheng Chen <a href="&#109;&#x61;&#x69;&#x6c;&#116;&#111;&#x3a;&#91;&#x63;&#104;&#101;&#110;&#x67;&#117;&#46;&#46;&#46;&#64;&#103;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#99;&#111;&#x6d;&#x5d;&#40;&#41;">&#91;&#x63;&#104;&#101;&#110;&#x67;&#117;&#46;&#46;&#46;&#64;&#103;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#99;&#111;&#x6d;&#x5d;&#40;&#41;</a></p>
<p>杀手应用一般来说是指什么样的应用呢？比如用户群特别大的网游？还是那些专有的科学计算用的软件？
On 3月24日, 下午12时36分, qiaojie <a href="&#x6d;&#97;&#x69;&#x6c;&#116;&#x6f;&#x3a;&#x5b;&#113;&#x69;&#97;&#111;&#46;&#x2e;&#x2e;&#64;&#x67;&#109;&#x61;&#x69;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#x29;">&#x5b;&#113;&#x69;&#97;&#111;&#46;&#x2e;&#x2e;&#64;&#x67;&#109;&#x61;&#x69;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>并行计算本来就是曲高和寡的东西，就跟3D渲染一样，能开发引擎的毕竟只是小部分人，大多数人在引擎的基础上做应用。关键在于是否有杀手应用，只要有大量的需求 ，自然会有人去做开发。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#109;&#x61;&#x69;&#x6c;&#116;&#x6f;&#x3a;&#x5b;&#x68;&#111;&#110;&#x67;&#122;&#104;&#97;&#110;&#x67;&#46;&#46;&#x2e;&#46;&#x40;&#x67;&#109;&#97;&#105;&#x6c;&#x2e;&#99;&#x6f;&#109;&#x5d;&#40;&#x29;">&#x5b;&#x68;&#111;&#110;&#x67;&#122;&#104;&#97;&#110;&#x67;&#46;&#46;&#x2e;&#46;&#x40;&#x67;&#109;&#97;&#105;&#x6c;&#x2e;&#99;&#x6f;&#109;&#x5d;&#40;&#x29;</a></p>
<blockquote>
<p>异构平台从网络处理器算起已经快10年了，现在情况仍然不明朗。就我看到的，异构平台要想高效，就必须向程序员暴露非常多的硬件细节，这必然导致编程的复杂性。 曲高和寡，要想渗透到应用程序这一块，我觉得很难。</p>
<p>2010/3/24 qiaojie <a href="&#x6d;&#97;&#105;&#108;&#116;&#x6f;&#x3a;&#x5b;&#x71;&#x69;&#x61;&#x6f;&#x2e;&#46;&#x2e;&#x40;&#x67;&#109;&#x61;&#x69;&#x6c;&#46;&#99;&#x6f;&#x6d;&#93;&#40;&#41;">&#x5b;&#x71;&#x69;&#x61;&#x6f;&#x2e;&#46;&#x2e;&#x40;&#x67;&#109;&#x61;&#x69;&#x6c;&#46;&#99;&#x6f;&#x6d;&#93;&#40;&#41;</a></p>
<blockquote>
<p>说的没错，cell已经成了先烈了。不过这不代表异构的方向不对，CUDA，OpenCL也都是异构平台，以后我们会越来越习惯异构平台的。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#109;&#x61;&#105;&#x6c;&#x74;&#111;&#58;&#x5b;&#x68;&#111;&#x6e;&#x67;&#122;&#x68;&#x61;&#110;&#x67;&#46;&#46;&#x2e;&#46;&#x40;&#x67;&#109;&#x61;&#105;&#108;&#46;&#99;&#111;&#109;&#93;&#40;&#x29;">&#x5b;&#x68;&#111;&#x6e;&#x67;&#122;&#x68;&#x61;&#110;&#x67;&#46;&#46;&#x2e;&#46;&#x40;&#x67;&#109;&#x61;&#105;&#108;&#46;&#99;&#111;&#109;&#93;&#40;&#x29;</a></p>
<p>异构平台如果编程复杂度降不下来的话很难流行起来。cell已经死了...</p>
<blockquote>
<p> 2010/3/24 qiaojie <a href="&#x6d;&#97;&#x69;&#108;&#116;&#111;&#x3a;&#x5b;&#x71;&#105;&#x61;&#111;&#46;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#105;&#108;&#x2e;&#99;&#111;&#x6d;&#x5d;&#x28;&#x29;">&#x5b;&#x71;&#105;&#x61;&#111;&#46;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#105;&#108;&#x2e;&#99;&#111;&#x6d;&#x5d;&#x28;&#x29;</a></p>
<blockquote>
<p>不是所有的程序都需要并行化的，能用串行化解决的问题没必要并行，所以即使将来many-core系统成为主流，大部分程序员也没必要去搞并行计算。
  我觉得未来的主流应该是类似cell这样一颗全功能核心带众多协处理核心的异构系统，这样才能达到最优的 性能/核心面积比。</p>
<p>2010/3/24 Guancheng Chen <a href="&#109;&#x61;&#105;&#x6c;&#116;&#111;&#x3a;&#91;&#99;&#x68;&#x65;&#x6e;&#x67;&#x75;&#97;&#110;&#99;&#x68;&#x2e;&#46;&#x2e;&#x40;&#103;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#111;&#109;&#x5d;&#40;&#x29;">&#91;&#99;&#x68;&#x65;&#x6e;&#x67;&#x75;&#97;&#110;&#99;&#x68;&#x2e;&#46;&#x2e;&#x40;&#103;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#111;&#109;&#x5d;&#40;&#x29;</a></p>
<p>Nice 大胆预测Linear speedup应该是每个程序员十年后的目标 呵呵</p>
<blockquote>
<p>On 3月23日, 上午10时43分, qiaojie <a href="&#109;&#97;&#x69;&#x6c;&#x74;&#111;&#x3a;&#x5b;&#113;&#x69;&#97;&#111;&#x2e;&#x2e;&#46;&#x40;&#x67;&#109;&#97;&#105;&#x6c;&#x2e;&#99;&#x6f;&#109;&#x5d;&#x28;&#x29;">&#x5b;&#113;&#x69;&#97;&#111;&#x2e;&#x2e;&#46;&#x40;&#x67;&#109;&#97;&#105;&#x6c;&#x2e;&#99;&#x6f;&#109;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>目前正在写的是一个软件渲染器，采用了光栅化和光线跟踪混合算法，渲染算法已经完全并行化了，
在4核系统上基本可以达到线性加速比，更多核的系统暂时还没测试。kd-tree的构造暂时还没有并
行化，以后有空了再研究。</p>
<p>2010/3/23 Guancheng Chen <a href="&#109;&#97;&#105;&#108;&#116;&#x6f;&#x3a;&#91;&#99;&#x68;&#101;&#x6e;&#103;&#117;&#97;&#110;&#x63;&#104;&#x2e;&#x2e;&#46;&#x40;&#103;&#x6d;&#97;&#105;&#108;&#46;&#99;&#111;&#109;&#x5d;&#40;&#x29;">&#91;&#99;&#x68;&#101;&#x6e;&#103;&#117;&#97;&#110;&#x63;&#104;&#x2e;&#x2e;&#46;&#x40;&#103;&#x6d;&#97;&#105;&#108;&#46;&#99;&#111;&#109;&#x5d;&#40;&#x29;</a></p>
<blockquote>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？</p>
<p>On 3月23日, 上午9时15分, qiaojie <a href="&#x6d;&#x61;&#105;&#x6c;&#x74;&#x6f;&#58;&#x5b;&#x71;&#x69;&#97;&#x6f;&#46;&#x2e;&#46;&#64;&#x67;&#109;&#97;&#105;&#x6c;&#46;&#x63;&#111;&#109;&#93;&#x28;&#41;">&#x5b;&#x71;&#x69;&#97;&#x6f;&#46;&#x2e;&#46;&#64;&#x67;&#109;&#97;&#105;&#x6c;&#46;&#x63;&#111;&#109;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1)
=
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank
Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？</p>
</blockquote>
<p> To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> 居振梁 <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-25</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>哈哈，估计有人想说“这次居然是收敛的”</p>
<p>2010/3/25 机械唯物主义 : linjunhalida <a href="&#x6d;&#x61;&#x69;&#108;&#x74;&#x6f;&#58;&#x5b;&#x6c;&#105;&#110;&#106;&#x75;&#x6e;&#x2e;&#46;&#46;&#x40;&#103;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#93;&#x28;&#41;">&#x5b;&#x6c;&#105;&#110;&#106;&#x75;&#x6e;&#x2e;&#46;&#46;&#x40;&#103;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#93;&#x28;&#41;</a></p>
<h2 id="-">恩，离题远了。不再讨论经济。</h2>
<p>御剑乘风来，除魔天地间。有酒乐逍遥，无酒我亦颠。
<a href="http://www.xspirithack.org/" target="_blank"><a href="http://www.xspirithack.org">http://www.xspirithack.org</a></a>
一饮尽江河，再饮吞日月。千杯醉不倒，唯我酒剑仙。
<a href="">显示删减掉的内容</a></p>
<p><img src="" alt=""> qiaojie <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-25</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>淡定....
2010/3/25 居振梁 <a href="&#x6d;&#97;&#105;&#108;&#116;&#111;&#x3a;&#x5b;&#106;&#117;&#x7a;&#104;&#101;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#109;&#x61;&#x69;&#108;&#46;&#x63;&#111;&#x6d;&#x5d;&#40;&#x29;">&#x5b;&#106;&#117;&#x7a;&#104;&#101;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#109;&#x61;&#x69;&#108;&#46;&#x63;&#111;&#x6d;&#x5d;&#40;&#x29;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>哈哈，估计有人想说“这次居然是收敛的”</p>
<p>2010/3/25 机械唯物主义 : linjunhalida <a href="&#x6d;&#97;&#x69;&#x6c;&#116;&#111;&#58;&#91;&#108;&#105;&#110;&#x6a;&#x75;&#110;&#46;&#x2e;&#46;&#x40;&#103;&#x6d;&#x61;&#105;&#108;&#x2e;&#x63;&#111;&#x6d;&#93;&#40;&#x29;">&#91;&#108;&#105;&#110;&#x6a;&#x75;&#110;&#46;&#x2e;&#46;&#x40;&#103;&#x6d;&#x61;&#105;&#108;&#x2e;&#x63;&#111;&#x6d;&#93;&#40;&#x29;</a></p>
<h2 id="-"> 恩，离题远了。不再讨论经济。</h2>
<p>御剑乘风来，除魔天地间。有酒乐逍遥，无酒我亦颠。
<a href="http://www.xspirithack.org/" target="_blank"><a href="http://www.xspirithack.org">http://www.xspirithack.org</a></a>
一饮尽江河，再饮吞日月。千杯醉不倒，唯我酒剑仙。</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> tinyfool <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-25</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>呵呵，其实咱们组真的已经是互联网上讨论组里面，最平和，最专业的一个了。</p>
<p>大家有时候稍微相互包容点，就不至于弄得大家都不愉快的，我们还是挺好的。
不准老幸灾乐祸，惟恐天下不乱的，哈哈</p>
<p>技术讨论技术吧
我继续鼓吹OPENCL，哈哈</p>
<p>在 2010-3-25，下午2:44， 居振梁 写道：</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>哈哈，估计有人想说“这次居然是收敛的”</p>
<p>2010/3/25 机械唯物主义 : linjunhalida <a href="&#x6d;&#97;&#x69;&#108;&#116;&#x6f;&#x3a;&#91;&#x6c;&#x69;&#x6e;&#106;&#x75;&#x6e;&#x2e;&#46;&#x2e;&#x40;&#x67;&#x6d;&#97;&#x69;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#40;&#x29;">&#91;&#x6c;&#x69;&#x6e;&#106;&#x75;&#x6e;&#x2e;&#46;&#x2e;&#x40;&#x67;&#x6d;&#97;&#x69;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#40;&#x29;</a></p>
<h2 id="-">恩，离题远了。不再讨论经济。</h2>
<p>御剑乘风来，除魔天地间。有酒乐逍遥，无酒我亦颠。
<a href="http://www.xspirithack.org/" target="_blank"><a href="http://www.xspirithack.org">http://www.xspirithack.org</a></a>
一饮尽江河，再饮吞日月。千杯醉不倒，唯我酒剑仙。</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a></p>
<p><img src="" alt=""> fxc...@gmail.com <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-26</p>
<p>其他收件人：</p>
<p>好吧，俺也打个广告。
既然大家都说tools是concurrent的一个大issue。那不妨看看MS的Concurrency工具包：Parallel
Debugger/Parallel Profiler. 在下一个版本VS里面会加入Static Analysis的support。
<a href="http://msdn.microsoft.com/en-us/concurrency/default.aspx" target="_blank">msdn.microsoft.com/en-us/concurrency/default.aspx</a></p>
<p>On Mar 24, 9:04 am, 莫华枫 <a href="&#x6d;&#x61;&#105;&#x6c;&#x74;&#x6f;&#x3a;&#x5b;&#108;&#x6f;&#110;&#x67;&#x73;&#104;&#x61;&#110;&#x6b;&#x2e;&#46;&#46;&#64;&#103;&#109;&#97;&#105;&#x6c;&#x2e;&#99;&#x6f;&#109;&#93;&#x28;&#x29;">&#x5b;&#108;&#x6f;&#110;&#x67;&#x73;&#104;&#x61;&#110;&#x6b;&#x2e;&#46;&#46;&#64;&#103;&#109;&#97;&#105;&#x6c;&#x2e;&#99;&#x6f;&#109;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>凑个热闹，也来个广告：CERL 2.0初具雏形。</p>
<p>--
反者道之动，弱者道之用
longshank...@gmail.com<a href="http://[blog.csdn.net/longshanks/](http://blog.csdn.net/longshanks/" target="_blank">http://[blog.csdn.net/longshanks/](http://blog.csdn.net/longshanks/</a>)
wave开通
<a href="">显示删减掉的内容</a>
<img src="" alt=""> AWu <img src="" alt=""></p>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-28</p>
<p>其他收件人：</p>
<p>这不是逼俺买MBP嘛？</p>
<p>感觉并行需要有足够简单，足够可靠的工程实施方法才能够大规模得被应用～
毕竟IT业从业人员不是所有人都足够聪明能够写得了、分析得了并行</p>
<p>一个可靠的工程方法来规避并行可能引发的性能或者功能缺陷，如果能够抽象到库里面规避当然更好，但是库这个东西得有足够多的工程实践才能做得出来吧，所
以我认为第一步是有一个可行的并行工程实施方法。</p>
<p>On 3月22日, 下午2时06分, Guancheng Chen <a href="&#109;&#x61;&#x69;&#108;&#x74;&#x6f;&#58;&#x5b;&#99;&#104;&#101;&#x6e;&#x67;&#117;&#97;&#110;&#x63;&#104;&#46;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#97;&#105;&#108;&#x2e;&#99;&#x6f;&#x6d;&#93;&#40;&#41;">&#x5b;&#99;&#104;&#101;&#x6e;&#x67;&#117;&#97;&#110;&#x63;&#104;&#46;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#97;&#105;&#108;&#x2e;&#99;&#x6f;&#x6d;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>On 3月22日, 上午2时20分, Tinyfool <a href="&#x6d;&#97;&#105;&#x6c;&#116;&#x6f;&#x3a;&#x5b;&#116;&#x69;&#x6e;&#x79;&#102;&#46;&#x2e;&#x2e;&#64;&#x67;&#109;&#97;&#105;&#x6c;&#x2e;&#x63;&#111;&#109;&#93;&#x28;&#41;">&#x5b;&#116;&#x69;&#x6e;&#x79;&#102;&#46;&#x2e;&#x2e;&#64;&#x67;&#109;&#97;&#105;&#x6c;&#x2e;&#x63;&#111;&#109;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#x6d;&#97;&#x69;&#108;&#x74;&#x6f;&#58;&#x5b;&#x6a;&#101;&#x2e;&#46;&#x2e;&#64;&#x6c;&#105;&#118;&#x65;&#46;&#99;&#111;&#109;&#93;&#x28;&#x29;">&#x5b;&#x6a;&#101;&#x2e;&#46;&#x2e;&#64;&#x6c;&#105;&#118;&#x65;&#46;&#99;&#111;&#109;&#93;&#x28;&#x29;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#109;&#x61;&#x69;&#x6c;&#x74;&#x6f;&#x3a;&#91;&#x63;&#x68;&#x65;&#110;&#103;&#x75;&#x61;&#x6e;&#x63;&#104;&#46;&#46;&#46;&#64;&#103;&#109;&#x61;&#x69;&#108;&#x2e;&#99;&#x6f;&#109;&#x5d;&#x28;&#41;">&#91;&#x63;&#x68;&#x65;&#110;&#103;&#x75;&#x61;&#x6e;&#x63;&#104;&#46;&#46;&#46;&#64;&#103;&#109;&#x61;&#x69;&#108;&#x2e;&#99;&#x6f;&#109;&#x5d;&#x28;&#41;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#x6d;&#97;&#x69;&#x6c;&#x74;&#111;&#x3a;&#x5b;&#x70;&#x6f;&#x6e;&#46;&#x2e;&#46;&#x40;&#x67;&#111;&#x6f;&#103;&#108;&#x65;&#x67;&#x72;&#111;&#x75;&#112;&#115;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#41;">&#x5b;&#x70;&#x6f;&#x6e;&#46;&#x2e;&#46;&#x40;&#x67;&#111;&#x6f;&#103;&#108;&#x65;&#x67;&#x72;&#111;&#x75;&#112;&#115;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#41;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。</p>
</li>
</ol>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>--
Tinyfool的开发日记<a href="http://www.tinydust.net/dev/" target="_blank"><a href="http://www.tinydust.net/dev/">http://www.tinydust.net/dev/</a></a>
代码中国网<a href="http://www.codechina.org/" target="_blank"><a href="http://www.codechina.org">http://www.codechina.org</a></a>
myTwitter:<a href="http://twitter.com/tinyfool" target="_blank"><a href="http://twitter.com/tinyfool">http://twitter.com/tinyfool</a></a>
<a href="">显示删减掉的内容</a>
上一页 <a href="">上一页</a>  </p>
</blockquote>
</blockquote>
<p>第 <strong>1</strong> 页
  下一页 <a href="">下一页</a></p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/好文摘录/">好文摘录</a></li></span></span> | <span class="time">recent updated:<time title="2014-03-07 11:24:30"datetime="2014-03-07 11:24:30"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/03/2014-02-03--{技术}{多线程}实施并行编程的五大障碍/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-03--{技术}{多线程}实施并行编程的五大障碍" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/03/2014-02-03--阿里数据库专家：写给我们这些浮躁的程序员/">阿里数据库专家：写给我们这些浮躁的程序员</a></h1>
      
        <span>Posted on<time datetime="2014-02-03T03:24:29.000Z"> <a href="/2014/02/03/2014-02-03--阿里数据库专家：写给我们这些浮躁的程序员/">feb. 3 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-">阿里数据库专家：写给我们这些浮躁的程序员</h1>
<p><strong>本文作者：叶正盛，阿里巴巴数据库技术专家，专注于数据库应用性能量化。</strong></p>
<p>再次写给我们这些刚入行浮躁的程序员，如何成长，以下是列出了一些成长的心得，我们不必每条都去实践，但是优秀的程序员成长过程中总会实践里面的几条。</p>
<p><strong>多做项目，多思考</strong></p>
<p>不要害怕做事，刚毕业的同学最缺的就是工作经验，乱七八糟的项目能让你很快就了解了一个公司的业务与使用的技术，并且可以多接触同事与客户。</p>
<p>当你毕业后刚进一家公司时，如果主管没有把你安排到项目组工作，那真的很杯具，因为他认为你还不能胜任工作或者你的加入会让项目组更糟。</p>
<p>还有人说，我刚进公司，公司就把我当成了苦工，工资又低，项目组加入好几个，也做了很多事情，每天都要加班。我估计有很多人感觉是这种状态，为什么会是这样，因为全国人民（不只是程序员）里有90%可能都和你一样的感觉，这说明你现在状况是很普遍的，也说明你现在的能力并没有很多出众的地方。也许是逆境才能让人成长，如果有一天你让你的团队从这些苦力工作中解脱出来或者能给你的团队前进的动力，那你就升华了，你就比他们出众。你没有能力去改变现状，所以只能接受，而不要认为是自己生不逢时，或者说公司环境太差。创业也一样，不要认为公司没发展的主要原因是环境太差，那你不要去当老板算了，投资环境都非常好还能轮到你吗。</p>
<p>还有很多同学感觉自己付出了很多，回报太少，这个问题很难平衡，首先一点，公司在聘你进来后不会因为你没有成绩就先给你回报，公司也不可能会在你有了成绩后就立即给你回报，但是长时间付出没有回报，那这个公司就不值得你付出。我不赞成频繁换公司，这么做至少可以说明你是一个只求回报不求付出的人。</p>
<p>至于薪资的问题，这个很难去评估，因为每个企业的收益相差太远。但是刚毕业的同学工作需要关注薪资+成长环境，当薪资可以满足普通生活需求后，成长环境更为重要，就好比，给你一月5000元，或者6000元，真的不那么重要，因为这些收入在你以后的人生中基本没有影响。当然，如果你现在在大城市几年里每个月只拿着1000元，那还是需要选择一下收入更好的公司，因为这么低的收入会严重影响你的工作学习计划，也说明你的公司不重视员工，没有能力给员工好生活的公司，将来的发展也是有限的。</p>
<p>特别说明一点，互联网公司与传统信息化企业不一样，互联网一直是风险比较高的行业，也许你选择了一个看好的企业，也佩服老板的眼光，可能你现在需要的是与公司同甘共苦。不要指望在刚创业的团队里拿到非常好的待遇，因为你现在就是在投资，也许几年后公司成功了，你就是功臣，不怎么出色的你也可以当上总监或副总裁。</p>
<p><strong>自己开发框架与工具来提高工作效率</strong></p>
<p>当你参与了很多项目，当你发现自己经常做一些COPY,PASTE的操作时，你可以考虑花时间去提取问题的共性，做一些自动化工具去摆平问题，或者是写一些基础框架来屏蔽这些无聊并且累赘的代码。</p>
<p>自己开发框架与工具，可以让你快速的从一个初级程序员转变成更高级的程序员或分析师或架构师，因为这个过程中给你提供了为其他程序员服务的机会，你有动力去了解其它程序员的工作需求，你可以把你的框架或工具写得很好，接口简单灵活并且性能好，分析师和架构师就经常要干这种让人力成本降低的事。但要记住一点，不要以为自己开发框架与工具就认为很NB了，因为这种工作并不会体现多少技术含量，而只是提高个人抽象问题的能力，这个活很多程序员都能干，但是很少人去干好。</p>
<p><strong>参与开源项目</strong></p>
<p>参与开源项目可以让你领略到不同程序员的沟通方法，开发习惯，技术思维，可以认识更多的朋友，如果你足够强，也可能一举成名哦。可以让你更深入了解这个开源东西，所以最好是感兴趣或者是与工作有关的，不要说什么流行就参与什么。开源项目可以自己贡献一个新的项目，或者参与一个感兴趣的项目。</p>
<p>不要指望开源项目会给你带来直接的金钱，如果你想拿着开源项目封装一下去发财，那我真不知道如何做，可以去问问什么什么芯，什么什么国产操作系统的人，他们更有经验。</p>
<p><strong>英语</strong></p>
<p>在这个全球信息时代，英语真的是一个很重要的工具，我真的很羡慕那些学校里英语就很好的同学，好的英语能力可以更快速的了解到更多知识。当前，新的技术与知识大部份语言都是英语或翻译成英语，如果能把英语学好，可以让你人生少奋斗10年。</p>
<p><strong>写技术博客</strong></p>
<p>写技术博客是一种可以快速提高的方法，但是一个人能坚持每周写技术博客，那是需要付出很多代价，写博客并不是要我们写出高质量的文章才发表，我们可以分享自己的一些小经验，也可以分享自己的体会。一样东西在你大脑里，并不表示你已经掌握了，如果你能说给别人听，或者用文字表达出来，那首先你要将这些知识点整理清楚才好表达。我经常认为自己已经对某个问题了解了，但是在整理技术博客时发现自己的知识盲点，然后再去查找知识来补充自己的盲点，直到最后搞清楚了才算告一段落。</p>
<p>有些人不喜欢分享或者害怕分享，但是在这个世界，只要不是公司机密或商业秘密，拿出来分享可以让你得到更多同行的反馈，网络上的人会给你相对真实的反馈，因为大部份人与你没有利益关系。</p>
<p>新人不要害怕自己分享的知识是否有技术含量，只要你认为有价值，都可以拿出来，这不仅可以给别人提供知识，也可以自己整理思路，还可以得到网友的反馈。如果你的知识没有价值，分享出来也没有关系，如果你的文章技术含量低，怕被人鄙视，那是你这个人不敢承认现实，因为同事与朋友可能不会说你的文章很菜，就算被鄙视了又如何，有时被人鄙视也是一种前进的动力。有人说如果几年后我进步了很多，但还让人看到我这些初学时弱智的文档，误人子弟，不好意思，Ok，那个时候有可以完全把文档删除，其实我更喜欢放在那里品味自己成长的过程，把有误导的地方更正。</p>
<p>我知道有一个技术博客作者，数据库专家杨廷琨(<a href="http://yangtingkun.itpub.net/)，他几年来，每天坚持写一篇技术博客，现在已经有2千多篇，我的ORACLE数据库水平比他差很多，但是我也偶尔看到一些他新写的文档我几年前就会了，但这些并不妨碍我对这位博客作者的敬佩，因为他的博客让我学到了很多知识。" target="_blank">http://yangtingkun.itpub.net/)，他几年来，每天坚持写一篇技术博客，现在已经有2千多篇，我的ORACLE数据库水平比他差很多，但是我也偶尔看到一些他新写的文档我几年前就会了，但这些并不妨碍我对这位博客作者的敬佩，因为他的博客让我学到了很多知识。</a></p>
<p><strong>加入感兴趣的技术论坛</strong></p>
<p>每个公司使用的技术与产品及环境都不太一样，也许你在公司里感觉什么东西都是别人做好了，我只是个流水线工人，我们的系统由于有严格的规范也不太出问题，自己的实践提高机会太少，那建议你加入感兴趣的技术论坛。</p>
<p>技术论坛上你可以看到很多人各种各样的问题与分享讨论，你也可以试着去帮别人解决问题。技术论坛可以让你进一步成长，但不要告诉我你只是会沙发、顶或接分的那种。</p>
<p>国内CSDN、OSCHINA、ITPUB、CHINAUNIX、JAVAEYE都是人气很旺，里面也不缺技术大牛与无敌大菜鸟。</p>
<p><strong>常看参考手册</strong></p>
<p>很多程序员，遇到问题喜欢直接去请教别人，或是Google找结果，通过别人或Google也许问题可以解决，但是只能形成知识点，不能形成知识体系。</p>
<p>要全面掌握一个东西最快的方法是看产品的官方参考手册，参考手册一般是代表正规的用法或者是推荐的用法，对于小产品最好是先将参考手册全部看一遍。如果是比较大的产品如（ORACLE、JAVA、.NET）那可以选择看经常使用到的部分。只有当你在看完参考手册还不懂的时候再去Google或与别人探讨，这样的方式会让你的知识更体系化。</p>
<p><strong>深入分析问题原因</strong></p>
<p>程序员一定要具备对技术问题刨根问底的想法，很多程序员能解决问题，但是不想去了解问题的根源。我们经常遇到问题，而且很多问题重启程序或者重启机器就好了，有多少程序员会去挖掘重启就解决问题的原因。我是从事数据库的，也经常看到很多人遇到数据库有问题，重装一下搞定，而没有深入分析问题产生的原因。也许在生产环境我们没有时间去分析，但是在开发环境、测试环境你是不是也经常重启解决问题。如果能在开发环境与测试环境遇到问题，这是技术人员成长的最好机会，我们在自己的领域一定不能放过这种成长的机会，因为大部份专家都是在这种历练中出来的。</p>
<p><strong>不要害怕复杂</strong></p>
<p>很多程序员习惯了利用各种框架及工具解决问题，自己只是写一些简单逻辑，当有一天遇到一个问题，没有对应的框架或工具时就放弃需求。我们不要害怕困难，如果你每天的代码都没有挑战，那何来提高，我们应该在适当的时候给自己一些压力，这样可以让自己提高得更快一些。比如你的系统需要一个轻量级的工作流引擎、编译器、解析器、界面设计器、屏幕控制器，或者一个http服务器之类的东东，但是现有的东西都感觉不太满意，你可以自己去搞一个试试，不要害怕不成功，不要害怕自己做不好。这些东西看起来有点复杂，但是当你深入去做时，你会发现里面有很多有意思的东西，你需要去逐步改进你的小系统，直到它能很好的运行为止，这是个很好的成长过程，可以让你对程序有更深的理解，也可打开思路。</p>
<p><strong>学习计算机基础，深入技术原理</strong></p>
<p>有时候我们经常迷惘，感觉技术水平没有提高，感觉技术能力总是浮在表面，特别是当你发现自己算法分析、性能分析、故障诊断能力有限时，也许这是你再次需要学习计算机基础的时候，因为基础不牢，所以你的问题诊断准确率不高。每个程序员应该都学过计算机基础（计算机体系、操作系统、网络、数据库原理、算法等等），这些知识对很多人来说是很枯燥。在当前高级编程语言时代，你的计算机基础不好也能编码，而且效率也不低，但是当你要想成为技术牛人，计算机基础就是一道坎，因为不扎实的计算机基础知识会让你在忽悠与被忽悠中成长。</p>
<p><strong>关心产品市场与商业动态</strong></p>
<p>程序员是否需要关心产品市场与商业动态，我认为是有必要的，除非你真是技术天才，能闭关十年后横扫江湖。计算机技术发展太快，每年都有新的流行产品与技术，大公司也经常改变战略或易主。如果你想引领技术潮流，想创业，那一定要关心产品市场与商业动态。</p>
<p><strong>不要去轻视任何一种职位、语言、工具</strong></p>
<p>在IT岗位里，没有高低之分，不要去轻视任何一种岗位，有些程序员认为自己的成果最有价值，美工、测试只是边缘岗位，项目经理就只会瞎指挥，不干活，销售人员与售前人员接到定单后屁事都没有，整个项目基本上就是我一个人的成果。这种心态是最要不得的。其实你的领导并不会这么想，很多事情是你不知道的，如客户关系就可能不是你一个人搞定的。还有最重要的一点，如果这个项目没有你参加怎么样？项目可能换成另外一个人做，也许他也能做得也不错，这就说明你的价值或重要性并不像你想象的那么重要。举个例子：</p>
<p>就好比你买一台联想电脑4000块，卖给一个没看过电脑的火星人20000块，这台电脑是最后的成果，但是否表示联想这台电脑是最重要的，可能你买一台戴尔的电脑还赚的钱更多，也可能你只要给对方一台杂牌电脑就可以拿到20000块。在这个例子里更重要的也许是客户关系与抓住商机，而买什么样的电脑影响不大（你在项目里的地位可能就是这台电脑的作用，没有你肯定不完整，但是很容易找到你的替代品，所以你的价值并不是最重要的）。</p>
<p>计算机编程语言是初学者最喜欢对比的话题，有的大师也经常对比各种语言的优缺点。我并不反对的评论那种语言的优劣，但我们不能去鄙视某种语言的及其使用者，因为流行的语言都有它生存的环境，可能是我们对技术的见识太窄，也可能是我们对人类的思维习惯了解的不全面，不要总是拿自己的习惯去评价。有很多系统管理员喜欢用命令行，喜欢用shell,perl等脚本语言，这些东西在我看来简直是低效且易读性差的东西，但是当你经常在没有图形界面下工作时，脚本语言可能真是更高效的选择。</p>
<p><strong>最后写上一句浮躁的根源：</strong></p>
<p>不要把祖国当母亲，应该把祖国当自己的孩子。</p>
<p>本不想讲这句话的，但是现实就是如此，浮躁的人群总是对社会充满了意见。我认为所有的这些浮躁都有一个共同点，就是认为自己无法改变这个社会，改变这个社会是国家的事，是其他人的事。</p>
<p>小时候老师总是讲祖国是母亲，我们是花朵，但是实际上我们也不是什么花朵，我们就是郑智化歌里的那根“小小的草，风吹雨打后依然不倒”。现实的社会总是充满着种种不平衡，但是浮躁并不能解决问题。有时总在想祖国并不像我的母亲，她更像是我的孩子，她还很小，经历过很多坎坷，我们经常感觉自家的孩子比不上别人的孩子的某个方面，于是对孩子多加责骂，也可能会让她花一个暑假的时间去补习。小孩子有一些成绩后也会骄傲，有时还会欺骗，我们不能容忍的是她的恶意谎言，但是她还没有到无药可救的程度，她依然还在成长。我们经常拿孩子与别人的孩子对比，而且总是发现别人孩子更好的一面，但是你是否希望与别人交换孩子呢，除了感情外你是否了解别人孩子的全部，我们需要更多的面对现实，应该在孩子成长的时候及时指出她的缺点，她不可能什么都是优秀的，所以我们应该尽自己的能力让她更好一些。你不太可能改变母亲，但是你的行动会影响孩子，你抛弃孩子，你真正的孩子将来可能也会抛弃你，所以说祖国可能并不像母亲，更像孩子，如果你把祖国当孩子，也许是另一种人生价值。
来源： <a href="[http://www.oschina.net/question/5189_20311](http://www.oschina.net/question/5189_20311)">[http://www.oschina.net/question/5189_20311](http://www.oschina.net/question/5189_20311)</a> </p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/好文摘录/">好文摘录</a></li></span></span> | <span class="time">recent updated:<time title="2014-03-07 11:24:29"datetime="2014-03-07 11:24:29"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/03/2014-02-03--阿里数据库专家：写给我们这些浮躁的程序员/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-03--阿里数据库专家：写给我们这些浮躁的程序员" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/03/2014-02-03--程序算法与人生选择/">程序算法与人生选择</a></h1>
      
        <span>Posted on<time datetime="2014-02-03T03:24:29.000Z"> <a href="/2014/02/03/2014-02-03--程序算法与人生选择/">feb. 3 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-">程序算法与人生选择</h1>
<p><a href="&quot;把这个链接拖到你的Chrome收藏夹工具栏中&quot;">High一下!</a></p>
<h1 id="-coolshell-cn-http-coolshell-cn-"><a href="http://coolshell.cn/" target="_blank">酷壳 – CoolShell.cn</a></h1>
<p>享受编程和技术所带来的快乐 – <a href="http://coolshell.cn" target="_blank">http://coolshell.cn</a></p>
<ul>
<li><a href="http://coolshell.cn/" title="首页" target="_blank">首页</a></li>
<li><a href="http://coolshell.cn/featured_posts" target="_blank">推荐文章</a></li>
<li><a href="http://coolshell.cn/plugins" target="_blank">本站插件</a></li>
<li><a href="http://coolshell.cn/guestbook" target="_blank">留言小本</a></li>
<li><a href="http://coolshell.cn/about" target="_blank">关于酷壳</a></li>
<li><a href="http://coolshell.cn/haoel" target="_blank">关于陈皓</a></li>
<li><a href=""></a>
<a href="http://coolshell.cn/" title="转到首页" target="_blank">首页</a> &gt; <a href="http://coolshell.cn/category/misc" title="查看 杂项资源 中的全部文章" target="_blank">杂项资源</a> &gt; 程序算法与人生选择</li>
</ul>
<h2 id="-">程序算法与人生选择</h2>
<p>2012年12月28日 <a href="http://coolshell.cn/articles/author/haoel" title="由 陈皓 发布" target="_blank">陈皓</a> <a href="">发表评论</a> <a href="">阅读评论</a> 63,218 人阅读    </p>
<p><img src="" alt="">每年一到要找工作的时候，我就能收到很多人给我发来的邮件，总是问我怎么选择他们的offer，去腾讯还是去豆瓣，去外企还是去国内的企业，去创业还是去考研，来北京还是回老家，该不该去创新工场？该不该去thoughtworks？……等等，等等。今年从7月份到现在，我收到并回复了60多封这样的邮件。我更多帮他们整理思路，帮他们明白自己最想要的是什么。（注：我以后不再回复类似的邮件了）。</p>
<p>我深深地发现，对于我国这样从小被父母和老师安排各种事情长大的人，当有一天，父母和老师都跟不上的时候，我们几乎完全不知道怎么去做选择。而我最近也离开了亚马逊，换了一个工作。又正值年底，就像去年的那篇《<a href="http://coolshell.cn/articles/6142.html" title="三个事和三个问题" target="_blank">三个故事和三个问题</a>》一样，让我想到写一篇这样的文章。</p>
<h3 id="-">几个例子</h3>
<p>当我们在面对各种对选择的影响因子的时候，如：城市，公司规模，公司性质，薪水，项目，户口，技术，方向，眼界…… 你总会发现，你会在几个公司中纠结一些东西，举几个例子：</p>
<ul>
<li><p>某网友和我说，他们去上海腾讯，因为腾讯的规模很大，但却发现薪水待遇没有豆瓣高（低的还不是一点），如果以后要换工作的话，起薪点直接关系到了以后的高工资。我说那就去豆瓣吧，他说豆瓣在北京，污染那么严重，又没有户口，生存环境不好。我说去腾讯吧，他说腾讯最近组织调整，不稳定。我说那就去豆瓣吧，慢公司，发展很稳当。他说，豆瓣的盈利不清楚，而且用Python，自己不喜欢。我说，那就去腾讯吧，……</p>
</li>
<li><p>还有一网友和我说，他想回老家，因为老家的人脉关系比较好，能混得好。但又想留在大城市，因为大城市可以开眼界。</p>
</li>
<li><p>另一网友和我说，他想进外企，练练英语，开开眼界，但是又怕在外企里当个螺丝钉，想法得不到实施。朋友拉他去创业，觉得创业挺好的，锻炼大，但是朋友做的那个不知道能不能做好。</p>
</li>
<li><p>还有一网友在创新工场的某团队和考研之间抉择，不知道去创新工场行不行，觉得那个项目一般，但是感觉那个团队挺有激情的，另一方面觉得自己的学历还不够，读个研应该能找到更好的工作。</p>
</li>
<li><p>还有一些朋友问题我应该学什么技术？不应该学什么技术？或是怎么学会学得最快，技术的路径应该是什么？有的说只做后端不做前端，有的说，只做算法研究，不做工程，等等，等等。因为他们觉得人生有限，术业有专攻。</p>
</li>
<li><p>等等，等等……</p>
</li>
</ul>
<p>我个人觉得，如果是非计算机科班出生的人不会做选择，不知道怎么走也罢了，但是我们计算机科班出生的人是学过算法的，<strong>懂算法的人应该是知道怎么做选择的</strong>。</p>
<h2 id="-">#</h2>
<h3 id="-">排序算法</h3>
<p>你不可能要所有的东西，所以你只能要你最重要的东西，你要知道什么东西最重要，你就需要对你心内的那些欲望和抱负有清楚的认识，不然，你就会在纠结中度过。</p>
<p>所以，在选择中纠结的人有必要参考一下排序算法。</p>
<ul>
<li><p>首先，你最需要参考的就是“冒泡排序”——这种算法的思路就是每次冒泡出一个最大的数。所以，你有必要问问你自己，面对那些影响你选择的因子，如果你只能要一个的话，你会要哪个？而剩下的都可以放弃。于是，当你把最大的数，一个一个冒泡出来的时候，并用这个决策因子来过滤选项的时候，你就能比较容易地知道知道你应该选什么了。<strong>这个算法告诉我们，人的杂念越少，就越容易做出选择。</strong></p>
</li>
<li><p>好吧，可能你已茫然到了怎么比较两个决策因子的大小，比如：你分不清楚，工资&gt;业务前景吗？业务前景&gt;能力提升吗？所以你完全没有办法进行冒泡法。那你，你不妨参考一个“快速排序”的思路——这个算法告诉我们，我们一开始并不需要找到最大的数，我们只需要把你价值观中的某个标准拿出来，然后，把可以满足这个价值的放到右边，不能的放到左边去。比如，你的标准是：工资大于5000元&amp;&amp;业务前景长于3年的公司，你可以用这个标准来过滤你的选项。然后，你可以再调整这个标准再继续递归下去。<strong>这个算法告诉我们，我们的选择标准越清晰，我们就越容易做出选择</strong>。</p>
</li>
</ul>
<p>这是排序算法中最经典的两个算法了，面试必考。相信你已烂熟于心中了。所以，我觉得你把这个算法应用于你的人生选择也应该不是什么问题。关于在于，你是否知道自己想要的是什么？</p>
<p>排序算法的核心思想就是，<strong>让你帮助你认清自己最需要的是什么，认清自己最想要的是什么，然后根据这个去做选择</strong>。</p>
<h3 id="-">贪婪算法</h3>
<p>所谓贪婪算法，是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择（注意：是当前状态下），从而希望导致结果是最好或最优的算法。贪婪算法最经典的一个例子就是<a href="http://coolshell.cn/articles/7459.html" title="Huffman 编码压缩算法" target="_blank">哈夫曼编码</a>。</p>
<p>对于人类来说，一般人在行为处事的时候都会使用到贪婪算法，</p>
<ul>
<li><p>比如在找零钱的时候，如果要找补36元，我们一般会按这样的顺序找钱：20元，10元，5元，1元。</p>
</li>
<li><p>或者我们在过十字路口的时候，要从到对角线的那个街区时，我们也会使用贪婪算法——哪边的绿灯先亮了我们就先过到那边去，然后再转身90度等红灯再过街。</p>
</li>
</ul>
<p>这样的例子有很多。对于选择中，大多数人都会选用贪婪算法，因为这是一个比较简单的算法，未来太复杂了，只能走一步看一步，在当前的状况下做出最利于自己的判断和选择即可。</p>
<p>有的人会贪婪薪水，有的人会贪婪做的项目，有的人会贪婪业务，有的人会贪婪职位，有的人会贪婪自己的兴趣……这些都没什么问题。贪婪算法并没有错，虽然不是全局最优解，但其可以让你找到局部最优解或是次优解。其实，有次优解也不错了。<strong>贪婪算法基本上是一种急功近利的算法，但是并不代表这种算法不好，如果贪婪的是一种长远和持续，又未尝不可呢？</strong>。</p>
<h3 id="-">动态规划</h3>
<p>但是我们知道，对于大部分的问题，贪婪法通常都不能找出最优解，因为他们一般没有测试所有可能的解。<strong>因为贪婪算法是一种短视的行为，只会跟据当前的形式做判断，也就是过早做决定</strong>，因而没法达到最佳解。</p>
<p>动态规划和贪婪算法的最大不同是，贪婪算法做出选择，不能回退。动态规划则会保存以前的运算结果，并根据以前的结果对当前进行选择，有回退功能。</p>
<p>动态规划算法至少告诉我们两个事：</p>
<p>1）<strong>承前启后非常重要，</strong>当你准备去做遍历的时候，你的上次的经历不但能开启你以后的经历，而且还能为后面的经历所用。你的每一步都没有浪费。</p>
<p>2）<strong>是否可以回退也很重要</strong>。这意思是——如果你面前有两个选择，一个是A公司一个是B公司，如果今天你错失了B公司，那到你明天还能不能找回来？</p>
<p>比如说：你有两个offer，一个是Yahoo，一个是Baidu，上述的第一点会让我们思考，Yahoo和Baidu谁能给我们开启更大的平台？上述的第二点告诉我们，是进入Yahoo后如果没有选好，是否还能回退到Baidu公司？还是进入Baidu公司后能容易回退到Yahoo公司？</p>
<h3 id="-dijkstra-"><strong>Dijkstra</strong>最短路径</h3>
<p>最短路径是一个Greedy + DP的算法。相当经典。这个算法的大意如下：</p>
<p>1）在初始化的时候，所有的结点都和我是无穷大，默认是达不到的。</p>
<p>2）从离自己最近的结点开始贪婪。</p>
<p>3）走过去，看看又能到达什么样的结点，计算并更新到所有目标点的距离。</p>
<p>4）再贪婪与原点最短的结点，如此反复。</p>
<p>这个算法给我们带来了一些这样的启示：</p>
<ul>
<li><p>有朋友和我说过他想成为一个架构师，或是某技术领域的专家，并会踏踏实实的向这个目标前进，永不放弃。我还是鼓励了他，但我也告诉他了这个著名的算法，我说，这个算法告诉你，架构师或某领域的专家对你来说目前的距离是无穷大，他们放在心中，先看看你能够得着的东西。<strong>所谓踏实，并不是踏踏实实追求你的目标，而是踏踏实实把你够得着看得见的就在身边的东西干好。</strong>我还记得我刚参加工作，从老家出来的时候，从来没有想过要成为一个技术牛人，也从来没有想过我的博客会那么的有影响力，在做自己力所能及，看得见摸得着的事情，我就看见什么技术就学什么，学着学着就知道怎么学更轻松，怎么学更扎实，这也许就是我的最短路径。</p>
</li>
<li><p>有很多朋友问我要不要学C++，或是问我学Python还是学Ruby，是不是不用学前端，等等。这些朋友告诉我，他们不可能学习多个语言，学了不用也就忘了，而且术业有专攻。这并没有什么不对的，只是我个人觉得，学习一个东西没有必要只有两种状态，一种是不学，另一种是精通。了解一个技术其实花不了多少时间，我学C++的目的其实是为了更懂Java，学TCP/IP协议其实是为了更懂Socket编程，很多东西都是连通和相辅相成的，学好了C/C++/Unix/TCP等这些基础技术后，我发现到达别的技术路径一下缩短了（这就是为什么<a href="http://coolshell.cn/articles/8489.html" title="Go 语言简介（下）— 特性" target="_blank">我用两天时间就可以了解Go语言的原因</a>）。<strong>这就好像这个算法一样，算法效率不高，也许达到你的目标，你在一开始花了很长时间，遍历了很多地方，但是，这也许这就是你的最短路径</strong>。</p>
</li>
</ul>
<h3 id="-trade-off">算法就是Trade-Off</h3>
<p>你根本没有办法能得到所有你想得到的东西，<strong>任何的选择都意味着放弃</strong>——<strong>当你要去获得一个东西的时候，你总是需要放弃一些东西</strong>。<strong>人生本来就是一个跷跷板，一头上，另一头必然下</strong>。这和我们做软件设计或算法设计一样，用时间换空间，用空间换时间，还有CAP理论，总是有很多的Trade-Off，正如这个短语的原意一样——<strong>你总是要用某种东西去交易某种东西</strong>。</p>
<p>我们都在用某种东西在交易我们的未来，有的人用自己的努力，有的人用自己的思考，有的人用自己的年轻，有的人用自己的自由，有的人用自己的价值观，有的人用自己的道德…… …… 有的人在交换金钱，有的人在交换眼界，有的人在交换经历，有的人在交换地位，有的人在交换能力，有的人在交换自由，有的人在交换兴趣，有的人在交换虚荣心，在交换安逸享乐…… ……</p>
<p><strong>每个人有每个人的算法，每个算法都有每个算法的purpose，就算大家在用同样的算法，但是每个人算法中的那些变量、开关和条件都不一样，得到的结果也不一样。我们就是生活在Matrix里的一段程序，我们每个人的算法决定着我们每个人的选择，我们的选择决定了我们的人生</strong>。</p>
<p><strong>2012年就要过去了，祝大家新年快乐！</strong>
<img src="" alt="插图来自电影 Life of Pi"></p>
<p>插图来自电影 Life of Pi</p>
<p>（全文完）</p>
<p><strong>（转载本站文章请注明作者和出处 <a href="http://coolshell.cn/" target="_blank">酷壳 – CoolShell.cn</a> ，请勿用于任何商业用途）</strong></p>
<p>——=== <strong>访问 <a href="http://coolshell.cn/404/" target="_blank">酷壳404页面</a> 以支持公益事业</strong> ===——
<a href="&quot;分享到新浪微博&quot;"></a><a href="&quot;分享到腾讯微博&quot;"></a><a href="&quot;分享到搜狐微博&quot;"></a><a href="&quot;分享到网易微博&quot;"></a><a href="&quot;分享到豆瓣&quot;"></a><a href="&quot;分享到人人网&quot;"></a><a href=""></a><a href="&quot;分享到饭否&quot;"></a><a href="&quot;分享到Twitter&quot;"></a><a href="&quot;分享到Facebook&quot;"></a><a href="&quot;分享到Gmail邮箱&quot;"></a><a href="&quot;分享到LinkedIn&quot;"></a><a href="&quot;分享到FriendFeed&quot;"></a><a href="&quot;分享到Digg&quot;"></a><a href="http://www.jiathis.com/share?uid=1541368" target="_blank"></a><a href="">573</a>
分类: <a href="http://coolshell.cn/category/misc" title="查看 杂项资源 中的全部文章" target="_blank">杂项资源</a> 标签: <a href="http://coolshell.cn/tag/algorithm" target="_blank">Algorithm</a>, <a href="http://coolshell.cn/tag/job" target="_blank">Job</a>, <a href="http://coolshell.cn/tag/programmer" target="_blank">Programmer</a>, <a href="http://coolshell.cn/tag/%e7%a8%8b%e5%ba%8f%e5%91%98" target="_blank">程序员</a></p>
<p><img src="&quot;好烂啊&quot;" alt="好烂啊"><img src="&quot;有点差&quot;" alt="有点差"><img src="&quot;凑合看看&quot;" alt="凑合看看"><img src="&quot;还不错&quot;" alt="还不错"><img src="&quot;很精彩&quot;" alt="很精彩"> (<strong>111</strong> 人打了分，平均分： <strong>4.94</strong> )
<img src="&quot;Loading ...&quot;" alt="Loading ..."> Loading ...</p>
<h3 id="-">相关文章</h3>
<ul>
<li>2012年08月22日 -- <a href="http://coolshell.cn/articles/8138.html" target="_blank">为什么我反对纯算法面试题</a></li>
<li>2012年04月17日 -- <a href="http://coolshell.cn/articles/7048.html" target="_blank">挑战无处不在</a></li>
<li>2011年12月20日 -- <a href="http://coolshell.cn/articles/6142.html" target="_blank">三个事和三个问题</a></li>
<li>2010年10月26日 -- <a href="http://coolshell.cn/articles/3231.html" target="_blank">你和你的工作</a></li>
<li>2012年04月11日 -- <a href="http://coolshell.cn/articles/6994.html" target="_blank">我们需要专职的QA吗？</a></li>
<li>2012年08月27日 -- <a href="http://coolshell.cn/articles/8170.html" target="_blank">一次Ajax查错的经历</a></li>
<li>2012年08月16日 -- <a href="http://coolshell.cn/articles/8088.html" target="_blank">对技术的态度</a></li>
<li>2012年04月19日 -- <a href="http://coolshell.cn/articles/7126.html" target="_blank">这到底是谁之错？</a>
<a href="http://www.zemanta.com/?wp-related-posts" target="_blank">Zemanta</a></li>
</ul>
<p><a href="">评论 (168)</a> <a href="">Trackbacks (12)</a> <a href="">发表评论</a> <a href="http://coolshell.cn/articles/8790.html/trackback" target="_blank">Trackback</a></p>
<ol>
<li><img src="" alt=""></li>
</ol>
<p>qte</p>
<p>2013年2月18日23:20 | <a href="">/#1</a></p>
<p><a href="">回复</a> | <a href="">引用</a>
想了下，DP也说得通，抱歉打搅了<a href="">@sigh1988</a></p>
<ol>
<li><img src="" alt=""></li>
</ol>
<p>lanxzh</p>
<p>2013年2月20日10:31 | <a href="">/#2</a></p>
<p><a href="">回复</a> | <a href="">引用</a>
写得作者切身经历的体会和感受，非常好!</p>
<ol>
<li><img src="" alt=""></li>
</ol>
<p>jpbai</p>
<p>2013年2月20日16:57 | <a href="">/#3</a></p>
<p><a href="">回复</a> | <a href="">引用</a>
身在其中的时候经常会表现得浮躁</p>
<ol>
<li><img src="" alt=""></li>
</ol>
<p>FansUnion</p>
<p>2013年2月25日16:41 | <a href="">/#4</a></p>
<p><a href="">回复</a> | <a href="">引用</a>
非常经典啊!</p>
<p>使用几种经典的算法，回答了 若干人的提问-困惑-纠结。</p>
<p>赞！</p>
<ol>
<li><img src="" alt=""></li>
</ol>
<p>sam wu</p>
<p>2013年2月27日14:29 | <a href="">/#5</a></p>
<p><a href="">回复</a> | <a href="">引用</a>
蛮好的文章，很多人面临这些问题。</p>
<ol>
<li><img src="" alt=""></li>
</ol>
<p>LEo</p>
<p>2013年2月27日21:15 | <a href="">/#6</a></p>
<p><a href="">回复</a> | <a href="">引用</a>
看看这些，我自己觉得好讽刺。我现在连一个机会都没有。难道我只好去参加那些培训吗？</p>
<ol>
<li><img src="" alt=""></li>
</ol>
<p><a href="http://www.cnblogs.com/effort0209/" target="_blank">effort</a></p>
<p>2013年3月24日17:55 | <a href="">/#7</a></p>
<p><a href="">回复</a> | <a href="">引用</a>
说的不错，比喻恰当，追求时间舍不得空间，怀拥空间，又惦念着时间，可能真正的茫然是：我们不知道想要什么，总觉得一切东西放到一起时总会有平衡点，当寻求平衡点时，又忘记了我们自己，空耗了精力…..</p>
<ol>
<li><img src="" alt=""></li>
</ol>
<p>tamalegebi</p>
<p>2013年4月2日15:34 | <a href="">/#8</a></p>
<p><a href="">回复</a> | <a href="">引用</a>
完全看不懂算法和人生有啥直接关系，到时那个和网友的扯淡很有意思</p>
<ol>
<li><img src="" alt=""></li>
</ol>
<p>sunny鮟</p>
<p>2013年4月2日22:23 | <a href="">/#9</a></p>
<p><a href="">回复</a> | <a href="">引用</a>
越看越有意思,一个不喜欢自己专业而喜欢搞搞计算机但又完全不会计算机而苦恼的在自学了一段时间之后好像没学一样的大二学生看完表示,还是不知道未来的路在何方……..</p>
<ol>
<li><img src="" alt=""></li>
</ol>
<p><a href="http://lq2419.blog.51cto.com/" target="_blank">呼伦贝尔</a></p>
<p>2013年4月12日21:08 | <a href="">/#10</a></p>
<p><a href="">回复</a> | <a href="">引用</a>
以前忘记在哪看到过这篇文章，觉得这篇不错，现在在你博客里看到，果断转载了。</p>
<ol>
<li><img src="" alt=""></li>
</ol>
<p>linwkr</p>
<p>2013年5月1日18:46 | <a href="">/#11</a></p>
<p><a href="">回复</a> | <a href="">引用</a>
学习了。。。
从自己的领域对人生的思考:每个人都有每个人的算法</p>
<ol>
<li><img src="" alt=""></li>
</ol>
<p>it_liao</p>
<p>2013年5月6日00:19 | <a href="">/#12</a></p>
<p><a href="">回复</a> | <a href="">引用</a>
写得非常棒，要顶~</p>
<ol>
<li><img src="" alt=""></li>
</ol>
<p>IT熊猫</p>
<p>2013年6月21日18:31 | <a href="">/#13</a></p>
<p><a href="">回复</a> | <a href="">引用</a>
好形象哇，好明白哇，看完这我就知道那些 把简单事说得那么复杂的 “大师” 们是多么贱了。
皓哥你的确很高啊，既让我明白了算法的原理，又有点人生感悟的意思，不愧是高手哇。
以后多写点这样的文章啊，不必非得人生感悟哇，把技术知识点形象话就很造福啦。</p>
<ol>
<li><img src="" alt=""></li>
</ol>
<p>kunpengku</p>
<p>2013年6月21日21:00 | <a href="">/#14</a></p>
<p><a href="">回复</a> | <a href="">引用</a>
文章写的非常好，关于算法和人生的结合。</p>
<ol>
<li><img src="" alt=""></li>
</ol>
<p><a href="http://my.oschina.net/nicefan" target="_blank">Fan.Action</a></p>
<p>2013年6月28日16:23 | <a href="">/#15</a></p>
<p><a href="">回复</a> | <a href="">引用</a>
很受启发，很好文章，很受启发！</p>
<ol>
<li><img src="" alt=""></li>
</ol>
<p><a href="http://blog.csdn.net/mxdlove00" target="_blank">大灰狼</a></p>
<p>2013年7月2日12:47 | <a href="">/#16</a></p>
<p><a href="">回复</a> | <a href="">引用</a>
楼主这样的才算是真正的活学活用啊，我感觉我的算法白学了。楼主的这种抽象思维值得学习！</p>
<ol>
<li><img src="" alt=""></li>
</ol>
<p>呢喃的猫咪</p>
<p>2013年7月12日10:47 | <a href="">/#17</a></p>
<p><a href="">回复</a> | <a href="">引用</a>
我是在其他地方看到这篇文章，然后追过来的。
我很喜欢算法，但很遗憾我不懂算法，唯一值得庆幸的是，大学里学的数学专业，现在也算在做编程的工作。文章的的几种算法，每一种几乎都是我大学里地一门专业课。
把对算法的理解融入到人生和职场，才能引发程序员们的共鸣啊。对大部分程序员来说，图片和语言很多时候都显得很苍白无力，很多人都不屑于去看文字去读文字，有时候我也会觉得看那么多废话不如多看多写两行代码来的实在，只是，偶尔真的需要停下来思考思考。这篇从程序员的视角切入的感悟，才能真正引人深思啊。</p>
<ol>
<li><img src="" alt=""></li>
</ol>
<p>呢喃的猫咪</p>
<p>2013年7月12日11:11 | <a href="">/#18</a></p>
<p><a href="">回复</a> | <a href="">引用</a>
算法效率不高，也许达到你的目标，你在一开始花了很长时间，遍历了很多地方，但是，这也许这就是你的最短路径。</p>
<p>我最认可的一句话，因为我终于明白为什么在所有的否定之下我仍然能坚持自己所做之事。我一直相信，也许我现在做的对目前而言不是最优的，但一定是离初始目的最近的。
评论分页</p>
<p><a href="http://coolshell.cn/articles/8790.html/comment-page-3#comments" target="_blank">« 上一页</a> <a href="http://coolshell.cn/articles/8790.html/comment-page-1#comments" target="_blank">1</a> <a href="http://coolshell.cn/articles/8790.html/comment-page-2#comments" target="_blank">2</a> <a href="http://coolshell.cn/articles/8790.html/comment-page-3#comments" target="_blank">3</a> 4 8790</p>
<ol>
<li>2012年12月29日23:14 | <a href="">/#1</a></li>
</ol>
<p><a href="http://argcandargv.com/archives/936" target="_blank">程序算法与人生选择 | argc &amp;&amp; argv</a></p>
<ol>
<li>2012年12月30日20:05 | <a href="">/#2</a></li>
</ol>
<p><a href="http://binary.duapp.com/2012/12/972.html" target="_blank">程序算法与人生选择 | 蜗牛都知道</a></p>
<ol>
<li>2013年1月2日09:23 | <a href="">/#3</a></li>
</ol>
<p><a href="http://www.coderli.com/%e7%a8%8b%e5%ba%8f%e7%ae%97%e6%b3%95%e4%b8%8e%e4%ba%ba%e7%94%9f%e9%80%89%e6%8b%a9" target="_blank">程序算法与人生选择 | OneCoder</a></p>
<ol>
<li>2013年1月5日10:29 | <a href="">/#4</a></li>
</ol>
<p><a href="http://php8848.com/3620.html" target="_blank">我所看到的那些博主的2012年工作总结 | 高度PHP</a></p>
<ol>
<li>2013年1月5日10:45 | <a href="">/#5</a></li>
</ol>
<p><a href="http://g00.asia/2013/01/94.html" target="_blank">程序算法与人生选择 | grace自留地</a></p>
<ol>
<li>2013年1月7日16:01 | <a href="">/#6</a></li>
</ol>
<p><a href="http://www.67tgb.com/?p=532" target="_blank">望月听涛 » 2012年度工作总结</a></p>
<ol>
<li>2013年1月7日16:18 | <a href="">/#7</a></li>
</ol>
<p><a href="http://architecture.riaos.com/?p=3017963" target="_blank">2012年度工作总结 | 架构（architecture.riaos.com）</a></p>
<ol>
<li>2013年2月23日22:28 | <a href="">/#8</a></li>
</ol>
<p><a href="http://sirx.wordpress.com.cn/2013/02/23/%e7%a8%8b%e5%ba%8f%e7%ae%97%e6%b3%95%e4%b8%8e%e4%ba%ba%e7%94%9f%e9%80%89%e6%8b%a9z/" target="_blank">程序算法与人生选择[z] » 笑笑先生</a></p>
<ol>
<li>2013年4月10日15:35 | <a href="">/#9</a></li>
</ol>
<p><a href="http://codingke.sinaapp.com/?p=4" target="_blank">Codingke-左手代码右手湿 » 《Rework》摘录及感想</a></p>
<ol>
<li>2013年4月12日14:44 | <a href="">/#10</a></li>
</ol>
<p><a href="http://codingke.sinaapp.com/?p=42" target="_blank">Codingke-编程疯子 » 《Rework》摘录及感想</a></p>
<ol>
<li>2013年4月20日09:49 | <a href="">/#11</a></li>
</ol>
<p><a href="http://www.ruanfei.com/news/archives/77" target="_blank">一个程序员对《Rework》的摘录及感想 – 软飞</a></p>
<ol>
<li>2013年5月15日15:19 | <a href="">/#12</a></li>
</ol>
<p><a href="http://www.w3c.com.cn/%e7%a8%8b%e5%ba%8f%e7%ae%97%e6%b3%95%e4%b8%8e%e4%ba%ba%e7%94%9f%e9%80%89%e6%8b%a9" target="_blank">程序算法与人生选择 – Sina App Engine – 开发者问答</a>
昵称 (必填)</p>
<p>电子邮箱 (我们会为您保密) (必填)
网址</p>
<p><a href="http://coolshell.cn/comments/feed" target="_blank">订阅评论</a></p>
<p><a href="http://coolshell.cn/articles/8883.html" target="_blank">应该知道的Linux技巧</a> <a href="http://coolshell.cn/articles/8767.html" target="_blank">Web工程师的工具箱</a></p>
<p><a href="http://coolshell.cn/feed" title="订阅这个博客的文章" target="_blank">订阅</a></p>
<ul>
<li><a href="http://fusion.google.com/add?feedurl=http://coolshell.cn/feed" title="订阅到 Google" target="_blank">Google</a></li>
<li><a href="http://reader.youdao.com/#url=http://coolshell.cn/feed" title="订阅到有道" target="_blank">有道</a></li>
<li><a href="http://www.xianguo.com/subscribe.php?url=http://coolshell.cn/feed" title="订阅到鲜果" target="_blank">鲜果</a></li>
<li><a href="http://www.zhuaxia.com/add_channel.php?url=http://coolshell.cn/feed" title="订阅到抓虾" target="_blank">抓虾</a></li>
<li><a href="http://add.my.yahoo.com/rss?url=http://coolshell.cn/feed" title="订阅到 My Yahoo!" target="_blank">My Yahoo!</a></li>
<li><a href="http://www.newsgator.com/ngs/subscriber/subfext.aspx?url=http://coolshell.cn/feed" title="订阅到 newsgator" target="_blank">newsgator</a></li>
<li><a href="http://www.bloglines.com/sub/http://coolshell.cn/feed" title="订阅到 Bloglines" target="_blank">Bloglines</a></li>
<li><a href="http://inezha.com/add?url=http://coolshell.cn/feed" title="订阅到哪吒" target="_blank">哪吒</a></li>
<li><a href="http://mail.qq.com/cgi-bin/feed?u=http://coolshell.cn/feed" title="订阅到QQ Mail" target="_blank">QQ Mail</a></li>
<li><a href="http://9.douban.com/reader/subscribe?url=http://coolshell.cn/feed" title="订阅到Douban" target="_blank">Douban</a></li>
<li><a href="http://www.rojo.com/add-subscription?resource=http://coolshell.cn/feed" title="订阅到Rojo" target="_blank">Rojo</a></li>
<li><a href="http://www.pageflakes.com/subscribe.aspx?url=http://coolshell.cn/feed" title="订阅到Pageflakes" target="_blank">Pageflakes</a>
<a href="http://twitter.com/haoel/" title="Follow me!" target="_blank">Twitter</a></li>
</ul>
<h3 id="-">本站公告</h3>
<p>访问 <a href="http://coolshell.cn/404/" target="_blank">酷壳404页面</a> 支持公益！</p>
<p>酷壳建议大家多使用RSS访问阅读（本站已经是全文输出，推荐使用cloud.feedly.com）。有相关事宜欢迎电邮：haoel(at)hotmail.com。最后，感谢大家对酷壳的支持和体谅！</p>
<p><strong>感谢 <a href="http://42qu.com/" title="42区 找到给你答案的人" target="_blank">42qu.com</a> 为本站提供 <a href="http://vps.42qu.com/" title="42区虚拟主机，卖给创业的你" target="_blank">VPS</a></strong></p>
<h3 id="-">最新文章</h3>
<ul>
<li><a href="http://coolshell.cn/articles/10217.html" title="加班与效率" target="_blank">加班与效率</a></li>
<li><a href="http://coolshell.cn/articles/10169.html" title="类型的本质和函数式实现" target="_blank">类型的本质和函数式实现</a></li>
<li><a href="http://coolshell.cn/articles/10115.html" title="C语言全局变量那些事儿" target="_blank">C语言全局变量那些事儿</a></li>
<li><a href="http://coolshell.cn/articles/9886.html" title="二叉树迭代器算法" target="_blank">二叉树迭代器算法</a></li>
<li><a href="http://coolshell.cn/articles/9917.html" title="Alan Cox：大教堂、市集与市议会" target="_blank">Alan Cox：大教堂、市集与市议会</a></li>
<li><a href="http://coolshell.cn/articles/9949.html" title="IoC/DIP其实是一种管理思想" target="_blank">IoC/DIP其实是一种管理思想</a></li>
<li><a href="http://coolshell.cn/articles/9859.html" title="Alan Cox：单向链表中prev指针的妙用" target="_blank">Alan Cox：单向链表中prev指针的妙用</a></li>
<li><a href="http://coolshell.cn/articles/9749.html" title="Javascript 装载和执行" target="_blank">Javascript 装载和执行</a></li>
<li><a href="http://coolshell.cn/articles/9703.html" title="无锁HashMap的原理与实现" target="_blank">无锁HashMap的原理与实现</a></li>
<li><a href="http://coolshell.cn/articles/9666.html" title="浏览器的渲染原理简介" target="_blank">浏览器的渲染原理简介</a></li>
<li><a href="http://coolshell.cn/articles/9606.html" title="疫苗：Java HashMap的死循环" target="_blank">疫苗：Java HashMap的死循环</a></li>
<li><a href="http://coolshell.cn/articles/9543.html" title="“C++的数组不支持多态”？" target="_blank">“C++的数组不支持多态”？</a></li>
<li><a href="http://coolshell.cn/articles/9410.html" title="Unix考古记：一个“遗失”的shell" target="_blank">Unix考古记：一个“遗失”的shell</a></li>
<li><a href="http://coolshell.cn/articles/9508.html" title="PFIF网上寻人协议" target="_blank">PFIF网上寻人协议</a></li>
<li><a href="http://coolshell.cn/articles/9308.html" title="“作环保的程序员，从不用百度开始”" target="_blank">“作环保的程序员，从不用百度开始”</a></li>
<li><a href="http://coolshell.cn/articles/9156.html" title="《Rework》摘录及感想" target="_blank">《Rework》摘录及感想</a></li>
<li><a href="http://coolshell.cn/articles/9229.html" title="实例分析Java Class的文件结构" target="_blank">实例分析Java Class的文件结构</a></li>
<li><a href="http://coolshell.cn/articles/9169.html" title="并发框架Disruptor译文" target="_blank">并发框架Disruptor译文</a></li>
<li><a href="http://coolshell.cn/articles/9104.html" title="sed 简明教程" target="_blank">sed 简明教程</a></li>
<li><a href="http://coolshell.cn/articles/9070.html" title="AWK 简明教程" target="_blank">AWK 简明教程</a></li>
<li><a href="http://coolshell.cn/articles/8990.html" title="Linus：利用二级指针删除单向链表" target="_blank">Linus：利用二级指针删除单向链表</a></li>
<li><a href="http://coolshell.cn/articles/8961.html" title="从面向对象的设计模式看软件设计" target="_blank">从面向对象的设计模式看软件设计</a></li>
<li><a href="http://coolshell.cn/articles/8883.html" title="应该知道的Linux技巧" target="_blank">应该知道的Linux技巧</a></li>
<li><a href="http://coolshell.cn/articles/8790.html" title="程序算法与人生选择" target="_blank">程序算法与人生选择</a></li>
<li><a href="http://coolshell.cn/articles/8767.html" title="Web工程师的工具箱" target="_blank">Web工程师的工具箱</a></li>
<li><a href="http://coolshell.cn/articles/8745.html" title="如此理解面向对象编程" target="_blank">如此理解面向对象编程</a></li>
<li><a href="http://coolshell.cn/articles/8711.html" title="程序员疫苗：代码注入" target="_blank">程序员疫苗：代码注入</a></li>
<li><a href="http://coolshell.cn/articles/8619.html" title="你可能不知道的Shell" target="_blank">你可能不知道的Shell</a></li>
<li><a href="http://coolshell.cn/articles/8638.html" title="为什么不能用微信或米聊这类的软件" target="_blank">为什么不能用微信或米聊这类的软件</a></li>
<li><a href="http://coolshell.cn/articles/8593.html" title="如何测试洗牌程序" target="_blank">如何测试洗牌程序</a></li>
</ul>
<h3 id="-">全站热门</h3>
<ul>
<li><a href="http://coolshell.cn/articles/4990.html" title="程序员技术练级攻略 - 312,422 人阅读" target="_blank">程序员技术练级攻略</a></li>
<li><a href="http://coolshell.cn/articles/5426.html" title="简明 Vim 练级攻略 - 234,355 人阅读" target="_blank">简明 Vim 练级攻略</a></li>
<li><a href="http://coolshell.cn/articles/4102.html" title="如何学好C语言 - 117,770 人阅读" target="_blank">如何学好C语言</a></li>
<li><a href="http://coolshell.cn/articles/914.html" title="6个变态的C语言Hello World程序 - 113,320 人阅读" target="_blank">6个变态的C语言Hello World程序</a></li>
<li><a href="http://coolshell.cn/articles/6470.html" title="由12306.cn谈谈网站性能技术 - 93,543 人阅读" target="_blank">由12306.cn谈谈网站性能技术</a></li>
<li><a href="http://coolshell.cn/articles/8883.html" title="应该知道的Linux技巧 - 89,617 人阅读" target="_blank">应该知道的Linux技巧</a></li>
<li><a href="http://coolshell.cn/articles/2250.html" title="“21天教你学会C++” - 89,390 人阅读" target="_blank">“21天教你学会C++”</a></li>
<li><a href="http://coolshell.cn/articles/3549.html" title="Android将允许纯C/C++开发应用 - 88,606 人阅读" target="_blank">Android将允许纯C/C++开发应用</a></li>
<li><a href="http://coolshell.cn/articles/1870.html" title="我是怎么招聘程序员的 - 87,272 人阅读" target="_blank">我是怎么招聘程序员的</a></li>
<li><a href="http://coolshell.cn/articles/7186.html" title="做个环保主义的程序员 - 84,428 人阅读" target="_blank">做个环保主义的程序员</a></li>
<li><a href="http://coolshell.cn/articles/9308.html" title="“作环保的程序员，从不用百度开始” - 80,045 人阅读" target="_blank">“作环保的程序员，从不用百度开始”</a></li>
<li><a href="http://coolshell.cn/articles/7829.html" title="28个Unix/Linux的命令行神器 - 75,080 人阅读" target="_blank">28个Unix/Linux的命令行神器</a></li>
<li><a href="http://coolshell.cn/articles/1391.html" title="编程真难啊 - 70,871 人阅读" target="_blank">编程真难啊</a></li>
<li><a href="http://coolshell.cn/articles/2287.html" title="C++ 程序员自信心曲线图 - 70,709 人阅读" target="_blank">C++ 程序员自信心曲线图</a></li>
<li><a href="http://coolshell.cn/articles/6043.html" title="Web开发中需要了解的东西 - 69,987 人阅读" target="_blank">Web开发中需要了解的东西</a></li>
<li><a href="http://coolshell.cn/articles/5701.html" title="SteveY对Amazon和Google平台的吐槽 - 69,372 人阅读" target="_blank">SteveY对Amazon和Google平台的吐槽</a></li>
<li><a href="http://coolshell.cn/articles/355.html" title="20本最好的Linux免费书籍 - 68,994 人阅读" target="_blank">20本最好的Linux免费书籍</a></li>
<li><a href="http://coolshell.cn/articles/4758.html" title="如何写出无法维护的代码 - 65,186 人阅读" target="_blank">如何写出无法维护的代码</a></li>
<li><a href="http://coolshell.cn/articles/8790.html" title="程序算法与人生选择 - 63,218 人阅读" target="_blank">程序算法与人生选择</a></li>
<li><a href="http://coolshell.cn/articles/2058.html" title="各种流行的编程风格 - 63,082 人阅读" target="_blank">各种流行的编程风格</a></li>
<li><a href="http://coolshell.cn/articles/3008.html" title="Windows编程革命简史 - 61,890 人阅读" target="_blank">Windows编程革命简史</a></li>
<li><a href="http://coolshell.cn/articles/4119.html" title="如何学好C++语言 - 61,778 人阅读" target="_blank">如何学好C++语言</a></li>
<li><a href="http://coolshell.cn/articles/5761.html" title="深入理解C语言 - 61,397 人阅读" target="_blank">深入理解C语言</a></li>
<li><a href="http://coolshell.cn/articles/4429.html" title="面试题：火车运煤问题 - 60,295 人阅读" target="_blank">面试题：火车运煤问题</a></li>
<li><a href="http://coolshell.cn/articles/6142.html" title="三个事和三个问题 - 59,185 人阅读" target="_blank">三个事和三个问题</a></li>
<li><a href="http://coolshell.cn/articles/1695.html" title="别的程序员是怎么读你的简历的 - 57,916 人阅读" target="_blank">别的程序员是怎么读你的简历的</a></li>
<li><a href="http://coolshell.cn/articles/2420.html" title="老手是这样教新手编程的 - 56,712 人阅读" target="_blank">老手是这样教新手编程的</a></li>
<li><a href="http://coolshell.cn/articles/945.html" title="C语言的谜题 - 54,791 人阅读" target="_blank">C语言的谜题</a></li>
<li><a href="http://coolshell.cn/articles/3363.html" title="偷了世界的程序员 - 54,702 人阅读" target="_blank">偷了世界的程序员</a></li>
<li><a href="http://coolshell.cn/articles/4506.html" title="再谈“我是怎么招聘程序员的”（上） - 54,089 人阅读" target="_blank">再谈“我是怎么招聘程序员的”（上）</a><h3 id="-">新浪微博</h3>
</li>
</ul>
<h3 id="-">标签</h3>
<p><a href="http://coolshell.cn/tag/agile" title="15 个话题" target="_blank">agile</a> <a href="http://coolshell.cn/tag/ajax" title="11 个话题" target="_blank">AJAX</a> <a href="http://coolshell.cn/tag/algorithm" title="20 个话题" target="_blank">Algorithm</a> <a href="http://coolshell.cn/tag/android" title="8 个话题" target="_blank">Android</a> <a href="http://coolshell.cn/tag/bash" title="8 个话题" target="_blank">Bash</a> <a href="http://coolshell.cn/tag/c" title="74 个话题" target="_blank">C++</a> <a href="http://coolshell.cn/tag/coding" title="25 个话题" target="_blank">Coding</a> <a href="http://coolshell.cn/tag/css" title="21 个话题" target="_blank">CSS</a> <a href="http://coolshell.cn/tag/database" title="7 个话题" target="_blank">Database</a> <a href="http://coolshell.cn/tag/design" title="17 个话题" target="_blank">Design</a> <a href="http://coolshell.cn/tag/design-pattern" title="8 个话题" target="_blank">design pattern</a> <a href="http://coolshell.cn/tag/ebook" title="15 个话题" target="_blank">ebook</a> <a href="http://coolshell.cn/tag/flash" title="7 个话题" target="_blank">Flash</a> <a href="http://coolshell.cn/tag/game" title="9 个话题" target="_blank">Game</a> <a href="http://coolshell.cn/tag/go" title="9 个话题" target="_blank">Go</a> <a href="http://coolshell.cn/tag/google" title="31 个话题" target="_blank">Google</a> <a href="http://coolshell.cn/tag/html" title="32 个话题" target="_blank">HTML</a> <a href="http://coolshell.cn/tag/ie" title="10 个话题" target="_blank">IE</a> <a href="http://coolshell.cn/tag/java" title="45 个话题" target="_blank">Java</a> <a href="http://coolshell.cn/tag/javascript" title="48 个话题" target="_blank">Javascript</a> <a href="http://coolshell.cn/tag/jquery" title="11 个话题" target="_blank">jQuery</a> <a href="http://coolshell.cn/tag/linux" title="58 个话题" target="_blank">Linux</a> <a href="http://coolshell.cn/tag/mysql" title="7 个话题" target="_blank">MySQL</a> <a href="http://coolshell.cn/tag/oop" title="8 个话题" target="_blank">OOP</a> <a href="http://coolshell.cn/tag/password" title="8 个话题" target="_blank">password</a> <a href="http://coolshell.cn/tag/performance" title="13 个话题" target="_blank">Performance</a> <a href="http://coolshell.cn/tag/php" title="25 个话题" target="_blank">PHP</a> <a href="http://coolshell.cn/tag/programmer" title="88 个话题" target="_blank">Programmer</a> <a href="http://coolshell.cn/tag/programming-language" title="12 个话题" target="_blank">programming language</a> <a href="http://coolshell.cn/tag/puzzle" title="9 个话题" target="_blank">Puzzle</a> <a href="http://coolshell.cn/tag/pythondev" title="27 个话题" target="_blank">Python</a> <a href="http://coolshell.cn/tag/ruby" title="9 个话题" target="_blank">Ruby</a> <a href="http://coolshell.cn/tag/sql" title="10 个话题" target="_blank">SQL</a> <a href="http://coolshell.cn/tag/tdd" title="8 个话题" target="_blank">TDD</a> <a href="http://coolshell.cn/tag/ui" title="12 个话题" target="_blank">UI</a> <a href="http://coolshell.cn/tag/unix" title="31 个话题" target="_blank">Unix</a> <a href="http://coolshell.cn/tag/vim" title="18 个话题" target="_blank">vim</a> <a href="http://coolshell.cn/tag/web" title="35 个话题" target="_blank">Web</a> <a href="http://coolshell.cn/tag/windows" title="17 个话题" target="_blank">Windows</a> <a href="http://coolshell.cn/tag/xml" title="8 个话题" target="_blank">XML</a> <a href="http://coolshell.cn/tag/%e5%8f%a3%e4%bb%a4" title="7 个话题" target="_blank">口令</a> <a href="http://coolshell.cn/tag/%e5%ae%89%e5%85%a8" title="16 个话题" target="_blank">安全</a> <a href="http://coolshell.cn/tag/%e7%a8%8b%e5%ba%8f%e5%91%98" title="88 个话题" target="_blank">程序员</a> <a href="http://coolshell.cn/tag/%e7%ae%97%e6%b3%95" title="9 个话题" target="_blank">算法</a> <a href="http://coolshell.cn/tag/interview" title="14 个话题" target="_blank">面试</a></p>
<h3 id="-">分类目录</h3>
<ul>
<li><a href="http://coolshell.cn/category/proglanguage/dotnet" title="查看 .NET编程 下的所有文章" target="_blank">.NET编程</a> (2)</li>
<li><a href="http://coolshell.cn/category/proglanguage/ajaxdev" title="查看 Ajax开发 下的所有文章" target="_blank">Ajax开发</a> (9)</li>
<li><a href="http://coolshell.cn/category/proglanguage/cplusplus" title="查看 C/C++语言 下的所有文章" target="_blank">C/C++语言</a> (53)</li>
<li><a href="http://coolshell.cn/category/proglanguage/erlang" title="查看 Erlang 下的所有文章" target="_blank">Erlang</a> (1)</li>
<li><a href="http://coolshell.cn/category/proglanguage/javadev" title="查看 Java语言 下的所有文章" target="_blank">Java语言</a> (29)</li>
<li><a href="http://coolshell.cn/category/proglanguage/phpdev" title="查看 PHP脚本 下的所有文章" target="_blank">PHP脚本</a> (11)</li>
<li><a href="http://coolshell.cn/category/proglanguage/pythondev" title="查看 Python 下的所有文章" target="_blank">Python</a> (21)</li>
<li><a href="http://coolshell.cn/category/proglanguage/rubydev" title="查看 Ruby 下的所有文章" target="_blank">Ruby</a> (4)</li>
<li><a href="http://coolshell.cn/category/operatingsystem/unixlinux" title="查看 Unix/Linux 下的所有文章" target="_blank">Unix/Linux</a> (66)</li>
<li><a href="http://coolshell.cn/category/proglanguage/webdev" title="查看 Web开发 下的所有文章" target="_blank">Web开发</a> (99)</li>
<li><a href="http://coolshell.cn/category/operatingsystem/mswindows" title="查看 Windows 下的所有文章" target="_blank">Windows</a> (12)</li>
<li><a href="http://coolshell.cn/category/itnews" title="查看 业界新闻 下的所有文章" target="_blank">业界新闻</a> (25)</li>
<li><a href="http://coolshell.cn/category/%e4%bc%81%e4%b8%9a%e5%ba%94%e7%94%a8" title="查看 企业应用 下的所有文章" target="_blank">企业应用</a> (2)</li>
<li><a href="http://coolshell.cn/category/technews" title="查看 技术新闻 下的所有文章" target="_blank">技术新闻</a> (32)</li>
<li><a href="http://coolshell.cn/category/%e6%8a%80%e6%9c%af%e7%ae%a1%e7%90%86" title="查看 技术管理 下的所有文章" target="_blank">技术管理</a> (10)</li>
<li><a href="http://coolshell.cn/category/techarticle" title="查看 技术读物 下的所有文章" target="_blank">技术读物</a> (115)</li>
<li><a href="http://coolshell.cn/category/operatingsystem" title="查看 操作系统 下的所有文章" target="_blank">操作系统</a> (43)</li>
<li><a href="http://coolshell.cn/category/datebase" title="查看 数据库 下的所有文章" target="_blank">数据库</a> (10)</li>
<li><a href="http://coolshell.cn/category/misc" title="查看 杂项资源 下的所有文章" target="_blank">杂项资源</a> (249)</li>
<li><a href="http://coolshell.cn/category/process" title="查看 流程方法 下的所有文章" target="_blank">流程方法</a> (43)</li>
<li><a href="http://coolshell.cn/category/progdesign" title="查看 程序设计 下的所有文章" target="_blank">程序设计</a> (69)</li>
<li><a href="http://coolshell.cn/category/%e7%b3%bb%e7%bb%9f%e6%9e%b6%e6%9e%84" title="查看 系统架构 下的所有文章" target="_blank">系统架构</a> (6)</li>
<li><a href="http://coolshell.cn/category/tools" title="查看 编程工具 下的所有文章" target="_blank">编程工具</a> (61)</li>
<li><a href="http://coolshell.cn/category/proglanguage" title="查看 编程语言 下的所有文章" target="_blank">编程语言</a> (159)</li>
<li><a href="http://coolshell.cn/category/netsecurity" title="查看 网络安全 下的所有文章" target="_blank">网络安全</a> (22)</li>
<li><a href="http://coolshell.cn/category/career" title="查看 职场生涯 下的所有文章" target="_blank">职场生涯</a> (32)</li>
<li><a href="http://coolshell.cn/category/funny" title="查看 趣味问题 下的所有文章" target="_blank">趣味问题</a> (13)</li>
<li><a href="http://coolshell.cn/category/story" title="查看 轶事趣闻 下的所有文章" target="_blank">轶事趣闻</a> (145)</li>
</ul>
<h3 id="-">归档</h3>
<ul>
<li><a href="http://coolshell.cn/articles/date/2013/07" title="2013 年七月" target="_blank">2013 年七月</a> (6)</li>
<li><a href="http://coolshell.cn/articles/date/2013/06" title="2013 年六月" target="_blank">2013 年六月</a> (2)</li>
<li><a href="http://coolshell.cn/articles/date/2013/05" title="2013 年五月" target="_blank">2013 年五月</a> (3)</li>
<li><a href="http://coolshell.cn/articles/date/2013/04" title="2013 年四月" target="_blank">2013 年四月</a> (3)</li>
<li><a href="http://coolshell.cn/articles/date/2013/03" title="2013 年三月" target="_blank">2013 年三月</a> (3)</li>
<li><a href="http://coolshell.cn/articles/date/2013/02" title="2013 年二月" target="_blank">2013 年二月</a> (5)</li>
<li><a href="http://coolshell.cn/articles/date/2013/01" title="2013 年一月" target="_blank">2013 年一月</a> (1)</li>
<li><a href="http://coolshell.cn/articles/date/2012/12" title="2012 年十二月" target="_blank">2012 年十二月</a> (4)</li>
<li><a href="http://coolshell.cn/articles/date/2012/11" title="2012 年十一月" target="_blank">2012 年十一月</a> (5)</li>
<li><a href="http://coolshell.cn/articles/date/2012/10" title="2012 年十月" target="_blank">2012 年十月</a> (3)</li>
<li><a href="http://coolshell.cn/articles/date/2012/09" title="2012 年九月" target="_blank">2012 年九月</a> (4)</li>
<li><a href="http://coolshell.cn/articles/date/2012/08" title="2012 年八月" target="_blank">2012 年八月</a> (8)</li>
<li><a href="http://coolshell.cn/articles/date/2012/07" title="2012 年七月" target="_blank">2012 年七月</a> (4)</li>
<li><a href="http://coolshell.cn/articles/date/2012/06" title="2012 年六月" target="_blank">2012 年六月</a> (7)</li>
<li><a href="http://coolshell.cn/articles/date/2012/05" title="2012 年五月" target="_blank">2012 年五月</a> (6)</li>
<li><a href="http://coolshell.cn/articles/date/2012/04" title="2012 年四月" target="_blank">2012 年四月</a> (6)</li>
<li><a href="http://coolshell.cn/articles/date/2012/03" title="2012 年三月" target="_blank">2012 年三月</a> (6)</li>
<li><a href="http://coolshell.cn/articles/date/2012/02" title="2012 年二月" target="_blank">2012 年二月</a> (3)</li>
<li><a href="http://coolshell.cn/articles/date/2012/01" title="2012 年一月" target="_blank">2012 年一月</a> (6)</li>
<li><a href="http://coolshell.cn/articles/date/2011/12" title="2011 年十二月" target="_blank">2011 年十二月</a> (5)</li>
<li><a href="http://coolshell.cn/articles/date/2011/11" title="2011 年十一月" target="_blank">2011 年十一月</a> (9)</li>
<li><a href="http://coolshell.cn/articles/date/2011/10" title="2011 年十月" target="_blank">2011 年十月</a> (6)</li>
<li><a href="http://coolshell.cn/articles/date/2011/09" title="2011 年九月" target="_blank">2011 年九月</a> (5)</li>
<li><a href="http://coolshell.cn/articles/date/2011/08" title="2011 年八月" target="_blank">2011 年八月</a> (14)</li>
<li><a href="http://coolshell.cn/articles/date/2011/07" title="2011 年七月" target="_blank">2011 年七月</a> (6)</li>
<li><a href="http://coolshell.cn/articles/date/2011/06" title="2011 年六月" target="_blank">2011 年六月</a> (12)</li>
<li><a href="http://coolshell.cn/articles/date/2011/05" title="2011 年五月" target="_blank">2011 年五月</a> (5)</li>
<li><a href="http://coolshell.cn/articles/date/2011/04" title="2011 年四月" target="_blank">2011 年四月</a> (18)</li>
<li><a href="http://coolshell.cn/articles/date/2011/03" title="2011 年三月" target="_blank">2011 年三月</a> (16)</li>
<li><a href="http://coolshell.cn/articles/date/2011/02" title="2011 年二月" target="_blank">2011 年二月</a> (16)</li>
<li><a href="http://coolshell.cn/articles/date/2011/01" title="2011 年一月" target="_blank">2011 年一月</a> (18)</li>
<li><a href="http://coolshell.cn/articles/date/2010/12" title="2010 年十二月" target="_blank">2010 年十二月</a> (11)</li>
<li><a href="http://coolshell.cn/articles/date/2010/11" title="2010 年十一月" target="_blank">2010 年十一月</a> (11)</li>
<li><a href="http://coolshell.cn/articles/date/2010/10" title="2010 年十月" target="_blank">2010 年十月</a> (19)</li>
<li><a href="http://coolshell.cn/articles/date/2010/09" title="2010 年九月" target="_blank">2010 年九月</a> (15)</li>
<li><a href="http://coolshell.cn/articles/date/2010/08" title="2010 年八月" target="_blank">2010 年八月</a> (10)</li>
<li><a href="http://coolshell.cn/articles/date/2010/07" title="2010 年七月" target="_blank">2010 年七月</a> (20)</li>
<li><a href="http://coolshell.cn/articles/date/2010/06" title="2010 年六月" target="_blank">2010 年六月</a> (9)</li>
<li><a href="http://coolshell.cn/articles/date/2010/05" title="2010 年五月" target="_blank">2010 年五月</a> (13)</li>
<li><a href="http://coolshell.cn/articles/date/2010/04" title="2010 年四月" target="_blank">2010 年四月</a> (12)</li>
<li><a href="http://coolshell.cn/articles/date/2010/03" title="2010 年三月" target="_blank">2010 年三月</a> (11)</li>
<li><a href="http://coolshell.cn/articles/date/2010/02" title="2010 年二月" target="_blank">2010 年二月</a> (7)</li>
<li><a href="http://coolshell.cn/articles/date/2010/01" title="2010 年一月" target="_blank">2010 年一月</a> (9)</li>
<li><a href="http://coolshell.cn/articles/date/2009/12" title="2009 年十二月" target="_blank">2009 年十二月</a> (22)</li>
<li><a href="http://coolshell.cn/articles/date/2009/11" title="2009 年十一月" target="_blank">2009 年十一月</a> (27)</li>
<li><a href="http://coolshell.cn/articles/date/2009/10" title="2009 年十月" target="_blank">2009 年十月</a> (17)</li>
<li><a href="http://coolshell.cn/articles/date/2009/09" title="2009 年九月" target="_blank">2009 年九月</a> (15)</li>
<li><a href="http://coolshell.cn/articles/date/2009/08" title="2009 年八月" target="_blank">2009 年八月</a> (21)</li>
<li><a href="http://coolshell.cn/articles/date/2009/07" title="2009 年七月" target="_blank">2009 年七月</a> (18)</li>
<li><a href="http://coolshell.cn/articles/date/2009/06" title="2009 年六月" target="_blank">2009 年六月</a> (19)</li>
<li><a href="http://coolshell.cn/articles/date/2009/05" title="2009 年五月" target="_blank">2009 年五月</a> (27)</li>
<li><a href="http://coolshell.cn/articles/date/2009/04" title="2009 年四月" target="_blank">2009 年四月</a> (53)</li>
<li><p><a href="http://coolshell.cn/articles/date/2009/03" title="2009 年三月" target="_blank">2009 年三月</a> (43)</p>
<h3 id="-">最新评论</h3>
</li>
<li><p><a href="http://coolshell.cn/articles/5132.html#comment-612339" title="疯狂的 Web 应用开源项目, 2011年08月11日" target="_blank">Coffee PUre Cleanse Diet</a>: Hi mates, how is the whole thing, and what you would like to say about this paragraph, in...</p>
</li>
<li><a href="http://coolshell.cn/articles/7186.html#comment-612323" title="做个环保主义的程序员, 2012年04月27日" target="_blank">Small Warm</a>: @呵呵 你认为用baidu就棱不到你吗</li>
<li><a href="http://coolshell.cn/articles/10217.html#comment-612301" title="加班与效率, 2013年07月24日" target="_blank">do</a>: 都是被勤能补拙害的. 天天加班的项目经理不是好程序猿</li>
<li><a href="http://coolshell.cn/articles/10217.html#comment-612246" title="加班与效率, 2013年07月24日" target="_blank">忧郁</a>: 加班没有加班费，是我一生中最大的痛</li>
<li><a href="http://coolshell.cn/guestbook#comment-612169" title="留言小本, 2009年03月02日" target="_blank">李巨宁</a>: 看了博主的几篇心得，觉得博主的语言很有重量，很踏实，实在是让 我获益良多，十分感谢。</li>
<li><a href="http://coolshell.cn/articles/3961.html#comment-612020" title="“火柴棍式”程序员面试题, 2011年03月21日" target="_blank">arrowcj</a>: 不能把i–变成i++么？</li>
<li><a href="http://coolshell.cn/articles/9859.html#comment-611941" title="Alan Cox：单向链表中prev指针的妙用, 2013年06月30日" target="_blank">Yeclipse</a>: The key point has nothing to do with linked list, nor with pre pointer. It just tries to avoid cloning one...</li>
<li><a href="http://coolshell.cn/articles/10217.html#comment-610764" title="加班与效率, 2013年07月24日" target="_blank">ForgetFul</a>: 中国是集体主义国家，其在人数和工作时间上的创造力总能让我惊叹</li>
<li><a href="http://coolshell.cn/articles/21.html#comment-610445" title="101个设计模式, 2009年03月02日" target="_blank">Darlena Failla</a>: First time visit here and have your terrific write-up. May I’ve a copy of the short article?</li>
<li><a href="http://coolshell.cn/articles/2394.html#comment-610430" title="九个PHP很有用的功能, 2010年05月06日" target="_blank">Octavia Vitera</a>: Wonderful collection, many thanks for sharing Eric :)</li>
<li><a href="http://coolshell.cn/articles/8745.html#comment-610422" title="如此理解面向对象编程, 2012年12月13日" target="_blank">Broderick Timmreck</a>: Many thanks for the backlink with podcast.</li>
<li><a href="http://coolshell.cn/articles/2492.html#comment-610416" title="WTF Javascript, 2010年06月02日" target="_blank">Joellen Pekara</a>: Extremely educational thanks, I reckon your current followers may well want even more well written...</li>
<li><a href="http://coolshell.cn/articles/4334.html#comment-610415" title="Eclipse开发Android应用程序入门:重装上阵, 2011年04月08日" target="_blank">Jonah Garvey</a>: I have been reading this blog for just a very good although. Keep up the magnificent job you are doing...</li>
<li><a href="http://coolshell.cn/articles/7992.html#comment-610407" title="C++的坑真的多吗？, 2012年08月06日" target="_blank">Shayla Sturk</a>: Oh and I am not a Liverpool or Chelsea supporter, but the way the Liverpool fans were still singing...</li>
<li><a href="http://coolshell.cn/articles/656.html#comment-610406" title="Linux 的僵尸(zombie)进程, 2009年04月25日" target="_blank">Nevada Riedlinger</a>: good app many thanks for sharing</li>
</ul>
<h3 id="-">友情链接</h3>
<ul>
<li><a href="http://blog.csdn.net/haoel" target="_blank">陈皓的博客</a></li>
<li><a href="http://ifeve.com/" title="促进并发编程的研究和推广" target="_blank">并发编程</a></li>
<li><a href="http://www.raychase.net/" title="一个啰嗦的程序员" target="_blank">四火的唠叨</a></li>
<li><a href="http://www.devtext.com/" title="我们关注互联网、关注软件开发、提供开发技术交流、问答平台" target="_blank">devtext 开发者社区</a></li>
<li><a href="http://claymore.phpme.info/" target="_blank">Claymore&#39;s blog</a></li>
<li><a href="http://www.dutor.net/" target="_blank">Dutor.net</a></li>
<li><a href="http://luy.li/" title="all linux" target="_blank">bones7456</a></li>
<li><a href="http://keeng2008.appspot.com/" title="Keengle&#39;s Blog" target="_blank">Keengle&#39;s Blog</a></li>
<li><a href="http://www.nowamagic.net/" title="专注于互联网主流的各种技术" target="_blank">简明现代魔法</a></li>
<li><a href="http://www.rosoo.net/" title="关注技术更新，关注行业动态。努力做到更好。" target="_blank">罗素工作室</a></li>
<li><a href="http://www.codecho.com/" title="聆听代码的回音" target="_blank">代码回音</a></li>
<li><a href="http://hellogcc.blogbus.com/" title="致力于讨论和学习GNU Toolchain方面的工作组" target="_blank">HelloGcc Working Group</a></li>
<li><a href="http://http://blog.lvscar.info/" title="Just for Fun" target="_blank">吕毅的Blog</a></li>
<li><a href="http://www.cnblogs.com/weidagang2046/" title="Just for Fun" target="_blank">Todd Wei的Blog</a></li>
<li><a href="http://www.cppfans.org/" title="记录我们点滴学习工作生活" target="_blank">C++爱好者博客</a></li>
<li><a href="http://www.mhtml5.com/" title="致力于HTML5在中国的发展与应用" target="_blank">HTML5研究小组</a></li>
<li><a href="http://www.12freeblog.com/" title="关注网站运营，分享技术心得" target="_blank">12Free</a></li>
<li><a href="http://zhuwenhao.com/" title="朱文昊的中文博客－－专注技术，向往自由" target="_blank">朱文昊Albert Zhu</a></li>
<li><a href="http://www.cguage.com/" title="某VC++软件开发爱好者" target="_blank">C瓜哥的博客</a></li>
<li><a href="http://www.kaiyuanba.cn/" title="汇聚各种开源项目的中英文混合介绍并分类排列，致力于软件项目的开源事业" target="_blank">开源吧</a></li>
<li><a href="http://www.stackpop.org/" title="靖难|魔都小码农" target="_blank">靖难|魔都小码农</a></li>
<li><a href="http://acm.zhihua-lai.com/" title="Smart Ideas, Smart Algorithms" target="_blank">ACMer</a></li>
<li><a href="http://chenpeng.info/" title="优秀的开源软件让生活更简单" target="_blank">陈鹏个人博客</a></li>
<li><a href="http://www.coderli.com/" title="一个普通的coder，coding为了生活，coding因为消遣:-) Just a coder" target="_blank">OneCoder</a></li>
<li><a href="http://www.crazyshell.org/blog/" title="专注于底层基础, TCP/IP, 存储, (高性能.高可用.分布式.高并发系统) 研究" target="_blank">狂Shell – Happy Hacking</a></li>
<li><a href="http://blog.tektea.com/" title="关注IT技术 | 分享 | 交流 | 记录" target="_blank">TekTea&#39;s Blog</a></li>
<li><p><a href="http://shellblog.sinaapp.com/" title="我有一颗百度的心。" target="_blank">夕水溪下</a></p>
<h3 id="-">功能</h3>
</li>
<li><p><a href="http://coolshell.cn/wp-login.php?action=register" target="_blank">注册</a></p>
</li>
<li><a href="http://coolshell.cn/wp-login.php" target="_blank">登录</a></li>
<li><a href="http://coolshell.cn/feed" title="使用 RSS 2.0 订阅本站点内容" target="_blank">文章 RSS</a></li>
<li><a href="http://coolshell.cn/comments/feed" title="使用 RSS 订阅本站点的所有文章的近期评论" target="_blank">评论 RSS</a></li>
<li><a href="http://cn.wordpress.org/" title="基于 WordPress，一个优美、先进的个人信息发布平台。" target="_blank">WordPress.org</a></li>
</ul>
<p><a href="http://www.cnzz.com/stat/website.php?web_id=1785679" title="站长统计" target="_blank"><img src="" alt=""></a></p>
<p><a href="">回到顶部</a> <a href="http://wordpress.org/" target="_blank">WordPress</a></p>
<p>版权所有 © 2009-2013 酷壳 – CoolShell.cn
主题由 <a href="http://www.neoease.com/" target="_blank">NeoEase</a> 提供, 通过 <a href="http://validator.w3.org/check?uri=referer" target="_blank">XHTML 1.1</a> 和 <a href="http://jigsaw.w3.org/css-validator/check/referer?profile=css3" target="_blank">CSS 3</a> 验证. <a href="http://www.cnzz.com/stat/website.php?web_id=1785679" title="站长统计" target="_blank"><img src="" alt=""></a></p>
<p><img src="" alt=""></p>
<p>检测到你还在使用百度这个搜索引擎，
做为一个程序员，这是一种自暴自弃！</p>
<p><strong><a href="http://coolshell.cn/articles/7186.html" target="_blank">做环保的程序员，从不用百度开始！</a></strong>
<img src="" alt=""></p>
<p>检测到你还在使用百度这个搜索引擎，
做为一个程序员，这是一种自暴自弃！</p>
<p><strong><a href="http://coolshell.cn/articles/7186.html" target="_blank">做环保的程序员，从不用百度开始！</a></strong></p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/好文摘录/">好文摘录</a></li></span></span> | <span class="time">recent updated:<time title="2014-03-07 11:24:29"datetime="2014-03-07 11:24:29"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/03/2014-02-03--程序算法与人生选择/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-03--程序算法与人生选择" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>





<ul id="pagination" class="pagination pagination-lg">
  <li><a class="extend prev" href="/page/2/">&laquo;</a></li><li><a class="page-number" href="/">1</a></li><li><a class="page-number" href="/page/2/">2</a></li><li><a class="page-number" href="/page/2/">2</a></li><li class="active"><li><span class="page-number current">3</span></li><li><a class="page-number" href="/page/4/">4</a></li><li><a class="page-number" href="/page/5/">5</a></li><li><a class="page-number" href="/page/6/">6</a></li><li><span class="space">&hellip;</span></li></li><li><a class="page-number" href="/page/164/">164</a></li><li><a class="page-number" href="/page/165/">165</a></li><li><a class="extend next" href="/page/4/">&raquo;</a></li>
  <div class="clearfix"></div>
</ul></div><!--wapper-->
       </div><!-- ID main-col END -->
       <aside id="sidebar" class="alignright col-sx-6 col-sm-4 col-md-3 col-lg-3">
<div id="widget_search" class="widget panel panel-primary">
    <form action="//google.com/search" method="get" accept-charset="utf-8">
  <div class="input-group">
    <input class="form-control" id="searchbox" type="search" name="q" results="0" placeholder="search">
    <span class="input-group-btn">
      <button class="btn btn-default" type="submit">Go!</button>
    </span>
    <input type="hidden" name="q" value="site:itsolife.com">
  </div>
</form>
</div>

<div id="widget_category" class="widget panel panel-primary">
  <div class="panel-heading">category</div>  <div data-src='category' class='ajax_widgets'>正在加载...</div>
</div>

<div id="widget_recent_posts" class="widget panel panel-primary">
  <div class="panel-heading">recent posts</div>  <div data-src='recent_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_tagcloud" class="widget panel panel-primary">
  <div class="panel-heading">tagcloud</div>  <div data-src='tagcloud' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_latest_update_posts" class="widget panel panel-primary">
  <div class="panel-heading">最近更新</div>  <div data-src='latest_update_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_recent_comments" class="widget panel panel-primary">
  <div class="panel-heading">recent comments</div>  

<div class="list-group-item ds-recent-comments" data-num-items="6" data-show-avatars="1" data-show-time="1" data-show-title="1" data-show-admin="1" data-excerpt-length="50"></div>



</div>

</aside>
       <div class="clearfix"></div>
     </div><!-- row END -->
  </div>
  <footer id="footer" class="container">
  <div class="panel panel-info">
  <section id='footer_widget'></section>  <div class="panel-footer">
  <div id="site-info">
    <span class='author'>
  
  &copy; 2014 RobinChia
  
    &nbsp;&nbsp;</span>
  
  <span id='analytics-51la'></span><span id='analytics-google'>
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-48559895-1']);
  _gaq.push(['_trackPageview']);
  _js2load.push({src:('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'});
</script></span><span id='analytics-cnzz'>
<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_5774006'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s17.cnzz.com/stat.php%3Fid%3D5774006%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>
</span><span id='analytics-baidu'>
<script>
var _hmt = _hmt || [];
_js2load.push({src:"//hm.baidu.com/hm.js?1442f50724afc42380b51f097c43082c"});
</script>
</span>  </div>
  <div id="copyright">Blog powered by <a href='http://zespia.tw/hexo/'><strong>hexo</strong></a> Theme <strong><a href='https://github.com/chenall/hexo-theme-chenall'>chenall</a></strong>(Some change in it)<span class="pull-right"> 更新时间: <em>2014-03-15 16:43:39</em></span></div>
</div>
<div class="clearfix"></div>


  </div>
  </footer>
  
        <script src="http://cdn.bootcss.com/jquery/1.10.2/jquery.min.js"></script>        
        <script src="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/js/bootstrap.min.js"></script>        
                
        <script src="http://cdn.bootcss.com/prettify/r298/prettify.min.js"></script>    <script type="text/javascript">
   var lang=["bsh", "c", "cc", "cpp", "cs", "csh", "cyc", "cv", "htm", "html",
    "java", "js", "m", "mxml", "perl", "pl", "pm", "py", "rb", "sh",
    "xhtml", "xml", "xsl"];
   var pretty_base='';
   $('script').each(function(){
	var c = $(this).attr('src');
	if (!c)
	    return;
	if (c.match(/(\/)?prettify(\.min)?\.js/i))
	{
	    var index = c.lastIndexOf('/');
	    if (index != -1)
		pretty_base = c.substr(0,index + 1);
	    return false;
	}
   })
   $('pre code').each(function(){
	var c = $(this).attr('class')
	if (!c)
	    return;
	c = c.match(/\s?(lang\-\w+)/i);
	if (c && lang.indexOf(c[1]) == -1)
	{
	    lang.push(c[1]);
	    $.getScript(pretty_base + c[1] + '.min.js');
	}
   })

    $(window).load(function(){
       $("pre").addClass("prettyprint");
       prettyPrint();
    })
</script>    
            <script type="text/javascript">
var duoshuoQuery = {short_name:"robinchia"};
_js2load.push({src:'http://static.duoshuo.com/embed.js',charset:'UTF-8'});
</script>
    
            <!--wumii_relatedItems-->
    
        <script src="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js"></script>    <script type="text/javascript">
(function($){
  $('.entry').each(function(i){
    $(this).find('img').each(function(){
      var alt = this.alt;

      if (alt){
        $(this).before('<span class="caption">' + alt + '</span>');
      }

      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox" rel="fancybox' + i + '" />');
    });
  });

  $('.fancybox').fancybox();
})(jQuery);
</script>    
        <script src="http://cdn.bootcss.com/mathjax/2.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>    <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>
    
<script type="text/javascript">
$('.ajax_widgets').each(function(){var src=$(this).attr('data-src');if(src)$(this).load('/widgets/'+src+'.html');});
$.each(_js2load,function(index,obj){loadjs(obj.src,obj.charset)});
</script>

<div id="scroll2top">
<img src="/scroll2top/arrow.png"/>
</div>
<script src="/scroll2top/scroll2top.min.js"></script>
<div id="winterland">
  <canvas></canvas>
</div>
<script src="/js/winterland.min.js"></script>

  </body>
</html>
