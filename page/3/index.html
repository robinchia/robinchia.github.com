
<!DOCTYPE HTML>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>The 3 Page | It so life</title>
<meta name="author" content="RobinChia">

<meta name="description" content="It so life">


<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<meta property="og:site_name" content="It so life"/>

<!--[if IE]><style>.testIE.IE{display:inline;}</style><![endif]-->
<!--[if lte IE 7]><link rel="stylesheet" href="/css/ie7.css" type="text/css"><![endif]-->
<!--[if (lt IE 9)&(gt IE 7)]><style>.testIE.IE8{display:inline;}</style><![endif]-->
<!--[if gt IE 8]><style>.testIE.IE9{display:inline;}</style><![endif]-->

<link href="/favicon.png" rel="icon">
<link rel="alternate" href="/atom.xml" title="It so life Feed" type="application/atom+xml">

<link rel="stylesheet" href="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/css/bootstrap.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/font-awesome/4.0.3/css/font-awesome.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/prettify/r298/prettify.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" type="text/css">
<link rel="stylesheet" href="/css/style.css" type="text/css">
<!--[if lt IE 9]>
   <style>article,aside,dialog,footer,header,section,footer,nav,figure,menu{display:block}</style>
   <script src="http://cdn.staticfile.org/html5shiv/r29/html5.min.js"></script>
   <script src="http://cdn.staticfile.org/respond.js/1.4.2/respond.min.js"></script>
<link href="http://cdn.staticfile.org/respond.js/1.4.2/respond-proxy.html" id="respond-proxy" rel="respond-proxy" />
<link href="/js/respond.proxy.gif" id="respond-redirect" rel="respond-redirect" />
<script src="/js/respond.proxy.js"></script>
   <script src="http://cdn.bootcss.com/selectivizr/1.0.2/selectivizr-min.js"></script>
<![endif]-->
<script type="text/javascript">
function loadjs(c,d){var a=document.createElement("script");a.async=!0;a.type="text/javascript";a.src=c;a.charset=d||"gbk";(document.getElementsByTagName("HEAD")[0]||document.getElementsByTagName("BODY")[0]).appendChild(a)};
var _protocol = (("https:" == document.location.protocol) ? " https://" : " http://");
var _js2load = [];
</script>

</head>
<body>
      <header id="header" class="container"><nav id="main-nav" class="navbar navbar-default navbar-fixed-top " role="navigation">
  <div class="container">
    <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
      <span class="sr-only">Toggle navigation</span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="/">It so life</a>
    </div>
    <div  class="collapse navbar-collapse">
      <ul  class="nav navbar-nav">
  
        <li><a href="/" title="Home">Home</a></li>      
        <li><a href="/about/" title="About">About</a></li>      
        <li><a href="/archives/" title="Archives">Archives</a></li>      
      <li class='dropdown'>
        <a class='dropdown-toggle' data-toggle='dropdown' href='#'>website<b class='caret'></b></a>
        <ul class='dropdown-menu pure-menu-selected'>
    
          <li><a href="//groups.google.com/forum/#!forum/pongba" title="TopLanguage">TopLanguage</a></li>    
          <li><a href="//itpub.net/" title="ITPub">ITPub</a></li>    
          <li><a href="//blog.jobbole.com/" title="Bole">Bole</a></li>    
          <li><a href="//nosql-database.org/" title="nosql">nosql</a></li>    
          <li><a href="//gitimmersion.googol.im/" title="Git">Git</a></li>    
        </ul>
      </li>
    
      </ul>
      <ul class="nav navbar-nav navbar-right">
      
        <li><a href="/atom.xml">RSS</a></li>
      
      
        <li><a href="https://twitter.com/robinchia">twitter</a></li>
      
      
      
      
        <li><a href="https://github.com/robinchia">github</a></li>
      
      </ul>
    </div>
  </div>
</nav>
<div class="clearfix"></div>
</header>
  <div id='content' class="container">
     <div class="page-header-wrapper">
      <!--[if lt IE 9]><div class="alert alert-warning alert-dismissable"><button type="button" class="close" data-dismiss="alert" aria-hidden="true">&times;</button><strong>提示:</strong>您的浏览器版本太低了,建议升级到 <strong><a href="http://windows.microsoft.com/zh-cn/internet-explorer/download-ie" title="IE9">IE9</a></strong> 以上,本站使用<a href="https://www.google.com/intl/zh-CN/chrome/">Chrome浏览器</a>可以获得最好的显示效果.</div><![endif]-->
      <div class="page-header"><h1 align="center"><big>It so life</big> </h1>
        <h5 align="center"><big>love as life</big></h5>
      </div>
     </div>
     <div class="row">
       <div id="main-col" class="alignleft col-sx-12 col-sm-8 col-md-9 col-lg-9">
      <section id='header_widget'></section>
          <div id="wrapper"><article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/03/2014-02-03--专访张龙：我的漫漫程序人生路部分摘录/">专访张龙：我的漫漫程序人生路(部分摘录)</a></h1>
      
        <span>Posted on<time datetime="2014-02-03T03:24:29.000Z"> <a href="/2014/02/03/2014-02-03--专访张龙：我的漫漫程序人生路部分摘录/">feb. 3 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-">专访张龙：我的漫漫程序人生路(部分摘录)</h1>
<h1 id="-">专访张龙：我的漫漫程序人生路</h1>
<p>一、关于基础</p>
<p><strong>CSDN：你在系列文章最后分享了9点心得体会，总结当时到现在的这段时光，是否有新的感悟分享？</strong></p>
<p><strong>张龙：</strong>我现在依然在坚守着这些体会：</p>
<ol>
<li><p>基础的重要性。我总是不断强调基础的重要性，因为我是有切身体会的。基础的东西可以让你受用一生。struts出来了，webwork出来，tapestry出来了，jsf出来了，struts2也出来了，等等等等。但是这些框架或者标准都是新东西吗？其实每个人都知道并不是的，他们都是基于HTTP协议的，换句话说都是构建在jsp与servlet基础之上的，有很多人连这两个基础都没掌握好，就去学这些框架，这真是难以想象的。有了好的基础会让你学习新东西更快，也更扎实，走的也更远，否则你永远都是在跟着别人的脚步。</p>
</li>
<li><p>还是基础。我们都知道Spring是非常优秀的框架，也是很多公司采用的技术选型。但是你是否真的了解Spring的核心IOC与AOP了吗？适当看些设计模式的书会让你受益匪浅。其实你只要掌握了java的动态代理对于AOP的理解就是自然而然的事情了。</p>
</li>
<li><p>舍得投入。 有时间的话买些书看看，好书可以让你系统的学习一些技术，而不是一些支离破碎的技术点。</p>
</li>
<li><p>抓紧时间。 将游戏的时间控制的少一些，把精力放在学习上吧，如果你想投身IT行业，做好不断学习的准备</p>
</li>
<li><p>要有激情。 没有激情的人生是惨淡的人生。生活和学习要有激情，否则你体会不到淋漓尽致的快乐与苦痛。</p>
</li>
<li><p>要有耐心。 没有耐心是无法成为一个优秀的程序员的。其实写程序的时候大部分时间是与错误、异常相伴的，不要幻想一下就能将程序写对，优秀的程序实际上是不断重构的过程。</p>
</li>
<li><p>要能耐得住寂寞。 很多时候我们都是与计算机为伴的，如果你没有对程序的兴趣与热情，时间长了你会坐不住的。</p>
</li>
</ol>
<p>8.英语的重要性，如果你想进外企的话，那么英语是必须要过的一关（主要体现在听说上）。</p>
<ol>
<li>最后一点，坚持学习。活到老学到老是对程序开发人员最好的描述。</li>
</ol>
<p><strong>基础的东西总是最重要的。</strong></p>
<hr>
<hr>
<p>二、关于自学（经验）</p>
<p><strong>CSDN：在（中）篇里，你提及上大学最大的两个收获就是：决定了自己的人生方向和掌握了自学的方法。你对现在正处在大学里的准程序员们有何建议？</strong></p>
<p><strong>张龙：</strong>我始终认为这是我大学期间最大的两个收获。因为进入大学后就意味着要独立承担自己的一切，别人可以给你建议，但最后拿主意的一定是自己。<strong>特别是对于计算机专业来说，自学意味着一切。</strong>毕竟计算机领域涉及众多，学校上课讲的只是最基本和基础的，在掌握了这些内容之后剩下的就要靠自己了。</p>
<p>现如今，互联网上的资源一应俱全，你要的东西网上基本都能找到，比我那个时代好太多了。不过，这是一个最好的时代，也是一个最坏的时代。可能你需要的很多资源都需要翻墙才能获取，这应该是每个程序员的必备技能了。另外，对于在校学生来说，有机会可以兼职或是去公司实习，这样可以尽早步入社会，了解公司都需要什么，为今后的工作提前做好铺垫。</p>
<pre><code>关于压力
</code></pre><p><strong>CSDN：你在研究生的时候做过柯尼卡—美能达公司的经销商管理系统、一个游戏点卡的销售网站，都给了你不小的压力，你是如何对待压力的？</strong></p>
<p><strong>张龙：</strong>压力每个人都有，做事情如果没有压力其实很容易造成拖延。这种压力一方面来自于自身，另一方面则是外界施加的。适度的压力会激发人的潜能，<strong>我现在在做事情的时候就喜欢给自己设定一个截止日期，算是自己给自己的压力吧。</strong>没有压力可能一件事，特别是需要长时间付出的事情永远也做不完。</p>
<p>三、关于沟通（经验）
<strong>CSDN：你在研究生期间就给人讲授课程，锻炼自己的口语表达能力，不少程序员相对比较内敛，这方面你有什么经验可分享？</strong></p>
<p><strong>张龙：</strong>我觉得这是个循环问题。你越闭塞，越不想与人交流，那你就越陷在自己的圈子当中，不愿走出来。反过来说，当你<strong>走出去，多多参与讨论，多多与人沟通，这对你的思维也是很好的锻炼，你就知道该如何与人打交道。</strong>你永远不是一个人在战斗，走出去才能实现更好的腾飞。</p>
<p>四、关于学习（建议）
<strong>CSDN：在你一路走来，遇到一些浮躁的心境时是怎么处理的？对刚进入这个领域的人有何建议？</strong></p>
<p><strong>张龙：</strong>浮躁、烦恼每个人都有，也不光是程序员才会这样，各行各业的人都会遇到各种各样的问题。适当排解很重要，憋在心里只会把人憋疯，出去找朋友喝喝酒、唱唱歌，一切都会过去的。我不是专家，不敢给人提建议，只是觉得<strong>学习是保证你今后的路越走越宽的最佳手段</strong>。</p>
<p><strong>来源： &lt;</strong><a href="http://www.csdn.net/article/2013-08-21/2816646" target="_blank"><strong><a href="http://www.csdn.net/article/2013-08-21/2816646">http://www.csdn.net/article/2013-08-21/2816646</a></strong></a><strong>&gt;</strong></p>
<hr>
<p>另：一个文章摘录</p>
<p>程序员最重要的技能         火龙果软件 发布于 2013-8-22    <img src="" alt="">
什么才是程序员最有价值的技能？怎样才能成为一名成功的开发者呢？我敢打赌，在你的职业生涯中你至少问过自己一次这样的问题。你找到答案了吗？你认为自己搞清楚了没有？
许多年轻的程序员会告诉你，伟大的开发者最重要的技能是<strong>对自己所用语言的掌握</strong>。当然，你得对 C/#、 F/#、C++、Java、Ruby、Haskell 或什么别的语言娴熟于心。然而，语言本身并不能提供足够的技能让你完成桌面或 web 应用。
“那要不就是对平台的知识了，”你又问自己。也许甚至是整个平台体系，如果你仔细思考一下的话。比方说，这有可能意味着要知道 Windows API 或 iOS 开发的工具或库。可是，你再想一下。如果趋势变了的话又会怎样？如果项目转向另一个平台的话又会怎样？如果你只具备前一个平台的知识的话，你还会是一名伟大的程序员吗？我不这么认为。
“对！我知道了。肯定是<strong>解决问题和分析性思维的能力</strong>”，你几乎对着我吼起来了。事实上你是对的。没有一个好的开发者是不具备分析性思维的。但是，问题解决仍然不是你应该具备的最重要技能。
“如果不是编程知识的话，那一定就是<strong>编程激情</strong>。你每天都得学点新东西。不能停止，你得热爱它。”的确，你是对的，尽管这并非最重要的能力，但已经接近了。让你从好的开发者变成伟大的开发者的，是编程的激情，尤其是学习的激情。
然而，还有一个技能更有价值，那就是<strong>沟通</strong>。
许多时候这一点被低估了，可如果不使用沟通技能的话你一天都过不了。而且，你要沟通的还不仅仅是客户。还包括你的同事，分享你的想法，用不侮辱人的方式辩论，说服你的老板应该采取你的方式。此外，还有还要汇报状态更新，解释发生的事情。你每天都要沟通，而且要沟通得当，如果你要成为伟大的开发者的话。
这就是我要发文章谈演讲这个似乎不相干话题的原因。我认为从中你可以学到很多东西，如果你对此感兴趣的话你可以继续学习 coursera 的课程（英文）。</p>
<p>来源： <a href="[http://www.uml.org.cn/itnews/2013082209.asp](http://www.uml.org.cn/itnews/2013082209.asp)">[http://www.uml.org.cn/itnews/2013082209.asp](http://www.uml.org.cn/itnews/2013082209.asp)</a> </p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/好文摘录/">好文摘录</a></li></span></span> | <span class="time">recent updated:<time title="2014-03-07 11:24:29"datetime="2014-03-07 11:24:29"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/03/2014-02-03--专访张龙：我的漫漫程序人生路部分摘录/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-03--专访张龙：我的漫漫程序人生路部分摘录" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/03/2014-02-03--分享警惕偷走时间的5大窃贼/">【分享】警惕偷走时间的5大窃贼</a></h1>
      
        <span>Posted on<time datetime="2014-02-03T03:24:29.000Z"> <a href="/2014/02/03/2014-02-03--分享警惕偷走时间的5大窃贼/">feb. 3 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-5-">【分享】警惕偷走时间的5大窃贼</h1>
<p><a href=""></a></p>
<p><a href="http://www.cnblogs.com/cancanwyq/" target="_blank">E8软件 中国式流程管控解决方案领导者 400-006-2800 公众微信号：e8flow</a></p>
<p>致力于中国管理软件设计
E8软件||ITSM解决方案||IT服务管理系统||ITIL管理思想执行工具||E8.NET工作流架构||企业流程管理解决方案</p>
<ul>
<li><a href="http://www.cnblogs.com/" target="_blank">博客园</a></li>
<li><a href="http://www.cnblogs.com/cancanwyq/" target="_blank">首页</a></li>
<li><a href="http://q.cnblogs.com/" target="_blank">博问</a></li>
<li><a href="http://home.cnblogs.com/ing/" target="_blank">闪存</a>
<em>
</em></li>
<li><a href="http://www.cnblogs.com/cancanwyq/rss" target="_blank">订阅</a></li>
<li><a href="http://www.cnblogs.com/cancanwyq/admin/EditPosts.aspx" target="_blank">管理</a>
随笔-133  文章-34  评论-370 </li>
</ul>
<h1 id="-5-http-www-cnblogs-com-cancanwyq-p-3281827-html-"><a href="http://www.cnblogs.com/cancanwyq/p/3281827.html" target="_blank">【分享】警惕偷走时间的5大窃贼</a></h1>
<p> <a href="http://www.chinae8.net/" target="_blank"><img src="" alt=""></a></p>
<p>好的管理者都是好的时间管理者。而管理者时间管理的根本是抓大放小、果断决策、大胆授权、梳理系统、做好计划。只有这样，管理者才能防范偷走你宝贵时间的5大窃贼，才能让自己免于焦头烂额。</p>
<p>管理者管理什么？一是管事，二是管人，三是管时间。在这三个维度上，管事最容易，管人最困难，管时间不难却最容易被忽略。</p>
<p>很多管理者天天忙得团团转，却得不到上司的好评，主要的原因就是不会做时间管理，让自己和下属宝贵的时间被浪费掉。</p>
<p>什么会偷走管理者的时间，让管理者焦头烂额却得不到应得的结果？以我的经验，管理者有5大时间窃贼需要提防。</p>
<ol>
<li><p>抓小放大。很多管理者忙于无数的小细节，不跳出细节思考什么才是自己真正应该做的事情。结果是不重要的事情做了一大堆，重要的事情一个没有做，上司不关心的事情做了一大堆，上司关心的事情一个没有做。其实事情都有逻辑关系和层次：解决一个上一级的问题，通常能让你一下子解决3〜5个次一级的问题。如果我们能抓住最上级的问题用心解决，解决一个最上级问题的效果会相当于解决几十个最底层级的问题。但解决一个大问题和解决一个小问题花的时间差别并不大，至少不是几十倍的差别。</p>
</li>
<li><p>议而不决。很多管理者忙于开会，忙于和很多相关和不相关的同事讨论如何解决一个问题，却迟迟不愿自己负起责任做出决定。这类管理者把本来可以半个小时开完的会议拖延到3个小时，把本来可以在一次会议上做的决定延迟到下一次会议。议而不决的后果是让管理者要处理的事情大量积压，让管理者的时间越来越少。这样的管理者没有认识到，没有事情可以通过拖延得到解决，决策的质量也不能通过拖延得到提高。</p>
</li>
<li><p>不能授权。很多管理者习惯于自己做事情，不习惯授权给别人做，总担心别人做不好，总觉得教会别人做不如自己做快。久而久之，自己做的小事越来越多，自己的时间越来越不够用，身边的人越来越闲，自己的委屈越来越多。</p>
</li>
<li><p>管而不理。很多管理者习惯于管事，不习惯于理事。例如，发现有人迟到，会狠狠地批评当事人，却不会思考是否是公司的考勤制度或考勤技术有问题。管而不理的后果是，一件事情发生一次，管理者要管一次，次次发生，次次要管。随着企业规模的扩大，次次管的事情会大幅增加，管理者的时间越来越少。其实只要系统梳理一次，一类问题就能解决了。从这个角度看，管是小，理是大，管理者要抓大放小，就要更多地梳理，而不是被动地管理。</p>
</li>
<li><p>不做计划。计划是什么？就是把你要做的事情和你可以用的资源合理地匹配起来，简而言之就是事先想清楚在什么时间用什么资源完成你要做的事情。在可以用的资源里，最重要的和最稀少的资源就是时间了。不做计划意味着资源和事情不匹配，意味着资源尤其是时间资源的浪费。一个人一天就24小时，浪费了就没有了。很多人忙，其实不是没有时间，而是没有合理地安排时间。</p>
</li>
</ol>
<p>好的管理者都是好的时间管理者。而管理者时间管理的根本是抓大放小、果断决策、大胆授权、梳理系统、做好计划。只有这样，管理者才能防范偷走你宝贵时间的5大窃贼，才能让自己免于焦头烂额。</p>
<p><strong>分享是一种美德，请随手转播  </strong></p>
<p>敬请关注【流程管理】公众微信平台，微信号：<strong>e8flow</strong>,宣传流程管理理念，每日会与您分享管理技巧，管理经验、哲理小故事和财经评论、财经观点。 您可以通过 “添加朋友”--&gt; &quot;搜索号码&quot; 或 “查找公众微信账号”,输入 e8flow ,搜索添加此关注</p>
<p>E8软件 提升企业战略执行力
<a href="http://www.chinae8.net/" target="_blank"><a href="http://www.chinae8.net">http://www.chinae8.net</a>
</a> 流程银行QQ群 :74080032
【流程管理】微信公众号：e8flow
绿色通道： <a href="">好文要顶</a> <a href="">关注我</a> <a href="">收藏该文</a><a href="http://space.cnblogs.com/msg/send/%e8%8b%8f%e5%ba%b7%e8%83%9c" target="_blank">与我联系</a> <a href="&quot;分享至新浪微博&quot;"><img src="" alt=""></a></p>
<p><a href="http://home.cnblogs.com/u/cancanwyq/" target="_blank"><img src="" alt=""></a></p>
<p><a href="http://home.cnblogs.com/u/cancanwyq/" target="_blank">苏康胜</a>
<a href="http://home.cnblogs.com/u/cancanwyq/followees" target="_blank">关注 - 0</a>
<a href="http://home.cnblogs.com/u/cancanwyq/followers" target="_blank">粉丝 - 24</a></p>
<p><a href="">+加关注</a></p>
<p>0</p>
<p>0
(请您对文章做出评价)</p>
<p><a href="http://www.cnblogs.com/cancanwyq/archive/2013/08/21/3271848.html" target="_blank">«</a> 上一篇：<a href="http://www.cnblogs.com/cancanwyq/archive/2013/08/21/3271848.html" title="发布于2013-08-21 09:04" target="_blank">2013年江苏省钢贸市场融资黑洞引发传统信用分析技术的思考</a></p>
<p>posted @ 2013-08-26 08:24 <a href="http://www.cnblogs.com/cancanwyq/" target="_blank">苏康胜</a> 阅读(162) 评论(0) <a href="http://www.cnblogs.com/cancanwyq/admin/EditPosts.aspx?postid=3281827" target="_blank">编辑</a> <a href="">收藏</a></p>
<p><a href="">刷新评论</a><a href="">刷新页面</a><a href="">返回顶部</a></p>
<p>注册用户登录后才能发表评论，请 <a href="">登录</a> 或 <a href="">注册</a>，<a href="http://www.cnblogs.com/" target="_blank">访问</a>网站首页。
<a href="http://www.cnblogs.com/" title="程序员的网上家园" target="_blank">博客园首页</a><a href="http://q.cnblogs.com/" title="程序员问答社区" target="_blank">博问</a><a href="http://news.cnblogs.com/" title="IT新闻" target="_blank">新闻</a><a href="http://home.cnblogs.com/ing/" target="_blank">闪存</a><a href="http://job.cnblogs.com/" target="_blank">程序员招聘</a><a href="http://kb.cnblogs.com/" target="_blank">知识库</a></p>
<p><strong>最新IT新闻</strong>:
· <a href="http://news.cnblogs.com/n/186400/" target="_blank">淘宝保险潜行三年保单超10亿笔 运费险占比过半</a>
· <a href="http://news.cnblogs.com/n/186399/" target="_blank">科学家发现古埃及人陨石项链：距今5000年</a>
· <a href="http://news.cnblogs.com/n/186398/" target="_blank">键盘藏真菌比臭鞋高65倍</a>
· <a href="http://news.cnblogs.com/n/186396/" target="_blank">乔布斯和马斯克两巨人之间的“神同步”</a>
· <a href="http://news.cnblogs.com/n/186395/" target="_blank">苹果7月修改应用排行算法：首次参考用户评级</a>
» <a href="http://news.cnblogs.com/" title="IT新闻" target="_blank">更多新闻...</a></p>
<p><strong>最新知识库文章</strong>:
· <a href="http://kb.cnblogs.com/page/186346/" target="_blank">计算机专业学习浅谈</a>
· <a href="http://kb.cnblogs.com/page/186221/" target="_blank">遗失的乔布斯访谈</a>
· <a href="http://kb.cnblogs.com/page/179631/" target="_blank">从登录开始</a>
· <a href="http://kb.cnblogs.com/page/179146/" target="_blank">聊聊内存泄露</a>
· <a href="http://kb.cnblogs.com/page/185599/" target="_blank">与Google轻轻地擦肩而过</a>
» <a href="http://kb.cnblogs.com/" target="_blank">更多知识库文章...</a></p>
<h3 id="-">公告</h3>
<p>自2007年10月20日
<a href="http://www.newzgc.com/" target="_blank"><img src="" alt=""><img src="" alt=""><img src="" alt=""><img src="" alt=""><img src="" alt=""><img src="" alt=""><img src="" alt=""><img src="" alt=""></a>
<a href="http://www.feifanit.com.cn/productITSM.htm?default=solutions" target="_blank">E8.ITSM HelpDesk 您身边的IT服务管理专家</a>
<a href="http://www.feifanit.com.cn/productITSM.htm" target="_blank"><img src="" alt=""></a>
<a href="http://www.feifanit.com.cn/productFlow.htm" target="_blank">E8.Net工作流提升企业管理执行力</a>
<a href="http://www.feifanit.com.cn/productFlow.htm" target="_blank"><img src="" alt=""></a>
<a href="http://t.qq.com/E8FLOW" target="_blank"><img src="" alt=""></a> 敬请关注【流程管理专家】公众微信号：e8flow,分享流程管理经验，传播管理理念，提升管理执行力！</p>
<p>昵称：<a href="http://home.cnblogs.com/u/cancanwyq/" target="_blank">苏康胜</a>
园龄：<a href="http://home.cnblogs.com/u/cancanwyq/" title="入园时间：2006-02-15" target="_blank">7年6个月</a>
粉丝：<a href="http://home.cnblogs.com/u/cancanwyq/followers/" target="_blank">24</a>
关注：<a href="http://home.cnblogs.com/u/cancanwyq/followees/" target="_blank">0</a></p>
<p><a href="">+加关注</a></p>
<h3 id="-">搜索</h3>
<h3 id="-">我的标签</h3>
<ul>
<li><a href="http://www.cnblogs.com/cancanwyq/tag/%E5%B7%A5%E4%BD%9C%E6%B5%81/" target="_blank">工作流</a>(15)</li>
<li><a href="http://www.cnblogs.com/cancanwyq/tag/.net/" target="_blank">.net</a>(11)</li>
<li><a href="http://www.cnblogs.com/cancanwyq/tag/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/" target="_blank">项目管理</a>(8)</li>
<li><a href="http://www.cnblogs.com/cancanwyq/tag/%E5%BC%80%E5%8F%91%E5%9B%A2%E9%98%9F/" target="_blank">开发团队</a>(6)</li>
<li><a href="http://www.cnblogs.com/cancanwyq/tag/E8.net/" target="_blank">E8.net</a>(6)</li>
<li><a href="http://www.cnblogs.com/cancanwyq/tag/ITIL/" target="_blank">ITIL</a>(5)</li>
<li><a href="http://www.cnblogs.com/cancanwyq/tag/IT%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86/" target="_blank">IT服务管理</a>(4)</li>
<li><a href="http://www.cnblogs.com/cancanwyq/tag/.Net%E5%B7%A5%E4%BD%9C%E6%B5%81/" target="_blank">.Net工作流</a>(4)</li>
<li><a href="http://www.cnblogs.com/cancanwyq/tag/CIO/" target="_blank">CIO</a>(4)</li>
<li><a href="http://www.cnblogs.com/cancanwyq/tag/E8.Net%E6%9E%B6%E6%9E%84/" target="_blank">E8.Net架构</a>(3)</li>
<li><p><a href="http://www.cnblogs.com/cancanwyq/tag/" target="_blank">更多</a></p>
<h3 id="-">经典收藏</h3>
</li>
<li><p><a href="http://blog.vsharing.com/cancanwyq" target="_blank">ITIL标准面向中国企业的实践之路</a></p>
</li>
<li><a href="http://blog.vsharing.com/cancanwyq" target="_blank">ITIL与ITSM管理软件</a></li>
<li><a href="http://www.cnblogs.com/cancanwyq/articles/343325.html" target="_blank">工作流技术杂谈</a></li>
<li><a href="http://www.feifanit.com.cn/" target="_blank">工作流应用网站</a></li>
</ul>
<h3 id="-">团队博客</h3>
<ul>
<li><a href="http://dotnetenterprise.cnblogs.com/" target="_blank">.Net企业应用开发</a></li>
<li><a href="http://shanghai.cnblogs.com/" target="_blank">上海.net俱乐部</a></li>
<li><p><a href="http://shenzhen.cnblogs.com/" target="_blank">深圳.Net俱乐部</a></p>
<h3 id="-">阅读排行榜</h3>
</li>
<li><p><a href="http://www.cnblogs.com/cancanwyq/archive/2009/09/22/1571707.html" target="_blank">1. 从网友发的一个关于程序员人生的流程图想到的(4923)</a></p>
</li>
<li><a href="http://www.cnblogs.com/cancanwyq/archive/2009/03/18/1415070.html" target="_blank">2. 技术高速发展，IT人员路在何方？(3554)</a></li>
<li><a href="http://www.cnblogs.com/cancanwyq/archive/2007/10/27/939392.html" target="_blank">3. 模式窗口window.open造成Session丢失的解决方法(2984)</a></li>
<li><a href="http://www.cnblogs.com/cancanwyq/archive/2009/05/12/1454574.html" target="_blank">4. 机会来了，创业你准备好了吗？(2668)</a></li>
<li><a href="http://www.cnblogs.com/cancanwyq/archive/2010/06/10/1755244.html" target="_blank">5. 软件公司有一种幸福叫好好活着(2566)</a></li>
</ul>
<h3 id="-">推荐排行榜</h3>
<ul>
<li><a href="http://www.cnblogs.com/cancanwyq/archive/2010/06/10/1755244.html" target="_blank">1. 软件公司有一种幸福叫好好活着(6)</a></li>
<li><a href="http://www.cnblogs.com/cancanwyq/archive/2010/06/09/1754443.html" target="_blank">2. 软件企业三个“留住”，创建品质团队(4)</a></li>
<li><a href="http://www.cnblogs.com/cancanwyq/archive/2010/08/23/1806258.html" target="_blank">3. 项目经理进阶修炼2--处理需求变更策略(4)</a></li>
<li><a href="http://www.cnblogs.com/cancanwyq/archive/2010/07/19/1780453.html" target="_blank">4. 中国程序员有望挑战“比尔.盖茨”的三大管理类需求(3)</a></li>
<li><a href="http://www.cnblogs.com/cancanwyq/archive/2010/08/16/1800428.html" target="_blank">5. 软件开发技术高手转向项目管理者要突破的误区-- 跟博客园的朋友探讨的思路(3)</a>
Copyright ©2013 苏康胜</li>
</ul>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/好文摘录/">好文摘录</a></li></span></span> | <span class="time">recent updated:<time title="2014-03-07 11:24:29"datetime="2014-03-07 11:24:29"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/03/2014-02-03--分享警惕偷走时间的5大窃贼/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-03--分享警惕偷走时间的5大窃贼" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/03/2014-02-03--BruceEckel：编程生涯/">Bruce Eckel：编程生涯</a></h1>
      
        <span>Posted on<time datetime="2014-02-03T03:24:29.000Z"> <a href="/2014/02/03/2014-02-03--BruceEckel：编程生涯/">feb. 3 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="bruce-eckel-">Bruce Eckel：编程生涯</h1>
<p><strong>EN文：</strong></p>
<p>Computing Thoughts
A Career in Computing
by Bruce Eckel
June 2, 2009
 <strong>Summary</strong>
I regularly receive requests for career advice, and I&#39;ve tried to capture the answers in this blog, and in a follow-on. For those of you who asked but never got an answer, I apologize. Your questions stimulated me to work on this, and it&#39;s taken awhile.</p>
<p>The question that people ask is usually the wrong one: &quot;should I learn C++ or Java?&quot; In this essay, I shall try to lay out my view of the true issues involved in choosing a career in computing.</p>
<p>Note that I am not talking here to the people who already know it is their calling. You&#39;re going to do it regardless of what anyone says, because it&#39;s in your blood and you can&#39;t get away from it. You know the answer already: C++ AND Java AND shell scripting AND Python AND a host of other languages and technologies that you&#39;ll learn as a matter of course. You already know several of these languages, even if you&#39;re only 14.</p>
<p>The person who asks me this question may be coming from another career. Or perhaps they are coming from a field like web development and they&#39;ve figured out that HTML is only kind of like programming, and they&#39;d like to try building something more substantial. But I especially hope that, if you are asking this question, you&#39;ve realized that to be successful in computing, you need to teach yourself how to learn, and never stop learning.</p>
<p>The more I do this, the more it seems to me that software is <a href="http://www.artima.com/weblogs/viewpost.jsp?thread=255898" target="_blank">more akin to writing</a> than anything else. And we haven&#39;t figured out what makes a good writer, we only know when we like what someone writes. This is not some kind of engineering where all we have to do is put something in one end and turn the crank. It is tempting to think of software as deterministic -- that&#39;s what we want it to be, and that&#39;s the reason that we keep coming up with tools to help us produce the behavior we desire. But my experience keeps indicating the opposite, that it is more about people than processes, and the fact that it runs on a deterministic machine becomes less and less of an influence, just like the Heisenberg principle doesn&#39;t affect things on a human scale.</p>
<p>My father built custom homes, and in my youth I would occasionally work for him, mostly doing grunt labor and sometimes hanging sheet rock. He and his lead carpenter would tell me that they gave me these jobs for my own good -- so that I wouldn&#39;t go into the business. It worked.</p>
<p>So I can also use the analogy that building software is like building a house. We don&#39;t refer to everyone who works on a house as if they were exactly the same. There are concrete masons, roofers, plumbers, electricians, sheet rockers, plasterers, tile setters, laborers, rough carpenters, finish carpenters, and of course, general contractors. Each of these requires a different set of skills, which requires a different amount of time and effort to acquire. House-building is also subject to boom and bust cycles, like programming. If you want to get in quick, you might take a job as a laborer or a sheet rocker, where you can start getting paid without much of a learning curve. As long as demmand is strong, you have steady work, and your pay might even go up if there aren&#39;t enough people to do the work. But as soon as there&#39;s a downturn, carpenters and even the general contractor can hang the sheet rock themselves.</p>
<p>When the Internet was first booming, all you had to do was spend some time learning HTML and you could get a job and earn some pretty good money. When things turned down, however, it rapidly becomes clear that there is a hierarchy of desirable skills, and the HTML programmers (like the laborers and sheet rockers) go first, while the highly-skilled code smiths and carpenters are retained.</p>
<p>What I&#39;m trying to say here is that you don&#39;t want to go into this business unless you are ready to commit to lifelong learning. Sometimes it seems like programming is a well-paying, reliable job -- but the only way you can make sure of this is if you are always making yourself more valuable.</p>
<p>Of course you can find exceptions. There are always those people who learn one language and are just competent enough and perhaps savvy enough to stay employed without doing much to expand their abilities. But they are surviving by luck, and they are ultimately vulnerable. To make yourself less vulnerable, you need to continuously improve your abilities, by reading, going to user groups, conferences, and seminars. The more depth you have in this field, the more valuable you will be, which means you have more stable job prospects and can command higher salaries.</p>
<p>Another approach is to look at the field in general, and find a place where you already have talents. For example, my brother is interested in software, and dabbles with it, but his business is in installing computers, fixing them and upgrading them. He&#39;s always been meticulous, so when he installs or fixes your computer you know that it will be in excellent shape when he&#39;s done; not just the software, but all the way down to the cables, which will be bundled neat and out of the way. He&#39;s always had more work than he could do, and he never noticed the dot-com bust. And needless to say, his work cannot be offshored.</p>
<p>I stayed in college a long time, and managed to get by in various ways. I even began a Ph.D. program at UCLA, which was mercifully cut short -- I say mercifully because I no longer loved being in college, and the reason I stayed in college for so long was because I enjoyed it so much. But what I enjoyed was typically the off-track stuff. Art and dance classes, working on the college newspaper, and even the handful of computer programming classes that I took (which were off-track because I was a physics undergrad and a computer <em>engineering</em> graduate student). Although I was far from exceptional academically (a delightful irony is that many colleges that would not have accepted me as a student now use my books in their courses!), I really enjoyed the life of the college student, and had I finished a Ph.D. I probably would have taken the easy path and ended up a professor.</p>
<p>But as it turns out, some of the greatest value that I got from college was from those same off-track courses, the ones that expanded my mind beyond &quot;stuff we already know.&quot; I think this is especially true in computing because you are always programming to support some other goal, and the more you know about that goal the better you&#39;ll perform (I&#39;ve encountered some European graduate programs that require the study of computing in combination with some other specialty, and you build your thesis by solving a domain-specific problem in that other specialty).</p>
<p>I also think that knowing more than just programming vastly improves your problem-solving skills (just as knowing more than one programming language vastly improves your programming skills). On multiple occasions I have encountered people, trained only in computer science, who seem to have more limits in their thinking than those who come from some other background, like math or physics, which requires more rigorous thinking and is less prone to &quot;it works for me&quot; solutions.</p>
<p>In one session a conference that I organized, one of the topics was to come up with a list of features for the ideal job candidate:</p>
<ul>
<li>Learning as a lifestyle. For example, you should know more than one language; nothing opens your eyes more to the strengths and limitations of a language than learning another one.</li>
<li>Know where and how to get new knowledge.</li>
<li>Study prior art.</li>
<li>We are tool users.</li>
<li>Learn to do the simplest thing.</li>
<li>Understand the business (Read magazines. Start with Fast Company, which has very short and interesting articles. Then you can see if you want to read others)</li>
<li>You are personally responsible for errors. &quot;It works for me&quot; is not an acceptable strategy. Find your own bugs.</li>
<li>Become a leader: someone who communicates and inspires.</li>
<li>Who are you serving?</li>
<li>There is no right answer ... and always a better way. Show and discuss your code, without emotional attachment. You are not your code.</li>
<li>It&#39;s an asymptotic journey towards perfection.</li>
</ul>
<p>Take whatever risks you can -- the best risks are the scary ones, but in trying you will feel more alive than you can imagine. It&#39;s best if you don&#39;t plan for a particular outcome, because you will often miss the true possibilities if you&#39;re too attached to a result. My best adventures have been ones that have started with &quot;lets do a little experiment and see where it takes us.</p>
<p>Some people will be disappointed by this answer, and reply &quot;yes, that&#39;s all very interesting and useful. But really, what should I learn? C++ or Java?&quot; I&#39;ll fend these off by repeating here: I know it seems like all the ones and zeroes should make everything deterministic, so that such questions should have a simple answer, but they don&#39;t. It&#39;s not about making one choice and being done with it. It&#39;s about continuous learning and sometimes, bold choices. Trust me, your life will be more exciting this way.</p>
<h1 id="-further-reading-"><a href="">Further Reading</a></h1>
<p>Here&#39;s an earlier piece I wrote on <a href="http://mindview.net/WebLog/log-0030" target="_blank">how I got started in programming</a>.
I found all these to be interesting and stimulating takes on the same subject: </p>
<ul>
<li>Teach yourself programming in ten years, by Peter Norvig: <a href="http://norvig.com/21-days.html" target="_blank"><a href="http://norvig.com/21-days.html">http://norvig.com/21-days.html</a></a></li>
<li>How to be a Programmer, by Robert Read: <a href="http://samizdat.mines.edu/howto/HowToBeAProgrammer.html" target="_blank"><a href="http://samizdat.mines.edu/howto/HowToBeAProgrammer.html">http://samizdat.mines.edu/howto/HowToBeAProgrammer.html</a></a></li>
<li>Here&#39;s a <a href="http://news-service.stanford.edu/news/2005/june15/jobs-061505.html" target="_blank">speech by Steve Jobs</a>, trying to inspire a group of graduating college students.</li>
<li>Kathy Sierra: Does College Matter? <a href="http://headrush.typepad.com/creating_passionate_users/2005/07/does_college_ma.html" target="_blank"><a href="http://headrush.typepad.com/creating_passionate_users/2005/07/does_college_ma.html">http://headrush.typepad.com/creating_passionate_users/2005/07/does_college_ma.html</a></a></li>
<li><a href="http://www.paulgraham.com/college.html" target="_blank"><a href="http://www.paulgraham.com/college.html">http://www.paulgraham.com/college.html</a></a></li>
<li><a href="http://www.joelonsoftware.com/articles/CollegeAdvice.html" target="_blank"><a href="http://www.joelonsoftware.com/articles/CollegeAdvice.html">http://www.joelonsoftware.com/articles/CollegeAdvice.html</a></a></li>
<li><a href="http://www.jamesshore.com/Blog/Five-Design-Skills.html" target="_blank"><a href="http://www.jamesshore.com/Blog/Five-Design-Skills.html">http://www.jamesshore.com/Blog/Five-Design-Skills.html</a></a></li>
<li><a href="http://steve-yegge.blogspot.com/2006/03/truth-about-interviewing.html" target="_blank"><a href="http://steve-yegge.blogspot.com/2006/03/truth-about-interviewing.html">http://steve-yegge.blogspot.com/2006/03/truth-about-interviewing.html</a></a></li>
</ul>
<p>In a future article (I&#39;ll post the link here when it&#39;s done), I will talk about the importance of understanding management and business issues, whether or not you ever plan to be a manager, and in that article I&#39;ll include a list of books that (even though they&#39;re about management) you should read to prepare yourself for your career.</p>
<h1 id="talk-back-">Talk Back!</h1>
<p>Have an opinion? Readers have already posted <a href="http://www.artima.com/forums/flat.jsp?forum=106&amp;thread=259358" target="_blank">24 comments</a> about this weblog entry. Why not <a href="http://www.artima.com/forums/post.jsp?forum=106&amp;thread=259358&amp;reply=true" target="_blank">add yours</a>?</p>
<h1 id="rss-feed">RSS Feed</h1>
<p>If you&#39;d like to be notified whenever Bruce Eckel adds a new entry to <a href="http://www.artima.com/weblogs/index.jsp?blogger=beckel" target="_blank">his weblog</a>, subscribe to his <a href="http://www.artima.com/weblogs/feeds/bloggers/beckel.rss" target="_blank">RSS feed</a>.  </p>
<hr>
<p><strong>中文：</strong></p>
<p><strong>Bruce Eckel：编程生涯</strong></p>
<p>作者 <strong>Bruce Eckel</strong> 是编程界的大牛，著有大名鼎鼎的《Thinking in C++》和《Thinking in Java》。
本文是他对程序员（尤其是新手）的忠告。</p>
<p>================华丽的分割线================</p>
<p>大家总是问一个错误的问题：“我应该学习C++还是Java？”在本文中，我将告诉大伙儿：对于选择编程生涯真正需要关注的是哪些问题。</p>
<p>请 注意，这篇文章的目标读者并不是那些已经做出自己选择的人。（对于这些人而言）你会继续自己的编程生涯，而不管别人会怎么说。因为它已经渗透到你的血液 中，你已经无法摆脱。你已经知道答案：C++、Java、Shell脚本、Python、还有其它一大堆的语言和技术，你都理所当然地会去学习。甚至有可 能你才仅仅14岁，就已经知道好几种不同的语言。</p>
<p>问我这样的问题的人可能来自其他行业，或者来自诸如Web开发之类的领域。他们知道HTML是一种类编程语言，而且想尝试构建某些更大型的应用。但我特别希望，当你在问这个问题时，你已经意识到了想要在计算机领域取得成功，你需要掌握自学能力，而且永不停息。</p>
<p><strong>在这个领域做得越多，我越觉得软件开发比任何行业都更接近于写作。</strong> 我们从来不知道是什么造就了优秀的作者，我们只知道什么时候我们会喜欢某个人的文字。编程不是一种工程，仅需要把东西从入口倒进去，然后再转动手柄。把软 件开发看成确定性的，是一个诱人的想法。因为这个想法，人们总想搞出一些工具来帮我们开发出想要的软件。但是我的经验告诉我，事实并非如此——人的重要性 远高于流程。而软件是否运行在一部精确的机器上已经越来越不重要了——这犹如测不准原理对人类的影响。</p>
<p>我的父亲是造房子的，小时候我偶尔会帮忙打下手，放放砖块之类。他和他的木工告诉我，他们是为我好才让我干这些活——这样我就不至于走入这个行业。事实确实是这样。</p>
<p>我 们不妨把软件开发比作盖房子。造房子的人当然不可能完全一样。这些人里面有：混凝土工、屋顶工、管道工、电工、砖瓦工、水泥工、瓦片工、搬运工、粗木工、 细木工。当然，还有工头。每个工种都需要相应的技能，这些技能都需要花时间和精力去掌握。跟软件开发一样，造房子也是一个“建立/推翻”的过程。如果你想 很快地获得回报，你可能从搬运工和砖瓦工开始做，这样的话，你无需太多的学习曲线就可以获得回报。当需求很多时，你的工作会很稳固，甚至收入也可能提升 ——如果没有足够的人手的话。但是，一旦行情不妙，木匠甚至工头就可能把砖瓦工一脚踢开。</p>
<p>当互联网刚刚兴起时，仅仅是花一点时间学习HTML，你就可以得到一份薪水丰厚的工作。但是当形势惨淡时，对于技能的要求更高了——HTML程序员（就像搬运工和砖瓦工一样）第一个被抛弃了，而拥有更高技能的程序员则留了下来。</p>
<p>我想说的是： <strong>除非你准备活到老学到老，不然的话，不要进入这个行业！编程看起来似乎是一个高收入而又稳定的工作。但要做到这一点，唯一的途径是：始终让自己更有价值。</strong></p>
<p>当然，你总能找到例外。总有那么一些人，仅仅学了一门编程语言，就可以胜任留在一个岗位上，而不需要增长他的技能。但他们只是幸免于难而已，他们最终无疑是很脆弱的。为了不让自己变得脆弱，你需要持续的提高自己，通过阅读、加入用户组、参加研讨会…… <strong>你学得越深入，你就越有价值，也就意味着你有更好的职业前景，可以配得上更高的薪水。</strong></p>
<p>另 一个方法是：先大致地了解这个领域，找到最适合你的地方。打个比方：我的兄弟对软件很感兴趣，也进入了这个行业，但他的工作是安装、维修、升级电脑。他总 是一丝不苟，所以当他把电脑搞好，一定会很完美——不只只是软件，连电线都会被仔细地捆好。他总是生意兴隆，远远超出他的精力所能及。他甚至都不用担心 .com 泡沫的崩溃。显然他的饭碗不容易被抢走。</p>
<p>我在高校里待了很久，甚至还在UCLA（加州大学洛杉矶分校）开始进修博士学位，后来 又幸运地终止了。我说“幸运”是因为我不再喜欢呆在学校，而我之前在高校待了那么久，只是因为我很享受它。但我所享受的，基本上是不务正业的东西——艺术 和舞蹈课，在校报工作，还有一小撮计算机课程（之所以说计算机课程“不务正业”，是因为我本科是物理专业，研究生才是计算机专业）。虽然我在学术上远谈不 上卓越（有意思的是很多当时也许不会接受我这个学生的学校现在却用我的书做教材）。我真的很享受作为学生的日子，当我完成博士课程，也许会以一个教授的身 份终老一生。</p>
<p>但就如现在看到的，我在学校里最大的收获恰恰来自我那些“不务正业”的课程，它们拓展了我的思维，使之超越了“我们已经知道 的东西”。在计算机领域中，你总是为某种目标而编程。你对目标了解得越多，你就做得越好。我遇到过一些欧洲的研究生，他们需要结合其它专业领域来搞编程， 他们的论文需要解决这个专业领域的特定的问题。</p>
<p><strong>了解编程之外的领域，将会极大得提高你解决问题的能力</strong> （就如同多学几种编程语言将极大地提高你的编程技能）。很多时候，我发现仅仅学习计算机专业的学生，比那些（除了计算机之外）拥有其它背景的学生，在思维上有更多的局限性。因为后者有着更严谨的思维，也不那么容易想当然。</p>
<p>有一次我组织了一次会议，其中一个议题是：理想的应聘者有哪些特征：
◇把学习当成生活方式。比如：你应该知道不止一种语言，没有什么比学习一门新语言更能让你开阔眼界了。
◇知道如何获取知识
◇Study prior art
◇善用工具
◇学会把事情简化
◇理解业务
◇为自己的错误负责。“我就是这样的”是不能接受的托词。能找到自己的失误。
◇成为一个领导者，善于沟通和激励。
◇搞清楚你在为谁服务
◇没有绝对正确的答案（更好的方法总是存在的）。展示并讨论你的代码，不要带着感情因素——你的代码并不等于你本人。
◇明白完美是渐进的</p>
<p>要 尝试一些冒险的事情——尤其是那些令人害怕的冒险。当你尝试之后，将体会到出乎意料的兴奋。（在冒险的过程中）最好不要刻意去计划某个特定的结果。当你过 于注重结果，你往往会错过那些真正有价值的问题。我的冒险往往是这样开始的——“我们先做些试验，看看它会把我们带到什么地方”。</p>
<p>或许某 些人会对我的回答感到失望，并回复我说：“是的，这很有趣也很有用。但我到底应该学什么？C++还是Java？” 我再重复一次：并不是所有的问题都有一个唯一的简单的答案。问题的关键不在于选择某个编程语言，然后掌握之。问题的关键在于：持续学习，并且很多时候，有 不止一个选择。相信我所说的，你的生活会更精彩！</p>
<p>洋文原始出处：
<a href="http://www.artima.com/weblogs/viewpost.jsp?thread=259358" target="_blank"><a href="http://www.artima.com/weblogs/viewpost.jsp?thread=259358">http://www.artima.com/weblogs/viewpost.jsp?thread=259358</a></a>
来源： <a href="[http://www.rootsir.com/transshipment/2012/709.html](http://www.rootsir.com/transshipment/2012/709.html)">[http://www.rootsir.com/transshipment/2012/709.html](http://www.rootsir.com/transshipment/2012/709.html)</a> </p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/好文摘录/">好文摘录</a></li></span></span> | <span class="time">recent updated:<time title="2014-03-07 11:24:29"datetime="2014-03-07 11:24:29"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/03/2014-02-03--BruceEckel：编程生涯/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-03--BruceEckel：编程生涯" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/03/2014-02-03--{技术}{多线程}实施并行编程的五大障碍/">{技术}{多线程}实施并行编程的五大障碍</a></h1>
      
        <span>Posted on<time datetime="2014-02-03T03:24:29.000Z"> <a href="/2014/02/03/2014-02-03--{技术}{多线程}实施并行编程的五大障碍/">feb. 3 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-">{技术}{多线程}实施并行编程的五大障碍</h1>
<p>要使用 Google·网上论坛讨论区，请在您的浏览器设置中启用 JavaScript，然后刷新该网页。   <plaintext/><xmp>.</p>
<ol>
<li><a href="https://plus.google.com/?gpsrc=ogpy0&amp;tab=gX" target="_blank">+你</a></li>
<li><a href="http://www.google.com/webhp?hl=zh-CN&amp;tab=gw" target="_blank">搜索</a></li>
<li><a href="http://www.google.com/imghp?hl=zh-CN&amp;tab=gi" target="_blank">图片</a></li>
<li><a href="https://maps.google.com/maps?hl=zh-CN&amp;tab=gl" target="_blank">地图</a></li>
<li><a href="https://play.google.com/?hl=zh-CN&amp;tab=g8" target="_blank">Play</a></li>
<li><a href="https://www.youtube.com/?tab=g1" target="_blank">YouTube</a></li>
<li><a href="https://news.google.com/nwshp?hl=zh-CN&amp;tab=gn" target="_blank">新闻</a></li>
<li><a href="https://mail.google.com/mail/?tab=gm" target="_blank">Gmail</a></li>
<li><a href="https://drive.google.com/?tab=go" target="_blank">云端硬盘</a></li>
<li><a href="https://www.google.com/calendar?tab=gc" target="_blank">日历</a></li>
<li><p><a href="http://www.google.com/intl/zh-CN/options/" target="_blank">更多</a></p>
</li>
<li><p><a href="https://translate.google.com/?hl=zh-CN&amp;tab=gT" target="_blank">翻译</a></p>
</li>
<li><a href="http://www.google.com/mobile/?hl=zh-CN&amp;tab=gD" target="_blank">移动</a></li>
<li><a href="http://books.google.com/bkshp?hl=zh-CN&amp;tab=gp" target="_blank">图书</a></li>
<li><a href="https://wallet.google.com/manage/?tab=ga" target="_blank">电子钱包</a></li>
<li><a href="https://www.blogger.com/?tab=gj" target="_blank">Blogger</a></li>
<li><a href="https://www.google.com/finance?tab=ge" target="_blank">财经</a></li>
<li><a href="https://plus.google.com/photos?tab=gq" target="_blank">相册</a></li>
<li><a href="http://video.google.com/?hl=zh-CN&amp;tab=gv" target="_blank">视频</a>
1.</li>
<li><a href="http://www.google.com/intl/zh-CN/options/" target="_blank">更多</a></li>
</ol>
<p><a href="https://groups.google.com/d/overview" title="Google 网上论坛"></a></p>
<p>隐藏字段搜索论坛或帖子</p>
<p><img src="" alt=""></p>
<h2 id="account-options">Account Options</h2>
<p>1.</p>
<ol>
<li><a href="https://www.google.com/a/UniversalLogin?continue=https%3A%2F%2Fgroups.google.com%2Fd%2Ftopic%2Fpongba%2FBPGNU3OJZos&amp;hl=zh-CN&amp;service=groups2&amp;hd=default" target="_blank">登录</a><h2 id="-"><a href="">网上论坛</a></h2>
</li>
</ol>
<p><img src="" alt=""><img src="" alt="">第  个，共  个（ 个未读）</p>
<p><img src="" alt="">
<img src="" alt=""></p>
<p><img src="" alt=""></p>
<p><img src="" alt=""></p>
<p><a href="">首页</a></p>
<p>导入预定义搜索，将它们添加到您保存的搜索结果中。</p>
<p>点击论坛的星标即可收藏它
[0</p>
<h3 id="-">最近看过的论坛</h3>
<p>]()</p>
<p><a href=""></a></p>
<p><a href="">0  TopLanguage</a></p>
<p>[0</p>
<h3 id="-">最近的搜索</h3>
<p>]()</p>
<p><a href=""></a>
[0</p>
<h3 id="-">最近发过帖的论坛</h3>
<p>]()</p>
<p><a href=""></a></p>
<p>请<a href="https://www.google.com/a/UniversalLogin?continue=https%3A%2F%2Fgroups.google.com%2Fd%2Ftopic%2Fpongba%2FBPGNU3OJZos&amp;hl=zh-CN&amp;service=groups2&amp;hd=default" target="_blank">登录</a>或开始浏览，以整理您的论坛并查看最近的项目。</p>
<p>©2013 Google
<a href="http://www.google.com/intl/zh-CN/policies/privacy/" target="_blank">隐私权政策</a>  -  <a href="http://www.google.com/intl/zh-CN/policies/terms/" target="_blank">服务条款</a>  -  <a href="http://www.google.com/" target="_blank">Google 首页</a></p>
<p><a href=""></a> <a href=""></a> <a href="">TopLanguage</a> › 由于长期没有活动，本主题已不再开放新回复。如果您要发帖，请在上方搜索更新的主题或发布新问题。 {技术}{多线程}实施并行编程的五大障碍</p>
<p>此主题和其他讨论重复。   <a href=""></a>
系统将您从重复的主题重定向到这里。   <a href=""></a></p>
<p>24 名作者发布了 95 个帖子</p>
<p><img src="" alt="">
上一页 <a href="">上一页</a>  </p>
<p>第 <strong>1</strong> 页
  下一页 <a href="">下一页</a></p>
<p><img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问“什么是实施并行编程的最大障
碍”时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看
<a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/" target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/</a></a>
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是“专家”们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了“编译指导”、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说“在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶……你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的”，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：“你觉得并行编程容易么？”，十有八九会说“我觉得很难”。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点“教育”有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。
<a href="">显示删减掉的内容</a></p>
</li>
</ol>
<p><img src="" alt=""> 机械唯物主义 : linjunhalida <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>恩恩，有些事情还是没有并行的必要。等光处理器出来就好了。
2010/3/22 Guancheng Chen <a href="&#109;&#97;&#x69;&#108;&#116;&#111;&#58;&#91;&#99;&#x68;&#101;&#110;&#x67;&#x75;&#46;&#x2e;&#x2e;&#64;&#x67;&#109;&#97;&#105;&#108;&#x2e;&#99;&#111;&#x6d;&#x5d;&#40;&#41;">&#91;&#99;&#x68;&#101;&#110;&#x67;&#x75;&#46;&#x2e;&#x2e;&#64;&#x67;&#109;&#97;&#105;&#108;&#x2e;&#99;&#111;&#x6d;&#x5d;&#40;&#41;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问“什么是实施并行编程的最大障
碍”时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。
( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看
<a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/" target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/</a></a>
)</p>
<ol>
<li>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</li>
<li>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是“专家”们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了“编译指导”、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。
可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说“在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶……你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的”，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：“你觉得并行编程容易么？”，十有八九会说“我觉得很难”。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</li>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？
(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx
总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点“教育”有很大关系了。</li>
<li>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</li>
<li>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> 陨落雕 <img src="" alt=""></li>
</ol>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>呃，我想的障碍是: 1. 类C语言的统治地位; 2. 内存带宽不够; 3. 误导性宣传;</p>
<p>On Mar 21, 7:37 pm, Guancheng Chen <a href="&#x6d;&#97;&#105;&#108;&#116;&#111;&#x3a;&#91;&#99;&#104;&#101;&#110;&#103;&#117;&#x61;&#110;&#99;&#104;&#46;&#46;&#46;&#64;&#x67;&#x6d;&#x61;&#x69;&#108;&#46;&#x63;&#x6f;&#x6d;&#93;&#40;&#41;">&#91;&#99;&#104;&#101;&#110;&#103;&#117;&#x61;&#110;&#99;&#104;&#46;&#46;&#46;&#64;&#x67;&#x6d;&#x61;&#x69;&#108;&#46;&#x63;&#x6f;&#x6d;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看<a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..</p>
<p>)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。</p>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<blockquote>
<p>尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。
<a href="">显示删减掉的内容</a></p>
</li>
</ol>
</blockquote>
<p><img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>可是按现在的趋势，多核一定会在光处理器之前成为主流啊</p>
<p>On 3月22日, 上午12时42分, 机械唯物主义 : linjunhalida <a href="&#109;&#x61;&#x69;&#x6c;&#116;&#x6f;&#58;&#91;&#108;&#105;&#110;&#x6a;&#x75;&#x6e;&#104;&#97;&#x6c;&#x2e;&#46;&#46;&#64;&#x67;&#x6d;&#97;&#105;&#108;&#x2e;&#99;&#111;&#x6d;&#93;&#x28;&#41;">&#91;&#108;&#105;&#110;&#x6a;&#x75;&#x6e;&#104;&#97;&#x6c;&#x2e;&#46;&#46;&#64;&#x67;&#x6d;&#97;&#105;&#108;&#x2e;&#99;&#111;&#x6d;&#93;&#x28;&#41;</a>
wrote:</p>
<blockquote>
<p>恩恩，有些事情还是没有并行的必要。等光处理器出来就好了。</p>
<p>2010/3/22 Guancheng Chen <a href="&#x6d;&#97;&#x69;&#108;&#x74;&#111;&#58;&#x5b;&#x63;&#x68;&#x65;&#x6e;&#103;&#117;&#x61;&#110;&#99;&#104;&#46;&#x2e;&#46;&#x40;&#103;&#x6d;&#97;&#x69;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#41;">&#x5b;&#x63;&#x68;&#x65;&#x6e;&#103;&#117;&#x61;&#110;&#99;&#104;&#46;&#x2e;&#46;&#x40;&#103;&#x6d;&#97;&#x69;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#41;</a></p>
</blockquote>
<p>&gt;
&gt;
&gt;</p>
<blockquote>
<blockquote>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问“什么是实施并行编程的最大障
碍”时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..</p>
</blockquote>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<blockquote>
<blockquote>
<p>)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是“专家”们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了“编译指导”、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说“在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶……你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的”，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：“你觉得并行编程容易么？”，十有八九会说“我觉得很难”。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点“教育”有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。</p>
</li>
</ol>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
</blockquote>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<ol>
<li>C语言可以使用pthread等库实现并行化，C++ JAVA等已经会即将支持多线程 所以语言能实现并行化 只是难易问题</li>
<li>是指Shared memory模型，多核共享一条内存总线所以造成带宽问题么？这确实是个问题，不过我感觉硬件商家会负责为你带来越来越多的带
宽，而程序员的任务只是合理的利用好这些给定的带宽</li>
<li>能具体说说哪些误导宣传么？</li>
</ol>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>On 3月22日, 上午1时46分, 陨落雕 <a href="&#109;&#x61;&#105;&#x6c;&#116;&#x6f;&#58;&#91;&#103;&#x65;&#x6f;&#x2e;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#97;&#x69;&#x6c;&#46;&#x63;&#x6f;&#109;&#93;&#x28;&#x29;">&#91;&#103;&#x65;&#x6f;&#x2e;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#97;&#x69;&#x6c;&#46;&#x63;&#x6f;&#109;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>呃，我想的障碍是: 1. 类C语言的统治地位; 2. 内存带宽不够; 3. 误导性宣传;</p>
<p>On Mar 21, 7:37 pm, Guancheng Chen <a href="&#x6d;&#97;&#x69;&#x6c;&#116;&#x6f;&#58;&#x5b;&#99;&#x68;&#101;&#110;&#x67;&#x75;&#x61;&#110;&#99;&#x68;&#46;&#x2e;&#46;&#x40;&#103;&#109;&#97;&#105;&#108;&#46;&#x63;&#111;&#109;&#93;&#40;&#x29;">&#x5b;&#99;&#x68;&#101;&#110;&#x67;&#x75;&#x61;&#110;&#99;&#x68;&#46;&#x2e;&#46;&#x40;&#103;&#109;&#97;&#105;&#108;&#46;&#x63;&#111;&#109;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看<a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。
<a href="">显示删减掉的内容</a></p>
</li>
</ol>
</blockquote>
</blockquote>
<p><img src="" alt=""> Jeffrey Zhao <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是“抽象”这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上……我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog: <a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter: <a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p><strong>From:</strong> <a href="&quot;chenguancheng@gmail.com&quot;">Guancheng Chen</a></p>
<p><strong>Sent:</strong> Monday, March 22, 2010 7:37 AM
<strong>To:</strong> <a href="&quot;pongba@googlegroups.com&quot;">TopLanguage</a></p>
<p><strong>Subject:</strong> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问“什么是实施并行编程的最大障
碍”时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。
( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看
<a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/" target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/</a></a>
)</p>
<ol>
<li>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</li>
<li>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是“专家”们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了“编译指导”、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。
可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说“在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶……你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的”，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：“你觉得并行编程容易么？”，十有八九会说“我觉得很难”。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</li>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？
(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx
总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点“教育”有很大关系了。</li>
<li>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</li>
<li>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> tinyfool <img src="" alt=""></li>
</ol>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？
还有支持显卡计算的OpenCL也是无比强大啊。
2010/3/22 Jeffrey Zhao <a href="&#109;&#97;&#105;&#x6c;&#116;&#111;&#58;&#x5b;&#106;&#x65;&#x2e;&#x2e;&#x2e;&#64;&#108;&#105;&#118;&#x65;&#46;&#99;&#111;&#109;&#x5d;&#x28;&#41;">&#x5b;&#106;&#x65;&#x2e;&#x2e;&#x2e;&#64;&#108;&#105;&#118;&#x65;&#46;&#99;&#111;&#109;&#x5d;&#x28;&#41;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是“抽象”这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上……我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog: <a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter: <a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p><strong>From:</strong> <a href="&quot;chenguancheng@gmail.com&quot;">Guancheng Chen</a></p>
<p><strong>Sent:</strong> Monday, March 22, 2010 7:37 AM
<strong>To:</strong> <a href="&quot;pongba@googlegroups.com&quot;">TopLanguage</a></p>
<p><strong>Subject:</strong> [TL] {技术}{多线程}实施并行编程的五大障碍
近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问“什么是实施并行编程的最大障
碍”时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。
( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看
<a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/" target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/</a></a>
)</p>
<ol>
<li>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</li>
<li>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是“专家”们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了“编译指导”、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。
可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说“在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶……你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的”，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：“你觉得并行编程容易么？”，十有八九会说“我觉得很难”。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</li>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？
(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx
总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点“教育”有很大关系了。</li>
<li>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</li>
<li>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</li>
</ol>
<h2 id="to-unsubscribe-from-this-group-send-email-to-pongba-unsubscribegooglegroups-com-http-unsubscribegooglegroups-com-or-reply-to-this-email-with-the-words-remove-me-as-the-subject-">To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</h2>
<p>Tinyfool的开发日记 <a href="http://www.tinydust.net/dev/" target="_blank"><a href="http://www.tinydust.net/dev/">http://www.tinydust.net/dev/</a></a>
代码中国网 <a href="http://www.codechina.org/" target="_blank"><a href="http://www.codechina.org">http://www.codechina.org</a></a>
myTwitter: <a href="http://twitter.com/tinyfool" target="_blank"><a href="http://twitter.com/tinyfool">http://twitter.com/tinyfool</a></a>
<a href="">显示删减掉的内容</a></p>
<p><img src="" alt=""> 陨落雕 <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<ol>
<li>这和第二个问题是连起来的，到最后，你还是操作的mutable object，就是无穷无尽的memory consistency的麻烦；</li>
<li>就是这个问题，可惜从来都没跟上来过，光传输是一个可行性，如果实现了的确会改变现在的处境；</li>
<li>说在shared memory模型上内核数量可以无限上去的误导宣传，可惜这个20年前就失败，现在在TOP500上能看到的
supercomputer都是distributed memory model；</li>
</ol>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>On Mar 21, 8:58 pm, Guancheng Chen <a href="&#109;&#97;&#x69;&#108;&#116;&#111;&#58;&#x5b;&#99;&#x68;&#101;&#x6e;&#x67;&#117;&#x61;&#x6e;&#x63;&#104;&#x2e;&#46;&#x2e;&#x40;&#103;&#109;&#x61;&#x69;&#108;&#x2e;&#x63;&#111;&#109;&#93;&#x28;&#x29;">&#x5b;&#99;&#x68;&#101;&#x6e;&#x67;&#117;&#x61;&#x6e;&#x63;&#104;&#x2e;&#46;&#x2e;&#x40;&#103;&#109;&#x61;&#x69;&#108;&#x2e;&#x63;&#111;&#109;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<ol>
<li>C语言可以使用pthread等库实现并行化，C++ JAVA等已经会即将支持多线程 所以语言能实现并行化 只是难易问题</li>
<li>是指Shared memory模型，多核共享一条内存总线所以造成带宽问题么？这确实是个问题，不过我感觉硬件商家会负责为你带来越来越多的带
宽，而程序员的任务只是合理的利用好这些给定的带宽</li>
<li>能具体说说哪些误导宣传么？</li>
</ol>
<p>On 3月22日, 上午1时46分, 陨落雕 <a href="&#x6d;&#x61;&#x69;&#108;&#x74;&#111;&#x3a;&#x5b;&#103;&#x65;&#x6f;&#46;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#109;&#x61;&#105;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#93;&#40;&#41;">&#x5b;&#103;&#x65;&#x6f;&#46;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#109;&#x61;&#105;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>呃，我想的障碍是: 1. 类C语言的统治地位; 2. 内存带宽不够; 3. 误导性宣传;</p>
<p>On Mar 21, 7:37 pm, Guancheng Chen <a href="&#109;&#97;&#105;&#108;&#x74;&#x6f;&#x3a;&#91;&#99;&#x68;&#x65;&#110;&#103;&#117;&#x61;&#110;&#x63;&#x68;&#x2e;&#46;&#x2e;&#64;&#x67;&#109;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#111;&#109;&#x5d;&#x28;&#x29;">&#91;&#99;&#x68;&#x65;&#110;&#103;&#117;&#x61;&#110;&#x63;&#x68;&#x2e;&#46;&#x2e;&#64;&#x67;&#109;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#111;&#109;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看<a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。
<a href="">显示删减掉的内容</a>
<img src="" alt=""> 陨落雕 <img src="" alt=""></p>
</li>
</ol>
</blockquote>
</blockquote>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>OpenCL解决了一大类的问题（每个kernel只需要一小部分数据，类似rasterization的渲染），而且现在他们有动力解决另一大类的问
题（每个小的kernel需要查询大量数据，类似ray tracer的渲染）。但是现在移植还是好困难啊，特别是显存和内存通信时候的
consolation，头疼死了，显存不够要swap out的时候，也很头疼。</p>
<p>On Mar 21, 9:20 pm, Tinyfool <a href="&#x6d;&#97;&#105;&#x6c;&#116;&#x6f;&#58;&#91;&#x74;&#105;&#110;&#x79;&#102;&#x2e;&#46;&#46;&#x40;&#x67;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#x29;">&#91;&#x74;&#105;&#110;&#x79;&#102;&#x2e;&#46;&#46;&#x40;&#x67;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#x6d;&#97;&#105;&#x6c;&#116;&#111;&#58;&#x5b;&#106;&#101;&#x2e;&#x2e;&#x2e;&#64;&#x6c;&#x69;&#x76;&#101;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#40;&#41;">&#x5b;&#106;&#101;&#x2e;&#x2e;&#x2e;&#64;&#x6c;&#x69;&#x76;&#101;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#40;&#41;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
</blockquote>
</blockquote>
<p>&gt;</p>
<blockquote>
<blockquote>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#109;&#97;&#105;&#x6c;&#116;&#111;&#58;&#91;&#99;&#x68;&#x65;&#x6e;&#x67;&#117;&#97;&#110;&#x63;&#x68;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#109;&#x61;&#x69;&#108;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#x28;&#x29;">&#91;&#99;&#x68;&#x65;&#x6e;&#x67;&#117;&#97;&#110;&#x63;&#x68;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#109;&#x61;&#x69;&#108;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#x28;&#x29;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#109;&#97;&#105;&#x6c;&#116;&#111;&#58;&#x5b;&#112;&#111;&#110;&#x2e;&#46;&#46;&#64;&#x67;&#x6f;&#x6f;&#x67;&#x6c;&#x65;&#103;&#114;&#x6f;&#117;&#x70;&#x73;&#x2e;&#x63;&#111;&#109;&#x5d;&#x28;&#41;">&#x5b;&#112;&#111;&#110;&#x2e;&#46;&#46;&#64;&#x67;&#x6f;&#x6f;&#x67;&#x6c;&#x65;&#103;&#114;&#x6f;&#117;&#x70;&#x73;&#x2e;&#x63;&#111;&#109;&#x5d;&#x28;&#41;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
</blockquote>
</blockquote>
<p>&gt;</p>
<blockquote>
<blockquote>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..</p>
<p>)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。</p>
</blockquote>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<blockquote>
<blockquote>
<p>尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。</p>
</li>
</ol>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>--
Tinyfool的开发日记<a href="http://www.tinydust.net/dev/" target="_blank"><a href="http://www.tinydust.net/dev/">http://www.tinydust.net/dev/</a></a>
代码中国网<a href="http://www.codechina.org/" target="_blank"><a href="http://www.codechina.org">http://www.codechina.org</a></a>
myTwitter:<a href="http://twitter.com/tinyfool" target="_blank"><a href="http://twitter.com/tinyfool">http://twitter.com/tinyfool</a></a>
<a href="">显示删减掉的内容</a></p>
</blockquote>
<p><img src="" alt=""> Jeffrey Zhao <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>哈哈，广告好，扩展视野，那我继续做广告了……</p>
<p>微软其实很早就在搞Microsoft Accelerator项目，旨在利用DirectX进行计算，.NET项目。 <a href="http://research.microsoft.com/en-us/projects/Accelerator/" title="http://research.microsoft.com/en-us/projects/Accelerator/
CTRL + 单击以下链接"><a href="http://research.microsoft.com/en-us/projects/Accelerator/" target="_blank">http://research.microsoft.com/en-us/projects/Accelerator/</a></a></p>
<p>然后F/#这边由于语言的支持良好，可以设计出丰富的表达式、DSL等Modeling Language，再由框架进行自动并行，解决问题可以很容易（已经2.0了）。</p>
<p>这篇文章是个简单介绍：<a href="http://strangelights.com/blog/archive/2008/09/21/1628.aspx" target="_blank"><a href="http://strangelights.com/blog/archive/2008/09/21/1628.aspx">http://strangelights.com/blog/archive/2008/09/21/1628.aspx</a></a></p>
<p>Microsoft Solver Foundation <a href="http://code.msdn.microsoft.com/solverfoundation" target="_blank"><a href="http://code.msdn.microsoft.com/solverfoundation">http://code.msdn.microsoft.com/solverfoundation</a></a></p>
<p>F/# Optimization Modeling Language Utilizing Microsoft Solver Foundation <a href="http://code.msdn.microsoft.com/solverfoundationfs1" title="http://code.msdn.microsoft.com/solverfoundationfs1
CTRL + 单击以下链接"><a href="http://code.msdn.microsoft.com/solverfoundationfs1" target="_blank">http://code.msdn.microsoft.com/solverfoundationfs1</a></a></p>
<p>现在就等OpenCL如果有标准出来，肯定立马可以跟上个类库，哦耶。</p>
<p>Jeffrey Zhao
Blog: <a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter: <a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a>
<strong>From:</strong> <a href="&quot;tinyfool@gmail.com&quot;">Tinyfool</a></p>
<p><strong>Sent:</strong> Monday, March 22, 2010 9:20 AM
<strong>To:</strong> <a href="&quot;pongba@googlegroups.com&quot;">pon...@googlegroups.com</a></p>
<p><strong>Subject:</strong> Re: [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？
还有支持显卡计算的OpenCL也是无比强大啊。
2010/3/22 Jeffrey Zhao <a href="&#x6d;&#97;&#x69;&#x6c;&#x74;&#111;&#58;&#91;&#x6a;&#x65;&#46;&#x2e;&#46;&#64;&#x6c;&#x69;&#118;&#101;&#46;&#99;&#111;&#109;&#93;&#40;&#x29;">&#91;&#x6a;&#x65;&#46;&#x2e;&#46;&#64;&#x6c;&#x69;&#118;&#101;&#46;&#99;&#111;&#109;&#93;&#40;&#x29;</a>
我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是“抽象”这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上……我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog: <a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter: <a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p><strong>From:</strong> <a href="&quot;chenguancheng@gmail.com&quot;">Guancheng Chen</a></p>
<p><strong>Sent:</strong> Monday, March 22, 2010 7:37 AM
<strong>To:</strong> <a href="&quot;pongba@googlegroups.com&quot;">TopLanguage</a></p>
<p><strong>Subject:</strong> [TL] {技术}{多线程}实施并行编程的五大障碍
近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问“什么是实施并行编程的最大障
碍”时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。
( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看
<a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/" target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/</a></a>
)</p>
<ol>
<li>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</li>
<li>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是“专家”们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了“编译指导”、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。
可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说“在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶……你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的”，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：“你觉得并行编程容易么？”，十有八九会说“我觉得很难”。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</li>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？
(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx
总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点“教育”有很大关系了。</li>
<li>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</li>
<li>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</li>
</ol>
<h2 id="to-unsubscribe-from-this-group-send-email-to-pongba-unsubscribegooglegroups-com-http-unsubscribegooglegroups-com-or-reply-to-this-email-with-the-words-remove-me-as-the-subject-">To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</h2>
<p>Tinyfool的开发日记 <a href="http://www.tinydust.net/dev/" target="_blank"><a href="http://www.tinydust.net/dev/">http://www.tinydust.net/dev/</a></a>
代码中国网 <a href="http://www.codechina.org/" target="_blank"><a href="http://www.codechina.org">http://www.codechina.org</a></a>
myTwitter: <a href="http://twitter.com/tinyfool" target="_blank"><a href="http://twitter.com/tinyfool">http://twitter.com/tinyfool</a></a></p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> tinyfool <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>OpenCL早就出来标准了，而且在做各个平台的实现…</p>
<p>视野啊…
2010/3/22 Jeffrey Zhao <a href="&#x6d;&#x61;&#105;&#x6c;&#116;&#111;&#x3a;&#91;&#106;&#x65;&#46;&#46;&#x2e;&#x40;&#108;&#x69;&#x76;&#101;&#x2e;&#99;&#x6f;&#x6d;&#93;&#x28;&#41;">&#91;&#106;&#x65;&#46;&#46;&#x2e;&#x40;&#108;&#x69;&#x76;&#101;&#x2e;&#99;&#x6f;&#x6d;&#93;&#x28;&#41;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>哈哈，广告好，扩展视野，那我继续做广告了……</p>
<p>微软其实很早就在搞Microsoft Accelerator项目，旨在利用DirectX进行计算，.NET项目。 <a href="http://research.microsoft.com/en-us/projects/Accelerator/" title="http://research.microsoft.com/en-us/projects/Accelerator/
CTRL + 单击以下链接"><a href="http://research.microsoft.com/en-us/projects/Accelerator/" target="_blank">http://research.microsoft.com/en-us/projects/Accelerator/</a></a></p>
<p>然后F/#这边由于语言的支持良好，可以设计出丰富的表达式、DSL等Modeling Language，再由框架进行自动并行，解决问题可以很容易（已经2.0了）。</p>
<p>这篇文章是个简单介绍：<a href="http://strangelights.com/blog/archive/2008/09/21/1628.aspx" target="_blank"><a href="http://strangelights.com/blog/archive/2008/09/21/1628.aspx">http://strangelights.com/blog/archive/2008/09/21/1628.aspx</a></a></p>
<p>Microsoft Solver Foundation <a href="http://code.msdn.microsoft.com/solverfoundation" target="_blank"><a href="http://code.msdn.microsoft.com/solverfoundation">http://code.msdn.microsoft.com/solverfoundation</a></a></p>
<p>F/# Optimization Modeling Language Utilizing Microsoft Solver Foundation <a href="http://code.msdn.microsoft.com/solverfoundationfs1" title="http://code.msdn.microsoft.com/solverfoundationfs1
CTRL + 单击以下链接"><a href="http://code.msdn.microsoft.com/solverfoundationfs1" target="_blank">http://code.msdn.microsoft.com/solverfoundationfs1</a></a></p>
<p>现在就等OpenCL如果有标准出来，肯定立马可以跟上个类库，哦耶。</p>
<p>Jeffrey Zhao
Blog: <a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter: <a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a>
<strong>From:</strong> <a href="&quot;tinyfool@gmail.com&quot;">Tinyfool</a></p>
<p><strong>Sent:</strong> Monday, March 22, 2010 9:20 AM
<strong>To:</strong> <a href="&quot;pongba@googlegroups.com&quot;">pon...@googlegroups.com</a></p>
<p><strong>Subject:</strong> Re: [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？
还有支持显卡计算的OpenCL也是无比强大啊。
2010/3/22 Jeffrey Zhao <a href="&#x6d;&#97;&#105;&#108;&#x74;&#x6f;&#58;&#91;&#106;&#x65;&#x2e;&#46;&#46;&#x40;&#108;&#105;&#118;&#101;&#46;&#99;&#111;&#109;&#93;&#40;&#41;">&#91;&#106;&#x65;&#x2e;&#46;&#46;&#x40;&#108;&#105;&#118;&#101;&#46;&#99;&#111;&#109;&#93;&#40;&#41;</a>
我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是“抽象”这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上……我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog: <a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter: <a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p><strong>From:</strong> <a href="&quot;chenguancheng@gmail.com&quot;">Guancheng Chen</a></p>
<p><strong>Sent:</strong> Monday, March 22, 2010 7:37 AM
<strong>To:</strong> <a href="&quot;pongba@googlegroups.com&quot;">TopLanguage</a></p>
<p><strong>Subject:</strong> [TL] {技术}{多线程}实施并行编程的五大障碍
近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问“什么是实施并行编程的最大障
碍”时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。
( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看
<a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/" target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/</a></a>
)</p>
<ol>
<li>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</li>
<li>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是“专家”们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了“编译指导”、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。
可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说“在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶……你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的”，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：“你觉得并行编程容易么？”，十有八九会说“我觉得很难”。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</li>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？
(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx
总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点“教育”有很大关系了。</li>
<li>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</li>
<li>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</li>
</ol>
<h2 id="to-unsubscribe-from-this-group-send-email-to-pongba-unsubscribegooglegroups-com-http-unsubscribegooglegroups-com-or-reply-to-this-email-with-the-words-remove-me-as-the-subject-">To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</h2>
<p>Tinyfool的开发日记 <a href="http://www.tinydust.net/dev/" target="_blank"><a href="http://www.tinydust.net/dev/">http://www.tinydust.net/dev/</a></a>
代码中国网 <a href="http://www.codechina.org/" target="_blank"><a href="http://www.codechina.org">http://www.codechina.org</a></a>
myTwitter: <a href="http://twitter.com/tinyfool" target="_blank"><a href="http://twitter.com/tinyfool">http://twitter.com/tinyfool</a></a></p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>--
Tinyfool的开发日记 <a href="http://www.tinydust.net/dev/" target="_blank"><a href="http://www.tinydust.net/dev/">http://www.tinydust.net/dev/</a></a>
代码中国网 <a href="http://www.codechina.org/" target="_blank"><a href="http://www.codechina.org">http://www.codechina.org</a></a>
myTwitter: <a href="http://twitter.com/tinyfool" target="_blank"><a href="http://twitter.com/tinyfool">http://twitter.com/tinyfool</a></a>
<a href="">显示删减掉的内容</a></p>
<p><img src="" alt=""> woo <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>C的pthread太重量级了，我觉得golang的go要好很多，虽然只是试验阶段</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>On 17:58 Sun 21 Mar     , Guancheng Chen wrote:</p>
<blockquote>
<ol>
<li>C语言可以使用pthread等库实现并行化，C++ JAVA等已经会即将支持多线程 所以语言能实现并行化 只是难易问题</li>
<li>是指Shared memory模型，多核共享一条内存总线所以造成带宽问题么？这确实是个问题，不过我感觉硬件商家会负责为你带来越来越多的带
宽，而程序员的任务只是合理的利用好这些给定的带宽</li>
<li>能具体说说哪些误导宣传么？</li>
</ol>
<p>On 3月22日, 上午1时46分, 陨落雕 <a href="&#109;&#x61;&#105;&#108;&#x74;&#x6f;&#x3a;&#x5b;&#103;&#101;&#111;&#46;&#x2e;&#x2e;&#x2e;&#64;&#103;&#x6d;&#97;&#105;&#x6c;&#46;&#x63;&#x6f;&#109;&#x5d;&#40;&#x29;">&#x5b;&#103;&#101;&#111;&#46;&#x2e;&#x2e;&#x2e;&#64;&#103;&#x6d;&#97;&#105;&#x6c;&#46;&#x63;&#x6f;&#109;&#x5d;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>呃，我想的障碍是: 1. 类C语言的统治地位; 2. 内存带宽不够; 3. 误导性宣传;</p>
<p>On Mar 21, 7:37 pm, Guancheng Chen <a href="&#109;&#97;&#105;&#x6c;&#x74;&#111;&#58;&#91;&#x63;&#x68;&#101;&#x6e;&#x67;&#x75;&#97;&#110;&#99;&#x68;&#46;&#x2e;&#x2e;&#64;&#103;&#109;&#97;&#105;&#x6c;&#46;&#99;&#x6f;&#109;&#x5d;&#40;&#41;">&#91;&#x63;&#x68;&#101;&#x6e;&#x67;&#x75;&#97;&#110;&#99;&#x68;&#46;&#x2e;&#x2e;&#64;&#103;&#109;&#97;&#105;&#x6c;&#46;&#99;&#x6f;&#109;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看<a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。</p>
</li>
</ol>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> 陨落雕 <img src="" alt=""></p>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>言多必失啊，coalescing是写显存时候的问题，单词也拼错了......</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>On Mar 21, 9:33 pm, 陨落雕 <a href="&#109;&#97;&#x69;&#x6c;&#116;&#111;&#x3a;&#x5b;&#103;&#101;&#111;&#46;&#x2e;&#46;&#x2e;&#64;&#x67;&#109;&#97;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#109;&#x5d;&#40;&#41;">&#x5b;&#103;&#101;&#111;&#46;&#x2e;&#46;&#x2e;&#64;&#x67;&#109;&#97;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#109;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>OpenCL解决了一大类的问题（每个kernel只需要一小部分数据，类似rasterization的渲染），而且现在他们有动力解决另一大类的问
题（每个小的kernel需要查询大量数据，类似ray tracer的渲染）。但是现在移植还是好困难啊，特别是显存和内存通信时候的
consolation，头疼死了，显存不够要swap out的时候，也很头疼。</p>
<p>On Mar 21, 9:20 pm, Tinyfool <a href="&#x6d;&#x61;&#105;&#108;&#116;&#111;&#x3a;&#x5b;&#116;&#x69;&#x6e;&#x79;&#102;&#46;&#46;&#46;&#64;&#103;&#109;&#x61;&#105;&#108;&#46;&#99;&#111;&#x6d;&#x5d;&#40;&#41;">&#x5b;&#116;&#x69;&#x6e;&#x79;&#102;&#46;&#46;&#46;&#64;&#103;&#109;&#x61;&#105;&#108;&#46;&#99;&#111;&#x6d;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#109;&#97;&#105;&#108;&#x74;&#x6f;&#x3a;&#x5b;&#106;&#x65;&#46;&#46;&#x2e;&#64;&#x6c;&#105;&#118;&#101;&#x2e;&#99;&#x6f;&#109;&#x5d;&#40;&#41;">&#x5b;&#106;&#x65;&#46;&#46;&#x2e;&#64;&#x6c;&#105;&#118;&#101;&#x2e;&#99;&#x6f;&#109;&#x5d;&#40;&#41;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#x6d;&#x61;&#x69;&#x6c;&#116;&#x6f;&#58;&#91;&#x63;&#x68;&#x65;&#x6e;&#103;&#x75;&#x61;&#x6e;&#x63;&#x68;&#46;&#x2e;&#x2e;&#64;&#103;&#109;&#97;&#x69;&#108;&#46;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#x29;">&#91;&#x63;&#x68;&#x65;&#x6e;&#103;&#x75;&#x61;&#x6e;&#x63;&#x68;&#46;&#x2e;&#x2e;&#64;&#103;&#109;&#97;&#x69;&#108;&#46;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#x29;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#109;&#x61;&#x69;&#108;&#116;&#111;&#58;&#x5b;&#112;&#111;&#x6e;&#x2e;&#46;&#46;&#64;&#x67;&#x6f;&#111;&#x67;&#108;&#101;&#x67;&#114;&#111;&#117;&#112;&#x73;&#x2e;&#99;&#111;&#x6d;&#93;&#40;&#41;">&#x5b;&#112;&#111;&#x6e;&#x2e;&#46;&#46;&#64;&#x67;&#x6f;&#111;&#x67;&#108;&#101;&#x67;&#114;&#111;&#117;&#112;&#x73;&#x2e;&#99;&#111;&#x6d;&#93;&#40;&#41;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。</p>
</li>
</ol>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>--
Tinyfool的开发日记<a href="http://www.tinydust.net/dev/" target="_blank"><a href="http://www.tinydust.net/dev/">http://www.tinydust.net/dev/</a></a></p>
</blockquote>
<p>...</p>
<p>read more &gt;&gt;
<a href="">显示删减掉的内容</a></p>
</blockquote>
<p><img src="" alt=""> Jeffrey Zhao <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>是嘛，我记得是提交了标准还在审核。</p>
<p>好吧，我去查了一下果然在08年12月1.0 Stable release了。</p>
<p>Jeffrey Zhao
Blog: <a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter: <a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a>
<strong>From:</strong> <a href="&quot;tinyfool@gmail.com&quot;">Tinyfool</a></p>
<p><strong>Sent:</strong> Monday, March 22, 2010 9:46 AM</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p><strong>To:</strong> <a href="&quot;pongba@googlegroups.com&quot;">pon...@googlegroups.com</a></p>
<p><strong>Subject:</strong> Re: [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>OpenCL早就出来标准了，而且在做各个平台的实现…</p>
<p>视野啊…
2010/3/22 Jeffrey Zhao <a href="&#109;&#x61;&#x69;&#108;&#116;&#111;&#58;&#91;&#106;&#x65;&#46;&#x2e;&#x2e;&#64;&#108;&#105;&#118;&#101;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#40;&#x29;">&#91;&#106;&#x65;&#46;&#x2e;&#x2e;&#64;&#108;&#105;&#118;&#101;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#40;&#x29;</a>
哈哈，广告好，扩展视野，那我继续做广告了……</p>
<p>微软其实很早就在搞Microsoft Accelerator项目，旨在利用DirectX进行计算，.NET项目。 <a href="http://research.microsoft.com/en-us/projects/Accelerator/" title="http://research.microsoft.com/en-us/projects/Accelerator/
CTRL + 单击以下链接"><a href="http://research.microsoft.com/en-us/projects/Accelerator/" target="_blank">http://research.microsoft.com/en-us/projects/Accelerator/</a></a></p>
<p>然后F/#这边由于语言的支持良好，可以设计出丰富的表达式、DSL等Modeling Language，再由框架进行自动并行，解决问题可以很容易（已经2.0了）。</p>
<p>这篇文章是个简单介绍：<a href="http://strangelights.com/blog/archive/2008/09/21/1628.aspx" title="http://strangelights.com/blog/archive/2008/09/21/1628.aspx
CTRL + 单击以下链接"><a href="http://strangelights.com/blog/archive/2008/09/21/1628.aspx" target="_blank">http://strangelights.com/blog/archive/2008/09/21/1628.aspx</a></a></p>
<p>Microsoft Solver Foundation <a href="http://code.msdn.microsoft.com/solverfoundation" title="http://code.msdn.microsoft.com/solverfoundation
CTRL + 单击以下链接"><a href="http://code.msdn.microsoft.com/solverfoundation" target="_blank">http://code.msdn.microsoft.com/solverfoundation</a></a></p>
<p>F/# Optimization Modeling Language Utilizing Microsoft Solver Foundation <a href="http://code.msdn.microsoft.com/solverfoundationfs1" title="http://code.msdn.microsoft.com/solverfoundationfs1
CTRL + 单击以下链接"><a href="http://code.msdn.microsoft.com/solverfoundationfs1" target="_blank">http://code.msdn.microsoft.com/solverfoundationfs1</a></a></p>
<p>现在就等OpenCL如果有标准出来，肯定立马可以跟上个类库，哦耶。</p>
<p>Jeffrey Zhao
Blog: <a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter: <a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a>
<strong>From:</strong> <a href="&quot;tinyfool@gmail.com&quot;">Tinyfool</a></p>
<p><strong>Sent:</strong> Monday, March 22, 2010 9:20 AM
<strong>To:</strong> <a href="&quot;pongba@googlegroups.com&quot;">pon...@googlegroups.com</a></p>
<p><strong>Subject:</strong> Re: [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？
还有支持显卡计算的OpenCL也是无比强大啊。
2010/3/22 Jeffrey Zhao <a href="&#109;&#97;&#105;&#x6c;&#116;&#111;&#58;&#x5b;&#x6a;&#101;&#46;&#46;&#46;&#64;&#x6c;&#105;&#118;&#101;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#41;">&#x5b;&#x6a;&#101;&#46;&#46;&#46;&#64;&#x6c;&#105;&#118;&#101;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#41;</a>
我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是“抽象”这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上……我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog: <a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter: <a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p><strong>From:</strong> <a href="&quot;chenguancheng@gmail.com&quot;">Guancheng Chen</a></p>
<p><strong>Sent:</strong> Monday, March 22, 2010 7:37 AM
<strong>To:</strong> <a href="&quot;pongba@googlegroups.com&quot;">TopLanguage</a></p>
<p><strong>Subject:</strong> [TL] {技术}{多线程}实施并行编程的五大障碍
近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问“什么是实施并行编程的最大障
碍”时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。
( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看
<a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/" target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/</a></a>
)</p>
<ol>
<li>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</li>
<li>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是“专家”们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了“编译指导”、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。
可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说“在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶……你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的”，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：“你觉得并行编程容易么？”，十有八九会说“我觉得很难”。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</li>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？
(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx
总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点“教育”有很大关系了。</li>
<li>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</li>
<li>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</li>
</ol>
<h2 id="to-unsubscribe-from-this-group-send-email-to-pongba-unsubscribegooglegroups-com-http-unsubscribegooglegroups-com-or-reply-to-this-email-with-the-words-remove-me-as-the-subject-">To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</h2>
<p>Tinyfool的开发日记 <a href="http://www.tinydust.net/dev/" target="_blank"><a href="http://www.tinydust.net/dev/">http://www.tinydust.net/dev/</a></a>
代码中国网 <a href="http://www.codechina.org/" target="_blank"><a href="http://www.codechina.org">http://www.codechina.org</a></a>
myTwitter: <a href="http://twitter.com/tinyfool" target="_blank"><a href="http://twitter.com/tinyfool">http://twitter.com/tinyfool</a></a></p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<h2 id="to-unsubscribe-from-this-group-send-email-to-pongba-unsubscribegooglegroups-com-http-unsubscribegooglegroups-com-or-reply-to-this-email-with-the-words-remove-me-as-the-subject-">To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</h2>
<p>Tinyfool的开发日记 <a href="http://www.tinydust.net/dev/" target="_blank"><a href="http://www.tinydust.net/dev/">http://www.tinydust.net/dev/</a></a>
代码中国网 <a href="http://www.codechina.org/" target="_blank"><a href="http://www.codechina.org">http://www.codechina.org</a></a>
myTwitter: <a href="http://twitter.com/tinyfool" target="_blank"><a href="http://twitter.com/tinyfool">http://twitter.com/tinyfool</a></a></p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> changsheng <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>个人觉得最大障碍在工具上.</p>
<p>并行学术上研究得不少, 主要在算法和模型上. 工程上的工具, 多是自串行程序来设计的, 弄得复杂不堪. 并行需要语言和库两级支持, Pthreads 和 MPI 仅从库上入手, 让程序员处理各种重复且复杂的分发, 并发锁等. OpenMP好一些, 可惜目前只支持线程并行.
用 ErLang 等将并行设计在语言里的来做并行会容易得多, 得易于面向消息传递的隔离模型, 程序稳定易写. 模型和语言的性能是一个问题, 主要的问题还在用的人和实际并行项目不多.</p>
<p>调试工具就更少了. 有少数商业化的工具.
当然, 我是将可维护性归结为语言工具太差.</p>
<pre><code>                                                 Changsheng Jiang
</code></pre><p>2010/3/22 Guancheng Chen <a href="&#109;&#97;&#105;&#x6c;&#116;&#111;&#58;&#x5b;&#99;&#x68;&#101;&#110;&#103;&#117;&#46;&#46;&#46;&#64;&#103;&#109;&#97;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#93;&#40;&#x29;">&#x5b;&#99;&#x68;&#101;&#110;&#103;&#117;&#46;&#46;&#46;&#64;&#103;&#109;&#97;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#93;&#40;&#x29;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问“什么是实施并行编程的最大障
碍”时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。
( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看
<a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/" target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/</a></a>
)</p>
<ol>
<li>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</li>
<li>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是“专家”们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了“编译指导”、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。
可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说“在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶……你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的”，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：“你觉得并行编程容易么？”，十有八九会说“我觉得很难”。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</li>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？
(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx
总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点“教育”有很大关系了。</li>
<li>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</li>
<li>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。</li>
</ol>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a></p>
<p><img src="" alt=""> Milo Yip <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>我在等NVidia的Fermi和Nexus，想試做全域照明。
但怕買了Fermi後，機器也只是用來做做翻譯……</p>
<p>在 2010年3月22日上午9:51，Jeffrey Zhao <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#x3a;&#x5b;&#106;&#x65;&#46;&#x2e;&#46;&#x40;&#x6c;&#105;&#118;&#x65;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#40;&#x29;">&#x5b;&#106;&#x65;&#46;&#x2e;&#46;&#x40;&#x6c;&#105;&#118;&#x65;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#40;&#x29;</a> 寫道：</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<blockquote>
<p>是嘛，我记得是提交了标准还在审核。</p>
<p>好吧，我去查了一下果然在08年12月1.0 Stable release了。</p>
<p>Jeffrey Zhao
Blog: <a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter: <a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a>
From: Tinyfool
Sent: Monday, March 22, 2010 9:46 AM
To: <a href="">pon...@googlegroups.com</a>
Subject: Re: [TL] {技术}{多线程}实施并行编程的五大障碍
OpenCL早就出来标准了，而且在做各个平台的实现…
视野啊…</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#109;&#x61;&#105;&#108;&#x74;&#x6f;&#x3a;&#x5b;&#x6a;&#101;&#x2e;&#x2e;&#46;&#64;&#x6c;&#x69;&#x76;&#x65;&#46;&#x63;&#x6f;&#109;&#x5d;&#x28;&#x29;">&#x5b;&#x6a;&#101;&#x2e;&#x2e;&#46;&#64;&#x6c;&#x69;&#x76;&#x65;&#46;&#x63;&#x6f;&#109;&#x5d;&#x28;&#x29;</a>
&gt;</p>
<blockquote>
<p>哈哈，广告好，扩展视野，那我继续做广告了……</p>
<p>微软其实很早就在搞Microsoft Accelerator项目，旨在利用DirectX进行计算，.NET项目。
<a href="http://research.microsoft.com/en-us/projects/Accelerator/" target="_blank"><a href="http://research.microsoft.com/en-us/projects/Accelerator/">http://research.microsoft.com/en-us/projects/Accelerator/</a></a></p>
<p>然后F/#这边由于语言的支持良好，可以设计出丰富的表达式、DSL等Modeling
Language，再由框架进行自动并行，解决问题可以很容易（已经2.0了）。</p>
<p>这篇文章是个简单介绍：<a href="http://strangelights.com/blog/archive/2008/09/21/1628.aspx" target="_blank"><a href="http://strangelights.com/blog/archive/2008/09/21/1628.aspx">http://strangelights.com/blog/archive/2008/09/21/1628.aspx</a></a></p>
<p>Microsoft Solver Foundation
<a href="http://code.msdn.microsoft.com/solverfoundation" target="_blank"><a href="http://code.msdn.microsoft.com/solverfoundation">http://code.msdn.microsoft.com/solverfoundation</a></a></p>
<p>F/# Optimization Modeling Language Utilizing Microsoft Solver Foundation
<a href="http://code.msdn.microsoft.com/solverfoundationfs1" target="_blank"><a href="http://code.msdn.microsoft.com/solverfoundationfs1">http://code.msdn.microsoft.com/solverfoundationfs1</a></a></p>
<p>现在就等OpenCL如果有标准出来，肯定立马可以跟上个类库，哦耶。</p>
<p>Jeffrey Zhao
Blog: <a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter: <a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a>
From: Tinyfool
Sent: Monday, March 22, 2010 9:20 AM
To: <a href="">pon...@googlegroups.com</a>
Subject: Re: [TL] {技术}{多线程}实施并行编程的五大障碍
唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下
Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？
还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#x6f;&#58;&#x5b;&#106;&#x65;&#46;&#46;&#x2e;&#64;&#108;&#105;&#118;&#101;&#46;&#99;&#111;&#x6d;&#93;&#x28;&#41;">&#x5b;&#106;&#x65;&#46;&#46;&#x2e;&#64;&#108;&#105;&#118;&#101;&#46;&#99;&#111;&#x6d;&#93;&#x28;&#41;</a>
&gt;</p>
<blockquote>
<p>我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是“抽象”这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上……我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog: <a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter: <a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a>
From: Guancheng Chen
Sent: Monday, March 22, 2010 7:37 AM
To: TopLanguage
Subject: [TL] {技术}{多线程}实施并行编程的五大障碍
近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问“什么是实施并行编程的最大障
碍”时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/" target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/</a></a>
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是“专家”们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了“编译指导”、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说“在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶……你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的”，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：“你觉得并行编程容易么？”，十有八九会说“我觉得很难”。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点“教育”有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。</p>
</li>
</ol>
<p>To unsubscribe from this group, send email to
pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to
pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>--
Tinyfool的开发日记 <a href="http://www.tinydust.net/dev/" target="_blank"><a href="http://www.tinydust.net/dev/">http://www.tinydust.net/dev/</a></a>
代码中国网 <a href="http://www.codechina.org/" target="_blank"><a href="http://www.codechina.org">http://www.codechina.org</a></a>
myTwitter: <a href="http://twitter.com/tinyfool" target="_blank"><a href="http://twitter.com/tinyfool">http://twitter.com/tinyfool</a></a></p>
<p>To unsubscribe from this group, send email to
pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to
pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>--
Tinyfool的开发日记 <a href="http://www.tinydust.net/dev/" target="_blank"><a href="http://www.tinydust.net/dev/">http://www.tinydust.net/dev/</a></a>
代码中国网 <a href="http://www.codechina.org/" target="_blank"><a href="http://www.codechina.org">http://www.codechina.org</a></a>
myTwitter: <a href="http://twitter.com/tinyfool" target="_blank"><a href="http://twitter.com/tinyfool">http://twitter.com/tinyfool</a></a></p>
<p>To unsubscribe from this group, send email to
pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to
pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>--
Milo Yip</p>
<p>Twitter @miloyip
<a href="http://www.cnblogs.com/miloyip/" target="_blank"><a href="http://www.cnblogs.com/miloyip/">http://www.cnblogs.com/miloyip/</a></a>
<a href="http://miloyip.seezone.net/" target="_blank"><a href="http://miloyip.seezone.net/">http://miloyip.seezone.net/</a></a>
<a href="">显示删减掉的内容</a>
<img src="" alt=""> Milo Yip <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>應該是「全局照明」</p>
<p>在 2010年3月22日上午10:20，Milo Yip <a href="&#109;&#97;&#105;&#108;&#x74;&#x6f;&#58;&#x5b;&#109;&#x69;&#108;&#46;&#x2e;&#x2e;&#64;&#103;&#109;&#97;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#93;&#40;&#41;">&#x5b;&#109;&#x69;&#108;&#46;&#x2e;&#x2e;&#64;&#103;&#109;&#97;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#93;&#40;&#41;</a> 寫道：</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<blockquote>
<p>我在等NVidia的Fermi和Nexus，想試做全域照明。
但怕買了Fermi後，機器也只是用來做做翻譯……</p>
<p>在 2010年3月22日上午9:51，Jeffrey Zhao <a href="&#109;&#97;&#105;&#108;&#x74;&#x6f;&#58;&#x5b;&#x6a;&#x65;&#46;&#x2e;&#x2e;&#x40;&#x6c;&#x69;&#118;&#x65;&#46;&#x63;&#x6f;&#109;&#93;&#40;&#x29;">&#x5b;&#x6a;&#x65;&#46;&#x2e;&#x2e;&#x40;&#x6c;&#x69;&#118;&#x65;&#46;&#x63;&#x6f;&#109;&#93;&#40;&#x29;</a> 寫道：</p>
<blockquote>
<p>是嘛，我记得是提交了标准还在审核。</p>
<p>好吧，我去查了一下果然在08年12月1.0 Stable release了。</p>
<p>Jeffrey Zhao
Blog: <a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter: <a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a>
From: Tinyfool
Sent: Monday, March 22, 2010 9:46 AM
To: <a href="">pon...@googlegroups.com</a>
Subject: Re: [TL] {技术}{多线程}实施并行编程的五大障碍
OpenCL早就出来标准了，而且在做各个平台的实现…
视野啊…</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#109;&#x61;&#x69;&#108;&#116;&#111;&#58;&#x5b;&#x6a;&#101;&#x2e;&#x2e;&#x2e;&#x40;&#108;&#105;&#x76;&#x65;&#46;&#x63;&#111;&#x6d;&#93;&#40;&#41;">&#x5b;&#x6a;&#101;&#x2e;&#x2e;&#x2e;&#x40;&#108;&#105;&#x76;&#x65;&#46;&#x63;&#111;&#x6d;&#93;&#40;&#41;</a>
&gt;</p>
<blockquote>
<p>哈哈，广告好，扩展视野，那我继续做广告了……</p>
<p>微软其实很早就在搞Microsoft Accelerator项目，旨在利用DirectX进行计算，.NET项目。
<a href="http://research.microsoft.com/en-us/projects/Accelerator/" target="_blank"><a href="http://research.microsoft.com/en-us/projects/Accelerator/">http://research.microsoft.com/en-us/projects/Accelerator/</a></a></p>
<p>然后F/#这边由于语言的支持良好，可以设计出丰富的表达式、DSL等Modeling
Language，再由框架进行自动并行，解决问题可以很容易（已经2.0了）。</p>
<p>这篇文章是个简单介绍：<a href="http://strangelights.com/blog/archive/2008/09/21/1628.aspx" target="_blank"><a href="http://strangelights.com/blog/archive/2008/09/21/1628.aspx">http://strangelights.com/blog/archive/2008/09/21/1628.aspx</a></a></p>
<p>Microsoft Solver Foundation
<a href="http://code.msdn.microsoft.com/solverfoundation" target="_blank"><a href="http://code.msdn.microsoft.com/solverfoundation">http://code.msdn.microsoft.com/solverfoundation</a></a></p>
<p>F/# Optimization Modeling Language Utilizing Microsoft Solver Foundation
<a href="http://code.msdn.microsoft.com/solverfoundationfs1" target="_blank"><a href="http://code.msdn.microsoft.com/solverfoundationfs1">http://code.msdn.microsoft.com/solverfoundationfs1</a></a></p>
<p>现在就等OpenCL如果有标准出来，肯定立马可以跟上个类库，哦耶。</p>
<p>Jeffrey Zhao
Blog: <a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter: <a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a>
From: Tinyfool
Sent: Monday, March 22, 2010 9:20 AM
To: <a href="">pon...@googlegroups.com</a>
Subject: Re: [TL] {技术}{多线程}实施并行编程的五大障碍
唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下
Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？
还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#109;&#x61;&#105;&#x6c;&#x74;&#111;&#x3a;&#x5b;&#106;&#101;&#46;&#46;&#46;&#64;&#108;&#105;&#118;&#x65;&#46;&#x63;&#111;&#109;&#x5d;&#x28;&#41;">&#x5b;&#106;&#101;&#46;&#46;&#46;&#64;&#108;&#105;&#118;&#x65;&#46;&#x63;&#111;&#109;&#x5d;&#x28;&#41;</a>
&gt;</p>
<blockquote>
<p>我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是“抽象”这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上……我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog: <a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter: <a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a>
From: Guancheng Chen
Sent: Monday, March 22, 2010 7:37 AM
To: TopLanguage
Subject: [TL] {技术}{多线程}实施并行编程的五大障碍
近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问“什么是实施并行编程的最大障
碍”时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/" target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/</a></a>
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是“专家”们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了“编译指导”、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说“在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶……你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的”，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：“你觉得并行编程容易么？”，十有八九会说“我觉得很难”。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点“教育”有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。</p>
</li>
</ol>
<p>To unsubscribe from this group, send email to
pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to
pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>--
Tinyfool的开发日记 <a href="http://www.tinydust.net/dev/" target="_blank"><a href="http://www.tinydust.net/dev/">http://www.tinydust.net/dev/</a></a>
代码中国网 <a href="http://www.codechina.org/" target="_blank"><a href="http://www.codechina.org">http://www.codechina.org</a></a>
myTwitter: <a href="http://twitter.com/tinyfool" target="_blank"><a href="http://twitter.com/tinyfool">http://twitter.com/tinyfool</a></a></p>
<p>To unsubscribe from this group, send email to
pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to
pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>--
Tinyfool的开发日记 <a href="http://www.tinydust.net/dev/" target="_blank"><a href="http://www.tinydust.net/dev/">http://www.tinydust.net/dev/</a></a>
代码中国网 <a href="http://www.codechina.org/" target="_blank"><a href="http://www.codechina.org">http://www.codechina.org</a></a>
myTwitter: <a href="http://twitter.com/tinyfool" target="_blank"><a href="http://twitter.com/tinyfool">http://twitter.com/tinyfool</a></a></p>
<p>To unsubscribe from this group, send email to
pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to
pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>--
Milo Yip</p>
<p>Twitter @miloyip
<a href="http://www.cnblogs.com/miloyip/" target="_blank"><a href="http://www.cnblogs.com/miloyip/">http://www.cnblogs.com/miloyip/</a></a>
<a href="http://miloyip.seezone.net/" target="_blank"><a href="http://miloyip.seezone.net/">http://miloyip.seezone.net/</a></a></p>
</blockquote>
<p>--
Milo Yip</p>
<p>Twitter @miloyip
<a href="http://www.cnblogs.com/miloyip/" target="_blank"><a href="http://www.cnblogs.com/miloyip/">http://www.cnblogs.com/miloyip/</a></a>
<a href="http://miloyip.seezone.net/" target="_blank"><a href="http://miloyip.seezone.net/">http://miloyip.seezone.net/</a></a>
<a href="">显示删减掉的内容</a></p>
<p><img src="" alt=""> archerzz <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>工具的确是个问题，没有好的工具，很难快速推广。
2010/3/22 Changsheng Jiang <a href="&#109;&#97;&#105;&#108;&#116;&#x6f;&#58;&#x5b;&#x6a;&#x69;&#x61;&#110;&#103;&#46;&#x2e;&#x2e;&#x40;&#103;&#109;&#97;&#x69;&#x6c;&#46;&#99;&#x6f;&#109;&#93;&#40;&#x29;">&#x5b;&#x6a;&#x69;&#x61;&#110;&#103;&#46;&#x2e;&#x2e;&#x40;&#103;&#109;&#97;&#x69;&#x6c;&#46;&#99;&#x6f;&#109;&#93;&#40;&#x29;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>个人觉得最大障碍在工具上.</p>
<p>并行学术上研究得不少, 主要在算法和模型上. 工程上的工具, 多是自串行程序来设计的, 弄得复杂不堪. 并行需要语言和库两级支持, Pthreads 和 MPI 仅从库上入手, 让程序员处理各种重复且复杂的分发, 并发锁等. OpenMP好一些, 可惜目前只支持线程并行.
用 ErLang 等将并行设计在语言里的来做并行会容易得多, 得易于面向消息传递的隔离模型, 程序稳定易写. 模型和语言的性能是一个问题, 主要的问题还在用的人和实际并行项目不多.</p>
<p>调试工具就更少了. 有少数商业化的工具.
当然, 我是将可维护性归结为语言工具太差.</p>
<pre><code>                                                 Changsheng Jiang
</code></pre><p>2010/3/22 Guancheng Chen <a href="&#x6d;&#97;&#x69;&#x6c;&#116;&#x6f;&#58;&#91;&#x63;&#x68;&#101;&#110;&#103;&#x75;&#x2e;&#x2e;&#46;&#64;&#103;&#109;&#x61;&#105;&#108;&#46;&#99;&#x6f;&#109;&#93;&#x28;&#41;">&#91;&#x63;&#x68;&#101;&#110;&#103;&#x75;&#x2e;&#x2e;&#46;&#64;&#103;&#109;&#x61;&#105;&#108;&#46;&#99;&#x6f;&#109;&#93;&#x28;&#41;</a></p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问“什么是实施并行编程的最大障
碍”时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。
( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看
<a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/" target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/</a></a>
)</p>
<ol>
<li>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</li>
<li>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是“专家”们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了“编译指导”、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。
可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说“在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶……你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的”，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：“你觉得并行编程容易么？”，十有八九会说“我觉得很难”。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</li>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？
(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx
总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点“教育”有很大关系了。</li>
<li>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</li>
<li>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> 陨落雕 <img src="" alt=""></li>
</ol>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>我也想用Fermi来解一个和ray tracer类似的问题，话说NV招了好多搞ray tracer和hpc的大牛。</p>
<p>On Mar 21, 10:20 pm, Milo Yip <a href="&#x6d;&#x61;&#105;&#x6c;&#116;&#x6f;&#x3a;&#x5b;&#109;&#x69;&#108;&#x6f;&#46;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#105;&#108;&#46;&#99;&#x6f;&#x6d;&#93;&#40;&#41;">&#x5b;&#109;&#x69;&#108;&#x6f;&#46;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#105;&#108;&#46;&#99;&#x6f;&#x6d;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>我在等NVidia的Fermi和Nexus，想試做全域照明。
但怕買了Fermi後，機器也只是用來做做翻譯......</p>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>在 2010年3月22日上午9:51，Jeffrey Zhao <a href="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#111;&#x3a;&#91;&#x6a;&#x65;&#46;&#46;&#46;&#x40;&#108;&#x69;&#x76;&#x65;&#x2e;&#x63;&#x6f;&#109;&#93;&#x28;&#41;">&#91;&#x6a;&#x65;&#46;&#46;&#46;&#x40;&#108;&#x69;&#x76;&#x65;&#x2e;&#x63;&#x6f;&#109;&#93;&#x28;&#41;</a> 寫道：</p>
<blockquote>
<p>是嘛，我记得是提交了标准还在审核。</p>
<p>好吧，我去查了一下果然在08年12月1.0 Stable release了。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a>
From: Tinyfool
Sent: Monday, March 22, 2010 9:46 AM
To: <a href="">pon...@googlegroups.com</a>
Subject: Re: [TL] {技术}{多线程}实施并行编程的五大障碍
OpenCL早就出来标准了，而且在做各个平台的实现...
视野啊...</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#x6d;&#97;&#105;&#x6c;&#116;&#x6f;&#x3a;&#91;&#x6a;&#x65;&#46;&#x2e;&#46;&#x40;&#108;&#x69;&#118;&#101;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#x29;">&#91;&#x6a;&#x65;&#46;&#x2e;&#46;&#x40;&#108;&#x69;&#118;&#101;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#x29;</a></p>
<blockquote>
<p>哈哈，广告好，扩展视野，那我继续做广告了......</p>
</blockquote>
</blockquote>
</blockquote>
<p>&gt;</p>
<blockquote>
<blockquote>
<blockquote>
<p>微软其实很早就在搞Microsoft Accelerator项目，旨在利用DirectX进行计算，.NET项目。
<a href="http://research.microsoft.com/en-us/projects/Accelerator/" target="_blank"><a href="http://research.microsoft.com/en-us/projects/Accelerator/">http://research.microsoft.com/en-us/projects/Accelerator/</a></a></p>
<p>然后F/#这边由于语言的支持良好，可以设计出丰富的表达式、DSL等Modeling
Language，再由框架进行自动并行，解决问题可以很容易（已经2.0了）。</p>
<p>这篇文章是个简单介绍：<a href="http://strangelights.com/blog/archive/2008/09/21/1628.aspx" target="_blank"><a href="http://strangelights.com/blog/archive/2008/09/21/1628.aspx">http://strangelights.com/blog/archive/2008/09/21/1628.aspx</a></a></p>
<p>Microsoft Solver Foundation
<a href="http://code.msdn.microsoft.com/solverfoundation" target="_blank"><a href="http://code.msdn.microsoft.com/solverfoundation">http://code.msdn.microsoft.com/solverfoundation</a></a></p>
<p>F/# Optimization Modeling Language Utilizing Microsoft Solver Foundation
<a href="http://code.msdn.microsoft.com/solverfoundationfs1" target="_blank"><a href="http://code.msdn.microsoft.com/solverfoundationfs1">http://code.msdn.microsoft.com/solverfoundationfs1</a></a></p>
<p>现在就等OpenCL如果有标准出来，肯定立马可以跟上个类库，哦耶。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a>
From: Tinyfool
Sent: Monday, March 22, 2010 9:20 AM
To: <a href="">pon...@googlegroups.com</a>
Subject: Re: [TL] {技术}{多线程}实施并行编程的五大障碍
唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下
Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？
还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#111;&#x3a;&#x5b;&#x6a;&#101;&#x2e;&#x2e;&#x2e;&#x40;&#108;&#x69;&#118;&#101;&#46;&#99;&#x6f;&#109;&#x5d;&#40;&#x29;">&#x5b;&#x6a;&#101;&#x2e;&#x2e;&#x2e;&#x40;&#108;&#x69;&#118;&#101;&#46;&#99;&#x6f;&#109;&#x5d;&#40;&#x29;</a></p>
<blockquote>
<p>我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>&gt;</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a>
From: Guancheng Chen
Sent: Monday, March 22, 2010 7:37 AM
To: TopLanguage
Subject: [TL] {技术}{多线程}实施并行编程的五大障碍
近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..</p>
<p>)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。</p>
<p>尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这</li>
</ol>
</blockquote>
</blockquote>
</blockquote>
<p>...</p>
<p>read more &gt;&gt;
<a href="">显示删减掉的内容</a></p>
</blockquote>
<p><img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>微软好像已经推出了跟OpenCL类似的Direct Compute，也能搞GPU CPU混合计算</p>
<p>On 3月22日, 上午2时42分, &quot;Jeffrey Zhao&quot; <a href="&#x6d;&#97;&#x69;&#108;&#116;&#111;&#58;&#x5b;&#x6a;&#x65;&#46;&#x2e;&#x2e;&#64;&#x6c;&#105;&#x76;&#x65;&#46;&#99;&#111;&#109;&#93;&#x28;&#41;">&#x5b;&#x6a;&#x65;&#46;&#x2e;&#x2e;&#64;&#x6c;&#105;&#x76;&#x65;&#46;&#99;&#111;&#109;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>哈哈，广告好，扩展视野，那我继续做广告了......</p>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>微软其实很早就在搞Microsoft Accelerator项目，旨在利用DirectX进行计算，.NET项目。<a href="http://research.microsoft.com/en-us/projects/Accelerator/" target="_blank"><a href="http://research.microsoft.com/en-us/projects/Accelerator/">http://research.microsoft.com/en-us/projects/Accelerator/</a></a></p>
<p>然后F/#这边由于语言的支持良好，可以设计出丰富的表达式、DSL等Modeling Language，再由框架进行自动并行，解决问题可以很容易（已经2.0了）。</p>
<p>这篇文章是个简单介绍：<a href="http://strangelights.com/blog/archive/2008/09/21/1628.aspx" target="_blank"><a href="http://strangelights.com/blog/archive/2008/09/21/1628.aspx">http://strangelights.com/blog/archive/2008/09/21/1628.aspx</a></a></p>
<p>Microsoft Solver Foundation<a href="http://[code.msdn.microsoft.com/solverfoundation](http://code.msdn.microsoft.com/solverfoundation" target="_blank">http://[code.msdn.microsoft.com/solverfoundation](http://code.msdn.microsoft.com/solverfoundation</a>)</p>
<p>F/# Optimization Modeling Language Utilizing Microsoft Solver Foundation<a href="http://[code.msdn.microsoft.com/solverfoundationfs1](http://code.msdn.microsoft.com/solverfoundationfs1" target="_blank">http://[code.msdn.microsoft.com/solverfoundationfs1](http://code.msdn.microsoft.com/solverfoundationfs1</a>)</p>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>现在就等OpenCL如果有标准出来，肯定立马可以跟上个类库，哦耶。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p>From: Tinyfool
Sent: Monday, March 22, 2010 9:20 AM
To: <a href="">pon...@googlegroups.com</a>
Subject: Re: [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#x6d;&#97;&#105;&#108;&#116;&#x6f;&#58;&#91;&#x6a;&#x65;&#46;&#x2e;&#x2e;&#x40;&#108;&#105;&#x76;&#101;&#46;&#x63;&#111;&#x6d;&#93;&#40;&#x29;">&#91;&#x6a;&#x65;&#46;&#x2e;&#x2e;&#x40;&#108;&#105;&#x76;&#101;&#46;&#x63;&#111;&#x6d;&#93;&#40;&#x29;</a></p>
<p>  我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>  其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>  例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>  至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>  例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>  Jeffrey Zhao
  Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
  Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p>  From: Guancheng Chen
  Sent: Monday, March 22, 2010 7:37 AM
  To: TopLanguage
  Subject: [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>  近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
  碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
  (fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
  Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
  的看法。</p>
<p>  ( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看
 <a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..</p>
<p>  )</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。</p>
<p>尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
</li>
<li><p>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</p>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
</li>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可...</p>
</li>
</ol>
<p>阅读更多 &gt;&gt;
<a href="">显示删减掉的内容</a>
<img src="" alt=""> 郑伟 <img src="" alt=""></p>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>我觉得 想要并行开发 必须绕开c/c++
2010/3/22 Guancheng Chen <a href="&#109;&#x61;&#105;&#108;&#116;&#x6f;&#58;&#91;&#99;&#104;&#101;&#x6e;&#x67;&#x75;&#x2e;&#x2e;&#x2e;&#64;&#103;&#x6d;&#97;&#105;&#108;&#46;&#x63;&#x6f;&#109;&#x5d;&#x28;&#x29;">&#91;&#99;&#104;&#101;&#x6e;&#x67;&#x75;&#x2e;&#x2e;&#x2e;&#64;&#103;&#x6d;&#97;&#105;&#108;&#46;&#x63;&#x6f;&#109;&#x5d;&#x28;&#x29;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>微软好像已经推出了跟OpenCL类似的Direct Compute，也能搞GPU CPU混合计算
On 3月22日, 上午2时42分, &quot;Jeffrey Zhao&quot; <a href="&#x6d;&#x61;&#105;&#x6c;&#x74;&#x6f;&#58;&#91;&#106;&#x65;&#46;&#x2e;&#46;&#x40;&#108;&#x69;&#x76;&#x65;&#46;&#x63;&#111;&#x6d;&#x5d;&#40;&#41;">&#91;&#106;&#x65;&#46;&#x2e;&#46;&#x40;&#108;&#x69;&#x76;&#x65;&#46;&#x63;&#111;&#x6d;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>哈哈，广告好，扩展视野，那我继续做广告了......</p>
<p>微软其实很早就在搞Microsoft Accelerator项目，旨在利用DirectX进行计算，.NET项目。<a href="http://research.microsoft.com/en-us/projects/Accelerator/" target="_blank"><a href="http://research.microsoft.com/en-us/projects/Accelerator/">http://research.microsoft.com/en-us/projects/Accelerator/</a></a></p>
<p>然后F/#这边由于语言的支持良好，可以设计出丰富的表达式、DSL等Modeling Language，再由框架进行自动并行，解决问题可以很容易（已经2.0了）。</p>
<p>这篇文章是个简单介绍：<a href="http://strangelights.com/blog/archive/2008/09/21/1628.aspx" target="_blank"><a href="http://strangelights.com/blog/archive/2008/09/21/1628.aspx">http://strangelights.com/blog/archive/2008/09/21/1628.aspx</a></a></p>
<p>Microsoft Solver Foundation<a href="http://[code.msdn.microsoft.com/solverfoundation](http://code.msdn.microsoft.com/solverfoundation" target="_blank">http://[code.msdn.microsoft.com/solverfoundation](http://code.msdn.microsoft.com/solverfoundation</a>)</p>
<p>F/# Optimization Modeling Language Utilizing Microsoft Solver Foundation<a href="http://[code.msdn.microsoft.com/solverfoundationfs1](http://code.msdn.microsoft.com/solverfoundationfs1" target="_blank">http://[code.msdn.microsoft.com/solverfoundationfs1](http://code.msdn.microsoft.com/solverfoundationfs1</a>)</p>
<p>现在就等OpenCL如果有标准出来，肯定立马可以跟上个类库，哦耶。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p>From: Tinyfool
Sent: Monday, March 22, 2010 9:20 AM
To: <a href="">pon...@googlegroups.com</a>
Subject: Re: [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#109;&#x61;&#105;&#x6c;&#116;&#111;&#58;&#91;&#106;&#x65;&#x2e;&#46;&#x2e;&#64;&#108;&#105;&#118;&#101;&#46;&#99;&#111;&#109;&#x5d;&#x28;&#41;">&#91;&#106;&#x65;&#x2e;&#46;&#x2e;&#64;&#108;&#105;&#118;&#101;&#46;&#99;&#111;&#109;&#x5d;&#x28;&#41;</a></p>
<p>  我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>  其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>  例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>  至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>  例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>  Jeffrey Zhao
  Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
  Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p>  From: Guancheng Chen
  Sent: Monday, March 22, 2010 7:37 AM
  To: TopLanguage
  Subject: [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>  近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
  碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
  (fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
  Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
  的看法。</p>
<p>  ( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看
 <a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
  )</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
</li>
<li><p>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</p>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
</li>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维&gt;   护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可...</p>
</li>
</ol>
<p>阅读更多 &gt;&gt;</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a></p>
<p><img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>很有意思的事情是我上次问过一个负责定制OpenCL的哥们，&quot;从商业角度上讲，苹果为什么要自己搞一个新标准？&quot; 他就说那个时候苹果意识到未来这种
通用并行计算平台的重要性，而为了保证最大的商业利益就选择自己重新搞一个新标准而不是跟当时已有CUDA的Nvidia合作，结果现在NV也开始支持
OpenCL，但是他们最新的一本教材里说到&quot;根据我们的经验，学习OpenCL最好的办法是先学CUDA&quot;</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>On 3月22日, 上午6时10分, 陨落雕 <a href="&#x6d;&#x61;&#105;&#x6c;&#116;&#111;&#58;&#x5b;&#103;&#101;&#x6f;&#x2e;&#46;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#97;&#x69;&#x6c;&#46;&#99;&#x6f;&#x6d;&#93;&#x28;&#41;">&#x5b;&#103;&#101;&#x6f;&#x2e;&#46;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#97;&#x69;&#x6c;&#46;&#99;&#x6f;&#x6d;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>我也想用Fermi来解一个和ray tracer类似的问题，话说NV招了好多搞ray tracer和hpc的大牛。</p>
<p>On Mar 21, 10:20 pm, Milo Yip <a href="&#109;&#97;&#x69;&#x6c;&#116;&#111;&#x3a;&#91;&#109;&#x69;&#x6c;&#x6f;&#x2e;&#46;&#x2e;&#64;&#103;&#109;&#x61;&#x69;&#108;&#46;&#99;&#x6f;&#109;&#93;&#x28;&#41;">&#91;&#109;&#x69;&#x6c;&#x6f;&#x2e;&#46;&#x2e;&#64;&#103;&#109;&#x61;&#x69;&#108;&#46;&#99;&#x6f;&#109;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>我在等NVidia的Fermi和Nexus，想試做全域照明。
但怕買了Fermi後，機器也只是用來做做翻譯......</p>
<p>在 2010年3月22日上午9:51，Jeffrey Zhao <a href="&#x6d;&#x61;&#105;&#x6c;&#x74;&#111;&#x3a;&#x5b;&#x6a;&#x65;&#x2e;&#46;&#46;&#x40;&#x6c;&#105;&#x76;&#x65;&#x2e;&#99;&#111;&#109;&#x5d;&#40;&#x29;">&#x5b;&#x6a;&#x65;&#x2e;&#46;&#46;&#x40;&#x6c;&#105;&#x76;&#x65;&#x2e;&#99;&#111;&#109;&#x5d;&#40;&#x29;</a> 寫道：</p>
<blockquote>
<p>是嘛，我记得是提交了标准还在审核。</p>
<p>好吧，我去查了一下果然在08年12月1.0 Stable release了。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a>
From: Tinyfool
Sent: Monday, March 22, 2010 9:46 AM
To: <a href="">pon...@googlegroups.com</a>
Subject: Re: [TL] {技术}{多线程}实施并行编程的五大障碍
OpenCL早就出来标准了，而且在做各个平台的实现...
视野啊...</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#x6d;&#97;&#105;&#x6c;&#x74;&#111;&#58;&#x5b;&#x6a;&#x65;&#46;&#x2e;&#46;&#64;&#x6c;&#105;&#x76;&#x65;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#x28;&#41;">&#x5b;&#x6a;&#x65;&#46;&#x2e;&#46;&#64;&#x6c;&#105;&#x76;&#x65;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#x28;&#41;</a></p>
<blockquote>
<p>哈哈，广告好，扩展视野，那我继续做广告了......</p>
<p>微软其实很早就在搞Microsoft Accelerator项目，旨在利用DirectX进行计算，.NET项目。
<a href="http://research.microsoft.com/en-us/projects/Accelerator/" target="_blank"><a href="http://research.microsoft.com/en-us/projects/Accelerator/">http://research.microsoft.com/en-us/projects/Accelerator/</a></a></p>
<p>然后F/#这边由于语言的支持良好，可以设计出丰富的表达式、DSL等Modeling
Language，再由框架进行自动并行，解决问题可以很容易（已经2.0了）。</p>
<p>这篇文章是个简单介绍：<a href="http://strangelights.com/blog/archive/2008/09/21/1628.aspx" target="_blank"><a href="http://strangelights.com/blog/archive/2008/09/21/1628.aspx">http://strangelights.com/blog/archive/2008/09/21/1628.aspx</a></a></p>
<p>Microsoft Solver Foundation
<a href="http://code.msdn.microsoft.com/solverfoundation" target="_blank"><a href="http://code.msdn.microsoft.com/solverfoundation">http://code.msdn.microsoft.com/solverfoundation</a></a></p>
<p>F/# Optimization Modeling Language Utilizing Microsoft Solver Foundation
<a href="http://code.msdn.microsoft.com/solverfoundationfs1" target="_blank"><a href="http://code.msdn.microsoft.com/solverfoundationfs1">http://code.msdn.microsoft.com/solverfoundationfs1</a></a></p>
<p>现在就等OpenCL如果有标准出来，肯定立马可以跟上个类库，哦耶。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a>
From: Tinyfool
Sent: Monday, March 22, 2010 9:20 AM
To: <a href="">pon...@googlegroups.com</a>
Subject: Re: [TL] {技术}{多线程}实施并行编程的五大障碍
唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下
Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？
还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#109;&#x61;&#x69;&#x6c;&#116;&#111;&#x3a;&#91;&#x6a;&#101;&#46;&#46;&#x2e;&#64;&#108;&#x69;&#118;&#101;&#46;&#99;&#x6f;&#x6d;&#93;&#x28;&#x29;">&#91;&#x6a;&#101;&#46;&#46;&#x2e;&#64;&#108;&#x69;&#118;&#101;&#46;&#99;&#x6f;&#x6d;&#93;&#x28;&#x29;</a></p>
<blockquote>
<p>我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a>
From: Guancheng Chen
Sent: Monday, March 22, 2010 7:37 AM
To: TopLanguage
Subject: [TL] {技术}{多线程}实施并行编程的五大障碍
近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li>对众核的恐惧...</li>
</ol>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>阅读更多 &gt;&gt;
<a href="">显示删减掉的内容</a>
<img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>不知道您觉得现有的工具哪些个最趁手呢？</p>
<p>On 3月22日, 上午3时19分, Changsheng Jiang <a href="&#x6d;&#x61;&#x69;&#108;&#116;&#x6f;&#x3a;&#91;&#106;&#x69;&#97;&#110;&#103;&#122;&#x75;&#x6f;&#x2e;&#x2e;&#x2e;&#64;&#103;&#109;&#97;&#105;&#108;&#x2e;&#x63;&#111;&#x6d;&#93;&#x28;&#41;">&#91;&#106;&#x69;&#97;&#110;&#103;&#122;&#x75;&#x6f;&#x2e;&#x2e;&#x2e;&#64;&#103;&#109;&#97;&#105;&#108;&#x2e;&#x63;&#111;&#x6d;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>个人觉得最大障碍在工具上.</p>
<p>并行学术上研究得不少, 主要在算法和模型上. 工程上的工具, 多是自串行程序来设计的, 弄得复杂不堪. 并行需要语言和库两级支持, Pthreads 和
MPI 仅从库上入手, 让程序员处理各种重复且复杂的分发, 并发锁等. OpenMP好一些, 可惜目前只支持线程并行.</p>
<p>用 ErLang 等将并行设计在语言里的来做并行会容易得多, 得易于面向消息传递的隔离模型, 程序稳定易写. 模型和语言的性能是一个问题,
主要的问题还在用的人和实际并行项目不多.</p>
<p>调试工具就更少了. 有少数商业化的工具.</p>
<p>当然, 我是将可维护性归结为语言工具太差.</p>
<pre><code>                                                 Changsheng Jiang
</code></pre><p>2010/3/22 Guancheng Chen <a href="&#x6d;&#97;&#x69;&#108;&#116;&#111;&#58;&#x5b;&#x63;&#104;&#101;&#110;&#103;&#x75;&#97;&#x6e;&#99;&#104;&#46;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#97;&#x69;&#108;&#46;&#99;&#x6f;&#x6d;&#93;&#40;&#x29;">&#x5b;&#x63;&#104;&#101;&#110;&#103;&#x75;&#97;&#x6e;&#99;&#104;&#46;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#97;&#x69;&#108;&#46;&#99;&#x6f;&#x6d;&#93;&#40;&#x29;</a></p>
</blockquote>
<p>&gt;
&gt;
&gt;</p>
<blockquote>
<blockquote>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..</p>
<p>)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。</p>
</blockquote>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<blockquote>
<blockquote>
<p>尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。</p>
</li>
</ol>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
<a href="">显示删减掉的内容</a></p>
</blockquote>
</blockquote>
<p><img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>哈哈 是想绕开C++那些本来就复杂的要死的feature么？是不是如果有一门新的易用的编程语言会比诸如给C++添加thread特性的方法要
好？</p>
<p>On 3月22日, 上午6时48分, Kula <a href="&#x6d;&#x61;&#105;&#108;&#x74;&#111;&#x3a;&#x5b;&#107;&#117;&#x6c;&#97;&#x73;&#46;&#46;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#x29;">&#x5b;&#107;&#117;&#x6c;&#97;&#x73;&#46;&#46;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>我觉得 想要并行开发 必须绕开c/c++</p>
<p>2010/3/22 Guancheng Chen <a href="&#x6d;&#97;&#x69;&#108;&#x74;&#x6f;&#58;&#91;&#99;&#x68;&#x65;&#110;&#x67;&#117;&#x61;&#x6e;&#99;&#x68;&#x2e;&#x2e;&#46;&#x40;&#x67;&#x6d;&#97;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#x28;&#x29;">&#91;&#99;&#x68;&#x65;&#110;&#x67;&#117;&#x61;&#x6e;&#99;&#x68;&#x2e;&#x2e;&#46;&#x40;&#x67;&#x6d;&#97;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#x28;&#x29;</a></p>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>&gt;
&gt;
&gt;</p>
<blockquote>
<blockquote>
<p>微软好像已经推出了跟OpenCL类似的Direct Compute，也能搞GPU CPU混合计算</p>
<p>On 3月22日, 上午2时42分, &quot;Jeffrey Zhao&quot; <a href="&#109;&#x61;&#105;&#x6c;&#x74;&#111;&#x3a;&#91;&#x6a;&#x65;&#46;&#x2e;&#46;&#64;&#108;&#x69;&#x76;&#101;&#46;&#x63;&#x6f;&#x6d;&#93;&#40;&#41;">&#91;&#x6a;&#x65;&#46;&#x2e;&#46;&#64;&#108;&#x69;&#x76;&#101;&#46;&#x63;&#x6f;&#x6d;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>哈哈，广告好，扩展视野，那我继续做广告了......</p>
<p>微软其实很早就在搞Microsoft Accelerator项目，旨在利用DirectX进行计算，.NET项目。
<a href="http://research.microsoft.com/en-us/projects/Accelerator/" target="_blank"><a href="http://research.microsoft.com/en-us/projects/Accelerator/">http://research.microsoft.com/en-us/projects/Accelerator/</a></a></p>
<p>然后F/#这边由于语言的支持良好，可以设计出丰富的表达式、DSL等Modeling
Language，再由框架进行自动并行，解决问题可以很容易（已经2.0了）。</p>
<p>这篇文章是个简单介绍：<a href="http://strangelights.com/blog/archive/2008/09/21/1628.aspx" target="_blank"><a href="http://strangelights.com/blog/archive/2008/09/21/1628.aspx">http://strangelights.com/blog/archive/2008/09/21/1628.aspx</a></a></p>
<p>Microsoft Solver Foundationhttp://
<a href="http://code.msdn.microsoft.com/solverfoundation" target="_blank">code.msdn.microsoft.com/solverfoundation</a></p>
<p>F/# Optimization Modeling Language Utilizing Microsoft Solver
Foundation<a href="http://[code.msdn.microsoft.com/solverfoundationfs1](http://code.msdn.microsoft.com/solverfoundationfs1" target="_blank">http://[code.msdn.microsoft.com/solverfoundationfs1](http://code.msdn.microsoft.com/solverfoundationfs1</a>)</p>
<p>现在就等OpenCL如果有标准出来，肯定立马可以跟上个类库，哦耶。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p>From: Tinyfool
Sent: Monday, March 22, 2010 9:20 AM
To: <a href="">pon...@googlegroups.com</a>
Subject: Re: [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#x6d;&#x61;&#x69;&#108;&#116;&#111;&#58;&#x5b;&#x6a;&#101;&#x2e;&#x2e;&#x2e;&#x40;&#108;&#105;&#118;&#x65;&#46;&#x63;&#x6f;&#x6d;&#93;&#x28;&#41;">&#x5b;&#x6a;&#101;&#x2e;&#x2e;&#x2e;&#x40;&#108;&#105;&#118;&#x65;&#46;&#x63;&#x6f;&#x6d;&#93;&#x28;&#41;</a></p>
<p>  我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>  其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>  例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>  至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>  例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>  Jeffrey Zhao
  Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
  Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p>  From: Guancheng Chen
  Sent: Monday, March 22, 2010 7:37 AM
  To: TopLanguage
  Subject: [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>  近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
  碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
  (fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
  Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
  的看法。</p>
<p>  ( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看
 <a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-" target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a></a>.
..
  )</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线</p>
</li>
</ol>
</blockquote>
<p>程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。</p>
<blockquote>
<p>  尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
  并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
  好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
  和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
  OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
  训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li><p>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</p>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
</li>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false...</p>
</li>
</ol>
</blockquote>
</blockquote>
<p>阅读更多 &gt;&gt;
<a href="">显示删减掉的内容</a>
<img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>On 3月22日, 上午2时20分, Tinyfool <a href="&#109;&#x61;&#105;&#108;&#116;&#111;&#x3a;&#x5b;&#116;&#x69;&#110;&#121;&#102;&#46;&#46;&#46;&#64;&#103;&#109;&#97;&#105;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#x29;">&#x5b;&#116;&#x69;&#110;&#121;&#102;&#46;&#46;&#46;&#64;&#103;&#109;&#97;&#105;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#x6d;&#97;&#105;&#x6c;&#116;&#x6f;&#x3a;&#x5b;&#106;&#101;&#x2e;&#x2e;&#46;&#x40;&#x6c;&#x69;&#x76;&#101;&#x2e;&#x63;&#111;&#109;&#x5d;&#40;&#41;">&#x5b;&#106;&#101;&#x2e;&#x2e;&#46;&#x40;&#x6c;&#x69;&#x76;&#101;&#x2e;&#x63;&#111;&#109;&#x5d;&#40;&#41;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
</blockquote>
</blockquote>
<p>&gt;</p>
<blockquote>
<blockquote>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#109;&#97;&#x69;&#108;&#x74;&#x6f;&#58;&#x5b;&#99;&#x68;&#101;&#110;&#x67;&#x75;&#97;&#110;&#99;&#x68;&#46;&#46;&#x2e;&#x40;&#x67;&#109;&#x61;&#105;&#x6c;&#46;&#x63;&#111;&#x6d;&#x5d;&#x28;&#41;">&#x5b;&#99;&#x68;&#101;&#110;&#x67;&#x75;&#97;&#110;&#99;&#x68;&#46;&#46;&#x2e;&#x40;&#x67;&#109;&#x61;&#105;&#x6c;&#46;&#x63;&#111;&#x6d;&#x5d;&#x28;&#41;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#x6d;&#x61;&#x69;&#108;&#116;&#111;&#x3a;&#91;&#x70;&#111;&#x6e;&#46;&#x2e;&#46;&#64;&#103;&#111;&#111;&#103;&#x6c;&#x65;&#x67;&#x72;&#x6f;&#117;&#112;&#x73;&#46;&#99;&#x6f;&#109;&#93;&#x28;&#41;">&#91;&#x70;&#111;&#x6e;&#46;&#x2e;&#46;&#64;&#103;&#111;&#111;&#103;&#x6c;&#x65;&#x67;&#x72;&#x6f;&#117;&#112;&#x73;&#46;&#99;&#x6f;&#109;&#93;&#x28;&#41;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
</blockquote>
</blockquote>
<p>&gt;</p>
<blockquote>
<blockquote>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..</p>
<p>)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。</p>
</blockquote>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<blockquote>
<blockquote>
<p>尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。</p>
</li>
</ol>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>--
Tinyfool的开发日记<a href="http://www.tinydust.net/dev/" target="_blank"><a href="http://www.tinydust.net/dev/">http://www.tinydust.net/dev/</a></a>
代码中国网<a href="http://www.codechina.org/" target="_blank"><a href="http://www.codechina.org">http://www.codechina.org</a></a>
myTwitter:<a href="http://twitter.com/tinyfool" target="_blank"><a href="http://twitter.com/tinyfool">http://twitter.com/tinyfool</a></a>
<a href="">显示删减掉的内容</a></p>
</blockquote>
<p><img src="" alt=""> changsheng <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>说来惭愧, 接触并行时间不长, 没什么实际经验, 只写过几个并行程序.</p>
<p>感觉 MPI + OpenMP 倒算好用. 简单的单机程序, 用OpenMP并行, 添加几个编译指令就可以. 复杂点的, 用MPI, 也能忍, 只是需要重新设计一下程序和算法.
除了简单的打印, 跟踪一个进程, 不知道怎么调试并行程序. 没有专用平台如NUMA等的编程经验.</p>
<pre><code>                                                 Changsheng Jiang
</code></pre><p>2010/3/22 Guancheng Chen <a href="&#x6d;&#97;&#105;&#108;&#116;&#x6f;&#x3a;&#x5b;&#x63;&#104;&#101;&#110;&#103;&#117;&#46;&#x2e;&#x2e;&#64;&#x67;&#109;&#x61;&#105;&#108;&#46;&#99;&#x6f;&#109;&#93;&#x28;&#41;">&#x5b;&#x63;&#104;&#101;&#110;&#103;&#117;&#46;&#x2e;&#x2e;&#64;&#x67;&#109;&#x61;&#105;&#108;&#46;&#99;&#x6f;&#109;&#93;&#x28;&#41;</a>
不知道您觉得现有的工具哪些个最趁手呢？
On 3月22日, 上午3时19分, Changsheng Jiang <a href="&#x6d;&#x61;&#x69;&#108;&#x74;&#111;&#58;&#x5b;&#x6a;&#x69;&#x61;&#110;&#x67;&#x7a;&#x75;&#111;&#x2e;&#46;&#46;&#64;&#103;&#109;&#x61;&#x69;&#x6c;&#46;&#99;&#111;&#109;&#93;&#x28;&#41;">&#x5b;&#x6a;&#x69;&#x61;&#110;&#x67;&#x7a;&#x75;&#111;&#x2e;&#46;&#46;&#64;&#103;&#109;&#x61;&#x69;&#x6c;&#46;&#99;&#111;&#109;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>个人觉得最大障碍在工具上.</p>
<p>并行学术上研究得不少, 主要在算法和模型上. 工程上的工具, 多是自串行程序来设计的, 弄得复杂不堪. 并行需要语言和库两级支持, Pthreads 和
MPI 仅从库上入手, 让程序员处理各种重复且复杂的分发, 并发锁等. OpenMP好一些, 可惜目前只支持线程并行.</p>
<p>用 ErLang 等将并行设计在语言里的来做并行会容易得多, 得易于面向消息传递的隔离模型, 程序稳定易写. 模型和语言的性能是一个问题,
主要的问题还在用的人和实际并行项目不多.</p>
<p>调试工具就更少了. 有少数商业化的工具.</p>
<p>当然, 我是将可维护性归结为语言工具太差.</p>
<pre><code>                                                 Changsheng Jiang
</code></pre><p>2010/3/22 Guancheng Chen <a href="&#109;&#x61;&#105;&#108;&#x74;&#111;&#x3a;&#91;&#99;&#104;&#x65;&#110;&#103;&#x75;&#x61;&#110;&#x63;&#x68;&#46;&#46;&#x2e;&#64;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#46;&#99;&#111;&#109;&#93;&#x28;&#41;">&#91;&#99;&#104;&#x65;&#110;&#103;&#x75;&#x61;&#110;&#x63;&#x68;&#46;&#46;&#x2e;&#64;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#46;&#99;&#111;&#109;&#93;&#x28;&#41;</a></p>
<blockquote>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。</p>
</li>
</ol>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> doyle <img src="" alt=""></p>
</blockquote>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>2010/3/22 Guancheng Chen <a href="&#109;&#x61;&#x69;&#108;&#116;&#111;&#x3a;&#91;&#99;&#x68;&#101;&#x6e;&#103;&#x75;&#46;&#46;&#46;&#64;&#x67;&#x6d;&#97;&#105;&#x6c;&#x2e;&#99;&#x6f;&#109;&#93;&#40;&#x29;">&#91;&#99;&#x68;&#101;&#x6e;&#103;&#x75;&#46;&#46;&#46;&#64;&#x67;&#x6d;&#97;&#105;&#x6c;&#x2e;&#99;&#x6f;&#109;&#93;&#40;&#x29;</a>
我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>我也是被蛊惑了...所以向老婆提申请来着,结果被否掉了...
 On 3月22日, 上午2时20分, Tinyfool <a href="&#x6d;&#97;&#105;&#x6c;&#x74;&#111;&#x3a;&#91;&#116;&#x69;&#110;&#121;&#102;&#46;&#x2e;&#x2e;&#64;&#x67;&#109;&#x61;&#x69;&#108;&#x2e;&#99;&#111;&#x6d;&#x5d;&#x28;&#x29;">&#91;&#116;&#x69;&#110;&#121;&#102;&#46;&#x2e;&#x2e;&#64;&#x67;&#109;&#x61;&#x69;&#108;&#x2e;&#99;&#111;&#x6d;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#x6d;&#97;&#105;&#108;&#x74;&#111;&#x3a;&#x5b;&#x6a;&#101;&#46;&#46;&#46;&#x40;&#x6c;&#x69;&#x76;&#x65;&#46;&#x63;&#111;&#x6d;&#93;&#x28;&#41;">&#x5b;&#x6a;&#101;&#46;&#46;&#46;&#x40;&#x6c;&#x69;&#x76;&#x65;&#46;&#x63;&#111;&#x6d;&#93;&#x28;&#41;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#x6f;&#58;&#x5b;&#x63;&#x68;&#x65;&#110;&#x67;&#117;&#97;&#x6e;&#99;&#x68;&#x2e;&#46;&#x2e;&#x40;&#103;&#x6d;&#97;&#x69;&#108;&#46;&#99;&#111;&#x6d;&#x5d;&#x28;&#x29;">&#x5b;&#x63;&#x68;&#x65;&#110;&#x67;&#117;&#97;&#x6e;&#99;&#x68;&#x2e;&#46;&#x2e;&#x40;&#103;&#x6d;&#97;&#x69;&#108;&#46;&#99;&#111;&#x6d;&#x5d;&#x28;&#x29;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#x6d;&#97;&#x69;&#108;&#x74;&#111;&#58;&#x5b;&#112;&#x6f;&#x6e;&#x2e;&#46;&#x2e;&#64;&#103;&#x6f;&#x6f;&#x67;&#x6c;&#x65;&#x67;&#114;&#111;&#117;&#112;&#x73;&#46;&#99;&#x6f;&#x6d;&#x5d;&#40;&#41;">&#x5b;&#112;&#x6f;&#x6e;&#x2e;&#46;&#x2e;&#64;&#103;&#x6f;&#x6f;&#x67;&#x6c;&#x65;&#x67;&#114;&#111;&#117;&#112;&#x73;&#46;&#99;&#x6f;&#x6d;&#x5d;&#40;&#41;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
</blockquote>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>&gt;</p>
<blockquote>
<blockquote>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。</p>
</li>
</ol>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>--</p>
<p>Tinyfool的开发日记<a href="http://www.tinydust.net/dev/" target="_blank"><a href="http://www.tinydust.net/dev/">http://www.tinydust.net/dev/</a></a>
代码中国网<a href="http://www.codechina.org/" target="_blank"><a href="http://www.codechina.org">http://www.codechina.org</a></a>
myTwitter:<a href="http://twitter.com/tinyfool" target="_blank"><a href="http://twitter.com/tinyfool">http://twitter.com/tinyfool</a></a></p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a></p>
<p><img src="" alt=""> tinyfool <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>热烈支持，哈哈
2010/3/22 Guancheng Chen <a href="&#x6d;&#97;&#105;&#108;&#116;&#x6f;&#x3a;&#91;&#x63;&#104;&#101;&#x6e;&#x67;&#x75;&#46;&#x2e;&#46;&#64;&#x67;&#x6d;&#97;&#105;&#x6c;&#x2e;&#x63;&#111;&#109;&#93;&#40;&#41;">&#91;&#x63;&#104;&#101;&#x6e;&#x67;&#x75;&#46;&#x2e;&#46;&#64;&#x67;&#x6d;&#97;&#105;&#x6c;&#x2e;&#x63;&#111;&#109;&#93;&#40;&#41;</a>
我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>On 3月22日, 上午2时20分, Tinyfool <a href="&#x6d;&#97;&#x69;&#x6c;&#x74;&#111;&#58;&#x5b;&#116;&#x69;&#x6e;&#121;&#x66;&#46;&#46;&#46;&#x40;&#x67;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#99;&#111;&#x6d;&#93;&#40;&#41;">&#x5b;&#116;&#x69;&#x6e;&#121;&#x66;&#46;&#46;&#46;&#x40;&#x67;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#99;&#111;&#x6d;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p><a href="">显示删减掉的内容</a>
<img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>我个人也觉得OpenMP是目前比较好用的并行方式。像您这样设计算法的程序员，是不是基本上也是只对串行算法做优化改进，然后性能瓶颈比较大的部分才
考虑实施并行化？</p>
<p>On 3月22日, 上午7时09分, Changsheng Jiang <a href="&#x6d;&#x61;&#105;&#x6c;&#x74;&#x6f;&#58;&#x5b;&#106;&#105;&#97;&#x6e;&#x67;&#122;&#117;&#111;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#109;&#x61;&#x69;&#x6c;&#46;&#99;&#x6f;&#x6d;&#93;&#40;&#x29;">&#x5b;&#106;&#105;&#97;&#x6e;&#x67;&#122;&#117;&#111;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#109;&#x61;&#x69;&#x6c;&#46;&#99;&#x6f;&#x6d;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>说来惭愧, 接触并行时间不长, 没什么实际经验, 只写过几个并行程序.</p>
<p>感觉 MPI + OpenMP 倒算好用. 简单的单机程序, 用OpenMP并行, 添加几个编译指令就可以. 复杂点的, 用MPI, 也能忍,
只是需要重新设计一下程序和算法.</p>
<p>除了简单的打印, 跟踪一个进程, 不知道怎么调试并行程序. 没有专用平台如NUMA等的编程经验.</p>
<pre><code>                                                 Changsheng Jiang
</code></pre><p>2010/3/22 Guancheng Chen <a href="&#x6d;&#x61;&#105;&#108;&#x74;&#x6f;&#58;&#91;&#x63;&#104;&#101;&#110;&#x67;&#x75;&#x61;&#110;&#x63;&#x68;&#46;&#46;&#x2e;&#64;&#103;&#109;&#x61;&#x69;&#x6c;&#46;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#41;">&#91;&#x63;&#104;&#101;&#110;&#x67;&#x75;&#x61;&#110;&#x63;&#x68;&#46;&#46;&#x2e;&#64;&#103;&#109;&#x61;&#x69;&#x6c;&#46;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#41;</a></p>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>&gt;
&gt;
&gt;</p>
<blockquote>
<blockquote>
<p>不知道您觉得现有的工具哪些个最趁手呢？</p>
<p>On 3月22日, 上午3时19分, Changsheng Jiang <a href="&#109;&#x61;&#x69;&#108;&#x74;&#111;&#x3a;&#x5b;&#x6a;&#x69;&#x61;&#x6e;&#103;&#x7a;&#117;&#111;&#x2e;&#x2e;&#46;&#x40;&#103;&#x6d;&#x61;&#105;&#108;&#x2e;&#x63;&#111;&#109;&#x5d;&#40;&#41;">&#x5b;&#x6a;&#x69;&#x61;&#x6e;&#103;&#x7a;&#117;&#111;&#x2e;&#x2e;&#46;&#x40;&#103;&#x6d;&#x61;&#105;&#108;&#x2e;&#x63;&#111;&#109;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>个人觉得最大障碍在工具上.</p>
<p>并行学术上研究得不少, 主要在算法和模型上. 工程上的工具, 多是自串行程序来设计的, 弄得复杂不堪. 并行需要语言和库两级支持,
Pthreads 和
MPI 仅从库上入手, 让程序员处理各种重复且复杂的分发, 并发锁等. OpenMP好一些, 可惜目前只支持线程并行.</p>
<p>用 ErLang 等将并行设计在语言里的来做并行会容易得多, 得易于面向消息传递的隔离模型, 程序稳定易写. 模型和语言的性能是一个问题,
主要的问题还在用的人和实际并行项目不多.</p>
<p>调试工具就更少了. 有少数商业化的工具.</p>
<p>当然, 我是将可维护性归结为语言工具太差.</p>
<pre><code>                                                 Changsheng Jiang
</code></pre><p>2010/3/22 Guancheng Chen <a href="&#x6d;&#97;&#x69;&#108;&#x74;&#111;&#x3a;&#91;&#x63;&#104;&#x65;&#110;&#103;&#x75;&#97;&#110;&#x63;&#104;&#46;&#46;&#x2e;&#64;&#x67;&#x6d;&#97;&#x69;&#108;&#x2e;&#x63;&#111;&#109;&#x5d;&#40;&#41;">&#91;&#x63;&#104;&#x65;&#110;&#103;&#x75;&#97;&#110;&#x63;&#104;&#46;&#46;&#x2e;&#64;&#x67;&#x6d;&#97;&#x69;&#108;&#x2e;&#x63;&#111;&#109;&#x5d;&#40;&#41;</a></p>
<blockquote>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-" target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a></a>.
..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线</p>
</blockquote>
</blockquote>
<p>程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。</p>
<blockquote>
<blockquote>
<p>尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。</p>
</li>
</ol>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
<a href="">显示删减掉的内容</a></p>
</blockquote>
</blockquote>
<p><img src="" alt=""> changsheng <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>说设计算法, 其实, 是实现算法, 找到合适的算法实现了.</p>
<p>五个障碍中的第一条在, 人力有限, 只能并行不并行不行的部分.
                                                     Changsheng Jiang
2010/3/22 Guancheng Chen <a href="&#109;&#97;&#x69;&#108;&#116;&#x6f;&#58;&#91;&#99;&#x68;&#101;&#x6e;&#103;&#117;&#46;&#46;&#46;&#x40;&#103;&#109;&#97;&#x69;&#x6c;&#46;&#99;&#x6f;&#x6d;&#x5d;&#40;&#x29;">&#91;&#99;&#x68;&#101;&#x6e;&#103;&#117;&#46;&#46;&#46;&#x40;&#103;&#109;&#97;&#x69;&#x6c;&#46;&#99;&#x6f;&#x6d;&#x5d;&#40;&#x29;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>我个人也觉得OpenMP是目前比较好用的并行方式。像您这样设计算法的程序员，是不是基本上也是只对串行算法做优化改进，然后性能瓶颈比较大的部分才
考虑实施并行化？
On 3月22日, 上午7时09分, Changsheng Jiang <a href="&#109;&#97;&#105;&#108;&#x74;&#x6f;&#x3a;&#91;&#106;&#105;&#x61;&#x6e;&#x67;&#x7a;&#117;&#x6f;&#46;&#x2e;&#x2e;&#x40;&#x67;&#109;&#x61;&#x69;&#108;&#46;&#x63;&#111;&#109;&#x5d;&#x28;&#41;">&#91;&#106;&#105;&#x61;&#x6e;&#x67;&#x7a;&#117;&#x6f;&#46;&#x2e;&#x2e;&#x40;&#x67;&#109;&#x61;&#x69;&#108;&#46;&#x63;&#111;&#109;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>说来惭愧, 接触并行时间不长, 没什么实际经验, 只写过几个并行程序.</p>
<p>感觉 MPI + OpenMP 倒算好用. 简单的单机程序, 用OpenMP并行, 添加几个编译指令就可以. 复杂点的, 用MPI, 也能忍,
只是需要重新设计一下程序和算法.</p>
<p>除了简单的打印, 跟踪一个进程, 不知道怎么调试并行程序. 没有专用平台如NUMA等的编程经验.</p>
<pre><code>                                                 Changsheng Jiang
</code></pre><p>2010/3/22 Guancheng Chen <a href="&#109;&#97;&#x69;&#x6c;&#116;&#111;&#58;&#x5b;&#99;&#104;&#x65;&#x6e;&#103;&#x75;&#97;&#x6e;&#x63;&#x68;&#46;&#x2e;&#x2e;&#64;&#103;&#109;&#x61;&#105;&#x6c;&#x2e;&#99;&#111;&#x6d;&#93;&#x28;&#41;">&#x5b;&#99;&#104;&#x65;&#x6e;&#103;&#x75;&#97;&#x6e;&#x63;&#x68;&#46;&#x2e;&#x2e;&#64;&#103;&#109;&#x61;&#105;&#x6c;&#x2e;&#99;&#111;&#x6d;&#93;&#x28;&#41;</a></p>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>&gt;
&gt;
&gt;</p>
<blockquote>
<blockquote>
<p>不知道您觉得现有的工具哪些个最趁手呢？</p>
<p>On 3月22日, 上午3时19分, Changsheng Jiang <a href="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#111;&#58;&#x5b;&#x6a;&#105;&#97;&#x6e;&#x67;&#x7a;&#117;&#x6f;&#46;&#x2e;&#46;&#64;&#103;&#x6d;&#97;&#x69;&#x6c;&#46;&#x63;&#x6f;&#109;&#x5d;&#x28;&#41;">&#x5b;&#x6a;&#105;&#97;&#x6e;&#x67;&#x7a;&#117;&#x6f;&#46;&#x2e;&#46;&#64;&#103;&#x6d;&#97;&#x69;&#x6c;&#46;&#x63;&#x6f;&#109;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>个人觉得最大障碍在工具上.</p>
<p>并行学术上研究得不少, 主要在算法和模型上. 工程上的工具, 多是自串行程序来设计的, 弄得复杂不堪. 并行需要语言和库两级支持,
Pthreads 和
MPI 仅从库上入手, 让程序员处理各种重复且复杂的分发, 并发锁等. OpenMP好一些, 可惜目前只支持线程并行.</p>
<p>用 ErLang 等将并行设计在语言里的来做并行会容易得多, 得易于面向消息传递的隔离模型, 程序稳定易写. 模型和语言的性能是一个问题,
主要的问题还在用的人和实际并行项目不多.</p>
<p>调试工具就更少了. 有少数商业化的工具.</p>
<p>当然, 我是将可维护性归结为语言工具太差.</p>
<pre><code>                                                 Changsheng Jiang
</code></pre><p>2010/3/22 Guancheng Chen <a href="&#109;&#97;&#105;&#x6c;&#x74;&#111;&#58;&#x5b;&#99;&#104;&#x65;&#x6e;&#103;&#x75;&#97;&#x6e;&#99;&#x68;&#x2e;&#46;&#46;&#x40;&#x67;&#x6d;&#97;&#x69;&#108;&#x2e;&#x63;&#111;&#x6d;&#93;&#x28;&#x29;">&#x5b;&#99;&#104;&#x65;&#x6e;&#103;&#x75;&#97;&#x6e;&#99;&#x68;&#x2e;&#46;&#46;&#x40;&#x67;&#x6d;&#97;&#x69;&#108;&#x2e;&#x63;&#111;&#x6d;&#93;&#x28;&#x29;</a></p>
<blockquote>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-" target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a></a>.
..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线</p>
</blockquote>
</blockquote>
<p>程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。</p>
<blockquote>
<blockquote>
<p>尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。</p>
</li>
</ol>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
 To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> Alleluia <img src="" alt=""></p>
</blockquote>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>Parallelism 说到底是算法问题.Parallelism与Concurrency不同,Concurrency所面对的问题相对的单一可以
让一群有经验的专家来实现一套通用库或者语言来提供一个基本的编程框架.而在Parallelism上,具体的不同问题,其所需要并行的算法是根本不同
的.原因在于不同的问题,其内部的DataDependency的结构完全不同,不同的Data Dependency的结构,需要构造不同的算法.即
便是相同的Data Dependency,在不同的颗粒度下，在不同的硬件条件下所采用的算法也是完全不同的.因为一旦出现Data
Dependency也就意味着并行计算模块之间需要进行通信.从以计算节点为单位的分布式并行,到多核CPU上的Numa结构,到SIMD上的向量处
理器,其计算单元之间的通信手段,通信效率简直天差地别.比如说,在SMP上最常见的并行算法,work stealing也就是Intel的TBB,
是建立在两个条件下第一个是CPU的Cache机制上,这使得通常在内存的之间的数据搬运消耗非常小,第二个是SMP上计算单元相对的少,因此每个计算
单元被分配到的任务就相对的重。其开销远远大于通信的开销,因此这种机制在SMP上相对的划算.但是如果你要在GPU上做Work Stealing就
完全不可行,因为GPU的运算单元数量极多,被分配到的任务就相对来说的非常轻量,CUDA上的一个thread很多时候运算一次的时间不会超过
10us,而一次跨Block的线程之间的通信开销就往往要达到100us左右,再加上目前GPU上的Cache机制非常落后导致了需要频繁的通信开销
的Work Stealing在GPU上是非常不划算得.
所以我个人认为在硬件架构没有更多的突破之前,OpenCL这种东西是没有任何生命力的.不要说CPU的并行与GPU之间差异巨大,就是不同的GPU之
间AMD与Nvidia两个也是各自为政,一个平台上跑得非常快的东西,在另外一个平台极大的可能是龟速.其最终的结果估计就是跟Java的
write once run everywhere一样是个大笑话.</p>
<p>On 3月22日, 下午2时06分, Guancheng Chen <a href="&#109;&#97;&#x69;&#108;&#x74;&#111;&#58;&#x5b;&#99;&#x68;&#x65;&#110;&#x67;&#x75;&#x61;&#x6e;&#x63;&#104;&#x2e;&#46;&#46;&#64;&#x67;&#109;&#x61;&#105;&#108;&#x2e;&#x63;&#111;&#109;&#x5d;&#40;&#41;">&#x5b;&#99;&#x68;&#x65;&#110;&#x67;&#x75;&#x61;&#x6e;&#x63;&#104;&#x2e;&#46;&#46;&#64;&#x67;&#109;&#x61;&#105;&#108;&#x2e;&#x63;&#111;&#109;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>On 3月22日, 上午2时20分, Tinyfool <a href="&#109;&#x61;&#x69;&#108;&#116;&#x6f;&#58;&#x5b;&#x74;&#105;&#110;&#x79;&#102;&#46;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#97;&#105;&#x6c;&#x2e;&#99;&#111;&#x6d;&#x5d;&#40;&#41;">&#x5b;&#x74;&#105;&#110;&#x79;&#102;&#46;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#97;&#105;&#x6c;&#x2e;&#99;&#111;&#x6d;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#109;&#x61;&#x69;&#108;&#116;&#111;&#x3a;&#91;&#106;&#x65;&#46;&#46;&#x2e;&#x40;&#108;&#105;&#x76;&#x65;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#x28;&#41;">&#91;&#106;&#x65;&#46;&#46;&#x2e;&#x40;&#108;&#105;&#x76;&#x65;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#x28;&#41;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#x6d;&#97;&#105;&#x6c;&#x74;&#x6f;&#58;&#91;&#x63;&#104;&#x65;&#110;&#103;&#x75;&#x61;&#110;&#99;&#x68;&#x2e;&#x2e;&#46;&#x40;&#x67;&#109;&#97;&#x69;&#108;&#46;&#99;&#x6f;&#109;&#93;&#40;&#x29;">&#91;&#x63;&#104;&#x65;&#110;&#103;&#x75;&#x61;&#110;&#99;&#x68;&#x2e;&#x2e;&#46;&#x40;&#x67;&#109;&#97;&#x69;&#108;&#46;&#99;&#x6f;&#109;&#93;&#40;&#x29;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#109;&#x61;&#105;&#108;&#116;&#x6f;&#58;&#x5b;&#112;&#x6f;&#x6e;&#46;&#46;&#x2e;&#64;&#x67;&#111;&#111;&#x67;&#x6c;&#101;&#103;&#114;&#x6f;&#117;&#112;&#115;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#x29;">&#x5b;&#112;&#x6f;&#x6e;&#46;&#46;&#x2e;&#64;&#x67;&#111;&#111;&#x67;&#x6c;&#101;&#103;&#114;&#x6f;&#117;&#112;&#115;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#x29;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
</blockquote>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<blockquote>
<blockquote>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。</p>
</li>
</ol>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>--
Tinyfool的开发日记<a href="http://www.tinydust.net/dev/" target="_blank"><a href="http://www.tinydust.net/dev/">http://www.tinydust.net/dev/</a></a>
代码中国网<a href="http://www.codechina.org/" target="_blank"><a href="http://www.codechina.org">http://www.codechina.org</a></a>
myTwitter:<a href="http://twitter.com/tinyfool" target="_blank"><a href="http://twitter.com/tinyfool">http://twitter.com/tinyfool</a></a>
<a href="">显示删减掉的内容</a></p>
</blockquote>
</blockquote>
<p><img src="" alt=""> Alleluia <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>其实并行计算这个东西,对现有的基于文本内容的程序意义不是很大.因为文本内容的数据量增加是线性的.而相对来说,视频音频的数据就完全不同是按平方甚
至是指数增加的.一个文本长度增加一倍,数据量也就增加一倍.而一张图片,长宽增加一倍,数据量要增加四倍.一个既有的算法在没有大的理论突破的前提
下,在特定的硬件平台上能够优化加速5-6倍已经是了不得了.但是对于多媒体数据来说,这个加速真的不算什么.一个算法在720p上快3,4倍,换到
1080p的也就是达到了720p上不加速的效果而已.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>绝大部分的观点Can&#39;t agree more.其实这也是为什么我引用了高老爷子那段话的原因，因为程序的本质就是数据结构和算法，你要没有非常适
合并行的算法那简直就是巧妇难为无米之炊。但是有疑问的一点是关于Parallelism和Concurrency这两个单词的区别，实际上这也是非常
有意思的一件事情，Sun的多线程指南上写的是： Parallelism is a condition that arises when at
least two threads are executing simultaneously, while concurrency is a
condition that exists when at least two threads are making progress.
Therefore concurrency is a more generalized form of parallelism that
can include time-slicing as a form of virtual parallelism.不知道您怎么看？</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>On 3月22日, 上午8时06分, Alleluia <a href="&#x6d;&#97;&#x69;&#x6c;&#x74;&#x6f;&#x3a;&#x5b;&#97;&#x6c;&#x6c;&#117;&#x6c;&#x2e;&#46;&#46;&#64;&#x67;&#x6d;&#x61;&#105;&#108;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#41;">&#x5b;&#97;&#x6c;&#x6c;&#117;&#x6c;&#x2e;&#46;&#46;&#64;&#x67;&#x6d;&#x61;&#105;&#108;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>Parallelism 说到底是算法问题.Parallelism与Concurrency不同,Concurrency所面对的问题相对的单一可以
让一群有经验的专家来实现一套通用库或者语言来提供一个基本的编程框架.而在Parallelism上,具体的不同问题,其所需要并行的算法是根本不同
的.原因在于不同的问题,其内部的DataDependency的结构完全不同,不同的Data Dependency的结构,需要构造不同的算法.即
便是相同的Data Dependency,在不同的颗粒度下，在不同的硬件条件下所采用的算法也是完全不同的.因为一旦出现Data
Dependency也就意味着并行计算模块之间需要进行通信.从以计算节点为单位的分布式并行,到多核CPU上的Numa结构,到SIMD上的向量处
理器,其计算单元之间的通信手段,通信效率简直天差地别.比如说,在SMP上最常见的并行算法,work stealing也就是Intel的TBB,
是建立在两个条件下第一个是CPU的Cache机制上,这使得通常在内存的之间的数据搬运消耗非常小,第二个是SMP上计算单元相对的少,因此每个计算
单元被分配到的任务就相对的重。其开销远远大于通信的开销,因此这种机制在SMP上相对的划算.但是如果你要在GPU上做Work Stealing就
完全不可行,因为GPU的运算单元数量极多,被分配到的任务就相对来说的非常轻量,CUDA上的一个thread很多时候运算一次的时间不会超过
10us,而一次跨Block的线程之间的通信开销就往往要达到100us左右,再加上目前GPU上的Cache机制非常落后导致了需要频繁的通信开销
的Work Stealing在GPU上是非常不划算得.
所以我个人认为在硬件架构没有更多的突破之前,OpenCL这种东西是没有任何生命力的.不要说CPU的并行与GPU之间差异巨大,就是不同的GPU之
间AMD与Nvidia两个也是各自为政,一个平台上跑得非常快的东西,在另外一个平台极大的可能是龟速.其最终的结果估计就是跟Java的
write once run everywhere一样是个大笑话.</p>
<p>On 3月22日, 下午2时06分, Guancheng Chen <a href="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#x6f;&#x3a;&#x5b;&#x63;&#104;&#101;&#x6e;&#x67;&#117;&#97;&#x6e;&#x63;&#104;&#46;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#97;&#105;&#108;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#40;&#41;">&#x5b;&#x63;&#104;&#101;&#x6e;&#x67;&#117;&#97;&#x6e;&#x63;&#104;&#46;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#97;&#105;&#108;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>On 3月22日, 上午2时20分, Tinyfool <a href="&#x6d;&#x61;&#105;&#x6c;&#116;&#x6f;&#x3a;&#x5b;&#x74;&#x69;&#x6e;&#121;&#102;&#46;&#x2e;&#x2e;&#x40;&#103;&#109;&#x61;&#x69;&#x6c;&#x2e;&#99;&#111;&#x6d;&#93;&#x28;&#x29;">&#x5b;&#x74;&#x69;&#x6e;&#121;&#102;&#46;&#x2e;&#x2e;&#x40;&#103;&#109;&#x61;&#x69;&#x6c;&#x2e;&#99;&#111;&#x6d;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#x6d;&#97;&#x69;&#108;&#116;&#x6f;&#58;&#x5b;&#106;&#x65;&#46;&#46;&#46;&#64;&#x6c;&#105;&#118;&#101;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#40;&#x29;">&#x5b;&#106;&#x65;&#46;&#46;&#46;&#64;&#x6c;&#105;&#118;&#101;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#40;&#x29;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#x6d;&#97;&#105;&#x6c;&#116;&#x6f;&#58;&#91;&#99;&#104;&#x65;&#x6e;&#x67;&#x75;&#x61;&#110;&#x63;&#x68;&#46;&#46;&#x2e;&#x40;&#103;&#x6d;&#97;&#x69;&#108;&#x2e;&#99;&#111;&#x6d;&#93;&#40;&#41;">&#91;&#99;&#104;&#x65;&#x6e;&#x67;&#x75;&#x61;&#110;&#x63;&#x68;&#46;&#46;&#x2e;&#x40;&#103;&#x6d;&#97;&#x69;&#108;&#x2e;&#99;&#111;&#x6d;&#93;&#40;&#41;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#x6d;&#97;&#105;&#108;&#x74;&#111;&#x3a;&#91;&#112;&#111;&#110;&#46;&#46;&#x2e;&#x40;&#x67;&#111;&#x6f;&#x67;&#x6c;&#101;&#x67;&#x72;&#x6f;&#x75;&#112;&#115;&#x2e;&#99;&#x6f;&#109;&#x5d;&#x28;&#41;">&#91;&#112;&#111;&#110;&#46;&#46;&#x2e;&#x40;&#x67;&#111;&#x6f;&#x67;&#x6c;&#101;&#x67;&#x72;&#x6f;&#x75;&#112;&#115;&#x2e;&#99;&#x6f;&#109;&#x5d;&#x28;&#41;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，...</p>
</blockquote>
</blockquote>
</blockquote>
<p>阅读更多 &gt;&gt;
<a href="">显示删减掉的内容</a></p>
</blockquote>
<p><img src="" alt=""> Alleluia <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>Concurrency 说到底纯粹就是一个IO问题.而IO问题本质上是和计算完全无关的事情,不存在能不能行可不可计算的问题.因此它相对来说非常
单纯。他更多的是一种类似时钟同步的问题,如果你把IO事件想像成一种时钟信号.其实时钟本来也就是一堆信号而已.如果你做过Circuit 的东西就
会明白,IO只是在不同的时序下进行数据采样.比如最简单的同步时钟,所有的时序电路公用一个时钟,把不同的电路安排在不同的时序边沿上触发.当然更复
杂异步逻辑的道理也是一样的.放到宏观的Concurrency的问题的实质并没有多大改变,只不过CPU依靠PC指针的移动把这种电路上的时序处理软
件化了.</p>
<p>而Parallelism更多的是需要考虑计算问题同时还要兼顾IO.Parallelism首先要回答的是一个东西是不是可并行的.回答完这个问题
后,如果可并行那么在什么样的硬件设备上并行是最合适的这样一个问题.在Parallelism中需要考虑的的IO也不仅仅是来自于网络更多是,缓存,
内存,磁盘,总线等等.其实我觉得,在Parallelism下你总是处于一个矛盾状态,颗粒度越小的并行获得的计算资源的利用率也就越大加速比就越
大,但是同时通信系统的工作也就越是繁忙整个运算过程浪费在通信消耗上的时间也就越多.
这个当中的tradeoff是非常困难的.很多时候速度不快,完全不是因为你的核心不够多,而是你的通信速度不够高.</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>On 3月22日, 下午3时21分, Guancheng Chen <a href="&#109;&#x61;&#x69;&#x6c;&#116;&#x6f;&#x3a;&#x5b;&#x63;&#x68;&#101;&#x6e;&#x67;&#x75;&#97;&#110;&#99;&#x68;&#46;&#x2e;&#46;&#x40;&#103;&#x6d;&#97;&#105;&#x6c;&#x2e;&#99;&#111;&#109;&#93;&#x28;&#41;">&#x5b;&#x63;&#x68;&#101;&#x6e;&#x67;&#x75;&#97;&#110;&#99;&#x68;&#46;&#x2e;&#46;&#x40;&#103;&#x6d;&#97;&#105;&#x6c;&#x2e;&#99;&#111;&#109;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>绝大部分的观点Can&#39;t agree more.其实这也是为什么我引用了高老爷子那段话的原因，因为程序的本质就是数据结构和算法，你要没有非常适
合并行的算法那简直就是巧妇难为无米之炊。但是有疑问的一点是关于Parallelism和Concurrency这两个单词的区别，实际上这也是非常
有意思的一件事情，Sun的多线程指南上写的是： Parallelism is a condition that arises when at
least two threads are executing simultaneously, while concurrency is a
condition that exists when at least two threads are making progress.
Therefore concurrency is a more generalized form of parallelism that
can include time-slicing as a form of virtual parallelism.不知道您怎么看？</p>
<p>On 3月22日, 上午8时06分, Alleluia <a href="&#x6d;&#x61;&#105;&#108;&#x74;&#111;&#58;&#91;&#97;&#108;&#x6c;&#x75;&#x6c;&#46;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#99;&#111;&#x6d;&#x5d;&#40;&#41;">&#91;&#97;&#108;&#x6c;&#x75;&#x6c;&#46;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#99;&#111;&#x6d;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>Parallelism 说到底是算法问题.Parallelism与Concurrency不同,Concurrency所面对的问题相对的单一可以
让一群有经验的专家来实现一套通用库或者语言来提供一个基本的编程框架.而在Parallelism上,具体的不同问题,其所需要并行的算法是根本不同
的.原因在于不同的问题,其内部的DataDependency的结构完全不同,不同的Data Dependency的结构,需要构造不同的算法.即
便是相同的Data Dependency,在不同的颗粒度下，在不同的硬件条件下所采用的算法也是完全不同的.因为一旦出现Data
Dependency也就意味着并行计算模块之间需要进行通信.从以计算节点为单位的分布式并行,到多核CPU上的Numa结构,到SIMD上的向量处
理器,其计算单元之间的通信手段,通信效率简直天差地别.比如说,在SMP上最常见的并行算法,work stealing也就是Intel的TBB,
是建立在两个条件下第一个是CPU的Cache机制上,这使得通常在内存的之间的数据搬运消耗非常小,第二个是SMP上计算单元相对的少,因此每个计算
单元被分配到的任务就相对的重。其开销远远大于通信的开销,因此这种机制在SMP上相对的划算.但是如果你要在GPU上做Work Stealing就
完全不可行,因为GPU的运算单元数量极多,被分配到的任务就相对来说的非常轻量,CUDA上的一个thread很多时候运算一次的时间不会超过
10us,而一次跨Block的线程之间的通信开销就往往要达到100us左右,再加上目前GPU上的Cache机制非常落后导致了需要频繁的通信开销
的Work Stealing在GPU上是非常不划算得.
所以我个人认为在硬件架构没有更多的突破之前,OpenCL这种东西是没有任何生命力的.不要说CPU的并行与GPU之间差异巨大,就是不同的GPU之
间AMD与Nvidia两个也是各自为政,一个平台上跑得非常快的东西,在另外一个平台极大的可能是龟速.其最终的结果估计就是跟Java的
write once run everywhere一样是个大笑话.</p>
<p>On 3月22日, 下午2时06分, Guancheng Chen <a href="&#109;&#97;&#x69;&#x6c;&#116;&#x6f;&#x3a;&#91;&#99;&#104;&#x65;&#110;&#x67;&#117;&#97;&#x6e;&#x63;&#x68;&#x2e;&#x2e;&#46;&#64;&#x67;&#x6d;&#x61;&#x69;&#108;&#46;&#x63;&#111;&#x6d;&#x5d;&#x28;&#41;">&#91;&#99;&#104;&#x65;&#110;&#x67;&#117;&#97;&#x6e;&#x63;&#x68;&#x2e;&#x2e;&#46;&#64;&#x67;&#x6d;&#x61;&#x69;&#108;&#46;&#x63;&#111;&#x6d;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>On 3月22日, 上午2时20分, Tinyfool <a href="&#x6d;&#x61;&#105;&#x6c;&#116;&#x6f;&#x3a;&#91;&#x74;&#105;&#x6e;&#121;&#102;&#46;&#46;&#x2e;&#x40;&#103;&#109;&#97;&#x69;&#108;&#46;&#99;&#x6f;&#x6d;&#x5d;&#40;&#x29;">&#91;&#x74;&#105;&#x6e;&#121;&#102;&#46;&#46;&#x2e;&#x40;&#103;&#109;&#97;&#x69;&#108;&#46;&#99;&#x6f;&#x6d;&#x5d;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#109;&#x61;&#x69;&#x6c;&#x74;&#x6f;&#x3a;&#91;&#x6a;&#x65;&#46;&#x2e;&#x2e;&#x40;&#108;&#x69;&#x76;&#101;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#x29;">&#91;&#x6a;&#x65;&#46;&#x2e;&#x2e;&#x40;&#108;&#x69;&#x76;&#101;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#x29;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#x6d;&#97;&#105;&#108;&#116;&#x6f;&#58;&#91;&#99;&#x68;&#x65;&#x6e;&#103;&#117;&#x61;&#x6e;&#x63;&#x68;&#46;&#x2e;&#46;&#64;&#x67;&#x6d;&#97;&#x69;&#x6c;&#46;&#99;&#x6f;&#x6d;&#93;&#x28;&#41;">&#91;&#99;&#x68;&#x65;&#x6e;&#103;&#117;&#x61;&#x6e;&#x63;&#x68;&#46;&#x2e;&#46;&#64;&#x67;&#x6d;&#97;&#x69;&#x6c;&#46;&#99;&#x6f;&#x6d;&#93;&#x28;&#41;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#109;&#x61;&#x69;&#x6c;&#x74;&#x6f;&#58;&#x5b;&#112;&#x6f;&#110;&#x2e;&#46;&#46;&#64;&#103;&#x6f;&#x6f;&#x67;&#108;&#101;&#103;&#x72;&#x6f;&#x75;&#x70;&#115;&#x2e;&#99;&#111;&#x6d;&#93;&#x28;&#x29;">&#x5b;&#112;&#x6f;&#110;&#x2e;&#46;&#46;&#64;&#103;&#x6f;&#x6f;&#x67;&#108;&#101;&#103;&#x72;&#x6f;&#x75;&#x70;&#115;&#x2e;&#99;&#111;&#x6d;&#93;&#x28;&#x29;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>...</p>
<p>阅读更多 &gt;&gt;
<a href="">显示删减掉的内容</a>
<img src="" alt=""> Alleluia <img src="" alt=""></p>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>Microsoft Accelerator稍稍看了一下这个东西,是05年的工作.这个东西其实已经不新鲜了.大概跟PyCUDA
array-processing operations such as those which frequently arise in
domains.
但是我要说的是,这个领域相对于真正需要的并行计算实在是太少太少.比如说他强调的 image processing and
scientific computing,当中很多非线性滤波的并行算法就不能用这个架构来做.</p>
<p>On 3月22日, 上午9时42分, &quot;Jeffrey Zhao&quot; <a href="&#109;&#x61;&#105;&#108;&#116;&#111;&#x3a;&#91;&#x6a;&#101;&#46;&#x2e;&#x2e;&#64;&#108;&#x69;&#118;&#x65;&#46;&#99;&#111;&#109;&#x5d;&#x28;&#41;">&#91;&#x6a;&#101;&#46;&#x2e;&#x2e;&#64;&#108;&#x69;&#118;&#x65;&#46;&#99;&#111;&#109;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>哈哈，广告好，扩展视野，那我继续做广告了......</p>
<p>微软其实很早就在搞Microsoft Accelerator项目，旨在利用DirectX进行计算，.NET项目。<a href="http://research.microsoft.com/en-us/projects/Accelerator/" target="_blank"><a href="http://research.microsoft.com/en-us/projects/Accelerator/">http://research.microsoft.com/en-us/projects/Accelerator/</a></a></p>
<p>然后F/#这边由于语言的支持良好，可以设计出丰富的表达式、DSL等Modeling Language，再由框架进行自动并行，解决问题可以很容易（已经2.0了）。</p>
<p>这篇文章是个简单介绍：<a href="http://strangelights.com/blog/archive/2008/09/21/1628.aspx" target="_blank"><a href="http://strangelights.com/blog/archive/2008/09/21/1628.aspx">http://strangelights.com/blog/archive/2008/09/21/1628.aspx</a></a></p>
<p>Microsoft Solver Foundation<a href="http://[code.msdn.microsoft.com/solverfoundation](http://code.msdn.microsoft.com/solverfoundation" target="_blank">http://[code.msdn.microsoft.com/solverfoundation](http://code.msdn.microsoft.com/solverfoundation</a>)</p>
<p>F/# Optimization Modeling Language Utilizing Microsoft Solver Foundation<a href="http://[code.msdn.microsoft.com/solverfoundationfs1](http://code.msdn.microsoft.com/solverfoundationfs1" target="_blank">http://[code.msdn.microsoft.com/solverfoundationfs1](http://code.msdn.microsoft.com/solverfoundationfs1</a>)</p>
<p>现在就等OpenCL如果有标准出来，肯定立马可以跟上个类库，哦耶。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p>From: Tinyfool
Sent: Monday, March 22, 2010 9:20 AM
To: <a href="">pon...@googlegroups.com</a>
Subject: Re: [TL] {技术}{多线程}实施并行编程的五大障碍</p>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#109;&#x61;&#x69;&#108;&#116;&#111;&#x3a;&#91;&#x6a;&#101;&#46;&#46;&#x2e;&#x40;&#108;&#x69;&#x76;&#x65;&#46;&#x63;&#111;&#109;&#93;&#x28;&#x29;">&#91;&#x6a;&#101;&#46;&#46;&#x2e;&#x40;&#108;&#x69;&#x76;&#x65;&#46;&#x63;&#111;&#109;&#93;&#x28;&#x29;</a></p>
<p>  我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>  其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>  例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>  至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>  例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>  Jeffrey Zhao
  Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
  Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p>  From: Guancheng Chen
  Sent: Monday, March 22, 2010 7:37 AM
  To: TopLanguage
  Subject: [TL] {技术}{多线程}实施并行编程的五大障碍</p>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>&gt;</p>
<blockquote>
<p>  近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
  碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
  (fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
  Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
  的看法。</p>
<p>  ( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看
 <a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
  )</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
</li>
<li><p>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</p>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，</p>
<p>Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
</li>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
...</p>
</li>
</ol>
<p>阅读更多 &gt;&gt;
<a href="">显示删减掉的内容</a></p>
</blockquote>
<p><img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>您的观点很有新意，我以前没有过用IO来区分Concurrency和Parallelism的想法，我猜测可能跟您的网络/通信背景有关。其实我觉得
从广义上来讲Parallelism和Concurrency是基本重合的两个概念，只不过可能Concurrency稍微偏工程一点，
Parallelism稍微偏研究一点。例如Herb Sutter要出的新书叫Effective Concurrency,而市面上其他讲并行计算
的书不少也使用Parallel相关的词汇。</p>
<p>另外您这句话我有些不赞同：&quot;颗粒度越小的并行获得的计算资源的利用率也就越大加速比就越大&quot;，拿一个计算密集型的嵌套循环举例，对比并行外层循环和并
行内层循环，无疑你在并行化外层循环时的性能加速比更好，而这时候你的并行度是粗粒度的(内循环并行相对来说是细粒度的)。当然，粗/细粒度的选择确实
是个tradeoff，拿锁竞争来说，细粒度的锁意味着更好的Scalability，但是你加锁/解锁的次数相比组粒度所来说增加了，而这种加锁/解
锁的操作是有开销的，所以需要在锁操作本身的开销和程序的Scalability中做一个平衡。</p>
<p>多谢指教！</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>On 3月22日, 上午10时19分, Alleluia <a href="&#x6d;&#97;&#105;&#108;&#x74;&#111;&#58;&#x5b;&#x61;&#108;&#108;&#117;&#x6c;&#46;&#46;&#46;&#64;&#x67;&#x6d;&#97;&#x69;&#x6c;&#46;&#x63;&#x6f;&#109;&#x5d;&#x28;&#41;">&#x5b;&#x61;&#108;&#108;&#117;&#x6c;&#46;&#46;&#46;&#64;&#x67;&#x6d;&#97;&#x69;&#x6c;&#46;&#x63;&#x6f;&#109;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>Concurrency 说到底纯粹就是一个IO问题.而IO问题本质上是和计算完全无关的事情,不存在能不能行可不可计算的问题.因此它相对来说非常
单纯。他更多的是一种类似时钟同步的问题,如果你把IO事件想像成一种时钟信号.其实时钟本来也就是一堆信号而已.如果你做过Circuit 的东西就
会明白,IO只是在不同的时序下进行数据采样.比如最简单的同步时钟,所有的时序电路公用一个时钟,把不同的电路安排在不同的时序边沿上触发.当然更复
杂异步逻辑的道理也是一样的.放到宏观的Concurrency的问题的实质并没有多大改变,只不过CPU依靠PC指针的移动把这种电路上的时序处理软
件化了.</p>
<p>而Parallelism更多的是需要考虑计算问题同时还要兼顾IO.Parallelism首先要回答的是一个东西是不是可并行的.回答完这个问题
后,如果可并行那么在什么样的硬件设备上并行是最合适的这样一个问题.在Parallelism中需要考虑的的IO也不仅仅是来自于网络更多是,缓存,
内存,磁盘,总线等等.其实我觉得,在Parallelism下你总是处于一个矛盾状态,颗粒度越小的并行获得的计算资源的利用率也就越大加速比就越
大,但是同时通信系统的工作也就越是繁忙整个运算过程浪费在通信消耗上的时间也就越多.
这个当中的tradeoff是非常困难的.很多时候速度不快,完全不是因为你的核心不够多,而是你的通信速度不够高.</p>
<p>On 3月22日, 下午3时21分, Guancheng Chen <a href="&#x6d;&#x61;&#105;&#x6c;&#116;&#x6f;&#x3a;&#x5b;&#x63;&#104;&#x65;&#x6e;&#103;&#x75;&#x61;&#x6e;&#x63;&#104;&#46;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#97;&#105;&#108;&#x2e;&#99;&#111;&#109;&#x5d;&#40;&#41;">&#x5b;&#x63;&#104;&#x65;&#x6e;&#103;&#x75;&#x61;&#x6e;&#x63;&#104;&#46;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#97;&#105;&#108;&#x2e;&#99;&#111;&#109;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>绝大部分的观点Can&#39;t agree more.其实这也是为什么我引用了高老爷子那段话的原因，因为程序的本质就是数据结构和算法，你要没有非常适
合并行的算法那简直就是巧妇难为无米之炊。但是有疑问的一点是关于Parallelism和Concurrency这两个单词的区别，实际上这也是非常
有意思的一件事情，Sun的多线程指南上写的是： Parallelism is a condition that arises when at
least two threads are executing simultaneously, while concurrency is a
condition that exists when at least two threads are making progress.
Therefore concurrency is a more generalized form of parallelism that
can include time-slicing as a form of virtual parallelism.不知道您怎么看？</p>
<p>On 3月22日, 上午8时06分, Alleluia <a href="&#109;&#97;&#x69;&#x6c;&#x74;&#111;&#58;&#x5b;&#97;&#108;&#108;&#117;&#108;&#x2e;&#46;&#x2e;&#64;&#103;&#x6d;&#97;&#x69;&#108;&#46;&#x63;&#x6f;&#109;&#93;&#40;&#41;">&#x5b;&#97;&#108;&#108;&#117;&#108;&#x2e;&#46;&#x2e;&#64;&#103;&#x6d;&#97;&#x69;&#108;&#46;&#x63;&#x6f;&#109;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>Parallelism 说到底是算法问题.Parallelism与Concurrency不同,Concurrency所面对的问题相对的单一可以
让一群有经验的专家来实现一套通用库或者语言来提供一个基本的编程框架.而在Parallelism上,具体的不同问题,其所需要并行的算法是根本不同
的.原因在于不同的问题,其内部的DataDependency的结构完全不同,不同的Data Dependency的结构,需要构造不同的算法.即
便是相同的Data Dependency,在不同的颗粒度下，在不同的硬件条件下所采用的算法也是完全不同的.因为一旦出现Data
Dependency也就意味着并行计算模块之间需要进行通信.从以计算节点为单位的分布式并行,到多核CPU上的Numa结构,到SIMD上的向量处
理器,其计算单元之间的通信手段,通信效率简直天差地别.比如说,在SMP上最常见的并行算法,work stealing也就是Intel的TBB,
是建立在两个条件下第一个是CPU的Cache机制上,这使得通常在内存的之间的数据搬运消耗非常小,第二个是SMP上计算单元相对的少,因此每个计算
单元被分配到的任务就相对的重。其开销远远大于通信的开销,因此这种机制在SMP上相对的划算.但是如果你要在GPU上做Work Stealing就
完全不可行,因为GPU的运算单元数量极多,被分配到的任务就相对来说的非常轻量,CUDA上的一个thread很多时候运算一次的时间不会超过
10us,而一次跨Block的线程之间的通信开销就往往要达到100us左右,再加上目前GPU上的Cache机制非常落后导致了需要频繁的通信开销
的Work Stealing在GPU上是非常不划算得.
所以我个人认为在硬件架构没有更多的突破之前,OpenCL这种东西是没有任何生命力的.不要说CPU的并行与GPU之间差异巨大,就是不同的GPU之
间AMD与Nvidia两个也是各自为政,一个平台上跑得非常快的东西,在另外一个平台极大的可能是龟速.其最终的结果估计就是跟Java的
write once run everywhere一样是个大笑话.</p>
<p>On 3月22日, 下午2时06分, Guancheng Chen <a href="&#109;&#x61;&#x69;&#x6c;&#x74;&#x6f;&#x3a;&#91;&#x63;&#104;&#101;&#110;&#103;&#x75;&#x61;&#x6e;&#99;&#x68;&#46;&#46;&#46;&#x40;&#103;&#x6d;&#97;&#105;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#93;&#40;&#x29;">&#91;&#x63;&#104;&#101;&#110;&#103;&#x75;&#x61;&#x6e;&#99;&#x68;&#46;&#46;&#46;&#x40;&#103;&#x6d;&#97;&#105;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>On 3月22日, 上午2时20分, Tinyfool <a href="&#109;&#97;&#x69;&#x6c;&#x74;&#x6f;&#x3a;&#91;&#x74;&#x69;&#110;&#121;&#x66;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#109;&#97;&#105;&#108;&#x2e;&#99;&#111;&#x6d;&#93;&#40;&#x29;">&#91;&#x74;&#x69;&#110;&#121;&#x66;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#109;&#97;&#105;&#108;&#x2e;&#99;&#111;&#x6d;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#109;&#97;&#x69;&#108;&#116;&#111;&#x3a;&#x5b;&#x6a;&#x65;&#x2e;&#46;&#46;&#x40;&#x6c;&#x69;&#x76;&#x65;&#x2e;&#99;&#111;&#x6d;&#x5d;&#40;&#41;">&#x5b;&#x6a;&#x65;&#x2e;&#46;&#46;&#x40;&#x6c;&#x69;&#x76;&#x65;&#x2e;&#99;&#111;&#x6d;&#x5d;&#40;&#41;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#x6d;&#x61;&#105;&#x6c;&#116;&#111;&#58;&#91;&#99;&#x68;&#x65;&#110;&#103;&#117;&#x61;&#x6e;&#x63;&#x68;&#46;&#46;&#x2e;&#64;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#99;&#111;&#x6d;&#93;&#40;&#x29;">&#91;&#99;&#x68;&#x65;&#110;&#103;&#117;&#x61;&#x6e;&#x63;&#x68;&#46;&#46;&#x2e;&#64;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#99;&#111;&#x6d;&#93;&#40;&#x29;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#109;&#x61;&#105;&#108;&#x74;&#x6f;&#58;&#91;&#x70;&#x6f;&#110;&#46;&#x2e;&#46;&#64;&#103;&#x6f;&#111;&#x67;&#108;&#x65;&#103;&#114;&#111;&#x75;&#112;&#115;&#46;&#x63;&#111;&#109;&#x5d;&#40;&#41;">&#91;&#x70;&#x6f;&#110;&#46;&#x2e;&#46;&#64;&#103;&#x6f;&#111;&#x67;&#108;&#x65;&#103;&#114;&#111;&#x75;&#112;&#115;&#46;&#x63;&#111;&#109;&#x5d;&#40;&#41;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也...</p>
</li>
</ol>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>阅读更多 &gt;&gt;
<a href="">显示删减掉的内容</a>
<img src="" alt=""> Googol Lee <img src="" alt=""></p>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>彻底来晚了......我是来广告golang的！大并发IO还是csp模型的语言更靠谱！</p>
<p>不过golang在cpu密集的并发上不知道效果会怎么样，就现在的表现来看比erlang好，但还赶不上c/c++</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>On Mar 22, 9:20 am, Tinyfool <a href="&#x6d;&#97;&#x69;&#108;&#x74;&#111;&#58;&#91;&#116;&#105;&#x6e;&#x79;&#102;&#46;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#105;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#x29;">&#91;&#116;&#105;&#x6e;&#x79;&#102;&#46;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#105;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#109;&#x61;&#105;&#x6c;&#116;&#x6f;&#x3a;&#91;&#106;&#x65;&#x2e;&#46;&#x2e;&#x40;&#x6c;&#x69;&#x76;&#x65;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#41;">&#91;&#106;&#x65;&#x2e;&#46;&#x2e;&#x40;&#x6c;&#x69;&#x76;&#x65;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#41;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#x6d;&#97;&#105;&#108;&#116;&#111;&#58;&#91;&#99;&#x68;&#101;&#x6e;&#103;&#x75;&#97;&#110;&#99;&#104;&#46;&#46;&#46;&#x40;&#103;&#x6d;&#97;&#105;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#40;&#x29;">&#91;&#99;&#x68;&#101;&#x6e;&#103;&#x75;&#97;&#110;&#99;&#104;&#46;&#46;&#46;&#x40;&#103;&#x6d;&#97;&#105;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#40;&#x29;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#x6d;&#x61;&#x69;&#108;&#x74;&#x6f;&#58;&#91;&#x70;&#x6f;&#110;&#x2e;&#46;&#x2e;&#x40;&#x67;&#x6f;&#x6f;&#x67;&#108;&#x65;&#103;&#114;&#111;&#117;&#x70;&#115;&#46;&#99;&#x6f;&#109;&#93;&#40;&#x29;">&#91;&#x70;&#x6f;&#110;&#x2e;&#46;&#x2e;&#x40;&#x67;&#x6f;&#x6f;&#x67;&#108;&#x65;&#103;&#114;&#111;&#117;&#x70;&#115;&#46;&#99;&#x6f;&#109;&#93;&#40;&#x29;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄</p>
</li>
</ol>
</blockquote>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<blockquote>
<blockquote>
<p>了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。</p>
</li>
</ol>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>--
Tinyfool的开发日记<a href="http://www.tinydust.net/dev/" target="_blank"><a href="http://www.tinydust.net/dev/">http://www.tinydust.net/dev/</a></a>
代码中国网<a href="http://www.codechina.org/" target="_blank"><a href="http://www.codechina.org">http://www.codechina.org</a></a>
myTwitter:<a href="http://twitter.com/tinyfool" target="_blank"><a href="http://twitter.com/tinyfool">http://twitter.com/tinyfool</a></a>
<a href="">显示删减掉的内容</a></p>
</blockquote>
<p><img src="" alt=""> Jeffrey Zhao <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>锟斤拷锟斤拷锟斤拷F/#锟斤拷锟斤拷锟斤拷锟斤拷锟揭伙拷锟斤拷锟斤拷诺姆锟绞斤拷锟绞碉拷锟紺SP锟侥★拷</p>
<p>锟斤拷锟斤拷锟斤拷锟斤拷锟节达拷锟斤拷院锟节诧拷锟斤拷锟斤拷锟斤拷锟较斤拷锟斤拷F/#锟狡广，锟斤拷锟斤拷锟斤拷</p>
<p>Jeffrey Zhao
Blog: <a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter: @jeffz_cn</p>
<hr>
<p>From: &quot;Googol Lee&quot; <a href="&#x6d;&#x61;&#105;&#x6c;&#116;&#111;&#x3a;&#x5b;&#x67;&#111;&#x6f;&#x67;&#46;&#x2e;&#46;&#x40;&#x67;&#109;&#97;&#x69;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#40;&#41;">&#x5b;&#x67;&#111;&#x6f;&#x67;&#46;&#x2e;&#46;&#x40;&#x67;&#109;&#97;&#x69;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#40;&#41;</a>
Sent: Monday, March 22, 2010 8:30 PM
To: &quot;TopLanguage&quot; <a href="&#x6d;&#x61;&#105;&#108;&#x74;&#111;&#x3a;&#91;&#x70;&#x6f;&#110;&#x2e;&#x2e;&#x2e;&#64;&#103;&#x6f;&#111;&#x67;&#x6c;&#101;&#103;&#x72;&#x6f;&#117;&#x70;&#115;&#46;&#x63;&#x6f;&#109;&#x5d;&#40;&#41;">&#91;&#x70;&#x6f;&#110;&#x2e;&#x2e;&#x2e;&#64;&#103;&#x6f;&#111;&#x67;&#x6c;&#101;&#103;&#x72;&#x6f;&#117;&#x70;&#115;&#46;&#x63;&#x6f;&#109;&#x5d;&#40;&#41;</a>
Subject: [TL] Re: {锟斤拷锟斤拷}{锟斤拷锟竭筹拷}实施锟斤拷锟叫憋拷痰锟斤拷锟斤拷锟较帮拷</p>
<blockquote>
<p>锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷......锟斤拷锟斤拷锟斤拷锟斤拷锟絞olang锟侥ｏ拷锟襟并凤拷IO锟斤拷锟斤拷csp模锟酵碉拷锟斤拷锟皆革拷锟阶ｏ拷</p>
<p>锟斤拷锟斤拷golang锟斤拷cpu锟杰硷拷锟侥诧拷锟斤拷锟较诧拷知锟斤拷效锟斤拷锟斤拷锟矫达拷锟斤拷锟斤拷锟节的憋拷锟斤拷锟斤拷锟斤拷锟斤拷erlang锟矫ｏ拷锟斤拷锟斤拷锟较诧拷锟斤拷c/c++</p>
<p>On Mar 22, 9:20 am, Tinyfool <a href="&#109;&#97;&#105;&#x6c;&#x74;&#111;&#x3a;&#x5b;&#x74;&#x69;&#x6e;&#x79;&#x66;&#46;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#97;&#105;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#41;">&#x5b;&#x74;&#x69;&#x6e;&#x79;&#x66;&#46;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#97;&#105;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷模锟斤拷锟饺伙拷越锟斤拷冒锟斤拷锟斤拷锟剿ｏ拷锟斤拷也锟斤拷锟斤拷锟揭伙拷锟�</p>
<p>Mac OS X锟斤拷锟铰的诧拷锟叫伙拷锟狡斤拷锟斤拷GCD锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟街撅拷知锟斤拷锟睫憋拷强锟斤拷锟剿吧ｏ拷</p>
<p>锟斤拷锟斤拷支锟斤拷锟皆匡拷锟斤拷锟斤拷锟絆penCL也锟斤拷锟睫憋拷强锟襟啊★拷</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#x6d;&#97;&#x69;&#108;&#x74;&#x6f;&#x3a;&#x5b;&#x6a;&#x65;&#x2e;&#46;&#46;&#64;&#108;&#105;&#x76;&#x65;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#40;&#41;">&#x5b;&#x6a;&#x65;&#x2e;&#46;&#46;&#64;&#108;&#105;&#x76;&#x65;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#40;&#41;</a></p>
<blockquote>
<p> 锟斤拷锟斤拷锟斤拷锟斤拷妫猴拷锟斤拷瞬锟斤拷锌狻拷锟斤拷锟紽/#锟斤拷锟斤拷锟斤拷锟皆碉拷支锟街ｏ拷锟斤拷锟叫憋拷锟斤拷丫锟斤拷锟斤拷缀芏锟斤拷恕锟斤拷锟斤拷锟叫э拷剩锟街达拷锟叫э拷剩锟斤拷锟轿拷锟斤拷远锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟竭★拷</p>
<p>锟斤拷实锟斤拷锟斤拷&quot;锟斤拷锟斤拷&quot;锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷茫锟街灰拷锟脚ｏ拷税锟斤拷锟斤拷壮锟斤拷锟斤拷锟侥讹拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷装锟斤拷锟斤拷锟斤拷锟斤拷一锟斤拷锟斤拷锟矫的筹拷锟襟，对大部分筹拷锟斤拷员锟斤拷说锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷唷�</p>
<p>锟斤拷锟斤拷Memory Consistency锟斤拷锟斤拷JVM锟斤拷CLR锟斤拷锟斤拷锟节革拷CPU锟杰癸拷锟斤拷统一锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷没锟叫诧拷锟叫匡拷锟街э拷郑锟叫达拷锟斤拷谐锟斤拷锟斤拷丫锟斤拷锟斤拷锟斤拷锟斤拷珊芏锟斤拷恕锟�</p>
<p>锟斤拷锟节斤拷锟斤拷锟斤拷......锟揭撅拷锟斤拷锟斤拷实锟斤拷锟斤拷锟斤拷獾癸拷锟斤拷遣锟斤拷锟斤拷锟斤拷械模锟揭诧拷锟斤拷遣锟斤拷锟斤拷锟斤拷锟斤拷锟街的革拷祝锟斤拷锟斤拷牵锟斤拷锟斤拷冢锟斤拷锟斤拷锟斤拷锟矫伙拷锟斤拷锟斤拷吮锟斤拷锟斤拷锟矫★拷</p>
<p>锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷系锟结构锟斤拷锟斤拷锟斤拷系统锟饺等★拷锟斤拷锟斤拷然锟酵诧拷锟斤拷锟叫关ｏ拷锟斤拷也锟斤拷锟角诧拷锟斤拷锟斤拷锟叫的讹拷锟斤拷锟斤拷</p>
</blockquote>
</blockquote>
<p>&gt;</p>
<blockquote>
<blockquote>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#109;&#97;&#x69;&#108;&#116;&#x6f;&#x3a;&#x5b;&#99;&#104;&#101;&#110;&#x67;&#117;&#97;&#x6e;&#x63;&#104;&#x2e;&#46;&#46;&#64;&#x67;&#109;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#40;&#41;">&#x5b;&#99;&#104;&#101;&#110;&#x67;&#117;&#97;&#x6e;&#x63;&#104;&#x2e;&#46;&#46;&#64;&#x67;&#109;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#40;&#41;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#x6d;&#97;&#105;&#x6c;&#116;&#111;&#58;&#x5b;&#112;&#111;&#x6e;&#46;&#46;&#x2e;&#64;&#103;&#x6f;&#111;&#x67;&#x6c;&#x65;&#103;&#x72;&#111;&#117;&#112;&#115;&#x2e;&#x63;&#111;&#x6d;&#93;&#x28;&#41;">&#x5b;&#112;&#111;&#x6e;&#46;&#46;&#x2e;&#64;&#103;&#x6f;&#111;&#x67;&#x6c;&#x65;&#103;&#x72;&#111;&#117;&#112;&#115;&#x2e;&#x63;&#111;&#x6d;&#93;&#x28;&#41;</a>
/<em>Subject:/</em> [TL] {锟斤拷锟斤拷}{锟斤拷锟竭筹拷}实施锟斤拷锟叫憋拷痰锟斤拷锟斤拷锟较帮拷</p>
<p>锟斤拷锟节匡拷锟斤拷一篇锟斤拷锟斤拷Intel锟侥猴拷锟斤拷锟斤拷思锟侥凤拷锟斤拷锟斤拷锟铰ｏ拷锟斤拷锟斤拷锟结到锟斤拷锟斤拷锟斤拷45锟斤拷锟斤拷锟侥革拷锟斤拷司锟斤拷锟斤拷员/锟斤拷锟斤拷锟斤拷锟斤拷/战锟斤拷师锟斤拷锟斤拷&quot;什么锟斤拷实施锟斤拷锟叫憋拷痰锟斤拷锟斤拷锟斤拷
锟斤拷&quot;时锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷乇锟斤拷峒帮拷拇锟斤拷锟斤拷锟洁：锟斤拷锟斤拷锟斤拷锟斤拷(legacy code)锟斤拷锟斤拷锟斤拷(education)锟斤拷锟斤拷锟斤拷(tools)锟斤拷锟斤拷锟节猴拷锟斤拷锟狡的恐撅拷
(fear of many cores)锟皆硷拷锟斤拷维锟斤拷锟斤拷(maintainability)锟斤拷锟斤拷锟斤拷锟斤拷然锟斤拷一篇Intel
Parallel
Studio锟斤拷锟斤拷锟侥ｏ拷锟斤拷锟斤拷锟斤拷锟斤拷锟结及锟斤拷锟斤拷锟斤拷锟斤拷习锟饺达拷浅锟街碉拷锟斤拷锟斤拷郏锟斤拷锟斤拷锟斤拷锟斤拷叶锟斤拷锟斤拷锟斤拷锟较帮拷锟斤拷一些锟斤拷浅锟斤拷锟斤拷锟斤拷希锟斤拷锟斤拷锟斤拷一锟斤拷锟斤拷砖锟斤拷锟斤拷锟斤拷锟斤拷茫锟斤拷锟接拷锟揭革拷锟斤拷锟斤拷锟�
锟侥匡拷锟斤拷锟斤拷</p>
<p>( 注锟斤拷锟斤拷锟斤拷Google Group锟斤拷锟斤拷原锟侥碉拷一些锟斤拷锟斤拷锟接讹拷失效锟剿ｏ拷锟斤拷锟斤拷锟斤拷懈锟矫碉拷锟侥讹拷锟斤拷锟介，锟诫看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>锟斤拷锟斤拷锟斤拷锟斤拷
锟斤拷锟斤拷锟斤拷知锟斤拷锟斤拷锟叫伙拷实施锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷压锟剿撅拷锟斤拷锟叫╋拷锟斤拷锟斤拷锟斤拷锟斤拷锟叫伙拷锟斤拷100K~1000K锟侥达拷锟斤拷锟斤拷锟斤拷锟角筹拷锟斤拷锟斤拷斜锟教憋拷锟斤拷锟斤拷锟角非筹拷锟斤拷锟阶筹拷锟斤拷模锟�
一锟斤拷锟斤拷锟斤拷锟絛ata race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe锟饺碉拷锟斤拷锟斤拷锟斤拷锟斤拷锟揭伙拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟酵凤拷螅锟斤拷说要锟斤拷
效锟缴匡拷锟侥诧拷锟叫伙拷锟斤拷些锟接达拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷恕锟斤拷锟斤拷锟斤拷训锟斤拷呛芏锟斤拷锟斤拷锟斤拷锟斤拷牖癸拷斜锟叫达拷锟斤拷丫锟斤拷锟街帮拷锟斤拷牡锟阶拷筒锟饺拷锟斤拷锟斤拷猓拷锟斤拷锟斤拷锟斤拷锟窖╋拷霞锟剿拷锟斤拷映杀锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷通锟斤拷一
些锟斤拷锟斤拷谋锟斤拷锟斤拷锟�(锟斤拷锟斤拷Intel锟斤拷ICC)锟皆讹拷锟斤拷锟叫伙拷一些锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷省钱锟侥ｏ拷锟斤拷锟斤拷锟斤拷锟街凤拷锟斤拷锟斤拷锟斤拷缺锟捷撅拷锟斤拷锟斤拷锟斤拷Intel ICC锟斤拷锟斤拷锟皆讹拷锟酵憋拷锟斤拷锟斤拷
锟斤拷锟皆讹拷锟斤拷锟叫伙拷锟侥达拷锟斤拷浅锟斤拷伲锟斤拷佣锟斤拷锟斤拷锟斤拷锟斤拷峁╋拷锟斤拷锟斤拷锟斤拷呕锟斤拷浅锟斤拷锟斤拷蓿锟斤拷锟斤拷揖锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷芑锟斤拷speedup锟侥达拷锟斤拷也锟叫很讹拷约锟斤拷锟斤拷锟斤拷(锟斤拷锟斤拷loop锟斤拷循锟斤拷之锟斤拷
没锟斤拷dependence锟斤拷锟斤拷锟揭革拷loop应锟斤拷锟斤拷一锟斤拷锟斤拷锟斤拷锟饺碉拷)锟斤拷锟斤拷锟斤拷目前锟斤拷锟斤拷状锟斤拷锟角达拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟诫并锟斤拷锟斤拷锟斤拷效锟侥憋拷锟斤拷锟叫伙拷锟斤拷锟斤拷锟斤拷业锟侥角讹拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟�
锟斤拷一锟街斤拷锟斤拷锟斤拷锟斤拷锟斤拷诙锟绞憋拷锟斤拷诳锟斤拷倏煽锟斤拷锟酵拷锟绞凳╋拷锟斤拷谢锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟�%~30%锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷么锟斤拷锟斤拷丫锟斤拷锟轿拷锟剿撅拷锟绞★拷锟斤拷锟斤拷杀锟斤拷恕锟�</p>
</li>
<li><p>锟斤拷锟斤拷
锟节讹拷锟斤拷锟斤拷习锟斤拷锟斤拷芫锟斤拷浅锟斤拷锟皆比憋拷锟斤拷锟斤拷斜锟教凤拷锟斤拷慕锟斤拷锟斤拷恕锟斤拷锟绞碉拷锟斤拷斜锟斤拷锟窖撅拷锟叫讹拷锟斤拷十锟斤拷锟斤拷锟绞凤拷耍锟斤拷锟斤拷锟斤拷诙锟斤拷CPU锟斤拷锟斤拷之前锟斤拷些锟斤拷锟叫憋拷潭锟斤拷锟�&quot;专锟斤拷&quot;锟角碉拷锟斤拷
锟竭★拷锟斤拷时锟斤拷牟锟斤拷斜锟教达拷锟斤拷锟斤拷锟节硷拷群锟斤拷锟斤拷锟酵伙拷锟斤拷叻锟斤拷锟斤拷锟斤拷希锟酵拷锟組PI(message
passing model)锟斤拷锟斤拷SMP(锟皆称多处锟斤拷锟斤拷锟斤拷锟斤拷一
锟斤拷锟斤拷锟斤拷锟斤拷锟叫讹拷锟斤拷锟斤拷锟紺PU锟斤拷锟斤拷锟斤拷shared memory model)锟斤拷锟斤拷刹锟斤拷屑锟斤拷恪thread锟斤拷准锟斤拷1995锟疥建锟斤拷锟侥ｏ拷之锟斤拷锟斤拷锟斤拷锟�
Windows锟斤拷锟絎in32 thread锟斤拷锟斤拷锟斤拷锟街筹拷锟斤拷锟斤拷&quot;锟斤拷锟斤拷指锟斤拷&quot;锟斤拷锟斤拷锟斤拷data parallel模锟酵碉拷OpenMP(OpenMP 3.0锟斤拷
锟斤拷锟斤拷task parallel支锟斤拷)锟斤拷task parallel锟侥憋拷锟斤拷Click锟斤拷Intel锟斤拷Intel Thread
Building
Block(task parallel)锟斤拷Java 1.5锟斤拷始锟皆讹拷锟竭筹拷锟结供锟较好碉拷支锟斤拷(锟斤拷锟斤拷锟斤拷Java
Memory Model)锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷
GPU锟侥凤拷展锟斤拷Nvidia锟街匡拷始锟斤拷CUDA(data-parallel)锟斤拷Apple一锟斤拷锟斤拷锟皆ｏ拷锟斤拷锟叫憋拷锟斤拷院锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷业貌锟揭伙拷郑锟斤拷锟斤拷锟斤拷约锟斤拷锟斤拷锟脚�
锟剿革拷锟斤拷锟紺PU锟斤拷GPU锟斤拷媳锟教碉拷OpenCL锟斤拷微锟斤拷一锟斤拷也锟斤拷住锟斤拷也要锟斤拷锟斤拷Visual
Studio2010锟斤拷始锟斤拷C/#锟侥诧拷锟叫库，锟斤拷锟斤拷C++0x也
要锟斤拷锟斤拷锟斤拷叱锟街э拷郑锟斤拷锟斤拷锟斤拷锟斤拷瞎哦锟紼rlang也锟斤拷为锟斤拷锟斤拷支锟街诧拷锟叫憋拷锟斤拷锟斤拷锟饺筹拷锟斤拷锟斤拷之锟斤拷锟斤拷摩锟斤拷锟斤拷锟节达拷锟斤拷锟斤拷锟斤拷锟绞э拷锟斤拷锟斤拷业锟界都锟斤拷始锟斤拷锟斤拷锟斤拷锟叫憋拷谭锟斤拷锟�
展锟斤拷</p>
</li>
</ol>
<p>锟斤拷锟角对筹拷锟斤拷员锟斤拷说锟斤拷锟斤拷什么锟斤拷锟斤拷兀锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟杰的斤拷锟斤拷蠖蓟锟斤拷谴锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷些锟姐法锟斤拷锟斤拷萁峁癸拷锟斤拷叩锟斤拷锟斤拷锟揭黄拷锟教革拷锟剿�&quot;锟斤拷锟揭匡拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟�
锟斤拷硬锟斤拷锟斤拷锟斤拷锟斤拷丫锟斤拷藜瓶锟绞╋拷说锟斤拷碌模锟斤拷锟斤拷墙锟組oore锟斤拷锟斤拷失效锟斤拷锟斤拷锟斤拷锟斤拷锟窖革拷锟斤拷锟斤拷锟斤拷锟斤拷撸锟斤拷锟斤拷锟斤拷歉锟斤拷锟斤拷堑幕锟斤拷锟街伙拷锟斤拷锟侥承┲革拷锟斤拷锟斤拷锟斤拷械酶锟斤拷锟剿讹拷锟窖★拷锟斤拷锟斤拷锟斤拷
锟教碉拷锟诫法锟斤拷证锟斤拷锟斤拷失锟杰的ｏ拷锟斤拷一锟姐都锟斤拷锟斤拷械锟斤拷锟斤拷锟�......锟斤拷锟斤拷说锟斤拷锟叫讹拷锟劫筹拷锟斤拷员锟斤拷锟斤拷锟斤拷未锟斤拷一片锟斤拷锟斤拷锟侥伙拷锟斤拷锟斤拷锟斤拷强锟揭碉拷锟斤拷趣锟斤拷锟揭硷拷锟斤拷没锟斤拷锟斤拷说锟斤拷锟斤拷锟斤拷锟斤拷堑锟斤拷呖唷�
锟斤拷锟斤拷锟斤拷锟斤拷学院锟斤拷些锟斤拷硬锟斤拷锟侥家伙拷一直锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟角达拷锟�&quot;锟斤拷锟缴硷拷硬锟斤拷锟斤拷展锟斤拷锟斤拷锟斤拷锟斤拷转锟斤拷直锟接碉拷锟铰筹拷锟斤拷员锟斤拷锟斤拷训锟斤拷锟斤拷锟窖撅拷锟斤拷锟斤拷锟剿★拷锟斤拷么锟斤拷锟斤拷员锟斤拷锟斤拷锟杰碉拷锟斤拷锟矫碉拷
锟斤拷锟叫憋拷探锟斤拷锟斤拷锟斤拷穑亢锟斤拷锟饺伙拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷一锟斤拷锟斤拷通锟侥筹拷锟斤拷员锟斤拷&quot;锟斤拷锟斤拷貌锟斤拷斜锟斤拷锟斤拷锟斤拷么锟斤拷&quot;锟斤拷十锟叫八九伙拷说&quot;锟揭撅拷锟矫猴拷锟斤拷&quot;锟斤拷前一锟斤拷锟斤拷锟斤拷锟斤拷锟桔凤拷锟斤拷锟斤拷锟斤拷锟斤拷枚锟斤拷叱锟�
锟矫伙拷锟角讹拷锟教好ｏ拷锟斤拷实锟斤拷原锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷露锟斤拷叱锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷疲锟斤拷锟斤拷锟絠solation锟侥讹拷锟斤拷模式锟斤拷锟斤拷programming productivity
锟斤拷performance之锟斤拷锟揭碉拷锟饺较好碉拷锟斤拷锟皆ｏ拷锟斤拷锟皆癸拷锟节猴拷锟叫凤拷锟斤拷锟斤拷锟斤拷锟斤拷锟竭讹拷选锟斤拷锟剿讹拷锟斤拷(锟斤拷锟斤拷锟狡凤拷)锟斤拷锟接达拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟叫撅拷锟斤拷系锟斤拷模锟斤拷锟斤拷锟叫�
OS/Compiler锟侥ｏ拷锟斤拷锟角讹拷锟斤拷锟斤拷锟斤拷锟皆的ｏ拷锟斤拷锟节讹拷锟节伙拷努锟斤拷锟斤拷为锟斤拷锟侥筹拷锟斤拷员锟结供一锟斤拷锟斤拷锟斤拷锟斤拷使锟矫的诧拷锟叫憋拷锟侥ｏ拷停锟絀ntel锟解几锟疥不也锟节革拷锟斤拷锟斤拷
训么锟斤拷锟解都锟角猴拷锟斤拷锟襟，碉拷锟角ｏ拷锟斤拷锟斤拷锟斤拷锟饺拷锟斤拷斜锟斤拷时锟斤拷锟斤拷锟洁当锟斤拷锟斤拷路要锟竭★拷锟斤拷锟斤拷锟絀T锟斤拷锟斤拷锟斤拷锟斤拷锟介单锟斤拷锟斤拷锟斤拷锟斤拷胁锟斤拷斜锟教碉拷锟介籍锟斤拷锟角革拷锟杰好碉拷写锟秸★拷</p>
<ol>
<li>锟斤拷锟斤拷
锟斤拷锟斤拷锟斤拷锟斤拷锟铰ｏ拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷么锟街阶讹拷锟斤拷锟斤拷锟斤拷锟矫的ｏ拷锟斤拷锟揭猴拷锟矫的诧拷锟叫憋拷坦锟斤拷锟斤拷卸锟斤拷锟斤拷兀锟斤拷锟接拷锟揭诧拷锟戒）锟斤拷</li>
</ol>
<p>(1) IDE: Intel Parallel Studio锟斤拷微锟斤拷锟斤拷锟较筹拷锟斤拷锟斤拷VS2010锟斤拷一锟斤拷锟斤拷Sun锟斤拷Sun
Studio(锟斤拷知锟斤拷锟斤拷锟轿达拷锟斤拷锟�
锟轿ｏ拷锟斤拷锟斤拷锟斤拷锟斤拷锟酵猴拷小锟斤拷)锟斤拷Nvidia锟斤拷CUDA平台什么锟侥撅拷锟饺诧拷锟斤拷锟斤拷
(2) Compiler: Intel锟斤拷ICC(锟斤拷锟皆讹拷锟斤拷锟叫伙拷一些锟斤拷锟斤拷)锟斤拷Nema Labs锟斤拷FASThread(锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟侥斤拷锟斤拷锟斤拷锟斤拷锟斤拷芸锟斤拷锟�
锟缴匡拷锟斤拷指锟斤拷锟斤拷锟斤拷员实施锟斤拷锟叫伙拷)
(3) Performance Tuning: Intel Vtune Analyzer(锟桔猴拷锟斤拷锟杰凤拷锟斤拷)锟斤拷Thread
profiler锟斤拷
Acumem锟斤拷Thread Spotter(锟斤拷远锟斤拷Cache锟斤拷锟斤拷锟杰凤拷锟斤拷锟斤拷锟脚伙拷)
(4) Debugging: Petra锟斤拷Jinx</p>
<p>锟斤拷锟斤拷锟斤拷锟揭革拷锟剿撅拷锟斤拷锟斤拷锟角对筹拷锟斤拷员锟斤拷说确实锟斤拷锟矫ｏ拷锟斤拷锟斤拷前锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷要锟斤拷锟矫★拷锟斤拷锟斤拷实锟街革拷诙锟斤拷锟�&quot;锟斤拷锟斤拷&quot;锟叫很达拷锟较碉拷恕锟�</p>
<ol>
<li><p>锟斤拷锟节核的恐撅拷
锟斤拷锟斤拷锟斤拷锟角匡拷锟斤拷4锟斤拷锟窖撅拷锟角筹拷锟秸憋拷锟剿ｏ拷锟饺癸拷锟斤拷锟角可撅拷锟斤拷8锟剿ｏ拷16锟剿ｏ拷32锟斤拷锟剿★拷锟斤拷锟斤拷确锟斤拷锟斤拷拇锟斤拷锟斤拷诤锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷泻芎玫锟斤拷锟斤拷埽锟斤拷芎玫目锟斤拷锟斤拷锟斤拷裕锟斤拷锟�
锟斤拷锟斤拷歉锟斤拷锟斤拷狻ｏ拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷芯锟斤拷锟斤拷嵌锟斤拷叱坛锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟杰凤拷锟斤拷锟斤拷目锟侥撅拷锟斤拷为锟剿帮拷锟斤拷锟斤拷锟皆憋拷锟矫的斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟缴碉拷锟斤拷锟斤拷瓶锟斤拷锟斤拷实锟斤拷锟较ｏ拷为锟剿得碉拷锟杰好碉拷
锟斤拷锟斤拷锟斤拷锟皆ｏ拷锟斤拷锟斤拷员锟斤拷要锟斤拷锟斤拷锟斤拷要使锟矫诧拷锟斤拷锟窖好碉拷锟斤拷萁峁�(锟斤拷锟斤拷concurrent hash
map)锟斤拷使锟斤拷细锟斤拷锟饺碉拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟教ｏ拷锟斤拷锟絛ata
parallel锟斤拷锟姐法锟斤拷锟斤拷锟杰碉拷锟斤拷(锟斤拷锟斤拷锟斤拷偷锟絝alse sharing锟斤拷锟斤拷)锟饺等等等ｏ拷锟斤拷锟斤拷锟斤拷每一锟筋都锟角诧拷小锟斤拷锟斤拷战锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷一篇锟斤拷锟铰讹拷锟斤拷锟�
锟斤拷锟竭程筹拷锟斤拷锟结供锟斤拷一些锟斤拷锟矫的斤拷锟介。</p>
</li>
<li><p>锟斤拷维锟斤拷锟斤拷
锟斤拷锟斤拷锟斤拷锟绞ｏ拷锟斤拷锟斤拷希锟斤拷锟叫达拷锟斤拷锟杰癸拷锟斤拷锟街达拷锟絩untime系统锟斤拷build系统锟皆硷拷锟斤拷锟斤拷锟斤拷锟叫达拷锟斤拷一锟斤拷锟斤拷确锟侥癸拷锟斤拷锟斤拷锟斤拷锟角革拷希锟斤拷锟斤拷些锟斤拷锟叫达拷锟斤拷锟斤拷锟斤拷锟斤拷狻拷锟斤拷锟轿�
锟斤拷锟斤拷锟斤拷锟叫较筹拷锟斤拷锟斤拷锟斤拷锟斤拷锟节★拷锟斤拷锟斤拷锟街阶讹拷锟斤拷锟斤拷锟斤拷锟秸诧拷锟叫憋拷痰某锟斤拷锟皆憋拷锟街拷锟斤拷伲锟斤拷锟斤拷也锟斤拷斜锟斤拷锟斤拷锟斤拷锟斤拷么锟斤拷锟窖ｏ拷锟斤拷锟斤拷锟斤拷锟斤拷锟叫╋拷锟斤拷写锟斤拷锟街伙拷锟斤拷锟揭恍┬⌒★拷母亩锟斤拷锟斤拷锟斤拷锌锟�
锟杰碉拷锟斤拷锟铰碉拷bug锟斤拷锟铰碉拷锟斤拷锟斤拷瓶锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟揭伙拷锟斤拷浅锟酵达拷锟斤拷锟斤拷锟介。</p>
</li>
</ol>
</blockquote>
</blockquote>
<p>&gt;</p>
<blockquote>
<blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE
ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>--
Tinyfool锟侥匡拷锟斤拷锟秸硷拷<a href="http://www.tinydust.net/dev/" target="_blank"><a href="http://www.tinydust.net/dev/">http://www.tinydust.net/dev/</a></a>
锟斤拷锟斤拷锟叫癸拷锟斤拷<a href="http://www.codechina.org/" target="_blank"><a href="http://www.codechina.org">http://www.codechina.org</a></a>
myTwitter:<a href="http://twitter.com/tinyfool" target="_blank"><a href="http://twitter.com/tinyfool">http://twitter.com/tinyfool</a></a></p>
</blockquote>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>To unsubscribe from this group, send email to
pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
<p><a href="">显示删减掉的内容</a>
<img src="" alt=""> Lai Jiangshan <img src="" alt=""></p>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>由于内存/cache模型和编译器/cpu的优化, 并行化是不可能通过库来实现的.
我认为最大的障碍是支持并行化的语言.
2010/3/22 Guancheng Chen <a href="&#x6d;&#x61;&#105;&#108;&#x74;&#x6f;&#58;&#x5b;&#x63;&#104;&#x65;&#110;&#x67;&#117;&#x2e;&#46;&#46;&#x40;&#103;&#109;&#x61;&#105;&#x6c;&#46;&#99;&#111;&#x6d;&#x5d;&#40;&#x29;">&#x5b;&#x63;&#104;&#x65;&#110;&#x67;&#117;&#x2e;&#46;&#46;&#x40;&#103;&#109;&#x61;&#105;&#x6c;&#46;&#99;&#111;&#x6d;&#x5d;&#40;&#x29;</a></p>
<ol>
<li>C语言可以使用pthread等库实现并行化，C++ JAVA等已经会即将支持多线程 所以语言能实现并行化 只是难易问题</li>
<li>是指Shared memory模型，多核共享一条内存总线所以造成带宽问题么？这确实是个问题，不过我感觉硬件商家会负责为你带来越来越多的带
宽，而程序员的任务只是合理的利用好这些给定的带宽</li>
<li>能具体说说哪些误导宣传么？
On 3月22日, 上午1时46分, 陨落雕 <a href="&#x6d;&#x61;&#105;&#108;&#116;&#111;&#58;&#91;&#103;&#x65;&#x6f;&#x2e;&#46;&#46;&#x2e;&#64;&#x67;&#109;&#x61;&#x69;&#x6c;&#46;&#99;&#111;&#109;&#x5d;&#x28;&#41;">&#91;&#103;&#x65;&#x6f;&#x2e;&#46;&#46;&#x2e;&#64;&#x67;&#109;&#x61;&#x69;&#x6c;&#46;&#99;&#111;&#109;&#x5d;&#x28;&#41;</a> wrote:<blockquote>
<p>呃，我想的障碍是: 1. 类C语言的统治地位; 2. 内存带宽不够; 3. 误导性宣传;</p>
</blockquote>
</li>
</ol>
<p>&gt;</p>
<blockquote>
<p>On Mar 21, 7:37 pm, Guancheng Chen <a href="&#x6d;&#x61;&#105;&#x6c;&#x74;&#x6f;&#58;&#x5b;&#99;&#x68;&#x65;&#x6e;&#103;&#x75;&#x61;&#110;&#99;&#x68;&#x2e;&#46;&#46;&#64;&#103;&#x6d;&#97;&#x69;&#108;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#x29;">&#x5b;&#99;&#x68;&#x65;&#x6e;&#103;&#x75;&#x61;&#110;&#99;&#x68;&#x2e;&#46;&#46;&#64;&#103;&#x6d;&#97;&#x69;&#108;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看<a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..</p>
</blockquote>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<blockquote>
<blockquote>
<p>)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a></p>
</li>
</ol>
</blockquote>
</blockquote>
<p><img src="" alt=""> Jeffrey Zhao <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>能详细说说为什么“由于内存/cache模型和编译器/cpu的优化, 并行化是不可能通过库来实现的”吗？</p>
<p>Jeffrey Zhao
Blog: <a href="http://www.cnblogs.com/JeffreyZhao/" title="http://www.cnblogs.com/JeffreyZhao/
CTRL + Click to follow link"><a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter: @jeffz_cn
<strong>From:</strong> <a href="&quot;mailto:eag0628@gmail.com
CTRL + Click to follow link&quot;">Lai Jiangshan</a></p>
<p><strong>Sent:</strong> Monday, March 22, 2010 10:17 PM
<strong>To:</strong> <a href="&quot;mailto:pongba@googlegroups.com
CTRL + Click to follow link&quot;">pon...@googlegroups.com</a></p>
<p><strong>Subject:</strong> Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>由于内存/cache模型和编译器/cpu的优化, 并行化是不可能通过库来实现的.
我认为最大的障碍是支持并行化的语言.
2010/3/22 Guancheng Chen <a href="&#x6d;&#x61;&#105;&#x6c;&#x74;&#111;&#58;&#x5b;&#99;&#104;&#x65;&#x6e;&#x67;&#117;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#109;&#x61;&#105;&#x6c;&#46;&#99;&#111;&#x6d;&#x5d;&#x28;&#x29;">&#x5b;&#99;&#104;&#x65;&#x6e;&#x67;&#117;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#109;&#x61;&#105;&#x6c;&#46;&#99;&#111;&#x6d;&#x5d;&#x28;&#x29;</a></p>
<ol>
<li>C语言可以使用pthread等库实现并行化，C++ JAVA等已经会即将支持多线程 所以语言能实现并行化 只是难易问题</li>
<li>是指Shared memory模型，多核共享一条内存总线所以造成带宽问题么？这确实是个问题，不过我感觉硬件商家会负责为你带来越来越多的带
宽，而程序员的任务只是合理的利用好这些给定的带宽</li>
<li>能具体说说哪些误导宣传么？
On 3月22日, 上午1时46分, 陨落雕 <a href="&#109;&#x61;&#x69;&#108;&#x74;&#111;&#x3a;&#91;&#103;&#x65;&#111;&#x2e;&#46;&#46;&#46;&#x40;&#x67;&#109;&#x61;&#105;&#x6c;&#46;&#99;&#x6f;&#x6d;&#x5d;&#40;&#x29;">&#91;&#103;&#x65;&#111;&#x2e;&#46;&#46;&#46;&#x40;&#x67;&#109;&#x61;&#105;&#x6c;&#46;&#99;&#x6f;&#x6d;&#x5d;&#40;&#x29;</a> wrote:<blockquote>
<p>呃，我想的障碍是: 1. 类C语言的统治地位; 2. 内存带宽不够; 3. 误导性宣传;</p>
<p>On Mar 21, 7:37 pm, Guancheng Chen <a href="&#x6d;&#x61;&#x69;&#x6c;&#116;&#x6f;&#x3a;&#x5b;&#x63;&#x68;&#x65;&#x6e;&#x67;&#x75;&#x61;&#x6e;&#99;&#x68;&#x2e;&#x2e;&#46;&#x40;&#103;&#109;&#97;&#105;&#108;&#x2e;&#x63;&#111;&#x6d;&#93;&#x28;&#41;">&#x5b;&#x63;&#x68;&#x65;&#x6e;&#x67;&#x75;&#x61;&#x6e;&#99;&#x68;&#x2e;&#x2e;&#46;&#x40;&#103;&#109;&#97;&#105;&#108;&#x2e;&#x63;&#111;&#x6d;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看<a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
</li>
</ol>
</blockquote>
</blockquote>
</li>
</ol>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>您值得是那篇著名的“Threads Cannot be Implemented as a Library”吧？恩，好用的并行语言确实关键，虽然
C++0x和Java都会加入memory model，但是要程序员来手动负责这些事情确实还是挺约束生产力的。</p>
<p>On 3月22日, 下午3时17分, Lai Jiangshan <a href="&#x6d;&#97;&#x69;&#x6c;&#x74;&#x6f;&#x3a;&#91;&#x65;&#97;&#103;&#x30;&#x2e;&#46;&#46;&#x40;&#x67;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#93;&#x28;&#x29;">&#91;&#x65;&#97;&#103;&#x30;&#x2e;&#46;&#46;&#x40;&#x67;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>由于内存/cache模型和编译器/cpu的优化, 并行化是不可能通过库来实现的.</p>
<p>我认为最大的障碍是支持并行化的语言.</p>
<p>2010/3/22 Guancheng Chen <a href="&#109;&#x61;&#105;&#x6c;&#116;&#111;&#58;&#91;&#99;&#104;&#101;&#110;&#x67;&#x75;&#97;&#110;&#99;&#104;&#x2e;&#x2e;&#46;&#64;&#x67;&#109;&#x61;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#40;&#41;">&#91;&#99;&#104;&#101;&#110;&#x67;&#x75;&#97;&#110;&#99;&#104;&#x2e;&#x2e;&#46;&#64;&#x67;&#109;&#x61;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#40;&#41;</a></p>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>&gt;
&gt;
&gt;</p>
<blockquote>
<blockquote>
<ol>
<li>C语言可以使用pthread等库实现并行化，C++ JAVA等已经会即将支持多线程 所以语言能实现并行化 只是难易问题</li>
<li>是指Shared memory模型，多核共享一条内存总线所以造成带宽问题么？这确实是个问题，不过我感觉硬件商家会负责为你带来越来越多的带
宽，而程序员的任务只是合理的利用好这些给定的带宽</li>
<li>能具体说说哪些误导宣传么？</li>
</ol>
<p>On 3月22日, 上午1时46分, 陨落雕 <a href="&#109;&#x61;&#105;&#x6c;&#x74;&#111;&#x3a;&#91;&#x67;&#101;&#x6f;&#x2e;&#46;&#x2e;&#x2e;&#x40;&#103;&#109;&#x61;&#x69;&#108;&#46;&#x63;&#x6f;&#109;&#x5d;&#x28;&#41;">&#91;&#x67;&#101;&#x6f;&#x2e;&#46;&#x2e;&#x2e;&#x40;&#103;&#109;&#x61;&#x69;&#108;&#46;&#x63;&#x6f;&#109;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>呃，我想的障碍是: 1. 类C语言的统治地位; 2. 内存带宽不够; 3. 误导性宣传;</p>
<p>On Mar 21, 7:37 pm, Guancheng Chen <a href="&#109;&#97;&#105;&#x6c;&#116;&#x6f;&#x3a;&#x5b;&#99;&#x68;&#x65;&#110;&#103;&#117;&#x61;&#110;&#99;&#104;&#46;&#46;&#46;&#x40;&#103;&#109;&#97;&#105;&#108;&#46;&#x63;&#111;&#109;&#93;&#x28;&#41;">&#x5b;&#99;&#x68;&#x65;&#110;&#103;&#117;&#x61;&#110;&#99;&#104;&#46;&#46;&#46;&#x40;&#103;&#109;&#97;&#105;&#108;&#46;&#x63;&#111;&#109;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看
<a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线</p>
</blockquote>
</blockquote>
<p>程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。</p>
<blockquote>
<blockquote>
<p>尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。</p>
</li>
</ol>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
<a href="">显示删减掉的内容</a></p>
</blockquote>
</blockquote>
<p><img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>主要就是那篇《Threads Cannot be Implemented as a Library》的论文，跟我以前发帖说的
Sequential Consistency，memory model有关</p>
<p>On 3月22日, 下午3时38分, &quot;Jeffrey Zhao&quot; <a href="&#x6d;&#97;&#105;&#108;&#x74;&#x6f;&#58;&#91;&#106;&#x65;&#x2e;&#46;&#46;&#64;&#x6c;&#x69;&#x76;&#x65;&#46;&#x63;&#111;&#x6d;&#x5d;&#x28;&#x29;">&#91;&#106;&#x65;&#x2e;&#46;&#46;&#64;&#x6c;&#x69;&#x76;&#x65;&#46;&#x63;&#111;&#x6d;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>能详细说说为什么&quot;由于内存/cache模型和编译器/cpu的优化, 并行化是不可能通过库来实现的&quot;吗？</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter: @jeffz_cn</p>
<p>From: Lai Jiangshan
Sent: Monday, March 22, 2010 10:17 PM
To: <a href="">pon...@googlegroups.com</a>
Subject: Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>由于内存/cache模型和编译器/cpu的优化, 并行化是不可能通过库来实现的.</p>
<p>我认为最大的障碍是支持并行化的语言.</p>
<p>2010/3/22 Guancheng Chen <a href="&#x6d;&#97;&#x69;&#108;&#x74;&#111;&#x3a;&#x5b;&#x63;&#x68;&#x65;&#110;&#x67;&#117;&#97;&#110;&#99;&#x68;&#46;&#x2e;&#x2e;&#64;&#x67;&#109;&#x61;&#105;&#108;&#46;&#x63;&#x6f;&#109;&#x5d;&#x28;&#x29;">&#x5b;&#x63;&#x68;&#x65;&#110;&#x67;&#117;&#97;&#110;&#99;&#x68;&#46;&#x2e;&#x2e;&#64;&#x67;&#109;&#x61;&#105;&#108;&#46;&#x63;&#x6f;&#109;&#x5d;&#x28;&#x29;</a></p>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>&gt;</p>
<blockquote>
<ol>
<li>C语言可以使用pthread等库实现并行化，C++ JAVA等已经会即将支持多线程 所以语言能实现并行化 只是难易问题</li>
<li>是指Shared memory模型，多核共享一条内存总线所以造成带宽问题么？这确实是个问题，不过我感觉硬件商家会负责为你带来越来越多的带
宽，而程序员的任务只是合理的利用好这些给定的带宽</li>
<li><p>能具体说说哪些误导宣传么？</p>
<p>On 3月22日, 上午1时46分, 陨落雕 <a href="&#x6d;&#97;&#x69;&#108;&#116;&#x6f;&#58;&#x5b;&#x67;&#x65;&#x6f;&#46;&#46;&#46;&#46;&#x40;&#103;&#109;&#97;&#105;&#x6c;&#46;&#x63;&#111;&#x6d;&#x5d;&#x28;&#41;">&#x5b;&#x67;&#x65;&#x6f;&#46;&#46;&#46;&#46;&#x40;&#103;&#109;&#97;&#105;&#x6c;&#46;&#x63;&#111;&#x6d;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>呃，我想的障碍是: 1. 类C语言的统治地位; 2. 内存带宽不够; 3. 误导性宣传;</p>
<p>On Mar 21, 7:37 pm, Guancheng Chen <a href="&#109;&#97;&#x69;&#x6c;&#116;&#x6f;&#x3a;&#x5b;&#99;&#104;&#x65;&#110;&#103;&#x75;&#97;&#x6e;&#99;&#x68;&#x2e;&#x2e;&#46;&#x40;&#x67;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#x6d;&#93;&#x28;&#x29;">&#x5b;&#99;&#104;&#x65;&#110;&#103;&#x75;&#97;&#x6e;&#99;&#x68;&#x2e;&#x2e;&#46;&#x40;&#x67;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#x6d;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看<a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。</p>
</li>
</ol>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
</li>
</ol>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> Alleluia <img src="" alt=""></p>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>no no.其实Concurrency和Parallelism完全是两码事情,IO来区分它们其实完全是从最基本的体系结构上来说就是如此的.你把
IO理解为网络通信,磁盘读写就太狭隘了.
比如看这个图
<a href="http://ian--king.javaeye.com/upload/picture/pic/57449/40915ec8-f578-3398-9931-1afa4364a2b9.jpg" target="_blank"><a href="http://ian--king.javaeye.com/upload/picture/pic/57449/40915ec8-f578-3398-9931-1afa4364a2b9.jpg">http://ian--king.javaeye.com/upload/picture/pic/57449/40915ec8-f578-3398-9931-1afa4364a2b9.jpg</a></a>
,我们要计算一个ax^2+bx+c的一元二次方程,左边的是并行计算,右边的是顺序计算.这两者完全就是两个体系结构,我们现在所使用的计算机是右边
那个图是由Control Flow Drive的.左边是Data Flow Drive的是典型的并行计算机的结构.其中最大的区别就是,右边的架
构采用了PC指针和Assignment.Assignment本身不是一个计算过程,仅仅是一次IO操作,从存储器里拿出数据/程序灌入运算器或者相
反.那么Assignment跟Concurrency有什么关系呢?为了响应Assigment这种基础的IO,那么冯结构必须依靠CPU时钟来驱动
PC指针的移动.因此控制流驱动模式构成了CPU响应外界IO的最基本的模式.无论是内存还是磁盘或者网络,CPU要获取外部设备的IO最基本模式,只
能是通过本地时钟触发控制流，周期性发起状态查询.CPU在某个周期向其他设备发送信号，在收到远端设备的反馈信号后计算得出本地代码序列上的程序段地
址,然后移动PC指针指向该地址进行处理。无论是早期的轮询模式还是现在广泛采用的中断方式，其基本的IO模式并没有改变,只不过查询对象由最初的IO
设备演变为中断寄存器.
因此你可以看到,Concurrency其实只是在讨论如何能够利用外设信号与CPU时钟之间的差异,让CPU在一定的时钟周期内尽可能多的响应不同外
设信号。一个通常的程序仅仅只需要通过Assigment响应内存IO,而Concurrency程序需要相应成千上万个外部设备,这仅仅是量上的区别
并没有到任何质上的区别,Concurrency程序本质上仍然是一个顺序执行的程序而已.采用恰当的技术比如完成端口之类的,可以在单核CPU机器上
仅仅采用单线程模型就能得到极高的并发性.当然多核同时处理可以进一步提高并发量,但是这不是必须的.
换一句话说,目前的CPU架构本身就是一种具备了Concurrency能力的顺序型架构.甚至在当初冯诺伊曼设计这个架构的时候,就极力杜绝并行计算
的指令在这种机器上出现在程序里,因为他认为并行执行的指令会让人发疯.而你再看右边的计算机构,与冯结构完全不同.他的计算是彻底并行的,这就是所谓
的数据流驱动.虽然说冯结构本身不利于并行,但是这个体系发展到现在,已经在不同层面上用冯结构模拟数据流计算.往小里说,CPU上最典型的顺序型程序
在微指令层面上有很大一部分就是数据流驱动并行执行的,因为要做OOO.往大了说,并行在若干个独立内核上的线程组之间的互相通信,也是一种数据流驱
动.并行必定是数据流驱动的.这是两者本质上的不同.如果你去看GPU上的并行就更接近这个模型,所有的计算都是分成若干个stage,数据依次从
stage上流过,stage上的并行计算单元对数据进行高密度的并行计算.这就是所谓的流处理器.当然现在的流处理器还是非常的简单,未来的GPU会
像Dataflow machine的方向发展.当然DataFlow machine也有自己的问题，比如说的指令牌粒度太小了，这导致两个重要缺
点，一个是通信代价非常高，另一个是指令牌点火代价很高。而Standford的ImagineGPU流处理器引擎可以看作介于数据流机和指令流机之间
的架构，所作的一个重要权衡就是增加指令牌的粒度，从而减小点火代价和利用赠大的Token粒度去减小通信代价</p>
<p>至于粒度问题,关键是看你的计算资源有多少.比如说CPU目前最多8核,16核.那么你所谓的按照循环来进行并行自然是可行的,但是你放到CUDA上
去,GTX295有250个内核,你为了让他所有的内核处于工作繁忙的状态,就根本不可能按照循环层次来进行并行,在这个上面并行的粒度是需要划分的极
为纤细的。更诡异的是有些算法,处理的数据量很小,但是计算量可能极为庞大.比如一些运动估计算法,在一个16/*16的像素区域内要完成256×256
次sad运算.这种数据量和计算完全非常不成比例的.怎么对并行粒度的进行有效的划分,非常考算法功夫的.并行计算最好是通过算法杜绝锁,这也是非常困
难的地方.</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>On 3月22日, 下午7时04分, Guancheng Chen <a href="&#109;&#x61;&#105;&#x6c;&#116;&#x6f;&#58;&#x5b;&#x63;&#x68;&#101;&#x6e;&#103;&#x75;&#x61;&#x6e;&#99;&#104;&#46;&#46;&#x2e;&#x40;&#x67;&#109;&#x61;&#x69;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#40;&#41;">&#x5b;&#x63;&#x68;&#101;&#x6e;&#103;&#x75;&#x61;&#x6e;&#99;&#104;&#46;&#46;&#x2e;&#x40;&#x67;&#109;&#x61;&#x69;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>您的观点很有新意，我以前没有过用IO来区分Concurrency和Parallelism的想法，我猜测可能跟您的网络/通信背景有关。其实我觉得
从广义上来讲Parallelism和Concurrency是基本重合的两个概念，只不过可能Concurrency稍微偏工程一点，
Parallelism稍微偏研究一点。例如Herb Sutter要出的新书叫Effective Concurrency,而市面上其他讲并行计算
的书不少也使用Parallel相关的词汇。</p>
<p>另外您这句话我有些不赞同：&quot;颗粒度越小的并行获得的计算资源的利用率也就越大加速比就越大&quot;，拿一个计算密集型的嵌套循环举例，对比并行外层循环和并
行内层循环，无疑你在并行化外层循环时的性能加速比更好，而这时候你的并行度是粗粒度的(内循环并行相对来说是细粒度的)。当然，粗/细粒度的选择确实
是个tradeoff，拿锁竞争来说，细粒度的锁意味着更好的Scalability，但是你加锁/解锁的次数相比组粒度所来说增加了，而这种加锁/解
锁的操作是有开销的，所以需要在锁操作本身的开销和程序的Scalability中做一个平衡。</p>
<p>多谢指教！</p>
<p>On 3月22日, 上午10时19分, Alleluia <a href="&#x6d;&#x61;&#x69;&#x6c;&#116;&#111;&#58;&#x5b;&#97;&#108;&#108;&#x75;&#x6c;&#46;&#x2e;&#46;&#x40;&#103;&#x6d;&#x61;&#105;&#108;&#x2e;&#x63;&#111;&#x6d;&#93;&#x28;&#x29;">&#x5b;&#97;&#108;&#108;&#x75;&#x6c;&#46;&#x2e;&#46;&#x40;&#103;&#x6d;&#x61;&#105;&#108;&#x2e;&#x63;&#111;&#x6d;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>Concurrency 说到底纯粹就是一个IO问题.而IO问题本质上是和计算完全无关的事情,不存在能不能行可不可计算的问题.因此它相对来说非常
单纯。他更多的是一种类似时钟同步的问题,如果你把IO事件想像成一种时钟信号.其实时钟本来也就是一堆信号而已.如果你做过Circuit 的东西就
会明白,IO只是在不同的时序下进行数据采样.比如最简单的同步时钟,所有的时序电路公用一个时钟,把不同的电路安排在不同的时序边沿上触发.当然更复
杂异步逻辑的道理也是一样的.放到宏观的Concurrency的问题的实质并没有多大改变,只不过CPU依靠PC指针的移动把这种电路上的时序处理软
件化了.</p>
<p>而Parallelism更多的是需要考虑计算问题同时还要兼顾IO.Parallelism首先要回答的是一个东西是不是可并行的.回答完这个问题
后,如果可并行那么在什么样的硬件设备上并行是最合适的这样一个问题.在Parallelism中需要考虑的的IO也不仅仅是来自于网络更多是,缓存,
内存,磁盘,总线等等.其实我觉得,在Parallelism下你总是处于一个矛盾状态,颗粒度越小的并行获得的计算资源的利用率也就越大加速比就越
大,但是同时通信系统的工作也就越是繁忙整个运算过程浪费在通信消耗上的时间也就越多.
这个当中的tradeoff是非常困难的.很多时候速度不快,完全不是因为你的核心不够多,而是你的通信速度不够高.</p>
<p>On 3月22日, 下午3时21分, Guancheng Chen <a href="&#109;&#97;&#x69;&#108;&#x74;&#111;&#x3a;&#91;&#x63;&#x68;&#101;&#x6e;&#x67;&#117;&#97;&#x6e;&#99;&#x68;&#x2e;&#x2e;&#x2e;&#64;&#103;&#109;&#x61;&#105;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#93;&#40;&#41;">&#91;&#x63;&#x68;&#101;&#x6e;&#x67;&#117;&#97;&#x6e;&#99;&#x68;&#x2e;&#x2e;&#x2e;&#64;&#103;&#109;&#x61;&#105;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>绝大部分的观点Can&#39;t agree more.其实这也是为什么我引用了高老爷子那段话的原因，因为程序的本质就是数据结构和算法，你要没有非常适
合并行的算法那简直就是巧妇难为无米之炊。但是有疑问的一点是关于Parallelism和Concurrency这两个单词的区别，实际上这也是非常
有意思的一件事情，Sun的多线程指南上写的是： Parallelism is a condition that arises when at
least two threads are executing simultaneously, while concurrency is a
condition that exists when at least two threads are making progress.
Therefore concurrency is a more generalized form of parallelism that
can include time-slicing as a form of virtual parallelism.不知道您怎么看？</p>
<p>On 3月22日, 上午8时06分, Alleluia <a href="&#x6d;&#97;&#x69;&#x6c;&#x74;&#111;&#58;&#x5b;&#97;&#108;&#x6c;&#x75;&#x6c;&#x2e;&#x2e;&#46;&#x40;&#103;&#109;&#x61;&#105;&#x6c;&#x2e;&#x63;&#111;&#109;&#x5d;&#x28;&#41;">&#x5b;&#97;&#108;&#x6c;&#x75;&#x6c;&#x2e;&#x2e;&#46;&#x40;&#103;&#109;&#x61;&#105;&#x6c;&#x2e;&#x63;&#111;&#109;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>Parallelism 说到底是算法问题.Parallelism与Concurrency不同,Concurrency所面对的问题相对的单一可以
让一群有经验的专家来实现一套通用库或者语言来提供一个基本的编程框架.而在Parallelism上,具体的不同问题,其所需要并行的算法是根本不同
的.原因在于不同的问题,其内部的DataDependency的结构完全不同,不同的Data Dependency的结构,需要构造不同的算法.即
便是相同的Data Dependency,在不同的颗粒度下，在不同的硬件条件下所采用的算法也是完全不同的.因为一旦出现Data
Dependency也就意味着并行计算模块之间需要进行通信.从以计算节点为单位的分布式并行,到多核CPU上的Numa结构,到SIMD上的向量处
理器,其计算单元之间的通信手段,通信效率简直天差地别.比如说,在SMP上最常见的并行算法,work stealing也就是Intel的TBB,
是建立在两个条件下第一个是CPU的Cache机制上,这使得通常在内存的之间的数据搬运消耗非常小,第二个是SMP上计算单元相对的少,因此每个计算
单元被分配到的任务就相对的重。其开销远远大于通信的开销,因此这种机制在SMP上相对的划算.但是如果你要在GPU上做Work Stealing就
完全不可行,因为GPU的运算单元数量极多,被分配到的任务就相对来说的非常轻量,CUDA上的一个thread很多时候运算一次的时间不会超过
10us,而一次跨Block的线程之间的通信开销就往往要达到100us左右,再加上目前GPU上的Cache机制非常落后导致了需要频繁的通信开销
的Work Stealing在GPU上是非常不划算得.
所以我个人认为在硬件架构没有更多的突破之前,OpenCL这种东西是没有任何生命力的.不要说CPU的并行与GPU之间差异巨大,就是不同的GPU之
间AMD与Nvidia两个也是各自为政,一个平台上跑得非常快的东西,在另外一个平台极大的可能是龟速.其最终的结果估计就是跟Java的
write once run everywhere一样是个大笑话.</p>
<p>On 3月22日, 下午2时06分, Guancheng Chen <a href="&#x6d;&#97;&#105;&#x6c;&#x74;&#111;&#58;&#91;&#x63;&#104;&#101;&#x6e;&#x67;&#117;&#x61;&#110;&#99;&#x68;&#x2e;&#x2e;&#46;&#64;&#103;&#109;&#97;&#105;&#108;&#x2e;&#99;&#111;&#109;&#93;&#x28;&#41;">&#91;&#x63;&#104;&#101;&#x6e;&#x67;&#117;&#x61;&#110;&#99;&#x68;&#x2e;&#x2e;&#46;&#64;&#103;&#109;&#97;&#105;&#108;&#x2e;&#99;&#111;&#109;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>On 3月22日, 上午2时20分, Tinyfool <a href="&#x6d;&#97;&#x69;&#x6c;&#x74;&#111;&#58;&#x5b;&#x74;&#x69;&#110;&#121;&#x66;&#46;&#46;&#x2e;&#64;&#x67;&#109;&#x61;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#40;&#41;">&#x5b;&#x74;&#x69;&#110;&#121;&#x66;&#46;&#46;&#x2e;&#64;&#x67;&#109;&#x61;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#109;&#97;&#x69;&#x6c;&#x74;&#x6f;&#58;&#x5b;&#x6a;&#x65;&#x2e;&#46;&#46;&#64;&#x6c;&#105;&#118;&#x65;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#41;">&#x5b;&#x6a;&#x65;&#x2e;&#46;&#46;&#64;&#x6c;&#105;&#118;&#x65;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#41;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a></p>
<p>Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#109;&#x61;&#x69;&#x6c;&#116;&#x6f;&#58;&#91;&#99;&#104;&#101;&#x6e;&#x67;&#x75;&#97;&#110;&#x63;&#104;&#x2e;&#46;&#x2e;&#64;&#103;&#109;&#97;&#105;&#108;&#x2e;&#x63;&#111;&#109;&#93;&#40;&#x29;">&#91;&#99;&#104;&#101;&#x6e;&#x67;&#x75;&#97;&#110;&#x63;&#104;&#x2e;&#46;&#x2e;&#64;&#103;&#109;&#97;&#105;&#108;&#x2e;&#x63;&#111;&#109;&#93;&#40;&#x29;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#x6d;&#x61;&#105;&#108;&#116;&#x6f;&#58;&#91;&#112;&#111;&#x6e;&#46;&#46;&#x2e;&#64;&#x67;&#111;&#x6f;&#103;&#108;&#x65;&#x67;&#x72;&#111;&#117;&#x70;&#x73;&#46;&#x63;&#111;&#109;&#93;&#40;&#x29;">&#91;&#112;&#111;&#x6e;&#46;&#46;&#x2e;&#64;&#x67;&#111;&#x6f;&#103;&#108;&#x65;&#x67;&#x72;&#111;&#117;&#x70;&#x73;&#46;&#x63;&#111;&#109;&#93;&#40;&#x29;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>&gt;</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间</li>
</ol>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>...</p>
<p>阅读更多 &gt;&gt;
<a href="">显示删减掉的内容</a></p>
</blockquote>
<p><img src="" alt=""> Alleluia <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>且抛开,流处理器这种异构的内核,SMP和Numa之间的差异.就说说单个CPU上做SIMD并行化的需要考虑的内存/cache问题.
比如作矩阵乘法运算,如果矩阵都是按照行存储, 则在A/*B中, 乘法对B的访问是按列的. 假设B一行有N个元素, 那么在存储器中, 两个同列不同
行的元素所在的存储单元相差N. 对B的访问并不是局部化的. 因为访问不局部化, 所以每次乘法, 都需要从内存中调一个 cache 单元到
CPU. 这个极大的降低了处理器的执行速度. 因此, 矩阵乘法的优化的核心, 在于局部化B的访问. 反过来, 如果矩阵按照列存储, 则要局部化
对A的访问. 关于怎样局部化访问还能获得正确的乘法,那就要针对具体的情况设计正确的算法.
为何并行化不可能用库来实现呢?其实问题根源在于,并行颗粒度的变化,导致对IO,算法的乃至硬件结构产生天差地别的变化.一个顺序型的问题,可以划分
成不同的颗粒度.比如说一个100M的Byte型数组,要求和,你可以按照1M的颗粒度进行划分,也可以按照1K,甚至256，128，乃至
4byte,8byte进行划分.每种划分,产生的数据搬运的次数,每次数据搬运的大小,乃至缓存命中率都是不同。
再进一步说,颗粒度划分的越细,意味着计算单元就需要增加,否则就没有意义.但是一旦运算单元的增加到一个的极限,就会引起硬件结构的改变,比如说
SMP根本无法支撑超过16Core的架构,超过这个限度你就得换Nehalem那种Numa架构.在Numa结构下你就不得不考虑,本地内存和远端内
存的区别。
目前没有一个很好的方案来统一不同等级并行计算的架构,在8核之下你用Numa就是杀鸡用牛刀了,而超过32核Numa也不堪重负需要像GPU那样去设
计硬件架构这也就是为什么Intel的Larrebe会难产的原因.每个X86内核都要顶着一个硕大的Deocder还有branch
prediction,OOO之类的庞然大物,用PII来做Larrebe都非常的头大的事情.所以,我个人认为,并行化本身就是和硬件结构极为相关的
事情,这一切都不太可能由一个统一的计算库来完成统一的封装.</p>
<p>On 3月22日, 下午10时38分, &quot;Jeffrey Zhao&quot; <a href="&#109;&#x61;&#105;&#x6c;&#x74;&#x6f;&#58;&#91;&#106;&#x65;&#x2e;&#x2e;&#x2e;&#64;&#x6c;&#x69;&#118;&#x65;&#46;&#99;&#111;&#109;&#93;&#40;&#x29;">&#91;&#106;&#x65;&#x2e;&#x2e;&#x2e;&#64;&#x6c;&#x69;&#118;&#x65;&#46;&#99;&#111;&#109;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>能详细说说为什么&quot;由于内存/cache模型和编译器/cpu的优化, 并行化是不可能通过库来实现的&quot;吗？</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter: @jeffz_cn</p>
<p>From: Lai Jiangshan
Sent: Monday, March 22, 2010 10:17 PM
To: <a href="">pon...@googlegroups.com</a>
Subject: Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>由于内存/cache模型和编译器/cpu的优化, 并行化是不可能通过库来实现的.</p>
<p>我认为最大的障碍是支持并行化的语言.</p>
<p>2010/3/22 Guancheng Chen <a href="&#x6d;&#x61;&#x69;&#x6c;&#116;&#x6f;&#58;&#91;&#99;&#x68;&#101;&#x6e;&#103;&#117;&#x61;&#x6e;&#x63;&#104;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#109;&#x61;&#105;&#x6c;&#46;&#99;&#x6f;&#x6d;&#93;&#40;&#x29;">&#91;&#99;&#x68;&#101;&#x6e;&#103;&#117;&#x61;&#x6e;&#x63;&#104;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#109;&#x61;&#105;&#x6c;&#46;&#99;&#x6f;&#x6d;&#93;&#40;&#x29;</a></p>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>&gt;</p>
<blockquote>
<ol>
<li>C语言可以使用pthread等库实现并行化，C++ JAVA等已经会即将支持多线程 所以语言能实现并行化 只是难易问题</li>
<li>是指Shared memory模型，多核共享一条内存总线所以造成带宽问题么？这确实是个问题，不过我感觉硬件商家会负责为你带来越来越多的带
宽，而程序员的任务只是合理的利用好这些给定的带宽</li>
<li><p>能具体说说哪些误导宣传么？</p>
<p>On 3月22日, 上午1时46分, 陨落雕 <a href="&#x6d;&#97;&#x69;&#x6c;&#116;&#x6f;&#58;&#91;&#103;&#101;&#x6f;&#x2e;&#46;&#x2e;&#x2e;&#64;&#103;&#109;&#97;&#x69;&#108;&#46;&#99;&#111;&#109;&#x5d;&#40;&#x29;">&#91;&#103;&#101;&#x6f;&#x2e;&#46;&#x2e;&#x2e;&#64;&#103;&#109;&#97;&#x69;&#108;&#46;&#99;&#111;&#109;&#x5d;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>呃，我想的障碍是: 1. 类C语言的统治地位; 2. 内存带宽不够; 3. 误导性宣传;</p>
<p>On Mar 21, 7:37 pm, Guancheng Chen <a href="&#109;&#x61;&#x69;&#x6c;&#116;&#111;&#x3a;&#91;&#x63;&#104;&#101;&#x6e;&#103;&#117;&#97;&#x6e;&#99;&#x68;&#46;&#x2e;&#46;&#x40;&#x67;&#109;&#x61;&#105;&#108;&#46;&#x63;&#111;&#109;&#93;&#40;&#x29;">&#91;&#x63;&#104;&#101;&#x6e;&#103;&#117;&#97;&#x6e;&#99;&#x68;&#46;&#x2e;&#46;&#x40;&#x67;&#109;&#x61;&#105;&#108;&#46;&#x63;&#111;&#109;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看<a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。</p>
</li>
</ol>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
</li>
</ol>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> 郑伟 <img src="" alt=""></p>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>我对这个比较感兴趣，能详细介绍一下golang在多核下的表现吗？</p>
<p>2010/3/22 Googol Lee <a href="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#x6f;&#x3a;&#91;&#x67;&#111;&#x6f;&#x67;&#x2e;&#46;&#46;&#x40;&#x67;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#x28;&#41;">&#91;&#x67;&#111;&#x6f;&#x67;&#x2e;&#46;&#46;&#x40;&#x67;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#x28;&#41;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>彻底来晚了......我是来广告golang的！大并发IO还是csp模型的语言更靠谱！
不过golang在cpu密集的并发上不知道效果会怎么样，就现在的表现来看比erlang好，但还赶不上c/c++
On Mar 22, 9:20 am, Tinyfool <a href="&#109;&#97;&#105;&#x6c;&#116;&#x6f;&#x3a;&#91;&#116;&#x69;&#110;&#121;&#102;&#x2e;&#46;&#x2e;&#x40;&#103;&#x6d;&#x61;&#105;&#108;&#46;&#x63;&#111;&#x6d;&#93;&#x28;&#x29;">&#91;&#116;&#x69;&#110;&#121;&#102;&#x2e;&#46;&#x2e;&#x40;&#103;&#x6d;&#x61;&#105;&#108;&#46;&#x63;&#111;&#x6d;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#109;&#97;&#x69;&#108;&#116;&#111;&#58;&#91;&#106;&#101;&#46;&#x2e;&#46;&#64;&#108;&#x69;&#x76;&#101;&#46;&#x63;&#x6f;&#109;&#x5d;&#40;&#x29;">&#91;&#106;&#101;&#46;&#x2e;&#46;&#64;&#108;&#x69;&#x76;&#101;&#46;&#x63;&#x6f;&#109;&#x5d;&#40;&#x29;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#109;&#97;&#x69;&#x6c;&#116;&#111;&#x3a;&#x5b;&#x63;&#x68;&#101;&#110;&#103;&#x75;&#x61;&#110;&#99;&#104;&#46;&#x2e;&#46;&#x40;&#103;&#109;&#97;&#x69;&#108;&#46;&#x63;&#111;&#109;&#93;&#40;&#x29;">&#x5b;&#x63;&#x68;&#101;&#110;&#103;&#x75;&#x61;&#110;&#99;&#104;&#46;&#x2e;&#46;&#x40;&#103;&#109;&#97;&#x69;&#108;&#46;&#x63;&#111;&#109;&#93;&#40;&#x29;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#x6d;&#x61;&#x69;&#x6c;&#116;&#x6f;&#58;&#91;&#x70;&#111;&#110;&#x2e;&#46;&#x2e;&#x40;&#103;&#x6f;&#x6f;&#x67;&#x6c;&#x65;&#x67;&#114;&#x6f;&#117;&#x70;&#x73;&#x2e;&#x63;&#111;&#109;&#93;&#40;&#41;">&#91;&#x70;&#111;&#110;&#x2e;&#46;&#x2e;&#x40;&#103;&#x6f;&#x6f;&#x67;&#x6c;&#x65;&#x67;&#114;&#x6f;&#117;&#x70;&#x73;&#x2e;&#x63;&#111;&#109;&#93;&#40;&#41;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。</p>
</li>
</ol>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>--</p>
<p>Tinyfool的开发日记<a href="http://www.tinydust.net/dev/" target="_blank"><a href="http://www.tinydust.net/dev/">http://www.tinydust.net/dev/</a></a>
代码中国网<a href="http://www.codechina.org/" target="_blank"><a href="http://www.codechina.org">http://www.codechina.org</a></a></p>
<p>myTwitter:<a href="http://twitter.com/tinyfool" target="_blank"><a href="http://twitter.com/tinyfool">http://twitter.com/tinyfool</a></a>
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a></p>
</blockquote>
<p><img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-23</p>
<p>其他收件人：</p>
<p>您说的可能跟那个问题不是一回事情，窃以为Lai Jiangshan所说的是指CPU和编译器会对并行程序做违反程序semantics的优化（例如
reordering），导致破坏Memory Consistency，例如大牛HJ Boehm的一篇论文《Threads Cannot be
Implemented as a Library》，我之前也写过一篇浅显小文：<a href="http://www.parallellabs.com/2010/03/06/why-should-programmer-care-about-sequential-consistency-rather-than-cache-coherence/" target="_blank"><a href="http://www.parallellabs.com/">http://www.parallellabs.com/</a>
2010/03/06/why-should-programmer-care-about-sequential-consistency-
rather-than-cache-coherence/</a></p>
<p>另外对于您的Concurrency和Parallelism的看法，我大致理解了您所指的&quot;Concurrency&quot;的含义，它跟我所认为的软件层面
的Concurrency不太一样，您的含义更宏观一些，但是感觉我还没有抓住它的精要，不知道能否推荐几篇文献供我参考？</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>On 3月22日, 下午4时35分, Alleluia <a href="&#109;&#x61;&#x69;&#x6c;&#116;&#111;&#58;&#91;&#97;&#x6c;&#108;&#x75;&#108;&#46;&#46;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#111;&#109;&#93;&#x28;&#x29;">&#91;&#97;&#x6c;&#108;&#x75;&#108;&#46;&#46;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#111;&#109;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>且抛开,流处理器这种异构的内核,SMP和Numa之间的差异.就说说单个CPU上做SIMD并行化的需要考虑的内存/cache问题.
比如作矩阵乘法运算,如果矩阵都是按照行存储, 则在A/*B中, 乘法对B的访问是按列的. 假设B一行有N个元素, 那么在存储器中, 两个同列不同
行的元素所在的存储单元相差N. 对B的访问并不是局部化的. 因为访问不局部化, 所以每次乘法, 都需要从内存中调一个 cache 单元到
CPU. 这个极大的降低了处理器的执行速度. 因此, 矩阵乘法的优化的核心, 在于局部化B的访问. 反过来, 如果矩阵按照列存储, 则要局部化
对A的访问. 关于怎样局部化访问还能获得正确的乘法,那就要针对具体的情况设计正确的算法.
为何并行化不可能用库来实现呢?其实问题根源在于,并行颗粒度的变化,导致对IO,算法的乃至硬件结构产生天差地别的变化.一个顺序型的问题,可以划分
成不同的颗粒度.比如说一个100M的Byte型数组,要求和,你可以按照1M的颗粒度进行划分,也可以按照1K,甚至256，128，乃至
4byte,8byte进行划分.每种划分,产生的数据搬运的次数,每次数据搬运的大小,乃至缓存命中率都是不同。
再进一步说,颗粒度划分的越细,意味着计算单元就需要增加,否则就没有意义.但是一旦运算单元的增加到一个的极限,就会引起硬件结构的改变,比如说
SMP根本无法支撑超过16Core的架构,超过这个限度你就得换Nehalem那种Numa架构.在Numa结构下你就不得不考虑,本地内存和远端内
存的区别。
目前没有一个很好的方案来统一不同等级并行计算的架构,在8核之下你用Numa就是杀鸡用牛刀了,而超过32核Numa也不堪重负需要像GPU那样去设
计硬件架构这也就是为什么Intel的Larrebe会难产的原因.每个X86内核都要顶着一个硕大的Deocder还有branch
prediction,OOO之类的庞然大物,用PII来做Larrebe都非常的头大的事情.所以,我个人认为,并行化本身就是和硬件结构极为相关的
事情,这一切都不太可能由一个统一的计算库来完成统一的封装.</p>
<p>On 3月22日, 下午10时38分, &quot;Jeffrey Zhao&quot; <a href="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#111;&#58;&#91;&#106;&#x65;&#x2e;&#46;&#x2e;&#x40;&#108;&#105;&#118;&#101;&#46;&#x63;&#111;&#x6d;&#x5d;&#x28;&#x29;">&#91;&#106;&#x65;&#x2e;&#46;&#x2e;&#x40;&#108;&#105;&#118;&#101;&#46;&#x63;&#111;&#x6d;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>能详细说说为什么&quot;由于内存/cache模型和编译器/cpu的优化, 并行化是不可能通过库来实现的&quot;吗？</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter: @jeffz_cn</p>
<p>From: Lai Jiangshan
Sent: Monday, March 22, 2010 10:17 PM
To: <a href="">pon...@googlegroups.com</a>
Subject: Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>由于内存/cache模型和编译器/cpu的优化, 并行化是不可能通过库来实现的.</p>
<p>我认为最大的障碍是支持并行化的语言.</p>
<p>2010/3/22 Guancheng Chen <a href="&#x6d;&#x61;&#105;&#108;&#116;&#111;&#x3a;&#x5b;&#x63;&#104;&#x65;&#110;&#x67;&#117;&#97;&#x6e;&#99;&#104;&#46;&#x2e;&#46;&#x40;&#x67;&#109;&#x61;&#x69;&#108;&#x2e;&#99;&#111;&#x6d;&#93;&#40;&#x29;">&#x5b;&#x63;&#104;&#x65;&#110;&#x67;&#117;&#97;&#x6e;&#99;&#104;&#46;&#x2e;&#46;&#x40;&#x67;&#109;&#x61;&#x69;&#108;&#x2e;&#99;&#111;&#x6d;&#93;&#40;&#x29;</a></p>
<ol>
<li>C语言可以使用pthread等库实现并行化，C++ JAVA等已经会即将支持多线程 所以语言能实现并行化 只是难易问题</li>
<li>是指Shared memory模型，多核共享一条内存总线所以造成带宽问题么？这确实是个问题，不过我感觉硬件商家会负责为你带来越来越多的带
宽，而程序员的任务只是合理的利用好这些给定的带宽</li>
<li><p>能具体说说哪些误导宣传么？</p>
<p>On 3月22日, 上午1时46分, 陨落雕 <a href="&#109;&#x61;&#105;&#108;&#x74;&#111;&#58;&#x5b;&#103;&#x65;&#111;&#46;&#46;&#x2e;&#46;&#x40;&#x67;&#x6d;&#x61;&#x69;&#108;&#46;&#x63;&#x6f;&#109;&#x5d;&#x28;&#41;">&#x5b;&#103;&#x65;&#111;&#46;&#46;&#x2e;&#46;&#x40;&#x67;&#x6d;&#x61;&#x69;&#108;&#46;&#x63;&#x6f;&#109;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>呃，我想的障碍是: 1. 类C语言的统治地位; 2. 内存带宽不够; 3. 误导性宣传;</p>
<p>On Mar 21, 7:37 pm, Guancheng Chen <a href="&#x6d;&#97;&#105;&#x6c;&#x74;&#x6f;&#x3a;&#x5b;&#x63;&#104;&#101;&#x6e;&#103;&#117;&#x61;&#x6e;&#99;&#x68;&#46;&#46;&#x2e;&#x40;&#103;&#109;&#97;&#105;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#x28;&#x29;">&#x5b;&#x63;&#104;&#101;&#x6e;&#103;&#117;&#x61;&#x6e;&#99;&#x68;&#46;&#46;&#x2e;&#x40;&#103;&#109;&#97;&#105;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看<a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx...</p>
</blockquote>
</blockquote>
</li>
</ol>
</blockquote>
<p>阅读更多 &gt;&gt;
<a href="">显示删减掉的内容</a>
<img src="" alt=""> windstorm <img src="" alt=""></p>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-23</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>实在是不能同意你更多......很早很早以前我就在这里和人争论过，GPU的并行计算平台不可能一统天下的。CUDA也不是救世主。OpenCL更不是。</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p><a href="http://www.kunli.info/" target="_blank">www.kunli.info</a>
<a href="http://twitter.com/cnbuff" target="_blank"><a href="http://twitter.com/cnbuff">http://twitter.com/cnbuff</a></a></p>
<p>2010/3/22 Alleluia <a href="&#109;&#97;&#105;&#108;&#x74;&#111;&#58;&#x5b;&#97;&#x6c;&#108;&#117;&#46;&#46;&#x2e;&#64;&#103;&#109;&#97;&#x69;&#108;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#40;&#41;">&#x5b;&#97;&#x6c;&#108;&#117;&#46;&#46;&#x2e;&#64;&#103;&#109;&#97;&#x69;&#108;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#40;&#41;</a>:</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<blockquote>
<p>Parallelism 说到底是算法问题.Parallelism与Concurrency不同,Concurrency所面对的问题相对的单一可以
让一群有经验的专家来实现一套通用库或者语言来提供一个基本的编程框架.而在Parallelism上,具体的不同问题,其所需要并行的算法是根本不同
的.原因在于不同的问题,其内部的DataDependency的结构完全不同,不同的Data Dependency的结构,需要构造不同的算法.即
便是相同的Data Dependency,在不同的颗粒度下，在不同的硬件条件下所采用的算法也是完全不同的.因为一旦出现Data
Dependency也就意味着并行计算模块之间需要进行通信.从以计算节点为单位的分布式并行,到多核CPU上的Numa结构,到SIMD上的向量处
理器,其计算单元之间的通信手段,通信效率简直天差地别.比如说,在SMP上最常见的并行算法,work stealing也就是Intel的TBB,
是建立在两个条件下第一个是CPU的Cache机制上,这使得通常在内存的之间的数据搬运消耗非常小,第二个是SMP上计算单元相对的少,因此每个计算
单元被分配到的任务就相对的重。其开销远远大于通信的开销,因此这种机制在SMP上相对的划算.但是如果你要在GPU上做Work Stealing就
完全不可行,因为GPU的运算单元数量极多,被分配到的任务就相对来说的非常轻量,CUDA上的一个thread很多时候运算一次的时间不会超过
10us,而一次跨Block的线程之间的通信开销就往往要达到100us左右,再加上目前GPU上的Cache机制非常落后导致了需要频繁的通信开销
的Work Stealing在GPU上是非常不划算得.
所以我个人认为在硬件架构没有更多的突破之前,OpenCL这种东西是没有任何生命力的.不要说CPU的并行与GPU之间差异巨大,就是不同的GPU之
间AMD与Nvidia两个也是各自为政,一个平台上跑得非常快的东西,在另外一个平台极大的可能是龟速.其最终的结果估计就是跟Java的
write once run everywhere一样是个大笑话.</p>
<p>On 3月22日, 下午2时06分, Guancheng Chen <a href="&#109;&#x61;&#x69;&#x6c;&#116;&#111;&#x3a;&#91;&#x63;&#104;&#x65;&#110;&#x67;&#117;&#97;&#110;&#99;&#x68;&#46;&#46;&#46;&#64;&#103;&#109;&#x61;&#105;&#108;&#46;&#99;&#111;&#109;&#93;&#x28;&#41;">&#91;&#x63;&#104;&#x65;&#110;&#x67;&#117;&#97;&#110;&#99;&#x68;&#46;&#46;&#46;&#64;&#103;&#109;&#x61;&#105;&#108;&#46;&#99;&#111;&#109;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>On 3月22日, 上午2时20分, Tinyfool <a href="&#x6d;&#x61;&#105;&#x6c;&#x74;&#111;&#x3a;&#x5b;&#x74;&#105;&#x6e;&#121;&#x66;&#x2e;&#46;&#46;&#x40;&#103;&#109;&#x61;&#x69;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#x29;">&#x5b;&#x74;&#105;&#x6e;&#121;&#x66;&#x2e;&#46;&#46;&#x40;&#103;&#109;&#x61;&#x69;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#x6d;&#x61;&#105;&#108;&#x74;&#111;&#x3a;&#x5b;&#106;&#x65;&#46;&#x2e;&#x2e;&#x40;&#x6c;&#105;&#x76;&#101;&#46;&#x63;&#111;&#x6d;&#x5d;&#x28;&#x29;">&#x5b;&#106;&#x65;&#46;&#x2e;&#x2e;&#x40;&#x6c;&#105;&#x76;&#101;&#46;&#x63;&#111;&#x6d;&#x5d;&#x28;&#x29;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#x6d;&#x61;&#105;&#108;&#x74;&#x6f;&#x3a;&#x5b;&#99;&#104;&#101;&#x6e;&#103;&#117;&#x61;&#110;&#x63;&#x68;&#x2e;&#x2e;&#x2e;&#64;&#103;&#x6d;&#97;&#105;&#108;&#x2e;&#x63;&#111;&#109;&#93;&#x28;&#41;">&#x5b;&#99;&#104;&#101;&#x6e;&#103;&#117;&#x61;&#110;&#x63;&#x68;&#x2e;&#x2e;&#x2e;&#64;&#103;&#x6d;&#97;&#105;&#108;&#x2e;&#x63;&#111;&#109;&#93;&#x28;&#41;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#x6d;&#97;&#105;&#x6c;&#116;&#x6f;&#58;&#x5b;&#112;&#111;&#110;&#x2e;&#46;&#x2e;&#x40;&#103;&#x6f;&#111;&#x67;&#108;&#x65;&#103;&#114;&#x6f;&#x75;&#112;&#115;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#x28;&#x29;">&#x5b;&#112;&#111;&#110;&#x2e;&#46;&#x2e;&#x40;&#103;&#x6f;&#111;&#x67;&#108;&#x65;&#103;&#114;&#x6f;&#x75;&#112;&#115;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#x28;&#x29;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。</p>
</li>
</ol>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>--
Tinyfool的开发日记<a href="http://www.tinydust.net/dev/" target="_blank"><a href="http://www.tinydust.net/dev/">http://www.tinydust.net/dev/</a></a>
代码中国网<a href="http://www.codechina.org/" target="_blank"><a href="http://www.codechina.org">http://www.codechina.org</a></a>
myTwitter:<a href="http://twitter.com/tinyfool" target="_blank"><a href="http://twitter.com/tinyfool">http://twitter.com/tinyfool</a></a></p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p><a href="">显示删减掉的内容</a></p>
</blockquote>
<p><img src="" alt=""> Juv...@gmail.com <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-23</p>
<p>其他收件人：</p>
<p>好像大家说的concurrency和parallelism不是一个东西？
<a href="">显示删减掉的内容</a>
<img src="" alt=""> windstorm <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-23</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>我觉得这两个东西，sun的多线程编程手册说得很清楚了，没必要重新定义。</p>
<p>Parallelism is a condition that arises when at least two threads are
executing simultaneously, while concurrency is a condition that exists
when at least two threads are making progress.</p>
<p>也就是说concurrency有点像更通用化，限制条件更低的parallelism，而某些case下两者完全不同。比如单核多线程程序，你可以叫它是concurrent
program，但不能叫它是parallel
program。Concurrency在现有体系的处理器架构下都可以做到。和Alleluia说的一样，只是一个时钟周期同步的问题。写过硬件编程的人，几乎都算是写过concurrent
program，但很少写过parallel program</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p><a href="http://www.kunli.info/" target="_blank">www.kunli.info</a>
<a href="http://twitter.com/cnbuff" target="_blank"><a href="http://twitter.com/cnbuff">http://twitter.com/cnbuff</a></a></p>
<p>2010/3/22 <a href="">Juv...@gmail.com</a> <a href="&#x6d;&#x61;&#x69;&#108;&#116;&#x6f;&#x3a;&#x5b;&#x6a;&#117;&#118;&#x2e;&#46;&#46;&#x40;&#x67;&#109;&#97;&#105;&#x6c;&#46;&#x63;&#111;&#x6d;&#93;&#x28;&#41;">&#x5b;&#x6a;&#117;&#118;&#x2e;&#46;&#46;&#x40;&#x67;&#109;&#97;&#105;&#x6c;&#46;&#x63;&#111;&#x6d;&#93;&#x28;&#41;</a>:</p>
<blockquote>
<p>好像大家说的concurrency和parallelism不是一个东西？</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p><a href="">显示删减掉的内容</a></p>
</blockquote>
<p><img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-23</p>
<p>其他收件人：</p>
<p>我觉得现有的OpenCL确实非常不成熟，但是从纯性能角度上来讲，我看好Heterogeneous架构，尽管它们的编程难度太大，就像前面提到的不
同架构需要做不同优化等。CPU的性能是latency-oriented，GPU是throughput-oriented,Intel的
Larrabee虽然现在来看不成功，但是业界都在朝着那个方向努力。</p>
<p>On 3月22日, 下午6时18分, windstorm <a href="&#x6d;&#97;&#x69;&#108;&#116;&#x6f;&#58;&#91;&#x6c;&#105;&#107;&#117;&#110;&#97;&#x72;&#109;&#115;&#116;&#x72;&#x2e;&#46;&#46;&#x40;&#x67;&#109;&#x61;&#x69;&#108;&#x2e;&#x63;&#111;&#109;&#93;&#x28;&#x29;">&#91;&#x6c;&#105;&#107;&#117;&#110;&#97;&#x72;&#109;&#115;&#116;&#x72;&#x2e;&#46;&#46;&#x40;&#x67;&#109;&#x61;&#x69;&#108;&#x2e;&#x63;&#111;&#109;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>实在是不能同意你更多......很早很早以前我就在这里和人争论过，GPU的并行计算平台不可能一统天下的。CUDA也不是救世主。OpenCL更不是。</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Alleluia <a href="&#x6d;&#97;&#105;&#x6c;&#x74;&#x6f;&#x3a;&#x5b;&#97;&#x6c;&#x6c;&#117;&#x6c;&#x2e;&#46;&#46;&#x40;&#x67;&#109;&#x61;&#105;&#x6c;&#46;&#x63;&#111;&#x6d;&#x5d;&#x28;&#x29;">&#x5b;&#97;&#x6c;&#x6c;&#117;&#x6c;&#x2e;&#46;&#46;&#x40;&#x67;&#109;&#x61;&#105;&#x6c;&#46;&#x63;&#111;&#x6d;&#x5d;&#x28;&#x29;</a>:</p>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>&gt;
&gt;
&gt;</p>
<blockquote>
<blockquote>
<p>Parallelism 说到底是算法问题.Parallelism与Concurrency不同,Concurrency所面对的问题相对的单一可以
让一群有经验的专家来实现一套通用库或者语言来提供一个基本的编程框架.而在Parallelism上,具体的不同问题,其所需要并行的算法是根本不同
的.原因在于不同的问题,其内部的DataDependency的结构完全不同,不同的Data Dependency的结构,需要构造不同的算法.即
便是相同的Data Dependency,在不同的颗粒度下，在不同的硬件条件下所采用的算法也是完全不同的.因为一旦出现Data
Dependency也就意味着并行计算模块之间需要进行通信.从以计算节点为单位的分布式并行,到多核CPU上的Numa结构,到SIMD上的向量处
理器,其计算单元之间的通信手段,通信效率简直天差地别.比如说,在SMP上最常见的并行算法,work stealing也就是Intel的TBB,
是建立在两个条件下第一个是CPU的Cache机制上,这使得通常在内存的之间的数据搬运消耗非常小,第二个是SMP上计算单元相对的少,因此每个计算
单元被分配到的任务就相对的重。其开销远远大于通信的开销,因此这种机制在SMP上相对的划算.但是如果你要在GPU上做Work Stealing就
完全不可行,因为GPU的运算单元数量极多,被分配到的任务就相对来说的非常轻量,CUDA上的一个thread很多时候运算一次的时间不会超过
10us,而一次跨Block的线程之间的通信开销就往往要达到100us左右,再加上目前GPU上的Cache机制非常落后导致了需要频繁的通信开销
的Work Stealing在GPU上是非常不划算得.
所以我个人认为在硬件架构没有更多的突破之前,OpenCL这种东西是没有任何生命力的.不要说CPU的并行与GPU之间差异巨大,就是不同的GPU之
间AMD与Nvidia两个也是各自为政,一个平台上跑得非常快的东西,在另外一个平台极大的可能是龟速.其最终的结果估计就是跟Java的
write once run everywhere一样是个大笑话.</p>
<p>On 3月22日, 下午2时06分, Guancheng Chen <a href="&#x6d;&#x61;&#105;&#108;&#x74;&#x6f;&#x3a;&#91;&#x63;&#x68;&#x65;&#x6e;&#103;&#x75;&#97;&#x6e;&#99;&#x68;&#46;&#46;&#x2e;&#x40;&#103;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#40;&#41;">&#91;&#x63;&#x68;&#x65;&#x6e;&#103;&#x75;&#97;&#x6e;&#99;&#x68;&#46;&#46;&#x2e;&#x40;&#103;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>On 3月22日, 上午2时20分, Tinyfool <a href="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#111;&#58;&#x5b;&#x74;&#105;&#x6e;&#121;&#x66;&#46;&#x2e;&#x2e;&#64;&#x67;&#109;&#97;&#105;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#93;&#40;&#41;">&#x5b;&#x74;&#105;&#x6e;&#121;&#x66;&#46;&#x2e;&#x2e;&#64;&#x67;&#109;&#97;&#105;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#x6d;&#97;&#105;&#108;&#116;&#x6f;&#58;&#x5b;&#x6a;&#x65;&#x2e;&#46;&#46;&#64;&#108;&#x69;&#x76;&#101;&#x2e;&#99;&#111;&#109;&#x5d;&#x28;&#x29;">&#x5b;&#x6a;&#x65;&#x2e;&#46;&#46;&#64;&#108;&#x69;&#x76;&#101;&#x2e;&#99;&#111;&#109;&#x5d;&#x28;&#x29;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#109;&#x61;&#105;&#x6c;&#x74;&#111;&#58;&#x5b;&#x63;&#x68;&#101;&#110;&#103;&#x75;&#x61;&#110;&#x63;&#104;&#46;&#x2e;&#46;&#x40;&#103;&#109;&#x61;&#105;&#108;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#x29;">&#x5b;&#x63;&#x68;&#101;&#110;&#103;&#x75;&#x61;&#110;&#x63;&#104;&#46;&#x2e;&#46;&#x40;&#103;&#109;&#x61;&#105;&#108;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#x29;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#109;&#x61;&#105;&#x6c;&#x74;&#x6f;&#58;&#x5b;&#x70;&#x6f;&#110;&#x2e;&#x2e;&#x2e;&#64;&#103;&#111;&#111;&#x67;&#108;&#x65;&#x67;&#114;&#x6f;&#x75;&#112;&#115;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#x29;">&#x5b;&#x70;&#x6f;&#110;&#x2e;&#x2e;&#x2e;&#64;&#103;&#111;&#111;&#x67;&#108;&#x65;&#x67;&#114;&#x6f;&#x75;&#112;&#115;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#x29;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？...</li>
</ol>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>阅读更多 &gt;&gt;
<a href="">显示删减掉的内容</a>
<img src="" alt=""> windstorm <img src="" alt=""></p>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-23</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>Larrabee当初我还是很看好的，它的架构比其他的更像一个统一的方案，可惜后来Intel自己经验不足搞不好。</p>
<p>OPENCL还是主要面向multimedia吧，CUDA/OpenCL在业界代表了流处理的方向，从GPU针对任务的角度讲是好的。其他的就算了。就像Alleluia说的那样，在硬件架构没有更多的突破之前，不说没有生命力，至少想取得任何进一步的突破都太难。</p>
<p>现在这个领域，你吹你的水，我吹我的水。至于谁的泡泡大，我看不清。所以真要选东西学，最好还是针对自己的application选靠谱。这也是并行编程教育难的问题。大家需求完全不一样。</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p><a href="http://www.kunli.info/" target="_blank">www.kunli.info</a>
<a href="http://twitter.com/cnbuff" target="_blank"><a href="http://twitter.com/cnbuff">http://twitter.com/cnbuff</a></a></p>
<p>2010/3/22 Guancheng Chen <a href="&#x6d;&#97;&#x69;&#x6c;&#x74;&#x6f;&#x3a;&#91;&#99;&#x68;&#x65;&#x6e;&#x67;&#x75;&#x2e;&#46;&#46;&#64;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#46;&#99;&#111;&#109;&#93;&#x28;&#x29;">&#91;&#99;&#x68;&#x65;&#x6e;&#x67;&#x75;&#x2e;&#46;&#46;&#64;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#46;&#99;&#111;&#109;&#93;&#x28;&#x29;</a>:</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<blockquote>
<p>我觉得现有的OpenCL确实非常不成熟，但是从纯性能角度上来讲，我看好Heterogeneous架构，尽管它们的编程难度太大，就像前面提到的不
同架构需要做不同优化等。CPU的性能是latency-oriented，GPU是throughput-oriented,Intel的
Larrabee虽然现在来看不成功，但是业界都在朝着那个方向努力。</p>
<p>On 3月22日, 下午6时18分, windstorm <a href="&#x6d;&#x61;&#x69;&#108;&#116;&#x6f;&#x3a;&#x5b;&#x6c;&#x69;&#x6b;&#x75;&#110;&#x61;&#114;&#109;&#x73;&#x74;&#x72;&#x2e;&#46;&#46;&#64;&#x67;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#99;&#111;&#x6d;&#93;&#40;&#x29;">&#x5b;&#x6c;&#x69;&#x6b;&#x75;&#110;&#x61;&#114;&#109;&#x73;&#x74;&#x72;&#x2e;&#46;&#46;&#64;&#x67;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#99;&#111;&#x6d;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>实在是不能同意你更多......很早很早以前我就在这里和人争论过，GPU的并行计算平台不可能一统天下的。CUDA也不是救世主。OpenCL更不是。</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Alleluia <a href="&#x6d;&#97;&#x69;&#x6c;&#116;&#111;&#58;&#91;&#x61;&#x6c;&#x6c;&#117;&#x6c;&#46;&#46;&#x2e;&#x40;&#x67;&#109;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#93;&#x28;&#41;">&#91;&#x61;&#x6c;&#x6c;&#117;&#x6c;&#46;&#46;&#x2e;&#x40;&#x67;&#109;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#93;&#x28;&#41;</a>:</p>
<blockquote>
<p>Parallelism 说到底是算法问题.Parallelism与Concurrency不同,Concurrency所面对的问题相对的单一可以
让一群有经验的专家来实现一套通用库或者语言来提供一个基本的编程框架.而在Parallelism上,具体的不同问题,其所需要并行的算法是根本不同
的.原因在于不同的问题,其内部的DataDependency的结构完全不同,不同的Data Dependency的结构,需要构造不同的算法.即
便是相同的Data Dependency,在不同的颗粒度下，在不同的硬件条件下所采用的算法也是完全不同的.因为一旦出现Data
Dependency也就意味着并行计算模块之间需要进行通信.从以计算节点为单位的分布式并行,到多核CPU上的Numa结构,到SIMD上的向量处
理器,其计算单元之间的通信手段,通信效率简直天差地别.比如说,在SMP上最常见的并行算法,work stealing也就是Intel的TBB,
是建立在两个条件下第一个是CPU的Cache机制上,这使得通常在内存的之间的数据搬运消耗非常小,第二个是SMP上计算单元相对的少,因此每个计算
单元被分配到的任务就相对的重。其开销远远大于通信的开销,因此这种机制在SMP上相对的划算.但是如果你要在GPU上做Work Stealing就
完全不可行,因为GPU的运算单元数量极多,被分配到的任务就相对来说的非常轻量,CUDA上的一个thread很多时候运算一次的时间不会超过
10us,而一次跨Block的线程之间的通信开销就往往要达到100us左右,再加上目前GPU上的Cache机制非常落后导致了需要频繁的通信开销
的Work Stealing在GPU上是非常不划算得.
所以我个人认为在硬件架构没有更多的突破之前,OpenCL这种东西是没有任何生命力的.不要说CPU的并行与GPU之间差异巨大,就是不同的GPU之
间AMD与Nvidia两个也是各自为政,一个平台上跑得非常快的东西,在另外一个平台极大的可能是龟速.其最终的结果估计就是跟Java的
write once run everywhere一样是个大笑话.</p>
<p>On 3月22日, 下午2时06分, Guancheng Chen <a href="&#109;&#x61;&#105;&#x6c;&#116;&#111;&#58;&#x5b;&#99;&#x68;&#x65;&#110;&#x67;&#x75;&#x61;&#110;&#99;&#104;&#x2e;&#x2e;&#46;&#64;&#x67;&#109;&#x61;&#x69;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#41;">&#x5b;&#99;&#x68;&#x65;&#110;&#x67;&#x75;&#x61;&#110;&#99;&#104;&#x2e;&#x2e;&#46;&#64;&#x67;&#109;&#x61;&#x69;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>On 3月22日, 上午2时20分, Tinyfool <a href="&#x6d;&#97;&#x69;&#x6c;&#x74;&#111;&#x3a;&#x5b;&#x74;&#x69;&#x6e;&#x79;&#102;&#46;&#46;&#x2e;&#64;&#x67;&#109;&#x61;&#x69;&#x6c;&#x2e;&#99;&#111;&#x6d;&#x5d;&#40;&#41;">&#x5b;&#x74;&#x69;&#x6e;&#x79;&#102;&#46;&#46;&#x2e;&#64;&#x67;&#109;&#x61;&#x69;&#x6c;&#x2e;&#99;&#111;&#x6d;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#x6d;&#x61;&#105;&#x6c;&#116;&#x6f;&#58;&#x5b;&#106;&#x65;&#46;&#x2e;&#x2e;&#x40;&#108;&#x69;&#x76;&#101;&#x2e;&#x63;&#111;&#x6d;&#93;&#x28;&#x29;">&#x5b;&#106;&#x65;&#46;&#x2e;&#x2e;&#x40;&#108;&#x69;&#x76;&#101;&#x2e;&#x63;&#111;&#x6d;&#93;&#x28;&#x29;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#x6d;&#97;&#105;&#108;&#116;&#111;&#x3a;&#91;&#99;&#x68;&#x65;&#110;&#103;&#117;&#x61;&#x6e;&#x63;&#x68;&#46;&#46;&#x2e;&#64;&#x67;&#109;&#x61;&#x69;&#108;&#x2e;&#99;&#x6f;&#109;&#x5d;&#x28;&#x29;">&#91;&#99;&#x68;&#x65;&#110;&#103;&#117;&#x61;&#x6e;&#x63;&#x68;&#46;&#46;&#x2e;&#64;&#x67;&#109;&#x61;&#x69;&#108;&#x2e;&#99;&#x6f;&#109;&#x5d;&#x28;&#x29;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#109;&#97;&#105;&#108;&#x74;&#111;&#x3a;&#x5b;&#112;&#111;&#x6e;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#111;&#111;&#103;&#x6c;&#101;&#103;&#x72;&#111;&#x75;&#x70;&#115;&#46;&#x63;&#111;&#x6d;&#x5d;&#x28;&#x29;">&#x5b;&#112;&#111;&#x6e;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#111;&#111;&#103;&#x6c;&#101;&#103;&#x72;&#111;&#x75;&#x70;&#115;&#46;&#x63;&#111;&#x6d;&#x5d;&#x28;&#x29;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？...</li>
</ol>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>阅读更多 &gt;&gt;</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p><a href="">显示删减掉的内容</a></p>
</blockquote>
<p><img src="" alt=""> Alleluia <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-23</p>
<p>其他收件人：</p>
<p>对于Concurrency和Parallelism之间混乱的根源就是多线程/进程模型.Concurrrency可以用multithread/
process,也可以不用.一个单核单线程的Concurrency程序只要写的好,对于几万个并发连接不是问题.但是Parallelism必须要
用到multithread.对于Concurrency来说,multithread只是一种可选的方案.
当然,在CPU架构上Concurrency和Parallelism的很多设施都是可以复用的,比如高性能的线程池,以及细粒度的锁等等.</p>
<p>On 3月23日, 上午4时32分, windstorm <a href="&#109;&#x61;&#105;&#108;&#x74;&#x6f;&#x3a;&#x5b;&#x6c;&#x69;&#107;&#117;&#x6e;&#x61;&#x72;&#109;&#x73;&#116;&#x72;&#x2e;&#46;&#46;&#64;&#103;&#109;&#x61;&#x69;&#x6c;&#46;&#x63;&#111;&#x6d;&#93;&#x28;&#x29;">&#x5b;&#x6c;&#x69;&#107;&#117;&#x6e;&#x61;&#x72;&#109;&#x73;&#116;&#x72;&#x2e;&#46;&#46;&#64;&#103;&#109;&#x61;&#x69;&#x6c;&#46;&#x63;&#111;&#x6d;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>我觉得这两个东西，sun的多线程编程手册说得很清楚了，没必要重新定义。</p>
<p>Parallelism is a condition that arises when at least two threads are
executing simultaneously, while concurrency is a condition that exists
when at least two threads are making progress.</p>
<p>也就是说concurrency有点像更通用化，限制条件更低的parallelism，而某些case下两者完全不同。比如单核多线程程序，你可以叫它是co ncurrent
program，但不能叫它是parallel
program。Concurrency在现有体系的处理器架构下都可以做到。和Alleluia说的一样，只是一个时钟周期同步的问题。写过硬件编程的人，几 乎都算是写过concurrent
program，但很少写过parallel program</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>2010/3/22 <a href="">Juv...@gmail.com</a> <a href="&#109;&#x61;&#105;&#108;&#x74;&#111;&#x3a;&#91;&#106;&#117;&#x76;&#x2e;&#x2e;&#46;&#64;&#103;&#x6d;&#97;&#x69;&#108;&#46;&#x63;&#x6f;&#109;&#x5d;&#x28;&#x29;">&#91;&#106;&#117;&#x76;&#x2e;&#x2e;&#46;&#64;&#103;&#x6d;&#97;&#x69;&#108;&#46;&#x63;&#x6f;&#109;&#x5d;&#x28;&#x29;</a>:</p>
<blockquote>
<p>好像大家说的concurrency和parallelism不是一个东西？</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> Alleluia <img src="" alt=""></p>
</blockquote>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-23</p>
<p>其他收件人：</p>
<p>Heterogeneous目前来看也是一个暂时的过渡性的东西. Heterogeneous架构最大的问题还是硬件,CPU和GPU之间的
PCIE2的bus带宽太窄了.在上面来回传递一次几M的内存可能需要化掉500us左右.如果一个算法本来就是在3-4ms级别的,你要用GPU去优
化,内存带宽的消耗就占了1/10,这是非常可怕的事情.或许像AMD那种Fusion架构是一种趋势,但是目前来说没有太大的进展.貌似AMD出了一
款混合的CPU,但是貌似还没有看到有多大的优势.</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>On 3月23日, 上午5时02分, Guancheng Chen <a href="&#x6d;&#97;&#105;&#x6c;&#x74;&#111;&#58;&#x5b;&#99;&#104;&#x65;&#x6e;&#103;&#x75;&#97;&#x6e;&#99;&#104;&#46;&#x2e;&#46;&#x40;&#x67;&#x6d;&#x61;&#105;&#x6c;&#46;&#99;&#x6f;&#x6d;&#93;&#40;&#x29;">&#x5b;&#99;&#104;&#x65;&#x6e;&#103;&#x75;&#97;&#x6e;&#99;&#104;&#46;&#x2e;&#46;&#x40;&#x67;&#x6d;&#x61;&#105;&#x6c;&#46;&#99;&#x6f;&#x6d;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>我觉得现有的OpenCL确实非常不成熟，但是从纯性能角度上来讲，我看好Heterogeneous架构，尽管它们的编程难度太大，就像前面提到的不
同架构需要做不同优化等。CPU的性能是latency-oriented，GPU是throughput-oriented,Intel的
Larrabee虽然现在来看不成功，但是业界都在朝着那个方向努力。</p>
<p>On 3月22日, 下午6时18分, windstorm <a href="&#109;&#97;&#x69;&#x6c;&#116;&#111;&#x3a;&#x5b;&#108;&#x69;&#107;&#117;&#x6e;&#x61;&#x72;&#109;&#115;&#116;&#x72;&#46;&#46;&#x2e;&#x40;&#x67;&#x6d;&#97;&#x69;&#x6c;&#46;&#99;&#111;&#109;&#93;&#40;&#41;">&#x5b;&#108;&#x69;&#107;&#117;&#x6e;&#x61;&#x72;&#109;&#115;&#116;&#x72;&#46;&#46;&#x2e;&#x40;&#x67;&#x6d;&#97;&#x69;&#x6c;&#46;&#99;&#111;&#109;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>实在是不能同意你更多......很早很早以前我就在这里和人争论过，GPU的并行计算平台不可能一统天下的。CUDA也不是救世主。OpenCL更不是。</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Alleluia <a href="&#x6d;&#x61;&#105;&#108;&#x74;&#x6f;&#58;&#x5b;&#97;&#x6c;&#x6c;&#x75;&#x6c;&#x2e;&#x2e;&#46;&#x40;&#103;&#109;&#x61;&#105;&#108;&#46;&#99;&#x6f;&#109;&#x5d;&#40;&#x29;">&#x5b;&#97;&#x6c;&#x6c;&#x75;&#x6c;&#x2e;&#x2e;&#46;&#x40;&#103;&#109;&#x61;&#105;&#108;&#46;&#99;&#x6f;&#109;&#x5d;&#40;&#x29;</a>:</p>
<blockquote>
<p>Parallelism 说到底是算法问题.Parallelism与Concurrency不同,Concurrency所面对的问题相对的单一可以
让一群有经验的专家来实现一套通用库或者语言来提供一个基本的编程框架.而在Parallelism上,具体的不同问题,其所需要并行的算法是根本不同
的.原因在于不同的问题,其内部的DataDependency的结构完全不同,不同的Data Dependency的结构,需要构造不同的算法.即
便是相同的Data Dependency,在不同的颗粒度下，在不同的硬件条件下所采用的算法也是完全不同的.因为一旦出现Data
Dependency也就意味着并行计算模块之间需要进行通信.从以计算节点为单位的分布式并行,到多核CPU上的Numa结构,到SIMD上的向量处
理器,其计算单元之间的通信手段,通信效率简直天差地别.比如说,在SMP上最常见的并行算法,work stealing也就是Intel的TBB,
是建立在两个条件下第一个是CPU的Cache机制上,这使得通常在内存的之间的数据搬运消耗非常小,第二个是SMP上计算单元相对的少,因此每个计算
单元被分配到的任务就相对的重。其开销远远大于通信的开销,因此这种机制在SMP上相对的划算.但是如果你要在GPU上做Work Stealing就
完全不可行,因为GPU的运算单元数量极多,被分配到的任务就相对来说的非常轻量,CUDA上的一个thread很多时候运算一次的时间不会超过
10us,而一次跨Block的线程之间的通信开销就往往要达到100us左右,再加上目前GPU上的Cache机制非常落后导致了需要频繁的通信开销
的Work Stealing在GPU上是非常不划算得.
所以我个人认为在硬件架构没有更多的突破之前,OpenCL这种东西是没有任何生命力的.不要说CPU的并行与GPU之间差异巨大,就是不同的GPU之
间AMD与Nvidia两个也是各自为政,一个平台上跑得非常快的东西,在另外一个平台极大的可能是龟速.其最终的结果估计就是跟Java的
write once run everywhere一样是个大笑话.</p>
<p>On 3月22日, 下午2时06分, Guancheng Chen <a href="&#109;&#x61;&#105;&#108;&#116;&#x6f;&#x3a;&#91;&#99;&#x68;&#101;&#110;&#103;&#117;&#97;&#110;&#99;&#104;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#109;&#97;&#x69;&#x6c;&#46;&#x63;&#111;&#109;&#93;&#x28;&#41;">&#91;&#99;&#x68;&#101;&#110;&#103;&#117;&#97;&#110;&#99;&#104;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#109;&#97;&#x69;&#x6c;&#46;&#x63;&#111;&#109;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>On 3月22日, 上午2时20分, Tinyfool <a href="&#109;&#x61;&#x69;&#x6c;&#x74;&#x6f;&#58;&#91;&#116;&#105;&#x6e;&#121;&#102;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#97;&#105;&#x6c;&#x2e;&#99;&#111;&#x6d;&#x5d;&#x28;&#x29;">&#91;&#116;&#105;&#x6e;&#121;&#102;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#97;&#105;&#x6c;&#x2e;&#99;&#111;&#x6d;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#109;&#x61;&#x69;&#x6c;&#116;&#111;&#x3a;&#91;&#106;&#x65;&#x2e;&#46;&#x2e;&#x40;&#108;&#x69;&#x76;&#101;&#x2e;&#x63;&#x6f;&#109;&#93;&#x28;&#x29;">&#91;&#106;&#x65;&#x2e;&#46;&#x2e;&#x40;&#108;&#x69;&#x76;&#101;&#x2e;&#x63;&#x6f;&#109;&#93;&#x28;&#x29;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#x6d;&#97;&#105;&#x6c;&#116;&#x6f;&#58;&#x5b;&#x63;&#104;&#x65;&#x6e;&#103;&#117;&#x61;&#110;&#99;&#104;&#46;&#46;&#46;&#x40;&#103;&#109;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#93;&#x28;&#41;">&#x5b;&#x63;&#104;&#x65;&#x6e;&#103;&#117;&#x61;&#110;&#99;&#104;&#46;&#46;&#46;&#x40;&#103;&#109;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#93;&#x28;&#41;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#109;&#97;&#x69;&#108;&#116;&#111;&#x3a;&#91;&#112;&#111;&#110;&#x2e;&#x2e;&#46;&#x40;&#103;&#111;&#111;&#x67;&#x6c;&#101;&#103;&#x72;&#111;&#x75;&#112;&#x73;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#40;&#41;">&#91;&#112;&#111;&#110;&#x2e;&#x2e;&#46;&#x40;&#103;&#111;&#111;&#x67;&#x6c;&#101;&#103;&#x72;&#111;&#x75;&#112;&#x73;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#40;&#41;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>...</p>
<p>阅读更多 &gt;&gt;
<a href="">显示删减掉的内容</a></p>
</blockquote>
<p><img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-23</p>
<p>其他收件人：</p>
<p>恩 您也是搞体系结构的么？
现在我在跟瑞典这边的爱立信合作做毕设 不过对象不是他们的Erlang 而是传统的C/C++程序 下半年可能我也去搞GPGPU了 因为它的
data parallel模型对遗留代码的并行化很有搞头，现在我粗略的想法是把Compute sensitive的任务放一部分到GPU上去做，
当然我也对GPU目前的一些限制有所了解 但是一些探索工作还是非常值得的 到时候还想向前辈多多请教</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>On 3月22日, 下午11时30分, Alleluia <a href="&#x6d;&#97;&#x69;&#108;&#116;&#111;&#x3a;&#x5b;&#x61;&#x6c;&#x6c;&#x75;&#x6c;&#46;&#x2e;&#46;&#x40;&#103;&#109;&#x61;&#105;&#108;&#46;&#99;&#111;&#x6d;&#93;&#40;&#x29;">&#x5b;&#x61;&#x6c;&#x6c;&#x75;&#x6c;&#46;&#x2e;&#46;&#x40;&#103;&#109;&#x61;&#105;&#108;&#46;&#99;&#111;&#x6d;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>Heterogeneous目前来看也是一个暂时的过渡性的东西. Heterogeneous架构最大的问题还是硬件,CPU和GPU之间的
PCIE2的bus带宽太窄了.在上面来回传递一次几M的内存可能需要化掉500us左右.如果一个算法本来就是在3-4ms级别的,你要用GPU去优
化,内存带宽的消耗就占了1/10,这是非常可怕的事情.或许像AMD那种Fusion架构是一种趋势,但是目前来说没有太大的进展.貌似AMD出了一
款混合的CPU,但是貌似还没有看到有多大的优势.
On 3月23日, 上午5时02分, Guancheng Chen <a href="&#x6d;&#x61;&#x69;&#108;&#116;&#x6f;&#x3a;&#91;&#x63;&#x68;&#x65;&#x6e;&#x67;&#117;&#97;&#110;&#99;&#104;&#46;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#x61;&#105;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#93;&#40;&#41;">&#91;&#x63;&#x68;&#x65;&#x6e;&#x67;&#117;&#97;&#110;&#99;&#104;&#46;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#x61;&#105;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>我觉得现有的OpenCL确实非常不成熟，但是从纯性能角度上来讲，我看好Heterogeneous架构，尽管它们的编程难度太大，就像前面提到的不
同架构需要做不同优化等。CPU的性能是latency-oriented，GPU是throughput-oriented,Intel的
Larrabee虽然现在来看不成功，但是业界都在朝着那个方向努力。</p>
<p>On 3月22日, 下午6时18分, windstorm <a href="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#x6f;&#58;&#x5b;&#x6c;&#x69;&#x6b;&#117;&#x6e;&#97;&#x72;&#x6d;&#115;&#x74;&#x72;&#x2e;&#x2e;&#46;&#x40;&#x67;&#x6d;&#97;&#105;&#x6c;&#x2e;&#99;&#x6f;&#109;&#x5d;&#40;&#x29;">&#x5b;&#x6c;&#x69;&#x6b;&#117;&#x6e;&#97;&#x72;&#x6d;&#115;&#x74;&#x72;&#x2e;&#x2e;&#46;&#x40;&#x67;&#x6d;&#97;&#105;&#x6c;&#x2e;&#99;&#x6f;&#109;&#x5d;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>实在是不能同意你更多......很早很早以前我就在这里和人争论过，GPU的并行计算平台不可能一统天下的。CUDA也不是救世主。OpenCL更不是。</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Alleluia <a href="&#x6d;&#x61;&#105;&#x6c;&#116;&#x6f;&#58;&#x5b;&#97;&#x6c;&#x6c;&#x75;&#108;&#x2e;&#46;&#46;&#x40;&#103;&#x6d;&#97;&#x69;&#108;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#x29;">&#x5b;&#97;&#x6c;&#x6c;&#x75;&#108;&#x2e;&#46;&#46;&#x40;&#103;&#x6d;&#97;&#x69;&#108;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#x29;</a>:</p>
<blockquote>
<p>Parallelism 说到底是算法问题.Parallelism与Concurrency不同,Concurrency所面对的问题相对的单一可以
让一群有经验的专家来实现一套通用库或者语言来提供一个基本的编程框架.而在Parallelism上,具体的不同问题,其所需要并行的算法是根本不同
的.原因在于不同的问题,其内部的DataDependency的结构完全不同,不同的Data Dependency的结构,需要构造不同的算法.即
便是相同的Data Dependency,在不同的颗粒度下，在不同的硬件条件下所采用的算法也是完全不同的.因为一旦出现Data
Dependency也就意味着并行计算模块之间需要进行通信.从以计算节点为单位的分布式并行,到多核CPU上的Numa结构,到SIMD上的向量处
理器,其计算单元之间的通信手段,通信效率简直天差地别.比如说,在SMP上最常见的并行算法,work stealing也就是Intel的TBB,
是建立在两个条件下第一个是CPU的Cache机制上,这使得通常在内存的之间的数据搬运消耗非常小,第二个是SMP上计算单元相对的少,因此每个计算
单元被分配到的任务就相对的重。其开销远远大于通信的开销,因此这种机制在SMP上相对的划算.但是如果你要在GPU上做Work Stealing就
完全不可行,因为GPU的运算单元数量极多,被分配到的任务就相对来说的非常轻量,CUDA上的一个thread很多时候运算一次的时间不会超过
10us,而一次跨Block的线程之间的通信开销就往往要达到100us左右,再加上目前GPU上的Cache机制非常落后导致了需要频繁的通信开销
的Work Stealing在GPU上是非常不划算得.
所以我个人认为在硬件架构没有更多的突破之前,OpenCL这种东西是没有任何生命力的.不要说CPU的并行与GPU之间差异巨大,就是不同的GPU之
间AMD与Nvidia两个也是各自为政,一个平台上跑得非常快的东西,在另外一个平台极大的可能是龟速.其最终的结果估计就是跟Java的
write once run everywhere一样是个大笑话.</p>
<p>On 3月22日, 下午2时06分, Guancheng Chen <a href="&#109;&#97;&#x69;&#x6c;&#116;&#111;&#58;&#91;&#x63;&#104;&#101;&#x6e;&#103;&#117;&#97;&#110;&#99;&#104;&#x2e;&#x2e;&#46;&#64;&#103;&#109;&#97;&#x69;&#x6c;&#46;&#x63;&#x6f;&#109;&#x5d;&#x28;&#x29;">&#91;&#x63;&#104;&#101;&#x6e;&#103;&#117;&#97;&#110;&#99;&#104;&#x2e;&#x2e;&#46;&#64;&#103;&#109;&#97;&#x69;&#x6c;&#46;&#x63;&#x6f;&#109;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>On 3月22日, 上午2时20分, Tinyfool <a href="&#109;&#97;&#x69;&#108;&#x74;&#x6f;&#x3a;&#91;&#116;&#105;&#x6e;&#x79;&#102;&#x2e;&#x2e;&#46;&#64;&#x67;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#x63;&#111;&#109;&#x5d;&#40;&#x29;">&#91;&#116;&#105;&#x6e;&#x79;&#102;&#x2e;&#x2e;&#46;&#64;&#x67;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#x63;&#111;&#109;&#x5d;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#109;&#97;&#x69;&#108;&#116;&#111;&#58;&#x5b;&#x6a;&#101;&#46;&#x2e;&#46;&#x40;&#108;&#105;&#118;&#x65;&#x2e;&#99;&#111;&#x6d;&#x5d;&#40;&#41;">&#x5b;&#x6a;&#101;&#46;&#x2e;&#46;&#x40;&#108;&#105;&#118;&#x65;&#x2e;&#99;&#111;&#x6d;&#x5d;&#40;&#41;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#x6d;&#97;&#x69;&#108;&#116;&#111;&#x3a;&#91;&#x63;&#x68;&#x65;&#110;&#x67;&#117;&#97;&#x6e;&#x63;&#104;&#46;&#x2e;&#46;&#64;&#103;&#109;&#x61;&#x69;&#108;&#46;&#x63;&#x6f;&#109;&#93;&#40;&#41;">&#91;&#x63;&#x68;&#x65;&#110;&#x67;&#117;&#97;&#x6e;&#x63;&#104;&#46;&#x2e;&#46;&#64;&#103;&#109;&#x61;&#x69;&#108;&#46;&#x63;&#x6f;&#109;&#93;&#40;&#41;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#x6d;&#97;&#105;&#108;&#116;&#x6f;&#x3a;&#91;&#112;&#x6f;&#110;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#111;&#x6f;&#x67;&#x6c;&#101;&#x67;&#114;&#111;&#117;&#112;&#115;&#46;&#99;&#x6f;&#109;&#x5d;&#40;&#41;">&#91;&#112;&#x6f;&#110;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#111;&#x6f;&#x67;&#x6c;&#101;&#x67;&#114;&#111;&#117;&#112;&#115;&#46;&#99;&#x6f;&#109;&#x5d;&#40;&#41;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。...</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>阅读更多 &gt;&gt;
<a href="">显示删减掉的内容</a>
<img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-23</p>
<p>其他收件人：</p>
<p>教育以人为本，最终决定使用何种并行技术的还是程序员。目前业界对程序员并没有并行编程的技能要求，全民并行编程的时代什么时候才能到来？这是个问
题。</p>
<p>On 3月22日, 下午10时41分, windstorm <a href="&#x6d;&#97;&#105;&#108;&#116;&#111;&#58;&#91;&#x6c;&#x69;&#107;&#117;&#x6e;&#x61;&#114;&#x6d;&#x73;&#x74;&#114;&#46;&#x2e;&#46;&#x40;&#x67;&#109;&#97;&#105;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#93;&#40;&#41;">&#91;&#x6c;&#x69;&#107;&#117;&#x6e;&#x61;&#114;&#x6d;&#x73;&#x74;&#114;&#46;&#x2e;&#46;&#x40;&#x67;&#109;&#97;&#105;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>Larrabee当初我还是很看好的，它的架构比其他的更像一个统一的方案，可惜后来Intel自己经验不足搞不好。</p>
<p>OPENCL还是主要面向multimedia吧，CUDA/OpenCL在业界代表了流处理的方向，从GPU针对任务的角度讲是好的。其他的就算了。就像Al leluia说的那样，在硬件架构没有更多的突破之前，不说没有生命力，至少想取得任何进一步的突破都太难。</p>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>现在这个领域，你吹你的水，我吹我的水。至于谁的泡泡大，我看不清。所以真要选东西学，最好还是针对自己的application选靠谱。这也是并行编程教育难 的问题。大家需求完全不一样。</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Guancheng Chen <a href="&#109;&#97;&#105;&#x6c;&#116;&#x6f;&#x3a;&#x5b;&#x63;&#x68;&#x65;&#x6e;&#x67;&#117;&#x61;&#110;&#x63;&#x68;&#46;&#x2e;&#46;&#x40;&#x67;&#109;&#x61;&#105;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#x29;">&#x5b;&#x63;&#x68;&#x65;&#x6e;&#x67;&#117;&#x61;&#110;&#x63;&#x68;&#46;&#x2e;&#46;&#x40;&#x67;&#109;&#x61;&#105;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#x29;</a>:</p>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>&gt;
&gt;
&gt;</p>
<blockquote>
<blockquote>
<p>我觉得现有的OpenCL确实非常不成熟，但是从纯性能角度上来讲，我看好Heterogeneous架构，尽管它们的编程难度太大，就像前面提到的不
同架构需要做不同优化等。CPU的性能是latency-oriented，GPU是throughput-oriented,Intel的
Larrabee虽然现在来看不成功，但是业界都在朝着那个方向努力。</p>
<p>On 3月22日, 下午6时18分, windstorm <a href="&#x6d;&#x61;&#x69;&#x6c;&#116;&#x6f;&#58;&#91;&#108;&#105;&#107;&#x75;&#x6e;&#97;&#114;&#109;&#115;&#x74;&#x72;&#46;&#x2e;&#46;&#x40;&#103;&#109;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#40;&#41;">&#91;&#108;&#105;&#107;&#x75;&#x6e;&#97;&#114;&#109;&#115;&#x74;&#x72;&#46;&#x2e;&#46;&#x40;&#103;&#109;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>实在是不能同意你更多......很早很早以前我就在这里和人争论过，GPU的并行计算平台不可能一统天下的。CUDA也不是救世主。OpenCL更不是。</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Alleluia <a href="&#x6d;&#x61;&#x69;&#108;&#x74;&#x6f;&#58;&#x5b;&#x61;&#x6c;&#x6c;&#x75;&#108;&#x2e;&#46;&#46;&#x40;&#x67;&#109;&#97;&#105;&#x6c;&#46;&#99;&#111;&#x6d;&#93;&#x28;&#x29;">&#x5b;&#x61;&#x6c;&#x6c;&#x75;&#108;&#x2e;&#46;&#46;&#x40;&#x67;&#109;&#97;&#105;&#x6c;&#46;&#99;&#111;&#x6d;&#93;&#x28;&#x29;</a>:</p>
<blockquote>
<p>Parallelism 说到底是算法问题.Parallelism与Concurrency不同,Concurrency所面对的问题相对的单一可以
让一群有经验的专家来实现一套通用库或者语言来提供一个基本的编程框架.而在Parallelism上,具体的不同问题,其所需要并行的算法是根本不同
的.原因在于不同的问题,其内部的DataDependency的结构完全不同,不同的Data Dependency的结构,需要构造不同的算法.即
便是相同的Data Dependency,在不同的颗粒度下，在不同的硬件条件下所采用的算法也是完全不同的.因为一旦出现Data
Dependency也就意味着并行计算模块之间需要进行通信.从以计算节点为单位的分布式并行,到多核CPU上的Numa结构,到SIMD上的向量处
理器,其计算单元之间的通信手段,通信效率简直天差地别.比如说,在SMP上最常见的并行算法,work stealing也就是Intel的TBB,
是建立在两个条件下第一个是CPU的Cache机制上,这使得通常在内存的之间的数据搬运消耗非常小,第二个是SMP上计算单元相对的少,因此每个计算
单元被分配到的任务就相对的重。其开销远远大于通信的开销,因此这种机制在SMP上相对的划算.但是如果你要在GPU上做Work Stealing就
完全不可行,因为GPU的运算单元数量极多,被分配到的任务就相对来说的非常轻量,CUDA上的一个thread很多时候运算一次的时间不会超过
10us,而一次跨Block的线程之间的通信开销就往往要达到100us左右,再加上目前GPU上的Cache机制非常落后导致了需要频繁的通信开销
的Work Stealing在GPU上是非常不划算得.
所以我个人认为在硬件架构没有更多的突破之前,OpenCL这种东西是没有任何生命力的.不要说CPU的并行与GPU之间差异巨大,就是不同的GPU之
间AMD与Nvidia两个也是各自为政,一个平台上跑得非常快的东西,在另外一个平台极大的可能是龟速.其最终的结果估计就是跟Java的
write once run everywhere一样是个大笑话.</p>
<p>On 3月22日, 下午2时06分, Guancheng Chen <a href="&#x6d;&#97;&#105;&#x6c;&#116;&#x6f;&#58;&#91;&#x63;&#104;&#101;&#x6e;&#103;&#x75;&#x61;&#x6e;&#x63;&#x68;&#46;&#46;&#46;&#x40;&#103;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#41;">&#91;&#x63;&#104;&#101;&#x6e;&#103;&#x75;&#x61;&#x6e;&#x63;&#x68;&#46;&#46;&#46;&#x40;&#103;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>On 3月22日, 上午2时20分, Tinyfool <a href="&#x6d;&#97;&#105;&#108;&#116;&#111;&#x3a;&#x5b;&#116;&#105;&#110;&#121;&#102;&#46;&#46;&#46;&#x40;&#x67;&#109;&#97;&#x69;&#x6c;&#46;&#99;&#111;&#x6d;&#x5d;&#x28;&#x29;">&#x5b;&#116;&#105;&#110;&#121;&#102;&#46;&#46;&#46;&#x40;&#x67;&#109;&#97;&#x69;&#x6c;&#46;&#99;&#111;&#x6d;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#x6d;&#97;&#105;&#x6c;&#x74;&#x6f;&#58;&#91;&#x6a;&#101;&#x2e;&#46;&#46;&#64;&#x6c;&#x69;&#118;&#x65;&#46;&#99;&#111;&#x6d;&#x5d;&#40;&#41;">&#91;&#x6a;&#101;&#x2e;&#46;&#46;&#64;&#x6c;&#x69;&#118;&#x65;&#46;&#99;&#111;&#x6d;&#x5d;&#40;&#41;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#109;&#97;&#105;&#x6c;&#116;&#x6f;&#58;&#91;&#99;&#x68;&#101;&#x6e;&#x67;&#x75;&#x61;&#x6e;&#99;&#x68;&#x2e;&#x2e;&#46;&#x40;&#x67;&#109;&#97;&#x69;&#x6c;&#46;&#99;&#x6f;&#109;&#x5d;&#40;&#41;">&#91;&#99;&#x68;&#101;&#x6e;&#x67;&#x75;&#x61;&#x6e;&#99;&#x68;&#x2e;&#x2e;&#46;&#x40;&#x67;&#109;&#97;&#x69;&#x6c;&#46;&#99;&#x6f;&#109;&#x5d;&#40;&#41;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#x6d;&#97;&#x69;&#x6c;&#x74;&#111;&#58;&#91;&#112;&#111;&#x6e;&#46;&#x2e;&#46;&#64;&#103;&#x6f;&#x6f;&#x67;&#x6c;&#101;&#x67;&#x72;&#x6f;&#117;&#x70;&#x73;&#46;&#99;&#x6f;&#x6d;&#93;&#40;&#41;">&#91;&#112;&#111;&#x6e;&#46;&#x2e;&#46;&#64;&#103;&#x6f;&#x6f;&#x67;&#x6c;&#101;&#x67;&#x72;&#x6f;&#117;&#x70;&#x73;&#46;&#99;&#x6f;&#x6d;&#93;&#40;&#41;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线...</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>阅读更多 &gt;&gt;
<a href="">显示删减掉的内容</a></p>
</blockquote>
<p><img src="" alt=""> windstorm <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-23</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>全民并行编程的时代，只有在全民能够并行编程的时候才会到来嘛，现在不是这个时候</p>
<p>我个人倾向于等待一个比较好的统一性架构。两条路：</p>
<p>一是某一个全新概念的提出，这个要看学术界的努力，而且在某种意义上讲，学术界搞出一个真正可行的并行架构的可能性比工业界更高。虽说今天多核的发展是工业界引领的，但是点子还是最早学术界提出的。典型的有几个：斯坦福的Hydra（1996），斯坦福的Imagine(2000)，MIT的RAW（2002），以及UT奥斯丁的TRIPS（2003）。在这个问题上，是不得不佩服美国的创造力，要知道直到在2000年左右，所有的人都还在为处理器频率按照摩尔定律翻翻而狂热，美国的顶尖研究员就早已看到了这条路的尽头并指出未来处理器的发展之路。</p>
<p>二是你用现有的架构，但是application引导。如果要找一个面向多application
domain的话，刚才说了，本来看好Larrabee，因为它的架构解决了CUDA一个很大的潜在问题，而且允许现有程序员不经过任何特殊training就上手编程，包括图形图像，科学计算，或者网络处理，各个领域。</p>
<p>不过可能就是因为这个solution的过于理想化导致结构的过于复杂化，才让其目前暂时流产。</p>
<p>总的来说，现在的问题就是软件发展不成熟，硬件发展不完善，你没法靠程序员决定使用什么并行技术，完全靠应用主导，这套技术在这个应用上如鱼得水，在那个应用上完全不罩，作为程序员，有什么办法？</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p><a href="http://www.kunli.info/" target="_blank">www.kunli.info</a>
<a href="http://twitter.com/cnbuff" target="_blank"><a href="http://twitter.com/cnbuff">http://twitter.com/cnbuff</a></a></p>
<p>2010/3/22 Guancheng Chen <a href="&#x6d;&#x61;&#105;&#108;&#x74;&#x6f;&#58;&#91;&#x63;&#x68;&#x65;&#110;&#103;&#117;&#x2e;&#x2e;&#46;&#x40;&#x67;&#109;&#x61;&#x69;&#108;&#x2e;&#99;&#111;&#x6d;&#x5d;&#40;&#x29;">&#91;&#x63;&#x68;&#x65;&#110;&#103;&#117;&#x2e;&#x2e;&#46;&#x40;&#x67;&#109;&#x61;&#x69;&#108;&#x2e;&#99;&#111;&#x6d;&#x5d;&#40;&#x29;</a>:</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<blockquote>
<p>教育以人为本，最终决定使用何种并行技术的还是程序员。目前业界对程序员并没有并行编程的技能要求，全民并行编程的时代什么时候才能到来？这是个问
题。</p>
<p>On 3月22日, 下午10时41分, windstorm <a href="&#x6d;&#x61;&#105;&#108;&#x74;&#111;&#x3a;&#91;&#108;&#105;&#x6b;&#117;&#x6e;&#97;&#114;&#x6d;&#x73;&#x74;&#x72;&#x2e;&#46;&#46;&#x40;&#103;&#109;&#x61;&#x69;&#108;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#x28;&#x29;">&#91;&#108;&#105;&#x6b;&#117;&#x6e;&#97;&#114;&#x6d;&#x73;&#x74;&#x72;&#x2e;&#46;&#46;&#x40;&#103;&#109;&#x61;&#x69;&#108;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>Larrabee当初我还是很看好的，它的架构比其他的更像一个统一的方案，可惜后来Intel自己经验不足搞不好。</p>
<p>OPENCL还是主要面向multimedia吧，CUDA/OpenCL在业界代表了流处理的方向，从GPU针对任务的角度讲是好的。其他的就算了。就像Al leluia说的那样，在硬件架构没有更多的突破之前，不说没有生命力，至少想取得任何进一步的突破都太难。</p>
<p>现在这个领域，你吹你的水，我吹我的水。至于谁的泡泡大，我看不清。所以真要选东西学，最好还是针对自己的application选靠谱。这也是并行编程教育难 的问题。大家需求完全不一样。</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Guancheng Chen <a href="&#109;&#x61;&#105;&#108;&#116;&#x6f;&#x3a;&#x5b;&#x63;&#104;&#x65;&#110;&#103;&#117;&#x61;&#x6e;&#x63;&#x68;&#x2e;&#46;&#x2e;&#x40;&#x67;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#93;&#x28;&#x29;">&#x5b;&#x63;&#104;&#x65;&#110;&#103;&#117;&#x61;&#x6e;&#x63;&#x68;&#x2e;&#46;&#x2e;&#x40;&#x67;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#93;&#x28;&#x29;</a>:</p>
<blockquote>
<p>我觉得现有的OpenCL确实非常不成熟，但是从纯性能角度上来讲，我看好Heterogeneous架构，尽管它们的编程难度太大，就像前面提到的不
同架构需要做不同优化等。CPU的性能是latency-oriented，GPU是throughput-oriented,Intel的
Larrabee虽然现在来看不成功，但是业界都在朝着那个方向努力。</p>
<p>On 3月22日, 下午6时18分, windstorm <a href="&#109;&#x61;&#x69;&#x6c;&#x74;&#111;&#58;&#x5b;&#108;&#105;&#x6b;&#x75;&#110;&#x61;&#114;&#109;&#115;&#x74;&#x72;&#46;&#x2e;&#x2e;&#x40;&#x67;&#109;&#97;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#x28;&#41;">&#x5b;&#108;&#105;&#x6b;&#x75;&#110;&#x61;&#114;&#109;&#115;&#x74;&#x72;&#46;&#x2e;&#x2e;&#x40;&#x67;&#109;&#97;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>实在是不能同意你更多......很早很早以前我就在这里和人争论过，GPU的并行计算平台不可能一统天下的。CUDA也不是救世主。OpenCL更不是。</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Alleluia <a href="&#109;&#97;&#x69;&#x6c;&#116;&#111;&#x3a;&#x5b;&#x61;&#108;&#108;&#117;&#108;&#x2e;&#46;&#46;&#x40;&#103;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#109;&#x5d;&#x28;&#x29;">&#x5b;&#x61;&#108;&#108;&#117;&#108;&#x2e;&#46;&#46;&#x40;&#103;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#109;&#x5d;&#x28;&#x29;</a>:</p>
<blockquote>
<p>Parallelism 说到底是算法问题.Parallelism与Concurrency不同,Concurrency所面对的问题相对的单一可以
让一群有经验的专家来实现一套通用库或者语言来提供一个基本的编程框架.而在Parallelism上,具体的不同问题,其所需要并行的算法是根本不同
的.原因在于不同的问题,其内部的DataDependency的结构完全不同,不同的Data Dependency的结构,需要构造不同的算法.即
便是相同的Data Dependency,在不同的颗粒度下，在不同的硬件条件下所采用的算法也是完全不同的.因为一旦出现Data
Dependency也就意味着并行计算模块之间需要进行通信.从以计算节点为单位的分布式并行,到多核CPU上的Numa结构,到SIMD上的向量处
理器,其计算单元之间的通信手段,通信效率简直天差地别.比如说,在SMP上最常见的并行算法,work stealing也就是Intel的TBB,
是建立在两个条件下第一个是CPU的Cache机制上,这使得通常在内存的之间的数据搬运消耗非常小,第二个是SMP上计算单元相对的少,因此每个计算
单元被分配到的任务就相对的重。其开销远远大于通信的开销,因此这种机制在SMP上相对的划算.但是如果你要在GPU上做Work Stealing就
完全不可行,因为GPU的运算单元数量极多,被分配到的任务就相对来说的非常轻量,CUDA上的一个thread很多时候运算一次的时间不会超过
10us,而一次跨Block的线程之间的通信开销就往往要达到100us左右,再加上目前GPU上的Cache机制非常落后导致了需要频繁的通信开销
的Work Stealing在GPU上是非常不划算得.
所以我个人认为在硬件架构没有更多的突破之前,OpenCL这种东西是没有任何生命力的.不要说CPU的并行与GPU之间差异巨大,就是不同的GPU之
间AMD与Nvidia两个也是各自为政,一个平台上跑得非常快的东西,在另外一个平台极大的可能是龟速.其最终的结果估计就是跟Java的
write once run everywhere一样是个大笑话.</p>
<p>On 3月22日, 下午2时06分, Guancheng Chen <a href="&#x6d;&#x61;&#x69;&#x6c;&#116;&#111;&#x3a;&#91;&#x63;&#104;&#x65;&#110;&#103;&#117;&#x61;&#x6e;&#x63;&#104;&#46;&#x2e;&#46;&#64;&#103;&#109;&#97;&#x69;&#108;&#x2e;&#x63;&#111;&#x6d;&#93;&#x28;&#41;">&#91;&#x63;&#104;&#x65;&#110;&#103;&#117;&#x61;&#x6e;&#x63;&#104;&#46;&#x2e;&#46;&#64;&#103;&#109;&#97;&#x69;&#108;&#x2e;&#x63;&#111;&#x6d;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>On 3月22日, 上午2时20分, Tinyfool <a href="&#109;&#x61;&#x69;&#108;&#x74;&#x6f;&#58;&#x5b;&#x74;&#105;&#x6e;&#121;&#x66;&#46;&#46;&#46;&#64;&#x67;&#109;&#97;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#x28;&#x29;">&#x5b;&#x74;&#105;&#x6e;&#121;&#x66;&#46;&#46;&#46;&#64;&#x67;&#109;&#97;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#111;&#58;&#x5b;&#x6a;&#x65;&#46;&#x2e;&#x2e;&#x40;&#x6c;&#x69;&#x76;&#101;&#46;&#99;&#x6f;&#109;&#93;&#40;&#x29;">&#x5b;&#x6a;&#x65;&#46;&#x2e;&#x2e;&#x40;&#x6c;&#x69;&#x76;&#101;&#46;&#99;&#x6f;&#109;&#93;&#40;&#x29;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#109;&#97;&#x69;&#108;&#116;&#111;&#x3a;&#x5b;&#99;&#x68;&#x65;&#110;&#x67;&#117;&#97;&#x6e;&#x63;&#104;&#x2e;&#46;&#46;&#x40;&#x67;&#109;&#x61;&#105;&#108;&#46;&#99;&#x6f;&#109;&#93;&#40;&#41;">&#x5b;&#99;&#x68;&#x65;&#110;&#x67;&#117;&#97;&#x6e;&#x63;&#104;&#x2e;&#46;&#46;&#x40;&#x67;&#109;&#x61;&#105;&#108;&#46;&#99;&#x6f;&#109;&#93;&#40;&#41;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#109;&#x61;&#x69;&#x6c;&#116;&#x6f;&#x3a;&#91;&#112;&#111;&#x6e;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#111;&#x6f;&#x67;&#108;&#x65;&#103;&#x72;&#x6f;&#x75;&#112;&#115;&#46;&#x63;&#111;&#x6d;&#x5d;&#40;&#41;">&#91;&#112;&#111;&#x6e;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#111;&#x6f;&#x67;&#108;&#x65;&#103;&#x72;&#x6f;&#x75;&#112;&#115;&#46;&#x63;&#111;&#x6d;&#x5d;&#40;&#41;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线...</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>阅读更多 &gt;&gt;</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p><a href="">显示删减掉的内容</a>
<img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-23</p>
<p>其他收件人：</p>
<p>恩</p>
<p>第二点其实我就是指程序员根据他自己的程序领域选择合适的并行技术。Top Language真是藏龙卧虎啊。你是在Boulder么?我一个大学女同
学在你那读MIS的phd</p>
<p>On 3月23日, 上午12时04分, windstorm <a href="&#109;&#x61;&#105;&#x6c;&#x74;&#111;&#x3a;&#x5b;&#x6c;&#x69;&#107;&#x75;&#x6e;&#97;&#x72;&#x6d;&#x73;&#116;&#x72;&#x2e;&#46;&#46;&#x40;&#103;&#x6d;&#x61;&#x69;&#108;&#46;&#99;&#111;&#109;&#93;&#40;&#41;">&#x5b;&#x6c;&#x69;&#107;&#x75;&#x6e;&#97;&#x72;&#x6d;&#x73;&#116;&#x72;&#x2e;&#46;&#46;&#x40;&#103;&#x6d;&#x61;&#x69;&#108;&#46;&#99;&#111;&#109;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>全民并行编程的时代，只有在全民能够并行编程的时候才会到来嘛，现在不是这个时候</p>
<p>我个人倾向于等待一个比较好的统一性架构。两条路：</p>
<p>一是某一个全新概念的提出，这个要看学术界的努力，而且在某种意义上讲，学术界搞出一个真正可行的并行架构的可能性比工业界更高。虽说今天多核的发展是工业界引 领的，但是点子还是最早学术界提出的。典型的有几个：斯坦福的Hydra（1996），斯坦福的Imagine(2000)，MIT的RAW（2002），以及 UT奥斯丁的TRIPS（2003）。在这个问题上，是不得不佩服美国的创造力，要知道直到在2000年左右，所有的人都还在为处理器频率按照摩尔定律翻翻而狂 热，美国的顶尖研究员就早已看到了这条路的尽头并指出未来处理器的发展之路。</p>
<p>二是你用现有的架构，但是application引导。如果要找一个面向多application
domain的话，刚才说了，本来看好Larrabee，因为它的架构解决了CUDA一个很大的潜在问题，而且允许现有程序员不经过任何特殊training就 上手编程，包括图形图像，科学计算，或者网络处理，各个领域。</p>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>不过可能就是因为这个solution的过于理想化导致结构的过于复杂化，才让其目前暂时流产。</p>
<p>总的来说，现在的问题就是软件发展不成熟，硬件发展不完善，你没法靠程序员决定使用什么并行技术，完全靠应用主导，这套技术在这个应用上如鱼得水，在那个应用上 完全不罩，作为程序员，有什么办法？</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Guancheng Chen <a href="&#x6d;&#97;&#x69;&#x6c;&#x74;&#x6f;&#58;&#x5b;&#99;&#x68;&#x65;&#110;&#103;&#117;&#x61;&#110;&#99;&#x68;&#x2e;&#46;&#46;&#64;&#x67;&#x6d;&#97;&#x69;&#108;&#46;&#99;&#x6f;&#x6d;&#93;&#40;&#x29;">&#x5b;&#99;&#x68;&#x65;&#110;&#103;&#117;&#x61;&#110;&#99;&#x68;&#x2e;&#46;&#46;&#64;&#x67;&#x6d;&#97;&#x69;&#108;&#46;&#99;&#x6f;&#x6d;&#93;&#40;&#x29;</a>:</p>
<blockquote>
<p>教育以人为本，最终决定使用何种并行技术的还是程序员。目前业界对程序员并没有并行编程的技能要求，全民并行编程的时代什么时候才能到来？这是个问
题。</p>
<p>On 3月22日, 下午10时41分, windstorm <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#91;&#x6c;&#x69;&#x6b;&#117;&#110;&#x61;&#114;&#109;&#x73;&#116;&#x72;&#x2e;&#46;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#x28;&#x29;">&#91;&#x6c;&#x69;&#x6b;&#117;&#110;&#x61;&#114;&#109;&#x73;&#116;&#x72;&#x2e;&#46;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>Larrabee当初我还是很看好的，它的架构比其他的更像一个统一的方案，可惜后来Intel自己经验不足搞不好。</p>
<p>OPENCL还是主要面向multimedia吧，CUDA/OpenCL在业界代表了流处理的方向，从GPU针对任务的角度讲是好的。其他的就算了。就像Al leluia说的那样，在硬件架构没有更多的突破之前，不说没有生命力，至少想取得任何进一步的突破都太难。</p>
<p>现在这个领域，你吹你的水，我吹我的水。至于谁的泡泡大，我看不清。所以真要选东西学，最好还是针对自己的application选靠谱。这也是并行编程教育难 的问题。大家需求完全不一样。</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Guancheng Chen <a href="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#111;&#x3a;&#x5b;&#x63;&#x68;&#101;&#x6e;&#x67;&#117;&#97;&#110;&#x63;&#104;&#x2e;&#46;&#x2e;&#64;&#103;&#109;&#97;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#93;&#x28;&#41;">&#x5b;&#x63;&#x68;&#101;&#x6e;&#x67;&#117;&#97;&#110;&#x63;&#104;&#x2e;&#46;&#x2e;&#64;&#103;&#109;&#97;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#93;&#x28;&#41;</a>:</p>
<blockquote>
<p>我觉得现有的OpenCL确实非常不成熟，但是从纯性能角度上来讲，我看好Heterogeneous架构，尽管它们的编程难度太大，就像前面提到的不
同架构需要做不同优化等。CPU的性能是latency-oriented，GPU是throughput-oriented,Intel的
Larrabee虽然现在来看不成功，但是业界都在朝着那个方向努力。</p>
<p>On 3月22日, 下午6时18分, windstorm <a href="&#109;&#x61;&#x69;&#x6c;&#116;&#111;&#58;&#x5b;&#x6c;&#105;&#x6b;&#x75;&#110;&#x61;&#x72;&#x6d;&#x73;&#116;&#114;&#46;&#x2e;&#46;&#64;&#103;&#x6d;&#97;&#x69;&#108;&#46;&#x63;&#111;&#x6d;&#x5d;&#x28;&#41;">&#x5b;&#x6c;&#105;&#x6b;&#x75;&#110;&#x61;&#x72;&#x6d;&#x73;&#116;&#114;&#46;&#x2e;&#46;&#64;&#103;&#x6d;&#97;&#x69;&#108;&#46;&#x63;&#111;&#x6d;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>实在是不能同意你更多......很早很早以前我就在这里和人争论过，GPU的并行计算平台不可能一统天下的。CUDA也不是救世主。OpenCL更不是。</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Alleluia <a href="&#109;&#97;&#x69;&#x6c;&#116;&#x6f;&#x3a;&#x5b;&#x61;&#x6c;&#x6c;&#117;&#x6c;&#46;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#41;">&#x5b;&#x61;&#x6c;&#x6c;&#117;&#x6c;&#46;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#41;</a>:</p>
<blockquote>
<p>Parallelism 说到底是算法问题.Parallelism与Concurrency不同,Concurrency所面对的问题相对的单一可以
让一群有经验的专家来实现一套通用库或者语言来提供一个基本的编程框架.而在Parallelism上,具体的不同问题,其所需要并行的算法是根本不同
的.原因在于不同的问题,其内部的DataDependency的结构完全不同,不同的Data Dependency的结构,需要构造不同的算法.即
便是相同的Data Dependency,在不同的颗粒度下，在不同的硬件条件下所采用的算法也是完全不同的.因为一旦出现Data
Dependency也就意味着并行计算模块之间需要进行通信.从以计算节点为单位的分布式并行,到多核CPU上的Numa结构,到SIMD上的向量处
理器,其计算单元之间的通信手段,通信效率简直天差地别.比如说,在SMP上最常见的并行算法,work stealing也就是Intel的TBB,
是建立在两个条件下第一个是CPU的Cache机制上,这使得通常在内存的之间的数据搬运消耗非常小,第二个是SMP上计算单元相对的少,因此每个计算
单元被分配到的任务就相对的重。其开销远远大于通信的开销,因此这种机制在SMP上相对的划算.但是如果你要在GPU上做Work Stealing就
完全不可行,因为GPU的运算单元数量极多,被分配到的任务就相对来说的非常轻量,CUDA上的一个thread很多时候运算一次的时间不会超过
10us,而一次跨Block的线程之间的通信开销就往往要达到100us左右,再加上目前GPU上的Cache机制非常落后导致了需要频繁的通信开销
的Work Stealing在GPU上是非常不划算得.
所以我个人认为在硬件架构没有更多的突破之前,OpenCL这种东西是没有任何生命力的.不要说CPU的并行与GPU之间差异巨大,就是不同的GPU之
间AMD与Nvidia两个也是各自为政,一个平台上跑得非常快的东西,在另外一个平台极大的可能是龟速.其最终的结果估计就是跟Java的
write once run everywhere一样是个大笑话.</p>
<p>On 3月22日, 下午2时06分, Guancheng Chen <a href="&#109;&#97;&#x69;&#108;&#116;&#111;&#58;&#91;&#x63;&#104;&#x65;&#x6e;&#103;&#117;&#97;&#110;&#x63;&#x68;&#46;&#x2e;&#46;&#x40;&#x67;&#x6d;&#x61;&#x69;&#108;&#x2e;&#99;&#x6f;&#109;&#x5d;&#x28;&#x29;">&#91;&#x63;&#104;&#x65;&#x6e;&#103;&#117;&#97;&#110;&#x63;&#x68;&#46;&#x2e;&#46;&#x40;&#x67;&#x6d;&#x61;&#x69;&#108;&#x2e;&#99;&#x6f;&#109;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>On 3月22日, 上午2时20分, Tinyfool <a href="&#x6d;&#97;&#x69;&#108;&#x74;&#x6f;&#x3a;&#x5b;&#x74;&#x69;&#x6e;&#121;&#x66;&#46;&#x2e;&#46;&#64;&#103;&#109;&#97;&#105;&#108;&#x2e;&#x63;&#x6f;&#109;&#93;&#40;&#41;">&#x5b;&#x74;&#x69;&#x6e;&#121;&#x66;&#46;&#x2e;&#46;&#64;&#103;&#109;&#97;&#105;&#108;&#x2e;&#x63;&#x6f;&#109;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#x6d;&#97;&#x69;&#108;&#116;&#x6f;&#58;&#91;&#x6a;&#101;&#46;&#46;&#46;&#x40;&#x6c;&#x69;&#x76;&#101;&#x2e;&#99;&#111;&#x6d;&#x5d;&#x28;&#x29;">&#91;&#x6a;&#101;&#46;&#46;&#46;&#x40;&#x6c;&#x69;&#x76;&#101;&#x2e;&#99;&#111;&#x6d;&#x5d;&#x28;&#x29;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#109;&#97;&#105;&#108;&#x74;&#x6f;&#58;&#x5b;&#99;&#104;&#x65;&#110;&#103;&#x75;&#97;&#110;&#99;&#x68;&#46;&#x2e;&#46;&#64;&#x67;&#x6d;&#x61;&#105;&#108;&#46;&#x63;&#111;&#x6d;&#93;&#40;&#x29;">&#x5b;&#99;&#104;&#x65;&#110;&#103;&#x75;&#97;&#110;&#99;&#x68;&#46;&#x2e;&#46;&#64;&#x67;&#x6d;&#x61;&#105;&#108;&#46;&#x63;&#111;&#x6d;&#93;&#40;&#x29;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#109;&#97;&#x69;&#108;&#116;&#111;&#58;&#x5b;&#112;&#x6f;&#110;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#x6f;&#x6f;&#103;&#108;&#101;&#103;&#114;&#111;&#117;&#112;&#115;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#40;&#41;">&#x5b;&#112;&#x6f;&#110;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#x6f;&#x6f;&#103;&#108;&#101;&#103;&#114;&#111;&#117;&#112;&#115;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#40;&#41;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器...</li>
</ol>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>阅读更多 &gt;&gt;
<a href="">显示删减掉的内容</a></p>
</blockquote>
<p><img src="" alt=""> Alleluia <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-23</p>
<p>其他收件人：</p>
<p>我不是搞体系结构的.但是我认为目前来说做Parallelism的人首先不是去熟悉什么API或者Libarary,而是要熟悉两样东西体系结构和算
法.没有这两样,几乎写不出什么高效率的并行程序.当然你的需求只是并行化循环这种简单的东西当然可以里例外.呵呵.
我觉得你最好放弃用GPGPU去搞遗留代码的想法.现在市面上的GPU产品无论是A记的还是N记的其编程架构与CPU完全不同,你不要想把一个循环简单
的porting到GPU上就能并行了.那是几乎不可能的,比如最简单的你如何处理branch?如果branch非常多,divergence会把速
度拖得比CPU版本还慢.你如何处理CPU代码里的数组随机访问,在GPU上无论是片上的还是片外的内存是不能随机访问的,最要命的是没有cache,
随机访问的代价极其高昂.你几乎需要把CPU上的代码面目全非地从新写一遍,遗留代码除了用作调试测试做结果比对之外几乎要全部抛弃.</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>On 3月23日, 上午6时42分, Guancheng Chen <a href="&#x6d;&#97;&#105;&#x6c;&#x74;&#111;&#58;&#91;&#x63;&#104;&#101;&#x6e;&#x67;&#x75;&#x61;&#x6e;&#99;&#104;&#x2e;&#46;&#46;&#64;&#x67;&#x6d;&#x61;&#x69;&#108;&#x2e;&#99;&#111;&#109;&#93;&#x28;&#x29;">&#91;&#x63;&#104;&#101;&#x6e;&#x67;&#x75;&#x61;&#x6e;&#99;&#104;&#x2e;&#46;&#46;&#64;&#x67;&#x6d;&#x61;&#x69;&#108;&#x2e;&#99;&#111;&#109;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>恩 您也是搞体系结构的么？
现在我在跟瑞典这边的爱立信合作做毕设 不过对象不是他们的Erlang 而是传统的C/C++程序 下半年可能我也去搞GPGPU了 因为它的
data parallel模型对遗留代码的并行化很有搞头，现在我粗略的想法是把Compute sensitive的任务放一部分到GPU上去做，
当然我也对GPU目前的一些限制有所了解 但是一些探索工作还是非常值得的 到时候还想向前辈多多请教</p>
<p>On 3月22日, 下午11时30分, Alleluia <a href="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#111;&#x3a;&#91;&#x61;&#108;&#x6c;&#117;&#108;&#x2e;&#46;&#x2e;&#x40;&#x67;&#109;&#97;&#105;&#108;&#46;&#99;&#x6f;&#109;&#x5d;&#40;&#x29;">&#91;&#x61;&#108;&#x6c;&#117;&#108;&#x2e;&#46;&#x2e;&#x40;&#x67;&#109;&#97;&#105;&#108;&#46;&#99;&#x6f;&#109;&#x5d;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>Heterogeneous目前来看也是一个暂时的过渡性的东西. Heterogeneous架构最大的问题还是硬件,CPU和GPU之间的
PCIE2的bus带宽太窄了.在上面来回传递一次几M的内存可能需要化掉500us左右.如果一个算法本来就是在3-4ms级别的,你要用GPU去优
化,内存带宽的消耗就占了1/10,这是非常可怕的事情.或许像AMD那种Fusion架构是一种趋势,但是目前来说没有太大的进展.貌似AMD出了一
款混合的CPU,但是貌似还没有看到有多大的优势.
On 3月23日, 上午5时02分, Guancheng Chen <a href="&#109;&#x61;&#x69;&#108;&#x74;&#111;&#58;&#91;&#x63;&#104;&#x65;&#x6e;&#x67;&#x75;&#x61;&#x6e;&#99;&#104;&#46;&#46;&#x2e;&#64;&#x67;&#109;&#x61;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#93;&#x28;&#41;">&#91;&#x63;&#104;&#x65;&#x6e;&#x67;&#x75;&#x61;&#x6e;&#99;&#104;&#46;&#46;&#x2e;&#64;&#x67;&#109;&#x61;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>我觉得现有的OpenCL确实非常不成熟，但是从纯性能角度上来讲，我看好Heterogeneous架构，尽管它们的编程难度太大，就像前面提到的不
同架构需要做不同优化等。CPU的性能是latency-oriented，GPU是throughput-oriented,Intel的
Larrabee虽然现在来看不成功，但是业界都在朝着那个方向努力。</p>
<p>On 3月22日, 下午6时18分, windstorm <a href="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#111;&#x3a;&#91;&#108;&#105;&#x6b;&#117;&#x6e;&#x61;&#114;&#109;&#115;&#116;&#x72;&#x2e;&#46;&#46;&#x40;&#103;&#109;&#97;&#x69;&#108;&#46;&#99;&#111;&#109;&#x5d;&#40;&#x29;">&#91;&#108;&#105;&#x6b;&#117;&#x6e;&#x61;&#114;&#109;&#115;&#116;&#x72;&#x2e;&#46;&#46;&#x40;&#103;&#109;&#97;&#x69;&#108;&#46;&#99;&#111;&#109;&#x5d;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>实在是不能同意你更多......很早很早以前我就在这里和人争论过，GPU的并行计算平台不可能一统天下的。CUDA也不是救世主。OpenCL更不是。</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Alleluia <a href="&#109;&#x61;&#x69;&#x6c;&#116;&#x6f;&#58;&#x5b;&#97;&#x6c;&#x6c;&#x75;&#108;&#46;&#x2e;&#x2e;&#64;&#103;&#109;&#x61;&#105;&#108;&#46;&#x63;&#111;&#109;&#93;&#x28;&#41;">&#x5b;&#97;&#x6c;&#x6c;&#x75;&#108;&#46;&#x2e;&#x2e;&#64;&#103;&#109;&#x61;&#105;&#108;&#46;&#x63;&#111;&#109;&#93;&#x28;&#41;</a>:</p>
<blockquote>
<p>Parallelism 说到底是算法问题.Parallelism与Concurrency不同,Concurrency所面对的问题相对的单一可以
让一群有经验的专家来实现一套通用库或者语言来提供一个基本的编程框架.而在Parallelism上,具体的不同问题,其所需要并行的算法是根本不同
的.原因在于不同的问题,其内部的DataDependency的结构完全不同,不同的Data Dependency的结构,需要构造不同的算法.即
便是相同的Data Dependency,在不同的颗粒度下，在不同的硬件条件下所采用的算法也是完全不同的.因为一旦出现Data
Dependency也就意味着并行计算模块之间需要进行通信.从以计算节点为单位的分布式并行,到多核CPU上的Numa结构,到SIMD上的向量处
理器,其计算单元之间的通信手段,通信效率简直天差地别.比如说,在SMP上最常见的并行算法,work stealing也就是Intel的TBB,
是建立在两个条件下第一个是CPU的Cache机制上,这使得通常在内存的之间的数据搬运消耗非常小,第二个是SMP上计算单元相对的少,因此每个计算
单元被分配到的任务就相对的重。其开销远远大于通信的开销,因此这种机制在SMP上相对的划算.但是如果你要在GPU上做Work Stealing就
完全不可行,因为GPU的运算单元数量极多,被分配到的任务就相对来说的非常轻量,CUDA上的一个thread很多时候运算一次的时间不会超过
10us,而一次跨Block的线程之间的通信开销就往往要达到100us左右,再加上目前GPU上的Cache机制非常落后导致了需要频繁的通信开销
的Work Stealing在GPU上是非常不划算得.
所以我个人认为在硬件架构没有更多的突破之前,OpenCL这种东西是没有任何生命力的.不要说CPU的并行与GPU之间差异巨大,就是不同的GPU之
间AMD与Nvidia两个也是各自为政,一个平台上跑得非常快的东西,在另外一个平台极大的可能是龟速.其最终的结果估计就是跟Java的
write once run everywhere一样是个大笑话.</p>
<p>On 3月22日, 下午2时06分, Guancheng Chen <a href="&#x6d;&#x61;&#x69;&#x6c;&#116;&#111;&#x3a;&#91;&#x63;&#x68;&#x65;&#110;&#x67;&#x75;&#97;&#110;&#x63;&#104;&#x2e;&#46;&#46;&#x40;&#103;&#109;&#97;&#x69;&#108;&#x2e;&#99;&#111;&#109;&#x5d;&#x28;&#x29;">&#91;&#x63;&#x68;&#x65;&#110;&#x67;&#x75;&#97;&#110;&#x63;&#104;&#x2e;&#46;&#46;&#x40;&#103;&#109;&#97;&#x69;&#108;&#x2e;&#99;&#111;&#109;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>On 3月22日, 上午2时20分, Tinyfool <a href="&#x6d;&#x61;&#105;&#108;&#x74;&#x6f;&#x3a;&#91;&#116;&#x69;&#110;&#121;&#x66;&#46;&#x2e;&#46;&#x40;&#x67;&#109;&#97;&#105;&#108;&#x2e;&#x63;&#x6f;&#109;&#93;&#x28;&#41;">&#91;&#116;&#x69;&#110;&#121;&#x66;&#46;&#x2e;&#46;&#x40;&#x67;&#109;&#97;&#105;&#108;&#x2e;&#x63;&#x6f;&#109;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#109;&#97;&#105;&#108;&#116;&#x6f;&#58;&#x5b;&#106;&#x65;&#46;&#x2e;&#46;&#x40;&#x6c;&#105;&#118;&#101;&#x2e;&#x63;&#111;&#109;&#93;&#x28;&#41;">&#x5b;&#106;&#x65;&#46;&#x2e;&#46;&#x40;&#x6c;&#105;&#118;&#101;&#x2e;&#x63;&#111;&#109;&#93;&#x28;&#41;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#109;&#97;&#x69;&#x6c;&#116;&#x6f;&#x3a;&#x5b;&#x63;&#x68;&#101;&#110;&#103;&#x75;&#97;&#x6e;&#99;&#x68;&#46;&#46;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#93;&#40;&#41;">&#x5b;&#x63;&#x68;&#101;&#110;&#103;&#x75;&#97;&#x6e;&#99;&#x68;&#46;&#46;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#93;&#40;&#41;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#x6d;&#97;&#105;&#108;&#116;&#x6f;&#x3a;&#91;&#x70;&#x6f;&#x6e;&#x2e;&#x2e;&#x2e;&#64;&#103;&#x6f;&#x6f;&#x67;&#108;&#101;&#103;&#x72;&#x6f;&#117;&#112;&#115;&#46;&#99;&#x6f;&#109;&#93;&#40;&#41;">&#91;&#x70;&#x6f;&#x6e;&#x2e;&#x2e;&#x2e;&#64;&#103;&#x6f;&#x6f;&#x67;&#108;&#101;&#103;&#x72;&#x6f;&#117;&#112;&#115;&#46;&#99;&#x6f;&#109;&#93;&#40;&#41;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发</p>
</li>
</ol>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>...</p>
<p>阅读更多 &gt;&gt;
<a href="">显示删减掉的内容</a>
<img src="" alt=""> Alleluia <img src="" alt=""></p>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-23</p>
<p>其他收件人：</p>
<p>我当初就不看好Larrabee这个东西,想想一个Core上一个Decoder就要消耗1瓦的功率,32个捆起来这个Core的功率要多大啊.我觉得
一捆Arm棒在一起都比PII靠谱.</p>
<p>On 3月23日, 上午5时41分, windstorm <a href="&#109;&#97;&#x69;&#x6c;&#116;&#x6f;&#x3a;&#x5b;&#x6c;&#x69;&#107;&#x75;&#x6e;&#x61;&#114;&#x6d;&#x73;&#x74;&#114;&#46;&#46;&#46;&#x40;&#x67;&#109;&#97;&#x69;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#x28;&#x29;">&#x5b;&#x6c;&#x69;&#107;&#x75;&#x6e;&#x61;&#114;&#x6d;&#x73;&#x74;&#114;&#46;&#46;&#46;&#x40;&#x67;&#109;&#97;&#x69;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>Larrabee当初我还是很看好的，它的架构比其他的更像一个统一的方案，可惜后来Intel自己经验不足搞不好。</p>
<p>OPENCL还是主要面向multimedia吧，CUDA/OpenCL在业界代表了流处理的方向，从GPU针对任务的角度讲是好的。其他的就算了。就像Al leluia说的那样，在硬件架构没有更多的突破之前，不说没有生命力，至少想取得任何进一步的突破都太难。</p>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>现在这个领域，你吹你的水，我吹我的水。至于谁的泡泡大，我看不清。所以真要选东西学，最好还是针对自己的application选靠谱。这也是并行编程教育难 的问题。大家需求完全不一样。</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Guancheng Chen <a href="&#109;&#97;&#x69;&#108;&#116;&#111;&#58;&#91;&#99;&#x68;&#101;&#110;&#103;&#x75;&#x61;&#x6e;&#x63;&#104;&#46;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#46;&#x63;&#x6f;&#109;&#x5d;&#x28;&#41;">&#91;&#99;&#x68;&#101;&#110;&#103;&#x75;&#x61;&#x6e;&#x63;&#104;&#46;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#46;&#x63;&#x6f;&#109;&#x5d;&#x28;&#41;</a>:</p>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>&gt;
&gt;
&gt;</p>
<blockquote>
<blockquote>
<p>我觉得现有的OpenCL确实非常不成熟，但是从纯性能角度上来讲，我看好Heterogeneous架构，尽管它们的编程难度太大，就像前面提到的不
同架构需要做不同优化等。CPU的性能是latency-oriented，GPU是throughput-oriented,Intel的
Larrabee虽然现在来看不成功，但是业界都在朝着那个方向努力。</p>
<p>On 3月22日, 下午6时18分, windstorm <a href="&#109;&#97;&#x69;&#108;&#116;&#111;&#x3a;&#x5b;&#x6c;&#105;&#107;&#x75;&#x6e;&#x61;&#114;&#109;&#x73;&#x74;&#114;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#97;&#x69;&#108;&#46;&#99;&#111;&#x6d;&#x5d;&#40;&#x29;">&#x5b;&#x6c;&#105;&#107;&#x75;&#x6e;&#x61;&#114;&#109;&#x73;&#x74;&#114;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#97;&#x69;&#108;&#46;&#99;&#111;&#x6d;&#x5d;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>实在是不能同意你更多......很早很早以前我就在这里和人争论过，GPU的并行计算平台不可能一统天下的。CUDA也不是救世主。OpenCL更不是。</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Alleluia <a href="&#109;&#x61;&#105;&#108;&#x74;&#x6f;&#58;&#91;&#x61;&#x6c;&#x6c;&#x75;&#108;&#46;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#99;&#111;&#109;&#93;&#x28;&#41;">&#91;&#x61;&#x6c;&#x6c;&#x75;&#108;&#46;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#99;&#111;&#109;&#93;&#x28;&#41;</a>:</p>
<blockquote>
<p>Parallelism 说到底是算法问题.Parallelism与Concurrency不同,Concurrency所面对的问题相对的单一可以
让一群有经验的专家来实现一套通用库或者语言来提供一个基本的编程框架.而在Parallelism上,具体的不同问题,其所需要并行的算法是根本不同
的.原因在于不同的问题,其内部的DataDependency的结构完全不同,不同的Data Dependency的结构,需要构造不同的算法.即
便是相同的Data Dependency,在不同的颗粒度下，在不同的硬件条件下所采用的算法也是完全不同的.因为一旦出现Data
Dependency也就意味着并行计算模块之间需要进行通信.从以计算节点为单位的分布式并行,到多核CPU上的Numa结构,到SIMD上的向量处
理器,其计算单元之间的通信手段,通信效率简直天差地别.比如说,在SMP上最常见的并行算法,work stealing也就是Intel的TBB,
是建立在两个条件下第一个是CPU的Cache机制上,这使得通常在内存的之间的数据搬运消耗非常小,第二个是SMP上计算单元相对的少,因此每个计算
单元被分配到的任务就相对的重。其开销远远大于通信的开销,因此这种机制在SMP上相对的划算.但是如果你要在GPU上做Work Stealing就
完全不可行,因为GPU的运算单元数量极多,被分配到的任务就相对来说的非常轻量,CUDA上的一个thread很多时候运算一次的时间不会超过
10us,而一次跨Block的线程之间的通信开销就往往要达到100us左右,再加上目前GPU上的Cache机制非常落后导致了需要频繁的通信开销
的Work Stealing在GPU上是非常不划算得.
所以我个人认为在硬件架构没有更多的突破之前,OpenCL这种东西是没有任何生命力的.不要说CPU的并行与GPU之间差异巨大,就是不同的GPU之
间AMD与Nvidia两个也是各自为政,一个平台上跑得非常快的东西,在另外一个平台极大的可能是龟速.其最终的结果估计就是跟Java的
write once run everywhere一样是个大笑话.</p>
<p>On 3月22日, 下午2时06分, Guancheng Chen <a href="&#109;&#x61;&#105;&#x6c;&#x74;&#x6f;&#58;&#x5b;&#99;&#104;&#x65;&#x6e;&#103;&#x75;&#97;&#x6e;&#99;&#104;&#x2e;&#46;&#46;&#64;&#103;&#109;&#x61;&#x69;&#108;&#46;&#99;&#111;&#x6d;&#93;&#40;&#41;">&#x5b;&#99;&#104;&#x65;&#x6e;&#103;&#x75;&#97;&#x6e;&#99;&#104;&#x2e;&#46;&#46;&#64;&#103;&#109;&#x61;&#x69;&#108;&#46;&#99;&#111;&#x6d;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>On 3月22日, 上午2时20分, Tinyfool <a href="&#109;&#97;&#x69;&#x6c;&#x74;&#x6f;&#x3a;&#x5b;&#116;&#105;&#x6e;&#x79;&#x66;&#46;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#97;&#105;&#x6c;&#x2e;&#x63;&#111;&#109;&#93;&#40;&#41;">&#x5b;&#116;&#105;&#x6e;&#x79;&#x66;&#46;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#97;&#105;&#x6c;&#x2e;&#x63;&#111;&#109;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#109;&#97;&#x69;&#108;&#116;&#x6f;&#58;&#91;&#x6a;&#x65;&#46;&#46;&#46;&#64;&#x6c;&#x69;&#x76;&#101;&#x2e;&#99;&#x6f;&#x6d;&#93;&#x28;&#41;">&#91;&#x6a;&#x65;&#46;&#46;&#46;&#64;&#x6c;&#x69;&#x76;&#101;&#x2e;&#99;&#x6f;&#x6d;&#93;&#x28;&#41;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#x6d;&#97;&#105;&#x6c;&#x74;&#x6f;&#x3a;&#91;&#99;&#104;&#101;&#110;&#103;&#x75;&#x61;&#110;&#x63;&#104;&#46;&#x2e;&#46;&#64;&#x67;&#x6d;&#x61;&#x69;&#108;&#x2e;&#99;&#111;&#x6d;&#93;&#x28;&#41;">&#91;&#99;&#104;&#101;&#110;&#103;&#x75;&#x61;&#110;&#x63;&#104;&#46;&#x2e;&#46;&#64;&#x67;&#x6d;&#x61;&#x69;&#108;&#x2e;&#99;&#111;&#x6d;&#93;&#x28;&#41;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#109;&#x61;&#105;&#x6c;&#116;&#x6f;&#x3a;&#x5b;&#x70;&#111;&#110;&#46;&#46;&#46;&#64;&#x67;&#111;&#x6f;&#x67;&#108;&#x65;&#103;&#114;&#111;&#117;&#x70;&#x73;&#x2e;&#99;&#111;&#109;&#93;&#40;&#x29;">&#x5b;&#x70;&#111;&#110;&#46;&#46;&#46;&#64;&#x67;&#111;&#x6f;&#x67;&#108;&#x65;&#103;&#114;&#111;&#117;&#x70;&#x73;&#x2e;&#99;&#111;&#109;&#93;&#40;&#x29;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>...</p>
<p>阅读更多 &gt;&gt;
<a href="">显示删减掉的内容</a></p>
</blockquote>
<p><img src="" alt=""> windstorm <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-23</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>显然不是简单捆绑那么简单阿。</p>
<p>而且我看好它，并不是它将来会一统天下，而是说它相对革命性的架构部分程度上满足了线程完备，从而扩展了GPU的使用领域，所以我看好以它为代表的这种架构的发展。同类型的还有Sun当年的Rock和Niagara
1/2</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p><a href="http://www.kunli.info/" target="_blank">www.kunli.info</a>
<a href="http://twitter.com/cnbuff" target="_blank"><a href="http://twitter.com/cnbuff">http://twitter.com/cnbuff</a></a></p>
<p>2010/3/22 Alleluia <a href="&#x6d;&#x61;&#105;&#x6c;&#116;&#111;&#58;&#91;&#97;&#x6c;&#x6c;&#117;&#x2e;&#46;&#46;&#x40;&#103;&#109;&#97;&#105;&#x6c;&#46;&#99;&#111;&#109;&#x5d;&#x28;&#41;">&#91;&#97;&#x6c;&#x6c;&#117;&#x2e;&#46;&#46;&#x40;&#103;&#109;&#97;&#105;&#x6c;&#46;&#99;&#111;&#109;&#x5d;&#x28;&#41;</a>:</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<blockquote>
<p>我当初就不看好Larrabee这个东西,想想一个Core上一个Decoder就要消耗1瓦的功率,32个捆起来这个Core的功率要多大啊.我觉得
一捆Arm棒在一起都比PII靠谱.</p>
<p>On 3月23日, 上午5时41分, windstorm <a href="&#x6d;&#x61;&#x69;&#x6c;&#116;&#111;&#58;&#91;&#108;&#105;&#107;&#117;&#110;&#97;&#114;&#109;&#x73;&#116;&#114;&#x2e;&#x2e;&#46;&#64;&#x67;&#109;&#97;&#105;&#108;&#x2e;&#x63;&#x6f;&#109;&#93;&#x28;&#x29;">&#91;&#108;&#105;&#107;&#117;&#110;&#97;&#114;&#109;&#x73;&#116;&#114;&#x2e;&#x2e;&#46;&#64;&#x67;&#109;&#97;&#105;&#108;&#x2e;&#x63;&#x6f;&#109;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>Larrabee当初我还是很看好的，它的架构比其他的更像一个统一的方案，可惜后来Intel自己经验不足搞不好。</p>
<p>OPENCL还是主要面向multimedia吧，CUDA/OpenCL在业界代表了流处理的方向，从GPU针对任务的角度讲是好的。其他的就算了。就像Al leluia说的那样，在硬件架构没有更多的突破之前，不说没有生命力，至少想取得任何进一步的突破都太难。</p>
<p>现在这个领域，你吹你的水，我吹我的水。至于谁的泡泡大，我看不清。所以真要选东西学，最好还是针对自己的application选靠谱。这也是并行编程教育难 的问题。大家需求完全不一样。</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Guancheng Chen <a href="&#x6d;&#97;&#x69;&#x6c;&#116;&#111;&#x3a;&#91;&#99;&#104;&#x65;&#x6e;&#103;&#x75;&#x61;&#110;&#99;&#104;&#46;&#x2e;&#46;&#x40;&#x67;&#109;&#97;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#40;&#41;">&#91;&#99;&#104;&#x65;&#x6e;&#103;&#x75;&#x61;&#110;&#99;&#104;&#46;&#x2e;&#46;&#x40;&#x67;&#109;&#97;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#40;&#41;</a>:</p>
<blockquote>
<p>我觉得现有的OpenCL确实非常不成熟，但是从纯性能角度上来讲，我看好Heterogeneous架构，尽管它们的编程难度太大，就像前面提到的不
同架构需要做不同优化等。CPU的性能是latency-oriented，GPU是throughput-oriented,Intel的
Larrabee虽然现在来看不成功，但是业界都在朝着那个方向努力。</p>
<p>On 3月22日, 下午6时18分, windstorm <a href="&#x6d;&#x61;&#x69;&#108;&#116;&#111;&#x3a;&#91;&#x6c;&#105;&#107;&#117;&#x6e;&#97;&#x72;&#109;&#x73;&#x74;&#x72;&#x2e;&#x2e;&#46;&#64;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#46;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#41;">&#91;&#x6c;&#105;&#107;&#117;&#x6e;&#97;&#x72;&#109;&#x73;&#x74;&#x72;&#x2e;&#x2e;&#46;&#64;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#46;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>实在是不能同意你更多......很早很早以前我就在这里和人争论过，GPU的并行计算平台不可能一统天下的。CUDA也不是救世主。OpenCL更不是。</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Alleluia <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#x3a;&#x5b;&#x61;&#x6c;&#108;&#117;&#108;&#46;&#x2e;&#46;&#64;&#103;&#x6d;&#x61;&#105;&#x6c;&#46;&#99;&#111;&#109;&#x5d;&#40;&#41;">&#x5b;&#x61;&#x6c;&#108;&#117;&#108;&#46;&#x2e;&#46;&#64;&#103;&#x6d;&#x61;&#105;&#x6c;&#46;&#99;&#111;&#109;&#x5d;&#40;&#41;</a>:</p>
<blockquote>
<p>Parallelism 说到底是算法问题.Parallelism与Concurrency不同,Concurrency所面对的问题相对的单一可以
让一群有经验的专家来实现一套通用库或者语言来提供一个基本的编程框架.而在Parallelism上,具体的不同问题,其所需要并行的算法是根本不同
的.原因在于不同的问题,其内部的DataDependency的结构完全不同,不同的Data Dependency的结构,需要构造不同的算法.即
便是相同的Data Dependency,在不同的颗粒度下，在不同的硬件条件下所采用的算法也是完全不同的.因为一旦出现Data
Dependency也就意味着并行计算模块之间需要进行通信.从以计算节点为单位的分布式并行,到多核CPU上的Numa结构,到SIMD上的向量处
理器,其计算单元之间的通信手段,通信效率简直天差地别.比如说,在SMP上最常见的并行算法,work stealing也就是Intel的TBB,
是建立在两个条件下第一个是CPU的Cache机制上,这使得通常在内存的之间的数据搬运消耗非常小,第二个是SMP上计算单元相对的少,因此每个计算
单元被分配到的任务就相对的重。其开销远远大于通信的开销,因此这种机制在SMP上相对的划算.但是如果你要在GPU上做Work Stealing就
完全不可行,因为GPU的运算单元数量极多,被分配到的任务就相对来说的非常轻量,CUDA上的一个thread很多时候运算一次的时间不会超过
10us,而一次跨Block的线程之间的通信开销就往往要达到100us左右,再加上目前GPU上的Cache机制非常落后导致了需要频繁的通信开销
的Work Stealing在GPU上是非常不划算得.
所以我个人认为在硬件架构没有更多的突破之前,OpenCL这种东西是没有任何生命力的.不要说CPU的并行与GPU之间差异巨大,就是不同的GPU之
间AMD与Nvidia两个也是各自为政,一个平台上跑得非常快的东西,在另外一个平台极大的可能是龟速.其最终的结果估计就是跟Java的
write once run everywhere一样是个大笑话.</p>
<p>On 3月22日, 下午2时06分, Guancheng Chen <a href="&#109;&#97;&#x69;&#x6c;&#x74;&#x6f;&#x3a;&#91;&#x63;&#104;&#x65;&#x6e;&#103;&#x75;&#x61;&#x6e;&#x63;&#x68;&#x2e;&#x2e;&#46;&#64;&#x67;&#109;&#97;&#x69;&#108;&#46;&#99;&#111;&#109;&#93;&#x28;&#41;">&#91;&#x63;&#104;&#x65;&#x6e;&#103;&#x75;&#x61;&#x6e;&#x63;&#x68;&#x2e;&#x2e;&#46;&#64;&#x67;&#109;&#97;&#x69;&#108;&#46;&#99;&#111;&#109;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>On 3月22日, 上午2时20分, Tinyfool <a href="&#109;&#x61;&#105;&#x6c;&#x74;&#x6f;&#58;&#x5b;&#116;&#x69;&#110;&#121;&#x66;&#46;&#x2e;&#46;&#x40;&#103;&#109;&#x61;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#109;&#93;&#40;&#x29;">&#x5b;&#116;&#x69;&#110;&#121;&#x66;&#46;&#x2e;&#46;&#x40;&#103;&#109;&#x61;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#109;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#x6d;&#97;&#105;&#108;&#116;&#x6f;&#x3a;&#91;&#x6a;&#x65;&#x2e;&#x2e;&#x2e;&#64;&#108;&#x69;&#118;&#x65;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#x29;">&#91;&#x6a;&#x65;&#x2e;&#x2e;&#x2e;&#64;&#108;&#x69;&#118;&#x65;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#x29;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#109;&#x61;&#x69;&#108;&#x74;&#x6f;&#x3a;&#91;&#99;&#104;&#101;&#110;&#103;&#117;&#x61;&#x6e;&#x63;&#104;&#46;&#46;&#x2e;&#64;&#x67;&#x6d;&#x61;&#x69;&#108;&#x2e;&#99;&#111;&#109;&#93;&#x28;&#41;">&#91;&#99;&#104;&#101;&#110;&#103;&#117;&#x61;&#x6e;&#x63;&#104;&#46;&#46;&#x2e;&#64;&#x67;&#x6d;&#x61;&#x69;&#108;&#x2e;&#99;&#111;&#109;&#93;&#x28;&#41;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#109;&#97;&#x69;&#108;&#116;&#x6f;&#x3a;&#91;&#112;&#111;&#110;&#46;&#x2e;&#46;&#x40;&#x67;&#111;&#111;&#x67;&#x6c;&#x65;&#x67;&#114;&#111;&#x75;&#112;&#115;&#46;&#99;&#x6f;&#x6d;&#93;&#x28;&#x29;">&#91;&#112;&#111;&#110;&#46;&#x2e;&#46;&#x40;&#x67;&#111;&#111;&#x67;&#x6c;&#x65;&#x67;&#114;&#111;&#x75;&#112;&#115;&#46;&#99;&#x6f;&#x6d;&#93;&#x28;&#x29;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>...</p>
<p>阅读更多 &gt;&gt;</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p><a href="">显示删减掉的内容</a>
<img src="" alt=""> windstorm <img src="" alt=""></p>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-23</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>女生？LJJ？</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p><a href="http://www.kunli.info/" target="_blank">www.kunli.info</a>
<a href="http://twitter.com/cnbuff" target="_blank"><a href="http://twitter.com/cnbuff">http://twitter.com/cnbuff</a></a></p>
<p>2010/3/22 Guancheng Chen <a href="&#109;&#x61;&#105;&#x6c;&#116;&#x6f;&#58;&#x5b;&#99;&#x68;&#x65;&#x6e;&#x67;&#117;&#46;&#46;&#46;&#x40;&#x67;&#109;&#97;&#105;&#x6c;&#46;&#99;&#111;&#x6d;&#93;&#40;&#41;">&#x5b;&#99;&#x68;&#x65;&#x6e;&#x67;&#117;&#46;&#46;&#46;&#x40;&#x67;&#109;&#97;&#105;&#x6c;&#46;&#99;&#111;&#x6d;&#93;&#40;&#41;</a>:</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<blockquote>
<p>恩</p>
<p>第二点其实我就是指程序员根据他自己的程序领域选择合适的并行技术。Top Language真是藏龙卧虎啊。你是在Boulder么?我一个大学女同
学在你那读MIS的phd</p>
<p>On 3月23日, 上午12时04分, windstorm <a href="&#x6d;&#97;&#105;&#x6c;&#116;&#x6f;&#x3a;&#x5b;&#x6c;&#x69;&#x6b;&#117;&#110;&#97;&#114;&#109;&#115;&#x74;&#x72;&#x2e;&#46;&#x2e;&#x40;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#x6d;&#93;&#x28;&#x29;">&#x5b;&#x6c;&#x69;&#x6b;&#117;&#110;&#97;&#114;&#109;&#115;&#x74;&#x72;&#x2e;&#46;&#x2e;&#x40;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#x6d;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>全民并行编程的时代，只有在全民能够并行编程的时候才会到来嘛，现在不是这个时候</p>
<p>我个人倾向于等待一个比较好的统一性架构。两条路：</p>
<p>一是某一个全新概念的提出，这个要看学术界的努力，而且在某种意义上讲，学术界搞出一个真正可行的并行架构的可能性比工业界更高。虽说今天多核的发展是工业界引 领的，但是点子还是最早学术界提出的。典型的有几个：斯坦福的Hydra（1996），斯坦福的Imagine(2000)，MIT的RAW（2002），以及 UT奥斯丁的TRIPS（2003）。在这个问题上，是不得不佩服美国的创造力，要知道直到在2000年左右，所有的人都还在为处理器频率按照摩尔定律翻翻而狂 热，美国的顶尖研究员就早已看到了这条路的尽头并指出未来处理器的发展之路。</p>
<p>二是你用现有的架构，但是application引导。如果要找一个面向多application
domain的话，刚才说了，本来看好Larrabee，因为它的架构解决了CUDA一个很大的潜在问题，而且允许现有程序员不经过任何特殊training就 上手编程，包括图形图像，科学计算，或者网络处理，各个领域。</p>
<p>不过可能就是因为这个solution的过于理想化导致结构的过于复杂化，才让其目前暂时流产。</p>
<p>总的来说，现在的问题就是软件发展不成熟，硬件发展不完善，你没法靠程序员决定使用什么并行技术，完全靠应用主导，这套技术在这个应用上如鱼得水，在那个应用上 完全不罩，作为程序员，有什么办法？</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Guancheng Chen <a href="&#x6d;&#x61;&#105;&#x6c;&#x74;&#111;&#x3a;&#91;&#x63;&#104;&#x65;&#x6e;&#x67;&#x75;&#97;&#110;&#99;&#x68;&#46;&#46;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#40;&#41;">&#91;&#x63;&#104;&#x65;&#x6e;&#x67;&#x75;&#97;&#110;&#99;&#x68;&#46;&#46;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#40;&#41;</a>:</p>
<blockquote>
<p>教育以人为本，最终决定使用何种并行技术的还是程序员。目前业界对程序员并没有并行编程的技能要求，全民并行编程的时代什么时候才能到来？这是个问
题。</p>
<p>On 3月22日, 下午10时41分, windstorm <a href="&#109;&#x61;&#105;&#x6c;&#x74;&#111;&#58;&#x5b;&#108;&#x69;&#107;&#117;&#x6e;&#x61;&#114;&#x6d;&#x73;&#x74;&#x72;&#x2e;&#x2e;&#46;&#64;&#x67;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#99;&#111;&#109;&#x5d;&#x28;&#x29;">&#x5b;&#108;&#x69;&#107;&#117;&#x6e;&#x61;&#114;&#x6d;&#x73;&#x74;&#x72;&#x2e;&#x2e;&#46;&#64;&#x67;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#99;&#111;&#109;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>Larrabee当初我还是很看好的，它的架构比其他的更像一个统一的方案，可惜后来Intel自己经验不足搞不好。</p>
<p>OPENCL还是主要面向multimedia吧，CUDA/OpenCL在业界代表了流处理的方向，从GPU针对任务的角度讲是好的。其他的就算了。就像Al leluia说的那样，在硬件架构没有更多的突破之前，不说没有生命力，至少想取得任何进一步的突破都太难。</p>
<p>现在这个领域，你吹你的水，我吹我的水。至于谁的泡泡大，我看不清。所以真要选东西学，最好还是针对自己的application选靠谱。这也是并行编程教育难 的问题。大家需求完全不一样。</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Guancheng Chen <a href="&#x6d;&#x61;&#105;&#108;&#116;&#x6f;&#58;&#x5b;&#x63;&#104;&#x65;&#x6e;&#x67;&#x75;&#x61;&#x6e;&#99;&#104;&#x2e;&#46;&#46;&#x40;&#x67;&#x6d;&#97;&#105;&#x6c;&#46;&#99;&#111;&#x6d;&#x5d;&#x28;&#41;">&#x5b;&#x63;&#104;&#x65;&#x6e;&#x67;&#x75;&#x61;&#x6e;&#99;&#104;&#x2e;&#46;&#46;&#x40;&#x67;&#x6d;&#97;&#105;&#x6c;&#46;&#99;&#111;&#x6d;&#x5d;&#x28;&#41;</a>:</p>
<blockquote>
<p>我觉得现有的OpenCL确实非常不成熟，但是从纯性能角度上来讲，我看好Heterogeneous架构，尽管它们的编程难度太大，就像前面提到的不
同架构需要做不同优化等。CPU的性能是latency-oriented，GPU是throughput-oriented,Intel的
Larrabee虽然现在来看不成功，但是业界都在朝着那个方向努力。</p>
<p>On 3月22日, 下午6时18分, windstorm <a href="&#109;&#97;&#105;&#108;&#x74;&#x6f;&#58;&#x5b;&#x6c;&#x69;&#x6b;&#x75;&#110;&#x61;&#114;&#109;&#115;&#x74;&#x72;&#x2e;&#46;&#x2e;&#x40;&#103;&#109;&#97;&#105;&#x6c;&#46;&#99;&#111;&#x6d;&#x5d;&#40;&#41;">&#x5b;&#x6c;&#x69;&#x6b;&#x75;&#110;&#x61;&#114;&#109;&#115;&#x74;&#x72;&#x2e;&#46;&#x2e;&#x40;&#103;&#109;&#97;&#105;&#x6c;&#46;&#99;&#111;&#x6d;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>实在是不能同意你更多......很早很早以前我就在这里和人争论过，GPU的并行计算平台不可能一统天下的。CUDA也不是救世主。OpenCL更不是。</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Alleluia <a href="&#x6d;&#x61;&#x69;&#x6c;&#116;&#x6f;&#x3a;&#91;&#x61;&#108;&#108;&#117;&#x6c;&#46;&#46;&#46;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#x6f;&#109;&#x5d;&#40;&#x29;">&#91;&#x61;&#108;&#108;&#117;&#x6c;&#46;&#46;&#46;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#x6f;&#109;&#x5d;&#40;&#x29;</a>:</p>
<blockquote>
<p>Parallelism 说到底是算法问题.Parallelism与Concurrency不同,Concurrency所面对的问题相对的单一可以
让一群有经验的专家来实现一套通用库或者语言来提供一个基本的编程框架.而在Parallelism上,具体的不同问题,其所需要并行的算法是根本不同
的.原因在于不同的问题,其内部的DataDependency的结构完全不同,不同的Data Dependency的结构,需要构造不同的算法.即
便是相同的Data Dependency,在不同的颗粒度下，在不同的硬件条件下所采用的算法也是完全不同的.因为一旦出现Data
Dependency也就意味着并行计算模块之间需要进行通信.从以计算节点为单位的分布式并行,到多核CPU上的Numa结构,到SIMD上的向量处
理器,其计算单元之间的通信手段,通信效率简直天差地别.比如说,在SMP上最常见的并行算法,work stealing也就是Intel的TBB,
是建立在两个条件下第一个是CPU的Cache机制上,这使得通常在内存的之间的数据搬运消耗非常小,第二个是SMP上计算单元相对的少,因此每个计算
单元被分配到的任务就相对的重。其开销远远大于通信的开销,因此这种机制在SMP上相对的划算.但是如果你要在GPU上做Work Stealing就
完全不可行,因为GPU的运算单元数量极多,被分配到的任务就相对来说的非常轻量,CUDA上的一个thread很多时候运算一次的时间不会超过
10us,而一次跨Block的线程之间的通信开销就往往要达到100us左右,再加上目前GPU上的Cache机制非常落后导致了需要频繁的通信开销
的Work Stealing在GPU上是非常不划算得.
所以我个人认为在硬件架构没有更多的突破之前,OpenCL这种东西是没有任何生命力的.不要说CPU的并行与GPU之间差异巨大,就是不同的GPU之
间AMD与Nvidia两个也是各自为政,一个平台上跑得非常快的东西,在另外一个平台极大的可能是龟速.其最终的结果估计就是跟Java的
write once run everywhere一样是个大笑话.</p>
<p>On 3月22日, 下午2时06分, Guancheng Chen <a href="&#x6d;&#x61;&#x69;&#108;&#116;&#111;&#x3a;&#x5b;&#x63;&#x68;&#101;&#x6e;&#x67;&#117;&#x61;&#x6e;&#x63;&#x68;&#x2e;&#46;&#x2e;&#64;&#x67;&#109;&#x61;&#105;&#108;&#x2e;&#99;&#x6f;&#x6d;&#93;&#x28;&#41;">&#x5b;&#x63;&#x68;&#101;&#x6e;&#x67;&#117;&#x61;&#x6e;&#x63;&#x68;&#x2e;&#46;&#x2e;&#64;&#x67;&#109;&#x61;&#105;&#108;&#x2e;&#99;&#x6f;&#x6d;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>On 3月22日, 上午2时20分, Tinyfool <a href="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#111;&#58;&#91;&#116;&#x69;&#x6e;&#x79;&#x66;&#x2e;&#x2e;&#46;&#64;&#103;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#93;&#40;&#x29;">&#91;&#116;&#x69;&#x6e;&#x79;&#x66;&#x2e;&#x2e;&#46;&#64;&#103;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#109;&#97;&#105;&#x6c;&#116;&#111;&#58;&#91;&#x6a;&#101;&#46;&#46;&#46;&#64;&#x6c;&#105;&#118;&#101;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#41;">&#91;&#x6a;&#101;&#46;&#46;&#46;&#64;&#x6c;&#105;&#118;&#101;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#41;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#109;&#97;&#x69;&#x6c;&#116;&#x6f;&#x3a;&#x5b;&#x63;&#x68;&#101;&#110;&#103;&#117;&#x61;&#x6e;&#99;&#104;&#46;&#x2e;&#46;&#x40;&#103;&#x6d;&#97;&#x69;&#108;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#x28;&#41;">&#x5b;&#x63;&#x68;&#101;&#110;&#103;&#117;&#x61;&#x6e;&#99;&#104;&#46;&#x2e;&#46;&#x40;&#103;&#x6d;&#97;&#x69;&#108;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#x28;&#41;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#109;&#97;&#x69;&#108;&#116;&#x6f;&#x3a;&#91;&#x70;&#111;&#110;&#46;&#46;&#46;&#x40;&#103;&#x6f;&#111;&#x67;&#108;&#x65;&#103;&#114;&#x6f;&#117;&#x70;&#115;&#46;&#99;&#x6f;&#x6d;&#x5d;&#40;&#x29;">&#91;&#x70;&#111;&#110;&#46;&#46;&#46;&#x40;&#103;&#x6f;&#111;&#x67;&#108;&#x65;&#103;&#114;&#x6f;&#117;&#x70;&#115;&#46;&#99;&#x6f;&#x6d;&#x5d;&#40;&#x29;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器...</li>
</ol>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>阅读更多 &gt;&gt;</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p><a href="">显示删减掉的内容</a></p>
</blockquote>
<p><img src="" alt=""> SevenCat <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-23</p>
<p>其他收件人：</p>
<p>大家在什么项目上用到并行编程？
<a href="">显示删减掉的内容</a>
<img src="" alt=""> qiaojie <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-23</p>
<p>其他收件人：</p>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1) = 5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？
<a href="">显示删减掉的内容</a></p>
<p><img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-23</p>
<p>其他收件人：</p>
<p>多谢大牛指教。我之所以提到并行化循环，是因为我以前实习过的公司的解决方案就是以data parallel模型的把循环并行化为主，其实新编写的代
码也可以用他们的技术。我之所以要提到遗留代码，是因为如果针对只对遗留代码的循环进行并行化就已经能取得比较可观的speedup(如果本身该循环是
热点，经过一些指导被程序员正确改成independent的之后即可并行化)，同时又不会引入太多的并行编程的复杂度。我原来测试它的时候一般1-3
个小时就能出结果，speedup在1.2~1.6之间(dual core, quad core 2.X)。</p>
<p>另外想请教您的实际工作中一般适用什么样的并行算法？任务分解(如TBB)？还是数据分解？</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>On 3月23日, 上午3时09分, Alleluia <a href="&#109;&#x61;&#105;&#108;&#116;&#111;&#x3a;&#x5b;&#x61;&#x6c;&#108;&#x75;&#108;&#x2e;&#46;&#x2e;&#x40;&#103;&#x6d;&#x61;&#105;&#x6c;&#46;&#99;&#111;&#x6d;&#93;&#x28;&#41;">&#x5b;&#x61;&#x6c;&#108;&#x75;&#108;&#x2e;&#46;&#x2e;&#x40;&#103;&#x6d;&#x61;&#105;&#x6c;&#46;&#99;&#111;&#x6d;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>我不是搞体系结构的.但是我认为目前来说做Parallelism的人首先不是去熟悉什么API或者Libarary,而是要熟悉两样东西体系结构和算
法.没有这两样,几乎写不出什么高效率的并行程序.当然你的需求只是并行化循环这种简单的东西当然可以里例外.呵呵.
我觉得你最好放弃用GPGPU去搞遗留代码的想法.现在市面上的GPU产品无论是A记的还是N记的其编程架构与CPU完全不同,你不要想把一个循环简单
的porting到GPU上就能并行了.那是几乎不可能的,比如最简单的你如何处理branch?如果branch非常多,divergence会把速
度拖得比CPU版本还慢.你如何处理CPU代码里的数组随机访问,在GPU上无论是片上的还是片外的内存是不能随机访问的,最要命的是没有cache,
随机访问的代价极其高昂.你几乎需要把CPU上的代码面目全非地从新写一遍,遗留代码除了用作调试测试做结果比对之外几乎要全部抛弃.</p>
<p>On 3月23日, 上午6时42分, Guancheng Chen <a href="&#109;&#x61;&#x69;&#108;&#x74;&#x6f;&#58;&#x5b;&#99;&#x68;&#x65;&#110;&#103;&#x75;&#x61;&#110;&#x63;&#104;&#x2e;&#x2e;&#46;&#64;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#46;&#99;&#x6f;&#109;&#x5d;&#x28;&#41;">&#x5b;&#99;&#x68;&#x65;&#110;&#103;&#x75;&#x61;&#110;&#x63;&#104;&#x2e;&#x2e;&#46;&#64;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#46;&#99;&#x6f;&#109;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>恩 您也是搞体系结构的么？
现在我在跟瑞典这边的爱立信合作做毕设 不过对象不是他们的Erlang 而是传统的C/C++程序 下半年可能我也去搞GPGPU了 因为它的
data parallel模型对遗留代码的并行化很有搞头，现在我粗略的想法是把Compute sensitive的任务放一部分到GPU上去做，
当然我也对GPU目前的一些限制有所了解 但是一些探索工作还是非常值得的 到时候还想向前辈多多请教</p>
<p>On 3月22日, 下午11时30分, Alleluia <a href="&#109;&#x61;&#x69;&#x6c;&#116;&#111;&#x3a;&#91;&#97;&#x6c;&#x6c;&#x75;&#108;&#x2e;&#x2e;&#46;&#x40;&#103;&#109;&#97;&#x69;&#108;&#46;&#99;&#x6f;&#109;&#x5d;&#40;&#x29;">&#91;&#97;&#x6c;&#x6c;&#x75;&#108;&#x2e;&#x2e;&#46;&#x40;&#103;&#109;&#97;&#x69;&#108;&#46;&#99;&#x6f;&#109;&#x5d;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>Heterogeneous目前来看也是一个暂时的过渡性的东西. Heterogeneous架构最大的问题还是硬件,CPU和GPU之间的
PCIE2的bus带宽太窄了.在上面来回传递一次几M的内存可能需要化掉500us左右.如果一个算法本来就是在3-4ms级别的,你要用GPU去优
化,内存带宽的消耗就占了1/10,这是非常可怕的事情.或许像AMD那种Fusion架构是一种趋势,但是目前来说没有太大的进展.貌似AMD出了一
款混合的CPU,但是貌似还没有看到有多大的优势.
On 3月23日, 上午5时02分, Guancheng Chen <a href="&#109;&#97;&#105;&#x6c;&#116;&#111;&#x3a;&#x5b;&#x63;&#x68;&#101;&#110;&#103;&#117;&#x61;&#110;&#99;&#104;&#46;&#46;&#x2e;&#x40;&#103;&#109;&#97;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#x28;&#x29;">&#x5b;&#x63;&#x68;&#101;&#110;&#103;&#117;&#x61;&#110;&#99;&#104;&#46;&#46;&#x2e;&#x40;&#103;&#109;&#97;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>我觉得现有的OpenCL确实非常不成熟，但是从纯性能角度上来讲，我看好Heterogeneous架构，尽管它们的编程难度太大，就像前面提到的不
同架构需要做不同优化等。CPU的性能是latency-oriented，GPU是throughput-oriented,Intel的
Larrabee虽然现在来看不成功，但是业界都在朝着那个方向努力。</p>
<p>On 3月22日, 下午6时18分, windstorm <a href="&#109;&#x61;&#105;&#108;&#x74;&#x6f;&#x3a;&#91;&#108;&#x69;&#107;&#117;&#110;&#x61;&#x72;&#109;&#115;&#x74;&#x72;&#46;&#46;&#x2e;&#64;&#103;&#x6d;&#x61;&#x69;&#x6c;&#46;&#x63;&#x6f;&#109;&#x5d;&#x28;&#x29;">&#91;&#108;&#x69;&#107;&#117;&#110;&#x61;&#x72;&#109;&#115;&#x74;&#x72;&#46;&#46;&#x2e;&#64;&#103;&#x6d;&#x61;&#x69;&#x6c;&#46;&#x63;&#x6f;&#109;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>实在是不能同意你更多......很早很早以前我就在这里和人争论过，GPU的并行计算平台不可能一统天下的。CUDA也不是救世主。OpenCL更不是。</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Alleluia <a href="&#x6d;&#x61;&#x69;&#x6c;&#116;&#x6f;&#58;&#91;&#x61;&#x6c;&#108;&#x75;&#x6c;&#x2e;&#46;&#x2e;&#64;&#103;&#109;&#x61;&#105;&#108;&#x2e;&#99;&#x6f;&#109;&#93;&#x28;&#x29;">&#91;&#x61;&#x6c;&#108;&#x75;&#x6c;&#x2e;&#46;&#x2e;&#64;&#103;&#109;&#x61;&#105;&#108;&#x2e;&#99;&#x6f;&#109;&#93;&#x28;&#x29;</a>:</p>
<blockquote>
<p>Parallelism 说到底是算法问题.Parallelism与Concurrency不同,Concurrency所面对的问题相对的单一可以
让一群有经验的专家来实现一套通用库或者语言来提供一个基本的编程框架.而在Parallelism上,具体的不同问题,其所需要并行的算法是根本不同
的.原因在于不同的问题,其内部的DataDependency的结构完全不同,不同的Data Dependency的结构,需要构造不同的算法.即
便是相同的Data Dependency,在不同的颗粒度下，在不同的硬件条件下所采用的算法也是完全不同的.因为一旦出现Data
Dependency也就意味着并行计算模块之间需要进行通信.从以计算节点为单位的分布式并行,到多核CPU上的Numa结构,到SIMD上的向量处
理器,其计算单元之间的通信手段,通信效率简直天差地别.比如说,在SMP上最常见的并行算法,work stealing也就是Intel的TBB,
是建立在两个条件下第一个是CPU的Cache机制上,这使得通常在内存的之间的数据搬运消耗非常小,第二个是SMP上计算单元相对的少,因此每个计算
单元被分配到的任务就相对的重。其开销远远大于通信的开销,因此这种机制在SMP上相对的划算.但是如果你要在GPU上做Work Stealing就
完全不可行,因为GPU的运算单元数量极多,被分配到的任务就相对来说的非常轻量,CUDA上的一个thread很多时候运算一次的时间不会超过
10us,而一次跨Block的线程之间的通信开销就往往要达到100us左右,再加上目前GPU上的Cache机制非常落后导致了需要频繁的通信开销
的Work Stealing在GPU上是非常不划算得.
所以我个人认为在硬件架构没有更多的突破之前,OpenCL这种东西是没有任何生命力的.不要说CPU的并行与GPU之间差异巨大,就是不同的GPU之
间AMD与Nvidia两个也是各自为政,一个平台上跑得非常快的东西,在另外一个平台极大的可能是龟速.其最终的结果估计就是跟Java的
write once run everywhere一样是个大笑话.</p>
<p>On 3月22日, 下午2时06分, Guancheng Chen <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#x3a;&#91;&#x63;&#x68;&#101;&#110;&#x67;&#117;&#97;&#x6e;&#99;&#104;&#x2e;&#46;&#x2e;&#x40;&#103;&#109;&#x61;&#105;&#x6c;&#46;&#99;&#111;&#109;&#x5d;&#x28;&#x29;">&#91;&#x63;&#x68;&#101;&#110;&#x67;&#117;&#97;&#x6e;&#99;&#104;&#x2e;&#46;&#x2e;&#x40;&#103;&#109;&#x61;&#105;&#x6c;&#46;&#99;&#111;&#109;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>On 3月22日, 上午2时20分, Tinyfool <a href="&#x6d;&#x61;&#x69;&#108;&#116;&#x6f;&#58;&#x5b;&#x74;&#105;&#110;&#x79;&#102;&#46;&#46;&#46;&#x40;&#103;&#109;&#x61;&#x69;&#x6c;&#46;&#x63;&#x6f;&#109;&#93;&#40;&#x29;">&#x5b;&#x74;&#105;&#110;&#x79;&#102;&#46;&#46;&#46;&#x40;&#103;&#109;&#x61;&#x69;&#x6c;&#46;&#x63;&#x6f;&#109;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#109;&#97;&#x69;&#x6c;&#116;&#111;&#x3a;&#91;&#106;&#x65;&#x2e;&#46;&#46;&#x40;&#x6c;&#x69;&#118;&#x65;&#x2e;&#99;&#111;&#109;&#x5d;&#x28;&#x29;">&#91;&#106;&#x65;&#x2e;&#46;&#46;&#x40;&#x6c;&#x69;&#118;&#x65;&#x2e;&#99;&#111;&#109;&#x5d;&#x28;&#x29;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#x6d;&#x61;&#105;&#108;&#x74;&#111;&#58;&#x5b;&#x63;&#104;&#x65;&#110;&#103;&#117;&#97;&#x6e;&#99;&#x68;&#x2e;&#46;&#x2e;&#64;&#103;&#109;&#97;&#105;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#x28;&#x29;">&#x5b;&#x63;&#104;&#x65;&#110;&#103;&#117;&#97;&#x6e;&#99;&#x68;&#x2e;&#46;&#x2e;&#64;&#103;&#109;&#97;&#105;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#x28;&#x29;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#109;&#97;&#x69;&#x6c;&#116;&#111;&#58;&#x5b;&#112;&#x6f;&#110;&#46;&#x2e;&#x2e;&#64;&#x67;&#x6f;&#x6f;&#x67;&#108;&#x65;&#x67;&#x72;&#x6f;&#x75;&#112;&#115;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#40;&#41;">&#x5b;&#112;&#x6f;&#110;&#46;&#x2e;&#x2e;&#64;&#x67;&#x6f;&#x6f;&#x67;&#108;&#x65;&#x67;&#x72;&#x6f;&#x75;&#112;&#115;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#40;&#41;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育...</p>
</li>
</ol>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>阅读更多 &gt;&gt;
<a href="">显示删减掉的内容</a>
<img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-23</p>
<p>其他收件人：</p>
<p>Yeap.</p>
<p>On 3月23日, 上午3时37分, windstorm <a href="&#x6d;&#x61;&#x69;&#x6c;&#116;&#x6f;&#x3a;&#91;&#108;&#x69;&#107;&#117;&#110;&#x61;&#114;&#109;&#x73;&#x74;&#114;&#x2e;&#x2e;&#46;&#x40;&#x67;&#109;&#97;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#109;&#93;&#x28;&#x29;">&#91;&#108;&#x69;&#107;&#117;&#110;&#x61;&#114;&#109;&#x73;&#x74;&#114;&#x2e;&#x2e;&#46;&#x40;&#x67;&#109;&#97;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#109;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>女生？LJJ？</p>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>&gt;</p>
<blockquote>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Guancheng Chen <a href="&#109;&#x61;&#x69;&#108;&#116;&#x6f;&#58;&#91;&#x63;&#104;&#101;&#x6e;&#103;&#117;&#x61;&#x6e;&#99;&#104;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#97;&#105;&#x6c;&#46;&#99;&#x6f;&#x6d;&#93;&#40;&#x29;">&#91;&#x63;&#104;&#101;&#x6e;&#103;&#117;&#x61;&#x6e;&#99;&#104;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#97;&#105;&#x6c;&#46;&#99;&#x6f;&#x6d;&#93;&#40;&#x29;</a>:</p>
<blockquote>
<p>恩</p>
<p>第二点其实我就是指程序员根据他自己的程序领域选择合适的并行技术。Top Language真是藏龙卧虎啊。你是在Boulder么?我一个大学女同
学在你那读MIS的phd</p>
<p>On 3月23日, 上午12时04分, windstorm <a href="&#109;&#97;&#x69;&#108;&#116;&#x6f;&#58;&#x5b;&#108;&#x69;&#x6b;&#117;&#x6e;&#x61;&#x72;&#109;&#115;&#x74;&#114;&#46;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#99;&#111;&#x6d;&#93;&#40;&#x29;">&#x5b;&#108;&#x69;&#x6b;&#117;&#x6e;&#x61;&#x72;&#109;&#115;&#x74;&#114;&#46;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#99;&#111;&#x6d;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>全民并行编程的时代，只有在全民能够并行编程的时候才会到来嘛，现在不是这个时候</p>
<p>我个人倾向于等待一个比较好的统一性架构。两条路：</p>
<p>一是某一个全新概念的提出，这个要看学术界的努力，而且在某种意义上讲，学术界搞出一个真正可行的并行架构的可能性比工业界更高。虽说今天多核的发展是工业界引 领的，但是点子还是最早学术界提出的。典型的有几个：斯坦福的Hydra（1996），斯坦福的Imagine(2000)，MIT的RAW（2002），以及 UT奥斯丁的TRIPS（2003）。在这个问题上，是不得不佩服美国的创造力，要知道直到在2000年左右，所有的人都还在为处理器频率按照摩尔定律翻翻而狂 热，美国的顶尖研究员就早已看到了这条路的尽头并指出未来处理器的发展之路。</p>
<p>二是你用现有的架构，但是application引导。如果要找一个面向多application
domain的话，刚才说了，本来看好Larrabee，因为它的架构解决了CUDA一个很大的潜在问题，而且允许现有程序员不经过任何特殊training就 上手编程，包括图形图像，科学计算，或者网络处理，各个领域。</p>
<p>不过可能就是因为这个solution的过于理想化导致结构的过于复杂化，才让其目前暂时流产。</p>
<p>总的来说，现在的问题就是软件发展不成熟，硬件发展不完善，你没法靠程序员决定使用什么并行技术，完全靠应用主导，这套技术在这个应用上如鱼得水，在那个应用上 完全不罩，作为程序员，有什么办法？</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Guancheng Chen <a href="&#109;&#97;&#x69;&#108;&#116;&#111;&#58;&#91;&#x63;&#104;&#x65;&#110;&#x67;&#117;&#x61;&#110;&#x63;&#x68;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#109;&#97;&#105;&#x6c;&#x2e;&#99;&#x6f;&#109;&#x5d;&#x28;&#x29;">&#91;&#x63;&#104;&#x65;&#110;&#x67;&#117;&#x61;&#110;&#x63;&#x68;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#109;&#97;&#105;&#x6c;&#x2e;&#99;&#x6f;&#109;&#x5d;&#x28;&#x29;</a>:</p>
<blockquote>
<p>教育以人为本，最终决定使用何种并行技术的还是程序员。目前业界对程序员并没有并行编程的技能要求，全民并行编程的时代什么时候才能到来？这是个问
题。</p>
<p>On 3月22日, 下午10时41分, windstorm <a href="&#109;&#97;&#x69;&#x6c;&#116;&#111;&#x3a;&#91;&#x6c;&#105;&#107;&#x75;&#x6e;&#x61;&#114;&#x6d;&#x73;&#x74;&#x72;&#x2e;&#x2e;&#46;&#x40;&#x67;&#x6d;&#97;&#105;&#108;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#x29;">&#91;&#x6c;&#105;&#107;&#x75;&#x6e;&#x61;&#114;&#x6d;&#x73;&#x74;&#x72;&#x2e;&#x2e;&#46;&#x40;&#x67;&#x6d;&#97;&#105;&#108;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>Larrabee当初我还是很看好的，它的架构比其他的更像一个统一的方案，可惜后来Intel自己经验不足搞不好。</p>
<p>OPENCL还是主要面向multimedia吧，CUDA/OpenCL在业界代表了流处理的方向，从GPU针对任务的角度讲是好的。其他的就算了。就像Al leluia说的那样，在硬件架构没有更多的突破之前，不说没有生命力，至少想取得任何进一步的突破都太难。</p>
<p>现在这个领域，你吹你的水，我吹我的水。至于谁的泡泡大，我看不清。所以真要选东西学，最好还是针对自己的application选靠谱。这也是并行编程教育难 的问题。大家需求完全不一样。</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Guancheng Chen <a href="&#x6d;&#x61;&#105;&#108;&#x74;&#x6f;&#58;&#91;&#x63;&#x68;&#x65;&#x6e;&#103;&#x75;&#x61;&#x6e;&#99;&#x68;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#97;&#105;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#x29;">&#91;&#x63;&#x68;&#x65;&#x6e;&#103;&#x75;&#x61;&#x6e;&#99;&#x68;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#97;&#105;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#x29;</a>:</p>
<blockquote>
<p>我觉得现有的OpenCL确实非常不成熟，但是从纯性能角度上来讲，我看好Heterogeneous架构，尽管它们的编程难度太大，就像前面提到的不
同架构需要做不同优化等。CPU的性能是latency-oriented，GPU是throughput-oriented,Intel的
Larrabee虽然现在来看不成功，但是业界都在朝着那个方向努力。</p>
<p>On 3月22日, 下午6时18分, windstorm <a href="&#109;&#x61;&#x69;&#x6c;&#116;&#111;&#x3a;&#x5b;&#108;&#105;&#107;&#x75;&#x6e;&#97;&#114;&#x6d;&#115;&#x74;&#114;&#46;&#x2e;&#46;&#64;&#x67;&#109;&#97;&#105;&#108;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#40;&#41;">&#x5b;&#108;&#105;&#107;&#x75;&#x6e;&#97;&#114;&#x6d;&#115;&#x74;&#114;&#46;&#x2e;&#46;&#64;&#x67;&#109;&#97;&#105;&#108;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>实在是不能同意你更多......很早很早以前我就在这里和人争论过，GPU的并行计算平台不可能一统天下的。CUDA也不是救世主。OpenCL更不是。</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Alleluia <a href="&#109;&#x61;&#x69;&#x6c;&#x74;&#x6f;&#x3a;&#91;&#97;&#x6c;&#108;&#117;&#x6c;&#46;&#46;&#46;&#x40;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#46;&#x63;&#111;&#109;&#93;&#x28;&#x29;">&#91;&#97;&#x6c;&#108;&#117;&#x6c;&#46;&#46;&#46;&#x40;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#46;&#x63;&#111;&#109;&#93;&#x28;&#x29;</a>:</p>
<blockquote>
<p>Parallelism 说到底是算法问题.Parallelism与Concurrency不同,Concurrency所面对的问题相对的单一可以
让一群有经验的专家来实现一套通用库或者语言来提供一个基本的编程框架.而在Parallelism上,具体的不同问题,其所需要并行的算法是根本不同
的.原因在于不同的问题,其内部的DataDependency的结构完全不同,不同的Data Dependency的结构,需要构造不同的算法.即
便是相同的Data Dependency,在不同的颗粒度下，在不同的硬件条件下所采用的算法也是完全不同的.因为一旦出现Data
Dependency也就意味着并行计算模块之间需要进行通信.从以计算节点为单位的分布式并行,到多核CPU上的Numa结构,到SIMD上的向量处
理器,其计算单元之间的通信手段,通信效率简直天差地别.比如说,在SMP上最常见的并行算法,work stealing也就是Intel的TBB,
是建立在两个条件下第一个是CPU的Cache机制上,这使得通常在内存的之间的数据搬运消耗非常小,第二个是SMP上计算单元相对的少,因此每个计算
单元被分配到的任务就相对的重。其开销远远大于通信的开销,因此这种机制在SMP上相对的划算.但是如果你要在GPU上做Work Stealing就
完全不可行,因为GPU的运算单元数量极多,被分配到的任务就相对来说的非常轻量,CUDA上的一个thread很多时候运算一次的时间不会超过
10us,而一次跨Block的线程之间的通信开销就往往要达到100us左右,再加上目前GPU上的Cache机制非常落后导致了需要频繁的通信开销
的Work Stealing在GPU上是非常不划算得.
所以我个人认为在硬件架构没有更多的突破之前,OpenCL这种东西是没有任何生命力的.不要说CPU的并行与GPU之间差异巨大,就是不同的GPU之
间AMD与Nvidia两个也是各自为政,一个平台上跑得非常快的东西,在另外一个平台极大的可能是龟速.其最终的结果估计就是跟Java的
write once run everywhere一样是个大笑话.</p>
<p>On 3月22日, 下午2时06分, Guancheng Chen <a href="&#x6d;&#97;&#105;&#x6c;&#x74;&#x6f;&#58;&#x5b;&#x63;&#x68;&#101;&#110;&#103;&#x75;&#x61;&#x6e;&#x63;&#104;&#46;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#40;&#41;">&#x5b;&#x63;&#x68;&#101;&#110;&#103;&#x75;&#x61;&#x6e;&#x63;&#104;&#46;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>On 3月22日, 上午2时20分, Tinyfool <a href="&#x6d;&#x61;&#105;&#x6c;&#x74;&#111;&#58;&#91;&#x74;&#105;&#x6e;&#x79;&#102;&#46;&#x2e;&#x2e;&#x40;&#x67;&#109;&#x61;&#105;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#x29;">&#91;&#x74;&#105;&#x6e;&#x79;&#102;&#46;&#x2e;&#x2e;&#x40;&#x67;&#109;&#x61;&#105;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#x6d;&#97;&#x69;&#108;&#116;&#111;&#58;&#91;&#106;&#x65;&#x2e;&#46;&#46;&#x40;&#x6c;&#x69;&#x76;&#x65;&#x2e;&#99;&#x6f;&#x6d;&#93;&#x28;&#x29;">&#91;&#106;&#x65;&#x2e;&#46;&#46;&#x40;&#x6c;&#x69;&#x76;&#x65;&#x2e;&#99;&#x6f;&#x6d;&#93;&#x28;&#x29;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#109;&#x61;&#x69;&#x6c;&#116;&#x6f;&#x3a;&#91;&#99;&#104;&#101;&#110;&#x67;&#x75;&#97;&#x6e;&#99;&#104;&#46;&#x2e;&#x2e;&#x40;&#x67;&#109;&#97;&#105;&#x6c;&#46;&#x63;&#111;&#109;&#93;&#x28;&#x29;">&#91;&#99;&#104;&#101;&#110;&#x67;&#x75;&#97;&#x6e;&#99;&#104;&#46;&#x2e;&#x2e;&#x40;&#x67;&#109;&#97;&#105;&#x6c;&#46;&#x63;&#111;&#109;&#93;&#x28;&#x29;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#109;&#97;&#x69;&#x6c;&#x74;&#111;&#58;&#91;&#x70;&#x6f;&#110;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#x6f;&#111;&#103;&#x6c;&#x65;&#103;&#114;&#x6f;&#x75;&#x70;&#115;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#x29;">&#91;&#x70;&#x6f;&#110;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#x6f;&#111;&#103;&#x6c;&#x65;&#103;&#114;&#x6f;&#x75;&#x70;&#115;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#x29;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，...</li>
</ol>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>阅读更多 &gt;&gt;
<a href="">显示删减掉的内容</a></p>
</blockquote>
<p><img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-23</p>
<p>其他收件人：</p>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>On 3月23日, 上午9时15分, qiaojie <a href="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#x6f;&#58;&#91;&#x71;&#x69;&#x61;&#111;&#46;&#x2e;&#46;&#x40;&#x67;&#109;&#97;&#x69;&#x6c;&#46;&#99;&#x6f;&#x6d;&#93;&#40;&#x29;">&#91;&#x71;&#x69;&#x61;&#111;&#46;&#x2e;&#46;&#x40;&#x67;&#109;&#97;&#x69;&#x6c;&#46;&#99;&#x6f;&#x6d;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1) =
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？
<a href="">显示删减掉的内容</a>
<img src="" alt=""> qiaojie <img src="" alt=""></p>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-23</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>目前正在写的是一个软件渲染器，采用了光栅化和光线跟踪混合算法，渲染算法已经完全并行化了，</p>
<p>在4核系统上基本可以达到线性加速比，更多核的系统暂时还没测试。kd-tree的构造暂时还没有并
行化，以后有空了再研究。</p>
<p>2010/3/23 Guancheng Chen <a href="&#x6d;&#x61;&#x69;&#108;&#x74;&#x6f;&#x3a;&#x5b;&#99;&#x68;&#101;&#110;&#x67;&#x75;&#46;&#46;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#x69;&#108;&#46;&#99;&#x6f;&#x6d;&#93;&#x28;&#x29;">&#x5b;&#99;&#x68;&#101;&#110;&#x67;&#x75;&#46;&#46;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#x69;&#108;&#46;&#99;&#x6f;&#x6d;&#93;&#x28;&#x29;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？
On 3月23日, 上午9时15分, qiaojie <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#x3a;&#91;&#x71;&#105;&#x61;&#x6f;&#46;&#46;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#105;&#108;&#x2e;&#99;&#111;&#x6d;&#x5d;&#x28;&#41;">&#91;&#x71;&#105;&#x61;&#x6f;&#46;&#46;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#105;&#108;&#x2e;&#99;&#111;&#x6d;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1) =
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a></p>
<p><img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-24</p>
<p>其他收件人：</p>
<p>Nice 大胆预测Linear speedup应该是每个程序员十年后的目标 呵呵</p>
<p>On 3月23日, 上午10时43分, qiaojie <a href="&#x6d;&#97;&#105;&#x6c;&#x74;&#x6f;&#58;&#x5b;&#113;&#105;&#97;&#x6f;&#x2e;&#46;&#46;&#x40;&#x67;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#x28;&#x29;">&#x5b;&#113;&#105;&#97;&#x6f;&#x2e;&#46;&#46;&#x40;&#x67;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>目前正在写的是一个软件渲染器，采用了光栅化和光线跟踪混合算法，渲染算法已经完全并行化了，
在4核系统上基本可以达到线性加速比，更多核的系统暂时还没测试。kd-tree的构造暂时还没有并
行化，以后有空了再研究。</p>
<p>2010/3/23 Guancheng Chen <a href="&#x6d;&#x61;&#x69;&#108;&#x74;&#111;&#58;&#x5b;&#99;&#104;&#x65;&#110;&#103;&#x75;&#x61;&#110;&#99;&#x68;&#x2e;&#x2e;&#46;&#64;&#103;&#x6d;&#97;&#105;&#108;&#x2e;&#99;&#111;&#x6d;&#x5d;&#x28;&#41;">&#x5b;&#99;&#104;&#x65;&#110;&#103;&#x75;&#x61;&#110;&#99;&#x68;&#x2e;&#x2e;&#46;&#64;&#103;&#x6d;&#97;&#105;&#108;&#x2e;&#99;&#111;&#x6d;&#x5d;&#x28;&#41;</a></p>
</blockquote>
<p>&gt;
&gt;
&gt;</p>
<blockquote>
<blockquote>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？</p>
<p>On 3月23日, 上午9时15分, qiaojie <a href="&#109;&#x61;&#105;&#x6c;&#116;&#111;&#x3a;&#91;&#113;&#105;&#97;&#111;&#46;&#46;&#x2e;&#64;&#x67;&#x6d;&#97;&#105;&#108;&#x2e;&#99;&#x6f;&#x6d;&#93;&#40;&#41;">&#91;&#113;&#105;&#97;&#111;&#46;&#46;&#x2e;&#64;&#x67;&#x6d;&#97;&#105;&#108;&#x2e;&#99;&#x6f;&#x6d;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1) =
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？</p>
</blockquote>
<p> To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> longshanksmo <img src="" alt=""></p>
</blockquote>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-24</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<h2 id="-cerl-2-0-">凑个热闹，也来个广告：CERL 2.0初具雏形。</h2>
<p>反者道之动，弱者道之用
<a href="">longsh...@gmail.com</a>
<a href="http://blog.csdn.net/longshanks/" target="_blank"><a href="http://blog.csdn.net/longshanks/">http://blog.csdn.net/longshanks/</a></a>
wave开通
<a href="">显示删减掉的内容</a></p>
<p><img src="" alt=""> qiaojie <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-24</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>不是所有的程序都需要并行化的，能用串行化解决的问题没必要并行，所以即使将来many-core系统成为主流，大部分程序员也没必要去搞并行计算。</p>
<p>我觉得未来的主流应该是类似cell这样一颗全功能核心带众多协处理核心的异构系统，这样才能达到最优的 性能/核心面积比。
2010/3/24 Guancheng Chen <a href="&#109;&#x61;&#105;&#x6c;&#x74;&#111;&#58;&#x5b;&#x63;&#x68;&#101;&#110;&#x67;&#117;&#46;&#x2e;&#46;&#64;&#x67;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#x28;&#x29;">&#x5b;&#x63;&#x68;&#101;&#110;&#x67;&#117;&#46;&#x2e;&#46;&#64;&#x67;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#x28;&#x29;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>Nice 大胆预测Linear speedup应该是每个程序员十年后的目标 呵呵
On 3月23日, 上午10时43分, qiaojie <a href="&#x6d;&#97;&#x69;&#x6c;&#116;&#x6f;&#x3a;&#91;&#113;&#x69;&#97;&#x6f;&#46;&#x2e;&#46;&#64;&#103;&#x6d;&#x61;&#105;&#108;&#x2e;&#x63;&#x6f;&#109;&#93;&#x28;&#x29;">&#91;&#113;&#x69;&#97;&#x6f;&#46;&#x2e;&#46;&#64;&#103;&#x6d;&#x61;&#105;&#108;&#x2e;&#x63;&#x6f;&#109;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>目前正在写的是一个软件渲染器，采用了光栅化和光线跟踪混合算法，渲染算法已经完全并行化了，
在4核系统上基本可以达到线性加速比，更多核的系统暂时还没测试。kd-tree的构造暂时还没有并
行化，以后有空了再研究。</p>
<p>2010/3/23 Guancheng Chen <a href="&#109;&#97;&#x69;&#x6c;&#116;&#111;&#58;&#91;&#x63;&#x68;&#101;&#110;&#x67;&#x75;&#97;&#110;&#99;&#x68;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#x6d;&#x5d;&#40;&#41;">&#91;&#x63;&#x68;&#101;&#110;&#x67;&#x75;&#97;&#110;&#99;&#x68;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#x6d;&#x5d;&#40;&#41;</a></p>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>&gt;
&gt;
&gt;</p>
<blockquote>
<blockquote>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？</p>
<p>On 3月23日, 上午9时15分, qiaojie <a href="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#x6f;&#58;&#x5b;&#113;&#105;&#x61;&#x6f;&#x2e;&#x2e;&#46;&#64;&#x67;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#x28;&#x29;">&#x5b;&#113;&#105;&#x61;&#x6f;&#x2e;&#x2e;&#46;&#64;&#x67;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1) =
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？</p>
</blockquote>
<p> To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> 机械唯物主义 : linjunhalida <img src="" alt=""></p>
</blockquote>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-24</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>我猜测未来的主流是数据中心，动态分配运算，存储资源。CPU，内存集群。
加上本地终端，运行一些本地进程，比如GUI，实时视频采集和分析什么的。CPU＋GPU。
根据需求和成本来考虑程序在本地或者数据中心。
其实好像这就是现在的状况？
未来的状况还是要局限于成本和性能，
如果瓶颈在数据传输，那么中心化趋势会很明显。
如果瓶颈在运算，那么程序员要花很多时间在并行处理上。
2010/3/24 qiaojie <a href="&#x6d;&#x61;&#x69;&#108;&#x74;&#x6f;&#58;&#91;&#113;&#105;&#x61;&#x2e;&#46;&#46;&#x40;&#103;&#x6d;&#97;&#x69;&#x6c;&#46;&#x63;&#111;&#109;&#93;&#40;&#x29;">&#91;&#113;&#105;&#x61;&#x2e;&#46;&#46;&#x40;&#103;&#x6d;&#97;&#x69;&#x6c;&#46;&#x63;&#111;&#109;&#93;&#40;&#x29;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>不是所有的程序都需要并行化的，能用串行化解决的问题没必要并行，所以即使将来many-core系统成为主流，大部分程序员也没必要去搞并行计算。</p>
<p>我觉得未来的主流应该是类似cell这样一颗全功能核心带众多协处理核心的异构系统，这样才能达到最优的 性能/核心面积比。
2010/3/24 Guancheng Chen <a href="&#109;&#97;&#105;&#108;&#x74;&#111;&#58;&#x5b;&#99;&#104;&#x65;&#110;&#x67;&#117;&#x2e;&#46;&#x2e;&#x40;&#103;&#109;&#x61;&#x69;&#108;&#46;&#99;&#111;&#109;&#x5d;&#x28;&#x29;">&#x5b;&#99;&#104;&#x65;&#110;&#x67;&#117;&#x2e;&#46;&#x2e;&#x40;&#103;&#109;&#x61;&#x69;&#108;&#46;&#99;&#111;&#109;&#x5d;&#x28;&#x29;</a></p>
<p>Nice 大胆预测Linear speedup应该是每个程序员十年后的目标 呵呵
On 3月23日, 上午10时43分, qiaojie <a href="&#109;&#x61;&#x69;&#108;&#x74;&#111;&#58;&#91;&#x71;&#105;&#97;&#x6f;&#x2e;&#x2e;&#x2e;&#64;&#103;&#109;&#x61;&#105;&#x6c;&#46;&#99;&#x6f;&#x6d;&#x5d;&#40;&#x29;">&#91;&#x71;&#105;&#97;&#x6f;&#x2e;&#x2e;&#x2e;&#64;&#103;&#109;&#x61;&#105;&#x6c;&#46;&#99;&#x6f;&#x6d;&#x5d;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>目前正在写的是一个软件渲染器，采用了光栅化和光线跟踪混合算法，渲染算法已经完全并行化了，
在4核系统上基本可以达到线性加速比，更多核的系统暂时还没测试。kd-tree的构造暂时还没有并
行化，以后有空了再研究。</p>
<p>2010/3/23 Guancheng Chen <a href="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#x6f;&#x3a;&#x5b;&#99;&#x68;&#x65;&#110;&#x67;&#x75;&#97;&#110;&#x63;&#x68;&#x2e;&#x2e;&#46;&#x40;&#103;&#x6d;&#x61;&#x69;&#108;&#46;&#99;&#x6f;&#109;&#x5d;&#40;&#x29;">&#x5b;&#99;&#x68;&#x65;&#110;&#x67;&#x75;&#97;&#110;&#x63;&#x68;&#x2e;&#x2e;&#46;&#x40;&#103;&#x6d;&#x61;&#x69;&#108;&#46;&#99;&#x6f;&#109;&#x5d;&#40;&#x29;</a></p>
<blockquote>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？</p>
<p>On 3月23日, 上午9时15分, qiaojie <a href="&#109;&#x61;&#105;&#x6c;&#116;&#111;&#58;&#x5b;&#x71;&#x69;&#97;&#111;&#x2e;&#46;&#x2e;&#64;&#103;&#109;&#97;&#105;&#x6c;&#46;&#99;&#x6f;&#109;&#x5d;&#x28;&#x29;">&#x5b;&#x71;&#x69;&#97;&#111;&#x2e;&#46;&#x2e;&#64;&#103;&#109;&#97;&#105;&#x6c;&#46;&#99;&#x6f;&#109;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1) =
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？</p>
</blockquote>
<p> To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a></p>
<p><img src="" alt=""> Hongzh...@gmail.com <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-24</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>异构平台如果编程复杂度降不下来的话很难流行起来。cell已经死了...
2010/3/24 qiaojie <a href="&#109;&#x61;&#105;&#x6c;&#116;&#111;&#x3a;&#91;&#x71;&#105;&#97;&#x2e;&#46;&#46;&#x40;&#x67;&#109;&#x61;&#x69;&#108;&#x2e;&#99;&#111;&#109;&#x5d;&#40;&#41;">&#91;&#x71;&#105;&#97;&#x2e;&#46;&#46;&#x40;&#x67;&#109;&#x61;&#x69;&#108;&#x2e;&#99;&#111;&#109;&#x5d;&#40;&#41;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>不是所有的程序都需要并行化的，能用串行化解决的问题没必要并行，所以即使将来many-core系统成为主流，大部分程序员也没必要去搞并行计算。</p>
<p>我觉得未来的主流应该是类似cell这样一颗全功能核心带众多协处理核心的异构系统，这样才能达到最优的 性能/核心面积比。
2010/3/24 Guancheng Chen <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#91;&#99;&#x68;&#x65;&#110;&#103;&#x75;&#x2e;&#46;&#46;&#x40;&#103;&#109;&#x61;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#93;&#40;&#x29;">&#91;&#99;&#x68;&#x65;&#110;&#103;&#x75;&#x2e;&#46;&#46;&#x40;&#103;&#109;&#x61;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#93;&#40;&#x29;</a></p>
<p>Nice 大胆预测Linear speedup应该是每个程序员十年后的目标 呵呵
On 3月23日, 上午10时43分, qiaojie <a href="&#109;&#x61;&#x69;&#x6c;&#x74;&#111;&#58;&#x5b;&#113;&#x69;&#x61;&#111;&#x2e;&#46;&#46;&#x40;&#x67;&#x6d;&#97;&#x69;&#108;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#x28;&#41;">&#x5b;&#113;&#x69;&#x61;&#111;&#x2e;&#46;&#46;&#x40;&#x67;&#x6d;&#97;&#x69;&#108;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>目前正在写的是一个软件渲染器，采用了光栅化和光线跟踪混合算法，渲染算法已经完全并行化了，
在4核系统上基本可以达到线性加速比，更多核的系统暂时还没测试。kd-tree的构造暂时还没有并
行化，以后有空了再研究。</p>
<p>2010/3/23 Guancheng Chen <a href="&#109;&#x61;&#x69;&#108;&#116;&#x6f;&#58;&#91;&#99;&#104;&#x65;&#x6e;&#x67;&#x75;&#x61;&#x6e;&#99;&#104;&#46;&#46;&#46;&#64;&#x67;&#109;&#97;&#x69;&#108;&#46;&#99;&#111;&#109;&#x5d;&#40;&#41;">&#91;&#99;&#104;&#x65;&#x6e;&#x67;&#x75;&#x61;&#x6e;&#99;&#104;&#46;&#46;&#46;&#64;&#x67;&#109;&#97;&#x69;&#108;&#46;&#99;&#111;&#109;&#x5d;&#40;&#41;</a></p>
<blockquote>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？</p>
<p>On 3月23日, 上午9时15分, qiaojie <a href="&#x6d;&#x61;&#105;&#x6c;&#116;&#x6f;&#x3a;&#91;&#x71;&#x69;&#x61;&#111;&#x2e;&#x2e;&#46;&#64;&#x67;&#109;&#x61;&#105;&#108;&#46;&#99;&#x6f;&#x6d;&#93;&#40;&#x29;">&#91;&#x71;&#x69;&#x61;&#111;&#x2e;&#x2e;&#46;&#64;&#x67;&#109;&#x61;&#105;&#108;&#46;&#99;&#x6f;&#x6d;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1) =
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？</p>
</blockquote>
<p> To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> qiaojie <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-24</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>说的没错，cell已经成了先烈了。不过这不代表异构的方向不对，CUDA，OpenCL也都是异构平台，以后我们会越来越习惯异构平台的。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#109;&#97;&#105;&#108;&#x74;&#111;&#58;&#91;&#104;&#111;&#x6e;&#x67;&#122;&#104;&#x2e;&#46;&#46;&#64;&#x67;&#x6d;&#97;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#40;&#41;">&#91;&#104;&#111;&#x6e;&#x67;&#122;&#104;&#x2e;&#46;&#46;&#64;&#x67;&#x6d;&#97;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#40;&#41;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>异构平台如果编程复杂度降不下来的话很难流行起来。cell已经死了...
2010/3/24 qiaojie <a href="&#109;&#97;&#105;&#x6c;&#116;&#111;&#x3a;&#x5b;&#113;&#x69;&#x61;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#97;&#105;&#x6c;&#46;&#99;&#x6f;&#x6d;&#93;&#x28;&#x29;">&#x5b;&#113;&#x69;&#x61;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#97;&#105;&#x6c;&#46;&#99;&#x6f;&#x6d;&#93;&#x28;&#x29;</a>
 不是所有的程序都需要并行化的，能用串行化解决的问题没必要并行，所以即使将来many-core系统成为主流，大部分程序员也没必要去搞并行计算。</p>
<p>我觉得未来的主流应该是类似cell这样一颗全功能核心带众多协处理核心的异构系统，这样才能达到最优的 性能/核心面积比。</p>
<p>2010/3/24 Guancheng Chen <a href="&#109;&#x61;&#105;&#x6c;&#116;&#111;&#58;&#x5b;&#x63;&#104;&#x65;&#110;&#103;&#117;&#x2e;&#46;&#x2e;&#64;&#x67;&#x6d;&#97;&#105;&#108;&#x2e;&#x63;&#111;&#x6d;&#93;&#x28;&#x29;">&#x5b;&#x63;&#104;&#x65;&#110;&#103;&#117;&#x2e;&#46;&#x2e;&#64;&#x67;&#x6d;&#97;&#105;&#108;&#x2e;&#x63;&#111;&#x6d;&#93;&#x28;&#x29;</a></p>
<p>Nice 大胆预测Linear speedup应该是每个程序员十年后的目标 呵呵
On 3月23日, 上午10时43分, qiaojie <a href="&#x6d;&#97;&#105;&#108;&#x74;&#111;&#x3a;&#91;&#113;&#105;&#x61;&#x6f;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#109;&#97;&#x69;&#x6c;&#46;&#99;&#111;&#x6d;&#x5d;&#40;&#41;">&#91;&#113;&#105;&#x61;&#x6f;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#109;&#97;&#x69;&#x6c;&#46;&#99;&#111;&#x6d;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>目前正在写的是一个软件渲染器，采用了光栅化和光线跟踪混合算法，渲染算法已经完全并行化了，
在4核系统上基本可以达到线性加速比，更多核的系统暂时还没测试。kd-tree的构造暂时还没有并
行化，以后有空了再研究。</p>
<p>2010/3/23 Guancheng Chen <a href="&#x6d;&#97;&#105;&#x6c;&#x74;&#111;&#58;&#91;&#99;&#x68;&#101;&#110;&#x67;&#x75;&#x61;&#x6e;&#99;&#104;&#x2e;&#x2e;&#46;&#x40;&#x67;&#x6d;&#97;&#x69;&#108;&#46;&#x63;&#111;&#109;&#x5d;&#x28;&#x29;">&#91;&#99;&#x68;&#101;&#110;&#x67;&#x75;&#x61;&#x6e;&#99;&#104;&#x2e;&#x2e;&#46;&#x40;&#x67;&#x6d;&#97;&#x69;&#108;&#46;&#x63;&#111;&#109;&#x5d;&#x28;&#x29;</a></p>
<blockquote>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？</p>
<p>On 3月23日, 上午9时15分, qiaojie <a href="&#x6d;&#x61;&#x69;&#108;&#116;&#x6f;&#58;&#x5b;&#x71;&#105;&#x61;&#x6f;&#46;&#46;&#x2e;&#x40;&#103;&#x6d;&#x61;&#x69;&#108;&#46;&#99;&#x6f;&#109;&#93;&#x28;&#41;">&#x5b;&#x71;&#105;&#x61;&#x6f;&#46;&#46;&#x2e;&#x40;&#103;&#x6d;&#x61;&#x69;&#108;&#46;&#99;&#x6f;&#109;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1) =
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？</p>
</blockquote>
<p> To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a></p>
<p><img src="" alt=""> sunjoy <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-24</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>挺有意思的，我之前没有接触过并行计算的相关理论，按照你的公式我花了个图，反映并行度、加速比以及CPU核之间的关系。</p>
<p>2010/3/23 qiaojie <a href="&#109;&#97;&#105;&#108;&#x74;&#x6f;&#58;&#x5b;&#113;&#105;&#97;&#46;&#46;&#46;&#64;&#103;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#111;&#109;&#x5d;&#40;&#41;">&#x5b;&#113;&#105;&#97;&#46;&#46;&#46;&#64;&#103;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#111;&#109;&#x5d;&#40;&#41;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1) = 5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？
 To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a></p>
<p>附件 (1)</p>
<p><a href="https://groups.google.com/group/pongba/attach/53e12db326792d31/parallelism.png?part=4&amp;authuser=0&amp;view=1" title="parallelism.png"></a></p>
<p>parallelism.png 23 KB   <a href="https://groups.google.com/group/pongba/attach/53e12db326792d31/parallelism.png?part=4&amp;authuser=0&amp;view=1" target="_blank">查看</a>   <a href="https://groups.google.com/group/pongba/attach/53e12db326792d31/parallelism.png?part=4&amp;authuser=0" target="_blank">下载</a>
<img src="" alt=""> Hongzh...@gmail.com <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-24</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>异构平台从网络处理器算起已经快10年了，现在情况仍然不明朗。就我看到的，异构平台要想高效，就必须向程序员暴露非常多的硬件细节，这必然导致编程的复杂性。曲高和寡，要想渗透到应用程序这一块，我觉得很难。</p>
<p>2010/3/24 qiaojie <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#91;&#x71;&#105;&#97;&#46;&#46;&#46;&#x40;&#x67;&#109;&#97;&#105;&#x6c;&#46;&#99;&#111;&#109;&#93;&#40;&#x29;">&#91;&#x71;&#105;&#97;&#46;&#46;&#46;&#x40;&#x67;&#109;&#97;&#105;&#x6c;&#46;&#99;&#111;&#109;&#93;&#40;&#x29;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>说的没错，cell已经成了先烈了。不过这不代表异构的方向不对，CUDA，OpenCL也都是异构平台，以后我们会越来越习惯异构平台的。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#x6d;&#97;&#105;&#x6c;&#x74;&#111;&#x3a;&#91;&#104;&#111;&#110;&#x67;&#x7a;&#x68;&#x2e;&#x2e;&#46;&#x40;&#x67;&#x6d;&#x61;&#x69;&#108;&#46;&#x63;&#111;&#x6d;&#93;&#40;&#41;">&#91;&#104;&#111;&#110;&#x67;&#x7a;&#x68;&#x2e;&#x2e;&#46;&#x40;&#x67;&#x6d;&#x61;&#x69;&#108;&#46;&#x63;&#111;&#x6d;&#93;&#40;&#41;</a></p>
<p>异构平台如果编程复杂度降不下来的话很难流行起来。cell已经死了...
2010/3/24 qiaojie <a href="&#109;&#97;&#105;&#x6c;&#x74;&#x6f;&#58;&#x5b;&#x71;&#x69;&#97;&#x2e;&#x2e;&#46;&#64;&#103;&#109;&#97;&#105;&#x6c;&#x2e;&#99;&#x6f;&#109;&#93;&#40;&#41;">&#x5b;&#x71;&#x69;&#97;&#x2e;&#x2e;&#46;&#64;&#103;&#109;&#97;&#105;&#x6c;&#x2e;&#99;&#x6f;&#109;&#93;&#40;&#41;</a>
 不是所有的程序都需要并行化的，能用串行化解决的问题没必要并行，所以即使将来many-core系统成为主流，大部分程序员也没必要去搞并行计算。</p>
<p>我觉得未来的主流应该是类似cell这样一颗全功能核心带众多协处理核心的异构系统，这样才能达到最优的 性能/核心面积比。</p>
<p>2010/3/24 Guancheng Chen <a href="&#109;&#97;&#105;&#x6c;&#116;&#x6f;&#x3a;&#91;&#x63;&#104;&#101;&#110;&#x67;&#x75;&#46;&#46;&#x2e;&#64;&#103;&#109;&#x61;&#105;&#108;&#x2e;&#99;&#111;&#x6d;&#x5d;&#x28;&#x29;">&#91;&#x63;&#104;&#101;&#110;&#x67;&#x75;&#46;&#46;&#x2e;&#64;&#103;&#109;&#x61;&#105;&#108;&#x2e;&#99;&#111;&#x6d;&#x5d;&#x28;&#x29;</a></p>
<p>Nice 大胆预测Linear speedup应该是每个程序员十年后的目标 呵呵
On 3月23日, 上午10时43分, qiaojie <a href="&#109;&#97;&#x69;&#x6c;&#x74;&#111;&#58;&#91;&#113;&#x69;&#97;&#111;&#x2e;&#x2e;&#46;&#64;&#x67;&#109;&#97;&#x69;&#108;&#x2e;&#99;&#x6f;&#x6d;&#93;&#x28;&#x29;">&#91;&#113;&#x69;&#97;&#111;&#x2e;&#x2e;&#46;&#64;&#x67;&#109;&#97;&#x69;&#108;&#x2e;&#99;&#x6f;&#x6d;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>目前正在写的是一个软件渲染器，采用了光栅化和光线跟踪混合算法，渲染算法已经完全并行化了，
在4核系统上基本可以达到线性加速比，更多核的系统暂时还没测试。kd-tree的构造暂时还没有并
行化，以后有空了再研究。</p>
<p>2010/3/23 Guancheng Chen <a href="&#109;&#x61;&#105;&#108;&#x74;&#x6f;&#58;&#x5b;&#99;&#104;&#x65;&#110;&#x67;&#117;&#x61;&#x6e;&#99;&#x68;&#46;&#46;&#46;&#64;&#103;&#109;&#x61;&#105;&#108;&#46;&#99;&#111;&#x6d;&#93;&#40;&#x29;">&#x5b;&#99;&#104;&#x65;&#110;&#x67;&#117;&#x61;&#x6e;&#99;&#x68;&#46;&#46;&#46;&#64;&#103;&#109;&#x61;&#105;&#108;&#46;&#99;&#111;&#x6d;&#93;&#40;&#x29;</a></p>
<blockquote>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？</p>
<p>On 3月23日, 上午9时15分, qiaojie <a href="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#x6f;&#x3a;&#91;&#x71;&#x69;&#x61;&#111;&#46;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#x61;&#105;&#108;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#41;">&#91;&#x71;&#x69;&#x61;&#111;&#46;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#x61;&#105;&#108;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1) =
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？</p>
</blockquote>
<p> To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a></p>
<p><img src="" alt=""> qiaojie <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-24</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>并行计算本来就是曲高和寡的东西，就跟3D渲染一样，能开发引擎的毕竟只是小部分人，大多数人在引擎的基础上做应用。关键在于是否有杀手应用，只要有大量的需求，自然会有人去做开发。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#109;&#97;&#x69;&#108;&#x74;&#111;&#x3a;&#91;&#x68;&#x6f;&#110;&#x67;&#122;&#x68;&#x2e;&#46;&#46;&#x40;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#x6d;&#x5d;&#x28;&#41;">&#91;&#x68;&#x6f;&#110;&#x67;&#122;&#x68;&#x2e;&#46;&#46;&#x40;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#x6d;&#x5d;&#x28;&#41;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>异构平台从网络处理器算起已经快10年了，现在情况仍然不明朗。就我看到的，异构平台要想高效，就必须向程序员暴露非常多的硬件细节，这必然导致编程的复杂性。曲高和寡，要想渗透到应用程序这一块，我觉得很难。</p>
<p>2010/3/24 qiaojie <a href="&#x6d;&#97;&#x69;&#108;&#116;&#x6f;&#x3a;&#91;&#113;&#105;&#97;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#109;&#97;&#105;&#x6c;&#x2e;&#99;&#111;&#109;&#x5d;&#x28;&#41;">&#91;&#113;&#105;&#97;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#109;&#97;&#105;&#x6c;&#x2e;&#99;&#111;&#109;&#x5d;&#x28;&#41;</a>
说的没错，cell已经成了先烈了。不过这不代表异构的方向不对，CUDA，OpenCL也都是异构平台，以后我们会越来越习惯异构平台的。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#109;&#x61;&#x69;&#108;&#x74;&#111;&#x3a;&#x5b;&#104;&#x6f;&#110;&#103;&#122;&#x68;&#46;&#x2e;&#46;&#x40;&#x67;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#109;&#93;&#40;&#x29;">&#x5b;&#104;&#x6f;&#110;&#103;&#122;&#x68;&#46;&#x2e;&#46;&#x40;&#x67;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#109;&#93;&#40;&#x29;</a></p>
<p>异构平台如果编程复杂度降不下来的话很难流行起来。cell已经死了...
2010/3/24 qiaojie <a href="&#x6d;&#x61;&#105;&#108;&#116;&#x6f;&#x3a;&#x5b;&#113;&#105;&#97;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#x6f;&#109;&#93;&#40;&#41;">&#x5b;&#113;&#105;&#97;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#x6f;&#109;&#93;&#40;&#41;</a>
 不是所有的程序都需要并行化的，能用串行化解决的问题没必要并行，所以即使将来many-core系统成为主流，大部分程序员也没必要去搞并行计算。</p>
<p>我觉得未来的主流应该是类似cell这样一颗全功能核心带众多协处理核心的异构系统，这样才能达到最优的 性能/核心面积比。</p>
<p>2010/3/24 Guancheng Chen <a href="&#x6d;&#x61;&#105;&#x6c;&#x74;&#x6f;&#58;&#91;&#x63;&#104;&#101;&#110;&#x67;&#x75;&#46;&#46;&#46;&#x40;&#x67;&#x6d;&#97;&#105;&#108;&#46;&#x63;&#111;&#109;&#93;&#40;&#41;">&#91;&#x63;&#104;&#101;&#110;&#x67;&#x75;&#46;&#46;&#46;&#x40;&#x67;&#x6d;&#97;&#105;&#108;&#46;&#x63;&#111;&#109;&#93;&#40;&#41;</a></p>
<p>Nice 大胆预测Linear speedup应该是每个程序员十年后的目标 呵呵
On 3月23日, 上午10时43分, qiaojie <a href="&#x6d;&#97;&#105;&#x6c;&#116;&#111;&#58;&#x5b;&#x71;&#105;&#97;&#x6f;&#x2e;&#46;&#x2e;&#x40;&#x67;&#109;&#x61;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#109;&#x5d;&#x28;&#x29;">&#x5b;&#x71;&#105;&#97;&#x6f;&#x2e;&#46;&#x2e;&#x40;&#x67;&#109;&#x61;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#109;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>目前正在写的是一个软件渲染器，采用了光栅化和光线跟踪混合算法，渲染算法已经完全并行化了，
在4核系统上基本可以达到线性加速比，更多核的系统暂时还没测试。kd-tree的构造暂时还没有并
行化，以后有空了再研究。</p>
<p>2010/3/23 Guancheng Chen <a href="&#x6d;&#x61;&#105;&#108;&#116;&#x6f;&#58;&#91;&#99;&#x68;&#x65;&#110;&#x67;&#117;&#x61;&#x6e;&#x63;&#x68;&#46;&#x2e;&#x2e;&#x40;&#x67;&#109;&#97;&#105;&#108;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#x28;&#x29;">&#91;&#99;&#x68;&#x65;&#110;&#x67;&#117;&#x61;&#x6e;&#x63;&#x68;&#46;&#x2e;&#x2e;&#x40;&#x67;&#109;&#97;&#105;&#108;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#x28;&#x29;</a></p>
<blockquote>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？</p>
<p>On 3月23日, 上午9时15分, qiaojie <a href="&#109;&#x61;&#105;&#x6c;&#x74;&#x6f;&#x3a;&#x5b;&#113;&#x69;&#x61;&#111;&#46;&#46;&#46;&#64;&#x67;&#109;&#x61;&#x69;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#x29;">&#x5b;&#113;&#x69;&#x61;&#111;&#46;&#46;&#46;&#64;&#x67;&#109;&#x61;&#x69;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1) =
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？</p>
</blockquote>
<p> To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-25</p>
<p>其他收件人：</p>
<p>杀手应用一般来说是指什么样的应用呢？比如用户群特别大的网游？还是那些专有的科学计算用的软件？</p>
<p>On 3月24日, 下午12时36分, qiaojie <a href="&#x6d;&#97;&#x69;&#108;&#x74;&#x6f;&#x3a;&#x5b;&#113;&#x69;&#97;&#111;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#109;&#97;&#x69;&#x6c;&#46;&#x63;&#x6f;&#109;&#x5d;&#40;&#x29;">&#x5b;&#113;&#x69;&#97;&#111;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#109;&#97;&#x69;&#x6c;&#46;&#x63;&#x6f;&#109;&#x5d;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>并行计算本来就是曲高和寡的东西，就跟3D渲染一样，能开发引擎的毕竟只是小部分人，大多数人在引擎的基础上做应用。关键在于是否有杀手应用，只要有大量的需求 ，自然会有人去做开发。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#x6d;&#97;&#x69;&#108;&#116;&#111;&#x3a;&#x5b;&#x68;&#x6f;&#110;&#103;&#122;&#104;&#97;&#x6e;&#x67;&#46;&#46;&#x2e;&#46;&#64;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#93;&#x28;&#41;">&#x5b;&#x68;&#x6f;&#110;&#103;&#122;&#104;&#97;&#x6e;&#x67;&#46;&#46;&#x2e;&#46;&#64;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#93;&#x28;&#41;</a></p>
</blockquote>
<p>&gt;
&gt;
&gt;</p>
<blockquote>
<blockquote>
<p>异构平台从网络处理器算起已经快10年了，现在情况仍然不明朗。就我看到的，异构平台要想高效，就必须向程序员暴露非常多的硬件细节，这必然导致编程的复杂性。 曲高和寡，要想渗透到应用程序这一块，我觉得很难。</p>
<p>2010/3/24 qiaojie <a href="&#x6d;&#x61;&#x69;&#108;&#116;&#111;&#58;&#91;&#x71;&#105;&#x61;&#111;&#46;&#46;&#46;&#64;&#x67;&#109;&#97;&#105;&#108;&#46;&#x63;&#111;&#x6d;&#x5d;&#x28;&#x29;">&#91;&#x71;&#105;&#x61;&#111;&#46;&#46;&#46;&#64;&#x67;&#109;&#97;&#105;&#108;&#46;&#x63;&#111;&#x6d;&#x5d;&#x28;&#x29;</a></p>
</blockquote>
</blockquote>
<p>&gt;</p>
<blockquote>
<blockquote>
<blockquote>
<p>说的没错，cell已经成了先烈了。不过这不代表异构的方向不对，CUDA，OpenCL也都是异构平台，以后我们会越来越习惯异构平台的。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#x6d;&#x61;&#x69;&#x6c;&#116;&#x6f;&#58;&#91;&#x68;&#x6f;&#110;&#103;&#x7a;&#104;&#x61;&#x6e;&#x67;&#x2e;&#46;&#46;&#46;&#64;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#109;&#93;&#x28;&#x29;">&#91;&#x68;&#x6f;&#110;&#103;&#x7a;&#104;&#x61;&#x6e;&#x67;&#x2e;&#46;&#46;&#46;&#64;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#109;&#93;&#x28;&#x29;</a></p>
<p>异构平台如果编程复杂度降不下来的话很难流行起来。cell已经死了...</p>
<blockquote>
<p> 2010/3/24 qiaojie <a href="&#109;&#x61;&#x69;&#108;&#x74;&#x6f;&#x3a;&#91;&#x71;&#x69;&#97;&#x6f;&#46;&#x2e;&#x2e;&#64;&#103;&#109;&#97;&#x69;&#x6c;&#46;&#x63;&#111;&#x6d;&#93;&#x28;&#41;">&#91;&#x71;&#x69;&#97;&#x6f;&#46;&#x2e;&#x2e;&#64;&#103;&#109;&#97;&#x69;&#x6c;&#46;&#x63;&#111;&#x6d;&#93;&#x28;&#41;</a></p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>&gt;</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>不是所有的程序都需要并行化的，能用串行化解决的问题没必要并行，所以即使将来many-core系统成为主流，大部分程序员也没必要去搞并行计算。
  我觉得未来的主流应该是类似cell这样一颗全功能核心带众多协处理核心的异构系统，这样才能达到最优的 性能/核心面积比。</p>
<p>2010/3/24 Guancheng Chen <a href="&#x6d;&#97;&#105;&#108;&#116;&#x6f;&#x3a;&#x5b;&#x63;&#104;&#101;&#110;&#103;&#x75;&#97;&#x6e;&#x63;&#104;&#x2e;&#46;&#46;&#64;&#x67;&#109;&#x61;&#105;&#x6c;&#46;&#x63;&#x6f;&#109;&#x5d;&#x28;&#x29;">&#x5b;&#x63;&#104;&#101;&#110;&#103;&#x75;&#97;&#x6e;&#x63;&#104;&#x2e;&#46;&#46;&#64;&#x67;&#109;&#x61;&#105;&#x6c;&#46;&#x63;&#x6f;&#109;&#x5d;&#x28;&#x29;</a></p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>&gt;</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>Nice 大胆预测Linear speedup应该是每个程序员十年后的目标 呵呵</p>
<blockquote>
<p>On 3月23日, 上午10时43分, qiaojie <a href="&#109;&#x61;&#105;&#108;&#116;&#111;&#58;&#91;&#x71;&#x69;&#x61;&#x6f;&#46;&#x2e;&#46;&#64;&#103;&#x6d;&#97;&#x69;&#108;&#46;&#x63;&#x6f;&#109;&#93;&#40;&#x29;">&#91;&#x71;&#x69;&#x61;&#x6f;&#46;&#x2e;&#46;&#64;&#103;&#x6d;&#97;&#x69;&#108;&#46;&#x63;&#x6f;&#109;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>目前正在写的是一个软件渲染器，采用了光栅化和光线跟踪混合算法，渲染算法已经完全并行化了，
在4核系统上基本可以达到线性加速比，更多核的系统暂时还没测试。kd-tree的构造暂时还没有并
行化，以后有空了再研究。</p>
<p>2010/3/23 Guancheng Chen <a href="&#x6d;&#x61;&#x69;&#108;&#x74;&#111;&#58;&#91;&#x63;&#104;&#101;&#x6e;&#103;&#x75;&#x61;&#x6e;&#99;&#104;&#46;&#x2e;&#46;&#x40;&#x67;&#109;&#97;&#105;&#108;&#46;&#x63;&#x6f;&#109;&#x5d;&#x28;&#x29;">&#91;&#x63;&#104;&#101;&#x6e;&#103;&#x75;&#x61;&#x6e;&#99;&#104;&#46;&#x2e;&#46;&#x40;&#x67;&#109;&#97;&#105;&#108;&#46;&#x63;&#x6f;&#109;&#x5d;&#x28;&#x29;</a></p>
<blockquote>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？</p>
<p>On 3月23日, 上午9时15分, qiaojie <a href="&#109;&#97;&#105;&#x6c;&#116;&#111;&#58;&#91;&#113;&#105;&#x61;&#x6f;&#46;&#46;&#46;&#64;&#103;&#x6d;&#97;&#x69;&#108;&#x2e;&#99;&#111;&#109;&#x5d;&#x28;&#x29;">&#91;&#113;&#105;&#x61;&#x6f;&#46;&#46;&#46;&#64;&#103;&#x6d;&#97;&#x69;&#108;&#x2e;&#99;&#111;&#109;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1)
=
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank
Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？</p>
</blockquote>
<p> To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
<a href="">显示删减掉的内容</a></p>
</blockquote>
</blockquote>
<p><img src="" alt=""> qiaojie <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-25</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>3D游戏就是一类杀手应用，由此支撑起了一个庞大的GPU市场，芯片行业的研发成本是很高的，没有一个庞大的市场是做不起来的。目前的消费者对于多核系统显然还没有强烈的需求，因为应用跟不上，i7发布快2年了还没进入主流市场，这种情况延续下去的话摩尔定律将因此失效。不过我相信杀手级应用总会出现的，这可能要硬件性能突破一个临界点，比方说目前GPU的性能再提升一个数量级的话，光线跟踪算法就可以提供流畅的接近CG的画质，倒是此类应用便会流行开来。</p>
<p>2010/3/25 Guancheng Chen <a href="&#109;&#x61;&#x69;&#108;&#x74;&#x6f;&#58;&#91;&#x63;&#x68;&#101;&#110;&#x67;&#117;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#97;&#x69;&#108;&#x2e;&#99;&#x6f;&#109;&#x5d;&#x28;&#x29;">&#91;&#x63;&#x68;&#101;&#110;&#x67;&#117;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#97;&#x69;&#108;&#x2e;&#99;&#x6f;&#109;&#x5d;&#x28;&#x29;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>杀手应用一般来说是指什么样的应用呢？比如用户群特别大的网游？还是那些专有的科学计算用的软件？
On 3月24日, 下午12时36分, qiaojie <a href="&#109;&#x61;&#x69;&#108;&#x74;&#111;&#58;&#91;&#113;&#105;&#x61;&#111;&#46;&#46;&#46;&#x40;&#103;&#x6d;&#97;&#x69;&#x6c;&#46;&#x63;&#111;&#x6d;&#93;&#x28;&#41;">&#91;&#113;&#105;&#x61;&#111;&#46;&#46;&#46;&#x40;&#103;&#x6d;&#97;&#x69;&#x6c;&#46;&#x63;&#111;&#x6d;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>并行计算本来就是曲高和寡的东西，就跟3D渲染一样，能开发引擎的毕竟只是小部分人，大多数人在引擎的基础上做应用。关键在于是否有杀手应用，只要有大量的需求 ，自然会有人去做开发。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#x6d;&#x61;&#105;&#108;&#x74;&#x6f;&#58;&#91;&#104;&#111;&#110;&#103;&#x7a;&#104;&#x61;&#110;&#103;&#x2e;&#46;&#x2e;&#x2e;&#64;&#103;&#109;&#x61;&#105;&#108;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#x28;&#41;">&#91;&#104;&#111;&#110;&#103;&#x7a;&#104;&#x61;&#110;&#103;&#x2e;&#46;&#x2e;&#x2e;&#64;&#103;&#109;&#x61;&#105;&#108;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#x28;&#41;</a></p>
<blockquote>
<p>异构平台从网络处理器算起已经快10年了，现在情况仍然不明朗。就我看到的，异构平台要想高效，就必须向程序员暴露非常多的硬件细节，这必然导致编程的复杂性。 曲高和寡，要想渗透到应用程序这一块，我觉得很难。</p>
<p>2010/3/24 qiaojie <a href="&#x6d;&#97;&#x69;&#108;&#116;&#x6f;&#58;&#91;&#113;&#105;&#x61;&#111;&#46;&#46;&#x2e;&#64;&#103;&#109;&#x61;&#105;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#x29;">&#91;&#113;&#105;&#x61;&#111;&#46;&#46;&#x2e;&#64;&#103;&#109;&#x61;&#105;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#x29;</a></p>
<blockquote>
<p>说的没错，cell已经成了先烈了。不过这不代表异构的方向不对，CUDA，OpenCL也都是异构平台，以后我们会越来越习惯异构平台的。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#x6d;&#x61;&#x69;&#108;&#116;&#111;&#58;&#91;&#x68;&#111;&#110;&#x67;&#122;&#104;&#97;&#x6e;&#x67;&#46;&#x2e;&#46;&#46;&#x40;&#x67;&#x6d;&#x61;&#x69;&#108;&#46;&#99;&#x6f;&#x6d;&#x5d;&#40;&#x29;">&#91;&#x68;&#111;&#110;&#x67;&#122;&#104;&#97;&#x6e;&#x67;&#46;&#x2e;&#46;&#46;&#x40;&#x67;&#x6d;&#x61;&#x69;&#108;&#46;&#99;&#x6f;&#x6d;&#x5d;&#40;&#x29;</a></p>
<p>异构平台如果编程复杂度降不下来的话很难流行起来。cell已经死了...</p>
<blockquote>
<p> 2010/3/24 qiaojie <a href="&#109;&#x61;&#x69;&#108;&#116;&#x6f;&#x3a;&#x5b;&#113;&#105;&#97;&#111;&#46;&#46;&#46;&#64;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#46;&#99;&#x6f;&#109;&#93;&#40;&#41;">&#x5b;&#113;&#105;&#97;&#111;&#46;&#46;&#46;&#64;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#46;&#99;&#x6f;&#109;&#93;&#40;&#41;</a></p>
<blockquote>
<p>不是所有的程序都需要并行化的，能用串行化解决的问题没必要并行，所以即使将来many-core系统成为主流，大部分程序员也没必要去搞并行计算。
  我觉得未来的主流应该是类似cell这样一颗全功能核心带众多协处理核心的异构系统，这样才能达到最优的 性能/核心面积比。</p>
<p>2010/3/24 Guancheng Chen <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#x3a;&#91;&#x63;&#x68;&#101;&#110;&#x67;&#117;&#97;&#110;&#x63;&#x68;&#x2e;&#x2e;&#46;&#64;&#x67;&#x6d;&#97;&#105;&#x6c;&#x2e;&#99;&#111;&#109;&#93;&#40;&#41;">&#91;&#x63;&#x68;&#101;&#110;&#x67;&#117;&#97;&#110;&#x63;&#x68;&#x2e;&#x2e;&#46;&#64;&#x67;&#x6d;&#97;&#105;&#x6c;&#x2e;&#99;&#111;&#109;&#93;&#40;&#41;</a></p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>&gt;</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>Nice 大胆预测Linear speedup应该是每个程序员十年后的目标 呵呵</p>
<blockquote>
<p>On 3月23日, 上午10时43分, qiaojie <a href="&#x6d;&#97;&#x69;&#x6c;&#x74;&#111;&#58;&#91;&#113;&#105;&#97;&#x6f;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#40;&#x29;">&#91;&#113;&#105;&#97;&#x6f;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>目前正在写的是一个软件渲染器，采用了光栅化和光线跟踪混合算法，渲染算法已经完全并行化了，
在4核系统上基本可以达到线性加速比，更多核的系统暂时还没测试。kd-tree的构造暂时还没有并
行化，以后有空了再研究。</p>
<p>2010/3/23 Guancheng Chen <a href="&#109;&#x61;&#105;&#x6c;&#116;&#111;&#58;&#x5b;&#99;&#x68;&#x65;&#x6e;&#103;&#117;&#x61;&#x6e;&#x63;&#104;&#46;&#x2e;&#46;&#64;&#103;&#109;&#x61;&#x69;&#108;&#46;&#x63;&#111;&#x6d;&#x5d;&#x28;&#x29;">&#x5b;&#99;&#x68;&#x65;&#x6e;&#103;&#117;&#x61;&#x6e;&#x63;&#104;&#46;&#x2e;&#46;&#64;&#103;&#109;&#x61;&#x69;&#108;&#46;&#x63;&#111;&#x6d;&#x5d;&#x28;&#x29;</a></p>
<blockquote>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？</p>
<p>On 3月23日, 上午9时15分, qiaojie <a href="&#109;&#x61;&#105;&#x6c;&#x74;&#111;&#58;&#91;&#113;&#105;&#97;&#x6f;&#x2e;&#46;&#x2e;&#64;&#x67;&#x6d;&#x61;&#105;&#108;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#41;">&#91;&#113;&#105;&#97;&#x6f;&#x2e;&#46;&#x2e;&#64;&#x67;&#x6d;&#x61;&#105;&#108;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1)
=
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank
Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？</p>
</blockquote>
<p> To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> 机械唯物主义 : linjunhalida <img src="" alt=""></p>
</blockquote>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-25</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>一个谬误：刺激需求
产能=消费，产能才是主动力。技术成长是随着产能成长而起来的。
而产能多的结果就是满足了需求，造成一种需求带来技术进步的假像。
而技术和产能之间的关系又错综复杂。。
2010/3/25 qiaojie <a href="&#109;&#x61;&#x69;&#x6c;&#x74;&#111;&#x3a;&#91;&#x71;&#105;&#97;&#x2e;&#x2e;&#x2e;&#64;&#103;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#99;&#111;&#x6d;&#x5d;&#40;&#x29;">&#91;&#x71;&#105;&#97;&#x2e;&#x2e;&#x2e;&#64;&#103;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#99;&#111;&#x6d;&#x5d;&#40;&#x29;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>3D游戏就是一类杀手应用，由此支撑起了一个庞大的GPU市场，芯片行业的研发成本是很高的，没有一个庞大的市场是做不起来的。目前的消费者对于多核系统显然还没有强烈的需求，因为应用跟不上，i7发布快2年了还没进入主流市场，这种情况延续下去的话摩尔定律将因此失效。不过我相信杀手级应用总会出现的，这可能要硬件性能突破一个临界点，比方说目前GPU的性能再提升一个数量级的话，光线跟踪算法就可以提供流畅的接近CG的画质，倒是此类应用便会流行开来。</p>
<p>2010/3/25 Guancheng Chen <a href="&#109;&#97;&#105;&#108;&#116;&#x6f;&#x3a;&#91;&#99;&#104;&#x65;&#x6e;&#x67;&#117;&#x2e;&#x2e;&#x2e;&#64;&#103;&#109;&#97;&#x69;&#x6c;&#46;&#99;&#111;&#x6d;&#93;&#40;&#41;">&#91;&#99;&#104;&#x65;&#x6e;&#x67;&#117;&#x2e;&#x2e;&#x2e;&#64;&#103;&#109;&#97;&#x69;&#x6c;&#46;&#99;&#111;&#x6d;&#93;&#40;&#41;</a></p>
<p>杀手应用一般来说是指什么样的应用呢？比如用户群特别大的网游？还是那些专有的科学计算用的软件？
On 3月24日, 下午12时36分, qiaojie <a href="&#x6d;&#97;&#105;&#x6c;&#x74;&#x6f;&#x3a;&#x5b;&#x71;&#x69;&#97;&#x6f;&#x2e;&#46;&#46;&#x40;&#x67;&#109;&#97;&#105;&#108;&#x2e;&#99;&#x6f;&#109;&#93;&#x28;&#41;">&#x5b;&#x71;&#x69;&#97;&#x6f;&#x2e;&#46;&#46;&#x40;&#x67;&#109;&#97;&#105;&#108;&#x2e;&#99;&#x6f;&#109;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>并行计算本来就是曲高和寡的东西，就跟3D渲染一样，能开发引擎的毕竟只是小部分人，大多数人在引擎的基础上做应用。关键在于是否有杀手应用，只要有大量的需求 ，自然会有人去做开发。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#x6f;&#58;&#91;&#x68;&#111;&#x6e;&#x67;&#x7a;&#x68;&#x61;&#110;&#103;&#x2e;&#x2e;&#46;&#46;&#x40;&#x67;&#109;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#41;">&#91;&#x68;&#111;&#x6e;&#x67;&#x7a;&#x68;&#x61;&#110;&#103;&#x2e;&#x2e;&#46;&#46;&#x40;&#x67;&#109;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#41;</a></p>
<blockquote>
<p>异构平台从网络处理器算起已经快10年了，现在情况仍然不明朗。就我看到的，异构平台要想高效，就必须向程序员暴露非常多的硬件细节，这必然导致编程的复杂性。 曲高和寡，要想渗透到应用程序这一块，我觉得很难。</p>
<p>2010/3/24 qiaojie <a href="&#x6d;&#97;&#x69;&#x6c;&#x74;&#111;&#58;&#91;&#x71;&#x69;&#x61;&#111;&#46;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#x61;&#x69;&#108;&#46;&#99;&#111;&#x6d;&#93;&#x28;&#41;">&#91;&#x71;&#x69;&#x61;&#111;&#46;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#x61;&#x69;&#108;&#46;&#99;&#111;&#x6d;&#93;&#x28;&#41;</a></p>
<blockquote>
<p>说的没错，cell已经成了先烈了。不过这不代表异构的方向不对，CUDA，OpenCL也都是异构平台，以后我们会越来越习惯异构平台的。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#109;&#x61;&#105;&#108;&#116;&#x6f;&#58;&#x5b;&#104;&#x6f;&#110;&#x67;&#122;&#104;&#97;&#x6e;&#x67;&#46;&#x2e;&#46;&#46;&#x40;&#x67;&#109;&#97;&#105;&#108;&#46;&#x63;&#111;&#109;&#x5d;&#x28;&#41;">&#x5b;&#104;&#x6f;&#110;&#x67;&#122;&#104;&#97;&#x6e;&#x67;&#46;&#x2e;&#46;&#46;&#x40;&#x67;&#109;&#97;&#105;&#108;&#46;&#x63;&#111;&#109;&#x5d;&#x28;&#41;</a></p>
<p>异构平台如果编程复杂度降不下来的话很难流行起来。cell已经死了...</p>
<blockquote>
<p> 2010/3/24 qiaojie <a href="&#x6d;&#x61;&#105;&#x6c;&#x74;&#111;&#58;&#91;&#113;&#x69;&#97;&#111;&#46;&#46;&#46;&#x40;&#103;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#x63;&#111;&#109;&#93;&#40;&#41;">&#91;&#113;&#x69;&#97;&#111;&#46;&#46;&#46;&#x40;&#103;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#x63;&#111;&#109;&#93;&#40;&#41;</a></p>
<blockquote>
<p>不是所有的程序都需要并行化的，能用串行化解决的问题没必要并行，所以即使将来many-core系统成为主流，大部分程序员也没必要去搞并行计算。
  我觉得未来的主流应该是类似cell这样一颗全功能核心带众多协处理核心的异构系统，这样才能达到最优的 性能/核心面积比。</p>
<p>2010/3/24 Guancheng Chen <a href="&#x6d;&#x61;&#x69;&#108;&#x74;&#111;&#58;&#91;&#99;&#104;&#101;&#x6e;&#103;&#x75;&#x61;&#x6e;&#99;&#x68;&#46;&#46;&#x2e;&#x40;&#x67;&#x6d;&#97;&#x69;&#108;&#x2e;&#x63;&#111;&#x6d;&#93;&#x28;&#41;">&#91;&#99;&#104;&#101;&#x6e;&#103;&#x75;&#x61;&#x6e;&#99;&#x68;&#46;&#46;&#x2e;&#x40;&#x67;&#x6d;&#97;&#x69;&#108;&#x2e;&#x63;&#111;&#x6d;&#93;&#x28;&#41;</a></p>
<p>Nice 大胆预测Linear speedup应该是每个程序员十年后的目标 呵呵</p>
<blockquote>
<p>On 3月23日, 上午10时43分, qiaojie <a href="&#x6d;&#97;&#105;&#x6c;&#116;&#111;&#x3a;&#x5b;&#113;&#105;&#97;&#111;&#46;&#x2e;&#46;&#x40;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#46;&#99;&#111;&#x6d;&#93;&#x28;&#41;">&#x5b;&#113;&#105;&#97;&#111;&#46;&#x2e;&#46;&#x40;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#46;&#99;&#111;&#x6d;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>目前正在写的是一个软件渲染器，采用了光栅化和光线跟踪混合算法，渲染算法已经完全并行化了，
在4核系统上基本可以达到线性加速比，更多核的系统暂时还没测试。kd-tree的构造暂时还没有并
行化，以后有空了再研究。</p>
<p>2010/3/23 Guancheng Chen <a href="&#x6d;&#x61;&#105;&#x6c;&#x74;&#111;&#58;&#91;&#99;&#x68;&#101;&#x6e;&#x67;&#117;&#97;&#110;&#99;&#x68;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#97;&#x69;&#108;&#x2e;&#x63;&#111;&#109;&#93;&#x28;&#x29;">&#91;&#99;&#x68;&#101;&#x6e;&#x67;&#117;&#97;&#110;&#99;&#x68;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#97;&#x69;&#108;&#x2e;&#x63;&#111;&#109;&#93;&#x28;&#x29;</a></p>
<blockquote>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？</p>
<p>On 3月23日, 上午9时15分, qiaojie <a href="&#109;&#x61;&#105;&#x6c;&#116;&#x6f;&#58;&#x5b;&#113;&#x69;&#97;&#x6f;&#x2e;&#x2e;&#46;&#64;&#x67;&#109;&#x61;&#x69;&#108;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#41;">&#x5b;&#113;&#x69;&#97;&#x6f;&#x2e;&#x2e;&#46;&#64;&#x67;&#109;&#x61;&#x69;&#108;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1)
=
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank
Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？</p>
</blockquote>
<p> To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a></p>
</blockquote>
</blockquote>
<p><img src="" alt=""> qiaojie <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-25</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>如果产能=消费的话就没有产能过剩这一说了。</p>
<p>2010/3/25 机械唯物主义 : linjunhalida <a href="&#109;&#97;&#105;&#x6c;&#x74;&#111;&#58;&#x5b;&#108;&#x69;&#x6e;&#106;&#117;&#110;&#x2e;&#46;&#46;&#x40;&#x67;&#109;&#97;&#x69;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#93;&#x28;&#41;">&#x5b;&#108;&#x69;&#x6e;&#106;&#117;&#110;&#x2e;&#46;&#46;&#x40;&#x67;&#109;&#97;&#x69;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#93;&#x28;&#41;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>一个谬误：刺激需求
产能=消费，产能才是主动力。技术成长是随着产能成长而起来的。
而产能多的结果就是满足了需求，造成一种需求带来技术进步的假像。
而技术和产能之间的关系又错综复杂。。
2010/3/25 qiaojie <a href="&#x6d;&#97;&#105;&#x6c;&#x74;&#x6f;&#58;&#x5b;&#x71;&#x69;&#97;&#46;&#46;&#46;&#64;&#103;&#109;&#97;&#105;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#x29;">&#x5b;&#x71;&#x69;&#97;&#46;&#46;&#46;&#64;&#103;&#109;&#97;&#105;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#x29;</a></p>
<p>3D游戏就是一类杀手应用，由此支撑起了一个庞大的GPU市场，芯片行业的研发成本是很高的，没有一个庞大的市场是做不起来的。目前的消费者对于多核系统显然还没有强烈的需求，因为应用跟不上，i7发布快2年了还没进入主流市场，这种情况延续下去的话摩尔定律将因此失效。不过我相信杀手级应用总会出现的，这可能要硬件性能突破一个临界点，比方说目前GPU的性能再提升一个数量级的话，光线跟踪算法就可以提供流畅的接近CG的画质，倒是此类应用便会流行开来。</p>
<p>2010/3/25 Guancheng Chen <a href="&#109;&#97;&#105;&#x6c;&#x74;&#111;&#58;&#91;&#x63;&#104;&#x65;&#x6e;&#x67;&#x75;&#46;&#x2e;&#46;&#64;&#103;&#x6d;&#97;&#x69;&#x6c;&#46;&#99;&#x6f;&#109;&#x5d;&#x28;&#x29;">&#91;&#x63;&#104;&#x65;&#x6e;&#x67;&#x75;&#46;&#x2e;&#46;&#64;&#103;&#x6d;&#97;&#x69;&#x6c;&#46;&#99;&#x6f;&#109;&#x5d;&#x28;&#x29;</a></p>
<p>杀手应用一般来说是指什么样的应用呢？比如用户群特别大的网游？还是那些专有的科学计算用的软件？
On 3月24日, 下午12时36分, qiaojie <a href="&#x6d;&#97;&#105;&#x6c;&#116;&#111;&#x3a;&#91;&#113;&#x69;&#97;&#x6f;&#46;&#x2e;&#46;&#x40;&#103;&#109;&#97;&#x69;&#108;&#x2e;&#99;&#x6f;&#x6d;&#93;&#40;&#x29;">&#91;&#113;&#x69;&#97;&#x6f;&#46;&#x2e;&#46;&#x40;&#103;&#109;&#97;&#x69;&#108;&#x2e;&#99;&#x6f;&#x6d;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>并行计算本来就是曲高和寡的东西，就跟3D渲染一样，能开发引擎的毕竟只是小部分人，大多数人在引擎的基础上做应用。关键在于是否有杀手应用，只要有大量的需求 ，自然会有人去做开发。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#109;&#97;&#x69;&#108;&#116;&#x6f;&#58;&#91;&#x68;&#x6f;&#x6e;&#x67;&#122;&#104;&#x61;&#110;&#x67;&#x2e;&#x2e;&#46;&#46;&#64;&#x67;&#x6d;&#x61;&#105;&#x6c;&#46;&#x63;&#x6f;&#109;&#93;&#40;&#41;">&#91;&#x68;&#x6f;&#x6e;&#x67;&#122;&#104;&#x61;&#110;&#x67;&#x2e;&#x2e;&#46;&#46;&#64;&#x67;&#x6d;&#x61;&#105;&#x6c;&#46;&#x63;&#x6f;&#109;&#93;&#40;&#41;</a></p>
<blockquote>
<p>异构平台从网络处理器算起已经快10年了，现在情况仍然不明朗。就我看到的，异构平台要想高效，就必须向程序员暴露非常多的硬件细节，这必然导致编程的复杂性。 曲高和寡，要想渗透到应用程序这一块，我觉得很难。</p>
<p>2010/3/24 qiaojie <a href="&#109;&#x61;&#x69;&#108;&#116;&#111;&#x3a;&#91;&#x71;&#105;&#97;&#x6f;&#x2e;&#46;&#x2e;&#x40;&#103;&#x6d;&#x61;&#105;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#x29;">&#91;&#x71;&#105;&#97;&#x6f;&#x2e;&#46;&#x2e;&#x40;&#103;&#x6d;&#x61;&#105;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#x29;</a></p>
<blockquote>
<p>说的没错，cell已经成了先烈了。不过这不代表异构的方向不对，CUDA，OpenCL也都是异构平台，以后我们会越来越习惯异构平台的。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#109;&#x61;&#105;&#108;&#x74;&#x6f;&#x3a;&#91;&#104;&#111;&#x6e;&#x67;&#122;&#104;&#97;&#110;&#103;&#x2e;&#x2e;&#x2e;&#46;&#64;&#103;&#109;&#97;&#105;&#108;&#x2e;&#99;&#111;&#x6d;&#x5d;&#x28;&#41;">&#91;&#104;&#111;&#x6e;&#x67;&#122;&#104;&#97;&#110;&#103;&#x2e;&#x2e;&#x2e;&#46;&#64;&#103;&#109;&#97;&#105;&#108;&#x2e;&#99;&#111;&#x6d;&#x5d;&#x28;&#41;</a></p>
<p>异构平台如果编程复杂度降不下来的话很难流行起来。cell已经死了...</p>
<blockquote>
<p> 2010/3/24 qiaojie <a href="&#x6d;&#97;&#105;&#x6c;&#116;&#x6f;&#58;&#x5b;&#x71;&#105;&#97;&#111;&#46;&#46;&#x2e;&#64;&#x67;&#x6d;&#x61;&#x69;&#108;&#x2e;&#99;&#x6f;&#x6d;&#93;&#40;&#x29;">&#x5b;&#x71;&#105;&#97;&#111;&#46;&#46;&#x2e;&#64;&#x67;&#x6d;&#x61;&#x69;&#108;&#x2e;&#99;&#x6f;&#x6d;&#93;&#40;&#x29;</a></p>
<blockquote>
<p>不是所有的程序都需要并行化的，能用串行化解决的问题没必要并行，所以即使将来many-core系统成为主流，大部分程序员也没必要去搞并行计算。
  我觉得未来的主流应该是类似cell这样一颗全功能核心带众多协处理核心的异构系统，这样才能达到最优的 性能/核心面积比。</p>
<p>2010/3/24 Guancheng Chen <a href="&#109;&#97;&#x69;&#x6c;&#116;&#x6f;&#58;&#x5b;&#x63;&#x68;&#101;&#x6e;&#103;&#117;&#97;&#110;&#99;&#104;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#109;&#x61;&#x69;&#108;&#46;&#x63;&#x6f;&#x6d;&#93;&#40;&#x29;">&#x5b;&#x63;&#x68;&#101;&#x6e;&#103;&#117;&#97;&#110;&#99;&#104;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#109;&#x61;&#x69;&#108;&#46;&#x63;&#x6f;&#x6d;&#93;&#40;&#x29;</a></p>
<p>Nice 大胆预测Linear speedup应该是每个程序员十年后的目标 呵呵</p>
<blockquote>
<p>On 3月23日, 上午10时43分, qiaojie <a href="&#109;&#97;&#x69;&#108;&#x74;&#111;&#58;&#91;&#113;&#105;&#97;&#x6f;&#46;&#x2e;&#46;&#x40;&#103;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#x29;">&#91;&#113;&#105;&#97;&#x6f;&#46;&#x2e;&#46;&#x40;&#103;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>目前正在写的是一个软件渲染器，采用了光栅化和光线跟踪混合算法，渲染算法已经完全并行化了，
在4核系统上基本可以达到线性加速比，更多核的系统暂时还没测试。kd-tree的构造暂时还没有并
行化，以后有空了再研究。</p>
<p>2010/3/23 Guancheng Chen <a href="&#x6d;&#x61;&#x69;&#x6c;&#116;&#111;&#58;&#91;&#x63;&#x68;&#101;&#110;&#x67;&#117;&#97;&#x6e;&#x63;&#x68;&#46;&#x2e;&#x2e;&#x40;&#x67;&#109;&#97;&#x69;&#x6c;&#46;&#x63;&#x6f;&#109;&#x5d;&#40;&#41;">&#91;&#x63;&#x68;&#101;&#110;&#x67;&#117;&#97;&#x6e;&#x63;&#x68;&#46;&#x2e;&#x2e;&#x40;&#x67;&#109;&#97;&#x69;&#x6c;&#46;&#x63;&#x6f;&#109;&#x5d;&#40;&#41;</a></p>
<blockquote>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？</p>
<p>On 3月23日, 上午9时15分, qiaojie <a href="&#x6d;&#x61;&#105;&#x6c;&#x74;&#111;&#58;&#91;&#113;&#105;&#x61;&#111;&#x2e;&#x2e;&#46;&#x40;&#x67;&#109;&#97;&#105;&#x6c;&#x2e;&#99;&#x6f;&#109;&#x5d;&#x28;&#41;">&#91;&#113;&#105;&#x61;&#111;&#x2e;&#x2e;&#46;&#x40;&#x67;&#109;&#97;&#105;&#x6c;&#x2e;&#99;&#x6f;&#109;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1)
=
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank
Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？</p>
</blockquote>
<p> To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> 机械唯物主义 : linjunhalida <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-25</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>产能过剩的说法本来就不对。
产出的东西没有价值，这样的活动就不能说是生产。
比如我这个程序员，花了1周写了一个垃圾程序，然后被开除了。
然后1个月闲着，这是我产能过剩吗？
而闲着的原因是政府给我失业金，我就不需要工作闲起来了。。。
2010/3/25 qiaojie <a href="&#x6d;&#97;&#x69;&#x6c;&#x74;&#x6f;&#58;&#x5b;&#113;&#105;&#x61;&#46;&#46;&#46;&#x40;&#x67;&#109;&#x61;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#41;">&#x5b;&#113;&#105;&#x61;&#46;&#46;&#46;&#x40;&#x67;&#109;&#x61;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#41;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>如果产能=消费的话就没有产能过剩这一说了。</p>
<p>2010/3/25 机械唯物主义 : linjunhalida <a href="&#x6d;&#x61;&#x69;&#108;&#x74;&#111;&#x3a;&#91;&#x6c;&#105;&#x6e;&#x6a;&#117;&#110;&#46;&#46;&#46;&#64;&#x67;&#109;&#97;&#105;&#x6c;&#46;&#x63;&#111;&#109;&#x5d;&#40;&#x29;">&#91;&#x6c;&#105;&#x6e;&#x6a;&#117;&#110;&#46;&#46;&#46;&#64;&#x67;&#109;&#97;&#105;&#x6c;&#46;&#x63;&#111;&#109;&#x5d;&#40;&#x29;</a></p>
<p>一个谬误：刺激需求
产能=消费，产能才是主动力。技术成长是随着产能成长而起来的。
而产能多的结果就是满足了需求，造成一种需求带来技术进步的假像。
而技术和产能之间的关系又错综复杂。。
2010/3/25 qiaojie <a href="&#x6d;&#97;&#x69;&#x6c;&#116;&#x6f;&#x3a;&#x5b;&#113;&#105;&#x61;&#46;&#x2e;&#46;&#x40;&#x67;&#109;&#97;&#x69;&#108;&#x2e;&#99;&#111;&#x6d;&#93;&#40;&#41;">&#x5b;&#113;&#105;&#x61;&#46;&#x2e;&#46;&#x40;&#x67;&#109;&#97;&#x69;&#108;&#x2e;&#99;&#111;&#x6d;&#93;&#40;&#41;</a></p>
<p>3D游戏就是一类杀手应用，由此支撑起了一个庞大的GPU市场，芯片行业的研发成本是很高的，没有一个庞大的市场是做不起来的。目前的消费者对于多核系统显然还没有强烈的需求，因为应用跟不上，i7发布快2年了还没进入主流市场，这种情况延续下去的话摩尔定律将因此失效。不过我相信杀手级应用总会出现的，这可能要硬件性能突破一个临界点，比方说目前GPU的性能再提升一个数量级的话，光线跟踪算法就可以提供流畅的接近CG的画质，倒是此类应用便会流行开来。</p>
<p>2010/3/25 Guancheng Chen <a href="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#111;&#58;&#91;&#99;&#x68;&#101;&#x6e;&#x67;&#117;&#46;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#97;&#x69;&#108;&#46;&#x63;&#111;&#x6d;&#x5d;&#x28;&#41;">&#91;&#99;&#x68;&#101;&#x6e;&#x67;&#117;&#46;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#97;&#x69;&#108;&#46;&#x63;&#111;&#x6d;&#x5d;&#x28;&#41;</a></p>
<p>杀手应用一般来说是指什么样的应用呢？比如用户群特别大的网游？还是那些专有的科学计算用的软件？
On 3月24日, 下午12时36分, qiaojie <a href="&#109;&#97;&#105;&#x6c;&#116;&#111;&#58;&#x5b;&#x71;&#x69;&#97;&#111;&#46;&#46;&#46;&#64;&#103;&#109;&#x61;&#x69;&#x6c;&#46;&#99;&#x6f;&#109;&#93;&#40;&#x29;">&#x5b;&#x71;&#x69;&#97;&#111;&#46;&#46;&#46;&#64;&#103;&#109;&#x61;&#x69;&#x6c;&#46;&#99;&#x6f;&#109;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>并行计算本来就是曲高和寡的东西，就跟3D渲染一样，能开发引擎的毕竟只是小部分人，大多数人在引擎的基础上做应用。关键在于是否有杀手应用，只要有大量的需求 ，自然会有人去做开发。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#x6d;&#x61;&#105;&#108;&#x74;&#111;&#x3a;&#x5b;&#x68;&#111;&#x6e;&#103;&#x7a;&#104;&#97;&#110;&#103;&#46;&#x2e;&#x2e;&#46;&#64;&#x67;&#x6d;&#x61;&#105;&#108;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#40;&#41;">&#x5b;&#x68;&#111;&#x6e;&#103;&#x7a;&#104;&#97;&#110;&#103;&#46;&#x2e;&#x2e;&#46;&#64;&#x67;&#x6d;&#x61;&#105;&#108;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#40;&#41;</a></p>
<blockquote>
<p>异构平台从网络处理器算起已经快10年了，现在情况仍然不明朗。就我看到的，异构平台要想高效，就必须向程序员暴露非常多的硬件细节，这必然导致编程的复杂性。 曲高和寡，要想渗透到应用程序这一块，我觉得很难。</p>
<p>2010/3/24 qiaojie <a href="&#109;&#97;&#x69;&#108;&#x74;&#111;&#x3a;&#x5b;&#113;&#x69;&#x61;&#x6f;&#46;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#97;&#105;&#108;&#x2e;&#99;&#111;&#x6d;&#x5d;&#40;&#x29;">&#x5b;&#113;&#x69;&#x61;&#x6f;&#46;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#97;&#105;&#108;&#x2e;&#99;&#111;&#x6d;&#x5d;&#40;&#x29;</a></p>
<blockquote>
<p>说的没错，cell已经成了先烈了。不过这不代表异构的方向不对，CUDA，OpenCL也都是异构平台，以后我们会越来越习惯异构平台的。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#109;&#97;&#x69;&#108;&#116;&#x6f;&#x3a;&#x5b;&#104;&#111;&#x6e;&#103;&#122;&#x68;&#97;&#110;&#x67;&#x2e;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#105;&#108;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#40;&#41;">&#x5b;&#104;&#111;&#x6e;&#103;&#122;&#x68;&#97;&#110;&#x67;&#x2e;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#105;&#108;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#40;&#41;</a></p>
<p>异构平台如果编程复杂度降不下来的话很难流行起来。cell已经死了...</p>
<blockquote>
<p> 2010/3/24 qiaojie <a href="&#109;&#97;&#105;&#x6c;&#x74;&#x6f;&#x3a;&#91;&#x71;&#x69;&#97;&#111;&#46;&#x2e;&#46;&#x40;&#103;&#109;&#97;&#105;&#108;&#x2e;&#99;&#x6f;&#109;&#93;&#40;&#41;">&#91;&#x71;&#x69;&#97;&#111;&#46;&#x2e;&#46;&#x40;&#103;&#109;&#97;&#105;&#108;&#x2e;&#99;&#x6f;&#109;&#93;&#40;&#41;</a></p>
<blockquote>
<p>不是所有的程序都需要并行化的，能用串行化解决的问题没必要并行，所以即使将来many-core系统成为主流，大部分程序员也没必要去搞并行计算。
  我觉得未来的主流应该是类似cell这样一颗全功能核心带众多协处理核心的异构系统，这样才能达到最优的 性能/核心面积比。</p>
<p>2010/3/24 Guancheng Chen <a href="&#x6d;&#x61;&#x69;&#x6c;&#116;&#111;&#58;&#x5b;&#99;&#x68;&#101;&#x6e;&#x67;&#117;&#97;&#110;&#99;&#104;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#109;&#x61;&#105;&#108;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#x28;&#x29;">&#x5b;&#99;&#x68;&#101;&#x6e;&#x67;&#117;&#97;&#110;&#99;&#104;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#109;&#x61;&#105;&#108;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#x28;&#x29;</a></p>
<p>Nice 大胆预测Linear speedup应该是每个程序员十年后的目标 呵呵</p>
<blockquote>
<p>On 3月23日, 上午10时43分, qiaojie <a href="&#x6d;&#97;&#105;&#108;&#x74;&#x6f;&#58;&#x5b;&#x71;&#x69;&#97;&#x6f;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#105;&#x6c;&#46;&#x63;&#111;&#x6d;&#93;&#x28;&#41;">&#x5b;&#x71;&#x69;&#97;&#x6f;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#105;&#x6c;&#46;&#x63;&#111;&#x6d;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>目前正在写的是一个软件渲染器，采用了光栅化和光线跟踪混合算法，渲染算法已经完全并行化了，
在4核系统上基本可以达到线性加速比，更多核的系统暂时还没测试。kd-tree的构造暂时还没有并
行化，以后有空了再研究。</p>
<p>2010/3/23 Guancheng Chen <a href="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#111;&#x3a;&#91;&#x63;&#104;&#x65;&#x6e;&#103;&#x75;&#97;&#x6e;&#x63;&#x68;&#x2e;&#46;&#x2e;&#64;&#103;&#x6d;&#97;&#x69;&#108;&#x2e;&#x63;&#x6f;&#109;&#93;&#40;&#41;">&#91;&#x63;&#104;&#x65;&#x6e;&#103;&#x75;&#97;&#x6e;&#x63;&#x68;&#x2e;&#46;&#x2e;&#64;&#103;&#x6d;&#97;&#x69;&#108;&#x2e;&#x63;&#x6f;&#109;&#93;&#40;&#41;</a></p>
<blockquote>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？</p>
<p>On 3月23日, 上午9时15分, qiaojie <a href="&#109;&#97;&#x69;&#x6c;&#116;&#111;&#58;&#91;&#113;&#x69;&#97;&#111;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#97;&#105;&#x6c;&#46;&#x63;&#111;&#109;&#x5d;&#x28;&#x29;">&#91;&#113;&#x69;&#97;&#111;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#97;&#105;&#x6c;&#46;&#x63;&#111;&#109;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1)
=
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank
Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？</p>
</blockquote>
<p> To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a></p>
<p><img src="" alt=""> 机械唯物主义 : linjunhalida <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-25</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>扯远了。我觉得并行和串行应该是信息处理本质上的2种方式，
在不同的场景下，可以采用不同的方式进行。
重要的是能够“又好又快”地实现需求，以及根据场景，把一个需求进行实现方式的伸缩。
不过看起来这样的工作还是要靠程序员来实现？而体系架构设计者要根据对应问题的本质特性来设计架构？
2010/3/25 机械唯物主义 : linjunhalida <a href="&#109;&#97;&#105;&#x6c;&#116;&#111;&#58;&#x5b;&#108;&#x69;&#110;&#x6a;&#117;&#x6e;&#46;&#x2e;&#46;&#x40;&#103;&#109;&#97;&#x69;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#x29;">&#x5b;&#108;&#x69;&#110;&#x6a;&#117;&#x6e;&#46;&#x2e;&#46;&#x40;&#103;&#109;&#97;&#x69;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#x29;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>产能过剩的说法本来就不对。
产出的东西没有价值，这样的活动就不能说是生产。
比如我这个程序员，花了1周写了一个垃圾程序，然后被开除了。
然后1个月闲着，这是我产能过剩吗？
而闲着的原因是政府给我失业金，我就不需要工作闲起来了。。。</p>
<p>2010/3/25 qiaojie <a href="&#109;&#x61;&#105;&#x6c;&#116;&#111;&#x3a;&#x5b;&#113;&#x69;&#97;&#46;&#x2e;&#x2e;&#x40;&#x67;&#109;&#x61;&#105;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#x29;">&#x5b;&#113;&#x69;&#97;&#46;&#x2e;&#x2e;&#x40;&#x67;&#109;&#x61;&#105;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#x29;</a>
如果产能=消费的话就没有产能过剩这一说了。</p>
<p>2010/3/25 机械唯物主义 : linjunhalida <a href="&#109;&#x61;&#x69;&#108;&#116;&#111;&#x3a;&#91;&#x6c;&#x69;&#110;&#x6a;&#x75;&#110;&#x2e;&#46;&#46;&#x40;&#x67;&#x6d;&#x61;&#105;&#x6c;&#46;&#x63;&#111;&#109;&#93;&#x28;&#x29;">&#91;&#x6c;&#x69;&#110;&#x6a;&#x75;&#110;&#x2e;&#46;&#46;&#x40;&#x67;&#x6d;&#x61;&#105;&#x6c;&#46;&#x63;&#111;&#109;&#93;&#x28;&#x29;</a></p>
<p>一个谬误：刺激需求
产能=消费，产能才是主动力。技术成长是随着产能成长而起来的。
而产能多的结果就是满足了需求，造成一种需求带来技术进步的假像。
而技术和产能之间的关系又错综复杂。。
2010/3/25 qiaojie <a href="&#109;&#x61;&#x69;&#x6c;&#x74;&#111;&#x3a;&#x5b;&#x71;&#105;&#97;&#x2e;&#46;&#46;&#64;&#103;&#109;&#x61;&#x69;&#x6c;&#46;&#99;&#111;&#109;&#x5d;&#40;&#x29;">&#x5b;&#x71;&#105;&#97;&#x2e;&#46;&#46;&#64;&#103;&#109;&#x61;&#x69;&#x6c;&#46;&#99;&#111;&#109;&#x5d;&#40;&#x29;</a></p>
<p>3D游戏就是一类杀手应用，由此支撑起了一个庞大的GPU市场，芯片行业的研发成本是很高的，没有一个庞大的市场是做不起来的。目前的消费者对于多核系统显然还没有强烈的需求，因为应用跟不上，i7发布快2年了还没进入主流市场，这种情况延续下去的话摩尔定律将因此失效。不过我相信杀手级应用总会出现的，这可能要硬件性能突破一个临界点，比方说目前GPU的性能再提升一个数量级的话，光线跟踪算法就可以提供流畅的接近CG的画质，倒是此类应用便会流行开来。</p>
<p>2010/3/25 Guancheng Chen <a href="&#x6d;&#x61;&#x69;&#108;&#x74;&#111;&#x3a;&#91;&#99;&#x68;&#x65;&#110;&#103;&#x75;&#x2e;&#46;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#x69;&#108;&#46;&#99;&#111;&#x6d;&#93;&#40;&#x29;">&#91;&#99;&#x68;&#x65;&#110;&#103;&#x75;&#x2e;&#46;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#x69;&#108;&#46;&#99;&#111;&#x6d;&#93;&#40;&#x29;</a></p>
<p>杀手应用一般来说是指什么样的应用呢？比如用户群特别大的网游？还是那些专有的科学计算用的软件？
On 3月24日, 下午12时36分, qiaojie <a href="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#111;&#x3a;&#91;&#x71;&#105;&#97;&#111;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#109;&#97;&#x69;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#x29;">&#91;&#x71;&#105;&#97;&#111;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#109;&#97;&#x69;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>并行计算本来就是曲高和寡的东西，就跟3D渲染一样，能开发引擎的毕竟只是小部分人，大多数人在引擎的基础上做应用。关键在于是否有杀手应用，只要有大量的需求 ，自然会有人去做开发。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#109;&#97;&#105;&#108;&#x74;&#111;&#x3a;&#x5b;&#x68;&#111;&#x6e;&#x67;&#122;&#104;&#x61;&#110;&#103;&#46;&#46;&#x2e;&#46;&#64;&#x67;&#x6d;&#x61;&#105;&#108;&#x2e;&#99;&#x6f;&#109;&#93;&#x28;&#41;">&#x5b;&#x68;&#111;&#x6e;&#x67;&#122;&#104;&#x61;&#110;&#103;&#46;&#46;&#x2e;&#46;&#64;&#x67;&#x6d;&#x61;&#105;&#108;&#x2e;&#99;&#x6f;&#109;&#93;&#x28;&#41;</a></p>
<blockquote>
<p>异构平台从网络处理器算起已经快10年了，现在情况仍然不明朗。就我看到的，异构平台要想高效，就必须向程序员暴露非常多的硬件细节，这必然导致编程的复杂性。 曲高和寡，要想渗透到应用程序这一块，我觉得很难。</p>
<p>2010/3/24 qiaojie <a href="&#x6d;&#97;&#x69;&#x6c;&#116;&#x6f;&#58;&#91;&#113;&#x69;&#x61;&#111;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#109;&#x61;&#105;&#108;&#x2e;&#x63;&#x6f;&#109;&#93;&#x28;&#41;">&#91;&#113;&#x69;&#x61;&#111;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#109;&#x61;&#105;&#108;&#x2e;&#x63;&#x6f;&#109;&#93;&#x28;&#41;</a></p>
<blockquote>
<p>说的没错，cell已经成了先烈了。不过这不代表异构的方向不对，CUDA，OpenCL也都是异构平台，以后我们会越来越习惯异构平台的。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#x6d;&#97;&#x69;&#108;&#116;&#x6f;&#58;&#x5b;&#104;&#x6f;&#110;&#103;&#122;&#x68;&#97;&#x6e;&#103;&#46;&#46;&#46;&#x2e;&#x40;&#x67;&#109;&#x61;&#x69;&#108;&#46;&#99;&#111;&#109;&#93;&#x28;&#41;">&#x5b;&#104;&#x6f;&#110;&#103;&#122;&#x68;&#97;&#x6e;&#103;&#46;&#46;&#46;&#x2e;&#x40;&#x67;&#109;&#x61;&#x69;&#108;&#46;&#99;&#111;&#109;&#93;&#x28;&#41;</a></p>
<p>异构平台如果编程复杂度降不下来的话很难流行起来。cell已经死了...</p>
<blockquote>
<p> 2010/3/24 qiaojie <a href="&#x6d;&#97;&#x69;&#x6c;&#x74;&#x6f;&#x3a;&#91;&#x71;&#105;&#97;&#111;&#x2e;&#46;&#46;&#64;&#103;&#109;&#97;&#105;&#108;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#x28;&#x29;">&#91;&#x71;&#105;&#97;&#111;&#x2e;&#46;&#46;&#64;&#103;&#109;&#97;&#105;&#108;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#x28;&#x29;</a></p>
<blockquote>
<p>不是所有的程序都需要并行化的，能用串行化解决的问题没必要并行，所以即使将来many-core系统成为主流，大部分程序员也没必要去搞并行计算。
  我觉得未来的主流应该是类似cell这样一颗全功能核心带众多协处理核心的异构系统，这样才能达到最优的 性能/核心面积比。</p>
<p>2010/3/24 Guancheng Chen <a href="&#x6d;&#97;&#105;&#x6c;&#116;&#111;&#58;&#91;&#x63;&#x68;&#101;&#110;&#103;&#x75;&#x61;&#110;&#x63;&#x68;&#x2e;&#x2e;&#46;&#64;&#103;&#109;&#x61;&#x69;&#108;&#x2e;&#99;&#x6f;&#109;&#93;&#40;&#x29;">&#91;&#x63;&#x68;&#101;&#110;&#103;&#x75;&#x61;&#110;&#x63;&#x68;&#x2e;&#x2e;&#46;&#64;&#103;&#109;&#x61;&#x69;&#108;&#x2e;&#99;&#x6f;&#109;&#93;&#40;&#x29;</a></p>
<p>Nice 大胆预测Linear speedup应该是每个程序员十年后的目标 呵呵</p>
<blockquote>
<p>On 3月23日, 上午10时43分, qiaojie <a href="&#109;&#97;&#105;&#x6c;&#116;&#x6f;&#58;&#91;&#x71;&#x69;&#x61;&#x6f;&#x2e;&#46;&#46;&#64;&#103;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#99;&#111;&#x6d;&#x5d;&#x28;&#41;">&#91;&#x71;&#x69;&#x61;&#x6f;&#x2e;&#46;&#46;&#64;&#103;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#99;&#111;&#x6d;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>目前正在写的是一个软件渲染器，采用了光栅化和光线跟踪混合算法，渲染算法已经完全并行化了，
在4核系统上基本可以达到线性加速比，更多核的系统暂时还没测试。kd-tree的构造暂时还没有并
行化，以后有空了再研究。</p>
<p>2010/3/23 Guancheng Chen <a href="&#109;&#x61;&#x69;&#x6c;&#116;&#x6f;&#x3a;&#91;&#99;&#x68;&#x65;&#110;&#103;&#x75;&#97;&#x6e;&#99;&#104;&#46;&#x2e;&#x2e;&#64;&#x67;&#109;&#x61;&#105;&#108;&#46;&#99;&#x6f;&#x6d;&#93;&#40;&#x29;">&#91;&#99;&#x68;&#x65;&#110;&#103;&#x75;&#97;&#x6e;&#99;&#104;&#46;&#x2e;&#x2e;&#64;&#x67;&#109;&#x61;&#105;&#108;&#46;&#99;&#x6f;&#x6d;&#93;&#40;&#x29;</a></p>
<blockquote>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？</p>
<p>On 3月23日, 上午9时15分, qiaojie <a href="&#x6d;&#97;&#105;&#x6c;&#116;&#111;&#x3a;&#x5b;&#113;&#105;&#97;&#x6f;&#x2e;&#46;&#46;&#x40;&#x67;&#109;&#x61;&#105;&#108;&#x2e;&#99;&#111;&#109;&#x5d;&#x28;&#x29;">&#x5b;&#113;&#105;&#97;&#x6f;&#x2e;&#46;&#46;&#x40;&#x67;&#109;&#x61;&#105;&#108;&#x2e;&#99;&#111;&#109;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1)
=
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank
Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？</p>
</blockquote>
<p> To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> qiaojie <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-25</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>什么叫产能过剩？假设全世界每年消费10000亿斤粮食，结果今年收成好，生产了15000亿斤，</p>
<p>那多出来的5000亿斤无法被市场消化掉，就是产能过剩。那5000亿斤没价值，是垃圾？生产那
5000亿斤的农民是闲的蛋疼没事干？靠政府失业金养？</p>
<p>2010/3/25 机械唯物主义 : linjunhalida <a href="&#109;&#x61;&#x69;&#108;&#116;&#111;&#58;&#x5b;&#x6c;&#105;&#110;&#106;&#117;&#x6e;&#x2e;&#46;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#105;&#x6c;&#46;&#x63;&#x6f;&#109;&#93;&#40;&#x29;">&#x5b;&#x6c;&#105;&#110;&#106;&#117;&#x6e;&#x2e;&#46;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#105;&#x6c;&#46;&#x63;&#x6f;&#109;&#93;&#40;&#x29;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>产能过剩的说法本来就不对。
产出的东西没有价值，这样的活动就不能说是生产。
比如我这个程序员，花了1周写了一个垃圾程序，然后被开除了。
然后1个月闲着，这是我产能过剩吗？
而闲着的原因是政府给我失业金，我就不需要工作闲起来了。。。</p>
<p>2010/3/25 qiaojie <a href="&#x6d;&#x61;&#x69;&#108;&#x74;&#111;&#x3a;&#x5b;&#113;&#x69;&#97;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#111;&#x6d;&#93;&#40;&#41;">&#x5b;&#113;&#x69;&#97;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#111;&#x6d;&#93;&#40;&#41;</a>
如果产能=消费的话就没有产能过剩这一说了。</p>
<p>2010/3/25 机械唯物主义 : linjunhalida <a href="&#x6d;&#97;&#105;&#108;&#x74;&#111;&#x3a;&#91;&#x6c;&#x69;&#x6e;&#x6a;&#117;&#110;&#x2e;&#x2e;&#46;&#x40;&#103;&#109;&#97;&#x69;&#108;&#46;&#x63;&#x6f;&#x6d;&#93;&#40;&#x29;">&#91;&#x6c;&#x69;&#x6e;&#x6a;&#117;&#110;&#x2e;&#x2e;&#46;&#x40;&#103;&#109;&#97;&#x69;&#108;&#46;&#x63;&#x6f;&#x6d;&#93;&#40;&#x29;</a></p>
<p>一个谬误：刺激需求
产能=消费，产能才是主动力。技术成长是随着产能成长而起来的。
而产能多的结果就是满足了需求，造成一种需求带来技术进步的假像。
而技术和产能之间的关系又错综复杂。。
2010/3/25 qiaojie <a href="&#x6d;&#x61;&#x69;&#108;&#116;&#x6f;&#x3a;&#91;&#x71;&#x69;&#97;&#46;&#46;&#46;&#64;&#x67;&#109;&#x61;&#105;&#x6c;&#x2e;&#99;&#x6f;&#109;&#x5d;&#x28;&#x29;">&#91;&#x71;&#x69;&#97;&#46;&#46;&#46;&#64;&#x67;&#109;&#x61;&#105;&#x6c;&#x2e;&#99;&#x6f;&#109;&#x5d;&#x28;&#x29;</a></p>
<p>3D游戏就是一类杀手应用，由此支撑起了一个庞大的GPU市场，芯片行业的研发成本是很高的，没有一个庞大的市场是做不起来的。目前的消费者对于多核系统显然还没有强烈的需求，因为应用跟不上，i7发布快2年了还没进入主流市场，这种情况延续下去的话摩尔定律将因此失效。不过我相信杀手级应用总会出现的，这可能要硬件性能突破一个临界点，比方说目前GPU的性能再提升一个数量级的话，光线跟踪算法就可以提供流畅的接近CG的画质，倒是此类应用便会流行开来。</p>
<p>2010/3/25 Guancheng Chen <a href="&#109;&#97;&#105;&#x6c;&#116;&#x6f;&#x3a;&#x5b;&#99;&#104;&#101;&#x6e;&#103;&#117;&#x2e;&#46;&#x2e;&#64;&#103;&#109;&#97;&#105;&#x6c;&#46;&#99;&#111;&#x6d;&#x5d;&#40;&#x29;">&#x5b;&#99;&#104;&#101;&#x6e;&#103;&#117;&#x2e;&#46;&#x2e;&#64;&#103;&#109;&#97;&#105;&#x6c;&#46;&#99;&#111;&#x6d;&#x5d;&#40;&#x29;</a></p>
<p>杀手应用一般来说是指什么样的应用呢？比如用户群特别大的网游？还是那些专有的科学计算用的软件？
On 3月24日, 下午12时36分, qiaojie <a href="&#109;&#97;&#105;&#x6c;&#x74;&#x6f;&#58;&#x5b;&#113;&#x69;&#97;&#x6f;&#x2e;&#x2e;&#46;&#64;&#x67;&#109;&#97;&#105;&#x6c;&#46;&#x63;&#111;&#109;&#93;&#x28;&#41;">&#x5b;&#113;&#x69;&#97;&#x6f;&#x2e;&#x2e;&#46;&#64;&#x67;&#109;&#97;&#105;&#x6c;&#46;&#x63;&#111;&#109;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>并行计算本来就是曲高和寡的东西，就跟3D渲染一样，能开发引擎的毕竟只是小部分人，大多数人在引擎的基础上做应用。关键在于是否有杀手应用，只要有大量的需求 ，自然会有人去做开发。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#109;&#97;&#105;&#108;&#116;&#x6f;&#58;&#91;&#x68;&#111;&#110;&#x67;&#122;&#104;&#x61;&#x6e;&#x67;&#46;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#109;&#97;&#x69;&#108;&#46;&#99;&#x6f;&#109;&#93;&#40;&#x29;">&#91;&#x68;&#111;&#110;&#x67;&#122;&#104;&#x61;&#x6e;&#x67;&#46;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#109;&#97;&#x69;&#108;&#46;&#99;&#x6f;&#109;&#93;&#40;&#x29;</a></p>
<blockquote>
<p>异构平台从网络处理器算起已经快10年了，现在情况仍然不明朗。就我看到的，异构平台要想高效，就必须向程序员暴露非常多的硬件细节，这必然导致编程的复杂性。 曲高和寡，要想渗透到应用程序这一块，我觉得很难。</p>
<p>2010/3/24 qiaojie <a href="&#109;&#x61;&#105;&#x6c;&#116;&#x6f;&#x3a;&#x5b;&#113;&#105;&#97;&#111;&#x2e;&#46;&#x2e;&#64;&#x67;&#109;&#x61;&#x69;&#108;&#46;&#99;&#x6f;&#109;&#x5d;&#40;&#x29;">&#x5b;&#113;&#105;&#97;&#111;&#x2e;&#46;&#x2e;&#64;&#x67;&#109;&#x61;&#x69;&#108;&#46;&#99;&#x6f;&#109;&#x5d;&#40;&#x29;</a></p>
<blockquote>
<p>说的没错，cell已经成了先烈了。不过这不代表异构的方向不对，CUDA，OpenCL也都是异构平台，以后我们会越来越习惯异构平台的。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#111;&#x3a;&#x5b;&#x68;&#x6f;&#x6e;&#x67;&#122;&#104;&#97;&#110;&#x67;&#46;&#x2e;&#46;&#x2e;&#x40;&#103;&#109;&#97;&#x69;&#108;&#x2e;&#99;&#x6f;&#109;&#93;&#x28;&#41;">&#x5b;&#x68;&#x6f;&#x6e;&#x67;&#122;&#104;&#97;&#110;&#x67;&#46;&#x2e;&#46;&#x2e;&#x40;&#103;&#109;&#97;&#x69;&#108;&#x2e;&#99;&#x6f;&#109;&#93;&#x28;&#41;</a></p>
<p>异构平台如果编程复杂度降不下来的话很难流行起来。cell已经死了...</p>
<blockquote>
<p> 2010/3/24 qiaojie <a href="&#109;&#x61;&#105;&#108;&#x74;&#x6f;&#x3a;&#x5b;&#113;&#105;&#x61;&#111;&#46;&#x2e;&#x2e;&#64;&#103;&#x6d;&#97;&#x69;&#108;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#x29;">&#x5b;&#113;&#105;&#x61;&#111;&#46;&#x2e;&#x2e;&#64;&#103;&#x6d;&#97;&#x69;&#108;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#x29;</a></p>
<blockquote>
<p>不是所有的程序都需要并行化的，能用串行化解决的问题没必要并行，所以即使将来many-core系统成为主流，大部分程序员也没必要去搞并行计算。
  我觉得未来的主流应该是类似cell这样一颗全功能核心带众多协处理核心的异构系统，这样才能达到最优的 性能/核心面积比。</p>
<p>2010/3/24 Guancheng Chen <a href="&#109;&#97;&#105;&#x6c;&#116;&#111;&#x3a;&#x5b;&#99;&#104;&#x65;&#x6e;&#x67;&#117;&#x61;&#x6e;&#99;&#104;&#x2e;&#46;&#46;&#64;&#x67;&#109;&#x61;&#105;&#x6c;&#46;&#99;&#x6f;&#x6d;&#x5d;&#40;&#x29;">&#x5b;&#99;&#104;&#x65;&#x6e;&#x67;&#117;&#x61;&#x6e;&#99;&#104;&#x2e;&#46;&#46;&#64;&#x67;&#109;&#x61;&#105;&#x6c;&#46;&#99;&#x6f;&#x6d;&#x5d;&#40;&#x29;</a></p>
<p>Nice 大胆预测Linear speedup应该是每个程序员十年后的目标 呵呵</p>
<blockquote>
<p>On 3月23日, 上午10时43分, qiaojie <a href="&#x6d;&#97;&#105;&#108;&#x74;&#111;&#58;&#91;&#x71;&#x69;&#97;&#x6f;&#x2e;&#46;&#x2e;&#64;&#103;&#x6d;&#97;&#105;&#x6c;&#x2e;&#99;&#x6f;&#109;&#x5d;&#40;&#41;">&#91;&#x71;&#x69;&#97;&#x6f;&#x2e;&#46;&#x2e;&#64;&#103;&#x6d;&#97;&#105;&#x6c;&#x2e;&#99;&#x6f;&#109;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>目前正在写的是一个软件渲染器，采用了光栅化和光线跟踪混合算法，渲染算法已经完全并行化了，
在4核系统上基本可以达到线性加速比，更多核的系统暂时还没测试。kd-tree的构造暂时还没有并
行化，以后有空了再研究。</p>
<p>2010/3/23 Guancheng Chen <a href="&#109;&#97;&#x69;&#x6c;&#x74;&#111;&#x3a;&#x5b;&#x63;&#104;&#x65;&#x6e;&#x67;&#x75;&#97;&#x6e;&#x63;&#104;&#x2e;&#46;&#46;&#x40;&#x67;&#109;&#x61;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#93;&#40;&#41;">&#x5b;&#x63;&#104;&#x65;&#x6e;&#x67;&#x75;&#97;&#x6e;&#x63;&#104;&#x2e;&#46;&#46;&#x40;&#x67;&#109;&#x61;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#93;&#40;&#41;</a></p>
<blockquote>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？</p>
<p>On 3月23日, 上午9时15分, qiaojie <a href="&#x6d;&#x61;&#x69;&#108;&#x74;&#111;&#58;&#x5b;&#113;&#x69;&#97;&#x6f;&#x2e;&#x2e;&#46;&#x40;&#x67;&#109;&#x61;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#40;&#41;">&#x5b;&#113;&#x69;&#97;&#x6f;&#x2e;&#x2e;&#46;&#x40;&#x67;&#109;&#x61;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1)
=
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank
Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？</p>
</blockquote>
<p> To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a></p>
<p><img src="" alt=""> tinyfool <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-25</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>哈哈，终于从技术聊到经济了</p>
<p>在 2010-3-25，下午2:11， qiaojie 写道：</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>什么叫产能过剩？假设全世界每年消费10000亿斤粮食，结果今年收成好，生产了15000亿斤，</p>
<p>那多出来的5000亿斤无法被市场消化掉，就是产能过剩。那5000亿斤没价值，是垃圾？生产那
5000亿斤的农民是闲的蛋疼没事干？靠政府失业金养？</p>
<p>2010/3/25 机械唯物主义 : linjunhalida <a href="&#x6d;&#97;&#105;&#x6c;&#x74;&#x6f;&#58;&#91;&#x6c;&#105;&#x6e;&#x6a;&#x75;&#x6e;&#46;&#46;&#x2e;&#64;&#103;&#x6d;&#97;&#105;&#108;&#46;&#x63;&#x6f;&#109;&#93;&#x28;&#x29;">&#91;&#x6c;&#105;&#x6e;&#x6a;&#x75;&#x6e;&#46;&#46;&#x2e;&#64;&#103;&#x6d;&#97;&#105;&#108;&#46;&#x63;&#x6f;&#109;&#93;&#x28;&#x29;</a>
产能过剩的说法本来就不对。
产出的东西没有价值，这样的活动就不能说是生产。
比如我这个程序员，花了1周写了一个垃圾程序，然后被开除了。
然后1个月闲着，这是我产能过剩吗？
而闲着的原因是政府给我失业金，我就不需要工作闲起来了。。。</p>
<p>2010/3/25 qiaojie <a href="&#x6d;&#x61;&#x69;&#108;&#116;&#111;&#x3a;&#91;&#x71;&#x69;&#x61;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#x61;&#x69;&#x6c;&#46;&#99;&#111;&#x6d;&#x5d;&#x28;&#x29;">&#91;&#x71;&#x69;&#x61;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#x61;&#x69;&#x6c;&#46;&#99;&#111;&#x6d;&#x5d;&#x28;&#x29;</a>
如果产能=消费的话就没有产能过剩这一说了。</p>
<p>2010/3/25 机械唯物主义 : linjunhalida <a href="&#x6d;&#97;&#x69;&#x6c;&#x74;&#x6f;&#58;&#91;&#108;&#x69;&#110;&#106;&#117;&#x6e;&#46;&#46;&#x2e;&#64;&#103;&#109;&#x61;&#x69;&#108;&#x2e;&#99;&#111;&#109;&#x5d;&#x28;&#x29;">&#91;&#108;&#x69;&#110;&#106;&#117;&#x6e;&#46;&#46;&#x2e;&#64;&#103;&#109;&#x61;&#x69;&#108;&#x2e;&#99;&#111;&#109;&#x5d;&#x28;&#x29;</a></p>
<p>一个谬误：刺激需求
产能=消费，产能才是主动力。技术成长是随着产能成长而起来的。
而产能多的结果就是满足了需求，造成一种需求带来技术进步的假像。
而技术和产能之间的关系又错综复杂。。
2010/3/25 qiaojie <a href="&#x6d;&#x61;&#105;&#108;&#x74;&#x6f;&#x3a;&#91;&#113;&#x69;&#97;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#109;&#x61;&#x69;&#108;&#46;&#99;&#111;&#109;&#93;&#40;&#x29;">&#91;&#113;&#x69;&#97;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#109;&#x61;&#x69;&#108;&#46;&#99;&#111;&#109;&#93;&#40;&#x29;</a></p>
<p>3D游戏就是一类杀手应用，由此支撑起了一个庞大的GPU市场，芯片行业的研发成本是很高的，没有一个庞大的市场是做不起来的。目前的消费者对于多核系统显然还没有强烈的需求，因为应用跟不上，i7发布快2年了还没进入主流市场，这种情况延续下去的话摩尔定律将因此失效。不过我相信杀手级应用总会出现的，这可能要硬件性能突破一个临界点，比方说目前GPU的性能再提升一个数量级的话，光线跟踪算法就可以提供流畅的接近CG的画质，倒是此类应用便会流行开来。</p>
<p>2010/3/25 Guancheng Chen <a href="&#109;&#97;&#105;&#x6c;&#x74;&#111;&#x3a;&#91;&#99;&#104;&#101;&#x6e;&#x67;&#x75;&#46;&#46;&#x2e;&#x40;&#103;&#x6d;&#x61;&#x69;&#x6c;&#46;&#x63;&#111;&#109;&#93;&#40;&#41;">&#91;&#99;&#104;&#101;&#x6e;&#x67;&#x75;&#46;&#46;&#x2e;&#x40;&#103;&#x6d;&#x61;&#x69;&#x6c;&#46;&#x63;&#111;&#109;&#93;&#40;&#41;</a></p>
<p>杀手应用一般来说是指什么样的应用呢？比如用户群特别大的网游？还是那些专有的科学计算用的软件？
On 3月24日, 下午12时36分, qiaojie <a href="&#x6d;&#x61;&#x69;&#108;&#x74;&#111;&#58;&#x5b;&#113;&#x69;&#x61;&#111;&#46;&#46;&#x2e;&#64;&#x67;&#x6d;&#97;&#x69;&#108;&#46;&#x63;&#x6f;&#109;&#x5d;&#40;&#x29;">&#x5b;&#113;&#x69;&#x61;&#111;&#46;&#46;&#x2e;&#64;&#x67;&#x6d;&#97;&#x69;&#108;&#46;&#x63;&#x6f;&#109;&#x5d;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>并行计算本来就是曲高和寡的东西，就跟3D渲染一样，能开发引擎的毕竟只是小部分人，大多数人在引擎的基础上做应用。关键在于是否有杀手应用，只要有大量的需求 ，自然会有人去做开发。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#x6d;&#97;&#105;&#x6c;&#x74;&#111;&#x3a;&#91;&#x68;&#x6f;&#110;&#103;&#122;&#104;&#97;&#110;&#x67;&#46;&#46;&#46;&#46;&#x40;&#x67;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#x6f;&#109;&#93;&#x28;&#41;">&#91;&#x68;&#x6f;&#110;&#103;&#122;&#104;&#97;&#110;&#x67;&#46;&#46;&#46;&#46;&#x40;&#x67;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#x6f;&#109;&#93;&#x28;&#41;</a></p>
<blockquote>
<p>异构平台从网络处理器算起已经快10年了，现在情况仍然不明朗。就我看到的，异构平台要想高效，就必须向程序员暴露非常多的硬件细节，这必然导致编程的复杂性。 曲高和寡，要想渗透到应用程序这一块，我觉得很难。</p>
<p>2010/3/24 qiaojie <a href="&#x6d;&#x61;&#105;&#108;&#x74;&#x6f;&#58;&#x5b;&#x71;&#x69;&#x61;&#111;&#46;&#x2e;&#46;&#x40;&#x67;&#109;&#x61;&#x69;&#108;&#x2e;&#99;&#111;&#x6d;&#93;&#40;&#x29;">&#x5b;&#x71;&#x69;&#x61;&#111;&#46;&#x2e;&#46;&#x40;&#x67;&#109;&#x61;&#x69;&#108;&#x2e;&#99;&#111;&#x6d;&#93;&#40;&#x29;</a></p>
<blockquote>
<p>说的没错，cell已经成了先烈了。不过这不代表异构的方向不对，CUDA，OpenCL也都是异构平台，以后我们会越来越习惯异构平台的。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#109;&#x61;&#105;&#x6c;&#116;&#111;&#58;&#91;&#104;&#111;&#110;&#103;&#x7a;&#x68;&#x61;&#110;&#103;&#46;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#109;&#x61;&#105;&#x6c;&#46;&#99;&#111;&#109;&#x5d;&#x28;&#41;">&#91;&#104;&#111;&#110;&#103;&#x7a;&#x68;&#x61;&#110;&#103;&#46;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#109;&#x61;&#105;&#x6c;&#46;&#99;&#111;&#109;&#x5d;&#x28;&#41;</a></p>
<p>异构平台如果编程复杂度降不下来的话很难流行起来。cell已经死了...</p>
<blockquote>
<p> 2010/3/24 qiaojie <a href="&#x6d;&#x61;&#105;&#108;&#116;&#x6f;&#x3a;&#91;&#x71;&#105;&#97;&#x6f;&#x2e;&#x2e;&#46;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#x6f;&#x6d;&#93;&#x28;&#x29;">&#91;&#x71;&#105;&#97;&#x6f;&#x2e;&#x2e;&#46;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#x6f;&#x6d;&#93;&#x28;&#x29;</a></p>
<blockquote>
<p>不是所有的程序都需要并行化的，能用串行化解决的问题没必要并行，所以即使将来many-core系统成为主流，大部分程序员也没必要去搞并行计算。
  我觉得未来的主流应该是类似cell这样一颗全功能核心带众多协处理核心的异构系统，这样才能达到最优的 性能/核心面积比。</p>
<p>2010/3/24 Guancheng Chen <a href="&#109;&#97;&#105;&#108;&#x74;&#x6f;&#58;&#x5b;&#x63;&#x68;&#x65;&#110;&#x67;&#117;&#97;&#x6e;&#99;&#104;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#109;&#x61;&#x69;&#108;&#x2e;&#99;&#111;&#x6d;&#x5d;&#x28;&#x29;">&#x5b;&#x63;&#x68;&#x65;&#110;&#x67;&#117;&#97;&#x6e;&#99;&#104;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#109;&#x61;&#x69;&#108;&#x2e;&#99;&#111;&#x6d;&#x5d;&#x28;&#x29;</a></p>
<p>Nice 大胆预测Linear speedup应该是每个程序员十年后的目标 呵呵</p>
<blockquote>
<p>On 3月23日, 上午10时43分, qiaojie <a href="&#109;&#x61;&#105;&#108;&#116;&#111;&#58;&#91;&#113;&#105;&#97;&#x6f;&#46;&#46;&#46;&#64;&#103;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#111;&#109;&#x5d;&#x28;&#41;">&#91;&#113;&#105;&#97;&#x6f;&#46;&#46;&#46;&#64;&#103;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#111;&#109;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>目前正在写的是一个软件渲染器，采用了光栅化和光线跟踪混合算法，渲染算法已经完全并行化了，
在4核系统上基本可以达到线性加速比，更多核的系统暂时还没测试。kd-tree的构造暂时还没有并
行化，以后有空了再研究。</p>
<p>2010/3/23 Guancheng Chen <a href="&#109;&#x61;&#x69;&#108;&#116;&#111;&#58;&#x5b;&#x63;&#104;&#101;&#x6e;&#x67;&#117;&#97;&#110;&#99;&#x68;&#46;&#46;&#x2e;&#x40;&#103;&#109;&#97;&#x69;&#x6c;&#46;&#x63;&#111;&#109;&#x5d;&#x28;&#41;">&#x5b;&#x63;&#104;&#101;&#x6e;&#x67;&#117;&#97;&#110;&#99;&#x68;&#46;&#46;&#x2e;&#x40;&#103;&#109;&#97;&#x69;&#x6c;&#46;&#x63;&#111;&#109;&#x5d;&#x28;&#41;</a></p>
<blockquote>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？</p>
<p>On 3月23日, 上午9时15分, qiaojie <a href="&#109;&#x61;&#x69;&#x6c;&#116;&#x6f;&#58;&#x5b;&#113;&#x69;&#97;&#x6f;&#46;&#46;&#46;&#x40;&#x67;&#x6d;&#x61;&#105;&#108;&#46;&#99;&#111;&#109;&#x5d;&#x28;&#41;">&#x5b;&#113;&#x69;&#97;&#x6f;&#46;&#46;&#46;&#x40;&#x67;&#x6d;&#x61;&#105;&#108;&#46;&#99;&#111;&#109;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1)
=
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank
Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？</p>
</blockquote>
<p> To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> 机械唯物主义 : linjunhalida <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-25</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>本来就不该生产那么多的粮食，多余的人力和土地可以用来做别的事情。
问题在于为什么他们估算错误？
2010/3/25 qiaojie <a href="&#x6d;&#x61;&#x69;&#108;&#x74;&#x6f;&#58;&#91;&#x71;&#x69;&#97;&#46;&#46;&#46;&#x40;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#109;&#93;&#x28;&#x29;">&#91;&#x71;&#x69;&#97;&#46;&#46;&#46;&#x40;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#109;&#93;&#x28;&#x29;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>什么叫产能过剩？假设全世界每年消费10000亿斤粮食，结果今年收成好，生产了15000亿斤，</p>
<p>那多出来的5000亿斤无法被市场消化掉，就是产能过剩。那5000亿斤没价值，是垃圾？生产那
5000亿斤的农民是闲的蛋疼没事干？靠政府失业金养？</p>
<p>2010/3/25 机械唯物主义 : linjunhalida <a href="&#109;&#x61;&#x69;&#x6c;&#116;&#111;&#58;&#x5b;&#x6c;&#x69;&#x6e;&#106;&#x75;&#x6e;&#x2e;&#46;&#46;&#64;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#46;&#99;&#111;&#x6d;&#x5d;&#x28;&#x29;">&#x5b;&#x6c;&#x69;&#x6e;&#106;&#x75;&#x6e;&#x2e;&#46;&#46;&#64;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#46;&#99;&#111;&#x6d;&#x5d;&#x28;&#x29;</a>
产能过剩的说法本来就不对。
产出的东西没有价值，这样的活动就不能说是生产。
比如我这个程序员，花了1周写了一个垃圾程序，然后被开除了。
然后1个月闲着，这是我产能过剩吗？
而闲着的原因是政府给我失业金，我就不需要工作闲起来了。。。</p>
<p>2010/3/25 qiaojie <a href="&#109;&#97;&#x69;&#x6c;&#116;&#x6f;&#58;&#x5b;&#113;&#x69;&#x61;&#46;&#x2e;&#46;&#x40;&#x67;&#x6d;&#97;&#x69;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#93;&#x28;&#41;">&#x5b;&#113;&#x69;&#x61;&#46;&#x2e;&#46;&#x40;&#x67;&#x6d;&#97;&#x69;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#93;&#x28;&#41;</a>
如果产能=消费的话就没有产能过剩这一说了。</p>
<p>2010/3/25 机械唯物主义 : linjunhalida <a href="&#109;&#x61;&#105;&#x6c;&#116;&#111;&#x3a;&#x5b;&#108;&#105;&#110;&#106;&#117;&#110;&#x2e;&#46;&#x2e;&#x40;&#103;&#x6d;&#x61;&#x69;&#x6c;&#46;&#99;&#111;&#x6d;&#93;&#x28;&#x29;">&#x5b;&#108;&#105;&#110;&#106;&#117;&#110;&#x2e;&#46;&#x2e;&#x40;&#103;&#x6d;&#x61;&#x69;&#x6c;&#46;&#99;&#111;&#x6d;&#93;&#x28;&#x29;</a></p>
<p>一个谬误：刺激需求
产能=消费，产能才是主动力。技术成长是随着产能成长而起来的。
而产能多的结果就是满足了需求，造成一种需求带来技术进步的假像。
而技术和产能之间的关系又错综复杂。。
2010/3/25 qiaojie <a href="&#x6d;&#x61;&#105;&#x6c;&#116;&#x6f;&#58;&#91;&#x71;&#105;&#x61;&#x2e;&#46;&#x2e;&#64;&#103;&#x6d;&#x61;&#105;&#108;&#46;&#x63;&#111;&#x6d;&#93;&#40;&#x29;">&#91;&#x71;&#105;&#x61;&#x2e;&#46;&#x2e;&#64;&#103;&#x6d;&#x61;&#105;&#108;&#46;&#x63;&#111;&#x6d;&#93;&#40;&#x29;</a></p>
<p>3D游戏就是一类杀手应用，由此支撑起了一个庞大的GPU市场，芯片行业的研发成本是很高的，没有一个庞大的市场是做不起来的。目前的消费者对于多核系统显然还没有强烈的需求，因为应用跟不上，i7发布快2年了还没进入主流市场，这种情况延续下去的话摩尔定律将因此失效。不过我相信杀手级应用总会出现的，这可能要硬件性能突破一个临界点，比方说目前GPU的性能再提升一个数量级的话，光线跟踪算法就可以提供流畅的接近CG的画质，倒是此类应用便会流行开来。</p>
<p>2010/3/25 Guancheng Chen <a href="&#x6d;&#x61;&#x69;&#108;&#x74;&#x6f;&#x3a;&#x5b;&#x63;&#x68;&#x65;&#110;&#x67;&#117;&#x2e;&#46;&#46;&#64;&#x67;&#109;&#97;&#105;&#x6c;&#46;&#99;&#x6f;&#109;&#93;&#x28;&#41;">&#x5b;&#x63;&#x68;&#x65;&#110;&#x67;&#117;&#x2e;&#46;&#46;&#64;&#x67;&#109;&#97;&#105;&#x6c;&#46;&#99;&#x6f;&#109;&#93;&#x28;&#41;</a></p>
<p>杀手应用一般来说是指什么样的应用呢？比如用户群特别大的网游？还是那些专有的科学计算用的软件？
On 3月24日, 下午12时36分, qiaojie <a href="&#x6d;&#97;&#x69;&#x6c;&#116;&#x6f;&#58;&#91;&#113;&#x69;&#x61;&#111;&#x2e;&#x2e;&#46;&#x40;&#103;&#109;&#97;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#40;&#41;">&#91;&#113;&#x69;&#x61;&#111;&#x2e;&#x2e;&#46;&#x40;&#103;&#109;&#97;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>并行计算本来就是曲高和寡的东西，就跟3D渲染一样，能开发引擎的毕竟只是小部分人，大多数人在引擎的基础上做应用。关键在于是否有杀手应用，只要有大量的需求 ，自然会有人去做开发。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#x6d;&#x61;&#x69;&#x6c;&#116;&#x6f;&#x3a;&#x5b;&#104;&#111;&#110;&#103;&#122;&#x68;&#x61;&#110;&#x67;&#x2e;&#x2e;&#x2e;&#46;&#64;&#103;&#109;&#x61;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#x28;&#x29;">&#x5b;&#104;&#111;&#110;&#103;&#122;&#x68;&#x61;&#110;&#x67;&#x2e;&#x2e;&#x2e;&#46;&#64;&#103;&#109;&#x61;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#x28;&#x29;</a></p>
<blockquote>
<p>异构平台从网络处理器算起已经快10年了，现在情况仍然不明朗。就我看到的，异构平台要想高效，就必须向程序员暴露非常多的硬件细节，这必然导致编程的复杂性。 曲高和寡，要想渗透到应用程序这一块，我觉得很难。</p>
<p>2010/3/24 qiaojie <a href="&#109;&#97;&#x69;&#x6c;&#116;&#x6f;&#58;&#x5b;&#x71;&#105;&#97;&#x6f;&#46;&#46;&#x2e;&#64;&#103;&#109;&#x61;&#x69;&#x6c;&#46;&#99;&#x6f;&#x6d;&#93;&#x28;&#x29;">&#x5b;&#x71;&#105;&#97;&#x6f;&#46;&#46;&#x2e;&#64;&#103;&#109;&#x61;&#x69;&#x6c;&#46;&#99;&#x6f;&#x6d;&#93;&#x28;&#x29;</a></p>
<blockquote>
<p>说的没错，cell已经成了先烈了。不过这不代表异构的方向不对，CUDA，OpenCL也都是异构平台，以后我们会越来越习惯异构平台的。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#109;&#97;&#x69;&#108;&#x74;&#x6f;&#58;&#91;&#104;&#x6f;&#110;&#x67;&#x7a;&#104;&#x61;&#110;&#103;&#x2e;&#46;&#46;&#46;&#64;&#103;&#x6d;&#x61;&#105;&#108;&#46;&#x63;&#111;&#x6d;&#x5d;&#40;&#41;">&#91;&#104;&#x6f;&#110;&#x67;&#x7a;&#104;&#x61;&#110;&#103;&#x2e;&#46;&#46;&#46;&#64;&#103;&#x6d;&#x61;&#105;&#108;&#46;&#x63;&#111;&#x6d;&#x5d;&#40;&#41;</a></p>
<p>异构平台如果编程复杂度降不下来的话很难流行起来。cell已经死了...</p>
<blockquote>
<p> 2010/3/24 qiaojie <a href="&#x6d;&#x61;&#105;&#x6c;&#x74;&#111;&#x3a;&#x5b;&#x71;&#x69;&#x61;&#x6f;&#46;&#x2e;&#x2e;&#x40;&#x67;&#109;&#x61;&#105;&#108;&#46;&#99;&#111;&#109;&#x5d;&#40;&#41;">&#x5b;&#x71;&#x69;&#x61;&#x6f;&#46;&#x2e;&#x2e;&#x40;&#x67;&#109;&#x61;&#105;&#108;&#46;&#99;&#111;&#109;&#x5d;&#40;&#41;</a></p>
<blockquote>
<p>不是所有的程序都需要并行化的，能用串行化解决的问题没必要并行，所以即使将来many-core系统成为主流，大部分程序员也没必要去搞并行计算。
  我觉得未来的主流应该是类似cell这样一颗全功能核心带众多协处理核心的异构系统，这样才能达到最优的 性能/核心面积比。</p>
<p>2010/3/24 Guancheng Chen <a href="&#x6d;&#97;&#105;&#x6c;&#x74;&#111;&#58;&#x5b;&#99;&#x68;&#x65;&#x6e;&#x67;&#117;&#x61;&#110;&#99;&#x68;&#46;&#x2e;&#46;&#x40;&#103;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#109;&#93;&#40;&#x29;">&#x5b;&#99;&#x68;&#x65;&#x6e;&#x67;&#117;&#x61;&#110;&#99;&#x68;&#46;&#x2e;&#46;&#x40;&#103;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#109;&#93;&#40;&#x29;</a></p>
<p>Nice 大胆预测Linear speedup应该是每个程序员十年后的目标 呵呵</p>
<blockquote>
<p>On 3月23日, 上午10时43分, qiaojie <a href="&#x6d;&#97;&#x69;&#108;&#x74;&#x6f;&#x3a;&#91;&#113;&#105;&#97;&#x6f;&#46;&#46;&#46;&#x40;&#x67;&#109;&#97;&#105;&#108;&#46;&#x63;&#x6f;&#109;&#93;&#x28;&#x29;">&#91;&#113;&#105;&#97;&#x6f;&#46;&#46;&#46;&#x40;&#x67;&#109;&#97;&#105;&#108;&#46;&#x63;&#x6f;&#109;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>目前正在写的是一个软件渲染器，采用了光栅化和光线跟踪混合算法，渲染算法已经完全并行化了，
在4核系统上基本可以达到线性加速比，更多核的系统暂时还没测试。kd-tree的构造暂时还没有并
行化，以后有空了再研究。</p>
<p>2010/3/23 Guancheng Chen <a href="&#x6d;&#97;&#105;&#108;&#116;&#x6f;&#58;&#91;&#x63;&#x68;&#x65;&#x6e;&#103;&#117;&#97;&#110;&#x63;&#x68;&#46;&#46;&#x2e;&#64;&#103;&#x6d;&#97;&#105;&#108;&#46;&#x63;&#111;&#109;&#x5d;&#x28;&#x29;">&#91;&#x63;&#x68;&#x65;&#x6e;&#103;&#117;&#97;&#110;&#x63;&#x68;&#46;&#46;&#x2e;&#64;&#103;&#x6d;&#97;&#105;&#108;&#46;&#x63;&#111;&#109;&#x5d;&#x28;&#x29;</a></p>
<blockquote>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？</p>
<p>On 3月23日, 上午9时15分, qiaojie <a href="&#x6d;&#97;&#105;&#108;&#116;&#x6f;&#58;&#91;&#113;&#x69;&#97;&#111;&#x2e;&#46;&#46;&#x40;&#x67;&#x6d;&#97;&#105;&#108;&#46;&#99;&#111;&#x6d;&#93;&#x28;&#x29;">&#91;&#113;&#x69;&#97;&#111;&#x2e;&#46;&#46;&#x40;&#x67;&#x6d;&#97;&#105;&#108;&#46;&#99;&#111;&#x6d;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1)
=
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank
Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？</p>
</blockquote>
<p> To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a></p>
<p><img src="" alt=""> qiaojie <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-25</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>产能过剩和短缺导致的价格波动是市场经济的典型特征，想要消除过剩和短缺那叫计划经济，</p>
<p>学点经济学常识再来讨论这些问题吧。
2010/3/25 机械唯物主义 : linjunhalida <a href="&#109;&#97;&#105;&#108;&#x74;&#111;&#x3a;&#91;&#x6c;&#105;&#110;&#x6a;&#x75;&#x6e;&#46;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#x61;&#x69;&#108;&#x2e;&#99;&#x6f;&#109;&#x5d;&#40;&#41;">&#91;&#x6c;&#105;&#110;&#x6a;&#x75;&#x6e;&#46;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#x61;&#x69;&#108;&#x2e;&#99;&#x6f;&#109;&#x5d;&#40;&#41;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>本来就不该生产那么多的粮食，多余的人力和土地可以用来做别的事情。
问题在于为什么他们估算错误？</p>
<p>2010/3/25 qiaojie <a href="&#109;&#97;&#x69;&#x6c;&#x74;&#x6f;&#58;&#x5b;&#x71;&#x69;&#97;&#x2e;&#46;&#46;&#x40;&#x67;&#109;&#x61;&#x69;&#108;&#x2e;&#x63;&#111;&#x6d;&#93;&#x28;&#41;">&#x5b;&#x71;&#x69;&#97;&#x2e;&#46;&#46;&#x40;&#x67;&#109;&#x61;&#x69;&#108;&#x2e;&#x63;&#111;&#x6d;&#93;&#x28;&#41;</a>
什么叫产能过剩？假设全世界每年消费10000亿斤粮食，结果今年收成好，生产了15000亿斤，</p>
<p>那多出来的5000亿斤无法被市场消化掉，就是产能过剩。那5000亿斤没价值，是垃圾？生产那
5000亿斤的农民是闲的蛋疼没事干？靠政府失业金养？</p>
<p>2010/3/25 机械唯物主义 : linjunhalida <a href="&#109;&#x61;&#105;&#x6c;&#116;&#x6f;&#58;&#x5b;&#108;&#105;&#110;&#x6a;&#117;&#x6e;&#46;&#x2e;&#46;&#64;&#x67;&#109;&#97;&#x69;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#93;&#x28;&#x29;">&#x5b;&#108;&#105;&#110;&#x6a;&#117;&#x6e;&#46;&#x2e;&#46;&#64;&#x67;&#109;&#97;&#x69;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#93;&#x28;&#x29;</a>
产能过剩的说法本来就不对。
产出的东西没有价值，这样的活动就不能说是生产。
比如我这个程序员，花了1周写了一个垃圾程序，然后被开除了。
然后1个月闲着，这是我产能过剩吗？
而闲着的原因是政府给我失业金，我就不需要工作闲起来了。。。</p>
<p>2010/3/25 qiaojie <a href="&#109;&#x61;&#x69;&#x6c;&#116;&#x6f;&#x3a;&#x5b;&#x71;&#x69;&#97;&#46;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#x61;&#x69;&#108;&#46;&#x63;&#x6f;&#109;&#93;&#40;&#x29;">&#x5b;&#x71;&#x69;&#97;&#46;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#x61;&#x69;&#108;&#46;&#x63;&#x6f;&#109;&#93;&#40;&#x29;</a>
如果产能=消费的话就没有产能过剩这一说了。</p>
<p>2010/3/25 机械唯物主义 : linjunhalida <a href="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#x6f;&#x3a;&#x5b;&#108;&#105;&#110;&#x6a;&#117;&#x6e;&#46;&#46;&#x2e;&#64;&#103;&#109;&#97;&#x69;&#108;&#46;&#99;&#x6f;&#109;&#93;&#40;&#x29;">&#x5b;&#108;&#105;&#110;&#x6a;&#117;&#x6e;&#46;&#46;&#x2e;&#64;&#103;&#109;&#97;&#x69;&#108;&#46;&#99;&#x6f;&#109;&#93;&#40;&#x29;</a></p>
<p>一个谬误：刺激需求
产能=消费，产能才是主动力。技术成长是随着产能成长而起来的。
而产能多的结果就是满足了需求，造成一种需求带来技术进步的假像。
而技术和产能之间的关系又错综复杂。。
2010/3/25 qiaojie <a href="&#109;&#x61;&#x69;&#x6c;&#116;&#111;&#58;&#91;&#x71;&#105;&#x61;&#46;&#46;&#x2e;&#x40;&#x67;&#109;&#97;&#x69;&#108;&#46;&#99;&#x6f;&#x6d;&#93;&#40;&#x29;">&#91;&#x71;&#105;&#x61;&#46;&#46;&#x2e;&#x40;&#x67;&#109;&#97;&#x69;&#108;&#46;&#99;&#x6f;&#x6d;&#93;&#40;&#x29;</a></p>
<p>3D游戏就是一类杀手应用，由此支撑起了一个庞大的GPU市场，芯片行业的研发成本是很高的，没有一个庞大的市场是做不起来的。目前的消费者对于多核系统显然还没有强烈的需求，因为应用跟不上，i7发布快2年了还没进入主流市场，这种情况延续下去的话摩尔定律将因此失效。不过我相信杀手级应用总会出现的，这可能要硬件性能突破一个临界点，比方说目前GPU的性能再提升一个数量级的话，光线跟踪算法就可以提供流畅的接近CG的画质，倒是此类应用便会流行开来。</p>
<p>2010/3/25 Guancheng Chen <a href="&#x6d;&#97;&#105;&#x6c;&#116;&#x6f;&#x3a;&#x5b;&#99;&#104;&#101;&#110;&#103;&#x75;&#x2e;&#46;&#x2e;&#x40;&#103;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#x6f;&#109;&#93;&#40;&#41;">&#x5b;&#99;&#104;&#101;&#110;&#103;&#x75;&#x2e;&#46;&#x2e;&#x40;&#103;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#x6f;&#109;&#93;&#40;&#41;</a></p>
<p>杀手应用一般来说是指什么样的应用呢？比如用户群特别大的网游？还是那些专有的科学计算用的软件？
On 3月24日, 下午12时36分, qiaojie <a href="&#x6d;&#97;&#105;&#108;&#x74;&#111;&#58;&#91;&#x71;&#x69;&#x61;&#111;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#109;&#97;&#x69;&#108;&#x2e;&#99;&#x6f;&#109;&#93;&#x28;&#41;">&#91;&#x71;&#x69;&#x61;&#111;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#109;&#97;&#x69;&#108;&#x2e;&#99;&#x6f;&#109;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>并行计算本来就是曲高和寡的东西，就跟3D渲染一样，能开发引擎的毕竟只是小部分人，大多数人在引擎的基础上做应用。关键在于是否有杀手应用，只要有大量的需求 ，自然会有人去做开发。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#109;&#97;&#105;&#108;&#x74;&#111;&#58;&#91;&#x68;&#x6f;&#110;&#103;&#122;&#x68;&#x61;&#x6e;&#x67;&#x2e;&#46;&#46;&#46;&#x40;&#103;&#109;&#x61;&#105;&#108;&#46;&#x63;&#x6f;&#109;&#x5d;&#x28;&#41;">&#91;&#x68;&#x6f;&#110;&#103;&#122;&#x68;&#x61;&#x6e;&#x67;&#x2e;&#46;&#46;&#46;&#x40;&#103;&#109;&#x61;&#105;&#108;&#46;&#x63;&#x6f;&#109;&#x5d;&#x28;&#41;</a></p>
<blockquote>
<p>异构平台从网络处理器算起已经快10年了，现在情况仍然不明朗。就我看到的，异构平台要想高效，就必须向程序员暴露非常多的硬件细节，这必然导致编程的复杂性。 曲高和寡，要想渗透到应用程序这一块，我觉得很难。</p>
<p>2010/3/24 qiaojie <a href="&#x6d;&#x61;&#105;&#108;&#116;&#x6f;&#58;&#x5b;&#x71;&#105;&#97;&#111;&#46;&#x2e;&#46;&#64;&#103;&#109;&#x61;&#x69;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#41;">&#x5b;&#x71;&#105;&#97;&#111;&#46;&#x2e;&#46;&#64;&#103;&#109;&#x61;&#x69;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#41;</a></p>
<blockquote>
<p>说的没错，cell已经成了先烈了。不过这不代表异构的方向不对，CUDA，OpenCL也都是异构平台，以后我们会越来越习惯异构平台的。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#109;&#x61;&#105;&#x6c;&#x74;&#111;&#58;&#x5b;&#x68;&#111;&#x6e;&#103;&#122;&#x68;&#x61;&#110;&#103;&#x2e;&#46;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#97;&#105;&#108;&#46;&#99;&#x6f;&#109;&#x5d;&#x28;&#x29;">&#x5b;&#x68;&#111;&#x6e;&#103;&#122;&#x68;&#x61;&#110;&#103;&#x2e;&#46;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#97;&#105;&#108;&#46;&#99;&#x6f;&#109;&#x5d;&#x28;&#x29;</a></p>
<p>异构平台如果编程复杂度降不下来的话很难流行起来。cell已经死了...</p>
<blockquote>
<p> 2010/3/24 qiaojie <a href="&#109;&#97;&#105;&#x6c;&#116;&#111;&#58;&#91;&#113;&#x69;&#97;&#x6f;&#46;&#46;&#46;&#x40;&#x67;&#109;&#x61;&#105;&#x6c;&#46;&#x63;&#x6f;&#109;&#x5d;&#x28;&#41;">&#91;&#113;&#x69;&#97;&#x6f;&#46;&#46;&#46;&#x40;&#x67;&#109;&#x61;&#105;&#x6c;&#46;&#x63;&#x6f;&#109;&#x5d;&#x28;&#41;</a></p>
<blockquote>
<p>不是所有的程序都需要并行化的，能用串行化解决的问题没必要并行，所以即使将来many-core系统成为主流，大部分程序员也没必要去搞并行计算。
  我觉得未来的主流应该是类似cell这样一颗全功能核心带众多协处理核心的异构系统，这样才能达到最优的 性能/核心面积比。</p>
<p>2010/3/24 Guancheng Chen <a href="&#x6d;&#97;&#105;&#108;&#116;&#111;&#58;&#91;&#x63;&#x68;&#x65;&#110;&#103;&#117;&#97;&#110;&#99;&#104;&#46;&#46;&#46;&#x40;&#x67;&#109;&#97;&#105;&#x6c;&#46;&#x63;&#111;&#x6d;&#x5d;&#40;&#41;">&#91;&#x63;&#x68;&#x65;&#110;&#103;&#117;&#97;&#110;&#99;&#104;&#46;&#46;&#46;&#x40;&#x67;&#109;&#97;&#105;&#x6c;&#46;&#x63;&#111;&#x6d;&#x5d;&#40;&#41;</a></p>
<p>Nice 大胆预测Linear speedup应该是每个程序员十年后的目标 呵呵</p>
<blockquote>
<p>On 3月23日, 上午10时43分, qiaojie <a href="&#109;&#97;&#x69;&#x6c;&#x74;&#x6f;&#x3a;&#91;&#x71;&#x69;&#x61;&#111;&#x2e;&#46;&#46;&#64;&#x67;&#x6d;&#97;&#x69;&#108;&#x2e;&#99;&#111;&#x6d;&#93;&#x28;&#41;">&#91;&#x71;&#x69;&#x61;&#111;&#x2e;&#46;&#46;&#64;&#x67;&#x6d;&#97;&#x69;&#108;&#x2e;&#99;&#111;&#x6d;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>目前正在写的是一个软件渲染器，采用了光栅化和光线跟踪混合算法，渲染算法已经完全并行化了，
在4核系统上基本可以达到线性加速比，更多核的系统暂时还没测试。kd-tree的构造暂时还没有并
行化，以后有空了再研究。</p>
<p>2010/3/23 Guancheng Chen <a href="&#109;&#x61;&#105;&#x6c;&#x74;&#x6f;&#x3a;&#x5b;&#x63;&#x68;&#x65;&#x6e;&#103;&#x75;&#x61;&#110;&#99;&#x68;&#x2e;&#x2e;&#x2e;&#64;&#103;&#x6d;&#x61;&#105;&#108;&#x2e;&#99;&#111;&#109;&#93;&#x28;&#41;">&#x5b;&#x63;&#x68;&#x65;&#x6e;&#103;&#x75;&#x61;&#110;&#99;&#x68;&#x2e;&#x2e;&#x2e;&#64;&#103;&#x6d;&#x61;&#105;&#108;&#x2e;&#99;&#111;&#109;&#93;&#x28;&#41;</a></p>
<blockquote>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？</p>
<p>On 3月23日, 上午9时15分, qiaojie <a href="&#109;&#97;&#x69;&#x6c;&#116;&#111;&#x3a;&#91;&#x71;&#x69;&#x61;&#x6f;&#46;&#x2e;&#x2e;&#x40;&#103;&#109;&#x61;&#x69;&#x6c;&#46;&#99;&#111;&#109;&#93;&#x28;&#x29;">&#91;&#x71;&#x69;&#x61;&#x6f;&#46;&#x2e;&#x2e;&#x40;&#103;&#109;&#x61;&#x69;&#x6c;&#46;&#99;&#111;&#109;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1)
=
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank
Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？</p>
</blockquote>
<p> To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> 机械唯物主义 : linjunhalida <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-25</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>小规模的，市场会自动调节。
如果出现大规模的问题，就有可能是信息错误——货币的币值变了。
2010/3/25 qiaojie <a href="&#109;&#x61;&#x69;&#x6c;&#x74;&#111;&#x3a;&#x5b;&#113;&#105;&#x61;&#x2e;&#46;&#x2e;&#64;&#x67;&#109;&#97;&#105;&#x6c;&#46;&#99;&#x6f;&#109;&#x5d;&#x28;&#41;">&#x5b;&#113;&#105;&#x61;&#x2e;&#46;&#x2e;&#64;&#x67;&#109;&#97;&#105;&#x6c;&#46;&#99;&#x6f;&#109;&#x5d;&#x28;&#41;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>产能过剩和短缺导致的价格波动是市场经济的典型特征，想要消除过剩和短缺那叫计划经济，</p>
<p>学点经济学常识再来讨论这些问题吧。
2010/3/25 机械唯物主义 : linjunhalida <a href="&#x6d;&#97;&#x69;&#x6c;&#116;&#111;&#x3a;&#91;&#x6c;&#105;&#x6e;&#x6a;&#117;&#x6e;&#46;&#46;&#46;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#109;&#93;&#40;&#x29;">&#91;&#x6c;&#105;&#x6e;&#x6a;&#117;&#x6e;&#46;&#46;&#46;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#109;&#93;&#40;&#x29;</a>
本来就不该生产那么多的粮食，多余的人力和土地可以用来做别的事情。
问题在于为什么他们估算错误？</p>
<p>2010/3/25 qiaojie <a href="&#109;&#x61;&#105;&#108;&#x74;&#111;&#58;&#x5b;&#x71;&#x69;&#x61;&#x2e;&#x2e;&#x2e;&#64;&#103;&#x6d;&#97;&#105;&#108;&#46;&#x63;&#111;&#x6d;&#x5d;&#40;&#x29;">&#x5b;&#x71;&#x69;&#x61;&#x2e;&#x2e;&#x2e;&#64;&#103;&#x6d;&#97;&#105;&#108;&#46;&#x63;&#111;&#x6d;&#x5d;&#40;&#x29;</a>
什么叫产能过剩？假设全世界每年消费10000亿斤粮食，结果今年收成好，生产了15000亿斤，</p>
<p>那多出来的5000亿斤无法被市场消化掉，就是产能过剩。那5000亿斤没价值，是垃圾？生产那
5000亿斤的农民是闲的蛋疼没事干？靠政府失业金养？</p>
<p>2010/3/25 机械唯物主义 : linjunhalida <a href="&#109;&#x61;&#105;&#x6c;&#x74;&#x6f;&#58;&#91;&#108;&#105;&#x6e;&#106;&#x75;&#110;&#x2e;&#x2e;&#46;&#64;&#103;&#109;&#97;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#x29;">&#91;&#108;&#105;&#x6e;&#106;&#x75;&#110;&#x2e;&#x2e;&#46;&#64;&#103;&#109;&#97;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#x29;</a>
产能过剩的说法本来就不对。
产出的东西没有价值，这样的活动就不能说是生产。
比如我这个程序员，花了1周写了一个垃圾程序，然后被开除了。
然后1个月闲着，这是我产能过剩吗？
而闲着的原因是政府给我失业金，我就不需要工作闲起来了。。。</p>
<p>2010/3/25 qiaojie <a href="&#109;&#x61;&#105;&#x6c;&#x74;&#x6f;&#x3a;&#x5b;&#x71;&#x69;&#x61;&#x2e;&#x2e;&#46;&#64;&#x67;&#x6d;&#97;&#105;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#40;&#x29;">&#x5b;&#x71;&#x69;&#x61;&#x2e;&#x2e;&#46;&#64;&#x67;&#x6d;&#97;&#105;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#40;&#x29;</a>
如果产能=消费的话就没有产能过剩这一说了。</p>
<p>2010/3/25 机械唯物主义 : linjunhalida <a href="&#x6d;&#x61;&#x69;&#108;&#x74;&#x6f;&#x3a;&#x5b;&#108;&#105;&#x6e;&#106;&#117;&#110;&#x2e;&#46;&#x2e;&#x40;&#x67;&#109;&#97;&#105;&#108;&#46;&#x63;&#x6f;&#x6d;&#93;&#x28;&#41;">&#x5b;&#108;&#105;&#x6e;&#106;&#117;&#110;&#x2e;&#46;&#x2e;&#x40;&#x67;&#109;&#97;&#105;&#108;&#46;&#x63;&#x6f;&#x6d;&#93;&#x28;&#41;</a></p>
<p>一个谬误：刺激需求
产能=消费，产能才是主动力。技术成长是随着产能成长而起来的。
而产能多的结果就是满足了需求，造成一种需求带来技术进步的假像。
而技术和产能之间的关系又错综复杂。。
2010/3/25 qiaojie <a href="&#109;&#x61;&#105;&#108;&#116;&#x6f;&#x3a;&#x5b;&#113;&#x69;&#97;&#46;&#46;&#46;&#x40;&#x67;&#109;&#97;&#x69;&#108;&#x2e;&#x63;&#111;&#109;&#93;&#x28;&#41;">&#x5b;&#113;&#x69;&#97;&#46;&#46;&#46;&#x40;&#x67;&#109;&#97;&#x69;&#108;&#x2e;&#x63;&#111;&#109;&#93;&#x28;&#41;</a></p>
<p>3D游戏就是一类杀手应用，由此支撑起了一个庞大的GPU市场，芯片行业的研发成本是很高的，没有一个庞大的市场是做不起来的。目前的消费者对于多核系统显然还没有强烈的需求，因为应用跟不上，i7发布快2年了还没进入主流市场，这种情况延续下去的话摩尔定律将因此失效。不过我相信杀手级应用总会出现的，这可能要硬件性能突破一个临界点，比方说目前GPU的性能再提升一个数量级的话，光线跟踪算法就可以提供流畅的接近CG的画质，倒是此类应用便会流行开来。</p>
<p>2010/3/25 Guancheng Chen <a href="&#109;&#x61;&#105;&#x6c;&#116;&#x6f;&#58;&#91;&#x63;&#104;&#101;&#x6e;&#103;&#x75;&#46;&#x2e;&#46;&#64;&#103;&#x6d;&#97;&#x69;&#108;&#46;&#x63;&#x6f;&#109;&#x5d;&#x28;&#41;">&#91;&#x63;&#104;&#101;&#x6e;&#103;&#x75;&#46;&#x2e;&#46;&#64;&#103;&#x6d;&#97;&#x69;&#108;&#46;&#x63;&#x6f;&#109;&#x5d;&#x28;&#41;</a></p>
<p>杀手应用一般来说是指什么样的应用呢？比如用户群特别大的网游？还是那些专有的科学计算用的软件？
On 3月24日, 下午12时36分, qiaojie <a href="&#109;&#x61;&#105;&#108;&#116;&#111;&#58;&#x5b;&#113;&#x69;&#x61;&#111;&#x2e;&#x2e;&#46;&#x40;&#103;&#109;&#x61;&#x69;&#x6c;&#x2e;&#99;&#111;&#x6d;&#93;&#x28;&#41;">&#x5b;&#113;&#x69;&#x61;&#111;&#x2e;&#x2e;&#46;&#x40;&#103;&#109;&#x61;&#x69;&#x6c;&#x2e;&#99;&#111;&#x6d;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>并行计算本来就是曲高和寡的东西，就跟3D渲染一样，能开发引擎的毕竟只是小部分人，大多数人在引擎的基础上做应用。关键在于是否有杀手应用，只要有大量的需求 ，自然会有人去做开发。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#x6d;&#97;&#x69;&#x6c;&#116;&#111;&#x3a;&#x5b;&#x68;&#111;&#110;&#x67;&#122;&#x68;&#x61;&#110;&#x67;&#46;&#46;&#x2e;&#46;&#x40;&#103;&#x6d;&#x61;&#105;&#108;&#46;&#99;&#111;&#109;&#x5d;&#40;&#x29;">&#x5b;&#x68;&#111;&#110;&#x67;&#122;&#x68;&#x61;&#110;&#x67;&#46;&#46;&#x2e;&#46;&#x40;&#103;&#x6d;&#x61;&#105;&#108;&#46;&#99;&#111;&#109;&#x5d;&#40;&#x29;</a></p>
<blockquote>
<p>异构平台从网络处理器算起已经快10年了，现在情况仍然不明朗。就我看到的，异构平台要想高效，就必须向程序员暴露非常多的硬件细节，这必然导致编程的复杂性。 曲高和寡，要想渗透到应用程序这一块，我觉得很难。</p>
<p>2010/3/24 qiaojie <a href="&#109;&#97;&#x69;&#x6c;&#116;&#x6f;&#x3a;&#91;&#113;&#105;&#x61;&#x6f;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#x61;&#x69;&#x6c;&#46;&#99;&#111;&#x6d;&#x5d;&#40;&#x29;">&#91;&#113;&#105;&#x61;&#x6f;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#x61;&#x69;&#x6c;&#46;&#99;&#111;&#x6d;&#x5d;&#40;&#x29;</a></p>
<blockquote>
<p>说的没错，cell已经成了先烈了。不过这不代表异构的方向不对，CUDA，OpenCL也都是异构平台，以后我们会越来越习惯异构平台的。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#x6d;&#97;&#x69;&#108;&#116;&#111;&#x3a;&#x5b;&#104;&#x6f;&#110;&#103;&#122;&#x68;&#97;&#x6e;&#x67;&#46;&#46;&#46;&#x2e;&#64;&#103;&#x6d;&#97;&#x69;&#108;&#46;&#x63;&#111;&#109;&#93;&#40;&#x29;">&#x5b;&#104;&#x6f;&#110;&#103;&#122;&#x68;&#97;&#x6e;&#x67;&#46;&#46;&#46;&#x2e;&#64;&#103;&#x6d;&#97;&#x69;&#108;&#46;&#x63;&#111;&#109;&#93;&#40;&#x29;</a></p>
<p>异构平台如果编程复杂度降不下来的话很难流行起来。cell已经死了...</p>
<blockquote>
<p> 2010/3/24 qiaojie <a href="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#x6f;&#x3a;&#91;&#x71;&#105;&#x61;&#111;&#x2e;&#x2e;&#46;&#64;&#103;&#109;&#x61;&#105;&#108;&#x2e;&#x63;&#111;&#109;&#x5d;&#40;&#41;">&#91;&#x71;&#105;&#x61;&#111;&#x2e;&#x2e;&#46;&#64;&#103;&#109;&#x61;&#105;&#108;&#x2e;&#x63;&#111;&#109;&#x5d;&#40;&#41;</a></p>
<blockquote>
<p>不是所有的程序都需要并行化的，能用串行化解决的问题没必要并行，所以即使将来many-core系统成为主流，大部分程序员也没必要去搞并行计算。
  我觉得未来的主流应该是类似cell这样一颗全功能核心带众多协处理核心的异构系统，这样才能达到最优的 性能/核心面积比。</p>
<p>2010/3/24 Guancheng Chen <a href="&#x6d;&#x61;&#x69;&#108;&#x74;&#x6f;&#58;&#x5b;&#99;&#x68;&#101;&#110;&#103;&#117;&#x61;&#110;&#x63;&#104;&#x2e;&#x2e;&#46;&#64;&#x67;&#109;&#97;&#x69;&#108;&#46;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#41;">&#x5b;&#99;&#x68;&#101;&#110;&#103;&#117;&#x61;&#110;&#x63;&#104;&#x2e;&#x2e;&#46;&#64;&#x67;&#109;&#97;&#x69;&#108;&#46;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#41;</a></p>
<p>Nice 大胆预测Linear speedup应该是每个程序员十年后的目标 呵呵</p>
<blockquote>
<p>On 3月23日, 上午10时43分, qiaojie <a href="&#x6d;&#97;&#105;&#x6c;&#x74;&#111;&#58;&#x5b;&#113;&#105;&#97;&#x6f;&#x2e;&#46;&#46;&#x40;&#x67;&#x6d;&#97;&#105;&#108;&#x2e;&#99;&#x6f;&#109;&#93;&#40;&#41;">&#x5b;&#113;&#105;&#97;&#x6f;&#x2e;&#46;&#46;&#x40;&#x67;&#x6d;&#97;&#105;&#108;&#x2e;&#99;&#x6f;&#109;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>目前正在写的是一个软件渲染器，采用了光栅化和光线跟踪混合算法，渲染算法已经完全并行化了，
在4核系统上基本可以达到线性加速比，更多核的系统暂时还没测试。kd-tree的构造暂时还没有并
行化，以后有空了再研究。</p>
<p>2010/3/23 Guancheng Chen <a href="&#x6d;&#x61;&#x69;&#x6c;&#116;&#x6f;&#58;&#x5b;&#x63;&#x68;&#x65;&#x6e;&#x67;&#117;&#x61;&#110;&#99;&#104;&#x2e;&#x2e;&#46;&#x40;&#103;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#93;&#40;&#41;">&#x5b;&#x63;&#x68;&#x65;&#x6e;&#x67;&#117;&#x61;&#110;&#99;&#104;&#x2e;&#x2e;&#46;&#x40;&#103;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#93;&#40;&#41;</a></p>
<blockquote>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？</p>
<p>On 3月23日, 上午9时15分, qiaojie <a href="&#109;&#x61;&#105;&#x6c;&#x74;&#111;&#58;&#x5b;&#113;&#105;&#97;&#111;&#x2e;&#x2e;&#46;&#64;&#103;&#109;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#93;&#40;&#41;">&#x5b;&#113;&#105;&#97;&#111;&#x2e;&#x2e;&#46;&#64;&#103;&#109;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1)
=
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank
Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？</p>
</blockquote>
<p> To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a></p>
<p><img src="" alt=""> qiaojie <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-25</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>恩，很快会被升华成为政治问题
2010/3/25 郝培强 tinyfool <a href="&#x6d;&#97;&#x69;&#x6c;&#x74;&#x6f;&#58;&#91;&#x74;&#105;&#x6e;&#121;&#46;&#46;&#46;&#x40;&#103;&#109;&#97;&#x69;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#41;">&#91;&#x74;&#105;&#x6e;&#121;&#46;&#46;&#46;&#x40;&#103;&#109;&#97;&#x69;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#41;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>哈哈，终于从技术聊到经济了</p>
<p>在 2010-3-25，下午2:11， qiaojie 写道：</p>
<p>什么叫产能过剩？假设全世界每年消费10000亿斤粮食，结果今年收成好，生产了15000亿斤，</p>
<p>那多出来的5000亿斤无法被市场消化掉，就是产能过剩。那5000亿斤没价值，是垃圾？生产那
5000亿斤的农民是闲的蛋疼没事干？靠政府失业金养？</p>
<p>2010/3/25 机械唯物主义 : linjunhalida <a href="&#109;&#97;&#105;&#x6c;&#x74;&#x6f;&#58;&#91;&#108;&#x69;&#110;&#106;&#117;&#110;&#x2e;&#x2e;&#46;&#64;&#103;&#109;&#x61;&#105;&#108;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#x28;&#x29;">&#91;&#108;&#x69;&#110;&#106;&#117;&#110;&#x2e;&#x2e;&#46;&#64;&#103;&#109;&#x61;&#105;&#108;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#x28;&#x29;</a>
产能过剩的说法本来就不对。
产出的东西没有价值，这样的活动就不能说是生产。
比如我这个程序员，花了1周写了一个垃圾程序，然后被开除了。
然后1个月闲着，这是我产能过剩吗？
而闲着的原因是政府给我失业金，我就不需要工作闲起来了。。。</p>
<p>2010/3/25 qiaojie <a href="&#109;&#x61;&#x69;&#108;&#x74;&#x6f;&#x3a;&#91;&#x71;&#x69;&#97;&#x2e;&#x2e;&#46;&#64;&#103;&#109;&#x61;&#x69;&#108;&#46;&#x63;&#111;&#x6d;&#x5d;&#40;&#41;">&#91;&#x71;&#x69;&#97;&#x2e;&#x2e;&#46;&#64;&#103;&#109;&#x61;&#x69;&#108;&#46;&#x63;&#111;&#x6d;&#x5d;&#40;&#41;</a>
如果产能=消费的话就没有产能过剩这一说了。</p>
<p>2010/3/25 机械唯物主义 : linjunhalida <a href="&#x6d;&#x61;&#105;&#x6c;&#116;&#111;&#58;&#91;&#x6c;&#x69;&#x6e;&#106;&#x75;&#110;&#x2e;&#46;&#46;&#x40;&#103;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#x28;&#x29;">&#91;&#x6c;&#x69;&#x6e;&#106;&#x75;&#110;&#x2e;&#46;&#46;&#x40;&#103;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#x28;&#x29;</a></p>
<p>一个谬误：刺激需求
产能=消费，产能才是主动力。技术成长是随着产能成长而起来的。
而产能多的结果就是满足了需求，造成一种需求带来技术进步的假像。
而技术和产能之间的关系又错综复杂。。
2010/3/25 qiaojie <a href="&#109;&#x61;&#x69;&#x6c;&#x74;&#111;&#58;&#x5b;&#x71;&#105;&#x61;&#46;&#x2e;&#x2e;&#64;&#103;&#x6d;&#97;&#105;&#108;&#46;&#x63;&#111;&#109;&#93;&#x28;&#41;">&#x5b;&#x71;&#105;&#x61;&#46;&#x2e;&#x2e;&#64;&#103;&#x6d;&#97;&#105;&#108;&#46;&#x63;&#111;&#109;&#93;&#x28;&#41;</a></p>
<p>3D游戏就是一类杀手应用，由此支撑起了一个庞大的GPU市场，芯片行业的研发成本是很高的，没有一个庞大的市场是做不起来的。目前的消费者对于多核系统显然还没有强烈的需求，因为应用跟不上，i7发布快2年了还没进入主流市场，这种情况延续下去的话摩尔定律将因此失效。不过我相信杀手级应用总会出现的，这可能要硬件性能突破一个临界点，比方说目前GPU的性能再提升一个数量级的话，光线跟踪算法就可以提供流畅的接近CG的画质，倒是此类应用便会流行开来。</p>
<p>2010/3/25 Guancheng Chen <a href="&#x6d;&#97;&#x69;&#x6c;&#x74;&#111;&#x3a;&#91;&#x63;&#104;&#101;&#110;&#103;&#117;&#46;&#46;&#x2e;&#x40;&#x67;&#x6d;&#97;&#x69;&#x6c;&#46;&#x63;&#111;&#x6d;&#93;&#x28;&#41;">&#91;&#x63;&#104;&#101;&#110;&#103;&#117;&#46;&#46;&#x2e;&#x40;&#x67;&#x6d;&#97;&#x69;&#x6c;&#46;&#x63;&#111;&#x6d;&#93;&#x28;&#41;</a></p>
<p>杀手应用一般来说是指什么样的应用呢？比如用户群特别大的网游？还是那些专有的科学计算用的软件？
On 3月24日, 下午12时36分, qiaojie <a href="&#109;&#x61;&#105;&#108;&#x74;&#x6f;&#58;&#91;&#x71;&#105;&#x61;&#x6f;&#x2e;&#46;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#105;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#41;">&#91;&#x71;&#105;&#x61;&#x6f;&#x2e;&#46;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#105;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>并行计算本来就是曲高和寡的东西，就跟3D渲染一样，能开发引擎的毕竟只是小部分人，大多数人在引擎的基础上做应用。关键在于是否有杀手应用，只要有大量的需求 ，自然会有人去做开发。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#109;&#x61;&#x69;&#x6c;&#x74;&#x6f;&#x3a;&#91;&#x68;&#111;&#110;&#103;&#x7a;&#104;&#x61;&#110;&#x67;&#x2e;&#46;&#x2e;&#x2e;&#x40;&#x67;&#109;&#97;&#x69;&#x6c;&#46;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#x29;">&#91;&#x68;&#111;&#110;&#103;&#x7a;&#104;&#x61;&#110;&#x67;&#x2e;&#46;&#x2e;&#x2e;&#x40;&#x67;&#109;&#97;&#x69;&#x6c;&#46;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#x29;</a></p>
<blockquote>
<p>异构平台从网络处理器算起已经快10年了，现在情况仍然不明朗。就我看到的，异构平台要想高效，就必须向程序员暴露非常多的硬件细节，这必然导致编程的复杂性。 曲高和寡，要想渗透到应用程序这一块，我觉得很难。</p>
<p>2010/3/24 qiaojie <a href="&#109;&#97;&#105;&#108;&#x74;&#111;&#58;&#x5b;&#113;&#105;&#x61;&#111;&#x2e;&#x2e;&#46;&#x40;&#x67;&#109;&#x61;&#105;&#108;&#x2e;&#99;&#111;&#109;&#93;&#x28;&#41;">&#x5b;&#113;&#105;&#x61;&#111;&#x2e;&#x2e;&#46;&#x40;&#x67;&#109;&#x61;&#105;&#108;&#x2e;&#99;&#111;&#109;&#93;&#x28;&#41;</a></p>
<blockquote>
<p>说的没错，cell已经成了先烈了。不过这不代表异构的方向不对，CUDA，OpenCL也都是异构平台，以后我们会越来越习惯异构平台的。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#109;&#x61;&#x69;&#108;&#116;&#111;&#58;&#x5b;&#x68;&#111;&#110;&#x67;&#122;&#104;&#97;&#x6e;&#103;&#46;&#x2e;&#46;&#46;&#x40;&#x67;&#x6d;&#97;&#x69;&#108;&#46;&#x63;&#111;&#x6d;&#x5d;&#40;&#x29;">&#x5b;&#x68;&#111;&#110;&#x67;&#122;&#104;&#97;&#x6e;&#103;&#46;&#x2e;&#46;&#46;&#x40;&#x67;&#x6d;&#97;&#x69;&#108;&#46;&#x63;&#111;&#x6d;&#x5d;&#40;&#x29;</a></p>
<p>异构平台如果编程复杂度降不下来的话很难流行起来。cell已经死了...</p>
<blockquote>
<p> 2010/3/24 qiaojie <a href="&#109;&#97;&#105;&#x6c;&#x74;&#x6f;&#58;&#91;&#113;&#x69;&#x61;&#111;&#46;&#x2e;&#46;&#64;&#103;&#109;&#x61;&#x69;&#108;&#x2e;&#99;&#111;&#109;&#x5d;&#x28;&#x29;">&#91;&#113;&#x69;&#x61;&#111;&#46;&#x2e;&#46;&#64;&#103;&#109;&#x61;&#x69;&#108;&#x2e;&#99;&#111;&#109;&#x5d;&#x28;&#x29;</a></p>
<blockquote>
<p>不是所有的程序都需要并行化的，能用串行化解决的问题没必要并行，所以即使将来many-core系统成为主流，大部分程序员也没必要去搞并行计算。
  我觉得未来的主流应该是类似cell这样一颗全功能核心带众多协处理核心的异构系统，这样才能达到最优的 性能/核心面积比。</p>
<p>2010/3/24 Guancheng Chen <a href="&#x6d;&#x61;&#105;&#108;&#x74;&#x6f;&#x3a;&#x5b;&#x63;&#x68;&#101;&#110;&#103;&#x75;&#x61;&#x6e;&#x63;&#x68;&#x2e;&#46;&#x2e;&#64;&#x67;&#x6d;&#97;&#105;&#x6c;&#x2e;&#99;&#x6f;&#109;&#93;&#40;&#41;">&#x5b;&#x63;&#x68;&#101;&#110;&#103;&#x75;&#x61;&#x6e;&#x63;&#x68;&#x2e;&#46;&#x2e;&#64;&#x67;&#x6d;&#97;&#105;&#x6c;&#x2e;&#99;&#x6f;&#109;&#93;&#40;&#41;</a></p>
<p>Nice 大胆预测Linear speedup应该是每个程序员十年后的目标 呵呵</p>
<blockquote>
<p>On 3月23日, 上午10时43分, qiaojie <a href="&#x6d;&#97;&#105;&#x6c;&#116;&#x6f;&#58;&#91;&#x71;&#105;&#97;&#111;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#109;&#x61;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#x29;">&#91;&#x71;&#105;&#97;&#111;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#109;&#x61;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>目前正在写的是一个软件渲染器，采用了光栅化和光线跟踪混合算法，渲染算法已经完全并行化了，
在4核系统上基本可以达到线性加速比，更多核的系统暂时还没测试。kd-tree的构造暂时还没有并
行化，以后有空了再研究。</p>
<p>2010/3/23 Guancheng Chen <a href="&#x6d;&#x61;&#x69;&#x6c;&#116;&#x6f;&#58;&#91;&#99;&#x68;&#x65;&#110;&#x67;&#117;&#97;&#110;&#x63;&#104;&#46;&#46;&#x2e;&#x40;&#103;&#x6d;&#97;&#x69;&#108;&#46;&#x63;&#111;&#109;&#x5d;&#40;&#x29;">&#91;&#99;&#x68;&#x65;&#110;&#x67;&#117;&#97;&#110;&#x63;&#104;&#46;&#46;&#x2e;&#x40;&#103;&#x6d;&#97;&#x69;&#108;&#46;&#x63;&#111;&#109;&#x5d;&#40;&#x29;</a></p>
<blockquote>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？</p>
<p>On 3月23日, 上午9时15分, qiaojie <a href="&#109;&#97;&#105;&#x6c;&#116;&#111;&#58;&#x5b;&#x71;&#x69;&#x61;&#x6f;&#x2e;&#46;&#46;&#x40;&#103;&#x6d;&#97;&#105;&#108;&#46;&#x63;&#111;&#x6d;&#93;&#x28;&#x29;">&#x5b;&#x71;&#x69;&#x61;&#x6f;&#x2e;&#46;&#46;&#x40;&#103;&#x6d;&#97;&#105;&#108;&#46;&#x63;&#111;&#x6d;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1)
=
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank
Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？</p>
</blockquote>
<p> To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> tinyfool <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-25</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>哈哈，二位都平和一点，咱们继续回到技术讨论的主线吧</p>
<p>在 2010-3-25，下午2:40， qiaojie 写道：</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>恩，很快会被升华成为政治问题
2010/3/25 郝培强 tinyfool <a href="&#109;&#x61;&#x69;&#108;&#x74;&#x6f;&#58;&#91;&#x74;&#105;&#x6e;&#x79;&#x2e;&#46;&#46;&#x40;&#x67;&#x6d;&#97;&#105;&#108;&#x2e;&#99;&#111;&#x6d;&#x5d;&#x28;&#41;">&#91;&#x74;&#105;&#x6e;&#x79;&#x2e;&#46;&#46;&#x40;&#x67;&#x6d;&#97;&#105;&#108;&#x2e;&#99;&#111;&#x6d;&#x5d;&#x28;&#41;</a>
哈哈，终于从技术聊到经济了</p>
<p>在 2010-3-25，下午2:11， qiaojie 写道：</p>
<p>什么叫产能过剩？假设全世界每年消费10000亿斤粮食，结果今年收成好，生产了15000亿斤，</p>
<p>那多出来的5000亿斤无法被市场消化掉，就是产能过剩。那5000亿斤没价值，是垃圾？生产那
5000亿斤的农民是闲的蛋疼没事干？靠政府失业金养？</p>
<p>2010/3/25 机械唯物主义 : linjunhalida <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#x3a;&#x5b;&#108;&#x69;&#x6e;&#106;&#x75;&#x6e;&#x2e;&#46;&#x2e;&#x40;&#103;&#109;&#x61;&#105;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#93;&#x28;&#x29;">&#x5b;&#108;&#x69;&#x6e;&#106;&#x75;&#x6e;&#x2e;&#46;&#x2e;&#x40;&#103;&#109;&#x61;&#105;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#93;&#x28;&#x29;</a>
产能过剩的说法本来就不对。
产出的东西没有价值，这样的活动就不能说是生产。
比如我这个程序员，花了1周写了一个垃圾程序，然后被开除了。
然后1个月闲着，这是我产能过剩吗？
而闲着的原因是政府给我失业金，我就不需要工作闲起来了。。。</p>
<p>2010/3/25 qiaojie <a href="&#x6d;&#x61;&#x69;&#x6c;&#116;&#111;&#58;&#x5b;&#x71;&#105;&#x61;&#x2e;&#x2e;&#46;&#x40;&#x67;&#x6d;&#97;&#105;&#108;&#x2e;&#99;&#x6f;&#109;&#x5d;&#x28;&#x29;">&#x5b;&#x71;&#105;&#x61;&#x2e;&#x2e;&#46;&#x40;&#x67;&#x6d;&#97;&#105;&#108;&#x2e;&#99;&#x6f;&#109;&#x5d;&#x28;&#x29;</a>
如果产能=消费的话就没有产能过剩这一说了。</p>
<p>2010/3/25 机械唯物主义 : linjunhalida <a href="&#x6d;&#x61;&#x69;&#x6c;&#116;&#111;&#x3a;&#x5b;&#108;&#105;&#x6e;&#106;&#117;&#110;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#x61;&#105;&#x6c;&#46;&#x63;&#x6f;&#109;&#93;&#x28;&#41;">&#x5b;&#108;&#105;&#x6e;&#106;&#117;&#110;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#x61;&#105;&#x6c;&#46;&#x63;&#x6f;&#109;&#93;&#x28;&#41;</a></p>
<p>一个谬误：刺激需求
产能=消费，产能才是主动力。技术成长是随着产能成长而起来的。
而产能多的结果就是满足了需求，造成一种需求带来技术进步的假像。
而技术和产能之间的关系又错综复杂。。
2010/3/25 qiaojie <a href="&#109;&#x61;&#x69;&#108;&#x74;&#111;&#58;&#91;&#113;&#x69;&#x61;&#46;&#x2e;&#46;&#64;&#103;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#x28;&#x29;">&#91;&#113;&#x69;&#x61;&#46;&#x2e;&#46;&#64;&#103;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#x28;&#x29;</a></p>
<p>3D游戏就是一类杀手应用，由此支撑起了一个庞大的GPU市场，芯片行业的研发成本是很高的，没有一个庞大的市场是做不起来的。目前的消费者对于多核系统显然还没有强烈的需求，因为应用跟不上，i7发布快2年了还没进入主流市场，这种情况延续下去的话摩尔定律将因此失效。不过我相信杀手级应用总会出现的，这可能要硬件性能突破一个临界点，比方说目前GPU的性能再提升一个数量级的话，光线跟踪算法就可以提供流畅的接近CG的画质，倒是此类应用便会流行开来。</p>
<p>2010/3/25 Guancheng Chen <a href="&#x6d;&#x61;&#x69;&#x6c;&#116;&#111;&#x3a;&#91;&#x63;&#x68;&#x65;&#x6e;&#x67;&#x75;&#46;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#97;&#105;&#x6c;&#46;&#99;&#111;&#x6d;&#93;&#x28;&#41;">&#91;&#x63;&#x68;&#x65;&#x6e;&#x67;&#x75;&#46;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#97;&#105;&#x6c;&#46;&#99;&#111;&#x6d;&#93;&#x28;&#41;</a></p>
<p>杀手应用一般来说是指什么样的应用呢？比如用户群特别大的网游？还是那些专有的科学计算用的软件？
On 3月24日, 下午12时36分, qiaojie <a href="&#x6d;&#97;&#105;&#x6c;&#x74;&#x6f;&#x3a;&#91;&#x71;&#x69;&#97;&#x6f;&#x2e;&#46;&#46;&#64;&#x67;&#109;&#97;&#x69;&#108;&#46;&#x63;&#x6f;&#109;&#x5d;&#x28;&#41;">&#91;&#x71;&#x69;&#97;&#x6f;&#x2e;&#46;&#46;&#64;&#x67;&#109;&#97;&#x69;&#108;&#46;&#x63;&#x6f;&#109;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>并行计算本来就是曲高和寡的东西，就跟3D渲染一样，能开发引擎的毕竟只是小部分人，大多数人在引擎的基础上做应用。关键在于是否有杀手应用，只要有大量的需求 ，自然会有人去做开发。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#x6d;&#97;&#x69;&#108;&#116;&#111;&#x3a;&#91;&#x68;&#111;&#x6e;&#103;&#122;&#x68;&#x61;&#x6e;&#x67;&#x2e;&#46;&#x2e;&#46;&#64;&#x67;&#x6d;&#97;&#105;&#108;&#46;&#99;&#x6f;&#109;&#x5d;&#40;&#41;">&#91;&#x68;&#111;&#x6e;&#103;&#122;&#x68;&#x61;&#x6e;&#x67;&#x2e;&#46;&#x2e;&#46;&#64;&#x67;&#x6d;&#97;&#105;&#108;&#46;&#99;&#x6f;&#109;&#x5d;&#40;&#41;</a></p>
<blockquote>
<p>异构平台从网络处理器算起已经快10年了，现在情况仍然不明朗。就我看到的，异构平台要想高效，就必须向程序员暴露非常多的硬件细节，这必然导致编程的复杂性。 曲高和寡，要想渗透到应用程序这一块，我觉得很难。</p>
<p>2010/3/24 qiaojie <a href="&#109;&#97;&#105;&#x6c;&#x74;&#111;&#58;&#x5b;&#x71;&#x69;&#97;&#x6f;&#46;&#x2e;&#46;&#64;&#103;&#109;&#x61;&#x69;&#108;&#46;&#x63;&#x6f;&#109;&#x5d;&#x28;&#x29;">&#x5b;&#x71;&#x69;&#97;&#x6f;&#46;&#x2e;&#46;&#64;&#103;&#109;&#x61;&#x69;&#108;&#46;&#x63;&#x6f;&#109;&#x5d;&#x28;&#x29;</a></p>
<blockquote>
<p>说的没错，cell已经成了先烈了。不过这不代表异构的方向不对，CUDA，OpenCL也都是异构平台，以后我们会越来越习惯异构平台的。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#109;&#x61;&#x69;&#108;&#x74;&#x6f;&#58;&#x5b;&#x68;&#111;&#x6e;&#103;&#122;&#x68;&#97;&#x6e;&#x67;&#46;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#97;&#x69;&#108;&#46;&#x63;&#x6f;&#109;&#93;&#x28;&#x29;">&#x5b;&#x68;&#111;&#x6e;&#103;&#122;&#x68;&#97;&#x6e;&#x67;&#46;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#97;&#x69;&#108;&#46;&#x63;&#x6f;&#109;&#93;&#x28;&#x29;</a></p>
<p>异构平台如果编程复杂度降不下来的话很难流行起来。cell已经死了...</p>
<blockquote>
<p> 2010/3/24 qiaojie <a href="&#109;&#x61;&#x69;&#108;&#116;&#111;&#x3a;&#91;&#x71;&#x69;&#97;&#x6f;&#x2e;&#x2e;&#46;&#64;&#x67;&#109;&#97;&#x69;&#x6c;&#x2e;&#99;&#111;&#109;&#93;&#40;&#x29;">&#91;&#x71;&#x69;&#97;&#x6f;&#x2e;&#x2e;&#46;&#64;&#x67;&#109;&#97;&#x69;&#x6c;&#x2e;&#99;&#111;&#109;&#93;&#40;&#x29;</a></p>
<blockquote>
<p>不是所有的程序都需要并行化的，能用串行化解决的问题没必要并行，所以即使将来many-core系统成为主流，大部分程序员也没必要去搞并行计算。
  我觉得未来的主流应该是类似cell这样一颗全功能核心带众多协处理核心的异构系统，这样才能达到最优的 性能/核心面积比。</p>
<p>2010/3/24 Guancheng Chen <a href="&#109;&#x61;&#x69;&#108;&#x74;&#x6f;&#58;&#91;&#x63;&#x68;&#x65;&#110;&#103;&#x75;&#97;&#110;&#99;&#x68;&#x2e;&#46;&#x2e;&#x40;&#x67;&#109;&#97;&#105;&#108;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#x29;">&#91;&#x63;&#x68;&#x65;&#110;&#103;&#x75;&#97;&#110;&#99;&#x68;&#x2e;&#46;&#x2e;&#x40;&#x67;&#109;&#97;&#105;&#108;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#x29;</a></p>
<p>Nice 大胆预测Linear speedup应该是每个程序员十年后的目标 呵呵</p>
<blockquote>
<p>On 3月23日, 上午10时43分, qiaojie <a href="&#109;&#x61;&#x69;&#108;&#116;&#111;&#58;&#x5b;&#113;&#105;&#97;&#x6f;&#46;&#x2e;&#46;&#64;&#x67;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#99;&#111;&#109;&#93;&#40;&#x29;">&#x5b;&#113;&#105;&#97;&#x6f;&#46;&#x2e;&#46;&#64;&#x67;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#99;&#111;&#109;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>目前正在写的是一个软件渲染器，采用了光栅化和光线跟踪混合算法，渲染算法已经完全并行化了，
在4核系统上基本可以达到线性加速比，更多核的系统暂时还没测试。kd-tree的构造暂时还没有并
行化，以后有空了再研究。</p>
<p>2010/3/23 Guancheng Chen <a href="&#x6d;&#97;&#x69;&#x6c;&#116;&#111;&#x3a;&#x5b;&#x63;&#x68;&#x65;&#110;&#103;&#117;&#97;&#110;&#99;&#x68;&#46;&#x2e;&#46;&#64;&#103;&#x6d;&#97;&#105;&#108;&#x2e;&#99;&#111;&#x6d;&#93;&#x28;&#41;">&#x5b;&#x63;&#x68;&#x65;&#110;&#103;&#117;&#97;&#110;&#99;&#x68;&#46;&#x2e;&#46;&#64;&#103;&#x6d;&#97;&#105;&#108;&#x2e;&#99;&#111;&#x6d;&#93;&#x28;&#41;</a></p>
<blockquote>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？</p>
<p>On 3月23日, 上午9时15分, qiaojie <a href="&#109;&#97;&#105;&#108;&#x74;&#111;&#58;&#x5b;&#113;&#x69;&#x61;&#111;&#x2e;&#46;&#46;&#x40;&#x67;&#109;&#x61;&#x69;&#108;&#46;&#99;&#111;&#x6d;&#x5d;&#x28;&#x29;">&#x5b;&#113;&#x69;&#x61;&#111;&#x2e;&#46;&#46;&#x40;&#x67;&#109;&#x61;&#x69;&#108;&#46;&#99;&#111;&#x6d;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1)
=
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank
Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？</p>
</blockquote>
<p> To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a></p>
<p><img src="" alt=""> 机械唯物主义 : linjunhalida <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-25</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>恩，离题远了。不再讨论经济。</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>2010/3/25 郝培强 tinyfool <a href="&#x6d;&#97;&#105;&#x6c;&#116;&#x6f;&#58;&#x5b;&#x74;&#105;&#x6e;&#121;&#x2e;&#46;&#46;&#64;&#x67;&#109;&#97;&#105;&#108;&#46;&#x63;&#111;&#109;&#93;&#40;&#41;">&#x5b;&#x74;&#105;&#x6e;&#121;&#x2e;&#46;&#46;&#64;&#x67;&#109;&#97;&#105;&#108;&#46;&#x63;&#111;&#109;&#93;&#40;&#41;</a>
哈哈，二位都平和一点，咱们继续回到技术讨论的主线吧</p>
<p>在 2010-3-25，下午2:40， qiaojie 写道：</p>
<p>恩，很快会被升华成为政治问题
2010/3/25 郝培强 tinyfool <a href="&#x6d;&#97;&#105;&#108;&#x74;&#x6f;&#58;&#x5b;&#116;&#x69;&#x6e;&#121;&#46;&#46;&#x2e;&#x40;&#103;&#109;&#97;&#105;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#93;&#40;&#x29;">&#x5b;&#116;&#x69;&#x6e;&#121;&#46;&#46;&#x2e;&#x40;&#103;&#109;&#97;&#105;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#93;&#40;&#x29;</a>
哈哈，终于从技术聊到经济了</p>
<p>在 2010-3-25，下午2:11， qiaojie 写道：</p>
<p>什么叫产能过剩？假设全世界每年消费10000亿斤粮食，结果今年收成好，生产了15000亿斤，</p>
<p>那多出来的5000亿斤无法被市场消化掉，就是产能过剩。那5000亿斤没价值，是垃圾？生产那
5000亿斤的农民是闲的蛋疼没事干？靠政府失业金养？</p>
<p>2010/3/25 机械唯物主义 : linjunhalida <a href="&#x6d;&#97;&#105;&#108;&#116;&#111;&#x3a;&#x5b;&#108;&#105;&#x6e;&#106;&#117;&#110;&#x2e;&#x2e;&#46;&#64;&#x67;&#x6d;&#x61;&#105;&#108;&#46;&#x63;&#x6f;&#x6d;&#93;&#40;&#x29;">&#x5b;&#108;&#105;&#x6e;&#106;&#117;&#110;&#x2e;&#x2e;&#46;&#64;&#x67;&#x6d;&#x61;&#105;&#108;&#46;&#x63;&#x6f;&#x6d;&#93;&#40;&#x29;</a>
产能过剩的说法本来就不对。
产出的东西没有价值，这样的活动就不能说是生产。
比如我这个程序员，花了1周写了一个垃圾程序，然后被开除了。
然后1个月闲着，这是我产能过剩吗？
而闲着的原因是政府给我失业金，我就不需要工作闲起来了。。。</p>
<p>2010/3/25 qiaojie <a href="&#109;&#x61;&#105;&#x6c;&#116;&#111;&#58;&#91;&#113;&#x69;&#x61;&#x2e;&#46;&#46;&#64;&#x67;&#x6d;&#x61;&#105;&#x6c;&#46;&#99;&#111;&#x6d;&#93;&#40;&#x29;">&#91;&#113;&#x69;&#x61;&#x2e;&#46;&#46;&#64;&#x67;&#x6d;&#x61;&#105;&#x6c;&#46;&#99;&#111;&#x6d;&#93;&#40;&#x29;</a>
如果产能=消费的话就没有产能过剩这一说了。</p>
<p>2010/3/25 机械唯物主义 : linjunhalida <a href="&#109;&#x61;&#105;&#108;&#x74;&#111;&#58;&#x5b;&#108;&#x69;&#110;&#106;&#117;&#110;&#46;&#x2e;&#x2e;&#64;&#103;&#109;&#97;&#x69;&#108;&#x2e;&#99;&#x6f;&#x6d;&#93;&#x28;&#x29;">&#x5b;&#108;&#x69;&#110;&#106;&#117;&#110;&#46;&#x2e;&#x2e;&#64;&#103;&#109;&#97;&#x69;&#108;&#x2e;&#99;&#x6f;&#x6d;&#93;&#x28;&#x29;</a></p>
<p>一个谬误：刺激需求
产能=消费，产能才是主动力。技术成长是随着产能成长而起来的。
而产能多的结果就是满足了需求，造成一种需求带来技术进步的假像。
而技术和产能之间的关系又错综复杂。。
2010/3/25 qiaojie <a href="&#109;&#97;&#105;&#108;&#x74;&#x6f;&#58;&#91;&#x71;&#x69;&#x61;&#46;&#x2e;&#46;&#x40;&#x67;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#40;&#x29;">&#91;&#x71;&#x69;&#x61;&#46;&#x2e;&#46;&#x40;&#x67;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#40;&#x29;</a></p>
<p>3D游戏就是一类杀手应用，由此支撑起了一个庞大的GPU市场，芯片行业的研发成本是很高的，没有一个庞大的市场是做不起来的。目前的消费者对于多核系统显然还没有强烈的需求，因为应用跟不上，i7发布快2年了还没进入主流市场，这种情况延续下去的话摩尔定律将因此失效。不过我相信杀手级应用总会出现的，这可能要硬件性能突破一个临界点，比方说目前GPU的性能再提升一个数量级的话，光线跟踪算法就可以提供流畅的接近CG的画质，倒是此类应用便会流行开来。</p>
<p>2010/3/25 Guancheng Chen <a href="&#x6d;&#97;&#105;&#x6c;&#x74;&#111;&#x3a;&#x5b;&#x63;&#x68;&#x65;&#110;&#103;&#117;&#46;&#46;&#x2e;&#x40;&#x67;&#x6d;&#97;&#x69;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#93;&#x28;&#41;">&#x5b;&#x63;&#x68;&#x65;&#110;&#103;&#117;&#46;&#46;&#x2e;&#x40;&#x67;&#x6d;&#97;&#x69;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#93;&#x28;&#41;</a></p>
<p>杀手应用一般来说是指什么样的应用呢？比如用户群特别大的网游？还是那些专有的科学计算用的软件？
On 3月24日, 下午12时36分, qiaojie <a href="&#109;&#x61;&#105;&#108;&#116;&#x6f;&#x3a;&#91;&#x71;&#105;&#97;&#x6f;&#46;&#x2e;&#46;&#x40;&#103;&#109;&#x61;&#105;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#40;&#x29;">&#91;&#x71;&#105;&#97;&#x6f;&#46;&#x2e;&#46;&#x40;&#103;&#109;&#x61;&#105;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>并行计算本来就是曲高和寡的东西，就跟3D渲染一样，能开发引擎的毕竟只是小部分人，大多数人在引擎的基础上做应用。关键在于是否有杀手应用，只要有大量的需求 ，自然会有人去做开发。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#x6d;&#97;&#x69;&#x6c;&#116;&#x6f;&#58;&#91;&#104;&#x6f;&#x6e;&#x67;&#x7a;&#x68;&#x61;&#x6e;&#103;&#46;&#x2e;&#x2e;&#46;&#64;&#x67;&#x6d;&#97;&#105;&#108;&#46;&#x63;&#111;&#109;&#x5d;&#x28;&#x29;">&#91;&#104;&#x6f;&#x6e;&#x67;&#x7a;&#x68;&#x61;&#x6e;&#103;&#46;&#x2e;&#x2e;&#46;&#64;&#x67;&#x6d;&#97;&#105;&#108;&#46;&#x63;&#111;&#109;&#x5d;&#x28;&#x29;</a></p>
<blockquote>
<p>异构平台从网络处理器算起已经快10年了，现在情况仍然不明朗。就我看到的，异构平台要想高效，就必须向程序员暴露非常多的硬件细节，这必然导致编程的复杂性。 曲高和寡，要想渗透到应用程序这一块，我觉得很难。</p>
<p>2010/3/24 qiaojie <a href="&#x6d;&#97;&#105;&#x6c;&#x74;&#111;&#x3a;&#91;&#113;&#x69;&#97;&#111;&#x2e;&#x2e;&#46;&#64;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#93;&#x28;&#x29;">&#91;&#113;&#x69;&#97;&#111;&#x2e;&#x2e;&#46;&#64;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#93;&#x28;&#x29;</a></p>
<blockquote>
<p>说的没错，cell已经成了先烈了。不过这不代表异构的方向不对，CUDA，OpenCL也都是异构平台，以后我们会越来越习惯异构平台的。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#x6d;&#x61;&#x69;&#x6c;&#116;&#x6f;&#x3a;&#91;&#x68;&#111;&#x6e;&#103;&#x7a;&#x68;&#x61;&#x6e;&#x67;&#46;&#x2e;&#46;&#46;&#x40;&#103;&#109;&#97;&#105;&#x6c;&#x2e;&#99;&#x6f;&#109;&#93;&#x28;&#x29;">&#91;&#x68;&#111;&#x6e;&#103;&#x7a;&#x68;&#x61;&#x6e;&#x67;&#46;&#x2e;&#46;&#46;&#x40;&#103;&#109;&#97;&#105;&#x6c;&#x2e;&#99;&#x6f;&#109;&#93;&#x28;&#x29;</a></p>
<p>异构平台如果编程复杂度降不下来的话很难流行起来。cell已经死了...</p>
<blockquote>
<p> 2010/3/24 qiaojie <a href="&#109;&#97;&#x69;&#108;&#x74;&#x6f;&#x3a;&#x5b;&#x71;&#105;&#x61;&#111;&#x2e;&#46;&#x2e;&#64;&#x67;&#109;&#97;&#x69;&#x6c;&#x2e;&#99;&#111;&#109;&#93;&#40;&#x29;">&#x5b;&#x71;&#105;&#x61;&#111;&#x2e;&#46;&#x2e;&#64;&#x67;&#109;&#97;&#x69;&#x6c;&#x2e;&#99;&#111;&#109;&#93;&#40;&#x29;</a></p>
<blockquote>
<p>不是所有的程序都需要并行化的，能用串行化解决的问题没必要并行，所以即使将来many-core系统成为主流，大部分程序员也没必要去搞并行计算。
  我觉得未来的主流应该是类似cell这样一颗全功能核心带众多协处理核心的异构系统，这样才能达到最优的 性能/核心面积比。</p>
<p>2010/3/24 Guancheng Chen <a href="&#109;&#x61;&#105;&#108;&#116;&#x6f;&#58;&#91;&#99;&#104;&#x65;&#x6e;&#103;&#117;&#97;&#110;&#x63;&#x68;&#x2e;&#46;&#x2e;&#64;&#x67;&#x6d;&#x61;&#x69;&#108;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#x29;">&#91;&#99;&#104;&#x65;&#x6e;&#103;&#117;&#97;&#110;&#x63;&#x68;&#x2e;&#46;&#x2e;&#64;&#x67;&#x6d;&#x61;&#x69;&#108;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#x29;</a></p>
<p>Nice 大胆预测Linear speedup应该是每个程序员十年后的目标 呵呵</p>
<blockquote>
<p>On 3月23日, 上午10时43分, qiaojie <a href="&#x6d;&#97;&#105;&#x6c;&#x74;&#x6f;&#x3a;&#x5b;&#x71;&#x69;&#x61;&#111;&#x2e;&#46;&#x2e;&#64;&#x67;&#109;&#x61;&#105;&#108;&#x2e;&#x63;&#111;&#109;&#93;&#40;&#41;">&#x5b;&#x71;&#x69;&#x61;&#111;&#x2e;&#46;&#x2e;&#64;&#x67;&#109;&#x61;&#105;&#108;&#x2e;&#x63;&#111;&#109;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>目前正在写的是一个软件渲染器，采用了光栅化和光线跟踪混合算法，渲染算法已经完全并行化了，
在4核系统上基本可以达到线性加速比，更多核的系统暂时还没测试。kd-tree的构造暂时还没有并
行化，以后有空了再研究。</p>
<p>2010/3/23 Guancheng Chen <a href="&#x6d;&#97;&#x69;&#x6c;&#x74;&#x6f;&#x3a;&#x5b;&#99;&#104;&#x65;&#x6e;&#x67;&#117;&#97;&#110;&#x63;&#104;&#x2e;&#46;&#x2e;&#x40;&#103;&#109;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#x28;&#x29;">&#x5b;&#99;&#104;&#x65;&#x6e;&#x67;&#117;&#97;&#110;&#x63;&#104;&#x2e;&#46;&#x2e;&#x40;&#103;&#109;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#x28;&#x29;</a></p>
<blockquote>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？</p>
<p>On 3月23日, 上午9时15分, qiaojie <a href="&#x6d;&#97;&#105;&#108;&#116;&#x6f;&#x3a;&#x5b;&#113;&#x69;&#97;&#x6f;&#x2e;&#x2e;&#46;&#x40;&#103;&#109;&#97;&#x69;&#x6c;&#x2e;&#x63;&#111;&#109;&#93;&#40;&#41;">&#x5b;&#113;&#x69;&#97;&#x6f;&#x2e;&#x2e;&#46;&#x40;&#103;&#109;&#97;&#x69;&#x6c;&#x2e;&#x63;&#111;&#109;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1)
=
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank
Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？</p>
</blockquote>
<p> To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> 居振梁 <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-25</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>哈哈，估计有人想说“这次居然是收敛的”</p>
<p>2010/3/25 机械唯物主义 : linjunhalida <a href="&#109;&#97;&#x69;&#x6c;&#116;&#111;&#58;&#x5b;&#108;&#105;&#x6e;&#x6a;&#x75;&#x6e;&#x2e;&#46;&#x2e;&#x40;&#103;&#x6d;&#97;&#x69;&#108;&#x2e;&#x63;&#111;&#109;&#93;&#x28;&#41;">&#x5b;&#108;&#105;&#x6e;&#x6a;&#x75;&#x6e;&#x2e;&#46;&#x2e;&#x40;&#103;&#x6d;&#97;&#x69;&#108;&#x2e;&#x63;&#111;&#109;&#93;&#x28;&#41;</a></p>
<h2 id="-">恩，离题远了。不再讨论经济。</h2>
<p>御剑乘风来，除魔天地间。有酒乐逍遥，无酒我亦颠。
<a href="http://www.xspirithack.org/" target="_blank"><a href="http://www.xspirithack.org">http://www.xspirithack.org</a></a>
一饮尽江河，再饮吞日月。千杯醉不倒，唯我酒剑仙。
<a href="">显示删减掉的内容</a></p>
<p><img src="" alt=""> qiaojie <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-25</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>淡定....
2010/3/25 居振梁 <a href="&#109;&#x61;&#105;&#108;&#x74;&#x6f;&#x3a;&#91;&#x6a;&#117;&#122;&#104;&#x65;&#x2e;&#46;&#46;&#x40;&#x67;&#x6d;&#97;&#x69;&#x6c;&#46;&#99;&#x6f;&#109;&#x5d;&#x28;&#x29;">&#91;&#x6a;&#117;&#122;&#104;&#x65;&#x2e;&#46;&#46;&#x40;&#x67;&#x6d;&#97;&#x69;&#x6c;&#46;&#99;&#x6f;&#109;&#x5d;&#x28;&#x29;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>哈哈，估计有人想说“这次居然是收敛的”</p>
<p>2010/3/25 机械唯物主义 : linjunhalida <a href="&#109;&#x61;&#x69;&#108;&#x74;&#111;&#x3a;&#91;&#x6c;&#105;&#110;&#x6a;&#117;&#x6e;&#x2e;&#46;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#x69;&#108;&#46;&#x63;&#111;&#x6d;&#x5d;&#x28;&#41;">&#91;&#x6c;&#105;&#110;&#x6a;&#117;&#x6e;&#x2e;&#46;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#x69;&#108;&#46;&#x63;&#111;&#x6d;&#x5d;&#x28;&#41;</a></p>
<h2 id="-"> 恩，离题远了。不再讨论经济。</h2>
<p>御剑乘风来，除魔天地间。有酒乐逍遥，无酒我亦颠。
<a href="http://www.xspirithack.org/" target="_blank"><a href="http://www.xspirithack.org">http://www.xspirithack.org</a></a>
一饮尽江河，再饮吞日月。千杯醉不倒，唯我酒剑仙。</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> tinyfool <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-25</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>呵呵，其实咱们组真的已经是互联网上讨论组里面，最平和，最专业的一个了。</p>
<p>大家有时候稍微相互包容点，就不至于弄得大家都不愉快的，我们还是挺好的。
不准老幸灾乐祸，惟恐天下不乱的，哈哈</p>
<p>技术讨论技术吧
我继续鼓吹OPENCL，哈哈</p>
<p>在 2010-3-25，下午2:44， 居振梁 写道：</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>哈哈，估计有人想说“这次居然是收敛的”</p>
<p>2010/3/25 机械唯物主义 : linjunhalida <a href="&#109;&#x61;&#x69;&#108;&#x74;&#x6f;&#58;&#x5b;&#108;&#105;&#x6e;&#106;&#117;&#110;&#x2e;&#46;&#x2e;&#64;&#x67;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#x6f;&#109;&#93;&#x28;&#41;">&#x5b;&#108;&#105;&#x6e;&#106;&#117;&#110;&#x2e;&#46;&#x2e;&#64;&#x67;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#x6f;&#109;&#93;&#x28;&#41;</a></p>
<h2 id="-">恩，离题远了。不再讨论经济。</h2>
<p>御剑乘风来，除魔天地间。有酒乐逍遥，无酒我亦颠。
<a href="http://www.xspirithack.org/" target="_blank"><a href="http://www.xspirithack.org">http://www.xspirithack.org</a></a>
一饮尽江河，再饮吞日月。千杯醉不倒，唯我酒剑仙。</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a></p>
<p><img src="" alt=""> fxc...@gmail.com <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-26</p>
<p>其他收件人：</p>
<p>好吧，俺也打个广告。
既然大家都说tools是concurrent的一个大issue。那不妨看看MS的Concurrency工具包：Parallel
Debugger/Parallel Profiler. 在下一个版本VS里面会加入Static Analysis的support。
<a href="http://msdn.microsoft.com/en-us/concurrency/default.aspx" target="_blank">msdn.microsoft.com/en-us/concurrency/default.aspx</a></p>
<p>On Mar 24, 9:04 am, 莫华枫 <a href="&#109;&#x61;&#x69;&#x6c;&#x74;&#111;&#x3a;&#91;&#x6c;&#x6f;&#x6e;&#103;&#115;&#x68;&#97;&#x6e;&#x6b;&#46;&#46;&#46;&#64;&#103;&#x6d;&#97;&#105;&#108;&#x2e;&#99;&#111;&#109;&#93;&#40;&#x29;">&#91;&#x6c;&#x6f;&#x6e;&#103;&#115;&#x68;&#97;&#x6e;&#x6b;&#46;&#46;&#46;&#64;&#103;&#x6d;&#97;&#105;&#108;&#x2e;&#99;&#111;&#109;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>凑个热闹，也来个广告：CERL 2.0初具雏形。</p>
<p>--
反者道之动，弱者道之用
longshank...@gmail.com<a href="http://[blog.csdn.net/longshanks/](http://blog.csdn.net/longshanks/" target="_blank">http://[blog.csdn.net/longshanks/](http://blog.csdn.net/longshanks/</a>)
wave开通
<a href="">显示删减掉的内容</a>
<img src="" alt=""> AWu <img src="" alt=""></p>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-28</p>
<p>其他收件人：</p>
<p>这不是逼俺买MBP嘛？</p>
<p>感觉并行需要有足够简单，足够可靠的工程实施方法才能够大规模得被应用～
毕竟IT业从业人员不是所有人都足够聪明能够写得了、分析得了并行</p>
<p>一个可靠的工程方法来规避并行可能引发的性能或者功能缺陷，如果能够抽象到库里面规避当然更好，但是库这个东西得有足够多的工程实践才能做得出来吧，所
以我认为第一步是有一个可行的并行工程实施方法。</p>
<p>On 3月22日, 下午2时06分, Guancheng Chen <a href="&#x6d;&#x61;&#x69;&#108;&#x74;&#x6f;&#58;&#91;&#99;&#104;&#x65;&#110;&#x67;&#117;&#x61;&#110;&#x63;&#104;&#46;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#x61;&#105;&#108;&#x2e;&#x63;&#x6f;&#109;&#93;&#40;&#x29;">&#91;&#99;&#104;&#x65;&#110;&#x67;&#117;&#x61;&#110;&#x63;&#104;&#46;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#x61;&#105;&#108;&#x2e;&#x63;&#x6f;&#109;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>On 3月22日, 上午2时20分, Tinyfool <a href="&#x6d;&#97;&#x69;&#108;&#x74;&#x6f;&#x3a;&#x5b;&#116;&#x69;&#110;&#121;&#102;&#46;&#x2e;&#46;&#x40;&#x67;&#x6d;&#97;&#x69;&#108;&#46;&#99;&#x6f;&#x6d;&#x5d;&#40;&#x29;">&#x5b;&#116;&#x69;&#110;&#121;&#102;&#46;&#x2e;&#46;&#x40;&#x67;&#x6d;&#97;&#x69;&#108;&#46;&#99;&#x6f;&#x6d;&#x5d;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#109;&#x61;&#x69;&#x6c;&#x74;&#x6f;&#x3a;&#x5b;&#x6a;&#x65;&#46;&#46;&#46;&#64;&#108;&#x69;&#118;&#101;&#46;&#99;&#x6f;&#109;&#x5d;&#x28;&#41;">&#x5b;&#x6a;&#x65;&#46;&#46;&#46;&#64;&#108;&#x69;&#118;&#101;&#46;&#99;&#x6f;&#109;&#x5d;&#x28;&#41;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#111;&#58;&#x5b;&#x63;&#x68;&#x65;&#x6e;&#x67;&#x75;&#x61;&#x6e;&#x63;&#104;&#x2e;&#x2e;&#46;&#x40;&#103;&#109;&#97;&#105;&#108;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#40;&#x29;">&#x5b;&#x63;&#x68;&#x65;&#x6e;&#x67;&#x75;&#x61;&#x6e;&#x63;&#104;&#x2e;&#x2e;&#46;&#x40;&#103;&#109;&#97;&#105;&#108;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#40;&#x29;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#109;&#x61;&#x69;&#x6c;&#116;&#x6f;&#58;&#91;&#112;&#x6f;&#110;&#46;&#x2e;&#46;&#x40;&#103;&#x6f;&#x6f;&#x67;&#108;&#x65;&#x67;&#x72;&#x6f;&#x75;&#112;&#x73;&#x2e;&#x63;&#x6f;&#109;&#93;&#40;&#x29;">&#91;&#112;&#x6f;&#110;&#46;&#x2e;&#46;&#x40;&#103;&#x6f;&#x6f;&#x67;&#108;&#x65;&#x67;&#x72;&#x6f;&#x75;&#112;&#x73;&#x2e;&#x63;&#x6f;&#109;&#93;&#40;&#x29;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。</p>
</li>
</ol>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>--
Tinyfool的开发日记<a href="http://www.tinydust.net/dev/" target="_blank"><a href="http://www.tinydust.net/dev/">http://www.tinydust.net/dev/</a></a>
代码中国网<a href="http://www.codechina.org/" target="_blank"><a href="http://www.codechina.org">http://www.codechina.org</a></a>
myTwitter:<a href="http://twitter.com/tinyfool" target="_blank"><a href="http://twitter.com/tinyfool">http://twitter.com/tinyfool</a></a>
<a href="">显示删减掉的内容</a>
上一页 <a href="">上一页</a>  </p>
</blockquote>
</blockquote>
<p>第 <strong>1</strong> 页
  下一页 <a href="">下一页</a></p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/好文摘录/">好文摘录</a></li></span></span> | <span class="time">recent updated:<time title="2014-03-07 11:24:30"datetime="2014-03-07 11:24:30"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/03/2014-02-03--{技术}{多线程}实施并行编程的五大障碍/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-03--{技术}{多线程}实施并行编程的五大障碍" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/03/2014-02-03--学习与记忆/">学习与记忆</a></h1>
      
        <span>Posted on<time datetime="2014-02-03T03:24:29.000Z"> <a href="/2014/02/03/2014-02-03--学习与记忆/">feb. 3 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-">学习与记忆</h1>
<p><a href="http://blog.csdn.net/tag/details.html?tag=%e7%ae%97%e6%b3%95" target="_blank">算法</a><a href="http://blog.csdn.net/tag/details.html?tag=%e6%b4%bb%e5%8a%a8" target="_blank">活动</a><a href="http://blog.csdn.net/tag/details.html?tag=%e7%bd%91%e7%bb%9c" target="_blank">网络</a><a href="http://blog.csdn.net/tag/details.html?tag=%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84" target="_blank">数据结构</a><a href="http://blog.csdn.net/tag/details.html?tag=%e5%b7%a5%e4%bd%9c" target="_blank">工作</a><a href="http://blog.csdn.net/tag/details.html?tag=google" target="_blank">google</a></p>
<p><strong>学习与记忆</strong></p>
<p>By 刘未鹏(pongba)</p>
<p>C++的罗浮宫(<a href="http://blog.csdn.net/pongba" title="http://blog.csdn.net/pongba/archive/2008/04/18/2302905.aspx" target="_blank"><a href="http://blog.csdn.net/pongba">http://blog.csdn.net/pongba</a></a>)</p>
<p>TopLanguage(<a href="http://groups.google.com/group/pongba" title="http://groups.google.com/group/pongba" target="_blank"><a href="http://groups.google.com/group/pongba">http://groups.google.com/group/pongba</a></a>)</p>
<p>正儿巴经学习算法算起来也有快两个月了，之前作为计算机工科生虽然算法和数据结构是必修课，但实际上只是停留在“理解”的层面，相当肤浅，更遑论举一反三灵活运用了。因此，所谓“正儿巴经”学习算法，意即开始对算法思想的本质进行归根究底的过程、对思维方法论进行归纳抽象的过程、对各种解题技巧进行一般化的过程、通过不断练习来让记忆内隐化的过程..</p>
<p>在“正儿巴经”学习算法之前，我曾经有大半年时间都在用业余时间“正儿巴经”地学习心理学和认知神经科学。所以在开始正经思考算法问题之前做的第一件事情就是仔细琢磨一直令我困惑的问题——那些看似抓不到摸不着的灵感到底是怎么来的。</p>
<p>现代心理学的一个最伟大的原则就是：所有的心理活动同时都是生理活动。——实际上，“心理活动”只不过是“大脑神经活动”的通俗称呼。虽然大脑的结构极度复杂，然而许多人不知道的是，现代神经科学对大脑功能从高层原则上的认识已经可以说是相当完备了，而对于记忆和学习这块更加是因为<a href="http://en.wikipedia.org/wiki/Eric_Kandel" target="_blank">Eric Kandel</a>的<a href="http://www.douban.com/subject/1944205/" target="_blank">突破性工作</a>变得相当清晰。可以说剩下的工作主要就是补充细节了。于是乎，借助于三本关于记忆和学习的书，一本专门论述解题心理学的书，wikipedia，波利亚的三卷解题书，以及自己在思考有限多的问题的过程中对自己的思维过程的反省和总结，我试着对解题的心理学做了一个思考和总结（《<a href="http://blog.csdn.net/pongba/archive/2008/04/18/2302905.aspx" target="_blank">跟波利亚学解题</a>》）。——这听起来很奇怪，一个本身只会初级算法的人又如何去思考涵盖所有问题解决的思维过程呢？还是引用波利亚著名的发明者悖论吧：有时候，一个一般性的问题反而要比它的一个特例更好解决。</p>
<p>然而，一般性的问题思考清楚了，清楚解题思维的本质了，并不代表我就万能了，就立即擅长解决所有算法问题了。解题不是光靠思维的，巧妇难为无米之炊。事实上，在《跟波利亚学解题》中总结的一个非常关键的要点就是：启发法固然可贵，然而知识的重要性是不可替代的。不存在通用的、万能的知识，要不然我们也不必到今天还在不断探索物质世界的规律了。此外，获得知识的过程——<strong>学习——本质上是个体力活（尽管是有一定方法的体力活）</strong>，这个体力活大致分为两步：</p>
<ul>
<li><strong>将外界（书本上的）知识转化为</strong><a href="http://en.wikipedia.org/wiki/Explicit_memory" target="_blank"><strong>外显记忆</strong></a><strong>。</strong></li>
<li><strong>通过不断练习，将外显记忆转化为</strong><a href="http://en.wikipedia.org/wiki/Implicit_memory" target="_blank"><strong>内隐记忆</strong></a><strong>。</strong></li>
</ul>
<p>（关于什么是外显记忆什么是内隐记忆请参考wikipedia或者《<a href="http://blog.csdn.net/pongba/archive/2008/04/18/2302905.aspx" target="_blank">跟波利亚学解题</a>》）</p>
<p>而第二步又包含两个过程：</p>
<ul>
<li><strong>将关于思维方法的知识转化为内隐记忆从而不知不觉就遵循。</strong></li>
<li><strong>将关于事实知识（例如“定理”、“性质”）的提取线索们转化为内隐记忆从而看到XX就能想到YY。（参考《</strong><a href="http://www.douban.com/subject/1315575/" target="_blank">找寻逝去的自我</a><strong>》第二章“记忆的建构：对现在和过去的编码和提取”）</strong></li>
</ul>
<p>关于第一点有本不错的书——《<a href="http://www.douban.com/subject/2345548/" target="_blank">学习的艺术</a>》。</p>
<p>关于第二点有一个不错的例子，最初从李笑来老师的blog上读到的（《<a href="http://www.xiaolai.net/?p=459" target="_blank">把时间当作朋友</a>》）：
我李敖看的书很少会忘掉，什么原因呢？方法好。什么方法？心狠手辣。剪刀美工刀全部下来，把书给分尸掉了，就是切开了。这一页我需要，这一段我需要，我把它分类分出来了。那背面有怎么办呢？把它影印出来，或者一开始就买两本书，把两本书都切开以后排出来，把要看的部分切开。结果一本书看完了，这本书也被分尸掉了。这就是我的看书方法。</p>
<p><em>那分类怎么分呢？我有很多自己做的夹子，夹子我写上字，把资料全部分类。一本书看完以后，全部进入我的夹子里面了。我可以分出几千个类来，分的很细。好比说按照图书馆的分类，哲学类，宗教类；宗教类再分佛教类、道教类、天主教类。我李敖分的更细了，天主教还可以分，神父算一类。神父还可以细分，神父同性恋就是一类，神父还俗又是一类。修女同性恋是一类，修女还俗这又是一类。</em></p>
<p>任何书里有关的内容都进入我的资料里来。进入干什么呢？当我要写小说的时候，需要这个资料，打开资料，只是写一下就好了。或者发生了一个什么事件，跟修女同性恋有关系，我要发表对新闻的感想，把新闻拿过来，我的资料打开，两个一合并，文章立刻就写出来了。</p>
<p>换句话说，我这本书看完之后，被我大卸八块，五马分尸。可是被我勾住了，这些资料我不凭记忆来记它，我凭用细部的很耐心的功夫把它勾紧，放在资料夹子里。我的记忆力只要记这些标题就好了。标题是按照我的习惯来分，基本上都翻译成英文字，用英文字母排出来，偶尔也有些中文的。</p>
<p>今天我把看家的本领告诉大家，李敖知道的那么多，博闻强记，记忆力那么好。我告诉大家，记忆力是可以训练的。记忆力一开始就是你不要偷懒，不要说躺在那里看书，看完了这本书还是干干净净的，整整齐齐的，这不对。看完了这本书，这本书就大卸八块，书进了资料夹，才算看完这本书。</p>
<p>今天我为大家特别亮一手，把如何看书的招告诉大家。不要以为这本书看完了，干干净净的新的算看过。那个不算看过，因为当时是看过，可是浪费了。你不能够有系统的扣住这些资料，跟资料挂钩。可是找我这个方法，可以把你看过的书，都把它的精华抓出来，扣在一起。这就是我的这种土法炼钢的治学方法。</p>
<p>恰恰运用了记忆最深刻的原理。</p>
<p>我们的大脑本质上是一个计算器，其物质基础是神经网络；而不断的练习则是对该网络节点间联系强度（神经细胞间的突触联系强度）的训练。——可惜的是像爱因斯坦大脑内的经过完美训练的神经网络参数不能直接导入到我大脑中，也许将来可以做到，但目前只有笨办法，实在是件郁闷的事。</p>
<p>所以，拿起书吧，训练你的神经网络，路漫漫其修远兮..</p>
<p><strong>参考</strong></p>
<p>我在豆瓣上列了两个豆列</p>
<ol>
<li>大半年来看过的心理学和神经科学（初步）的书都列在<a href="http://www.douban.com/doulist/46003/" target="_blank">这个豆列</a>里了。</li>
<li>其中涉及到思维方法论的书单独列在<a href="http://www.douban.com/doulist/127649/" target="_blank">这个豆列</a>里了。</li>
<li>如果你觉得里面列的书太多了不知从何下手，可以优先考虑《<a href="http://blog.csdn.net/pongba/archive/2008/04/18/2302905.aspx" target="_blank">跟波利亚学解题</a>》中列出的书。</li>
</ol>
<p><strong>P.S.</strong></p>
<p>很久不宣传我们的<a href="http://groups.google.com/group/pongba" target="_blank">TopLanguage讨论组</a>了，这个可爱的讨论组<a href="http://blog.csdn.net/pongba/archive/2008/03/12/2172677.aspx" target="_blank">诞生</a>大半年了，大半年来，人数达到了1千多，讨论8千多，主题6百多。目前活跃程度仅次于Python-CN，更重要的是，讨论组内的总体讨论质量相当高（只过年前后那段时候水了一阵）。反正我从中受益很多，在此谢谢大家！</p>
<p>那么，为什么现在又来宣传捏？盖因近来愈是发现里面牛人众多，藏龙卧虎，所以我要大言不惭地替各位牛人吹嘘，“欢迎加入牛逼<a href="http://groups.google.com/group/pongba" target="_blank">TopLanguage</a>兄弟会”:P 我们<strong><em>不</em></strong>讨论鸡零狗碎的，或者可以请教Google得到的，或者可以查书查到的问题 :P
来源： <a href="[http://blog.csdn.net/pongba/article/details/2513263](http://blog.csdn.net/pongba/article/details/2513263)">[http://blog.csdn.net/pongba/article/details/2513263](http://blog.csdn.net/pongba/article/details/2513263)</a> 
17楼 <a href="http://blog.csdn.net/xiaoyao3857" target="_blank">xiaoyao3857</a> 2011-11-08 00:13发表 <a href="http://blog.csdn.net/pongba/article/details/2513263#reply" title="回复" target="_blank">[回复]</a> <a href="http://blog.csdn.net/xiaoyao3857" target="_blank"><img src="" alt=""></a> 牛人啊，弄IT的还看了那么多书，包括心理学的、算法等，实在是强 16楼 <a href="http://blog.csdn.net/dongzezhen" target="_blank">dongzezhen</a> 2011-08-18 17:51发表 <a href="http://blog.csdn.net/pongba/article/details/2513263#reply" title="回复" target="_blank">[回复]</a> <a href="http://blog.csdn.net/dongzezhen" target="_blank"><img src="" alt=""></a> 真的很喜欢你写的文章~~ 15楼 <a href="http://blog.csdn.net/popskf" target="_blank">popskf</a> 2010-10-09 22:45发表 <a href="http://blog.csdn.net/pongba/article/details/2513263#reply" title="回复" target="_blank">[回复]</a> <a href="http://blog.csdn.net/popskf" target="_blank"><img src="" alt=""></a> 您说的TopLanguage讨论组是不是被和谐了？那个地址上不去哟。 14楼 <a href="http://blog.csdn.net/dongan383" target="_blank">dongan383</a> 2010-08-15 20:47发表 <a href="http://blog.csdn.net/pongba/article/details/2513263#reply" title="回复" target="_blank">[回复]</a> <a href="http://blog.csdn.net/dongan383" target="_blank"><img src="" alt=""></a> 找到知音啦！心里的好些困惑一下子揭开了许多！[e01] 13楼 <a href="http://blog.csdn.net/%E5%8C%BF%E5%90%8D%E7%94%A8%E6%88%B7" target="_blank">匿名用户</a> 2010-03-08 15:52发表 <a href="http://blog.csdn.net/pongba/article/details/2513263#reply" title="回复" target="_blank">[回复]</a> <a href="http://blog.csdn.net/%E5%8C%BF%E5%90%8D%E7%94%A8%E6%88%B7" target="_blank"><img src="" alt=""></a> [e01] 12楼 <a href="http://blog.csdn.net/WolfMvP" target="_blank">WolfMvP</a> 2010-03-06 14:13发表 <a href="http://blog.csdn.net/pongba/article/details/2513263#reply" title="回复" target="_blank">[回复]</a> <a href="http://blog.csdn.net/WolfMvP" target="_blank"><img src="" alt=""></a> 没有你读过那么多的书，不过，有时候我也在思考为什么我心里想的和嘴里说的不一样，是很自然的事儿不是刻意为之，原来源头在这里呀，嘿嘿，受教咯！ 11楼 <a href="http://blog.csdn.net/flyinginwind" target="_blank">flyinginwind</a> 2009-11-12 08:32发表 <a href="http://blog.csdn.net/pongba/article/details/2513263#reply" title="回复" target="_blank">[回复]</a> <a href="http://blog.csdn.net/flyinginwind" target="_blank"><img src="" alt=""></a> 偶尔按照这样子的方式在做，但是看了你的文章之后，使我从偶然世界中来到了必然世界，知道了自己以后的方向了。 10楼 <a href="http://blog.csdn.net/kewan001" target="_blank">kewan001</a> 2008-10-12 12:25发表 <a href="http://blog.csdn.net/pongba/article/details/2513263#reply" title="回复" target="_blank">[回复]</a> <a href="http://blog.csdn.net/kewan001" target="_blank"><img src="" alt=""></a> 我也时不时的思考，关于如何学习，记忆等这些问题，但不曾看过什么著作，你带我看到了一个新的世界，谢过 9楼 <a href="http://blog.csdn.net/ybark" target="_blank">ybark</a> 2008-08-19 17:53发表 <a href="http://blog.csdn.net/pongba/article/details/2513263#reply" title="回复" target="_blank">[回复]</a> <a href="http://blog.csdn.net/ybark" target="_blank"><img src="" alt=""></a> 天天看卢浮宫，不过好久没更新啦，期待ing 8楼 <a href="http://blog.csdn.net/daxi" target="_blank">daxi</a> 2008-07-26 20:03发表 <a href="http://blog.csdn.net/pongba/article/details/2513263#reply" title="回复" target="_blank">[回复]</a> <a href="http://blog.csdn.net/daxi" target="_blank"><img src="" alt=""></a> 受教了，我以前的知识面太窄，要先博后渊才能看的更高更远 7楼 <a href="http://blog.csdn.net/%E8%B7%AF%E8%BF%87" target="_blank">路过</a> 2008-07-24 22:17发表 <a href="http://blog.csdn.net/pongba/article/details/2513263#reply" title="回复" target="_blank">[回复]</a> <a href="http://blog.csdn.net/%E8%B7%AF%E8%BF%87" target="_blank"><img src="" alt=""></a> 我认为老子的&quot;无为则无不为&quot;是学习的终极本质. 6楼 <a href="http://blog.csdn.net/xinghongyang" target="_blank">xinghongyang</a> 2008-07-21 14:28发表 <a href="http://blog.csdn.net/pongba/article/details/2513263#reply" title="回复" target="_blank">[回复]</a> <a href="http://blog.csdn.net/xinghongyang" target="_blank"><img src="" alt=""></a> 文章写得很有深度，看了之后，感慨比较多，以前一直追寻的方法用文字表达出来，原来是这么子的简单，只是这些方法性的引导，最重要的还是实际操作，我个人觉得自己读过很多的书，缺的就是实际操作能力，以致于一直在重复同样的事情，而没有那种收获的感觉。 5楼 <a href="http://blog.csdn.net/vip585" target="_blank">vip585</a> 2008-07-09 20:40发表 <a href="http://blog.csdn.net/pongba/article/details/2513263#reply" title="回复" target="_blank">[回复]</a> <a href="http://blog.csdn.net/vip585" target="_blank"><img src="" alt=""></a> 佩服啊,我有个问题在烦,就是如何掌握自己的心理,把握自己朝理想的方向不断前进呢. 4楼 <a href="http://blog.csdn.net/wodiw" target="_blank">wodiw</a> 2008-06-10 11:04发表 <a href="http://blog.csdn.net/pongba/article/details/2513263#reply" title="回复" target="_blank">[回复]</a> <a href="http://blog.csdn.net/wodiw" target="_blank"><img src="" alt=""></a> 如果能找个好媳妇，或幸免于难！ 3楼 <a href="http://blog.csdn.net/wodiw" target="_blank">wodiw</a> 2008-06-10 11:03发表 <a href="http://blog.csdn.net/pongba/article/details/2513263#reply" title="回复" target="_blank">[回复]</a> <a href="http://blog.csdn.net/wodiw" target="_blank"><img src="" alt=""></a> 照这个趋势下去，刘兄最终可能会是个哲学家！！ 2楼 <a href="http://blog.csdn.net/%E7%8B%BC%E6%9C%9B%E5%85%AE" target="_blank">狼望兮</a> 2008-06-06 17:17发表 <a href="http://blog.csdn.net/pongba/article/details/2513263#reply" title="回复" target="_blank">[回复]</a> <a href="http://blog.csdn.net/%E7%8B%BC%E6%9C%9B%E5%85%AE" target="_blank"><img src="" alt=""></a> 文章写得很有深度，看了之后，感慨比较多，以前一直追寻的方法用文字表达出来，原来是这么子的简单，只是这些方法性的引导，最重要的还是实际操作，我个人觉得自己读过很多的书，缺的就是实际操作能力，以致于一直在重复同样的事情，而没有那种收获的感觉。 1楼 <a href="http://blog.csdn.net/fferror" target="_blank">fferror</a> 2008-06-05 22:02发表 <a href="http://blog.csdn.net/pongba/article/details/2513263#reply" title="回复" target="_blank">[回复]</a> <a href="http://blog.csdn.net/pongba/article/details/2513263#quote" title="引用" target="_blank">[引用]</a> <a href="http://blog.csdn.net/pongba/article/details/2513263#report" title="举报" target="_blank">[举报]</a> <a href="http://blog.csdn.net/fferror" target="_blank"><img src="" alt=""></a> 看得出pongba对于认知科学的一些理解已经进入implicit memory了。</p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/好文摘录/">好文摘录</a></li></span></span> | <span class="time">recent updated:<time title="2014-03-07 11:24:29"datetime="2014-03-07 11:24:29"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/03/2014-02-03--学习与记忆/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-03--学习与记忆" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>





<ul id="pagination" class="pagination pagination-lg">
  <li><a class="extend prev" href="/page/2/">&laquo;</a></li><li><a class="page-number" href="/">1</a></li><li><a class="page-number" href="/page/2/">2</a></li><li><a class="page-number" href="/page/2/">2</a></li><li class="active"><li><span class="page-number current">3</span></li><li><a class="page-number" href="/page/4/">4</a></li><li><a class="page-number" href="/page/5/">5</a></li><li><a class="page-number" href="/page/6/">6</a></li><li><span class="space">&hellip;</span></li></li><li><a class="page-number" href="/page/164/">164</a></li><li><a class="page-number" href="/page/165/">165</a></li><li><a class="extend next" href="/page/4/">&raquo;</a></li>
  <div class="clearfix"></div>
</ul></div><!--wapper-->
       </div><!-- ID main-col END -->
       <aside id="sidebar" class="alignright col-sx-6 col-sm-4 col-md-3 col-lg-3">
<div id="widget_search" class="widget panel panel-primary">
    <form action="//google.com/search" method="get" accept-charset="utf-8">
  <div class="input-group">
    <input class="form-control" id="searchbox" type="search" name="q" results="0" placeholder="search">
    <span class="input-group-btn">
      <button class="btn btn-default" type="submit">Go!</button>
    </span>
    <input type="hidden" name="q" value="site:itsolife.com">
  </div>
</form>
</div>

<div id="widget_category" class="widget panel panel-primary">
  <div class="panel-heading">category</div>  <div data-src='category' class='ajax_widgets'>正在加载...</div>
</div>

<div id="widget_recent_posts" class="widget panel panel-primary">
  <div class="panel-heading">recent posts</div>  <div data-src='recent_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_tagcloud" class="widget panel panel-primary">
  <div class="panel-heading">tagcloud</div>  <div data-src='tagcloud' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_latest_update_posts" class="widget panel panel-primary">
  <div class="panel-heading">最近更新</div>  <div data-src='latest_update_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_recent_comments" class="widget panel panel-primary">
  <div class="panel-heading">recent comments</div>  

<div class="list-group-item ds-recent-comments" data-num-items="6" data-show-avatars="1" data-show-time="1" data-show-title="1" data-show-admin="1" data-excerpt-length="50"></div>



</div>

</aside>
       <div class="clearfix"></div>
     </div><!-- row END -->
  </div>
  <footer id="footer" class="container">
  <div class="panel panel-info">
  <section id='footer_widget'></section>  <div class="panel-footer">
  <div id="site-info">
    <span class='author'>
  
  &copy; 2014 RobinChia
  
    &nbsp;&nbsp;</span>
  
  <span id='analytics-51la'></span><span id='analytics-google'>
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-48559895-1']);
  _gaq.push(['_trackPageview']);
  _js2load.push({src:('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'});
</script></span><span id='analytics-cnzz'>
<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_5774006'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s17.cnzz.com/stat.php%3Fid%3D5774006%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>
</span><span id='analytics-baidu'>
<script>
var _hmt = _hmt || [];
_js2load.push({src:"//hm.baidu.com/hm.js?1442f50724afc42380b51f097c43082c"});
</script>
</span>  </div>
  <div id="copyright">Blog powered by <a href='http://zespia.tw/hexo/'><strong>hexo</strong></a> Theme <strong><a href='https://github.com/chenall/hexo-theme-chenall'>chenall</a></strong>(Some change in it)<span class="pull-right"> 更新时间: <em>2014-03-25 18:15:41</em></span></div>
</div>
<div class="clearfix"></div>


  </div>
  </footer>
  
        <script src="http://cdn.bootcss.com/jquery/1.10.2/jquery.min.js"></script>        
        <script src="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/js/bootstrap.min.js"></script>        
                
        <script src="http://cdn.bootcss.com/prettify/r298/prettify.min.js"></script>    <script type="text/javascript">
   var lang=["bsh", "c", "cc", "cpp", "cs", "csh", "cyc", "cv", "htm", "html",
    "java", "js", "m", "mxml", "perl", "pl", "pm", "py", "rb", "sh",
    "xhtml", "xml", "xsl"];
   var pretty_base='';
   $('script').each(function(){
	var c = $(this).attr('src');
	if (!c)
	    return;
	if (c.match(/(\/)?prettify(\.min)?\.js/i))
	{
	    var index = c.lastIndexOf('/');
	    if (index != -1)
		pretty_base = c.substr(0,index + 1);
	    return false;
	}
   })
   $('pre code').each(function(){
	var c = $(this).attr('class')
	if (!c)
	    return;
	c = c.match(/\s?(lang\-\w+)/i);
	if (c && lang.indexOf(c[1]) == -1)
	{
	    lang.push(c[1]);
	    $.getScript(pretty_base + c[1] + '.min.js');
	}
   })

    $(window).load(function(){
       $("pre").addClass("prettyprint");
       prettyPrint();
    })
</script>    
            <script type="text/javascript">
var duoshuoQuery = {short_name:"robinchia"};
_js2load.push({src:'http://static.duoshuo.com/embed.js',charset:'UTF-8'});
</script>
    
            <!--wumii_relatedItems-->
    
        <script src="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js"></script>    <script type="text/javascript">
(function($){
  $('.entry').each(function(i){
    $(this).find('img').each(function(){
      var alt = this.alt;

      if (alt){
        $(this).before('<span class="caption">' + alt + '</span>');
      }

      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox" rel="fancybox' + i + '" />');
    });
  });

  $('.fancybox').fancybox();
})(jQuery);
</script>    
        <script src="http://cdn.bootcss.com/mathjax/2.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>    <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>
    
<script type="text/javascript">
$('.ajax_widgets').each(function(){var src=$(this).attr('data-src');if(src)$(this).load('/widgets/'+src+'.html');});
$.each(_js2load,function(index,obj){loadjs(obj.src,obj.charset)});
</script>

<div id="scroll2top">
<img src="/scroll2top/arrow.png"/>
</div>
<script src="/scroll2top/scroll2top.min.js"></script>
<div id="winterland">
  <canvas></canvas>
</div>
<script src="/js/winterland.min.js"></script>

  </body>
</html>
