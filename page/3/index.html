
<!DOCTYPE HTML>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>The 3 Page | It so life</title>
<meta name="author" content="RobinChia">

<meta name="description" content="It so life">


<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<meta property="og:site_name" content="It so life"/>

<!--[if IE]><style>.testIE.IE{display:inline;}</style><![endif]-->
<!--[if lte IE 7]><link rel="stylesheet" href="/css/ie7.css" type="text/css"><![endif]-->
<!--[if (lt IE 9)&(gt IE 7)]><style>.testIE.IE8{display:inline;}</style><![endif]-->
<!--[if gt IE 8]><style>.testIE.IE9{display:inline;}</style><![endif]-->

<link href="/favicon.png" rel="icon">
<link rel="alternate" href="/atom.xml" title="It so life Feed" type="application/atom+xml">

<link rel="stylesheet" href="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/css/bootstrap.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/font-awesome/4.0.3/css/font-awesome.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/prettify/r298/prettify.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" type="text/css">
<link rel="stylesheet" href="/css/style.css" type="text/css">
<!--[if lt IE 9]>
   <style>article,aside,dialog,footer,header,section,footer,nav,figure,menu{display:block}</style>
   <script src="http://cdn.staticfile.org/html5shiv/r29/html5.min.js"></script>
   <script src="http://cdn.staticfile.org/respond.js/1.4.2/respond.min.js"></script>
<link href="http://cdn.staticfile.org/respond.js/1.4.2/respond-proxy.html" id="respond-proxy" rel="respond-proxy" />
<link href="/js/respond.proxy.gif" id="respond-redirect" rel="respond-redirect" />
<script src="/js/respond.proxy.js"></script>
   <script src="http://cdn.bootcss.com/selectivizr/1.0.2/selectivizr-min.js"></script>
<![endif]-->
<script type="text/javascript">
function loadjs(c,d){var a=document.createElement("script");a.async=!0;a.type="text/javascript";a.src=c;a.charset=d||"gbk";(document.getElementsByTagName("HEAD")[0]||document.getElementsByTagName("BODY")[0]).appendChild(a)};
var _protocol = (("https:" == document.location.protocol) ? " https://" : " http://");
var _js2load = [];
</script>

</head>
<body>
      <header id="header" class="container"><nav id="main-nav" class="navbar navbar-default navbar-fixed-top " role="navigation">
  <div class="container">
    <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
      <span class="sr-only">Toggle navigation</span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="/">It so life</a>
    </div>
    <div  class="collapse navbar-collapse">
      <ul  class="nav navbar-nav">
  
        <li><a href="/" title="Home">Home</a></li>      
        <li><a href="/about/" title="About">About</a></li>      
        <li><a href="/archives/" title="Archives">Archives</a></li>      
      <li class='dropdown'>
        <a class='dropdown-toggle' data-toggle='dropdown' href='#'>website<b class='caret'></b></a>
        <ul class='dropdown-menu pure-menu-selected'>
    
          <li><a href="//groups.google.com/forum/#!forum/pongba" title="TopLanguage">TopLanguage</a></li>    
          <li><a href="//itpub.net/" title="ITPub">ITPub</a></li>    
          <li><a href="//blog.jobbole.com/" title="Bole">Bole</a></li>    
          <li><a href="//nosql-database.org/" title="nosql">nosql</a></li>    
          <li><a href="//gitimmersion.googol.im/" title="Git">Git</a></li>    
        </ul>
      </li>
    
      </ul>
      <ul class="nav navbar-nav navbar-right">
      
        <li><a href="/atom.xml">RSS</a></li>
      
      
        <li><a href="https://twitter.com/robinchia">twitter</a></li>
      
      
      
      
        <li><a href="https://github.com/robinchia">github</a></li>
      
      </ul>
    </div>
  </div>
</nav>
<div class="clearfix"></div>
</header>
  <div id='content' class="container">
     <div class="page-header-wrapper">
      <!--[if lt IE 9]><div class="alert alert-warning alert-dismissable"><button type="button" class="close" data-dismiss="alert" aria-hidden="true">&times;</button><strong>提示:</strong>您的浏览器版本太低了,建议升级到 <strong><a href="http://windows.microsoft.com/zh-cn/internet-explorer/download-ie" title="IE9">IE9</a></strong> 以上,本站使用<a href="https://www.google.com/intl/zh-CN/chrome/">Chrome浏览器</a>可以获得最好的显示效果.</div><![endif]-->
      <div class="page-header"><h1 align="center"><big>It so life</big> </h1>
        <h5 align="center"><big>love as life</big></h5>
      </div>
     </div>
     <div class="row">
       <div id="main-col" class="alignleft col-sx-12 col-sm-8 col-md-9 col-lg-9">
      <section id='header_widget'></section>
          <div id="wrapper"><article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/03/2014-02-03--{技术}{多线程}实施并行编程的五大障碍/">{技术}{多线程}实施并行编程的五大障碍</a></h1>
      
        <span>Posted on<time datetime="2014-02-03T03:24:29.000Z"> <a href="/2014/02/03/2014-02-03--{技术}{多线程}实施并行编程的五大障碍/">feb. 3 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-">{技术}{多线程}实施并行编程的五大障碍</h1>
<p>要使用 Google·网上论坛讨论区，请在您的浏览器设置中启用 JavaScript，然后刷新该网页。   <plaintext/><xmp>.</p>
<ol>
<li><a href="https://plus.google.com/?gpsrc=ogpy0&amp;tab=gX" target="_blank">+你</a></li>
<li><a href="http://www.google.com/webhp?hl=zh-CN&amp;tab=gw" target="_blank">搜索</a></li>
<li><a href="http://www.google.com/imghp?hl=zh-CN&amp;tab=gi" target="_blank">图片</a></li>
<li><a href="https://maps.google.com/maps?hl=zh-CN&amp;tab=gl" target="_blank">地图</a></li>
<li><a href="https://play.google.com/?hl=zh-CN&amp;tab=g8" target="_blank">Play</a></li>
<li><a href="https://www.youtube.com/?tab=g1" target="_blank">YouTube</a></li>
<li><a href="https://news.google.com/nwshp?hl=zh-CN&amp;tab=gn" target="_blank">新闻</a></li>
<li><a href="https://mail.google.com/mail/?tab=gm" target="_blank">Gmail</a></li>
<li><a href="https://drive.google.com/?tab=go" target="_blank">云端硬盘</a></li>
<li><a href="https://www.google.com/calendar?tab=gc" target="_blank">日历</a></li>
<li><p><a href="http://www.google.com/intl/zh-CN/options/" target="_blank">更多</a></p>
</li>
<li><p><a href="https://translate.google.com/?hl=zh-CN&amp;tab=gT" target="_blank">翻译</a></p>
</li>
<li><a href="http://www.google.com/mobile/?hl=zh-CN&amp;tab=gD" target="_blank">移动</a></li>
<li><a href="http://books.google.com/bkshp?hl=zh-CN&amp;tab=gp" target="_blank">图书</a></li>
<li><a href="https://wallet.google.com/manage/?tab=ga" target="_blank">电子钱包</a></li>
<li><a href="https://www.blogger.com/?tab=gj" target="_blank">Blogger</a></li>
<li><a href="https://www.google.com/finance?tab=ge" target="_blank">财经</a></li>
<li><a href="https://plus.google.com/photos?tab=gq" target="_blank">相册</a></li>
<li><a href="http://video.google.com/?hl=zh-CN&amp;tab=gv" target="_blank">视频</a>
1.</li>
<li><a href="http://www.google.com/intl/zh-CN/options/" target="_blank">更多</a></li>
</ol>
<p><a href="https://groups.google.com/d/overview" title="Google 网上论坛"></a></p>
<p>隐藏字段搜索论坛或帖子</p>
<p><img src="" alt=""></p>
<h2 id="account-options">Account Options</h2>
<p>1.</p>
<ol>
<li><a href="https://www.google.com/a/UniversalLogin?continue=https%3A%2F%2Fgroups.google.com%2Fd%2Ftopic%2Fpongba%2FBPGNU3OJZos&amp;hl=zh-CN&amp;service=groups2&amp;hd=default" target="_blank">登录</a><h2 id="-"><a href="">网上论坛</a></h2>
</li>
</ol>
<p><img src="" alt=""><img src="" alt="">第  个，共  个（ 个未读）</p>
<p><img src="" alt="">
<img src="" alt=""></p>
<p><img src="" alt=""></p>
<p><img src="" alt=""></p>
<p><a href="">首页</a></p>
<p>导入预定义搜索，将它们添加到您保存的搜索结果中。</p>
<p>点击论坛的星标即可收藏它
[0</p>
<h3 id="-">最近看过的论坛</h3>
<p>]()</p>
<p><a href=""></a></p>
<p><a href="">0  TopLanguage</a></p>
<p>[0</p>
<h3 id="-">最近的搜索</h3>
<p>]()</p>
<p><a href=""></a>
[0</p>
<h3 id="-">最近发过帖的论坛</h3>
<p>]()</p>
<p><a href=""></a></p>
<p>请<a href="https://www.google.com/a/UniversalLogin?continue=https%3A%2F%2Fgroups.google.com%2Fd%2Ftopic%2Fpongba%2FBPGNU3OJZos&amp;hl=zh-CN&amp;service=groups2&amp;hd=default" target="_blank">登录</a>或开始浏览，以整理您的论坛并查看最近的项目。</p>
<p>©2013 Google
<a href="http://www.google.com/intl/zh-CN/policies/privacy/" target="_blank">隐私权政策</a>  -  <a href="http://www.google.com/intl/zh-CN/policies/terms/" target="_blank">服务条款</a>  -  <a href="http://www.google.com/" target="_blank">Google 首页</a></p>
<p><a href=""></a> <a href=""></a> <a href="">TopLanguage</a> › 由于长期没有活动，本主题已不再开放新回复。如果您要发帖，请在上方搜索更新的主题或发布新问题。 {技术}{多线程}实施并行编程的五大障碍</p>
<p>此主题和其他讨论重复。   <a href=""></a>
系统将您从重复的主题重定向到这里。   <a href=""></a></p>
<p>24 名作者发布了 95 个帖子</p>
<p><img src="" alt="">
上一页 <a href="">上一页</a>  </p>
<p>第 <strong>1</strong> 页
  下一页 <a href="">下一页</a></p>
<p><img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问“什么是实施并行编程的最大障
碍”时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看
<a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/" target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/</a></a>
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是“专家”们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了“编译指导”、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说“在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶……你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的”，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：“你觉得并行编程容易么？”，十有八九会说“我觉得很难”。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点“教育”有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。
<a href="">显示删减掉的内容</a></p>
</li>
</ol>
<p><img src="" alt=""> 机械唯物主义 : linjunhalida <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>恩恩，有些事情还是没有并行的必要。等光处理器出来就好了。
2010/3/22 Guancheng Chen <a href="&#109;&#x61;&#x69;&#x6c;&#116;&#x6f;&#x3a;&#91;&#x63;&#x68;&#101;&#110;&#103;&#x75;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#46;&#99;&#x6f;&#109;&#x5d;&#x28;&#41;">&#91;&#x63;&#x68;&#101;&#110;&#103;&#x75;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#46;&#99;&#x6f;&#109;&#x5d;&#x28;&#41;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问“什么是实施并行编程的最大障
碍”时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。
( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看
<a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/" target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/</a></a>
)</p>
<ol>
<li>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</li>
<li>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是“专家”们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了“编译指导”、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。
可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说“在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶……你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的”，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：“你觉得并行编程容易么？”，十有八九会说“我觉得很难”。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</li>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？
(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx
总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点“教育”有很大关系了。</li>
<li>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</li>
<li>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> 陨落雕 <img src="" alt=""></li>
</ol>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>呃，我想的障碍是: 1. 类C语言的统治地位; 2. 内存带宽不够; 3. 误导性宣传;</p>
<p>On Mar 21, 7:37 pm, Guancheng Chen <a href="&#x6d;&#97;&#105;&#108;&#116;&#x6f;&#58;&#x5b;&#99;&#104;&#x65;&#110;&#103;&#117;&#x61;&#x6e;&#99;&#x68;&#46;&#x2e;&#x2e;&#x40;&#x67;&#109;&#x61;&#x69;&#108;&#46;&#x63;&#111;&#109;&#93;&#40;&#x29;">&#x5b;&#99;&#104;&#x65;&#110;&#103;&#117;&#x61;&#x6e;&#99;&#x68;&#46;&#x2e;&#x2e;&#x40;&#x67;&#109;&#x61;&#x69;&#108;&#46;&#x63;&#111;&#109;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看<a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..</p>
<p>)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。</p>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<blockquote>
<p>尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。
<a href="">显示删减掉的内容</a></p>
</li>
</ol>
</blockquote>
<p><img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>可是按现在的趋势，多核一定会在光处理器之前成为主流啊</p>
<p>On 3月22日, 上午12时42分, 机械唯物主义 : linjunhalida <a href="&#109;&#x61;&#x69;&#108;&#x74;&#x6f;&#x3a;&#91;&#x6c;&#x69;&#110;&#106;&#x75;&#x6e;&#104;&#x61;&#x6c;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#109;&#x61;&#105;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#93;&#40;&#x29;">&#91;&#x6c;&#x69;&#110;&#106;&#x75;&#x6e;&#104;&#x61;&#x6c;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#109;&#x61;&#105;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#93;&#40;&#x29;</a>
wrote:</p>
<blockquote>
<p>恩恩，有些事情还是没有并行的必要。等光处理器出来就好了。</p>
<p>2010/3/22 Guancheng Chen <a href="&#109;&#x61;&#105;&#x6c;&#x74;&#111;&#x3a;&#91;&#99;&#104;&#x65;&#110;&#103;&#x75;&#x61;&#x6e;&#x63;&#x68;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#109;&#x61;&#x69;&#108;&#46;&#99;&#111;&#109;&#93;&#40;&#41;">&#91;&#99;&#104;&#x65;&#110;&#103;&#x75;&#x61;&#x6e;&#x63;&#x68;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#109;&#x61;&#x69;&#108;&#46;&#99;&#111;&#109;&#93;&#40;&#41;</a></p>
</blockquote>
<p>&gt;
&gt;
&gt;</p>
<blockquote>
<blockquote>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问“什么是实施并行编程的最大障
碍”时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..</p>
</blockquote>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<blockquote>
<blockquote>
<p>)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是“专家”们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了“编译指导”、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说“在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶……你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的”，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：“你觉得并行编程容易么？”，十有八九会说“我觉得很难”。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点“教育”有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。</p>
</li>
</ol>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
</blockquote>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<ol>
<li>C语言可以使用pthread等库实现并行化，C++ JAVA等已经会即将支持多线程 所以语言能实现并行化 只是难易问题</li>
<li>是指Shared memory模型，多核共享一条内存总线所以造成带宽问题么？这确实是个问题，不过我感觉硬件商家会负责为你带来越来越多的带
宽，而程序员的任务只是合理的利用好这些给定的带宽</li>
<li>能具体说说哪些误导宣传么？</li>
</ol>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>On 3月22日, 上午1时46分, 陨落雕 <a href="&#x6d;&#97;&#105;&#x6c;&#116;&#x6f;&#58;&#91;&#x67;&#x65;&#x6f;&#46;&#46;&#x2e;&#x2e;&#64;&#103;&#x6d;&#97;&#105;&#x6c;&#46;&#99;&#111;&#109;&#93;&#x28;&#x29;">&#91;&#x67;&#x65;&#x6f;&#46;&#46;&#x2e;&#x2e;&#64;&#103;&#x6d;&#97;&#105;&#x6c;&#46;&#99;&#111;&#109;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>呃，我想的障碍是: 1. 类C语言的统治地位; 2. 内存带宽不够; 3. 误导性宣传;</p>
<p>On Mar 21, 7:37 pm, Guancheng Chen <a href="&#x6d;&#97;&#105;&#x6c;&#x74;&#x6f;&#x3a;&#91;&#x63;&#x68;&#x65;&#x6e;&#x67;&#117;&#97;&#x6e;&#x63;&#104;&#46;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#97;&#x69;&#108;&#x2e;&#99;&#111;&#109;&#x5d;&#x28;&#41;">&#91;&#x63;&#x68;&#x65;&#x6e;&#x67;&#117;&#97;&#x6e;&#x63;&#104;&#46;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#97;&#x69;&#108;&#x2e;&#99;&#111;&#109;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看<a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。
<a href="">显示删减掉的内容</a></p>
</li>
</ol>
</blockquote>
</blockquote>
<p><img src="" alt=""> Jeffrey Zhao <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是“抽象”这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上……我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog: <a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter: <a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p><strong>From:</strong> <a href="&quot;chenguancheng@gmail.com&quot;">Guancheng Chen</a></p>
<p><strong>Sent:</strong> Monday, March 22, 2010 7:37 AM
<strong>To:</strong> <a href="&quot;pongba@googlegroups.com&quot;">TopLanguage</a></p>
<p><strong>Subject:</strong> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问“什么是实施并行编程的最大障
碍”时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。
( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看
<a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/" target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/</a></a>
)</p>
<ol>
<li>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</li>
<li>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是“专家”们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了“编译指导”、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。
可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说“在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶……你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的”，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：“你觉得并行编程容易么？”，十有八九会说“我觉得很难”。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</li>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？
(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx
总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点“教育”有很大关系了。</li>
<li>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</li>
<li>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> tinyfool <img src="" alt=""></li>
</ol>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？
还有支持显卡计算的OpenCL也是无比强大啊。
2010/3/22 Jeffrey Zhao <a href="&#109;&#x61;&#105;&#108;&#x74;&#x6f;&#x3a;&#91;&#x6a;&#x65;&#x2e;&#x2e;&#x2e;&#64;&#x6c;&#105;&#x76;&#x65;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#x28;&#41;">&#91;&#x6a;&#x65;&#x2e;&#x2e;&#x2e;&#64;&#x6c;&#105;&#x76;&#x65;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#x28;&#41;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是“抽象”这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上……我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog: <a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter: <a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p><strong>From:</strong> <a href="&quot;chenguancheng@gmail.com&quot;">Guancheng Chen</a></p>
<p><strong>Sent:</strong> Monday, March 22, 2010 7:37 AM
<strong>To:</strong> <a href="&quot;pongba@googlegroups.com&quot;">TopLanguage</a></p>
<p><strong>Subject:</strong> [TL] {技术}{多线程}实施并行编程的五大障碍
近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问“什么是实施并行编程的最大障
碍”时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。
( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看
<a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/" target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/</a></a>
)</p>
<ol>
<li>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</li>
<li>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是“专家”们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了“编译指导”、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。
可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说“在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶……你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的”，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：“你觉得并行编程容易么？”，十有八九会说“我觉得很难”。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</li>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？
(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx
总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点“教育”有很大关系了。</li>
<li>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</li>
<li>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</li>
</ol>
<h2 id="to-unsubscribe-from-this-group-send-email-to-pongba-unsubscribegooglegroups-com-http-unsubscribegooglegroups-com-or-reply-to-this-email-with-the-words-remove-me-as-the-subject-">To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</h2>
<p>Tinyfool的开发日记 <a href="http://www.tinydust.net/dev/" target="_blank"><a href="http://www.tinydust.net/dev/">http://www.tinydust.net/dev/</a></a>
代码中国网 <a href="http://www.codechina.org/" target="_blank"><a href="http://www.codechina.org">http://www.codechina.org</a></a>
myTwitter: <a href="http://twitter.com/tinyfool" target="_blank"><a href="http://twitter.com/tinyfool">http://twitter.com/tinyfool</a></a>
<a href="">显示删减掉的内容</a></p>
<p><img src="" alt=""> 陨落雕 <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<ol>
<li>这和第二个问题是连起来的，到最后，你还是操作的mutable object，就是无穷无尽的memory consistency的麻烦；</li>
<li>就是这个问题，可惜从来都没跟上来过，光传输是一个可行性，如果实现了的确会改变现在的处境；</li>
<li>说在shared memory模型上内核数量可以无限上去的误导宣传，可惜这个20年前就失败，现在在TOP500上能看到的
supercomputer都是distributed memory model；</li>
</ol>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>On Mar 21, 8:58 pm, Guancheng Chen <a href="&#x6d;&#97;&#x69;&#x6c;&#116;&#x6f;&#58;&#91;&#x63;&#104;&#x65;&#110;&#x67;&#117;&#97;&#x6e;&#x63;&#x68;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#109;&#97;&#x69;&#108;&#x2e;&#x63;&#111;&#109;&#x5d;&#40;&#41;">&#91;&#x63;&#104;&#x65;&#110;&#x67;&#117;&#97;&#x6e;&#x63;&#x68;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#109;&#97;&#x69;&#108;&#x2e;&#x63;&#111;&#109;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<ol>
<li>C语言可以使用pthread等库实现并行化，C++ JAVA等已经会即将支持多线程 所以语言能实现并行化 只是难易问题</li>
<li>是指Shared memory模型，多核共享一条内存总线所以造成带宽问题么？这确实是个问题，不过我感觉硬件商家会负责为你带来越来越多的带
宽，而程序员的任务只是合理的利用好这些给定的带宽</li>
<li>能具体说说哪些误导宣传么？</li>
</ol>
<p>On 3月22日, 上午1时46分, 陨落雕 <a href="&#109;&#x61;&#105;&#108;&#x74;&#111;&#58;&#91;&#103;&#101;&#x6f;&#x2e;&#46;&#46;&#46;&#64;&#103;&#109;&#x61;&#105;&#108;&#46;&#x63;&#111;&#x6d;&#93;&#x28;&#41;">&#91;&#103;&#101;&#x6f;&#x2e;&#46;&#46;&#46;&#64;&#103;&#109;&#x61;&#105;&#108;&#46;&#x63;&#111;&#x6d;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>呃，我想的障碍是: 1. 类C语言的统治地位; 2. 内存带宽不够; 3. 误导性宣传;</p>
<p>On Mar 21, 7:37 pm, Guancheng Chen <a href="&#x6d;&#x61;&#105;&#108;&#116;&#111;&#x3a;&#x5b;&#x63;&#x68;&#x65;&#x6e;&#103;&#x75;&#97;&#110;&#99;&#104;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#109;&#97;&#x69;&#x6c;&#46;&#99;&#111;&#x6d;&#93;&#40;&#41;">&#x5b;&#x63;&#x68;&#x65;&#x6e;&#103;&#x75;&#97;&#110;&#99;&#104;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#109;&#97;&#x69;&#x6c;&#46;&#99;&#111;&#x6d;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看<a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。
<a href="">显示删减掉的内容</a>
<img src="" alt=""> 陨落雕 <img src="" alt=""></p>
</li>
</ol>
</blockquote>
</blockquote>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>OpenCL解决了一大类的问题（每个kernel只需要一小部分数据，类似rasterization的渲染），而且现在他们有动力解决另一大类的问
题（每个小的kernel需要查询大量数据，类似ray tracer的渲染）。但是现在移植还是好困难啊，特别是显存和内存通信时候的
consolation，头疼死了，显存不够要swap out的时候，也很头疼。</p>
<p>On Mar 21, 9:20 pm, Tinyfool <a href="&#x6d;&#97;&#x69;&#x6c;&#x74;&#111;&#x3a;&#x5b;&#116;&#x69;&#x6e;&#x79;&#102;&#x2e;&#46;&#46;&#64;&#x67;&#x6d;&#97;&#105;&#108;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#40;&#x29;">&#x5b;&#116;&#x69;&#x6e;&#x79;&#102;&#x2e;&#46;&#46;&#64;&#x67;&#x6d;&#97;&#105;&#108;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#109;&#x61;&#x69;&#x6c;&#x74;&#111;&#58;&#x5b;&#106;&#101;&#46;&#x2e;&#x2e;&#x40;&#108;&#105;&#118;&#x65;&#x2e;&#x63;&#111;&#109;&#x5d;&#40;&#41;">&#x5b;&#106;&#101;&#46;&#x2e;&#x2e;&#x40;&#108;&#105;&#118;&#x65;&#x2e;&#x63;&#111;&#109;&#x5d;&#40;&#41;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
</blockquote>
</blockquote>
<p>&gt;</p>
<blockquote>
<blockquote>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#109;&#97;&#x69;&#108;&#x74;&#x6f;&#58;&#91;&#99;&#x68;&#101;&#x6e;&#103;&#x75;&#97;&#x6e;&#x63;&#104;&#x2e;&#46;&#x2e;&#x40;&#x67;&#109;&#97;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#41;">&#91;&#99;&#x68;&#101;&#x6e;&#103;&#x75;&#97;&#x6e;&#x63;&#104;&#x2e;&#46;&#x2e;&#x40;&#x67;&#109;&#97;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#41;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#109;&#x61;&#x69;&#x6c;&#x74;&#x6f;&#x3a;&#91;&#x70;&#111;&#110;&#46;&#46;&#46;&#x40;&#103;&#x6f;&#x6f;&#103;&#108;&#101;&#103;&#x72;&#111;&#x75;&#x70;&#x73;&#x2e;&#99;&#111;&#x6d;&#93;&#x28;&#41;">&#91;&#x70;&#111;&#110;&#46;&#46;&#46;&#x40;&#103;&#x6f;&#x6f;&#103;&#108;&#101;&#103;&#x72;&#111;&#x75;&#x70;&#x73;&#x2e;&#99;&#111;&#x6d;&#93;&#x28;&#41;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
</blockquote>
</blockquote>
<p>&gt;</p>
<blockquote>
<blockquote>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..</p>
<p>)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。</p>
</blockquote>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<blockquote>
<blockquote>
<p>尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。</p>
</li>
</ol>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>--
Tinyfool的开发日记<a href="http://www.tinydust.net/dev/" target="_blank"><a href="http://www.tinydust.net/dev/">http://www.tinydust.net/dev/</a></a>
代码中国网<a href="http://www.codechina.org/" target="_blank"><a href="http://www.codechina.org">http://www.codechina.org</a></a>
myTwitter:<a href="http://twitter.com/tinyfool" target="_blank"><a href="http://twitter.com/tinyfool">http://twitter.com/tinyfool</a></a>
<a href="">显示删减掉的内容</a></p>
</blockquote>
<p><img src="" alt=""> Jeffrey Zhao <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>哈哈，广告好，扩展视野，那我继续做广告了……</p>
<p>微软其实很早就在搞Microsoft Accelerator项目，旨在利用DirectX进行计算，.NET项目。 <a href="http://research.microsoft.com/en-us/projects/Accelerator/" title="http://research.microsoft.com/en-us/projects/Accelerator/
CTRL + 单击以下链接"><a href="http://research.microsoft.com/en-us/projects/Accelerator/" target="_blank">http://research.microsoft.com/en-us/projects/Accelerator/</a></a></p>
<p>然后F/#这边由于语言的支持良好，可以设计出丰富的表达式、DSL等Modeling Language，再由框架进行自动并行，解决问题可以很容易（已经2.0了）。</p>
<p>这篇文章是个简单介绍：<a href="http://strangelights.com/blog/archive/2008/09/21/1628.aspx" target="_blank"><a href="http://strangelights.com/blog/archive/2008/09/21/1628.aspx">http://strangelights.com/blog/archive/2008/09/21/1628.aspx</a></a></p>
<p>Microsoft Solver Foundation <a href="http://code.msdn.microsoft.com/solverfoundation" target="_blank"><a href="http://code.msdn.microsoft.com/solverfoundation">http://code.msdn.microsoft.com/solverfoundation</a></a></p>
<p>F/# Optimization Modeling Language Utilizing Microsoft Solver Foundation <a href="http://code.msdn.microsoft.com/solverfoundationfs1" title="http://code.msdn.microsoft.com/solverfoundationfs1
CTRL + 单击以下链接"><a href="http://code.msdn.microsoft.com/solverfoundationfs1" target="_blank">http://code.msdn.microsoft.com/solverfoundationfs1</a></a></p>
<p>现在就等OpenCL如果有标准出来，肯定立马可以跟上个类库，哦耶。</p>
<p>Jeffrey Zhao
Blog: <a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter: <a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a>
<strong>From:</strong> <a href="&quot;tinyfool@gmail.com&quot;">Tinyfool</a></p>
<p><strong>Sent:</strong> Monday, March 22, 2010 9:20 AM
<strong>To:</strong> <a href="&quot;pongba@googlegroups.com&quot;">pon...@googlegroups.com</a></p>
<p><strong>Subject:</strong> Re: [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？
还有支持显卡计算的OpenCL也是无比强大啊。
2010/3/22 Jeffrey Zhao <a href="&#x6d;&#x61;&#x69;&#108;&#x74;&#x6f;&#58;&#x5b;&#x6a;&#101;&#x2e;&#46;&#46;&#x40;&#108;&#105;&#x76;&#101;&#x2e;&#99;&#x6f;&#109;&#x5d;&#x28;&#x29;">&#x5b;&#x6a;&#101;&#x2e;&#46;&#46;&#x40;&#108;&#105;&#x76;&#101;&#x2e;&#99;&#x6f;&#109;&#x5d;&#x28;&#x29;</a>
我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是“抽象”这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上……我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog: <a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter: <a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p><strong>From:</strong> <a href="&quot;chenguancheng@gmail.com&quot;">Guancheng Chen</a></p>
<p><strong>Sent:</strong> Monday, March 22, 2010 7:37 AM
<strong>To:</strong> <a href="&quot;pongba@googlegroups.com&quot;">TopLanguage</a></p>
<p><strong>Subject:</strong> [TL] {技术}{多线程}实施并行编程的五大障碍
近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问“什么是实施并行编程的最大障
碍”时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。
( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看
<a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/" target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/</a></a>
)</p>
<ol>
<li>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</li>
<li>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是“专家”们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了“编译指导”、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。
可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说“在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶……你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的”，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：“你觉得并行编程容易么？”，十有八九会说“我觉得很难”。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</li>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？
(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx
总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点“教育”有很大关系了。</li>
<li>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</li>
<li>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</li>
</ol>
<h2 id="to-unsubscribe-from-this-group-send-email-to-pongba-unsubscribegooglegroups-com-http-unsubscribegooglegroups-com-or-reply-to-this-email-with-the-words-remove-me-as-the-subject-">To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</h2>
<p>Tinyfool的开发日记 <a href="http://www.tinydust.net/dev/" target="_blank"><a href="http://www.tinydust.net/dev/">http://www.tinydust.net/dev/</a></a>
代码中国网 <a href="http://www.codechina.org/" target="_blank"><a href="http://www.codechina.org">http://www.codechina.org</a></a>
myTwitter: <a href="http://twitter.com/tinyfool" target="_blank"><a href="http://twitter.com/tinyfool">http://twitter.com/tinyfool</a></a></p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> tinyfool <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>OpenCL早就出来标准了，而且在做各个平台的实现…</p>
<p>视野啊…
2010/3/22 Jeffrey Zhao <a href="&#x6d;&#97;&#105;&#x6c;&#116;&#111;&#58;&#91;&#x6a;&#101;&#46;&#46;&#x2e;&#x40;&#x6c;&#x69;&#118;&#x65;&#x2e;&#99;&#111;&#x6d;&#x5d;&#x28;&#41;">&#91;&#x6a;&#101;&#46;&#46;&#x2e;&#x40;&#x6c;&#x69;&#118;&#x65;&#x2e;&#99;&#111;&#x6d;&#x5d;&#x28;&#41;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>哈哈，广告好，扩展视野，那我继续做广告了……</p>
<p>微软其实很早就在搞Microsoft Accelerator项目，旨在利用DirectX进行计算，.NET项目。 <a href="http://research.microsoft.com/en-us/projects/Accelerator/" title="http://research.microsoft.com/en-us/projects/Accelerator/
CTRL + 单击以下链接"><a href="http://research.microsoft.com/en-us/projects/Accelerator/" target="_blank">http://research.microsoft.com/en-us/projects/Accelerator/</a></a></p>
<p>然后F/#这边由于语言的支持良好，可以设计出丰富的表达式、DSL等Modeling Language，再由框架进行自动并行，解决问题可以很容易（已经2.0了）。</p>
<p>这篇文章是个简单介绍：<a href="http://strangelights.com/blog/archive/2008/09/21/1628.aspx" target="_blank"><a href="http://strangelights.com/blog/archive/2008/09/21/1628.aspx">http://strangelights.com/blog/archive/2008/09/21/1628.aspx</a></a></p>
<p>Microsoft Solver Foundation <a href="http://code.msdn.microsoft.com/solverfoundation" target="_blank"><a href="http://code.msdn.microsoft.com/solverfoundation">http://code.msdn.microsoft.com/solverfoundation</a></a></p>
<p>F/# Optimization Modeling Language Utilizing Microsoft Solver Foundation <a href="http://code.msdn.microsoft.com/solverfoundationfs1" title="http://code.msdn.microsoft.com/solverfoundationfs1
CTRL + 单击以下链接"><a href="http://code.msdn.microsoft.com/solverfoundationfs1" target="_blank">http://code.msdn.microsoft.com/solverfoundationfs1</a></a></p>
<p>现在就等OpenCL如果有标准出来，肯定立马可以跟上个类库，哦耶。</p>
<p>Jeffrey Zhao
Blog: <a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter: <a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a>
<strong>From:</strong> <a href="&quot;tinyfool@gmail.com&quot;">Tinyfool</a></p>
<p><strong>Sent:</strong> Monday, March 22, 2010 9:20 AM
<strong>To:</strong> <a href="&quot;pongba@googlegroups.com&quot;">pon...@googlegroups.com</a></p>
<p><strong>Subject:</strong> Re: [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？
还有支持显卡计算的OpenCL也是无比强大啊。
2010/3/22 Jeffrey Zhao <a href="&#x6d;&#x61;&#105;&#108;&#x74;&#111;&#58;&#91;&#106;&#x65;&#46;&#46;&#x2e;&#64;&#108;&#105;&#118;&#101;&#46;&#99;&#x6f;&#109;&#x5d;&#x28;&#41;">&#91;&#106;&#x65;&#46;&#46;&#x2e;&#64;&#108;&#105;&#118;&#101;&#46;&#99;&#x6f;&#109;&#x5d;&#x28;&#41;</a>
我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是“抽象”这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上……我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog: <a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter: <a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p><strong>From:</strong> <a href="&quot;chenguancheng@gmail.com&quot;">Guancheng Chen</a></p>
<p><strong>Sent:</strong> Monday, March 22, 2010 7:37 AM
<strong>To:</strong> <a href="&quot;pongba@googlegroups.com&quot;">TopLanguage</a></p>
<p><strong>Subject:</strong> [TL] {技术}{多线程}实施并行编程的五大障碍
近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问“什么是实施并行编程的最大障
碍”时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。
( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看
<a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/" target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/</a></a>
)</p>
<ol>
<li>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</li>
<li>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是“专家”们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了“编译指导”、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。
可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说“在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶……你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的”，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：“你觉得并行编程容易么？”，十有八九会说“我觉得很难”。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</li>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？
(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx
总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点“教育”有很大关系了。</li>
<li>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</li>
<li>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</li>
</ol>
<h2 id="to-unsubscribe-from-this-group-send-email-to-pongba-unsubscribegooglegroups-com-http-unsubscribegooglegroups-com-or-reply-to-this-email-with-the-words-remove-me-as-the-subject-">To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</h2>
<p>Tinyfool的开发日记 <a href="http://www.tinydust.net/dev/" target="_blank"><a href="http://www.tinydust.net/dev/">http://www.tinydust.net/dev/</a></a>
代码中国网 <a href="http://www.codechina.org/" target="_blank"><a href="http://www.codechina.org">http://www.codechina.org</a></a>
myTwitter: <a href="http://twitter.com/tinyfool" target="_blank"><a href="http://twitter.com/tinyfool">http://twitter.com/tinyfool</a></a></p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>--
Tinyfool的开发日记 <a href="http://www.tinydust.net/dev/" target="_blank"><a href="http://www.tinydust.net/dev/">http://www.tinydust.net/dev/</a></a>
代码中国网 <a href="http://www.codechina.org/" target="_blank"><a href="http://www.codechina.org">http://www.codechina.org</a></a>
myTwitter: <a href="http://twitter.com/tinyfool" target="_blank"><a href="http://twitter.com/tinyfool">http://twitter.com/tinyfool</a></a>
<a href="">显示删减掉的内容</a></p>
<p><img src="" alt=""> woo <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>C的pthread太重量级了，我觉得golang的go要好很多，虽然只是试验阶段</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>On 17:58 Sun 21 Mar     , Guancheng Chen wrote:</p>
<blockquote>
<ol>
<li>C语言可以使用pthread等库实现并行化，C++ JAVA等已经会即将支持多线程 所以语言能实现并行化 只是难易问题</li>
<li>是指Shared memory模型，多核共享一条内存总线所以造成带宽问题么？这确实是个问题，不过我感觉硬件商家会负责为你带来越来越多的带
宽，而程序员的任务只是合理的利用好这些给定的带宽</li>
<li>能具体说说哪些误导宣传么？</li>
</ol>
<p>On 3月22日, 上午1时46分, 陨落雕 <a href="&#x6d;&#x61;&#105;&#x6c;&#x74;&#x6f;&#x3a;&#x5b;&#x67;&#101;&#x6f;&#x2e;&#46;&#46;&#x2e;&#x40;&#x67;&#109;&#97;&#105;&#108;&#x2e;&#99;&#x6f;&#109;&#93;&#x28;&#41;">&#x5b;&#x67;&#101;&#x6f;&#x2e;&#46;&#46;&#x2e;&#x40;&#x67;&#109;&#97;&#105;&#108;&#x2e;&#99;&#x6f;&#109;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>呃，我想的障碍是: 1. 类C语言的统治地位; 2. 内存带宽不够; 3. 误导性宣传;</p>
<p>On Mar 21, 7:37 pm, Guancheng Chen <a href="&#x6d;&#97;&#105;&#108;&#116;&#111;&#x3a;&#x5b;&#x63;&#x68;&#x65;&#110;&#x67;&#x75;&#97;&#110;&#99;&#x68;&#46;&#46;&#x2e;&#64;&#x67;&#x6d;&#x61;&#105;&#108;&#46;&#x63;&#x6f;&#109;&#x5d;&#40;&#x29;">&#x5b;&#x63;&#x68;&#x65;&#110;&#x67;&#x75;&#97;&#110;&#99;&#x68;&#46;&#46;&#x2e;&#64;&#x67;&#x6d;&#x61;&#105;&#108;&#46;&#x63;&#x6f;&#109;&#x5d;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看<a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。</p>
</li>
</ol>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> 陨落雕 <img src="" alt=""></p>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>言多必失啊，coalescing是写显存时候的问题，单词也拼错了......</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>On Mar 21, 9:33 pm, 陨落雕 <a href="&#109;&#x61;&#x69;&#108;&#116;&#111;&#x3a;&#91;&#103;&#x65;&#x6f;&#46;&#x2e;&#46;&#46;&#64;&#103;&#109;&#x61;&#105;&#x6c;&#46;&#x63;&#x6f;&#109;&#x5d;&#x28;&#x29;">&#91;&#103;&#x65;&#x6f;&#46;&#x2e;&#46;&#46;&#64;&#103;&#109;&#x61;&#105;&#x6c;&#46;&#x63;&#x6f;&#109;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>OpenCL解决了一大类的问题（每个kernel只需要一小部分数据，类似rasterization的渲染），而且现在他们有动力解决另一大类的问
题（每个小的kernel需要查询大量数据，类似ray tracer的渲染）。但是现在移植还是好困难啊，特别是显存和内存通信时候的
consolation，头疼死了，显存不够要swap out的时候，也很头疼。</p>
<p>On Mar 21, 9:20 pm, Tinyfool <a href="&#109;&#x61;&#x69;&#x6c;&#116;&#x6f;&#58;&#x5b;&#x74;&#x69;&#110;&#x79;&#x66;&#46;&#46;&#x2e;&#64;&#103;&#109;&#x61;&#x69;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#x29;">&#x5b;&#x74;&#x69;&#110;&#x79;&#x66;&#46;&#46;&#x2e;&#64;&#103;&#109;&#x61;&#x69;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#109;&#97;&#105;&#x6c;&#116;&#x6f;&#58;&#x5b;&#x6a;&#101;&#x2e;&#46;&#x2e;&#x40;&#x6c;&#105;&#x76;&#x65;&#46;&#99;&#111;&#x6d;&#93;&#40;&#x29;">&#x5b;&#x6a;&#101;&#x2e;&#46;&#x2e;&#x40;&#x6c;&#105;&#x76;&#x65;&#46;&#99;&#111;&#x6d;&#93;&#40;&#x29;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#109;&#x61;&#x69;&#108;&#116;&#x6f;&#x3a;&#x5b;&#x63;&#x68;&#101;&#x6e;&#x67;&#117;&#97;&#x6e;&#x63;&#104;&#46;&#x2e;&#46;&#x40;&#103;&#x6d;&#x61;&#x69;&#108;&#x2e;&#99;&#x6f;&#109;&#x5d;&#40;&#41;">&#x5b;&#x63;&#x68;&#101;&#x6e;&#x67;&#117;&#97;&#x6e;&#x63;&#104;&#46;&#x2e;&#46;&#x40;&#103;&#x6d;&#x61;&#x69;&#108;&#x2e;&#99;&#x6f;&#109;&#x5d;&#40;&#41;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#x6d;&#x61;&#105;&#x6c;&#116;&#111;&#58;&#x5b;&#112;&#x6f;&#110;&#46;&#46;&#46;&#x40;&#x67;&#x6f;&#x6f;&#x67;&#108;&#101;&#103;&#x72;&#111;&#117;&#112;&#115;&#46;&#99;&#111;&#x6d;&#93;&#x28;&#x29;">&#x5b;&#112;&#x6f;&#110;&#46;&#46;&#46;&#x40;&#x67;&#x6f;&#x6f;&#x67;&#108;&#101;&#103;&#x72;&#111;&#117;&#112;&#115;&#46;&#99;&#111;&#x6d;&#93;&#x28;&#x29;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。</p>
</li>
</ol>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>--
Tinyfool的开发日记<a href="http://www.tinydust.net/dev/" target="_blank"><a href="http://www.tinydust.net/dev/">http://www.tinydust.net/dev/</a></a></p>
</blockquote>
<p>...</p>
<p>read more &gt;&gt;
<a href="">显示删减掉的内容</a></p>
</blockquote>
<p><img src="" alt=""> Jeffrey Zhao <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>是嘛，我记得是提交了标准还在审核。</p>
<p>好吧，我去查了一下果然在08年12月1.0 Stable release了。</p>
<p>Jeffrey Zhao
Blog: <a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter: <a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a>
<strong>From:</strong> <a href="&quot;tinyfool@gmail.com&quot;">Tinyfool</a></p>
<p><strong>Sent:</strong> Monday, March 22, 2010 9:46 AM</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p><strong>To:</strong> <a href="&quot;pongba@googlegroups.com&quot;">pon...@googlegroups.com</a></p>
<p><strong>Subject:</strong> Re: [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>OpenCL早就出来标准了，而且在做各个平台的实现…</p>
<p>视野啊…
2010/3/22 Jeffrey Zhao <a href="&#109;&#97;&#x69;&#x6c;&#x74;&#x6f;&#58;&#x5b;&#x6a;&#x65;&#46;&#x2e;&#46;&#x40;&#108;&#x69;&#x76;&#101;&#46;&#x63;&#111;&#x6d;&#x5d;&#40;&#41;">&#x5b;&#x6a;&#x65;&#46;&#x2e;&#46;&#x40;&#108;&#x69;&#x76;&#101;&#46;&#x63;&#111;&#x6d;&#x5d;&#40;&#41;</a>
哈哈，广告好，扩展视野，那我继续做广告了……</p>
<p>微软其实很早就在搞Microsoft Accelerator项目，旨在利用DirectX进行计算，.NET项目。 <a href="http://research.microsoft.com/en-us/projects/Accelerator/" title="http://research.microsoft.com/en-us/projects/Accelerator/
CTRL + 单击以下链接"><a href="http://research.microsoft.com/en-us/projects/Accelerator/" target="_blank">http://research.microsoft.com/en-us/projects/Accelerator/</a></a></p>
<p>然后F/#这边由于语言的支持良好，可以设计出丰富的表达式、DSL等Modeling Language，再由框架进行自动并行，解决问题可以很容易（已经2.0了）。</p>
<p>这篇文章是个简单介绍：<a href="http://strangelights.com/blog/archive/2008/09/21/1628.aspx" title="http://strangelights.com/blog/archive/2008/09/21/1628.aspx
CTRL + 单击以下链接"><a href="http://strangelights.com/blog/archive/2008/09/21/1628.aspx" target="_blank">http://strangelights.com/blog/archive/2008/09/21/1628.aspx</a></a></p>
<p>Microsoft Solver Foundation <a href="http://code.msdn.microsoft.com/solverfoundation" title="http://code.msdn.microsoft.com/solverfoundation
CTRL + 单击以下链接"><a href="http://code.msdn.microsoft.com/solverfoundation" target="_blank">http://code.msdn.microsoft.com/solverfoundation</a></a></p>
<p>F/# Optimization Modeling Language Utilizing Microsoft Solver Foundation <a href="http://code.msdn.microsoft.com/solverfoundationfs1" title="http://code.msdn.microsoft.com/solverfoundationfs1
CTRL + 单击以下链接"><a href="http://code.msdn.microsoft.com/solverfoundationfs1" target="_blank">http://code.msdn.microsoft.com/solverfoundationfs1</a></a></p>
<p>现在就等OpenCL如果有标准出来，肯定立马可以跟上个类库，哦耶。</p>
<p>Jeffrey Zhao
Blog: <a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter: <a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a>
<strong>From:</strong> <a href="&quot;tinyfool@gmail.com&quot;">Tinyfool</a></p>
<p><strong>Sent:</strong> Monday, March 22, 2010 9:20 AM
<strong>To:</strong> <a href="&quot;pongba@googlegroups.com&quot;">pon...@googlegroups.com</a></p>
<p><strong>Subject:</strong> Re: [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？
还有支持显卡计算的OpenCL也是无比强大啊。
2010/3/22 Jeffrey Zhao <a href="&#x6d;&#97;&#x69;&#x6c;&#x74;&#111;&#58;&#x5b;&#106;&#101;&#x2e;&#46;&#x2e;&#64;&#x6c;&#105;&#x76;&#x65;&#46;&#x63;&#111;&#x6d;&#93;&#40;&#41;">&#x5b;&#106;&#101;&#x2e;&#46;&#x2e;&#64;&#x6c;&#105;&#x76;&#x65;&#46;&#x63;&#111;&#x6d;&#93;&#40;&#41;</a>
我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是“抽象”这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上……我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog: <a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter: <a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p><strong>From:</strong> <a href="&quot;chenguancheng@gmail.com&quot;">Guancheng Chen</a></p>
<p><strong>Sent:</strong> Monday, March 22, 2010 7:37 AM
<strong>To:</strong> <a href="&quot;pongba@googlegroups.com&quot;">TopLanguage</a></p>
<p><strong>Subject:</strong> [TL] {技术}{多线程}实施并行编程的五大障碍
近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问“什么是实施并行编程的最大障
碍”时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。
( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看
<a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/" target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/</a></a>
)</p>
<ol>
<li>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</li>
<li>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是“专家”们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了“编译指导”、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。
可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说“在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶……你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的”，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：“你觉得并行编程容易么？”，十有八九会说“我觉得很难”。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</li>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？
(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx
总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点“教育”有很大关系了。</li>
<li>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</li>
<li>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</li>
</ol>
<h2 id="to-unsubscribe-from-this-group-send-email-to-pongba-unsubscribegooglegroups-com-http-unsubscribegooglegroups-com-or-reply-to-this-email-with-the-words-remove-me-as-the-subject-">To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</h2>
<p>Tinyfool的开发日记 <a href="http://www.tinydust.net/dev/" target="_blank"><a href="http://www.tinydust.net/dev/">http://www.tinydust.net/dev/</a></a>
代码中国网 <a href="http://www.codechina.org/" target="_blank"><a href="http://www.codechina.org">http://www.codechina.org</a></a>
myTwitter: <a href="http://twitter.com/tinyfool" target="_blank"><a href="http://twitter.com/tinyfool">http://twitter.com/tinyfool</a></a></p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<h2 id="to-unsubscribe-from-this-group-send-email-to-pongba-unsubscribegooglegroups-com-http-unsubscribegooglegroups-com-or-reply-to-this-email-with-the-words-remove-me-as-the-subject-">To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</h2>
<p>Tinyfool的开发日记 <a href="http://www.tinydust.net/dev/" target="_blank"><a href="http://www.tinydust.net/dev/">http://www.tinydust.net/dev/</a></a>
代码中国网 <a href="http://www.codechina.org/" target="_blank"><a href="http://www.codechina.org">http://www.codechina.org</a></a>
myTwitter: <a href="http://twitter.com/tinyfool" target="_blank"><a href="http://twitter.com/tinyfool">http://twitter.com/tinyfool</a></a></p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> changsheng <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>个人觉得最大障碍在工具上.</p>
<p>并行学术上研究得不少, 主要在算法和模型上. 工程上的工具, 多是自串行程序来设计的, 弄得复杂不堪. 并行需要语言和库两级支持, Pthreads 和 MPI 仅从库上入手, 让程序员处理各种重复且复杂的分发, 并发锁等. OpenMP好一些, 可惜目前只支持线程并行.
用 ErLang 等将并行设计在语言里的来做并行会容易得多, 得易于面向消息传递的隔离模型, 程序稳定易写. 模型和语言的性能是一个问题, 主要的问题还在用的人和实际并行项目不多.</p>
<p>调试工具就更少了. 有少数商业化的工具.
当然, 我是将可维护性归结为语言工具太差.</p>
<pre><code>                                                 Changsheng Jiang
</code></pre><p>2010/3/22 Guancheng Chen <a href="&#109;&#97;&#x69;&#108;&#116;&#x6f;&#58;&#91;&#x63;&#x68;&#101;&#x6e;&#103;&#x75;&#46;&#46;&#x2e;&#64;&#103;&#109;&#x61;&#x69;&#x6c;&#x2e;&#99;&#111;&#x6d;&#x5d;&#40;&#41;">&#91;&#x63;&#x68;&#101;&#x6e;&#103;&#x75;&#46;&#46;&#x2e;&#64;&#103;&#109;&#x61;&#x69;&#x6c;&#x2e;&#99;&#111;&#x6d;&#x5d;&#40;&#41;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问“什么是实施并行编程的最大障
碍”时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。
( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看
<a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/" target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/</a></a>
)</p>
<ol>
<li>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</li>
<li>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是“专家”们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了“编译指导”、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。
可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说“在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶……你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的”，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：“你觉得并行编程容易么？”，十有八九会说“我觉得很难”。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</li>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？
(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx
总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点“教育”有很大关系了。</li>
<li>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</li>
<li>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。</li>
</ol>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a></p>
<p><img src="" alt=""> Milo Yip <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>我在等NVidia的Fermi和Nexus，想試做全域照明。
但怕買了Fermi後，機器也只是用來做做翻譯……</p>
<p>在 2010年3月22日上午9:51，Jeffrey Zhao <a href="&#x6d;&#97;&#x69;&#108;&#x74;&#111;&#58;&#x5b;&#x6a;&#101;&#46;&#46;&#x2e;&#x40;&#x6c;&#x69;&#x76;&#101;&#46;&#99;&#x6f;&#x6d;&#93;&#40;&#41;">&#x5b;&#x6a;&#101;&#46;&#46;&#x2e;&#x40;&#x6c;&#x69;&#x76;&#101;&#46;&#99;&#x6f;&#x6d;&#93;&#40;&#41;</a> 寫道：</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<blockquote>
<p>是嘛，我记得是提交了标准还在审核。</p>
<p>好吧，我去查了一下果然在08年12月1.0 Stable release了。</p>
<p>Jeffrey Zhao
Blog: <a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter: <a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a>
From: Tinyfool
Sent: Monday, March 22, 2010 9:46 AM
To: <a href="">pon...@googlegroups.com</a>
Subject: Re: [TL] {技术}{多线程}实施并行编程的五大障碍
OpenCL早就出来标准了，而且在做各个平台的实现…
视野啊…</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#x6d;&#97;&#x69;&#x6c;&#116;&#111;&#58;&#x5b;&#x6a;&#101;&#x2e;&#46;&#x2e;&#64;&#x6c;&#105;&#x76;&#101;&#46;&#99;&#111;&#x6d;&#93;&#x28;&#41;">&#x5b;&#x6a;&#101;&#x2e;&#46;&#x2e;&#64;&#x6c;&#105;&#x76;&#101;&#46;&#99;&#111;&#x6d;&#93;&#x28;&#41;</a>
&gt;</p>
<blockquote>
<p>哈哈，广告好，扩展视野，那我继续做广告了……</p>
<p>微软其实很早就在搞Microsoft Accelerator项目，旨在利用DirectX进行计算，.NET项目。
<a href="http://research.microsoft.com/en-us/projects/Accelerator/" target="_blank"><a href="http://research.microsoft.com/en-us/projects/Accelerator/">http://research.microsoft.com/en-us/projects/Accelerator/</a></a></p>
<p>然后F/#这边由于语言的支持良好，可以设计出丰富的表达式、DSL等Modeling
Language，再由框架进行自动并行，解决问题可以很容易（已经2.0了）。</p>
<p>这篇文章是个简单介绍：<a href="http://strangelights.com/blog/archive/2008/09/21/1628.aspx" target="_blank"><a href="http://strangelights.com/blog/archive/2008/09/21/1628.aspx">http://strangelights.com/blog/archive/2008/09/21/1628.aspx</a></a></p>
<p>Microsoft Solver Foundation
<a href="http://code.msdn.microsoft.com/solverfoundation" target="_blank"><a href="http://code.msdn.microsoft.com/solverfoundation">http://code.msdn.microsoft.com/solverfoundation</a></a></p>
<p>F/# Optimization Modeling Language Utilizing Microsoft Solver Foundation
<a href="http://code.msdn.microsoft.com/solverfoundationfs1" target="_blank"><a href="http://code.msdn.microsoft.com/solverfoundationfs1">http://code.msdn.microsoft.com/solverfoundationfs1</a></a></p>
<p>现在就等OpenCL如果有标准出来，肯定立马可以跟上个类库，哦耶。</p>
<p>Jeffrey Zhao
Blog: <a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter: <a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a>
From: Tinyfool
Sent: Monday, March 22, 2010 9:20 AM
To: <a href="">pon...@googlegroups.com</a>
Subject: Re: [TL] {技术}{多线程}实施并行编程的五大障碍
唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下
Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？
还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#x6d;&#x61;&#x69;&#x6c;&#116;&#x6f;&#58;&#91;&#106;&#x65;&#46;&#46;&#46;&#x40;&#x6c;&#105;&#118;&#x65;&#x2e;&#x63;&#x6f;&#109;&#93;&#40;&#x29;">&#91;&#106;&#x65;&#46;&#46;&#46;&#x40;&#x6c;&#105;&#118;&#x65;&#x2e;&#x63;&#x6f;&#109;&#93;&#40;&#x29;</a>
&gt;</p>
<blockquote>
<p>我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是“抽象”这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上……我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog: <a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter: <a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a>
From: Guancheng Chen
Sent: Monday, March 22, 2010 7:37 AM
To: TopLanguage
Subject: [TL] {技术}{多线程}实施并行编程的五大障碍
近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问“什么是实施并行编程的最大障
碍”时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/" target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/</a></a>
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是“专家”们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了“编译指导”、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说“在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶……你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的”，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：“你觉得并行编程容易么？”，十有八九会说“我觉得很难”。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点“教育”有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。</p>
</li>
</ol>
<p>To unsubscribe from this group, send email to
pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to
pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>--
Tinyfool的开发日记 <a href="http://www.tinydust.net/dev/" target="_blank"><a href="http://www.tinydust.net/dev/">http://www.tinydust.net/dev/</a></a>
代码中国网 <a href="http://www.codechina.org/" target="_blank"><a href="http://www.codechina.org">http://www.codechina.org</a></a>
myTwitter: <a href="http://twitter.com/tinyfool" target="_blank"><a href="http://twitter.com/tinyfool">http://twitter.com/tinyfool</a></a></p>
<p>To unsubscribe from this group, send email to
pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to
pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>--
Tinyfool的开发日记 <a href="http://www.tinydust.net/dev/" target="_blank"><a href="http://www.tinydust.net/dev/">http://www.tinydust.net/dev/</a></a>
代码中国网 <a href="http://www.codechina.org/" target="_blank"><a href="http://www.codechina.org">http://www.codechina.org</a></a>
myTwitter: <a href="http://twitter.com/tinyfool" target="_blank"><a href="http://twitter.com/tinyfool">http://twitter.com/tinyfool</a></a></p>
<p>To unsubscribe from this group, send email to
pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to
pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>--
Milo Yip</p>
<p>Twitter @miloyip
<a href="http://www.cnblogs.com/miloyip/" target="_blank"><a href="http://www.cnblogs.com/miloyip/">http://www.cnblogs.com/miloyip/</a></a>
<a href="http://miloyip.seezone.net/" target="_blank"><a href="http://miloyip.seezone.net/">http://miloyip.seezone.net/</a></a>
<a href="">显示删减掉的内容</a>
<img src="" alt=""> Milo Yip <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>應該是「全局照明」</p>
<p>在 2010年3月22日上午10:20，Milo Yip <a href="&#109;&#x61;&#x69;&#108;&#116;&#111;&#x3a;&#x5b;&#x6d;&#x69;&#108;&#x2e;&#46;&#x2e;&#x40;&#x67;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#109;&#x5d;&#40;&#x29;">&#x5b;&#x6d;&#x69;&#108;&#x2e;&#46;&#x2e;&#x40;&#x67;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#109;&#x5d;&#40;&#x29;</a> 寫道：</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<blockquote>
<p>我在等NVidia的Fermi和Nexus，想試做全域照明。
但怕買了Fermi後，機器也只是用來做做翻譯……</p>
<p>在 2010年3月22日上午9:51，Jeffrey Zhao <a href="&#x6d;&#x61;&#x69;&#x6c;&#116;&#x6f;&#x3a;&#x5b;&#x6a;&#x65;&#x2e;&#46;&#x2e;&#x40;&#108;&#x69;&#x76;&#x65;&#46;&#x63;&#111;&#109;&#93;&#x28;&#41;">&#x5b;&#x6a;&#x65;&#x2e;&#46;&#x2e;&#x40;&#108;&#x69;&#x76;&#x65;&#46;&#x63;&#111;&#109;&#93;&#x28;&#41;</a> 寫道：</p>
<blockquote>
<p>是嘛，我记得是提交了标准还在审核。</p>
<p>好吧，我去查了一下果然在08年12月1.0 Stable release了。</p>
<p>Jeffrey Zhao
Blog: <a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter: <a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a>
From: Tinyfool
Sent: Monday, March 22, 2010 9:46 AM
To: <a href="">pon...@googlegroups.com</a>
Subject: Re: [TL] {技术}{多线程}实施并行编程的五大障碍
OpenCL早就出来标准了，而且在做各个平台的实现…
视野啊…</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#109;&#x61;&#x69;&#108;&#116;&#111;&#x3a;&#91;&#x6a;&#x65;&#x2e;&#46;&#x2e;&#x40;&#x6c;&#x69;&#x76;&#x65;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#40;&#x29;">&#91;&#x6a;&#x65;&#x2e;&#46;&#x2e;&#x40;&#x6c;&#x69;&#x76;&#x65;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#40;&#x29;</a>
&gt;</p>
<blockquote>
<p>哈哈，广告好，扩展视野，那我继续做广告了……</p>
<p>微软其实很早就在搞Microsoft Accelerator项目，旨在利用DirectX进行计算，.NET项目。
<a href="http://research.microsoft.com/en-us/projects/Accelerator/" target="_blank"><a href="http://research.microsoft.com/en-us/projects/Accelerator/">http://research.microsoft.com/en-us/projects/Accelerator/</a></a></p>
<p>然后F/#这边由于语言的支持良好，可以设计出丰富的表达式、DSL等Modeling
Language，再由框架进行自动并行，解决问题可以很容易（已经2.0了）。</p>
<p>这篇文章是个简单介绍：<a href="http://strangelights.com/blog/archive/2008/09/21/1628.aspx" target="_blank"><a href="http://strangelights.com/blog/archive/2008/09/21/1628.aspx">http://strangelights.com/blog/archive/2008/09/21/1628.aspx</a></a></p>
<p>Microsoft Solver Foundation
<a href="http://code.msdn.microsoft.com/solverfoundation" target="_blank"><a href="http://code.msdn.microsoft.com/solverfoundation">http://code.msdn.microsoft.com/solverfoundation</a></a></p>
<p>F/# Optimization Modeling Language Utilizing Microsoft Solver Foundation
<a href="http://code.msdn.microsoft.com/solverfoundationfs1" target="_blank"><a href="http://code.msdn.microsoft.com/solverfoundationfs1">http://code.msdn.microsoft.com/solverfoundationfs1</a></a></p>
<p>现在就等OpenCL如果有标准出来，肯定立马可以跟上个类库，哦耶。</p>
<p>Jeffrey Zhao
Blog: <a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter: <a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a>
From: Tinyfool
Sent: Monday, March 22, 2010 9:20 AM
To: <a href="">pon...@googlegroups.com</a>
Subject: Re: [TL] {技术}{多线程}实施并行编程的五大障碍
唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下
Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？
还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#109;&#x61;&#x69;&#108;&#x74;&#111;&#58;&#91;&#106;&#101;&#46;&#46;&#x2e;&#64;&#108;&#105;&#118;&#x65;&#x2e;&#x63;&#111;&#109;&#x5d;&#40;&#41;">&#91;&#106;&#101;&#46;&#46;&#x2e;&#64;&#108;&#105;&#118;&#x65;&#x2e;&#x63;&#111;&#109;&#x5d;&#40;&#41;</a>
&gt;</p>
<blockquote>
<p>我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是“抽象”这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上……我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog: <a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter: <a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a>
From: Guancheng Chen
Sent: Monday, March 22, 2010 7:37 AM
To: TopLanguage
Subject: [TL] {技术}{多线程}实施并行编程的五大障碍
近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问“什么是实施并行编程的最大障
碍”时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/" target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/</a></a>
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是“专家”们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了“编译指导”、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说“在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶……你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的”，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：“你觉得并行编程容易么？”，十有八九会说“我觉得很难”。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点“教育”有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。</p>
</li>
</ol>
<p>To unsubscribe from this group, send email to
pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to
pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>--
Tinyfool的开发日记 <a href="http://www.tinydust.net/dev/" target="_blank"><a href="http://www.tinydust.net/dev/">http://www.tinydust.net/dev/</a></a>
代码中国网 <a href="http://www.codechina.org/" target="_blank"><a href="http://www.codechina.org">http://www.codechina.org</a></a>
myTwitter: <a href="http://twitter.com/tinyfool" target="_blank"><a href="http://twitter.com/tinyfool">http://twitter.com/tinyfool</a></a></p>
<p>To unsubscribe from this group, send email to
pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to
pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>--
Tinyfool的开发日记 <a href="http://www.tinydust.net/dev/" target="_blank"><a href="http://www.tinydust.net/dev/">http://www.tinydust.net/dev/</a></a>
代码中国网 <a href="http://www.codechina.org/" target="_blank"><a href="http://www.codechina.org">http://www.codechina.org</a></a>
myTwitter: <a href="http://twitter.com/tinyfool" target="_blank"><a href="http://twitter.com/tinyfool">http://twitter.com/tinyfool</a></a></p>
<p>To unsubscribe from this group, send email to
pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to
pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>--
Milo Yip</p>
<p>Twitter @miloyip
<a href="http://www.cnblogs.com/miloyip/" target="_blank"><a href="http://www.cnblogs.com/miloyip/">http://www.cnblogs.com/miloyip/</a></a>
<a href="http://miloyip.seezone.net/" target="_blank"><a href="http://miloyip.seezone.net/">http://miloyip.seezone.net/</a></a></p>
</blockquote>
<p>--
Milo Yip</p>
<p>Twitter @miloyip
<a href="http://www.cnblogs.com/miloyip/" target="_blank"><a href="http://www.cnblogs.com/miloyip/">http://www.cnblogs.com/miloyip/</a></a>
<a href="http://miloyip.seezone.net/" target="_blank"><a href="http://miloyip.seezone.net/">http://miloyip.seezone.net/</a></a>
<a href="">显示删减掉的内容</a></p>
<p><img src="" alt=""> archerzz <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>工具的确是个问题，没有好的工具，很难快速推广。
2010/3/22 Changsheng Jiang <a href="&#109;&#97;&#x69;&#108;&#x74;&#111;&#x3a;&#91;&#106;&#105;&#97;&#x6e;&#x67;&#46;&#46;&#46;&#64;&#x67;&#x6d;&#x61;&#105;&#108;&#46;&#99;&#x6f;&#109;&#x5d;&#x28;&#x29;">&#91;&#106;&#105;&#97;&#x6e;&#x67;&#46;&#46;&#46;&#64;&#x67;&#x6d;&#x61;&#105;&#108;&#46;&#99;&#x6f;&#109;&#x5d;&#x28;&#x29;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>个人觉得最大障碍在工具上.</p>
<p>并行学术上研究得不少, 主要在算法和模型上. 工程上的工具, 多是自串行程序来设计的, 弄得复杂不堪. 并行需要语言和库两级支持, Pthreads 和 MPI 仅从库上入手, 让程序员处理各种重复且复杂的分发, 并发锁等. OpenMP好一些, 可惜目前只支持线程并行.
用 ErLang 等将并行设计在语言里的来做并行会容易得多, 得易于面向消息传递的隔离模型, 程序稳定易写. 模型和语言的性能是一个问题, 主要的问题还在用的人和实际并行项目不多.</p>
<p>调试工具就更少了. 有少数商业化的工具.
当然, 我是将可维护性归结为语言工具太差.</p>
<pre><code>                                                 Changsheng Jiang
</code></pre><p>2010/3/22 Guancheng Chen <a href="&#x6d;&#x61;&#x69;&#108;&#116;&#x6f;&#x3a;&#x5b;&#99;&#x68;&#101;&#110;&#103;&#117;&#x2e;&#46;&#x2e;&#64;&#103;&#x6d;&#97;&#105;&#x6c;&#46;&#99;&#x6f;&#109;&#x5d;&#x28;&#41;">&#x5b;&#99;&#x68;&#101;&#110;&#103;&#117;&#x2e;&#46;&#x2e;&#64;&#103;&#x6d;&#97;&#105;&#x6c;&#46;&#99;&#x6f;&#109;&#x5d;&#x28;&#41;</a></p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问“什么是实施并行编程的最大障
碍”时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。
( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看
<a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/" target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-parallelism/</a></a>
)</p>
<ol>
<li>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</li>
<li>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是“专家”们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了“编译指导”、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。
可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说“在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶……你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的”，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：“你觉得并行编程容易么？”，十有八九会说“我觉得很难”。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</li>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？
(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx
总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点“教育”有很大关系了。</li>
<li>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</li>
<li>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> 陨落雕 <img src="" alt=""></li>
</ol>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>我也想用Fermi来解一个和ray tracer类似的问题，话说NV招了好多搞ray tracer和hpc的大牛。</p>
<p>On Mar 21, 10:20 pm, Milo Yip <a href="&#x6d;&#97;&#x69;&#108;&#116;&#111;&#x3a;&#x5b;&#109;&#105;&#x6c;&#111;&#x2e;&#46;&#x2e;&#64;&#103;&#109;&#x61;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#93;&#x28;&#41;">&#x5b;&#109;&#105;&#x6c;&#111;&#x2e;&#46;&#x2e;&#64;&#103;&#109;&#x61;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>我在等NVidia的Fermi和Nexus，想試做全域照明。
但怕買了Fermi後，機器也只是用來做做翻譯......</p>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>在 2010年3月22日上午9:51，Jeffrey Zhao <a href="&#109;&#97;&#105;&#x6c;&#116;&#111;&#58;&#x5b;&#x6a;&#x65;&#x2e;&#46;&#46;&#64;&#108;&#x69;&#118;&#x65;&#x2e;&#99;&#x6f;&#109;&#93;&#40;&#x29;">&#x5b;&#x6a;&#x65;&#x2e;&#46;&#46;&#64;&#108;&#x69;&#118;&#x65;&#x2e;&#99;&#x6f;&#109;&#93;&#40;&#x29;</a> 寫道：</p>
<blockquote>
<p>是嘛，我记得是提交了标准还在审核。</p>
<p>好吧，我去查了一下果然在08年12月1.0 Stable release了。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a>
From: Tinyfool
Sent: Monday, March 22, 2010 9:46 AM
To: <a href="">pon...@googlegroups.com</a>
Subject: Re: [TL] {技术}{多线程}实施并行编程的五大障碍
OpenCL早就出来标准了，而且在做各个平台的实现...
视野啊...</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#x6d;&#x61;&#105;&#108;&#x74;&#x6f;&#x3a;&#91;&#x6a;&#x65;&#46;&#x2e;&#x2e;&#64;&#108;&#x69;&#x76;&#x65;&#46;&#x63;&#111;&#109;&#93;&#x28;&#41;">&#91;&#x6a;&#x65;&#46;&#x2e;&#x2e;&#64;&#108;&#x69;&#x76;&#x65;&#46;&#x63;&#111;&#109;&#93;&#x28;&#41;</a></p>
<blockquote>
<p>哈哈，广告好，扩展视野，那我继续做广告了......</p>
</blockquote>
</blockquote>
</blockquote>
<p>&gt;</p>
<blockquote>
<blockquote>
<blockquote>
<p>微软其实很早就在搞Microsoft Accelerator项目，旨在利用DirectX进行计算，.NET项目。
<a href="http://research.microsoft.com/en-us/projects/Accelerator/" target="_blank"><a href="http://research.microsoft.com/en-us/projects/Accelerator/">http://research.microsoft.com/en-us/projects/Accelerator/</a></a></p>
<p>然后F/#这边由于语言的支持良好，可以设计出丰富的表达式、DSL等Modeling
Language，再由框架进行自动并行，解决问题可以很容易（已经2.0了）。</p>
<p>这篇文章是个简单介绍：<a href="http://strangelights.com/blog/archive/2008/09/21/1628.aspx" target="_blank"><a href="http://strangelights.com/blog/archive/2008/09/21/1628.aspx">http://strangelights.com/blog/archive/2008/09/21/1628.aspx</a></a></p>
<p>Microsoft Solver Foundation
<a href="http://code.msdn.microsoft.com/solverfoundation" target="_blank"><a href="http://code.msdn.microsoft.com/solverfoundation">http://code.msdn.microsoft.com/solverfoundation</a></a></p>
<p>F/# Optimization Modeling Language Utilizing Microsoft Solver Foundation
<a href="http://code.msdn.microsoft.com/solverfoundationfs1" target="_blank"><a href="http://code.msdn.microsoft.com/solverfoundationfs1">http://code.msdn.microsoft.com/solverfoundationfs1</a></a></p>
<p>现在就等OpenCL如果有标准出来，肯定立马可以跟上个类库，哦耶。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a>
From: Tinyfool
Sent: Monday, March 22, 2010 9:20 AM
To: <a href="">pon...@googlegroups.com</a>
Subject: Re: [TL] {技术}{多线程}实施并行编程的五大障碍
唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下
Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？
还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#109;&#x61;&#x69;&#x6c;&#116;&#111;&#x3a;&#x5b;&#x6a;&#x65;&#46;&#x2e;&#x2e;&#64;&#x6c;&#105;&#x76;&#101;&#46;&#99;&#x6f;&#109;&#x5d;&#40;&#x29;">&#x5b;&#x6a;&#x65;&#46;&#x2e;&#x2e;&#64;&#x6c;&#105;&#x76;&#101;&#46;&#99;&#x6f;&#109;&#x5d;&#40;&#x29;</a></p>
<blockquote>
<p>我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>&gt;</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a>
From: Guancheng Chen
Sent: Monday, March 22, 2010 7:37 AM
To: TopLanguage
Subject: [TL] {技术}{多线程}实施并行编程的五大障碍
近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..</p>
<p>)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。</p>
<p>尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这</li>
</ol>
</blockquote>
</blockquote>
</blockquote>
<p>...</p>
<p>read more &gt;&gt;
<a href="">显示删减掉的内容</a></p>
</blockquote>
<p><img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>微软好像已经推出了跟OpenCL类似的Direct Compute，也能搞GPU CPU混合计算</p>
<p>On 3月22日, 上午2时42分, &quot;Jeffrey Zhao&quot; <a href="&#109;&#x61;&#105;&#108;&#x74;&#111;&#58;&#91;&#106;&#x65;&#46;&#x2e;&#x2e;&#x40;&#x6c;&#x69;&#118;&#x65;&#x2e;&#x63;&#111;&#109;&#93;&#40;&#x29;">&#91;&#106;&#x65;&#46;&#x2e;&#x2e;&#x40;&#x6c;&#x69;&#118;&#x65;&#x2e;&#x63;&#111;&#109;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>哈哈，广告好，扩展视野，那我继续做广告了......</p>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>微软其实很早就在搞Microsoft Accelerator项目，旨在利用DirectX进行计算，.NET项目。<a href="http://research.microsoft.com/en-us/projects/Accelerator/" target="_blank"><a href="http://research.microsoft.com/en-us/projects/Accelerator/">http://research.microsoft.com/en-us/projects/Accelerator/</a></a></p>
<p>然后F/#这边由于语言的支持良好，可以设计出丰富的表达式、DSL等Modeling Language，再由框架进行自动并行，解决问题可以很容易（已经2.0了）。</p>
<p>这篇文章是个简单介绍：<a href="http://strangelights.com/blog/archive/2008/09/21/1628.aspx" target="_blank"><a href="http://strangelights.com/blog/archive/2008/09/21/1628.aspx">http://strangelights.com/blog/archive/2008/09/21/1628.aspx</a></a></p>
<p>Microsoft Solver Foundation<a href="http://[code.msdn.microsoft.com/solverfoundation](http://code.msdn.microsoft.com/solverfoundation" target="_blank">http://[code.msdn.microsoft.com/solverfoundation](http://code.msdn.microsoft.com/solverfoundation</a>)</p>
<p>F/# Optimization Modeling Language Utilizing Microsoft Solver Foundation<a href="http://[code.msdn.microsoft.com/solverfoundationfs1](http://code.msdn.microsoft.com/solverfoundationfs1" target="_blank">http://[code.msdn.microsoft.com/solverfoundationfs1](http://code.msdn.microsoft.com/solverfoundationfs1</a>)</p>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>现在就等OpenCL如果有标准出来，肯定立马可以跟上个类库，哦耶。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p>From: Tinyfool
Sent: Monday, March 22, 2010 9:20 AM
To: <a href="">pon...@googlegroups.com</a>
Subject: Re: [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#109;&#97;&#105;&#108;&#x74;&#111;&#58;&#91;&#106;&#x65;&#x2e;&#x2e;&#x2e;&#64;&#108;&#105;&#x76;&#x65;&#x2e;&#99;&#111;&#109;&#x5d;&#40;&#41;">&#91;&#106;&#x65;&#x2e;&#x2e;&#x2e;&#64;&#108;&#105;&#x76;&#x65;&#x2e;&#99;&#111;&#109;&#x5d;&#40;&#41;</a></p>
<p>  我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>  其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>  例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>  至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>  例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>  Jeffrey Zhao
  Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
  Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p>  From: Guancheng Chen
  Sent: Monday, March 22, 2010 7:37 AM
  To: TopLanguage
  Subject: [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>  近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
  碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
  (fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
  Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
  的看法。</p>
<p>  ( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看
 <a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..</p>
<p>  )</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。</p>
<p>尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
</li>
<li><p>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</p>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
</li>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可...</p>
</li>
</ol>
<p>阅读更多 &gt;&gt;
<a href="">显示删减掉的内容</a>
<img src="" alt=""> 郑伟 <img src="" alt=""></p>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>我觉得 想要并行开发 必须绕开c/c++
2010/3/22 Guancheng Chen <a href="&#x6d;&#x61;&#105;&#108;&#x74;&#x6f;&#58;&#x5b;&#x63;&#104;&#101;&#110;&#x67;&#x75;&#46;&#46;&#46;&#64;&#103;&#109;&#97;&#105;&#108;&#x2e;&#99;&#x6f;&#x6d;&#93;&#40;&#x29;">&#x5b;&#x63;&#104;&#101;&#110;&#x67;&#x75;&#46;&#46;&#46;&#64;&#103;&#109;&#97;&#105;&#108;&#x2e;&#99;&#x6f;&#x6d;&#93;&#40;&#x29;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>微软好像已经推出了跟OpenCL类似的Direct Compute，也能搞GPU CPU混合计算
On 3月22日, 上午2时42分, &quot;Jeffrey Zhao&quot; <a href="&#x6d;&#97;&#105;&#108;&#116;&#x6f;&#x3a;&#91;&#x6a;&#101;&#x2e;&#x2e;&#x2e;&#64;&#108;&#105;&#118;&#x65;&#46;&#x63;&#x6f;&#109;&#x5d;&#x28;&#x29;">&#91;&#x6a;&#101;&#x2e;&#x2e;&#x2e;&#64;&#108;&#105;&#118;&#x65;&#46;&#x63;&#x6f;&#109;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>哈哈，广告好，扩展视野，那我继续做广告了......</p>
<p>微软其实很早就在搞Microsoft Accelerator项目，旨在利用DirectX进行计算，.NET项目。<a href="http://research.microsoft.com/en-us/projects/Accelerator/" target="_blank"><a href="http://research.microsoft.com/en-us/projects/Accelerator/">http://research.microsoft.com/en-us/projects/Accelerator/</a></a></p>
<p>然后F/#这边由于语言的支持良好，可以设计出丰富的表达式、DSL等Modeling Language，再由框架进行自动并行，解决问题可以很容易（已经2.0了）。</p>
<p>这篇文章是个简单介绍：<a href="http://strangelights.com/blog/archive/2008/09/21/1628.aspx" target="_blank"><a href="http://strangelights.com/blog/archive/2008/09/21/1628.aspx">http://strangelights.com/blog/archive/2008/09/21/1628.aspx</a></a></p>
<p>Microsoft Solver Foundation<a href="http://[code.msdn.microsoft.com/solverfoundation](http://code.msdn.microsoft.com/solverfoundation" target="_blank">http://[code.msdn.microsoft.com/solverfoundation](http://code.msdn.microsoft.com/solverfoundation</a>)</p>
<p>F/# Optimization Modeling Language Utilizing Microsoft Solver Foundation<a href="http://[code.msdn.microsoft.com/solverfoundationfs1](http://code.msdn.microsoft.com/solverfoundationfs1" target="_blank">http://[code.msdn.microsoft.com/solverfoundationfs1](http://code.msdn.microsoft.com/solverfoundationfs1</a>)</p>
<p>现在就等OpenCL如果有标准出来，肯定立马可以跟上个类库，哦耶。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p>From: Tinyfool
Sent: Monday, March 22, 2010 9:20 AM
To: <a href="">pon...@googlegroups.com</a>
Subject: Re: [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#109;&#x61;&#x69;&#108;&#x74;&#111;&#x3a;&#x5b;&#106;&#101;&#x2e;&#46;&#46;&#x40;&#108;&#x69;&#x76;&#x65;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#41;">&#x5b;&#106;&#101;&#x2e;&#46;&#46;&#x40;&#108;&#x69;&#x76;&#x65;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#41;</a></p>
<p>  我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>  其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>  例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>  至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>  例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>  Jeffrey Zhao
  Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
  Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p>  From: Guancheng Chen
  Sent: Monday, March 22, 2010 7:37 AM
  To: TopLanguage
  Subject: [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>  近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
  碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
  (fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
  Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
  的看法。</p>
<p>  ( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看
 <a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
  )</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
</li>
<li><p>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</p>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
</li>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维&gt;   护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可...</p>
</li>
</ol>
<p>阅读更多 &gt;&gt;</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a></p>
<p><img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>很有意思的事情是我上次问过一个负责定制OpenCL的哥们，&quot;从商业角度上讲，苹果为什么要自己搞一个新标准？&quot; 他就说那个时候苹果意识到未来这种
通用并行计算平台的重要性，而为了保证最大的商业利益就选择自己重新搞一个新标准而不是跟当时已有CUDA的Nvidia合作，结果现在NV也开始支持
OpenCL，但是他们最新的一本教材里说到&quot;根据我们的经验，学习OpenCL最好的办法是先学CUDA&quot;</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>On 3月22日, 上午6时10分, 陨落雕 <a href="&#109;&#x61;&#105;&#x6c;&#x74;&#111;&#58;&#x5b;&#103;&#101;&#111;&#x2e;&#x2e;&#46;&#x2e;&#x40;&#x67;&#109;&#x61;&#105;&#108;&#x2e;&#x63;&#111;&#109;&#x5d;&#40;&#x29;">&#x5b;&#103;&#101;&#111;&#x2e;&#x2e;&#46;&#x2e;&#x40;&#x67;&#109;&#x61;&#105;&#108;&#x2e;&#x63;&#111;&#109;&#x5d;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>我也想用Fermi来解一个和ray tracer类似的问题，话说NV招了好多搞ray tracer和hpc的大牛。</p>
<p>On Mar 21, 10:20 pm, Milo Yip <a href="&#x6d;&#x61;&#x69;&#108;&#116;&#111;&#x3a;&#91;&#109;&#x69;&#x6c;&#111;&#46;&#46;&#x2e;&#x40;&#103;&#109;&#x61;&#x69;&#x6c;&#46;&#99;&#x6f;&#109;&#x5d;&#x28;&#41;">&#91;&#109;&#x69;&#x6c;&#111;&#46;&#46;&#x2e;&#x40;&#103;&#109;&#x61;&#x69;&#x6c;&#46;&#99;&#x6f;&#109;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>我在等NVidia的Fermi和Nexus，想試做全域照明。
但怕買了Fermi後，機器也只是用來做做翻譯......</p>
<p>在 2010年3月22日上午9:51，Jeffrey Zhao <a href="&#x6d;&#97;&#105;&#108;&#116;&#111;&#x3a;&#91;&#x6a;&#101;&#46;&#46;&#46;&#64;&#108;&#x69;&#118;&#x65;&#46;&#99;&#x6f;&#109;&#x5d;&#40;&#x29;">&#91;&#x6a;&#101;&#46;&#46;&#46;&#64;&#108;&#x69;&#118;&#x65;&#46;&#99;&#x6f;&#109;&#x5d;&#40;&#x29;</a> 寫道：</p>
<blockquote>
<p>是嘛，我记得是提交了标准还在审核。</p>
<p>好吧，我去查了一下果然在08年12月1.0 Stable release了。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a>
From: Tinyfool
Sent: Monday, March 22, 2010 9:46 AM
To: <a href="">pon...@googlegroups.com</a>
Subject: Re: [TL] {技术}{多线程}实施并行编程的五大障碍
OpenCL早就出来标准了，而且在做各个平台的实现...
视野啊...</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#109;&#97;&#105;&#x6c;&#x74;&#x6f;&#58;&#91;&#x6a;&#101;&#46;&#46;&#46;&#64;&#108;&#105;&#x76;&#x65;&#x2e;&#99;&#111;&#109;&#93;&#x28;&#41;">&#91;&#x6a;&#101;&#46;&#46;&#46;&#64;&#108;&#105;&#x76;&#x65;&#x2e;&#99;&#111;&#109;&#93;&#x28;&#41;</a></p>
<blockquote>
<p>哈哈，广告好，扩展视野，那我继续做广告了......</p>
<p>微软其实很早就在搞Microsoft Accelerator项目，旨在利用DirectX进行计算，.NET项目。
<a href="http://research.microsoft.com/en-us/projects/Accelerator/" target="_blank"><a href="http://research.microsoft.com/en-us/projects/Accelerator/">http://research.microsoft.com/en-us/projects/Accelerator/</a></a></p>
<p>然后F/#这边由于语言的支持良好，可以设计出丰富的表达式、DSL等Modeling
Language，再由框架进行自动并行，解决问题可以很容易（已经2.0了）。</p>
<p>这篇文章是个简单介绍：<a href="http://strangelights.com/blog/archive/2008/09/21/1628.aspx" target="_blank"><a href="http://strangelights.com/blog/archive/2008/09/21/1628.aspx">http://strangelights.com/blog/archive/2008/09/21/1628.aspx</a></a></p>
<p>Microsoft Solver Foundation
<a href="http://code.msdn.microsoft.com/solverfoundation" target="_blank"><a href="http://code.msdn.microsoft.com/solverfoundation">http://code.msdn.microsoft.com/solverfoundation</a></a></p>
<p>F/# Optimization Modeling Language Utilizing Microsoft Solver Foundation
<a href="http://code.msdn.microsoft.com/solverfoundationfs1" target="_blank"><a href="http://code.msdn.microsoft.com/solverfoundationfs1">http://code.msdn.microsoft.com/solverfoundationfs1</a></a></p>
<p>现在就等OpenCL如果有标准出来，肯定立马可以跟上个类库，哦耶。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a>
From: Tinyfool
Sent: Monday, March 22, 2010 9:20 AM
To: <a href="">pon...@googlegroups.com</a>
Subject: Re: [TL] {技术}{多线程}实施并行编程的五大障碍
唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下
Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？
还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#x6d;&#x61;&#105;&#108;&#116;&#111;&#x3a;&#x5b;&#106;&#x65;&#46;&#x2e;&#x2e;&#64;&#x6c;&#105;&#x76;&#101;&#46;&#x63;&#x6f;&#x6d;&#93;&#x28;&#41;">&#x5b;&#106;&#x65;&#46;&#x2e;&#x2e;&#64;&#x6c;&#105;&#x76;&#101;&#46;&#x63;&#x6f;&#x6d;&#93;&#x28;&#41;</a></p>
<blockquote>
<p>我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a>
From: Guancheng Chen
Sent: Monday, March 22, 2010 7:37 AM
To: TopLanguage
Subject: [TL] {技术}{多线程}实施并行编程的五大障碍
近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li>对众核的恐惧...</li>
</ol>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>阅读更多 &gt;&gt;
<a href="">显示删减掉的内容</a>
<img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>不知道您觉得现有的工具哪些个最趁手呢？</p>
<p>On 3月22日, 上午3时19分, Changsheng Jiang <a href="&#x6d;&#97;&#105;&#108;&#x74;&#111;&#x3a;&#91;&#x6a;&#x69;&#97;&#x6e;&#x67;&#x7a;&#117;&#111;&#x2e;&#46;&#x2e;&#64;&#103;&#x6d;&#x61;&#105;&#x6c;&#46;&#x63;&#x6f;&#109;&#x5d;&#40;&#41;">&#91;&#x6a;&#x69;&#97;&#x6e;&#x67;&#x7a;&#117;&#111;&#x2e;&#46;&#x2e;&#64;&#103;&#x6d;&#x61;&#105;&#x6c;&#46;&#x63;&#x6f;&#109;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>个人觉得最大障碍在工具上.</p>
<p>并行学术上研究得不少, 主要在算法和模型上. 工程上的工具, 多是自串行程序来设计的, 弄得复杂不堪. 并行需要语言和库两级支持, Pthreads 和
MPI 仅从库上入手, 让程序员处理各种重复且复杂的分发, 并发锁等. OpenMP好一些, 可惜目前只支持线程并行.</p>
<p>用 ErLang 等将并行设计在语言里的来做并行会容易得多, 得易于面向消息传递的隔离模型, 程序稳定易写. 模型和语言的性能是一个问题,
主要的问题还在用的人和实际并行项目不多.</p>
<p>调试工具就更少了. 有少数商业化的工具.</p>
<p>当然, 我是将可维护性归结为语言工具太差.</p>
<pre><code>                                                 Changsheng Jiang
</code></pre><p>2010/3/22 Guancheng Chen <a href="&#x6d;&#x61;&#105;&#x6c;&#116;&#x6f;&#58;&#x5b;&#x63;&#x68;&#101;&#110;&#103;&#117;&#x61;&#110;&#99;&#104;&#x2e;&#x2e;&#46;&#64;&#x67;&#109;&#97;&#105;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#x28;&#x29;">&#x5b;&#x63;&#x68;&#101;&#110;&#103;&#117;&#x61;&#110;&#99;&#104;&#x2e;&#x2e;&#46;&#64;&#x67;&#109;&#97;&#105;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#x28;&#x29;</a></p>
</blockquote>
<p>&gt;
&gt;
&gt;</p>
<blockquote>
<blockquote>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..</p>
<p>)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。</p>
</blockquote>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<blockquote>
<blockquote>
<p>尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。</p>
</li>
</ol>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
<a href="">显示删减掉的内容</a></p>
</blockquote>
</blockquote>
<p><img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>哈哈 是想绕开C++那些本来就复杂的要死的feature么？是不是如果有一门新的易用的编程语言会比诸如给C++添加thread特性的方法要
好？</p>
<p>On 3月22日, 上午6时48分, Kula <a href="&#x6d;&#97;&#x69;&#108;&#x74;&#111;&#58;&#91;&#107;&#117;&#108;&#x61;&#x73;&#46;&#46;&#x2e;&#64;&#103;&#x6d;&#x61;&#x69;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#x29;">&#91;&#107;&#117;&#108;&#x61;&#x73;&#46;&#46;&#x2e;&#64;&#103;&#x6d;&#x61;&#x69;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>我觉得 想要并行开发 必须绕开c/c++</p>
<p>2010/3/22 Guancheng Chen <a href="&#x6d;&#97;&#105;&#x6c;&#116;&#111;&#58;&#x5b;&#99;&#104;&#x65;&#110;&#x67;&#117;&#97;&#x6e;&#99;&#104;&#x2e;&#46;&#46;&#x40;&#103;&#109;&#97;&#x69;&#x6c;&#46;&#x63;&#111;&#x6d;&#93;&#x28;&#41;">&#x5b;&#99;&#104;&#x65;&#110;&#x67;&#117;&#97;&#x6e;&#99;&#104;&#x2e;&#46;&#46;&#x40;&#103;&#109;&#97;&#x69;&#x6c;&#46;&#x63;&#111;&#x6d;&#93;&#x28;&#41;</a></p>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>&gt;
&gt;
&gt;</p>
<blockquote>
<blockquote>
<p>微软好像已经推出了跟OpenCL类似的Direct Compute，也能搞GPU CPU混合计算</p>
<p>On 3月22日, 上午2时42分, &quot;Jeffrey Zhao&quot; <a href="&#109;&#97;&#105;&#108;&#x74;&#111;&#58;&#x5b;&#106;&#x65;&#46;&#x2e;&#46;&#64;&#108;&#105;&#x76;&#101;&#46;&#99;&#x6f;&#x6d;&#x5d;&#40;&#41;">&#x5b;&#106;&#x65;&#46;&#x2e;&#46;&#64;&#108;&#105;&#x76;&#101;&#46;&#99;&#x6f;&#x6d;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>哈哈，广告好，扩展视野，那我继续做广告了......</p>
<p>微软其实很早就在搞Microsoft Accelerator项目，旨在利用DirectX进行计算，.NET项目。
<a href="http://research.microsoft.com/en-us/projects/Accelerator/" target="_blank"><a href="http://research.microsoft.com/en-us/projects/Accelerator/">http://research.microsoft.com/en-us/projects/Accelerator/</a></a></p>
<p>然后F/#这边由于语言的支持良好，可以设计出丰富的表达式、DSL等Modeling
Language，再由框架进行自动并行，解决问题可以很容易（已经2.0了）。</p>
<p>这篇文章是个简单介绍：<a href="http://strangelights.com/blog/archive/2008/09/21/1628.aspx" target="_blank"><a href="http://strangelights.com/blog/archive/2008/09/21/1628.aspx">http://strangelights.com/blog/archive/2008/09/21/1628.aspx</a></a></p>
<p>Microsoft Solver Foundationhttp://
<a href="http://code.msdn.microsoft.com/solverfoundation" target="_blank">code.msdn.microsoft.com/solverfoundation</a></p>
<p>F/# Optimization Modeling Language Utilizing Microsoft Solver
Foundation<a href="http://[code.msdn.microsoft.com/solverfoundationfs1](http://code.msdn.microsoft.com/solverfoundationfs1" target="_blank">http://[code.msdn.microsoft.com/solverfoundationfs1](http://code.msdn.microsoft.com/solverfoundationfs1</a>)</p>
<p>现在就等OpenCL如果有标准出来，肯定立马可以跟上个类库，哦耶。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p>From: Tinyfool
Sent: Monday, March 22, 2010 9:20 AM
To: <a href="">pon...@googlegroups.com</a>
Subject: Re: [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#x6d;&#97;&#x69;&#108;&#x74;&#111;&#x3a;&#91;&#x6a;&#101;&#46;&#46;&#46;&#64;&#x6c;&#105;&#x76;&#x65;&#x2e;&#99;&#111;&#x6d;&#93;&#x28;&#x29;">&#91;&#x6a;&#101;&#46;&#46;&#46;&#64;&#x6c;&#105;&#x76;&#x65;&#x2e;&#99;&#111;&#x6d;&#93;&#x28;&#x29;</a></p>
<p>  我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>  其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>  例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>  至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>  例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>  Jeffrey Zhao
  Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
  Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p>  From: Guancheng Chen
  Sent: Monday, March 22, 2010 7:37 AM
  To: TopLanguage
  Subject: [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>  近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
  碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
  (fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
  Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
  的看法。</p>
<p>  ( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看
 <a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-" target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a></a>.
..
  )</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线</p>
</li>
</ol>
</blockquote>
<p>程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。</p>
<blockquote>
<p>  尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
  并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
  好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
  和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
  OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
  训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li><p>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</p>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
</li>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false...</p>
</li>
</ol>
</blockquote>
</blockquote>
<p>阅读更多 &gt;&gt;
<a href="">显示删减掉的内容</a>
<img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>On 3月22日, 上午2时20分, Tinyfool <a href="&#x6d;&#x61;&#105;&#x6c;&#x74;&#x6f;&#58;&#91;&#116;&#x69;&#110;&#x79;&#102;&#46;&#x2e;&#46;&#64;&#103;&#x6d;&#x61;&#x69;&#108;&#x2e;&#99;&#x6f;&#109;&#x5d;&#40;&#41;">&#91;&#116;&#x69;&#110;&#x79;&#102;&#46;&#x2e;&#46;&#64;&#103;&#x6d;&#x61;&#x69;&#108;&#x2e;&#99;&#x6f;&#109;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#109;&#x61;&#x69;&#x6c;&#x74;&#x6f;&#58;&#x5b;&#x6a;&#x65;&#x2e;&#46;&#x2e;&#64;&#108;&#x69;&#x76;&#x65;&#46;&#99;&#111;&#109;&#x5d;&#40;&#x29;">&#x5b;&#x6a;&#x65;&#x2e;&#46;&#x2e;&#64;&#108;&#x69;&#x76;&#x65;&#46;&#99;&#111;&#109;&#x5d;&#40;&#x29;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
</blockquote>
</blockquote>
<p>&gt;</p>
<blockquote>
<blockquote>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#x6d;&#x61;&#x69;&#108;&#116;&#111;&#58;&#91;&#x63;&#104;&#x65;&#x6e;&#x67;&#117;&#x61;&#x6e;&#x63;&#104;&#x2e;&#46;&#x2e;&#x40;&#103;&#x6d;&#x61;&#x69;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#41;">&#91;&#x63;&#104;&#x65;&#x6e;&#x67;&#117;&#x61;&#x6e;&#x63;&#104;&#x2e;&#46;&#x2e;&#x40;&#103;&#x6d;&#x61;&#x69;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#41;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#x6d;&#97;&#x69;&#108;&#x74;&#111;&#58;&#91;&#x70;&#x6f;&#x6e;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#x6f;&#x6f;&#103;&#108;&#101;&#103;&#114;&#x6f;&#117;&#x70;&#x73;&#x2e;&#99;&#111;&#x6d;&#93;&#40;&#x29;">&#91;&#x70;&#x6f;&#x6e;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#x6f;&#x6f;&#103;&#108;&#101;&#103;&#114;&#x6f;&#117;&#x70;&#x73;&#x2e;&#99;&#111;&#x6d;&#93;&#40;&#x29;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
</blockquote>
</blockquote>
<p>&gt;</p>
<blockquote>
<blockquote>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..</p>
<p>)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。</p>
</blockquote>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<blockquote>
<blockquote>
<p>尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。</p>
</li>
</ol>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>--
Tinyfool的开发日记<a href="http://www.tinydust.net/dev/" target="_blank"><a href="http://www.tinydust.net/dev/">http://www.tinydust.net/dev/</a></a>
代码中国网<a href="http://www.codechina.org/" target="_blank"><a href="http://www.codechina.org">http://www.codechina.org</a></a>
myTwitter:<a href="http://twitter.com/tinyfool" target="_blank"><a href="http://twitter.com/tinyfool">http://twitter.com/tinyfool</a></a>
<a href="">显示删减掉的内容</a></p>
</blockquote>
<p><img src="" alt=""> changsheng <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>说来惭愧, 接触并行时间不长, 没什么实际经验, 只写过几个并行程序.</p>
<p>感觉 MPI + OpenMP 倒算好用. 简单的单机程序, 用OpenMP并行, 添加几个编译指令就可以. 复杂点的, 用MPI, 也能忍, 只是需要重新设计一下程序和算法.
除了简单的打印, 跟踪一个进程, 不知道怎么调试并行程序. 没有专用平台如NUMA等的编程经验.</p>
<pre><code>                                                 Changsheng Jiang
</code></pre><p>2010/3/22 Guancheng Chen <a href="&#x6d;&#x61;&#105;&#x6c;&#x74;&#x6f;&#58;&#x5b;&#x63;&#x68;&#101;&#x6e;&#x67;&#x75;&#46;&#46;&#46;&#64;&#103;&#x6d;&#x61;&#105;&#x6c;&#46;&#99;&#x6f;&#109;&#93;&#x28;&#x29;">&#x5b;&#x63;&#x68;&#101;&#x6e;&#x67;&#x75;&#46;&#46;&#46;&#64;&#103;&#x6d;&#x61;&#105;&#x6c;&#46;&#99;&#x6f;&#109;&#93;&#x28;&#x29;</a>
不知道您觉得现有的工具哪些个最趁手呢？
On 3月22日, 上午3时19分, Changsheng Jiang <a href="&#109;&#97;&#105;&#x6c;&#x74;&#x6f;&#58;&#91;&#x6a;&#x69;&#97;&#x6e;&#x67;&#x7a;&#117;&#111;&#x2e;&#x2e;&#46;&#x40;&#103;&#x6d;&#x61;&#105;&#108;&#x2e;&#x63;&#111;&#109;&#93;&#40;&#41;">&#91;&#x6a;&#x69;&#97;&#x6e;&#x67;&#x7a;&#117;&#111;&#x2e;&#x2e;&#46;&#x40;&#103;&#x6d;&#x61;&#105;&#108;&#x2e;&#x63;&#111;&#109;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>个人觉得最大障碍在工具上.</p>
<p>并行学术上研究得不少, 主要在算法和模型上. 工程上的工具, 多是自串行程序来设计的, 弄得复杂不堪. 并行需要语言和库两级支持, Pthreads 和
MPI 仅从库上入手, 让程序员处理各种重复且复杂的分发, 并发锁等. OpenMP好一些, 可惜目前只支持线程并行.</p>
<p>用 ErLang 等将并行设计在语言里的来做并行会容易得多, 得易于面向消息传递的隔离模型, 程序稳定易写. 模型和语言的性能是一个问题,
主要的问题还在用的人和实际并行项目不多.</p>
<p>调试工具就更少了. 有少数商业化的工具.</p>
<p>当然, 我是将可维护性归结为语言工具太差.</p>
<pre><code>                                                 Changsheng Jiang
</code></pre><p>2010/3/22 Guancheng Chen <a href="&#x6d;&#97;&#105;&#x6c;&#116;&#x6f;&#x3a;&#91;&#99;&#104;&#101;&#x6e;&#x67;&#x75;&#97;&#x6e;&#99;&#104;&#46;&#46;&#x2e;&#x40;&#103;&#109;&#97;&#x69;&#x6c;&#46;&#99;&#111;&#109;&#x5d;&#x28;&#x29;">&#91;&#99;&#104;&#101;&#x6e;&#x67;&#x75;&#97;&#x6e;&#99;&#104;&#46;&#46;&#x2e;&#x40;&#103;&#109;&#97;&#x69;&#x6c;&#46;&#99;&#111;&#109;&#x5d;&#x28;&#x29;</a></p>
<blockquote>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。</p>
</li>
</ol>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> doyle <img src="" alt=""></p>
</blockquote>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>2010/3/22 Guancheng Chen <a href="&#109;&#97;&#x69;&#108;&#x74;&#111;&#58;&#x5b;&#99;&#104;&#x65;&#x6e;&#x67;&#117;&#46;&#x2e;&#46;&#x40;&#103;&#x6d;&#x61;&#x69;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#93;&#x28;&#x29;">&#x5b;&#99;&#104;&#x65;&#x6e;&#x67;&#117;&#46;&#x2e;&#46;&#x40;&#103;&#x6d;&#x61;&#x69;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#93;&#x28;&#x29;</a>
我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>我也是被蛊惑了...所以向老婆提申请来着,结果被否掉了...
 On 3月22日, 上午2时20分, Tinyfool <a href="&#109;&#x61;&#x69;&#x6c;&#116;&#111;&#58;&#91;&#116;&#x69;&#x6e;&#x79;&#102;&#46;&#x2e;&#x2e;&#64;&#103;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#99;&#111;&#109;&#93;&#40;&#x29;">&#91;&#116;&#x69;&#x6e;&#x79;&#102;&#46;&#x2e;&#x2e;&#64;&#103;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#99;&#111;&#109;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#109;&#x61;&#x69;&#x6c;&#x74;&#111;&#x3a;&#x5b;&#106;&#101;&#x2e;&#46;&#46;&#x40;&#x6c;&#x69;&#118;&#101;&#x2e;&#99;&#111;&#109;&#93;&#40;&#x29;">&#x5b;&#106;&#101;&#x2e;&#46;&#46;&#x40;&#x6c;&#x69;&#118;&#101;&#x2e;&#99;&#111;&#109;&#93;&#40;&#x29;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#109;&#x61;&#x69;&#x6c;&#116;&#111;&#58;&#91;&#x63;&#x68;&#x65;&#x6e;&#103;&#x75;&#x61;&#x6e;&#99;&#x68;&#x2e;&#46;&#x2e;&#64;&#x67;&#109;&#x61;&#x69;&#108;&#x2e;&#99;&#x6f;&#109;&#x5d;&#x28;&#41;">&#91;&#x63;&#x68;&#x65;&#x6e;&#103;&#x75;&#x61;&#x6e;&#99;&#x68;&#x2e;&#46;&#x2e;&#64;&#x67;&#109;&#x61;&#x69;&#108;&#x2e;&#99;&#x6f;&#109;&#x5d;&#x28;&#41;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#x6d;&#97;&#x69;&#x6c;&#116;&#x6f;&#58;&#91;&#x70;&#111;&#110;&#x2e;&#x2e;&#46;&#64;&#103;&#111;&#x6f;&#x67;&#108;&#101;&#x67;&#114;&#111;&#x75;&#112;&#115;&#46;&#x63;&#111;&#109;&#93;&#x28;&#x29;">&#91;&#x70;&#111;&#110;&#x2e;&#x2e;&#46;&#64;&#103;&#111;&#x6f;&#x67;&#108;&#101;&#x67;&#114;&#111;&#x75;&#112;&#115;&#46;&#x63;&#111;&#109;&#93;&#x28;&#x29;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
</blockquote>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>&gt;</p>
<blockquote>
<blockquote>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。</p>
</li>
</ol>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>--</p>
<p>Tinyfool的开发日记<a href="http://www.tinydust.net/dev/" target="_blank"><a href="http://www.tinydust.net/dev/">http://www.tinydust.net/dev/</a></a>
代码中国网<a href="http://www.codechina.org/" target="_blank"><a href="http://www.codechina.org">http://www.codechina.org</a></a>
myTwitter:<a href="http://twitter.com/tinyfool" target="_blank"><a href="http://twitter.com/tinyfool">http://twitter.com/tinyfool</a></a></p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a></p>
<p><img src="" alt=""> tinyfool <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>热烈支持，哈哈
2010/3/22 Guancheng Chen <a href="&#109;&#97;&#x69;&#x6c;&#x74;&#111;&#58;&#91;&#99;&#104;&#x65;&#110;&#103;&#x75;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#109;&#x61;&#x69;&#108;&#46;&#x63;&#x6f;&#109;&#93;&#x28;&#x29;">&#91;&#99;&#104;&#x65;&#110;&#103;&#x75;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#109;&#x61;&#x69;&#108;&#46;&#x63;&#x6f;&#109;&#93;&#x28;&#x29;</a>
我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>On 3月22日, 上午2时20分, Tinyfool <a href="&#x6d;&#97;&#105;&#x6c;&#116;&#x6f;&#58;&#91;&#116;&#x69;&#110;&#x79;&#102;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#109;&#97;&#105;&#108;&#46;&#99;&#x6f;&#x6d;&#93;&#x28;&#41;">&#91;&#116;&#x69;&#110;&#x79;&#102;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#109;&#97;&#105;&#108;&#46;&#99;&#x6f;&#x6d;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p><a href="">显示删减掉的内容</a>
<img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>我个人也觉得OpenMP是目前比较好用的并行方式。像您这样设计算法的程序员，是不是基本上也是只对串行算法做优化改进，然后性能瓶颈比较大的部分才
考虑实施并行化？</p>
<p>On 3月22日, 上午7时09分, Changsheng Jiang <a href="&#x6d;&#97;&#105;&#x6c;&#116;&#x6f;&#58;&#91;&#106;&#105;&#x61;&#x6e;&#x67;&#x7a;&#x75;&#x6f;&#46;&#x2e;&#46;&#x40;&#x67;&#109;&#x61;&#x69;&#108;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#x29;">&#91;&#106;&#105;&#x61;&#x6e;&#x67;&#x7a;&#x75;&#x6f;&#46;&#x2e;&#46;&#x40;&#x67;&#109;&#x61;&#x69;&#108;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>说来惭愧, 接触并行时间不长, 没什么实际经验, 只写过几个并行程序.</p>
<p>感觉 MPI + OpenMP 倒算好用. 简单的单机程序, 用OpenMP并行, 添加几个编译指令就可以. 复杂点的, 用MPI, 也能忍,
只是需要重新设计一下程序和算法.</p>
<p>除了简单的打印, 跟踪一个进程, 不知道怎么调试并行程序. 没有专用平台如NUMA等的编程经验.</p>
<pre><code>                                                 Changsheng Jiang
</code></pre><p>2010/3/22 Guancheng Chen <a href="&#x6d;&#x61;&#105;&#108;&#116;&#111;&#x3a;&#91;&#x63;&#x68;&#101;&#x6e;&#x67;&#x75;&#97;&#x6e;&#99;&#104;&#46;&#46;&#46;&#x40;&#x67;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#111;&#109;&#93;&#x28;&#41;">&#91;&#x63;&#x68;&#101;&#x6e;&#x67;&#x75;&#97;&#x6e;&#99;&#104;&#46;&#46;&#46;&#x40;&#x67;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#111;&#109;&#93;&#x28;&#41;</a></p>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>&gt;
&gt;
&gt;</p>
<blockquote>
<blockquote>
<p>不知道您觉得现有的工具哪些个最趁手呢？</p>
<p>On 3月22日, 上午3时19分, Changsheng Jiang <a href="&#109;&#x61;&#105;&#108;&#116;&#111;&#x3a;&#x5b;&#x6a;&#105;&#x61;&#110;&#x67;&#122;&#x75;&#111;&#46;&#x2e;&#46;&#64;&#x67;&#x6d;&#97;&#x69;&#108;&#46;&#x63;&#x6f;&#109;&#93;&#x28;&#x29;">&#x5b;&#x6a;&#105;&#x61;&#110;&#x67;&#122;&#x75;&#111;&#46;&#x2e;&#46;&#64;&#x67;&#x6d;&#97;&#x69;&#108;&#46;&#x63;&#x6f;&#109;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>个人觉得最大障碍在工具上.</p>
<p>并行学术上研究得不少, 主要在算法和模型上. 工程上的工具, 多是自串行程序来设计的, 弄得复杂不堪. 并行需要语言和库两级支持,
Pthreads 和
MPI 仅从库上入手, 让程序员处理各种重复且复杂的分发, 并发锁等. OpenMP好一些, 可惜目前只支持线程并行.</p>
<p>用 ErLang 等将并行设计在语言里的来做并行会容易得多, 得易于面向消息传递的隔离模型, 程序稳定易写. 模型和语言的性能是一个问题,
主要的问题还在用的人和实际并行项目不多.</p>
<p>调试工具就更少了. 有少数商业化的工具.</p>
<p>当然, 我是将可维护性归结为语言工具太差.</p>
<pre><code>                                                 Changsheng Jiang
</code></pre><p>2010/3/22 Guancheng Chen <a href="&#x6d;&#97;&#105;&#x6c;&#116;&#x6f;&#58;&#91;&#x63;&#x68;&#x65;&#110;&#103;&#x75;&#x61;&#110;&#x63;&#104;&#46;&#46;&#46;&#x40;&#103;&#x6d;&#97;&#x69;&#108;&#x2e;&#99;&#x6f;&#109;&#x5d;&#x28;&#41;">&#91;&#x63;&#x68;&#x65;&#110;&#103;&#x75;&#x61;&#110;&#x63;&#104;&#46;&#46;&#46;&#x40;&#103;&#x6d;&#97;&#x69;&#108;&#x2e;&#99;&#x6f;&#109;&#x5d;&#x28;&#41;</a></p>
<blockquote>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-" target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a></a>.
..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线</p>
</blockquote>
</blockquote>
<p>程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。</p>
<blockquote>
<blockquote>
<p>尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。</p>
</li>
</ol>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
<a href="">显示删减掉的内容</a></p>
</blockquote>
</blockquote>
<p><img src="" alt=""> changsheng <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>说设计算法, 其实, 是实现算法, 找到合适的算法实现了.</p>
<p>五个障碍中的第一条在, 人力有限, 只能并行不并行不行的部分.
                                                     Changsheng Jiang
2010/3/22 Guancheng Chen <a href="&#109;&#97;&#105;&#x6c;&#x74;&#111;&#x3a;&#x5b;&#99;&#104;&#101;&#x6e;&#103;&#117;&#46;&#46;&#46;&#x40;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#46;&#x63;&#x6f;&#109;&#93;&#x28;&#x29;">&#x5b;&#99;&#104;&#101;&#x6e;&#103;&#117;&#46;&#46;&#46;&#x40;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#46;&#x63;&#x6f;&#109;&#93;&#x28;&#x29;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>我个人也觉得OpenMP是目前比较好用的并行方式。像您这样设计算法的程序员，是不是基本上也是只对串行算法做优化改进，然后性能瓶颈比较大的部分才
考虑实施并行化？
On 3月22日, 上午7时09分, Changsheng Jiang <a href="&#109;&#97;&#105;&#x6c;&#116;&#111;&#58;&#x5b;&#106;&#105;&#97;&#110;&#103;&#122;&#117;&#x6f;&#x2e;&#x2e;&#46;&#64;&#x67;&#x6d;&#97;&#x69;&#108;&#46;&#x63;&#111;&#x6d;&#x5d;&#40;&#41;">&#x5b;&#106;&#105;&#97;&#110;&#103;&#122;&#117;&#x6f;&#x2e;&#x2e;&#46;&#64;&#x67;&#x6d;&#97;&#x69;&#108;&#46;&#x63;&#111;&#x6d;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>说来惭愧, 接触并行时间不长, 没什么实际经验, 只写过几个并行程序.</p>
<p>感觉 MPI + OpenMP 倒算好用. 简单的单机程序, 用OpenMP并行, 添加几个编译指令就可以. 复杂点的, 用MPI, 也能忍,
只是需要重新设计一下程序和算法.</p>
<p>除了简单的打印, 跟踪一个进程, 不知道怎么调试并行程序. 没有专用平台如NUMA等的编程经验.</p>
<pre><code>                                                 Changsheng Jiang
</code></pre><p>2010/3/22 Guancheng Chen <a href="&#x6d;&#97;&#x69;&#108;&#x74;&#111;&#58;&#91;&#99;&#x68;&#101;&#x6e;&#103;&#x75;&#97;&#110;&#x63;&#x68;&#46;&#46;&#46;&#64;&#103;&#x6d;&#97;&#105;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#x28;&#x29;">&#91;&#99;&#x68;&#101;&#x6e;&#103;&#x75;&#97;&#110;&#x63;&#x68;&#46;&#46;&#46;&#64;&#103;&#x6d;&#97;&#105;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#x28;&#x29;</a></p>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>&gt;
&gt;
&gt;</p>
<blockquote>
<blockquote>
<p>不知道您觉得现有的工具哪些个最趁手呢？</p>
<p>On 3月22日, 上午3时19分, Changsheng Jiang <a href="&#109;&#97;&#105;&#x6c;&#x74;&#x6f;&#58;&#x5b;&#x6a;&#x69;&#97;&#x6e;&#103;&#122;&#117;&#111;&#x2e;&#x2e;&#46;&#64;&#103;&#x6d;&#97;&#x69;&#108;&#46;&#x63;&#x6f;&#x6d;&#93;&#x28;&#41;">&#x5b;&#x6a;&#x69;&#97;&#x6e;&#103;&#122;&#117;&#111;&#x2e;&#x2e;&#46;&#64;&#103;&#x6d;&#97;&#x69;&#108;&#46;&#x63;&#x6f;&#x6d;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>个人觉得最大障碍在工具上.</p>
<p>并行学术上研究得不少, 主要在算法和模型上. 工程上的工具, 多是自串行程序来设计的, 弄得复杂不堪. 并行需要语言和库两级支持,
Pthreads 和
MPI 仅从库上入手, 让程序员处理各种重复且复杂的分发, 并发锁等. OpenMP好一些, 可惜目前只支持线程并行.</p>
<p>用 ErLang 等将并行设计在语言里的来做并行会容易得多, 得易于面向消息传递的隔离模型, 程序稳定易写. 模型和语言的性能是一个问题,
主要的问题还在用的人和实际并行项目不多.</p>
<p>调试工具就更少了. 有少数商业化的工具.</p>
<p>当然, 我是将可维护性归结为语言工具太差.</p>
<pre><code>                                                 Changsheng Jiang
</code></pre><p>2010/3/22 Guancheng Chen <a href="&#x6d;&#x61;&#x69;&#108;&#116;&#x6f;&#x3a;&#91;&#x63;&#104;&#101;&#110;&#x67;&#117;&#x61;&#x6e;&#99;&#x68;&#46;&#46;&#x2e;&#x40;&#103;&#x6d;&#97;&#x69;&#108;&#x2e;&#99;&#111;&#x6d;&#93;&#40;&#41;">&#91;&#x63;&#104;&#101;&#110;&#x67;&#117;&#x61;&#x6e;&#99;&#x68;&#46;&#46;&#x2e;&#x40;&#103;&#x6d;&#97;&#x69;&#108;&#x2e;&#99;&#111;&#x6d;&#93;&#40;&#41;</a></p>
<blockquote>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-" target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a></a>.
..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线</p>
</blockquote>
</blockquote>
<p>程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。</p>
<blockquote>
<blockquote>
<p>尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。</p>
</li>
</ol>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
 To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> Alleluia <img src="" alt=""></p>
</blockquote>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>Parallelism 说到底是算法问题.Parallelism与Concurrency不同,Concurrency所面对的问题相对的单一可以
让一群有经验的专家来实现一套通用库或者语言来提供一个基本的编程框架.而在Parallelism上,具体的不同问题,其所需要并行的算法是根本不同
的.原因在于不同的问题,其内部的DataDependency的结构完全不同,不同的Data Dependency的结构,需要构造不同的算法.即
便是相同的Data Dependency,在不同的颗粒度下，在不同的硬件条件下所采用的算法也是完全不同的.因为一旦出现Data
Dependency也就意味着并行计算模块之间需要进行通信.从以计算节点为单位的分布式并行,到多核CPU上的Numa结构,到SIMD上的向量处
理器,其计算单元之间的通信手段,通信效率简直天差地别.比如说,在SMP上最常见的并行算法,work stealing也就是Intel的TBB,
是建立在两个条件下第一个是CPU的Cache机制上,这使得通常在内存的之间的数据搬运消耗非常小,第二个是SMP上计算单元相对的少,因此每个计算
单元被分配到的任务就相对的重。其开销远远大于通信的开销,因此这种机制在SMP上相对的划算.但是如果你要在GPU上做Work Stealing就
完全不可行,因为GPU的运算单元数量极多,被分配到的任务就相对来说的非常轻量,CUDA上的一个thread很多时候运算一次的时间不会超过
10us,而一次跨Block的线程之间的通信开销就往往要达到100us左右,再加上目前GPU上的Cache机制非常落后导致了需要频繁的通信开销
的Work Stealing在GPU上是非常不划算得.
所以我个人认为在硬件架构没有更多的突破之前,OpenCL这种东西是没有任何生命力的.不要说CPU的并行与GPU之间差异巨大,就是不同的GPU之
间AMD与Nvidia两个也是各自为政,一个平台上跑得非常快的东西,在另外一个平台极大的可能是龟速.其最终的结果估计就是跟Java的
write once run everywhere一样是个大笑话.</p>
<p>On 3月22日, 下午2时06分, Guancheng Chen <a href="&#109;&#x61;&#x69;&#x6c;&#116;&#111;&#58;&#x5b;&#x63;&#x68;&#101;&#110;&#x67;&#117;&#97;&#x6e;&#99;&#x68;&#46;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#105;&#108;&#x2e;&#x63;&#111;&#109;&#x5d;&#x28;&#x29;">&#x5b;&#x63;&#x68;&#101;&#110;&#x67;&#117;&#97;&#x6e;&#99;&#x68;&#46;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#105;&#108;&#x2e;&#x63;&#111;&#109;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>On 3月22日, 上午2时20分, Tinyfool <a href="&#109;&#x61;&#x69;&#x6c;&#x74;&#x6f;&#58;&#91;&#x74;&#105;&#x6e;&#121;&#x66;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#93;&#40;&#x29;">&#91;&#x74;&#105;&#x6e;&#121;&#x66;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#x6d;&#x61;&#x69;&#108;&#116;&#x6f;&#58;&#91;&#x6a;&#101;&#x2e;&#46;&#x2e;&#64;&#x6c;&#x69;&#x76;&#x65;&#x2e;&#99;&#x6f;&#109;&#x5d;&#x28;&#41;">&#91;&#x6a;&#101;&#x2e;&#46;&#x2e;&#64;&#x6c;&#x69;&#x76;&#x65;&#x2e;&#99;&#x6f;&#109;&#x5d;&#x28;&#41;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#x6d;&#97;&#x69;&#108;&#x74;&#111;&#x3a;&#91;&#99;&#104;&#x65;&#110;&#103;&#117;&#97;&#x6e;&#99;&#104;&#46;&#46;&#x2e;&#x40;&#x67;&#109;&#x61;&#x69;&#108;&#46;&#x63;&#x6f;&#x6d;&#93;&#x28;&#41;">&#91;&#99;&#104;&#x65;&#110;&#103;&#117;&#97;&#x6e;&#99;&#104;&#46;&#46;&#x2e;&#x40;&#x67;&#109;&#x61;&#x69;&#108;&#46;&#x63;&#x6f;&#x6d;&#93;&#x28;&#41;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#x6d;&#x61;&#105;&#108;&#x74;&#111;&#58;&#91;&#112;&#111;&#110;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#111;&#111;&#103;&#108;&#x65;&#x67;&#114;&#x6f;&#x75;&#112;&#115;&#x2e;&#x63;&#111;&#109;&#x5d;&#x28;&#41;">&#91;&#112;&#111;&#110;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#111;&#111;&#103;&#108;&#x65;&#x67;&#114;&#x6f;&#x75;&#112;&#115;&#x2e;&#x63;&#111;&#109;&#x5d;&#x28;&#41;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
</blockquote>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<blockquote>
<blockquote>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。</p>
</li>
</ol>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>--
Tinyfool的开发日记<a href="http://www.tinydust.net/dev/" target="_blank"><a href="http://www.tinydust.net/dev/">http://www.tinydust.net/dev/</a></a>
代码中国网<a href="http://www.codechina.org/" target="_blank"><a href="http://www.codechina.org">http://www.codechina.org</a></a>
myTwitter:<a href="http://twitter.com/tinyfool" target="_blank"><a href="http://twitter.com/tinyfool">http://twitter.com/tinyfool</a></a>
<a href="">显示删减掉的内容</a></p>
</blockquote>
</blockquote>
<p><img src="" alt=""> Alleluia <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>其实并行计算这个东西,对现有的基于文本内容的程序意义不是很大.因为文本内容的数据量增加是线性的.而相对来说,视频音频的数据就完全不同是按平方甚
至是指数增加的.一个文本长度增加一倍,数据量也就增加一倍.而一张图片,长宽增加一倍,数据量要增加四倍.一个既有的算法在没有大的理论突破的前提
下,在特定的硬件平台上能够优化加速5-6倍已经是了不得了.但是对于多媒体数据来说,这个加速真的不算什么.一个算法在720p上快3,4倍,换到
1080p的也就是达到了720p上不加速的效果而已.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>绝大部分的观点Can&#39;t agree more.其实这也是为什么我引用了高老爷子那段话的原因，因为程序的本质就是数据结构和算法，你要没有非常适
合并行的算法那简直就是巧妇难为无米之炊。但是有疑问的一点是关于Parallelism和Concurrency这两个单词的区别，实际上这也是非常
有意思的一件事情，Sun的多线程指南上写的是： Parallelism is a condition that arises when at
least two threads are executing simultaneously, while concurrency is a
condition that exists when at least two threads are making progress.
Therefore concurrency is a more generalized form of parallelism that
can include time-slicing as a form of virtual parallelism.不知道您怎么看？</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>On 3月22日, 上午8时06分, Alleluia <a href="&#109;&#x61;&#x69;&#x6c;&#x74;&#x6f;&#58;&#x5b;&#97;&#x6c;&#108;&#x75;&#108;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#109;&#x61;&#105;&#108;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#x29;">&#x5b;&#97;&#x6c;&#108;&#x75;&#108;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#109;&#x61;&#105;&#108;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>Parallelism 说到底是算法问题.Parallelism与Concurrency不同,Concurrency所面对的问题相对的单一可以
让一群有经验的专家来实现一套通用库或者语言来提供一个基本的编程框架.而在Parallelism上,具体的不同问题,其所需要并行的算法是根本不同
的.原因在于不同的问题,其内部的DataDependency的结构完全不同,不同的Data Dependency的结构,需要构造不同的算法.即
便是相同的Data Dependency,在不同的颗粒度下，在不同的硬件条件下所采用的算法也是完全不同的.因为一旦出现Data
Dependency也就意味着并行计算模块之间需要进行通信.从以计算节点为单位的分布式并行,到多核CPU上的Numa结构,到SIMD上的向量处
理器,其计算单元之间的通信手段,通信效率简直天差地别.比如说,在SMP上最常见的并行算法,work stealing也就是Intel的TBB,
是建立在两个条件下第一个是CPU的Cache机制上,这使得通常在内存的之间的数据搬运消耗非常小,第二个是SMP上计算单元相对的少,因此每个计算
单元被分配到的任务就相对的重。其开销远远大于通信的开销,因此这种机制在SMP上相对的划算.但是如果你要在GPU上做Work Stealing就
完全不可行,因为GPU的运算单元数量极多,被分配到的任务就相对来说的非常轻量,CUDA上的一个thread很多时候运算一次的时间不会超过
10us,而一次跨Block的线程之间的通信开销就往往要达到100us左右,再加上目前GPU上的Cache机制非常落后导致了需要频繁的通信开销
的Work Stealing在GPU上是非常不划算得.
所以我个人认为在硬件架构没有更多的突破之前,OpenCL这种东西是没有任何生命力的.不要说CPU的并行与GPU之间差异巨大,就是不同的GPU之
间AMD与Nvidia两个也是各自为政,一个平台上跑得非常快的东西,在另外一个平台极大的可能是龟速.其最终的结果估计就是跟Java的
write once run everywhere一样是个大笑话.</p>
<p>On 3月22日, 下午2时06分, Guancheng Chen <a href="&#109;&#97;&#x69;&#108;&#x74;&#x6f;&#58;&#x5b;&#x63;&#x68;&#x65;&#110;&#x67;&#x75;&#97;&#x6e;&#99;&#104;&#x2e;&#x2e;&#46;&#x40;&#103;&#x6d;&#97;&#x69;&#108;&#x2e;&#x63;&#x6f;&#109;&#93;&#40;&#x29;">&#x5b;&#x63;&#x68;&#x65;&#110;&#x67;&#x75;&#97;&#x6e;&#99;&#104;&#x2e;&#x2e;&#46;&#x40;&#103;&#x6d;&#97;&#x69;&#108;&#x2e;&#x63;&#x6f;&#109;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>On 3月22日, 上午2时20分, Tinyfool <a href="&#109;&#x61;&#105;&#x6c;&#x74;&#x6f;&#58;&#x5b;&#116;&#105;&#110;&#x79;&#x66;&#46;&#46;&#46;&#x40;&#103;&#109;&#x61;&#105;&#108;&#46;&#99;&#x6f;&#109;&#x5d;&#40;&#x29;">&#x5b;&#116;&#105;&#110;&#x79;&#x66;&#46;&#46;&#46;&#x40;&#103;&#109;&#x61;&#105;&#108;&#46;&#99;&#x6f;&#109;&#x5d;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#109;&#x61;&#105;&#108;&#x74;&#111;&#58;&#91;&#106;&#101;&#46;&#x2e;&#x2e;&#x40;&#108;&#x69;&#118;&#x65;&#46;&#x63;&#x6f;&#109;&#93;&#x28;&#x29;">&#91;&#106;&#101;&#46;&#x2e;&#x2e;&#x40;&#108;&#x69;&#118;&#x65;&#46;&#x63;&#x6f;&#109;&#93;&#x28;&#x29;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#x6d;&#97;&#x69;&#x6c;&#x74;&#x6f;&#58;&#x5b;&#x63;&#x68;&#101;&#110;&#103;&#117;&#97;&#x6e;&#99;&#x68;&#x2e;&#x2e;&#46;&#x40;&#x67;&#109;&#x61;&#x69;&#108;&#x2e;&#99;&#111;&#x6d;&#93;&#x28;&#41;">&#x5b;&#x63;&#x68;&#101;&#110;&#103;&#117;&#97;&#x6e;&#99;&#x68;&#x2e;&#x2e;&#46;&#x40;&#x67;&#109;&#x61;&#x69;&#108;&#x2e;&#99;&#111;&#x6d;&#93;&#x28;&#41;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#x6d;&#x61;&#x69;&#x6c;&#116;&#111;&#58;&#91;&#x70;&#x6f;&#x6e;&#46;&#46;&#x2e;&#x40;&#103;&#x6f;&#111;&#x67;&#x6c;&#x65;&#103;&#x72;&#x6f;&#117;&#x70;&#x73;&#46;&#x63;&#x6f;&#x6d;&#93;&#x28;&#41;">&#91;&#x70;&#x6f;&#x6e;&#46;&#46;&#x2e;&#x40;&#103;&#x6f;&#111;&#x67;&#x6c;&#x65;&#103;&#x72;&#x6f;&#117;&#x70;&#x73;&#46;&#x63;&#x6f;&#x6d;&#93;&#x28;&#41;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，...</p>
</blockquote>
</blockquote>
</blockquote>
<p>阅读更多 &gt;&gt;
<a href="">显示删减掉的内容</a></p>
</blockquote>
<p><img src="" alt=""> Alleluia <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>Concurrency 说到底纯粹就是一个IO问题.而IO问题本质上是和计算完全无关的事情,不存在能不能行可不可计算的问题.因此它相对来说非常
单纯。他更多的是一种类似时钟同步的问题,如果你把IO事件想像成一种时钟信号.其实时钟本来也就是一堆信号而已.如果你做过Circuit 的东西就
会明白,IO只是在不同的时序下进行数据采样.比如最简单的同步时钟,所有的时序电路公用一个时钟,把不同的电路安排在不同的时序边沿上触发.当然更复
杂异步逻辑的道理也是一样的.放到宏观的Concurrency的问题的实质并没有多大改变,只不过CPU依靠PC指针的移动把这种电路上的时序处理软
件化了.</p>
<p>而Parallelism更多的是需要考虑计算问题同时还要兼顾IO.Parallelism首先要回答的是一个东西是不是可并行的.回答完这个问题
后,如果可并行那么在什么样的硬件设备上并行是最合适的这样一个问题.在Parallelism中需要考虑的的IO也不仅仅是来自于网络更多是,缓存,
内存,磁盘,总线等等.其实我觉得,在Parallelism下你总是处于一个矛盾状态,颗粒度越小的并行获得的计算资源的利用率也就越大加速比就越
大,但是同时通信系统的工作也就越是繁忙整个运算过程浪费在通信消耗上的时间也就越多.
这个当中的tradeoff是非常困难的.很多时候速度不快,完全不是因为你的核心不够多,而是你的通信速度不够高.</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>On 3月22日, 下午3时21分, Guancheng Chen <a href="&#x6d;&#97;&#105;&#x6c;&#116;&#x6f;&#x3a;&#91;&#x63;&#104;&#x65;&#x6e;&#103;&#x75;&#x61;&#110;&#99;&#x68;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#x61;&#x69;&#108;&#46;&#99;&#x6f;&#109;&#93;&#40;&#x29;">&#91;&#x63;&#104;&#x65;&#x6e;&#103;&#x75;&#x61;&#110;&#99;&#x68;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#x61;&#x69;&#108;&#46;&#99;&#x6f;&#109;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>绝大部分的观点Can&#39;t agree more.其实这也是为什么我引用了高老爷子那段话的原因，因为程序的本质就是数据结构和算法，你要没有非常适
合并行的算法那简直就是巧妇难为无米之炊。但是有疑问的一点是关于Parallelism和Concurrency这两个单词的区别，实际上这也是非常
有意思的一件事情，Sun的多线程指南上写的是： Parallelism is a condition that arises when at
least two threads are executing simultaneously, while concurrency is a
condition that exists when at least two threads are making progress.
Therefore concurrency is a more generalized form of parallelism that
can include time-slicing as a form of virtual parallelism.不知道您怎么看？</p>
<p>On 3月22日, 上午8时06分, Alleluia <a href="&#109;&#97;&#x69;&#108;&#116;&#x6f;&#58;&#91;&#x61;&#x6c;&#x6c;&#x75;&#x6c;&#x2e;&#x2e;&#46;&#64;&#103;&#x6d;&#x61;&#105;&#108;&#x2e;&#99;&#x6f;&#109;&#93;&#40;&#41;">&#91;&#x61;&#x6c;&#x6c;&#x75;&#x6c;&#x2e;&#x2e;&#46;&#64;&#103;&#x6d;&#x61;&#105;&#108;&#x2e;&#99;&#x6f;&#109;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>Parallelism 说到底是算法问题.Parallelism与Concurrency不同,Concurrency所面对的问题相对的单一可以
让一群有经验的专家来实现一套通用库或者语言来提供一个基本的编程框架.而在Parallelism上,具体的不同问题,其所需要并行的算法是根本不同
的.原因在于不同的问题,其内部的DataDependency的结构完全不同,不同的Data Dependency的结构,需要构造不同的算法.即
便是相同的Data Dependency,在不同的颗粒度下，在不同的硬件条件下所采用的算法也是完全不同的.因为一旦出现Data
Dependency也就意味着并行计算模块之间需要进行通信.从以计算节点为单位的分布式并行,到多核CPU上的Numa结构,到SIMD上的向量处
理器,其计算单元之间的通信手段,通信效率简直天差地别.比如说,在SMP上最常见的并行算法,work stealing也就是Intel的TBB,
是建立在两个条件下第一个是CPU的Cache机制上,这使得通常在内存的之间的数据搬运消耗非常小,第二个是SMP上计算单元相对的少,因此每个计算
单元被分配到的任务就相对的重。其开销远远大于通信的开销,因此这种机制在SMP上相对的划算.但是如果你要在GPU上做Work Stealing就
完全不可行,因为GPU的运算单元数量极多,被分配到的任务就相对来说的非常轻量,CUDA上的一个thread很多时候运算一次的时间不会超过
10us,而一次跨Block的线程之间的通信开销就往往要达到100us左右,再加上目前GPU上的Cache机制非常落后导致了需要频繁的通信开销
的Work Stealing在GPU上是非常不划算得.
所以我个人认为在硬件架构没有更多的突破之前,OpenCL这种东西是没有任何生命力的.不要说CPU的并行与GPU之间差异巨大,就是不同的GPU之
间AMD与Nvidia两个也是各自为政,一个平台上跑得非常快的东西,在另外一个平台极大的可能是龟速.其最终的结果估计就是跟Java的
write once run everywhere一样是个大笑话.</p>
<p>On 3月22日, 下午2时06分, Guancheng Chen <a href="&#109;&#x61;&#105;&#108;&#x74;&#x6f;&#x3a;&#91;&#99;&#104;&#101;&#110;&#103;&#x75;&#x61;&#x6e;&#99;&#104;&#46;&#46;&#x2e;&#x40;&#x67;&#109;&#x61;&#x69;&#108;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#41;">&#91;&#99;&#104;&#101;&#110;&#103;&#x75;&#x61;&#x6e;&#99;&#104;&#46;&#46;&#x2e;&#x40;&#x67;&#109;&#x61;&#x69;&#108;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>On 3月22日, 上午2时20分, Tinyfool <a href="&#x6d;&#97;&#105;&#x6c;&#116;&#111;&#x3a;&#91;&#116;&#x69;&#x6e;&#x79;&#x66;&#x2e;&#x2e;&#46;&#64;&#103;&#109;&#97;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#x28;&#x29;">&#91;&#116;&#x69;&#x6e;&#x79;&#x66;&#x2e;&#x2e;&#46;&#64;&#103;&#109;&#97;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#91;&#106;&#101;&#46;&#x2e;&#x2e;&#x40;&#108;&#x69;&#118;&#101;&#46;&#x63;&#111;&#109;&#93;&#x28;&#x29;">&#91;&#106;&#101;&#46;&#x2e;&#x2e;&#x40;&#108;&#x69;&#118;&#101;&#46;&#x63;&#111;&#109;&#93;&#x28;&#x29;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#109;&#97;&#105;&#x6c;&#116;&#111;&#x3a;&#x5b;&#x63;&#x68;&#x65;&#x6e;&#103;&#x75;&#x61;&#x6e;&#x63;&#x68;&#x2e;&#46;&#46;&#x40;&#103;&#109;&#97;&#x69;&#x6c;&#46;&#x63;&#x6f;&#109;&#x5d;&#40;&#41;">&#x5b;&#x63;&#x68;&#x65;&#x6e;&#103;&#x75;&#x61;&#x6e;&#x63;&#x68;&#x2e;&#46;&#46;&#x40;&#103;&#109;&#97;&#x69;&#x6c;&#46;&#x63;&#x6f;&#109;&#x5d;&#40;&#41;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#109;&#97;&#x69;&#x6c;&#x74;&#x6f;&#58;&#91;&#112;&#x6f;&#x6e;&#x2e;&#46;&#x2e;&#64;&#x67;&#x6f;&#111;&#x67;&#108;&#101;&#103;&#114;&#111;&#117;&#112;&#x73;&#x2e;&#x63;&#111;&#109;&#x5d;&#40;&#41;">&#91;&#112;&#x6f;&#x6e;&#x2e;&#46;&#x2e;&#64;&#x67;&#x6f;&#111;&#x67;&#108;&#101;&#103;&#114;&#111;&#117;&#112;&#x73;&#x2e;&#x63;&#111;&#109;&#x5d;&#40;&#41;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>...</p>
<p>阅读更多 &gt;&gt;
<a href="">显示删减掉的内容</a>
<img src="" alt=""> Alleluia <img src="" alt=""></p>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>Microsoft Accelerator稍稍看了一下这个东西,是05年的工作.这个东西其实已经不新鲜了.大概跟PyCUDA
array-processing operations such as those which frequently arise in
domains.
但是我要说的是,这个领域相对于真正需要的并行计算实在是太少太少.比如说他强调的 image processing and
scientific computing,当中很多非线性滤波的并行算法就不能用这个架构来做.</p>
<p>On 3月22日, 上午9时42分, &quot;Jeffrey Zhao&quot; <a href="&#x6d;&#97;&#x69;&#108;&#116;&#111;&#x3a;&#91;&#x6a;&#x65;&#46;&#x2e;&#x2e;&#64;&#x6c;&#105;&#118;&#x65;&#x2e;&#99;&#x6f;&#x6d;&#93;&#x28;&#41;">&#91;&#x6a;&#x65;&#46;&#x2e;&#x2e;&#64;&#x6c;&#105;&#118;&#x65;&#x2e;&#99;&#x6f;&#x6d;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>哈哈，广告好，扩展视野，那我继续做广告了......</p>
<p>微软其实很早就在搞Microsoft Accelerator项目，旨在利用DirectX进行计算，.NET项目。<a href="http://research.microsoft.com/en-us/projects/Accelerator/" target="_blank"><a href="http://research.microsoft.com/en-us/projects/Accelerator/">http://research.microsoft.com/en-us/projects/Accelerator/</a></a></p>
<p>然后F/#这边由于语言的支持良好，可以设计出丰富的表达式、DSL等Modeling Language，再由框架进行自动并行，解决问题可以很容易（已经2.0了）。</p>
<p>这篇文章是个简单介绍：<a href="http://strangelights.com/blog/archive/2008/09/21/1628.aspx" target="_blank"><a href="http://strangelights.com/blog/archive/2008/09/21/1628.aspx">http://strangelights.com/blog/archive/2008/09/21/1628.aspx</a></a></p>
<p>Microsoft Solver Foundation<a href="http://[code.msdn.microsoft.com/solverfoundation](http://code.msdn.microsoft.com/solverfoundation" target="_blank">http://[code.msdn.microsoft.com/solverfoundation](http://code.msdn.microsoft.com/solverfoundation</a>)</p>
<p>F/# Optimization Modeling Language Utilizing Microsoft Solver Foundation<a href="http://[code.msdn.microsoft.com/solverfoundationfs1](http://code.msdn.microsoft.com/solverfoundationfs1" target="_blank">http://[code.msdn.microsoft.com/solverfoundationfs1](http://code.msdn.microsoft.com/solverfoundationfs1</a>)</p>
<p>现在就等OpenCL如果有标准出来，肯定立马可以跟上个类库，哦耶。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p>From: Tinyfool
Sent: Monday, March 22, 2010 9:20 AM
To: <a href="">pon...@googlegroups.com</a>
Subject: Re: [TL] {技术}{多线程}实施并行编程的五大障碍</p>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#x6d;&#x61;&#x69;&#108;&#116;&#x6f;&#x3a;&#x5b;&#106;&#x65;&#x2e;&#46;&#x2e;&#x40;&#108;&#x69;&#x76;&#101;&#46;&#99;&#x6f;&#x6d;&#93;&#40;&#41;">&#x5b;&#106;&#x65;&#x2e;&#46;&#x2e;&#x40;&#108;&#x69;&#x76;&#101;&#46;&#99;&#x6f;&#x6d;&#93;&#40;&#41;</a></p>
<p>  我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>  其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>  例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>  至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>  例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>  Jeffrey Zhao
  Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
  Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p>  From: Guancheng Chen
  Sent: Monday, March 22, 2010 7:37 AM
  To: TopLanguage
  Subject: [TL] {技术}{多线程}实施并行编程的五大障碍</p>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>&gt;</p>
<blockquote>
<p>  近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
  碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
  (fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
  Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
  的看法。</p>
<p>  ( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看
 <a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
  )</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
</li>
<li><p>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</p>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，</p>
<p>Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
</li>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
...</p>
</li>
</ol>
<p>阅读更多 &gt;&gt;
<a href="">显示删减掉的内容</a></p>
</blockquote>
<p><img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>您的观点很有新意，我以前没有过用IO来区分Concurrency和Parallelism的想法，我猜测可能跟您的网络/通信背景有关。其实我觉得
从广义上来讲Parallelism和Concurrency是基本重合的两个概念，只不过可能Concurrency稍微偏工程一点，
Parallelism稍微偏研究一点。例如Herb Sutter要出的新书叫Effective Concurrency,而市面上其他讲并行计算
的书不少也使用Parallel相关的词汇。</p>
<p>另外您这句话我有些不赞同：&quot;颗粒度越小的并行获得的计算资源的利用率也就越大加速比就越大&quot;，拿一个计算密集型的嵌套循环举例，对比并行外层循环和并
行内层循环，无疑你在并行化外层循环时的性能加速比更好，而这时候你的并行度是粗粒度的(内循环并行相对来说是细粒度的)。当然，粗/细粒度的选择确实
是个tradeoff，拿锁竞争来说，细粒度的锁意味着更好的Scalability，但是你加锁/解锁的次数相比组粒度所来说增加了，而这种加锁/解
锁的操作是有开销的，所以需要在锁操作本身的开销和程序的Scalability中做一个平衡。</p>
<p>多谢指教！</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>On 3月22日, 上午10时19分, Alleluia <a href="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#111;&#x3a;&#91;&#x61;&#108;&#x6c;&#117;&#108;&#46;&#46;&#x2e;&#x40;&#103;&#x6d;&#97;&#x69;&#108;&#46;&#99;&#111;&#109;&#x5d;&#x28;&#41;">&#91;&#x61;&#108;&#x6c;&#117;&#108;&#46;&#46;&#x2e;&#x40;&#103;&#x6d;&#97;&#x69;&#108;&#46;&#99;&#111;&#109;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>Concurrency 说到底纯粹就是一个IO问题.而IO问题本质上是和计算完全无关的事情,不存在能不能行可不可计算的问题.因此它相对来说非常
单纯。他更多的是一种类似时钟同步的问题,如果你把IO事件想像成一种时钟信号.其实时钟本来也就是一堆信号而已.如果你做过Circuit 的东西就
会明白,IO只是在不同的时序下进行数据采样.比如最简单的同步时钟,所有的时序电路公用一个时钟,把不同的电路安排在不同的时序边沿上触发.当然更复
杂异步逻辑的道理也是一样的.放到宏观的Concurrency的问题的实质并没有多大改变,只不过CPU依靠PC指针的移动把这种电路上的时序处理软
件化了.</p>
<p>而Parallelism更多的是需要考虑计算问题同时还要兼顾IO.Parallelism首先要回答的是一个东西是不是可并行的.回答完这个问题
后,如果可并行那么在什么样的硬件设备上并行是最合适的这样一个问题.在Parallelism中需要考虑的的IO也不仅仅是来自于网络更多是,缓存,
内存,磁盘,总线等等.其实我觉得,在Parallelism下你总是处于一个矛盾状态,颗粒度越小的并行获得的计算资源的利用率也就越大加速比就越
大,但是同时通信系统的工作也就越是繁忙整个运算过程浪费在通信消耗上的时间也就越多.
这个当中的tradeoff是非常困难的.很多时候速度不快,完全不是因为你的核心不够多,而是你的通信速度不够高.</p>
<p>On 3月22日, 下午3时21分, Guancheng Chen <a href="&#109;&#x61;&#x69;&#x6c;&#116;&#111;&#x3a;&#x5b;&#99;&#x68;&#101;&#x6e;&#103;&#x75;&#97;&#x6e;&#x63;&#104;&#x2e;&#46;&#46;&#x40;&#103;&#109;&#x61;&#105;&#108;&#46;&#x63;&#x6f;&#109;&#x5d;&#40;&#41;">&#x5b;&#99;&#x68;&#101;&#x6e;&#103;&#x75;&#97;&#x6e;&#x63;&#104;&#x2e;&#46;&#46;&#x40;&#103;&#109;&#x61;&#105;&#108;&#46;&#x63;&#x6f;&#109;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>绝大部分的观点Can&#39;t agree more.其实这也是为什么我引用了高老爷子那段话的原因，因为程序的本质就是数据结构和算法，你要没有非常适
合并行的算法那简直就是巧妇难为无米之炊。但是有疑问的一点是关于Parallelism和Concurrency这两个单词的区别，实际上这也是非常
有意思的一件事情，Sun的多线程指南上写的是： Parallelism is a condition that arises when at
least two threads are executing simultaneously, while concurrency is a
condition that exists when at least two threads are making progress.
Therefore concurrency is a more generalized form of parallelism that
can include time-slicing as a form of virtual parallelism.不知道您怎么看？</p>
<p>On 3月22日, 上午8时06分, Alleluia <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#x3a;&#91;&#x61;&#108;&#108;&#x75;&#x6c;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#109;&#x61;&#105;&#108;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#40;&#41;">&#91;&#x61;&#108;&#108;&#x75;&#x6c;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#109;&#x61;&#105;&#108;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>Parallelism 说到底是算法问题.Parallelism与Concurrency不同,Concurrency所面对的问题相对的单一可以
让一群有经验的专家来实现一套通用库或者语言来提供一个基本的编程框架.而在Parallelism上,具体的不同问题,其所需要并行的算法是根本不同
的.原因在于不同的问题,其内部的DataDependency的结构完全不同,不同的Data Dependency的结构,需要构造不同的算法.即
便是相同的Data Dependency,在不同的颗粒度下，在不同的硬件条件下所采用的算法也是完全不同的.因为一旦出现Data
Dependency也就意味着并行计算模块之间需要进行通信.从以计算节点为单位的分布式并行,到多核CPU上的Numa结构,到SIMD上的向量处
理器,其计算单元之间的通信手段,通信效率简直天差地别.比如说,在SMP上最常见的并行算法,work stealing也就是Intel的TBB,
是建立在两个条件下第一个是CPU的Cache机制上,这使得通常在内存的之间的数据搬运消耗非常小,第二个是SMP上计算单元相对的少,因此每个计算
单元被分配到的任务就相对的重。其开销远远大于通信的开销,因此这种机制在SMP上相对的划算.但是如果你要在GPU上做Work Stealing就
完全不可行,因为GPU的运算单元数量极多,被分配到的任务就相对来说的非常轻量,CUDA上的一个thread很多时候运算一次的时间不会超过
10us,而一次跨Block的线程之间的通信开销就往往要达到100us左右,再加上目前GPU上的Cache机制非常落后导致了需要频繁的通信开销
的Work Stealing在GPU上是非常不划算得.
所以我个人认为在硬件架构没有更多的突破之前,OpenCL这种东西是没有任何生命力的.不要说CPU的并行与GPU之间差异巨大,就是不同的GPU之
间AMD与Nvidia两个也是各自为政,一个平台上跑得非常快的东西,在另外一个平台极大的可能是龟速.其最终的结果估计就是跟Java的
write once run everywhere一样是个大笑话.</p>
<p>On 3月22日, 下午2时06分, Guancheng Chen <a href="&#x6d;&#x61;&#105;&#x6c;&#x74;&#x6f;&#x3a;&#91;&#x63;&#x68;&#101;&#x6e;&#103;&#x75;&#97;&#x6e;&#99;&#x68;&#x2e;&#x2e;&#46;&#x40;&#103;&#x6d;&#97;&#x69;&#108;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#x29;">&#91;&#x63;&#x68;&#101;&#x6e;&#103;&#x75;&#97;&#x6e;&#99;&#x68;&#x2e;&#x2e;&#46;&#x40;&#103;&#x6d;&#97;&#x69;&#108;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>On 3月22日, 上午2时20分, Tinyfool <a href="&#109;&#x61;&#x69;&#108;&#x74;&#x6f;&#x3a;&#91;&#116;&#x69;&#x6e;&#x79;&#102;&#x2e;&#46;&#46;&#x40;&#x67;&#109;&#97;&#x69;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#x28;&#41;">&#91;&#116;&#x69;&#x6e;&#x79;&#102;&#x2e;&#46;&#46;&#x40;&#x67;&#109;&#97;&#x69;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#109;&#97;&#105;&#108;&#116;&#x6f;&#x3a;&#x5b;&#106;&#101;&#46;&#x2e;&#x2e;&#64;&#108;&#x69;&#118;&#101;&#46;&#99;&#111;&#x6d;&#93;&#x28;&#41;">&#x5b;&#106;&#101;&#46;&#x2e;&#x2e;&#64;&#108;&#x69;&#118;&#101;&#46;&#99;&#111;&#x6d;&#93;&#x28;&#41;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#x6d;&#97;&#x69;&#108;&#x74;&#x6f;&#x3a;&#91;&#99;&#x68;&#101;&#110;&#x67;&#117;&#x61;&#110;&#99;&#x68;&#46;&#46;&#46;&#x40;&#103;&#x6d;&#97;&#105;&#x6c;&#46;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#41;">&#91;&#99;&#x68;&#101;&#110;&#x67;&#117;&#x61;&#110;&#99;&#x68;&#46;&#46;&#46;&#x40;&#103;&#x6d;&#97;&#105;&#x6c;&#46;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#41;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#x6d;&#x61;&#105;&#x6c;&#116;&#111;&#58;&#x5b;&#112;&#111;&#110;&#46;&#46;&#x2e;&#64;&#103;&#x6f;&#111;&#103;&#108;&#x65;&#103;&#114;&#111;&#x75;&#x70;&#x73;&#46;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#41;">&#x5b;&#112;&#111;&#110;&#46;&#46;&#x2e;&#64;&#103;&#x6f;&#111;&#103;&#108;&#x65;&#103;&#114;&#111;&#x75;&#x70;&#x73;&#46;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#41;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也...</p>
</li>
</ol>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>阅读更多 &gt;&gt;
<a href="">显示删减掉的内容</a>
<img src="" alt=""> Googol Lee <img src="" alt=""></p>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>彻底来晚了......我是来广告golang的！大并发IO还是csp模型的语言更靠谱！</p>
<p>不过golang在cpu密集的并发上不知道效果会怎么样，就现在的表现来看比erlang好，但还赶不上c/c++</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>On Mar 22, 9:20 am, Tinyfool <a href="&#109;&#97;&#105;&#108;&#x74;&#111;&#x3a;&#x5b;&#x74;&#x69;&#x6e;&#121;&#x66;&#46;&#x2e;&#x2e;&#x40;&#103;&#109;&#97;&#105;&#108;&#x2e;&#99;&#111;&#109;&#x5d;&#x28;&#41;">&#x5b;&#x74;&#x69;&#x6e;&#121;&#x66;&#46;&#x2e;&#x2e;&#x40;&#103;&#109;&#97;&#105;&#108;&#x2e;&#99;&#111;&#109;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#109;&#x61;&#105;&#108;&#116;&#x6f;&#58;&#x5b;&#106;&#x65;&#x2e;&#46;&#x2e;&#x40;&#108;&#x69;&#x76;&#101;&#x2e;&#x63;&#111;&#109;&#x5d;&#x28;&#x29;">&#x5b;&#106;&#x65;&#x2e;&#46;&#x2e;&#x40;&#108;&#x69;&#x76;&#101;&#x2e;&#x63;&#111;&#109;&#x5d;&#x28;&#x29;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#109;&#97;&#105;&#108;&#x74;&#111;&#58;&#x5b;&#x63;&#x68;&#101;&#x6e;&#x67;&#x75;&#97;&#x6e;&#x63;&#104;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#109;&#97;&#105;&#108;&#x2e;&#x63;&#111;&#109;&#x5d;&#x28;&#x29;">&#x5b;&#x63;&#x68;&#101;&#x6e;&#x67;&#x75;&#97;&#x6e;&#x63;&#104;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#109;&#97;&#105;&#108;&#x2e;&#x63;&#111;&#109;&#x5d;&#x28;&#x29;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#x6d;&#97;&#x69;&#108;&#116;&#111;&#x3a;&#x5b;&#112;&#x6f;&#110;&#46;&#46;&#46;&#64;&#x67;&#x6f;&#x6f;&#103;&#x6c;&#101;&#103;&#x72;&#111;&#117;&#x70;&#115;&#x2e;&#99;&#111;&#x6d;&#93;&#x28;&#x29;">&#x5b;&#112;&#x6f;&#110;&#46;&#46;&#46;&#64;&#x67;&#x6f;&#x6f;&#103;&#x6c;&#101;&#103;&#x72;&#111;&#117;&#x70;&#115;&#x2e;&#99;&#111;&#x6d;&#93;&#x28;&#x29;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄</p>
</li>
</ol>
</blockquote>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<blockquote>
<blockquote>
<p>了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。</p>
</li>
</ol>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>--
Tinyfool的开发日记<a href="http://www.tinydust.net/dev/" target="_blank"><a href="http://www.tinydust.net/dev/">http://www.tinydust.net/dev/</a></a>
代码中国网<a href="http://www.codechina.org/" target="_blank"><a href="http://www.codechina.org">http://www.codechina.org</a></a>
myTwitter:<a href="http://twitter.com/tinyfool" target="_blank"><a href="http://twitter.com/tinyfool">http://twitter.com/tinyfool</a></a>
<a href="">显示删减掉的内容</a></p>
</blockquote>
<p><img src="" alt=""> Jeffrey Zhao <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>锟斤拷锟斤拷锟斤拷F/#锟斤拷锟斤拷锟斤拷锟斤拷锟揭伙拷锟斤拷锟斤拷诺姆锟绞斤拷锟绞碉拷锟紺SP锟侥★拷</p>
<p>锟斤拷锟斤拷锟斤拷锟斤拷锟节达拷锟斤拷院锟节诧拷锟斤拷锟斤拷锟斤拷锟较斤拷锟斤拷F/#锟狡广，锟斤拷锟斤拷锟斤拷</p>
<p>Jeffrey Zhao
Blog: <a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter: @jeffz_cn</p>
<hr>
<p>From: &quot;Googol Lee&quot; <a href="&#109;&#x61;&#105;&#108;&#x74;&#x6f;&#58;&#x5b;&#x67;&#x6f;&#111;&#103;&#46;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#40;&#x29;">&#x5b;&#x67;&#x6f;&#111;&#103;&#46;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#40;&#x29;</a>
Sent: Monday, March 22, 2010 8:30 PM
To: &quot;TopLanguage&quot; <a href="&#109;&#x61;&#105;&#108;&#x74;&#x6f;&#x3a;&#91;&#x70;&#111;&#110;&#x2e;&#x2e;&#46;&#64;&#x67;&#x6f;&#x6f;&#103;&#x6c;&#101;&#x67;&#114;&#111;&#117;&#112;&#115;&#46;&#x63;&#111;&#109;&#x5d;&#40;&#41;">&#91;&#x70;&#111;&#110;&#x2e;&#x2e;&#46;&#64;&#x67;&#x6f;&#x6f;&#103;&#x6c;&#101;&#x67;&#114;&#111;&#117;&#112;&#115;&#46;&#x63;&#111;&#109;&#x5d;&#40;&#41;</a>
Subject: [TL] Re: {锟斤拷锟斤拷}{锟斤拷锟竭筹拷}实施锟斤拷锟叫憋拷痰锟斤拷锟斤拷锟较帮拷</p>
<blockquote>
<p>锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷......锟斤拷锟斤拷锟斤拷锟斤拷锟絞olang锟侥ｏ拷锟襟并凤拷IO锟斤拷锟斤拷csp模锟酵碉拷锟斤拷锟皆革拷锟阶ｏ拷</p>
<p>锟斤拷锟斤拷golang锟斤拷cpu锟杰硷拷锟侥诧拷锟斤拷锟较诧拷知锟斤拷效锟斤拷锟斤拷锟矫达拷锟斤拷锟斤拷锟节的憋拷锟斤拷锟斤拷锟斤拷锟斤拷erlang锟矫ｏ拷锟斤拷锟斤拷锟较诧拷锟斤拷c/c++</p>
<p>On Mar 22, 9:20 am, Tinyfool <a href="&#109;&#97;&#105;&#108;&#x74;&#x6f;&#x3a;&#x5b;&#x74;&#x69;&#110;&#x79;&#x66;&#x2e;&#x2e;&#46;&#x40;&#103;&#x6d;&#97;&#105;&#108;&#x2e;&#99;&#111;&#109;&#x5d;&#x28;&#41;">&#x5b;&#x74;&#x69;&#110;&#x79;&#x66;&#x2e;&#x2e;&#46;&#x40;&#103;&#x6d;&#97;&#105;&#108;&#x2e;&#99;&#111;&#109;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷模锟斤拷锟饺伙拷越锟斤拷冒锟斤拷锟斤拷锟剿ｏ拷锟斤拷也锟斤拷锟斤拷锟揭伙拷锟�</p>
<p>Mac OS X锟斤拷锟铰的诧拷锟叫伙拷锟狡斤拷锟斤拷GCD锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟街撅拷知锟斤拷锟睫憋拷强锟斤拷锟剿吧ｏ拷</p>
<p>锟斤拷锟斤拷支锟斤拷锟皆匡拷锟斤拷锟斤拷锟絆penCL也锟斤拷锟睫憋拷强锟襟啊★拷</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#x6d;&#x61;&#x69;&#108;&#116;&#x6f;&#58;&#x5b;&#x6a;&#x65;&#x2e;&#x2e;&#x2e;&#64;&#108;&#105;&#118;&#x65;&#x2e;&#99;&#111;&#x6d;&#x5d;&#40;&#x29;">&#x5b;&#x6a;&#x65;&#x2e;&#x2e;&#x2e;&#64;&#108;&#105;&#118;&#x65;&#x2e;&#99;&#111;&#x6d;&#x5d;&#40;&#x29;</a></p>
<blockquote>
<p> 锟斤拷锟斤拷锟斤拷锟斤拷妫猴拷锟斤拷瞬锟斤拷锌狻拷锟斤拷锟紽/#锟斤拷锟斤拷锟斤拷锟皆碉拷支锟街ｏ拷锟斤拷锟叫憋拷锟斤拷丫锟斤拷锟斤拷缀芏锟斤拷恕锟斤拷锟斤拷锟叫э拷剩锟街达拷锟叫э拷剩锟斤拷锟轿拷锟斤拷远锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟竭★拷</p>
<p>锟斤拷实锟斤拷锟斤拷&quot;锟斤拷锟斤拷&quot;锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷茫锟街灰拷锟脚ｏ拷税锟斤拷锟斤拷壮锟斤拷锟斤拷锟侥讹拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷装锟斤拷锟斤拷锟斤拷锟斤拷一锟斤拷锟斤拷锟矫的筹拷锟襟，对大部分筹拷锟斤拷员锟斤拷说锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷唷�</p>
<p>锟斤拷锟斤拷Memory Consistency锟斤拷锟斤拷JVM锟斤拷CLR锟斤拷锟斤拷锟节革拷CPU锟杰癸拷锟斤拷统一锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷没锟叫诧拷锟叫匡拷锟街э拷郑锟叫达拷锟斤拷谐锟斤拷锟斤拷丫锟斤拷锟斤拷锟斤拷锟斤拷珊芏锟斤拷恕锟�</p>
<p>锟斤拷锟节斤拷锟斤拷锟斤拷......锟揭撅拷锟斤拷锟斤拷实锟斤拷锟斤拷锟斤拷獾癸拷锟斤拷遣锟斤拷锟斤拷锟斤拷械模锟揭诧拷锟斤拷遣锟斤拷锟斤拷锟斤拷锟斤拷锟街的革拷祝锟斤拷锟斤拷牵锟斤拷锟斤拷冢锟斤拷锟斤拷锟斤拷锟矫伙拷锟斤拷锟斤拷吮锟斤拷锟斤拷锟矫★拷</p>
<p>锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷系锟结构锟斤拷锟斤拷锟斤拷系统锟饺等★拷锟斤拷锟斤拷然锟酵诧拷锟斤拷锟叫关ｏ拷锟斤拷也锟斤拷锟角诧拷锟斤拷锟斤拷锟叫的讹拷锟斤拷锟斤拷</p>
</blockquote>
</blockquote>
<p>&gt;</p>
<blockquote>
<blockquote>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#109;&#x61;&#x69;&#x6c;&#x74;&#111;&#x3a;&#91;&#99;&#104;&#x65;&#110;&#x67;&#x75;&#x61;&#110;&#99;&#x68;&#46;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#x69;&#108;&#46;&#x63;&#111;&#109;&#93;&#40;&#x29;">&#91;&#99;&#104;&#x65;&#110;&#x67;&#x75;&#x61;&#110;&#99;&#x68;&#46;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#x69;&#108;&#46;&#x63;&#111;&#109;&#93;&#40;&#x29;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#x6f;&#x3a;&#x5b;&#x70;&#111;&#110;&#46;&#x2e;&#x2e;&#x40;&#103;&#x6f;&#111;&#x67;&#x6c;&#x65;&#103;&#114;&#x6f;&#x75;&#x70;&#x73;&#x2e;&#x63;&#111;&#109;&#93;&#x28;&#x29;">&#x5b;&#x70;&#111;&#110;&#46;&#x2e;&#x2e;&#x40;&#103;&#x6f;&#111;&#x67;&#x6c;&#x65;&#103;&#114;&#x6f;&#x75;&#x70;&#x73;&#x2e;&#x63;&#111;&#109;&#93;&#x28;&#x29;</a>
/<em>Subject:/</em> [TL] {锟斤拷锟斤拷}{锟斤拷锟竭筹拷}实施锟斤拷锟叫憋拷痰锟斤拷锟斤拷锟较帮拷</p>
<p>锟斤拷锟节匡拷锟斤拷一篇锟斤拷锟斤拷Intel锟侥猴拷锟斤拷锟斤拷思锟侥凤拷锟斤拷锟斤拷锟铰ｏ拷锟斤拷锟斤拷锟结到锟斤拷锟斤拷锟斤拷45锟斤拷锟斤拷锟侥革拷锟斤拷司锟斤拷锟斤拷员/锟斤拷锟斤拷锟斤拷锟斤拷/战锟斤拷师锟斤拷锟斤拷&quot;什么锟斤拷实施锟斤拷锟叫憋拷痰锟斤拷锟斤拷锟斤拷
锟斤拷&quot;时锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷乇锟斤拷峒帮拷拇锟斤拷锟斤拷锟洁：锟斤拷锟斤拷锟斤拷锟斤拷(legacy code)锟斤拷锟斤拷锟斤拷(education)锟斤拷锟斤拷锟斤拷(tools)锟斤拷锟斤拷锟节猴拷锟斤拷锟狡的恐撅拷
(fear of many cores)锟皆硷拷锟斤拷维锟斤拷锟斤拷(maintainability)锟斤拷锟斤拷锟斤拷锟斤拷然锟斤拷一篇Intel
Parallel
Studio锟斤拷锟斤拷锟侥ｏ拷锟斤拷锟斤拷锟斤拷锟斤拷锟结及锟斤拷锟斤拷锟斤拷锟斤拷习锟饺达拷浅锟街碉拷锟斤拷锟斤拷郏锟斤拷锟斤拷锟斤拷锟斤拷叶锟斤拷锟斤拷锟斤拷锟较帮拷锟斤拷一些锟斤拷浅锟斤拷锟斤拷锟斤拷希锟斤拷锟斤拷锟斤拷一锟斤拷锟斤拷砖锟斤拷锟斤拷锟斤拷锟斤拷茫锟斤拷锟接拷锟揭革拷锟斤拷锟斤拷锟�
锟侥匡拷锟斤拷锟斤拷</p>
<p>( 注锟斤拷锟斤拷锟斤拷Google Group锟斤拷锟斤拷原锟侥碉拷一些锟斤拷锟斤拷锟接讹拷失效锟剿ｏ拷锟斤拷锟斤拷锟斤拷懈锟矫碉拷锟侥讹拷锟斤拷锟介，锟诫看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>锟斤拷锟斤拷锟斤拷锟斤拷
锟斤拷锟斤拷锟斤拷知锟斤拷锟斤拷锟叫伙拷实施锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷压锟剿撅拷锟斤拷锟叫╋拷锟斤拷锟斤拷锟斤拷锟斤拷锟叫伙拷锟斤拷100K~1000K锟侥达拷锟斤拷锟斤拷锟斤拷锟角筹拷锟斤拷锟斤拷斜锟教憋拷锟斤拷锟斤拷锟角非筹拷锟斤拷锟阶筹拷锟斤拷模锟�
一锟斤拷锟斤拷锟斤拷锟絛ata race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe锟饺碉拷锟斤拷锟斤拷锟斤拷锟斤拷锟揭伙拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟酵凤拷螅锟斤拷说要锟斤拷
效锟缴匡拷锟侥诧拷锟叫伙拷锟斤拷些锟接达拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷恕锟斤拷锟斤拷锟斤拷训锟斤拷呛芏锟斤拷锟斤拷锟斤拷锟斤拷牖癸拷斜锟叫达拷锟斤拷丫锟斤拷锟街帮拷锟斤拷牡锟阶拷筒锟饺拷锟斤拷锟斤拷猓拷锟斤拷锟斤拷锟斤拷锟窖╋拷霞锟剿拷锟斤拷映杀锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷通锟斤拷一
些锟斤拷锟斤拷谋锟斤拷锟斤拷锟�(锟斤拷锟斤拷Intel锟斤拷ICC)锟皆讹拷锟斤拷锟叫伙拷一些锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷省钱锟侥ｏ拷锟斤拷锟斤拷锟斤拷锟街凤拷锟斤拷锟斤拷锟斤拷缺锟捷撅拷锟斤拷锟斤拷锟斤拷Intel ICC锟斤拷锟斤拷锟皆讹拷锟酵憋拷锟斤拷锟斤拷
锟斤拷锟皆讹拷锟斤拷锟叫伙拷锟侥达拷锟斤拷浅锟斤拷伲锟斤拷佣锟斤拷锟斤拷锟斤拷锟斤拷峁╋拷锟斤拷锟斤拷锟斤拷呕锟斤拷浅锟斤拷锟斤拷蓿锟斤拷锟斤拷揖锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷芑锟斤拷speedup锟侥达拷锟斤拷也锟叫很讹拷约锟斤拷锟斤拷锟斤拷(锟斤拷锟斤拷loop锟斤拷循锟斤拷之锟斤拷
没锟斤拷dependence锟斤拷锟斤拷锟揭革拷loop应锟斤拷锟斤拷一锟斤拷锟斤拷锟斤拷锟饺碉拷)锟斤拷锟斤拷锟斤拷目前锟斤拷锟斤拷状锟斤拷锟角达拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟诫并锟斤拷锟斤拷锟斤拷效锟侥憋拷锟斤拷锟叫伙拷锟斤拷锟斤拷锟斤拷业锟侥角讹拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟�
锟斤拷一锟街斤拷锟斤拷锟斤拷锟斤拷锟斤拷诙锟绞憋拷锟斤拷诳锟斤拷倏煽锟斤拷锟酵拷锟绞凳╋拷锟斤拷谢锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟�%~30%锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷么锟斤拷锟斤拷丫锟斤拷锟轿拷锟剿撅拷锟绞★拷锟斤拷锟斤拷杀锟斤拷恕锟�</p>
</li>
<li><p>锟斤拷锟斤拷
锟节讹拷锟斤拷锟斤拷习锟斤拷锟斤拷芫锟斤拷浅锟斤拷锟皆比憋拷锟斤拷锟斤拷斜锟教凤拷锟斤拷慕锟斤拷锟斤拷恕锟斤拷锟绞碉拷锟斤拷斜锟斤拷锟窖撅拷锟叫讹拷锟斤拷十锟斤拷锟斤拷锟绞凤拷耍锟斤拷锟斤拷锟斤拷诙锟斤拷CPU锟斤拷锟斤拷之前锟斤拷些锟斤拷锟叫憋拷潭锟斤拷锟�&quot;专锟斤拷&quot;锟角碉拷锟斤拷
锟竭★拷锟斤拷时锟斤拷牟锟斤拷斜锟教达拷锟斤拷锟斤拷锟节硷拷群锟斤拷锟斤拷锟酵伙拷锟斤拷叻锟斤拷锟斤拷锟斤拷希锟酵拷锟組PI(message
passing model)锟斤拷锟斤拷SMP(锟皆称多处锟斤拷锟斤拷锟斤拷锟斤拷一
锟斤拷锟斤拷锟斤拷锟斤拷锟叫讹拷锟斤拷锟斤拷锟紺PU锟斤拷锟斤拷锟斤拷shared memory model)锟斤拷锟斤拷刹锟斤拷屑锟斤拷恪thread锟斤拷准锟斤拷1995锟疥建锟斤拷锟侥ｏ拷之锟斤拷锟斤拷锟斤拷锟�
Windows锟斤拷锟絎in32 thread锟斤拷锟斤拷锟斤拷锟街筹拷锟斤拷锟斤拷&quot;锟斤拷锟斤拷指锟斤拷&quot;锟斤拷锟斤拷锟斤拷data parallel模锟酵碉拷OpenMP(OpenMP 3.0锟斤拷
锟斤拷锟斤拷task parallel支锟斤拷)锟斤拷task parallel锟侥憋拷锟斤拷Click锟斤拷Intel锟斤拷Intel Thread
Building
Block(task parallel)锟斤拷Java 1.5锟斤拷始锟皆讹拷锟竭筹拷锟结供锟较好碉拷支锟斤拷(锟斤拷锟斤拷锟斤拷Java
Memory Model)锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷
GPU锟侥凤拷展锟斤拷Nvidia锟街匡拷始锟斤拷CUDA(data-parallel)锟斤拷Apple一锟斤拷锟斤拷锟皆ｏ拷锟斤拷锟叫憋拷锟斤拷院锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷业貌锟揭伙拷郑锟斤拷锟斤拷锟斤拷约锟斤拷锟斤拷锟脚�
锟剿革拷锟斤拷锟紺PU锟斤拷GPU锟斤拷媳锟教碉拷OpenCL锟斤拷微锟斤拷一锟斤拷也锟斤拷住锟斤拷也要锟斤拷锟斤拷Visual
Studio2010锟斤拷始锟斤拷C/#锟侥诧拷锟叫库，锟斤拷锟斤拷C++0x也
要锟斤拷锟斤拷锟斤拷叱锟街э拷郑锟斤拷锟斤拷锟斤拷锟斤拷瞎哦锟紼rlang也锟斤拷为锟斤拷锟斤拷支锟街诧拷锟叫憋拷锟斤拷锟斤拷锟饺筹拷锟斤拷锟斤拷之锟斤拷锟斤拷摩锟斤拷锟斤拷锟节达拷锟斤拷锟斤拷锟斤拷锟绞э拷锟斤拷锟斤拷业锟界都锟斤拷始锟斤拷锟斤拷锟斤拷锟叫憋拷谭锟斤拷锟�
展锟斤拷</p>
</li>
</ol>
<p>锟斤拷锟角对筹拷锟斤拷员锟斤拷说锟斤拷锟斤拷什么锟斤拷锟斤拷兀锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟杰的斤拷锟斤拷蠖蓟锟斤拷谴锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷些锟姐法锟斤拷锟斤拷萁峁癸拷锟斤拷叩锟斤拷锟斤拷锟揭黄拷锟教革拷锟剿�&quot;锟斤拷锟揭匡拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟�
锟斤拷硬锟斤拷锟斤拷锟斤拷锟斤拷丫锟斤拷藜瓶锟绞╋拷说锟斤拷碌模锟斤拷锟斤拷墙锟組oore锟斤拷锟斤拷失效锟斤拷锟斤拷锟斤拷锟斤拷锟窖革拷锟斤拷锟斤拷锟斤拷锟斤拷撸锟斤拷锟斤拷锟斤拷歉锟斤拷锟斤拷堑幕锟斤拷锟街伙拷锟斤拷锟侥承┲革拷锟斤拷锟斤拷锟斤拷械酶锟斤拷锟剿讹拷锟窖★拷锟斤拷锟斤拷锟斤拷
锟教碉拷锟诫法锟斤拷证锟斤拷锟斤拷失锟杰的ｏ拷锟斤拷一锟姐都锟斤拷锟斤拷械锟斤拷锟斤拷锟�......锟斤拷锟斤拷说锟斤拷锟叫讹拷锟劫筹拷锟斤拷员锟斤拷锟斤拷锟斤拷未锟斤拷一片锟斤拷锟斤拷锟侥伙拷锟斤拷锟斤拷锟斤拷强锟揭碉拷锟斤拷趣锟斤拷锟揭硷拷锟斤拷没锟斤拷锟斤拷说锟斤拷锟斤拷锟斤拷锟斤拷堑锟斤拷呖唷�
锟斤拷锟斤拷锟斤拷锟斤拷学院锟斤拷些锟斤拷硬锟斤拷锟侥家伙拷一直锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟角达拷锟�&quot;锟斤拷锟缴硷拷硬锟斤拷锟斤拷展锟斤拷锟斤拷锟斤拷锟斤拷转锟斤拷直锟接碉拷锟铰筹拷锟斤拷员锟斤拷锟斤拷训锟斤拷锟斤拷锟窖撅拷锟斤拷锟斤拷锟剿★拷锟斤拷么锟斤拷锟斤拷员锟斤拷锟斤拷锟杰碉拷锟斤拷锟矫碉拷
锟斤拷锟叫憋拷探锟斤拷锟斤拷锟斤拷穑亢锟斤拷锟饺伙拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷一锟斤拷锟斤拷通锟侥筹拷锟斤拷员锟斤拷&quot;锟斤拷锟斤拷貌锟斤拷斜锟斤拷锟斤拷锟斤拷么锟斤拷&quot;锟斤拷十锟叫八九伙拷说&quot;锟揭撅拷锟矫猴拷锟斤拷&quot;锟斤拷前一锟斤拷锟斤拷锟斤拷锟斤拷锟桔凤拷锟斤拷锟斤拷锟斤拷锟斤拷枚锟斤拷叱锟�
锟矫伙拷锟角讹拷锟教好ｏ拷锟斤拷实锟斤拷原锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷露锟斤拷叱锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷疲锟斤拷锟斤拷锟絠solation锟侥讹拷锟斤拷模式锟斤拷锟斤拷programming productivity
锟斤拷performance之锟斤拷锟揭碉拷锟饺较好碉拷锟斤拷锟皆ｏ拷锟斤拷锟皆癸拷锟节猴拷锟叫凤拷锟斤拷锟斤拷锟斤拷锟斤拷锟竭讹拷选锟斤拷锟剿讹拷锟斤拷(锟斤拷锟斤拷锟狡凤拷)锟斤拷锟接达拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟叫撅拷锟斤拷系锟斤拷模锟斤拷锟斤拷锟叫�
OS/Compiler锟侥ｏ拷锟斤拷锟角讹拷锟斤拷锟斤拷锟斤拷锟皆的ｏ拷锟斤拷锟节讹拷锟节伙拷努锟斤拷锟斤拷为锟斤拷锟侥筹拷锟斤拷员锟结供一锟斤拷锟斤拷锟斤拷锟斤拷使锟矫的诧拷锟叫憋拷锟侥ｏ拷停锟絀ntel锟解几锟疥不也锟节革拷锟斤拷锟斤拷
训么锟斤拷锟解都锟角猴拷锟斤拷锟襟，碉拷锟角ｏ拷锟斤拷锟斤拷锟斤拷锟饺拷锟斤拷斜锟斤拷时锟斤拷锟斤拷锟洁当锟斤拷锟斤拷路要锟竭★拷锟斤拷锟斤拷锟絀T锟斤拷锟斤拷锟斤拷锟斤拷锟介单锟斤拷锟斤拷锟斤拷锟斤拷胁锟斤拷斜锟教碉拷锟介籍锟斤拷锟角革拷锟杰好碉拷写锟秸★拷</p>
<ol>
<li>锟斤拷锟斤拷
锟斤拷锟斤拷锟斤拷锟斤拷锟铰ｏ拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷么锟街阶讹拷锟斤拷锟斤拷锟斤拷锟矫的ｏ拷锟斤拷锟揭猴拷锟矫的诧拷锟叫憋拷坦锟斤拷锟斤拷卸锟斤拷锟斤拷兀锟斤拷锟接拷锟揭诧拷锟戒）锟斤拷</li>
</ol>
<p>(1) IDE: Intel Parallel Studio锟斤拷微锟斤拷锟斤拷锟较筹拷锟斤拷锟斤拷VS2010锟斤拷一锟斤拷锟斤拷Sun锟斤拷Sun
Studio(锟斤拷知锟斤拷锟斤拷锟轿达拷锟斤拷锟�
锟轿ｏ拷锟斤拷锟斤拷锟斤拷锟斤拷锟酵猴拷小锟斤拷)锟斤拷Nvidia锟斤拷CUDA平台什么锟侥撅拷锟饺诧拷锟斤拷锟斤拷
(2) Compiler: Intel锟斤拷ICC(锟斤拷锟皆讹拷锟斤拷锟叫伙拷一些锟斤拷锟斤拷)锟斤拷Nema Labs锟斤拷FASThread(锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟侥斤拷锟斤拷锟斤拷锟斤拷锟斤拷芸锟斤拷锟�
锟缴匡拷锟斤拷指锟斤拷锟斤拷锟斤拷员实施锟斤拷锟叫伙拷)
(3) Performance Tuning: Intel Vtune Analyzer(锟桔猴拷锟斤拷锟杰凤拷锟斤拷)锟斤拷Thread
profiler锟斤拷
Acumem锟斤拷Thread Spotter(锟斤拷远锟斤拷Cache锟斤拷锟斤拷锟杰凤拷锟斤拷锟斤拷锟脚伙拷)
(4) Debugging: Petra锟斤拷Jinx</p>
<p>锟斤拷锟斤拷锟斤拷锟揭革拷锟剿撅拷锟斤拷锟斤拷锟角对筹拷锟斤拷员锟斤拷说确实锟斤拷锟矫ｏ拷锟斤拷锟斤拷前锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷要锟斤拷锟矫★拷锟斤拷锟斤拷实锟街革拷诙锟斤拷锟�&quot;锟斤拷锟斤拷&quot;锟叫很达拷锟较碉拷恕锟�</p>
<ol>
<li><p>锟斤拷锟节核的恐撅拷
锟斤拷锟斤拷锟斤拷锟角匡拷锟斤拷4锟斤拷锟窖撅拷锟角筹拷锟秸憋拷锟剿ｏ拷锟饺癸拷锟斤拷锟角可撅拷锟斤拷8锟剿ｏ拷16锟剿ｏ拷32锟斤拷锟剿★拷锟斤拷锟斤拷确锟斤拷锟斤拷拇锟斤拷锟斤拷诤锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷泻芎玫锟斤拷锟斤拷埽锟斤拷芎玫目锟斤拷锟斤拷锟斤拷裕锟斤拷锟�
锟斤拷锟斤拷歉锟斤拷锟斤拷狻ｏ拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷芯锟斤拷锟斤拷嵌锟斤拷叱坛锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟杰凤拷锟斤拷锟斤拷目锟侥撅拷锟斤拷为锟剿帮拷锟斤拷锟斤拷锟皆憋拷锟矫的斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟缴碉拷锟斤拷锟斤拷瓶锟斤拷锟斤拷实锟斤拷锟较ｏ拷为锟剿得碉拷锟杰好碉拷
锟斤拷锟斤拷锟斤拷锟皆ｏ拷锟斤拷锟斤拷员锟斤拷要锟斤拷锟斤拷锟斤拷要使锟矫诧拷锟斤拷锟窖好碉拷锟斤拷萁峁�(锟斤拷锟斤拷concurrent hash
map)锟斤拷使锟斤拷细锟斤拷锟饺碉拷锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟教ｏ拷锟斤拷锟絛ata
parallel锟斤拷锟姐法锟斤拷锟斤拷锟杰碉拷锟斤拷(锟斤拷锟斤拷锟斤拷偷锟絝alse sharing锟斤拷锟斤拷)锟饺等等等ｏ拷锟斤拷锟斤拷锟斤拷每一锟筋都锟角诧拷小锟斤拷锟斤拷战锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷一篇锟斤拷锟铰讹拷锟斤拷锟�
锟斤拷锟竭程筹拷锟斤拷锟结供锟斤拷一些锟斤拷锟矫的斤拷锟介。</p>
</li>
<li><p>锟斤拷维锟斤拷锟斤拷
锟斤拷锟斤拷锟斤拷锟绞ｏ拷锟斤拷锟斤拷希锟斤拷锟叫达拷锟斤拷锟杰癸拷锟斤拷锟街达拷锟絩untime系统锟斤拷build系统锟皆硷拷锟斤拷锟斤拷锟斤拷锟叫达拷锟斤拷一锟斤拷锟斤拷确锟侥癸拷锟斤拷锟斤拷锟斤拷锟角革拷希锟斤拷锟斤拷些锟斤拷锟叫达拷锟斤拷锟斤拷锟斤拷锟斤拷狻拷锟斤拷锟轿�
锟斤拷锟斤拷锟斤拷锟叫较筹拷锟斤拷锟斤拷锟斤拷锟斤拷锟节★拷锟斤拷锟斤拷锟街阶讹拷锟斤拷锟斤拷锟斤拷锟秸诧拷锟叫憋拷痰某锟斤拷锟皆憋拷锟街拷锟斤拷伲锟斤拷锟斤拷也锟斤拷斜锟斤拷锟斤拷锟斤拷锟斤拷么锟斤拷锟窖ｏ拷锟斤拷锟斤拷锟斤拷锟斤拷锟叫╋拷锟斤拷写锟斤拷锟街伙拷锟斤拷锟揭恍┬⌒★拷母亩锟斤拷锟斤拷锟斤拷锌锟�
锟杰碉拷锟斤拷锟铰碉拷bug锟斤拷锟铰碉拷锟斤拷锟斤拷瓶锟斤拷锟斤拷锟斤拷锟斤拷锟斤拷锟揭伙拷锟斤拷浅锟酵达拷锟斤拷锟斤拷锟介。</p>
</li>
</ol>
</blockquote>
</blockquote>
<p>&gt;</p>
<blockquote>
<blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE
ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>--
Tinyfool锟侥匡拷锟斤拷锟秸硷拷<a href="http://www.tinydust.net/dev/" target="_blank"><a href="http://www.tinydust.net/dev/">http://www.tinydust.net/dev/</a></a>
锟斤拷锟斤拷锟叫癸拷锟斤拷<a href="http://www.codechina.org/" target="_blank"><a href="http://www.codechina.org">http://www.codechina.org</a></a>
myTwitter:<a href="http://twitter.com/tinyfool" target="_blank"><a href="http://twitter.com/tinyfool">http://twitter.com/tinyfool</a></a></p>
</blockquote>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>To unsubscribe from this group, send email to
pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
<p><a href="">显示删减掉的内容</a>
<img src="" alt=""> Lai Jiangshan <img src="" alt=""></p>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>由于内存/cache模型和编译器/cpu的优化, 并行化是不可能通过库来实现的.
我认为最大的障碍是支持并行化的语言.
2010/3/22 Guancheng Chen <a href="&#109;&#x61;&#x69;&#108;&#x74;&#x6f;&#58;&#x5b;&#99;&#104;&#x65;&#x6e;&#x67;&#x75;&#46;&#x2e;&#46;&#64;&#103;&#109;&#97;&#105;&#x6c;&#x2e;&#99;&#111;&#109;&#x5d;&#x28;&#x29;">&#x5b;&#99;&#104;&#x65;&#x6e;&#x67;&#x75;&#46;&#x2e;&#46;&#64;&#103;&#109;&#97;&#105;&#x6c;&#x2e;&#99;&#111;&#109;&#x5d;&#x28;&#x29;</a></p>
<ol>
<li>C语言可以使用pthread等库实现并行化，C++ JAVA等已经会即将支持多线程 所以语言能实现并行化 只是难易问题</li>
<li>是指Shared memory模型，多核共享一条内存总线所以造成带宽问题么？这确实是个问题，不过我感觉硬件商家会负责为你带来越来越多的带
宽，而程序员的任务只是合理的利用好这些给定的带宽</li>
<li>能具体说说哪些误导宣传么？
On 3月22日, 上午1时46分, 陨落雕 <a href="&#x6d;&#97;&#x69;&#108;&#x74;&#x6f;&#x3a;&#91;&#103;&#x65;&#x6f;&#x2e;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#46;&#x63;&#111;&#x6d;&#93;&#40;&#41;">&#91;&#103;&#x65;&#x6f;&#x2e;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#46;&#x63;&#111;&#x6d;&#93;&#40;&#41;</a> wrote:<blockquote>
<p>呃，我想的障碍是: 1. 类C语言的统治地位; 2. 内存带宽不够; 3. 误导性宣传;</p>
</blockquote>
</li>
</ol>
<p>&gt;</p>
<blockquote>
<p>On Mar 21, 7:37 pm, Guancheng Chen <a href="&#x6d;&#x61;&#x69;&#x6c;&#116;&#x6f;&#x3a;&#91;&#x63;&#x68;&#x65;&#110;&#103;&#x75;&#x61;&#x6e;&#x63;&#x68;&#46;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#40;&#41;">&#91;&#x63;&#x68;&#x65;&#110;&#103;&#x75;&#x61;&#x6e;&#x63;&#x68;&#46;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看<a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..</p>
</blockquote>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<blockquote>
<blockquote>
<p>)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a></p>
</li>
</ol>
</blockquote>
</blockquote>
<p><img src="" alt=""> Jeffrey Zhao <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>能详细说说为什么“由于内存/cache模型和编译器/cpu的优化, 并行化是不可能通过库来实现的”吗？</p>
<p>Jeffrey Zhao
Blog: <a href="http://www.cnblogs.com/JeffreyZhao/" title="http://www.cnblogs.com/JeffreyZhao/
CTRL + Click to follow link"><a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter: @jeffz_cn
<strong>From:</strong> <a href="&quot;mailto:eag0628@gmail.com
CTRL + Click to follow link&quot;">Lai Jiangshan</a></p>
<p><strong>Sent:</strong> Monday, March 22, 2010 10:17 PM
<strong>To:</strong> <a href="&quot;mailto:pongba@googlegroups.com
CTRL + Click to follow link&quot;">pon...@googlegroups.com</a></p>
<p><strong>Subject:</strong> Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>由于内存/cache模型和编译器/cpu的优化, 并行化是不可能通过库来实现的.
我认为最大的障碍是支持并行化的语言.
2010/3/22 Guancheng Chen <a href="&#x6d;&#x61;&#105;&#x6c;&#116;&#x6f;&#x3a;&#91;&#99;&#x68;&#x65;&#110;&#x67;&#x75;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#109;&#97;&#105;&#108;&#46;&#x63;&#x6f;&#109;&#x5d;&#x28;&#41;">&#91;&#99;&#x68;&#x65;&#110;&#x67;&#x75;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#109;&#97;&#105;&#108;&#46;&#x63;&#x6f;&#109;&#x5d;&#x28;&#41;</a></p>
<ol>
<li>C语言可以使用pthread等库实现并行化，C++ JAVA等已经会即将支持多线程 所以语言能实现并行化 只是难易问题</li>
<li>是指Shared memory模型，多核共享一条内存总线所以造成带宽问题么？这确实是个问题，不过我感觉硬件商家会负责为你带来越来越多的带
宽，而程序员的任务只是合理的利用好这些给定的带宽</li>
<li>能具体说说哪些误导宣传么？
On 3月22日, 上午1时46分, 陨落雕 <a href="&#x6d;&#x61;&#105;&#x6c;&#116;&#x6f;&#58;&#91;&#x67;&#x65;&#111;&#46;&#46;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#x61;&#x69;&#108;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#40;&#41;">&#91;&#x67;&#x65;&#111;&#46;&#46;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#x61;&#x69;&#108;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#40;&#41;</a> wrote:<blockquote>
<p>呃，我想的障碍是: 1. 类C语言的统治地位; 2. 内存带宽不够; 3. 误导性宣传;</p>
<p>On Mar 21, 7:37 pm, Guancheng Chen <a href="&#x6d;&#97;&#x69;&#108;&#x74;&#x6f;&#58;&#91;&#x63;&#104;&#101;&#x6e;&#x67;&#x75;&#97;&#110;&#x63;&#104;&#46;&#x2e;&#x2e;&#x40;&#103;&#109;&#97;&#105;&#108;&#46;&#x63;&#111;&#109;&#x5d;&#x28;&#41;">&#91;&#x63;&#104;&#101;&#x6e;&#x67;&#x75;&#97;&#110;&#x63;&#104;&#46;&#x2e;&#x2e;&#x40;&#103;&#109;&#97;&#105;&#108;&#46;&#x63;&#111;&#109;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看<a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
</li>
</ol>
</blockquote>
</blockquote>
</li>
</ol>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>您值得是那篇著名的“Threads Cannot be Implemented as a Library”吧？恩，好用的并行语言确实关键，虽然
C++0x和Java都会加入memory model，但是要程序员来手动负责这些事情确实还是挺约束生产力的。</p>
<p>On 3月22日, 下午3时17分, Lai Jiangshan <a href="&#x6d;&#x61;&#x69;&#108;&#116;&#x6f;&#x3a;&#x5b;&#101;&#97;&#103;&#48;&#x2e;&#46;&#46;&#64;&#x67;&#109;&#97;&#x69;&#x6c;&#x2e;&#99;&#111;&#x6d;&#x5d;&#40;&#41;">&#x5b;&#101;&#97;&#103;&#48;&#x2e;&#46;&#46;&#64;&#x67;&#109;&#97;&#x69;&#x6c;&#x2e;&#99;&#111;&#x6d;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>由于内存/cache模型和编译器/cpu的优化, 并行化是不可能通过库来实现的.</p>
<p>我认为最大的障碍是支持并行化的语言.</p>
<p>2010/3/22 Guancheng Chen <a href="&#x6d;&#x61;&#105;&#x6c;&#x74;&#111;&#x3a;&#91;&#x63;&#x68;&#x65;&#110;&#103;&#117;&#x61;&#x6e;&#x63;&#x68;&#x2e;&#46;&#46;&#64;&#x67;&#109;&#97;&#x69;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#93;&#x28;&#41;">&#91;&#x63;&#x68;&#x65;&#110;&#103;&#117;&#x61;&#x6e;&#x63;&#x68;&#x2e;&#46;&#46;&#64;&#x67;&#109;&#97;&#x69;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#93;&#x28;&#41;</a></p>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>&gt;
&gt;
&gt;</p>
<blockquote>
<blockquote>
<ol>
<li>C语言可以使用pthread等库实现并行化，C++ JAVA等已经会即将支持多线程 所以语言能实现并行化 只是难易问题</li>
<li>是指Shared memory模型，多核共享一条内存总线所以造成带宽问题么？这确实是个问题，不过我感觉硬件商家会负责为你带来越来越多的带
宽，而程序员的任务只是合理的利用好这些给定的带宽</li>
<li>能具体说说哪些误导宣传么？</li>
</ol>
<p>On 3月22日, 上午1时46分, 陨落雕 <a href="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#x6f;&#58;&#91;&#x67;&#x65;&#111;&#46;&#46;&#46;&#46;&#64;&#x67;&#x6d;&#x61;&#105;&#x6c;&#46;&#x63;&#111;&#x6d;&#93;&#x28;&#x29;">&#91;&#x67;&#x65;&#111;&#46;&#46;&#46;&#46;&#64;&#x67;&#x6d;&#x61;&#105;&#x6c;&#46;&#x63;&#111;&#x6d;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>呃，我想的障碍是: 1. 类C语言的统治地位; 2. 内存带宽不够; 3. 误导性宣传;</p>
<p>On Mar 21, 7:37 pm, Guancheng Chen <a href="&#x6d;&#x61;&#105;&#x6c;&#116;&#111;&#58;&#x5b;&#x63;&#104;&#101;&#110;&#x67;&#x75;&#x61;&#x6e;&#x63;&#x68;&#x2e;&#46;&#46;&#x40;&#x67;&#x6d;&#97;&#105;&#x6c;&#46;&#99;&#111;&#x6d;&#93;&#x28;&#x29;">&#x5b;&#x63;&#104;&#101;&#110;&#x67;&#x75;&#x61;&#x6e;&#x63;&#x68;&#x2e;&#46;&#46;&#x40;&#x67;&#x6d;&#97;&#105;&#x6c;&#46;&#99;&#111;&#x6d;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看
<a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线</p>
</blockquote>
</blockquote>
<p>程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。</p>
<blockquote>
<blockquote>
<p>尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。</p>
</li>
</ol>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
<a href="">显示删减掉的内容</a></p>
</blockquote>
</blockquote>
<p><img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>主要就是那篇《Threads Cannot be Implemented as a Library》的论文，跟我以前发帖说的
Sequential Consistency，memory model有关</p>
<p>On 3月22日, 下午3时38分, &quot;Jeffrey Zhao&quot; <a href="&#109;&#97;&#x69;&#x6c;&#x74;&#x6f;&#58;&#x5b;&#x6a;&#101;&#x2e;&#x2e;&#46;&#x40;&#x6c;&#105;&#x76;&#x65;&#x2e;&#99;&#x6f;&#109;&#x5d;&#40;&#41;">&#x5b;&#x6a;&#101;&#x2e;&#x2e;&#46;&#x40;&#x6c;&#105;&#x76;&#x65;&#x2e;&#99;&#x6f;&#109;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>能详细说说为什么&quot;由于内存/cache模型和编译器/cpu的优化, 并行化是不可能通过库来实现的&quot;吗？</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter: @jeffz_cn</p>
<p>From: Lai Jiangshan
Sent: Monday, March 22, 2010 10:17 PM
To: <a href="">pon...@googlegroups.com</a>
Subject: Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>由于内存/cache模型和编译器/cpu的优化, 并行化是不可能通过库来实现的.</p>
<p>我认为最大的障碍是支持并行化的语言.</p>
<p>2010/3/22 Guancheng Chen <a href="&#109;&#x61;&#x69;&#x6c;&#x74;&#111;&#x3a;&#x5b;&#99;&#x68;&#x65;&#x6e;&#103;&#117;&#97;&#110;&#99;&#x68;&#46;&#x2e;&#46;&#64;&#x67;&#109;&#97;&#105;&#x6c;&#46;&#99;&#111;&#x6d;&#93;&#x28;&#x29;">&#x5b;&#99;&#x68;&#x65;&#x6e;&#103;&#117;&#97;&#110;&#99;&#x68;&#46;&#x2e;&#46;&#64;&#x67;&#109;&#97;&#105;&#x6c;&#46;&#99;&#111;&#x6d;&#93;&#x28;&#x29;</a></p>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>&gt;</p>
<blockquote>
<ol>
<li>C语言可以使用pthread等库实现并行化，C++ JAVA等已经会即将支持多线程 所以语言能实现并行化 只是难易问题</li>
<li>是指Shared memory模型，多核共享一条内存总线所以造成带宽问题么？这确实是个问题，不过我感觉硬件商家会负责为你带来越来越多的带
宽，而程序员的任务只是合理的利用好这些给定的带宽</li>
<li><p>能具体说说哪些误导宣传么？</p>
<p>On 3月22日, 上午1时46分, 陨落雕 <a href="&#109;&#x61;&#105;&#108;&#116;&#111;&#58;&#91;&#103;&#101;&#x6f;&#x2e;&#x2e;&#46;&#46;&#64;&#x67;&#109;&#97;&#105;&#108;&#x2e;&#x63;&#111;&#x6d;&#93;&#40;&#x29;">&#91;&#103;&#101;&#x6f;&#x2e;&#x2e;&#46;&#46;&#64;&#x67;&#109;&#97;&#105;&#108;&#x2e;&#x63;&#111;&#x6d;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>呃，我想的障碍是: 1. 类C语言的统治地位; 2. 内存带宽不够; 3. 误导性宣传;</p>
<p>On Mar 21, 7:37 pm, Guancheng Chen <a href="&#x6d;&#97;&#105;&#108;&#x74;&#111;&#x3a;&#x5b;&#x63;&#104;&#101;&#x6e;&#x67;&#x75;&#x61;&#x6e;&#x63;&#x68;&#46;&#x2e;&#x2e;&#x40;&#103;&#109;&#97;&#105;&#108;&#x2e;&#99;&#111;&#109;&#93;&#x28;&#41;">&#x5b;&#x63;&#104;&#101;&#x6e;&#x67;&#x75;&#x61;&#x6e;&#x63;&#x68;&#46;&#x2e;&#x2e;&#x40;&#103;&#109;&#97;&#105;&#108;&#x2e;&#99;&#111;&#109;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看<a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。</p>
</li>
</ol>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
</li>
</ol>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> Alleluia <img src="" alt=""></p>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>no no.其实Concurrency和Parallelism完全是两码事情,IO来区分它们其实完全是从最基本的体系结构上来说就是如此的.你把
IO理解为网络通信,磁盘读写就太狭隘了.
比如看这个图
<a href="http://ian--king.javaeye.com/upload/picture/pic/57449/40915ec8-f578-3398-9931-1afa4364a2b9.jpg" target="_blank"><a href="http://ian--king.javaeye.com/upload/picture/pic/57449/40915ec8-f578-3398-9931-1afa4364a2b9.jpg">http://ian--king.javaeye.com/upload/picture/pic/57449/40915ec8-f578-3398-9931-1afa4364a2b9.jpg</a></a>
,我们要计算一个ax^2+bx+c的一元二次方程,左边的是并行计算,右边的是顺序计算.这两者完全就是两个体系结构,我们现在所使用的计算机是右边
那个图是由Control Flow Drive的.左边是Data Flow Drive的是典型的并行计算机的结构.其中最大的区别就是,右边的架
构采用了PC指针和Assignment.Assignment本身不是一个计算过程,仅仅是一次IO操作,从存储器里拿出数据/程序灌入运算器或者相
反.那么Assignment跟Concurrency有什么关系呢?为了响应Assigment这种基础的IO,那么冯结构必须依靠CPU时钟来驱动
PC指针的移动.因此控制流驱动模式构成了CPU响应外界IO的最基本的模式.无论是内存还是磁盘或者网络,CPU要获取外部设备的IO最基本模式,只
能是通过本地时钟触发控制流，周期性发起状态查询.CPU在某个周期向其他设备发送信号，在收到远端设备的反馈信号后计算得出本地代码序列上的程序段地
址,然后移动PC指针指向该地址进行处理。无论是早期的轮询模式还是现在广泛采用的中断方式，其基本的IO模式并没有改变,只不过查询对象由最初的IO
设备演变为中断寄存器.
因此你可以看到,Concurrency其实只是在讨论如何能够利用外设信号与CPU时钟之间的差异,让CPU在一定的时钟周期内尽可能多的响应不同外
设信号。一个通常的程序仅仅只需要通过Assigment响应内存IO,而Concurrency程序需要相应成千上万个外部设备,这仅仅是量上的区别
并没有到任何质上的区别,Concurrency程序本质上仍然是一个顺序执行的程序而已.采用恰当的技术比如完成端口之类的,可以在单核CPU机器上
仅仅采用单线程模型就能得到极高的并发性.当然多核同时处理可以进一步提高并发量,但是这不是必须的.
换一句话说,目前的CPU架构本身就是一种具备了Concurrency能力的顺序型架构.甚至在当初冯诺伊曼设计这个架构的时候,就极力杜绝并行计算
的指令在这种机器上出现在程序里,因为他认为并行执行的指令会让人发疯.而你再看右边的计算机构,与冯结构完全不同.他的计算是彻底并行的,这就是所谓
的数据流驱动.虽然说冯结构本身不利于并行,但是这个体系发展到现在,已经在不同层面上用冯结构模拟数据流计算.往小里说,CPU上最典型的顺序型程序
在微指令层面上有很大一部分就是数据流驱动并行执行的,因为要做OOO.往大了说,并行在若干个独立内核上的线程组之间的互相通信,也是一种数据流驱
动.并行必定是数据流驱动的.这是两者本质上的不同.如果你去看GPU上的并行就更接近这个模型,所有的计算都是分成若干个stage,数据依次从
stage上流过,stage上的并行计算单元对数据进行高密度的并行计算.这就是所谓的流处理器.当然现在的流处理器还是非常的简单,未来的GPU会
像Dataflow machine的方向发展.当然DataFlow machine也有自己的问题，比如说的指令牌粒度太小了，这导致两个重要缺
点，一个是通信代价非常高，另一个是指令牌点火代价很高。而Standford的ImagineGPU流处理器引擎可以看作介于数据流机和指令流机之间
的架构，所作的一个重要权衡就是增加指令牌的粒度，从而减小点火代价和利用赠大的Token粒度去减小通信代价</p>
<p>至于粒度问题,关键是看你的计算资源有多少.比如说CPU目前最多8核,16核.那么你所谓的按照循环来进行并行自然是可行的,但是你放到CUDA上
去,GTX295有250个内核,你为了让他所有的内核处于工作繁忙的状态,就根本不可能按照循环层次来进行并行,在这个上面并行的粒度是需要划分的极
为纤细的。更诡异的是有些算法,处理的数据量很小,但是计算量可能极为庞大.比如一些运动估计算法,在一个16/*16的像素区域内要完成256×256
次sad运算.这种数据量和计算完全非常不成比例的.怎么对并行粒度的进行有效的划分,非常考算法功夫的.并行计算最好是通过算法杜绝锁,这也是非常困
难的地方.</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>On 3月22日, 下午7时04分, Guancheng Chen <a href="&#109;&#x61;&#x69;&#x6c;&#116;&#x6f;&#58;&#x5b;&#x63;&#x68;&#101;&#x6e;&#103;&#x75;&#97;&#110;&#99;&#x68;&#46;&#46;&#46;&#x40;&#103;&#x6d;&#97;&#105;&#108;&#46;&#99;&#111;&#x6d;&#x5d;&#40;&#x29;">&#x5b;&#x63;&#x68;&#101;&#x6e;&#103;&#x75;&#97;&#110;&#99;&#x68;&#46;&#46;&#46;&#x40;&#103;&#x6d;&#97;&#105;&#108;&#46;&#99;&#111;&#x6d;&#x5d;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>您的观点很有新意，我以前没有过用IO来区分Concurrency和Parallelism的想法，我猜测可能跟您的网络/通信背景有关。其实我觉得
从广义上来讲Parallelism和Concurrency是基本重合的两个概念，只不过可能Concurrency稍微偏工程一点，
Parallelism稍微偏研究一点。例如Herb Sutter要出的新书叫Effective Concurrency,而市面上其他讲并行计算
的书不少也使用Parallel相关的词汇。</p>
<p>另外您这句话我有些不赞同：&quot;颗粒度越小的并行获得的计算资源的利用率也就越大加速比就越大&quot;，拿一个计算密集型的嵌套循环举例，对比并行外层循环和并
行内层循环，无疑你在并行化外层循环时的性能加速比更好，而这时候你的并行度是粗粒度的(内循环并行相对来说是细粒度的)。当然，粗/细粒度的选择确实
是个tradeoff，拿锁竞争来说，细粒度的锁意味着更好的Scalability，但是你加锁/解锁的次数相比组粒度所来说增加了，而这种加锁/解
锁的操作是有开销的，所以需要在锁操作本身的开销和程序的Scalability中做一个平衡。</p>
<p>多谢指教！</p>
<p>On 3月22日, 上午10时19分, Alleluia <a href="&#109;&#97;&#x69;&#108;&#x74;&#111;&#58;&#91;&#x61;&#x6c;&#x6c;&#x75;&#x6c;&#46;&#46;&#46;&#64;&#x67;&#109;&#97;&#105;&#x6c;&#46;&#x63;&#111;&#109;&#93;&#x28;&#41;">&#91;&#x61;&#x6c;&#x6c;&#x75;&#x6c;&#46;&#46;&#46;&#64;&#x67;&#109;&#97;&#105;&#x6c;&#46;&#x63;&#111;&#109;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>Concurrency 说到底纯粹就是一个IO问题.而IO问题本质上是和计算完全无关的事情,不存在能不能行可不可计算的问题.因此它相对来说非常
单纯。他更多的是一种类似时钟同步的问题,如果你把IO事件想像成一种时钟信号.其实时钟本来也就是一堆信号而已.如果你做过Circuit 的东西就
会明白,IO只是在不同的时序下进行数据采样.比如最简单的同步时钟,所有的时序电路公用一个时钟,把不同的电路安排在不同的时序边沿上触发.当然更复
杂异步逻辑的道理也是一样的.放到宏观的Concurrency的问题的实质并没有多大改变,只不过CPU依靠PC指针的移动把这种电路上的时序处理软
件化了.</p>
<p>而Parallelism更多的是需要考虑计算问题同时还要兼顾IO.Parallelism首先要回答的是一个东西是不是可并行的.回答完这个问题
后,如果可并行那么在什么样的硬件设备上并行是最合适的这样一个问题.在Parallelism中需要考虑的的IO也不仅仅是来自于网络更多是,缓存,
内存,磁盘,总线等等.其实我觉得,在Parallelism下你总是处于一个矛盾状态,颗粒度越小的并行获得的计算资源的利用率也就越大加速比就越
大,但是同时通信系统的工作也就越是繁忙整个运算过程浪费在通信消耗上的时间也就越多.
这个当中的tradeoff是非常困难的.很多时候速度不快,完全不是因为你的核心不够多,而是你的通信速度不够高.</p>
<p>On 3月22日, 下午3时21分, Guancheng Chen <a href="&#109;&#x61;&#x69;&#x6c;&#x74;&#x6f;&#x3a;&#91;&#x63;&#104;&#x65;&#x6e;&#103;&#117;&#97;&#x6e;&#x63;&#104;&#46;&#46;&#x2e;&#x40;&#x67;&#109;&#x61;&#x69;&#x6c;&#46;&#99;&#x6f;&#109;&#x5d;&#40;&#x29;">&#91;&#x63;&#104;&#x65;&#x6e;&#103;&#117;&#97;&#x6e;&#x63;&#104;&#46;&#46;&#x2e;&#x40;&#x67;&#109;&#x61;&#x69;&#x6c;&#46;&#99;&#x6f;&#109;&#x5d;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>绝大部分的观点Can&#39;t agree more.其实这也是为什么我引用了高老爷子那段话的原因，因为程序的本质就是数据结构和算法，你要没有非常适
合并行的算法那简直就是巧妇难为无米之炊。但是有疑问的一点是关于Parallelism和Concurrency这两个单词的区别，实际上这也是非常
有意思的一件事情，Sun的多线程指南上写的是： Parallelism is a condition that arises when at
least two threads are executing simultaneously, while concurrency is a
condition that exists when at least two threads are making progress.
Therefore concurrency is a more generalized form of parallelism that
can include time-slicing as a form of virtual parallelism.不知道您怎么看？</p>
<p>On 3月22日, 上午8时06分, Alleluia <a href="&#109;&#x61;&#x69;&#108;&#116;&#111;&#58;&#x5b;&#x61;&#x6c;&#108;&#117;&#x6c;&#x2e;&#46;&#x2e;&#x40;&#103;&#109;&#97;&#105;&#108;&#x2e;&#x63;&#111;&#109;&#93;&#40;&#x29;">&#x5b;&#x61;&#x6c;&#108;&#117;&#x6c;&#x2e;&#46;&#x2e;&#x40;&#103;&#109;&#97;&#105;&#108;&#x2e;&#x63;&#111;&#109;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>Parallelism 说到底是算法问题.Parallelism与Concurrency不同,Concurrency所面对的问题相对的单一可以
让一群有经验的专家来实现一套通用库或者语言来提供一个基本的编程框架.而在Parallelism上,具体的不同问题,其所需要并行的算法是根本不同
的.原因在于不同的问题,其内部的DataDependency的结构完全不同,不同的Data Dependency的结构,需要构造不同的算法.即
便是相同的Data Dependency,在不同的颗粒度下，在不同的硬件条件下所采用的算法也是完全不同的.因为一旦出现Data
Dependency也就意味着并行计算模块之间需要进行通信.从以计算节点为单位的分布式并行,到多核CPU上的Numa结构,到SIMD上的向量处
理器,其计算单元之间的通信手段,通信效率简直天差地别.比如说,在SMP上最常见的并行算法,work stealing也就是Intel的TBB,
是建立在两个条件下第一个是CPU的Cache机制上,这使得通常在内存的之间的数据搬运消耗非常小,第二个是SMP上计算单元相对的少,因此每个计算
单元被分配到的任务就相对的重。其开销远远大于通信的开销,因此这种机制在SMP上相对的划算.但是如果你要在GPU上做Work Stealing就
完全不可行,因为GPU的运算单元数量极多,被分配到的任务就相对来说的非常轻量,CUDA上的一个thread很多时候运算一次的时间不会超过
10us,而一次跨Block的线程之间的通信开销就往往要达到100us左右,再加上目前GPU上的Cache机制非常落后导致了需要频繁的通信开销
的Work Stealing在GPU上是非常不划算得.
所以我个人认为在硬件架构没有更多的突破之前,OpenCL这种东西是没有任何生命力的.不要说CPU的并行与GPU之间差异巨大,就是不同的GPU之
间AMD与Nvidia两个也是各自为政,一个平台上跑得非常快的东西,在另外一个平台极大的可能是龟速.其最终的结果估计就是跟Java的
write once run everywhere一样是个大笑话.</p>
<p>On 3月22日, 下午2时06分, Guancheng Chen <a href="&#x6d;&#97;&#105;&#108;&#x74;&#x6f;&#x3a;&#x5b;&#x63;&#104;&#101;&#x6e;&#103;&#x75;&#97;&#x6e;&#x63;&#104;&#46;&#46;&#x2e;&#x40;&#103;&#109;&#x61;&#x69;&#108;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#40;&#41;">&#x5b;&#x63;&#104;&#101;&#x6e;&#103;&#x75;&#97;&#x6e;&#x63;&#104;&#46;&#46;&#x2e;&#x40;&#103;&#109;&#x61;&#x69;&#108;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>On 3月22日, 上午2时20分, Tinyfool <a href="&#x6d;&#x61;&#x69;&#108;&#116;&#111;&#58;&#91;&#116;&#x69;&#110;&#121;&#102;&#x2e;&#x2e;&#46;&#x40;&#x67;&#x6d;&#x61;&#105;&#x6c;&#46;&#99;&#111;&#x6d;&#x5d;&#40;&#x29;">&#91;&#116;&#x69;&#110;&#121;&#102;&#x2e;&#x2e;&#46;&#x40;&#x67;&#x6d;&#x61;&#105;&#x6c;&#46;&#99;&#111;&#x6d;&#x5d;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#x6d;&#97;&#105;&#x6c;&#116;&#x6f;&#58;&#91;&#106;&#x65;&#46;&#46;&#x2e;&#64;&#108;&#x69;&#x76;&#x65;&#46;&#x63;&#111;&#x6d;&#x5d;&#40;&#x29;">&#91;&#106;&#x65;&#46;&#46;&#x2e;&#64;&#108;&#x69;&#x76;&#x65;&#46;&#x63;&#111;&#x6d;&#x5d;&#40;&#x29;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a></p>
<p>Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#x6d;&#97;&#105;&#x6c;&#116;&#x6f;&#x3a;&#91;&#x63;&#x68;&#x65;&#x6e;&#x67;&#117;&#97;&#110;&#x63;&#104;&#46;&#46;&#x2e;&#64;&#103;&#109;&#x61;&#x69;&#108;&#46;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#41;">&#91;&#x63;&#x68;&#x65;&#x6e;&#x67;&#117;&#97;&#110;&#x63;&#104;&#46;&#46;&#x2e;&#64;&#103;&#109;&#x61;&#x69;&#108;&#46;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#41;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#x3a;&#x5b;&#112;&#111;&#110;&#x2e;&#46;&#46;&#64;&#103;&#x6f;&#111;&#x67;&#108;&#x65;&#x67;&#114;&#x6f;&#117;&#112;&#115;&#x2e;&#99;&#x6f;&#109;&#93;&#x28;&#x29;">&#x5b;&#112;&#111;&#110;&#x2e;&#46;&#46;&#64;&#103;&#x6f;&#111;&#x67;&#108;&#x65;&#x67;&#114;&#x6f;&#117;&#112;&#115;&#x2e;&#99;&#x6f;&#109;&#93;&#x28;&#x29;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>&gt;</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间</li>
</ol>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>...</p>
<p>阅读更多 &gt;&gt;
<a href="">显示删减掉的内容</a></p>
</blockquote>
<p><img src="" alt=""> Alleluia <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>其他收件人：</p>
<p>且抛开,流处理器这种异构的内核,SMP和Numa之间的差异.就说说单个CPU上做SIMD并行化的需要考虑的内存/cache问题.
比如作矩阵乘法运算,如果矩阵都是按照行存储, 则在A/*B中, 乘法对B的访问是按列的. 假设B一行有N个元素, 那么在存储器中, 两个同列不同
行的元素所在的存储单元相差N. 对B的访问并不是局部化的. 因为访问不局部化, 所以每次乘法, 都需要从内存中调一个 cache 单元到
CPU. 这个极大的降低了处理器的执行速度. 因此, 矩阵乘法的优化的核心, 在于局部化B的访问. 反过来, 如果矩阵按照列存储, 则要局部化
对A的访问. 关于怎样局部化访问还能获得正确的乘法,那就要针对具体的情况设计正确的算法.
为何并行化不可能用库来实现呢?其实问题根源在于,并行颗粒度的变化,导致对IO,算法的乃至硬件结构产生天差地别的变化.一个顺序型的问题,可以划分
成不同的颗粒度.比如说一个100M的Byte型数组,要求和,你可以按照1M的颗粒度进行划分,也可以按照1K,甚至256，128，乃至
4byte,8byte进行划分.每种划分,产生的数据搬运的次数,每次数据搬运的大小,乃至缓存命中率都是不同。
再进一步说,颗粒度划分的越细,意味着计算单元就需要增加,否则就没有意义.但是一旦运算单元的增加到一个的极限,就会引起硬件结构的改变,比如说
SMP根本无法支撑超过16Core的架构,超过这个限度你就得换Nehalem那种Numa架构.在Numa结构下你就不得不考虑,本地内存和远端内
存的区别。
目前没有一个很好的方案来统一不同等级并行计算的架构,在8核之下你用Numa就是杀鸡用牛刀了,而超过32核Numa也不堪重负需要像GPU那样去设
计硬件架构这也就是为什么Intel的Larrebe会难产的原因.每个X86内核都要顶着一个硕大的Deocder还有branch
prediction,OOO之类的庞然大物,用PII来做Larrebe都非常的头大的事情.所以,我个人认为,并行化本身就是和硬件结构极为相关的
事情,这一切都不太可能由一个统一的计算库来完成统一的封装.</p>
<p>On 3月22日, 下午10时38分, &quot;Jeffrey Zhao&quot; <a href="&#109;&#x61;&#x69;&#108;&#116;&#111;&#x3a;&#91;&#x6a;&#101;&#x2e;&#x2e;&#46;&#64;&#x6c;&#x69;&#x76;&#101;&#x2e;&#99;&#x6f;&#109;&#93;&#x28;&#41;">&#91;&#x6a;&#101;&#x2e;&#x2e;&#46;&#64;&#x6c;&#x69;&#x76;&#101;&#x2e;&#99;&#x6f;&#109;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>能详细说说为什么&quot;由于内存/cache模型和编译器/cpu的优化, 并行化是不可能通过库来实现的&quot;吗？</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter: @jeffz_cn</p>
<p>From: Lai Jiangshan
Sent: Monday, March 22, 2010 10:17 PM
To: <a href="">pon...@googlegroups.com</a>
Subject: Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>由于内存/cache模型和编译器/cpu的优化, 并行化是不可能通过库来实现的.</p>
<p>我认为最大的障碍是支持并行化的语言.</p>
<p>2010/3/22 Guancheng Chen <a href="&#109;&#x61;&#105;&#108;&#116;&#111;&#58;&#x5b;&#99;&#104;&#101;&#x6e;&#103;&#x75;&#x61;&#x6e;&#x63;&#104;&#x2e;&#x2e;&#x2e;&#64;&#103;&#109;&#x61;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#93;&#40;&#x29;">&#x5b;&#99;&#104;&#101;&#x6e;&#103;&#x75;&#x61;&#x6e;&#x63;&#104;&#x2e;&#x2e;&#x2e;&#64;&#103;&#109;&#x61;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#93;&#40;&#x29;</a></p>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>&gt;</p>
<blockquote>
<ol>
<li>C语言可以使用pthread等库实现并行化，C++ JAVA等已经会即将支持多线程 所以语言能实现并行化 只是难易问题</li>
<li>是指Shared memory模型，多核共享一条内存总线所以造成带宽问题么？这确实是个问题，不过我感觉硬件商家会负责为你带来越来越多的带
宽，而程序员的任务只是合理的利用好这些给定的带宽</li>
<li><p>能具体说说哪些误导宣传么？</p>
<p>On 3月22日, 上午1时46分, 陨落雕 <a href="&#109;&#x61;&#105;&#x6c;&#x74;&#111;&#58;&#91;&#103;&#101;&#x6f;&#46;&#46;&#x2e;&#46;&#64;&#x67;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#93;&#40;&#x29;">&#91;&#103;&#101;&#x6f;&#46;&#46;&#x2e;&#46;&#64;&#x67;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>呃，我想的障碍是: 1. 类C语言的统治地位; 2. 内存带宽不够; 3. 误导性宣传;</p>
<p>On Mar 21, 7:37 pm, Guancheng Chen <a href="&#109;&#x61;&#105;&#108;&#116;&#111;&#x3a;&#x5b;&#99;&#x68;&#101;&#x6e;&#103;&#117;&#x61;&#110;&#99;&#x68;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#x69;&#108;&#46;&#x63;&#111;&#109;&#93;&#40;&#x29;">&#x5b;&#99;&#x68;&#101;&#x6e;&#103;&#117;&#x61;&#110;&#99;&#x68;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#x69;&#108;&#46;&#x63;&#111;&#109;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看<a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。</p>
</li>
</ol>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
</li>
</ol>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> 郑伟 <img src="" alt=""></p>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-22</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>我对这个比较感兴趣，能详细介绍一下golang在多核下的表现吗？</p>
<p>2010/3/22 Googol Lee <a href="&#x6d;&#x61;&#x69;&#x6c;&#116;&#x6f;&#58;&#x5b;&#x67;&#x6f;&#111;&#x67;&#x2e;&#x2e;&#46;&#x40;&#103;&#x6d;&#97;&#105;&#108;&#46;&#99;&#111;&#109;&#x5d;&#x28;&#41;">&#x5b;&#x67;&#x6f;&#111;&#x67;&#x2e;&#x2e;&#46;&#x40;&#103;&#x6d;&#97;&#105;&#108;&#46;&#99;&#111;&#109;&#x5d;&#x28;&#41;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>彻底来晚了......我是来广告golang的！大并发IO还是csp模型的语言更靠谱！
不过golang在cpu密集的并发上不知道效果会怎么样，就现在的表现来看比erlang好，但还赶不上c/c++
On Mar 22, 9:20 am, Tinyfool <a href="&#109;&#x61;&#x69;&#x6c;&#116;&#x6f;&#x3a;&#91;&#x74;&#105;&#x6e;&#x79;&#102;&#x2e;&#46;&#46;&#x40;&#x67;&#109;&#x61;&#105;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#93;&#x28;&#x29;">&#91;&#x74;&#105;&#x6e;&#x79;&#102;&#x2e;&#46;&#46;&#x40;&#x67;&#109;&#x61;&#105;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#109;&#x61;&#105;&#x6c;&#116;&#111;&#x3a;&#91;&#106;&#101;&#46;&#46;&#x2e;&#x40;&#108;&#x69;&#x76;&#x65;&#46;&#99;&#111;&#x6d;&#93;&#40;&#41;">&#91;&#106;&#101;&#46;&#46;&#x2e;&#x40;&#108;&#x69;&#x76;&#x65;&#46;&#99;&#111;&#x6d;&#93;&#40;&#41;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#x6d;&#x61;&#105;&#x6c;&#x74;&#111;&#58;&#91;&#x63;&#x68;&#x65;&#110;&#103;&#x75;&#97;&#x6e;&#x63;&#104;&#46;&#46;&#x2e;&#x40;&#x67;&#x6d;&#97;&#105;&#x6c;&#46;&#99;&#x6f;&#109;&#93;&#x28;&#x29;">&#91;&#x63;&#x68;&#x65;&#110;&#103;&#x75;&#97;&#x6e;&#x63;&#104;&#46;&#46;&#x2e;&#x40;&#x67;&#x6d;&#97;&#105;&#x6c;&#46;&#99;&#x6f;&#109;&#93;&#x28;&#x29;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#109;&#x61;&#x69;&#x6c;&#x74;&#x6f;&#x3a;&#x5b;&#112;&#x6f;&#110;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#111;&#111;&#103;&#x6c;&#x65;&#103;&#x72;&#111;&#117;&#112;&#115;&#46;&#x63;&#111;&#109;&#x5d;&#40;&#41;">&#x5b;&#112;&#x6f;&#110;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#111;&#111;&#103;&#x6c;&#x65;&#103;&#x72;&#111;&#117;&#112;&#115;&#46;&#x63;&#111;&#109;&#x5d;&#40;&#41;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。</p>
</li>
</ol>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>--</p>
<p>Tinyfool的开发日记<a href="http://www.tinydust.net/dev/" target="_blank"><a href="http://www.tinydust.net/dev/">http://www.tinydust.net/dev/</a></a>
代码中国网<a href="http://www.codechina.org/" target="_blank"><a href="http://www.codechina.org">http://www.codechina.org</a></a></p>
<p>myTwitter:<a href="http://twitter.com/tinyfool" target="_blank"><a href="http://twitter.com/tinyfool">http://twitter.com/tinyfool</a></a>
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a></p>
</blockquote>
<p><img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-23</p>
<p>其他收件人：</p>
<p>您说的可能跟那个问题不是一回事情，窃以为Lai Jiangshan所说的是指CPU和编译器会对并行程序做违反程序semantics的优化（例如
reordering），导致破坏Memory Consistency，例如大牛HJ Boehm的一篇论文《Threads Cannot be
Implemented as a Library》，我之前也写过一篇浅显小文：<a href="http://www.parallellabs.com/2010/03/06/why-should-programmer-care-about-sequential-consistency-rather-than-cache-coherence/" target="_blank"><a href="http://www.parallellabs.com/">http://www.parallellabs.com/</a>
2010/03/06/why-should-programmer-care-about-sequential-consistency-
rather-than-cache-coherence/</a></p>
<p>另外对于您的Concurrency和Parallelism的看法，我大致理解了您所指的&quot;Concurrency&quot;的含义，它跟我所认为的软件层面
的Concurrency不太一样，您的含义更宏观一些，但是感觉我还没有抓住它的精要，不知道能否推荐几篇文献供我参考？</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>On 3月22日, 下午4时35分, Alleluia <a href="&#x6d;&#x61;&#x69;&#108;&#x74;&#x6f;&#58;&#x5b;&#97;&#x6c;&#x6c;&#x75;&#108;&#46;&#x2e;&#x2e;&#x40;&#x67;&#109;&#x61;&#105;&#x6c;&#46;&#99;&#x6f;&#109;&#93;&#x28;&#41;">&#x5b;&#97;&#x6c;&#x6c;&#x75;&#108;&#46;&#x2e;&#x2e;&#x40;&#x67;&#109;&#x61;&#105;&#x6c;&#46;&#99;&#x6f;&#109;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>且抛开,流处理器这种异构的内核,SMP和Numa之间的差异.就说说单个CPU上做SIMD并行化的需要考虑的内存/cache问题.
比如作矩阵乘法运算,如果矩阵都是按照行存储, 则在A/*B中, 乘法对B的访问是按列的. 假设B一行有N个元素, 那么在存储器中, 两个同列不同
行的元素所在的存储单元相差N. 对B的访问并不是局部化的. 因为访问不局部化, 所以每次乘法, 都需要从内存中调一个 cache 单元到
CPU. 这个极大的降低了处理器的执行速度. 因此, 矩阵乘法的优化的核心, 在于局部化B的访问. 反过来, 如果矩阵按照列存储, 则要局部化
对A的访问. 关于怎样局部化访问还能获得正确的乘法,那就要针对具体的情况设计正确的算法.
为何并行化不可能用库来实现呢?其实问题根源在于,并行颗粒度的变化,导致对IO,算法的乃至硬件结构产生天差地别的变化.一个顺序型的问题,可以划分
成不同的颗粒度.比如说一个100M的Byte型数组,要求和,你可以按照1M的颗粒度进行划分,也可以按照1K,甚至256，128，乃至
4byte,8byte进行划分.每种划分,产生的数据搬运的次数,每次数据搬运的大小,乃至缓存命中率都是不同。
再进一步说,颗粒度划分的越细,意味着计算单元就需要增加,否则就没有意义.但是一旦运算单元的增加到一个的极限,就会引起硬件结构的改变,比如说
SMP根本无法支撑超过16Core的架构,超过这个限度你就得换Nehalem那种Numa架构.在Numa结构下你就不得不考虑,本地内存和远端内
存的区别。
目前没有一个很好的方案来统一不同等级并行计算的架构,在8核之下你用Numa就是杀鸡用牛刀了,而超过32核Numa也不堪重负需要像GPU那样去设
计硬件架构这也就是为什么Intel的Larrebe会难产的原因.每个X86内核都要顶着一个硕大的Deocder还有branch
prediction,OOO之类的庞然大物,用PII来做Larrebe都非常的头大的事情.所以,我个人认为,并行化本身就是和硬件结构极为相关的
事情,这一切都不太可能由一个统一的计算库来完成统一的封装.</p>
<p>On 3月22日, 下午10时38分, &quot;Jeffrey Zhao&quot; <a href="&#109;&#x61;&#x69;&#108;&#x74;&#x6f;&#58;&#x5b;&#x6a;&#x65;&#46;&#x2e;&#x2e;&#64;&#x6c;&#x69;&#x76;&#x65;&#x2e;&#99;&#x6f;&#x6d;&#93;&#x28;&#41;">&#x5b;&#x6a;&#x65;&#46;&#x2e;&#x2e;&#64;&#x6c;&#x69;&#x76;&#x65;&#x2e;&#99;&#x6f;&#x6d;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>能详细说说为什么&quot;由于内存/cache模型和编译器/cpu的优化, 并行化是不可能通过库来实现的&quot;吗？</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter: @jeffz_cn</p>
<p>From: Lai Jiangshan
Sent: Monday, March 22, 2010 10:17 PM
To: <a href="">pon...@googlegroups.com</a>
Subject: Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>由于内存/cache模型和编译器/cpu的优化, 并行化是不可能通过库来实现的.</p>
<p>我认为最大的障碍是支持并行化的语言.</p>
<p>2010/3/22 Guancheng Chen <a href="&#x6d;&#97;&#x69;&#x6c;&#x74;&#x6f;&#58;&#91;&#99;&#x68;&#x65;&#110;&#x67;&#117;&#97;&#x6e;&#x63;&#x68;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#109;&#x61;&#x69;&#108;&#46;&#x63;&#x6f;&#109;&#x5d;&#x28;&#x29;">&#91;&#99;&#x68;&#x65;&#110;&#x67;&#117;&#97;&#x6e;&#x63;&#x68;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#109;&#x61;&#x69;&#108;&#46;&#x63;&#x6f;&#109;&#x5d;&#x28;&#x29;</a></p>
<ol>
<li>C语言可以使用pthread等库实现并行化，C++ JAVA等已经会即将支持多线程 所以语言能实现并行化 只是难易问题</li>
<li>是指Shared memory模型，多核共享一条内存总线所以造成带宽问题么？这确实是个问题，不过我感觉硬件商家会负责为你带来越来越多的带
宽，而程序员的任务只是合理的利用好这些给定的带宽</li>
<li><p>能具体说说哪些误导宣传么？</p>
<p>On 3月22日, 上午1时46分, 陨落雕 <a href="&#109;&#x61;&#x69;&#108;&#x74;&#x6f;&#x3a;&#91;&#x67;&#101;&#111;&#46;&#46;&#46;&#46;&#x40;&#x67;&#x6d;&#97;&#105;&#x6c;&#x2e;&#99;&#111;&#x6d;&#x5d;&#40;&#41;">&#91;&#x67;&#101;&#111;&#46;&#46;&#46;&#46;&#x40;&#x67;&#x6d;&#97;&#105;&#x6c;&#x2e;&#99;&#111;&#x6d;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>呃，我想的障碍是: 1. 类C语言的统治地位; 2. 内存带宽不够; 3. 误导性宣传;</p>
<p>On Mar 21, 7:37 pm, Guancheng Chen <a href="&#x6d;&#97;&#x69;&#x6c;&#x74;&#111;&#58;&#91;&#x63;&#x68;&#x65;&#x6e;&#103;&#x75;&#97;&#110;&#99;&#x68;&#46;&#x2e;&#46;&#x40;&#x67;&#109;&#x61;&#x69;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#41;">&#91;&#x63;&#x68;&#x65;&#x6e;&#103;&#x75;&#97;&#110;&#99;&#x68;&#46;&#x2e;&#46;&#x40;&#x67;&#109;&#x61;&#x69;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看<a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx...</p>
</blockquote>
</blockquote>
</li>
</ol>
</blockquote>
<p>阅读更多 &gt;&gt;
<a href="">显示删减掉的内容</a>
<img src="" alt=""> windstorm <img src="" alt=""></p>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-23</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>实在是不能同意你更多......很早很早以前我就在这里和人争论过，GPU的并行计算平台不可能一统天下的。CUDA也不是救世主。OpenCL更不是。</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p><a href="http://www.kunli.info/" target="_blank">www.kunli.info</a>
<a href="http://twitter.com/cnbuff" target="_blank"><a href="http://twitter.com/cnbuff">http://twitter.com/cnbuff</a></a></p>
<p>2010/3/22 Alleluia <a href="&#x6d;&#x61;&#x69;&#108;&#116;&#x6f;&#x3a;&#91;&#x61;&#x6c;&#108;&#x75;&#x2e;&#x2e;&#x2e;&#64;&#103;&#109;&#x61;&#105;&#x6c;&#x2e;&#99;&#111;&#109;&#93;&#40;&#41;">&#91;&#x61;&#x6c;&#108;&#x75;&#x2e;&#x2e;&#x2e;&#64;&#103;&#109;&#x61;&#105;&#x6c;&#x2e;&#99;&#111;&#109;&#93;&#40;&#41;</a>:</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<blockquote>
<p>Parallelism 说到底是算法问题.Parallelism与Concurrency不同,Concurrency所面对的问题相对的单一可以
让一群有经验的专家来实现一套通用库或者语言来提供一个基本的编程框架.而在Parallelism上,具体的不同问题,其所需要并行的算法是根本不同
的.原因在于不同的问题,其内部的DataDependency的结构完全不同,不同的Data Dependency的结构,需要构造不同的算法.即
便是相同的Data Dependency,在不同的颗粒度下，在不同的硬件条件下所采用的算法也是完全不同的.因为一旦出现Data
Dependency也就意味着并行计算模块之间需要进行通信.从以计算节点为单位的分布式并行,到多核CPU上的Numa结构,到SIMD上的向量处
理器,其计算单元之间的通信手段,通信效率简直天差地别.比如说,在SMP上最常见的并行算法,work stealing也就是Intel的TBB,
是建立在两个条件下第一个是CPU的Cache机制上,这使得通常在内存的之间的数据搬运消耗非常小,第二个是SMP上计算单元相对的少,因此每个计算
单元被分配到的任务就相对的重。其开销远远大于通信的开销,因此这种机制在SMP上相对的划算.但是如果你要在GPU上做Work Stealing就
完全不可行,因为GPU的运算单元数量极多,被分配到的任务就相对来说的非常轻量,CUDA上的一个thread很多时候运算一次的时间不会超过
10us,而一次跨Block的线程之间的通信开销就往往要达到100us左右,再加上目前GPU上的Cache机制非常落后导致了需要频繁的通信开销
的Work Stealing在GPU上是非常不划算得.
所以我个人认为在硬件架构没有更多的突破之前,OpenCL这种东西是没有任何生命力的.不要说CPU的并行与GPU之间差异巨大,就是不同的GPU之
间AMD与Nvidia两个也是各自为政,一个平台上跑得非常快的东西,在另外一个平台极大的可能是龟速.其最终的结果估计就是跟Java的
write once run everywhere一样是个大笑话.</p>
<p>On 3月22日, 下午2时06分, Guancheng Chen <a href="&#x6d;&#97;&#105;&#108;&#x74;&#111;&#58;&#x5b;&#x63;&#x68;&#x65;&#110;&#x67;&#117;&#97;&#x6e;&#99;&#x68;&#46;&#x2e;&#46;&#64;&#103;&#x6d;&#x61;&#105;&#x6c;&#46;&#x63;&#x6f;&#109;&#93;&#x28;&#41;">&#x5b;&#x63;&#x68;&#x65;&#110;&#x67;&#117;&#97;&#x6e;&#99;&#x68;&#46;&#x2e;&#46;&#64;&#103;&#x6d;&#x61;&#105;&#x6c;&#46;&#x63;&#x6f;&#109;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>On 3月22日, 上午2时20分, Tinyfool <a href="&#x6d;&#x61;&#x69;&#x6c;&#116;&#111;&#58;&#x5b;&#116;&#105;&#x6e;&#x79;&#102;&#x2e;&#46;&#x2e;&#x40;&#103;&#109;&#97;&#x69;&#108;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#x29;">&#x5b;&#116;&#105;&#x6e;&#x79;&#102;&#x2e;&#46;&#x2e;&#x40;&#103;&#109;&#97;&#x69;&#108;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#x6d;&#x61;&#105;&#x6c;&#116;&#111;&#58;&#91;&#x6a;&#x65;&#x2e;&#x2e;&#46;&#64;&#x6c;&#105;&#118;&#x65;&#46;&#x63;&#111;&#109;&#x5d;&#40;&#41;">&#91;&#x6a;&#x65;&#x2e;&#x2e;&#46;&#64;&#x6c;&#105;&#118;&#x65;&#46;&#x63;&#111;&#109;&#x5d;&#40;&#41;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#x6d;&#x61;&#x69;&#108;&#116;&#111;&#58;&#x5b;&#x63;&#104;&#x65;&#110;&#x67;&#x75;&#x61;&#x6e;&#x63;&#x68;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#109;&#x61;&#105;&#x6c;&#46;&#99;&#111;&#x6d;&#x5d;&#40;&#41;">&#x5b;&#x63;&#104;&#x65;&#110;&#x67;&#x75;&#x61;&#x6e;&#x63;&#x68;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#109;&#x61;&#105;&#x6c;&#46;&#99;&#111;&#x6d;&#x5d;&#40;&#41;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#x6d;&#97;&#x69;&#x6c;&#x74;&#x6f;&#58;&#x5b;&#x70;&#111;&#110;&#46;&#46;&#x2e;&#64;&#x67;&#x6f;&#111;&#x67;&#108;&#x65;&#103;&#x72;&#x6f;&#117;&#112;&#115;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#40;&#x29;">&#x5b;&#x70;&#111;&#110;&#46;&#46;&#x2e;&#64;&#x67;&#x6f;&#111;&#x67;&#108;&#x65;&#103;&#x72;&#x6f;&#117;&#112;&#115;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#40;&#x29;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。</p>
</li>
</ol>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>--
Tinyfool的开发日记<a href="http://www.tinydust.net/dev/" target="_blank"><a href="http://www.tinydust.net/dev/">http://www.tinydust.net/dev/</a></a>
代码中国网<a href="http://www.codechina.org/" target="_blank"><a href="http://www.codechina.org">http://www.codechina.org</a></a>
myTwitter:<a href="http://twitter.com/tinyfool" target="_blank"><a href="http://twitter.com/tinyfool">http://twitter.com/tinyfool</a></a></p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p><a href="">显示删减掉的内容</a></p>
</blockquote>
<p><img src="" alt=""> Juv...@gmail.com <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-23</p>
<p>其他收件人：</p>
<p>好像大家说的concurrency和parallelism不是一个东西？
<a href="">显示删减掉的内容</a>
<img src="" alt=""> windstorm <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-23</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>我觉得这两个东西，sun的多线程编程手册说得很清楚了，没必要重新定义。</p>
<p>Parallelism is a condition that arises when at least two threads are
executing simultaneously, while concurrency is a condition that exists
when at least two threads are making progress.</p>
<p>也就是说concurrency有点像更通用化，限制条件更低的parallelism，而某些case下两者完全不同。比如单核多线程程序，你可以叫它是concurrent
program，但不能叫它是parallel
program。Concurrency在现有体系的处理器架构下都可以做到。和Alleluia说的一样，只是一个时钟周期同步的问题。写过硬件编程的人，几乎都算是写过concurrent
program，但很少写过parallel program</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p><a href="http://www.kunli.info/" target="_blank">www.kunli.info</a>
<a href="http://twitter.com/cnbuff" target="_blank"><a href="http://twitter.com/cnbuff">http://twitter.com/cnbuff</a></a></p>
<p>2010/3/22 <a href="">Juv...@gmail.com</a> <a href="&#x6d;&#97;&#x69;&#108;&#x74;&#x6f;&#58;&#x5b;&#106;&#117;&#118;&#46;&#x2e;&#x2e;&#64;&#103;&#x6d;&#97;&#x69;&#x6c;&#46;&#x63;&#111;&#x6d;&#93;&#x28;&#41;">&#x5b;&#106;&#117;&#118;&#46;&#x2e;&#x2e;&#64;&#103;&#x6d;&#97;&#x69;&#x6c;&#46;&#x63;&#111;&#x6d;&#93;&#x28;&#41;</a>:</p>
<blockquote>
<p>好像大家说的concurrency和parallelism不是一个东西？</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p><a href="">显示删减掉的内容</a></p>
</blockquote>
<p><img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-23</p>
<p>其他收件人：</p>
<p>我觉得现有的OpenCL确实非常不成熟，但是从纯性能角度上来讲，我看好Heterogeneous架构，尽管它们的编程难度太大，就像前面提到的不
同架构需要做不同优化等。CPU的性能是latency-oriented，GPU是throughput-oriented,Intel的
Larrabee虽然现在来看不成功，但是业界都在朝着那个方向努力。</p>
<p>On 3月22日, 下午6时18分, windstorm <a href="&#109;&#x61;&#x69;&#108;&#116;&#111;&#x3a;&#91;&#108;&#x69;&#107;&#117;&#x6e;&#x61;&#114;&#x6d;&#115;&#x74;&#114;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#x69;&#108;&#46;&#x63;&#111;&#109;&#93;&#40;&#x29;">&#91;&#108;&#x69;&#107;&#117;&#x6e;&#x61;&#114;&#x6d;&#115;&#x74;&#114;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#x69;&#108;&#46;&#x63;&#111;&#109;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>实在是不能同意你更多......很早很早以前我就在这里和人争论过，GPU的并行计算平台不可能一统天下的。CUDA也不是救世主。OpenCL更不是。</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Alleluia <a href="&#109;&#x61;&#105;&#x6c;&#x74;&#x6f;&#x3a;&#91;&#97;&#108;&#108;&#117;&#x6c;&#46;&#x2e;&#x2e;&#x40;&#103;&#109;&#97;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#40;&#x29;">&#91;&#97;&#108;&#108;&#117;&#x6c;&#46;&#x2e;&#x2e;&#x40;&#103;&#109;&#97;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#40;&#x29;</a>:</p>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>&gt;
&gt;
&gt;</p>
<blockquote>
<blockquote>
<p>Parallelism 说到底是算法问题.Parallelism与Concurrency不同,Concurrency所面对的问题相对的单一可以
让一群有经验的专家来实现一套通用库或者语言来提供一个基本的编程框架.而在Parallelism上,具体的不同问题,其所需要并行的算法是根本不同
的.原因在于不同的问题,其内部的DataDependency的结构完全不同,不同的Data Dependency的结构,需要构造不同的算法.即
便是相同的Data Dependency,在不同的颗粒度下，在不同的硬件条件下所采用的算法也是完全不同的.因为一旦出现Data
Dependency也就意味着并行计算模块之间需要进行通信.从以计算节点为单位的分布式并行,到多核CPU上的Numa结构,到SIMD上的向量处
理器,其计算单元之间的通信手段,通信效率简直天差地别.比如说,在SMP上最常见的并行算法,work stealing也就是Intel的TBB,
是建立在两个条件下第一个是CPU的Cache机制上,这使得通常在内存的之间的数据搬运消耗非常小,第二个是SMP上计算单元相对的少,因此每个计算
单元被分配到的任务就相对的重。其开销远远大于通信的开销,因此这种机制在SMP上相对的划算.但是如果你要在GPU上做Work Stealing就
完全不可行,因为GPU的运算单元数量极多,被分配到的任务就相对来说的非常轻量,CUDA上的一个thread很多时候运算一次的时间不会超过
10us,而一次跨Block的线程之间的通信开销就往往要达到100us左右,再加上目前GPU上的Cache机制非常落后导致了需要频繁的通信开销
的Work Stealing在GPU上是非常不划算得.
所以我个人认为在硬件架构没有更多的突破之前,OpenCL这种东西是没有任何生命力的.不要说CPU的并行与GPU之间差异巨大,就是不同的GPU之
间AMD与Nvidia两个也是各自为政,一个平台上跑得非常快的东西,在另外一个平台极大的可能是龟速.其最终的结果估计就是跟Java的
write once run everywhere一样是个大笑话.</p>
<p>On 3月22日, 下午2时06分, Guancheng Chen <a href="&#x6d;&#x61;&#x69;&#x6c;&#116;&#x6f;&#x3a;&#x5b;&#x63;&#x68;&#x65;&#110;&#103;&#x75;&#x61;&#x6e;&#99;&#x68;&#x2e;&#46;&#x2e;&#64;&#103;&#109;&#x61;&#105;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#41;">&#x5b;&#x63;&#x68;&#x65;&#110;&#103;&#x75;&#x61;&#x6e;&#99;&#x68;&#x2e;&#46;&#x2e;&#64;&#103;&#109;&#x61;&#105;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>On 3月22日, 上午2时20分, Tinyfool <a href="&#x6d;&#x61;&#x69;&#108;&#116;&#x6f;&#x3a;&#91;&#x74;&#105;&#x6e;&#121;&#x66;&#46;&#x2e;&#46;&#x40;&#x67;&#x6d;&#x61;&#x69;&#108;&#46;&#99;&#111;&#x6d;&#x5d;&#x28;&#x29;">&#91;&#x74;&#105;&#x6e;&#121;&#x66;&#46;&#x2e;&#46;&#x40;&#x67;&#x6d;&#x61;&#x69;&#108;&#46;&#99;&#111;&#x6d;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#x6d;&#x61;&#105;&#x6c;&#116;&#111;&#x3a;&#91;&#x6a;&#x65;&#x2e;&#46;&#46;&#x40;&#108;&#x69;&#x76;&#101;&#46;&#x63;&#x6f;&#109;&#x5d;&#x28;&#x29;">&#91;&#x6a;&#x65;&#x2e;&#46;&#46;&#x40;&#108;&#x69;&#x76;&#101;&#46;&#x63;&#x6f;&#109;&#x5d;&#x28;&#x29;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#109;&#x61;&#x69;&#x6c;&#x74;&#x6f;&#58;&#x5b;&#99;&#x68;&#101;&#110;&#103;&#x75;&#97;&#110;&#x63;&#x68;&#x2e;&#x2e;&#x2e;&#64;&#103;&#109;&#97;&#105;&#x6c;&#46;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#x29;">&#x5b;&#99;&#x68;&#101;&#110;&#103;&#x75;&#97;&#110;&#x63;&#x68;&#x2e;&#x2e;&#x2e;&#64;&#103;&#109;&#97;&#105;&#x6c;&#46;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#x29;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#109;&#97;&#105;&#x6c;&#x74;&#x6f;&#58;&#x5b;&#x70;&#111;&#x6e;&#46;&#46;&#46;&#64;&#103;&#111;&#111;&#103;&#108;&#x65;&#103;&#114;&#x6f;&#x75;&#x70;&#x73;&#x2e;&#99;&#111;&#109;&#x5d;&#40;&#x29;">&#x5b;&#x70;&#111;&#x6e;&#46;&#46;&#46;&#64;&#103;&#111;&#111;&#103;&#108;&#x65;&#103;&#114;&#x6f;&#x75;&#x70;&#x73;&#x2e;&#99;&#111;&#109;&#x5d;&#40;&#x29;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？...</li>
</ol>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>阅读更多 &gt;&gt;
<a href="">显示删减掉的内容</a>
<img src="" alt=""> windstorm <img src="" alt=""></p>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-23</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>Larrabee当初我还是很看好的，它的架构比其他的更像一个统一的方案，可惜后来Intel自己经验不足搞不好。</p>
<p>OPENCL还是主要面向multimedia吧，CUDA/OpenCL在业界代表了流处理的方向，从GPU针对任务的角度讲是好的。其他的就算了。就像Alleluia说的那样，在硬件架构没有更多的突破之前，不说没有生命力，至少想取得任何进一步的突破都太难。</p>
<p>现在这个领域，你吹你的水，我吹我的水。至于谁的泡泡大，我看不清。所以真要选东西学，最好还是针对自己的application选靠谱。这也是并行编程教育难的问题。大家需求完全不一样。</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p><a href="http://www.kunli.info/" target="_blank">www.kunli.info</a>
<a href="http://twitter.com/cnbuff" target="_blank"><a href="http://twitter.com/cnbuff">http://twitter.com/cnbuff</a></a></p>
<p>2010/3/22 Guancheng Chen <a href="&#109;&#97;&#105;&#108;&#x74;&#x6f;&#x3a;&#91;&#99;&#x68;&#101;&#110;&#x67;&#x75;&#46;&#x2e;&#x2e;&#64;&#x67;&#109;&#x61;&#x69;&#108;&#46;&#x63;&#111;&#109;&#x5d;&#40;&#41;">&#91;&#99;&#x68;&#101;&#110;&#x67;&#x75;&#46;&#x2e;&#x2e;&#64;&#x67;&#109;&#x61;&#x69;&#108;&#46;&#x63;&#111;&#109;&#x5d;&#40;&#41;</a>:</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<blockquote>
<p>我觉得现有的OpenCL确实非常不成熟，但是从纯性能角度上来讲，我看好Heterogeneous架构，尽管它们的编程难度太大，就像前面提到的不
同架构需要做不同优化等。CPU的性能是latency-oriented，GPU是throughput-oriented,Intel的
Larrabee虽然现在来看不成功，但是业界都在朝着那个方向努力。</p>
<p>On 3月22日, 下午6时18分, windstorm <a href="&#109;&#x61;&#105;&#108;&#116;&#111;&#58;&#x5b;&#108;&#105;&#107;&#x75;&#x6e;&#x61;&#114;&#109;&#115;&#x74;&#114;&#x2e;&#x2e;&#46;&#x40;&#x67;&#109;&#x61;&#105;&#108;&#46;&#99;&#111;&#x6d;&#93;&#x28;&#41;">&#x5b;&#108;&#105;&#107;&#x75;&#x6e;&#x61;&#114;&#109;&#115;&#x74;&#114;&#x2e;&#x2e;&#46;&#x40;&#x67;&#109;&#x61;&#105;&#108;&#46;&#99;&#111;&#x6d;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>实在是不能同意你更多......很早很早以前我就在这里和人争论过，GPU的并行计算平台不可能一统天下的。CUDA也不是救世主。OpenCL更不是。</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Alleluia <a href="&#109;&#97;&#105;&#108;&#x74;&#111;&#x3a;&#x5b;&#97;&#108;&#x6c;&#117;&#108;&#46;&#x2e;&#46;&#64;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#46;&#99;&#x6f;&#109;&#93;&#40;&#41;">&#x5b;&#97;&#108;&#x6c;&#117;&#108;&#46;&#x2e;&#46;&#64;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#46;&#99;&#x6f;&#109;&#93;&#40;&#41;</a>:</p>
<blockquote>
<p>Parallelism 说到底是算法问题.Parallelism与Concurrency不同,Concurrency所面对的问题相对的单一可以
让一群有经验的专家来实现一套通用库或者语言来提供一个基本的编程框架.而在Parallelism上,具体的不同问题,其所需要并行的算法是根本不同
的.原因在于不同的问题,其内部的DataDependency的结构完全不同,不同的Data Dependency的结构,需要构造不同的算法.即
便是相同的Data Dependency,在不同的颗粒度下，在不同的硬件条件下所采用的算法也是完全不同的.因为一旦出现Data
Dependency也就意味着并行计算模块之间需要进行通信.从以计算节点为单位的分布式并行,到多核CPU上的Numa结构,到SIMD上的向量处
理器,其计算单元之间的通信手段,通信效率简直天差地别.比如说,在SMP上最常见的并行算法,work stealing也就是Intel的TBB,
是建立在两个条件下第一个是CPU的Cache机制上,这使得通常在内存的之间的数据搬运消耗非常小,第二个是SMP上计算单元相对的少,因此每个计算
单元被分配到的任务就相对的重。其开销远远大于通信的开销,因此这种机制在SMP上相对的划算.但是如果你要在GPU上做Work Stealing就
完全不可行,因为GPU的运算单元数量极多,被分配到的任务就相对来说的非常轻量,CUDA上的一个thread很多时候运算一次的时间不会超过
10us,而一次跨Block的线程之间的通信开销就往往要达到100us左右,再加上目前GPU上的Cache机制非常落后导致了需要频繁的通信开销
的Work Stealing在GPU上是非常不划算得.
所以我个人认为在硬件架构没有更多的突破之前,OpenCL这种东西是没有任何生命力的.不要说CPU的并行与GPU之间差异巨大,就是不同的GPU之
间AMD与Nvidia两个也是各自为政,一个平台上跑得非常快的东西,在另外一个平台极大的可能是龟速.其最终的结果估计就是跟Java的
write once run everywhere一样是个大笑话.</p>
<p>On 3月22日, 下午2时06分, Guancheng Chen <a href="&#x6d;&#97;&#x69;&#x6c;&#116;&#x6f;&#x3a;&#91;&#99;&#x68;&#x65;&#x6e;&#103;&#117;&#x61;&#x6e;&#x63;&#104;&#46;&#x2e;&#x2e;&#x40;&#103;&#109;&#97;&#105;&#108;&#x2e;&#x63;&#x6f;&#109;&#93;&#x28;&#41;">&#91;&#99;&#x68;&#x65;&#x6e;&#103;&#117;&#x61;&#x6e;&#x63;&#104;&#46;&#x2e;&#x2e;&#x40;&#103;&#109;&#97;&#105;&#108;&#x2e;&#x63;&#x6f;&#109;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>On 3月22日, 上午2时20分, Tinyfool <a href="&#x6d;&#x61;&#x69;&#x6c;&#116;&#x6f;&#58;&#91;&#x74;&#x69;&#x6e;&#121;&#102;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#109;&#x61;&#105;&#x6c;&#x2e;&#99;&#x6f;&#109;&#93;&#40;&#41;">&#91;&#x74;&#x69;&#x6e;&#121;&#102;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#109;&#x61;&#105;&#x6c;&#x2e;&#99;&#x6f;&#109;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#x6d;&#x61;&#105;&#108;&#x74;&#111;&#58;&#91;&#106;&#x65;&#46;&#46;&#46;&#64;&#108;&#x69;&#118;&#x65;&#46;&#x63;&#111;&#x6d;&#x5d;&#x28;&#x29;">&#91;&#106;&#x65;&#46;&#46;&#46;&#64;&#108;&#x69;&#118;&#x65;&#46;&#x63;&#111;&#x6d;&#x5d;&#x28;&#x29;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#x6d;&#97;&#x69;&#108;&#116;&#x6f;&#x3a;&#x5b;&#x63;&#104;&#101;&#110;&#x67;&#x75;&#x61;&#x6e;&#99;&#104;&#46;&#46;&#x2e;&#64;&#x67;&#x6d;&#97;&#105;&#x6c;&#x2e;&#99;&#111;&#x6d;&#x5d;&#40;&#x29;">&#x5b;&#x63;&#104;&#101;&#110;&#x67;&#x75;&#x61;&#x6e;&#99;&#104;&#46;&#46;&#x2e;&#64;&#x67;&#x6d;&#97;&#105;&#x6c;&#x2e;&#99;&#111;&#x6d;&#x5d;&#40;&#x29;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#109;&#x61;&#x69;&#x6c;&#x74;&#111;&#x3a;&#91;&#112;&#x6f;&#x6e;&#x2e;&#46;&#46;&#x40;&#x67;&#111;&#x6f;&#103;&#x6c;&#101;&#103;&#114;&#111;&#117;&#112;&#x73;&#46;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#x29;">&#91;&#112;&#x6f;&#x6e;&#x2e;&#46;&#46;&#x40;&#x67;&#111;&#x6f;&#103;&#x6c;&#101;&#103;&#114;&#111;&#117;&#112;&#x73;&#46;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#x29;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？...</li>
</ol>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>阅读更多 &gt;&gt;</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p><a href="">显示删减掉的内容</a></p>
</blockquote>
<p><img src="" alt=""> Alleluia <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-23</p>
<p>其他收件人：</p>
<p>对于Concurrency和Parallelism之间混乱的根源就是多线程/进程模型.Concurrrency可以用multithread/
process,也可以不用.一个单核单线程的Concurrency程序只要写的好,对于几万个并发连接不是问题.但是Parallelism必须要
用到multithread.对于Concurrency来说,multithread只是一种可选的方案.
当然,在CPU架构上Concurrency和Parallelism的很多设施都是可以复用的,比如高性能的线程池,以及细粒度的锁等等.</p>
<p>On 3月23日, 上午4时32分, windstorm <a href="&#x6d;&#x61;&#x69;&#108;&#x74;&#111;&#x3a;&#91;&#108;&#105;&#x6b;&#117;&#x6e;&#x61;&#x72;&#109;&#115;&#116;&#x72;&#x2e;&#46;&#46;&#x40;&#103;&#109;&#97;&#x69;&#108;&#x2e;&#99;&#x6f;&#x6d;&#93;&#x28;&#x29;">&#91;&#108;&#105;&#x6b;&#117;&#x6e;&#x61;&#x72;&#109;&#115;&#116;&#x72;&#x2e;&#46;&#46;&#x40;&#103;&#109;&#97;&#x69;&#108;&#x2e;&#99;&#x6f;&#x6d;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>我觉得这两个东西，sun的多线程编程手册说得很清楚了，没必要重新定义。</p>
<p>Parallelism is a condition that arises when at least two threads are
executing simultaneously, while concurrency is a condition that exists
when at least two threads are making progress.</p>
<p>也就是说concurrency有点像更通用化，限制条件更低的parallelism，而某些case下两者完全不同。比如单核多线程程序，你可以叫它是co ncurrent
program，但不能叫它是parallel
program。Concurrency在现有体系的处理器架构下都可以做到。和Alleluia说的一样，只是一个时钟周期同步的问题。写过硬件编程的人，几 乎都算是写过concurrent
program，但很少写过parallel program</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>2010/3/22 <a href="">Juv...@gmail.com</a> <a href="&#109;&#x61;&#x69;&#108;&#116;&#x6f;&#x3a;&#x5b;&#106;&#x75;&#118;&#46;&#46;&#x2e;&#64;&#103;&#109;&#x61;&#105;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#x29;">&#x5b;&#106;&#x75;&#118;&#46;&#46;&#x2e;&#64;&#103;&#109;&#x61;&#105;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#x29;</a>:</p>
<blockquote>
<p>好像大家说的concurrency和parallelism不是一个东西？</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> Alleluia <img src="" alt=""></p>
</blockquote>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-23</p>
<p>其他收件人：</p>
<p>Heterogeneous目前来看也是一个暂时的过渡性的东西. Heterogeneous架构最大的问题还是硬件,CPU和GPU之间的
PCIE2的bus带宽太窄了.在上面来回传递一次几M的内存可能需要化掉500us左右.如果一个算法本来就是在3-4ms级别的,你要用GPU去优
化,内存带宽的消耗就占了1/10,这是非常可怕的事情.或许像AMD那种Fusion架构是一种趋势,但是目前来说没有太大的进展.貌似AMD出了一
款混合的CPU,但是貌似还没有看到有多大的优势.</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>On 3月23日, 上午5时02分, Guancheng Chen <a href="&#x6d;&#x61;&#105;&#x6c;&#116;&#x6f;&#x3a;&#x5b;&#99;&#x68;&#101;&#110;&#103;&#117;&#97;&#110;&#99;&#x68;&#46;&#46;&#x2e;&#64;&#x67;&#x6d;&#97;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#93;&#40;&#41;">&#x5b;&#99;&#x68;&#101;&#110;&#103;&#117;&#97;&#110;&#99;&#x68;&#46;&#46;&#x2e;&#64;&#x67;&#x6d;&#97;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>我觉得现有的OpenCL确实非常不成熟，但是从纯性能角度上来讲，我看好Heterogeneous架构，尽管它们的编程难度太大，就像前面提到的不
同架构需要做不同优化等。CPU的性能是latency-oriented，GPU是throughput-oriented,Intel的
Larrabee虽然现在来看不成功，但是业界都在朝着那个方向努力。</p>
<p>On 3月22日, 下午6时18分, windstorm <a href="&#x6d;&#x61;&#x69;&#x6c;&#116;&#111;&#58;&#x5b;&#108;&#x69;&#107;&#117;&#x6e;&#97;&#x72;&#x6d;&#x73;&#116;&#x72;&#46;&#x2e;&#46;&#x40;&#103;&#109;&#97;&#x69;&#108;&#x2e;&#99;&#x6f;&#109;&#93;&#x28;&#41;">&#x5b;&#108;&#x69;&#107;&#117;&#x6e;&#97;&#x72;&#x6d;&#x73;&#116;&#x72;&#46;&#x2e;&#46;&#x40;&#103;&#109;&#97;&#x69;&#108;&#x2e;&#99;&#x6f;&#109;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>实在是不能同意你更多......很早很早以前我就在这里和人争论过，GPU的并行计算平台不可能一统天下的。CUDA也不是救世主。OpenCL更不是。</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Alleluia <a href="&#109;&#97;&#x69;&#x6c;&#116;&#x6f;&#x3a;&#x5b;&#x61;&#x6c;&#x6c;&#x75;&#x6c;&#x2e;&#x2e;&#46;&#64;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#46;&#99;&#x6f;&#109;&#93;&#x28;&#41;">&#x5b;&#x61;&#x6c;&#x6c;&#x75;&#x6c;&#x2e;&#x2e;&#46;&#64;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#46;&#99;&#x6f;&#109;&#93;&#x28;&#41;</a>:</p>
<blockquote>
<p>Parallelism 说到底是算法问题.Parallelism与Concurrency不同,Concurrency所面对的问题相对的单一可以
让一群有经验的专家来实现一套通用库或者语言来提供一个基本的编程框架.而在Parallelism上,具体的不同问题,其所需要并行的算法是根本不同
的.原因在于不同的问题,其内部的DataDependency的结构完全不同,不同的Data Dependency的结构,需要构造不同的算法.即
便是相同的Data Dependency,在不同的颗粒度下，在不同的硬件条件下所采用的算法也是完全不同的.因为一旦出现Data
Dependency也就意味着并行计算模块之间需要进行通信.从以计算节点为单位的分布式并行,到多核CPU上的Numa结构,到SIMD上的向量处
理器,其计算单元之间的通信手段,通信效率简直天差地别.比如说,在SMP上最常见的并行算法,work stealing也就是Intel的TBB,
是建立在两个条件下第一个是CPU的Cache机制上,这使得通常在内存的之间的数据搬运消耗非常小,第二个是SMP上计算单元相对的少,因此每个计算
单元被分配到的任务就相对的重。其开销远远大于通信的开销,因此这种机制在SMP上相对的划算.但是如果你要在GPU上做Work Stealing就
完全不可行,因为GPU的运算单元数量极多,被分配到的任务就相对来说的非常轻量,CUDA上的一个thread很多时候运算一次的时间不会超过
10us,而一次跨Block的线程之间的通信开销就往往要达到100us左右,再加上目前GPU上的Cache机制非常落后导致了需要频繁的通信开销
的Work Stealing在GPU上是非常不划算得.
所以我个人认为在硬件架构没有更多的突破之前,OpenCL这种东西是没有任何生命力的.不要说CPU的并行与GPU之间差异巨大,就是不同的GPU之
间AMD与Nvidia两个也是各自为政,一个平台上跑得非常快的东西,在另外一个平台极大的可能是龟速.其最终的结果估计就是跟Java的
write once run everywhere一样是个大笑话.</p>
<p>On 3月22日, 下午2时06分, Guancheng Chen <a href="&#109;&#x61;&#105;&#x6c;&#x74;&#x6f;&#x3a;&#91;&#99;&#x68;&#x65;&#110;&#x67;&#x75;&#x61;&#110;&#x63;&#x68;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#99;&#x6f;&#109;&#93;&#x28;&#41;">&#91;&#99;&#x68;&#x65;&#110;&#x67;&#x75;&#x61;&#110;&#x63;&#x68;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#99;&#x6f;&#109;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>On 3月22日, 上午2时20分, Tinyfool <a href="&#109;&#97;&#105;&#108;&#116;&#x6f;&#x3a;&#91;&#116;&#105;&#x6e;&#121;&#x66;&#46;&#46;&#x2e;&#64;&#x67;&#x6d;&#97;&#105;&#108;&#46;&#99;&#x6f;&#109;&#x5d;&#40;&#41;">&#91;&#116;&#105;&#x6e;&#121;&#x66;&#46;&#46;&#x2e;&#64;&#x67;&#x6d;&#97;&#105;&#108;&#46;&#99;&#x6f;&#109;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#109;&#97;&#105;&#x6c;&#x74;&#x6f;&#x3a;&#91;&#106;&#x65;&#x2e;&#x2e;&#46;&#x40;&#x6c;&#105;&#118;&#101;&#46;&#99;&#111;&#109;&#93;&#x28;&#41;">&#91;&#106;&#x65;&#x2e;&#x2e;&#46;&#x40;&#x6c;&#105;&#118;&#101;&#46;&#99;&#111;&#109;&#93;&#x28;&#41;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#109;&#97;&#105;&#x6c;&#116;&#111;&#58;&#91;&#99;&#x68;&#x65;&#x6e;&#103;&#x75;&#97;&#110;&#99;&#x68;&#46;&#46;&#46;&#64;&#x67;&#109;&#97;&#105;&#x6c;&#x2e;&#99;&#111;&#109;&#93;&#x28;&#x29;">&#91;&#99;&#x68;&#x65;&#x6e;&#103;&#x75;&#97;&#110;&#99;&#x68;&#46;&#46;&#46;&#64;&#x67;&#109;&#97;&#105;&#x6c;&#x2e;&#99;&#111;&#109;&#93;&#x28;&#x29;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#x6d;&#x61;&#x69;&#108;&#116;&#x6f;&#x3a;&#91;&#x70;&#111;&#110;&#x2e;&#46;&#x2e;&#64;&#x67;&#x6f;&#x6f;&#103;&#x6c;&#x65;&#103;&#x72;&#111;&#x75;&#x70;&#115;&#46;&#x63;&#x6f;&#109;&#93;&#x28;&#41;">&#91;&#x70;&#111;&#110;&#x2e;&#46;&#x2e;&#64;&#x67;&#x6f;&#x6f;&#103;&#x6c;&#x65;&#103;&#x72;&#111;&#x75;&#x70;&#115;&#46;&#x63;&#x6f;&#109;&#93;&#x28;&#41;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>...</p>
<p>阅读更多 &gt;&gt;
<a href="">显示删减掉的内容</a></p>
</blockquote>
<p><img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-23</p>
<p>其他收件人：</p>
<p>恩 您也是搞体系结构的么？
现在我在跟瑞典这边的爱立信合作做毕设 不过对象不是他们的Erlang 而是传统的C/C++程序 下半年可能我也去搞GPGPU了 因为它的
data parallel模型对遗留代码的并行化很有搞头，现在我粗略的想法是把Compute sensitive的任务放一部分到GPU上去做，
当然我也对GPU目前的一些限制有所了解 但是一些探索工作还是非常值得的 到时候还想向前辈多多请教</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>On 3月22日, 下午11时30分, Alleluia <a href="&#109;&#97;&#105;&#108;&#x74;&#x6f;&#x3a;&#x5b;&#97;&#108;&#x6c;&#x75;&#108;&#46;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#97;&#105;&#108;&#x2e;&#99;&#x6f;&#x6d;&#93;&#x28;&#41;">&#x5b;&#97;&#108;&#x6c;&#x75;&#108;&#46;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#97;&#105;&#108;&#x2e;&#99;&#x6f;&#x6d;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>Heterogeneous目前来看也是一个暂时的过渡性的东西. Heterogeneous架构最大的问题还是硬件,CPU和GPU之间的
PCIE2的bus带宽太窄了.在上面来回传递一次几M的内存可能需要化掉500us左右.如果一个算法本来就是在3-4ms级别的,你要用GPU去优
化,内存带宽的消耗就占了1/10,这是非常可怕的事情.或许像AMD那种Fusion架构是一种趋势,但是目前来说没有太大的进展.貌似AMD出了一
款混合的CPU,但是貌似还没有看到有多大的优势.
On 3月23日, 上午5时02分, Guancheng Chen <a href="&#109;&#97;&#x69;&#x6c;&#116;&#x6f;&#x3a;&#91;&#x63;&#104;&#101;&#x6e;&#x67;&#117;&#x61;&#110;&#99;&#104;&#x2e;&#46;&#x2e;&#x40;&#x67;&#109;&#x61;&#x69;&#108;&#x2e;&#99;&#x6f;&#109;&#93;&#x28;&#41;">&#91;&#x63;&#104;&#101;&#x6e;&#x67;&#117;&#x61;&#110;&#99;&#104;&#x2e;&#46;&#x2e;&#x40;&#x67;&#109;&#x61;&#x69;&#108;&#x2e;&#99;&#x6f;&#109;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>我觉得现有的OpenCL确实非常不成熟，但是从纯性能角度上来讲，我看好Heterogeneous架构，尽管它们的编程难度太大，就像前面提到的不
同架构需要做不同优化等。CPU的性能是latency-oriented，GPU是throughput-oriented,Intel的
Larrabee虽然现在来看不成功，但是业界都在朝着那个方向努力。</p>
<p>On 3月22日, 下午6时18分, windstorm <a href="&#109;&#x61;&#105;&#108;&#116;&#x6f;&#x3a;&#91;&#x6c;&#105;&#107;&#117;&#110;&#x61;&#x72;&#x6d;&#115;&#x74;&#x72;&#46;&#46;&#46;&#64;&#103;&#109;&#97;&#105;&#x6c;&#x2e;&#x63;&#111;&#109;&#93;&#40;&#x29;">&#91;&#x6c;&#105;&#107;&#117;&#110;&#x61;&#x72;&#x6d;&#115;&#x74;&#x72;&#46;&#46;&#46;&#64;&#103;&#109;&#97;&#105;&#x6c;&#x2e;&#x63;&#111;&#109;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>实在是不能同意你更多......很早很早以前我就在这里和人争论过，GPU的并行计算平台不可能一统天下的。CUDA也不是救世主。OpenCL更不是。</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Alleluia <a href="&#109;&#x61;&#105;&#x6c;&#x74;&#111;&#x3a;&#91;&#x61;&#108;&#108;&#x75;&#x6c;&#x2e;&#x2e;&#46;&#64;&#x67;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#40;&#x29;">&#91;&#x61;&#108;&#108;&#x75;&#x6c;&#x2e;&#x2e;&#46;&#64;&#x67;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#40;&#x29;</a>:</p>
<blockquote>
<p>Parallelism 说到底是算法问题.Parallelism与Concurrency不同,Concurrency所面对的问题相对的单一可以
让一群有经验的专家来实现一套通用库或者语言来提供一个基本的编程框架.而在Parallelism上,具体的不同问题,其所需要并行的算法是根本不同
的.原因在于不同的问题,其内部的DataDependency的结构完全不同,不同的Data Dependency的结构,需要构造不同的算法.即
便是相同的Data Dependency,在不同的颗粒度下，在不同的硬件条件下所采用的算法也是完全不同的.因为一旦出现Data
Dependency也就意味着并行计算模块之间需要进行通信.从以计算节点为单位的分布式并行,到多核CPU上的Numa结构,到SIMD上的向量处
理器,其计算单元之间的通信手段,通信效率简直天差地别.比如说,在SMP上最常见的并行算法,work stealing也就是Intel的TBB,
是建立在两个条件下第一个是CPU的Cache机制上,这使得通常在内存的之间的数据搬运消耗非常小,第二个是SMP上计算单元相对的少,因此每个计算
单元被分配到的任务就相对的重。其开销远远大于通信的开销,因此这种机制在SMP上相对的划算.但是如果你要在GPU上做Work Stealing就
完全不可行,因为GPU的运算单元数量极多,被分配到的任务就相对来说的非常轻量,CUDA上的一个thread很多时候运算一次的时间不会超过
10us,而一次跨Block的线程之间的通信开销就往往要达到100us左右,再加上目前GPU上的Cache机制非常落后导致了需要频繁的通信开销
的Work Stealing在GPU上是非常不划算得.
所以我个人认为在硬件架构没有更多的突破之前,OpenCL这种东西是没有任何生命力的.不要说CPU的并行与GPU之间差异巨大,就是不同的GPU之
间AMD与Nvidia两个也是各自为政,一个平台上跑得非常快的东西,在另外一个平台极大的可能是龟速.其最终的结果估计就是跟Java的
write once run everywhere一样是个大笑话.</p>
<p>On 3月22日, 下午2时06分, Guancheng Chen <a href="&#109;&#x61;&#105;&#108;&#x74;&#x6f;&#x3a;&#x5b;&#x63;&#x68;&#101;&#110;&#103;&#x75;&#x61;&#110;&#x63;&#104;&#46;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#97;&#105;&#x6c;&#x2e;&#99;&#111;&#109;&#93;&#x28;&#x29;">&#x5b;&#x63;&#x68;&#101;&#110;&#103;&#x75;&#x61;&#110;&#x63;&#104;&#46;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#97;&#105;&#x6c;&#x2e;&#99;&#111;&#109;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>On 3月22日, 上午2时20分, Tinyfool <a href="&#109;&#97;&#105;&#x6c;&#116;&#111;&#58;&#x5b;&#x74;&#105;&#110;&#121;&#102;&#46;&#46;&#46;&#x40;&#103;&#x6d;&#97;&#105;&#108;&#x2e;&#99;&#111;&#x6d;&#x5d;&#x28;&#x29;">&#x5b;&#x74;&#105;&#110;&#121;&#102;&#46;&#46;&#46;&#x40;&#103;&#x6d;&#97;&#105;&#108;&#x2e;&#99;&#111;&#x6d;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#109;&#97;&#105;&#108;&#x74;&#x6f;&#x3a;&#x5b;&#106;&#x65;&#46;&#46;&#x2e;&#x40;&#108;&#105;&#x76;&#x65;&#x2e;&#99;&#x6f;&#x6d;&#93;&#40;&#x29;">&#x5b;&#106;&#x65;&#46;&#46;&#x2e;&#x40;&#108;&#105;&#x76;&#x65;&#x2e;&#99;&#x6f;&#x6d;&#93;&#40;&#x29;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#x6d;&#97;&#x69;&#108;&#116;&#111;&#58;&#x5b;&#99;&#x68;&#x65;&#110;&#103;&#x75;&#97;&#x6e;&#99;&#x68;&#x2e;&#46;&#x2e;&#64;&#x67;&#109;&#x61;&#105;&#108;&#46;&#x63;&#111;&#x6d;&#93;&#40;&#41;">&#x5b;&#99;&#x68;&#x65;&#110;&#103;&#x75;&#97;&#x6e;&#99;&#x68;&#x2e;&#46;&#x2e;&#64;&#x67;&#109;&#x61;&#105;&#108;&#46;&#x63;&#111;&#x6d;&#93;&#40;&#41;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#x6d;&#97;&#105;&#108;&#116;&#x6f;&#x3a;&#91;&#112;&#x6f;&#110;&#46;&#x2e;&#x2e;&#x40;&#x67;&#x6f;&#x6f;&#x67;&#x6c;&#x65;&#103;&#x72;&#x6f;&#x75;&#x70;&#115;&#46;&#x63;&#111;&#x6d;&#x5d;&#x28;&#41;">&#91;&#112;&#x6f;&#110;&#46;&#x2e;&#x2e;&#x40;&#x67;&#x6f;&#x6f;&#x67;&#x6c;&#x65;&#103;&#x72;&#x6f;&#x75;&#x70;&#115;&#46;&#x63;&#111;&#x6d;&#x5d;&#x28;&#41;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。...</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>阅读更多 &gt;&gt;
<a href="">显示删减掉的内容</a>
<img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-23</p>
<p>其他收件人：</p>
<p>教育以人为本，最终决定使用何种并行技术的还是程序员。目前业界对程序员并没有并行编程的技能要求，全民并行编程的时代什么时候才能到来？这是个问
题。</p>
<p>On 3月22日, 下午10时41分, windstorm <a href="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#111;&#x3a;&#91;&#x6c;&#x69;&#x6b;&#117;&#110;&#97;&#x72;&#x6d;&#x73;&#x74;&#114;&#x2e;&#x2e;&#46;&#x40;&#103;&#109;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#40;&#41;">&#91;&#x6c;&#x69;&#x6b;&#117;&#110;&#97;&#x72;&#x6d;&#x73;&#x74;&#114;&#x2e;&#x2e;&#46;&#x40;&#103;&#109;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>Larrabee当初我还是很看好的，它的架构比其他的更像一个统一的方案，可惜后来Intel自己经验不足搞不好。</p>
<p>OPENCL还是主要面向multimedia吧，CUDA/OpenCL在业界代表了流处理的方向，从GPU针对任务的角度讲是好的。其他的就算了。就像Al leluia说的那样，在硬件架构没有更多的突破之前，不说没有生命力，至少想取得任何进一步的突破都太难。</p>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>现在这个领域，你吹你的水，我吹我的水。至于谁的泡泡大，我看不清。所以真要选东西学，最好还是针对自己的application选靠谱。这也是并行编程教育难 的问题。大家需求完全不一样。</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Guancheng Chen <a href="&#109;&#x61;&#105;&#108;&#x74;&#111;&#x3a;&#x5b;&#99;&#x68;&#x65;&#110;&#x67;&#117;&#x61;&#x6e;&#x63;&#104;&#46;&#46;&#x2e;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#x6f;&#109;&#93;&#x28;&#41;">&#x5b;&#99;&#x68;&#x65;&#110;&#x67;&#117;&#x61;&#x6e;&#x63;&#104;&#46;&#46;&#x2e;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#x6f;&#109;&#93;&#x28;&#41;</a>:</p>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>&gt;
&gt;
&gt;</p>
<blockquote>
<blockquote>
<p>我觉得现有的OpenCL确实非常不成熟，但是从纯性能角度上来讲，我看好Heterogeneous架构，尽管它们的编程难度太大，就像前面提到的不
同架构需要做不同优化等。CPU的性能是latency-oriented，GPU是throughput-oriented,Intel的
Larrabee虽然现在来看不成功，但是业界都在朝着那个方向努力。</p>
<p>On 3月22日, 下午6时18分, windstorm <a href="&#x6d;&#x61;&#x69;&#x6c;&#116;&#111;&#58;&#x5b;&#108;&#x69;&#107;&#117;&#x6e;&#97;&#114;&#109;&#115;&#x74;&#114;&#46;&#46;&#x2e;&#64;&#x67;&#109;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#41;">&#x5b;&#108;&#x69;&#107;&#117;&#x6e;&#97;&#114;&#109;&#115;&#x74;&#114;&#46;&#46;&#x2e;&#64;&#x67;&#109;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>实在是不能同意你更多......很早很早以前我就在这里和人争论过，GPU的并行计算平台不可能一统天下的。CUDA也不是救世主。OpenCL更不是。</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Alleluia <a href="&#x6d;&#97;&#105;&#x6c;&#x74;&#x6f;&#x3a;&#91;&#x61;&#108;&#108;&#x75;&#108;&#x2e;&#x2e;&#46;&#64;&#x67;&#x6d;&#x61;&#105;&#108;&#x2e;&#99;&#x6f;&#x6d;&#93;&#x28;&#41;">&#91;&#x61;&#108;&#108;&#x75;&#108;&#x2e;&#x2e;&#46;&#64;&#x67;&#x6d;&#x61;&#105;&#108;&#x2e;&#99;&#x6f;&#x6d;&#93;&#x28;&#41;</a>:</p>
<blockquote>
<p>Parallelism 说到底是算法问题.Parallelism与Concurrency不同,Concurrency所面对的问题相对的单一可以
让一群有经验的专家来实现一套通用库或者语言来提供一个基本的编程框架.而在Parallelism上,具体的不同问题,其所需要并行的算法是根本不同
的.原因在于不同的问题,其内部的DataDependency的结构完全不同,不同的Data Dependency的结构,需要构造不同的算法.即
便是相同的Data Dependency,在不同的颗粒度下，在不同的硬件条件下所采用的算法也是完全不同的.因为一旦出现Data
Dependency也就意味着并行计算模块之间需要进行通信.从以计算节点为单位的分布式并行,到多核CPU上的Numa结构,到SIMD上的向量处
理器,其计算单元之间的通信手段,通信效率简直天差地别.比如说,在SMP上最常见的并行算法,work stealing也就是Intel的TBB,
是建立在两个条件下第一个是CPU的Cache机制上,这使得通常在内存的之间的数据搬运消耗非常小,第二个是SMP上计算单元相对的少,因此每个计算
单元被分配到的任务就相对的重。其开销远远大于通信的开销,因此这种机制在SMP上相对的划算.但是如果你要在GPU上做Work Stealing就
完全不可行,因为GPU的运算单元数量极多,被分配到的任务就相对来说的非常轻量,CUDA上的一个thread很多时候运算一次的时间不会超过
10us,而一次跨Block的线程之间的通信开销就往往要达到100us左右,再加上目前GPU上的Cache机制非常落后导致了需要频繁的通信开销
的Work Stealing在GPU上是非常不划算得.
所以我个人认为在硬件架构没有更多的突破之前,OpenCL这种东西是没有任何生命力的.不要说CPU的并行与GPU之间差异巨大,就是不同的GPU之
间AMD与Nvidia两个也是各自为政,一个平台上跑得非常快的东西,在另外一个平台极大的可能是龟速.其最终的结果估计就是跟Java的
write once run everywhere一样是个大笑话.</p>
<p>On 3月22日, 下午2时06分, Guancheng Chen <a href="&#x6d;&#x61;&#x69;&#108;&#116;&#x6f;&#58;&#x5b;&#x63;&#x68;&#x65;&#110;&#x67;&#117;&#x61;&#110;&#99;&#x68;&#x2e;&#x2e;&#46;&#x40;&#x67;&#x6d;&#97;&#105;&#108;&#x2e;&#99;&#111;&#x6d;&#93;&#40;&#41;">&#x5b;&#x63;&#x68;&#x65;&#110;&#x67;&#117;&#x61;&#110;&#99;&#x68;&#x2e;&#x2e;&#46;&#x40;&#x67;&#x6d;&#97;&#105;&#108;&#x2e;&#99;&#111;&#x6d;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>On 3月22日, 上午2时20分, Tinyfool <a href="&#109;&#x61;&#105;&#108;&#116;&#111;&#x3a;&#91;&#x74;&#x69;&#x6e;&#x79;&#x66;&#x2e;&#46;&#x2e;&#64;&#103;&#109;&#97;&#105;&#108;&#x2e;&#99;&#111;&#x6d;&#93;&#x28;&#41;">&#91;&#x74;&#x69;&#x6e;&#x79;&#x66;&#x2e;&#46;&#x2e;&#64;&#103;&#109;&#97;&#105;&#108;&#x2e;&#99;&#111;&#x6d;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#x6d;&#x61;&#105;&#108;&#x74;&#111;&#58;&#x5b;&#x6a;&#x65;&#x2e;&#x2e;&#x2e;&#x40;&#x6c;&#x69;&#x76;&#101;&#46;&#x63;&#x6f;&#109;&#93;&#40;&#x29;">&#x5b;&#x6a;&#x65;&#x2e;&#x2e;&#x2e;&#x40;&#x6c;&#x69;&#x76;&#101;&#46;&#x63;&#x6f;&#109;&#93;&#40;&#x29;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#x6d;&#x61;&#105;&#x6c;&#116;&#x6f;&#x3a;&#91;&#99;&#x68;&#x65;&#110;&#103;&#117;&#x61;&#110;&#x63;&#104;&#46;&#x2e;&#46;&#64;&#103;&#109;&#x61;&#105;&#x6c;&#46;&#99;&#x6f;&#109;&#93;&#x28;&#41;">&#91;&#99;&#x68;&#x65;&#110;&#103;&#117;&#x61;&#110;&#x63;&#104;&#46;&#x2e;&#46;&#64;&#103;&#109;&#x61;&#105;&#x6c;&#46;&#99;&#x6f;&#109;&#93;&#x28;&#41;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#109;&#x61;&#105;&#x6c;&#x74;&#111;&#58;&#x5b;&#x70;&#111;&#110;&#x2e;&#46;&#x2e;&#64;&#x67;&#x6f;&#111;&#103;&#108;&#101;&#x67;&#114;&#x6f;&#x75;&#x70;&#115;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#x29;">&#x5b;&#x70;&#111;&#110;&#x2e;&#46;&#x2e;&#64;&#x67;&#x6f;&#111;&#103;&#108;&#101;&#x67;&#114;&#x6f;&#x75;&#x70;&#115;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#x29;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线...</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>阅读更多 &gt;&gt;
<a href="">显示删减掉的内容</a></p>
</blockquote>
<p><img src="" alt=""> windstorm <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-23</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>全民并行编程的时代，只有在全民能够并行编程的时候才会到来嘛，现在不是这个时候</p>
<p>我个人倾向于等待一个比较好的统一性架构。两条路：</p>
<p>一是某一个全新概念的提出，这个要看学术界的努力，而且在某种意义上讲，学术界搞出一个真正可行的并行架构的可能性比工业界更高。虽说今天多核的发展是工业界引领的，但是点子还是最早学术界提出的。典型的有几个：斯坦福的Hydra（1996），斯坦福的Imagine(2000)，MIT的RAW（2002），以及UT奥斯丁的TRIPS（2003）。在这个问题上，是不得不佩服美国的创造力，要知道直到在2000年左右，所有的人都还在为处理器频率按照摩尔定律翻翻而狂热，美国的顶尖研究员就早已看到了这条路的尽头并指出未来处理器的发展之路。</p>
<p>二是你用现有的架构，但是application引导。如果要找一个面向多application
domain的话，刚才说了，本来看好Larrabee，因为它的架构解决了CUDA一个很大的潜在问题，而且允许现有程序员不经过任何特殊training就上手编程，包括图形图像，科学计算，或者网络处理，各个领域。</p>
<p>不过可能就是因为这个solution的过于理想化导致结构的过于复杂化，才让其目前暂时流产。</p>
<p>总的来说，现在的问题就是软件发展不成熟，硬件发展不完善，你没法靠程序员决定使用什么并行技术，完全靠应用主导，这套技术在这个应用上如鱼得水，在那个应用上完全不罩，作为程序员，有什么办法？</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p><a href="http://www.kunli.info/" target="_blank">www.kunli.info</a>
<a href="http://twitter.com/cnbuff" target="_blank"><a href="http://twitter.com/cnbuff">http://twitter.com/cnbuff</a></a></p>
<p>2010/3/22 Guancheng Chen <a href="&#109;&#x61;&#105;&#x6c;&#116;&#x6f;&#58;&#x5b;&#x63;&#104;&#x65;&#110;&#x67;&#x75;&#x2e;&#x2e;&#46;&#64;&#x67;&#x6d;&#97;&#105;&#x6c;&#x2e;&#99;&#x6f;&#109;&#x5d;&#40;&#41;">&#x5b;&#x63;&#104;&#x65;&#110;&#x67;&#x75;&#x2e;&#x2e;&#46;&#64;&#x67;&#x6d;&#97;&#105;&#x6c;&#x2e;&#99;&#x6f;&#109;&#x5d;&#40;&#41;</a>:</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<blockquote>
<p>教育以人为本，最终决定使用何种并行技术的还是程序员。目前业界对程序员并没有并行编程的技能要求，全民并行编程的时代什么时候才能到来？这是个问
题。</p>
<p>On 3月22日, 下午10时41分, windstorm <a href="&#109;&#x61;&#105;&#108;&#116;&#x6f;&#58;&#91;&#x6c;&#x69;&#x6b;&#117;&#x6e;&#x61;&#114;&#x6d;&#x73;&#116;&#114;&#46;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#97;&#x69;&#108;&#46;&#x63;&#111;&#x6d;&#x5d;&#40;&#41;">&#91;&#x6c;&#x69;&#x6b;&#117;&#x6e;&#x61;&#114;&#x6d;&#x73;&#116;&#114;&#46;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#97;&#x69;&#108;&#46;&#x63;&#111;&#x6d;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>Larrabee当初我还是很看好的，它的架构比其他的更像一个统一的方案，可惜后来Intel自己经验不足搞不好。</p>
<p>OPENCL还是主要面向multimedia吧，CUDA/OpenCL在业界代表了流处理的方向，从GPU针对任务的角度讲是好的。其他的就算了。就像Al leluia说的那样，在硬件架构没有更多的突破之前，不说没有生命力，至少想取得任何进一步的突破都太难。</p>
<p>现在这个领域，你吹你的水，我吹我的水。至于谁的泡泡大，我看不清。所以真要选东西学，最好还是针对自己的application选靠谱。这也是并行编程教育难 的问题。大家需求完全不一样。</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Guancheng Chen <a href="&#x6d;&#x61;&#105;&#x6c;&#x74;&#x6f;&#x3a;&#x5b;&#x63;&#104;&#x65;&#x6e;&#103;&#x75;&#x61;&#x6e;&#99;&#x68;&#46;&#x2e;&#x2e;&#x40;&#x67;&#109;&#97;&#105;&#108;&#x2e;&#x63;&#111;&#109;&#93;&#40;&#41;">&#x5b;&#x63;&#104;&#x65;&#x6e;&#103;&#x75;&#x61;&#x6e;&#99;&#x68;&#46;&#x2e;&#x2e;&#x40;&#x67;&#109;&#97;&#105;&#108;&#x2e;&#x63;&#111;&#109;&#93;&#40;&#41;</a>:</p>
<blockquote>
<p>我觉得现有的OpenCL确实非常不成熟，但是从纯性能角度上来讲，我看好Heterogeneous架构，尽管它们的编程难度太大，就像前面提到的不
同架构需要做不同优化等。CPU的性能是latency-oriented，GPU是throughput-oriented,Intel的
Larrabee虽然现在来看不成功，但是业界都在朝着那个方向努力。</p>
<p>On 3月22日, 下午6时18分, windstorm <a href="&#109;&#x61;&#105;&#x6c;&#x74;&#x6f;&#58;&#91;&#108;&#x69;&#x6b;&#117;&#110;&#x61;&#x72;&#x6d;&#x73;&#x74;&#114;&#46;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#97;&#x69;&#x6c;&#46;&#99;&#111;&#x6d;&#x5d;&#40;&#x29;">&#91;&#108;&#x69;&#x6b;&#117;&#110;&#x61;&#x72;&#x6d;&#x73;&#x74;&#114;&#46;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#97;&#x69;&#x6c;&#46;&#99;&#111;&#x6d;&#x5d;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>实在是不能同意你更多......很早很早以前我就在这里和人争论过，GPU的并行计算平台不可能一统天下的。CUDA也不是救世主。OpenCL更不是。</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Alleluia <a href="&#x6d;&#97;&#x69;&#x6c;&#x74;&#111;&#x3a;&#91;&#x61;&#108;&#108;&#117;&#108;&#46;&#46;&#x2e;&#64;&#x67;&#109;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#111;&#109;&#93;&#x28;&#x29;">&#91;&#x61;&#108;&#108;&#117;&#108;&#46;&#46;&#x2e;&#64;&#x67;&#109;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#111;&#109;&#93;&#x28;&#x29;</a>:</p>
<blockquote>
<p>Parallelism 说到底是算法问题.Parallelism与Concurrency不同,Concurrency所面对的问题相对的单一可以
让一群有经验的专家来实现一套通用库或者语言来提供一个基本的编程框架.而在Parallelism上,具体的不同问题,其所需要并行的算法是根本不同
的.原因在于不同的问题,其内部的DataDependency的结构完全不同,不同的Data Dependency的结构,需要构造不同的算法.即
便是相同的Data Dependency,在不同的颗粒度下，在不同的硬件条件下所采用的算法也是完全不同的.因为一旦出现Data
Dependency也就意味着并行计算模块之间需要进行通信.从以计算节点为单位的分布式并行,到多核CPU上的Numa结构,到SIMD上的向量处
理器,其计算单元之间的通信手段,通信效率简直天差地别.比如说,在SMP上最常见的并行算法,work stealing也就是Intel的TBB,
是建立在两个条件下第一个是CPU的Cache机制上,这使得通常在内存的之间的数据搬运消耗非常小,第二个是SMP上计算单元相对的少,因此每个计算
单元被分配到的任务就相对的重。其开销远远大于通信的开销,因此这种机制在SMP上相对的划算.但是如果你要在GPU上做Work Stealing就
完全不可行,因为GPU的运算单元数量极多,被分配到的任务就相对来说的非常轻量,CUDA上的一个thread很多时候运算一次的时间不会超过
10us,而一次跨Block的线程之间的通信开销就往往要达到100us左右,再加上目前GPU上的Cache机制非常落后导致了需要频繁的通信开销
的Work Stealing在GPU上是非常不划算得.
所以我个人认为在硬件架构没有更多的突破之前,OpenCL这种东西是没有任何生命力的.不要说CPU的并行与GPU之间差异巨大,就是不同的GPU之
间AMD与Nvidia两个也是各自为政,一个平台上跑得非常快的东西,在另外一个平台极大的可能是龟速.其最终的结果估计就是跟Java的
write once run everywhere一样是个大笑话.</p>
<p>On 3月22日, 下午2时06分, Guancheng Chen <a href="&#109;&#97;&#x69;&#108;&#116;&#x6f;&#58;&#x5b;&#99;&#104;&#x65;&#110;&#x67;&#x75;&#97;&#110;&#x63;&#104;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#109;&#97;&#x69;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#93;&#40;&#x29;">&#x5b;&#99;&#104;&#x65;&#110;&#x67;&#x75;&#97;&#110;&#x63;&#104;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#109;&#97;&#x69;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>On 3月22日, 上午2时20分, Tinyfool <a href="&#109;&#97;&#x69;&#108;&#116;&#x6f;&#x3a;&#91;&#x74;&#x69;&#110;&#x79;&#x66;&#46;&#x2e;&#x2e;&#x40;&#x67;&#109;&#x61;&#105;&#x6c;&#46;&#99;&#x6f;&#109;&#x5d;&#x28;&#41;">&#91;&#x74;&#x69;&#110;&#x79;&#x66;&#46;&#x2e;&#x2e;&#x40;&#x67;&#109;&#x61;&#105;&#x6c;&#46;&#99;&#x6f;&#109;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#109;&#97;&#x69;&#108;&#x74;&#111;&#58;&#91;&#x6a;&#101;&#x2e;&#46;&#46;&#64;&#108;&#105;&#x76;&#x65;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#40;&#41;">&#91;&#x6a;&#101;&#x2e;&#46;&#46;&#64;&#108;&#105;&#x76;&#x65;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#40;&#41;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#109;&#x61;&#105;&#x6c;&#x74;&#111;&#x3a;&#91;&#99;&#104;&#x65;&#x6e;&#x67;&#x75;&#97;&#x6e;&#99;&#104;&#x2e;&#46;&#46;&#x40;&#103;&#109;&#97;&#x69;&#x6c;&#x2e;&#x63;&#111;&#109;&#93;&#40;&#41;">&#91;&#99;&#104;&#x65;&#x6e;&#x67;&#x75;&#97;&#x6e;&#99;&#104;&#x2e;&#46;&#46;&#x40;&#103;&#109;&#97;&#x69;&#x6c;&#x2e;&#x63;&#111;&#109;&#93;&#40;&#41;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#109;&#x61;&#x69;&#x6c;&#116;&#x6f;&#x3a;&#91;&#112;&#x6f;&#x6e;&#46;&#x2e;&#x2e;&#x40;&#x67;&#x6f;&#111;&#103;&#x6c;&#101;&#103;&#x72;&#111;&#x75;&#x70;&#115;&#x2e;&#x63;&#111;&#x6d;&#93;&#x28;&#x29;">&#91;&#112;&#x6f;&#x6e;&#46;&#x2e;&#x2e;&#x40;&#x67;&#x6f;&#111;&#103;&#x6c;&#101;&#103;&#x72;&#111;&#x75;&#x70;&#115;&#x2e;&#x63;&#111;&#x6d;&#93;&#x28;&#x29;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线...</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>阅读更多 &gt;&gt;</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p><a href="">显示删减掉的内容</a>
<img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-23</p>
<p>其他收件人：</p>
<p>恩</p>
<p>第二点其实我就是指程序员根据他自己的程序领域选择合适的并行技术。Top Language真是藏龙卧虎啊。你是在Boulder么?我一个大学女同
学在你那读MIS的phd</p>
<p>On 3月23日, 上午12时04分, windstorm <a href="&#x6d;&#x61;&#105;&#x6c;&#x74;&#111;&#58;&#91;&#108;&#105;&#x6b;&#x75;&#x6e;&#97;&#114;&#109;&#x73;&#x74;&#114;&#46;&#46;&#46;&#64;&#x67;&#109;&#x61;&#105;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#93;&#x28;&#x29;">&#91;&#108;&#105;&#x6b;&#x75;&#x6e;&#97;&#114;&#109;&#x73;&#x74;&#114;&#46;&#46;&#46;&#64;&#x67;&#109;&#x61;&#105;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>全民并行编程的时代，只有在全民能够并行编程的时候才会到来嘛，现在不是这个时候</p>
<p>我个人倾向于等待一个比较好的统一性架构。两条路：</p>
<p>一是某一个全新概念的提出，这个要看学术界的努力，而且在某种意义上讲，学术界搞出一个真正可行的并行架构的可能性比工业界更高。虽说今天多核的发展是工业界引 领的，但是点子还是最早学术界提出的。典型的有几个：斯坦福的Hydra（1996），斯坦福的Imagine(2000)，MIT的RAW（2002），以及 UT奥斯丁的TRIPS（2003）。在这个问题上，是不得不佩服美国的创造力，要知道直到在2000年左右，所有的人都还在为处理器频率按照摩尔定律翻翻而狂 热，美国的顶尖研究员就早已看到了这条路的尽头并指出未来处理器的发展之路。</p>
<p>二是你用现有的架构，但是application引导。如果要找一个面向多application
domain的话，刚才说了，本来看好Larrabee，因为它的架构解决了CUDA一个很大的潜在问题，而且允许现有程序员不经过任何特殊training就 上手编程，包括图形图像，科学计算，或者网络处理，各个领域。</p>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>不过可能就是因为这个solution的过于理想化导致结构的过于复杂化，才让其目前暂时流产。</p>
<p>总的来说，现在的问题就是软件发展不成熟，硬件发展不完善，你没法靠程序员决定使用什么并行技术，完全靠应用主导，这套技术在这个应用上如鱼得水，在那个应用上 完全不罩，作为程序员，有什么办法？</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Guancheng Chen <a href="&#109;&#x61;&#x69;&#108;&#x74;&#x6f;&#x3a;&#91;&#99;&#104;&#x65;&#110;&#x67;&#117;&#97;&#110;&#99;&#104;&#46;&#46;&#x2e;&#64;&#x67;&#109;&#x61;&#105;&#x6c;&#46;&#x63;&#x6f;&#109;&#93;&#40;&#41;">&#91;&#99;&#104;&#x65;&#110;&#x67;&#117;&#97;&#110;&#99;&#104;&#46;&#46;&#x2e;&#64;&#x67;&#109;&#x61;&#105;&#x6c;&#46;&#x63;&#x6f;&#109;&#93;&#40;&#41;</a>:</p>
<blockquote>
<p>教育以人为本，最终决定使用何种并行技术的还是程序员。目前业界对程序员并没有并行编程的技能要求，全民并行编程的时代什么时候才能到来？这是个问
题。</p>
<p>On 3月22日, 下午10时41分, windstorm <a href="&#x6d;&#97;&#105;&#x6c;&#x74;&#111;&#58;&#x5b;&#x6c;&#x69;&#x6b;&#117;&#x6e;&#97;&#114;&#x6d;&#115;&#116;&#114;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#97;&#x69;&#108;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#x29;">&#x5b;&#x6c;&#x69;&#x6b;&#117;&#x6e;&#97;&#114;&#x6d;&#115;&#116;&#114;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#97;&#x69;&#108;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>Larrabee当初我还是很看好的，它的架构比其他的更像一个统一的方案，可惜后来Intel自己经验不足搞不好。</p>
<p>OPENCL还是主要面向multimedia吧，CUDA/OpenCL在业界代表了流处理的方向，从GPU针对任务的角度讲是好的。其他的就算了。就像Al leluia说的那样，在硬件架构没有更多的突破之前，不说没有生命力，至少想取得任何进一步的突破都太难。</p>
<p>现在这个领域，你吹你的水，我吹我的水。至于谁的泡泡大，我看不清。所以真要选东西学，最好还是针对自己的application选靠谱。这也是并行编程教育难 的问题。大家需求完全不一样。</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Guancheng Chen <a href="&#x6d;&#x61;&#x69;&#108;&#116;&#111;&#58;&#x5b;&#x63;&#x68;&#x65;&#110;&#x67;&#117;&#97;&#x6e;&#x63;&#x68;&#46;&#46;&#x2e;&#x40;&#103;&#x6d;&#97;&#105;&#108;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#40;&#41;">&#x5b;&#x63;&#x68;&#x65;&#110;&#x67;&#117;&#97;&#x6e;&#x63;&#x68;&#46;&#46;&#x2e;&#x40;&#103;&#x6d;&#97;&#105;&#108;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#40;&#41;</a>:</p>
<blockquote>
<p>我觉得现有的OpenCL确实非常不成熟，但是从纯性能角度上来讲，我看好Heterogeneous架构，尽管它们的编程难度太大，就像前面提到的不
同架构需要做不同优化等。CPU的性能是latency-oriented，GPU是throughput-oriented,Intel的
Larrabee虽然现在来看不成功，但是业界都在朝着那个方向努力。</p>
<p>On 3月22日, 下午6时18分, windstorm <a href="&#x6d;&#97;&#x69;&#x6c;&#x74;&#111;&#x3a;&#x5b;&#108;&#x69;&#107;&#x75;&#x6e;&#97;&#114;&#x6d;&#x73;&#x74;&#x72;&#x2e;&#46;&#46;&#x40;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#99;&#111;&#109;&#93;&#x28;&#41;">&#x5b;&#108;&#x69;&#107;&#x75;&#x6e;&#97;&#114;&#x6d;&#x73;&#x74;&#x72;&#x2e;&#46;&#46;&#x40;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#99;&#111;&#109;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>实在是不能同意你更多......很早很早以前我就在这里和人争论过，GPU的并行计算平台不可能一统天下的。CUDA也不是救世主。OpenCL更不是。</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Alleluia <a href="&#109;&#97;&#x69;&#x6c;&#116;&#111;&#58;&#91;&#x61;&#x6c;&#x6c;&#117;&#108;&#46;&#x2e;&#x2e;&#64;&#x67;&#109;&#97;&#x69;&#x6c;&#46;&#99;&#111;&#x6d;&#93;&#x28;&#x29;">&#91;&#x61;&#x6c;&#x6c;&#117;&#108;&#46;&#x2e;&#x2e;&#64;&#x67;&#109;&#97;&#x69;&#x6c;&#46;&#99;&#111;&#x6d;&#93;&#x28;&#x29;</a>:</p>
<blockquote>
<p>Parallelism 说到底是算法问题.Parallelism与Concurrency不同,Concurrency所面对的问题相对的单一可以
让一群有经验的专家来实现一套通用库或者语言来提供一个基本的编程框架.而在Parallelism上,具体的不同问题,其所需要并行的算法是根本不同
的.原因在于不同的问题,其内部的DataDependency的结构完全不同,不同的Data Dependency的结构,需要构造不同的算法.即
便是相同的Data Dependency,在不同的颗粒度下，在不同的硬件条件下所采用的算法也是完全不同的.因为一旦出现Data
Dependency也就意味着并行计算模块之间需要进行通信.从以计算节点为单位的分布式并行,到多核CPU上的Numa结构,到SIMD上的向量处
理器,其计算单元之间的通信手段,通信效率简直天差地别.比如说,在SMP上最常见的并行算法,work stealing也就是Intel的TBB,
是建立在两个条件下第一个是CPU的Cache机制上,这使得通常在内存的之间的数据搬运消耗非常小,第二个是SMP上计算单元相对的少,因此每个计算
单元被分配到的任务就相对的重。其开销远远大于通信的开销,因此这种机制在SMP上相对的划算.但是如果你要在GPU上做Work Stealing就
完全不可行,因为GPU的运算单元数量极多,被分配到的任务就相对来说的非常轻量,CUDA上的一个thread很多时候运算一次的时间不会超过
10us,而一次跨Block的线程之间的通信开销就往往要达到100us左右,再加上目前GPU上的Cache机制非常落后导致了需要频繁的通信开销
的Work Stealing在GPU上是非常不划算得.
所以我个人认为在硬件架构没有更多的突破之前,OpenCL这种东西是没有任何生命力的.不要说CPU的并行与GPU之间差异巨大,就是不同的GPU之
间AMD与Nvidia两个也是各自为政,一个平台上跑得非常快的东西,在另外一个平台极大的可能是龟速.其最终的结果估计就是跟Java的
write once run everywhere一样是个大笑话.</p>
<p>On 3月22日, 下午2时06分, Guancheng Chen <a href="&#109;&#97;&#x69;&#108;&#116;&#x6f;&#58;&#x5b;&#99;&#x68;&#101;&#110;&#x67;&#117;&#x61;&#110;&#99;&#104;&#46;&#x2e;&#x2e;&#64;&#103;&#x6d;&#x61;&#x69;&#x6c;&#46;&#99;&#x6f;&#109;&#x5d;&#40;&#x29;">&#x5b;&#99;&#x68;&#101;&#110;&#x67;&#117;&#x61;&#110;&#99;&#104;&#46;&#x2e;&#x2e;&#64;&#103;&#x6d;&#x61;&#x69;&#x6c;&#46;&#99;&#x6f;&#109;&#x5d;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>On 3月22日, 上午2时20分, Tinyfool <a href="&#x6d;&#97;&#x69;&#x6c;&#x74;&#111;&#58;&#x5b;&#x74;&#x69;&#x6e;&#121;&#102;&#x2e;&#46;&#46;&#x40;&#x67;&#109;&#x61;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#41;">&#x5b;&#x74;&#x69;&#x6e;&#121;&#102;&#x2e;&#46;&#46;&#x40;&#x67;&#109;&#x61;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#109;&#x61;&#x69;&#108;&#116;&#x6f;&#58;&#x5b;&#x6a;&#x65;&#x2e;&#x2e;&#46;&#x40;&#x6c;&#105;&#x76;&#x65;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#40;&#41;">&#x5b;&#x6a;&#x65;&#x2e;&#x2e;&#46;&#x40;&#x6c;&#105;&#x76;&#x65;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#40;&#41;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#x6d;&#x61;&#x69;&#108;&#116;&#x6f;&#x3a;&#x5b;&#x63;&#104;&#x65;&#110;&#x67;&#117;&#97;&#x6e;&#x63;&#x68;&#46;&#x2e;&#46;&#64;&#x67;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#93;&#x28;&#x29;">&#x5b;&#x63;&#104;&#x65;&#110;&#x67;&#117;&#97;&#x6e;&#x63;&#x68;&#46;&#x2e;&#46;&#64;&#x67;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#93;&#x28;&#x29;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#x6d;&#x61;&#105;&#x6c;&#x74;&#111;&#58;&#x5b;&#112;&#111;&#x6e;&#46;&#x2e;&#x2e;&#x40;&#103;&#111;&#111;&#103;&#x6c;&#101;&#x67;&#114;&#x6f;&#x75;&#x70;&#x73;&#x2e;&#x63;&#111;&#x6d;&#93;&#40;&#x29;">&#x5b;&#112;&#111;&#x6e;&#46;&#x2e;&#x2e;&#x40;&#103;&#111;&#111;&#103;&#x6c;&#101;&#x67;&#114;&#x6f;&#x75;&#x70;&#x73;&#x2e;&#x63;&#111;&#x6d;&#93;&#40;&#x29;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器...</li>
</ol>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>阅读更多 &gt;&gt;
<a href="">显示删减掉的内容</a></p>
</blockquote>
<p><img src="" alt=""> Alleluia <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-23</p>
<p>其他收件人：</p>
<p>我不是搞体系结构的.但是我认为目前来说做Parallelism的人首先不是去熟悉什么API或者Libarary,而是要熟悉两样东西体系结构和算
法.没有这两样,几乎写不出什么高效率的并行程序.当然你的需求只是并行化循环这种简单的东西当然可以里例外.呵呵.
我觉得你最好放弃用GPGPU去搞遗留代码的想法.现在市面上的GPU产品无论是A记的还是N记的其编程架构与CPU完全不同,你不要想把一个循环简单
的porting到GPU上就能并行了.那是几乎不可能的,比如最简单的你如何处理branch?如果branch非常多,divergence会把速
度拖得比CPU版本还慢.你如何处理CPU代码里的数组随机访问,在GPU上无论是片上的还是片外的内存是不能随机访问的,最要命的是没有cache,
随机访问的代价极其高昂.你几乎需要把CPU上的代码面目全非地从新写一遍,遗留代码除了用作调试测试做结果比对之外几乎要全部抛弃.</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>On 3月23日, 上午6时42分, Guancheng Chen <a href="&#109;&#97;&#x69;&#108;&#116;&#x6f;&#x3a;&#91;&#x63;&#104;&#101;&#110;&#x67;&#117;&#x61;&#x6e;&#99;&#104;&#46;&#46;&#46;&#64;&#x67;&#109;&#97;&#x69;&#108;&#46;&#x63;&#111;&#109;&#93;&#40;&#x29;">&#91;&#x63;&#104;&#101;&#110;&#x67;&#117;&#x61;&#x6e;&#99;&#104;&#46;&#46;&#46;&#64;&#x67;&#109;&#97;&#x69;&#108;&#46;&#x63;&#111;&#109;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>恩 您也是搞体系结构的么？
现在我在跟瑞典这边的爱立信合作做毕设 不过对象不是他们的Erlang 而是传统的C/C++程序 下半年可能我也去搞GPGPU了 因为它的
data parallel模型对遗留代码的并行化很有搞头，现在我粗略的想法是把Compute sensitive的任务放一部分到GPU上去做，
当然我也对GPU目前的一些限制有所了解 但是一些探索工作还是非常值得的 到时候还想向前辈多多请教</p>
<p>On 3月22日, 下午11时30分, Alleluia <a href="&#109;&#x61;&#x69;&#108;&#116;&#111;&#58;&#91;&#97;&#x6c;&#x6c;&#117;&#x6c;&#x2e;&#x2e;&#46;&#64;&#x67;&#109;&#97;&#x69;&#108;&#x2e;&#99;&#111;&#109;&#93;&#40;&#x29;">&#91;&#97;&#x6c;&#x6c;&#117;&#x6c;&#x2e;&#x2e;&#46;&#64;&#x67;&#109;&#97;&#x69;&#108;&#x2e;&#99;&#111;&#109;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>Heterogeneous目前来看也是一个暂时的过渡性的东西. Heterogeneous架构最大的问题还是硬件,CPU和GPU之间的
PCIE2的bus带宽太窄了.在上面来回传递一次几M的内存可能需要化掉500us左右.如果一个算法本来就是在3-4ms级别的,你要用GPU去优
化,内存带宽的消耗就占了1/10,这是非常可怕的事情.或许像AMD那种Fusion架构是一种趋势,但是目前来说没有太大的进展.貌似AMD出了一
款混合的CPU,但是貌似还没有看到有多大的优势.
On 3月23日, 上午5时02分, Guancheng Chen <a href="&#x6d;&#x61;&#105;&#x6c;&#116;&#x6f;&#58;&#x5b;&#x63;&#x68;&#101;&#x6e;&#x67;&#117;&#x61;&#x6e;&#99;&#x68;&#x2e;&#x2e;&#x2e;&#64;&#103;&#109;&#97;&#105;&#108;&#x2e;&#x63;&#111;&#109;&#x5d;&#x28;&#x29;">&#x5b;&#x63;&#x68;&#101;&#x6e;&#x67;&#117;&#x61;&#x6e;&#99;&#x68;&#x2e;&#x2e;&#x2e;&#64;&#103;&#109;&#97;&#105;&#108;&#x2e;&#x63;&#111;&#109;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>我觉得现有的OpenCL确实非常不成熟，但是从纯性能角度上来讲，我看好Heterogeneous架构，尽管它们的编程难度太大，就像前面提到的不
同架构需要做不同优化等。CPU的性能是latency-oriented，GPU是throughput-oriented,Intel的
Larrabee虽然现在来看不成功，但是业界都在朝着那个方向努力。</p>
<p>On 3月22日, 下午6时18分, windstorm <a href="&#x6d;&#x61;&#105;&#x6c;&#116;&#x6f;&#x3a;&#x5b;&#x6c;&#105;&#107;&#x75;&#110;&#97;&#x72;&#x6d;&#x73;&#x74;&#114;&#46;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#97;&#x69;&#108;&#46;&#99;&#111;&#109;&#93;&#40;&#41;">&#x5b;&#x6c;&#105;&#107;&#x75;&#110;&#97;&#x72;&#x6d;&#x73;&#x74;&#114;&#46;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#97;&#x69;&#108;&#46;&#99;&#111;&#109;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>实在是不能同意你更多......很早很早以前我就在这里和人争论过，GPU的并行计算平台不可能一统天下的。CUDA也不是救世主。OpenCL更不是。</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Alleluia <a href="&#109;&#x61;&#x69;&#108;&#x74;&#111;&#x3a;&#91;&#97;&#x6c;&#x6c;&#x75;&#108;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#109;&#97;&#105;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#x29;">&#91;&#97;&#x6c;&#x6c;&#x75;&#108;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#109;&#97;&#105;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#x29;</a>:</p>
<blockquote>
<p>Parallelism 说到底是算法问题.Parallelism与Concurrency不同,Concurrency所面对的问题相对的单一可以
让一群有经验的专家来实现一套通用库或者语言来提供一个基本的编程框架.而在Parallelism上,具体的不同问题,其所需要并行的算法是根本不同
的.原因在于不同的问题,其内部的DataDependency的结构完全不同,不同的Data Dependency的结构,需要构造不同的算法.即
便是相同的Data Dependency,在不同的颗粒度下，在不同的硬件条件下所采用的算法也是完全不同的.因为一旦出现Data
Dependency也就意味着并行计算模块之间需要进行通信.从以计算节点为单位的分布式并行,到多核CPU上的Numa结构,到SIMD上的向量处
理器,其计算单元之间的通信手段,通信效率简直天差地别.比如说,在SMP上最常见的并行算法,work stealing也就是Intel的TBB,
是建立在两个条件下第一个是CPU的Cache机制上,这使得通常在内存的之间的数据搬运消耗非常小,第二个是SMP上计算单元相对的少,因此每个计算
单元被分配到的任务就相对的重。其开销远远大于通信的开销,因此这种机制在SMP上相对的划算.但是如果你要在GPU上做Work Stealing就
完全不可行,因为GPU的运算单元数量极多,被分配到的任务就相对来说的非常轻量,CUDA上的一个thread很多时候运算一次的时间不会超过
10us,而一次跨Block的线程之间的通信开销就往往要达到100us左右,再加上目前GPU上的Cache机制非常落后导致了需要频繁的通信开销
的Work Stealing在GPU上是非常不划算得.
所以我个人认为在硬件架构没有更多的突破之前,OpenCL这种东西是没有任何生命力的.不要说CPU的并行与GPU之间差异巨大,就是不同的GPU之
间AMD与Nvidia两个也是各自为政,一个平台上跑得非常快的东西,在另外一个平台极大的可能是龟速.其最终的结果估计就是跟Java的
write once run everywhere一样是个大笑话.</p>
<p>On 3月22日, 下午2时06分, Guancheng Chen <a href="&#109;&#x61;&#x69;&#x6c;&#x74;&#111;&#x3a;&#91;&#x63;&#x68;&#101;&#x6e;&#x67;&#x75;&#x61;&#x6e;&#99;&#104;&#46;&#46;&#46;&#64;&#x67;&#x6d;&#97;&#x69;&#x6c;&#46;&#99;&#111;&#x6d;&#93;&#40;&#41;">&#91;&#x63;&#x68;&#101;&#x6e;&#x67;&#x75;&#x61;&#x6e;&#99;&#104;&#46;&#46;&#46;&#64;&#x67;&#x6d;&#97;&#x69;&#x6c;&#46;&#99;&#111;&#x6d;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>On 3月22日, 上午2时20分, Tinyfool <a href="&#x6d;&#x61;&#x69;&#x6c;&#116;&#x6f;&#58;&#91;&#116;&#105;&#x6e;&#x79;&#x66;&#46;&#46;&#x2e;&#x40;&#x67;&#109;&#x61;&#x69;&#x6c;&#x2e;&#99;&#111;&#x6d;&#93;&#x28;&#x29;">&#91;&#116;&#105;&#x6e;&#x79;&#x66;&#46;&#46;&#x2e;&#x40;&#x67;&#109;&#x61;&#x69;&#x6c;&#x2e;&#99;&#111;&#x6d;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#109;&#x61;&#x69;&#108;&#116;&#x6f;&#58;&#x5b;&#106;&#x65;&#46;&#x2e;&#46;&#64;&#108;&#105;&#118;&#x65;&#x2e;&#x63;&#111;&#109;&#93;&#x28;&#41;">&#x5b;&#106;&#x65;&#46;&#x2e;&#46;&#64;&#108;&#105;&#118;&#x65;&#x2e;&#x63;&#111;&#109;&#93;&#x28;&#41;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#x6d;&#97;&#105;&#108;&#x74;&#111;&#x3a;&#91;&#x63;&#104;&#101;&#110;&#x67;&#117;&#x61;&#110;&#99;&#x68;&#x2e;&#46;&#46;&#x40;&#103;&#109;&#97;&#x69;&#108;&#46;&#x63;&#111;&#109;&#93;&#x28;&#x29;">&#91;&#x63;&#104;&#101;&#110;&#x67;&#117;&#x61;&#110;&#99;&#x68;&#x2e;&#46;&#46;&#x40;&#103;&#109;&#97;&#x69;&#108;&#46;&#x63;&#111;&#109;&#93;&#x28;&#x29;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#109;&#97;&#105;&#108;&#x74;&#111;&#x3a;&#x5b;&#x70;&#x6f;&#110;&#46;&#x2e;&#x2e;&#x40;&#x67;&#111;&#x6f;&#103;&#x6c;&#101;&#x67;&#114;&#111;&#x75;&#112;&#x73;&#x2e;&#99;&#111;&#x6d;&#x5d;&#40;&#x29;">&#x5b;&#x70;&#x6f;&#110;&#46;&#x2e;&#x2e;&#x40;&#x67;&#111;&#x6f;&#103;&#x6c;&#101;&#x67;&#114;&#111;&#x75;&#112;&#x73;&#x2e;&#99;&#111;&#x6d;&#x5d;&#40;&#x29;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发</p>
</li>
</ol>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>...</p>
<p>阅读更多 &gt;&gt;
<a href="">显示删减掉的内容</a>
<img src="" alt=""> Alleluia <img src="" alt=""></p>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-23</p>
<p>其他收件人：</p>
<p>我当初就不看好Larrabee这个东西,想想一个Core上一个Decoder就要消耗1瓦的功率,32个捆起来这个Core的功率要多大啊.我觉得
一捆Arm棒在一起都比PII靠谱.</p>
<p>On 3月23日, 上午5时41分, windstorm <a href="&#109;&#97;&#105;&#108;&#x74;&#x6f;&#x3a;&#x5b;&#108;&#105;&#107;&#117;&#110;&#97;&#x72;&#109;&#x73;&#116;&#114;&#x2e;&#46;&#x2e;&#64;&#103;&#x6d;&#x61;&#105;&#108;&#46;&#99;&#x6f;&#109;&#93;&#40;&#41;">&#x5b;&#108;&#105;&#107;&#117;&#110;&#97;&#x72;&#109;&#x73;&#116;&#114;&#x2e;&#46;&#x2e;&#64;&#103;&#x6d;&#x61;&#105;&#108;&#46;&#99;&#x6f;&#109;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>Larrabee当初我还是很看好的，它的架构比其他的更像一个统一的方案，可惜后来Intel自己经验不足搞不好。</p>
<p>OPENCL还是主要面向multimedia吧，CUDA/OpenCL在业界代表了流处理的方向，从GPU针对任务的角度讲是好的。其他的就算了。就像Al leluia说的那样，在硬件架构没有更多的突破之前，不说没有生命力，至少想取得任何进一步的突破都太难。</p>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>现在这个领域，你吹你的水，我吹我的水。至于谁的泡泡大，我看不清。所以真要选东西学，最好还是针对自己的application选靠谱。这也是并行编程教育难 的问题。大家需求完全不一样。</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Guancheng Chen <a href="&#x6d;&#97;&#x69;&#108;&#x74;&#111;&#x3a;&#x5b;&#x63;&#x68;&#x65;&#110;&#x67;&#117;&#97;&#110;&#99;&#104;&#46;&#46;&#x2e;&#64;&#x67;&#x6d;&#97;&#105;&#x6c;&#46;&#99;&#111;&#109;&#x5d;&#40;&#41;">&#x5b;&#x63;&#x68;&#x65;&#110;&#x67;&#117;&#97;&#110;&#99;&#104;&#46;&#46;&#x2e;&#64;&#x67;&#x6d;&#97;&#105;&#x6c;&#46;&#99;&#111;&#109;&#x5d;&#40;&#41;</a>:</p>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>&gt;
&gt;
&gt;</p>
<blockquote>
<blockquote>
<p>我觉得现有的OpenCL确实非常不成熟，但是从纯性能角度上来讲，我看好Heterogeneous架构，尽管它们的编程难度太大，就像前面提到的不
同架构需要做不同优化等。CPU的性能是latency-oriented，GPU是throughput-oriented,Intel的
Larrabee虽然现在来看不成功，但是业界都在朝着那个方向努力。</p>
<p>On 3月22日, 下午6时18分, windstorm <a href="&#109;&#x61;&#105;&#x6c;&#116;&#111;&#58;&#x5b;&#x6c;&#x69;&#x6b;&#x75;&#110;&#97;&#114;&#x6d;&#115;&#116;&#x72;&#x2e;&#46;&#x2e;&#x40;&#x67;&#x6d;&#97;&#x69;&#108;&#46;&#99;&#x6f;&#x6d;&#x5d;&#40;&#x29;">&#x5b;&#x6c;&#x69;&#x6b;&#x75;&#110;&#97;&#114;&#x6d;&#115;&#116;&#x72;&#x2e;&#46;&#x2e;&#x40;&#x67;&#x6d;&#97;&#x69;&#108;&#46;&#99;&#x6f;&#x6d;&#x5d;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>实在是不能同意你更多......很早很早以前我就在这里和人争论过，GPU的并行计算平台不可能一统天下的。CUDA也不是救世主。OpenCL更不是。</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Alleluia <a href="&#109;&#x61;&#x69;&#108;&#116;&#x6f;&#x3a;&#91;&#97;&#108;&#x6c;&#117;&#108;&#46;&#46;&#46;&#x40;&#x67;&#109;&#97;&#105;&#x6c;&#x2e;&#99;&#111;&#109;&#x5d;&#40;&#x29;">&#91;&#97;&#108;&#x6c;&#117;&#108;&#46;&#46;&#46;&#x40;&#x67;&#109;&#97;&#105;&#x6c;&#x2e;&#99;&#111;&#109;&#x5d;&#40;&#x29;</a>:</p>
<blockquote>
<p>Parallelism 说到底是算法问题.Parallelism与Concurrency不同,Concurrency所面对的问题相对的单一可以
让一群有经验的专家来实现一套通用库或者语言来提供一个基本的编程框架.而在Parallelism上,具体的不同问题,其所需要并行的算法是根本不同
的.原因在于不同的问题,其内部的DataDependency的结构完全不同,不同的Data Dependency的结构,需要构造不同的算法.即
便是相同的Data Dependency,在不同的颗粒度下，在不同的硬件条件下所采用的算法也是完全不同的.因为一旦出现Data
Dependency也就意味着并行计算模块之间需要进行通信.从以计算节点为单位的分布式并行,到多核CPU上的Numa结构,到SIMD上的向量处
理器,其计算单元之间的通信手段,通信效率简直天差地别.比如说,在SMP上最常见的并行算法,work stealing也就是Intel的TBB,
是建立在两个条件下第一个是CPU的Cache机制上,这使得通常在内存的之间的数据搬运消耗非常小,第二个是SMP上计算单元相对的少,因此每个计算
单元被分配到的任务就相对的重。其开销远远大于通信的开销,因此这种机制在SMP上相对的划算.但是如果你要在GPU上做Work Stealing就
完全不可行,因为GPU的运算单元数量极多,被分配到的任务就相对来说的非常轻量,CUDA上的一个thread很多时候运算一次的时间不会超过
10us,而一次跨Block的线程之间的通信开销就往往要达到100us左右,再加上目前GPU上的Cache机制非常落后导致了需要频繁的通信开销
的Work Stealing在GPU上是非常不划算得.
所以我个人认为在硬件架构没有更多的突破之前,OpenCL这种东西是没有任何生命力的.不要说CPU的并行与GPU之间差异巨大,就是不同的GPU之
间AMD与Nvidia两个也是各自为政,一个平台上跑得非常快的东西,在另外一个平台极大的可能是龟速.其最终的结果估计就是跟Java的
write once run everywhere一样是个大笑话.</p>
<p>On 3月22日, 下午2时06分, Guancheng Chen <a href="&#x6d;&#x61;&#x69;&#x6c;&#116;&#111;&#58;&#91;&#99;&#104;&#x65;&#110;&#x67;&#x75;&#97;&#110;&#x63;&#104;&#x2e;&#x2e;&#x2e;&#64;&#103;&#x6d;&#x61;&#x69;&#108;&#x2e;&#99;&#x6f;&#x6d;&#93;&#40;&#x29;">&#91;&#99;&#104;&#x65;&#110;&#x67;&#x75;&#97;&#110;&#x63;&#104;&#x2e;&#x2e;&#x2e;&#64;&#103;&#x6d;&#x61;&#x69;&#108;&#x2e;&#99;&#x6f;&#x6d;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>On 3月22日, 上午2时20分, Tinyfool <a href="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#x6f;&#58;&#x5b;&#x74;&#105;&#x6e;&#x79;&#x66;&#46;&#x2e;&#x2e;&#x40;&#x67;&#109;&#97;&#105;&#108;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#41;">&#x5b;&#x74;&#105;&#x6e;&#x79;&#x66;&#46;&#x2e;&#x2e;&#x40;&#x67;&#109;&#97;&#105;&#108;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#109;&#x61;&#105;&#x6c;&#x74;&#x6f;&#58;&#91;&#x6a;&#x65;&#x2e;&#46;&#x2e;&#x40;&#x6c;&#105;&#x76;&#101;&#46;&#99;&#111;&#109;&#x5d;&#x28;&#41;">&#91;&#x6a;&#x65;&#x2e;&#46;&#x2e;&#x40;&#x6c;&#105;&#x76;&#101;&#46;&#99;&#111;&#109;&#x5d;&#x28;&#41;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#109;&#97;&#x69;&#x6c;&#x74;&#111;&#x3a;&#91;&#99;&#104;&#x65;&#x6e;&#x67;&#117;&#97;&#110;&#x63;&#x68;&#x2e;&#46;&#x2e;&#64;&#x67;&#x6d;&#x61;&#105;&#108;&#x2e;&#99;&#x6f;&#109;&#x5d;&#40;&#x29;">&#91;&#99;&#104;&#x65;&#x6e;&#x67;&#117;&#97;&#110;&#x63;&#x68;&#x2e;&#46;&#x2e;&#64;&#x67;&#x6d;&#x61;&#105;&#108;&#x2e;&#99;&#x6f;&#109;&#x5d;&#40;&#x29;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#109;&#97;&#x69;&#108;&#116;&#x6f;&#58;&#x5b;&#112;&#111;&#110;&#x2e;&#x2e;&#46;&#x40;&#103;&#x6f;&#x6f;&#103;&#108;&#101;&#x67;&#114;&#x6f;&#x75;&#x70;&#x73;&#x2e;&#99;&#111;&#x6d;&#93;&#x28;&#41;">&#x5b;&#112;&#111;&#110;&#x2e;&#x2e;&#46;&#x40;&#103;&#x6f;&#x6f;&#103;&#108;&#101;&#x67;&#114;&#x6f;&#x75;&#x70;&#x73;&#x2e;&#99;&#111;&#x6d;&#93;&#x28;&#41;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>...</p>
<p>阅读更多 &gt;&gt;
<a href="">显示删减掉的内容</a></p>
</blockquote>
<p><img src="" alt=""> windstorm <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-23</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>显然不是简单捆绑那么简单阿。</p>
<p>而且我看好它，并不是它将来会一统天下，而是说它相对革命性的架构部分程度上满足了线程完备，从而扩展了GPU的使用领域，所以我看好以它为代表的这种架构的发展。同类型的还有Sun当年的Rock和Niagara
1/2</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p><a href="http://www.kunli.info/" target="_blank">www.kunli.info</a>
<a href="http://twitter.com/cnbuff" target="_blank"><a href="http://twitter.com/cnbuff">http://twitter.com/cnbuff</a></a></p>
<p>2010/3/22 Alleluia <a href="&#109;&#97;&#x69;&#108;&#116;&#111;&#x3a;&#91;&#97;&#x6c;&#x6c;&#117;&#46;&#x2e;&#46;&#x40;&#x67;&#109;&#x61;&#x69;&#108;&#46;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#x29;">&#91;&#97;&#x6c;&#x6c;&#117;&#46;&#x2e;&#46;&#x40;&#x67;&#109;&#x61;&#x69;&#108;&#46;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#x29;</a>:</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<blockquote>
<p>我当初就不看好Larrabee这个东西,想想一个Core上一个Decoder就要消耗1瓦的功率,32个捆起来这个Core的功率要多大啊.我觉得
一捆Arm棒在一起都比PII靠谱.</p>
<p>On 3月23日, 上午5时41分, windstorm <a href="&#x6d;&#97;&#105;&#x6c;&#116;&#111;&#58;&#91;&#108;&#105;&#x6b;&#117;&#110;&#x61;&#x72;&#x6d;&#x73;&#116;&#114;&#46;&#46;&#x2e;&#64;&#x67;&#109;&#x61;&#105;&#108;&#x2e;&#99;&#111;&#109;&#x5d;&#x28;&#41;">&#91;&#108;&#105;&#x6b;&#117;&#110;&#x61;&#x72;&#x6d;&#x73;&#116;&#114;&#46;&#46;&#x2e;&#64;&#x67;&#109;&#x61;&#105;&#108;&#x2e;&#99;&#111;&#109;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>Larrabee当初我还是很看好的，它的架构比其他的更像一个统一的方案，可惜后来Intel自己经验不足搞不好。</p>
<p>OPENCL还是主要面向multimedia吧，CUDA/OpenCL在业界代表了流处理的方向，从GPU针对任务的角度讲是好的。其他的就算了。就像Al leluia说的那样，在硬件架构没有更多的突破之前，不说没有生命力，至少想取得任何进一步的突破都太难。</p>
<p>现在这个领域，你吹你的水，我吹我的水。至于谁的泡泡大，我看不清。所以真要选东西学，最好还是针对自己的application选靠谱。这也是并行编程教育难 的问题。大家需求完全不一样。</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Guancheng Chen <a href="&#109;&#97;&#x69;&#108;&#x74;&#x6f;&#x3a;&#x5b;&#x63;&#x68;&#x65;&#x6e;&#103;&#x75;&#x61;&#x6e;&#x63;&#104;&#46;&#x2e;&#46;&#64;&#x67;&#x6d;&#x61;&#105;&#x6c;&#46;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#41;">&#x5b;&#x63;&#x68;&#x65;&#x6e;&#103;&#x75;&#x61;&#x6e;&#x63;&#104;&#46;&#x2e;&#46;&#64;&#x67;&#x6d;&#x61;&#105;&#x6c;&#46;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#41;</a>:</p>
<blockquote>
<p>我觉得现有的OpenCL确实非常不成熟，但是从纯性能角度上来讲，我看好Heterogeneous架构，尽管它们的编程难度太大，就像前面提到的不
同架构需要做不同优化等。CPU的性能是latency-oriented，GPU是throughput-oriented,Intel的
Larrabee虽然现在来看不成功，但是业界都在朝着那个方向努力。</p>
<p>On 3月22日, 下午6时18分, windstorm <a href="&#109;&#97;&#105;&#x6c;&#116;&#111;&#58;&#x5b;&#x6c;&#x69;&#107;&#117;&#x6e;&#97;&#114;&#109;&#115;&#x74;&#x72;&#x2e;&#46;&#46;&#64;&#x67;&#109;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#93;&#40;&#41;">&#x5b;&#x6c;&#x69;&#107;&#117;&#x6e;&#97;&#114;&#109;&#115;&#x74;&#x72;&#x2e;&#46;&#46;&#64;&#x67;&#109;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>实在是不能同意你更多......很早很早以前我就在这里和人争论过，GPU的并行计算平台不可能一统天下的。CUDA也不是救世主。OpenCL更不是。</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Alleluia <a href="&#109;&#97;&#x69;&#x6c;&#116;&#x6f;&#x3a;&#91;&#x61;&#x6c;&#108;&#x75;&#108;&#x2e;&#46;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#105;&#108;&#x2e;&#x63;&#111;&#109;&#x5d;&#x28;&#41;">&#91;&#x61;&#x6c;&#108;&#x75;&#108;&#x2e;&#46;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#105;&#108;&#x2e;&#x63;&#111;&#109;&#x5d;&#x28;&#41;</a>:</p>
<blockquote>
<p>Parallelism 说到底是算法问题.Parallelism与Concurrency不同,Concurrency所面对的问题相对的单一可以
让一群有经验的专家来实现一套通用库或者语言来提供一个基本的编程框架.而在Parallelism上,具体的不同问题,其所需要并行的算法是根本不同
的.原因在于不同的问题,其内部的DataDependency的结构完全不同,不同的Data Dependency的结构,需要构造不同的算法.即
便是相同的Data Dependency,在不同的颗粒度下，在不同的硬件条件下所采用的算法也是完全不同的.因为一旦出现Data
Dependency也就意味着并行计算模块之间需要进行通信.从以计算节点为单位的分布式并行,到多核CPU上的Numa结构,到SIMD上的向量处
理器,其计算单元之间的通信手段,通信效率简直天差地别.比如说,在SMP上最常见的并行算法,work stealing也就是Intel的TBB,
是建立在两个条件下第一个是CPU的Cache机制上,这使得通常在内存的之间的数据搬运消耗非常小,第二个是SMP上计算单元相对的少,因此每个计算
单元被分配到的任务就相对的重。其开销远远大于通信的开销,因此这种机制在SMP上相对的划算.但是如果你要在GPU上做Work Stealing就
完全不可行,因为GPU的运算单元数量极多,被分配到的任务就相对来说的非常轻量,CUDA上的一个thread很多时候运算一次的时间不会超过
10us,而一次跨Block的线程之间的通信开销就往往要达到100us左右,再加上目前GPU上的Cache机制非常落后导致了需要频繁的通信开销
的Work Stealing在GPU上是非常不划算得.
所以我个人认为在硬件架构没有更多的突破之前,OpenCL这种东西是没有任何生命力的.不要说CPU的并行与GPU之间差异巨大,就是不同的GPU之
间AMD与Nvidia两个也是各自为政,一个平台上跑得非常快的东西,在另外一个平台极大的可能是龟速.其最终的结果估计就是跟Java的
write once run everywhere一样是个大笑话.</p>
<p>On 3月22日, 下午2时06分, Guancheng Chen <a href="&#x6d;&#97;&#x69;&#108;&#x74;&#111;&#x3a;&#x5b;&#x63;&#104;&#x65;&#110;&#x67;&#117;&#97;&#110;&#99;&#x68;&#46;&#46;&#x2e;&#64;&#x67;&#109;&#x61;&#x69;&#x6c;&#46;&#99;&#x6f;&#x6d;&#93;&#40;&#41;">&#x5b;&#x63;&#104;&#x65;&#110;&#x67;&#117;&#97;&#110;&#99;&#x68;&#46;&#46;&#x2e;&#64;&#x67;&#109;&#x61;&#x69;&#x6c;&#46;&#99;&#x6f;&#x6d;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>On 3月22日, 上午2时20分, Tinyfool <a href="&#x6d;&#97;&#105;&#x6c;&#x74;&#111;&#x3a;&#x5b;&#116;&#x69;&#110;&#x79;&#x66;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#46;&#99;&#111;&#109;&#x5d;&#x28;&#41;">&#x5b;&#116;&#x69;&#110;&#x79;&#x66;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#46;&#99;&#111;&#109;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#109;&#97;&#105;&#x6c;&#116;&#x6f;&#58;&#x5b;&#x6a;&#101;&#x2e;&#46;&#x2e;&#x40;&#x6c;&#x69;&#118;&#x65;&#46;&#99;&#111;&#109;&#93;&#x28;&#x29;">&#x5b;&#x6a;&#101;&#x2e;&#46;&#x2e;&#x40;&#x6c;&#x69;&#118;&#x65;&#46;&#99;&#111;&#109;&#93;&#x28;&#x29;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#109;&#x61;&#x69;&#108;&#x74;&#x6f;&#58;&#91;&#x63;&#104;&#x65;&#110;&#x67;&#117;&#97;&#110;&#x63;&#104;&#x2e;&#x2e;&#46;&#x40;&#x67;&#109;&#x61;&#105;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#93;&#40;&#x29;">&#91;&#x63;&#104;&#x65;&#110;&#x67;&#117;&#97;&#110;&#x63;&#104;&#x2e;&#x2e;&#46;&#x40;&#x67;&#109;&#x61;&#105;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#93;&#40;&#x29;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#109;&#x61;&#x69;&#x6c;&#116;&#111;&#58;&#x5b;&#112;&#x6f;&#x6e;&#x2e;&#46;&#46;&#x40;&#103;&#111;&#111;&#x67;&#108;&#101;&#x67;&#x72;&#x6f;&#117;&#112;&#x73;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#x29;">&#x5b;&#112;&#x6f;&#x6e;&#x2e;&#46;&#46;&#x40;&#103;&#111;&#111;&#x67;&#108;&#101;&#x67;&#x72;&#x6f;&#117;&#112;&#x73;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#x29;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>...</p>
<p>阅读更多 &gt;&gt;</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p><a href="">显示删减掉的内容</a>
<img src="" alt=""> windstorm <img src="" alt=""></p>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-23</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>女生？LJJ？</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p><a href="http://www.kunli.info/" target="_blank">www.kunli.info</a>
<a href="http://twitter.com/cnbuff" target="_blank"><a href="http://twitter.com/cnbuff">http://twitter.com/cnbuff</a></a></p>
<p>2010/3/22 Guancheng Chen <a href="&#x6d;&#97;&#105;&#x6c;&#116;&#x6f;&#x3a;&#91;&#99;&#104;&#x65;&#x6e;&#103;&#x75;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#109;&#97;&#105;&#108;&#46;&#x63;&#111;&#x6d;&#93;&#40;&#x29;">&#91;&#99;&#104;&#x65;&#x6e;&#103;&#x75;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#109;&#97;&#105;&#108;&#46;&#x63;&#111;&#x6d;&#93;&#40;&#x29;</a>:</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<blockquote>
<p>恩</p>
<p>第二点其实我就是指程序员根据他自己的程序领域选择合适的并行技术。Top Language真是藏龙卧虎啊。你是在Boulder么?我一个大学女同
学在你那读MIS的phd</p>
<p>On 3月23日, 上午12时04分, windstorm <a href="&#x6d;&#x61;&#105;&#108;&#x74;&#111;&#58;&#91;&#x6c;&#x69;&#x6b;&#x75;&#110;&#x61;&#114;&#x6d;&#115;&#x74;&#x72;&#46;&#46;&#x2e;&#64;&#103;&#x6d;&#97;&#105;&#108;&#x2e;&#99;&#111;&#x6d;&#x5d;&#40;&#41;">&#91;&#x6c;&#x69;&#x6b;&#x75;&#110;&#x61;&#114;&#x6d;&#115;&#x74;&#x72;&#46;&#46;&#x2e;&#64;&#103;&#x6d;&#97;&#105;&#108;&#x2e;&#99;&#111;&#x6d;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>全民并行编程的时代，只有在全民能够并行编程的时候才会到来嘛，现在不是这个时候</p>
<p>我个人倾向于等待一个比较好的统一性架构。两条路：</p>
<p>一是某一个全新概念的提出，这个要看学术界的努力，而且在某种意义上讲，学术界搞出一个真正可行的并行架构的可能性比工业界更高。虽说今天多核的发展是工业界引 领的，但是点子还是最早学术界提出的。典型的有几个：斯坦福的Hydra（1996），斯坦福的Imagine(2000)，MIT的RAW（2002），以及 UT奥斯丁的TRIPS（2003）。在这个问题上，是不得不佩服美国的创造力，要知道直到在2000年左右，所有的人都还在为处理器频率按照摩尔定律翻翻而狂 热，美国的顶尖研究员就早已看到了这条路的尽头并指出未来处理器的发展之路。</p>
<p>二是你用现有的架构，但是application引导。如果要找一个面向多application
domain的话，刚才说了，本来看好Larrabee，因为它的架构解决了CUDA一个很大的潜在问题，而且允许现有程序员不经过任何特殊training就 上手编程，包括图形图像，科学计算，或者网络处理，各个领域。</p>
<p>不过可能就是因为这个solution的过于理想化导致结构的过于复杂化，才让其目前暂时流产。</p>
<p>总的来说，现在的问题就是软件发展不成熟，硬件发展不完善，你没法靠程序员决定使用什么并行技术，完全靠应用主导，这套技术在这个应用上如鱼得水，在那个应用上 完全不罩，作为程序员，有什么办法？</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Guancheng Chen <a href="&#109;&#x61;&#x69;&#108;&#x74;&#x6f;&#x3a;&#91;&#99;&#x68;&#x65;&#110;&#103;&#x75;&#97;&#x6e;&#x63;&#104;&#46;&#46;&#x2e;&#x40;&#103;&#x6d;&#97;&#105;&#x6c;&#46;&#x63;&#111;&#x6d;&#93;&#40;&#41;">&#91;&#99;&#x68;&#x65;&#110;&#103;&#x75;&#97;&#x6e;&#x63;&#104;&#46;&#46;&#x2e;&#x40;&#103;&#x6d;&#97;&#105;&#x6c;&#46;&#x63;&#111;&#x6d;&#93;&#40;&#41;</a>:</p>
<blockquote>
<p>教育以人为本，最终决定使用何种并行技术的还是程序员。目前业界对程序员并没有并行编程的技能要求，全民并行编程的时代什么时候才能到来？这是个问
题。</p>
<p>On 3月22日, 下午10时41分, windstorm <a href="&#109;&#97;&#105;&#108;&#116;&#x6f;&#x3a;&#x5b;&#x6c;&#105;&#x6b;&#x75;&#110;&#97;&#x72;&#x6d;&#x73;&#116;&#114;&#46;&#x2e;&#46;&#x40;&#103;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#99;&#111;&#x6d;&#93;&#x28;&#41;">&#x5b;&#x6c;&#105;&#x6b;&#x75;&#110;&#97;&#x72;&#x6d;&#x73;&#116;&#114;&#46;&#x2e;&#46;&#x40;&#103;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#99;&#111;&#x6d;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>Larrabee当初我还是很看好的，它的架构比其他的更像一个统一的方案，可惜后来Intel自己经验不足搞不好。</p>
<p>OPENCL还是主要面向multimedia吧，CUDA/OpenCL在业界代表了流处理的方向，从GPU针对任务的角度讲是好的。其他的就算了。就像Al leluia说的那样，在硬件架构没有更多的突破之前，不说没有生命力，至少想取得任何进一步的突破都太难。</p>
<p>现在这个领域，你吹你的水，我吹我的水。至于谁的泡泡大，我看不清。所以真要选东西学，最好还是针对自己的application选靠谱。这也是并行编程教育难 的问题。大家需求完全不一样。</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Guancheng Chen <a href="&#x6d;&#97;&#x69;&#108;&#x74;&#x6f;&#58;&#x5b;&#99;&#104;&#101;&#x6e;&#103;&#x75;&#97;&#110;&#x63;&#x68;&#x2e;&#x2e;&#46;&#64;&#103;&#109;&#x61;&#105;&#108;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#40;&#x29;">&#x5b;&#99;&#104;&#101;&#x6e;&#103;&#x75;&#97;&#110;&#x63;&#x68;&#x2e;&#x2e;&#46;&#64;&#103;&#109;&#x61;&#105;&#108;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#40;&#x29;</a>:</p>
<blockquote>
<p>我觉得现有的OpenCL确实非常不成熟，但是从纯性能角度上来讲，我看好Heterogeneous架构，尽管它们的编程难度太大，就像前面提到的不
同架构需要做不同优化等。CPU的性能是latency-oriented，GPU是throughput-oriented,Intel的
Larrabee虽然现在来看不成功，但是业界都在朝着那个方向努力。</p>
<p>On 3月22日, 下午6时18分, windstorm <a href="&#x6d;&#x61;&#x69;&#x6c;&#116;&#111;&#58;&#x5b;&#x6c;&#105;&#107;&#x75;&#x6e;&#x61;&#114;&#x6d;&#115;&#116;&#114;&#46;&#x2e;&#46;&#x40;&#103;&#109;&#x61;&#x69;&#x6c;&#46;&#99;&#111;&#109;&#x5d;&#x28;&#41;">&#x5b;&#x6c;&#105;&#107;&#x75;&#x6e;&#x61;&#114;&#x6d;&#115;&#116;&#114;&#46;&#x2e;&#46;&#x40;&#103;&#109;&#x61;&#x69;&#x6c;&#46;&#99;&#111;&#109;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>实在是不能同意你更多......很早很早以前我就在这里和人争论过，GPU的并行计算平台不可能一统天下的。CUDA也不是救世主。OpenCL更不是。</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Alleluia <a href="&#x6d;&#x61;&#x69;&#x6c;&#116;&#111;&#58;&#x5b;&#x61;&#x6c;&#x6c;&#x75;&#108;&#x2e;&#46;&#46;&#x40;&#103;&#x6d;&#x61;&#105;&#108;&#46;&#x63;&#111;&#109;&#93;&#x28;&#x29;">&#x5b;&#x61;&#x6c;&#x6c;&#x75;&#108;&#x2e;&#46;&#46;&#x40;&#103;&#x6d;&#x61;&#105;&#108;&#46;&#x63;&#111;&#109;&#93;&#x28;&#x29;</a>:</p>
<blockquote>
<p>Parallelism 说到底是算法问题.Parallelism与Concurrency不同,Concurrency所面对的问题相对的单一可以
让一群有经验的专家来实现一套通用库或者语言来提供一个基本的编程框架.而在Parallelism上,具体的不同问题,其所需要并行的算法是根本不同
的.原因在于不同的问题,其内部的DataDependency的结构完全不同,不同的Data Dependency的结构,需要构造不同的算法.即
便是相同的Data Dependency,在不同的颗粒度下，在不同的硬件条件下所采用的算法也是完全不同的.因为一旦出现Data
Dependency也就意味着并行计算模块之间需要进行通信.从以计算节点为单位的分布式并行,到多核CPU上的Numa结构,到SIMD上的向量处
理器,其计算单元之间的通信手段,通信效率简直天差地别.比如说,在SMP上最常见的并行算法,work stealing也就是Intel的TBB,
是建立在两个条件下第一个是CPU的Cache机制上,这使得通常在内存的之间的数据搬运消耗非常小,第二个是SMP上计算单元相对的少,因此每个计算
单元被分配到的任务就相对的重。其开销远远大于通信的开销,因此这种机制在SMP上相对的划算.但是如果你要在GPU上做Work Stealing就
完全不可行,因为GPU的运算单元数量极多,被分配到的任务就相对来说的非常轻量,CUDA上的一个thread很多时候运算一次的时间不会超过
10us,而一次跨Block的线程之间的通信开销就往往要达到100us左右,再加上目前GPU上的Cache机制非常落后导致了需要频繁的通信开销
的Work Stealing在GPU上是非常不划算得.
所以我个人认为在硬件架构没有更多的突破之前,OpenCL这种东西是没有任何生命力的.不要说CPU的并行与GPU之间差异巨大,就是不同的GPU之
间AMD与Nvidia两个也是各自为政,一个平台上跑得非常快的东西,在另外一个平台极大的可能是龟速.其最终的结果估计就是跟Java的
write once run everywhere一样是个大笑话.</p>
<p>On 3月22日, 下午2时06分, Guancheng Chen <a href="&#x6d;&#x61;&#105;&#108;&#116;&#x6f;&#58;&#x5b;&#x63;&#x68;&#x65;&#110;&#x67;&#117;&#x61;&#110;&#99;&#104;&#46;&#x2e;&#46;&#64;&#103;&#109;&#x61;&#105;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#x28;&#41;">&#x5b;&#x63;&#x68;&#x65;&#110;&#x67;&#117;&#x61;&#110;&#99;&#104;&#46;&#x2e;&#46;&#64;&#103;&#109;&#x61;&#105;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>On 3月22日, 上午2时20分, Tinyfool <a href="&#109;&#97;&#105;&#x6c;&#116;&#x6f;&#x3a;&#91;&#116;&#x69;&#110;&#121;&#x66;&#x2e;&#46;&#x2e;&#64;&#x67;&#109;&#x61;&#105;&#108;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#x29;">&#91;&#116;&#x69;&#110;&#121;&#x66;&#x2e;&#46;&#x2e;&#64;&#x67;&#109;&#x61;&#105;&#108;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#109;&#97;&#x69;&#x6c;&#116;&#x6f;&#x3a;&#x5b;&#x6a;&#101;&#x2e;&#x2e;&#46;&#x40;&#x6c;&#x69;&#x76;&#x65;&#46;&#99;&#111;&#x6d;&#x5d;&#x28;&#x29;">&#x5b;&#x6a;&#101;&#x2e;&#x2e;&#46;&#x40;&#x6c;&#x69;&#x76;&#x65;&#46;&#99;&#111;&#x6d;&#x5d;&#x28;&#x29;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#109;&#97;&#105;&#x6c;&#x74;&#x6f;&#x3a;&#x5b;&#x63;&#104;&#x65;&#110;&#x67;&#117;&#x61;&#110;&#x63;&#104;&#46;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#97;&#105;&#108;&#46;&#99;&#x6f;&#109;&#93;&#x28;&#41;">&#x5b;&#x63;&#104;&#x65;&#110;&#x67;&#117;&#x61;&#110;&#x63;&#104;&#46;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#97;&#105;&#108;&#46;&#99;&#x6f;&#109;&#93;&#x28;&#41;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#x6d;&#97;&#105;&#108;&#116;&#111;&#58;&#x5b;&#112;&#x6f;&#x6e;&#x2e;&#46;&#46;&#64;&#x67;&#x6f;&#x6f;&#103;&#x6c;&#x65;&#x67;&#114;&#x6f;&#117;&#x70;&#x73;&#x2e;&#99;&#111;&#109;&#x5d;&#x28;&#41;">&#x5b;&#112;&#x6f;&#x6e;&#x2e;&#46;&#46;&#64;&#x67;&#x6f;&#x6f;&#103;&#x6c;&#x65;&#x67;&#114;&#x6f;&#117;&#x70;&#x73;&#x2e;&#99;&#111;&#109;&#x5d;&#x28;&#41;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器...</li>
</ol>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>阅读更多 &gt;&gt;</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p><a href="">显示删减掉的内容</a></p>
</blockquote>
<p><img src="" alt=""> SevenCat <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-23</p>
<p>其他收件人：</p>
<p>大家在什么项目上用到并行编程？
<a href="">显示删减掉的内容</a>
<img src="" alt=""> qiaojie <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-23</p>
<p>其他收件人：</p>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1) = 5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？
<a href="">显示删减掉的内容</a></p>
<p><img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-23</p>
<p>其他收件人：</p>
<p>多谢大牛指教。我之所以提到并行化循环，是因为我以前实习过的公司的解决方案就是以data parallel模型的把循环并行化为主，其实新编写的代
码也可以用他们的技术。我之所以要提到遗留代码，是因为如果针对只对遗留代码的循环进行并行化就已经能取得比较可观的speedup(如果本身该循环是
热点，经过一些指导被程序员正确改成independent的之后即可并行化)，同时又不会引入太多的并行编程的复杂度。我原来测试它的时候一般1-3
个小时就能出结果，speedup在1.2~1.6之间(dual core, quad core 2.X)。</p>
<p>另外想请教您的实际工作中一般适用什么样的并行算法？任务分解(如TBB)？还是数据分解？</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>On 3月23日, 上午3时09分, Alleluia <a href="&#109;&#x61;&#x69;&#108;&#116;&#x6f;&#58;&#91;&#x61;&#108;&#108;&#117;&#x6c;&#46;&#46;&#46;&#64;&#103;&#109;&#x61;&#105;&#108;&#46;&#99;&#x6f;&#x6d;&#93;&#40;&#41;">&#91;&#x61;&#108;&#108;&#117;&#x6c;&#46;&#46;&#46;&#64;&#103;&#109;&#x61;&#105;&#108;&#46;&#99;&#x6f;&#x6d;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>我不是搞体系结构的.但是我认为目前来说做Parallelism的人首先不是去熟悉什么API或者Libarary,而是要熟悉两样东西体系结构和算
法.没有这两样,几乎写不出什么高效率的并行程序.当然你的需求只是并行化循环这种简单的东西当然可以里例外.呵呵.
我觉得你最好放弃用GPGPU去搞遗留代码的想法.现在市面上的GPU产品无论是A记的还是N记的其编程架构与CPU完全不同,你不要想把一个循环简单
的porting到GPU上就能并行了.那是几乎不可能的,比如最简单的你如何处理branch?如果branch非常多,divergence会把速
度拖得比CPU版本还慢.你如何处理CPU代码里的数组随机访问,在GPU上无论是片上的还是片外的内存是不能随机访问的,最要命的是没有cache,
随机访问的代价极其高昂.你几乎需要把CPU上的代码面目全非地从新写一遍,遗留代码除了用作调试测试做结果比对之外几乎要全部抛弃.</p>
<p>On 3月23日, 上午6时42分, Guancheng Chen <a href="&#x6d;&#x61;&#105;&#108;&#x74;&#111;&#58;&#91;&#x63;&#x68;&#x65;&#110;&#x67;&#117;&#x61;&#x6e;&#99;&#104;&#46;&#x2e;&#46;&#64;&#103;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#99;&#111;&#109;&#93;&#x28;&#41;">&#91;&#x63;&#x68;&#x65;&#110;&#x67;&#117;&#x61;&#x6e;&#99;&#104;&#46;&#x2e;&#46;&#64;&#103;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#99;&#111;&#109;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>恩 您也是搞体系结构的么？
现在我在跟瑞典这边的爱立信合作做毕设 不过对象不是他们的Erlang 而是传统的C/C++程序 下半年可能我也去搞GPGPU了 因为它的
data parallel模型对遗留代码的并行化很有搞头，现在我粗略的想法是把Compute sensitive的任务放一部分到GPU上去做，
当然我也对GPU目前的一些限制有所了解 但是一些探索工作还是非常值得的 到时候还想向前辈多多请教</p>
<p>On 3月22日, 下午11时30分, Alleluia <a href="&#x6d;&#x61;&#105;&#108;&#x74;&#111;&#58;&#x5b;&#x61;&#108;&#x6c;&#x75;&#x6c;&#x2e;&#x2e;&#46;&#x40;&#x67;&#109;&#97;&#105;&#108;&#46;&#x63;&#111;&#x6d;&#x5d;&#x28;&#41;">&#x5b;&#x61;&#108;&#x6c;&#x75;&#x6c;&#x2e;&#x2e;&#46;&#x40;&#x67;&#109;&#97;&#105;&#108;&#46;&#x63;&#111;&#x6d;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>Heterogeneous目前来看也是一个暂时的过渡性的东西. Heterogeneous架构最大的问题还是硬件,CPU和GPU之间的
PCIE2的bus带宽太窄了.在上面来回传递一次几M的内存可能需要化掉500us左右.如果一个算法本来就是在3-4ms级别的,你要用GPU去优
化,内存带宽的消耗就占了1/10,这是非常可怕的事情.或许像AMD那种Fusion架构是一种趋势,但是目前来说没有太大的进展.貌似AMD出了一
款混合的CPU,但是貌似还没有看到有多大的优势.
On 3月23日, 上午5时02分, Guancheng Chen <a href="&#x6d;&#97;&#105;&#x6c;&#x74;&#x6f;&#58;&#91;&#99;&#x68;&#x65;&#110;&#x67;&#x75;&#x61;&#x6e;&#99;&#x68;&#46;&#x2e;&#46;&#x40;&#103;&#109;&#97;&#x69;&#x6c;&#46;&#99;&#111;&#x6d;&#93;&#x28;&#41;">&#91;&#99;&#x68;&#x65;&#110;&#x67;&#x75;&#x61;&#x6e;&#99;&#x68;&#46;&#x2e;&#46;&#x40;&#103;&#109;&#97;&#x69;&#x6c;&#46;&#99;&#111;&#x6d;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>我觉得现有的OpenCL确实非常不成熟，但是从纯性能角度上来讲，我看好Heterogeneous架构，尽管它们的编程难度太大，就像前面提到的不
同架构需要做不同优化等。CPU的性能是latency-oriented，GPU是throughput-oriented,Intel的
Larrabee虽然现在来看不成功，但是业界都在朝着那个方向努力。</p>
<p>On 3月22日, 下午6时18分, windstorm <a href="&#109;&#97;&#105;&#x6c;&#116;&#x6f;&#x3a;&#x5b;&#108;&#105;&#107;&#x75;&#x6e;&#97;&#114;&#109;&#x73;&#x74;&#x72;&#x2e;&#46;&#x2e;&#64;&#103;&#109;&#97;&#x69;&#x6c;&#46;&#99;&#x6f;&#109;&#93;&#x28;&#x29;">&#x5b;&#108;&#105;&#107;&#x75;&#x6e;&#97;&#114;&#109;&#x73;&#x74;&#x72;&#x2e;&#46;&#x2e;&#64;&#103;&#109;&#97;&#x69;&#x6c;&#46;&#99;&#x6f;&#109;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>实在是不能同意你更多......很早很早以前我就在这里和人争论过，GPU的并行计算平台不可能一统天下的。CUDA也不是救世主。OpenCL更不是。</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Alleluia <a href="&#109;&#97;&#105;&#x6c;&#116;&#111;&#x3a;&#91;&#97;&#x6c;&#x6c;&#x75;&#x6c;&#46;&#x2e;&#46;&#64;&#103;&#x6d;&#x61;&#105;&#108;&#x2e;&#99;&#111;&#x6d;&#x5d;&#x28;&#41;">&#91;&#97;&#x6c;&#x6c;&#x75;&#x6c;&#46;&#x2e;&#46;&#64;&#103;&#x6d;&#x61;&#105;&#108;&#x2e;&#99;&#111;&#x6d;&#x5d;&#x28;&#41;</a>:</p>
<blockquote>
<p>Parallelism 说到底是算法问题.Parallelism与Concurrency不同,Concurrency所面对的问题相对的单一可以
让一群有经验的专家来实现一套通用库或者语言来提供一个基本的编程框架.而在Parallelism上,具体的不同问题,其所需要并行的算法是根本不同
的.原因在于不同的问题,其内部的DataDependency的结构完全不同,不同的Data Dependency的结构,需要构造不同的算法.即
便是相同的Data Dependency,在不同的颗粒度下，在不同的硬件条件下所采用的算法也是完全不同的.因为一旦出现Data
Dependency也就意味着并行计算模块之间需要进行通信.从以计算节点为单位的分布式并行,到多核CPU上的Numa结构,到SIMD上的向量处
理器,其计算单元之间的通信手段,通信效率简直天差地别.比如说,在SMP上最常见的并行算法,work stealing也就是Intel的TBB,
是建立在两个条件下第一个是CPU的Cache机制上,这使得通常在内存的之间的数据搬运消耗非常小,第二个是SMP上计算单元相对的少,因此每个计算
单元被分配到的任务就相对的重。其开销远远大于通信的开销,因此这种机制在SMP上相对的划算.但是如果你要在GPU上做Work Stealing就
完全不可行,因为GPU的运算单元数量极多,被分配到的任务就相对来说的非常轻量,CUDA上的一个thread很多时候运算一次的时间不会超过
10us,而一次跨Block的线程之间的通信开销就往往要达到100us左右,再加上目前GPU上的Cache机制非常落后导致了需要频繁的通信开销
的Work Stealing在GPU上是非常不划算得.
所以我个人认为在硬件架构没有更多的突破之前,OpenCL这种东西是没有任何生命力的.不要说CPU的并行与GPU之间差异巨大,就是不同的GPU之
间AMD与Nvidia两个也是各自为政,一个平台上跑得非常快的东西,在另外一个平台极大的可能是龟速.其最终的结果估计就是跟Java的
write once run everywhere一样是个大笑话.</p>
<p>On 3月22日, 下午2时06分, Guancheng Chen <a href="&#x6d;&#97;&#105;&#x6c;&#116;&#x6f;&#x3a;&#x5b;&#99;&#x68;&#101;&#x6e;&#103;&#x75;&#97;&#110;&#x63;&#104;&#46;&#x2e;&#x2e;&#x40;&#103;&#109;&#97;&#x69;&#x6c;&#46;&#99;&#x6f;&#109;&#x5d;&#x28;&#x29;">&#x5b;&#99;&#x68;&#101;&#x6e;&#103;&#x75;&#97;&#110;&#x63;&#104;&#46;&#x2e;&#x2e;&#x40;&#103;&#109;&#97;&#x69;&#x6c;&#46;&#99;&#x6f;&#109;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>On 3月22日, 上午2时20分, Tinyfool <a href="&#x6d;&#97;&#x69;&#108;&#x74;&#111;&#58;&#x5b;&#116;&#x69;&#x6e;&#121;&#102;&#46;&#x2e;&#x2e;&#x40;&#x67;&#109;&#x61;&#105;&#x6c;&#46;&#99;&#111;&#x6d;&#x5d;&#40;&#x29;">&#x5b;&#116;&#x69;&#x6e;&#121;&#102;&#46;&#x2e;&#x2e;&#x40;&#x67;&#109;&#x61;&#105;&#x6c;&#46;&#99;&#111;&#x6d;&#x5d;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#109;&#x61;&#x69;&#x6c;&#x74;&#x6f;&#x3a;&#x5b;&#106;&#101;&#x2e;&#46;&#46;&#64;&#x6c;&#x69;&#x76;&#x65;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#x29;">&#x5b;&#106;&#101;&#x2e;&#46;&#46;&#64;&#x6c;&#x69;&#x76;&#x65;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#x29;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#109;&#97;&#105;&#108;&#x74;&#111;&#58;&#x5b;&#99;&#x68;&#101;&#x6e;&#x67;&#x75;&#97;&#110;&#x63;&#x68;&#46;&#46;&#46;&#x40;&#x67;&#x6d;&#x61;&#105;&#108;&#x2e;&#x63;&#111;&#109;&#93;&#x28;&#x29;">&#x5b;&#99;&#x68;&#101;&#x6e;&#x67;&#x75;&#97;&#110;&#x63;&#x68;&#46;&#46;&#46;&#x40;&#x67;&#x6d;&#x61;&#105;&#108;&#x2e;&#x63;&#111;&#109;&#93;&#x28;&#x29;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#109;&#x61;&#105;&#x6c;&#x74;&#x6f;&#x3a;&#91;&#x70;&#x6f;&#x6e;&#46;&#46;&#46;&#x40;&#103;&#x6f;&#x6f;&#103;&#x6c;&#101;&#103;&#x72;&#x6f;&#x75;&#x70;&#x73;&#46;&#99;&#111;&#109;&#x5d;&#x28;&#41;">&#91;&#x70;&#x6f;&#x6e;&#46;&#46;&#46;&#x40;&#103;&#x6f;&#x6f;&#103;&#x6c;&#101;&#103;&#x72;&#x6f;&#x75;&#x70;&#x73;&#46;&#99;&#111;&#109;&#x5d;&#x28;&#41;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育...</p>
</li>
</ol>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>阅读更多 &gt;&gt;
<a href="">显示删减掉的内容</a>
<img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-23</p>
<p>其他收件人：</p>
<p>Yeap.</p>
<p>On 3月23日, 上午3时37分, windstorm <a href="&#x6d;&#97;&#x69;&#108;&#116;&#111;&#x3a;&#x5b;&#x6c;&#x69;&#x6b;&#x75;&#110;&#97;&#114;&#x6d;&#x73;&#116;&#114;&#46;&#x2e;&#46;&#x40;&#x67;&#109;&#x61;&#105;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#40;&#x29;">&#x5b;&#x6c;&#x69;&#x6b;&#x75;&#110;&#97;&#114;&#x6d;&#x73;&#116;&#114;&#46;&#x2e;&#46;&#x40;&#x67;&#109;&#x61;&#105;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>女生？LJJ？</p>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>&gt;</p>
<blockquote>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Guancheng Chen <a href="&#x6d;&#x61;&#105;&#108;&#x74;&#111;&#x3a;&#91;&#x63;&#x68;&#x65;&#x6e;&#x67;&#117;&#97;&#x6e;&#x63;&#x68;&#46;&#46;&#x2e;&#64;&#x67;&#109;&#x61;&#x69;&#108;&#x2e;&#99;&#x6f;&#x6d;&#93;&#x28;&#x29;">&#91;&#x63;&#x68;&#x65;&#x6e;&#x67;&#117;&#97;&#x6e;&#x63;&#x68;&#46;&#46;&#x2e;&#64;&#x67;&#109;&#x61;&#x69;&#108;&#x2e;&#99;&#x6f;&#x6d;&#93;&#x28;&#x29;</a>:</p>
<blockquote>
<p>恩</p>
<p>第二点其实我就是指程序员根据他自己的程序领域选择合适的并行技术。Top Language真是藏龙卧虎啊。你是在Boulder么?我一个大学女同
学在你那读MIS的phd</p>
<p>On 3月23日, 上午12时04分, windstorm <a href="&#109;&#x61;&#x69;&#x6c;&#116;&#111;&#58;&#x5b;&#108;&#105;&#x6b;&#117;&#x6e;&#97;&#x72;&#x6d;&#x73;&#116;&#114;&#46;&#x2e;&#x2e;&#64;&#103;&#x6d;&#97;&#105;&#108;&#x2e;&#x63;&#111;&#109;&#93;&#40;&#41;">&#x5b;&#108;&#105;&#x6b;&#117;&#x6e;&#97;&#x72;&#x6d;&#x73;&#116;&#114;&#46;&#x2e;&#x2e;&#64;&#103;&#x6d;&#97;&#105;&#108;&#x2e;&#x63;&#111;&#109;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>全民并行编程的时代，只有在全民能够并行编程的时候才会到来嘛，现在不是这个时候</p>
<p>我个人倾向于等待一个比较好的统一性架构。两条路：</p>
<p>一是某一个全新概念的提出，这个要看学术界的努力，而且在某种意义上讲，学术界搞出一个真正可行的并行架构的可能性比工业界更高。虽说今天多核的发展是工业界引 领的，但是点子还是最早学术界提出的。典型的有几个：斯坦福的Hydra（1996），斯坦福的Imagine(2000)，MIT的RAW（2002），以及 UT奥斯丁的TRIPS（2003）。在这个问题上，是不得不佩服美国的创造力，要知道直到在2000年左右，所有的人都还在为处理器频率按照摩尔定律翻翻而狂 热，美国的顶尖研究员就早已看到了这条路的尽头并指出未来处理器的发展之路。</p>
<p>二是你用现有的架构，但是application引导。如果要找一个面向多application
domain的话，刚才说了，本来看好Larrabee，因为它的架构解决了CUDA一个很大的潜在问题，而且允许现有程序员不经过任何特殊training就 上手编程，包括图形图像，科学计算，或者网络处理，各个领域。</p>
<p>不过可能就是因为这个solution的过于理想化导致结构的过于复杂化，才让其目前暂时流产。</p>
<p>总的来说，现在的问题就是软件发展不成熟，硬件发展不完善，你没法靠程序员决定使用什么并行技术，完全靠应用主导，这套技术在这个应用上如鱼得水，在那个应用上 完全不罩，作为程序员，有什么办法？</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Guancheng Chen <a href="&#109;&#97;&#105;&#108;&#x74;&#111;&#58;&#91;&#99;&#x68;&#101;&#x6e;&#x67;&#x75;&#x61;&#x6e;&#99;&#104;&#46;&#x2e;&#x2e;&#64;&#103;&#109;&#x61;&#x69;&#108;&#46;&#99;&#111;&#109;&#93;&#40;&#x29;">&#91;&#99;&#x68;&#101;&#x6e;&#x67;&#x75;&#x61;&#x6e;&#99;&#104;&#46;&#x2e;&#x2e;&#64;&#103;&#109;&#x61;&#x69;&#108;&#46;&#99;&#111;&#109;&#93;&#40;&#x29;</a>:</p>
<blockquote>
<p>教育以人为本，最终决定使用何种并行技术的还是程序员。目前业界对程序员并没有并行编程的技能要求，全民并行编程的时代什么时候才能到来？这是个问
题。</p>
<p>On 3月22日, 下午10时41分, windstorm <a href="&#x6d;&#97;&#105;&#108;&#116;&#111;&#x3a;&#x5b;&#108;&#105;&#x6b;&#x75;&#110;&#x61;&#114;&#109;&#x73;&#x74;&#114;&#46;&#46;&#46;&#x40;&#x67;&#109;&#97;&#x69;&#x6c;&#x2e;&#99;&#111;&#109;&#93;&#x28;&#41;">&#x5b;&#108;&#105;&#x6b;&#x75;&#110;&#x61;&#114;&#109;&#x73;&#x74;&#114;&#46;&#46;&#46;&#x40;&#x67;&#109;&#97;&#x69;&#x6c;&#x2e;&#99;&#111;&#109;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>Larrabee当初我还是很看好的，它的架构比其他的更像一个统一的方案，可惜后来Intel自己经验不足搞不好。</p>
<p>OPENCL还是主要面向multimedia吧，CUDA/OpenCL在业界代表了流处理的方向，从GPU针对任务的角度讲是好的。其他的就算了。就像Al leluia说的那样，在硬件架构没有更多的突破之前，不说没有生命力，至少想取得任何进一步的突破都太难。</p>
<p>现在这个领域，你吹你的水，我吹我的水。至于谁的泡泡大，我看不清。所以真要选东西学，最好还是针对自己的application选靠谱。这也是并行编程教育难 的问题。大家需求完全不一样。</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Guancheng Chen <a href="&#x6d;&#97;&#x69;&#108;&#116;&#111;&#58;&#91;&#x63;&#x68;&#101;&#x6e;&#103;&#117;&#97;&#x6e;&#99;&#x68;&#x2e;&#46;&#x2e;&#64;&#x67;&#109;&#97;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#93;&#40;&#41;">&#91;&#x63;&#x68;&#101;&#x6e;&#103;&#117;&#97;&#x6e;&#99;&#x68;&#x2e;&#46;&#x2e;&#64;&#x67;&#109;&#97;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#93;&#40;&#41;</a>:</p>
<blockquote>
<p>我觉得现有的OpenCL确实非常不成熟，但是从纯性能角度上来讲，我看好Heterogeneous架构，尽管它们的编程难度太大，就像前面提到的不
同架构需要做不同优化等。CPU的性能是latency-oriented，GPU是throughput-oriented,Intel的
Larrabee虽然现在来看不成功，但是业界都在朝着那个方向努力。</p>
<p>On 3月22日, 下午6时18分, windstorm <a href="&#109;&#97;&#105;&#x6c;&#x74;&#111;&#x3a;&#x5b;&#108;&#x69;&#107;&#x75;&#110;&#97;&#x72;&#109;&#115;&#116;&#x72;&#x2e;&#46;&#x2e;&#64;&#x67;&#109;&#x61;&#105;&#108;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#40;&#x29;">&#x5b;&#108;&#x69;&#107;&#x75;&#110;&#97;&#x72;&#109;&#115;&#116;&#x72;&#x2e;&#46;&#x2e;&#64;&#x67;&#109;&#x61;&#105;&#108;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>实在是不能同意你更多......很早很早以前我就在这里和人争论过，GPU的并行计算平台不可能一统天下的。CUDA也不是救世主。OpenCL更不是。</p>
<hr>
<p>Yours Sincerely
Kun</p>
<p>www.kunli.info<a href="http://[twitter.com/cnbuff](http://twitter.com/cnbuff" target="_blank">http://[twitter.com/cnbuff](http://twitter.com/cnbuff</a>)</p>
<p>2010/3/22 Alleluia <a href="&#109;&#97;&#105;&#108;&#116;&#x6f;&#x3a;&#x5b;&#97;&#x6c;&#108;&#117;&#108;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#109;&#x61;&#105;&#108;&#x2e;&#99;&#x6f;&#109;&#93;&#40;&#41;">&#x5b;&#97;&#x6c;&#108;&#117;&#108;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#109;&#x61;&#105;&#108;&#x2e;&#99;&#x6f;&#109;&#93;&#40;&#41;</a>:</p>
<blockquote>
<p>Parallelism 说到底是算法问题.Parallelism与Concurrency不同,Concurrency所面对的问题相对的单一可以
让一群有经验的专家来实现一套通用库或者语言来提供一个基本的编程框架.而在Parallelism上,具体的不同问题,其所需要并行的算法是根本不同
的.原因在于不同的问题,其内部的DataDependency的结构完全不同,不同的Data Dependency的结构,需要构造不同的算法.即
便是相同的Data Dependency,在不同的颗粒度下，在不同的硬件条件下所采用的算法也是完全不同的.因为一旦出现Data
Dependency也就意味着并行计算模块之间需要进行通信.从以计算节点为单位的分布式并行,到多核CPU上的Numa结构,到SIMD上的向量处
理器,其计算单元之间的通信手段,通信效率简直天差地别.比如说,在SMP上最常见的并行算法,work stealing也就是Intel的TBB,
是建立在两个条件下第一个是CPU的Cache机制上,这使得通常在内存的之间的数据搬运消耗非常小,第二个是SMP上计算单元相对的少,因此每个计算
单元被分配到的任务就相对的重。其开销远远大于通信的开销,因此这种机制在SMP上相对的划算.但是如果你要在GPU上做Work Stealing就
完全不可行,因为GPU的运算单元数量极多,被分配到的任务就相对来说的非常轻量,CUDA上的一个thread很多时候运算一次的时间不会超过
10us,而一次跨Block的线程之间的通信开销就往往要达到100us左右,再加上目前GPU上的Cache机制非常落后导致了需要频繁的通信开销
的Work Stealing在GPU上是非常不划算得.
所以我个人认为在硬件架构没有更多的突破之前,OpenCL这种东西是没有任何生命力的.不要说CPU的并行与GPU之间差异巨大,就是不同的GPU之
间AMD与Nvidia两个也是各自为政,一个平台上跑得非常快的东西,在另外一个平台极大的可能是龟速.其最终的结果估计就是跟Java的
write once run everywhere一样是个大笑话.</p>
<p>On 3月22日, 下午2时06分, Guancheng Chen <a href="&#x6d;&#x61;&#x69;&#108;&#x74;&#x6f;&#58;&#x5b;&#x63;&#x68;&#x65;&#110;&#103;&#x75;&#x61;&#110;&#99;&#x68;&#x2e;&#46;&#x2e;&#x40;&#103;&#109;&#97;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#40;&#x29;">&#x5b;&#x63;&#x68;&#x65;&#110;&#103;&#x75;&#x61;&#110;&#99;&#x68;&#x2e;&#46;&#x2e;&#x40;&#103;&#109;&#97;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>On 3月22日, 上午2时20分, Tinyfool <a href="&#109;&#x61;&#x69;&#x6c;&#x74;&#111;&#x3a;&#x5b;&#x74;&#105;&#110;&#x79;&#x66;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#x6f;&#109;&#93;&#40;&#x29;">&#x5b;&#x74;&#105;&#110;&#x79;&#x66;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#x6f;&#109;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#x6d;&#97;&#105;&#108;&#116;&#111;&#58;&#x5b;&#x6a;&#x65;&#46;&#46;&#x2e;&#64;&#108;&#x69;&#x76;&#101;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#x29;">&#x5b;&#x6a;&#x65;&#46;&#46;&#x2e;&#64;&#108;&#x69;&#x76;&#101;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#x29;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#x6d;&#x61;&#105;&#108;&#116;&#111;&#x3a;&#x5b;&#x63;&#x68;&#101;&#110;&#103;&#x75;&#x61;&#x6e;&#99;&#x68;&#46;&#x2e;&#46;&#x40;&#103;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#111;&#109;&#x5d;&#40;&#41;">&#x5b;&#x63;&#x68;&#101;&#110;&#103;&#x75;&#x61;&#x6e;&#99;&#x68;&#46;&#x2e;&#46;&#x40;&#103;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#111;&#109;&#x5d;&#40;&#41;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#x6d;&#97;&#105;&#x6c;&#116;&#111;&#58;&#x5b;&#x70;&#111;&#110;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#x6f;&#111;&#103;&#x6c;&#101;&#103;&#114;&#111;&#117;&#112;&#115;&#x2e;&#x63;&#111;&#109;&#93;&#40;&#41;">&#x5b;&#x70;&#111;&#110;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#x6f;&#111;&#103;&#x6c;&#101;&#103;&#114;&#111;&#117;&#112;&#115;&#x2e;&#x63;&#111;&#109;&#93;&#40;&#41;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，...</li>
</ol>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>阅读更多 &gt;&gt;
<a href="">显示删减掉的内容</a></p>
</blockquote>
<p><img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-23</p>
<p>其他收件人：</p>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>On 3月23日, 上午9时15分, qiaojie <a href="&#109;&#97;&#x69;&#108;&#x74;&#111;&#x3a;&#91;&#113;&#105;&#97;&#111;&#46;&#46;&#46;&#x40;&#103;&#x6d;&#97;&#105;&#108;&#x2e;&#99;&#111;&#x6d;&#x5d;&#x28;&#41;">&#91;&#113;&#105;&#97;&#111;&#46;&#46;&#46;&#x40;&#103;&#x6d;&#97;&#105;&#108;&#x2e;&#99;&#111;&#x6d;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1) =
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？
<a href="">显示删减掉的内容</a>
<img src="" alt=""> qiaojie <img src="" alt=""></p>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-23</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>目前正在写的是一个软件渲染器，采用了光栅化和光线跟踪混合算法，渲染算法已经完全并行化了，</p>
<p>在4核系统上基本可以达到线性加速比，更多核的系统暂时还没测试。kd-tree的构造暂时还没有并
行化，以后有空了再研究。</p>
<p>2010/3/23 Guancheng Chen <a href="&#x6d;&#x61;&#105;&#108;&#x74;&#x6f;&#58;&#91;&#x63;&#x68;&#101;&#x6e;&#103;&#x75;&#46;&#x2e;&#46;&#64;&#103;&#109;&#97;&#105;&#x6c;&#46;&#99;&#x6f;&#109;&#x5d;&#40;&#x29;">&#91;&#x63;&#x68;&#101;&#x6e;&#103;&#x75;&#46;&#x2e;&#46;&#64;&#103;&#109;&#97;&#105;&#x6c;&#46;&#99;&#x6f;&#109;&#x5d;&#40;&#x29;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？
On 3月23日, 上午9时15分, qiaojie <a href="&#109;&#x61;&#x69;&#x6c;&#116;&#x6f;&#58;&#91;&#113;&#x69;&#97;&#111;&#46;&#46;&#46;&#x40;&#103;&#109;&#x61;&#x69;&#108;&#46;&#99;&#111;&#x6d;&#93;&#x28;&#x29;">&#91;&#113;&#x69;&#97;&#111;&#46;&#46;&#46;&#x40;&#103;&#109;&#x61;&#x69;&#108;&#46;&#99;&#111;&#x6d;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1) =
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a></p>
<p><img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-24</p>
<p>其他收件人：</p>
<p>Nice 大胆预测Linear speedup应该是每个程序员十年后的目标 呵呵</p>
<p>On 3月23日, 上午10时43分, qiaojie <a href="&#x6d;&#x61;&#105;&#x6c;&#x74;&#111;&#x3a;&#x5b;&#x71;&#x69;&#x61;&#x6f;&#x2e;&#x2e;&#46;&#64;&#x67;&#109;&#97;&#105;&#x6c;&#x2e;&#99;&#x6f;&#109;&#x5d;&#x28;&#41;">&#x5b;&#x71;&#x69;&#x61;&#x6f;&#x2e;&#x2e;&#46;&#64;&#x67;&#109;&#97;&#105;&#x6c;&#x2e;&#99;&#x6f;&#109;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>目前正在写的是一个软件渲染器，采用了光栅化和光线跟踪混合算法，渲染算法已经完全并行化了，
在4核系统上基本可以达到线性加速比，更多核的系统暂时还没测试。kd-tree的构造暂时还没有并
行化，以后有空了再研究。</p>
<p>2010/3/23 Guancheng Chen <a href="&#109;&#97;&#105;&#x6c;&#x74;&#x6f;&#x3a;&#x5b;&#99;&#104;&#101;&#110;&#103;&#x75;&#97;&#110;&#99;&#104;&#x2e;&#46;&#46;&#x40;&#x67;&#109;&#97;&#105;&#x6c;&#46;&#x63;&#x6f;&#109;&#93;&#x28;&#41;">&#x5b;&#99;&#104;&#101;&#110;&#103;&#x75;&#97;&#110;&#99;&#104;&#x2e;&#46;&#46;&#x40;&#x67;&#109;&#97;&#105;&#x6c;&#46;&#x63;&#x6f;&#109;&#93;&#x28;&#41;</a></p>
</blockquote>
<p>&gt;
&gt;
&gt;</p>
<blockquote>
<blockquote>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？</p>
<p>On 3月23日, 上午9时15分, qiaojie <a href="&#109;&#x61;&#105;&#108;&#116;&#111;&#58;&#91;&#x71;&#105;&#x61;&#x6f;&#46;&#46;&#46;&#x40;&#103;&#109;&#x61;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#x29;">&#91;&#x71;&#105;&#x61;&#x6f;&#46;&#46;&#46;&#x40;&#103;&#109;&#x61;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1) =
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？</p>
</blockquote>
<p> To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> longshanksmo <img src="" alt=""></p>
</blockquote>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-24</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<h2 id="-cerl-2-0-">凑个热闹，也来个广告：CERL 2.0初具雏形。</h2>
<p>反者道之动，弱者道之用
<a href="">longsh...@gmail.com</a>
<a href="http://blog.csdn.net/longshanks/" target="_blank"><a href="http://blog.csdn.net/longshanks/">http://blog.csdn.net/longshanks/</a></a>
wave开通
<a href="">显示删减掉的内容</a></p>
<p><img src="" alt=""> qiaojie <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-24</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>不是所有的程序都需要并行化的，能用串行化解决的问题没必要并行，所以即使将来many-core系统成为主流，大部分程序员也没必要去搞并行计算。</p>
<p>我觉得未来的主流应该是类似cell这样一颗全功能核心带众多协处理核心的异构系统，这样才能达到最优的 性能/核心面积比。
2010/3/24 Guancheng Chen <a href="&#109;&#97;&#x69;&#108;&#x74;&#111;&#x3a;&#x5b;&#x63;&#104;&#x65;&#110;&#x67;&#x75;&#46;&#46;&#x2e;&#64;&#x67;&#x6d;&#97;&#x69;&#108;&#46;&#x63;&#111;&#x6d;&#x5d;&#40;&#x29;">&#x5b;&#x63;&#104;&#x65;&#110;&#x67;&#x75;&#46;&#46;&#x2e;&#64;&#x67;&#x6d;&#97;&#x69;&#108;&#46;&#x63;&#111;&#x6d;&#x5d;&#40;&#x29;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>Nice 大胆预测Linear speedup应该是每个程序员十年后的目标 呵呵
On 3月23日, 上午10时43分, qiaojie <a href="&#x6d;&#x61;&#105;&#108;&#116;&#x6f;&#58;&#91;&#113;&#105;&#97;&#111;&#46;&#x2e;&#46;&#x40;&#x67;&#109;&#97;&#105;&#108;&#46;&#99;&#x6f;&#109;&#x5d;&#x28;&#x29;">&#91;&#113;&#105;&#97;&#111;&#46;&#x2e;&#46;&#x40;&#x67;&#109;&#97;&#105;&#108;&#46;&#99;&#x6f;&#109;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>目前正在写的是一个软件渲染器，采用了光栅化和光线跟踪混合算法，渲染算法已经完全并行化了，
在4核系统上基本可以达到线性加速比，更多核的系统暂时还没测试。kd-tree的构造暂时还没有并
行化，以后有空了再研究。</p>
<p>2010/3/23 Guancheng Chen <a href="&#x6d;&#x61;&#105;&#x6c;&#x74;&#111;&#58;&#x5b;&#99;&#104;&#x65;&#x6e;&#x67;&#117;&#97;&#110;&#99;&#104;&#x2e;&#46;&#x2e;&#64;&#x67;&#x6d;&#x61;&#105;&#108;&#x2e;&#x63;&#111;&#109;&#93;&#x28;&#x29;">&#x5b;&#99;&#104;&#x65;&#x6e;&#x67;&#117;&#97;&#110;&#99;&#104;&#x2e;&#46;&#x2e;&#64;&#x67;&#x6d;&#x61;&#105;&#108;&#x2e;&#x63;&#111;&#109;&#93;&#x28;&#x29;</a></p>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>&gt;
&gt;
&gt;</p>
<blockquote>
<blockquote>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？</p>
<p>On 3月23日, 上午9时15分, qiaojie <a href="&#x6d;&#97;&#x69;&#x6c;&#x74;&#111;&#58;&#x5b;&#x71;&#105;&#x61;&#x6f;&#x2e;&#46;&#46;&#x40;&#103;&#109;&#97;&#105;&#x6c;&#46;&#99;&#x6f;&#x6d;&#93;&#x28;&#x29;">&#x5b;&#x71;&#105;&#x61;&#x6f;&#x2e;&#46;&#46;&#x40;&#103;&#109;&#97;&#105;&#x6c;&#46;&#99;&#x6f;&#x6d;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1) =
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？</p>
</blockquote>
<p> To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> 机械唯物主义 : linjunhalida <img src="" alt=""></p>
</blockquote>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-24</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>我猜测未来的主流是数据中心，动态分配运算，存储资源。CPU，内存集群。
加上本地终端，运行一些本地进程，比如GUI，实时视频采集和分析什么的。CPU＋GPU。
根据需求和成本来考虑程序在本地或者数据中心。
其实好像这就是现在的状况？
未来的状况还是要局限于成本和性能，
如果瓶颈在数据传输，那么中心化趋势会很明显。
如果瓶颈在运算，那么程序员要花很多时间在并行处理上。
2010/3/24 qiaojie <a href="&#109;&#x61;&#105;&#x6c;&#x74;&#x6f;&#x3a;&#91;&#x71;&#105;&#x61;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#97;&#105;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#40;&#x29;">&#91;&#x71;&#105;&#x61;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#97;&#105;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#40;&#x29;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>不是所有的程序都需要并行化的，能用串行化解决的问题没必要并行，所以即使将来many-core系统成为主流，大部分程序员也没必要去搞并行计算。</p>
<p>我觉得未来的主流应该是类似cell这样一颗全功能核心带众多协处理核心的异构系统，这样才能达到最优的 性能/核心面积比。
2010/3/24 Guancheng Chen <a href="&#x6d;&#97;&#105;&#x6c;&#116;&#x6f;&#58;&#x5b;&#x63;&#104;&#x65;&#110;&#103;&#x75;&#x2e;&#x2e;&#46;&#64;&#x67;&#109;&#x61;&#x69;&#108;&#46;&#99;&#x6f;&#x6d;&#93;&#x28;&#41;">&#x5b;&#x63;&#104;&#x65;&#110;&#103;&#x75;&#x2e;&#x2e;&#46;&#64;&#x67;&#109;&#x61;&#x69;&#108;&#46;&#99;&#x6f;&#x6d;&#93;&#x28;&#41;</a></p>
<p>Nice 大胆预测Linear speedup应该是每个程序员十年后的目标 呵呵
On 3月23日, 上午10时43分, qiaojie <a href="&#109;&#x61;&#x69;&#108;&#116;&#111;&#x3a;&#x5b;&#x71;&#105;&#x61;&#111;&#x2e;&#46;&#x2e;&#x40;&#x67;&#x6d;&#97;&#x69;&#x6c;&#46;&#x63;&#111;&#109;&#x5d;&#x28;&#41;">&#x5b;&#x71;&#105;&#x61;&#111;&#x2e;&#46;&#x2e;&#x40;&#x67;&#x6d;&#97;&#x69;&#x6c;&#46;&#x63;&#111;&#109;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>目前正在写的是一个软件渲染器，采用了光栅化和光线跟踪混合算法，渲染算法已经完全并行化了，
在4核系统上基本可以达到线性加速比，更多核的系统暂时还没测试。kd-tree的构造暂时还没有并
行化，以后有空了再研究。</p>
<p>2010/3/23 Guancheng Chen <a href="&#109;&#97;&#105;&#108;&#x74;&#111;&#x3a;&#x5b;&#x63;&#104;&#x65;&#110;&#x67;&#x75;&#x61;&#x6e;&#99;&#104;&#46;&#46;&#46;&#x40;&#x67;&#x6d;&#97;&#x69;&#x6c;&#46;&#99;&#111;&#x6d;&#x5d;&#40;&#x29;">&#x5b;&#x63;&#104;&#x65;&#110;&#x67;&#x75;&#x61;&#x6e;&#99;&#104;&#46;&#46;&#46;&#x40;&#x67;&#x6d;&#97;&#x69;&#x6c;&#46;&#99;&#111;&#x6d;&#x5d;&#40;&#x29;</a></p>
<blockquote>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？</p>
<p>On 3月23日, 上午9时15分, qiaojie <a href="&#x6d;&#97;&#x69;&#108;&#x74;&#x6f;&#58;&#x5b;&#x71;&#x69;&#97;&#x6f;&#x2e;&#x2e;&#46;&#64;&#103;&#109;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#111;&#109;&#93;&#x28;&#x29;">&#x5b;&#x71;&#x69;&#97;&#x6f;&#x2e;&#x2e;&#46;&#64;&#103;&#109;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#111;&#109;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1) =
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？</p>
</blockquote>
<p> To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a></p>
<p><img src="" alt=""> Hongzh...@gmail.com <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-24</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>异构平台如果编程复杂度降不下来的话很难流行起来。cell已经死了...
2010/3/24 qiaojie <a href="&#x6d;&#97;&#105;&#108;&#x74;&#x6f;&#x3a;&#x5b;&#113;&#x69;&#x61;&#x2e;&#x2e;&#46;&#64;&#103;&#109;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#93;&#40;&#x29;">&#x5b;&#113;&#x69;&#x61;&#x2e;&#x2e;&#46;&#64;&#103;&#109;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#93;&#40;&#x29;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>不是所有的程序都需要并行化的，能用串行化解决的问题没必要并行，所以即使将来many-core系统成为主流，大部分程序员也没必要去搞并行计算。</p>
<p>我觉得未来的主流应该是类似cell这样一颗全功能核心带众多协处理核心的异构系统，这样才能达到最优的 性能/核心面积比。
2010/3/24 Guancheng Chen <a href="&#x6d;&#x61;&#x69;&#x6c;&#116;&#x6f;&#x3a;&#91;&#99;&#104;&#101;&#110;&#103;&#117;&#x2e;&#46;&#46;&#x40;&#x67;&#109;&#97;&#x69;&#x6c;&#46;&#99;&#x6f;&#x6d;&#x5d;&#40;&#x29;">&#91;&#99;&#104;&#101;&#110;&#103;&#117;&#x2e;&#46;&#46;&#x40;&#x67;&#109;&#97;&#x69;&#x6c;&#46;&#99;&#x6f;&#x6d;&#x5d;&#40;&#x29;</a></p>
<p>Nice 大胆预测Linear speedup应该是每个程序员十年后的目标 呵呵
On 3月23日, 上午10时43分, qiaojie <a href="&#109;&#97;&#105;&#108;&#x74;&#x6f;&#x3a;&#x5b;&#113;&#x69;&#x61;&#x6f;&#x2e;&#46;&#46;&#x40;&#x67;&#109;&#x61;&#x69;&#x6c;&#x2e;&#99;&#111;&#x6d;&#93;&#40;&#41;">&#x5b;&#113;&#x69;&#x61;&#x6f;&#x2e;&#46;&#46;&#x40;&#x67;&#109;&#x61;&#x69;&#x6c;&#x2e;&#99;&#111;&#x6d;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>目前正在写的是一个软件渲染器，采用了光栅化和光线跟踪混合算法，渲染算法已经完全并行化了，
在4核系统上基本可以达到线性加速比，更多核的系统暂时还没测试。kd-tree的构造暂时还没有并
行化，以后有空了再研究。</p>
<p>2010/3/23 Guancheng Chen <a href="&#109;&#97;&#x69;&#x6c;&#116;&#111;&#x3a;&#91;&#99;&#104;&#x65;&#110;&#103;&#x75;&#97;&#x6e;&#99;&#x68;&#46;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#105;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#x28;&#x29;">&#91;&#99;&#104;&#x65;&#110;&#103;&#x75;&#97;&#x6e;&#99;&#x68;&#46;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#105;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#x28;&#x29;</a></p>
<blockquote>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？</p>
<p>On 3月23日, 上午9时15分, qiaojie <a href="&#109;&#97;&#x69;&#108;&#116;&#x6f;&#x3a;&#x5b;&#113;&#x69;&#x61;&#111;&#46;&#46;&#46;&#x40;&#103;&#109;&#x61;&#105;&#x6c;&#46;&#99;&#x6f;&#x6d;&#x5d;&#40;&#41;">&#x5b;&#113;&#x69;&#x61;&#111;&#46;&#46;&#46;&#x40;&#103;&#109;&#x61;&#105;&#x6c;&#46;&#99;&#x6f;&#x6d;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1) =
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？</p>
</blockquote>
<p> To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> qiaojie <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-24</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>说的没错，cell已经成了先烈了。不过这不代表异构的方向不对，CUDA，OpenCL也都是异构平台，以后我们会越来越习惯异构平台的。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#109;&#97;&#x69;&#x6c;&#116;&#111;&#x3a;&#x5b;&#x68;&#x6f;&#110;&#103;&#122;&#x68;&#x2e;&#46;&#46;&#x40;&#103;&#109;&#97;&#105;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#93;&#x28;&#x29;">&#x5b;&#x68;&#x6f;&#110;&#103;&#122;&#x68;&#x2e;&#46;&#46;&#x40;&#103;&#109;&#97;&#105;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#93;&#x28;&#x29;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>异构平台如果编程复杂度降不下来的话很难流行起来。cell已经死了...
2010/3/24 qiaojie <a href="&#109;&#x61;&#x69;&#108;&#x74;&#111;&#58;&#x5b;&#113;&#105;&#x61;&#x2e;&#46;&#46;&#64;&#103;&#109;&#x61;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#93;&#40;&#x29;">&#x5b;&#113;&#105;&#x61;&#x2e;&#46;&#46;&#64;&#103;&#109;&#x61;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#93;&#40;&#x29;</a>
 不是所有的程序都需要并行化的，能用串行化解决的问题没必要并行，所以即使将来many-core系统成为主流，大部分程序员也没必要去搞并行计算。</p>
<p>我觉得未来的主流应该是类似cell这样一颗全功能核心带众多协处理核心的异构系统，这样才能达到最优的 性能/核心面积比。</p>
<p>2010/3/24 Guancheng Chen <a href="&#109;&#97;&#x69;&#x6c;&#x74;&#111;&#x3a;&#91;&#99;&#104;&#101;&#x6e;&#x67;&#x75;&#46;&#46;&#46;&#64;&#x67;&#x6d;&#x61;&#105;&#108;&#46;&#99;&#x6f;&#109;&#93;&#40;&#x29;">&#91;&#99;&#104;&#101;&#x6e;&#x67;&#x75;&#46;&#46;&#46;&#64;&#x67;&#x6d;&#x61;&#105;&#108;&#46;&#99;&#x6f;&#109;&#93;&#40;&#x29;</a></p>
<p>Nice 大胆预测Linear speedup应该是每个程序员十年后的目标 呵呵
On 3月23日, 上午10时43分, qiaojie <a href="&#109;&#97;&#x69;&#x6c;&#x74;&#x6f;&#x3a;&#91;&#x71;&#x69;&#97;&#111;&#46;&#x2e;&#46;&#x40;&#103;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#111;&#109;&#x5d;&#x28;&#41;">&#91;&#x71;&#x69;&#97;&#111;&#46;&#x2e;&#46;&#x40;&#103;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#111;&#109;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>目前正在写的是一个软件渲染器，采用了光栅化和光线跟踪混合算法，渲染算法已经完全并行化了，
在4核系统上基本可以达到线性加速比，更多核的系统暂时还没测试。kd-tree的构造暂时还没有并
行化，以后有空了再研究。</p>
<p>2010/3/23 Guancheng Chen <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#x3a;&#91;&#99;&#x68;&#x65;&#110;&#x67;&#117;&#97;&#110;&#99;&#104;&#x2e;&#46;&#x2e;&#x40;&#103;&#x6d;&#x61;&#x69;&#108;&#x2e;&#99;&#x6f;&#x6d;&#93;&#x28;&#41;">&#91;&#99;&#x68;&#x65;&#110;&#x67;&#117;&#97;&#110;&#99;&#104;&#x2e;&#46;&#x2e;&#x40;&#103;&#x6d;&#x61;&#x69;&#108;&#x2e;&#99;&#x6f;&#x6d;&#93;&#x28;&#41;</a></p>
<blockquote>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？</p>
<p>On 3月23日, 上午9时15分, qiaojie <a href="&#x6d;&#97;&#x69;&#108;&#x74;&#x6f;&#x3a;&#91;&#113;&#x69;&#x61;&#111;&#x2e;&#x2e;&#46;&#x40;&#103;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#99;&#111;&#109;&#x5d;&#x28;&#41;">&#91;&#113;&#x69;&#x61;&#111;&#x2e;&#x2e;&#46;&#x40;&#103;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#99;&#111;&#109;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1) =
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？</p>
</blockquote>
<p> To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a></p>
<p><img src="" alt=""> sunjoy <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-24</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>挺有意思的，我之前没有接触过并行计算的相关理论，按照你的公式我花了个图，反映并行度、加速比以及CPU核之间的关系。</p>
<p>2010/3/23 qiaojie <a href="&#109;&#97;&#x69;&#108;&#x74;&#x6f;&#58;&#91;&#x71;&#105;&#x61;&#x2e;&#x2e;&#46;&#64;&#x67;&#x6d;&#x61;&#105;&#108;&#46;&#99;&#x6f;&#109;&#x5d;&#40;&#41;">&#91;&#x71;&#105;&#x61;&#x2e;&#x2e;&#46;&#64;&#x67;&#x6d;&#x61;&#105;&#108;&#46;&#99;&#x6f;&#109;&#x5d;&#40;&#41;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1) = 5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？
 To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a></p>
<p>附件 (1)</p>
<p><a href="https://groups.google.com/group/pongba/attach/53e12db326792d31/parallelism.png?part=4&amp;authuser=0&amp;view=1" title="parallelism.png"></a></p>
<p>parallelism.png 23 KB   <a href="https://groups.google.com/group/pongba/attach/53e12db326792d31/parallelism.png?part=4&amp;authuser=0&amp;view=1" target="_blank">查看</a>   <a href="https://groups.google.com/group/pongba/attach/53e12db326792d31/parallelism.png?part=4&amp;authuser=0" target="_blank">下载</a>
<img src="" alt=""> Hongzh...@gmail.com <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-24</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>异构平台从网络处理器算起已经快10年了，现在情况仍然不明朗。就我看到的，异构平台要想高效，就必须向程序员暴露非常多的硬件细节，这必然导致编程的复杂性。曲高和寡，要想渗透到应用程序这一块，我觉得很难。</p>
<p>2010/3/24 qiaojie <a href="&#x6d;&#x61;&#x69;&#108;&#116;&#x6f;&#x3a;&#x5b;&#x71;&#x69;&#97;&#46;&#x2e;&#46;&#x40;&#x67;&#x6d;&#x61;&#x69;&#108;&#46;&#99;&#x6f;&#109;&#93;&#x28;&#x29;">&#x5b;&#x71;&#x69;&#97;&#46;&#x2e;&#46;&#x40;&#x67;&#x6d;&#x61;&#x69;&#108;&#46;&#99;&#x6f;&#109;&#93;&#x28;&#x29;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>说的没错，cell已经成了先烈了。不过这不代表异构的方向不对，CUDA，OpenCL也都是异构平台，以后我们会越来越习惯异构平台的。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#109;&#97;&#x69;&#x6c;&#x74;&#111;&#x3a;&#x5b;&#104;&#x6f;&#x6e;&#103;&#122;&#104;&#46;&#x2e;&#x2e;&#x40;&#103;&#109;&#x61;&#105;&#108;&#x2e;&#99;&#x6f;&#x6d;&#93;&#40;&#41;">&#x5b;&#104;&#x6f;&#x6e;&#103;&#122;&#104;&#46;&#x2e;&#x2e;&#x40;&#103;&#109;&#x61;&#105;&#108;&#x2e;&#99;&#x6f;&#x6d;&#93;&#40;&#41;</a></p>
<p>异构平台如果编程复杂度降不下来的话很难流行起来。cell已经死了...
2010/3/24 qiaojie <a href="&#x6d;&#x61;&#105;&#x6c;&#x74;&#111;&#58;&#x5b;&#x71;&#105;&#x61;&#x2e;&#x2e;&#x2e;&#64;&#103;&#109;&#97;&#x69;&#108;&#46;&#x63;&#111;&#109;&#93;&#40;&#41;">&#x5b;&#x71;&#105;&#x61;&#x2e;&#x2e;&#x2e;&#64;&#103;&#109;&#97;&#x69;&#108;&#46;&#x63;&#111;&#109;&#93;&#40;&#41;</a>
 不是所有的程序都需要并行化的，能用串行化解决的问题没必要并行，所以即使将来many-core系统成为主流，大部分程序员也没必要去搞并行计算。</p>
<p>我觉得未来的主流应该是类似cell这样一颗全功能核心带众多协处理核心的异构系统，这样才能达到最优的 性能/核心面积比。</p>
<p>2010/3/24 Guancheng Chen <a href="&#109;&#x61;&#x69;&#108;&#x74;&#x6f;&#58;&#x5b;&#99;&#104;&#101;&#110;&#103;&#117;&#x2e;&#x2e;&#46;&#64;&#x67;&#x6d;&#x61;&#105;&#108;&#x2e;&#99;&#x6f;&#109;&#93;&#x28;&#41;">&#x5b;&#99;&#104;&#101;&#110;&#103;&#117;&#x2e;&#x2e;&#46;&#64;&#x67;&#x6d;&#x61;&#105;&#108;&#x2e;&#99;&#x6f;&#109;&#93;&#x28;&#41;</a></p>
<p>Nice 大胆预测Linear speedup应该是每个程序员十年后的目标 呵呵
On 3月23日, 上午10时43分, qiaojie <a href="&#109;&#x61;&#105;&#108;&#x74;&#x6f;&#58;&#91;&#113;&#x69;&#x61;&#111;&#x2e;&#46;&#46;&#64;&#x67;&#109;&#97;&#x69;&#108;&#x2e;&#99;&#111;&#109;&#93;&#40;&#41;">&#91;&#113;&#x69;&#x61;&#111;&#x2e;&#46;&#46;&#64;&#x67;&#109;&#97;&#x69;&#108;&#x2e;&#99;&#111;&#109;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>目前正在写的是一个软件渲染器，采用了光栅化和光线跟踪混合算法，渲染算法已经完全并行化了，
在4核系统上基本可以达到线性加速比，更多核的系统暂时还没测试。kd-tree的构造暂时还没有并
行化，以后有空了再研究。</p>
<p>2010/3/23 Guancheng Chen <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#x5b;&#x63;&#x68;&#x65;&#110;&#x67;&#117;&#x61;&#x6e;&#x63;&#104;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#109;&#x61;&#x69;&#x6c;&#46;&#x63;&#111;&#x6d;&#x5d;&#40;&#x29;">&#x5b;&#x63;&#x68;&#x65;&#110;&#x67;&#117;&#x61;&#x6e;&#x63;&#104;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#109;&#x61;&#x69;&#x6c;&#46;&#x63;&#111;&#x6d;&#x5d;&#40;&#x29;</a></p>
<blockquote>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？</p>
<p>On 3月23日, 上午9时15分, qiaojie <a href="&#109;&#x61;&#x69;&#108;&#x74;&#x6f;&#58;&#91;&#x71;&#105;&#x61;&#x6f;&#x2e;&#46;&#x2e;&#x40;&#103;&#109;&#97;&#x69;&#108;&#46;&#99;&#x6f;&#109;&#x5d;&#x28;&#x29;">&#91;&#x71;&#105;&#x61;&#x6f;&#x2e;&#46;&#x2e;&#x40;&#103;&#109;&#97;&#x69;&#108;&#46;&#99;&#x6f;&#109;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1) =
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？</p>
</blockquote>
<p> To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a></p>
<p><img src="" alt=""> qiaojie <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-24</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>并行计算本来就是曲高和寡的东西，就跟3D渲染一样，能开发引擎的毕竟只是小部分人，大多数人在引擎的基础上做应用。关键在于是否有杀手应用，只要有大量的需求，自然会有人去做开发。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#x6d;&#x61;&#105;&#108;&#116;&#x6f;&#58;&#91;&#104;&#111;&#x6e;&#x67;&#122;&#x68;&#x2e;&#x2e;&#46;&#x40;&#x67;&#109;&#97;&#x69;&#108;&#46;&#99;&#111;&#109;&#x5d;&#x28;&#41;">&#91;&#104;&#111;&#x6e;&#x67;&#122;&#x68;&#x2e;&#x2e;&#46;&#x40;&#x67;&#109;&#97;&#x69;&#108;&#46;&#99;&#111;&#109;&#x5d;&#x28;&#41;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>异构平台从网络处理器算起已经快10年了，现在情况仍然不明朗。就我看到的，异构平台要想高效，就必须向程序员暴露非常多的硬件细节，这必然导致编程的复杂性。曲高和寡，要想渗透到应用程序这一块，我觉得很难。</p>
<p>2010/3/24 qiaojie <a href="&#109;&#97;&#x69;&#108;&#116;&#x6f;&#58;&#91;&#113;&#x69;&#x61;&#46;&#x2e;&#46;&#x40;&#x67;&#109;&#x61;&#105;&#x6c;&#46;&#x63;&#x6f;&#109;&#93;&#40;&#41;">&#91;&#113;&#x69;&#x61;&#46;&#x2e;&#46;&#x40;&#x67;&#109;&#x61;&#105;&#x6c;&#46;&#x63;&#x6f;&#109;&#93;&#40;&#41;</a>
说的没错，cell已经成了先烈了。不过这不代表异构的方向不对，CUDA，OpenCL也都是异构平台，以后我们会越来越习惯异构平台的。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#x6d;&#97;&#x69;&#x6c;&#x74;&#111;&#58;&#91;&#x68;&#x6f;&#x6e;&#103;&#122;&#104;&#x2e;&#46;&#46;&#64;&#x67;&#109;&#x61;&#x69;&#108;&#46;&#99;&#x6f;&#x6d;&#93;&#x28;&#41;">&#91;&#x68;&#x6f;&#x6e;&#103;&#122;&#104;&#x2e;&#46;&#46;&#64;&#x67;&#109;&#x61;&#x69;&#108;&#46;&#99;&#x6f;&#x6d;&#93;&#x28;&#41;</a></p>
<p>异构平台如果编程复杂度降不下来的话很难流行起来。cell已经死了...
2010/3/24 qiaojie <a href="&#109;&#x61;&#105;&#x6c;&#116;&#111;&#x3a;&#x5b;&#x71;&#105;&#x61;&#46;&#x2e;&#46;&#x40;&#x67;&#109;&#x61;&#105;&#108;&#46;&#99;&#x6f;&#x6d;&#x5d;&#40;&#x29;">&#x5b;&#x71;&#105;&#x61;&#46;&#x2e;&#46;&#x40;&#x67;&#109;&#x61;&#105;&#108;&#46;&#99;&#x6f;&#x6d;&#x5d;&#40;&#x29;</a>
 不是所有的程序都需要并行化的，能用串行化解决的问题没必要并行，所以即使将来many-core系统成为主流，大部分程序员也没必要去搞并行计算。</p>
<p>我觉得未来的主流应该是类似cell这样一颗全功能核心带众多协处理核心的异构系统，这样才能达到最优的 性能/核心面积比。</p>
<p>2010/3/24 Guancheng Chen <a href="&#109;&#x61;&#x69;&#x6c;&#116;&#x6f;&#58;&#91;&#99;&#x68;&#101;&#x6e;&#103;&#x75;&#46;&#x2e;&#x2e;&#64;&#x67;&#109;&#x61;&#x69;&#x6c;&#46;&#x63;&#x6f;&#109;&#93;&#40;&#41;">&#91;&#99;&#x68;&#101;&#x6e;&#103;&#x75;&#46;&#x2e;&#x2e;&#64;&#x67;&#109;&#x61;&#x69;&#x6c;&#46;&#x63;&#x6f;&#109;&#93;&#40;&#41;</a></p>
<p>Nice 大胆预测Linear speedup应该是每个程序员十年后的目标 呵呵
On 3月23日, 上午10时43分, qiaojie <a href="&#x6d;&#97;&#x69;&#108;&#116;&#111;&#x3a;&#x5b;&#x71;&#x69;&#97;&#111;&#46;&#x2e;&#x2e;&#64;&#x67;&#109;&#x61;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#41;">&#x5b;&#x71;&#x69;&#97;&#111;&#46;&#x2e;&#x2e;&#64;&#x67;&#109;&#x61;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>目前正在写的是一个软件渲染器，采用了光栅化和光线跟踪混合算法，渲染算法已经完全并行化了，
在4核系统上基本可以达到线性加速比，更多核的系统暂时还没测试。kd-tree的构造暂时还没有并
行化，以后有空了再研究。</p>
<p>2010/3/23 Guancheng Chen <a href="&#x6d;&#x61;&#105;&#108;&#x74;&#x6f;&#x3a;&#91;&#99;&#104;&#x65;&#x6e;&#x67;&#117;&#x61;&#x6e;&#x63;&#104;&#46;&#x2e;&#46;&#x40;&#103;&#x6d;&#97;&#x69;&#108;&#46;&#99;&#111;&#x6d;&#93;&#40;&#41;">&#91;&#99;&#104;&#x65;&#x6e;&#x67;&#117;&#x61;&#x6e;&#x63;&#104;&#46;&#x2e;&#46;&#x40;&#103;&#x6d;&#97;&#x69;&#108;&#46;&#99;&#111;&#x6d;&#93;&#40;&#41;</a></p>
<blockquote>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？</p>
<p>On 3月23日, 上午9时15分, qiaojie <a href="&#x6d;&#97;&#x69;&#108;&#116;&#111;&#58;&#91;&#113;&#x69;&#97;&#x6f;&#46;&#x2e;&#46;&#64;&#103;&#x6d;&#97;&#105;&#x6c;&#x2e;&#x63;&#111;&#109;&#93;&#x28;&#x29;">&#91;&#113;&#x69;&#97;&#x6f;&#46;&#x2e;&#46;&#64;&#103;&#x6d;&#97;&#105;&#x6c;&#x2e;&#x63;&#111;&#109;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1) =
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？</p>
</blockquote>
<p> To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> Guancheng Chen <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-25</p>
<p>其他收件人：</p>
<p>杀手应用一般来说是指什么样的应用呢？比如用户群特别大的网游？还是那些专有的科学计算用的软件？</p>
<p>On 3月24日, 下午12时36分, qiaojie <a href="&#x6d;&#97;&#105;&#x6c;&#x74;&#111;&#x3a;&#91;&#x71;&#105;&#x61;&#x6f;&#46;&#46;&#x2e;&#x40;&#103;&#x6d;&#x61;&#105;&#108;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#41;">&#91;&#x71;&#105;&#x61;&#x6f;&#46;&#46;&#x2e;&#x40;&#103;&#x6d;&#x61;&#105;&#108;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>并行计算本来就是曲高和寡的东西，就跟3D渲染一样，能开发引擎的毕竟只是小部分人，大多数人在引擎的基础上做应用。关键在于是否有杀手应用，只要有大量的需求 ，自然会有人去做开发。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#109;&#97;&#x69;&#108;&#116;&#x6f;&#x3a;&#x5b;&#104;&#x6f;&#x6e;&#103;&#x7a;&#104;&#97;&#110;&#103;&#46;&#46;&#46;&#46;&#64;&#103;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#93;&#x28;&#x29;">&#x5b;&#104;&#x6f;&#x6e;&#103;&#x7a;&#104;&#97;&#110;&#103;&#46;&#46;&#46;&#46;&#64;&#103;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#93;&#x28;&#x29;</a></p>
</blockquote>
<p>&gt;
&gt;
&gt;</p>
<blockquote>
<blockquote>
<p>异构平台从网络处理器算起已经快10年了，现在情况仍然不明朗。就我看到的，异构平台要想高效，就必须向程序员暴露非常多的硬件细节，这必然导致编程的复杂性。 曲高和寡，要想渗透到应用程序这一块，我觉得很难。</p>
<p>2010/3/24 qiaojie <a href="&#x6d;&#97;&#x69;&#108;&#116;&#x6f;&#x3a;&#91;&#x71;&#x69;&#x61;&#111;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#109;&#x61;&#105;&#108;&#x2e;&#99;&#x6f;&#109;&#93;&#x28;&#x29;">&#91;&#x71;&#x69;&#x61;&#111;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#109;&#x61;&#105;&#108;&#x2e;&#99;&#x6f;&#109;&#93;&#x28;&#x29;</a></p>
</blockquote>
</blockquote>
<p>&gt;</p>
<blockquote>
<blockquote>
<blockquote>
<p>说的没错，cell已经成了先烈了。不过这不代表异构的方向不对，CUDA，OpenCL也都是异构平台，以后我们会越来越习惯异构平台的。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#x6d;&#x61;&#105;&#x6c;&#x74;&#x6f;&#58;&#x5b;&#104;&#x6f;&#110;&#103;&#x7a;&#104;&#x61;&#110;&#x67;&#x2e;&#46;&#46;&#x2e;&#64;&#x67;&#109;&#x61;&#x69;&#108;&#46;&#x63;&#x6f;&#x6d;&#93;&#x28;&#41;">&#x5b;&#104;&#x6f;&#110;&#103;&#x7a;&#104;&#x61;&#110;&#x67;&#x2e;&#46;&#46;&#x2e;&#64;&#x67;&#109;&#x61;&#x69;&#108;&#46;&#x63;&#x6f;&#x6d;&#93;&#x28;&#41;</a></p>
<p>异构平台如果编程复杂度降不下来的话很难流行起来。cell已经死了...</p>
<blockquote>
<p> 2010/3/24 qiaojie <a href="&#x6d;&#x61;&#x69;&#x6c;&#116;&#111;&#58;&#91;&#x71;&#105;&#x61;&#111;&#x2e;&#x2e;&#x2e;&#64;&#103;&#109;&#97;&#x69;&#108;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#x29;">&#91;&#x71;&#105;&#x61;&#111;&#x2e;&#x2e;&#x2e;&#64;&#103;&#109;&#97;&#x69;&#108;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#x29;</a></p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>&gt;</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>不是所有的程序都需要并行化的，能用串行化解决的问题没必要并行，所以即使将来many-core系统成为主流，大部分程序员也没必要去搞并行计算。
  我觉得未来的主流应该是类似cell这样一颗全功能核心带众多协处理核心的异构系统，这样才能达到最优的 性能/核心面积比。</p>
<p>2010/3/24 Guancheng Chen <a href="&#109;&#x61;&#x69;&#108;&#x74;&#111;&#58;&#x5b;&#x63;&#104;&#101;&#x6e;&#103;&#x75;&#x61;&#x6e;&#99;&#x68;&#x2e;&#x2e;&#46;&#64;&#x67;&#109;&#97;&#x69;&#108;&#46;&#x63;&#111;&#109;&#x5d;&#40;&#41;">&#x5b;&#x63;&#104;&#101;&#x6e;&#103;&#x75;&#x61;&#x6e;&#99;&#x68;&#x2e;&#x2e;&#46;&#64;&#x67;&#109;&#97;&#x69;&#108;&#46;&#x63;&#111;&#109;&#x5d;&#40;&#41;</a></p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>&gt;</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>Nice 大胆预测Linear speedup应该是每个程序员十年后的目标 呵呵</p>
<blockquote>
<p>On 3月23日, 上午10时43分, qiaojie <a href="&#109;&#x61;&#105;&#108;&#116;&#111;&#58;&#x5b;&#113;&#105;&#x61;&#x6f;&#x2e;&#x2e;&#46;&#x40;&#103;&#x6d;&#x61;&#x69;&#x6c;&#46;&#99;&#x6f;&#109;&#x5d;&#40;&#x29;">&#x5b;&#113;&#105;&#x61;&#x6f;&#x2e;&#x2e;&#46;&#x40;&#103;&#x6d;&#x61;&#x69;&#x6c;&#46;&#99;&#x6f;&#109;&#x5d;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>目前正在写的是一个软件渲染器，采用了光栅化和光线跟踪混合算法，渲染算法已经完全并行化了，
在4核系统上基本可以达到线性加速比，更多核的系统暂时还没测试。kd-tree的构造暂时还没有并
行化，以后有空了再研究。</p>
<p>2010/3/23 Guancheng Chen <a href="&#x6d;&#97;&#x69;&#108;&#116;&#x6f;&#x3a;&#91;&#x63;&#x68;&#101;&#110;&#103;&#117;&#97;&#110;&#99;&#x68;&#46;&#46;&#46;&#x40;&#x67;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#x28;&#41;">&#91;&#x63;&#x68;&#101;&#110;&#103;&#117;&#97;&#110;&#99;&#x68;&#46;&#46;&#46;&#x40;&#x67;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#x28;&#41;</a></p>
<blockquote>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？</p>
<p>On 3月23日, 上午9时15分, qiaojie <a href="&#x6d;&#x61;&#105;&#x6c;&#x74;&#x6f;&#58;&#x5b;&#113;&#105;&#x61;&#111;&#46;&#46;&#x2e;&#64;&#103;&#109;&#97;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#93;&#40;&#41;">&#x5b;&#113;&#105;&#x61;&#111;&#46;&#46;&#x2e;&#64;&#103;&#109;&#97;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1)
=
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank
Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？</p>
</blockquote>
<p> To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
<a href="">显示删减掉的内容</a></p>
</blockquote>
</blockquote>
<p><img src="" alt=""> qiaojie <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-25</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>3D游戏就是一类杀手应用，由此支撑起了一个庞大的GPU市场，芯片行业的研发成本是很高的，没有一个庞大的市场是做不起来的。目前的消费者对于多核系统显然还没有强烈的需求，因为应用跟不上，i7发布快2年了还没进入主流市场，这种情况延续下去的话摩尔定律将因此失效。不过我相信杀手级应用总会出现的，这可能要硬件性能突破一个临界点，比方说目前GPU的性能再提升一个数量级的话，光线跟踪算法就可以提供流畅的接近CG的画质，倒是此类应用便会流行开来。</p>
<p>2010/3/25 Guancheng Chen <a href="&#109;&#97;&#x69;&#108;&#116;&#111;&#x3a;&#91;&#x63;&#x68;&#101;&#110;&#x67;&#x75;&#x2e;&#46;&#x2e;&#64;&#x67;&#109;&#x61;&#105;&#108;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#x28;&#x29;">&#91;&#x63;&#x68;&#101;&#110;&#x67;&#x75;&#x2e;&#46;&#x2e;&#64;&#x67;&#109;&#x61;&#105;&#108;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#x28;&#x29;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>杀手应用一般来说是指什么样的应用呢？比如用户群特别大的网游？还是那些专有的科学计算用的软件？
On 3月24日, 下午12时36分, qiaojie <a href="&#x6d;&#x61;&#x69;&#108;&#116;&#111;&#x3a;&#91;&#113;&#105;&#x61;&#x6f;&#46;&#x2e;&#x2e;&#64;&#103;&#x6d;&#97;&#105;&#108;&#46;&#99;&#111;&#x6d;&#93;&#40;&#x29;">&#91;&#113;&#105;&#x61;&#x6f;&#46;&#x2e;&#x2e;&#64;&#103;&#x6d;&#97;&#105;&#108;&#46;&#99;&#111;&#x6d;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>并行计算本来就是曲高和寡的东西，就跟3D渲染一样，能开发引擎的毕竟只是小部分人，大多数人在引擎的基础上做应用。关键在于是否有杀手应用，只要有大量的需求 ，自然会有人去做开发。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#x6d;&#97;&#105;&#x6c;&#x74;&#x6f;&#58;&#x5b;&#104;&#x6f;&#110;&#103;&#122;&#x68;&#97;&#110;&#103;&#46;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#109;&#x61;&#105;&#108;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#x29;">&#x5b;&#104;&#x6f;&#110;&#103;&#122;&#x68;&#97;&#110;&#103;&#46;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#109;&#x61;&#105;&#108;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#x29;</a></p>
<blockquote>
<p>异构平台从网络处理器算起已经快10年了，现在情况仍然不明朗。就我看到的，异构平台要想高效，就必须向程序员暴露非常多的硬件细节，这必然导致编程的复杂性。 曲高和寡，要想渗透到应用程序这一块，我觉得很难。</p>
<p>2010/3/24 qiaojie <a href="&#109;&#x61;&#x69;&#108;&#x74;&#111;&#58;&#x5b;&#x71;&#x69;&#97;&#x6f;&#46;&#46;&#x2e;&#64;&#103;&#109;&#97;&#x69;&#108;&#46;&#x63;&#111;&#x6d;&#x5d;&#x28;&#41;">&#x5b;&#x71;&#x69;&#97;&#x6f;&#46;&#46;&#x2e;&#64;&#103;&#109;&#97;&#x69;&#108;&#46;&#x63;&#111;&#x6d;&#x5d;&#x28;&#41;</a></p>
<blockquote>
<p>说的没错，cell已经成了先烈了。不过这不代表异构的方向不对，CUDA，OpenCL也都是异构平台，以后我们会越来越习惯异构平台的。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#109;&#97;&#x69;&#x6c;&#x74;&#x6f;&#x3a;&#91;&#x68;&#x6f;&#110;&#x67;&#122;&#104;&#97;&#110;&#x67;&#x2e;&#46;&#46;&#46;&#64;&#x67;&#109;&#x61;&#x69;&#108;&#46;&#x63;&#111;&#x6d;&#93;&#x28;&#41;">&#91;&#x68;&#x6f;&#110;&#x67;&#122;&#104;&#97;&#110;&#x67;&#x2e;&#46;&#46;&#46;&#64;&#x67;&#109;&#x61;&#x69;&#108;&#46;&#x63;&#111;&#x6d;&#93;&#x28;&#41;</a></p>
<p>异构平台如果编程复杂度降不下来的话很难流行起来。cell已经死了...</p>
<blockquote>
<p> 2010/3/24 qiaojie <a href="&#x6d;&#x61;&#105;&#108;&#116;&#111;&#58;&#91;&#x71;&#x69;&#x61;&#111;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#109;&#97;&#105;&#x6c;&#46;&#99;&#111;&#x6d;&#93;&#x28;&#41;">&#91;&#x71;&#x69;&#x61;&#111;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#109;&#97;&#105;&#x6c;&#46;&#99;&#111;&#x6d;&#93;&#x28;&#41;</a></p>
<blockquote>
<p>不是所有的程序都需要并行化的，能用串行化解决的问题没必要并行，所以即使将来many-core系统成为主流，大部分程序员也没必要去搞并行计算。
  我觉得未来的主流应该是类似cell这样一颗全功能核心带众多协处理核心的异构系统，这样才能达到最优的 性能/核心面积比。</p>
<p>2010/3/24 Guancheng Chen <a href="&#x6d;&#x61;&#105;&#108;&#116;&#111;&#x3a;&#x5b;&#x63;&#x68;&#101;&#x6e;&#x67;&#x75;&#x61;&#110;&#99;&#104;&#46;&#x2e;&#46;&#x40;&#x67;&#109;&#x61;&#x69;&#108;&#x2e;&#99;&#111;&#109;&#93;&#40;&#x29;">&#x5b;&#x63;&#x68;&#101;&#x6e;&#x67;&#x75;&#x61;&#110;&#99;&#104;&#46;&#x2e;&#46;&#x40;&#x67;&#109;&#x61;&#x69;&#108;&#x2e;&#99;&#111;&#109;&#93;&#40;&#x29;</a></p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>&gt;</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>Nice 大胆预测Linear speedup应该是每个程序员十年后的目标 呵呵</p>
<blockquote>
<p>On 3月23日, 上午10时43分, qiaojie <a href="&#x6d;&#97;&#105;&#x6c;&#116;&#111;&#x3a;&#91;&#x71;&#x69;&#x61;&#111;&#x2e;&#x2e;&#46;&#64;&#103;&#109;&#97;&#x69;&#x6c;&#46;&#99;&#x6f;&#109;&#93;&#40;&#41;">&#91;&#x71;&#x69;&#x61;&#111;&#x2e;&#x2e;&#46;&#64;&#103;&#109;&#97;&#x69;&#x6c;&#46;&#99;&#x6f;&#109;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>目前正在写的是一个软件渲染器，采用了光栅化和光线跟踪混合算法，渲染算法已经完全并行化了，
在4核系统上基本可以达到线性加速比，更多核的系统暂时还没测试。kd-tree的构造暂时还没有并
行化，以后有空了再研究。</p>
<p>2010/3/23 Guancheng Chen <a href="&#109;&#x61;&#105;&#x6c;&#x74;&#x6f;&#58;&#x5b;&#99;&#104;&#101;&#x6e;&#103;&#x75;&#x61;&#110;&#x63;&#x68;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#97;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#40;&#41;">&#x5b;&#99;&#104;&#101;&#x6e;&#103;&#x75;&#x61;&#110;&#x63;&#x68;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#97;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#40;&#41;</a></p>
<blockquote>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？</p>
<p>On 3月23日, 上午9时15分, qiaojie <a href="&#109;&#x61;&#x69;&#x6c;&#116;&#111;&#58;&#x5b;&#113;&#105;&#x61;&#111;&#x2e;&#46;&#x2e;&#64;&#103;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#41;">&#x5b;&#113;&#105;&#x61;&#111;&#x2e;&#46;&#x2e;&#64;&#103;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1)
=
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank
Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？</p>
</blockquote>
<p> To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> 机械唯物主义 : linjunhalida <img src="" alt=""></p>
</blockquote>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-25</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>一个谬误：刺激需求
产能=消费，产能才是主动力。技术成长是随着产能成长而起来的。
而产能多的结果就是满足了需求，造成一种需求带来技术进步的假像。
而技术和产能之间的关系又错综复杂。。
2010/3/25 qiaojie <a href="&#109;&#x61;&#x69;&#108;&#x74;&#x6f;&#x3a;&#x5b;&#x71;&#105;&#x61;&#46;&#x2e;&#x2e;&#x40;&#103;&#109;&#97;&#105;&#x6c;&#46;&#99;&#x6f;&#109;&#93;&#x28;&#x29;">&#x5b;&#x71;&#105;&#x61;&#46;&#x2e;&#x2e;&#x40;&#103;&#109;&#97;&#105;&#x6c;&#46;&#99;&#x6f;&#109;&#93;&#x28;&#x29;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>3D游戏就是一类杀手应用，由此支撑起了一个庞大的GPU市场，芯片行业的研发成本是很高的，没有一个庞大的市场是做不起来的。目前的消费者对于多核系统显然还没有强烈的需求，因为应用跟不上，i7发布快2年了还没进入主流市场，这种情况延续下去的话摩尔定律将因此失效。不过我相信杀手级应用总会出现的，这可能要硬件性能突破一个临界点，比方说目前GPU的性能再提升一个数量级的话，光线跟踪算法就可以提供流畅的接近CG的画质，倒是此类应用便会流行开来。</p>
<p>2010/3/25 Guancheng Chen <a href="&#x6d;&#x61;&#x69;&#x6c;&#116;&#111;&#58;&#x5b;&#99;&#x68;&#x65;&#110;&#103;&#117;&#46;&#x2e;&#x2e;&#x40;&#x67;&#109;&#97;&#105;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#41;">&#x5b;&#99;&#x68;&#x65;&#110;&#103;&#117;&#46;&#x2e;&#x2e;&#x40;&#x67;&#109;&#97;&#105;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#41;</a></p>
<p>杀手应用一般来说是指什么样的应用呢？比如用户群特别大的网游？还是那些专有的科学计算用的软件？
On 3月24日, 下午12时36分, qiaojie <a href="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#x6f;&#58;&#x5b;&#113;&#x69;&#97;&#111;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#97;&#105;&#x6c;&#46;&#x63;&#x6f;&#109;&#x5d;&#x28;&#x29;">&#x5b;&#113;&#x69;&#97;&#111;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#97;&#105;&#x6c;&#46;&#x63;&#x6f;&#109;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>并行计算本来就是曲高和寡的东西，就跟3D渲染一样，能开发引擎的毕竟只是小部分人，大多数人在引擎的基础上做应用。关键在于是否有杀手应用，只要有大量的需求 ，自然会有人去做开发。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#109;&#97;&#x69;&#108;&#116;&#x6f;&#58;&#x5b;&#104;&#111;&#110;&#103;&#122;&#x68;&#x61;&#x6e;&#103;&#x2e;&#46;&#46;&#x2e;&#64;&#103;&#x6d;&#x61;&#105;&#108;&#x2e;&#99;&#x6f;&#109;&#x5d;&#40;&#x29;">&#x5b;&#104;&#111;&#110;&#103;&#122;&#x68;&#x61;&#x6e;&#103;&#x2e;&#46;&#46;&#x2e;&#64;&#103;&#x6d;&#x61;&#105;&#108;&#x2e;&#99;&#x6f;&#109;&#x5d;&#40;&#x29;</a></p>
<blockquote>
<p>异构平台从网络处理器算起已经快10年了，现在情况仍然不明朗。就我看到的，异构平台要想高效，就必须向程序员暴露非常多的硬件细节，这必然导致编程的复杂性。 曲高和寡，要想渗透到应用程序这一块，我觉得很难。</p>
<p>2010/3/24 qiaojie <a href="&#109;&#x61;&#x69;&#108;&#x74;&#111;&#x3a;&#x5b;&#x71;&#x69;&#x61;&#x6f;&#46;&#x2e;&#x2e;&#64;&#103;&#x6d;&#97;&#x69;&#108;&#46;&#x63;&#x6f;&#109;&#93;&#40;&#41;">&#x5b;&#x71;&#x69;&#x61;&#x6f;&#46;&#x2e;&#x2e;&#64;&#103;&#x6d;&#97;&#x69;&#108;&#46;&#x63;&#x6f;&#109;&#93;&#40;&#41;</a></p>
<blockquote>
<p>说的没错，cell已经成了先烈了。不过这不代表异构的方向不对，CUDA，OpenCL也都是异构平台，以后我们会越来越习惯异构平台的。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#109;&#x61;&#105;&#x6c;&#116;&#x6f;&#x3a;&#x5b;&#104;&#111;&#110;&#103;&#x7a;&#x68;&#97;&#x6e;&#x67;&#46;&#46;&#46;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#105;&#108;&#x2e;&#x63;&#111;&#109;&#93;&#40;&#x29;">&#x5b;&#104;&#111;&#110;&#103;&#x7a;&#x68;&#97;&#x6e;&#x67;&#46;&#46;&#46;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#105;&#108;&#x2e;&#x63;&#111;&#109;&#93;&#40;&#x29;</a></p>
<p>异构平台如果编程复杂度降不下来的话很难流行起来。cell已经死了...</p>
<blockquote>
<p> 2010/3/24 qiaojie <a href="&#109;&#x61;&#x69;&#x6c;&#116;&#x6f;&#58;&#x5b;&#x71;&#x69;&#x61;&#111;&#x2e;&#46;&#x2e;&#64;&#x67;&#109;&#x61;&#x69;&#108;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#40;&#41;">&#x5b;&#x71;&#x69;&#x61;&#111;&#x2e;&#46;&#x2e;&#64;&#x67;&#109;&#x61;&#x69;&#108;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#40;&#41;</a></p>
<blockquote>
<p>不是所有的程序都需要并行化的，能用串行化解决的问题没必要并行，所以即使将来many-core系统成为主流，大部分程序员也没必要去搞并行计算。
  我觉得未来的主流应该是类似cell这样一颗全功能核心带众多协处理核心的异构系统，这样才能达到最优的 性能/核心面积比。</p>
<p>2010/3/24 Guancheng Chen <a href="&#109;&#97;&#105;&#x6c;&#x74;&#x6f;&#58;&#91;&#99;&#x68;&#x65;&#110;&#x67;&#117;&#x61;&#x6e;&#99;&#x68;&#x2e;&#x2e;&#46;&#x40;&#x67;&#109;&#x61;&#105;&#108;&#46;&#99;&#111;&#x6d;&#93;&#x28;&#x29;">&#91;&#99;&#x68;&#x65;&#110;&#x67;&#117;&#x61;&#x6e;&#99;&#x68;&#x2e;&#x2e;&#46;&#x40;&#x67;&#109;&#x61;&#105;&#108;&#46;&#99;&#111;&#x6d;&#93;&#x28;&#x29;</a></p>
<p>Nice 大胆预测Linear speedup应该是每个程序员十年后的目标 呵呵</p>
<blockquote>
<p>On 3月23日, 上午10时43分, qiaojie <a href="&#x6d;&#x61;&#105;&#x6c;&#x74;&#111;&#58;&#91;&#113;&#105;&#97;&#111;&#46;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#105;&#108;&#46;&#x63;&#111;&#109;&#x5d;&#40;&#41;">&#91;&#113;&#105;&#97;&#111;&#46;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#105;&#108;&#46;&#x63;&#111;&#109;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>目前正在写的是一个软件渲染器，采用了光栅化和光线跟踪混合算法，渲染算法已经完全并行化了，
在4核系统上基本可以达到线性加速比，更多核的系统暂时还没测试。kd-tree的构造暂时还没有并
行化，以后有空了再研究。</p>
<p>2010/3/23 Guancheng Chen <a href="&#109;&#97;&#x69;&#x6c;&#116;&#111;&#58;&#x5b;&#99;&#104;&#x65;&#x6e;&#103;&#117;&#x61;&#110;&#x63;&#104;&#x2e;&#x2e;&#46;&#x40;&#x67;&#109;&#97;&#105;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#x29;">&#x5b;&#99;&#104;&#x65;&#x6e;&#103;&#117;&#x61;&#110;&#x63;&#104;&#x2e;&#x2e;&#46;&#x40;&#x67;&#109;&#97;&#105;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#x29;</a></p>
<blockquote>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？</p>
<p>On 3月23日, 上午9时15分, qiaojie <a href="&#109;&#97;&#105;&#x6c;&#x74;&#x6f;&#x3a;&#91;&#113;&#105;&#97;&#111;&#x2e;&#46;&#46;&#x40;&#x67;&#109;&#x61;&#105;&#108;&#x2e;&#99;&#111;&#x6d;&#93;&#40;&#x29;">&#91;&#113;&#105;&#97;&#111;&#x2e;&#46;&#46;&#x40;&#x67;&#109;&#x61;&#105;&#108;&#x2e;&#99;&#111;&#x6d;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1)
=
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank
Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？</p>
</blockquote>
<p> To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a></p>
</blockquote>
</blockquote>
<p><img src="" alt=""> qiaojie <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-25</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>如果产能=消费的话就没有产能过剩这一说了。</p>
<p>2010/3/25 机械唯物主义 : linjunhalida <a href="&#x6d;&#97;&#105;&#108;&#116;&#111;&#58;&#91;&#108;&#x69;&#x6e;&#106;&#x75;&#110;&#x2e;&#46;&#x2e;&#x40;&#103;&#x6d;&#97;&#105;&#x6c;&#46;&#99;&#x6f;&#x6d;&#93;&#x28;&#x29;">&#91;&#108;&#x69;&#x6e;&#106;&#x75;&#110;&#x2e;&#46;&#x2e;&#x40;&#103;&#x6d;&#97;&#105;&#x6c;&#46;&#99;&#x6f;&#x6d;&#93;&#x28;&#x29;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>一个谬误：刺激需求
产能=消费，产能才是主动力。技术成长是随着产能成长而起来的。
而产能多的结果就是满足了需求，造成一种需求带来技术进步的假像。
而技术和产能之间的关系又错综复杂。。
2010/3/25 qiaojie <a href="&#x6d;&#97;&#x69;&#108;&#x74;&#111;&#x3a;&#91;&#x71;&#x69;&#x61;&#x2e;&#46;&#x2e;&#x40;&#x67;&#109;&#97;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#109;&#x5d;&#40;&#x29;">&#91;&#x71;&#x69;&#x61;&#x2e;&#46;&#x2e;&#x40;&#x67;&#109;&#97;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#109;&#x5d;&#40;&#x29;</a></p>
<p>3D游戏就是一类杀手应用，由此支撑起了一个庞大的GPU市场，芯片行业的研发成本是很高的，没有一个庞大的市场是做不起来的。目前的消费者对于多核系统显然还没有强烈的需求，因为应用跟不上，i7发布快2年了还没进入主流市场，这种情况延续下去的话摩尔定律将因此失效。不过我相信杀手级应用总会出现的，这可能要硬件性能突破一个临界点，比方说目前GPU的性能再提升一个数量级的话，光线跟踪算法就可以提供流畅的接近CG的画质，倒是此类应用便会流行开来。</p>
<p>2010/3/25 Guancheng Chen <a href="&#109;&#97;&#105;&#108;&#116;&#x6f;&#x3a;&#91;&#99;&#104;&#101;&#110;&#103;&#x75;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#109;&#97;&#105;&#108;&#x2e;&#99;&#111;&#x6d;&#93;&#x28;&#x29;">&#91;&#99;&#104;&#101;&#110;&#103;&#x75;&#x2e;&#x2e;&#x2e;&#x40;&#x67;&#109;&#97;&#105;&#108;&#x2e;&#99;&#111;&#x6d;&#93;&#x28;&#x29;</a></p>
<p>杀手应用一般来说是指什么样的应用呢？比如用户群特别大的网游？还是那些专有的科学计算用的软件？
On 3月24日, 下午12时36分, qiaojie <a href="&#109;&#x61;&#x69;&#108;&#x74;&#111;&#x3a;&#91;&#113;&#x69;&#97;&#111;&#x2e;&#x2e;&#x2e;&#64;&#103;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#99;&#111;&#109;&#93;&#40;&#41;">&#91;&#113;&#x69;&#97;&#111;&#x2e;&#x2e;&#x2e;&#64;&#103;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#99;&#111;&#109;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>并行计算本来就是曲高和寡的东西，就跟3D渲染一样，能开发引擎的毕竟只是小部分人，大多数人在引擎的基础上做应用。关键在于是否有杀手应用，只要有大量的需求 ，自然会有人去做开发。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#x6d;&#x61;&#105;&#x6c;&#116;&#x6f;&#x3a;&#x5b;&#104;&#111;&#110;&#x67;&#122;&#x68;&#97;&#110;&#103;&#x2e;&#x2e;&#x2e;&#x2e;&#64;&#103;&#x6d;&#97;&#105;&#x6c;&#x2e;&#x63;&#111;&#109;&#93;&#40;&#x29;">&#x5b;&#104;&#111;&#110;&#x67;&#122;&#x68;&#97;&#110;&#103;&#x2e;&#x2e;&#x2e;&#x2e;&#64;&#103;&#x6d;&#97;&#105;&#x6c;&#x2e;&#x63;&#111;&#109;&#93;&#40;&#x29;</a></p>
<blockquote>
<p>异构平台从网络处理器算起已经快10年了，现在情况仍然不明朗。就我看到的，异构平台要想高效，就必须向程序员暴露非常多的硬件细节，这必然导致编程的复杂性。 曲高和寡，要想渗透到应用程序这一块，我觉得很难。</p>
<p>2010/3/24 qiaojie <a href="&#109;&#x61;&#x69;&#x6c;&#116;&#111;&#58;&#x5b;&#113;&#105;&#97;&#x6f;&#46;&#46;&#x2e;&#64;&#x67;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#x6f;&#109;&#93;&#40;&#41;">&#x5b;&#113;&#105;&#97;&#x6f;&#46;&#46;&#x2e;&#64;&#x67;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#x6f;&#109;&#93;&#40;&#41;</a></p>
<blockquote>
<p>说的没错，cell已经成了先烈了。不过这不代表异构的方向不对，CUDA，OpenCL也都是异构平台，以后我们会越来越习惯异构平台的。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#x6d;&#x61;&#105;&#x6c;&#x74;&#x6f;&#58;&#91;&#x68;&#111;&#x6e;&#103;&#x7a;&#x68;&#x61;&#110;&#103;&#x2e;&#46;&#46;&#x2e;&#x40;&#x67;&#109;&#x61;&#x69;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#41;">&#91;&#x68;&#111;&#x6e;&#103;&#x7a;&#x68;&#x61;&#110;&#103;&#x2e;&#46;&#46;&#x2e;&#x40;&#x67;&#109;&#x61;&#x69;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#41;</a></p>
<p>异构平台如果编程复杂度降不下来的话很难流行起来。cell已经死了...</p>
<blockquote>
<p> 2010/3/24 qiaojie <a href="&#x6d;&#x61;&#x69;&#108;&#x74;&#111;&#58;&#x5b;&#x71;&#x69;&#97;&#111;&#x2e;&#46;&#46;&#64;&#103;&#x6d;&#97;&#105;&#108;&#46;&#x63;&#x6f;&#109;&#x5d;&#x28;&#x29;">&#x5b;&#x71;&#x69;&#97;&#111;&#x2e;&#46;&#46;&#64;&#103;&#x6d;&#97;&#105;&#108;&#46;&#x63;&#x6f;&#109;&#x5d;&#x28;&#x29;</a></p>
<blockquote>
<p>不是所有的程序都需要并行化的，能用串行化解决的问题没必要并行，所以即使将来many-core系统成为主流，大部分程序员也没必要去搞并行计算。
  我觉得未来的主流应该是类似cell这样一颗全功能核心带众多协处理核心的异构系统，这样才能达到最优的 性能/核心面积比。</p>
<p>2010/3/24 Guancheng Chen <a href="&#x6d;&#97;&#x69;&#x6c;&#x74;&#111;&#x3a;&#x5b;&#99;&#104;&#x65;&#110;&#x67;&#x75;&#97;&#110;&#x63;&#104;&#x2e;&#x2e;&#46;&#x40;&#x67;&#109;&#97;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#x28;&#x29;">&#x5b;&#99;&#104;&#x65;&#110;&#x67;&#x75;&#97;&#110;&#x63;&#104;&#x2e;&#x2e;&#46;&#x40;&#x67;&#109;&#97;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#x28;&#x29;</a></p>
<p>Nice 大胆预测Linear speedup应该是每个程序员十年后的目标 呵呵</p>
<blockquote>
<p>On 3月23日, 上午10时43分, qiaojie <a href="&#x6d;&#97;&#x69;&#108;&#x74;&#111;&#x3a;&#91;&#113;&#x69;&#97;&#111;&#x2e;&#x2e;&#46;&#x40;&#103;&#109;&#97;&#x69;&#x6c;&#46;&#99;&#111;&#109;&#x5d;&#x28;&#x29;">&#91;&#113;&#x69;&#97;&#111;&#x2e;&#x2e;&#46;&#x40;&#103;&#109;&#97;&#x69;&#x6c;&#46;&#99;&#111;&#109;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>目前正在写的是一个软件渲染器，采用了光栅化和光线跟踪混合算法，渲染算法已经完全并行化了，
在4核系统上基本可以达到线性加速比，更多核的系统暂时还没测试。kd-tree的构造暂时还没有并
行化，以后有空了再研究。</p>
<p>2010/3/23 Guancheng Chen <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#x5b;&#99;&#x68;&#x65;&#x6e;&#103;&#117;&#97;&#x6e;&#99;&#x68;&#x2e;&#x2e;&#46;&#x40;&#103;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#109;&#x5d;&#x28;&#x29;">&#x5b;&#99;&#x68;&#x65;&#x6e;&#103;&#117;&#97;&#x6e;&#99;&#x68;&#x2e;&#x2e;&#46;&#x40;&#103;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#109;&#x5d;&#x28;&#x29;</a></p>
<blockquote>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？</p>
<p>On 3月23日, 上午9时15分, qiaojie <a href="&#x6d;&#x61;&#105;&#x6c;&#116;&#x6f;&#x3a;&#91;&#113;&#105;&#x61;&#x6f;&#46;&#46;&#46;&#x40;&#103;&#109;&#97;&#x69;&#108;&#46;&#x63;&#111;&#109;&#x5d;&#40;&#41;">&#91;&#113;&#105;&#x61;&#x6f;&#46;&#46;&#46;&#x40;&#103;&#109;&#97;&#x69;&#108;&#46;&#x63;&#111;&#109;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1)
=
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank
Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？</p>
</blockquote>
<p> To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> 机械唯物主义 : linjunhalida <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-25</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>产能过剩的说法本来就不对。
产出的东西没有价值，这样的活动就不能说是生产。
比如我这个程序员，花了1周写了一个垃圾程序，然后被开除了。
然后1个月闲着，这是我产能过剩吗？
而闲着的原因是政府给我失业金，我就不需要工作闲起来了。。。
2010/3/25 qiaojie <a href="&#x6d;&#97;&#105;&#x6c;&#x74;&#111;&#x3a;&#x5b;&#113;&#105;&#x61;&#46;&#x2e;&#x2e;&#64;&#x67;&#109;&#x61;&#x69;&#x6c;&#46;&#99;&#x6f;&#109;&#x5d;&#40;&#x29;">&#x5b;&#113;&#105;&#x61;&#46;&#x2e;&#x2e;&#64;&#x67;&#109;&#x61;&#x69;&#x6c;&#46;&#99;&#x6f;&#109;&#x5d;&#40;&#x29;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>如果产能=消费的话就没有产能过剩这一说了。</p>
<p>2010/3/25 机械唯物主义 : linjunhalida <a href="&#x6d;&#x61;&#105;&#108;&#116;&#x6f;&#58;&#91;&#x6c;&#x69;&#x6e;&#106;&#x75;&#110;&#46;&#x2e;&#x2e;&#64;&#x67;&#109;&#97;&#105;&#108;&#46;&#x63;&#x6f;&#109;&#93;&#x28;&#41;">&#91;&#x6c;&#x69;&#x6e;&#106;&#x75;&#110;&#46;&#x2e;&#x2e;&#64;&#x67;&#109;&#97;&#105;&#108;&#46;&#x63;&#x6f;&#109;&#93;&#x28;&#41;</a></p>
<p>一个谬误：刺激需求
产能=消费，产能才是主动力。技术成长是随着产能成长而起来的。
而产能多的结果就是满足了需求，造成一种需求带来技术进步的假像。
而技术和产能之间的关系又错综复杂。。
2010/3/25 qiaojie <a href="&#109;&#97;&#x69;&#108;&#x74;&#111;&#58;&#91;&#113;&#105;&#97;&#x2e;&#x2e;&#x2e;&#64;&#103;&#x6d;&#97;&#x69;&#x6c;&#46;&#99;&#x6f;&#x6d;&#x5d;&#40;&#x29;">&#91;&#113;&#105;&#97;&#x2e;&#x2e;&#x2e;&#64;&#103;&#x6d;&#97;&#x69;&#x6c;&#46;&#99;&#x6f;&#x6d;&#x5d;&#40;&#x29;</a></p>
<p>3D游戏就是一类杀手应用，由此支撑起了一个庞大的GPU市场，芯片行业的研发成本是很高的，没有一个庞大的市场是做不起来的。目前的消费者对于多核系统显然还没有强烈的需求，因为应用跟不上，i7发布快2年了还没进入主流市场，这种情况延续下去的话摩尔定律将因此失效。不过我相信杀手级应用总会出现的，这可能要硬件性能突破一个临界点，比方说目前GPU的性能再提升一个数量级的话，光线跟踪算法就可以提供流畅的接近CG的画质，倒是此类应用便会流行开来。</p>
<p>2010/3/25 Guancheng Chen <a href="&#109;&#x61;&#105;&#108;&#x74;&#111;&#x3a;&#x5b;&#99;&#104;&#x65;&#x6e;&#x67;&#117;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#x61;&#105;&#x6c;&#46;&#99;&#x6f;&#x6d;&#93;&#x28;&#x29;">&#x5b;&#99;&#104;&#x65;&#x6e;&#x67;&#117;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#x61;&#105;&#x6c;&#46;&#99;&#x6f;&#x6d;&#93;&#x28;&#x29;</a></p>
<p>杀手应用一般来说是指什么样的应用呢？比如用户群特别大的网游？还是那些专有的科学计算用的软件？
On 3月24日, 下午12时36分, qiaojie <a href="&#109;&#x61;&#x69;&#108;&#x74;&#x6f;&#58;&#91;&#x71;&#x69;&#x61;&#x6f;&#46;&#46;&#46;&#x40;&#103;&#x6d;&#97;&#105;&#108;&#46;&#99;&#x6f;&#x6d;&#93;&#40;&#x29;">&#91;&#x71;&#x69;&#x61;&#x6f;&#46;&#46;&#46;&#x40;&#103;&#x6d;&#97;&#105;&#108;&#46;&#99;&#x6f;&#x6d;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>并行计算本来就是曲高和寡的东西，就跟3D渲染一样，能开发引擎的毕竟只是小部分人，大多数人在引擎的基础上做应用。关键在于是否有杀手应用，只要有大量的需求 ，自然会有人去做开发。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#x6d;&#97;&#105;&#x6c;&#x74;&#x6f;&#x3a;&#91;&#x68;&#x6f;&#x6e;&#x67;&#x7a;&#x68;&#x61;&#110;&#103;&#x2e;&#46;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#97;&#105;&#x6c;&#x2e;&#99;&#x6f;&#109;&#x5d;&#x28;&#41;">&#91;&#x68;&#x6f;&#x6e;&#x67;&#x7a;&#x68;&#x61;&#110;&#103;&#x2e;&#46;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#97;&#105;&#x6c;&#x2e;&#99;&#x6f;&#109;&#x5d;&#x28;&#41;</a></p>
<blockquote>
<p>异构平台从网络处理器算起已经快10年了，现在情况仍然不明朗。就我看到的，异构平台要想高效，就必须向程序员暴露非常多的硬件细节，这必然导致编程的复杂性。 曲高和寡，要想渗透到应用程序这一块，我觉得很难。</p>
<p>2010/3/24 qiaojie <a href="&#109;&#x61;&#x69;&#108;&#x74;&#x6f;&#x3a;&#x5b;&#113;&#105;&#97;&#x6f;&#46;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#x61;&#105;&#108;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#41;">&#x5b;&#113;&#105;&#97;&#x6f;&#46;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#x61;&#105;&#108;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#41;</a></p>
<blockquote>
<p>说的没错，cell已经成了先烈了。不过这不代表异构的方向不对，CUDA，OpenCL也都是异构平台，以后我们会越来越习惯异构平台的。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#109;&#97;&#105;&#x6c;&#x74;&#111;&#x3a;&#x5b;&#x68;&#111;&#110;&#103;&#x7a;&#x68;&#x61;&#x6e;&#x67;&#x2e;&#x2e;&#x2e;&#46;&#x40;&#x67;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#99;&#111;&#109;&#93;&#40;&#41;">&#x5b;&#x68;&#111;&#110;&#103;&#x7a;&#x68;&#x61;&#x6e;&#x67;&#x2e;&#x2e;&#x2e;&#46;&#x40;&#x67;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#99;&#111;&#109;&#93;&#40;&#41;</a></p>
<p>异构平台如果编程复杂度降不下来的话很难流行起来。cell已经死了...</p>
<blockquote>
<p> 2010/3/24 qiaojie <a href="&#109;&#97;&#x69;&#108;&#116;&#111;&#x3a;&#91;&#113;&#105;&#97;&#x6f;&#46;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#105;&#x6c;&#46;&#x63;&#x6f;&#109;&#93;&#40;&#41;">&#91;&#113;&#105;&#97;&#x6f;&#46;&#x2e;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#105;&#x6c;&#46;&#x63;&#x6f;&#109;&#93;&#40;&#41;</a></p>
<blockquote>
<p>不是所有的程序都需要并行化的，能用串行化解决的问题没必要并行，所以即使将来many-core系统成为主流，大部分程序员也没必要去搞并行计算。
  我觉得未来的主流应该是类似cell这样一颗全功能核心带众多协处理核心的异构系统，这样才能达到最优的 性能/核心面积比。</p>
<p>2010/3/24 Guancheng Chen <a href="&#x6d;&#x61;&#x69;&#x6c;&#116;&#111;&#58;&#x5b;&#99;&#104;&#x65;&#x6e;&#x67;&#117;&#x61;&#x6e;&#x63;&#104;&#46;&#46;&#x2e;&#64;&#x67;&#109;&#x61;&#105;&#108;&#x2e;&#x63;&#x6f;&#109;&#93;&#x28;&#x29;">&#x5b;&#99;&#104;&#x65;&#x6e;&#x67;&#117;&#x61;&#x6e;&#x63;&#104;&#46;&#46;&#x2e;&#64;&#x67;&#109;&#x61;&#105;&#108;&#x2e;&#x63;&#x6f;&#109;&#93;&#x28;&#x29;</a></p>
<p>Nice 大胆预测Linear speedup应该是每个程序员十年后的目标 呵呵</p>
<blockquote>
<p>On 3月23日, 上午10时43分, qiaojie <a href="&#109;&#x61;&#105;&#x6c;&#116;&#111;&#x3a;&#x5b;&#x71;&#105;&#x61;&#x6f;&#46;&#46;&#46;&#x40;&#x67;&#109;&#97;&#x69;&#108;&#x2e;&#99;&#x6f;&#x6d;&#93;&#x28;&#x29;">&#x5b;&#x71;&#105;&#x61;&#x6f;&#46;&#46;&#46;&#x40;&#x67;&#109;&#97;&#x69;&#108;&#x2e;&#99;&#x6f;&#x6d;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>目前正在写的是一个软件渲染器，采用了光栅化和光线跟踪混合算法，渲染算法已经完全并行化了，
在4核系统上基本可以达到线性加速比，更多核的系统暂时还没测试。kd-tree的构造暂时还没有并
行化，以后有空了再研究。</p>
<p>2010/3/23 Guancheng Chen <a href="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#x6f;&#x3a;&#x5b;&#99;&#x68;&#101;&#110;&#103;&#117;&#x61;&#x6e;&#x63;&#104;&#x2e;&#x2e;&#46;&#x40;&#103;&#x6d;&#x61;&#x69;&#108;&#x2e;&#99;&#111;&#x6d;&#x5d;&#40;&#41;">&#x5b;&#99;&#x68;&#101;&#110;&#103;&#117;&#x61;&#x6e;&#x63;&#104;&#x2e;&#x2e;&#46;&#x40;&#103;&#x6d;&#x61;&#x69;&#108;&#x2e;&#99;&#111;&#x6d;&#x5d;&#40;&#41;</a></p>
<blockquote>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？</p>
<p>On 3月23日, 上午9时15分, qiaojie <a href="&#109;&#97;&#105;&#108;&#x74;&#111;&#x3a;&#91;&#113;&#x69;&#97;&#111;&#x2e;&#x2e;&#46;&#64;&#103;&#x6d;&#97;&#105;&#x6c;&#46;&#99;&#x6f;&#109;&#x5d;&#40;&#41;">&#91;&#113;&#x69;&#97;&#111;&#x2e;&#x2e;&#46;&#64;&#103;&#x6d;&#97;&#105;&#x6c;&#46;&#99;&#x6f;&#109;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1)
=
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank
Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？</p>
</blockquote>
<p> To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a></p>
<p><img src="" alt=""> 机械唯物主义 : linjunhalida <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-25</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>扯远了。我觉得并行和串行应该是信息处理本质上的2种方式，
在不同的场景下，可以采用不同的方式进行。
重要的是能够“又好又快”地实现需求，以及根据场景，把一个需求进行实现方式的伸缩。
不过看起来这样的工作还是要靠程序员来实现？而体系架构设计者要根据对应问题的本质特性来设计架构？
2010/3/25 机械唯物主义 : linjunhalida <a href="&#109;&#x61;&#x69;&#x6c;&#116;&#x6f;&#x3a;&#x5b;&#x6c;&#x69;&#110;&#x6a;&#x75;&#110;&#46;&#46;&#46;&#x40;&#103;&#x6d;&#x61;&#105;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#x29;">&#x5b;&#x6c;&#x69;&#110;&#x6a;&#x75;&#110;&#46;&#46;&#46;&#x40;&#103;&#x6d;&#x61;&#105;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#x29;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>产能过剩的说法本来就不对。
产出的东西没有价值，这样的活动就不能说是生产。
比如我这个程序员，花了1周写了一个垃圾程序，然后被开除了。
然后1个月闲着，这是我产能过剩吗？
而闲着的原因是政府给我失业金，我就不需要工作闲起来了。。。</p>
<p>2010/3/25 qiaojie <a href="&#109;&#x61;&#105;&#108;&#116;&#x6f;&#x3a;&#x5b;&#113;&#105;&#97;&#x2e;&#46;&#x2e;&#x40;&#103;&#109;&#97;&#105;&#108;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#40;&#41;">&#x5b;&#113;&#105;&#97;&#x2e;&#46;&#x2e;&#x40;&#103;&#109;&#97;&#105;&#108;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#40;&#41;</a>
如果产能=消费的话就没有产能过剩这一说了。</p>
<p>2010/3/25 机械唯物主义 : linjunhalida <a href="&#109;&#x61;&#105;&#108;&#x74;&#x6f;&#58;&#91;&#x6c;&#105;&#x6e;&#x6a;&#117;&#x6e;&#46;&#46;&#x2e;&#x40;&#103;&#109;&#97;&#105;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#93;&#40;&#x29;">&#91;&#x6c;&#105;&#x6e;&#x6a;&#117;&#x6e;&#46;&#46;&#x2e;&#x40;&#103;&#109;&#97;&#105;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#93;&#40;&#x29;</a></p>
<p>一个谬误：刺激需求
产能=消费，产能才是主动力。技术成长是随着产能成长而起来的。
而产能多的结果就是满足了需求，造成一种需求带来技术进步的假像。
而技术和产能之间的关系又错综复杂。。
2010/3/25 qiaojie <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#x3a;&#91;&#113;&#x69;&#x61;&#46;&#46;&#x2e;&#x40;&#103;&#109;&#x61;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#93;&#40;&#x29;">&#91;&#113;&#x69;&#x61;&#46;&#46;&#x2e;&#x40;&#103;&#109;&#x61;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#93;&#40;&#x29;</a></p>
<p>3D游戏就是一类杀手应用，由此支撑起了一个庞大的GPU市场，芯片行业的研发成本是很高的，没有一个庞大的市场是做不起来的。目前的消费者对于多核系统显然还没有强烈的需求，因为应用跟不上，i7发布快2年了还没进入主流市场，这种情况延续下去的话摩尔定律将因此失效。不过我相信杀手级应用总会出现的，这可能要硬件性能突破一个临界点，比方说目前GPU的性能再提升一个数量级的话，光线跟踪算法就可以提供流畅的接近CG的画质，倒是此类应用便会流行开来。</p>
<p>2010/3/25 Guancheng Chen <a href="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#x6f;&#58;&#x5b;&#99;&#104;&#101;&#x6e;&#x67;&#x75;&#x2e;&#46;&#46;&#x40;&#103;&#x6d;&#x61;&#x69;&#108;&#46;&#99;&#x6f;&#109;&#93;&#x28;&#x29;">&#x5b;&#99;&#104;&#101;&#x6e;&#x67;&#x75;&#x2e;&#46;&#46;&#x40;&#103;&#x6d;&#x61;&#x69;&#108;&#46;&#99;&#x6f;&#109;&#93;&#x28;&#x29;</a></p>
<p>杀手应用一般来说是指什么样的应用呢？比如用户群特别大的网游？还是那些专有的科学计算用的软件？
On 3月24日, 下午12时36分, qiaojie <a href="&#109;&#97;&#x69;&#x6c;&#x74;&#x6f;&#x3a;&#91;&#113;&#105;&#97;&#x6f;&#x2e;&#46;&#46;&#x40;&#x67;&#x6d;&#97;&#x69;&#108;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#x28;&#41;">&#91;&#113;&#105;&#97;&#x6f;&#x2e;&#46;&#46;&#x40;&#x67;&#x6d;&#97;&#x69;&#108;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>并行计算本来就是曲高和寡的东西，就跟3D渲染一样，能开发引擎的毕竟只是小部分人，大多数人在引擎的基础上做应用。关键在于是否有杀手应用，只要有大量的需求 ，自然会有人去做开发。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#109;&#97;&#x69;&#x6c;&#116;&#111;&#58;&#x5b;&#x68;&#x6f;&#110;&#103;&#x7a;&#x68;&#97;&#x6e;&#103;&#x2e;&#46;&#46;&#46;&#64;&#x67;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#93;&#40;&#41;">&#x5b;&#x68;&#x6f;&#110;&#103;&#x7a;&#x68;&#97;&#x6e;&#103;&#x2e;&#46;&#46;&#46;&#64;&#x67;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#93;&#40;&#41;</a></p>
<blockquote>
<p>异构平台从网络处理器算起已经快10年了，现在情况仍然不明朗。就我看到的，异构平台要想高效，就必须向程序员暴露非常多的硬件细节，这必然导致编程的复杂性。 曲高和寡，要想渗透到应用程序这一块，我觉得很难。</p>
<p>2010/3/24 qiaojie <a href="&#109;&#97;&#x69;&#108;&#x74;&#111;&#x3a;&#x5b;&#x71;&#105;&#97;&#x6f;&#x2e;&#x2e;&#46;&#64;&#x67;&#x6d;&#97;&#x69;&#108;&#x2e;&#x63;&#111;&#109;&#x5d;&#x28;&#41;">&#x5b;&#x71;&#105;&#97;&#x6f;&#x2e;&#x2e;&#46;&#64;&#x67;&#x6d;&#97;&#x69;&#108;&#x2e;&#x63;&#111;&#109;&#x5d;&#x28;&#41;</a></p>
<blockquote>
<p>说的没错，cell已经成了先烈了。不过这不代表异构的方向不对，CUDA，OpenCL也都是异构平台，以后我们会越来越习惯异构平台的。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#109;&#x61;&#105;&#108;&#116;&#x6f;&#x3a;&#91;&#104;&#x6f;&#110;&#x67;&#x7a;&#x68;&#x61;&#x6e;&#103;&#46;&#x2e;&#x2e;&#x2e;&#64;&#103;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#109;&#x5d;&#40;&#x29;">&#91;&#104;&#x6f;&#110;&#x67;&#x7a;&#x68;&#x61;&#x6e;&#103;&#46;&#x2e;&#x2e;&#x2e;&#64;&#103;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#109;&#x5d;&#40;&#x29;</a></p>
<p>异构平台如果编程复杂度降不下来的话很难流行起来。cell已经死了...</p>
<blockquote>
<p> 2010/3/24 qiaojie <a href="&#109;&#97;&#105;&#108;&#x74;&#111;&#x3a;&#91;&#113;&#105;&#x61;&#x6f;&#46;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#x61;&#x69;&#108;&#46;&#99;&#111;&#109;&#x5d;&#x28;&#41;">&#91;&#113;&#105;&#x61;&#x6f;&#46;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#x61;&#x69;&#108;&#46;&#99;&#111;&#109;&#x5d;&#x28;&#41;</a></p>
<blockquote>
<p>不是所有的程序都需要并行化的，能用串行化解决的问题没必要并行，所以即使将来many-core系统成为主流，大部分程序员也没必要去搞并行计算。
  我觉得未来的主流应该是类似cell这样一颗全功能核心带众多协处理核心的异构系统，这样才能达到最优的 性能/核心面积比。</p>
<p>2010/3/24 Guancheng Chen <a href="&#109;&#x61;&#105;&#108;&#116;&#111;&#58;&#91;&#99;&#104;&#x65;&#x6e;&#x67;&#117;&#x61;&#x6e;&#99;&#x68;&#46;&#46;&#x2e;&#64;&#103;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#111;&#x6d;&#93;&#40;&#x29;">&#91;&#99;&#104;&#x65;&#x6e;&#x67;&#117;&#x61;&#x6e;&#99;&#x68;&#46;&#46;&#x2e;&#64;&#103;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#111;&#x6d;&#93;&#40;&#x29;</a></p>
<p>Nice 大胆预测Linear speedup应该是每个程序员十年后的目标 呵呵</p>
<blockquote>
<p>On 3月23日, 上午10时43分, qiaojie <a href="&#109;&#x61;&#105;&#x6c;&#x74;&#111;&#58;&#x5b;&#113;&#105;&#x61;&#111;&#x2e;&#46;&#x2e;&#x40;&#103;&#x6d;&#97;&#105;&#x6c;&#x2e;&#x63;&#111;&#109;&#x5d;&#40;&#41;">&#x5b;&#113;&#105;&#x61;&#111;&#x2e;&#46;&#x2e;&#x40;&#103;&#x6d;&#97;&#105;&#x6c;&#x2e;&#x63;&#111;&#109;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>目前正在写的是一个软件渲染器，采用了光栅化和光线跟踪混合算法，渲染算法已经完全并行化了，
在4核系统上基本可以达到线性加速比，更多核的系统暂时还没测试。kd-tree的构造暂时还没有并
行化，以后有空了再研究。</p>
<p>2010/3/23 Guancheng Chen <a href="&#109;&#97;&#x69;&#108;&#116;&#x6f;&#x3a;&#x5b;&#99;&#104;&#x65;&#x6e;&#x67;&#117;&#x61;&#x6e;&#99;&#104;&#x2e;&#46;&#46;&#64;&#x67;&#x6d;&#97;&#105;&#108;&#46;&#99;&#111;&#109;&#93;&#x28;&#x29;">&#x5b;&#99;&#104;&#x65;&#x6e;&#x67;&#117;&#x61;&#x6e;&#99;&#104;&#x2e;&#46;&#46;&#64;&#x67;&#x6d;&#97;&#105;&#108;&#46;&#99;&#111;&#109;&#93;&#x28;&#x29;</a></p>
<blockquote>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？</p>
<p>On 3月23日, 上午9时15分, qiaojie <a href="&#x6d;&#97;&#x69;&#x6c;&#x74;&#111;&#x3a;&#x5b;&#113;&#x69;&#97;&#111;&#46;&#46;&#x2e;&#x40;&#103;&#109;&#97;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#93;&#40;&#x29;">&#x5b;&#113;&#x69;&#97;&#111;&#46;&#46;&#x2e;&#x40;&#103;&#109;&#97;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1)
=
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank
Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？</p>
</blockquote>
<p> To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> qiaojie <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-25</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>什么叫产能过剩？假设全世界每年消费10000亿斤粮食，结果今年收成好，生产了15000亿斤，</p>
<p>那多出来的5000亿斤无法被市场消化掉，就是产能过剩。那5000亿斤没价值，是垃圾？生产那
5000亿斤的农民是闲的蛋疼没事干？靠政府失业金养？</p>
<p>2010/3/25 机械唯物主义 : linjunhalida <a href="&#109;&#x61;&#x69;&#x6c;&#x74;&#111;&#58;&#91;&#108;&#105;&#x6e;&#x6a;&#117;&#110;&#46;&#x2e;&#46;&#x40;&#103;&#109;&#x61;&#105;&#108;&#46;&#x63;&#x6f;&#109;&#93;&#x28;&#41;">&#91;&#108;&#105;&#x6e;&#x6a;&#117;&#110;&#46;&#x2e;&#46;&#x40;&#103;&#109;&#x61;&#105;&#108;&#46;&#x63;&#x6f;&#109;&#93;&#x28;&#41;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>产能过剩的说法本来就不对。
产出的东西没有价值，这样的活动就不能说是生产。
比如我这个程序员，花了1周写了一个垃圾程序，然后被开除了。
然后1个月闲着，这是我产能过剩吗？
而闲着的原因是政府给我失业金，我就不需要工作闲起来了。。。</p>
<p>2010/3/25 qiaojie <a href="&#109;&#x61;&#105;&#x6c;&#116;&#111;&#58;&#91;&#113;&#x69;&#x61;&#x2e;&#46;&#46;&#64;&#x67;&#109;&#x61;&#105;&#108;&#x2e;&#99;&#x6f;&#109;&#93;&#x28;&#x29;">&#91;&#113;&#x69;&#x61;&#x2e;&#46;&#46;&#64;&#x67;&#109;&#x61;&#105;&#108;&#x2e;&#99;&#x6f;&#109;&#93;&#x28;&#x29;</a>
如果产能=消费的话就没有产能过剩这一说了。</p>
<p>2010/3/25 机械唯物主义 : linjunhalida <a href="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#111;&#x3a;&#91;&#x6c;&#105;&#x6e;&#x6a;&#x75;&#110;&#46;&#x2e;&#46;&#x40;&#103;&#109;&#x61;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#41;">&#91;&#x6c;&#105;&#x6e;&#x6a;&#x75;&#110;&#46;&#x2e;&#46;&#x40;&#103;&#109;&#x61;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#41;</a></p>
<p>一个谬误：刺激需求
产能=消费，产能才是主动力。技术成长是随着产能成长而起来的。
而产能多的结果就是满足了需求，造成一种需求带来技术进步的假像。
而技术和产能之间的关系又错综复杂。。
2010/3/25 qiaojie <a href="&#109;&#97;&#105;&#108;&#116;&#x6f;&#58;&#91;&#x71;&#105;&#97;&#x2e;&#46;&#46;&#x40;&#x67;&#109;&#x61;&#x69;&#108;&#x2e;&#99;&#111;&#x6d;&#93;&#x28;&#41;">&#91;&#x71;&#105;&#97;&#x2e;&#46;&#46;&#x40;&#x67;&#109;&#x61;&#x69;&#108;&#x2e;&#99;&#111;&#x6d;&#93;&#x28;&#41;</a></p>
<p>3D游戏就是一类杀手应用，由此支撑起了一个庞大的GPU市场，芯片行业的研发成本是很高的，没有一个庞大的市场是做不起来的。目前的消费者对于多核系统显然还没有强烈的需求，因为应用跟不上，i7发布快2年了还没进入主流市场，这种情况延续下去的话摩尔定律将因此失效。不过我相信杀手级应用总会出现的，这可能要硬件性能突破一个临界点，比方说目前GPU的性能再提升一个数量级的话，光线跟踪算法就可以提供流畅的接近CG的画质，倒是此类应用便会流行开来。</p>
<p>2010/3/25 Guancheng Chen <a href="&#109;&#x61;&#x69;&#108;&#x74;&#x6f;&#x3a;&#x5b;&#x63;&#x68;&#x65;&#110;&#x67;&#x75;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#109;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#40;&#41;">&#x5b;&#x63;&#x68;&#x65;&#110;&#x67;&#x75;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#109;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#40;&#41;</a></p>
<p>杀手应用一般来说是指什么样的应用呢？比如用户群特别大的网游？还是那些专有的科学计算用的软件？
On 3月24日, 下午12时36分, qiaojie <a href="&#x6d;&#x61;&#x69;&#108;&#x74;&#x6f;&#x3a;&#x5b;&#113;&#105;&#x61;&#x6f;&#46;&#x2e;&#46;&#64;&#x67;&#x6d;&#x61;&#105;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#x28;&#41;">&#x5b;&#113;&#105;&#x61;&#x6f;&#46;&#x2e;&#46;&#64;&#x67;&#x6d;&#x61;&#105;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>并行计算本来就是曲高和寡的东西，就跟3D渲染一样，能开发引擎的毕竟只是小部分人，大多数人在引擎的基础上做应用。关键在于是否有杀手应用，只要有大量的需求 ，自然会有人去做开发。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#109;&#x61;&#x69;&#x6c;&#116;&#111;&#58;&#91;&#104;&#111;&#110;&#103;&#x7a;&#104;&#x61;&#x6e;&#103;&#x2e;&#x2e;&#46;&#46;&#64;&#x67;&#109;&#97;&#105;&#108;&#46;&#x63;&#111;&#x6d;&#x5d;&#x28;&#x29;">&#91;&#104;&#111;&#110;&#103;&#x7a;&#104;&#x61;&#x6e;&#103;&#x2e;&#x2e;&#46;&#46;&#64;&#x67;&#109;&#97;&#105;&#108;&#46;&#x63;&#111;&#x6d;&#x5d;&#x28;&#x29;</a></p>
<blockquote>
<p>异构平台从网络处理器算起已经快10年了，现在情况仍然不明朗。就我看到的，异构平台要想高效，就必须向程序员暴露非常多的硬件细节，这必然导致编程的复杂性。 曲高和寡，要想渗透到应用程序这一块，我觉得很难。</p>
<p>2010/3/24 qiaojie <a href="&#x6d;&#x61;&#105;&#x6c;&#116;&#111;&#58;&#91;&#x71;&#105;&#x61;&#x6f;&#x2e;&#46;&#x2e;&#64;&#103;&#109;&#x61;&#105;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#x28;&#41;">&#91;&#x71;&#105;&#x61;&#x6f;&#x2e;&#46;&#x2e;&#64;&#103;&#109;&#x61;&#105;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#x28;&#41;</a></p>
<blockquote>
<p>说的没错，cell已经成了先烈了。不过这不代表异构的方向不对，CUDA，OpenCL也都是异构平台，以后我们会越来越习惯异构平台的。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#109;&#x61;&#105;&#x6c;&#x74;&#111;&#x3a;&#91;&#x68;&#111;&#110;&#x67;&#122;&#x68;&#x61;&#110;&#103;&#46;&#x2e;&#46;&#x2e;&#x40;&#103;&#x6d;&#97;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#40;&#x29;">&#91;&#x68;&#111;&#110;&#x67;&#122;&#x68;&#x61;&#110;&#103;&#46;&#x2e;&#46;&#x2e;&#x40;&#103;&#x6d;&#97;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#40;&#x29;</a></p>
<p>异构平台如果编程复杂度降不下来的话很难流行起来。cell已经死了...</p>
<blockquote>
<p> 2010/3/24 qiaojie <a href="&#109;&#x61;&#105;&#x6c;&#x74;&#111;&#58;&#x5b;&#x71;&#x69;&#x61;&#x6f;&#x2e;&#46;&#46;&#x40;&#x67;&#x6d;&#97;&#x69;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#x28;&#x29;">&#x5b;&#x71;&#x69;&#x61;&#x6f;&#x2e;&#46;&#46;&#x40;&#x67;&#x6d;&#97;&#x69;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#x28;&#x29;</a></p>
<blockquote>
<p>不是所有的程序都需要并行化的，能用串行化解决的问题没必要并行，所以即使将来many-core系统成为主流，大部分程序员也没必要去搞并行计算。
  我觉得未来的主流应该是类似cell这样一颗全功能核心带众多协处理核心的异构系统，这样才能达到最优的 性能/核心面积比。</p>
<p>2010/3/24 Guancheng Chen <a href="&#109;&#97;&#105;&#x6c;&#116;&#x6f;&#x3a;&#91;&#99;&#104;&#x65;&#110;&#x67;&#x75;&#97;&#x6e;&#99;&#x68;&#x2e;&#46;&#x2e;&#64;&#x67;&#109;&#97;&#x69;&#108;&#46;&#x63;&#111;&#x6d;&#x5d;&#40;&#x29;">&#91;&#99;&#104;&#x65;&#110;&#x67;&#x75;&#97;&#x6e;&#99;&#x68;&#x2e;&#46;&#x2e;&#64;&#x67;&#109;&#97;&#x69;&#108;&#46;&#x63;&#111;&#x6d;&#x5d;&#40;&#x29;</a></p>
<p>Nice 大胆预测Linear speedup应该是每个程序员十年后的目标 呵呵</p>
<blockquote>
<p>On 3月23日, 上午10时43分, qiaojie <a href="&#x6d;&#97;&#x69;&#x6c;&#x74;&#111;&#x3a;&#91;&#x71;&#105;&#97;&#111;&#46;&#x2e;&#46;&#64;&#x67;&#x6d;&#97;&#105;&#x6c;&#46;&#99;&#111;&#109;&#x5d;&#x28;&#41;">&#91;&#x71;&#105;&#97;&#111;&#46;&#x2e;&#46;&#64;&#x67;&#x6d;&#97;&#105;&#x6c;&#46;&#99;&#111;&#109;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>目前正在写的是一个软件渲染器，采用了光栅化和光线跟踪混合算法，渲染算法已经完全并行化了，
在4核系统上基本可以达到线性加速比，更多核的系统暂时还没测试。kd-tree的构造暂时还没有并
行化，以后有空了再研究。</p>
<p>2010/3/23 Guancheng Chen <a href="&#109;&#x61;&#105;&#x6c;&#x74;&#111;&#58;&#91;&#99;&#104;&#x65;&#x6e;&#x67;&#117;&#x61;&#x6e;&#x63;&#x68;&#x2e;&#46;&#46;&#64;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#46;&#x63;&#111;&#109;&#x5d;&#40;&#41;">&#91;&#99;&#104;&#x65;&#x6e;&#x67;&#117;&#x61;&#x6e;&#x63;&#x68;&#x2e;&#46;&#46;&#64;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#46;&#x63;&#111;&#109;&#x5d;&#40;&#41;</a></p>
<blockquote>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？</p>
<p>On 3月23日, 上午9时15分, qiaojie <a href="&#x6d;&#97;&#105;&#x6c;&#x74;&#111;&#x3a;&#91;&#x71;&#105;&#x61;&#x6f;&#x2e;&#46;&#46;&#x40;&#103;&#109;&#97;&#x69;&#108;&#46;&#x63;&#111;&#x6d;&#93;&#x28;&#41;">&#91;&#x71;&#105;&#x61;&#x6f;&#x2e;&#46;&#46;&#x40;&#103;&#109;&#97;&#x69;&#108;&#46;&#x63;&#111;&#x6d;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1)
=
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank
Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？</p>
</blockquote>
<p> To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a></p>
<p><img src="" alt=""> tinyfool <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-25</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>哈哈，终于从技术聊到经济了</p>
<p>在 2010-3-25，下午2:11， qiaojie 写道：</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>什么叫产能过剩？假设全世界每年消费10000亿斤粮食，结果今年收成好，生产了15000亿斤，</p>
<p>那多出来的5000亿斤无法被市场消化掉，就是产能过剩。那5000亿斤没价值，是垃圾？生产那
5000亿斤的农民是闲的蛋疼没事干？靠政府失业金养？</p>
<p>2010/3/25 机械唯物主义 : linjunhalida <a href="&#x6d;&#x61;&#x69;&#108;&#x74;&#111;&#x3a;&#x5b;&#108;&#105;&#110;&#106;&#x75;&#110;&#x2e;&#46;&#46;&#x40;&#103;&#109;&#97;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#109;&#93;&#40;&#41;">&#x5b;&#108;&#105;&#110;&#106;&#x75;&#110;&#x2e;&#46;&#46;&#x40;&#103;&#109;&#97;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#109;&#93;&#40;&#41;</a>
产能过剩的说法本来就不对。
产出的东西没有价值，这样的活动就不能说是生产。
比如我这个程序员，花了1周写了一个垃圾程序，然后被开除了。
然后1个月闲着，这是我产能过剩吗？
而闲着的原因是政府给我失业金，我就不需要工作闲起来了。。。</p>
<p>2010/3/25 qiaojie <a href="&#109;&#x61;&#x69;&#108;&#116;&#x6f;&#x3a;&#91;&#x71;&#105;&#97;&#x2e;&#x2e;&#46;&#64;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#40;&#x29;">&#91;&#x71;&#105;&#97;&#x2e;&#x2e;&#46;&#64;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#40;&#x29;</a>
如果产能=消费的话就没有产能过剩这一说了。</p>
<p>2010/3/25 机械唯物主义 : linjunhalida <a href="&#109;&#97;&#105;&#x6c;&#116;&#111;&#58;&#91;&#x6c;&#105;&#110;&#106;&#x75;&#110;&#46;&#46;&#x2e;&#64;&#x67;&#x6d;&#97;&#x69;&#x6c;&#46;&#x63;&#111;&#x6d;&#93;&#x28;&#41;">&#91;&#x6c;&#105;&#110;&#106;&#x75;&#110;&#46;&#46;&#x2e;&#64;&#x67;&#x6d;&#97;&#x69;&#x6c;&#46;&#x63;&#111;&#x6d;&#93;&#x28;&#41;</a></p>
<p>一个谬误：刺激需求
产能=消费，产能才是主动力。技术成长是随着产能成长而起来的。
而产能多的结果就是满足了需求，造成一种需求带来技术进步的假像。
而技术和产能之间的关系又错综复杂。。
2010/3/25 qiaojie <a href="&#109;&#x61;&#105;&#x6c;&#x74;&#111;&#x3a;&#x5b;&#113;&#x69;&#97;&#46;&#46;&#46;&#64;&#103;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#93;&#40;&#41;">&#x5b;&#113;&#x69;&#97;&#46;&#46;&#46;&#64;&#103;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#93;&#40;&#41;</a></p>
<p>3D游戏就是一类杀手应用，由此支撑起了一个庞大的GPU市场，芯片行业的研发成本是很高的，没有一个庞大的市场是做不起来的。目前的消费者对于多核系统显然还没有强烈的需求，因为应用跟不上，i7发布快2年了还没进入主流市场，这种情况延续下去的话摩尔定律将因此失效。不过我相信杀手级应用总会出现的，这可能要硬件性能突破一个临界点，比方说目前GPU的性能再提升一个数量级的话，光线跟踪算法就可以提供流畅的接近CG的画质，倒是此类应用便会流行开来。</p>
<p>2010/3/25 Guancheng Chen <a href="&#x6d;&#97;&#x69;&#x6c;&#116;&#x6f;&#x3a;&#x5b;&#99;&#x68;&#101;&#x6e;&#x67;&#117;&#x2e;&#46;&#46;&#x40;&#103;&#109;&#97;&#105;&#x6c;&#46;&#99;&#x6f;&#x6d;&#x5d;&#40;&#x29;">&#x5b;&#99;&#x68;&#101;&#x6e;&#x67;&#117;&#x2e;&#46;&#46;&#x40;&#103;&#109;&#97;&#105;&#x6c;&#46;&#99;&#x6f;&#x6d;&#x5d;&#40;&#x29;</a></p>
<p>杀手应用一般来说是指什么样的应用呢？比如用户群特别大的网游？还是那些专有的科学计算用的软件？
On 3月24日, 下午12时36分, qiaojie <a href="&#109;&#x61;&#105;&#108;&#116;&#111;&#x3a;&#x5b;&#113;&#105;&#x61;&#x6f;&#x2e;&#x2e;&#46;&#x40;&#103;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#99;&#111;&#109;&#93;&#40;&#x29;">&#x5b;&#113;&#105;&#x61;&#x6f;&#x2e;&#x2e;&#46;&#x40;&#103;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#99;&#111;&#109;&#93;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>并行计算本来就是曲高和寡的东西，就跟3D渲染一样，能开发引擎的毕竟只是小部分人，大多数人在引擎的基础上做应用。关键在于是否有杀手应用，只要有大量的需求 ，自然会有人去做开发。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#109;&#97;&#105;&#108;&#x74;&#x6f;&#58;&#91;&#104;&#x6f;&#110;&#x67;&#x7a;&#104;&#x61;&#x6e;&#x67;&#x2e;&#x2e;&#46;&#46;&#64;&#103;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#93;&#x28;&#41;">&#91;&#104;&#x6f;&#110;&#x67;&#x7a;&#104;&#x61;&#x6e;&#x67;&#x2e;&#x2e;&#46;&#46;&#64;&#103;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#93;&#x28;&#41;</a></p>
<blockquote>
<p>异构平台从网络处理器算起已经快10年了，现在情况仍然不明朗。就我看到的，异构平台要想高效，就必须向程序员暴露非常多的硬件细节，这必然导致编程的复杂性。 曲高和寡，要想渗透到应用程序这一块，我觉得很难。</p>
<p>2010/3/24 qiaojie <a href="&#x6d;&#x61;&#x69;&#108;&#x74;&#x6f;&#x3a;&#x5b;&#x71;&#x69;&#97;&#111;&#46;&#x2e;&#46;&#x40;&#103;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#99;&#111;&#109;&#x5d;&#40;&#x29;">&#x5b;&#x71;&#x69;&#97;&#111;&#46;&#x2e;&#46;&#x40;&#103;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#99;&#111;&#109;&#x5d;&#40;&#x29;</a></p>
<blockquote>
<p>说的没错，cell已经成了先烈了。不过这不代表异构的方向不对，CUDA，OpenCL也都是异构平台，以后我们会越来越习惯异构平台的。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#109;&#97;&#x69;&#108;&#x74;&#111;&#58;&#91;&#104;&#x6f;&#x6e;&#x67;&#x7a;&#104;&#x61;&#110;&#x67;&#x2e;&#x2e;&#46;&#46;&#x40;&#103;&#109;&#97;&#x69;&#x6c;&#46;&#x63;&#111;&#109;&#x5d;&#40;&#x29;">&#91;&#104;&#x6f;&#x6e;&#x67;&#x7a;&#104;&#x61;&#110;&#x67;&#x2e;&#x2e;&#46;&#46;&#x40;&#103;&#109;&#97;&#x69;&#x6c;&#46;&#x63;&#111;&#109;&#x5d;&#40;&#x29;</a></p>
<p>异构平台如果编程复杂度降不下来的话很难流行起来。cell已经死了...</p>
<blockquote>
<p> 2010/3/24 qiaojie <a href="&#x6d;&#x61;&#105;&#x6c;&#116;&#x6f;&#58;&#x5b;&#113;&#105;&#x61;&#x6f;&#x2e;&#x2e;&#46;&#x40;&#103;&#109;&#97;&#105;&#x6c;&#46;&#99;&#111;&#109;&#93;&#40;&#x29;">&#x5b;&#113;&#105;&#x61;&#x6f;&#x2e;&#x2e;&#46;&#x40;&#103;&#109;&#97;&#105;&#x6c;&#46;&#99;&#111;&#109;&#93;&#40;&#x29;</a></p>
<blockquote>
<p>不是所有的程序都需要并行化的，能用串行化解决的问题没必要并行，所以即使将来many-core系统成为主流，大部分程序员也没必要去搞并行计算。
  我觉得未来的主流应该是类似cell这样一颗全功能核心带众多协处理核心的异构系统，这样才能达到最优的 性能/核心面积比。</p>
<p>2010/3/24 Guancheng Chen <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#x5b;&#x63;&#x68;&#x65;&#x6e;&#103;&#117;&#97;&#x6e;&#99;&#x68;&#46;&#x2e;&#x2e;&#64;&#x67;&#109;&#97;&#x69;&#108;&#x2e;&#99;&#x6f;&#109;&#x5d;&#40;&#x29;">&#x5b;&#x63;&#x68;&#x65;&#x6e;&#103;&#117;&#97;&#x6e;&#99;&#x68;&#46;&#x2e;&#x2e;&#64;&#x67;&#109;&#97;&#x69;&#108;&#x2e;&#99;&#x6f;&#109;&#x5d;&#40;&#x29;</a></p>
<p>Nice 大胆预测Linear speedup应该是每个程序员十年后的目标 呵呵</p>
<blockquote>
<p>On 3月23日, 上午10时43分, qiaojie <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#91;&#113;&#x69;&#97;&#111;&#46;&#x2e;&#46;&#x40;&#x67;&#109;&#97;&#105;&#x6c;&#46;&#99;&#111;&#x6d;&#93;&#x28;&#x29;">&#91;&#113;&#x69;&#97;&#111;&#46;&#x2e;&#46;&#x40;&#x67;&#109;&#97;&#105;&#x6c;&#46;&#99;&#111;&#x6d;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>目前正在写的是一个软件渲染器，采用了光栅化和光线跟踪混合算法，渲染算法已经完全并行化了，
在4核系统上基本可以达到线性加速比，更多核的系统暂时还没测试。kd-tree的构造暂时还没有并
行化，以后有空了再研究。</p>
<p>2010/3/23 Guancheng Chen <a href="&#109;&#x61;&#105;&#108;&#x74;&#111;&#x3a;&#x5b;&#x63;&#104;&#x65;&#x6e;&#103;&#117;&#x61;&#110;&#99;&#104;&#x2e;&#46;&#46;&#64;&#103;&#x6d;&#97;&#105;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#40;&#x29;">&#x5b;&#x63;&#104;&#x65;&#x6e;&#103;&#117;&#x61;&#110;&#99;&#104;&#x2e;&#46;&#46;&#64;&#103;&#x6d;&#97;&#105;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#40;&#x29;</a></p>
<blockquote>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？</p>
<p>On 3月23日, 上午9时15分, qiaojie <a href="&#x6d;&#97;&#105;&#108;&#116;&#111;&#x3a;&#x5b;&#x71;&#105;&#97;&#111;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#109;&#x61;&#105;&#108;&#46;&#x63;&#x6f;&#109;&#x5d;&#40;&#41;">&#x5b;&#x71;&#105;&#97;&#111;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#109;&#x61;&#105;&#108;&#46;&#x63;&#x6f;&#109;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1)
=
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank
Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？</p>
</blockquote>
<p> To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> 机械唯物主义 : linjunhalida <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-25</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>本来就不该生产那么多的粮食，多余的人力和土地可以用来做别的事情。
问题在于为什么他们估算错误？
2010/3/25 qiaojie <a href="&#x6d;&#x61;&#x69;&#x6c;&#116;&#x6f;&#58;&#x5b;&#x71;&#x69;&#x61;&#x2e;&#46;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#41;">&#x5b;&#x71;&#x69;&#x61;&#x2e;&#46;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#x5d;&#x28;&#41;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>什么叫产能过剩？假设全世界每年消费10000亿斤粮食，结果今年收成好，生产了15000亿斤，</p>
<p>那多出来的5000亿斤无法被市场消化掉，就是产能过剩。那5000亿斤没价值，是垃圾？生产那
5000亿斤的农民是闲的蛋疼没事干？靠政府失业金养？</p>
<p>2010/3/25 机械唯物主义 : linjunhalida <a href="&#x6d;&#x61;&#105;&#108;&#116;&#x6f;&#x3a;&#91;&#x6c;&#x69;&#110;&#106;&#117;&#x6e;&#x2e;&#46;&#x2e;&#x40;&#x67;&#x6d;&#97;&#x69;&#x6c;&#46;&#x63;&#111;&#x6d;&#93;&#x28;&#x29;">&#91;&#x6c;&#x69;&#110;&#106;&#117;&#x6e;&#x2e;&#46;&#x2e;&#x40;&#x67;&#x6d;&#97;&#x69;&#x6c;&#46;&#x63;&#111;&#x6d;&#93;&#x28;&#x29;</a>
产能过剩的说法本来就不对。
产出的东西没有价值，这样的活动就不能说是生产。
比如我这个程序员，花了1周写了一个垃圾程序，然后被开除了。
然后1个月闲着，这是我产能过剩吗？
而闲着的原因是政府给我失业金，我就不需要工作闲起来了。。。</p>
<p>2010/3/25 qiaojie <a href="&#x6d;&#x61;&#105;&#108;&#x74;&#111;&#58;&#91;&#113;&#x69;&#97;&#x2e;&#x2e;&#46;&#x40;&#103;&#x6d;&#x61;&#105;&#108;&#x2e;&#99;&#x6f;&#x6d;&#93;&#x28;&#x29;">&#91;&#113;&#x69;&#97;&#x2e;&#x2e;&#46;&#x40;&#103;&#x6d;&#x61;&#105;&#108;&#x2e;&#99;&#x6f;&#x6d;&#93;&#x28;&#x29;</a>
如果产能=消费的话就没有产能过剩这一说了。</p>
<p>2010/3/25 机械唯物主义 : linjunhalida <a href="&#109;&#97;&#x69;&#108;&#116;&#111;&#x3a;&#x5b;&#108;&#105;&#x6e;&#106;&#x75;&#x6e;&#46;&#x2e;&#46;&#64;&#103;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#x28;&#x29;">&#x5b;&#108;&#105;&#x6e;&#106;&#x75;&#x6e;&#46;&#x2e;&#46;&#64;&#103;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#x28;&#x29;</a></p>
<p>一个谬误：刺激需求
产能=消费，产能才是主动力。技术成长是随着产能成长而起来的。
而产能多的结果就是满足了需求，造成一种需求带来技术进步的假像。
而技术和产能之间的关系又错综复杂。。
2010/3/25 qiaojie <a href="&#109;&#x61;&#105;&#108;&#x74;&#x6f;&#x3a;&#x5b;&#113;&#105;&#x61;&#x2e;&#x2e;&#x2e;&#64;&#103;&#x6d;&#x61;&#105;&#108;&#x2e;&#99;&#x6f;&#x6d;&#93;&#40;&#x29;">&#x5b;&#113;&#105;&#x61;&#x2e;&#x2e;&#x2e;&#64;&#103;&#x6d;&#x61;&#105;&#108;&#x2e;&#99;&#x6f;&#x6d;&#93;&#40;&#x29;</a></p>
<p>3D游戏就是一类杀手应用，由此支撑起了一个庞大的GPU市场，芯片行业的研发成本是很高的，没有一个庞大的市场是做不起来的。目前的消费者对于多核系统显然还没有强烈的需求，因为应用跟不上，i7发布快2年了还没进入主流市场，这种情况延续下去的话摩尔定律将因此失效。不过我相信杀手级应用总会出现的，这可能要硬件性能突破一个临界点，比方说目前GPU的性能再提升一个数量级的话，光线跟踪算法就可以提供流畅的接近CG的画质，倒是此类应用便会流行开来。</p>
<p>2010/3/25 Guancheng Chen <a href="&#x6d;&#97;&#105;&#x6c;&#x74;&#111;&#58;&#91;&#x63;&#104;&#101;&#x6e;&#103;&#x75;&#x2e;&#x2e;&#46;&#x40;&#103;&#x6d;&#x61;&#105;&#108;&#46;&#99;&#x6f;&#x6d;&#93;&#x28;&#x29;">&#91;&#x63;&#104;&#101;&#x6e;&#103;&#x75;&#x2e;&#x2e;&#46;&#x40;&#103;&#x6d;&#x61;&#105;&#108;&#46;&#99;&#x6f;&#x6d;&#93;&#x28;&#x29;</a></p>
<p>杀手应用一般来说是指什么样的应用呢？比如用户群特别大的网游？还是那些专有的科学计算用的软件？
On 3月24日, 下午12时36分, qiaojie <a href="&#x6d;&#x61;&#x69;&#108;&#116;&#111;&#x3a;&#91;&#113;&#x69;&#x61;&#111;&#x2e;&#x2e;&#46;&#64;&#103;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#99;&#111;&#x6d;&#x5d;&#40;&#41;">&#91;&#113;&#x69;&#x61;&#111;&#x2e;&#x2e;&#46;&#64;&#103;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#99;&#111;&#x6d;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>并行计算本来就是曲高和寡的东西，就跟3D渲染一样，能开发引擎的毕竟只是小部分人，大多数人在引擎的基础上做应用。关键在于是否有杀手应用，只要有大量的需求 ，自然会有人去做开发。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#109;&#x61;&#x69;&#x6c;&#x74;&#x6f;&#x3a;&#91;&#104;&#x6f;&#110;&#x67;&#x7a;&#104;&#97;&#110;&#103;&#46;&#x2e;&#x2e;&#46;&#64;&#x67;&#109;&#97;&#105;&#108;&#x2e;&#99;&#111;&#x6d;&#x5d;&#40;&#41;">&#91;&#104;&#x6f;&#110;&#x67;&#x7a;&#104;&#97;&#110;&#103;&#46;&#x2e;&#x2e;&#46;&#64;&#x67;&#109;&#97;&#105;&#108;&#x2e;&#99;&#111;&#x6d;&#x5d;&#40;&#41;</a></p>
<blockquote>
<p>异构平台从网络处理器算起已经快10年了，现在情况仍然不明朗。就我看到的，异构平台要想高效，就必须向程序员暴露非常多的硬件细节，这必然导致编程的复杂性。 曲高和寡，要想渗透到应用程序这一块，我觉得很难。</p>
<p>2010/3/24 qiaojie <a href="&#x6d;&#x61;&#105;&#x6c;&#116;&#x6f;&#58;&#x5b;&#x71;&#x69;&#97;&#x6f;&#x2e;&#46;&#46;&#64;&#103;&#x6d;&#97;&#105;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#41;">&#x5b;&#x71;&#x69;&#97;&#x6f;&#x2e;&#46;&#46;&#64;&#103;&#x6d;&#97;&#105;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#41;</a></p>
<blockquote>
<p>说的没错，cell已经成了先烈了。不过这不代表异构的方向不对，CUDA，OpenCL也都是异构平台，以后我们会越来越习惯异构平台的。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#109;&#97;&#105;&#x6c;&#116;&#x6f;&#x3a;&#x5b;&#104;&#111;&#x6e;&#x67;&#122;&#104;&#x61;&#x6e;&#x67;&#46;&#46;&#x2e;&#x2e;&#x40;&#x67;&#109;&#x61;&#105;&#108;&#x2e;&#x63;&#111;&#109;&#x5d;&#40;&#x29;">&#x5b;&#104;&#111;&#x6e;&#x67;&#122;&#104;&#x61;&#x6e;&#x67;&#46;&#46;&#x2e;&#x2e;&#x40;&#x67;&#109;&#x61;&#105;&#108;&#x2e;&#x63;&#111;&#109;&#x5d;&#40;&#x29;</a></p>
<p>异构平台如果编程复杂度降不下来的话很难流行起来。cell已经死了...</p>
<blockquote>
<p> 2010/3/24 qiaojie <a href="&#x6d;&#97;&#105;&#108;&#116;&#111;&#x3a;&#91;&#x71;&#105;&#97;&#111;&#46;&#46;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#x69;&#108;&#x2e;&#99;&#111;&#x6d;&#93;&#x28;&#x29;">&#91;&#x71;&#105;&#97;&#111;&#46;&#46;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#x69;&#108;&#x2e;&#99;&#111;&#x6d;&#93;&#x28;&#x29;</a></p>
<blockquote>
<p>不是所有的程序都需要并行化的，能用串行化解决的问题没必要并行，所以即使将来many-core系统成为主流，大部分程序员也没必要去搞并行计算。
  我觉得未来的主流应该是类似cell这样一颗全功能核心带众多协处理核心的异构系统，这样才能达到最优的 性能/核心面积比。</p>
<p>2010/3/24 Guancheng Chen <a href="&#x6d;&#x61;&#x69;&#108;&#116;&#111;&#x3a;&#x5b;&#x63;&#104;&#101;&#x6e;&#x67;&#117;&#97;&#x6e;&#99;&#x68;&#46;&#46;&#46;&#x40;&#103;&#109;&#x61;&#105;&#108;&#46;&#99;&#111;&#109;&#x5d;&#40;&#x29;">&#x5b;&#x63;&#104;&#101;&#x6e;&#x67;&#117;&#97;&#x6e;&#99;&#x68;&#46;&#46;&#46;&#x40;&#103;&#109;&#x61;&#105;&#108;&#46;&#99;&#111;&#109;&#x5d;&#40;&#x29;</a></p>
<p>Nice 大胆预测Linear speedup应该是每个程序员十年后的目标 呵呵</p>
<blockquote>
<p>On 3月23日, 上午10时43分, qiaojie <a href="&#109;&#97;&#x69;&#x6c;&#x74;&#111;&#x3a;&#x5b;&#x71;&#105;&#x61;&#x6f;&#x2e;&#x2e;&#46;&#x40;&#103;&#109;&#x61;&#105;&#x6c;&#x2e;&#99;&#111;&#x6d;&#93;&#40;&#41;">&#x5b;&#x71;&#105;&#x61;&#x6f;&#x2e;&#x2e;&#46;&#x40;&#103;&#109;&#x61;&#105;&#x6c;&#x2e;&#99;&#111;&#x6d;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>目前正在写的是一个软件渲染器，采用了光栅化和光线跟踪混合算法，渲染算法已经完全并行化了，
在4核系统上基本可以达到线性加速比，更多核的系统暂时还没测试。kd-tree的构造暂时还没有并
行化，以后有空了再研究。</p>
<p>2010/3/23 Guancheng Chen <a href="&#x6d;&#x61;&#105;&#108;&#116;&#111;&#x3a;&#x5b;&#99;&#x68;&#101;&#x6e;&#103;&#x75;&#97;&#110;&#x63;&#104;&#x2e;&#46;&#46;&#64;&#x67;&#109;&#97;&#x69;&#108;&#46;&#99;&#x6f;&#109;&#93;&#40;&#41;">&#x5b;&#99;&#x68;&#101;&#x6e;&#103;&#x75;&#97;&#110;&#x63;&#104;&#x2e;&#46;&#46;&#64;&#x67;&#109;&#97;&#x69;&#108;&#46;&#99;&#x6f;&#109;&#93;&#40;&#41;</a></p>
<blockquote>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？</p>
<p>On 3月23日, 上午9时15分, qiaojie <a href="&#x6d;&#97;&#x69;&#108;&#116;&#x6f;&#x3a;&#x5b;&#x71;&#105;&#x61;&#111;&#x2e;&#46;&#46;&#x40;&#103;&#x6d;&#97;&#105;&#x6c;&#46;&#99;&#111;&#109;&#93;&#x28;&#x29;">&#x5b;&#x71;&#105;&#x61;&#111;&#x2e;&#46;&#46;&#x40;&#103;&#x6d;&#97;&#105;&#x6c;&#46;&#99;&#111;&#109;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1)
=
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank
Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？</p>
</blockquote>
<p> To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a></p>
<p><img src="" alt=""> qiaojie <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-25</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>产能过剩和短缺导致的价格波动是市场经济的典型特征，想要消除过剩和短缺那叫计划经济，</p>
<p>学点经济学常识再来讨论这些问题吧。
2010/3/25 机械唯物主义 : linjunhalida <a href="&#109;&#97;&#105;&#x6c;&#116;&#111;&#x3a;&#91;&#108;&#105;&#x6e;&#106;&#117;&#110;&#x2e;&#46;&#x2e;&#64;&#x67;&#109;&#97;&#105;&#x6c;&#46;&#x63;&#x6f;&#109;&#x5d;&#40;&#x29;">&#91;&#108;&#105;&#x6e;&#106;&#117;&#110;&#x2e;&#46;&#x2e;&#64;&#x67;&#109;&#97;&#105;&#x6c;&#46;&#x63;&#x6f;&#109;&#x5d;&#40;&#x29;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>本来就不该生产那么多的粮食，多余的人力和土地可以用来做别的事情。
问题在于为什么他们估算错误？</p>
<p>2010/3/25 qiaojie <a href="&#109;&#x61;&#x69;&#x6c;&#116;&#111;&#58;&#x5b;&#113;&#105;&#x61;&#46;&#x2e;&#x2e;&#64;&#103;&#x6d;&#x61;&#105;&#108;&#46;&#99;&#x6f;&#x6d;&#93;&#40;&#41;">&#x5b;&#113;&#105;&#x61;&#46;&#x2e;&#x2e;&#64;&#103;&#x6d;&#x61;&#105;&#108;&#46;&#99;&#x6f;&#x6d;&#93;&#40;&#41;</a>
什么叫产能过剩？假设全世界每年消费10000亿斤粮食，结果今年收成好，生产了15000亿斤，</p>
<p>那多出来的5000亿斤无法被市场消化掉，就是产能过剩。那5000亿斤没价值，是垃圾？生产那
5000亿斤的农民是闲的蛋疼没事干？靠政府失业金养？</p>
<p>2010/3/25 机械唯物主义 : linjunhalida <a href="&#109;&#x61;&#105;&#x6c;&#x74;&#x6f;&#58;&#x5b;&#x6c;&#105;&#110;&#x6a;&#117;&#x6e;&#x2e;&#46;&#46;&#x40;&#x67;&#x6d;&#97;&#x69;&#108;&#46;&#x63;&#111;&#x6d;&#x5d;&#x28;&#x29;">&#x5b;&#x6c;&#105;&#110;&#x6a;&#117;&#x6e;&#x2e;&#46;&#46;&#x40;&#x67;&#x6d;&#97;&#x69;&#108;&#46;&#x63;&#111;&#x6d;&#x5d;&#x28;&#x29;</a>
产能过剩的说法本来就不对。
产出的东西没有价值，这样的活动就不能说是生产。
比如我这个程序员，花了1周写了一个垃圾程序，然后被开除了。
然后1个月闲着，这是我产能过剩吗？
而闲着的原因是政府给我失业金，我就不需要工作闲起来了。。。</p>
<p>2010/3/25 qiaojie <a href="&#x6d;&#x61;&#x69;&#108;&#116;&#x6f;&#x3a;&#x5b;&#x71;&#x69;&#x61;&#x2e;&#46;&#x2e;&#64;&#x67;&#x6d;&#x61;&#x69;&#108;&#x2e;&#99;&#x6f;&#109;&#x5d;&#x28;&#x29;">&#x5b;&#x71;&#x69;&#x61;&#x2e;&#46;&#x2e;&#64;&#x67;&#x6d;&#x61;&#x69;&#108;&#x2e;&#99;&#x6f;&#109;&#x5d;&#x28;&#x29;</a>
如果产能=消费的话就没有产能过剩这一说了。</p>
<p>2010/3/25 机械唯物主义 : linjunhalida <a href="&#x6d;&#97;&#x69;&#x6c;&#x74;&#111;&#58;&#x5b;&#108;&#105;&#110;&#x6a;&#117;&#x6e;&#x2e;&#46;&#46;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#x63;&#x6f;&#109;&#x5d;&#40;&#x29;">&#x5b;&#108;&#105;&#110;&#x6a;&#117;&#x6e;&#x2e;&#46;&#46;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#x63;&#x6f;&#109;&#x5d;&#40;&#x29;</a></p>
<p>一个谬误：刺激需求
产能=消费，产能才是主动力。技术成长是随着产能成长而起来的。
而产能多的结果就是满足了需求，造成一种需求带来技术进步的假像。
而技术和产能之间的关系又错综复杂。。
2010/3/25 qiaojie <a href="&#x6d;&#x61;&#105;&#108;&#x74;&#111;&#58;&#91;&#x71;&#105;&#97;&#x2e;&#46;&#46;&#x40;&#103;&#109;&#97;&#x69;&#108;&#46;&#x63;&#111;&#x6d;&#93;&#x28;&#41;">&#91;&#x71;&#105;&#97;&#x2e;&#46;&#46;&#x40;&#103;&#109;&#97;&#x69;&#108;&#46;&#x63;&#111;&#x6d;&#93;&#x28;&#41;</a></p>
<p>3D游戏就是一类杀手应用，由此支撑起了一个庞大的GPU市场，芯片行业的研发成本是很高的，没有一个庞大的市场是做不起来的。目前的消费者对于多核系统显然还没有强烈的需求，因为应用跟不上，i7发布快2年了还没进入主流市场，这种情况延续下去的话摩尔定律将因此失效。不过我相信杀手级应用总会出现的，这可能要硬件性能突破一个临界点，比方说目前GPU的性能再提升一个数量级的话，光线跟踪算法就可以提供流畅的接近CG的画质，倒是此类应用便会流行开来。</p>
<p>2010/3/25 Guancheng Chen <a href="&#109;&#97;&#x69;&#108;&#x74;&#111;&#58;&#x5b;&#x63;&#104;&#x65;&#110;&#x67;&#117;&#x2e;&#46;&#x2e;&#64;&#103;&#109;&#x61;&#x69;&#x6c;&#46;&#x63;&#111;&#x6d;&#93;&#40;&#41;">&#x5b;&#x63;&#104;&#x65;&#110;&#x67;&#117;&#x2e;&#46;&#x2e;&#64;&#103;&#109;&#x61;&#x69;&#x6c;&#46;&#x63;&#111;&#x6d;&#93;&#40;&#41;</a></p>
<p>杀手应用一般来说是指什么样的应用呢？比如用户群特别大的网游？还是那些专有的科学计算用的软件？
On 3月24日, 下午12时36分, qiaojie <a href="&#109;&#97;&#105;&#x6c;&#x74;&#x6f;&#58;&#x5b;&#113;&#x69;&#97;&#x6f;&#46;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#99;&#111;&#x6d;&#x5d;&#40;&#41;">&#x5b;&#113;&#x69;&#97;&#x6f;&#46;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#99;&#111;&#x6d;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>并行计算本来就是曲高和寡的东西，就跟3D渲染一样，能开发引擎的毕竟只是小部分人，大多数人在引擎的基础上做应用。关键在于是否有杀手应用，只要有大量的需求 ，自然会有人去做开发。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#109;&#x61;&#105;&#x6c;&#116;&#111;&#58;&#x5b;&#x68;&#x6f;&#110;&#x67;&#122;&#104;&#x61;&#110;&#x67;&#46;&#x2e;&#x2e;&#x2e;&#64;&#103;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#111;&#109;&#x5d;&#40;&#41;">&#x5b;&#x68;&#x6f;&#110;&#x67;&#122;&#104;&#x61;&#110;&#x67;&#46;&#x2e;&#x2e;&#x2e;&#64;&#103;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#111;&#109;&#x5d;&#40;&#41;</a></p>
<blockquote>
<p>异构平台从网络处理器算起已经快10年了，现在情况仍然不明朗。就我看到的，异构平台要想高效，就必须向程序员暴露非常多的硬件细节，这必然导致编程的复杂性。 曲高和寡，要想渗透到应用程序这一块，我觉得很难。</p>
<p>2010/3/24 qiaojie <a href="&#109;&#x61;&#x69;&#108;&#x74;&#x6f;&#58;&#91;&#113;&#x69;&#x61;&#x6f;&#46;&#x2e;&#x2e;&#x40;&#x67;&#109;&#97;&#105;&#x6c;&#46;&#99;&#111;&#x6d;&#x5d;&#x28;&#41;">&#91;&#113;&#x69;&#x61;&#x6f;&#46;&#x2e;&#x2e;&#x40;&#x67;&#109;&#97;&#105;&#x6c;&#46;&#99;&#111;&#x6d;&#x5d;&#x28;&#41;</a></p>
<blockquote>
<p>说的没错，cell已经成了先烈了。不过这不代表异构的方向不对，CUDA，OpenCL也都是异构平台，以后我们会越来越习惯异构平台的。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#x6d;&#97;&#x69;&#108;&#116;&#x6f;&#x3a;&#x5b;&#104;&#x6f;&#x6e;&#x67;&#122;&#x68;&#97;&#110;&#x67;&#46;&#46;&#x2e;&#x2e;&#64;&#103;&#109;&#97;&#105;&#x6c;&#46;&#99;&#111;&#109;&#x5d;&#40;&#x29;">&#x5b;&#104;&#x6f;&#x6e;&#x67;&#122;&#x68;&#97;&#110;&#x67;&#46;&#46;&#x2e;&#x2e;&#64;&#103;&#109;&#97;&#105;&#x6c;&#46;&#99;&#111;&#109;&#x5d;&#40;&#x29;</a></p>
<p>异构平台如果编程复杂度降不下来的话很难流行起来。cell已经死了...</p>
<blockquote>
<p> 2010/3/24 qiaojie <a href="&#x6d;&#97;&#105;&#108;&#116;&#111;&#x3a;&#x5b;&#x71;&#105;&#x61;&#x6f;&#46;&#x2e;&#46;&#x40;&#x67;&#x6d;&#97;&#105;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#41;">&#x5b;&#x71;&#105;&#x61;&#x6f;&#46;&#x2e;&#46;&#x40;&#x67;&#x6d;&#97;&#105;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#41;</a></p>
<blockquote>
<p>不是所有的程序都需要并行化的，能用串行化解决的问题没必要并行，所以即使将来many-core系统成为主流，大部分程序员也没必要去搞并行计算。
  我觉得未来的主流应该是类似cell这样一颗全功能核心带众多协处理核心的异构系统，这样才能达到最优的 性能/核心面积比。</p>
<p>2010/3/24 Guancheng Chen <a href="&#109;&#97;&#105;&#x6c;&#116;&#111;&#58;&#91;&#x63;&#x68;&#x65;&#x6e;&#103;&#x75;&#97;&#110;&#99;&#x68;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#x29;">&#91;&#x63;&#x68;&#x65;&#x6e;&#103;&#x75;&#97;&#110;&#99;&#x68;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#x29;</a></p>
<p>Nice 大胆预测Linear speedup应该是每个程序员十年后的目标 呵呵</p>
<blockquote>
<p>On 3月23日, 上午10时43分, qiaojie <a href="&#x6d;&#x61;&#105;&#x6c;&#116;&#111;&#x3a;&#91;&#113;&#105;&#x61;&#111;&#46;&#x2e;&#x2e;&#64;&#x67;&#109;&#x61;&#105;&#x6c;&#46;&#x63;&#111;&#109;&#x5d;&#x28;&#x29;">&#91;&#113;&#105;&#x61;&#111;&#46;&#x2e;&#x2e;&#64;&#x67;&#109;&#x61;&#105;&#x6c;&#46;&#x63;&#111;&#109;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>目前正在写的是一个软件渲染器，采用了光栅化和光线跟踪混合算法，渲染算法已经完全并行化了，
在4核系统上基本可以达到线性加速比，更多核的系统暂时还没测试。kd-tree的构造暂时还没有并
行化，以后有空了再研究。</p>
<p>2010/3/23 Guancheng Chen <a href="&#109;&#97;&#105;&#108;&#116;&#x6f;&#58;&#91;&#x63;&#104;&#x65;&#x6e;&#x67;&#117;&#97;&#x6e;&#x63;&#104;&#x2e;&#46;&#46;&#64;&#103;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#40;&#41;">&#91;&#x63;&#104;&#x65;&#x6e;&#x67;&#117;&#97;&#x6e;&#x63;&#104;&#x2e;&#46;&#46;&#64;&#103;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#40;&#41;</a></p>
<blockquote>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？</p>
<p>On 3月23日, 上午9时15分, qiaojie <a href="&#x6d;&#x61;&#x69;&#108;&#x74;&#x6f;&#58;&#x5b;&#x71;&#x69;&#x61;&#x6f;&#x2e;&#46;&#46;&#64;&#103;&#x6d;&#x61;&#105;&#108;&#x2e;&#x63;&#111;&#x6d;&#93;&#40;&#41;">&#x5b;&#x71;&#x69;&#x61;&#x6f;&#x2e;&#46;&#46;&#64;&#103;&#x6d;&#x61;&#105;&#108;&#x2e;&#x63;&#111;&#x6d;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1)
=
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank
Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？</p>
</blockquote>
<p> To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> 机械唯物主义 : linjunhalida <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-25</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>小规模的，市场会自动调节。
如果出现大规模的问题，就有可能是信息错误——货币的币值变了。
2010/3/25 qiaojie <a href="&#109;&#x61;&#105;&#108;&#x74;&#111;&#x3a;&#x5b;&#x71;&#105;&#x61;&#46;&#46;&#46;&#64;&#103;&#x6d;&#x61;&#x69;&#x6c;&#46;&#99;&#x6f;&#109;&#x5d;&#40;&#41;">&#x5b;&#x71;&#105;&#x61;&#46;&#46;&#46;&#64;&#103;&#x6d;&#x61;&#x69;&#x6c;&#46;&#99;&#x6f;&#109;&#x5d;&#40;&#41;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>产能过剩和短缺导致的价格波动是市场经济的典型特征，想要消除过剩和短缺那叫计划经济，</p>
<p>学点经济学常识再来讨论这些问题吧。
2010/3/25 机械唯物主义 : linjunhalida <a href="&#109;&#x61;&#105;&#x6c;&#116;&#x6f;&#x3a;&#x5b;&#x6c;&#x69;&#x6e;&#x6a;&#x75;&#110;&#46;&#46;&#46;&#64;&#x67;&#109;&#x61;&#105;&#108;&#46;&#x63;&#111;&#109;&#x5d;&#x28;&#41;">&#x5b;&#x6c;&#x69;&#x6e;&#x6a;&#x75;&#110;&#46;&#46;&#46;&#64;&#x67;&#109;&#x61;&#105;&#108;&#46;&#x63;&#111;&#109;&#x5d;&#x28;&#41;</a>
本来就不该生产那么多的粮食，多余的人力和土地可以用来做别的事情。
问题在于为什么他们估算错误？</p>
<p>2010/3/25 qiaojie <a href="&#x6d;&#97;&#x69;&#108;&#116;&#x6f;&#x3a;&#91;&#x71;&#105;&#97;&#x2e;&#x2e;&#46;&#64;&#103;&#x6d;&#x61;&#105;&#x6c;&#46;&#99;&#111;&#109;&#93;&#40;&#x29;">&#91;&#x71;&#105;&#97;&#x2e;&#x2e;&#46;&#64;&#103;&#x6d;&#x61;&#105;&#x6c;&#46;&#99;&#111;&#109;&#93;&#40;&#x29;</a>
什么叫产能过剩？假设全世界每年消费10000亿斤粮食，结果今年收成好，生产了15000亿斤，</p>
<p>那多出来的5000亿斤无法被市场消化掉，就是产能过剩。那5000亿斤没价值，是垃圾？生产那
5000亿斤的农民是闲的蛋疼没事干？靠政府失业金养？</p>
<p>2010/3/25 机械唯物主义 : linjunhalida <a href="&#x6d;&#97;&#105;&#108;&#x74;&#x6f;&#x3a;&#91;&#x6c;&#x69;&#110;&#x6a;&#x75;&#x6e;&#x2e;&#46;&#x2e;&#x40;&#103;&#x6d;&#x61;&#x69;&#108;&#46;&#x63;&#111;&#109;&#93;&#40;&#41;">&#91;&#x6c;&#x69;&#110;&#x6a;&#x75;&#x6e;&#x2e;&#46;&#x2e;&#x40;&#103;&#x6d;&#x61;&#x69;&#108;&#46;&#x63;&#111;&#109;&#93;&#40;&#41;</a>
产能过剩的说法本来就不对。
产出的东西没有价值，这样的活动就不能说是生产。
比如我这个程序员，花了1周写了一个垃圾程序，然后被开除了。
然后1个月闲着，这是我产能过剩吗？
而闲着的原因是政府给我失业金，我就不需要工作闲起来了。。。</p>
<p>2010/3/25 qiaojie <a href="&#x6d;&#97;&#x69;&#x6c;&#116;&#111;&#58;&#91;&#x71;&#105;&#x61;&#x2e;&#46;&#x2e;&#64;&#x67;&#x6d;&#97;&#105;&#108;&#46;&#99;&#x6f;&#x6d;&#93;&#40;&#x29;">&#91;&#x71;&#105;&#x61;&#x2e;&#46;&#x2e;&#64;&#x67;&#x6d;&#97;&#105;&#108;&#46;&#99;&#x6f;&#x6d;&#93;&#40;&#x29;</a>
如果产能=消费的话就没有产能过剩这一说了。</p>
<p>2010/3/25 机械唯物主义 : linjunhalida <a href="&#x6d;&#97;&#105;&#x6c;&#116;&#x6f;&#x3a;&#91;&#x6c;&#105;&#110;&#106;&#x75;&#110;&#x2e;&#46;&#x2e;&#x40;&#x67;&#109;&#x61;&#x69;&#x6c;&#46;&#99;&#x6f;&#109;&#93;&#40;&#x29;">&#91;&#x6c;&#105;&#110;&#106;&#x75;&#110;&#x2e;&#46;&#x2e;&#x40;&#x67;&#109;&#x61;&#x69;&#x6c;&#46;&#99;&#x6f;&#109;&#93;&#40;&#x29;</a></p>
<p>一个谬误：刺激需求
产能=消费，产能才是主动力。技术成长是随着产能成长而起来的。
而产能多的结果就是满足了需求，造成一种需求带来技术进步的假像。
而技术和产能之间的关系又错综复杂。。
2010/3/25 qiaojie <a href="&#x6d;&#97;&#x69;&#108;&#x74;&#x6f;&#x3a;&#x5b;&#113;&#x69;&#97;&#x2e;&#x2e;&#46;&#64;&#103;&#109;&#97;&#105;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#41;">&#x5b;&#113;&#x69;&#97;&#x2e;&#x2e;&#46;&#64;&#103;&#109;&#97;&#105;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#41;</a></p>
<p>3D游戏就是一类杀手应用，由此支撑起了一个庞大的GPU市场，芯片行业的研发成本是很高的，没有一个庞大的市场是做不起来的。目前的消费者对于多核系统显然还没有强烈的需求，因为应用跟不上，i7发布快2年了还没进入主流市场，这种情况延续下去的话摩尔定律将因此失效。不过我相信杀手级应用总会出现的，这可能要硬件性能突破一个临界点，比方说目前GPU的性能再提升一个数量级的话，光线跟踪算法就可以提供流畅的接近CG的画质，倒是此类应用便会流行开来。</p>
<p>2010/3/25 Guancheng Chen <a href="&#x6d;&#x61;&#x69;&#108;&#116;&#111;&#58;&#x5b;&#99;&#104;&#x65;&#x6e;&#x67;&#117;&#x2e;&#46;&#46;&#64;&#x67;&#109;&#x61;&#105;&#x6c;&#x2e;&#x63;&#111;&#109;&#93;&#40;&#41;">&#x5b;&#99;&#104;&#x65;&#x6e;&#x67;&#117;&#x2e;&#46;&#46;&#64;&#x67;&#109;&#x61;&#105;&#x6c;&#x2e;&#x63;&#111;&#109;&#93;&#40;&#41;</a></p>
<p>杀手应用一般来说是指什么样的应用呢？比如用户群特别大的网游？还是那些专有的科学计算用的软件？
On 3月24日, 下午12时36分, qiaojie <a href="&#109;&#97;&#105;&#x6c;&#116;&#x6f;&#x3a;&#x5b;&#113;&#x69;&#97;&#x6f;&#46;&#x2e;&#x2e;&#64;&#103;&#109;&#x61;&#x69;&#108;&#46;&#x63;&#x6f;&#x6d;&#93;&#40;&#41;">&#x5b;&#113;&#x69;&#97;&#x6f;&#46;&#x2e;&#x2e;&#64;&#103;&#109;&#x61;&#x69;&#108;&#46;&#x63;&#x6f;&#x6d;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>并行计算本来就是曲高和寡的东西，就跟3D渲染一样，能开发引擎的毕竟只是小部分人，大多数人在引擎的基础上做应用。关键在于是否有杀手应用，只要有大量的需求 ，自然会有人去做开发。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#x6d;&#97;&#105;&#108;&#x74;&#111;&#x3a;&#x5b;&#104;&#111;&#110;&#103;&#x7a;&#x68;&#97;&#110;&#103;&#46;&#46;&#x2e;&#46;&#x40;&#x67;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#99;&#111;&#109;&#x5d;&#40;&#41;">&#x5b;&#104;&#111;&#110;&#103;&#x7a;&#x68;&#97;&#110;&#103;&#46;&#46;&#x2e;&#46;&#x40;&#x67;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#99;&#111;&#109;&#x5d;&#40;&#41;</a></p>
<blockquote>
<p>异构平台从网络处理器算起已经快10年了，现在情况仍然不明朗。就我看到的，异构平台要想高效，就必须向程序员暴露非常多的硬件细节，这必然导致编程的复杂性。 曲高和寡，要想渗透到应用程序这一块，我觉得很难。</p>
<p>2010/3/24 qiaojie <a href="&#x6d;&#x61;&#105;&#x6c;&#x74;&#111;&#58;&#91;&#x71;&#105;&#97;&#111;&#46;&#x2e;&#46;&#64;&#103;&#109;&#97;&#x69;&#108;&#x2e;&#x63;&#x6f;&#109;&#93;&#x28;&#41;">&#91;&#x71;&#105;&#97;&#111;&#46;&#x2e;&#46;&#64;&#103;&#109;&#97;&#x69;&#108;&#x2e;&#x63;&#x6f;&#109;&#93;&#x28;&#41;</a></p>
<blockquote>
<p>说的没错，cell已经成了先烈了。不过这不代表异构的方向不对，CUDA，OpenCL也都是异构平台，以后我们会越来越习惯异构平台的。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#109;&#97;&#105;&#108;&#x74;&#111;&#58;&#91;&#x68;&#111;&#x6e;&#x67;&#122;&#104;&#97;&#x6e;&#103;&#46;&#46;&#x2e;&#46;&#64;&#x67;&#x6d;&#97;&#105;&#x6c;&#x2e;&#99;&#x6f;&#109;&#x5d;&#40;&#x29;">&#91;&#x68;&#111;&#x6e;&#x67;&#122;&#104;&#97;&#x6e;&#103;&#46;&#46;&#x2e;&#46;&#64;&#x67;&#x6d;&#97;&#105;&#x6c;&#x2e;&#99;&#x6f;&#109;&#x5d;&#40;&#x29;</a></p>
<p>异构平台如果编程复杂度降不下来的话很难流行起来。cell已经死了...</p>
<blockquote>
<p> 2010/3/24 qiaojie <a href="&#x6d;&#x61;&#105;&#108;&#116;&#x6f;&#58;&#x5b;&#x71;&#x69;&#97;&#111;&#46;&#x2e;&#x2e;&#64;&#103;&#x6d;&#97;&#x69;&#x6c;&#46;&#99;&#111;&#109;&#x5d;&#40;&#x29;">&#x5b;&#x71;&#x69;&#97;&#111;&#46;&#x2e;&#x2e;&#64;&#103;&#x6d;&#97;&#x69;&#x6c;&#46;&#99;&#111;&#109;&#x5d;&#40;&#x29;</a></p>
<blockquote>
<p>不是所有的程序都需要并行化的，能用串行化解决的问题没必要并行，所以即使将来many-core系统成为主流，大部分程序员也没必要去搞并行计算。
  我觉得未来的主流应该是类似cell这样一颗全功能核心带众多协处理核心的异构系统，这样才能达到最优的 性能/核心面积比。</p>
<p>2010/3/24 Guancheng Chen <a href="&#x6d;&#97;&#x69;&#x6c;&#x74;&#x6f;&#x3a;&#x5b;&#99;&#x68;&#101;&#110;&#x67;&#117;&#x61;&#110;&#99;&#104;&#46;&#x2e;&#46;&#64;&#103;&#x6d;&#x61;&#105;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#x29;">&#x5b;&#99;&#x68;&#101;&#110;&#x67;&#117;&#x61;&#110;&#99;&#104;&#46;&#x2e;&#46;&#64;&#103;&#x6d;&#x61;&#105;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#x29;</a></p>
<p>Nice 大胆预测Linear speedup应该是每个程序员十年后的目标 呵呵</p>
<blockquote>
<p>On 3月23日, 上午10时43分, qiaojie <a href="&#x6d;&#97;&#105;&#x6c;&#x74;&#111;&#x3a;&#91;&#113;&#105;&#x61;&#x6f;&#46;&#x2e;&#46;&#64;&#x67;&#109;&#97;&#x69;&#108;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#40;&#41;">&#91;&#113;&#105;&#x61;&#x6f;&#46;&#x2e;&#46;&#64;&#x67;&#109;&#97;&#x69;&#108;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>目前正在写的是一个软件渲染器，采用了光栅化和光线跟踪混合算法，渲染算法已经完全并行化了，
在4核系统上基本可以达到线性加速比，更多核的系统暂时还没测试。kd-tree的构造暂时还没有并
行化，以后有空了再研究。</p>
<p>2010/3/23 Guancheng Chen <a href="&#x6d;&#x61;&#x69;&#108;&#x74;&#111;&#x3a;&#91;&#99;&#104;&#101;&#x6e;&#x67;&#x75;&#97;&#x6e;&#99;&#x68;&#46;&#x2e;&#x2e;&#x40;&#x67;&#109;&#x61;&#105;&#108;&#46;&#x63;&#111;&#x6d;&#x5d;&#40;&#x29;">&#91;&#99;&#104;&#101;&#x6e;&#x67;&#x75;&#97;&#x6e;&#99;&#x68;&#46;&#x2e;&#x2e;&#x40;&#x67;&#109;&#x61;&#105;&#108;&#46;&#x63;&#111;&#x6d;&#x5d;&#40;&#x29;</a></p>
<blockquote>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？</p>
<p>On 3月23日, 上午9时15分, qiaojie <a href="&#109;&#x61;&#105;&#108;&#x74;&#111;&#58;&#91;&#x71;&#105;&#97;&#111;&#x2e;&#x2e;&#46;&#64;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#99;&#111;&#109;&#x5d;&#40;&#41;">&#91;&#x71;&#105;&#97;&#111;&#x2e;&#x2e;&#46;&#64;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#99;&#111;&#109;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1)
=
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank
Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？</p>
</blockquote>
<p> To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a></p>
<p><img src="" alt=""> qiaojie <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-25</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>恩，很快会被升华成为政治问题
2010/3/25 郝培强 tinyfool <a href="&#109;&#x61;&#x69;&#x6c;&#116;&#x6f;&#x3a;&#x5b;&#x74;&#x69;&#x6e;&#x79;&#x2e;&#46;&#x2e;&#x40;&#103;&#109;&#x61;&#x69;&#x6c;&#46;&#99;&#111;&#109;&#x5d;&#x28;&#x29;">&#x5b;&#x74;&#x69;&#x6e;&#x79;&#x2e;&#46;&#x2e;&#x40;&#103;&#109;&#x61;&#x69;&#x6c;&#46;&#99;&#111;&#109;&#x5d;&#x28;&#x29;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>哈哈，终于从技术聊到经济了</p>
<p>在 2010-3-25，下午2:11， qiaojie 写道：</p>
<p>什么叫产能过剩？假设全世界每年消费10000亿斤粮食，结果今年收成好，生产了15000亿斤，</p>
<p>那多出来的5000亿斤无法被市场消化掉，就是产能过剩。那5000亿斤没价值，是垃圾？生产那
5000亿斤的农民是闲的蛋疼没事干？靠政府失业金养？</p>
<p>2010/3/25 机械唯物主义 : linjunhalida <a href="&#x6d;&#x61;&#105;&#x6c;&#116;&#x6f;&#x3a;&#x5b;&#108;&#105;&#110;&#106;&#117;&#110;&#x2e;&#x2e;&#46;&#64;&#103;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#99;&#111;&#109;&#93;&#40;&#x29;">&#x5b;&#108;&#105;&#110;&#106;&#117;&#110;&#x2e;&#x2e;&#46;&#64;&#103;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#99;&#111;&#109;&#93;&#40;&#x29;</a>
产能过剩的说法本来就不对。
产出的东西没有价值，这样的活动就不能说是生产。
比如我这个程序员，花了1周写了一个垃圾程序，然后被开除了。
然后1个月闲着，这是我产能过剩吗？
而闲着的原因是政府给我失业金，我就不需要工作闲起来了。。。</p>
<p>2010/3/25 qiaojie <a href="&#x6d;&#97;&#x69;&#x6c;&#116;&#111;&#x3a;&#91;&#x71;&#x69;&#x61;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#x61;&#105;&#x6c;&#46;&#x63;&#111;&#109;&#93;&#40;&#x29;">&#91;&#x71;&#x69;&#x61;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#x61;&#105;&#x6c;&#46;&#x63;&#111;&#109;&#93;&#40;&#x29;</a>
如果产能=消费的话就没有产能过剩这一说了。</p>
<p>2010/3/25 机械唯物主义 : linjunhalida <a href="&#109;&#97;&#x69;&#108;&#116;&#x6f;&#x3a;&#91;&#x6c;&#x69;&#110;&#x6a;&#x75;&#x6e;&#x2e;&#46;&#x2e;&#x40;&#103;&#109;&#x61;&#x69;&#108;&#46;&#99;&#x6f;&#109;&#x5d;&#40;&#41;">&#91;&#x6c;&#x69;&#110;&#x6a;&#x75;&#x6e;&#x2e;&#46;&#x2e;&#x40;&#103;&#109;&#x61;&#x69;&#108;&#46;&#99;&#x6f;&#109;&#x5d;&#40;&#41;</a></p>
<p>一个谬误：刺激需求
产能=消费，产能才是主动力。技术成长是随着产能成长而起来的。
而产能多的结果就是满足了需求，造成一种需求带来技术进步的假像。
而技术和产能之间的关系又错综复杂。。
2010/3/25 qiaojie <a href="&#x6d;&#97;&#105;&#108;&#x74;&#111;&#58;&#x5b;&#113;&#105;&#97;&#x2e;&#46;&#x2e;&#x40;&#103;&#109;&#97;&#105;&#x6c;&#x2e;&#x63;&#111;&#109;&#93;&#40;&#41;">&#x5b;&#113;&#105;&#97;&#x2e;&#46;&#x2e;&#x40;&#103;&#109;&#97;&#105;&#x6c;&#x2e;&#x63;&#111;&#109;&#93;&#40;&#41;</a></p>
<p>3D游戏就是一类杀手应用，由此支撑起了一个庞大的GPU市场，芯片行业的研发成本是很高的，没有一个庞大的市场是做不起来的。目前的消费者对于多核系统显然还没有强烈的需求，因为应用跟不上，i7发布快2年了还没进入主流市场，这种情况延续下去的话摩尔定律将因此失效。不过我相信杀手级应用总会出现的，这可能要硬件性能突破一个临界点，比方说目前GPU的性能再提升一个数量级的话，光线跟踪算法就可以提供流畅的接近CG的画质，倒是此类应用便会流行开来。</p>
<p>2010/3/25 Guancheng Chen <a href="&#109;&#x61;&#x69;&#108;&#116;&#x6f;&#x3a;&#91;&#99;&#x68;&#x65;&#x6e;&#103;&#117;&#x2e;&#46;&#46;&#x40;&#x67;&#x6d;&#97;&#105;&#108;&#46;&#x63;&#111;&#x6d;&#93;&#x28;&#41;">&#91;&#99;&#x68;&#x65;&#x6e;&#103;&#117;&#x2e;&#46;&#46;&#x40;&#x67;&#x6d;&#97;&#105;&#108;&#46;&#x63;&#111;&#x6d;&#93;&#x28;&#41;</a></p>
<p>杀手应用一般来说是指什么样的应用呢？比如用户群特别大的网游？还是那些专有的科学计算用的软件？
On 3月24日, 下午12时36分, qiaojie <a href="&#109;&#x61;&#105;&#108;&#x74;&#x6f;&#x3a;&#x5b;&#113;&#105;&#x61;&#x6f;&#x2e;&#46;&#46;&#64;&#x67;&#109;&#97;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#109;&#x5d;&#x28;&#x29;">&#x5b;&#113;&#105;&#x61;&#x6f;&#x2e;&#46;&#46;&#64;&#x67;&#109;&#97;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#109;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>并行计算本来就是曲高和寡的东西，就跟3D渲染一样，能开发引擎的毕竟只是小部分人，大多数人在引擎的基础上做应用。关键在于是否有杀手应用，只要有大量的需求 ，自然会有人去做开发。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#109;&#x61;&#x69;&#108;&#116;&#x6f;&#58;&#91;&#104;&#111;&#x6e;&#x67;&#122;&#x68;&#97;&#x6e;&#103;&#46;&#46;&#46;&#46;&#64;&#x67;&#x6d;&#x61;&#105;&#108;&#46;&#x63;&#111;&#x6d;&#x5d;&#40;&#x29;">&#91;&#104;&#111;&#x6e;&#x67;&#122;&#x68;&#97;&#x6e;&#103;&#46;&#46;&#46;&#46;&#64;&#x67;&#x6d;&#x61;&#105;&#108;&#46;&#x63;&#111;&#x6d;&#x5d;&#40;&#x29;</a></p>
<blockquote>
<p>异构平台从网络处理器算起已经快10年了，现在情况仍然不明朗。就我看到的，异构平台要想高效，就必须向程序员暴露非常多的硬件细节，这必然导致编程的复杂性。 曲高和寡，要想渗透到应用程序这一块，我觉得很难。</p>
<p>2010/3/24 qiaojie <a href="&#x6d;&#97;&#105;&#x6c;&#116;&#111;&#58;&#91;&#x71;&#105;&#97;&#x6f;&#x2e;&#46;&#x2e;&#64;&#103;&#109;&#x61;&#105;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#x29;">&#91;&#x71;&#105;&#97;&#x6f;&#x2e;&#46;&#x2e;&#64;&#103;&#109;&#x61;&#105;&#x6c;&#46;&#x63;&#x6f;&#x6d;&#x5d;&#x28;&#x29;</a></p>
<blockquote>
<p>说的没错，cell已经成了先烈了。不过这不代表异构的方向不对，CUDA，OpenCL也都是异构平台，以后我们会越来越习惯异构平台的。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#109;&#x61;&#105;&#x6c;&#116;&#111;&#58;&#91;&#x68;&#x6f;&#x6e;&#x67;&#x7a;&#104;&#97;&#110;&#103;&#x2e;&#46;&#46;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#99;&#111;&#109;&#93;&#x28;&#x29;">&#91;&#x68;&#x6f;&#x6e;&#x67;&#x7a;&#104;&#97;&#110;&#103;&#x2e;&#46;&#46;&#x2e;&#x40;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#99;&#111;&#109;&#93;&#x28;&#x29;</a></p>
<p>异构平台如果编程复杂度降不下来的话很难流行起来。cell已经死了...</p>
<blockquote>
<p> 2010/3/24 qiaojie <a href="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#111;&#x3a;&#91;&#x71;&#105;&#x61;&#x6f;&#46;&#x2e;&#46;&#x40;&#103;&#x6d;&#97;&#x69;&#108;&#46;&#x63;&#111;&#109;&#x5d;&#40;&#41;">&#91;&#x71;&#105;&#x61;&#x6f;&#46;&#x2e;&#46;&#x40;&#103;&#x6d;&#97;&#x69;&#108;&#46;&#x63;&#111;&#109;&#x5d;&#40;&#41;</a></p>
<blockquote>
<p>不是所有的程序都需要并行化的，能用串行化解决的问题没必要并行，所以即使将来many-core系统成为主流，大部分程序员也没必要去搞并行计算。
  我觉得未来的主流应该是类似cell这样一颗全功能核心带众多协处理核心的异构系统，这样才能达到最优的 性能/核心面积比。</p>
<p>2010/3/24 Guancheng Chen <a href="&#x6d;&#x61;&#105;&#x6c;&#116;&#111;&#x3a;&#91;&#99;&#x68;&#x65;&#110;&#x67;&#117;&#x61;&#x6e;&#x63;&#104;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#x61;&#105;&#x6c;&#46;&#x63;&#111;&#109;&#x5d;&#40;&#41;">&#91;&#99;&#x68;&#x65;&#110;&#x67;&#117;&#x61;&#x6e;&#x63;&#104;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#x61;&#105;&#x6c;&#46;&#x63;&#111;&#109;&#x5d;&#40;&#41;</a></p>
<p>Nice 大胆预测Linear speedup应该是每个程序员十年后的目标 呵呵</p>
<blockquote>
<p>On 3月23日, 上午10时43分, qiaojie <a href="&#x6d;&#x61;&#105;&#108;&#116;&#111;&#x3a;&#91;&#113;&#105;&#x61;&#x6f;&#46;&#x2e;&#46;&#x40;&#103;&#109;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#111;&#109;&#93;&#x28;&#41;">&#91;&#113;&#105;&#x61;&#x6f;&#46;&#x2e;&#46;&#x40;&#103;&#109;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#111;&#109;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>目前正在写的是一个软件渲染器，采用了光栅化和光线跟踪混合算法，渲染算法已经完全并行化了，
在4核系统上基本可以达到线性加速比，更多核的系统暂时还没测试。kd-tree的构造暂时还没有并
行化，以后有空了再研究。</p>
<p>2010/3/23 Guancheng Chen <a href="&#109;&#x61;&#x69;&#108;&#x74;&#x6f;&#x3a;&#91;&#x63;&#x68;&#101;&#110;&#103;&#x75;&#97;&#x6e;&#x63;&#104;&#x2e;&#x2e;&#46;&#x40;&#x67;&#109;&#97;&#x69;&#x6c;&#46;&#99;&#111;&#109;&#93;&#x28;&#41;">&#91;&#x63;&#x68;&#101;&#110;&#103;&#x75;&#97;&#x6e;&#x63;&#104;&#x2e;&#x2e;&#46;&#x40;&#x67;&#109;&#97;&#x69;&#x6c;&#46;&#99;&#111;&#109;&#93;&#x28;&#41;</a></p>
<blockquote>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？</p>
<p>On 3月23日, 上午9时15分, qiaojie <a href="&#x6d;&#x61;&#105;&#x6c;&#x74;&#111;&#x3a;&#x5b;&#113;&#x69;&#97;&#111;&#46;&#x2e;&#x2e;&#64;&#x67;&#109;&#x61;&#x69;&#x6c;&#46;&#99;&#x6f;&#109;&#x5d;&#40;&#41;">&#x5b;&#113;&#x69;&#97;&#111;&#46;&#x2e;&#x2e;&#64;&#x67;&#109;&#x61;&#x69;&#x6c;&#46;&#99;&#x6f;&#109;&#x5d;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1)
=
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank
Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？</p>
</blockquote>
<p> To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> tinyfool <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-25</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>哈哈，二位都平和一点，咱们继续回到技术讨论的主线吧</p>
<p>在 2010-3-25，下午2:40， qiaojie 写道：</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>恩，很快会被升华成为政治问题
2010/3/25 郝培强 tinyfool <a href="&#x6d;&#97;&#x69;&#108;&#116;&#111;&#58;&#x5b;&#116;&#x69;&#x6e;&#x79;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#109;&#x61;&#105;&#108;&#46;&#x63;&#111;&#109;&#x5d;&#40;&#x29;">&#x5b;&#116;&#x69;&#x6e;&#x79;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#109;&#x61;&#105;&#108;&#46;&#x63;&#111;&#109;&#x5d;&#40;&#x29;</a>
哈哈，终于从技术聊到经济了</p>
<p>在 2010-3-25，下午2:11， qiaojie 写道：</p>
<p>什么叫产能过剩？假设全世界每年消费10000亿斤粮食，结果今年收成好，生产了15000亿斤，</p>
<p>那多出来的5000亿斤无法被市场消化掉，就是产能过剩。那5000亿斤没价值，是垃圾？生产那
5000亿斤的农民是闲的蛋疼没事干？靠政府失业金养？</p>
<p>2010/3/25 机械唯物主义 : linjunhalida <a href="&#109;&#x61;&#x69;&#108;&#116;&#x6f;&#58;&#91;&#108;&#105;&#x6e;&#x6a;&#117;&#x6e;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#97;&#105;&#x6c;&#46;&#99;&#111;&#x6d;&#93;&#40;&#x29;">&#91;&#108;&#105;&#x6e;&#x6a;&#117;&#x6e;&#x2e;&#x2e;&#x2e;&#x40;&#103;&#x6d;&#97;&#105;&#x6c;&#46;&#99;&#111;&#x6d;&#93;&#40;&#x29;</a>
产能过剩的说法本来就不对。
产出的东西没有价值，这样的活动就不能说是生产。
比如我这个程序员，花了1周写了一个垃圾程序，然后被开除了。
然后1个月闲着，这是我产能过剩吗？
而闲着的原因是政府给我失业金，我就不需要工作闲起来了。。。</p>
<p>2010/3/25 qiaojie <a href="&#x6d;&#x61;&#105;&#x6c;&#x74;&#111;&#58;&#x5b;&#113;&#105;&#97;&#x2e;&#46;&#46;&#x40;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#46;&#x63;&#x6f;&#109;&#93;&#x28;&#x29;">&#x5b;&#113;&#105;&#97;&#x2e;&#46;&#46;&#x40;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#46;&#x63;&#x6f;&#109;&#93;&#x28;&#x29;</a>
如果产能=消费的话就没有产能过剩这一说了。</p>
<p>2010/3/25 机械唯物主义 : linjunhalida <a href="&#109;&#x61;&#105;&#x6c;&#x74;&#111;&#58;&#91;&#108;&#105;&#110;&#x6a;&#x75;&#110;&#46;&#46;&#46;&#64;&#x67;&#109;&#x61;&#105;&#108;&#x2e;&#99;&#x6f;&#x6d;&#93;&#40;&#x29;">&#91;&#108;&#105;&#110;&#x6a;&#x75;&#110;&#46;&#46;&#46;&#64;&#x67;&#109;&#x61;&#105;&#108;&#x2e;&#99;&#x6f;&#x6d;&#93;&#40;&#x29;</a></p>
<p>一个谬误：刺激需求
产能=消费，产能才是主动力。技术成长是随着产能成长而起来的。
而产能多的结果就是满足了需求，造成一种需求带来技术进步的假像。
而技术和产能之间的关系又错综复杂。。
2010/3/25 qiaojie <a href="&#x6d;&#97;&#x69;&#108;&#116;&#x6f;&#58;&#x5b;&#113;&#105;&#97;&#x2e;&#46;&#46;&#64;&#x67;&#x6d;&#97;&#x69;&#108;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#40;&#x29;">&#x5b;&#113;&#105;&#97;&#x2e;&#46;&#46;&#64;&#x67;&#x6d;&#97;&#x69;&#108;&#x2e;&#x63;&#111;&#x6d;&#x5d;&#40;&#x29;</a></p>
<p>3D游戏就是一类杀手应用，由此支撑起了一个庞大的GPU市场，芯片行业的研发成本是很高的，没有一个庞大的市场是做不起来的。目前的消费者对于多核系统显然还没有强烈的需求，因为应用跟不上，i7发布快2年了还没进入主流市场，这种情况延续下去的话摩尔定律将因此失效。不过我相信杀手级应用总会出现的，这可能要硬件性能突破一个临界点，比方说目前GPU的性能再提升一个数量级的话，光线跟踪算法就可以提供流畅的接近CG的画质，倒是此类应用便会流行开来。</p>
<p>2010/3/25 Guancheng Chen <a href="&#x6d;&#x61;&#105;&#x6c;&#x74;&#111;&#x3a;&#91;&#x63;&#x68;&#x65;&#x6e;&#103;&#x75;&#x2e;&#46;&#46;&#64;&#x67;&#x6d;&#x61;&#105;&#108;&#46;&#99;&#111;&#109;&#x5d;&#x28;&#41;">&#91;&#x63;&#x68;&#x65;&#x6e;&#103;&#x75;&#x2e;&#46;&#46;&#64;&#x67;&#x6d;&#x61;&#105;&#108;&#46;&#99;&#111;&#109;&#x5d;&#x28;&#41;</a></p>
<p>杀手应用一般来说是指什么样的应用呢？比如用户群特别大的网游？还是那些专有的科学计算用的软件？
On 3月24日, 下午12时36分, qiaojie <a href="&#x6d;&#97;&#x69;&#x6c;&#116;&#111;&#x3a;&#91;&#113;&#x69;&#97;&#111;&#46;&#46;&#x2e;&#x40;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#109;&#x5d;&#40;&#x29;">&#91;&#113;&#x69;&#97;&#111;&#46;&#46;&#x2e;&#x40;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#109;&#x5d;&#40;&#x29;</a> wrote:</p>
<blockquote>
<p>并行计算本来就是曲高和寡的东西，就跟3D渲染一样，能开发引擎的毕竟只是小部分人，大多数人在引擎的基础上做应用。关键在于是否有杀手应用，只要有大量的需求 ，自然会有人去做开发。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#109;&#97;&#105;&#x6c;&#116;&#111;&#58;&#91;&#104;&#x6f;&#x6e;&#103;&#x7a;&#104;&#x61;&#110;&#x67;&#46;&#x2e;&#46;&#46;&#64;&#x67;&#109;&#97;&#105;&#x6c;&#x2e;&#99;&#111;&#x6d;&#93;&#40;&#41;">&#91;&#104;&#x6f;&#x6e;&#103;&#x7a;&#104;&#x61;&#110;&#x67;&#46;&#x2e;&#46;&#46;&#64;&#x67;&#109;&#97;&#105;&#x6c;&#x2e;&#99;&#111;&#x6d;&#93;&#40;&#41;</a></p>
<blockquote>
<p>异构平台从网络处理器算起已经快10年了，现在情况仍然不明朗。就我看到的，异构平台要想高效，就必须向程序员暴露非常多的硬件细节，这必然导致编程的复杂性。 曲高和寡，要想渗透到应用程序这一块，我觉得很难。</p>
<p>2010/3/24 qiaojie <a href="&#109;&#97;&#x69;&#108;&#x74;&#111;&#58;&#x5b;&#x71;&#105;&#97;&#x6f;&#x2e;&#46;&#x2e;&#64;&#103;&#109;&#97;&#x69;&#108;&#x2e;&#99;&#111;&#x6d;&#93;&#40;&#x29;">&#x5b;&#x71;&#105;&#97;&#x6f;&#x2e;&#46;&#x2e;&#64;&#103;&#109;&#97;&#x69;&#108;&#x2e;&#99;&#111;&#x6d;&#93;&#40;&#x29;</a></p>
<blockquote>
<p>说的没错，cell已经成了先烈了。不过这不代表异构的方向不对，CUDA，OpenCL也都是异构平台，以后我们会越来越习惯异构平台的。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#x6d;&#97;&#105;&#x6c;&#116;&#111;&#58;&#91;&#104;&#111;&#110;&#103;&#122;&#104;&#x61;&#x6e;&#103;&#46;&#x2e;&#46;&#x2e;&#64;&#x67;&#109;&#x61;&#x69;&#x6c;&#46;&#99;&#111;&#x6d;&#93;&#40;&#41;">&#91;&#104;&#111;&#110;&#103;&#122;&#104;&#x61;&#x6e;&#103;&#46;&#x2e;&#46;&#x2e;&#64;&#x67;&#109;&#x61;&#x69;&#x6c;&#46;&#99;&#111;&#x6d;&#93;&#40;&#41;</a></p>
<p>异构平台如果编程复杂度降不下来的话很难流行起来。cell已经死了...</p>
<blockquote>
<p> 2010/3/24 qiaojie <a href="&#109;&#x61;&#105;&#x6c;&#116;&#111;&#x3a;&#x5b;&#x71;&#105;&#97;&#111;&#x2e;&#x2e;&#46;&#x40;&#103;&#109;&#97;&#105;&#x6c;&#46;&#99;&#x6f;&#109;&#93;&#40;&#x29;">&#x5b;&#x71;&#105;&#97;&#111;&#x2e;&#x2e;&#46;&#x40;&#103;&#109;&#97;&#105;&#x6c;&#46;&#99;&#x6f;&#109;&#93;&#40;&#x29;</a></p>
<blockquote>
<p>不是所有的程序都需要并行化的，能用串行化解决的问题没必要并行，所以即使将来many-core系统成为主流，大部分程序员也没必要去搞并行计算。
  我觉得未来的主流应该是类似cell这样一颗全功能核心带众多协处理核心的异构系统，这样才能达到最优的 性能/核心面积比。</p>
<p>2010/3/24 Guancheng Chen <a href="&#109;&#97;&#x69;&#108;&#116;&#111;&#x3a;&#91;&#99;&#x68;&#x65;&#110;&#x67;&#117;&#x61;&#110;&#99;&#104;&#46;&#46;&#46;&#x40;&#x67;&#x6d;&#97;&#x69;&#108;&#x2e;&#99;&#x6f;&#x6d;&#93;&#x28;&#41;">&#91;&#99;&#x68;&#x65;&#110;&#x67;&#117;&#x61;&#110;&#99;&#104;&#46;&#46;&#46;&#x40;&#x67;&#x6d;&#97;&#x69;&#108;&#x2e;&#99;&#x6f;&#x6d;&#93;&#x28;&#41;</a></p>
<p>Nice 大胆预测Linear speedup应该是每个程序员十年后的目标 呵呵</p>
<blockquote>
<p>On 3月23日, 上午10时43分, qiaojie <a href="&#x6d;&#97;&#x69;&#108;&#116;&#111;&#x3a;&#91;&#x71;&#105;&#x61;&#111;&#x2e;&#x2e;&#46;&#x40;&#x67;&#x6d;&#97;&#x69;&#x6c;&#46;&#99;&#111;&#109;&#x5d;&#x28;&#41;">&#91;&#x71;&#105;&#x61;&#111;&#x2e;&#x2e;&#46;&#x40;&#x67;&#x6d;&#97;&#x69;&#x6c;&#46;&#99;&#111;&#109;&#x5d;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>目前正在写的是一个软件渲染器，采用了光栅化和光线跟踪混合算法，渲染算法已经完全并行化了，
在4核系统上基本可以达到线性加速比，更多核的系统暂时还没测试。kd-tree的构造暂时还没有并
行化，以后有空了再研究。</p>
<p>2010/3/23 Guancheng Chen <a href="&#109;&#97;&#x69;&#108;&#116;&#111;&#58;&#x5b;&#x63;&#104;&#101;&#110;&#103;&#x75;&#97;&#x6e;&#99;&#x68;&#x2e;&#46;&#x2e;&#64;&#x67;&#x6d;&#97;&#x69;&#108;&#x2e;&#99;&#111;&#x6d;&#93;&#x28;&#x29;">&#x5b;&#x63;&#104;&#101;&#110;&#103;&#x75;&#97;&#x6e;&#99;&#x68;&#x2e;&#46;&#x2e;&#64;&#x67;&#x6d;&#97;&#x69;&#108;&#x2e;&#99;&#111;&#x6d;&#93;&#x28;&#x29;</a></p>
<blockquote>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？</p>
<p>On 3月23日, 上午9时15分, qiaojie <a href="&#109;&#x61;&#105;&#108;&#116;&#111;&#x3a;&#91;&#113;&#x69;&#x61;&#111;&#x2e;&#46;&#x2e;&#64;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#93;&#x28;&#x29;">&#91;&#113;&#x69;&#x61;&#111;&#x2e;&#46;&#x2e;&#64;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#111;&#x6d;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1)
=
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank
Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？</p>
</blockquote>
<p> To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a></p>
<p><img src="" alt=""> 机械唯物主义 : linjunhalida <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-25</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>恩，离题远了。不再讨论经济。</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>2010/3/25 郝培强 tinyfool <a href="&#109;&#x61;&#x69;&#108;&#x74;&#111;&#58;&#91;&#x74;&#x69;&#110;&#121;&#46;&#46;&#46;&#64;&#103;&#109;&#97;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#x29;">&#91;&#x74;&#x69;&#110;&#121;&#46;&#46;&#46;&#64;&#103;&#109;&#97;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#x5d;&#40;&#x29;</a>
哈哈，二位都平和一点，咱们继续回到技术讨论的主线吧</p>
<p>在 2010-3-25，下午2:40， qiaojie 写道：</p>
<p>恩，很快会被升华成为政治问题
2010/3/25 郝培强 tinyfool <a href="&#x6d;&#x61;&#105;&#x6c;&#116;&#x6f;&#58;&#x5b;&#x74;&#x69;&#x6e;&#121;&#46;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#97;&#x69;&#x6c;&#46;&#99;&#x6f;&#x6d;&#x5d;&#40;&#x29;">&#x5b;&#x74;&#x69;&#x6e;&#121;&#46;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#97;&#x69;&#x6c;&#46;&#99;&#x6f;&#x6d;&#x5d;&#40;&#x29;</a>
哈哈，终于从技术聊到经济了</p>
<p>在 2010-3-25，下午2:11， qiaojie 写道：</p>
<p>什么叫产能过剩？假设全世界每年消费10000亿斤粮食，结果今年收成好，生产了15000亿斤，</p>
<p>那多出来的5000亿斤无法被市场消化掉，就是产能过剩。那5000亿斤没价值，是垃圾？生产那
5000亿斤的农民是闲的蛋疼没事干？靠政府失业金养？</p>
<p>2010/3/25 机械唯物主义 : linjunhalida <a href="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#x6f;&#x3a;&#x5b;&#108;&#105;&#x6e;&#106;&#x75;&#110;&#x2e;&#46;&#46;&#64;&#x67;&#109;&#97;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#40;&#x29;">&#x5b;&#108;&#105;&#x6e;&#106;&#x75;&#110;&#x2e;&#46;&#46;&#64;&#x67;&#109;&#97;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#x5d;&#40;&#x29;</a>
产能过剩的说法本来就不对。
产出的东西没有价值，这样的活动就不能说是生产。
比如我这个程序员，花了1周写了一个垃圾程序，然后被开除了。
然后1个月闲着，这是我产能过剩吗？
而闲着的原因是政府给我失业金，我就不需要工作闲起来了。。。</p>
<p>2010/3/25 qiaojie <a href="&#109;&#x61;&#105;&#x6c;&#116;&#111;&#58;&#x5b;&#x71;&#105;&#97;&#x2e;&#x2e;&#46;&#x40;&#103;&#x6d;&#x61;&#105;&#108;&#x2e;&#99;&#111;&#109;&#x5d;&#x28;&#41;">&#x5b;&#x71;&#105;&#97;&#x2e;&#x2e;&#46;&#x40;&#103;&#x6d;&#x61;&#105;&#108;&#x2e;&#99;&#111;&#109;&#x5d;&#x28;&#41;</a>
如果产能=消费的话就没有产能过剩这一说了。</p>
<p>2010/3/25 机械唯物主义 : linjunhalida <a href="&#x6d;&#x61;&#105;&#x6c;&#116;&#111;&#58;&#x5b;&#108;&#105;&#110;&#106;&#117;&#110;&#46;&#46;&#x2e;&#x40;&#103;&#x6d;&#97;&#x69;&#x6c;&#46;&#x63;&#111;&#109;&#x5d;&#x28;&#x29;">&#x5b;&#108;&#105;&#110;&#106;&#117;&#110;&#46;&#46;&#x2e;&#x40;&#103;&#x6d;&#97;&#x69;&#x6c;&#46;&#x63;&#111;&#109;&#x5d;&#x28;&#x29;</a></p>
<p>一个谬误：刺激需求
产能=消费，产能才是主动力。技术成长是随着产能成长而起来的。
而产能多的结果就是满足了需求，造成一种需求带来技术进步的假像。
而技术和产能之间的关系又错综复杂。。
2010/3/25 qiaojie <a href="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#x6f;&#x3a;&#x5b;&#x71;&#105;&#97;&#46;&#46;&#x2e;&#64;&#x67;&#x6d;&#x61;&#105;&#108;&#x2e;&#99;&#111;&#x6d;&#93;&#x28;&#x29;">&#x5b;&#x71;&#105;&#97;&#46;&#46;&#x2e;&#64;&#x67;&#x6d;&#x61;&#105;&#108;&#x2e;&#99;&#111;&#x6d;&#93;&#x28;&#x29;</a></p>
<p>3D游戏就是一类杀手应用，由此支撑起了一个庞大的GPU市场，芯片行业的研发成本是很高的，没有一个庞大的市场是做不起来的。目前的消费者对于多核系统显然还没有强烈的需求，因为应用跟不上，i7发布快2年了还没进入主流市场，这种情况延续下去的话摩尔定律将因此失效。不过我相信杀手级应用总会出现的，这可能要硬件性能突破一个临界点，比方说目前GPU的性能再提升一个数量级的话，光线跟踪算法就可以提供流畅的接近CG的画质，倒是此类应用便会流行开来。</p>
<p>2010/3/25 Guancheng Chen <a href="&#x6d;&#x61;&#105;&#108;&#x74;&#x6f;&#58;&#x5b;&#x63;&#104;&#x65;&#x6e;&#103;&#x75;&#x2e;&#46;&#46;&#64;&#103;&#x6d;&#x61;&#105;&#108;&#46;&#x63;&#x6f;&#109;&#x5d;&#x28;&#x29;">&#x5b;&#x63;&#104;&#x65;&#x6e;&#103;&#x75;&#x2e;&#46;&#46;&#64;&#103;&#x6d;&#x61;&#105;&#108;&#46;&#x63;&#x6f;&#109;&#x5d;&#x28;&#x29;</a></p>
<p>杀手应用一般来说是指什么样的应用呢？比如用户群特别大的网游？还是那些专有的科学计算用的软件？
On 3月24日, 下午12时36分, qiaojie <a href="&#x6d;&#97;&#105;&#x6c;&#116;&#x6f;&#x3a;&#91;&#x71;&#105;&#97;&#x6f;&#46;&#x2e;&#46;&#64;&#x67;&#x6d;&#x61;&#105;&#108;&#x2e;&#x63;&#111;&#x6d;&#93;&#40;&#41;">&#91;&#x71;&#105;&#97;&#x6f;&#46;&#x2e;&#46;&#64;&#x67;&#x6d;&#x61;&#105;&#108;&#x2e;&#x63;&#111;&#x6d;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>并行计算本来就是曲高和寡的东西，就跟3D渲染一样，能开发引擎的毕竟只是小部分人，大多数人在引擎的基础上做应用。关键在于是否有杀手应用，只要有大量的需求 ，自然会有人去做开发。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#109;&#x61;&#105;&#108;&#116;&#x6f;&#58;&#x5b;&#104;&#111;&#110;&#103;&#x7a;&#x68;&#x61;&#110;&#103;&#x2e;&#x2e;&#46;&#x2e;&#64;&#x67;&#109;&#x61;&#105;&#108;&#x2e;&#x63;&#x6f;&#109;&#93;&#40;&#41;">&#x5b;&#104;&#111;&#110;&#103;&#x7a;&#x68;&#x61;&#110;&#103;&#x2e;&#x2e;&#46;&#x2e;&#64;&#x67;&#109;&#x61;&#105;&#108;&#x2e;&#x63;&#x6f;&#109;&#93;&#40;&#41;</a></p>
<blockquote>
<p>异构平台从网络处理器算起已经快10年了，现在情况仍然不明朗。就我看到的，异构平台要想高效，就必须向程序员暴露非常多的硬件细节，这必然导致编程的复杂性。 曲高和寡，要想渗透到应用程序这一块，我觉得很难。</p>
<p>2010/3/24 qiaojie <a href="&#x6d;&#97;&#x69;&#108;&#x74;&#111;&#58;&#x5b;&#x71;&#105;&#x61;&#111;&#x2e;&#x2e;&#x2e;&#64;&#103;&#x6d;&#97;&#105;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#93;&#40;&#x29;">&#x5b;&#x71;&#105;&#x61;&#111;&#x2e;&#x2e;&#x2e;&#64;&#103;&#x6d;&#97;&#105;&#x6c;&#x2e;&#99;&#x6f;&#x6d;&#93;&#40;&#x29;</a></p>
<blockquote>
<p>说的没错，cell已经成了先烈了。不过这不代表异构的方向不对，CUDA，OpenCL也都是异构平台，以后我们会越来越习惯异构平台的。</p>
<p>2010/3/24 Hongzhang Liu <a href="&#109;&#x61;&#105;&#108;&#116;&#111;&#x3a;&#x5b;&#x68;&#111;&#x6e;&#x67;&#x7a;&#x68;&#x61;&#x6e;&#103;&#46;&#x2e;&#x2e;&#46;&#x40;&#x67;&#109;&#x61;&#x69;&#x6c;&#46;&#99;&#111;&#x6d;&#x5d;&#x28;&#41;">&#x5b;&#x68;&#111;&#x6e;&#x67;&#x7a;&#x68;&#x61;&#x6e;&#103;&#46;&#x2e;&#x2e;&#46;&#x40;&#x67;&#109;&#x61;&#x69;&#x6c;&#46;&#99;&#111;&#x6d;&#x5d;&#x28;&#41;</a></p>
<p>异构平台如果编程复杂度降不下来的话很难流行起来。cell已经死了...</p>
<blockquote>
<p> 2010/3/24 qiaojie <a href="&#x6d;&#x61;&#105;&#108;&#116;&#111;&#x3a;&#x5b;&#x71;&#x69;&#97;&#x6f;&#x2e;&#46;&#46;&#x40;&#x67;&#109;&#x61;&#x69;&#x6c;&#46;&#x63;&#111;&#109;&#93;&#x28;&#x29;">&#x5b;&#x71;&#x69;&#97;&#x6f;&#x2e;&#46;&#46;&#x40;&#x67;&#109;&#x61;&#x69;&#x6c;&#46;&#x63;&#111;&#109;&#93;&#x28;&#x29;</a></p>
<blockquote>
<p>不是所有的程序都需要并行化的，能用串行化解决的问题没必要并行，所以即使将来many-core系统成为主流，大部分程序员也没必要去搞并行计算。
  我觉得未来的主流应该是类似cell这样一颗全功能核心带众多协处理核心的异构系统，这样才能达到最优的 性能/核心面积比。</p>
<p>2010/3/24 Guancheng Chen <a href="&#109;&#x61;&#105;&#x6c;&#x74;&#x6f;&#58;&#x5b;&#x63;&#104;&#x65;&#110;&#x67;&#x75;&#97;&#x6e;&#x63;&#104;&#x2e;&#46;&#46;&#64;&#x67;&#109;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#93;&#x28;&#41;">&#x5b;&#x63;&#104;&#x65;&#110;&#x67;&#x75;&#97;&#x6e;&#x63;&#104;&#x2e;&#46;&#46;&#64;&#x67;&#109;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#109;&#93;&#x28;&#41;</a></p>
<p>Nice 大胆预测Linear speedup应该是每个程序员十年后的目标 呵呵</p>
<blockquote>
<p>On 3月23日, 上午10时43分, qiaojie <a href="&#109;&#x61;&#105;&#108;&#116;&#x6f;&#x3a;&#91;&#113;&#x69;&#97;&#x6f;&#46;&#x2e;&#46;&#64;&#x67;&#109;&#x61;&#105;&#x6c;&#46;&#99;&#x6f;&#109;&#93;&#x28;&#41;">&#91;&#113;&#x69;&#97;&#x6f;&#46;&#x2e;&#46;&#64;&#x67;&#109;&#x61;&#105;&#x6c;&#46;&#99;&#x6f;&#109;&#93;&#x28;&#41;</a> wrote:</p>
<blockquote>
<p>目前正在写的是一个软件渲染器，采用了光栅化和光线跟踪混合算法，渲染算法已经完全并行化了，
在4核系统上基本可以达到线性加速比，更多核的系统暂时还没测试。kd-tree的构造暂时还没有并
行化，以后有空了再研究。</p>
<p>2010/3/23 Guancheng Chen <a href="&#109;&#x61;&#105;&#x6c;&#x74;&#x6f;&#58;&#x5b;&#99;&#104;&#101;&#x6e;&#103;&#x75;&#x61;&#110;&#99;&#104;&#x2e;&#x2e;&#46;&#64;&#x67;&#109;&#97;&#x69;&#108;&#46;&#99;&#111;&#109;&#x5d;&#40;&#x29;">&#x5b;&#99;&#104;&#101;&#x6e;&#103;&#x75;&#x61;&#110;&#99;&#104;&#x2e;&#x2e;&#46;&#64;&#x67;&#109;&#97;&#x69;&#108;&#46;&#99;&#111;&#109;&#x5d;&#40;&#x29;</a></p>
<blockquote>
<p>赞同。不知道您在实际项目中并行编程用的多么？是IO密集型还是CPU密集型的任务为主呢？</p>
<p>On 3月23日, 上午9时15分, qiaojie <a href="&#109;&#x61;&#105;&#x6c;&#x74;&#x6f;&#x3a;&#91;&#x71;&#x69;&#x61;&#x6f;&#46;&#46;&#46;&#x40;&#x67;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#40;&#41;">&#91;&#x71;&#x69;&#x61;&#x6f;&#46;&#46;&#46;&#x40;&#x67;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>看了大家关于关于并行编程的5大障碍的讨论，忍不住说几句。</p>
<p>比较赞同Alleluia同学的观点。Parallelism真正的难点不在于我的程序能不能并行，而在于并行了之后性能是否得以提升。
用Parallel的唯一目的是为了得到更好的性能，如果一个程序用串行算法就可以达到性能要求，改成并行除了浪费CPU之
外并无实际意义。而要通过并行算法得到令人满意的加速比是非常困难的事情。举一个现实中的例子做类比：在人月神话
一书中指出向一个将要延期的项目中盲目增加人手，不但不能按时交付，反而可能更加延长项目的交付。这个例子告诉我
们，一项任务的完成时间跟所用的人手并不成简单的线性关系，如果任务分解不当，人多反而帮倒忙，这个道理同样适用
于并行算法。</p>
<p>把一个串行算法改成并行算法，首先要看并行度，不是所有的部分都可以并行的，有些部分只能串行归并，只有那些并行的
部分才可以被多核加速，并行度对于多核的加速效果有着决定性作用，假设一个并行算法有90%的并行度，那么他在8核CPU
上得到的加速比就是1 / (0.9/8+0.1) = 4.7倍，而在100核上的加速比降低到了1 / (0.9/100+0.1)
=
5.26倍，所以说在多核上要得
到线性加速比是非常困难的，这个只是理想情况，并行化之后还会引入其他的overhead，另外目前的内存属于串行化访问的IO
设备，这在多核系统中将很容易成为瓶颈。所以在GPU上为了解决这个问题设置了多组内存Bank、加大位宽等方法来实施并行
化的内存访问，但是这也只能部分解决带宽问题，还是会碰上Bank
Conflict以及访问合并等问题，制约了GPU的scatter/gather
能力。</p>
<p>有些同学提到用FPL来解决并行化问题，我觉得是过于乐观了，FPL在学术界研究了几十年了，如果能解决并行化问题那早就解
决了，轮不到我们再去担心这个问题。FPL最大的问题，它是面向软件的抽象，而不是面向硬件的抽象。而并行化是为了解决性
能问题，所以面向硬件体系架构是必须的，所以纵使你FPL能很容易的写出并行化的程序，但是执行速度比串行化的C代码还慢，
那要并行化有何用？</p>
</blockquote>
<p> To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words
&quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
</blockquote>
</blockquote>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> 居振梁 <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-25</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>哈哈，估计有人想说“这次居然是收敛的”</p>
<p>2010/3/25 机械唯物主义 : linjunhalida <a href="&#109;&#x61;&#105;&#x6c;&#x74;&#111;&#x3a;&#x5b;&#x6c;&#105;&#110;&#x6a;&#x75;&#x6e;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#x61;&#105;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#x28;&#x29;">&#x5b;&#x6c;&#105;&#110;&#x6a;&#x75;&#x6e;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#x6d;&#x61;&#105;&#108;&#x2e;&#x63;&#x6f;&#x6d;&#93;&#x28;&#x29;</a></p>
<h2 id="-">恩，离题远了。不再讨论经济。</h2>
<p>御剑乘风来，除魔天地间。有酒乐逍遥，无酒我亦颠。
<a href="http://www.xspirithack.org/" target="_blank"><a href="http://www.xspirithack.org">http://www.xspirithack.org</a></a>
一饮尽江河，再饮吞日月。千杯醉不倒，唯我酒剑仙。
<a href="">显示删减掉的内容</a></p>
<p><img src="" alt=""> qiaojie <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-25</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>淡定....
2010/3/25 居振梁 <a href="&#x6d;&#x61;&#105;&#108;&#116;&#111;&#58;&#x5b;&#x6a;&#x75;&#x7a;&#104;&#x65;&#x2e;&#x2e;&#46;&#64;&#x67;&#109;&#97;&#105;&#108;&#46;&#99;&#x6f;&#109;&#x5d;&#40;&#x29;">&#x5b;&#x6a;&#x75;&#x7a;&#104;&#x65;&#x2e;&#x2e;&#46;&#64;&#x67;&#109;&#97;&#105;&#108;&#46;&#99;&#x6f;&#109;&#x5d;&#40;&#x29;</a></p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>哈哈，估计有人想说“这次居然是收敛的”</p>
<p>2010/3/25 机械唯物主义 : linjunhalida <a href="&#x6d;&#x61;&#x69;&#108;&#116;&#x6f;&#x3a;&#x5b;&#x6c;&#105;&#110;&#x6a;&#x75;&#110;&#x2e;&#46;&#x2e;&#x40;&#103;&#109;&#x61;&#105;&#108;&#x2e;&#99;&#x6f;&#x6d;&#93;&#40;&#41;">&#x5b;&#x6c;&#105;&#110;&#x6a;&#x75;&#110;&#x2e;&#46;&#x2e;&#x40;&#103;&#109;&#x61;&#105;&#108;&#x2e;&#99;&#x6f;&#x6d;&#93;&#40;&#41;</a></p>
<h2 id="-"> 恩，离题远了。不再讨论经济。</h2>
<p>御剑乘风来，除魔天地间。有酒乐逍遥，无酒我亦颠。
<a href="http://www.xspirithack.org/" target="_blank"><a href="http://www.xspirithack.org">http://www.xspirithack.org</a></a>
一饮尽江河，再饮吞日月。千杯醉不倒，唯我酒剑仙。</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a>
<img src="" alt=""> tinyfool <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-25</p>
<p>Re: [TL] Re: {技术}{多线程}实施并行编程的五大障碍</p>
<p>其他收件人：</p>
<p>呵呵，其实咱们组真的已经是互联网上讨论组里面，最平和，最专业的一个了。</p>
<p>大家有时候稍微相互包容点，就不至于弄得大家都不愉快的，我们还是挺好的。
不准老幸灾乐祸，惟恐天下不乱的，哈哈</p>
<p>技术讨论技术吧
我继续鼓吹OPENCL，哈哈</p>
<p>在 2010-3-25，下午2:44， 居振梁 写道：</p>
<ul>
<li>显示引用文字 -</li>
</ul>
<p>哈哈，估计有人想说“这次居然是收敛的”</p>
<p>2010/3/25 机械唯物主义 : linjunhalida <a href="&#x6d;&#x61;&#105;&#108;&#x74;&#111;&#58;&#91;&#x6c;&#x69;&#x6e;&#106;&#117;&#x6e;&#46;&#x2e;&#46;&#x40;&#x67;&#109;&#97;&#x69;&#x6c;&#46;&#x63;&#111;&#x6d;&#93;&#40;&#x29;">&#91;&#x6c;&#x69;&#x6e;&#106;&#117;&#x6e;&#46;&#x2e;&#46;&#x40;&#x67;&#109;&#97;&#x69;&#x6c;&#46;&#x63;&#111;&#x6d;&#93;&#40;&#x29;</a></p>
<h2 id="-">恩，离题远了。不再讨论经济。</h2>
<p>御剑乘风来，除魔天地间。有酒乐逍遥，无酒我亦颠。
<a href="http://www.xspirithack.org/" target="_blank"><a href="http://www.xspirithack.org">http://www.xspirithack.org</a></a>
一饮尽江河，再饮吞日月。千杯醉不倒，唯我酒剑仙。</p>
<p>To unsubscribe from this group, send email to pongba+<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE ME&quot; as the subject.
<a href="">显示删减掉的内容</a></p>
<p><img src="" alt=""> fxc...@gmail.com <img src="" alt=""></p>
<p><img src="" alt=""></p>
<p>10-3-26</p>
<p>其他收件人：</p>
<p>好吧，俺也打个广告。
既然大家都说tools是concurrent的一个大issue。那不妨看看MS的Concurrency工具包：Parallel
Debugger/Parallel Profiler. 在下一个版本VS里面会加入Static Analysis的support。
<a href="http://msdn.microsoft.com/en-us/concurrency/default.aspx" target="_blank">msdn.microsoft.com/en-us/concurrency/default.aspx</a></p>
<p>On Mar 24, 9:04 am, 莫华枫 <a href="&#x6d;&#x61;&#105;&#x6c;&#116;&#x6f;&#58;&#91;&#x6c;&#111;&#110;&#103;&#x73;&#104;&#x61;&#x6e;&#107;&#x2e;&#46;&#x2e;&#64;&#103;&#109;&#x61;&#x69;&#108;&#46;&#x63;&#x6f;&#109;&#93;&#40;&#41;">&#91;&#x6c;&#111;&#110;&#103;&#x73;&#104;&#x61;&#x6e;&#107;&#x2e;&#46;&#x2e;&#64;&#103;&#109;&#x61;&#x69;&#108;&#46;&#x63;&#x6f;&#109;&#93;&#40;&#41;</a> wrote:</p>
<blockquote>
<p>凑个热闹，也来个广告：CERL 2.0初具雏形。</p>
<p>--
反者道之动，弱者道之用
longshank...@gmail.com<a href="http://[blog.csdn.net/longshanks/](http://blog.csdn.net/longshanks/" target="_blank">http://[blog.csdn.net/longshanks/](http://blog.csdn.net/longshanks/</a>)
wave开通
<a href="">显示删减掉的内容</a>
<img src="" alt=""> AWu <img src="" alt=""></p>
</blockquote>
<p><img src="" alt=""></p>
<p>10-3-28</p>
<p>其他收件人：</p>
<p>这不是逼俺买MBP嘛？</p>
<p>感觉并行需要有足够简单，足够可靠的工程实施方法才能够大规模得被应用～
毕竟IT业从业人员不是所有人都足够聪明能够写得了、分析得了并行</p>
<p>一个可靠的工程方法来规避并行可能引发的性能或者功能缺陷，如果能够抽象到库里面规避当然更好，但是库这个东西得有足够多的工程实践才能做得出来吧，所
以我认为第一步是有一个可行的并行工程实施方法。</p>
<p>On 3月22日, 下午2时06分, Guancheng Chen <a href="&#109;&#x61;&#x69;&#108;&#116;&#x6f;&#x3a;&#x5b;&#x63;&#104;&#101;&#x6e;&#103;&#x75;&#97;&#x6e;&#x63;&#x68;&#46;&#x2e;&#46;&#64;&#103;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#109;&#93;&#x28;&#x29;">&#x5b;&#x63;&#104;&#101;&#x6e;&#103;&#x75;&#97;&#x6e;&#x63;&#x68;&#46;&#x2e;&#46;&#64;&#103;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#109;&#93;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>我还以为GCD是指最大公约数，搜了一下原来也是类似task parallelism的库 受您蛊惑 下一次我要买Macbook Pro了。。。</p>
<p>On 3月22日, 上午2时20分, Tinyfool <a href="&#x6d;&#97;&#105;&#108;&#116;&#x6f;&#x3a;&#x5b;&#x74;&#105;&#110;&#x79;&#102;&#46;&#x2e;&#x2e;&#x40;&#103;&#109;&#97;&#105;&#x6c;&#46;&#99;&#x6f;&#109;&#x5d;&#x28;&#x29;">&#x5b;&#x74;&#105;&#110;&#x79;&#102;&#46;&#x2e;&#x2e;&#x40;&#103;&#109;&#97;&#105;&#x6c;&#46;&#99;&#x6f;&#109;&#x5d;&#x28;&#x29;</a> wrote:</p>
<blockquote>
<p>唉，本来不想广告的，既然赵姐夫都冒出来了，我也来广告一下</p>
<p>Mac OS X最新的并行机制叫做GCD，靠，听名字就知道无比强大了吧？</p>
<p>还有支持显卡计算的OpenCL也是无比强大啊。</p>
<p>2010/3/22 Jeffrey Zhao <a href="&#x6d;&#x61;&#x69;&#108;&#x74;&#111;&#58;&#x5b;&#106;&#x65;&#46;&#46;&#x2e;&#x40;&#x6c;&#105;&#x76;&#101;&#46;&#99;&#111;&#109;&#x5d;&#x28;&#41;">&#x5b;&#106;&#x65;&#46;&#46;&#x2e;&#x40;&#x6c;&#105;&#x76;&#101;&#46;&#99;&#111;&#109;&#x5d;&#x28;&#41;</a></p>
<blockquote>
<p> 我来做广告：有了并行库、或是F/#这种语言的支持，并行编程已经容易很多了。开发效率，执行效率，可维护性都可以有显著提高。</p>
<p>其实还是&quot;抽象&quot;这个万能武器的作用，只要有牛人把容易出问题的东西隐藏起来，封装起来，给一个好用的抽象，对大部分程序员来说就能美好许多。</p>
<p>例如Memory Consistency，让JVM或CLR那样在各CPU架构中统一起来，即便是没有并行库的支持，写并行程序已经可以轻松很多了。</p>
<p>至于教育上......我觉得其实这个问题倒不是并行特有的，也不是并行上面表现的更彻底，而是（国内）本来就没多少人被教育好。</p>
<p>例如计算机体系结构，操作系统等等。这虽然和并行有关，但也不是并行特有的东西。</p>
<p>Jeffrey Zhao
Blog:<a href="http://www.cnblogs.com/JeffreyZhao/" target="_blank"><a href="http://www.cnblogs.com/JeffreyZhao/">http://www.cnblogs.com/JeffreyZhao/</a></a>
Twitter:<a href="https://twitter.com/jeffz_cn" target="_blank"><a href="https://twitter.com/jeffz_cn">https://twitter.com/jeffz_cn</a></a></p>
<p> /<em>From:/</em> Guancheng Chen <a href="&#109;&#97;&#x69;&#108;&#x74;&#111;&#x3a;&#x5b;&#99;&#104;&#x65;&#x6e;&#x67;&#x75;&#97;&#x6e;&#x63;&#x68;&#46;&#x2e;&#46;&#x40;&#x67;&#x6d;&#x61;&#105;&#108;&#x2e;&#99;&#x6f;&#109;&#x5d;&#40;&#41;">&#x5b;&#99;&#104;&#x65;&#x6e;&#x67;&#x75;&#97;&#x6e;&#x63;&#x68;&#46;&#x2e;&#46;&#x40;&#x67;&#x6d;&#x61;&#105;&#108;&#x2e;&#99;&#x6f;&#109;&#x5d;&#40;&#41;</a>
/<em>Sent:/</em> Monday, March 22, 2010 7:37 AM
/<em>To:/</em> TopLanguage <a href="&#109;&#97;&#105;&#x6c;&#x74;&#111;&#x3a;&#x5b;&#x70;&#111;&#110;&#46;&#x2e;&#46;&#x40;&#103;&#x6f;&#111;&#x67;&#x6c;&#x65;&#x67;&#114;&#111;&#x75;&#x70;&#x73;&#46;&#x63;&#x6f;&#x6d;&#93;&#40;&#x29;">&#x5b;&#x70;&#111;&#110;&#46;&#x2e;&#46;&#x40;&#103;&#x6f;&#111;&#x67;&#x6c;&#x65;&#x67;&#114;&#111;&#x75;&#x70;&#x73;&#46;&#x63;&#x6f;&#x6d;&#93;&#40;&#x29;</a>
/<em>Subject:/</em> [TL] {技术}{多线程}实施并行编程的五大障碍</p>
<p>近期看见一篇来自Intel的很有意思的分析文章，作者提到在他向45名与会的各公司程序员/开发经理/战略师提问&quot;什么是实施并行编程的最大障
碍&quot;时，下面五个因素被提及的次数最多：遗留代码(legacy code)、教育(education)、工具(tools)、对众核趋势的恐惧
(fear of many cores)以及可维护性(maintainability)。文章虽然是一篇Intel Parallel
Studio的软文，但是其中提及的这五大障碍却非常值得讨论，下面是我对这五大障碍的一些粗浅看法，希望能起到一个抛砖引玉的作用，欢迎大家给出你们
的看法。</p>
<p>( 注：好像Google Group让我原文的一些超链接都失效了，如果想有更好的阅读体验，请看</p>
<p><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-." target="_blank"><a href="http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-">http://www.parallellabs.com/2010/03/22/five-obstacles-that-slow-down-</a>.</a>..
)</p>
<ol>
<li><p>遗留代码
众所周知，并行化实施最大的困难在于怎样把公司的那些遗留代码给并行化。100K~1000K的代码量都非常正常，而并行编程本身又是非常容易出错的，
一大堆诸如data race, dependency, non-deterministic, memory consistency,
dead lock, serialization bottleneck, thread safe等的问题随便哪一个拉出来都让人头大，更别说要高
效可靠的并行化这些庞大的遗留代码了。更困难的是很多遗留代码还有编写者已经离职，文档注释不全等问题，这无疑是雪上加霜。从成本上来讲，如果能通过一
些优秀的编译器(例如Intel的ICC)自动并行化一些遗留代码无疑是最省钱的，但是这种方法最大的缺陷就在于像Intel ICC这种自动型编译器
能自动并行化的代码非常少，从而导致它能提供的性能优化非常有限，而且就算是真正能获得speedup的代码也有很多约束条件(例如loop的循环之间
没有dependence，并且该loop应该是一个程序热点)。所以目前的现状就是大量的遗留代码并不能有效的被并行化，从商业的角度上来讲，如果能
有一种解决方案能在短时间内快速可靠的通过实施并行化让遗留代码获得10%~30%的性能提升，那么它就已经能为公司节省大量成本了。</p>
</li>
<li><p>教育
第二大的障碍可能就是程序员缺乏并行编程方面的教育了。其实并行编程已经有二三十年的历史了，不过在多核CPU出现之前那些并行编程都是&quot;专家&quot;们的玩
具。那时候的并行编程大都是跑在集群、大型机或者服务器上，通过MPI(message passing model)或者SMP(对称多处理器，即一
个主板上有多个单核CPU，属于shared memory model)来完成并行计算。Pthread标准是1995年建立的，之后出来了
Windows版的Win32 thread，后来又出来了&quot;编译指导&quot;、面向data parallel模型的OpenMP(OpenMP 3.0加
入了task parallel支持)，task parallel的鼻祖Click，Intel的Intel Thread Building
Block(task parallel)，Java 1.5开始对多线程提供较好的支持(加入了Java Memory Model)，近几年随着
GPU的发展，Nvidia又开始搞CUDA(data-parallel)，Apple一看不对，并行编程以后是主流啊，我得插一手，于是自己撑旗弄
了个针对CPU和GPU混合编程的OpenCL，微软一看也坐不住了也要随着Visual Studio2010开始搞C/#的并行库，马上C++0x也
要加入多线程支持，甚至连老古董Erlang也因为天生支持并行被重新热炒，总之随着摩尔定律在串行世界的失效，整个业界都开始被迫往并行编程方向发
展。</p>
</li>
</ol>
<p>可是对程序员来说呢是什么情况呢？我们现在所接受的教育大都还是串行世界的那些算法和数据结构，高德纳在一篇访谈里说&quot;在我看来，这种现象或多或少是由
于硬件设计者已经无计可施了导致的，他们将Moore定律失效的责任推脱给软件开发者，而他们给我们的机器只是在某些指标上运行得更快了而已。如果多线
程的想法被证明是失败的，我一点都不会感到惊讶......你听说过有多少程序员对这种未来一片光明的机器抱有强烈的兴趣？我几乎没有听说过，除了他们的诉苦。
尽管我们学院那些搞硬件的家伙一直想让我相信我是错的&quot;，可见硬件发展被迫向多核转移直接导致程序员们免费的午餐已经结束了。那么程序员现在受到良好的
并行编程教育了吗？很显然，现在随便问一个普通的程序员：&quot;你觉得并行编程容易么？&quot;，十有八九会说&quot;我觉得很难&quot;。前一阵有人讨论服务器编程用多线程
好还是多进程好？其实根本原因就在于哪怕多线程有性能优势，可是isolation的多进程模式能在programming productivity
和performance之间找到比较好的折衷，所以国内很有服务器开发者都选择了多进程(例如云风)。从大趋势上来讲，不管是研究体系机构的，还是写
OS/Compiler的，还是定义编程语言的，现在都在积极努力的为广大的程序员提供一个更容易使用的并行编程模型，Intel这几年不也在搞多核培
训么，这都是好现象，但是，离真正的全民并行编程时代还有相当长的路要走。近几年的IT技术热门书单里面很少有并行编程的书籍就是个很好的写照。</p>
<ol>
<li>工具
工欲善其事，必先利其器。那么现阶段我们能用的，并且好用的并行编程工具有多少呢（欢迎大家补充）？</li>
</ol>
<p>(1) IDE: Intel Parallel Studio，微软马上出来的VS2010算一个，Sun的Sun Studio(不知道它的未来如
何，但是它本来就很小众)，Nvidia的CUDA平台什么的就先不算了
(2) Compiler: Intel的ICC(能自动并行化一些代码)，Nema Labs的FASThread(针对遗留代码的解决方案，能快速
可靠的指导程序员实施并行化)
(3) Performance Tuning: Intel Vtune Analyzer(综合性能分析)，Thread profiler，
Acumem的Thread Spotter(针对多核Cache的性能分析和优化)
(4) Debugging: Petra的Jinx</p>
<p>总体上我个人觉得它们对程序员来说确实有用，但是前提条件是你要会用。这其实又跟第二点&quot;教育&quot;有很大关系了。</p>
<ol>
<li><p>对众核的恐惧
现在我们看到4核已经非常普遍了，等过几年那可就是8核，16核，32核了。怎样确保你的代码在核数倍增的趋势下仍能有很好的性能，很好的可伸缩性？这
真的是个问题。我现在所做的研究就是多线程程序中锁竞争的性能分析，目的就是为了帮助程序员更好的解决由锁竞争造成的性能瓶颈。实际上，为了得到很好的
可伸缩性，程序员需要往往需要使用并行友好的数据结构(例如concurrent hash map)，使用细粒度的锁甚至无锁编程，设计data
parallel的算法，性能调优(例如典型的false sharing问题)等等等等，这其中每一项都是不小的挑战。我曾经翻译过的一篇文章对设计
多线程程序提供了一些有用的建议。</p>
</li>
<li><p>可维护性
毫无疑问，我们希望并行代码能够与现存的runtime系统、build系统以及其他现有代码一起正确的工作，我们更希望这些并行代码易于理解、便于维
护并且有较长的生命周期。可是现阶段真正掌握并行编程的程序员少之又少，而且并行编程又是这么困难，哪怕你对这些并行代码只是做一些小小的改动都很有可
能导致新的bug，新的性能瓶颈，那真的是一件非常痛苦的事情。</p>
</li>
</ol>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
<p>To unsubscribe from this group, send email to pongba+
<a href="http://unsubscribegooglegroups.com/" target="_blank">unsubscribegooglegroups.com</a> or reply to this email with the words &quot;REMOVE
ME&quot; as the subject.</p>
</blockquote>
<p>--
Tinyfool的开发日记<a href="http://www.tinydust.net/dev/" target="_blank"><a href="http://www.tinydust.net/dev/">http://www.tinydust.net/dev/</a></a>
代码中国网<a href="http://www.codechina.org/" target="_blank"><a href="http://www.codechina.org">http://www.codechina.org</a></a>
myTwitter:<a href="http://twitter.com/tinyfool" target="_blank"><a href="http://twitter.com/tinyfool">http://twitter.com/tinyfool</a></a>
<a href="">显示删减掉的内容</a>
上一页 <a href="">上一页</a>  </p>
</blockquote>
</blockquote>
<p>第 <strong>1</strong> 页
  下一页 <a href="">下一页</a></p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/好文摘录/">好文摘录</a></li></span></span> | <span class="time">recent updated:<time title="2014-03-07 11:24:30"datetime="2014-03-07 11:24:30"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/03/2014-02-03--{技术}{多线程}实施并行编程的五大障碍/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-03--{技术}{多线程}实施并行编程的五大障碍" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/03/2014-02-03--BruceEckel：编程生涯/">Bruce Eckel：编程生涯</a></h1>
      
        <span>Posted on<time datetime="2014-02-03T03:24:29.000Z"> <a href="/2014/02/03/2014-02-03--BruceEckel：编程生涯/">feb. 3 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="bruce-eckel-">Bruce Eckel：编程生涯</h1>
<p><strong>EN文：</strong></p>
<p>Computing Thoughts
A Career in Computing
by Bruce Eckel
June 2, 2009
 <strong>Summary</strong>
I regularly receive requests for career advice, and I&#39;ve tried to capture the answers in this blog, and in a follow-on. For those of you who asked but never got an answer, I apologize. Your questions stimulated me to work on this, and it&#39;s taken awhile.</p>
<p>The question that people ask is usually the wrong one: &quot;should I learn C++ or Java?&quot; In this essay, I shall try to lay out my view of the true issues involved in choosing a career in computing.</p>
<p>Note that I am not talking here to the people who already know it is their calling. You&#39;re going to do it regardless of what anyone says, because it&#39;s in your blood and you can&#39;t get away from it. You know the answer already: C++ AND Java AND shell scripting AND Python AND a host of other languages and technologies that you&#39;ll learn as a matter of course. You already know several of these languages, even if you&#39;re only 14.</p>
<p>The person who asks me this question may be coming from another career. Or perhaps they are coming from a field like web development and they&#39;ve figured out that HTML is only kind of like programming, and they&#39;d like to try building something more substantial. But I especially hope that, if you are asking this question, you&#39;ve realized that to be successful in computing, you need to teach yourself how to learn, and never stop learning.</p>
<p>The more I do this, the more it seems to me that software is <a href="http://www.artima.com/weblogs/viewpost.jsp?thread=255898" target="_blank">more akin to writing</a> than anything else. And we haven&#39;t figured out what makes a good writer, we only know when we like what someone writes. This is not some kind of engineering where all we have to do is put something in one end and turn the crank. It is tempting to think of software as deterministic -- that&#39;s what we want it to be, and that&#39;s the reason that we keep coming up with tools to help us produce the behavior we desire. But my experience keeps indicating the opposite, that it is more about people than processes, and the fact that it runs on a deterministic machine becomes less and less of an influence, just like the Heisenberg principle doesn&#39;t affect things on a human scale.</p>
<p>My father built custom homes, and in my youth I would occasionally work for him, mostly doing grunt labor and sometimes hanging sheet rock. He and his lead carpenter would tell me that they gave me these jobs for my own good -- so that I wouldn&#39;t go into the business. It worked.</p>
<p>So I can also use the analogy that building software is like building a house. We don&#39;t refer to everyone who works on a house as if they were exactly the same. There are concrete masons, roofers, plumbers, electricians, sheet rockers, plasterers, tile setters, laborers, rough carpenters, finish carpenters, and of course, general contractors. Each of these requires a different set of skills, which requires a different amount of time and effort to acquire. House-building is also subject to boom and bust cycles, like programming. If you want to get in quick, you might take a job as a laborer or a sheet rocker, where you can start getting paid without much of a learning curve. As long as demmand is strong, you have steady work, and your pay might even go up if there aren&#39;t enough people to do the work. But as soon as there&#39;s a downturn, carpenters and even the general contractor can hang the sheet rock themselves.</p>
<p>When the Internet was first booming, all you had to do was spend some time learning HTML and you could get a job and earn some pretty good money. When things turned down, however, it rapidly becomes clear that there is a hierarchy of desirable skills, and the HTML programmers (like the laborers and sheet rockers) go first, while the highly-skilled code smiths and carpenters are retained.</p>
<p>What I&#39;m trying to say here is that you don&#39;t want to go into this business unless you are ready to commit to lifelong learning. Sometimes it seems like programming is a well-paying, reliable job -- but the only way you can make sure of this is if you are always making yourself more valuable.</p>
<p>Of course you can find exceptions. There are always those people who learn one language and are just competent enough and perhaps savvy enough to stay employed without doing much to expand their abilities. But they are surviving by luck, and they are ultimately vulnerable. To make yourself less vulnerable, you need to continuously improve your abilities, by reading, going to user groups, conferences, and seminars. The more depth you have in this field, the more valuable you will be, which means you have more stable job prospects and can command higher salaries.</p>
<p>Another approach is to look at the field in general, and find a place where you already have talents. For example, my brother is interested in software, and dabbles with it, but his business is in installing computers, fixing them and upgrading them. He&#39;s always been meticulous, so when he installs or fixes your computer you know that it will be in excellent shape when he&#39;s done; not just the software, but all the way down to the cables, which will be bundled neat and out of the way. He&#39;s always had more work than he could do, and he never noticed the dot-com bust. And needless to say, his work cannot be offshored.</p>
<p>I stayed in college a long time, and managed to get by in various ways. I even began a Ph.D. program at UCLA, which was mercifully cut short -- I say mercifully because I no longer loved being in college, and the reason I stayed in college for so long was because I enjoyed it so much. But what I enjoyed was typically the off-track stuff. Art and dance classes, working on the college newspaper, and even the handful of computer programming classes that I took (which were off-track because I was a physics undergrad and a computer <em>engineering</em> graduate student). Although I was far from exceptional academically (a delightful irony is that many colleges that would not have accepted me as a student now use my books in their courses!), I really enjoyed the life of the college student, and had I finished a Ph.D. I probably would have taken the easy path and ended up a professor.</p>
<p>But as it turns out, some of the greatest value that I got from college was from those same off-track courses, the ones that expanded my mind beyond &quot;stuff we already know.&quot; I think this is especially true in computing because you are always programming to support some other goal, and the more you know about that goal the better you&#39;ll perform (I&#39;ve encountered some European graduate programs that require the study of computing in combination with some other specialty, and you build your thesis by solving a domain-specific problem in that other specialty).</p>
<p>I also think that knowing more than just programming vastly improves your problem-solving skills (just as knowing more than one programming language vastly improves your programming skills). On multiple occasions I have encountered people, trained only in computer science, who seem to have more limits in their thinking than those who come from some other background, like math or physics, which requires more rigorous thinking and is less prone to &quot;it works for me&quot; solutions.</p>
<p>In one session a conference that I organized, one of the topics was to come up with a list of features for the ideal job candidate:</p>
<ul>
<li>Learning as a lifestyle. For example, you should know more than one language; nothing opens your eyes more to the strengths and limitations of a language than learning another one.</li>
<li>Know where and how to get new knowledge.</li>
<li>Study prior art.</li>
<li>We are tool users.</li>
<li>Learn to do the simplest thing.</li>
<li>Understand the business (Read magazines. Start with Fast Company, which has very short and interesting articles. Then you can see if you want to read others)</li>
<li>You are personally responsible for errors. &quot;It works for me&quot; is not an acceptable strategy. Find your own bugs.</li>
<li>Become a leader: someone who communicates and inspires.</li>
<li>Who are you serving?</li>
<li>There is no right answer ... and always a better way. Show and discuss your code, without emotional attachment. You are not your code.</li>
<li>It&#39;s an asymptotic journey towards perfection.</li>
</ul>
<p>Take whatever risks you can -- the best risks are the scary ones, but in trying you will feel more alive than you can imagine. It&#39;s best if you don&#39;t plan for a particular outcome, because you will often miss the true possibilities if you&#39;re too attached to a result. My best adventures have been ones that have started with &quot;lets do a little experiment and see where it takes us.</p>
<p>Some people will be disappointed by this answer, and reply &quot;yes, that&#39;s all very interesting and useful. But really, what should I learn? C++ or Java?&quot; I&#39;ll fend these off by repeating here: I know it seems like all the ones and zeroes should make everything deterministic, so that such questions should have a simple answer, but they don&#39;t. It&#39;s not about making one choice and being done with it. It&#39;s about continuous learning and sometimes, bold choices. Trust me, your life will be more exciting this way.</p>
<h1 id="-further-reading-"><a href="">Further Reading</a></h1>
<p>Here&#39;s an earlier piece I wrote on <a href="http://mindview.net/WebLog/log-0030" target="_blank">how I got started in programming</a>.
I found all these to be interesting and stimulating takes on the same subject: </p>
<ul>
<li>Teach yourself programming in ten years, by Peter Norvig: <a href="http://norvig.com/21-days.html" target="_blank"><a href="http://norvig.com/21-days.html">http://norvig.com/21-days.html</a></a></li>
<li>How to be a Programmer, by Robert Read: <a href="http://samizdat.mines.edu/howto/HowToBeAProgrammer.html" target="_blank"><a href="http://samizdat.mines.edu/howto/HowToBeAProgrammer.html">http://samizdat.mines.edu/howto/HowToBeAProgrammer.html</a></a></li>
<li>Here&#39;s a <a href="http://news-service.stanford.edu/news/2005/june15/jobs-061505.html" target="_blank">speech by Steve Jobs</a>, trying to inspire a group of graduating college students.</li>
<li>Kathy Sierra: Does College Matter? <a href="http://headrush.typepad.com/creating_passionate_users/2005/07/does_college_ma.html" target="_blank"><a href="http://headrush.typepad.com/creating_passionate_users/2005/07/does_college_ma.html">http://headrush.typepad.com/creating_passionate_users/2005/07/does_college_ma.html</a></a></li>
<li><a href="http://www.paulgraham.com/college.html" target="_blank"><a href="http://www.paulgraham.com/college.html">http://www.paulgraham.com/college.html</a></a></li>
<li><a href="http://www.joelonsoftware.com/articles/CollegeAdvice.html" target="_blank"><a href="http://www.joelonsoftware.com/articles/CollegeAdvice.html">http://www.joelonsoftware.com/articles/CollegeAdvice.html</a></a></li>
<li><a href="http://www.jamesshore.com/Blog/Five-Design-Skills.html" target="_blank"><a href="http://www.jamesshore.com/Blog/Five-Design-Skills.html">http://www.jamesshore.com/Blog/Five-Design-Skills.html</a></a></li>
<li><a href="http://steve-yegge.blogspot.com/2006/03/truth-about-interviewing.html" target="_blank"><a href="http://steve-yegge.blogspot.com/2006/03/truth-about-interviewing.html">http://steve-yegge.blogspot.com/2006/03/truth-about-interviewing.html</a></a></li>
</ul>
<p>In a future article (I&#39;ll post the link here when it&#39;s done), I will talk about the importance of understanding management and business issues, whether or not you ever plan to be a manager, and in that article I&#39;ll include a list of books that (even though they&#39;re about management) you should read to prepare yourself for your career.</p>
<h1 id="talk-back-">Talk Back!</h1>
<p>Have an opinion? Readers have already posted <a href="http://www.artima.com/forums/flat.jsp?forum=106&amp;thread=259358" target="_blank">24 comments</a> about this weblog entry. Why not <a href="http://www.artima.com/forums/post.jsp?forum=106&amp;thread=259358&amp;reply=true" target="_blank">add yours</a>?</p>
<h1 id="rss-feed">RSS Feed</h1>
<p>If you&#39;d like to be notified whenever Bruce Eckel adds a new entry to <a href="http://www.artima.com/weblogs/index.jsp?blogger=beckel" target="_blank">his weblog</a>, subscribe to his <a href="http://www.artima.com/weblogs/feeds/bloggers/beckel.rss" target="_blank">RSS feed</a>.  </p>
<hr>
<p><strong>中文：</strong></p>
<p><strong>Bruce Eckel：编程生涯</strong></p>
<p>作者 <strong>Bruce Eckel</strong> 是编程界的大牛，著有大名鼎鼎的《Thinking in C++》和《Thinking in Java》。
本文是他对程序员（尤其是新手）的忠告。</p>
<p>================华丽的分割线================</p>
<p>大家总是问一个错误的问题：“我应该学习C++还是Java？”在本文中，我将告诉大伙儿：对于选择编程生涯真正需要关注的是哪些问题。</p>
<p>请 注意，这篇文章的目标读者并不是那些已经做出自己选择的人。（对于这些人而言）你会继续自己的编程生涯，而不管别人会怎么说。因为它已经渗透到你的血液 中，你已经无法摆脱。你已经知道答案：C++、Java、Shell脚本、Python、还有其它一大堆的语言和技术，你都理所当然地会去学习。甚至有可 能你才仅仅14岁，就已经知道好几种不同的语言。</p>
<p>问我这样的问题的人可能来自其他行业，或者来自诸如Web开发之类的领域。他们知道HTML是一种类编程语言，而且想尝试构建某些更大型的应用。但我特别希望，当你在问这个问题时，你已经意识到了想要在计算机领域取得成功，你需要掌握自学能力，而且永不停息。</p>
<p><strong>在这个领域做得越多，我越觉得软件开发比任何行业都更接近于写作。</strong> 我们从来不知道是什么造就了优秀的作者，我们只知道什么时候我们会喜欢某个人的文字。编程不是一种工程，仅需要把东西从入口倒进去，然后再转动手柄。把软 件开发看成确定性的，是一个诱人的想法。因为这个想法，人们总想搞出一些工具来帮我们开发出想要的软件。但是我的经验告诉我，事实并非如此——人的重要性 远高于流程。而软件是否运行在一部精确的机器上已经越来越不重要了——这犹如测不准原理对人类的影响。</p>
<p>我的父亲是造房子的，小时候我偶尔会帮忙打下手，放放砖块之类。他和他的木工告诉我，他们是为我好才让我干这些活——这样我就不至于走入这个行业。事实确实是这样。</p>
<p>我 们不妨把软件开发比作盖房子。造房子的人当然不可能完全一样。这些人里面有：混凝土工、屋顶工、管道工、电工、砖瓦工、水泥工、瓦片工、搬运工、粗木工、 细木工。当然，还有工头。每个工种都需要相应的技能，这些技能都需要花时间和精力去掌握。跟软件开发一样，造房子也是一个“建立/推翻”的过程。如果你想 很快地获得回报，你可能从搬运工和砖瓦工开始做，这样的话，你无需太多的学习曲线就可以获得回报。当需求很多时，你的工作会很稳固，甚至收入也可能提升 ——如果没有足够的人手的话。但是，一旦行情不妙，木匠甚至工头就可能把砖瓦工一脚踢开。</p>
<p>当互联网刚刚兴起时，仅仅是花一点时间学习HTML，你就可以得到一份薪水丰厚的工作。但是当形势惨淡时，对于技能的要求更高了——HTML程序员（就像搬运工和砖瓦工一样）第一个被抛弃了，而拥有更高技能的程序员则留了下来。</p>
<p>我想说的是： <strong>除非你准备活到老学到老，不然的话，不要进入这个行业！编程看起来似乎是一个高收入而又稳定的工作。但要做到这一点，唯一的途径是：始终让自己更有价值。</strong></p>
<p>当然，你总能找到例外。总有那么一些人，仅仅学了一门编程语言，就可以胜任留在一个岗位上，而不需要增长他的技能。但他们只是幸免于难而已，他们最终无疑是很脆弱的。为了不让自己变得脆弱，你需要持续的提高自己，通过阅读、加入用户组、参加研讨会…… <strong>你学得越深入，你就越有价值，也就意味着你有更好的职业前景，可以配得上更高的薪水。</strong></p>
<p>另 一个方法是：先大致地了解这个领域，找到最适合你的地方。打个比方：我的兄弟对软件很感兴趣，也进入了这个行业，但他的工作是安装、维修、升级电脑。他总 是一丝不苟，所以当他把电脑搞好，一定会很完美——不只只是软件，连电线都会被仔细地捆好。他总是生意兴隆，远远超出他的精力所能及。他甚至都不用担心 .com 泡沫的崩溃。显然他的饭碗不容易被抢走。</p>
<p>我在高校里待了很久，甚至还在UCLA（加州大学洛杉矶分校）开始进修博士学位，后来 又幸运地终止了。我说“幸运”是因为我不再喜欢呆在学校，而我之前在高校待了那么久，只是因为我很享受它。但我所享受的，基本上是不务正业的东西——艺术 和舞蹈课，在校报工作，还有一小撮计算机课程（之所以说计算机课程“不务正业”，是因为我本科是物理专业，研究生才是计算机专业）。虽然我在学术上远谈不 上卓越（有意思的是很多当时也许不会接受我这个学生的学校现在却用我的书做教材）。我真的很享受作为学生的日子，当我完成博士课程，也许会以一个教授的身 份终老一生。</p>
<p>但就如现在看到的，我在学校里最大的收获恰恰来自我那些“不务正业”的课程，它们拓展了我的思维，使之超越了“我们已经知道 的东西”。在计算机领域中，你总是为某种目标而编程。你对目标了解得越多，你就做得越好。我遇到过一些欧洲的研究生，他们需要结合其它专业领域来搞编程， 他们的论文需要解决这个专业领域的特定的问题。</p>
<p><strong>了解编程之外的领域，将会极大得提高你解决问题的能力</strong> （就如同多学几种编程语言将极大地提高你的编程技能）。很多时候，我发现仅仅学习计算机专业的学生，比那些（除了计算机之外）拥有其它背景的学生，在思维上有更多的局限性。因为后者有着更严谨的思维，也不那么容易想当然。</p>
<p>有一次我组织了一次会议，其中一个议题是：理想的应聘者有哪些特征：
◇把学习当成生活方式。比如：你应该知道不止一种语言，没有什么比学习一门新语言更能让你开阔眼界了。
◇知道如何获取知识
◇Study prior art
◇善用工具
◇学会把事情简化
◇理解业务
◇为自己的错误负责。“我就是这样的”是不能接受的托词。能找到自己的失误。
◇成为一个领导者，善于沟通和激励。
◇搞清楚你在为谁服务
◇没有绝对正确的答案（更好的方法总是存在的）。展示并讨论你的代码，不要带着感情因素——你的代码并不等于你本人。
◇明白完美是渐进的</p>
<p>要 尝试一些冒险的事情——尤其是那些令人害怕的冒险。当你尝试之后，将体会到出乎意料的兴奋。（在冒险的过程中）最好不要刻意去计划某个特定的结果。当你过 于注重结果，你往往会错过那些真正有价值的问题。我的冒险往往是这样开始的——“我们先做些试验，看看它会把我们带到什么地方”。</p>
<p>或许某 些人会对我的回答感到失望，并回复我说：“是的，这很有趣也很有用。但我到底应该学什么？C++还是Java？” 我再重复一次：并不是所有的问题都有一个唯一的简单的答案。问题的关键不在于选择某个编程语言，然后掌握之。问题的关键在于：持续学习，并且很多时候，有 不止一个选择。相信我所说的，你的生活会更精彩！</p>
<p>洋文原始出处：
<a href="http://www.artima.com/weblogs/viewpost.jsp?thread=259358" target="_blank"><a href="http://www.artima.com/weblogs/viewpost.jsp?thread=259358">http://www.artima.com/weblogs/viewpost.jsp?thread=259358</a></a>
来源： <a href="[http://www.rootsir.com/transshipment/2012/709.html](http://www.rootsir.com/transshipment/2012/709.html)">[http://www.rootsir.com/transshipment/2012/709.html](http://www.rootsir.com/transshipment/2012/709.html)</a> </p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/好文摘录/">好文摘录</a></li></span></span> | <span class="time">recent updated:<time title="2014-03-07 11:24:29"datetime="2014-03-07 11:24:29"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/03/2014-02-03--BruceEckel：编程生涯/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-03--BruceEckel：编程生涯" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/03/2014-02-03--分享警惕偷走时间的5大窃贼/">【分享】警惕偷走时间的5大窃贼</a></h1>
      
        <span>Posted on<time datetime="2014-02-03T03:24:29.000Z"> <a href="/2014/02/03/2014-02-03--分享警惕偷走时间的5大窃贼/">feb. 3 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-5-">【分享】警惕偷走时间的5大窃贼</h1>
<p><a href=""></a></p>
<p><a href="http://www.cnblogs.com/cancanwyq/" target="_blank">E8软件 中国式流程管控解决方案领导者 400-006-2800 公众微信号：e8flow</a></p>
<p>致力于中国管理软件设计
E8软件||ITSM解决方案||IT服务管理系统||ITIL管理思想执行工具||E8.NET工作流架构||企业流程管理解决方案</p>
<ul>
<li><a href="http://www.cnblogs.com/" target="_blank">博客园</a></li>
<li><a href="http://www.cnblogs.com/cancanwyq/" target="_blank">首页</a></li>
<li><a href="http://q.cnblogs.com/" target="_blank">博问</a></li>
<li><a href="http://home.cnblogs.com/ing/" target="_blank">闪存</a>
<em>
</em></li>
<li><a href="http://www.cnblogs.com/cancanwyq/rss" target="_blank">订阅</a></li>
<li><a href="http://www.cnblogs.com/cancanwyq/admin/EditPosts.aspx" target="_blank">管理</a>
随笔-133  文章-34  评论-370 </li>
</ul>
<h1 id="-5-http-www-cnblogs-com-cancanwyq-p-3281827-html-"><a href="http://www.cnblogs.com/cancanwyq/p/3281827.html" target="_blank">【分享】警惕偷走时间的5大窃贼</a></h1>
<p> <a href="http://www.chinae8.net/" target="_blank"><img src="" alt=""></a></p>
<p>好的管理者都是好的时间管理者。而管理者时间管理的根本是抓大放小、果断决策、大胆授权、梳理系统、做好计划。只有这样，管理者才能防范偷走你宝贵时间的5大窃贼，才能让自己免于焦头烂额。</p>
<p>管理者管理什么？一是管事，二是管人，三是管时间。在这三个维度上，管事最容易，管人最困难，管时间不难却最容易被忽略。</p>
<p>很多管理者天天忙得团团转，却得不到上司的好评，主要的原因就是不会做时间管理，让自己和下属宝贵的时间被浪费掉。</p>
<p>什么会偷走管理者的时间，让管理者焦头烂额却得不到应得的结果？以我的经验，管理者有5大时间窃贼需要提防。</p>
<ol>
<li><p>抓小放大。很多管理者忙于无数的小细节，不跳出细节思考什么才是自己真正应该做的事情。结果是不重要的事情做了一大堆，重要的事情一个没有做，上司不关心的事情做了一大堆，上司关心的事情一个没有做。其实事情都有逻辑关系和层次：解决一个上一级的问题，通常能让你一下子解决3〜5个次一级的问题。如果我们能抓住最上级的问题用心解决，解决一个最上级问题的效果会相当于解决几十个最底层级的问题。但解决一个大问题和解决一个小问题花的时间差别并不大，至少不是几十倍的差别。</p>
</li>
<li><p>议而不决。很多管理者忙于开会，忙于和很多相关和不相关的同事讨论如何解决一个问题，却迟迟不愿自己负起责任做出决定。这类管理者把本来可以半个小时开完的会议拖延到3个小时，把本来可以在一次会议上做的决定延迟到下一次会议。议而不决的后果是让管理者要处理的事情大量积压，让管理者的时间越来越少。这样的管理者没有认识到，没有事情可以通过拖延得到解决，决策的质量也不能通过拖延得到提高。</p>
</li>
<li><p>不能授权。很多管理者习惯于自己做事情，不习惯授权给别人做，总担心别人做不好，总觉得教会别人做不如自己做快。久而久之，自己做的小事越来越多，自己的时间越来越不够用，身边的人越来越闲，自己的委屈越来越多。</p>
</li>
<li><p>管而不理。很多管理者习惯于管事，不习惯于理事。例如，发现有人迟到，会狠狠地批评当事人，却不会思考是否是公司的考勤制度或考勤技术有问题。管而不理的后果是，一件事情发生一次，管理者要管一次，次次发生，次次要管。随着企业规模的扩大，次次管的事情会大幅增加，管理者的时间越来越少。其实只要系统梳理一次，一类问题就能解决了。从这个角度看，管是小，理是大，管理者要抓大放小，就要更多地梳理，而不是被动地管理。</p>
</li>
<li><p>不做计划。计划是什么？就是把你要做的事情和你可以用的资源合理地匹配起来，简而言之就是事先想清楚在什么时间用什么资源完成你要做的事情。在可以用的资源里，最重要的和最稀少的资源就是时间了。不做计划意味着资源和事情不匹配，意味着资源尤其是时间资源的浪费。一个人一天就24小时，浪费了就没有了。很多人忙，其实不是没有时间，而是没有合理地安排时间。</p>
</li>
</ol>
<p>好的管理者都是好的时间管理者。而管理者时间管理的根本是抓大放小、果断决策、大胆授权、梳理系统、做好计划。只有这样，管理者才能防范偷走你宝贵时间的5大窃贼，才能让自己免于焦头烂额。</p>
<p><strong>分享是一种美德，请随手转播  </strong></p>
<p>敬请关注【流程管理】公众微信平台，微信号：<strong>e8flow</strong>,宣传流程管理理念，每日会与您分享管理技巧，管理经验、哲理小故事和财经评论、财经观点。 您可以通过 “添加朋友”--&gt; &quot;搜索号码&quot; 或 “查找公众微信账号”,输入 e8flow ,搜索添加此关注</p>
<p>E8软件 提升企业战略执行力
<a href="http://www.chinae8.net/" target="_blank"><a href="http://www.chinae8.net">http://www.chinae8.net</a>
</a> 流程银行QQ群 :74080032
【流程管理】微信公众号：e8flow
绿色通道： <a href="">好文要顶</a> <a href="">关注我</a> <a href="">收藏该文</a><a href="http://space.cnblogs.com/msg/send/%e8%8b%8f%e5%ba%b7%e8%83%9c" target="_blank">与我联系</a> <a href="&quot;分享至新浪微博&quot;"><img src="" alt=""></a></p>
<p><a href="http://home.cnblogs.com/u/cancanwyq/" target="_blank"><img src="" alt=""></a></p>
<p><a href="http://home.cnblogs.com/u/cancanwyq/" target="_blank">苏康胜</a>
<a href="http://home.cnblogs.com/u/cancanwyq/followees" target="_blank">关注 - 0</a>
<a href="http://home.cnblogs.com/u/cancanwyq/followers" target="_blank">粉丝 - 24</a></p>
<p><a href="">+加关注</a></p>
<p>0</p>
<p>0
(请您对文章做出评价)</p>
<p><a href="http://www.cnblogs.com/cancanwyq/archive/2013/08/21/3271848.html" target="_blank">«</a> 上一篇：<a href="http://www.cnblogs.com/cancanwyq/archive/2013/08/21/3271848.html" title="发布于2013-08-21 09:04" target="_blank">2013年江苏省钢贸市场融资黑洞引发传统信用分析技术的思考</a></p>
<p>posted @ 2013-08-26 08:24 <a href="http://www.cnblogs.com/cancanwyq/" target="_blank">苏康胜</a> 阅读(162) 评论(0) <a href="http://www.cnblogs.com/cancanwyq/admin/EditPosts.aspx?postid=3281827" target="_blank">编辑</a> <a href="">收藏</a></p>
<p><a href="">刷新评论</a><a href="">刷新页面</a><a href="">返回顶部</a></p>
<p>注册用户登录后才能发表评论，请 <a href="">登录</a> 或 <a href="">注册</a>，<a href="http://www.cnblogs.com/" target="_blank">访问</a>网站首页。
<a href="http://www.cnblogs.com/" title="程序员的网上家园" target="_blank">博客园首页</a><a href="http://q.cnblogs.com/" title="程序员问答社区" target="_blank">博问</a><a href="http://news.cnblogs.com/" title="IT新闻" target="_blank">新闻</a><a href="http://home.cnblogs.com/ing/" target="_blank">闪存</a><a href="http://job.cnblogs.com/" target="_blank">程序员招聘</a><a href="http://kb.cnblogs.com/" target="_blank">知识库</a></p>
<p><strong>最新IT新闻</strong>:
· <a href="http://news.cnblogs.com/n/186400/" target="_blank">淘宝保险潜行三年保单超10亿笔 运费险占比过半</a>
· <a href="http://news.cnblogs.com/n/186399/" target="_blank">科学家发现古埃及人陨石项链：距今5000年</a>
· <a href="http://news.cnblogs.com/n/186398/" target="_blank">键盘藏真菌比臭鞋高65倍</a>
· <a href="http://news.cnblogs.com/n/186396/" target="_blank">乔布斯和马斯克两巨人之间的“神同步”</a>
· <a href="http://news.cnblogs.com/n/186395/" target="_blank">苹果7月修改应用排行算法：首次参考用户评级</a>
» <a href="http://news.cnblogs.com/" title="IT新闻" target="_blank">更多新闻...</a></p>
<p><strong>最新知识库文章</strong>:
· <a href="http://kb.cnblogs.com/page/186346/" target="_blank">计算机专业学习浅谈</a>
· <a href="http://kb.cnblogs.com/page/186221/" target="_blank">遗失的乔布斯访谈</a>
· <a href="http://kb.cnblogs.com/page/179631/" target="_blank">从登录开始</a>
· <a href="http://kb.cnblogs.com/page/179146/" target="_blank">聊聊内存泄露</a>
· <a href="http://kb.cnblogs.com/page/185599/" target="_blank">与Google轻轻地擦肩而过</a>
» <a href="http://kb.cnblogs.com/" target="_blank">更多知识库文章...</a></p>
<h3 id="-">公告</h3>
<p>自2007年10月20日
<a href="http://www.newzgc.com/" target="_blank"><img src="" alt=""><img src="" alt=""><img src="" alt=""><img src="" alt=""><img src="" alt=""><img src="" alt=""><img src="" alt=""><img src="" alt=""></a>
<a href="http://www.feifanit.com.cn/productITSM.htm?default=solutions" target="_blank">E8.ITSM HelpDesk 您身边的IT服务管理专家</a>
<a href="http://www.feifanit.com.cn/productITSM.htm" target="_blank"><img src="" alt=""></a>
<a href="http://www.feifanit.com.cn/productFlow.htm" target="_blank">E8.Net工作流提升企业管理执行力</a>
<a href="http://www.feifanit.com.cn/productFlow.htm" target="_blank"><img src="" alt=""></a>
<a href="http://t.qq.com/E8FLOW" target="_blank"><img src="" alt=""></a> 敬请关注【流程管理专家】公众微信号：e8flow,分享流程管理经验，传播管理理念，提升管理执行力！</p>
<p>昵称：<a href="http://home.cnblogs.com/u/cancanwyq/" target="_blank">苏康胜</a>
园龄：<a href="http://home.cnblogs.com/u/cancanwyq/" title="入园时间：2006-02-15" target="_blank">7年6个月</a>
粉丝：<a href="http://home.cnblogs.com/u/cancanwyq/followers/" target="_blank">24</a>
关注：<a href="http://home.cnblogs.com/u/cancanwyq/followees/" target="_blank">0</a></p>
<p><a href="">+加关注</a></p>
<h3 id="-">搜索</h3>
<h3 id="-">我的标签</h3>
<ul>
<li><a href="http://www.cnblogs.com/cancanwyq/tag/%E5%B7%A5%E4%BD%9C%E6%B5%81/" target="_blank">工作流</a>(15)</li>
<li><a href="http://www.cnblogs.com/cancanwyq/tag/.net/" target="_blank">.net</a>(11)</li>
<li><a href="http://www.cnblogs.com/cancanwyq/tag/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/" target="_blank">项目管理</a>(8)</li>
<li><a href="http://www.cnblogs.com/cancanwyq/tag/%E5%BC%80%E5%8F%91%E5%9B%A2%E9%98%9F/" target="_blank">开发团队</a>(6)</li>
<li><a href="http://www.cnblogs.com/cancanwyq/tag/E8.net/" target="_blank">E8.net</a>(6)</li>
<li><a href="http://www.cnblogs.com/cancanwyq/tag/ITIL/" target="_blank">ITIL</a>(5)</li>
<li><a href="http://www.cnblogs.com/cancanwyq/tag/IT%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86/" target="_blank">IT服务管理</a>(4)</li>
<li><a href="http://www.cnblogs.com/cancanwyq/tag/.Net%E5%B7%A5%E4%BD%9C%E6%B5%81/" target="_blank">.Net工作流</a>(4)</li>
<li><a href="http://www.cnblogs.com/cancanwyq/tag/CIO/" target="_blank">CIO</a>(4)</li>
<li><a href="http://www.cnblogs.com/cancanwyq/tag/E8.Net%E6%9E%B6%E6%9E%84/" target="_blank">E8.Net架构</a>(3)</li>
<li><p><a href="http://www.cnblogs.com/cancanwyq/tag/" target="_blank">更多</a></p>
<h3 id="-">经典收藏</h3>
</li>
<li><p><a href="http://blog.vsharing.com/cancanwyq" target="_blank">ITIL标准面向中国企业的实践之路</a></p>
</li>
<li><a href="http://blog.vsharing.com/cancanwyq" target="_blank">ITIL与ITSM管理软件</a></li>
<li><a href="http://www.cnblogs.com/cancanwyq/articles/343325.html" target="_blank">工作流技术杂谈</a></li>
<li><a href="http://www.feifanit.com.cn/" target="_blank">工作流应用网站</a></li>
</ul>
<h3 id="-">团队博客</h3>
<ul>
<li><a href="http://dotnetenterprise.cnblogs.com/" target="_blank">.Net企业应用开发</a></li>
<li><a href="http://shanghai.cnblogs.com/" target="_blank">上海.net俱乐部</a></li>
<li><p><a href="http://shenzhen.cnblogs.com/" target="_blank">深圳.Net俱乐部</a></p>
<h3 id="-">阅读排行榜</h3>
</li>
<li><p><a href="http://www.cnblogs.com/cancanwyq/archive/2009/09/22/1571707.html" target="_blank">1. 从网友发的一个关于程序员人生的流程图想到的(4923)</a></p>
</li>
<li><a href="http://www.cnblogs.com/cancanwyq/archive/2009/03/18/1415070.html" target="_blank">2. 技术高速发展，IT人员路在何方？(3554)</a></li>
<li><a href="http://www.cnblogs.com/cancanwyq/archive/2007/10/27/939392.html" target="_blank">3. 模式窗口window.open造成Session丢失的解决方法(2984)</a></li>
<li><a href="http://www.cnblogs.com/cancanwyq/archive/2009/05/12/1454574.html" target="_blank">4. 机会来了，创业你准备好了吗？(2668)</a></li>
<li><a href="http://www.cnblogs.com/cancanwyq/archive/2010/06/10/1755244.html" target="_blank">5. 软件公司有一种幸福叫好好活着(2566)</a></li>
</ul>
<h3 id="-">推荐排行榜</h3>
<ul>
<li><a href="http://www.cnblogs.com/cancanwyq/archive/2010/06/10/1755244.html" target="_blank">1. 软件公司有一种幸福叫好好活着(6)</a></li>
<li><a href="http://www.cnblogs.com/cancanwyq/archive/2010/06/09/1754443.html" target="_blank">2. 软件企业三个“留住”，创建品质团队(4)</a></li>
<li><a href="http://www.cnblogs.com/cancanwyq/archive/2010/08/23/1806258.html" target="_blank">3. 项目经理进阶修炼2--处理需求变更策略(4)</a></li>
<li><a href="http://www.cnblogs.com/cancanwyq/archive/2010/07/19/1780453.html" target="_blank">4. 中国程序员有望挑战“比尔.盖茨”的三大管理类需求(3)</a></li>
<li><a href="http://www.cnblogs.com/cancanwyq/archive/2010/08/16/1800428.html" target="_blank">5. 软件开发技术高手转向项目管理者要突破的误区-- 跟博客园的朋友探讨的思路(3)</a>
Copyright ©2013 苏康胜</li>
</ul>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/好文摘录/">好文摘录</a></li></span></span> | <span class="time">recent updated:<time title="2014-03-07 11:24:29"datetime="2014-03-07 11:24:29"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/03/2014-02-03--分享警惕偷走时间的5大窃贼/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-03--分享警惕偷走时间的5大窃贼" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/03/2014-02-03--阿里数据库专家：写给我们这些浮躁的程序员/">阿里数据库专家：写给我们这些浮躁的程序员</a></h1>
      
        <span>Posted on<time datetime="2014-02-03T03:24:29.000Z"> <a href="/2014/02/03/2014-02-03--阿里数据库专家：写给我们这些浮躁的程序员/">feb. 3 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-">阿里数据库专家：写给我们这些浮躁的程序员</h1>
<p><strong>本文作者：叶正盛，阿里巴巴数据库技术专家，专注于数据库应用性能量化。</strong></p>
<p>再次写给我们这些刚入行浮躁的程序员，如何成长，以下是列出了一些成长的心得，我们不必每条都去实践，但是优秀的程序员成长过程中总会实践里面的几条。</p>
<p><strong>多做项目，多思考</strong></p>
<p>不要害怕做事，刚毕业的同学最缺的就是工作经验，乱七八糟的项目能让你很快就了解了一个公司的业务与使用的技术，并且可以多接触同事与客户。</p>
<p>当你毕业后刚进一家公司时，如果主管没有把你安排到项目组工作，那真的很杯具，因为他认为你还不能胜任工作或者你的加入会让项目组更糟。</p>
<p>还有人说，我刚进公司，公司就把我当成了苦工，工资又低，项目组加入好几个，也做了很多事情，每天都要加班。我估计有很多人感觉是这种状态，为什么会是这样，因为全国人民（不只是程序员）里有90%可能都和你一样的感觉，这说明你现在状况是很普遍的，也说明你现在的能力并没有很多出众的地方。也许是逆境才能让人成长，如果有一天你让你的团队从这些苦力工作中解脱出来或者能给你的团队前进的动力，那你就升华了，你就比他们出众。你没有能力去改变现状，所以只能接受，而不要认为是自己生不逢时，或者说公司环境太差。创业也一样，不要认为公司没发展的主要原因是环境太差，那你不要去当老板算了，投资环境都非常好还能轮到你吗。</p>
<p>还有很多同学感觉自己付出了很多，回报太少，这个问题很难平衡，首先一点，公司在聘你进来后不会因为你没有成绩就先给你回报，公司也不可能会在你有了成绩后就立即给你回报，但是长时间付出没有回报，那这个公司就不值得你付出。我不赞成频繁换公司，这么做至少可以说明你是一个只求回报不求付出的人。</p>
<p>至于薪资的问题，这个很难去评估，因为每个企业的收益相差太远。但是刚毕业的同学工作需要关注薪资+成长环境，当薪资可以满足普通生活需求后，成长环境更为重要，就好比，给你一月5000元，或者6000元，真的不那么重要，因为这些收入在你以后的人生中基本没有影响。当然，如果你现在在大城市几年里每个月只拿着1000元，那还是需要选择一下收入更好的公司，因为这么低的收入会严重影响你的工作学习计划，也说明你的公司不重视员工，没有能力给员工好生活的公司，将来的发展也是有限的。</p>
<p>特别说明一点，互联网公司与传统信息化企业不一样，互联网一直是风险比较高的行业，也许你选择了一个看好的企业，也佩服老板的眼光，可能你现在需要的是与公司同甘共苦。不要指望在刚创业的团队里拿到非常好的待遇，因为你现在就是在投资，也许几年后公司成功了，你就是功臣，不怎么出色的你也可以当上总监或副总裁。</p>
<p><strong>自己开发框架与工具来提高工作效率</strong></p>
<p>当你参与了很多项目，当你发现自己经常做一些COPY,PASTE的操作时，你可以考虑花时间去提取问题的共性，做一些自动化工具去摆平问题，或者是写一些基础框架来屏蔽这些无聊并且累赘的代码。</p>
<p>自己开发框架与工具，可以让你快速的从一个初级程序员转变成更高级的程序员或分析师或架构师，因为这个过程中给你提供了为其他程序员服务的机会，你有动力去了解其它程序员的工作需求，你可以把你的框架或工具写得很好，接口简单灵活并且性能好，分析师和架构师就经常要干这种让人力成本降低的事。但要记住一点，不要以为自己开发框架与工具就认为很NB了，因为这种工作并不会体现多少技术含量，而只是提高个人抽象问题的能力，这个活很多程序员都能干，但是很少人去干好。</p>
<p><strong>参与开源项目</strong></p>
<p>参与开源项目可以让你领略到不同程序员的沟通方法，开发习惯，技术思维，可以认识更多的朋友，如果你足够强，也可能一举成名哦。可以让你更深入了解这个开源东西，所以最好是感兴趣或者是与工作有关的，不要说什么流行就参与什么。开源项目可以自己贡献一个新的项目，或者参与一个感兴趣的项目。</p>
<p>不要指望开源项目会给你带来直接的金钱，如果你想拿着开源项目封装一下去发财，那我真不知道如何做，可以去问问什么什么芯，什么什么国产操作系统的人，他们更有经验。</p>
<p><strong>英语</strong></p>
<p>在这个全球信息时代，英语真的是一个很重要的工具，我真的很羡慕那些学校里英语就很好的同学，好的英语能力可以更快速的了解到更多知识。当前，新的技术与知识大部份语言都是英语或翻译成英语，如果能把英语学好，可以让你人生少奋斗10年。</p>
<p><strong>写技术博客</strong></p>
<p>写技术博客是一种可以快速提高的方法，但是一个人能坚持每周写技术博客，那是需要付出很多代价，写博客并不是要我们写出高质量的文章才发表，我们可以分享自己的一些小经验，也可以分享自己的体会。一样东西在你大脑里，并不表示你已经掌握了，如果你能说给别人听，或者用文字表达出来，那首先你要将这些知识点整理清楚才好表达。我经常认为自己已经对某个问题了解了，但是在整理技术博客时发现自己的知识盲点，然后再去查找知识来补充自己的盲点，直到最后搞清楚了才算告一段落。</p>
<p>有些人不喜欢分享或者害怕分享，但是在这个世界，只要不是公司机密或商业秘密，拿出来分享可以让你得到更多同行的反馈，网络上的人会给你相对真实的反馈，因为大部份人与你没有利益关系。</p>
<p>新人不要害怕自己分享的知识是否有技术含量，只要你认为有价值，都可以拿出来，这不仅可以给别人提供知识，也可以自己整理思路，还可以得到网友的反馈。如果你的知识没有价值，分享出来也没有关系，如果你的文章技术含量低，怕被人鄙视，那是你这个人不敢承认现实，因为同事与朋友可能不会说你的文章很菜，就算被鄙视了又如何，有时被人鄙视也是一种前进的动力。有人说如果几年后我进步了很多，但还让人看到我这些初学时弱智的文档，误人子弟，不好意思，Ok，那个时候有可以完全把文档删除，其实我更喜欢放在那里品味自己成长的过程，把有误导的地方更正。</p>
<p>我知道有一个技术博客作者，数据库专家杨廷琨(<a href="http://yangtingkun.itpub.net/)，他几年来，每天坚持写一篇技术博客，现在已经有2千多篇，我的ORACLE数据库水平比他差很多，但是我也偶尔看到一些他新写的文档我几年前就会了，但这些并不妨碍我对这位博客作者的敬佩，因为他的博客让我学到了很多知识。" target="_blank">http://yangtingkun.itpub.net/)，他几年来，每天坚持写一篇技术博客，现在已经有2千多篇，我的ORACLE数据库水平比他差很多，但是我也偶尔看到一些他新写的文档我几年前就会了，但这些并不妨碍我对这位博客作者的敬佩，因为他的博客让我学到了很多知识。</a></p>
<p><strong>加入感兴趣的技术论坛</strong></p>
<p>每个公司使用的技术与产品及环境都不太一样，也许你在公司里感觉什么东西都是别人做好了，我只是个流水线工人，我们的系统由于有严格的规范也不太出问题，自己的实践提高机会太少，那建议你加入感兴趣的技术论坛。</p>
<p>技术论坛上你可以看到很多人各种各样的问题与分享讨论，你也可以试着去帮别人解决问题。技术论坛可以让你进一步成长，但不要告诉我你只是会沙发、顶或接分的那种。</p>
<p>国内CSDN、OSCHINA、ITPUB、CHINAUNIX、JAVAEYE都是人气很旺，里面也不缺技术大牛与无敌大菜鸟。</p>
<p><strong>常看参考手册</strong></p>
<p>很多程序员，遇到问题喜欢直接去请教别人，或是Google找结果，通过别人或Google也许问题可以解决，但是只能形成知识点，不能形成知识体系。</p>
<p>要全面掌握一个东西最快的方法是看产品的官方参考手册，参考手册一般是代表正规的用法或者是推荐的用法，对于小产品最好是先将参考手册全部看一遍。如果是比较大的产品如（ORACLE、JAVA、.NET）那可以选择看经常使用到的部分。只有当你在看完参考手册还不懂的时候再去Google或与别人探讨，这样的方式会让你的知识更体系化。</p>
<p><strong>深入分析问题原因</strong></p>
<p>程序员一定要具备对技术问题刨根问底的想法，很多程序员能解决问题，但是不想去了解问题的根源。我们经常遇到问题，而且很多问题重启程序或者重启机器就好了，有多少程序员会去挖掘重启就解决问题的原因。我是从事数据库的，也经常看到很多人遇到数据库有问题，重装一下搞定，而没有深入分析问题产生的原因。也许在生产环境我们没有时间去分析，但是在开发环境、测试环境你是不是也经常重启解决问题。如果能在开发环境与测试环境遇到问题，这是技术人员成长的最好机会，我们在自己的领域一定不能放过这种成长的机会，因为大部份专家都是在这种历练中出来的。</p>
<p><strong>不要害怕复杂</strong></p>
<p>很多程序员习惯了利用各种框架及工具解决问题，自己只是写一些简单逻辑，当有一天遇到一个问题，没有对应的框架或工具时就放弃需求。我们不要害怕困难，如果你每天的代码都没有挑战，那何来提高，我们应该在适当的时候给自己一些压力，这样可以让自己提高得更快一些。比如你的系统需要一个轻量级的工作流引擎、编译器、解析器、界面设计器、屏幕控制器，或者一个http服务器之类的东东，但是现有的东西都感觉不太满意，你可以自己去搞一个试试，不要害怕不成功，不要害怕自己做不好。这些东西看起来有点复杂，但是当你深入去做时，你会发现里面有很多有意思的东西，你需要去逐步改进你的小系统，直到它能很好的运行为止，这是个很好的成长过程，可以让你对程序有更深的理解，也可打开思路。</p>
<p><strong>学习计算机基础，深入技术原理</strong></p>
<p>有时候我们经常迷惘，感觉技术水平没有提高，感觉技术能力总是浮在表面，特别是当你发现自己算法分析、性能分析、故障诊断能力有限时，也许这是你再次需要学习计算机基础的时候，因为基础不牢，所以你的问题诊断准确率不高。每个程序员应该都学过计算机基础（计算机体系、操作系统、网络、数据库原理、算法等等），这些知识对很多人来说是很枯燥。在当前高级编程语言时代，你的计算机基础不好也能编码，而且效率也不低，但是当你要想成为技术牛人，计算机基础就是一道坎，因为不扎实的计算机基础知识会让你在忽悠与被忽悠中成长。</p>
<p><strong>关心产品市场与商业动态</strong></p>
<p>程序员是否需要关心产品市场与商业动态，我认为是有必要的，除非你真是技术天才，能闭关十年后横扫江湖。计算机技术发展太快，每年都有新的流行产品与技术，大公司也经常改变战略或易主。如果你想引领技术潮流，想创业，那一定要关心产品市场与商业动态。</p>
<p><strong>不要去轻视任何一种职位、语言、工具</strong></p>
<p>在IT岗位里，没有高低之分，不要去轻视任何一种岗位，有些程序员认为自己的成果最有价值，美工、测试只是边缘岗位，项目经理就只会瞎指挥，不干活，销售人员与售前人员接到定单后屁事都没有，整个项目基本上就是我一个人的成果。这种心态是最要不得的。其实你的领导并不会这么想，很多事情是你不知道的，如客户关系就可能不是你一个人搞定的。还有最重要的一点，如果这个项目没有你参加怎么样？项目可能换成另外一个人做，也许他也能做得也不错，这就说明你的价值或重要性并不像你想象的那么重要。举个例子：</p>
<p>就好比你买一台联想电脑4000块，卖给一个没看过电脑的火星人20000块，这台电脑是最后的成果，但是否表示联想这台电脑是最重要的，可能你买一台戴尔的电脑还赚的钱更多，也可能你只要给对方一台杂牌电脑就可以拿到20000块。在这个例子里更重要的也许是客户关系与抓住商机，而买什么样的电脑影响不大（你在项目里的地位可能就是这台电脑的作用，没有你肯定不完整，但是很容易找到你的替代品，所以你的价值并不是最重要的）。</p>
<p>计算机编程语言是初学者最喜欢对比的话题，有的大师也经常对比各种语言的优缺点。我并不反对的评论那种语言的优劣，但我们不能去鄙视某种语言的及其使用者，因为流行的语言都有它生存的环境，可能是我们对技术的见识太窄，也可能是我们对人类的思维习惯了解的不全面，不要总是拿自己的习惯去评价。有很多系统管理员喜欢用命令行，喜欢用shell,perl等脚本语言，这些东西在我看来简直是低效且易读性差的东西，但是当你经常在没有图形界面下工作时，脚本语言可能真是更高效的选择。</p>
<p><strong>最后写上一句浮躁的根源：</strong></p>
<p>不要把祖国当母亲，应该把祖国当自己的孩子。</p>
<p>本不想讲这句话的，但是现实就是如此，浮躁的人群总是对社会充满了意见。我认为所有的这些浮躁都有一个共同点，就是认为自己无法改变这个社会，改变这个社会是国家的事，是其他人的事。</p>
<p>小时候老师总是讲祖国是母亲，我们是花朵，但是实际上我们也不是什么花朵，我们就是郑智化歌里的那根“小小的草，风吹雨打后依然不倒”。现实的社会总是充满着种种不平衡，但是浮躁并不能解决问题。有时总在想祖国并不像我的母亲，她更像是我的孩子，她还很小，经历过很多坎坷，我们经常感觉自家的孩子比不上别人的孩子的某个方面，于是对孩子多加责骂，也可能会让她花一个暑假的时间去补习。小孩子有一些成绩后也会骄傲，有时还会欺骗，我们不能容忍的是她的恶意谎言，但是她还没有到无药可救的程度，她依然还在成长。我们经常拿孩子与别人的孩子对比，而且总是发现别人孩子更好的一面，但是你是否希望与别人交换孩子呢，除了感情外你是否了解别人孩子的全部，我们需要更多的面对现实，应该在孩子成长的时候及时指出她的缺点，她不可能什么都是优秀的，所以我们应该尽自己的能力让她更好一些。你不太可能改变母亲，但是你的行动会影响孩子，你抛弃孩子，你真正的孩子将来可能也会抛弃你，所以说祖国可能并不像母亲，更像孩子，如果你把祖国当孩子，也许是另一种人生价值。
来源： <a href="[http://www.oschina.net/question/5189_20311](http://www.oschina.net/question/5189_20311)">[http://www.oschina.net/question/5189_20311](http://www.oschina.net/question/5189_20311)</a> </p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/好文摘录/">好文摘录</a></li></span></span> | <span class="time">recent updated:<time title="2014-03-07 11:24:29"datetime="2014-03-07 11:24:29"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/03/2014-02-03--阿里数据库专家：写给我们这些浮躁的程序员/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-03--阿里数据库专家：写给我们这些浮躁的程序员" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/03/2014-02-03--程序算法与人生选择/">程序算法与人生选择</a></h1>
      
        <span>Posted on<time datetime="2014-02-03T03:24:29.000Z"> <a href="/2014/02/03/2014-02-03--程序算法与人生选择/">feb. 3 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-">程序算法与人生选择</h1>
<p><a href="&quot;把这个链接拖到你的Chrome收藏夹工具栏中&quot;">High一下!</a></p>
<h1 id="-coolshell-cn-http-coolshell-cn-"><a href="http://coolshell.cn/" target="_blank">酷壳 – CoolShell.cn</a></h1>
<p>享受编程和技术所带来的快乐 – <a href="http://coolshell.cn" target="_blank">http://coolshell.cn</a></p>
<ul>
<li><a href="http://coolshell.cn/" title="首页" target="_blank">首页</a></li>
<li><a href="http://coolshell.cn/featured_posts" target="_blank">推荐文章</a></li>
<li><a href="http://coolshell.cn/plugins" target="_blank">本站插件</a></li>
<li><a href="http://coolshell.cn/guestbook" target="_blank">留言小本</a></li>
<li><a href="http://coolshell.cn/about" target="_blank">关于酷壳</a></li>
<li><a href="http://coolshell.cn/haoel" target="_blank">关于陈皓</a></li>
<li><a href=""></a>
<a href="http://coolshell.cn/" title="转到首页" target="_blank">首页</a> &gt; <a href="http://coolshell.cn/category/misc" title="查看 杂项资源 中的全部文章" target="_blank">杂项资源</a> &gt; 程序算法与人生选择</li>
</ul>
<h2 id="-">程序算法与人生选择</h2>
<p>2012年12月28日 <a href="http://coolshell.cn/articles/author/haoel" title="由 陈皓 发布" target="_blank">陈皓</a> <a href="">发表评论</a> <a href="">阅读评论</a> 63,218 人阅读    </p>
<p><img src="" alt="">每年一到要找工作的时候，我就能收到很多人给我发来的邮件，总是问我怎么选择他们的offer，去腾讯还是去豆瓣，去外企还是去国内的企业，去创业还是去考研，来北京还是回老家，该不该去创新工场？该不该去thoughtworks？……等等，等等。今年从7月份到现在，我收到并回复了60多封这样的邮件。我更多帮他们整理思路，帮他们明白自己最想要的是什么。（注：我以后不再回复类似的邮件了）。</p>
<p>我深深地发现，对于我国这样从小被父母和老师安排各种事情长大的人，当有一天，父母和老师都跟不上的时候，我们几乎完全不知道怎么去做选择。而我最近也离开了亚马逊，换了一个工作。又正值年底，就像去年的那篇《<a href="http://coolshell.cn/articles/6142.html" title="三个事和三个问题" target="_blank">三个故事和三个问题</a>》一样，让我想到写一篇这样的文章。</p>
<h3 id="-">几个例子</h3>
<p>当我们在面对各种对选择的影响因子的时候，如：城市，公司规模，公司性质，薪水，项目，户口，技术，方向，眼界…… 你总会发现，你会在几个公司中纠结一些东西，举几个例子：</p>
<ul>
<li><p>某网友和我说，他们去上海腾讯，因为腾讯的规模很大，但却发现薪水待遇没有豆瓣高（低的还不是一点），如果以后要换工作的话，起薪点直接关系到了以后的高工资。我说那就去豆瓣吧，他说豆瓣在北京，污染那么严重，又没有户口，生存环境不好。我说去腾讯吧，他说腾讯最近组织调整，不稳定。我说那就去豆瓣吧，慢公司，发展很稳当。他说，豆瓣的盈利不清楚，而且用Python，自己不喜欢。我说，那就去腾讯吧，……</p>
</li>
<li><p>还有一网友和我说，他想回老家，因为老家的人脉关系比较好，能混得好。但又想留在大城市，因为大城市可以开眼界。</p>
</li>
<li><p>另一网友和我说，他想进外企，练练英语，开开眼界，但是又怕在外企里当个螺丝钉，想法得不到实施。朋友拉他去创业，觉得创业挺好的，锻炼大，但是朋友做的那个不知道能不能做好。</p>
</li>
<li><p>还有一网友在创新工场的某团队和考研之间抉择，不知道去创新工场行不行，觉得那个项目一般，但是感觉那个团队挺有激情的，另一方面觉得自己的学历还不够，读个研应该能找到更好的工作。</p>
</li>
<li><p>还有一些朋友问题我应该学什么技术？不应该学什么技术？或是怎么学会学得最快，技术的路径应该是什么？有的说只做后端不做前端，有的说，只做算法研究，不做工程，等等，等等。因为他们觉得人生有限，术业有专攻。</p>
</li>
<li><p>等等，等等……</p>
</li>
</ul>
<p>我个人觉得，如果是非计算机科班出生的人不会做选择，不知道怎么走也罢了，但是我们计算机科班出生的人是学过算法的，<strong>懂算法的人应该是知道怎么做选择的</strong>。</p>
<h2 id="-">#</h2>
<h3 id="-">排序算法</h3>
<p>你不可能要所有的东西，所以你只能要你最重要的东西，你要知道什么东西最重要，你就需要对你心内的那些欲望和抱负有清楚的认识，不然，你就会在纠结中度过。</p>
<p>所以，在选择中纠结的人有必要参考一下排序算法。</p>
<ul>
<li><p>首先，你最需要参考的就是“冒泡排序”——这种算法的思路就是每次冒泡出一个最大的数。所以，你有必要问问你自己，面对那些影响你选择的因子，如果你只能要一个的话，你会要哪个？而剩下的都可以放弃。于是，当你把最大的数，一个一个冒泡出来的时候，并用这个决策因子来过滤选项的时候，你就能比较容易地知道知道你应该选什么了。<strong>这个算法告诉我们，人的杂念越少，就越容易做出选择。</strong></p>
</li>
<li><p>好吧，可能你已茫然到了怎么比较两个决策因子的大小，比如：你分不清楚，工资&gt;业务前景吗？业务前景&gt;能力提升吗？所以你完全没有办法进行冒泡法。那你，你不妨参考一个“快速排序”的思路——这个算法告诉我们，我们一开始并不需要找到最大的数，我们只需要把你价值观中的某个标准拿出来，然后，把可以满足这个价值的放到右边，不能的放到左边去。比如，你的标准是：工资大于5000元&amp;&amp;业务前景长于3年的公司，你可以用这个标准来过滤你的选项。然后，你可以再调整这个标准再继续递归下去。<strong>这个算法告诉我们，我们的选择标准越清晰，我们就越容易做出选择</strong>。</p>
</li>
</ul>
<p>这是排序算法中最经典的两个算法了，面试必考。相信你已烂熟于心中了。所以，我觉得你把这个算法应用于你的人生选择也应该不是什么问题。关于在于，你是否知道自己想要的是什么？</p>
<p>排序算法的核心思想就是，<strong>让你帮助你认清自己最需要的是什么，认清自己最想要的是什么，然后根据这个去做选择</strong>。</p>
<h3 id="-">贪婪算法</h3>
<p>所谓贪婪算法，是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择（注意：是当前状态下），从而希望导致结果是最好或最优的算法。贪婪算法最经典的一个例子就是<a href="http://coolshell.cn/articles/7459.html" title="Huffman 编码压缩算法" target="_blank">哈夫曼编码</a>。</p>
<p>对于人类来说，一般人在行为处事的时候都会使用到贪婪算法，</p>
<ul>
<li><p>比如在找零钱的时候，如果要找补36元，我们一般会按这样的顺序找钱：20元，10元，5元，1元。</p>
</li>
<li><p>或者我们在过十字路口的时候，要从到对角线的那个街区时，我们也会使用贪婪算法——哪边的绿灯先亮了我们就先过到那边去，然后再转身90度等红灯再过街。</p>
</li>
</ul>
<p>这样的例子有很多。对于选择中，大多数人都会选用贪婪算法，因为这是一个比较简单的算法，未来太复杂了，只能走一步看一步，在当前的状况下做出最利于自己的判断和选择即可。</p>
<p>有的人会贪婪薪水，有的人会贪婪做的项目，有的人会贪婪业务，有的人会贪婪职位，有的人会贪婪自己的兴趣……这些都没什么问题。贪婪算法并没有错，虽然不是全局最优解，但其可以让你找到局部最优解或是次优解。其实，有次优解也不错了。<strong>贪婪算法基本上是一种急功近利的算法，但是并不代表这种算法不好，如果贪婪的是一种长远和持续，又未尝不可呢？</strong>。</p>
<h3 id="-">动态规划</h3>
<p>但是我们知道，对于大部分的问题，贪婪法通常都不能找出最优解，因为他们一般没有测试所有可能的解。<strong>因为贪婪算法是一种短视的行为，只会跟据当前的形式做判断，也就是过早做决定</strong>，因而没法达到最佳解。</p>
<p>动态规划和贪婪算法的最大不同是，贪婪算法做出选择，不能回退。动态规划则会保存以前的运算结果，并根据以前的结果对当前进行选择，有回退功能。</p>
<p>动态规划算法至少告诉我们两个事：</p>
<p>1）<strong>承前启后非常重要，</strong>当你准备去做遍历的时候，你的上次的经历不但能开启你以后的经历，而且还能为后面的经历所用。你的每一步都没有浪费。</p>
<p>2）<strong>是否可以回退也很重要</strong>。这意思是——如果你面前有两个选择，一个是A公司一个是B公司，如果今天你错失了B公司，那到你明天还能不能找回来？</p>
<p>比如说：你有两个offer，一个是Yahoo，一个是Baidu，上述的第一点会让我们思考，Yahoo和Baidu谁能给我们开启更大的平台？上述的第二点告诉我们，是进入Yahoo后如果没有选好，是否还能回退到Baidu公司？还是进入Baidu公司后能容易回退到Yahoo公司？</p>
<h3 id="-dijkstra-"><strong>Dijkstra</strong>最短路径</h3>
<p>最短路径是一个Greedy + DP的算法。相当经典。这个算法的大意如下：</p>
<p>1）在初始化的时候，所有的结点都和我是无穷大，默认是达不到的。</p>
<p>2）从离自己最近的结点开始贪婪。</p>
<p>3）走过去，看看又能到达什么样的结点，计算并更新到所有目标点的距离。</p>
<p>4）再贪婪与原点最短的结点，如此反复。</p>
<p>这个算法给我们带来了一些这样的启示：</p>
<ul>
<li><p>有朋友和我说过他想成为一个架构师，或是某技术领域的专家，并会踏踏实实的向这个目标前进，永不放弃。我还是鼓励了他，但我也告诉他了这个著名的算法，我说，这个算法告诉你，架构师或某领域的专家对你来说目前的距离是无穷大，他们放在心中，先看看你能够得着的东西。<strong>所谓踏实，并不是踏踏实实追求你的目标，而是踏踏实实把你够得着看得见的就在身边的东西干好。</strong>我还记得我刚参加工作，从老家出来的时候，从来没有想过要成为一个技术牛人，也从来没有想过我的博客会那么的有影响力，在做自己力所能及，看得见摸得着的事情，我就看见什么技术就学什么，学着学着就知道怎么学更轻松，怎么学更扎实，这也许就是我的最短路径。</p>
</li>
<li><p>有很多朋友问我要不要学C++，或是问我学Python还是学Ruby，是不是不用学前端，等等。这些朋友告诉我，他们不可能学习多个语言，学了不用也就忘了，而且术业有专攻。这并没有什么不对的，只是我个人觉得，学习一个东西没有必要只有两种状态，一种是不学，另一种是精通。了解一个技术其实花不了多少时间，我学C++的目的其实是为了更懂Java，学TCP/IP协议其实是为了更懂Socket编程，很多东西都是连通和相辅相成的，学好了C/C++/Unix/TCP等这些基础技术后，我发现到达别的技术路径一下缩短了（这就是为什么<a href="http://coolshell.cn/articles/8489.html" title="Go 语言简介（下）— 特性" target="_blank">我用两天时间就可以了解Go语言的原因</a>）。<strong>这就好像这个算法一样，算法效率不高，也许达到你的目标，你在一开始花了很长时间，遍历了很多地方，但是，这也许这就是你的最短路径</strong>。</p>
</li>
</ul>
<h3 id="-trade-off">算法就是Trade-Off</h3>
<p>你根本没有办法能得到所有你想得到的东西，<strong>任何的选择都意味着放弃</strong>——<strong>当你要去获得一个东西的时候，你总是需要放弃一些东西</strong>。<strong>人生本来就是一个跷跷板，一头上，另一头必然下</strong>。这和我们做软件设计或算法设计一样，用时间换空间，用空间换时间，还有CAP理论，总是有很多的Trade-Off，正如这个短语的原意一样——<strong>你总是要用某种东西去交易某种东西</strong>。</p>
<p>我们都在用某种东西在交易我们的未来，有的人用自己的努力，有的人用自己的思考，有的人用自己的年轻，有的人用自己的自由，有的人用自己的价值观，有的人用自己的道德…… …… 有的人在交换金钱，有的人在交换眼界，有的人在交换经历，有的人在交换地位，有的人在交换能力，有的人在交换自由，有的人在交换兴趣，有的人在交换虚荣心，在交换安逸享乐…… ……</p>
<p><strong>每个人有每个人的算法，每个算法都有每个算法的purpose，就算大家在用同样的算法，但是每个人算法中的那些变量、开关和条件都不一样，得到的结果也不一样。我们就是生活在Matrix里的一段程序，我们每个人的算法决定着我们每个人的选择，我们的选择决定了我们的人生</strong>。</p>
<p><strong>2012年就要过去了，祝大家新年快乐！</strong>
<img src="" alt="插图来自电影 Life of Pi"></p>
<p>插图来自电影 Life of Pi</p>
<p>（全文完）</p>
<p><strong>（转载本站文章请注明作者和出处 <a href="http://coolshell.cn/" target="_blank">酷壳 – CoolShell.cn</a> ，请勿用于任何商业用途）</strong></p>
<p>——=== <strong>访问 <a href="http://coolshell.cn/404/" target="_blank">酷壳404页面</a> 以支持公益事业</strong> ===——
<a href="&quot;分享到新浪微博&quot;"></a><a href="&quot;分享到腾讯微博&quot;"></a><a href="&quot;分享到搜狐微博&quot;"></a><a href="&quot;分享到网易微博&quot;"></a><a href="&quot;分享到豆瓣&quot;"></a><a href="&quot;分享到人人网&quot;"></a><a href=""></a><a href="&quot;分享到饭否&quot;"></a><a href="&quot;分享到Twitter&quot;"></a><a href="&quot;分享到Facebook&quot;"></a><a href="&quot;分享到Gmail邮箱&quot;"></a><a href="&quot;分享到LinkedIn&quot;"></a><a href="&quot;分享到FriendFeed&quot;"></a><a href="&quot;分享到Digg&quot;"></a><a href="http://www.jiathis.com/share?uid=1541368" target="_blank"></a><a href="">573</a>
分类: <a href="http://coolshell.cn/category/misc" title="查看 杂项资源 中的全部文章" target="_blank">杂项资源</a> 标签: <a href="http://coolshell.cn/tag/algorithm" target="_blank">Algorithm</a>, <a href="http://coolshell.cn/tag/job" target="_blank">Job</a>, <a href="http://coolshell.cn/tag/programmer" target="_blank">Programmer</a>, <a href="http://coolshell.cn/tag/%e7%a8%8b%e5%ba%8f%e5%91%98" target="_blank">程序员</a></p>
<p><img src="&quot;好烂啊&quot;" alt="好烂啊"><img src="&quot;有点差&quot;" alt="有点差"><img src="&quot;凑合看看&quot;" alt="凑合看看"><img src="&quot;还不错&quot;" alt="还不错"><img src="&quot;很精彩&quot;" alt="很精彩"> (<strong>111</strong> 人打了分，平均分： <strong>4.94</strong> )
<img src="&quot;Loading ...&quot;" alt="Loading ..."> Loading ...</p>
<h3 id="-">相关文章</h3>
<ul>
<li>2012年08月22日 -- <a href="http://coolshell.cn/articles/8138.html" target="_blank">为什么我反对纯算法面试题</a></li>
<li>2012年04月17日 -- <a href="http://coolshell.cn/articles/7048.html" target="_blank">挑战无处不在</a></li>
<li>2011年12月20日 -- <a href="http://coolshell.cn/articles/6142.html" target="_blank">三个事和三个问题</a></li>
<li>2010年10月26日 -- <a href="http://coolshell.cn/articles/3231.html" target="_blank">你和你的工作</a></li>
<li>2012年04月11日 -- <a href="http://coolshell.cn/articles/6994.html" target="_blank">我们需要专职的QA吗？</a></li>
<li>2012年08月27日 -- <a href="http://coolshell.cn/articles/8170.html" target="_blank">一次Ajax查错的经历</a></li>
<li>2012年08月16日 -- <a href="http://coolshell.cn/articles/8088.html" target="_blank">对技术的态度</a></li>
<li>2012年04月19日 -- <a href="http://coolshell.cn/articles/7126.html" target="_blank">这到底是谁之错？</a>
<a href="http://www.zemanta.com/?wp-related-posts" target="_blank">Zemanta</a></li>
</ul>
<p><a href="">评论 (168)</a> <a href="">Trackbacks (12)</a> <a href="">发表评论</a> <a href="http://coolshell.cn/articles/8790.html/trackback" target="_blank">Trackback</a></p>
<ol>
<li><img src="" alt=""></li>
</ol>
<p>qte</p>
<p>2013年2月18日23:20 | <a href="">/#1</a></p>
<p><a href="">回复</a> | <a href="">引用</a>
想了下，DP也说得通，抱歉打搅了<a href="">@sigh1988</a></p>
<ol>
<li><img src="" alt=""></li>
</ol>
<p>lanxzh</p>
<p>2013年2月20日10:31 | <a href="">/#2</a></p>
<p><a href="">回复</a> | <a href="">引用</a>
写得作者切身经历的体会和感受，非常好!</p>
<ol>
<li><img src="" alt=""></li>
</ol>
<p>jpbai</p>
<p>2013年2月20日16:57 | <a href="">/#3</a></p>
<p><a href="">回复</a> | <a href="">引用</a>
身在其中的时候经常会表现得浮躁</p>
<ol>
<li><img src="" alt=""></li>
</ol>
<p>FansUnion</p>
<p>2013年2月25日16:41 | <a href="">/#4</a></p>
<p><a href="">回复</a> | <a href="">引用</a>
非常经典啊!</p>
<p>使用几种经典的算法，回答了 若干人的提问-困惑-纠结。</p>
<p>赞！</p>
<ol>
<li><img src="" alt=""></li>
</ol>
<p>sam wu</p>
<p>2013年2月27日14:29 | <a href="">/#5</a></p>
<p><a href="">回复</a> | <a href="">引用</a>
蛮好的文章，很多人面临这些问题。</p>
<ol>
<li><img src="" alt=""></li>
</ol>
<p>LEo</p>
<p>2013年2月27日21:15 | <a href="">/#6</a></p>
<p><a href="">回复</a> | <a href="">引用</a>
看看这些，我自己觉得好讽刺。我现在连一个机会都没有。难道我只好去参加那些培训吗？</p>
<ol>
<li><img src="" alt=""></li>
</ol>
<p><a href="http://www.cnblogs.com/effort0209/" target="_blank">effort</a></p>
<p>2013年3月24日17:55 | <a href="">/#7</a></p>
<p><a href="">回复</a> | <a href="">引用</a>
说的不错，比喻恰当，追求时间舍不得空间，怀拥空间，又惦念着时间，可能真正的茫然是：我们不知道想要什么，总觉得一切东西放到一起时总会有平衡点，当寻求平衡点时，又忘记了我们自己，空耗了精力…..</p>
<ol>
<li><img src="" alt=""></li>
</ol>
<p>tamalegebi</p>
<p>2013年4月2日15:34 | <a href="">/#8</a></p>
<p><a href="">回复</a> | <a href="">引用</a>
完全看不懂算法和人生有啥直接关系，到时那个和网友的扯淡很有意思</p>
<ol>
<li><img src="" alt=""></li>
</ol>
<p>sunny鮟</p>
<p>2013年4月2日22:23 | <a href="">/#9</a></p>
<p><a href="">回复</a> | <a href="">引用</a>
越看越有意思,一个不喜欢自己专业而喜欢搞搞计算机但又完全不会计算机而苦恼的在自学了一段时间之后好像没学一样的大二学生看完表示,还是不知道未来的路在何方……..</p>
<ol>
<li><img src="" alt=""></li>
</ol>
<p><a href="http://lq2419.blog.51cto.com/" target="_blank">呼伦贝尔</a></p>
<p>2013年4月12日21:08 | <a href="">/#10</a></p>
<p><a href="">回复</a> | <a href="">引用</a>
以前忘记在哪看到过这篇文章，觉得这篇不错，现在在你博客里看到，果断转载了。</p>
<ol>
<li><img src="" alt=""></li>
</ol>
<p>linwkr</p>
<p>2013年5月1日18:46 | <a href="">/#11</a></p>
<p><a href="">回复</a> | <a href="">引用</a>
学习了。。。
从自己的领域对人生的思考:每个人都有每个人的算法</p>
<ol>
<li><img src="" alt=""></li>
</ol>
<p>it_liao</p>
<p>2013年5月6日00:19 | <a href="">/#12</a></p>
<p><a href="">回复</a> | <a href="">引用</a>
写得非常棒，要顶~</p>
<ol>
<li><img src="" alt=""></li>
</ol>
<p>IT熊猫</p>
<p>2013年6月21日18:31 | <a href="">/#13</a></p>
<p><a href="">回复</a> | <a href="">引用</a>
好形象哇，好明白哇，看完这我就知道那些 把简单事说得那么复杂的 “大师” 们是多么贱了。
皓哥你的确很高啊，既让我明白了算法的原理，又有点人生感悟的意思，不愧是高手哇。
以后多写点这样的文章啊，不必非得人生感悟哇，把技术知识点形象话就很造福啦。</p>
<ol>
<li><img src="" alt=""></li>
</ol>
<p>kunpengku</p>
<p>2013年6月21日21:00 | <a href="">/#14</a></p>
<p><a href="">回复</a> | <a href="">引用</a>
文章写的非常好，关于算法和人生的结合。</p>
<ol>
<li><img src="" alt=""></li>
</ol>
<p><a href="http://my.oschina.net/nicefan" target="_blank">Fan.Action</a></p>
<p>2013年6月28日16:23 | <a href="">/#15</a></p>
<p><a href="">回复</a> | <a href="">引用</a>
很受启发，很好文章，很受启发！</p>
<ol>
<li><img src="" alt=""></li>
</ol>
<p><a href="http://blog.csdn.net/mxdlove00" target="_blank">大灰狼</a></p>
<p>2013年7月2日12:47 | <a href="">/#16</a></p>
<p><a href="">回复</a> | <a href="">引用</a>
楼主这样的才算是真正的活学活用啊，我感觉我的算法白学了。楼主的这种抽象思维值得学习！</p>
<ol>
<li><img src="" alt=""></li>
</ol>
<p>呢喃的猫咪</p>
<p>2013年7月12日10:47 | <a href="">/#17</a></p>
<p><a href="">回复</a> | <a href="">引用</a>
我是在其他地方看到这篇文章，然后追过来的。
我很喜欢算法，但很遗憾我不懂算法，唯一值得庆幸的是，大学里学的数学专业，现在也算在做编程的工作。文章的的几种算法，每一种几乎都是我大学里地一门专业课。
把对算法的理解融入到人生和职场，才能引发程序员们的共鸣啊。对大部分程序员来说，图片和语言很多时候都显得很苍白无力，很多人都不屑于去看文字去读文字，有时候我也会觉得看那么多废话不如多看多写两行代码来的实在，只是，偶尔真的需要停下来思考思考。这篇从程序员的视角切入的感悟，才能真正引人深思啊。</p>
<ol>
<li><img src="" alt=""></li>
</ol>
<p>呢喃的猫咪</p>
<p>2013年7月12日11:11 | <a href="">/#18</a></p>
<p><a href="">回复</a> | <a href="">引用</a>
算法效率不高，也许达到你的目标，你在一开始花了很长时间，遍历了很多地方，但是，这也许这就是你的最短路径。</p>
<p>我最认可的一句话，因为我终于明白为什么在所有的否定之下我仍然能坚持自己所做之事。我一直相信，也许我现在做的对目前而言不是最优的，但一定是离初始目的最近的。
评论分页</p>
<p><a href="http://coolshell.cn/articles/8790.html/comment-page-3#comments" target="_blank">« 上一页</a> <a href="http://coolshell.cn/articles/8790.html/comment-page-1#comments" target="_blank">1</a> <a href="http://coolshell.cn/articles/8790.html/comment-page-2#comments" target="_blank">2</a> <a href="http://coolshell.cn/articles/8790.html/comment-page-3#comments" target="_blank">3</a> 4 8790</p>
<ol>
<li>2012年12月29日23:14 | <a href="">/#1</a></li>
</ol>
<p><a href="http://argcandargv.com/archives/936" target="_blank">程序算法与人生选择 | argc &amp;&amp; argv</a></p>
<ol>
<li>2012年12月30日20:05 | <a href="">/#2</a></li>
</ol>
<p><a href="http://binary.duapp.com/2012/12/972.html" target="_blank">程序算法与人生选择 | 蜗牛都知道</a></p>
<ol>
<li>2013年1月2日09:23 | <a href="">/#3</a></li>
</ol>
<p><a href="http://www.coderli.com/%e7%a8%8b%e5%ba%8f%e7%ae%97%e6%b3%95%e4%b8%8e%e4%ba%ba%e7%94%9f%e9%80%89%e6%8b%a9" target="_blank">程序算法与人生选择 | OneCoder</a></p>
<ol>
<li>2013年1月5日10:29 | <a href="">/#4</a></li>
</ol>
<p><a href="http://php8848.com/3620.html" target="_blank">我所看到的那些博主的2012年工作总结 | 高度PHP</a></p>
<ol>
<li>2013年1月5日10:45 | <a href="">/#5</a></li>
</ol>
<p><a href="http://g00.asia/2013/01/94.html" target="_blank">程序算法与人生选择 | grace自留地</a></p>
<ol>
<li>2013年1月7日16:01 | <a href="">/#6</a></li>
</ol>
<p><a href="http://www.67tgb.com/?p=532" target="_blank">望月听涛 » 2012年度工作总结</a></p>
<ol>
<li>2013年1月7日16:18 | <a href="">/#7</a></li>
</ol>
<p><a href="http://architecture.riaos.com/?p=3017963" target="_blank">2012年度工作总结 | 架构（architecture.riaos.com）</a></p>
<ol>
<li>2013年2月23日22:28 | <a href="">/#8</a></li>
</ol>
<p><a href="http://sirx.wordpress.com.cn/2013/02/23/%e7%a8%8b%e5%ba%8f%e7%ae%97%e6%b3%95%e4%b8%8e%e4%ba%ba%e7%94%9f%e9%80%89%e6%8b%a9z/" target="_blank">程序算法与人生选择[z] » 笑笑先生</a></p>
<ol>
<li>2013年4月10日15:35 | <a href="">/#9</a></li>
</ol>
<p><a href="http://codingke.sinaapp.com/?p=4" target="_blank">Codingke-左手代码右手湿 » 《Rework》摘录及感想</a></p>
<ol>
<li>2013年4月12日14:44 | <a href="">/#10</a></li>
</ol>
<p><a href="http://codingke.sinaapp.com/?p=42" target="_blank">Codingke-编程疯子 » 《Rework》摘录及感想</a></p>
<ol>
<li>2013年4月20日09:49 | <a href="">/#11</a></li>
</ol>
<p><a href="http://www.ruanfei.com/news/archives/77" target="_blank">一个程序员对《Rework》的摘录及感想 – 软飞</a></p>
<ol>
<li>2013年5月15日15:19 | <a href="">/#12</a></li>
</ol>
<p><a href="http://www.w3c.com.cn/%e7%a8%8b%e5%ba%8f%e7%ae%97%e6%b3%95%e4%b8%8e%e4%ba%ba%e7%94%9f%e9%80%89%e6%8b%a9" target="_blank">程序算法与人生选择 – Sina App Engine – 开发者问答</a>
昵称 (必填)</p>
<p>电子邮箱 (我们会为您保密) (必填)
网址</p>
<p><a href="http://coolshell.cn/comments/feed" target="_blank">订阅评论</a></p>
<p><a href="http://coolshell.cn/articles/8883.html" target="_blank">应该知道的Linux技巧</a> <a href="http://coolshell.cn/articles/8767.html" target="_blank">Web工程师的工具箱</a></p>
<p><a href="http://coolshell.cn/feed" title="订阅这个博客的文章" target="_blank">订阅</a></p>
<ul>
<li><a href="http://fusion.google.com/add?feedurl=http://coolshell.cn/feed" title="订阅到 Google" target="_blank">Google</a></li>
<li><a href="http://reader.youdao.com/#url=http://coolshell.cn/feed" title="订阅到有道" target="_blank">有道</a></li>
<li><a href="http://www.xianguo.com/subscribe.php?url=http://coolshell.cn/feed" title="订阅到鲜果" target="_blank">鲜果</a></li>
<li><a href="http://www.zhuaxia.com/add_channel.php?url=http://coolshell.cn/feed" title="订阅到抓虾" target="_blank">抓虾</a></li>
<li><a href="http://add.my.yahoo.com/rss?url=http://coolshell.cn/feed" title="订阅到 My Yahoo!" target="_blank">My Yahoo!</a></li>
<li><a href="http://www.newsgator.com/ngs/subscriber/subfext.aspx?url=http://coolshell.cn/feed" title="订阅到 newsgator" target="_blank">newsgator</a></li>
<li><a href="http://www.bloglines.com/sub/http://coolshell.cn/feed" title="订阅到 Bloglines" target="_blank">Bloglines</a></li>
<li><a href="http://inezha.com/add?url=http://coolshell.cn/feed" title="订阅到哪吒" target="_blank">哪吒</a></li>
<li><a href="http://mail.qq.com/cgi-bin/feed?u=http://coolshell.cn/feed" title="订阅到QQ Mail" target="_blank">QQ Mail</a></li>
<li><a href="http://9.douban.com/reader/subscribe?url=http://coolshell.cn/feed" title="订阅到Douban" target="_blank">Douban</a></li>
<li><a href="http://www.rojo.com/add-subscription?resource=http://coolshell.cn/feed" title="订阅到Rojo" target="_blank">Rojo</a></li>
<li><a href="http://www.pageflakes.com/subscribe.aspx?url=http://coolshell.cn/feed" title="订阅到Pageflakes" target="_blank">Pageflakes</a>
<a href="http://twitter.com/haoel/" title="Follow me!" target="_blank">Twitter</a></li>
</ul>
<h3 id="-">本站公告</h3>
<p>访问 <a href="http://coolshell.cn/404/" target="_blank">酷壳404页面</a> 支持公益！</p>
<p>酷壳建议大家多使用RSS访问阅读（本站已经是全文输出，推荐使用cloud.feedly.com）。有相关事宜欢迎电邮：haoel(at)hotmail.com。最后，感谢大家对酷壳的支持和体谅！</p>
<p><strong>感谢 <a href="http://42qu.com/" title="42区 找到给你答案的人" target="_blank">42qu.com</a> 为本站提供 <a href="http://vps.42qu.com/" title="42区虚拟主机，卖给创业的你" target="_blank">VPS</a></strong></p>
<h3 id="-">最新文章</h3>
<ul>
<li><a href="http://coolshell.cn/articles/10217.html" title="加班与效率" target="_blank">加班与效率</a></li>
<li><a href="http://coolshell.cn/articles/10169.html" title="类型的本质和函数式实现" target="_blank">类型的本质和函数式实现</a></li>
<li><a href="http://coolshell.cn/articles/10115.html" title="C语言全局变量那些事儿" target="_blank">C语言全局变量那些事儿</a></li>
<li><a href="http://coolshell.cn/articles/9886.html" title="二叉树迭代器算法" target="_blank">二叉树迭代器算法</a></li>
<li><a href="http://coolshell.cn/articles/9917.html" title="Alan Cox：大教堂、市集与市议会" target="_blank">Alan Cox：大教堂、市集与市议会</a></li>
<li><a href="http://coolshell.cn/articles/9949.html" title="IoC/DIP其实是一种管理思想" target="_blank">IoC/DIP其实是一种管理思想</a></li>
<li><a href="http://coolshell.cn/articles/9859.html" title="Alan Cox：单向链表中prev指针的妙用" target="_blank">Alan Cox：单向链表中prev指针的妙用</a></li>
<li><a href="http://coolshell.cn/articles/9749.html" title="Javascript 装载和执行" target="_blank">Javascript 装载和执行</a></li>
<li><a href="http://coolshell.cn/articles/9703.html" title="无锁HashMap的原理与实现" target="_blank">无锁HashMap的原理与实现</a></li>
<li><a href="http://coolshell.cn/articles/9666.html" title="浏览器的渲染原理简介" target="_blank">浏览器的渲染原理简介</a></li>
<li><a href="http://coolshell.cn/articles/9606.html" title="疫苗：Java HashMap的死循环" target="_blank">疫苗：Java HashMap的死循环</a></li>
<li><a href="http://coolshell.cn/articles/9543.html" title="“C++的数组不支持多态”？" target="_blank">“C++的数组不支持多态”？</a></li>
<li><a href="http://coolshell.cn/articles/9410.html" title="Unix考古记：一个“遗失”的shell" target="_blank">Unix考古记：一个“遗失”的shell</a></li>
<li><a href="http://coolshell.cn/articles/9508.html" title="PFIF网上寻人协议" target="_blank">PFIF网上寻人协议</a></li>
<li><a href="http://coolshell.cn/articles/9308.html" title="“作环保的程序员，从不用百度开始”" target="_blank">“作环保的程序员，从不用百度开始”</a></li>
<li><a href="http://coolshell.cn/articles/9156.html" title="《Rework》摘录及感想" target="_blank">《Rework》摘录及感想</a></li>
<li><a href="http://coolshell.cn/articles/9229.html" title="实例分析Java Class的文件结构" target="_blank">实例分析Java Class的文件结构</a></li>
<li><a href="http://coolshell.cn/articles/9169.html" title="并发框架Disruptor译文" target="_blank">并发框架Disruptor译文</a></li>
<li><a href="http://coolshell.cn/articles/9104.html" title="sed 简明教程" target="_blank">sed 简明教程</a></li>
<li><a href="http://coolshell.cn/articles/9070.html" title="AWK 简明教程" target="_blank">AWK 简明教程</a></li>
<li><a href="http://coolshell.cn/articles/8990.html" title="Linus：利用二级指针删除单向链表" target="_blank">Linus：利用二级指针删除单向链表</a></li>
<li><a href="http://coolshell.cn/articles/8961.html" title="从面向对象的设计模式看软件设计" target="_blank">从面向对象的设计模式看软件设计</a></li>
<li><a href="http://coolshell.cn/articles/8883.html" title="应该知道的Linux技巧" target="_blank">应该知道的Linux技巧</a></li>
<li><a href="http://coolshell.cn/articles/8790.html" title="程序算法与人生选择" target="_blank">程序算法与人生选择</a></li>
<li><a href="http://coolshell.cn/articles/8767.html" title="Web工程师的工具箱" target="_blank">Web工程师的工具箱</a></li>
<li><a href="http://coolshell.cn/articles/8745.html" title="如此理解面向对象编程" target="_blank">如此理解面向对象编程</a></li>
<li><a href="http://coolshell.cn/articles/8711.html" title="程序员疫苗：代码注入" target="_blank">程序员疫苗：代码注入</a></li>
<li><a href="http://coolshell.cn/articles/8619.html" title="你可能不知道的Shell" target="_blank">你可能不知道的Shell</a></li>
<li><a href="http://coolshell.cn/articles/8638.html" title="为什么不能用微信或米聊这类的软件" target="_blank">为什么不能用微信或米聊这类的软件</a></li>
<li><a href="http://coolshell.cn/articles/8593.html" title="如何测试洗牌程序" target="_blank">如何测试洗牌程序</a></li>
</ul>
<h3 id="-">全站热门</h3>
<ul>
<li><a href="http://coolshell.cn/articles/4990.html" title="程序员技术练级攻略 - 312,422 人阅读" target="_blank">程序员技术练级攻略</a></li>
<li><a href="http://coolshell.cn/articles/5426.html" title="简明 Vim 练级攻略 - 234,355 人阅读" target="_blank">简明 Vim 练级攻略</a></li>
<li><a href="http://coolshell.cn/articles/4102.html" title="如何学好C语言 - 117,770 人阅读" target="_blank">如何学好C语言</a></li>
<li><a href="http://coolshell.cn/articles/914.html" title="6个变态的C语言Hello World程序 - 113,320 人阅读" target="_blank">6个变态的C语言Hello World程序</a></li>
<li><a href="http://coolshell.cn/articles/6470.html" title="由12306.cn谈谈网站性能技术 - 93,543 人阅读" target="_blank">由12306.cn谈谈网站性能技术</a></li>
<li><a href="http://coolshell.cn/articles/8883.html" title="应该知道的Linux技巧 - 89,617 人阅读" target="_blank">应该知道的Linux技巧</a></li>
<li><a href="http://coolshell.cn/articles/2250.html" title="“21天教你学会C++” - 89,390 人阅读" target="_blank">“21天教你学会C++”</a></li>
<li><a href="http://coolshell.cn/articles/3549.html" title="Android将允许纯C/C++开发应用 - 88,606 人阅读" target="_blank">Android将允许纯C/C++开发应用</a></li>
<li><a href="http://coolshell.cn/articles/1870.html" title="我是怎么招聘程序员的 - 87,272 人阅读" target="_blank">我是怎么招聘程序员的</a></li>
<li><a href="http://coolshell.cn/articles/7186.html" title="做个环保主义的程序员 - 84,428 人阅读" target="_blank">做个环保主义的程序员</a></li>
<li><a href="http://coolshell.cn/articles/9308.html" title="“作环保的程序员，从不用百度开始” - 80,045 人阅读" target="_blank">“作环保的程序员，从不用百度开始”</a></li>
<li><a href="http://coolshell.cn/articles/7829.html" title="28个Unix/Linux的命令行神器 - 75,080 人阅读" target="_blank">28个Unix/Linux的命令行神器</a></li>
<li><a href="http://coolshell.cn/articles/1391.html" title="编程真难啊 - 70,871 人阅读" target="_blank">编程真难啊</a></li>
<li><a href="http://coolshell.cn/articles/2287.html" title="C++ 程序员自信心曲线图 - 70,709 人阅读" target="_blank">C++ 程序员自信心曲线图</a></li>
<li><a href="http://coolshell.cn/articles/6043.html" title="Web开发中需要了解的东西 - 69,987 人阅读" target="_blank">Web开发中需要了解的东西</a></li>
<li><a href="http://coolshell.cn/articles/5701.html" title="SteveY对Amazon和Google平台的吐槽 - 69,372 人阅读" target="_blank">SteveY对Amazon和Google平台的吐槽</a></li>
<li><a href="http://coolshell.cn/articles/355.html" title="20本最好的Linux免费书籍 - 68,994 人阅读" target="_blank">20本最好的Linux免费书籍</a></li>
<li><a href="http://coolshell.cn/articles/4758.html" title="如何写出无法维护的代码 - 65,186 人阅读" target="_blank">如何写出无法维护的代码</a></li>
<li><a href="http://coolshell.cn/articles/8790.html" title="程序算法与人生选择 - 63,218 人阅读" target="_blank">程序算法与人生选择</a></li>
<li><a href="http://coolshell.cn/articles/2058.html" title="各种流行的编程风格 - 63,082 人阅读" target="_blank">各种流行的编程风格</a></li>
<li><a href="http://coolshell.cn/articles/3008.html" title="Windows编程革命简史 - 61,890 人阅读" target="_blank">Windows编程革命简史</a></li>
<li><a href="http://coolshell.cn/articles/4119.html" title="如何学好C++语言 - 61,778 人阅读" target="_blank">如何学好C++语言</a></li>
<li><a href="http://coolshell.cn/articles/5761.html" title="深入理解C语言 - 61,397 人阅读" target="_blank">深入理解C语言</a></li>
<li><a href="http://coolshell.cn/articles/4429.html" title="面试题：火车运煤问题 - 60,295 人阅读" target="_blank">面试题：火车运煤问题</a></li>
<li><a href="http://coolshell.cn/articles/6142.html" title="三个事和三个问题 - 59,185 人阅读" target="_blank">三个事和三个问题</a></li>
<li><a href="http://coolshell.cn/articles/1695.html" title="别的程序员是怎么读你的简历的 - 57,916 人阅读" target="_blank">别的程序员是怎么读你的简历的</a></li>
<li><a href="http://coolshell.cn/articles/2420.html" title="老手是这样教新手编程的 - 56,712 人阅读" target="_blank">老手是这样教新手编程的</a></li>
<li><a href="http://coolshell.cn/articles/945.html" title="C语言的谜题 - 54,791 人阅读" target="_blank">C语言的谜题</a></li>
<li><a href="http://coolshell.cn/articles/3363.html" title="偷了世界的程序员 - 54,702 人阅读" target="_blank">偷了世界的程序员</a></li>
<li><a href="http://coolshell.cn/articles/4506.html" title="再谈“我是怎么招聘程序员的”（上） - 54,089 人阅读" target="_blank">再谈“我是怎么招聘程序员的”（上）</a><h3 id="-">新浪微博</h3>
</li>
</ul>
<h3 id="-">标签</h3>
<p><a href="http://coolshell.cn/tag/agile" title="15 个话题" target="_blank">agile</a> <a href="http://coolshell.cn/tag/ajax" title="11 个话题" target="_blank">AJAX</a> <a href="http://coolshell.cn/tag/algorithm" title="20 个话题" target="_blank">Algorithm</a> <a href="http://coolshell.cn/tag/android" title="8 个话题" target="_blank">Android</a> <a href="http://coolshell.cn/tag/bash" title="8 个话题" target="_blank">Bash</a> <a href="http://coolshell.cn/tag/c" title="74 个话题" target="_blank">C++</a> <a href="http://coolshell.cn/tag/coding" title="25 个话题" target="_blank">Coding</a> <a href="http://coolshell.cn/tag/css" title="21 个话题" target="_blank">CSS</a> <a href="http://coolshell.cn/tag/database" title="7 个话题" target="_blank">Database</a> <a href="http://coolshell.cn/tag/design" title="17 个话题" target="_blank">Design</a> <a href="http://coolshell.cn/tag/design-pattern" title="8 个话题" target="_blank">design pattern</a> <a href="http://coolshell.cn/tag/ebook" title="15 个话题" target="_blank">ebook</a> <a href="http://coolshell.cn/tag/flash" title="7 个话题" target="_blank">Flash</a> <a href="http://coolshell.cn/tag/game" title="9 个话题" target="_blank">Game</a> <a href="http://coolshell.cn/tag/go" title="9 个话题" target="_blank">Go</a> <a href="http://coolshell.cn/tag/google" title="31 个话题" target="_blank">Google</a> <a href="http://coolshell.cn/tag/html" title="32 个话题" target="_blank">HTML</a> <a href="http://coolshell.cn/tag/ie" title="10 个话题" target="_blank">IE</a> <a href="http://coolshell.cn/tag/java" title="45 个话题" target="_blank">Java</a> <a href="http://coolshell.cn/tag/javascript" title="48 个话题" target="_blank">Javascript</a> <a href="http://coolshell.cn/tag/jquery" title="11 个话题" target="_blank">jQuery</a> <a href="http://coolshell.cn/tag/linux" title="58 个话题" target="_blank">Linux</a> <a href="http://coolshell.cn/tag/mysql" title="7 个话题" target="_blank">MySQL</a> <a href="http://coolshell.cn/tag/oop" title="8 个话题" target="_blank">OOP</a> <a href="http://coolshell.cn/tag/password" title="8 个话题" target="_blank">password</a> <a href="http://coolshell.cn/tag/performance" title="13 个话题" target="_blank">Performance</a> <a href="http://coolshell.cn/tag/php" title="25 个话题" target="_blank">PHP</a> <a href="http://coolshell.cn/tag/programmer" title="88 个话题" target="_blank">Programmer</a> <a href="http://coolshell.cn/tag/programming-language" title="12 个话题" target="_blank">programming language</a> <a href="http://coolshell.cn/tag/puzzle" title="9 个话题" target="_blank">Puzzle</a> <a href="http://coolshell.cn/tag/pythondev" title="27 个话题" target="_blank">Python</a> <a href="http://coolshell.cn/tag/ruby" title="9 个话题" target="_blank">Ruby</a> <a href="http://coolshell.cn/tag/sql" title="10 个话题" target="_blank">SQL</a> <a href="http://coolshell.cn/tag/tdd" title="8 个话题" target="_blank">TDD</a> <a href="http://coolshell.cn/tag/ui" title="12 个话题" target="_blank">UI</a> <a href="http://coolshell.cn/tag/unix" title="31 个话题" target="_blank">Unix</a> <a href="http://coolshell.cn/tag/vim" title="18 个话题" target="_blank">vim</a> <a href="http://coolshell.cn/tag/web" title="35 个话题" target="_blank">Web</a> <a href="http://coolshell.cn/tag/windows" title="17 个话题" target="_blank">Windows</a> <a href="http://coolshell.cn/tag/xml" title="8 个话题" target="_blank">XML</a> <a href="http://coolshell.cn/tag/%e5%8f%a3%e4%bb%a4" title="7 个话题" target="_blank">口令</a> <a href="http://coolshell.cn/tag/%e5%ae%89%e5%85%a8" title="16 个话题" target="_blank">安全</a> <a href="http://coolshell.cn/tag/%e7%a8%8b%e5%ba%8f%e5%91%98" title="88 个话题" target="_blank">程序员</a> <a href="http://coolshell.cn/tag/%e7%ae%97%e6%b3%95" title="9 个话题" target="_blank">算法</a> <a href="http://coolshell.cn/tag/interview" title="14 个话题" target="_blank">面试</a></p>
<h3 id="-">分类目录</h3>
<ul>
<li><a href="http://coolshell.cn/category/proglanguage/dotnet" title="查看 .NET编程 下的所有文章" target="_blank">.NET编程</a> (2)</li>
<li><a href="http://coolshell.cn/category/proglanguage/ajaxdev" title="查看 Ajax开发 下的所有文章" target="_blank">Ajax开发</a> (9)</li>
<li><a href="http://coolshell.cn/category/proglanguage/cplusplus" title="查看 C/C++语言 下的所有文章" target="_blank">C/C++语言</a> (53)</li>
<li><a href="http://coolshell.cn/category/proglanguage/erlang" title="查看 Erlang 下的所有文章" target="_blank">Erlang</a> (1)</li>
<li><a href="http://coolshell.cn/category/proglanguage/javadev" title="查看 Java语言 下的所有文章" target="_blank">Java语言</a> (29)</li>
<li><a href="http://coolshell.cn/category/proglanguage/phpdev" title="查看 PHP脚本 下的所有文章" target="_blank">PHP脚本</a> (11)</li>
<li><a href="http://coolshell.cn/category/proglanguage/pythondev" title="查看 Python 下的所有文章" target="_blank">Python</a> (21)</li>
<li><a href="http://coolshell.cn/category/proglanguage/rubydev" title="查看 Ruby 下的所有文章" target="_blank">Ruby</a> (4)</li>
<li><a href="http://coolshell.cn/category/operatingsystem/unixlinux" title="查看 Unix/Linux 下的所有文章" target="_blank">Unix/Linux</a> (66)</li>
<li><a href="http://coolshell.cn/category/proglanguage/webdev" title="查看 Web开发 下的所有文章" target="_blank">Web开发</a> (99)</li>
<li><a href="http://coolshell.cn/category/operatingsystem/mswindows" title="查看 Windows 下的所有文章" target="_blank">Windows</a> (12)</li>
<li><a href="http://coolshell.cn/category/itnews" title="查看 业界新闻 下的所有文章" target="_blank">业界新闻</a> (25)</li>
<li><a href="http://coolshell.cn/category/%e4%bc%81%e4%b8%9a%e5%ba%94%e7%94%a8" title="查看 企业应用 下的所有文章" target="_blank">企业应用</a> (2)</li>
<li><a href="http://coolshell.cn/category/technews" title="查看 技术新闻 下的所有文章" target="_blank">技术新闻</a> (32)</li>
<li><a href="http://coolshell.cn/category/%e6%8a%80%e6%9c%af%e7%ae%a1%e7%90%86" title="查看 技术管理 下的所有文章" target="_blank">技术管理</a> (10)</li>
<li><a href="http://coolshell.cn/category/techarticle" title="查看 技术读物 下的所有文章" target="_blank">技术读物</a> (115)</li>
<li><a href="http://coolshell.cn/category/operatingsystem" title="查看 操作系统 下的所有文章" target="_blank">操作系统</a> (43)</li>
<li><a href="http://coolshell.cn/category/datebase" title="查看 数据库 下的所有文章" target="_blank">数据库</a> (10)</li>
<li><a href="http://coolshell.cn/category/misc" title="查看 杂项资源 下的所有文章" target="_blank">杂项资源</a> (249)</li>
<li><a href="http://coolshell.cn/category/process" title="查看 流程方法 下的所有文章" target="_blank">流程方法</a> (43)</li>
<li><a href="http://coolshell.cn/category/progdesign" title="查看 程序设计 下的所有文章" target="_blank">程序设计</a> (69)</li>
<li><a href="http://coolshell.cn/category/%e7%b3%bb%e7%bb%9f%e6%9e%b6%e6%9e%84" title="查看 系统架构 下的所有文章" target="_blank">系统架构</a> (6)</li>
<li><a href="http://coolshell.cn/category/tools" title="查看 编程工具 下的所有文章" target="_blank">编程工具</a> (61)</li>
<li><a href="http://coolshell.cn/category/proglanguage" title="查看 编程语言 下的所有文章" target="_blank">编程语言</a> (159)</li>
<li><a href="http://coolshell.cn/category/netsecurity" title="查看 网络安全 下的所有文章" target="_blank">网络安全</a> (22)</li>
<li><a href="http://coolshell.cn/category/career" title="查看 职场生涯 下的所有文章" target="_blank">职场生涯</a> (32)</li>
<li><a href="http://coolshell.cn/category/funny" title="查看 趣味问题 下的所有文章" target="_blank">趣味问题</a> (13)</li>
<li><a href="http://coolshell.cn/category/story" title="查看 轶事趣闻 下的所有文章" target="_blank">轶事趣闻</a> (145)</li>
</ul>
<h3 id="-">归档</h3>
<ul>
<li><a href="http://coolshell.cn/articles/date/2013/07" title="2013 年七月" target="_blank">2013 年七月</a> (6)</li>
<li><a href="http://coolshell.cn/articles/date/2013/06" title="2013 年六月" target="_blank">2013 年六月</a> (2)</li>
<li><a href="http://coolshell.cn/articles/date/2013/05" title="2013 年五月" target="_blank">2013 年五月</a> (3)</li>
<li><a href="http://coolshell.cn/articles/date/2013/04" title="2013 年四月" target="_blank">2013 年四月</a> (3)</li>
<li><a href="http://coolshell.cn/articles/date/2013/03" title="2013 年三月" target="_blank">2013 年三月</a> (3)</li>
<li><a href="http://coolshell.cn/articles/date/2013/02" title="2013 年二月" target="_blank">2013 年二月</a> (5)</li>
<li><a href="http://coolshell.cn/articles/date/2013/01" title="2013 年一月" target="_blank">2013 年一月</a> (1)</li>
<li><a href="http://coolshell.cn/articles/date/2012/12" title="2012 年十二月" target="_blank">2012 年十二月</a> (4)</li>
<li><a href="http://coolshell.cn/articles/date/2012/11" title="2012 年十一月" target="_blank">2012 年十一月</a> (5)</li>
<li><a href="http://coolshell.cn/articles/date/2012/10" title="2012 年十月" target="_blank">2012 年十月</a> (3)</li>
<li><a href="http://coolshell.cn/articles/date/2012/09" title="2012 年九月" target="_blank">2012 年九月</a> (4)</li>
<li><a href="http://coolshell.cn/articles/date/2012/08" title="2012 年八月" target="_blank">2012 年八月</a> (8)</li>
<li><a href="http://coolshell.cn/articles/date/2012/07" title="2012 年七月" target="_blank">2012 年七月</a> (4)</li>
<li><a href="http://coolshell.cn/articles/date/2012/06" title="2012 年六月" target="_blank">2012 年六月</a> (7)</li>
<li><a href="http://coolshell.cn/articles/date/2012/05" title="2012 年五月" target="_blank">2012 年五月</a> (6)</li>
<li><a href="http://coolshell.cn/articles/date/2012/04" title="2012 年四月" target="_blank">2012 年四月</a> (6)</li>
<li><a href="http://coolshell.cn/articles/date/2012/03" title="2012 年三月" target="_blank">2012 年三月</a> (6)</li>
<li><a href="http://coolshell.cn/articles/date/2012/02" title="2012 年二月" target="_blank">2012 年二月</a> (3)</li>
<li><a href="http://coolshell.cn/articles/date/2012/01" title="2012 年一月" target="_blank">2012 年一月</a> (6)</li>
<li><a href="http://coolshell.cn/articles/date/2011/12" title="2011 年十二月" target="_blank">2011 年十二月</a> (5)</li>
<li><a href="http://coolshell.cn/articles/date/2011/11" title="2011 年十一月" target="_blank">2011 年十一月</a> (9)</li>
<li><a href="http://coolshell.cn/articles/date/2011/10" title="2011 年十月" target="_blank">2011 年十月</a> (6)</li>
<li><a href="http://coolshell.cn/articles/date/2011/09" title="2011 年九月" target="_blank">2011 年九月</a> (5)</li>
<li><a href="http://coolshell.cn/articles/date/2011/08" title="2011 年八月" target="_blank">2011 年八月</a> (14)</li>
<li><a href="http://coolshell.cn/articles/date/2011/07" title="2011 年七月" target="_blank">2011 年七月</a> (6)</li>
<li><a href="http://coolshell.cn/articles/date/2011/06" title="2011 年六月" target="_blank">2011 年六月</a> (12)</li>
<li><a href="http://coolshell.cn/articles/date/2011/05" title="2011 年五月" target="_blank">2011 年五月</a> (5)</li>
<li><a href="http://coolshell.cn/articles/date/2011/04" title="2011 年四月" target="_blank">2011 年四月</a> (18)</li>
<li><a href="http://coolshell.cn/articles/date/2011/03" title="2011 年三月" target="_blank">2011 年三月</a> (16)</li>
<li><a href="http://coolshell.cn/articles/date/2011/02" title="2011 年二月" target="_blank">2011 年二月</a> (16)</li>
<li><a href="http://coolshell.cn/articles/date/2011/01" title="2011 年一月" target="_blank">2011 年一月</a> (18)</li>
<li><a href="http://coolshell.cn/articles/date/2010/12" title="2010 年十二月" target="_blank">2010 年十二月</a> (11)</li>
<li><a href="http://coolshell.cn/articles/date/2010/11" title="2010 年十一月" target="_blank">2010 年十一月</a> (11)</li>
<li><a href="http://coolshell.cn/articles/date/2010/10" title="2010 年十月" target="_blank">2010 年十月</a> (19)</li>
<li><a href="http://coolshell.cn/articles/date/2010/09" title="2010 年九月" target="_blank">2010 年九月</a> (15)</li>
<li><a href="http://coolshell.cn/articles/date/2010/08" title="2010 年八月" target="_blank">2010 年八月</a> (10)</li>
<li><a href="http://coolshell.cn/articles/date/2010/07" title="2010 年七月" target="_blank">2010 年七月</a> (20)</li>
<li><a href="http://coolshell.cn/articles/date/2010/06" title="2010 年六月" target="_blank">2010 年六月</a> (9)</li>
<li><a href="http://coolshell.cn/articles/date/2010/05" title="2010 年五月" target="_blank">2010 年五月</a> (13)</li>
<li><a href="http://coolshell.cn/articles/date/2010/04" title="2010 年四月" target="_blank">2010 年四月</a> (12)</li>
<li><a href="http://coolshell.cn/articles/date/2010/03" title="2010 年三月" target="_blank">2010 年三月</a> (11)</li>
<li><a href="http://coolshell.cn/articles/date/2010/02" title="2010 年二月" target="_blank">2010 年二月</a> (7)</li>
<li><a href="http://coolshell.cn/articles/date/2010/01" title="2010 年一月" target="_blank">2010 年一月</a> (9)</li>
<li><a href="http://coolshell.cn/articles/date/2009/12" title="2009 年十二月" target="_blank">2009 年十二月</a> (22)</li>
<li><a href="http://coolshell.cn/articles/date/2009/11" title="2009 年十一月" target="_blank">2009 年十一月</a> (27)</li>
<li><a href="http://coolshell.cn/articles/date/2009/10" title="2009 年十月" target="_blank">2009 年十月</a> (17)</li>
<li><a href="http://coolshell.cn/articles/date/2009/09" title="2009 年九月" target="_blank">2009 年九月</a> (15)</li>
<li><a href="http://coolshell.cn/articles/date/2009/08" title="2009 年八月" target="_blank">2009 年八月</a> (21)</li>
<li><a href="http://coolshell.cn/articles/date/2009/07" title="2009 年七月" target="_blank">2009 年七月</a> (18)</li>
<li><a href="http://coolshell.cn/articles/date/2009/06" title="2009 年六月" target="_blank">2009 年六月</a> (19)</li>
<li><a href="http://coolshell.cn/articles/date/2009/05" title="2009 年五月" target="_blank">2009 年五月</a> (27)</li>
<li><a href="http://coolshell.cn/articles/date/2009/04" title="2009 年四月" target="_blank">2009 年四月</a> (53)</li>
<li><p><a href="http://coolshell.cn/articles/date/2009/03" title="2009 年三月" target="_blank">2009 年三月</a> (43)</p>
<h3 id="-">最新评论</h3>
</li>
<li><p><a href="http://coolshell.cn/articles/5132.html#comment-612339" title="疯狂的 Web 应用开源项目, 2011年08月11日" target="_blank">Coffee PUre Cleanse Diet</a>: Hi mates, how is the whole thing, and what you would like to say about this paragraph, in...</p>
</li>
<li><a href="http://coolshell.cn/articles/7186.html#comment-612323" title="做个环保主义的程序员, 2012年04月27日" target="_blank">Small Warm</a>: @呵呵 你认为用baidu就棱不到你吗</li>
<li><a href="http://coolshell.cn/articles/10217.html#comment-612301" title="加班与效率, 2013年07月24日" target="_blank">do</a>: 都是被勤能补拙害的. 天天加班的项目经理不是好程序猿</li>
<li><a href="http://coolshell.cn/articles/10217.html#comment-612246" title="加班与效率, 2013年07月24日" target="_blank">忧郁</a>: 加班没有加班费，是我一生中最大的痛</li>
<li><a href="http://coolshell.cn/guestbook#comment-612169" title="留言小本, 2009年03月02日" target="_blank">李巨宁</a>: 看了博主的几篇心得，觉得博主的语言很有重量，很踏实，实在是让 我获益良多，十分感谢。</li>
<li><a href="http://coolshell.cn/articles/3961.html#comment-612020" title="“火柴棍式”程序员面试题, 2011年03月21日" target="_blank">arrowcj</a>: 不能把i–变成i++么？</li>
<li><a href="http://coolshell.cn/articles/9859.html#comment-611941" title="Alan Cox：单向链表中prev指针的妙用, 2013年06月30日" target="_blank">Yeclipse</a>: The key point has nothing to do with linked list, nor with pre pointer. It just tries to avoid cloning one...</li>
<li><a href="http://coolshell.cn/articles/10217.html#comment-610764" title="加班与效率, 2013年07月24日" target="_blank">ForgetFul</a>: 中国是集体主义国家，其在人数和工作时间上的创造力总能让我惊叹</li>
<li><a href="http://coolshell.cn/articles/21.html#comment-610445" title="101个设计模式, 2009年03月02日" target="_blank">Darlena Failla</a>: First time visit here and have your terrific write-up. May I’ve a copy of the short article?</li>
<li><a href="http://coolshell.cn/articles/2394.html#comment-610430" title="九个PHP很有用的功能, 2010年05月06日" target="_blank">Octavia Vitera</a>: Wonderful collection, many thanks for sharing Eric :)</li>
<li><a href="http://coolshell.cn/articles/8745.html#comment-610422" title="如此理解面向对象编程, 2012年12月13日" target="_blank">Broderick Timmreck</a>: Many thanks for the backlink with podcast.</li>
<li><a href="http://coolshell.cn/articles/2492.html#comment-610416" title="WTF Javascript, 2010年06月02日" target="_blank">Joellen Pekara</a>: Extremely educational thanks, I reckon your current followers may well want even more well written...</li>
<li><a href="http://coolshell.cn/articles/4334.html#comment-610415" title="Eclipse开发Android应用程序入门:重装上阵, 2011年04月08日" target="_blank">Jonah Garvey</a>: I have been reading this blog for just a very good although. Keep up the magnificent job you are doing...</li>
<li><a href="http://coolshell.cn/articles/7992.html#comment-610407" title="C++的坑真的多吗？, 2012年08月06日" target="_blank">Shayla Sturk</a>: Oh and I am not a Liverpool or Chelsea supporter, but the way the Liverpool fans were still singing...</li>
<li><a href="http://coolshell.cn/articles/656.html#comment-610406" title="Linux 的僵尸(zombie)进程, 2009年04月25日" target="_blank">Nevada Riedlinger</a>: good app many thanks for sharing</li>
</ul>
<h3 id="-">友情链接</h3>
<ul>
<li><a href="http://blog.csdn.net/haoel" target="_blank">陈皓的博客</a></li>
<li><a href="http://ifeve.com/" title="促进并发编程的研究和推广" target="_blank">并发编程</a></li>
<li><a href="http://www.raychase.net/" title="一个啰嗦的程序员" target="_blank">四火的唠叨</a></li>
<li><a href="http://www.devtext.com/" title="我们关注互联网、关注软件开发、提供开发技术交流、问答平台" target="_blank">devtext 开发者社区</a></li>
<li><a href="http://claymore.phpme.info/" target="_blank">Claymore&#39;s blog</a></li>
<li><a href="http://www.dutor.net/" target="_blank">Dutor.net</a></li>
<li><a href="http://luy.li/" title="all linux" target="_blank">bones7456</a></li>
<li><a href="http://keeng2008.appspot.com/" title="Keengle&#39;s Blog" target="_blank">Keengle&#39;s Blog</a></li>
<li><a href="http://www.nowamagic.net/" title="专注于互联网主流的各种技术" target="_blank">简明现代魔法</a></li>
<li><a href="http://www.rosoo.net/" title="关注技术更新，关注行业动态。努力做到更好。" target="_blank">罗素工作室</a></li>
<li><a href="http://www.codecho.com/" title="聆听代码的回音" target="_blank">代码回音</a></li>
<li><a href="http://hellogcc.blogbus.com/" title="致力于讨论和学习GNU Toolchain方面的工作组" target="_blank">HelloGcc Working Group</a></li>
<li><a href="http://http://blog.lvscar.info/" title="Just for Fun" target="_blank">吕毅的Blog</a></li>
<li><a href="http://www.cnblogs.com/weidagang2046/" title="Just for Fun" target="_blank">Todd Wei的Blog</a></li>
<li><a href="http://www.cppfans.org/" title="记录我们点滴学习工作生活" target="_blank">C++爱好者博客</a></li>
<li><a href="http://www.mhtml5.com/" title="致力于HTML5在中国的发展与应用" target="_blank">HTML5研究小组</a></li>
<li><a href="http://www.12freeblog.com/" title="关注网站运营，分享技术心得" target="_blank">12Free</a></li>
<li><a href="http://zhuwenhao.com/" title="朱文昊的中文博客－－专注技术，向往自由" target="_blank">朱文昊Albert Zhu</a></li>
<li><a href="http://www.cguage.com/" title="某VC++软件开发爱好者" target="_blank">C瓜哥的博客</a></li>
<li><a href="http://www.kaiyuanba.cn/" title="汇聚各种开源项目的中英文混合介绍并分类排列，致力于软件项目的开源事业" target="_blank">开源吧</a></li>
<li><a href="http://www.stackpop.org/" title="靖难|魔都小码农" target="_blank">靖难|魔都小码农</a></li>
<li><a href="http://acm.zhihua-lai.com/" title="Smart Ideas, Smart Algorithms" target="_blank">ACMer</a></li>
<li><a href="http://chenpeng.info/" title="优秀的开源软件让生活更简单" target="_blank">陈鹏个人博客</a></li>
<li><a href="http://www.coderli.com/" title="一个普通的coder，coding为了生活，coding因为消遣:-) Just a coder" target="_blank">OneCoder</a></li>
<li><a href="http://www.crazyshell.org/blog/" title="专注于底层基础, TCP/IP, 存储, (高性能.高可用.分布式.高并发系统) 研究" target="_blank">狂Shell – Happy Hacking</a></li>
<li><a href="http://blog.tektea.com/" title="关注IT技术 | 分享 | 交流 | 记录" target="_blank">TekTea&#39;s Blog</a></li>
<li><p><a href="http://shellblog.sinaapp.com/" title="我有一颗百度的心。" target="_blank">夕水溪下</a></p>
<h3 id="-">功能</h3>
</li>
<li><p><a href="http://coolshell.cn/wp-login.php?action=register" target="_blank">注册</a></p>
</li>
<li><a href="http://coolshell.cn/wp-login.php" target="_blank">登录</a></li>
<li><a href="http://coolshell.cn/feed" title="使用 RSS 2.0 订阅本站点内容" target="_blank">文章 RSS</a></li>
<li><a href="http://coolshell.cn/comments/feed" title="使用 RSS 订阅本站点的所有文章的近期评论" target="_blank">评论 RSS</a></li>
<li><a href="http://cn.wordpress.org/" title="基于 WordPress，一个优美、先进的个人信息发布平台。" target="_blank">WordPress.org</a></li>
</ul>
<p><a href="http://www.cnzz.com/stat/website.php?web_id=1785679" title="站长统计" target="_blank"><img src="" alt=""></a></p>
<p><a href="">回到顶部</a> <a href="http://wordpress.org/" target="_blank">WordPress</a></p>
<p>版权所有 © 2009-2013 酷壳 – CoolShell.cn
主题由 <a href="http://www.neoease.com/" target="_blank">NeoEase</a> 提供, 通过 <a href="http://validator.w3.org/check?uri=referer" target="_blank">XHTML 1.1</a> 和 <a href="http://jigsaw.w3.org/css-validator/check/referer?profile=css3" target="_blank">CSS 3</a> 验证. <a href="http://www.cnzz.com/stat/website.php?web_id=1785679" title="站长统计" target="_blank"><img src="" alt=""></a></p>
<p><img src="" alt=""></p>
<p>检测到你还在使用百度这个搜索引擎，
做为一个程序员，这是一种自暴自弃！</p>
<p><strong><a href="http://coolshell.cn/articles/7186.html" target="_blank">做环保的程序员，从不用百度开始！</a></strong>
<img src="" alt=""></p>
<p>检测到你还在使用百度这个搜索引擎，
做为一个程序员，这是一种自暴自弃！</p>
<p><strong><a href="http://coolshell.cn/articles/7186.html" target="_blank">做环保的程序员，从不用百度开始！</a></strong></p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/好文摘录/">好文摘录</a></li></span></span> | <span class="time">recent updated:<time title="2014-03-07 11:24:29"datetime="2014-03-07 11:24:29"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/03/2014-02-03--程序算法与人生选择/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-03--程序算法与人生选择" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>





<ul id="pagination" class="pagination pagination-lg">
  <li><a class="extend prev" href="/page/2/">&laquo;</a></li><li><a class="page-number" href="/">1</a></li><li><a class="page-number" href="/page/2/">2</a></li><li><a class="page-number" href="/page/2/">2</a></li><li class="active"><li><span class="page-number current">3</span></li><li><a class="page-number" href="/page/4/">4</a></li><li><a class="page-number" href="/page/5/">5</a></li><li><a class="page-number" href="/page/6/">6</a></li><li><span class="space">&hellip;</span></li></li><li><a class="page-number" href="/page/164/">164</a></li><li><a class="page-number" href="/page/165/">165</a></li><li><a class="extend next" href="/page/4/">&raquo;</a></li>
  <div class="clearfix"></div>
</ul></div><!--wapper-->
       </div><!-- ID main-col END -->
       <aside id="sidebar" class="alignright col-sx-6 col-sm-4 col-md-3 col-lg-3">
<div id="widget_search" class="widget panel panel-primary">
    <form action="//google.com/search" method="get" accept-charset="utf-8">
  <div class="input-group">
    <input class="form-control" id="searchbox" type="search" name="q" results="0" placeholder="search">
    <span class="input-group-btn">
      <button class="btn btn-default" type="submit">Go!</button>
    </span>
    <input type="hidden" name="q" value="site:itsolife.com">
  </div>
</form>
</div>

<div id="widget_category" class="widget panel panel-primary">
  <div class="panel-heading">category</div>  <div data-src='category' class='ajax_widgets'>正在加载...</div>
</div>

<div id="widget_recent_posts" class="widget panel panel-primary">
  <div class="panel-heading">recent posts</div>  <div data-src='recent_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_tagcloud" class="widget panel panel-primary">
  <div class="panel-heading">tagcloud</div>  <div data-src='tagcloud' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_latest_update_posts" class="widget panel panel-primary">
  <div class="panel-heading">最近更新</div>  <div data-src='latest_update_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_recent_comments" class="widget panel panel-primary">
  <div class="panel-heading">recent comments</div>  

<div class="list-group-item ds-recent-comments" data-num-items="6" data-show-avatars="1" data-show-time="1" data-show-title="1" data-show-admin="1" data-excerpt-length="50"></div>



</div>

</aside>
       <div class="clearfix"></div>
     </div><!-- row END -->
  </div>
  <footer id="footer" class="container">
  <div class="panel panel-info">
  <section id='footer_widget'></section>  <div class="panel-footer">
  <div id="site-info">
    <span class='author'>
  
  &copy; 2014 RobinChia
  
    &nbsp;&nbsp;</span>
  
  <span id='analytics-51la'></span><span id='analytics-google'>
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-48559895-1']);
  _gaq.push(['_trackPageview']);
  _js2load.push({src:('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'});
</script></span><span id='analytics-cnzz'>
<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_5774006'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s17.cnzz.com/stat.php%3Fid%3D5774006%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>
</span><span id='analytics-baidu'>
<script>
var _hmt = _hmt || [];
_js2load.push({src:"//hm.baidu.com/hm.js?1442f50724afc42380b51f097c43082c"});
</script>
</span>  </div>
  <div id="copyright">Blog powered by <a href='http://zespia.tw/hexo/'><strong>hexo</strong></a> Theme <strong><a href='https://github.com/chenall/hexo-theme-chenall'>chenall</a></strong>(Some change in it)<span class="pull-right"> 更新时间: <em>2014-03-15 16:33:41</em></span></div>
</div>
<div class="clearfix"></div>


  </div>
  </footer>
  
        <script src="http://cdn.bootcss.com/jquery/1.10.2/jquery.min.js"></script>        
        <script src="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/js/bootstrap.min.js"></script>        
                
        <script src="http://cdn.bootcss.com/prettify/r298/prettify.min.js"></script>    <script type="text/javascript">
   var lang=["bsh", "c", "cc", "cpp", "cs", "csh", "cyc", "cv", "htm", "html",
    "java", "js", "m", "mxml", "perl", "pl", "pm", "py", "rb", "sh",
    "xhtml", "xml", "xsl"];
   var pretty_base='';
   $('script').each(function(){
	var c = $(this).attr('src');
	if (!c)
	    return;
	if (c.match(/(\/)?prettify(\.min)?\.js/i))
	{
	    var index = c.lastIndexOf('/');
	    if (index != -1)
		pretty_base = c.substr(0,index + 1);
	    return false;
	}
   })
   $('pre code').each(function(){
	var c = $(this).attr('class')
	if (!c)
	    return;
	c = c.match(/\s?(lang\-\w+)/i);
	if (c && lang.indexOf(c[1]) == -1)
	{
	    lang.push(c[1]);
	    $.getScript(pretty_base + c[1] + '.min.js');
	}
   })

    $(window).load(function(){
       $("pre").addClass("prettyprint");
       prettyPrint();
    })
</script>    
            <script type="text/javascript">
var duoshuoQuery = {short_name:"robinchia"};
_js2load.push({src:'http://static.duoshuo.com/embed.js',charset:'UTF-8'});
</script>
    
            <!--wumii_relatedItems-->
    
        <script src="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js"></script>    <script type="text/javascript">
(function($){
  $('.entry').each(function(i){
    $(this).find('img').each(function(){
      var alt = this.alt;

      if (alt){
        $(this).before('<span class="caption">' + alt + '</span>');
      }

      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox" rel="fancybox' + i + '" />');
    });
  });

  $('.fancybox').fancybox();
})(jQuery);
</script>    
        <script src="http://cdn.bootcss.com/mathjax/2.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>    <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>
    
<script type="text/javascript">
$('.ajax_widgets').each(function(){var src=$(this).attr('data-src');if(src)$(this).load('/widgets/'+src+'.html');});
$.each(_js2load,function(index,obj){loadjs(obj.src,obj.charset)});
</script>

<div id="scroll2top">
<img src="/scroll2top/arrow.png"/>
</div>
<script src="/scroll2top/scroll2top.min.js"></script>
<div id="winterland">
  <canvas></canvas>
</div>
<script src="/js/winterland.min.js"></script>

  </body>
</html>
