
<!DOCTYPE HTML>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>The 7 Page | It so life</title>
<meta name="author" content="RobinChia">

<meta name="description" content="It so life">


<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<meta property="og:site_name" content="It so life"/>

<!--[if IE]><style>.testIE.IE{display:inline;}</style><![endif]-->
<!--[if lte IE 7]><link rel="stylesheet" href="/css/ie7.css" type="text/css"><![endif]-->
<!--[if (lt IE 9)&(gt IE 7)]><style>.testIE.IE8{display:inline;}</style><![endif]-->
<!--[if gt IE 8]><style>.testIE.IE9{display:inline;}</style><![endif]-->

<link href="/favicon.png" rel="icon">
<link rel="alternate" href="/atom.xml" title="It so life Feed" type="application/atom+xml">

<link rel="stylesheet" href="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/css/bootstrap.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/font-awesome/4.0.3/css/font-awesome.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/prettify/r298/prettify.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" type="text/css">
<link rel="stylesheet" href="/css/style.css" type="text/css">
<!--[if lt IE 9]>
   <style>article,aside,dialog,footer,header,section,footer,nav,figure,menu{display:block}</style>
   <script src="http://cdn.staticfile.org/html5shiv/r29/html5.min.js"></script>
   <script src="http://cdn.staticfile.org/respond.js/1.4.2/respond.min.js"></script>
<link href="http://cdn.staticfile.org/respond.js/1.4.2/respond-proxy.html" id="respond-proxy" rel="respond-proxy" />
<link href="/js/respond.proxy.gif" id="respond-redirect" rel="respond-redirect" />
<script src="/js/respond.proxy.js"></script>
   <script src="http://cdn.bootcss.com/selectivizr/1.0.2/selectivizr-min.js"></script>
<![endif]-->
<script type="text/javascript">
function loadjs(c,d){var a=document.createElement("script");a.async=!0;a.type="text/javascript";a.src=c;a.charset=d||"gbk";(document.getElementsByTagName("HEAD")[0]||document.getElementsByTagName("BODY")[0]).appendChild(a)};
var _protocol = (("https:" == document.location.protocol) ? " https://" : " http://");
var _js2load = [];
</script>

</head>
<body>
      <header id="header" class="container"><nav id="main-nav" class="navbar navbar-default navbar-fixed-top " role="navigation">
  <div class="container">
    <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
      <span class="sr-only">Toggle navigation</span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="/">It so life</a>
    </div>
    <div  class="collapse navbar-collapse">
      <ul  class="nav navbar-nav">
  
        <li><a href="/" title="Home">Home</a></li>      
        <li><a href="/about/" title="About">About</a></li>      
        <li><a href="/archives/" title="Archives">Archives</a></li>      
      <li class='dropdown'>
        <a class='dropdown-toggle' data-toggle='dropdown' href='#'>website<b class='caret'></b></a>
        <ul class='dropdown-menu pure-menu-selected'>
    
          <li><a href="//groups.google.com/forum/#!forum/pongba" title="TopLanguage">TopLanguage</a></li>    
          <li><a href="//itpub.net/" title="ITPub">ITPub</a></li>    
          <li><a href="//blog.jobbole.com/" title="Bole">Bole</a></li>    
          <li><a href="//nosql-database.org/" title="nosql">nosql</a></li>    
          <li><a href="//gitimmersion.googol.im/" title="Git">Git</a></li>    
        </ul>
      </li>
    
      </ul>
      <ul class="nav navbar-nav navbar-right">
      
        <li><a href="/atom.xml">RSS</a></li>
      
      
        <li><a href="https://twitter.com/robinchia">twitter</a></li>
      
      
      
      
        <li><a href="https://github.com/robinchia">github</a></li>
      
      </ul>
    </div>
  </div>
</nav>
<div class="clearfix"></div>
</header>
  <div id='content' class="container">
     <div class="page-header-wrapper">
      <!--[if lt IE 9]><div class="alert alert-warning alert-dismissable"><button type="button" class="close" data-dismiss="alert" aria-hidden="true">&times;</button><strong>提示:</strong>您的浏览器版本太低了,建议升级到 <strong><a href="http://windows.microsoft.com/zh-cn/internet-explorer/download-ie" title="IE9">IE9</a></strong> 以上,本站使用<a href="https://www.google.com/intl/zh-CN/chrome/">Chrome浏览器</a>可以获得最好的显示效果.</div><![endif]-->
      <div class="page-header"><h1 align="center"><big>It so life</big> </h1>
        <h5 align="center"><big>love as life</big></h5>
      </div>
     </div>
     <div class="row">
       <div id="main-col" class="alignleft col-sx-12 col-sm-8 col-md-9 col-lg-9">
      <section id='header_widget'></section>
          <div id="wrapper"><article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-webservice-CXF--ApacheCXF/">Apache CXF</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:45.000Z"> <a href="/2014/02/02/2014-02-02-webservice-CXF--ApacheCXF/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="apache-cxf">Apache CXF</h1>
<p>CXF是基于JAX-WS实现的，JAX-WS规范是一组XML web services的JAVA API，它使用户无需编写复杂的SOAP ENV,WSDL。在 JAX-WS中，一个远程调用可以转换为一个基于XML的协议例如SOAP。在使用JAX-WS过程中，开发者不需要编写任何生成和处理SOAP消息的代码。JAX-WS的运行时实现会将这些API的调用转换成为对于SOAP消息。</p>
<p>在服务器端，用户只需要通过Java语言定义远程调用所需要实现的接口SEI (service endpoint interface)，并提供相关的实现，通过调用JAX-WS的服务发布接口就可以将其发布为WebService接口。 
在客户端，用户可以通过JAX-WS的API创建一个代理（用本地对象来替代远程的服务）来实现对于远程服务器端的调用。
来源： <a href="[http://blog.csdn.net/chjttony/article/details/6196289](http://blog.csdn.net/chjttony/article/details/6196289)">[http://blog.csdn.net/chjttony/article/details/6196289](http://blog.csdn.net/chjttony/article/details/6196289)</a> </p>
<p>一、与Axis2的不同之处
1、Apache CXF 支持 WS-Addressing、WS-Policy、WS-RM、WS-Security和WS-I BasicProfile 
2、Axis2 支持 WS-Addressing、WS-RM、WS-Security和WS-I BasicProfile，WS-Policy将在新版本里得到支持 
3、Apache CXF 是根据Spring哲学来进行编写的，即可以无缝地与Spring进行整合 
4、Axis2 不是 
5、Axis2 支持更多的 data bindings，包括 XMLBeans、JiBX、JaxMe 和 JaxBRI，以及它原生的 data binding（ADB）。 
6、Apache CXF 目前仅支持 JAXB 和 Aegis，并且默认是 JAXB 2.0，与 XFire 默认是支持 Aegis 不同，XMLBeans、JiBX 和 Castor 将在 CXF 2.1 版本中得到支持，目前版本是 2.0.2 
7、Axis2 支持多种语言，它有 C/C++ 版本。 
8、Apache CXF 提供方便的Spring整合方法，可以通过注解、Spring标签式配置来暴露Web Services和消费Web Services</p>
<p>二、A simple JAX-WS service
原文见<a href="http://cwiki.apache.org/CXF20DOC/a-simple-jax-ws-service.html" target="_blank"><a href="http://cwiki.apache.org/CXF20DOC/a-simple-jax-ws-service.html">http://cwiki.apache.org/CXF20DOC/a-simple-jax-ws-service.html</a></a></p>
<p> 来源： <a href="http://www.iteye.com/topic/143877" target="_blank"><a href="http://www.iteye.com/topic/143877">http://www.iteye.com/topic/143877</a></a>
CXF旨在为服务创建必要的基础设施，它的整体架构主要由以下几个部分组成：</p>
<p>1.Bus</p>
<p>它是C X F架构的主干，为共享资源提供了一个可配置的场所，作用非常类似于S p r i n g的ApplicationContext。这些共享资源包括WSDL管理器、绑定工厂等。通过对Bus进行扩展，可以方便地容纳自己的资源，或替换现有的资源。默认Bus实现是基于Spring的，通过依赖注入，将运行时组件串起来。Bus的创建由BusFactory负责，默认是 SpringBusFactory，对应于默认Bus实现。在构造过程中，SpringBusFactory会搜索META-INF/cxf（就包含在 CXF的Jar中）下的所有Bean配置文件，根据它们构建一个ApplicationContext。开发者也可提供自己的配置文件来定制Bus。</p>
<p>2.消息传递和拦截器（Interceptor）</p>
<p>CXF建立于一个通用的消息层之上，主要由消息、拦截器和拦截器链（InterceptorChain）组成。CXF是以消息处理为中心的，熟悉 JSP/Servlet的开发者可以将拦截器视为CXF架构中的“Filter”，拦截器链也与“FilterChain”类似。通过拦截器，开发者可以方便地在消息传递、处理的整个过程中对CXF进行扩展。拦截器的方法主要有两个：handleMessage和handleFault，分别对应消息处理和错误处理。在开发拦截器的时候需要注意两点：</p>
<p>拦截器不是线程安全的，不建议在拦截器中定义实例变量并使用它。这一点跟JSP/Servlet中对于Filter的处理是一样的；</p>
<p>不要调用下一个拦截器的handleMessage或handleFault，这个工作由InterceptorChain来完成。</p>
<p>3.前端（Front End）</p>
<p>它为CXF提供了创建服务的编程模型，当前主要的前端就是JAX-WS。</p>
<p>4.服务模型</p>
<p>CXF中的服务通过服务模型来表示。它主要有两部分：ServiceInfo和服务本身。ServiceInfo作用类似WSDL，包含接口信息、绑定、端点（EndPoint）等信息；服务则包含了ServiceInfo、数据绑定、拦截器和服务属性等信息。可使用Java类和WSDL来创建服务。一般是由前端负责服务的创建，它通过ServiceFactory来完成。</p>
<p>5.绑定（Binding）</p>
<p>绑定提供了在传输之上映射具体格式和协议的方法，主要的两个类是Binding和BindingFactory。BindingFactory负责创建Binding。</p>
<p>6.传输（Transport）</p>
<p>为了向绑定和前端屏蔽传输细节，CXF提供了自己的传输抽象。其中主要有两个对象：Conduit和Destination。前者是消息发送的基础，后者则对应消息接收。开发者还可以给Conduit和Destination注册MessageObserver，以便在消息发送和接收时获得通知。</p>
<p><strong>开发方法</strong></p>
<p>CXF 可以创建的Web 服务应用有两种：服务提供者和服务消费者。这种结构可类比客户端/ 服务器结构，服务消费者类似于客户端，服务提供者类似于服务器。使用CXF 创建应用时，服务提供者和服务消费者并不需要同时出现，因为有可能应用只是作为服务提供者或服务消费者单独出现。
来源： <a href="[http://blog.csdn.net/jacklee_6297/article/details/5888232](http://blog.csdn.net/jacklee_6297/article/details/5888232)">[http://blog.csdn.net/jacklee_6297/article/details/5888232](http://blog.csdn.net/jacklee_6297/article/details/5888232)</a><strong> 开发Webservice工程步骤：</strong></p>
<p>2.使用CXF开发Webservice工程步骤： </p>
<p>1).为CXF设置编译和开发环境 
在<a href="http://cxf.apache.org/download.html" target="_blank">http://cxf.apache.org/download.html</a> 下载相应的CXF包，/lib目录下的jar 文件引入工程 
2).创建基于XCF的Webservice服务端工程。
3).编写Webservice的客户端程序，调用服务端服务。</p>
<p>3.CXF中的Factory：</p>
<p>CXF不但可以使用JAX-WS开发web服务，也可以将POJO发布为web服务，对于这两种不同的方式，对应的factory如下：</p>
<pre><code>                             服务端                               客户端  
</code></pre><p>JAX-WS                      JaxWsServerFactoryBean             JaxWsProxyFactoryBean</p>
<p>POJO                           ServiceFactoryBean                     ClientProxyFactoryBean</p>
<p>4.CXF使用JAX-WS开发服务端：</p>
<p>(1).定义服务接口：</p>
<p>在接口上添加Webservice注解：@WebService。如：</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/chjttony/article/details/6196289#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/chjttony/article/details/6196289#" title="copy" target="_blank">copy</a></p>
<ol>
<li>package service;  </li>
<li>import javax.jws.WebService;  </li>
<li>@WebService  </li>
<li>public interface OrderProcess {  </li>
<li>String processOrder(Order order);  </li>
<li>}  </li>
</ol>
<p>(2).实现服务接口：</p>
<p>在实现类上也添加Webservice注解：@WebService(endpointInterface = 服务接口全路径,   serviceName = 对外发布的服务名)。如：</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/chjttony/article/details/6196289#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/chjttony/article/details/6196289#" title="copy" target="_blank">copy</a></p>
<ol>
<li>package service;  </li>
<li>import javax.jws.WebService;  </li>
<li>@WebService(endpointInterface = &quot;service.OrderProcess&quot;，serviceName=”order”)  </li>
<li>public class OrderProcessImpl implements OrderProcess {  </li>
<li>public String processOrder(Order order) {  </li>
<li>return &quot;hello world&quot;+order;  </li>
<li>}  </li>
<li>}  </li>
</ol>
<p>(3).对外发布服务：</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/chjttony/article/details/6196289#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/chjttony/article/details/6196289#" title="copy" target="_blank">copy</a></p>
<ol>
<li>//创建web服务工厂  </li>
<li>JaxWsServerFactoryBean factory = new JaxWsServerFactoryBean();  </li>
<li>//设置服务类  </li>
<li>factory.setServiceClass(服务接口实现类.class);  </li>
<li>//设置对外发布服务地址  </li>
<li>factory.setAddress(对外发布的服务地址);  </li>
<li>//创建服务  </li>
<li>Server server = factory.create();  </li>
<li>//启动服务  </li>
<li>server.start();  </li>
</ol>
<p>5.CXF使用JAX-WS开发客户端：</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/chjttony/article/details/6196289#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/chjttony/article/details/6196289#" title="copy" target="_blank">copy</a></p>
<ol>
<li>//创建web服务代理工厂  </li>
<li>JaxWsProxyFactoryBean factory = new JaxWsProxyFactoryBean();  </li>
<li>//设置要调用的web服务服务端发布地址  </li>
<li>factory.setAddress(web服务的发布地址);  </li>
<li>//设置要调用的web服务  </li>
<li>factory.setServiceClass(web服务接口.class);  </li>
<li>//创建web服务对象  </li>
<li>服务接口 对象 = (服务接口) factory.create();  </li>
<li>通过对象调用web服务的方法  </li>
<li>6.CXF使用POJO开发服务端：  </li>
<li>和使用JAX-WS开发方式前两步完全一样，第三步稍有不同如下：  </li>
<li>//创建web服务工厂  </li>
<li>ServiceFactoryBean svrFactory = new ServiceFactoryBean();  </li>
<li>//设置服务类  </li>
<li>svrFactory.setServiceClass(服务接口实现类.class);  </li>
<li>//设置对外发布服务地址  </li>
<li>svrFactory.setAddress(对外发布的服务地址);  </li>
<li>//创建服务  </li>
<li>Server server = svrFactory.create();  </li>
<li>//启动服务  </li>
<li>server.start();  </li>
</ol>
<p>6.CXF使用POJO开发客户端：</p>
<p>和JAX-WS方式除了代理工厂不同以外，其他均相同：</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/chjttony/article/details/6196289#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/chjttony/article/details/6196289#" title="copy" target="_blank">copy</a></p>
<ol>
<li>//创建web服务代理工厂  </li>
<li>ClientProxyFactoryBean factory = new ClientProxyFactoryBean();  </li>
<li>//设置要调用的web服务服务端发布地址  </li>
<li>factory.setAddress(web服务的发布地址);  </li>
<li>//设置要调用的web服务  </li>
<li>factory.setServiceClass(web服务接口.class);  </li>
<li>//创建web服务对象  </li>
<li>服务接口 对象 = (服务接口) factory.create();  </li>
</ol>
<p>通过对象调用web服务的方法</p>
<p>7.CXF与Spring的集成：</p>
<p>(1).对工程引入spring支持。</p>
<p>(2).在web.xml文件中添加spring和CXF相应的配置如下：</p>
<p><strong>[xhtml]</strong> <a href="http://blog.csdn.net/chjttony/article/details/6196289#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/chjttony/article/details/6196289#" title="copy" target="_blank">copy</a></p>
<ol>
<li><web-app>  </li>
<li><context-param>  </li>
<li><param-name>contextConfigLocation</param-name>  </li>
<li><param-value>spring配置文件路径</param-value>  </li>
<li></context-param>  </li>
<li><listener>  </li>
<li><listener-class>  </li>
<li>org.springframework.web.context.ContextLoaderListener  </li>
<li></listener-class>  </li>
<li></listener>  </li>
<li><servlet>  </li>
<li><servlet-name>CXFServlet</servlet-name>  </li>
<li><display-name>CXF Servlet</display-name>  </li>
<li><servlet-class>  </li>
<li>org.apache.cxf.transport.servlet.CXFServlet  </li>
<li></servlet-class>  </li>
<li><load-on-startup>1</load-on-startup>  </li>
<li></servlet>  </li>
<li><servlet-mapping>  </li>
<li><servlet-name>CXFServlet</servlet-name>  </li>
<li><url-pattern>/service//*</url-pattern>  </li>
<li></servlet-mapping>  </li>
<li></web-app>  </li>
</ol>
<p>(3).在spring配置文件中导入CXF的相关配置如下：</p>
<p><strong>[xhtml]</strong> <a href="http://blog.csdn.net/chjttony/article/details/6196289#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/chjttony/article/details/6196289#" title="copy" target="_blank">copy</a></p>
<ol>
<li><import resource="classpath:META-INF/cxf/cxf.xml" />  </li>
<li><import resource="classpath:META-INF/cxf/cxf-extension-soap.xml" />  </li>
<li><import resource="classpath:META-INF/cxf/cxf-servlet.xml" />  



</li>
</ol>
<p>(4).在spring配置文件中配置要发布的web服务如下：</p>
<p><strong>[xhtml]</strong> <a href="http://blog.csdn.net/chjttony/article/details/6196289#" title="view plain" target="_blank">view plain</a><a href="http://blog.csdn.net/chjttony/article/details/6196289#" title="copy" target="_blank">copy</a></p>
<ol>
<li>&lt;jaxws:endpoint  </li>
<li>id=&quot;……&quot;  </li>
<li>implementor=&quot;服务接口实现类全路径&quot;  </li>
<li><p>address=&quot;/web服务发布地址(相对地址)&quot; /&gt;  </p>
<p>来源：<a href="http://blog.csdn.net/chjttony/article/details/6196289" target="_blank"><a href="http://blog.csdn.net/chjttony/article/details/6196289">http://blog.csdn.net/chjttony/article/details/6196289</a></a></p>
</li>
</ol>
<p><strong>拦截器方式的使用实例：</strong></p>
<p>基于CXF2.0前2个学习笔记，对原先服务端与客户端进行修改，实现在SOAP Header里面添加自定义的数据进行认证
在做之前，先要理解如下的信息
<strong>拦截器(Interceptor)简单说明</strong>
      Interceptor是CXF架构中一个很有特色的模式。你可以在不对核心模块进行修改的情况下，动态添加很多功能。这对于CXF这个以处理消息为中心的服务框架来说是非常有用的，CXF通过在Interceptor中对消息进行特殊处理，实现了很多重要功能模块，例如：日志记录，Soap消息处理，消息的压缩处。简单的说，可以在收到请求后，还未进行业务处理前，进行处理。或者在请求包发送前，进行报文的处理。
<strong>几个的API的介绍</strong>
<strong>Interceptor</strong></p>
<p>定义两个方法，一个处理消息 handleMessage， 一个是处理错误 handleFault。</p>
<p><strong>InterceptorChain
</strong>  单个的Interceptor功能有限，CXF要实现一个SOAP消息处理，需要将许许多多的Interceptor组合在一起使用。因此设计了 InterceptorChain，在我看了InterceptorChain就像是一个Interceptor的小队长。 小队长有调配安置Interceptor的权力（add，remove），也有控制消息处理的权力（doInterceptor，pause，resume，reset，abort），同时也有交付错误处理的权力（ {get|set}FaultObserver）。更有意思的是为灵活控制Interceptor的处理消息顺序（doInterceptStartingAt，doInterceptorStartingAfter），这也是InterceptorChain比较难理解的地方。
<strong>Fault</strong>
  定义了CXF中的错误消息。
<strong>InterceptorProvider</strong>
这里定义了Interceptor的后备保障部队。我们可以在InterceptorProvider中设置In，Out，InFault，OutFault 后备小分队，添加我们所希望添加的Interceptor。而InterceptorChain会根据这些后备小分队，组建自己的小分队实例，完成具体的作战功能任务。
<strong>AbstractAttributedInterceptorProvider</strong>
   InterceptorProvider实现的抽象类，由于这个类来继承了HashMap，我们可以像这个类中存储一些属性信息。
<strong>AbstractBasicInterceptorProvider</strong>
   与AbstractAttributedInterceptorProvider不同，这个Interceptor只是简单实现了InterceptorProvider的功能，并不提供对其属性存储的扩展。
<strong>Message</strong>
   由于Interceptor是针对Message来进行处理的，当你打开Message这个类文件时，你会发现在Message中定义了很多常量，同时你还可以从Message中获取到很多与Message操作相关的信息。可以获取设置的对象有InterceptorChain Exchange Destination，还有获取设置Content的泛型接口，是不是感觉Message和Bus差不多，都成了大杂货铺，一切与消息处理相关的信息都可以放在Message中。</p>
<p>理解了Interceptor功能，下面的修改就很简单了</p>
<p><strong>服务端修改</strong>
1.新建一个拦截器(Interceptor)
<img src="" alt="">package hs.cxf.soapHeader;
<img src="" alt="">
<img src="" alt="">import javax.xml.soap.SOAPException;
<img src="" alt="">import javax.xml.soap.SOAPHeader;
<img src="" alt="">import javax.xml.soap.SOAPMessage;
<img src="" alt="">import org.apache.cxf.binding.soap.SoapMessage;
<img src="" alt="">import org.apache.cxf.binding.soap.saaj.SAAJInInterceptor;
<img src="" alt="">import org.apache.cxf.interceptor.Fault;
<img src="" alt="">import org.apache.cxf.phase.AbstractPhaseInterceptor;
<img src="" alt="">import org.apache.cxf.phase.Phase;
<img src="" alt="">import org.w3c.dom.NodeList;
<img src="" alt="">
<img src="" alt="">//<em>/</em>
<img src="" alt=""> /<em> 
<img src="" alt=""> /</em> @Title:获取soap头信息
<img src="" alt=""> /<em> 
<img src="" alt=""> /</em> @Description:
<img src="" alt=""> /<em> 
<img src="" alt=""> /</em> @Copyright:
<img src="" alt=""> /<em> 
<img src="" alt=""> /</em> @author zz
<img src="" alt=""> /<em> @version 1.00.000
<img src="" alt=""> /</em> 
<img src="" alt=""> /<em>/
<img src="" alt="">public class ReadSoapHeader extends AbstractPhaseInterceptor<SoapMessage> {
<img src="" alt="">
<img src="" alt="">    private SAAJInInterceptor saa = new SAAJInInterceptor();
<img src="" alt="">
<img src="" alt="">    public ReadSoapHeader() {
<img src="" alt="">        super(Phase.PRE_PROTOCOL);
<img src="" alt="">        getAfter().add(SAAJInInterceptor.class.getName());
<img src="" alt="">    }
<img src="" alt="">
<img src="" alt="">    public void handleMessage(SoapMessage message) throws Fault {
<img src="" alt="">
<img src="" alt="">        SOAPMessage mess = message.getContent(SOAPMessage.class);
<img src="" alt="">        if (mess == null) {
<img src="" alt="">            saa.handleMessage(message);
<img src="" alt="">            mess = message.getContent(SOAPMessage.class);
<img src="" alt="">        }
<img src="" alt="">        SOAPHeader head = null;
<img src="" alt="">        try {
<img src="" alt="">            head = mess.getSOAPHeader();
<img src="" alt="">        } catch (SOAPException e) {
<img src="" alt="">            e.printStackTrace();
<img src="" alt="">        }
<img src="" alt="">        if (head == null) {
<img src="" alt="">            return;
<img src="" alt="">        }
<img src="" alt="">        try {
<img src="" alt="">            //读取自定义的节点
<img src="" alt="">            NodeList nodes = head.getElementsByTagName(&quot;tns:spId&quot;);
<img src="" alt="">            NodeList nodepass = head.getElementsByTagName(&quot;tns:spPassword&quot;);
<img src="" alt="">            //获取节点值，简单认证
<img src="" alt="">            if (nodes.item(0).getTextContent().equals(&quot;wdw&quot;)) {
<img src="" alt="">                if (nodepass.item(0).getTextContent().equals(&quot;wdwsb&quot;)) {
<img src="" alt="">                    System.out.println(&quot;认证成功&quot;);
<img src="" alt="">                }
<img src="" alt="">            } else {
<img src="" alt="">                SOAPException soapExc = new SOAPException(&quot;认证错误&quot;);
<img src="" alt="">                throw new Fault(soapExc);
<img src="" alt="">            }
<img src="" alt="">
<img src="" alt="">        } catch (Exception e) {
<img src="" alt="">            SOAPException soapExc = new SOAPException(&quot;认证错误&quot;);
<img src="" alt="">            throw new Fault(soapExc);
<img src="" alt="">        }
<img src="" alt="">    }
<img src="" alt="">
<img src="" alt="">}
2.配置文件中新增拦截器配置
<img src="" alt=""><beans xmlns="http://www.springframework.org/schema/beans"  
![]()    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
![]()    xmlns:jaxws="http://cxf.apache.org/jaxws"  
![]()    xsi:schemaLocation="   
![]()http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd   
![]()http://cxf.apache.org/jaxws http://cxf.apache.org/schemas/jaxws.xsd"><br><img src="" alt=""><br><img src="" alt="">    <import resource="classpath:META-INF/cxf/cxf.xml" /><br><img src="" alt="">    <import resource="classpath:META-INF/cxf/cxf-extension-soap.xml" /><br><img src="" alt="">    <import resource="classpath:META-INF/cxf/cxf-servlet.xml" /><br><img src="" alt=""><br><img src="" alt="">    <bean id="jaxWsServiceFactoryBean"  
![]()        class="org.apache.cxf.jaxws.support.JaxWsServiceFactoryBean"><br><img src="" alt="">        <property name="wrapped" value="true" /><br><img src="" alt="">        <property name="dataBinding" ref="aegisBean" /><br><img src="" alt="">    </bean><br><img src="" alt=""><br><img src="" alt="">    <bean id="aegisBean"  
![]()        class="org.apache.cxf.aegis.databinding.AegisDatabinding" /><br><img src="" alt=""><br><img src="" alt="">    <jaxws:endpoint id="CollectiveServices"  
![]()        implementor="hs.cxf.server.WebServiceSampleImpl" address="/HelloWorld"><br><img src="" alt="">        <jaxws:inInterceptors><br><img src="" alt="">          <!-- 日志拦截器 --><br><img src="" alt="">          <bean class="org.apache.cxf.interceptor.LoggingOutInterceptor"/><br><img src="" alt="">          <!-- 自定义拦截器 --> 
<img src="" alt="">          <bean class="hs.cxf.soapHeader.ReadSoapHeader"/><br><img src="" alt="">          </jaxws:inInterceptors><br><img src="" alt="">        <jaxws:serviceFactory><br><img src="" alt="">            <ref bean="jaxWsServiceFactoryBean"/><br><img src="" alt="">        </jaxws:serviceFactory><br><img src="" alt="">    </jaxws:endpoint><br><img src="" alt=""></beans><br><img src="" alt="">
服务端的配置就告一段落了，接下来是客户端的修改
<strong>客户端
</strong>1.同样新增一个Interceptor
<img src="" alt="">package hs.cxf.client.SoapHeader;
<img src="" alt="">
<img src="" alt="">
<img src="" alt="">import java.util.List;
<img src="" alt="">import javax.xml.namespace.QName;
<img src="" alt="">import org.apache.cxf.binding.soap.SoapHeader;
<img src="" alt="">import org.apache.cxf.binding.soap.SoapMessage;
<img src="" alt="">import org.apache.cxf.binding.soap.interceptor.AbstractSoapInterceptor;
<img src="" alt="">import org.apache.cxf.headers.Header;
<img src="" alt="">import org.apache.cxf.helpers.DOMUtils;
<img src="" alt="">import org.apache.cxf.interceptor.Fault;
<img src="" alt="">import org.apache.cxf.phase.Phase;
<img src="" alt="">import org.w3c.dom.Document;
<img src="" alt="">import org.w3c.dom.Element;
<img src="" alt="">//</em>/<em>
<img src="" alt=""> /</em> 
<img src="" alt=""> /<em> @Title:在发送消息前，封装Soap Header 信息
<img src="" alt=""> /</em> 
<img src="" alt=""> /<em> @Description:
<img src="" alt=""> /</em> 
<img src="" alt=""> /<em> @Copyright: 
<img src="" alt=""> /</em>
<img src="" alt=""> /<em> @author zz
<img src="" alt=""> /</em> @version 1.00.000
<img src="" alt=""> /<em>
<img src="" alt=""> /</em>/
<img src="" alt="">
<img src="" alt="">public class AddSoapHeader extends AbstractSoapInterceptor {
<img src="" alt="">      private static String nameURI=&quot;<a href="http://127.0.0.1:8080/cxfTest/ws/HelloWorld" target="_blank">http://127.0.0.1:8080/cxfTest/ws/HelloWorld</a>&quot;;<br><img src="" alt=""><br><img src="" alt="">        public AddSoapHeader(){<br><img src="" alt="">            super(Phase.WRITE);<br><img src="" alt="">        }<br><img src="" alt=""><br><img src="" alt="">        public void handleMessage(SoapMessage message) throws Fault {<br><img src="" alt="">            String spPassword=&quot;wdwsb&quot;;<br><img src="" alt="">            String spName=&quot;wdw&quot;;<br><img src="" alt=""><br><img src="" alt="">            QName qname=new QName(&quot;RequestSOAPHeader&quot;);<br><img src="" alt="">            Document doc=DOMUtils.createDocument();<br><img src="" alt="">            //自定义节点
<img src="" alt="">            Element spId=doc.createElement(&quot;tns:spId&quot;);<br><img src="" alt="">            spId.setTextContent(spName);<br><img src="" alt="">            //自定义节点
<img src="" alt="">            Element spPass=doc.createElement(&quot;tns:spPassword&quot;);<br><img src="" alt="">            spPass.setTextContent(spPassword);<br><img src="" alt=""><br><img src="" alt="">            Element root=doc.createElementNS(nameURI, &quot;tns:RequestSOAPHeader&quot;);<br><img src="" alt="">            root.appendChild(spId);<br><img src="" alt="">            root.appendChild(spPass);<br><img src="" alt=""><br><img src="" alt="">            SoapHeader head=new SoapHeader(qname,root);<br><img src="" alt="">            List<Header> headers=message.getHeaders();<br><img src="" alt="">            headers.add(head);<br><img src="" alt="">            System.out.println(&quot;&gt;&gt;&gt;&gt;&gt;添加header&lt;&lt;&lt;&lt;&lt;&lt;&lt;&quot;);
<img src="" alt="">        }<br><img src="" alt="">
<img src="" alt="">}
<img src="" alt="">
2.客户端调用程序修改
<img src="" alt="">package hs.cxf.client;
<img src="" alt="">
<img src="" alt="">import hs.cxf.client.SoapHeader.AddSoapHeader;
<img src="" alt="">import java.util.ArrayList;
<img src="" alt="">import javax.xml.bind.JAXBElement;
<img src="" alt="">import javax.xml.namespace.QName;
<img src="" alt="">import org.apache.cxf.endpoint.Client;
<img src="" alt="">import org.apache.cxf.frontend.ClientProxy;
<img src="" alt="">import org.apache.cxf.interceptor.Interceptor;
<img src="" alt="">import org.apache.cxf.jaxws.JaxWsProxyFactoryBean;
<img src="" alt="">import org.apache.cxf.transport.http.HTTPConduit;
<img src="" alt="">import org.apache.cxf.transports.http.configuration.HTTPClientPolicy;
<img src="" alt="">
<img src="" alt="">//<em>/</em>
<img src="" alt=""> /<em> @Title:
<img src="" alt=""> /</em> 
<img src="" alt=""> /<em> @Description:
<img src="" alt=""> /</em> 
<img src="" alt=""> /<em> @Copyright: 
<img src="" alt=""> /</em> 
<img src="" alt=""> /<em> @author zz
<img src="" alt=""> /</em> @version 1.00.000
<img src="" alt=""> /<em> 
<img src="" alt=""> /</em>/
<img src="" alt="">public class TestClient {
<img src="" alt="">
<img src="" alt="">    //<em>/</em>
<img src="" alt="">     /<em> 测试1
<img src="" alt="">     /</em>/
<img src="" alt="">    @SuppressWarnings(&quot;unchecked&quot;)
<img src="" alt="">    public void testSend1() {
<img src="" alt="">        try {
<img src="" alt="">            JaxWsProxyFactoryBean factory = new JaxWsProxyFactoryBean();
<img src="" alt="">
<img src="" alt="">            ArrayList<Interceptor> list = new ArrayList<Interceptor>();
<img src="" alt="">            // 添加soap header 
<img src="" alt="">            list.add(new AddSoapHeader());
<img src="" alt="">            // 添加soap消息日志打印
<img src="" alt="">            list.add(new org.apache.cxf.interceptor.LoggingOutInterceptor());
<img src="" alt="">            factory.setOutInterceptors(list);
<img src="" alt="">            factory.setServiceClass(WebServiceSample.class);
<img src="" alt="">            factory.setAddress(&quot;<a href="http://127.0.0.1:8080/cxfTest/ws/HelloWorld" target="_blank">http://127.0.0.1:8080/cxfTest/ws/HelloWorld</a>&quot;);
<img src="" alt="">
<img src="" alt="">            Object obj = factory.create();
<img src="" alt="">            System.out.println(obj == null ? &quot;NULL&quot; : obj.getClass().getName());
<img src="" alt="">            if (obj != null) {
<img src="" alt="">                WebServiceSample ws = (WebServiceSample) obj;
<img src="" alt="">                String str = ws.say(&quot;test&quot;);
<img src="" alt="">                System.out.println(str);
<img src="" alt="">
<img src="" alt="">                str = ws.say(&quot;1111&quot;);
<img src="" alt="">                System.out.println(str);
<img src="" alt="">
<img src="" alt="">                User u = new User();
<img src="" alt="">                JAXBElement<String> je = new JAXBElement<String>(new QName(
<img src="" alt="">                        &quot;<a href="http://bean.cxf.hs" target="_blank">http://bean.cxf.hs</a>&quot;, &quot;name&quot;), String.class, &quot;张三&quot;);
<img src="" alt="">                u.setName(je);
<img src="" alt="">                str = ws.sayUserName(u);
<img src="" alt="">                System.out.println(str);
<img src="" alt="">
<img src="" alt="">                // 通过对象来交互
<img src="" alt="">                ReqBean req = new ReqBean();
<img src="" alt="">                req.setExp(new JAXBElement<String>(new QName(
<img src="" alt="">                        &quot;<a href="http://bean.cxf.hs" target="_blank">http://bean.cxf.hs</a>&quot;, &quot;exp&quot;), String.class,
<img src="" alt="">                        &quot;<exp>111<exp>&quot;));
<img src="" alt="">                req.setSeqId(new JAXBElement<String>(new QName(
<img src="" alt="">                        &quot;<a href="http://bean.cxf.hs" target="_blank">http://bean.cxf.hs</a>&quot;, &quot;seqId&quot;), String.class,
<img src="" alt="">                        &quot;12345678&quot;));
<img src="" alt="">                RespBean resp = ws.action(req);
<img src="" alt="">                System.out.println(&quot;resp_id:&quot; + resp.getRespId().getValue());
<img src="" alt="">                System.out.println(&quot;resp_exp:&quot; + resp.getExp().getValue());
<img src="" alt="">            }
<img src="" alt="">        } catch (Exception ex) {
<img src="" alt="">            ex.printStackTrace();
<img src="" alt="">        }
<img src="" alt="">    }
<img src="" alt="">
<img src="" alt="">    //<em>/</em>
<img src="" alt="">     /<em> 测试2
<img src="" alt="">     /</em>/
<img src="" alt="">    @SuppressWarnings(&quot;unchecked&quot;)
<img src="" alt="">    public void testSend2() {
<img src="" alt="">        String webServiceUrl = &quot;<a href="http://127.0.0.1:8080/cxfTest/ws/HelloWorld" target="_blank">http://127.0.0.1:8080/cxfTest/ws/HelloWorld</a>&quot;;
<img src="" alt="">        String webServiceConTimeout = &quot;60000&quot;;
<img src="" alt="">        String webServiceRevTimeout = &quot;60000&quot;;
<img src="" alt="">        JaxWsProxyFactoryBean factory = new JaxWsProxyFactoryBean();
<img src="" alt="">
<img src="" alt="">        ArrayList<Interceptor> list = new ArrayList<Interceptor>();
<img src="" alt="">        // 添加soap header 信息
<img src="" alt="">        list.add(new AddSoapHeader());
<img src="" alt="">        // 添加soap消息日志打印
<img src="" alt="">        list.add(new org.apache.cxf.interceptor.LoggingOutInterceptor());
<img src="" alt="">        factory.setOutInterceptors(list);
<img src="" alt="">        factory.setServiceClass(WebServiceSample.class);
<img src="" alt="">        factory.setAddress(webServiceUrl);
<img src="" alt="">        WebServiceSample service = (WebServiceSample) factory.create();
<img src="" alt="">
<img src="" alt="">        //超时时间设置
<img src="" alt="">        Client clientP = ClientProxy.getClient(service);
<img src="" alt="">        HTTPConduit http = (HTTPConduit) clientP.getConduit();
<img src="" alt="">        HTTPClientPolicy httpClientPolicy = new HTTPClientPolicy();
<img src="" alt="">        httpClientPolicy.setConnectionTimeout(Integer
<img src="" alt="">                .valueOf(webServiceConTimeout));
<img src="" alt="">        httpClientPolicy.setReceiveTimeout(Integer
<img src="" alt="">                .valueOf(webServiceRevTimeout));
<img src="" alt="">        httpClientPolicy.setAllowChunking(false);
<img src="" alt="">        http.setClient(httpClientPolicy);
<img src="" alt=""><br><img src="" alt=""><br><img src="" alt="">        // 通过对象来交互
<img src="" alt="">        ReqBean req = new ReqBean();
<img src="" alt="">        req.setExp(new JAXBElement<String>(new QName(
<img src="" alt="">                &quot;<a href="http://bean.cxf.hs" target="_blank">http://bean.cxf.hs</a>&quot;, &quot;exp&quot;), String.class,
<img src="" alt="">                &quot;<exp>111<exp>&quot;));
<img src="" alt="">        req.setSeqId(new JAXBElement<String>(new QName(
<img src="" alt="">                &quot;<a href="http://bean.cxf.hs" target="_blank">http://bean.cxf.hs</a>&quot;, &quot;seqId&quot;), String.class,
<img src="" alt="">                &quot;12345678&quot;));
<img src="" alt="">        System.out.println(&quot;&gt;&gt;&gt;&gt;&gt;&gt;发送消息&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&quot;);
<img src="" alt="">        RespBean resp = service.action(req);
<img src="" alt="">        System.out.println(&quot;resp_id:&quot; + resp.getRespId().getValue());
<img src="" alt="">        System.out.println(&quot;resp_exp:&quot; + resp.getExp().getValue());
<img src="" alt="">
<img src="" alt="">    }
<img src="" alt="">
<img src="" alt="">    //<em>/</em>
<img src="" alt="">     /<em> @param args
<img src="" alt="">     /</em>/
<img src="" alt="">    public static void main(String[] args) {
<img src="" alt="">        TestClient tc = new TestClient();
<img src="" alt="">        tc.testSend1();
<img src="" alt="">        System.out.println(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;2&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&quot;);
<img src="" alt="">        tc.testSend2();
<img src="" alt="">        System.out.println(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;END&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&quot;);
<img src="" alt="">    }
<img src="" alt="">
<img src="" alt="">}
到这里就结束了，可以进行测试了</p>
<p>posted on 2011-04-19 14:23 <a href="http://www.blogjava.net/fatbear/" target="_blank">fatbear</a> 阅读(3424) <a href="http://www.blogjava.net/fatbear/archive/2011/04/19/348567.html#Post" target="_blank">评论(10)</a>  <a href="http://www.blogjava.net/fatbear/admin/EditPosts.aspx?postid=348567" target="_blank">编辑</a>  <a href="http://www.blogjava.net/fatbear/AddToFavorite.aspx?id=348567" target="_blank">收藏</a> 所属分类: <a href="http://www.blogjava.net/fatbear/category/38312.html" target="_blank">web service</a>
<img src="" alt=""></p>
<p><a href=""></a><a href=""></a></p>
<p>[</p>
<h3 id="-">评论</h3>
<p>]()</p>
<h3 id="-http-www-blogjava-net-fatbear-archive-2011-04-19-348567-html-348729-permalink-re-cxf2-0-3-soap-header-re-cxf2-0-3-soap-header-2011-04-21-19-01-akana-"><a href=""></a><a href="http://www.blogjava.net/fatbear/archive/2011/04/19/348567.html#348729" title="permalink: re: CXF2.0学习笔记-3 SOAP Header">/#</a> <a href=""></a>re: CXF2.0学习笔记-3 SOAP Header 2011-04-21 19:01 <a href="">akana</a></h3>
<p>hello，我想问一下你的ReadSoapHeader这个服务端读取soap header实现成功了吗？我这里用这种方式总是出错： head = mess.getSOAPHeader();出现java.lang.NullPointerException错误。。  <a href="http://www.blogjava.net/fatbear/archive/2011/04/19/348567.html#post" target="_blank">回复</a>  <a href="http://www.blogjava.net/comment?author=akana" title="查看该作者发表过的评论" target="_blank">更多评论</a><a href=""></a>  <a href=""></a></p>
<h3 id="-http-www-blogjava-net-fatbear-archive-2011-04-19-348567-html-348730-permalink-re-cxf2-0-3-soap-header-re-cxf2-0-3-soap-header-2011-04-21-19-02-akana-"><a href="http://www.blogjava.net/fatbear/archive/2011/04/19/348567.html#348730" title="permalink: re: CXF2.0学习笔记-3 SOAP Header" target="_blank">/#</a> <a href=""></a>re: CXF2.0学习笔记-3 SOAP Header 2011-04-21 19:02 <a href="">akana</a></h3>
<p>另外问一下你学习CXF2.0的资料有哪些呢？可以推荐一下吗？  <a href="http://www.blogjava.net/fatbear/archive/2011/04/19/348567.html#post" target="_blank">回复</a>  <a href="http://www.blogjava.net/comment?author=akana" title="查看该作者发表过的评论" target="_blank">更多评论</a> <a href=""></a>  <a href=""></a></p>
<h3 id="-http-www-blogjava-net-fatbear-archive-2011-04-19-348567-html-348785-permalink-re-cxf2-0-3-soap-header-re-cxf2-0-3-soap-header-2011-04-22-11-55-akana-"><a href="http://www.blogjava.net/fatbear/archive/2011/04/19/348567.html#348785" title="permalink: re: CXF2.0学习笔记-3 SOAP Header" target="_blank">/#</a> <a href=""></a>re: CXF2.0学习笔记-3 SOAP Header 2011-04-22 11:55 <a href="">akana</a></h3>
<p>@akana 
找到错误了。我的ReadSoapHeader引用了 
import org.apache.xmlbeans.impl.soap.SOAPException; 
import org.apache.xmlbeans.impl.soap.SOAPHeader; 
import org.apache.xmlbeans.impl.soap.SOAPMessage; 
而应该是 
import javax.xml.soap.SOAPException; 
import javax.xml.soap.SOAPHeader; 
import javax.xml.soap.SOAPMessage;  <a href="http://www.blogjava.net/fatbear/archive/2011/04/19/348567.html#post" target="_blank">回复</a>  <a href="http://www.blogjava.net/comment?author=akana" title="查看该作者发表过的评论" target="_blank">更多评论</a> <a href=""></a>  <a href=""></a></p>
<h3 id="-http-www-blogjava-net-fatbear-archive-2011-04-19-348567-html-348838-permalink-re-cxf2-0-3-soap-header-re-cxf2-0-3-soap-header-2011-04-22-21-53-fatbear-http-www-blogjava-net-fatbear-"><a href="http://www.blogjava.net/fatbear/archive/2011/04/19/348567.html#348838" title="permalink: re: CXF2.0学习笔记-3 SOAP Header" target="_blank">/#</a> <a href=""></a>re: CXF2.0学习笔记-3 SOAP Header 2011-04-22 21:53 <a href="http://www.blogjava.net/fatbear/">fatbear</a></h3>
<p>@akana 
呵呵，我也是看官方文档与网络上的资料后，自己写的，一般都有经过测试的  <a href="http://www.blogjava.net/fatbear/archive/2011/04/19/348567.html#post" target="_blank">回复</a>  <a href="http://www.blogjava.net/comment?author=fatbear" title="查看该作者发表过的评论" target="_blank">更多评论</a> <a href=""></a>  <a href=""></a></p>
<h3 id="-http-www-blogjava-net-fatbear-archive-2011-04-19-348567-html-357625-permalink-re-cxf-2-0-3-soap-header-re-cxf-2-0-3-soap-header-2011-08-31-11-08-"><a href="http://www.blogjava.net/fatbear/archive/2011/04/19/348567.html#357625" title="permalink: re: CXF 2.0 学习笔记-3 SOAP Header" target="_blank">/#</a> <a href=""></a>re: CXF 2.0 学习笔记-3 SOAP Header 2011-08-31 11:08 <a href="">无</a></h3>
<p>您好，ReadSoapHeader这个服务端读取soap header时，mess这个一直都是空的，这是怎么回事呀？  <a href="http://www.blogjava.net/fatbear/archive/2011/04/19/348567.html#post" target="_blank">回复</a>  <a href="http://www.blogjava.net/comment?author=%e6%97%a0" title="查看该作者发表过的评论" target="_blank">更多评论</a> <a href=""></a>  <a href=""></a></p>
<h3 id="-http-www-blogjava-net-fatbear-archive-2011-04-19-348567-html-382882-permalink-re-cxf-2-0-3-soap-header-re-cxf-2-0-3-soap-header-2012-07-12-15-27-"><a href="http://www.blogjava.net/fatbear/archive/2011/04/19/348567.html#382882" title="permalink: re: CXF 2.0 学习笔记-3 SOAP Header" target="_blank">/#</a> <a href=""></a>re: CXF 2.0 学习笔记-3 SOAP Header 2012-07-12 15:27 <a href="">林子</a></h3>
<p>factory.setOutInterceptors(list); 
factory.setServiceClass(WebServiceSample.class); 
factory.setAddress(&quot;<a href="http://127.0.0.1:8080/cxfTest/ws/HelloWorld%22" target="_blank"><a href="http://127.0.0.1:8080/cxfTest/ws/HelloWorld">http://127.0.0.1:8080/cxfTest/ws/HelloWorld</a>&quot;</a>); 
类org.apache.cxf.jaxws.JaxWsProxyFactoryBean 没有以上3个方法，引用的路径完全一样。。  <a href="http://www.blogjava.net/fatbear/archive/2011/04/19/348567.html#post" target="_blank">回复</a>  <a href="http://www.blogjava.net/comment?author=%e6%9e%97%e5%ad%90" title="查看该作者发表过的评论" target="_blank">更多评论</a> <a href=""></a>  <a href=""></a></p>
<h3 id="-http-www-blogjava-net-fatbear-archive-2011-04-19-348567-html-382899-permalink-re-cxf-2-0-3-soap-header-re-cxf-2-0-3-soap-header-2012-07-12-16-45-"><a href="http://www.blogjava.net/fatbear/archive/2011/04/19/348567.html#382899" title="permalink: re: CXF 2.0 学习笔记-3 SOAP Header" target="_blank">/#</a> <a href=""></a>re: CXF 2.0 学习笔记-3 SOAP Header 2012-07-12 16:45 <a href="">林子</a></h3>
<p>@林子 
我找到原因了，那是因为这3个方法时父类的方法而我没导入他父类的jar包，但是又抛了一个新异常： 
Exception in thread &quot;main&quot; javax.xml.ws.soap.SOAPFaultException: Could not find conduit initiator for transport <a href="http://schemas.xmlsoap.org/soap/http" target="_blank"><a href="http://schemas.xmlsoap.org/soap/http">http://schemas.xmlsoap.org/soap/http</a></a> 
at org.apache.cxf.jaxws.JaxWsClientProxy.invoke(JaxWsClientProxy.java:146) 
at $Proxy25.sendSms(Unknown Source) 
at Test.main(Test.java:48) 
Caused by: java.lang.RuntimeException: Could not find conduit initiator for transport <a href="http://schemas.xmlsoap.org/soap/http" target="_blank"><a href="http://schemas.xmlsoap.org/soap/http">http://schemas.xmlsoap.org/soap/http</a></a> 
at org.apache.cxf.binding.soap.SoapTransportFactory.getConduit(SoapTransportFactory.java:230) 
at org.apache.cxf.endpoint.AbstractConduitSelector.getSelectedConduit(AbstractConduitSelector.java:81) 
at org.apache.cxf.endpoint.UpfrontConduitSelector.prepare(UpfrontConduitSelector.java:61) 
at org.apache.cxf.endpoint.ClientImpl.prepareConduitSelector(ClientImpl.java:809) 
at org.apache.cxf.endpoint.ClientImpl.doInvoke(ClientImpl.java:505) 
at org.apache.cxf.endpoint.ClientImpl.invoke(ClientImpl.java:440) 
at org.apache.cxf.endpoint.ClientImpl.invoke(ClientImpl.java:343) 
at org.apache.cxf.endpoint.ClientImpl.invoke(ClientImpl.java:295) 
at org.apache.cxf.frontend.ClientProxy.invokeSync(ClientProxy.java:73) 
at org.apache.cxf.jaxws.JaxWsClientProxy.invoke(JaxWsClientProxy.java:124) 
... 2 more 
  <a href="http://www.blogjava.net/fatbear/archive/2011/04/19/348567.html#post" target="_blank">回复</a>  <a href="http://www.blogjava.net/comment?author=%e6%9e%97%e5%ad%90" title="查看该作者发表过的评论" target="_blank">更多评论</a> <a href=""></a>  <a href=""></a></p>
<h3 id="-http-www-blogjava-net-fatbear-archive-2011-04-19-348567-html-384016-permalink-re-cxf-2-0-3-soap-header-re-cxf-2-0-3-soap-header-2012-07-26-08-45-fatbear-http-www-blogjava-net-fatbear-"><a href="http://www.blogjava.net/fatbear/archive/2011/04/19/348567.html#384016" title="permalink: re: CXF 2.0 学习笔记-3 SOAP Header" target="_blank">/#</a> <a href=""></a>re: CXF 2.0 学习笔记-3 SOAP Header 2012-07-26 08:45 <a href="http://www.blogjava.net/fatbear/">fatbear</a></h3>
<p>@林子 
现在开发cxf已经很简单了，eclipse3.7已经自带有cxf插件，可以很方便的生成服务端与客户端，你可以用那个来弄，基本就不会有问题了  <a href="http://www.blogjava.net/fatbear/archive/2011/04/19/348567.html#post" target="_blank">回复</a>  <a href="http://www.blogjava.net/comment?author=fatbear" title="查看该作者发表过的评论" target="_blank">更多评论</a> <a href=""></a>  <a href=""></a></p>
<h3 id="-http-www-blogjava-net-fatbear-archive-2011-04-19-348567-html-393143-permalink-re-cxf-2-0-3-soap-header-re-cxf-2-0-3-soap-header-2012-12-18-14-40-randy-"><a href="http://www.blogjava.net/fatbear/archive/2011/04/19/348567.html#393143" title="permalink: re: CXF 2.0 学习笔记-3 SOAP Header[未登录]" target="_blank">/#</a> <a href=""></a>re: CXF 2.0 学习笔记-3 SOAP Header[未登录] 2012-12-18 14:40 <a href="">randy</a></h3>
<p>能解释下这两句代码的意思吗？ 
if (mess == null) { 
saa.handleMessage(message); 
mess = message.getContent(SOAPMessage.class); 
} 
还有什么情况下mess会为null？谢谢  <a href="http://www.blogjava.net/fatbear/archive/2011/04/19/348567.html#post" target="_blank">回复</a>  <a href="http://www.blogjava.net/comment?author=randy" title="查看该作者发表过的评论" target="_blank">更多评论</a> <a href=""></a>  <a href=""></a></p>
<h3 id="-http-www-blogjava-net-fatbear-archive-2011-04-19-348567-html-400293-permalink-re-cxf-2-0-3-soap-header-re-cxf-2-0-3-soap-header-2013-06-06-12-08-eason-"><a href="http://www.blogjava.net/fatbear/archive/2011/04/19/348567.html#400293" title="permalink: re: CXF 2.0 学习笔记-3 SOAP Header[未登录]" target="_blank">/#</a> <a href=""></a>re: CXF 2.0 学习笔记-3 SOAP Header[未登录]<a href=""></a> 2013-06-06 12:08 <a href="">Eason</a></h3>
<p>xml格式： </p>
<p><soap:Header> </p>
<p><auth:authentication xmlns:auth="[http://gd.chinamobile.com//authentication">](<a href="http://gd.chinamobile.com//authentication%22%3E">http://gd.chinamobile.com//authentication%22%3E</a>) </p>
<p><auth:systemID>1</auth:systemID> </p>
<p><auth:userID>test</auth:userID> </p>
<p><auth:password>test</auth:password> 
</auth:authentication> 
</soap:Header> 这个如何生成？  <a href="http://www.blogjava.net/fatbear/archive/2011/04/19/348567.html#post" target="_blank">回复</a>  <a href="http://www.blogjava.net/comment?author=Eason" title="查看该作者发表过的评论" target="_blank">更多评论</a> <a href=""></a><br>来源： <a href="[http://www.blogjava.net/fatbear/archive/2011/04/19/348567.html](http://www.blogjava.net/fatbear/archive/2011/04/19/348567.html)">[http://www.blogjava.net/fatbear/archive/2011/04/19/348567.html](http://www.blogjava.net/fatbear/archive/2011/04/19/348567.html)</a> </p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/webservice/">webservice</a></li></span><span class="breadcrumb"><li><a href="/categories/webservice/">webservice</a></li><li><a href="/categories/webservice/CXF/">CXF</a></li></span></span> | <span class="tags">Tagged <a href="/tags/CXF/" class="label label-primary">CXF</a><a href="/tags/webservice/" class="label label-success">webservice</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:45"datetime="2014-03-07 09:54:45"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-webservice-CXF--ApacheCXF/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-webservice-CXF--ApacheCXF" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-服务器-Nginx--Nginx调优/">Nginx调优</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:45.000Z"> <a href="/2014/02/02/2014-02-02-服务器-Nginx--Nginx调优/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="nginx-">Nginx调优</h1>
<p>这篇文章的目的是要谈谈我的 Nginx 调优经验，就不涉及数据库调优的内容了。</p>
<h3 id="-">初始服务器设置</h3>
<p>我的服务器运行在亚马逊 EC2 t1 micro 上，选择 Nginx + PHP5-fpm 作为后端，因为一些安全因素还打开了SSL。</p>
<h3 id="-">性能测试</h3>
<p>我使用了Blitz.io 来进行压力测试。下面是我使用的命令：
1 -p</p>
<p>1-250:60 <a href="https://mydomian.com" target="_blank">https://mydomian.com</a></p>
<p>这是一个用户线性递增的测试，每个测试用户跑60秒。Blitz.io为每个请求每秒增加4个( = rise / run = 260 / 60)测试用户。</p>
<h3 id="-">结论</h3>
<p>我把结论提前写在这里，如果你不想读完整篇文章也没有问题。</p>
<ol>
<li>Nginx默认设置的DH算法（译注：Diffie-Hellman key exchange algorithm）是影响SSL性能的最大因素，因此采用如下设置能增加SSL性能：
1</li>
</ol>
<p>2
3</p>
<p>4
5 ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</p>
<p>ssl_ciphers ECDHE</p>
<p>-RSA</p>
<p>-AES256-SHA384:AES256-SHA256:RC4:HIGH:!MD5:!aNULL:!eNULL:!NULL:!DH:!EDH:!AESGCM;
ssl_prefer_server_ciphers on;</p>
<p>ssl_session_cache shared:SSL:10m;
ssl_session_timeout 10m;</p>
<ol>
<li>升级硬件 Upgrade your EC2 from t1.micro to c1.medium</li>
<li>正确配置 Nginx的worker进程数量 Set Nginx to have 2 worker processes as a c1.medium gives you 2 CPUs</li>
</ol>
<h3 id="-">细节解释</h3>
<p>以下是我进行测试的详细过程。</p>
<p><strong>尝试1：升级硬件</strong></p>
<p>直觉告诉我，想解决性能问题的直接途径就是升级硬件，我把EC2实例从t1.micro升级到了为高流量而优化过的c1.medium</p>
<p>升级后的测试结果：
<img src="" alt=""></p>
<p>巅峰时服务器的hits达到50/sec，压力增加时，time-out增加，hits减少。</p>
<p><strong>尝试2：测试CPU性能</strong></p>
<p>我打开top然后重启了测试，注意到2个CPU的使用率不到13%，内存使用了300Mb，很明显硬件没有充分利用。所以我更改了nginx的设置</p>
<p>worker_processes 2;</p>
<p><strong>尝试3，4，5：调整Nginx和PHP5-fpm</strong></p>
<p>以下尝试得到的结果都和尝试1相同</p>
<p>尝试3：</p>
<p><strong>nginx.conf</strong>
1</p>
<p>2
3</p>
<p>4
5</p>
<p>6
 worker_processes 2;</p>
<p>events {
worker_connections 19000;</p>
<p>multi_accept on;
}</p>
<p>...</p>
<p>尝试4：</p>
<p><strong>nginx.conf</strong>
1</p>
<p>2
3</p>
<p>4
5</p>
<p>6
7</p>
<p>8
9</p>
<p>10
11</p>
<p>12
13</p>
<p>14
15 worker_processes 2;</p>
<p>events {
worker_connections 19000;</p>
<p>multi_accept on;
}</p>
<p>http {
gzip on;</p>
<p>gzip_disable &quot;msie6&quot;;
gzip_min_length 1000;</p>
<p>gzip_proxied expired no-cache no-store private auth;
gzip_types text/plain application/xml application/javascript text/css application/x-javascript;</p>
<p>…
}</p>
<p>...</p>
<p>尝试5：</p>
<p>在尝试4未变的情况下我更改了php5-fpm的设置：
1</p>
<p>2
3</p>
<p>4
5 pm.max_children = 160</p>
<p>pm.start_servers = 24
pm.min_spare_servers = 20</p>
<p>pm.max_spare_servers = 35
pm.max_requests = 1500</p>
<h3 id="-6-"><strong>尝试6**</strong>：在另一个服务器部署**</h3>
<p>我有一个1.5Gb RAM和8CPU的<a href="http://blog.jobbole.com/go/linode/" title="Linode" target="_blank">Linode</a>服务器，采用刚才的设置，这是我的测试结果：
<img src="" alt=""></p>
<p><a href="http://blog.jobbole.com/go/linode/" title="Linode" target="_blank">Linode</a>的服务器的结果棒极了！我的第一个直觉是难道Linode比EC2好吗。在我把我的服务迁移到Linode之前我想确保两者仅有的对性能有可能产生影响的不同被排除掉。</p>
<p><strong>尝试7：大惊喜</strong></p>
<p>我Google到Nginx在SSL上有些问题。Nginx默认使用DHE算法来产生密匙，改变这个设置应该能使它快一些。</p>
<p>这里是我参考的一些文章：</p>
<p><a href="http://matt.io/entry/ur" target="_blank">http://matt.io/entry/ur</a></p>
<p><a href="http://auxbuss.com/blog/posts/2011_06_28_ssl_session_caching_on_nginx/" target="_blank">http://auxbuss.com/blog/posts/2011_06_28_ssl_session_caching_on_nginx/</a></p>
<p>所以我更改了nginx.conf，删掉了kEDH算法
1</p>
<p>2
3</p>
<p>4
5</p>
<p>6
7</p>
<p>8
9</p>
<p>10
11</p>
<p>12
13</p>
<p>14
15 worker_processes 2;</p>
<p>events {
worker_connections 1024;</p>
<p>}
http {</p>
<p>gzip on;
gzip_disable &quot;msie6&quot;;</p>
<p>gzip_min_length 1000;
gzip_proxied expired no-cache no-store private auth;</p>
<p>gzip_types text/plain application/xml application/javascript text/css application/x-javascript;
ssl_ciphers ALL:!kEDH!ADH:RC4+RSA:+HIGH:+EXP;</p>
<p>…
}</p>
<p>...</p>
<p>下图是测试结果：</p>
<p><img src="" alt=""></p>
<p>效果很显著！</p>
<p><strong>尝试8： 硬件提升是必要的吗</strong></p>
<p>现在我的EC2和Linode表现差不多了。但是我真的需要升级到c1.medium实例才能实现这个性能的提升吗？或许不是这样……所以我把我改回了t1.micro。因为t1.micro实例只有一个CPU，所以我把worder_processes设置改回1。下面是测试的结果：</p>
<p><img src="" alt=""></p>
<p>所以答案是肯定的，硬件上的提升是必要的。</p>
<p><strong>尝试9：</strong></p>
<p>有人在 Hacker News 上反馈说我的SSL密匙不能满足Perfect Forward Secrecy，我采用了他们的建议，对我的SSL设置做了如下更改：
1</p>
<p>2
3</p>
<p>4
5 ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</p>
<p>ssl_ciphers ECDHE-RSA-AES256-SHA384:AES256-SHA256:RC4:HIGH:!MD5:!aNULL:!eNULL:!NULL:!DH:!EDH:!AESGCM;
ssl_prefer_server_ciphers on;</p>
<p>ssl_session_cache shared:SSL:10m;
ssl_session_timeout 10m;</p>
<p>现在这个设置应该满足Perfect Forward Secrecy协议了。我重新跑了测试：</p>
<p><strong><a href="http://techsamurais.com/wp-content/uploads/2013/08/attempt10.png" title="Nginx SSL性能调优" target="_blank"><img src="" alt="attempt10"></a></strong></p>
<p>太棒了，性能也没有下降。很棒的学习经验！</p>
<p>来源： &lt;<a href="http://blog.jobbole.com/44844/" target="_blank">Nginx SSL性能调优 - 博客 - 伯乐在线</a>&gt; </p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/服务器/">服务器</a></li></span><span class="breadcrumb"><li><a href="/categories/服务器/">服务器</a></li><li><a href="/categories/服务器/Nginx/">Nginx</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Nginx/" class="label label-primary">Nginx</a><a href="/tags/服务器/" class="label label-success">服务器</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:45"datetime="2014-03-07 09:54:45"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-服务器-Nginx--Nginx调优/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-服务器-Nginx--Nginx调优" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-服务器-tomcat--Servlet工作原理/">Servlet工作原理</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:45.000Z"> <a href="/2014/02/02/2014-02-02-服务器-tomcat--Servlet工作原理/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="servlet-">Servlet工作原理</h1>
<p><a href="http://blog.csdn.net/haojun186/article/details/7467100" target="_blank">Servlet工作原理</a></p>
<p><a href="">从 Servlet 容器说起</a></p>
<p>要介绍 Servlet 必须要先把 Servlet 容器说清楚，Servlet 与 Servlet 容器的关系有点像枪和子弹的关系，枪是为子弹而生，而子弹又让枪有了杀伤力。虽然它们是彼此依存的，但是又相互独立发展，这一切都是为了适应工业化生产的结果。从技术角度来说是为了解耦，通过标准化接口来相互协作。既然接口是连接 Servlet 与 Servlet 容器的关键，那我们就从它们的接口说起。</p>
<p>前面说了 Servlet 容器作为一个独立发展的标准化产品，目前它的种类很多，但是它们都有自己的市场定位，很难说谁优谁劣，各有特点。例如现在比较流行的 Jetty，在定制化和移动领域有不错的发展，我们这里还是以大家最为熟悉 Tomcat 为例来介绍 Servlet 容器如何管理 Servlet。Tomcat 本身也很复杂，我们只从 Servlet 与 Servlet 容器的接口部分开始介绍，关于 Tomcat 的详细介绍可以参考我的另外一篇文章《 Tomcat 系统架构与模式设计分析》。</p>
<p>Tomcat 的容器等级中，Context 容器是直接管理 Servlet 在容器中的包装类 Wrapper，所以 Context 容器如何运行将直接影响 Servlet 的工作方式。
<a href=""><strong>图 1 . Tomcat 容器模型</strong></a>
<img src="" alt="图 1 . Tomcat 容器模型"></p>
<p>从上图可以看出 Tomcat 的容器分为四个等级，真正管理 Servlet 的容器是 Context 容器，一个 Context 对应一个 Web 工程，在 Tomcat 的配置文件中可以很容易发现这一点，如下：
<a href=""><strong>清单 1 Context 配置参数</strong></a></p>
<Context path="/projectOne " docBase="D:\projects\projectOne"
reloadable="true" />

<p>下面详细介绍一下 Tomcat 解析 Context 容器的过程，包括如何构建 Servlet 的过程。</p>
<p><a href="">Servlet 容器的启动过程</a></p>
<p>Tomcat7 也开始支持嵌入式功能，增加了一个启动类 org.apache.catalina.startup.Tomcat。创建一个实例对象并调用 start 方法就可以很容易启动 Tomcat，我们还可以通过这个对象来增加和修改 Tomcat 的配置参数，如可以动态增加 Context、Servlet 等。下面我们就利用这个 Tomcat 类来管理新增的一个 Context 容器，我们就选择 Tomcat7 自带的 examples Web 工程，并看看它是如何加到这个 Context 容器中的。
<a href=""><strong>清单 2 . 给 Tomcat 增加一个 Web 工程</strong></a></p>
<p>Tomcat tomcat = getTomcatInstance();
File appDir = new File(getBuildDirectory(), &quot;webapps/examples&quot;);</p>
<p>tomcat.addWebapp(null, &quot;/examples&quot;, appDir.getAbsolutePath());
tomcat.start();</p>
<p>ByteChunk res = getUrl(&quot;<a href="http://localhost" target="_blank">http://localhost</a>:&quot; + getPort() +
               &quot;/examples/servlets/servlet/HelloWorldExample&quot;);</p>
<p>assertTrue(res.toString().indexOf(&quot;<h1>Hello World!</h1>&quot;) &gt; 0);</p>
<p>清单 1 的代码是创建一个 Tomcat 实例并新增一个 Web 应用，然后启动 Tomcat 并调用其中的一个 HelloWorldExample Servlet，看有没有正确返回预期的数据。</p>
<p>Tomcat 的 addWebapp 方法的代码如下：
<a href=""><strong>清单 3 .Tomcat.addWebapp</strong></a></p>
<p>public Context addWebapp(Host host, String url, String path) {
        silence(url);</p>
<pre><code>    Context ctx = new StandardContext();
    ctx.setPath( url );

    ctx.setDocBase(path);
    if (defaultRealm == null) {

        initSimpleAuth();
    }

    ctx.setRealm(defaultRealm);
    ctx.addLifecycleListener(new DefaultWebXmlListener());

    ContextConfig ctxCfg = new ContextConfig();
    ctx.addLifecycleListener(ctxCfg);

    ctxCfg.setDefaultWebXml(&quot;org/apache/catalin/startup/NO_DEFAULT_XML&quot;);
    if (host == null) {

        getHost().addChild(ctx);
    } else {

        host.addChild(ctx);
    }

    return ctx;
</code></pre><p>}</p>
<p>前面已经介绍了一个 Web 应用对应一个 Context 容器，也就是 Servlet 运行时的 Servlet 容器，添加一个 Web 应用时将会创建一个 StandardContext 容器，并且给这个 Context 容器设置必要的参数，url 和 path 分别代表这个应用在 Tomcat 中的访问路径和这个应用实际的物理路径，这个两个参数与清单 1 中的两个参数是一致的。其中最重要的一个配置是 ContextConfig，这个类将会负责整个 Web 应用配置的解析工作，后面将会详细介绍。最后将这个 Context 容器加到父容器 Host 中。</p>
<p>接下去将会调用 Tomcat 的 start 方法启动 Tomcat，如果你清楚 Tomcat 的系统架构，你会容易理解 Tomcat 的启动逻辑，Tomcat 的启动逻辑是基于观察者模式设计的，所有的容器都会继承 Lifecycle 接口，它管理者容器的整个生命周期，所有容器的的修改和状态的改变都会由它去通知已经注册的观察者（Listener），关于这个设计模式可以参考《 Tomcat 的系统架构与设计模式，第二部分：设计模式》。Tomcat 启动的时序图可以用图 2 表示。
<a href=""><strong>图 2. Tomcat 主要类的启动时序图（</strong></a><strong><a href="http://www.ibm.com/developerworks/cn/java/j-lo-servlet/image003.jpg" target="_blank">查看大图</a>）</strong>
<img src="" alt="图 2. Tomcat 主要类的启动时序图"></p>
<p>上图描述了 Tomcat 启动过程中，主要类之间的时序关系，下面我们将会重点关注添加 examples 应用所对应的 StandardContext 容器的启动过程。</p>
<p>当 Context 容器初始化状态设为 init 时，添加在 Contex 容器的 Listener 将会被调用。ContextConfig 继承了 LifecycleListener 接口，它是在调用清单 3 时被加入到 StandardContext 容器中。ContextConfig 类会负责整个 Web 应用的配置文件的解析工作。</p>
<p>ContextConfig 的 init 方法将会主要完成以下工作：</p>
<ol>
<li>创建用于解析 xml 配置文件的 contextDigester 对象</li>
<li>读取默认 context.xml 配置文件，如果存在解析它</li>
<li>读取默认 Host 配置文件，如果存在解析它</li>
<li>读取默认 Context 自身的配置文件，如果存在解析它</li>
<li>设置 Context 的 DocBase</li>
</ol>
<p>ContextConfig 的 init 方法完成后，Context 容器的会执行 startInternal 方法，这个方法启动逻辑比较复杂，主要包括如下几个部分：</p>
<ol>
<li>创建读取资源文件的对象</li>
<li>创建 ClassLoader 对象</li>
<li>设置应用的工作目录</li>
<li>启动相关的辅助类如：logger、realm、resources 等</li>
<li>修改启动状态，通知感兴趣的观察者（Web 应用的配置）</li>
<li>子容器的初始化</li>
<li>获取 ServletContext 并设置必要的参数</li>
<li>初始化“load on startup”的 Servlet</li>
</ol>
<p><a href="">Web 应用的初始化工作</a></p>
<p>Web 应用的初始化工作是在 ContextConfig 的 configureStart 方法中实现的，应用的初始化主要是要解析 web.xml 文件，这个文件描述了一个 Web 应用的关键信息，也是一个 Web 应用的入口。</p>
<p>Tomcat 首先会找 globalWebXml 这个文件的搜索路径是在 engine 的工作目录下寻找以下两个文件中的任一个 org/apache/catalin/startup/NO_DEFAULT_XML 或 conf/web.xml。接着会找 hostWebXml 这个文件可能会在 System.getProperty(&quot;catalina.base&quot;)/conf/${EngineName}/${HostName}/web.xml.default，接着寻找应用的配置文件 examples/WEB-INF/web.xml。web.xml 文件中的各个配置项将会被解析成相应的属性保存在 WebXml 对象中。如果当前应用支持 Servlet3.0，解析还将完成额外 9 项工作，这个额外的 9 项工作主要是为 Servlet3.0 新增的特性，包括 jar 包中的 META-INF/web-fragment.xml 的解析以及对 annotations 的支持。</p>
<p>接下去将会将 WebXml 对象中的属性设置到 Context 容器中，这里包括创建 Servlet 对象、filter、listener 等等。这段代码在 WebXml 的 configureContext 方法中。下面是解析 Servlet 的代码片段：
<a href=""><strong>清单 4. 创建 Wrapper 实例</strong></a></p>
<p>for (ServletDef servlet : servlets.values()) {
            Wrapper wrapper = context.createWrapper();</p>
<pre><code>        String jspFile = servlet.getJspFile();
        if (jspFile != null) {

            wrapper.setJspFile(jspFile);
        }

        if (servlet.getLoadOnStartup() != null) {
            wrapper.setLoadOnStartup(servlet.getLoadOnStartup().intValue());

        }
        if (servlet.getEnabled() != null) {

            wrapper.setEnabled(servlet.getEnabled().booleanValue());
        }

        wrapper.setName(servlet.getServletName());
        Map&lt;String,String&gt; params = servlet.getParameterMap();

        for (Entry&lt;String, String&gt; entry : params.entrySet()) {
            wrapper.addInitParameter(entry.getKey(), entry.getValue());

        }
        wrapper.setRunAs(servlet.getRunAs());

        Set&lt;SecurityRoleRef&gt; roleRefs = servlet.getSecurityRoleRefs();
        for (SecurityRoleRef roleRef : roleRefs) {

            wrapper.addSecurityReference(
                    roleRef.getName(), roleRef.getLink());

        }
        wrapper.setServletClass(servlet.getServletClass());

        MultipartDef multipartdef = servlet.getMultipartDef();
        if (multipartdef != null) {

            if (multipartdef.getMaxFileSize() != null &amp;&amp;
                    multipartdef.getMaxRequestSize()!= null &amp;&amp;

                    multipartdef.getFileSizeThreshold() != null) {
                wrapper.setMultipartConfigElement(new
</code></pre><p>MultipartConfigElement(
                            multipartdef.getLocation(),</p>
<pre><code>                        Long.parseLong(multipartdef.getMaxFileSize()),
                        Long.parseLong(multipartdef.getMaxRequestSize()),

                        Integer.parseInt(
                                multipartdef.getFileSizeThreshold())));

            } else {
                wrapper.setMultipartConfigElement(new
</code></pre><p>MultipartConfigElement(
                            multipartdef.getLocation()));</p>
<pre><code>            }
        }

        if (servlet.getAsyncSupported() != null) {
            wrapper.setAsyncSupported(

                    servlet.getAsyncSupported().booleanValue());
        }

        context.addChild(wrapper);
</code></pre><p>}</p>
<p>这段代码清楚的描述了如何将 Servlet 包装成 Context 容器中的 StandardWrapper，这里有个疑问，为什么要将 Servlet 包装成 StandardWrapper 而不直接是 Servlet 对象。这里 StandardWrapper 是 Tomcat 容器中的一部分，它具有容器的特征，而 Servlet 为了一个独立的 web 开发标准，不应该强耦合在 Tomcat 中。</p>
<p>除了将 Servlet 包装成 StandardWrapper 并作为子容器添加到 Context 中，其它的所有 web.xml 属性都被解析到 Context 中，所以说 Context 容器才是真正运行 Servlet 的 Servlet 容器。一个 Web 应用对应一个 Context 容器，容器的配置属性由应用的 web.xml 指定，这样我们就能理解 web.xml 到底起到什么作用了。</p>
<p><a href="http://www.ibm.com/developerworks/cn/java/j-lo-servlet/#ibm-pcon" target="_blank">回页首</a></p>
<p><a href="">创建 Servlet 实例</a></p>
<p>前面已经完成了 Servlet 的解析工作，并且被包装成 StandardWrapper 添加在 Context 容器中，但是它仍然不能为我们工作，它还没有被实例化。下面我们将介绍 Servlet 对象是如何创建的，以及如何被初始化的。</p>
<p><a href="">创建 Servlet 对象</a></p>
<p>如果 Servlet 的 load-on-startup 配置项大于 0，那么在 Context 容器启动的时候就会被实例化，前面提到在解析配置文件时会读取默认的 globalWebXml，在 conf 下的 web.xml 文件中定义了一些默认的配置项，其定义了两个 Servlet，分别是：org.apache.catalina.servlets.DefaultServlet 和 org.apache.jasper.servlet.JspServlet 它们的 load-on-startup 分别是 1 和 3，也就是当 Tomcat 启动时这两个 Servlet 就会被启动。</p>
<p>创建 Servlet 实例的方法是从 Wrapper. loadServlet 开始的。loadServlet 方法要完成的就是获取 servletClass 然后把它交给 InstanceManager 去创建一个基于 servletClass.class 的对象。如果这个 Servlet 配置了 jsp-file，那么这个 servletClass 就是 conf/web.xml 中定义的 org.apache.jasper.servlet.JspServlet 了。</p>
<p>创建 Servlet 对象的相关类结构图如下：
<a href=""><strong>图 3. 创建 Servlet 对象的相关类结构</strong></a>
<img src="" alt="图 3. 创建 Servlet 对象的相关类结构"></p>
<p><a href="">初始化 Servlet</a></p>
<p>初始化 Servlet 在 StandardWrapper 的 initServlet 方法中，这个方法很简单就是调用 Servlet 的 init 的方法，同时把包装了 StandardWrapper 对象的 StandardWrapperFacade 作为 ServletConfig 传给 Servlet。Tomcat 容器为何要传 StandardWrapperFacade 给 Servlet 对象将在后面做详细解析。</p>
<p>如果该 Servlet 关联的是一个 jsp 文件，那么前面初始化的就是 JspServlet，接下去会模拟一次简单请求，请求调用这个 jsp 文件，以便编译这个 jsp 文件为 class，并初始化这个 class。</p>
<p>这样 Servlet 对象就初始化完成了，事实上 Servlet 从被 web.xml 中解析到完成初始化，这个过程非常复杂，中间有很多过程，包括各种容器状态的转化引起的监听事件的触发、各种访问权限的控制和一些不可预料的错误发生的判断行为等等。我们这里只抓了一些关键环节进行阐述，试图让大家有个总体脉络。</p>
<p>下面是这个过程的一个完整的时序图，其中也省略了一些细节。
<a href=""><strong>图 4. 初始化 Servlet 的时序图（</strong></a><strong><a href="http://www.ibm.com/developerworks/cn/java/j-lo-servlet/image007.jpg" target="_blank">查看大图</a>）</strong>
<img src="" alt="图 4. 初始化 Servlet 的时序图"></p>
<p><a href="http://www.ibm.com/developerworks/cn/java/j-lo-servlet/#ibm-pcon" target="_blank">回页首</a></p>
<p><a href="">Servlet 体系结构</a></p>
<p>我们知道 Java Web 应用是基于 Servlet 规范运转的，那么 Servlet 本身又是如何运转的呢？为何要设计这样的体系结构。
<a href=""><strong>图 5.Servlet 顶层类关联图</strong></a>
<img src="" alt="图 5.Servlet 顶层类关联图"></p>
<p>从上图可以看出 Servlet 规范就是基于这几个类运转的，与 Servlet 主动关联的是三个类，分别是 ServletConfig、ServletRequest 和 ServletResponse。这三个类都是通过容器传递给 Servlet 的，其中 ServletConfig 是在 Servlet 初始化时就传给 Servlet 了，而后两个是在请求达到时调用 Servlet 时传递过来的。我们很清楚 ServletRequest 和 ServletResponse 在 Servlet 运行的意义，但是 ServletConfig 和 ServletContext 对 Servlet 有何价值？仔细查看 ServletConfig 接口中声明的方法发现，这些方法都是为了获取这个 Servlet 的一些配置属性，而这些配置属性可能在 Servlet 运行时被用到。而 ServletContext 又是干什么的呢？ Servlet 的运行模式是一个典型的“握手型的交互式”运行模式。所谓“握手型的交互式”就是两个模块为了交换数据通常都会准备一个交易场景，这个场景一直跟随个这个交易过程直到这个交易完成为止。这个交易场景的初始化是根据这次交易对象指定的参数来定制的，这些指定参数通常就会是一个配置类。所以对号入座，交易场景就由 ServletContext 来描述，而定制的参数集合就由 ServletConfig 来描述。而 ServletRequest 和 ServletResponse 就是要交互的具体对象了，它们通常都是作为运输工具来传递交互结果。</p>
<p>ServletConfig 是在 Servlet init 时由容器传过来的，那么 ServletConfig 到底是个什么对象呢？</p>
<p>下图是 ServletConfig 和 ServletContext 在 Tomcat 容器中的类关系图。
<a href=""><strong>图 6. ServletConfig 在容器中的类关联图</strong></a>
<img src="" alt="图 6. ServletConfig 在容器中的类关联图"></p>
<p>上图可以看出 StandardWrapper 和 StandardWrapperFacade 都实现了 ServletConfig 接口，而 StandardWrapperFacade 是 StandardWrapper 门面类。所以传给 Servlet 的是 StandardWrapperFacade 对象，这个类能够保证从 StandardWrapper 中拿到 ServletConfig 所规定的数据，而又不把 ServletConfig 不关心的数据暴露给 Servlet。</p>
<p>同样 ServletContext 也与 ServletConfig 有类似的结构，Servlet 中能拿到的 ServletContext 的实际对象也是 ApplicationContextFacade 对象。ApplicationContextFacade 同样保证 ServletContex 只能从容器中拿到它该拿的数据，它们都起到对数据的封装作用，它们使用的都是门面设计模式。</p>
<p>通过 ServletContext 可以拿到 Context 容器中一些必要信息，比如应用的工作路径，容器支持的 Servlet 最小版本等。</p>
<p>Servlet 中定义的两个 ServletRequest 和 ServletResponse 它们实际的对象又是什么呢？，我们在创建自己的 Servlet 类时通常使用的都是 HttpServletRequest 和 HttpServletResponse，它们继承了 ServletRequest 和 ServletResponse。为何 Context 容器传过来的 ServletRequest、ServletResponse 可以被转化为 HttpServletRequest 和 HttpServletResponse 呢？
<a href=""><strong>图 7.Request 相关类结构图</strong></a>
<img src="" alt="图 7.Request 相关类结构图"></p>
<p>上图是 Tomcat 创建的 Request 和 Response 的类结构图。Tomcat 一接受到请求首先将会创建 org.apache.coyote.Request 和 org.apache.coyote.Response，这两个类是 Tomcat 内部使用的描述一次请求和相应的信息类它们是一个轻量级的类，它们作用就是在服务器接收到请求后，经过简单解析将这个请求快速的分配给后续线程去处理，所以它们的对象很小，很容易被 JVM 回收。接下去当交给一个用户线程去处理这个请求时又创建 org.apache.catalina.connector. Request 和 org.apache.catalina.connector. Response 对象。这两个对象一直穿越整个 Servlet 容器直到要传给 Servlet，传给 Servlet 的是 Request 和 Response 的门面类 RequestFacade 和 RequestFacade，这里使用门面模式与前面一样都是基于同样的目的——封装容器中的数据。一次请求对应的 Request 和 Response 的类转化如下图所示：
<a href=""><strong>图 8.Request 和 Response 的转变过程</strong></a>
<img src="" alt="图 8.Request 和 Response 的转变过程"></p>
<p><a href="http://www.ibm.com/developerworks/cn/java/j-lo-servlet/#ibm-pcon" target="_blank">回页首</a></p>
<p><a href="">Servlet 如何工作</a></p>
<p>我们已经清楚了 Servlet 是如何被加载的、Servlet 是如何被初始化的，以及 Servlet 的体系结构，现在的问题就是它是如何被调用的。</p>
<p>当用户从浏览器向服务器发起一个请求，通常会包含如下信息：<a href="http://hostname" target="_blank">http://hostname</a>: port /contextpath/servletpath，hostname 和 port 是用来与服务器建立 TCP 连接，而后面的 URL 才是用来选择服务器中那个子容器服务用户的请求。那服务器是如何根据这个 URL 来达到正确的 Servlet 容器中的呢？</p>
<p>Tomcat7.0 中这件事很容易解决，因为这种映射工作有专门一个类来完成的，这个就是 org.apache.tomcat.util.http.mapper，这个类保存了 Tomcat 的 Container 容器中的所有子容器的信息，当 org.apache.catalina.connector. Request 类在进入 Container 容器之前，mapper 将会根据这次请求的 hostnane 和 contextpath 将 host 和 context 容器设置到 Request 的 mappingData 属性中。所以当 Request 进入 Container 容器之前，它要访问那个子容器这时就已经确定了。
<a href=""><strong>图 9.Request 的 Mapper 类关系图</strong></a>
<img src="" alt="图 9.Request 的 Mapper 类关系图"></p>
<p>可能你有疑问，mapper 中怎么会有容器的完整关系，这要回到图 2 中 19 步 MapperListener 类的初始化过程，下面是 MapperListener 的 init 方法代码 :
<a href=""><strong>清单 5. MapperListener.init</strong></a></p>
<p>public void init() {
        findDefaultHost();</p>
<pre><code>    Engine engine = (Engine) connector.getService().getContainer();
    engine.addContainerListener(this);

    Container[] conHosts = engine.findChildren();
    for (Container conHost : conHosts) {

        Host host = (Host) conHost;
        if (!LifecycleState.NEW.equals(host.getState())) {

            host.addLifecycleListener(this);
            registerHost(host);

        }
    }
</code></pre><p>}</p>
<p>这段代码的作用就是将 MapperListener 类作为一个监听者加到整个 Container 容器中的每个子容器中，这样只要任何一个容器发生变化，MapperListener 都将会被通知，相应的保存容器关系的 MapperListener 的 mapper 属性也会修改。for 循环中就是将 host 及下面的子容器注册到 mapper 中。
<a href=""><strong>图 10.Request 在容器中的路由图</strong></a>
<img src="" alt="图 10.Request 在容器中的路由图"></p>
<p>上图描述了一次 Request 请求是如何达到最终的 Wrapper 容器的，我们现正知道了请求是如何达到正确的 Wrapper 容器，但是请求到达最终的 Servlet 还要完成一些步骤，必须要执行 Filter 链，以及要通知你在 web.xml 中定义的 listener。</p>
<p>接下去就要执行 Servlet 的 service 方法了，通常情况下，我们自己定义的 servlet 并不是直接去实现 javax.servlet.servlet 接口，而是去继承更简单的 HttpServlet 类或者 GenericServlet 类，我们可以有选择的覆盖相应方法去实现我们要完成的工作。</p>
<p>Servlet 的确已经能够帮我们完成所有的工作了，但是现在的 web 应用很少有直接将交互全部页面都用 servlet 来实现，而是采用更加高效的 MVC 框架来实现。这些 MVC 框架基本的原理都是将所有的请求都映射到一个 Servlet，然后去实现 service 方法，这个方法也就是 MVC 框架的入口。</p>
<p>当 Servlet 从 Servlet 容器中移除时，也就表明该 Servlet 的生命周期结束了，这时 Servlet 的 destroy 方法将被调用，做一些扫尾工作。</p>
<p><a href="http://www.ibm.com/developerworks/cn/java/j-lo-servlet/#ibm-pcon" target="_blank">回页首</a></p>
<p><a href="">Session 与 Cookie</a></p>
<p>前面我们已经说明了 Servlet 如何被调用，我们基于 Servlet 来构建应用程序，那么我们能从 Servlet 获得哪些数据信息呢？</p>
<p>Servlet 能够给我们提供两部分数据，一个是在 Servlet 初始化时调用 init 方法时设置的 ServletConfig，这个类基本上含有了 Servlet 本身和 Servlet 所运行的 Servlet 容器中的基本信息。根据前面的介绍 ServletConfig 的实际对象是 StandardWrapperFacade，到底能获得哪些容器信息可以看看这类提供了哪些接口。还有一部分数据是由 ServletRequest 类提供，它的实际对象是 RequestFacade，从提供的方法中发现主要是描述这次请求的 HTTP 协议的信息。所以要掌握 Servlet 的工作方式必须要很清楚 HTTP 协议，如果你还不清楚赶紧去找一些参考资料。关于这一块还有一个让很多人迷惑的 Session 与 Cookie。</p>
<p>Session 与 Cookie 不管是对 Java Web 的熟练使用者还是初学者来说都是一个令人头疼的东西。Session 与 Cookie 的作用都是为了保持访问用户与后端服务器的交互状态。它们有各自的优点也有各自的缺陷。然而具有讽刺意味的是它们优点和它们的使用场景又是矛盾的，例如使用 Cookie 来传递信息时，随着 Cookie 个数的增多和访问量的增加，它占用的网络带宽也很大，试想假如 Cookie 占用 200 个字节，如果一天的 PV 有几亿的时候，它要占用多少带宽。所以大访问量的时候希望用 Session，但是 Session 的致命弱点是不容易在多台服务器之间共享，所以这也限制了 Session 的使用。</p>
<p>不管 Session 和 Cookie 有什么不足，我们还是要用它们。下面详细讲一下，Session 如何基于 Cookie 来工作。实际上有三种方式能可以让 Session 正常工作：</p>
<ol>
<li>基于 URL Path Parameter，默认就支持</li>
<li>基于 Cookie，如果你没有修改 Context 容器个 cookies 标识的话，默认也是支持的</li>
<li>基于 SSL，默认不支持，只有 connector.getAttribute(&quot;SSLEnabled&quot;) 为 TRUE 时才支持</li>
</ol>
<p>第一种情况下，当浏览器不支持 Cookie 功能时，浏览器会将用户的 SessionCookieName 重写到用户请求的 URL 参数中，它的传递格式如 /path/Servlet;name=value;name2=value2? Name3=value3，其中“Servlet；”后面的 K-V 对就是要传递的 Path Parameters，服务器会从这个 Path Parameters 中拿到用户配置的 SessionCookieName。关于这个 SessionCookieName，如果你在 web.xml 中配置 session-config 配置项的话，其 cookie-config 下的 name 属性就是这个 SessionCookieName 值，如果你没有配置 session-config 配置项，默认的 SessionCookieName 就是大家熟悉的“JSESSIONID”。接着 Request 根据这个 SessionCookieName 到 Parameters 拿到 Session ID 并设置到 request.setRequestedSessionId 中。</p>
<p>请注意如果客户端也支持 Cookie 的话，Tomcat 仍然会解析 Cookie 中的 Session ID，并会覆盖 URL 中的 Session ID。</p>
<p>如果是第三种情况的话将会根据 javax.servlet.request.ssl_session 属性值设置 Session ID。</p>
<p>有了 Session ID 服务器端就可以创建 HttpSession 对象了，第一次触发是通过 request. getSession() 方法，如果当前的 Session ID 还没有对应的 HttpSession 对象那么就创建一个新的，并将这个对象加到 org.apache.catalina. Manager 的 sessions 容器中保存，Manager 类将管理所有 Session 的生命周期，Session 过期将被回收，服务器关闭，Session 将被序列化到磁盘等。只要这个 HttpSession 对象存在，用户就可以根据 Session ID 来获取到这个对象，也就达到了状态的保持。
<a href=""><strong>图 11.Session 相关类图</strong></a>
<img src="" alt="图 11.Session 相关类图"></p>
<p>上从图中可以看出从 request.getSession 中获取的 HttpSession 对象实际上是 StandardSession 对象的门面对象，这与前面的 Request 和 Servlet 是一样的原理。下图是 Session 工作的时序图：
<a href=""><strong>图 12.Session 工作的时序图（</strong></a><strong><a href="http://www.ibm.com/developerworks/cn/java/j-lo-servlet/image023.jpg" target="_blank">查看大图</a>）</strong>
<img src="" alt="图 12.Session 工作的时序图"></p>
<p>还有一点与 Session 关联的 Cookie 与其它 Cookie 没有什么不同，这个配置的配置可以通过 web.xml 中的 session-config 配置项来指定。</p>
<p><a href="http://www.ibm.com/developerworks/cn/java/j-lo-servlet/#ibm-pcon" target="_blank">回页首</a></p>
<p><a href="">Servlet 中的 Listener</a></p>
<p>整个 Tomcat 服务器中 Listener 使用的非常广泛，它是基于观察者模式设计的，Listener 的设计对开发 Servlet 应用程序提供了一种快捷的手段，能够方便的从另一个纵向维度控制程序和数据。目前 Servlet 中提供了 5 种两类事件的观察者接口，它们分别是：4 个 EventListeners 类型的，ServletContextAttributeListener、ServletRequestAttributeListener、ServletRequestListener、HttpSessionAttributeListener 和 2 个 LifecycleListeners 类型的，ServletContextListener、HttpSessionListener。如下图所示：
<a href=""><strong>图 13.Servlet 中的 Listener（</strong></a><strong><a href="http://www.ibm.com/developerworks/cn/java/j-lo-servlet/image025.png" target="_blank">查看大图</a>）</strong>
<img src="" alt="图 13.Servlet 中的 Listener"></p>
<p>它们基本上涵盖了整个 Servlet 生命周期中，你感兴趣的每种事件。这些 Listener 的实现类可以配置在 web.xml 中的 <listener> 标签中。当然也可以在应用程序中动态添加 Listener，需要注意的是 ServletContextListener 在容器启动之后就不能再添加新的，因为它所监听的事件已经不会再出现。掌握这些 Listener 的使用，能够让我们的程序设计的更加灵活。
来源： <a href="[http://blog.csdn.net/haojun186/article/details/7467100](http://blog.csdn.net/haojun186/article/details/7467100)">[http://blog.csdn.net/haojun186/article/details/7467100](http://blog.csdn.net/haojun186/article/details/7467100)</a> </p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/服务器/">服务器</a></li></span><span class="breadcrumb"><li><a href="/categories/服务器/">服务器</a></li><li><a href="/categories/服务器/tomcat/">tomcat</a></li></span></span> | <span class="tags">Tagged <a href="/tags/tomcat/" class="label label-primary">tomcat</a><a href="/tags/服务器/" class="label label-success">服务器</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:45"datetime="2014-03-07 09:54:45"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-服务器-tomcat--Servlet工作原理/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-服务器-tomcat--Servlet工作原理" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-webservice-CXF--CXF获取客户端IP解决WebServiceContext为null问题/">CXF获取客户端IP(解决WebServiceContext为null问题)</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:45.000Z"> <a href="/2014/02/02/2014-02-02-webservice-CXF--CXF获取客户端IP解决WebServiceContext为null问题/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="cxf-ip-webservicecontext-null-">CXF获取客户端IP(解决WebServiceContext为null问题)</h1>
<p>网络上很多文章都是这样配的：
1</p>
<p>2
3</p>
<p>4
5</p>
<p>6
7</p>
<p>8
 @Resource</p>
<p>private</p>
<p>WebServiceContext wscontext;</p>
<p>public</p>
<p>String getIP(){</p>
<p>MessageContext ctx = wscontext.getMessageContext();</p>
<p>HttpServletRequest request = (HttpServletRequest)ctx.ge(AbstractHTTPDestination.HTTP_REQUEST);</p>
<p>return</p>
<p>request.getRemoteAddr();</p>
<p>}</p>
<p>但是在我测试的过程中，发现如果把这段代码写在aop切点中，wscontext就是null，如果写在普通的实现类，就可以正常获取。其实很多帖子也说到null的问题，但最后都没解决。</p>
<p>现在在<a href="http://www.javatips.net/blog/2012/03/getting-ip-address-using-cxf" target="_blank">这里</a>发现另一种方法，经测试完全有效:
1</p>
<p>2
3 Message message = PhaseInterceptorChain.getCurrentMessage();</p>
<p>HttpServletRequest httprequest = (HttpServletRequest)message.get(AbstractHTTPDestination.HTTP_REQUEST);
return</p>
<p>httprequest.getRemoteAddr();
来源： <a href="[https://linchunyu.info/81/cxf_fetch_request_ip.html](https://linchunyu.info/81/cxf_fetch_request_ip.html)">[https://linchunyu.info/81/cxf_fetch_request_ip.html](https://linchunyu.info/81/cxf_fetch_request_ip.html)</a> </p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/webservice/">webservice</a></li></span><span class="breadcrumb"><li><a href="/categories/webservice/">webservice</a></li><li><a href="/categories/webservice/CXF/">CXF</a></li></span></span> | <span class="tags">Tagged <a href="/tags/CXF/" class="label label-primary">CXF</a><a href="/tags/webservice/" class="label label-success">webservice</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:45"datetime="2014-03-07 09:54:45"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-webservice-CXF--CXF获取客户端IP解决WebServiceContext为null问题/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-webservice-CXF--CXF获取客户端IP解决WebServiceContext为null问题" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-webservice--Webservicesoapwsdl区别之个人见解/">Webservice soap wsdl区别之个人见解</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:45.000Z"> <a href="/2014/02/02/2014-02-02-webservice--Webservicesoapwsdl区别之个人见解/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="webservice-soap-wsdl-">Webservice soap wsdl区别之个人见解</h1>
<p><img src="" alt=""><img src="" alt=""> <img src="" alt=""> <a href="http://www.wudongqi.com/blogedit.asp?id=652" title="编辑该日志" target="_blank"><img src="" alt=""></a> <a href="http://www.wudongqi.com/blogedit.asp?action=del&amp;id=652" target="_blank"><img src="" alt=""></a>
    ● Web Service实现业务诉求：Web Service是真正“办事”的那个，提供一种办事接口的统称。
    ● WSDL提供“能办的事的文档说明”：对要提供的服务的一种描述格式。我想帮你的忙，但是我要告诉你我都能干什么，以及干这些事情需要的参数类型。
    ● SOAP提供“请求”的规范：向服务接口传递请求的格式，包括方法和参数等。你想让人家办事，总得告诉人家你想干什么吧，SOAP就是定义这个“请求”的格式的，按照SOAP定义的“请求”格式“书写”请求就可以保证Web Service能够正确的解读你想让它干什么以及你为它提供了什么参数。在这个请求中，你需要描述的主要问题有：向哪个Web Service发送请求，请求的参数类型、参数值、返回值类型。这些都“填写”完毕，也就完成了符合SOAP规范的SOAP消息。
    wsdl和soap虽然是web service的两大标准，但是两者并没有必然的联系，都可以独立使用。
    wsdl提供了一个统一的接口，目前已经成为一个国际上公认的标准，通过wsdl提供的接口可以访问不同类型的资源（如java、c/#、C、C、C++等），因为wsdl是基于xml，与语言平台无关的。另外wsdl提供了binding和service元素，用以绑定接口到具体的服务，实现了接口与实现的分离。
    soap（简单对象访问协议）是一种基于http的传输协议，用来访问远程服务
    wsdl与soap的关系在于：wsdl绑定服务的时候可以设定使用的协议，协议可以是soap、http、smtp、ftp等任何一种传输协议，除此以外wsdl还可以绑定jms、ejb及local java等等，不过都是需要对binding和service元素做扩展的，而且需要扩展服务器的功能以支持这种扩展
    soap协议是一种请求和应答协议规范，而http是web传输协议，soap的传输是可以基于http的，但也可以基于其他的传输协议，如ftp、smtp等。
    简单对象访问协议（SOAP）是W3C组织的一个Note, 它描述了一种在分散的或分布式的环境中如何交换信息的轻量级协议。SOAP是一个基于XML的协议，它包括三个部分：SOAP封装(Envelop)，封装定义了一个描述消息中的内容是什么，是谁发送的，谁应当接受并处理它以及如何处理它们的框架；SOAP编码规则（Encoding Rules），用于表示应用程序需要使用的数据类型的实例；SOAP RPC表示(RPC Representation)，表示远程过程调用和应答的协定；SOAP可以和多种传输协议绑定（Binding），使用底层协议交换信息。在这个文档中，目前只定义了SOAP如何和HTTP以及HTTP扩展进行绑定的框架。
    SOAP是个通信协议， SOAP在HTTP协议的基础上，把编写成XML的REQUEST参数, 放在HTTP BODY上提交个WEB SERVICE服务器(SERVLET，ASP什么的) 处理完成后，结果也写成XML作为RESPONSE送回用户端， 为了使用户端和WEB SERVICE可以相互对应，可以使用WSDL作为这种通信方式的描述文件，利用WSDL工具可以自动生成WS和用户端的框架文件，SOAP具备把复杂对象序列化捆绑到XML里去的能力。
    SOAP的前身是RPC, 就是远程呼叫处理的协议，这个协议安全性不是很好，多数防火墙都会阻挡RPC的通信包，而SOAP则使用HTTP协议作为基本的协议，使用端口80使得SOAP可以透过防火墙，完成RPC的功能。
    SOAP协议和HTTP协议一样，都是底层的通信协议，只是请求包的格式不同而已，SOAP包是XML格式的，现在我们编写WEB SERVICE不需要深入理解SOAP也没关系。如果SERVICE和CLIENT在同样的环境下使用SOAP，由于一般情况下都有自动生成SOAP程序框架的工具，因此不知道细节也没关系. 可是, 如果CLIENT和SERVICE的环境不同，比如说JAVA的Client和.NET的SERVICE进行通信，或者是VB CLIENT和TOMCAT下的JAVA SERVICE通信，还是要知道一点细节为好. 特别是, WSDL或者UDDI都不是标准，如果不让用就只好手工配制SOAP MESSAGE啦。</p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/webservice/">webservice</a></li></span></span> | <span class="tags">Tagged <a href="/tags/webservice/" class="label label-primary">webservice</a></span> | <span class="time">recent updated:<time title="2014-03-07 10:27:47"datetime="2014-03-07 10:27:47"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-webservice--Webservicesoapwsdl区别之个人见解/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-webservice--Webservicesoapwsdl区别之个人见解" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>





<ul id="pagination" class="pagination pagination-lg">
  <li><a class="extend prev" href="/page/6/">&laquo;</a></li><li><a class="page-number" href="/">1</a></li><li><a class="page-number" href="/page/2/">2</a></li><li><span class="space">&hellip;</span></li><li><a class="page-number" href="/page/4/">4</a></li><li><a class="page-number" href="/page/5/">5</a></li><li><a class="page-number" href="/page/6/">6</a></li><li class="active"><li><span class="page-number current">7</span></li><li><a class="page-number" href="/page/8/">8</a></li><li><a class="page-number" href="/page/9/">9</a></li><li><a class="page-number" href="/page/10/">10</a></li><li><span class="space">&hellip;</span></li></li><li><a class="page-number" href="/page/164/">164</a></li><li><a class="page-number" href="/page/165/">165</a></li><li><a class="extend next" href="/page/8/">&raquo;</a></li>
  <div class="clearfix"></div>
</ul></div><!--wapper-->
       </div><!-- ID main-col END -->
       <aside id="sidebar" class="alignright col-sx-6 col-sm-4 col-md-3 col-lg-3">
<div id="widget_search" class="widget panel panel-primary">
    <form action="//google.com/search" method="get" accept-charset="utf-8">
  <div class="input-group">
    <input class="form-control" id="searchbox" type="search" name="q" results="0" placeholder="search">
    <span class="input-group-btn">
      <button class="btn btn-default" type="submit">Go!</button>
    </span>
    <input type="hidden" name="q" value="site:itsolife.com">
  </div>
</form>
</div>

<div id="widget_category" class="widget panel panel-primary">
  <div class="panel-heading">category</div>  <div data-src='category' class='ajax_widgets'>正在加载...</div>
</div>

<div id="widget_recent_posts" class="widget panel panel-primary">
  <div class="panel-heading">recent posts</div>  <div data-src='recent_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_tagcloud" class="widget panel panel-primary">
  <div class="panel-heading">tagcloud</div>  <div data-src='tagcloud' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_latest_update_posts" class="widget panel panel-primary">
  <div class="panel-heading">最近更新</div>  <div data-src='latest_update_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_recent_comments" class="widget panel panel-primary">
  <div class="panel-heading">recent comments</div>  

<div class="list-group-item ds-recent-comments" data-num-items="6" data-show-avatars="1" data-show-time="1" data-show-title="1" data-show-admin="1" data-excerpt-length="50"></div>



</div>

</aside>
       <div class="clearfix"></div>
     </div><!-- row END -->
  </div>
  <footer id="footer" class="container">
  <div class="panel panel-info">
  <section id='footer_widget'></section>  <div class="panel-footer">
  <div id="site-info">
    <span class='author'>
  
  &copy; 2014 RobinChia
  
    &nbsp;&nbsp;</span>
  
  <span id='analytics-51la'></span><span id='analytics-google'>
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-48559895-1']);
  _gaq.push(['_trackPageview']);
  _js2load.push({src:('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'});
</script></span><span id='analytics-cnzz'>
<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_5774006'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s17.cnzz.com/stat.php%3Fid%3D5774006%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>
</span><span id='analytics-baidu'>
<script>
var _hmt = _hmt || [];
_js2load.push({src:"//hm.baidu.com/hm.js?1442f50724afc42380b51f097c43082c"});
</script>
</span>  </div>
  <div id="copyright">Blog powered by <a href='http://zespia.tw/hexo/'><strong>hexo</strong></a> Theme <strong><a href='https://github.com/chenall/hexo-theme-chenall'>chenall</a></strong>(Some change in it)<span class="pull-right"> 更新时间: <em>2014-03-23 21:54:37</em></span></div>
</div>
<div class="clearfix"></div>


  </div>
  </footer>
  
        <script src="http://cdn.bootcss.com/jquery/1.10.2/jquery.min.js"></script>        
        <script src="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/js/bootstrap.min.js"></script>        
                
        <script src="http://cdn.bootcss.com/prettify/r298/prettify.min.js"></script>    <script type="text/javascript">
   var lang=["bsh", "c", "cc", "cpp", "cs", "csh", "cyc", "cv", "htm", "html",
    "java", "js", "m", "mxml", "perl", "pl", "pm", "py", "rb", "sh",
    "xhtml", "xml", "xsl"];
   var pretty_base='';
   $('script').each(function(){
	var c = $(this).attr('src');
	if (!c)
	    return;
	if (c.match(/(\/)?prettify(\.min)?\.js/i))
	{
	    var index = c.lastIndexOf('/');
	    if (index != -1)
		pretty_base = c.substr(0,index + 1);
	    return false;
	}
   })
   $('pre code').each(function(){
	var c = $(this).attr('class')
	if (!c)
	    return;
	c = c.match(/\s?(lang\-\w+)/i);
	if (c && lang.indexOf(c[1]) == -1)
	{
	    lang.push(c[1]);
	    $.getScript(pretty_base + c[1] + '.min.js');
	}
   })

    $(window).load(function(){
       $("pre").addClass("prettyprint");
       prettyPrint();
    })
</script>    
            <script type="text/javascript">
var duoshuoQuery = {short_name:"robinchia"};
_js2load.push({src:'http://static.duoshuo.com/embed.js',charset:'UTF-8'});
</script>
    
            <!--wumii_relatedItems-->
    
        <script src="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js"></script>    <script type="text/javascript">
(function($){
  $('.entry').each(function(i){
    $(this).find('img').each(function(){
      var alt = this.alt;

      if (alt){
        $(this).before('<span class="caption">' + alt + '</span>');
      }

      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox" rel="fancybox' + i + '" />');
    });
  });

  $('.fancybox').fancybox();
})(jQuery);
</script>    
        <script src="http://cdn.bootcss.com/mathjax/2.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>    <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>
    
<script type="text/javascript">
$('.ajax_widgets').each(function(){var src=$(this).attr('data-src');if(src)$(this).load('/widgets/'+src+'.html');});
$.each(_js2load,function(index,obj){loadjs(obj.src,obj.charset)});
</script>

<div id="scroll2top">
<img src="/scroll2top/arrow.png"/>
</div>
<script src="/scroll2top/scroll2top.min.js"></script>
<div id="winterland">
  <canvas></canvas>
</div>
<script src="/js/winterland.min.js"></script>

  </body>
</html>
