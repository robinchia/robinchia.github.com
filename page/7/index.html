
<!DOCTYPE HTML>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>The 7 Page | It so life</title>
<meta name="author" content="RobinChia">

<meta name="description" content="It so life">


<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<meta property="og:site_name" content="It so life"/>

<!--[if IE]><style>.testIE.IE{display:inline;}</style><![endif]-->
<!--[if lte IE 7]><link rel="stylesheet" href="/css/ie7.css" type="text/css"><![endif]-->
<!--[if (lt IE 9)&(gt IE 7)]><style>.testIE.IE8{display:inline;}</style><![endif]-->
<!--[if gt IE 8]><style>.testIE.IE9{display:inline;}</style><![endif]-->

<link href="/favicon.png" rel="icon">
<link rel="alternate" href="/atom.xml" title="It so life Feed" type="application/atom+xml">

<link rel="stylesheet" href="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/css/bootstrap.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/font-awesome/4.0.3/css/font-awesome.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/prettify/r298/prettify.min.css" type="text/css">
<link rel="stylesheet" href="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" type="text/css">
<link rel="stylesheet" href="/css/style.css" type="text/css">
<!--[if lt IE 9]>
   <style>article,aside,dialog,footer,header,section,footer,nav,figure,menu{display:block}</style>
   <script src="http://cdn.staticfile.org/html5shiv/r29/html5.min.js"></script>
   <script src="http://cdn.staticfile.org/respond.js/1.4.2/respond.min.js"></script>
<link href="http://cdn.staticfile.org/respond.js/1.4.2/respond-proxy.html" id="respond-proxy" rel="respond-proxy" />
<link href="/js/respond.proxy.gif" id="respond-redirect" rel="respond-redirect" />
<script src="/js/respond.proxy.js"></script>
   <script src="http://cdn.bootcss.com/selectivizr/1.0.2/selectivizr-min.js"></script>
<![endif]-->
<script type="text/javascript">
function loadjs(c,d){var a=document.createElement("script");a.async=!0;a.type="text/javascript";a.src=c;a.charset=d||"gbk";(document.getElementsByTagName("HEAD")[0]||document.getElementsByTagName("BODY")[0]).appendChild(a)};
var _protocol = (("https:" == document.location.protocol) ? " https://" : " http://");
var _js2load = [];
</script>

</head>
<body>
      <header id="header" class="container"><nav id="main-nav" class="navbar navbar-default navbar-fixed-top " role="navigation">
  <div class="container">
    <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
      <span class="sr-only">Toggle navigation</span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="/">It so life</a>
    </div>
    <div  class="collapse navbar-collapse">
      <ul  class="nav navbar-nav">
  
        <li><a href="/" title="Home">Home</a></li>      
        <li><a href="/about/" title="About">About</a></li>      
        <li><a href="/archives/" title="Archives">Archives</a></li>      
      <li class='dropdown'>
        <a class='dropdown-toggle' data-toggle='dropdown' href='#'>website<b class='caret'></b></a>
        <ul class='dropdown-menu pure-menu-selected'>
    
          <li><a href="//groups.google.com/forum/#!forum/pongba" title="TopLanguage">TopLanguage</a></li>    
          <li><a href="//itpub.net/" title="ITPub">ITPub</a></li>    
          <li><a href="//blog.jobbole.com/" title="Bole">Bole</a></li>    
          <li><a href="//nosql-database.org/" title="nosql">nosql</a></li>    
          <li><a href="//gitimmersion.googol.im/" title="Git">Git</a></li>    
        </ul>
      </li>
    
      </ul>
      <ul class="nav navbar-nav navbar-right">
      
        <li><a href="/atom.xml">RSS</a></li>
      
      
        <li><a href="https://twitter.com/robinchia">twitter</a></li>
      
      
      
      
        <li><a href="https://github.com/robinchia">github</a></li>
      
      </ul>
    </div>
  </div>
</nav>
<div class="clearfix"></div>
</header>
  <div id='content' class="container">
     <div class="page-header-wrapper">
      <!--[if lt IE 9]><div class="alert alert-warning alert-dismissable"><button type="button" class="close" data-dismiss="alert" aria-hidden="true">&times;</button><strong>提示:</strong>您的浏览器版本太低了,建议升级到 <strong><a href="http://windows.microsoft.com/zh-cn/internet-explorer/download-ie" title="IE9">IE9</a></strong> 以上,本站使用<a href="https://www.google.com/intl/zh-CN/chrome/">Chrome浏览器</a>可以获得最好的显示效果.</div><![endif]-->
      <div class="page-header"><h1 align="center"><big>It so life</big> </h1>
        <h5 align="center"><big>love as life</big></h5>
      </div>
     </div>
     <div class="row">
       <div id="main-col" class="alignleft col-sx-12 col-sm-8 col-md-9 col-lg-9">
      <section id='header_widget'></section>
          <div id="wrapper"><article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-服务器-tomcat--Tomcat工作原理2/">Tomcat工作原理2</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:45.000Z"> <a href="/2014/02/02/2014-02-02-服务器-tomcat--Tomcat工作原理2/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="tomcat-2">Tomcat工作原理2</h1>
<p><a href="http://blog.csdn.net/haojun186/article/details/7467112" target="_blank">Tomcat工作原理2</a></p>
<p><a href="">门面设计模式</a></p>
<p>门面设计模式在 Tomcat 中有多处使用，在 Request 和 Response 对象封装中、Standard Wrapper 到 ServletConfig 封装中、ApplicationContext 到 ServletContext 封装中等都用到了这种设计模式。</p>
<p><a href="">门面设计模式的原理</a></p>
<p>这么多场合都用到了这种设计模式，那这种设计模式究竟能有什么作用呢？顾名思义，就是将一个东西封装成一个门面好与人家更容易进行交流，就像一个国家的外交部一样。</p>
<p>这种设计模式主要用在一个大的系统中有多个子系统组成时，这多个子系统肯定要涉及到相互通信，但是每个子系统又不能将自己的内部数据过多的暴露给其它系统，不然就没有必要划分子系统了。每个子系统都会设计一个门面，把别的系统感兴趣的数据封装起来，通过这个门面来进行访问。这就是门面设计模式存在的意义。</p>
<p>门面设计模式示意图如下：
<a href=""><strong>图 1. 门面示意图</strong></a>
<img src="" alt="图 1. 门面示意图"></p>
<p>Client 只能访问到 Façade 中提供的数据是门面设计模式的关键，至于 Client 如何访问 Façade 和 Subsystem 如何提供 Façade 门面设计模式并没有规定死。</p>
<p><a href="">Tomcat 的门面设计模式示例</a></p>
<p>Tomcat 中门面设计模式使用的很多，因为 Tomcat 中有很多不同组件，每个组件要相互交互数据，用门面模式隔离数据是个很好的方法。</p>
<p>下面是 Request 上使用的门面设计模式：
<a href=""><strong>图 2. Request 的门面设计模式类图</strong></a>
<img src="" alt="图 2. Request 的门面设计模式类图"></p>
<p>从图中可以看出 HttpRequestFacade 类封装了 HttpRequest 接口能够提供数据，通过 HttpRequestFacade 访问到的数据都被代理到 HttpRequest 中，通常被封装的对象都被设为 Private 或者 Protected 访问修饰，以防止在 Façade 中被直接访问。</p>
<p><a href="http://www.ibm.com/developerworks/cn/java/j-lo-tomcat2/#ibm-pcon" target="_blank">回页首</a></p>
<p><a href="">观察者设计模式</a></p>
<p>这种设计模式也是常用的设计方法通常也叫发布 - 订阅模式，也就是事件监听机制，通常在某个事件发生的前后会触发一些操作。</p>
<p><a href="">观察者模式的原理</a></p>
<p>观察者模式原理也很简单，就是你在做事的时候旁边总有一个人在盯着你，当你做的事情是它感兴趣的时候，它就会跟着做另外一些事情。但是盯着你的人必须要到你那去登记，不然你无法通知它。观察者模式通常包含下面这几个角色：</p>
<ul>
<li>Subject 就是抽象主题：它负责管理所有观察者的引用，同时定义主要的事件操作。</li>
<li>ConcreteSubject 具体主题：它实现了抽象主题的所有定义的接口，当自己发生变化时，会通知所有观察者。</li>
<li>Observer 观察者：监听主题发生变化相应的操作接口。</li>
</ul>
<p><a href="">Tomcat 的观察者模式示例</a></p>
<p>Tomcat 中观察者模式也有多处使用，前面讲的控制组件生命周期的 Lifecycle 就是这种模式的体现，还有对 Servlet 实例的创建、Session 的管理、Container 等都是同样的原理。下面主要看一下 Lifecycle 的具体实现。</p>
<p>Lifecycle 的观察者模式结构图：
<a href=""><strong>图 3. Lifecycle 的观察者模式结构图</strong></a>
<img src="" alt="图 3. Lifecycle 的观察者模式结构图"></p>
<p>上面的结构图中，LifecycleListener 代表的是抽象观察者，它定义一个 lifecycleEvent 方法，这个方法就是当主题变化时要执行的方法。 ServerLifecycleListener 代表的是具体的观察者，它实现了 LifecycleListener 接口的方法，就是这个具体的观察者具体的实现方式。Lifecycle 接口代表的是抽象主题，它定义了管理观察者的方法和它要所做的其它方法。而 StandardServer 代表的是具体主题，它实现了抽象主题的所有方法。这里 Tomcat 对观察者做了扩展，增加了另外两个类：LifecycleSupport、LifecycleEvent，它们作为辅助类扩展了观察者的功能。LifecycleEvent 使得可以定义事件类别，不同的事件可区别处理，更加灵活。LifecycleSupport 类代理了主题对多观察者的管理，将这个管理抽出来统一实现，以后如果修改只要修改 LifecycleSupport 类就可以了，不需要去修改所有具体主题，因为所有具体主题的对观察者的操作都被代理给 LifecycleSupport 类了。这可以认为是观察者模式的改进版。</p>
<p>LifecycleSupport 调用观察者的方法代码如下：
<a href=""><strong>清单 1. LifecycleSupport 中的 fireLifecycleEvent 方法</strong></a></p>
<p>public void fireLifecycleEvent(String type, Object data) {
    LifecycleEvent event = new LifecycleEvent(lifecycle, type, data);</p>
<pre><code>LifecycleListener interested[] = null;
synchronized (listeners) {

    interested = (LifecycleListener[]) listeners.clone();
}

for (int i = 0; i &lt; interested.length; i++)
    interested[i].lifecycleEvent(event);
</code></pre><p>}</p>
<p>主题是怎么通知观察者呢？看下面代码：
<a href=""><strong>清单 2. 容器中的 start 方法</strong></a></p>
<p>public void start() throws LifecycleException {
    lifecycle.fireLifecycleEvent(BEFORE_START_EVENT, null);</p>
<pre><code>lifecycle.fireLifecycleEvent(START_EVENT, null);
started = true;

synchronized (services) {
    for (int i = 0; i &lt; services.length; i++) {

        if (services[i] instanceof Lifecycle)
            ((Lifecycle) services[i]).start();

        }
    }

lifecycle.fireLifecycleEvent(AFTER_START_EVENT, null);
</code></pre><p>}</p>
<p><a href="http://www.ibm.com/developerworks/cn/java/j-lo-tomcat2/#ibm-pcon" target="_blank">回页首</a></p>
<p><a href="">命令设计模式</a></p>
<p>前面把 Tomcat 中两个核心组件 Connector 和 Container，比作一对夫妻。男的将接受过来的请求以命令的方式交给女主人。对应到 Connector 和 Container，Connector 也是通过命令模式调用 Container 的。</p>
<p><a href="">命令模式的原理</a></p>
<p>命令模式主要作用就是封装命令，把发出命令的责任和执行命令的责任分开。也是一种功能的分工。不同的模块可以对同一个命令做出不同解释。</p>
<p>下面是命令模式通常包含下面几个角色：</p>
<ul>
<li>Client：创建一个命令，并决定接受者</li>
<li>Command 命令：命令接口定义一个抽象方法</li>
<li>ConcreteCommand：具体命令，负责调用接受者的相应操作</li>
<li>Invoker 请求者：负责调用命令对象执行请求</li>
<li>Receiver 接受者：负责具体实施和执行一次请求</li>
</ul>
<p><a href="">Tomcat 中的命令模式的示例</a></p>
<p>Tomcat 中命令模式在 Connector 和 Container 组件之间有体现，Tomcat 作为一个应用服务器，无疑会接受到很多请求，如何分配和执行这些请求是必须的功能。</p>
<p>下面看一下 Tomcat 是如何实现命令模式的，下面是 Tomcat 命令模式的结构图：
<a href=""><strong>图 4. Tomcat 命令模式的结构图</strong></a>
<img src="" alt="图 4. Tomcat 命令模式的结构图"></p>
<p>Connector 作为抽象请求者，HttpConnector 作为具体请求者。HttpProcessor 作为命令。Container 作为命令的抽象接受者，ContainerBase 作为具体的接受者。客户端就是应用服务器 Server 组件了。Server 首先创建命令请求者 HttpConnector 对象，然后创建命令 HttpProcessor 命令对象。再把命令对象交给命令接受者 ContainerBase 容器来处理命令。命令的最终是被 Tomcat 的 Container 执行的。命令可以以队列的方式进来，Container 也可以以不同的方式来处理请求，如 HTTP1.0 协议和 HTTP1.1 的处理方式就会不同。</p>
<p><a href="http://www.ibm.com/developerworks/cn/java/j-lo-tomcat2/#ibm-pcon" target="_blank">回页首</a></p>
<p><a href="">责任链模式</a></p>
<p>Tomcat 中一个最容易发现的设计模式就是责任链模式，这个设计模式也是 Tomcat 中 Container 设计的基础，整个容器的就是通过一个链连接在一起，这个链一直将请求正确的传递给最终处理请求的那个 Servlet。</p>
<p><a href="">责任链模式的原理</a></p>
<p>责任链模式，就是很多对象有每个对象对其下家的引用而连接起来形成一条链，请求在这条链上传递，直到链上的某个对象处理此请求，或者每个对象都可以处理请求，并传给下一家，直到最终链上每个对象都处理完。这样可以不影响客户端而能够在链上增加任意的处理节点。</p>
<p>通常责任链模式包含下面几个角色：</p>
<ul>
<li>Handler（抽象处理者）：定义一个处理请求的接口</li>
<li>ConcreteHandler（具体处理者）：处理请求的具体类，或者传给下家</li>
</ul>
<p><a href="">Tomcat 中责任链模式示例</a></p>
<p>在 tomcat 中这种设计模式几乎被完整的使用，tomcat 的容器设置就是责任链模式，从 Engine 到 Host 再到 Context 一直到 Wrapper 都是通过一个链传递请求。</p>
<p>Tomcat 中责任链模式的类结构图如下：
<a href=""><strong>图 5. Tomcat 责任链模式的结构图</strong></a>
<img src="" alt="图 5. Tomcat 责任链模式的结构图"></p>
<p>上图基本描述了四个子容器使用责任链模式的类结构图，对应的责任链模式的角色，Container 扮演抽象处理者角色，具体处理者由 StandardEngine 等子容器扮演。与标准的责任链不同的是，这里引入了 Pipeline 和 Valve 接口。他们有什么作用呢？</p>
<p>实际上 Pipeline 和 Valve 是扩展了这个链的功能，使得在链往下传递过程中，能够接受外界的干预。Pipeline 就是连接每个子容器的管子，里面传递的 Request 和 Response 对象好比管子里流的水，而 Valve 就是这个管子上开的一个个小口子，让你有机会能够接触到里面的水，做一些额外的事情。</p>
<p>为了防止水被引出来而不能流到下一个容器中，每一段管子最后总有一个节点保证它一定能流到下一个子容器，所以每个容器都有一个 StandardXXXValve。只要涉及到这种有链式是处理流程这是一个非常值得借鉴的模式。
来源： <a href="[http://blog.csdn.net/haojun186/article/details/7467112](http://blog.csdn.net/haojun186/article/details/7467112)">[http://blog.csdn.net/haojun186/article/details/7467112](http://blog.csdn.net/haojun186/article/details/7467112)</a> </p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/服务器/">服务器</a></li></span><span class="breadcrumb"><li><a href="/categories/服务器/">服务器</a></li><li><a href="/categories/服务器/tomcat/">tomcat</a></li></span></span> | <span class="tags">Tagged <a href="/tags/tomcat/" class="label label-primary">tomcat</a><a href="/tags/服务器/" class="label label-success">服务器</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:45"datetime="2014-03-07 09:54:45"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-服务器-tomcat--Tomcat工作原理2/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-服务器-tomcat--Tomcat工作原理2" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-服务器-tomcat--tomcat详解/">tomcat详解</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:45.000Z"> <a href="/2014/02/02/2014-02-02-服务器-tomcat--tomcat详解/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="tomcat-">tomcat详解</h1>
<p><strong>一、Tomcat简介</strong></p>
<hr>
<p><strong>1、Tomcat</strong></p>
<p>Tomcat在严格意义上并不是一个真正的应用服务器，它只是一个可以支持运行Serlvet/JSP的Web容器，不过Tomcat也扩展了一些应用服务器的功能，如JNDI，数据库连接池，用户事务处理等等。Tomcat是Apache组织下Jakarta项目下的一个子项目，目前Tomcat被非常广泛的应用在中小规模的Java Web应用中。</p>
<p>Tomcat 是一种具有JSP环境的Servlet容器。Servlet容器是代替用户管理和调用 Servlet的运行时外壳。作为一个开放源代码的软件， Jakarta -Tomcat有着自己独特的优势：</p>
<p>l         首先，它容易得到。事实上，任何人都可以从互联网上自由地下载这个软件。无论从<a href="http://jakarta.Apache.org还是从其他网站（Jakarta" target="_blank">http://jakarta.Apache.org还是从其他网站（Jakarta</a> Tomcat是Apache软件基金会开发的一个开放源码的应用服务器）。</p>
<p>l         其次，对于开发人员，特别是Java开发人员，Tomcat提供了全部的源代码，包括Servlet引擎、JSP引擎、HTTP服务器。无论是对哪一方面感兴趣的程序员，都可以从这些由世界顶尖的程序员书写的代码中获得收益。</p>
<p>l         最后，由于源代码的开放及世界上许多程序员的卓有成效的工作， Tomcat已经可以和大部分的主流服务器一起工作，而且是以相当高的效率一起工作。如：以模块的形式被载入Apache，以ISAPI形式被载入IIS或PWS，以NSAPI的形式被载入Netscape Enterprise Server。</p>
<p>l         由于Java的跨平台特性，基于Java的Tomcat也具有跨平台性。</p>
<hr>
<hr>
<p><strong>2、Tomcat5.0包含三个主要的部分</strong></p>
<p>包括：
/<em> Catalina - 一个符合Servlet API规范2.3的Servlet Container
/</em> Jasper - 一个符合JSP规范1.2的JSP编译器和运行环境
/* Webapps - Tomcat中包含的一些例子和用于测试的web例程，以及相关文档。</p>
<hr>
<hr>
<p><strong>3、应用服务器（如WebLogic）与Tomcat有何区别。</strong></p>
<pre><code>   应用服务器提供更多的J2EE特征，如EJB，JMS，JAAS等，同时也支持Jsp和Servlet。而Tomcat则功能没有那么强大，它不提供EJB等支持。但如果与JBoss（一个开源的应用服务器）集成到一块，则可以实现J2EE的全部功能。
</code></pre><hr>
<hr>
<p><strong>4、Tomcat 目录的结构</strong></p>
<hr>
<p><strong>（1）Tomcat的安装</strong></p>
<hr>
<pre><code>其实对于完全由Java写成的Tomcat，Win32版本和Linux版本没有多大区别，比如Linux版本，在Solaris下也没有问题。这里，主要以Win32版本作为示例。
</code></pre><p>注意：在安装使用Tomcat之前，先安装JDK，最好是Sun的JDK 1 .2 以上版。</p>
<hr>
<p><strong>（2）Tomcat的目录结构</strong></p>
<p>首先，下载jakarta-tomcat.zip包，解压缩到一个目录下，如：“c:/tomcat”。这时，会得到如下的Tomcat的目录结构：</p>
<ul>
<li><ul>
<li><ul>
<li>jakarta - tomcat</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>| - - - bin             Tomcat执行脚本目录</p>
<p>| - - - Common          放置一些通用类（如JDBC的驱动程序等）</p>
<p>| - - - conf               Tomcat配置文件</p>
<p>| - - - doc                 Tomcat文档</p>
<p>| - - - lib                 Tomcat运行需要的库文件（JARS）</p>
<p>| - - - logs               Tomcat执行时的LOG文件</p>
<p>| - - - src            Tomcat的源代码</p>
<p>| - - - webapps             Tomcat的主要Web发布目录（存放我们自己的JSP,SERVLET,类）</p>
<p>| - - - work            Tomcat的工作目录，Tomcat将翻译JSP文件到的Java文件和class文件放在这里。
<strong>目 录 名</strong></p>
<p><strong>该目录内的文件的一般功能描述</strong>bin</p>
<p>包含有Startup.bat（启动服务器）与shutdown.bat（关闭服务器）文件conf</p>
<p>包含设置部署在Tomcat上的Web应用的变量的初始值的设置文件，包括 <em>server.xml</em> (Tomcat的全局配置文件) 和 <em>web.xml</em> （为不同的Tomcat配置的web应用设置缺省值的文件）doc</p>
<p>包含关于Tomcat的各种各样的文档。common</p>
<p>在其lib目录下，主要存放如JDBC的驱动程序等lib</p>
<p>包含被Tomcat使用的各种各样的jar文件。在UNIX上，任何这个目录中的文件将被附加到Tomcat的classpath中。logs</p>
<p>Tomcat的log文件。src</p>
<p>servlet API的源文件。webapps</p>
<p>包含Web应用的程序 （JSP、Servlet和JavaBean等）work</p>
<p>由Tomcat自动生成，这是Tomcat放置它运行期间的中间(intermediate)文件(诸如编译的JSP文件)地方。 如果当Tomcat运行时，你删除了这个目录那么将不能够执行包含JSP的页面。</p>
<hr>
<p><strong>（3）、各个目录下所应该存放的文件：</strong>按照Tomcat的规范，Tomcat的Web应用程序应该由如下目录组成</p>
<pre><code>     页面内容等文件的存放位置：/*.html, /*.jsp等可以有许多目录层次，由用户的网站结构而定，实现的功能应该是网站的界面，也就是用户主要的可见部分。除了HTML文件、JSP文件外，还有js（JavaScript）文件和css（样式表）文件以及其他多媒体文件等。



     Web-INF/web.xml这是一个Web应用程序的描述文件。这个文件是一个XML文件，描述了Servlet和这个Web应用程序的其他组件信息，此外还包括一些初始化信息和安全约束等等。



    Web-INF/classes/这个目录及其下的子目录应该包括这个Web应用程序的所有JavaBean及Servlet等编译好的Java类文件（/*.class）文件，以及没有被压缩打入JAR包的其他class文件和相关资源。注意，在这个目录下的Java类应该按照其所属的包层次组织目录（即如果该/*.class文件具有包的定义，则该/*.class文件应该放在./WEB-INF/classes/包名下）。









    通常Web-INF/classes/这个目录下的类文件也可以打包成JAR文件,并可以放到WEB-INF下的lib目录下。如将 classes目录下的各个/*.class文件打包成WebMis.jar文件（jar cvf WebMis.jar /*./*）
</code></pre><p><strong>注意：</strong></p>
<p>（1）WEB-INF目录中包含应用软件所使用的资源，但是WEB-INF却不在公共文档根目录之中。在这个目录中所包含的文件都不能被客户机所访问。</p>
<p>（2）类目录中（在WEB-INF下）包含运行Web应用程序时所需的Servlets，Beans等类。</p>
<p>（3）lib目录（在WEB-INF下）包含有Java archive files (JARs)，例如标签库或者Servlets，Beans等类的/*.jar文件。</p>
<p>（4）如果一个类出现在JAR文件中同时也出现在类的目录中，类加载器会加载位于类目录中的那一个。</p>
<pre><code>     common/lib/ 这个目录下包含了所有压缩到JAR文件中的类文件和相关文件。比如：第三方提供的Java库文件、JDBC驱动程序等。

     其中msbase.jar、mssqlserver.jar、msutil.jar文件为SqlServer2000的JDBC驱动程序

     其中servlet-api.jar和jsp-api.jar为Servlet和JSP的API所在的包
</code></pre><p><strong>二、Tomcat的环境配置</strong></p>
<hr>
<hr>
<p><strong>1、启动Tomcat</strong></p>
<p>在Bin目录下，有一个名为startup.bat的脚本文件，执行这个脚本文件，就可以启动Tomcat服务器，不过，在启动服务器之前，还需要进行一些设置。</p>
<p>l         <strong>首先，设置系统的环境变量。</strong></p>
<pre><code>     **TOMCAT_HOME（或者：CATALINA_HOME）值：**
</code></pre><p>d:/jakarta-tomcat-5.0.16 (用TOMCAT_HOME指示Tomcat根目录，下面以Tomcat 5.0.16版为例)。</p>
<pre><code>     **JAVA_HOME值：**
</code></pre><p>c:/j2sdk1.4.0(用JAVA_HOME指示jdk1.4的安装目录)。</p>
<p><strong>注意</strong>：对于设置Windows的系统环境变量，可以打开控制面板中的“系统”程序；在“系统环境变量”中增加两个环境变量项目JAVA_HOME（最好为大写）指向JDK的目录和TOMCAT_HOME（最好为大写）指向所安装的tomcat的目录。</p>
<p><strong>2、启动和关闭Tomcat服务器</strong></p>
<p>（1）启动Tomcat服务器：执行在Bin目录下的名为startup.bat的脚本文件可以启动Tomcat服务器</p>
<p>现在可以运行TOMCAT并作为一个独立的Servlet容器。</p>
<hr>
<p><strong>（2）测试Tomcat的服务器启动与否：</strong></p>
<p>可以在浏览器中输入<a href="http://127.0.0.1:8080/index.html" target="_blank"><a href="http://127.0.0.1:8080/index.jsp">http://127.0.0.1:8080/index.jsp</a></a>，是否出现如下内容。</p>
<hr>
<hr>
<p><strong>（3）启动本站点的JSP页面：</strong>在Tomcat中的JSP文件和JavaBean程序的存放位置</p>
<pre><code>     JSP文件放在“Webapps/站点名称”的目录下

    自定义的JavaBean程序/*.java文件（可以不需要它）及/*.class类文件存放在“Webapps/站点名称/ WEB-INF/classes/”目录下****
</code></pre><p>因此，将/*.jsp文件拷贝到“TOMCAT_HOME/Webapps/站点名称”目录下，然后输入其URL地址</p>
<p><strong>（4）关闭Tomcat服务器：</strong>执行在Bin目录下的名为shutdown.bat的脚本文件可以终止Tomcat服务器。</p>
<hr>
<p><strong>三、配置Tomcat服务器</strong></p>
<hr>
<p><strong>1、概述</strong></p>
<p>Tomcat为用户提供了一系列的配置文件来帮助用户配置自己的Tomcat，Tomcat的配置文件主要是基于XML的；如server.xml、web.xml等，下面将详细讨论Tomcat的主要配置文件以及如何利用这些配置文件解决常见问题。</p>
<hr>
<p><strong>2、server.xml 主配置文件</strong></p>
<p>server.xml是Tomcat的主配置文件，主要完成如下两个目标：</p>
<pre><code>     提供Tomcat组件的初始配置；

     说明Tomcat的结构,含义,使得Tomcat通过实例化组件完成起动及构建自身。
</code></pre><p>观察<strong>server.xml</strong>，可以发现其中有如下的一些元素。</p>
<p>（1）Server元素：</p>
<p>Server元素是<strong>server.xml</strong>文件的最高级别的元素， Server元素描述一个Tomcat服务器，一般来说用户不用关心这个元素。一个Server元素一般会包括Logger和ContextManager两个元素</p>
<pre><code>     Logger：Logger元素定义了一个日志对象，一个日志对象包含有如下属性：
</code></pre><p>1) name：表示这个日志对象的名称。</p>
<p>2) path：表示这个日志对象包含的日志内容要输出到哪一个日志文件。</p>
<p>3) verbosityLevel：表示这个日志文件记录的日志的级别。</p>
<p>一般来说，Logger对象是对Java Servlet、JSP和Tomcat运行期事件的记录</p>
<pre><code>     ContextManager：ContextManager定义了一组ContextInterceptors（ContextManager的事件监听器） , RequestInterceptors（的事件监听器）、Contexts（Web应用程序的上下文目录）和它们的Connectors（连接器）的结构和配置。ContextManager包含如下一些属性：
</code></pre><p>1) debug：记录日志记录调试信息的等级。</p>
<p>2) home：webapps /、conf /、logs /和所有Context的根目录信息。这个属性的作用是从一个不同于TOMCAT _ HOME的目录启动Tomcat。</p>
<p>3) workDir：Tomcat工作目录。</p>
<p>ContextInterceptor 和RequestInterceptors两者都是监听ContextManager的特定事件的拦截器。ContextInterceptor监听Tomcat的启动和结束事件信息。而RequestInterceptors监听用户对服务器发出的请求信息。一般用户无需关心这些拦截器，对于开发人员需要了解这就是全局性的操作得以实现的方法</p>
<hr>
<p><strong>（2）Connector元素：</strong></p>
<p>Connector（连接器）元素描述了一个到用户的连接，不管是直接由Tomcat到用户的浏览器还是通过一个Web服务器。Tomcat的工作进程和由不同的用户建立的连接传来的读/写信息和请求/答复信息都是由连接器对象管理的。对连接器对象的配置中应当包含管理类、TCP/IP端口等内容。<em>**</em></p>
<hr>
<p><strong>（3）Context元素：</strong></p>
<p>每一个Context都描述了一个Tomcat的Web应用程序的目录。这个对象包含以下属性：</p>
<p>1)docBase。这是Context的目录。可以是绝对目录也可以是基于ContextManage的根目录的相对目录。</p>
<p>2)path。这是Context在Web服务时的虚拟目录位置和目录名。</p>
<p>3)debug。日志记录的调试信息记录等级。</p>
<p>4)reloadable。这是为了方便Servlet的开发人员而设置的，当这个属性开关打开的时候，Tomcat将检查Servlet是否被更新而决定是否自动重新载入它</p>
<p>3、<strong>配置实例</strong>：打开Tomcat下的conf文件夹下的server.xml文件</p>
<p>（1）改变Tomcat服务器的端口号</p>
<p>需要使用Connector 元素，Connector表示一个到用户的联接,不管是通过web服务器或直接到用户浏览器(在一个独立配置中)。Connector负责管理Tomcat的工作线程和读/写连接到不同用户的端口的请求/响应。Connector的配置包含如下信息：句柄类、句柄监听的TCP/IP端口、句柄服务器端口的TCP/IP的backlog。修改后，必须重新启动Tomcat的服务器。</p>
<p><strong>注意：</strong>可以将端口号改变为80，单要保证80端口没有被占用；另外，也可以同时分配两个端口号，只要产生两个Connector的配置信息。</p>
<p><strong>    <!-- Define a non-SSL Coyote HTTP/1.1 Connector on port 8080 --></strong></p>
<p><strong>   &lt;Connector port=&quot;8080&quot;    maxThreads=&quot;150&quot; minSpareThreads=&quot;25&quot; maxSpareThreads=&quot;75&quot;</strong></p>
<p><strong>     enableLookups=&quot;false&quot; redirectPort=&quot;8443&quot; acceptCount=&quot;100&quot;  debug=&quot;0&quot; connectionTimeout=&quot;20000&quot;  disableUploadTimeout=&quot;true&quot; /&gt;</strong></p>
<hr>
<p><strong>    <!-- Define a non-SSL Coyote HTTP/1.1 Connector on port 8000 --></strong></p>
<p><strong>    &lt;Connector port=&quot;8000&quot;    maxThreads=&quot;150&quot; minSpareThreads=&quot;25&quot; maxSpareThreads=&quot;75&quot;</strong></p>
<p><strong>enableLookups=&quot;false&quot; redirectPort=&quot;8443&quot; acceptCount=&quot;100&quot;  debug=&quot;0&quot; connectionTimeout=&quot;20000&quot;  disableUploadTimeout=&quot;true&quot; /&gt;</strong></p>
<p>（2）增加新的虚拟目录并指向物理目录</p>
<p>设立一个虚拟工作目录是比较简单的，只需要在server.xml文件中添加一个Context对象就可以了。如，要在webapps/下增加一个WebMis文件夹以存放jsp页面文件，并且让用户可以使用<a href="http://127.0.0.1:8080/WebMis虚拟目录访问，则：需要使用Context" target="_blank">http://127.0.0.1:8080/WebMis虚拟目录访问，则：需要使用Context</a> 元素，每个Context提供一个指向你放置你Web项目的Tomcat的下属目录。每个Context包含如下配置：  </p>
<p>l         Context放置的路径，可以是与ContextManager主目录相关的路径；</p>
<p>l         纪录调试信息的调试级别；</p>
<p>l         可重载的标志，开发Servlet时，重载更改后的Servlet。这是一个非常便利的特性,你可以调试或用Tomcat测试新代码而不用停止或重新启动Tomcat。要打开重载,把reloadable设为true即可。</p>
<p>其中：path=&quot;/WebMis&quot;说明其相对web URL的路径，是一个虚拟的路径，如：<a href="http://127.0.0.1:8080/WebMis" target="_blank"><a href="http://127.0.0.1:8080/WebMis">http://127.0.0.1:8080/WebMis</a></a>，docBase=&quot;WebMis&quot;说明其相对webapps的位置，是物理存在的目录，同时需要在webapps/下增加一个WebMis物理文件夹。</p>
<p>（3）       加入自己的日志文件</p>
<p>添加Logger对象就可以加入自己的日志文件，添加工作相当简单，只需要将作为示例的Logger对象复制一份，然后修改一下前面介绍的几个属性就可以了。在设定了Logger以后，就可以在自己的Servlet中使用ServletContext.log()方法来建立自己的日志文件。</p>
<p>4、<strong>配置实例</strong>：打开conf文件夹下的web.xml文件</p>
<p>（1）web.xml文件：它包含了描述整个Web应用程序（Web应用程序由一整套Web文件jsp、servlet、html、jpg、gif、class等组成）的信息。下面以一个web.xml文件为例，讲解里面的各个对象。</p>
<p>&lt;!DOCTYPE web-app PUBLIC &quot;-//Sun Microsystems, Inc.//DTD Web Application 2.2//EN&quot;</p>
<p>&quot;<a href="http://java.sun.com/j2ee/dtds/web-app_2_2.dtd&quot;&gt;" target="_blank">http://java.sun.com/j2ee/dtds/web-app_2_2.dtd&quot;&gt;</a></p>
<web-app>

<p><display-name>My Web Application</display-name></p>
<description>在这里加入Web应用程序的描述信息</description>

<p>&lt;!-</p>
<p>下面定义了Web应用程序的初始化参数，在JSP或Servlet文件中使用下面的语句</p>
<p>来得到初始化参数</p>
<p>String value =</p>
<p>getServletContext().getInitParameter(&quot;name&quot;);</p>
<p>这里可以定义任意多的初始化参数</p>
<p>--&gt;</p>
<context-param>

<p><param-name>webmaster</param-name></p>
<p><param-value>myaddress@mycompany.com</param-value></p>
<description>这里包含了初始化参数的描述</description>

<p></context-param></p>
<p>&lt;!-</p>
<p>下面的定义描述了组成这个Web应用程序的Servlet，还包含初始化参数。在Tomcat中，也可以将放在Web-INF/classes中的Servlet直接以servlet/Servlet名访问，但是一般来说，不推荐这样使用。而且这样的使用方法还会导致Servlet的相关资源组织的复杂性。所以一般来说推荐将所有的Servlet在这里定义出来。初始化参数可以在Servlet中使用如下语句来获得：</p>
<p>String value =getServletConfig().getInitParameter(&quot;name&quot;);</p>
<p>--&gt;</p>
<servlet>

<servlet-name>controller</servlet-name>

<description>这里加入这个Servlet的描述</description>

<servlet-class>com.mycompany.mypackage.ControllerServlet</servlet-class>

<strong><init-param></strong>

<strong><param-name>listOrders</paramName></strong>

<strong><param-value>com.mycompany.myactions.ListOrdersAction</param-value></strong>

<strong></init-param></strong>

<init-param>

<param-name>saveCustomer</paramName>

<param-value>com.mycompany.myactions.SaveCustomerAction</param-value>

</init-param>

&lt;!-

服务器启动后这个Servlet加载的时间

--&gt;

<load-on-startup>5</load-on-startup>

</servlet>

<servlet>

<servlet-name>graph</servlet-name>

<description>这个Servlet的描述</description>

</servlet>

<p>&lt;!-</p>
<p>Servlet映射对应了一个特殊的URI请求到一个特殊的Servlet的关系</p>
<p>--&gt;</p>
<servlet-mapping>

<p><servlet-name>controller</servlet-name></p>
<p><url-pattern>/*.do</url-pattern></p>
<p></servlet-mapping></p>
<servlet-mapping>

<p><servlet-name>graph</servlet-name></p>
<p><url-pattern>/graph</url-pattern></p>
<p></servlet-mapping></p>
<p>&lt;!-</p>
<p>设定缺省的Session过期时间（单位为分）</p>
<p>--&gt;</p>
<session-config>

<p><session-timeout>30</session-timeout></p>
<p></session-config></p>
<p></web-app><em>**</em></p>
<p><strong>（2）配置实例：会话(session)超时修改，</strong>修改conf/web.xml中的如下数据值（单位为分）</p>
<p><strong>5、在Tomcat中实现利用JDBC驱动程序访问SQLServer2000数据库</strong></p>
<p>只需要将SQLServer2000的JDBC驱动程序的三个/<em>.jar（msbase.jar、mssqlserver.jar和msutil.jar）文件放在/common/lib目录下，然后在/</em>.java程序中访问它。</p>
<p><strong>四、在Tomcat5中配置连接池和数据源</strong></p>
<hr>
<p><strong>1、DataSource接口介绍</strong></p>
<hr>
<p><strong>（1）DataSource 概述</strong></p>
<p>JDBC1.0原来是用DriverManager类来产生一个对数据源的连接。JDBC2.0用一种替代的方法，使用DataSource的实现，代码变的更小巧精致，也更容易控制。</p>
<p>一个DataSource对象代表了一个真正的数据源。根据DataSource的实现方法，数据源既可以是从关系数据库，也电子表格，还可以是一个表格形式的文件。当一个DataSource对象注册到名字服务中（JNDI），应用程序就可以通过名字服务获得DataSource对象，并用它来产生一个与DataSource代表的数据源之间的连接。</p>
<p>javax.sql包中的DataSource接口，可以采用三种实现形式：简单的实现（只提供Connection对象）、连接池形式的实现和分布式事务形式的实现。</p>
<p>javax.sql包中的ConnectionPoolDataSource提供对连接池实现的接口。</p>
<p><strong>（2）使用DataSource的优点</strong></p>
<p>l         DataSource与DriverManager的不同</p>
<p>关于数据源的信息和如何来定位数据源，例如数据库服务器的名字，在哪台机器上，端口号等等，都包含在DataSource对象的属性里面去了。这样，对应用程序的设计来说是更方便了，因为并不需要硬性的把驱动的名字写死到程序里面去。通常驱动名字中都包含了驱动提供商的名字，而在DriverManager类中通常是这么做的。</p>
<p>l         可移植性</p>
<p>如果数据源要移植到另一个数据库驱动中，代码也很容易做修改。所需要做的修改只是更改DataSource的相关的属性。而使用DataSource对象的代码不需要做任何改动。</p>
<p><strong>（3）配置DataSource</strong></p>
<p>主要包括设定DataSource的属性，然后将它注册到JNDI名字服务中去。在注册DataSource对象的的过程中，系统管理员需要把DataSource对象和一个逻辑名字关联起来。名字可以是任意的，通常取成能代表数据源并且容易记住的名字。</p>
<p>在下面的例子中，名字起为：WebMisDB，按照惯例，逻辑名字通常都在jdbc的子上下文中。这样，逻辑名字的全名就是：jdbc/WebMisDB。</p>
<p><strong>（4）产生一个与数据源的连接</strong></p>
<p>一旦配置好了数据源对象，应用程序设计者就可以用它来产生一个与数据源的连接。下面的代码片段示例了如何用JNDI上下文获得一个数据源对象，然后如何用数据源对象产生一个与数据源的连接。开始的两行用的是JNDI API，第三行用的才是JDBC的API： 
Context ctx = new InitialContext(); </p>
<p>DataSource ds = (DataSource)ctx.lookup(&quot;jdbc/WebMisDB&quot;);</p>
<p>Connection con = ds.getConnection(&quot;myPassword&quot;, &quot;myUserName&quot;); 
在一个基本的DataSource实现中，DataSource.getConnection方法返回的Connection对象和用DriverManager.getConnection方法返回的Connection对象是一样的。因为DataSource提供的方便性，我们推荐使用DataSource对象来得到一个Connection对象。</p>
<p><strong>（5）DataSource的应用场合</strong></p>
<p>对于普通的应用程序设计者，是否使用DataSource对象只是一个选择问题。但是，对于那些需要用的连接池或者分布式的事务的应用程序设计者来说，就必须使用DataSource对象来获得Connection。需要注意的是对Tomcat而言，在JNDI的名称前面应该加上&quot;java:comp/env/&quot; </p>
<p><strong>（6）数据源（DataSource）的作用</strong></p>
<p>它相当于客户端程序和连接池的中介，想要获得连接池中的连接对象，必须建立一个与该连接池相应的数据源，然后通过该数据源获得连接。</p>
<p><strong>2、JNDI（</strong>JAVA NAMING AND DIRECTORY INTERFACE---Java 命名和目录接口<strong>）</strong></p>
<p><strong>（1）</strong>JNDI简介<em>**</em></p>
<p>分布式计算环境通常使用命名和目录服务来获取共享的组件和资源。命名和目录服务将名称与位置、服务、信息和资源关联起来。它是一个为JAVA应用程序提供命名服务的应用程序编程接口（API）。</p>
<p>命名服务提供了一种为对象命名的机制，这样你就可以在无需知道对象位置的情况下获取和使用对象。只要该对象在命名服务器上注册过，且你必须知道命名服务器的地址和该对象在命名服务器上注册的JNDI名。就可以找到该对象，获得其引用，从而运用它提供的服务。</p>
<p>命名服务提供名称—对象的映射。目录服务提供有关对象的信息，并提供定位这些对象所需的搜索工具。</p>
<p>Java 命名和目录接口或 JNDI 提供了一个用于访问不同的命名和目录服务的公共接口（JAVA API）。运用一个命名服务来查找与一个特定名字相关的一个对象，JDBC可以用JNDI来访问一个关系数据库。</p>
<p><strong>（2）获得JNDI的初始环境</strong></p>
<p>在JNDI中，在目录结构中的每一个结点称为Context 。每一个JNDI名字都是相对于Context 的。这里没有绝对名字的概念存在。对一个应用来说，它可以通过使用InitialContext 类来得到其第一个Context：</p>
<p>Context  ctx = new InitialContext ();</p>
<p>应用可以通过这个初始化的Context经由这个目录树来定位它所需要的资源或对象。InitialContext在网页应用程序初始化时被设置，用来支持网页应用程序组件。所有的入口和资源都放在JNDI命名空间里的java:comp/env段里。</p>
<p><strong>（3）查找已绑定的对象</strong></p>
<p>用ctx..lookup(String name); 根据name找对象</p>
<p>例：</p>
<p>import javax.naming./*;</p>
<p>public class TestJNDI</p>
<p>{    </p>
<p>public static void main(String[] args)</p>
<p>{</p>
<pre><code>    try
</code></pre><p>{</p>
<pre><code>    Context ctx=new InitialContext();

    Object object=ctx.lookup(“JNDIName”);       //根据JNDI名查找绑定的对象

    String str=(String) object;                                 //强制转换

    }
</code></pre><p>catch(NamingException e)</p>
<p>{    e.printStackTrace();</p>
<pre><code>    }
</code></pre><p>catch(ClassCastException e)</p>
<p>{    e.printStackTrace();</p>
<pre><code>    }
</code></pre><p>   }</p>
<p>}<em>**</em></p>
<hr>
<p><strong>3、数据库连接池技术</strong></p>
<hr>
<p><strong>（1）</strong>传统的Web数据库编程模式</p>
<p>l         在主程序（如Servlet、Beans）中建立数据库连接。</p>
<p>l         进行SQL操作，取出数据。</p>
<p>l         断开数据库连接。</p>
<p>使用这种模式开发，存在很多问题。</p>
<p>l         首先，我们要为每一次WEB请求（例如察看某一篇文章的内容）建立一次数据库连接，对于一次或几次操作来讲，或许你觉察不到系统的开销，但是，对于WEB程序来讲，即使在某一较短的时间段内，其操作请求数也远远不是一两次，而是数十上百次（想想全世界的网友都有可能在您的网页上查找资料），在这种情况下，系统开销是相当大的。事实上，在一个基于数据库的WEB系统中，建立数据库连接的操作将是系统中代价最大的操作之一。很多时候，可能您的网站速度瓶颈就在于此。</p>
<p>l         其次，使用传统的模式，你必须去管理每一个连接，确保他们能被正确关闭，如果出现程序异常而导致某些连接未能关闭，将导致数据库系统中的内存泄露，最终我们将不得不重启数据库。<em>**</em></p>
<p>l         频繁的建立、关闭连接，会极大的减低系统的性能，因为对于连接的使用成了系统性能的瓶颈。<em>**</em></p>
<hr>
<p><strong>（2）数据库连接是一种关键的有限的昂贵的资源</strong></p>
<p>这一点在多用户的网页应用程序中体现得尤为突出。对数据库连接的管理能显著影响到整个应用程序的伸缩性和健壮性，影响到程序的性能指标。数据库连接池正是针对这个问题提出来的。</p>
<p>连接池是这么一种机制，当应用程序关闭一个Connection的时候，这个连接被回收，而不是被destroy，因为建立一个连接是一个很费资源的操作。如果能把回收的连接重新利用，会减少新创建连接的数目，显著的提高运行的性能。该策略的核心思想是：连接复用。</p>
<p>通过采用连接池的方法，服务器在启动时先打开一定数量的连接。当应用需要连接时，就可以从服务器请求一个连接。当应用结束该连接时，服务器就把它释放到连接池，以备其他客户机使用。
客户获得连接并访问数据库以后结束客户获得连接并访问数据库以后结束客户获得连接并访问数据库以后结束开始停止服务吗</p>
<p>？产生新的连接等待引入的连接结束是服务器监听客户的连接请求                    客户获得连接</p>
<p><strong>（3）连接池的主要作用</strong></p>
<p>l         减少了建立和释放数据库连接的消耗</p>
<p>l         数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而再不是重新建立一个；</p>
<p>l         释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏。这项技术能明显提高对数据库操作的性能。</p>
<p>l         封装用户信息  使用连接池可以封装连接数据库系统所用的用户信息（帐号和密码），这样客户端程序在建立连接时不用考虑安全信息。</p>
<p><strong>（4）数据库连接池的工作原理</strong></p>
<pre><code>   当程序中需要建立数据库连接时，只须从内存中取一个来用而不用新建。同样，使用完毕后，只需放回内存即可。而连接的建立、断开都有连接池自身来管理。同时，我们还可以通过设置连接池的参数来控制连接池中的连接数、每个连接的最大使用次数等等
</code></pre><p><strong>（5）数据库连接池的最小连接数和最大连接数</strong></p>
<p>数据库连接池的最小连接数和最大连接数的设置要考虑到下列几个因素：</p>
<p>l         最小连接数是连接池一直保持的数据库连接，所以如果应用程序对数据库连接的使用量不大，将会有大量的数据库连接资源被浪费；</p>
<p>l         最大连接数是连接池能申请的最大连接数，如果数据库连接请求超过此数，后面的数据库连接请求将被加入到等待队列中，这会影响之后的数据库操作。</p>
<p>如果最小连接数与最大连接数相差太大，那么最先的连接请求将会获利，之后超过最小连接数量的连接请求等价于建立一个新的数据库连接。不过，这些大于最小连接数的数据库连接在使用完不会马上被释放，它将被放到连接池中等待重复使用或是空闲超时后被释放。</p>
<p><strong>（6）使用连接池得到连接</strong>
假设应用程序需要建立到一个名字为EmpolyeeDB的DataSource的连接。使用连接池得到连接的代码如下： 
Context ctx = new InitialContext(); </p>
<p>DataSource ds = (DataSource)ctx.lookup(&quot;jdbc/EmployeeDB&quot;);</p>
<p>Connection con = ds.getConnection(&quot;myPassword&quot;, &quot;myUserName&quot;);</p>
<p>或者：</p>
<p>Context ctx = new InitialContext(); </p>
<p>ConnectionPoolDataSource ds = (ConnectionPoolDataSource)ctx.lookup(&quot;jdbc/EmployeeDB&quot;);</p>
<p>PooledConnection con = ds.getConnection(&quot;myPassword&quot;, &quot;myUserName&quot;);</p>
<p>是否使用连接池获得一个连接，在应用程序的代码上是看不出不同的。在使用这个Connection连接上也没有什么不一样的地方，唯一的不同是在java的finally语句块中来关闭一个连接。在finally中关闭连接是一个好的编程习惯。这样，即使方法抛出异常，Connection也会被关闭并回收到连接池中去。代码应该如下所示： 
try</p>
<p>{… 
}</p>
<p>catch（）</p>
<p>{… 
}</p>
<p>finally</p>
<p>{ </p>
<p>if（con!=null）</p>
<p>con.close();</p>
<p>}<em>**</em></p>
<hr>
<p><strong>4、在Tomcat中配置数据库的连接池</strong></p>
<hr>
<p><strong>（1）连接池配置(Database Connection Pool (DBCP) Configurations)</strong></p>
<p>DBCP使用的是Jakarta-Commons Database Connection Pool 要使用连接池需要如下的组件即jar文件。</p>
<p>l         Jakarta-Commons DBCP 1.1 对应commons-dbcp-1.1.jar。</p>
<p>l         Jakarta-Commons Collections 2.0 对应commons-collections.jar。</p>
<p>l         Jakarta-Commons Pool 1.1 对应commons-pool-1.1.jar。</p>
<p>这三个jar文件要与你的JDBC驱动程序一起放到【TOMCAT_HOME】/common/lib目录下以便让tomcat和你的web应用都能够找到。</p>
<hr>
<p><strong>注：</strong></p>
<p>l         这三个jar文件是默认存在与【TOMCAT_HOME】/common/lib下的。</p>
<p>l         需要注意的地方：第三方的驱动程序或者其他类只能以/<em>.jar的形式放到Tomcat的common/lib目录中,因为Tomcat只把/</em>.jar文件加到CLASSPATH中。</p>
<p>l         不要把上诉三个文件放到WEB-INF/lib或者其他地方因为这样会引起混淆。<em>**</em></p>
<hr>
<p><strong>（2）通过配置阻止连接池漏洞</strong></p>
<p>数据库连接池创建和管理连接池中建立好的数据库连接，循环使用这些连接以得到更好的效率。这样比始终为一个用户保持一个连接和为用户的请求频繁的建立和销毁数据库连接要高效的多。</p>
<p>这样就有一个问题出现了，一个Web应用程序必须显示的释放ResultSet，Statement和Connection。如果在关闭这些资源的过程中失败将导致这些资源永远不在可用，这就是所谓的连接池漏洞。这个漏洞最终会导致连接池中所有的连接不可用。</p>
<p>通过配置Jakarta Common DBCP可以跟踪和恢复那些被遗弃的数据库连接。</p>
<p>以下是一系列相关配置：</p>
<p>l         通过配置DBCP数据源中的参数removeAbandoned来保证删除被遗弃的连接使其可以被重新利用。</p>
<p>为ResourceParams(见下文的数据源配置)标签添加参数removeAbandoned</p>
<parameter>

<name>removeAbandoned</name>

<value>true</value>

</parameter>

<p>通过这样配置的以后当连接池中的有效连接接近用完时DBCP将试图恢复和重用被遗弃的连接。这个参数的值默认是false。</p>
<p>l         通过设置removeAbandonedTimeout来设置被遗弃的连接的超时的时间，即当一个连接连接被遗弃的时间超过设置的时间时那么它会自动转换成可利用的连接。</p>
<pre><code>&lt;parameter&gt;

 &lt;name&gt;removeAbandonedTimeout&lt;/name&gt;

 &lt;value&gt;60&lt;/value&gt;

 &lt;/parameter&gt;

默认的超时时间是300秒。
</code></pre><p>l         设置logAbandoned参数，以将被遗弃的数据库连接的回收记入日志中</p>
<parameter>

<name>logAbandoned</name>

<value>true</value>

</parameter>

<p>这个参数默认为false。<em>**</em></p>
<p><strong>（3）修改server.xml文件</strong></p>
<pre><code>   &lt;Context path=&quot;/WebMis&quot; docBase=&quot;WebMis&quot; debug=&quot;0&quot; reloadable=&quot;true&quot;&gt;



               &lt;Resource name=&quot;jdbc/webmis&quot; auth=&quot;Container&quot; type=&quot;javax.sql.DataSource&quot;/&gt;  

               &lt;ResourceParams** name=&quot;jdbc/webmis&quot;**&gt;      

                             &lt;parameter&gt;             

                                     &lt;name&gt;

                                            factory

                                     &lt;/name&gt;        

                                     &lt;value&gt;org.apache.commons.dbcp.BasicDataSourceFactory

                                     &lt;/value&gt;        

                          &lt;/parameter&gt;

                          &lt;parameter&gt;             

                                   &lt;name&gt;

                                          driverClassName

                                   &lt;/name&gt;        

                                     &lt;value&gt;**com.microsoft.jdbc.sqlserver.SQLServerDriver**

                                     &lt;/value&gt;        

                              &lt;/parameter&gt;

                             &lt;parameter&gt;      

                                     &lt;name&gt;

                                            url

                                     &lt;/name&gt;        

                           &lt;value&gt;**jdbc:microsoft:sqlserver://127.0.0.1:1433;DatabaseName=DataBase**

                          &lt;/value&gt;

                             &lt;/parameter&gt;            

                             &lt;parameter&gt;

                                        &lt;name&gt;

                                               username

                                         &lt;/name&gt;             

                                     &lt;value&gt;

                                          **sa**

                                     &lt;/value&gt;

                            &lt;/parameter&gt;            

                             &lt;parameter&gt;

                                        &lt;name&gt;

                                               password

                                        &lt;/name&gt;

                                        &lt;value&gt;
</code></pre><p>maxActive 连接池的最大数据库连接数。设为0表示无限制。                                            </value> </p>
<pre><code>                             &lt;/parameter&gt;            

                             &lt;parameter&gt;



                                        &lt;name&gt;

                                               maxActive

                                        &lt;/name&gt;

                                        &lt;value&gt;

                                               20
</code></pre><p>回收被遗弃的（一般是忘了释放的）数据库连接到连接池中，设为－1表示无限制。maxIdle  数据库连接的最大空闲时间。超过此空闲时间，数据库连接将被标记为不可用，然后被释放。设为0表示无限制。                                            </value></p>
<pre><code>                             &lt;/parameter&gt;

                             &lt;parameter&gt;             

                                    &lt;name&gt;

                                             maxIdle

                                      &lt;/name&gt;
</code></pre><p>maxWait 最大建立连接等待时间。如果超过此时间将接到异常。设为－1表示无限制。                                        <value>10</value></p>
<pre><code>                            &lt;/parameter&gt;

                            &lt;parameter&gt;

                                        &lt;name&gt;maxWait&lt;/name&gt;

                                        &lt;value&gt;-1&lt;/value&gt;

                          &lt;/parameter&gt; 
</code></pre><parameter>
  <name>removeAbandoned</name>
  <!-- Abandoned DB connections are removed and recycled -->
  <value>true</value>
 </parameter>
 <parameter>
  <name>removeAbandonedTimeout</name>
  <!-- Use the removeAbandonedTimeout parameter to set the number of seconds a DB connection has been idle before it is considered abandoned.  -->
  <value>60</value>
 </parameter>
 <parameter>
  <name>logAbandoned</name>
  <!-- Log a stack trace of the code which abandoned -->
  <value>false</value>
 </parameter>    

<p>数据库连接过多长时间不用将被视为被遗弃而收回连接池中将被遗弃的数据库连接的回收记入日志                   </ResourceParams></p>
<pre><code>          &lt;/Context&gt;
</code></pre><p>注意：</p>
<p>l         所有的入口和资源都放在JNDI命名空间里的java:comp/env段里</p>
<p>l         设置JNDI资源要在$CATALINA_HOME/conf/server.xml文件里使用下列标志符：
1) <Resource>--设置应用程序可用的资源的名字和类型（同上面说的<resource-ref>等价）。
2) <ResourceParams>--设置Java资源类工厂的名称或将用的JavaBean属性。
上述这些标志符必须放在<Context>和</Context>之间</p>
<hr>
<p><strong>（2）、拷贝SQLServer的JDBC驱动程序到Tomcat的/common/lib目录下</strong></p>
<hr>
<p><strong>（3）、在程序中利用数据源来访问数据库</strong></p>
<pre><code>          try

          {

                 Context initCtx = new InitialContext();

               Context envCtx = (Context) initCtx.lookup(&quot;java:comp/env&quot;);

            DataSource ds = (DataSource)envCtx.lookup(&quot;jdbc/webmis&quot;);

             Connection con=ds.getConnection();

      }

    catch (NamingException e)

       {

               e.printStackTrace();

        }

        catch (SQLException e)

       {

               e.printStackTrace();

         }
</code></pre><hr>
<p><strong>5、在server.xml文件中与数据源的描述相关的标签含义</strong></p>
<p>l         maxActive 连接池的最大数据库连接数。设为0表示无限制。<em>**</em></p>
<p>l         maxIdle  数据库连接的最大空闲时间。超过此空闲时间，数据库连接将被标记为不可用，然后被释放。设为0表示无限制。<em>**</em></p>
<p>l         maxWait 最大建立连接等待时间。如果超过此时间将接到异常。设为－1表示无限制。<em>**</em></p>
<p>l         removeAbandoned 回收被遗弃的（一般是忘了释放的）数据库连接到连接池中。<em>**</em></p>
<p>l         removeAbandonedTimeout 数据库连接过多长时间不用将被视为被遗弃而收回连接池中。<em>**</em></p>
<p>l         logAbandoned 将被遗弃的数据库连接的回收记入日志。<em>**</em></p>
<p>l         driverClassName JDBC驱动程序。<em>**</em></p>
<p>l         url   数据库DSN连接字符串<em>**</em></p>
<p><strong>6**</strong>、在Web应用的web.xml文件中引用该资源**</p>
<p>将下面的标签放在放在<web-app>和</web-app>中间</p>
<p><strong><!-- Database Config start --></strong></p>
<p><strong><resource-ref></strong></p>
<p><strong><description>connectDB test</description></strong></p>
<p><strong><res-ref-name>jdbc/webmis</res-ref-name></strong></p>
<p><strong><res-type>javax.sql.DataSource</res-type></strong></p>
<p><strong><res-auth>Container</res-auth></strong></p>
<p><strong></resource-ref></strong></p>
<p><strong><!-- Database Config end --></strong></p>
<p><strong>4，综合配置实例</strong></p>
<p>首先在C:根目录下建立文件夹mywebapp，作为一个虚拟目录的位置。</p>
<p>建立一个Sql Server数据库DataBonus</p>
<p>找到C:/jakarta-tomcat-5.0.19/conf/server.xml，打开。</p>
<p>加入：</p>
 <Context path="/mywebapp" docBase="C:/mywebapp" debug="0" reloadable="true">



       <Resource name="jdbc/mybonusds" auth="Container" type="javax.sql.DataSource"/><br>
<ResourceParams name="jdbc/mybonusds"><br>
              <parameter><br>
                 <name>factory</name><br>
                 <value>org.apache.commons.dbcp.BasicDataSourceFactory</value><br>
              </parameter>

              <parameter><br>
                 <name>driverClassName</name><br>
                 <value>com.microsoft.jdbc.sqlserver.SQLServerDriver</value><br>
              </parameter>

              <parameter><br>
                  <name>url</name><br>
                  <value>

jdbc:microsoft:sqlserver://127.0.0.1:1433;DatabaseName=DataBonus

                   </value>

               </parameter><br>
               <parameter>

                 <name>username</name><br>
                 <value>sa</value>

                </parameter><br>
                <parameter>

                   <name>password</name>

                   <value></value><br>
                </parameter><br>
                <parameter>

<name>maxActive</name>

                    <value>20</value>

                </parameter>

                <parameter><br>
                   <name>maxIdle</name>

                   <value>10</value>

                </parameter>

                <parameter><br>
                   <name>maxWait</name>

                   <value>-1</value>

                </parameter><br>
<parameter>

             <name>removeAbandoned</name>

             <!-- Abandoned DB connections are removed and recycled -->

             <value>true</value>

          </parameter>

          <parameter>

              <name>removeAbandonedTimeout</name>

  <!-- Use the removeAbandonedTimeout parameter to set the number of seconds a DB connection has been idle before it is considered abandoned.  -->

              <value>60</value>

           </parameter>

           <parameter>

              <name>logAbandoned</name>

            <!-- Log a stack trace of the code which abandoned -->

              <value>false</value>

           </parameter><br>
         </ResourceParams>

</Context>



<p>   做一个JSP页面index.jsp放到mywebapp下面，代码：</p>
<p>&lt;%--字符集设为&quot;gb2312&quot;,使动态页面支持中文--%&gt;</p>
<p>&lt;%@ page contentType=&quot;text/html; charset=GB2312&quot;%&gt;</p>
<!-- 这里使用一个字串变量 ("PAGETITLE") 保持题目和主标题的一致性。-->

<html>

<head>

<title>

&lt;%= pagetitle %&gt;

</title>

</head>



<body bgcolor=/#FFFFFF>



<font face="Helvetica">



<h2>

<font color=/#DB1260>

&lt;%= pagetitle %&gt;

</font>

</h2>



<!-- 导入必要的类和类库 -->



&lt;%@ page import=&quot;

    javax.naming./<em>,

    java.sql./</em>,

    javax.sql.DataSource

&quot;%&gt;



<!-- 声明一个类方法 -->



&lt;%!

//声明变量

//标题

  String pagetitle = &quot;这是JSP调用数据库的例子&quot;;



%&gt;



<!-- 下面这些代码将被插入到servlet中 -->



&lt;%



   java.sql.Connection conn= null;

   java.sql.Statement stmt =null;

   java.sql.ResultSet rs=null;



  try {

    // 通过JNDI获取主接口



     Context initCtx = new InitialContext();

     Context envCtx = (Context) initCtx.lookup(&quot;java:comp/env&quot;);

     DataSource ds = (DataSource)envCtx.lookup(&quot;jdbc/mybonusds&quot;);

     conn=ds.getConnection();



      stmt = conn.createStatement();





           //执行SQL语句

      stmt.execute(&quot;select /* from 奖金&quot;);

    //取得结果集

      rs = stmt.getResultSet();



    %&gt;



  <table border="1">

   <tr>

      <td width="60" height="20">&lt;% out.print(&quot;编号&quot;); %&gt;</td>

      <td width="80" height="20">&lt;% out.print(&quot;姓名&quot;); %&gt;</td>

      <td width="200" height="20">&lt;% out.print(&quot;发奖名称&quot;); %&gt;</td>

      <td width="100" height="20">&lt;% out.print(&quot;金额&quot;); %&gt;</td>

      <td width="200" height="20">&lt;% out.print(&quot;备注&quot;); %&gt;</td>

   </tr>

  &lt;%   while (rs.next()) {



  %&gt;

    <tr>

      <td width="60" height="20">&lt;% out.print(rs.getString(&quot;编号&quot;)); %&gt;</td>

      <td width="80" height="20">&lt;% out.print(rs.getString(&quot;姓名&quot;)); %&gt;</td>

      <td width="200" height="20">&lt;% out.print(rs.getString(&quot;发奖名称&quot;)); %&gt;</td>

      <td width="100" height="20">&lt;% out.print(rs.getString(&quot;金额&quot;)); %&gt;</td>

      <td width="200" height="20">&lt;% out.print(rs.getString(&quot;备注&quot;)); %&gt;</td>

   </tr>

     &lt;%  } %&gt;

  </table>





&lt;%

 // Catch exceptions

  }



  catch (Exception e) {

  }

  finally {



 if (rs != null)

     {

      try{rs.close();}catch(Exception ignore){};

      }



     if (stmt != null)

     {

      try{stmt.close();}catch(Exception ignore){};

      }

     if (conn != null)

     {

      try{conn.close();}catch(Exception ignore){};

      }





 %&gt;





&lt;%

  }

%&gt;



</font>

</body>

</html>



<p>启动Tomcat。</p>
<p>浏览：<a href="http://127.0.0.1:8080/mywebapp/index.jsp" target="_blank">http://127.0.0.1:8080/mywebapp/index.jsp</a></p>
<p><strong>四、在Tomcat中实现系统和Web管理的配置</strong></p>
<hr>
<p><strong>1、配置系统管理（Admin Web Application）</strong></p>
<hr>
<p><strong>（1）概述</strong></p>
<p>大多数商业化的J2EE服务器都提供一个功能强大的管理界面（如Weblogic的管理控制台），且大都采用易于理解的Web应用界面。Tomcat按照自己的方式，同样提供一个成熟的管理工具，并且丝毫不逊于那些商业化的竞争对手。</p>
<p>Tomcat的Admin Web Application最初在4.1版本时出现，当时的功能包括管理context、data source、user和group等。当然也可以管理像初始化参数，user、group、role的多种数据库管理等。在后续的版本中，这些功能将得到很大的扩展，但现有的功能已经非常实用了。</p>
<hr>
<p><strong>（2）系统管理Web应用程序</strong></p>
<p>Tomcat中的Admin Web Application被定义在自动部署文件：C:/jakarta-tomcat-5.0.19/server/webapps/admin/ admin.xml 中（请见下图所示）。</p>
<hr>
<p><strong>（3）编辑admin.xml文件</strong></p>
<p>通过编辑admin.xml文件，以确定Context中的docBase参数设置为Admin Web Application所在的目录路径（应该是绝对路径）。作为另外一种选择，你也可以删除这个自动部署文件，而在C:/jakarta-tomcat-5.0.19/conf/server.xml文件中建立一个Admin Web Application的context，效果是一样的。</p>
<pre><code>   你不能管理Admin Web Application这个应用，换而言之，除了删除CATALINA_BASE/webapps/admin.xml ，你可能什么都做不了。
</code></pre><p><strong>注意：</strong>如果将其中的被注释掉的&lt;Valve className=&quot;org.apache.catalina.valves.RemoteAddrValve&quot;</p>
<pre><code>allow=&quot;127.0.0.1&quot;/&gt;打开，将能够限制访问Admin Web Application的程序主机为本机（服务器主机）；当然也可以设置为其它的主机IP地址（如设置为 Web管理员所的工作主机）。
</code></pre><hr>
<p><strong>（4）在C:/jakarta-tomcat-5.0.19/conf/ tomcat-users.xml 文件中添加系统管理员的角色和系统管理员</strong></p>
<p>Tomcat中提供UserDatabaseRealm（默认），这样我们可以根据管理的需要添加不同的用户角色和与该角色相配置的用户名称和密码</p>
<p>l         添加用户角色</p>
<role name="admin"/>

<p>l         添加与该角色相配置的用户名称和密码</p>
<user name="admin" password="12345678" roles="admin"/>

<p>当你完成这些步骤后，请重新启动Tomcat，访问<a href="http://localhost:8080/admin，你将看到一个登录界面。Admin" target="_blank">http://localhost:8080/admin，你将看到一个登录界面。Admin</a> Web Application程序采用基于容器管理的安全机制，并采用了Jakarta Struts框架。下面是在原来的tomcat-users.xml 文件中再添加了两个角色admin和manager，同时也添加了与该两个角色相配置的用户admin和manager。</p>
<p>&lt;?xml version=&#39;1.0&#39; encoding=&#39;utf-8&#39;?&gt;</p>
<tomcat-users>

  <role rolename="role1"/>

  <role rolename="tomcat"/>

<p><strong>  <role rolename="admin"/></strong></p>
<p><strong>  <role rolename="manager"/></strong></p>
<p>  <strong><user username="admin" password="12345678" roles="admin"/></strong></p>
<p><strong>  <user name="manager" password="12345678" roles="manager"/></strong></p>
  <user username="role1" password="tomcat" roles="role1"/>

  <user username="tomcat" password="tomcat" roles="tomcat"/>

  <user username="both" password="tomcat" roles="tomcat,role1"/>

<p></tomcat-users></p>
<p><strong>（5）登录Admin Web Application程序</strong></p>
<p>输入<a href="http://localhost:8080/admin/" target="_blank"><a href="http://localhost:8080/admin/">http://localhost:8080/admin/</a></a>进入系统管理员的登录页，然后在页中</p>
<p>输入用户名称：admin</p>
<p>密码： 12345678</p>
<pre><code>   将进入系统管理的界面，在该系统管理的程序中将可以配置各种资源如Data Sources、Mail Sessions、Environment Entries，并且也可以管理Users 和Groups 以及Roles等功能。
</code></pre><hr>
<p><strong>2、配置应用管理（Manager Web Application）</strong></p>
<hr>
<p><strong>（1）概述</strong></p>
<p>Tomcat中所提供的Manager Web Application让你通过一个比Admin Web Application更为简单的用户界面，执行一些与Web应用任务相关的一些管理功能。</p>
<hr>
<p><strong>（2）Manager Web Application程序</strong></p>
<p>Manager Web Application被被定义在一个自动部署文件中C:/jakarta-tomcat-5.0.19/server/webapps/manager/manager.xml 。</p>
<hr>
<p><strong>（3）编辑manager.xml文件</strong></p>
<p>通过编辑这个文件，以确保其中的context中的docBase属性参数是C:/jakarta-tomcat-5.0.19/server/webapps/manager的绝对路径。</p>
<hr>
<p><strong>（4）在C:/jakarta-tomcat-5.0.19/conf/ tomcat-users.xml 文件中添加Web管理员的角色和Web管理员</strong></p>
<p>l         添加用户角色</p>
<p><strong><role name=" manager "/></strong></p>
<p>l         添加与该角色相配置的用户名称和密码</p>
<p><strong>  <user name="manager" password="12345678" roles="manager"/></strong></p>
<hr>
<p><strong>（5）登录Web管理员的页面</strong></p>
<p>l         文本型管理界面</p>
<p>然后重新启动Tomcat，输入<a href="http://localhost:8080/manager/" target="_blank"><a href="http://localhost:8080/manager/">http://localhost:8080/manager/</a></a>，将进入看到一个很朴素的文本型管理界面</p>
<p>如果输入<a href="http://localhost:8080/manager/" target="_blank"><a href="http://localhost:8080/manager/">http://localhost:8080/manager/</a></a>list，将进入一个登录管理界面，然后</p>
<p>输入用户名称：manager（前面在tomcat-users.xml中设置的）</p>
<p>密码：12345678</p>
<p>将显示出</p>
<p>l         HTML 型管理界面</p>
<p>输入<a href="http://localhost:8080/manager/html/list" target="_blank"><a href="http://localhost:8080/manager/html/list">http://localhost:8080/manager/html/list</a></a>，将出现如下的页面，然后再</p>
<p>输入用户名称：manager</p>
<p>密码：12345678</p>
<p>将出现Web方式的管理页面</p>
<p>Manager application可以让用户在没有系统管理特权的基础上，部署安装新的Web应用，以用于测试。同时也可以对所部署的Web应用程序的工作状态进行控制（Start 或者 Stop），以免重新启动服务器（这在对web.xml等配置的内容发生改变的情况下，特别有效）。当有用户尝试访问这个被停止的应用时，将看到一个503的错误——“503 - This application is not currently available”。</p>
<hr>
<p><strong>3、配置各种用户角色、用户组和用户</strong></p>
<p>（1）添加用户角色：在 admin的界面中点击左面的Roles节点，然后在右面的下拉列表框中选择Create New Role项目。</p>
<p>然后输入角色的名称和描述</p>
<pre><code>   最后点击“保存”，将存储在C:/jakarta-tomcat-5.0.19/conf/tomcat-users.xml文件中并且在管理界面中显示出。
</code></pre><p><strong>（2）添加用户组：</strong>在 admin的界面中点击左面的Groups节点，然后在右面的下拉列表框中选择Create New Group项目。</p>
<hr>
<p>然后输入组的名称和描述，并且设置该组的角色。所应该注意的是，给组分配角色，则意味着该组中的各个成员（用户）将具有该角色所分配的各种权限。</p>
<hr>
<p>最后点击“Save”以保存它（仍然放在C:/jakarta-tomcat-5.0.19/conf/tomcat-users.xml文件中）</p>
<hr>
<p><strong>（3）添加属于某一用户组内的用户</strong></p>
<p>在 admin的界面中点击左面的Users节点，然后在右面的下拉列表框中选择Create New User项目。</p>
<p>然后该用户的名称同时包括全名称、密谋，并且设置该用户所属的用户组；同时也可以为该用户再设置其它的角色以使该用户除了具有用户组的通用的权利以外，还具有其他方面的权利。</p>
<p>下面对“teacherZhang”这个用户进行设置，同时他也是系统管理员，因此将下面的admin的角色也选中。</p>
<p>最后点击保存（仍然放在C:/jakarta-tomcat-5.0.19/conf/tomcat-users.xml文件中）</p>
<hr>
<p><strong>4、添加其它的系统资源</strong></p>
<hr>
<p><strong>（1）DataSource</strong></p>
<pre><code>   在 admin的界面中点击左面的DataSourcs节点，然后在右面的下拉列表框中选择Create New DataSource项目。

   在各个输入的项目中根据数据库的特性进行输入。最后点击“Save”以保存。
</code></pre><hr>
<p><strong>（2）添加环境变量</strong></p>
<pre><code>   在 admin的界面中点击左面的Environment Entries节点，然后在右面的下拉列表框中选择Create New Env Entry项目。

   在各个输入的项目中根据数据库的特性进行输入。最后点击“Save”以保存。****
</code></pre><hr>
<p><strong>5、对Web应用程序进行管理</strong></p>
<p>（1）输入<a href="http://localhost:8080/manager/html/list" target="_blank"><a href="http://localhost:8080/manager/html/list">http://localhost:8080/manager/html/list</a></a>，将出现登录页并且进行登录，然后再进入Tomcat Web Application Manager</p>
<p>（2）查看在Web服务中所发布的各个Web应用</p>
<hr>
<p><strong>（3）启动或者终止、移除某一Web应用：</strong></p>
<p>点击该 Web应用右面的Stop链接，也可以点击Start再次启动它。Undeploy（移除）一个Web应用，只是指从Tomcat的运行拷贝中删除了该应用，如果你重新启动Tomcat，被删除的应用将再次出现（也就是说，移除并不是指从硬盘上删除）。</p>
<hr>
<p><strong>（4）部署某一Web应用</strong></p>
<p>有三种方式可以在Tomcat系统中部署Web应用。</p>
<p>l         直接拷贝你的WAR文件或者你的Web应用文件夹（包括该Web应用的所有内容）到C:/jakarta-tomcat-5.0.19/webapps目录下。</p>
<p>该文件必须以“.war”作为扩展名。一旦Tomcat监听到这个文件，它将（缺省的）解开该文件包作为一个子目录，并以WAR文件的文件名作为子目录的名字。接下来，Tomcat将在内存中建立一个context，就好象你在server.xml文件里建立一样。当然，其他必需的内容，将从server.xml中的DefaultContext获得。</p>
<p>l         部署web应用的另一种方式是写一个Context XML片断文件，然后把该文件拷贝到C:/jakarta-tomcat-5.0.19/webapps目录下。</p>
<p>一个Context片断并非一个完整的XML文件，而只是一个Context元素，以及对该应用的相应描述。这种片断文件就像是从server.xml中切取出来的context元素一样，所以这种片断被命名为“context片断”。这个web应用本身可以存储在硬盘上的任何地方。</p>
<p>举个例子，如果我们想部署一个名叫JspExamples的Web应用，该应用使用realm作为访问控制方式，我们可以使用下面这个片断：</p>
<!-- 

 Context fragment for deploying JspExamples 

-->

<Context path="/JspExamples" docBase="JspExamples" debug="0" reloadable="true">

<RealmclassName="org.apache.catalina.realm.UserDatabaseRealm"  resourceName="UserDatabase"/>

</Context>

<p>把该片断命名为“JspExamples.xml”，然后拷贝到C:/jakarta-tomcat-5.0.19/webapps目录下。这种Context片断提供了一种便利的方法来部署web应用，你不需要编辑server.xml，除非你想改变缺省的部署特性，安装一个新的Web应用时不需要重启动Tomcat。</p>
<p>l         采用GUI管理界面进行发布</p>
<p>如果提供了该Web应用的/*.war文件，直接浏览并发布它</p>
<p>如果Web应用是以目录形式存在的，则可以：</p>
<p><strong>五、Tomcat服务器的Web安全的解决方法</strong></p>
<hr>
<p><strong>1、概述</strong></p>
<p>在任何一种WEB应用开发中，不论大中小规模的，每个开发者都会遇到一些需要保护程序数据的问题，涉及到用户的LOGIN ID和PASSWORD。那么如何执行验证方式更好呢？实际上，有很多方式来实现。</p>
<p>下面将讨论在Tomcat中实现基本的（BASIC）和基于表单的（FORM-BASED）验证方式。它通过server.xml和web.xml文件提供基本的和基于表单的验证。</p>
<p>对于采用基于表单的（FORM-BASED）验证方式，只是要求在登录的JSP页面中的j_security_check 表单(for FORM-based) 需要两个参数：j_username和j_password。</p>
<p>对于用户的登录的名称和密码在Tomcat中可以以两种形式来存放，一是采用server.xml；另一种也可以采用用户自己的数据库表来存储。</p>
<hr>
<p><strong>2、设计系统中的各种人员的角色</strong></p>
<hr>
<p><strong>（1）设计思想</strong></p>
<p>l         统一用户管理，实现基于角色、粗粒度（基于URL）和细粒度（基于应用组件的方法调用）的访问策略管理体系，</p>
<p>l         基于分级角色的权限管理、统一证书管理和统一资源管理</p>
<hr>
<p><strong>（2）设计目标</strong></p>
<p>一般采用数据库表（对于复杂的也可以采用LDAP）记录每个系统用户的帐号信息、功能权限和数据权限信息，这样能够增加用户管理和权限设置的灵活性，同时也避免多个用户共用一个帐号的情况。</p>
<p><strong>（3）优点</strong></p>
<hr>
<p>l         从用户角度来看，登录所有应用系统都使用唯一的用户名和口令（数字证书）同时在访问系统时，也只需要登录一次（单点登录全网漫游---SSO（Single Sign-On））。</p>
<p>l        从管理者角度来看，提供了统一、集中、有效的用户管理。</p>
<p><strong>七、在Tomcat中采用基于表单的安全验证</strong></p>
<hr>
<p><strong>1、概述</strong></p>
<hr>
<p><strong>（1）基于表单的验证</strong></p>
<p>基于From的安全认证可以通过Tomcat Server对Form表单中所提供的数据进行验证，基于表单的验证使系统开发者可以自定义用户的登陆页面和报错页面。这种验证方法与基本HTTP的验证方法的唯一区别就在于它可以根据用户的要求制定登陆和出错页面。</p>
<p>通过拦截并检查用户的请求，检查用户是否在应用系统中已经创建好login session。如果没有，则将用户转向到认证服务的登录页面。但在Tomcat中的基于表单的验证凭证不被保护并以纯文本发送。</p>
<hr>
<p><strong>（2）在Tomcat 中的实现</strong></p>
<p>在Tomcat中，用户、用户组和角色都是在XML配置文件（C:/jakarta-tomcat-5.0.19/conf/tomcat-users.xml）中指定的，我们只需要提供一个登陆页面，包含一个名为j_security_check的Form表单，一个名为j_username的TextBox和一个名为j_password的PasswordBox，然后在/WEB-INF/web.xml中配置即可使用Tomcat默认的JAAS身份验证。</p>
<p>使用JAAS验证的好处是，验证逻辑从页面中分离，对页面的限制访问是通过/WEB-INF/web.xml中的配置指定的，无需自定义过滤器。</p>
<hr>
<p><strong>（3）为了实现Web应用程序的安全，Tomcat Web容器执行下面的步骤：</strong></p>
<p>l         在受保护的Web资源被访问时，判断用户是否被认证。</p>
<p>l         如果用户没有得到认证，则通过重定向到部署描述符中定义的注册页面，要求用户提供安全信任状。</p>
<p>l         根据为该容器配置的安全领域，确认用户的信任状有效。</p>
<p>l         判断得到认证的用户是否被授权访问部署描述符（web.xml）中定义的Web资源。<em>**</em></p>
<hr>
<hr>
<p><strong>2、设计步骤</strong></p>
<hr>
<hr>
<p><strong>（1）编写登录页面和错误处理页面：</strong>请见FormSafeWebApp 程序中的页面</p>
<hr>
<hr>
<hr>
<p><strong>（2）登录的页面文件的内容如下</strong></p>
<p>基于FORM的用户认证要求你返回一个包括用户名和密码的HTML表单，这个表单相对应与用户名和密码的元素必须是j_username和j_password，并且表单的action描述必须为j_security_check（其实是一个Servlet）。该表单的具体操作以及j_username和j_password名字在Servlet中定义。当这个表单到达服务器的时候，由内部的Tomcat Server安全区对它进行确认。</p>
<p>包括这个表单的资源可以是一个HTML页面、一个JSP页面或者一个Servlet。你可以在<form-login-page>元素中定义。基于表单的认证能够使开发人员定制认证的用户界面。在web.xml的login-config标签项目定义了认证机制的类型、登录的URI和错误页面。</p>
<p>下面为该页面的内容：</p>
<p>&lt;%@ page contentType=&quot;text/html; charset=GBK&quot; %&gt;</p>
<p><strong>注意：</strong>action应该为j_security_check<html><head><title>在Tomcat 中采用Form 验证方式实现的安全Web应用程序的登录页</title></p>
<p></head><body bgcolor="/#ffffff"></p>
<form method="post" name="Login" **action="j_security_check"**>

<p><table width="500" border="1" align="center"> <tr></p>
<p><strong>注意：</strong>用户名称和密码的输入应该为j_username 和j_password    <td colspan="2"> <div align="center"><strong>在Tomcat中采用</strong><strong>基于表单的安全验证的登录表单 </strong> </div></td> </tr></p>
  <tr><td width="224"><div align="right">用户名称：</div></td>

    <td width="260"><input type="text" **name="j_username"**></td> </tr>

  <tr> <td><div align="right">密码：</div></td>

<td><input type="password" **name="j_password"**></td>

  </tr>

<p>  <tr><td><div align="right"><input type="submit" name="Submit" value="提交"></p>
<pre><code>&lt;/div&gt;&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;reset&quot; name=&quot;Submit2&quot; value=&quot;重置&quot;&gt;&lt;/td&gt;
</code></pre><p>  </tr></table></form></body></html><em>**</em></p>
<hr>
<p><strong>（3）修改web.xml文件</strong></p>
<p>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</p>
<p>定义本Web应用的默认启始页面&lt;!DOCTYPE web-app PUBLIC &quot;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN&quot; &quot;<a href="http://java.sun.com/dtd/web-app_2_3.dtd&quot;&gt;" target="_blank">http://java.sun.com/dtd/web-app_2_3.dtd&quot;&gt;</a></p>
<web-app>

<pre><code>   &lt;welcome-file-list&gt;

       &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt;

    &lt;/welcome-file-list&gt;
</code></pre> <!-- Security is active on entire directory -->

<p> <strong> <security-constraint></strong></p>
<p><strong>    <display-name>Tomcat Server Form Security Constraint</display-name></strong></p>
<p><strong>    <web-resource-collection></strong></p>
<p><strong>     <web-resource-name>Protected Area</web-resource-name></strong></p>
<p><strong>      <description>A Page of Login Success</description></strong></p>
<p><strong>       <url-pattern>/ProtectedDirOne/index.jsp</url-pattern></strong></p>
<p><strong>      </web-resource-collection></strong></p>
<p><strong>    <auth-constraint></strong></p>
<p>指定Form验证的用户的角色名称<strong>      <!-- Anyone with one of the listed roles may access this area --></strong></p>
<p><strong>      <role-name>admin</role-name></strong></p>
<p><strong>    </auth-constraint></strong></p>
<p>指定验证的方式为Form<strong>  </security-constraint></strong></p>
<p><strong>  <!-- Login configuration uses form-based authentication --></strong></p>
<p><strong>  <login-config></strong></p>
<p><strong>    <auth-method>FORM</auth-method></strong></p>
<p><strong>    <realm-name>Tomcat Server Configuration Form-Based Authentication Area</realm-name></strong></p>
<p><strong>    <form-login-config></strong></p>
<p><strong>             <form-login-page>/login.jsp </form-login-page></strong></p>
<p><strong>              <form-error-page>/Error.htm </form-error-page></strong></p>
<hr>
<p><strong>    </form-login-config></strong></p>
<p><strong>  </login-config></strong></p>
<p><strong>  <!-- Security roles referenced by this web application --></strong></p>
<p><strong>  <security-role></strong></p>
<p>关联Tomcat中的admin的角色<strong>    <description></strong></p>
<p><strong>      The role is Administration</strong></p>
<p><strong>    </description></strong></p>
<p><strong>    <role-name>admin</role-name></strong></p>
<p><strong>  </security-role></strong></p>
<p></web-app></p>
<hr>
<p><strong>（4）在C:/jakarta-tomcat-5.0.19/conf/tomcat-users.xml文件</strong>中配置admin的角色以及与该 admin角色相匹配的用户名称和密码</p>
<hr>
<hr>
<p><strong>（5）执行该页面</strong></p>
<p>在浏览器中直接输入受保护的页面的URL地址：</p>
<p><a href="http://127.0.0.1:8080/FormSafeWebApp/ProtectedDirOne/" target="_blank"><a href="http://127.0.0.1:8080/FormSafeWebApp/ProtectedDirOne/">http://127.0.0.1:8080/FormSafeWebApp/ProtectedDirOne/</a></a>，将出现要求登录的页面。</p>
<hr>
<p>在表单中输入用户名称为admin（前面在tomcat-users.xml文件中所设置的某一用户名称），密码为12345678。然后点击“提交”，将出现如下页面</p>
<p>如果用户名称或者密码输入不正确，将出现如下的页面也就是错误页面</p>
<p><strong>（6）在页面中获得当前登录成功后的用户名称和实体名称</strong></p>
<pre><code>   利用request对象中的getRemoteUser()方法获得当前登录成功后的用户名称和利用getUserPrincipal()方法获得当前登录成功后的实体名称。
</code></pre><hr>
<hr>
<p><strong>八、在Tomcat中配置单点登录（Single Sign-On）</strong></p>
<hr>
<p><strong>1、概述</strong></p>
<p>一旦你设置了realm和验证的方法，你就需要进行实际的用户登录处理。一般说来，对用户而言登录系统是一件很麻烦的事情，你必须尽量减少用户登录验证的次数。作为缺省的情况，当用户第一次请求受保护的资源时，每一个Web应用都会要求用户登录。</p>
<p>如果你运行了多个Web应用，并且每个应用都需要进行单独的用户验证，那这看起来就有点像你在与你的用户搏斗。用户们不知道怎样才能把多个分离的应用整合成一个单独的系统，所有他们也就不知道他们需要访问多少个不同的应用，只是很迷惑，为什么总要不停的登录。</p>
<hr>
<p><strong>2、Tomcat 中的“Single Sign-On”特性及配置</strong></p>
<p>其主要的特性是能够允许用户在访问同一虚拟主机下所有Web应用时，只需登录一次。为了使用这个功能，你只需要在C:/jakarta-tomcat-5.0.19/conf /server.xml文件中的Host标签上添加一个SingleSignOn Valve元素即可，如下所示：</p>
<Valve className="org.apache.catalina.authenticator.SingleSignOn"   debug="0"/>

<p>在Tomcat初始安装后，server.xml的注释里面包括SingleSignOn Valve配置的例子，你只需要去掉注释（<strong>在339行左右</strong>），即可使用。那么，任何用户只要登录过一个应用，则对于同一虚拟主机下的所有应用同样有效。</p>
<hr>
<p><strong>3、测试单点登录</strong></p>
<hr>
<p><strong>（1）      直接进入前面的Form验证所产生的Web应用</strong></p>
<p><strong>（<a href="http://127.0.0.1:8080/FormSafeWebApp/ProtectedDirOne/" target="_blank"><a href="http://127.0.0.1:8080/FormSafeWebApp/ProtectedDirOne/">http://127.0.0.1:8080/FormSafeWebApp/ProtectedDirOne/</a></a>）将出现要求登录的页面</strong></p>
<hr>
<hr>
<p>在表单中输入用户名称为admin（前面在tomcat-users.xml文件中所设置的某一用户名称），密码为12345678。然后点击“提交”，将以用户名admin进行成功登录该Web应用。</p>
<p>（2）再在该浏览器窗口内（不能在新窗口，否则会成为另一用户）直接输入<a href="http://127.0.0.1:8080/admin/frameset.jsp" target="_blank"><a href="http://127.0.0.1:8080/admin/frameset.jsp">http://127.0.0.1:8080/admin/frameset.jsp</a></a>，此时将以admin的用户浏览另一Web应用。观察能否直接进入Tomcat的系统管理的页面，此时应该可以并且出现下面的页面。</p>
<hr>
<pre><code>   如果新开一浏览器窗口并直接输入[http://127.0.0.1:8080/admin/frameset.jsp](http://127.0.0.1:8080/admin/frameset.jsp)，看能否直接进入Tomcat的系统管理的页面，此时将会出现要求登录的页面。
</code></pre><hr>
<hr>
<p><strong>4、使用single sign-on valve所应该注意的问题</strong></p>
<p>l         value必须被配置和嵌套在相同的Host元素里，并且所有需要进行单点验证的web应用（必须通过context元素定义）都位于该Host下。</p>
<p>l         包括共享用户信息的realm必须被设置在同一级Host中或者嵌套之外。</p>
<p>l         不能被context中的realm覆盖。</p>
<p>l         使用单点登录的web应用最好使用一个Tomcat的内置的验证方式（Basic或者Form）（被定义在web.xml中的<auth-method>中），这比自定义的验证方式强。</p>
<p>l         单点登录需要使用cookies。
来源： <a href="[http://blog.csdn.net/haojun186/article/details/7564174](http://blog.csdn.net/haojun186/article/details/7564174)">[http://blog.csdn.net/haojun186/article/details/7564174](http://blog.csdn.net/haojun186/article/details/7564174)</a> </p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/服务器/">服务器</a></li></span><span class="breadcrumb"><li><a href="/categories/服务器/">服务器</a></li><li><a href="/categories/服务器/tomcat/">tomcat</a></li></span></span> | <span class="tags">Tagged <a href="/tags/tomcat/" class="label label-primary">tomcat</a><a href="/tags/服务器/" class="label label-success">服务器</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:45"datetime="2014-03-07 09:54:45"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-服务器-tomcat--tomcat详解/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-服务器-tomcat--tomcat详解" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-服务器-Nginx--Nginx调优/">Nginx调优</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:45.000Z"> <a href="/2014/02/02/2014-02-02-服务器-Nginx--Nginx调优/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="nginx-">Nginx调优</h1>
<p>这篇文章的目的是要谈谈我的 Nginx 调优经验，就不涉及数据库调优的内容了。</p>
<h3 id="-">初始服务器设置</h3>
<p>我的服务器运行在亚马逊 EC2 t1 micro 上，选择 Nginx + PHP5-fpm 作为后端，因为一些安全因素还打开了SSL。</p>
<h3 id="-">性能测试</h3>
<p>我使用了Blitz.io 来进行压力测试。下面是我使用的命令：
1 -p</p>
<p>1-250:60 <a href="https://mydomian.com" target="_blank">https://mydomian.com</a></p>
<p>这是一个用户线性递增的测试，每个测试用户跑60秒。Blitz.io为每个请求每秒增加4个( = rise / run = 260 / 60)测试用户。</p>
<h3 id="-">结论</h3>
<p>我把结论提前写在这里，如果你不想读完整篇文章也没有问题。</p>
<ol>
<li>Nginx默认设置的DH算法（译注：Diffie-Hellman key exchange algorithm）是影响SSL性能的最大因素，因此采用如下设置能增加SSL性能：
1</li>
</ol>
<p>2
3</p>
<p>4
5 ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</p>
<p>ssl_ciphers ECDHE</p>
<p>-RSA</p>
<p>-AES256-SHA384:AES256-SHA256:RC4:HIGH:!MD5:!aNULL:!eNULL:!NULL:!DH:!EDH:!AESGCM;
ssl_prefer_server_ciphers on;</p>
<p>ssl_session_cache shared:SSL:10m;
ssl_session_timeout 10m;</p>
<ol>
<li>升级硬件 Upgrade your EC2 from t1.micro to c1.medium</li>
<li>正确配置 Nginx的worker进程数量 Set Nginx to have 2 worker processes as a c1.medium gives you 2 CPUs</li>
</ol>
<h3 id="-">细节解释</h3>
<p>以下是我进行测试的详细过程。</p>
<p><strong>尝试1：升级硬件</strong></p>
<p>直觉告诉我，想解决性能问题的直接途径就是升级硬件，我把EC2实例从t1.micro升级到了为高流量而优化过的c1.medium</p>
<p>升级后的测试结果：
<img src="" alt=""></p>
<p>巅峰时服务器的hits达到50/sec，压力增加时，time-out增加，hits减少。</p>
<p><strong>尝试2：测试CPU性能</strong></p>
<p>我打开top然后重启了测试，注意到2个CPU的使用率不到13%，内存使用了300Mb，很明显硬件没有充分利用。所以我更改了nginx的设置</p>
<p>worker_processes 2;</p>
<p><strong>尝试3，4，5：调整Nginx和PHP5-fpm</strong></p>
<p>以下尝试得到的结果都和尝试1相同</p>
<p>尝试3：</p>
<p><strong>nginx.conf</strong>
1</p>
<p>2
3</p>
<p>4
5</p>
<p>6
 worker_processes 2;</p>
<p>events {
worker_connections 19000;</p>
<p>multi_accept on;
}</p>
<p>...</p>
<p>尝试4：</p>
<p><strong>nginx.conf</strong>
1</p>
<p>2
3</p>
<p>4
5</p>
<p>6
7</p>
<p>8
9</p>
<p>10
11</p>
<p>12
13</p>
<p>14
15 worker_processes 2;</p>
<p>events {
worker_connections 19000;</p>
<p>multi_accept on;
}</p>
<p>http {
gzip on;</p>
<p>gzip_disable &quot;msie6&quot;;
gzip_min_length 1000;</p>
<p>gzip_proxied expired no-cache no-store private auth;
gzip_types text/plain application/xml application/javascript text/css application/x-javascript;</p>
<p>…
}</p>
<p>...</p>
<p>尝试5：</p>
<p>在尝试4未变的情况下我更改了php5-fpm的设置：
1</p>
<p>2
3</p>
<p>4
5 pm.max_children = 160</p>
<p>pm.start_servers = 24
pm.min_spare_servers = 20</p>
<p>pm.max_spare_servers = 35
pm.max_requests = 1500</p>
<h3 id="-6-"><strong>尝试6**</strong>：在另一个服务器部署**</h3>
<p>我有一个1.5Gb RAM和8CPU的<a href="http://blog.jobbole.com/go/linode/" title="Linode" target="_blank">Linode</a>服务器，采用刚才的设置，这是我的测试结果：
<img src="" alt=""></p>
<p><a href="http://blog.jobbole.com/go/linode/" title="Linode" target="_blank">Linode</a>的服务器的结果棒极了！我的第一个直觉是难道Linode比EC2好吗。在我把我的服务迁移到Linode之前我想确保两者仅有的对性能有可能产生影响的不同被排除掉。</p>
<p><strong>尝试7：大惊喜</strong></p>
<p>我Google到Nginx在SSL上有些问题。Nginx默认使用DHE算法来产生密匙，改变这个设置应该能使它快一些。</p>
<p>这里是我参考的一些文章：</p>
<p><a href="http://matt.io/entry/ur" target="_blank">http://matt.io/entry/ur</a></p>
<p><a href="http://auxbuss.com/blog/posts/2011_06_28_ssl_session_caching_on_nginx/" target="_blank">http://auxbuss.com/blog/posts/2011_06_28_ssl_session_caching_on_nginx/</a></p>
<p>所以我更改了nginx.conf，删掉了kEDH算法
1</p>
<p>2
3</p>
<p>4
5</p>
<p>6
7</p>
<p>8
9</p>
<p>10
11</p>
<p>12
13</p>
<p>14
15 worker_processes 2;</p>
<p>events {
worker_connections 1024;</p>
<p>}
http {</p>
<p>gzip on;
gzip_disable &quot;msie6&quot;;</p>
<p>gzip_min_length 1000;
gzip_proxied expired no-cache no-store private auth;</p>
<p>gzip_types text/plain application/xml application/javascript text/css application/x-javascript;
ssl_ciphers ALL:!kEDH!ADH:RC4+RSA:+HIGH:+EXP;</p>
<p>…
}</p>
<p>...</p>
<p>下图是测试结果：</p>
<p><img src="" alt=""></p>
<p>效果很显著！</p>
<p><strong>尝试8： 硬件提升是必要的吗</strong></p>
<p>现在我的EC2和Linode表现差不多了。但是我真的需要升级到c1.medium实例才能实现这个性能的提升吗？或许不是这样……所以我把我改回了t1.micro。因为t1.micro实例只有一个CPU，所以我把worder_processes设置改回1。下面是测试的结果：</p>
<p><img src="" alt=""></p>
<p>所以答案是肯定的，硬件上的提升是必要的。</p>
<p><strong>尝试9：</strong></p>
<p>有人在 Hacker News 上反馈说我的SSL密匙不能满足Perfect Forward Secrecy，我采用了他们的建议，对我的SSL设置做了如下更改：
1</p>
<p>2
3</p>
<p>4
5 ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</p>
<p>ssl_ciphers ECDHE-RSA-AES256-SHA384:AES256-SHA256:RC4:HIGH:!MD5:!aNULL:!eNULL:!NULL:!DH:!EDH:!AESGCM;
ssl_prefer_server_ciphers on;</p>
<p>ssl_session_cache shared:SSL:10m;
ssl_session_timeout 10m;</p>
<p>现在这个设置应该满足Perfect Forward Secrecy协议了。我重新跑了测试：</p>
<p><strong><a href="http://techsamurais.com/wp-content/uploads/2013/08/attempt10.png" title="Nginx SSL性能调优" target="_blank"><img src="" alt="attempt10"></a></strong></p>
<p>太棒了，性能也没有下降。很棒的学习经验！</p>
<p>来源： &lt;<a href="http://blog.jobbole.com/44844/" target="_blank">Nginx SSL性能调优 - 博客 - 伯乐在线</a>&gt; </p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/服务器/">服务器</a></li></span><span class="breadcrumb"><li><a href="/categories/服务器/">服务器</a></li><li><a href="/categories/服务器/Nginx/">Nginx</a></li></span></span> | <span class="tags">Tagged <a href="/tags/Nginx/" class="label label-primary">Nginx</a><a href="/tags/服务器/" class="label label-success">服务器</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:45"datetime="2014-03-07 09:54:45"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-服务器-Nginx--Nginx调优/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-服务器-Nginx--Nginx调优" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-服务器-tomcat--Servlet工作原理/">Servlet工作原理</a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:45.000Z"> <a href="/2014/02/02/2014-02-02-服务器-tomcat--Servlet工作原理/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="servlet-">Servlet工作原理</h1>
<p><a href="http://blog.csdn.net/haojun186/article/details/7467100" target="_blank">Servlet工作原理</a></p>
<p><a href="">从 Servlet 容器说起</a></p>
<p>要介绍 Servlet 必须要先把 Servlet 容器说清楚，Servlet 与 Servlet 容器的关系有点像枪和子弹的关系，枪是为子弹而生，而子弹又让枪有了杀伤力。虽然它们是彼此依存的，但是又相互独立发展，这一切都是为了适应工业化生产的结果。从技术角度来说是为了解耦，通过标准化接口来相互协作。既然接口是连接 Servlet 与 Servlet 容器的关键，那我们就从它们的接口说起。</p>
<p>前面说了 Servlet 容器作为一个独立发展的标准化产品，目前它的种类很多，但是它们都有自己的市场定位，很难说谁优谁劣，各有特点。例如现在比较流行的 Jetty，在定制化和移动领域有不错的发展，我们这里还是以大家最为熟悉 Tomcat 为例来介绍 Servlet 容器如何管理 Servlet。Tomcat 本身也很复杂，我们只从 Servlet 与 Servlet 容器的接口部分开始介绍，关于 Tomcat 的详细介绍可以参考我的另外一篇文章《 Tomcat 系统架构与模式设计分析》。</p>
<p>Tomcat 的容器等级中，Context 容器是直接管理 Servlet 在容器中的包装类 Wrapper，所以 Context 容器如何运行将直接影响 Servlet 的工作方式。
<a href=""><strong>图 1 . Tomcat 容器模型</strong></a>
<img src="" alt="图 1 . Tomcat 容器模型"></p>
<p>从上图可以看出 Tomcat 的容器分为四个等级，真正管理 Servlet 的容器是 Context 容器，一个 Context 对应一个 Web 工程，在 Tomcat 的配置文件中可以很容易发现这一点，如下：
<a href=""><strong>清单 1 Context 配置参数</strong></a></p>
<Context path="/projectOne " docBase="D:\projects\projectOne"
reloadable="true" />

<p>下面详细介绍一下 Tomcat 解析 Context 容器的过程，包括如何构建 Servlet 的过程。</p>
<p><a href="">Servlet 容器的启动过程</a></p>
<p>Tomcat7 也开始支持嵌入式功能，增加了一个启动类 org.apache.catalina.startup.Tomcat。创建一个实例对象并调用 start 方法就可以很容易启动 Tomcat，我们还可以通过这个对象来增加和修改 Tomcat 的配置参数，如可以动态增加 Context、Servlet 等。下面我们就利用这个 Tomcat 类来管理新增的一个 Context 容器，我们就选择 Tomcat7 自带的 examples Web 工程，并看看它是如何加到这个 Context 容器中的。
<a href=""><strong>清单 2 . 给 Tomcat 增加一个 Web 工程</strong></a></p>
<p>Tomcat tomcat = getTomcatInstance();
File appDir = new File(getBuildDirectory(), &quot;webapps/examples&quot;);</p>
<p>tomcat.addWebapp(null, &quot;/examples&quot;, appDir.getAbsolutePath());
tomcat.start();</p>
<p>ByteChunk res = getUrl(&quot;<a href="http://localhost" target="_blank">http://localhost</a>:&quot; + getPort() +
               &quot;/examples/servlets/servlet/HelloWorldExample&quot;);</p>
<p>assertTrue(res.toString().indexOf(&quot;<h1>Hello World!</h1>&quot;) &gt; 0);</p>
<p>清单 1 的代码是创建一个 Tomcat 实例并新增一个 Web 应用，然后启动 Tomcat 并调用其中的一个 HelloWorldExample Servlet，看有没有正确返回预期的数据。</p>
<p>Tomcat 的 addWebapp 方法的代码如下：
<a href=""><strong>清单 3 .Tomcat.addWebapp</strong></a></p>
<p>public Context addWebapp(Host host, String url, String path) {
        silence(url);</p>
<pre><code>    Context ctx = new StandardContext();
    ctx.setPath( url );

    ctx.setDocBase(path);
    if (defaultRealm == null) {

        initSimpleAuth();
    }

    ctx.setRealm(defaultRealm);
    ctx.addLifecycleListener(new DefaultWebXmlListener());

    ContextConfig ctxCfg = new ContextConfig();
    ctx.addLifecycleListener(ctxCfg);

    ctxCfg.setDefaultWebXml(&quot;org/apache/catalin/startup/NO_DEFAULT_XML&quot;);
    if (host == null) {

        getHost().addChild(ctx);
    } else {

        host.addChild(ctx);
    }

    return ctx;
</code></pre><p>}</p>
<p>前面已经介绍了一个 Web 应用对应一个 Context 容器，也就是 Servlet 运行时的 Servlet 容器，添加一个 Web 应用时将会创建一个 StandardContext 容器，并且给这个 Context 容器设置必要的参数，url 和 path 分别代表这个应用在 Tomcat 中的访问路径和这个应用实际的物理路径，这个两个参数与清单 1 中的两个参数是一致的。其中最重要的一个配置是 ContextConfig，这个类将会负责整个 Web 应用配置的解析工作，后面将会详细介绍。最后将这个 Context 容器加到父容器 Host 中。</p>
<p>接下去将会调用 Tomcat 的 start 方法启动 Tomcat，如果你清楚 Tomcat 的系统架构，你会容易理解 Tomcat 的启动逻辑，Tomcat 的启动逻辑是基于观察者模式设计的，所有的容器都会继承 Lifecycle 接口，它管理者容器的整个生命周期，所有容器的的修改和状态的改变都会由它去通知已经注册的观察者（Listener），关于这个设计模式可以参考《 Tomcat 的系统架构与设计模式，第二部分：设计模式》。Tomcat 启动的时序图可以用图 2 表示。
<a href=""><strong>图 2. Tomcat 主要类的启动时序图（</strong></a><strong><a href="http://www.ibm.com/developerworks/cn/java/j-lo-servlet/image003.jpg" target="_blank">查看大图</a>）</strong>
<img src="" alt="图 2. Tomcat 主要类的启动时序图"></p>
<p>上图描述了 Tomcat 启动过程中，主要类之间的时序关系，下面我们将会重点关注添加 examples 应用所对应的 StandardContext 容器的启动过程。</p>
<p>当 Context 容器初始化状态设为 init 时，添加在 Contex 容器的 Listener 将会被调用。ContextConfig 继承了 LifecycleListener 接口，它是在调用清单 3 时被加入到 StandardContext 容器中。ContextConfig 类会负责整个 Web 应用的配置文件的解析工作。</p>
<p>ContextConfig 的 init 方法将会主要完成以下工作：</p>
<ol>
<li>创建用于解析 xml 配置文件的 contextDigester 对象</li>
<li>读取默认 context.xml 配置文件，如果存在解析它</li>
<li>读取默认 Host 配置文件，如果存在解析它</li>
<li>读取默认 Context 自身的配置文件，如果存在解析它</li>
<li>设置 Context 的 DocBase</li>
</ol>
<p>ContextConfig 的 init 方法完成后，Context 容器的会执行 startInternal 方法，这个方法启动逻辑比较复杂，主要包括如下几个部分：</p>
<ol>
<li>创建读取资源文件的对象</li>
<li>创建 ClassLoader 对象</li>
<li>设置应用的工作目录</li>
<li>启动相关的辅助类如：logger、realm、resources 等</li>
<li>修改启动状态，通知感兴趣的观察者（Web 应用的配置）</li>
<li>子容器的初始化</li>
<li>获取 ServletContext 并设置必要的参数</li>
<li>初始化“load on startup”的 Servlet</li>
</ol>
<p><a href="">Web 应用的初始化工作</a></p>
<p>Web 应用的初始化工作是在 ContextConfig 的 configureStart 方法中实现的，应用的初始化主要是要解析 web.xml 文件，这个文件描述了一个 Web 应用的关键信息，也是一个 Web 应用的入口。</p>
<p>Tomcat 首先会找 globalWebXml 这个文件的搜索路径是在 engine 的工作目录下寻找以下两个文件中的任一个 org/apache/catalin/startup/NO_DEFAULT_XML 或 conf/web.xml。接着会找 hostWebXml 这个文件可能会在 System.getProperty(&quot;catalina.base&quot;)/conf/${EngineName}/${HostName}/web.xml.default，接着寻找应用的配置文件 examples/WEB-INF/web.xml。web.xml 文件中的各个配置项将会被解析成相应的属性保存在 WebXml 对象中。如果当前应用支持 Servlet3.0，解析还将完成额外 9 项工作，这个额外的 9 项工作主要是为 Servlet3.0 新增的特性，包括 jar 包中的 META-INF/web-fragment.xml 的解析以及对 annotations 的支持。</p>
<p>接下去将会将 WebXml 对象中的属性设置到 Context 容器中，这里包括创建 Servlet 对象、filter、listener 等等。这段代码在 WebXml 的 configureContext 方法中。下面是解析 Servlet 的代码片段：
<a href=""><strong>清单 4. 创建 Wrapper 实例</strong></a></p>
<p>for (ServletDef servlet : servlets.values()) {
            Wrapper wrapper = context.createWrapper();</p>
<pre><code>        String jspFile = servlet.getJspFile();
        if (jspFile != null) {

            wrapper.setJspFile(jspFile);
        }

        if (servlet.getLoadOnStartup() != null) {
            wrapper.setLoadOnStartup(servlet.getLoadOnStartup().intValue());

        }
        if (servlet.getEnabled() != null) {

            wrapper.setEnabled(servlet.getEnabled().booleanValue());
        }

        wrapper.setName(servlet.getServletName());
        Map&lt;String,String&gt; params = servlet.getParameterMap();

        for (Entry&lt;String, String&gt; entry : params.entrySet()) {
            wrapper.addInitParameter(entry.getKey(), entry.getValue());

        }
        wrapper.setRunAs(servlet.getRunAs());

        Set&lt;SecurityRoleRef&gt; roleRefs = servlet.getSecurityRoleRefs();
        for (SecurityRoleRef roleRef : roleRefs) {

            wrapper.addSecurityReference(
                    roleRef.getName(), roleRef.getLink());

        }
        wrapper.setServletClass(servlet.getServletClass());

        MultipartDef multipartdef = servlet.getMultipartDef();
        if (multipartdef != null) {

            if (multipartdef.getMaxFileSize() != null &amp;&amp;
                    multipartdef.getMaxRequestSize()!= null &amp;&amp;

                    multipartdef.getFileSizeThreshold() != null) {
                wrapper.setMultipartConfigElement(new
</code></pre><p>MultipartConfigElement(
                            multipartdef.getLocation(),</p>
<pre><code>                        Long.parseLong(multipartdef.getMaxFileSize()),
                        Long.parseLong(multipartdef.getMaxRequestSize()),

                        Integer.parseInt(
                                multipartdef.getFileSizeThreshold())));

            } else {
                wrapper.setMultipartConfigElement(new
</code></pre><p>MultipartConfigElement(
                            multipartdef.getLocation()));</p>
<pre><code>            }
        }

        if (servlet.getAsyncSupported() != null) {
            wrapper.setAsyncSupported(

                    servlet.getAsyncSupported().booleanValue());
        }

        context.addChild(wrapper);
</code></pre><p>}</p>
<p>这段代码清楚的描述了如何将 Servlet 包装成 Context 容器中的 StandardWrapper，这里有个疑问，为什么要将 Servlet 包装成 StandardWrapper 而不直接是 Servlet 对象。这里 StandardWrapper 是 Tomcat 容器中的一部分，它具有容器的特征，而 Servlet 为了一个独立的 web 开发标准，不应该强耦合在 Tomcat 中。</p>
<p>除了将 Servlet 包装成 StandardWrapper 并作为子容器添加到 Context 中，其它的所有 web.xml 属性都被解析到 Context 中，所以说 Context 容器才是真正运行 Servlet 的 Servlet 容器。一个 Web 应用对应一个 Context 容器，容器的配置属性由应用的 web.xml 指定，这样我们就能理解 web.xml 到底起到什么作用了。</p>
<p><a href="http://www.ibm.com/developerworks/cn/java/j-lo-servlet/#ibm-pcon" target="_blank">回页首</a></p>
<p><a href="">创建 Servlet 实例</a></p>
<p>前面已经完成了 Servlet 的解析工作，并且被包装成 StandardWrapper 添加在 Context 容器中，但是它仍然不能为我们工作，它还没有被实例化。下面我们将介绍 Servlet 对象是如何创建的，以及如何被初始化的。</p>
<p><a href="">创建 Servlet 对象</a></p>
<p>如果 Servlet 的 load-on-startup 配置项大于 0，那么在 Context 容器启动的时候就会被实例化，前面提到在解析配置文件时会读取默认的 globalWebXml，在 conf 下的 web.xml 文件中定义了一些默认的配置项，其定义了两个 Servlet，分别是：org.apache.catalina.servlets.DefaultServlet 和 org.apache.jasper.servlet.JspServlet 它们的 load-on-startup 分别是 1 和 3，也就是当 Tomcat 启动时这两个 Servlet 就会被启动。</p>
<p>创建 Servlet 实例的方法是从 Wrapper. loadServlet 开始的。loadServlet 方法要完成的就是获取 servletClass 然后把它交给 InstanceManager 去创建一个基于 servletClass.class 的对象。如果这个 Servlet 配置了 jsp-file，那么这个 servletClass 就是 conf/web.xml 中定义的 org.apache.jasper.servlet.JspServlet 了。</p>
<p>创建 Servlet 对象的相关类结构图如下：
<a href=""><strong>图 3. 创建 Servlet 对象的相关类结构</strong></a>
<img src="" alt="图 3. 创建 Servlet 对象的相关类结构"></p>
<p><a href="">初始化 Servlet</a></p>
<p>初始化 Servlet 在 StandardWrapper 的 initServlet 方法中，这个方法很简单就是调用 Servlet 的 init 的方法，同时把包装了 StandardWrapper 对象的 StandardWrapperFacade 作为 ServletConfig 传给 Servlet。Tomcat 容器为何要传 StandardWrapperFacade 给 Servlet 对象将在后面做详细解析。</p>
<p>如果该 Servlet 关联的是一个 jsp 文件，那么前面初始化的就是 JspServlet，接下去会模拟一次简单请求，请求调用这个 jsp 文件，以便编译这个 jsp 文件为 class，并初始化这个 class。</p>
<p>这样 Servlet 对象就初始化完成了，事实上 Servlet 从被 web.xml 中解析到完成初始化，这个过程非常复杂，中间有很多过程，包括各种容器状态的转化引起的监听事件的触发、各种访问权限的控制和一些不可预料的错误发生的判断行为等等。我们这里只抓了一些关键环节进行阐述，试图让大家有个总体脉络。</p>
<p>下面是这个过程的一个完整的时序图，其中也省略了一些细节。
<a href=""><strong>图 4. 初始化 Servlet 的时序图（</strong></a><strong><a href="http://www.ibm.com/developerworks/cn/java/j-lo-servlet/image007.jpg" target="_blank">查看大图</a>）</strong>
<img src="" alt="图 4. 初始化 Servlet 的时序图"></p>
<p><a href="http://www.ibm.com/developerworks/cn/java/j-lo-servlet/#ibm-pcon" target="_blank">回页首</a></p>
<p><a href="">Servlet 体系结构</a></p>
<p>我们知道 Java Web 应用是基于 Servlet 规范运转的，那么 Servlet 本身又是如何运转的呢？为何要设计这样的体系结构。
<a href=""><strong>图 5.Servlet 顶层类关联图</strong></a>
<img src="" alt="图 5.Servlet 顶层类关联图"></p>
<p>从上图可以看出 Servlet 规范就是基于这几个类运转的，与 Servlet 主动关联的是三个类，分别是 ServletConfig、ServletRequest 和 ServletResponse。这三个类都是通过容器传递给 Servlet 的，其中 ServletConfig 是在 Servlet 初始化时就传给 Servlet 了，而后两个是在请求达到时调用 Servlet 时传递过来的。我们很清楚 ServletRequest 和 ServletResponse 在 Servlet 运行的意义，但是 ServletConfig 和 ServletContext 对 Servlet 有何价值？仔细查看 ServletConfig 接口中声明的方法发现，这些方法都是为了获取这个 Servlet 的一些配置属性，而这些配置属性可能在 Servlet 运行时被用到。而 ServletContext 又是干什么的呢？ Servlet 的运行模式是一个典型的“握手型的交互式”运行模式。所谓“握手型的交互式”就是两个模块为了交换数据通常都会准备一个交易场景，这个场景一直跟随个这个交易过程直到这个交易完成为止。这个交易场景的初始化是根据这次交易对象指定的参数来定制的，这些指定参数通常就会是一个配置类。所以对号入座，交易场景就由 ServletContext 来描述，而定制的参数集合就由 ServletConfig 来描述。而 ServletRequest 和 ServletResponse 就是要交互的具体对象了，它们通常都是作为运输工具来传递交互结果。</p>
<p>ServletConfig 是在 Servlet init 时由容器传过来的，那么 ServletConfig 到底是个什么对象呢？</p>
<p>下图是 ServletConfig 和 ServletContext 在 Tomcat 容器中的类关系图。
<a href=""><strong>图 6. ServletConfig 在容器中的类关联图</strong></a>
<img src="" alt="图 6. ServletConfig 在容器中的类关联图"></p>
<p>上图可以看出 StandardWrapper 和 StandardWrapperFacade 都实现了 ServletConfig 接口，而 StandardWrapperFacade 是 StandardWrapper 门面类。所以传给 Servlet 的是 StandardWrapperFacade 对象，这个类能够保证从 StandardWrapper 中拿到 ServletConfig 所规定的数据，而又不把 ServletConfig 不关心的数据暴露给 Servlet。</p>
<p>同样 ServletContext 也与 ServletConfig 有类似的结构，Servlet 中能拿到的 ServletContext 的实际对象也是 ApplicationContextFacade 对象。ApplicationContextFacade 同样保证 ServletContex 只能从容器中拿到它该拿的数据，它们都起到对数据的封装作用，它们使用的都是门面设计模式。</p>
<p>通过 ServletContext 可以拿到 Context 容器中一些必要信息，比如应用的工作路径，容器支持的 Servlet 最小版本等。</p>
<p>Servlet 中定义的两个 ServletRequest 和 ServletResponse 它们实际的对象又是什么呢？，我们在创建自己的 Servlet 类时通常使用的都是 HttpServletRequest 和 HttpServletResponse，它们继承了 ServletRequest 和 ServletResponse。为何 Context 容器传过来的 ServletRequest、ServletResponse 可以被转化为 HttpServletRequest 和 HttpServletResponse 呢？
<a href=""><strong>图 7.Request 相关类结构图</strong></a>
<img src="" alt="图 7.Request 相关类结构图"></p>
<p>上图是 Tomcat 创建的 Request 和 Response 的类结构图。Tomcat 一接受到请求首先将会创建 org.apache.coyote.Request 和 org.apache.coyote.Response，这两个类是 Tomcat 内部使用的描述一次请求和相应的信息类它们是一个轻量级的类，它们作用就是在服务器接收到请求后，经过简单解析将这个请求快速的分配给后续线程去处理，所以它们的对象很小，很容易被 JVM 回收。接下去当交给一个用户线程去处理这个请求时又创建 org.apache.catalina.connector. Request 和 org.apache.catalina.connector. Response 对象。这两个对象一直穿越整个 Servlet 容器直到要传给 Servlet，传给 Servlet 的是 Request 和 Response 的门面类 RequestFacade 和 RequestFacade，这里使用门面模式与前面一样都是基于同样的目的——封装容器中的数据。一次请求对应的 Request 和 Response 的类转化如下图所示：
<a href=""><strong>图 8.Request 和 Response 的转变过程</strong></a>
<img src="" alt="图 8.Request 和 Response 的转变过程"></p>
<p><a href="http://www.ibm.com/developerworks/cn/java/j-lo-servlet/#ibm-pcon" target="_blank">回页首</a></p>
<p><a href="">Servlet 如何工作</a></p>
<p>我们已经清楚了 Servlet 是如何被加载的、Servlet 是如何被初始化的，以及 Servlet 的体系结构，现在的问题就是它是如何被调用的。</p>
<p>当用户从浏览器向服务器发起一个请求，通常会包含如下信息：<a href="http://hostname" target="_blank">http://hostname</a>: port /contextpath/servletpath，hostname 和 port 是用来与服务器建立 TCP 连接，而后面的 URL 才是用来选择服务器中那个子容器服务用户的请求。那服务器是如何根据这个 URL 来达到正确的 Servlet 容器中的呢？</p>
<p>Tomcat7.0 中这件事很容易解决，因为这种映射工作有专门一个类来完成的，这个就是 org.apache.tomcat.util.http.mapper，这个类保存了 Tomcat 的 Container 容器中的所有子容器的信息，当 org.apache.catalina.connector. Request 类在进入 Container 容器之前，mapper 将会根据这次请求的 hostnane 和 contextpath 将 host 和 context 容器设置到 Request 的 mappingData 属性中。所以当 Request 进入 Container 容器之前，它要访问那个子容器这时就已经确定了。
<a href=""><strong>图 9.Request 的 Mapper 类关系图</strong></a>
<img src="" alt="图 9.Request 的 Mapper 类关系图"></p>
<p>可能你有疑问，mapper 中怎么会有容器的完整关系，这要回到图 2 中 19 步 MapperListener 类的初始化过程，下面是 MapperListener 的 init 方法代码 :
<a href=""><strong>清单 5. MapperListener.init</strong></a></p>
<p>public void init() {
        findDefaultHost();</p>
<pre><code>    Engine engine = (Engine) connector.getService().getContainer();
    engine.addContainerListener(this);

    Container[] conHosts = engine.findChildren();
    for (Container conHost : conHosts) {

        Host host = (Host) conHost;
        if (!LifecycleState.NEW.equals(host.getState())) {

            host.addLifecycleListener(this);
            registerHost(host);

        }
    }
</code></pre><p>}</p>
<p>这段代码的作用就是将 MapperListener 类作为一个监听者加到整个 Container 容器中的每个子容器中，这样只要任何一个容器发生变化，MapperListener 都将会被通知，相应的保存容器关系的 MapperListener 的 mapper 属性也会修改。for 循环中就是将 host 及下面的子容器注册到 mapper 中。
<a href=""><strong>图 10.Request 在容器中的路由图</strong></a>
<img src="" alt="图 10.Request 在容器中的路由图"></p>
<p>上图描述了一次 Request 请求是如何达到最终的 Wrapper 容器的，我们现正知道了请求是如何达到正确的 Wrapper 容器，但是请求到达最终的 Servlet 还要完成一些步骤，必须要执行 Filter 链，以及要通知你在 web.xml 中定义的 listener。</p>
<p>接下去就要执行 Servlet 的 service 方法了，通常情况下，我们自己定义的 servlet 并不是直接去实现 javax.servlet.servlet 接口，而是去继承更简单的 HttpServlet 类或者 GenericServlet 类，我们可以有选择的覆盖相应方法去实现我们要完成的工作。</p>
<p>Servlet 的确已经能够帮我们完成所有的工作了，但是现在的 web 应用很少有直接将交互全部页面都用 servlet 来实现，而是采用更加高效的 MVC 框架来实现。这些 MVC 框架基本的原理都是将所有的请求都映射到一个 Servlet，然后去实现 service 方法，这个方法也就是 MVC 框架的入口。</p>
<p>当 Servlet 从 Servlet 容器中移除时，也就表明该 Servlet 的生命周期结束了，这时 Servlet 的 destroy 方法将被调用，做一些扫尾工作。</p>
<p><a href="http://www.ibm.com/developerworks/cn/java/j-lo-servlet/#ibm-pcon" target="_blank">回页首</a></p>
<p><a href="">Session 与 Cookie</a></p>
<p>前面我们已经说明了 Servlet 如何被调用，我们基于 Servlet 来构建应用程序，那么我们能从 Servlet 获得哪些数据信息呢？</p>
<p>Servlet 能够给我们提供两部分数据，一个是在 Servlet 初始化时调用 init 方法时设置的 ServletConfig，这个类基本上含有了 Servlet 本身和 Servlet 所运行的 Servlet 容器中的基本信息。根据前面的介绍 ServletConfig 的实际对象是 StandardWrapperFacade，到底能获得哪些容器信息可以看看这类提供了哪些接口。还有一部分数据是由 ServletRequest 类提供，它的实际对象是 RequestFacade，从提供的方法中发现主要是描述这次请求的 HTTP 协议的信息。所以要掌握 Servlet 的工作方式必须要很清楚 HTTP 协议，如果你还不清楚赶紧去找一些参考资料。关于这一块还有一个让很多人迷惑的 Session 与 Cookie。</p>
<p>Session 与 Cookie 不管是对 Java Web 的熟练使用者还是初学者来说都是一个令人头疼的东西。Session 与 Cookie 的作用都是为了保持访问用户与后端服务器的交互状态。它们有各自的优点也有各自的缺陷。然而具有讽刺意味的是它们优点和它们的使用场景又是矛盾的，例如使用 Cookie 来传递信息时，随着 Cookie 个数的增多和访问量的增加，它占用的网络带宽也很大，试想假如 Cookie 占用 200 个字节，如果一天的 PV 有几亿的时候，它要占用多少带宽。所以大访问量的时候希望用 Session，但是 Session 的致命弱点是不容易在多台服务器之间共享，所以这也限制了 Session 的使用。</p>
<p>不管 Session 和 Cookie 有什么不足，我们还是要用它们。下面详细讲一下，Session 如何基于 Cookie 来工作。实际上有三种方式能可以让 Session 正常工作：</p>
<ol>
<li>基于 URL Path Parameter，默认就支持</li>
<li>基于 Cookie，如果你没有修改 Context 容器个 cookies 标识的话，默认也是支持的</li>
<li>基于 SSL，默认不支持，只有 connector.getAttribute(&quot;SSLEnabled&quot;) 为 TRUE 时才支持</li>
</ol>
<p>第一种情况下，当浏览器不支持 Cookie 功能时，浏览器会将用户的 SessionCookieName 重写到用户请求的 URL 参数中，它的传递格式如 /path/Servlet;name=value;name2=value2? Name3=value3，其中“Servlet；”后面的 K-V 对就是要传递的 Path Parameters，服务器会从这个 Path Parameters 中拿到用户配置的 SessionCookieName。关于这个 SessionCookieName，如果你在 web.xml 中配置 session-config 配置项的话，其 cookie-config 下的 name 属性就是这个 SessionCookieName 值，如果你没有配置 session-config 配置项，默认的 SessionCookieName 就是大家熟悉的“JSESSIONID”。接着 Request 根据这个 SessionCookieName 到 Parameters 拿到 Session ID 并设置到 request.setRequestedSessionId 中。</p>
<p>请注意如果客户端也支持 Cookie 的话，Tomcat 仍然会解析 Cookie 中的 Session ID，并会覆盖 URL 中的 Session ID。</p>
<p>如果是第三种情况的话将会根据 javax.servlet.request.ssl_session 属性值设置 Session ID。</p>
<p>有了 Session ID 服务器端就可以创建 HttpSession 对象了，第一次触发是通过 request. getSession() 方法，如果当前的 Session ID 还没有对应的 HttpSession 对象那么就创建一个新的，并将这个对象加到 org.apache.catalina. Manager 的 sessions 容器中保存，Manager 类将管理所有 Session 的生命周期，Session 过期将被回收，服务器关闭，Session 将被序列化到磁盘等。只要这个 HttpSession 对象存在，用户就可以根据 Session ID 来获取到这个对象，也就达到了状态的保持。
<a href=""><strong>图 11.Session 相关类图</strong></a>
<img src="" alt="图 11.Session 相关类图"></p>
<p>上从图中可以看出从 request.getSession 中获取的 HttpSession 对象实际上是 StandardSession 对象的门面对象，这与前面的 Request 和 Servlet 是一样的原理。下图是 Session 工作的时序图：
<a href=""><strong>图 12.Session 工作的时序图（</strong></a><strong><a href="http://www.ibm.com/developerworks/cn/java/j-lo-servlet/image023.jpg" target="_blank">查看大图</a>）</strong>
<img src="" alt="图 12.Session 工作的时序图"></p>
<p>还有一点与 Session 关联的 Cookie 与其它 Cookie 没有什么不同，这个配置的配置可以通过 web.xml 中的 session-config 配置项来指定。</p>
<p><a href="http://www.ibm.com/developerworks/cn/java/j-lo-servlet/#ibm-pcon" target="_blank">回页首</a></p>
<p><a href="">Servlet 中的 Listener</a></p>
<p>整个 Tomcat 服务器中 Listener 使用的非常广泛，它是基于观察者模式设计的，Listener 的设计对开发 Servlet 应用程序提供了一种快捷的手段，能够方便的从另一个纵向维度控制程序和数据。目前 Servlet 中提供了 5 种两类事件的观察者接口，它们分别是：4 个 EventListeners 类型的，ServletContextAttributeListener、ServletRequestAttributeListener、ServletRequestListener、HttpSessionAttributeListener 和 2 个 LifecycleListeners 类型的，ServletContextListener、HttpSessionListener。如下图所示：
<a href=""><strong>图 13.Servlet 中的 Listener（</strong></a><strong><a href="http://www.ibm.com/developerworks/cn/java/j-lo-servlet/image025.png" target="_blank">查看大图</a>）</strong>
<img src="" alt="图 13.Servlet 中的 Listener"></p>
<p>它们基本上涵盖了整个 Servlet 生命周期中，你感兴趣的每种事件。这些 Listener 的实现类可以配置在 web.xml 中的 <listener> 标签中。当然也可以在应用程序中动态添加 Listener，需要注意的是 ServletContextListener 在容器启动之后就不能再添加新的，因为它所监听的事件已经不会再出现。掌握这些 Listener 的使用，能够让我们的程序设计的更加灵活。
来源： <a href="[http://blog.csdn.net/haojun186/article/details/7467100](http://blog.csdn.net/haojun186/article/details/7467100)">[http://blog.csdn.net/haojun186/article/details/7467100](http://blog.csdn.net/haojun186/article/details/7467100)</a> </p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/服务器/">服务器</a></li></span><span class="breadcrumb"><li><a href="/categories/服务器/">服务器</a></li><li><a href="/categories/服务器/tomcat/">tomcat</a></li></span></span> | <span class="tags">Tagged <a href="/tags/tomcat/" class="label label-primary">tomcat</a><a href="/tags/服务器/" class="label label-success">服务器</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:45"datetime="2014-03-07 09:54:45"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-服务器-tomcat--Servlet工作原理/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-服务器-tomcat--Servlet工作原理" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>



  <article>
<div id="post" class="post well">
  <div class="post-content">
    <header class="well-sm">
      <i class="fa icon fa-5x pull-left"></i>
      <h1 class="title"><a href="/2014/02/02/2014-02-02-ftp--被动模式下FTP的详细工作过程-大浪淘沙-51CTO技术博客/">被动模式下FTP的详细工作过程 </a></h1>
      
        <span>Posted on<time datetime="2014-02-02T01:54:45.000Z"> <a href="/2014/02/02/2014-02-02-ftp--被动模式下FTP的详细工作过程-大浪淘沙-51CTO技术博客/">feb. 2 2014</a></time></span>      
    </header>
    
    
    <div class="entry">
      
        <h1 id="-ftp-51cto-">被动模式下FTP的详细工作过程 - 大浪淘沙 - 51CTO技术博客</h1>
<h3 id="-">分享到</h3>
<ul>
<li><a href="">一键分享</a></li>
<li><a href="">QQ空间</a></li>
<li><a href="">新浪微博</a></li>
<li><a href="">百度云收藏</a></li>
<li><a href="">人人网</a></li>
<li><a href="">腾讯微博</a></li>
<li><a href="">百度相册</a></li>
<li><a href="">开心网</a></li>
<li><a href="">腾讯朋友</a></li>
<li><a href="">百度贴吧</a></li>
<li><a href="">豆瓣网</a></li>
<li><a href="">搜狐微博</a></li>
<li><a href="">百度新首页</a></li>
<li><a href="">QQ好友</a></li>
<li><a href="">和讯微博</a></li>
<li><a href="">更多...</a></li>
</ul>
<p><a href="">百度分享</a></p>
<p><a href="http://blog.51cto.com/" target="_blank"><img src="" alt=""></a><a href="http://www.51cto.com/" target="_blank">51CTO首页</a><img src="" alt=""><a href="http://blog.51cto.com/" target="_blank">51CTO博客</a><img src="" alt=""><a href="http://home.51cto.com/?reback=http://yuanbin.blog.51cto.com/363003/108009" target="_blank">我的博客</a><img src="" alt=""> <a href="http://blog.51cto.com/search.php" target="_blank">搜索</a> <a href="">每日博报</a></p>
<p><img src="" alt="">社区：<a href="http://edu.51cto.com/" target="_blank">学院</a><a href="http://bbs.51cto.com/" target="_blank">论坛</a><a href="http://blog.51cto.com/" target="_blank">博客</a><a href="http://down.51cto.com/" target="_blank">下载</a><a href="">更多<img src="" alt=""></a></p>
<p><a href="http://home.51cto.com/index.php?s=/Home/index" target="_blank"><img src="&quot;今天领无忧币了吗？&quot;" alt=""></a><a href="http://home.51cto.com/?reback=http://yuanbin.blog.51cto.com/363003/108009" target="_blank">登录</a><a href="http://ucenter.51cto.com/reg_01.php?reback=http://yuanbin.blog.51cto.com/363003/108009" target="_blank">注册</a></p>
<ul>
<li><a href="http://home.51cto.com/" target="_blank">家园</a></li>
<li><a href="http://edu.51cto.com/" target="_blank">学院</a></li>
<li><a href="http://blog.51cto.com/" target="_blank">博客</a></li>
<li><a href="http://bbs.51cto.com/" target="_blank">论坛</a></li>
<li><a href="http://down.51cto.com/" target="_blank">下载</a></li>
<li><a href="http://selftest.51cto.com/" target="_blank">自测</a></li>
<li><a href="http://doctor.51cto.com/" target="_blank">门诊</a></li>
<li><a href="http://blog.51cto.com/newsletter/" target="_blank">周刊</a></li>
<li><a href="http://book.51cto.com/" target="_blank">读书</a></li>
<li><a href="http://g.51cto.com/" target="_blank">技术圈</a></li>
</ul>
<p><a href="http://blog.51cto.com/blogcommend" target="_blank"><img src="" alt=""></a></p>
<p>[</p>
<h1 id="-">大浪淘沙</h1>
<p>](<a href="http://yuanbin.blog.51cto.com" target="_blank">http://yuanbin.blog.51cto.com</a>)</p>
<p><a href="http://yuanbin.blog.51cto.com" target="_blank"><a href="http://yuanbin.blog.51cto.com">http://yuanbin.blog.51cto.com</a></a>  <a href="">【复制】</a> <a href="http://yuanbin.blog.51cto.com/rss.php?uid=363003" target="_blank"></a><a href="http://yuanbin.blog.51cto.com/rss.php?uid=363003">【订阅】</a></p>
<p><a href="http://yuanbin.blog.51cto.com/363003/o" title="察看yuanbin0710所有原创文章" target="_blank">原创</a>:29<a href="http://yuanbin.blog.51cto.com/363003/t" title="察看yuanbin0710所有翻译文章" target="_blank">翻译</a>:0<a href="http://yuanbin.blog.51cto.com/363003/c" title="察看yuanbin0710所有转载文章" target="_blank">转载</a>:8</p>
<p><a href="">博 客</a>|<a href="http://home.51cto.com/apps/photo/index.php?s=/Index/photos/uid/363003" target="_blank">图库</a>|<a href="http://yuanbin.blog.51cto.com/addblog.php" target="_blank">写博文</a>|<a href="http://51ctoblog.blog.51cto.com/all/26414/4" target="_blank">帮 助</a></p>
<ul>
<li><a href="">首页</a>|</li>
<li><a href="http://yuanbin.blog.51cto.com/363003/d-1" target="_blank">Linux System</a>|</li>
<li><a href="http://yuanbin.blog.51cto.com/363003/d-2" target="_blank">Linux Server</a>|</li>
<li><a href="http://yuanbin.blog.51cto.com/363003/d-3" target="_blank">Windows System</a>|</li>
<li><a href="http://yuanbin.blog.51cto.com/363003/d-4" target="_blank">Windows Server</a>|</li>
<li><a href="http://yuanbin.blog.51cto.com/363003/d-5" target="_blank">网络技术</a>|</li>
<li><a href="http://yuanbin.blog.51cto.com/363003/d-6" target="_blank">生活</a></li>
</ul>
<h2 id="-yuanbin0710-blog"><strong>yuanbin0710</strong> 的BLOG</h2>
<p><img src="" alt=""></p>
<p><a href="http://home.51cto.com/index.php?s=/space/363003#message" target="_blank">写留言</a><a href="http://g.51cto.com/addgroup.php?uid=" target="_blank">邀请进圈子</a><a href="http://home.51cto.com/index.php?s=/Notify/write/uid/363003" target="_blank">发消息</a> <a href="">加友情链接</a><a href="http://home.51cto.com/index.php?s=/space/363003" target="_blank">进家园 加好友</a>
2012年度IT博客大赛
<a href="http://blog.51cto.com/contest2012/#top10000" target="_blank">十大杰出IT博客诞生</a></p>
<p><a href="http://blog.51cto.com/contest2012/" target="_blank"><img src="" alt=""></a></p>
<h2 id="-">博客统计信息</h2>
<p><a href="http://blog.51cto.com/blogcommend" target="_blank"><strong>51CTO推荐博客</strong></a>
用户名：yuanbin0710
文章数：37
评论数：166
访问量：279930
<a href="http://home.51cto.com/index.php?s=/Account/credit" target="_blank">无忧币</a>：20
<a href="http://51ctoblog.blog.51cto.com/26414/5591" target="_blank">博客积分</a>：1338
<a href="http://51ctoblog.blog.51cto.com/26414/5591" target="_blank">博客等级</a>：4
注册日期：2008-04-17</p>
<h2 id="-">热门专题</h2>
<p><a href="http://blog.51cto.com/zt" target="_blank">更多&gt;&gt;</a></p>
<p><a href="http://blog.51cto.com/zt/546" target="_blank"><img src="" alt=""></a> <a href="http://blog.51cto.com/zt/546" title="RHEL6从零基础到熟练使用" target="_blank">RHEL6从零基础到熟练使用</a> 阅读量：8542</p>
<p><a href="http://blog.51cto.com/zt/549" target="_blank"><img src="" alt=""></a> <a href="http://blog.51cto.com/zt/549" title="VMware5.5从零开始学起" target="_blank">VMware5.5从零开始学起</a> 阅读量：3326
<a href="http://blog.51cto.com/zt/547" target="_blank"><img src="" alt=""></a> <a href="http://blog.51cto.com/zt/547" title=" Hyper-V 3.0功能部署" target="_blank">Hyper-V 3.0功能部署</a> 阅读量：2014</p>
<p><a href="http://blog.51cto.com/zt/550" target="_blank"><img src="" alt=""></a> <a href="http://blog.51cto.com/zt/550" title="Windows Server入门教程" target="_blank">Windows Server入门教程</a> 阅读量：4726</p>
<h2 id="-">热门文章</h2>
<ul>
<li><a href="http://yuanbin.blog.51cto.com/363003/110825" target="_blank">DDNS配置实例（DHCP+DNS=..</a></li>
<li><a href="http://yuanbin.blog.51cto.com/363003/108572" target="_blank">BIND配置文件详解（一）</a></li>
<li><a href="http://yuanbin.blog.51cto.com/363003/117105" target="_blank">SWAT—Samba WEB管..</a></li>
<li><a href="http://yuanbin.blog.51cto.com/363003/108578" target="_blank">BIND配置文件详解（二）</a></li>
<li><a href="http://yuanbin.blog.51cto.com/363003/129071" target="_blank">两种方式建立Vsftpd虚拟用户</a></li>
<li><a href="http://yuanbin.blog.51cto.com/363003/115761" target="_blank">Samba配置文件常用参数详解</a></li>
<li><a href="http://yuanbin.blog.51cto.com/363003/112029" target="_blank">子网划分的两个例子</a></li>
<li><a href="http://yuanbin.blog.51cto.com/363003/129030" target="_blank">CentOS5启用Telnet服务详解</a><h2 id="-blog-">搜索BLOG文章</h2>
</li>
</ul>
<h2 id="-2-http-yuanbin-blog-51cto-com-mygroup-php-">我的技术圈(<a href="http://yuanbin.blog.51cto.com/mygroup.php" target="_blank"><strong>2</strong></a>)</h2>
<p><a href="http://home.51cto.com/apps/group/index.php?s=/Index/index/" target="_blank">更多&gt;&gt;</a></p>
<ul>
<li><a href="http://g.51cto.com/htbenet" target="_blank">北大青鸟benet网络工程师</a>  </li>
<li><p><a href="http://g.51cto.com/pro" target="_blank">IT pro</a>  </p>
<h2 id="-">最近访客</h2>
</li>
<li><p><a href="http://6601738.blog.51cto.com/" target="_blank"><img src="" alt=""></a></p>
</li>
</ul>
<p><a href="http://6601738.blog.51cto.com/" target="_blank">nj_ka..</a></p>
<ul>
<li><a href="http://huan108.blog.51cto.com/" target="_blank"><img src="" alt=""></a></li>
</ul>
<p><a href="http://huan108.blog.51cto.com/" target="_blank">huan108</a></p>
<ul>
<li><a href="http://902339.blog.51cto.com/" target="_blank"><img src="" alt=""></a></li>
</ul>
<p><a href="http://902339.blog.51cto.com/" target="_blank">doget</a></p>
<ul>
<li><a href="http://176650.blog.51cto.com/" target="_blank"><img src="" alt=""></a></li>
</ul>
<p><a href="http://176650.blog.51cto.com/" target="_blank">gaoti..</a></p>
<ul>
<li><a href="http://1433850.blog.51cto.com/" target="_blank"><img src="" alt=""></a></li>
</ul>
<p><a href="http://1433850.blog.51cto.com/" target="_blank">lonrn</a></p>
<ul>
<li><a href="http://3023685.blog.51cto.com/" target="_blank"><img src="" alt=""></a></li>
</ul>
<p><a href="http://3023685.blog.51cto.com/" target="_blank">wei13..</a></p>
<ul>
<li><a href="http://1055631.blog.51cto.com/" target="_blank"><img src="" alt=""></a></li>
</ul>
<p><a href="http://1055631.blog.51cto.com/" target="_blank">deeps..</a></p>
<ul>
<li><a href="http://championxie.blog.51cto.com/" target="_blank"><img src="" alt=""></a></li>
</ul>
<p><a href="http://championxie.blog.51cto.com/" target="_blank">champ..</a></p>
<ul>
<li><a href="http://1838662.blog.51cto.com/" target="_blank"><img src="" alt=""></a></li>
</ul>
<p><a href="http://1838662.blog.51cto.com/" target="_blank">flyer..</a></p>
<ul>
<li><a href="http://shitao123.blog.51cto.com/" target="_blank"><img src="" alt=""></a></li>
</ul>
<p><a href="http://shitao123.blog.51cto.com/" target="_blank">sht19..</a></p>
<ul>
<li><a href="http://7122578.blog.51cto.com/" target="_blank"><img src="" alt=""></a></li>
</ul>
<p><a href="http://7122578.blog.51cto.com/" target="_blank">浩临天下</a></p>
<ul>
<li><a href="http://489730.blog.51cto.com/" target="_blank"><img src="" alt=""></a></li>
</ul>
<p><a href="http://489730.blog.51cto.com/" target="_blank">登徒浪子</a></p>
<h2 id="-">最新评论</h2>
<ul>
<li><a href="http://8309257.blog.51cto.com/" target="_blank"><strong>eologo</strong></a>：<a href="http://yuanbin.blog.51cto.com/363003/110825" target="_blank">我没成功，请远程赐教，不胜感谢，..</a></li>
<li><a href="http://6718737.blog.51cto.com/" target="_blank"><strong>452165649</strong></a>：<a href="http://yuanbin.blog.51cto.com/363003/110825" target="_blank">我是在rh5.4上做的，为什么它不出现..</a></li>
<li><a href="http://jxcia.blog.51cto.com/" target="_blank"><strong>zhuyingkang</strong></a>：<a href="http://yuanbin.blog.51cto.com/363003/108359" target="_blank">博主还在么？能否看到我的留言？方..</a></li>
<li>[匿名]51cto游客：<a href="http://yuanbin.blog.51cto.com/363003/108359" target="_blank">我最近也在研究VSFTP，在根据楼主这..</a></li>
<li><a href="http://886201.blog.51cto.com/" target="_blank"><strong>happy2501</strong></a>：<a href="http://yuanbin.blog.51cto.com/363003/114207" target="_blank">您好，我按照您的做法做下来，测试..</a><h2 id="51cto-">51CTO推荐博文</h2>
</li>
</ul>
<p><a href="http://blog.51cto.com/artcommend" target="_blank">更多&gt;&gt;</a></p>
<ul>
<li><a href="http://mingwang.blog.51cto.com/1997299/1338756" title="用Windows Server 2012 R2 搭建二层证书服务结构 Part 1" target="_blank">用Windows Server 2012 R2 搭建二..</a></li>
<li><a href="http://ksyiwen.blog.51cto.com/2754337/1338850" title="TMG学习（六），发布内网多个Web站点" target="_blank">TMG学习（六），发布内网多个Web站点</a></li>
<li><a href="http://chenguang.blog.51cto.com/350944/1338882" title="实用防火墙（Iptables）脚本分析" target="_blank">实用防火墙（Iptables）脚本分析</a></li>
<li><a href="http://gtstorageworld.blog.51cto.com/908359/1339080" title="Hadoop迈入2.0时代 更适合企业应用" target="_blank">Hadoop迈入2.0时代 更适合企业应用</a></li>
<li><a href="http://itmydream.blog.51cto.com/961933/1339095" title="服务器（AD，DHCP，DNS，File）迁移案例" target="_blank">服务器（AD，DHCP，DNS，File）迁..</a></li>
<li><a href="http://rfyiamcool.blog.51cto.com/1030776/1339114" title="对于复杂流程确认的运维自动化方案的理解与探讨" target="_blank">对于复杂流程确认的运维自动化方..</a></li>
<li><a href="http://systema.blog.51cto.com/4037770/1338873" title="Office 365_邮件迁移之_直接转换迁移（CEM）" target="_blank">Office 365<em>邮件迁移之</em>直接转换..</a></li>
<li><a href="http://yaocoder.blog.51cto.com/2668309/1338567" title="网络编程释疑之：TCP的TIME_WAIT状态在服务器开发中的影响？" target="_blank">网络编程释疑之：TCP的TIME_WAIT..</a></li>
<li><a href="http://hucwuhen.blog.51cto.com/6253667/1338638" title="浅谈服务器被黑后的检查工作流程" target="_blank">浅谈服务器被黑后的检查工作流程</a></li>
<li><a href="http://magic3.blog.51cto.com/1146917/1337977" title="Backup Exec 2012  备份和还原活动目录(非授权还原)" target="_blank">Backup Exec 2012 备份和还原活..</a></li>
<li><a href="http://lixiaosong.blog.51cto.com/705126/1338148" title="AD 重置密码完整脚本" target="_blank">AD 重置密码完整脚本</a></li>
</ul>
<h2 id="-">友情链接</h2>
<ul>
<li><a href="http://lovesu.blog.51cto.com/" title="Bnsen" target="_blank">Bnsen</a></li>
<li><a href="http://jary3000.blog.51cto.com/" title="千山岛主之微软技术空间站" target="_blank">千山岛主之微软技..</a></li>
<li><a href="http://liuyu.blog.51cto.com/" title="seven" target="_blank">seven</a></li>
<li><a href="http://llk726.blog.51cto.com/" title="键盘人生" target="_blank">键盘人生</a></li>
<li><a href="http://kongming.blog.51cto.com/" title="祝孔明" target="_blank">祝孔明</a></li>
<li><a href="http://chenguang.blog.51cto.com/" title="李晨光" target="_blank">李晨光</a> <img src="" alt="三日内更新"></li>
<li><a href="http://baidu.blog.51cto.com/" title="秋日惜枫" target="_blank">秋日惜枫</a></li>
<li><a href="http://ming228.blog.51cto.com/" title="yangming.com" target="_blank">yangming.com</a></li>
<li><a href="http://redking.blog.51cto.com/" title="王乾De技术Blog" target="_blank">王乾De技术Blog</a></li>
<li><a href="http://idefeng.blog.51cto.com/" title="define_myself" target="_blank">define_myself</a></li>
<li><a href="http://xiaofw.blog.51cto.com/" title="社区大管家小废物" target="_blank">社区大管家小废物</a></li>
<li><a href="http://struggle.blog.51cto.com/" title="激情因梦想而存在" target="_blank">激情因梦想而存在</a></li>
<li><a href="http://yuelei.blog.51cto.com/" title="岳雷的微软网络课堂" target="_blank">岳雷的微软网络课堂</a></li>
<li><a href="http://huxiaoqiu.blog.51cto.com/" title="胡晓秋工作室" target="_blank">胡晓秋工作室</a></li>
<li><a href="http://51ctoblog.blog.51cto.com/" title="51CTO博客开发" target="_blank">51CTO博客开发</a></li>
</ul>
<p><a href="http://blog.51cto.com/contest2013/index.php?mod=userlist_third" target="_blank"><img src="" alt=""></a></p>
<p><a href="http://leonarding.blog.51cto.com/6045525/1335805" target="_blank">·【征文】聊IT运维标准化与安全，奖50元京东购物卡</a><a href="http://edu.51cto.com/lesson/id-58.html" target="_blank">·iOS企业级开发初级课程-UIView与控件(共20集 )</a><a href=""></a></p>
<p><a href="http://yuanbin.blog.51cto.com/all/363003" target="_blank">博主的更多文章&gt;&gt;</a></p>
<p><img src="" alt=""> 被动模式下FTP的详细工作过程 2008-10-25 20:03:53</p>
<p>标签：<a href="http://blog.51cto.com/tag-FTP.html" target="_blank">FTP</a> <a href="http://blog.51cto.com/tag-休闲.html" target="_blank">休闲</a> <a href="http://blog.51cto.com/tag-被动模式.html" target="_blank">被动模式</a> <a href="http://blog.51cto.com/tag-职场.html" target="_blank">职场</a> <a href="http://blog.51cto.com/tag-工作过程.html" target="_blank">工作过程</a>
原创作品，允许转载，转载时请务必以超链接形式标明文章 <a href="">原始出处</a> 、作者信息和本声明。否则将追究法律责任。<a href=""><a href="http://yuanbin.blog.51cto.com/363003/108009">http://yuanbin.blog.51cto.com/363003/108009</a></a></p>
<p><strong>文中有不对或者有不清楚的地方，请大家告诉我，谢谢！</strong></p>
<hr>
<p><strong>被动模式下FTP的详细工作过程</strong></p>
<p>PASV FTP在工作的第一步，与PORT FTP一样，会首先使用21端口建立控制连接；但在第二步，由FTP客户端主动发起建立数据传输连接请求，服务器的数据传输端口为随机端口，因此，每次建立的数据传输连接通道，服务器所使用的端口都不相同。</p>
<p>本示例客户端IP是192.168.120.168，服务器IP是192.168.120.240，因为客户端的MS-DOS不支持PASV模式，所以使用FlashFXP软件来连接服务器。通过抓包工具来查看用户从连接FTP服务器到退出FTP服务器经过的所有过程。
使用FlashFXP所做的操作：1.输入FTP服务器的IP，要登入的用户名和密码。2.进入用户家目录，查看.bashrc和.bash_profile两个文件。3.退出FTP。</p>
<p><strong>PASV FTP**</strong>的详细工作过程：**</p>
<p><strong>1.</strong> 因为FTP使用的是TCP协议，所以客户端FlashFXP在连接服务器192.168.120.240时，首先会经历TCP的三次握手来建立控制通道。客户端使用任意的端口N（&gt;1024）来连接FTP服务器默认的21端口。这和PORT模式一样。
<strong>2.</strong> 在TCP三次握手结束后，服务器端正式响应客户端的控制连接请求，控制通道建立。</p>
<p><strong>3.</strong> 客户端向服务器发送含有ACK的数据段来确认控制连接建立并发送用户名。
<strong>4.</strong> 服务器向客户端发送含有ACK的数据段来确认用户名。</p>
<p><strong>5.</strong> 服务器向客户端询问密码。
<strong>6.</strong> 客户端向服务器发送含有ACK的数据段来确认并发送密码，密码为明文。</p>
<p><strong>7.</strong> 服务器向客户端发送含有ACK的数据段来确认密码收到。
<strong>8.</strong> 服务器向客户端发送登陆成功的信息。</p>
<p><strong>9.</strong> 客户端向服务器发送含有ACK的数据段来确认并发送查询系统类型的指令（见图一）。
<strong>10.</strong> 服务器向客户端发送含有ACK的数据段来确认收到指令。</p>
<p><strong>11.</strong> 服务器向客户端回应系统的类型为UNIX（见图二）。
<strong>12.</strong> 客户端向服务器发送列出服务器的所有扩展命令和扩展功能的指令（见图三）。</p>
<p><strong>13.</strong> 服务器响应客户端的FEAT请求（见图四）。
<strong>14.</strong> 服务器响应客户端有EPSV（扩展PASV，支持非IPV4）的扩展功能（见图五）。</p>
<p><strong>15.</strong> 客户端向服务器发送含有ACK的数据段来确认收到信息。
<strong>16.</strong> 服务器响应客户端自己的其他特性（见图六）。MDTM：保留下载文件的日期/时间；REST STREAM：重设文件传输方式为stream形式。</p>
<p><strong>17.</strong> 客户端确认收到服务器的信息。
<strong>18.</strong> 服务器响应客户端进入到用户的家目录（见图七）。</p>
<p><strong>19.</strong> 客户端确认收到服务器的信息。
<strong>20.</strong> 客户端向服务器发送文件传输使用何种模式（Binary、ASCII）的指令（见图八）。</p>
<p><strong>21.</strong> 服务器回应客户端使用Binary模式（见图九）。
<strong>22.</strong> 客户端向服务器询问.bashrc文件的大小（见图十）。</p>
<p><strong>23.</strong> 服务器回应客户端.bashrc文件的大小为124字节（见图十一）。
<strong>24.</strong> 客户端向服务器发出PASV的指令（用来进行数据传输）（见图十二）。</p>
<p><strong>25.</strong> 服务器回应客户端使用PASV模式，并且商量数据传输端口用232x256+151=59543（见图十三）。
<strong>26.</strong> 客户端主动使用N+1端口来连接服务器的59543端口，并且向服务器发送含有SYN的数据段来开始进行数据传输连接的第1次握手（见图十四）。</p>
<p><strong>27.</strong> 服务器向客户端发送含有SYN和ACK的数据段来进行第2次握手（见图十五）。
<strong>28.</strong> 客户端向服务器发送含有ACK的数据段来进行第3次握手（见图十六）。</p>
<p><strong>29.</strong> 3次握手过程完成，客户端向服务器发送查看.bashrc文件的指令（见图十七）。
<strong>30.</strong> 服务器回应客户端使用Binary数据传输模式连接.bashrc文件（见图十八）。</p>
<p><strong>31.</strong> 服务器开始进行数据传输。
<strong>32.</strong> 服务器确定数据传输完毕，然后向客户端发送含有FIN和ACK的数据段来请求断开本次数据连接，第1次断开（见图十九）。</p>
<p><strong>33.</strong> 客户端向服务器发送含有ACK的数据段答应服务器的断接请求，第2次断开（见图二十）。
<strong>34.</strong> 服务器响应客户端文件发送完成的信息（见图二十一）。</p>
<p><strong>35.</strong> 客户端向服务器发送含有ACK的数据段来确认收到信息。
<strong>36.</strong> 客户端向服务器发送含有FIN和ACK的数据段来请求断开客户端到服务器之间的数据连接，第3次断开（见图二十二）。</p>
<p><strong>37.</strong> 服务器向客户端发送含有ACK的数据段确认断开连接，第4次断开（见图二十三）
<strong>38.</strong> 接下来是查看.bash_profile文件的过程。其过程和查看.bashrc文件的过程一样（在此不详述了），只是服务器和客户端的数据传输端口变了。服务器的数据传输端口是随机的；客户端的数据传输端口是N+2。</p>
<p><strong>39.</strong> 客户端在查看完.bash_profile文件并彻底完成该次数据连接的4次断开后，向服务器发送退出的指令（见图二十四）。
<strong>40.</strong> 服务器响应客户端的退出请求（见图二十五）。</p>
<p><strong>41.</strong> 服务器向客户端发送含有FIN和ACK的数据段，请求断开控制连接（见图二十六）。这是第一次断开控制连接。
<strong>42.</strong> 客户端向服务器发送含有ACK的数据段来应答服务器的断接请求（见图二十七）。这是第二次断开控制连接。</p>
<p><strong>43.</strong> 客户端向服务器发送含有FIN和ACK的数据段，请求断开到服务器之间的控制连接（见图二十八）。这是第三次断开控制连接。
<strong>44.</strong> 服务器向客户端发送含有ACK的数据段，来确认客户端的断接请求（见图二十九）。这样本次FTP控制连接完全断开。</p>
<p><strong>通过查看本次示例（被动FTP）的详细过程，我们可以得到以下几点结果：</strong></p>
<p><strong>1.</strong> 服务器的控制连接端口为21，数据传输端口随机（&gt;1024）并且每次的数据传输端口都不一样。
<strong>2.</strong> 客户端的控制连接端口为N（&gt;1024），数据传输端口在第一次进行数据传输时为N+1,在第二次数据传输时为N+2，依次类推。</p>
<p><strong>3.</strong> 服务器主动告诉客户端自己的数据传输端口。
<strong>4.</strong> 客户端主动用数据传输端口N+x去连接服务器的随机数据传输端口。</p>
<p><strong>5.</strong> 在一次FTP连接的过程中，只有一次控制连接，却可以有多次数据传输连接。
<strong>6.</strong> 不管是控制连接还是数据传输连接，在每次从建立到完成都需要经过3次连接和4次断开的过程。（这符合TCP协议的要求）</p>
<p><strong>本文档使用的图例：</strong></p>
<p><a href="http://img1.51cto.com/attachment/200810/25/363003_1224935974PU0j.gif" target="_blank"><img src="" alt="11"></a> 
图一：客户端发送查询系统类型的指令</p>
<p><a href="http://img1.51cto.com/attachment/200810/25/363003_1224935976j9JR.jpg" target="_blank"></a><a href="http://img1.51cto.com/attachment/200810/25/363003_1224935977k2F8.gif"><img src="" alt="13"></a></p>
<p>图二：服务器响应客户端系统类型为UNIX</p>
<p><a href="http://img1.51cto.com/attachment/200810/25/363003_1224935978q1o9.gif" target="_blank"><img src="" alt="14"></a>
图三：客户端请求服务器列出它的所有扩展命令和扩展功能</p>
<p><a href="http://img1.51cto.com/attachment/200810/25/363003_1224935983sdRz.gif" target="_blank"><img src="" alt="15"></a></p>
<p>图四：服务器响应客户端的FEAT请求</p>
<p><a href="http://img1.51cto.com/attachment/200810/25/363003_1224936006Aznp.gif" target="_blank"><img src="" alt="16"></a>
图五：服务器响应客户端有EPSV（扩展PASV，支持非IPV4）的扩展功能</p>
<p><a href="http://img1.51cto.com/attachment/200810/25/363003_12249360074yJ5.gif" target="_blank"><img src="" alt="18"></a></p>
<p>图六：服务器响应客户端自己支持的其他特性</p>
<p><a href="http://img1.51cto.com/attachment/200810/25/363003_1224936015iZgn.gif" target="_blank"><img src="" alt="20"></a>
图七：服务器响应客户端进入到用户家目录</p>
<p><a href="http://img1.51cto.com/attachment/200810/25/363003_1224936017ZmNc.gif" target="_blank"><img src="" alt="22"></a></p>
<p>图八：客户端向服务器询问文件传输的模式</p>
<p><a href="http://img1.51cto.com/attachment/200810/25/363003_1224936018IMjR.gif" target="_blank"><img src="" alt="23"></a>
图九：服务器响应客户端使用Binary模式</p>
<p><a href="http://img1.51cto.com/attachment/200810/25/363003_1224936020hNul.gif" target="_blank"><img src="" alt="24"></a></p>
<p>图十：客户端向服务器询问.bashrc文件的大小</p>
<p><a href="http://img1.51cto.com/attachment/200810/25/363003_1224936022sj6P.gif" target="_blank"><img src="" alt="25"></a>
图十一：服务器回应客户端.bashrc文件的大小为124字节</p>
<p><a href="http://img1.51cto.com/attachment/200810/25/363003_12249360237iAu.gif" target="_blank"><img src="" alt="26"></a></p>
<p>图十二：客户端向服务器发送PASV指令</p>
<p><a href="http://img1.51cto.com/attachment/200810/25/363003_12249361801LGh.gif" target="_blank"><img src="" alt="27"></a>
图十三：服务器响应客户端使用PASV模式，并且商量数据传输端口用59543</p>
<p><a href="http://img1.51cto.com/attachment/200810/25/363003_1224936181n4nW.gif" target="_blank"><img src="" alt="28"></a></p>
<p>图十四：第一次数据传输连接之第一次握手</p>
<p><a href="http://img1.51cto.com/attachment/200810/25/363003_122493618223uT.gif" target="_blank"><img src="" alt="29"></a>
图十五：第一次数据传输连接之第二次握手</p>
<p><a href="http://img1.51cto.com/attachment/200810/25/363003_1224936183BjjV.gif" target="_blank"><img src="" alt="30"></a></p>
<p>图十六：第一次数据传输连接之第三次握手</p>
<p><a href="http://img1.51cto.com/attachment/200810/25/363003_1224936185srsz.gif" target="_blank"><img src="" alt="31"></a>
图十七：客户端向服务器发送查看.bashrc文件的指令</p>
<p><a href="http://img1.51cto.com/attachment/200810/25/363003_1224936186ZS1w.gif" target="_blank"><img src="" alt="32"></a></p>
<p>图十八：服务器响应客户端使用Binary数据传输模式来连接.bashrc文件</p>
<p><a href="http://img1.51cto.com/attachment/200810/25/363003_1224936188Q6dX.gif" target="_blank"><img src="" alt="34"></a>
图十九：服务器发送FIN和ACK请求断开本次数据连接（第1次断开）</p>
<p><a href="http://img1.51cto.com/attachment/200810/25/363003_1224936210T20g.gif" target="_blank"><img src="" alt="35"></a></p>
<p>图二十：客户端发送ACK答应服务器的请求（第2次断开）</p>
<p><a href="http://img1.51cto.com/attachment/200810/25/363003_1224936213ulWM.gif" target="_blank"><img src="" alt="36"></a>
图二十一：服务器响应客户端文件发送完毕的信息</p>
<p><a href="http://img1.51cto.com/attachment/200810/25/363003_1224936217J6aY.gif" target="_blank"><img src="" alt="38"></a></p>
<p>图二十二：客户端向服务器发送含有FIN和ACK的数据段请求断开数据连接（第3次断开）</p>
<p><a href="http://img1.51cto.com/attachment/200810/25/363003_1224936218Leca.gif" target="_blank"><img src="" alt="39"></a>
图二十三：服务器向客户端发送含有ACK的数据段确认断开连接（第4次断开）</p>
<p><a href="http://img1.51cto.com/attachment/200810/25/363003_1224936220HQq5.gif" target="_blank"><img src="" alt="56"></a></p>
<p>图二十四：客户端向服务器发出退出的指令</p>
<p><a href="http://img1.51cto.com/attachment/200810/25/363003_1224936221ejql.gif" target="_blank"><img src="" alt="57"></a>
图二十五：服务器响应客户端的退出请求</p>
<p><a href="http://img1.51cto.com/attachment/200810/25/363003_1224936223xMjK.gif" target="_blank"><img src="" alt="58"></a></p>
<p>图二十六：服务器向客户端发送FIN和ACK请求断开控制连接（第1次断开）</p>
<p><a href="http://img1.51cto.com/attachment/200810/25/363003_12249362249BCE.gif" target="_blank"><img src="" alt="59"></a>
图二十七：客户端向服务器发送ACK答应服务器请求（第2次断开）</p>
<p><a href="http://img1.51cto.com/attachment/200810/25/363003_1224936225gvOK.gif" target="_blank"><img src="" alt="60"></a></p>
<p>图二十八：客户端向服务器发送FIN和ACK请求断开控制连接（第3次断开）</p>
<p><a href="http://img1.51cto.com/attachment/200810/25/363003_1224936226MLVx.gif" target="_blank"><img src="" alt="61"></a>
图二十九：服务器向客户端发送ACK答应断开控制连接（第4次断开）</p>
<p><a href="http://img1.51cto.com/attachment/200810/25/363003_1224936227MSuY.gif" target="_blank"><img src="" alt="62"></a></p>
<p>图三十：本次示例全部过程</p>
<p>本文档完整的图例，请见附件。</p>
<p>本文出自 “<a href="http://yuanbin.blog.51cto.com" target="_blank">大浪淘沙</a>” 博客，请务必保留此出处<a href="http://yuanbin.blog.51cto.com/363003/108009" target="_blank"><a href="http://yuanbin.blog.51cto.com/363003/108009">http://yuanbin.blog.51cto.com/363003/108009</a></a>
<img src="" alt="分享至"> <a href="&quot;分享到新浪微博&quot;"></a> <a href="&quot;分享到QQ空间&quot;"></a> <a href="&quot;分享到腾讯微博&quot;"></a> <a href="&quot;分享到百度搜藏&quot;"></a> <a href="&quot;分享到人人网&quot;"></a> <a href="&quot;分享到QQ收藏&quot;"></a> <a href="&quot;分享到豆瓣网&quot;"></a> <a href="&quot;分享到百度空间&quot;"></a> <a href="&quot;分享到MSN&quot;"></a> ** 更多 <a href="&quot;累计分享0次&quot;">0</a> <a href="&quot;一键收藏，随时查看，分享好友！&quot;"><img src="" alt="一键收藏，随时查看，分享好友！"></a></p>
<p><img src="" alt=""> <a href="">cccc0912</a> 1人 了这篇文章
<strong>附件下载：</strong>
<a href=""><img src="" alt="">FTP被动模式详细工作过程（图例）</a></p>
<p>类别：<a href="http://yuanbin.blog.51cto.com/363003/d-2" target="_blank">Linux Server</a>┆<a href="">技术圈</a>(0)┆阅读(2046)┆评论(2) ┆ <a href="">推送到技术圈</a>┆<a href="">返回首页</a>
上一篇 <a href="http://yuanbin.blog.51cto.com/363003/107672" title="主动模式下FTP的详细工作过程" target="_blank">主动模式下FTP的详细工作过程</a> 下一篇 <a href="http://yuanbin.blog.51cto.com/363003/108014" title="FTP总结" target="_blank">FTP总结</a>
<a href="http://blog.51cto.com/contest2013/index.php?mod=userlist_top50" target="_blank"><img src="" alt=""></a></p>
<h2 id="-">相关文章</h2>
<ul>
<li><a href="http://nickzp.blog.51cto.com/12728/39642" title="FTP主动模式及被动模式" target="_blank">FTP主动模式及被动模式</a></li>
<li><a href="http://yuanbin.blog.51cto.com/363003/107672" title="主动模式下FTP的详细工作过程" target="_blank">主动模式下FTP的详细工作过程</a></li>
<li><a href="http://xwnet.blog.51cto.com/233677/95182" title="FTP上传文件经常中断或超时的解决方案" target="_blank">FTP上传文件经常中断或超时的解决方案</a></li>
<li><a href="http://heyiyi.blog.51cto.com/205455/104282" title="RedHat AS 4 下架设FTP服务器" target="_blank">RedHat AS 4 下架设FTP服务器</a></li>
<li><a href="http://zhouhaipeng.blog.51cto.com/447669/91890" title="ftp命令大全" target="_blank">ftp命令大全</a></li>
<li><a href="http://userli.blog.51cto.com/45840/68768" title="『第9天』从FTP入侵到SQL" target="_blank">『第9天』从FTP入侵到SQL</a></li>
<li><a href="http://tempcom.blog.51cto.com/475758/106600" title="Ubuntu实用简单的FTP架设" target="_blank">Ubuntu实用简单的FTP架设</a></li>
<li><a href="http://22494.blog.51cto.com/12494/19269" title="Serv-U FTP之PASV和PORT模式" target="_blank">Serv-U FTP之PASV和PORT模式</a></li>
<li><a href="http://recordtrip.blog.51cto.com/346611/100469" title="2003server 搭建FTP服务器 不能下载文件问题" target="_blank">2003server 搭建FTP服务器 不能下载文件问题</a></li>
<li><a href="http://chuan.blog.51cto.com/130796/58481" title="FTP组隔离用户" target="_blank">FTP组隔离用户</a>
<a href=""></a></li>
</ul>
<h2 id="-">文章评论</h2>
<p> <a href=""></a></p>
<p>[1楼]    <img src="" alt="">  [匿名]yangming1052 <a href="">回复</a></p>
<p>2008-10-27 11:17:13
不错 学习了。。
<a href=""></a></p>
<p>[2楼]    <img src="" alt="">  <a href="http://xiaofang1213.blog.51cto.com/" target="_blank"><strong>小芳1213</strong></a> <a href="">回复</a></p>
<p>2010-09-21 08:25:03
很不错噢。</p>
<p> <a href=""></a></p>
<p><a href=""></a></p>
<h2 id="-">发表评论</h2>
<p><a href="http://blog.51cto.com/newsletter/230/" target="_blank">周刊：IT行业盲目涨工资比房产泡沫更危险？</a>
昵  称： <a href="http://home.51cto.com/index.php?reback=http://yuanbin.blog.51cto.com/363003/108009" target="_blank">登录</a>  <a href="http://ucenter.51cto.com/reg_01.php?reback=http://blog.51cto.com" target="_blank">快速注册</a> 验证码： <img src="" alt=""></p>
<p>点击图片可刷新验证码请点击后输入验证码<a href="http://51ctoblog.blog.51cto.com/26414/5591" target="_blank">博客过2级，无需填写验证码</a> 内  容：</p>
<p>同时赞一个
返回顶部</p>
<p>Copyright By 51CTO.COM 版权所有
<a href="http://blog.51cto.com/" target="_blank"><img src="" alt=""></a>
<a href="http://www.cnzz.com/stat/website.php?web_id=4274540" title="站长统计" target="_blank"><img src="" alt=""></a></p>
<p>附件下载<a href="">close</a></p>
<p>请输入验证码：
<img src="&quot;单击更换验证码！&quot;" alt="">
确认</p>

      
    </div>
    
    
      
    
    
        <footer id="post-meta">
        <span class="categories">Posted in<span class="breadcrumb fa fa-folder"><li><a href="/categories/ftp/">ftp</a></li></span></span> | <span class="tags">Tagged <a href="/tags/ftp/" class="label label-primary">ftp</a></span> | <span class="time">recent updated:<time title="2014-03-07 09:54:45"datetime="2014-03-07 09:54:45"> mar. 7 2014</time></span> | <span class="comment-link">
<a href="http://itsolife.com/2014/02/02/2014-02-02-ftp--被动模式下FTP的详细工作过程-大浪淘沙-51CTO技术博客/#comments" class="ds-thread-count comment-link" data-thread-key="2014-02-02-ftp--被动模式下FTP的详细工作过程-大浪淘沙-51CTO技术博客" data-count-type="comments">暂无评论</a></span>
        </footer>
    
    <div class="clearfix"></div>
  </div>
</div>
</article>





<ul id="pagination" class="pagination pagination-lg">
  <li><a class="extend prev" href="/page/6/">&laquo;</a></li><li><a class="page-number" href="/">1</a></li><li><a class="page-number" href="/page/2/">2</a></li><li><span class="space">&hellip;</span></li><li><a class="page-number" href="/page/4/">4</a></li><li><a class="page-number" href="/page/5/">5</a></li><li><a class="page-number" href="/page/6/">6</a></li><li class="active"><li><span class="page-number current">7</span></li><li><a class="page-number" href="/page/8/">8</a></li><li><a class="page-number" href="/page/9/">9</a></li><li><a class="page-number" href="/page/10/">10</a></li><li><span class="space">&hellip;</span></li></li><li><a class="page-number" href="/page/164/">164</a></li><li><a class="page-number" href="/page/165/">165</a></li><li><a class="extend next" href="/page/8/">&raquo;</a></li>
  <div class="clearfix"></div>
</ul></div><!--wapper-->
       </div><!-- ID main-col END -->
       <aside id="sidebar" class="alignright col-sx-6 col-sm-4 col-md-3 col-lg-3">
<div id="widget_search" class="widget panel panel-primary">
    <form action="//google.com/search" method="get" accept-charset="utf-8">
  <div class="input-group">
    <input class="form-control" id="searchbox" type="search" name="q" results="0" placeholder="search">
    <span class="input-group-btn">
      <button class="btn btn-default" type="submit">Go!</button>
    </span>
    <input type="hidden" name="q" value="site:itsolife.com">
  </div>
</form>
</div>

<div id="widget_category" class="widget panel panel-primary">
  <div class="panel-heading">category</div>  <div data-src='category' class='ajax_widgets'>正在加载...</div>
</div>

<div id="widget_recent_posts" class="widget panel panel-primary">
  <div class="panel-heading">recent posts</div>  <div data-src='recent_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_tagcloud" class="widget panel panel-primary">
  <div class="panel-heading">tagcloud</div>  <div data-src='tagcloud' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_latest_update_posts" class="widget panel panel-primary">
  <div class="panel-heading">最近更新</div>  <div data-src='latest_update_posts' class='ajax_widgets'>正在加载...</div></div>

<div id="widget_recent_comments" class="widget panel panel-primary">
  <div class="panel-heading">recent comments</div>  

<div class="list-group-item ds-recent-comments" data-num-items="6" data-show-avatars="1" data-show-time="1" data-show-title="1" data-show-admin="1" data-excerpt-length="50"></div>



</div>

</aside>
       <div class="clearfix"></div>
     </div><!-- row END -->
  </div>
  <footer id="footer" class="container">
  <div class="panel panel-info">
  <section id='footer_widget'></section>  <div class="panel-footer">
  <div id="site-info">
    <span class='author'>
  
  &copy; 2014 RobinChia
  
    &nbsp;&nbsp;</span>
  
  <span id='analytics-51la'></span><span id='analytics-google'>
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-48559895-1']);
  _gaq.push(['_trackPageview']);
  _js2load.push({src:('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'});
</script></span><span id='analytics-cnzz'>
<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_5774006'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s17.cnzz.com/stat.php%3Fid%3D5774006%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>
</span><span id='analytics-baidu'>
<script>
var _hmt = _hmt || [];
_js2load.push({src:"//hm.baidu.com/hm.js?1442f50724afc42380b51f097c43082c"});
</script>
</span>  </div>
  <div id="copyright">Blog powered by <a href='http://zespia.tw/hexo/'><strong>hexo</strong></a> Theme <strong><a href='https://github.com/chenall/hexo-theme-chenall'>chenall</a></strong>(Some change in it)<span class="pull-right"> 更新时间: <em>2014-03-15 16:43:39</em></span></div>
</div>
<div class="clearfix"></div>


  </div>
  </footer>
  
        <script src="http://cdn.bootcss.com/jquery/1.10.2/jquery.min.js"></script>        
        <script src="http://cdn.staticfile.org/twitter-bootstrap/3.1.0/js/bootstrap.min.js"></script>        
                
        <script src="http://cdn.bootcss.com/prettify/r298/prettify.min.js"></script>    <script type="text/javascript">
   var lang=["bsh", "c", "cc", "cpp", "cs", "csh", "cyc", "cv", "htm", "html",
    "java", "js", "m", "mxml", "perl", "pl", "pm", "py", "rb", "sh",
    "xhtml", "xml", "xsl"];
   var pretty_base='';
   $('script').each(function(){
	var c = $(this).attr('src');
	if (!c)
	    return;
	if (c.match(/(\/)?prettify(\.min)?\.js/i))
	{
	    var index = c.lastIndexOf('/');
	    if (index != -1)
		pretty_base = c.substr(0,index + 1);
	    return false;
	}
   })
   $('pre code').each(function(){
	var c = $(this).attr('class')
	if (!c)
	    return;
	c = c.match(/\s?(lang\-\w+)/i);
	if (c && lang.indexOf(c[1]) == -1)
	{
	    lang.push(c[1]);
	    $.getScript(pretty_base + c[1] + '.min.js');
	}
   })

    $(window).load(function(){
       $("pre").addClass("prettyprint");
       prettyPrint();
    })
</script>    
            <script type="text/javascript">
var duoshuoQuery = {short_name:"robinchia"};
_js2load.push({src:'http://static.duoshuo.com/embed.js',charset:'UTF-8'});
</script>
    
            <!--wumii_relatedItems-->
    
        <script src="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js"></script>    <script type="text/javascript">
(function($){
  $('.entry').each(function(i){
    $(this).find('img').each(function(){
      var alt = this.alt;

      if (alt){
        $(this).before('<span class="caption">' + alt + '</span>');
      }

      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox" rel="fancybox' + i + '" />');
    });
  });

  $('.fancybox').fancybox();
})(jQuery);
</script>    
        <script src="http://cdn.bootcss.com/mathjax/2.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>    <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>
    
<script type="text/javascript">
$('.ajax_widgets').each(function(){var src=$(this).attr('data-src');if(src)$(this).load('/widgets/'+src+'.html');});
$.each(_js2load,function(index,obj){loadjs(obj.src,obj.charset)});
</script>

<div id="scroll2top">
<img src="/scroll2top/arrow.png"/>
</div>
<script src="/scroll2top/scroll2top.min.js"></script>
<div id="winterland">
  <canvas></canvas>
</div>
<script src="/js/winterland.min.js"></script>

  </body>
</html>
